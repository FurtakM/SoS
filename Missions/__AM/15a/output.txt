// starting begin ResetFog ;
   0: CALL_OW 335
// AnimateTrees ( true ) ;
   4: LD_INT 1
   6: PPUSH
   7: CALL_OW 573
// InitVariables ;
  11: CALL 73 0 0
// InitGlobalVariables ;
  15: CALL 21232 0 0
// InitMacro ;
  19: CALL 21400 0 0
// InitNature ;
  23: CALL 17898 0 0
// InitArtifact ;
  27: CALL 18515 0 0
// if debug then
  31: LD_EXP 1
  35: IFFALSE 44
// FogOff ( 1 ) ;
  37: LD_INT 1
  39: PPUSH
  40: CALL_OW 344
// PrepareAmerican ;
  44: CALL 5067 0 0
// PrepareAlliance ;
  48: CALL 1444 0 0
// PrepareArabian ;
  52: CALL 6839 0 0
// PrepareRussian ;
  56: CALL 8848 0 0
// PrepareLegion ;
  60: CALL 7271 0 0
// Action ;
  64: CALL 11443 0 0
// MC_Start ( ) ;
  68: CALL 23565 0 0
// end ;
  72: END
// export debug ; export russianDestroyed , legionDestroyed , americanDestroyed , arabianDestroyed ; export americanCapitulated , russianCapitulated , legionCapitulated ; export artifactArCaptured , alienSpotted , spawnOmar ; export artifactIResearched , artifactIIResearched , artifactIIIResearched ; export vehicleLostCounter , artifactDestroyCounter ; export allianceTeam , arabianAttacked ; export function InitVariables ; begin
  73: LD_INT 0
  75: PPUSH
// debug := false ;
  76: LD_ADDR_EXP 1
  80: PUSH
  81: LD_INT 0
  83: ST_TO_ADDR
// artifactArCaptured := LoadVariable ( 11_artifact_captured , 0 ) ;
  84: LD_ADDR_EXP 9
  88: PUSH
  89: LD_STRING 11_artifact_captured
  91: PPUSH
  92: LD_INT 0
  94: PPUSH
  95: CALL_OW 30
  99: ST_TO_ADDR
// russianDestroyed := false ;
 100: LD_ADDR_EXP 2
 104: PUSH
 105: LD_INT 0
 107: ST_TO_ADDR
// legionDestroyed := false ;
 108: LD_ADDR_EXP 3
 112: PUSH
 113: LD_INT 0
 115: ST_TO_ADDR
// americanDestroyed := false ;
 116: LD_ADDR_EXP 4
 120: PUSH
 121: LD_INT 0
 123: ST_TO_ADDR
// arabianDestroyed := false ;
 124: LD_ADDR_EXP 5
 128: PUSH
 129: LD_INT 0
 131: ST_TO_ADDR
// americanCapitulated := false ;
 132: LD_ADDR_EXP 6
 136: PUSH
 137: LD_INT 0
 139: ST_TO_ADDR
// russianCapitulated := false ;
 140: LD_ADDR_EXP 7
 144: PUSH
 145: LD_INT 0
 147: ST_TO_ADDR
// legionCapitulated := false ;
 148: LD_ADDR_EXP 8
 152: PUSH
 153: LD_INT 0
 155: ST_TO_ADDR
// artifactIResearched := false ;
 156: LD_ADDR_EXP 12
 160: PUSH
 161: LD_INT 0
 163: ST_TO_ADDR
// artifactIIResearched := false ;
 164: LD_ADDR_EXP 13
 168: PUSH
 169: LD_INT 0
 171: ST_TO_ADDR
// artifactIIIResearched := false ;
 172: LD_ADDR_EXP 14
 176: PUSH
 177: LD_INT 0
 179: ST_TO_ADDR
// alienSpotted := false ;
 180: LD_ADDR_EXP 10
 184: PUSH
 185: LD_INT 0
 187: ST_TO_ADDR
// spawnOmar := false ;
 188: LD_ADDR_EXP 11
 192: PUSH
 193: LD_INT 0
 195: ST_TO_ADDR
// vehicleLostCounter := 0 ;
 196: LD_ADDR_EXP 15
 200: PUSH
 201: LD_INT 0
 203: ST_TO_ADDR
// artifactDestroyCounter := 0 ;
 204: LD_ADDR_EXP 16
 208: PUSH
 209: LD_INT 0
 211: ST_TO_ADDR
// allianceTeam := [ ] ;
 212: LD_ADDR_EXP 17
 216: PUSH
 217: EMPTY
 218: ST_TO_ADDR
// arabianAttacked := false ;
 219: LD_ADDR_EXP 18
 223: PUSH
 224: LD_INT 0
 226: ST_TO_ADDR
// end ;
 227: LD_VAR 0 1
 231: RET
// export function CustomInitMacro ( ) ; begin
 232: LD_INT 0
 234: PPUSH
// mc_parking := [ arabianParkingArea , russianParkingArea , legionParkingArea , powellParking ] ;
 235: LD_ADDR_EXP 119
 239: PUSH
 240: LD_INT 26
 242: PUSH
 243: LD_INT 1
 245: PUSH
 246: LD_INT 4
 248: PUSH
 249: LD_INT 8
 251: PUSH
 252: EMPTY
 253: LIST
 254: LIST
 255: LIST
 256: LIST
 257: ST_TO_ADDR
// mc_scan_area := [ arabianBaseArea , russianBaseArea , legionBaseArea , powellBase ] ;
 258: LD_ADDR_EXP 120
 262: PUSH
 263: LD_INT 27
 265: PUSH
 266: LD_INT 2
 268: PUSH
 269: LD_INT 3
 271: PUSH
 272: LD_INT 7
 274: PUSH
 275: EMPTY
 276: LIST
 277: LIST
 278: LIST
 279: LIST
 280: ST_TO_ADDR
// MC_SetMinesField ( 1 , [ 6 , 7 , 9 , 10 ] [ Difficulty ] , arabianMinefield ) ;
 281: LD_INT 1
 283: PPUSH
 284: LD_INT 6
 286: PUSH
 287: LD_INT 7
 289: PUSH
 290: LD_INT 9
 292: PUSH
 293: LD_INT 10
 295: PUSH
 296: EMPTY
 297: LIST
 298: LIST
 299: LIST
 300: LIST
 301: PUSH
 302: LD_OWVAR 67
 306: ARRAY
 307: PPUSH
 308: LD_INT 28
 310: PPUSH
 311: CALL 45254 0 3
// MC_SetLabKind ( 1 , [ b_lab_weapon , b_lab_siberium , b_lab_biological , b_lab_opto ] ) ;
 315: LD_INT 1
 317: PPUSH
 318: LD_INT 10
 320: PUSH
 321: LD_INT 11
 323: PUSH
 324: LD_INT 13
 326: PUSH
 327: LD_INT 15
 329: PUSH
 330: EMPTY
 331: LIST
 332: LIST
 333: LIST
 334: LIST
 335: PPUSH
 336: CALL 46314 0 2
// MC_SetCratesArea ( 1 , [ arabianCratesArea ] ) ;
 340: LD_INT 1
 342: PPUSH
 343: LD_INT 29
 345: PUSH
 346: EMPTY
 347: LIST
 348: PPUSH
 349: CALL 46407 0 2
// mc_ape := Replace ( mc_ape , 1 , FilterAllUnits ( [ [ f_side , 2 ] , [ f_class , class_apeman_soldier ] ] ) ) ;
 353: LD_ADDR_EXP 124
 357: PUSH
 358: LD_EXP 124
 362: PPUSH
 363: LD_INT 1
 365: PPUSH
 366: LD_INT 22
 368: PUSH
 369: LD_INT 2
 371: PUSH
 372: EMPTY
 373: LIST
 374: LIST
 375: PUSH
 376: LD_INT 25
 378: PUSH
 379: LD_INT 15
 381: PUSH
 382: EMPTY
 383: LIST
 384: LIST
 385: PUSH
 386: EMPTY
 387: LIST
 388: LIST
 389: PPUSH
 390: CALL_OW 69
 394: PPUSH
 395: CALL_OW 1
 399: ST_TO_ADDR
// MC_SetProduceList ( 1 , [ [ ar_medium_trike , engine_solar , control_manual , ar_control_tower ] , [ ar_medium_trike , engine_solar , control_manual , ar_control_tower ] , [ ar_medium_trike , engine_combustion , control_manual , ar_rocket_launcher ] , [ ar_medium_trike , engine_combustion , control_manual , ar_rocket_launcher ] , [ ar_medium_trike , engine_combustion , control_manual , ar_rocket_launcher ] , [ ar_medium_trike , engine_combustion , control_manual , ar_rocket_launcher ] , [ ar_medium_trike , engine_combustion , control_remote , ar_crane ] ] ) ;
 400: LD_INT 1
 402: PPUSH
 403: LD_INT 13
 405: PUSH
 406: LD_INT 2
 408: PUSH
 409: LD_INT 1
 411: PUSH
 412: LD_INT 31
 414: PUSH
 415: EMPTY
 416: LIST
 417: LIST
 418: LIST
 419: LIST
 420: PUSH
 421: LD_INT 13
 423: PUSH
 424: LD_INT 2
 426: PUSH
 427: LD_INT 1
 429: PUSH
 430: LD_INT 31
 432: PUSH
 433: EMPTY
 434: LIST
 435: LIST
 436: LIST
 437: LIST
 438: PUSH
 439: LD_INT 13
 441: PUSH
 442: LD_INT 1
 444: PUSH
 445: LD_INT 1
 447: PUSH
 448: LD_INT 28
 450: PUSH
 451: EMPTY
 452: LIST
 453: LIST
 454: LIST
 455: LIST
 456: PUSH
 457: LD_INT 13
 459: PUSH
 460: LD_INT 1
 462: PUSH
 463: LD_INT 1
 465: PUSH
 466: LD_INT 28
 468: PUSH
 469: EMPTY
 470: LIST
 471: LIST
 472: LIST
 473: LIST
 474: PUSH
 475: LD_INT 13
 477: PUSH
 478: LD_INT 1
 480: PUSH
 481: LD_INT 1
 483: PUSH
 484: LD_INT 28
 486: PUSH
 487: EMPTY
 488: LIST
 489: LIST
 490: LIST
 491: LIST
 492: PUSH
 493: LD_INT 13
 495: PUSH
 496: LD_INT 1
 498: PUSH
 499: LD_INT 1
 501: PUSH
 502: LD_INT 28
 504: PUSH
 505: EMPTY
 506: LIST
 507: LIST
 508: LIST
 509: LIST
 510: PUSH
 511: LD_INT 13
 513: PUSH
 514: LD_INT 1
 516: PUSH
 517: LD_INT 2
 519: PUSH
 520: LD_EXP 80
 524: PUSH
 525: EMPTY
 526: LIST
 527: LIST
 528: LIST
 529: LIST
 530: PUSH
 531: EMPTY
 532: LIST
 533: LIST
 534: LIST
 535: LIST
 536: LIST
 537: LIST
 538: LIST
 539: PPUSH
 540: CALL 45572 0 2
// MC_SetDefenderLimit ( 1 , 4 ) ;
 544: LD_INT 1
 546: PPUSH
 547: LD_INT 4
 549: PPUSH
 550: CALL 45757 0 2
// MC_SetLabKind ( 2 , [ b_lab_weapon , b_lab_siberium , b_lab_computer , b_lab_spacetime ] ) ;
 554: LD_INT 2
 556: PPUSH
 557: LD_INT 10
 559: PUSH
 560: LD_INT 11
 562: PUSH
 563: LD_INT 12
 565: PUSH
 566: LD_INT 14
 568: PUSH
 569: EMPTY
 570: LIST
 571: LIST
 572: LIST
 573: LIST
 574: PPUSH
 575: CALL 46314 0 2
// MC_SetCratesArea ( 2 , [ russianCratesArea ] ) ;
 579: LD_INT 2
 581: PPUSH
 582: LD_INT 14
 584: PUSH
 585: EMPTY
 586: LIST
 587: PPUSH
 588: CALL 46407 0 2
// MC_SetProduceList ( 2 , [ [ ru_medium_wheeled , engine_siberite , control_computer , ru_cargo_bay ] , [ ru_medium_tracked , engine_siberite , control_computer , ru_crane ] , [ ru_medium_tracked , engine_siberite , control_computer , ru_crane ] , [ ru_heavy_tracked , engine_siberite , control_computer , ru_rocket ] , [ ru_heavy_tracked , engine_siberite , control_computer , ru_rocket ] , [ ru_heavy_tracked , engine_siberite , control_computer , ru_rocket ] , [ ru_heavy_tracked , engine_siberite , control_computer , ru_rocket ] , [ ru_heavy_tracked , engine_siberite , control_computer , ru_rocket ] ] ) ;
 592: LD_INT 2
 594: PPUSH
 595: LD_INT 21
 597: PUSH
 598: LD_INT 3
 600: PUSH
 601: LD_INT 3
 603: PUSH
 604: LD_INT 51
 606: PUSH
 607: EMPTY
 608: LIST
 609: LIST
 610: LIST
 611: LIST
 612: PUSH
 613: LD_INT 22
 615: PUSH
 616: LD_INT 3
 618: PUSH
 619: LD_INT 3
 621: PUSH
 622: LD_INT 52
 624: PUSH
 625: EMPTY
 626: LIST
 627: LIST
 628: LIST
 629: LIST
 630: PUSH
 631: LD_INT 22
 633: PUSH
 634: LD_INT 3
 636: PUSH
 637: LD_INT 3
 639: PUSH
 640: LD_INT 52
 642: PUSH
 643: EMPTY
 644: LIST
 645: LIST
 646: LIST
 647: LIST
 648: PUSH
 649: LD_INT 24
 651: PUSH
 652: LD_INT 3
 654: PUSH
 655: LD_INT 3
 657: PUSH
 658: LD_INT 47
 660: PUSH
 661: EMPTY
 662: LIST
 663: LIST
 664: LIST
 665: LIST
 666: PUSH
 667: LD_INT 24
 669: PUSH
 670: LD_INT 3
 672: PUSH
 673: LD_INT 3
 675: PUSH
 676: LD_INT 47
 678: PUSH
 679: EMPTY
 680: LIST
 681: LIST
 682: LIST
 683: LIST
 684: PUSH
 685: LD_INT 24
 687: PUSH
 688: LD_INT 3
 690: PUSH
 691: LD_INT 3
 693: PUSH
 694: LD_INT 47
 696: PUSH
 697: EMPTY
 698: LIST
 699: LIST
 700: LIST
 701: LIST
 702: PUSH
 703: LD_INT 24
 705: PUSH
 706: LD_INT 3
 708: PUSH
 709: LD_INT 3
 711: PUSH
 712: LD_INT 47
 714: PUSH
 715: EMPTY
 716: LIST
 717: LIST
 718: LIST
 719: LIST
 720: PUSH
 721: LD_INT 24
 723: PUSH
 724: LD_INT 3
 726: PUSH
 727: LD_INT 3
 729: PUSH
 730: LD_INT 47
 732: PUSH
 733: EMPTY
 734: LIST
 735: LIST
 736: LIST
 737: LIST
 738: PUSH
 739: EMPTY
 740: LIST
 741: LIST
 742: LIST
 743: LIST
 744: LIST
 745: LIST
 746: LIST
 747: LIST
 748: PPUSH
 749: CALL 45572 0 2
// MC_SetDefenderLimit ( 2 , 5 ) ;
 753: LD_INT 2
 755: PPUSH
 756: LD_INT 5
 758: PPUSH
 759: CALL 45757 0 2
// MC_SetUpgradeBuilding ( 2 , b_depot ) ;
 763: LD_INT 2
 765: PPUSH
 766: LD_INT 0
 768: PPUSH
 769: CALL 46187 0 2
// MC_SetMinesField ( 3 , [ 10 , 12 , 14 , 15 ] [ Difficulty ] , legionMinefield ) ;
 773: LD_INT 3
 775: PPUSH
 776: LD_INT 10
 778: PUSH
 779: LD_INT 12
 781: PUSH
 782: LD_INT 14
 784: PUSH
 785: LD_INT 15
 787: PUSH
 788: EMPTY
 789: LIST
 790: LIST
 791: LIST
 792: LIST
 793: PUSH
 794: LD_OWVAR 67
 798: ARRAY
 799: PPUSH
 800: LD_INT 24
 802: PPUSH
 803: CALL 45254 0 3
// MC_SetLabKind ( 3 , [ b_lab_weapon , b_lab_siberium , b_lab_biological , b_lab_opto ] ) ;
 807: LD_INT 3
 809: PPUSH
 810: LD_INT 10
 812: PUSH
 813: LD_INT 11
 815: PUSH
 816: LD_INT 13
 818: PUSH
 819: LD_INT 15
 821: PUSH
 822: EMPTY
 823: LIST
 824: LIST
 825: LIST
 826: LIST
 827: PPUSH
 828: CALL 46314 0 2
// MC_SetCratesArea ( 3 , [ legionCratesArea ] ) ;
 832: LD_INT 3
 834: PPUSH
 835: LD_INT 13
 837: PUSH
 838: EMPTY
 839: LIST
 840: PPUSH
 841: CALL 46407 0 2
// mc_ape := Replace ( mc_ape , 3 , FilterAllUnits ( [ [ f_side , 8 ] , [ f_class , class_apeman_soldier ] ] ) ) ;
 845: LD_ADDR_EXP 124
 849: PUSH
 850: LD_EXP 124
 854: PPUSH
 855: LD_INT 3
 857: PPUSH
 858: LD_INT 22
 860: PUSH
 861: LD_INT 8
 863: PUSH
 864: EMPTY
 865: LIST
 866: LIST
 867: PUSH
 868: LD_INT 25
 870: PUSH
 871: LD_INT 15
 873: PUSH
 874: EMPTY
 875: LIST
 876: LIST
 877: PUSH
 878: EMPTY
 879: LIST
 880: LIST
 881: PPUSH
 882: CALL_OW 69
 886: PPUSH
 887: CALL_OW 1
 891: ST_TO_ADDR
// MC_SetProduceList ( 3 , [ [ ar_medium_trike , engine_solar , control_manual , ar_control_tower ] , [ ar_medium_trike , engine_solar , control_manual , ar_control_tower ] , [ ar_medium_trike , engine_siberite , control_remote , ar_cargo_bay ] , [ ar_half_tracked , engine_combustion , control_manual , ar_rocket_launcher ] , [ ar_half_tracked , engine_combustion , control_manual , ar_rocket_launcher ] , [ ar_half_tracked , engine_combustion , control_manual , ar_rocket_launcher ] , [ ar_half_tracked , engine_combustion , control_manual , ar_rocket_launcher ] , [ ar_half_tracked , engine_combustion , control_remote , ar_crane ] ] ) ;
 892: LD_INT 3
 894: PPUSH
 895: LD_INT 13
 897: PUSH
 898: LD_INT 2
 900: PUSH
 901: LD_INT 1
 903: PUSH
 904: LD_INT 31
 906: PUSH
 907: EMPTY
 908: LIST
 909: LIST
 910: LIST
 911: LIST
 912: PUSH
 913: LD_INT 13
 915: PUSH
 916: LD_INT 2
 918: PUSH
 919: LD_INT 1
 921: PUSH
 922: LD_INT 31
 924: PUSH
 925: EMPTY
 926: LIST
 927: LIST
 928: LIST
 929: LIST
 930: PUSH
 931: LD_INT 13
 933: PUSH
 934: LD_INT 3
 936: PUSH
 937: LD_INT 2
 939: PUSH
 940: LD_INT 32
 942: PUSH
 943: EMPTY
 944: LIST
 945: LIST
 946: LIST
 947: LIST
 948: PUSH
 949: LD_INT 14
 951: PUSH
 952: LD_INT 1
 954: PUSH
 955: LD_INT 1
 957: PUSH
 958: LD_INT 28
 960: PUSH
 961: EMPTY
 962: LIST
 963: LIST
 964: LIST
 965: LIST
 966: PUSH
 967: LD_INT 14
 969: PUSH
 970: LD_INT 1
 972: PUSH
 973: LD_INT 1
 975: PUSH
 976: LD_INT 28
 978: PUSH
 979: EMPTY
 980: LIST
 981: LIST
 982: LIST
 983: LIST
 984: PUSH
 985: LD_INT 14
 987: PUSH
 988: LD_INT 1
 990: PUSH
 991: LD_INT 1
 993: PUSH
 994: LD_INT 28
 996: PUSH
 997: EMPTY
 998: LIST
 999: LIST
1000: LIST
1001: LIST
1002: PUSH
1003: LD_INT 14
1005: PUSH
1006: LD_INT 1
1008: PUSH
1009: LD_INT 1
1011: PUSH
1012: LD_INT 28
1014: PUSH
1015: EMPTY
1016: LIST
1017: LIST
1018: LIST
1019: LIST
1020: PUSH
1021: LD_INT 14
1023: PUSH
1024: LD_INT 1
1026: PUSH
1027: LD_INT 2
1029: PUSH
1030: LD_EXP 80
1034: PUSH
1035: EMPTY
1036: LIST
1037: LIST
1038: LIST
1039: LIST
1040: PUSH
1041: EMPTY
1042: LIST
1043: LIST
1044: LIST
1045: LIST
1046: LIST
1047: LIST
1048: LIST
1049: LIST
1050: PPUSH
1051: CALL 45572 0 2
// MC_SetDefenderLimit ( 3 , 4 ) ;
1055: LD_INT 3
1057: PPUSH
1058: LD_INT 4
1060: PPUSH
1061: CALL 45757 0 2
// MC_SetLabKind ( 4 , [ b_lab_weapon , b_lab_computer , b_lab_siberium , b_lab_opto ] ) ;
1065: LD_INT 4
1067: PPUSH
1068: LD_INT 10
1070: PUSH
1071: LD_INT 12
1073: PUSH
1074: LD_INT 11
1076: PUSH
1077: LD_INT 15
1079: PUSH
1080: EMPTY
1081: LIST
1082: LIST
1083: LIST
1084: LIST
1085: PPUSH
1086: CALL 46314 0 2
// MC_SetCratesArea ( 4 , [ americanCratesArea ] ) ;
1090: LD_INT 4
1092: PPUSH
1093: LD_INT 33
1095: PUSH
1096: EMPTY
1097: LIST
1098: PPUSH
1099: CALL 46407 0 2
// MC_SetAllowedTurretWeapons ( 4 , [ us_double_gun , us_heavy_gun , us_rocket_launcher , us_laser , us_double_laser ] ) ;
1103: LD_INT 4
1105: PPUSH
1106: LD_INT 5
1108: PUSH
1109: LD_INT 6
1111: PUSH
1112: LD_INT 7
1114: PUSH
1115: LD_INT 9
1117: PUSH
1118: LD_INT 10
1120: PUSH
1121: EMPTY
1122: LIST
1123: LIST
1124: LIST
1125: LIST
1126: LIST
1127: PPUSH
1128: CALL 46725 0 2
// MC_SetFactoryExtension ( 4 , 54 , 85 , 2 , [ b_ext_laser , b_ext_track , b_ext_gun , b_ext_rocket , b_ext_radio ] ) ;
1132: LD_INT 4
1134: PPUSH
1135: LD_INT 54
1137: PPUSH
1138: LD_INT 85
1140: PPUSH
1141: LD_INT 2
1143: PPUSH
1144: LD_INT 25
1146: PUSH
1147: LD_INT 16
1149: PUSH
1150: LD_INT 17
1152: PUSH
1153: LD_INT 18
1155: PUSH
1156: LD_INT 22
1158: PUSH
1159: EMPTY
1160: LIST
1161: LIST
1162: LIST
1163: LIST
1164: LIST
1165: PPUSH
1166: CALL 46519 0 5
// MC_SetProduceList ( 4 , [ [ us_morphling , engine_combustion , control_manual , us_rocket_launcher ] , [ us_morphling , engine_combustion , control_manual , us_heavy_gun ] , [ us_morphling , engine_combustion , control_manual , us_rocket_launcher ] , [ us_morphling , engine_combustion , control_manual , us_heavy_gun ] , [ us_morphling , engine_combustion , control_computer , us_cargo_bay ] , [ us_medium_tracked , engine_combustion , control_computer , us_crane ] ] ) ;
1170: LD_INT 4
1172: PPUSH
1173: LD_INT 5
1175: PUSH
1176: LD_INT 1
1178: PUSH
1179: LD_INT 1
1181: PUSH
1182: LD_INT 7
1184: PUSH
1185: EMPTY
1186: LIST
1187: LIST
1188: LIST
1189: LIST
1190: PUSH
1191: LD_INT 5
1193: PUSH
1194: LD_INT 1
1196: PUSH
1197: LD_INT 1
1199: PUSH
1200: LD_INT 6
1202: PUSH
1203: EMPTY
1204: LIST
1205: LIST
1206: LIST
1207: LIST
1208: PUSH
1209: LD_INT 5
1211: PUSH
1212: LD_INT 1
1214: PUSH
1215: LD_INT 1
1217: PUSH
1218: LD_INT 7
1220: PUSH
1221: EMPTY
1222: LIST
1223: LIST
1224: LIST
1225: LIST
1226: PUSH
1227: LD_INT 5
1229: PUSH
1230: LD_INT 1
1232: PUSH
1233: LD_INT 1
1235: PUSH
1236: LD_INT 6
1238: PUSH
1239: EMPTY
1240: LIST
1241: LIST
1242: LIST
1243: LIST
1244: PUSH
1245: LD_INT 5
1247: PUSH
1248: LD_INT 1
1250: PUSH
1251: LD_INT 3
1253: PUSH
1254: LD_INT 12
1256: PUSH
1257: EMPTY
1258: LIST
1259: LIST
1260: LIST
1261: LIST
1262: PUSH
1263: LD_INT 3
1265: PUSH
1266: LD_INT 1
1268: PUSH
1269: LD_INT 3
1271: PUSH
1272: LD_INT 13
1274: PUSH
1275: EMPTY
1276: LIST
1277: LIST
1278: LIST
1279: LIST
1280: PUSH
1281: EMPTY
1282: LIST
1283: LIST
1284: LIST
1285: LIST
1286: LIST
1287: LIST
1288: PPUSH
1289: CALL 45572 0 2
// MC_SetDefenderLimit ( 4 , 4 ) ;
1293: LD_INT 4
1295: PPUSH
1296: LD_INT 4
1298: PPUSH
1299: CALL 45757 0 2
// MC_SetTame ( 4 , powellApe ) ;
1303: LD_INT 4
1305: PPUSH
1306: LD_INT 11
1308: PPUSH
1309: CALL 46138 0 2
// end ;
1313: LD_VAR 0 1
1317: RET
// every 0 0$1 trigger debug do var i ;
1318: LD_EXP 1
1322: IFFALSE 1420
1324: GO 1326
1326: DISABLE
1327: LD_INT 0
1329: PPUSH
// begin enable ;
1330: ENABLE
// for i in FilterAllUnits ( [ [ f_side , 7 ] , [ f_or , [ f_type , unit_human ] , [ f_type , unit_vehicle ] ] , [ f_not , [ f_lives , 1000 ] ] ] ) do
1331: LD_ADDR_VAR 0 1
1335: PUSH
1336: LD_INT 22
1338: PUSH
1339: LD_INT 7
1341: PUSH
1342: EMPTY
1343: LIST
1344: LIST
1345: PUSH
1346: LD_INT 2
1348: PUSH
1349: LD_INT 21
1351: PUSH
1352: LD_INT 1
1354: PUSH
1355: EMPTY
1356: LIST
1357: LIST
1358: PUSH
1359: LD_INT 21
1361: PUSH
1362: LD_INT 2
1364: PUSH
1365: EMPTY
1366: LIST
1367: LIST
1368: PUSH
1369: EMPTY
1370: LIST
1371: LIST
1372: LIST
1373: PUSH
1374: LD_INT 3
1376: PUSH
1377: LD_INT 24
1379: PUSH
1380: LD_INT 1000
1382: PUSH
1383: EMPTY
1384: LIST
1385: LIST
1386: PUSH
1387: EMPTY
1388: LIST
1389: LIST
1390: PUSH
1391: EMPTY
1392: LIST
1393: LIST
1394: LIST
1395: PPUSH
1396: CALL_OW 69
1400: PUSH
1401: FOR_IN
1402: IFFALSE 1418
// SetLives ( i , 1000 ) ;
1404: LD_VAR 0 1
1408: PPUSH
1409: LD_INT 1000
1411: PPUSH
1412: CALL_OW 234
1416: GO 1401
1418: POP
1419: POP
// end ;
1420: PPOPN 1
1422: END
// every 0 0$1 trigger artifactDestroyCounter >= 5 do
1423: LD_EXP 16
1427: PUSH
1428: LD_INT 5
1430: GREATEREQUAL
1431: IFFALSE 1443
1433: GO 1435
1435: DISABLE
// SetAchievement ( ACH_ARTIFACT ) ; end_of_file
1436: LD_STRING ACH_ARTIFACT
1438: PPUSH
1439: CALL_OW 543
1443: END
// export JMM , Roth , Lisa , Donaldson , Bobby , Cyrus , Denis , Brown , Gladstone , Houten , Cornel , Gary , Frank , Kikuchi , Simms , Joan , DeltaDoctor , Connie ; export Gossudarov , Kirilenkova , Titov , Fadeev , Dolgov , Petrosyan , Scholtze , Oblukov , Kapitsova , Lipshchin , Petrovova , Kovalyuk , Kuzmov , Karamazov ; export Burlak , Belkov , Gnyevko ; export function PrepareAlliance ; var i , veh , selected , tmp ; begin
1444: LD_INT 0
1446: PPUSH
1447: PPUSH
1448: PPUSH
1449: PPUSH
1450: PPUSH
// uc_side := 7 ;
1451: LD_ADDR_OWVAR 20
1455: PUSH
1456: LD_INT 7
1458: ST_TO_ADDR
// tmp := [ ] ;
1459: LD_ADDR_VAR 0 5
1463: PUSH
1464: EMPTY
1465: ST_TO_ADDR
// JMM := PrepareUnit ( JMM , ( not debug ) , 14a_ ) ;
1466: LD_ADDR_EXP 19
1470: PUSH
1471: LD_STRING JMM
1473: PPUSH
1474: LD_EXP 1
1478: NOT
1479: PPUSH
1480: LD_STRING 14a_
1482: PPUSH
1483: CALL 52026 0 3
1487: ST_TO_ADDR
// Burlak := PrepareUnit ( Burlak , ( not debug ) , 14a_ ) ;
1488: LD_ADDR_EXP 51
1492: PUSH
1493: LD_STRING Burlak
1495: PPUSH
1496: LD_EXP 1
1500: NOT
1501: PPUSH
1502: LD_STRING 14a_
1504: PPUSH
1505: CALL 52026 0 3
1509: ST_TO_ADDR
// Joan := PrepareUnit ( Joan , ( not debug ) , 13a_ ) ;
1510: LD_ADDR_EXP 34
1514: PUSH
1515: LD_STRING Joan
1517: PPUSH
1518: LD_EXP 1
1522: NOT
1523: PPUSH
1524: LD_STRING 13a_
1526: PPUSH
1527: CALL 52026 0 3
1531: ST_TO_ADDR
// Roth := PrepareUnit ( Roth , ( not debug ) , 13a_ ) ;
1532: LD_ADDR_EXP 20
1536: PUSH
1537: LD_STRING Roth
1539: PPUSH
1540: LD_EXP 1
1544: NOT
1545: PPUSH
1546: LD_STRING 13a_
1548: PPUSH
1549: CALL 52026 0 3
1553: ST_TO_ADDR
// Gossudarov := PrepareUnit ( Gossudarov , ( not debug ) , 13a_ ) ;
1554: LD_ADDR_EXP 37
1558: PUSH
1559: LD_STRING Gossudarov
1561: PPUSH
1562: LD_EXP 1
1566: NOT
1567: PPUSH
1568: LD_STRING 13a_
1570: PPUSH
1571: CALL 52026 0 3
1575: ST_TO_ADDR
// Denis := PrepareUnit ( Denis , ( not debug ) , 13a_ ) ;
1576: LD_ADDR_EXP 25
1580: PUSH
1581: LD_STRING Denis
1583: PPUSH
1584: LD_EXP 1
1588: NOT
1589: PPUSH
1590: LD_STRING 13a_
1592: PPUSH
1593: CALL 52026 0 3
1597: ST_TO_ADDR
// DeltaDoctor := PrepareUnit ( DeltaDoctor , ( not debug ) , 13a_ ) ;
1598: LD_ADDR_EXP 35
1602: PUSH
1603: LD_STRING DeltaDoctor
1605: PPUSH
1606: LD_EXP 1
1610: NOT
1611: PPUSH
1612: LD_STRING 13a_
1614: PPUSH
1615: CALL 52026 0 3
1619: ST_TO_ADDR
// if DeltaDoctor then
1620: LD_EXP 35
1624: IFFALSE 1642
// tmp := tmp ^ DeltaDoctor ;
1626: LD_ADDR_VAR 0 5
1630: PUSH
1631: LD_VAR 0 5
1635: PUSH
1636: LD_EXP 35
1640: ADD
1641: ST_TO_ADDR
// Simms := PrepareUnit ( Simms , ( not debug ) , 13a_ ) ;
1642: LD_ADDR_EXP 33
1646: PUSH
1647: LD_STRING Simms
1649: PPUSH
1650: LD_EXP 1
1654: NOT
1655: PPUSH
1656: LD_STRING 13a_
1658: PPUSH
1659: CALL 52026 0 3
1663: ST_TO_ADDR
// if Simms then
1664: LD_EXP 33
1668: IFFALSE 1686
// tmp := tmp ^ Simms ;
1670: LD_ADDR_VAR 0 5
1674: PUSH
1675: LD_VAR 0 5
1679: PUSH
1680: LD_EXP 33
1684: ADD
1685: ST_TO_ADDR
// Frank := PrepareUnit ( Frank , ( not debug ) , 13a_ ) ;
1686: LD_ADDR_EXP 31
1690: PUSH
1691: LD_STRING Frank
1693: PPUSH
1694: LD_EXP 1
1698: NOT
1699: PPUSH
1700: LD_STRING 13a_
1702: PPUSH
1703: CALL 52026 0 3
1707: ST_TO_ADDR
// if Frank then
1708: LD_EXP 31
1712: IFFALSE 1730
// tmp := tmp ^ Frank ;
1714: LD_ADDR_VAR 0 5
1718: PUSH
1719: LD_VAR 0 5
1723: PUSH
1724: LD_EXP 31
1728: ADD
1729: ST_TO_ADDR
// Kirilenkova := PrepareUnit ( Kirilenkova , ( not debug ) , 13a_ ) ;
1730: LD_ADDR_EXP 38
1734: PUSH
1735: LD_STRING Kirilenkova
1737: PPUSH
1738: LD_EXP 1
1742: NOT
1743: PPUSH
1744: LD_STRING 13a_
1746: PPUSH
1747: CALL 52026 0 3
1751: ST_TO_ADDR
// if Kirilenkova then
1752: LD_EXP 38
1756: IFFALSE 1774
// tmp := tmp ^ Kirilenkova ;
1758: LD_ADDR_VAR 0 5
1762: PUSH
1763: LD_VAR 0 5
1767: PUSH
1768: LD_EXP 38
1772: ADD
1773: ST_TO_ADDR
// Titov := PrepareUnit ( Titov , ( not debug ) , 13a_ ) ;
1774: LD_ADDR_EXP 39
1778: PUSH
1779: LD_STRING Titov
1781: PPUSH
1782: LD_EXP 1
1786: NOT
1787: PPUSH
1788: LD_STRING 13a_
1790: PPUSH
1791: CALL 52026 0 3
1795: ST_TO_ADDR
// if Titov then
1796: LD_EXP 39
1800: IFFALSE 1818
// tmp := tmp ^ Titov ;
1802: LD_ADDR_VAR 0 5
1806: PUSH
1807: LD_VAR 0 5
1811: PUSH
1812: LD_EXP 39
1816: ADD
1817: ST_TO_ADDR
// Fadeev := PrepareUnit ( Fadeev , ( not debug ) , 13a_ ) ;
1818: LD_ADDR_EXP 40
1822: PUSH
1823: LD_STRING Fadeev
1825: PPUSH
1826: LD_EXP 1
1830: NOT
1831: PPUSH
1832: LD_STRING 13a_
1834: PPUSH
1835: CALL 52026 0 3
1839: ST_TO_ADDR
// if Fadeev then
1840: LD_EXP 40
1844: IFFALSE 1862
// tmp := tmp ^ Fadeev ;
1846: LD_ADDR_VAR 0 5
1850: PUSH
1851: LD_VAR 0 5
1855: PUSH
1856: LD_EXP 40
1860: ADD
1861: ST_TO_ADDR
// Dolgov := PrepareUnit ( Dolgov , ( not debug ) , 13a_ ) ;
1862: LD_ADDR_EXP 41
1866: PUSH
1867: LD_STRING Dolgov
1869: PPUSH
1870: LD_EXP 1
1874: NOT
1875: PPUSH
1876: LD_STRING 13a_
1878: PPUSH
1879: CALL 52026 0 3
1883: ST_TO_ADDR
// if Dolgov then
1884: LD_EXP 41
1888: IFFALSE 1906
// tmp := tmp ^ Dolgov ;
1890: LD_ADDR_VAR 0 5
1894: PUSH
1895: LD_VAR 0 5
1899: PUSH
1900: LD_EXP 41
1904: ADD
1905: ST_TO_ADDR
// Petrosyan := PrepareUnit ( Petrosyan , ( not debug ) , 13a_ ) ;
1906: LD_ADDR_EXP 42
1910: PUSH
1911: LD_STRING Petrosyan
1913: PPUSH
1914: LD_EXP 1
1918: NOT
1919: PPUSH
1920: LD_STRING 13a_
1922: PPUSH
1923: CALL 52026 0 3
1927: ST_TO_ADDR
// if Petrosyan then
1928: LD_EXP 42
1932: IFFALSE 1950
// tmp := tmp ^ Petrosyan ;
1934: LD_ADDR_VAR 0 5
1938: PUSH
1939: LD_VAR 0 5
1943: PUSH
1944: LD_EXP 42
1948: ADD
1949: ST_TO_ADDR
// Scholtze := PrepareUnit ( Scholtze , ( not debug ) , 13a_ ) ;
1950: LD_ADDR_EXP 43
1954: PUSH
1955: LD_STRING Scholtze
1957: PPUSH
1958: LD_EXP 1
1962: NOT
1963: PPUSH
1964: LD_STRING 13a_
1966: PPUSH
1967: CALL 52026 0 3
1971: ST_TO_ADDR
// if Scholtze then
1972: LD_EXP 43
1976: IFFALSE 1994
// tmp := tmp ^ Scholtze ;
1978: LD_ADDR_VAR 0 5
1982: PUSH
1983: LD_VAR 0 5
1987: PUSH
1988: LD_EXP 43
1992: ADD
1993: ST_TO_ADDR
// Oblukov := PrepareUnit ( Oblukov , ( not debug ) , 13a_ ) ;
1994: LD_ADDR_EXP 44
1998: PUSH
1999: LD_STRING Oblukov
2001: PPUSH
2002: LD_EXP 1
2006: NOT
2007: PPUSH
2008: LD_STRING 13a_
2010: PPUSH
2011: CALL 52026 0 3
2015: ST_TO_ADDR
// if Oblukov then
2016: LD_EXP 44
2020: IFFALSE 2038
// tmp := tmp ^ Oblukov ;
2022: LD_ADDR_VAR 0 5
2026: PUSH
2027: LD_VAR 0 5
2031: PUSH
2032: LD_EXP 44
2036: ADD
2037: ST_TO_ADDR
// Kapitsova := PrepareUnit ( Kapitsova , ( not debug ) , 13a_ ) ;
2038: LD_ADDR_EXP 45
2042: PUSH
2043: LD_STRING Kapitsova
2045: PPUSH
2046: LD_EXP 1
2050: NOT
2051: PPUSH
2052: LD_STRING 13a_
2054: PPUSH
2055: CALL 52026 0 3
2059: ST_TO_ADDR
// if Kapitsova then
2060: LD_EXP 45
2064: IFFALSE 2082
// tmp := tmp ^ Kapitsova ;
2066: LD_ADDR_VAR 0 5
2070: PUSH
2071: LD_VAR 0 5
2075: PUSH
2076: LD_EXP 45
2080: ADD
2081: ST_TO_ADDR
// Lipshchin := PrepareUnit ( Lipshchin , ( not debug ) , 13a_ ) ;
2082: LD_ADDR_EXP 46
2086: PUSH
2087: LD_STRING Lipshchin
2089: PPUSH
2090: LD_EXP 1
2094: NOT
2095: PPUSH
2096: LD_STRING 13a_
2098: PPUSH
2099: CALL 52026 0 3
2103: ST_TO_ADDR
// if Lipshchin then
2104: LD_EXP 46
2108: IFFALSE 2126
// tmp := tmp ^ Lipshchin ;
2110: LD_ADDR_VAR 0 5
2114: PUSH
2115: LD_VAR 0 5
2119: PUSH
2120: LD_EXP 46
2124: ADD
2125: ST_TO_ADDR
// Petrovova := PrepareUnit ( Petrovova , ( not debug ) , 13a_ ) ;
2126: LD_ADDR_EXP 47
2130: PUSH
2131: LD_STRING Petrovova
2133: PPUSH
2134: LD_EXP 1
2138: NOT
2139: PPUSH
2140: LD_STRING 13a_
2142: PPUSH
2143: CALL 52026 0 3
2147: ST_TO_ADDR
// if Petrovova then
2148: LD_EXP 47
2152: IFFALSE 2170
// tmp := tmp ^ Petrovova ;
2154: LD_ADDR_VAR 0 5
2158: PUSH
2159: LD_VAR 0 5
2163: PUSH
2164: LD_EXP 47
2168: ADD
2169: ST_TO_ADDR
// Kovalyuk := PrepareUnit ( Kovalyuk , ( not debug ) , 13a_ ) ;
2170: LD_ADDR_EXP 48
2174: PUSH
2175: LD_STRING Kovalyuk
2177: PPUSH
2178: LD_EXP 1
2182: NOT
2183: PPUSH
2184: LD_STRING 13a_
2186: PPUSH
2187: CALL 52026 0 3
2191: ST_TO_ADDR
// if Kovalyuk then
2192: LD_EXP 48
2196: IFFALSE 2214
// tmp := tmp ^ Kovalyuk ;
2198: LD_ADDR_VAR 0 5
2202: PUSH
2203: LD_VAR 0 5
2207: PUSH
2208: LD_EXP 48
2212: ADD
2213: ST_TO_ADDR
// Kuzmov := PrepareUnit ( Kuzmov , ( not debug ) , 13a_ ) ;
2214: LD_ADDR_EXP 49
2218: PUSH
2219: LD_STRING Kuzmov
2221: PPUSH
2222: LD_EXP 1
2226: NOT
2227: PPUSH
2228: LD_STRING 13a_
2230: PPUSH
2231: CALL 52026 0 3
2235: ST_TO_ADDR
// if Kuzmov then
2236: LD_EXP 49
2240: IFFALSE 2258
// tmp := tmp ^ Kuzmov ;
2242: LD_ADDR_VAR 0 5
2246: PUSH
2247: LD_VAR 0 5
2251: PUSH
2252: LD_EXP 49
2256: ADD
2257: ST_TO_ADDR
// Karamazov := PrepareUnit ( Karamazov , ( not debug ) , 13a_ ) ;
2258: LD_ADDR_EXP 50
2262: PUSH
2263: LD_STRING Karamazov
2265: PPUSH
2266: LD_EXP 1
2270: NOT
2271: PPUSH
2272: LD_STRING 13a_
2274: PPUSH
2275: CALL 52026 0 3
2279: ST_TO_ADDR
// if Karamazov then
2280: LD_EXP 50
2284: IFFALSE 2302
// tmp := tmp ^ Karamazov ;
2286: LD_ADDR_VAR 0 5
2290: PUSH
2291: LD_VAR 0 5
2295: PUSH
2296: LD_EXP 50
2300: ADD
2301: ST_TO_ADDR
// Belkov := PrepareUnit ( Belkov , ( not debug ) , 13a_ ) ;
2302: LD_ADDR_EXP 52
2306: PUSH
2307: LD_STRING Belkov
2309: PPUSH
2310: LD_EXP 1
2314: NOT
2315: PPUSH
2316: LD_STRING 13a_
2318: PPUSH
2319: CALL 52026 0 3
2323: ST_TO_ADDR
// if Belkov then
2324: LD_EXP 52
2328: IFFALSE 2346
// tmp := tmp ^ Belkov ;
2330: LD_ADDR_VAR 0 5
2334: PUSH
2335: LD_VAR 0 5
2339: PUSH
2340: LD_EXP 52
2344: ADD
2345: ST_TO_ADDR
// Gnyevko := PrepareUnit ( Gnyevko , ( not debug ) , 13a_ ) ;
2346: LD_ADDR_EXP 53
2350: PUSH
2351: LD_STRING Gnyevko
2353: PPUSH
2354: LD_EXP 1
2358: NOT
2359: PPUSH
2360: LD_STRING 13a_
2362: PPUSH
2363: CALL 52026 0 3
2367: ST_TO_ADDR
// if Gnyevko then
2368: LD_EXP 53
2372: IFFALSE 2390
// tmp := tmp ^ Gnyevko ;
2374: LD_ADDR_VAR 0 5
2378: PUSH
2379: LD_VAR 0 5
2383: PUSH
2384: LD_EXP 53
2388: ADD
2389: ST_TO_ADDR
// Connie = NewCharacter ( Coonie ) ;
2390: LD_ADDR_EXP 36
2394: PUSH
2395: LD_STRING Coonie
2397: PPUSH
2398: CALL_OW 25
2402: ST_TO_ADDR
// if not Lisa then
2403: LD_EXP 21
2407: NOT
2408: IFFALSE 2454
// begin Lisa := PrepareUnit ( Lisa , ( not debug ) , 13a_ ) ;
2410: LD_ADDR_EXP 21
2414: PUSH
2415: LD_STRING Lisa
2417: PPUSH
2418: LD_EXP 1
2422: NOT
2423: PPUSH
2424: LD_STRING 13a_
2426: PPUSH
2427: CALL 52026 0 3
2431: ST_TO_ADDR
// if Lisa then
2432: LD_EXP 21
2436: IFFALSE 2454
// tmp := tmp ^ Lisa ;
2438: LD_ADDR_VAR 0 5
2442: PUSH
2443: LD_VAR 0 5
2447: PUSH
2448: LD_EXP 21
2452: ADD
2453: ST_TO_ADDR
// end ; if not Donaldson then
2454: LD_EXP 22
2458: NOT
2459: IFFALSE 2505
// begin Donaldson := PrepareUnit ( Donaldson , ( not debug ) , 13a_ ) ;
2461: LD_ADDR_EXP 22
2465: PUSH
2466: LD_STRING Donaldson
2468: PPUSH
2469: LD_EXP 1
2473: NOT
2474: PPUSH
2475: LD_STRING 13a_
2477: PPUSH
2478: CALL 52026 0 3
2482: ST_TO_ADDR
// if Donaldson then
2483: LD_EXP 22
2487: IFFALSE 2505
// tmp := tmp ^ Donaldson ;
2489: LD_ADDR_VAR 0 5
2493: PUSH
2494: LD_VAR 0 5
2498: PUSH
2499: LD_EXP 22
2503: ADD
2504: ST_TO_ADDR
// end ; if not Bobby then
2505: LD_EXP 23
2509: NOT
2510: IFFALSE 2556
// begin Bobby := PrepareUnit ( Bobby , ( not debug ) , 13a_ ) ;
2512: LD_ADDR_EXP 23
2516: PUSH
2517: LD_STRING Bobby
2519: PPUSH
2520: LD_EXP 1
2524: NOT
2525: PPUSH
2526: LD_STRING 13a_
2528: PPUSH
2529: CALL 52026 0 3
2533: ST_TO_ADDR
// if Bobby then
2534: LD_EXP 23
2538: IFFALSE 2556
// tmp := tmp ^ Bobby ;
2540: LD_ADDR_VAR 0 5
2544: PUSH
2545: LD_VAR 0 5
2549: PUSH
2550: LD_EXP 23
2554: ADD
2555: ST_TO_ADDR
// end ; if not Cyrus then
2556: LD_EXP 24
2560: NOT
2561: IFFALSE 2607
// begin Cyrus := PrepareUnit ( Cyrus , ( not debug ) , 13a_ ) ;
2563: LD_ADDR_EXP 24
2567: PUSH
2568: LD_STRING Cyrus
2570: PPUSH
2571: LD_EXP 1
2575: NOT
2576: PPUSH
2577: LD_STRING 13a_
2579: PPUSH
2580: CALL 52026 0 3
2584: ST_TO_ADDR
// if Cyrus then
2585: LD_EXP 24
2589: IFFALSE 2607
// tmp := tmp ^ Cyrus ;
2591: LD_ADDR_VAR 0 5
2595: PUSH
2596: LD_VAR 0 5
2600: PUSH
2601: LD_EXP 24
2605: ADD
2606: ST_TO_ADDR
// end ; if not Brown then
2607: LD_EXP 26
2611: NOT
2612: IFFALSE 2658
// begin Brown := PrepareUnit ( Brown , ( not debug ) , 13a_ ) ;
2614: LD_ADDR_EXP 26
2618: PUSH
2619: LD_STRING Brown
2621: PPUSH
2622: LD_EXP 1
2626: NOT
2627: PPUSH
2628: LD_STRING 13a_
2630: PPUSH
2631: CALL 52026 0 3
2635: ST_TO_ADDR
// if Brown then
2636: LD_EXP 26
2640: IFFALSE 2658
// tmp := tmp ^ Brown ;
2642: LD_ADDR_VAR 0 5
2646: PUSH
2647: LD_VAR 0 5
2651: PUSH
2652: LD_EXP 26
2656: ADD
2657: ST_TO_ADDR
// end ; if not Gladstone then
2658: LD_EXP 27
2662: NOT
2663: IFFALSE 2709
// begin Gladstone := PrepareUnit ( Gladstone , ( not debug ) , 13a_ ) ;
2665: LD_ADDR_EXP 27
2669: PUSH
2670: LD_STRING Gladstone
2672: PPUSH
2673: LD_EXP 1
2677: NOT
2678: PPUSH
2679: LD_STRING 13a_
2681: PPUSH
2682: CALL 52026 0 3
2686: ST_TO_ADDR
// if Gladstone then
2687: LD_EXP 27
2691: IFFALSE 2709
// tmp := tmp ^ Gladstone ;
2693: LD_ADDR_VAR 0 5
2697: PUSH
2698: LD_VAR 0 5
2702: PUSH
2703: LD_EXP 27
2707: ADD
2708: ST_TO_ADDR
// end ; if not Cornel then
2709: LD_EXP 29
2713: NOT
2714: IFFALSE 2760
// begin Cornel := PrepareUnit ( Cornel , ( not debug ) , 13a_ ) ;
2716: LD_ADDR_EXP 29
2720: PUSH
2721: LD_STRING Cornel
2723: PPUSH
2724: LD_EXP 1
2728: NOT
2729: PPUSH
2730: LD_STRING 13a_
2732: PPUSH
2733: CALL 52026 0 3
2737: ST_TO_ADDR
// if Cornel then
2738: LD_EXP 29
2742: IFFALSE 2760
// tmp := tmp ^ Cornel ;
2744: LD_ADDR_VAR 0 5
2748: PUSH
2749: LD_VAR 0 5
2753: PUSH
2754: LD_EXP 29
2758: ADD
2759: ST_TO_ADDR
// end ; if not Houten then
2760: LD_EXP 28
2764: NOT
2765: IFFALSE 2811
// begin Houten := PrepareUnit ( Houten , ( not debug ) , 13a_ ) ;
2767: LD_ADDR_EXP 28
2771: PUSH
2772: LD_STRING Houten
2774: PPUSH
2775: LD_EXP 1
2779: NOT
2780: PPUSH
2781: LD_STRING 13a_
2783: PPUSH
2784: CALL 52026 0 3
2788: ST_TO_ADDR
// if Houten then
2789: LD_EXP 28
2793: IFFALSE 2811
// tmp := tmp ^ Houten ;
2795: LD_ADDR_VAR 0 5
2799: PUSH
2800: LD_VAR 0 5
2804: PUSH
2805: LD_EXP 28
2809: ADD
2810: ST_TO_ADDR
// end ; if not Gary then
2811: LD_EXP 30
2815: NOT
2816: IFFALSE 2862
// begin Gary := PrepareUnit ( Gary , ( not debug ) , 13a_ ) ;
2818: LD_ADDR_EXP 30
2822: PUSH
2823: LD_STRING Gary
2825: PPUSH
2826: LD_EXP 1
2830: NOT
2831: PPUSH
2832: LD_STRING 13a_
2834: PPUSH
2835: CALL 52026 0 3
2839: ST_TO_ADDR
// if Gary then
2840: LD_EXP 30
2844: IFFALSE 2862
// tmp := tmp ^ Gary ;
2846: LD_ADDR_VAR 0 5
2850: PUSH
2851: LD_VAR 0 5
2855: PUSH
2856: LD_EXP 30
2860: ADD
2861: ST_TO_ADDR
// end ; if not Kikuchi then
2862: LD_EXP 32
2866: NOT
2867: IFFALSE 2913
// begin Kikuchi := PrepareUnit ( Kikuchi , ( not debug ) , 13a_ ) ;
2869: LD_ADDR_EXP 32
2873: PUSH
2874: LD_STRING Kikuchi
2876: PPUSH
2877: LD_EXP 1
2881: NOT
2882: PPUSH
2883: LD_STRING 13a_
2885: PPUSH
2886: CALL 52026 0 3
2890: ST_TO_ADDR
// if Kikuchi then
2891: LD_EXP 32
2895: IFFALSE 2913
// tmp := tmp ^ Kikuchi ;
2897: LD_ADDR_VAR 0 5
2901: PUSH
2902: LD_VAR 0 5
2906: PUSH
2907: LD_EXP 32
2911: ADD
2912: ST_TO_ADDR
// end ; tmp := tmp union CreateCharacterSet ( 13a_others ) ;
2913: LD_ADDR_VAR 0 5
2917: PUSH
2918: LD_VAR 0 5
2922: PUSH
2923: LD_STRING 13a_others
2925: PPUSH
2926: CALL_OW 31
2930: UNION
2931: ST_TO_ADDR
// tmp := tmp diff 0 ;
2932: LD_ADDR_VAR 0 5
2936: PUSH
2937: LD_VAR 0 5
2941: PUSH
2942: LD_INT 0
2944: DIFF
2945: ST_TO_ADDR
// if tmp < 15 then
2946: LD_VAR 0 5
2950: PUSH
2951: LD_INT 15
2953: LESS
2954: IFFALSE 3042
// for i = 15 downto tmp do
2956: LD_ADDR_VAR 0 2
2960: PUSH
2961: DOUBLE
2962: LD_INT 15
2964: INC
2965: ST_TO_ADDR
2966: LD_VAR 0 5
2970: PUSH
2971: FOR_DOWNTO
2972: IFFALSE 3040
// begin uc_nation := [ 1 , 3 ] [ rand ( 1 , 2 ) ] ;
2974: LD_ADDR_OWVAR 21
2978: PUSH
2979: LD_INT 1
2981: PUSH
2982: LD_INT 3
2984: PUSH
2985: EMPTY
2986: LIST
2987: LIST
2988: PUSH
2989: LD_INT 1
2991: PPUSH
2992: LD_INT 2
2994: PPUSH
2995: CALL_OW 12
2999: ARRAY
3000: ST_TO_ADDR
// PrepareHuman ( false , rand ( 1 , 4 ) , 8 ) ;
3001: LD_INT 0
3003: PPUSH
3004: LD_INT 1
3006: PPUSH
3007: LD_INT 4
3009: PPUSH
3010: CALL_OW 12
3014: PPUSH
3015: LD_INT 8
3017: PPUSH
3018: CALL_OW 380
// tmp := tmp ^ CreateHuman ;
3022: LD_ADDR_VAR 0 5
3026: PUSH
3027: LD_VAR 0 5
3031: PUSH
3032: CALL_OW 44
3036: ADD
3037: ST_TO_ADDR
// end ;
3038: GO 2971
3040: POP
3041: POP
// if not debug then
3042: LD_EXP 1
3046: NOT
3047: IFFALSE 3227
// selected = CharacterSelection (  , [ 14 , 14 , 13 , 12 ] [ Difficulty ] , [ 14 , 14 , 13 , 12 ] [ Difficulty ] , [ sel_change_class , JMM , Burlak , Roth , Joan , Denis , Gossudarov , sel_not_hired , sel_changeable , sel_change_class ] ^ tmp , [ class_soldier , class_scientistic , [ class_engineer , 1 ] , class_mechanic , [ class_sniper , 0 , 3 ] , [ class_bazooker , 0 , 3 ] ] ) else
3049: LD_ADDR_VAR 0 4
3053: PUSH
3054: LD_STRING 
3056: PPUSH
3057: LD_INT 14
3059: PUSH
3060: LD_INT 14
3062: PUSH
3063: LD_INT 13
3065: PUSH
3066: LD_INT 12
3068: PUSH
3069: EMPTY
3070: LIST
3071: LIST
3072: LIST
3073: LIST
3074: PUSH
3075: LD_OWVAR 67
3079: ARRAY
3080: PPUSH
3081: LD_INT 14
3083: PUSH
3084: LD_INT 14
3086: PUSH
3087: LD_INT 13
3089: PUSH
3090: LD_INT 12
3092: PUSH
3093: EMPTY
3094: LIST
3095: LIST
3096: LIST
3097: LIST
3098: PUSH
3099: LD_OWVAR 67
3103: ARRAY
3104: PPUSH
3105: LD_INT -5
3107: PUSH
3108: LD_EXP 19
3112: PUSH
3113: LD_EXP 51
3117: PUSH
3118: LD_EXP 20
3122: PUSH
3123: LD_EXP 34
3127: PUSH
3128: LD_EXP 25
3132: PUSH
3133: LD_EXP 37
3137: PUSH
3138: LD_INT -2
3140: PUSH
3141: LD_INT -3
3143: PUSH
3144: LD_INT -5
3146: PUSH
3147: EMPTY
3148: LIST
3149: LIST
3150: LIST
3151: LIST
3152: LIST
3153: LIST
3154: LIST
3155: LIST
3156: LIST
3157: LIST
3158: PUSH
3159: LD_VAR 0 5
3163: ADD
3164: PPUSH
3165: LD_INT 1
3167: PUSH
3168: LD_INT 4
3170: PUSH
3171: LD_INT 2
3173: PUSH
3174: LD_INT 1
3176: PUSH
3177: EMPTY
3178: LIST
3179: LIST
3180: PUSH
3181: LD_INT 3
3183: PUSH
3184: LD_INT 5
3186: PUSH
3187: LD_INT 0
3189: PUSH
3190: LD_INT 3
3192: PUSH
3193: EMPTY
3194: LIST
3195: LIST
3196: LIST
3197: PUSH
3198: LD_INT 9
3200: PUSH
3201: LD_INT 0
3203: PUSH
3204: LD_INT 3
3206: PUSH
3207: EMPTY
3208: LIST
3209: LIST
3210: LIST
3211: PUSH
3212: EMPTY
3213: LIST
3214: LIST
3215: LIST
3216: LIST
3217: LIST
3218: LIST
3219: PPUSH
3220: CALL_OW 42
3224: ST_TO_ADDR
3225: GO 3276
// selected := [ Titov , Fadeev , Dolgov , Petrosyan , Scholtze , Oblukov , Kapitsova ] ;
3227: LD_ADDR_VAR 0 4
3231: PUSH
3232: LD_EXP 39
3236: PUSH
3237: LD_EXP 40
3241: PUSH
3242: LD_EXP 41
3246: PUSH
3247: LD_EXP 42
3251: PUSH
3252: LD_EXP 43
3256: PUSH
3257: LD_EXP 44
3261: PUSH
3262: LD_EXP 45
3266: PUSH
3267: EMPTY
3268: LIST
3269: LIST
3270: LIST
3271: LIST
3272: LIST
3273: LIST
3274: LIST
3275: ST_TO_ADDR
// allianceTeam := tmp diff selected ;
3276: LD_ADDR_EXP 17
3280: PUSH
3281: LD_VAR 0 5
3285: PUSH
3286: LD_VAR 0 4
3290: DIFF
3291: ST_TO_ADDR
// uc_nation := 1 ;
3292: LD_ADDR_OWVAR 21
3296: PUSH
3297: LD_INT 1
3299: ST_TO_ADDR
// PrepareVehicle ( us_morphling , engine_siberite , control_manual , us_heavy_gun , 100 ) ;
3300: LD_INT 5
3302: PPUSH
3303: LD_INT 3
3305: PPUSH
3306: LD_INT 1
3308: PPUSH
3309: LD_INT 6
3311: PPUSH
3312: LD_INT 100
3314: PPUSH
3315: CALL 56890 0 5
// veh := CreateVehicle ;
3319: LD_ADDR_VAR 0 3
3323: PUSH
3324: CALL_OW 45
3328: ST_TO_ADDR
// SetMark ( veh , - 7 ) ;
3329: LD_VAR 0 3
3333: PPUSH
3334: LD_INT 7
3336: NEG
3337: PPUSH
3338: CALL_OW 242
// SetDir ( veh , 3 ) ;
3342: LD_VAR 0 3
3346: PPUSH
3347: LD_INT 3
3349: PPUSH
3350: CALL_OW 233
// PlaceUnitArea ( veh , allianceJMMSpawnArea , false ) ;
3354: LD_VAR 0 3
3358: PPUSH
3359: LD_INT 31
3361: PPUSH
3362: LD_INT 0
3364: PPUSH
3365: CALL_OW 49
// PlaceHumanInUnit ( JMM , veh ) ;
3369: LD_EXP 19
3373: PPUSH
3374: LD_VAR 0 3
3378: PPUSH
3379: CALL_OW 52
// if Joan then
3383: LD_EXP 34
3387: IFFALSE 3459
// begin PrepareVehicle ( us_medium_tracked , engine_siberite , control_manual , us_radar , 100 ) ;
3389: LD_INT 3
3391: PPUSH
3392: LD_INT 3
3394: PPUSH
3395: LD_INT 1
3397: PPUSH
3398: LD_INT 11
3400: PPUSH
3401: LD_INT 100
3403: PPUSH
3404: CALL 56890 0 5
// veh := CreateVehicle ;
3408: LD_ADDR_VAR 0 3
3412: PUSH
3413: CALL_OW 45
3417: ST_TO_ADDR
// SetDir ( veh , 3 ) ;
3418: LD_VAR 0 3
3422: PPUSH
3423: LD_INT 3
3425: PPUSH
3426: CALL_OW 233
// PlaceUnitArea ( veh , allianceSpawnArea , false ) ;
3430: LD_VAR 0 3
3434: PPUSH
3435: LD_INT 30
3437: PPUSH
3438: LD_INT 0
3440: PPUSH
3441: CALL_OW 49
// PlaceHumanInUnit ( Joan , veh ) ;
3445: LD_EXP 34
3449: PPUSH
3450: LD_VAR 0 3
3454: PPUSH
3455: CALL_OW 52
// end ; if Roth then
3459: LD_EXP 20
3463: IFFALSE 3535
// begin PrepareVehicle ( us_medium_tracked , engine_siberite , control_manual , us_radar , 100 ) ;
3465: LD_INT 3
3467: PPUSH
3468: LD_INT 3
3470: PPUSH
3471: LD_INT 1
3473: PPUSH
3474: LD_INT 11
3476: PPUSH
3477: LD_INT 100
3479: PPUSH
3480: CALL 56890 0 5
// veh := CreateVehicle ;
3484: LD_ADDR_VAR 0 3
3488: PUSH
3489: CALL_OW 45
3493: ST_TO_ADDR
// SetDir ( veh , 3 ) ;
3494: LD_VAR 0 3
3498: PPUSH
3499: LD_INT 3
3501: PPUSH
3502: CALL_OW 233
// PlaceUnitArea ( veh , allianceSpawnArea , false ) ;
3506: LD_VAR 0 3
3510: PPUSH
3511: LD_INT 30
3513: PPUSH
3514: LD_INT 0
3516: PPUSH
3517: CALL_OW 49
// PlaceHumanInUnit ( Roth , veh ) ;
3521: LD_EXP 20
3525: PPUSH
3526: LD_VAR 0 3
3530: PPUSH
3531: CALL_OW 52
// end ; if Denis then
3535: LD_EXP 25
3539: IFFALSE 3611
// begin PrepareVehicle ( us_morphling , engine_siberite , control_manual , us_laser , 100 ) ;
3541: LD_INT 5
3543: PPUSH
3544: LD_INT 3
3546: PPUSH
3547: LD_INT 1
3549: PPUSH
3550: LD_INT 9
3552: PPUSH
3553: LD_INT 100
3555: PPUSH
3556: CALL 56890 0 5
// veh := CreateVehicle ;
3560: LD_ADDR_VAR 0 3
3564: PUSH
3565: CALL_OW 45
3569: ST_TO_ADDR
// SetDir ( veh , 3 ) ;
3570: LD_VAR 0 3
3574: PPUSH
3575: LD_INT 3
3577: PPUSH
3578: CALL_OW 233
// PlaceUnitArea ( veh , allianceSpawnArea , false ) ;
3582: LD_VAR 0 3
3586: PPUSH
3587: LD_INT 30
3589: PPUSH
3590: LD_INT 0
3592: PPUSH
3593: CALL_OW 49
// PlaceHumanInUnit ( Denis , veh ) ;
3597: LD_EXP 25
3601: PPUSH
3602: LD_VAR 0 3
3606: PPUSH
3607: CALL_OW 52
// end ; uc_nation := 3 ;
3611: LD_ADDR_OWVAR 21
3615: PUSH
3616: LD_INT 3
3618: ST_TO_ADDR
// PrepareVehicle ( ru_medium_tracked , engine_siberite , control_manual , ru_rocket_launcher , 100 ) ;
3619: LD_INT 22
3621: PPUSH
3622: LD_INT 3
3624: PPUSH
3625: LD_INT 1
3627: PPUSH
3628: LD_INT 45
3630: PPUSH
3631: LD_INT 100
3633: PPUSH
3634: CALL 56890 0 5
// veh := CreateVehicle ;
3638: LD_ADDR_VAR 0 3
3642: PUSH
3643: CALL_OW 45
3647: ST_TO_ADDR
// SetMark ( veh , - 7 ) ;
3648: LD_VAR 0 3
3652: PPUSH
3653: LD_INT 7
3655: NEG
3656: PPUSH
3657: CALL_OW 242
// SetDir ( veh , 3 ) ;
3661: LD_VAR 0 3
3665: PPUSH
3666: LD_INT 3
3668: PPUSH
3669: CALL_OW 233
// PlaceUnitArea ( veh , allianceJMMSpawnArea , false ) ;
3673: LD_VAR 0 3
3677: PPUSH
3678: LD_INT 31
3680: PPUSH
3681: LD_INT 0
3683: PPUSH
3684: CALL_OW 49
// PlaceHumanInUnit ( Burlak , veh ) ;
3688: LD_EXP 51
3692: PPUSH
3693: LD_VAR 0 3
3697: PPUSH
3698: CALL_OW 52
// if Gossudarov then
3702: LD_EXP 37
3706: IFFALSE 3793
// begin PrepareVehicle ( ru_medium_tracked , engine_siberite , control_manual , ru_cargo_bay , 100 ) ;
3708: LD_INT 22
3710: PPUSH
3711: LD_INT 3
3713: PPUSH
3714: LD_INT 1
3716: PPUSH
3717: LD_INT 51
3719: PPUSH
3720: LD_INT 100
3722: PPUSH
3723: CALL 56890 0 5
// veh := CreateVehicle ;
3727: LD_ADDR_VAR 0 3
3731: PUSH
3732: CALL_OW 45
3736: ST_TO_ADDR
// SetDir ( veh , 3 ) ;
3737: LD_VAR 0 3
3741: PPUSH
3742: LD_INT 3
3744: PPUSH
3745: CALL_OW 233
// PlaceUnitArea ( veh , allianceSpawnArea , false ) ;
3749: LD_VAR 0 3
3753: PPUSH
3754: LD_INT 30
3756: PPUSH
3757: LD_INT 0
3759: PPUSH
3760: CALL_OW 49
// PlaceHumanInUnit ( Gossudarov , veh ) ;
3764: LD_EXP 37
3768: PPUSH
3769: LD_VAR 0 3
3773: PPUSH
3774: CALL_OW 52
// SetCargo ( veh , mat_cans , 100 ) ;
3778: LD_VAR 0 3
3782: PPUSH
3783: LD_INT 1
3785: PPUSH
3786: LD_INT 100
3788: PPUSH
3789: CALL_OW 290
// end ; for i in selected do
3793: LD_ADDR_VAR 0 2
3797: PUSH
3798: LD_VAR 0 4
3802: PUSH
3803: FOR_IN
3804: IFFALSE 4362
// begin uc_nation := GetNation ( i ) ;
3806: LD_ADDR_OWVAR 21
3810: PUSH
3811: LD_VAR 0 2
3815: PPUSH
3816: CALL_OW 248
3820: ST_TO_ADDR
// if i in [ Lisa , Donaldson , Cyrus , Bobby ] then
3821: LD_VAR 0 2
3825: PUSH
3826: LD_EXP 21
3830: PUSH
3831: LD_EXP 22
3835: PUSH
3836: LD_EXP 24
3840: PUSH
3841: LD_EXP 23
3845: PUSH
3846: EMPTY
3847: LIST
3848: LIST
3849: LIST
3850: LIST
3851: IN
3852: IFFALSE 3875
// PrepareVehicle ( us_morphling , engine_siberite , control_manual , us_heavy_gun , 100 ) else
3854: LD_INT 5
3856: PPUSH
3857: LD_INT 3
3859: PPUSH
3860: LD_INT 1
3862: PPUSH
3863: LD_INT 6
3865: PPUSH
3866: LD_INT 100
3868: PPUSH
3869: CALL 56890 0 5
3873: GO 4309
// if i in [ Oblukov , Kuzmov , Petrovova , Titov ] then
3875: LD_VAR 0 2
3879: PUSH
3880: LD_EXP 44
3884: PUSH
3885: LD_EXP 49
3889: PUSH
3890: LD_EXP 47
3894: PUSH
3895: LD_EXP 39
3899: PUSH
3900: EMPTY
3901: LIST
3902: LIST
3903: LIST
3904: LIST
3905: IN
3906: IFFALSE 3937
// PrepareVehicle ( ru_heavy_tracked , engine_combustion , control_manual , ru_heavy_gun , rand ( 65 , 75 ) ) else
3908: LD_INT 24
3910: PPUSH
3911: LD_INT 1
3913: PPUSH
3914: LD_INT 1
3916: PPUSH
3917: LD_INT 46
3919: PPUSH
3920: LD_INT 65
3922: PPUSH
3923: LD_INT 75
3925: PPUSH
3926: CALL_OW 12
3930: PPUSH
3931: CALL 56890 0 5
3935: GO 4309
// if i = Karamazov then
3937: LD_VAR 0 2
3941: PUSH
3942: LD_EXP 50
3946: EQUAL
3947: IFFALSE 3970
// PrepareVehicle ( ru_medium_tracked , engine_siberite , control_manual , ru_crane , 100 ) else
3949: LD_INT 22
3951: PPUSH
3952: LD_INT 3
3954: PPUSH
3955: LD_INT 1
3957: PPUSH
3958: LD_INT 52
3960: PPUSH
3961: LD_INT 100
3963: PPUSH
3964: CALL 56890 0 5
3968: GO 4309
// if i = Brown then
3970: LD_VAR 0 2
3974: PUSH
3975: LD_EXP 26
3979: EQUAL
3980: IFFALSE 4003
// PrepareVehicle ( us_medium_tracked , engine_siberite , control_manual , us_crane , 100 ) else
3982: LD_INT 3
3984: PPUSH
3985: LD_INT 3
3987: PPUSH
3988: LD_INT 1
3990: PPUSH
3991: LD_INT 13
3993: PPUSH
3994: LD_INT 100
3996: PPUSH
3997: CALL 56890 0 5
4001: GO 4309
// if uc_nation = nation_american then
4003: LD_OWVAR 21
4007: PUSH
4008: LD_INT 1
4010: EQUAL
4011: IFFALSE 4162
// begin PrepareVehicle ( [ us_medium_tracked , us_morphling , us_morphling ] [ uc_nation mod 3 + 1 ] , [ engine_combustion , engine_siberite , engine_combustion ] [ uc_nation mod 3 + 1 ] , control_manual , [ [ us_radar , us_gatling_gun , us_double_gun ] , [ us_heavy_gun , us_rocket_launcher , us_laser ] , [ us_heavy_gun , us_laser , us_cargo_bay ] ] [ uc_nation mod 3 + 1 ] [ rand ( 1 , 3 ) ] , rand ( 65 , 75 ) ) ;
4013: LD_INT 3
4015: PUSH
4016: LD_INT 5
4018: PUSH
4019: LD_INT 5
4021: PUSH
4022: EMPTY
4023: LIST
4024: LIST
4025: LIST
4026: PUSH
4027: LD_OWVAR 21
4031: PUSH
4032: LD_INT 3
4034: MOD
4035: PUSH
4036: LD_INT 1
4038: PLUS
4039: ARRAY
4040: PPUSH
4041: LD_INT 1
4043: PUSH
4044: LD_INT 3
4046: PUSH
4047: LD_INT 1
4049: PUSH
4050: EMPTY
4051: LIST
4052: LIST
4053: LIST
4054: PUSH
4055: LD_OWVAR 21
4059: PUSH
4060: LD_INT 3
4062: MOD
4063: PUSH
4064: LD_INT 1
4066: PLUS
4067: ARRAY
4068: PPUSH
4069: LD_INT 1
4071: PPUSH
4072: LD_INT 11
4074: PUSH
4075: LD_INT 4
4077: PUSH
4078: LD_INT 5
4080: PUSH
4081: EMPTY
4082: LIST
4083: LIST
4084: LIST
4085: PUSH
4086: LD_INT 6
4088: PUSH
4089: LD_INT 7
4091: PUSH
4092: LD_INT 9
4094: PUSH
4095: EMPTY
4096: LIST
4097: LIST
4098: LIST
4099: PUSH
4100: LD_INT 6
4102: PUSH
4103: LD_INT 9
4105: PUSH
4106: LD_INT 12
4108: PUSH
4109: EMPTY
4110: LIST
4111: LIST
4112: LIST
4113: PUSH
4114: EMPTY
4115: LIST
4116: LIST
4117: LIST
4118: PUSH
4119: LD_OWVAR 21
4123: PUSH
4124: LD_INT 3
4126: MOD
4127: PUSH
4128: LD_INT 1
4130: PLUS
4131: ARRAY
4132: PUSH
4133: LD_INT 1
4135: PPUSH
4136: LD_INT 3
4138: PPUSH
4139: CALL_OW 12
4143: ARRAY
4144: PPUSH
4145: LD_INT 65
4147: PPUSH
4148: LD_INT 75
4150: PPUSH
4151: CALL_OW 12
4155: PPUSH
4156: CALL 56890 0 5
// end else
4160: GO 4309
// begin PrepareVehicle ( [ ru_medium_tracked , ru_heavy_wheeled , ru_heavy_wheeled ] [ uc_nation mod 3 + 1 ] , [ engine_combustion , engine_siberite , engine_combustion ] [ uc_nation mod 3 + 1 ] , control_manual , [ [ ru_rocket_launcher , ru_gatling_gun , ru_gun ] , [ ru_heavy_gun , ru_rocket_launcher , ru_gun ] , [ ru_heavy_gun , ru_gatling_gun , ru_rocket_launcher ] ] [ uc_nation mod 3 + 1 ] [ rand ( 1 , 3 ) ] , rand ( 65 , 75 ) ) ;
4162: LD_INT 22
4164: PUSH
4165: LD_INT 23
4167: PUSH
4168: LD_INT 23
4170: PUSH
4171: EMPTY
4172: LIST
4173: LIST
4174: LIST
4175: PUSH
4176: LD_OWVAR 21
4180: PUSH
4181: LD_INT 3
4183: MOD
4184: PUSH
4185: LD_INT 1
4187: PLUS
4188: ARRAY
4189: PPUSH
4190: LD_INT 1
4192: PUSH
4193: LD_INT 3
4195: PUSH
4196: LD_INT 1
4198: PUSH
4199: EMPTY
4200: LIST
4201: LIST
4202: LIST
4203: PUSH
4204: LD_OWVAR 21
4208: PUSH
4209: LD_INT 3
4211: MOD
4212: PUSH
4213: LD_INT 1
4215: PLUS
4216: ARRAY
4217: PPUSH
4218: LD_INT 1
4220: PPUSH
4221: LD_INT 45
4223: PUSH
4224: LD_INT 43
4226: PUSH
4227: LD_INT 44
4229: PUSH
4230: EMPTY
4231: LIST
4232: LIST
4233: LIST
4234: PUSH
4235: LD_INT 46
4237: PUSH
4238: LD_INT 45
4240: PUSH
4241: LD_INT 44
4243: PUSH
4244: EMPTY
4245: LIST
4246: LIST
4247: LIST
4248: PUSH
4249: LD_INT 46
4251: PUSH
4252: LD_INT 43
4254: PUSH
4255: LD_INT 45
4257: PUSH
4258: EMPTY
4259: LIST
4260: LIST
4261: LIST
4262: PUSH
4263: EMPTY
4264: LIST
4265: LIST
4266: LIST
4267: PUSH
4268: LD_OWVAR 21
4272: PUSH
4273: LD_INT 3
4275: MOD
4276: PUSH
4277: LD_INT 1
4279: PLUS
4280: ARRAY
4281: PUSH
4282: LD_INT 1
4284: PPUSH
4285: LD_INT 3
4287: PPUSH
4288: CALL_OW 12
4292: ARRAY
4293: PPUSH
4294: LD_INT 65
4296: PPUSH
4297: LD_INT 75
4299: PPUSH
4300: CALL_OW 12
4304: PPUSH
4305: CALL 56890 0 5
// end ; veh := CreateVehicle ;
4309: LD_ADDR_VAR 0 3
4313: PUSH
4314: CALL_OW 45
4318: ST_TO_ADDR
// SetDir ( veh , 3 ) ;
4319: LD_VAR 0 3
4323: PPUSH
4324: LD_INT 3
4326: PPUSH
4327: CALL_OW 233
// PlaceUnitArea ( veh , allianceSpawnArea , false ) ;
4331: LD_VAR 0 3
4335: PPUSH
4336: LD_INT 30
4338: PPUSH
4339: LD_INT 0
4341: PPUSH
4342: CALL_OW 49
// PlaceHumanInUnit ( i , veh ) ;
4346: LD_VAR 0 2
4350: PPUSH
4351: LD_VAR 0 3
4355: PPUSH
4356: CALL_OW 52
// end ;
4360: GO 3803
4362: POP
4363: POP
// if artifactArCaptured then
4364: LD_EXP 9
4368: IFFALSE 4454
// begin uc_nation := nation_american ;
4370: LD_ADDR_OWVAR 21
4374: PUSH
4375: LD_INT 1
4377: ST_TO_ADDR
// PrepareVehicle ( us_medium_tracked , engine_siberite , control_computer , us_cargo_bay , 100 ) ;
4378: LD_INT 3
4380: PPUSH
4381: LD_INT 3
4383: PPUSH
4384: LD_INT 3
4386: PPUSH
4387: LD_INT 12
4389: PPUSH
4390: LD_INT 100
4392: PPUSH
4393: CALL 56890 0 5
// veh := CreateVehicle ;
4397: LD_ADDR_VAR 0 3
4401: PUSH
4402: CALL_OW 45
4406: ST_TO_ADDR
// SetDir ( veh , 3 ) ;
4407: LD_VAR 0 3
4411: PPUSH
4412: LD_INT 3
4414: PPUSH
4415: CALL_OW 233
// PlaceUnitXY ( veh , 198 , 22 , false ) ;
4419: LD_VAR 0 3
4423: PPUSH
4424: LD_INT 198
4426: PPUSH
4427: LD_INT 22
4429: PPUSH
4430: LD_INT 0
4432: PPUSH
4433: CALL_OW 48
// SetCargo ( veh , mat_artifact , 50 ) ;
4437: LD_VAR 0 3
4441: PPUSH
4442: LD_INT 4
4444: PPUSH
4445: LD_INT 50
4447: PPUSH
4448: CALL_OW 290
// end else
4452: GO 4473
// begin CreateResourcesXY ( mat_artifact , 5 , 267 , 226 , false ) ;
4454: LD_INT 4
4456: PPUSH
4457: LD_INT 5
4459: PPUSH
4460: LD_INT 267
4462: PPUSH
4463: LD_INT 226
4465: PPUSH
4466: LD_INT 0
4468: PPUSH
4469: CALL_OW 58
// end ; uc_nation := nation_american ;
4473: LD_ADDR_OWVAR 21
4477: PUSH
4478: LD_INT 1
4480: ST_TO_ADDR
// PrepareVehicle ( us_medium_tracked , engine_siberite , control_computer , us_cargo_bay , 100 ) ;
4481: LD_INT 3
4483: PPUSH
4484: LD_INT 3
4486: PPUSH
4487: LD_INT 3
4489: PPUSH
4490: LD_INT 12
4492: PPUSH
4493: LD_INT 100
4495: PPUSH
4496: CALL 56890 0 5
// veh := CreateVehicle ;
4500: LD_ADDR_VAR 0 3
4504: PUSH
4505: CALL_OW 45
4509: ST_TO_ADDR
// SetDir ( veh , 3 ) ;
4510: LD_VAR 0 3
4514: PPUSH
4515: LD_INT 3
4517: PPUSH
4518: CALL_OW 233
// PlaceUnitXY ( veh , 218 , 23 , false ) ;
4522: LD_VAR 0 3
4526: PPUSH
4527: LD_INT 218
4529: PPUSH
4530: LD_INT 23
4532: PPUSH
4533: LD_INT 0
4535: PPUSH
4536: CALL_OW 48
// SetCargo ( veh , mat_artifact , 30 ) ;
4540: LD_VAR 0 3
4544: PPUSH
4545: LD_INT 4
4547: PPUSH
4548: LD_INT 30
4550: PPUSH
4551: CALL_OW 290
// uc_nation := nation_russian ;
4555: LD_ADDR_OWVAR 21
4559: PUSH
4560: LD_INT 3
4562: ST_TO_ADDR
// PrepareVehicle ( ru_medium_tracked , engine_siberite , control_computer , ru_cargo_bay , 100 ) ;
4563: LD_INT 22
4565: PPUSH
4566: LD_INT 3
4568: PPUSH
4569: LD_INT 3
4571: PPUSH
4572: LD_INT 51
4574: PPUSH
4575: LD_INT 100
4577: PPUSH
4578: CALL 56890 0 5
// veh := CreateVehicle ;
4582: LD_ADDR_VAR 0 3
4586: PUSH
4587: CALL_OW 45
4591: ST_TO_ADDR
// SetDir ( veh , 3 ) ;
4592: LD_VAR 0 3
4596: PPUSH
4597: LD_INT 3
4599: PPUSH
4600: CALL_OW 233
// PlaceUnitXY ( veh , 214 , 20 , false ) ;
4604: LD_VAR 0 3
4608: PPUSH
4609: LD_INT 214
4611: PPUSH
4612: LD_INT 20
4614: PPUSH
4615: LD_INT 0
4617: PPUSH
4618: CALL_OW 48
// SetCargo ( veh , mat_artifact , 40 ) ;
4622: LD_VAR 0 3
4626: PPUSH
4627: LD_INT 4
4629: PPUSH
4630: LD_INT 40
4632: PPUSH
4633: CALL_OW 290
// end ;
4637: LD_VAR 0 1
4641: RET
// export function AllianceSupport ; var i , veh ; begin
4642: LD_INT 0
4644: PPUSH
4645: PPUSH
4646: PPUSH
// if not allianceTeam then
4647: LD_EXP 17
4651: NOT
4652: IFFALSE 4656
// exit ;
4654: GO 5062
// for i := 1 to 6 do
4656: LD_ADDR_VAR 0 2
4660: PUSH
4661: DOUBLE
4662: LD_INT 1
4664: DEC
4665: ST_TO_ADDR
4666: LD_INT 6
4668: PUSH
4669: FOR_TO
4670: IFFALSE 4966
// begin uc_side := 7 ;
4672: LD_ADDR_OWVAR 20
4676: PUSH
4677: LD_INT 7
4679: ST_TO_ADDR
// uc_nation := [ 1 , 3 ] [ i mod 2 + 1 ] ;
4680: LD_ADDR_OWVAR 21
4684: PUSH
4685: LD_INT 1
4687: PUSH
4688: LD_INT 3
4690: PUSH
4691: EMPTY
4692: LIST
4693: LIST
4694: PUSH
4695: LD_VAR 0 2
4699: PUSH
4700: LD_INT 2
4702: MOD
4703: PUSH
4704: LD_INT 1
4706: PLUS
4707: ARRAY
4708: ST_TO_ADDR
// if uc_nation = 1 then
4709: LD_OWVAR 21
4713: PUSH
4714: LD_INT 1
4716: EQUAL
4717: IFFALSE 4759
// PrepareVehicle ( us_morphling , engine_siberite , control_manual , [ us_heavy_gun , us_rocket_launcher ] [ rand ( 1 , 2 ) ] , 100 ) else
4719: LD_INT 5
4721: PPUSH
4722: LD_INT 3
4724: PPUSH
4725: LD_INT 1
4727: PPUSH
4728: LD_INT 6
4730: PUSH
4731: LD_INT 7
4733: PUSH
4734: EMPTY
4735: LIST
4736: LIST
4737: PUSH
4738: LD_INT 1
4740: PPUSH
4741: LD_INT 2
4743: PPUSH
4744: CALL_OW 12
4748: ARRAY
4749: PPUSH
4750: LD_INT 100
4752: PPUSH
4753: CALL 56890 0 5
4757: GO 4797
// PrepareVehicle ( ru_heavy_wheeled , engine_siberite , control_manual , [ ru_heavy_gun , ru_rocket ] [ rand ( 1 , 2 ) ] , 100 ) ;
4759: LD_INT 23
4761: PPUSH
4762: LD_INT 3
4764: PPUSH
4765: LD_INT 1
4767: PPUSH
4768: LD_INT 46
4770: PUSH
4771: LD_INT 47
4773: PUSH
4774: EMPTY
4775: LIST
4776: LIST
4777: PUSH
4778: LD_INT 1
4780: PPUSH
4781: LD_INT 2
4783: PPUSH
4784: CALL_OW 12
4788: ARRAY
4789: PPUSH
4790: LD_INT 100
4792: PPUSH
4793: CALL 56890 0 5
// if not allianceTeam then
4797: LD_EXP 17
4801: NOT
4802: IFFALSE 4806
// break ;
4804: GO 4966
// veh := CreateVehicle ;
4806: LD_ADDR_VAR 0 3
4810: PUSH
4811: CALL_OW 45
4815: ST_TO_ADDR
// SetDir ( veh , 4 ) ;
4816: LD_VAR 0 3
4820: PPUSH
4821: LD_INT 4
4823: PPUSH
4824: CALL_OW 233
// PlaceUnitArea ( veh , allianceSouthSupp , false ) ;
4828: LD_VAR 0 3
4832: PPUSH
4833: LD_INT 38
4835: PPUSH
4836: LD_INT 0
4838: PPUSH
4839: CALL_OW 49
// if GetSkill ( allianceTeam [ 1 ] , class_mechanic ) > 4 then
4843: LD_EXP 17
4847: PUSH
4848: LD_INT 1
4850: ARRAY
4851: PPUSH
4852: LD_INT 3
4854: PPUSH
4855: CALL_OW 259
4859: PUSH
4860: LD_INT 4
4862: GREATER
4863: IFFALSE 4881
// SetClass ( allianceTeam [ 1 ] , class_mechanic ) ;
4865: LD_EXP 17
4869: PUSH
4870: LD_INT 1
4872: ARRAY
4873: PPUSH
4874: LD_INT 3
4876: PPUSH
4877: CALL_OW 336
// if GetSkill ( allianceTeam [ 1 ] , class_scientistic ) > 8 then
4881: LD_EXP 17
4885: PUSH
4886: LD_INT 1
4888: ARRAY
4889: PPUSH
4890: LD_INT 4
4892: PPUSH
4893: CALL_OW 259
4897: PUSH
4898: LD_INT 8
4900: GREATER
4901: IFFALSE 4919
// SetClass ( allianceTeam [ 1 ] , class_scientistic ) ;
4903: LD_EXP 17
4907: PUSH
4908: LD_INT 1
4910: ARRAY
4911: PPUSH
4912: LD_INT 4
4914: PPUSH
4915: CALL_OW 336
// PlaceHumanInUnit ( allianceTeam [ 1 ] , veh ) ;
4919: LD_EXP 17
4923: PUSH
4924: LD_INT 1
4926: ARRAY
4927: PPUSH
4928: LD_VAR 0 3
4932: PPUSH
4933: CALL_OW 52
// allianceTeam := Delete ( allianceTeam , 1 ) ;
4937: LD_ADDR_EXP 17
4941: PUSH
4942: LD_EXP 17
4946: PPUSH
4947: LD_INT 1
4949: PPUSH
4950: CALL_OW 3
4954: ST_TO_ADDR
// ComHold ( veh ) ;
4955: LD_VAR 0 3
4959: PPUSH
4960: CALL_OW 140
// end ;
4964: GO 4669
4966: POP
4967: POP
// uc_side := 7 ;
4968: LD_ADDR_OWVAR 20
4972: PUSH
4973: LD_INT 7
4975: ST_TO_ADDR
// uc_nation := 1 ;
4976: LD_ADDR_OWVAR 21
4980: PUSH
4981: LD_INT 1
4983: ST_TO_ADDR
// PrepareVehicle ( us_morphling , engine_siberite , control_computer , us_radar , 100 ) ;
4984: LD_INT 5
4986: PPUSH
4987: LD_INT 3
4989: PPUSH
4990: LD_INT 3
4992: PPUSH
4993: LD_INT 11
4995: PPUSH
4996: LD_INT 100
4998: PPUSH
4999: CALL 56890 0 5
// veh := CreateVehicle ;
5003: LD_ADDR_VAR 0 3
5007: PUSH
5008: CALL_OW 45
5012: ST_TO_ADDR
// SetDir ( veh , 4 ) ;
5013: LD_VAR 0 3
5017: PPUSH
5018: LD_INT 4
5020: PPUSH
5021: CALL_OW 233
// PlaceUnitXY ( veh , 305 , 218 , false ) ;
5025: LD_VAR 0 3
5029: PPUSH
5030: LD_INT 305
5032: PPUSH
5033: LD_INT 218
5035: PPUSH
5036: LD_INT 0
5038: PPUSH
5039: CALL_OW 48
// ComHold ( veh ) ;
5043: LD_VAR 0 3
5047: PPUSH
5048: CALL_OW 140
// CenterNowOnXY ( 313 , 220 ) ;
5052: LD_INT 313
5054: PPUSH
5055: LD_INT 220
5057: PPUSH
5058: CALL_OW 86
// end ; end_of_file
5062: LD_VAR 0 1
5066: RET
// export Powell ; export function PrepareAmerican ; var i , b , veh , cl , tmp , depot , lab , armoury , workshop ; begin
5067: LD_INT 0
5069: PPUSH
5070: PPUSH
5071: PPUSH
5072: PPUSH
5073: PPUSH
5074: PPUSH
5075: PPUSH
5076: PPUSH
5077: PPUSH
5078: PPUSH
// InitHc ;
5079: CALL_OW 19
// uc_side := 1 ;
5083: LD_ADDR_OWVAR 20
5087: PUSH
5088: LD_INT 1
5090: ST_TO_ADDR
// uc_nation := 1 ;
5091: LD_ADDR_OWVAR 21
5095: PUSH
5096: LD_INT 1
5098: ST_TO_ADDR
// for i in FilterAllUnits ( [ [ f_side , 1 ] , [ f_type , unit_building ] ] ) do
5099: LD_ADDR_VAR 0 2
5103: PUSH
5104: LD_INT 22
5106: PUSH
5107: LD_INT 1
5109: PUSH
5110: EMPTY
5111: LIST
5112: LIST
5113: PUSH
5114: LD_INT 21
5116: PUSH
5117: LD_INT 3
5119: PUSH
5120: EMPTY
5121: LIST
5122: LIST
5123: PUSH
5124: EMPTY
5125: LIST
5126: LIST
5127: PPUSH
5128: CALL_OW 69
5132: PUSH
5133: FOR_IN
5134: IFFALSE 5150
// SetBLevel ( i , 10 ) ;
5136: LD_VAR 0 2
5140: PPUSH
5141: LD_INT 10
5143: PPUSH
5144: CALL_OW 241
5148: GO 5133
5150: POP
5151: POP
// SetResourceType ( GetBase ( am_depot ) , mat_cans , 7500 ) ;
5152: LD_INT 387
5154: PPUSH
5155: CALL_OW 274
5159: PPUSH
5160: LD_INT 1
5162: PPUSH
5163: LD_INT 7500
5165: PPUSH
5166: CALL_OW 277
// SetResourceType ( GetBase ( am_depot ) , mat_oil , 4000 ) ;
5170: LD_INT 387
5172: PPUSH
5173: CALL_OW 274
5177: PPUSH
5178: LD_INT 2
5180: PPUSH
5181: LD_INT 4000
5183: PPUSH
5184: CALL_OW 277
// SetResourceType ( GetBase ( am_depot ) , mat_siberit , 50 ) ;
5188: LD_INT 387
5190: PPUSH
5191: CALL_OW 274
5195: PPUSH
5196: LD_INT 3
5198: PPUSH
5199: LD_INT 50
5201: PPUSH
5202: CALL_OW 277
// SetResourceType ( GetBase ( am_depot2 ) , mat_cans , 5500 ) ;
5206: LD_INT 476
5208: PPUSH
5209: CALL_OW 274
5213: PPUSH
5214: LD_INT 1
5216: PPUSH
5217: LD_INT 5500
5219: PPUSH
5220: CALL_OW 277
// SetResourceType ( GetBase ( am_depot2 ) , mat_oil , 4000 ) ;
5224: LD_INT 476
5226: PPUSH
5227: CALL_OW 274
5231: PPUSH
5232: LD_INT 2
5234: PPUSH
5235: LD_INT 4000
5237: PPUSH
5238: CALL_OW 277
// SetResourceType ( GetBase ( am_depot2 ) , mat_siberit , 10 ) ;
5242: LD_INT 476
5244: PPUSH
5245: CALL_OW 274
5249: PPUSH
5250: LD_INT 3
5252: PPUSH
5253: LD_INT 10
5255: PPUSH
5256: CALL_OW 277
// Powell := NewCharacter ( Powell ) ;
5260: LD_ADDR_EXP 54
5264: PUSH
5265: LD_STRING Powell
5267: PPUSH
5268: CALL_OW 25
5272: ST_TO_ADDR
// PlaceHumanInUnit ( Powell , am_depot ) ;
5273: LD_EXP 54
5277: PPUSH
5278: LD_INT 387
5280: PPUSH
5281: CALL_OW 52
// tmp := [ ] ;
5285: LD_ADDR_VAR 0 6
5289: PUSH
5290: EMPTY
5291: ST_TO_ADDR
// Lisa := PrepareUnit ( Lisa , ( not debug ) , 12p_ ) ;
5292: LD_ADDR_EXP 21
5296: PUSH
5297: LD_STRING Lisa
5299: PPUSH
5300: LD_EXP 1
5304: NOT
5305: PPUSH
5306: LD_STRING 12p_
5308: PPUSH
5309: CALL 52026 0 3
5313: ST_TO_ADDR
// if Lisa then
5314: LD_EXP 21
5318: IFFALSE 5336
// tmp := tmp ^ Lisa ;
5320: LD_ADDR_VAR 0 6
5324: PUSH
5325: LD_VAR 0 6
5329: PUSH
5330: LD_EXP 21
5334: ADD
5335: ST_TO_ADDR
// Donaldson := PrepareUnit ( Donaldson , ( not debug ) , 12p_ ) ;
5336: LD_ADDR_EXP 22
5340: PUSH
5341: LD_STRING Donaldson
5343: PPUSH
5344: LD_EXP 1
5348: NOT
5349: PPUSH
5350: LD_STRING 12p_
5352: PPUSH
5353: CALL 52026 0 3
5357: ST_TO_ADDR
// if Donaldson then
5358: LD_EXP 22
5362: IFFALSE 5380
// tmp := tmp ^ Donaldson ;
5364: LD_ADDR_VAR 0 6
5368: PUSH
5369: LD_VAR 0 6
5373: PUSH
5374: LD_EXP 22
5378: ADD
5379: ST_TO_ADDR
// Bobby := PrepareUnit ( Bobby , ( not debug ) , 12p_ ) ;
5380: LD_ADDR_EXP 23
5384: PUSH
5385: LD_STRING Bobby
5387: PPUSH
5388: LD_EXP 1
5392: NOT
5393: PPUSH
5394: LD_STRING 12p_
5396: PPUSH
5397: CALL 52026 0 3
5401: ST_TO_ADDR
// if Bobby then
5402: LD_EXP 23
5406: IFFALSE 5424
// tmp := tmp ^ Bobby ;
5408: LD_ADDR_VAR 0 6
5412: PUSH
5413: LD_VAR 0 6
5417: PUSH
5418: LD_EXP 23
5422: ADD
5423: ST_TO_ADDR
// Cyrus := PrepareUnit ( Cyrus , ( not debug ) , 12p_ ) ;
5424: LD_ADDR_EXP 24
5428: PUSH
5429: LD_STRING Cyrus
5431: PPUSH
5432: LD_EXP 1
5436: NOT
5437: PPUSH
5438: LD_STRING 12p_
5440: PPUSH
5441: CALL 52026 0 3
5445: ST_TO_ADDR
// if Cyrus then
5446: LD_EXP 24
5450: IFFALSE 5468
// tmp := tmp ^ Cyrus ;
5452: LD_ADDR_VAR 0 6
5456: PUSH
5457: LD_VAR 0 6
5461: PUSH
5462: LD_EXP 24
5466: ADD
5467: ST_TO_ADDR
// Brown := PrepareUnit ( Brown , ( not debug ) , 12p_ ) ;
5468: LD_ADDR_EXP 26
5472: PUSH
5473: LD_STRING Brown
5475: PPUSH
5476: LD_EXP 1
5480: NOT
5481: PPUSH
5482: LD_STRING 12p_
5484: PPUSH
5485: CALL 52026 0 3
5489: ST_TO_ADDR
// if Brown then
5490: LD_EXP 26
5494: IFFALSE 5512
// tmp := tmp ^ Brown ;
5496: LD_ADDR_VAR 0 6
5500: PUSH
5501: LD_VAR 0 6
5505: PUSH
5506: LD_EXP 26
5510: ADD
5511: ST_TO_ADDR
// Gladstone := PrepareUnit ( Gladstone , ( not debug ) , 12p_ ) ;
5512: LD_ADDR_EXP 27
5516: PUSH
5517: LD_STRING Gladstone
5519: PPUSH
5520: LD_EXP 1
5524: NOT
5525: PPUSH
5526: LD_STRING 12p_
5528: PPUSH
5529: CALL 52026 0 3
5533: ST_TO_ADDR
// if Gladstone then
5534: LD_EXP 27
5538: IFFALSE 5556
// tmp := tmp ^ Gladstone ;
5540: LD_ADDR_VAR 0 6
5544: PUSH
5545: LD_VAR 0 6
5549: PUSH
5550: LD_EXP 27
5554: ADD
5555: ST_TO_ADDR
// Houten := PrepareUnit ( Houten , ( not debug ) , 12p_ ) ;
5556: LD_ADDR_EXP 28
5560: PUSH
5561: LD_STRING Houten
5563: PPUSH
5564: LD_EXP 1
5568: NOT
5569: PPUSH
5570: LD_STRING 12p_
5572: PPUSH
5573: CALL 52026 0 3
5577: ST_TO_ADDR
// if Houten then
5578: LD_EXP 28
5582: IFFALSE 5600
// tmp := tmp ^ Houten ;
5584: LD_ADDR_VAR 0 6
5588: PUSH
5589: LD_VAR 0 6
5593: PUSH
5594: LD_EXP 28
5598: ADD
5599: ST_TO_ADDR
// Cornel := PrepareUnit ( Cornel , ( not debug ) , 12p_ ) ;
5600: LD_ADDR_EXP 29
5604: PUSH
5605: LD_STRING Cornel
5607: PPUSH
5608: LD_EXP 1
5612: NOT
5613: PPUSH
5614: LD_STRING 12p_
5616: PPUSH
5617: CALL 52026 0 3
5621: ST_TO_ADDR
// if Cornel then
5622: LD_EXP 29
5626: IFFALSE 5644
// tmp := tmp ^ Cornel ;
5628: LD_ADDR_VAR 0 6
5632: PUSH
5633: LD_VAR 0 6
5637: PUSH
5638: LD_EXP 29
5642: ADD
5643: ST_TO_ADDR
// Gary := PrepareUnit ( Gary , ( not debug ) , 12p_ ) ;
5644: LD_ADDR_EXP 30
5648: PUSH
5649: LD_STRING Gary
5651: PPUSH
5652: LD_EXP 1
5656: NOT
5657: PPUSH
5658: LD_STRING 12p_
5660: PPUSH
5661: CALL 52026 0 3
5665: ST_TO_ADDR
// if Gary then
5666: LD_EXP 30
5670: IFFALSE 5688
// tmp := tmp ^ Gary ;
5672: LD_ADDR_VAR 0 6
5676: PUSH
5677: LD_VAR 0 6
5681: PUSH
5682: LD_EXP 30
5686: ADD
5687: ST_TO_ADDR
// Kikuchi := PrepareUnit ( Kikuchi , ( not debug ) , 12p_ ) ;
5688: LD_ADDR_EXP 32
5692: PUSH
5693: LD_STRING Kikuchi
5695: PPUSH
5696: LD_EXP 1
5700: NOT
5701: PPUSH
5702: LD_STRING 12p_
5704: PPUSH
5705: CALL 52026 0 3
5709: ST_TO_ADDR
// if Kikuchi then
5710: LD_EXP 32
5714: IFFALSE 5732
// tmp := tmp ^ Kikuchi ;
5716: LD_ADDR_VAR 0 6
5720: PUSH
5721: LD_VAR 0 6
5725: PUSH
5726: LD_EXP 32
5730: ADD
5731: ST_TO_ADDR
// tmp := tmp union CreateCharacterSet ( 12p_others ) ;
5732: LD_ADDR_VAR 0 6
5736: PUSH
5737: LD_VAR 0 6
5741: PUSH
5742: LD_STRING 12p_others
5744: PPUSH
5745: CALL_OW 31
5749: UNION
5750: ST_TO_ADDR
// if tmp < 36 then
5751: LD_VAR 0 6
5755: PUSH
5756: LD_INT 36
5758: LESS
5759: IFFALSE 5826
// for i = 1 to 36 - tmp do
5761: LD_ADDR_VAR 0 2
5765: PUSH
5766: DOUBLE
5767: LD_INT 1
5769: DEC
5770: ST_TO_ADDR
5771: LD_INT 36
5773: PUSH
5774: LD_VAR 0 6
5778: MINUS
5779: PUSH
5780: FOR_TO
5781: IFFALSE 5824
// begin PrepareHuman ( sex_male , i mod 4 + 1 , 10 ) ;
5783: LD_INT 1
5785: PPUSH
5786: LD_VAR 0 2
5790: PUSH
5791: LD_INT 4
5793: MOD
5794: PUSH
5795: LD_INT 1
5797: PLUS
5798: PPUSH
5799: LD_INT 10
5801: PPUSH
5802: CALL_OW 380
// tmp := tmp ^ CreateHuman ;
5806: LD_ADDR_VAR 0 6
5810: PUSH
5811: LD_VAR 0 6
5815: PUSH
5816: CALL_OW 44
5820: ADD
5821: ST_TO_ADDR
// end ;
5822: GO 5780
5824: POP
5825: POP
// for i in tmp do
5826: LD_ADDR_VAR 0 2
5830: PUSH
5831: LD_VAR 0 6
5835: PUSH
5836: FOR_IN
5837: IFFALSE 5862
// PlaceUnitXYR ( i , 62 , 93 , 9 , false ) ;
5839: LD_VAR 0 2
5843: PPUSH
5844: LD_INT 62
5846: PPUSH
5847: LD_INT 93
5849: PPUSH
5850: LD_INT 9
5852: PPUSH
5853: LD_INT 0
5855: PPUSH
5856: CALL_OW 50
5860: GO 5836
5862: POP
5863: POP
// mc_bases := Replace ( mc_bases , 4 , FilterAllUnits ( [ f_side , 1 ] ) diff Powell ) ;
5864: LD_ADDR_EXP 95
5868: PUSH
5869: LD_EXP 95
5873: PPUSH
5874: LD_INT 4
5876: PPUSH
5877: LD_INT 22
5879: PUSH
5880: LD_INT 1
5882: PUSH
5883: EMPTY
5884: LIST
5885: LIST
5886: PPUSH
5887: CALL_OW 69
5891: PUSH
5892: LD_EXP 54
5896: DIFF
5897: PPUSH
5898: CALL_OW 1
5902: ST_TO_ADDR
// uc_side := 0 ;
5903: LD_ADDR_OWVAR 20
5907: PUSH
5908: LD_INT 0
5910: ST_TO_ADDR
// uc_nation := 0 ;
5911: LD_ADDR_OWVAR 21
5915: PUSH
5916: LD_INT 0
5918: ST_TO_ADDR
// for i = 1 to 4 do
5919: LD_ADDR_VAR 0 2
5923: PUSH
5924: DOUBLE
5925: LD_INT 1
5927: DEC
5928: ST_TO_ADDR
5929: LD_INT 4
5931: PUSH
5932: FOR_TO
5933: IFFALSE 5964
// begin InitHc ;
5935: CALL_OW 19
// hc_class := class_apeman ;
5939: LD_ADDR_OWVAR 28
5943: PUSH
5944: LD_INT 12
5946: ST_TO_ADDR
// PlaceUnitArea ( CreateHuman , powellApe , false ) ;
5947: CALL_OW 44
5951: PPUSH
5952: LD_INT 11
5954: PPUSH
5955: LD_INT 0
5957: PPUSH
5958: CALL_OW 49
// end ;
5962: GO 5932
5964: POP
5965: POP
// end ;
5966: LD_VAR 0 1
5970: RET
// every 11 11$30 trigger not americanDestroyed and not MC_GetVehicles ( 4 , true ) do var i , tmp , target ;
5971: LD_EXP 4
5975: NOT
5976: PUSH
5977: LD_INT 4
5979: PPUSH
5980: LD_INT 1
5982: PPUSH
5983: CALL 47038 0 2
5987: NOT
5988: AND
5989: IFFALSE 6761
5991: GO 5993
5993: DISABLE
5994: LD_INT 0
5996: PPUSH
5997: PPUSH
5998: PPUSH
// begin enable ;
5999: ENABLE
// if not FilterAllUnits ( [ [ f_side , 1 ] , [ f_nation , 1 ] , [ f_btype , b_factory ] ] ) then
6000: LD_INT 22
6002: PUSH
6003: LD_INT 1
6005: PUSH
6006: EMPTY
6007: LIST
6008: LIST
6009: PUSH
6010: LD_INT 23
6012: PUSH
6013: LD_INT 1
6015: PUSH
6016: EMPTY
6017: LIST
6018: LIST
6019: PUSH
6020: LD_INT 30
6022: PUSH
6023: LD_INT 3
6025: PUSH
6026: EMPTY
6027: LIST
6028: LIST
6029: PUSH
6030: EMPTY
6031: LIST
6032: LIST
6033: LIST
6034: PPUSH
6035: CALL_OW 69
6039: NOT
6040: IFFALSE 6044
// exit ;
6042: GO 6761
// if Prob ( 40 ) then
6044: LD_INT 40
6046: PPUSH
6047: CALL_OW 13
6051: IFFALSE 6178
// begin MC_InsertProduceList ( 4 , [ [ us_morphling , engine_combustion , control_remote , us_rocket_launcher ] , [ us_morphling , engine_combustion , control_remote , us_rocket_launcher ] , [ us_morphling , engine_combustion , control_remote , us_rocket_launcher ] , [ us_morphling , engine_combustion , control_remote , us_heavy_gun ] , [ us_morphling , engine_combustion , control_remote , us_heavy_gun ] , [ us_morphling , engine_combustion , control_remote , us_heavy_gun ] , ] ) ;
6053: LD_INT 4
6055: PPUSH
6056: LD_INT 5
6058: PUSH
6059: LD_INT 1
6061: PUSH
6062: LD_INT 2
6064: PUSH
6065: LD_INT 7
6067: PUSH
6068: EMPTY
6069: LIST
6070: LIST
6071: LIST
6072: LIST
6073: PUSH
6074: LD_INT 5
6076: PUSH
6077: LD_INT 1
6079: PUSH
6080: LD_INT 2
6082: PUSH
6083: LD_INT 7
6085: PUSH
6086: EMPTY
6087: LIST
6088: LIST
6089: LIST
6090: LIST
6091: PUSH
6092: LD_INT 5
6094: PUSH
6095: LD_INT 1
6097: PUSH
6098: LD_INT 2
6100: PUSH
6101: LD_INT 7
6103: PUSH
6104: EMPTY
6105: LIST
6106: LIST
6107: LIST
6108: LIST
6109: PUSH
6110: LD_INT 5
6112: PUSH
6113: LD_INT 1
6115: PUSH
6116: LD_INT 2
6118: PUSH
6119: LD_INT 6
6121: PUSH
6122: EMPTY
6123: LIST
6124: LIST
6125: LIST
6126: LIST
6127: PUSH
6128: LD_INT 5
6130: PUSH
6131: LD_INT 1
6133: PUSH
6134: LD_INT 2
6136: PUSH
6137: LD_INT 6
6139: PUSH
6140: EMPTY
6141: LIST
6142: LIST
6143: LIST
6144: LIST
6145: PUSH
6146: LD_INT 5
6148: PUSH
6149: LD_INT 1
6151: PUSH
6152: LD_INT 2
6154: PUSH
6155: LD_INT 6
6157: PUSH
6158: EMPTY
6159: LIST
6160: LIST
6161: LIST
6162: LIST
6163: PUSH
6164: EMPTY
6165: LIST
6166: LIST
6167: LIST
6168: LIST
6169: LIST
6170: LIST
6171: PPUSH
6172: CALL 45620 0 2
// end else
6176: GO 6301
// begin MC_InsertProduceList ( 4 , [ [ us_morphling , engine_combustion , control_remote , us_rocket_launcher ] , [ us_morphling , engine_combustion , control_remote , us_laser ] , [ us_morphling , engine_combustion , control_remote , us_laser ] , [ us_morphling , engine_combustion , control_remote , us_heavy_gun ] , [ us_morphling , engine_combustion , control_remote , us_heavy_gun ] , [ us_morphling , engine_combustion , control_remote , us_heavy_gun ] , ] ) ;
6178: LD_INT 4
6180: PPUSH
6181: LD_INT 5
6183: PUSH
6184: LD_INT 1
6186: PUSH
6187: LD_INT 2
6189: PUSH
6190: LD_INT 7
6192: PUSH
6193: EMPTY
6194: LIST
6195: LIST
6196: LIST
6197: LIST
6198: PUSH
6199: LD_INT 5
6201: PUSH
6202: LD_INT 1
6204: PUSH
6205: LD_INT 2
6207: PUSH
6208: LD_INT 9
6210: PUSH
6211: EMPTY
6212: LIST
6213: LIST
6214: LIST
6215: LIST
6216: PUSH
6217: LD_INT 5
6219: PUSH
6220: LD_INT 1
6222: PUSH
6223: LD_INT 2
6225: PUSH
6226: LD_INT 9
6228: PUSH
6229: EMPTY
6230: LIST
6231: LIST
6232: LIST
6233: LIST
6234: PUSH
6235: LD_INT 5
6237: PUSH
6238: LD_INT 1
6240: PUSH
6241: LD_INT 2
6243: PUSH
6244: LD_INT 6
6246: PUSH
6247: EMPTY
6248: LIST
6249: LIST
6250: LIST
6251: LIST
6252: PUSH
6253: LD_INT 5
6255: PUSH
6256: LD_INT 1
6258: PUSH
6259: LD_INT 2
6261: PUSH
6262: LD_INT 6
6264: PUSH
6265: EMPTY
6266: LIST
6267: LIST
6268: LIST
6269: LIST
6270: PUSH
6271: LD_INT 5
6273: PUSH
6274: LD_INT 1
6276: PUSH
6277: LD_INT 2
6279: PUSH
6280: LD_INT 6
6282: PUSH
6283: EMPTY
6284: LIST
6285: LIST
6286: LIST
6287: LIST
6288: PUSH
6289: EMPTY
6290: LIST
6291: LIST
6292: LIST
6293: LIST
6294: LIST
6295: LIST
6296: PPUSH
6297: CALL 45620 0 2
// end ; repeat wait ( 0 0$1 ) ;
6301: LD_INT 35
6303: PPUSH
6304: CALL_OW 67
// until MC_GetVehicles ( 4 , true ) >= 6 ;
6308: LD_INT 4
6310: PPUSH
6311: LD_INT 1
6313: PPUSH
6314: CALL 47038 0 2
6318: PUSH
6319: LD_INT 6
6321: GREATEREQUAL
6322: IFFALSE 6301
// wait ( 0 0$30 ) ;
6324: LD_INT 1050
6326: PPUSH
6327: CALL_OW 67
// tmp := MC_GetVehicles ( 4 , true ) ;
6331: LD_ADDR_VAR 0 2
6335: PUSH
6336: LD_INT 4
6338: PPUSH
6339: LD_INT 1
6341: PPUSH
6342: CALL 47038 0 2
6346: ST_TO_ADDR
// mc_vehicles := Replace ( mc_vehicles , 4 , mc_vehicles [ 4 ] diff tmp ) ;
6347: LD_ADDR_EXP 114
6351: PUSH
6352: LD_EXP 114
6356: PPUSH
6357: LD_INT 4
6359: PPUSH
6360: LD_EXP 114
6364: PUSH
6365: LD_INT 4
6367: ARRAY
6368: PUSH
6369: LD_VAR 0 2
6373: DIFF
6374: PPUSH
6375: CALL_OW 1
6379: ST_TO_ADDR
// target := rand ( 0 , 2 ) ;
6380: LD_ADDR_VAR 0 3
6384: PUSH
6385: LD_INT 0
6387: PPUSH
6388: LD_INT 2
6390: PPUSH
6391: CALL_OW 12
6395: ST_TO_ADDR
// if target then
6396: LD_VAR 0 3
6400: IFFALSE 6528
// begin repeat tmp := UnitFilter ( tmp , [ f_lives , 250 ] ) ;
6402: LD_ADDR_VAR 0 2
6406: PUSH
6407: LD_VAR 0 2
6411: PPUSH
6412: LD_INT 24
6414: PUSH
6415: LD_INT 250
6417: PUSH
6418: EMPTY
6419: LIST
6420: LIST
6421: PPUSH
6422: CALL_OW 72
6426: ST_TO_ADDR
// for i in tmp do
6427: LD_ADDR_VAR 0 1
6431: PUSH
6432: LD_VAR 0 2
6436: PUSH
6437: FOR_IN
6438: IFFALSE 6478
// if GetDistUnitXY ( i , 114 , 108 ) > 9 then
6440: LD_VAR 0 1
6444: PPUSH
6445: LD_INT 114
6447: PPUSH
6448: LD_INT 108
6450: PPUSH
6451: CALL_OW 297
6455: PUSH
6456: LD_INT 9
6458: GREATER
6459: IFFALSE 6476
// ComMoveXY ( i , 114 , 108 ) ;
6461: LD_VAR 0 1
6465: PPUSH
6466: LD_INT 114
6468: PPUSH
6469: LD_INT 108
6471: PPUSH
6472: CALL_OW 111
6476: GO 6437
6478: POP
6479: POP
// wait ( 0 0$1 ) ;
6480: LD_INT 35
6482: PPUSH
6483: CALL_OW 67
// until UnitFilter ( tmp , [ f_distxy , 114 , 108 , 9 ] ) >= ( tmp - 1 ) ;
6487: LD_VAR 0 2
6491: PPUSH
6492: LD_INT 92
6494: PUSH
6495: LD_INT 114
6497: PUSH
6498: LD_INT 108
6500: PUSH
6501: LD_INT 9
6503: PUSH
6504: EMPTY
6505: LIST
6506: LIST
6507: LIST
6508: LIST
6509: PPUSH
6510: CALL_OW 72
6514: PUSH
6515: LD_VAR 0 2
6519: PUSH
6520: LD_INT 1
6522: MINUS
6523: GREATEREQUAL
6524: IFFALSE 6402
// end else
6526: GO 6652
// begin repeat tmp := UnitFilter ( tmp , [ f_lives , 250 ] ) ;
6528: LD_ADDR_VAR 0 2
6532: PUSH
6533: LD_VAR 0 2
6537: PPUSH
6538: LD_INT 24
6540: PUSH
6541: LD_INT 250
6543: PUSH
6544: EMPTY
6545: LIST
6546: LIST
6547: PPUSH
6548: CALL_OW 72
6552: ST_TO_ADDR
// for i in tmp do
6553: LD_ADDR_VAR 0 1
6557: PUSH
6558: LD_VAR 0 2
6562: PUSH
6563: FOR_IN
6564: IFFALSE 6604
// if GetDistUnitXY ( i , 129 , 139 ) > 9 then
6566: LD_VAR 0 1
6570: PPUSH
6571: LD_INT 129
6573: PPUSH
6574: LD_INT 139
6576: PPUSH
6577: CALL_OW 297
6581: PUSH
6582: LD_INT 9
6584: GREATER
6585: IFFALSE 6602
// ComMoveXY ( i , 129 , 139 ) ;
6587: LD_VAR 0 1
6591: PPUSH
6592: LD_INT 129
6594: PPUSH
6595: LD_INT 139
6597: PPUSH
6598: CALL_OW 111
6602: GO 6563
6604: POP
6605: POP
// wait ( 0 0$1 ) ;
6606: LD_INT 35
6608: PPUSH
6609: CALL_OW 67
// until UnitFilter ( tmp , [ f_distxy , 129 , 139 , 9 ] ) >= ( tmp - 1 ) ;
6613: LD_VAR 0 2
6617: PPUSH
6618: LD_INT 92
6620: PUSH
6621: LD_INT 129
6623: PUSH
6624: LD_INT 139
6626: PUSH
6627: LD_INT 9
6629: PUSH
6630: EMPTY
6631: LIST
6632: LIST
6633: LIST
6634: LIST
6635: PPUSH
6636: CALL_OW 72
6640: PUSH
6641: LD_VAR 0 2
6645: PUSH
6646: LD_INT 1
6648: MINUS
6649: GREATEREQUAL
6650: IFFALSE 6528
// end ; repeat wait ( 0 0$1 ) ;
6652: LD_INT 35
6654: PPUSH
6655: CALL_OW 67
// for i in tmp do
6659: LD_ADDR_VAR 0 1
6663: PUSH
6664: LD_VAR 0 2
6668: PUSH
6669: FOR_IN
6670: IFFALSE 6752
// begin if GetLives ( i ) > 251 then
6672: LD_VAR 0 1
6676: PPUSH
6677: CALL_OW 256
6681: PUSH
6682: LD_INT 251
6684: GREATER
6685: IFFALSE 6723
// ComAttackUnit ( i , NearestUnitToUnit ( FilterAllUnits ( [ f_enemy , 1 ] ) , i ) ) else
6687: LD_VAR 0 1
6691: PPUSH
6692: LD_INT 81
6694: PUSH
6695: LD_INT 1
6697: PUSH
6698: EMPTY
6699: LIST
6700: LIST
6701: PPUSH
6702: CALL_OW 69
6706: PPUSH
6707: LD_VAR 0 1
6711: PPUSH
6712: CALL_OW 74
6716: PPUSH
6717: CALL_OW 115
6721: GO 6750
// if IsDead ( i ) then
6723: LD_VAR 0 1
6727: PPUSH
6728: CALL_OW 301
6732: IFFALSE 6750
// tmp := tmp diff i ;
6734: LD_ADDR_VAR 0 2
6738: PUSH
6739: LD_VAR 0 2
6743: PUSH
6744: LD_VAR 0 1
6748: DIFF
6749: ST_TO_ADDR
// end ;
6750: GO 6669
6752: POP
6753: POP
// until not tmp ;
6754: LD_VAR 0 2
6758: NOT
6759: IFFALSE 6652
// end ;
6761: PPOPN 3
6763: END
// every 30 30$00 trigger not americanDestroyed do
6764: LD_EXP 4
6768: NOT
6769: IFFALSE 6838
6771: GO 6773
6773: DISABLE
// begin wait ( [ 30 30$00 , 20 20$00 , 15 15$00 , 10 10$00 ] [ Difficulty ] ) ;
6774: LD_INT 63000
6776: PUSH
6777: LD_INT 42000
6779: PUSH
6780: LD_INT 31500
6782: PUSH
6783: LD_INT 21000
6785: PUSH
6786: EMPTY
6787: LIST
6788: LIST
6789: LIST
6790: LIST
6791: PUSH
6792: LD_OWVAR 67
6796: ARRAY
6797: PPUSH
6798: CALL_OW 67
// if americanDestroyed then
6802: LD_EXP 4
6806: IFFALSE 6810
// exit ;
6808: GO 6838
// MC_InsertProduceList ( 4 , [ [ us_morphling , engine_siberite , control_manual , us_siberium_rocket ] ] ) ;
6810: LD_INT 4
6812: PPUSH
6813: LD_INT 5
6815: PUSH
6816: LD_INT 3
6818: PUSH
6819: LD_INT 1
6821: PUSH
6822: LD_INT 8
6824: PUSH
6825: EMPTY
6826: LIST
6827: LIST
6828: LIST
6829: LIST
6830: PUSH
6831: EMPTY
6832: LIST
6833: PPUSH
6834: CALL 45620 0 2
// end ; end_of_file
6838: END
// export function PrepareArabian ; var i , un , tmp , side ; begin
6839: LD_INT 0
6841: PPUSH
6842: PPUSH
6843: PPUSH
6844: PPUSH
6845: PPUSH
// side := 2 ;
6846: LD_ADDR_VAR 0 5
6850: PUSH
6851: LD_INT 2
6853: ST_TO_ADDR
// InitHc ;
6854: CALL_OW 19
// uc_side := side ;
6858: LD_ADDR_OWVAR 20
6862: PUSH
6863: LD_VAR 0 5
6867: ST_TO_ADDR
// uc_nation := 2 ;
6868: LD_ADDR_OWVAR 21
6872: PUSH
6873: LD_INT 2
6875: ST_TO_ADDR
// for i in FilterAllUnits ( [ [ f_side , 2 ] , [ f_type , unit_building ] ] ) do
6876: LD_ADDR_VAR 0 2
6880: PUSH
6881: LD_INT 22
6883: PUSH
6884: LD_INT 2
6886: PUSH
6887: EMPTY
6888: LIST
6889: LIST
6890: PUSH
6891: LD_INT 21
6893: PUSH
6894: LD_INT 3
6896: PUSH
6897: EMPTY
6898: LIST
6899: LIST
6900: PUSH
6901: EMPTY
6902: LIST
6903: LIST
6904: PPUSH
6905: CALL_OW 69
6909: PUSH
6910: FOR_IN
6911: IFFALSE 6927
// SetBLevel ( i , 10 ) ;
6913: LD_VAR 0 2
6917: PPUSH
6918: LD_INT 10
6920: PPUSH
6921: CALL_OW 241
6925: GO 6910
6927: POP
6928: POP
// tmp := FilterAllUnits ( [ [ f_side , side ] , [ f_btype , b_bunker ] , [ f_empty ] ] ) ;
6929: LD_ADDR_VAR 0 4
6933: PUSH
6934: LD_INT 22
6936: PUSH
6937: LD_VAR 0 5
6941: PUSH
6942: EMPTY
6943: LIST
6944: LIST
6945: PUSH
6946: LD_INT 30
6948: PUSH
6949: LD_INT 32
6951: PUSH
6952: EMPTY
6953: LIST
6954: LIST
6955: PUSH
6956: LD_INT 58
6958: PUSH
6959: EMPTY
6960: LIST
6961: PUSH
6962: EMPTY
6963: LIST
6964: LIST
6965: LIST
6966: PPUSH
6967: CALL_OW 69
6971: ST_TO_ADDR
// for i = 1 to 10 do
6972: LD_ADDR_VAR 0 2
6976: PUSH
6977: DOUBLE
6978: LD_INT 1
6980: DEC
6981: ST_TO_ADDR
6982: LD_INT 10
6984: PUSH
6985: FOR_TO
6986: IFFALSE 7058
// begin uc_nation := nation_nature ;
6988: LD_ADDR_OWVAR 21
6992: PUSH
6993: LD_INT 0
6995: ST_TO_ADDR
// hc_class := class_apeman_soldier ;
6996: LD_ADDR_OWVAR 28
7000: PUSH
7001: LD_INT 15
7003: ST_TO_ADDR
// hc_gallery :=  ;
7004: LD_ADDR_OWVAR 33
7008: PUSH
7009: LD_STRING 
7011: ST_TO_ADDR
// hc_name :=  ;
7012: LD_ADDR_OWVAR 26
7016: PUSH
7017: LD_STRING 
7019: ST_TO_ADDR
// un := CreateHuman ;
7020: LD_ADDR_VAR 0 3
7024: PUSH
7025: CALL_OW 44
7029: ST_TO_ADDR
// PlaceHumanInUnit ( un , tmp [ tmp - i ] ) ;
7030: LD_VAR 0 3
7034: PPUSH
7035: LD_VAR 0 4
7039: PUSH
7040: LD_VAR 0 4
7044: PUSH
7045: LD_VAR 0 2
7049: MINUS
7050: ARRAY
7051: PPUSH
7052: CALL_OW 52
// end ;
7056: GO 6985
7058: POP
7059: POP
// PrepareBase ( ar_depot , arabianBaseArea ,  , [ 8 , 9 , 10 , 10 ] [ Difficulty ] , [ 3000 , 500 , 150 ] , [ 16 , 6 , 6 , 6 ] ) ;
7060: LD_INT 503
7062: PPUSH
7063: LD_INT 27
7065: PPUSH
7066: LD_STRING 
7068: PPUSH
7069: LD_INT 8
7071: PUSH
7072: LD_INT 9
7074: PUSH
7075: LD_INT 10
7077: PUSH
7078: LD_INT 10
7080: PUSH
7081: EMPTY
7082: LIST
7083: LIST
7084: LIST
7085: LIST
7086: PUSH
7087: LD_OWVAR 67
7091: ARRAY
7092: PPUSH
7093: LD_INT 3000
7095: PUSH
7096: LD_INT 500
7098: PUSH
7099: LD_INT 150
7101: PUSH
7102: EMPTY
7103: LIST
7104: LIST
7105: LIST
7106: PPUSH
7107: LD_INT 16
7109: PUSH
7110: LD_INT 6
7112: PUSH
7113: LD_INT 6
7115: PUSH
7116: LD_INT 6
7118: PUSH
7119: EMPTY
7120: LIST
7121: LIST
7122: LIST
7123: LIST
7124: PPUSH
7125: CALL 60336 0 6
// mc_bases := Replace ( mc_bases , 1 , FilterAllUnits ( [ [ f_side , side ] , [ f_nation , 2 ] , [ f_not , [ f_type , unit_vehicle ] ] ] ) ) ;
7129: LD_ADDR_EXP 95
7133: PUSH
7134: LD_EXP 95
7138: PPUSH
7139: LD_INT 1
7141: PPUSH
7142: LD_INT 22
7144: PUSH
7145: LD_VAR 0 5
7149: PUSH
7150: EMPTY
7151: LIST
7152: LIST
7153: PUSH
7154: LD_INT 23
7156: PUSH
7157: LD_INT 2
7159: PUSH
7160: EMPTY
7161: LIST
7162: LIST
7163: PUSH
7164: LD_INT 3
7166: PUSH
7167: LD_INT 21
7169: PUSH
7170: LD_INT 2
7172: PUSH
7173: EMPTY
7174: LIST
7175: LIST
7176: PUSH
7177: EMPTY
7178: LIST
7179: LIST
7180: PUSH
7181: EMPTY
7182: LIST
7183: LIST
7184: LIST
7185: PPUSH
7186: CALL_OW 69
7190: PPUSH
7191: CALL_OW 1
7195: ST_TO_ADDR
// end ;
7196: LD_VAR 0 1
7200: RET
// export Omar ; export function PrepareOmarAli ; begin
7201: LD_INT 0
7203: PPUSH
// uc_side := 5 ;
7204: LD_ADDR_OWVAR 20
7208: PUSH
7209: LD_INT 5
7211: ST_TO_ADDR
// uc_nation := 2 ;
7212: LD_ADDR_OWVAR 21
7216: PUSH
7217: LD_INT 2
7219: ST_TO_ADDR
// Omar := NewCharacter ( Omar ) ;
7220: LD_ADDR_EXP 55
7224: PUSH
7225: LD_STRING Omar
7227: PPUSH
7228: CALL_OW 25
7232: ST_TO_ADDR
// PlaceUnitXY ( Omar , 330 , 244 , false ) ;
7233: LD_EXP 55
7237: PPUSH
7238: LD_INT 330
7240: PPUSH
7241: LD_INT 244
7243: PPUSH
7244: LD_INT 0
7246: PPUSH
7247: CALL_OW 48
// ComMoveXY ( Omar , 252 , 220 ) ;
7251: LD_EXP 55
7255: PPUSH
7256: LD_INT 252
7258: PPUSH
7259: LD_INT 220
7261: PPUSH
7262: CALL_OW 111
// end ; end_of_file
7266: LD_VAR 0 1
7270: RET
// export Schulz , Kozlov ; export function PrepareLegion ; var i , side , un , tmp ; begin
7271: LD_INT 0
7273: PPUSH
7274: PPUSH
7275: PPUSH
7276: PPUSH
7277: PPUSH
// side := 8 ;
7278: LD_ADDR_VAR 0 3
7282: PUSH
7283: LD_INT 8
7285: ST_TO_ADDR
// InitHc ;
7286: CALL_OW 19
// uc_side := side ;
7290: LD_ADDR_OWVAR 20
7294: PUSH
7295: LD_VAR 0 3
7299: ST_TO_ADDR
// uc_nation := 2 ;
7300: LD_ADDR_OWVAR 21
7304: PUSH
7305: LD_INT 2
7307: ST_TO_ADDR
// for i in FilterAllUnits ( [ [ f_side , side ] , [ f_type , unit_building ] ] ) do
7308: LD_ADDR_VAR 0 2
7312: PUSH
7313: LD_INT 22
7315: PUSH
7316: LD_VAR 0 3
7320: PUSH
7321: EMPTY
7322: LIST
7323: LIST
7324: PUSH
7325: LD_INT 21
7327: PUSH
7328: LD_INT 3
7330: PUSH
7331: EMPTY
7332: LIST
7333: LIST
7334: PUSH
7335: EMPTY
7336: LIST
7337: LIST
7338: PPUSH
7339: CALL_OW 69
7343: PUSH
7344: FOR_IN
7345: IFFALSE 7361
// SetBLevel ( i , 10 ) ;
7347: LD_VAR 0 2
7351: PPUSH
7352: LD_INT 10
7354: PPUSH
7355: CALL_OW 241
7359: GO 7344
7361: POP
7362: POP
// Schulz := NewCharacter ( Schulz ) ;
7363: LD_ADDR_EXP 56
7367: PUSH
7368: LD_STRING Schulz
7370: PPUSH
7371: CALL_OW 25
7375: ST_TO_ADDR
// Kozlov := PrepareUnit ( Kozlov , false ,  ) ;
7376: LD_ADDR_EXP 57
7380: PUSH
7381: LD_STRING Kozlov
7383: PPUSH
7384: LD_INT 0
7386: PPUSH
7387: LD_STRING 
7389: PPUSH
7390: CALL 52026 0 3
7394: ST_TO_ADDR
// PlaceHumanInUnit ( Kozlov , FilterAllUnits ( [ [ f_side , 8 ] , [ f_nation , 3 ] , [ f_btype , b_lab_full ] ] ) [ 1 ] ) ;
7395: LD_EXP 57
7399: PPUSH
7400: LD_INT 22
7402: PUSH
7403: LD_INT 8
7405: PUSH
7406: EMPTY
7407: LIST
7408: LIST
7409: PUSH
7410: LD_INT 23
7412: PUSH
7413: LD_INT 3
7415: PUSH
7416: EMPTY
7417: LIST
7418: LIST
7419: PUSH
7420: LD_INT 30
7422: PUSH
7423: LD_INT 8
7425: PUSH
7426: EMPTY
7427: LIST
7428: LIST
7429: PUSH
7430: EMPTY
7431: LIST
7432: LIST
7433: LIST
7434: PPUSH
7435: CALL_OW 69
7439: PUSH
7440: LD_INT 1
7442: ARRAY
7443: PPUSH
7444: CALL_OW 52
// SetSkill ( Kozlov , class_mechanic , 10 ) ;
7448: LD_EXP 57
7452: PPUSH
7453: LD_INT 3
7455: PPUSH
7456: LD_INT 10
7458: PPUSH
7459: CALL_OW 237
// tmp := FilterAllUnits ( [ [ f_side , side ] , [ f_btype , b_bunker ] , [ f_empty ] ] ) ;
7463: LD_ADDR_VAR 0 5
7467: PUSH
7468: LD_INT 22
7470: PUSH
7471: LD_VAR 0 3
7475: PUSH
7476: EMPTY
7477: LIST
7478: LIST
7479: PUSH
7480: LD_INT 30
7482: PUSH
7483: LD_INT 32
7485: PUSH
7486: EMPTY
7487: LIST
7488: LIST
7489: PUSH
7490: LD_INT 58
7492: PUSH
7493: EMPTY
7494: LIST
7495: PUSH
7496: EMPTY
7497: LIST
7498: LIST
7499: LIST
7500: PPUSH
7501: CALL_OW 69
7505: ST_TO_ADDR
// for i = 1 to 10 do
7506: LD_ADDR_VAR 0 2
7510: PUSH
7511: DOUBLE
7512: LD_INT 1
7514: DEC
7515: ST_TO_ADDR
7516: LD_INT 10
7518: PUSH
7519: FOR_TO
7520: IFFALSE 7592
// begin uc_nation := nation_nature ;
7522: LD_ADDR_OWVAR 21
7526: PUSH
7527: LD_INT 0
7529: ST_TO_ADDR
// hc_class := class_apeman_soldier ;
7530: LD_ADDR_OWVAR 28
7534: PUSH
7535: LD_INT 15
7537: ST_TO_ADDR
// hc_gallery :=  ;
7538: LD_ADDR_OWVAR 33
7542: PUSH
7543: LD_STRING 
7545: ST_TO_ADDR
// hc_name :=  ;
7546: LD_ADDR_OWVAR 26
7550: PUSH
7551: LD_STRING 
7553: ST_TO_ADDR
// un := CreateHuman ;
7554: LD_ADDR_VAR 0 4
7558: PUSH
7559: CALL_OW 44
7563: ST_TO_ADDR
// PlaceHumanInUnit ( un , tmp [ tmp - i ] ) ;
7564: LD_VAR 0 4
7568: PPUSH
7569: LD_VAR 0 5
7573: PUSH
7574: LD_VAR 0 5
7578: PUSH
7579: LD_VAR 0 2
7583: MINUS
7584: ARRAY
7585: PPUSH
7586: CALL_OW 52
// end ;
7590: GO 7519
7592: POP
7593: POP
// PrepareBase ( ar_depot1 , legionBaseArea ,  , [ 8 , 9 , 10 , 10 ] [ Difficulty ] , [ 3000 , 500 , 150 ] , [ 16 , 6 , 6 , 8 ] ) ;
7594: LD_INT 324
7596: PPUSH
7597: LD_INT 3
7599: PPUSH
7600: LD_STRING 
7602: PPUSH
7603: LD_INT 8
7605: PUSH
7606: LD_INT 9
7608: PUSH
7609: LD_INT 10
7611: PUSH
7612: LD_INT 10
7614: PUSH
7615: EMPTY
7616: LIST
7617: LIST
7618: LIST
7619: LIST
7620: PUSH
7621: LD_OWVAR 67
7625: ARRAY
7626: PPUSH
7627: LD_INT 3000
7629: PUSH
7630: LD_INT 500
7632: PUSH
7633: LD_INT 150
7635: PUSH
7636: EMPTY
7637: LIST
7638: LIST
7639: LIST
7640: PPUSH
7641: LD_INT 16
7643: PUSH
7644: LD_INT 6
7646: PUSH
7647: LD_INT 6
7649: PUSH
7650: LD_INT 8
7652: PUSH
7653: EMPTY
7654: LIST
7655: LIST
7656: LIST
7657: LIST
7658: PPUSH
7659: CALL 60336 0 6
// mc_bases := Replace ( mc_bases , 3 , FilterAllUnits ( [ [ f_side , side ] , [ f_nation , 2 ] , [ f_not , [ f_type , unit_vehicle ] ] ] ) diff Schulz ) ;
7663: LD_ADDR_EXP 95
7667: PUSH
7668: LD_EXP 95
7672: PPUSH
7673: LD_INT 3
7675: PPUSH
7676: LD_INT 22
7678: PUSH
7679: LD_VAR 0 3
7683: PUSH
7684: EMPTY
7685: LIST
7686: LIST
7687: PUSH
7688: LD_INT 23
7690: PUSH
7691: LD_INT 2
7693: PUSH
7694: EMPTY
7695: LIST
7696: LIST
7697: PUSH
7698: LD_INT 3
7700: PUSH
7701: LD_INT 21
7703: PUSH
7704: LD_INT 2
7706: PUSH
7707: EMPTY
7708: LIST
7709: LIST
7710: PUSH
7711: EMPTY
7712: LIST
7713: LIST
7714: PUSH
7715: EMPTY
7716: LIST
7717: LIST
7718: LIST
7719: PPUSH
7720: CALL_OW 69
7724: PUSH
7725: LD_EXP 56
7729: DIFF
7730: PPUSH
7731: CALL_OW 1
7735: ST_TO_ADDR
// end ;
7736: LD_VAR 0 1
7740: RET
// export function BuildKozlovBomb ; begin
7741: LD_INT 0
7743: PPUSH
// if not IsOk ( kozlov_fac ) or not IsOk ( kozlov_lab ) then
7744: LD_INT 332
7746: PPUSH
7747: CALL_OW 302
7751: NOT
7752: PUSH
7753: LD_INT 336
7755: PPUSH
7756: CALL_OW 302
7760: NOT
7761: OR
7762: IFFALSE 7766
// exit ;
7764: GO 7863
// ComChangeProfession ( Kozlov , 4 ) ;
7766: LD_EXP 57
7770: PPUSH
7771: LD_INT 4
7773: PPUSH
7774: CALL_OW 123
// ComResearch ( kozlov_lab , tech_sibFiss ) ;
7778: LD_INT 336
7780: PPUSH
7781: LD_INT 25
7783: PPUSH
7784: CALL_OW 124
// repeat wait ( 0 0$1 ) ;
7788: LD_INT 35
7790: PPUSH
7791: CALL_OW 67
// until GetTech ( tech_sibFiss , 8 ) = state_researched ;
7795: LD_INT 25
7797: PPUSH
7798: LD_INT 8
7800: PPUSH
7801: CALL_OW 321
7805: PUSH
7806: LD_INT 2
7808: EQUAL
7809: IFFALSE 7788
// ComExitBuilding ( Kozlov ) ;
7811: LD_EXP 57
7815: PPUSH
7816: CALL_OW 122
// AddComEnterUnit ( Kozlov , kozlov_fac ) ;
7820: LD_EXP 57
7824: PPUSH
7825: LD_INT 332
7827: PPUSH
7828: CALL_OW 180
// AddComChangeProfession ( Kozlov , 3 ) ;
7832: LD_EXP 57
7836: PPUSH
7837: LD_INT 3
7839: PPUSH
7840: CALL_OW 183
// ComConstruct ( kozlov_fac , ru_heavy_wheeled , engine_siberite , control_manual , ru_siberium_rocket ) ;
7844: LD_INT 332
7846: PPUSH
7847: LD_INT 23
7849: PPUSH
7850: LD_INT 3
7852: PPUSH
7853: LD_INT 1
7855: PPUSH
7856: LD_INT 48
7858: PPUSH
7859: CALL_OW 125
// end ;
7863: LD_VAR 0 1
7867: RET
// every 11 11$30 trigger not legionDestroyed and not MC_GetVehicles ( 3 , true ) do var i , tmp , target ;
7868: LD_EXP 3
7872: NOT
7873: PUSH
7874: LD_INT 3
7876: PPUSH
7877: LD_INT 1
7879: PPUSH
7880: CALL 47038 0 2
7884: NOT
7885: AND
7886: IFFALSE 8742
7888: GO 7890
7890: DISABLE
7891: LD_INT 0
7893: PPUSH
7894: PPUSH
7895: PPUSH
// begin enable ;
7896: ENABLE
// if not FilterAllUnits ( [ [ f_side , 8 ] , [ f_nation , 2 ] , [ f_btype , b_factory ] ] ) then
7897: LD_INT 22
7899: PUSH
7900: LD_INT 8
7902: PUSH
7903: EMPTY
7904: LIST
7905: LIST
7906: PUSH
7907: LD_INT 23
7909: PUSH
7910: LD_INT 2
7912: PUSH
7913: EMPTY
7914: LIST
7915: LIST
7916: PUSH
7917: LD_INT 30
7919: PUSH
7920: LD_INT 3
7922: PUSH
7923: EMPTY
7924: LIST
7925: LIST
7926: PUSH
7927: EMPTY
7928: LIST
7929: LIST
7930: LIST
7931: PPUSH
7932: CALL_OW 69
7936: NOT
7937: IFFALSE 7941
// exit ;
7939: GO 8742
// if Prob ( 40 ) then
7941: LD_INT 40
7943: PPUSH
7944: CALL_OW 13
7948: IFFALSE 8075
// begin MC_InsertProduceList ( 3 , [ [ ar_half_tracked , engine_combustion , control_remote , ar_rocket_launcher ] , [ ar_half_tracked , engine_combustion , control_remote , ar_rocket_launcher ] , [ ar_half_tracked , engine_combustion , control_remote , ar_rocket_launcher ] , [ ar_half_tracked , engine_combustion , control_remote , ar_rocket_launcher ] , [ ar_half_tracked , engine_combustion , control_remote , ar_rocket_launcher ] , [ ar_half_tracked , engine_combustion , control_remote , ar_flame_thrower ] , ] ) ;
7950: LD_INT 3
7952: PPUSH
7953: LD_INT 14
7955: PUSH
7956: LD_INT 1
7958: PUSH
7959: LD_INT 2
7961: PUSH
7962: LD_INT 28
7964: PUSH
7965: EMPTY
7966: LIST
7967: LIST
7968: LIST
7969: LIST
7970: PUSH
7971: LD_INT 14
7973: PUSH
7974: LD_INT 1
7976: PUSH
7977: LD_INT 2
7979: PUSH
7980: LD_INT 28
7982: PUSH
7983: EMPTY
7984: LIST
7985: LIST
7986: LIST
7987: LIST
7988: PUSH
7989: LD_INT 14
7991: PUSH
7992: LD_INT 1
7994: PUSH
7995: LD_INT 2
7997: PUSH
7998: LD_INT 28
8000: PUSH
8001: EMPTY
8002: LIST
8003: LIST
8004: LIST
8005: LIST
8006: PUSH
8007: LD_INT 14
8009: PUSH
8010: LD_INT 1
8012: PUSH
8013: LD_INT 2
8015: PUSH
8016: LD_INT 28
8018: PUSH
8019: EMPTY
8020: LIST
8021: LIST
8022: LIST
8023: LIST
8024: PUSH
8025: LD_INT 14
8027: PUSH
8028: LD_INT 1
8030: PUSH
8031: LD_INT 2
8033: PUSH
8034: LD_INT 28
8036: PUSH
8037: EMPTY
8038: LIST
8039: LIST
8040: LIST
8041: LIST
8042: PUSH
8043: LD_INT 14
8045: PUSH
8046: LD_INT 1
8048: PUSH
8049: LD_INT 2
8051: PUSH
8052: LD_INT 26
8054: PUSH
8055: EMPTY
8056: LIST
8057: LIST
8058: LIST
8059: LIST
8060: PUSH
8061: EMPTY
8062: LIST
8063: LIST
8064: LIST
8065: LIST
8066: LIST
8067: LIST
8068: PPUSH
8069: CALL 45620 0 2
// end else
8073: GO 8282
// begin MC_InsertProduceList ( 3 , [ [ ar_half_tracked , engine_combustion , control_remote , [ ar_gun , ar_flame_thrower , ar_flame_thrower , ar_rocket_launcher ] [ Difficulty ] ] , [ ar_half_tracked , engine_combustion , control_remote , [ ar_gun , ar_flame_thrower , ar_flame_thrower , ar_flame_thrower ] [ Difficulty ] ] , [ ar_half_tracked , engine_combustion , control_remote , [ ar_flame_thrower , ar_flame_thrower , ar_selfpropelled_bomb , ar_selfpropelled_bomb ] [ Difficulty ] ] , [ ar_medium_trike , engine_combustion , control_remote , [ ar_flame_thrower , ar_selfpropelled_bomb , ar_selfpropelled_bomb , ar_selfpropelled_bomb ] [ Difficulty ] ] , [ ar_medium_trike , engine_combustion , control_remote , ar_selfpropelled_bomb ] , [ ar_half_tracked , engine_combustion , control_remote , ar_flame_thrower ] , ] ) ;
8075: LD_INT 3
8077: PPUSH
8078: LD_INT 14
8080: PUSH
8081: LD_INT 1
8083: PUSH
8084: LD_INT 2
8086: PUSH
8087: LD_INT 27
8089: PUSH
8090: LD_INT 26
8092: PUSH
8093: LD_INT 26
8095: PUSH
8096: LD_INT 28
8098: PUSH
8099: EMPTY
8100: LIST
8101: LIST
8102: LIST
8103: LIST
8104: PUSH
8105: LD_OWVAR 67
8109: ARRAY
8110: PUSH
8111: EMPTY
8112: LIST
8113: LIST
8114: LIST
8115: LIST
8116: PUSH
8117: LD_INT 14
8119: PUSH
8120: LD_INT 1
8122: PUSH
8123: LD_INT 2
8125: PUSH
8126: LD_INT 27
8128: PUSH
8129: LD_INT 26
8131: PUSH
8132: LD_INT 26
8134: PUSH
8135: LD_INT 26
8137: PUSH
8138: EMPTY
8139: LIST
8140: LIST
8141: LIST
8142: LIST
8143: PUSH
8144: LD_OWVAR 67
8148: ARRAY
8149: PUSH
8150: EMPTY
8151: LIST
8152: LIST
8153: LIST
8154: LIST
8155: PUSH
8156: LD_INT 14
8158: PUSH
8159: LD_INT 1
8161: PUSH
8162: LD_INT 2
8164: PUSH
8165: LD_INT 26
8167: PUSH
8168: LD_INT 26
8170: PUSH
8171: LD_INT 29
8173: PUSH
8174: LD_INT 29
8176: PUSH
8177: EMPTY
8178: LIST
8179: LIST
8180: LIST
8181: LIST
8182: PUSH
8183: LD_OWVAR 67
8187: ARRAY
8188: PUSH
8189: EMPTY
8190: LIST
8191: LIST
8192: LIST
8193: LIST
8194: PUSH
8195: LD_INT 13
8197: PUSH
8198: LD_INT 1
8200: PUSH
8201: LD_INT 2
8203: PUSH
8204: LD_INT 26
8206: PUSH
8207: LD_INT 29
8209: PUSH
8210: LD_INT 29
8212: PUSH
8213: LD_INT 29
8215: PUSH
8216: EMPTY
8217: LIST
8218: LIST
8219: LIST
8220: LIST
8221: PUSH
8222: LD_OWVAR 67
8226: ARRAY
8227: PUSH
8228: EMPTY
8229: LIST
8230: LIST
8231: LIST
8232: LIST
8233: PUSH
8234: LD_INT 13
8236: PUSH
8237: LD_INT 1
8239: PUSH
8240: LD_INT 2
8242: PUSH
8243: LD_INT 29
8245: PUSH
8246: EMPTY
8247: LIST
8248: LIST
8249: LIST
8250: LIST
8251: PUSH
8252: LD_INT 14
8254: PUSH
8255: LD_INT 1
8257: PUSH
8258: LD_INT 2
8260: PUSH
8261: LD_INT 26
8263: PUSH
8264: EMPTY
8265: LIST
8266: LIST
8267: LIST
8268: LIST
8269: PUSH
8270: EMPTY
8271: LIST
8272: LIST
8273: LIST
8274: LIST
8275: LIST
8276: LIST
8277: PPUSH
8278: CALL 45620 0 2
// end ; repeat wait ( 0 0$1 ) ;
8282: LD_INT 35
8284: PPUSH
8285: CALL_OW 67
// until MC_GetVehicles ( 3 , true ) >= 6 ;
8289: LD_INT 3
8291: PPUSH
8292: LD_INT 1
8294: PPUSH
8295: CALL 47038 0 2
8299: PUSH
8300: LD_INT 6
8302: GREATEREQUAL
8303: IFFALSE 8282
// wait ( 0 0$30 ) ;
8305: LD_INT 1050
8307: PPUSH
8308: CALL_OW 67
// tmp := MC_GetVehicles ( 3 , true ) ;
8312: LD_ADDR_VAR 0 2
8316: PUSH
8317: LD_INT 3
8319: PPUSH
8320: LD_INT 1
8322: PPUSH
8323: CALL 47038 0 2
8327: ST_TO_ADDR
// mc_vehicles := Replace ( mc_vehicles , 3 , mc_vehicles [ 3 ] diff tmp ) ;
8328: LD_ADDR_EXP 114
8332: PUSH
8333: LD_EXP 114
8337: PPUSH
8338: LD_INT 3
8340: PPUSH
8341: LD_EXP 114
8345: PUSH
8346: LD_INT 3
8348: ARRAY
8349: PUSH
8350: LD_VAR 0 2
8354: DIFF
8355: PPUSH
8356: CALL_OW 1
8360: ST_TO_ADDR
// target := rand ( 0 , 2 ) ;
8361: LD_ADDR_VAR 0 3
8365: PUSH
8366: LD_INT 0
8368: PPUSH
8369: LD_INT 2
8371: PPUSH
8372: CALL_OW 12
8376: ST_TO_ADDR
// if target then
8377: LD_VAR 0 3
8381: IFFALSE 8509
// begin repeat tmp := UnitFilter ( tmp , [ f_lives , 250 ] ) ;
8383: LD_ADDR_VAR 0 2
8387: PUSH
8388: LD_VAR 0 2
8392: PPUSH
8393: LD_INT 24
8395: PUSH
8396: LD_INT 250
8398: PUSH
8399: EMPTY
8400: LIST
8401: LIST
8402: PPUSH
8403: CALL_OW 72
8407: ST_TO_ADDR
// for i in tmp do
8408: LD_ADDR_VAR 0 1
8412: PUSH
8413: LD_VAR 0 2
8417: PUSH
8418: FOR_IN
8419: IFFALSE 8459
// if GetDistUnitXY ( i , 89 , 71 ) > 9 then
8421: LD_VAR 0 1
8425: PPUSH
8426: LD_INT 89
8428: PPUSH
8429: LD_INT 71
8431: PPUSH
8432: CALL_OW 297
8436: PUSH
8437: LD_INT 9
8439: GREATER
8440: IFFALSE 8457
// ComMoveXY ( i , 89 , 71 ) ;
8442: LD_VAR 0 1
8446: PPUSH
8447: LD_INT 89
8449: PPUSH
8450: LD_INT 71
8452: PPUSH
8453: CALL_OW 111
8457: GO 8418
8459: POP
8460: POP
// wait ( 0 0$1 ) ;
8461: LD_INT 35
8463: PPUSH
8464: CALL_OW 67
// until UnitFilter ( tmp , [ f_distxy , 89 , 71 , 9 ] ) >= ( tmp - 1 ) ;
8468: LD_VAR 0 2
8472: PPUSH
8473: LD_INT 92
8475: PUSH
8476: LD_INT 89
8478: PUSH
8479: LD_INT 71
8481: PUSH
8482: LD_INT 9
8484: PUSH
8485: EMPTY
8486: LIST
8487: LIST
8488: LIST
8489: LIST
8490: PPUSH
8491: CALL_OW 72
8495: PUSH
8496: LD_VAR 0 2
8500: PUSH
8501: LD_INT 1
8503: MINUS
8504: GREATEREQUAL
8505: IFFALSE 8383
// end else
8507: GO 8633
// begin repeat tmp := UnitFilter ( tmp , [ f_lives , 250 ] ) ;
8509: LD_ADDR_VAR 0 2
8513: PUSH
8514: LD_VAR 0 2
8518: PPUSH
8519: LD_INT 24
8521: PUSH
8522: LD_INT 250
8524: PUSH
8525: EMPTY
8526: LIST
8527: LIST
8528: PPUSH
8529: CALL_OW 72
8533: ST_TO_ADDR
// for i in tmp do
8534: LD_ADDR_VAR 0 1
8538: PUSH
8539: LD_VAR 0 2
8543: PUSH
8544: FOR_IN
8545: IFFALSE 8585
// if GetDistUnitXY ( i , 147 , 4 ) > 9 then
8547: LD_VAR 0 1
8551: PPUSH
8552: LD_INT 147
8554: PPUSH
8555: LD_INT 4
8557: PPUSH
8558: CALL_OW 297
8562: PUSH
8563: LD_INT 9
8565: GREATER
8566: IFFALSE 8583
// ComMoveXY ( i , 147 , 4 ) ;
8568: LD_VAR 0 1
8572: PPUSH
8573: LD_INT 147
8575: PPUSH
8576: LD_INT 4
8578: PPUSH
8579: CALL_OW 111
8583: GO 8544
8585: POP
8586: POP
// wait ( 0 0$1 ) ;
8587: LD_INT 35
8589: PPUSH
8590: CALL_OW 67
// until UnitFilter ( tmp , [ f_distxy , 147 , 4 , 9 ] ) >= ( tmp - 1 ) ;
8594: LD_VAR 0 2
8598: PPUSH
8599: LD_INT 92
8601: PUSH
8602: LD_INT 147
8604: PUSH
8605: LD_INT 4
8607: PUSH
8608: LD_INT 9
8610: PUSH
8611: EMPTY
8612: LIST
8613: LIST
8614: LIST
8615: LIST
8616: PPUSH
8617: CALL_OW 72
8621: PUSH
8622: LD_VAR 0 2
8626: PUSH
8627: LD_INT 1
8629: MINUS
8630: GREATEREQUAL
8631: IFFALSE 8509
// end ; repeat wait ( 0 0$1 ) ;
8633: LD_INT 35
8635: PPUSH
8636: CALL_OW 67
// for i in tmp do
8640: LD_ADDR_VAR 0 1
8644: PUSH
8645: LD_VAR 0 2
8649: PUSH
8650: FOR_IN
8651: IFFALSE 8733
// begin if GetLives ( i ) > 251 then
8653: LD_VAR 0 1
8657: PPUSH
8658: CALL_OW 256
8662: PUSH
8663: LD_INT 251
8665: GREATER
8666: IFFALSE 8704
// ComAttackUnit ( i , NearestUnitToUnit ( FilterAllUnits ( [ f_enemy , 8 ] ) , i ) ) else
8668: LD_VAR 0 1
8672: PPUSH
8673: LD_INT 81
8675: PUSH
8676: LD_INT 8
8678: PUSH
8679: EMPTY
8680: LIST
8681: LIST
8682: PPUSH
8683: CALL_OW 69
8687: PPUSH
8688: LD_VAR 0 1
8692: PPUSH
8693: CALL_OW 74
8697: PPUSH
8698: CALL_OW 115
8702: GO 8731
// if IsDead ( i ) then
8704: LD_VAR 0 1
8708: PPUSH
8709: CALL_OW 301
8713: IFFALSE 8731
// tmp := tmp diff i ;
8715: LD_ADDR_VAR 0 2
8719: PUSH
8720: LD_VAR 0 2
8724: PUSH
8725: LD_VAR 0 1
8729: DIFF
8730: ST_TO_ADDR
// end ;
8731: GO 8650
8733: POP
8734: POP
// until not tmp ;
8735: LD_VAR 0 2
8739: NOT
8740: IFFALSE 8633
// end ;
8742: PPOPN 3
8744: END
// every 0 0$1 trigger IsOk ( Kozlov ) and not legionDestroyed do
8745: LD_EXP 57
8749: PPUSH
8750: CALL_OW 302
8754: PUSH
8755: LD_EXP 3
8759: NOT
8760: AND
8761: IFFALSE 8770
8763: GO 8765
8765: DISABLE
// BuildKozlovBomb ;
8766: CALL 7741 0 0
8770: END
// every 0 0$3 trigger FilterAllUnits ( [ [ f_side , 8 ] , [ f_weapon , ru_siberium_rocket ] ] ) do
8771: LD_INT 22
8773: PUSH
8774: LD_INT 8
8776: PUSH
8777: EMPTY
8778: LIST
8779: LIST
8780: PUSH
8781: LD_INT 34
8783: PUSH
8784: LD_INT 48
8786: PUSH
8787: EMPTY
8788: LIST
8789: LIST
8790: PUSH
8791: EMPTY
8792: LIST
8793: LIST
8794: PPUSH
8795: CALL_OW 69
8799: IFFALSE 8847
8801: GO 8803
8803: DISABLE
// begin ComAttackPlace ( FilterAllUnits ( [ [ f_side , 8 ] , [ f_weapon , ru_siberium_rocket ] ] ) [ 1 ] , 173 , 96 ) ;
8804: LD_INT 22
8806: PUSH
8807: LD_INT 8
8809: PUSH
8810: EMPTY
8811: LIST
8812: LIST
8813: PUSH
8814: LD_INT 34
8816: PUSH
8817: LD_INT 48
8819: PUSH
8820: EMPTY
8821: LIST
8822: LIST
8823: PUSH
8824: EMPTY
8825: LIST
8826: LIST
8827: PPUSH
8828: CALL_OW 69
8832: PUSH
8833: LD_INT 1
8835: ARRAY
8836: PPUSH
8837: LD_INT 173
8839: PPUSH
8840: LD_INT 96
8842: PPUSH
8843: CALL_OW 116
// end ; end_of_file
8847: END
// export Platonov , Yakotich , Gleb , Bierezov ; export behemoths , behemothBuilders ; export function PrepareRussian ; var i , j , base , tmp , side , xy , b , teleport ; begin
8848: LD_INT 0
8850: PPUSH
8851: PPUSH
8852: PPUSH
8853: PPUSH
8854: PPUSH
8855: PPUSH
8856: PPUSH
8857: PPUSH
8858: PPUSH
// side := 3 ;
8859: LD_ADDR_VAR 0 6
8863: PUSH
8864: LD_INT 3
8866: ST_TO_ADDR
// InitHc ;
8867: CALL_OW 19
// uc_side := side ;
8871: LD_ADDR_OWVAR 20
8875: PUSH
8876: LD_VAR 0 6
8880: ST_TO_ADDR
// uc_nation := 3 ;
8881: LD_ADDR_OWVAR 21
8885: PUSH
8886: LD_INT 3
8888: ST_TO_ADDR
// for i in FilterAllUnits ( [ [ f_side , side ] , [ f_type , unit_building ] ] ) do
8889: LD_ADDR_VAR 0 2
8893: PUSH
8894: LD_INT 22
8896: PUSH
8897: LD_VAR 0 6
8901: PUSH
8902: EMPTY
8903: LIST
8904: LIST
8905: PUSH
8906: LD_INT 21
8908: PUSH
8909: LD_INT 3
8911: PUSH
8912: EMPTY
8913: LIST
8914: LIST
8915: PUSH
8916: EMPTY
8917: LIST
8918: LIST
8919: PPUSH
8920: CALL_OW 69
8924: PUSH
8925: FOR_IN
8926: IFFALSE 8942
// SetBLevel ( i , 10 ) ;
8928: LD_VAR 0 2
8932: PPUSH
8933: LD_INT 10
8935: PPUSH
8936: CALL_OW 241
8940: GO 8925
8942: POP
8943: POP
// teleport := FilterAllUnits ( [ [ f_side , side ] , [ f_btype , b_teleport ] ] ) ;
8944: LD_ADDR_VAR 0 9
8948: PUSH
8949: LD_INT 22
8951: PUSH
8952: LD_VAR 0 6
8956: PUSH
8957: EMPTY
8958: LIST
8959: LIST
8960: PUSH
8961: LD_INT 30
8963: PUSH
8964: LD_INT 34
8966: PUSH
8967: EMPTY
8968: LIST
8969: LIST
8970: PUSH
8971: EMPTY
8972: LIST
8973: LIST
8974: PPUSH
8975: CALL_OW 69
8979: ST_TO_ADDR
// if teleport then
8980: LD_VAR 0 9
8984: IFFALSE 9005
// TeleportExit ( teleport [ 1 ] , 123 , 122 ) ;
8986: LD_VAR 0 9
8990: PUSH
8991: LD_INT 1
8993: ARRAY
8994: PPUSH
8995: LD_INT 123
8997: PPUSH
8998: LD_INT 122
9000: PPUSH
9001: CALL_OW 243
// hc_importance := 0 ;
9005: LD_ADDR_OWVAR 32
9009: PUSH
9010: LD_INT 0
9012: ST_TO_ADDR
// Platonov := NewCharacter ( Platonov ) ;
9013: LD_ADDR_EXP 58
9017: PUSH
9018: LD_STRING Platonov
9020: PPUSH
9021: CALL_OW 25
9025: ST_TO_ADDR
// Yakotich := NewCharacter ( Yakotich ) ;
9026: LD_ADDR_EXP 59
9030: PUSH
9031: LD_STRING Yakotich
9033: PPUSH
9034: CALL_OW 25
9038: ST_TO_ADDR
// Gleb := NewCharacter ( Gleb ) ;
9039: LD_ADDR_EXP 60
9043: PUSH
9044: LD_STRING Gleb
9046: PPUSH
9047: CALL_OW 25
9051: ST_TO_ADDR
// if TestCharacters ( 03_Cornel ) then
9052: LD_STRING 03_Cornel
9054: PPUSH
9055: CALL_OW 28
9059: IFFALSE 9107
// begin Bierezov := NewCharacter ( Mikhail ) ;
9061: LD_ADDR_EXP 61
9065: PUSH
9066: LD_STRING Mikhail
9068: PPUSH
9069: CALL_OW 25
9073: ST_TO_ADDR
// PlaceUnitXYR ( Bierezov , 197 , 111 , 9 , false ) ;
9074: LD_EXP 61
9078: PPUSH
9079: LD_INT 197
9081: PPUSH
9082: LD_INT 111
9084: PPUSH
9085: LD_INT 9
9087: PPUSH
9088: LD_INT 0
9090: PPUSH
9091: CALL_OW 50
// SetClass ( Bierezov , 3 ) ;
9095: LD_EXP 61
9099: PPUSH
9100: LD_INT 3
9102: PPUSH
9103: CALL_OW 336
// end ; PlaceHumanInUnit ( Platonov , ru_depot ) ;
9107: LD_EXP 58
9111: PPUSH
9112: LD_INT 126
9114: PPUSH
9115: CALL_OW 52
// PlaceUnitXYR ( Yakotich , 197 , 111 , 9 , false ) ;
9119: LD_EXP 59
9123: PPUSH
9124: LD_INT 197
9126: PPUSH
9127: LD_INT 111
9129: PPUSH
9130: LD_INT 9
9132: PPUSH
9133: LD_INT 0
9135: PPUSH
9136: CALL_OW 50
// PlaceUnitXYR ( Gleb , 197 , 111 , 9 , false ) ;
9140: LD_EXP 60
9144: PPUSH
9145: LD_INT 197
9147: PPUSH
9148: LD_INT 111
9150: PPUSH
9151: LD_INT 9
9153: PPUSH
9154: LD_INT 0
9156: PPUSH
9157: CALL_OW 50
// tmp := PrepareBase ( ru_depot , russianBaseArea , zhukov , [ 9 , 10 , 10 , 10 ] [ Difficulty ] , [ 9000 , 1000 , 300 ] , [ 21 , 8 , 13 , 8 ] ) ;
9161: LD_ADDR_VAR 0 5
9165: PUSH
9166: LD_INT 126
9168: PPUSH
9169: LD_INT 2
9171: PPUSH
9172: LD_STRING zhukov
9174: PPUSH
9175: LD_INT 9
9177: PUSH
9178: LD_INT 10
9180: PUSH
9181: LD_INT 10
9183: PUSH
9184: LD_INT 10
9186: PUSH
9187: EMPTY
9188: LIST
9189: LIST
9190: LIST
9191: LIST
9192: PUSH
9193: LD_OWVAR 67
9197: ARRAY
9198: PPUSH
9199: LD_INT 9000
9201: PUSH
9202: LD_INT 1000
9204: PUSH
9205: LD_INT 300
9207: PUSH
9208: EMPTY
9209: LIST
9210: LIST
9211: LIST
9212: PPUSH
9213: LD_INT 21
9215: PUSH
9216: LD_INT 8
9218: PUSH
9219: LD_INT 13
9221: PUSH
9222: LD_INT 8
9224: PUSH
9225: EMPTY
9226: LIST
9227: LIST
9228: LIST
9229: LIST
9230: PPUSH
9231: CALL 60336 0 6
9235: ST_TO_ADDR
// base := GetBase ( ru_depot2 ) ;
9236: LD_ADDR_VAR 0 4
9240: PUSH
9241: LD_INT 267
9243: PPUSH
9244: CALL_OW 274
9248: ST_TO_ADDR
// SetResourceType ( base , mat_cans , 5000 ) ;
9249: LD_VAR 0 4
9253: PPUSH
9254: LD_INT 1
9256: PPUSH
9257: LD_INT 5000
9259: PPUSH
9260: CALL_OW 277
// SetResourceType ( base , mat_oil , 200 ) ;
9264: LD_VAR 0 4
9268: PPUSH
9269: LD_INT 2
9271: PPUSH
9272: LD_INT 200
9274: PPUSH
9275: CALL_OW 277
// SetResourceType ( base , mat_siberit , 200 ) ;
9279: LD_VAR 0 4
9283: PPUSH
9284: LD_INT 3
9286: PPUSH
9287: LD_INT 200
9289: PPUSH
9290: CALL_OW 277
// mc_bases := Replace ( mc_bases , 2 , tmp union FilterAllUnits ( [ [ f_side , side ] , [ f_not , [ f_type , unit_vehicle ] ] ] ) diff Platonov ) ;
9294: LD_ADDR_EXP 95
9298: PUSH
9299: LD_EXP 95
9303: PPUSH
9304: LD_INT 2
9306: PPUSH
9307: LD_VAR 0 5
9311: PUSH
9312: LD_INT 22
9314: PUSH
9315: LD_VAR 0 6
9319: PUSH
9320: EMPTY
9321: LIST
9322: LIST
9323: PUSH
9324: LD_INT 3
9326: PUSH
9327: LD_INT 21
9329: PUSH
9330: LD_INT 2
9332: PUSH
9333: EMPTY
9334: LIST
9335: LIST
9336: PUSH
9337: EMPTY
9338: LIST
9339: LIST
9340: PUSH
9341: EMPTY
9342: LIST
9343: LIST
9344: PPUSH
9345: CALL_OW 69
9349: UNION
9350: PUSH
9351: LD_EXP 58
9355: DIFF
9356: PPUSH
9357: CALL_OW 1
9361: ST_TO_ADDR
// behemoths := [ ] ;
9362: LD_ADDR_EXP 62
9366: PUSH
9367: EMPTY
9368: ST_TO_ADDR
// behemothBuilders := [ ] ;
9369: LD_ADDR_EXP 63
9373: PUSH
9374: EMPTY
9375: ST_TO_ADDR
// j := 3 ;
9376: LD_ADDR_VAR 0 3
9380: PUSH
9381: LD_INT 3
9383: ST_TO_ADDR
// for i in FilterAllUnits ( [ [ f_side , 3 ] , [ f_class , 3 ] ] ) do
9384: LD_ADDR_VAR 0 2
9388: PUSH
9389: LD_INT 22
9391: PUSH
9392: LD_INT 3
9394: PUSH
9395: EMPTY
9396: LIST
9397: LIST
9398: PUSH
9399: LD_INT 25
9401: PUSH
9402: LD_INT 3
9404: PUSH
9405: EMPTY
9406: LIST
9407: LIST
9408: PUSH
9409: EMPTY
9410: LIST
9411: LIST
9412: PPUSH
9413: CALL_OW 69
9417: PUSH
9418: FOR_IN
9419: IFFALSE 9469
// begin behemothBuilders := Join ( behemothBuilders , i ) ;
9421: LD_ADDR_EXP 63
9425: PUSH
9426: LD_EXP 63
9430: PPUSH
9431: LD_VAR 0 2
9435: PPUSH
9436: CALL 88763 0 2
9440: ST_TO_ADDR
// j := j - 1 ;
9441: LD_ADDR_VAR 0 3
9445: PUSH
9446: LD_VAR 0 3
9450: PUSH
9451: LD_INT 1
9453: MINUS
9454: ST_TO_ADDR
// if j = 0 then
9455: LD_VAR 0 3
9459: PUSH
9460: LD_INT 0
9462: EQUAL
9463: IFFALSE 9467
// break ;
9465: GO 9469
// end ;
9467: GO 9418
9469: POP
9470: POP
// end ;
9471: LD_VAR 0 1
9475: RET
// export function BuildBehemoths ; var i , j , xy , tmp ; begin
9476: LD_INT 0
9478: PPUSH
9479: PPUSH
9480: PPUSH
9481: PPUSH
9482: PPUSH
// xy := [ [ 209 , 149 ] , [ 219 , 154 ] , [ 223 , 149 ] , [ 232 , 155 ] ] ;
9483: LD_ADDR_VAR 0 4
9487: PUSH
9488: LD_INT 209
9490: PUSH
9491: LD_INT 149
9493: PUSH
9494: EMPTY
9495: LIST
9496: LIST
9497: PUSH
9498: LD_INT 219
9500: PUSH
9501: LD_INT 154
9503: PUSH
9504: EMPTY
9505: LIST
9506: LIST
9507: PUSH
9508: LD_INT 223
9510: PUSH
9511: LD_INT 149
9513: PUSH
9514: EMPTY
9515: LIST
9516: LIST
9517: PUSH
9518: LD_INT 232
9520: PUSH
9521: LD_INT 155
9523: PUSH
9524: EMPTY
9525: LIST
9526: LIST
9527: PUSH
9528: EMPTY
9529: LIST
9530: LIST
9531: LIST
9532: LIST
9533: ST_TO_ADDR
// if not behemothBuilders then
9534: LD_EXP 63
9538: NOT
9539: IFFALSE 9543
// exit ;
9541: GO 9647
// j := 1 ;
9543: LD_ADDR_VAR 0 3
9547: PUSH
9548: LD_INT 1
9550: ST_TO_ADDR
// for i in behemothBuilders do
9551: LD_ADDR_VAR 0 2
9555: PUSH
9556: LD_EXP 63
9560: PUSH
9561: FOR_IN
9562: IFFALSE 9645
// begin if IsInUnit ( i ) then
9564: LD_VAR 0 2
9568: PPUSH
9569: CALL_OW 310
9573: IFFALSE 9584
// ComExitBuilding ( i ) ;
9575: LD_VAR 0 2
9579: PPUSH
9580: CALL_OW 122
// AddComBuildBehemoth ( i , b_behemoth , xy [ j ] [ 1 ] , xy [ j ] [ 2 ] , 0 ) ;
9584: LD_VAR 0 2
9588: PPUSH
9589: LD_INT 37
9591: PPUSH
9592: LD_VAR 0 4
9596: PUSH
9597: LD_VAR 0 3
9601: ARRAY
9602: PUSH
9603: LD_INT 1
9605: ARRAY
9606: PPUSH
9607: LD_VAR 0 4
9611: PUSH
9612: LD_VAR 0 3
9616: ARRAY
9617: PUSH
9618: LD_INT 2
9620: ARRAY
9621: PPUSH
9622: LD_INT 0
9624: PPUSH
9625: CALL_OW 230
// j := j + 1 ;
9629: LD_ADDR_VAR 0 3
9633: PUSH
9634: LD_VAR 0 3
9638: PUSH
9639: LD_INT 1
9641: PLUS
9642: ST_TO_ADDR
// end ;
9643: GO 9561
9645: POP
9646: POP
// end ;
9647: LD_VAR 0 1
9651: RET
// every 0 0$3 trigger GetBehemoths ( 3 ) and not FilterAllUnits ( [ [ f_side , 3 ] , [ f_btype , b_behemoth ] ] ) do var i , tmp ;
9652: LD_INT 3
9654: PPUSH
9655: CALL 88824 0 1
9659: PUSH
9660: LD_INT 22
9662: PUSH
9663: LD_INT 3
9665: PUSH
9666: EMPTY
9667: LIST
9668: LIST
9669: PUSH
9670: LD_INT 30
9672: PUSH
9673: LD_INT 37
9675: PUSH
9676: EMPTY
9677: LIST
9678: LIST
9679: PUSH
9680: EMPTY
9681: LIST
9682: LIST
9683: PPUSH
9684: CALL_OW 69
9688: NOT
9689: AND
9690: IFFALSE 9876
9692: GO 9694
9694: DISABLE
9695: LD_INT 0
9697: PPUSH
9698: PPUSH
// begin enable ;
9699: ENABLE
// tmp := GetBehemoths ( 3 ) ;
9700: LD_ADDR_VAR 0 2
9704: PUSH
9705: LD_INT 3
9707: PPUSH
9708: CALL 88824 0 1
9712: ST_TO_ADDR
// for i in tmp do
9713: LD_ADDR_VAR 0 1
9717: PUSH
9718: LD_VAR 0 2
9722: PUSH
9723: FOR_IN
9724: IFFALSE 9874
// begin if IsInArea ( i , powellBase ) and not GetTag ( i ) = 2 then
9726: LD_VAR 0 1
9730: PPUSH
9731: LD_INT 7
9733: PPUSH
9734: CALL_OW 308
9738: PUSH
9739: LD_VAR 0 1
9743: PPUSH
9744: CALL_OW 110
9748: PUSH
9749: LD_INT 2
9751: EQUAL
9752: NOT
9753: AND
9754: IFFALSE 9768
// SetTag ( i , 2 ) ;
9756: LD_VAR 0 1
9760: PPUSH
9761: LD_INT 2
9763: PPUSH
9764: CALL_OW 109
// if not FilterAllUnits ( [ [ f_enemy , 3 ] , [ f_dist , i , 12 ] ] ) and not GetTag ( i ) = 2 then
9768: LD_INT 81
9770: PUSH
9771: LD_INT 3
9773: PUSH
9774: EMPTY
9775: LIST
9776: LIST
9777: PUSH
9778: LD_INT 91
9780: PUSH
9781: LD_VAR 0 1
9785: PUSH
9786: LD_INT 12
9788: PUSH
9789: EMPTY
9790: LIST
9791: LIST
9792: LIST
9793: PUSH
9794: EMPTY
9795: LIST
9796: LIST
9797: PPUSH
9798: CALL_OW 69
9802: NOT
9803: PUSH
9804: LD_VAR 0 1
9808: PPUSH
9809: CALL_OW 110
9813: PUSH
9814: LD_INT 2
9816: EQUAL
9817: NOT
9818: AND
9819: IFFALSE 9838
// ComAgressiveMove ( i , 64 , 93 ) else
9821: LD_VAR 0 1
9825: PPUSH
9826: LD_INT 64
9828: PPUSH
9829: LD_INT 93
9831: PPUSH
9832: CALL_OW 114
9836: GO 9872
// ComAttackUnit ( i , NearestUnitToUnit ( FilterAllUnits ( [ f_enemy , 3 ] ) , i ) ) ;
9838: LD_VAR 0 1
9842: PPUSH
9843: LD_INT 81
9845: PUSH
9846: LD_INT 3
9848: PUSH
9849: EMPTY
9850: LIST
9851: LIST
9852: PPUSH
9853: CALL_OW 69
9857: PPUSH
9858: LD_VAR 0 1
9862: PPUSH
9863: CALL_OW 74
9867: PPUSH
9868: CALL_OW 115
// end ;
9872: GO 9723
9874: POP
9875: POP
// end ;
9876: PPOPN 2
9878: END
// every 11 11$30 trigger not russianDestroyed and not MC_GetVehicles ( 2 , true ) do var i , tmp , target , teleport ;
9879: LD_EXP 2
9883: NOT
9884: PUSH
9885: LD_INT 2
9887: PPUSH
9888: LD_INT 1
9890: PPUSH
9891: CALL 47038 0 2
9895: NOT
9896: AND
9897: IFFALSE 10821
9899: GO 9901
9901: DISABLE
9902: LD_INT 0
9904: PPUSH
9905: PPUSH
9906: PPUSH
9907: PPUSH
// begin enable ;
9908: ENABLE
// if not FilterAllUnits ( [ [ f_side , 3 ] , [ f_btype , b_factory ] ] ) then
9909: LD_INT 22
9911: PUSH
9912: LD_INT 3
9914: PUSH
9915: EMPTY
9916: LIST
9917: LIST
9918: PUSH
9919: LD_INT 30
9921: PUSH
9922: LD_INT 3
9924: PUSH
9925: EMPTY
9926: LIST
9927: LIST
9928: PUSH
9929: EMPTY
9930: LIST
9931: LIST
9932: PPUSH
9933: CALL_OW 69
9937: NOT
9938: IFFALSE 9942
// exit ;
9940: GO 10821
// teleport := FilterAllUnits ( [ [ f_side , 3 ] , [ f_btype , b_teleport ] ] ) ;
9942: LD_ADDR_VAR 0 4
9946: PUSH
9947: LD_INT 22
9949: PUSH
9950: LD_INT 3
9952: PUSH
9953: EMPTY
9954: LIST
9955: LIST
9956: PUSH
9957: LD_INT 30
9959: PUSH
9960: LD_INT 34
9962: PUSH
9963: EMPTY
9964: LIST
9965: LIST
9966: PUSH
9967: EMPTY
9968: LIST
9969: LIST
9970: PPUSH
9971: CALL_OW 69
9975: ST_TO_ADDR
// if Prob ( 40 ) then
9976: LD_INT 40
9978: PPUSH
9979: CALL_OW 13
9983: IFFALSE 10110
// begin MC_InsertProduceList ( 2 , [ [ ru_medium_tracked , engine_siberite , control_computer , ru_time_lapser ] , [ ru_medium_tracked , engine_siberite , control_computer , ru_time_lapser ] , [ ru_medium_tracked , engine_siberite , control_computer , ru_time_lapser ] , [ ru_heavy_tracked , engine_siberite , control_computer , ru_heavy_gun ] , [ ru_heavy_tracked , engine_siberite , control_computer , ru_heavy_gun ] , [ ru_heavy_tracked , engine_siberite , control_computer , ru_heavy_gun ] ] ) ;
9985: LD_INT 2
9987: PPUSH
9988: LD_INT 22
9990: PUSH
9991: LD_INT 3
9993: PUSH
9994: LD_INT 3
9996: PUSH
9997: LD_INT 49
9999: PUSH
10000: EMPTY
10001: LIST
10002: LIST
10003: LIST
10004: LIST
10005: PUSH
10006: LD_INT 22
10008: PUSH
10009: LD_INT 3
10011: PUSH
10012: LD_INT 3
10014: PUSH
10015: LD_INT 49
10017: PUSH
10018: EMPTY
10019: LIST
10020: LIST
10021: LIST
10022: LIST
10023: PUSH
10024: LD_INT 22
10026: PUSH
10027: LD_INT 3
10029: PUSH
10030: LD_INT 3
10032: PUSH
10033: LD_INT 49
10035: PUSH
10036: EMPTY
10037: LIST
10038: LIST
10039: LIST
10040: LIST
10041: PUSH
10042: LD_INT 24
10044: PUSH
10045: LD_INT 3
10047: PUSH
10048: LD_INT 3
10050: PUSH
10051: LD_INT 46
10053: PUSH
10054: EMPTY
10055: LIST
10056: LIST
10057: LIST
10058: LIST
10059: PUSH
10060: LD_INT 24
10062: PUSH
10063: LD_INT 3
10065: PUSH
10066: LD_INT 3
10068: PUSH
10069: LD_INT 46
10071: PUSH
10072: EMPTY
10073: LIST
10074: LIST
10075: LIST
10076: LIST
10077: PUSH
10078: LD_INT 24
10080: PUSH
10081: LD_INT 3
10083: PUSH
10084: LD_INT 3
10086: PUSH
10087: LD_INT 46
10089: PUSH
10090: EMPTY
10091: LIST
10092: LIST
10093: LIST
10094: LIST
10095: PUSH
10096: EMPTY
10097: LIST
10098: LIST
10099: LIST
10100: LIST
10101: LIST
10102: LIST
10103: PPUSH
10104: CALL 45620 0 2
// end else
10108: GO 10233
// begin MC_InsertProduceList ( 2 , [ [ ru_heavy_tracked , engine_siberite , control_computer , ru_rocket ] , [ ru_heavy_tracked , engine_siberite , control_computer , ru_rocket ] , [ ru_heavy_tracked , engine_siberite , control_computer , ru_rocket ] , [ ru_heavy_tracked , engine_siberite , control_computer , ru_heavy_gun ] , [ ru_heavy_tracked , engine_siberite , control_computer , ru_heavy_gun ] , [ ru_heavy_tracked , engine_siberite , control_computer , ru_heavy_gun ] ] ) ;
10110: LD_INT 2
10112: PPUSH
10113: LD_INT 24
10115: PUSH
10116: LD_INT 3
10118: PUSH
10119: LD_INT 3
10121: PUSH
10122: LD_INT 47
10124: PUSH
10125: EMPTY
10126: LIST
10127: LIST
10128: LIST
10129: LIST
10130: PUSH
10131: LD_INT 24
10133: PUSH
10134: LD_INT 3
10136: PUSH
10137: LD_INT 3
10139: PUSH
10140: LD_INT 47
10142: PUSH
10143: EMPTY
10144: LIST
10145: LIST
10146: LIST
10147: LIST
10148: PUSH
10149: LD_INT 24
10151: PUSH
10152: LD_INT 3
10154: PUSH
10155: LD_INT 3
10157: PUSH
10158: LD_INT 47
10160: PUSH
10161: EMPTY
10162: LIST
10163: LIST
10164: LIST
10165: LIST
10166: PUSH
10167: LD_INT 24
10169: PUSH
10170: LD_INT 3
10172: PUSH
10173: LD_INT 3
10175: PUSH
10176: LD_INT 46
10178: PUSH
10179: EMPTY
10180: LIST
10181: LIST
10182: LIST
10183: LIST
10184: PUSH
10185: LD_INT 24
10187: PUSH
10188: LD_INT 3
10190: PUSH
10191: LD_INT 3
10193: PUSH
10194: LD_INT 46
10196: PUSH
10197: EMPTY
10198: LIST
10199: LIST
10200: LIST
10201: LIST
10202: PUSH
10203: LD_INT 24
10205: PUSH
10206: LD_INT 3
10208: PUSH
10209: LD_INT 3
10211: PUSH
10212: LD_INT 46
10214: PUSH
10215: EMPTY
10216: LIST
10217: LIST
10218: LIST
10219: LIST
10220: PUSH
10221: EMPTY
10222: LIST
10223: LIST
10224: LIST
10225: LIST
10226: LIST
10227: LIST
10228: PPUSH
10229: CALL 45620 0 2
// end ; if Difficulty > 1 then
10233: LD_OWVAR 67
10237: PUSH
10238: LD_INT 1
10240: GREATER
10241: IFFALSE 10271
// MC_InsertProduceList ( 2 , [ [ ru_heavy_tracked , engine_siberite , control_computer , ru_rocket ] ] ) ;
10243: LD_INT 2
10245: PPUSH
10246: LD_INT 24
10248: PUSH
10249: LD_INT 3
10251: PUSH
10252: LD_INT 3
10254: PUSH
10255: LD_INT 47
10257: PUSH
10258: EMPTY
10259: LIST
10260: LIST
10261: LIST
10262: LIST
10263: PUSH
10264: EMPTY
10265: LIST
10266: PPUSH
10267: CALL 45620 0 2
// repeat wait ( 0 0$1 ) ;
10271: LD_INT 35
10273: PPUSH
10274: CALL_OW 67
// until MC_GetVehicles ( 2 , true ) >= [ 6 , 7 , 7 , 7 ] [ Difficulty ] ;
10278: LD_INT 2
10280: PPUSH
10281: LD_INT 1
10283: PPUSH
10284: CALL 47038 0 2
10288: PUSH
10289: LD_INT 6
10291: PUSH
10292: LD_INT 7
10294: PUSH
10295: LD_INT 7
10297: PUSH
10298: LD_INT 7
10300: PUSH
10301: EMPTY
10302: LIST
10303: LIST
10304: LIST
10305: LIST
10306: PUSH
10307: LD_OWVAR 67
10311: ARRAY
10312: GREATEREQUAL
10313: IFFALSE 10271
// wait ( 0 0$30 ) ;
10315: LD_INT 1050
10317: PPUSH
10318: CALL_OW 67
// tmp := MC_GetVehicles ( 2 , true ) ;
10322: LD_ADDR_VAR 0 2
10326: PUSH
10327: LD_INT 2
10329: PPUSH
10330: LD_INT 1
10332: PPUSH
10333: CALL 47038 0 2
10337: ST_TO_ADDR
// mc_vehicles := Replace ( mc_vehicles , 2 , mc_vehicles [ 2 ] diff tmp ) ;
10338: LD_ADDR_EXP 114
10342: PUSH
10343: LD_EXP 114
10347: PPUSH
10348: LD_INT 2
10350: PPUSH
10351: LD_EXP 114
10355: PUSH
10356: LD_INT 2
10358: ARRAY
10359: PUSH
10360: LD_VAR 0 2
10364: DIFF
10365: PPUSH
10366: CALL_OW 1
10370: ST_TO_ADDR
// target := rand ( 0 , 1 ) ;
10371: LD_ADDR_VAR 0 3
10375: PUSH
10376: LD_INT 0
10378: PPUSH
10379: LD_INT 1
10381: PPUSH
10382: CALL_OW 12
10386: ST_TO_ADDR
// if target then
10387: LD_VAR 0 3
10391: IFFALSE 10519
// begin repeat tmp := UnitFilter ( tmp , [ f_lives , 250 ] ) ;
10393: LD_ADDR_VAR 0 2
10397: PUSH
10398: LD_VAR 0 2
10402: PPUSH
10403: LD_INT 24
10405: PUSH
10406: LD_INT 250
10408: PUSH
10409: EMPTY
10410: LIST
10411: LIST
10412: PPUSH
10413: CALL_OW 72
10417: ST_TO_ADDR
// for i in tmp do
10418: LD_ADDR_VAR 0 1
10422: PUSH
10423: LD_VAR 0 2
10427: PUSH
10428: FOR_IN
10429: IFFALSE 10469
// if GetDistUnitXY ( i , 139 , 89 ) > 9 then
10431: LD_VAR 0 1
10435: PPUSH
10436: LD_INT 139
10438: PPUSH
10439: LD_INT 89
10441: PPUSH
10442: CALL_OW 297
10446: PUSH
10447: LD_INT 9
10449: GREATER
10450: IFFALSE 10467
// ComMoveXY ( i , 139 , 89 ) ;
10452: LD_VAR 0 1
10456: PPUSH
10457: LD_INT 139
10459: PPUSH
10460: LD_INT 89
10462: PPUSH
10463: CALL_OW 111
10467: GO 10428
10469: POP
10470: POP
// wait ( 0 0$1 ) ;
10471: LD_INT 35
10473: PPUSH
10474: CALL_OW 67
// until UnitFilter ( tmp , [ f_distxy , 139 , 89 , 9 ] ) >= ( tmp - 1 ) ;
10478: LD_VAR 0 2
10482: PPUSH
10483: LD_INT 92
10485: PUSH
10486: LD_INT 139
10488: PUSH
10489: LD_INT 89
10491: PUSH
10492: LD_INT 9
10494: PUSH
10495: EMPTY
10496: LIST
10497: LIST
10498: LIST
10499: LIST
10500: PPUSH
10501: CALL_OW 72
10505: PUSH
10506: LD_VAR 0 2
10510: PUSH
10511: LD_INT 1
10513: MINUS
10514: GREATEREQUAL
10515: IFFALSE 10393
// end else
10517: GO 10661
// begin ComEnterUnit ( tmp , teleport [ 1 ] ) ;
10519: LD_VAR 0 2
10523: PPUSH
10524: LD_VAR 0 4
10528: PUSH
10529: LD_INT 1
10531: ARRAY
10532: PPUSH
10533: CALL_OW 120
// repeat tmp := UnitFilter ( tmp , [ f_lives , 250 ] ) ;
10537: LD_ADDR_VAR 0 2
10541: PUSH
10542: LD_VAR 0 2
10546: PPUSH
10547: LD_INT 24
10549: PUSH
10550: LD_INT 250
10552: PUSH
10553: EMPTY
10554: LIST
10555: LIST
10556: PPUSH
10557: CALL_OW 72
10561: ST_TO_ADDR
// for i in tmp do
10562: LD_ADDR_VAR 0 1
10566: PUSH
10567: LD_VAR 0 2
10571: PUSH
10572: FOR_IN
10573: IFFALSE 10613
// if GetDistUnitXY ( i , 124 , 139 ) > 9 then
10575: LD_VAR 0 1
10579: PPUSH
10580: LD_INT 124
10582: PPUSH
10583: LD_INT 139
10585: PPUSH
10586: CALL_OW 297
10590: PUSH
10591: LD_INT 9
10593: GREATER
10594: IFFALSE 10611
// ComMoveXY ( i , 124 , 139 ) ;
10596: LD_VAR 0 1
10600: PPUSH
10601: LD_INT 124
10603: PPUSH
10604: LD_INT 139
10606: PPUSH
10607: CALL_OW 111
10611: GO 10572
10613: POP
10614: POP
// wait ( 0 0$1 ) ;
10615: LD_INT 35
10617: PPUSH
10618: CALL_OW 67
// until UnitFilter ( tmp , [ f_distxy , 124 , 139 , 9 ] ) >= ( tmp - 1 ) ;
10622: LD_VAR 0 2
10626: PPUSH
10627: LD_INT 92
10629: PUSH
10630: LD_INT 124
10632: PUSH
10633: LD_INT 139
10635: PUSH
10636: LD_INT 9
10638: PUSH
10639: EMPTY
10640: LIST
10641: LIST
10642: LIST
10643: LIST
10644: PPUSH
10645: CALL_OW 72
10649: PUSH
10650: LD_VAR 0 2
10654: PUSH
10655: LD_INT 1
10657: MINUS
10658: GREATEREQUAL
10659: IFFALSE 10537
// end ; repeat wait ( 0 0$1 ) ;
10661: LD_INT 35
10663: PPUSH
10664: CALL_OW 67
// for i in tmp do
10668: LD_ADDR_VAR 0 1
10672: PUSH
10673: LD_VAR 0 2
10677: PUSH
10678: FOR_IN
10679: IFFALSE 10812
// begin if GetLives ( i ) > 251 then
10681: LD_VAR 0 1
10685: PPUSH
10686: CALL_OW 256
10690: PUSH
10691: LD_INT 251
10693: GREATER
10694: IFFALSE 10783
// begin if GetWeapon ( i ) = ru_time_lapser then
10696: LD_VAR 0 1
10700: PPUSH
10701: CALL_OW 264
10705: PUSH
10706: LD_INT 49
10708: EQUAL
10709: IFFALSE 10747
// ComMoveUnit ( i , NearestUnitToUnit ( FilterAllUnits ( [ f_enemy , 3 ] ) , i ) ) else
10711: LD_VAR 0 1
10715: PPUSH
10716: LD_INT 81
10718: PUSH
10719: LD_INT 3
10721: PUSH
10722: EMPTY
10723: LIST
10724: LIST
10725: PPUSH
10726: CALL_OW 69
10730: PPUSH
10731: LD_VAR 0 1
10735: PPUSH
10736: CALL_OW 74
10740: PPUSH
10741: CALL_OW 112
10745: GO 10781
// ComAttackUnit ( i , NearestUnitToUnit ( FilterAllUnits ( [ f_enemy , 3 ] ) , i ) ) ;
10747: LD_VAR 0 1
10751: PPUSH
10752: LD_INT 81
10754: PUSH
10755: LD_INT 3
10757: PUSH
10758: EMPTY
10759: LIST
10760: LIST
10761: PPUSH
10762: CALL_OW 69
10766: PPUSH
10767: LD_VAR 0 1
10771: PPUSH
10772: CALL_OW 74
10776: PPUSH
10777: CALL_OW 115
// end else
10781: GO 10810
// if IsDead ( i ) then
10783: LD_VAR 0 1
10787: PPUSH
10788: CALL_OW 301
10792: IFFALSE 10810
// tmp := tmp diff i ;
10794: LD_ADDR_VAR 0 2
10798: PUSH
10799: LD_VAR 0 2
10803: PUSH
10804: LD_VAR 0 1
10808: DIFF
10809: ST_TO_ADDR
// end ;
10810: GO 10678
10812: POP
10813: POP
// until not tmp ;
10814: LD_VAR 0 2
10818: NOT
10819: IFFALSE 10661
// end ;
10821: PPOPN 4
10823: END
// every 30 30$00 trigger not russianDestroyed do
10824: LD_EXP 2
10828: NOT
10829: IFFALSE 10898
10831: GO 10833
10833: DISABLE
// begin wait ( [ 50 50$00 , 40 40$00 , 30 30$00 , 25 25$00 ] [ Difficulty ] ) ;
10834: LD_INT 105000
10836: PUSH
10837: LD_INT 84000
10839: PUSH
10840: LD_INT 63000
10842: PUSH
10843: LD_INT 52500
10845: PUSH
10846: EMPTY
10847: LIST
10848: LIST
10849: LIST
10850: LIST
10851: PUSH
10852: LD_OWVAR 67
10856: ARRAY
10857: PPUSH
10858: CALL_OW 67
// if russianDestroyed then
10862: LD_EXP 2
10866: IFFALSE 10870
// exit ;
10868: GO 10898
// MC_InsertProduceList ( 2 , [ [ ru_heavy_wheeled , engine_siberite , control_manual , ru_siberium_rocket ] ] ) ;
10870: LD_INT 2
10872: PPUSH
10873: LD_INT 23
10875: PUSH
10876: LD_INT 3
10878: PUSH
10879: LD_INT 1
10881: PUSH
10882: LD_INT 48
10884: PUSH
10885: EMPTY
10886: LIST
10887: LIST
10888: LIST
10889: LIST
10890: PUSH
10891: EMPTY
10892: LIST
10893: PPUSH
10894: CALL 45620 0 2
// end ; end_of_file
10898: END
// export function CustomEvent ( event ) ; begin
10899: LD_INT 0
10901: PPUSH
// end ;
10902: LD_VAR 0 2
10906: RET
// on SibDepositContaminated ( unit , x , y ) do begin if InArea ( x , y , motherLodeArea ) then
10907: LD_VAR 0 2
10911: PPUSH
10912: LD_VAR 0 3
10916: PPUSH
10917: LD_INT 15
10919: PPUSH
10920: CALL_OW 309
10924: IFFALSE 10933
// YouLost ( MothContaminate ) ;
10926: LD_STRING MothContaminate
10928: PPUSH
10929: CALL_OW 104
// end ;
10933: PPOPN 3
10935: END
// on SiberiteRocketExploded ( unit , x , y ) do begin if InArea ( x , y , motherLodeArea ) then
10936: LD_VAR 0 2
10940: PPUSH
10941: LD_VAR 0 3
10945: PPUSH
10946: LD_INT 15
10948: PPUSH
10949: CALL_OW 309
10953: IFFALSE 10969
// begin wait ( 0 0$6 ) ;
10955: LD_INT 210
10957: PPUSH
10958: CALL_OW 67
// YouLost ( MothContaminateBomb ) ;
10962: LD_STRING MothContaminateBomb
10964: PPUSH
10965: CALL_OW 104
// end ; end ;
10969: PPOPN 3
10971: END
// on UnitDestroyed ( un ) do begin if un = JMM then
10972: LD_VAR 0 1
10976: PUSH
10977: LD_EXP 19
10981: EQUAL
10982: IFFALSE 10993
// begin YouLost ( JMM ) ;
10984: LD_STRING JMM
10986: PPUSH
10987: CALL_OW 104
// exit ;
10991: GO 11122
// end ; if GetSide ( un ) = 2 and not arabianAttacked then
10993: LD_VAR 0 1
10997: PPUSH
10998: CALL_OW 255
11002: PUSH
11003: LD_INT 2
11005: EQUAL
11006: PUSH
11007: LD_EXP 18
11011: NOT
11012: AND
11013: IFFALSE 11023
// arabianAttacked := true ;
11015: LD_ADDR_EXP 18
11019: PUSH
11020: LD_INT 1
11022: ST_TO_ADDR
// if un = Powell then
11023: LD_VAR 0 1
11027: PUSH
11028: LD_EXP 54
11032: EQUAL
11033: IFFALSE 11043
// americanDestroyed := true ;
11035: LD_ADDR_EXP 4
11039: PUSH
11040: LD_INT 1
11042: ST_TO_ADDR
// if un = Platonov then
11043: LD_VAR 0 1
11047: PUSH
11048: LD_EXP 58
11052: EQUAL
11053: IFFALSE 11063
// russianDestroyed := true ;
11055: LD_ADDR_EXP 2
11059: PUSH
11060: LD_INT 1
11062: ST_TO_ADDR
// if un in FilterAllUnits ( [ [ f_side , 7 ] , [ f_type , unit_vehicle ] ] ) then
11063: LD_VAR 0 1
11067: PUSH
11068: LD_INT 22
11070: PUSH
11071: LD_INT 7
11073: PUSH
11074: EMPTY
11075: LIST
11076: LIST
11077: PUSH
11078: LD_INT 21
11080: PUSH
11081: LD_INT 2
11083: PUSH
11084: EMPTY
11085: LIST
11086: LIST
11087: PUSH
11088: EMPTY
11089: LIST
11090: LIST
11091: PPUSH
11092: CALL_OW 69
11096: IN
11097: IFFALSE 11113
// vehicleLostCounter := vehicleLostCounter + 1 ;
11099: LD_ADDR_EXP 15
11103: PUSH
11104: LD_EXP 15
11108: PUSH
11109: LD_INT 1
11111: PLUS
11112: ST_TO_ADDR
// MCE_UnitDestroyed ( un ) ;
11113: LD_VAR 0 1
11117: PPUSH
11118: CALL 49040 0 1
// end ;
11122: PPOPN 1
11124: END
// on BuildingStarted ( building , builder ) do begin MCE_BuildingStarted ( building , builder ) ;
11125: LD_VAR 0 1
11129: PPUSH
11130: LD_VAR 0 2
11134: PPUSH
11135: CALL 51374 0 2
// end ;
11139: PPOPN 2
11141: END
// on UpgradeComplete ( building ) do begin MCE_UpgradeComplete ( building ) ;
11142: LD_VAR 0 1
11146: PPUSH
11147: CALL 50442 0 1
// end ;
11151: PPOPN 1
11153: END
// on BuildingComplete ( building ) do begin if building in FilterAllUnits ( [ [ f_side , 8 ] , [ f_btype , b_workshop ] , [ f_nation , 3 ] ] ) then
11154: LD_VAR 0 1
11158: PUSH
11159: LD_INT 22
11161: PUSH
11162: LD_INT 8
11164: PUSH
11165: EMPTY
11166: LIST
11167: LIST
11168: PUSH
11169: LD_INT 30
11171: PUSH
11172: LD_INT 2
11174: PUSH
11175: EMPTY
11176: LIST
11177: LIST
11178: PUSH
11179: LD_INT 23
11181: PUSH
11182: LD_INT 3
11184: PUSH
11185: EMPTY
11186: LIST
11187: LIST
11188: PUSH
11189: EMPTY
11190: LIST
11191: LIST
11192: LIST
11193: PPUSH
11194: CALL_OW 69
11198: IN
11199: IFFALSE 11226
// begin ComUpgrade ( building ) ;
11201: LD_VAR 0 1
11205: PPUSH
11206: CALL_OW 146
// ComComplete ( Kozlov , building ) ;
11210: LD_EXP 57
11214: PPUSH
11215: LD_VAR 0 1
11219: PPUSH
11220: CALL 59875 0 2
// exit ;
11224: GO 11235
// end ; MCE_BuildingComplete ( building ) ;
11226: LD_VAR 0 1
11230: PPUSH
11231: CALL 50683 0 1
// end ;
11235: PPOPN 1
11237: END
// on ResearchComplete ( tech , lab ) do begin MCE_ResearchComplete ( tech , lab ) ;
11238: LD_VAR 0 1
11242: PPUSH
11243: LD_VAR 0 2
11247: PPUSH
11248: CALL 48736 0 2
// end ;
11252: PPOPN 2
11254: END
// on CrateSpawn ( id , x , y , amount , mode ) do begin MCE_CrateSpawn ( id , x , y , amount , mode ) ;
11255: LD_VAR 0 1
11259: PPUSH
11260: LD_VAR 0 2
11264: PPUSH
11265: LD_VAR 0 3
11269: PPUSH
11270: LD_VAR 0 4
11274: PPUSH
11275: LD_VAR 0 5
11279: PPUSH
11280: CALL 48356 0 5
// end ;
11284: PPOPN 5
11286: END
// on VehicleConstructed ( vehicle , factory ) do begin MCE_VehicleConstructed ( vehicle , factory ) ;
11287: LD_VAR 0 1
11291: PPUSH
11292: LD_VAR 0 2
11296: PPUSH
11297: CALL 47937 0 2
// end ;
11301: PPOPN 2
11303: END
// on VehicleCaptured ( new , old , side , capturing_unit ) do begin MCE_VehicleCaptured ( new , old , side , capturing_unit ) ;
11304: LD_VAR 0 1
11308: PPUSH
11309: LD_VAR 0 2
11313: PPUSH
11314: LD_VAR 0 3
11318: PPUSH
11319: LD_VAR 0 4
11323: PPUSH
11324: CALL 47775 0 4
// end ;
11328: PPOPN 4
11330: END
// on BuildingCaptured ( building , side , capturning_unit ) do begin MCE_BuildingCaptured ( building , side , capturning_unit ) ;
11331: LD_VAR 0 1
11335: PPUSH
11336: LD_VAR 0 2
11340: PPUSH
11341: LD_VAR 0 3
11345: PPUSH
11346: CALL 47550 0 3
// end ;
11350: PPOPN 3
11352: END
// on EnterBuilding ( building , unit ) do begin MCE_EnterBuilding ( building , unit ) ;
11353: LD_VAR 0 1
11357: PPUSH
11358: LD_VAR 0 2
11362: PPUSH
11363: CALL 47435 0 2
// end ;
11367: PPOPN 2
11369: END
// on LeaveBuilding ( building , unit ) do begin MCE_LeaveBuilding ( building , unit ) ;
11370: LD_VAR 0 1
11374: PPUSH
11375: LD_VAR 0 2
11379: PPUSH
11380: CALL 51669 0 2
// end ;
11384: PPOPN 2
11386: END
// on EvacuateVehicle ( driver , abandoned_vehicle , unknown1 , unknown2 ) do begin MCE_EvacuateVehicle ( driver , abandoned_vehicle , unknown1 , unknown2 ) ;
11387: LD_VAR 0 1
11391: PPUSH
11392: LD_VAR 0 2
11396: PPUSH
11397: LD_VAR 0 3
11401: PPUSH
11402: LD_VAR 0 4
11406: PPUSH
11407: CALL 51885 0 4
// end ;
11411: PPOPN 4
11413: END
// on ApemanTamed ( ape , sci ) do begin MCE_ApemanTamed ( ape , sci ) ;
11414: LD_VAR 0 1
11418: PPUSH
11419: LD_VAR 0 2
11423: PPUSH
11424: CALL 47244 0 2
// end ;
11428: PPOPN 2
11430: END
// on Command ( cmd ) do begin SOS_Command ( cmd ) ;
11431: LD_VAR 0 1
11435: PPUSH
11436: CALL 106552 0 1
// end ; end_of_file
11440: PPOPN 1
11442: END
// export function Action ; begin
11443: LD_INT 0
11445: PPUSH
// InGameOn ;
11446: CALL_OW 8
// CenterNowOnXY ( 206 , 11 ) ;
11450: LD_INT 206
11452: PPUSH
11453: LD_INT 11
11455: PPUSH
11456: CALL_OW 86
// wait ( 0 0$1 ) ;
11460: LD_INT 35
11462: PPUSH
11463: CALL_OW 67
// Say ( JMM , DStart-JMM-JMM-1 ) ;
11467: LD_EXP 19
11471: PPUSH
11472: LD_STRING DStart-JMM-JMM-1
11474: PPUSH
11475: CALL_OW 88
// Say ( Burlak , DStart-JMM-Bur-1 ) ;
11479: LD_EXP 51
11483: PPUSH
11484: LD_STRING DStart-JMM-Bur-1
11486: PPUSH
11487: CALL_OW 88
// Say ( JMM , DStart-JMM-JMM-2 ) ;
11491: LD_EXP 19
11495: PPUSH
11496: LD_STRING DStart-JMM-JMM-2
11498: PPUSH
11499: CALL_OW 88
// Say ( Burlak , DStart-JMM-Bur-2 ) ;
11503: LD_EXP 51
11507: PPUSH
11508: LD_STRING DStart-JMM-Bur-2
11510: PPUSH
11511: CALL_OW 88
// InGameOff ;
11515: CALL_OW 9
// ChangeMissionObjectives ( MStart ) ;
11519: LD_STRING MStart
11521: PPUSH
11522: CALL_OW 337
// SaveForQuickRestart ;
11526: CALL_OW 22
// end ;
11530: LD_VAR 0 1
11534: RET
// every 0 0$2 trigger SeeXY ( 7 , 255 , 219 ) do var speaker ;
11535: LD_INT 7
11537: PPUSH
11538: LD_INT 255
11540: PPUSH
11541: LD_INT 219
11543: PPUSH
11544: CALL_OW 293
11548: IFFALSE 12157
11550: GO 11552
11552: DISABLE
11553: LD_INT 0
11555: PPUSH
// begin wait ( 0 0$3 ) ;
11556: LD_INT 105
11558: PPUSH
11559: CALL_OW 67
// alienSpotted := true ;
11563: LD_ADDR_EXP 10
11567: PUSH
11568: LD_INT 1
11570: ST_TO_ADDR
// speaker := FilterAllUnits ( [ [ f_side , 7 ] , [ f_nation , 3 ] , [ f_type , unit_human ] , [ f_sex , sex_male ] ] ) diff [ Burlak , Titov , Dolgov , Petrosyan , Kuzmov , Kovalyuk , Scholtze ] ;
11571: LD_ADDR_VAR 0 1
11575: PUSH
11576: LD_INT 22
11578: PUSH
11579: LD_INT 7
11581: PUSH
11582: EMPTY
11583: LIST
11584: LIST
11585: PUSH
11586: LD_INT 23
11588: PUSH
11589: LD_INT 3
11591: PUSH
11592: EMPTY
11593: LIST
11594: LIST
11595: PUSH
11596: LD_INT 21
11598: PUSH
11599: LD_INT 1
11601: PUSH
11602: EMPTY
11603: LIST
11604: LIST
11605: PUSH
11606: LD_INT 26
11608: PUSH
11609: LD_INT 1
11611: PUSH
11612: EMPTY
11613: LIST
11614: LIST
11615: PUSH
11616: EMPTY
11617: LIST
11618: LIST
11619: LIST
11620: LIST
11621: PPUSH
11622: CALL_OW 69
11626: PUSH
11627: LD_EXP 51
11631: PUSH
11632: LD_EXP 39
11636: PUSH
11637: LD_EXP 41
11641: PUSH
11642: LD_EXP 42
11646: PUSH
11647: LD_EXP 49
11651: PUSH
11652: LD_EXP 48
11656: PUSH
11657: LD_EXP 43
11661: PUSH
11662: EMPTY
11663: LIST
11664: LIST
11665: LIST
11666: LIST
11667: LIST
11668: LIST
11669: LIST
11670: DIFF
11671: ST_TO_ADDR
// DialogueOn ;
11672: CALL_OW 6
// PlaceSeeing ( 255 , 219 , 7 , - 20 ) ;
11676: LD_INT 255
11678: PPUSH
11679: LD_INT 219
11681: PPUSH
11682: LD_INT 7
11684: PPUSH
11685: LD_INT 20
11687: NEG
11688: PPUSH
11689: CALL_OW 330
// CenterNowOnXY ( 255 , 219 ) ;
11693: LD_INT 255
11695: PPUSH
11696: LD_INT 219
11698: PPUSH
11699: CALL_OW 86
// if speaker then
11703: LD_VAR 0 1
11707: IFFALSE 11725
// Say ( speaker [ 1 ] , DAlienBase-RSol1-1 ) ;
11709: LD_VAR 0 1
11713: PUSH
11714: LD_INT 1
11716: ARRAY
11717: PPUSH
11718: LD_STRING DAlienBase-RSol1-1
11720: PPUSH
11721: CALL_OW 88
// Say ( JMM , DAlienBase-JMM-1 ) ;
11725: LD_EXP 19
11729: PPUSH
11730: LD_STRING DAlienBase-JMM-1
11732: PPUSH
11733: CALL_OW 88
// if IsOk ( Burlak ) then
11737: LD_EXP 51
11741: PPUSH
11742: CALL_OW 302
11746: IFFALSE 11767
// begin dwait ( 0 0$1 ) ;
11748: LD_INT 35
11750: PPUSH
11751: CALL_OW 68
// Say ( Burlak , DAlienBase-Bur-1 ) ;
11755: LD_EXP 51
11759: PPUSH
11760: LD_STRING DAlienBase-Bur-1
11762: PPUSH
11763: CALL_OW 88
// end ; if IsOk ( Roth ) then
11767: LD_EXP 20
11771: PPUSH
11772: CALL_OW 302
11776: IFFALSE 11790
// Say ( Roth , DAlienBase-Roth-1 ) ;
11778: LD_EXP 20
11782: PPUSH
11783: LD_STRING DAlienBase-Roth-1
11785: PPUSH
11786: CALL_OW 88
// if IsOk ( Gossudarov ) then
11790: LD_EXP 37
11794: PPUSH
11795: CALL_OW 302
11799: IFFALSE 11815
// Say ( Gossudarov , DAlienBase-Gos-1 ) else
11801: LD_EXP 37
11805: PPUSH
11806: LD_STRING DAlienBase-Gos-1
11808: PPUSH
11809: CALL_OW 88
11813: GO 11932
// begin speaker := FilterAllUnits ( [ [ f_side , 7 ] , [ f_class , 4 ] , [ f_type , unit_human ] , [ f_sex , sex_male ] ] ) diff [ Roth , JMM , Burlak , Titov , Kuzmov , Kovalyuk ] ;
11815: LD_ADDR_VAR 0 1
11819: PUSH
11820: LD_INT 22
11822: PUSH
11823: LD_INT 7
11825: PUSH
11826: EMPTY
11827: LIST
11828: LIST
11829: PUSH
11830: LD_INT 25
11832: PUSH
11833: LD_INT 4
11835: PUSH
11836: EMPTY
11837: LIST
11838: LIST
11839: PUSH
11840: LD_INT 21
11842: PUSH
11843: LD_INT 1
11845: PUSH
11846: EMPTY
11847: LIST
11848: LIST
11849: PUSH
11850: LD_INT 26
11852: PUSH
11853: LD_INT 1
11855: PUSH
11856: EMPTY
11857: LIST
11858: LIST
11859: PUSH
11860: EMPTY
11861: LIST
11862: LIST
11863: LIST
11864: LIST
11865: PPUSH
11866: CALL_OW 69
11870: PUSH
11871: LD_EXP 20
11875: PUSH
11876: LD_EXP 19
11880: PUSH
11881: LD_EXP 51
11885: PUSH
11886: LD_EXP 39
11890: PUSH
11891: LD_EXP 49
11895: PUSH
11896: LD_EXP 48
11900: PUSH
11901: EMPTY
11902: LIST
11903: LIST
11904: LIST
11905: LIST
11906: LIST
11907: LIST
11908: DIFF
11909: ST_TO_ADDR
// if speaker then
11910: LD_VAR 0 1
11914: IFFALSE 11932
// Say ( speaker [ 1 ] , DAlienBase-Sci1-1 ) ;
11916: LD_VAR 0 1
11920: PUSH
11921: LD_INT 1
11923: ARRAY
11924: PPUSH
11925: LD_STRING DAlienBase-Sci1-1
11927: PPUSH
11928: CALL_OW 88
// end ; RemoveSeeing ( 255 , 219 , 7 ) ;
11932: LD_INT 255
11934: PPUSH
11935: LD_INT 219
11937: PPUSH
11938: LD_INT 7
11940: PPUSH
11941: CALL_OW 331
// DialogueOff ;
11945: CALL_OW 7
// repeat wait ( 0 0$1 ) ;
11949: LD_INT 35
11951: PPUSH
11952: CALL_OW 67
// until IsSelected ( alien ) ;
11956: LD_INT 1
11958: PPUSH
11959: CALL_OW 306
11963: IFFALSE 11949
// if not artifactIResearched or not artifactIIResearched then
11965: LD_EXP 12
11969: NOT
11970: PUSH
11971: LD_EXP 13
11975: NOT
11976: OR
11977: IFFALSE 12157
// begin if IsOk ( Roth ) then
11979: LD_EXP 20
11983: PPUSH
11984: CALL_OW 302
11988: IFFALSE 12004
// Say ( Roth , DAlieBaseNotReady-Roth-1 ) else
11990: LD_EXP 20
11994: PPUSH
11995: LD_STRING DAlieBaseNotReady-Roth-1
11997: PPUSH
11998: CALL_OW 88
12002: GO 12157
// if IsOk ( Gossudarov ) then
12004: LD_EXP 37
12008: PPUSH
12009: CALL_OW 302
12013: IFFALSE 12029
// Say ( Gossudarov , DAlieBaseNotReady-Gos-1 ) else
12015: LD_EXP 37
12019: PPUSH
12020: LD_STRING DAlieBaseNotReady-Gos-1
12022: PPUSH
12023: CALL_OW 88
12027: GO 12157
// begin speaker := FilterAllUnits ( [ [ f_side , 7 ] , [ f_nation , 3 ] , [ f_class , 4 ] , [ f_type , unit_human ] , [ f_sex , sex_male ] ] ) diff [ Roth , JMM , Burlak , Titov , Kuzmov , Kovalyuk ] ;
12029: LD_ADDR_VAR 0 1
12033: PUSH
12034: LD_INT 22
12036: PUSH
12037: LD_INT 7
12039: PUSH
12040: EMPTY
12041: LIST
12042: LIST
12043: PUSH
12044: LD_INT 23
12046: PUSH
12047: LD_INT 3
12049: PUSH
12050: EMPTY
12051: LIST
12052: LIST
12053: PUSH
12054: LD_INT 25
12056: PUSH
12057: LD_INT 4
12059: PUSH
12060: EMPTY
12061: LIST
12062: LIST
12063: PUSH
12064: LD_INT 21
12066: PUSH
12067: LD_INT 1
12069: PUSH
12070: EMPTY
12071: LIST
12072: LIST
12073: PUSH
12074: LD_INT 26
12076: PUSH
12077: LD_INT 1
12079: PUSH
12080: EMPTY
12081: LIST
12082: LIST
12083: PUSH
12084: EMPTY
12085: LIST
12086: LIST
12087: LIST
12088: LIST
12089: LIST
12090: PPUSH
12091: CALL_OW 69
12095: PUSH
12096: LD_EXP 20
12100: PUSH
12101: LD_EXP 19
12105: PUSH
12106: LD_EXP 51
12110: PUSH
12111: LD_EXP 39
12115: PUSH
12116: LD_EXP 49
12120: PUSH
12121: LD_EXP 48
12125: PUSH
12126: EMPTY
12127: LIST
12128: LIST
12129: LIST
12130: LIST
12131: LIST
12132: LIST
12133: DIFF
12134: ST_TO_ADDR
// if speaker then
12135: LD_VAR 0 1
12139: IFFALSE 12157
// Say ( speaker [ 1 ] , DAlieBaseNotReady-RSci1-1 ) ;
12141: LD_VAR 0 1
12145: PUSH
12146: LD_INT 1
12148: ARRAY
12149: PPUSH
12150: LD_STRING DAlieBaseNotReady-RSci1-1
12152: PPUSH
12153: CALL_OW 88
// end ; end ; end ;
12157: PPOPN 1
12159: END
// every 0 0$1 trigger GetTech ( tech_Artifact , 7 ) = state_researched do var speaker ;
12160: LD_INT 24
12162: PPUSH
12163: LD_INT 7
12165: PPUSH
12166: CALL_OW 321
12170: PUSH
12171: LD_INT 2
12173: EQUAL
12174: IFFALSE 12865
12176: GO 12178
12178: DISABLE
12179: LD_INT 0
12181: PPUSH
// begin speaker := FilterAllUnits ( [ [ f_side , 7 ] , [ f_nation , 3 ] , [ f_class , 4 ] , [ f_type , unit_human ] , [ f_sex , sex_male ] ] ) diff [ Roth , JMM , Burlak , Titov , Kuzmov , Kovalyuk ] ;
12182: LD_ADDR_VAR 0 1
12186: PUSH
12187: LD_INT 22
12189: PUSH
12190: LD_INT 7
12192: PUSH
12193: EMPTY
12194: LIST
12195: LIST
12196: PUSH
12197: LD_INT 23
12199: PUSH
12200: LD_INT 3
12202: PUSH
12203: EMPTY
12204: LIST
12205: LIST
12206: PUSH
12207: LD_INT 25
12209: PUSH
12210: LD_INT 4
12212: PUSH
12213: EMPTY
12214: LIST
12215: LIST
12216: PUSH
12217: LD_INT 21
12219: PUSH
12220: LD_INT 1
12222: PUSH
12223: EMPTY
12224: LIST
12225: LIST
12226: PUSH
12227: LD_INT 26
12229: PUSH
12230: LD_INT 1
12232: PUSH
12233: EMPTY
12234: LIST
12235: LIST
12236: PUSH
12237: EMPTY
12238: LIST
12239: LIST
12240: LIST
12241: LIST
12242: LIST
12243: PPUSH
12244: CALL_OW 69
12248: PUSH
12249: LD_EXP 20
12253: PUSH
12254: LD_EXP 19
12258: PUSH
12259: LD_EXP 51
12263: PUSH
12264: LD_EXP 39
12268: PUSH
12269: LD_EXP 49
12273: PUSH
12274: LD_EXP 48
12278: PUSH
12279: EMPTY
12280: LIST
12281: LIST
12282: LIST
12283: LIST
12284: LIST
12285: LIST
12286: DIFF
12287: ST_TO_ADDR
// if not speaker then
12288: LD_VAR 0 1
12292: NOT
12293: IFFALSE 12297
// exit ;
12295: GO 12865
// DialogueOn ;
12297: CALL_OW 6
// Say ( speaker [ 1 ] , DArtefTechnology-RSci1-1 ) ;
12301: LD_VAR 0 1
12305: PUSH
12306: LD_INT 1
12308: ARRAY
12309: PPUSH
12310: LD_STRING DArtefTechnology-RSci1-1
12312: PPUSH
12313: CALL_OW 88
// if IsOk ( Burlak ) then
12317: LD_EXP 51
12321: PPUSH
12322: CALL_OW 302
12326: IFFALSE 12340
// Say ( Burlak , DArtefTechnology-Bur-1 ) ;
12328: LD_EXP 51
12332: PPUSH
12333: LD_STRING DArtefTechnology-Bur-1
12335: PPUSH
12336: CALL_OW 88
// Say ( speaker [ 1 ] , DArtefTechnology-RSci1-2 ) ;
12340: LD_VAR 0 1
12344: PUSH
12345: LD_INT 1
12347: ARRAY
12348: PPUSH
12349: LD_STRING DArtefTechnology-RSci1-2
12351: PPUSH
12352: CALL_OW 88
// if Denis then
12356: LD_EXP 25
12360: IFFALSE 12377
// speaker := [ Denis ] else
12362: LD_ADDR_VAR 0 1
12366: PUSH
12367: LD_EXP 25
12371: PUSH
12372: EMPTY
12373: LIST
12374: ST_TO_ADDR
12375: GO 12483
// speaker := FilterAllUnits ( [ [ f_side , 7 ] , [ f_nation , 1 ] , [ f_class , 4 ] , [ f_type , unit_human ] , [ f_sex , sex_male ] ] ) diff [ Roth , JMM , Burlak , Titov , Kuzmov , Kovalyuk ] ;
12377: LD_ADDR_VAR 0 1
12381: PUSH
12382: LD_INT 22
12384: PUSH
12385: LD_INT 7
12387: PUSH
12388: EMPTY
12389: LIST
12390: LIST
12391: PUSH
12392: LD_INT 23
12394: PUSH
12395: LD_INT 1
12397: PUSH
12398: EMPTY
12399: LIST
12400: LIST
12401: PUSH
12402: LD_INT 25
12404: PUSH
12405: LD_INT 4
12407: PUSH
12408: EMPTY
12409: LIST
12410: LIST
12411: PUSH
12412: LD_INT 21
12414: PUSH
12415: LD_INT 1
12417: PUSH
12418: EMPTY
12419: LIST
12420: LIST
12421: PUSH
12422: LD_INT 26
12424: PUSH
12425: LD_INT 1
12427: PUSH
12428: EMPTY
12429: LIST
12430: LIST
12431: PUSH
12432: EMPTY
12433: LIST
12434: LIST
12435: LIST
12436: LIST
12437: LIST
12438: PPUSH
12439: CALL_OW 69
12443: PUSH
12444: LD_EXP 20
12448: PUSH
12449: LD_EXP 19
12453: PUSH
12454: LD_EXP 51
12458: PUSH
12459: LD_EXP 39
12463: PUSH
12464: LD_EXP 49
12468: PUSH
12469: LD_EXP 48
12473: PUSH
12474: EMPTY
12475: LIST
12476: LIST
12477: LIST
12478: LIST
12479: LIST
12480: LIST
12481: DIFF
12482: ST_TO_ADDR
// if speaker then
12483: LD_VAR 0 1
12487: IFFALSE 12505
// Say ( speaker [ 1 ] , DArtefTechnology-Sci1-2 ) ;
12489: LD_VAR 0 1
12493: PUSH
12494: LD_INT 1
12496: ARRAY
12497: PPUSH
12498: LD_STRING DArtefTechnology-Sci1-2
12500: PPUSH
12501: CALL_OW 88
// speaker := FilterAllUnits ( [ [ f_side , 7 ] , [ f_nation , 3 ] , [ f_class , 4 ] , [ f_type , unit_human ] , [ f_sex , sex_male ] ] ) diff [ Roth , JMM , Burlak , Titov , Kuzmov , Kovalyuk ] ;
12505: LD_ADDR_VAR 0 1
12509: PUSH
12510: LD_INT 22
12512: PUSH
12513: LD_INT 7
12515: PUSH
12516: EMPTY
12517: LIST
12518: LIST
12519: PUSH
12520: LD_INT 23
12522: PUSH
12523: LD_INT 3
12525: PUSH
12526: EMPTY
12527: LIST
12528: LIST
12529: PUSH
12530: LD_INT 25
12532: PUSH
12533: LD_INT 4
12535: PUSH
12536: EMPTY
12537: LIST
12538: LIST
12539: PUSH
12540: LD_INT 21
12542: PUSH
12543: LD_INT 1
12545: PUSH
12546: EMPTY
12547: LIST
12548: LIST
12549: PUSH
12550: LD_INT 26
12552: PUSH
12553: LD_INT 1
12555: PUSH
12556: EMPTY
12557: LIST
12558: LIST
12559: PUSH
12560: EMPTY
12561: LIST
12562: LIST
12563: LIST
12564: LIST
12565: LIST
12566: PPUSH
12567: CALL_OW 69
12571: PUSH
12572: LD_EXP 20
12576: PUSH
12577: LD_EXP 19
12581: PUSH
12582: LD_EXP 51
12586: PUSH
12587: LD_EXP 39
12591: PUSH
12592: LD_EXP 49
12596: PUSH
12597: LD_EXP 48
12601: PUSH
12602: EMPTY
12603: LIST
12604: LIST
12605: LIST
12606: LIST
12607: LIST
12608: LIST
12609: DIFF
12610: ST_TO_ADDR
// if speaker and ( artifactArCaptured or arabianDestroyed ) then
12611: LD_VAR 0 1
12615: PUSH
12616: LD_EXP 9
12620: PUSH
12621: LD_EXP 5
12625: OR
12626: AND
12627: IFFALSE 12861
// begin if arabianDestroyed and IsOk ( Burlak ) then
12629: LD_EXP 5
12633: PUSH
12634: LD_EXP 51
12638: PPUSH
12639: CALL_OW 302
12643: AND
12644: IFFALSE 12660
// Say ( Burlak , DArtefTechnology-Bur-2 ) else
12646: LD_EXP 51
12650: PPUSH
12651: LD_STRING DArtefTechnology-Bur-2
12653: PPUSH
12654: CALL_OW 88
12658: GO 12672
// Say ( JMM , DArtefTechnology-JMM-2 ) ;
12660: LD_EXP 19
12664: PPUSH
12665: LD_STRING DArtefTechnology-JMM-2
12667: PPUSH
12668: CALL_OW 88
// Say ( speaker [ 1 ] , DArtefTechnology-RSci1-3 ) ;
12672: LD_VAR 0 1
12676: PUSH
12677: LD_INT 1
12679: ARRAY
12680: PPUSH
12681: LD_STRING DArtefTechnology-RSci1-3
12683: PPUSH
12684: CALL_OW 88
// if Denis then
12688: LD_EXP 25
12692: IFFALSE 12709
// speaker := [ Denis ] else
12694: LD_ADDR_VAR 0 1
12698: PUSH
12699: LD_EXP 25
12703: PUSH
12704: EMPTY
12705: LIST
12706: ST_TO_ADDR
12707: GO 12815
// speaker := FilterAllUnits ( [ [ f_side , 7 ] , [ f_nation , 1 ] , [ f_class , 4 ] , [ f_type , unit_human ] , [ f_sex , sex_male ] ] ) diff [ Roth , JMM , Burlak , Titov , Kuzmov , Kovalyuk ] ;
12709: LD_ADDR_VAR 0 1
12713: PUSH
12714: LD_INT 22
12716: PUSH
12717: LD_INT 7
12719: PUSH
12720: EMPTY
12721: LIST
12722: LIST
12723: PUSH
12724: LD_INT 23
12726: PUSH
12727: LD_INT 1
12729: PUSH
12730: EMPTY
12731: LIST
12732: LIST
12733: PUSH
12734: LD_INT 25
12736: PUSH
12737: LD_INT 4
12739: PUSH
12740: EMPTY
12741: LIST
12742: LIST
12743: PUSH
12744: LD_INT 21
12746: PUSH
12747: LD_INT 1
12749: PUSH
12750: EMPTY
12751: LIST
12752: LIST
12753: PUSH
12754: LD_INT 26
12756: PUSH
12757: LD_INT 1
12759: PUSH
12760: EMPTY
12761: LIST
12762: LIST
12763: PUSH
12764: EMPTY
12765: LIST
12766: LIST
12767: LIST
12768: LIST
12769: LIST
12770: PPUSH
12771: CALL_OW 69
12775: PUSH
12776: LD_EXP 20
12780: PUSH
12781: LD_EXP 19
12785: PUSH
12786: LD_EXP 51
12790: PUSH
12791: LD_EXP 39
12795: PUSH
12796: LD_EXP 49
12800: PUSH
12801: LD_EXP 48
12805: PUSH
12806: EMPTY
12807: LIST
12808: LIST
12809: LIST
12810: LIST
12811: LIST
12812: LIST
12813: DIFF
12814: ST_TO_ADDR
// if speaker then
12815: LD_VAR 0 1
12819: IFFALSE 12861
// if alienSpotted then
12821: LD_EXP 10
12825: IFFALSE 12845
// Say ( speaker [ 1 ] , DArtefTechnology-Sci1-3 ) else
12827: LD_VAR 0 1
12831: PUSH
12832: LD_INT 1
12834: ARRAY
12835: PPUSH
12836: LD_STRING DArtefTechnology-Sci1-3
12838: PPUSH
12839: CALL_OW 88
12843: GO 12861
// Say ( speaker [ 1 ] , DArtefTechnology-Sci1-3a ) ;
12845: LD_VAR 0 1
12849: PUSH
12850: LD_INT 1
12852: ARRAY
12853: PPUSH
12854: LD_STRING DArtefTechnology-Sci1-3a
12856: PPUSH
12857: CALL_OW 88
// end ; DialogueOff ;
12861: CALL_OW 7
// end ;
12865: PPOPN 1
12867: END
// every 0 0$1 trigger artifactIResearched do var speaker ;
12868: LD_EXP 12
12872: IFFALSE 13075
12874: GO 12876
12876: DISABLE
12877: LD_INT 0
12879: PPUSH
// begin if Denis then
12880: LD_EXP 25
12884: IFFALSE 12901
// speaker := [ Denis ] else
12886: LD_ADDR_VAR 0 1
12890: PUSH
12891: LD_EXP 25
12895: PUSH
12896: EMPTY
12897: LIST
12898: ST_TO_ADDR
12899: GO 13007
// speaker := FilterAllUnits ( [ [ f_side , 7 ] , [ f_nation , 1 ] , [ f_class , 4 ] , [ f_type , unit_human ] , [ f_sex , sex_male ] ] ) diff [ Roth , JMM , Burlak , Titov , Kuzmov , Kovalyuk ] ;
12901: LD_ADDR_VAR 0 1
12905: PUSH
12906: LD_INT 22
12908: PUSH
12909: LD_INT 7
12911: PUSH
12912: EMPTY
12913: LIST
12914: LIST
12915: PUSH
12916: LD_INT 23
12918: PUSH
12919: LD_INT 1
12921: PUSH
12922: EMPTY
12923: LIST
12924: LIST
12925: PUSH
12926: LD_INT 25
12928: PUSH
12929: LD_INT 4
12931: PUSH
12932: EMPTY
12933: LIST
12934: LIST
12935: PUSH
12936: LD_INT 21
12938: PUSH
12939: LD_INT 1
12941: PUSH
12942: EMPTY
12943: LIST
12944: LIST
12945: PUSH
12946: LD_INT 26
12948: PUSH
12949: LD_INT 1
12951: PUSH
12952: EMPTY
12953: LIST
12954: LIST
12955: PUSH
12956: EMPTY
12957: LIST
12958: LIST
12959: LIST
12960: LIST
12961: LIST
12962: PPUSH
12963: CALL_OW 69
12967: PUSH
12968: LD_EXP 20
12972: PUSH
12973: LD_EXP 19
12977: PUSH
12978: LD_EXP 51
12982: PUSH
12983: LD_EXP 39
12987: PUSH
12988: LD_EXP 49
12992: PUSH
12993: LD_EXP 48
12997: PUSH
12998: EMPTY
12999: LIST
13000: LIST
13001: LIST
13002: LIST
13003: LIST
13004: LIST
13005: DIFF
13006: ST_TO_ADDR
// if not speaker then
13007: LD_VAR 0 1
13011: NOT
13012: IFFALSE 13016
// exit ;
13014: GO 13075
// DialogueOn ;
13016: CALL_OW 6
// Say ( speaker [ 1 ] , DArtefTechnologyAm-Sci1-1 ) ;
13020: LD_VAR 0 1
13024: PUSH
13025: LD_INT 1
13027: ARRAY
13028: PPUSH
13029: LD_STRING DArtefTechnologyAm-Sci1-1
13031: PPUSH
13032: CALL_OW 88
// if IsOk ( Burlak ) then
13036: LD_EXP 51
13040: PPUSH
13041: CALL_OW 302
13045: IFFALSE 13059
// Say ( Burlak , DArtefTechnologyAm-Bur-1 ) ;
13047: LD_EXP 51
13051: PPUSH
13052: LD_STRING DArtefTechnologyAm-Bur-1
13054: PPUSH
13055: CALL_OW 88
// Say ( JMM , DArtefTechnologyAm-JMM-1 ) ;
13059: LD_EXP 19
13063: PPUSH
13064: LD_STRING DArtefTechnologyAm-JMM-1
13066: PPUSH
13067: CALL_OW 88
// DialogueOff ;
13071: CALL_OW 7
// end ;
13075: PPOPN 1
13077: END
// every 0 0$1 trigger artifactIIResearched do var speaker ;
13078: LD_EXP 13
13082: IFFALSE 13284
13084: GO 13086
13086: DISABLE
13087: LD_INT 0
13089: PPUSH
// begin speaker := FilterAllUnits ( [ [ f_side , 7 ] , [ f_nation , 3 ] , [ f_class , 4 ] , [ f_type , unit_human ] , [ f_sex , sex_male ] ] ) diff [ Roth , JMM , Burlak , Titov , Kuzmov , Kovalyuk ] ;
13090: LD_ADDR_VAR 0 1
13094: PUSH
13095: LD_INT 22
13097: PUSH
13098: LD_INT 7
13100: PUSH
13101: EMPTY
13102: LIST
13103: LIST
13104: PUSH
13105: LD_INT 23
13107: PUSH
13108: LD_INT 3
13110: PUSH
13111: EMPTY
13112: LIST
13113: LIST
13114: PUSH
13115: LD_INT 25
13117: PUSH
13118: LD_INT 4
13120: PUSH
13121: EMPTY
13122: LIST
13123: LIST
13124: PUSH
13125: LD_INT 21
13127: PUSH
13128: LD_INT 1
13130: PUSH
13131: EMPTY
13132: LIST
13133: LIST
13134: PUSH
13135: LD_INT 26
13137: PUSH
13138: LD_INT 1
13140: PUSH
13141: EMPTY
13142: LIST
13143: LIST
13144: PUSH
13145: EMPTY
13146: LIST
13147: LIST
13148: LIST
13149: LIST
13150: LIST
13151: PPUSH
13152: CALL_OW 69
13156: PUSH
13157: LD_EXP 20
13161: PUSH
13162: LD_EXP 19
13166: PUSH
13167: LD_EXP 51
13171: PUSH
13172: LD_EXP 39
13176: PUSH
13177: LD_EXP 49
13181: PUSH
13182: LD_EXP 48
13186: PUSH
13187: EMPTY
13188: LIST
13189: LIST
13190: LIST
13191: LIST
13192: LIST
13193: LIST
13194: DIFF
13195: ST_TO_ADDR
// if not speaker then
13196: LD_VAR 0 1
13200: NOT
13201: IFFALSE 13205
// exit ;
13203: GO 13284
// DialogueOn ;
13205: CALL_OW 6
// Say ( speaker [ speaker ] , DArtefTechnologyRu-RSci1-1 ) ;
13209: LD_VAR 0 1
13213: PUSH
13214: LD_VAR 0 1
13218: ARRAY
13219: PPUSH
13220: LD_STRING DArtefTechnologyRu-RSci1-1
13222: PPUSH
13223: CALL_OW 88
// if IsOk ( Burlak ) then
13227: LD_EXP 51
13231: PPUSH
13232: CALL_OW 302
13236: IFFALSE 13250
// Say ( Burlak , DArtefTechnologyRu-Bur-1 ) ;
13238: LD_EXP 51
13242: PPUSH
13243: LD_STRING DArtefTechnologyRu-Bur-1
13245: PPUSH
13246: CALL_OW 88
// Say ( speaker [ speaker ] , DArtefTechnologyRu-RSci1-2 ) ;
13250: LD_VAR 0 1
13254: PUSH
13255: LD_VAR 0 1
13259: ARRAY
13260: PPUSH
13261: LD_STRING DArtefTechnologyRu-RSci1-2
13263: PPUSH
13264: CALL_OW 88
// Say ( JMM , DArtefTechnologyRu-JMM-1 ) ;
13268: LD_EXP 19
13272: PPUSH
13273: LD_STRING DArtefTechnologyRu-JMM-1
13275: PPUSH
13276: CALL_OW 88
// DialogueOff ;
13280: CALL_OW 7
// end ;
13284: PPOPN 1
13286: END
// every 0 0$1 trigger GetTech ( tech_Artifact , 7 ) = state_researched and GetSide ( alien ) = 7 do var speaker ;
13287: LD_INT 24
13289: PPUSH
13290: LD_INT 7
13292: PPUSH
13293: CALL_OW 321
13297: PUSH
13298: LD_INT 2
13300: EQUAL
13301: PUSH
13302: LD_INT 1
13304: PPUSH
13305: CALL_OW 255
13309: PUSH
13310: LD_INT 7
13312: EQUAL
13313: AND
13314: IFFALSE 13482
13316: GO 13318
13318: DISABLE
13319: LD_INT 0
13321: PPUSH
// begin if Denis then
13322: LD_EXP 25
13326: IFFALSE 13343
// speaker := [ Denis ] else
13328: LD_ADDR_VAR 0 1
13332: PUSH
13333: LD_EXP 25
13337: PUSH
13338: EMPTY
13339: LIST
13340: ST_TO_ADDR
13341: GO 13449
// speaker := FilterAllUnits ( [ [ f_side , 7 ] , [ f_nation , 1 ] , [ f_class , 4 ] , [ f_type , unit_human ] , [ f_sex , sex_male ] ] ) diff [ Roth , JMM , Burlak , Titov , Kuzmov , Kovalyuk ] ;
13343: LD_ADDR_VAR 0 1
13347: PUSH
13348: LD_INT 22
13350: PUSH
13351: LD_INT 7
13353: PUSH
13354: EMPTY
13355: LIST
13356: LIST
13357: PUSH
13358: LD_INT 23
13360: PUSH
13361: LD_INT 1
13363: PUSH
13364: EMPTY
13365: LIST
13366: LIST
13367: PUSH
13368: LD_INT 25
13370: PUSH
13371: LD_INT 4
13373: PUSH
13374: EMPTY
13375: LIST
13376: LIST
13377: PUSH
13378: LD_INT 21
13380: PUSH
13381: LD_INT 1
13383: PUSH
13384: EMPTY
13385: LIST
13386: LIST
13387: PUSH
13388: LD_INT 26
13390: PUSH
13391: LD_INT 1
13393: PUSH
13394: EMPTY
13395: LIST
13396: LIST
13397: PUSH
13398: EMPTY
13399: LIST
13400: LIST
13401: LIST
13402: LIST
13403: LIST
13404: PPUSH
13405: CALL_OW 69
13409: PUSH
13410: LD_EXP 20
13414: PUSH
13415: LD_EXP 19
13419: PUSH
13420: LD_EXP 51
13424: PUSH
13425: LD_EXP 39
13429: PUSH
13430: LD_EXP 49
13434: PUSH
13435: LD_EXP 48
13439: PUSH
13440: EMPTY
13441: LIST
13442: LIST
13443: LIST
13444: LIST
13445: LIST
13446: LIST
13447: DIFF
13448: ST_TO_ADDR
// if not speaker then
13449: LD_VAR 0 1
13453: NOT
13454: IFFALSE 13458
// exit ;
13456: GO 13482
// DialogueOn ;
13458: CALL_OW 6
// Say ( speaker [ 1 ] , DArtefTechnologyArStart-Sci1-1 ) ;
13462: LD_VAR 0 1
13466: PUSH
13467: LD_INT 1
13469: ARRAY
13470: PPUSH
13471: LD_STRING DArtefTechnologyArStart-Sci1-1
13473: PPUSH
13474: CALL_OW 88
// DialogueOff ;
13478: CALL_OW 7
// end ;
13482: PPOPN 1
13484: END
// every 0 0$1 trigger artifactIIIResearched do var speaker ;
13485: LD_EXP 14
13489: IFFALSE 13770
13491: GO 13493
13493: DISABLE
13494: LD_INT 0
13496: PPUSH
// begin speaker := FilterAllUnits ( [ [ f_side , 7 ] , [ f_nation , 3 ] , [ f_class , 4 ] , [ f_type , unit_human ] , [ f_sex , sex_male ] ] ) diff [ Roth , JMM , Burlak , Titov , Kuzmov , Kovalyuk ] ;
13497: LD_ADDR_VAR 0 1
13501: PUSH
13502: LD_INT 22
13504: PUSH
13505: LD_INT 7
13507: PUSH
13508: EMPTY
13509: LIST
13510: LIST
13511: PUSH
13512: LD_INT 23
13514: PUSH
13515: LD_INT 3
13517: PUSH
13518: EMPTY
13519: LIST
13520: LIST
13521: PUSH
13522: LD_INT 25
13524: PUSH
13525: LD_INT 4
13527: PUSH
13528: EMPTY
13529: LIST
13530: LIST
13531: PUSH
13532: LD_INT 21
13534: PUSH
13535: LD_INT 1
13537: PUSH
13538: EMPTY
13539: LIST
13540: LIST
13541: PUSH
13542: LD_INT 26
13544: PUSH
13545: LD_INT 1
13547: PUSH
13548: EMPTY
13549: LIST
13550: LIST
13551: PUSH
13552: EMPTY
13553: LIST
13554: LIST
13555: LIST
13556: LIST
13557: LIST
13558: PPUSH
13559: CALL_OW 69
13563: PUSH
13564: LD_EXP 20
13568: PUSH
13569: LD_EXP 19
13573: PUSH
13574: LD_EXP 51
13578: PUSH
13579: LD_EXP 39
13583: PUSH
13584: LD_EXP 49
13588: PUSH
13589: LD_EXP 48
13593: PUSH
13594: EMPTY
13595: LIST
13596: LIST
13597: LIST
13598: LIST
13599: LIST
13600: LIST
13601: DIFF
13602: ST_TO_ADDR
// if not speaker then
13603: LD_VAR 0 1
13607: NOT
13608: IFFALSE 13612
// exit ;
13610: GO 13770
// DialogueOn ;
13612: CALL_OW 6
// Say ( speaker [ 1 ] , DArtefTechnologyAr-RSci1-1 ) ;
13616: LD_VAR 0 1
13620: PUSH
13621: LD_INT 1
13623: ARRAY
13624: PPUSH
13625: LD_STRING DArtefTechnologyAr-RSci1-1
13627: PPUSH
13628: CALL_OW 88
// Say ( JMM , DArtefTechnologyAr-JMM-1 ) ;
13632: LD_EXP 19
13636: PPUSH
13637: LD_STRING DArtefTechnologyAr-JMM-1
13639: PPUSH
13640: CALL_OW 88
// Say ( speaker [ 1 ] , DArtefTechnologyAr-RSci1-2 ) ;
13644: LD_VAR 0 1
13648: PUSH
13649: LD_INT 1
13651: ARRAY
13652: PPUSH
13653: LD_STRING DArtefTechnologyAr-RSci1-2
13655: PPUSH
13656: CALL_OW 88
// Say ( JMM , DArtefTechnologyAr-JMM-2 ) ;
13660: LD_EXP 19
13664: PPUSH
13665: LD_STRING DArtefTechnologyAr-JMM-2
13667: PPUSH
13668: CALL_OW 88
// Say ( speaker [ 1 ] , DArtefTechnologyAr-RSci1-3 ) ;
13672: LD_VAR 0 1
13676: PUSH
13677: LD_INT 1
13679: ARRAY
13680: PPUSH
13681: LD_STRING DArtefTechnologyAr-RSci1-3
13683: PPUSH
13684: CALL_OW 88
// Say ( JMM , DArtefTechnologyAr-JMM-3 ) ;
13688: LD_EXP 19
13692: PPUSH
13693: LD_STRING DArtefTechnologyAr-JMM-3
13695: PPUSH
13696: CALL_OW 88
// Say ( speaker [ 1 ] , DArtefTechnologyAr-RSci1-4 ) ;
13700: LD_VAR 0 1
13704: PUSH
13705: LD_INT 1
13707: ARRAY
13708: PPUSH
13709: LD_STRING DArtefTechnologyAr-RSci1-4
13711: PPUSH
13712: CALL_OW 88
// if IsOk ( Burlak ) then
13716: LD_EXP 51
13720: PPUSH
13721: CALL_OW 302
13725: IFFALSE 13739
// Say ( Burlak , DArtefTechnologyAr-Bur-4 ) ;
13727: LD_EXP 51
13731: PPUSH
13732: LD_STRING DArtefTechnologyAr-Bur-4
13734: PPUSH
13735: CALL_OW 88
// Say ( JMM , DArtefTechnologyAr-JMM-4 ) ;
13739: LD_EXP 19
13743: PPUSH
13744: LD_STRING DArtefTechnologyAr-JMM-4
13746: PPUSH
13747: CALL_OW 88
// DialogueOff ;
13751: CALL_OW 7
// wait ( 0 0$45 ) ;
13755: LD_INT 1575
13757: PPUSH
13758: CALL_OW 67
// spawnOmar := true ;
13762: LD_ADDR_EXP 11
13766: PUSH
13767: LD_INT 1
13769: ST_TO_ADDR
// end ;
13770: PPOPN 1
13772: END
// every 0 0$1 trigger spawnOmar do
13773: LD_EXP 11
13777: IFFALSE 14157
13779: GO 13781
13781: DISABLE
// begin PrepareOmarAli ;
13782: CALL 7201 0 0
// if not HasTask ( Omar ) then
13786: LD_EXP 55
13790: PPUSH
13791: CALL_OW 314
13795: NOT
13796: IFFALSE 13813
// ComMoveXY ( Omar , 252 , 220 ) ;
13798: LD_EXP 55
13802: PPUSH
13803: LD_INT 252
13805: PPUSH
13806: LD_INT 220
13808: PPUSH
13809: CALL_OW 111
// if not Omar then
13813: LD_EXP 55
13817: NOT
13818: IFFALSE 13822
// exit ;
13820: GO 14157
// repeat wait ( 0 0$1 ) ;
13822: LD_INT 35
13824: PPUSH
13825: CALL_OW 67
// if not HasTask ( Omar ) and GetDistUnitXY ( Omar , 252 , 220 ) > 6 then
13829: LD_EXP 55
13833: PPUSH
13834: CALL_OW 314
13838: NOT
13839: PUSH
13840: LD_EXP 55
13844: PPUSH
13845: LD_INT 252
13847: PPUSH
13848: LD_INT 220
13850: PPUSH
13851: CALL_OW 297
13855: PUSH
13856: LD_INT 6
13858: GREATER
13859: AND
13860: IFFALSE 13877
// ComMoveXY ( Omar , 252 , 220 ) ;
13862: LD_EXP 55
13866: PPUSH
13867: LD_INT 252
13869: PPUSH
13870: LD_INT 220
13872: PPUSH
13873: CALL_OW 111
// until See ( 7 , Omar ) ;
13877: LD_INT 7
13879: PPUSH
13880: LD_EXP 55
13884: PPUSH
13885: CALL_OW 292
13889: IFFALSE 13822
// CenterNowOnUnits ( Omar ) ;
13891: LD_EXP 55
13895: PPUSH
13896: CALL_OW 87
// DialogueOn ;
13900: CALL_OW 6
// Say ( Omar , DOmar-Omar-1 ) ;
13904: LD_EXP 55
13908: PPUSH
13909: LD_STRING DOmar-Omar-1
13911: PPUSH
13912: CALL_OW 88
// Say ( JMM , DOmar-JMM-1 ) ;
13916: LD_EXP 19
13920: PPUSH
13921: LD_STRING DOmar-JMM-1
13923: PPUSH
13924: CALL_OW 88
// Say ( Omar , DOmar-Omar-2 ) ;
13928: LD_EXP 55
13932: PPUSH
13933: LD_STRING DOmar-Omar-2
13935: PPUSH
13936: CALL_OW 88
// Say ( JMM , DOmar-JMM-2 ) ;
13940: LD_EXP 19
13944: PPUSH
13945: LD_STRING DOmar-JMM-2
13947: PPUSH
13948: CALL_OW 88
// Say ( Omar , DOmar-Omar-3 ) ;
13952: LD_EXP 55
13956: PPUSH
13957: LD_STRING DOmar-Omar-3
13959: PPUSH
13960: CALL_OW 88
// if IsOk ( Burlak ) then
13964: LD_EXP 51
13968: PPUSH
13969: CALL_OW 302
13973: IFFALSE 13989
// Say ( Burlak , DOmar-Bur-3 ) else
13975: LD_EXP 51
13979: PPUSH
13980: LD_STRING DOmar-Bur-3
13982: PPUSH
13983: CALL_OW 88
13987: GO 14001
// Say ( JMM , DOmar-JMM-3 ) ;
13989: LD_EXP 19
13993: PPUSH
13994: LD_STRING DOmar-JMM-3
13996: PPUSH
13997: CALL_OW 88
// Say ( Omar , DOmar-Omar-4 ) ;
14001: LD_EXP 55
14005: PPUSH
14006: LD_STRING DOmar-Omar-4
14008: PPUSH
14009: CALL_OW 88
// case Query ( QAccept ) of 1 :
14013: LD_STRING QAccept
14015: PPUSH
14016: CALL_OW 97
14020: PUSH
14021: LD_INT 1
14023: DOUBLE
14024: EQUAL
14025: IFTRUE 14029
14027: GO 14065
14029: POP
// begin Say ( JMM , DQrAccept#1-JMM-1 ) ;
14030: LD_EXP 19
14034: PPUSH
14035: LD_STRING DQrAccept#1-JMM-1
14037: PPUSH
14038: CALL_OW 88
// SetSide ( Omar , 7 ) ;
14042: LD_EXP 55
14046: PPUSH
14047: LD_INT 7
14049: PPUSH
14050: CALL_OW 235
// ComStop ( Omar ) ;
14054: LD_EXP 55
14058: PPUSH
14059: CALL_OW 141
// end ; 2 :
14063: GO 14114
14065: LD_INT 2
14067: DOUBLE
14068: EQUAL
14069: IFTRUE 14073
14071: GO 14113
14073: POP
// begin if IsOk ( Burlak ) then
14074: LD_EXP 51
14078: PPUSH
14079: CALL_OW 302
14083: IFFALSE 14099
// Say ( Burlak , DQrAccept#2-Bur-1 ) else
14085: LD_EXP 51
14089: PPUSH
14090: LD_STRING DQrAccept#2-Bur-1
14092: PPUSH
14093: CALL_OW 88
14097: GO 14111
// Say ( JMM , DQrAccept#2-JMM-1 ) ;
14099: LD_EXP 19
14103: PPUSH
14104: LD_STRING DQrAccept#2-JMM-1
14106: PPUSH
14107: CALL_OW 88
// end ; end ;
14111: GO 14114
14113: POP
// DialogueOff ;
14114: CALL_OW 7
// if GetSide ( Omar ) = 7 then
14118: LD_EXP 55
14122: PPUSH
14123: CALL_OW 255
14127: PUSH
14128: LD_INT 7
14130: EQUAL
14131: IFFALSE 14142
// begin SetAchievement ( ACH_OMAR ) ;
14133: LD_STRING ACH_OMAR
14135: PPUSH
14136: CALL_OW 543
// exit ;
14140: GO 14157
// end ; ComMoveXY ( Omar , 202 , 115 ) ;
14142: LD_EXP 55
14146: PPUSH
14147: LD_INT 202
14149: PPUSH
14150: LD_INT 115
14152: PPUSH
14153: CALL_OW 111
// end ;
14157: END
// every 0 0$1 trigger GetDistUnitXY ( Omar , 200 , 98 ) < 40 and russianDestroyed do
14158: LD_EXP 55
14162: PPUSH
14163: LD_INT 200
14165: PPUSH
14166: LD_INT 98
14168: PPUSH
14169: CALL_OW 297
14173: PUSH
14174: LD_INT 40
14176: LESS
14177: PUSH
14178: LD_EXP 2
14182: AND
14183: IFFALSE 14401
14185: GO 14187
14187: DISABLE
// begin SetSide ( Omar , 5 ) ;
14188: LD_EXP 55
14192: PPUSH
14193: LD_INT 5
14195: PPUSH
14196: CALL_OW 235
// if IsInUnit ( Omar ) then
14200: LD_EXP 55
14204: PPUSH
14205: CALL_OW 310
14209: IFFALSE 14220
// ComExitVehicle ( Omar ) ;
14211: LD_EXP 55
14215: PPUSH
14216: CALL_OW 121
// if IsInUnit ( Omar ) then
14220: LD_EXP 55
14224: PPUSH
14225: CALL_OW 310
14229: IFFALSE 14240
// ComExitBuilding ( Omar ) ;
14231: LD_EXP 55
14235: PPUSH
14236: CALL_OW 122
// wait ( 0 0$1 ) ;
14240: LD_INT 35
14242: PPUSH
14243: CALL_OW 67
// ComMoveXY ( Omar , 203 , 120 ) ;
14247: LD_EXP 55
14251: PPUSH
14252: LD_INT 203
14254: PPUSH
14255: LD_INT 120
14257: PPUSH
14258: CALL_OW 111
// repeat wait ( 0 0$1 ) ;
14262: LD_INT 35
14264: PPUSH
14265: CALL_OW 67
// until IsSelected ( Omar ) or GetDistUnitXY ( Omar , 203 , 120 ) < 6 ;
14269: LD_EXP 55
14273: PPUSH
14274: CALL_OW 306
14278: PUSH
14279: LD_EXP 55
14283: PPUSH
14284: LD_INT 203
14286: PPUSH
14287: LD_INT 120
14289: PPUSH
14290: CALL_OW 297
14294: PUSH
14295: LD_INT 6
14297: LESS
14298: OR
14299: IFFALSE 14262
// CenterNowOnUnits ( Omar ) ;
14301: LD_EXP 55
14305: PPUSH
14306: CALL_OW 87
// DialogueOn ;
14310: CALL_OW 6
// Say ( JMM , DOmarContam-JMM-1 ) ;
14314: LD_EXP 19
14318: PPUSH
14319: LD_STRING DOmarContam-JMM-1
14321: PPUSH
14322: CALL_OW 88
// Say ( Omar , DOmarContam-Omar-1 ) ;
14326: LD_EXP 55
14330: PPUSH
14331: LD_STRING DOmarContam-Omar-1
14333: PPUSH
14334: CALL_OW 88
// Say ( JMM , DOmarContam-JMM-2 ) ;
14338: LD_EXP 19
14342: PPUSH
14343: LD_STRING DOmarContam-JMM-2
14345: PPUSH
14346: CALL_OW 88
// DialogueOff ;
14350: CALL_OW 7
// SetAttitude ( 5 , 7 , att_enemy , true ) ;
14354: LD_INT 5
14356: PPUSH
14357: LD_INT 7
14359: PPUSH
14360: LD_INT 2
14362: PPUSH
14363: LD_INT 1
14365: PPUSH
14366: CALL_OW 80
// repeat wait ( 0 0$3 ) ;
14370: LD_INT 105
14372: PPUSH
14373: CALL_OW 67
// until IsAt ( Omar , 203 , 120 ) ;
14377: LD_EXP 55
14381: PPUSH
14382: LD_INT 203
14384: PPUSH
14385: LD_INT 120
14387: PPUSH
14388: CALL_OW 307
14392: IFFALSE 14370
// YouLost ( MothContaminate ) ;
14394: LD_STRING MothContaminate
14396: PPUSH
14397: CALL_OW 104
// end ;
14401: END
// every 0 0$2 trigger not americanDestroyed and FilterAllUnits ( [ [ f_side , 1 ] , [ f_weapon , us_siberium_rocket ] ] ) do
14402: LD_EXP 4
14406: NOT
14407: PUSH
14408: LD_INT 22
14410: PUSH
14411: LD_INT 1
14413: PUSH
14414: EMPTY
14415: LIST
14416: LIST
14417: PUSH
14418: LD_INT 34
14420: PUSH
14421: LD_INT 8
14423: PUSH
14424: EMPTY
14425: LIST
14426: LIST
14427: PUSH
14428: EMPTY
14429: LIST
14430: LIST
14431: PPUSH
14432: CALL_OW 69
14436: AND
14437: IFFALSE 14556
14439: GO 14441
14441: DISABLE
// begin wait ( 0 0$5 ) ;
14442: LD_INT 175
14444: PPUSH
14445: CALL_OW 67
// if not IsOk ( Powell ) or not FilterAllUnits ( [ [ f_side , 1 ] , [ f_weapon , us_siberium_rocket ] ] ) then
14449: LD_EXP 54
14453: PPUSH
14454: CALL_OW 302
14458: NOT
14459: PUSH
14460: LD_INT 22
14462: PUSH
14463: LD_INT 1
14465: PUSH
14466: EMPTY
14467: LIST
14468: LIST
14469: PUSH
14470: LD_INT 34
14472: PUSH
14473: LD_INT 8
14475: PUSH
14476: EMPTY
14477: LIST
14478: LIST
14479: PUSH
14480: EMPTY
14481: LIST
14482: LIST
14483: PPUSH
14484: CALL_OW 69
14488: NOT
14489: OR
14490: IFFALSE 14494
// exit ;
14492: GO 14556
// DialogueOn ;
14494: CALL_OW 6
// SayRadio ( Powell , DWinAmericans-Pow-1 ) ;
14498: LD_EXP 54
14502: PPUSH
14503: LD_STRING DWinAmericans-Pow-1
14505: PPUSH
14506: CALL_OW 94
// if IsOk ( Burlak ) then
14510: LD_EXP 51
14514: PPUSH
14515: CALL_OW 302
14519: IFFALSE 14533
// Say ( Burlak , DWinAmericans-Bur-1 ) ;
14521: LD_EXP 51
14525: PPUSH
14526: LD_STRING DWinAmericans-Bur-1
14528: PPUSH
14529: CALL_OW 88
// Say ( JMM , DWinAmericans-JMM-1 ) ;
14533: LD_EXP 19
14537: PPUSH
14538: LD_STRING DWinAmericans-JMM-1
14540: PPUSH
14541: CALL_OW 88
// DialogueOff ;
14545: CALL_OW 7
// YouLost ( AmBomb ) ;
14549: LD_STRING AmBomb
14551: PPUSH
14552: CALL_OW 104
// end ;
14556: END
// every 0 0$2 trigger not russianDestroyed and FilterAllUnits ( [ [ f_side , 3 ] , [ f_weapon , ru_siberium_rocket ] ] ) do
14557: LD_EXP 2
14561: NOT
14562: PUSH
14563: LD_INT 22
14565: PUSH
14566: LD_INT 3
14568: PUSH
14569: EMPTY
14570: LIST
14571: LIST
14572: PUSH
14573: LD_INT 34
14575: PUSH
14576: LD_INT 48
14578: PUSH
14579: EMPTY
14580: LIST
14581: LIST
14582: PUSH
14583: EMPTY
14584: LIST
14585: LIST
14586: PPUSH
14587: CALL_OW 69
14591: AND
14592: IFFALSE 14711
14594: GO 14596
14596: DISABLE
// begin wait ( 0 0$5 ) ;
14597: LD_INT 175
14599: PPUSH
14600: CALL_OW 67
// if not IsOk ( Platonov ) or not FilterAllUnits ( [ [ f_side , 3 ] , [ f_weapon , ru_siberium_rocket ] ] ) then
14604: LD_EXP 58
14608: PPUSH
14609: CALL_OW 302
14613: NOT
14614: PUSH
14615: LD_INT 22
14617: PUSH
14618: LD_INT 3
14620: PUSH
14621: EMPTY
14622: LIST
14623: LIST
14624: PUSH
14625: LD_INT 34
14627: PUSH
14628: LD_INT 48
14630: PUSH
14631: EMPTY
14632: LIST
14633: LIST
14634: PUSH
14635: EMPTY
14636: LIST
14637: LIST
14638: PPUSH
14639: CALL_OW 69
14643: NOT
14644: OR
14645: IFFALSE 14649
// exit ;
14647: GO 14711
// DialogueOn ;
14649: CALL_OW 6
// SayRadio ( Platonov , DWinRussians-Pla-1 ) ;
14653: LD_EXP 58
14657: PPUSH
14658: LD_STRING DWinRussians-Pla-1
14660: PPUSH
14661: CALL_OW 94
// if IsOk ( Burlak ) then
14665: LD_EXP 51
14669: PPUSH
14670: CALL_OW 302
14674: IFFALSE 14688
// Say ( Burlak , DWinRussians-Bur-1 ) ;
14676: LD_EXP 51
14680: PPUSH
14681: LD_STRING DWinRussians-Bur-1
14683: PPUSH
14684: CALL_OW 88
// Say ( JMM , DWinRussians-JMM-1 ) ;
14688: LD_EXP 19
14692: PPUSH
14693: LD_STRING DWinRussians-JMM-1
14695: PPUSH
14696: CALL_OW 88
// DialogueOff ;
14700: CALL_OW 7
// YouLost ( RuBomb ) ;
14704: LD_STRING RuBomb
14706: PPUSH
14707: CALL_OW 104
// end ;
14711: END
// every 0 0$20 trigger FilterUnitsInArea ( powellBase , [ f_side , 7 ] ) and not americanDestroyed do
14712: LD_INT 7
14714: PPUSH
14715: LD_INT 22
14717: PUSH
14718: LD_INT 7
14720: PUSH
14721: EMPTY
14722: LIST
14723: LIST
14724: PPUSH
14725: CALL_OW 70
14729: PUSH
14730: LD_EXP 4
14734: NOT
14735: AND
14736: IFFALSE 14765
14738: GO 14740
14740: DISABLE
// begin SayRadio ( Powell , DSurrenderAmericans-Pow-1 ) ;
14741: LD_EXP 54
14745: PPUSH
14746: LD_STRING DSurrenderAmericans-Pow-1
14748: PPUSH
14749: CALL_OW 94
// Say ( JMM , DSurrenderAmericans-JMM-1 ) ;
14753: LD_EXP 19
14757: PPUSH
14758: LD_STRING DSurrenderAmericans-JMM-1
14760: PPUSH
14761: CALL_OW 88
// end ;
14765: END
// every 0 0$20 trigger FilterUnitsInArea ( russianBaseArea , [ f_side , 7 ] ) and not russianDestroyed and Burlak do
14766: LD_INT 2
14768: PPUSH
14769: LD_INT 22
14771: PUSH
14772: LD_INT 7
14774: PUSH
14775: EMPTY
14776: LIST
14777: LIST
14778: PPUSH
14779: CALL_OW 70
14783: PUSH
14784: LD_EXP 2
14788: NOT
14789: AND
14790: PUSH
14791: LD_EXP 51
14795: AND
14796: IFFALSE 14825
14798: GO 14800
14800: DISABLE
// begin SayRadio ( Platonov , DSurrenderRussians-Pla-1 ) ;
14801: LD_EXP 58
14805: PPUSH
14806: LD_STRING DSurrenderRussians-Pla-1
14808: PPUSH
14809: CALL_OW 94
// Say ( Burlak , DSurrenderRussians-Bur-1 ) ;
14813: LD_EXP 51
14817: PPUSH
14818: LD_STRING DSurrenderRussians-Bur-1
14820: PPUSH
14821: CALL_OW 88
// end ;
14825: END
// every 0 0$2 + 0 0$5 trigger americanDestroyed do var i , tmp , speaker ;
14826: LD_EXP 4
14830: IFFALSE 15213
14832: GO 14834
14834: DISABLE
14835: LD_INT 0
14837: PPUSH
14838: PPUSH
14839: PPUSH
// begin MC_Kill ( 4 ) ;
14840: LD_INT 4
14842: PPUSH
14843: CALL 21642 0 1
// SetAttitude ( 1 , 7 , att_friend , true ) ;
14847: LD_INT 1
14849: PPUSH
14850: LD_INT 7
14852: PPUSH
14853: LD_INT 1
14855: PPUSH
14856: LD_INT 1
14858: PPUSH
14859: CALL_OW 80
// speaker := FilterAllUnits ( [ [ f_side , 1 ] , [ f_sex , sex_male ] , [ f_nation , 1 ] ] ) diff [ Powell , Gladstone , Cyrus , Bobby , Gary , Houten ] ;
14863: LD_ADDR_VAR 0 3
14867: PUSH
14868: LD_INT 22
14870: PUSH
14871: LD_INT 1
14873: PUSH
14874: EMPTY
14875: LIST
14876: LIST
14877: PUSH
14878: LD_INT 26
14880: PUSH
14881: LD_INT 1
14883: PUSH
14884: EMPTY
14885: LIST
14886: LIST
14887: PUSH
14888: LD_INT 23
14890: PUSH
14891: LD_INT 1
14893: PUSH
14894: EMPTY
14895: LIST
14896: LIST
14897: PUSH
14898: EMPTY
14899: LIST
14900: LIST
14901: LIST
14902: PPUSH
14903: CALL_OW 69
14907: PUSH
14908: LD_EXP 54
14912: PUSH
14913: LD_EXP 27
14917: PUSH
14918: LD_EXP 24
14922: PUSH
14923: LD_EXP 23
14927: PUSH
14928: LD_EXP 30
14932: PUSH
14933: LD_EXP 28
14937: PUSH
14938: EMPTY
14939: LIST
14940: LIST
14941: LIST
14942: LIST
14943: LIST
14944: LIST
14945: DIFF
14946: ST_TO_ADDR
// if speaker then
14947: LD_VAR 0 3
14951: IFFALSE 14977
// begin DialogueOn ;
14953: CALL_OW 6
// SayRadio ( speaker [ 1 ] , DSurrenderAmericans-Sol1-1a ) ;
14957: LD_VAR 0 3
14961: PUSH
14962: LD_INT 1
14964: ARRAY
14965: PPUSH
14966: LD_STRING DSurrenderAmericans-Sol1-1a
14968: PPUSH
14969: CALL_OW 94
// DialogueOff ;
14973: CALL_OW 7
// end ; americanCapitulated := true ;
14977: LD_ADDR_EXP 6
14981: PUSH
14982: LD_INT 1
14984: ST_TO_ADDR
// tmp := FilterAllUnits ( [ [ f_side , 1 ] , [ f_type , unit_human ] ] ) ^ FilterAllUnits ( [ [ f_side , 1 ] , [ f_type , unit_vehicle ] , [ control_manual ] ] ) ;
14985: LD_ADDR_VAR 0 2
14989: PUSH
14990: LD_INT 22
14992: PUSH
14993: LD_INT 1
14995: PUSH
14996: EMPTY
14997: LIST
14998: LIST
14999: PUSH
15000: LD_INT 21
15002: PUSH
15003: LD_INT 1
15005: PUSH
15006: EMPTY
15007: LIST
15008: LIST
15009: PUSH
15010: EMPTY
15011: LIST
15012: LIST
15013: PPUSH
15014: CALL_OW 69
15018: PUSH
15019: LD_INT 22
15021: PUSH
15022: LD_INT 1
15024: PUSH
15025: EMPTY
15026: LIST
15027: LIST
15028: PUSH
15029: LD_INT 21
15031: PUSH
15032: LD_INT 2
15034: PUSH
15035: EMPTY
15036: LIST
15037: LIST
15038: PUSH
15039: LD_INT 1
15041: PUSH
15042: EMPTY
15043: LIST
15044: PUSH
15045: EMPTY
15046: LIST
15047: LIST
15048: LIST
15049: PPUSH
15050: CALL_OW 69
15054: ADD
15055: ST_TO_ADDR
// if tmp then
15056: LD_VAR 0 2
15060: IFFALSE 15213
// repeat wait ( 0 0$1 ) ;
15062: LD_INT 35
15064: PPUSH
15065: CALL_OW 67
// for i in tmp do
15069: LD_ADDR_VAR 0 1
15073: PUSH
15074: LD_VAR 0 2
15078: PUSH
15079: FOR_IN
15080: IFFALSE 15162
// begin if IsInUnit ( i ) and GetType ( IsInUnit ( i ) ) = unit_building then
15082: LD_VAR 0 1
15086: PPUSH
15087: CALL_OW 310
15091: PUSH
15092: LD_VAR 0 1
15096: PPUSH
15097: CALL_OW 310
15101: PPUSH
15102: CALL_OW 247
15106: PUSH
15107: LD_INT 3
15109: EQUAL
15110: AND
15111: IFFALSE 15122
// ComExitBuilding ( i ) ;
15113: LD_VAR 0 1
15117: PPUSH
15118: CALL_OW 122
// AddComMoveXY ( i , 122 , 242 ) ;
15122: LD_VAR 0 1
15126: PPUSH
15127: LD_INT 122
15129: PPUSH
15130: LD_INT 242
15132: PPUSH
15133: CALL_OW 171
// if IsInArea ( i , americanEscape ) then
15137: LD_VAR 0 1
15141: PPUSH
15142: LD_INT 35
15144: PPUSH
15145: CALL_OW 308
15149: IFFALSE 15160
// RemoveUnit ( i ) ;
15151: LD_VAR 0 1
15155: PPUSH
15156: CALL_OW 64
// end ;
15160: GO 15079
15162: POP
15163: POP
// until not FilterAllUnits ( [ [ f_side , 1 ] , [ f_or , [ f_type , unit_human ] , [ f_control , control_manual ] ] ] ) ;
15164: LD_INT 22
15166: PUSH
15167: LD_INT 1
15169: PUSH
15170: EMPTY
15171: LIST
15172: LIST
15173: PUSH
15174: LD_INT 2
15176: PUSH
15177: LD_INT 21
15179: PUSH
15180: LD_INT 1
15182: PUSH
15183: EMPTY
15184: LIST
15185: LIST
15186: PUSH
15187: LD_INT 33
15189: PUSH
15190: LD_INT 1
15192: PUSH
15193: EMPTY
15194: LIST
15195: LIST
15196: PUSH
15197: EMPTY
15198: LIST
15199: LIST
15200: LIST
15201: PUSH
15202: EMPTY
15203: LIST
15204: LIST
15205: PPUSH
15206: CALL_OW 69
15210: NOT
15211: IFFALSE 15062
// end ;
15213: PPOPN 3
15215: END
// every 0 0$2 + 0 0$5 trigger russianDestroyed do var i , tmp , speaker ;
15216: LD_EXP 2
15220: IFFALSE 15621
15222: GO 15224
15224: DISABLE
15225: LD_INT 0
15227: PPUSH
15228: PPUSH
15229: PPUSH
// begin repeat wait ( 0 0$1 ) ;
15230: LD_INT 35
15232: PPUSH
15233: CALL_OW 67
// until IsDead ( Yakotich ) ;
15237: LD_EXP 59
15241: PPUSH
15242: CALL_OW 301
15246: IFFALSE 15230
// MC_Kill ( 2 ) ;
15248: LD_INT 2
15250: PPUSH
15251: CALL 21642 0 1
// SetAttitude ( 3 , 7 , att_friend , true ) ;
15255: LD_INT 3
15257: PPUSH
15258: LD_INT 7
15260: PPUSH
15261: LD_INT 1
15263: PPUSH
15264: LD_INT 1
15266: PPUSH
15267: CALL_OW 80
// speaker := FilterAllUnits ( [ [ f_side , 3 ] , [ f_sex , sex_male ] , [ f_nation , 3 ] ] ) diff [ Platonov , Yakotich ] ;
15271: LD_ADDR_VAR 0 3
15275: PUSH
15276: LD_INT 22
15278: PUSH
15279: LD_INT 3
15281: PUSH
15282: EMPTY
15283: LIST
15284: LIST
15285: PUSH
15286: LD_INT 26
15288: PUSH
15289: LD_INT 1
15291: PUSH
15292: EMPTY
15293: LIST
15294: LIST
15295: PUSH
15296: LD_INT 23
15298: PUSH
15299: LD_INT 3
15301: PUSH
15302: EMPTY
15303: LIST
15304: LIST
15305: PUSH
15306: EMPTY
15307: LIST
15308: LIST
15309: LIST
15310: PPUSH
15311: CALL_OW 69
15315: PUSH
15316: LD_EXP 58
15320: PUSH
15321: LD_EXP 59
15325: PUSH
15326: EMPTY
15327: LIST
15328: LIST
15329: DIFF
15330: ST_TO_ADDR
// if speaker then
15331: LD_VAR 0 3
15335: IFFALSE 15385
// begin DialogueOn ;
15337: CALL_OW 6
// if Burlak then
15341: LD_EXP 51
15345: IFFALSE 15365
// SayRadio ( speaker [ 1 ] , DSurrenderRussians-RSol1-1 ) else
15347: LD_VAR 0 3
15351: PUSH
15352: LD_INT 1
15354: ARRAY
15355: PPUSH
15356: LD_STRING DSurrenderRussians-RSol1-1
15358: PPUSH
15359: CALL_OW 94
15363: GO 15381
// SayRadio ( speaker [ 1 ] , DSurrenderRussians-RSol1-1a ) ;
15365: LD_VAR 0 3
15369: PUSH
15370: LD_INT 1
15372: ARRAY
15373: PPUSH
15374: LD_STRING DSurrenderRussians-RSol1-1a
15376: PPUSH
15377: CALL_OW 94
// DialogueOff ;
15381: CALL_OW 7
// end ; russianCapitulated := true ;
15385: LD_ADDR_EXP 7
15389: PUSH
15390: LD_INT 1
15392: ST_TO_ADDR
// tmp := FilterAllUnits ( [ [ f_side , 3 ] , [ f_type , unit_human ] ] ) ^ FilterAllUnits ( [ [ f_side , 3 ] , [ f_type , unit_vehicle ] , [ control_manual ] ] ) ;
15393: LD_ADDR_VAR 0 2
15397: PUSH
15398: LD_INT 22
15400: PUSH
15401: LD_INT 3
15403: PUSH
15404: EMPTY
15405: LIST
15406: LIST
15407: PUSH
15408: LD_INT 21
15410: PUSH
15411: LD_INT 1
15413: PUSH
15414: EMPTY
15415: LIST
15416: LIST
15417: PUSH
15418: EMPTY
15419: LIST
15420: LIST
15421: PPUSH
15422: CALL_OW 69
15426: PUSH
15427: LD_INT 22
15429: PUSH
15430: LD_INT 3
15432: PUSH
15433: EMPTY
15434: LIST
15435: LIST
15436: PUSH
15437: LD_INT 21
15439: PUSH
15440: LD_INT 2
15442: PUSH
15443: EMPTY
15444: LIST
15445: LIST
15446: PUSH
15447: LD_INT 1
15449: PUSH
15450: EMPTY
15451: LIST
15452: PUSH
15453: EMPTY
15454: LIST
15455: LIST
15456: LIST
15457: PPUSH
15458: CALL_OW 69
15462: ADD
15463: ST_TO_ADDR
// if tmp then
15464: LD_VAR 0 2
15468: IFFALSE 15621
// repeat wait ( 0 0$1 ) ;
15470: LD_INT 35
15472: PPUSH
15473: CALL_OW 67
// for i in tmp do
15477: LD_ADDR_VAR 0 1
15481: PUSH
15482: LD_VAR 0 2
15486: PUSH
15487: FOR_IN
15488: IFFALSE 15570
// begin if IsInUnit ( i ) and GetType ( IsInUnit ( i ) ) = unit_building then
15490: LD_VAR 0 1
15494: PPUSH
15495: CALL_OW 310
15499: PUSH
15500: LD_VAR 0 1
15504: PPUSH
15505: CALL_OW 310
15509: PPUSH
15510: CALL_OW 247
15514: PUSH
15515: LD_INT 3
15517: EQUAL
15518: AND
15519: IFFALSE 15530
// ComExitBuilding ( i ) ;
15521: LD_VAR 0 1
15525: PPUSH
15526: CALL_OW 122
// AddComMoveXY ( i , 154 , 1 ) ;
15530: LD_VAR 0 1
15534: PPUSH
15535: LD_INT 154
15537: PPUSH
15538: LD_INT 1
15540: PPUSH
15541: CALL_OW 171
// if IsInArea ( i , russianEscape ) then
15545: LD_VAR 0 1
15549: PPUSH
15550: LD_INT 36
15552: PPUSH
15553: CALL_OW 308
15557: IFFALSE 15568
// RemoveUnit ( i ) ;
15559: LD_VAR 0 1
15563: PPUSH
15564: CALL_OW 64
// end ;
15568: GO 15487
15570: POP
15571: POP
// until not FilterAllUnits ( [ [ f_side , 3 ] , [ f_or , [ f_type , unit_human ] , [ f_control , control_manual ] ] ] ) ;
15572: LD_INT 22
15574: PUSH
15575: LD_INT 3
15577: PUSH
15578: EMPTY
15579: LIST
15580: LIST
15581: PUSH
15582: LD_INT 2
15584: PUSH
15585: LD_INT 21
15587: PUSH
15588: LD_INT 1
15590: PUSH
15591: EMPTY
15592: LIST
15593: LIST
15594: PUSH
15595: LD_INT 33
15597: PUSH
15598: LD_INT 1
15600: PUSH
15601: EMPTY
15602: LIST
15603: LIST
15604: PUSH
15605: EMPTY
15606: LIST
15607: LIST
15608: LIST
15609: PUSH
15610: EMPTY
15611: LIST
15612: LIST
15613: PPUSH
15614: CALL_OW 69
15618: NOT
15619: IFFALSE 15470
// end ;
15621: PPOPN 3
15623: END
// every 0 0$3 trigger FilterAllUnits ( [ [ f_side , 8 ] , [ f_type , unit_human ] , [ f_nation , 2 ] ] ) < 18 or IsDead ( Kozlov ) or GetSide ( ar_depot1 ) = 7 do
15624: LD_INT 22
15626: PUSH
15627: LD_INT 8
15629: PUSH
15630: EMPTY
15631: LIST
15632: LIST
15633: PUSH
15634: LD_INT 21
15636: PUSH
15637: LD_INT 1
15639: PUSH
15640: EMPTY
15641: LIST
15642: LIST
15643: PUSH
15644: LD_INT 23
15646: PUSH
15647: LD_INT 2
15649: PUSH
15650: EMPTY
15651: LIST
15652: LIST
15653: PUSH
15654: EMPTY
15655: LIST
15656: LIST
15657: LIST
15658: PPUSH
15659: CALL_OW 69
15663: PUSH
15664: LD_INT 18
15666: LESS
15667: PUSH
15668: LD_EXP 57
15672: PPUSH
15673: CALL_OW 301
15677: OR
15678: PUSH
15679: LD_INT 324
15681: PPUSH
15682: CALL_OW 255
15686: PUSH
15687: LD_INT 7
15689: EQUAL
15690: OR
15691: IFFALSE 15704
15693: GO 15695
15695: DISABLE
// legionDestroyed := true ;
15696: LD_ADDR_EXP 3
15700: PUSH
15701: LD_INT 1
15703: ST_TO_ADDR
15704: END
// every 0 0$3 trigger FilterAllUnits ( [ [ f_side , 2 ] , [ f_type , unit_human ] , [ f_nation , 2 ] ] ) < 9 do
15705: LD_INT 22
15707: PUSH
15708: LD_INT 2
15710: PUSH
15711: EMPTY
15712: LIST
15713: LIST
15714: PUSH
15715: LD_INT 21
15717: PUSH
15718: LD_INT 1
15720: PUSH
15721: EMPTY
15722: LIST
15723: LIST
15724: PUSH
15725: LD_INT 23
15727: PUSH
15728: LD_INT 2
15730: PUSH
15731: EMPTY
15732: LIST
15733: LIST
15734: PUSH
15735: EMPTY
15736: LIST
15737: LIST
15738: LIST
15739: PPUSH
15740: CALL_OW 69
15744: PUSH
15745: LD_INT 9
15747: LESS
15748: IFFALSE 15761
15750: GO 15752
15752: DISABLE
// arabianDestroyed := true ;
15753: LD_ADDR_EXP 5
15757: PUSH
15758: LD_INT 1
15760: ST_TO_ADDR
15761: END
// every 0 0$1 trigger arabianDestroyed do var i , tmp ;
15762: LD_EXP 5
15766: IFFALSE 16010
15768: GO 15770
15770: DISABLE
15771: LD_INT 0
15773: PPUSH
15774: PPUSH
// begin MC_Kill ( 1 ) ;
15775: LD_INT 1
15777: PPUSH
15778: CALL 21642 0 1
// tmp := FilterAllUnits ( [ [ f_side , 2 ] , [ f_type , unit_human ] ] ) ^ FilterAllUnits ( [ [ f_side , 8 ] , [ f_type , unit_vehicle ] , [ control_manual ] ] ) ;
15782: LD_ADDR_VAR 0 2
15786: PUSH
15787: LD_INT 22
15789: PUSH
15790: LD_INT 2
15792: PUSH
15793: EMPTY
15794: LIST
15795: LIST
15796: PUSH
15797: LD_INT 21
15799: PUSH
15800: LD_INT 1
15802: PUSH
15803: EMPTY
15804: LIST
15805: LIST
15806: PUSH
15807: EMPTY
15808: LIST
15809: LIST
15810: PPUSH
15811: CALL_OW 69
15815: PUSH
15816: LD_INT 22
15818: PUSH
15819: LD_INT 8
15821: PUSH
15822: EMPTY
15823: LIST
15824: LIST
15825: PUSH
15826: LD_INT 21
15828: PUSH
15829: LD_INT 2
15831: PUSH
15832: EMPTY
15833: LIST
15834: LIST
15835: PUSH
15836: LD_INT 1
15838: PUSH
15839: EMPTY
15840: LIST
15841: PUSH
15842: EMPTY
15843: LIST
15844: LIST
15845: LIST
15846: PPUSH
15847: CALL_OW 69
15851: ADD
15852: ST_TO_ADDR
// if tmp then
15853: LD_VAR 0 2
15857: IFFALSE 16010
// repeat wait ( 0 0$1 ) ;
15859: LD_INT 35
15861: PPUSH
15862: CALL_OW 67
// for i in tmp do
15866: LD_ADDR_VAR 0 1
15870: PUSH
15871: LD_VAR 0 2
15875: PUSH
15876: FOR_IN
15877: IFFALSE 15959
// begin if IsInUnit ( i ) and GetType ( IsInUnit ( i ) ) = unit_building then
15879: LD_VAR 0 1
15883: PPUSH
15884: CALL_OW 310
15888: PUSH
15889: LD_VAR 0 1
15893: PPUSH
15894: CALL_OW 310
15898: PPUSH
15899: CALL_OW 247
15903: PUSH
15904: LD_INT 3
15906: EQUAL
15907: AND
15908: IFFALSE 15919
// ComExitBuilding ( i ) ;
15910: LD_VAR 0 1
15914: PPUSH
15915: CALL_OW 122
// AddComMoveXY ( i , 254 , 268 ) ;
15919: LD_VAR 0 1
15923: PPUSH
15924: LD_INT 254
15926: PPUSH
15927: LD_INT 268
15929: PPUSH
15930: CALL_OW 171
// if IsInArea ( i , arabEscape ) then
15934: LD_VAR 0 1
15938: PPUSH
15939: LD_INT 34
15941: PPUSH
15942: CALL_OW 308
15946: IFFALSE 15957
// RemoveUnit ( i ) ;
15948: LD_VAR 0 1
15952: PPUSH
15953: CALL_OW 64
// end ;
15957: GO 15876
15959: POP
15960: POP
// until not FilterAllUnits ( [ [ f_side , 2 ] , [ f_or , [ f_type , unit_human ] , [ f_control , control_manual ] ] ] ) ;
15961: LD_INT 22
15963: PUSH
15964: LD_INT 2
15966: PUSH
15967: EMPTY
15968: LIST
15969: LIST
15970: PUSH
15971: LD_INT 2
15973: PUSH
15974: LD_INT 21
15976: PUSH
15977: LD_INT 1
15979: PUSH
15980: EMPTY
15981: LIST
15982: LIST
15983: PUSH
15984: LD_INT 33
15986: PUSH
15987: LD_INT 1
15989: PUSH
15990: EMPTY
15991: LIST
15992: LIST
15993: PUSH
15994: EMPTY
15995: LIST
15996: LIST
15997: LIST
15998: PUSH
15999: EMPTY
16000: LIST
16001: LIST
16002: PPUSH
16003: CALL_OW 69
16007: NOT
16008: IFFALSE 15859
// end ;
16010: PPOPN 2
16012: END
// every 0 0$1 trigger legionDestroyed do var i , tmp ;
16013: LD_EXP 3
16017: IFFALSE 16369
16019: GO 16021
16021: DISABLE
16022: LD_INT 0
16024: PPUSH
16025: PPUSH
// begin MC_Kill ( 3 ) ;
16026: LD_INT 3
16028: PPUSH
16029: CALL 21642 0 1
// SetAttitude ( 8 , 7 , att_friend , true ) ;
16033: LD_INT 8
16035: PPUSH
16036: LD_INT 7
16038: PPUSH
16039: LD_INT 1
16041: PPUSH
16042: LD_INT 1
16044: PPUSH
16045: CALL_OW 80
// DialogueOn ;
16049: CALL_OW 6
// SayRadio ( Schulz , D15-Szulc-1 ) ;
16053: LD_EXP 56
16057: PPUSH
16058: LD_STRING D15-Szulc-1
16060: PPUSH
16061: CALL_OW 94
// DialogueOff ;
16065: CALL_OW 7
// legionCapitulated := true ;
16069: LD_ADDR_EXP 8
16073: PUSH
16074: LD_INT 1
16076: ST_TO_ADDR
// for i in FilterAllUnits ( [ [ f_side , 8 ] , [ f_type , unit_building ] , [ f_nation , 3 ] ] ) do
16077: LD_ADDR_VAR 0 1
16081: PUSH
16082: LD_INT 22
16084: PUSH
16085: LD_INT 8
16087: PUSH
16088: EMPTY
16089: LIST
16090: LIST
16091: PUSH
16092: LD_INT 21
16094: PUSH
16095: LD_INT 3
16097: PUSH
16098: EMPTY
16099: LIST
16100: LIST
16101: PUSH
16102: LD_INT 23
16104: PUSH
16105: LD_INT 3
16107: PUSH
16108: EMPTY
16109: LIST
16110: LIST
16111: PUSH
16112: EMPTY
16113: LIST
16114: LIST
16115: LIST
16116: PPUSH
16117: CALL_OW 69
16121: PUSH
16122: FOR_IN
16123: IFFALSE 16139
// SetLives ( i , 3 ) ;
16125: LD_VAR 0 1
16129: PPUSH
16130: LD_INT 3
16132: PPUSH
16133: CALL_OW 234
16137: GO 16122
16139: POP
16140: POP
// tmp := FilterAllUnits ( [ [ f_side , 8 ] , [ f_type , unit_human ] ] ) ^ FilterAllUnits ( [ [ f_side , 8 ] , [ f_type , unit_vehicle ] , [ control_manual ] ] ) ;
16141: LD_ADDR_VAR 0 2
16145: PUSH
16146: LD_INT 22
16148: PUSH
16149: LD_INT 8
16151: PUSH
16152: EMPTY
16153: LIST
16154: LIST
16155: PUSH
16156: LD_INT 21
16158: PUSH
16159: LD_INT 1
16161: PUSH
16162: EMPTY
16163: LIST
16164: LIST
16165: PUSH
16166: EMPTY
16167: LIST
16168: LIST
16169: PPUSH
16170: CALL_OW 69
16174: PUSH
16175: LD_INT 22
16177: PUSH
16178: LD_INT 8
16180: PUSH
16181: EMPTY
16182: LIST
16183: LIST
16184: PUSH
16185: LD_INT 21
16187: PUSH
16188: LD_INT 2
16190: PUSH
16191: EMPTY
16192: LIST
16193: LIST
16194: PUSH
16195: LD_INT 1
16197: PUSH
16198: EMPTY
16199: LIST
16200: PUSH
16201: EMPTY
16202: LIST
16203: LIST
16204: LIST
16205: PPUSH
16206: CALL_OW 69
16210: ADD
16211: ST_TO_ADDR
// if tmp then
16212: LD_VAR 0 2
16216: IFFALSE 16369
// repeat wait ( 0 0$1 ) ;
16218: LD_INT 35
16220: PPUSH
16221: CALL_OW 67
// for i in tmp do
16225: LD_ADDR_VAR 0 1
16229: PUSH
16230: LD_VAR 0 2
16234: PUSH
16235: FOR_IN
16236: IFFALSE 16318
// begin if IsInUnit ( i ) and GetType ( IsInUnit ( i ) ) = unit_building then
16238: LD_VAR 0 1
16242: PPUSH
16243: CALL_OW 310
16247: PUSH
16248: LD_VAR 0 1
16252: PPUSH
16253: CALL_OW 310
16257: PPUSH
16258: CALL_OW 247
16262: PUSH
16263: LD_INT 3
16265: EQUAL
16266: AND
16267: IFFALSE 16278
// ComExitBuilding ( i ) ;
16269: LD_VAR 0 1
16273: PPUSH
16274: CALL_OW 122
// AddComMoveXY ( i , 10 , 1 ) ;
16278: LD_VAR 0 1
16282: PPUSH
16283: LD_INT 10
16285: PPUSH
16286: LD_INT 1
16288: PPUSH
16289: CALL_OW 171
// if IsInArea ( i , legionEscape ) then
16293: LD_VAR 0 1
16297: PPUSH
16298: LD_INT 32
16300: PPUSH
16301: CALL_OW 308
16305: IFFALSE 16316
// RemoveUnit ( i ) ;
16307: LD_VAR 0 1
16311: PPUSH
16312: CALL_OW 64
// end ;
16316: GO 16235
16318: POP
16319: POP
// until not FilterAllUnits ( [ [ f_side , 8 ] , [ f_or , [ f_type , unit_human ] , [ f_control , control_manual ] ] ] ) ;
16320: LD_INT 22
16322: PUSH
16323: LD_INT 8
16325: PUSH
16326: EMPTY
16327: LIST
16328: LIST
16329: PUSH
16330: LD_INT 2
16332: PUSH
16333: LD_INT 21
16335: PUSH
16336: LD_INT 1
16338: PUSH
16339: EMPTY
16340: LIST
16341: LIST
16342: PUSH
16343: LD_INT 33
16345: PUSH
16346: LD_INT 1
16348: PUSH
16349: EMPTY
16350: LIST
16351: LIST
16352: PUSH
16353: EMPTY
16354: LIST
16355: LIST
16356: LIST
16357: PUSH
16358: EMPTY
16359: LIST
16360: LIST
16361: PPUSH
16362: CALL_OW 69
16366: NOT
16367: IFFALSE 16218
// end ;
16369: PPOPN 2
16371: END
// every 0 0$10 trigger legionDestroyed and americanDestroyed and arabianAttacked and not arabianDestroyed and tick >= 30 30$00 do
16372: LD_EXP 3
16376: PUSH
16377: LD_EXP 4
16381: AND
16382: PUSH
16383: LD_EXP 18
16387: AND
16388: PUSH
16389: LD_EXP 5
16393: NOT
16394: AND
16395: PUSH
16396: LD_OWVAR 1
16400: PUSH
16401: LD_INT 63000
16403: GREATEREQUAL
16404: AND
16405: IFFALSE 16414
16407: GO 16409
16409: DISABLE
// AllianceSupport ;
16410: CALL 4642 0 0
16414: END
// every 0 0$5 trigger americanDestroyed and russianDestroyed and legionDestroyed and arabianDestroyed and americanCapitulated and russianCapitulated and legionCapitulated and ( GetSide ( Omar ) <> 5 or IsDead ( Omar ) or not IsPlaced ( Omar ) ) do var med1 , med2 ;
16415: LD_EXP 4
16419: PUSH
16420: LD_EXP 2
16424: AND
16425: PUSH
16426: LD_EXP 3
16430: AND
16431: PUSH
16432: LD_EXP 5
16436: AND
16437: PUSH
16438: LD_EXP 6
16442: AND
16443: PUSH
16444: LD_EXP 7
16448: AND
16449: PUSH
16450: LD_EXP 8
16454: AND
16455: PUSH
16456: LD_EXP 55
16460: PPUSH
16461: CALL_OW 255
16465: PUSH
16466: LD_INT 5
16468: NONEQUAL
16469: PUSH
16470: LD_EXP 55
16474: PPUSH
16475: CALL_OW 301
16479: OR
16480: PUSH
16481: LD_EXP 55
16485: PPUSH
16486: CALL_OW 305
16490: NOT
16491: OR
16492: AND
16493: IFFALSE 17895
16495: GO 16497
16497: DISABLE
16498: LD_INT 0
16500: PPUSH
16501: PPUSH
// begin wait ( 0 0$5 ) ;
16502: LD_INT 175
16504: PPUSH
16505: CALL_OW 67
// music_class := 5 ;
16509: LD_ADDR_OWVAR 72
16513: PUSH
16514: LD_INT 5
16516: ST_TO_ADDR
// music_nat := 5 ;
16517: LD_ADDR_OWVAR 71
16521: PUSH
16522: LD_INT 5
16524: ST_TO_ADDR
// if vehicleLostCounter < 3 then
16525: LD_EXP 15
16529: PUSH
16530: LD_INT 3
16532: LESS
16533: IFFALSE 16542
// SetAchievement ( ACH_ECONOMY ) ;
16535: LD_STRING ACH_ECONOMY
16537: PPUSH
16538: CALL_OW 543
// if tick < 60 60$00 then
16542: LD_OWVAR 1
16546: PUSH
16547: LD_INT 126000
16549: LESS
16550: IFFALSE 16566
// begin wait ( 3 ) ;
16552: LD_INT 3
16554: PPUSH
16555: CALL_OW 67
// SetAchievement ( ACH_ASPEED_19 ) ;
16559: LD_STRING ACH_ASPEED_19
16561: PPUSH
16562: CALL_OW 543
// end ; CenterNowOnUnits ( JMM ) ;
16566: LD_EXP 19
16570: PPUSH
16571: CALL_OW 87
// InGameOn ;
16575: CALL_OW 8
// DialogueOn ;
16579: CALL_OW 6
// Say ( JMM , DEnd-JMM-JMM-1 ) ;
16583: LD_EXP 19
16587: PPUSH
16588: LD_STRING DEnd-JMM-JMM-1
16590: PPUSH
16591: CALL_OW 88
// if Joan then
16595: LD_EXP 34
16599: IFFALSE 16615
// Say ( Joan , DEnd-JMM-Joan-1 ) else
16601: LD_EXP 34
16605: PPUSH
16606: LD_STRING DEnd-JMM-Joan-1
16608: PPUSH
16609: CALL_OW 88
16613: GO 16659
// if Lisa and GetSide ( Lisa ) = 7 and IsPlaced ( Lisa ) then
16615: LD_EXP 21
16619: PUSH
16620: LD_EXP 21
16624: PPUSH
16625: CALL_OW 255
16629: PUSH
16630: LD_INT 7
16632: EQUAL
16633: AND
16634: PUSH
16635: LD_EXP 21
16639: PPUSH
16640: CALL_OW 305
16644: AND
16645: IFFALSE 16659
// Say ( Lisa , DEnd-JMM-Lisa-1 ) ;
16647: LD_EXP 21
16651: PPUSH
16652: LD_STRING DEnd-JMM-Lisa-1
16654: PPUSH
16655: CALL_OW 88
// if Frank and IsPlaced ( Frank ) then
16659: LD_EXP 31
16663: PUSH
16664: LD_EXP 31
16668: PPUSH
16669: CALL_OW 305
16673: AND
16674: IFFALSE 16688
// Say ( Frank , DEnd-JMM-Frank-1 ) ;
16676: LD_EXP 31
16680: PPUSH
16681: LD_STRING DEnd-JMM-Frank-1
16683: PPUSH
16684: CALL_OW 88
// if Cyrus and GetSide ( Cyrus ) = 7 and IsPlaced ( Cyrus ) then
16688: LD_EXP 24
16692: PUSH
16693: LD_EXP 24
16697: PPUSH
16698: CALL_OW 255
16702: PUSH
16703: LD_INT 7
16705: EQUAL
16706: AND
16707: PUSH
16708: LD_EXP 24
16712: PPUSH
16713: CALL_OW 305
16717: AND
16718: IFFALSE 16732
// Say ( Cyrus , DEnd-JMM-Cyrus-1 ) ;
16720: LD_EXP 24
16724: PPUSH
16725: LD_STRING DEnd-JMM-Cyrus-1
16727: PPUSH
16728: CALL_OW 88
// if Burlak then
16732: LD_EXP 51
16736: IFFALSE 16750
// Say ( Burlak , DEnd-JMM-Bur-1 ) ;
16738: LD_EXP 51
16742: PPUSH
16743: LD_STRING DEnd-JMM-Bur-1
16745: PPUSH
16746: CALL_OW 88
// if Joan and Lisa and GetSide ( Lisa ) = 7 and IsPlaced ( Lisa ) and IsOk ( Burlak ) then
16750: LD_EXP 34
16754: PUSH
16755: LD_EXP 21
16759: AND
16760: PUSH
16761: LD_EXP 21
16765: PPUSH
16766: CALL_OW 255
16770: PUSH
16771: LD_INT 7
16773: EQUAL
16774: AND
16775: PUSH
16776: LD_EXP 21
16780: PPUSH
16781: CALL_OW 305
16785: AND
16786: PUSH
16787: LD_EXP 51
16791: PPUSH
16792: CALL_OW 302
16796: AND
16797: IFFALSE 16811
// Say ( Lisa , DEnd-Burlak-Lisa-1 ) ;
16799: LD_EXP 21
16803: PPUSH
16804: LD_STRING DEnd-Burlak-Lisa-1
16806: PPUSH
16807: CALL_OW 88
// if Belkov and IsPlaced ( Belkov ) then
16811: LD_EXP 52
16815: PUSH
16816: LD_EXP 52
16820: PPUSH
16821: CALL_OW 305
16825: AND
16826: IFFALSE 16840
// Say ( Belkov , DEnd-JMM-Bel-1 ) ;
16828: LD_EXP 52
16832: PPUSH
16833: LD_STRING DEnd-JMM-Bel-1
16835: PPUSH
16836: CALL_OW 88
// if Gnyevko and IsPlaced ( Gnyevko ) then
16840: LD_EXP 53
16844: PUSH
16845: LD_EXP 53
16849: PPUSH
16850: CALL_OW 305
16854: AND
16855: IFFALSE 16869
// Say ( Gnyevko , DEnd-JMM-Gny-1 ) ;
16857: LD_EXP 53
16861: PPUSH
16862: LD_STRING DEnd-JMM-Gny-1
16864: PPUSH
16865: CALL_OW 88
// if Cornel and GetSide ( Cornel ) = 7 and IsPlaced ( Cornel ) then
16869: LD_EXP 29
16873: PUSH
16874: LD_EXP 29
16878: PPUSH
16879: CALL_OW 255
16883: PUSH
16884: LD_INT 7
16886: EQUAL
16887: AND
16888: PUSH
16889: LD_EXP 29
16893: PPUSH
16894: CALL_OW 305
16898: AND
16899: IFFALSE 16913
// Say ( Cornel , DEnd-JMM-Corn-1 ) ;
16901: LD_EXP 29
16905: PPUSH
16906: LD_STRING DEnd-JMM-Corn-1
16908: PPUSH
16909: CALL_OW 88
// if Donaldson and GetSide ( Donaldson ) = 7 and IsPlaced ( Donaldson ) then
16913: LD_EXP 22
16917: PUSH
16918: LD_EXP 22
16922: PPUSH
16923: CALL_OW 255
16927: PUSH
16928: LD_INT 7
16930: EQUAL
16931: AND
16932: PUSH
16933: LD_EXP 22
16937: PPUSH
16938: CALL_OW 305
16942: AND
16943: IFFALSE 16957
// Say ( Donaldson , DEnd-JMM-Don-1 ) ;
16945: LD_EXP 22
16949: PPUSH
16950: LD_STRING DEnd-JMM-Don-1
16952: PPUSH
16953: CALL_OW 88
// if Bobby and GetSide ( Bobby ) = 7 and IsPlaced ( Bobby ) then
16957: LD_EXP 23
16961: PUSH
16962: LD_EXP 23
16966: PPUSH
16967: CALL_OW 255
16971: PUSH
16972: LD_INT 7
16974: EQUAL
16975: AND
16976: PUSH
16977: LD_EXP 23
16981: PPUSH
16982: CALL_OW 305
16986: AND
16987: IFFALSE 17001
// Say ( Bobby , DEnd-JMM-Bobby-1 ) ;
16989: LD_EXP 23
16993: PPUSH
16994: LD_STRING DEnd-JMM-Bobby-1
16996: PPUSH
16997: CALL_OW 88
// if Denis and GetSide ( Denis ) = 7 and IsPlaced ( Denis ) then
17001: LD_EXP 25
17005: PUSH
17006: LD_EXP 25
17010: PPUSH
17011: CALL_OW 255
17015: PUSH
17016: LD_INT 7
17018: EQUAL
17019: AND
17020: PUSH
17021: LD_EXP 25
17025: PPUSH
17026: CALL_OW 305
17030: AND
17031: IFFALSE 17045
// Say ( Denis , DEnd-JMM-Den-1 ) ;
17033: LD_EXP 25
17037: PPUSH
17038: LD_STRING DEnd-JMM-Den-1
17040: PPUSH
17041: CALL_OW 88
// if Gladstone and GetSide ( Gladstone ) = 7 and IsPlaced ( Gladstone ) then
17045: LD_EXP 27
17049: PUSH
17050: LD_EXP 27
17054: PPUSH
17055: CALL_OW 255
17059: PUSH
17060: LD_INT 7
17062: EQUAL
17063: AND
17064: PUSH
17065: LD_EXP 27
17069: PPUSH
17070: CALL_OW 305
17074: AND
17075: IFFALSE 17089
// Say ( Gladstone , DEnd-JMM-Glad-1 ) ;
17077: LD_EXP 27
17081: PPUSH
17082: LD_STRING DEnd-JMM-Glad-1
17084: PPUSH
17085: CALL_OW 88
// if Kikuchi and GetSide ( Kikuchi ) = 7 and IsPlaced ( Kikuchi ) then
17089: LD_EXP 32
17093: PUSH
17094: LD_EXP 32
17098: PPUSH
17099: CALL_OW 255
17103: PUSH
17104: LD_INT 7
17106: EQUAL
17107: AND
17108: PUSH
17109: LD_EXP 32
17113: PPUSH
17114: CALL_OW 305
17118: AND
17119: IFFALSE 17133
// Say ( Kikuchi , DEnd-JMM-Yam-1 ) ;
17121: LD_EXP 32
17125: PPUSH
17126: LD_STRING DEnd-JMM-Yam-1
17128: PPUSH
17129: CALL_OW 88
// if Brown and GetSide ( Brown ) = 7 and IsPlaced ( Brown ) then
17133: LD_EXP 26
17137: PUSH
17138: LD_EXP 26
17142: PPUSH
17143: CALL_OW 255
17147: PUSH
17148: LD_INT 7
17150: EQUAL
17151: AND
17152: PUSH
17153: LD_EXP 26
17157: PPUSH
17158: CALL_OW 305
17162: AND
17163: IFFALSE 17177
// Say ( Brown , DEnd-JMM-Brown-1 ) ;
17165: LD_EXP 26
17169: PPUSH
17170: LD_STRING DEnd-JMM-Brown-1
17172: PPUSH
17173: CALL_OW 88
// if Connie and GetSide ( Connie ) = 7 and IsPlaced ( Connie ) then
17177: LD_EXP 36
17181: PUSH
17182: LD_EXP 36
17186: PPUSH
17187: CALL_OW 255
17191: PUSH
17192: LD_INT 7
17194: EQUAL
17195: AND
17196: PUSH
17197: LD_EXP 36
17201: PPUSH
17202: CALL_OW 305
17206: AND
17207: IFFALSE 17221
// Say ( Connie , DEnd-JMM-Con-1 ) ;
17209: LD_EXP 36
17213: PPUSH
17214: LD_STRING DEnd-JMM-Con-1
17216: PPUSH
17217: CALL_OW 88
// if Gary and GetSide ( Gary ) = 7 and IsPlaced ( Gary ) then
17221: LD_EXP 30
17225: PUSH
17226: LD_EXP 30
17230: PPUSH
17231: CALL_OW 255
17235: PUSH
17236: LD_INT 7
17238: EQUAL
17239: AND
17240: PUSH
17241: LD_EXP 30
17245: PPUSH
17246: CALL_OW 305
17250: AND
17251: IFFALSE 17265
// Say ( Gary , DEnd-JMM-Gary-1 ) ;
17253: LD_EXP 30
17257: PPUSH
17258: LD_STRING DEnd-JMM-Gary-1
17260: PPUSH
17261: CALL_OW 88
// if Simms and Roth and IsPlaced ( Simms ) then
17265: LD_EXP 33
17269: PUSH
17270: LD_EXP 20
17274: AND
17275: PUSH
17276: LD_EXP 33
17280: PPUSH
17281: CALL_OW 305
17285: AND
17286: IFFALSE 17300
// Say ( Simms , DEnd-JMM-Sim-1 ) ;
17288: LD_EXP 33
17292: PPUSH
17293: LD_STRING DEnd-JMM-Sim-1
17295: PPUSH
17296: CALL_OW 88
// if Houten and GetSide ( Houten ) = 7 and IsPlaced ( Houten ) then
17300: LD_EXP 28
17304: PUSH
17305: LD_EXP 28
17309: PPUSH
17310: CALL_OW 255
17314: PUSH
17315: LD_INT 7
17317: EQUAL
17318: AND
17319: PUSH
17320: LD_EXP 28
17324: PPUSH
17325: CALL_OW 305
17329: AND
17330: IFFALSE 17344
// Say ( Houten , DEnd-JMM-VanH-1 ) ;
17332: LD_EXP 28
17336: PPUSH
17337: LD_STRING DEnd-JMM-VanH-1
17339: PPUSH
17340: CALL_OW 88
// if Dolgov and IsPlaced ( Dolgov ) then
17344: LD_EXP 41
17348: PUSH
17349: LD_EXP 41
17353: PPUSH
17354: CALL_OW 305
17358: AND
17359: IFFALSE 17373
// Say ( Dolgov , DEnd-JMM-Dol-1 ) ;
17361: LD_EXP 41
17365: PPUSH
17366: LD_STRING DEnd-JMM-Dol-1
17368: PPUSH
17369: CALL_OW 88
// if Kapitsova and IsPlaced ( Kapitsova ) then
17373: LD_EXP 45
17377: PUSH
17378: LD_EXP 45
17382: PPUSH
17383: CALL_OW 305
17387: AND
17388: IFFALSE 17402
// Say ( Kapitsova , DEnd-JMM-Kap-1 ) ;
17390: LD_EXP 45
17394: PPUSH
17395: LD_STRING DEnd-JMM-Kap-1
17397: PPUSH
17398: CALL_OW 88
// if Kovalyuk and IsPlaced ( Kovalyuk ) then
17402: LD_EXP 48
17406: PUSH
17407: LD_EXP 48
17411: PPUSH
17412: CALL_OW 305
17416: AND
17417: IFFALSE 17431
// Say ( Kovalyuk , DEnd-JMM-Kov-1 ) ;
17419: LD_EXP 48
17423: PPUSH
17424: LD_STRING DEnd-JMM-Kov-1
17426: PPUSH
17427: CALL_OW 88
// if Scholtze and IsPlaced ( Scholtze ) then
17431: LD_EXP 43
17435: PUSH
17436: LD_EXP 43
17440: PPUSH
17441: CALL_OW 305
17445: AND
17446: IFFALSE 17460
// Say ( Scholtze , DEnd-JMM-Sch-1 ) ;
17448: LD_EXP 43
17452: PPUSH
17453: LD_STRING DEnd-JMM-Sch-1
17455: PPUSH
17456: CALL_OW 88
// if Titov and IsPlaced ( Titov ) then
17460: LD_EXP 39
17464: PUSH
17465: LD_EXP 39
17469: PPUSH
17470: CALL_OW 305
17474: AND
17475: IFFALSE 17489
// Say ( Titov , DEnd-JMM-Tit-1 ) ;
17477: LD_EXP 39
17481: PPUSH
17482: LD_STRING DEnd-JMM-Tit-1
17484: PPUSH
17485: CALL_OW 88
// if Oblukov and IsPlaced ( Oblukov ) then
17489: LD_EXP 44
17493: PUSH
17494: LD_EXP 44
17498: PPUSH
17499: CALL_OW 305
17503: AND
17504: IFFALSE 17518
// Say ( Oblukov , DEnd-JMM-Obl-1 ) ;
17506: LD_EXP 44
17510: PPUSH
17511: LD_STRING DEnd-JMM-Obl-1
17513: PPUSH
17514: CALL_OW 88
// if Lipshchin and IsPlaced ( Lipshchin ) then
17518: LD_EXP 46
17522: PUSH
17523: LD_EXP 46
17527: PPUSH
17528: CALL_OW 305
17532: AND
17533: IFFALSE 17547
// Say ( Lipshchin , DEnd-JMM-Lip-1 ) ;
17535: LD_EXP 46
17539: PPUSH
17540: LD_STRING DEnd-JMM-Lip-1
17542: PPUSH
17543: CALL_OW 88
// if Fadeev and IsPlaced ( Fadeev ) and Burlak then
17547: LD_EXP 40
17551: PUSH
17552: LD_EXP 40
17556: PPUSH
17557: CALL_OW 305
17561: AND
17562: PUSH
17563: LD_EXP 51
17567: AND
17568: IFFALSE 17582
// Say ( Fadeev , DEnd-Burlak-Fad-1 ) ;
17570: LD_EXP 40
17574: PPUSH
17575: LD_STRING DEnd-Burlak-Fad-1
17577: PPUSH
17578: CALL_OW 88
// if Petrovova and IsPlaced ( Petrovova ) then
17582: LD_EXP 47
17586: PUSH
17587: LD_EXP 47
17591: PPUSH
17592: CALL_OW 305
17596: AND
17597: IFFALSE 17611
// Say ( Petrovova , DEnd-Burlak-Ptr-1 ) ;
17599: LD_EXP 47
17603: PPUSH
17604: LD_STRING DEnd-Burlak-Ptr-1
17606: PPUSH
17607: CALL_OW 88
// if Kuzmov and IsPlaced ( Kuzmov ) then
17611: LD_EXP 49
17615: PUSH
17616: LD_EXP 49
17620: PPUSH
17621: CALL_OW 305
17625: AND
17626: IFFALSE 17640
// Say ( Kuzmov , DEnd-Burlak-Kuz-1 ) ;
17628: LD_EXP 49
17632: PPUSH
17633: LD_STRING DEnd-Burlak-Kuz-1
17635: PPUSH
17636: CALL_OW 88
// if Kirilenkova and IsPlaced ( Kirilenkova ) and Burlak then
17640: LD_EXP 38
17644: PUSH
17645: LD_EXP 38
17649: PPUSH
17650: CALL_OW 305
17654: AND
17655: PUSH
17656: LD_EXP 51
17660: AND
17661: IFFALSE 17675
// Say ( Kirilenkova , DEnd-Burlak-Kir-1 ) ;
17663: LD_EXP 38
17667: PPUSH
17668: LD_STRING DEnd-Burlak-Kir-1
17670: PPUSH
17671: CALL_OW 88
// if Burlak then
17675: LD_EXP 51
17679: IFFALSE 17693
// Say ( JMM , DEnd-Burlak-JMM-1 ) ;
17681: LD_EXP 19
17685: PPUSH
17686: LD_STRING DEnd-Burlak-JMM-1
17688: PPUSH
17689: CALL_OW 88
// dwait ( 0 0$2 ) ;
17693: LD_INT 70
17695: PPUSH
17696: CALL_OW 68
// SayRadio ( Schulz , DEnd-Szulc ) ;
17700: LD_EXP 56
17704: PPUSH
17705: LD_STRING DEnd-Szulc
17707: PPUSH
17708: CALL_OW 94
// dwait ( 0 0$1 ) ;
17712: LD_INT 35
17714: PPUSH
17715: CALL_OW 68
// if IsLive ( Burlak ) then
17719: LD_EXP 51
17723: PPUSH
17724: CALL_OW 300
17728: IFFALSE 17740
// med1 := 1 else
17730: LD_ADDR_VAR 0 1
17734: PUSH
17735: LD_INT 1
17737: ST_TO_ADDR
17738: GO 17749
// med1 := - 1 ;
17740: LD_ADDR_VAR 0 1
17744: PUSH
17745: LD_INT 1
17747: NEG
17748: ST_TO_ADDR
// if artifactIResearched and artifactIIResearched and artifactIIIResearched then
17749: LD_EXP 12
17753: PUSH
17754: LD_EXP 13
17758: AND
17759: PUSH
17760: LD_EXP 14
17764: AND
17765: IFFALSE 17777
// med2 := 1 else
17767: LD_ADDR_VAR 0 2
17771: PUSH
17772: LD_INT 1
17774: ST_TO_ADDR
17775: GO 17786
// med2 := - 1 ;
17777: LD_ADDR_VAR 0 2
17781: PUSH
17782: LD_INT 1
17784: NEG
17785: ST_TO_ADDR
// AddMedal ( Hero , 1 ) ;
17786: LD_STRING Hero
17788: PPUSH
17789: LD_INT 1
17791: PPUSH
17792: CALL_OW 101
// AddMedal ( Artefact , med2 ) ;
17796: LD_STRING Artefact
17798: PPUSH
17799: LD_VAR 0 2
17803: PPUSH
17804: CALL_OW 101
// AddMedal ( ReconcileBurlak , med1 ) ;
17808: LD_STRING ReconcileBurlak
17810: PPUSH
17811: LD_VAR 0 1
17815: PPUSH
17816: CALL_OW 101
// if Difficulty >= 3 and med1 = 1 and med2 = 1 then
17820: LD_OWVAR 67
17824: PUSH
17825: LD_INT 3
17827: GREATEREQUAL
17828: PUSH
17829: LD_VAR 0 1
17833: PUSH
17834: LD_INT 1
17836: EQUAL
17837: AND
17838: PUSH
17839: LD_VAR 0 2
17843: PUSH
17844: LD_INT 1
17846: EQUAL
17847: AND
17848: IFFALSE 17860
// SetAchievementEX ( ACH_AMER , 19 ) ;
17850: LD_STRING ACH_AMER
17852: PPUSH
17853: LD_INT 19
17855: PPUSH
17856: CALL_OW 564
// GiveMedals ( MAIN ) ;
17860: LD_STRING MAIN
17862: PPUSH
17863: CALL_OW 102
// InGameOff ;
17867: CALL_OW 9
// DialogueOff ;
17871: CALL_OW 7
// music_nat := 1 ;
17875: LD_ADDR_OWVAR 71
17879: PUSH
17880: LD_INT 1
17882: ST_TO_ADDR
// music_class := 4 ;
17883: LD_ADDR_OWVAR 72
17887: PUSH
17888: LD_INT 4
17890: ST_TO_ADDR
// YouWin ;
17891: CALL_OW 103
// end ; end_of_file
17895: PPOPN 2
17897: END
// export function InitNature ; begin
17898: LD_INT 0
17900: PPUSH
// PrepareNature ( 3 , 3 , 2 , 1 , 1 , 0 , 0 , natureArea1 , 0 ) ;
17901: LD_INT 3
17903: PPUSH
17904: LD_INT 3
17906: PPUSH
17907: LD_INT 2
17909: PPUSH
17910: LD_INT 1
17912: PPUSH
17913: LD_INT 1
17915: PPUSH
17916: LD_INT 0
17918: PPUSH
17919: LD_INT 0
17921: PPUSH
17922: LD_INT 17
17924: PPUSH
17925: LD_INT 0
17927: PPUSH
17928: CALL 85389 0 9
// PrepareNature ( 2 , 1 , 1 , 1 , 1 , 0 , 0 , natureArea2 , 0 ) ;
17932: LD_INT 2
17934: PPUSH
17935: LD_INT 1
17937: PPUSH
17938: LD_INT 1
17940: PPUSH
17941: LD_INT 1
17943: PPUSH
17944: LD_INT 1
17946: PPUSH
17947: LD_INT 0
17949: PPUSH
17950: LD_INT 0
17952: PPUSH
17953: LD_INT 18
17955: PPUSH
17956: LD_INT 0
17958: PPUSH
17959: CALL 85389 0 9
// PrepareNature ( 4 , 1 , 2 , 4 , 2 , 1 , 0 , natureArea3 , 0 ) ;
17963: LD_INT 4
17965: PPUSH
17966: LD_INT 1
17968: PPUSH
17969: LD_INT 2
17971: PPUSH
17972: LD_INT 4
17974: PPUSH
17975: LD_INT 2
17977: PPUSH
17978: LD_INT 1
17980: PPUSH
17981: LD_INT 0
17983: PPUSH
17984: LD_INT 19
17986: PPUSH
17987: LD_INT 0
17989: PPUSH
17990: CALL 85389 0 9
// PrepareNature ( 0 , 0 , 0 , 0 , 0 , 0 , 9 , 0 , natureWaterArea ) ;
17994: LD_INT 0
17996: PPUSH
17997: LD_INT 0
17999: PPUSH
18000: LD_INT 0
18002: PPUSH
18003: LD_INT 0
18005: PPUSH
18006: LD_INT 0
18008: PPUSH
18009: LD_INT 0
18011: PPUSH
18012: LD_INT 9
18014: PPUSH
18015: LD_INT 0
18017: PPUSH
18018: LD_INT 20
18020: PPUSH
18021: CALL 85389 0 9
// end ; end_of_file
18025: LD_VAR 0 1
18029: RET
// every 0 0$30 do var time ;
18030: GO 18032
18032: DISABLE
18033: LD_INT 0
18035: PPUSH
// begin time := 0 0$30 ;
18036: LD_ADDR_VAR 0 1
18040: PUSH
18041: LD_INT 1050
18043: ST_TO_ADDR
// repeat wait ( time ) ;
18044: LD_VAR 0 1
18048: PPUSH
18049: CALL_OW 67
// if Prob ( 50 ) then
18053: LD_INT 50
18055: PPUSH
18056: CALL_OW 13
18060: IFFALSE 18089
// CreateCratesXYR ( rand ( 1 , 5 ) , 106 , 89 , 45 , true ) ;
18062: LD_INT 1
18064: PPUSH
18065: LD_INT 5
18067: PPUSH
18068: CALL_OW 12
18072: PPUSH
18073: LD_INT 106
18075: PPUSH
18076: LD_INT 89
18078: PPUSH
18079: LD_INT 45
18081: PPUSH
18082: LD_INT 1
18084: PPUSH
18085: CALL_OW 56
// time := time + 0 0$3 ;
18089: LD_ADDR_VAR 0 1
18093: PUSH
18094: LD_VAR 0 1
18098: PUSH
18099: LD_INT 105
18101: PLUS
18102: ST_TO_ADDR
// if Prob ( 30 ) then
18103: LD_INT 30
18105: PPUSH
18106: CALL_OW 13
18110: IFFALSE 18156
// begin wait ( rand ( 0 0$15 , 0 0$21 ) ) ;
18112: LD_INT 525
18114: PPUSH
18115: LD_INT 735
18117: PPUSH
18118: CALL_OW 12
18122: PPUSH
18123: CALL_OW 67
// CreateCratesXYR ( rand ( 1 , 5 ) , 21 , 26 , 12 , true ) ;
18127: LD_INT 1
18129: PPUSH
18130: LD_INT 5
18132: PPUSH
18133: CALL_OW 12
18137: PPUSH
18138: LD_INT 21
18140: PPUSH
18141: LD_INT 26
18143: PPUSH
18144: LD_INT 12
18146: PPUSH
18147: LD_INT 1
18149: PPUSH
18150: CALL_OW 56
// end else
18154: GO 18192
// begin wait ( rand ( 0 0$20 , 0 0$35 ) ) ;
18156: LD_INT 700
18158: PPUSH
18159: LD_INT 1225
18161: PPUSH
18162: CALL_OW 12
18166: PPUSH
18167: CALL_OW 67
// CreateCratesArea ( rand ( 1 , 5 ) , russianCratesArea , true ) ;
18171: LD_INT 1
18173: PPUSH
18174: LD_INT 5
18176: PPUSH
18177: CALL_OW 12
18181: PPUSH
18182: LD_INT 14
18184: PPUSH
18185: LD_INT 1
18187: PPUSH
18188: CALL_OW 55
// end ; if Prob ( 50 ) then
18192: LD_INT 50
18194: PPUSH
18195: CALL_OW 13
18199: IFFALSE 18245
// begin wait ( rand ( 0 0$20 , 0 0$30 ) ) ;
18201: LD_INT 700
18203: PPUSH
18204: LD_INT 1050
18206: PPUSH
18207: CALL_OW 12
18211: PPUSH
18212: CALL_OW 67
// CreateCratesXYR ( rand ( 1 , 5 ) , 181 , 218 , 16 , true ) ;
18216: LD_INT 1
18218: PPUSH
18219: LD_INT 5
18221: PPUSH
18222: CALL_OW 12
18226: PPUSH
18227: LD_INT 181
18229: PPUSH
18230: LD_INT 218
18232: PPUSH
18233: LD_INT 16
18235: PPUSH
18236: LD_INT 1
18238: PPUSH
18239: CALL_OW 56
// end else
18243: GO 18317
// begin wait ( rand ( 0 0$10 , 0 0$15 ) ) ;
18245: LD_INT 350
18247: PPUSH
18248: LD_INT 525
18250: PPUSH
18251: CALL_OW 12
18255: PPUSH
18256: CALL_OW 67
// CreateCratesArea ( rand ( 1 , 5 ) , legionCratesArea , true ) ;
18260: LD_INT 1
18262: PPUSH
18263: LD_INT 5
18265: PPUSH
18266: CALL_OW 12
18270: PPUSH
18271: LD_INT 13
18273: PPUSH
18274: LD_INT 1
18276: PPUSH
18277: CALL_OW 55
// wait ( rand ( 0 0$10 , 0 0$20 ) ) ;
18281: LD_INT 350
18283: PPUSH
18284: LD_INT 700
18286: PPUSH
18287: CALL_OW 12
18291: PPUSH
18292: CALL_OW 67
// CreateCratesArea ( rand ( 1 , 5 ) , americanCratesArea , true ) ;
18296: LD_INT 1
18298: PPUSH
18299: LD_INT 5
18301: PPUSH
18302: CALL_OW 12
18306: PPUSH
18307: LD_INT 33
18309: PPUSH
18310: LD_INT 1
18312: PPUSH
18313: CALL_OW 55
// end ; if Prob ( [ 65 , 62 , 55 , 50 ] [ Difficulty ] ) then
18317: LD_INT 65
18319: PUSH
18320: LD_INT 62
18322: PUSH
18323: LD_INT 55
18325: PUSH
18326: LD_INT 50
18328: PUSH
18329: EMPTY
18330: LIST
18331: LIST
18332: LIST
18333: LIST
18334: PUSH
18335: LD_OWVAR 67
18339: ARRAY
18340: PPUSH
18341: CALL_OW 13
18345: IFFALSE 18391
// begin wait ( rand ( 0 0$15 , 0 0$25 ) ) ;
18347: LD_INT 525
18349: PPUSH
18350: LD_INT 875
18352: PPUSH
18353: CALL_OW 12
18357: PPUSH
18358: CALL_OW 67
// CreateCratesXYR ( rand ( 1 , 5 ) , 294 , 211 , 30 , true ) ;
18362: LD_INT 1
18364: PPUSH
18365: LD_INT 5
18367: PPUSH
18368: CALL_OW 12
18372: PPUSH
18373: LD_INT 294
18375: PPUSH
18376: LD_INT 211
18378: PPUSH
18379: LD_INT 30
18381: PPUSH
18382: LD_INT 1
18384: PPUSH
18385: CALL_OW 56
// end else
18389: GO 18433
// begin wait ( rand ( 0 0$12 , 0 0$22 ) ) ;
18391: LD_INT 420
18393: PPUSH
18394: LD_INT 770
18396: PPUSH
18397: CALL_OW 12
18401: PPUSH
18402: CALL_OW 67
// CreateCratesXYR ( rand ( 1 , 5 ) , 294 , 211 , 30 , true ) ;
18406: LD_INT 1
18408: PPUSH
18409: LD_INT 5
18411: PPUSH
18412: CALL_OW 12
18416: PPUSH
18417: LD_INT 294
18419: PPUSH
18420: LD_INT 211
18422: PPUSH
18423: LD_INT 30
18425: PPUSH
18426: LD_INT 1
18428: PPUSH
18429: CALL_OW 56
// end ; if time > 2 2$20 then
18433: LD_VAR 0 1
18437: PUSH
18438: LD_INT 4900
18440: GREATER
18441: IFFALSE 18451
// time := 0 0$50 ;
18443: LD_ADDR_VAR 0 1
18447: PUSH
18448: LD_INT 1750
18450: ST_TO_ADDR
// until false ;
18451: LD_INT 0
18453: IFFALSE 18044
// end ;
18455: PPOPN 1
18457: END
// every 0 0$45 trigger tick < 10 10$00 do
18458: LD_OWVAR 1
18462: PUSH
18463: LD_INT 21000
18465: LESS
18466: IFFALSE 18514
18468: GO 18470
18470: DISABLE
// begin enable ;
18471: ENABLE
// wait ( rand ( 0 0$10 , 0 0$20 ) ) ;
18472: LD_INT 350
18474: PPUSH
18475: LD_INT 700
18477: PPUSH
18478: CALL_OW 12
18482: PPUSH
18483: CALL_OW 67
// CreateCratesXYR ( rand ( 3 , 5 ) , 181 , 13 , 20 , true ) ;
18487: LD_INT 3
18489: PPUSH
18490: LD_INT 5
18492: PPUSH
18493: CALL_OW 12
18497: PPUSH
18498: LD_INT 181
18500: PPUSH
18501: LD_INT 13
18503: PPUSH
18504: LD_INT 20
18506: PPUSH
18507: LD_INT 1
18509: PPUSH
18510: CALL_OW 56
// end ; end_of_file
18514: END
// export artifactsPos , artifactsRecharge , artifactsSibCost , artifactsResearched , artifactsLabsWorking ; export artifactsResDifficulty , artifactsResProgress , artifactsLabs , artifactsButtons , artifactsReady ; export function InitArtifact ; begin
18515: LD_INT 0
18517: PPUSH
// SetArtifactRes ( 7 , true ) ;
18518: LD_INT 7
18520: PPUSH
18521: LD_INT 1
18523: PPUSH
18524: CALL_OW 467
// artifactsPos := [ [ ] , [ ] , [ ] ] ;
18528: LD_ADDR_EXP 64
18532: PUSH
18533: EMPTY
18534: PUSH
18535: EMPTY
18536: PUSH
18537: EMPTY
18538: PUSH
18539: EMPTY
18540: LIST
18541: LIST
18542: LIST
18543: ST_TO_ADDR
// artifactsRecharge := [ 0 0$30 * Difficulty , 1 1$20 * Difficulty , - 1 ] ;
18544: LD_ADDR_EXP 65
18548: PUSH
18549: LD_INT 1050
18551: PUSH
18552: LD_OWVAR 67
18556: MUL
18557: PUSH
18558: LD_INT 2800
18560: PUSH
18561: LD_OWVAR 67
18565: MUL
18566: PUSH
18567: LD_INT 1
18569: NEG
18570: PUSH
18571: EMPTY
18572: LIST
18573: LIST
18574: LIST
18575: ST_TO_ADDR
// artifactsSibCost := [ 10 , 35 , 100 ] ;
18576: LD_ADDR_EXP 66
18580: PUSH
18581: LD_INT 10
18583: PUSH
18584: LD_INT 35
18586: PUSH
18587: LD_INT 100
18589: PUSH
18590: EMPTY
18591: LIST
18592: LIST
18593: LIST
18594: ST_TO_ADDR
// artifactsResearched := [ 0 , 0 , 0 ] ;
18595: LD_ADDR_EXP 67
18599: PUSH
18600: LD_INT 0
18602: PUSH
18603: LD_INT 0
18605: PUSH
18606: LD_INT 0
18608: PUSH
18609: EMPTY
18610: LIST
18611: LIST
18612: LIST
18613: ST_TO_ADDR
// artifactsResDifficulty := [ 300 , 500 , 800 ] ;
18614: LD_ADDR_EXP 69
18618: PUSH
18619: LD_INT 300
18621: PUSH
18622: LD_INT 500
18624: PUSH
18625: LD_INT 800
18627: PUSH
18628: EMPTY
18629: LIST
18630: LIST
18631: LIST
18632: ST_TO_ADDR
// artifactsResProgress := [ 0 , 0 , 0 ] ;
18633: LD_ADDR_EXP 70
18637: PUSH
18638: LD_INT 0
18640: PUSH
18641: LD_INT 0
18643: PUSH
18644: LD_INT 0
18646: PUSH
18647: EMPTY
18648: LIST
18649: LIST
18650: LIST
18651: ST_TO_ADDR
// artifactsLabs := [ 0 , 0 , 0 ] ;
18652: LD_ADDR_EXP 71
18656: PUSH
18657: LD_INT 0
18659: PUSH
18660: LD_INT 0
18662: PUSH
18663: LD_INT 0
18665: PUSH
18666: EMPTY
18667: LIST
18668: LIST
18669: LIST
18670: ST_TO_ADDR
// artifactsLabsWorking := [ 0 , 0 , 0 ] ;
18671: LD_ADDR_EXP 68
18675: PUSH
18676: LD_INT 0
18678: PUSH
18679: LD_INT 0
18681: PUSH
18682: LD_INT 0
18684: PUSH
18685: EMPTY
18686: LIST
18687: LIST
18688: LIST
18689: ST_TO_ADDR
// artifactsButtons := [ [ art_use_eye , art_place , art_exp_left ] , [ art_use_sibexplosion , art_unit , art_exp_mid ] , [ art_use_teleport , art_place , art_exp_right ] ] ;
18690: LD_ADDR_EXP 72
18694: PUSH
18695: LD_INT 4
18697: PUSH
18698: LD_INT 3
18700: PUSH
18701: LD_INT 1
18703: PUSH
18704: EMPTY
18705: LIST
18706: LIST
18707: LIST
18708: PUSH
18709: LD_INT 5
18711: PUSH
18712: LD_INT 4
18714: PUSH
18715: LD_INT 2
18717: PUSH
18718: EMPTY
18719: LIST
18720: LIST
18721: LIST
18722: PUSH
18723: LD_INT 6
18725: PUSH
18726: LD_INT 3
18728: PUSH
18729: LD_INT 3
18731: PUSH
18732: EMPTY
18733: LIST
18734: LIST
18735: LIST
18736: PUSH
18737: EMPTY
18738: LIST
18739: LIST
18740: LIST
18741: ST_TO_ADDR
// artifactsReady := [ 0 , 0 , 0 ] ;
18742: LD_ADDR_EXP 73
18746: PUSH
18747: LD_INT 0
18749: PUSH
18750: LD_INT 0
18752: PUSH
18753: LD_INT 0
18755: PUSH
18756: EMPTY
18757: LIST
18758: LIST
18759: LIST
18760: ST_TO_ADDR
// end ;
18761: LD_VAR 0 1
18765: RET
// every 0 0$1 trigger GetTech ( tech_artifact , 7 ) = state_researched do var i , pos , j , labs , nearestLab ;
18766: LD_INT 24
18768: PPUSH
18769: LD_INT 7
18771: PPUSH
18772: CALL_OW 321
18776: PUSH
18777: LD_INT 2
18779: EQUAL
18780: IFFALSE 19706
18782: GO 18784
18784: DISABLE
18785: LD_INT 0
18787: PPUSH
18788: PPUSH
18789: PPUSH
18790: PPUSH
18791: PPUSH
// begin enable ;
18792: ENABLE
// for i = 1 to 3 do
18793: LD_ADDR_VAR 0 1
18797: PUSH
18798: DOUBLE
18799: LD_INT 1
18801: DEC
18802: ST_TO_ADDR
18803: LD_INT 3
18805: PUSH
18806: FOR_TO
18807: IFFALSE 19704
// begin pos := FindArtifact ( i + 2 ) ;
18809: LD_ADDR_VAR 0 2
18813: PUSH
18814: LD_VAR 0 1
18818: PUSH
18819: LD_INT 2
18821: PLUS
18822: PPUSH
18823: CALL_OW 469
18827: ST_TO_ADDR
// artifactsPos := Replace ( artifactsPos , i , pos ) ;
18828: LD_ADDR_EXP 64
18832: PUSH
18833: LD_EXP 64
18837: PPUSH
18838: LD_VAR 0 1
18842: PPUSH
18843: LD_VAR 0 2
18847: PPUSH
18848: CALL_OW 1
18852: ST_TO_ADDR
// if pos then
18853: LD_VAR 0 2
18857: IFFALSE 19565
// begin case i of 1 :
18859: LD_VAR 0 1
18863: PUSH
18864: LD_INT 1
18866: DOUBLE
18867: EQUAL
18868: IFTRUE 18872
18870: GO 18949
18872: POP
// labs := FilterAllUnits ( [ [ f_side , 7 ] , [ f_nation , 1 ] , [ f_or , [ f_btype , b_lab_full ] , [ f_btype , b_lab_half ] , [ f_btype , b_lab_siberium ] ] ] ) ; 2 :
18873: LD_ADDR_VAR 0 4
18877: PUSH
18878: LD_INT 22
18880: PUSH
18881: LD_INT 7
18883: PUSH
18884: EMPTY
18885: LIST
18886: LIST
18887: PUSH
18888: LD_INT 23
18890: PUSH
18891: LD_INT 1
18893: PUSH
18894: EMPTY
18895: LIST
18896: LIST
18897: PUSH
18898: LD_INT 2
18900: PUSH
18901: LD_INT 30
18903: PUSH
18904: LD_INT 8
18906: PUSH
18907: EMPTY
18908: LIST
18909: LIST
18910: PUSH
18911: LD_INT 30
18913: PUSH
18914: LD_INT 7
18916: PUSH
18917: EMPTY
18918: LIST
18919: LIST
18920: PUSH
18921: LD_INT 30
18923: PUSH
18924: LD_INT 11
18926: PUSH
18927: EMPTY
18928: LIST
18929: LIST
18930: PUSH
18931: EMPTY
18932: LIST
18933: LIST
18934: LIST
18935: LIST
18936: PUSH
18937: EMPTY
18938: LIST
18939: LIST
18940: LIST
18941: PPUSH
18942: CALL_OW 69
18946: ST_TO_ADDR
18947: GO 19057
18949: LD_INT 2
18951: DOUBLE
18952: EQUAL
18953: IFTRUE 18957
18955: GO 19034
18957: POP
// labs := FilterAllUnits ( [ [ f_side , 7 ] , [ f_nation , 3 ] , [ f_or , [ f_btype , b_lab_full ] , [ f_btype , b_lab_half ] , [ f_btype , b_lab_siberium ] ] ] ) ; 3 :
18958: LD_ADDR_VAR 0 4
18962: PUSH
18963: LD_INT 22
18965: PUSH
18966: LD_INT 7
18968: PUSH
18969: EMPTY
18970: LIST
18971: LIST
18972: PUSH
18973: LD_INT 23
18975: PUSH
18976: LD_INT 3
18978: PUSH
18979: EMPTY
18980: LIST
18981: LIST
18982: PUSH
18983: LD_INT 2
18985: PUSH
18986: LD_INT 30
18988: PUSH
18989: LD_INT 8
18991: PUSH
18992: EMPTY
18993: LIST
18994: LIST
18995: PUSH
18996: LD_INT 30
18998: PUSH
18999: LD_INT 7
19001: PUSH
19002: EMPTY
19003: LIST
19004: LIST
19005: PUSH
19006: LD_INT 30
19008: PUSH
19009: LD_INT 11
19011: PUSH
19012: EMPTY
19013: LIST
19014: LIST
19015: PUSH
19016: EMPTY
19017: LIST
19018: LIST
19019: LIST
19020: LIST
19021: PUSH
19022: EMPTY
19023: LIST
19024: LIST
19025: LIST
19026: PPUSH
19027: CALL_OW 69
19031: ST_TO_ADDR
19032: GO 19057
19034: LD_INT 3
19036: DOUBLE
19037: EQUAL
19038: IFTRUE 19042
19040: GO 19056
19042: POP
// labs := [ alien ] ; end ;
19043: LD_ADDR_VAR 0 4
19047: PUSH
19048: LD_INT 1
19050: PUSH
19051: EMPTY
19052: LIST
19053: ST_TO_ADDR
19054: GO 19057
19056: POP
// if not labs then
19057: LD_VAR 0 4
19061: NOT
19062: IFFALSE 19066
// continue ;
19064: GO 18806
// nearestLab := NearestUnitToXY ( labs , artifactsPos [ i ] [ 1 ] , artifactsPos [ i ] [ 2 ] ) ;
19066: LD_ADDR_VAR 0 5
19070: PUSH
19071: LD_VAR 0 4
19075: PPUSH
19076: LD_EXP 64
19080: PUSH
19081: LD_VAR 0 1
19085: ARRAY
19086: PUSH
19087: LD_INT 1
19089: ARRAY
19090: PPUSH
19091: LD_EXP 64
19095: PUSH
19096: LD_VAR 0 1
19100: ARRAY
19101: PUSH
19102: LD_INT 2
19104: ARRAY
19105: PPUSH
19106: CALL_OW 73
19110: ST_TO_ADDR
// if not nearestLab or nearestLab <> artifactsLabs [ i ] then
19111: LD_VAR 0 5
19115: NOT
19116: PUSH
19117: LD_VAR 0 5
19121: PUSH
19122: LD_EXP 71
19126: PUSH
19127: LD_VAR 0 1
19131: ARRAY
19132: NONEQUAL
19133: OR
19134: IFFALSE 19239
// begin SetArtifactUse ( 7 , artifactsButtons [ i ] [ 3 ] , art_no , artifactsLabs [ i ] ) ;
19136: LD_INT 7
19138: PPUSH
19139: LD_EXP 72
19143: PUSH
19144: LD_VAR 0 1
19148: ARRAY
19149: PUSH
19150: LD_INT 3
19152: ARRAY
19153: PPUSH
19154: LD_INT 0
19156: PPUSH
19157: LD_EXP 71
19161: PUSH
19162: LD_VAR 0 1
19166: ARRAY
19167: PPUSH
19168: CALL_OW 468
// SetArtifactUse ( 7 , artifactsButtons [ i ] [ 1 ] , art_no , artifactsLabs [ i ] ) ;
19172: LD_INT 7
19174: PPUSH
19175: LD_EXP 72
19179: PUSH
19180: LD_VAR 0 1
19184: ARRAY
19185: PUSH
19186: LD_INT 1
19188: ARRAY
19189: PPUSH
19190: LD_INT 0
19192: PPUSH
19193: LD_EXP 71
19197: PUSH
19198: LD_VAR 0 1
19202: ARRAY
19203: PPUSH
19204: CALL_OW 468
// if nearestLab then
19208: LD_VAR 0 5
19212: IFFALSE 19239
// artifactsLabs := Replace ( artifactsLabs , i , nearestLab ) ;
19214: LD_ADDR_EXP 71
19218: PUSH
19219: LD_EXP 71
19223: PPUSH
19224: LD_VAR 0 1
19228: PPUSH
19229: LD_VAR 0 5
19233: PPUSH
19234: CALL_OW 1
19238: ST_TO_ADDR
// end ; if not nearestLab then
19239: LD_VAR 0 5
19243: NOT
19244: IFFALSE 19248
// continue ;
19246: GO 18806
// if GetDistUnitXY ( nearestLab , artifactsPos [ i ] [ 1 ] , artifactsPos [ i ] [ 2 ] ) < 8 then
19248: LD_VAR 0 5
19252: PPUSH
19253: LD_EXP 64
19257: PUSH
19258: LD_VAR 0 1
19262: ARRAY
19263: PUSH
19264: LD_INT 1
19266: ARRAY
19267: PPUSH
19268: LD_EXP 64
19272: PUSH
19273: LD_VAR 0 1
19277: ARRAY
19278: PUSH
19279: LD_INT 2
19281: ARRAY
19282: PPUSH
19283: CALL_OW 297
19287: PUSH
19288: LD_INT 8
19290: LESS
19291: IFFALSE 19488
// begin if not artifactsResearched [ i ] then
19293: LD_EXP 67
19297: PUSH
19298: LD_VAR 0 1
19302: ARRAY
19303: NOT
19304: IFFALSE 19385
// begin if BuildingStatus ( nearestLab ) = bs_idle then
19306: LD_VAR 0 5
19310: PPUSH
19311: CALL_OW 461
19315: PUSH
19316: LD_INT 2
19318: EQUAL
19319: IFFALSE 19353
// SetArtifactUse ( 7 , artifactsButtons [ i ] [ 3 ] , art_instant , nearestLab ) else
19321: LD_INT 7
19323: PPUSH
19324: LD_EXP 72
19328: PUSH
19329: LD_VAR 0 1
19333: ARRAY
19334: PUSH
19335: LD_INT 3
19337: ARRAY
19338: PPUSH
19339: LD_INT 2
19341: PPUSH
19342: LD_VAR 0 5
19346: PPUSH
19347: CALL_OW 468
19351: GO 19383
// SetArtifactUse ( 7 , artifactsButtons [ i ] [ 3 ] , art_gray , nearestLab ) ;
19353: LD_INT 7
19355: PPUSH
19356: LD_EXP 72
19360: PUSH
19361: LD_VAR 0 1
19365: ARRAY
19366: PUSH
19367: LD_INT 3
19369: ARRAY
19370: PPUSH
19371: LD_INT 1
19373: PPUSH
19374: LD_VAR 0 5
19378: PPUSH
19379: CALL_OW 468
// end else
19383: GO 19486
// begin if BuildingStatus ( nearestLab ) = bs_idle and artifactsReady [ i ] then
19385: LD_VAR 0 5
19389: PPUSH
19390: CALL_OW 461
19394: PUSH
19395: LD_INT 2
19397: EQUAL
19398: PUSH
19399: LD_EXP 73
19403: PUSH
19404: LD_VAR 0 1
19408: ARRAY
19409: AND
19410: IFFALSE 19456
// SetArtifactUse ( 7 , artifactsButtons [ i ] [ 1 ] , artifactsButtons [ i ] [ 2 ] , nearestLab ) else
19412: LD_INT 7
19414: PPUSH
19415: LD_EXP 72
19419: PUSH
19420: LD_VAR 0 1
19424: ARRAY
19425: PUSH
19426: LD_INT 1
19428: ARRAY
19429: PPUSH
19430: LD_EXP 72
19434: PUSH
19435: LD_VAR 0 1
19439: ARRAY
19440: PUSH
19441: LD_INT 2
19443: ARRAY
19444: PPUSH
19445: LD_VAR 0 5
19449: PPUSH
19450: CALL_OW 468
19454: GO 19486
// SetArtifactUse ( 7 , artifactsButtons [ i ] [ 1 ] , art_gray , nearestLab ) end ;
19456: LD_INT 7
19458: PPUSH
19459: LD_EXP 72
19463: PUSH
19464: LD_VAR 0 1
19468: ARRAY
19469: PUSH
19470: LD_INT 1
19472: ARRAY
19473: PPUSH
19474: LD_INT 1
19476: PPUSH
19477: LD_VAR 0 5
19481: PPUSH
19482: CALL_OW 468
// end else
19486: GO 19563
// begin if not artifactsResearched [ i ] then
19488: LD_EXP 67
19492: PUSH
19493: LD_VAR 0 1
19497: ARRAY
19498: NOT
19499: IFFALSE 19533
// SetArtifactUse ( 7 , artifactsButtons [ i ] [ 3 ] , art_no , nearestLab ) else
19501: LD_INT 7
19503: PPUSH
19504: LD_EXP 72
19508: PUSH
19509: LD_VAR 0 1
19513: ARRAY
19514: PUSH
19515: LD_INT 3
19517: ARRAY
19518: PPUSH
19519: LD_INT 0
19521: PPUSH
19522: LD_VAR 0 5
19526: PPUSH
19527: CALL_OW 468
19531: GO 19563
// SetArtifactUse ( 7 , artifactsButtons [ i ] [ 1 ] , art_no , nearestLab ) ;
19533: LD_INT 7
19535: PPUSH
19536: LD_EXP 72
19540: PUSH
19541: LD_VAR 0 1
19545: ARRAY
19546: PUSH
19547: LD_INT 1
19549: ARRAY
19550: PPUSH
19551: LD_INT 0
19553: PPUSH
19554: LD_VAR 0 5
19558: PPUSH
19559: CALL_OW 468
// end ; end else
19563: GO 19702
// begin if not artifactsLabs [ i ] then
19565: LD_EXP 71
19569: PUSH
19570: LD_VAR 0 1
19574: ARRAY
19575: NOT
19576: IFFALSE 19580
// continue ;
19578: GO 18806
// SetArtifactUse ( 7 , artifactsButtons [ i ] [ 3 ] , art_no , artifactsLabs [ i ] ) ;
19580: LD_INT 7
19582: PPUSH
19583: LD_EXP 72
19587: PUSH
19588: LD_VAR 0 1
19592: ARRAY
19593: PUSH
19594: LD_INT 3
19596: ARRAY
19597: PPUSH
19598: LD_INT 0
19600: PPUSH
19601: LD_EXP 71
19605: PUSH
19606: LD_VAR 0 1
19610: ARRAY
19611: PPUSH
19612: CALL_OW 468
// SetArtifactUse ( 7 , artifactsButtons [ i ] [ 1 ] , art_no , artifactsLabs [ i ] ) ;
19616: LD_INT 7
19618: PPUSH
19619: LD_EXP 72
19623: PUSH
19624: LD_VAR 0 1
19628: ARRAY
19629: PUSH
19630: LD_INT 1
19632: ARRAY
19633: PPUSH
19634: LD_INT 0
19636: PPUSH
19637: LD_EXP 71
19641: PUSH
19642: LD_VAR 0 1
19646: ARRAY
19647: PPUSH
19648: CALL_OW 468
// if artifactsLabsWorking [ i ] then
19652: LD_EXP 68
19656: PUSH
19657: LD_VAR 0 1
19661: ARRAY
19662: IFFALSE 19702
// begin artifactsLabsWorking := Replace ( artifactsLabsWorking , i , false ) ;
19664: LD_ADDR_EXP 68
19668: PUSH
19669: LD_EXP 68
19673: PPUSH
19674: LD_VAR 0 1
19678: PPUSH
19679: LD_INT 0
19681: PPUSH
19682: CALL_OW 1
19686: ST_TO_ADDR
// ComCancel ( artifactsLabs [ i ] ) ;
19687: LD_EXP 71
19691: PUSH
19692: LD_VAR 0 1
19696: ARRAY
19697: PPUSH
19698: CALL_OW 127
// end ; end ; end ;
19702: GO 18806
19704: POP
19705: POP
// end ;
19706: PPOPN 5
19708: END
// on ArtifactUsed ( side , icon , x , y ) do var i , lab , time , list , un ;
19709: LD_INT 0
19711: PPUSH
19712: PPUSH
19713: PPUSH
19714: PPUSH
19715: PPUSH
// begin if icon = artifactsButtons [ 1 ] [ 3 ] then
19716: LD_VAR 0 2
19720: PUSH
19721: LD_EXP 72
19725: PUSH
19726: LD_INT 1
19728: ARRAY
19729: PUSH
19730: LD_INT 3
19732: ARRAY
19733: EQUAL
19734: IFFALSE 19857
// begin lab := artifactsLabs [ 1 ] ;
19736: LD_ADDR_VAR 0 6
19740: PUSH
19741: LD_EXP 71
19745: PUSH
19746: LD_INT 1
19748: ARRAY
19749: ST_TO_ADDR
// if not lab then
19750: LD_VAR 0 6
19754: NOT
19755: IFFALSE 19759
// exit ;
19757: GO 20837
// SetSpecResearch ( lab , artifactsResDifficulty [ 1 ] , true ) ;
19759: LD_VAR 0 6
19763: PPUSH
19764: LD_EXP 69
19768: PUSH
19769: LD_INT 1
19771: ARRAY
19772: PPUSH
19773: LD_INT 1
19775: PPUSH
19776: CALL_OW 486
// if artifactsResProgress [ 1 ] then
19780: LD_EXP 70
19784: PUSH
19785: LD_INT 1
19787: ARRAY
19788: IFFALSE 19808
// SetWorkingProgress ( lab , artifactsResProgress [ 1 ] ) ;
19790: LD_VAR 0 6
19794: PPUSH
19795: LD_EXP 70
19799: PUSH
19800: LD_INT 1
19802: ARRAY
19803: PPUSH
19804: CALL_OW 329
// artifactsLabsWorking := Replace ( artifactsLabsWorking , 1 , 1 ) ;
19808: LD_ADDR_EXP 68
19812: PUSH
19813: LD_EXP 68
19817: PPUSH
19818: LD_INT 1
19820: PPUSH
19821: LD_INT 1
19823: PPUSH
19824: CALL_OW 1
19828: ST_TO_ADDR
// SetArtifactUse ( 7 , artifactsButtons [ 1 ] [ 3 ] , art_no , lab ) ;
19829: LD_INT 7
19831: PPUSH
19832: LD_EXP 72
19836: PUSH
19837: LD_INT 1
19839: ARRAY
19840: PUSH
19841: LD_INT 3
19843: ARRAY
19844: PPUSH
19845: LD_INT 0
19847: PPUSH
19848: LD_VAR 0 6
19852: PPUSH
19853: CALL_OW 468
// end ; if icon = artifactsButtons [ 2 ] [ 3 ] then
19857: LD_VAR 0 2
19861: PUSH
19862: LD_EXP 72
19866: PUSH
19867: LD_INT 2
19869: ARRAY
19870: PUSH
19871: LD_INT 3
19873: ARRAY
19874: EQUAL
19875: IFFALSE 19998
// begin lab := artifactsLabs [ 2 ] ;
19877: LD_ADDR_VAR 0 6
19881: PUSH
19882: LD_EXP 71
19886: PUSH
19887: LD_INT 2
19889: ARRAY
19890: ST_TO_ADDR
// if not lab then
19891: LD_VAR 0 6
19895: NOT
19896: IFFALSE 19900
// exit ;
19898: GO 20837
// SetSpecResearch ( lab , artifactsResDifficulty [ 2 ] , true ) ;
19900: LD_VAR 0 6
19904: PPUSH
19905: LD_EXP 69
19909: PUSH
19910: LD_INT 2
19912: ARRAY
19913: PPUSH
19914: LD_INT 1
19916: PPUSH
19917: CALL_OW 486
// if artifactsResProgress [ 2 ] then
19921: LD_EXP 70
19925: PUSH
19926: LD_INT 2
19928: ARRAY
19929: IFFALSE 19949
// SetWorkingProgress ( lab , artifactsResProgress [ 2 ] ) ;
19931: LD_VAR 0 6
19935: PPUSH
19936: LD_EXP 70
19940: PUSH
19941: LD_INT 2
19943: ARRAY
19944: PPUSH
19945: CALL_OW 329
// artifactsLabsWorking := Replace ( artifactsLabsWorking , 2 , 1 ) ;
19949: LD_ADDR_EXP 68
19953: PUSH
19954: LD_EXP 68
19958: PPUSH
19959: LD_INT 2
19961: PPUSH
19962: LD_INT 1
19964: PPUSH
19965: CALL_OW 1
19969: ST_TO_ADDR
// SetArtifactUse ( 7 , artifactsButtons [ 2 ] [ 3 ] , art_no , lab ) ;
19970: LD_INT 7
19972: PPUSH
19973: LD_EXP 72
19977: PUSH
19978: LD_INT 2
19980: ARRAY
19981: PUSH
19982: LD_INT 3
19984: ARRAY
19985: PPUSH
19986: LD_INT 0
19988: PPUSH
19989: LD_VAR 0 6
19993: PPUSH
19994: CALL_OW 468
// end ; if icon = artifactsButtons [ 3 ] [ 3 ] then
19998: LD_VAR 0 2
20002: PUSH
20003: LD_EXP 72
20007: PUSH
20008: LD_INT 3
20010: ARRAY
20011: PUSH
20012: LD_INT 3
20014: ARRAY
20015: EQUAL
20016: IFFALSE 20139
// begin lab := artifactsLabs [ 3 ] ;
20018: LD_ADDR_VAR 0 6
20022: PUSH
20023: LD_EXP 71
20027: PUSH
20028: LD_INT 3
20030: ARRAY
20031: ST_TO_ADDR
// if not lab then
20032: LD_VAR 0 6
20036: NOT
20037: IFFALSE 20041
// exit ;
20039: GO 20837
// SetSpecResearch ( lab , artifactsResDifficulty [ 3 ] , true ) ;
20041: LD_VAR 0 6
20045: PPUSH
20046: LD_EXP 69
20050: PUSH
20051: LD_INT 3
20053: ARRAY
20054: PPUSH
20055: LD_INT 1
20057: PPUSH
20058: CALL_OW 486
// if artifactsResProgress [ 3 ] then
20062: LD_EXP 70
20066: PUSH
20067: LD_INT 3
20069: ARRAY
20070: IFFALSE 20090
// SetWorkingProgress ( lab , artifactsResProgress [ 3 ] ) ;
20072: LD_VAR 0 6
20076: PPUSH
20077: LD_EXP 70
20081: PUSH
20082: LD_INT 3
20084: ARRAY
20085: PPUSH
20086: CALL_OW 329
// artifactsLabsWorking := Replace ( artifactsLabsWorking , 3 , 1 ) ;
20090: LD_ADDR_EXP 68
20094: PUSH
20095: LD_EXP 68
20099: PPUSH
20100: LD_INT 3
20102: PPUSH
20103: LD_INT 1
20105: PPUSH
20106: CALL_OW 1
20110: ST_TO_ADDR
// SetArtifactUse ( 7 , artifactsButtons [ 3 ] [ 3 ] , art_no , lab ) ;
20111: LD_INT 7
20113: PPUSH
20114: LD_EXP 72
20118: PUSH
20119: LD_INT 3
20121: ARRAY
20122: PUSH
20123: LD_INT 3
20125: ARRAY
20126: PPUSH
20127: LD_INT 0
20129: PPUSH
20130: LD_VAR 0 6
20134: PPUSH
20135: CALL_OW 468
// end ; if icon = artifactsButtons [ 1 ] [ 1 ] then
20139: LD_VAR 0 2
20143: PUSH
20144: LD_EXP 72
20148: PUSH
20149: LD_INT 1
20151: ARRAY
20152: PUSH
20153: LD_INT 1
20155: ARRAY
20156: EQUAL
20157: IFFALSE 20315
// begin lab := artifactsLabs [ 1 ] ;
20159: LD_ADDR_VAR 0 6
20163: PUSH
20164: LD_EXP 71
20168: PUSH
20169: LD_INT 1
20171: ARRAY
20172: ST_TO_ADDR
// if GetBaseMaterials ( GetBase ( lab ) ) [ 3 ] < artifactsSibCost [ 1 ] then
20173: LD_VAR 0 6
20177: PPUSH
20178: CALL_OW 274
20182: PPUSH
20183: CALL 88993 0 1
20187: PUSH
20188: LD_INT 3
20190: ARRAY
20191: PUSH
20192: LD_EXP 66
20196: PUSH
20197: LD_INT 1
20199: ARRAY
20200: LESS
20201: IFFALSE 20215
// begin HintSpec ( ArtifactCost , 2 ) ;
20203: LD_STRING ArtifactCost
20205: PPUSH
20206: LD_INT 2
20208: PPUSH
20209: CALL_OW 338
// exit ;
20213: GO 20837
// end ; artifactsReady := Replace ( artifactsReady , 1 , false ) ;
20215: LD_ADDR_EXP 73
20219: PUSH
20220: LD_EXP 73
20224: PPUSH
20225: LD_INT 1
20227: PPUSH
20228: LD_INT 0
20230: PPUSH
20231: CALL_OW 1
20235: ST_TO_ADDR
// PlaceSeeing ( x , y , 7 , - 12 ) ;
20236: LD_VAR 0 3
20240: PPUSH
20241: LD_VAR 0 4
20245: PPUSH
20246: LD_INT 7
20248: PPUSH
20249: LD_INT 12
20251: NEG
20252: PPUSH
20253: CALL_OW 330
// wait ( 0 0$30 ) ;
20257: LD_INT 1050
20259: PPUSH
20260: CALL_OW 67
// RemoveSeeing ( x , y , 7 ) ;
20264: LD_VAR 0 3
20268: PPUSH
20269: LD_VAR 0 4
20273: PPUSH
20274: LD_INT 7
20276: PPUSH
20277: CALL_OW 331
// wait ( artifactsRecharge [ 1 ] ) ;
20281: LD_EXP 65
20285: PUSH
20286: LD_INT 1
20288: ARRAY
20289: PPUSH
20290: CALL_OW 67
// artifactsReady := Replace ( artifactsReady , 1 , true ) ;
20294: LD_ADDR_EXP 73
20298: PUSH
20299: LD_EXP 73
20303: PPUSH
20304: LD_INT 1
20306: PPUSH
20307: LD_INT 1
20309: PPUSH
20310: CALL_OW 1
20314: ST_TO_ADDR
// end ; if icon = artifactsButtons [ 2 ] [ 1 ] then
20315: LD_VAR 0 2
20319: PUSH
20320: LD_EXP 72
20324: PUSH
20325: LD_INT 2
20327: ARRAY
20328: PUSH
20329: LD_INT 1
20331: ARRAY
20332: EQUAL
20333: IFFALSE 20570
// begin lab := artifactsLabs [ 2 ] ;
20335: LD_ADDR_VAR 0 6
20339: PUSH
20340: LD_EXP 71
20344: PUSH
20345: LD_INT 2
20347: ARRAY
20348: ST_TO_ADDR
// if not x in FilterAllUnits ( [ [ f_enemy , 7 ] , [ f_or , [ f_engine , engine_siberite ] , [ f_btype , b_siberite_power ] , [ f_btype , b_siberite_mine ] , [ f_bweapon , ru_time_lapser ] , [ f_weapon , ru_time_lapser ] , [ f_btype , b_ext_siberium ] ] ] ) then
20349: LD_VAR 0 3
20353: PUSH
20354: LD_INT 81
20356: PUSH
20357: LD_INT 7
20359: PUSH
20360: EMPTY
20361: LIST
20362: LIST
20363: PUSH
20364: LD_INT 2
20366: PUSH
20367: LD_INT 32
20369: PUSH
20370: LD_INT 3
20372: PUSH
20373: EMPTY
20374: LIST
20375: LIST
20376: PUSH
20377: LD_INT 30
20379: PUSH
20380: LD_INT 28
20382: PUSH
20383: EMPTY
20384: LIST
20385: LIST
20386: PUSH
20387: LD_INT 30
20389: PUSH
20390: LD_INT 30
20392: PUSH
20393: EMPTY
20394: LIST
20395: LIST
20396: PUSH
20397: LD_INT 35
20399: PUSH
20400: LD_INT 49
20402: PUSH
20403: EMPTY
20404: LIST
20405: LIST
20406: PUSH
20407: LD_INT 34
20409: PUSH
20410: LD_INT 49
20412: PUSH
20413: EMPTY
20414: LIST
20415: LIST
20416: PUSH
20417: LD_INT 30
20419: PUSH
20420: LD_INT 21
20422: PUSH
20423: EMPTY
20424: LIST
20425: LIST
20426: PUSH
20427: EMPTY
20428: LIST
20429: LIST
20430: LIST
20431: LIST
20432: LIST
20433: LIST
20434: LIST
20435: PUSH
20436: EMPTY
20437: LIST
20438: LIST
20439: PPUSH
20440: CALL_OW 69
20444: IN
20445: NOT
20446: IFFALSE 20450
// exit ;
20448: GO 20837
// if GetBaseMaterials ( GetBase ( lab ) ) [ 3 ] < artifactsSibCost [ 2 ] then
20450: LD_VAR 0 6
20454: PPUSH
20455: CALL_OW 274
20459: PPUSH
20460: CALL 88993 0 1
20464: PUSH
20465: LD_INT 3
20467: ARRAY
20468: PUSH
20469: LD_EXP 66
20473: PUSH
20474: LD_INT 2
20476: ARRAY
20477: LESS
20478: IFFALSE 20492
// begin HintSpec ( ArtifactCost , 2 ) ;
20480: LD_STRING ArtifactCost
20482: PPUSH
20483: LD_INT 2
20485: PPUSH
20486: CALL_OW 338
// exit ;
20490: GO 20837
// end ; artifactsReady := Replace ( artifactsReady , 2 , false ) ;
20492: LD_ADDR_EXP 73
20496: PUSH
20497: LD_EXP 73
20501: PPUSH
20502: LD_INT 2
20504: PPUSH
20505: LD_INT 0
20507: PPUSH
20508: CALL_OW 1
20512: ST_TO_ADDR
// KillUnit ( x ) ;
20513: LD_VAR 0 3
20517: PPUSH
20518: CALL_OW 66
// artifactDestroyCounter := artifactDestroyCounter + 1 ;
20522: LD_ADDR_EXP 16
20526: PUSH
20527: LD_EXP 16
20531: PUSH
20532: LD_INT 1
20534: PLUS
20535: ST_TO_ADDR
// wait ( artifactsRecharge [ 2 ] ) ;
20536: LD_EXP 65
20540: PUSH
20541: LD_INT 2
20543: ARRAY
20544: PPUSH
20545: CALL_OW 67
// artifactsReady := Replace ( artifactsReady , 2 , true ) ;
20549: LD_ADDR_EXP 73
20553: PUSH
20554: LD_EXP 73
20558: PPUSH
20559: LD_INT 2
20561: PPUSH
20562: LD_INT 1
20564: PPUSH
20565: CALL_OW 1
20569: ST_TO_ADDR
// end ; if icon = artifactsButtons [ 3 ] [ 1 ] then
20570: LD_VAR 0 2
20574: PUSH
20575: LD_EXP 72
20579: PUSH
20580: LD_INT 3
20582: ARRAY
20583: PUSH
20584: LD_INT 1
20586: ARRAY
20587: EQUAL
20588: IFFALSE 20837
// begin lab := artifactsLabs [ 3 ] ;
20590: LD_ADDR_VAR 0 6
20594: PUSH
20595: LD_EXP 71
20599: PUSH
20600: LD_INT 3
20602: ARRAY
20603: ST_TO_ADDR
// if GetBaseMaterials ( GetBase ( lab ) ) [ 3 ] < artifactsSibCost [ 3 ] then
20604: LD_VAR 0 6
20608: PPUSH
20609: CALL_OW 274
20613: PPUSH
20614: CALL 88993 0 1
20618: PUSH
20619: LD_INT 3
20621: ARRAY
20622: PUSH
20623: LD_EXP 66
20627: PUSH
20628: LD_INT 3
20630: ARRAY
20631: LESS
20632: IFFALSE 20646
// begin HintSpec ( ArtifactCost , 2 ) ;
20634: LD_STRING ArtifactCost
20636: PPUSH
20637: LD_INT 2
20639: PPUSH
20640: CALL_OW 338
// exit ;
20644: GO 20837
// end ; SetAreaMapShow ( teleportArea , 1 ) ;
20646: LD_INT 37
20648: PPUSH
20649: LD_INT 1
20651: PPUSH
20652: CALL_OW 424
// time := 0 0$30 ;
20656: LD_ADDR_VAR 0 7
20660: PUSH
20661: LD_INT 1050
20663: ST_TO_ADDR
// artifactsReady := Replace ( artifactsReady , 3 , false ) ;
20664: LD_ADDR_EXP 73
20668: PUSH
20669: LD_EXP 73
20673: PPUSH
20674: LD_INT 3
20676: PPUSH
20677: LD_INT 0
20679: PPUSH
20680: CALL_OW 1
20684: ST_TO_ADDR
// repeat display_strings := [ #Am15a-1 , time ] ;
20685: LD_ADDR_OWVAR 47
20689: PUSH
20690: LD_STRING #Am15a-1
20692: PUSH
20693: LD_VAR 0 7
20697: PUSH
20698: EMPTY
20699: LIST
20700: LIST
20701: ST_TO_ADDR
// wait ( 0 0$1 ) ;
20702: LD_INT 35
20704: PPUSH
20705: CALL_OW 67
// time := time - 0 0$1 ;
20709: LD_ADDR_VAR 0 7
20713: PUSH
20714: LD_VAR 0 7
20718: PUSH
20719: LD_INT 35
20721: MINUS
20722: ST_TO_ADDR
// until time = 0 0$00 ;
20723: LD_VAR 0 7
20727: PUSH
20728: LD_INT 0
20730: EQUAL
20731: IFFALSE 20685
// display_strings :=  ;
20733: LD_ADDR_OWVAR 47
20737: PUSH
20738: LD_STRING 
20740: ST_TO_ADDR
// SetAreaMapShow ( teleportArea , 0 ) ;
20741: LD_INT 37
20743: PPUSH
20744: LD_INT 0
20746: PPUSH
20747: CALL_OW 424
// list := FilterUnitsInArea ( teleportArea , [ f_not , [ f_type , unit_building ] ] ) ;
20751: LD_ADDR_VAR 0 8
20755: PUSH
20756: LD_INT 37
20758: PPUSH
20759: LD_INT 3
20761: PUSH
20762: LD_INT 21
20764: PUSH
20765: LD_INT 3
20767: PUSH
20768: EMPTY
20769: LIST
20770: LIST
20771: PUSH
20772: EMPTY
20773: LIST
20774: LIST
20775: PPUSH
20776: CALL_OW 70
20780: ST_TO_ADDR
// CenterOnXY ( x , y ) ;
20781: LD_VAR 0 3
20785: PPUSH
20786: LD_VAR 0 4
20790: PPUSH
20791: CALL_OW 84
// for un in list do
20795: LD_ADDR_VAR 0 9
20799: PUSH
20800: LD_VAR 0 8
20804: PUSH
20805: FOR_IN
20806: IFFALSE 20835
// TeleportUnit ( un , x , y , 12 , true ) ;
20808: LD_VAR 0 9
20812: PPUSH
20813: LD_VAR 0 3
20817: PPUSH
20818: LD_VAR 0 4
20822: PPUSH
20823: LD_INT 12
20825: PPUSH
20826: LD_INT 1
20828: PPUSH
20829: CALL_OW 483
20833: GO 20805
20835: POP
20836: POP
// end ; end ;
20837: PPOPN 9
20839: END
// on SpecResearchCancel ( lab , progress ) do var i , labNum ;
20840: LD_INT 0
20842: PPUSH
20843: PPUSH
// begin labNum := 0 ;
20844: LD_ADDR_VAR 0 4
20848: PUSH
20849: LD_INT 0
20851: ST_TO_ADDR
// for i = 1 to artifactsLabs do
20852: LD_ADDR_VAR 0 3
20856: PUSH
20857: DOUBLE
20858: LD_INT 1
20860: DEC
20861: ST_TO_ADDR
20862: LD_EXP 71
20866: PUSH
20867: FOR_TO
20868: IFFALSE 20902
// if artifactsLabs [ i ] = lab then
20870: LD_EXP 71
20874: PUSH
20875: LD_VAR 0 3
20879: ARRAY
20880: PUSH
20881: LD_VAR 0 1
20885: EQUAL
20886: IFFALSE 20900
// begin labNum := i ;
20888: LD_ADDR_VAR 0 4
20892: PUSH
20893: LD_VAR 0 3
20897: ST_TO_ADDR
// break ;
20898: GO 20902
// end ;
20900: GO 20867
20902: POP
20903: POP
// if not labNum then
20904: LD_VAR 0 4
20908: NOT
20909: IFFALSE 20913
// exit ;
20911: GO 20991
// SetArtifactUse ( 7 , artifactsButtons [ labNum ] [ 3 ] , art_instant , lab ) ;
20913: LD_INT 7
20915: PPUSH
20916: LD_EXP 72
20920: PUSH
20921: LD_VAR 0 4
20925: ARRAY
20926: PUSH
20927: LD_INT 3
20929: ARRAY
20930: PPUSH
20931: LD_INT 2
20933: PPUSH
20934: LD_VAR 0 1
20938: PPUSH
20939: CALL_OW 468
// artifactsResProgress := Replace ( artifactsResProgress , labNum , progress ) ;
20943: LD_ADDR_EXP 70
20947: PUSH
20948: LD_EXP 70
20952: PPUSH
20953: LD_VAR 0 4
20957: PPUSH
20958: LD_VAR 0 2
20962: PPUSH
20963: CALL_OW 1
20967: ST_TO_ADDR
// artifactsLabsWorking := Replace ( artifactsLabsWorking , labNum , 0 ) ;
20968: LD_ADDR_EXP 68
20972: PUSH
20973: LD_EXP 68
20977: PPUSH
20978: LD_VAR 0 4
20982: PPUSH
20983: LD_INT 0
20985: PPUSH
20986: CALL_OW 1
20990: ST_TO_ADDR
// end ;
20991: PPOPN 4
20993: END
// on SpecResearchComplete ( lab ) do var i , labNum ;
20994: LD_INT 0
20996: PPUSH
20997: PPUSH
// begin labNum := 0 ;
20998: LD_ADDR_VAR 0 3
21002: PUSH
21003: LD_INT 0
21005: ST_TO_ADDR
// for i = 1 to artifactsLabs do
21006: LD_ADDR_VAR 0 2
21010: PUSH
21011: DOUBLE
21012: LD_INT 1
21014: DEC
21015: ST_TO_ADDR
21016: LD_EXP 71
21020: PUSH
21021: FOR_TO
21022: IFFALSE 21056
// if artifactsLabs [ i ] = lab then
21024: LD_EXP 71
21028: PUSH
21029: LD_VAR 0 2
21033: ARRAY
21034: PUSH
21035: LD_VAR 0 1
21039: EQUAL
21040: IFFALSE 21054
// begin labNum := i ;
21042: LD_ADDR_VAR 0 3
21046: PUSH
21047: LD_VAR 0 2
21051: ST_TO_ADDR
// break ;
21052: GO 21056
// end ;
21054: GO 21021
21056: POP
21057: POP
// if not labNum then
21058: LD_VAR 0 3
21062: NOT
21063: IFFALSE 21067
// exit ;
21065: GO 21229
// SetArtifactUse ( 7 , artifactsButtons [ labNum ] [ 3 ] , art_no , lab ) ;
21067: LD_INT 7
21069: PPUSH
21070: LD_EXP 72
21074: PUSH
21075: LD_VAR 0 3
21079: ARRAY
21080: PUSH
21081: LD_INT 3
21083: ARRAY
21084: PPUSH
21085: LD_INT 0
21087: PPUSH
21088: LD_VAR 0 1
21092: PPUSH
21093: CALL_OW 468
// artifactsResearched := Replace ( artifactsResearched , labNum , true ) ;
21097: LD_ADDR_EXP 67
21101: PUSH
21102: LD_EXP 67
21106: PPUSH
21107: LD_VAR 0 3
21111: PPUSH
21112: LD_INT 1
21114: PPUSH
21115: CALL_OW 1
21119: ST_TO_ADDR
// artifactsReady := Replace ( artifactsReady , labNum , true ) ;
21120: LD_ADDR_EXP 73
21124: PUSH
21125: LD_EXP 73
21129: PPUSH
21130: LD_VAR 0 3
21134: PPUSH
21135: LD_INT 1
21137: PPUSH
21138: CALL_OW 1
21142: ST_TO_ADDR
// artifactsLabsWorking := Replace ( artifactsLabsWorking , labNum , false ) ;
21143: LD_ADDR_EXP 68
21147: PUSH
21148: LD_EXP 68
21152: PPUSH
21153: LD_VAR 0 3
21157: PPUSH
21158: LD_INT 0
21160: PPUSH
21161: CALL_OW 1
21165: ST_TO_ADDR
// case labNum of 1 :
21166: LD_VAR 0 3
21170: PUSH
21171: LD_INT 1
21173: DOUBLE
21174: EQUAL
21175: IFTRUE 21179
21177: GO 21190
21179: POP
// artifactIResearched := true ; 2 :
21180: LD_ADDR_EXP 12
21184: PUSH
21185: LD_INT 1
21187: ST_TO_ADDR
21188: GO 21229
21190: LD_INT 2
21192: DOUBLE
21193: EQUAL
21194: IFTRUE 21198
21196: GO 21209
21198: POP
// artifactIIResearched := true ; 3 :
21199: LD_ADDR_EXP 13
21203: PUSH
21204: LD_INT 1
21206: ST_TO_ADDR
21207: GO 21229
21209: LD_INT 3
21211: DOUBLE
21212: EQUAL
21213: IFTRUE 21217
21215: GO 21228
21217: POP
// artifactIIIResearched := true ; end ;
21218: LD_ADDR_EXP 14
21222: PUSH
21223: LD_INT 1
21225: ST_TO_ADDR
21226: GO 21229
21228: POP
// end ; end_of_file
21229: PPOPN 3
21231: END
// export ru_radar , ru_big_cargo_bay , us_hack , us_artillery , ar_bio_bomb , ar_mortar , ar_crane , ar_miner ; export tech_Artillery , tech_RadMat , tech_BasicTools , tech_Cargo , tech_Track , tech_Crane , tech_Bulldozer , tech_Hovercraft , tech_MultiBarrels ; export class_mastodont , class_horse ; export function InitGlobalVariables ; begin
21232: LD_INT 0
21234: PPUSH
// ar_miner := 81 ;
21235: LD_ADDR_EXP 81
21239: PUSH
21240: LD_INT 81
21242: ST_TO_ADDR
// ar_crane := 88 ;
21243: LD_ADDR_EXP 80
21247: PUSH
21248: LD_INT 88
21250: ST_TO_ADDR
// ru_big_cargo_bay := 89 ;
21251: LD_ADDR_EXP 75
21255: PUSH
21256: LD_INT 89
21258: ST_TO_ADDR
// us_hack := 99 ;
21259: LD_ADDR_EXP 76
21263: PUSH
21264: LD_INT 99
21266: ST_TO_ADDR
// us_artillery := 97 ;
21267: LD_ADDR_EXP 77
21271: PUSH
21272: LD_INT 97
21274: ST_TO_ADDR
// ar_bio_bomb := 91 ;
21275: LD_ADDR_EXP 78
21279: PUSH
21280: LD_INT 91
21282: ST_TO_ADDR
// ar_mortar := 92 ;
21283: LD_ADDR_EXP 79
21287: PUSH
21288: LD_INT 92
21290: ST_TO_ADDR
// ru_radar := 98 ;
21291: LD_ADDR_EXP 74
21295: PUSH
21296: LD_INT 98
21298: ST_TO_ADDR
// tech_Artillery := 80 ;
21299: LD_ADDR_EXP 82
21303: PUSH
21304: LD_INT 80
21306: ST_TO_ADDR
// tech_RadMat := 81 ;
21307: LD_ADDR_EXP 83
21311: PUSH
21312: LD_INT 81
21314: ST_TO_ADDR
// tech_BasicTools := 82 ;
21315: LD_ADDR_EXP 84
21319: PUSH
21320: LD_INT 82
21322: ST_TO_ADDR
// tech_Cargo := 83 ;
21323: LD_ADDR_EXP 85
21327: PUSH
21328: LD_INT 83
21330: ST_TO_ADDR
// tech_Track := 84 ;
21331: LD_ADDR_EXP 86
21335: PUSH
21336: LD_INT 84
21338: ST_TO_ADDR
// tech_Crane := 85 ;
21339: LD_ADDR_EXP 87
21343: PUSH
21344: LD_INT 85
21346: ST_TO_ADDR
// tech_Bulldozer := 86 ;
21347: LD_ADDR_EXP 88
21351: PUSH
21352: LD_INT 86
21354: ST_TO_ADDR
// tech_Hovercraft := 87 ;
21355: LD_ADDR_EXP 89
21359: PUSH
21360: LD_INT 87
21362: ST_TO_ADDR
// tech_MultiBarrels := 88 ;
21363: LD_ADDR_EXP 90
21367: PUSH
21368: LD_INT 88
21370: ST_TO_ADDR
// class_mastodont := 31 ;
21371: LD_ADDR_EXP 91
21375: PUSH
21376: LD_INT 31
21378: ST_TO_ADDR
// class_horse := 21 ;
21379: LD_ADDR_EXP 92
21383: PUSH
21384: LD_INT 21
21386: ST_TO_ADDR
// end ;
21387: LD_VAR 0 1
21391: RET
// every 1 do
21392: GO 21394
21394: DISABLE
// InitGlobalVariables ; end_of_file
21395: CALL 21232 0 0
21399: END
// export skirmish , debug_mc ; export mc_bases , mc_building_need_repair , mc_building_repairs , mc_need_heal , mc_healers , mc_build_list , mc_builders , mc_construct_list , mc_turret_list , mc_empty_turret_list , mc_busy_turret_list , mc_defender_limit , mc_repair_vehicle , mc_mines , mc_miners , mc_minefields , mc_crates , mc_crates_collector , mc_crates_area , mc_vehicles , mc_attack , mc_produce , mc_defender , mc_scan , mc_parking , mc_scan_area , mc_sides , mc_tech , mc_can_tame , mc_ape , mc_ape_in_lab , mc_taming , mc_build_upgrade , mc_lab , mc_lab_upgrade , mc_teleport_exit , mc_teleport_exit_set , mc_deposits_xy , mc_deposits_finder , mc_allowed_tower_weapons , mc_remote_driver , mc_class , mc_class_case_use , mc_is_defending ; export function InitMacro ; var i ; begin
21400: LD_INT 0
21402: PPUSH
21403: PPUSH
// skirmish := false ;
21404: LD_ADDR_EXP 93
21408: PUSH
21409: LD_INT 0
21411: ST_TO_ADDR
// debug_mc := false ;
21412: LD_ADDR_EXP 94
21416: PUSH
21417: LD_INT 0
21419: ST_TO_ADDR
// mc_bases := [ ] ;
21420: LD_ADDR_EXP 95
21424: PUSH
21425: EMPTY
21426: ST_TO_ADDR
// mc_sides := [ ] ;
21427: LD_ADDR_EXP 121
21431: PUSH
21432: EMPTY
21433: ST_TO_ADDR
// mc_building_need_repair := [ ] ;
21434: LD_ADDR_EXP 96
21438: PUSH
21439: EMPTY
21440: ST_TO_ADDR
// mc_building_repairs := [ ] ;
21441: LD_ADDR_EXP 97
21445: PUSH
21446: EMPTY
21447: ST_TO_ADDR
// mc_need_heal := [ ] ;
21448: LD_ADDR_EXP 98
21452: PUSH
21453: EMPTY
21454: ST_TO_ADDR
// mc_healers := [ ] ;
21455: LD_ADDR_EXP 99
21459: PUSH
21460: EMPTY
21461: ST_TO_ADDR
// mc_build_list := [ ] ;
21462: LD_ADDR_EXP 100
21466: PUSH
21467: EMPTY
21468: ST_TO_ADDR
// mc_build_upgrade := [ ] ;
21469: LD_ADDR_EXP 127
21473: PUSH
21474: EMPTY
21475: ST_TO_ADDR
// mc_builders := [ ] ;
21476: LD_ADDR_EXP 101
21480: PUSH
21481: EMPTY
21482: ST_TO_ADDR
// mc_construct_list := [ ] ;
21483: LD_ADDR_EXP 102
21487: PUSH
21488: EMPTY
21489: ST_TO_ADDR
// mc_turret_list := [ ] ;
21490: LD_ADDR_EXP 103
21494: PUSH
21495: EMPTY
21496: ST_TO_ADDR
// mc_empty_turret_list := [ ] ;
21497: LD_ADDR_EXP 104
21501: PUSH
21502: EMPTY
21503: ST_TO_ADDR
// mc_miners := [ ] ;
21504: LD_ADDR_EXP 109
21508: PUSH
21509: EMPTY
21510: ST_TO_ADDR
// mc_mines := [ ] ;
21511: LD_ADDR_EXP 108
21515: PUSH
21516: EMPTY
21517: ST_TO_ADDR
// mc_minefields := [ ] ;
21518: LD_ADDR_EXP 110
21522: PUSH
21523: EMPTY
21524: ST_TO_ADDR
// mc_crates := [ ] ;
21525: LD_ADDR_EXP 111
21529: PUSH
21530: EMPTY
21531: ST_TO_ADDR
// mc_crates_collector := [ ] ;
21532: LD_ADDR_EXP 112
21536: PUSH
21537: EMPTY
21538: ST_TO_ADDR
// mc_crates_area := [ ] ;
21539: LD_ADDR_EXP 113
21543: PUSH
21544: EMPTY
21545: ST_TO_ADDR
// mc_vehicles := [ ] ;
21546: LD_ADDR_EXP 114
21550: PUSH
21551: EMPTY
21552: ST_TO_ADDR
// mc_attack := [ ] ;
21553: LD_ADDR_EXP 115
21557: PUSH
21558: EMPTY
21559: ST_TO_ADDR
// mc_produce := [ ] ;
21560: LD_ADDR_EXP 116
21564: PUSH
21565: EMPTY
21566: ST_TO_ADDR
// mc_defender := [ ] ;
21567: LD_ADDR_EXP 117
21571: PUSH
21572: EMPTY
21573: ST_TO_ADDR
// mc_parking := [ ] ;
21574: LD_ADDR_EXP 119
21578: PUSH
21579: EMPTY
21580: ST_TO_ADDR
// mc_busy_turret_list := [ ] ;
21581: LD_ADDR_EXP 105
21585: PUSH
21586: EMPTY
21587: ST_TO_ADDR
// mc_repair_vehicle := [ ] ;
21588: LD_ADDR_EXP 107
21592: PUSH
21593: EMPTY
21594: ST_TO_ADDR
// mc_scan := [ ] ;
21595: LD_ADDR_EXP 118
21599: PUSH
21600: EMPTY
21601: ST_TO_ADDR
// mc_scan_area := [ ] ;
21602: LD_ADDR_EXP 120
21606: PUSH
21607: EMPTY
21608: ST_TO_ADDR
// mc_tech := [ ] ;
21609: LD_ADDR_EXP 122
21613: PUSH
21614: EMPTY
21615: ST_TO_ADDR
// mc_class := [ ] ;
21616: LD_ADDR_EXP 136
21620: PUSH
21621: EMPTY
21622: ST_TO_ADDR
// mc_class_case_use := [ ] ;
21623: LD_ADDR_EXP 137
21627: PUSH
21628: EMPTY
21629: ST_TO_ADDR
// mc_is_defending := [ ] ;
21630: LD_ADDR_EXP 138
21634: PUSH
21635: EMPTY
21636: ST_TO_ADDR
// end ;
21637: LD_VAR 0 1
21641: RET
// export function MC_Kill ( base ) ; begin
21642: LD_INT 0
21644: PPUSH
// mc_bases := Replace ( mc_bases , base , [ ] ) ;
21645: LD_ADDR_EXP 95
21649: PUSH
21650: LD_EXP 95
21654: PPUSH
21655: LD_VAR 0 1
21659: PPUSH
21660: EMPTY
21661: PPUSH
21662: CALL_OW 1
21666: ST_TO_ADDR
// mc_building_need_repair := Replace ( mc_building_need_repair , base , [ ] ) ;
21667: LD_ADDR_EXP 96
21671: PUSH
21672: LD_EXP 96
21676: PPUSH
21677: LD_VAR 0 1
21681: PPUSH
21682: EMPTY
21683: PPUSH
21684: CALL_OW 1
21688: ST_TO_ADDR
// mc_building_repairs := Replace ( mc_building_repairs , base , [ ] ) ;
21689: LD_ADDR_EXP 97
21693: PUSH
21694: LD_EXP 97
21698: PPUSH
21699: LD_VAR 0 1
21703: PPUSH
21704: EMPTY
21705: PPUSH
21706: CALL_OW 1
21710: ST_TO_ADDR
// mc_need_heal := Replace ( mc_need_heal , base , [ ] ) ;
21711: LD_ADDR_EXP 98
21715: PUSH
21716: LD_EXP 98
21720: PPUSH
21721: LD_VAR 0 1
21725: PPUSH
21726: EMPTY
21727: PPUSH
21728: CALL_OW 1
21732: ST_TO_ADDR
// mc_healers := Replace ( mc_healers , base , [ ] ) ;
21733: LD_ADDR_EXP 99
21737: PUSH
21738: LD_EXP 99
21742: PPUSH
21743: LD_VAR 0 1
21747: PPUSH
21748: EMPTY
21749: PPUSH
21750: CALL_OW 1
21754: ST_TO_ADDR
// mc_build_list := Replace ( mc_build_list , base , [ ] ) ;
21755: LD_ADDR_EXP 100
21759: PUSH
21760: LD_EXP 100
21764: PPUSH
21765: LD_VAR 0 1
21769: PPUSH
21770: EMPTY
21771: PPUSH
21772: CALL_OW 1
21776: ST_TO_ADDR
// mc_builders := Replace ( mc_builders , base , [ ] ) ;
21777: LD_ADDR_EXP 101
21781: PUSH
21782: LD_EXP 101
21786: PPUSH
21787: LD_VAR 0 1
21791: PPUSH
21792: EMPTY
21793: PPUSH
21794: CALL_OW 1
21798: ST_TO_ADDR
// mc_construct_list := Replace ( mc_construct_list , base , [ ] ) ;
21799: LD_ADDR_EXP 102
21803: PUSH
21804: LD_EXP 102
21808: PPUSH
21809: LD_VAR 0 1
21813: PPUSH
21814: EMPTY
21815: PPUSH
21816: CALL_OW 1
21820: ST_TO_ADDR
// mc_turret_list := Replace ( mc_turret_list , base , [ ] ) ;
21821: LD_ADDR_EXP 103
21825: PUSH
21826: LD_EXP 103
21830: PPUSH
21831: LD_VAR 0 1
21835: PPUSH
21836: EMPTY
21837: PPUSH
21838: CALL_OW 1
21842: ST_TO_ADDR
// mc_empty_turret_list := Replace ( mc_empty_turret_list , base , [ ] ) ;
21843: LD_ADDR_EXP 104
21847: PUSH
21848: LD_EXP 104
21852: PPUSH
21853: LD_VAR 0 1
21857: PPUSH
21858: EMPTY
21859: PPUSH
21860: CALL_OW 1
21864: ST_TO_ADDR
// mc_busy_turret_list := Replace ( mc_busy_turret_list , base , [ ] ) ;
21865: LD_ADDR_EXP 105
21869: PUSH
21870: LD_EXP 105
21874: PPUSH
21875: LD_VAR 0 1
21879: PPUSH
21880: EMPTY
21881: PPUSH
21882: CALL_OW 1
21886: ST_TO_ADDR
// mc_defender_limit := Replace ( mc_defender_limit , base , 0 ) ;
21887: LD_ADDR_EXP 106
21891: PUSH
21892: LD_EXP 106
21896: PPUSH
21897: LD_VAR 0 1
21901: PPUSH
21902: LD_INT 0
21904: PPUSH
21905: CALL_OW 1
21909: ST_TO_ADDR
// mc_repair_vehicle := Replace ( mc_repair_vehicle , base , [ ] ) ;
21910: LD_ADDR_EXP 107
21914: PUSH
21915: LD_EXP 107
21919: PPUSH
21920: LD_VAR 0 1
21924: PPUSH
21925: EMPTY
21926: PPUSH
21927: CALL_OW 1
21931: ST_TO_ADDR
// mc_mines := Replace ( mc_mines , base , [ ] ) ;
21932: LD_ADDR_EXP 108
21936: PUSH
21937: LD_EXP 108
21941: PPUSH
21942: LD_VAR 0 1
21946: PPUSH
21947: EMPTY
21948: PPUSH
21949: CALL_OW 1
21953: ST_TO_ADDR
// mc_miners := Replace ( mc_miners , base , [ ] ) ;
21954: LD_ADDR_EXP 109
21958: PUSH
21959: LD_EXP 109
21963: PPUSH
21964: LD_VAR 0 1
21968: PPUSH
21969: EMPTY
21970: PPUSH
21971: CALL_OW 1
21975: ST_TO_ADDR
// mc_minefields := Replace ( mc_minefields , base , [ ] ) ;
21976: LD_ADDR_EXP 110
21980: PUSH
21981: LD_EXP 110
21985: PPUSH
21986: LD_VAR 0 1
21990: PPUSH
21991: EMPTY
21992: PPUSH
21993: CALL_OW 1
21997: ST_TO_ADDR
// mc_crates := Replace ( mc_crates , base , [ ] ) ;
21998: LD_ADDR_EXP 111
22002: PUSH
22003: LD_EXP 111
22007: PPUSH
22008: LD_VAR 0 1
22012: PPUSH
22013: EMPTY
22014: PPUSH
22015: CALL_OW 1
22019: ST_TO_ADDR
// mc_crates_collector := Replace ( mc_crates_collector , base , [ ] ) ;
22020: LD_ADDR_EXP 112
22024: PUSH
22025: LD_EXP 112
22029: PPUSH
22030: LD_VAR 0 1
22034: PPUSH
22035: EMPTY
22036: PPUSH
22037: CALL_OW 1
22041: ST_TO_ADDR
// mc_crates_area := Replace ( mc_crates_area , base , [ ] ) ;
22042: LD_ADDR_EXP 113
22046: PUSH
22047: LD_EXP 113
22051: PPUSH
22052: LD_VAR 0 1
22056: PPUSH
22057: EMPTY
22058: PPUSH
22059: CALL_OW 1
22063: ST_TO_ADDR
// mc_vehicles := Replace ( mc_vehicles , base , [ ] ) ;
22064: LD_ADDR_EXP 114
22068: PUSH
22069: LD_EXP 114
22073: PPUSH
22074: LD_VAR 0 1
22078: PPUSH
22079: EMPTY
22080: PPUSH
22081: CALL_OW 1
22085: ST_TO_ADDR
// mc_attack := Replace ( mc_attack , base , [ ] ) ;
22086: LD_ADDR_EXP 115
22090: PUSH
22091: LD_EXP 115
22095: PPUSH
22096: LD_VAR 0 1
22100: PPUSH
22101: EMPTY
22102: PPUSH
22103: CALL_OW 1
22107: ST_TO_ADDR
// mc_produce := Replace ( mc_produce , base , [ ] ) ;
22108: LD_ADDR_EXP 116
22112: PUSH
22113: LD_EXP 116
22117: PPUSH
22118: LD_VAR 0 1
22122: PPUSH
22123: EMPTY
22124: PPUSH
22125: CALL_OW 1
22129: ST_TO_ADDR
// mc_defender := Replace ( mc_defender , base , [ ] ) ;
22130: LD_ADDR_EXP 117
22134: PUSH
22135: LD_EXP 117
22139: PPUSH
22140: LD_VAR 0 1
22144: PPUSH
22145: EMPTY
22146: PPUSH
22147: CALL_OW 1
22151: ST_TO_ADDR
// mc_scan := Replace ( mc_scan , base , [ ] ) ;
22152: LD_ADDR_EXP 118
22156: PUSH
22157: LD_EXP 118
22161: PPUSH
22162: LD_VAR 0 1
22166: PPUSH
22167: EMPTY
22168: PPUSH
22169: CALL_OW 1
22173: ST_TO_ADDR
// mc_parking := Replace ( mc_parking , base , [ ] ) ;
22174: LD_ADDR_EXP 119
22178: PUSH
22179: LD_EXP 119
22183: PPUSH
22184: LD_VAR 0 1
22188: PPUSH
22189: EMPTY
22190: PPUSH
22191: CALL_OW 1
22195: ST_TO_ADDR
// mc_scan_area := Replace ( mc_scan_area , base , [ ] ) ;
22196: LD_ADDR_EXP 120
22200: PUSH
22201: LD_EXP 120
22205: PPUSH
22206: LD_VAR 0 1
22210: PPUSH
22211: EMPTY
22212: PPUSH
22213: CALL_OW 1
22217: ST_TO_ADDR
// mc_tech := Replace ( mc_tech , base , [ ] ) ;
22218: LD_ADDR_EXP 122
22222: PUSH
22223: LD_EXP 122
22227: PPUSH
22228: LD_VAR 0 1
22232: PPUSH
22233: EMPTY
22234: PPUSH
22235: CALL_OW 1
22239: ST_TO_ADDR
// mc_ape := Replace ( mc_ape , base , [ ] ) ;
22240: LD_ADDR_EXP 124
22244: PUSH
22245: LD_EXP 124
22249: PPUSH
22250: LD_VAR 0 1
22254: PPUSH
22255: EMPTY
22256: PPUSH
22257: CALL_OW 1
22261: ST_TO_ADDR
// mc_ape_in_lab := Replace ( mc_ape_in_lab , base , [ ] ) ;
22262: LD_ADDR_EXP 125
22266: PUSH
22267: LD_EXP 125
22271: PPUSH
22272: LD_VAR 0 1
22276: PPUSH
22277: EMPTY
22278: PPUSH
22279: CALL_OW 1
22283: ST_TO_ADDR
// mc_taming := Replace ( mc_taming , base , [ ] ) ;
22284: LD_ADDR_EXP 126
22288: PUSH
22289: LD_EXP 126
22293: PPUSH
22294: LD_VAR 0 1
22298: PPUSH
22299: EMPTY
22300: PPUSH
22301: CALL_OW 1
22305: ST_TO_ADDR
// mc_build_upgrade := Replace ( mc_build_upgrade , base , [ ] ) ;
22306: LD_ADDR_EXP 127
22310: PUSH
22311: LD_EXP 127
22315: PPUSH
22316: LD_VAR 0 1
22320: PPUSH
22321: EMPTY
22322: PPUSH
22323: CALL_OW 1
22327: ST_TO_ADDR
// mc_lab := Replace ( mc_lab , base , [ ] ) ;
22328: LD_ADDR_EXP 128
22332: PUSH
22333: LD_EXP 128
22337: PPUSH
22338: LD_VAR 0 1
22342: PPUSH
22343: EMPTY
22344: PPUSH
22345: CALL_OW 1
22349: ST_TO_ADDR
// mc_lab_upgrade := Replace ( mc_lab_upgrade , base , [ ] ) ;
22350: LD_ADDR_EXP 129
22354: PUSH
22355: LD_EXP 129
22359: PPUSH
22360: LD_VAR 0 1
22364: PPUSH
22365: EMPTY
22366: PPUSH
22367: CALL_OW 1
22371: ST_TO_ADDR
// mc_teleport_exit := Replace ( mc_teleport_exit , base , [ ] ) ;
22372: LD_ADDR_EXP 130
22376: PUSH
22377: LD_EXP 130
22381: PPUSH
22382: LD_VAR 0 1
22386: PPUSH
22387: EMPTY
22388: PPUSH
22389: CALL_OW 1
22393: ST_TO_ADDR
// mc_teleport_exit_set := Replace ( mc_teleport_exit_set , base , [ ] ) ;
22394: LD_ADDR_EXP 131
22398: PUSH
22399: LD_EXP 131
22403: PPUSH
22404: LD_VAR 0 1
22408: PPUSH
22409: EMPTY
22410: PPUSH
22411: CALL_OW 1
22415: ST_TO_ADDR
// mc_deposits_xy := Replace ( mc_deposits_xy , base , [ ] ) ;
22416: LD_ADDR_EXP 132
22420: PUSH
22421: LD_EXP 132
22425: PPUSH
22426: LD_VAR 0 1
22430: PPUSH
22431: EMPTY
22432: PPUSH
22433: CALL_OW 1
22437: ST_TO_ADDR
// mc_deposits_finder := Replace ( mc_deposits_finder , base , [ ] ) ;
22438: LD_ADDR_EXP 133
22442: PUSH
22443: LD_EXP 133
22447: PPUSH
22448: LD_VAR 0 1
22452: PPUSH
22453: EMPTY
22454: PPUSH
22455: CALL_OW 1
22459: ST_TO_ADDR
// mc_allowed_tower_weapons := Replace ( mc_allowed_tower_weapons , base , [ ] ) ;
22460: LD_ADDR_EXP 134
22464: PUSH
22465: LD_EXP 134
22469: PPUSH
22470: LD_VAR 0 1
22474: PPUSH
22475: EMPTY
22476: PPUSH
22477: CALL_OW 1
22481: ST_TO_ADDR
// mc_remote_driver := Replace ( mc_remote_driver , base , [ ] ) ;
22482: LD_ADDR_EXP 135
22486: PUSH
22487: LD_EXP 135
22491: PPUSH
22492: LD_VAR 0 1
22496: PPUSH
22497: EMPTY
22498: PPUSH
22499: CALL_OW 1
22503: ST_TO_ADDR
// mc_class := Replace ( mc_class , base , [ ] ) ;
22504: LD_ADDR_EXP 136
22508: PUSH
22509: LD_EXP 136
22513: PPUSH
22514: LD_VAR 0 1
22518: PPUSH
22519: EMPTY
22520: PPUSH
22521: CALL_OW 1
22525: ST_TO_ADDR
// mc_class_case_use := Replace ( mc_class_case_use , base , 0 ) ;
22526: LD_ADDR_EXP 137
22530: PUSH
22531: LD_EXP 137
22535: PPUSH
22536: LD_VAR 0 1
22540: PPUSH
22541: LD_INT 0
22543: PPUSH
22544: CALL_OW 1
22548: ST_TO_ADDR
// mc_is_defending := Replace ( mc_is_defending , base , false ) ;
22549: LD_ADDR_EXP 138
22553: PUSH
22554: LD_EXP 138
22558: PPUSH
22559: LD_VAR 0 1
22563: PPUSH
22564: LD_INT 0
22566: PPUSH
22567: CALL_OW 1
22571: ST_TO_ADDR
// end ;
22572: LD_VAR 0 2
22576: RET
// export function MC_Add ( side , units ) ; var base ; begin
22577: LD_INT 0
22579: PPUSH
22580: PPUSH
// base := mc_bases + 1 ;
22581: LD_ADDR_VAR 0 4
22585: PUSH
22586: LD_EXP 95
22590: PUSH
22591: LD_INT 1
22593: PLUS
22594: ST_TO_ADDR
// mc_sides := Replace ( mc_sides , base , side ) ;
22595: LD_ADDR_EXP 121
22599: PUSH
22600: LD_EXP 121
22604: PPUSH
22605: LD_VAR 0 4
22609: PPUSH
22610: LD_VAR 0 1
22614: PPUSH
22615: CALL_OW 1
22619: ST_TO_ADDR
// mc_bases := Replace ( mc_bases , base , units ) ;
22620: LD_ADDR_EXP 95
22624: PUSH
22625: LD_EXP 95
22629: PPUSH
22630: LD_VAR 0 4
22634: PPUSH
22635: LD_VAR 0 2
22639: PPUSH
22640: CALL_OW 1
22644: ST_TO_ADDR
// mc_building_need_repair := Replace ( mc_building_need_repair , base , [ ] ) ;
22645: LD_ADDR_EXP 96
22649: PUSH
22650: LD_EXP 96
22654: PPUSH
22655: LD_VAR 0 4
22659: PPUSH
22660: EMPTY
22661: PPUSH
22662: CALL_OW 1
22666: ST_TO_ADDR
// mc_building_repairs := Replace ( mc_building_repairs , base , [ ] ) ;
22667: LD_ADDR_EXP 97
22671: PUSH
22672: LD_EXP 97
22676: PPUSH
22677: LD_VAR 0 4
22681: PPUSH
22682: EMPTY
22683: PPUSH
22684: CALL_OW 1
22688: ST_TO_ADDR
// mc_need_heal := Replace ( mc_need_heal , base , [ ] ) ;
22689: LD_ADDR_EXP 98
22693: PUSH
22694: LD_EXP 98
22698: PPUSH
22699: LD_VAR 0 4
22703: PPUSH
22704: EMPTY
22705: PPUSH
22706: CALL_OW 1
22710: ST_TO_ADDR
// mc_healers := Replace ( mc_healers , base , [ ] ) ;
22711: LD_ADDR_EXP 99
22715: PUSH
22716: LD_EXP 99
22720: PPUSH
22721: LD_VAR 0 4
22725: PPUSH
22726: EMPTY
22727: PPUSH
22728: CALL_OW 1
22732: ST_TO_ADDR
// mc_build_list := Replace ( mc_build_list , base , [ ] ) ;
22733: LD_ADDR_EXP 100
22737: PUSH
22738: LD_EXP 100
22742: PPUSH
22743: LD_VAR 0 4
22747: PPUSH
22748: EMPTY
22749: PPUSH
22750: CALL_OW 1
22754: ST_TO_ADDR
// mc_builders := Replace ( mc_builders , base , [ ] ) ;
22755: LD_ADDR_EXP 101
22759: PUSH
22760: LD_EXP 101
22764: PPUSH
22765: LD_VAR 0 4
22769: PPUSH
22770: EMPTY
22771: PPUSH
22772: CALL_OW 1
22776: ST_TO_ADDR
// mc_construct_list := Replace ( mc_construct_list , base , [ ] ) ;
22777: LD_ADDR_EXP 102
22781: PUSH
22782: LD_EXP 102
22786: PPUSH
22787: LD_VAR 0 4
22791: PPUSH
22792: EMPTY
22793: PPUSH
22794: CALL_OW 1
22798: ST_TO_ADDR
// mc_turret_list := Replace ( mc_turret_list , base , [ ] ) ;
22799: LD_ADDR_EXP 103
22803: PUSH
22804: LD_EXP 103
22808: PPUSH
22809: LD_VAR 0 4
22813: PPUSH
22814: EMPTY
22815: PPUSH
22816: CALL_OW 1
22820: ST_TO_ADDR
// mc_empty_turret_list := Replace ( mc_empty_turret_list , base , [ ] ) ;
22821: LD_ADDR_EXP 104
22825: PUSH
22826: LD_EXP 104
22830: PPUSH
22831: LD_VAR 0 4
22835: PPUSH
22836: EMPTY
22837: PPUSH
22838: CALL_OW 1
22842: ST_TO_ADDR
// mc_busy_turret_list := Replace ( mc_busy_turret_list , base , [ ] ) ;
22843: LD_ADDR_EXP 105
22847: PUSH
22848: LD_EXP 105
22852: PPUSH
22853: LD_VAR 0 4
22857: PPUSH
22858: EMPTY
22859: PPUSH
22860: CALL_OW 1
22864: ST_TO_ADDR
// mc_defender_limit := Replace ( mc_defender_limit , base , 0 ) ;
22865: LD_ADDR_EXP 106
22869: PUSH
22870: LD_EXP 106
22874: PPUSH
22875: LD_VAR 0 4
22879: PPUSH
22880: LD_INT 0
22882: PPUSH
22883: CALL_OW 1
22887: ST_TO_ADDR
// mc_repair_vehicle := Replace ( mc_repair_vehicle , base , [ ] ) ;
22888: LD_ADDR_EXP 107
22892: PUSH
22893: LD_EXP 107
22897: PPUSH
22898: LD_VAR 0 4
22902: PPUSH
22903: EMPTY
22904: PPUSH
22905: CALL_OW 1
22909: ST_TO_ADDR
// mc_mines := Replace ( mc_mines , base , [ ] ) ;
22910: LD_ADDR_EXP 108
22914: PUSH
22915: LD_EXP 108
22919: PPUSH
22920: LD_VAR 0 4
22924: PPUSH
22925: EMPTY
22926: PPUSH
22927: CALL_OW 1
22931: ST_TO_ADDR
// mc_miners := Replace ( mc_miners , base , [ ] ) ;
22932: LD_ADDR_EXP 109
22936: PUSH
22937: LD_EXP 109
22941: PPUSH
22942: LD_VAR 0 4
22946: PPUSH
22947: EMPTY
22948: PPUSH
22949: CALL_OW 1
22953: ST_TO_ADDR
// mc_minefields := Replace ( mc_minefields , base , [ ] ) ;
22954: LD_ADDR_EXP 110
22958: PUSH
22959: LD_EXP 110
22963: PPUSH
22964: LD_VAR 0 4
22968: PPUSH
22969: EMPTY
22970: PPUSH
22971: CALL_OW 1
22975: ST_TO_ADDR
// mc_crates := Replace ( mc_crates , base , [ ] ) ;
22976: LD_ADDR_EXP 111
22980: PUSH
22981: LD_EXP 111
22985: PPUSH
22986: LD_VAR 0 4
22990: PPUSH
22991: EMPTY
22992: PPUSH
22993: CALL_OW 1
22997: ST_TO_ADDR
// mc_crates_collector := Replace ( mc_crates_collector , base , [ ] ) ;
22998: LD_ADDR_EXP 112
23002: PUSH
23003: LD_EXP 112
23007: PPUSH
23008: LD_VAR 0 4
23012: PPUSH
23013: EMPTY
23014: PPUSH
23015: CALL_OW 1
23019: ST_TO_ADDR
// mc_crates_area := Replace ( mc_crates_area , base , [ ] ) ;
23020: LD_ADDR_EXP 113
23024: PUSH
23025: LD_EXP 113
23029: PPUSH
23030: LD_VAR 0 4
23034: PPUSH
23035: EMPTY
23036: PPUSH
23037: CALL_OW 1
23041: ST_TO_ADDR
// mc_vehicles := Replace ( mc_vehicles , base , [ ] ) ;
23042: LD_ADDR_EXP 114
23046: PUSH
23047: LD_EXP 114
23051: PPUSH
23052: LD_VAR 0 4
23056: PPUSH
23057: EMPTY
23058: PPUSH
23059: CALL_OW 1
23063: ST_TO_ADDR
// mc_attack := Replace ( mc_attack , base , [ ] ) ;
23064: LD_ADDR_EXP 115
23068: PUSH
23069: LD_EXP 115
23073: PPUSH
23074: LD_VAR 0 4
23078: PPUSH
23079: EMPTY
23080: PPUSH
23081: CALL_OW 1
23085: ST_TO_ADDR
// mc_produce := Replace ( mc_produce , base , [ ] ) ;
23086: LD_ADDR_EXP 116
23090: PUSH
23091: LD_EXP 116
23095: PPUSH
23096: LD_VAR 0 4
23100: PPUSH
23101: EMPTY
23102: PPUSH
23103: CALL_OW 1
23107: ST_TO_ADDR
// mc_defender := Replace ( mc_defender , base , [ ] ) ;
23108: LD_ADDR_EXP 117
23112: PUSH
23113: LD_EXP 117
23117: PPUSH
23118: LD_VAR 0 4
23122: PPUSH
23123: EMPTY
23124: PPUSH
23125: CALL_OW 1
23129: ST_TO_ADDR
// mc_scan := Replace ( mc_scan , base , [ ] ) ;
23130: LD_ADDR_EXP 118
23134: PUSH
23135: LD_EXP 118
23139: PPUSH
23140: LD_VAR 0 4
23144: PPUSH
23145: EMPTY
23146: PPUSH
23147: CALL_OW 1
23151: ST_TO_ADDR
// mc_parking := Replace ( mc_parking , base , [ ] ) ;
23152: LD_ADDR_EXP 119
23156: PUSH
23157: LD_EXP 119
23161: PPUSH
23162: LD_VAR 0 4
23166: PPUSH
23167: EMPTY
23168: PPUSH
23169: CALL_OW 1
23173: ST_TO_ADDR
// mc_scan_area := Replace ( mc_scan_area , base , [ ] ) ;
23174: LD_ADDR_EXP 120
23178: PUSH
23179: LD_EXP 120
23183: PPUSH
23184: LD_VAR 0 4
23188: PPUSH
23189: EMPTY
23190: PPUSH
23191: CALL_OW 1
23195: ST_TO_ADDR
// mc_tech := Replace ( mc_tech , base , [ ] ) ;
23196: LD_ADDR_EXP 122
23200: PUSH
23201: LD_EXP 122
23205: PPUSH
23206: LD_VAR 0 4
23210: PPUSH
23211: EMPTY
23212: PPUSH
23213: CALL_OW 1
23217: ST_TO_ADDR
// mc_ape := Replace ( mc_ape , base , [ ] ) ;
23218: LD_ADDR_EXP 124
23222: PUSH
23223: LD_EXP 124
23227: PPUSH
23228: LD_VAR 0 4
23232: PPUSH
23233: EMPTY
23234: PPUSH
23235: CALL_OW 1
23239: ST_TO_ADDR
// mc_ape_in_lab := Replace ( mc_ape_in_lab , base , [ ] ) ;
23240: LD_ADDR_EXP 125
23244: PUSH
23245: LD_EXP 125
23249: PPUSH
23250: LD_VAR 0 4
23254: PPUSH
23255: EMPTY
23256: PPUSH
23257: CALL_OW 1
23261: ST_TO_ADDR
// mc_taming := Replace ( mc_taming , base , [ ] ) ;
23262: LD_ADDR_EXP 126
23266: PUSH
23267: LD_EXP 126
23271: PPUSH
23272: LD_VAR 0 4
23276: PPUSH
23277: EMPTY
23278: PPUSH
23279: CALL_OW 1
23283: ST_TO_ADDR
// mc_build_upgrade := Replace ( mc_build_upgrade , base , [ ] ) ;
23284: LD_ADDR_EXP 127
23288: PUSH
23289: LD_EXP 127
23293: PPUSH
23294: LD_VAR 0 4
23298: PPUSH
23299: EMPTY
23300: PPUSH
23301: CALL_OW 1
23305: ST_TO_ADDR
// mc_lab := Replace ( mc_lab , base , [ ] ) ;
23306: LD_ADDR_EXP 128
23310: PUSH
23311: LD_EXP 128
23315: PPUSH
23316: LD_VAR 0 4
23320: PPUSH
23321: EMPTY
23322: PPUSH
23323: CALL_OW 1
23327: ST_TO_ADDR
// mc_lab_upgrade := Replace ( mc_lab_upgrade , base , [ ] ) ;
23328: LD_ADDR_EXP 129
23332: PUSH
23333: LD_EXP 129
23337: PPUSH
23338: LD_VAR 0 4
23342: PPUSH
23343: EMPTY
23344: PPUSH
23345: CALL_OW 1
23349: ST_TO_ADDR
// mc_teleport_exit := Replace ( mc_teleport_exit , base , [ ] ) ;
23350: LD_ADDR_EXP 130
23354: PUSH
23355: LD_EXP 130
23359: PPUSH
23360: LD_VAR 0 4
23364: PPUSH
23365: EMPTY
23366: PPUSH
23367: CALL_OW 1
23371: ST_TO_ADDR
// mc_teleport_exit_set := Replace ( mc_teleport_exit_set , base , [ ] ) ;
23372: LD_ADDR_EXP 131
23376: PUSH
23377: LD_EXP 131
23381: PPUSH
23382: LD_VAR 0 4
23386: PPUSH
23387: EMPTY
23388: PPUSH
23389: CALL_OW 1
23393: ST_TO_ADDR
// mc_deposits_xy := Replace ( mc_deposits_xy , base , [ ] ) ;
23394: LD_ADDR_EXP 132
23398: PUSH
23399: LD_EXP 132
23403: PPUSH
23404: LD_VAR 0 4
23408: PPUSH
23409: EMPTY
23410: PPUSH
23411: CALL_OW 1
23415: ST_TO_ADDR
// mc_deposits_finder := Replace ( mc_deposits_finder , base , [ ] ) ;
23416: LD_ADDR_EXP 133
23420: PUSH
23421: LD_EXP 133
23425: PPUSH
23426: LD_VAR 0 4
23430: PPUSH
23431: EMPTY
23432: PPUSH
23433: CALL_OW 1
23437: ST_TO_ADDR
// mc_allowed_tower_weapons := Replace ( mc_allowed_tower_weapons , base , [ ] ) ;
23438: LD_ADDR_EXP 134
23442: PUSH
23443: LD_EXP 134
23447: PPUSH
23448: LD_VAR 0 4
23452: PPUSH
23453: EMPTY
23454: PPUSH
23455: CALL_OW 1
23459: ST_TO_ADDR
// mc_remote_driver := Replace ( mc_remote_driver , base , [ ] ) ;
23460: LD_ADDR_EXP 135
23464: PUSH
23465: LD_EXP 135
23469: PPUSH
23470: LD_VAR 0 4
23474: PPUSH
23475: EMPTY
23476: PPUSH
23477: CALL_OW 1
23481: ST_TO_ADDR
// mc_class := Replace ( mc_class , base , [ ] ) ;
23482: LD_ADDR_EXP 136
23486: PUSH
23487: LD_EXP 136
23491: PPUSH
23492: LD_VAR 0 4
23496: PPUSH
23497: EMPTY
23498: PPUSH
23499: CALL_OW 1
23503: ST_TO_ADDR
// mc_class_case_use := Replace ( mc_class_case_use , base , 0 ) ;
23504: LD_ADDR_EXP 137
23508: PUSH
23509: LD_EXP 137
23513: PPUSH
23514: LD_VAR 0 4
23518: PPUSH
23519: LD_INT 0
23521: PPUSH
23522: CALL_OW 1
23526: ST_TO_ADDR
// mc_is_defending := Replace ( mc_is_defending , base , false ) ;
23527: LD_ADDR_EXP 138
23531: PUSH
23532: LD_EXP 138
23536: PPUSH
23537: LD_VAR 0 4
23541: PPUSH
23542: LD_INT 0
23544: PPUSH
23545: CALL_OW 1
23549: ST_TO_ADDR
// result := base ;
23550: LD_ADDR_VAR 0 3
23554: PUSH
23555: LD_VAR 0 4
23559: ST_TO_ADDR
// end ;
23560: LD_VAR 0 3
23564: RET
// export function MC_Start ( ) ; var i ; begin
23565: LD_INT 0
23567: PPUSH
23568: PPUSH
// for i = 1 to mc_bases do
23569: LD_ADDR_VAR 0 2
23573: PUSH
23574: DOUBLE
23575: LD_INT 1
23577: DEC
23578: ST_TO_ADDR
23579: LD_EXP 95
23583: PUSH
23584: FOR_TO
23585: IFFALSE 24685
// begin mc_bases := Replace ( mc_bases , i , mc_bases [ i ] diff 0 ) ;
23587: LD_ADDR_EXP 95
23591: PUSH
23592: LD_EXP 95
23596: PPUSH
23597: LD_VAR 0 2
23601: PPUSH
23602: LD_EXP 95
23606: PUSH
23607: LD_VAR 0 2
23611: ARRAY
23612: PUSH
23613: LD_INT 0
23615: DIFF
23616: PPUSH
23617: CALL_OW 1
23621: ST_TO_ADDR
// mc_building_need_repair := Replace ( mc_building_need_repair , i , [ ] ) ;
23622: LD_ADDR_EXP 96
23626: PUSH
23627: LD_EXP 96
23631: PPUSH
23632: LD_VAR 0 2
23636: PPUSH
23637: EMPTY
23638: PPUSH
23639: CALL_OW 1
23643: ST_TO_ADDR
// mc_building_repairs := Replace ( mc_building_repairs , i , [ ] ) ;
23644: LD_ADDR_EXP 97
23648: PUSH
23649: LD_EXP 97
23653: PPUSH
23654: LD_VAR 0 2
23658: PPUSH
23659: EMPTY
23660: PPUSH
23661: CALL_OW 1
23665: ST_TO_ADDR
// mc_need_heal := Replace ( mc_need_heal , i , [ ] ) ;
23666: LD_ADDR_EXP 98
23670: PUSH
23671: LD_EXP 98
23675: PPUSH
23676: LD_VAR 0 2
23680: PPUSH
23681: EMPTY
23682: PPUSH
23683: CALL_OW 1
23687: ST_TO_ADDR
// mc_healers := Replace ( mc_healers , i , [ [ ] , [ ] ] ) ;
23688: LD_ADDR_EXP 99
23692: PUSH
23693: LD_EXP 99
23697: PPUSH
23698: LD_VAR 0 2
23702: PPUSH
23703: EMPTY
23704: PUSH
23705: EMPTY
23706: PUSH
23707: EMPTY
23708: LIST
23709: LIST
23710: PPUSH
23711: CALL_OW 1
23715: ST_TO_ADDR
// mc_build_list := Replace ( mc_build_list , i , [ ] ) ;
23716: LD_ADDR_EXP 100
23720: PUSH
23721: LD_EXP 100
23725: PPUSH
23726: LD_VAR 0 2
23730: PPUSH
23731: EMPTY
23732: PPUSH
23733: CALL_OW 1
23737: ST_TO_ADDR
// mc_build_upgrade := Replace ( mc_build_upgrade , i , [ ] ) ;
23738: LD_ADDR_EXP 127
23742: PUSH
23743: LD_EXP 127
23747: PPUSH
23748: LD_VAR 0 2
23752: PPUSH
23753: EMPTY
23754: PPUSH
23755: CALL_OW 1
23759: ST_TO_ADDR
// mc_builders := Replace ( mc_builders , i , [ ] ) ;
23760: LD_ADDR_EXP 101
23764: PUSH
23765: LD_EXP 101
23769: PPUSH
23770: LD_VAR 0 2
23774: PPUSH
23775: EMPTY
23776: PPUSH
23777: CALL_OW 1
23781: ST_TO_ADDR
// mc_construct_list := Replace ( mc_construct_list , i , [ ] ) ;
23782: LD_ADDR_EXP 102
23786: PUSH
23787: LD_EXP 102
23791: PPUSH
23792: LD_VAR 0 2
23796: PPUSH
23797: EMPTY
23798: PPUSH
23799: CALL_OW 1
23803: ST_TO_ADDR
// mc_turret_list := Replace ( mc_turret_list , i , UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_bunker ] , [ f_btype , b_turret ] ] ) ) ;
23804: LD_ADDR_EXP 103
23808: PUSH
23809: LD_EXP 103
23813: PPUSH
23814: LD_VAR 0 2
23818: PPUSH
23819: LD_EXP 95
23823: PUSH
23824: LD_VAR 0 2
23828: ARRAY
23829: PPUSH
23830: LD_INT 2
23832: PUSH
23833: LD_INT 30
23835: PUSH
23836: LD_INT 32
23838: PUSH
23839: EMPTY
23840: LIST
23841: LIST
23842: PUSH
23843: LD_INT 30
23845: PUSH
23846: LD_INT 33
23848: PUSH
23849: EMPTY
23850: LIST
23851: LIST
23852: PUSH
23853: EMPTY
23854: LIST
23855: LIST
23856: LIST
23857: PPUSH
23858: CALL_OW 72
23862: PPUSH
23863: CALL_OW 1
23867: ST_TO_ADDR
// mc_empty_turret_list := Replace ( mc_empty_turret_list , i , UnitFilter ( mc_bases [ i ] , [ [ f_or , [ f_btype , b_bunker ] , [ f_btype , b_breastwork ] ] , [ f_empty ] ] ) ) ;
23868: LD_ADDR_EXP 104
23872: PUSH
23873: LD_EXP 104
23877: PPUSH
23878: LD_VAR 0 2
23882: PPUSH
23883: LD_EXP 95
23887: PUSH
23888: LD_VAR 0 2
23892: ARRAY
23893: PPUSH
23894: LD_INT 2
23896: PUSH
23897: LD_INT 30
23899: PUSH
23900: LD_INT 32
23902: PUSH
23903: EMPTY
23904: LIST
23905: LIST
23906: PUSH
23907: LD_INT 30
23909: PUSH
23910: LD_INT 31
23912: PUSH
23913: EMPTY
23914: LIST
23915: LIST
23916: PUSH
23917: EMPTY
23918: LIST
23919: LIST
23920: LIST
23921: PUSH
23922: LD_INT 58
23924: PUSH
23925: EMPTY
23926: LIST
23927: PUSH
23928: EMPTY
23929: LIST
23930: LIST
23931: PPUSH
23932: CALL_OW 72
23936: PPUSH
23937: CALL_OW 1
23941: ST_TO_ADDR
// mc_busy_turret_list := Replace ( mc_busy_turret_list , i , [ ] ) ;
23942: LD_ADDR_EXP 105
23946: PUSH
23947: LD_EXP 105
23951: PPUSH
23952: LD_VAR 0 2
23956: PPUSH
23957: EMPTY
23958: PPUSH
23959: CALL_OW 1
23963: ST_TO_ADDR
// mc_miners := Replace ( mc_miners , i , [ ] ) ;
23964: LD_ADDR_EXP 109
23968: PUSH
23969: LD_EXP 109
23973: PPUSH
23974: LD_VAR 0 2
23978: PPUSH
23979: EMPTY
23980: PPUSH
23981: CALL_OW 1
23985: ST_TO_ADDR
// mc_mines := Replace ( mc_mines , i , [ ] ) ;
23986: LD_ADDR_EXP 108
23990: PUSH
23991: LD_EXP 108
23995: PPUSH
23996: LD_VAR 0 2
24000: PPUSH
24001: EMPTY
24002: PPUSH
24003: CALL_OW 1
24007: ST_TO_ADDR
// mc_minefields := Replace ( mc_minefields , i , [ ] ) ;
24008: LD_ADDR_EXP 110
24012: PUSH
24013: LD_EXP 110
24017: PPUSH
24018: LD_VAR 0 2
24022: PPUSH
24023: EMPTY
24024: PPUSH
24025: CALL_OW 1
24029: ST_TO_ADDR
// mc_crates := Replace ( mc_crates , i , [ ] ) ;
24030: LD_ADDR_EXP 111
24034: PUSH
24035: LD_EXP 111
24039: PPUSH
24040: LD_VAR 0 2
24044: PPUSH
24045: EMPTY
24046: PPUSH
24047: CALL_OW 1
24051: ST_TO_ADDR
// mc_crates_collector := Replace ( mc_crates_collector , i , [ ] ) ;
24052: LD_ADDR_EXP 112
24056: PUSH
24057: LD_EXP 112
24061: PPUSH
24062: LD_VAR 0 2
24066: PPUSH
24067: EMPTY
24068: PPUSH
24069: CALL_OW 1
24073: ST_TO_ADDR
// mc_crates_area := Replace ( mc_crates_area , i , [ ] ) ;
24074: LD_ADDR_EXP 113
24078: PUSH
24079: LD_EXP 113
24083: PPUSH
24084: LD_VAR 0 2
24088: PPUSH
24089: EMPTY
24090: PPUSH
24091: CALL_OW 1
24095: ST_TO_ADDR
// mc_vehicles := Replace ( mc_vehicles , i , [ ] ) ;
24096: LD_ADDR_EXP 114
24100: PUSH
24101: LD_EXP 114
24105: PPUSH
24106: LD_VAR 0 2
24110: PPUSH
24111: EMPTY
24112: PPUSH
24113: CALL_OW 1
24117: ST_TO_ADDR
// mc_attack := Replace ( mc_attack , i , [ ] ) ;
24118: LD_ADDR_EXP 115
24122: PUSH
24123: LD_EXP 115
24127: PPUSH
24128: LD_VAR 0 2
24132: PPUSH
24133: EMPTY
24134: PPUSH
24135: CALL_OW 1
24139: ST_TO_ADDR
// mc_produce := Replace ( mc_produce , i , [ ] ) ;
24140: LD_ADDR_EXP 116
24144: PUSH
24145: LD_EXP 116
24149: PPUSH
24150: LD_VAR 0 2
24154: PPUSH
24155: EMPTY
24156: PPUSH
24157: CALL_OW 1
24161: ST_TO_ADDR
// mc_defender := Replace ( mc_defender , i , [ ] ) ;
24162: LD_ADDR_EXP 117
24166: PUSH
24167: LD_EXP 117
24171: PPUSH
24172: LD_VAR 0 2
24176: PPUSH
24177: EMPTY
24178: PPUSH
24179: CALL_OW 1
24183: ST_TO_ADDR
// mc_defender_limit := Replace ( mc_defender_limit , i , 0 ) ;
24184: LD_ADDR_EXP 106
24188: PUSH
24189: LD_EXP 106
24193: PPUSH
24194: LD_VAR 0 2
24198: PPUSH
24199: LD_INT 0
24201: PPUSH
24202: CALL_OW 1
24206: ST_TO_ADDR
// mc_parking := Replace ( mc_parking , i , 0 ) ;
24207: LD_ADDR_EXP 119
24211: PUSH
24212: LD_EXP 119
24216: PPUSH
24217: LD_VAR 0 2
24221: PPUSH
24222: LD_INT 0
24224: PPUSH
24225: CALL_OW 1
24229: ST_TO_ADDR
// mc_repair_vehicle := Replace ( mc_repair_vehicle , i , [ ] ) ;
24230: LD_ADDR_EXP 107
24234: PUSH
24235: LD_EXP 107
24239: PPUSH
24240: LD_VAR 0 2
24244: PPUSH
24245: EMPTY
24246: PPUSH
24247: CALL_OW 1
24251: ST_TO_ADDR
// mc_scan := Replace ( mc_scan , i , 0 ) ;
24252: LD_ADDR_EXP 118
24256: PUSH
24257: LD_EXP 118
24261: PPUSH
24262: LD_VAR 0 2
24266: PPUSH
24267: LD_INT 0
24269: PPUSH
24270: CALL_OW 1
24274: ST_TO_ADDR
// mc_scan_area := Replace ( mc_scan_area , i , [ ] ) ;
24275: LD_ADDR_EXP 120
24279: PUSH
24280: LD_EXP 120
24284: PPUSH
24285: LD_VAR 0 2
24289: PPUSH
24290: EMPTY
24291: PPUSH
24292: CALL_OW 1
24296: ST_TO_ADDR
// mc_can_tame := Replace ( mc_can_tame , i , 0 ) ;
24297: LD_ADDR_EXP 123
24301: PUSH
24302: LD_EXP 123
24306: PPUSH
24307: LD_VAR 0 2
24311: PPUSH
24312: LD_INT 0
24314: PPUSH
24315: CALL_OW 1
24319: ST_TO_ADDR
// mc_ape := Replace ( mc_ape , i , [ ] ) ;
24320: LD_ADDR_EXP 124
24324: PUSH
24325: LD_EXP 124
24329: PPUSH
24330: LD_VAR 0 2
24334: PPUSH
24335: EMPTY
24336: PPUSH
24337: CALL_OW 1
24341: ST_TO_ADDR
// mc_ape_in_lab := Replace ( mc_ape_in_lab , i , [ ] ) ;
24342: LD_ADDR_EXP 125
24346: PUSH
24347: LD_EXP 125
24351: PPUSH
24352: LD_VAR 0 2
24356: PPUSH
24357: EMPTY
24358: PPUSH
24359: CALL_OW 1
24363: ST_TO_ADDR
// mc_taming := Replace ( mc_taming , i , [ ] ) ;
24364: LD_ADDR_EXP 126
24368: PUSH
24369: LD_EXP 126
24373: PPUSH
24374: LD_VAR 0 2
24378: PPUSH
24379: EMPTY
24380: PPUSH
24381: CALL_OW 1
24385: ST_TO_ADDR
// mc_lab := Replace ( mc_lab , i , UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_lab ] , [ f_btype , b_lab_half ] , [ f_btype , b_lab_full ] ] ) ) ;
24386: LD_ADDR_EXP 128
24390: PUSH
24391: LD_EXP 128
24395: PPUSH
24396: LD_VAR 0 2
24400: PPUSH
24401: LD_EXP 95
24405: PUSH
24406: LD_VAR 0 2
24410: ARRAY
24411: PPUSH
24412: LD_INT 2
24414: PUSH
24415: LD_INT 30
24417: PUSH
24418: LD_INT 6
24420: PUSH
24421: EMPTY
24422: LIST
24423: LIST
24424: PUSH
24425: LD_INT 30
24427: PUSH
24428: LD_INT 7
24430: PUSH
24431: EMPTY
24432: LIST
24433: LIST
24434: PUSH
24435: LD_INT 30
24437: PUSH
24438: LD_INT 8
24440: PUSH
24441: EMPTY
24442: LIST
24443: LIST
24444: PUSH
24445: EMPTY
24446: LIST
24447: LIST
24448: LIST
24449: LIST
24450: PPUSH
24451: CALL_OW 72
24455: PPUSH
24456: CALL_OW 1
24460: ST_TO_ADDR
// mc_lab_upgrade := Replace ( mc_lab_upgrade , i , [ ] ) ;
24461: LD_ADDR_EXP 129
24465: PUSH
24466: LD_EXP 129
24470: PPUSH
24471: LD_VAR 0 2
24475: PPUSH
24476: EMPTY
24477: PPUSH
24478: CALL_OW 1
24482: ST_TO_ADDR
// mc_teleport_exit := Replace ( mc_teleport_exit , i , [ ] ) ;
24483: LD_ADDR_EXP 130
24487: PUSH
24488: LD_EXP 130
24492: PPUSH
24493: LD_VAR 0 2
24497: PPUSH
24498: EMPTY
24499: PPUSH
24500: CALL_OW 1
24504: ST_TO_ADDR
// mc_teleport_exit_set := Replace ( mc_teleport_exit_set , i , [ ] ) ;
24505: LD_ADDR_EXP 131
24509: PUSH
24510: LD_EXP 131
24514: PPUSH
24515: LD_VAR 0 2
24519: PPUSH
24520: EMPTY
24521: PPUSH
24522: CALL_OW 1
24526: ST_TO_ADDR
// mc_deposits_xy := Replace ( mc_deposits_xy , i , [ ] ) ;
24527: LD_ADDR_EXP 132
24531: PUSH
24532: LD_EXP 132
24536: PPUSH
24537: LD_VAR 0 2
24541: PPUSH
24542: EMPTY
24543: PPUSH
24544: CALL_OW 1
24548: ST_TO_ADDR
// mc_deposits_finder := Replace ( mc_deposits_finder , i , [ ] ) ;
24549: LD_ADDR_EXP 133
24553: PUSH
24554: LD_EXP 133
24558: PPUSH
24559: LD_VAR 0 2
24563: PPUSH
24564: EMPTY
24565: PPUSH
24566: CALL_OW 1
24570: ST_TO_ADDR
// mc_allowed_tower_weapons := Replace ( mc_allowed_tower_weapons , i , [ ] ) ;
24571: LD_ADDR_EXP 134
24575: PUSH
24576: LD_EXP 134
24580: PPUSH
24581: LD_VAR 0 2
24585: PPUSH
24586: EMPTY
24587: PPUSH
24588: CALL_OW 1
24592: ST_TO_ADDR
// mc_remote_driver := Replace ( mc_remote_driver , i , [ ] ) ;
24593: LD_ADDR_EXP 135
24597: PUSH
24598: LD_EXP 135
24602: PPUSH
24603: LD_VAR 0 2
24607: PPUSH
24608: EMPTY
24609: PPUSH
24610: CALL_OW 1
24614: ST_TO_ADDR
// mc_class := Replace ( mc_class , i , [ ] ) ;
24615: LD_ADDR_EXP 136
24619: PUSH
24620: LD_EXP 136
24624: PPUSH
24625: LD_VAR 0 2
24629: PPUSH
24630: EMPTY
24631: PPUSH
24632: CALL_OW 1
24636: ST_TO_ADDR
// mc_class_case_use := Replace ( mc_class_case_use , i , 0 ) ;
24637: LD_ADDR_EXP 137
24641: PUSH
24642: LD_EXP 137
24646: PPUSH
24647: LD_VAR 0 2
24651: PPUSH
24652: LD_INT 0
24654: PPUSH
24655: CALL_OW 1
24659: ST_TO_ADDR
// mc_is_defending := Replace ( mc_is_defending , i , false ) ;
24660: LD_ADDR_EXP 138
24664: PUSH
24665: LD_EXP 138
24669: PPUSH
24670: LD_VAR 0 2
24674: PPUSH
24675: LD_INT 0
24677: PPUSH
24678: CALL_OW 1
24682: ST_TO_ADDR
// end ;
24683: GO 23584
24685: POP
24686: POP
// MC_InitSides ( ) ;
24687: CALL 24973 0 0
// MC_InitResearch ( ) ;
24691: CALL 24712 0 0
// CustomInitMacro ( ) ;
24695: CALL 232 0 0
// skirmish := true ;
24699: LD_ADDR_EXP 93
24703: PUSH
24704: LD_INT 1
24706: ST_TO_ADDR
// end ;
24707: LD_VAR 0 1
24711: RET
// export function MC_InitResearch ( ) ; var i , j , nation , tmp , un ; begin
24712: LD_INT 0
24714: PPUSH
24715: PPUSH
24716: PPUSH
24717: PPUSH
24718: PPUSH
24719: PPUSH
// if not mc_bases then
24720: LD_EXP 95
24724: NOT
24725: IFFALSE 24729
// exit ;
24727: GO 24968
// for i = 1 to 8 do
24729: LD_ADDR_VAR 0 2
24733: PUSH
24734: DOUBLE
24735: LD_INT 1
24737: DEC
24738: ST_TO_ADDR
24739: LD_INT 8
24741: PUSH
24742: FOR_TO
24743: IFFALSE 24769
// mc_tech := Replace ( mc_tech , i , [ ] ) ;
24745: LD_ADDR_EXP 122
24749: PUSH
24750: LD_EXP 122
24754: PPUSH
24755: LD_VAR 0 2
24759: PPUSH
24760: EMPTY
24761: PPUSH
24762: CALL_OW 1
24766: ST_TO_ADDR
24767: GO 24742
24769: POP
24770: POP
// tmp := [ ] ;
24771: LD_ADDR_VAR 0 5
24775: PUSH
24776: EMPTY
24777: ST_TO_ADDR
// for i = 1 to mc_sides do
24778: LD_ADDR_VAR 0 2
24782: PUSH
24783: DOUBLE
24784: LD_INT 1
24786: DEC
24787: ST_TO_ADDR
24788: LD_EXP 121
24792: PUSH
24793: FOR_TO
24794: IFFALSE 24852
// if not mc_sides [ i ] in tmp then
24796: LD_EXP 121
24800: PUSH
24801: LD_VAR 0 2
24805: ARRAY
24806: PUSH
24807: LD_VAR 0 5
24811: IN
24812: NOT
24813: IFFALSE 24850
// tmp := Insert ( tmp , tmp + 1 , mc_sides [ i ] ) ;
24815: LD_ADDR_VAR 0 5
24819: PUSH
24820: LD_VAR 0 5
24824: PPUSH
24825: LD_VAR 0 5
24829: PUSH
24830: LD_INT 1
24832: PLUS
24833: PPUSH
24834: LD_EXP 121
24838: PUSH
24839: LD_VAR 0 2
24843: ARRAY
24844: PPUSH
24845: CALL_OW 2
24849: ST_TO_ADDR
24850: GO 24793
24852: POP
24853: POP
// if not tmp then
24854: LD_VAR 0 5
24858: NOT
24859: IFFALSE 24863
// exit ;
24861: GO 24968
// for j in tmp do
24863: LD_ADDR_VAR 0 3
24867: PUSH
24868: LD_VAR 0 5
24872: PUSH
24873: FOR_IN
24874: IFFALSE 24966
// begin un := FilterAllUnits ( [ f_side , j ] ) ;
24876: LD_ADDR_VAR 0 6
24880: PUSH
24881: LD_INT 22
24883: PUSH
24884: LD_VAR 0 3
24888: PUSH
24889: EMPTY
24890: LIST
24891: LIST
24892: PPUSH
24893: CALL_OW 69
24897: ST_TO_ADDR
// if not un then
24898: LD_VAR 0 6
24902: NOT
24903: IFFALSE 24907
// continue ;
24905: GO 24873
// nation := GetNation ( un [ 1 ] ) ;
24907: LD_ADDR_VAR 0 4
24911: PUSH
24912: LD_VAR 0 6
24916: PUSH
24917: LD_INT 1
24919: ARRAY
24920: PPUSH
24921: CALL_OW 248
24925: ST_TO_ADDR
// mc_tech := Replace ( mc_tech , j , GetTechNation ( j , nation , state_enabled ) ) ;
24926: LD_ADDR_EXP 122
24930: PUSH
24931: LD_EXP 122
24935: PPUSH
24936: LD_VAR 0 3
24940: PPUSH
24941: LD_VAR 0 3
24945: PPUSH
24946: LD_VAR 0 4
24950: PPUSH
24951: LD_INT 1
24953: PPUSH
24954: CALL 52089 0 3
24958: PPUSH
24959: CALL_OW 1
24963: ST_TO_ADDR
// end ;
24964: GO 24873
24966: POP
24967: POP
// end ;
24968: LD_VAR 0 1
24972: RET
// export function MC_InitSides ( ) ; var i ; begin
24973: LD_INT 0
24975: PPUSH
24976: PPUSH
// if not mc_bases then
24977: LD_EXP 95
24981: NOT
24982: IFFALSE 24986
// exit ;
24984: GO 25060
// for i = 1 to mc_bases do
24986: LD_ADDR_VAR 0 2
24990: PUSH
24991: DOUBLE
24992: LD_INT 1
24994: DEC
24995: ST_TO_ADDR
24996: LD_EXP 95
25000: PUSH
25001: FOR_TO
25002: IFFALSE 25058
// if mc_bases [ i ] then
25004: LD_EXP 95
25008: PUSH
25009: LD_VAR 0 2
25013: ARRAY
25014: IFFALSE 25056
// mc_sides := Replace ( mc_sides , i , GetSide ( mc_bases [ i ] [ 1 ] ) ) ;
25016: LD_ADDR_EXP 121
25020: PUSH
25021: LD_EXP 121
25025: PPUSH
25026: LD_VAR 0 2
25030: PPUSH
25031: LD_EXP 95
25035: PUSH
25036: LD_VAR 0 2
25040: ARRAY
25041: PUSH
25042: LD_INT 1
25044: ARRAY
25045: PPUSH
25046: CALL_OW 255
25050: PPUSH
25051: CALL_OW 1
25055: ST_TO_ADDR
25056: GO 25001
25058: POP
25059: POP
// end ;
25060: LD_VAR 0 1
25064: RET
// every 0 0$03 trigger skirmish do
25065: LD_EXP 93
25069: IFFALSE 25223
25071: GO 25073
25073: DISABLE
// begin enable ;
25074: ENABLE
// MC_CheckBuildings ( ) ;
25075: CALL 29721 0 0
// MC_CheckPeopleLife ( ) ;
25079: CALL 29882 0 0
// RaiseSailEvent ( 100 ) ;
25083: LD_INT 100
25085: PPUSH
25086: CALL_OW 427
// RaiseSailEvent ( 103 ) ;
25090: LD_INT 103
25092: PPUSH
25093: CALL_OW 427
// RaiseSailEvent ( 104 ) ;
25097: LD_INT 104
25099: PPUSH
25100: CALL_OW 427
// RaiseSailEvent ( 105 ) ;
25104: LD_INT 105
25106: PPUSH
25107: CALL_OW 427
// RaiseSailEvent ( 106 ) ;
25111: LD_INT 106
25113: PPUSH
25114: CALL_OW 427
// RaiseSailEvent ( 107 ) ;
25118: LD_INT 107
25120: PPUSH
25121: CALL_OW 427
// RaiseSailEvent ( 108 ) ;
25125: LD_INT 108
25127: PPUSH
25128: CALL_OW 427
// RaiseSailEvent ( 109 ) ;
25132: LD_INT 109
25134: PPUSH
25135: CALL_OW 427
// RaiseSailEvent ( 110 ) ;
25139: LD_INT 110
25141: PPUSH
25142: CALL_OW 427
// RaiseSailEvent ( 111 ) ;
25146: LD_INT 111
25148: PPUSH
25149: CALL_OW 427
// RaiseSailEvent ( 112 ) ;
25153: LD_INT 112
25155: PPUSH
25156: CALL_OW 427
// RaiseSailEvent ( 113 ) ;
25160: LD_INT 113
25162: PPUSH
25163: CALL_OW 427
// RaiseSailEvent ( 120 ) ;
25167: LD_INT 120
25169: PPUSH
25170: CALL_OW 427
// RaiseSailEvent ( 121 ) ;
25174: LD_INT 121
25176: PPUSH
25177: CALL_OW 427
// RaiseSailEvent ( 122 ) ;
25181: LD_INT 122
25183: PPUSH
25184: CALL_OW 427
// RaiseSailEvent ( 123 ) ;
25188: LD_INT 123
25190: PPUSH
25191: CALL_OW 427
// RaiseSailEvent ( 124 ) ;
25195: LD_INT 124
25197: PPUSH
25198: CALL_OW 427
// RaiseSailEvent ( 125 ) ;
25202: LD_INT 125
25204: PPUSH
25205: CALL_OW 427
// RaiseSailEvent ( 126 ) ;
25209: LD_INT 126
25211: PPUSH
25212: CALL_OW 427
// RaiseSailEvent ( 200 ) ;
25216: LD_INT 200
25218: PPUSH
25219: CALL_OW 427
// end ;
25223: END
// on SailEvent ( event ) do begin if event < 100 then
25224: LD_VAR 0 1
25228: PUSH
25229: LD_INT 100
25231: LESS
25232: IFFALSE 25243
// CustomEvent ( event ) ;
25234: LD_VAR 0 1
25238: PPUSH
25239: CALL 10899 0 1
// if event = 100 then
25243: LD_VAR 0 1
25247: PUSH
25248: LD_INT 100
25250: EQUAL
25251: IFFALSE 25257
// MC_ClassManager ( ) ;
25253: CALL 25649 0 0
// if event = 101 then
25257: LD_VAR 0 1
25261: PUSH
25262: LD_INT 101
25264: EQUAL
25265: IFFALSE 25271
// MC_RepairBuildings ( ) ;
25267: CALL 30467 0 0
// if event = 102 then
25271: LD_VAR 0 1
25275: PUSH
25276: LD_INT 102
25278: EQUAL
25279: IFFALSE 25285
// MC_Heal ( ) ;
25281: CALL 31374 0 0
// if event = 103 then
25285: LD_VAR 0 1
25289: PUSH
25290: LD_INT 103
25292: EQUAL
25293: IFFALSE 25299
// MC_Build ( ) ;
25295: CALL 31796 0 0
// if event = 104 then
25299: LD_VAR 0 1
25303: PUSH
25304: LD_INT 104
25306: EQUAL
25307: IFFALSE 25313
// MC_TurretWeapon ( ) ;
25309: CALL 33437 0 0
// if event = 105 then
25313: LD_VAR 0 1
25317: PUSH
25318: LD_INT 105
25320: EQUAL
25321: IFFALSE 25327
// MC_BuildUpgrade ( ) ;
25323: CALL 32988 0 0
// if event = 106 then
25327: LD_VAR 0 1
25331: PUSH
25332: LD_INT 106
25334: EQUAL
25335: IFFALSE 25341
// MC_PlantMines ( ) ;
25337: CALL 33867 0 0
// if event = 107 then
25341: LD_VAR 0 1
25345: PUSH
25346: LD_INT 107
25348: EQUAL
25349: IFFALSE 25355
// MC_CollectCrates ( ) ;
25351: CALL 34658 0 0
// if event = 108 then
25355: LD_VAR 0 1
25359: PUSH
25360: LD_INT 108
25362: EQUAL
25363: IFFALSE 25369
// MC_LinkRemoteControl ( ) ;
25365: CALL 36508 0 0
// if event = 109 then
25369: LD_VAR 0 1
25373: PUSH
25374: LD_INT 109
25376: EQUAL
25377: IFFALSE 25383
// MC_ProduceVehicle ( ) ;
25379: CALL 36689 0 0
// if event = 110 then
25383: LD_VAR 0 1
25387: PUSH
25388: LD_INT 110
25390: EQUAL
25391: IFFALSE 25397
// MC_SendAttack ( ) ;
25393: CALL 37155 0 0
// if event = 111 then
25397: LD_VAR 0 1
25401: PUSH
25402: LD_INT 111
25404: EQUAL
25405: IFFALSE 25411
// MC_Defend ( ) ;
25407: CALL 37263 0 0
// if event = 112 then
25411: LD_VAR 0 1
25415: PUSH
25416: LD_INT 112
25418: EQUAL
25419: IFFALSE 25425
// MC_Research ( ) ;
25421: CALL 38143 0 0
// if event = 113 then
25425: LD_VAR 0 1
25429: PUSH
25430: LD_INT 113
25432: EQUAL
25433: IFFALSE 25439
// MC_MinesTrigger ( ) ;
25435: CALL 39257 0 0
// if event = 120 then
25439: LD_VAR 0 1
25443: PUSH
25444: LD_INT 120
25446: EQUAL
25447: IFFALSE 25453
// MC_RepairVehicle ( ) ;
25449: CALL 39356 0 0
// if event = 121 then
25453: LD_VAR 0 1
25457: PUSH
25458: LD_INT 121
25460: EQUAL
25461: IFFALSE 25467
// MC_TameApe ( ) ;
25463: CALL 40097 0 0
// if event = 122 then
25467: LD_VAR 0 1
25471: PUSH
25472: LD_INT 122
25474: EQUAL
25475: IFFALSE 25481
// MC_ChangeApeClass ( ) ;
25477: CALL 40926 0 0
// if event = 123 then
25481: LD_VAR 0 1
25485: PUSH
25486: LD_INT 123
25488: EQUAL
25489: IFFALSE 25495
// MC_Bazooka ( ) ;
25491: CALL 41576 0 0
// if event = 124 then
25495: LD_VAR 0 1
25499: PUSH
25500: LD_INT 124
25502: EQUAL
25503: IFFALSE 25509
// MC_TeleportExit ( ) ;
25505: CALL 41774 0 0
// if event = 125 then
25509: LD_VAR 0 1
25513: PUSH
25514: LD_INT 125
25516: EQUAL
25517: IFFALSE 25523
// MC_Deposits ( ) ;
25519: CALL 42421 0 0
// if event = 126 then
25523: LD_VAR 0 1
25527: PUSH
25528: LD_INT 126
25530: EQUAL
25531: IFFALSE 25537
// MC_RemoteDriver ( ) ;
25533: CALL 43046 0 0
// if event = 200 then
25537: LD_VAR 0 1
25541: PUSH
25542: LD_INT 200
25544: EQUAL
25545: IFFALSE 25551
// MC_Idle ( ) ;
25547: CALL 44995 0 0
// end ;
25551: PPOPN 1
25553: END
// export function MC_Reset ( base , tag ) ; var i ; begin
25554: LD_INT 0
25556: PPUSH
25557: PPUSH
// if not mc_bases [ base ] or not tag then
25558: LD_EXP 95
25562: PUSH
25563: LD_VAR 0 1
25567: ARRAY
25568: NOT
25569: PUSH
25570: LD_VAR 0 2
25574: NOT
25575: OR
25576: IFFALSE 25580
// exit ;
25578: GO 25644
// for i in mc_bases [ base ] union mc_ape [ base ] do
25580: LD_ADDR_VAR 0 4
25584: PUSH
25585: LD_EXP 95
25589: PUSH
25590: LD_VAR 0 1
25594: ARRAY
25595: PUSH
25596: LD_EXP 124
25600: PUSH
25601: LD_VAR 0 1
25605: ARRAY
25606: UNION
25607: PUSH
25608: FOR_IN
25609: IFFALSE 25642
// if GetTag ( i ) = tag then
25611: LD_VAR 0 4
25615: PPUSH
25616: CALL_OW 110
25620: PUSH
25621: LD_VAR 0 2
25625: EQUAL
25626: IFFALSE 25640
// SetTag ( i , 0 ) ;
25628: LD_VAR 0 4
25632: PPUSH
25633: LD_INT 0
25635: PPUSH
25636: CALL_OW 109
25640: GO 25608
25642: POP
25643: POP
// end ;
25644: LD_VAR 0 3
25648: RET
// export function MC_ClassManager ( ) ; var i , j , tmp , p , b , e , k ; begin
25649: LD_INT 0
25651: PPUSH
25652: PPUSH
25653: PPUSH
25654: PPUSH
25655: PPUSH
25656: PPUSH
25657: PPUSH
25658: PPUSH
// if not mc_bases then
25659: LD_EXP 95
25663: NOT
25664: IFFALSE 25668
// exit ;
25666: GO 26126
// for i = 1 to mc_bases do
25668: LD_ADDR_VAR 0 2
25672: PUSH
25673: DOUBLE
25674: LD_INT 1
25676: DEC
25677: ST_TO_ADDR
25678: LD_EXP 95
25682: PUSH
25683: FOR_TO
25684: IFFALSE 26124
// begin tmp := MC_ClassCheckReq ( i ) ;
25686: LD_ADDR_VAR 0 4
25690: PUSH
25691: LD_VAR 0 2
25695: PPUSH
25696: CALL 26131 0 1
25700: ST_TO_ADDR
// mc_class := Replace ( mc_class , i , tmp ) ;
25701: LD_ADDR_EXP 136
25705: PUSH
25706: LD_EXP 136
25710: PPUSH
25711: LD_VAR 0 2
25715: PPUSH
25716: LD_VAR 0 4
25720: PPUSH
25721: CALL_OW 1
25725: ST_TO_ADDR
// if not tmp then
25726: LD_VAR 0 4
25730: NOT
25731: IFFALSE 25735
// continue ;
25733: GO 25683
// b := [ UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_armoury ] , [ f_btype , b_barracks ] ] ) , UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) , UnitFilter ( mc_bases [ i ] , [ f_btype , b_factory ] ) , UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_lab ] , [ f_btype , b_lab_half ] , [ f_btype , b_lab_full ] ] ) ] ;
25735: LD_ADDR_VAR 0 6
25739: PUSH
25740: LD_EXP 95
25744: PUSH
25745: LD_VAR 0 2
25749: ARRAY
25750: PPUSH
25751: LD_INT 2
25753: PUSH
25754: LD_INT 30
25756: PUSH
25757: LD_INT 4
25759: PUSH
25760: EMPTY
25761: LIST
25762: LIST
25763: PUSH
25764: LD_INT 30
25766: PUSH
25767: LD_INT 5
25769: PUSH
25770: EMPTY
25771: LIST
25772: LIST
25773: PUSH
25774: EMPTY
25775: LIST
25776: LIST
25777: LIST
25778: PPUSH
25779: CALL_OW 72
25783: PUSH
25784: LD_EXP 95
25788: PUSH
25789: LD_VAR 0 2
25793: ARRAY
25794: PPUSH
25795: LD_INT 2
25797: PUSH
25798: LD_INT 30
25800: PUSH
25801: LD_INT 0
25803: PUSH
25804: EMPTY
25805: LIST
25806: LIST
25807: PUSH
25808: LD_INT 30
25810: PUSH
25811: LD_INT 1
25813: PUSH
25814: EMPTY
25815: LIST
25816: LIST
25817: PUSH
25818: EMPTY
25819: LIST
25820: LIST
25821: LIST
25822: PPUSH
25823: CALL_OW 72
25827: PUSH
25828: LD_EXP 95
25832: PUSH
25833: LD_VAR 0 2
25837: ARRAY
25838: PPUSH
25839: LD_INT 30
25841: PUSH
25842: LD_INT 3
25844: PUSH
25845: EMPTY
25846: LIST
25847: LIST
25848: PPUSH
25849: CALL_OW 72
25853: PUSH
25854: LD_EXP 95
25858: PUSH
25859: LD_VAR 0 2
25863: ARRAY
25864: PPUSH
25865: LD_INT 2
25867: PUSH
25868: LD_INT 30
25870: PUSH
25871: LD_INT 6
25873: PUSH
25874: EMPTY
25875: LIST
25876: LIST
25877: PUSH
25878: LD_INT 30
25880: PUSH
25881: LD_INT 7
25883: PUSH
25884: EMPTY
25885: LIST
25886: LIST
25887: PUSH
25888: LD_INT 30
25890: PUSH
25891: LD_INT 8
25893: PUSH
25894: EMPTY
25895: LIST
25896: LIST
25897: PUSH
25898: EMPTY
25899: LIST
25900: LIST
25901: LIST
25902: LIST
25903: PPUSH
25904: CALL_OW 72
25908: PUSH
25909: EMPTY
25910: LIST
25911: LIST
25912: LIST
25913: LIST
25914: ST_TO_ADDR
// for j = 1 to 4 do
25915: LD_ADDR_VAR 0 3
25919: PUSH
25920: DOUBLE
25921: LD_INT 1
25923: DEC
25924: ST_TO_ADDR
25925: LD_INT 4
25927: PUSH
25928: FOR_TO
25929: IFFALSE 26120
// begin if not tmp [ j ] then
25931: LD_VAR 0 4
25935: PUSH
25936: LD_VAR 0 3
25940: ARRAY
25941: NOT
25942: IFFALSE 25946
// continue ;
25944: GO 25928
// for p in tmp [ j ] do
25946: LD_ADDR_VAR 0 5
25950: PUSH
25951: LD_VAR 0 4
25955: PUSH
25956: LD_VAR 0 3
25960: ARRAY
25961: PUSH
25962: FOR_IN
25963: IFFALSE 26116
// begin if not b [ j ] then
25965: LD_VAR 0 6
25969: PUSH
25970: LD_VAR 0 3
25974: ARRAY
25975: NOT
25976: IFFALSE 25980
// break ;
25978: GO 26116
// e := 0 ;
25980: LD_ADDR_VAR 0 7
25984: PUSH
25985: LD_INT 0
25987: ST_TO_ADDR
// for k in b [ j ] do
25988: LD_ADDR_VAR 0 8
25992: PUSH
25993: LD_VAR 0 6
25997: PUSH
25998: LD_VAR 0 3
26002: ARRAY
26003: PUSH
26004: FOR_IN
26005: IFFALSE 26032
// if IsNotFull ( k ) then
26007: LD_VAR 0 8
26011: PPUSH
26012: CALL 54242 0 1
26016: IFFALSE 26030
// begin e := k ;
26018: LD_ADDR_VAR 0 7
26022: PUSH
26023: LD_VAR 0 8
26027: ST_TO_ADDR
// break ;
26028: GO 26032
// end ;
26030: GO 26004
26032: POP
26033: POP
// if e and not UnitGoingToBuilding ( p , e ) then
26034: LD_VAR 0 7
26038: PUSH
26039: LD_VAR 0 5
26043: PPUSH
26044: LD_VAR 0 7
26048: PPUSH
26049: CALL 87406 0 2
26053: NOT
26054: AND
26055: IFFALSE 26114
// begin if IsInUnit ( p ) then
26057: LD_VAR 0 5
26061: PPUSH
26062: CALL_OW 310
26066: IFFALSE 26077
// ComExitBuilding ( p ) ;
26068: LD_VAR 0 5
26072: PPUSH
26073: CALL_OW 122
// ComEnterUnit ( p , e ) ;
26077: LD_VAR 0 5
26081: PPUSH
26082: LD_VAR 0 7
26086: PPUSH
26087: CALL_OW 120
// AddComChangeProfession ( p , j ) ;
26091: LD_VAR 0 5
26095: PPUSH
26096: LD_VAR 0 3
26100: PPUSH
26101: CALL_OW 183
// AddComExitBuilding ( p ) ;
26105: LD_VAR 0 5
26109: PPUSH
26110: CALL_OW 182
// end ; end ;
26114: GO 25962
26116: POP
26117: POP
// end ;
26118: GO 25928
26120: POP
26121: POP
// end ;
26122: GO 25683
26124: POP
26125: POP
// end ;
26126: LD_VAR 0 1
26130: RET
// export function MC_ClassCheckReq ( base ) ; var i , tmp , sol , eng , mech , sci , sort , j , p , b , bcount ; begin
26131: LD_INT 0
26133: PPUSH
26134: PPUSH
26135: PPUSH
26136: PPUSH
26137: PPUSH
26138: PPUSH
26139: PPUSH
26140: PPUSH
26141: PPUSH
26142: PPUSH
26143: PPUSH
26144: PPUSH
// if not base or not mc_bases [ base ] or not UnitFilter ( mc_bases [ base ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) then
26145: LD_VAR 0 1
26149: NOT
26150: PUSH
26151: LD_EXP 95
26155: PUSH
26156: LD_VAR 0 1
26160: ARRAY
26161: NOT
26162: OR
26163: PUSH
26164: LD_EXP 95
26168: PUSH
26169: LD_VAR 0 1
26173: ARRAY
26174: PPUSH
26175: LD_INT 2
26177: PUSH
26178: LD_INT 30
26180: PUSH
26181: LD_INT 0
26183: PUSH
26184: EMPTY
26185: LIST
26186: LIST
26187: PUSH
26188: LD_INT 30
26190: PUSH
26191: LD_INT 1
26193: PUSH
26194: EMPTY
26195: LIST
26196: LIST
26197: PUSH
26198: EMPTY
26199: LIST
26200: LIST
26201: LIST
26202: PPUSH
26203: CALL_OW 72
26207: NOT
26208: OR
26209: IFFALSE 26213
// exit ;
26211: GO 29716
// tmp := UnitFilter ( mc_bases [ base ] , [ f_or , [ f_class , 1 ] , [ f_class , 2 ] , [ f_class , 3 ] , [ f_class , 4 ] , [ f_class , 5 ] , [ f_class , 8 ] , [ f_class , 9 ] ] ) ;
26213: LD_ADDR_VAR 0 4
26217: PUSH
26218: LD_EXP 95
26222: PUSH
26223: LD_VAR 0 1
26227: ARRAY
26228: PPUSH
26229: LD_INT 2
26231: PUSH
26232: LD_INT 25
26234: PUSH
26235: LD_INT 1
26237: PUSH
26238: EMPTY
26239: LIST
26240: LIST
26241: PUSH
26242: LD_INT 25
26244: PUSH
26245: LD_INT 2
26247: PUSH
26248: EMPTY
26249: LIST
26250: LIST
26251: PUSH
26252: LD_INT 25
26254: PUSH
26255: LD_INT 3
26257: PUSH
26258: EMPTY
26259: LIST
26260: LIST
26261: PUSH
26262: LD_INT 25
26264: PUSH
26265: LD_INT 4
26267: PUSH
26268: EMPTY
26269: LIST
26270: LIST
26271: PUSH
26272: LD_INT 25
26274: PUSH
26275: LD_INT 5
26277: PUSH
26278: EMPTY
26279: LIST
26280: LIST
26281: PUSH
26282: LD_INT 25
26284: PUSH
26285: LD_INT 8
26287: PUSH
26288: EMPTY
26289: LIST
26290: LIST
26291: PUSH
26292: LD_INT 25
26294: PUSH
26295: LD_INT 9
26297: PUSH
26298: EMPTY
26299: LIST
26300: LIST
26301: PUSH
26302: EMPTY
26303: LIST
26304: LIST
26305: LIST
26306: LIST
26307: LIST
26308: LIST
26309: LIST
26310: LIST
26311: PPUSH
26312: CALL_OW 72
26316: ST_TO_ADDR
// if not tmp then
26317: LD_VAR 0 4
26321: NOT
26322: IFFALSE 26326
// exit ;
26324: GO 29716
// for i in tmp do
26326: LD_ADDR_VAR 0 3
26330: PUSH
26331: LD_VAR 0 4
26335: PUSH
26336: FOR_IN
26337: IFFALSE 26368
// if GetTag ( i ) then
26339: LD_VAR 0 3
26343: PPUSH
26344: CALL_OW 110
26348: IFFALSE 26366
// tmp := tmp diff i ;
26350: LD_ADDR_VAR 0 4
26354: PUSH
26355: LD_VAR 0 4
26359: PUSH
26360: LD_VAR 0 3
26364: DIFF
26365: ST_TO_ADDR
26366: GO 26336
26368: POP
26369: POP
// if not tmp then
26370: LD_VAR 0 4
26374: NOT
26375: IFFALSE 26379
// exit ;
26377: GO 29716
// sol := UnitFilter ( mc_bases [ base ] , [ f_or , [ f_class , 1 ] , [ f_class , 5 ] , [ f_class , 8 ] , [ f_class , 9 ] ] ) ;
26379: LD_ADDR_VAR 0 5
26383: PUSH
26384: LD_EXP 95
26388: PUSH
26389: LD_VAR 0 1
26393: ARRAY
26394: PPUSH
26395: LD_INT 2
26397: PUSH
26398: LD_INT 25
26400: PUSH
26401: LD_INT 1
26403: PUSH
26404: EMPTY
26405: LIST
26406: LIST
26407: PUSH
26408: LD_INT 25
26410: PUSH
26411: LD_INT 5
26413: PUSH
26414: EMPTY
26415: LIST
26416: LIST
26417: PUSH
26418: LD_INT 25
26420: PUSH
26421: LD_INT 8
26423: PUSH
26424: EMPTY
26425: LIST
26426: LIST
26427: PUSH
26428: LD_INT 25
26430: PUSH
26431: LD_INT 9
26433: PUSH
26434: EMPTY
26435: LIST
26436: LIST
26437: PUSH
26438: EMPTY
26439: LIST
26440: LIST
26441: LIST
26442: LIST
26443: LIST
26444: PPUSH
26445: CALL_OW 72
26449: ST_TO_ADDR
// eng := UnitFilter ( mc_bases [ base ] , [ f_class , 2 ] ) ;
26450: LD_ADDR_VAR 0 6
26454: PUSH
26455: LD_EXP 95
26459: PUSH
26460: LD_VAR 0 1
26464: ARRAY
26465: PPUSH
26466: LD_INT 25
26468: PUSH
26469: LD_INT 2
26471: PUSH
26472: EMPTY
26473: LIST
26474: LIST
26475: PPUSH
26476: CALL_OW 72
26480: ST_TO_ADDR
// mech := UnitFilter ( mc_bases [ base ] , [ f_class , 3 ] ) ;
26481: LD_ADDR_VAR 0 7
26485: PUSH
26486: LD_EXP 95
26490: PUSH
26491: LD_VAR 0 1
26495: ARRAY
26496: PPUSH
26497: LD_INT 25
26499: PUSH
26500: LD_INT 3
26502: PUSH
26503: EMPTY
26504: LIST
26505: LIST
26506: PPUSH
26507: CALL_OW 72
26511: ST_TO_ADDR
// sci := UnitFilter ( mc_bases [ base ] , [ [ f_class , 4 ] , [ f_lives , 251 ] ] ) ;
26512: LD_ADDR_VAR 0 8
26516: PUSH
26517: LD_EXP 95
26521: PUSH
26522: LD_VAR 0 1
26526: ARRAY
26527: PPUSH
26528: LD_INT 25
26530: PUSH
26531: LD_INT 4
26533: PUSH
26534: EMPTY
26535: LIST
26536: LIST
26537: PUSH
26538: LD_INT 24
26540: PUSH
26541: LD_INT 251
26543: PUSH
26544: EMPTY
26545: LIST
26546: LIST
26547: PUSH
26548: EMPTY
26549: LIST
26550: LIST
26551: PPUSH
26552: CALL_OW 72
26556: ST_TO_ADDR
// if mc_is_defending [ base ] then
26557: LD_EXP 138
26561: PUSH
26562: LD_VAR 0 1
26566: ARRAY
26567: IFFALSE 27028
// begin mc_class_case_use := Replace ( mc_class_case_use , base , 4 ) ;
26569: LD_ADDR_EXP 137
26573: PUSH
26574: LD_EXP 137
26578: PPUSH
26579: LD_VAR 0 1
26583: PPUSH
26584: LD_INT 4
26586: PPUSH
26587: CALL_OW 1
26591: ST_TO_ADDR
// b := UnitFilter ( mc_bases [ base ] , [ f_or , [ f_btype , b_armoury ] , [ f_btype , b_barracks ] ] ) ;
26592: LD_ADDR_VAR 0 12
26596: PUSH
26597: LD_EXP 95
26601: PUSH
26602: LD_VAR 0 1
26606: ARRAY
26607: PPUSH
26608: LD_INT 2
26610: PUSH
26611: LD_INT 30
26613: PUSH
26614: LD_INT 4
26616: PUSH
26617: EMPTY
26618: LIST
26619: LIST
26620: PUSH
26621: LD_INT 30
26623: PUSH
26624: LD_INT 5
26626: PUSH
26627: EMPTY
26628: LIST
26629: LIST
26630: PUSH
26631: EMPTY
26632: LIST
26633: LIST
26634: LIST
26635: PPUSH
26636: CALL_OW 72
26640: ST_TO_ADDR
// if not b then
26641: LD_VAR 0 12
26645: NOT
26646: IFFALSE 26650
// exit ;
26648: GO 29716
// p := [ ] ;
26650: LD_ADDR_VAR 0 11
26654: PUSH
26655: EMPTY
26656: ST_TO_ADDR
// if sci >= 2 then
26657: LD_VAR 0 8
26661: PUSH
26662: LD_INT 2
26664: GREATEREQUAL
26665: IFFALSE 26696
// sci := [ sci [ 1 ] , sci [ 2 ] ] else
26667: LD_ADDR_VAR 0 8
26671: PUSH
26672: LD_VAR 0 8
26676: PUSH
26677: LD_INT 1
26679: ARRAY
26680: PUSH
26681: LD_VAR 0 8
26685: PUSH
26686: LD_INT 2
26688: ARRAY
26689: PUSH
26690: EMPTY
26691: LIST
26692: LIST
26693: ST_TO_ADDR
26694: GO 26757
// if sci = 1 then
26696: LD_VAR 0 8
26700: PUSH
26701: LD_INT 1
26703: EQUAL
26704: IFFALSE 26725
// sci := [ sci [ 1 ] ] else
26706: LD_ADDR_VAR 0 8
26710: PUSH
26711: LD_VAR 0 8
26715: PUSH
26716: LD_INT 1
26718: ARRAY
26719: PUSH
26720: EMPTY
26721: LIST
26722: ST_TO_ADDR
26723: GO 26757
// if sci = 0 then
26725: LD_VAR 0 8
26729: PUSH
26730: LD_INT 0
26732: EQUAL
26733: IFFALSE 26757
// p := SortBySkill ( tmp , 4 ) [ 1 ] ;
26735: LD_ADDR_VAR 0 11
26739: PUSH
26740: LD_VAR 0 4
26744: PPUSH
26745: LD_INT 4
26747: PPUSH
26748: CALL 87269 0 2
26752: PUSH
26753: LD_INT 1
26755: ARRAY
26756: ST_TO_ADDR
// if eng > 4 then
26757: LD_VAR 0 6
26761: PUSH
26762: LD_INT 4
26764: GREATER
26765: IFFALSE 26811
// for i = eng downto 4 do
26767: LD_ADDR_VAR 0 3
26771: PUSH
26772: DOUBLE
26773: LD_VAR 0 6
26777: INC
26778: ST_TO_ADDR
26779: LD_INT 4
26781: PUSH
26782: FOR_DOWNTO
26783: IFFALSE 26809
// eng := eng diff eng [ i ] ;
26785: LD_ADDR_VAR 0 6
26789: PUSH
26790: LD_VAR 0 6
26794: PUSH
26795: LD_VAR 0 6
26799: PUSH
26800: LD_VAR 0 3
26804: ARRAY
26805: DIFF
26806: ST_TO_ADDR
26807: GO 26782
26809: POP
26810: POP
// tmp := tmp diff ( sol union eng union mech union sci ) ;
26811: LD_ADDR_VAR 0 4
26815: PUSH
26816: LD_VAR 0 4
26820: PUSH
26821: LD_VAR 0 5
26825: PUSH
26826: LD_VAR 0 6
26830: UNION
26831: PUSH
26832: LD_VAR 0 7
26836: UNION
26837: PUSH
26838: LD_VAR 0 8
26842: UNION
26843: DIFF
26844: ST_TO_ADDR
// bcount := UnitFilter ( mc_bases [ base ] , [ f_or , [ f_btype , b_bunker ] , [ f_btype , b_breastwork ] ] ) + UnitFilter ( mc_bases [ base ] , [ f_or , [ f_btype , b_armoury ] , [ f_btype , b_barracks ] ] ) * 6 ;
26845: LD_ADDR_VAR 0 13
26849: PUSH
26850: LD_EXP 95
26854: PUSH
26855: LD_VAR 0 1
26859: ARRAY
26860: PPUSH
26861: LD_INT 2
26863: PUSH
26864: LD_INT 30
26866: PUSH
26867: LD_INT 32
26869: PUSH
26870: EMPTY
26871: LIST
26872: LIST
26873: PUSH
26874: LD_INT 30
26876: PUSH
26877: LD_INT 31
26879: PUSH
26880: EMPTY
26881: LIST
26882: LIST
26883: PUSH
26884: EMPTY
26885: LIST
26886: LIST
26887: LIST
26888: PPUSH
26889: CALL_OW 72
26893: PUSH
26894: LD_EXP 95
26898: PUSH
26899: LD_VAR 0 1
26903: ARRAY
26904: PPUSH
26905: LD_INT 2
26907: PUSH
26908: LD_INT 30
26910: PUSH
26911: LD_INT 4
26913: PUSH
26914: EMPTY
26915: LIST
26916: LIST
26917: PUSH
26918: LD_INT 30
26920: PUSH
26921: LD_INT 5
26923: PUSH
26924: EMPTY
26925: LIST
26926: LIST
26927: PUSH
26928: EMPTY
26929: LIST
26930: LIST
26931: LIST
26932: PPUSH
26933: CALL_OW 72
26937: PUSH
26938: LD_INT 6
26940: MUL
26941: PLUS
26942: ST_TO_ADDR
// if bcount < tmp then
26943: LD_VAR 0 13
26947: PUSH
26948: LD_VAR 0 4
26952: LESS
26953: IFFALSE 26999
// for i = tmp downto bcount do
26955: LD_ADDR_VAR 0 3
26959: PUSH
26960: DOUBLE
26961: LD_VAR 0 4
26965: INC
26966: ST_TO_ADDR
26967: LD_VAR 0 13
26971: PUSH
26972: FOR_DOWNTO
26973: IFFALSE 26997
// tmp := Delete ( tmp , tmp ) ;
26975: LD_ADDR_VAR 0 4
26979: PUSH
26980: LD_VAR 0 4
26984: PPUSH
26985: LD_VAR 0 4
26989: PPUSH
26990: CALL_OW 3
26994: ST_TO_ADDR
26995: GO 26972
26997: POP
26998: POP
// result := [ tmp , 0 , 0 , p ] ;
26999: LD_ADDR_VAR 0 2
27003: PUSH
27004: LD_VAR 0 4
27008: PUSH
27009: LD_INT 0
27011: PUSH
27012: LD_INT 0
27014: PUSH
27015: LD_VAR 0 11
27019: PUSH
27020: EMPTY
27021: LIST
27022: LIST
27023: LIST
27024: LIST
27025: ST_TO_ADDR
// exit ;
27026: GO 29716
// end ; if not UnitFilter ( mc_bases [ base ] , [ f_or , [ f_btype , b_lab ] , [ f_btype , b_lab_half ] , [ f_btype , b_lab_full ] ] ) and not UnitFilter ( mc_bases [ base ] , [ f_btype , b_factory ] ) then
27028: LD_EXP 95
27032: PUSH
27033: LD_VAR 0 1
27037: ARRAY
27038: PPUSH
27039: LD_INT 2
27041: PUSH
27042: LD_INT 30
27044: PUSH
27045: LD_INT 6
27047: PUSH
27048: EMPTY
27049: LIST
27050: LIST
27051: PUSH
27052: LD_INT 30
27054: PUSH
27055: LD_INT 7
27057: PUSH
27058: EMPTY
27059: LIST
27060: LIST
27061: PUSH
27062: LD_INT 30
27064: PUSH
27065: LD_INT 8
27067: PUSH
27068: EMPTY
27069: LIST
27070: LIST
27071: PUSH
27072: EMPTY
27073: LIST
27074: LIST
27075: LIST
27076: LIST
27077: PPUSH
27078: CALL_OW 72
27082: NOT
27083: PUSH
27084: LD_EXP 95
27088: PUSH
27089: LD_VAR 0 1
27093: ARRAY
27094: PPUSH
27095: LD_INT 30
27097: PUSH
27098: LD_INT 3
27100: PUSH
27101: EMPTY
27102: LIST
27103: LIST
27104: PPUSH
27105: CALL_OW 72
27109: NOT
27110: AND
27111: IFFALSE 27183
// begin if eng = tmp then
27113: LD_VAR 0 6
27117: PUSH
27118: LD_VAR 0 4
27122: EQUAL
27123: IFFALSE 27127
// exit ;
27125: GO 29716
// mc_class_case_use := Replace ( mc_class_case_use , base , 1 ) ;
27127: LD_ADDR_EXP 137
27131: PUSH
27132: LD_EXP 137
27136: PPUSH
27137: LD_VAR 0 1
27141: PPUSH
27142: LD_INT 1
27144: PPUSH
27145: CALL_OW 1
27149: ST_TO_ADDR
// result := [ 0 , tmp diff eng , 0 , 0 ] ;
27150: LD_ADDR_VAR 0 2
27154: PUSH
27155: LD_INT 0
27157: PUSH
27158: LD_VAR 0 4
27162: PUSH
27163: LD_VAR 0 6
27167: DIFF
27168: PUSH
27169: LD_INT 0
27171: PUSH
27172: LD_INT 0
27174: PUSH
27175: EMPTY
27176: LIST
27177: LIST
27178: LIST
27179: LIST
27180: ST_TO_ADDR
// exit ;
27181: GO 29716
// end ; if mc_tech [ mc_sides [ base ] ] and UnitFilter ( mc_bases [ base ] , [ f_or , [ f_btype , b_lab ] , [ f_btype , b_lab_half ] , [ f_btype , b_lab_full ] ] ) and not UnitFilter ( mc_bases [ base ] , [ f_btype , b_factory ] ) then
27183: LD_EXP 122
27187: PUSH
27188: LD_EXP 121
27192: PUSH
27193: LD_VAR 0 1
27197: ARRAY
27198: ARRAY
27199: PUSH
27200: LD_EXP 95
27204: PUSH
27205: LD_VAR 0 1
27209: ARRAY
27210: PPUSH
27211: LD_INT 2
27213: PUSH
27214: LD_INT 30
27216: PUSH
27217: LD_INT 6
27219: PUSH
27220: EMPTY
27221: LIST
27222: LIST
27223: PUSH
27224: LD_INT 30
27226: PUSH
27227: LD_INT 7
27229: PUSH
27230: EMPTY
27231: LIST
27232: LIST
27233: PUSH
27234: LD_INT 30
27236: PUSH
27237: LD_INT 8
27239: PUSH
27240: EMPTY
27241: LIST
27242: LIST
27243: PUSH
27244: EMPTY
27245: LIST
27246: LIST
27247: LIST
27248: LIST
27249: PPUSH
27250: CALL_OW 72
27254: AND
27255: PUSH
27256: LD_EXP 95
27260: PUSH
27261: LD_VAR 0 1
27265: ARRAY
27266: PPUSH
27267: LD_INT 30
27269: PUSH
27270: LD_INT 3
27272: PUSH
27273: EMPTY
27274: LIST
27275: LIST
27276: PPUSH
27277: CALL_OW 72
27281: NOT
27282: AND
27283: IFFALSE 27497
// begin if sci >= 6 then
27285: LD_VAR 0 8
27289: PUSH
27290: LD_INT 6
27292: GREATEREQUAL
27293: IFFALSE 27297
// exit ;
27295: GO 29716
// mc_class_case_use := Replace ( mc_class_case_use , base , 2 ) ;
27297: LD_ADDR_EXP 137
27301: PUSH
27302: LD_EXP 137
27306: PPUSH
27307: LD_VAR 0 1
27311: PPUSH
27312: LD_INT 2
27314: PPUSH
27315: CALL_OW 1
27319: ST_TO_ADDR
// sort := SortBySkill ( tmp diff sci , 4 ) ;
27320: LD_ADDR_VAR 0 9
27324: PUSH
27325: LD_VAR 0 4
27329: PUSH
27330: LD_VAR 0 8
27334: DIFF
27335: PPUSH
27336: LD_INT 4
27338: PPUSH
27339: CALL 87269 0 2
27343: ST_TO_ADDR
// p := [ ] ;
27344: LD_ADDR_VAR 0 11
27348: PUSH
27349: EMPTY
27350: ST_TO_ADDR
// if sci < 6 and sort > 6 then
27351: LD_VAR 0 8
27355: PUSH
27356: LD_INT 6
27358: LESS
27359: PUSH
27360: LD_VAR 0 9
27364: PUSH
27365: LD_INT 6
27367: GREATER
27368: AND
27369: IFFALSE 27450
// begin for i = 1 to 6 - sci do
27371: LD_ADDR_VAR 0 3
27375: PUSH
27376: DOUBLE
27377: LD_INT 1
27379: DEC
27380: ST_TO_ADDR
27381: LD_INT 6
27383: PUSH
27384: LD_VAR 0 8
27388: MINUS
27389: PUSH
27390: FOR_TO
27391: IFFALSE 27446
// begin p := Insert ( p , p + 1 , sort [ 1 ] ) ;
27393: LD_ADDR_VAR 0 11
27397: PUSH
27398: LD_VAR 0 11
27402: PPUSH
27403: LD_VAR 0 11
27407: PUSH
27408: LD_INT 1
27410: PLUS
27411: PPUSH
27412: LD_VAR 0 9
27416: PUSH
27417: LD_INT 1
27419: ARRAY
27420: PPUSH
27421: CALL_OW 2
27425: ST_TO_ADDR
// sort := Delete ( sort , 1 ) ;
27426: LD_ADDR_VAR 0 9
27430: PUSH
27431: LD_VAR 0 9
27435: PPUSH
27436: LD_INT 1
27438: PPUSH
27439: CALL_OW 3
27443: ST_TO_ADDR
// end ;
27444: GO 27390
27446: POP
27447: POP
// end else
27448: GO 27470
// if sort then
27450: LD_VAR 0 9
27454: IFFALSE 27470
// p := sort [ 1 ] ;
27456: LD_ADDR_VAR 0 11
27460: PUSH
27461: LD_VAR 0 9
27465: PUSH
27466: LD_INT 1
27468: ARRAY
27469: ST_TO_ADDR
// result := [ 0 , 0 , 0 , p ] ;
27470: LD_ADDR_VAR 0 2
27474: PUSH
27475: LD_INT 0
27477: PUSH
27478: LD_INT 0
27480: PUSH
27481: LD_INT 0
27483: PUSH
27484: LD_VAR 0 11
27488: PUSH
27489: EMPTY
27490: LIST
27491: LIST
27492: LIST
27493: LIST
27494: ST_TO_ADDR
// exit ;
27495: GO 29716
// end ; if mc_tech [ mc_sides [ base ] ] and UnitFilter ( mc_bases [ base ] , [ f_or , [ f_btype , b_lab ] , [ f_btype , b_lab_half ] , [ f_btype , b_lab_full ] ] ) and UnitFilter ( mc_bases [ base ] , [ f_btype , b_factory ] ) then
27497: LD_EXP 122
27501: PUSH
27502: LD_EXP 121
27506: PUSH
27507: LD_VAR 0 1
27511: ARRAY
27512: ARRAY
27513: PUSH
27514: LD_EXP 95
27518: PUSH
27519: LD_VAR 0 1
27523: ARRAY
27524: PPUSH
27525: LD_INT 2
27527: PUSH
27528: LD_INT 30
27530: PUSH
27531: LD_INT 6
27533: PUSH
27534: EMPTY
27535: LIST
27536: LIST
27537: PUSH
27538: LD_INT 30
27540: PUSH
27541: LD_INT 7
27543: PUSH
27544: EMPTY
27545: LIST
27546: LIST
27547: PUSH
27548: LD_INT 30
27550: PUSH
27551: LD_INT 8
27553: PUSH
27554: EMPTY
27555: LIST
27556: LIST
27557: PUSH
27558: EMPTY
27559: LIST
27560: LIST
27561: LIST
27562: LIST
27563: PPUSH
27564: CALL_OW 72
27568: AND
27569: PUSH
27570: LD_EXP 95
27574: PUSH
27575: LD_VAR 0 1
27579: ARRAY
27580: PPUSH
27581: LD_INT 30
27583: PUSH
27584: LD_INT 3
27586: PUSH
27587: EMPTY
27588: LIST
27589: LIST
27590: PPUSH
27591: CALL_OW 72
27595: AND
27596: IFFALSE 28330
// begin mc_class_case_use := Replace ( mc_class_case_use , base , 3 ) ;
27598: LD_ADDR_EXP 137
27602: PUSH
27603: LD_EXP 137
27607: PPUSH
27608: LD_VAR 0 1
27612: PPUSH
27613: LD_INT 3
27615: PPUSH
27616: CALL_OW 1
27620: ST_TO_ADDR
// result := [ 0 , 0 , 0 , 0 ] ;
27621: LD_ADDR_VAR 0 2
27625: PUSH
27626: LD_INT 0
27628: PUSH
27629: LD_INT 0
27631: PUSH
27632: LD_INT 0
27634: PUSH
27635: LD_INT 0
27637: PUSH
27638: EMPTY
27639: LIST
27640: LIST
27641: LIST
27642: LIST
27643: ST_TO_ADDR
// if not eng then
27644: LD_VAR 0 6
27648: NOT
27649: IFFALSE 27712
// begin p := SortBySkill ( tmp , 2 ) [ 1 ] ;
27651: LD_ADDR_VAR 0 11
27655: PUSH
27656: LD_VAR 0 4
27660: PPUSH
27661: LD_INT 2
27663: PPUSH
27664: CALL 87269 0 2
27668: PUSH
27669: LD_INT 1
27671: ARRAY
27672: ST_TO_ADDR
// result := Replace ( result , 2 , p ) ;
27673: LD_ADDR_VAR 0 2
27677: PUSH
27678: LD_VAR 0 2
27682: PPUSH
27683: LD_INT 2
27685: PPUSH
27686: LD_VAR 0 11
27690: PPUSH
27691: CALL_OW 1
27695: ST_TO_ADDR
// tmp := tmp diff p ;
27696: LD_ADDR_VAR 0 4
27700: PUSH
27701: LD_VAR 0 4
27705: PUSH
27706: LD_VAR 0 11
27710: DIFF
27711: ST_TO_ADDR
// end ; if tmp and sci < 6 then
27712: LD_VAR 0 4
27716: PUSH
27717: LD_VAR 0 8
27721: PUSH
27722: LD_INT 6
27724: LESS
27725: AND
27726: IFFALSE 27914
// begin sort := SortBySkill ( tmp diff ( sci union mech ) , 4 ) ;
27728: LD_ADDR_VAR 0 9
27732: PUSH
27733: LD_VAR 0 4
27737: PUSH
27738: LD_VAR 0 8
27742: PUSH
27743: LD_VAR 0 7
27747: UNION
27748: DIFF
27749: PPUSH
27750: LD_INT 4
27752: PPUSH
27753: CALL 87269 0 2
27757: ST_TO_ADDR
// p := [ ] ;
27758: LD_ADDR_VAR 0 11
27762: PUSH
27763: EMPTY
27764: ST_TO_ADDR
// if sort then
27765: LD_VAR 0 9
27769: IFFALSE 27885
// for i = 1 to 6 - sci do
27771: LD_ADDR_VAR 0 3
27775: PUSH
27776: DOUBLE
27777: LD_INT 1
27779: DEC
27780: ST_TO_ADDR
27781: LD_INT 6
27783: PUSH
27784: LD_VAR 0 8
27788: MINUS
27789: PUSH
27790: FOR_TO
27791: IFFALSE 27883
// begin if i = sort then
27793: LD_VAR 0 3
27797: PUSH
27798: LD_VAR 0 9
27802: EQUAL
27803: IFFALSE 27807
// break ;
27805: GO 27883
// if GetClass ( i ) = 4 then
27807: LD_VAR 0 3
27811: PPUSH
27812: CALL_OW 257
27816: PUSH
27817: LD_INT 4
27819: EQUAL
27820: IFFALSE 27824
// continue ;
27822: GO 27790
// p := Insert ( p , p + 1 , sort [ i ] ) ;
27824: LD_ADDR_VAR 0 11
27828: PUSH
27829: LD_VAR 0 11
27833: PPUSH
27834: LD_VAR 0 11
27838: PUSH
27839: LD_INT 1
27841: PLUS
27842: PPUSH
27843: LD_VAR 0 9
27847: PUSH
27848: LD_VAR 0 3
27852: ARRAY
27853: PPUSH
27854: CALL_OW 2
27858: ST_TO_ADDR
// tmp := tmp diff sort [ i ] ;
27859: LD_ADDR_VAR 0 4
27863: PUSH
27864: LD_VAR 0 4
27868: PUSH
27869: LD_VAR 0 9
27873: PUSH
27874: LD_VAR 0 3
27878: ARRAY
27879: DIFF
27880: ST_TO_ADDR
// end ;
27881: GO 27790
27883: POP
27884: POP
// if p then
27885: LD_VAR 0 11
27889: IFFALSE 27914
// result := Replace ( result , 4 , p ) ;
27891: LD_ADDR_VAR 0 2
27895: PUSH
27896: LD_VAR 0 2
27900: PPUSH
27901: LD_INT 4
27903: PPUSH
27904: LD_VAR 0 11
27908: PPUSH
27909: CALL_OW 1
27913: ST_TO_ADDR
// end ; if tmp and mech < 6 then
27914: LD_VAR 0 4
27918: PUSH
27919: LD_VAR 0 7
27923: PUSH
27924: LD_INT 6
27926: LESS
27927: AND
27928: IFFALSE 28116
// begin sort := SortBySkill ( tmp diff ( sci union mech ) , 3 ) ;
27930: LD_ADDR_VAR 0 9
27934: PUSH
27935: LD_VAR 0 4
27939: PUSH
27940: LD_VAR 0 8
27944: PUSH
27945: LD_VAR 0 7
27949: UNION
27950: DIFF
27951: PPUSH
27952: LD_INT 3
27954: PPUSH
27955: CALL 87269 0 2
27959: ST_TO_ADDR
// p := [ ] ;
27960: LD_ADDR_VAR 0 11
27964: PUSH
27965: EMPTY
27966: ST_TO_ADDR
// if sort then
27967: LD_VAR 0 9
27971: IFFALSE 28087
// for i = 1 to 6 - mech do
27973: LD_ADDR_VAR 0 3
27977: PUSH
27978: DOUBLE
27979: LD_INT 1
27981: DEC
27982: ST_TO_ADDR
27983: LD_INT 6
27985: PUSH
27986: LD_VAR 0 7
27990: MINUS
27991: PUSH
27992: FOR_TO
27993: IFFALSE 28085
// begin if i = sort then
27995: LD_VAR 0 3
27999: PUSH
28000: LD_VAR 0 9
28004: EQUAL
28005: IFFALSE 28009
// break ;
28007: GO 28085
// if GetClass ( i ) = 3 then
28009: LD_VAR 0 3
28013: PPUSH
28014: CALL_OW 257
28018: PUSH
28019: LD_INT 3
28021: EQUAL
28022: IFFALSE 28026
// continue ;
28024: GO 27992
// p := Insert ( p , p + 1 , sort [ i ] ) ;
28026: LD_ADDR_VAR 0 11
28030: PUSH
28031: LD_VAR 0 11
28035: PPUSH
28036: LD_VAR 0 11
28040: PUSH
28041: LD_INT 1
28043: PLUS
28044: PPUSH
28045: LD_VAR 0 9
28049: PUSH
28050: LD_VAR 0 3
28054: ARRAY
28055: PPUSH
28056: CALL_OW 2
28060: ST_TO_ADDR
// tmp := tmp diff sort [ i ] ;
28061: LD_ADDR_VAR 0 4
28065: PUSH
28066: LD_VAR 0 4
28070: PUSH
28071: LD_VAR 0 9
28075: PUSH
28076: LD_VAR 0 3
28080: ARRAY
28081: DIFF
28082: ST_TO_ADDR
// end ;
28083: GO 27992
28085: POP
28086: POP
// if p then
28087: LD_VAR 0 11
28091: IFFALSE 28116
// result := Replace ( result , 3 , p ) ;
28093: LD_ADDR_VAR 0 2
28097: PUSH
28098: LD_VAR 0 2
28102: PPUSH
28103: LD_INT 3
28105: PPUSH
28106: LD_VAR 0 11
28110: PPUSH
28111: CALL_OW 1
28115: ST_TO_ADDR
// end ; if tmp > 6 and eng < 6 then
28116: LD_VAR 0 4
28120: PUSH
28121: LD_INT 6
28123: GREATER
28124: PUSH
28125: LD_VAR 0 6
28129: PUSH
28130: LD_INT 6
28132: LESS
28133: AND
28134: IFFALSE 28328
// begin sort := SortBySkill ( tmp diff ( sci union mech union eng ) , 2 ) ;
28136: LD_ADDR_VAR 0 9
28140: PUSH
28141: LD_VAR 0 4
28145: PUSH
28146: LD_VAR 0 8
28150: PUSH
28151: LD_VAR 0 7
28155: UNION
28156: PUSH
28157: LD_VAR 0 6
28161: UNION
28162: DIFF
28163: PPUSH
28164: LD_INT 2
28166: PPUSH
28167: CALL 87269 0 2
28171: ST_TO_ADDR
// p := [ ] ;
28172: LD_ADDR_VAR 0 11
28176: PUSH
28177: EMPTY
28178: ST_TO_ADDR
// if sort then
28179: LD_VAR 0 9
28183: IFFALSE 28299
// for i = 1 to 6 - eng do
28185: LD_ADDR_VAR 0 3
28189: PUSH
28190: DOUBLE
28191: LD_INT 1
28193: DEC
28194: ST_TO_ADDR
28195: LD_INT 6
28197: PUSH
28198: LD_VAR 0 6
28202: MINUS
28203: PUSH
28204: FOR_TO
28205: IFFALSE 28297
// begin if i = sort then
28207: LD_VAR 0 3
28211: PUSH
28212: LD_VAR 0 9
28216: EQUAL
28217: IFFALSE 28221
// break ;
28219: GO 28297
// if GetClass ( i ) = 2 then
28221: LD_VAR 0 3
28225: PPUSH
28226: CALL_OW 257
28230: PUSH
28231: LD_INT 2
28233: EQUAL
28234: IFFALSE 28238
// continue ;
28236: GO 28204
// p := Insert ( p , p + 1 , sort [ i ] ) ;
28238: LD_ADDR_VAR 0 11
28242: PUSH
28243: LD_VAR 0 11
28247: PPUSH
28248: LD_VAR 0 11
28252: PUSH
28253: LD_INT 1
28255: PLUS
28256: PPUSH
28257: LD_VAR 0 9
28261: PUSH
28262: LD_VAR 0 3
28266: ARRAY
28267: PPUSH
28268: CALL_OW 2
28272: ST_TO_ADDR
// tmp := tmp diff sort [ i ] ;
28273: LD_ADDR_VAR 0 4
28277: PUSH
28278: LD_VAR 0 4
28282: PUSH
28283: LD_VAR 0 9
28287: PUSH
28288: LD_VAR 0 3
28292: ARRAY
28293: DIFF
28294: ST_TO_ADDR
// end ;
28295: GO 28204
28297: POP
28298: POP
// if p then
28299: LD_VAR 0 11
28303: IFFALSE 28328
// result := Replace ( result , 2 , p ) ;
28305: LD_ADDR_VAR 0 2
28309: PUSH
28310: LD_VAR 0 2
28314: PPUSH
28315: LD_INT 2
28317: PPUSH
28318: LD_VAR 0 11
28322: PPUSH
28323: CALL_OW 1
28327: ST_TO_ADDR
// end ; exit ;
28328: GO 29716
// end ; if not mc_tech [ mc_sides [ base ] ] and UnitFilter ( mc_bases [ base ] , [ f_btype , b_factory ] ) and mc_build_list [ base ] then
28330: LD_EXP 122
28334: PUSH
28335: LD_EXP 121
28339: PUSH
28340: LD_VAR 0 1
28344: ARRAY
28345: ARRAY
28346: NOT
28347: PUSH
28348: LD_EXP 95
28352: PUSH
28353: LD_VAR 0 1
28357: ARRAY
28358: PPUSH
28359: LD_INT 30
28361: PUSH
28362: LD_INT 3
28364: PUSH
28365: EMPTY
28366: LIST
28367: LIST
28368: PPUSH
28369: CALL_OW 72
28373: AND
28374: PUSH
28375: LD_EXP 100
28379: PUSH
28380: LD_VAR 0 1
28384: ARRAY
28385: AND
28386: IFFALSE 28994
// begin mc_class_case_use := Replace ( mc_class_case_use , base , 5 ) ;
28388: LD_ADDR_EXP 137
28392: PUSH
28393: LD_EXP 137
28397: PPUSH
28398: LD_VAR 0 1
28402: PPUSH
28403: LD_INT 5
28405: PPUSH
28406: CALL_OW 1
28410: ST_TO_ADDR
// result := [ 0 , 0 , 0 , 0 ] ;
28411: LD_ADDR_VAR 0 2
28415: PUSH
28416: LD_INT 0
28418: PUSH
28419: LD_INT 0
28421: PUSH
28422: LD_INT 0
28424: PUSH
28425: LD_INT 0
28427: PUSH
28428: EMPTY
28429: LIST
28430: LIST
28431: LIST
28432: LIST
28433: ST_TO_ADDR
// if sci > 1 then
28434: LD_VAR 0 8
28438: PUSH
28439: LD_INT 1
28441: GREATER
28442: IFFALSE 28470
// tmp := tmp diff ( sci diff sci [ 1 ] ) ;
28444: LD_ADDR_VAR 0 4
28448: PUSH
28449: LD_VAR 0 4
28453: PUSH
28454: LD_VAR 0 8
28458: PUSH
28459: LD_VAR 0 8
28463: PUSH
28464: LD_INT 1
28466: ARRAY
28467: DIFF
28468: DIFF
28469: ST_TO_ADDR
// if tmp and not sci then
28470: LD_VAR 0 4
28474: PUSH
28475: LD_VAR 0 8
28479: NOT
28480: AND
28481: IFFALSE 28550
// begin sort := SortBySkill ( tmp , 4 ) ;
28483: LD_ADDR_VAR 0 9
28487: PUSH
28488: LD_VAR 0 4
28492: PPUSH
28493: LD_INT 4
28495: PPUSH
28496: CALL 87269 0 2
28500: ST_TO_ADDR
// if sort then
28501: LD_VAR 0 9
28505: IFFALSE 28521
// p := sort [ 1 ] ;
28507: LD_ADDR_VAR 0 11
28511: PUSH
28512: LD_VAR 0 9
28516: PUSH
28517: LD_INT 1
28519: ARRAY
28520: ST_TO_ADDR
// if p then
28521: LD_VAR 0 11
28525: IFFALSE 28550
// result := Replace ( result , 4 , p ) ;
28527: LD_ADDR_VAR 0 2
28531: PUSH
28532: LD_VAR 0 2
28536: PPUSH
28537: LD_INT 4
28539: PPUSH
28540: LD_VAR 0 11
28544: PPUSH
28545: CALL_OW 1
28549: ST_TO_ADDR
// end ; tmp := tmp diff mech ;
28550: LD_ADDR_VAR 0 4
28554: PUSH
28555: LD_VAR 0 4
28559: PUSH
28560: LD_VAR 0 7
28564: DIFF
28565: ST_TO_ADDR
// if tmp and mech < 6 then
28566: LD_VAR 0 4
28570: PUSH
28571: LD_VAR 0 7
28575: PUSH
28576: LD_INT 6
28578: LESS
28579: AND
28580: IFFALSE 28768
// begin sort := SortBySkill ( tmp diff ( sci union mech ) , 3 ) ;
28582: LD_ADDR_VAR 0 9
28586: PUSH
28587: LD_VAR 0 4
28591: PUSH
28592: LD_VAR 0 8
28596: PUSH
28597: LD_VAR 0 7
28601: UNION
28602: DIFF
28603: PPUSH
28604: LD_INT 3
28606: PPUSH
28607: CALL 87269 0 2
28611: ST_TO_ADDR
// p := [ ] ;
28612: LD_ADDR_VAR 0 11
28616: PUSH
28617: EMPTY
28618: ST_TO_ADDR
// if sort then
28619: LD_VAR 0 9
28623: IFFALSE 28739
// for i = 1 to 6 - mech do
28625: LD_ADDR_VAR 0 3
28629: PUSH
28630: DOUBLE
28631: LD_INT 1
28633: DEC
28634: ST_TO_ADDR
28635: LD_INT 6
28637: PUSH
28638: LD_VAR 0 7
28642: MINUS
28643: PUSH
28644: FOR_TO
28645: IFFALSE 28737
// begin if i = sort then
28647: LD_VAR 0 3
28651: PUSH
28652: LD_VAR 0 9
28656: EQUAL
28657: IFFALSE 28661
// break ;
28659: GO 28737
// if GetClass ( i ) = 3 then
28661: LD_VAR 0 3
28665: PPUSH
28666: CALL_OW 257
28670: PUSH
28671: LD_INT 3
28673: EQUAL
28674: IFFALSE 28678
// continue ;
28676: GO 28644
// p := Insert ( p , p + 1 , sort [ i ] ) ;
28678: LD_ADDR_VAR 0 11
28682: PUSH
28683: LD_VAR 0 11
28687: PPUSH
28688: LD_VAR 0 11
28692: PUSH
28693: LD_INT 1
28695: PLUS
28696: PPUSH
28697: LD_VAR 0 9
28701: PUSH
28702: LD_VAR 0 3
28706: ARRAY
28707: PPUSH
28708: CALL_OW 2
28712: ST_TO_ADDR
// tmp := tmp diff sort [ i ] ;
28713: LD_ADDR_VAR 0 4
28717: PUSH
28718: LD_VAR 0 4
28722: PUSH
28723: LD_VAR 0 9
28727: PUSH
28728: LD_VAR 0 3
28732: ARRAY
28733: DIFF
28734: ST_TO_ADDR
// end ;
28735: GO 28644
28737: POP
28738: POP
// if p then
28739: LD_VAR 0 11
28743: IFFALSE 28768
// result := Replace ( result , 3 , p ) ;
28745: LD_ADDR_VAR 0 2
28749: PUSH
28750: LD_VAR 0 2
28754: PPUSH
28755: LD_INT 3
28757: PPUSH
28758: LD_VAR 0 11
28762: PPUSH
28763: CALL_OW 1
28767: ST_TO_ADDR
// end ; tmp := tmp diff eng ;
28768: LD_ADDR_VAR 0 4
28772: PUSH
28773: LD_VAR 0 4
28777: PUSH
28778: LD_VAR 0 6
28782: DIFF
28783: ST_TO_ADDR
// if tmp and eng < 6 then
28784: LD_VAR 0 4
28788: PUSH
28789: LD_VAR 0 6
28793: PUSH
28794: LD_INT 6
28796: LESS
28797: AND
28798: IFFALSE 28992
// begin sort := SortBySkill ( tmp diff ( sci union mech union eng ) , 2 ) ;
28800: LD_ADDR_VAR 0 9
28804: PUSH
28805: LD_VAR 0 4
28809: PUSH
28810: LD_VAR 0 8
28814: PUSH
28815: LD_VAR 0 7
28819: UNION
28820: PUSH
28821: LD_VAR 0 6
28825: UNION
28826: DIFF
28827: PPUSH
28828: LD_INT 2
28830: PPUSH
28831: CALL 87269 0 2
28835: ST_TO_ADDR
// p := [ ] ;
28836: LD_ADDR_VAR 0 11
28840: PUSH
28841: EMPTY
28842: ST_TO_ADDR
// if sort then
28843: LD_VAR 0 9
28847: IFFALSE 28963
// for i = 1 to 6 - eng do
28849: LD_ADDR_VAR 0 3
28853: PUSH
28854: DOUBLE
28855: LD_INT 1
28857: DEC
28858: ST_TO_ADDR
28859: LD_INT 6
28861: PUSH
28862: LD_VAR 0 6
28866: MINUS
28867: PUSH
28868: FOR_TO
28869: IFFALSE 28961
// begin if i = sort then
28871: LD_VAR 0 3
28875: PUSH
28876: LD_VAR 0 9
28880: EQUAL
28881: IFFALSE 28885
// break ;
28883: GO 28961
// if GetClass ( i ) = 2 then
28885: LD_VAR 0 3
28889: PPUSH
28890: CALL_OW 257
28894: PUSH
28895: LD_INT 2
28897: EQUAL
28898: IFFALSE 28902
// continue ;
28900: GO 28868
// p := Insert ( p , p + 1 , sort [ i ] ) ;
28902: LD_ADDR_VAR 0 11
28906: PUSH
28907: LD_VAR 0 11
28911: PPUSH
28912: LD_VAR 0 11
28916: PUSH
28917: LD_INT 1
28919: PLUS
28920: PPUSH
28921: LD_VAR 0 9
28925: PUSH
28926: LD_VAR 0 3
28930: ARRAY
28931: PPUSH
28932: CALL_OW 2
28936: ST_TO_ADDR
// tmp := tmp diff sort [ i ] ;
28937: LD_ADDR_VAR 0 4
28941: PUSH
28942: LD_VAR 0 4
28946: PUSH
28947: LD_VAR 0 9
28951: PUSH
28952: LD_VAR 0 3
28956: ARRAY
28957: DIFF
28958: ST_TO_ADDR
// end ;
28959: GO 28868
28961: POP
28962: POP
// if p then
28963: LD_VAR 0 11
28967: IFFALSE 28992
// result := Replace ( result , 2 , p ) ;
28969: LD_ADDR_VAR 0 2
28973: PUSH
28974: LD_VAR 0 2
28978: PPUSH
28979: LD_INT 2
28981: PPUSH
28982: LD_VAR 0 11
28986: PPUSH
28987: CALL_OW 1
28991: ST_TO_ADDR
// end ; exit ;
28992: GO 29716
// end ; if not mc_tech [ mc_sides [ base ] ] and UnitFilter ( mc_bases [ base ] , [ f_btype , b_factory ] ) and not mc_build_list [ base ] then
28994: LD_EXP 122
28998: PUSH
28999: LD_EXP 121
29003: PUSH
29004: LD_VAR 0 1
29008: ARRAY
29009: ARRAY
29010: NOT
29011: PUSH
29012: LD_EXP 95
29016: PUSH
29017: LD_VAR 0 1
29021: ARRAY
29022: PPUSH
29023: LD_INT 30
29025: PUSH
29026: LD_INT 3
29028: PUSH
29029: EMPTY
29030: LIST
29031: LIST
29032: PPUSH
29033: CALL_OW 72
29037: AND
29038: PUSH
29039: LD_EXP 100
29043: PUSH
29044: LD_VAR 0 1
29048: ARRAY
29049: NOT
29050: AND
29051: IFFALSE 29716
// begin mc_class_case_use := Replace ( mc_class_case_use , base , 6 ) ;
29053: LD_ADDR_EXP 137
29057: PUSH
29058: LD_EXP 137
29062: PPUSH
29063: LD_VAR 0 1
29067: PPUSH
29068: LD_INT 6
29070: PPUSH
29071: CALL_OW 1
29075: ST_TO_ADDR
// result := [ 0 , 0 , 0 , 0 ] ;
29076: LD_ADDR_VAR 0 2
29080: PUSH
29081: LD_INT 0
29083: PUSH
29084: LD_INT 0
29086: PUSH
29087: LD_INT 0
29089: PUSH
29090: LD_INT 0
29092: PUSH
29093: EMPTY
29094: LIST
29095: LIST
29096: LIST
29097: LIST
29098: ST_TO_ADDR
// if sci >= 1 then
29099: LD_VAR 0 8
29103: PUSH
29104: LD_INT 1
29106: GREATEREQUAL
29107: IFFALSE 29129
// tmp := tmp diff sci [ 1 ] ;
29109: LD_ADDR_VAR 0 4
29113: PUSH
29114: LD_VAR 0 4
29118: PUSH
29119: LD_VAR 0 8
29123: PUSH
29124: LD_INT 1
29126: ARRAY
29127: DIFF
29128: ST_TO_ADDR
// if tmp and not sci then
29129: LD_VAR 0 4
29133: PUSH
29134: LD_VAR 0 8
29138: NOT
29139: AND
29140: IFFALSE 29209
// begin sort := SortBySkill ( tmp , 4 ) ;
29142: LD_ADDR_VAR 0 9
29146: PUSH
29147: LD_VAR 0 4
29151: PPUSH
29152: LD_INT 4
29154: PPUSH
29155: CALL 87269 0 2
29159: ST_TO_ADDR
// if sort then
29160: LD_VAR 0 9
29164: IFFALSE 29180
// p := sort [ 1 ] ;
29166: LD_ADDR_VAR 0 11
29170: PUSH
29171: LD_VAR 0 9
29175: PUSH
29176: LD_INT 1
29178: ARRAY
29179: ST_TO_ADDR
// if p then
29180: LD_VAR 0 11
29184: IFFALSE 29209
// result := Replace ( result , 4 , p ) ;
29186: LD_ADDR_VAR 0 2
29190: PUSH
29191: LD_VAR 0 2
29195: PPUSH
29196: LD_INT 4
29198: PPUSH
29199: LD_VAR 0 11
29203: PPUSH
29204: CALL_OW 1
29208: ST_TO_ADDR
// end ; tmp := tmp diff mech ;
29209: LD_ADDR_VAR 0 4
29213: PUSH
29214: LD_VAR 0 4
29218: PUSH
29219: LD_VAR 0 7
29223: DIFF
29224: ST_TO_ADDR
// if tmp and mech < 6 then
29225: LD_VAR 0 4
29229: PUSH
29230: LD_VAR 0 7
29234: PUSH
29235: LD_INT 6
29237: LESS
29238: AND
29239: IFFALSE 29421
// begin sort := SortBySkill ( tmp diff mech , 3 ) ;
29241: LD_ADDR_VAR 0 9
29245: PUSH
29246: LD_VAR 0 4
29250: PUSH
29251: LD_VAR 0 7
29255: DIFF
29256: PPUSH
29257: LD_INT 3
29259: PPUSH
29260: CALL 87269 0 2
29264: ST_TO_ADDR
// p := [ ] ;
29265: LD_ADDR_VAR 0 11
29269: PUSH
29270: EMPTY
29271: ST_TO_ADDR
// if sort then
29272: LD_VAR 0 9
29276: IFFALSE 29392
// for i = 1 to 6 - mech do
29278: LD_ADDR_VAR 0 3
29282: PUSH
29283: DOUBLE
29284: LD_INT 1
29286: DEC
29287: ST_TO_ADDR
29288: LD_INT 6
29290: PUSH
29291: LD_VAR 0 7
29295: MINUS
29296: PUSH
29297: FOR_TO
29298: IFFALSE 29390
// begin if i = sort then
29300: LD_VAR 0 3
29304: PUSH
29305: LD_VAR 0 9
29309: EQUAL
29310: IFFALSE 29314
// break ;
29312: GO 29390
// if GetClass ( i ) = 3 then
29314: LD_VAR 0 3
29318: PPUSH
29319: CALL_OW 257
29323: PUSH
29324: LD_INT 3
29326: EQUAL
29327: IFFALSE 29331
// continue ;
29329: GO 29297
// p := Insert ( p , p + 1 , sort [ i ] ) ;
29331: LD_ADDR_VAR 0 11
29335: PUSH
29336: LD_VAR 0 11
29340: PPUSH
29341: LD_VAR 0 11
29345: PUSH
29346: LD_INT 1
29348: PLUS
29349: PPUSH
29350: LD_VAR 0 9
29354: PUSH
29355: LD_VAR 0 3
29359: ARRAY
29360: PPUSH
29361: CALL_OW 2
29365: ST_TO_ADDR
// tmp := tmp diff sort [ i ] ;
29366: LD_ADDR_VAR 0 4
29370: PUSH
29371: LD_VAR 0 4
29375: PUSH
29376: LD_VAR 0 9
29380: PUSH
29381: LD_VAR 0 3
29385: ARRAY
29386: DIFF
29387: ST_TO_ADDR
// end ;
29388: GO 29297
29390: POP
29391: POP
// if p then
29392: LD_VAR 0 11
29396: IFFALSE 29421
// result := Replace ( result , 3 , p ) ;
29398: LD_ADDR_VAR 0 2
29402: PUSH
29403: LD_VAR 0 2
29407: PPUSH
29408: LD_INT 3
29410: PPUSH
29411: LD_VAR 0 11
29415: PPUSH
29416: CALL_OW 1
29420: ST_TO_ADDR
// end ; tmp := tmp diff eng ;
29421: LD_ADDR_VAR 0 4
29425: PUSH
29426: LD_VAR 0 4
29430: PUSH
29431: LD_VAR 0 6
29435: DIFF
29436: ST_TO_ADDR
// if tmp and eng < 4 then
29437: LD_VAR 0 4
29441: PUSH
29442: LD_VAR 0 6
29446: PUSH
29447: LD_INT 4
29449: LESS
29450: AND
29451: IFFALSE 29641
// begin sort := SortBySkill ( tmp diff ( mech union eng ) , 2 ) ;
29453: LD_ADDR_VAR 0 9
29457: PUSH
29458: LD_VAR 0 4
29462: PUSH
29463: LD_VAR 0 7
29467: PUSH
29468: LD_VAR 0 6
29472: UNION
29473: DIFF
29474: PPUSH
29475: LD_INT 2
29477: PPUSH
29478: CALL 87269 0 2
29482: ST_TO_ADDR
// p := [ ] ;
29483: LD_ADDR_VAR 0 11
29487: PUSH
29488: EMPTY
29489: ST_TO_ADDR
// if sort then
29490: LD_VAR 0 9
29494: IFFALSE 29610
// for i = 1 to 4 - eng do
29496: LD_ADDR_VAR 0 3
29500: PUSH
29501: DOUBLE
29502: LD_INT 1
29504: DEC
29505: ST_TO_ADDR
29506: LD_INT 4
29508: PUSH
29509: LD_VAR 0 6
29513: MINUS
29514: PUSH
29515: FOR_TO
29516: IFFALSE 29608
// begin if i = sort then
29518: LD_VAR 0 3
29522: PUSH
29523: LD_VAR 0 9
29527: EQUAL
29528: IFFALSE 29532
// break ;
29530: GO 29608
// if GetClass ( i ) = 2 then
29532: LD_VAR 0 3
29536: PPUSH
29537: CALL_OW 257
29541: PUSH
29542: LD_INT 2
29544: EQUAL
29545: IFFALSE 29549
// continue ;
29547: GO 29515
// p := Insert ( p , p + 1 , sort [ i ] ) ;
29549: LD_ADDR_VAR 0 11
29553: PUSH
29554: LD_VAR 0 11
29558: PPUSH
29559: LD_VAR 0 11
29563: PUSH
29564: LD_INT 1
29566: PLUS
29567: PPUSH
29568: LD_VAR 0 9
29572: PUSH
29573: LD_VAR 0 3
29577: ARRAY
29578: PPUSH
29579: CALL_OW 2
29583: ST_TO_ADDR
// tmp := tmp diff sort [ i ] ;
29584: LD_ADDR_VAR 0 4
29588: PUSH
29589: LD_VAR 0 4
29593: PUSH
29594: LD_VAR 0 9
29598: PUSH
29599: LD_VAR 0 3
29603: ARRAY
29604: DIFF
29605: ST_TO_ADDR
// end ;
29606: GO 29515
29608: POP
29609: POP
// if p then
29610: LD_VAR 0 11
29614: IFFALSE 29639
// result := Replace ( result , 2 , p ) ;
29616: LD_ADDR_VAR 0 2
29620: PUSH
29621: LD_VAR 0 2
29625: PPUSH
29626: LD_INT 2
29628: PPUSH
29629: LD_VAR 0 11
29633: PPUSH
29634: CALL_OW 1
29638: ST_TO_ADDR
// end else
29639: GO 29685
// for i = eng downto 5 do
29641: LD_ADDR_VAR 0 3
29645: PUSH
29646: DOUBLE
29647: LD_VAR 0 6
29651: INC
29652: ST_TO_ADDR
29653: LD_INT 5
29655: PUSH
29656: FOR_DOWNTO
29657: IFFALSE 29683
// tmp := tmp union eng [ i ] ;
29659: LD_ADDR_VAR 0 4
29663: PUSH
29664: LD_VAR 0 4
29668: PUSH
29669: LD_VAR 0 6
29673: PUSH
29674: LD_VAR 0 3
29678: ARRAY
29679: UNION
29680: ST_TO_ADDR
29681: GO 29656
29683: POP
29684: POP
// result := Replace ( result , 1 , tmp diff sol ) ;
29685: LD_ADDR_VAR 0 2
29689: PUSH
29690: LD_VAR 0 2
29694: PPUSH
29695: LD_INT 1
29697: PPUSH
29698: LD_VAR 0 4
29702: PUSH
29703: LD_VAR 0 5
29707: DIFF
29708: PPUSH
29709: CALL_OW 1
29713: ST_TO_ADDR
// exit ;
29714: GO 29716
// end ; end ;
29716: LD_VAR 0 2
29720: RET
// export function MC_CheckBuildings ( ) ; var i , tmp ; begin
29721: LD_INT 0
29723: PPUSH
29724: PPUSH
29725: PPUSH
// if not mc_bases then
29726: LD_EXP 95
29730: NOT
29731: IFFALSE 29735
// exit ;
29733: GO 29877
// for i = 1 to mc_bases do
29735: LD_ADDR_VAR 0 2
29739: PUSH
29740: DOUBLE
29741: LD_INT 1
29743: DEC
29744: ST_TO_ADDR
29745: LD_EXP 95
29749: PUSH
29750: FOR_TO
29751: IFFALSE 29868
// begin tmp := UnitFilter ( mc_bases [ i ] , [ [ f_type , unit_building ] , [ f_not , [ f_or , [ f_btype , b_oil_mine ] , [ f_btype , b_siberite_mine ] ] ] , [ f_not , [ f_lives , 1000 ] ] ] ) ;
29753: LD_ADDR_VAR 0 3
29757: PUSH
29758: LD_EXP 95
29762: PUSH
29763: LD_VAR 0 2
29767: ARRAY
29768: PPUSH
29769: LD_INT 21
29771: PUSH
29772: LD_INT 3
29774: PUSH
29775: EMPTY
29776: LIST
29777: LIST
29778: PUSH
29779: LD_INT 3
29781: PUSH
29782: LD_INT 2
29784: PUSH
29785: LD_INT 30
29787: PUSH
29788: LD_INT 29
29790: PUSH
29791: EMPTY
29792: LIST
29793: LIST
29794: PUSH
29795: LD_INT 30
29797: PUSH
29798: LD_INT 30
29800: PUSH
29801: EMPTY
29802: LIST
29803: LIST
29804: PUSH
29805: EMPTY
29806: LIST
29807: LIST
29808: LIST
29809: PUSH
29810: EMPTY
29811: LIST
29812: LIST
29813: PUSH
29814: LD_INT 3
29816: PUSH
29817: LD_INT 24
29819: PUSH
29820: LD_INT 1000
29822: PUSH
29823: EMPTY
29824: LIST
29825: LIST
29826: PUSH
29827: EMPTY
29828: LIST
29829: LIST
29830: PUSH
29831: EMPTY
29832: LIST
29833: LIST
29834: LIST
29835: PPUSH
29836: CALL_OW 72
29840: ST_TO_ADDR
// mc_building_need_repair := Replace ( mc_building_need_repair , i , tmp ) ;
29841: LD_ADDR_EXP 96
29845: PUSH
29846: LD_EXP 96
29850: PPUSH
29851: LD_VAR 0 2
29855: PPUSH
29856: LD_VAR 0 3
29860: PPUSH
29861: CALL_OW 1
29865: ST_TO_ADDR
// end ;
29866: GO 29750
29868: POP
29869: POP
// RaiseSailEvent ( 101 ) ;
29870: LD_INT 101
29872: PPUSH
29873: CALL_OW 427
// end ;
29877: LD_VAR 0 1
29881: RET
// export function MC_CheckPeopleLife ( ) ; var i , j , k , tmp , need_heal_1 , need_heal_2 ; begin
29882: LD_INT 0
29884: PPUSH
29885: PPUSH
29886: PPUSH
29887: PPUSH
29888: PPUSH
29889: PPUSH
29890: PPUSH
// if not mc_bases then
29891: LD_EXP 95
29895: NOT
29896: IFFALSE 29900
// exit ;
29898: GO 30462
// for i = 1 to mc_bases do
29900: LD_ADDR_VAR 0 2
29904: PUSH
29905: DOUBLE
29906: LD_INT 1
29908: DEC
29909: ST_TO_ADDR
29910: LD_EXP 95
29914: PUSH
29915: FOR_TO
29916: IFFALSE 30453
// begin tmp := UnitFilter ( mc_bases [ i ] union mc_ape [ i ] , [ [ f_type , unit_human ] , [ f_and , [ f_not , [ f_inside ] ] , [ f_not , [ f_lives , 1000 ] ] ] ] ) ;
29918: LD_ADDR_VAR 0 5
29922: PUSH
29923: LD_EXP 95
29927: PUSH
29928: LD_VAR 0 2
29932: ARRAY
29933: PUSH
29934: LD_EXP 124
29938: PUSH
29939: LD_VAR 0 2
29943: ARRAY
29944: UNION
29945: PPUSH
29946: LD_INT 21
29948: PUSH
29949: LD_INT 1
29951: PUSH
29952: EMPTY
29953: LIST
29954: LIST
29955: PUSH
29956: LD_INT 1
29958: PUSH
29959: LD_INT 3
29961: PUSH
29962: LD_INT 54
29964: PUSH
29965: EMPTY
29966: LIST
29967: PUSH
29968: EMPTY
29969: LIST
29970: LIST
29971: PUSH
29972: LD_INT 3
29974: PUSH
29975: LD_INT 24
29977: PUSH
29978: LD_INT 1000
29980: PUSH
29981: EMPTY
29982: LIST
29983: LIST
29984: PUSH
29985: EMPTY
29986: LIST
29987: LIST
29988: PUSH
29989: EMPTY
29990: LIST
29991: LIST
29992: LIST
29993: PUSH
29994: EMPTY
29995: LIST
29996: LIST
29997: PPUSH
29998: CALL_OW 72
30002: ST_TO_ADDR
// need_heal_1 := UnitFilter ( mc_bases [ i ] , [ [ f_type , unit_human ] , [ f_and , [ f_not , [ f_inside ] ] , [ f_not , [ f_lives , 250 ] ] ] ] ) ;
30003: LD_ADDR_VAR 0 6
30007: PUSH
30008: LD_EXP 95
30012: PUSH
30013: LD_VAR 0 2
30017: ARRAY
30018: PPUSH
30019: LD_INT 21
30021: PUSH
30022: LD_INT 1
30024: PUSH
30025: EMPTY
30026: LIST
30027: LIST
30028: PUSH
30029: LD_INT 1
30031: PUSH
30032: LD_INT 3
30034: PUSH
30035: LD_INT 54
30037: PUSH
30038: EMPTY
30039: LIST
30040: PUSH
30041: EMPTY
30042: LIST
30043: LIST
30044: PUSH
30045: LD_INT 3
30047: PUSH
30048: LD_INT 24
30050: PUSH
30051: LD_INT 250
30053: PUSH
30054: EMPTY
30055: LIST
30056: LIST
30057: PUSH
30058: EMPTY
30059: LIST
30060: LIST
30061: PUSH
30062: EMPTY
30063: LIST
30064: LIST
30065: LIST
30066: PUSH
30067: EMPTY
30068: LIST
30069: LIST
30070: PPUSH
30071: CALL_OW 72
30075: ST_TO_ADDR
// need_heal_2 := tmp diff need_heal_1 ;
30076: LD_ADDR_VAR 0 7
30080: PUSH
30081: LD_VAR 0 5
30085: PUSH
30086: LD_VAR 0 6
30090: DIFF
30091: ST_TO_ADDR
// if not need_heal_1 then
30092: LD_VAR 0 6
30096: NOT
30097: IFFALSE 30130
// mc_need_heal := ReplaceIn ( mc_need_heal , [ i , 1 ] , [ ] ) else
30099: LD_ADDR_EXP 98
30103: PUSH
30104: LD_EXP 98
30108: PPUSH
30109: LD_VAR 0 2
30113: PUSH
30114: LD_INT 1
30116: PUSH
30117: EMPTY
30118: LIST
30119: LIST
30120: PPUSH
30121: EMPTY
30122: PPUSH
30123: CALL 57012 0 3
30127: ST_TO_ADDR
30128: GO 30200
// mc_need_heal := ReplaceIn ( mc_need_heal , [ i , 1 ] , UnitFilter ( mc_need_heal [ i ] [ 1 ] , [ f_not , [ f_lives , 1000 ] ] ) union need_heal_1 ) ;
30130: LD_ADDR_EXP 98
30134: PUSH
30135: LD_EXP 98
30139: PPUSH
30140: LD_VAR 0 2
30144: PUSH
30145: LD_INT 1
30147: PUSH
30148: EMPTY
30149: LIST
30150: LIST
30151: PPUSH
30152: LD_EXP 98
30156: PUSH
30157: LD_VAR 0 2
30161: ARRAY
30162: PUSH
30163: LD_INT 1
30165: ARRAY
30166: PPUSH
30167: LD_INT 3
30169: PUSH
30170: LD_INT 24
30172: PUSH
30173: LD_INT 1000
30175: PUSH
30176: EMPTY
30177: LIST
30178: LIST
30179: PUSH
30180: EMPTY
30181: LIST
30182: LIST
30183: PPUSH
30184: CALL_OW 72
30188: PUSH
30189: LD_VAR 0 6
30193: UNION
30194: PPUSH
30195: CALL 57012 0 3
30199: ST_TO_ADDR
// if not need_heal_2 then
30200: LD_VAR 0 7
30204: NOT
30205: IFFALSE 30238
// mc_need_heal := ReplaceIn ( mc_need_heal , [ i , 2 ] , [ ] ) else
30207: LD_ADDR_EXP 98
30211: PUSH
30212: LD_EXP 98
30216: PPUSH
30217: LD_VAR 0 2
30221: PUSH
30222: LD_INT 2
30224: PUSH
30225: EMPTY
30226: LIST
30227: LIST
30228: PPUSH
30229: EMPTY
30230: PPUSH
30231: CALL 57012 0 3
30235: ST_TO_ADDR
30236: GO 30270
// mc_need_heal := ReplaceIn ( mc_need_heal , [ i , 2 ] , need_heal_2 ) ;
30238: LD_ADDR_EXP 98
30242: PUSH
30243: LD_EXP 98
30247: PPUSH
30248: LD_VAR 0 2
30252: PUSH
30253: LD_INT 2
30255: PUSH
30256: EMPTY
30257: LIST
30258: LIST
30259: PPUSH
30260: LD_VAR 0 7
30264: PPUSH
30265: CALL 57012 0 3
30269: ST_TO_ADDR
// if need_heal_2 then
30270: LD_VAR 0 7
30274: IFFALSE 30435
// for j in need_heal_2 do
30276: LD_ADDR_VAR 0 3
30280: PUSH
30281: LD_VAR 0 7
30285: PUSH
30286: FOR_IN
30287: IFFALSE 30433
// begin tmp := UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_lab ] , [ f_btype , b_lab_half ] , [ f_btype , b_lab_full ] , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) ;
30289: LD_ADDR_VAR 0 5
30293: PUSH
30294: LD_EXP 95
30298: PUSH
30299: LD_VAR 0 2
30303: ARRAY
30304: PPUSH
30305: LD_INT 2
30307: PUSH
30308: LD_INT 30
30310: PUSH
30311: LD_INT 6
30313: PUSH
30314: EMPTY
30315: LIST
30316: LIST
30317: PUSH
30318: LD_INT 30
30320: PUSH
30321: LD_INT 7
30323: PUSH
30324: EMPTY
30325: LIST
30326: LIST
30327: PUSH
30328: LD_INT 30
30330: PUSH
30331: LD_INT 8
30333: PUSH
30334: EMPTY
30335: LIST
30336: LIST
30337: PUSH
30338: LD_INT 30
30340: PUSH
30341: LD_INT 0
30343: PUSH
30344: EMPTY
30345: LIST
30346: LIST
30347: PUSH
30348: LD_INT 30
30350: PUSH
30351: LD_INT 1
30353: PUSH
30354: EMPTY
30355: LIST
30356: LIST
30357: PUSH
30358: EMPTY
30359: LIST
30360: LIST
30361: LIST
30362: LIST
30363: LIST
30364: LIST
30365: PPUSH
30366: CALL_OW 72
30370: ST_TO_ADDR
// if tmp then
30371: LD_VAR 0 5
30375: IFFALSE 30431
// begin k := NearestUnitToUnit ( tmp , j ) ;
30377: LD_ADDR_VAR 0 4
30381: PUSH
30382: LD_VAR 0 5
30386: PPUSH
30387: LD_VAR 0 3
30391: PPUSH
30392: CALL_OW 74
30396: ST_TO_ADDR
// if GetDistUnits ( j , k ) > 5 then
30397: LD_VAR 0 3
30401: PPUSH
30402: LD_VAR 0 4
30406: PPUSH
30407: CALL_OW 296
30411: PUSH
30412: LD_INT 5
30414: GREATER
30415: IFFALSE 30431
// ComMoveToNearbyEntrance ( j , k ) ;
30417: LD_VAR 0 3
30421: PPUSH
30422: LD_VAR 0 4
30426: PPUSH
30427: CALL 89630 0 2
// end ; end ;
30431: GO 30286
30433: POP
30434: POP
// if not need_heal_1 and not need_heal_2 then
30435: LD_VAR 0 6
30439: NOT
30440: PUSH
30441: LD_VAR 0 7
30445: NOT
30446: AND
30447: IFFALSE 30451
// continue ;
30449: GO 29915
// end ;
30451: GO 29915
30453: POP
30454: POP
// RaiseSailEvent ( 102 ) ;
30455: LD_INT 102
30457: PPUSH
30458: CALL_OW 427
// end ;
30462: LD_VAR 0 1
30466: RET
// export function MC_RepairBuildings ( ) ; var i , j , un , tmp , cranes , to_repair_tmp , to_repair ; begin
30467: LD_INT 0
30469: PPUSH
30470: PPUSH
30471: PPUSH
30472: PPUSH
30473: PPUSH
30474: PPUSH
30475: PPUSH
30476: PPUSH
// if not mc_bases then
30477: LD_EXP 95
30481: NOT
30482: IFFALSE 30486
// exit ;
30484: GO 31369
// for i = 1 to mc_bases do
30486: LD_ADDR_VAR 0 2
30490: PUSH
30491: DOUBLE
30492: LD_INT 1
30494: DEC
30495: ST_TO_ADDR
30496: LD_EXP 95
30500: PUSH
30501: FOR_TO
30502: IFFALSE 31367
// begin if not mc_building_need_repair [ i ] then
30504: LD_EXP 96
30508: PUSH
30509: LD_VAR 0 2
30513: ARRAY
30514: NOT
30515: IFFALSE 30702
// begin cranes := UnitFilter ( mc_vehicles [ i ] , [ [ f_not , [ f_lives , 1000 ] ] , [ f_or , [ f_weapon , us_crane ] , [ f_weapon , ru_crane ] , [ f_weapon , ar_crane ] ] ] ) ;
30517: LD_ADDR_VAR 0 6
30521: PUSH
30522: LD_EXP 114
30526: PUSH
30527: LD_VAR 0 2
30531: ARRAY
30532: PPUSH
30533: LD_INT 3
30535: PUSH
30536: LD_INT 24
30538: PUSH
30539: LD_INT 1000
30541: PUSH
30542: EMPTY
30543: LIST
30544: LIST
30545: PUSH
30546: EMPTY
30547: LIST
30548: LIST
30549: PUSH
30550: LD_INT 2
30552: PUSH
30553: LD_INT 34
30555: PUSH
30556: LD_INT 13
30558: PUSH
30559: EMPTY
30560: LIST
30561: LIST
30562: PUSH
30563: LD_INT 34
30565: PUSH
30566: LD_INT 52
30568: PUSH
30569: EMPTY
30570: LIST
30571: LIST
30572: PUSH
30573: LD_INT 34
30575: PUSH
30576: LD_EXP 80
30580: PUSH
30581: EMPTY
30582: LIST
30583: LIST
30584: PUSH
30585: EMPTY
30586: LIST
30587: LIST
30588: LIST
30589: LIST
30590: PUSH
30591: EMPTY
30592: LIST
30593: LIST
30594: PPUSH
30595: CALL_OW 72
30599: ST_TO_ADDR
// if cranes then
30600: LD_VAR 0 6
30604: IFFALSE 30666
// for j in cranes do
30606: LD_ADDR_VAR 0 3
30610: PUSH
30611: LD_VAR 0 6
30615: PUSH
30616: FOR_IN
30617: IFFALSE 30664
// if not IsInArea ( j , mc_parking [ i ] ) then
30619: LD_VAR 0 3
30623: PPUSH
30624: LD_EXP 119
30628: PUSH
30629: LD_VAR 0 2
30633: ARRAY
30634: PPUSH
30635: CALL_OW 308
30639: NOT
30640: IFFALSE 30662
// ComMoveToArea ( j , mc_parking [ i ] ) ;
30642: LD_VAR 0 3
30646: PPUSH
30647: LD_EXP 119
30651: PUSH
30652: LD_VAR 0 2
30656: ARRAY
30657: PPUSH
30658: CALL_OW 113
30662: GO 30616
30664: POP
30665: POP
// mc_building_repairs := Replace ( mc_building_repairs , i , [ ] ) ;
30666: LD_ADDR_EXP 97
30670: PUSH
30671: LD_EXP 97
30675: PPUSH
30676: LD_VAR 0 2
30680: PPUSH
30681: EMPTY
30682: PPUSH
30683: CALL_OW 1
30687: ST_TO_ADDR
// MC_Reset ( i , 101 ) ;
30688: LD_VAR 0 2
30692: PPUSH
30693: LD_INT 101
30695: PPUSH
30696: CALL 25554 0 2
// continue ;
30700: GO 30501
// end ; mc_builders := Replace ( mc_builders , i , [ ] ) ;
30702: LD_ADDR_EXP 101
30706: PUSH
30707: LD_EXP 101
30711: PPUSH
30712: LD_VAR 0 2
30716: PPUSH
30717: EMPTY
30718: PPUSH
30719: CALL_OW 1
30723: ST_TO_ADDR
// MC_Reset ( i , 103 ) ;
30724: LD_VAR 0 2
30728: PPUSH
30729: LD_INT 103
30731: PPUSH
30732: CALL 25554 0 2
// tmp := UnitFilter ( mc_bases [ i ] union mc_ape [ i ] , [ [ f_or , [ f_class , 2 ] , [ f_class , 16 ] ] ] ) ;
30736: LD_ADDR_VAR 0 5
30740: PUSH
30741: LD_EXP 95
30745: PUSH
30746: LD_VAR 0 2
30750: ARRAY
30751: PUSH
30752: LD_EXP 124
30756: PUSH
30757: LD_VAR 0 2
30761: ARRAY
30762: UNION
30763: PPUSH
30764: LD_INT 2
30766: PUSH
30767: LD_INT 25
30769: PUSH
30770: LD_INT 2
30772: PUSH
30773: EMPTY
30774: LIST
30775: LIST
30776: PUSH
30777: LD_INT 25
30779: PUSH
30780: LD_INT 16
30782: PUSH
30783: EMPTY
30784: LIST
30785: LIST
30786: PUSH
30787: EMPTY
30788: LIST
30789: LIST
30790: LIST
30791: PUSH
30792: EMPTY
30793: LIST
30794: PPUSH
30795: CALL_OW 72
30799: ST_TO_ADDR
// if mc_need_heal [ i ] then
30800: LD_EXP 98
30804: PUSH
30805: LD_VAR 0 2
30809: ARRAY
30810: IFFALSE 30854
// tmp := tmp diff ( mc_need_heal [ i ] [ 1 ] union mc_need_heal [ i ] [ 2 ] ) ;
30812: LD_ADDR_VAR 0 5
30816: PUSH
30817: LD_VAR 0 5
30821: PUSH
30822: LD_EXP 98
30826: PUSH
30827: LD_VAR 0 2
30831: ARRAY
30832: PUSH
30833: LD_INT 1
30835: ARRAY
30836: PUSH
30837: LD_EXP 98
30841: PUSH
30842: LD_VAR 0 2
30846: ARRAY
30847: PUSH
30848: LD_INT 2
30850: ARRAY
30851: UNION
30852: DIFF
30853: ST_TO_ADDR
// cranes := UnitFilter ( mc_vehicles [ i ] , [ f_or , [ f_weapon , us_crane ] , [ f_weapon , ru_crane ] , [ f_weapon , ar_crane ] ] ) ;
30854: LD_ADDR_VAR 0 6
30858: PUSH
30859: LD_EXP 114
30863: PUSH
30864: LD_VAR 0 2
30868: ARRAY
30869: PPUSH
30870: LD_INT 2
30872: PUSH
30873: LD_INT 34
30875: PUSH
30876: LD_INT 13
30878: PUSH
30879: EMPTY
30880: LIST
30881: LIST
30882: PUSH
30883: LD_INT 34
30885: PUSH
30886: LD_INT 52
30888: PUSH
30889: EMPTY
30890: LIST
30891: LIST
30892: PUSH
30893: LD_INT 34
30895: PUSH
30896: LD_EXP 80
30900: PUSH
30901: EMPTY
30902: LIST
30903: LIST
30904: PUSH
30905: EMPTY
30906: LIST
30907: LIST
30908: LIST
30909: LIST
30910: PPUSH
30911: CALL_OW 72
30915: ST_TO_ADDR
// if cranes then
30916: LD_VAR 0 6
30920: IFFALSE 31056
// begin for j in cranes do
30922: LD_ADDR_VAR 0 3
30926: PUSH
30927: LD_VAR 0 6
30931: PUSH
30932: FOR_IN
30933: IFFALSE 31054
// begin if GetLives ( j ) = 1000 and not HasTask ( j ) then
30935: LD_VAR 0 3
30939: PPUSH
30940: CALL_OW 256
30944: PUSH
30945: LD_INT 1000
30947: EQUAL
30948: PUSH
30949: LD_VAR 0 3
30953: PPUSH
30954: CALL_OW 314
30958: NOT
30959: AND
30960: IFFALSE 30994
// ComRepairBuilding ( j , NearestUnitToUnit ( mc_building_need_repair [ i ] , j ) ) else
30962: LD_VAR 0 3
30966: PPUSH
30967: LD_EXP 96
30971: PUSH
30972: LD_VAR 0 2
30976: ARRAY
30977: PPUSH
30978: LD_VAR 0 3
30982: PPUSH
30983: CALL_OW 74
30987: PPUSH
30988: CALL_OW 130
30992: GO 31052
// if GetLives ( j ) < 500 and not IsInArea ( j , mc_parking [ i ] ) then
30994: LD_VAR 0 3
30998: PPUSH
30999: CALL_OW 256
31003: PUSH
31004: LD_INT 500
31006: LESS
31007: PUSH
31008: LD_VAR 0 3
31012: PPUSH
31013: LD_EXP 119
31017: PUSH
31018: LD_VAR 0 2
31022: ARRAY
31023: PPUSH
31024: CALL_OW 308
31028: NOT
31029: AND
31030: IFFALSE 31052
// ComMoveToArea ( j , mc_parking [ i ] ) ;
31032: LD_VAR 0 3
31036: PPUSH
31037: LD_EXP 119
31041: PUSH
31042: LD_VAR 0 2
31046: ARRAY
31047: PPUSH
31048: CALL_OW 113
// end ;
31052: GO 30932
31054: POP
31055: POP
// end ; if tmp > 3 then
31056: LD_VAR 0 5
31060: PUSH
31061: LD_INT 3
31063: GREATER
31064: IFFALSE 31084
// tmp := ShrinkArray ( tmp , 4 ) ;
31066: LD_ADDR_VAR 0 5
31070: PUSH
31071: LD_VAR 0 5
31075: PPUSH
31076: LD_INT 4
31078: PPUSH
31079: CALL 89078 0 2
31083: ST_TO_ADDR
// if not tmp then
31084: LD_VAR 0 5
31088: NOT
31089: IFFALSE 31093
// continue ;
31091: GO 30501
// for j in tmp do
31093: LD_ADDR_VAR 0 3
31097: PUSH
31098: LD_VAR 0 5
31102: PUSH
31103: FOR_IN
31104: IFFALSE 31363
// begin if IsInUnit ( j ) then
31106: LD_VAR 0 3
31110: PPUSH
31111: CALL_OW 310
31115: IFFALSE 31126
// ComExitBuilding ( j ) ;
31117: LD_VAR 0 3
31121: PPUSH
31122: CALL_OW 122
// if not j in mc_building_repairs [ i ] then
31126: LD_VAR 0 3
31130: PUSH
31131: LD_EXP 97
31135: PUSH
31136: LD_VAR 0 2
31140: ARRAY
31141: IN
31142: NOT
31143: IFFALSE 31201
// begin SetTag ( j , 101 ) ;
31145: LD_VAR 0 3
31149: PPUSH
31150: LD_INT 101
31152: PPUSH
31153: CALL_OW 109
// mc_building_repairs := ReplaceIn ( mc_building_repairs , [ i , mc_building_repairs [ i ] + 1 ] , j ) ;
31157: LD_ADDR_EXP 97
31161: PUSH
31162: LD_EXP 97
31166: PPUSH
31167: LD_VAR 0 2
31171: PUSH
31172: LD_EXP 97
31176: PUSH
31177: LD_VAR 0 2
31181: ARRAY
31182: PUSH
31183: LD_INT 1
31185: PLUS
31186: PUSH
31187: EMPTY
31188: LIST
31189: LIST
31190: PPUSH
31191: LD_VAR 0 3
31195: PPUSH
31196: CALL 57012 0 3
31200: ST_TO_ADDR
// end ; wait ( 1 ) ;
31201: LD_INT 1
31203: PPUSH
31204: CALL_OW 67
// to_repair_tmp := mc_building_need_repair [ i ] ;
31208: LD_ADDR_VAR 0 7
31212: PUSH
31213: LD_EXP 96
31217: PUSH
31218: LD_VAR 0 2
31222: ARRAY
31223: ST_TO_ADDR
// if mc_scan [ i ] then
31224: LD_EXP 118
31228: PUSH
31229: LD_VAR 0 2
31233: ARRAY
31234: IFFALSE 31296
// to_repair_tmp := UnitFilter ( mc_building_need_repair [ i ] , [ f_not , [ f_btype , b_bunker ] , [ f_btype , b_turret ] , [ f_btype , b_breastwork ] ] ) ;
31236: LD_ADDR_VAR 0 7
31240: PUSH
31241: LD_EXP 96
31245: PUSH
31246: LD_VAR 0 2
31250: ARRAY
31251: PPUSH
31252: LD_INT 3
31254: PUSH
31255: LD_INT 30
31257: PUSH
31258: LD_INT 32
31260: PUSH
31261: EMPTY
31262: LIST
31263: LIST
31264: PUSH
31265: LD_INT 30
31267: PUSH
31268: LD_INT 33
31270: PUSH
31271: EMPTY
31272: LIST
31273: LIST
31274: PUSH
31275: LD_INT 30
31277: PUSH
31278: LD_INT 31
31280: PUSH
31281: EMPTY
31282: LIST
31283: LIST
31284: PUSH
31285: EMPTY
31286: LIST
31287: LIST
31288: LIST
31289: LIST
31290: PPUSH
31291: CALL_OW 72
31295: ST_TO_ADDR
// if not to_repair_tmp then
31296: LD_VAR 0 7
31300: NOT
31301: IFFALSE 31305
// continue ;
31303: GO 31103
// to_repair := NearestUnitToUnit ( to_repair_tmp , j ) ;
31305: LD_ADDR_VAR 0 8
31309: PUSH
31310: LD_VAR 0 7
31314: PPUSH
31315: LD_VAR 0 3
31319: PPUSH
31320: CALL_OW 74
31324: ST_TO_ADDR
// if DangerAtRange ( to_repair , 16 ) [ 4 ] < 10 then
31325: LD_VAR 0 8
31329: PPUSH
31330: LD_INT 16
31332: PPUSH
31333: CALL 59611 0 2
31337: PUSH
31338: LD_INT 4
31340: ARRAY
31341: PUSH
31342: LD_INT 10
31344: LESS
31345: IFFALSE 31361
// ComRepairBuilding ( j , to_repair ) ;
31347: LD_VAR 0 3
31351: PPUSH
31352: LD_VAR 0 8
31356: PPUSH
31357: CALL_OW 130
// end ;
31361: GO 31103
31363: POP
31364: POP
// end ;
31365: GO 30501
31367: POP
31368: POP
// end ;
31369: LD_VAR 0 1
31373: RET
// export function MC_Heal ; var i , j , tmp ; begin
31374: LD_INT 0
31376: PPUSH
31377: PPUSH
31378: PPUSH
31379: PPUSH
// if not mc_bases then
31380: LD_EXP 95
31384: NOT
31385: IFFALSE 31389
// exit ;
31387: GO 31791
// for i = 1 to mc_bases do
31389: LD_ADDR_VAR 0 2
31393: PUSH
31394: DOUBLE
31395: LD_INT 1
31397: DEC
31398: ST_TO_ADDR
31399: LD_EXP 95
31403: PUSH
31404: FOR_TO
31405: IFFALSE 31789
// begin if not mc_need_heal [ i ] [ 1 ] and not mc_need_heal [ i ] [ 2 ] then
31407: LD_EXP 98
31411: PUSH
31412: LD_VAR 0 2
31416: ARRAY
31417: PUSH
31418: LD_INT 1
31420: ARRAY
31421: NOT
31422: PUSH
31423: LD_EXP 98
31427: PUSH
31428: LD_VAR 0 2
31432: ARRAY
31433: PUSH
31434: LD_INT 2
31436: ARRAY
31437: NOT
31438: AND
31439: IFFALSE 31477
// begin mc_healers := Replace ( mc_healers , i , [ ] ) ;
31441: LD_ADDR_EXP 99
31445: PUSH
31446: LD_EXP 99
31450: PPUSH
31451: LD_VAR 0 2
31455: PPUSH
31456: EMPTY
31457: PPUSH
31458: CALL_OW 1
31462: ST_TO_ADDR
// MC_Reset ( i , 102 ) ;
31463: LD_VAR 0 2
31467: PPUSH
31468: LD_INT 102
31470: PPUSH
31471: CALL 25554 0 2
// continue ;
31475: GO 31404
// end ; tmp := UnitFilter ( mc_bases [ i ] , [ f_class , 4 ] ) ;
31477: LD_ADDR_VAR 0 4
31481: PUSH
31482: LD_EXP 95
31486: PUSH
31487: LD_VAR 0 2
31491: ARRAY
31492: PPUSH
31493: LD_INT 25
31495: PUSH
31496: LD_INT 4
31498: PUSH
31499: EMPTY
31500: LIST
31501: LIST
31502: PPUSH
31503: CALL_OW 72
31507: ST_TO_ADDR
// if not tmp then
31508: LD_VAR 0 4
31512: NOT
31513: IFFALSE 31517
// continue ;
31515: GO 31404
// if mc_taming [ i ] then
31517: LD_EXP 126
31521: PUSH
31522: LD_VAR 0 2
31526: ARRAY
31527: IFFALSE 31551
// mc_taming := Replace ( mc_taming , i , [ ] ) ;
31529: LD_ADDR_EXP 126
31533: PUSH
31534: LD_EXP 126
31538: PPUSH
31539: LD_VAR 0 2
31543: PPUSH
31544: EMPTY
31545: PPUSH
31546: CALL_OW 1
31550: ST_TO_ADDR
// for j in tmp do
31551: LD_ADDR_VAR 0 3
31555: PUSH
31556: LD_VAR 0 4
31560: PUSH
31561: FOR_IN
31562: IFFALSE 31785
// begin if IsInUnit ( j ) then
31564: LD_VAR 0 3
31568: PPUSH
31569: CALL_OW 310
31573: IFFALSE 31584
// ComExitBuilding ( j ) ;
31575: LD_VAR 0 3
31579: PPUSH
31580: CALL_OW 122
// if not j in mc_healers [ i ] then
31584: LD_VAR 0 3
31588: PUSH
31589: LD_EXP 99
31593: PUSH
31594: LD_VAR 0 2
31598: ARRAY
31599: IN
31600: NOT
31601: IFFALSE 31647
// mc_healers := ReplaceIn ( mc_healers , [ i , mc_healers [ i ] + 1 ] , j ) ;
31603: LD_ADDR_EXP 99
31607: PUSH
31608: LD_EXP 99
31612: PPUSH
31613: LD_VAR 0 2
31617: PUSH
31618: LD_EXP 99
31622: PUSH
31623: LD_VAR 0 2
31627: ARRAY
31628: PUSH
31629: LD_INT 1
31631: PLUS
31632: PUSH
31633: EMPTY
31634: LIST
31635: LIST
31636: PPUSH
31637: LD_VAR 0 3
31641: PPUSH
31642: CALL 57012 0 3
31646: ST_TO_ADDR
// if GetTag ( j ) <> 102 then
31647: LD_VAR 0 3
31651: PPUSH
31652: CALL_OW 110
31656: PUSH
31657: LD_INT 102
31659: NONEQUAL
31660: IFFALSE 31674
// SetTag ( j , 102 ) ;
31662: LD_VAR 0 3
31666: PPUSH
31667: LD_INT 102
31669: PPUSH
31670: CALL_OW 109
// Wait ( 3 ) ;
31674: LD_INT 3
31676: PPUSH
31677: CALL_OW 67
// if mc_need_heal [ i ] [ 1 ] then
31681: LD_EXP 98
31685: PUSH
31686: LD_VAR 0 2
31690: ARRAY
31691: PUSH
31692: LD_INT 1
31694: ARRAY
31695: IFFALSE 31727
// ComHeal ( j , mc_need_heal [ i ] [ 1 ] [ 1 ] ) else
31697: LD_VAR 0 3
31701: PPUSH
31702: LD_EXP 98
31706: PUSH
31707: LD_VAR 0 2
31711: ARRAY
31712: PUSH
31713: LD_INT 1
31715: ARRAY
31716: PUSH
31717: LD_INT 1
31719: ARRAY
31720: PPUSH
31721: CALL_OW 128
31725: GO 31783
// if not HasTask ( j ) and mc_need_heal [ i ] [ 2 ] then
31727: LD_VAR 0 3
31731: PPUSH
31732: CALL_OW 314
31736: NOT
31737: PUSH
31738: LD_EXP 98
31742: PUSH
31743: LD_VAR 0 2
31747: ARRAY
31748: PUSH
31749: LD_INT 2
31751: ARRAY
31752: AND
31753: IFFALSE 31783
// ComHeal ( j , mc_need_heal [ i ] [ 2 ] [ 1 ] ) ;
31755: LD_VAR 0 3
31759: PPUSH
31760: LD_EXP 98
31764: PUSH
31765: LD_VAR 0 2
31769: ARRAY
31770: PUSH
31771: LD_INT 2
31773: ARRAY
31774: PUSH
31775: LD_INT 1
31777: ARRAY
31778: PPUSH
31779: CALL_OW 128
// end ;
31783: GO 31561
31785: POP
31786: POP
// end ;
31787: GO 31404
31789: POP
31790: POP
// end ;
31791: LD_VAR 0 1
31795: RET
// export function MC_Build ( ) ; var i , j , tmp , depot ; begin
31796: LD_INT 0
31798: PPUSH
31799: PPUSH
31800: PPUSH
31801: PPUSH
31802: PPUSH
// if not mc_bases then
31803: LD_EXP 95
31807: NOT
31808: IFFALSE 31812
// exit ;
31810: GO 32983
// for i = 1 to mc_bases do
31812: LD_ADDR_VAR 0 2
31816: PUSH
31817: DOUBLE
31818: LD_INT 1
31820: DEC
31821: ST_TO_ADDR
31822: LD_EXP 95
31826: PUSH
31827: FOR_TO
31828: IFFALSE 32981
// begin if mc_scan [ i ] then
31830: LD_EXP 118
31834: PUSH
31835: LD_VAR 0 2
31839: ARRAY
31840: IFFALSE 31844
// continue ;
31842: GO 31827
// if not mc_build_list [ i ] and not mc_construct_list [ i ] and mc_builders [ i ] then
31844: LD_EXP 100
31848: PUSH
31849: LD_VAR 0 2
31853: ARRAY
31854: NOT
31855: PUSH
31856: LD_EXP 102
31860: PUSH
31861: LD_VAR 0 2
31865: ARRAY
31866: NOT
31867: AND
31868: PUSH
31869: LD_EXP 101
31873: PUSH
31874: LD_VAR 0 2
31878: ARRAY
31879: AND
31880: IFFALSE 31918
// begin mc_builders := Replace ( mc_builders , i , [ ] ) ;
31882: LD_ADDR_EXP 101
31886: PUSH
31887: LD_EXP 101
31891: PPUSH
31892: LD_VAR 0 2
31896: PPUSH
31897: EMPTY
31898: PPUSH
31899: CALL_OW 1
31903: ST_TO_ADDR
// MC_Reset ( i , 103 ) ;
31904: LD_VAR 0 2
31908: PPUSH
31909: LD_INT 103
31911: PPUSH
31912: CALL 25554 0 2
// continue ;
31916: GO 31827
// end ; if mc_construct_list [ i ] then
31918: LD_EXP 102
31922: PUSH
31923: LD_VAR 0 2
31927: ARRAY
31928: IFFALSE 32148
// begin tmp := UnitFilter ( mc_bases [ i ] , [ f_class , 2 ] ) diff mc_building_repairs [ i ] ;
31930: LD_ADDR_VAR 0 4
31934: PUSH
31935: LD_EXP 95
31939: PUSH
31940: LD_VAR 0 2
31944: ARRAY
31945: PPUSH
31946: LD_INT 25
31948: PUSH
31949: LD_INT 2
31951: PUSH
31952: EMPTY
31953: LIST
31954: LIST
31955: PPUSH
31956: CALL_OW 72
31960: PUSH
31961: LD_EXP 97
31965: PUSH
31966: LD_VAR 0 2
31970: ARRAY
31971: DIFF
31972: ST_TO_ADDR
// if not tmp then
31973: LD_VAR 0 4
31977: NOT
31978: IFFALSE 31982
// continue ;
31980: GO 31827
// for j in tmp do
31982: LD_ADDR_VAR 0 3
31986: PUSH
31987: LD_VAR 0 4
31991: PUSH
31992: FOR_IN
31993: IFFALSE 32144
// begin if not mc_builders [ i ] then
31995: LD_EXP 101
31999: PUSH
32000: LD_VAR 0 2
32004: ARRAY
32005: NOT
32006: IFFALSE 32064
// begin SetTag ( j , 103 ) ;
32008: LD_VAR 0 3
32012: PPUSH
32013: LD_INT 103
32015: PPUSH
32016: CALL_OW 109
// mc_builders := ReplaceIn ( mc_builders , [ i , mc_builders [ i ] + 1 ] , j ) ;
32020: LD_ADDR_EXP 101
32024: PUSH
32025: LD_EXP 101
32029: PPUSH
32030: LD_VAR 0 2
32034: PUSH
32035: LD_EXP 101
32039: PUSH
32040: LD_VAR 0 2
32044: ARRAY
32045: PUSH
32046: LD_INT 1
32048: PLUS
32049: PUSH
32050: EMPTY
32051: LIST
32052: LIST
32053: PPUSH
32054: LD_VAR 0 3
32058: PPUSH
32059: CALL 57012 0 3
32063: ST_TO_ADDR
// end ; if IsInUnit ( j ) then
32064: LD_VAR 0 3
32068: PPUSH
32069: CALL_OW 310
32073: IFFALSE 32084
// ComExitBuilding ( j ) ;
32075: LD_VAR 0 3
32079: PPUSH
32080: CALL_OW 122
// wait ( 3 ) ;
32084: LD_INT 3
32086: PPUSH
32087: CALL_OW 67
// if not mc_construct_list [ i ] then
32091: LD_EXP 102
32095: PUSH
32096: LD_VAR 0 2
32100: ARRAY
32101: NOT
32102: IFFALSE 32106
// break ;
32104: GO 32144
// if not HasTask ( j ) then
32106: LD_VAR 0 3
32110: PPUSH
32111: CALL_OW 314
32115: NOT
32116: IFFALSE 32142
// ComComplete ( j , mc_construct_list [ i ] [ 1 ] ) ;
32118: LD_VAR 0 3
32122: PPUSH
32123: LD_EXP 102
32127: PUSH
32128: LD_VAR 0 2
32132: ARRAY
32133: PUSH
32134: LD_INT 1
32136: ARRAY
32137: PPUSH
32138: CALL 59875 0 2
// end ;
32142: GO 31992
32144: POP
32145: POP
// end else
32146: GO 32979
// if mc_build_list [ i ] then
32148: LD_EXP 100
32152: PUSH
32153: LD_VAR 0 2
32157: ARRAY
32158: IFFALSE 32979
// begin depot := UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) ;
32160: LD_ADDR_VAR 0 5
32164: PUSH
32165: LD_EXP 95
32169: PUSH
32170: LD_VAR 0 2
32174: ARRAY
32175: PPUSH
32176: LD_INT 2
32178: PUSH
32179: LD_INT 30
32181: PUSH
32182: LD_INT 0
32184: PUSH
32185: EMPTY
32186: LIST
32187: LIST
32188: PUSH
32189: LD_INT 30
32191: PUSH
32192: LD_INT 1
32194: PUSH
32195: EMPTY
32196: LIST
32197: LIST
32198: PUSH
32199: EMPTY
32200: LIST
32201: LIST
32202: LIST
32203: PPUSH
32204: CALL_OW 72
32208: ST_TO_ADDR
// if depot then
32209: LD_VAR 0 5
32213: IFFALSE 32231
// depot := depot [ 1 ] else
32215: LD_ADDR_VAR 0 5
32219: PUSH
32220: LD_VAR 0 5
32224: PUSH
32225: LD_INT 1
32227: ARRAY
32228: ST_TO_ADDR
32229: GO 32239
// depot := 0 ;
32231: LD_ADDR_VAR 0 5
32235: PUSH
32236: LD_INT 0
32238: ST_TO_ADDR
// if IsExtension ( mc_build_list [ i ] [ 1 ] [ 1 ] ) and not UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_workshop ] , [ f_btype , b_factory ] ] ) then
32239: LD_EXP 100
32243: PUSH
32244: LD_VAR 0 2
32248: ARRAY
32249: PUSH
32250: LD_INT 1
32252: ARRAY
32253: PUSH
32254: LD_INT 1
32256: ARRAY
32257: PPUSH
32258: CALL 59699 0 1
32262: PUSH
32263: LD_EXP 95
32267: PUSH
32268: LD_VAR 0 2
32272: ARRAY
32273: PPUSH
32274: LD_INT 2
32276: PUSH
32277: LD_INT 30
32279: PUSH
32280: LD_INT 2
32282: PUSH
32283: EMPTY
32284: LIST
32285: LIST
32286: PUSH
32287: LD_INT 30
32289: PUSH
32290: LD_INT 3
32292: PUSH
32293: EMPTY
32294: LIST
32295: LIST
32296: PUSH
32297: EMPTY
32298: LIST
32299: LIST
32300: LIST
32301: PPUSH
32302: CALL_OW 72
32306: NOT
32307: AND
32308: IFFALSE 32413
// begin for j = 1 to mc_build_list [ i ] do
32310: LD_ADDR_VAR 0 3
32314: PUSH
32315: DOUBLE
32316: LD_INT 1
32318: DEC
32319: ST_TO_ADDR
32320: LD_EXP 100
32324: PUSH
32325: LD_VAR 0 2
32329: ARRAY
32330: PUSH
32331: FOR_TO
32332: IFFALSE 32411
// if mc_build_list [ i ] [ j ] [ 1 ] = b_workshop then
32334: LD_EXP 100
32338: PUSH
32339: LD_VAR 0 2
32343: ARRAY
32344: PUSH
32345: LD_VAR 0 3
32349: ARRAY
32350: PUSH
32351: LD_INT 1
32353: ARRAY
32354: PUSH
32355: LD_INT 2
32357: EQUAL
32358: IFFALSE 32409
// begin mc_build_list := Replace ( mc_build_list , i , Reindex ( mc_build_list [ i ] , j , 1 , false ) ) ;
32360: LD_ADDR_EXP 100
32364: PUSH
32365: LD_EXP 100
32369: PPUSH
32370: LD_VAR 0 2
32374: PPUSH
32375: LD_EXP 100
32379: PUSH
32380: LD_VAR 0 2
32384: ARRAY
32385: PPUSH
32386: LD_VAR 0 3
32390: PPUSH
32391: LD_INT 1
32393: PPUSH
32394: LD_INT 0
32396: PPUSH
32397: CALL 56430 0 4
32401: PPUSH
32402: CALL_OW 1
32406: ST_TO_ADDR
// break ;
32407: GO 32411
// end ;
32409: GO 32331
32411: POP
32412: POP
// end ; if mc_build_list [ i ] [ 1 ] [ 1 ] = b_depot or ( depot and CanBeBuilt ( depot , mc_build_list [ i ] [ 1 ] [ 1 ] , mc_build_list [ i ] [ 1 ] [ 2 ] , mc_build_list [ i ] [ 1 ] [ 3 ] , mc_build_list [ i ] [ 1 ] [ 4 ] ) ) then
32413: LD_EXP 100
32417: PUSH
32418: LD_VAR 0 2
32422: ARRAY
32423: PUSH
32424: LD_INT 1
32426: ARRAY
32427: PUSH
32428: LD_INT 1
32430: ARRAY
32431: PUSH
32432: LD_INT 0
32434: EQUAL
32435: PUSH
32436: LD_VAR 0 5
32440: PUSH
32441: LD_VAR 0 5
32445: PPUSH
32446: LD_EXP 100
32450: PUSH
32451: LD_VAR 0 2
32455: ARRAY
32456: PUSH
32457: LD_INT 1
32459: ARRAY
32460: PUSH
32461: LD_INT 1
32463: ARRAY
32464: PPUSH
32465: LD_EXP 100
32469: PUSH
32470: LD_VAR 0 2
32474: ARRAY
32475: PUSH
32476: LD_INT 1
32478: ARRAY
32479: PUSH
32480: LD_INT 2
32482: ARRAY
32483: PPUSH
32484: LD_EXP 100
32488: PUSH
32489: LD_VAR 0 2
32493: ARRAY
32494: PUSH
32495: LD_INT 1
32497: ARRAY
32498: PUSH
32499: LD_INT 3
32501: ARRAY
32502: PPUSH
32503: LD_EXP 100
32507: PUSH
32508: LD_VAR 0 2
32512: ARRAY
32513: PUSH
32514: LD_INT 1
32516: ARRAY
32517: PUSH
32518: LD_INT 4
32520: ARRAY
32521: PPUSH
32522: CALL 65115 0 5
32526: AND
32527: OR
32528: IFFALSE 32809
// begin tmp := UnitFilter ( mc_bases [ i ] , [ f_class , 2 ] ) diff mc_building_repairs [ i ] ;
32530: LD_ADDR_VAR 0 4
32534: PUSH
32535: LD_EXP 95
32539: PUSH
32540: LD_VAR 0 2
32544: ARRAY
32545: PPUSH
32546: LD_INT 25
32548: PUSH
32549: LD_INT 2
32551: PUSH
32552: EMPTY
32553: LIST
32554: LIST
32555: PPUSH
32556: CALL_OW 72
32560: PUSH
32561: LD_EXP 97
32565: PUSH
32566: LD_VAR 0 2
32570: ARRAY
32571: DIFF
32572: ST_TO_ADDR
// if not tmp then
32573: LD_VAR 0 4
32577: NOT
32578: IFFALSE 32582
// continue ;
32580: GO 31827
// for j in tmp do
32582: LD_ADDR_VAR 0 3
32586: PUSH
32587: LD_VAR 0 4
32591: PUSH
32592: FOR_IN
32593: IFFALSE 32805
// begin if not mc_builders [ i ] then
32595: LD_EXP 101
32599: PUSH
32600: LD_VAR 0 2
32604: ARRAY
32605: NOT
32606: IFFALSE 32664
// begin SetTag ( j , 103 ) ;
32608: LD_VAR 0 3
32612: PPUSH
32613: LD_INT 103
32615: PPUSH
32616: CALL_OW 109
// mc_builders := ReplaceIn ( mc_builders , [ i , mc_builders [ i ] + 1 ] , j ) ;
32620: LD_ADDR_EXP 101
32624: PUSH
32625: LD_EXP 101
32629: PPUSH
32630: LD_VAR 0 2
32634: PUSH
32635: LD_EXP 101
32639: PUSH
32640: LD_VAR 0 2
32644: ARRAY
32645: PUSH
32646: LD_INT 1
32648: PLUS
32649: PUSH
32650: EMPTY
32651: LIST
32652: LIST
32653: PPUSH
32654: LD_VAR 0 3
32658: PPUSH
32659: CALL 57012 0 3
32663: ST_TO_ADDR
// end ; if IsInUnit ( j ) then
32664: LD_VAR 0 3
32668: PPUSH
32669: CALL_OW 310
32673: IFFALSE 32684
// ComExitBuilding ( j ) ;
32675: LD_VAR 0 3
32679: PPUSH
32680: CALL_OW 122
// wait ( 3 ) ;
32684: LD_INT 3
32686: PPUSH
32687: CALL_OW 67
// if not mc_build_list [ i ] then
32691: LD_EXP 100
32695: PUSH
32696: LD_VAR 0 2
32700: ARRAY
32701: NOT
32702: IFFALSE 32706
// break ;
32704: GO 32805
// if not HasTask ( j ) then
32706: LD_VAR 0 3
32710: PPUSH
32711: CALL_OW 314
32715: NOT
32716: IFFALSE 32803
// ComBuild ( j , mc_build_list [ i ] [ 1 ] [ 1 ] , mc_build_list [ i ] [ 1 ] [ 2 ] , mc_build_list [ i ] [ 1 ] [ 3 ] , mc_build_list [ i ] [ 1 ] [ 4 ] ) ;
32718: LD_VAR 0 3
32722: PPUSH
32723: LD_EXP 100
32727: PUSH
32728: LD_VAR 0 2
32732: ARRAY
32733: PUSH
32734: LD_INT 1
32736: ARRAY
32737: PUSH
32738: LD_INT 1
32740: ARRAY
32741: PPUSH
32742: LD_EXP 100
32746: PUSH
32747: LD_VAR 0 2
32751: ARRAY
32752: PUSH
32753: LD_INT 1
32755: ARRAY
32756: PUSH
32757: LD_INT 2
32759: ARRAY
32760: PPUSH
32761: LD_EXP 100
32765: PUSH
32766: LD_VAR 0 2
32770: ARRAY
32771: PUSH
32772: LD_INT 1
32774: ARRAY
32775: PUSH
32776: LD_INT 3
32778: ARRAY
32779: PPUSH
32780: LD_EXP 100
32784: PUSH
32785: LD_VAR 0 2
32789: ARRAY
32790: PUSH
32791: LD_INT 1
32793: ARRAY
32794: PUSH
32795: LD_INT 4
32797: ARRAY
32798: PPUSH
32799: CALL_OW 145
// end ;
32803: GO 32592
32805: POP
32806: POP
// end else
32807: GO 32979
// if not TryClearPlaceForBuilding ( mc_bases [ i ] , mc_build_list [ i ] [ 1 ] [ 1 ] , mc_build_list [ i ] [ 1 ] [ 2 ] , mc_build_list [ i ] [ 1 ] [ 3 ] , mc_build_list [ i ] [ 1 ] [ 4 ] , UnitFilter ( mc_bases [ i ] , [ f_type , unit_building ] ) , [ ] ) then
32809: LD_EXP 95
32813: PUSH
32814: LD_VAR 0 2
32818: ARRAY
32819: PPUSH
32820: LD_EXP 100
32824: PUSH
32825: LD_VAR 0 2
32829: ARRAY
32830: PUSH
32831: LD_INT 1
32833: ARRAY
32834: PUSH
32835: LD_INT 1
32837: ARRAY
32838: PPUSH
32839: LD_EXP 100
32843: PUSH
32844: LD_VAR 0 2
32848: ARRAY
32849: PUSH
32850: LD_INT 1
32852: ARRAY
32853: PUSH
32854: LD_INT 2
32856: ARRAY
32857: PPUSH
32858: LD_EXP 100
32862: PUSH
32863: LD_VAR 0 2
32867: ARRAY
32868: PUSH
32869: LD_INT 1
32871: ARRAY
32872: PUSH
32873: LD_INT 3
32875: ARRAY
32876: PPUSH
32877: LD_EXP 100
32881: PUSH
32882: LD_VAR 0 2
32886: ARRAY
32887: PUSH
32888: LD_INT 1
32890: ARRAY
32891: PUSH
32892: LD_INT 4
32894: ARRAY
32895: PPUSH
32896: LD_EXP 95
32900: PUSH
32901: LD_VAR 0 2
32905: ARRAY
32906: PPUSH
32907: LD_INT 21
32909: PUSH
32910: LD_INT 3
32912: PUSH
32913: EMPTY
32914: LIST
32915: LIST
32916: PPUSH
32917: CALL_OW 72
32921: PPUSH
32922: EMPTY
32923: PPUSH
32924: CALL 63865 0 7
32928: NOT
32929: IFFALSE 32979
// begin mc_build_list := Replace ( mc_build_list , i , Reindex ( mc_build_list [ i ] , 1 , - 1 , false ) ) ;
32931: LD_ADDR_EXP 100
32935: PUSH
32936: LD_EXP 100
32940: PPUSH
32941: LD_VAR 0 2
32945: PPUSH
32946: LD_EXP 100
32950: PUSH
32951: LD_VAR 0 2
32955: ARRAY
32956: PPUSH
32957: LD_INT 1
32959: PPUSH
32960: LD_INT 1
32962: NEG
32963: PPUSH
32964: LD_INT 0
32966: PPUSH
32967: CALL 56430 0 4
32971: PPUSH
32972: CALL_OW 1
32976: ST_TO_ADDR
// continue ;
32977: GO 31827
// end ; end ; end ;
32979: GO 31827
32981: POP
32982: POP
// end ;
32983: LD_VAR 0 1
32987: RET
// export function MC_BuildUpgrade ( ) ; var i , j , tmp , depot , lab ; begin
32988: LD_INT 0
32990: PPUSH
32991: PPUSH
32992: PPUSH
32993: PPUSH
32994: PPUSH
32995: PPUSH
// if not mc_bases then
32996: LD_EXP 95
33000: NOT
33001: IFFALSE 33005
// exit ;
33003: GO 33432
// for i = 1 to mc_bases do
33005: LD_ADDR_VAR 0 2
33009: PUSH
33010: DOUBLE
33011: LD_INT 1
33013: DEC
33014: ST_TO_ADDR
33015: LD_EXP 95
33019: PUSH
33020: FOR_TO
33021: IFFALSE 33430
// begin tmp := mc_build_upgrade [ i ] ;
33023: LD_ADDR_VAR 0 4
33027: PUSH
33028: LD_EXP 127
33032: PUSH
33033: LD_VAR 0 2
33037: ARRAY
33038: ST_TO_ADDR
// lab := UnitFilter ( mc_lab [ i ] , [ f_or , [ f_btype , b_lab ] , [ f_btype , b_lab_half ] ] ) ;
33039: LD_ADDR_VAR 0 6
33043: PUSH
33044: LD_EXP 128
33048: PUSH
33049: LD_VAR 0 2
33053: ARRAY
33054: PPUSH
33055: LD_INT 2
33057: PUSH
33058: LD_INT 30
33060: PUSH
33061: LD_INT 6
33063: PUSH
33064: EMPTY
33065: LIST
33066: LIST
33067: PUSH
33068: LD_INT 30
33070: PUSH
33071: LD_INT 7
33073: PUSH
33074: EMPTY
33075: LIST
33076: LIST
33077: PUSH
33078: EMPTY
33079: LIST
33080: LIST
33081: LIST
33082: PPUSH
33083: CALL_OW 72
33087: ST_TO_ADDR
// if not tmp and not lab then
33088: LD_VAR 0 4
33092: NOT
33093: PUSH
33094: LD_VAR 0 6
33098: NOT
33099: AND
33100: IFFALSE 33104
// continue ;
33102: GO 33020
// if tmp then
33104: LD_VAR 0 4
33108: IFFALSE 33228
// for j in tmp do
33110: LD_ADDR_VAR 0 3
33114: PUSH
33115: LD_VAR 0 4
33119: PUSH
33120: FOR_IN
33121: IFFALSE 33226
// begin if UpgradeCost ( j ) then
33123: LD_VAR 0 3
33127: PPUSH
33128: CALL 63525 0 1
33132: IFFALSE 33224
// begin ComUpgrade ( j ) ;
33134: LD_VAR 0 3
33138: PPUSH
33139: CALL_OW 146
// mc_build_upgrade := Replace ( mc_build_upgrade , i , mc_build_upgrade [ i ] diff j ) ;
33143: LD_ADDR_EXP 127
33147: PUSH
33148: LD_EXP 127
33152: PPUSH
33153: LD_VAR 0 2
33157: PPUSH
33158: LD_EXP 127
33162: PUSH
33163: LD_VAR 0 2
33167: ARRAY
33168: PUSH
33169: LD_VAR 0 3
33173: DIFF
33174: PPUSH
33175: CALL_OW 1
33179: ST_TO_ADDR
// mc_construct_list := ReplaceIn ( mc_construct_list , [ i , mc_construct_list [ i ] + 1 ] , j ) ;
33180: LD_ADDR_EXP 102
33184: PUSH
33185: LD_EXP 102
33189: PPUSH
33190: LD_VAR 0 2
33194: PUSH
33195: LD_EXP 102
33199: PUSH
33200: LD_VAR 0 2
33204: ARRAY
33205: PUSH
33206: LD_INT 1
33208: PLUS
33209: PUSH
33210: EMPTY
33211: LIST
33212: LIST
33213: PPUSH
33214: LD_VAR 0 3
33218: PPUSH
33219: CALL 57012 0 3
33223: ST_TO_ADDR
// end ; end ;
33224: GO 33120
33226: POP
33227: POP
// if not lab or not mc_lab_upgrade [ i ] then
33228: LD_VAR 0 6
33232: NOT
33233: PUSH
33234: LD_EXP 129
33238: PUSH
33239: LD_VAR 0 2
33243: ARRAY
33244: NOT
33245: OR
33246: IFFALSE 33250
// continue ;
33248: GO 33020
// for j in lab do
33250: LD_ADDR_VAR 0 3
33254: PUSH
33255: LD_VAR 0 6
33259: PUSH
33260: FOR_IN
33261: IFFALSE 33426
// begin if GetBType ( j ) in [ b_lab , b_lab_half ] and BuildingStatus ( j ) <> bs_build then
33263: LD_VAR 0 3
33267: PPUSH
33268: CALL_OW 266
33272: PUSH
33273: LD_INT 6
33275: PUSH
33276: LD_INT 7
33278: PUSH
33279: EMPTY
33280: LIST
33281: LIST
33282: IN
33283: PUSH
33284: LD_VAR 0 3
33288: PPUSH
33289: CALL_OW 461
33293: PUSH
33294: LD_INT 1
33296: NONEQUAL
33297: AND
33298: IFFALSE 33424
// begin if UpgradeLabCost ( j , mc_lab_upgrade [ i ] [ 1 ] ) then
33300: LD_VAR 0 3
33304: PPUSH
33305: LD_EXP 129
33309: PUSH
33310: LD_VAR 0 2
33314: ARRAY
33315: PUSH
33316: LD_INT 1
33318: ARRAY
33319: PPUSH
33320: CALL 63730 0 2
33324: IFFALSE 33424
// begin ComCancel ( j ) ;
33326: LD_VAR 0 3
33330: PPUSH
33331: CALL_OW 127
// AddComUpgradeLab ( j , mc_lab_upgrade [ i ] [ 1 ] ) ;
33335: LD_VAR 0 3
33339: PPUSH
33340: LD_EXP 129
33344: PUSH
33345: LD_VAR 0 2
33349: ARRAY
33350: PUSH
33351: LD_INT 1
33353: ARRAY
33354: PPUSH
33355: CALL_OW 207
// if not j in mc_construct_list [ i ] then
33359: LD_VAR 0 3
33363: PUSH
33364: LD_EXP 102
33368: PUSH
33369: LD_VAR 0 2
33373: ARRAY
33374: IN
33375: NOT
33376: IFFALSE 33422
// mc_construct_list := ReplaceIn ( mc_construct_list , [ i , mc_construct_list [ i ] + 1 ] , j ) ;
33378: LD_ADDR_EXP 102
33382: PUSH
33383: LD_EXP 102
33387: PPUSH
33388: LD_VAR 0 2
33392: PUSH
33393: LD_EXP 102
33397: PUSH
33398: LD_VAR 0 2
33402: ARRAY
33403: PUSH
33404: LD_INT 1
33406: PLUS
33407: PUSH
33408: EMPTY
33409: LIST
33410: LIST
33411: PPUSH
33412: LD_VAR 0 3
33416: PPUSH
33417: CALL 57012 0 3
33421: ST_TO_ADDR
// break ;
33422: GO 33426
// end ; end ; end ;
33424: GO 33260
33426: POP
33427: POP
// end ;
33428: GO 33020
33430: POP
33431: POP
// end ;
33432: LD_VAR 0 1
33436: RET
// export function MC_TurretWeapon ( ) ; var i , j , tmp , tmp2 , t , tw , busy , weapon ; begin
33437: LD_INT 0
33439: PPUSH
33440: PPUSH
33441: PPUSH
33442: PPUSH
33443: PPUSH
33444: PPUSH
33445: PPUSH
33446: PPUSH
33447: PPUSH
// if not mc_bases then
33448: LD_EXP 95
33452: NOT
33453: IFFALSE 33457
// exit ;
33455: GO 33862
// for i = 1 to mc_bases do
33457: LD_ADDR_VAR 0 2
33461: PUSH
33462: DOUBLE
33463: LD_INT 1
33465: DEC
33466: ST_TO_ADDR
33467: LD_EXP 95
33471: PUSH
33472: FOR_TO
33473: IFFALSE 33860
// begin if not mc_turret_list [ i ] or not UnitFilter ( mc_bases [ i ] , [ f_btype , b_factory ] ) then
33475: LD_EXP 103
33479: PUSH
33480: LD_VAR 0 2
33484: ARRAY
33485: NOT
33486: PUSH
33487: LD_EXP 95
33491: PUSH
33492: LD_VAR 0 2
33496: ARRAY
33497: PPUSH
33498: LD_INT 30
33500: PUSH
33501: LD_INT 3
33503: PUSH
33504: EMPTY
33505: LIST
33506: LIST
33507: PPUSH
33508: CALL_OW 72
33512: NOT
33513: OR
33514: IFFALSE 33518
// continue ;
33516: GO 33472
// busy := false ;
33518: LD_ADDR_VAR 0 8
33522: PUSH
33523: LD_INT 0
33525: ST_TO_ADDR
// tmp := UnitFilter ( mc_bases [ i ] , [ f_btype , b_factory ] ) ;
33526: LD_ADDR_VAR 0 4
33530: PUSH
33531: LD_EXP 95
33535: PUSH
33536: LD_VAR 0 2
33540: ARRAY
33541: PPUSH
33542: LD_INT 30
33544: PUSH
33545: LD_INT 3
33547: PUSH
33548: EMPTY
33549: LIST
33550: LIST
33551: PPUSH
33552: CALL_OW 72
33556: ST_TO_ADDR
// t := UnitFilter ( mc_turret_list [ i ] , [ f_or , [ f_btype , b_bunker ] , [ f_btype , b_turret ] ] ) ;
33557: LD_ADDR_VAR 0 6
33561: PUSH
33562: LD_EXP 103
33566: PUSH
33567: LD_VAR 0 2
33571: ARRAY
33572: PPUSH
33573: LD_INT 2
33575: PUSH
33576: LD_INT 30
33578: PUSH
33579: LD_INT 32
33581: PUSH
33582: EMPTY
33583: LIST
33584: LIST
33585: PUSH
33586: LD_INT 30
33588: PUSH
33589: LD_INT 33
33591: PUSH
33592: EMPTY
33593: LIST
33594: LIST
33595: PUSH
33596: EMPTY
33597: LIST
33598: LIST
33599: LIST
33600: PPUSH
33601: CALL_OW 72
33605: ST_TO_ADDR
// if not t then
33606: LD_VAR 0 6
33610: NOT
33611: IFFALSE 33615
// continue ;
33613: GO 33472
// for j in tmp do
33615: LD_ADDR_VAR 0 3
33619: PUSH
33620: LD_VAR 0 4
33624: PUSH
33625: FOR_IN
33626: IFFALSE 33656
// if not BuildingStatus ( j ) = bs_idle then
33628: LD_VAR 0 3
33632: PPUSH
33633: CALL_OW 461
33637: PUSH
33638: LD_INT 2
33640: EQUAL
33641: NOT
33642: IFFALSE 33654
// begin busy := true ;
33644: LD_ADDR_VAR 0 8
33648: PUSH
33649: LD_INT 1
33651: ST_TO_ADDR
// break ;
33652: GO 33656
// end ;
33654: GO 33625
33656: POP
33657: POP
// if busy then
33658: LD_VAR 0 8
33662: IFFALSE 33666
// continue ;
33664: GO 33472
// tw := UnitFilter ( t , [ f_bweapon , 0 ] ) ;
33666: LD_ADDR_VAR 0 7
33670: PUSH
33671: LD_VAR 0 6
33675: PPUSH
33676: LD_INT 35
33678: PUSH
33679: LD_INT 0
33681: PUSH
33682: EMPTY
33683: LIST
33684: LIST
33685: PPUSH
33686: CALL_OW 72
33690: ST_TO_ADDR
// if tw then
33691: LD_VAR 0 7
33695: IFFALSE 33772
// begin tw := tw [ 1 ] ;
33697: LD_ADDR_VAR 0 7
33701: PUSH
33702: LD_VAR 0 7
33706: PUSH
33707: LD_INT 1
33709: ARRAY
33710: ST_TO_ADDR
// weapon := GetTurretWeapon ( tw , mc_scan_area [ i ] ) ;
33711: LD_ADDR_VAR 0 9
33715: PUSH
33716: LD_VAR 0 7
33720: PPUSH
33721: LD_EXP 120
33725: PUSH
33726: LD_VAR 0 2
33730: ARRAY
33731: PPUSH
33732: CALL 62022 0 2
33736: ST_TO_ADDR
// if mc_allowed_tower_weapons [ i ] then
33737: LD_EXP 134
33741: PUSH
33742: LD_VAR 0 2
33746: ARRAY
33747: IFFALSE 33770
// if not weapon in mc_allowed_tower_weapons [ i ] then
33749: LD_VAR 0 9
33753: PUSH
33754: LD_EXP 134
33758: PUSH
33759: LD_VAR 0 2
33763: ARRAY
33764: IN
33765: NOT
33766: IFFALSE 33770
// continue ;
33768: GO 33472
// end else
33770: GO 33835
// begin tmp2 := UpgradeTurretsWeapon ( mc_turret_list [ i ] , tmp ) ;
33772: LD_ADDR_VAR 0 5
33776: PUSH
33777: LD_EXP 103
33781: PUSH
33782: LD_VAR 0 2
33786: ARRAY
33787: PPUSH
33788: LD_VAR 0 4
33792: PPUSH
33793: CALL 88311 0 2
33797: ST_TO_ADDR
// if not tmp2 then
33798: LD_VAR 0 5
33802: NOT
33803: IFFALSE 33807
// continue ;
33805: GO 33472
// tw := tmp2 [ 1 ] ;
33807: LD_ADDR_VAR 0 7
33811: PUSH
33812: LD_VAR 0 5
33816: PUSH
33817: LD_INT 1
33819: ARRAY
33820: ST_TO_ADDR
// weapon := tmp2 [ 2 ] ;
33821: LD_ADDR_VAR 0 9
33825: PUSH
33826: LD_VAR 0 5
33830: PUSH
33831: LD_INT 2
33833: ARRAY
33834: ST_TO_ADDR
// end ; if not weapon then
33835: LD_VAR 0 9
33839: NOT
33840: IFFALSE 33844
// continue ;
33842: GO 33472
// ComPlaceWeapon ( tw , weapon ) ;
33844: LD_VAR 0 7
33848: PPUSH
33849: LD_VAR 0 9
33853: PPUSH
33854: CALL_OW 148
// end ;
33858: GO 33472
33860: POP
33861: POP
// end ;
33862: LD_VAR 0 1
33866: RET
// export function MC_PlantMines ( ) ; var i , j , k , tmp , list , r ; begin
33867: LD_INT 0
33869: PPUSH
33870: PPUSH
33871: PPUSH
33872: PPUSH
33873: PPUSH
33874: PPUSH
33875: PPUSH
// if not mc_bases then
33876: LD_EXP 95
33880: NOT
33881: IFFALSE 33885
// exit ;
33883: GO 34653
// for i = 1 to mc_bases do
33885: LD_ADDR_VAR 0 2
33889: PUSH
33890: DOUBLE
33891: LD_INT 1
33893: DEC
33894: ST_TO_ADDR
33895: LD_EXP 95
33899: PUSH
33900: FOR_TO
33901: IFFALSE 34651
// begin if not mc_mines [ i ] or mc_mines [ i ] = mc_miners [ i ] or mc_scan [ i ] then
33903: LD_EXP 108
33907: PUSH
33908: LD_VAR 0 2
33912: ARRAY
33913: NOT
33914: PUSH
33915: LD_EXP 108
33919: PUSH
33920: LD_VAR 0 2
33924: ARRAY
33925: PUSH
33926: LD_EXP 109
33930: PUSH
33931: LD_VAR 0 2
33935: ARRAY
33936: EQUAL
33937: OR
33938: PUSH
33939: LD_EXP 118
33943: PUSH
33944: LD_VAR 0 2
33948: ARRAY
33949: OR
33950: IFFALSE 33954
// continue ;
33952: GO 33900
// if mc_miners [ i ] then
33954: LD_EXP 109
33958: PUSH
33959: LD_VAR 0 2
33963: ARRAY
33964: IFFALSE 34338
// begin for j = mc_miners [ i ] downto 1 do
33966: LD_ADDR_VAR 0 3
33970: PUSH
33971: DOUBLE
33972: LD_EXP 109
33976: PUSH
33977: LD_VAR 0 2
33981: ARRAY
33982: INC
33983: ST_TO_ADDR
33984: LD_INT 1
33986: PUSH
33987: FOR_DOWNTO
33988: IFFALSE 34336
// begin if IsDead ( mc_miners [ i ] [ j ] ) or GetClass ( mc_miners [ i ] [ j ] ) <> 1 then
33990: LD_EXP 109
33994: PUSH
33995: LD_VAR 0 2
33999: ARRAY
34000: PUSH
34001: LD_VAR 0 3
34005: ARRAY
34006: PPUSH
34007: CALL_OW 301
34011: PUSH
34012: LD_EXP 109
34016: PUSH
34017: LD_VAR 0 2
34021: ARRAY
34022: PUSH
34023: LD_VAR 0 3
34027: ARRAY
34028: PPUSH
34029: CALL_OW 257
34033: PUSH
34034: LD_INT 1
34036: NONEQUAL
34037: OR
34038: IFFALSE 34101
// begin tmp := mc_miners [ i ] diff mc_miners [ i ] [ j ] ;
34040: LD_ADDR_VAR 0 5
34044: PUSH
34045: LD_EXP 109
34049: PUSH
34050: LD_VAR 0 2
34054: ARRAY
34055: PUSH
34056: LD_EXP 109
34060: PUSH
34061: LD_VAR 0 2
34065: ARRAY
34066: PUSH
34067: LD_VAR 0 3
34071: ARRAY
34072: DIFF
34073: ST_TO_ADDR
// mc_miners := Replace ( mc_miners , i , tmp ) ;
34074: LD_ADDR_EXP 109
34078: PUSH
34079: LD_EXP 109
34083: PPUSH
34084: LD_VAR 0 2
34088: PPUSH
34089: LD_VAR 0 5
34093: PPUSH
34094: CALL_OW 1
34098: ST_TO_ADDR
// continue ;
34099: GO 33987
// end ; if GetClass ( mc_miners [ i ] [ j ] ) = 1 and not MineOfUnit ( mc_miners [ i ] [ j ] ) and not HasTask ( mc_miners [ i ] [ j ] ) then
34101: LD_EXP 109
34105: PUSH
34106: LD_VAR 0 2
34110: ARRAY
34111: PUSH
34112: LD_VAR 0 3
34116: ARRAY
34117: PPUSH
34118: CALL_OW 257
34122: PUSH
34123: LD_INT 1
34125: EQUAL
34126: PUSH
34127: LD_EXP 109
34131: PUSH
34132: LD_VAR 0 2
34136: ARRAY
34137: PUSH
34138: LD_VAR 0 3
34142: ARRAY
34143: PPUSH
34144: CALL_OW 459
34148: NOT
34149: AND
34150: PUSH
34151: LD_EXP 109
34155: PUSH
34156: LD_VAR 0 2
34160: ARRAY
34161: PUSH
34162: LD_VAR 0 3
34166: ARRAY
34167: PPUSH
34168: CALL_OW 314
34172: NOT
34173: AND
34174: IFFALSE 34334
// begin if IsInUnit ( mc_miners [ i ] [ j ] ) then
34176: LD_EXP 109
34180: PUSH
34181: LD_VAR 0 2
34185: ARRAY
34186: PUSH
34187: LD_VAR 0 3
34191: ARRAY
34192: PPUSH
34193: CALL_OW 310
34197: IFFALSE 34220
// ComExitBuilding ( mc_miners [ i ] [ j ] ) ;
34199: LD_EXP 109
34203: PUSH
34204: LD_VAR 0 2
34208: ARRAY
34209: PUSH
34210: LD_VAR 0 3
34214: ARRAY
34215: PPUSH
34216: CALL_OW 122
// if not HasTask ( mc_miners [ i ] [ j ] ) then
34220: LD_EXP 109
34224: PUSH
34225: LD_VAR 0 2
34229: ARRAY
34230: PUSH
34231: LD_VAR 0 3
34235: ARRAY
34236: PPUSH
34237: CALL_OW 314
34241: NOT
34242: IFFALSE 34334
// begin r := rand ( 1 , mc_mines [ i ] ) ;
34244: LD_ADDR_VAR 0 7
34248: PUSH
34249: LD_INT 1
34251: PPUSH
34252: LD_EXP 108
34256: PUSH
34257: LD_VAR 0 2
34261: ARRAY
34262: PPUSH
34263: CALL_OW 12
34267: ST_TO_ADDR
// AddComPlaceRemoteCharge ( mc_miners [ i ] [ j ] , mc_mines [ i ] [ r ] [ 1 ] , mc_mines [ i ] [ r ] [ 2 ] , 0 ) ;
34268: LD_EXP 109
34272: PUSH
34273: LD_VAR 0 2
34277: ARRAY
34278: PUSH
34279: LD_VAR 0 3
34283: ARRAY
34284: PPUSH
34285: LD_EXP 108
34289: PUSH
34290: LD_VAR 0 2
34294: ARRAY
34295: PUSH
34296: LD_VAR 0 7
34300: ARRAY
34301: PUSH
34302: LD_INT 1
34304: ARRAY
34305: PPUSH
34306: LD_EXP 108
34310: PUSH
34311: LD_VAR 0 2
34315: ARRAY
34316: PUSH
34317: LD_VAR 0 7
34321: ARRAY
34322: PUSH
34323: LD_INT 2
34325: ARRAY
34326: PPUSH
34327: LD_INT 0
34329: PPUSH
34330: CALL_OW 193
// end ; end ; end ;
34334: GO 33987
34336: POP
34337: POP
// end ; tmp := UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_armoury ] , [ f_btype , b_barracks ] , [ f_btype , b_bunker ] ] ) ;
34338: LD_ADDR_VAR 0 5
34342: PUSH
34343: LD_EXP 95
34347: PUSH
34348: LD_VAR 0 2
34352: ARRAY
34353: PPUSH
34354: LD_INT 2
34356: PUSH
34357: LD_INT 30
34359: PUSH
34360: LD_INT 4
34362: PUSH
34363: EMPTY
34364: LIST
34365: LIST
34366: PUSH
34367: LD_INT 30
34369: PUSH
34370: LD_INT 5
34372: PUSH
34373: EMPTY
34374: LIST
34375: LIST
34376: PUSH
34377: LD_INT 30
34379: PUSH
34380: LD_INT 32
34382: PUSH
34383: EMPTY
34384: LIST
34385: LIST
34386: PUSH
34387: EMPTY
34388: LIST
34389: LIST
34390: LIST
34391: LIST
34392: PPUSH
34393: CALL_OW 72
34397: ST_TO_ADDR
// if not tmp then
34398: LD_VAR 0 5
34402: NOT
34403: IFFALSE 34407
// continue ;
34405: GO 33900
// list := [ ] ;
34407: LD_ADDR_VAR 0 6
34411: PUSH
34412: EMPTY
34413: ST_TO_ADDR
// for j in tmp do
34414: LD_ADDR_VAR 0 3
34418: PUSH
34419: LD_VAR 0 5
34423: PUSH
34424: FOR_IN
34425: IFFALSE 34494
// begin for k in UnitsInside ( j ) do
34427: LD_ADDR_VAR 0 4
34431: PUSH
34432: LD_VAR 0 3
34436: PPUSH
34437: CALL_OW 313
34441: PUSH
34442: FOR_IN
34443: IFFALSE 34490
// if GetClass ( k ) = 1 and not MineOfUnit ( k ) then
34445: LD_VAR 0 4
34449: PPUSH
34450: CALL_OW 257
34454: PUSH
34455: LD_INT 1
34457: EQUAL
34458: PUSH
34459: LD_VAR 0 4
34463: PPUSH
34464: CALL_OW 459
34468: NOT
34469: AND
34470: IFFALSE 34488
// list := list ^ k ;
34472: LD_ADDR_VAR 0 6
34476: PUSH
34477: LD_VAR 0 6
34481: PUSH
34482: LD_VAR 0 4
34486: ADD
34487: ST_TO_ADDR
34488: GO 34442
34490: POP
34491: POP
// end ;
34492: GO 34424
34494: POP
34495: POP
// list := list diff mc_miners [ i ] ;
34496: LD_ADDR_VAR 0 6
34500: PUSH
34501: LD_VAR 0 6
34505: PUSH
34506: LD_EXP 109
34510: PUSH
34511: LD_VAR 0 2
34515: ARRAY
34516: DIFF
34517: ST_TO_ADDR
// if not list then
34518: LD_VAR 0 6
34522: NOT
34523: IFFALSE 34527
// continue ;
34525: GO 33900
// k := mc_mines [ i ] - mc_miners [ i ] ;
34527: LD_ADDR_VAR 0 4
34531: PUSH
34532: LD_EXP 108
34536: PUSH
34537: LD_VAR 0 2
34541: ARRAY
34542: PUSH
34543: LD_EXP 109
34547: PUSH
34548: LD_VAR 0 2
34552: ARRAY
34553: MINUS
34554: ST_TO_ADDR
// if k > list then
34555: LD_VAR 0 4
34559: PUSH
34560: LD_VAR 0 6
34564: GREATER
34565: IFFALSE 34577
// k := list ;
34567: LD_ADDR_VAR 0 4
34571: PUSH
34572: LD_VAR 0 6
34576: ST_TO_ADDR
// for j = 1 to k do
34577: LD_ADDR_VAR 0 3
34581: PUSH
34582: DOUBLE
34583: LD_INT 1
34585: DEC
34586: ST_TO_ADDR
34587: LD_VAR 0 4
34591: PUSH
34592: FOR_TO
34593: IFFALSE 34647
// mc_miners := ReplaceIn ( mc_miners , [ i , mc_miners [ i ] + 1 ] , list [ j ] ) ;
34595: LD_ADDR_EXP 109
34599: PUSH
34600: LD_EXP 109
34604: PPUSH
34605: LD_VAR 0 2
34609: PUSH
34610: LD_EXP 109
34614: PUSH
34615: LD_VAR 0 2
34619: ARRAY
34620: PUSH
34621: LD_INT 1
34623: PLUS
34624: PUSH
34625: EMPTY
34626: LIST
34627: LIST
34628: PPUSH
34629: LD_VAR 0 6
34633: PUSH
34634: LD_VAR 0 3
34638: ARRAY
34639: PPUSH
34640: CALL 57012 0 3
34644: ST_TO_ADDR
34645: GO 34592
34647: POP
34648: POP
// end ;
34649: GO 33900
34651: POP
34652: POP
// end ;
34653: LD_VAR 0 1
34657: RET
// export function MC_CollectCrates ( ) ; var i , j , k , tmp , side , target , cargo , depot , fac , components ; begin
34658: LD_INT 0
34660: PPUSH
34661: PPUSH
34662: PPUSH
34663: PPUSH
34664: PPUSH
34665: PPUSH
34666: PPUSH
34667: PPUSH
34668: PPUSH
34669: PPUSH
34670: PPUSH
// if not mc_bases then
34671: LD_EXP 95
34675: NOT
34676: IFFALSE 34680
// exit ;
34678: GO 36503
// for i = 1 to mc_bases do
34680: LD_ADDR_VAR 0 2
34684: PUSH
34685: DOUBLE
34686: LD_INT 1
34688: DEC
34689: ST_TO_ADDR
34690: LD_EXP 95
34694: PUSH
34695: FOR_TO
34696: IFFALSE 36501
// begin if not mc_bases [ i ] or mc_construct_list [ i ] then
34698: LD_EXP 95
34702: PUSH
34703: LD_VAR 0 2
34707: ARRAY
34708: NOT
34709: PUSH
34710: LD_EXP 102
34714: PUSH
34715: LD_VAR 0 2
34719: ARRAY
34720: OR
34721: IFFALSE 34725
// continue ;
34723: GO 34695
// if not mc_crates [ i ] and mc_crates_collector [ i ] then
34725: LD_EXP 111
34729: PUSH
34730: LD_VAR 0 2
34734: ARRAY
34735: NOT
34736: PUSH
34737: LD_EXP 112
34741: PUSH
34742: LD_VAR 0 2
34746: ARRAY
34747: AND
34748: IFFALSE 34786
// begin mc_crates_collector := Replace ( mc_crates_collector , i , [ ] ) ;
34750: LD_ADDR_EXP 112
34754: PUSH
34755: LD_EXP 112
34759: PPUSH
34760: LD_VAR 0 2
34764: PPUSH
34765: EMPTY
34766: PPUSH
34767: CALL_OW 1
34771: ST_TO_ADDR
// MC_Reset ( i , 107 ) ;
34772: LD_VAR 0 2
34776: PPUSH
34777: LD_INT 107
34779: PPUSH
34780: CALL 25554 0 2
// continue ;
34784: GO 34695
// end ; target := [ ] ;
34786: LD_ADDR_VAR 0 7
34790: PUSH
34791: EMPTY
34792: ST_TO_ADDR
// side := GetSide ( mc_bases [ i ] [ 1 ] ) ;
34793: LD_ADDR_VAR 0 6
34797: PUSH
34798: LD_EXP 95
34802: PUSH
34803: LD_VAR 0 2
34807: ARRAY
34808: PUSH
34809: LD_INT 1
34811: ARRAY
34812: PPUSH
34813: CALL_OW 255
34817: ST_TO_ADDR
// depot := UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) ;
34818: LD_ADDR_VAR 0 9
34822: PUSH
34823: LD_EXP 95
34827: PUSH
34828: LD_VAR 0 2
34832: ARRAY
34833: PPUSH
34834: LD_INT 2
34836: PUSH
34837: LD_INT 30
34839: PUSH
34840: LD_INT 0
34842: PUSH
34843: EMPTY
34844: LIST
34845: LIST
34846: PUSH
34847: LD_INT 30
34849: PUSH
34850: LD_INT 1
34852: PUSH
34853: EMPTY
34854: LIST
34855: LIST
34856: PUSH
34857: EMPTY
34858: LIST
34859: LIST
34860: LIST
34861: PPUSH
34862: CALL_OW 72
34866: ST_TO_ADDR
// for j = mc_crates [ i ] downto 1 do
34867: LD_ADDR_VAR 0 3
34871: PUSH
34872: DOUBLE
34873: LD_EXP 111
34877: PUSH
34878: LD_VAR 0 2
34882: ARRAY
34883: INC
34884: ST_TO_ADDR
34885: LD_INT 1
34887: PUSH
34888: FOR_DOWNTO
34889: IFFALSE 35134
// begin if ValidHex ( mc_crates [ i ] [ j ] [ 2 ] , mc_crates [ i ] [ j ] [ 3 ] ) and GetResourceAmountXY ( mc_crates [ i ] [ j ] [ 2 ] , mc_crates [ i ] [ j ] [ 3 ] ) = 0 then
34891: LD_EXP 111
34895: PUSH
34896: LD_VAR 0 2
34900: ARRAY
34901: PUSH
34902: LD_VAR 0 3
34906: ARRAY
34907: PUSH
34908: LD_INT 2
34910: ARRAY
34911: PPUSH
34912: LD_EXP 111
34916: PUSH
34917: LD_VAR 0 2
34921: ARRAY
34922: PUSH
34923: LD_VAR 0 3
34927: ARRAY
34928: PUSH
34929: LD_INT 3
34931: ARRAY
34932: PPUSH
34933: CALL_OW 488
34937: PUSH
34938: LD_EXP 111
34942: PUSH
34943: LD_VAR 0 2
34947: ARRAY
34948: PUSH
34949: LD_VAR 0 3
34953: ARRAY
34954: PUSH
34955: LD_INT 2
34957: ARRAY
34958: PPUSH
34959: LD_EXP 111
34963: PUSH
34964: LD_VAR 0 2
34968: ARRAY
34969: PUSH
34970: LD_VAR 0 3
34974: ARRAY
34975: PUSH
34976: LD_INT 3
34978: ARRAY
34979: PPUSH
34980: CALL_OW 284
34984: PUSH
34985: LD_INT 0
34987: EQUAL
34988: AND
34989: IFFALSE 35044
// begin tmp := Delete ( mc_crates [ i ] , j ) ;
34991: LD_ADDR_VAR 0 5
34995: PUSH
34996: LD_EXP 111
35000: PUSH
35001: LD_VAR 0 2
35005: ARRAY
35006: PPUSH
35007: LD_VAR 0 3
35011: PPUSH
35012: CALL_OW 3
35016: ST_TO_ADDR
// mc_crates := Replace ( mc_crates , i , tmp ) ;
35017: LD_ADDR_EXP 111
35021: PUSH
35022: LD_EXP 111
35026: PPUSH
35027: LD_VAR 0 2
35031: PPUSH
35032: LD_VAR 0 5
35036: PPUSH
35037: CALL_OW 1
35041: ST_TO_ADDR
// continue ;
35042: GO 34888
// end ; if DangerAtRangeXY ( side , mc_crates [ i ] [ j ] [ 2 ] , mc_crates [ i ] [ j ] [ 3 ] , 30 ) [ 4 ] = 0 then
35044: LD_VAR 0 6
35048: PPUSH
35049: LD_EXP 111
35053: PUSH
35054: LD_VAR 0 2
35058: ARRAY
35059: PUSH
35060: LD_VAR 0 3
35064: ARRAY
35065: PUSH
35066: LD_INT 2
35068: ARRAY
35069: PPUSH
35070: LD_EXP 111
35074: PUSH
35075: LD_VAR 0 2
35079: ARRAY
35080: PUSH
35081: LD_VAR 0 3
35085: ARRAY
35086: PUSH
35087: LD_INT 3
35089: ARRAY
35090: PPUSH
35091: LD_INT 30
35093: PPUSH
35094: CALL 57908 0 4
35098: PUSH
35099: LD_INT 4
35101: ARRAY
35102: PUSH
35103: LD_INT 0
35105: EQUAL
35106: IFFALSE 35132
// begin target := mc_crates [ i ] [ j ] ;
35108: LD_ADDR_VAR 0 7
35112: PUSH
35113: LD_EXP 111
35117: PUSH
35118: LD_VAR 0 2
35122: ARRAY
35123: PUSH
35124: LD_VAR 0 3
35128: ARRAY
35129: ST_TO_ADDR
// break ;
35130: GO 35134
// end ; end ;
35132: GO 34888
35134: POP
35135: POP
// if not target then
35136: LD_VAR 0 7
35140: NOT
35141: IFFALSE 35145
// continue ;
35143: GO 34695
// cargo := UnitFilter ( mc_vehicles [ i ] , [ [ f_or , [ f_not , [ f_empty ] ] , [ f_linked ] , [ f_control , control_apeman ] , [ f_control , control_computer ] ] , [ f_or , [ f_weapon , ar_cargo_bay ] , [ f_weapon , ru_cargo_bay ] , [ f_weapon , us_cargo_bay ] ] ] ) ;
35145: LD_ADDR_VAR 0 8
35149: PUSH
35150: LD_EXP 114
35154: PUSH
35155: LD_VAR 0 2
35159: ARRAY
35160: PPUSH
35161: LD_INT 2
35163: PUSH
35164: LD_INT 3
35166: PUSH
35167: LD_INT 58
35169: PUSH
35170: EMPTY
35171: LIST
35172: PUSH
35173: EMPTY
35174: LIST
35175: LIST
35176: PUSH
35177: LD_INT 61
35179: PUSH
35180: EMPTY
35181: LIST
35182: PUSH
35183: LD_INT 33
35185: PUSH
35186: LD_INT 5
35188: PUSH
35189: EMPTY
35190: LIST
35191: LIST
35192: PUSH
35193: LD_INT 33
35195: PUSH
35196: LD_INT 3
35198: PUSH
35199: EMPTY
35200: LIST
35201: LIST
35202: PUSH
35203: EMPTY
35204: LIST
35205: LIST
35206: LIST
35207: LIST
35208: LIST
35209: PUSH
35210: LD_INT 2
35212: PUSH
35213: LD_INT 34
35215: PUSH
35216: LD_INT 32
35218: PUSH
35219: EMPTY
35220: LIST
35221: LIST
35222: PUSH
35223: LD_INT 34
35225: PUSH
35226: LD_INT 51
35228: PUSH
35229: EMPTY
35230: LIST
35231: LIST
35232: PUSH
35233: LD_INT 34
35235: PUSH
35236: LD_INT 12
35238: PUSH
35239: EMPTY
35240: LIST
35241: LIST
35242: PUSH
35243: EMPTY
35244: LIST
35245: LIST
35246: LIST
35247: LIST
35248: PUSH
35249: EMPTY
35250: LIST
35251: LIST
35252: PPUSH
35253: CALL_OW 72
35257: ST_TO_ADDR
// if not cargo then
35258: LD_VAR 0 8
35262: NOT
35263: IFFALSE 35969
// begin if mc_crates_collector [ i ] < 5 then
35265: LD_EXP 112
35269: PUSH
35270: LD_VAR 0 2
35274: ARRAY
35275: PUSH
35276: LD_INT 5
35278: LESS
35279: IFFALSE 35645
// begin if mc_ape [ i ] then
35281: LD_EXP 124
35285: PUSH
35286: LD_VAR 0 2
35290: ARRAY
35291: IFFALSE 35338
// tmp := UnitFilter ( mc_ape [ i ] , [ [ f_class , 16 ] , [ f_lives , 750 ] ] ) ;
35293: LD_ADDR_VAR 0 5
35297: PUSH
35298: LD_EXP 124
35302: PUSH
35303: LD_VAR 0 2
35307: ARRAY
35308: PPUSH
35309: LD_INT 25
35311: PUSH
35312: LD_INT 16
35314: PUSH
35315: EMPTY
35316: LIST
35317: LIST
35318: PUSH
35319: LD_INT 24
35321: PUSH
35322: LD_INT 750
35324: PUSH
35325: EMPTY
35326: LIST
35327: LIST
35328: PUSH
35329: EMPTY
35330: LIST
35331: LIST
35332: PPUSH
35333: CALL_OW 72
35337: ST_TO_ADDR
// if not tmp then
35338: LD_VAR 0 5
35342: NOT
35343: IFFALSE 35390
// tmp := UnitFilter ( mc_bases [ i ] , [ [ f_class , 2 ] , [ f_lives , 750 ] ] ) ;
35345: LD_ADDR_VAR 0 5
35349: PUSH
35350: LD_EXP 95
35354: PUSH
35355: LD_VAR 0 2
35359: ARRAY
35360: PPUSH
35361: LD_INT 25
35363: PUSH
35364: LD_INT 2
35366: PUSH
35367: EMPTY
35368: LIST
35369: LIST
35370: PUSH
35371: LD_INT 24
35373: PUSH
35374: LD_INT 750
35376: PUSH
35377: EMPTY
35378: LIST
35379: LIST
35380: PUSH
35381: EMPTY
35382: LIST
35383: LIST
35384: PPUSH
35385: CALL_OW 72
35389: ST_TO_ADDR
// if mc_ape [ i ] and UnitFilter ( mc_bases [ i ] , [ [ f_class , 2 ] , [ f_lives , 750 ] ] ) and tmp < 5 then
35390: LD_EXP 124
35394: PUSH
35395: LD_VAR 0 2
35399: ARRAY
35400: PUSH
35401: LD_EXP 95
35405: PUSH
35406: LD_VAR 0 2
35410: ARRAY
35411: PPUSH
35412: LD_INT 25
35414: PUSH
35415: LD_INT 2
35417: PUSH
35418: EMPTY
35419: LIST
35420: LIST
35421: PUSH
35422: LD_INT 24
35424: PUSH
35425: LD_INT 750
35427: PUSH
35428: EMPTY
35429: LIST
35430: LIST
35431: PUSH
35432: EMPTY
35433: LIST
35434: LIST
35435: PPUSH
35436: CALL_OW 72
35440: AND
35441: PUSH
35442: LD_VAR 0 5
35446: PUSH
35447: LD_INT 5
35449: LESS
35450: AND
35451: IFFALSE 35533
// begin for j in UnitFilter ( mc_bases [ i ] , [ [ f_class , 2 ] , [ f_lives , 750 ] ] ) do
35453: LD_ADDR_VAR 0 3
35457: PUSH
35458: LD_EXP 95
35462: PUSH
35463: LD_VAR 0 2
35467: ARRAY
35468: PPUSH
35469: LD_INT 25
35471: PUSH
35472: LD_INT 2
35474: PUSH
35475: EMPTY
35476: LIST
35477: LIST
35478: PUSH
35479: LD_INT 24
35481: PUSH
35482: LD_INT 750
35484: PUSH
35485: EMPTY
35486: LIST
35487: LIST
35488: PUSH
35489: EMPTY
35490: LIST
35491: LIST
35492: PPUSH
35493: CALL_OW 72
35497: PUSH
35498: FOR_IN
35499: IFFALSE 35531
// begin tmp := tmp union j ;
35501: LD_ADDR_VAR 0 5
35505: PUSH
35506: LD_VAR 0 5
35510: PUSH
35511: LD_VAR 0 3
35515: UNION
35516: ST_TO_ADDR
// if tmp >= 5 then
35517: LD_VAR 0 5
35521: PUSH
35522: LD_INT 5
35524: GREATEREQUAL
35525: IFFALSE 35529
// break ;
35527: GO 35531
// end ;
35529: GO 35498
35531: POP
35532: POP
// end ; if not tmp then
35533: LD_VAR 0 5
35537: NOT
35538: IFFALSE 35542
// continue ;
35540: GO 34695
// for j in tmp do
35542: LD_ADDR_VAR 0 3
35546: PUSH
35547: LD_VAR 0 5
35551: PUSH
35552: FOR_IN
35553: IFFALSE 35643
// if not GetTag ( j ) then
35555: LD_VAR 0 3
35559: PPUSH
35560: CALL_OW 110
35564: NOT
35565: IFFALSE 35641
// begin mc_crates_collector := ReplaceIn ( mc_crates_collector , [ i , mc_crates_collector [ i ] + 1 ] , j ) ;
35567: LD_ADDR_EXP 112
35571: PUSH
35572: LD_EXP 112
35576: PPUSH
35577: LD_VAR 0 2
35581: PUSH
35582: LD_EXP 112
35586: PUSH
35587: LD_VAR 0 2
35591: ARRAY
35592: PUSH
35593: LD_INT 1
35595: PLUS
35596: PUSH
35597: EMPTY
35598: LIST
35599: LIST
35600: PPUSH
35601: LD_VAR 0 3
35605: PPUSH
35606: CALL 57012 0 3
35610: ST_TO_ADDR
// SetTag ( j , 107 ) ;
35611: LD_VAR 0 3
35615: PPUSH
35616: LD_INT 107
35618: PPUSH
35619: CALL_OW 109
// if mc_crates_collector [ i ] >= 5 then
35623: LD_EXP 112
35627: PUSH
35628: LD_VAR 0 2
35632: ARRAY
35633: PUSH
35634: LD_INT 5
35636: GREATEREQUAL
35637: IFFALSE 35641
// break ;
35639: GO 35643
// end ;
35641: GO 35552
35643: POP
35644: POP
// end ; if mc_crates_collector [ i ] and target then
35645: LD_EXP 112
35649: PUSH
35650: LD_VAR 0 2
35654: ARRAY
35655: PUSH
35656: LD_VAR 0 7
35660: AND
35661: IFFALSE 35967
// begin if mc_crates_collector [ i ] < target [ 1 ] then
35663: LD_EXP 112
35667: PUSH
35668: LD_VAR 0 2
35672: ARRAY
35673: PUSH
35674: LD_VAR 0 7
35678: PUSH
35679: LD_INT 1
35681: ARRAY
35682: LESS
35683: IFFALSE 35703
// tmp := mc_crates_collector [ i ] else
35685: LD_ADDR_VAR 0 5
35689: PUSH
35690: LD_EXP 112
35694: PUSH
35695: LD_VAR 0 2
35699: ARRAY
35700: ST_TO_ADDR
35701: GO 35717
// tmp := target [ 1 ] ;
35703: LD_ADDR_VAR 0 5
35707: PUSH
35708: LD_VAR 0 7
35712: PUSH
35713: LD_INT 1
35715: ARRAY
35716: ST_TO_ADDR
// k := 0 ;
35717: LD_ADDR_VAR 0 4
35721: PUSH
35722: LD_INT 0
35724: ST_TO_ADDR
// for j in mc_crates_collector [ i ] do
35725: LD_ADDR_VAR 0 3
35729: PUSH
35730: LD_EXP 112
35734: PUSH
35735: LD_VAR 0 2
35739: ARRAY
35740: PUSH
35741: FOR_IN
35742: IFFALSE 35965
// begin k := k + 1 ;
35744: LD_ADDR_VAR 0 4
35748: PUSH
35749: LD_VAR 0 4
35753: PUSH
35754: LD_INT 1
35756: PLUS
35757: ST_TO_ADDR
// if k > tmp then
35758: LD_VAR 0 4
35762: PUSH
35763: LD_VAR 0 5
35767: GREATER
35768: IFFALSE 35772
// break ;
35770: GO 35965
// if not GetClass ( j ) in [ 2 , 16 ] then
35772: LD_VAR 0 3
35776: PPUSH
35777: CALL_OW 257
35781: PUSH
35782: LD_INT 2
35784: PUSH
35785: LD_INT 16
35787: PUSH
35788: EMPTY
35789: LIST
35790: LIST
35791: IN
35792: NOT
35793: IFFALSE 35846
// begin mc_crates_collector := Replace ( mc_crates_collector , i , mc_crates_collector [ i ] diff j ) ;
35795: LD_ADDR_EXP 112
35799: PUSH
35800: LD_EXP 112
35804: PPUSH
35805: LD_VAR 0 2
35809: PPUSH
35810: LD_EXP 112
35814: PUSH
35815: LD_VAR 0 2
35819: ARRAY
35820: PUSH
35821: LD_VAR 0 3
35825: DIFF
35826: PPUSH
35827: CALL_OW 1
35831: ST_TO_ADDR
// SetTag ( j , 0 ) ;
35832: LD_VAR 0 3
35836: PPUSH
35837: LD_INT 0
35839: PPUSH
35840: CALL_OW 109
// continue ;
35844: GO 35741
// end ; if IsInUnit ( j ) then
35846: LD_VAR 0 3
35850: PPUSH
35851: CALL_OW 310
35855: IFFALSE 35866
// ComExitBuilding ( j ) ;
35857: LD_VAR 0 3
35861: PPUSH
35862: CALL_OW 122
// wait ( 3 ) ;
35866: LD_INT 3
35868: PPUSH
35869: CALL_OW 67
// if HasTask ( j ) and DangerAtRangeXY ( side , target [ 2 ] , target [ 3 ] , 30 ) [ 4 ] then
35873: LD_VAR 0 3
35877: PPUSH
35878: CALL_OW 314
35882: PUSH
35883: LD_VAR 0 6
35887: PPUSH
35888: LD_VAR 0 7
35892: PUSH
35893: LD_INT 2
35895: ARRAY
35896: PPUSH
35897: LD_VAR 0 7
35901: PUSH
35902: LD_INT 3
35904: ARRAY
35905: PPUSH
35906: LD_INT 30
35908: PPUSH
35909: CALL 57908 0 4
35913: PUSH
35914: LD_INT 4
35916: ARRAY
35917: AND
35918: IFFALSE 35936
// ComStandNearbyBuilding ( j , depot ) else
35920: LD_VAR 0 3
35924: PPUSH
35925: LD_VAR 0 9
35929: PPUSH
35930: CALL 53590 0 2
35934: GO 35963
// ComCollect ( j , target [ 2 ] , target [ 3 ] ) ;
35936: LD_VAR 0 3
35940: PPUSH
35941: LD_VAR 0 7
35945: PUSH
35946: LD_INT 2
35948: ARRAY
35949: PPUSH
35950: LD_VAR 0 7
35954: PUSH
35955: LD_INT 3
35957: ARRAY
35958: PPUSH
35959: CALL_OW 117
// end ;
35963: GO 35741
35965: POP
35966: POP
// end ; end else
35967: GO 36499
// begin for j in cargo do
35969: LD_ADDR_VAR 0 3
35973: PUSH
35974: LD_VAR 0 8
35978: PUSH
35979: FOR_IN
35980: IFFALSE 36497
// begin if GetTag ( j ) <> 0 then
35982: LD_VAR 0 3
35986: PPUSH
35987: CALL_OW 110
35991: PUSH
35992: LD_INT 0
35994: NONEQUAL
35995: IFFALSE 35999
// continue ;
35997: GO 35979
// if GetLives ( j ) < 1000 and not IsInArea ( j , mc_parking [ i ] ) then
35999: LD_VAR 0 3
36003: PPUSH
36004: CALL_OW 256
36008: PUSH
36009: LD_INT 1000
36011: LESS
36012: PUSH
36013: LD_VAR 0 3
36017: PPUSH
36018: LD_EXP 119
36022: PUSH
36023: LD_VAR 0 2
36027: ARRAY
36028: PPUSH
36029: CALL_OW 308
36033: NOT
36034: AND
36035: IFFALSE 36057
// ComMoveToArea ( j , mc_parking [ i ] ) ;
36037: LD_VAR 0 3
36041: PPUSH
36042: LD_EXP 119
36046: PUSH
36047: LD_VAR 0 2
36051: ARRAY
36052: PPUSH
36053: CALL_OW 113
// if GetLives ( j ) < 1000 and IsInArea ( j , mc_parking [ i ] ) then
36057: LD_VAR 0 3
36061: PPUSH
36062: CALL_OW 256
36066: PUSH
36067: LD_INT 1000
36069: LESS
36070: PUSH
36071: LD_VAR 0 3
36075: PPUSH
36076: LD_EXP 119
36080: PUSH
36081: LD_VAR 0 2
36085: ARRAY
36086: PPUSH
36087: CALL_OW 308
36091: AND
36092: IFFALSE 36096
// continue ;
36094: GO 35979
// if GetEngine ( j ) = engine_solar and GetFuel ( j ) < 15 then
36096: LD_VAR 0 3
36100: PPUSH
36101: CALL_OW 262
36105: PUSH
36106: LD_INT 2
36108: EQUAL
36109: PUSH
36110: LD_VAR 0 3
36114: PPUSH
36115: CALL_OW 261
36119: PUSH
36120: LD_INT 15
36122: LESS
36123: AND
36124: IFFALSE 36128
// continue ;
36126: GO 35979
// if GetEngine ( j ) = engine_combustion and GetFuel ( j ) < 10 then
36128: LD_VAR 0 3
36132: PPUSH
36133: CALL_OW 262
36137: PUSH
36138: LD_INT 1
36140: EQUAL
36141: PUSH
36142: LD_VAR 0 3
36146: PPUSH
36147: CALL_OW 261
36151: PUSH
36152: LD_INT 10
36154: LESS
36155: AND
36156: IFFALSE 36436
// begin if not depot then
36158: LD_VAR 0 9
36162: NOT
36163: IFFALSE 36167
// continue ;
36165: GO 35979
// if GetDistUnits ( j , NearestUnitToUnit ( depot , j ) ) < 6 then
36167: LD_VAR 0 3
36171: PPUSH
36172: LD_VAR 0 9
36176: PPUSH
36177: LD_VAR 0 3
36181: PPUSH
36182: CALL_OW 74
36186: PPUSH
36187: CALL_OW 296
36191: PUSH
36192: LD_INT 6
36194: LESS
36195: IFFALSE 36211
// SetFuel ( j , 100 ) else
36197: LD_VAR 0 3
36201: PPUSH
36202: LD_INT 100
36204: PPUSH
36205: CALL_OW 240
36209: GO 36436
// if GetFuel ( j ) = 0 then
36211: LD_VAR 0 3
36215: PPUSH
36216: CALL_OW 261
36220: PUSH
36221: LD_INT 0
36223: EQUAL
36224: IFFALSE 36436
// begin mc_vehicles := Replace ( mc_vehicles , i , mc_vehicles [ i ] diff j ) ;
36226: LD_ADDR_EXP 114
36230: PUSH
36231: LD_EXP 114
36235: PPUSH
36236: LD_VAR 0 2
36240: PPUSH
36241: LD_EXP 114
36245: PUSH
36246: LD_VAR 0 2
36250: ARRAY
36251: PUSH
36252: LD_VAR 0 3
36256: DIFF
36257: PPUSH
36258: CALL_OW 1
36262: ST_TO_ADDR
// if GetControl ( j ) = control_manual then
36263: LD_VAR 0 3
36267: PPUSH
36268: CALL_OW 263
36272: PUSH
36273: LD_INT 1
36275: EQUAL
36276: IFFALSE 36292
// ComExitVehicle ( IsInUnit ( j ) ) ;
36278: LD_VAR 0 3
36282: PPUSH
36283: CALL_OW 310
36287: PPUSH
36288: CALL_OW 121
// if GetControl ( j ) = control_remote then
36292: LD_VAR 0 3
36296: PPUSH
36297: CALL_OW 263
36301: PUSH
36302: LD_INT 2
36304: EQUAL
36305: IFFALSE 36316
// ComUnlink ( j ) ;
36307: LD_VAR 0 3
36311: PPUSH
36312: CALL_OW 136
// fac := MC_GetBuildings ( i , b_factory ) ;
36316: LD_ADDR_VAR 0 10
36320: PUSH
36321: LD_VAR 0 2
36325: PPUSH
36326: LD_INT 3
36328: PPUSH
36329: CALL 46075 0 2
36333: ST_TO_ADDR
// if fac then
36334: LD_VAR 0 10
36338: IFFALSE 36434
// begin for k in fac do
36340: LD_ADDR_VAR 0 4
36344: PUSH
36345: LD_VAR 0 10
36349: PUSH
36350: FOR_IN
36351: IFFALSE 36432
// begin components := Produce ( fac , GetChassis ( j ) , GetEngine ( j ) , GetControl ( j ) , GetWeapon ( j ) ) ;
36353: LD_ADDR_VAR 0 11
36357: PUSH
36358: LD_VAR 0 10
36362: PPUSH
36363: LD_VAR 0 3
36367: PPUSH
36368: CALL_OW 265
36372: PPUSH
36373: LD_VAR 0 3
36377: PPUSH
36378: CALL_OW 262
36382: PPUSH
36383: LD_VAR 0 3
36387: PPUSH
36388: CALL_OW 263
36392: PPUSH
36393: LD_VAR 0 3
36397: PPUSH
36398: CALL_OW 264
36402: PPUSH
36403: CALL 54508 0 5
36407: ST_TO_ADDR
// if components then
36408: LD_VAR 0 11
36412: IFFALSE 36430
// begin MC_InsertProduceList ( i , components ) ;
36414: LD_VAR 0 2
36418: PPUSH
36419: LD_VAR 0 11
36423: PPUSH
36424: CALL 45620 0 2
// break ;
36428: GO 36432
// end ; end ;
36430: GO 36350
36432: POP
36433: POP
// end ; continue ;
36434: GO 35979
// end ; end ; if GetCargo ( j , mat_cans ) < 100 and not HasTask ( j ) then
36436: LD_VAR 0 3
36440: PPUSH
36441: LD_INT 1
36443: PPUSH
36444: CALL_OW 289
36448: PUSH
36449: LD_INT 100
36451: LESS
36452: PUSH
36453: LD_VAR 0 3
36457: PPUSH
36458: CALL_OW 314
36462: NOT
36463: AND
36464: IFFALSE 36493
// ComCollect ( j , target [ 2 ] , target [ 3 ] ) ;
36466: LD_VAR 0 3
36470: PPUSH
36471: LD_VAR 0 7
36475: PUSH
36476: LD_INT 2
36478: ARRAY
36479: PPUSH
36480: LD_VAR 0 7
36484: PUSH
36485: LD_INT 3
36487: ARRAY
36488: PPUSH
36489: CALL_OW 117
// break ;
36493: GO 36497
// end ;
36495: GO 35979
36497: POP
36498: POP
// end ; end ;
36499: GO 34695
36501: POP
36502: POP
// end ;
36503: LD_VAR 0 1
36507: RET
// export function MC_LinkRemoteControl ( ) ; var i , j , tmp ; begin
36508: LD_INT 0
36510: PPUSH
36511: PPUSH
36512: PPUSH
36513: PPUSH
// if not mc_bases then
36514: LD_EXP 95
36518: NOT
36519: IFFALSE 36523
// exit ;
36521: GO 36684
// for i = 1 to mc_bases do
36523: LD_ADDR_VAR 0 2
36527: PUSH
36528: DOUBLE
36529: LD_INT 1
36531: DEC
36532: ST_TO_ADDR
36533: LD_EXP 95
36537: PUSH
36538: FOR_TO
36539: IFFALSE 36682
// begin tmp := UnitFilter ( mc_vehicles [ i ] union mc_defender [ i ] , [ f_control , control_remote ] ) ;
36541: LD_ADDR_VAR 0 4
36545: PUSH
36546: LD_EXP 114
36550: PUSH
36551: LD_VAR 0 2
36555: ARRAY
36556: PUSH
36557: LD_EXP 117
36561: PUSH
36562: LD_VAR 0 2
36566: ARRAY
36567: UNION
36568: PPUSH
36569: LD_INT 33
36571: PUSH
36572: LD_INT 2
36574: PUSH
36575: EMPTY
36576: LIST
36577: LIST
36578: PPUSH
36579: CALL_OW 72
36583: ST_TO_ADDR
// if tmp then
36584: LD_VAR 0 4
36588: IFFALSE 36680
// for j in tmp do
36590: LD_ADDR_VAR 0 3
36594: PUSH
36595: LD_VAR 0 4
36599: PUSH
36600: FOR_IN
36601: IFFALSE 36678
// if not IsControledBy ( j ) and GetLives ( j ) >= 250 then
36603: LD_VAR 0 3
36607: PPUSH
36608: CALL_OW 312
36612: NOT
36613: PUSH
36614: LD_VAR 0 3
36618: PPUSH
36619: CALL_OW 256
36623: PUSH
36624: LD_INT 250
36626: GREATEREQUAL
36627: AND
36628: IFFALSE 36641
// Connect ( j ) else
36630: LD_VAR 0 3
36634: PPUSH
36635: CALL 59983 0 1
36639: GO 36676
// if GetLives ( j ) < 250 and IsControledBy ( j ) then
36641: LD_VAR 0 3
36645: PPUSH
36646: CALL_OW 256
36650: PUSH
36651: LD_INT 250
36653: LESS
36654: PUSH
36655: LD_VAR 0 3
36659: PPUSH
36660: CALL_OW 312
36664: AND
36665: IFFALSE 36676
// ComUnlink ( j ) ;
36667: LD_VAR 0 3
36671: PPUSH
36672: CALL_OW 136
36676: GO 36600
36678: POP
36679: POP
// end ;
36680: GO 36538
36682: POP
36683: POP
// end ;
36684: LD_VAR 0 1
36688: RET
// export function MC_ProduceVehicle ( ) ; var i , j , tmp , fac ; begin
36689: LD_INT 0
36691: PPUSH
36692: PPUSH
36693: PPUSH
36694: PPUSH
36695: PPUSH
// if not mc_bases then
36696: LD_EXP 95
36700: NOT
36701: IFFALSE 36705
// exit ;
36703: GO 37150
// for i = 1 to mc_bases do
36705: LD_ADDR_VAR 0 2
36709: PUSH
36710: DOUBLE
36711: LD_INT 1
36713: DEC
36714: ST_TO_ADDR
36715: LD_EXP 95
36719: PUSH
36720: FOR_TO
36721: IFFALSE 37148
// begin if not mc_produce [ i ] then
36723: LD_EXP 116
36727: PUSH
36728: LD_VAR 0 2
36732: ARRAY
36733: NOT
36734: IFFALSE 36738
// continue ;
36736: GO 36720
// fac := UnitFilter ( mc_bases [ i ] , [ f_btype , b_factory ] ) ;
36738: LD_ADDR_VAR 0 5
36742: PUSH
36743: LD_EXP 95
36747: PUSH
36748: LD_VAR 0 2
36752: ARRAY
36753: PPUSH
36754: LD_INT 30
36756: PUSH
36757: LD_INT 3
36759: PUSH
36760: EMPTY
36761: LIST
36762: LIST
36763: PPUSH
36764: CALL_OW 72
36768: ST_TO_ADDR
// if not fac then
36769: LD_VAR 0 5
36773: NOT
36774: IFFALSE 36778
// continue ;
36776: GO 36720
// for j in fac do
36778: LD_ADDR_VAR 0 3
36782: PUSH
36783: LD_VAR 0 5
36787: PUSH
36788: FOR_IN
36789: IFFALSE 37144
// begin if BuildingStatus ( j ) <> bs_idle or DangerAtRange ( j , 15 ) [ 4 ] then
36791: LD_VAR 0 3
36795: PPUSH
36796: CALL_OW 461
36800: PUSH
36801: LD_INT 2
36803: NONEQUAL
36804: PUSH
36805: LD_VAR 0 3
36809: PPUSH
36810: LD_INT 15
36812: PPUSH
36813: CALL 59611 0 2
36817: PUSH
36818: LD_INT 4
36820: ARRAY
36821: OR
36822: IFFALSE 36826
// continue ;
36824: GO 36788
// if CanBeConstructed ( j , mc_produce [ i ] [ 1 ] [ 1 ] , mc_produce [ i ] [ 1 ] [ 2 ] , mc_produce [ i ] [ 1 ] [ 3 ] , mc_produce [ i ] [ 1 ] [ 4 ] ) and VehicleCost ( j , [ mc_produce [ i ] [ 1 ] [ 1 ] , mc_produce [ i ] [ 1 ] [ 2 ] , mc_produce [ i ] [ 1 ] [ 3 ] , mc_produce [ i ] [ 1 ] [ 4 ] ] ) then
36826: LD_VAR 0 3
36830: PPUSH
36831: LD_EXP 116
36835: PUSH
36836: LD_VAR 0 2
36840: ARRAY
36841: PUSH
36842: LD_INT 1
36844: ARRAY
36845: PUSH
36846: LD_INT 1
36848: ARRAY
36849: PPUSH
36850: LD_EXP 116
36854: PUSH
36855: LD_VAR 0 2
36859: ARRAY
36860: PUSH
36861: LD_INT 1
36863: ARRAY
36864: PUSH
36865: LD_INT 2
36867: ARRAY
36868: PPUSH
36869: LD_EXP 116
36873: PUSH
36874: LD_VAR 0 2
36878: ARRAY
36879: PUSH
36880: LD_INT 1
36882: ARRAY
36883: PUSH
36884: LD_INT 3
36886: ARRAY
36887: PPUSH
36888: LD_EXP 116
36892: PUSH
36893: LD_VAR 0 2
36897: ARRAY
36898: PUSH
36899: LD_INT 1
36901: ARRAY
36902: PUSH
36903: LD_INT 4
36905: ARRAY
36906: PPUSH
36907: CALL_OW 448
36911: PUSH
36912: LD_VAR 0 3
36916: PPUSH
36917: LD_EXP 116
36921: PUSH
36922: LD_VAR 0 2
36926: ARRAY
36927: PUSH
36928: LD_INT 1
36930: ARRAY
36931: PUSH
36932: LD_INT 1
36934: ARRAY
36935: PUSH
36936: LD_EXP 116
36940: PUSH
36941: LD_VAR 0 2
36945: ARRAY
36946: PUSH
36947: LD_INT 1
36949: ARRAY
36950: PUSH
36951: LD_INT 2
36953: ARRAY
36954: PUSH
36955: LD_EXP 116
36959: PUSH
36960: LD_VAR 0 2
36964: ARRAY
36965: PUSH
36966: LD_INT 1
36968: ARRAY
36969: PUSH
36970: LD_INT 3
36972: ARRAY
36973: PUSH
36974: LD_EXP 116
36978: PUSH
36979: LD_VAR 0 2
36983: ARRAY
36984: PUSH
36985: LD_INT 1
36987: ARRAY
36988: PUSH
36989: LD_INT 4
36991: ARRAY
36992: PUSH
36993: EMPTY
36994: LIST
36995: LIST
36996: LIST
36997: LIST
36998: PPUSH
36999: CALL 63378 0 2
37003: AND
37004: IFFALSE 37142
// begin AddComConstruct ( j , mc_produce [ i ] [ 1 ] [ 1 ] , mc_produce [ i ] [ 1 ] [ 2 ] , mc_produce [ i ] [ 1 ] [ 3 ] , mc_produce [ i ] [ 1 ] [ 4 ] ) ;
37006: LD_VAR 0 3
37010: PPUSH
37011: LD_EXP 116
37015: PUSH
37016: LD_VAR 0 2
37020: ARRAY
37021: PUSH
37022: LD_INT 1
37024: ARRAY
37025: PUSH
37026: LD_INT 1
37028: ARRAY
37029: PPUSH
37030: LD_EXP 116
37034: PUSH
37035: LD_VAR 0 2
37039: ARRAY
37040: PUSH
37041: LD_INT 1
37043: ARRAY
37044: PUSH
37045: LD_INT 2
37047: ARRAY
37048: PPUSH
37049: LD_EXP 116
37053: PUSH
37054: LD_VAR 0 2
37058: ARRAY
37059: PUSH
37060: LD_INT 1
37062: ARRAY
37063: PUSH
37064: LD_INT 3
37066: ARRAY
37067: PPUSH
37068: LD_EXP 116
37072: PUSH
37073: LD_VAR 0 2
37077: ARRAY
37078: PUSH
37079: LD_INT 1
37081: ARRAY
37082: PUSH
37083: LD_INT 4
37085: ARRAY
37086: PPUSH
37087: CALL_OW 185
// tmp := Delete ( mc_produce [ i ] , 1 ) ;
37091: LD_ADDR_VAR 0 4
37095: PUSH
37096: LD_EXP 116
37100: PUSH
37101: LD_VAR 0 2
37105: ARRAY
37106: PPUSH
37107: LD_INT 1
37109: PPUSH
37110: CALL_OW 3
37114: ST_TO_ADDR
// mc_produce := Replace ( mc_produce , i , tmp ) ;
37115: LD_ADDR_EXP 116
37119: PUSH
37120: LD_EXP 116
37124: PPUSH
37125: LD_VAR 0 2
37129: PPUSH
37130: LD_VAR 0 4
37134: PPUSH
37135: CALL_OW 1
37139: ST_TO_ADDR
// break ;
37140: GO 37144
// end ; end ;
37142: GO 36788
37144: POP
37145: POP
// end ;
37146: GO 36720
37148: POP
37149: POP
// end ;
37150: LD_VAR 0 1
37154: RET
// export function MC_SendAttack ( ) ; var i , tmp ; begin
37155: LD_INT 0
37157: PPUSH
37158: PPUSH
37159: PPUSH
// if not mc_bases then
37160: LD_EXP 95
37164: NOT
37165: IFFALSE 37169
// exit ;
37167: GO 37258
// for i = 1 to mc_bases do
37169: LD_ADDR_VAR 0 2
37173: PUSH
37174: DOUBLE
37175: LD_INT 1
37177: DEC
37178: ST_TO_ADDR
37179: LD_EXP 95
37183: PUSH
37184: FOR_TO
37185: IFFALSE 37256
// begin if mc_attack [ i ] then
37187: LD_EXP 115
37191: PUSH
37192: LD_VAR 0 2
37196: ARRAY
37197: IFFALSE 37254
// begin tmp := mc_attack [ i ] [ 1 ] ;
37199: LD_ADDR_VAR 0 3
37203: PUSH
37204: LD_EXP 115
37208: PUSH
37209: LD_VAR 0 2
37213: ARRAY
37214: PUSH
37215: LD_INT 1
37217: ARRAY
37218: ST_TO_ADDR
// mc_attack := Replace ( mc_attack , i , [ ] ) ;
37219: LD_ADDR_EXP 115
37223: PUSH
37224: LD_EXP 115
37228: PPUSH
37229: LD_VAR 0 2
37233: PPUSH
37234: EMPTY
37235: PPUSH
37236: CALL_OW 1
37240: ST_TO_ADDR
// Attack ( tmp ) ;
37241: LD_VAR 0 3
37245: PPUSH
37246: CALL 111086 0 1
// exit ;
37250: POP
37251: POP
37252: GO 37258
// end ; end ;
37254: GO 37184
37256: POP
37257: POP
// end ;
37258: LD_VAR 0 1
37262: RET
// export function MC_Defend ( ) ; var i , j , tmp , t , x , class ; begin
37263: LD_INT 0
37265: PPUSH
37266: PPUSH
37267: PPUSH
37268: PPUSH
37269: PPUSH
37270: PPUSH
37271: PPUSH
// if not mc_bases then
37272: LD_EXP 95
37276: NOT
37277: IFFALSE 37281
// exit ;
37279: GO 38138
// for i = 1 to mc_bases do
37281: LD_ADDR_VAR 0 2
37285: PUSH
37286: DOUBLE
37287: LD_INT 1
37289: DEC
37290: ST_TO_ADDR
37291: LD_EXP 95
37295: PUSH
37296: FOR_TO
37297: IFFALSE 38136
// begin if not mc_bases [ i ] then
37299: LD_EXP 95
37303: PUSH
37304: LD_VAR 0 2
37308: ARRAY
37309: NOT
37310: IFFALSE 37314
// continue ;
37312: GO 37296
// class := AllowSpecClass ( mc_bases [ i ] [ 1 ] ) ;
37314: LD_ADDR_VAR 0 7
37318: PUSH
37319: LD_EXP 95
37323: PUSH
37324: LD_VAR 0 2
37328: ARRAY
37329: PUSH
37330: LD_INT 1
37332: ARRAY
37333: PPUSH
37334: CALL 53812 0 1
37338: ST_TO_ADDR
// mc_scan := Replace ( mc_scan , i , ScanBase ( GetSide ( mc_bases [ i ] [ 1 ] ) , mc_scan_area [ i ] ) ) ;
37339: LD_ADDR_EXP 118
37343: PUSH
37344: LD_EXP 118
37348: PPUSH
37349: LD_VAR 0 2
37353: PPUSH
37354: LD_EXP 95
37358: PUSH
37359: LD_VAR 0 2
37363: ARRAY
37364: PUSH
37365: LD_INT 1
37367: ARRAY
37368: PPUSH
37369: CALL_OW 255
37373: PPUSH
37374: LD_EXP 120
37378: PUSH
37379: LD_VAR 0 2
37383: ARRAY
37384: PPUSH
37385: CALL 53777 0 2
37389: PPUSH
37390: CALL_OW 1
37394: ST_TO_ADDR
// if not mc_scan [ i ] then
37395: LD_EXP 118
37399: PUSH
37400: LD_VAR 0 2
37404: ARRAY
37405: NOT
37406: IFFALSE 37584
// begin mc_is_defending := Replace ( mc_is_defending , i , false ) ;
37408: LD_ADDR_EXP 138
37412: PUSH
37413: LD_EXP 138
37417: PPUSH
37418: LD_VAR 0 2
37422: PPUSH
37423: LD_INT 0
37425: PPUSH
37426: CALL_OW 1
37430: ST_TO_ADDR
// tmp := UnitFilter ( mc_bases [ i ] , [ f_or , [ f_class , 5 ] , [ f_class , 8 ] , [ f_class , 9 ] ] ) ;
37431: LD_ADDR_VAR 0 4
37435: PUSH
37436: LD_EXP 95
37440: PUSH
37441: LD_VAR 0 2
37445: ARRAY
37446: PPUSH
37447: LD_INT 2
37449: PUSH
37450: LD_INT 25
37452: PUSH
37453: LD_INT 5
37455: PUSH
37456: EMPTY
37457: LIST
37458: LIST
37459: PUSH
37460: LD_INT 25
37462: PUSH
37463: LD_INT 8
37465: PUSH
37466: EMPTY
37467: LIST
37468: LIST
37469: PUSH
37470: LD_INT 25
37472: PUSH
37473: LD_INT 9
37475: PUSH
37476: EMPTY
37477: LIST
37478: LIST
37479: PUSH
37480: EMPTY
37481: LIST
37482: LIST
37483: LIST
37484: LIST
37485: PPUSH
37486: CALL_OW 72
37490: ST_TO_ADDR
// if not tmp then
37491: LD_VAR 0 4
37495: NOT
37496: IFFALSE 37500
// continue ;
37498: GO 37296
// for j in tmp do
37500: LD_ADDR_VAR 0 3
37504: PUSH
37505: LD_VAR 0 4
37509: PUSH
37510: FOR_IN
37511: IFFALSE 37582
// if GetBType ( IsInUnit ( j ) ) = b_barracks and GetClass ( j ) = 1 and not MineOfUnit ( j ) and class then
37513: LD_VAR 0 3
37517: PPUSH
37518: CALL_OW 310
37522: PPUSH
37523: CALL_OW 266
37527: PUSH
37528: LD_INT 5
37530: EQUAL
37531: PUSH
37532: LD_VAR 0 3
37536: PPUSH
37537: CALL_OW 257
37541: PUSH
37542: LD_INT 1
37544: EQUAL
37545: AND
37546: PUSH
37547: LD_VAR 0 3
37551: PPUSH
37552: CALL_OW 459
37556: NOT
37557: AND
37558: PUSH
37559: LD_VAR 0 7
37563: AND
37564: IFFALSE 37580
// ComChangeProfession ( j , class ) ;
37566: LD_VAR 0 3
37570: PPUSH
37571: LD_VAR 0 7
37575: PPUSH
37576: CALL_OW 123
37580: GO 37510
37582: POP
37583: POP
// end ; if mc_scan [ i ] and not mc_is_defending [ i ] and not mc_defender [ i ] and ( UnitFilter ( mc_bases [ i ] , [ [ f_ok ] , [ f_or , [ f_btype , b_bunker ] , [ f_btype , b_turret ] , [ f_btype , b_armoury ] , [ f_btype , b_barracks ] ] ] ) < 4 or UnitFilter ( mc_bases [ i ] , [ [ f_not , [ f_lives , 1000 ] ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ] ) ) then
37584: LD_EXP 118
37588: PUSH
37589: LD_VAR 0 2
37593: ARRAY
37594: PUSH
37595: LD_EXP 138
37599: PUSH
37600: LD_VAR 0 2
37604: ARRAY
37605: NOT
37606: AND
37607: PUSH
37608: LD_EXP 117
37612: PUSH
37613: LD_VAR 0 2
37617: ARRAY
37618: NOT
37619: AND
37620: PUSH
37621: LD_EXP 95
37625: PUSH
37626: LD_VAR 0 2
37630: ARRAY
37631: PPUSH
37632: LD_INT 50
37634: PUSH
37635: EMPTY
37636: LIST
37637: PUSH
37638: LD_INT 2
37640: PUSH
37641: LD_INT 30
37643: PUSH
37644: LD_INT 32
37646: PUSH
37647: EMPTY
37648: LIST
37649: LIST
37650: PUSH
37651: LD_INT 30
37653: PUSH
37654: LD_INT 33
37656: PUSH
37657: EMPTY
37658: LIST
37659: LIST
37660: PUSH
37661: LD_INT 30
37663: PUSH
37664: LD_INT 4
37666: PUSH
37667: EMPTY
37668: LIST
37669: LIST
37670: PUSH
37671: LD_INT 30
37673: PUSH
37674: LD_INT 5
37676: PUSH
37677: EMPTY
37678: LIST
37679: LIST
37680: PUSH
37681: EMPTY
37682: LIST
37683: LIST
37684: LIST
37685: LIST
37686: LIST
37687: PUSH
37688: EMPTY
37689: LIST
37690: LIST
37691: PPUSH
37692: CALL_OW 72
37696: PUSH
37697: LD_INT 4
37699: LESS
37700: PUSH
37701: LD_EXP 95
37705: PUSH
37706: LD_VAR 0 2
37710: ARRAY
37711: PPUSH
37712: LD_INT 3
37714: PUSH
37715: LD_INT 24
37717: PUSH
37718: LD_INT 1000
37720: PUSH
37721: EMPTY
37722: LIST
37723: LIST
37724: PUSH
37725: EMPTY
37726: LIST
37727: LIST
37728: PUSH
37729: LD_INT 2
37731: PUSH
37732: LD_INT 30
37734: PUSH
37735: LD_INT 0
37737: PUSH
37738: EMPTY
37739: LIST
37740: LIST
37741: PUSH
37742: LD_INT 30
37744: PUSH
37745: LD_INT 1
37747: PUSH
37748: EMPTY
37749: LIST
37750: LIST
37751: PUSH
37752: EMPTY
37753: LIST
37754: LIST
37755: LIST
37756: PUSH
37757: EMPTY
37758: LIST
37759: LIST
37760: PPUSH
37761: CALL_OW 72
37765: OR
37766: AND
37767: IFFALSE 38018
// begin mc_is_defending := Replace ( mc_is_defending , i , true ) ;
37769: LD_ADDR_EXP 138
37773: PUSH
37774: LD_EXP 138
37778: PPUSH
37779: LD_VAR 0 2
37783: PPUSH
37784: LD_INT 1
37786: PPUSH
37787: CALL_OW 1
37791: ST_TO_ADDR
// tmp := UnitFilter ( mc_bases [ i ] , [ f_or , [ f_class , 1 ] , [ f_class , 5 ] , [ f_class , 8 ] , [ f_class , 9 ] ] ) ;
37792: LD_ADDR_VAR 0 4
37796: PUSH
37797: LD_EXP 95
37801: PUSH
37802: LD_VAR 0 2
37806: ARRAY
37807: PPUSH
37808: LD_INT 2
37810: PUSH
37811: LD_INT 25
37813: PUSH
37814: LD_INT 1
37816: PUSH
37817: EMPTY
37818: LIST
37819: LIST
37820: PUSH
37821: LD_INT 25
37823: PUSH
37824: LD_INT 5
37826: PUSH
37827: EMPTY
37828: LIST
37829: LIST
37830: PUSH
37831: LD_INT 25
37833: PUSH
37834: LD_INT 8
37836: PUSH
37837: EMPTY
37838: LIST
37839: LIST
37840: PUSH
37841: LD_INT 25
37843: PUSH
37844: LD_INT 9
37846: PUSH
37847: EMPTY
37848: LIST
37849: LIST
37850: PUSH
37851: EMPTY
37852: LIST
37853: LIST
37854: LIST
37855: LIST
37856: LIST
37857: PPUSH
37858: CALL_OW 72
37862: ST_TO_ADDR
// tmp := tmp diff FilterByTag ( tmp , 18 ) ;
37863: LD_ADDR_VAR 0 4
37867: PUSH
37868: LD_VAR 0 4
37872: PUSH
37873: LD_VAR 0 4
37877: PPUSH
37878: LD_INT 18
37880: PPUSH
37881: CALL 86281 0 2
37885: DIFF
37886: ST_TO_ADDR
// if not tmp and not UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_armoury ] , [ f_btype , b_barracks ] ] ) then
37887: LD_VAR 0 4
37891: NOT
37892: PUSH
37893: LD_EXP 95
37897: PUSH
37898: LD_VAR 0 2
37902: ARRAY
37903: PPUSH
37904: LD_INT 2
37906: PUSH
37907: LD_INT 30
37909: PUSH
37910: LD_INT 4
37912: PUSH
37913: EMPTY
37914: LIST
37915: LIST
37916: PUSH
37917: LD_INT 30
37919: PUSH
37920: LD_INT 5
37922: PUSH
37923: EMPTY
37924: LIST
37925: LIST
37926: PUSH
37927: EMPTY
37928: LIST
37929: LIST
37930: LIST
37931: PPUSH
37932: CALL_OW 72
37936: NOT
37937: AND
37938: IFFALSE 38000
// tmp := UnitFilter ( mc_bases [ i ] , [ f_or , [ f_class , 2 ] , [ f_class , 3 ] , [ f_class , 4 ] ] ) ;
37940: LD_ADDR_VAR 0 4
37944: PUSH
37945: LD_EXP 95
37949: PUSH
37950: LD_VAR 0 2
37954: ARRAY
37955: PPUSH
37956: LD_INT 2
37958: PUSH
37959: LD_INT 25
37961: PUSH
37962: LD_INT 2
37964: PUSH
37965: EMPTY
37966: LIST
37967: LIST
37968: PUSH
37969: LD_INT 25
37971: PUSH
37972: LD_INT 3
37974: PUSH
37975: EMPTY
37976: LIST
37977: LIST
37978: PUSH
37979: LD_INT 25
37981: PUSH
37982: LD_INT 4
37984: PUSH
37985: EMPTY
37986: LIST
37987: LIST
37988: PUSH
37989: EMPTY
37990: LIST
37991: LIST
37992: LIST
37993: LIST
37994: PPUSH
37995: CALL_OW 72
37999: ST_TO_ADDR
// BasicDefend ( i , tmp ) ;
38000: LD_VAR 0 2
38004: PPUSH
38005: LD_VAR 0 4
38009: PPUSH
38010: CALL 115795 0 2
// exit ;
38014: POP
38015: POP
38016: GO 38138
// end ; if mc_scan [ i ] and not mc_is_defending [ i ] and mc_defender [ i ] then
38018: LD_EXP 118
38022: PUSH
38023: LD_VAR 0 2
38027: ARRAY
38028: PUSH
38029: LD_EXP 138
38033: PUSH
38034: LD_VAR 0 2
38038: ARRAY
38039: NOT
38040: AND
38041: PUSH
38042: LD_EXP 117
38046: PUSH
38047: LD_VAR 0 2
38051: ARRAY
38052: AND
38053: IFFALSE 38134
// begin mc_is_defending := Replace ( mc_is_defending , i , true ) ;
38055: LD_ADDR_EXP 138
38059: PUSH
38060: LD_EXP 138
38064: PPUSH
38065: LD_VAR 0 2
38069: PPUSH
38070: LD_INT 1
38072: PPUSH
38073: CALL_OW 1
38077: ST_TO_ADDR
// tmp := mc_defender [ i ] ;
38078: LD_ADDR_VAR 0 4
38082: PUSH
38083: LD_EXP 117
38087: PUSH
38088: LD_VAR 0 2
38092: ARRAY
38093: ST_TO_ADDR
// mc_defender := Replace ( mc_defender , i , [ ] ) ;
38094: LD_ADDR_EXP 117
38098: PUSH
38099: LD_EXP 117
38103: PPUSH
38104: LD_VAR 0 2
38108: PPUSH
38109: EMPTY
38110: PPUSH
38111: CALL_OW 1
38115: ST_TO_ADDR
// Defend ( i , tmp ) ;
38116: LD_VAR 0 2
38120: PPUSH
38121: LD_VAR 0 4
38125: PPUSH
38126: CALL 116391 0 2
// exit ;
38130: POP
38131: POP
38132: GO 38138
// end ; end ;
38134: GO 37296
38136: POP
38137: POP
// end ;
38138: LD_VAR 0 1
38142: RET
// export function MC_Research ( ) ; var i , j , side , t , tmp , x , sci , tmp2 , researching , idle_lab ; begin
38143: LD_INT 0
38145: PPUSH
38146: PPUSH
38147: PPUSH
38148: PPUSH
38149: PPUSH
38150: PPUSH
38151: PPUSH
38152: PPUSH
38153: PPUSH
38154: PPUSH
38155: PPUSH
// if not mc_bases then
38156: LD_EXP 95
38160: NOT
38161: IFFALSE 38165
// exit ;
38163: GO 39252
// for i = 1 to mc_bases do
38165: LD_ADDR_VAR 0 2
38169: PUSH
38170: DOUBLE
38171: LD_INT 1
38173: DEC
38174: ST_TO_ADDR
38175: LD_EXP 95
38179: PUSH
38180: FOR_TO
38181: IFFALSE 39250
// begin tmp := mc_lab [ i ] ;
38183: LD_ADDR_VAR 0 6
38187: PUSH
38188: LD_EXP 128
38192: PUSH
38193: LD_VAR 0 2
38197: ARRAY
38198: ST_TO_ADDR
// if not tmp then
38199: LD_VAR 0 6
38203: NOT
38204: IFFALSE 38208
// continue ;
38206: GO 38180
// idle_lab := 0 ;
38208: LD_ADDR_VAR 0 11
38212: PUSH
38213: LD_INT 0
38215: ST_TO_ADDR
// for j in tmp do
38216: LD_ADDR_VAR 0 3
38220: PUSH
38221: LD_VAR 0 6
38225: PUSH
38226: FOR_IN
38227: IFFALSE 39246
// begin researching := false ;
38229: LD_ADDR_VAR 0 10
38233: PUSH
38234: LD_INT 0
38236: ST_TO_ADDR
// side := GetSide ( j ) ;
38237: LD_ADDR_VAR 0 4
38241: PUSH
38242: LD_VAR 0 3
38246: PPUSH
38247: CALL_OW 255
38251: ST_TO_ADDR
// if not mc_tech [ side ] then
38252: LD_EXP 122
38256: PUSH
38257: LD_VAR 0 4
38261: ARRAY
38262: NOT
38263: IFFALSE 38267
// continue ;
38265: GO 38226
// if BuildingStatus ( j ) = bs_idle then
38267: LD_VAR 0 3
38271: PPUSH
38272: CALL_OW 461
38276: PUSH
38277: LD_INT 2
38279: EQUAL
38280: IFFALSE 38468
// begin if idle_lab and UnitsInside ( j ) < 6 then
38282: LD_VAR 0 11
38286: PUSH
38287: LD_VAR 0 3
38291: PPUSH
38292: CALL_OW 313
38296: PUSH
38297: LD_INT 6
38299: LESS
38300: AND
38301: IFFALSE 38372
// begin tmp2 := UnitsInside ( idle_lab ) ;
38303: LD_ADDR_VAR 0 9
38307: PUSH
38308: LD_VAR 0 11
38312: PPUSH
38313: CALL_OW 313
38317: ST_TO_ADDR
// if tmp2 then
38318: LD_VAR 0 9
38322: IFFALSE 38364
// for x in tmp2 do
38324: LD_ADDR_VAR 0 7
38328: PUSH
38329: LD_VAR 0 9
38333: PUSH
38334: FOR_IN
38335: IFFALSE 38362
// begin ComExitBuilding ( x ) ;
38337: LD_VAR 0 7
38341: PPUSH
38342: CALL_OW 122
// AddComEnterUnit ( x , j ) ;
38346: LD_VAR 0 7
38350: PPUSH
38351: LD_VAR 0 3
38355: PPUSH
38356: CALL_OW 180
// end ;
38360: GO 38334
38362: POP
38363: POP
// idle_lab := 0 ;
38364: LD_ADDR_VAR 0 11
38368: PUSH
38369: LD_INT 0
38371: ST_TO_ADDR
// end ; for t in mc_tech [ side ] do
38372: LD_ADDR_VAR 0 5
38376: PUSH
38377: LD_EXP 122
38381: PUSH
38382: LD_VAR 0 4
38386: ARRAY
38387: PUSH
38388: FOR_IN
38389: IFFALSE 38449
// if CanBeResearched ( j , t ) and TechCanBeResearch ( side , t ) then
38391: LD_VAR 0 3
38395: PPUSH
38396: LD_VAR 0 5
38400: PPUSH
38401: CALL_OW 430
38405: PUSH
38406: LD_VAR 0 4
38410: PPUSH
38411: LD_VAR 0 5
38415: PPUSH
38416: CALL 52882 0 2
38420: AND
38421: IFFALSE 38447
// begin researching := true ;
38423: LD_ADDR_VAR 0 10
38427: PUSH
38428: LD_INT 1
38430: ST_TO_ADDR
// ComResearch ( j , t ) ;
38431: LD_VAR 0 3
38435: PPUSH
38436: LD_VAR 0 5
38440: PPUSH
38441: CALL_OW 124
// break ;
38445: GO 38449
// end ;
38447: GO 38388
38449: POP
38450: POP
// if not researching then
38451: LD_VAR 0 10
38455: NOT
38456: IFFALSE 38468
// idle_lab := j ;
38458: LD_ADDR_VAR 0 11
38462: PUSH
38463: LD_VAR 0 3
38467: ST_TO_ADDR
// end ; if BuildingStatus ( j ) = bs_need_ape then
38468: LD_VAR 0 3
38472: PPUSH
38473: CALL_OW 461
38477: PUSH
38478: LD_INT 10
38480: EQUAL
38481: IFFALSE 39069
// begin if not mc_ape [ i ] and not mc_ape_in_lab [ i ] and mc_tech [ side ] > 1 then
38483: LD_EXP 124
38487: PUSH
38488: LD_VAR 0 2
38492: ARRAY
38493: NOT
38494: PUSH
38495: LD_EXP 125
38499: PUSH
38500: LD_VAR 0 2
38504: ARRAY
38505: NOT
38506: AND
38507: PUSH
38508: LD_EXP 122
38512: PUSH
38513: LD_VAR 0 4
38517: ARRAY
38518: PUSH
38519: LD_INT 1
38521: GREATER
38522: AND
38523: IFFALSE 38654
// begin ComCancel ( j ) ;
38525: LD_VAR 0 3
38529: PPUSH
38530: CALL_OW 127
// mc_tech := Replace ( mc_tech , side , Reindex ( mc_tech [ side ] , mc_tech [ side ] - 1 , mc_tech [ side ] , false ) ) ;
38534: LD_ADDR_EXP 122
38538: PUSH
38539: LD_EXP 122
38543: PPUSH
38544: LD_VAR 0 4
38548: PPUSH
38549: LD_EXP 122
38553: PUSH
38554: LD_VAR 0 4
38558: ARRAY
38559: PPUSH
38560: LD_EXP 122
38564: PUSH
38565: LD_VAR 0 4
38569: ARRAY
38570: PUSH
38571: LD_INT 1
38573: MINUS
38574: PPUSH
38575: LD_EXP 122
38579: PUSH
38580: LD_VAR 0 4
38584: ARRAY
38585: PPUSH
38586: LD_INT 0
38588: PPUSH
38589: CALL 56430 0 4
38593: PPUSH
38594: CALL_OW 1
38598: ST_TO_ADDR
// mc_tech := Replace ( mc_tech , side , Reindex ( mc_tech [ side ] , mc_tech [ side ] , 1 , false ) ) ;
38599: LD_ADDR_EXP 122
38603: PUSH
38604: LD_EXP 122
38608: PPUSH
38609: LD_VAR 0 4
38613: PPUSH
38614: LD_EXP 122
38618: PUSH
38619: LD_VAR 0 4
38623: ARRAY
38624: PPUSH
38625: LD_EXP 122
38629: PUSH
38630: LD_VAR 0 4
38634: ARRAY
38635: PPUSH
38636: LD_INT 1
38638: PPUSH
38639: LD_INT 0
38641: PPUSH
38642: CALL 56430 0 4
38646: PPUSH
38647: CALL_OW 1
38651: ST_TO_ADDR
// continue ;
38652: GO 38226
// end ; if mc_ape [ i ] and not mc_ape_in_lab [ i ] then
38654: LD_EXP 124
38658: PUSH
38659: LD_VAR 0 2
38663: ARRAY
38664: PUSH
38665: LD_EXP 125
38669: PUSH
38670: LD_VAR 0 2
38674: ARRAY
38675: NOT
38676: AND
38677: IFFALSE 38804
// begin mc_ape_in_lab := ReplaceIn ( mc_ape_in_lab , [ i , mc_ape_in_lab [ i ] + 1 ] , mc_ape [ i ] [ 1 ] ) ;
38679: LD_ADDR_EXP 125
38683: PUSH
38684: LD_EXP 125
38688: PPUSH
38689: LD_VAR 0 2
38693: PUSH
38694: LD_EXP 125
38698: PUSH
38699: LD_VAR 0 2
38703: ARRAY
38704: PUSH
38705: LD_INT 1
38707: PLUS
38708: PUSH
38709: EMPTY
38710: LIST
38711: LIST
38712: PPUSH
38713: LD_EXP 124
38717: PUSH
38718: LD_VAR 0 2
38722: ARRAY
38723: PUSH
38724: LD_INT 1
38726: ARRAY
38727: PPUSH
38728: CALL 57012 0 3
38732: ST_TO_ADDR
// SetTag ( mc_ape [ i ] [ 1 ] , 112 ) ;
38733: LD_EXP 124
38737: PUSH
38738: LD_VAR 0 2
38742: ARRAY
38743: PUSH
38744: LD_INT 1
38746: ARRAY
38747: PPUSH
38748: LD_INT 112
38750: PPUSH
38751: CALL_OW 109
// tmp2 := Delete ( mc_ape [ i ] , 1 ) ;
38755: LD_ADDR_VAR 0 9
38759: PUSH
38760: LD_EXP 124
38764: PUSH
38765: LD_VAR 0 2
38769: ARRAY
38770: PPUSH
38771: LD_INT 1
38773: PPUSH
38774: CALL_OW 3
38778: ST_TO_ADDR
// mc_ape := Replace ( mc_ape , i , tmp2 ) ;
38779: LD_ADDR_EXP 124
38783: PUSH
38784: LD_EXP 124
38788: PPUSH
38789: LD_VAR 0 2
38793: PPUSH
38794: LD_VAR 0 9
38798: PPUSH
38799: CALL_OW 1
38803: ST_TO_ADDR
// end ; if mc_ape [ i ] and mc_ape_in_lab [ i ] and not IsInUnit ( mc_ape_in_lab [ i ] [ 1 ] ) and UnitsInside ( j ) = 6 then
38804: LD_EXP 124
38808: PUSH
38809: LD_VAR 0 2
38813: ARRAY
38814: PUSH
38815: LD_EXP 125
38819: PUSH
38820: LD_VAR 0 2
38824: ARRAY
38825: AND
38826: PUSH
38827: LD_EXP 125
38831: PUSH
38832: LD_VAR 0 2
38836: ARRAY
38837: PUSH
38838: LD_INT 1
38840: ARRAY
38841: PPUSH
38842: CALL_OW 310
38846: NOT
38847: AND
38848: PUSH
38849: LD_VAR 0 3
38853: PPUSH
38854: CALL_OW 313
38858: PUSH
38859: LD_INT 6
38861: EQUAL
38862: AND
38863: IFFALSE 38919
// begin tmp2 := UnitsInside ( j ) ;
38865: LD_ADDR_VAR 0 9
38869: PUSH
38870: LD_VAR 0 3
38874: PPUSH
38875: CALL_OW 313
38879: ST_TO_ADDR
// if tmp2 = 6 then
38880: LD_VAR 0 9
38884: PUSH
38885: LD_INT 6
38887: EQUAL
38888: IFFALSE 38919
// begin SetTag ( tmp2 [ 1 ] , 112 ) ;
38890: LD_VAR 0 9
38894: PUSH
38895: LD_INT 1
38897: ARRAY
38898: PPUSH
38899: LD_INT 112
38901: PPUSH
38902: CALL_OW 109
// ComExitBuilding ( tmp2 [ 1 ] ) ;
38906: LD_VAR 0 9
38910: PUSH
38911: LD_INT 1
38913: ARRAY
38914: PPUSH
38915: CALL_OW 122
// end ; end ; if mc_ape_in_lab [ i ] and not HasTask ( mc_ape_in_lab [ i ] [ 1 ] ) and not IsInUnit ( mc_ape_in_lab [ i ] [ 1 ] ) then
38919: LD_EXP 125
38923: PUSH
38924: LD_VAR 0 2
38928: ARRAY
38929: PUSH
38930: LD_EXP 125
38934: PUSH
38935: LD_VAR 0 2
38939: ARRAY
38940: PUSH
38941: LD_INT 1
38943: ARRAY
38944: PPUSH
38945: CALL_OW 314
38949: NOT
38950: AND
38951: PUSH
38952: LD_EXP 125
38956: PUSH
38957: LD_VAR 0 2
38961: ARRAY
38962: PUSH
38963: LD_INT 1
38965: ARRAY
38966: PPUSH
38967: CALL_OW 310
38971: NOT
38972: AND
38973: IFFALSE 38999
// ComEnterUnit ( mc_ape_in_lab [ i ] [ 1 ] , j ) ;
38975: LD_EXP 125
38979: PUSH
38980: LD_VAR 0 2
38984: ARRAY
38985: PUSH
38986: LD_INT 1
38988: ARRAY
38989: PPUSH
38990: LD_VAR 0 3
38994: PPUSH
38995: CALL_OW 120
// if IsInUnit ( mc_ape_in_lab [ i ] [ 1 ] ) and BuildingStatus ( IsInUnit ( mc_ape_in_lab [ i ] [ 1 ] ) ) <> bs_working then
38999: LD_EXP 125
39003: PUSH
39004: LD_VAR 0 2
39008: ARRAY
39009: PUSH
39010: LD_INT 1
39012: ARRAY
39013: PPUSH
39014: CALL_OW 310
39018: PUSH
39019: LD_EXP 125
39023: PUSH
39024: LD_VAR 0 2
39028: ARRAY
39029: PUSH
39030: LD_INT 1
39032: ARRAY
39033: PPUSH
39034: CALL_OW 310
39038: PPUSH
39039: CALL_OW 461
39043: PUSH
39044: LD_INT 3
39046: NONEQUAL
39047: AND
39048: IFFALSE 39069
// ComExitBuilding ( mc_ape_in_lab [ i ] [ 1 ] ) ;
39050: LD_EXP 125
39054: PUSH
39055: LD_VAR 0 2
39059: ARRAY
39060: PUSH
39061: LD_INT 1
39063: ARRAY
39064: PPUSH
39065: CALL_OW 122
// end ; if BuildingStatus ( j ) = bs_need_people and tmp > 1 then
39069: LD_VAR 0 3
39073: PPUSH
39074: CALL_OW 461
39078: PUSH
39079: LD_INT 6
39081: EQUAL
39082: PUSH
39083: LD_VAR 0 6
39087: PUSH
39088: LD_INT 1
39090: GREATER
39091: AND
39092: IFFALSE 39244
// begin sci := [ ] ;
39094: LD_ADDR_VAR 0 8
39098: PUSH
39099: EMPTY
39100: ST_TO_ADDR
// for x in ( tmp diff j ) do
39101: LD_ADDR_VAR 0 7
39105: PUSH
39106: LD_VAR 0 6
39110: PUSH
39111: LD_VAR 0 3
39115: DIFF
39116: PUSH
39117: FOR_IN
39118: IFFALSE 39170
// begin if sci = 6 then
39120: LD_VAR 0 8
39124: PUSH
39125: LD_INT 6
39127: EQUAL
39128: IFFALSE 39132
// break ;
39130: GO 39170
// if BuildingStatus ( x ) = bs_idle then
39132: LD_VAR 0 7
39136: PPUSH
39137: CALL_OW 461
39141: PUSH
39142: LD_INT 2
39144: EQUAL
39145: IFFALSE 39168
// sci := sci ^ UnitsInside ( x ) ;
39147: LD_ADDR_VAR 0 8
39151: PUSH
39152: LD_VAR 0 8
39156: PUSH
39157: LD_VAR 0 7
39161: PPUSH
39162: CALL_OW 313
39166: ADD
39167: ST_TO_ADDR
// end ;
39168: GO 39117
39170: POP
39171: POP
// if not sci then
39172: LD_VAR 0 8
39176: NOT
39177: IFFALSE 39181
// continue ;
39179: GO 38226
// for x in sci do
39181: LD_ADDR_VAR 0 7
39185: PUSH
39186: LD_VAR 0 8
39190: PUSH
39191: FOR_IN
39192: IFFALSE 39242
// if IsInUnit ( x ) and not HasTask ( x ) then
39194: LD_VAR 0 7
39198: PPUSH
39199: CALL_OW 310
39203: PUSH
39204: LD_VAR 0 7
39208: PPUSH
39209: CALL_OW 314
39213: NOT
39214: AND
39215: IFFALSE 39240
// begin ComExitBuilding ( x ) ;
39217: LD_VAR 0 7
39221: PPUSH
39222: CALL_OW 122
// AddComEnterUnit ( x , j ) ;
39226: LD_VAR 0 7
39230: PPUSH
39231: LD_VAR 0 3
39235: PPUSH
39236: CALL_OW 180
// end ;
39240: GO 39191
39242: POP
39243: POP
// end ; end ;
39244: GO 38226
39246: POP
39247: POP
// end ;
39248: GO 38180
39250: POP
39251: POP
// end ;
39252: LD_VAR 0 1
39256: RET
// export function MC_MinesTrigger ( ) ; var i ; begin
39257: LD_INT 0
39259: PPUSH
39260: PPUSH
// if not mc_bases then
39261: LD_EXP 95
39265: NOT
39266: IFFALSE 39270
// exit ;
39268: GO 39351
// for i = 1 to mc_bases do
39270: LD_ADDR_VAR 0 2
39274: PUSH
39275: DOUBLE
39276: LD_INT 1
39278: DEC
39279: ST_TO_ADDR
39280: LD_EXP 95
39284: PUSH
39285: FOR_TO
39286: IFFALSE 39349
// if mc_mines [ i ] and mc_miners [ i ] then
39288: LD_EXP 108
39292: PUSH
39293: LD_VAR 0 2
39297: ARRAY
39298: PUSH
39299: LD_EXP 109
39303: PUSH
39304: LD_VAR 0 2
39308: ARRAY
39309: AND
39310: IFFALSE 39347
// DetonateMines ( GetSide ( mc_miners [ i ] [ 1 ] ) , mc_mines [ i ] ) ;
39312: LD_EXP 109
39316: PUSH
39317: LD_VAR 0 2
39321: ARRAY
39322: PUSH
39323: LD_INT 1
39325: ARRAY
39326: PPUSH
39327: CALL_OW 255
39331: PPUSH
39332: LD_EXP 108
39336: PUSH
39337: LD_VAR 0 2
39341: ARRAY
39342: PPUSH
39343: CALL 53965 0 2
39347: GO 39285
39349: POP
39350: POP
// end ;
39351: LD_VAR 0 1
39355: RET
// export function MC_RepairVehicle ( ) ; var i , j , k , side , fac , vehs , tmp ; begin
39356: LD_INT 0
39358: PPUSH
39359: PPUSH
39360: PPUSH
39361: PPUSH
39362: PPUSH
39363: PPUSH
39364: PPUSH
39365: PPUSH
// if not mc_bases or not mc_parking then
39366: LD_EXP 95
39370: NOT
39371: PUSH
39372: LD_EXP 119
39376: NOT
39377: OR
39378: IFFALSE 39382
// exit ;
39380: GO 40092
// for i = 1 to mc_bases do
39382: LD_ADDR_VAR 0 2
39386: PUSH
39387: DOUBLE
39388: LD_INT 1
39390: DEC
39391: ST_TO_ADDR
39392: LD_EXP 95
39396: PUSH
39397: FOR_TO
39398: IFFALSE 40090
// begin if not mc_bases [ i ] or not mc_parking [ i ] then
39400: LD_EXP 95
39404: PUSH
39405: LD_VAR 0 2
39409: ARRAY
39410: NOT
39411: PUSH
39412: LD_EXP 119
39416: PUSH
39417: LD_VAR 0 2
39421: ARRAY
39422: NOT
39423: OR
39424: IFFALSE 39428
// continue ;
39426: GO 39397
// side := GetSide ( mc_bases [ i ] [ 1 ] ) ;
39428: LD_ADDR_VAR 0 5
39432: PUSH
39433: LD_EXP 95
39437: PUSH
39438: LD_VAR 0 2
39442: ARRAY
39443: PUSH
39444: LD_INT 1
39446: ARRAY
39447: PPUSH
39448: CALL_OW 255
39452: ST_TO_ADDR
// fac := UnitFilter ( mc_bases [ i ] , [ f_btype , b_factory ] ) ;
39453: LD_ADDR_VAR 0 6
39457: PUSH
39458: LD_EXP 95
39462: PUSH
39463: LD_VAR 0 2
39467: ARRAY
39468: PPUSH
39469: LD_INT 30
39471: PUSH
39472: LD_INT 3
39474: PUSH
39475: EMPTY
39476: LIST
39477: LIST
39478: PPUSH
39479: CALL_OW 72
39483: ST_TO_ADDR
// if not fac then
39484: LD_VAR 0 6
39488: NOT
39489: IFFALSE 39540
// fac := UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) ;
39491: LD_ADDR_VAR 0 6
39495: PUSH
39496: LD_EXP 95
39500: PUSH
39501: LD_VAR 0 2
39505: ARRAY
39506: PPUSH
39507: LD_INT 2
39509: PUSH
39510: LD_INT 30
39512: PUSH
39513: LD_INT 0
39515: PUSH
39516: EMPTY
39517: LIST
39518: LIST
39519: PUSH
39520: LD_INT 30
39522: PUSH
39523: LD_INT 1
39525: PUSH
39526: EMPTY
39527: LIST
39528: LIST
39529: PUSH
39530: EMPTY
39531: LIST
39532: LIST
39533: LIST
39534: PPUSH
39535: CALL_OW 72
39539: ST_TO_ADDR
// if not fac then
39540: LD_VAR 0 6
39544: NOT
39545: IFFALSE 39549
// continue ;
39547: GO 39397
// vehs := FilterUnitsInArea ( mc_parking [ i ] , [ [ f_side , side ] , [ f_type , unit_vehicle ] , [ f_not , [ f_lives , 1000 ] ] ] ) ;
39549: LD_ADDR_VAR 0 7
39553: PUSH
39554: LD_EXP 119
39558: PUSH
39559: LD_VAR 0 2
39563: ARRAY
39564: PPUSH
39565: LD_INT 22
39567: PUSH
39568: LD_VAR 0 5
39572: PUSH
39573: EMPTY
39574: LIST
39575: LIST
39576: PUSH
39577: LD_INT 21
39579: PUSH
39580: LD_INT 2
39582: PUSH
39583: EMPTY
39584: LIST
39585: LIST
39586: PUSH
39587: LD_INT 3
39589: PUSH
39590: LD_INT 24
39592: PUSH
39593: LD_INT 1000
39595: PUSH
39596: EMPTY
39597: LIST
39598: LIST
39599: PUSH
39600: EMPTY
39601: LIST
39602: LIST
39603: PUSH
39604: EMPTY
39605: LIST
39606: LIST
39607: LIST
39608: PPUSH
39609: CALL_OW 70
39613: ST_TO_ADDR
// for j in fac do
39614: LD_ADDR_VAR 0 3
39618: PUSH
39619: LD_VAR 0 6
39623: PUSH
39624: FOR_IN
39625: IFFALSE 39706
// vehs := vehs union FilterAllUnits ( [ [ f_side , side ] , [ f_dist , j , 15 ] , [ f_type , unit_vehicle ] , [ f_not , [ f_lives , 1000 ] ] ] ) ;
39627: LD_ADDR_VAR 0 7
39631: PUSH
39632: LD_VAR 0 7
39636: PUSH
39637: LD_INT 22
39639: PUSH
39640: LD_VAR 0 5
39644: PUSH
39645: EMPTY
39646: LIST
39647: LIST
39648: PUSH
39649: LD_INT 91
39651: PUSH
39652: LD_VAR 0 3
39656: PUSH
39657: LD_INT 15
39659: PUSH
39660: EMPTY
39661: LIST
39662: LIST
39663: LIST
39664: PUSH
39665: LD_INT 21
39667: PUSH
39668: LD_INT 2
39670: PUSH
39671: EMPTY
39672: LIST
39673: LIST
39674: PUSH
39675: LD_INT 3
39677: PUSH
39678: LD_INT 24
39680: PUSH
39681: LD_INT 1000
39683: PUSH
39684: EMPTY
39685: LIST
39686: LIST
39687: PUSH
39688: EMPTY
39689: LIST
39690: LIST
39691: PUSH
39692: EMPTY
39693: LIST
39694: LIST
39695: LIST
39696: LIST
39697: PPUSH
39698: CALL_OW 69
39702: UNION
39703: ST_TO_ADDR
39704: GO 39624
39706: POP
39707: POP
// if not vehs then
39708: LD_VAR 0 7
39712: NOT
39713: IFFALSE 39739
// begin mc_repair_vehicle := Replace ( mc_repair_vehicle , i , [ ] ) ;
39715: LD_ADDR_EXP 107
39719: PUSH
39720: LD_EXP 107
39724: PPUSH
39725: LD_VAR 0 2
39729: PPUSH
39730: EMPTY
39731: PPUSH
39732: CALL_OW 1
39736: ST_TO_ADDR
// continue ;
39737: GO 39397
// end ; tmp := UnitFilter ( mc_bases [ i ] , [ f_btype , b_factory ] ) ;
39739: LD_ADDR_VAR 0 8
39743: PUSH
39744: LD_EXP 95
39748: PUSH
39749: LD_VAR 0 2
39753: ARRAY
39754: PPUSH
39755: LD_INT 30
39757: PUSH
39758: LD_INT 3
39760: PUSH
39761: EMPTY
39762: LIST
39763: LIST
39764: PPUSH
39765: CALL_OW 72
39769: ST_TO_ADDR
// if tmp then
39770: LD_VAR 0 8
39774: IFFALSE 39877
// begin for j in tmp do
39776: LD_ADDR_VAR 0 3
39780: PUSH
39781: LD_VAR 0 8
39785: PUSH
39786: FOR_IN
39787: IFFALSE 39875
// for k in UnitsInside ( j ) do
39789: LD_ADDR_VAR 0 4
39793: PUSH
39794: LD_VAR 0 3
39798: PPUSH
39799: CALL_OW 313
39803: PUSH
39804: FOR_IN
39805: IFFALSE 39871
// if k then
39807: LD_VAR 0 4
39811: IFFALSE 39869
// if not k in mc_repair_vehicle [ i ] then
39813: LD_VAR 0 4
39817: PUSH
39818: LD_EXP 107
39822: PUSH
39823: LD_VAR 0 2
39827: ARRAY
39828: IN
39829: NOT
39830: IFFALSE 39869
// mc_repair_vehicle := Replace ( mc_repair_vehicle , i , mc_repair_vehicle [ i ] union k ) ;
39832: LD_ADDR_EXP 107
39836: PUSH
39837: LD_EXP 107
39841: PPUSH
39842: LD_VAR 0 2
39846: PPUSH
39847: LD_EXP 107
39851: PUSH
39852: LD_VAR 0 2
39856: ARRAY
39857: PUSH
39858: LD_VAR 0 4
39862: UNION
39863: PPUSH
39864: CALL_OW 1
39868: ST_TO_ADDR
39869: GO 39804
39871: POP
39872: POP
39873: GO 39786
39875: POP
39876: POP
// end ; if not mc_repair_vehicle [ i ] then
39877: LD_EXP 107
39881: PUSH
39882: LD_VAR 0 2
39886: ARRAY
39887: NOT
39888: IFFALSE 39892
// continue ;
39890: GO 39397
// for j in mc_repair_vehicle [ i ] do
39892: LD_ADDR_VAR 0 3
39896: PUSH
39897: LD_EXP 107
39901: PUSH
39902: LD_VAR 0 2
39906: ARRAY
39907: PUSH
39908: FOR_IN
39909: IFFALSE 40086
// begin if GetClass ( j ) <> 3 then
39911: LD_VAR 0 3
39915: PPUSH
39916: CALL_OW 257
39920: PUSH
39921: LD_INT 3
39923: NONEQUAL
39924: IFFALSE 39965
// begin mc_repair_vehicle := Replace ( mc_repair_vehicle , i , mc_repair_vehicle [ i ] diff j ) ;
39926: LD_ADDR_EXP 107
39930: PUSH
39931: LD_EXP 107
39935: PPUSH
39936: LD_VAR 0 2
39940: PPUSH
39941: LD_EXP 107
39945: PUSH
39946: LD_VAR 0 2
39950: ARRAY
39951: PUSH
39952: LD_VAR 0 3
39956: DIFF
39957: PPUSH
39958: CALL_OW 1
39962: ST_TO_ADDR
// continue ;
39963: GO 39908
// end ; if not IsDrivenBy ( j ) and not j in mc_need_heal [ i ] [ 1 ] and not j in mc_need_heal [ i ] [ 2 ] then
39965: LD_VAR 0 3
39969: PPUSH
39970: CALL_OW 311
39974: NOT
39975: PUSH
39976: LD_VAR 0 3
39980: PUSH
39981: LD_EXP 98
39985: PUSH
39986: LD_VAR 0 2
39990: ARRAY
39991: PUSH
39992: LD_INT 1
39994: ARRAY
39995: IN
39996: NOT
39997: AND
39998: PUSH
39999: LD_VAR 0 3
40003: PUSH
40004: LD_EXP 98
40008: PUSH
40009: LD_VAR 0 2
40013: ARRAY
40014: PUSH
40015: LD_INT 2
40017: ARRAY
40018: IN
40019: NOT
40020: AND
40021: IFFALSE 40084
// begin if IsInUnit ( j ) then
40023: LD_VAR 0 3
40027: PPUSH
40028: CALL_OW 310
40032: IFFALSE 40045
// ComExitBuilding ( j ) else
40034: LD_VAR 0 3
40038: PPUSH
40039: CALL_OW 122
40043: GO 40084
// if not WantToRepairVehicle ( j , vehs [ 1 ] ) then
40045: LD_VAR 0 3
40049: PPUSH
40050: LD_VAR 0 7
40054: PUSH
40055: LD_INT 1
40057: ARRAY
40058: PPUSH
40059: CALL 90820 0 2
40063: NOT
40064: IFFALSE 40084
// ComRepairVehicle ( j , vehs [ 1 ] ) ;
40066: LD_VAR 0 3
40070: PPUSH
40071: LD_VAR 0 7
40075: PUSH
40076: LD_INT 1
40078: ARRAY
40079: PPUSH
40080: CALL_OW 129
// end ; end ;
40084: GO 39908
40086: POP
40087: POP
// end ;
40088: GO 39397
40090: POP
40091: POP
// end ;
40092: LD_VAR 0 1
40096: RET
// export function MC_TameApe ( ) ; var i , j , x , y , ape , apes , tmp , dep , danger_at_area , side ; begin
40097: LD_INT 0
40099: PPUSH
40100: PPUSH
40101: PPUSH
40102: PPUSH
40103: PPUSH
40104: PPUSH
40105: PPUSH
40106: PPUSH
40107: PPUSH
40108: PPUSH
40109: PPUSH
// if not mc_bases then
40110: LD_EXP 95
40114: NOT
40115: IFFALSE 40119
// exit ;
40117: GO 40921
// for i = 1 to mc_bases do
40119: LD_ADDR_VAR 0 2
40123: PUSH
40124: DOUBLE
40125: LD_INT 1
40127: DEC
40128: ST_TO_ADDR
40129: LD_EXP 95
40133: PUSH
40134: FOR_TO
40135: IFFALSE 40919
// begin if not mc_can_tame [ i ] or mc_need_heal [ i ] [ 1 ] or mc_need_heal [ i ] [ 2 ] or not Researched ( mc_sides [ i ] , tech_apelang ) or mc_scan [ i ] then
40137: LD_EXP 123
40141: PUSH
40142: LD_VAR 0 2
40146: ARRAY
40147: NOT
40148: PUSH
40149: LD_EXP 98
40153: PUSH
40154: LD_VAR 0 2
40158: ARRAY
40159: PUSH
40160: LD_INT 1
40162: ARRAY
40163: OR
40164: PUSH
40165: LD_EXP 98
40169: PUSH
40170: LD_VAR 0 2
40174: ARRAY
40175: PUSH
40176: LD_INT 2
40178: ARRAY
40179: OR
40180: PUSH
40181: LD_EXP 121
40185: PUSH
40186: LD_VAR 0 2
40190: ARRAY
40191: PPUSH
40192: LD_INT 1
40194: PPUSH
40195: CALL_OW 325
40199: NOT
40200: OR
40201: PUSH
40202: LD_EXP 118
40206: PUSH
40207: LD_VAR 0 2
40211: ARRAY
40212: OR
40213: IFFALSE 40217
// continue ;
40215: GO 40134
// tmp := UnitFilter ( mc_bases [ i ] , [ [ f_class , 4 ] , [ f_ok ] , [ f_not , [ f_hastask ] ] ] ) diff mc_healers [ i ] ;
40217: LD_ADDR_VAR 0 8
40221: PUSH
40222: LD_EXP 95
40226: PUSH
40227: LD_VAR 0 2
40231: ARRAY
40232: PPUSH
40233: LD_INT 25
40235: PUSH
40236: LD_INT 4
40238: PUSH
40239: EMPTY
40240: LIST
40241: LIST
40242: PUSH
40243: LD_INT 50
40245: PUSH
40246: EMPTY
40247: LIST
40248: PUSH
40249: LD_INT 3
40251: PUSH
40252: LD_INT 60
40254: PUSH
40255: EMPTY
40256: LIST
40257: PUSH
40258: EMPTY
40259: LIST
40260: LIST
40261: PUSH
40262: EMPTY
40263: LIST
40264: LIST
40265: LIST
40266: PPUSH
40267: CALL_OW 72
40271: PUSH
40272: LD_EXP 99
40276: PUSH
40277: LD_VAR 0 2
40281: ARRAY
40282: DIFF
40283: ST_TO_ADDR
// dep := UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) ;
40284: LD_ADDR_VAR 0 9
40288: PUSH
40289: LD_EXP 95
40293: PUSH
40294: LD_VAR 0 2
40298: ARRAY
40299: PPUSH
40300: LD_INT 2
40302: PUSH
40303: LD_INT 30
40305: PUSH
40306: LD_INT 0
40308: PUSH
40309: EMPTY
40310: LIST
40311: LIST
40312: PUSH
40313: LD_INT 30
40315: PUSH
40316: LD_INT 1
40318: PUSH
40319: EMPTY
40320: LIST
40321: LIST
40322: PUSH
40323: EMPTY
40324: LIST
40325: LIST
40326: LIST
40327: PPUSH
40328: CALL_OW 72
40332: ST_TO_ADDR
// if not tmp or not dep then
40333: LD_VAR 0 8
40337: NOT
40338: PUSH
40339: LD_VAR 0 9
40343: NOT
40344: OR
40345: IFFALSE 40349
// continue ;
40347: GO 40134
// side := GetSide ( tmp [ 1 ] ) ;
40349: LD_ADDR_VAR 0 11
40353: PUSH
40354: LD_VAR 0 8
40358: PUSH
40359: LD_INT 1
40361: ARRAY
40362: PPUSH
40363: CALL_OW 255
40367: ST_TO_ADDR
// dep := dep [ 1 ] ;
40368: LD_ADDR_VAR 0 9
40372: PUSH
40373: LD_VAR 0 9
40377: PUSH
40378: LD_INT 1
40380: ARRAY
40381: ST_TO_ADDR
// apes := FilterUnitsInArea ( mc_can_tame [ i ] , [ [ f_side , 0 ] , [ f_class , class_apeman ] ] ) union FilterAllUnits ( [ [ f_side , 0 ] , [ f_class , class_apeman ] , [ f_dist , dep , 20 ] ] ) ;
40382: LD_ADDR_VAR 0 7
40386: PUSH
40387: LD_EXP 123
40391: PUSH
40392: LD_VAR 0 2
40396: ARRAY
40397: PPUSH
40398: LD_INT 22
40400: PUSH
40401: LD_INT 0
40403: PUSH
40404: EMPTY
40405: LIST
40406: LIST
40407: PUSH
40408: LD_INT 25
40410: PUSH
40411: LD_INT 12
40413: PUSH
40414: EMPTY
40415: LIST
40416: LIST
40417: PUSH
40418: EMPTY
40419: LIST
40420: LIST
40421: PPUSH
40422: CALL_OW 70
40426: PUSH
40427: LD_INT 22
40429: PUSH
40430: LD_INT 0
40432: PUSH
40433: EMPTY
40434: LIST
40435: LIST
40436: PUSH
40437: LD_INT 25
40439: PUSH
40440: LD_INT 12
40442: PUSH
40443: EMPTY
40444: LIST
40445: LIST
40446: PUSH
40447: LD_INT 91
40449: PUSH
40450: LD_VAR 0 9
40454: PUSH
40455: LD_INT 20
40457: PUSH
40458: EMPTY
40459: LIST
40460: LIST
40461: LIST
40462: PUSH
40463: EMPTY
40464: LIST
40465: LIST
40466: LIST
40467: PPUSH
40468: CALL_OW 69
40472: UNION
40473: ST_TO_ADDR
// danger_at_area := FilterUnitsInArea ( mc_can_tame [ i ] , [ f_enemy , side ] ) ;
40474: LD_ADDR_VAR 0 10
40478: PUSH
40479: LD_EXP 123
40483: PUSH
40484: LD_VAR 0 2
40488: ARRAY
40489: PPUSH
40490: LD_INT 81
40492: PUSH
40493: LD_VAR 0 11
40497: PUSH
40498: EMPTY
40499: LIST
40500: LIST
40501: PPUSH
40502: CALL_OW 70
40506: ST_TO_ADDR
// if not apes or danger_at_area then
40507: LD_VAR 0 7
40511: NOT
40512: PUSH
40513: LD_VAR 0 10
40517: OR
40518: IFFALSE 40568
// begin if mc_taming [ i ] then
40520: LD_EXP 126
40524: PUSH
40525: LD_VAR 0 2
40529: ARRAY
40530: IFFALSE 40566
// begin MC_Reset ( i , 121 ) ;
40532: LD_VAR 0 2
40536: PPUSH
40537: LD_INT 121
40539: PPUSH
40540: CALL 25554 0 2
// mc_taming := Replace ( mc_taming , i , [ ] ) ;
40544: LD_ADDR_EXP 126
40548: PUSH
40549: LD_EXP 126
40553: PPUSH
40554: LD_VAR 0 2
40558: PPUSH
40559: EMPTY
40560: PPUSH
40561: CALL_OW 1
40565: ST_TO_ADDR
// end ; continue ;
40566: GO 40134
// end ; for j in tmp do
40568: LD_ADDR_VAR 0 3
40572: PUSH
40573: LD_VAR 0 8
40577: PUSH
40578: FOR_IN
40579: IFFALSE 40915
// begin if not j in mc_taming [ i ] and mc_taming [ i ] < 3 then
40581: LD_VAR 0 3
40585: PUSH
40586: LD_EXP 126
40590: PUSH
40591: LD_VAR 0 2
40595: ARRAY
40596: IN
40597: NOT
40598: PUSH
40599: LD_EXP 126
40603: PUSH
40604: LD_VAR 0 2
40608: ARRAY
40609: PUSH
40610: LD_INT 3
40612: LESS
40613: AND
40614: IFFALSE 40672
// begin SetTag ( j , 121 ) ;
40616: LD_VAR 0 3
40620: PPUSH
40621: LD_INT 121
40623: PPUSH
40624: CALL_OW 109
// mc_taming := ReplaceIn ( mc_taming , [ i , mc_taming [ i ] + 1 ] , j ) ;
40628: LD_ADDR_EXP 126
40632: PUSH
40633: LD_EXP 126
40637: PPUSH
40638: LD_VAR 0 2
40642: PUSH
40643: LD_EXP 126
40647: PUSH
40648: LD_VAR 0 2
40652: ARRAY
40653: PUSH
40654: LD_INT 1
40656: PLUS
40657: PUSH
40658: EMPTY
40659: LIST
40660: LIST
40661: PPUSH
40662: LD_VAR 0 3
40666: PPUSH
40667: CALL 57012 0 3
40671: ST_TO_ADDR
// end ; if j in mc_taming [ i ] then
40672: LD_VAR 0 3
40676: PUSH
40677: LD_EXP 126
40681: PUSH
40682: LD_VAR 0 2
40686: ARRAY
40687: IN
40688: IFFALSE 40913
// begin if GetClass ( j ) <> 4 then
40690: LD_VAR 0 3
40694: PPUSH
40695: CALL_OW 257
40699: PUSH
40700: LD_INT 4
40702: NONEQUAL
40703: IFFALSE 40756
// begin mc_taming := Replace ( mc_taming , i , mc_taming [ i ] diff j ) ;
40705: LD_ADDR_EXP 126
40709: PUSH
40710: LD_EXP 126
40714: PPUSH
40715: LD_VAR 0 2
40719: PPUSH
40720: LD_EXP 126
40724: PUSH
40725: LD_VAR 0 2
40729: ARRAY
40730: PUSH
40731: LD_VAR 0 3
40735: DIFF
40736: PPUSH
40737: CALL_OW 1
40741: ST_TO_ADDR
// SetTag ( j , 0 ) ;
40742: LD_VAR 0 3
40746: PPUSH
40747: LD_INT 0
40749: PPUSH
40750: CALL_OW 109
// continue ;
40754: GO 40578
// end ; if IsInUnit ( j ) then
40756: LD_VAR 0 3
40760: PPUSH
40761: CALL_OW 310
40765: IFFALSE 40776
// ComExitBuilding ( j ) ;
40767: LD_VAR 0 3
40771: PPUSH
40772: CALL_OW 122
// ape := NearestUnitToUnit ( apes , j ) ;
40776: LD_ADDR_VAR 0 6
40780: PUSH
40781: LD_VAR 0 7
40785: PPUSH
40786: LD_VAR 0 3
40790: PPUSH
40791: CALL_OW 74
40795: ST_TO_ADDR
// if not ape then
40796: LD_VAR 0 6
40800: NOT
40801: IFFALSE 40805
// break ;
40803: GO 40915
// x := GetX ( ape ) ;
40805: LD_ADDR_VAR 0 4
40809: PUSH
40810: LD_VAR 0 6
40814: PPUSH
40815: CALL_OW 250
40819: ST_TO_ADDR
// y := GetY ( ape ) ;
40820: LD_ADDR_VAR 0 5
40824: PUSH
40825: LD_VAR 0 6
40829: PPUSH
40830: CALL_OW 251
40834: ST_TO_ADDR
// if not ValidHex ( x , y ) or DangerAtRangeXY ( side , x , y , 20 ) [ 4 ] then
40835: LD_VAR 0 4
40839: PPUSH
40840: LD_VAR 0 5
40844: PPUSH
40845: CALL_OW 488
40849: NOT
40850: PUSH
40851: LD_VAR 0 11
40855: PPUSH
40856: LD_VAR 0 4
40860: PPUSH
40861: LD_VAR 0 5
40865: PPUSH
40866: LD_INT 20
40868: PPUSH
40869: CALL 57908 0 4
40873: PUSH
40874: LD_INT 4
40876: ARRAY
40877: OR
40878: IFFALSE 40882
// break ;
40880: GO 40915
// if not HasTask ( j ) then
40882: LD_VAR 0 3
40886: PPUSH
40887: CALL_OW 314
40891: NOT
40892: IFFALSE 40913
// ComTameXY ( j , x , y ) ;
40894: LD_VAR 0 3
40898: PPUSH
40899: LD_VAR 0 4
40903: PPUSH
40904: LD_VAR 0 5
40908: PPUSH
40909: CALL_OW 131
// end ; end ;
40913: GO 40578
40915: POP
40916: POP
// end ;
40917: GO 40134
40919: POP
40920: POP
// end ;
40921: LD_VAR 0 1
40925: RET
// export function MC_ChangeApeClass ( ) ; var i , j , tmp , side , depot , selected , barracks ; begin
40926: LD_INT 0
40928: PPUSH
40929: PPUSH
40930: PPUSH
40931: PPUSH
40932: PPUSH
40933: PPUSH
40934: PPUSH
40935: PPUSH
// if not mc_bases then
40936: LD_EXP 95
40940: NOT
40941: IFFALSE 40945
// exit ;
40943: GO 41571
// for i = 1 to mc_bases do
40945: LD_ADDR_VAR 0 2
40949: PUSH
40950: DOUBLE
40951: LD_INT 1
40953: DEC
40954: ST_TO_ADDR
40955: LD_EXP 95
40959: PUSH
40960: FOR_TO
40961: IFFALSE 41569
// begin if not mc_ape [ i ] or not UnitFilter ( mc_ape [ i ] , [ f_class , 12 ] ) then
40963: LD_EXP 124
40967: PUSH
40968: LD_VAR 0 2
40972: ARRAY
40973: NOT
40974: PUSH
40975: LD_EXP 124
40979: PUSH
40980: LD_VAR 0 2
40984: ARRAY
40985: PPUSH
40986: LD_INT 25
40988: PUSH
40989: LD_INT 12
40991: PUSH
40992: EMPTY
40993: LIST
40994: LIST
40995: PPUSH
40996: CALL_OW 72
41000: NOT
41001: OR
41002: IFFALSE 41006
// continue ;
41004: GO 40960
// side := GetSide ( mc_ape [ i ] [ 1 ] ) ;
41006: LD_ADDR_VAR 0 5
41010: PUSH
41011: LD_EXP 124
41015: PUSH
41016: LD_VAR 0 2
41020: ARRAY
41021: PUSH
41022: LD_INT 1
41024: ARRAY
41025: PPUSH
41026: CALL_OW 255
41030: ST_TO_ADDR
// if Researched ( side , tech_apepsych ) then
41031: LD_VAR 0 5
41035: PPUSH
41036: LD_INT 2
41038: PPUSH
41039: CALL_OW 325
41043: IFFALSE 41296
// begin tmp := UnitFilter ( mc_ape [ i ] , [ f_class , 16 ] ) ;
41045: LD_ADDR_VAR 0 4
41049: PUSH
41050: LD_EXP 124
41054: PUSH
41055: LD_VAR 0 2
41059: ARRAY
41060: PPUSH
41061: LD_INT 25
41063: PUSH
41064: LD_INT 16
41066: PUSH
41067: EMPTY
41068: LIST
41069: LIST
41070: PPUSH
41071: CALL_OW 72
41075: ST_TO_ADDR
// if tmp < 6 then
41076: LD_VAR 0 4
41080: PUSH
41081: LD_INT 6
41083: LESS
41084: IFFALSE 41296
// begin depot := UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) ;
41086: LD_ADDR_VAR 0 6
41090: PUSH
41091: LD_EXP 95
41095: PUSH
41096: LD_VAR 0 2
41100: ARRAY
41101: PPUSH
41102: LD_INT 2
41104: PUSH
41105: LD_INT 30
41107: PUSH
41108: LD_INT 0
41110: PUSH
41111: EMPTY
41112: LIST
41113: LIST
41114: PUSH
41115: LD_INT 30
41117: PUSH
41118: LD_INT 1
41120: PUSH
41121: EMPTY
41122: LIST
41123: LIST
41124: PUSH
41125: EMPTY
41126: LIST
41127: LIST
41128: LIST
41129: PPUSH
41130: CALL_OW 72
41134: ST_TO_ADDR
// if depot then
41135: LD_VAR 0 6
41139: IFFALSE 41296
// begin selected := 0 ;
41141: LD_ADDR_VAR 0 7
41145: PUSH
41146: LD_INT 0
41148: ST_TO_ADDR
// for j in depot do
41149: LD_ADDR_VAR 0 3
41153: PUSH
41154: LD_VAR 0 6
41158: PUSH
41159: FOR_IN
41160: IFFALSE 41191
// begin if UnitsInside ( j ) < 6 then
41162: LD_VAR 0 3
41166: PPUSH
41167: CALL_OW 313
41171: PUSH
41172: LD_INT 6
41174: LESS
41175: IFFALSE 41189
// begin selected := j ;
41177: LD_ADDR_VAR 0 7
41181: PUSH
41182: LD_VAR 0 3
41186: ST_TO_ADDR
// break ;
41187: GO 41191
// end ; end ;
41189: GO 41159
41191: POP
41192: POP
// if selected then
41193: LD_VAR 0 7
41197: IFFALSE 41296
// begin for j in UnitFilter ( mc_ape [ i ] , [ f_class , 12 ] ) do
41199: LD_ADDR_VAR 0 3
41203: PUSH
41204: LD_EXP 124
41208: PUSH
41209: LD_VAR 0 2
41213: ARRAY
41214: PPUSH
41215: LD_INT 25
41217: PUSH
41218: LD_INT 12
41220: PUSH
41221: EMPTY
41222: LIST
41223: LIST
41224: PPUSH
41225: CALL_OW 72
41229: PUSH
41230: FOR_IN
41231: IFFALSE 41294
// if not HasTask ( j ) then
41233: LD_VAR 0 3
41237: PPUSH
41238: CALL_OW 314
41242: NOT
41243: IFFALSE 41292
// begin if not IsInUnit ( j ) then
41245: LD_VAR 0 3
41249: PPUSH
41250: CALL_OW 310
41254: NOT
41255: IFFALSE 41271
// ComEnterUnit ( j , selected ) ;
41257: LD_VAR 0 3
41261: PPUSH
41262: LD_VAR 0 7
41266: PPUSH
41267: CALL_OW 120
// AddComChangeProfession ( j , 16 ) ;
41271: LD_VAR 0 3
41275: PPUSH
41276: LD_INT 16
41278: PPUSH
41279: CALL_OW 183
// AddComExitBuilding ( j ) ;
41283: LD_VAR 0 3
41287: PPUSH
41288: CALL_OW 182
// end ;
41292: GO 41230
41294: POP
41295: POP
// end ; end ; end ; end ; if Researched ( side , tech_apeagres ) then
41296: LD_VAR 0 5
41300: PPUSH
41301: LD_INT 11
41303: PPUSH
41304: CALL_OW 325
41308: IFFALSE 41567
// begin tmp := UnitFilter ( mc_ape [ i ] , [ f_class , 16 ] ) ;
41310: LD_ADDR_VAR 0 4
41314: PUSH
41315: LD_EXP 124
41319: PUSH
41320: LD_VAR 0 2
41324: ARRAY
41325: PPUSH
41326: LD_INT 25
41328: PUSH
41329: LD_INT 16
41331: PUSH
41332: EMPTY
41333: LIST
41334: LIST
41335: PPUSH
41336: CALL_OW 72
41340: ST_TO_ADDR
// if tmp >= 6 or not Researched ( side , tech_apepsych ) then
41341: LD_VAR 0 4
41345: PUSH
41346: LD_INT 6
41348: GREATEREQUAL
41349: PUSH
41350: LD_VAR 0 5
41354: PPUSH
41355: LD_INT 2
41357: PPUSH
41358: CALL_OW 325
41362: NOT
41363: OR
41364: IFFALSE 41567
// begin barracks := UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_armoury ] , [ f_btype , b_barracks ] ] ) ;
41366: LD_ADDR_VAR 0 8
41370: PUSH
41371: LD_EXP 95
41375: PUSH
41376: LD_VAR 0 2
41380: ARRAY
41381: PPUSH
41382: LD_INT 2
41384: PUSH
41385: LD_INT 30
41387: PUSH
41388: LD_INT 4
41390: PUSH
41391: EMPTY
41392: LIST
41393: LIST
41394: PUSH
41395: LD_INT 30
41397: PUSH
41398: LD_INT 5
41400: PUSH
41401: EMPTY
41402: LIST
41403: LIST
41404: PUSH
41405: EMPTY
41406: LIST
41407: LIST
41408: LIST
41409: PPUSH
41410: CALL_OW 72
41414: ST_TO_ADDR
// if barracks then
41415: LD_VAR 0 8
41419: IFFALSE 41567
// begin selected := 0 ;
41421: LD_ADDR_VAR 0 7
41425: PUSH
41426: LD_INT 0
41428: ST_TO_ADDR
// for j in barracks do
41429: LD_ADDR_VAR 0 3
41433: PUSH
41434: LD_VAR 0 8
41438: PUSH
41439: FOR_IN
41440: IFFALSE 41471
// begin if UnitsInside ( j ) < 6 then
41442: LD_VAR 0 3
41446: PPUSH
41447: CALL_OW 313
41451: PUSH
41452: LD_INT 6
41454: LESS
41455: IFFALSE 41469
// begin selected := j ;
41457: LD_ADDR_VAR 0 7
41461: PUSH
41462: LD_VAR 0 3
41466: ST_TO_ADDR
// break ;
41467: GO 41471
// end ; end ;
41469: GO 41439
41471: POP
41472: POP
// if selected then
41473: LD_VAR 0 7
41477: IFFALSE 41567
// begin for j in UnitFilter ( mc_ape [ i ] , [ f_class , 12 ] ) do
41479: LD_ADDR_VAR 0 3
41483: PUSH
41484: LD_EXP 124
41488: PUSH
41489: LD_VAR 0 2
41493: ARRAY
41494: PPUSH
41495: LD_INT 25
41497: PUSH
41498: LD_INT 12
41500: PUSH
41501: EMPTY
41502: LIST
41503: LIST
41504: PPUSH
41505: CALL_OW 72
41509: PUSH
41510: FOR_IN
41511: IFFALSE 41565
// if not IsInUnit ( j ) and not HasTask ( j ) then
41513: LD_VAR 0 3
41517: PPUSH
41518: CALL_OW 310
41522: NOT
41523: PUSH
41524: LD_VAR 0 3
41528: PPUSH
41529: CALL_OW 314
41533: NOT
41534: AND
41535: IFFALSE 41563
// begin ComEnterUnit ( j , selected ) ;
41537: LD_VAR 0 3
41541: PPUSH
41542: LD_VAR 0 7
41546: PPUSH
41547: CALL_OW 120
// AddComChangeProfession ( j , 15 ) ;
41551: LD_VAR 0 3
41555: PPUSH
41556: LD_INT 15
41558: PPUSH
41559: CALL_OW 183
// end ;
41563: GO 41510
41565: POP
41566: POP
// end ; end ; end ; end ; end ;
41567: GO 40960
41569: POP
41570: POP
// end ;
41571: LD_VAR 0 1
41575: RET
// export function MC_Bazooka ( ) ; var i , j , tmp ; begin
41576: LD_INT 0
41578: PPUSH
41579: PPUSH
41580: PPUSH
41581: PPUSH
// if not mc_bases then
41582: LD_EXP 95
41586: NOT
41587: IFFALSE 41591
// exit ;
41589: GO 41769
// for i = 1 to mc_bases do
41591: LD_ADDR_VAR 0 2
41595: PUSH
41596: DOUBLE
41597: LD_INT 1
41599: DEC
41600: ST_TO_ADDR
41601: LD_EXP 95
41605: PUSH
41606: FOR_TO
41607: IFFALSE 41767
// begin tmp := UnitFilter ( mc_bases [ i ] , [ f_class , class_bazooker ] ) ;
41609: LD_ADDR_VAR 0 4
41613: PUSH
41614: LD_EXP 95
41618: PUSH
41619: LD_VAR 0 2
41623: ARRAY
41624: PPUSH
41625: LD_INT 25
41627: PUSH
41628: LD_INT 9
41630: PUSH
41631: EMPTY
41632: LIST
41633: LIST
41634: PPUSH
41635: CALL_OW 72
41639: ST_TO_ADDR
// if not tmp then
41640: LD_VAR 0 4
41644: NOT
41645: IFFALSE 41649
// continue ;
41647: GO 41606
// if not Researched ( mc_sides [ i ] , tech_spacanom ) and not Researched ( mc_sides [ i ] , tech_taurad ) then
41649: LD_EXP 121
41653: PUSH
41654: LD_VAR 0 2
41658: ARRAY
41659: PPUSH
41660: LD_INT 29
41662: PPUSH
41663: CALL_OW 325
41667: NOT
41668: PUSH
41669: LD_EXP 121
41673: PUSH
41674: LD_VAR 0 2
41678: ARRAY
41679: PPUSH
41680: LD_INT 28
41682: PPUSH
41683: CALL_OW 325
41687: NOT
41688: AND
41689: IFFALSE 41693
// continue ;
41691: GO 41606
// for j in tmp do
41693: LD_ADDR_VAR 0 3
41697: PUSH
41698: LD_VAR 0 4
41702: PUSH
41703: FOR_IN
41704: IFFALSE 41763
// if not j in mc_need_heal [ i ] [ 1 ] and not j in mc_need_heal [ i ] [ 2 ] then
41706: LD_VAR 0 3
41710: PUSH
41711: LD_EXP 98
41715: PUSH
41716: LD_VAR 0 2
41720: ARRAY
41721: PUSH
41722: LD_INT 1
41724: ARRAY
41725: IN
41726: NOT
41727: PUSH
41728: LD_VAR 0 3
41732: PUSH
41733: LD_EXP 98
41737: PUSH
41738: LD_VAR 0 2
41742: ARRAY
41743: PUSH
41744: LD_INT 2
41746: ARRAY
41747: IN
41748: NOT
41749: AND
41750: IFFALSE 41761
// ComSpaceTimeShoot ( j ) ;
41752: LD_VAR 0 3
41756: PPUSH
41757: CALL 52973 0 1
41761: GO 41703
41763: POP
41764: POP
// end ;
41765: GO 41606
41767: POP
41768: POP
// end ;
41769: LD_VAR 0 1
41773: RET
// export function MC_TeleportExit ( ) ; var i , j , x , y , save_point , tmp , teleports , sci ; begin
41774: LD_INT 0
41776: PPUSH
41777: PPUSH
41778: PPUSH
41779: PPUSH
41780: PPUSH
41781: PPUSH
41782: PPUSH
41783: PPUSH
41784: PPUSH
// if not mc_bases then
41785: LD_EXP 95
41789: NOT
41790: IFFALSE 41794
// exit ;
41792: GO 42416
// for i = 1 to mc_bases do
41794: LD_ADDR_VAR 0 2
41798: PUSH
41799: DOUBLE
41800: LD_INT 1
41802: DEC
41803: ST_TO_ADDR
41804: LD_EXP 95
41808: PUSH
41809: FOR_TO
41810: IFFALSE 42414
// begin if not mc_teleport_exit [ i ] or GetTech ( tech_targTeleport , mc_sides [ i ] ) <> state_researched then
41812: LD_EXP 130
41816: PUSH
41817: LD_VAR 0 2
41821: ARRAY
41822: NOT
41823: PUSH
41824: LD_INT 38
41826: PPUSH
41827: LD_EXP 121
41831: PUSH
41832: LD_VAR 0 2
41836: ARRAY
41837: PPUSH
41838: CALL_OW 321
41842: PUSH
41843: LD_INT 2
41845: NONEQUAL
41846: OR
41847: IFFALSE 41851
// continue ;
41849: GO 41809
// teleports := UnitFilter ( mc_bases [ i ] , [ f_btype , b_teleport ] ) ;
41851: LD_ADDR_VAR 0 8
41855: PUSH
41856: LD_EXP 95
41860: PUSH
41861: LD_VAR 0 2
41865: ARRAY
41866: PPUSH
41867: LD_INT 30
41869: PUSH
41870: LD_INT 34
41872: PUSH
41873: EMPTY
41874: LIST
41875: LIST
41876: PPUSH
41877: CALL_OW 72
41881: ST_TO_ADDR
// sci := FilterByTag ( UnitFilter ( mc_bases [ i ] , [ f_class , 4 ] ) , 0 ) ;
41882: LD_ADDR_VAR 0 9
41886: PUSH
41887: LD_EXP 95
41891: PUSH
41892: LD_VAR 0 2
41896: ARRAY
41897: PPUSH
41898: LD_INT 25
41900: PUSH
41901: LD_INT 4
41903: PUSH
41904: EMPTY
41905: LIST
41906: LIST
41907: PPUSH
41908: CALL_OW 72
41912: PPUSH
41913: LD_INT 0
41915: PPUSH
41916: CALL 86281 0 2
41920: ST_TO_ADDR
// if not sci or not teleports or FilterByTag ( mc_bases [ i ] , 124 ) then
41921: LD_VAR 0 9
41925: NOT
41926: PUSH
41927: LD_VAR 0 8
41931: NOT
41932: OR
41933: PUSH
41934: LD_EXP 95
41938: PUSH
41939: LD_VAR 0 2
41943: ARRAY
41944: PPUSH
41945: LD_INT 124
41947: PPUSH
41948: CALL 86281 0 2
41952: OR
41953: IFFALSE 41957
// continue ;
41955: GO 41809
// if mc_teleport_exit_set [ i ] < mc_teleport_exit [ i ] and mc_teleport_exit_set [ i ] < teleports then
41957: LD_EXP 131
41961: PUSH
41962: LD_VAR 0 2
41966: ARRAY
41967: PUSH
41968: LD_EXP 130
41972: PUSH
41973: LD_VAR 0 2
41977: ARRAY
41978: LESS
41979: PUSH
41980: LD_EXP 131
41984: PUSH
41985: LD_VAR 0 2
41989: ARRAY
41990: PUSH
41991: LD_VAR 0 8
41995: LESS
41996: AND
41997: IFFALSE 42412
// begin tmp := sci [ 1 ] ;
41999: LD_ADDR_VAR 0 7
42003: PUSH
42004: LD_VAR 0 9
42008: PUSH
42009: LD_INT 1
42011: ARRAY
42012: ST_TO_ADDR
// SetTag ( tmp , 124 ) ;
42013: LD_VAR 0 7
42017: PPUSH
42018: LD_INT 124
42020: PPUSH
42021: CALL_OW 109
// for j = mc_teleport_exit [ i ] downto mc_teleport_exit [ i ] do
42025: LD_ADDR_VAR 0 3
42029: PUSH
42030: DOUBLE
42031: LD_EXP 130
42035: PUSH
42036: LD_VAR 0 2
42040: ARRAY
42041: INC
42042: ST_TO_ADDR
42043: LD_EXP 130
42047: PUSH
42048: LD_VAR 0 2
42052: ARRAY
42053: PUSH
42054: FOR_DOWNTO
42055: IFFALSE 42398
// begin if IsInUnit ( tmp ) then
42057: LD_VAR 0 7
42061: PPUSH
42062: CALL_OW 310
42066: IFFALSE 42077
// ComExitBuilding ( tmp ) ;
42068: LD_VAR 0 7
42072: PPUSH
42073: CALL_OW 122
// repeat wait ( 0 0$1 ) ;
42077: LD_INT 35
42079: PPUSH
42080: CALL_OW 67
// until not IsInUnit ( tmp ) and not HasTask ( tmp ) ;
42084: LD_VAR 0 7
42088: PPUSH
42089: CALL_OW 310
42093: NOT
42094: PUSH
42095: LD_VAR 0 7
42099: PPUSH
42100: CALL_OW 314
42104: NOT
42105: AND
42106: IFFALSE 42077
// save_point := [ GetX ( tmp ) , GetY ( tmp ) ] ;
42108: LD_ADDR_VAR 0 6
42112: PUSH
42113: LD_VAR 0 7
42117: PPUSH
42118: CALL_OW 250
42122: PUSH
42123: LD_VAR 0 7
42127: PPUSH
42128: CALL_OW 251
42132: PUSH
42133: EMPTY
42134: LIST
42135: LIST
42136: ST_TO_ADDR
// repeat wait ( 0 0$1 ) ;
42137: LD_INT 35
42139: PPUSH
42140: CALL_OW 67
// x := mc_teleport_exit [ i ] [ j ] [ 1 ] ;
42144: LD_ADDR_VAR 0 4
42148: PUSH
42149: LD_EXP 130
42153: PUSH
42154: LD_VAR 0 2
42158: ARRAY
42159: PUSH
42160: LD_VAR 0 3
42164: ARRAY
42165: PUSH
42166: LD_INT 1
42168: ARRAY
42169: ST_TO_ADDR
// y := mc_teleport_exit [ i ] [ j ] [ 2 ] ;
42170: LD_ADDR_VAR 0 5
42174: PUSH
42175: LD_EXP 130
42179: PUSH
42180: LD_VAR 0 2
42184: ARRAY
42185: PUSH
42186: LD_VAR 0 3
42190: ARRAY
42191: PUSH
42192: LD_INT 2
42194: ARRAY
42195: ST_TO_ADDR
// if DangerAtRange ( tmp , 10 ) [ 4 ] then
42196: LD_VAR 0 7
42200: PPUSH
42201: LD_INT 10
42203: PPUSH
42204: CALL 59611 0 2
42208: PUSH
42209: LD_INT 4
42211: ARRAY
42212: IFFALSE 42250
// begin ComMoveXY ( tmp , save_point [ 1 ] , save_point [ 2 ] ) ;
42214: LD_VAR 0 7
42218: PPUSH
42219: LD_VAR 0 6
42223: PUSH
42224: LD_INT 1
42226: ARRAY
42227: PPUSH
42228: LD_VAR 0 6
42232: PUSH
42233: LD_INT 2
42235: ARRAY
42236: PPUSH
42237: CALL_OW 111
// wait ( 0 0$10 ) ;
42241: LD_INT 350
42243: PPUSH
42244: CALL_OW 67
// end else
42248: GO 42276
// begin ComMoveXY ( tmp , x , y ) ;
42250: LD_VAR 0 7
42254: PPUSH
42255: LD_VAR 0 4
42259: PPUSH
42260: LD_VAR 0 5
42264: PPUSH
42265: CALL_OW 111
// wait ( 0 0$3 ) ;
42269: LD_INT 105
42271: PPUSH
42272: CALL_OW 67
// end ; until IsAt ( tmp , x , y ) ;
42276: LD_VAR 0 7
42280: PPUSH
42281: LD_VAR 0 4
42285: PPUSH
42286: LD_VAR 0 5
42290: PPUSH
42291: CALL_OW 307
42295: IFFALSE 42137
// ComTeleportExit ( tmp , x , y , teleports [ j ] ) ;
42297: LD_VAR 0 7
42301: PPUSH
42302: LD_VAR 0 4
42306: PPUSH
42307: LD_VAR 0 5
42311: PPUSH
42312: LD_VAR 0 8
42316: PUSH
42317: LD_VAR 0 3
42321: ARRAY
42322: PPUSH
42323: CALL_OW 156
// repeat wait ( 0 0$1 ) ;
42327: LD_INT 35
42329: PPUSH
42330: CALL_OW 67
// until not HasTask ( tmp ) ;
42334: LD_VAR 0 7
42338: PPUSH
42339: CALL_OW 314
42343: NOT
42344: IFFALSE 42327
// mc_teleport_exit_set := ReplaceIn ( mc_teleport_exit_set , [ i , mc_teleport_exit_set [ i ] + 1 ] , teleports [ j ] ) ;
42346: LD_ADDR_EXP 131
42350: PUSH
42351: LD_EXP 131
42355: PPUSH
42356: LD_VAR 0 2
42360: PUSH
42361: LD_EXP 131
42365: PUSH
42366: LD_VAR 0 2
42370: ARRAY
42371: PUSH
42372: LD_INT 1
42374: PLUS
42375: PUSH
42376: EMPTY
42377: LIST
42378: LIST
42379: PPUSH
42380: LD_VAR 0 8
42384: PUSH
42385: LD_VAR 0 3
42389: ARRAY
42390: PPUSH
42391: CALL 57012 0 3
42395: ST_TO_ADDR
// end ;
42396: GO 42054
42398: POP
42399: POP
// MC_Reset ( i , 124 ) ;
42400: LD_VAR 0 2
42404: PPUSH
42405: LD_INT 124
42407: PPUSH
42408: CALL 25554 0 2
// end ; end ;
42412: GO 41809
42414: POP
42415: POP
// end ;
42416: LD_VAR 0 1
42420: RET
// export function MC_Deposits ( ) ; var i , tmp ; begin
42421: LD_INT 0
42423: PPUSH
42424: PPUSH
42425: PPUSH
// if not mc_bases then
42426: LD_EXP 95
42430: NOT
42431: IFFALSE 42435
// exit ;
42433: GO 43041
// for i = 1 to mc_bases do
42435: LD_ADDR_VAR 0 2
42439: PUSH
42440: DOUBLE
42441: LD_INT 1
42443: DEC
42444: ST_TO_ADDR
42445: LD_EXP 95
42449: PUSH
42450: FOR_TO
42451: IFFALSE 43039
// begin tmp := UnitFilter ( mc_bases [ i ] , [ f_class , 4 ] ) ;
42453: LD_ADDR_VAR 0 3
42457: PUSH
42458: LD_EXP 95
42462: PUSH
42463: LD_VAR 0 2
42467: ARRAY
42468: PPUSH
42469: LD_INT 25
42471: PUSH
42472: LD_INT 4
42474: PUSH
42475: EMPTY
42476: LIST
42477: LIST
42478: PPUSH
42479: CALL_OW 72
42483: ST_TO_ADDR
// if not tmp or not mc_deposits_xy [ i ] or not UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) then
42484: LD_VAR 0 3
42488: NOT
42489: PUSH
42490: LD_EXP 132
42494: PUSH
42495: LD_VAR 0 2
42499: ARRAY
42500: NOT
42501: OR
42502: PUSH
42503: LD_EXP 95
42507: PUSH
42508: LD_VAR 0 2
42512: ARRAY
42513: PPUSH
42514: LD_INT 2
42516: PUSH
42517: LD_INT 30
42519: PUSH
42520: LD_INT 0
42522: PUSH
42523: EMPTY
42524: LIST
42525: LIST
42526: PUSH
42527: LD_INT 30
42529: PUSH
42530: LD_INT 1
42532: PUSH
42533: EMPTY
42534: LIST
42535: LIST
42536: PUSH
42537: EMPTY
42538: LIST
42539: LIST
42540: LIST
42541: PPUSH
42542: CALL_OW 72
42546: NOT
42547: OR
42548: IFFALSE 42598
// begin if mc_deposits_finder [ i ] then
42550: LD_EXP 133
42554: PUSH
42555: LD_VAR 0 2
42559: ARRAY
42560: IFFALSE 42596
// begin MC_Reset ( i , 125 ) ;
42562: LD_VAR 0 2
42566: PPUSH
42567: LD_INT 125
42569: PPUSH
42570: CALL 25554 0 2
// mc_deposits_finder := Replace ( mc_deposits_finder , i , [ ] ) ;
42574: LD_ADDR_EXP 133
42578: PUSH
42579: LD_EXP 133
42583: PPUSH
42584: LD_VAR 0 2
42588: PPUSH
42589: EMPTY
42590: PPUSH
42591: CALL_OW 1
42595: ST_TO_ADDR
// end ; continue ;
42596: GO 42450
// end ; if mc_deposits_xy [ i ] [ 1 ] [ 3 ] = 1 and GetTech ( tech_sibdet , mc_sides [ i ] ) <> state_researched then
42598: LD_EXP 132
42602: PUSH
42603: LD_VAR 0 2
42607: ARRAY
42608: PUSH
42609: LD_INT 1
42611: ARRAY
42612: PUSH
42613: LD_INT 3
42615: ARRAY
42616: PUSH
42617: LD_INT 1
42619: EQUAL
42620: PUSH
42621: LD_INT 20
42623: PPUSH
42624: LD_EXP 121
42628: PUSH
42629: LD_VAR 0 2
42633: ARRAY
42634: PPUSH
42635: CALL_OW 321
42639: PUSH
42640: LD_INT 2
42642: NONEQUAL
42643: AND
42644: IFFALSE 42694
// begin if mc_deposits_finder [ i ] then
42646: LD_EXP 133
42650: PUSH
42651: LD_VAR 0 2
42655: ARRAY
42656: IFFALSE 42692
// begin MC_Reset ( i , 125 ) ;
42658: LD_VAR 0 2
42662: PPUSH
42663: LD_INT 125
42665: PPUSH
42666: CALL 25554 0 2
// mc_deposits_finder := Replace ( mc_deposits_finder , i , [ ] ) ;
42670: LD_ADDR_EXP 133
42674: PUSH
42675: LD_EXP 133
42679: PPUSH
42680: LD_VAR 0 2
42684: PPUSH
42685: EMPTY
42686: PPUSH
42687: CALL_OW 1
42691: ST_TO_ADDR
// end ; continue ;
42692: GO 42450
// end ; if GetResourceVisibility ( mc_deposits_xy [ i ] [ 1 ] [ 1 ] , mc_deposits_xy [ i ] [ 1 ] [ 2 ] , mc_sides [ i ] ) then
42694: LD_EXP 132
42698: PUSH
42699: LD_VAR 0 2
42703: ARRAY
42704: PUSH
42705: LD_INT 1
42707: ARRAY
42708: PUSH
42709: LD_INT 1
42711: ARRAY
42712: PPUSH
42713: LD_EXP 132
42717: PUSH
42718: LD_VAR 0 2
42722: ARRAY
42723: PUSH
42724: LD_INT 1
42726: ARRAY
42727: PUSH
42728: LD_INT 2
42730: ARRAY
42731: PPUSH
42732: LD_EXP 121
42736: PUSH
42737: LD_VAR 0 2
42741: ARRAY
42742: PPUSH
42743: CALL_OW 440
42747: IFFALSE 42790
// mc_deposits_xy := Replace ( mc_deposits_xy , i , Delete ( mc_deposits_xy [ i ] , 1 ) ) else
42749: LD_ADDR_EXP 132
42753: PUSH
42754: LD_EXP 132
42758: PPUSH
42759: LD_VAR 0 2
42763: PPUSH
42764: LD_EXP 132
42768: PUSH
42769: LD_VAR 0 2
42773: ARRAY
42774: PPUSH
42775: LD_INT 1
42777: PPUSH
42778: CALL_OW 3
42782: PPUSH
42783: CALL_OW 1
42787: ST_TO_ADDR
42788: GO 43037
// begin if not mc_deposits_finder [ i ] then
42790: LD_EXP 133
42794: PUSH
42795: LD_VAR 0 2
42799: ARRAY
42800: NOT
42801: IFFALSE 42853
// begin mc_deposits_finder := Replace ( mc_deposits_finder , i , [ tmp [ 1 ] ] ) ;
42803: LD_ADDR_EXP 133
42807: PUSH
42808: LD_EXP 133
42812: PPUSH
42813: LD_VAR 0 2
42817: PPUSH
42818: LD_VAR 0 3
42822: PUSH
42823: LD_INT 1
42825: ARRAY
42826: PUSH
42827: EMPTY
42828: LIST
42829: PPUSH
42830: CALL_OW 1
42834: ST_TO_ADDR
// SetTag ( tmp [ 1 ] , 125 ) ;
42835: LD_VAR 0 3
42839: PUSH
42840: LD_INT 1
42842: ARRAY
42843: PPUSH
42844: LD_INT 125
42846: PPUSH
42847: CALL_OW 109
// end else
42851: GO 43037
// begin if IsInUnit ( mc_deposits_finder [ i ] [ 1 ] ) then
42853: LD_EXP 133
42857: PUSH
42858: LD_VAR 0 2
42862: ARRAY
42863: PUSH
42864: LD_INT 1
42866: ARRAY
42867: PPUSH
42868: CALL_OW 310
42872: IFFALSE 42895
// ComExitBuilding ( mc_deposits_finder [ i ] [ 1 ] ) else
42874: LD_EXP 133
42878: PUSH
42879: LD_VAR 0 2
42883: ARRAY
42884: PUSH
42885: LD_INT 1
42887: ARRAY
42888: PPUSH
42889: CALL_OW 122
42893: GO 43037
// if not HasTask ( mc_deposits_finder [ i ] [ 1 ] ) and GetDistUnitXY ( mc_deposits_finder [ i ] [ 1 ] , mc_deposits_xy [ i ] [ 1 ] [ 1 ] , mc_deposits_xy [ i ] [ 1 ] [ 2 ] ) > 6 then
42895: LD_EXP 133
42899: PUSH
42900: LD_VAR 0 2
42904: ARRAY
42905: PUSH
42906: LD_INT 1
42908: ARRAY
42909: PPUSH
42910: CALL_OW 314
42914: NOT
42915: PUSH
42916: LD_EXP 133
42920: PUSH
42921: LD_VAR 0 2
42925: ARRAY
42926: PUSH
42927: LD_INT 1
42929: ARRAY
42930: PPUSH
42931: LD_EXP 132
42935: PUSH
42936: LD_VAR 0 2
42940: ARRAY
42941: PUSH
42942: LD_INT 1
42944: ARRAY
42945: PUSH
42946: LD_INT 1
42948: ARRAY
42949: PPUSH
42950: LD_EXP 132
42954: PUSH
42955: LD_VAR 0 2
42959: ARRAY
42960: PUSH
42961: LD_INT 1
42963: ARRAY
42964: PUSH
42965: LD_INT 2
42967: ARRAY
42968: PPUSH
42969: CALL_OW 297
42973: PUSH
42974: LD_INT 6
42976: GREATER
42977: AND
42978: IFFALSE 43037
// ComMoveXY ( mc_deposits_finder [ i ] [ 1 ] , mc_deposits_xy [ i ] [ 1 ] [ 1 ] , mc_deposits_xy [ i ] [ 1 ] [ 2 ] ) ;
42980: LD_EXP 133
42984: PUSH
42985: LD_VAR 0 2
42989: ARRAY
42990: PUSH
42991: LD_INT 1
42993: ARRAY
42994: PPUSH
42995: LD_EXP 132
42999: PUSH
43000: LD_VAR 0 2
43004: ARRAY
43005: PUSH
43006: LD_INT 1
43008: ARRAY
43009: PUSH
43010: LD_INT 1
43012: ARRAY
43013: PPUSH
43014: LD_EXP 132
43018: PUSH
43019: LD_VAR 0 2
43023: ARRAY
43024: PUSH
43025: LD_INT 1
43027: ARRAY
43028: PUSH
43029: LD_INT 2
43031: ARRAY
43032: PPUSH
43033: CALL_OW 111
// end ; end ; end ;
43037: GO 42450
43039: POP
43040: POP
// end ;
43041: LD_VAR 0 1
43045: RET
// export function MC_RemoteDriver ( ) ; var i , j , k , places , tmp , nation , ct , cts , mcts , x ; begin
43046: LD_INT 0
43048: PPUSH
43049: PPUSH
43050: PPUSH
43051: PPUSH
43052: PPUSH
43053: PPUSH
43054: PPUSH
43055: PPUSH
43056: PPUSH
43057: PPUSH
43058: PPUSH
// if not mc_bases then
43059: LD_EXP 95
43063: NOT
43064: IFFALSE 43068
// exit ;
43066: GO 44008
// for i = 1 to mc_bases do
43068: LD_ADDR_VAR 0 2
43072: PUSH
43073: DOUBLE
43074: LD_INT 1
43076: DEC
43077: ST_TO_ADDR
43078: LD_EXP 95
43082: PUSH
43083: FOR_TO
43084: IFFALSE 44006
// begin if not mc_bases [ i ] or mc_scan [ i ] then
43086: LD_EXP 95
43090: PUSH
43091: LD_VAR 0 2
43095: ARRAY
43096: NOT
43097: PUSH
43098: LD_EXP 118
43102: PUSH
43103: LD_VAR 0 2
43107: ARRAY
43108: OR
43109: IFFALSE 43113
// continue ;
43111: GO 43083
// nation := GetNation ( mc_bases [ i ] [ 1 ] ) ;
43113: LD_ADDR_VAR 0 7
43117: PUSH
43118: LD_EXP 95
43122: PUSH
43123: LD_VAR 0 2
43127: ARRAY
43128: PUSH
43129: LD_INT 1
43131: ARRAY
43132: PPUSH
43133: CALL_OW 248
43137: ST_TO_ADDR
// if nation = 3 or not UnitFilter ( mc_vehicles [ i ] union mc_defender [ i ] , [ f_control , control_remote ] ) then
43138: LD_VAR 0 7
43142: PUSH
43143: LD_INT 3
43145: EQUAL
43146: PUSH
43147: LD_EXP 114
43151: PUSH
43152: LD_VAR 0 2
43156: ARRAY
43157: PUSH
43158: LD_EXP 117
43162: PUSH
43163: LD_VAR 0 2
43167: ARRAY
43168: UNION
43169: PPUSH
43170: LD_INT 33
43172: PUSH
43173: LD_INT 2
43175: PUSH
43176: EMPTY
43177: LIST
43178: LIST
43179: PPUSH
43180: CALL_OW 72
43184: NOT
43185: OR
43186: IFFALSE 43190
// continue ;
43188: GO 43083
// cts := UnitFilter ( mc_bases [ i ] , [ f_btype , b_control_tower ] ) ;
43190: LD_ADDR_VAR 0 9
43194: PUSH
43195: LD_EXP 95
43199: PUSH
43200: LD_VAR 0 2
43204: ARRAY
43205: PPUSH
43206: LD_INT 30
43208: PUSH
43209: LD_INT 36
43211: PUSH
43212: EMPTY
43213: LIST
43214: LIST
43215: PPUSH
43216: CALL_OW 72
43220: ST_TO_ADDR
// mcts := UnitFilter ( mc_vehicles [ i ] , [ f_weapon , ar_control_tower ] ) ;
43221: LD_ADDR_VAR 0 10
43225: PUSH
43226: LD_EXP 114
43230: PUSH
43231: LD_VAR 0 2
43235: ARRAY
43236: PPUSH
43237: LD_INT 34
43239: PUSH
43240: LD_INT 31
43242: PUSH
43243: EMPTY
43244: LIST
43245: LIST
43246: PPUSH
43247: CALL_OW 72
43251: ST_TO_ADDR
// if not cts and not mcts then
43252: LD_VAR 0 9
43256: NOT
43257: PUSH
43258: LD_VAR 0 10
43262: NOT
43263: AND
43264: IFFALSE 43268
// continue ;
43266: GO 43083
// x := cts ;
43268: LD_ADDR_VAR 0 11
43272: PUSH
43273: LD_VAR 0 9
43277: ST_TO_ADDR
// if not x then
43278: LD_VAR 0 11
43282: NOT
43283: IFFALSE 43295
// x := mcts ;
43285: LD_ADDR_VAR 0 11
43289: PUSH
43290: LD_VAR 0 10
43294: ST_TO_ADDR
// if not x then
43295: LD_VAR 0 11
43299: NOT
43300: IFFALSE 43304
// continue ;
43302: GO 43083
// if mc_remote_driver [ i ] then
43304: LD_EXP 135
43308: PUSH
43309: LD_VAR 0 2
43313: ARRAY
43314: IFFALSE 43701
// for j in mc_remote_driver [ i ] do
43316: LD_ADDR_VAR 0 3
43320: PUSH
43321: LD_EXP 135
43325: PUSH
43326: LD_VAR 0 2
43330: ARRAY
43331: PUSH
43332: FOR_IN
43333: IFFALSE 43699
// begin if GetClass ( j ) <> 3 then
43335: LD_VAR 0 3
43339: PPUSH
43340: CALL_OW 257
43344: PUSH
43345: LD_INT 3
43347: NONEQUAL
43348: IFFALSE 43401
// begin mc_remote_driver := Replace ( mc_remote_driver , i , mc_remote_driver [ i ] diff j ) ;
43350: LD_ADDR_EXP 135
43354: PUSH
43355: LD_EXP 135
43359: PPUSH
43360: LD_VAR 0 2
43364: PPUSH
43365: LD_EXP 135
43369: PUSH
43370: LD_VAR 0 2
43374: ARRAY
43375: PUSH
43376: LD_VAR 0 3
43380: DIFF
43381: PPUSH
43382: CALL_OW 1
43386: ST_TO_ADDR
// SetTag ( j , 0 ) ;
43387: LD_VAR 0 3
43391: PPUSH
43392: LD_INT 0
43394: PPUSH
43395: CALL_OW 109
// continue ;
43399: GO 43332
// end ; if UnitFilter ( mc_vehicles [ i ] , [ [ f_weapon , ar_control_tower ] , [ f_empty ] ] ) and not IsDriver ( j ) then
43401: LD_EXP 114
43405: PUSH
43406: LD_VAR 0 2
43410: ARRAY
43411: PPUSH
43412: LD_INT 34
43414: PUSH
43415: LD_INT 31
43417: PUSH
43418: EMPTY
43419: LIST
43420: LIST
43421: PUSH
43422: LD_INT 58
43424: PUSH
43425: EMPTY
43426: LIST
43427: PUSH
43428: EMPTY
43429: LIST
43430: LIST
43431: PPUSH
43432: CALL_OW 72
43436: PUSH
43437: LD_VAR 0 3
43441: PPUSH
43442: CALL 86369 0 1
43446: NOT
43447: AND
43448: IFFALSE 43519
// begin if IsInUnit ( j ) then
43450: LD_VAR 0 3
43454: PPUSH
43455: CALL_OW 310
43459: IFFALSE 43470
// ComExitBuilding ( j ) ;
43461: LD_VAR 0 3
43465: PPUSH
43466: CALL_OW 122
// AddComEnterUnit ( j , UnitFilter ( mc_vehicles [ i ] , [ [ f_weapon , ar_control_tower ] , [ f_empty ] ] ) [ 1 ] ) ;
43470: LD_VAR 0 3
43474: PPUSH
43475: LD_EXP 114
43479: PUSH
43480: LD_VAR 0 2
43484: ARRAY
43485: PPUSH
43486: LD_INT 34
43488: PUSH
43489: LD_INT 31
43491: PUSH
43492: EMPTY
43493: LIST
43494: LIST
43495: PUSH
43496: LD_INT 58
43498: PUSH
43499: EMPTY
43500: LIST
43501: PUSH
43502: EMPTY
43503: LIST
43504: LIST
43505: PPUSH
43506: CALL_OW 72
43510: PUSH
43511: LD_INT 1
43513: ARRAY
43514: PPUSH
43515: CALL_OW 180
// end ; if not IsInUnit ( j ) or ( GetBType ( IsInUnit ( j ) ) <> b_control_tower and not IsDriver ( j ) ) then
43519: LD_VAR 0 3
43523: PPUSH
43524: CALL_OW 310
43528: NOT
43529: PUSH
43530: LD_VAR 0 3
43534: PPUSH
43535: CALL_OW 310
43539: PPUSH
43540: CALL_OW 266
43544: PUSH
43545: LD_INT 36
43547: NONEQUAL
43548: PUSH
43549: LD_VAR 0 3
43553: PPUSH
43554: CALL 86369 0 1
43558: NOT
43559: AND
43560: OR
43561: IFFALSE 43697
// begin if IsInUnit ( j ) then
43563: LD_VAR 0 3
43567: PPUSH
43568: CALL_OW 310
43572: IFFALSE 43583
// ComExitBuilding ( j ) ;
43574: LD_VAR 0 3
43578: PPUSH
43579: CALL_OW 122
// ct := 0 ;
43583: LD_ADDR_VAR 0 8
43587: PUSH
43588: LD_INT 0
43590: ST_TO_ADDR
// for k in x do
43591: LD_ADDR_VAR 0 4
43595: PUSH
43596: LD_VAR 0 11
43600: PUSH
43601: FOR_IN
43602: IFFALSE 43675
// if ( GetWeapon ( k ) = ar_control_tower and not IsDrivenBy ( k ) ) or ( GetBType ( k ) = b_control_tower and UnitsInside ( k ) < 3 ) then
43604: LD_VAR 0 4
43608: PPUSH
43609: CALL_OW 264
43613: PUSH
43614: LD_INT 31
43616: EQUAL
43617: PUSH
43618: LD_VAR 0 4
43622: PPUSH
43623: CALL_OW 311
43627: NOT
43628: AND
43629: PUSH
43630: LD_VAR 0 4
43634: PPUSH
43635: CALL_OW 266
43639: PUSH
43640: LD_INT 36
43642: EQUAL
43643: PUSH
43644: LD_VAR 0 4
43648: PPUSH
43649: CALL_OW 313
43653: PUSH
43654: LD_INT 3
43656: LESS
43657: AND
43658: OR
43659: IFFALSE 43673
// begin ct := k ;
43661: LD_ADDR_VAR 0 8
43665: PUSH
43666: LD_VAR 0 4
43670: ST_TO_ADDR
// break ;
43671: GO 43675
// end ;
43673: GO 43601
43675: POP
43676: POP
// if ct then
43677: LD_VAR 0 8
43681: IFFALSE 43697
// ComEnterUnit ( j , ct ) ;
43683: LD_VAR 0 3
43687: PPUSH
43688: LD_VAR 0 8
43692: PPUSH
43693: CALL_OW 120
// end ; end ;
43697: GO 43332
43699: POP
43700: POP
// places := 0 ;
43701: LD_ADDR_VAR 0 5
43705: PUSH
43706: LD_INT 0
43708: ST_TO_ADDR
// for j = 1 to x do
43709: LD_ADDR_VAR 0 3
43713: PUSH
43714: DOUBLE
43715: LD_INT 1
43717: DEC
43718: ST_TO_ADDR
43719: LD_VAR 0 11
43723: PUSH
43724: FOR_TO
43725: IFFALSE 43801
// if GetWeapon ( x [ j ] ) = ar_control_tower then
43727: LD_VAR 0 11
43731: PUSH
43732: LD_VAR 0 3
43736: ARRAY
43737: PPUSH
43738: CALL_OW 264
43742: PUSH
43743: LD_INT 31
43745: EQUAL
43746: IFFALSE 43764
// places := places + 1 else
43748: LD_ADDR_VAR 0 5
43752: PUSH
43753: LD_VAR 0 5
43757: PUSH
43758: LD_INT 1
43760: PLUS
43761: ST_TO_ADDR
43762: GO 43799
// if GetBType ( x [ j ] ) = b_control_tower then
43764: LD_VAR 0 11
43768: PUSH
43769: LD_VAR 0 3
43773: ARRAY
43774: PPUSH
43775: CALL_OW 266
43779: PUSH
43780: LD_INT 36
43782: EQUAL
43783: IFFALSE 43799
// places := places + 3 ;
43785: LD_ADDR_VAR 0 5
43789: PUSH
43790: LD_VAR 0 5
43794: PUSH
43795: LD_INT 3
43797: PLUS
43798: ST_TO_ADDR
43799: GO 43724
43801: POP
43802: POP
// if places = 0 or places <= mc_remote_driver [ i ] then
43803: LD_VAR 0 5
43807: PUSH
43808: LD_INT 0
43810: EQUAL
43811: PUSH
43812: LD_VAR 0 5
43816: PUSH
43817: LD_EXP 135
43821: PUSH
43822: LD_VAR 0 2
43826: ARRAY
43827: LESSEQUAL
43828: OR
43829: IFFALSE 43833
// continue ;
43831: GO 43083
// tmp := SortBySkill ( UnitFilter ( mc_bases [ i ] , [ f_class , 3 ] ) diff mc_remote_driver [ i ] , 3 ) ;
43833: LD_ADDR_VAR 0 6
43837: PUSH
43838: LD_EXP 95
43842: PUSH
43843: LD_VAR 0 2
43847: ARRAY
43848: PPUSH
43849: LD_INT 25
43851: PUSH
43852: LD_INT 3
43854: PUSH
43855: EMPTY
43856: LIST
43857: LIST
43858: PPUSH
43859: CALL_OW 72
43863: PUSH
43864: LD_EXP 135
43868: PUSH
43869: LD_VAR 0 2
43873: ARRAY
43874: DIFF
43875: PPUSH
43876: LD_INT 3
43878: PPUSH
43879: CALL 87269 0 2
43883: ST_TO_ADDR
// for j in tmp do
43884: LD_ADDR_VAR 0 3
43888: PUSH
43889: LD_VAR 0 6
43893: PUSH
43894: FOR_IN
43895: IFFALSE 43930
// if GetTag ( j ) > 0 then
43897: LD_VAR 0 3
43901: PPUSH
43902: CALL_OW 110
43906: PUSH
43907: LD_INT 0
43909: GREATER
43910: IFFALSE 43928
// tmp := tmp diff j ;
43912: LD_ADDR_VAR 0 6
43916: PUSH
43917: LD_VAR 0 6
43921: PUSH
43922: LD_VAR 0 3
43926: DIFF
43927: ST_TO_ADDR
43928: GO 43894
43930: POP
43931: POP
// if not tmp then
43932: LD_VAR 0 6
43936: NOT
43937: IFFALSE 43941
// continue ;
43939: GO 43083
// if places then
43941: LD_VAR 0 5
43945: IFFALSE 44004
// begin mc_remote_driver := Replace ( mc_remote_driver , i , mc_remote_driver [ i ] union tmp [ 1 ] ) ;
43947: LD_ADDR_EXP 135
43951: PUSH
43952: LD_EXP 135
43956: PPUSH
43957: LD_VAR 0 2
43961: PPUSH
43962: LD_EXP 135
43966: PUSH
43967: LD_VAR 0 2
43971: ARRAY
43972: PUSH
43973: LD_VAR 0 6
43977: PUSH
43978: LD_INT 1
43980: ARRAY
43981: UNION
43982: PPUSH
43983: CALL_OW 1
43987: ST_TO_ADDR
// SetTag ( tmp [ 1 ] , 126 ) ;
43988: LD_VAR 0 6
43992: PUSH
43993: LD_INT 1
43995: ARRAY
43996: PPUSH
43997: LD_INT 126
43999: PPUSH
44000: CALL_OW 109
// end ; end ;
44004: GO 43083
44006: POP
44007: POP
// end ;
44008: LD_VAR 0 1
44012: RET
// export function MC_Back ( base , base_unit_list , unit , class ) ; var i , j , tmp , x , depot ; begin
44013: LD_INT 0
44015: PPUSH
44016: PPUSH
44017: PPUSH
44018: PPUSH
44019: PPUSH
44020: PPUSH
// if not base or not base_unit_list or not unit or not class in [ 1 , 2 , 3 , 4 , 5 , 8 , 9 , 15 , 16 ] then
44021: LD_VAR 0 1
44025: NOT
44026: PUSH
44027: LD_VAR 0 2
44031: NOT
44032: OR
44033: PUSH
44034: LD_VAR 0 3
44038: NOT
44039: OR
44040: PUSH
44041: LD_VAR 0 4
44045: PUSH
44046: LD_INT 1
44048: PUSH
44049: LD_INT 2
44051: PUSH
44052: LD_INT 3
44054: PUSH
44055: LD_INT 4
44057: PUSH
44058: LD_INT 5
44060: PUSH
44061: LD_INT 8
44063: PUSH
44064: LD_INT 9
44066: PUSH
44067: LD_INT 15
44069: PUSH
44070: LD_INT 16
44072: PUSH
44073: EMPTY
44074: LIST
44075: LIST
44076: LIST
44077: LIST
44078: LIST
44079: LIST
44080: LIST
44081: LIST
44082: LIST
44083: IN
44084: NOT
44085: OR
44086: IFFALSE 44090
// exit ;
44088: GO 44990
// base_unit_list := UnitFilter ( base_unit_list , [ [ f_type , unit_building ] , [ f_lives , 250 ] ] ) ;
44090: LD_ADDR_VAR 0 2
44094: PUSH
44095: LD_VAR 0 2
44099: PPUSH
44100: LD_INT 21
44102: PUSH
44103: LD_INT 3
44105: PUSH
44106: EMPTY
44107: LIST
44108: LIST
44109: PUSH
44110: LD_INT 24
44112: PUSH
44113: LD_INT 250
44115: PUSH
44116: EMPTY
44117: LIST
44118: LIST
44119: PUSH
44120: EMPTY
44121: LIST
44122: LIST
44123: PPUSH
44124: CALL_OW 72
44128: ST_TO_ADDR
// case class of 1 , 15 :
44129: LD_VAR 0 4
44133: PUSH
44134: LD_INT 1
44136: DOUBLE
44137: EQUAL
44138: IFTRUE 44148
44140: LD_INT 15
44142: DOUBLE
44143: EQUAL
44144: IFTRUE 44148
44146: GO 44233
44148: POP
// tmp := UnitFilter ( base_unit_list , [ f_or , [ f_btype , b_bunker ] , [ f_btype , b_breastwork ] ] ) ^ UnitFilter ( base_unit_list , [ f_or , [ f_btype , b_armoury ] , [ f_btype , b_barracks ] ] ) ; 2 , 16 :
44149: LD_ADDR_VAR 0 8
44153: PUSH
44154: LD_VAR 0 2
44158: PPUSH
44159: LD_INT 2
44161: PUSH
44162: LD_INT 30
44164: PUSH
44165: LD_INT 32
44167: PUSH
44168: EMPTY
44169: LIST
44170: LIST
44171: PUSH
44172: LD_INT 30
44174: PUSH
44175: LD_INT 31
44177: PUSH
44178: EMPTY
44179: LIST
44180: LIST
44181: PUSH
44182: EMPTY
44183: LIST
44184: LIST
44185: LIST
44186: PPUSH
44187: CALL_OW 72
44191: PUSH
44192: LD_VAR 0 2
44196: PPUSH
44197: LD_INT 2
44199: PUSH
44200: LD_INT 30
44202: PUSH
44203: LD_INT 4
44205: PUSH
44206: EMPTY
44207: LIST
44208: LIST
44209: PUSH
44210: LD_INT 30
44212: PUSH
44213: LD_INT 5
44215: PUSH
44216: EMPTY
44217: LIST
44218: LIST
44219: PUSH
44220: EMPTY
44221: LIST
44222: LIST
44223: LIST
44224: PPUSH
44225: CALL_OW 72
44229: ADD
44230: ST_TO_ADDR
44231: GO 44479
44233: LD_INT 2
44235: DOUBLE
44236: EQUAL
44237: IFTRUE 44247
44239: LD_INT 16
44241: DOUBLE
44242: EQUAL
44243: IFTRUE 44247
44245: GO 44293
44247: POP
// tmp := UnitFilter ( base_unit_list , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) ; 3 :
44248: LD_ADDR_VAR 0 8
44252: PUSH
44253: LD_VAR 0 2
44257: PPUSH
44258: LD_INT 2
44260: PUSH
44261: LD_INT 30
44263: PUSH
44264: LD_INT 0
44266: PUSH
44267: EMPTY
44268: LIST
44269: LIST
44270: PUSH
44271: LD_INT 30
44273: PUSH
44274: LD_INT 1
44276: PUSH
44277: EMPTY
44278: LIST
44279: LIST
44280: PUSH
44281: EMPTY
44282: LIST
44283: LIST
44284: LIST
44285: PPUSH
44286: CALL_OW 72
44290: ST_TO_ADDR
44291: GO 44479
44293: LD_INT 3
44295: DOUBLE
44296: EQUAL
44297: IFTRUE 44301
44299: GO 44347
44301: POP
// tmp := UnitFilter ( base_unit_list , [ f_or , [ f_btype , b_workshop ] , [ f_btype , b_factory ] ] ) ; 4 :
44302: LD_ADDR_VAR 0 8
44306: PUSH
44307: LD_VAR 0 2
44311: PPUSH
44312: LD_INT 2
44314: PUSH
44315: LD_INT 30
44317: PUSH
44318: LD_INT 2
44320: PUSH
44321: EMPTY
44322: LIST
44323: LIST
44324: PUSH
44325: LD_INT 30
44327: PUSH
44328: LD_INT 3
44330: PUSH
44331: EMPTY
44332: LIST
44333: LIST
44334: PUSH
44335: EMPTY
44336: LIST
44337: LIST
44338: LIST
44339: PPUSH
44340: CALL_OW 72
44344: ST_TO_ADDR
44345: GO 44479
44347: LD_INT 4
44349: DOUBLE
44350: EQUAL
44351: IFTRUE 44355
44353: GO 44412
44355: POP
// tmp := UnitFilter ( base_unit_list , [ f_or , [ f_btype , b_lab ] , [ f_btype , b_lab_half ] , [ f_btype , b_lab_full ] ] ) ; 5 , 8 , 9 :
44356: LD_ADDR_VAR 0 8
44360: PUSH
44361: LD_VAR 0 2
44365: PPUSH
44366: LD_INT 2
44368: PUSH
44369: LD_INT 30
44371: PUSH
44372: LD_INT 6
44374: PUSH
44375: EMPTY
44376: LIST
44377: LIST
44378: PUSH
44379: LD_INT 30
44381: PUSH
44382: LD_INT 7
44384: PUSH
44385: EMPTY
44386: LIST
44387: LIST
44388: PUSH
44389: LD_INT 30
44391: PUSH
44392: LD_INT 8
44394: PUSH
44395: EMPTY
44396: LIST
44397: LIST
44398: PUSH
44399: EMPTY
44400: LIST
44401: LIST
44402: LIST
44403: LIST
44404: PPUSH
44405: CALL_OW 72
44409: ST_TO_ADDR
44410: GO 44479
44412: LD_INT 5
44414: DOUBLE
44415: EQUAL
44416: IFTRUE 44432
44418: LD_INT 8
44420: DOUBLE
44421: EQUAL
44422: IFTRUE 44432
44424: LD_INT 9
44426: DOUBLE
44427: EQUAL
44428: IFTRUE 44432
44430: GO 44478
44432: POP
// tmp := UnitFilter ( base_unit_list , [ f_or , [ f_btype , b_armoury ] , [ f_btype , b_barracks ] ] ) ; end ;
44433: LD_ADDR_VAR 0 8
44437: PUSH
44438: LD_VAR 0 2
44442: PPUSH
44443: LD_INT 2
44445: PUSH
44446: LD_INT 30
44448: PUSH
44449: LD_INT 4
44451: PUSH
44452: EMPTY
44453: LIST
44454: LIST
44455: PUSH
44456: LD_INT 30
44458: PUSH
44459: LD_INT 5
44461: PUSH
44462: EMPTY
44463: LIST
44464: LIST
44465: PUSH
44466: EMPTY
44467: LIST
44468: LIST
44469: LIST
44470: PPUSH
44471: CALL_OW 72
44475: ST_TO_ADDR
44476: GO 44479
44478: POP
// if not tmp then
44479: LD_VAR 0 8
44483: NOT
44484: IFFALSE 44488
// exit ;
44486: GO 44990
// if class in [ 1 , 15 ] and mc_empty_turret_list [ base ] then
44488: LD_VAR 0 4
44492: PUSH
44493: LD_INT 1
44495: PUSH
44496: LD_INT 15
44498: PUSH
44499: EMPTY
44500: LIST
44501: LIST
44502: IN
44503: PUSH
44504: LD_EXP 104
44508: PUSH
44509: LD_VAR 0 1
44513: ARRAY
44514: AND
44515: IFFALSE 44671
// begin x := mc_empty_turret_list [ base ] [ 1 ] ;
44517: LD_ADDR_VAR 0 9
44521: PUSH
44522: LD_EXP 104
44526: PUSH
44527: LD_VAR 0 1
44531: ARRAY
44532: PUSH
44533: LD_INT 1
44535: ARRAY
44536: ST_TO_ADDR
// if not x in mc_busy_turret_list [ base ] then
44537: LD_VAR 0 9
44541: PUSH
44542: LD_EXP 105
44546: PUSH
44547: LD_VAR 0 1
44551: ARRAY
44552: IN
44553: NOT
44554: IFFALSE 44669
// begin mc_busy_turret_list := ReplaceIn ( mc_busy_turret_list , [ base , mc_busy_turret_list [ base ] + 1 ] , x ) ;
44556: LD_ADDR_EXP 105
44560: PUSH
44561: LD_EXP 105
44565: PPUSH
44566: LD_VAR 0 1
44570: PUSH
44571: LD_EXP 105
44575: PUSH
44576: LD_VAR 0 1
44580: ARRAY
44581: PUSH
44582: LD_INT 1
44584: PLUS
44585: PUSH
44586: EMPTY
44587: LIST
44588: LIST
44589: PPUSH
44590: LD_VAR 0 9
44594: PPUSH
44595: CALL 57012 0 3
44599: ST_TO_ADDR
// mc_empty_turret_list := Replace ( mc_empty_turret_list , base , mc_empty_turret_list [ base ] diff x ) ;
44600: LD_ADDR_EXP 104
44604: PUSH
44605: LD_EXP 104
44609: PPUSH
44610: LD_VAR 0 1
44614: PPUSH
44615: LD_EXP 104
44619: PUSH
44620: LD_VAR 0 1
44624: ARRAY
44625: PUSH
44626: LD_VAR 0 9
44630: DIFF
44631: PPUSH
44632: CALL_OW 1
44636: ST_TO_ADDR
// ComEnterUnit ( unit , mc_busy_turret_list [ base ] [ mc_busy_turret_list [ base ] ] ) ;
44637: LD_VAR 0 3
44641: PPUSH
44642: LD_EXP 105
44646: PUSH
44647: LD_VAR 0 1
44651: ARRAY
44652: PUSH
44653: LD_EXP 105
44657: PUSH
44658: LD_VAR 0 1
44662: ARRAY
44663: ARRAY
44664: PPUSH
44665: CALL_OW 120
// end ; exit ;
44669: GO 44990
// end ; if tmp > 1 then
44671: LD_VAR 0 8
44675: PUSH
44676: LD_INT 1
44678: GREATER
44679: IFFALSE 44783
// for i = 2 to tmp do
44681: LD_ADDR_VAR 0 6
44685: PUSH
44686: DOUBLE
44687: LD_INT 2
44689: DEC
44690: ST_TO_ADDR
44691: LD_VAR 0 8
44695: PUSH
44696: FOR_TO
44697: IFFALSE 44781
// if BuildingStatus ( tmp [ i ] ) = bs_need_people then
44699: LD_VAR 0 8
44703: PUSH
44704: LD_VAR 0 6
44708: ARRAY
44709: PPUSH
44710: CALL_OW 461
44714: PUSH
44715: LD_INT 6
44717: EQUAL
44718: IFFALSE 44779
// begin x := tmp [ i ] ;
44720: LD_ADDR_VAR 0 9
44724: PUSH
44725: LD_VAR 0 8
44729: PUSH
44730: LD_VAR 0 6
44734: ARRAY
44735: ST_TO_ADDR
// tmp := Delete ( tmp , i ) ;
44736: LD_ADDR_VAR 0 8
44740: PUSH
44741: LD_VAR 0 8
44745: PPUSH
44746: LD_VAR 0 6
44750: PPUSH
44751: CALL_OW 3
44755: ST_TO_ADDR
// tmp := Insert ( tmp , 1 , x ) ;
44756: LD_ADDR_VAR 0 8
44760: PUSH
44761: LD_VAR 0 8
44765: PPUSH
44766: LD_INT 1
44768: PPUSH
44769: LD_VAR 0 9
44773: PPUSH
44774: CALL_OW 2
44778: ST_TO_ADDR
// end ;
44779: GO 44696
44781: POP
44782: POP
// for i in tmp do
44783: LD_ADDR_VAR 0 6
44787: PUSH
44788: LD_VAR 0 8
44792: PUSH
44793: FOR_IN
44794: IFFALSE 44863
// begin if ( UnitsInside ( i ) < 6 and not GetBType ( i ) in [ b_breastwork , b_bunker ] ) or UnitsInside ( i ) = 0 then
44796: LD_VAR 0 6
44800: PPUSH
44801: CALL_OW 313
44805: PUSH
44806: LD_INT 6
44808: LESS
44809: PUSH
44810: LD_VAR 0 6
44814: PPUSH
44815: CALL_OW 266
44819: PUSH
44820: LD_INT 31
44822: PUSH
44823: LD_INT 32
44825: PUSH
44826: EMPTY
44827: LIST
44828: LIST
44829: IN
44830: NOT
44831: AND
44832: PUSH
44833: LD_VAR 0 6
44837: PPUSH
44838: CALL_OW 313
44842: PUSH
44843: LD_INT 0
44845: EQUAL
44846: OR
44847: IFFALSE 44861
// begin j := i ;
44849: LD_ADDR_VAR 0 7
44853: PUSH
44854: LD_VAR 0 6
44858: ST_TO_ADDR
// break ;
44859: GO 44863
// end ; end ;
44861: GO 44793
44863: POP
44864: POP
// if j then
44865: LD_VAR 0 7
44869: IFFALSE 44887
// ComEnterUnit ( unit , j ) else
44871: LD_VAR 0 3
44875: PPUSH
44876: LD_VAR 0 7
44880: PPUSH
44881: CALL_OW 120
44885: GO 44990
// begin depot := UnitFilter ( base_unit_list , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) ;
44887: LD_ADDR_VAR 0 10
44891: PUSH
44892: LD_VAR 0 2
44896: PPUSH
44897: LD_INT 2
44899: PUSH
44900: LD_INT 30
44902: PUSH
44903: LD_INT 0
44905: PUSH
44906: EMPTY
44907: LIST
44908: LIST
44909: PUSH
44910: LD_INT 30
44912: PUSH
44913: LD_INT 1
44915: PUSH
44916: EMPTY
44917: LIST
44918: LIST
44919: PUSH
44920: EMPTY
44921: LIST
44922: LIST
44923: LIST
44924: PPUSH
44925: CALL_OW 72
44929: ST_TO_ADDR
// if depot then
44930: LD_VAR 0 10
44934: IFFALSE 44990
// begin depot := NearestUnitToUnit ( depot , unit ) ;
44936: LD_ADDR_VAR 0 10
44940: PUSH
44941: LD_VAR 0 10
44945: PPUSH
44946: LD_VAR 0 3
44950: PPUSH
44951: CALL_OW 74
44955: ST_TO_ADDR
// if GetDistUnits ( unit , depot ) > 10 then
44956: LD_VAR 0 3
44960: PPUSH
44961: LD_VAR 0 10
44965: PPUSH
44966: CALL_OW 296
44970: PUSH
44971: LD_INT 10
44973: GREATER
44974: IFFALSE 44990
// ComStandNearbyBuilding ( unit , depot ) ;
44976: LD_VAR 0 3
44980: PPUSH
44981: LD_VAR 0 10
44985: PPUSH
44986: CALL 53590 0 2
// end ; end ; end ;
44990: LD_VAR 0 5
44994: RET
// export function MC_Idle ( ) ; var i , j , tmp ; begin
44995: LD_INT 0
44997: PPUSH
44998: PPUSH
44999: PPUSH
45000: PPUSH
// if not mc_bases then
45001: LD_EXP 95
45005: NOT
45006: IFFALSE 45010
// exit ;
45008: GO 45249
// for i = 1 to mc_bases do
45010: LD_ADDR_VAR 0 2
45014: PUSH
45015: DOUBLE
45016: LD_INT 1
45018: DEC
45019: ST_TO_ADDR
45020: LD_EXP 95
45024: PUSH
45025: FOR_TO
45026: IFFALSE 45247
// begin tmp := UnitFilter ( mc_bases [ i ] , [ f_type , unit_human ] ) union mc_ape [ i ] ;
45028: LD_ADDR_VAR 0 4
45032: PUSH
45033: LD_EXP 95
45037: PUSH
45038: LD_VAR 0 2
45042: ARRAY
45043: PPUSH
45044: LD_INT 21
45046: PUSH
45047: LD_INT 1
45049: PUSH
45050: EMPTY
45051: LIST
45052: LIST
45053: PPUSH
45054: CALL_OW 72
45058: PUSH
45059: LD_EXP 124
45063: PUSH
45064: LD_VAR 0 2
45068: ARRAY
45069: UNION
45070: ST_TO_ADDR
// if not tmp then
45071: LD_VAR 0 4
45075: NOT
45076: IFFALSE 45080
// continue ;
45078: GO 45025
// for j in tmp do
45080: LD_ADDR_VAR 0 3
45084: PUSH
45085: LD_VAR 0 4
45089: PUSH
45090: FOR_IN
45091: IFFALSE 45243
// begin if not GetTag ( j ) and not HasTask ( j ) and not IsDrivenBy ( j ) and not IsInUnit ( j ) and not j in mc_need_heal [ i ] [ 1 ] and not j in mc_need_heal [ i ] [ 2 ] and not j in mc_repair_vehicle [ i ] then
45093: LD_VAR 0 3
45097: PPUSH
45098: CALL_OW 110
45102: NOT
45103: PUSH
45104: LD_VAR 0 3
45108: PPUSH
45109: CALL_OW 314
45113: NOT
45114: AND
45115: PUSH
45116: LD_VAR 0 3
45120: PPUSH
45121: CALL_OW 311
45125: NOT
45126: AND
45127: PUSH
45128: LD_VAR 0 3
45132: PPUSH
45133: CALL_OW 310
45137: NOT
45138: AND
45139: PUSH
45140: LD_VAR 0 3
45144: PUSH
45145: LD_EXP 98
45149: PUSH
45150: LD_VAR 0 2
45154: ARRAY
45155: PUSH
45156: LD_INT 1
45158: ARRAY
45159: IN
45160: NOT
45161: AND
45162: PUSH
45163: LD_VAR 0 3
45167: PUSH
45168: LD_EXP 98
45172: PUSH
45173: LD_VAR 0 2
45177: ARRAY
45178: PUSH
45179: LD_INT 2
45181: ARRAY
45182: IN
45183: NOT
45184: AND
45185: PUSH
45186: LD_VAR 0 3
45190: PUSH
45191: LD_EXP 107
45195: PUSH
45196: LD_VAR 0 2
45200: ARRAY
45201: IN
45202: NOT
45203: AND
45204: IFFALSE 45241
// MC_Back ( i , mc_bases [ i ] , j , GetClass ( j ) ) ;
45206: LD_VAR 0 2
45210: PPUSH
45211: LD_EXP 95
45215: PUSH
45216: LD_VAR 0 2
45220: ARRAY
45221: PPUSH
45222: LD_VAR 0 3
45226: PPUSH
45227: LD_VAR 0 3
45231: PPUSH
45232: CALL_OW 257
45236: PPUSH
45237: CALL 44013 0 4
// end ;
45241: GO 45090
45243: POP
45244: POP
// end ;
45245: GO 45025
45247: POP
45248: POP
// end ;
45249: LD_VAR 0 1
45253: RET
// export function MC_SetMinesField ( base , amount , area ) ; var i , tmp , list , x , j ; begin
45254: LD_INT 0
45256: PPUSH
45257: PPUSH
45258: PPUSH
45259: PPUSH
45260: PPUSH
45261: PPUSH
// if not mc_bases [ base ] then
45262: LD_EXP 95
45266: PUSH
45267: LD_VAR 0 1
45271: ARRAY
45272: NOT
45273: IFFALSE 45277
// exit ;
45275: GO 45459
// tmp := [ ] ;
45277: LD_ADDR_VAR 0 6
45281: PUSH
45282: EMPTY
45283: ST_TO_ADDR
// list := AreaToList ( area , 0 ) ;
45284: LD_ADDR_VAR 0 7
45288: PUSH
45289: LD_VAR 0 3
45293: PPUSH
45294: LD_INT 0
45296: PPUSH
45297: CALL_OW 517
45301: ST_TO_ADDR
// if not list then
45302: LD_VAR 0 7
45306: NOT
45307: IFFALSE 45311
// exit ;
45309: GO 45459
// for i = 1 to amount do
45311: LD_ADDR_VAR 0 5
45315: PUSH
45316: DOUBLE
45317: LD_INT 1
45319: DEC
45320: ST_TO_ADDR
45321: LD_VAR 0 2
45325: PUSH
45326: FOR_TO
45327: IFFALSE 45407
// begin x := rand ( 1 , list [ 1 ] ) ;
45329: LD_ADDR_VAR 0 8
45333: PUSH
45334: LD_INT 1
45336: PPUSH
45337: LD_VAR 0 7
45341: PUSH
45342: LD_INT 1
45344: ARRAY
45345: PPUSH
45346: CALL_OW 12
45350: ST_TO_ADDR
// tmp := Replace ( tmp , i , [ list [ 1 ] [ x ] , list [ 2 ] [ x ] ] ) ;
45351: LD_ADDR_VAR 0 6
45355: PUSH
45356: LD_VAR 0 6
45360: PPUSH
45361: LD_VAR 0 5
45365: PPUSH
45366: LD_VAR 0 7
45370: PUSH
45371: LD_INT 1
45373: ARRAY
45374: PUSH
45375: LD_VAR 0 8
45379: ARRAY
45380: PUSH
45381: LD_VAR 0 7
45385: PUSH
45386: LD_INT 2
45388: ARRAY
45389: PUSH
45390: LD_VAR 0 8
45394: ARRAY
45395: PUSH
45396: EMPTY
45397: LIST
45398: LIST
45399: PPUSH
45400: CALL_OW 1
45404: ST_TO_ADDR
// end ;
45405: GO 45326
45407: POP
45408: POP
// mc_mines := Replace ( mc_mines , base , tmp ) ;
45409: LD_ADDR_EXP 108
45413: PUSH
45414: LD_EXP 108
45418: PPUSH
45419: LD_VAR 0 1
45423: PPUSH
45424: LD_VAR 0 6
45428: PPUSH
45429: CALL_OW 1
45433: ST_TO_ADDR
// mc_minefields := Replace ( mc_minefields , base , area ) ;
45434: LD_ADDR_EXP 110
45438: PUSH
45439: LD_EXP 110
45443: PPUSH
45444: LD_VAR 0 1
45448: PPUSH
45449: LD_VAR 0 3
45453: PPUSH
45454: CALL_OW 1
45458: ST_TO_ADDR
// end ;
45459: LD_VAR 0 4
45463: RET
// export function MC_SetBuildingList ( base , construct_list ) ; begin
45464: LD_INT 0
45466: PPUSH
// if not mc_bases [ base ] then
45467: LD_EXP 95
45471: PUSH
45472: LD_VAR 0 1
45476: ARRAY
45477: NOT
45478: IFFALSE 45482
// exit ;
45480: GO 45507
// mc_build_list := Replace ( mc_build_list , base , construct_list ) ;
45482: LD_ADDR_EXP 100
45486: PUSH
45487: LD_EXP 100
45491: PPUSH
45492: LD_VAR 0 1
45496: PPUSH
45497: LD_VAR 0 2
45501: PPUSH
45502: CALL_OW 1
45506: ST_TO_ADDR
// end ;
45507: LD_VAR 0 3
45511: RET
// export function MC_InsertBuildingList ( base , list ) ; begin
45512: LD_INT 0
45514: PPUSH
// if not mc_bases [ base ] then
45515: LD_EXP 95
45519: PUSH
45520: LD_VAR 0 1
45524: ARRAY
45525: NOT
45526: IFFALSE 45530
// exit ;
45528: GO 45567
// mc_build_list := Replace ( mc_build_list , base , mc_build_list [ base ] union list ) ;
45530: LD_ADDR_EXP 100
45534: PUSH
45535: LD_EXP 100
45539: PPUSH
45540: LD_VAR 0 1
45544: PPUSH
45545: LD_EXP 100
45549: PUSH
45550: LD_VAR 0 1
45554: ARRAY
45555: PUSH
45556: LD_VAR 0 2
45560: UNION
45561: PPUSH
45562: CALL_OW 1
45566: ST_TO_ADDR
// end ;
45567: LD_VAR 0 3
45571: RET
// export function MC_SetProduceList ( base , produce_list ) ; begin
45572: LD_INT 0
45574: PPUSH
// if not mc_bases [ base ] then
45575: LD_EXP 95
45579: PUSH
45580: LD_VAR 0 1
45584: ARRAY
45585: NOT
45586: IFFALSE 45590
// exit ;
45588: GO 45615
// mc_produce := Replace ( mc_produce , base , produce_list ) ;
45590: LD_ADDR_EXP 116
45594: PUSH
45595: LD_EXP 116
45599: PPUSH
45600: LD_VAR 0 1
45604: PPUSH
45605: LD_VAR 0 2
45609: PPUSH
45610: CALL_OW 1
45614: ST_TO_ADDR
// end ;
45615: LD_VAR 0 3
45619: RET
// export function MC_InsertProduceList ( base , components ) ; begin
45620: LD_INT 0
45622: PPUSH
// if not mc_bases [ base ] then
45623: LD_EXP 95
45627: PUSH
45628: LD_VAR 0 1
45632: ARRAY
45633: NOT
45634: IFFALSE 45638
// exit ;
45636: GO 45675
// mc_produce := Replace ( mc_produce , base , mc_produce [ base ] ^ components ) ;
45638: LD_ADDR_EXP 116
45642: PUSH
45643: LD_EXP 116
45647: PPUSH
45648: LD_VAR 0 1
45652: PPUSH
45653: LD_EXP 116
45657: PUSH
45658: LD_VAR 0 1
45662: ARRAY
45663: PUSH
45664: LD_VAR 0 2
45668: ADD
45669: PPUSH
45670: CALL_OW 1
45674: ST_TO_ADDR
// end ;
45675: LD_VAR 0 3
45679: RET
// export function MC_SetDefenderList ( base , deflist ) ; begin
45680: LD_INT 0
45682: PPUSH
// if not mc_bases [ base ] then
45683: LD_EXP 95
45687: PUSH
45688: LD_VAR 0 1
45692: ARRAY
45693: NOT
45694: IFFALSE 45698
// exit ;
45696: GO 45752
// mc_defender := Replace ( mc_defender , base , deflist ) ;
45698: LD_ADDR_EXP 117
45702: PUSH
45703: LD_EXP 117
45707: PPUSH
45708: LD_VAR 0 1
45712: PPUSH
45713: LD_VAR 0 2
45717: PPUSH
45718: CALL_OW 1
45722: ST_TO_ADDR
// mc_defender_limit := Replace ( mc_defender_limit , base , deflist + 0 ) ;
45723: LD_ADDR_EXP 106
45727: PUSH
45728: LD_EXP 106
45732: PPUSH
45733: LD_VAR 0 1
45737: PPUSH
45738: LD_VAR 0 2
45742: PUSH
45743: LD_INT 0
45745: PLUS
45746: PPUSH
45747: CALL_OW 1
45751: ST_TO_ADDR
// end ;
45752: LD_VAR 0 3
45756: RET
// export function MC_SetDefenderLimit ( base , limit ) ; begin
45757: LD_INT 0
45759: PPUSH
// if not mc_bases [ base ] then
45760: LD_EXP 95
45764: PUSH
45765: LD_VAR 0 1
45769: ARRAY
45770: NOT
45771: IFFALSE 45775
// exit ;
45773: GO 45800
// mc_defender_limit := Replace ( mc_defender_limit , base , limit ) ;
45775: LD_ADDR_EXP 106
45779: PUSH
45780: LD_EXP 106
45784: PPUSH
45785: LD_VAR 0 1
45789: PPUSH
45790: LD_VAR 0 2
45794: PPUSH
45795: CALL_OW 1
45799: ST_TO_ADDR
// end ;
45800: LD_VAR 0 3
45804: RET
// export function MC_PrepareAttack ( base , group , path , flags ) ; var i , j , tmp ; begin
45805: LD_INT 0
45807: PPUSH
45808: PPUSH
45809: PPUSH
45810: PPUSH
// if not mc_bases [ base ] then
45811: LD_EXP 95
45815: PUSH
45816: LD_VAR 0 1
45820: ARRAY
45821: NOT
45822: IFFALSE 45826
// exit ;
45824: GO 45891
// mc_attack := ReplaceIn ( mc_attack , [ base , mc_attack [ base ] + 1 ] , [ base , group , path , flags ] ) ;
45826: LD_ADDR_EXP 115
45830: PUSH
45831: LD_EXP 115
45835: PPUSH
45836: LD_VAR 0 1
45840: PUSH
45841: LD_EXP 115
45845: PUSH
45846: LD_VAR 0 1
45850: ARRAY
45851: PUSH
45852: LD_INT 1
45854: PLUS
45855: PUSH
45856: EMPTY
45857: LIST
45858: LIST
45859: PPUSH
45860: LD_VAR 0 1
45864: PUSH
45865: LD_VAR 0 2
45869: PUSH
45870: LD_VAR 0 3
45874: PUSH
45875: LD_VAR 0 4
45879: PUSH
45880: EMPTY
45881: LIST
45882: LIST
45883: LIST
45884: LIST
45885: PPUSH
45886: CALL 57012 0 3
45890: ST_TO_ADDR
// end ;
45891: LD_VAR 0 5
45895: RET
// export function MC_SetDepositsXY ( base , deposits_list ) ; begin
45896: LD_INT 0
45898: PPUSH
// if not mc_bases [ base ] then
45899: LD_EXP 95
45903: PUSH
45904: LD_VAR 0 1
45908: ARRAY
45909: NOT
45910: IFFALSE 45914
// exit ;
45912: GO 45939
// mc_deposits_xy := Replace ( mc_deposits_xy , base , deposits_list ) ;
45914: LD_ADDR_EXP 132
45918: PUSH
45919: LD_EXP 132
45923: PPUSH
45924: LD_VAR 0 1
45928: PPUSH
45929: LD_VAR 0 2
45933: PPUSH
45934: CALL_OW 1
45938: ST_TO_ADDR
// end ;
45939: LD_VAR 0 3
45943: RET
// export function MC_GetMinesField ( base ) ; begin
45944: LD_INT 0
45946: PPUSH
// result := mc_mines [ base ] ;
45947: LD_ADDR_VAR 0 2
45951: PUSH
45952: LD_EXP 108
45956: PUSH
45957: LD_VAR 0 1
45961: ARRAY
45962: ST_TO_ADDR
// end ;
45963: LD_VAR 0 2
45967: RET
// export function MC_GetProduceList ( base ) ; begin
45968: LD_INT 0
45970: PPUSH
// result := mc_produce [ base ] ;
45971: LD_ADDR_VAR 0 2
45975: PUSH
45976: LD_EXP 116
45980: PUSH
45981: LD_VAR 0 1
45985: ARRAY
45986: ST_TO_ADDR
// end ;
45987: LD_VAR 0 2
45991: RET
// export function MC_GetBuilding ( base , btype ) ; var i ; begin
45992: LD_INT 0
45994: PPUSH
45995: PPUSH
// if not mc_bases then
45996: LD_EXP 95
46000: NOT
46001: IFFALSE 46005
// exit ;
46003: GO 46070
// if mc_bases [ base ] then
46005: LD_EXP 95
46009: PUSH
46010: LD_VAR 0 1
46014: ARRAY
46015: IFFALSE 46070
// begin result := UnitFilter ( mc_bases [ base ] , [ f_btype , btype ] ) ;
46017: LD_ADDR_VAR 0 3
46021: PUSH
46022: LD_EXP 95
46026: PUSH
46027: LD_VAR 0 1
46031: ARRAY
46032: PPUSH
46033: LD_INT 30
46035: PUSH
46036: LD_VAR 0 2
46040: PUSH
46041: EMPTY
46042: LIST
46043: LIST
46044: PPUSH
46045: CALL_OW 72
46049: ST_TO_ADDR
// if result then
46050: LD_VAR 0 3
46054: IFFALSE 46070
// result := result [ 1 ] ;
46056: LD_ADDR_VAR 0 3
46060: PUSH
46061: LD_VAR 0 3
46065: PUSH
46066: LD_INT 1
46068: ARRAY
46069: ST_TO_ADDR
// end ; end ;
46070: LD_VAR 0 3
46074: RET
// export function MC_GetBuildings ( base , btype ) ; var i ; begin
46075: LD_INT 0
46077: PPUSH
46078: PPUSH
// if not mc_bases then
46079: LD_EXP 95
46083: NOT
46084: IFFALSE 46088
// exit ;
46086: GO 46133
// if mc_bases [ base ] then
46088: LD_EXP 95
46092: PUSH
46093: LD_VAR 0 1
46097: ARRAY
46098: IFFALSE 46133
// result := UnitFilter ( mc_bases [ base ] , [ f_btype , btype ] ) ;
46100: LD_ADDR_VAR 0 3
46104: PUSH
46105: LD_EXP 95
46109: PUSH
46110: LD_VAR 0 1
46114: ARRAY
46115: PPUSH
46116: LD_INT 30
46118: PUSH
46119: LD_VAR 0 2
46123: PUSH
46124: EMPTY
46125: LIST
46126: LIST
46127: PPUSH
46128: CALL_OW 72
46132: ST_TO_ADDR
// end ;
46133: LD_VAR 0 3
46137: RET
// export function MC_SetTame ( base , area ) ; begin
46138: LD_INT 0
46140: PPUSH
// if not mc_bases or not base then
46141: LD_EXP 95
46145: NOT
46146: PUSH
46147: LD_VAR 0 1
46151: NOT
46152: OR
46153: IFFALSE 46157
// exit ;
46155: GO 46182
// mc_can_tame := Replace ( mc_can_tame , base , area ) ;
46157: LD_ADDR_EXP 123
46161: PUSH
46162: LD_EXP 123
46166: PPUSH
46167: LD_VAR 0 1
46171: PPUSH
46172: LD_VAR 0 2
46176: PPUSH
46177: CALL_OW 1
46181: ST_TO_ADDR
// end ;
46182: LD_VAR 0 3
46186: RET
// export function MC_SetUpgradeBuilding ( base , btype ) ; var tmp ; begin
46187: LD_INT 0
46189: PPUSH
46190: PPUSH
// if not mc_bases or not base then
46191: LD_EXP 95
46195: NOT
46196: PUSH
46197: LD_VAR 0 1
46201: NOT
46202: OR
46203: IFFALSE 46207
// exit ;
46205: GO 46309
// tmp := UnitFilter ( mc_bases [ base ] , [ f_btype , btype ] ) ;
46207: LD_ADDR_VAR 0 4
46211: PUSH
46212: LD_EXP 95
46216: PUSH
46217: LD_VAR 0 1
46221: ARRAY
46222: PPUSH
46223: LD_INT 30
46225: PUSH
46226: LD_VAR 0 2
46230: PUSH
46231: EMPTY
46232: LIST
46233: LIST
46234: PPUSH
46235: CALL_OW 72
46239: ST_TO_ADDR
// if not tmp then
46240: LD_VAR 0 4
46244: NOT
46245: IFFALSE 46249
// exit ;
46247: GO 46309
// mc_build_upgrade := Replace ( mc_build_upgrade , base , Insert ( mc_build_upgrade [ base ] , mc_build_upgrade [ base ] + 1 , tmp [ 1 ] ) ) ;
46249: LD_ADDR_EXP 127
46253: PUSH
46254: LD_EXP 127
46258: PPUSH
46259: LD_VAR 0 1
46263: PPUSH
46264: LD_EXP 127
46268: PUSH
46269: LD_VAR 0 1
46273: ARRAY
46274: PPUSH
46275: LD_EXP 127
46279: PUSH
46280: LD_VAR 0 1
46284: ARRAY
46285: PUSH
46286: LD_INT 1
46288: PLUS
46289: PPUSH
46290: LD_VAR 0 4
46294: PUSH
46295: LD_INT 1
46297: ARRAY
46298: PPUSH
46299: CALL_OW 2
46303: PPUSH
46304: CALL_OW 1
46308: ST_TO_ADDR
// end ;
46309: LD_VAR 0 3
46313: RET
// export function MC_SetLabKind ( base , kinds ) ; var i ; begin
46314: LD_INT 0
46316: PPUSH
46317: PPUSH
// if not mc_bases or not base or not kinds then
46318: LD_EXP 95
46322: NOT
46323: PUSH
46324: LD_VAR 0 1
46328: NOT
46329: OR
46330: PUSH
46331: LD_VAR 0 2
46335: NOT
46336: OR
46337: IFFALSE 46341
// exit ;
46339: GO 46402
// for i in kinds do
46341: LD_ADDR_VAR 0 4
46345: PUSH
46346: LD_VAR 0 2
46350: PUSH
46351: FOR_IN
46352: IFFALSE 46400
// mc_lab_upgrade := ReplaceIn ( mc_lab_upgrade , [ base , mc_lab_upgrade [ base ] + 1 ] , i ) ;
46354: LD_ADDR_EXP 129
46358: PUSH
46359: LD_EXP 129
46363: PPUSH
46364: LD_VAR 0 1
46368: PUSH
46369: LD_EXP 129
46373: PUSH
46374: LD_VAR 0 1
46378: ARRAY
46379: PUSH
46380: LD_INT 1
46382: PLUS
46383: PUSH
46384: EMPTY
46385: LIST
46386: LIST
46387: PPUSH
46388: LD_VAR 0 4
46392: PPUSH
46393: CALL 57012 0 3
46397: ST_TO_ADDR
46398: GO 46351
46400: POP
46401: POP
// end ;
46402: LD_VAR 0 3
46406: RET
// export function MC_SetCratesArea ( base , areas ) ; begin
46407: LD_INT 0
46409: PPUSH
// if not mc_bases or not base or not areas then
46410: LD_EXP 95
46414: NOT
46415: PUSH
46416: LD_VAR 0 1
46420: NOT
46421: OR
46422: PUSH
46423: LD_VAR 0 2
46427: NOT
46428: OR
46429: IFFALSE 46433
// exit ;
46431: GO 46458
// mc_crates_area := Replace ( mc_crates_area , base , areas ) ;
46433: LD_ADDR_EXP 113
46437: PUSH
46438: LD_EXP 113
46442: PPUSH
46443: LD_VAR 0 1
46447: PPUSH
46448: LD_VAR 0 2
46452: PPUSH
46453: CALL_OW 1
46457: ST_TO_ADDR
// end ;
46458: LD_VAR 0 3
46462: RET
// export function MC_SetTeleportExit ( base , teleports_exit ) ; begin
46463: LD_INT 0
46465: PPUSH
// if not mc_bases or not base or not teleports_exit then
46466: LD_EXP 95
46470: NOT
46471: PUSH
46472: LD_VAR 0 1
46476: NOT
46477: OR
46478: PUSH
46479: LD_VAR 0 2
46483: NOT
46484: OR
46485: IFFALSE 46489
// exit ;
46487: GO 46514
// mc_teleport_exit := Replace ( mc_teleport_exit , base , teleports_exit ) ;
46489: LD_ADDR_EXP 130
46493: PUSH
46494: LD_EXP 130
46498: PPUSH
46499: LD_VAR 0 1
46503: PPUSH
46504: LD_VAR 0 2
46508: PPUSH
46509: CALL_OW 1
46513: ST_TO_ADDR
// end ;
46514: LD_VAR 0 3
46518: RET
// export function MC_SetFactoryExtension ( base , x , y , d , ext_list ) ; var i , tmp ; begin
46519: LD_INT 0
46521: PPUSH
46522: PPUSH
46523: PPUSH
// if not mc_bases or not base or not ext_list then
46524: LD_EXP 95
46528: NOT
46529: PUSH
46530: LD_VAR 0 1
46534: NOT
46535: OR
46536: PUSH
46537: LD_VAR 0 5
46541: NOT
46542: OR
46543: IFFALSE 46547
// exit ;
46545: GO 46720
// tmp := GetFacExtXYD ( x , y , d ) ;
46547: LD_ADDR_VAR 0 8
46551: PUSH
46552: LD_VAR 0 2
46556: PPUSH
46557: LD_VAR 0 3
46561: PPUSH
46562: LD_VAR 0 4
46566: PPUSH
46567: CALL 86399 0 3
46571: ST_TO_ADDR
// if not tmp then
46572: LD_VAR 0 8
46576: NOT
46577: IFFALSE 46581
// exit ;
46579: GO 46720
// for i in tmp do
46581: LD_ADDR_VAR 0 7
46585: PUSH
46586: LD_VAR 0 8
46590: PUSH
46591: FOR_IN
46592: IFFALSE 46718
// begin mc_build_list := Replace ( mc_build_list , base , Insert ( mc_build_list [ base ] , mc_build_list [ base ] + 1 , [ ext_list [ 1 ] , i [ 1 ] , i [ 2 ] , i [ 3 ] ] ) ) ;
46594: LD_ADDR_EXP 100
46598: PUSH
46599: LD_EXP 100
46603: PPUSH
46604: LD_VAR 0 1
46608: PPUSH
46609: LD_EXP 100
46613: PUSH
46614: LD_VAR 0 1
46618: ARRAY
46619: PPUSH
46620: LD_EXP 100
46624: PUSH
46625: LD_VAR 0 1
46629: ARRAY
46630: PUSH
46631: LD_INT 1
46633: PLUS
46634: PPUSH
46635: LD_VAR 0 5
46639: PUSH
46640: LD_INT 1
46642: ARRAY
46643: PUSH
46644: LD_VAR 0 7
46648: PUSH
46649: LD_INT 1
46651: ARRAY
46652: PUSH
46653: LD_VAR 0 7
46657: PUSH
46658: LD_INT 2
46660: ARRAY
46661: PUSH
46662: LD_VAR 0 7
46666: PUSH
46667: LD_INT 3
46669: ARRAY
46670: PUSH
46671: EMPTY
46672: LIST
46673: LIST
46674: LIST
46675: LIST
46676: PPUSH
46677: CALL_OW 2
46681: PPUSH
46682: CALL_OW 1
46686: ST_TO_ADDR
// ext_list := Delete ( ext_list , 1 ) ;
46687: LD_ADDR_VAR 0 5
46691: PUSH
46692: LD_VAR 0 5
46696: PPUSH
46697: LD_INT 1
46699: PPUSH
46700: CALL_OW 3
46704: ST_TO_ADDR
// if not ext_list then
46705: LD_VAR 0 5
46709: NOT
46710: IFFALSE 46716
// exit ;
46712: POP
46713: POP
46714: GO 46720
// end ;
46716: GO 46591
46718: POP
46719: POP
// end ;
46720: LD_VAR 0 6
46724: RET
// export function MC_SetAllowedTurretWeapons ( base , weapon_list ) ; begin
46725: LD_INT 0
46727: PPUSH
// if not mc_bases or not base or not weapon_list then
46728: LD_EXP 95
46732: NOT
46733: PUSH
46734: LD_VAR 0 1
46738: NOT
46739: OR
46740: PUSH
46741: LD_VAR 0 2
46745: NOT
46746: OR
46747: IFFALSE 46751
// exit ;
46749: GO 46776
// mc_allowed_tower_weapons := Replace ( mc_allowed_tower_weapons , base , weapon_list ) ;
46751: LD_ADDR_EXP 134
46755: PUSH
46756: LD_EXP 134
46760: PPUSH
46761: LD_VAR 0 1
46765: PPUSH
46766: LD_VAR 0 2
46770: PPUSH
46771: CALL_OW 1
46775: ST_TO_ADDR
// end ;
46776: LD_VAR 0 3
46780: RET
// export function MC_SetTechList ( base , tech_list ) ; begin
46781: LD_INT 0
46783: PPUSH
// if not mc_bases or not base or not tech_list then
46784: LD_EXP 95
46788: NOT
46789: PUSH
46790: LD_VAR 0 1
46794: NOT
46795: OR
46796: PUSH
46797: LD_VAR 0 2
46801: NOT
46802: OR
46803: IFFALSE 46807
// exit ;
46805: GO 46832
// mc_tech := Replace ( mc_tech , base , tech_list ) ;
46807: LD_ADDR_EXP 122
46811: PUSH
46812: LD_EXP 122
46816: PPUSH
46817: LD_VAR 0 1
46821: PPUSH
46822: LD_VAR 0 2
46826: PPUSH
46827: CALL_OW 1
46831: ST_TO_ADDR
// end ;
46832: LD_VAR 0 3
46836: RET
// export function MC_SetParkingArea ( base , parking_area ) ; begin
46837: LD_INT 0
46839: PPUSH
// if not mc_bases or not parking_area or not base then
46840: LD_EXP 95
46844: NOT
46845: PUSH
46846: LD_VAR 0 2
46850: NOT
46851: OR
46852: PUSH
46853: LD_VAR 0 1
46857: NOT
46858: OR
46859: IFFALSE 46863
// exit ;
46861: GO 46888
// mc_parking := Replace ( mc_parking , base , parking_area ) ;
46863: LD_ADDR_EXP 119
46867: PUSH
46868: LD_EXP 119
46872: PPUSH
46873: LD_VAR 0 1
46877: PPUSH
46878: LD_VAR 0 2
46882: PPUSH
46883: CALL_OW 1
46887: ST_TO_ADDR
// end ;
46888: LD_VAR 0 3
46892: RET
// export function MC_SetScanArea ( base , scan_area ) ; begin
46893: LD_INT 0
46895: PPUSH
// if not mc_bases or not base or not scan_area then
46896: LD_EXP 95
46900: NOT
46901: PUSH
46902: LD_VAR 0 1
46906: NOT
46907: OR
46908: PUSH
46909: LD_VAR 0 2
46913: NOT
46914: OR
46915: IFFALSE 46919
// exit ;
46917: GO 46944
// mc_scan_area := Replace ( mc_scan_area , base , scan_area ) ;
46919: LD_ADDR_EXP 120
46923: PUSH
46924: LD_EXP 120
46928: PPUSH
46929: LD_VAR 0 1
46933: PPUSH
46934: LD_VAR 0 2
46938: PPUSH
46939: CALL_OW 1
46943: ST_TO_ADDR
// end ;
46944: LD_VAR 0 3
46948: RET
// export function MC_NotTameApeman ( base ) ; var ape_techs ; begin
46949: LD_INT 0
46951: PPUSH
46952: PPUSH
// if not mc_bases or not base then
46953: LD_EXP 95
46957: NOT
46958: PUSH
46959: LD_VAR 0 1
46963: NOT
46964: OR
46965: IFFALSE 46969
// exit ;
46967: GO 47033
// ape_techs := [ 1 , 2 , 3 , 4 , 11 ] ;
46969: LD_ADDR_VAR 0 3
46973: PUSH
46974: LD_INT 1
46976: PUSH
46977: LD_INT 2
46979: PUSH
46980: LD_INT 3
46982: PUSH
46983: LD_INT 4
46985: PUSH
46986: LD_INT 11
46988: PUSH
46989: EMPTY
46990: LIST
46991: LIST
46992: LIST
46993: LIST
46994: LIST
46995: ST_TO_ADDR
// mc_tech := Replace ( mc_tech , base , mc_tech [ base ] diff ape_techs ) ;
46996: LD_ADDR_EXP 122
47000: PUSH
47001: LD_EXP 122
47005: PPUSH
47006: LD_VAR 0 1
47010: PPUSH
47011: LD_EXP 122
47015: PUSH
47016: LD_VAR 0 1
47020: ARRAY
47021: PUSH
47022: LD_VAR 0 3
47026: DIFF
47027: PPUSH
47028: CALL_OW 1
47032: ST_TO_ADDR
// end ;
47033: LD_VAR 0 2
47037: RET
// export function MC_GetVehicles ( base , onlyCombat ) ; begin
47038: LD_INT 0
47040: PPUSH
// result := mc_vehicles [ base ] ;
47041: LD_ADDR_VAR 0 3
47045: PUSH
47046: LD_EXP 114
47050: PUSH
47051: LD_VAR 0 1
47055: ARRAY
47056: ST_TO_ADDR
// if onlyCombat then
47057: LD_VAR 0 2
47061: IFFALSE 47239
// result := result diff UnitFilter ( result , [ f_or , [ f_weapon , us_cargo_bay ] , [ f_weapon , ru_cargo_bay ] , [ f_weapon , ru_big_cargo_bay ] , [ f_weapon , ar_cargo_bay ] , [ f_weapon , us_crane ] , [ f_weapon , ru_crane ] , [ f_weapon , ar_crane ] , [ f_weapon , us_bulldozer ] , [ f_weapon , ru_bulldozer ] , [ f_weapon , ru_radar ] , [ f_weapon , ar_control_tower ] , [ f_weapon , ru_siberium_rocket ] , [ f_weapon , us_siberium_rocket ] ] ) ;
47063: LD_ADDR_VAR 0 3
47067: PUSH
47068: LD_VAR 0 3
47072: PUSH
47073: LD_VAR 0 3
47077: PPUSH
47078: LD_INT 2
47080: PUSH
47081: LD_INT 34
47083: PUSH
47084: LD_INT 12
47086: PUSH
47087: EMPTY
47088: LIST
47089: LIST
47090: PUSH
47091: LD_INT 34
47093: PUSH
47094: LD_INT 51
47096: PUSH
47097: EMPTY
47098: LIST
47099: LIST
47100: PUSH
47101: LD_INT 34
47103: PUSH
47104: LD_EXP 75
47108: PUSH
47109: EMPTY
47110: LIST
47111: LIST
47112: PUSH
47113: LD_INT 34
47115: PUSH
47116: LD_INT 32
47118: PUSH
47119: EMPTY
47120: LIST
47121: LIST
47122: PUSH
47123: LD_INT 34
47125: PUSH
47126: LD_INT 13
47128: PUSH
47129: EMPTY
47130: LIST
47131: LIST
47132: PUSH
47133: LD_INT 34
47135: PUSH
47136: LD_INT 52
47138: PUSH
47139: EMPTY
47140: LIST
47141: LIST
47142: PUSH
47143: LD_INT 34
47145: PUSH
47146: LD_EXP 80
47150: PUSH
47151: EMPTY
47152: LIST
47153: LIST
47154: PUSH
47155: LD_INT 34
47157: PUSH
47158: LD_INT 14
47160: PUSH
47161: EMPTY
47162: LIST
47163: LIST
47164: PUSH
47165: LD_INT 34
47167: PUSH
47168: LD_INT 53
47170: PUSH
47171: EMPTY
47172: LIST
47173: LIST
47174: PUSH
47175: LD_INT 34
47177: PUSH
47178: LD_EXP 74
47182: PUSH
47183: EMPTY
47184: LIST
47185: LIST
47186: PUSH
47187: LD_INT 34
47189: PUSH
47190: LD_INT 31
47192: PUSH
47193: EMPTY
47194: LIST
47195: LIST
47196: PUSH
47197: LD_INT 34
47199: PUSH
47200: LD_INT 48
47202: PUSH
47203: EMPTY
47204: LIST
47205: LIST
47206: PUSH
47207: LD_INT 34
47209: PUSH
47210: LD_INT 8
47212: PUSH
47213: EMPTY
47214: LIST
47215: LIST
47216: PUSH
47217: EMPTY
47218: LIST
47219: LIST
47220: LIST
47221: LIST
47222: LIST
47223: LIST
47224: LIST
47225: LIST
47226: LIST
47227: LIST
47228: LIST
47229: LIST
47230: LIST
47231: LIST
47232: PPUSH
47233: CALL_OW 72
47237: DIFF
47238: ST_TO_ADDR
// end ; end_of_file
47239: LD_VAR 0 3
47243: RET
// export function MCE_ApemanTamed ( ape , sci ) ; var i , tmp ; begin
47244: LD_INT 0
47246: PPUSH
47247: PPUSH
47248: PPUSH
// if not mc_bases or not skirmish then
47249: LD_EXP 95
47253: NOT
47254: PUSH
47255: LD_EXP 93
47259: NOT
47260: OR
47261: IFFALSE 47265
// exit ;
47263: GO 47430
// for i = 1 to mc_bases do
47265: LD_ADDR_VAR 0 4
47269: PUSH
47270: DOUBLE
47271: LD_INT 1
47273: DEC
47274: ST_TO_ADDR
47275: LD_EXP 95
47279: PUSH
47280: FOR_TO
47281: IFFALSE 47428
// begin if sci in mc_bases [ i ] then
47283: LD_VAR 0 2
47287: PUSH
47288: LD_EXP 95
47292: PUSH
47293: LD_VAR 0 4
47297: ARRAY
47298: IN
47299: IFFALSE 47426
// begin mc_ape := ReplaceIn ( mc_ape , [ i , mc_ape [ i ] + 1 ] , ape ) ;
47301: LD_ADDR_EXP 124
47305: PUSH
47306: LD_EXP 124
47310: PPUSH
47311: LD_VAR 0 4
47315: PUSH
47316: LD_EXP 124
47320: PUSH
47321: LD_VAR 0 4
47325: ARRAY
47326: PUSH
47327: LD_INT 1
47329: PLUS
47330: PUSH
47331: EMPTY
47332: LIST
47333: LIST
47334: PPUSH
47335: LD_VAR 0 1
47339: PPUSH
47340: CALL 57012 0 3
47344: ST_TO_ADDR
// tmp := NearestUnitToUnit ( UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) , ape ) ;
47345: LD_ADDR_VAR 0 5
47349: PUSH
47350: LD_EXP 95
47354: PUSH
47355: LD_VAR 0 4
47359: ARRAY
47360: PPUSH
47361: LD_INT 2
47363: PUSH
47364: LD_INT 30
47366: PUSH
47367: LD_INT 0
47369: PUSH
47370: EMPTY
47371: LIST
47372: LIST
47373: PUSH
47374: LD_INT 30
47376: PUSH
47377: LD_INT 1
47379: PUSH
47380: EMPTY
47381: LIST
47382: LIST
47383: PUSH
47384: EMPTY
47385: LIST
47386: LIST
47387: LIST
47388: PPUSH
47389: CALL_OW 72
47393: PPUSH
47394: LD_VAR 0 1
47398: PPUSH
47399: CALL_OW 74
47403: ST_TO_ADDR
// if tmp then
47404: LD_VAR 0 5
47408: IFFALSE 47424
// ComStandNearbyBuilding ( ape , tmp ) ;
47410: LD_VAR 0 1
47414: PPUSH
47415: LD_VAR 0 5
47419: PPUSH
47420: CALL 53590 0 2
// break ;
47424: GO 47428
// end ; end ;
47426: GO 47280
47428: POP
47429: POP
// end ;
47430: LD_VAR 0 3
47434: RET
// export function MCE_EnterBuilding ( building , unit ) ; var i , tmp ; begin
47435: LD_INT 0
47437: PPUSH
47438: PPUSH
47439: PPUSH
// if not mc_bases or not skirmish then
47440: LD_EXP 95
47444: NOT
47445: PUSH
47446: LD_EXP 93
47450: NOT
47451: OR
47452: IFFALSE 47456
// exit ;
47454: GO 47545
// for i = 1 to mc_bases do
47456: LD_ADDR_VAR 0 4
47460: PUSH
47461: DOUBLE
47462: LD_INT 1
47464: DEC
47465: ST_TO_ADDR
47466: LD_EXP 95
47470: PUSH
47471: FOR_TO
47472: IFFALSE 47543
// begin if building in mc_busy_turret_list [ i ] then
47474: LD_VAR 0 1
47478: PUSH
47479: LD_EXP 105
47483: PUSH
47484: LD_VAR 0 4
47488: ARRAY
47489: IN
47490: IFFALSE 47541
// begin tmp := mc_busy_turret_list [ i ] diff building ;
47492: LD_ADDR_VAR 0 5
47496: PUSH
47497: LD_EXP 105
47501: PUSH
47502: LD_VAR 0 4
47506: ARRAY
47507: PUSH
47508: LD_VAR 0 1
47512: DIFF
47513: ST_TO_ADDR
// mc_busy_turret_list := Replace ( mc_busy_turret_list , i , tmp ) ;
47514: LD_ADDR_EXP 105
47518: PUSH
47519: LD_EXP 105
47523: PPUSH
47524: LD_VAR 0 4
47528: PPUSH
47529: LD_VAR 0 5
47533: PPUSH
47534: CALL_OW 1
47538: ST_TO_ADDR
// break ;
47539: GO 47543
// end ; end ;
47541: GO 47471
47543: POP
47544: POP
// end ;
47545: LD_VAR 0 3
47549: RET
// export function MCE_BuildingCaptured ( building , side , capturning_unit ) ; var i , tmp ; begin
47550: LD_INT 0
47552: PPUSH
47553: PPUSH
47554: PPUSH
// if not mc_bases or not skirmish then
47555: LD_EXP 95
47559: NOT
47560: PUSH
47561: LD_EXP 93
47565: NOT
47566: OR
47567: IFFALSE 47571
// exit ;
47569: GO 47770
// for i = 1 to mc_bases do
47571: LD_ADDR_VAR 0 5
47575: PUSH
47576: DOUBLE
47577: LD_INT 1
47579: DEC
47580: ST_TO_ADDR
47581: LD_EXP 95
47585: PUSH
47586: FOR_TO
47587: IFFALSE 47768
// if building in mc_bases [ i ] then
47589: LD_VAR 0 1
47593: PUSH
47594: LD_EXP 95
47598: PUSH
47599: LD_VAR 0 5
47603: ARRAY
47604: IN
47605: IFFALSE 47766
// begin tmp := mc_bases [ i ] diff building ;
47607: LD_ADDR_VAR 0 6
47611: PUSH
47612: LD_EXP 95
47616: PUSH
47617: LD_VAR 0 5
47621: ARRAY
47622: PUSH
47623: LD_VAR 0 1
47627: DIFF
47628: ST_TO_ADDR
// mc_bases := Replace ( mc_bases , i , tmp ) ;
47629: LD_ADDR_EXP 95
47633: PUSH
47634: LD_EXP 95
47638: PPUSH
47639: LD_VAR 0 5
47643: PPUSH
47644: LD_VAR 0 6
47648: PPUSH
47649: CALL_OW 1
47653: ST_TO_ADDR
// if building in mc_turret_list [ i ] then
47654: LD_VAR 0 1
47658: PUSH
47659: LD_EXP 103
47663: PUSH
47664: LD_VAR 0 5
47668: ARRAY
47669: IN
47670: IFFALSE 47709
// mc_turret_list := Replace ( mc_turret_list , i , mc_turret_list [ i ] diff building ) ;
47672: LD_ADDR_EXP 103
47676: PUSH
47677: LD_EXP 103
47681: PPUSH
47682: LD_VAR 0 5
47686: PPUSH
47687: LD_EXP 103
47691: PUSH
47692: LD_VAR 0 5
47696: ARRAY
47697: PUSH
47698: LD_VAR 0 1
47702: DIFF
47703: PPUSH
47704: CALL_OW 1
47708: ST_TO_ADDR
// if building in mc_empty_turret_list [ i ] then
47709: LD_VAR 0 1
47713: PUSH
47714: LD_EXP 104
47718: PUSH
47719: LD_VAR 0 5
47723: ARRAY
47724: IN
47725: IFFALSE 47764
// mc_empty_turret_list := Replace ( mc_empty_turret_list , i , mc_empty_turret_list [ i ] diff building ) ;
47727: LD_ADDR_EXP 104
47731: PUSH
47732: LD_EXP 104
47736: PPUSH
47737: LD_VAR 0 5
47741: PPUSH
47742: LD_EXP 104
47746: PUSH
47747: LD_VAR 0 5
47751: ARRAY
47752: PUSH
47753: LD_VAR 0 1
47757: DIFF
47758: PPUSH
47759: CALL_OW 1
47763: ST_TO_ADDR
// break ;
47764: GO 47768
// end ;
47766: GO 47586
47768: POP
47769: POP
// end ;
47770: LD_VAR 0 4
47774: RET
// export function MCE_VehicleCaptured ( new , old , side , capturing_unit ) ; var i , tmp ; begin
47775: LD_INT 0
47777: PPUSH
47778: PPUSH
47779: PPUSH
// if not mc_bases or not skirmish or not side in mc_sides then
47780: LD_EXP 95
47784: NOT
47785: PUSH
47786: LD_EXP 93
47790: NOT
47791: OR
47792: PUSH
47793: LD_VAR 0 3
47797: PUSH
47798: LD_EXP 121
47802: IN
47803: NOT
47804: OR
47805: IFFALSE 47809
// exit ;
47807: GO 47932
// for i = 1 to mc_vehicles do
47809: LD_ADDR_VAR 0 6
47813: PUSH
47814: DOUBLE
47815: LD_INT 1
47817: DEC
47818: ST_TO_ADDR
47819: LD_EXP 114
47823: PUSH
47824: FOR_TO
47825: IFFALSE 47930
// if old in mc_vehicles [ i ] or new in mc_vehicles [ i ] then
47827: LD_VAR 0 2
47831: PUSH
47832: LD_EXP 114
47836: PUSH
47837: LD_VAR 0 6
47841: ARRAY
47842: IN
47843: PUSH
47844: LD_VAR 0 1
47848: PUSH
47849: LD_EXP 114
47853: PUSH
47854: LD_VAR 0 6
47858: ARRAY
47859: IN
47860: OR
47861: IFFALSE 47928
// begin tmp := mc_vehicles [ i ] diff old ;
47863: LD_ADDR_VAR 0 7
47867: PUSH
47868: LD_EXP 114
47872: PUSH
47873: LD_VAR 0 6
47877: ARRAY
47878: PUSH
47879: LD_VAR 0 2
47883: DIFF
47884: ST_TO_ADDR
// tmp := tmp diff new ;
47885: LD_ADDR_VAR 0 7
47889: PUSH
47890: LD_VAR 0 7
47894: PUSH
47895: LD_VAR 0 1
47899: DIFF
47900: ST_TO_ADDR
// mc_vehicles := Replace ( mc_vehicles , i , tmp ) ;
47901: LD_ADDR_EXP 114
47905: PUSH
47906: LD_EXP 114
47910: PPUSH
47911: LD_VAR 0 6
47915: PPUSH
47916: LD_VAR 0 7
47920: PPUSH
47921: CALL_OW 1
47925: ST_TO_ADDR
// break ;
47926: GO 47930
// end ;
47928: GO 47824
47930: POP
47931: POP
// end ;
47932: LD_VAR 0 5
47936: RET
// export function MCE_VehicleConstructed ( vehicle , factory ) ; var i , side , tmp ; begin
47937: LD_INT 0
47939: PPUSH
47940: PPUSH
47941: PPUSH
47942: PPUSH
// if not mc_bases or not skirmish then
47943: LD_EXP 95
47947: NOT
47948: PUSH
47949: LD_EXP 93
47953: NOT
47954: OR
47955: IFFALSE 47959
// exit ;
47957: GO 48351
// side := GetSide ( vehicle ) ;
47959: LD_ADDR_VAR 0 5
47963: PUSH
47964: LD_VAR 0 1
47968: PPUSH
47969: CALL_OW 255
47973: ST_TO_ADDR
// for i = 1 to mc_bases do
47974: LD_ADDR_VAR 0 4
47978: PUSH
47979: DOUBLE
47980: LD_INT 1
47982: DEC
47983: ST_TO_ADDR
47984: LD_EXP 95
47988: PUSH
47989: FOR_TO
47990: IFFALSE 48349
// begin if factory in mc_bases [ i ] then
47992: LD_VAR 0 2
47996: PUSH
47997: LD_EXP 95
48001: PUSH
48002: LD_VAR 0 4
48006: ARRAY
48007: IN
48008: IFFALSE 48347
// begin if mc_defender [ i ] < mc_defender_limit [ i ] and not GetWeapon ( vehicle ) in [ ar_control_tower , ar_cargo_bay , ru_cargo_bay , ru_big_cargo_bay , us_cargo_bay , ar_radar , ru_radar , us_radar , ru_bulldozer , us_bulldozer , ar_bio_bomb , ar_selfpropelled_bomb , us_hack , us_crane , ru_crane , ar_crane , ru_siberium_rocket , us_siberium_rocket ] then
48010: LD_EXP 117
48014: PUSH
48015: LD_VAR 0 4
48019: ARRAY
48020: PUSH
48021: LD_EXP 106
48025: PUSH
48026: LD_VAR 0 4
48030: ARRAY
48031: LESS
48032: PUSH
48033: LD_VAR 0 1
48037: PPUSH
48038: CALL_OW 264
48042: PUSH
48043: LD_INT 31
48045: PUSH
48046: LD_INT 32
48048: PUSH
48049: LD_INT 51
48051: PUSH
48052: LD_EXP 75
48056: PUSH
48057: LD_INT 12
48059: PUSH
48060: LD_INT 30
48062: PUSH
48063: LD_EXP 74
48067: PUSH
48068: LD_INT 11
48070: PUSH
48071: LD_INT 53
48073: PUSH
48074: LD_INT 14
48076: PUSH
48077: LD_EXP 78
48081: PUSH
48082: LD_INT 29
48084: PUSH
48085: LD_EXP 76
48089: PUSH
48090: LD_INT 13
48092: PUSH
48093: LD_INT 52
48095: PUSH
48096: LD_EXP 80
48100: PUSH
48101: LD_INT 48
48103: PUSH
48104: LD_INT 8
48106: PUSH
48107: EMPTY
48108: LIST
48109: LIST
48110: LIST
48111: LIST
48112: LIST
48113: LIST
48114: LIST
48115: LIST
48116: LIST
48117: LIST
48118: LIST
48119: LIST
48120: LIST
48121: LIST
48122: LIST
48123: LIST
48124: LIST
48125: LIST
48126: IN
48127: NOT
48128: AND
48129: IFFALSE 48177
// mc_defender := ReplaceIn ( mc_defender , [ i , mc_defender [ i ] + 1 ] , vehicle ) else
48131: LD_ADDR_EXP 117
48135: PUSH
48136: LD_EXP 117
48140: PPUSH
48141: LD_VAR 0 4
48145: PUSH
48146: LD_EXP 117
48150: PUSH
48151: LD_VAR 0 4
48155: ARRAY
48156: PUSH
48157: LD_INT 1
48159: PLUS
48160: PUSH
48161: EMPTY
48162: LIST
48163: LIST
48164: PPUSH
48165: LD_VAR 0 1
48169: PPUSH
48170: CALL 57012 0 3
48174: ST_TO_ADDR
48175: GO 48221
// mc_vehicles := ReplaceIn ( mc_vehicles , [ i , mc_vehicles [ i ] + 1 ] , vehicle ) ;
48177: LD_ADDR_EXP 114
48181: PUSH
48182: LD_EXP 114
48186: PPUSH
48187: LD_VAR 0 4
48191: PUSH
48192: LD_EXP 114
48196: PUSH
48197: LD_VAR 0 4
48201: ARRAY
48202: PUSH
48203: LD_INT 1
48205: PLUS
48206: PUSH
48207: EMPTY
48208: LIST
48209: LIST
48210: PPUSH
48211: LD_VAR 0 1
48215: PPUSH
48216: CALL 57012 0 3
48220: ST_TO_ADDR
// if GetControl ( vehicle ) = control_remote then
48221: LD_VAR 0 1
48225: PPUSH
48226: CALL_OW 263
48230: PUSH
48231: LD_INT 2
48233: EQUAL
48234: IFFALSE 48263
// begin repeat wait ( 0 0$3 ) ;
48236: LD_INT 105
48238: PPUSH
48239: CALL_OW 67
// Connect ( vehicle ) ;
48243: LD_VAR 0 1
48247: PPUSH
48248: CALL 59983 0 1
// until IsControledBy ( vehicle ) ;
48252: LD_VAR 0 1
48256: PPUSH
48257: CALL_OW 312
48261: IFFALSE 48236
// end ; ComMoveToArea ( vehicle , mc_parking [ i ] ) ;
48263: LD_VAR 0 1
48267: PPUSH
48268: LD_EXP 119
48272: PUSH
48273: LD_VAR 0 4
48277: ARRAY
48278: PPUSH
48279: CALL_OW 113
// if GetControl ( vehicle ) <> control_manual then
48283: LD_VAR 0 1
48287: PPUSH
48288: CALL_OW 263
48292: PUSH
48293: LD_INT 1
48295: NONEQUAL
48296: IFFALSE 48300
// break ;
48298: GO 48349
// repeat wait ( 0 0$1 ) ;
48300: LD_INT 35
48302: PPUSH
48303: CALL_OW 67
// until IsInArea ( vehicle , mc_parking [ i ] ) ;
48307: LD_VAR 0 1
48311: PPUSH
48312: LD_EXP 119
48316: PUSH
48317: LD_VAR 0 4
48321: ARRAY
48322: PPUSH
48323: CALL_OW 308
48327: IFFALSE 48300
// ComExitVehicle ( IsDrivenBy ( vehicle ) ) ;
48329: LD_VAR 0 1
48333: PPUSH
48334: CALL_OW 311
48338: PPUSH
48339: CALL_OW 121
// exit ;
48343: POP
48344: POP
48345: GO 48351
// end ; end ;
48347: GO 47989
48349: POP
48350: POP
// end ;
48351: LD_VAR 0 3
48355: RET
// export function MCE_CrateSpawn ( id , x , y , amount , mode ) ; var i , j , depot ; begin
48356: LD_INT 0
48358: PPUSH
48359: PPUSH
48360: PPUSH
48361: PPUSH
// if not mc_bases or not skirmish then
48362: LD_EXP 95
48366: NOT
48367: PUSH
48368: LD_EXP 93
48372: NOT
48373: OR
48374: IFFALSE 48378
// exit ;
48376: GO 48731
// repeat wait ( 0 0$1 ) ;
48378: LD_INT 35
48380: PPUSH
48381: CALL_OW 67
// until GetResourceAmountXY ( x , y ) ;
48385: LD_VAR 0 2
48389: PPUSH
48390: LD_VAR 0 3
48394: PPUSH
48395: CALL_OW 284
48399: IFFALSE 48378
// if GetResourceTypeXY ( x , y ) = mat_artefact then
48401: LD_VAR 0 2
48405: PPUSH
48406: LD_VAR 0 3
48410: PPUSH
48411: CALL_OW 283
48415: PUSH
48416: LD_INT 4
48418: EQUAL
48419: IFFALSE 48423
// exit ;
48421: GO 48731
// for i = 1 to mc_bases do
48423: LD_ADDR_VAR 0 7
48427: PUSH
48428: DOUBLE
48429: LD_INT 1
48431: DEC
48432: ST_TO_ADDR
48433: LD_EXP 95
48437: PUSH
48438: FOR_TO
48439: IFFALSE 48729
// begin if mc_crates_area [ i ] then
48441: LD_EXP 113
48445: PUSH
48446: LD_VAR 0 7
48450: ARRAY
48451: IFFALSE 48562
// for j in mc_crates_area [ i ] do
48453: LD_ADDR_VAR 0 8
48457: PUSH
48458: LD_EXP 113
48462: PUSH
48463: LD_VAR 0 7
48467: ARRAY
48468: PUSH
48469: FOR_IN
48470: IFFALSE 48560
// if InArea ( x , y , j ) then
48472: LD_VAR 0 2
48476: PPUSH
48477: LD_VAR 0 3
48481: PPUSH
48482: LD_VAR 0 8
48486: PPUSH
48487: CALL_OW 309
48491: IFFALSE 48558
// begin mc_crates := ReplaceIn ( mc_crates , [ i , mc_crates [ i ] + 1 ] , [ amount , x , y ] ) ;
48493: LD_ADDR_EXP 111
48497: PUSH
48498: LD_EXP 111
48502: PPUSH
48503: LD_VAR 0 7
48507: PUSH
48508: LD_EXP 111
48512: PUSH
48513: LD_VAR 0 7
48517: ARRAY
48518: PUSH
48519: LD_INT 1
48521: PLUS
48522: PUSH
48523: EMPTY
48524: LIST
48525: LIST
48526: PPUSH
48527: LD_VAR 0 4
48531: PUSH
48532: LD_VAR 0 2
48536: PUSH
48537: LD_VAR 0 3
48541: PUSH
48542: EMPTY
48543: LIST
48544: LIST
48545: LIST
48546: PPUSH
48547: CALL 57012 0 3
48551: ST_TO_ADDR
// exit ;
48552: POP
48553: POP
48554: POP
48555: POP
48556: GO 48731
// end ;
48558: GO 48469
48560: POP
48561: POP
// depot := UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) ;
48562: LD_ADDR_VAR 0 9
48566: PUSH
48567: LD_EXP 95
48571: PUSH
48572: LD_VAR 0 7
48576: ARRAY
48577: PPUSH
48578: LD_INT 2
48580: PUSH
48581: LD_INT 30
48583: PUSH
48584: LD_INT 0
48586: PUSH
48587: EMPTY
48588: LIST
48589: LIST
48590: PUSH
48591: LD_INT 30
48593: PUSH
48594: LD_INT 1
48596: PUSH
48597: EMPTY
48598: LIST
48599: LIST
48600: PUSH
48601: EMPTY
48602: LIST
48603: LIST
48604: LIST
48605: PPUSH
48606: CALL_OW 72
48610: ST_TO_ADDR
// if not depot then
48611: LD_VAR 0 9
48615: NOT
48616: IFFALSE 48620
// continue ;
48618: GO 48438
// for j in depot do
48620: LD_ADDR_VAR 0 8
48624: PUSH
48625: LD_VAR 0 9
48629: PUSH
48630: FOR_IN
48631: IFFALSE 48725
// if GetDistUnitXY ( j , x , y ) < 30 then
48633: LD_VAR 0 8
48637: PPUSH
48638: LD_VAR 0 2
48642: PPUSH
48643: LD_VAR 0 3
48647: PPUSH
48648: CALL_OW 297
48652: PUSH
48653: LD_INT 30
48655: LESS
48656: IFFALSE 48723
// begin mc_crates := ReplaceIn ( mc_crates , [ i , mc_crates [ i ] + 1 ] , [ amount , x , y ] ) ;
48658: LD_ADDR_EXP 111
48662: PUSH
48663: LD_EXP 111
48667: PPUSH
48668: LD_VAR 0 7
48672: PUSH
48673: LD_EXP 111
48677: PUSH
48678: LD_VAR 0 7
48682: ARRAY
48683: PUSH
48684: LD_INT 1
48686: PLUS
48687: PUSH
48688: EMPTY
48689: LIST
48690: LIST
48691: PPUSH
48692: LD_VAR 0 4
48696: PUSH
48697: LD_VAR 0 2
48701: PUSH
48702: LD_VAR 0 3
48706: PUSH
48707: EMPTY
48708: LIST
48709: LIST
48710: LIST
48711: PPUSH
48712: CALL 57012 0 3
48716: ST_TO_ADDR
// exit ;
48717: POP
48718: POP
48719: POP
48720: POP
48721: GO 48731
// end ;
48723: GO 48630
48725: POP
48726: POP
// end ;
48727: GO 48438
48729: POP
48730: POP
// end ;
48731: LD_VAR 0 6
48735: RET
// export function MCE_ResearchComplete ( tech , lab ) ; var side , i , tmp ; begin
48736: LD_INT 0
48738: PPUSH
48739: PPUSH
48740: PPUSH
48741: PPUSH
// if not mc_bases or not skirmish then
48742: LD_EXP 95
48746: NOT
48747: PUSH
48748: LD_EXP 93
48752: NOT
48753: OR
48754: IFFALSE 48758
// exit ;
48756: GO 49035
// side := GetSide ( lab ) ;
48758: LD_ADDR_VAR 0 4
48762: PUSH
48763: LD_VAR 0 2
48767: PPUSH
48768: CALL_OW 255
48772: ST_TO_ADDR
// if not side in mc_sides or not mc_tech or not mc_bases then
48773: LD_VAR 0 4
48777: PUSH
48778: LD_EXP 121
48782: IN
48783: NOT
48784: PUSH
48785: LD_EXP 122
48789: NOT
48790: OR
48791: PUSH
48792: LD_EXP 95
48796: NOT
48797: OR
48798: IFFALSE 48802
// exit ;
48800: GO 49035
// mc_tech := Replace ( mc_tech , side , mc_tech [ side ] diff tech ) ;
48802: LD_ADDR_EXP 122
48806: PUSH
48807: LD_EXP 122
48811: PPUSH
48812: LD_VAR 0 4
48816: PPUSH
48817: LD_EXP 122
48821: PUSH
48822: LD_VAR 0 4
48826: ARRAY
48827: PUSH
48828: LD_VAR 0 1
48832: DIFF
48833: PPUSH
48834: CALL_OW 1
48838: ST_TO_ADDR
// for i = 1 to mc_bases do
48839: LD_ADDR_VAR 0 5
48843: PUSH
48844: DOUBLE
48845: LD_INT 1
48847: DEC
48848: ST_TO_ADDR
48849: LD_EXP 95
48853: PUSH
48854: FOR_TO
48855: IFFALSE 49033
// begin if lab in mc_bases [ i ] then
48857: LD_VAR 0 2
48861: PUSH
48862: LD_EXP 95
48866: PUSH
48867: LD_VAR 0 5
48871: ARRAY
48872: IN
48873: IFFALSE 49031
// begin if tech in [ tech_apeagres , tech_apebrain , tech_apeneural , tech_apepsych ] and mc_ape_in_lab [ i ] then
48875: LD_VAR 0 1
48879: PUSH
48880: LD_INT 11
48882: PUSH
48883: LD_INT 4
48885: PUSH
48886: LD_INT 3
48888: PUSH
48889: LD_INT 2
48891: PUSH
48892: EMPTY
48893: LIST
48894: LIST
48895: LIST
48896: LIST
48897: IN
48898: PUSH
48899: LD_EXP 125
48903: PUSH
48904: LD_VAR 0 5
48908: ARRAY
48909: AND
48910: IFFALSE 49031
// begin tmp := mc_ape_in_lab [ i ] [ 1 ] ;
48912: LD_ADDR_VAR 0 6
48916: PUSH
48917: LD_EXP 125
48921: PUSH
48922: LD_VAR 0 5
48926: ARRAY
48927: PUSH
48928: LD_INT 1
48930: ARRAY
48931: ST_TO_ADDR
// mc_ape_in_lab := Replace ( mc_ape_in_lab , i , [ ] ) ;
48932: LD_ADDR_EXP 125
48936: PUSH
48937: LD_EXP 125
48941: PPUSH
48942: LD_VAR 0 5
48946: PPUSH
48947: EMPTY
48948: PPUSH
48949: CALL_OW 1
48953: ST_TO_ADDR
// SetTag ( tmp , 0 ) ;
48954: LD_VAR 0 6
48958: PPUSH
48959: LD_INT 0
48961: PPUSH
48962: CALL_OW 109
// ComExitBuilding ( tmp ) ;
48966: LD_VAR 0 6
48970: PPUSH
48971: CALL_OW 122
// mc_ape := Replace ( mc_ape , i , Insert ( mc_ape [ i ] , 1 , tmp ) ) ;
48975: LD_ADDR_EXP 124
48979: PUSH
48980: LD_EXP 124
48984: PPUSH
48985: LD_VAR 0 5
48989: PPUSH
48990: LD_EXP 124
48994: PUSH
48995: LD_VAR 0 5
48999: ARRAY
49000: PPUSH
49001: LD_INT 1
49003: PPUSH
49004: LD_VAR 0 6
49008: PPUSH
49009: CALL_OW 2
49013: PPUSH
49014: CALL_OW 1
49018: ST_TO_ADDR
// MC_Reset ( i , 112 ) ;
49019: LD_VAR 0 5
49023: PPUSH
49024: LD_INT 112
49026: PPUSH
49027: CALL 25554 0 2
// end ; end ; end ;
49031: GO 48854
49033: POP
49034: POP
// end ;
49035: LD_VAR 0 3
49039: RET
// export function MCE_UnitDestroyed ( un ) ; var i , j , btype , pos , tmp , fac , components ; begin
49040: LD_INT 0
49042: PPUSH
49043: PPUSH
49044: PPUSH
49045: PPUSH
49046: PPUSH
49047: PPUSH
49048: PPUSH
49049: PPUSH
// if not mc_bases or not skirmish then
49050: LD_EXP 95
49054: NOT
49055: PUSH
49056: LD_EXP 93
49060: NOT
49061: OR
49062: IFFALSE 49066
// exit ;
49064: GO 50437
// for i = 1 to mc_bases do
49066: LD_ADDR_VAR 0 3
49070: PUSH
49071: DOUBLE
49072: LD_INT 1
49074: DEC
49075: ST_TO_ADDR
49076: LD_EXP 95
49080: PUSH
49081: FOR_TO
49082: IFFALSE 50435
// if un in mc_bases [ i ] or un in mc_construct_list [ i ] or un in mc_defender [ i ] or un in mc_vehicles [ i ] or un in mc_ape [ i ] or un in mc_ape_in_lab [ i ] then
49084: LD_VAR 0 1
49088: PUSH
49089: LD_EXP 95
49093: PUSH
49094: LD_VAR 0 3
49098: ARRAY
49099: IN
49100: PUSH
49101: LD_VAR 0 1
49105: PUSH
49106: LD_EXP 102
49110: PUSH
49111: LD_VAR 0 3
49115: ARRAY
49116: IN
49117: OR
49118: PUSH
49119: LD_VAR 0 1
49123: PUSH
49124: LD_EXP 117
49128: PUSH
49129: LD_VAR 0 3
49133: ARRAY
49134: IN
49135: OR
49136: PUSH
49137: LD_VAR 0 1
49141: PUSH
49142: LD_EXP 114
49146: PUSH
49147: LD_VAR 0 3
49151: ARRAY
49152: IN
49153: OR
49154: PUSH
49155: LD_VAR 0 1
49159: PUSH
49160: LD_EXP 124
49164: PUSH
49165: LD_VAR 0 3
49169: ARRAY
49170: IN
49171: OR
49172: PUSH
49173: LD_VAR 0 1
49177: PUSH
49178: LD_EXP 125
49182: PUSH
49183: LD_VAR 0 3
49187: ARRAY
49188: IN
49189: OR
49190: IFFALSE 50433
// begin if un in mc_ape [ i ] then
49192: LD_VAR 0 1
49196: PUSH
49197: LD_EXP 124
49201: PUSH
49202: LD_VAR 0 3
49206: ARRAY
49207: IN
49208: IFFALSE 49247
// begin mc_ape := Replace ( mc_ape , i , mc_ape [ i ] diff un ) ;
49210: LD_ADDR_EXP 124
49214: PUSH
49215: LD_EXP 124
49219: PPUSH
49220: LD_VAR 0 3
49224: PPUSH
49225: LD_EXP 124
49229: PUSH
49230: LD_VAR 0 3
49234: ARRAY
49235: PUSH
49236: LD_VAR 0 1
49240: DIFF
49241: PPUSH
49242: CALL_OW 1
49246: ST_TO_ADDR
// end ; if un in mc_ape_in_lab [ i ] then
49247: LD_VAR 0 1
49251: PUSH
49252: LD_EXP 125
49256: PUSH
49257: LD_VAR 0 3
49261: ARRAY
49262: IN
49263: IFFALSE 49287
// begin mc_ape_in_lab := Replace ( mc_ape_in_lab , i , [ ] ) ;
49265: LD_ADDR_EXP 125
49269: PUSH
49270: LD_EXP 125
49274: PPUSH
49275: LD_VAR 0 3
49279: PPUSH
49280: EMPTY
49281: PPUSH
49282: CALL_OW 1
49286: ST_TO_ADDR
// end ; if GetType ( un ) = unit_vehicle and ( GetTag ( un ) = 20 or un in mc_defender [ i ] or GetWeapon ( un ) in [ us_cargo_bay , ru_cargo_bay , ru_big_cargo_bay , ar_cargo_bay , us_crane , ru_crane , ar_control_tower ] ) then
49287: LD_VAR 0 1
49291: PPUSH
49292: CALL_OW 247
49296: PUSH
49297: LD_INT 2
49299: EQUAL
49300: PUSH
49301: LD_VAR 0 1
49305: PPUSH
49306: CALL_OW 110
49310: PUSH
49311: LD_INT 20
49313: EQUAL
49314: PUSH
49315: LD_VAR 0 1
49319: PUSH
49320: LD_EXP 117
49324: PUSH
49325: LD_VAR 0 3
49329: ARRAY
49330: IN
49331: OR
49332: PUSH
49333: LD_VAR 0 1
49337: PPUSH
49338: CALL_OW 264
49342: PUSH
49343: LD_INT 12
49345: PUSH
49346: LD_INT 51
49348: PUSH
49349: LD_EXP 75
49353: PUSH
49354: LD_INT 32
49356: PUSH
49357: LD_INT 13
49359: PUSH
49360: LD_INT 52
49362: PUSH
49363: LD_INT 31
49365: PUSH
49366: EMPTY
49367: LIST
49368: LIST
49369: LIST
49370: LIST
49371: LIST
49372: LIST
49373: LIST
49374: IN
49375: OR
49376: AND
49377: IFFALSE 49685
// begin if un in mc_defender [ i ] then
49379: LD_VAR 0 1
49383: PUSH
49384: LD_EXP 117
49388: PUSH
49389: LD_VAR 0 3
49393: ARRAY
49394: IN
49395: IFFALSE 49434
// mc_defender := Replace ( mc_defender , i , mc_defender [ i ] diff un ) ;
49397: LD_ADDR_EXP 117
49401: PUSH
49402: LD_EXP 117
49406: PPUSH
49407: LD_VAR 0 3
49411: PPUSH
49412: LD_EXP 117
49416: PUSH
49417: LD_VAR 0 3
49421: ARRAY
49422: PUSH
49423: LD_VAR 0 1
49427: DIFF
49428: PPUSH
49429: CALL_OW 1
49433: ST_TO_ADDR
// fac := MC_GetBuildings ( i , b_factory ) ;
49434: LD_ADDR_VAR 0 8
49438: PUSH
49439: LD_VAR 0 3
49443: PPUSH
49444: LD_INT 3
49446: PPUSH
49447: CALL 46075 0 2
49451: ST_TO_ADDR
// if fac then
49452: LD_VAR 0 8
49456: IFFALSE 49685
// begin for j in fac do
49458: LD_ADDR_VAR 0 4
49462: PUSH
49463: LD_VAR 0 8
49467: PUSH
49468: FOR_IN
49469: IFFALSE 49683
// begin components := Produce ( fac , GetChassis ( un ) , GetEngine ( un ) , GetControl ( un ) , GetWeapon ( un ) ) ;
49471: LD_ADDR_VAR 0 9
49475: PUSH
49476: LD_VAR 0 8
49480: PPUSH
49481: LD_VAR 0 1
49485: PPUSH
49486: CALL_OW 265
49490: PPUSH
49491: LD_VAR 0 1
49495: PPUSH
49496: CALL_OW 262
49500: PPUSH
49501: LD_VAR 0 1
49505: PPUSH
49506: CALL_OW 263
49510: PPUSH
49511: LD_VAR 0 1
49515: PPUSH
49516: CALL_OW 264
49520: PPUSH
49521: CALL 54508 0 5
49525: ST_TO_ADDR
// if components then
49526: LD_VAR 0 9
49530: IFFALSE 49681
// begin if GetWeapon ( un ) = ar_control_tower then
49532: LD_VAR 0 1
49536: PPUSH
49537: CALL_OW 264
49541: PUSH
49542: LD_INT 31
49544: EQUAL
49545: IFFALSE 49662
// begin SetTag ( IsDrivenBy ( un ) , 0 ) ;
49547: LD_VAR 0 1
49551: PPUSH
49552: CALL_OW 311
49556: PPUSH
49557: LD_INT 0
49559: PPUSH
49560: CALL_OW 109
// mc_remote_driver := Replace ( mc_remote_driver , i , mc_remote_driver [ i ] diff IsDrivenBy ( un ) ) ;
49564: LD_ADDR_EXP 135
49568: PUSH
49569: LD_EXP 135
49573: PPUSH
49574: LD_VAR 0 3
49578: PPUSH
49579: LD_EXP 135
49583: PUSH
49584: LD_VAR 0 3
49588: ARRAY
49589: PUSH
49590: LD_VAR 0 1
49594: PPUSH
49595: CALL_OW 311
49599: DIFF
49600: PPUSH
49601: CALL_OW 1
49605: ST_TO_ADDR
// tmp := Insert ( mc_produce [ i ] , 1 , components ) ;
49606: LD_ADDR_VAR 0 7
49610: PUSH
49611: LD_EXP 116
49615: PUSH
49616: LD_VAR 0 3
49620: ARRAY
49621: PPUSH
49622: LD_INT 1
49624: PPUSH
49625: LD_VAR 0 9
49629: PPUSH
49630: CALL_OW 2
49634: ST_TO_ADDR
// mc_produce := Replace ( mc_produce , i , tmp ) ;
49635: LD_ADDR_EXP 116
49639: PUSH
49640: LD_EXP 116
49644: PPUSH
49645: LD_VAR 0 3
49649: PPUSH
49650: LD_VAR 0 7
49654: PPUSH
49655: CALL_OW 1
49659: ST_TO_ADDR
// end else
49660: GO 49679
// MC_InsertProduceList ( i , [ components ] ) ;
49662: LD_VAR 0 3
49666: PPUSH
49667: LD_VAR 0 9
49671: PUSH
49672: EMPTY
49673: LIST
49674: PPUSH
49675: CALL 45620 0 2
// break ;
49679: GO 49683
// end ; end ;
49681: GO 49468
49683: POP
49684: POP
// end ; end ; if GetType ( un ) = unit_building then
49685: LD_VAR 0 1
49689: PPUSH
49690: CALL_OW 247
49694: PUSH
49695: LD_INT 3
49697: EQUAL
49698: IFFALSE 50101
// begin btype := GetBType ( un ) ;
49700: LD_ADDR_VAR 0 5
49704: PUSH
49705: LD_VAR 0 1
49709: PPUSH
49710: CALL_OW 266
49714: ST_TO_ADDR
// if btype in [ b_oil_mine , b_siberite_mine ] then
49715: LD_VAR 0 5
49719: PUSH
49720: LD_INT 29
49722: PUSH
49723: LD_INT 30
49725: PUSH
49726: EMPTY
49727: LIST
49728: LIST
49729: IN
49730: IFFALSE 49803
// begin if not GetResourceVisibility ( GetX ( un ) , GetY ( un ) , GetSide ( un ) ) then
49732: LD_VAR 0 1
49736: PPUSH
49737: CALL_OW 250
49741: PPUSH
49742: LD_VAR 0 1
49746: PPUSH
49747: CALL_OW 251
49751: PPUSH
49752: LD_VAR 0 1
49756: PPUSH
49757: CALL_OW 255
49761: PPUSH
49762: CALL_OW 440
49766: NOT
49767: IFFALSE 49803
// SetResourceVisibility ( GetX ( un ) , GetY ( un ) , GetSide ( un ) ) ;
49769: LD_VAR 0 1
49773: PPUSH
49774: CALL_OW 250
49778: PPUSH
49779: LD_VAR 0 1
49783: PPUSH
49784: CALL_OW 251
49788: PPUSH
49789: LD_VAR 0 1
49793: PPUSH
49794: CALL_OW 255
49798: PPUSH
49799: CALL_OW 441
// end ; if btype = b_warehouse then
49803: LD_VAR 0 5
49807: PUSH
49808: LD_INT 1
49810: EQUAL
49811: IFFALSE 49829
// begin btype := b_depot ;
49813: LD_ADDR_VAR 0 5
49817: PUSH
49818: LD_INT 0
49820: ST_TO_ADDR
// pos := 1 ;
49821: LD_ADDR_VAR 0 6
49825: PUSH
49826: LD_INT 1
49828: ST_TO_ADDR
// end ; if btype = b_factory then
49829: LD_VAR 0 5
49833: PUSH
49834: LD_INT 3
49836: EQUAL
49837: IFFALSE 49855
// begin btype := b_workshop ;
49839: LD_ADDR_VAR 0 5
49843: PUSH
49844: LD_INT 2
49846: ST_TO_ADDR
// pos := 1 ;
49847: LD_ADDR_VAR 0 6
49851: PUSH
49852: LD_INT 1
49854: ST_TO_ADDR
// end ; if btype = b_barracks then
49855: LD_VAR 0 5
49859: PUSH
49860: LD_INT 5
49862: EQUAL
49863: IFFALSE 49873
// btype := b_armoury ;
49865: LD_ADDR_VAR 0 5
49869: PUSH
49870: LD_INT 4
49872: ST_TO_ADDR
// if btype in [ b_lab_half , b_lab_full ] then
49873: LD_VAR 0 5
49877: PUSH
49878: LD_INT 7
49880: PUSH
49881: LD_INT 8
49883: PUSH
49884: EMPTY
49885: LIST
49886: LIST
49887: IN
49888: IFFALSE 49898
// btype := b_lab ;
49890: LD_ADDR_VAR 0 5
49894: PUSH
49895: LD_INT 6
49897: ST_TO_ADDR
// mc_build_list := ReplaceIn ( mc_build_list , [ i , mc_build_list [ i ] + 1 ] , [ btype , GetX ( un ) , GetY ( un ) , GetDir ( un ) ] ) ;
49898: LD_ADDR_EXP 100
49902: PUSH
49903: LD_EXP 100
49907: PPUSH
49908: LD_VAR 0 3
49912: PUSH
49913: LD_EXP 100
49917: PUSH
49918: LD_VAR 0 3
49922: ARRAY
49923: PUSH
49924: LD_INT 1
49926: PLUS
49927: PUSH
49928: EMPTY
49929: LIST
49930: LIST
49931: PPUSH
49932: LD_VAR 0 5
49936: PUSH
49937: LD_VAR 0 1
49941: PPUSH
49942: CALL_OW 250
49946: PUSH
49947: LD_VAR 0 1
49951: PPUSH
49952: CALL_OW 251
49956: PUSH
49957: LD_VAR 0 1
49961: PPUSH
49962: CALL_OW 254
49966: PUSH
49967: EMPTY
49968: LIST
49969: LIST
49970: LIST
49971: LIST
49972: PPUSH
49973: CALL 57012 0 3
49977: ST_TO_ADDR
// if pos = 1 then
49978: LD_VAR 0 6
49982: PUSH
49983: LD_INT 1
49985: EQUAL
49986: IFFALSE 50101
// begin tmp := mc_build_list [ i ] ;
49988: LD_ADDR_VAR 0 7
49992: PUSH
49993: LD_EXP 100
49997: PUSH
49998: LD_VAR 0 3
50002: ARRAY
50003: ST_TO_ADDR
// if UnitFilter ( tmp , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) then
50004: LD_VAR 0 7
50008: PPUSH
50009: LD_INT 2
50011: PUSH
50012: LD_INT 30
50014: PUSH
50015: LD_INT 0
50017: PUSH
50018: EMPTY
50019: LIST
50020: LIST
50021: PUSH
50022: LD_INT 30
50024: PUSH
50025: LD_INT 1
50027: PUSH
50028: EMPTY
50029: LIST
50030: LIST
50031: PUSH
50032: EMPTY
50033: LIST
50034: LIST
50035: LIST
50036: PPUSH
50037: CALL_OW 72
50041: IFFALSE 50051
// pos := 2 ;
50043: LD_ADDR_VAR 0 6
50047: PUSH
50048: LD_INT 2
50050: ST_TO_ADDR
// tmp := ReplaceWith ( tmp , pos , tmp ) ;
50051: LD_ADDR_VAR 0 7
50055: PUSH
50056: LD_VAR 0 7
50060: PPUSH
50061: LD_VAR 0 6
50065: PPUSH
50066: LD_VAR 0 7
50070: PPUSH
50071: CALL 57338 0 3
50075: ST_TO_ADDR
// mc_build_list := Replace ( mc_build_list , i , tmp ) ;
50076: LD_ADDR_EXP 100
50080: PUSH
50081: LD_EXP 100
50085: PPUSH
50086: LD_VAR 0 3
50090: PPUSH
50091: LD_VAR 0 7
50095: PPUSH
50096: CALL_OW 1
50100: ST_TO_ADDR
// end ; end ; if un in mc_bases [ i ] then
50101: LD_VAR 0 1
50105: PUSH
50106: LD_EXP 95
50110: PUSH
50111: LD_VAR 0 3
50115: ARRAY
50116: IN
50117: IFFALSE 50156
// begin mc_bases := Replace ( mc_bases , i , mc_bases [ i ] diff un ) ;
50119: LD_ADDR_EXP 95
50123: PUSH
50124: LD_EXP 95
50128: PPUSH
50129: LD_VAR 0 3
50133: PPUSH
50134: LD_EXP 95
50138: PUSH
50139: LD_VAR 0 3
50143: ARRAY
50144: PUSH
50145: LD_VAR 0 1
50149: DIFF
50150: PPUSH
50151: CALL_OW 1
50155: ST_TO_ADDR
// end ; if un in mc_construct_list [ i ] then
50156: LD_VAR 0 1
50160: PUSH
50161: LD_EXP 102
50165: PUSH
50166: LD_VAR 0 3
50170: ARRAY
50171: IN
50172: IFFALSE 50211
// begin mc_construct_list := Replace ( mc_construct_list , i , mc_construct_list [ i ] diff un ) ;
50174: LD_ADDR_EXP 102
50178: PUSH
50179: LD_EXP 102
50183: PPUSH
50184: LD_VAR 0 3
50188: PPUSH
50189: LD_EXP 102
50193: PUSH
50194: LD_VAR 0 3
50198: ARRAY
50199: PUSH
50200: LD_VAR 0 1
50204: DIFF
50205: PPUSH
50206: CALL_OW 1
50210: ST_TO_ADDR
// end ; if un in mc_vehicles [ i ] then
50211: LD_VAR 0 1
50215: PUSH
50216: LD_EXP 114
50220: PUSH
50221: LD_VAR 0 3
50225: ARRAY
50226: IN
50227: IFFALSE 50266
// begin mc_vehicles := Replace ( mc_vehicles , i , mc_vehicles [ i ] diff un ) ;
50229: LD_ADDR_EXP 114
50233: PUSH
50234: LD_EXP 114
50238: PPUSH
50239: LD_VAR 0 3
50243: PPUSH
50244: LD_EXP 114
50248: PUSH
50249: LD_VAR 0 3
50253: ARRAY
50254: PUSH
50255: LD_VAR 0 1
50259: DIFF
50260: PPUSH
50261: CALL_OW 1
50265: ST_TO_ADDR
// end ; if un in mc_defender [ i ] then
50266: LD_VAR 0 1
50270: PUSH
50271: LD_EXP 117
50275: PUSH
50276: LD_VAR 0 3
50280: ARRAY
50281: IN
50282: IFFALSE 50321
// begin mc_defender := Replace ( mc_defender , i , mc_defender [ i ] diff un ) ;
50284: LD_ADDR_EXP 117
50288: PUSH
50289: LD_EXP 117
50293: PPUSH
50294: LD_VAR 0 3
50298: PPUSH
50299: LD_EXP 117
50303: PUSH
50304: LD_VAR 0 3
50308: ARRAY
50309: PUSH
50310: LD_VAR 0 1
50314: DIFF
50315: PPUSH
50316: CALL_OW 1
50320: ST_TO_ADDR
// end ; if un in mc_empty_turret_list [ i ] then
50321: LD_VAR 0 1
50325: PUSH
50326: LD_EXP 104
50330: PUSH
50331: LD_VAR 0 3
50335: ARRAY
50336: IN
50337: IFFALSE 50376
// begin mc_empty_turret_list := Replace ( mc_empty_turret_list , i , mc_empty_turret_list [ i ] diff un ) ;
50339: LD_ADDR_EXP 104
50343: PUSH
50344: LD_EXP 104
50348: PPUSH
50349: LD_VAR 0 3
50353: PPUSH
50354: LD_EXP 104
50358: PUSH
50359: LD_VAR 0 3
50363: ARRAY
50364: PUSH
50365: LD_VAR 0 1
50369: DIFF
50370: PPUSH
50371: CALL_OW 1
50375: ST_TO_ADDR
// end ; if un in mc_turret_list [ i ] then
50376: LD_VAR 0 1
50380: PUSH
50381: LD_EXP 103
50385: PUSH
50386: LD_VAR 0 3
50390: ARRAY
50391: IN
50392: IFFALSE 50431
// begin mc_turret_list := Replace ( mc_turret_list , i , mc_turret_list [ i ] diff un ) ;
50394: LD_ADDR_EXP 103
50398: PUSH
50399: LD_EXP 103
50403: PPUSH
50404: LD_VAR 0 3
50408: PPUSH
50409: LD_EXP 103
50413: PUSH
50414: LD_VAR 0 3
50418: ARRAY
50419: PUSH
50420: LD_VAR 0 1
50424: DIFF
50425: PPUSH
50426: CALL_OW 1
50430: ST_TO_ADDR
// end ; break ;
50431: GO 50435
// end ;
50433: GO 49081
50435: POP
50436: POP
// end ;
50437: LD_VAR 0 2
50441: RET
// export function MCE_UpgradeComplete ( building ) ; var i , j ; begin
50442: LD_INT 0
50444: PPUSH
50445: PPUSH
50446: PPUSH
// if not mc_bases or not skirmish then
50447: LD_EXP 95
50451: NOT
50452: PUSH
50453: LD_EXP 93
50457: NOT
50458: OR
50459: IFFALSE 50463
// exit ;
50461: GO 50678
// for i = 1 to mc_bases do
50463: LD_ADDR_VAR 0 3
50467: PUSH
50468: DOUBLE
50469: LD_INT 1
50471: DEC
50472: ST_TO_ADDR
50473: LD_EXP 95
50477: PUSH
50478: FOR_TO
50479: IFFALSE 50676
// begin if building in mc_construct_list [ i ] then
50481: LD_VAR 0 1
50485: PUSH
50486: LD_EXP 102
50490: PUSH
50491: LD_VAR 0 3
50495: ARRAY
50496: IN
50497: IFFALSE 50674
// begin mc_construct_list := Replace ( mc_construct_list , i , mc_construct_list [ i ] diff building ) ;
50499: LD_ADDR_EXP 102
50503: PUSH
50504: LD_EXP 102
50508: PPUSH
50509: LD_VAR 0 3
50513: PPUSH
50514: LD_EXP 102
50518: PUSH
50519: LD_VAR 0 3
50523: ARRAY
50524: PUSH
50525: LD_VAR 0 1
50529: DIFF
50530: PPUSH
50531: CALL_OW 1
50535: ST_TO_ADDR
// if building in mc_lab [ i ] then
50536: LD_VAR 0 1
50540: PUSH
50541: LD_EXP 128
50545: PUSH
50546: LD_VAR 0 3
50550: ARRAY
50551: IN
50552: IFFALSE 50607
// mc_lab_upgrade := Replace ( mc_lab_upgrade , i , Reindex ( mc_lab_upgrade [ i ] , 1 , mc_lab_upgrade [ i ] , false ) ) ;
50554: LD_ADDR_EXP 129
50558: PUSH
50559: LD_EXP 129
50563: PPUSH
50564: LD_VAR 0 3
50568: PPUSH
50569: LD_EXP 129
50573: PUSH
50574: LD_VAR 0 3
50578: ARRAY
50579: PPUSH
50580: LD_INT 1
50582: PPUSH
50583: LD_EXP 129
50587: PUSH
50588: LD_VAR 0 3
50592: ARRAY
50593: PPUSH
50594: LD_INT 0
50596: PPUSH
50597: CALL 56430 0 4
50601: PPUSH
50602: CALL_OW 1
50606: ST_TO_ADDR
// if not building in mc_bases [ i ] then
50607: LD_VAR 0 1
50611: PUSH
50612: LD_EXP 95
50616: PUSH
50617: LD_VAR 0 3
50621: ARRAY
50622: IN
50623: NOT
50624: IFFALSE 50670
// mc_bases := ReplaceIn ( mc_bases , [ i , mc_bases [ i ] + 1 ] , building ) ;
50626: LD_ADDR_EXP 95
50630: PUSH
50631: LD_EXP 95
50635: PPUSH
50636: LD_VAR 0 3
50640: PUSH
50641: LD_EXP 95
50645: PUSH
50646: LD_VAR 0 3
50650: ARRAY
50651: PUSH
50652: LD_INT 1
50654: PLUS
50655: PUSH
50656: EMPTY
50657: LIST
50658: LIST
50659: PPUSH
50660: LD_VAR 0 1
50664: PPUSH
50665: CALL 57012 0 3
50669: ST_TO_ADDR
// exit ;
50670: POP
50671: POP
50672: GO 50678
// end ; end ;
50674: GO 50478
50676: POP
50677: POP
// end ;
50678: LD_VAR 0 2
50682: RET
// export function MCE_BuildingComplete ( building ) ; var i , j , btype , tmp , units , side ; begin
50683: LD_INT 0
50685: PPUSH
50686: PPUSH
50687: PPUSH
50688: PPUSH
50689: PPUSH
50690: PPUSH
50691: PPUSH
// if not mc_bases or not skirmish then
50692: LD_EXP 95
50696: NOT
50697: PUSH
50698: LD_EXP 93
50702: NOT
50703: OR
50704: IFFALSE 50708
// exit ;
50706: GO 51369
// for i = 1 to mc_bases do
50708: LD_ADDR_VAR 0 3
50712: PUSH
50713: DOUBLE
50714: LD_INT 1
50716: DEC
50717: ST_TO_ADDR
50718: LD_EXP 95
50722: PUSH
50723: FOR_TO
50724: IFFALSE 51367
// begin if building in mc_construct_list [ i ] then
50726: LD_VAR 0 1
50730: PUSH
50731: LD_EXP 102
50735: PUSH
50736: LD_VAR 0 3
50740: ARRAY
50741: IN
50742: IFFALSE 51365
// begin mc_construct_list := Replace ( mc_construct_list , i , mc_construct_list [ i ] diff building ) ;
50744: LD_ADDR_EXP 102
50748: PUSH
50749: LD_EXP 102
50753: PPUSH
50754: LD_VAR 0 3
50758: PPUSH
50759: LD_EXP 102
50763: PUSH
50764: LD_VAR 0 3
50768: ARRAY
50769: PUSH
50770: LD_VAR 0 1
50774: DIFF
50775: PPUSH
50776: CALL_OW 1
50780: ST_TO_ADDR
// mc_bases := ReplaceIn ( mc_bases , [ i , mc_bases [ i ] + 1 ] , building ) ;
50781: LD_ADDR_EXP 95
50785: PUSH
50786: LD_EXP 95
50790: PPUSH
50791: LD_VAR 0 3
50795: PUSH
50796: LD_EXP 95
50800: PUSH
50801: LD_VAR 0 3
50805: ARRAY
50806: PUSH
50807: LD_INT 1
50809: PLUS
50810: PUSH
50811: EMPTY
50812: LIST
50813: LIST
50814: PPUSH
50815: LD_VAR 0 1
50819: PPUSH
50820: CALL 57012 0 3
50824: ST_TO_ADDR
// btype := GetBType ( building ) ;
50825: LD_ADDR_VAR 0 5
50829: PUSH
50830: LD_VAR 0 1
50834: PPUSH
50835: CALL_OW 266
50839: ST_TO_ADDR
// side := GetSide ( building ) ;
50840: LD_ADDR_VAR 0 8
50844: PUSH
50845: LD_VAR 0 1
50849: PPUSH
50850: CALL_OW 255
50854: ST_TO_ADDR
// if btype = b_lab then
50855: LD_VAR 0 5
50859: PUSH
50860: LD_INT 6
50862: EQUAL
50863: IFFALSE 50913
// begin mc_lab := ReplaceIn ( mc_lab , [ i , mc_lab [ i ] + 1 ] , building ) ;
50865: LD_ADDR_EXP 128
50869: PUSH
50870: LD_EXP 128
50874: PPUSH
50875: LD_VAR 0 3
50879: PUSH
50880: LD_EXP 128
50884: PUSH
50885: LD_VAR 0 3
50889: ARRAY
50890: PUSH
50891: LD_INT 1
50893: PLUS
50894: PUSH
50895: EMPTY
50896: LIST
50897: LIST
50898: PPUSH
50899: LD_VAR 0 1
50903: PPUSH
50904: CALL 57012 0 3
50908: ST_TO_ADDR
// exit ;
50909: POP
50910: POP
50911: GO 51369
// end ; if btype in [ b_depot , b_workshop , b_armoury ] then
50913: LD_VAR 0 5
50917: PUSH
50918: LD_INT 0
50920: PUSH
50921: LD_INT 2
50923: PUSH
50924: LD_INT 4
50926: PUSH
50927: EMPTY
50928: LIST
50929: LIST
50930: LIST
50931: IN
50932: IFFALSE 51056
// begin if btype = b_armoury then
50934: LD_VAR 0 5
50938: PUSH
50939: LD_INT 4
50941: EQUAL
50942: IFFALSE 50952
// btype := b_barracks ;
50944: LD_ADDR_VAR 0 5
50948: PUSH
50949: LD_INT 5
50951: ST_TO_ADDR
// if btype = b_depot then
50952: LD_VAR 0 5
50956: PUSH
50957: LD_INT 0
50959: EQUAL
50960: IFFALSE 50970
// btype := b_warehouse ;
50962: LD_ADDR_VAR 0 5
50966: PUSH
50967: LD_INT 1
50969: ST_TO_ADDR
// if btype = b_workshop then
50970: LD_VAR 0 5
50974: PUSH
50975: LD_INT 2
50977: EQUAL
50978: IFFALSE 50988
// btype := b_factory ;
50980: LD_ADDR_VAR 0 5
50984: PUSH
50985: LD_INT 3
50987: ST_TO_ADDR
// if GetRestrict ( btype , side ) = state_enabled then
50988: LD_VAR 0 5
50992: PPUSH
50993: LD_VAR 0 8
50997: PPUSH
50998: CALL_OW 323
51002: PUSH
51003: LD_INT 1
51005: EQUAL
51006: IFFALSE 51052
// mc_build_upgrade := ReplaceIn ( mc_build_upgrade , [ i , mc_build_upgrade [ i ] + 1 ] , building ) ;
51008: LD_ADDR_EXP 127
51012: PUSH
51013: LD_EXP 127
51017: PPUSH
51018: LD_VAR 0 3
51022: PUSH
51023: LD_EXP 127
51027: PUSH
51028: LD_VAR 0 3
51032: ARRAY
51033: PUSH
51034: LD_INT 1
51036: PLUS
51037: PUSH
51038: EMPTY
51039: LIST
51040: LIST
51041: PPUSH
51042: LD_VAR 0 1
51046: PPUSH
51047: CALL 57012 0 3
51051: ST_TO_ADDR
// exit ;
51052: POP
51053: POP
51054: GO 51369
// end ; if btype in [ b_bunker , b_turret ] then
51056: LD_VAR 0 5
51060: PUSH
51061: LD_INT 32
51063: PUSH
51064: LD_INT 33
51066: PUSH
51067: EMPTY
51068: LIST
51069: LIST
51070: IN
51071: IFFALSE 51361
// begin mc_turret_list := ReplaceIn ( mc_turret_list , [ i , mc_turret_list [ i ] + 1 ] , building ) ;
51073: LD_ADDR_EXP 103
51077: PUSH
51078: LD_EXP 103
51082: PPUSH
51083: LD_VAR 0 3
51087: PUSH
51088: LD_EXP 103
51092: PUSH
51093: LD_VAR 0 3
51097: ARRAY
51098: PUSH
51099: LD_INT 1
51101: PLUS
51102: PUSH
51103: EMPTY
51104: LIST
51105: LIST
51106: PPUSH
51107: LD_VAR 0 1
51111: PPUSH
51112: CALL 57012 0 3
51116: ST_TO_ADDR
// if btype = b_bunker then
51117: LD_VAR 0 5
51121: PUSH
51122: LD_INT 32
51124: EQUAL
51125: IFFALSE 51361
// begin mc_empty_turret_list := ReplaceIn ( mc_empty_turret_list , [ i , mc_empty_turret_list [ i ] + 1 ] , building ) ;
51127: LD_ADDR_EXP 104
51131: PUSH
51132: LD_EXP 104
51136: PPUSH
51137: LD_VAR 0 3
51141: PUSH
51142: LD_EXP 104
51146: PUSH
51147: LD_VAR 0 3
51151: ARRAY
51152: PUSH
51153: LD_INT 1
51155: PLUS
51156: PUSH
51157: EMPTY
51158: LIST
51159: LIST
51160: PPUSH
51161: LD_VAR 0 1
51165: PPUSH
51166: CALL 57012 0 3
51170: ST_TO_ADDR
// tmp := UnitFilter ( mc_bases [ i ] , [ [ f_class , 1 ] , [ f_not , [ f_inside ] ] ] ) ;
51171: LD_ADDR_VAR 0 6
51175: PUSH
51176: LD_EXP 95
51180: PUSH
51181: LD_VAR 0 3
51185: ARRAY
51186: PPUSH
51187: LD_INT 25
51189: PUSH
51190: LD_INT 1
51192: PUSH
51193: EMPTY
51194: LIST
51195: LIST
51196: PUSH
51197: LD_INT 3
51199: PUSH
51200: LD_INT 54
51202: PUSH
51203: EMPTY
51204: LIST
51205: PUSH
51206: EMPTY
51207: LIST
51208: LIST
51209: PUSH
51210: EMPTY
51211: LIST
51212: LIST
51213: PPUSH
51214: CALL_OW 72
51218: ST_TO_ADDR
// if tmp then
51219: LD_VAR 0 6
51223: IFFALSE 51229
// exit ;
51225: POP
51226: POP
51227: GO 51369
// tmp := UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_armoury ] , [ f_btype , b_barracks ] ] ) ;
51229: LD_ADDR_VAR 0 6
51233: PUSH
51234: LD_EXP 95
51238: PUSH
51239: LD_VAR 0 3
51243: ARRAY
51244: PPUSH
51245: LD_INT 2
51247: PUSH
51248: LD_INT 30
51250: PUSH
51251: LD_INT 4
51253: PUSH
51254: EMPTY
51255: LIST
51256: LIST
51257: PUSH
51258: LD_INT 30
51260: PUSH
51261: LD_INT 5
51263: PUSH
51264: EMPTY
51265: LIST
51266: LIST
51267: PUSH
51268: EMPTY
51269: LIST
51270: LIST
51271: LIST
51272: PPUSH
51273: CALL_OW 72
51277: ST_TO_ADDR
// if not tmp then
51278: LD_VAR 0 6
51282: NOT
51283: IFFALSE 51289
// exit ;
51285: POP
51286: POP
51287: GO 51369
// for j in tmp do
51289: LD_ADDR_VAR 0 4
51293: PUSH
51294: LD_VAR 0 6
51298: PUSH
51299: FOR_IN
51300: IFFALSE 51359
// begin units := UnitFilter ( UnitsInside ( j ) , [ f_class , 1 ] ) ;
51302: LD_ADDR_VAR 0 7
51306: PUSH
51307: LD_VAR 0 4
51311: PPUSH
51312: CALL_OW 313
51316: PPUSH
51317: LD_INT 25
51319: PUSH
51320: LD_INT 1
51322: PUSH
51323: EMPTY
51324: LIST
51325: LIST
51326: PPUSH
51327: CALL_OW 72
51331: ST_TO_ADDR
// if units then
51332: LD_VAR 0 7
51336: IFFALSE 51357
// begin ComExitBuilding ( units [ 1 ] ) ;
51338: LD_VAR 0 7
51342: PUSH
51343: LD_INT 1
51345: ARRAY
51346: PPUSH
51347: CALL_OW 122
// exit ;
51351: POP
51352: POP
51353: POP
51354: POP
51355: GO 51369
// end ; end ;
51357: GO 51299
51359: POP
51360: POP
// end ; end ; exit ;
51361: POP
51362: POP
51363: GO 51369
// end ; end ;
51365: GO 50723
51367: POP
51368: POP
// end ;
51369: LD_VAR 0 2
51373: RET
// export function MCE_BuildingStarted ( building , builder ) ; var i , j , btype , x , y , d ; begin
51374: LD_INT 0
51376: PPUSH
51377: PPUSH
51378: PPUSH
51379: PPUSH
51380: PPUSH
51381: PPUSH
51382: PPUSH
// if not mc_bases or not skirmish then
51383: LD_EXP 95
51387: NOT
51388: PUSH
51389: LD_EXP 93
51393: NOT
51394: OR
51395: IFFALSE 51399
// exit ;
51397: GO 51664
// btype := GetBType ( building ) ;
51399: LD_ADDR_VAR 0 6
51403: PUSH
51404: LD_VAR 0 1
51408: PPUSH
51409: CALL_OW 266
51413: ST_TO_ADDR
// x := GetX ( building ) ;
51414: LD_ADDR_VAR 0 7
51418: PUSH
51419: LD_VAR 0 1
51423: PPUSH
51424: CALL_OW 250
51428: ST_TO_ADDR
// y := GetY ( building ) ;
51429: LD_ADDR_VAR 0 8
51433: PUSH
51434: LD_VAR 0 1
51438: PPUSH
51439: CALL_OW 251
51443: ST_TO_ADDR
// d := GetDir ( building ) ;
51444: LD_ADDR_VAR 0 9
51448: PUSH
51449: LD_VAR 0 1
51453: PPUSH
51454: CALL_OW 254
51458: ST_TO_ADDR
// for i = 1 to mc_bases do
51459: LD_ADDR_VAR 0 4
51463: PUSH
51464: DOUBLE
51465: LD_INT 1
51467: DEC
51468: ST_TO_ADDR
51469: LD_EXP 95
51473: PUSH
51474: FOR_TO
51475: IFFALSE 51662
// begin if not mc_build_list [ i ] then
51477: LD_EXP 100
51481: PUSH
51482: LD_VAR 0 4
51486: ARRAY
51487: NOT
51488: IFFALSE 51492
// continue ;
51490: GO 51474
// for j := 1 to mc_build_list [ i ] do
51492: LD_ADDR_VAR 0 5
51496: PUSH
51497: DOUBLE
51498: LD_INT 1
51500: DEC
51501: ST_TO_ADDR
51502: LD_EXP 100
51506: PUSH
51507: LD_VAR 0 4
51511: ARRAY
51512: PUSH
51513: FOR_TO
51514: IFFALSE 51658
// if CompareArray ( [ btype , x , y , d ] , mc_build_list [ i ] [ j ] ) then
51516: LD_VAR 0 6
51520: PUSH
51521: LD_VAR 0 7
51525: PUSH
51526: LD_VAR 0 8
51530: PUSH
51531: LD_VAR 0 9
51535: PUSH
51536: EMPTY
51537: LIST
51538: LIST
51539: LIST
51540: LIST
51541: PPUSH
51542: LD_EXP 100
51546: PUSH
51547: LD_VAR 0 4
51551: ARRAY
51552: PUSH
51553: LD_VAR 0 5
51557: ARRAY
51558: PPUSH
51559: CALL 63194 0 2
51563: IFFALSE 51656
// begin mc_build_list := Replace ( mc_build_list , i , Delete ( mc_build_list [ i ] , j ) ) ;
51565: LD_ADDR_EXP 100
51569: PUSH
51570: LD_EXP 100
51574: PPUSH
51575: LD_VAR 0 4
51579: PPUSH
51580: LD_EXP 100
51584: PUSH
51585: LD_VAR 0 4
51589: ARRAY
51590: PPUSH
51591: LD_VAR 0 5
51595: PPUSH
51596: CALL_OW 3
51600: PPUSH
51601: CALL_OW 1
51605: ST_TO_ADDR
// mc_construct_list := ReplaceIn ( mc_construct_list , [ i , mc_construct_list [ i ] + 1 ] , building ) ;
51606: LD_ADDR_EXP 102
51610: PUSH
51611: LD_EXP 102
51615: PPUSH
51616: LD_VAR 0 4
51620: PUSH
51621: LD_EXP 102
51625: PUSH
51626: LD_VAR 0 4
51630: ARRAY
51631: PUSH
51632: LD_INT 1
51634: PLUS
51635: PUSH
51636: EMPTY
51637: LIST
51638: LIST
51639: PPUSH
51640: LD_VAR 0 1
51644: PPUSH
51645: CALL 57012 0 3
51649: ST_TO_ADDR
// exit ;
51650: POP
51651: POP
51652: POP
51653: POP
51654: GO 51664
// end ;
51656: GO 51513
51658: POP
51659: POP
// end ;
51660: GO 51474
51662: POP
51663: POP
// end ;
51664: LD_VAR 0 3
51668: RET
// export function MCE_LeaveBuilding ( building , unit ) ; var i , tmp ; begin
51669: LD_INT 0
51671: PPUSH
51672: PPUSH
51673: PPUSH
// if not mc_bases or not skirmish then
51674: LD_EXP 95
51678: NOT
51679: PUSH
51680: LD_EXP 93
51684: NOT
51685: OR
51686: IFFALSE 51690
// exit ;
51688: GO 51880
// for i = 1 to mc_bases do
51690: LD_ADDR_VAR 0 4
51694: PUSH
51695: DOUBLE
51696: LD_INT 1
51698: DEC
51699: ST_TO_ADDR
51700: LD_EXP 95
51704: PUSH
51705: FOR_TO
51706: IFFALSE 51793
// begin if building in mc_turret_list [ i ] and not building in mc_empty_turret_list [ i ] then
51708: LD_VAR 0 1
51712: PUSH
51713: LD_EXP 103
51717: PUSH
51718: LD_VAR 0 4
51722: ARRAY
51723: IN
51724: PUSH
51725: LD_VAR 0 1
51729: PUSH
51730: LD_EXP 104
51734: PUSH
51735: LD_VAR 0 4
51739: ARRAY
51740: IN
51741: NOT
51742: AND
51743: IFFALSE 51791
// begin mc_empty_turret_list := ReplaceIn ( mc_empty_turret_list , [ i , mc_empty_turret_list [ i ] + 1 ] , building ) ;
51745: LD_ADDR_EXP 104
51749: PUSH
51750: LD_EXP 104
51754: PPUSH
51755: LD_VAR 0 4
51759: PUSH
51760: LD_EXP 104
51764: PUSH
51765: LD_VAR 0 4
51769: ARRAY
51770: PUSH
51771: LD_INT 1
51773: PLUS
51774: PUSH
51775: EMPTY
51776: LIST
51777: LIST
51778: PPUSH
51779: LD_VAR 0 1
51783: PPUSH
51784: CALL 57012 0 3
51788: ST_TO_ADDR
// break ;
51789: GO 51793
// end ; end ;
51791: GO 51705
51793: POP
51794: POP
// if GetClass ( building ) in mc_sides and GetBType ( building ) = b_barracks and GetTag ( unit ) <> 18 then
51795: LD_VAR 0 1
51799: PPUSH
51800: CALL_OW 257
51804: PUSH
51805: LD_EXP 121
51809: IN
51810: PUSH
51811: LD_VAR 0 1
51815: PPUSH
51816: CALL_OW 266
51820: PUSH
51821: LD_INT 5
51823: EQUAL
51824: AND
51825: PUSH
51826: LD_VAR 0 2
51830: PPUSH
51831: CALL_OW 110
51835: PUSH
51836: LD_INT 18
51838: NONEQUAL
51839: AND
51840: IFFALSE 51880
// if GetClass ( unit ) in [ 5 , 8 , 9 ] then
51842: LD_VAR 0 2
51846: PPUSH
51847: CALL_OW 257
51851: PUSH
51852: LD_INT 5
51854: PUSH
51855: LD_INT 8
51857: PUSH
51858: LD_INT 9
51860: PUSH
51861: EMPTY
51862: LIST
51863: LIST
51864: LIST
51865: IN
51866: IFFALSE 51880
// SetClass ( unit , 1 ) ;
51868: LD_VAR 0 2
51872: PPUSH
51873: LD_INT 1
51875: PPUSH
51876: CALL_OW 336
// end ;
51880: LD_VAR 0 3
51884: RET
// export function MCE_EvacuateVehicle ( driver , abandoned_vehicle , unknown1 , unknown2 ) ; var i ; begin
51885: LD_INT 0
51887: PPUSH
51888: PPUSH
// if not mc_bases or not skirmish then
51889: LD_EXP 95
51893: NOT
51894: PUSH
51895: LD_EXP 93
51899: NOT
51900: OR
51901: IFFALSE 51905
// exit ;
51903: GO 52021
// if GetLives ( abandoned_vehicle ) > 250 then
51905: LD_VAR 0 2
51909: PPUSH
51910: CALL_OW 256
51914: PUSH
51915: LD_INT 250
51917: GREATER
51918: IFFALSE 51922
// exit ;
51920: GO 52021
// for i = 1 to mc_bases do
51922: LD_ADDR_VAR 0 6
51926: PUSH
51927: DOUBLE
51928: LD_INT 1
51930: DEC
51931: ST_TO_ADDR
51932: LD_EXP 95
51936: PUSH
51937: FOR_TO
51938: IFFALSE 52019
// begin if driver in mc_bases [ i ] then
51940: LD_VAR 0 1
51944: PUSH
51945: LD_EXP 95
51949: PUSH
51950: LD_VAR 0 6
51954: ARRAY
51955: IN
51956: IFFALSE 52017
// begin ComMoveToNearbyEntrance ( driver , UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) [ 1 ] ) ;
51958: LD_VAR 0 1
51962: PPUSH
51963: LD_EXP 95
51967: PUSH
51968: LD_VAR 0 6
51972: ARRAY
51973: PPUSH
51974: LD_INT 2
51976: PUSH
51977: LD_INT 30
51979: PUSH
51980: LD_INT 0
51982: PUSH
51983: EMPTY
51984: LIST
51985: LIST
51986: PUSH
51987: LD_INT 30
51989: PUSH
51990: LD_INT 1
51992: PUSH
51993: EMPTY
51994: LIST
51995: LIST
51996: PUSH
51997: EMPTY
51998: LIST
51999: LIST
52000: LIST
52001: PPUSH
52002: CALL_OW 72
52006: PUSH
52007: LD_INT 1
52009: ARRAY
52010: PPUSH
52011: CALL 89630 0 2
// break ;
52015: GO 52019
// end ; end ;
52017: GO 51937
52019: POP
52020: POP
// end ; end_of_file
52021: LD_VAR 0 5
52025: RET
// export function PrepareUnit ( ident , exist_mode , prefix ) ; var unit ; begin
52026: LD_INT 0
52028: PPUSH
52029: PPUSH
// if exist_mode then
52030: LD_VAR 0 2
52034: IFFALSE 52059
// unit := CreateCharacter ( prefix & ident ) else
52036: LD_ADDR_VAR 0 5
52040: PUSH
52041: LD_VAR 0 3
52045: PUSH
52046: LD_VAR 0 1
52050: STR
52051: PPUSH
52052: CALL_OW 34
52056: ST_TO_ADDR
52057: GO 52074
// unit := NewCharacter ( ident ) ;
52059: LD_ADDR_VAR 0 5
52063: PUSH
52064: LD_VAR 0 1
52068: PPUSH
52069: CALL_OW 25
52073: ST_TO_ADDR
// result := unit ;
52074: LD_ADDR_VAR 0 4
52078: PUSH
52079: LD_VAR 0 5
52083: ST_TO_ADDR
// end ;
52084: LD_VAR 0 4
52088: RET
// export function GetTechNation ( side , nation , state ) ; var i ; begin
52089: LD_INT 0
52091: PPUSH
52092: PPUSH
// if not side or not nation then
52093: LD_VAR 0 1
52097: NOT
52098: PUSH
52099: LD_VAR 0 2
52103: NOT
52104: OR
52105: IFFALSE 52109
// exit ;
52107: GO 52877
// case nation of nation_american :
52109: LD_VAR 0 2
52113: PUSH
52114: LD_INT 1
52116: DOUBLE
52117: EQUAL
52118: IFTRUE 52122
52120: GO 52336
52122: POP
// result := [ 35 , 45 , 46 , 47 , 82 , 83 , 84 , 85 , 86 , 1 , 2 , 6 , 15 , 16 , 7 , 12 , 13 , 10 , 14 , 20 , 21 , 22 , 25 , 32 , 27 , 36 , 69 , 39 , 34 , 40 , 48 , 49 , 50 , 51 , 52 , 53 , 54 , 55 , 56 , 57 , 58 , 59 , 60 , 61 , 62 , 80 , 82 , 83 , 84 , 85 , 86 ] ; nation_arabian :
52123: LD_ADDR_VAR 0 4
52127: PUSH
52128: LD_INT 35
52130: PUSH
52131: LD_INT 45
52133: PUSH
52134: LD_INT 46
52136: PUSH
52137: LD_INT 47
52139: PUSH
52140: LD_INT 82
52142: PUSH
52143: LD_INT 83
52145: PUSH
52146: LD_INT 84
52148: PUSH
52149: LD_INT 85
52151: PUSH
52152: LD_INT 86
52154: PUSH
52155: LD_INT 1
52157: PUSH
52158: LD_INT 2
52160: PUSH
52161: LD_INT 6
52163: PUSH
52164: LD_INT 15
52166: PUSH
52167: LD_INT 16
52169: PUSH
52170: LD_INT 7
52172: PUSH
52173: LD_INT 12
52175: PUSH
52176: LD_INT 13
52178: PUSH
52179: LD_INT 10
52181: PUSH
52182: LD_INT 14
52184: PUSH
52185: LD_INT 20
52187: PUSH
52188: LD_INT 21
52190: PUSH
52191: LD_INT 22
52193: PUSH
52194: LD_INT 25
52196: PUSH
52197: LD_INT 32
52199: PUSH
52200: LD_INT 27
52202: PUSH
52203: LD_INT 36
52205: PUSH
52206: LD_INT 69
52208: PUSH
52209: LD_INT 39
52211: PUSH
52212: LD_INT 34
52214: PUSH
52215: LD_INT 40
52217: PUSH
52218: LD_INT 48
52220: PUSH
52221: LD_INT 49
52223: PUSH
52224: LD_INT 50
52226: PUSH
52227: LD_INT 51
52229: PUSH
52230: LD_INT 52
52232: PUSH
52233: LD_INT 53
52235: PUSH
52236: LD_INT 54
52238: PUSH
52239: LD_INT 55
52241: PUSH
52242: LD_INT 56
52244: PUSH
52245: LD_INT 57
52247: PUSH
52248: LD_INT 58
52250: PUSH
52251: LD_INT 59
52253: PUSH
52254: LD_INT 60
52256: PUSH
52257: LD_INT 61
52259: PUSH
52260: LD_INT 62
52262: PUSH
52263: LD_INT 80
52265: PUSH
52266: LD_INT 82
52268: PUSH
52269: LD_INT 83
52271: PUSH
52272: LD_INT 84
52274: PUSH
52275: LD_INT 85
52277: PUSH
52278: LD_INT 86
52280: PUSH
52281: EMPTY
52282: LIST
52283: LIST
52284: LIST
52285: LIST
52286: LIST
52287: LIST
52288: LIST
52289: LIST
52290: LIST
52291: LIST
52292: LIST
52293: LIST
52294: LIST
52295: LIST
52296: LIST
52297: LIST
52298: LIST
52299: LIST
52300: LIST
52301: LIST
52302: LIST
52303: LIST
52304: LIST
52305: LIST
52306: LIST
52307: LIST
52308: LIST
52309: LIST
52310: LIST
52311: LIST
52312: LIST
52313: LIST
52314: LIST
52315: LIST
52316: LIST
52317: LIST
52318: LIST
52319: LIST
52320: LIST
52321: LIST
52322: LIST
52323: LIST
52324: LIST
52325: LIST
52326: LIST
52327: LIST
52328: LIST
52329: LIST
52330: LIST
52331: LIST
52332: LIST
52333: ST_TO_ADDR
52334: GO 52801
52336: LD_INT 2
52338: DOUBLE
52339: EQUAL
52340: IFTRUE 52344
52342: GO 52570
52344: POP
// result := [ 35 , 45 , 46 , 47 , 82 , 83 , 84 , 85 , 87 , 70 , 1 , 11 , 3 , 4 , 5 , 6 , 15 , 18 , 7 , 17 , 8 , 20 , 21 , 22 , 72 , 26 , 69 , 39 , 40 , 41 , 42 , 43 , 48 , 49 , 50 , 51 , 52 , 53 , 54 , 55 , 56 , 60 , 61 , 62 , 66 , 67 , 68 , 81 , 82 , 83 , 84 , 85 , 87 , 88 ] ; nation_russian :
52345: LD_ADDR_VAR 0 4
52349: PUSH
52350: LD_INT 35
52352: PUSH
52353: LD_INT 45
52355: PUSH
52356: LD_INT 46
52358: PUSH
52359: LD_INT 47
52361: PUSH
52362: LD_INT 82
52364: PUSH
52365: LD_INT 83
52367: PUSH
52368: LD_INT 84
52370: PUSH
52371: LD_INT 85
52373: PUSH
52374: LD_INT 87
52376: PUSH
52377: LD_INT 70
52379: PUSH
52380: LD_INT 1
52382: PUSH
52383: LD_INT 11
52385: PUSH
52386: LD_INT 3
52388: PUSH
52389: LD_INT 4
52391: PUSH
52392: LD_INT 5
52394: PUSH
52395: LD_INT 6
52397: PUSH
52398: LD_INT 15
52400: PUSH
52401: LD_INT 18
52403: PUSH
52404: LD_INT 7
52406: PUSH
52407: LD_INT 17
52409: PUSH
52410: LD_INT 8
52412: PUSH
52413: LD_INT 20
52415: PUSH
52416: LD_INT 21
52418: PUSH
52419: LD_INT 22
52421: PUSH
52422: LD_INT 72
52424: PUSH
52425: LD_INT 26
52427: PUSH
52428: LD_INT 69
52430: PUSH
52431: LD_INT 39
52433: PUSH
52434: LD_INT 40
52436: PUSH
52437: LD_INT 41
52439: PUSH
52440: LD_INT 42
52442: PUSH
52443: LD_INT 43
52445: PUSH
52446: LD_INT 48
52448: PUSH
52449: LD_INT 49
52451: PUSH
52452: LD_INT 50
52454: PUSH
52455: LD_INT 51
52457: PUSH
52458: LD_INT 52
52460: PUSH
52461: LD_INT 53
52463: PUSH
52464: LD_INT 54
52466: PUSH
52467: LD_INT 55
52469: PUSH
52470: LD_INT 56
52472: PUSH
52473: LD_INT 60
52475: PUSH
52476: LD_INT 61
52478: PUSH
52479: LD_INT 62
52481: PUSH
52482: LD_INT 66
52484: PUSH
52485: LD_INT 67
52487: PUSH
52488: LD_INT 68
52490: PUSH
52491: LD_INT 81
52493: PUSH
52494: LD_INT 82
52496: PUSH
52497: LD_INT 83
52499: PUSH
52500: LD_INT 84
52502: PUSH
52503: LD_INT 85
52505: PUSH
52506: LD_INT 87
52508: PUSH
52509: LD_INT 88
52511: PUSH
52512: EMPTY
52513: LIST
52514: LIST
52515: LIST
52516: LIST
52517: LIST
52518: LIST
52519: LIST
52520: LIST
52521: LIST
52522: LIST
52523: LIST
52524: LIST
52525: LIST
52526: LIST
52527: LIST
52528: LIST
52529: LIST
52530: LIST
52531: LIST
52532: LIST
52533: LIST
52534: LIST
52535: LIST
52536: LIST
52537: LIST
52538: LIST
52539: LIST
52540: LIST
52541: LIST
52542: LIST
52543: LIST
52544: LIST
52545: LIST
52546: LIST
52547: LIST
52548: LIST
52549: LIST
52550: LIST
52551: LIST
52552: LIST
52553: LIST
52554: LIST
52555: LIST
52556: LIST
52557: LIST
52558: LIST
52559: LIST
52560: LIST
52561: LIST
52562: LIST
52563: LIST
52564: LIST
52565: LIST
52566: LIST
52567: ST_TO_ADDR
52568: GO 52801
52570: LD_INT 3
52572: DOUBLE
52573: EQUAL
52574: IFTRUE 52578
52576: GO 52800
52578: POP
// result := [ 46 , 47 , 1 , 2 , 82 , 83 , 84 , 85 , 86 , 11 , 9 , 20 , 19 , 21 , 24 , 22 , 25 , 28 , 29 , 30 , 31 , 37 , 38 , 32 , 27 , 33 , 69 , 39 , 34 , 40 , 71 , 23 , 44 , 48 , 49 , 50 , 51 , 52 , 53 , 54 , 55 , 56 , 57 , 58 , 59 , 63 , 64 , 65 , 82 , 83 , 84 , 85 , 86 ] ; end ;
52579: LD_ADDR_VAR 0 4
52583: PUSH
52584: LD_INT 46
52586: PUSH
52587: LD_INT 47
52589: PUSH
52590: LD_INT 1
52592: PUSH
52593: LD_INT 2
52595: PUSH
52596: LD_INT 82
52598: PUSH
52599: LD_INT 83
52601: PUSH
52602: LD_INT 84
52604: PUSH
52605: LD_INT 85
52607: PUSH
52608: LD_INT 86
52610: PUSH
52611: LD_INT 11
52613: PUSH
52614: LD_INT 9
52616: PUSH
52617: LD_INT 20
52619: PUSH
52620: LD_INT 19
52622: PUSH
52623: LD_INT 21
52625: PUSH
52626: LD_INT 24
52628: PUSH
52629: LD_INT 22
52631: PUSH
52632: LD_INT 25
52634: PUSH
52635: LD_INT 28
52637: PUSH
52638: LD_INT 29
52640: PUSH
52641: LD_INT 30
52643: PUSH
52644: LD_INT 31
52646: PUSH
52647: LD_INT 37
52649: PUSH
52650: LD_INT 38
52652: PUSH
52653: LD_INT 32
52655: PUSH
52656: LD_INT 27
52658: PUSH
52659: LD_INT 33
52661: PUSH
52662: LD_INT 69
52664: PUSH
52665: LD_INT 39
52667: PUSH
52668: LD_INT 34
52670: PUSH
52671: LD_INT 40
52673: PUSH
52674: LD_INT 71
52676: PUSH
52677: LD_INT 23
52679: PUSH
52680: LD_INT 44
52682: PUSH
52683: LD_INT 48
52685: PUSH
52686: LD_INT 49
52688: PUSH
52689: LD_INT 50
52691: PUSH
52692: LD_INT 51
52694: PUSH
52695: LD_INT 52
52697: PUSH
52698: LD_INT 53
52700: PUSH
52701: LD_INT 54
52703: PUSH
52704: LD_INT 55
52706: PUSH
52707: LD_INT 56
52709: PUSH
52710: LD_INT 57
52712: PUSH
52713: LD_INT 58
52715: PUSH
52716: LD_INT 59
52718: PUSH
52719: LD_INT 63
52721: PUSH
52722: LD_INT 64
52724: PUSH
52725: LD_INT 65
52727: PUSH
52728: LD_INT 82
52730: PUSH
52731: LD_INT 83
52733: PUSH
52734: LD_INT 84
52736: PUSH
52737: LD_INT 85
52739: PUSH
52740: LD_INT 86
52742: PUSH
52743: EMPTY
52744: LIST
52745: LIST
52746: LIST
52747: LIST
52748: LIST
52749: LIST
52750: LIST
52751: LIST
52752: LIST
52753: LIST
52754: LIST
52755: LIST
52756: LIST
52757: LIST
52758: LIST
52759: LIST
52760: LIST
52761: LIST
52762: LIST
52763: LIST
52764: LIST
52765: LIST
52766: LIST
52767: LIST
52768: LIST
52769: LIST
52770: LIST
52771: LIST
52772: LIST
52773: LIST
52774: LIST
52775: LIST
52776: LIST
52777: LIST
52778: LIST
52779: LIST
52780: LIST
52781: LIST
52782: LIST
52783: LIST
52784: LIST
52785: LIST
52786: LIST
52787: LIST
52788: LIST
52789: LIST
52790: LIST
52791: LIST
52792: LIST
52793: LIST
52794: LIST
52795: LIST
52796: LIST
52797: ST_TO_ADDR
52798: GO 52801
52800: POP
// if state > - 1 and state < 3 then
52801: LD_VAR 0 3
52805: PUSH
52806: LD_INT 1
52808: NEG
52809: GREATER
52810: PUSH
52811: LD_VAR 0 3
52815: PUSH
52816: LD_INT 3
52818: LESS
52819: AND
52820: IFFALSE 52877
// for i in result do
52822: LD_ADDR_VAR 0 5
52826: PUSH
52827: LD_VAR 0 4
52831: PUSH
52832: FOR_IN
52833: IFFALSE 52875
// if GetTech ( i , side ) <> state then
52835: LD_VAR 0 5
52839: PPUSH
52840: LD_VAR 0 1
52844: PPUSH
52845: CALL_OW 321
52849: PUSH
52850: LD_VAR 0 3
52854: NONEQUAL
52855: IFFALSE 52873
// result := result diff i ;
52857: LD_ADDR_VAR 0 4
52861: PUSH
52862: LD_VAR 0 4
52866: PUSH
52867: LD_VAR 0 5
52871: DIFF
52872: ST_TO_ADDR
52873: GO 52832
52875: POP
52876: POP
// end ;
52877: LD_VAR 0 4
52881: RET
// export function TechCanBeResearch ( side , tech ) ; var i , tmp ; begin
52882: LD_INT 0
52884: PPUSH
52885: PPUSH
52886: PPUSH
// result := true ;
52887: LD_ADDR_VAR 0 3
52891: PUSH
52892: LD_INT 1
52894: ST_TO_ADDR
// tmp := GetTechTechsReq ( tech ) ;
52895: LD_ADDR_VAR 0 5
52899: PUSH
52900: LD_VAR 0 2
52904: PPUSH
52905: CALL_OW 480
52909: ST_TO_ADDR
// if not tmp then
52910: LD_VAR 0 5
52914: NOT
52915: IFFALSE 52919
// exit ;
52917: GO 52968
// for i in tmp do
52919: LD_ADDR_VAR 0 4
52923: PUSH
52924: LD_VAR 0 5
52928: PUSH
52929: FOR_IN
52930: IFFALSE 52966
// if GetTech ( i , side ) <> state_researched then
52932: LD_VAR 0 4
52936: PPUSH
52937: LD_VAR 0 1
52941: PPUSH
52942: CALL_OW 321
52946: PUSH
52947: LD_INT 2
52949: NONEQUAL
52950: IFFALSE 52964
// begin result := false ;
52952: LD_ADDR_VAR 0 3
52956: PUSH
52957: LD_INT 0
52959: ST_TO_ADDR
// exit ;
52960: POP
52961: POP
52962: GO 52968
// end ;
52964: GO 52929
52966: POP
52967: POP
// end ;
52968: LD_VAR 0 3
52972: RET
// export function ComSpaceTimeShoot ( unit ) ; var i , x , y , _x , _y , tmp , side , enemy , in_unit , tech_space , tech_time , missile ; begin
52973: LD_INT 0
52975: PPUSH
52976: PPUSH
52977: PPUSH
52978: PPUSH
52979: PPUSH
52980: PPUSH
52981: PPUSH
52982: PPUSH
52983: PPUSH
52984: PPUSH
52985: PPUSH
52986: PPUSH
52987: PPUSH
// if not unit or GetClass ( unit ) <> class_bazooker then
52988: LD_VAR 0 1
52992: NOT
52993: PUSH
52994: LD_VAR 0 1
52998: PPUSH
52999: CALL_OW 257
53003: PUSH
53004: LD_INT 9
53006: NONEQUAL
53007: OR
53008: IFFALSE 53012
// exit ;
53010: GO 53585
// side := GetSide ( unit ) ;
53012: LD_ADDR_VAR 0 9
53016: PUSH
53017: LD_VAR 0 1
53021: PPUSH
53022: CALL_OW 255
53026: ST_TO_ADDR
// tech_space := tech_spacanom ;
53027: LD_ADDR_VAR 0 12
53031: PUSH
53032: LD_INT 29
53034: ST_TO_ADDR
// tech_time := tech_taurad ;
53035: LD_ADDR_VAR 0 13
53039: PUSH
53040: LD_INT 28
53042: ST_TO_ADDR
// in_unit := IsInUnit ( unit ) ;
53043: LD_ADDR_VAR 0 11
53047: PUSH
53048: LD_VAR 0 1
53052: PPUSH
53053: CALL_OW 310
53057: ST_TO_ADDR
// if GetType ( in_unit ) = unit_vehicle then
53058: LD_VAR 0 11
53062: PPUSH
53063: CALL_OW 247
53067: PUSH
53068: LD_INT 2
53070: EQUAL
53071: IFFALSE 53075
// exit ;
53073: GO 53585
// tmp := FilterAllUnits ( [ [ f_enemy , side ] , [ f_not , [ f_type , unit_building ] ] ] ) ;
53075: LD_ADDR_VAR 0 8
53079: PUSH
53080: LD_INT 81
53082: PUSH
53083: LD_VAR 0 9
53087: PUSH
53088: EMPTY
53089: LIST
53090: LIST
53091: PUSH
53092: LD_INT 3
53094: PUSH
53095: LD_INT 21
53097: PUSH
53098: LD_INT 3
53100: PUSH
53101: EMPTY
53102: LIST
53103: LIST
53104: PUSH
53105: EMPTY
53106: LIST
53107: LIST
53108: PUSH
53109: EMPTY
53110: LIST
53111: LIST
53112: PPUSH
53113: CALL_OW 69
53117: ST_TO_ADDR
// if not tmp then
53118: LD_VAR 0 8
53122: NOT
53123: IFFALSE 53127
// exit ;
53125: GO 53585
// if in_unit then
53127: LD_VAR 0 11
53131: IFFALSE 53155
// enemy := NearestUnitToUnit ( tmp , in_unit ) else
53133: LD_ADDR_VAR 0 10
53137: PUSH
53138: LD_VAR 0 8
53142: PPUSH
53143: LD_VAR 0 11
53147: PPUSH
53148: CALL_OW 74
53152: ST_TO_ADDR
53153: GO 53175
// enemy := NearestUnitToUnit ( tmp , unit ) ;
53155: LD_ADDR_VAR 0 10
53159: PUSH
53160: LD_VAR 0 8
53164: PPUSH
53165: LD_VAR 0 1
53169: PPUSH
53170: CALL_OW 74
53174: ST_TO_ADDR
// if not enemy then
53175: LD_VAR 0 10
53179: NOT
53180: IFFALSE 53184
// exit ;
53182: GO 53585
// if ( in_unit and GetDistUnits ( in_unit , enemy ) > 13 ) or GetDistUnits ( unit , enemy ) > 12 then
53184: LD_VAR 0 11
53188: PUSH
53189: LD_VAR 0 11
53193: PPUSH
53194: LD_VAR 0 10
53198: PPUSH
53199: CALL_OW 296
53203: PUSH
53204: LD_INT 13
53206: GREATER
53207: AND
53208: PUSH
53209: LD_VAR 0 1
53213: PPUSH
53214: LD_VAR 0 10
53218: PPUSH
53219: CALL_OW 296
53223: PUSH
53224: LD_INT 12
53226: GREATER
53227: OR
53228: IFFALSE 53232
// exit ;
53230: GO 53585
// missile := [ 1 ] ;
53232: LD_ADDR_VAR 0 14
53236: PUSH
53237: LD_INT 1
53239: PUSH
53240: EMPTY
53241: LIST
53242: ST_TO_ADDR
// if Researched ( side , tech_space ) then
53243: LD_VAR 0 9
53247: PPUSH
53248: LD_VAR 0 12
53252: PPUSH
53253: CALL_OW 325
53257: IFFALSE 53286
// missile := Insert ( missile , missile + 1 , 2 ) ;
53259: LD_ADDR_VAR 0 14
53263: PUSH
53264: LD_VAR 0 14
53268: PPUSH
53269: LD_VAR 0 14
53273: PUSH
53274: LD_INT 1
53276: PLUS
53277: PPUSH
53278: LD_INT 2
53280: PPUSH
53281: CALL_OW 2
53285: ST_TO_ADDR
// if Researched ( side , tech_time ) and not Researched ( GetSide ( enemy ) , tech_time ) then
53286: LD_VAR 0 9
53290: PPUSH
53291: LD_VAR 0 13
53295: PPUSH
53296: CALL_OW 325
53300: PUSH
53301: LD_VAR 0 10
53305: PPUSH
53306: CALL_OW 255
53310: PPUSH
53311: LD_VAR 0 13
53315: PPUSH
53316: CALL_OW 325
53320: NOT
53321: AND
53322: IFFALSE 53351
// missile := Insert ( missile , missile + 1 , 3 ) ;
53324: LD_ADDR_VAR 0 14
53328: PUSH
53329: LD_VAR 0 14
53333: PPUSH
53334: LD_VAR 0 14
53338: PUSH
53339: LD_INT 1
53341: PLUS
53342: PPUSH
53343: LD_INT 3
53345: PPUSH
53346: CALL_OW 2
53350: ST_TO_ADDR
// if missile < 2 then
53351: LD_VAR 0 14
53355: PUSH
53356: LD_INT 2
53358: LESS
53359: IFFALSE 53363
// exit ;
53361: GO 53585
// x := GetX ( enemy ) ;
53363: LD_ADDR_VAR 0 4
53367: PUSH
53368: LD_VAR 0 10
53372: PPUSH
53373: CALL_OW 250
53377: ST_TO_ADDR
// y := GetY ( enemy ) ;
53378: LD_ADDR_VAR 0 5
53382: PUSH
53383: LD_VAR 0 10
53387: PPUSH
53388: CALL_OW 251
53392: ST_TO_ADDR
// _x := x + rand ( - 1 , 1 ) ;
53393: LD_ADDR_VAR 0 6
53397: PUSH
53398: LD_VAR 0 4
53402: PUSH
53403: LD_INT 1
53405: NEG
53406: PPUSH
53407: LD_INT 1
53409: PPUSH
53410: CALL_OW 12
53414: PLUS
53415: ST_TO_ADDR
// _y := y + rand ( - 1 , 1 ) ;
53416: LD_ADDR_VAR 0 7
53420: PUSH
53421: LD_VAR 0 5
53425: PUSH
53426: LD_INT 1
53428: NEG
53429: PPUSH
53430: LD_INT 1
53432: PPUSH
53433: CALL_OW 12
53437: PLUS
53438: ST_TO_ADDR
// if not ValidHex ( _x , _y ) then
53439: LD_VAR 0 6
53443: PPUSH
53444: LD_VAR 0 7
53448: PPUSH
53449: CALL_OW 488
53453: NOT
53454: IFFALSE 53476
// begin _x := x ;
53456: LD_ADDR_VAR 0 6
53460: PUSH
53461: LD_VAR 0 4
53465: ST_TO_ADDR
// _y := y ;
53466: LD_ADDR_VAR 0 7
53470: PUSH
53471: LD_VAR 0 5
53475: ST_TO_ADDR
// end ; i := rand ( 1 , missile ) ;
53476: LD_ADDR_VAR 0 3
53480: PUSH
53481: LD_INT 1
53483: PPUSH
53484: LD_VAR 0 14
53488: PPUSH
53489: CALL_OW 12
53493: ST_TO_ADDR
// case i of 1 :
53494: LD_VAR 0 3
53498: PUSH
53499: LD_INT 1
53501: DOUBLE
53502: EQUAL
53503: IFTRUE 53507
53505: GO 53524
53507: POP
// ComAttackUnit ( unit , enemy ) ; 2 :
53508: LD_VAR 0 1
53512: PPUSH
53513: LD_VAR 0 10
53517: PPUSH
53518: CALL_OW 115
53522: GO 53585
53524: LD_INT 2
53526: DOUBLE
53527: EQUAL
53528: IFTRUE 53532
53530: GO 53554
53532: POP
// ComSpaceShift ( unit , _x , _y ) ; 3 :
53533: LD_VAR 0 1
53537: PPUSH
53538: LD_VAR 0 6
53542: PPUSH
53543: LD_VAR 0 7
53547: PPUSH
53548: CALL_OW 153
53552: GO 53585
53554: LD_INT 3
53556: DOUBLE
53557: EQUAL
53558: IFTRUE 53562
53560: GO 53584
53562: POP
// ComTimeShift ( unit , _x , _y ) ; end ;
53563: LD_VAR 0 1
53567: PPUSH
53568: LD_VAR 0 6
53572: PPUSH
53573: LD_VAR 0 7
53577: PPUSH
53578: CALL_OW 154
53582: GO 53585
53584: POP
// end ;
53585: LD_VAR 0 2
53589: RET
// export function ComStandNearbyBuilding ( unit , building ) ; var i , x , y , _x , _y ; begin
53590: LD_INT 0
53592: PPUSH
53593: PPUSH
53594: PPUSH
53595: PPUSH
53596: PPUSH
53597: PPUSH
// if not unit or not building then
53598: LD_VAR 0 1
53602: NOT
53603: PUSH
53604: LD_VAR 0 2
53608: NOT
53609: OR
53610: IFFALSE 53614
// exit ;
53612: GO 53772
// x := GetX ( building ) ;
53614: LD_ADDR_VAR 0 5
53618: PUSH
53619: LD_VAR 0 2
53623: PPUSH
53624: CALL_OW 250
53628: ST_TO_ADDR
// y := GetY ( building ) ;
53629: LD_ADDR_VAR 0 6
53633: PUSH
53634: LD_VAR 0 2
53638: PPUSH
53639: CALL_OW 251
53643: ST_TO_ADDR
// for i = 0 to 5 do
53644: LD_ADDR_VAR 0 4
53648: PUSH
53649: DOUBLE
53650: LD_INT 0
53652: DEC
53653: ST_TO_ADDR
53654: LD_INT 5
53656: PUSH
53657: FOR_TO
53658: IFFALSE 53770
// begin _x := ShiftX ( x , i , 3 ) ;
53660: LD_ADDR_VAR 0 7
53664: PUSH
53665: LD_VAR 0 5
53669: PPUSH
53670: LD_VAR 0 4
53674: PPUSH
53675: LD_INT 3
53677: PPUSH
53678: CALL_OW 272
53682: ST_TO_ADDR
// _y := ShiftY ( y , i , 3 ) ;
53683: LD_ADDR_VAR 0 8
53687: PUSH
53688: LD_VAR 0 6
53692: PPUSH
53693: LD_VAR 0 4
53697: PPUSH
53698: LD_INT 3
53700: PPUSH
53701: CALL_OW 273
53705: ST_TO_ADDR
// if not ValidHex ( _x , _y ) then
53706: LD_VAR 0 7
53710: PPUSH
53711: LD_VAR 0 8
53715: PPUSH
53716: CALL_OW 488
53720: NOT
53721: IFFALSE 53725
// continue ;
53723: GO 53657
// if HexInfo ( _x , _y ) = 0 then
53725: LD_VAR 0 7
53729: PPUSH
53730: LD_VAR 0 8
53734: PPUSH
53735: CALL_OW 428
53739: PUSH
53740: LD_INT 0
53742: EQUAL
53743: IFFALSE 53768
// begin ComMoveXY ( unit , _x , _y ) ;
53745: LD_VAR 0 1
53749: PPUSH
53750: LD_VAR 0 7
53754: PPUSH
53755: LD_VAR 0 8
53759: PPUSH
53760: CALL_OW 111
// exit ;
53764: POP
53765: POP
53766: GO 53772
// end ; end ;
53768: GO 53657
53770: POP
53771: POP
// end ;
53772: LD_VAR 0 3
53776: RET
// export function ScanBase ( side , base_area ) ; begin
53777: LD_INT 0
53779: PPUSH
// result := FilterUnitsInArea ( base_area , [ f_enemy , side ] ) ;
53780: LD_ADDR_VAR 0 3
53784: PUSH
53785: LD_VAR 0 2
53789: PPUSH
53790: LD_INT 81
53792: PUSH
53793: LD_VAR 0 1
53797: PUSH
53798: EMPTY
53799: LIST
53800: LIST
53801: PPUSH
53802: CALL_OW 70
53806: ST_TO_ADDR
// end ;
53807: LD_VAR 0 3
53811: RET
// export function AllowSpecClass ( unit ) ; var side , nat , tech ; begin
53812: LD_INT 0
53814: PPUSH
53815: PPUSH
53816: PPUSH
53817: PPUSH
// result := false ;
53818: LD_ADDR_VAR 0 2
53822: PUSH
53823: LD_INT 0
53825: ST_TO_ADDR
// side := GetSide ( unit ) ;
53826: LD_ADDR_VAR 0 3
53830: PUSH
53831: LD_VAR 0 1
53835: PPUSH
53836: CALL_OW 255
53840: ST_TO_ADDR
// nat := GetNation ( unit ) ;
53841: LD_ADDR_VAR 0 4
53845: PUSH
53846: LD_VAR 0 1
53850: PPUSH
53851: CALL_OW 248
53855: ST_TO_ADDR
// case nat of 1 :
53856: LD_VAR 0 4
53860: PUSH
53861: LD_INT 1
53863: DOUBLE
53864: EQUAL
53865: IFTRUE 53869
53867: GO 53880
53869: POP
// tech := tech_lassight ; 2 :
53870: LD_ADDR_VAR 0 5
53874: PUSH
53875: LD_INT 12
53877: ST_TO_ADDR
53878: GO 53919
53880: LD_INT 2
53882: DOUBLE
53883: EQUAL
53884: IFTRUE 53888
53886: GO 53899
53888: POP
// tech := tech_mortar ; 3 :
53889: LD_ADDR_VAR 0 5
53893: PUSH
53894: LD_INT 41
53896: ST_TO_ADDR
53897: GO 53919
53899: LD_INT 3
53901: DOUBLE
53902: EQUAL
53903: IFTRUE 53907
53905: GO 53918
53907: POP
// tech := tech_bazooka ; end ;
53908: LD_ADDR_VAR 0 5
53912: PUSH
53913: LD_INT 44
53915: ST_TO_ADDR
53916: GO 53919
53918: POP
// if Researched ( side , tech ) then
53919: LD_VAR 0 3
53923: PPUSH
53924: LD_VAR 0 5
53928: PPUSH
53929: CALL_OW 325
53933: IFFALSE 53960
// result := [ class_sniper , class_mortar , class_bazooker ] [ nat ] ;
53935: LD_ADDR_VAR 0 2
53939: PUSH
53940: LD_INT 5
53942: PUSH
53943: LD_INT 8
53945: PUSH
53946: LD_INT 9
53948: PUSH
53949: EMPTY
53950: LIST
53951: LIST
53952: LIST
53953: PUSH
53954: LD_VAR 0 4
53958: ARRAY
53959: ST_TO_ADDR
// end ;
53960: LD_VAR 0 2
53964: RET
// export function DetonateMines ( side , mines ) ; var i , tmp ; begin
53965: LD_INT 0
53967: PPUSH
53968: PPUSH
53969: PPUSH
// if not mines then
53970: LD_VAR 0 2
53974: NOT
53975: IFFALSE 53979
// exit ;
53977: GO 54123
// tmp := FilterAllUnits ( [ [ f_enemy , side ] , [ f_not , [ f_type , unit_building ] ] ] ) ;
53979: LD_ADDR_VAR 0 5
53983: PUSH
53984: LD_INT 81
53986: PUSH
53987: LD_VAR 0 1
53991: PUSH
53992: EMPTY
53993: LIST
53994: LIST
53995: PUSH
53996: LD_INT 3
53998: PUSH
53999: LD_INT 21
54001: PUSH
54002: LD_INT 3
54004: PUSH
54005: EMPTY
54006: LIST
54007: LIST
54008: PUSH
54009: EMPTY
54010: LIST
54011: LIST
54012: PUSH
54013: EMPTY
54014: LIST
54015: LIST
54016: PPUSH
54017: CALL_OW 69
54021: ST_TO_ADDR
// for i in mines do
54022: LD_ADDR_VAR 0 4
54026: PUSH
54027: LD_VAR 0 2
54031: PUSH
54032: FOR_IN
54033: IFFALSE 54121
// begin if not MineAtPos ( i [ 1 ] , i [ 2 ] ) then
54035: LD_VAR 0 4
54039: PUSH
54040: LD_INT 1
54042: ARRAY
54043: PPUSH
54044: LD_VAR 0 4
54048: PUSH
54049: LD_INT 2
54051: ARRAY
54052: PPUSH
54053: CALL_OW 458
54057: NOT
54058: IFFALSE 54062
// continue ;
54060: GO 54032
// if HexInfo ( i [ 1 ] , i [ 2 ] ) in tmp then
54062: LD_VAR 0 4
54066: PUSH
54067: LD_INT 1
54069: ARRAY
54070: PPUSH
54071: LD_VAR 0 4
54075: PUSH
54076: LD_INT 2
54078: ARRAY
54079: PPUSH
54080: CALL_OW 428
54084: PUSH
54085: LD_VAR 0 5
54089: IN
54090: IFFALSE 54119
// LaunchMineAtPos ( i [ 1 ] , i [ 2 ] , side ) ;
54092: LD_VAR 0 4
54096: PUSH
54097: LD_INT 1
54099: ARRAY
54100: PPUSH
54101: LD_VAR 0 4
54105: PUSH
54106: LD_INT 2
54108: ARRAY
54109: PPUSH
54110: LD_VAR 0 1
54114: PPUSH
54115: CALL_OW 456
// end ;
54119: GO 54032
54121: POP
54122: POP
// end ;
54123: LD_VAR 0 3
54127: RET
// export function Count ( array ) ; var i ; begin
54128: LD_INT 0
54130: PPUSH
54131: PPUSH
// result := 0 ;
54132: LD_ADDR_VAR 0 2
54136: PUSH
54137: LD_INT 0
54139: ST_TO_ADDR
// for i in array do
54140: LD_ADDR_VAR 0 3
54144: PUSH
54145: LD_VAR 0 1
54149: PUSH
54150: FOR_IN
54151: IFFALSE 54175
// if i then
54153: LD_VAR 0 3
54157: IFFALSE 54173
// result := result + 1 ;
54159: LD_ADDR_VAR 0 2
54163: PUSH
54164: LD_VAR 0 2
54168: PUSH
54169: LD_INT 1
54171: PLUS
54172: ST_TO_ADDR
54173: GO 54150
54175: POP
54176: POP
// end ;
54177: LD_VAR 0 2
54181: RET
// export function IsEmpty ( building ) ; begin
54182: LD_INT 0
54184: PPUSH
// if not building then
54185: LD_VAR 0 1
54189: NOT
54190: IFFALSE 54194
// exit ;
54192: GO 54237
// result := building in FilterAllUnits ( [ [ f_side , GetSide ( building ) ] , [ f_empty ] ] ) ;
54194: LD_ADDR_VAR 0 2
54198: PUSH
54199: LD_VAR 0 1
54203: PUSH
54204: LD_INT 22
54206: PUSH
54207: LD_VAR 0 1
54211: PPUSH
54212: CALL_OW 255
54216: PUSH
54217: EMPTY
54218: LIST
54219: LIST
54220: PUSH
54221: LD_INT 58
54223: PUSH
54224: EMPTY
54225: LIST
54226: PUSH
54227: EMPTY
54228: LIST
54229: LIST
54230: PPUSH
54231: CALL_OW 69
54235: IN
54236: ST_TO_ADDR
// end ;
54237: LD_VAR 0 2
54241: RET
// export function IsNotFull ( building ) ; begin
54242: LD_INT 0
54244: PPUSH
// if not building then
54245: LD_VAR 0 1
54249: NOT
54250: IFFALSE 54254
// exit ;
54252: GO 54273
// result := UnitsInside ( building ) < 6 ;
54254: LD_ADDR_VAR 0 2
54258: PUSH
54259: LD_VAR 0 1
54263: PPUSH
54264: CALL_OW 313
54268: PUSH
54269: LD_INT 6
54271: LESS
54272: ST_TO_ADDR
// end ;
54273: LD_VAR 0 2
54277: RET
// export function GetFacExt ( factory ) ; var tmp , i , list ; begin
54278: LD_INT 0
54280: PPUSH
54281: PPUSH
54282: PPUSH
54283: PPUSH
// tmp := [ ] ;
54284: LD_ADDR_VAR 0 3
54288: PUSH
54289: EMPTY
54290: ST_TO_ADDR
// list := [ ] ;
54291: LD_ADDR_VAR 0 5
54295: PUSH
54296: EMPTY
54297: ST_TO_ADDR
// for i = 16 to 25 do
54298: LD_ADDR_VAR 0 4
54302: PUSH
54303: DOUBLE
54304: LD_INT 16
54306: DEC
54307: ST_TO_ADDR
54308: LD_INT 25
54310: PUSH
54311: FOR_TO
54312: IFFALSE 54385
// tmp := tmp ^ FilterAllUnits ( [ [ [ f_side , GetSide ( factory ) ] , [ f_dist , factory , 6 ] , [ f_btype , i ] ] ] ) ;
54314: LD_ADDR_VAR 0 3
54318: PUSH
54319: LD_VAR 0 3
54323: PUSH
54324: LD_INT 22
54326: PUSH
54327: LD_VAR 0 1
54331: PPUSH
54332: CALL_OW 255
54336: PUSH
54337: EMPTY
54338: LIST
54339: LIST
54340: PUSH
54341: LD_INT 91
54343: PUSH
54344: LD_VAR 0 1
54348: PUSH
54349: LD_INT 6
54351: PUSH
54352: EMPTY
54353: LIST
54354: LIST
54355: LIST
54356: PUSH
54357: LD_INT 30
54359: PUSH
54360: LD_VAR 0 4
54364: PUSH
54365: EMPTY
54366: LIST
54367: LIST
54368: PUSH
54369: EMPTY
54370: LIST
54371: LIST
54372: LIST
54373: PUSH
54374: EMPTY
54375: LIST
54376: PPUSH
54377: CALL_OW 69
54381: ADD
54382: ST_TO_ADDR
54383: GO 54311
54385: POP
54386: POP
// for i = 1 to tmp do
54387: LD_ADDR_VAR 0 4
54391: PUSH
54392: DOUBLE
54393: LD_INT 1
54395: DEC
54396: ST_TO_ADDR
54397: LD_VAR 0 3
54401: PUSH
54402: FOR_TO
54403: IFFALSE 54491
// list := list ^ [ [ GetBType ( tmp [ i ] ) , GetX ( tmp [ i ] ) , GetY ( tmp [ i ] ) , GetDir ( tmp [ i ] ) ] ] ;
54405: LD_ADDR_VAR 0 5
54409: PUSH
54410: LD_VAR 0 5
54414: PUSH
54415: LD_VAR 0 3
54419: PUSH
54420: LD_VAR 0 4
54424: ARRAY
54425: PPUSH
54426: CALL_OW 266
54430: PUSH
54431: LD_VAR 0 3
54435: PUSH
54436: LD_VAR 0 4
54440: ARRAY
54441: PPUSH
54442: CALL_OW 250
54446: PUSH
54447: LD_VAR 0 3
54451: PUSH
54452: LD_VAR 0 4
54456: ARRAY
54457: PPUSH
54458: CALL_OW 251
54462: PUSH
54463: LD_VAR 0 3
54467: PUSH
54468: LD_VAR 0 4
54472: ARRAY
54473: PPUSH
54474: CALL_OW 254
54478: PUSH
54479: EMPTY
54480: LIST
54481: LIST
54482: LIST
54483: LIST
54484: PUSH
54485: EMPTY
54486: LIST
54487: ADD
54488: ST_TO_ADDR
54489: GO 54402
54491: POP
54492: POP
// result := list ;
54493: LD_ADDR_VAR 0 2
54497: PUSH
54498: LD_VAR 0 5
54502: ST_TO_ADDR
// end ;
54503: LD_VAR 0 2
54507: RET
// export function Produce ( factory , chassis , engine , control , weapon ) ; var i , tmp , _chassis , _weapon , _engine , _control ; begin
54508: LD_INT 0
54510: PPUSH
54511: PPUSH
54512: PPUSH
54513: PPUSH
54514: PPUSH
54515: PPUSH
54516: PPUSH
// if not factory then
54517: LD_VAR 0 1
54521: NOT
54522: IFFALSE 54526
// exit ;
54524: GO 55119
// if control = control_apeman then
54526: LD_VAR 0 4
54530: PUSH
54531: LD_INT 5
54533: EQUAL
54534: IFFALSE 54643
// begin tmp := UnitsInside ( factory ) ;
54536: LD_ADDR_VAR 0 8
54540: PUSH
54541: LD_VAR 0 1
54545: PPUSH
54546: CALL_OW 313
54550: ST_TO_ADDR
// if not UnitFilter ( tmp , [ f_class , class_apeman ] ) then
54551: LD_VAR 0 8
54555: PPUSH
54556: LD_INT 25
54558: PUSH
54559: LD_INT 12
54561: PUSH
54562: EMPTY
54563: LIST
54564: LIST
54565: PPUSH
54566: CALL_OW 72
54570: NOT
54571: IFFALSE 54581
// control := control_manual ;
54573: LD_ADDR_VAR 0 4
54577: PUSH
54578: LD_INT 1
54580: ST_TO_ADDR
// tmp := GetFacExt ( factory ) ;
54581: LD_ADDR_VAR 0 8
54585: PUSH
54586: LD_VAR 0 1
54590: PPUSH
54591: CALL 54278 0 1
54595: ST_TO_ADDR
// if tmp then
54596: LD_VAR 0 8
54600: IFFALSE 54643
// begin for i in tmp do
54602: LD_ADDR_VAR 0 7
54606: PUSH
54607: LD_VAR 0 8
54611: PUSH
54612: FOR_IN
54613: IFFALSE 54641
// if i [ 1 ] = b_ext_radio then
54615: LD_VAR 0 7
54619: PUSH
54620: LD_INT 1
54622: ARRAY
54623: PUSH
54624: LD_INT 22
54626: EQUAL
54627: IFFALSE 54639
// begin control := control_remote ;
54629: LD_ADDR_VAR 0 4
54633: PUSH
54634: LD_INT 2
54636: ST_TO_ADDR
// break ;
54637: GO 54641
// end ;
54639: GO 54612
54641: POP
54642: POP
// end ; end ; if CanBeConstructed ( factory , chassis , engine , control , weapon ) then
54643: LD_VAR 0 1
54647: PPUSH
54648: LD_VAR 0 2
54652: PPUSH
54653: LD_VAR 0 3
54657: PPUSH
54658: LD_VAR 0 4
54662: PPUSH
54663: LD_VAR 0 5
54667: PPUSH
54668: CALL_OW 448
54672: IFFALSE 54707
// begin result := [ chassis , engine , control , weapon ] ;
54674: LD_ADDR_VAR 0 6
54678: PUSH
54679: LD_VAR 0 2
54683: PUSH
54684: LD_VAR 0 3
54688: PUSH
54689: LD_VAR 0 4
54693: PUSH
54694: LD_VAR 0 5
54698: PUSH
54699: EMPTY
54700: LIST
54701: LIST
54702: LIST
54703: LIST
54704: ST_TO_ADDR
// exit ;
54705: GO 55119
// end ; _chassis := AvailableChassisList ( factory ) ;
54707: LD_ADDR_VAR 0 9
54711: PUSH
54712: LD_VAR 0 1
54716: PPUSH
54717: CALL_OW 475
54721: ST_TO_ADDR
// _engine := AvailableEngineList ( factory ) ;
54722: LD_ADDR_VAR 0 11
54726: PUSH
54727: LD_VAR 0 1
54731: PPUSH
54732: CALL_OW 476
54736: ST_TO_ADDR
// _control := AvailableControlList ( factory ) ;
54737: LD_ADDR_VAR 0 12
54741: PUSH
54742: LD_VAR 0 1
54746: PPUSH
54747: CALL_OW 477
54751: ST_TO_ADDR
// _weapon := AvailableWeaponList ( factory ) ;
54752: LD_ADDR_VAR 0 10
54756: PUSH
54757: LD_VAR 0 1
54761: PPUSH
54762: CALL_OW 478
54766: ST_TO_ADDR
// if not _chassis or not _engine or not _control or not _weapon then
54767: LD_VAR 0 9
54771: NOT
54772: PUSH
54773: LD_VAR 0 11
54777: NOT
54778: OR
54779: PUSH
54780: LD_VAR 0 12
54784: NOT
54785: OR
54786: PUSH
54787: LD_VAR 0 10
54791: NOT
54792: OR
54793: IFFALSE 54828
// begin result := [ chassis , engine , control , weapon ] ;
54795: LD_ADDR_VAR 0 6
54799: PUSH
54800: LD_VAR 0 2
54804: PUSH
54805: LD_VAR 0 3
54809: PUSH
54810: LD_VAR 0 4
54814: PUSH
54815: LD_VAR 0 5
54819: PUSH
54820: EMPTY
54821: LIST
54822: LIST
54823: LIST
54824: LIST
54825: ST_TO_ADDR
// exit ;
54826: GO 55119
// end ; if not chassis in _chassis then
54828: LD_VAR 0 2
54832: PUSH
54833: LD_VAR 0 9
54837: IN
54838: NOT
54839: IFFALSE 54865
// chassis := _chassis [ rand ( 1 , _chassis ) ] ;
54841: LD_ADDR_VAR 0 2
54845: PUSH
54846: LD_VAR 0 9
54850: PUSH
54851: LD_INT 1
54853: PPUSH
54854: LD_VAR 0 9
54858: PPUSH
54859: CALL_OW 12
54863: ARRAY
54864: ST_TO_ADDR
// if not EngineCanBeMount ( chassis , engine ) then
54865: LD_VAR 0 2
54869: PPUSH
54870: LD_VAR 0 3
54874: PPUSH
54875: CALL 55124 0 2
54879: NOT
54880: IFFALSE 54939
// repeat engine := _engine [ 1 ] ;
54882: LD_ADDR_VAR 0 3
54886: PUSH
54887: LD_VAR 0 11
54891: PUSH
54892: LD_INT 1
54894: ARRAY
54895: ST_TO_ADDR
// _engine := Delete ( _engine , 1 ) ;
54896: LD_ADDR_VAR 0 11
54900: PUSH
54901: LD_VAR 0 11
54905: PPUSH
54906: LD_INT 1
54908: PPUSH
54909: CALL_OW 3
54913: ST_TO_ADDR
// until EngineCanBeMount ( chassis , engine ) or _engine = [ ] ;
54914: LD_VAR 0 2
54918: PPUSH
54919: LD_VAR 0 3
54923: PPUSH
54924: CALL 55124 0 2
54928: PUSH
54929: LD_VAR 0 11
54933: PUSH
54934: EMPTY
54935: EQUAL
54936: OR
54937: IFFALSE 54882
// if not control in _control then
54939: LD_VAR 0 4
54943: PUSH
54944: LD_VAR 0 12
54948: IN
54949: NOT
54950: IFFALSE 54976
// control := _control [ rand ( 1 , _control ) ] ;
54952: LD_ADDR_VAR 0 4
54956: PUSH
54957: LD_VAR 0 12
54961: PUSH
54962: LD_INT 1
54964: PPUSH
54965: LD_VAR 0 12
54969: PPUSH
54970: CALL_OW 12
54974: ARRAY
54975: ST_TO_ADDR
// if not WeaponCanBeMount ( chassis , weapon ) then
54976: LD_VAR 0 2
54980: PPUSH
54981: LD_VAR 0 5
54985: PPUSH
54986: CALL 55344 0 2
54990: NOT
54991: IFFALSE 55050
// repeat weapon := _weapon [ 1 ] ;
54993: LD_ADDR_VAR 0 5
54997: PUSH
54998: LD_VAR 0 10
55002: PUSH
55003: LD_INT 1
55005: ARRAY
55006: ST_TO_ADDR
// _weapon := Delete ( _weapon , 1 ) ;
55007: LD_ADDR_VAR 0 10
55011: PUSH
55012: LD_VAR 0 10
55016: PPUSH
55017: LD_INT 1
55019: PPUSH
55020: CALL_OW 3
55024: ST_TO_ADDR
// until WeaponCanBeMount ( chassis , weapon ) or _weapon = [ ] ;
55025: LD_VAR 0 2
55029: PPUSH
55030: LD_VAR 0 5
55034: PPUSH
55035: CALL 55344 0 2
55039: PUSH
55040: LD_VAR 0 10
55044: PUSH
55045: EMPTY
55046: EQUAL
55047: OR
55048: IFFALSE 54993
// result := [ ] ;
55050: LD_ADDR_VAR 0 6
55054: PUSH
55055: EMPTY
55056: ST_TO_ADDR
// if CanBeConstructed ( factory , chassis , engine , control , weapon ) then
55057: LD_VAR 0 1
55061: PPUSH
55062: LD_VAR 0 2
55066: PPUSH
55067: LD_VAR 0 3
55071: PPUSH
55072: LD_VAR 0 4
55076: PPUSH
55077: LD_VAR 0 5
55081: PPUSH
55082: CALL_OW 448
55086: IFFALSE 55119
// result := [ chassis , engine , control , weapon ] ;
55088: LD_ADDR_VAR 0 6
55092: PUSH
55093: LD_VAR 0 2
55097: PUSH
55098: LD_VAR 0 3
55102: PUSH
55103: LD_VAR 0 4
55107: PUSH
55108: LD_VAR 0 5
55112: PUSH
55113: EMPTY
55114: LIST
55115: LIST
55116: LIST
55117: LIST
55118: ST_TO_ADDR
// end ;
55119: LD_VAR 0 6
55123: RET
// export function EngineCanBeMount ( chassis , engine ) ; begin
55124: LD_INT 0
55126: PPUSH
// if not chassis or not engine then
55127: LD_VAR 0 1
55131: NOT
55132: PUSH
55133: LD_VAR 0 2
55137: NOT
55138: OR
55139: IFFALSE 55143
// exit ;
55141: GO 55339
// case engine of engine_solar :
55143: LD_VAR 0 2
55147: PUSH
55148: LD_INT 2
55150: DOUBLE
55151: EQUAL
55152: IFTRUE 55156
55154: GO 55194
55156: POP
// result := [ ar_hovercraft , ar_light_trike , ar_medium_trike , ar_half_tracked , us_light_wheeled , us_medium_wheeled , us_medium_tracked ] ; engine_combustion :
55157: LD_ADDR_VAR 0 3
55161: PUSH
55162: LD_INT 11
55164: PUSH
55165: LD_INT 12
55167: PUSH
55168: LD_INT 13
55170: PUSH
55171: LD_INT 14
55173: PUSH
55174: LD_INT 1
55176: PUSH
55177: LD_INT 2
55179: PUSH
55180: LD_INT 3
55182: PUSH
55183: EMPTY
55184: LIST
55185: LIST
55186: LIST
55187: LIST
55188: LIST
55189: LIST
55190: LIST
55191: ST_TO_ADDR
55192: GO 55323
55194: LD_INT 1
55196: DOUBLE
55197: EQUAL
55198: IFTRUE 55202
55200: GO 55264
55202: POP
// result := [ ar_hovercraft , ar_light_trike , ar_medium_trike , ar_half_tracked , us_light_wheeled , us_medium_wheeled , us_medium_tracked , us_heavy_tracked , us_morphling , ru_medium_wheeled , ru_heavy_wheeled , ru_medium_tracked , ru_heavy_tracked ] ; engine_siberite :
55203: LD_ADDR_VAR 0 3
55207: PUSH
55208: LD_INT 11
55210: PUSH
55211: LD_INT 12
55213: PUSH
55214: LD_INT 13
55216: PUSH
55217: LD_INT 14
55219: PUSH
55220: LD_INT 1
55222: PUSH
55223: LD_INT 2
55225: PUSH
55226: LD_INT 3
55228: PUSH
55229: LD_INT 4
55231: PUSH
55232: LD_INT 5
55234: PUSH
55235: LD_INT 21
55237: PUSH
55238: LD_INT 23
55240: PUSH
55241: LD_INT 22
55243: PUSH
55244: LD_INT 24
55246: PUSH
55247: EMPTY
55248: LIST
55249: LIST
55250: LIST
55251: LIST
55252: LIST
55253: LIST
55254: LIST
55255: LIST
55256: LIST
55257: LIST
55258: LIST
55259: LIST
55260: LIST
55261: ST_TO_ADDR
55262: GO 55323
55264: LD_INT 3
55266: DOUBLE
55267: EQUAL
55268: IFTRUE 55272
55270: GO 55322
55272: POP
// result := [ ar_medium_trike , ar_half_tracked , us_medium_wheeled , us_medium_tracked , us_heavy_tracked , us_morphling , ru_medium_wheeled , ru_medium_tracked , ru_heavy_wheeled , ru_heavy_tracked ] ; end ;
55273: LD_ADDR_VAR 0 3
55277: PUSH
55278: LD_INT 13
55280: PUSH
55281: LD_INT 14
55283: PUSH
55284: LD_INT 2
55286: PUSH
55287: LD_INT 3
55289: PUSH
55290: LD_INT 4
55292: PUSH
55293: LD_INT 5
55295: PUSH
55296: LD_INT 21
55298: PUSH
55299: LD_INT 22
55301: PUSH
55302: LD_INT 23
55304: PUSH
55305: LD_INT 24
55307: PUSH
55308: EMPTY
55309: LIST
55310: LIST
55311: LIST
55312: LIST
55313: LIST
55314: LIST
55315: LIST
55316: LIST
55317: LIST
55318: LIST
55319: ST_TO_ADDR
55320: GO 55323
55322: POP
// result := ( chassis in result ) ;
55323: LD_ADDR_VAR 0 3
55327: PUSH
55328: LD_VAR 0 1
55332: PUSH
55333: LD_VAR 0 3
55337: IN
55338: ST_TO_ADDR
// end ;
55339: LD_VAR 0 3
55343: RET
// export function WeaponCanBeMount ( chassis , weapon ) ; begin
55344: LD_INT 0
55346: PPUSH
// if not chassis or not weapon then
55347: LD_VAR 0 1
55351: NOT
55352: PUSH
55353: LD_VAR 0 2
55357: NOT
55358: OR
55359: IFFALSE 55363
// exit ;
55361: GO 56425
// case weapon of us_machine_gun :
55363: LD_VAR 0 2
55367: PUSH
55368: LD_INT 2
55370: DOUBLE
55371: EQUAL
55372: IFTRUE 55376
55374: GO 55406
55376: POP
// result := [ us_light_wheeled , us_medium_wheeled , us_medium_tracked , us_heavy_tracked , us_morphling ] ; us_light_gun :
55377: LD_ADDR_VAR 0 3
55381: PUSH
55382: LD_INT 1
55384: PUSH
55385: LD_INT 2
55387: PUSH
55388: LD_INT 3
55390: PUSH
55391: LD_INT 4
55393: PUSH
55394: LD_INT 5
55396: PUSH
55397: EMPTY
55398: LIST
55399: LIST
55400: LIST
55401: LIST
55402: LIST
55403: ST_TO_ADDR
55404: GO 56409
55406: LD_INT 3
55408: DOUBLE
55409: EQUAL
55410: IFTRUE 55414
55412: GO 55444
55414: POP
// result := [ us_light_wheeled , us_medium_wheeled , us_medium_tracked , us_heavy_tracked , us_morphling ] ; us_radar :
55415: LD_ADDR_VAR 0 3
55419: PUSH
55420: LD_INT 1
55422: PUSH
55423: LD_INT 2
55425: PUSH
55426: LD_INT 3
55428: PUSH
55429: LD_INT 4
55431: PUSH
55432: LD_INT 5
55434: PUSH
55435: EMPTY
55436: LIST
55437: LIST
55438: LIST
55439: LIST
55440: LIST
55441: ST_TO_ADDR
55442: GO 56409
55444: LD_INT 11
55446: DOUBLE
55447: EQUAL
55448: IFTRUE 55452
55450: GO 55482
55452: POP
// result := [ us_light_wheeled , us_medium_wheeled , us_medium_tracked , us_heavy_tracked , us_morphling ] ; us_gatling_gun :
55453: LD_ADDR_VAR 0 3
55457: PUSH
55458: LD_INT 1
55460: PUSH
55461: LD_INT 2
55463: PUSH
55464: LD_INT 3
55466: PUSH
55467: LD_INT 4
55469: PUSH
55470: LD_INT 5
55472: PUSH
55473: EMPTY
55474: LIST
55475: LIST
55476: LIST
55477: LIST
55478: LIST
55479: ST_TO_ADDR
55480: GO 56409
55482: LD_INT 4
55484: DOUBLE
55485: EQUAL
55486: IFTRUE 55490
55488: GO 55516
55490: POP
// result := [ us_medium_wheeled , us_medium_tracked , us_heavy_tracked , us_morphling ] ; us_double_gun :
55491: LD_ADDR_VAR 0 3
55495: PUSH
55496: LD_INT 2
55498: PUSH
55499: LD_INT 3
55501: PUSH
55502: LD_INT 4
55504: PUSH
55505: LD_INT 5
55507: PUSH
55508: EMPTY
55509: LIST
55510: LIST
55511: LIST
55512: LIST
55513: ST_TO_ADDR
55514: GO 56409
55516: LD_INT 5
55518: DOUBLE
55519: EQUAL
55520: IFTRUE 55524
55522: GO 55550
55524: POP
// result := [ us_medium_wheeled , us_medium_tracked , us_heavy_tracked , us_morphling ] ; us_laser :
55525: LD_ADDR_VAR 0 3
55529: PUSH
55530: LD_INT 2
55532: PUSH
55533: LD_INT 3
55535: PUSH
55536: LD_INT 4
55538: PUSH
55539: LD_INT 5
55541: PUSH
55542: EMPTY
55543: LIST
55544: LIST
55545: LIST
55546: LIST
55547: ST_TO_ADDR
55548: GO 56409
55550: LD_INT 9
55552: DOUBLE
55553: EQUAL
55554: IFTRUE 55558
55556: GO 55584
55558: POP
// result := [ us_medium_wheeled , us_medium_tracked , us_heavy_tracked , us_morphling ] ; us_rocket_launcher :
55559: LD_ADDR_VAR 0 3
55563: PUSH
55564: LD_INT 2
55566: PUSH
55567: LD_INT 3
55569: PUSH
55570: LD_INT 4
55572: PUSH
55573: LD_INT 5
55575: PUSH
55576: EMPTY
55577: LIST
55578: LIST
55579: LIST
55580: LIST
55581: ST_TO_ADDR
55582: GO 56409
55584: LD_INT 7
55586: DOUBLE
55587: EQUAL
55588: IFTRUE 55592
55590: GO 55618
55592: POP
// result := [ us_medium_wheeled , us_medium_tracked , us_heavy_tracked , us_morphling ] ; us_cargo_bay :
55593: LD_ADDR_VAR 0 3
55597: PUSH
55598: LD_INT 2
55600: PUSH
55601: LD_INT 3
55603: PUSH
55604: LD_INT 4
55606: PUSH
55607: LD_INT 5
55609: PUSH
55610: EMPTY
55611: LIST
55612: LIST
55613: LIST
55614: LIST
55615: ST_TO_ADDR
55616: GO 56409
55618: LD_INT 12
55620: DOUBLE
55621: EQUAL
55622: IFTRUE 55626
55624: GO 55652
55626: POP
// result := [ us_medium_wheeled , us_medium_tracked , us_heavy_tracked , us_morphling ] ; us_crane :
55627: LD_ADDR_VAR 0 3
55631: PUSH
55632: LD_INT 2
55634: PUSH
55635: LD_INT 3
55637: PUSH
55638: LD_INT 4
55640: PUSH
55641: LD_INT 5
55643: PUSH
55644: EMPTY
55645: LIST
55646: LIST
55647: LIST
55648: LIST
55649: ST_TO_ADDR
55650: GO 56409
55652: LD_INT 13
55654: DOUBLE
55655: EQUAL
55656: IFTRUE 55660
55658: GO 55686
55660: POP
// result := [ us_medium_wheeled , us_medium_tracked , us_heavy_tracked , us_morphling ] ; us_bulldozer :
55661: LD_ADDR_VAR 0 3
55665: PUSH
55666: LD_INT 2
55668: PUSH
55669: LD_INT 3
55671: PUSH
55672: LD_INT 4
55674: PUSH
55675: LD_INT 5
55677: PUSH
55678: EMPTY
55679: LIST
55680: LIST
55681: LIST
55682: LIST
55683: ST_TO_ADDR
55684: GO 56409
55686: LD_INT 14
55688: DOUBLE
55689: EQUAL
55690: IFTRUE 55694
55692: GO 55712
55694: POP
// result := [ us_heavy_tracked , us_morphling ] ; us_heavy_gun :
55695: LD_ADDR_VAR 0 3
55699: PUSH
55700: LD_INT 4
55702: PUSH
55703: LD_INT 5
55705: PUSH
55706: EMPTY
55707: LIST
55708: LIST
55709: ST_TO_ADDR
55710: GO 56409
55712: LD_INT 6
55714: DOUBLE
55715: EQUAL
55716: IFTRUE 55720
55718: GO 55738
55720: POP
// result := [ us_heavy_tracked , us_morphling ] ; us_double_laser :
55721: LD_ADDR_VAR 0 3
55725: PUSH
55726: LD_INT 4
55728: PUSH
55729: LD_INT 5
55731: PUSH
55732: EMPTY
55733: LIST
55734: LIST
55735: ST_TO_ADDR
55736: GO 56409
55738: LD_INT 10
55740: DOUBLE
55741: EQUAL
55742: IFTRUE 55746
55744: GO 55764
55746: POP
// result := [ us_heavy_tracked , us_morphling ] ; ar_multimissile_ballista :
55747: LD_ADDR_VAR 0 3
55751: PUSH
55752: LD_INT 4
55754: PUSH
55755: LD_INT 5
55757: PUSH
55758: EMPTY
55759: LIST
55760: LIST
55761: ST_TO_ADDR
55762: GO 56409
55764: LD_INT 22
55766: DOUBLE
55767: EQUAL
55768: IFTRUE 55772
55770: GO 55798
55772: POP
// result := [ ar_hovercraft , ar_light_trike , ar_medium_trike , ar_half_tracked ] ; ar_light_gun :
55773: LD_ADDR_VAR 0 3
55777: PUSH
55778: LD_INT 11
55780: PUSH
55781: LD_INT 12
55783: PUSH
55784: LD_INT 13
55786: PUSH
55787: LD_INT 14
55789: PUSH
55790: EMPTY
55791: LIST
55792: LIST
55793: LIST
55794: LIST
55795: ST_TO_ADDR
55796: GO 56409
55798: LD_INT 23
55800: DOUBLE
55801: EQUAL
55802: IFTRUE 55806
55804: GO 55832
55806: POP
// result := [ ar_hovercraft , ar_light_trike , ar_medium_trike , ar_half_tracked ] ; ar_double_machine_gun :
55807: LD_ADDR_VAR 0 3
55811: PUSH
55812: LD_INT 11
55814: PUSH
55815: LD_INT 12
55817: PUSH
55818: LD_INT 13
55820: PUSH
55821: LD_INT 14
55823: PUSH
55824: EMPTY
55825: LIST
55826: LIST
55827: LIST
55828: LIST
55829: ST_TO_ADDR
55830: GO 56409
55832: LD_INT 24
55834: DOUBLE
55835: EQUAL
55836: IFTRUE 55840
55838: GO 55866
55840: POP
// result := [ ar_hovercraft , ar_light_trike , ar_medium_trike , ar_half_tracked ] ; ar_radar :
55841: LD_ADDR_VAR 0 3
55845: PUSH
55846: LD_INT 11
55848: PUSH
55849: LD_INT 12
55851: PUSH
55852: LD_INT 13
55854: PUSH
55855: LD_INT 14
55857: PUSH
55858: EMPTY
55859: LIST
55860: LIST
55861: LIST
55862: LIST
55863: ST_TO_ADDR
55864: GO 56409
55866: LD_INT 30
55868: DOUBLE
55869: EQUAL
55870: IFTRUE 55874
55872: GO 55900
55874: POP
// result := [ ar_hovercraft , ar_light_trike , ar_medium_trike , ar_half_tracked ] ; ar_gatling_gun :
55875: LD_ADDR_VAR 0 3
55879: PUSH
55880: LD_INT 11
55882: PUSH
55883: LD_INT 12
55885: PUSH
55886: LD_INT 13
55888: PUSH
55889: LD_INT 14
55891: PUSH
55892: EMPTY
55893: LIST
55894: LIST
55895: LIST
55896: LIST
55897: ST_TO_ADDR
55898: GO 56409
55900: LD_INT 25
55902: DOUBLE
55903: EQUAL
55904: IFTRUE 55908
55906: GO 55926
55908: POP
// result := [ ar_medium_trike , ar_half_tracked ] ; ar_gun :
55909: LD_ADDR_VAR 0 3
55913: PUSH
55914: LD_INT 13
55916: PUSH
55917: LD_INT 14
55919: PUSH
55920: EMPTY
55921: LIST
55922: LIST
55923: ST_TO_ADDR
55924: GO 56409
55926: LD_INT 27
55928: DOUBLE
55929: EQUAL
55930: IFTRUE 55934
55932: GO 55952
55934: POP
// result := [ ar_medium_trike , ar_half_tracked ] ; ar_mortar :
55935: LD_ADDR_VAR 0 3
55939: PUSH
55940: LD_INT 13
55942: PUSH
55943: LD_INT 14
55945: PUSH
55946: EMPTY
55947: LIST
55948: LIST
55949: ST_TO_ADDR
55950: GO 56409
55952: LD_EXP 79
55956: DOUBLE
55957: EQUAL
55958: IFTRUE 55962
55960: GO 55988
55962: POP
// result := [ ar_hovercraft , ar_light_trike , ar_medium_trike , ar_half_tracked ] ; ar_rocket_launcher :
55963: LD_ADDR_VAR 0 3
55967: PUSH
55968: LD_INT 11
55970: PUSH
55971: LD_INT 12
55973: PUSH
55974: LD_INT 13
55976: PUSH
55977: LD_INT 14
55979: PUSH
55980: EMPTY
55981: LIST
55982: LIST
55983: LIST
55984: LIST
55985: ST_TO_ADDR
55986: GO 56409
55988: LD_INT 28
55990: DOUBLE
55991: EQUAL
55992: IFTRUE 55996
55994: GO 56014
55996: POP
// result := [ ar_medium_trike , ar_half_tracked ] ; ar_selfpropelled_bomb :
55997: LD_ADDR_VAR 0 3
56001: PUSH
56002: LD_INT 13
56004: PUSH
56005: LD_INT 14
56007: PUSH
56008: EMPTY
56009: LIST
56010: LIST
56011: ST_TO_ADDR
56012: GO 56409
56014: LD_INT 29
56016: DOUBLE
56017: EQUAL
56018: IFTRUE 56022
56020: GO 56040
56022: POP
// result := [ ar_medium_trike , ar_half_tracked ] ; ar_control_tower :
56023: LD_ADDR_VAR 0 3
56027: PUSH
56028: LD_INT 13
56030: PUSH
56031: LD_INT 14
56033: PUSH
56034: EMPTY
56035: LIST
56036: LIST
56037: ST_TO_ADDR
56038: GO 56409
56040: LD_INT 31
56042: DOUBLE
56043: EQUAL
56044: IFTRUE 56048
56046: GO 56066
56048: POP
// result := [ ar_medium_trike , ar_half_tracked ] ; ar_flame_thrower :
56049: LD_ADDR_VAR 0 3
56053: PUSH
56054: LD_INT 13
56056: PUSH
56057: LD_INT 14
56059: PUSH
56060: EMPTY
56061: LIST
56062: LIST
56063: ST_TO_ADDR
56064: GO 56409
56066: LD_INT 26
56068: DOUBLE
56069: EQUAL
56070: IFTRUE 56074
56072: GO 56092
56074: POP
// result := [ ar_medium_trike , ar_half_tracked ] ; ru_heavy_machine_gun :
56075: LD_ADDR_VAR 0 3
56079: PUSH
56080: LD_INT 13
56082: PUSH
56083: LD_INT 14
56085: PUSH
56086: EMPTY
56087: LIST
56088: LIST
56089: ST_TO_ADDR
56090: GO 56409
56092: LD_INT 42
56094: DOUBLE
56095: EQUAL
56096: IFTRUE 56100
56098: GO 56126
56100: POP
// result := [ ru_medium_wheeled , ru_medium_tracked , ru_heavy_wheeled , ru_heavy_tracked ] ; ru_gatling_gun :
56101: LD_ADDR_VAR 0 3
56105: PUSH
56106: LD_INT 21
56108: PUSH
56109: LD_INT 22
56111: PUSH
56112: LD_INT 23
56114: PUSH
56115: LD_INT 24
56117: PUSH
56118: EMPTY
56119: LIST
56120: LIST
56121: LIST
56122: LIST
56123: ST_TO_ADDR
56124: GO 56409
56126: LD_INT 43
56128: DOUBLE
56129: EQUAL
56130: IFTRUE 56134
56132: GO 56160
56134: POP
// result := [ ru_medium_wheeled , ru_medium_tracked , ru_heavy_wheeled , ru_heavy_tracked ] ; ru_gun :
56135: LD_ADDR_VAR 0 3
56139: PUSH
56140: LD_INT 21
56142: PUSH
56143: LD_INT 22
56145: PUSH
56146: LD_INT 23
56148: PUSH
56149: LD_INT 24
56151: PUSH
56152: EMPTY
56153: LIST
56154: LIST
56155: LIST
56156: LIST
56157: ST_TO_ADDR
56158: GO 56409
56160: LD_INT 44
56162: DOUBLE
56163: EQUAL
56164: IFTRUE 56168
56166: GO 56194
56168: POP
// result := [ ru_medium_wheeled , ru_medium_tracked , ru_heavy_wheeled , ru_heavy_tracked ] ; ru_rocket_launcher :
56169: LD_ADDR_VAR 0 3
56173: PUSH
56174: LD_INT 21
56176: PUSH
56177: LD_INT 22
56179: PUSH
56180: LD_INT 23
56182: PUSH
56183: LD_INT 24
56185: PUSH
56186: EMPTY
56187: LIST
56188: LIST
56189: LIST
56190: LIST
56191: ST_TO_ADDR
56192: GO 56409
56194: LD_INT 45
56196: DOUBLE
56197: EQUAL
56198: IFTRUE 56202
56200: GO 56228
56202: POP
// result := [ ru_medium_wheeled , ru_medium_tracked , ru_heavy_wheeled , ru_heavy_tracked ] ; ru_time_lapser :
56203: LD_ADDR_VAR 0 3
56207: PUSH
56208: LD_INT 21
56210: PUSH
56211: LD_INT 22
56213: PUSH
56214: LD_INT 23
56216: PUSH
56217: LD_INT 24
56219: PUSH
56220: EMPTY
56221: LIST
56222: LIST
56223: LIST
56224: LIST
56225: ST_TO_ADDR
56226: GO 56409
56228: LD_INT 49
56230: DOUBLE
56231: EQUAL
56232: IFTRUE 56236
56234: GO 56262
56236: POP
// result := [ ru_medium_wheeled , ru_medium_tracked , ru_heavy_wheeled , ru_heavy_tracked ] ; ru_cargo_bay :
56237: LD_ADDR_VAR 0 3
56241: PUSH
56242: LD_INT 21
56244: PUSH
56245: LD_INT 22
56247: PUSH
56248: LD_INT 23
56250: PUSH
56251: LD_INT 24
56253: PUSH
56254: EMPTY
56255: LIST
56256: LIST
56257: LIST
56258: LIST
56259: ST_TO_ADDR
56260: GO 56409
56262: LD_INT 51
56264: DOUBLE
56265: EQUAL
56266: IFTRUE 56270
56268: GO 56296
56270: POP
// result := [ ru_medium_wheeled , ru_medium_tracked , ru_heavy_wheeled , ru_heavy_tracked ] ; ru_crane :
56271: LD_ADDR_VAR 0 3
56275: PUSH
56276: LD_INT 21
56278: PUSH
56279: LD_INT 22
56281: PUSH
56282: LD_INT 23
56284: PUSH
56285: LD_INT 24
56287: PUSH
56288: EMPTY
56289: LIST
56290: LIST
56291: LIST
56292: LIST
56293: ST_TO_ADDR
56294: GO 56409
56296: LD_INT 52
56298: DOUBLE
56299: EQUAL
56300: IFTRUE 56304
56302: GO 56330
56304: POP
// result := [ ru_medium_wheeled , ru_medium_tracked , ru_heavy_wheeled , ru_heavy_tracked ] ; ru_bulldozer :
56305: LD_ADDR_VAR 0 3
56309: PUSH
56310: LD_INT 21
56312: PUSH
56313: LD_INT 22
56315: PUSH
56316: LD_INT 23
56318: PUSH
56319: LD_INT 24
56321: PUSH
56322: EMPTY
56323: LIST
56324: LIST
56325: LIST
56326: LIST
56327: ST_TO_ADDR
56328: GO 56409
56330: LD_INT 53
56332: DOUBLE
56333: EQUAL
56334: IFTRUE 56338
56336: GO 56356
56338: POP
// result := [ ru_heavy_wheeled , ru_heavy_tracked ] ; ru_heavy_gun :
56339: LD_ADDR_VAR 0 3
56343: PUSH
56344: LD_INT 23
56346: PUSH
56347: LD_INT 24
56349: PUSH
56350: EMPTY
56351: LIST
56352: LIST
56353: ST_TO_ADDR
56354: GO 56409
56356: LD_INT 46
56358: DOUBLE
56359: EQUAL
56360: IFTRUE 56364
56362: GO 56382
56364: POP
// result := [ ru_heavy_wheeled , ru_heavy_tracked ] ; ru_rocket :
56365: LD_ADDR_VAR 0 3
56369: PUSH
56370: LD_INT 23
56372: PUSH
56373: LD_INT 24
56375: PUSH
56376: EMPTY
56377: LIST
56378: LIST
56379: ST_TO_ADDR
56380: GO 56409
56382: LD_INT 47
56384: DOUBLE
56385: EQUAL
56386: IFTRUE 56390
56388: GO 56408
56390: POP
// result := [ ru_heavy_wheeled , ru_heavy_tracked ] ; end ;
56391: LD_ADDR_VAR 0 3
56395: PUSH
56396: LD_INT 23
56398: PUSH
56399: LD_INT 24
56401: PUSH
56402: EMPTY
56403: LIST
56404: LIST
56405: ST_TO_ADDR
56406: GO 56409
56408: POP
// result := ( chassis in result ) ;
56409: LD_ADDR_VAR 0 3
56413: PUSH
56414: LD_VAR 0 1
56418: PUSH
56419: LD_VAR 0 3
56423: IN
56424: ST_TO_ADDR
// end ;
56425: LD_VAR 0 3
56429: RET
// export function Reindex ( array , i_from , i_to , direction ) ; var i , j , k , d , tmp , length ; begin
56430: LD_INT 0
56432: PPUSH
56433: PPUSH
56434: PPUSH
56435: PPUSH
56436: PPUSH
56437: PPUSH
56438: PPUSH
// result := array ;
56439: LD_ADDR_VAR 0 5
56443: PUSH
56444: LD_VAR 0 1
56448: ST_TO_ADDR
// if not array or not i_from or not i_to or i_from > array or i_to > array then
56449: LD_VAR 0 1
56453: NOT
56454: PUSH
56455: LD_VAR 0 2
56459: NOT
56460: OR
56461: PUSH
56462: LD_VAR 0 3
56466: NOT
56467: OR
56468: PUSH
56469: LD_VAR 0 2
56473: PUSH
56474: LD_VAR 0 1
56478: GREATER
56479: OR
56480: PUSH
56481: LD_VAR 0 3
56485: PUSH
56486: LD_VAR 0 1
56490: GREATER
56491: OR
56492: IFFALSE 56496
// exit ;
56494: GO 56792
// if direction then
56496: LD_VAR 0 4
56500: IFFALSE 56564
// begin d := 1 ;
56502: LD_ADDR_VAR 0 9
56506: PUSH
56507: LD_INT 1
56509: ST_TO_ADDR
// if i_from > i_to then
56510: LD_VAR 0 2
56514: PUSH
56515: LD_VAR 0 3
56519: GREATER
56520: IFFALSE 56546
// length := ( array - i_from ) + i_to else
56522: LD_ADDR_VAR 0 11
56526: PUSH
56527: LD_VAR 0 1
56531: PUSH
56532: LD_VAR 0 2
56536: MINUS
56537: PUSH
56538: LD_VAR 0 3
56542: PLUS
56543: ST_TO_ADDR
56544: GO 56562
// length := i_to - i_from ;
56546: LD_ADDR_VAR 0 11
56550: PUSH
56551: LD_VAR 0 3
56555: PUSH
56556: LD_VAR 0 2
56560: MINUS
56561: ST_TO_ADDR
// end else
56562: GO 56625
// begin d := - 1 ;
56564: LD_ADDR_VAR 0 9
56568: PUSH
56569: LD_INT 1
56571: NEG
56572: ST_TO_ADDR
// if i_from > i_to then
56573: LD_VAR 0 2
56577: PUSH
56578: LD_VAR 0 3
56582: GREATER
56583: IFFALSE 56603
// length := i_from - i_to else
56585: LD_ADDR_VAR 0 11
56589: PUSH
56590: LD_VAR 0 2
56594: PUSH
56595: LD_VAR 0 3
56599: MINUS
56600: ST_TO_ADDR
56601: GO 56625
// length := ( array - i_to ) + i_from ;
56603: LD_ADDR_VAR 0 11
56607: PUSH
56608: LD_VAR 0 1
56612: PUSH
56613: LD_VAR 0 3
56617: MINUS
56618: PUSH
56619: LD_VAR 0 2
56623: PLUS
56624: ST_TO_ADDR
// end ; if not length then
56625: LD_VAR 0 11
56629: NOT
56630: IFFALSE 56634
// exit ;
56632: GO 56792
// tmp := array ;
56634: LD_ADDR_VAR 0 10
56638: PUSH
56639: LD_VAR 0 1
56643: ST_TO_ADDR
// for i = 1 to length do
56644: LD_ADDR_VAR 0 6
56648: PUSH
56649: DOUBLE
56650: LD_INT 1
56652: DEC
56653: ST_TO_ADDR
56654: LD_VAR 0 11
56658: PUSH
56659: FOR_TO
56660: IFFALSE 56780
// begin for j = 1 to array do
56662: LD_ADDR_VAR 0 7
56666: PUSH
56667: DOUBLE
56668: LD_INT 1
56670: DEC
56671: ST_TO_ADDR
56672: LD_VAR 0 1
56676: PUSH
56677: FOR_TO
56678: IFFALSE 56766
// begin k := j + d ;
56680: LD_ADDR_VAR 0 8
56684: PUSH
56685: LD_VAR 0 7
56689: PUSH
56690: LD_VAR 0 9
56694: PLUS
56695: ST_TO_ADDR
// if k > array then
56696: LD_VAR 0 8
56700: PUSH
56701: LD_VAR 0 1
56705: GREATER
56706: IFFALSE 56716
// k := 1 ;
56708: LD_ADDR_VAR 0 8
56712: PUSH
56713: LD_INT 1
56715: ST_TO_ADDR
// if not k then
56716: LD_VAR 0 8
56720: NOT
56721: IFFALSE 56733
// k := array ;
56723: LD_ADDR_VAR 0 8
56727: PUSH
56728: LD_VAR 0 1
56732: ST_TO_ADDR
// tmp := Replace ( tmp , k , array [ j ] ) ;
56733: LD_ADDR_VAR 0 10
56737: PUSH
56738: LD_VAR 0 10
56742: PPUSH
56743: LD_VAR 0 8
56747: PPUSH
56748: LD_VAR 0 1
56752: PUSH
56753: LD_VAR 0 7
56757: ARRAY
56758: PPUSH
56759: CALL_OW 1
56763: ST_TO_ADDR
// end ;
56764: GO 56677
56766: POP
56767: POP
// array := tmp ;
56768: LD_ADDR_VAR 0 1
56772: PUSH
56773: LD_VAR 0 10
56777: ST_TO_ADDR
// end ;
56778: GO 56659
56780: POP
56781: POP
// result := array ;
56782: LD_ADDR_VAR 0 5
56786: PUSH
56787: LD_VAR 0 1
56791: ST_TO_ADDR
// end ;
56792: LD_VAR 0 5
56796: RET
// export function GetElementIndex ( array , value ) ; var i ; begin
56797: LD_INT 0
56799: PPUSH
56800: PPUSH
// result := 0 ;
56801: LD_ADDR_VAR 0 3
56805: PUSH
56806: LD_INT 0
56808: ST_TO_ADDR
// if not array or not value in array then
56809: LD_VAR 0 1
56813: NOT
56814: PUSH
56815: LD_VAR 0 2
56819: PUSH
56820: LD_VAR 0 1
56824: IN
56825: NOT
56826: OR
56827: IFFALSE 56831
// exit ;
56829: GO 56885
// for i = 1 to array do
56831: LD_ADDR_VAR 0 4
56835: PUSH
56836: DOUBLE
56837: LD_INT 1
56839: DEC
56840: ST_TO_ADDR
56841: LD_VAR 0 1
56845: PUSH
56846: FOR_TO
56847: IFFALSE 56883
// if value = array [ i ] then
56849: LD_VAR 0 2
56853: PUSH
56854: LD_VAR 0 1
56858: PUSH
56859: LD_VAR 0 4
56863: ARRAY
56864: EQUAL
56865: IFFALSE 56881
// begin result := i ;
56867: LD_ADDR_VAR 0 3
56871: PUSH
56872: LD_VAR 0 4
56876: ST_TO_ADDR
// exit ;
56877: POP
56878: POP
56879: GO 56885
// end ;
56881: GO 56846
56883: POP
56884: POP
// end ;
56885: LD_VAR 0 3
56889: RET
// export function PrepareVehicle ( chassis , engine , control , weapon , fuel ) ; begin
56890: LD_INT 0
56892: PPUSH
// vc_chassis := chassis ;
56893: LD_ADDR_OWVAR 37
56897: PUSH
56898: LD_VAR 0 1
56902: ST_TO_ADDR
// vc_engine := engine ;
56903: LD_ADDR_OWVAR 39
56907: PUSH
56908: LD_VAR 0 2
56912: ST_TO_ADDR
// vc_control := control ;
56913: LD_ADDR_OWVAR 38
56917: PUSH
56918: LD_VAR 0 3
56922: ST_TO_ADDR
// vc_weapon := weapon ;
56923: LD_ADDR_OWVAR 40
56927: PUSH
56928: LD_VAR 0 4
56932: ST_TO_ADDR
// vc_fuel_battery := fuel ;
56933: LD_ADDR_OWVAR 41
56937: PUSH
56938: LD_VAR 0 5
56942: ST_TO_ADDR
// end ;
56943: LD_VAR 0 6
56947: RET
// export function WantPlant ( unit ) ; var task ; begin
56948: LD_INT 0
56950: PPUSH
56951: PPUSH
// result := false ;
56952: LD_ADDR_VAR 0 2
56956: PUSH
56957: LD_INT 0
56959: ST_TO_ADDR
// task := GetTaskList ( unit ) ;
56960: LD_ADDR_VAR 0 3
56964: PUSH
56965: LD_VAR 0 1
56969: PPUSH
56970: CALL_OW 437
56974: ST_TO_ADDR
// if task then
56975: LD_VAR 0 3
56979: IFFALSE 57007
// if task [ 1 ] [ 1 ] = p then
56981: LD_VAR 0 3
56985: PUSH
56986: LD_INT 1
56988: ARRAY
56989: PUSH
56990: LD_INT 1
56992: ARRAY
56993: PUSH
56994: LD_STRING p
56996: EQUAL
56997: IFFALSE 57007
// result := true ;
56999: LD_ADDR_VAR 0 2
57003: PUSH
57004: LD_INT 1
57006: ST_TO_ADDR
// end ;
57007: LD_VAR 0 2
57011: RET
// export function ReplaceIn ( arr , pos , value ) ; var i , tmp , s_arr ; begin
57012: LD_INT 0
57014: PPUSH
57015: PPUSH
57016: PPUSH
57017: PPUSH
// if pos < 1 then
57018: LD_VAR 0 2
57022: PUSH
57023: LD_INT 1
57025: LESS
57026: IFFALSE 57030
// exit ;
57028: GO 57333
// if pos = 1 then
57030: LD_VAR 0 2
57034: PUSH
57035: LD_INT 1
57037: EQUAL
57038: IFFALSE 57071
// result := Replace ( arr , pos [ 1 ] , value ) else
57040: LD_ADDR_VAR 0 4
57044: PUSH
57045: LD_VAR 0 1
57049: PPUSH
57050: LD_VAR 0 2
57054: PUSH
57055: LD_INT 1
57057: ARRAY
57058: PPUSH
57059: LD_VAR 0 3
57063: PPUSH
57064: CALL_OW 1
57068: ST_TO_ADDR
57069: GO 57333
// begin tmp := arr ;
57071: LD_ADDR_VAR 0 6
57075: PUSH
57076: LD_VAR 0 1
57080: ST_TO_ADDR
// s_arr := [ tmp ] ;
57081: LD_ADDR_VAR 0 7
57085: PUSH
57086: LD_VAR 0 6
57090: PUSH
57091: EMPTY
57092: LIST
57093: ST_TO_ADDR
// for i = 1 to pos - 1 do
57094: LD_ADDR_VAR 0 5
57098: PUSH
57099: DOUBLE
57100: LD_INT 1
57102: DEC
57103: ST_TO_ADDR
57104: LD_VAR 0 2
57108: PUSH
57109: LD_INT 1
57111: MINUS
57112: PUSH
57113: FOR_TO
57114: IFFALSE 57159
// begin tmp := tmp [ pos [ i ] ] ;
57116: LD_ADDR_VAR 0 6
57120: PUSH
57121: LD_VAR 0 6
57125: PUSH
57126: LD_VAR 0 2
57130: PUSH
57131: LD_VAR 0 5
57135: ARRAY
57136: ARRAY
57137: ST_TO_ADDR
// s_arr := s_arr ^ [ tmp ] ;
57138: LD_ADDR_VAR 0 7
57142: PUSH
57143: LD_VAR 0 7
57147: PUSH
57148: LD_VAR 0 6
57152: PUSH
57153: EMPTY
57154: LIST
57155: ADD
57156: ST_TO_ADDR
// end ;
57157: GO 57113
57159: POP
57160: POP
// tmp := Replace ( tmp , pos [ pos ] , value ) ;
57161: LD_ADDR_VAR 0 6
57165: PUSH
57166: LD_VAR 0 6
57170: PPUSH
57171: LD_VAR 0 2
57175: PUSH
57176: LD_VAR 0 2
57180: ARRAY
57181: PPUSH
57182: LD_VAR 0 3
57186: PPUSH
57187: CALL_OW 1
57191: ST_TO_ADDR
// s_arr := Replace ( s_arr , s_arr , tmp ) ;
57192: LD_ADDR_VAR 0 7
57196: PUSH
57197: LD_VAR 0 7
57201: PPUSH
57202: LD_VAR 0 7
57206: PPUSH
57207: LD_VAR 0 6
57211: PPUSH
57212: CALL_OW 1
57216: ST_TO_ADDR
// for i = s_arr downto 2 do
57217: LD_ADDR_VAR 0 5
57221: PUSH
57222: DOUBLE
57223: LD_VAR 0 7
57227: INC
57228: ST_TO_ADDR
57229: LD_INT 2
57231: PUSH
57232: FOR_DOWNTO
57233: IFFALSE 57317
// begin tmp := Replace ( s_arr [ i - 1 ] , pos [ i - 1 ] , s_arr [ i ] ) ;
57235: LD_ADDR_VAR 0 6
57239: PUSH
57240: LD_VAR 0 7
57244: PUSH
57245: LD_VAR 0 5
57249: PUSH
57250: LD_INT 1
57252: MINUS
57253: ARRAY
57254: PPUSH
57255: LD_VAR 0 2
57259: PUSH
57260: LD_VAR 0 5
57264: PUSH
57265: LD_INT 1
57267: MINUS
57268: ARRAY
57269: PPUSH
57270: LD_VAR 0 7
57274: PUSH
57275: LD_VAR 0 5
57279: ARRAY
57280: PPUSH
57281: CALL_OW 1
57285: ST_TO_ADDR
// s_arr := Replace ( s_arr , i - 1 , tmp ) ;
57286: LD_ADDR_VAR 0 7
57290: PUSH
57291: LD_VAR 0 7
57295: PPUSH
57296: LD_VAR 0 5
57300: PUSH
57301: LD_INT 1
57303: MINUS
57304: PPUSH
57305: LD_VAR 0 6
57309: PPUSH
57310: CALL_OW 1
57314: ST_TO_ADDR
// end ;
57315: GO 57232
57317: POP
57318: POP
// result := s_arr [ 1 ] ;
57319: LD_ADDR_VAR 0 4
57323: PUSH
57324: LD_VAR 0 7
57328: PUSH
57329: LD_INT 1
57331: ARRAY
57332: ST_TO_ADDR
// end ; end ;
57333: LD_VAR 0 4
57337: RET
// export function ReplaceWith ( list , pos1 , pos2 ) ; var i ; begin
57338: LD_INT 0
57340: PPUSH
57341: PPUSH
// if not list then
57342: LD_VAR 0 1
57346: NOT
57347: IFFALSE 57351
// exit ;
57349: GO 57442
// i := list [ pos1 ] ;
57351: LD_ADDR_VAR 0 5
57355: PUSH
57356: LD_VAR 0 1
57360: PUSH
57361: LD_VAR 0 2
57365: ARRAY
57366: ST_TO_ADDR
// if not i then
57367: LD_VAR 0 5
57371: NOT
57372: IFFALSE 57376
// exit ;
57374: GO 57442
// list := Replace ( list , pos1 , list [ pos2 ] ) ;
57376: LD_ADDR_VAR 0 1
57380: PUSH
57381: LD_VAR 0 1
57385: PPUSH
57386: LD_VAR 0 2
57390: PPUSH
57391: LD_VAR 0 1
57395: PUSH
57396: LD_VAR 0 3
57400: ARRAY
57401: PPUSH
57402: CALL_OW 1
57406: ST_TO_ADDR
// list := Replace ( list , pos2 , i ) ;
57407: LD_ADDR_VAR 0 1
57411: PUSH
57412: LD_VAR 0 1
57416: PPUSH
57417: LD_VAR 0 3
57421: PPUSH
57422: LD_VAR 0 5
57426: PPUSH
57427: CALL_OW 1
57431: ST_TO_ADDR
// result := list ;
57432: LD_ADDR_VAR 0 4
57436: PUSH
57437: LD_VAR 0 1
57441: ST_TO_ADDR
// end ;
57442: LD_VAR 0 4
57446: RET
// export function SortByDistanceUnit ( unit , list , asc , mode ) ; begin
57447: LD_INT 0
57449: PPUSH
// result := SortByDistanceXY ( GetX ( unit ) , GetY ( unit ) , list , asc , mode ) ;
57450: LD_ADDR_VAR 0 5
57454: PUSH
57455: LD_VAR 0 1
57459: PPUSH
57460: CALL_OW 250
57464: PPUSH
57465: LD_VAR 0 1
57469: PPUSH
57470: CALL_OW 251
57474: PPUSH
57475: LD_VAR 0 2
57479: PPUSH
57480: LD_VAR 0 3
57484: PPUSH
57485: LD_VAR 0 4
57489: PPUSH
57490: CALL 57500 0 5
57494: ST_TO_ADDR
// end ;
57495: LD_VAR 0 5
57499: RET
// export function SortByDistanceXY ( x , y , list , asc , mode ) ; var i , j , tmp ; begin
57500: LD_INT 0
57502: PPUSH
57503: PPUSH
57504: PPUSH
57505: PPUSH
// if not list then
57506: LD_VAR 0 3
57510: NOT
57511: IFFALSE 57515
// exit ;
57513: GO 57903
// result := [ ] ;
57515: LD_ADDR_VAR 0 6
57519: PUSH
57520: EMPTY
57521: ST_TO_ADDR
// for i in list do
57522: LD_ADDR_VAR 0 7
57526: PUSH
57527: LD_VAR 0 3
57531: PUSH
57532: FOR_IN
57533: IFFALSE 57735
// begin tmp := GetDistUnitXY ( i , x , y ) ;
57535: LD_ADDR_VAR 0 9
57539: PUSH
57540: LD_VAR 0 7
57544: PPUSH
57545: LD_VAR 0 1
57549: PPUSH
57550: LD_VAR 0 2
57554: PPUSH
57555: CALL_OW 297
57559: ST_TO_ADDR
// if not result then
57560: LD_VAR 0 6
57564: NOT
57565: IFFALSE 57591
// result := [ [ i , tmp ] ] else
57567: LD_ADDR_VAR 0 6
57571: PUSH
57572: LD_VAR 0 7
57576: PUSH
57577: LD_VAR 0 9
57581: PUSH
57582: EMPTY
57583: LIST
57584: LIST
57585: PUSH
57586: EMPTY
57587: LIST
57588: ST_TO_ADDR
57589: GO 57733
// begin if result [ result ] [ 2 ] < tmp then
57591: LD_VAR 0 6
57595: PUSH
57596: LD_VAR 0 6
57600: ARRAY
57601: PUSH
57602: LD_INT 2
57604: ARRAY
57605: PUSH
57606: LD_VAR 0 9
57610: LESS
57611: IFFALSE 57653
// result := Insert ( result , result + 1 , [ i , tmp ] ) else
57613: LD_ADDR_VAR 0 6
57617: PUSH
57618: LD_VAR 0 6
57622: PPUSH
57623: LD_VAR 0 6
57627: PUSH
57628: LD_INT 1
57630: PLUS
57631: PPUSH
57632: LD_VAR 0 7
57636: PUSH
57637: LD_VAR 0 9
57641: PUSH
57642: EMPTY
57643: LIST
57644: LIST
57645: PPUSH
57646: CALL_OW 2
57650: ST_TO_ADDR
57651: GO 57733
// for j = 1 to result do
57653: LD_ADDR_VAR 0 8
57657: PUSH
57658: DOUBLE
57659: LD_INT 1
57661: DEC
57662: ST_TO_ADDR
57663: LD_VAR 0 6
57667: PUSH
57668: FOR_TO
57669: IFFALSE 57731
// begin if tmp < result [ j ] [ 2 ] then
57671: LD_VAR 0 9
57675: PUSH
57676: LD_VAR 0 6
57680: PUSH
57681: LD_VAR 0 8
57685: ARRAY
57686: PUSH
57687: LD_INT 2
57689: ARRAY
57690: LESS
57691: IFFALSE 57729
// begin result := Insert ( result , j , [ i , tmp ] ) ;
57693: LD_ADDR_VAR 0 6
57697: PUSH
57698: LD_VAR 0 6
57702: PPUSH
57703: LD_VAR 0 8
57707: PPUSH
57708: LD_VAR 0 7
57712: PUSH
57713: LD_VAR 0 9
57717: PUSH
57718: EMPTY
57719: LIST
57720: LIST
57721: PPUSH
57722: CALL_OW 2
57726: ST_TO_ADDR
// break ;
57727: GO 57731
// end ; end ;
57729: GO 57668
57731: POP
57732: POP
// end ; end ;
57733: GO 57532
57735: POP
57736: POP
// if result and not asc then
57737: LD_VAR 0 6
57741: PUSH
57742: LD_VAR 0 4
57746: NOT
57747: AND
57748: IFFALSE 57823
// begin tmp := result ;
57750: LD_ADDR_VAR 0 9
57754: PUSH
57755: LD_VAR 0 6
57759: ST_TO_ADDR
// for i = tmp downto 1 do
57760: LD_ADDR_VAR 0 7
57764: PUSH
57765: DOUBLE
57766: LD_VAR 0 9
57770: INC
57771: ST_TO_ADDR
57772: LD_INT 1
57774: PUSH
57775: FOR_DOWNTO
57776: IFFALSE 57821
// result := Replace ( result , tmp - i + 1 , tmp [ i ] ) ;
57778: LD_ADDR_VAR 0 6
57782: PUSH
57783: LD_VAR 0 6
57787: PPUSH
57788: LD_VAR 0 9
57792: PUSH
57793: LD_VAR 0 7
57797: MINUS
57798: PUSH
57799: LD_INT 1
57801: PLUS
57802: PPUSH
57803: LD_VAR 0 9
57807: PUSH
57808: LD_VAR 0 7
57812: ARRAY
57813: PPUSH
57814: CALL_OW 1
57818: ST_TO_ADDR
57819: GO 57775
57821: POP
57822: POP
// end ; tmp := [ ] ;
57823: LD_ADDR_VAR 0 9
57827: PUSH
57828: EMPTY
57829: ST_TO_ADDR
// if mode then
57830: LD_VAR 0 5
57834: IFFALSE 57903
// begin for i = 1 to result do
57836: LD_ADDR_VAR 0 7
57840: PUSH
57841: DOUBLE
57842: LD_INT 1
57844: DEC
57845: ST_TO_ADDR
57846: LD_VAR 0 6
57850: PUSH
57851: FOR_TO
57852: IFFALSE 57891
// tmp := Replace ( tmp , i , result [ i ] [ 1 ] ) ;
57854: LD_ADDR_VAR 0 9
57858: PUSH
57859: LD_VAR 0 9
57863: PPUSH
57864: LD_VAR 0 7
57868: PPUSH
57869: LD_VAR 0 6
57873: PUSH
57874: LD_VAR 0 7
57878: ARRAY
57879: PUSH
57880: LD_INT 1
57882: ARRAY
57883: PPUSH
57884: CALL_OW 1
57888: ST_TO_ADDR
57889: GO 57851
57891: POP
57892: POP
// result := tmp ;
57893: LD_ADDR_VAR 0 6
57897: PUSH
57898: LD_VAR 0 9
57902: ST_TO_ADDR
// end ; end ;
57903: LD_VAR 0 6
57907: RET
// export function DangerAtRangeXY ( side , x , y , range ) ; var i , j , tmp , points , bpoints ; begin
57908: LD_INT 0
57910: PPUSH
57911: PPUSH
57912: PPUSH
57913: PPUSH
57914: PPUSH
57915: PPUSH
// result := [ 0 , 0 , 0 , [ ] ] ;
57916: LD_ADDR_VAR 0 5
57920: PUSH
57921: LD_INT 0
57923: PUSH
57924: LD_INT 0
57926: PUSH
57927: LD_INT 0
57929: PUSH
57930: EMPTY
57931: PUSH
57932: EMPTY
57933: LIST
57934: LIST
57935: LIST
57936: LIST
57937: ST_TO_ADDR
// if not x or not y then
57938: LD_VAR 0 2
57942: NOT
57943: PUSH
57944: LD_VAR 0 3
57948: NOT
57949: OR
57950: IFFALSE 57954
// exit ;
57952: GO 59606
// if not range then
57954: LD_VAR 0 4
57958: NOT
57959: IFFALSE 57969
// range := 10 ;
57961: LD_ADDR_VAR 0 4
57965: PUSH
57966: LD_INT 10
57968: ST_TO_ADDR
// tmp := FilterAllUnits ( [ [ f_enemy , side ] , [ f_distxy , x , y , range ] , [ f_not , [ f_type , unit_building ] ] ] ) ;
57969: LD_ADDR_VAR 0 8
57973: PUSH
57974: LD_INT 81
57976: PUSH
57977: LD_VAR 0 1
57981: PUSH
57982: EMPTY
57983: LIST
57984: LIST
57985: PUSH
57986: LD_INT 92
57988: PUSH
57989: LD_VAR 0 2
57993: PUSH
57994: LD_VAR 0 3
57998: PUSH
57999: LD_VAR 0 4
58003: PUSH
58004: EMPTY
58005: LIST
58006: LIST
58007: LIST
58008: LIST
58009: PUSH
58010: LD_INT 3
58012: PUSH
58013: LD_INT 21
58015: PUSH
58016: LD_INT 3
58018: PUSH
58019: EMPTY
58020: LIST
58021: LIST
58022: PUSH
58023: EMPTY
58024: LIST
58025: LIST
58026: PUSH
58027: EMPTY
58028: LIST
58029: LIST
58030: LIST
58031: PPUSH
58032: CALL_OW 69
58036: ST_TO_ADDR
// if not tmp then
58037: LD_VAR 0 8
58041: NOT
58042: IFFALSE 58046
// exit ;
58044: GO 59606
// for i in tmp do
58046: LD_ADDR_VAR 0 6
58050: PUSH
58051: LD_VAR 0 8
58055: PUSH
58056: FOR_IN
58057: IFFALSE 59581
// begin points := [ 0 , 0 , 0 ] ;
58059: LD_ADDR_VAR 0 9
58063: PUSH
58064: LD_INT 0
58066: PUSH
58067: LD_INT 0
58069: PUSH
58070: LD_INT 0
58072: PUSH
58073: EMPTY
58074: LIST
58075: LIST
58076: LIST
58077: ST_TO_ADDR
// bpoints := 1 ;
58078: LD_ADDR_VAR 0 10
58082: PUSH
58083: LD_INT 1
58085: ST_TO_ADDR
// case GetType ( i ) of unit_human :
58086: LD_VAR 0 6
58090: PPUSH
58091: CALL_OW 247
58095: PUSH
58096: LD_INT 1
58098: DOUBLE
58099: EQUAL
58100: IFTRUE 58104
58102: GO 58682
58104: POP
// begin if GetClass ( i ) = 1 then
58105: LD_VAR 0 6
58109: PPUSH
58110: CALL_OW 257
58114: PUSH
58115: LD_INT 1
58117: EQUAL
58118: IFFALSE 58139
// points := [ 10 , 5 , 3 ] ;
58120: LD_ADDR_VAR 0 9
58124: PUSH
58125: LD_INT 10
58127: PUSH
58128: LD_INT 5
58130: PUSH
58131: LD_INT 3
58133: PUSH
58134: EMPTY
58135: LIST
58136: LIST
58137: LIST
58138: ST_TO_ADDR
// if GetClass ( i ) in [ 2 , 3 , 4 ] then
58139: LD_VAR 0 6
58143: PPUSH
58144: CALL_OW 257
58148: PUSH
58149: LD_INT 2
58151: PUSH
58152: LD_INT 3
58154: PUSH
58155: LD_INT 4
58157: PUSH
58158: EMPTY
58159: LIST
58160: LIST
58161: LIST
58162: IN
58163: IFFALSE 58184
// points := [ 3 , 2 , 1 ] ;
58165: LD_ADDR_VAR 0 9
58169: PUSH
58170: LD_INT 3
58172: PUSH
58173: LD_INT 2
58175: PUSH
58176: LD_INT 1
58178: PUSH
58179: EMPTY
58180: LIST
58181: LIST
58182: LIST
58183: ST_TO_ADDR
// if GetClass ( i ) = 5 then
58184: LD_VAR 0 6
58188: PPUSH
58189: CALL_OW 257
58193: PUSH
58194: LD_INT 5
58196: EQUAL
58197: IFFALSE 58218
// points := [ 130 , 5 , 2 ] ;
58199: LD_ADDR_VAR 0 9
58203: PUSH
58204: LD_INT 130
58206: PUSH
58207: LD_INT 5
58209: PUSH
58210: LD_INT 2
58212: PUSH
58213: EMPTY
58214: LIST
58215: LIST
58216: LIST
58217: ST_TO_ADDR
// if GetClass ( i ) = 8 then
58218: LD_VAR 0 6
58222: PPUSH
58223: CALL_OW 257
58227: PUSH
58228: LD_INT 8
58230: EQUAL
58231: IFFALSE 58252
// points := [ 35 , 35 , 30 ] ;
58233: LD_ADDR_VAR 0 9
58237: PUSH
58238: LD_INT 35
58240: PUSH
58241: LD_INT 35
58243: PUSH
58244: LD_INT 30
58246: PUSH
58247: EMPTY
58248: LIST
58249: LIST
58250: LIST
58251: ST_TO_ADDR
// if GetClass ( i ) = 9 then
58252: LD_VAR 0 6
58256: PPUSH
58257: CALL_OW 257
58261: PUSH
58262: LD_INT 9
58264: EQUAL
58265: IFFALSE 58286
// points := [ 20 , 55 , 40 ] ;
58267: LD_ADDR_VAR 0 9
58271: PUSH
58272: LD_INT 20
58274: PUSH
58275: LD_INT 55
58277: PUSH
58278: LD_INT 40
58280: PUSH
58281: EMPTY
58282: LIST
58283: LIST
58284: LIST
58285: ST_TO_ADDR
// if GetClass ( i ) in [ 12 , 16 ] then
58286: LD_VAR 0 6
58290: PPUSH
58291: CALL_OW 257
58295: PUSH
58296: LD_INT 12
58298: PUSH
58299: LD_INT 16
58301: PUSH
58302: EMPTY
58303: LIST
58304: LIST
58305: IN
58306: IFFALSE 58327
// points := [ 5 , 3 , 2 ] ;
58308: LD_ADDR_VAR 0 9
58312: PUSH
58313: LD_INT 5
58315: PUSH
58316: LD_INT 3
58318: PUSH
58319: LD_INT 2
58321: PUSH
58322: EMPTY
58323: LIST
58324: LIST
58325: LIST
58326: ST_TO_ADDR
// if GetClass ( i ) = 17 then
58327: LD_VAR 0 6
58331: PPUSH
58332: CALL_OW 257
58336: PUSH
58337: LD_INT 17
58339: EQUAL
58340: IFFALSE 58361
// points := [ 100 , 50 , 75 ] ;
58342: LD_ADDR_VAR 0 9
58346: PUSH
58347: LD_INT 100
58349: PUSH
58350: LD_INT 50
58352: PUSH
58353: LD_INT 75
58355: PUSH
58356: EMPTY
58357: LIST
58358: LIST
58359: LIST
58360: ST_TO_ADDR
// if GetClass ( i ) = 15 then
58361: LD_VAR 0 6
58365: PPUSH
58366: CALL_OW 257
58370: PUSH
58371: LD_INT 15
58373: EQUAL
58374: IFFALSE 58395
// points := [ 10 , 5 , 3 ] ;
58376: LD_ADDR_VAR 0 9
58380: PUSH
58381: LD_INT 10
58383: PUSH
58384: LD_INT 5
58386: PUSH
58387: LD_INT 3
58389: PUSH
58390: EMPTY
58391: LIST
58392: LIST
58393: LIST
58394: ST_TO_ADDR
// if GetClass ( i ) = 14 then
58395: LD_VAR 0 6
58399: PPUSH
58400: CALL_OW 257
58404: PUSH
58405: LD_INT 14
58407: EQUAL
58408: IFFALSE 58429
// points := [ 10 , 0 , 0 ] ;
58410: LD_ADDR_VAR 0 9
58414: PUSH
58415: LD_INT 10
58417: PUSH
58418: LD_INT 0
58420: PUSH
58421: LD_INT 0
58423: PUSH
58424: EMPTY
58425: LIST
58426: LIST
58427: LIST
58428: ST_TO_ADDR
// if GetClass ( i ) = 11 then
58429: LD_VAR 0 6
58433: PPUSH
58434: CALL_OW 257
58438: PUSH
58439: LD_INT 11
58441: EQUAL
58442: IFFALSE 58463
// points := [ 30 , 10 , 5 ] ;
58444: LD_ADDR_VAR 0 9
58448: PUSH
58449: LD_INT 30
58451: PUSH
58452: LD_INT 10
58454: PUSH
58455: LD_INT 5
58457: PUSH
58458: EMPTY
58459: LIST
58460: LIST
58461: LIST
58462: ST_TO_ADDR
// if GetTech ( side , tech_stimdrugs ) = state_researched then
58463: LD_VAR 0 1
58467: PPUSH
58468: LD_INT 5
58470: PPUSH
58471: CALL_OW 321
58475: PUSH
58476: LD_INT 2
58478: EQUAL
58479: IFFALSE 58496
// bpoints := bpoints * 1.8 ;
58481: LD_ADDR_VAR 0 10
58485: PUSH
58486: LD_VAR 0 10
58490: PUSH
58491: LD_REAL  1.80000000000000E+0000
58494: MUL
58495: ST_TO_ADDR
// if GetClass ( i ) in [ 1 , 2 , 3 , 4 ] and GetTech ( side , tech_weap1 ) = state_researched then
58496: LD_VAR 0 6
58500: PPUSH
58501: CALL_OW 257
58505: PUSH
58506: LD_INT 1
58508: PUSH
58509: LD_INT 2
58511: PUSH
58512: LD_INT 3
58514: PUSH
58515: LD_INT 4
58517: PUSH
58518: EMPTY
58519: LIST
58520: LIST
58521: LIST
58522: LIST
58523: IN
58524: PUSH
58525: LD_VAR 0 1
58529: PPUSH
58530: LD_INT 51
58532: PPUSH
58533: CALL_OW 321
58537: PUSH
58538: LD_INT 2
58540: EQUAL
58541: AND
58542: IFFALSE 58559
// bpoints := bpoints * 1.2 ;
58544: LD_ADDR_VAR 0 10
58548: PUSH
58549: LD_VAR 0 10
58553: PUSH
58554: LD_REAL  1.20000000000000E+0000
58557: MUL
58558: ST_TO_ADDR
// if GetClass ( i ) in [ 5 , 7 , 9 ] and GetTech ( side , tech_weap2 ) = state_researched then
58559: LD_VAR 0 6
58563: PPUSH
58564: CALL_OW 257
58568: PUSH
58569: LD_INT 5
58571: PUSH
58572: LD_INT 7
58574: PUSH
58575: LD_INT 9
58577: PUSH
58578: EMPTY
58579: LIST
58580: LIST
58581: LIST
58582: IN
58583: PUSH
58584: LD_VAR 0 1
58588: PPUSH
58589: LD_INT 52
58591: PPUSH
58592: CALL_OW 321
58596: PUSH
58597: LD_INT 2
58599: EQUAL
58600: AND
58601: IFFALSE 58618
// bpoints := bpoints * 1.5 ;
58603: LD_ADDR_VAR 0 10
58607: PUSH
58608: LD_VAR 0 10
58612: PUSH
58613: LD_REAL  1.50000000000000E+0000
58616: MUL
58617: ST_TO_ADDR
// if GetTech ( side , tech_bio1 ) = state_researched then
58618: LD_VAR 0 1
58622: PPUSH
58623: LD_INT 66
58625: PPUSH
58626: CALL_OW 321
58630: PUSH
58631: LD_INT 2
58633: EQUAL
58634: IFFALSE 58651
// bpoints := bpoints * 1.1 ;
58636: LD_ADDR_VAR 0 10
58640: PUSH
58641: LD_VAR 0 10
58645: PUSH
58646: LD_REAL  1.10000000000000E+0000
58649: MUL
58650: ST_TO_ADDR
// bpoints := bpoints * ( GetSkill ( i , 1 ) * 1.15 ) ;
58651: LD_ADDR_VAR 0 10
58655: PUSH
58656: LD_VAR 0 10
58660: PUSH
58661: LD_VAR 0 6
58665: PPUSH
58666: LD_INT 1
58668: PPUSH
58669: CALL_OW 259
58673: PUSH
58674: LD_REAL  1.15000000000000E+0000
58677: MUL
58678: MUL
58679: ST_TO_ADDR
// end ; unit_vehicle :
58680: GO 59510
58682: LD_INT 2
58684: DOUBLE
58685: EQUAL
58686: IFTRUE 58690
58688: GO 59498
58690: POP
// begin if GetWeapon ( i ) in [ us_machine_gun , ru_heavy_machine_gun , ar_double_machine_gun ] then
58691: LD_VAR 0 6
58695: PPUSH
58696: CALL_OW 264
58700: PUSH
58701: LD_INT 2
58703: PUSH
58704: LD_INT 42
58706: PUSH
58707: LD_INT 24
58709: PUSH
58710: EMPTY
58711: LIST
58712: LIST
58713: LIST
58714: IN
58715: IFFALSE 58736
// points := [ 25 , 5 , 3 ] ;
58717: LD_ADDR_VAR 0 9
58721: PUSH
58722: LD_INT 25
58724: PUSH
58725: LD_INT 5
58727: PUSH
58728: LD_INT 3
58730: PUSH
58731: EMPTY
58732: LIST
58733: LIST
58734: LIST
58735: ST_TO_ADDR
// if GetWeapon ( i ) in [ us_gatling_gun , ru_gatling_gun , ar_gatling_gun ] then
58736: LD_VAR 0 6
58740: PPUSH
58741: CALL_OW 264
58745: PUSH
58746: LD_INT 4
58748: PUSH
58749: LD_INT 43
58751: PUSH
58752: LD_INT 25
58754: PUSH
58755: EMPTY
58756: LIST
58757: LIST
58758: LIST
58759: IN
58760: IFFALSE 58781
// points := [ 40 , 15 , 5 ] ;
58762: LD_ADDR_VAR 0 9
58766: PUSH
58767: LD_INT 40
58769: PUSH
58770: LD_INT 15
58772: PUSH
58773: LD_INT 5
58775: PUSH
58776: EMPTY
58777: LIST
58778: LIST
58779: LIST
58780: ST_TO_ADDR
// if GetWeapon ( i ) in [ us_light_gun , ar_light_gun ] then
58781: LD_VAR 0 6
58785: PPUSH
58786: CALL_OW 264
58790: PUSH
58791: LD_INT 3
58793: PUSH
58794: LD_INT 23
58796: PUSH
58797: EMPTY
58798: LIST
58799: LIST
58800: IN
58801: IFFALSE 58822
// points := [ 7 , 25 , 8 ] ;
58803: LD_ADDR_VAR 0 9
58807: PUSH
58808: LD_INT 7
58810: PUSH
58811: LD_INT 25
58813: PUSH
58814: LD_INT 8
58816: PUSH
58817: EMPTY
58818: LIST
58819: LIST
58820: LIST
58821: ST_TO_ADDR
// if GetWeapon ( i ) in [ us_double_gun , ar_gun , ru_gun ] then
58822: LD_VAR 0 6
58826: PPUSH
58827: CALL_OW 264
58831: PUSH
58832: LD_INT 5
58834: PUSH
58835: LD_INT 27
58837: PUSH
58838: LD_INT 44
58840: PUSH
58841: EMPTY
58842: LIST
58843: LIST
58844: LIST
58845: IN
58846: IFFALSE 58867
// points := [ 14 , 50 , 16 ] ;
58848: LD_ADDR_VAR 0 9
58852: PUSH
58853: LD_INT 14
58855: PUSH
58856: LD_INT 50
58858: PUSH
58859: LD_INT 16
58861: PUSH
58862: EMPTY
58863: LIST
58864: LIST
58865: LIST
58866: ST_TO_ADDR
// if GetWeapon ( i ) in [ us_heavy_gun , ru_heavy_gun ] then
58867: LD_VAR 0 6
58871: PPUSH
58872: CALL_OW 264
58876: PUSH
58877: LD_INT 6
58879: PUSH
58880: LD_INT 46
58882: PUSH
58883: EMPTY
58884: LIST
58885: LIST
58886: IN
58887: IFFALSE 58908
// points := [ 32 , 120 , 70 ] ;
58889: LD_ADDR_VAR 0 9
58893: PUSH
58894: LD_INT 32
58896: PUSH
58897: LD_INT 120
58899: PUSH
58900: LD_INT 70
58902: PUSH
58903: EMPTY
58904: LIST
58905: LIST
58906: LIST
58907: ST_TO_ADDR
// if GetWeapon ( i ) in [ us_rocket_launcher , ar_rocket_launcher , ru_rocket_launcher , ar_mortar ] then
58908: LD_VAR 0 6
58912: PPUSH
58913: CALL_OW 264
58917: PUSH
58918: LD_INT 7
58920: PUSH
58921: LD_INT 28
58923: PUSH
58924: LD_INT 45
58926: PUSH
58927: LD_EXP 79
58931: PUSH
58932: EMPTY
58933: LIST
58934: LIST
58935: LIST
58936: LIST
58937: IN
58938: IFFALSE 58959
// points := [ 35 , 20 , 45 ] ;
58940: LD_ADDR_VAR 0 9
58944: PUSH
58945: LD_INT 35
58947: PUSH
58948: LD_INT 20
58950: PUSH
58951: LD_INT 45
58953: PUSH
58954: EMPTY
58955: LIST
58956: LIST
58957: LIST
58958: ST_TO_ADDR
// if GetWeapon ( i ) in [ ru_rocket ] then
58959: LD_VAR 0 6
58963: PPUSH
58964: CALL_OW 264
58968: PUSH
58969: LD_INT 47
58971: PUSH
58972: EMPTY
58973: LIST
58974: IN
58975: IFFALSE 58996
// points := [ 67 , 45 , 75 ] ;
58977: LD_ADDR_VAR 0 9
58981: PUSH
58982: LD_INT 67
58984: PUSH
58985: LD_INT 45
58987: PUSH
58988: LD_INT 75
58990: PUSH
58991: EMPTY
58992: LIST
58993: LIST
58994: LIST
58995: ST_TO_ADDR
// if GetWeapon ( i ) in [ ar_flame_thrower ] then
58996: LD_VAR 0 6
59000: PPUSH
59001: CALL_OW 264
59005: PUSH
59006: LD_INT 26
59008: PUSH
59009: EMPTY
59010: LIST
59011: IN
59012: IFFALSE 59033
// points := [ 120 , 30 , 80 ] ;
59014: LD_ADDR_VAR 0 9
59018: PUSH
59019: LD_INT 120
59021: PUSH
59022: LD_INT 30
59024: PUSH
59025: LD_INT 80
59027: PUSH
59028: EMPTY
59029: LIST
59030: LIST
59031: LIST
59032: ST_TO_ADDR
// if GetWeapon ( i ) in [ ar_multimissile_ballista ] then
59033: LD_VAR 0 6
59037: PPUSH
59038: CALL_OW 264
59042: PUSH
59043: LD_INT 22
59045: PUSH
59046: EMPTY
59047: LIST
59048: IN
59049: IFFALSE 59070
// points := [ 40 , 1 , 1 ] ;
59051: LD_ADDR_VAR 0 9
59055: PUSH
59056: LD_INT 40
59058: PUSH
59059: LD_INT 1
59061: PUSH
59062: LD_INT 1
59064: PUSH
59065: EMPTY
59066: LIST
59067: LIST
59068: LIST
59069: ST_TO_ADDR
// if GetWeapon ( i ) in [ ar_selfpropelled_bomb ] then
59070: LD_VAR 0 6
59074: PPUSH
59075: CALL_OW 264
59079: PUSH
59080: LD_INT 29
59082: PUSH
59083: EMPTY
59084: LIST
59085: IN
59086: IFFALSE 59107
// points := [ 70 , 200 , 400 ] ;
59088: LD_ADDR_VAR 0 9
59092: PUSH
59093: LD_INT 70
59095: PUSH
59096: LD_INT 200
59098: PUSH
59099: LD_INT 400
59101: PUSH
59102: EMPTY
59103: LIST
59104: LIST
59105: LIST
59106: ST_TO_ADDR
// if GetWeapon ( i ) in [ us_bulldozer , ru_bulldozer ] then
59107: LD_VAR 0 6
59111: PPUSH
59112: CALL_OW 264
59116: PUSH
59117: LD_INT 14
59119: PUSH
59120: LD_INT 53
59122: PUSH
59123: EMPTY
59124: LIST
59125: LIST
59126: IN
59127: IFFALSE 59148
// points := [ 40 , 10 , 20 ] ;
59129: LD_ADDR_VAR 0 9
59133: PUSH
59134: LD_INT 40
59136: PUSH
59137: LD_INT 10
59139: PUSH
59140: LD_INT 20
59142: PUSH
59143: EMPTY
59144: LIST
59145: LIST
59146: LIST
59147: ST_TO_ADDR
// if GetWeapon ( i ) in [ us_laser ] then
59148: LD_VAR 0 6
59152: PPUSH
59153: CALL_OW 264
59157: PUSH
59158: LD_INT 9
59160: PUSH
59161: EMPTY
59162: LIST
59163: IN
59164: IFFALSE 59185
// points := [ 5 , 70 , 20 ] ;
59166: LD_ADDR_VAR 0 9
59170: PUSH
59171: LD_INT 5
59173: PUSH
59174: LD_INT 70
59176: PUSH
59177: LD_INT 20
59179: PUSH
59180: EMPTY
59181: LIST
59182: LIST
59183: LIST
59184: ST_TO_ADDR
// if GetWeapon ( i ) in [ us_double_laser ] then
59185: LD_VAR 0 6
59189: PPUSH
59190: CALL_OW 264
59194: PUSH
59195: LD_INT 10
59197: PUSH
59198: EMPTY
59199: LIST
59200: IN
59201: IFFALSE 59222
// points := [ 35 , 110 , 70 ] ;
59203: LD_ADDR_VAR 0 9
59207: PUSH
59208: LD_INT 35
59210: PUSH
59211: LD_INT 110
59213: PUSH
59214: LD_INT 70
59216: PUSH
59217: EMPTY
59218: LIST
59219: LIST
59220: LIST
59221: ST_TO_ADDR
// if GetChassis ( i ) = 25 then
59222: LD_VAR 0 6
59226: PPUSH
59227: CALL_OW 265
59231: PUSH
59232: LD_INT 25
59234: EQUAL
59235: IFFALSE 59256
// points := [ 80 , 65 , 100 ] ;
59237: LD_ADDR_VAR 0 9
59241: PUSH
59242: LD_INT 80
59244: PUSH
59245: LD_INT 65
59247: PUSH
59248: LD_INT 100
59250: PUSH
59251: EMPTY
59252: LIST
59253: LIST
59254: LIST
59255: ST_TO_ADDR
// if GetControl ( i ) = control_manual then
59256: LD_VAR 0 6
59260: PPUSH
59261: CALL_OW 263
59265: PUSH
59266: LD_INT 1
59268: EQUAL
59269: IFFALSE 59304
// bpoints := bpoints * ( GetSkill ( IsDrivenBy ( i ) , 3 ) * 4 ) ;
59271: LD_ADDR_VAR 0 10
59275: PUSH
59276: LD_VAR 0 10
59280: PUSH
59281: LD_VAR 0 6
59285: PPUSH
59286: CALL_OW 311
59290: PPUSH
59291: LD_INT 3
59293: PPUSH
59294: CALL_OW 259
59298: PUSH
59299: LD_INT 4
59301: MUL
59302: MUL
59303: ST_TO_ADDR
// if GetControl ( i ) = control_remote then
59304: LD_VAR 0 6
59308: PPUSH
59309: CALL_OW 263
59313: PUSH
59314: LD_INT 2
59316: EQUAL
59317: IFFALSE 59368
// begin j := IsControledBy ( i ) ;
59319: LD_ADDR_VAR 0 7
59323: PUSH
59324: LD_VAR 0 6
59328: PPUSH
59329: CALL_OW 312
59333: ST_TO_ADDR
// if j then
59334: LD_VAR 0 7
59338: IFFALSE 59368
// bpoints := bpoints * ( GetSkill ( j , 3 ) * 3 ) ;
59340: LD_ADDR_VAR 0 10
59344: PUSH
59345: LD_VAR 0 10
59349: PUSH
59350: LD_VAR 0 7
59354: PPUSH
59355: LD_INT 3
59357: PPUSH
59358: CALL_OW 259
59362: PUSH
59363: LD_INT 3
59365: MUL
59366: MUL
59367: ST_TO_ADDR
// end ; if GetWeapon ( i ) in [ us_double_gun , us_heavy_gun , ru_heavy_gun , ru_gun , ru_rocket , ru_rocket_launcher , ar_rocket_launcher , us_rocket_launcher , ar_gun , ar_selfpropelled_bomb ] and GetTech ( side , tech_weap2 ) = state_researched then
59368: LD_VAR 0 6
59372: PPUSH
59373: CALL_OW 264
59377: PUSH
59378: LD_INT 5
59380: PUSH
59381: LD_INT 6
59383: PUSH
59384: LD_INT 46
59386: PUSH
59387: LD_INT 44
59389: PUSH
59390: LD_INT 47
59392: PUSH
59393: LD_INT 45
59395: PUSH
59396: LD_INT 28
59398: PUSH
59399: LD_INT 7
59401: PUSH
59402: LD_INT 27
59404: PUSH
59405: LD_INT 29
59407: PUSH
59408: EMPTY
59409: LIST
59410: LIST
59411: LIST
59412: LIST
59413: LIST
59414: LIST
59415: LIST
59416: LIST
59417: LIST
59418: LIST
59419: IN
59420: PUSH
59421: LD_VAR 0 1
59425: PPUSH
59426: LD_INT 52
59428: PPUSH
59429: CALL_OW 321
59433: PUSH
59434: LD_INT 2
59436: EQUAL
59437: AND
59438: IFFALSE 59455
// bpoints := bpoints * 1.2 ;
59440: LD_ADDR_VAR 0 10
59444: PUSH
59445: LD_VAR 0 10
59449: PUSH
59450: LD_REAL  1.20000000000000E+0000
59453: MUL
59454: ST_TO_ADDR
// if GetWeapon ( i ) in [ us_heavy_gun , ru_heavy_gun , ru_rocket ] then
59455: LD_VAR 0 6
59459: PPUSH
59460: CALL_OW 264
59464: PUSH
59465: LD_INT 6
59467: PUSH
59468: LD_INT 46
59470: PUSH
59471: LD_INT 47
59473: PUSH
59474: EMPTY
59475: LIST
59476: LIST
59477: LIST
59478: IN
59479: IFFALSE 59496
// bpoints := bpoints * 1.2 ;
59481: LD_ADDR_VAR 0 10
59485: PUSH
59486: LD_VAR 0 10
59490: PUSH
59491: LD_REAL  1.20000000000000E+0000
59494: MUL
59495: ST_TO_ADDR
// end ; unit_building :
59496: GO 59510
59498: LD_INT 3
59500: DOUBLE
59501: EQUAL
59502: IFTRUE 59506
59504: GO 59509
59506: POP
// ; end ;
59507: GO 59510
59509: POP
// for j = 1 to 3 do
59510: LD_ADDR_VAR 0 7
59514: PUSH
59515: DOUBLE
59516: LD_INT 1
59518: DEC
59519: ST_TO_ADDR
59520: LD_INT 3
59522: PUSH
59523: FOR_TO
59524: IFFALSE 59577
// result := Replace ( result , j , result [ j ] + ( points [ j ] * bpoints ) ) ;
59526: LD_ADDR_VAR 0 5
59530: PUSH
59531: LD_VAR 0 5
59535: PPUSH
59536: LD_VAR 0 7
59540: PPUSH
59541: LD_VAR 0 5
59545: PUSH
59546: LD_VAR 0 7
59550: ARRAY
59551: PUSH
59552: LD_VAR 0 9
59556: PUSH
59557: LD_VAR 0 7
59561: ARRAY
59562: PUSH
59563: LD_VAR 0 10
59567: MUL
59568: PLUS
59569: PPUSH
59570: CALL_OW 1
59574: ST_TO_ADDR
59575: GO 59523
59577: POP
59578: POP
// end ;
59579: GO 58056
59581: POP
59582: POP
// result := Replace ( result , 4 , tmp ) ;
59583: LD_ADDR_VAR 0 5
59587: PUSH
59588: LD_VAR 0 5
59592: PPUSH
59593: LD_INT 4
59595: PPUSH
59596: LD_VAR 0 8
59600: PPUSH
59601: CALL_OW 1
59605: ST_TO_ADDR
// end ;
59606: LD_VAR 0 5
59610: RET
// export function DangerAtRange ( unit , range ) ; begin
59611: LD_INT 0
59613: PPUSH
// result := DangerAtRangeXY ( GetSide ( unit ) , GetX ( unit ) , GetY ( unit ) , range ) ;
59614: LD_ADDR_VAR 0 3
59618: PUSH
59619: LD_VAR 0 1
59623: PPUSH
59624: CALL_OW 255
59628: PPUSH
59629: LD_VAR 0 1
59633: PPUSH
59634: CALL_OW 250
59638: PPUSH
59639: LD_VAR 0 1
59643: PPUSH
59644: CALL_OW 251
59648: PPUSH
59649: LD_VAR 0 2
59653: PPUSH
59654: CALL 57908 0 4
59658: ST_TO_ADDR
// end ;
59659: LD_VAR 0 3
59663: RET
// export function DangerInArea ( side , area ) ; begin
59664: LD_INT 0
59666: PPUSH
// result := FilterUnitsInArea ( area , [ f_enemy , side ] ) ;
59667: LD_ADDR_VAR 0 3
59671: PUSH
59672: LD_VAR 0 2
59676: PPUSH
59677: LD_INT 81
59679: PUSH
59680: LD_VAR 0 1
59684: PUSH
59685: EMPTY
59686: LIST
59687: LIST
59688: PPUSH
59689: CALL_OW 70
59693: ST_TO_ADDR
// end ;
59694: LD_VAR 0 3
59698: RET
// export function IsExtension ( b ) ; begin
59699: LD_INT 0
59701: PPUSH
// result := b in [ b_ext_stitch , b_ext_radar , b_ext_radio , b_ext_gun , b_ext_computer , b_ext_siberium , b_ext_noncombat , b_ext_track , b_ext_laser , b_ext_rocket ] ;
59702: LD_ADDR_VAR 0 2
59706: PUSH
59707: LD_VAR 0 1
59711: PUSH
59712: LD_INT 23
59714: PUSH
59715: LD_INT 20
59717: PUSH
59718: LD_INT 22
59720: PUSH
59721: LD_INT 17
59723: PUSH
59724: LD_INT 24
59726: PUSH
59727: LD_INT 21
59729: PUSH
59730: LD_INT 19
59732: PUSH
59733: LD_INT 16
59735: PUSH
59736: LD_INT 25
59738: PUSH
59739: LD_INT 18
59741: PUSH
59742: EMPTY
59743: LIST
59744: LIST
59745: LIST
59746: LIST
59747: LIST
59748: LIST
59749: LIST
59750: LIST
59751: LIST
59752: LIST
59753: IN
59754: ST_TO_ADDR
// end ;
59755: LD_VAR 0 2
59759: RET
// export function GetBaseBuildings ( base , area , checkLink ) ; var tmp , i ; begin
59760: LD_INT 0
59762: PPUSH
59763: PPUSH
59764: PPUSH
// result := [ ] ;
59765: LD_ADDR_VAR 0 4
59769: PUSH
59770: EMPTY
59771: ST_TO_ADDR
// tmp := FilterUnitsInArea ( area , [ f_type , unit_building ] ) ;
59772: LD_ADDR_VAR 0 5
59776: PUSH
59777: LD_VAR 0 2
59781: PPUSH
59782: LD_INT 21
59784: PUSH
59785: LD_INT 3
59787: PUSH
59788: EMPTY
59789: LIST
59790: LIST
59791: PPUSH
59792: CALL_OW 70
59796: ST_TO_ADDR
// if not tmp then
59797: LD_VAR 0 5
59801: NOT
59802: IFFALSE 59806
// exit ;
59804: GO 59870
// if checkLink then
59806: LD_VAR 0 3
59810: IFFALSE 59860
// begin for i in tmp do
59812: LD_ADDR_VAR 0 6
59816: PUSH
59817: LD_VAR 0 5
59821: PUSH
59822: FOR_IN
59823: IFFALSE 59858
// if GetBase ( i ) <> base then
59825: LD_VAR 0 6
59829: PPUSH
59830: CALL_OW 274
59834: PUSH
59835: LD_VAR 0 1
59839: NONEQUAL
59840: IFFALSE 59856
// ComLinkToBase ( base , i ) ;
59842: LD_VAR 0 1
59846: PPUSH
59847: LD_VAR 0 6
59851: PPUSH
59852: CALL_OW 169
59856: GO 59822
59858: POP
59859: POP
// end ; result := tmp ;
59860: LD_ADDR_VAR 0 4
59864: PUSH
59865: LD_VAR 0 5
59869: ST_TO_ADDR
// end ;
59870: LD_VAR 0 4
59874: RET
// export function ComComplete ( units , b ) ; var i ; begin
59875: LD_INT 0
59877: PPUSH
59878: PPUSH
// if not units then
59879: LD_VAR 0 1
59883: NOT
59884: IFFALSE 59888
// exit ;
59886: GO 59978
// for i in units do
59888: LD_ADDR_VAR 0 4
59892: PUSH
59893: LD_VAR 0 1
59897: PUSH
59898: FOR_IN
59899: IFFALSE 59976
// if BuildingStatus ( b ) = bs_build then
59901: LD_VAR 0 2
59905: PPUSH
59906: CALL_OW 461
59910: PUSH
59911: LD_INT 1
59913: EQUAL
59914: IFFALSE 59974
// SetTaskList ( i , [ [ h , GetX ( b ) , GetY ( b ) , b , 0 , 0 , 0 ] ] ) ;
59916: LD_VAR 0 4
59920: PPUSH
59921: LD_STRING h
59923: PUSH
59924: LD_VAR 0 2
59928: PPUSH
59929: CALL_OW 250
59933: PUSH
59934: LD_VAR 0 2
59938: PPUSH
59939: CALL_OW 251
59943: PUSH
59944: LD_VAR 0 2
59948: PUSH
59949: LD_INT 0
59951: PUSH
59952: LD_INT 0
59954: PUSH
59955: LD_INT 0
59957: PUSH
59958: EMPTY
59959: LIST
59960: LIST
59961: LIST
59962: LIST
59963: LIST
59964: LIST
59965: LIST
59966: PUSH
59967: EMPTY
59968: LIST
59969: PPUSH
59970: CALL_OW 446
59974: GO 59898
59976: POP
59977: POP
// end ;
59978: LD_VAR 0 3
59982: RET
// export function Connect ( vehicle ) ; var i , t , mech , tmp , j ; begin
59983: LD_INT 0
59985: PPUSH
59986: PPUSH
59987: PPUSH
59988: PPUSH
59989: PPUSH
59990: PPUSH
// if not vehicle or GetControl ( vehicle ) <> control_remote then
59991: LD_VAR 0 1
59995: NOT
59996: PUSH
59997: LD_VAR 0 1
60001: PPUSH
60002: CALL_OW 263
60006: PUSH
60007: LD_INT 2
60009: NONEQUAL
60010: OR
60011: IFFALSE 60015
// exit ;
60013: GO 60331
// tmp := FilterAllUnits ( [ [ f_side , GetSide ( vehicle ) ] , [ f_or , [ f_btype , b_control_tower ] , [ f_weapon , ar_control_tower ] ] ] ) ;
60015: LD_ADDR_VAR 0 6
60019: PUSH
60020: LD_INT 22
60022: PUSH
60023: LD_VAR 0 1
60027: PPUSH
60028: CALL_OW 255
60032: PUSH
60033: EMPTY
60034: LIST
60035: LIST
60036: PUSH
60037: LD_INT 2
60039: PUSH
60040: LD_INT 30
60042: PUSH
60043: LD_INT 36
60045: PUSH
60046: EMPTY
60047: LIST
60048: LIST
60049: PUSH
60050: LD_INT 34
60052: PUSH
60053: LD_INT 31
60055: PUSH
60056: EMPTY
60057: LIST
60058: LIST
60059: PUSH
60060: EMPTY
60061: LIST
60062: LIST
60063: LIST
60064: PUSH
60065: EMPTY
60066: LIST
60067: LIST
60068: PPUSH
60069: CALL_OW 69
60073: ST_TO_ADDR
// if not tmp then
60074: LD_VAR 0 6
60078: NOT
60079: IFFALSE 60083
// exit ;
60081: GO 60331
// result := [ ] ;
60083: LD_ADDR_VAR 0 2
60087: PUSH
60088: EMPTY
60089: ST_TO_ADDR
// for i in tmp do
60090: LD_ADDR_VAR 0 3
60094: PUSH
60095: LD_VAR 0 6
60099: PUSH
60100: FOR_IN
60101: IFFALSE 60172
// begin t := UnitsInside ( i ) ;
60103: LD_ADDR_VAR 0 4
60107: PUSH
60108: LD_VAR 0 3
60112: PPUSH
60113: CALL_OW 313
60117: ST_TO_ADDR
// if t then
60118: LD_VAR 0 4
60122: IFFALSE 60170
// for j in t do
60124: LD_ADDR_VAR 0 7
60128: PUSH
60129: LD_VAR 0 4
60133: PUSH
60134: FOR_IN
60135: IFFALSE 60168
// result := Replace ( result , result + 1 , j ) ;
60137: LD_ADDR_VAR 0 2
60141: PUSH
60142: LD_VAR 0 2
60146: PPUSH
60147: LD_VAR 0 2
60151: PUSH
60152: LD_INT 1
60154: PLUS
60155: PPUSH
60156: LD_VAR 0 7
60160: PPUSH
60161: CALL_OW 1
60165: ST_TO_ADDR
60166: GO 60134
60168: POP
60169: POP
// end ;
60170: GO 60100
60172: POP
60173: POP
// if not result then
60174: LD_VAR 0 2
60178: NOT
60179: IFFALSE 60183
// exit ;
60181: GO 60331
// mech := result [ 1 ] ;
60183: LD_ADDR_VAR 0 5
60187: PUSH
60188: LD_VAR 0 2
60192: PUSH
60193: LD_INT 1
60195: ARRAY
60196: ST_TO_ADDR
// if result > 1 then
60197: LD_VAR 0 2
60201: PUSH
60202: LD_INT 1
60204: GREATER
60205: IFFALSE 60317
// begin for i = 2 to result do
60207: LD_ADDR_VAR 0 3
60211: PUSH
60212: DOUBLE
60213: LD_INT 2
60215: DEC
60216: ST_TO_ADDR
60217: LD_VAR 0 2
60221: PUSH
60222: FOR_TO
60223: IFFALSE 60315
// begin t := GetSkill ( result [ i ] , 3 ) - UnitsLinked ( result [ i ] ) ;
60225: LD_ADDR_VAR 0 4
60229: PUSH
60230: LD_VAR 0 2
60234: PUSH
60235: LD_VAR 0 3
60239: ARRAY
60240: PPUSH
60241: LD_INT 3
60243: PPUSH
60244: CALL_OW 259
60248: PUSH
60249: LD_VAR 0 2
60253: PUSH
60254: LD_VAR 0 3
60258: ARRAY
60259: PPUSH
60260: CALL_OW 432
60264: MINUS
60265: ST_TO_ADDR
// if t >= ( GetSkill ( mech , 3 ) - UnitsLinked ( mech ) ) then
60266: LD_VAR 0 4
60270: PUSH
60271: LD_VAR 0 5
60275: PPUSH
60276: LD_INT 3
60278: PPUSH
60279: CALL_OW 259
60283: PUSH
60284: LD_VAR 0 5
60288: PPUSH
60289: CALL_OW 432
60293: MINUS
60294: GREATEREQUAL
60295: IFFALSE 60313
// mech := result [ i ] ;
60297: LD_ADDR_VAR 0 5
60301: PUSH
60302: LD_VAR 0 2
60306: PUSH
60307: LD_VAR 0 3
60311: ARRAY
60312: ST_TO_ADDR
// end ;
60313: GO 60222
60315: POP
60316: POP
// end ; ComLinkTo ( vehicle , mech ) ;
60317: LD_VAR 0 1
60321: PPUSH
60322: LD_VAR 0 5
60326: PPUSH
60327: CALL_OW 135
// end ;
60331: LD_VAR 0 2
60335: RET
// export function PrepareBase ( base_dep , area , name , skill , sources , personel ) ; var i , j , d , b , f , x , un , base , side , nation , buildings , tmp ; begin
60336: LD_INT 0
60338: PPUSH
60339: PPUSH
60340: PPUSH
60341: PPUSH
60342: PPUSH
60343: PPUSH
60344: PPUSH
60345: PPUSH
60346: PPUSH
60347: PPUSH
60348: PPUSH
60349: PPUSH
60350: PPUSH
// result := [ ] ;
60351: LD_ADDR_VAR 0 7
60355: PUSH
60356: EMPTY
60357: ST_TO_ADDR
// if not GetBType ( base_dep ) in [ b_depot , b_warehouse ] then
60358: LD_VAR 0 1
60362: PPUSH
60363: CALL_OW 266
60367: PUSH
60368: LD_INT 0
60370: PUSH
60371: LD_INT 1
60373: PUSH
60374: EMPTY
60375: LIST
60376: LIST
60377: IN
60378: NOT
60379: IFFALSE 60383
// exit ;
60381: GO 62017
// if name then
60383: LD_VAR 0 3
60387: IFFALSE 60403
// SetBName ( base_dep , name ) ;
60389: LD_VAR 0 1
60393: PPUSH
60394: LD_VAR 0 3
60398: PPUSH
60399: CALL_OW 500
// base := GetBase ( base_dep ) ;
60403: LD_ADDR_VAR 0 15
60407: PUSH
60408: LD_VAR 0 1
60412: PPUSH
60413: CALL_OW 274
60417: ST_TO_ADDR
// side := GetSide ( base_dep ) ;
60418: LD_ADDR_VAR 0 16
60422: PUSH
60423: LD_VAR 0 1
60427: PPUSH
60428: CALL_OW 255
60432: ST_TO_ADDR
// nation := GetNation ( base_dep ) ;
60433: LD_ADDR_VAR 0 17
60437: PUSH
60438: LD_VAR 0 1
60442: PPUSH
60443: CALL_OW 248
60447: ST_TO_ADDR
// if sources then
60448: LD_VAR 0 5
60452: IFFALSE 60499
// for i = 1 to 3 do
60454: LD_ADDR_VAR 0 8
60458: PUSH
60459: DOUBLE
60460: LD_INT 1
60462: DEC
60463: ST_TO_ADDR
60464: LD_INT 3
60466: PUSH
60467: FOR_TO
60468: IFFALSE 60497
// AddResourceType ( base , i , sources [ i ] ) ;
60470: LD_VAR 0 15
60474: PPUSH
60475: LD_VAR 0 8
60479: PPUSH
60480: LD_VAR 0 5
60484: PUSH
60485: LD_VAR 0 8
60489: ARRAY
60490: PPUSH
60491: CALL_OW 276
60495: GO 60467
60497: POP
60498: POP
// buildings := GetBaseBuildings ( base , area , true ) ;
60499: LD_ADDR_VAR 0 18
60503: PUSH
60504: LD_VAR 0 15
60508: PPUSH
60509: LD_VAR 0 2
60513: PPUSH
60514: LD_INT 1
60516: PPUSH
60517: CALL 59760 0 3
60521: ST_TO_ADDR
// InitHc ;
60522: CALL_OW 19
// InitUc ;
60526: CALL_OW 18
// uc_side := side ;
60530: LD_ADDR_OWVAR 20
60534: PUSH
60535: LD_VAR 0 16
60539: ST_TO_ADDR
// uc_nation := nation ;
60540: LD_ADDR_OWVAR 21
60544: PUSH
60545: LD_VAR 0 17
60549: ST_TO_ADDR
// if buildings then
60550: LD_VAR 0 18
60554: IFFALSE 61876
// begin tmp := UnitFilter ( buildings , [ f_or , [ f_btype , b_oil_mine ] , [ f_btype , b_siberite_mine ] ] ) ;
60556: LD_ADDR_VAR 0 19
60560: PUSH
60561: LD_VAR 0 18
60565: PPUSH
60566: LD_INT 2
60568: PUSH
60569: LD_INT 30
60571: PUSH
60572: LD_INT 29
60574: PUSH
60575: EMPTY
60576: LIST
60577: LIST
60578: PUSH
60579: LD_INT 30
60581: PUSH
60582: LD_INT 30
60584: PUSH
60585: EMPTY
60586: LIST
60587: LIST
60588: PUSH
60589: EMPTY
60590: LIST
60591: LIST
60592: LIST
60593: PPUSH
60594: CALL_OW 72
60598: ST_TO_ADDR
// if tmp then
60599: LD_VAR 0 19
60603: IFFALSE 60651
// for i in tmp do
60605: LD_ADDR_VAR 0 8
60609: PUSH
60610: LD_VAR 0 19
60614: PUSH
60615: FOR_IN
60616: IFFALSE 60649
// SetResourceVisibility ( GetX ( i ) , GetY ( i ) , side ) ;
60618: LD_VAR 0 8
60622: PPUSH
60623: CALL_OW 250
60627: PPUSH
60628: LD_VAR 0 8
60632: PPUSH
60633: CALL_OW 251
60637: PPUSH
60638: LD_VAR 0 16
60642: PPUSH
60643: CALL_OW 441
60647: GO 60615
60649: POP
60650: POP
// if UnitFilter ( buildings , [ f_or , [ f_btype , b_bunker ] , [ f_btype , b_turret ] ] ) then
60651: LD_VAR 0 18
60655: PPUSH
60656: LD_INT 2
60658: PUSH
60659: LD_INT 30
60661: PUSH
60662: LD_INT 32
60664: PUSH
60665: EMPTY
60666: LIST
60667: LIST
60668: PUSH
60669: LD_INT 30
60671: PUSH
60672: LD_INT 33
60674: PUSH
60675: EMPTY
60676: LIST
60677: LIST
60678: PUSH
60679: EMPTY
60680: LIST
60681: LIST
60682: LIST
60683: PPUSH
60684: CALL_OW 72
60688: IFFALSE 60776
// begin for i in UnitFilter ( buildings , [ f_or , [ f_btype , b_bunker ] , [ f_btype , b_turret ] ] ) do
60690: LD_ADDR_VAR 0 8
60694: PUSH
60695: LD_VAR 0 18
60699: PPUSH
60700: LD_INT 2
60702: PUSH
60703: LD_INT 30
60705: PUSH
60706: LD_INT 32
60708: PUSH
60709: EMPTY
60710: LIST
60711: LIST
60712: PUSH
60713: LD_INT 30
60715: PUSH
60716: LD_INT 33
60718: PUSH
60719: EMPTY
60720: LIST
60721: LIST
60722: PUSH
60723: EMPTY
60724: LIST
60725: LIST
60726: LIST
60727: PPUSH
60728: CALL_OW 72
60732: PUSH
60733: FOR_IN
60734: IFFALSE 60774
// begin if not GetBWeapon ( i ) then
60736: LD_VAR 0 8
60740: PPUSH
60741: CALL_OW 269
60745: NOT
60746: IFFALSE 60772
// PlaceWeaponTurret ( i , GetTurretWeapon ( i , area ) ) ;
60748: LD_VAR 0 8
60752: PPUSH
60753: LD_VAR 0 8
60757: PPUSH
60758: LD_VAR 0 2
60762: PPUSH
60763: CALL 62022 0 2
60767: PPUSH
60768: CALL_OW 431
// end ;
60772: GO 60733
60774: POP
60775: POP
// end ; for i = 1 to personel do
60776: LD_ADDR_VAR 0 8
60780: PUSH
60781: DOUBLE
60782: LD_INT 1
60784: DEC
60785: ST_TO_ADDR
60786: LD_VAR 0 6
60790: PUSH
60791: FOR_TO
60792: IFFALSE 61856
// begin if i > 4 then
60794: LD_VAR 0 8
60798: PUSH
60799: LD_INT 4
60801: GREATER
60802: IFFALSE 60806
// break ;
60804: GO 61856
// case i of 1 :
60806: LD_VAR 0 8
60810: PUSH
60811: LD_INT 1
60813: DOUBLE
60814: EQUAL
60815: IFTRUE 60819
60817: GO 60899
60819: POP
// f := UnitFilter ( buildings , [ [ f_side , side ] , [ f_empty ] , [ f_or , [ f_btype , b_bunker ] , [ f_btype , b_armoury ] , [ f_btype , b_barracks ] ] ] ) ; 2 :
60820: LD_ADDR_VAR 0 12
60824: PUSH
60825: LD_VAR 0 18
60829: PPUSH
60830: LD_INT 22
60832: PUSH
60833: LD_VAR 0 16
60837: PUSH
60838: EMPTY
60839: LIST
60840: LIST
60841: PUSH
60842: LD_INT 58
60844: PUSH
60845: EMPTY
60846: LIST
60847: PUSH
60848: LD_INT 2
60850: PUSH
60851: LD_INT 30
60853: PUSH
60854: LD_INT 32
60856: PUSH
60857: EMPTY
60858: LIST
60859: LIST
60860: PUSH
60861: LD_INT 30
60863: PUSH
60864: LD_INT 4
60866: PUSH
60867: EMPTY
60868: LIST
60869: LIST
60870: PUSH
60871: LD_INT 30
60873: PUSH
60874: LD_INT 5
60876: PUSH
60877: EMPTY
60878: LIST
60879: LIST
60880: PUSH
60881: EMPTY
60882: LIST
60883: LIST
60884: LIST
60885: LIST
60886: PUSH
60887: EMPTY
60888: LIST
60889: LIST
60890: LIST
60891: PPUSH
60892: CALL_OW 72
60896: ST_TO_ADDR
60897: GO 61121
60899: LD_INT 2
60901: DOUBLE
60902: EQUAL
60903: IFTRUE 60907
60905: GO 60969
60907: POP
// f := UnitFilter ( buildings , [ [ f_side , side ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ] ) ; 3 :
60908: LD_ADDR_VAR 0 12
60912: PUSH
60913: LD_VAR 0 18
60917: PPUSH
60918: LD_INT 22
60920: PUSH
60921: LD_VAR 0 16
60925: PUSH
60926: EMPTY
60927: LIST
60928: LIST
60929: PUSH
60930: LD_INT 2
60932: PUSH
60933: LD_INT 30
60935: PUSH
60936: LD_INT 0
60938: PUSH
60939: EMPTY
60940: LIST
60941: LIST
60942: PUSH
60943: LD_INT 30
60945: PUSH
60946: LD_INT 1
60948: PUSH
60949: EMPTY
60950: LIST
60951: LIST
60952: PUSH
60953: EMPTY
60954: LIST
60955: LIST
60956: LIST
60957: PUSH
60958: EMPTY
60959: LIST
60960: LIST
60961: PPUSH
60962: CALL_OW 72
60966: ST_TO_ADDR
60967: GO 61121
60969: LD_INT 3
60971: DOUBLE
60972: EQUAL
60973: IFTRUE 60977
60975: GO 61039
60977: POP
// f := UnitFilter ( buildings , [ [ f_side , side ] , [ f_or , [ f_btype , b_workshop ] , [ f_btype , b_factory ] ] ] ) ; 4 :
60978: LD_ADDR_VAR 0 12
60982: PUSH
60983: LD_VAR 0 18
60987: PPUSH
60988: LD_INT 22
60990: PUSH
60991: LD_VAR 0 16
60995: PUSH
60996: EMPTY
60997: LIST
60998: LIST
60999: PUSH
61000: LD_INT 2
61002: PUSH
61003: LD_INT 30
61005: PUSH
61006: LD_INT 2
61008: PUSH
61009: EMPTY
61010: LIST
61011: LIST
61012: PUSH
61013: LD_INT 30
61015: PUSH
61016: LD_INT 3
61018: PUSH
61019: EMPTY
61020: LIST
61021: LIST
61022: PUSH
61023: EMPTY
61024: LIST
61025: LIST
61026: LIST
61027: PUSH
61028: EMPTY
61029: LIST
61030: LIST
61031: PPUSH
61032: CALL_OW 72
61036: ST_TO_ADDR
61037: GO 61121
61039: LD_INT 4
61041: DOUBLE
61042: EQUAL
61043: IFTRUE 61047
61045: GO 61120
61047: POP
// f := UnitFilter ( buildings , [ [ f_side , side ] , [ f_or , [ f_btype , b_lab ] , [ f_btype , b_lab_half ] , [ f_btype , b_lab_full ] ] ] ) ; end ;
61048: LD_ADDR_VAR 0 12
61052: PUSH
61053: LD_VAR 0 18
61057: PPUSH
61058: LD_INT 22
61060: PUSH
61061: LD_VAR 0 16
61065: PUSH
61066: EMPTY
61067: LIST
61068: LIST
61069: PUSH
61070: LD_INT 2
61072: PUSH
61073: LD_INT 30
61075: PUSH
61076: LD_INT 6
61078: PUSH
61079: EMPTY
61080: LIST
61081: LIST
61082: PUSH
61083: LD_INT 30
61085: PUSH
61086: LD_INT 7
61088: PUSH
61089: EMPTY
61090: LIST
61091: LIST
61092: PUSH
61093: LD_INT 30
61095: PUSH
61096: LD_INT 8
61098: PUSH
61099: EMPTY
61100: LIST
61101: LIST
61102: PUSH
61103: EMPTY
61104: LIST
61105: LIST
61106: LIST
61107: LIST
61108: PUSH
61109: EMPTY
61110: LIST
61111: LIST
61112: PPUSH
61113: CALL_OW 72
61117: ST_TO_ADDR
61118: GO 61121
61120: POP
// if i = 1 then
61121: LD_VAR 0 8
61125: PUSH
61126: LD_INT 1
61128: EQUAL
61129: IFFALSE 61240
// begin tmp := [ ] ;
61131: LD_ADDR_VAR 0 19
61135: PUSH
61136: EMPTY
61137: ST_TO_ADDR
// for j in f do
61138: LD_ADDR_VAR 0 9
61142: PUSH
61143: LD_VAR 0 12
61147: PUSH
61148: FOR_IN
61149: IFFALSE 61222
// if GetBType ( j ) = b_bunker then
61151: LD_VAR 0 9
61155: PPUSH
61156: CALL_OW 266
61160: PUSH
61161: LD_INT 32
61163: EQUAL
61164: IFFALSE 61191
// tmp := Insert ( tmp , 1 , j ) else
61166: LD_ADDR_VAR 0 19
61170: PUSH
61171: LD_VAR 0 19
61175: PPUSH
61176: LD_INT 1
61178: PPUSH
61179: LD_VAR 0 9
61183: PPUSH
61184: CALL_OW 2
61188: ST_TO_ADDR
61189: GO 61220
// tmp := Insert ( tmp , tmp + 1 , j ) ;
61191: LD_ADDR_VAR 0 19
61195: PUSH
61196: LD_VAR 0 19
61200: PPUSH
61201: LD_VAR 0 19
61205: PUSH
61206: LD_INT 1
61208: PLUS
61209: PPUSH
61210: LD_VAR 0 9
61214: PPUSH
61215: CALL_OW 2
61219: ST_TO_ADDR
61220: GO 61148
61222: POP
61223: POP
// if tmp then
61224: LD_VAR 0 19
61228: IFFALSE 61240
// f := tmp ;
61230: LD_ADDR_VAR 0 12
61234: PUSH
61235: LD_VAR 0 19
61239: ST_TO_ADDR
// end ; x := personel [ i ] ;
61240: LD_ADDR_VAR 0 13
61244: PUSH
61245: LD_VAR 0 6
61249: PUSH
61250: LD_VAR 0 8
61254: ARRAY
61255: ST_TO_ADDR
// if x = - 1 then
61256: LD_VAR 0 13
61260: PUSH
61261: LD_INT 1
61263: NEG
61264: EQUAL
61265: IFFALSE 61474
// begin for j in f do
61267: LD_ADDR_VAR 0 9
61271: PUSH
61272: LD_VAR 0 12
61276: PUSH
61277: FOR_IN
61278: IFFALSE 61470
// repeat InitHc ;
61280: CALL_OW 19
// if GetBType ( j ) = b_barracks then
61284: LD_VAR 0 9
61288: PPUSH
61289: CALL_OW 266
61293: PUSH
61294: LD_INT 5
61296: EQUAL
61297: IFFALSE 61367
// begin if UnitsInside ( j ) < 3 then
61299: LD_VAR 0 9
61303: PPUSH
61304: CALL_OW 313
61308: PUSH
61309: LD_INT 3
61311: LESS
61312: IFFALSE 61348
// PrepareHuman ( false , [ class_sniper , class_mortar , class_bazooker ] [ nation ] , skill ) else
61314: LD_INT 0
61316: PPUSH
61317: LD_INT 5
61319: PUSH
61320: LD_INT 8
61322: PUSH
61323: LD_INT 9
61325: PUSH
61326: EMPTY
61327: LIST
61328: LIST
61329: LIST
61330: PUSH
61331: LD_VAR 0 17
61335: ARRAY
61336: PPUSH
61337: LD_VAR 0 4
61341: PPUSH
61342: CALL_OW 380
61346: GO 61365
// PrepareHuman ( false , i , skill ) ;
61348: LD_INT 0
61350: PPUSH
61351: LD_VAR 0 8
61355: PPUSH
61356: LD_VAR 0 4
61360: PPUSH
61361: CALL_OW 380
// end else
61365: GO 61384
// PrepareHuman ( false , i , skill ) ;
61367: LD_INT 0
61369: PPUSH
61370: LD_VAR 0 8
61374: PPUSH
61375: LD_VAR 0 4
61379: PPUSH
61380: CALL_OW 380
// un := CreateHuman ;
61384: LD_ADDR_VAR 0 14
61388: PUSH
61389: CALL_OW 44
61393: ST_TO_ADDR
// result := Insert ( result , 1 , un ) ;
61394: LD_ADDR_VAR 0 7
61398: PUSH
61399: LD_VAR 0 7
61403: PPUSH
61404: LD_INT 1
61406: PPUSH
61407: LD_VAR 0 14
61411: PPUSH
61412: CALL_OW 2
61416: ST_TO_ADDR
// PlaceHumanInUnit ( un , j ) ;
61417: LD_VAR 0 14
61421: PPUSH
61422: LD_VAR 0 9
61426: PPUSH
61427: CALL_OW 52
// until UnitsInside ( j ) = 6 or GetBType ( j ) in [ b_bunker , b_breastwork ] ;
61431: LD_VAR 0 9
61435: PPUSH
61436: CALL_OW 313
61440: PUSH
61441: LD_INT 6
61443: EQUAL
61444: PUSH
61445: LD_VAR 0 9
61449: PPUSH
61450: CALL_OW 266
61454: PUSH
61455: LD_INT 32
61457: PUSH
61458: LD_INT 31
61460: PUSH
61461: EMPTY
61462: LIST
61463: LIST
61464: IN
61465: OR
61466: IFFALSE 61280
61468: GO 61277
61470: POP
61471: POP
// end else
61472: GO 61854
// for j = 1 to x do
61474: LD_ADDR_VAR 0 9
61478: PUSH
61479: DOUBLE
61480: LD_INT 1
61482: DEC
61483: ST_TO_ADDR
61484: LD_VAR 0 13
61488: PUSH
61489: FOR_TO
61490: IFFALSE 61852
// begin InitHc ;
61492: CALL_OW 19
// if not f then
61496: LD_VAR 0 12
61500: NOT
61501: IFFALSE 61590
// begin PrepareHuman ( false , i , skill ) ;
61503: LD_INT 0
61505: PPUSH
61506: LD_VAR 0 8
61510: PPUSH
61511: LD_VAR 0 4
61515: PPUSH
61516: CALL_OW 380
// un := CreateHuman ;
61520: LD_ADDR_VAR 0 14
61524: PUSH
61525: CALL_OW 44
61529: ST_TO_ADDR
// result := Insert ( result , 1 , un ) ;
61530: LD_ADDR_VAR 0 7
61534: PUSH
61535: LD_VAR 0 7
61539: PPUSH
61540: LD_INT 1
61542: PPUSH
61543: LD_VAR 0 14
61547: PPUSH
61548: CALL_OW 2
61552: ST_TO_ADDR
// PlaceUnitXYR ( un , GetX ( base_dep ) , GetY ( base_dep ) , 10 , false ) ;
61553: LD_VAR 0 14
61557: PPUSH
61558: LD_VAR 0 1
61562: PPUSH
61563: CALL_OW 250
61567: PPUSH
61568: LD_VAR 0 1
61572: PPUSH
61573: CALL_OW 251
61577: PPUSH
61578: LD_INT 10
61580: PPUSH
61581: LD_INT 0
61583: PPUSH
61584: CALL_OW 50
// continue ;
61588: GO 61489
// end ; if ( UnitsInside ( f [ 1 ] ) and GetBType ( f [ 1 ] ) in [ b_bunker , b_breastwork ] ) or ( UnitsInside ( f [ 1 ] ) = 6 ) then
61590: LD_VAR 0 12
61594: PUSH
61595: LD_INT 1
61597: ARRAY
61598: PPUSH
61599: CALL_OW 313
61603: PUSH
61604: LD_VAR 0 12
61608: PUSH
61609: LD_INT 1
61611: ARRAY
61612: PPUSH
61613: CALL_OW 266
61617: PUSH
61618: LD_INT 32
61620: PUSH
61621: LD_INT 31
61623: PUSH
61624: EMPTY
61625: LIST
61626: LIST
61627: IN
61628: AND
61629: PUSH
61630: LD_VAR 0 12
61634: PUSH
61635: LD_INT 1
61637: ARRAY
61638: PPUSH
61639: CALL_OW 313
61643: PUSH
61644: LD_INT 6
61646: EQUAL
61647: OR
61648: IFFALSE 61668
// f := Delete ( f , 1 ) ;
61650: LD_ADDR_VAR 0 12
61654: PUSH
61655: LD_VAR 0 12
61659: PPUSH
61660: LD_INT 1
61662: PPUSH
61663: CALL_OW 3
61667: ST_TO_ADDR
// if not f then
61668: LD_VAR 0 12
61672: NOT
61673: IFFALSE 61691
// begin x := x + 2 ;
61675: LD_ADDR_VAR 0 13
61679: PUSH
61680: LD_VAR 0 13
61684: PUSH
61685: LD_INT 2
61687: PLUS
61688: ST_TO_ADDR
// continue ;
61689: GO 61489
// end ; if GetBType ( f [ 1 ] ) = b_barracks then
61691: LD_VAR 0 12
61695: PUSH
61696: LD_INT 1
61698: ARRAY
61699: PPUSH
61700: CALL_OW 266
61704: PUSH
61705: LD_INT 5
61707: EQUAL
61708: IFFALSE 61782
// begin if UnitsInside ( f [ 1 ] ) < 3 then
61710: LD_VAR 0 12
61714: PUSH
61715: LD_INT 1
61717: ARRAY
61718: PPUSH
61719: CALL_OW 313
61723: PUSH
61724: LD_INT 3
61726: LESS
61727: IFFALSE 61763
// PrepareHuman ( false , [ class_sniper , class_mortar , class_bazooker ] [ nation ] , skill ) else
61729: LD_INT 0
61731: PPUSH
61732: LD_INT 5
61734: PUSH
61735: LD_INT 8
61737: PUSH
61738: LD_INT 9
61740: PUSH
61741: EMPTY
61742: LIST
61743: LIST
61744: LIST
61745: PUSH
61746: LD_VAR 0 17
61750: ARRAY
61751: PPUSH
61752: LD_VAR 0 4
61756: PPUSH
61757: CALL_OW 380
61761: GO 61780
// PrepareHuman ( false , i , skill ) ;
61763: LD_INT 0
61765: PPUSH
61766: LD_VAR 0 8
61770: PPUSH
61771: LD_VAR 0 4
61775: PPUSH
61776: CALL_OW 380
// end else
61780: GO 61799
// PrepareHuman ( false , i , skill ) ;
61782: LD_INT 0
61784: PPUSH
61785: LD_VAR 0 8
61789: PPUSH
61790: LD_VAR 0 4
61794: PPUSH
61795: CALL_OW 380
// un := CreateHuman ;
61799: LD_ADDR_VAR 0 14
61803: PUSH
61804: CALL_OW 44
61808: ST_TO_ADDR
// result := Insert ( result , 1 , un ) ;
61809: LD_ADDR_VAR 0 7
61813: PUSH
61814: LD_VAR 0 7
61818: PPUSH
61819: LD_INT 1
61821: PPUSH
61822: LD_VAR 0 14
61826: PPUSH
61827: CALL_OW 2
61831: ST_TO_ADDR
// PlaceHumanInUnit ( un , f [ 1 ] ) ;
61832: LD_VAR 0 14
61836: PPUSH
61837: LD_VAR 0 12
61841: PUSH
61842: LD_INT 1
61844: ARRAY
61845: PPUSH
61846: CALL_OW 52
// end ;
61850: GO 61489
61852: POP
61853: POP
// end ;
61854: GO 60791
61856: POP
61857: POP
// result := result ^ buildings ;
61858: LD_ADDR_VAR 0 7
61862: PUSH
61863: LD_VAR 0 7
61867: PUSH
61868: LD_VAR 0 18
61872: ADD
61873: ST_TO_ADDR
// end else
61874: GO 62017
// begin for i = 1 to personel do
61876: LD_ADDR_VAR 0 8
61880: PUSH
61881: DOUBLE
61882: LD_INT 1
61884: DEC
61885: ST_TO_ADDR
61886: LD_VAR 0 6
61890: PUSH
61891: FOR_TO
61892: IFFALSE 62015
// begin if i > 4 then
61894: LD_VAR 0 8
61898: PUSH
61899: LD_INT 4
61901: GREATER
61902: IFFALSE 61906
// break ;
61904: GO 62015
// x := personel [ i ] ;
61906: LD_ADDR_VAR 0 13
61910: PUSH
61911: LD_VAR 0 6
61915: PUSH
61916: LD_VAR 0 8
61920: ARRAY
61921: ST_TO_ADDR
// if x = - 1 then
61922: LD_VAR 0 13
61926: PUSH
61927: LD_INT 1
61929: NEG
61930: EQUAL
61931: IFFALSE 61935
// continue ;
61933: GO 61891
// PrepareHuman ( false , i , skill ) ;
61935: LD_INT 0
61937: PPUSH
61938: LD_VAR 0 8
61942: PPUSH
61943: LD_VAR 0 4
61947: PPUSH
61948: CALL_OW 380
// un := CreateHuman ;
61952: LD_ADDR_VAR 0 14
61956: PUSH
61957: CALL_OW 44
61961: ST_TO_ADDR
// PlaceUnitXYR ( un , GetX ( base_dep ) , GetY ( base_dep ) , 10 , false ) ;
61962: LD_VAR 0 14
61966: PPUSH
61967: LD_VAR 0 1
61971: PPUSH
61972: CALL_OW 250
61976: PPUSH
61977: LD_VAR 0 1
61981: PPUSH
61982: CALL_OW 251
61986: PPUSH
61987: LD_INT 10
61989: PPUSH
61990: LD_INT 0
61992: PPUSH
61993: CALL_OW 50
// result := result ^ un ;
61997: LD_ADDR_VAR 0 7
62001: PUSH
62002: LD_VAR 0 7
62006: PUSH
62007: LD_VAR 0 14
62011: ADD
62012: ST_TO_ADDR
// end ;
62013: GO 61891
62015: POP
62016: POP
// end ; end ;
62017: LD_VAR 0 7
62021: RET
// export function GetTurretWeapon ( tower , area ) ; var hex , list , factories , base , i , j , x , y , nat , h , tmp , height , side , fac_list , weapon ; begin
62022: LD_INT 0
62024: PPUSH
62025: PPUSH
62026: PPUSH
62027: PPUSH
62028: PPUSH
62029: PPUSH
62030: PPUSH
62031: PPUSH
62032: PPUSH
62033: PPUSH
62034: PPUSH
62035: PPUSH
62036: PPUSH
62037: PPUSH
62038: PPUSH
62039: PPUSH
// result := false ;
62040: LD_ADDR_VAR 0 3
62044: PUSH
62045: LD_INT 0
62047: ST_TO_ADDR
// if not tower or not GetBType ( tower ) in [ b_bunker , b_turret ] then
62048: LD_VAR 0 1
62052: NOT
62053: PUSH
62054: LD_VAR 0 1
62058: PPUSH
62059: CALL_OW 266
62063: PUSH
62064: LD_INT 32
62066: PUSH
62067: LD_INT 33
62069: PUSH
62070: EMPTY
62071: LIST
62072: LIST
62073: IN
62074: NOT
62075: OR
62076: IFFALSE 62080
// exit ;
62078: GO 63189
// nat := GetNation ( tower ) ;
62080: LD_ADDR_VAR 0 12
62084: PUSH
62085: LD_VAR 0 1
62089: PPUSH
62090: CALL_OW 248
62094: ST_TO_ADDR
// side := GetSide ( tower ) ;
62095: LD_ADDR_VAR 0 16
62099: PUSH
62100: LD_VAR 0 1
62104: PPUSH
62105: CALL_OW 255
62109: ST_TO_ADDR
// x := GetX ( tower ) ;
62110: LD_ADDR_VAR 0 10
62114: PUSH
62115: LD_VAR 0 1
62119: PPUSH
62120: CALL_OW 250
62124: ST_TO_ADDR
// y := GetY ( tower ) ;
62125: LD_ADDR_VAR 0 11
62129: PUSH
62130: LD_VAR 0 1
62134: PPUSH
62135: CALL_OW 251
62139: ST_TO_ADDR
// if not x or not y then
62140: LD_VAR 0 10
62144: NOT
62145: PUSH
62146: LD_VAR 0 11
62150: NOT
62151: OR
62152: IFFALSE 62156
// exit ;
62154: GO 63189
// weapon := 0 ;
62156: LD_ADDR_VAR 0 18
62160: PUSH
62161: LD_INT 0
62163: ST_TO_ADDR
// fac_list := [ ] ;
62164: LD_ADDR_VAR 0 17
62168: PUSH
62169: EMPTY
62170: ST_TO_ADDR
// factories := UnitFilter ( GetBaseBuildings ( GetBase ( tower ) , area , false ) , [ f_btype , b_factory ] ) ;
62171: LD_ADDR_VAR 0 6
62175: PUSH
62176: LD_VAR 0 1
62180: PPUSH
62181: CALL_OW 274
62185: PPUSH
62186: LD_VAR 0 2
62190: PPUSH
62191: LD_INT 0
62193: PPUSH
62194: CALL 59760 0 3
62198: PPUSH
62199: LD_INT 30
62201: PUSH
62202: LD_INT 3
62204: PUSH
62205: EMPTY
62206: LIST
62207: LIST
62208: PPUSH
62209: CALL_OW 72
62213: ST_TO_ADDR
// if not factories then
62214: LD_VAR 0 6
62218: NOT
62219: IFFALSE 62223
// exit ;
62221: GO 63189
// for i in factories do
62223: LD_ADDR_VAR 0 8
62227: PUSH
62228: LD_VAR 0 6
62232: PUSH
62233: FOR_IN
62234: IFFALSE 62259
// fac_list := fac_list union AvailableWeaponList ( i ) ;
62236: LD_ADDR_VAR 0 17
62240: PUSH
62241: LD_VAR 0 17
62245: PUSH
62246: LD_VAR 0 8
62250: PPUSH
62251: CALL_OW 478
62255: UNION
62256: ST_TO_ADDR
62257: GO 62233
62259: POP
62260: POP
// if not fac_list then
62261: LD_VAR 0 17
62265: NOT
62266: IFFALSE 62270
// exit ;
62268: GO 63189
// list := [ [ us_gatling_gun , us_double_gun , us_laser , us_double_laser , us_heavy_gun , us_rocket_launcher , us_radar ] , [ ar_gun , ar_rocket_launcher , ar_flame_thrower , ar_radar ] , [ ru_gatling_gun , ru_gun , ru_heavy_gun , ru_rocket_launcher , ru_rocket , ru_time_lapser ] ] [ nat ] ;
62270: LD_ADDR_VAR 0 5
62274: PUSH
62275: LD_INT 4
62277: PUSH
62278: LD_INT 5
62280: PUSH
62281: LD_INT 9
62283: PUSH
62284: LD_INT 10
62286: PUSH
62287: LD_INT 6
62289: PUSH
62290: LD_INT 7
62292: PUSH
62293: LD_INT 11
62295: PUSH
62296: EMPTY
62297: LIST
62298: LIST
62299: LIST
62300: LIST
62301: LIST
62302: LIST
62303: LIST
62304: PUSH
62305: LD_INT 27
62307: PUSH
62308: LD_INT 28
62310: PUSH
62311: LD_INT 26
62313: PUSH
62314: LD_INT 30
62316: PUSH
62317: EMPTY
62318: LIST
62319: LIST
62320: LIST
62321: LIST
62322: PUSH
62323: LD_INT 43
62325: PUSH
62326: LD_INT 44
62328: PUSH
62329: LD_INT 46
62331: PUSH
62332: LD_INT 45
62334: PUSH
62335: LD_INT 47
62337: PUSH
62338: LD_INT 49
62340: PUSH
62341: EMPTY
62342: LIST
62343: LIST
62344: LIST
62345: LIST
62346: LIST
62347: LIST
62348: PUSH
62349: EMPTY
62350: LIST
62351: LIST
62352: LIST
62353: PUSH
62354: LD_VAR 0 12
62358: ARRAY
62359: ST_TO_ADDR
// list := list isect fac_list ;
62360: LD_ADDR_VAR 0 5
62364: PUSH
62365: LD_VAR 0 5
62369: PUSH
62370: LD_VAR 0 17
62374: ISECT
62375: ST_TO_ADDR
// if not list then
62376: LD_VAR 0 5
62380: NOT
62381: IFFALSE 62385
// exit ;
62383: GO 63189
// if nat = nation_russian and ru_time_lapser in list and GetTech ( tech_lapser , side ) = state_researched then
62385: LD_VAR 0 12
62389: PUSH
62390: LD_INT 3
62392: EQUAL
62393: PUSH
62394: LD_INT 49
62396: PUSH
62397: LD_VAR 0 5
62401: IN
62402: AND
62403: PUSH
62404: LD_INT 31
62406: PPUSH
62407: LD_VAR 0 16
62411: PPUSH
62412: CALL_OW 321
62416: PUSH
62417: LD_INT 2
62419: EQUAL
62420: AND
62421: IFFALSE 62481
// begin if not FilterAllUnits ( [ [ f_side , side ] , [ f_bweapon , ru_time_lapser ] , [ f_dist , tower , 10 ] ] ) then
62423: LD_INT 22
62425: PUSH
62426: LD_VAR 0 16
62430: PUSH
62431: EMPTY
62432: LIST
62433: LIST
62434: PUSH
62435: LD_INT 35
62437: PUSH
62438: LD_INT 49
62440: PUSH
62441: EMPTY
62442: LIST
62443: LIST
62444: PUSH
62445: LD_INT 91
62447: PUSH
62448: LD_VAR 0 1
62452: PUSH
62453: LD_INT 10
62455: PUSH
62456: EMPTY
62457: LIST
62458: LIST
62459: LIST
62460: PUSH
62461: EMPTY
62462: LIST
62463: LIST
62464: LIST
62465: PPUSH
62466: CALL_OW 69
62470: NOT
62471: IFFALSE 62481
// weapon := ru_time_lapser ;
62473: LD_ADDR_VAR 0 18
62477: PUSH
62478: LD_INT 49
62480: ST_TO_ADDR
// end ; if nat in [ 1 , 2 ] and ( us_radar in list or ar_radar in list ) and GetTech ( tech_radar , side ) = state_researched then
62481: LD_VAR 0 12
62485: PUSH
62486: LD_INT 1
62488: PUSH
62489: LD_INT 2
62491: PUSH
62492: EMPTY
62493: LIST
62494: LIST
62495: IN
62496: PUSH
62497: LD_INT 11
62499: PUSH
62500: LD_VAR 0 5
62504: IN
62505: PUSH
62506: LD_INT 30
62508: PUSH
62509: LD_VAR 0 5
62513: IN
62514: OR
62515: AND
62516: PUSH
62517: LD_INT 6
62519: PPUSH
62520: LD_VAR 0 16
62524: PPUSH
62525: CALL_OW 321
62529: PUSH
62530: LD_INT 2
62532: EQUAL
62533: AND
62534: IFFALSE 62699
// begin if not FilterAllUnits ( [ [ f_side , side ] , [ f_or , [ f_bweapon , us_radar ] , [ f_bweapon , ar_radar ] ] , [ f_dist , tower , 18 ] ] ) and FilterAllUnits ( [ [ [ f_side , side ] , [ f_or , [ f_btype , b_bunker ] , [ f_btype , b_turret ] ] , [ f_dist , tower , 12 ] ] ] ) > 2 then
62536: LD_INT 22
62538: PUSH
62539: LD_VAR 0 16
62543: PUSH
62544: EMPTY
62545: LIST
62546: LIST
62547: PUSH
62548: LD_INT 2
62550: PUSH
62551: LD_INT 35
62553: PUSH
62554: LD_INT 11
62556: PUSH
62557: EMPTY
62558: LIST
62559: LIST
62560: PUSH
62561: LD_INT 35
62563: PUSH
62564: LD_INT 30
62566: PUSH
62567: EMPTY
62568: LIST
62569: LIST
62570: PUSH
62571: EMPTY
62572: LIST
62573: LIST
62574: LIST
62575: PUSH
62576: LD_INT 91
62578: PUSH
62579: LD_VAR 0 1
62583: PUSH
62584: LD_INT 18
62586: PUSH
62587: EMPTY
62588: LIST
62589: LIST
62590: LIST
62591: PUSH
62592: EMPTY
62593: LIST
62594: LIST
62595: LIST
62596: PPUSH
62597: CALL_OW 69
62601: NOT
62602: PUSH
62603: LD_INT 22
62605: PUSH
62606: LD_VAR 0 16
62610: PUSH
62611: EMPTY
62612: LIST
62613: LIST
62614: PUSH
62615: LD_INT 2
62617: PUSH
62618: LD_INT 30
62620: PUSH
62621: LD_INT 32
62623: PUSH
62624: EMPTY
62625: LIST
62626: LIST
62627: PUSH
62628: LD_INT 30
62630: PUSH
62631: LD_INT 33
62633: PUSH
62634: EMPTY
62635: LIST
62636: LIST
62637: PUSH
62638: EMPTY
62639: LIST
62640: LIST
62641: LIST
62642: PUSH
62643: LD_INT 91
62645: PUSH
62646: LD_VAR 0 1
62650: PUSH
62651: LD_INT 12
62653: PUSH
62654: EMPTY
62655: LIST
62656: LIST
62657: LIST
62658: PUSH
62659: EMPTY
62660: LIST
62661: LIST
62662: LIST
62663: PUSH
62664: EMPTY
62665: LIST
62666: PPUSH
62667: CALL_OW 69
62671: PUSH
62672: LD_INT 2
62674: GREATER
62675: AND
62676: IFFALSE 62699
// weapon := [ us_radar , ar_radar ] [ nat ] ;
62678: LD_ADDR_VAR 0 18
62682: PUSH
62683: LD_INT 11
62685: PUSH
62686: LD_INT 30
62688: PUSH
62689: EMPTY
62690: LIST
62691: LIST
62692: PUSH
62693: LD_VAR 0 12
62697: ARRAY
62698: ST_TO_ADDR
// end ; if not weapon and GetTech ( tech_rocket , side ) = state_researched and ( us_rocket_launcher in list or ar_rocket_launcher in list or ru_rocket_launcher in list ) then
62699: LD_VAR 0 18
62703: NOT
62704: PUSH
62705: LD_INT 40
62707: PPUSH
62708: LD_VAR 0 16
62712: PPUSH
62713: CALL_OW 321
62717: PUSH
62718: LD_INT 2
62720: EQUAL
62721: AND
62722: PUSH
62723: LD_INT 7
62725: PUSH
62726: LD_VAR 0 5
62730: IN
62731: PUSH
62732: LD_INT 28
62734: PUSH
62735: LD_VAR 0 5
62739: IN
62740: OR
62741: PUSH
62742: LD_INT 45
62744: PUSH
62745: LD_VAR 0 5
62749: IN
62750: OR
62751: AND
62752: IFFALSE 63006
// begin hex := GetHexInfo ( x , y ) ;
62754: LD_ADDR_VAR 0 4
62758: PUSH
62759: LD_VAR 0 10
62763: PPUSH
62764: LD_VAR 0 11
62768: PPUSH
62769: CALL_OW 546
62773: ST_TO_ADDR
// if hex [ 1 ] then
62774: LD_VAR 0 4
62778: PUSH
62779: LD_INT 1
62781: ARRAY
62782: IFFALSE 62786
// exit ;
62784: GO 63189
// height := hex [ 2 ] ;
62786: LD_ADDR_VAR 0 15
62790: PUSH
62791: LD_VAR 0 4
62795: PUSH
62796: LD_INT 2
62798: ARRAY
62799: ST_TO_ADDR
// tmp := [ 0 , 2 , 3 , 5 ] ;
62800: LD_ADDR_VAR 0 14
62804: PUSH
62805: LD_INT 0
62807: PUSH
62808: LD_INT 2
62810: PUSH
62811: LD_INT 3
62813: PUSH
62814: LD_INT 5
62816: PUSH
62817: EMPTY
62818: LIST
62819: LIST
62820: LIST
62821: LIST
62822: ST_TO_ADDR
// for i in tmp do
62823: LD_ADDR_VAR 0 8
62827: PUSH
62828: LD_VAR 0 14
62832: PUSH
62833: FOR_IN
62834: IFFALSE 63004
// begin j := [ ShiftX ( x , i , 5 ) , ShiftY ( y , i , 5 ) ] ;
62836: LD_ADDR_VAR 0 9
62840: PUSH
62841: LD_VAR 0 10
62845: PPUSH
62846: LD_VAR 0 8
62850: PPUSH
62851: LD_INT 5
62853: PPUSH
62854: CALL_OW 272
62858: PUSH
62859: LD_VAR 0 11
62863: PPUSH
62864: LD_VAR 0 8
62868: PPUSH
62869: LD_INT 5
62871: PPUSH
62872: CALL_OW 273
62876: PUSH
62877: EMPTY
62878: LIST
62879: LIST
62880: ST_TO_ADDR
// if ValidHex ( j [ 1 ] , j [ 2 ] ) then
62881: LD_VAR 0 9
62885: PUSH
62886: LD_INT 1
62888: ARRAY
62889: PPUSH
62890: LD_VAR 0 9
62894: PUSH
62895: LD_INT 2
62897: ARRAY
62898: PPUSH
62899: CALL_OW 488
62903: IFFALSE 63002
// begin hex := GetHexInfo ( j [ 1 ] , j [ 2 ] ) ;
62905: LD_ADDR_VAR 0 4
62909: PUSH
62910: LD_VAR 0 9
62914: PUSH
62915: LD_INT 1
62917: ARRAY
62918: PPUSH
62919: LD_VAR 0 9
62923: PUSH
62924: LD_INT 2
62926: ARRAY
62927: PPUSH
62928: CALL_OW 546
62932: ST_TO_ADDR
// if hex [ 1 ] then
62933: LD_VAR 0 4
62937: PUSH
62938: LD_INT 1
62940: ARRAY
62941: IFFALSE 62945
// continue ;
62943: GO 62833
// h := hex [ 2 ] ;
62945: LD_ADDR_VAR 0 13
62949: PUSH
62950: LD_VAR 0 4
62954: PUSH
62955: LD_INT 2
62957: ARRAY
62958: ST_TO_ADDR
// if h + 7 < height then
62959: LD_VAR 0 13
62963: PUSH
62964: LD_INT 7
62966: PLUS
62967: PUSH
62968: LD_VAR 0 15
62972: LESS
62973: IFFALSE 63002
// begin weapon := [ us_rocket_launcher , ar_rocket_launcher , ru_rocket_launcher ] [ nat ] ;
62975: LD_ADDR_VAR 0 18
62979: PUSH
62980: LD_INT 7
62982: PUSH
62983: LD_INT 28
62985: PUSH
62986: LD_INT 45
62988: PUSH
62989: EMPTY
62990: LIST
62991: LIST
62992: LIST
62993: PUSH
62994: LD_VAR 0 12
62998: ARRAY
62999: ST_TO_ADDR
// break ;
63000: GO 63004
// end ; end ; end ;
63002: GO 62833
63004: POP
63005: POP
// end ; if not weapon then
63006: LD_VAR 0 18
63010: NOT
63011: IFFALSE 63071
// begin list := list diff [ us_radar , ar_radar , ru_time_lapser ] ;
63013: LD_ADDR_VAR 0 5
63017: PUSH
63018: LD_VAR 0 5
63022: PUSH
63023: LD_INT 11
63025: PUSH
63026: LD_INT 30
63028: PUSH
63029: LD_INT 49
63031: PUSH
63032: EMPTY
63033: LIST
63034: LIST
63035: LIST
63036: DIFF
63037: ST_TO_ADDR
// if not list then
63038: LD_VAR 0 5
63042: NOT
63043: IFFALSE 63047
// exit ;
63045: GO 63189
// weapon := list [ rand ( 1 , list ) ] ;
63047: LD_ADDR_VAR 0 18
63051: PUSH
63052: LD_VAR 0 5
63056: PUSH
63057: LD_INT 1
63059: PPUSH
63060: LD_VAR 0 5
63064: PPUSH
63065: CALL_OW 12
63069: ARRAY
63070: ST_TO_ADDR
// end ; if weapon then
63071: LD_VAR 0 18
63075: IFFALSE 63189
// begin tmp := CostOfWeapon ( weapon ) ;
63077: LD_ADDR_VAR 0 14
63081: PUSH
63082: LD_VAR 0 18
63086: PPUSH
63087: CALL_OW 451
63091: ST_TO_ADDR
// j := GetBase ( tower ) ;
63092: LD_ADDR_VAR 0 9
63096: PUSH
63097: LD_VAR 0 1
63101: PPUSH
63102: CALL_OW 274
63106: ST_TO_ADDR
// if GetResourceType ( j , mat_cans ) >= tmp [ 1 ] and GetResourceType ( j , mat_oil ) >= tmp [ 2 ] and GetResourceType ( j , mat_siberit ) >= tmp [ 3 ] then
63107: LD_VAR 0 9
63111: PPUSH
63112: LD_INT 1
63114: PPUSH
63115: CALL_OW 275
63119: PUSH
63120: LD_VAR 0 14
63124: PUSH
63125: LD_INT 1
63127: ARRAY
63128: GREATEREQUAL
63129: PUSH
63130: LD_VAR 0 9
63134: PPUSH
63135: LD_INT 2
63137: PPUSH
63138: CALL_OW 275
63142: PUSH
63143: LD_VAR 0 14
63147: PUSH
63148: LD_INT 2
63150: ARRAY
63151: GREATEREQUAL
63152: AND
63153: PUSH
63154: LD_VAR 0 9
63158: PPUSH
63159: LD_INT 3
63161: PPUSH
63162: CALL_OW 275
63166: PUSH
63167: LD_VAR 0 14
63171: PUSH
63172: LD_INT 3
63174: ARRAY
63175: GREATEREQUAL
63176: AND
63177: IFFALSE 63189
// result := weapon ;
63179: LD_ADDR_VAR 0 3
63183: PUSH
63184: LD_VAR 0 18
63188: ST_TO_ADDR
// end ; end ;
63189: LD_VAR 0 3
63193: RET
// export function CompareArray ( array1 , array2 ) ; var i ; begin
63194: LD_INT 0
63196: PPUSH
63197: PPUSH
// result := true ;
63198: LD_ADDR_VAR 0 3
63202: PUSH
63203: LD_INT 1
63205: ST_TO_ADDR
// if array1 = array2 then
63206: LD_VAR 0 1
63210: PUSH
63211: LD_VAR 0 2
63215: EQUAL
63216: IFFALSE 63276
// begin for i = 1 to array1 do
63218: LD_ADDR_VAR 0 4
63222: PUSH
63223: DOUBLE
63224: LD_INT 1
63226: DEC
63227: ST_TO_ADDR
63228: LD_VAR 0 1
63232: PUSH
63233: FOR_TO
63234: IFFALSE 63272
// if array1 [ i ] <> array2 [ i ] then
63236: LD_VAR 0 1
63240: PUSH
63241: LD_VAR 0 4
63245: ARRAY
63246: PUSH
63247: LD_VAR 0 2
63251: PUSH
63252: LD_VAR 0 4
63256: ARRAY
63257: NONEQUAL
63258: IFFALSE 63270
// begin result := false ;
63260: LD_ADDR_VAR 0 3
63264: PUSH
63265: LD_INT 0
63267: ST_TO_ADDR
// break ;
63268: GO 63272
// end ;
63270: GO 63233
63272: POP
63273: POP
// end else
63274: GO 63284
// result := false ;
63276: LD_ADDR_VAR 0 3
63280: PUSH
63281: LD_INT 0
63283: ST_TO_ADDR
// end ;
63284: LD_VAR 0 3
63288: RET
// export function CompareArrayValues ( array1 , array2 ) ; var i ; begin
63289: LD_INT 0
63291: PPUSH
63292: PPUSH
// if not array1 or not array2 then
63293: LD_VAR 0 1
63297: NOT
63298: PUSH
63299: LD_VAR 0 2
63303: NOT
63304: OR
63305: IFFALSE 63309
// exit ;
63307: GO 63373
// result := true ;
63309: LD_ADDR_VAR 0 3
63313: PUSH
63314: LD_INT 1
63316: ST_TO_ADDR
// for i = 1 to array1 do
63317: LD_ADDR_VAR 0 4
63321: PUSH
63322: DOUBLE
63323: LD_INT 1
63325: DEC
63326: ST_TO_ADDR
63327: LD_VAR 0 1
63331: PUSH
63332: FOR_TO
63333: IFFALSE 63371
// if array1 [ i ] <> array2 [ i ] then
63335: LD_VAR 0 1
63339: PUSH
63340: LD_VAR 0 4
63344: ARRAY
63345: PUSH
63346: LD_VAR 0 2
63350: PUSH
63351: LD_VAR 0 4
63355: ARRAY
63356: NONEQUAL
63357: IFFALSE 63369
// begin result := false ;
63359: LD_ADDR_VAR 0 3
63363: PUSH
63364: LD_INT 0
63366: ST_TO_ADDR
// break ;
63367: GO 63371
// end ;
63369: GO 63332
63371: POP
63372: POP
// end ;
63373: LD_VAR 0 3
63377: RET
// export function VehicleCost ( fac , list ) ; var cost , pom ; begin
63378: LD_INT 0
63380: PPUSH
63381: PPUSH
63382: PPUSH
// pom := GetBase ( fac ) ;
63383: LD_ADDR_VAR 0 5
63387: PUSH
63388: LD_VAR 0 1
63392: PPUSH
63393: CALL_OW 274
63397: ST_TO_ADDR
// cost := CostOfVehicle ( list [ 1 ] , list [ 2 ] , list [ 3 ] , list [ 4 ] ) ;
63398: LD_ADDR_VAR 0 4
63402: PUSH
63403: LD_VAR 0 2
63407: PUSH
63408: LD_INT 1
63410: ARRAY
63411: PPUSH
63412: LD_VAR 0 2
63416: PUSH
63417: LD_INT 2
63419: ARRAY
63420: PPUSH
63421: LD_VAR 0 2
63425: PUSH
63426: LD_INT 3
63428: ARRAY
63429: PPUSH
63430: LD_VAR 0 2
63434: PUSH
63435: LD_INT 4
63437: ARRAY
63438: PPUSH
63439: CALL_OW 449
63443: ST_TO_ADDR
// result := GetResourceType ( pom , mat_cans ) >= cost [ 1 ] and GetResourceType ( pom , mat_oil ) >= cost [ 2 ] and GetResourceType ( pom , mat_siberit ) >= cost [ 3 ] ;
63444: LD_ADDR_VAR 0 3
63448: PUSH
63449: LD_VAR 0 5
63453: PPUSH
63454: LD_INT 1
63456: PPUSH
63457: CALL_OW 275
63461: PUSH
63462: LD_VAR 0 4
63466: PUSH
63467: LD_INT 1
63469: ARRAY
63470: GREATEREQUAL
63471: PUSH
63472: LD_VAR 0 5
63476: PPUSH
63477: LD_INT 2
63479: PPUSH
63480: CALL_OW 275
63484: PUSH
63485: LD_VAR 0 4
63489: PUSH
63490: LD_INT 2
63492: ARRAY
63493: GREATEREQUAL
63494: AND
63495: PUSH
63496: LD_VAR 0 5
63500: PPUSH
63501: LD_INT 3
63503: PPUSH
63504: CALL_OW 275
63508: PUSH
63509: LD_VAR 0 4
63513: PUSH
63514: LD_INT 3
63516: ARRAY
63517: GREATEREQUAL
63518: AND
63519: ST_TO_ADDR
// end ;
63520: LD_VAR 0 3
63524: RET
// export function UpgradeCost ( building ) ; var pom , cost , btype ; begin
63525: LD_INT 0
63527: PPUSH
63528: PPUSH
63529: PPUSH
63530: PPUSH
// pom := GetBase ( building ) ;
63531: LD_ADDR_VAR 0 3
63535: PUSH
63536: LD_VAR 0 1
63540: PPUSH
63541: CALL_OW 274
63545: ST_TO_ADDR
// if not pom then
63546: LD_VAR 0 3
63550: NOT
63551: IFFALSE 63555
// exit ;
63553: GO 63725
// btype := GetBType ( building ) ;
63555: LD_ADDR_VAR 0 5
63559: PUSH
63560: LD_VAR 0 1
63564: PPUSH
63565: CALL_OW 266
63569: ST_TO_ADDR
// if btype = b_armoury then
63570: LD_VAR 0 5
63574: PUSH
63575: LD_INT 4
63577: EQUAL
63578: IFFALSE 63588
// btype := b_barracks ;
63580: LD_ADDR_VAR 0 5
63584: PUSH
63585: LD_INT 5
63587: ST_TO_ADDR
// if btype = b_depot then
63588: LD_VAR 0 5
63592: PUSH
63593: LD_INT 0
63595: EQUAL
63596: IFFALSE 63606
// btype := b_warehouse ;
63598: LD_ADDR_VAR 0 5
63602: PUSH
63603: LD_INT 1
63605: ST_TO_ADDR
// if btype = b_workshop then
63606: LD_VAR 0 5
63610: PUSH
63611: LD_INT 2
63613: EQUAL
63614: IFFALSE 63624
// btype := b_factory ;
63616: LD_ADDR_VAR 0 5
63620: PUSH
63621: LD_INT 3
63623: ST_TO_ADDR
// cost := CostOfBuilding ( btype , GetNation ( building ) ) ;
63624: LD_ADDR_VAR 0 4
63628: PUSH
63629: LD_VAR 0 5
63633: PPUSH
63634: LD_VAR 0 1
63638: PPUSH
63639: CALL_OW 248
63643: PPUSH
63644: CALL_OW 450
63648: ST_TO_ADDR
// result := GetResourceType ( pom , mat_cans ) >= cost [ 1 ] and GetResourceType ( pom , mat_oil ) >= cost [ 2 ] and GetResourceType ( pom , mat_siberit ) >= cost [ 3 ] ;
63649: LD_ADDR_VAR 0 2
63653: PUSH
63654: LD_VAR 0 3
63658: PPUSH
63659: LD_INT 1
63661: PPUSH
63662: CALL_OW 275
63666: PUSH
63667: LD_VAR 0 4
63671: PUSH
63672: LD_INT 1
63674: ARRAY
63675: GREATEREQUAL
63676: PUSH
63677: LD_VAR 0 3
63681: PPUSH
63682: LD_INT 2
63684: PPUSH
63685: CALL_OW 275
63689: PUSH
63690: LD_VAR 0 4
63694: PUSH
63695: LD_INT 2
63697: ARRAY
63698: GREATEREQUAL
63699: AND
63700: PUSH
63701: LD_VAR 0 3
63705: PPUSH
63706: LD_INT 3
63708: PPUSH
63709: CALL_OW 275
63713: PUSH
63714: LD_VAR 0 4
63718: PUSH
63719: LD_INT 3
63721: ARRAY
63722: GREATEREQUAL
63723: AND
63724: ST_TO_ADDR
// end ;
63725: LD_VAR 0 2
63729: RET
// export function UpgradeLabCost ( building , btype ) ; var pom , cost ; begin
63730: LD_INT 0
63732: PPUSH
63733: PPUSH
63734: PPUSH
// pom := GetBase ( building ) ;
63735: LD_ADDR_VAR 0 4
63739: PUSH
63740: LD_VAR 0 1
63744: PPUSH
63745: CALL_OW 274
63749: ST_TO_ADDR
// if not pom then
63750: LD_VAR 0 4
63754: NOT
63755: IFFALSE 63759
// exit ;
63757: GO 63860
// cost := CostOfBuilding ( btype , GetNation ( building ) ) ;
63759: LD_ADDR_VAR 0 5
63763: PUSH
63764: LD_VAR 0 2
63768: PPUSH
63769: LD_VAR 0 1
63773: PPUSH
63774: CALL_OW 248
63778: PPUSH
63779: CALL_OW 450
63783: ST_TO_ADDR
// result := GetResourceType ( pom , mat_cans ) >= cost [ 1 ] and GetResourceType ( pom , mat_oil ) >= cost [ 2 ] and GetResourceType ( pom , mat_siberit ) >= cost [ 3 ] ;
63784: LD_ADDR_VAR 0 3
63788: PUSH
63789: LD_VAR 0 4
63793: PPUSH
63794: LD_INT 1
63796: PPUSH
63797: CALL_OW 275
63801: PUSH
63802: LD_VAR 0 5
63806: PUSH
63807: LD_INT 1
63809: ARRAY
63810: GREATEREQUAL
63811: PUSH
63812: LD_VAR 0 4
63816: PPUSH
63817: LD_INT 2
63819: PPUSH
63820: CALL_OW 275
63824: PUSH
63825: LD_VAR 0 5
63829: PUSH
63830: LD_INT 2
63832: ARRAY
63833: GREATEREQUAL
63834: AND
63835: PUSH
63836: LD_VAR 0 4
63840: PPUSH
63841: LD_INT 3
63843: PPUSH
63844: CALL_OW 275
63848: PUSH
63849: LD_VAR 0 5
63853: PUSH
63854: LD_INT 3
63856: ARRAY
63857: GREATEREQUAL
63858: AND
63859: ST_TO_ADDR
// end ;
63860: LD_VAR 0 3
63864: RET
// export function TryClearPlaceForBuilding ( btype , x , y , d , buildings , cleaners , parking ) ; var i , j , _x , _y , tmp , hexes , r , xy , dep , driver ; begin
63865: LD_INT 0
63867: PPUSH
63868: PPUSH
63869: PPUSH
63870: PPUSH
63871: PPUSH
63872: PPUSH
63873: PPUSH
63874: PPUSH
63875: PPUSH
63876: PPUSH
63877: PPUSH
// result := false ;
63878: LD_ADDR_VAR 0 8
63882: PUSH
63883: LD_INT 0
63885: ST_TO_ADDR
// if not buildings or not btype or not x or not y then
63886: LD_VAR 0 5
63890: NOT
63891: PUSH
63892: LD_VAR 0 1
63896: NOT
63897: OR
63898: PUSH
63899: LD_VAR 0 2
63903: NOT
63904: OR
63905: PUSH
63906: LD_VAR 0 3
63910: NOT
63911: OR
63912: IFFALSE 63916
// exit ;
63914: GO 64730
// hexes := GetBuildingHexes ( btype , x , y , d , GetNation ( buildings [ 1 ] ) , 0 ) ;
63916: LD_ADDR_VAR 0 14
63920: PUSH
63921: LD_VAR 0 1
63925: PPUSH
63926: LD_VAR 0 2
63930: PPUSH
63931: LD_VAR 0 3
63935: PPUSH
63936: LD_VAR 0 4
63940: PPUSH
63941: LD_VAR 0 5
63945: PUSH
63946: LD_INT 1
63948: ARRAY
63949: PPUSH
63950: CALL_OW 248
63954: PPUSH
63955: LD_INT 0
63957: PPUSH
63958: CALL 65967 0 6
63962: ST_TO_ADDR
// if not hexes then
63963: LD_VAR 0 14
63967: NOT
63968: IFFALSE 63972
// exit ;
63970: GO 64730
// dep := UnitFilter ( buildings , [ [ f_side , GetSide ( tmp ) ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ] ) ;
63972: LD_ADDR_VAR 0 17
63976: PUSH
63977: LD_VAR 0 5
63981: PPUSH
63982: LD_INT 22
63984: PUSH
63985: LD_VAR 0 13
63989: PPUSH
63990: CALL_OW 255
63994: PUSH
63995: EMPTY
63996: LIST
63997: LIST
63998: PUSH
63999: LD_INT 2
64001: PUSH
64002: LD_INT 30
64004: PUSH
64005: LD_INT 0
64007: PUSH
64008: EMPTY
64009: LIST
64010: LIST
64011: PUSH
64012: LD_INT 30
64014: PUSH
64015: LD_INT 1
64017: PUSH
64018: EMPTY
64019: LIST
64020: LIST
64021: PUSH
64022: EMPTY
64023: LIST
64024: LIST
64025: LIST
64026: PUSH
64027: EMPTY
64028: LIST
64029: LIST
64030: PPUSH
64031: CALL_OW 72
64035: ST_TO_ADDR
// for i = 1 to hexes do
64036: LD_ADDR_VAR 0 9
64040: PUSH
64041: DOUBLE
64042: LD_INT 1
64044: DEC
64045: ST_TO_ADDR
64046: LD_VAR 0 14
64050: PUSH
64051: FOR_TO
64052: IFFALSE 64728
// begin tmp := HexInfo ( hexes [ i ] [ 1 ] , hexes [ i ] [ 2 ] ) ;
64054: LD_ADDR_VAR 0 13
64058: PUSH
64059: LD_VAR 0 14
64063: PUSH
64064: LD_VAR 0 9
64068: ARRAY
64069: PUSH
64070: LD_INT 1
64072: ARRAY
64073: PPUSH
64074: LD_VAR 0 14
64078: PUSH
64079: LD_VAR 0 9
64083: ARRAY
64084: PUSH
64085: LD_INT 2
64087: ARRAY
64088: PPUSH
64089: CALL_OW 428
64093: ST_TO_ADDR
// if IsEnvironment ( hexes [ i ] [ 1 ] , hexes [ i ] [ 2 ] ) or not ValidHex ( hexes [ i ] [ 1 ] , hexes [ i ] [ 2 ] ) or GetType ( tmp ) = unit_building then
64094: LD_VAR 0 14
64098: PUSH
64099: LD_VAR 0 9
64103: ARRAY
64104: PUSH
64105: LD_INT 1
64107: ARRAY
64108: PPUSH
64109: LD_VAR 0 14
64113: PUSH
64114: LD_VAR 0 9
64118: ARRAY
64119: PUSH
64120: LD_INT 2
64122: ARRAY
64123: PPUSH
64124: CALL_OW 351
64128: PUSH
64129: LD_VAR 0 14
64133: PUSH
64134: LD_VAR 0 9
64138: ARRAY
64139: PUSH
64140: LD_INT 1
64142: ARRAY
64143: PPUSH
64144: LD_VAR 0 14
64148: PUSH
64149: LD_VAR 0 9
64153: ARRAY
64154: PUSH
64155: LD_INT 2
64157: ARRAY
64158: PPUSH
64159: CALL_OW 488
64163: NOT
64164: OR
64165: PUSH
64166: LD_VAR 0 13
64170: PPUSH
64171: CALL_OW 247
64175: PUSH
64176: LD_INT 3
64178: EQUAL
64179: OR
64180: IFFALSE 64186
// exit ;
64182: POP
64183: POP
64184: GO 64730
// if not tmp then
64186: LD_VAR 0 13
64190: NOT
64191: IFFALSE 64195
// continue ;
64193: GO 64051
// result := true ;
64195: LD_ADDR_VAR 0 8
64199: PUSH
64200: LD_INT 1
64202: ST_TO_ADDR
// if cleaners and GetType ( tmp ) = unit_vehicle and GetControl ( tmp ) = control_manual then
64203: LD_VAR 0 6
64207: PUSH
64208: LD_VAR 0 13
64212: PPUSH
64213: CALL_OW 247
64217: PUSH
64218: LD_INT 2
64220: EQUAL
64221: AND
64222: PUSH
64223: LD_VAR 0 13
64227: PPUSH
64228: CALL_OW 263
64232: PUSH
64233: LD_INT 1
64235: EQUAL
64236: AND
64237: IFFALSE 64401
// begin if IsDrivenBy ( tmp ) then
64239: LD_VAR 0 13
64243: PPUSH
64244: CALL_OW 311
64248: IFFALSE 64252
// continue ;
64250: GO 64051
// if UnitFilter ( cleaners , [ [ f_not , [ f_hastask ] ] , [ f_not , [ f_driving ] ] ] ) then
64252: LD_VAR 0 6
64256: PPUSH
64257: LD_INT 3
64259: PUSH
64260: LD_INT 60
64262: PUSH
64263: EMPTY
64264: LIST
64265: PUSH
64266: EMPTY
64267: LIST
64268: LIST
64269: PUSH
64270: LD_INT 3
64272: PUSH
64273: LD_INT 55
64275: PUSH
64276: EMPTY
64277: LIST
64278: PUSH
64279: EMPTY
64280: LIST
64281: LIST
64282: PUSH
64283: EMPTY
64284: LIST
64285: LIST
64286: PPUSH
64287: CALL_OW 72
64291: IFFALSE 64399
// begin driver := UnitFilter ( cleaners , [ [ f_not , [ f_hastask ] ] , [ f_not , [ f_driving ] ] ] ) [ 1 ] ;
64293: LD_ADDR_VAR 0 18
64297: PUSH
64298: LD_VAR 0 6
64302: PPUSH
64303: LD_INT 3
64305: PUSH
64306: LD_INT 60
64308: PUSH
64309: EMPTY
64310: LIST
64311: PUSH
64312: EMPTY
64313: LIST
64314: LIST
64315: PUSH
64316: LD_INT 3
64318: PUSH
64319: LD_INT 55
64321: PUSH
64322: EMPTY
64323: LIST
64324: PUSH
64325: EMPTY
64326: LIST
64327: LIST
64328: PUSH
64329: EMPTY
64330: LIST
64331: LIST
64332: PPUSH
64333: CALL_OW 72
64337: PUSH
64338: LD_INT 1
64340: ARRAY
64341: ST_TO_ADDR
// if IsInUnit ( driver ) then
64342: LD_VAR 0 18
64346: PPUSH
64347: CALL_OW 310
64351: IFFALSE 64362
// ComExit ( driver ) ;
64353: LD_VAR 0 18
64357: PPUSH
64358: CALL 89151 0 1
// AddComEnterUnit ( driver , tmp ) ;
64362: LD_VAR 0 18
64366: PPUSH
64367: LD_VAR 0 13
64371: PPUSH
64372: CALL_OW 180
// AddComMoveToArea ( driver , parking ) ;
64376: LD_VAR 0 18
64380: PPUSH
64381: LD_VAR 0 7
64385: PPUSH
64386: CALL_OW 173
// AddComExitVehicle ( driver ) ;
64390: LD_VAR 0 18
64394: PPUSH
64395: CALL_OW 181
// end ; continue ;
64399: GO 64051
// end ; if not cleaners or not tmp in cleaners then
64401: LD_VAR 0 6
64405: NOT
64406: PUSH
64407: LD_VAR 0 13
64411: PUSH
64412: LD_VAR 0 6
64416: IN
64417: NOT
64418: OR
64419: IFFALSE 64726
// begin if dep then
64421: LD_VAR 0 17
64425: IFFALSE 64561
// begin xy := [ ShiftX ( GetX ( dep [ 1 ] ) , GetDir ( dep [ 1 ] ) , 5 ) , ShiftY ( GetY ( dep [ 1 ] ) , GetDir ( dep [ 1 ] ) , 5 ) ] ;
64427: LD_ADDR_VAR 0 16
64431: PUSH
64432: LD_VAR 0 17
64436: PUSH
64437: LD_INT 1
64439: ARRAY
64440: PPUSH
64441: CALL_OW 250
64445: PPUSH
64446: LD_VAR 0 17
64450: PUSH
64451: LD_INT 1
64453: ARRAY
64454: PPUSH
64455: CALL_OW 254
64459: PPUSH
64460: LD_INT 5
64462: PPUSH
64463: CALL_OW 272
64467: PUSH
64468: LD_VAR 0 17
64472: PUSH
64473: LD_INT 1
64475: ARRAY
64476: PPUSH
64477: CALL_OW 251
64481: PPUSH
64482: LD_VAR 0 17
64486: PUSH
64487: LD_INT 1
64489: ARRAY
64490: PPUSH
64491: CALL_OW 254
64495: PPUSH
64496: LD_INT 5
64498: PPUSH
64499: CALL_OW 273
64503: PUSH
64504: EMPTY
64505: LIST
64506: LIST
64507: ST_TO_ADDR
// if ValidHex ( xy [ 1 ] , xy [ 2 ] ) then
64508: LD_VAR 0 16
64512: PUSH
64513: LD_INT 1
64515: ARRAY
64516: PPUSH
64517: LD_VAR 0 16
64521: PUSH
64522: LD_INT 2
64524: ARRAY
64525: PPUSH
64526: CALL_OW 488
64530: IFFALSE 64561
// begin ComMoveXY ( tmp , xy [ 1 ] , xy [ 2 ] ) ;
64532: LD_VAR 0 13
64536: PPUSH
64537: LD_VAR 0 16
64541: PUSH
64542: LD_INT 1
64544: ARRAY
64545: PPUSH
64546: LD_VAR 0 16
64550: PUSH
64551: LD_INT 2
64553: ARRAY
64554: PPUSH
64555: CALL_OW 111
// continue ;
64559: GO 64051
// end ; end ; r := GetDir ( tmp ) ;
64561: LD_ADDR_VAR 0 15
64565: PUSH
64566: LD_VAR 0 13
64570: PPUSH
64571: CALL_OW 254
64575: ST_TO_ADDR
// if r = 5 then
64576: LD_VAR 0 15
64580: PUSH
64581: LD_INT 5
64583: EQUAL
64584: IFFALSE 64594
// r := 0 ;
64586: LD_ADDR_VAR 0 15
64590: PUSH
64591: LD_INT 0
64593: ST_TO_ADDR
// for j = r to 5 do
64594: LD_ADDR_VAR 0 10
64598: PUSH
64599: DOUBLE
64600: LD_VAR 0 15
64604: DEC
64605: ST_TO_ADDR
64606: LD_INT 5
64608: PUSH
64609: FOR_TO
64610: IFFALSE 64724
// begin _x := ShiftX ( GetX ( tmp ) , j , 2 ) ;
64612: LD_ADDR_VAR 0 11
64616: PUSH
64617: LD_VAR 0 13
64621: PPUSH
64622: CALL_OW 250
64626: PPUSH
64627: LD_VAR 0 10
64631: PPUSH
64632: LD_INT 2
64634: PPUSH
64635: CALL_OW 272
64639: ST_TO_ADDR
// _y := ShiftY ( GetY ( tmp ) , j , 2 ) ;
64640: LD_ADDR_VAR 0 12
64644: PUSH
64645: LD_VAR 0 13
64649: PPUSH
64650: CALL_OW 251
64654: PPUSH
64655: LD_VAR 0 10
64659: PPUSH
64660: LD_INT 2
64662: PPUSH
64663: CALL_OW 273
64667: ST_TO_ADDR
// if ValidHex ( _x , _y ) and not HexInfo ( _x , _y ) then
64668: LD_VAR 0 11
64672: PPUSH
64673: LD_VAR 0 12
64677: PPUSH
64678: CALL_OW 488
64682: PUSH
64683: LD_VAR 0 11
64687: PPUSH
64688: LD_VAR 0 12
64692: PPUSH
64693: CALL_OW 428
64697: NOT
64698: AND
64699: IFFALSE 64722
// begin ComMoveXY ( tmp , _x , _y ) ;
64701: LD_VAR 0 13
64705: PPUSH
64706: LD_VAR 0 11
64710: PPUSH
64711: LD_VAR 0 12
64715: PPUSH
64716: CALL_OW 111
// break ;
64720: GO 64724
// end ; end ;
64722: GO 64609
64724: POP
64725: POP
// end ; end ;
64726: GO 64051
64728: POP
64729: POP
// end ;
64730: LD_VAR 0 8
64734: RET
// export function BuildingTechInvented ( side , btype ) ; begin
64735: LD_INT 0
64737: PPUSH
// result := true ;
64738: LD_ADDR_VAR 0 3
64742: PUSH
64743: LD_INT 1
64745: ST_TO_ADDR
// case btype of b_ext_computer , b_turret :
64746: LD_VAR 0 2
64750: PUSH
64751: LD_INT 24
64753: DOUBLE
64754: EQUAL
64755: IFTRUE 64765
64757: LD_INT 33
64759: DOUBLE
64760: EQUAL
64761: IFTRUE 64765
64763: GO 64790
64765: POP
// result := ( GetTech ( tech_ai , side ) = state_researched ) ; b_ext_radar :
64766: LD_ADDR_VAR 0 3
64770: PUSH
64771: LD_INT 32
64773: PPUSH
64774: LD_VAR 0 1
64778: PPUSH
64779: CALL_OW 321
64783: PUSH
64784: LD_INT 2
64786: EQUAL
64787: ST_TO_ADDR
64788: GO 65110
64790: LD_INT 20
64792: DOUBLE
64793: EQUAL
64794: IFTRUE 64798
64796: GO 64823
64798: POP
// result := ( GetTech ( tech_radar , side ) = state_researched ) ; b_ext_radio , b_control_tower :
64799: LD_ADDR_VAR 0 3
64803: PUSH
64804: LD_INT 6
64806: PPUSH
64807: LD_VAR 0 1
64811: PPUSH
64812: CALL_OW 321
64816: PUSH
64817: LD_INT 2
64819: EQUAL
64820: ST_TO_ADDR
64821: GO 65110
64823: LD_INT 22
64825: DOUBLE
64826: EQUAL
64827: IFTRUE 64837
64829: LD_INT 36
64831: DOUBLE
64832: EQUAL
64833: IFTRUE 64837
64835: GO 64862
64837: POP
// result := ( GetTech ( tech_remcont , side ) = state_researched ) ; b_siberite_mine :
64838: LD_ADDR_VAR 0 3
64842: PUSH
64843: LD_INT 15
64845: PPUSH
64846: LD_VAR 0 1
64850: PPUSH
64851: CALL_OW 321
64855: PUSH
64856: LD_INT 2
64858: EQUAL
64859: ST_TO_ADDR
64860: GO 65110
64862: LD_INT 30
64864: DOUBLE
64865: EQUAL
64866: IFTRUE 64870
64868: GO 64895
64870: POP
// result := ( GetTech ( tech_sibdet , side ) = state_researched ) ; b_siberite_power , b_ext_siberium :
64871: LD_ADDR_VAR 0 3
64875: PUSH
64876: LD_INT 20
64878: PPUSH
64879: LD_VAR 0 1
64883: PPUSH
64884: CALL_OW 321
64888: PUSH
64889: LD_INT 2
64891: EQUAL
64892: ST_TO_ADDR
64893: GO 65110
64895: LD_INT 28
64897: DOUBLE
64898: EQUAL
64899: IFTRUE 64909
64901: LD_INT 21
64903: DOUBLE
64904: EQUAL
64905: IFTRUE 64909
64907: GO 64934
64909: POP
// result := ( GetTech ( tech_sibpow , side ) = state_researched ) ; b_ext_track :
64910: LD_ADDR_VAR 0 3
64914: PUSH
64915: LD_INT 21
64917: PPUSH
64918: LD_VAR 0 1
64922: PPUSH
64923: CALL_OW 321
64927: PUSH
64928: LD_INT 2
64930: EQUAL
64931: ST_TO_ADDR
64932: GO 65110
64934: LD_INT 16
64936: DOUBLE
64937: EQUAL
64938: IFTRUE 64942
64940: GO 64969
64942: POP
// result := ( GetTech ( tech_track , side ) = state_researched ) ; b_ext_noncombat , b_ext_stitch :
64943: LD_ADDR_VAR 0 3
64947: PUSH
64948: LD_EXP 86
64952: PPUSH
64953: LD_VAR 0 1
64957: PPUSH
64958: CALL_OW 321
64962: PUSH
64963: LD_INT 2
64965: EQUAL
64966: ST_TO_ADDR
64967: GO 65110
64969: LD_INT 19
64971: DOUBLE
64972: EQUAL
64973: IFTRUE 64983
64975: LD_INT 23
64977: DOUBLE
64978: EQUAL
64979: IFTRUE 64983
64981: GO 65010
64983: POP
// result := ( GetTech ( tech_cargo , side ) = state_researched ) ; b_ext_gun :
64984: LD_ADDR_VAR 0 3
64988: PUSH
64989: LD_EXP 85
64993: PPUSH
64994: LD_VAR 0 1
64998: PPUSH
64999: CALL_OW 321
65003: PUSH
65004: LD_INT 2
65006: EQUAL
65007: ST_TO_ADDR
65008: GO 65110
65010: LD_INT 17
65012: DOUBLE
65013: EQUAL
65014: IFTRUE 65018
65016: GO 65043
65018: POP
// result := ( GetTech ( tech_gun , side ) = state_researched ) ; b_ext_rocket :
65019: LD_ADDR_VAR 0 3
65023: PUSH
65024: LD_INT 39
65026: PPUSH
65027: LD_VAR 0 1
65031: PPUSH
65032: CALL_OW 321
65036: PUSH
65037: LD_INT 2
65039: EQUAL
65040: ST_TO_ADDR
65041: GO 65110
65043: LD_INT 18
65045: DOUBLE
65046: EQUAL
65047: IFTRUE 65051
65049: GO 65076
65051: POP
// result := ( GetTech ( tech_rocket , side ) = state_researched ) ; b_solar_power :
65052: LD_ADDR_VAR 0 3
65056: PUSH
65057: LD_INT 40
65059: PPUSH
65060: LD_VAR 0 1
65064: PPUSH
65065: CALL_OW 321
65069: PUSH
65070: LD_INT 2
65072: EQUAL
65073: ST_TO_ADDR
65074: GO 65110
65076: LD_INT 27
65078: DOUBLE
65079: EQUAL
65080: IFTRUE 65084
65082: GO 65109
65084: POP
// result := ( GetTech ( tech_solpow , side ) = state_researched ) ; end ;
65085: LD_ADDR_VAR 0 3
65089: PUSH
65090: LD_INT 35
65092: PPUSH
65093: LD_VAR 0 1
65097: PPUSH
65098: CALL_OW 321
65102: PUSH
65103: LD_INT 2
65105: EQUAL
65106: ST_TO_ADDR
65107: GO 65110
65109: POP
// end ;
65110: LD_VAR 0 3
65114: RET
// export function CanBeBuilt ( depot , btype , x , y , d ) ; var i , j , side , pom , cost , hexes , height , dist , hex , tech ; begin
65115: LD_INT 0
65117: PPUSH
65118: PPUSH
65119: PPUSH
65120: PPUSH
65121: PPUSH
65122: PPUSH
65123: PPUSH
65124: PPUSH
65125: PPUSH
65126: PPUSH
65127: PPUSH
// result := false ;
65128: LD_ADDR_VAR 0 6
65132: PUSH
65133: LD_INT 0
65135: ST_TO_ADDR
// if not depot or not GetBType ( depot ) in [ b_depot , b_warehouse ] or not btype or not d in [ 0 , 1 , 2 , 3 , 4 , 5 ] or not ValidHex ( x , y ) then
65136: LD_VAR 0 1
65140: NOT
65141: PUSH
65142: LD_VAR 0 1
65146: PPUSH
65147: CALL_OW 266
65151: PUSH
65152: LD_INT 0
65154: PUSH
65155: LD_INT 1
65157: PUSH
65158: EMPTY
65159: LIST
65160: LIST
65161: IN
65162: NOT
65163: OR
65164: PUSH
65165: LD_VAR 0 2
65169: NOT
65170: OR
65171: PUSH
65172: LD_VAR 0 5
65176: PUSH
65177: LD_INT 0
65179: PUSH
65180: LD_INT 1
65182: PUSH
65183: LD_INT 2
65185: PUSH
65186: LD_INT 3
65188: PUSH
65189: LD_INT 4
65191: PUSH
65192: LD_INT 5
65194: PUSH
65195: EMPTY
65196: LIST
65197: LIST
65198: LIST
65199: LIST
65200: LIST
65201: LIST
65202: IN
65203: NOT
65204: OR
65205: PUSH
65206: LD_VAR 0 3
65210: PPUSH
65211: LD_VAR 0 4
65215: PPUSH
65216: CALL_OW 488
65220: NOT
65221: OR
65222: IFFALSE 65226
// exit ;
65224: GO 65962
// side := GetSide ( depot ) ;
65226: LD_ADDR_VAR 0 9
65230: PUSH
65231: LD_VAR 0 1
65235: PPUSH
65236: CALL_OW 255
65240: ST_TO_ADDR
// if not BuildingTechInvented ( side , btype ) then
65241: LD_VAR 0 9
65245: PPUSH
65246: LD_VAR 0 2
65250: PPUSH
65251: CALL 64735 0 2
65255: NOT
65256: IFFALSE 65260
// exit ;
65258: GO 65962
// pom := GetBase ( depot ) ;
65260: LD_ADDR_VAR 0 10
65264: PUSH
65265: LD_VAR 0 1
65269: PPUSH
65270: CALL_OW 274
65274: ST_TO_ADDR
// cost := CostOfBuilding ( btype , GetNation ( depot ) ) ;
65275: LD_ADDR_VAR 0 11
65279: PUSH
65280: LD_VAR 0 2
65284: PPUSH
65285: LD_VAR 0 1
65289: PPUSH
65290: CALL_OW 248
65294: PPUSH
65295: CALL_OW 450
65299: ST_TO_ADDR
// if not ( GetResourceType ( pom , mat_cans ) >= cost [ 1 ] and GetResourceType ( pom , mat_oil ) >= cost [ 2 ] and GetResourceType ( pom , mat_siberit ) >= cost [ 3 ] ) then
65300: LD_VAR 0 10
65304: PPUSH
65305: LD_INT 1
65307: PPUSH
65308: CALL_OW 275
65312: PUSH
65313: LD_VAR 0 11
65317: PUSH
65318: LD_INT 1
65320: ARRAY
65321: GREATEREQUAL
65322: PUSH
65323: LD_VAR 0 10
65327: PPUSH
65328: LD_INT 2
65330: PPUSH
65331: CALL_OW 275
65335: PUSH
65336: LD_VAR 0 11
65340: PUSH
65341: LD_INT 2
65343: ARRAY
65344: GREATEREQUAL
65345: AND
65346: PUSH
65347: LD_VAR 0 10
65351: PPUSH
65352: LD_INT 3
65354: PPUSH
65355: CALL_OW 275
65359: PUSH
65360: LD_VAR 0 11
65364: PUSH
65365: LD_INT 3
65367: ARRAY
65368: GREATEREQUAL
65369: AND
65370: NOT
65371: IFFALSE 65375
// exit ;
65373: GO 65962
// if GetBType ( depot ) = b_depot then
65375: LD_VAR 0 1
65379: PPUSH
65380: CALL_OW 266
65384: PUSH
65385: LD_INT 0
65387: EQUAL
65388: IFFALSE 65400
// dist := 28 else
65390: LD_ADDR_VAR 0 14
65394: PUSH
65395: LD_INT 28
65397: ST_TO_ADDR
65398: GO 65408
// dist := 36 ;
65400: LD_ADDR_VAR 0 14
65404: PUSH
65405: LD_INT 36
65407: ST_TO_ADDR
// if GetDistUnitXY ( depot , x , y ) > dist then
65408: LD_VAR 0 1
65412: PPUSH
65413: LD_VAR 0 3
65417: PPUSH
65418: LD_VAR 0 4
65422: PPUSH
65423: CALL_OW 297
65427: PUSH
65428: LD_VAR 0 14
65432: GREATER
65433: IFFALSE 65437
// exit ;
65435: GO 65962
// hexes := GetBuildingHexes ( btype , x , y , d , GetNation ( depot ) , 0 ) ;
65437: LD_ADDR_VAR 0 12
65441: PUSH
65442: LD_VAR 0 2
65446: PPUSH
65447: LD_VAR 0 3
65451: PPUSH
65452: LD_VAR 0 4
65456: PPUSH
65457: LD_VAR 0 5
65461: PPUSH
65462: LD_VAR 0 1
65466: PPUSH
65467: CALL_OW 248
65471: PPUSH
65472: LD_INT 0
65474: PPUSH
65475: CALL 65967 0 6
65479: ST_TO_ADDR
// if not hexes then
65480: LD_VAR 0 12
65484: NOT
65485: IFFALSE 65489
// exit ;
65487: GO 65962
// hex := GetHexInfo ( x , y ) ;
65489: LD_ADDR_VAR 0 15
65493: PUSH
65494: LD_VAR 0 3
65498: PPUSH
65499: LD_VAR 0 4
65503: PPUSH
65504: CALL_OW 546
65508: ST_TO_ADDR
// if hex [ 1 ] then
65509: LD_VAR 0 15
65513: PUSH
65514: LD_INT 1
65516: ARRAY
65517: IFFALSE 65521
// exit ;
65519: GO 65962
// height := hex [ 2 ] ;
65521: LD_ADDR_VAR 0 13
65525: PUSH
65526: LD_VAR 0 15
65530: PUSH
65531: LD_INT 2
65533: ARRAY
65534: ST_TO_ADDR
// for i = 1 to hexes do
65535: LD_ADDR_VAR 0 7
65539: PUSH
65540: DOUBLE
65541: LD_INT 1
65543: DEC
65544: ST_TO_ADDR
65545: LD_VAR 0 12
65549: PUSH
65550: FOR_TO
65551: IFFALSE 65881
// begin if not ValidHex ( hexes [ i ] [ 1 ] , hexes [ i ] [ 2 ] ) or HexInfo ( hexes [ i ] [ 1 ] , hexes [ i ] [ 2 ] ) > 0 or IsEnvironment ( hexes [ i ] [ 1 ] , hexes [ i ] [ 2 ] ) then
65553: LD_VAR 0 12
65557: PUSH
65558: LD_VAR 0 7
65562: ARRAY
65563: PUSH
65564: LD_INT 1
65566: ARRAY
65567: PPUSH
65568: LD_VAR 0 12
65572: PUSH
65573: LD_VAR 0 7
65577: ARRAY
65578: PUSH
65579: LD_INT 2
65581: ARRAY
65582: PPUSH
65583: CALL_OW 488
65587: NOT
65588: PUSH
65589: LD_VAR 0 12
65593: PUSH
65594: LD_VAR 0 7
65598: ARRAY
65599: PUSH
65600: LD_INT 1
65602: ARRAY
65603: PPUSH
65604: LD_VAR 0 12
65608: PUSH
65609: LD_VAR 0 7
65613: ARRAY
65614: PUSH
65615: LD_INT 2
65617: ARRAY
65618: PPUSH
65619: CALL_OW 428
65623: PUSH
65624: LD_INT 0
65626: GREATER
65627: OR
65628: PUSH
65629: LD_VAR 0 12
65633: PUSH
65634: LD_VAR 0 7
65638: ARRAY
65639: PUSH
65640: LD_INT 1
65642: ARRAY
65643: PPUSH
65644: LD_VAR 0 12
65648: PUSH
65649: LD_VAR 0 7
65653: ARRAY
65654: PUSH
65655: LD_INT 2
65657: ARRAY
65658: PPUSH
65659: CALL_OW 351
65663: OR
65664: IFFALSE 65670
// exit ;
65666: POP
65667: POP
65668: GO 65962
// j := GetHexInfo ( hexes [ i ] [ 1 ] , hexes [ i ] [ 2 ] ) ;
65670: LD_ADDR_VAR 0 8
65674: PUSH
65675: LD_VAR 0 12
65679: PUSH
65680: LD_VAR 0 7
65684: ARRAY
65685: PUSH
65686: LD_INT 1
65688: ARRAY
65689: PPUSH
65690: LD_VAR 0 12
65694: PUSH
65695: LD_VAR 0 7
65699: ARRAY
65700: PUSH
65701: LD_INT 2
65703: ARRAY
65704: PPUSH
65705: CALL_OW 546
65709: ST_TO_ADDR
// if j [ 1 ] or j [ 2 ] > height + 2 or j [ 2 ] < height - 2 or not j [ 3 ] in [ 0 , 8 , 9 , 10 , 11 , 12 , 13 , 16 , 17 , 18 , 19 , 20 , 21 ] or not j [ 5 ] or not j [ 6 ] in [ 1 , 2 , 7 , 9 , 10 , 11 ] then
65710: LD_VAR 0 8
65714: PUSH
65715: LD_INT 1
65717: ARRAY
65718: PUSH
65719: LD_VAR 0 8
65723: PUSH
65724: LD_INT 2
65726: ARRAY
65727: PUSH
65728: LD_VAR 0 13
65732: PUSH
65733: LD_INT 2
65735: PLUS
65736: GREATER
65737: OR
65738: PUSH
65739: LD_VAR 0 8
65743: PUSH
65744: LD_INT 2
65746: ARRAY
65747: PUSH
65748: LD_VAR 0 13
65752: PUSH
65753: LD_INT 2
65755: MINUS
65756: LESS
65757: OR
65758: PUSH
65759: LD_VAR 0 8
65763: PUSH
65764: LD_INT 3
65766: ARRAY
65767: PUSH
65768: LD_INT 0
65770: PUSH
65771: LD_INT 8
65773: PUSH
65774: LD_INT 9
65776: PUSH
65777: LD_INT 10
65779: PUSH
65780: LD_INT 11
65782: PUSH
65783: LD_INT 12
65785: PUSH
65786: LD_INT 13
65788: PUSH
65789: LD_INT 16
65791: PUSH
65792: LD_INT 17
65794: PUSH
65795: LD_INT 18
65797: PUSH
65798: LD_INT 19
65800: PUSH
65801: LD_INT 20
65803: PUSH
65804: LD_INT 21
65806: PUSH
65807: EMPTY
65808: LIST
65809: LIST
65810: LIST
65811: LIST
65812: LIST
65813: LIST
65814: LIST
65815: LIST
65816: LIST
65817: LIST
65818: LIST
65819: LIST
65820: LIST
65821: IN
65822: NOT
65823: OR
65824: PUSH
65825: LD_VAR 0 8
65829: PUSH
65830: LD_INT 5
65832: ARRAY
65833: NOT
65834: OR
65835: PUSH
65836: LD_VAR 0 8
65840: PUSH
65841: LD_INT 6
65843: ARRAY
65844: PUSH
65845: LD_INT 1
65847: PUSH
65848: LD_INT 2
65850: PUSH
65851: LD_INT 7
65853: PUSH
65854: LD_INT 9
65856: PUSH
65857: LD_INT 10
65859: PUSH
65860: LD_INT 11
65862: PUSH
65863: EMPTY
65864: LIST
65865: LIST
65866: LIST
65867: LIST
65868: LIST
65869: LIST
65870: IN
65871: NOT
65872: OR
65873: IFFALSE 65879
// exit ;
65875: POP
65876: POP
65877: GO 65962
// end ;
65879: GO 65550
65881: POP
65882: POP
// if DangerAtRangeXY ( side , x , y , 20 ) [ 4 ] then
65883: LD_VAR 0 9
65887: PPUSH
65888: LD_VAR 0 3
65892: PPUSH
65893: LD_VAR 0 4
65897: PPUSH
65898: LD_INT 20
65900: PPUSH
65901: CALL 57908 0 4
65905: PUSH
65906: LD_INT 4
65908: ARRAY
65909: IFFALSE 65913
// exit ;
65911: GO 65962
// if btype in [ b_oil_mine , b_siberite_mine ] and not GetResourceVisibility ( x , y , side ) then
65913: LD_VAR 0 2
65917: PUSH
65918: LD_INT 29
65920: PUSH
65921: LD_INT 30
65923: PUSH
65924: EMPTY
65925: LIST
65926: LIST
65927: IN
65928: PUSH
65929: LD_VAR 0 3
65933: PPUSH
65934: LD_VAR 0 4
65938: PPUSH
65939: LD_VAR 0 9
65943: PPUSH
65944: CALL_OW 440
65948: NOT
65949: AND
65950: IFFALSE 65954
// exit ;
65952: GO 65962
// result := true ;
65954: LD_ADDR_VAR 0 6
65958: PUSH
65959: LD_INT 1
65961: ST_TO_ADDR
// end ;
65962: LD_VAR 0 6
65966: RET
// export function GetBuildingHexes ( btype , x , y , dir , nation , mode ) ; var i , temp_list , temp_list2 ; var fDepotAm0 , fDepotAm1 , fDepotAm2 , fDepotAm3 , fDepotAm4 , fDepotAm5 , fDepotAr0 , fDepotAr1 , fDepotAr2 , fDepotAr3 , fDepotAr4 , fDepotAr5 , fDepotRu0 , fDepotRu1 , fDepotRu2 , fDepotRu3 , fDepotRu4 , fDepotRu5 ; var fFactory0 , fFactory1 , fFactory2 , fFactory3 , fFactory4 , fFactory5 , fExt0 , fExt1 , fExt2 , fExt3 , fExt4 , fExt5 ; var fLab0 , fLab1 , fLab2 , fLab3 , fLab4 , fLab5 , fControlTower0 , fControlTower1 , fControlTower2 , fControlTower3 , fControlTower4 , fControlTower5 ; var fBarracks0 , fBarracks1 , fBarracks2 , fBarracks3 , fBarracks4 , fBarracks5 , fBunker0 , fBunker1 , fBunker2 , fBunker3 , fBunker4 , fBunker5 ; begin
65967: LD_INT 0
65969: PPUSH
65970: PPUSH
65971: PPUSH
65972: PPUSH
65973: PPUSH
65974: PPUSH
65975: PPUSH
65976: PPUSH
65977: PPUSH
65978: PPUSH
65979: PPUSH
65980: PPUSH
65981: PPUSH
65982: PPUSH
65983: PPUSH
65984: PPUSH
65985: PPUSH
65986: PPUSH
65987: PPUSH
65988: PPUSH
65989: PPUSH
65990: PPUSH
65991: PPUSH
65992: PPUSH
65993: PPUSH
65994: PPUSH
65995: PPUSH
65996: PPUSH
65997: PPUSH
65998: PPUSH
65999: PPUSH
66000: PPUSH
66001: PPUSH
66002: PPUSH
66003: PPUSH
66004: PPUSH
66005: PPUSH
66006: PPUSH
66007: PPUSH
66008: PPUSH
66009: PPUSH
66010: PPUSH
66011: PPUSH
66012: PPUSH
66013: PPUSH
66014: PPUSH
66015: PPUSH
66016: PPUSH
66017: PPUSH
66018: PPUSH
66019: PPUSH
66020: PPUSH
66021: PPUSH
66022: PPUSH
66023: PPUSH
66024: PPUSH
66025: PPUSH
66026: PPUSH
// result = [ ] ;
66027: LD_ADDR_VAR 0 7
66031: PUSH
66032: EMPTY
66033: ST_TO_ADDR
// temp_list = [ ] ;
66034: LD_ADDR_VAR 0 9
66038: PUSH
66039: EMPTY
66040: ST_TO_ADDR
// if not dir in [ 0 , 1 , 2 , 3 , 4 , 5 ] or ( btype in [ b_depot , b_warehouse ] and not nation in [ nation_american , nation_arabian , nation_russian ] ) then
66041: LD_VAR 0 4
66045: PUSH
66046: LD_INT 0
66048: PUSH
66049: LD_INT 1
66051: PUSH
66052: LD_INT 2
66054: PUSH
66055: LD_INT 3
66057: PUSH
66058: LD_INT 4
66060: PUSH
66061: LD_INT 5
66063: PUSH
66064: EMPTY
66065: LIST
66066: LIST
66067: LIST
66068: LIST
66069: LIST
66070: LIST
66071: IN
66072: NOT
66073: PUSH
66074: LD_VAR 0 1
66078: PUSH
66079: LD_INT 0
66081: PUSH
66082: LD_INT 1
66084: PUSH
66085: EMPTY
66086: LIST
66087: LIST
66088: IN
66089: PUSH
66090: LD_VAR 0 5
66094: PUSH
66095: LD_INT 1
66097: PUSH
66098: LD_INT 2
66100: PUSH
66101: LD_INT 3
66103: PUSH
66104: EMPTY
66105: LIST
66106: LIST
66107: LIST
66108: IN
66109: NOT
66110: AND
66111: OR
66112: IFFALSE 66116
// exit ;
66114: GO 84507
// if btype in [ b_lab , b_lab_half , b_lab_full , b_lab_biological , b_lab_computer , b_lab_opto , b_lab_siberium , b_lab_spacetime , b_lab_weapon ] then
66116: LD_VAR 0 1
66120: PUSH
66121: LD_INT 6
66123: PUSH
66124: LD_INT 7
66126: PUSH
66127: LD_INT 8
66129: PUSH
66130: LD_INT 13
66132: PUSH
66133: LD_INT 12
66135: PUSH
66136: LD_INT 15
66138: PUSH
66139: LD_INT 11
66141: PUSH
66142: LD_INT 14
66144: PUSH
66145: LD_INT 10
66147: PUSH
66148: EMPTY
66149: LIST
66150: LIST
66151: LIST
66152: LIST
66153: LIST
66154: LIST
66155: LIST
66156: LIST
66157: LIST
66158: IN
66159: IFFALSE 66169
// btype = b_lab ;
66161: LD_ADDR_VAR 0 1
66165: PUSH
66166: LD_INT 6
66168: ST_TO_ADDR
// if not mode in [ 0 , 1 , 2 ] or ( not btype in [ b_depot , b_warehouse , b_workshop , b_factory , b_lab , b_control_tower , b_armoury , b_barracks , b_breastwork , b_bunker , b_turret ] and mode = 1 ) or ( not btype in [ b_workshop , b_factory ] and mode = 2 ) then
66169: LD_VAR 0 6
66173: PUSH
66174: LD_INT 0
66176: PUSH
66177: LD_INT 1
66179: PUSH
66180: LD_INT 2
66182: PUSH
66183: EMPTY
66184: LIST
66185: LIST
66186: LIST
66187: IN
66188: NOT
66189: PUSH
66190: LD_VAR 0 1
66194: PUSH
66195: LD_INT 0
66197: PUSH
66198: LD_INT 1
66200: PUSH
66201: LD_INT 2
66203: PUSH
66204: LD_INT 3
66206: PUSH
66207: LD_INT 6
66209: PUSH
66210: LD_INT 36
66212: PUSH
66213: LD_INT 4
66215: PUSH
66216: LD_INT 5
66218: PUSH
66219: LD_INT 31
66221: PUSH
66222: LD_INT 32
66224: PUSH
66225: LD_INT 33
66227: PUSH
66228: EMPTY
66229: LIST
66230: LIST
66231: LIST
66232: LIST
66233: LIST
66234: LIST
66235: LIST
66236: LIST
66237: LIST
66238: LIST
66239: LIST
66240: IN
66241: NOT
66242: PUSH
66243: LD_VAR 0 6
66247: PUSH
66248: LD_INT 1
66250: EQUAL
66251: AND
66252: OR
66253: PUSH
66254: LD_VAR 0 1
66258: PUSH
66259: LD_INT 2
66261: PUSH
66262: LD_INT 3
66264: PUSH
66265: EMPTY
66266: LIST
66267: LIST
66268: IN
66269: NOT
66270: PUSH
66271: LD_VAR 0 6
66275: PUSH
66276: LD_INT 2
66278: EQUAL
66279: AND
66280: OR
66281: IFFALSE 66291
// mode = 0 ;
66283: LD_ADDR_VAR 0 6
66287: PUSH
66288: LD_INT 0
66290: ST_TO_ADDR
// case mode of 0 :
66291: LD_VAR 0 6
66295: PUSH
66296: LD_INT 0
66298: DOUBLE
66299: EQUAL
66300: IFTRUE 66304
66302: GO 77757
66304: POP
// begin fDepotAm0 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ 1 , 3 ] , [ 0 , 3 ] , [ - 1 , 2 ] ] ;
66305: LD_ADDR_VAR 0 11
66309: PUSH
66310: LD_INT 0
66312: PUSH
66313: LD_INT 0
66315: PUSH
66316: EMPTY
66317: LIST
66318: LIST
66319: PUSH
66320: LD_INT 0
66322: PUSH
66323: LD_INT 1
66325: NEG
66326: PUSH
66327: EMPTY
66328: LIST
66329: LIST
66330: PUSH
66331: LD_INT 1
66333: PUSH
66334: LD_INT 0
66336: PUSH
66337: EMPTY
66338: LIST
66339: LIST
66340: PUSH
66341: LD_INT 1
66343: PUSH
66344: LD_INT 1
66346: PUSH
66347: EMPTY
66348: LIST
66349: LIST
66350: PUSH
66351: LD_INT 0
66353: PUSH
66354: LD_INT 1
66356: PUSH
66357: EMPTY
66358: LIST
66359: LIST
66360: PUSH
66361: LD_INT 1
66363: NEG
66364: PUSH
66365: LD_INT 0
66367: PUSH
66368: EMPTY
66369: LIST
66370: LIST
66371: PUSH
66372: LD_INT 1
66374: NEG
66375: PUSH
66376: LD_INT 1
66378: NEG
66379: PUSH
66380: EMPTY
66381: LIST
66382: LIST
66383: PUSH
66384: LD_INT 1
66386: NEG
66387: PUSH
66388: LD_INT 2
66390: NEG
66391: PUSH
66392: EMPTY
66393: LIST
66394: LIST
66395: PUSH
66396: LD_INT 0
66398: PUSH
66399: LD_INT 2
66401: NEG
66402: PUSH
66403: EMPTY
66404: LIST
66405: LIST
66406: PUSH
66407: LD_INT 1
66409: PUSH
66410: LD_INT 1
66412: NEG
66413: PUSH
66414: EMPTY
66415: LIST
66416: LIST
66417: PUSH
66418: LD_INT 1
66420: PUSH
66421: LD_INT 2
66423: PUSH
66424: EMPTY
66425: LIST
66426: LIST
66427: PUSH
66428: LD_INT 0
66430: PUSH
66431: LD_INT 2
66433: PUSH
66434: EMPTY
66435: LIST
66436: LIST
66437: PUSH
66438: LD_INT 1
66440: NEG
66441: PUSH
66442: LD_INT 1
66444: PUSH
66445: EMPTY
66446: LIST
66447: LIST
66448: PUSH
66449: LD_INT 1
66451: PUSH
66452: LD_INT 3
66454: PUSH
66455: EMPTY
66456: LIST
66457: LIST
66458: PUSH
66459: LD_INT 0
66461: PUSH
66462: LD_INT 3
66464: PUSH
66465: EMPTY
66466: LIST
66467: LIST
66468: PUSH
66469: LD_INT 1
66471: NEG
66472: PUSH
66473: LD_INT 2
66475: PUSH
66476: EMPTY
66477: LIST
66478: LIST
66479: PUSH
66480: EMPTY
66481: LIST
66482: LIST
66483: LIST
66484: LIST
66485: LIST
66486: LIST
66487: LIST
66488: LIST
66489: LIST
66490: LIST
66491: LIST
66492: LIST
66493: LIST
66494: LIST
66495: LIST
66496: LIST
66497: ST_TO_ADDR
// fDepotAm1 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , 1 ] , [ - 3 , 0 ] , [ - 3 , - 1 ] ] ;
66498: LD_ADDR_VAR 0 12
66502: PUSH
66503: LD_INT 0
66505: PUSH
66506: LD_INT 0
66508: PUSH
66509: EMPTY
66510: LIST
66511: LIST
66512: PUSH
66513: LD_INT 0
66515: PUSH
66516: LD_INT 1
66518: NEG
66519: PUSH
66520: EMPTY
66521: LIST
66522: LIST
66523: PUSH
66524: LD_INT 1
66526: PUSH
66527: LD_INT 0
66529: PUSH
66530: EMPTY
66531: LIST
66532: LIST
66533: PUSH
66534: LD_INT 1
66536: PUSH
66537: LD_INT 1
66539: PUSH
66540: EMPTY
66541: LIST
66542: LIST
66543: PUSH
66544: LD_INT 0
66546: PUSH
66547: LD_INT 1
66549: PUSH
66550: EMPTY
66551: LIST
66552: LIST
66553: PUSH
66554: LD_INT 1
66556: NEG
66557: PUSH
66558: LD_INT 0
66560: PUSH
66561: EMPTY
66562: LIST
66563: LIST
66564: PUSH
66565: LD_INT 1
66567: NEG
66568: PUSH
66569: LD_INT 1
66571: NEG
66572: PUSH
66573: EMPTY
66574: LIST
66575: LIST
66576: PUSH
66577: LD_INT 1
66579: PUSH
66580: LD_INT 1
66582: NEG
66583: PUSH
66584: EMPTY
66585: LIST
66586: LIST
66587: PUSH
66588: LD_INT 2
66590: PUSH
66591: LD_INT 0
66593: PUSH
66594: EMPTY
66595: LIST
66596: LIST
66597: PUSH
66598: LD_INT 2
66600: PUSH
66601: LD_INT 1
66603: PUSH
66604: EMPTY
66605: LIST
66606: LIST
66607: PUSH
66608: LD_INT 1
66610: NEG
66611: PUSH
66612: LD_INT 1
66614: PUSH
66615: EMPTY
66616: LIST
66617: LIST
66618: PUSH
66619: LD_INT 2
66621: NEG
66622: PUSH
66623: LD_INT 0
66625: PUSH
66626: EMPTY
66627: LIST
66628: LIST
66629: PUSH
66630: LD_INT 2
66632: NEG
66633: PUSH
66634: LD_INT 1
66636: NEG
66637: PUSH
66638: EMPTY
66639: LIST
66640: LIST
66641: PUSH
66642: LD_INT 2
66644: NEG
66645: PUSH
66646: LD_INT 1
66648: PUSH
66649: EMPTY
66650: LIST
66651: LIST
66652: PUSH
66653: LD_INT 3
66655: NEG
66656: PUSH
66657: LD_INT 0
66659: PUSH
66660: EMPTY
66661: LIST
66662: LIST
66663: PUSH
66664: LD_INT 3
66666: NEG
66667: PUSH
66668: LD_INT 1
66670: NEG
66671: PUSH
66672: EMPTY
66673: LIST
66674: LIST
66675: PUSH
66676: EMPTY
66677: LIST
66678: LIST
66679: LIST
66680: LIST
66681: LIST
66682: LIST
66683: LIST
66684: LIST
66685: LIST
66686: LIST
66687: LIST
66688: LIST
66689: LIST
66690: LIST
66691: LIST
66692: LIST
66693: ST_TO_ADDR
// fDepotAm2 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ - 2 , - 3 ] , [ - 3 , - 2 ] , [ - 3 , - 3 ] ] ;
66694: LD_ADDR_VAR 0 13
66698: PUSH
66699: LD_INT 0
66701: PUSH
66702: LD_INT 0
66704: PUSH
66705: EMPTY
66706: LIST
66707: LIST
66708: PUSH
66709: LD_INT 0
66711: PUSH
66712: LD_INT 1
66714: NEG
66715: PUSH
66716: EMPTY
66717: LIST
66718: LIST
66719: PUSH
66720: LD_INT 1
66722: PUSH
66723: LD_INT 0
66725: PUSH
66726: EMPTY
66727: LIST
66728: LIST
66729: PUSH
66730: LD_INT 1
66732: PUSH
66733: LD_INT 1
66735: PUSH
66736: EMPTY
66737: LIST
66738: LIST
66739: PUSH
66740: LD_INT 0
66742: PUSH
66743: LD_INT 1
66745: PUSH
66746: EMPTY
66747: LIST
66748: LIST
66749: PUSH
66750: LD_INT 1
66752: NEG
66753: PUSH
66754: LD_INT 0
66756: PUSH
66757: EMPTY
66758: LIST
66759: LIST
66760: PUSH
66761: LD_INT 1
66763: NEG
66764: PUSH
66765: LD_INT 1
66767: NEG
66768: PUSH
66769: EMPTY
66770: LIST
66771: LIST
66772: PUSH
66773: LD_INT 1
66775: NEG
66776: PUSH
66777: LD_INT 2
66779: NEG
66780: PUSH
66781: EMPTY
66782: LIST
66783: LIST
66784: PUSH
66785: LD_INT 2
66787: PUSH
66788: LD_INT 1
66790: PUSH
66791: EMPTY
66792: LIST
66793: LIST
66794: PUSH
66795: LD_INT 2
66797: PUSH
66798: LD_INT 2
66800: PUSH
66801: EMPTY
66802: LIST
66803: LIST
66804: PUSH
66805: LD_INT 1
66807: PUSH
66808: LD_INT 2
66810: PUSH
66811: EMPTY
66812: LIST
66813: LIST
66814: PUSH
66815: LD_INT 2
66817: NEG
66818: PUSH
66819: LD_INT 1
66821: NEG
66822: PUSH
66823: EMPTY
66824: LIST
66825: LIST
66826: PUSH
66827: LD_INT 2
66829: NEG
66830: PUSH
66831: LD_INT 2
66833: NEG
66834: PUSH
66835: EMPTY
66836: LIST
66837: LIST
66838: PUSH
66839: LD_INT 2
66841: NEG
66842: PUSH
66843: LD_INT 3
66845: NEG
66846: PUSH
66847: EMPTY
66848: LIST
66849: LIST
66850: PUSH
66851: LD_INT 3
66853: NEG
66854: PUSH
66855: LD_INT 2
66857: NEG
66858: PUSH
66859: EMPTY
66860: LIST
66861: LIST
66862: PUSH
66863: LD_INT 3
66865: NEG
66866: PUSH
66867: LD_INT 3
66869: NEG
66870: PUSH
66871: EMPTY
66872: LIST
66873: LIST
66874: PUSH
66875: EMPTY
66876: LIST
66877: LIST
66878: LIST
66879: LIST
66880: LIST
66881: LIST
66882: LIST
66883: LIST
66884: LIST
66885: LIST
66886: LIST
66887: LIST
66888: LIST
66889: LIST
66890: LIST
66891: LIST
66892: ST_TO_ADDR
// fDepotAm3 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 1 , - 3 ] , [ 0 , - 3 ] , [ 1 , - 2 ] ] ;
66893: LD_ADDR_VAR 0 14
66897: PUSH
66898: LD_INT 0
66900: PUSH
66901: LD_INT 0
66903: PUSH
66904: EMPTY
66905: LIST
66906: LIST
66907: PUSH
66908: LD_INT 0
66910: PUSH
66911: LD_INT 1
66913: NEG
66914: PUSH
66915: EMPTY
66916: LIST
66917: LIST
66918: PUSH
66919: LD_INT 1
66921: PUSH
66922: LD_INT 0
66924: PUSH
66925: EMPTY
66926: LIST
66927: LIST
66928: PUSH
66929: LD_INT 1
66931: PUSH
66932: LD_INT 1
66934: PUSH
66935: EMPTY
66936: LIST
66937: LIST
66938: PUSH
66939: LD_INT 0
66941: PUSH
66942: LD_INT 1
66944: PUSH
66945: EMPTY
66946: LIST
66947: LIST
66948: PUSH
66949: LD_INT 1
66951: NEG
66952: PUSH
66953: LD_INT 0
66955: PUSH
66956: EMPTY
66957: LIST
66958: LIST
66959: PUSH
66960: LD_INT 1
66962: NEG
66963: PUSH
66964: LD_INT 1
66966: NEG
66967: PUSH
66968: EMPTY
66969: LIST
66970: LIST
66971: PUSH
66972: LD_INT 1
66974: NEG
66975: PUSH
66976: LD_INT 2
66978: NEG
66979: PUSH
66980: EMPTY
66981: LIST
66982: LIST
66983: PUSH
66984: LD_INT 0
66986: PUSH
66987: LD_INT 2
66989: NEG
66990: PUSH
66991: EMPTY
66992: LIST
66993: LIST
66994: PUSH
66995: LD_INT 1
66997: PUSH
66998: LD_INT 1
67000: NEG
67001: PUSH
67002: EMPTY
67003: LIST
67004: LIST
67005: PUSH
67006: LD_INT 1
67008: PUSH
67009: LD_INT 2
67011: PUSH
67012: EMPTY
67013: LIST
67014: LIST
67015: PUSH
67016: LD_INT 0
67018: PUSH
67019: LD_INT 2
67021: PUSH
67022: EMPTY
67023: LIST
67024: LIST
67025: PUSH
67026: LD_INT 1
67028: NEG
67029: PUSH
67030: LD_INT 1
67032: PUSH
67033: EMPTY
67034: LIST
67035: LIST
67036: PUSH
67037: LD_INT 1
67039: NEG
67040: PUSH
67041: LD_INT 3
67043: NEG
67044: PUSH
67045: EMPTY
67046: LIST
67047: LIST
67048: PUSH
67049: LD_INT 0
67051: PUSH
67052: LD_INT 3
67054: NEG
67055: PUSH
67056: EMPTY
67057: LIST
67058: LIST
67059: PUSH
67060: LD_INT 1
67062: PUSH
67063: LD_INT 2
67065: NEG
67066: PUSH
67067: EMPTY
67068: LIST
67069: LIST
67070: PUSH
67071: EMPTY
67072: LIST
67073: LIST
67074: LIST
67075: LIST
67076: LIST
67077: LIST
67078: LIST
67079: LIST
67080: LIST
67081: LIST
67082: LIST
67083: LIST
67084: LIST
67085: LIST
67086: LIST
67087: LIST
67088: ST_TO_ADDR
// fDepotAm4 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ 2 , - 1 ] , [ 3 , 0 ] , [ 3 , 1 ] ] ;
67089: LD_ADDR_VAR 0 15
67093: PUSH
67094: LD_INT 0
67096: PUSH
67097: LD_INT 0
67099: PUSH
67100: EMPTY
67101: LIST
67102: LIST
67103: PUSH
67104: LD_INT 0
67106: PUSH
67107: LD_INT 1
67109: NEG
67110: PUSH
67111: EMPTY
67112: LIST
67113: LIST
67114: PUSH
67115: LD_INT 1
67117: PUSH
67118: LD_INT 0
67120: PUSH
67121: EMPTY
67122: LIST
67123: LIST
67124: PUSH
67125: LD_INT 1
67127: PUSH
67128: LD_INT 1
67130: PUSH
67131: EMPTY
67132: LIST
67133: LIST
67134: PUSH
67135: LD_INT 0
67137: PUSH
67138: LD_INT 1
67140: PUSH
67141: EMPTY
67142: LIST
67143: LIST
67144: PUSH
67145: LD_INT 1
67147: NEG
67148: PUSH
67149: LD_INT 0
67151: PUSH
67152: EMPTY
67153: LIST
67154: LIST
67155: PUSH
67156: LD_INT 1
67158: NEG
67159: PUSH
67160: LD_INT 1
67162: NEG
67163: PUSH
67164: EMPTY
67165: LIST
67166: LIST
67167: PUSH
67168: LD_INT 1
67170: PUSH
67171: LD_INT 1
67173: NEG
67174: PUSH
67175: EMPTY
67176: LIST
67177: LIST
67178: PUSH
67179: LD_INT 2
67181: PUSH
67182: LD_INT 0
67184: PUSH
67185: EMPTY
67186: LIST
67187: LIST
67188: PUSH
67189: LD_INT 2
67191: PUSH
67192: LD_INT 1
67194: PUSH
67195: EMPTY
67196: LIST
67197: LIST
67198: PUSH
67199: LD_INT 1
67201: NEG
67202: PUSH
67203: LD_INT 1
67205: PUSH
67206: EMPTY
67207: LIST
67208: LIST
67209: PUSH
67210: LD_INT 2
67212: NEG
67213: PUSH
67214: LD_INT 0
67216: PUSH
67217: EMPTY
67218: LIST
67219: LIST
67220: PUSH
67221: LD_INT 2
67223: NEG
67224: PUSH
67225: LD_INT 1
67227: NEG
67228: PUSH
67229: EMPTY
67230: LIST
67231: LIST
67232: PUSH
67233: LD_INT 2
67235: PUSH
67236: LD_INT 1
67238: NEG
67239: PUSH
67240: EMPTY
67241: LIST
67242: LIST
67243: PUSH
67244: LD_INT 3
67246: PUSH
67247: LD_INT 0
67249: PUSH
67250: EMPTY
67251: LIST
67252: LIST
67253: PUSH
67254: LD_INT 3
67256: PUSH
67257: LD_INT 1
67259: PUSH
67260: EMPTY
67261: LIST
67262: LIST
67263: PUSH
67264: EMPTY
67265: LIST
67266: LIST
67267: LIST
67268: LIST
67269: LIST
67270: LIST
67271: LIST
67272: LIST
67273: LIST
67274: LIST
67275: LIST
67276: LIST
67277: LIST
67278: LIST
67279: LIST
67280: LIST
67281: ST_TO_ADDR
// fDepotAm5 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ 3 , 2 ] , [ 3 , 3 ] , [ 2 , 3 ] ] ;
67282: LD_ADDR_VAR 0 16
67286: PUSH
67287: LD_INT 0
67289: PUSH
67290: LD_INT 0
67292: PUSH
67293: EMPTY
67294: LIST
67295: LIST
67296: PUSH
67297: LD_INT 0
67299: PUSH
67300: LD_INT 1
67302: NEG
67303: PUSH
67304: EMPTY
67305: LIST
67306: LIST
67307: PUSH
67308: LD_INT 1
67310: PUSH
67311: LD_INT 0
67313: PUSH
67314: EMPTY
67315: LIST
67316: LIST
67317: PUSH
67318: LD_INT 1
67320: PUSH
67321: LD_INT 1
67323: PUSH
67324: EMPTY
67325: LIST
67326: LIST
67327: PUSH
67328: LD_INT 0
67330: PUSH
67331: LD_INT 1
67333: PUSH
67334: EMPTY
67335: LIST
67336: LIST
67337: PUSH
67338: LD_INT 1
67340: NEG
67341: PUSH
67342: LD_INT 0
67344: PUSH
67345: EMPTY
67346: LIST
67347: LIST
67348: PUSH
67349: LD_INT 1
67351: NEG
67352: PUSH
67353: LD_INT 1
67355: NEG
67356: PUSH
67357: EMPTY
67358: LIST
67359: LIST
67360: PUSH
67361: LD_INT 1
67363: NEG
67364: PUSH
67365: LD_INT 2
67367: NEG
67368: PUSH
67369: EMPTY
67370: LIST
67371: LIST
67372: PUSH
67373: LD_INT 2
67375: PUSH
67376: LD_INT 1
67378: PUSH
67379: EMPTY
67380: LIST
67381: LIST
67382: PUSH
67383: LD_INT 2
67385: PUSH
67386: LD_INT 2
67388: PUSH
67389: EMPTY
67390: LIST
67391: LIST
67392: PUSH
67393: LD_INT 1
67395: PUSH
67396: LD_INT 2
67398: PUSH
67399: EMPTY
67400: LIST
67401: LIST
67402: PUSH
67403: LD_INT 2
67405: NEG
67406: PUSH
67407: LD_INT 1
67409: NEG
67410: PUSH
67411: EMPTY
67412: LIST
67413: LIST
67414: PUSH
67415: LD_INT 2
67417: NEG
67418: PUSH
67419: LD_INT 2
67421: NEG
67422: PUSH
67423: EMPTY
67424: LIST
67425: LIST
67426: PUSH
67427: LD_INT 3
67429: PUSH
67430: LD_INT 2
67432: PUSH
67433: EMPTY
67434: LIST
67435: LIST
67436: PUSH
67437: LD_INT 3
67439: PUSH
67440: LD_INT 3
67442: PUSH
67443: EMPTY
67444: LIST
67445: LIST
67446: PUSH
67447: LD_INT 2
67449: PUSH
67450: LD_INT 3
67452: PUSH
67453: EMPTY
67454: LIST
67455: LIST
67456: PUSH
67457: EMPTY
67458: LIST
67459: LIST
67460: LIST
67461: LIST
67462: LIST
67463: LIST
67464: LIST
67465: LIST
67466: LIST
67467: LIST
67468: LIST
67469: LIST
67470: LIST
67471: LIST
67472: LIST
67473: LIST
67474: ST_TO_ADDR
// fDepotAr0 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
67475: LD_ADDR_VAR 0 17
67479: PUSH
67480: LD_INT 0
67482: PUSH
67483: LD_INT 0
67485: PUSH
67486: EMPTY
67487: LIST
67488: LIST
67489: PUSH
67490: LD_INT 0
67492: PUSH
67493: LD_INT 1
67495: NEG
67496: PUSH
67497: EMPTY
67498: LIST
67499: LIST
67500: PUSH
67501: LD_INT 1
67503: PUSH
67504: LD_INT 0
67506: PUSH
67507: EMPTY
67508: LIST
67509: LIST
67510: PUSH
67511: LD_INT 1
67513: PUSH
67514: LD_INT 1
67516: PUSH
67517: EMPTY
67518: LIST
67519: LIST
67520: PUSH
67521: LD_INT 0
67523: PUSH
67524: LD_INT 1
67526: PUSH
67527: EMPTY
67528: LIST
67529: LIST
67530: PUSH
67531: LD_INT 1
67533: NEG
67534: PUSH
67535: LD_INT 0
67537: PUSH
67538: EMPTY
67539: LIST
67540: LIST
67541: PUSH
67542: LD_INT 1
67544: NEG
67545: PUSH
67546: LD_INT 1
67548: NEG
67549: PUSH
67550: EMPTY
67551: LIST
67552: LIST
67553: PUSH
67554: LD_INT 1
67556: NEG
67557: PUSH
67558: LD_INT 2
67560: NEG
67561: PUSH
67562: EMPTY
67563: LIST
67564: LIST
67565: PUSH
67566: LD_INT 0
67568: PUSH
67569: LD_INT 2
67571: NEG
67572: PUSH
67573: EMPTY
67574: LIST
67575: LIST
67576: PUSH
67577: LD_INT 1
67579: PUSH
67580: LD_INT 1
67582: NEG
67583: PUSH
67584: EMPTY
67585: LIST
67586: LIST
67587: PUSH
67588: LD_INT 2
67590: PUSH
67591: LD_INT 0
67593: PUSH
67594: EMPTY
67595: LIST
67596: LIST
67597: PUSH
67598: LD_INT 2
67600: PUSH
67601: LD_INT 1
67603: PUSH
67604: EMPTY
67605: LIST
67606: LIST
67607: PUSH
67608: LD_INT 2
67610: PUSH
67611: LD_INT 2
67613: PUSH
67614: EMPTY
67615: LIST
67616: LIST
67617: PUSH
67618: LD_INT 1
67620: PUSH
67621: LD_INT 2
67623: PUSH
67624: EMPTY
67625: LIST
67626: LIST
67627: PUSH
67628: LD_INT 0
67630: PUSH
67631: LD_INT 2
67633: PUSH
67634: EMPTY
67635: LIST
67636: LIST
67637: PUSH
67638: LD_INT 1
67640: NEG
67641: PUSH
67642: LD_INT 1
67644: PUSH
67645: EMPTY
67646: LIST
67647: LIST
67648: PUSH
67649: LD_INT 2
67651: NEG
67652: PUSH
67653: LD_INT 0
67655: PUSH
67656: EMPTY
67657: LIST
67658: LIST
67659: PUSH
67660: LD_INT 2
67662: NEG
67663: PUSH
67664: LD_INT 1
67666: NEG
67667: PUSH
67668: EMPTY
67669: LIST
67670: LIST
67671: PUSH
67672: LD_INT 2
67674: NEG
67675: PUSH
67676: LD_INT 2
67678: NEG
67679: PUSH
67680: EMPTY
67681: LIST
67682: LIST
67683: PUSH
67684: EMPTY
67685: LIST
67686: LIST
67687: LIST
67688: LIST
67689: LIST
67690: LIST
67691: LIST
67692: LIST
67693: LIST
67694: LIST
67695: LIST
67696: LIST
67697: LIST
67698: LIST
67699: LIST
67700: LIST
67701: LIST
67702: LIST
67703: LIST
67704: ST_TO_ADDR
// fDepotAr1 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
67705: LD_ADDR_VAR 0 18
67709: PUSH
67710: LD_INT 0
67712: PUSH
67713: LD_INT 0
67715: PUSH
67716: EMPTY
67717: LIST
67718: LIST
67719: PUSH
67720: LD_INT 0
67722: PUSH
67723: LD_INT 1
67725: NEG
67726: PUSH
67727: EMPTY
67728: LIST
67729: LIST
67730: PUSH
67731: LD_INT 1
67733: PUSH
67734: LD_INT 0
67736: PUSH
67737: EMPTY
67738: LIST
67739: LIST
67740: PUSH
67741: LD_INT 1
67743: PUSH
67744: LD_INT 1
67746: PUSH
67747: EMPTY
67748: LIST
67749: LIST
67750: PUSH
67751: LD_INT 0
67753: PUSH
67754: LD_INT 1
67756: PUSH
67757: EMPTY
67758: LIST
67759: LIST
67760: PUSH
67761: LD_INT 1
67763: NEG
67764: PUSH
67765: LD_INT 0
67767: PUSH
67768: EMPTY
67769: LIST
67770: LIST
67771: PUSH
67772: LD_INT 1
67774: NEG
67775: PUSH
67776: LD_INT 1
67778: NEG
67779: PUSH
67780: EMPTY
67781: LIST
67782: LIST
67783: PUSH
67784: LD_INT 1
67786: NEG
67787: PUSH
67788: LD_INT 2
67790: NEG
67791: PUSH
67792: EMPTY
67793: LIST
67794: LIST
67795: PUSH
67796: LD_INT 0
67798: PUSH
67799: LD_INT 2
67801: NEG
67802: PUSH
67803: EMPTY
67804: LIST
67805: LIST
67806: PUSH
67807: LD_INT 1
67809: PUSH
67810: LD_INT 1
67812: NEG
67813: PUSH
67814: EMPTY
67815: LIST
67816: LIST
67817: PUSH
67818: LD_INT 2
67820: PUSH
67821: LD_INT 0
67823: PUSH
67824: EMPTY
67825: LIST
67826: LIST
67827: PUSH
67828: LD_INT 2
67830: PUSH
67831: LD_INT 1
67833: PUSH
67834: EMPTY
67835: LIST
67836: LIST
67837: PUSH
67838: LD_INT 2
67840: PUSH
67841: LD_INT 2
67843: PUSH
67844: EMPTY
67845: LIST
67846: LIST
67847: PUSH
67848: LD_INT 1
67850: PUSH
67851: LD_INT 2
67853: PUSH
67854: EMPTY
67855: LIST
67856: LIST
67857: PUSH
67858: LD_INT 0
67860: PUSH
67861: LD_INT 2
67863: PUSH
67864: EMPTY
67865: LIST
67866: LIST
67867: PUSH
67868: LD_INT 1
67870: NEG
67871: PUSH
67872: LD_INT 1
67874: PUSH
67875: EMPTY
67876: LIST
67877: LIST
67878: PUSH
67879: LD_INT 2
67881: NEG
67882: PUSH
67883: LD_INT 0
67885: PUSH
67886: EMPTY
67887: LIST
67888: LIST
67889: PUSH
67890: LD_INT 2
67892: NEG
67893: PUSH
67894: LD_INT 1
67896: NEG
67897: PUSH
67898: EMPTY
67899: LIST
67900: LIST
67901: PUSH
67902: LD_INT 2
67904: NEG
67905: PUSH
67906: LD_INT 2
67908: NEG
67909: PUSH
67910: EMPTY
67911: LIST
67912: LIST
67913: PUSH
67914: EMPTY
67915: LIST
67916: LIST
67917: LIST
67918: LIST
67919: LIST
67920: LIST
67921: LIST
67922: LIST
67923: LIST
67924: LIST
67925: LIST
67926: LIST
67927: LIST
67928: LIST
67929: LIST
67930: LIST
67931: LIST
67932: LIST
67933: LIST
67934: ST_TO_ADDR
// fDepotAr2 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
67935: LD_ADDR_VAR 0 19
67939: PUSH
67940: LD_INT 0
67942: PUSH
67943: LD_INT 0
67945: PUSH
67946: EMPTY
67947: LIST
67948: LIST
67949: PUSH
67950: LD_INT 0
67952: PUSH
67953: LD_INT 1
67955: NEG
67956: PUSH
67957: EMPTY
67958: LIST
67959: LIST
67960: PUSH
67961: LD_INT 1
67963: PUSH
67964: LD_INT 0
67966: PUSH
67967: EMPTY
67968: LIST
67969: LIST
67970: PUSH
67971: LD_INT 1
67973: PUSH
67974: LD_INT 1
67976: PUSH
67977: EMPTY
67978: LIST
67979: LIST
67980: PUSH
67981: LD_INT 0
67983: PUSH
67984: LD_INT 1
67986: PUSH
67987: EMPTY
67988: LIST
67989: LIST
67990: PUSH
67991: LD_INT 1
67993: NEG
67994: PUSH
67995: LD_INT 0
67997: PUSH
67998: EMPTY
67999: LIST
68000: LIST
68001: PUSH
68002: LD_INT 1
68004: NEG
68005: PUSH
68006: LD_INT 1
68008: NEG
68009: PUSH
68010: EMPTY
68011: LIST
68012: LIST
68013: PUSH
68014: LD_INT 1
68016: NEG
68017: PUSH
68018: LD_INT 2
68020: NEG
68021: PUSH
68022: EMPTY
68023: LIST
68024: LIST
68025: PUSH
68026: LD_INT 0
68028: PUSH
68029: LD_INT 2
68031: NEG
68032: PUSH
68033: EMPTY
68034: LIST
68035: LIST
68036: PUSH
68037: LD_INT 1
68039: PUSH
68040: LD_INT 1
68042: NEG
68043: PUSH
68044: EMPTY
68045: LIST
68046: LIST
68047: PUSH
68048: LD_INT 2
68050: PUSH
68051: LD_INT 0
68053: PUSH
68054: EMPTY
68055: LIST
68056: LIST
68057: PUSH
68058: LD_INT 2
68060: PUSH
68061: LD_INT 1
68063: PUSH
68064: EMPTY
68065: LIST
68066: LIST
68067: PUSH
68068: LD_INT 2
68070: PUSH
68071: LD_INT 2
68073: PUSH
68074: EMPTY
68075: LIST
68076: LIST
68077: PUSH
68078: LD_INT 1
68080: PUSH
68081: LD_INT 2
68083: PUSH
68084: EMPTY
68085: LIST
68086: LIST
68087: PUSH
68088: LD_INT 0
68090: PUSH
68091: LD_INT 2
68093: PUSH
68094: EMPTY
68095: LIST
68096: LIST
68097: PUSH
68098: LD_INT 1
68100: NEG
68101: PUSH
68102: LD_INT 1
68104: PUSH
68105: EMPTY
68106: LIST
68107: LIST
68108: PUSH
68109: LD_INT 2
68111: NEG
68112: PUSH
68113: LD_INT 0
68115: PUSH
68116: EMPTY
68117: LIST
68118: LIST
68119: PUSH
68120: LD_INT 2
68122: NEG
68123: PUSH
68124: LD_INT 1
68126: NEG
68127: PUSH
68128: EMPTY
68129: LIST
68130: LIST
68131: PUSH
68132: LD_INT 2
68134: NEG
68135: PUSH
68136: LD_INT 2
68138: NEG
68139: PUSH
68140: EMPTY
68141: LIST
68142: LIST
68143: PUSH
68144: EMPTY
68145: LIST
68146: LIST
68147: LIST
68148: LIST
68149: LIST
68150: LIST
68151: LIST
68152: LIST
68153: LIST
68154: LIST
68155: LIST
68156: LIST
68157: LIST
68158: LIST
68159: LIST
68160: LIST
68161: LIST
68162: LIST
68163: LIST
68164: ST_TO_ADDR
// fDepotAr3 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
68165: LD_ADDR_VAR 0 20
68169: PUSH
68170: LD_INT 0
68172: PUSH
68173: LD_INT 0
68175: PUSH
68176: EMPTY
68177: LIST
68178: LIST
68179: PUSH
68180: LD_INT 0
68182: PUSH
68183: LD_INT 1
68185: NEG
68186: PUSH
68187: EMPTY
68188: LIST
68189: LIST
68190: PUSH
68191: LD_INT 1
68193: PUSH
68194: LD_INT 0
68196: PUSH
68197: EMPTY
68198: LIST
68199: LIST
68200: PUSH
68201: LD_INT 1
68203: PUSH
68204: LD_INT 1
68206: PUSH
68207: EMPTY
68208: LIST
68209: LIST
68210: PUSH
68211: LD_INT 0
68213: PUSH
68214: LD_INT 1
68216: PUSH
68217: EMPTY
68218: LIST
68219: LIST
68220: PUSH
68221: LD_INT 1
68223: NEG
68224: PUSH
68225: LD_INT 0
68227: PUSH
68228: EMPTY
68229: LIST
68230: LIST
68231: PUSH
68232: LD_INT 1
68234: NEG
68235: PUSH
68236: LD_INT 1
68238: NEG
68239: PUSH
68240: EMPTY
68241: LIST
68242: LIST
68243: PUSH
68244: LD_INT 1
68246: NEG
68247: PUSH
68248: LD_INT 2
68250: NEG
68251: PUSH
68252: EMPTY
68253: LIST
68254: LIST
68255: PUSH
68256: LD_INT 0
68258: PUSH
68259: LD_INT 2
68261: NEG
68262: PUSH
68263: EMPTY
68264: LIST
68265: LIST
68266: PUSH
68267: LD_INT 1
68269: PUSH
68270: LD_INT 1
68272: NEG
68273: PUSH
68274: EMPTY
68275: LIST
68276: LIST
68277: PUSH
68278: LD_INT 2
68280: PUSH
68281: LD_INT 0
68283: PUSH
68284: EMPTY
68285: LIST
68286: LIST
68287: PUSH
68288: LD_INT 2
68290: PUSH
68291: LD_INT 1
68293: PUSH
68294: EMPTY
68295: LIST
68296: LIST
68297: PUSH
68298: LD_INT 2
68300: PUSH
68301: LD_INT 2
68303: PUSH
68304: EMPTY
68305: LIST
68306: LIST
68307: PUSH
68308: LD_INT 1
68310: PUSH
68311: LD_INT 2
68313: PUSH
68314: EMPTY
68315: LIST
68316: LIST
68317: PUSH
68318: LD_INT 0
68320: PUSH
68321: LD_INT 2
68323: PUSH
68324: EMPTY
68325: LIST
68326: LIST
68327: PUSH
68328: LD_INT 1
68330: NEG
68331: PUSH
68332: LD_INT 1
68334: PUSH
68335: EMPTY
68336: LIST
68337: LIST
68338: PUSH
68339: LD_INT 2
68341: NEG
68342: PUSH
68343: LD_INT 0
68345: PUSH
68346: EMPTY
68347: LIST
68348: LIST
68349: PUSH
68350: LD_INT 2
68352: NEG
68353: PUSH
68354: LD_INT 1
68356: NEG
68357: PUSH
68358: EMPTY
68359: LIST
68360: LIST
68361: PUSH
68362: LD_INT 2
68364: NEG
68365: PUSH
68366: LD_INT 2
68368: NEG
68369: PUSH
68370: EMPTY
68371: LIST
68372: LIST
68373: PUSH
68374: EMPTY
68375: LIST
68376: LIST
68377: LIST
68378: LIST
68379: LIST
68380: LIST
68381: LIST
68382: LIST
68383: LIST
68384: LIST
68385: LIST
68386: LIST
68387: LIST
68388: LIST
68389: LIST
68390: LIST
68391: LIST
68392: LIST
68393: LIST
68394: ST_TO_ADDR
// fDepotAr4 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
68395: LD_ADDR_VAR 0 21
68399: PUSH
68400: LD_INT 0
68402: PUSH
68403: LD_INT 0
68405: PUSH
68406: EMPTY
68407: LIST
68408: LIST
68409: PUSH
68410: LD_INT 0
68412: PUSH
68413: LD_INT 1
68415: NEG
68416: PUSH
68417: EMPTY
68418: LIST
68419: LIST
68420: PUSH
68421: LD_INT 1
68423: PUSH
68424: LD_INT 0
68426: PUSH
68427: EMPTY
68428: LIST
68429: LIST
68430: PUSH
68431: LD_INT 1
68433: PUSH
68434: LD_INT 1
68436: PUSH
68437: EMPTY
68438: LIST
68439: LIST
68440: PUSH
68441: LD_INT 0
68443: PUSH
68444: LD_INT 1
68446: PUSH
68447: EMPTY
68448: LIST
68449: LIST
68450: PUSH
68451: LD_INT 1
68453: NEG
68454: PUSH
68455: LD_INT 0
68457: PUSH
68458: EMPTY
68459: LIST
68460: LIST
68461: PUSH
68462: LD_INT 1
68464: NEG
68465: PUSH
68466: LD_INT 1
68468: NEG
68469: PUSH
68470: EMPTY
68471: LIST
68472: LIST
68473: PUSH
68474: LD_INT 1
68476: NEG
68477: PUSH
68478: LD_INT 2
68480: NEG
68481: PUSH
68482: EMPTY
68483: LIST
68484: LIST
68485: PUSH
68486: LD_INT 0
68488: PUSH
68489: LD_INT 2
68491: NEG
68492: PUSH
68493: EMPTY
68494: LIST
68495: LIST
68496: PUSH
68497: LD_INT 1
68499: PUSH
68500: LD_INT 1
68502: NEG
68503: PUSH
68504: EMPTY
68505: LIST
68506: LIST
68507: PUSH
68508: LD_INT 2
68510: PUSH
68511: LD_INT 0
68513: PUSH
68514: EMPTY
68515: LIST
68516: LIST
68517: PUSH
68518: LD_INT 2
68520: PUSH
68521: LD_INT 1
68523: PUSH
68524: EMPTY
68525: LIST
68526: LIST
68527: PUSH
68528: LD_INT 2
68530: PUSH
68531: LD_INT 2
68533: PUSH
68534: EMPTY
68535: LIST
68536: LIST
68537: PUSH
68538: LD_INT 1
68540: PUSH
68541: LD_INT 2
68543: PUSH
68544: EMPTY
68545: LIST
68546: LIST
68547: PUSH
68548: LD_INT 0
68550: PUSH
68551: LD_INT 2
68553: PUSH
68554: EMPTY
68555: LIST
68556: LIST
68557: PUSH
68558: LD_INT 1
68560: NEG
68561: PUSH
68562: LD_INT 1
68564: PUSH
68565: EMPTY
68566: LIST
68567: LIST
68568: PUSH
68569: LD_INT 2
68571: NEG
68572: PUSH
68573: LD_INT 0
68575: PUSH
68576: EMPTY
68577: LIST
68578: LIST
68579: PUSH
68580: LD_INT 2
68582: NEG
68583: PUSH
68584: LD_INT 1
68586: NEG
68587: PUSH
68588: EMPTY
68589: LIST
68590: LIST
68591: PUSH
68592: LD_INT 2
68594: NEG
68595: PUSH
68596: LD_INT 2
68598: NEG
68599: PUSH
68600: EMPTY
68601: LIST
68602: LIST
68603: PUSH
68604: EMPTY
68605: LIST
68606: LIST
68607: LIST
68608: LIST
68609: LIST
68610: LIST
68611: LIST
68612: LIST
68613: LIST
68614: LIST
68615: LIST
68616: LIST
68617: LIST
68618: LIST
68619: LIST
68620: LIST
68621: LIST
68622: LIST
68623: LIST
68624: ST_TO_ADDR
// fDepotAr5 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
68625: LD_ADDR_VAR 0 22
68629: PUSH
68630: LD_INT 0
68632: PUSH
68633: LD_INT 0
68635: PUSH
68636: EMPTY
68637: LIST
68638: LIST
68639: PUSH
68640: LD_INT 0
68642: PUSH
68643: LD_INT 1
68645: NEG
68646: PUSH
68647: EMPTY
68648: LIST
68649: LIST
68650: PUSH
68651: LD_INT 1
68653: PUSH
68654: LD_INT 0
68656: PUSH
68657: EMPTY
68658: LIST
68659: LIST
68660: PUSH
68661: LD_INT 1
68663: PUSH
68664: LD_INT 1
68666: PUSH
68667: EMPTY
68668: LIST
68669: LIST
68670: PUSH
68671: LD_INT 0
68673: PUSH
68674: LD_INT 1
68676: PUSH
68677: EMPTY
68678: LIST
68679: LIST
68680: PUSH
68681: LD_INT 1
68683: NEG
68684: PUSH
68685: LD_INT 0
68687: PUSH
68688: EMPTY
68689: LIST
68690: LIST
68691: PUSH
68692: LD_INT 1
68694: NEG
68695: PUSH
68696: LD_INT 1
68698: NEG
68699: PUSH
68700: EMPTY
68701: LIST
68702: LIST
68703: PUSH
68704: LD_INT 1
68706: NEG
68707: PUSH
68708: LD_INT 2
68710: NEG
68711: PUSH
68712: EMPTY
68713: LIST
68714: LIST
68715: PUSH
68716: LD_INT 0
68718: PUSH
68719: LD_INT 2
68721: NEG
68722: PUSH
68723: EMPTY
68724: LIST
68725: LIST
68726: PUSH
68727: LD_INT 1
68729: PUSH
68730: LD_INT 1
68732: NEG
68733: PUSH
68734: EMPTY
68735: LIST
68736: LIST
68737: PUSH
68738: LD_INT 2
68740: PUSH
68741: LD_INT 0
68743: PUSH
68744: EMPTY
68745: LIST
68746: LIST
68747: PUSH
68748: LD_INT 2
68750: PUSH
68751: LD_INT 1
68753: PUSH
68754: EMPTY
68755: LIST
68756: LIST
68757: PUSH
68758: LD_INT 2
68760: PUSH
68761: LD_INT 2
68763: PUSH
68764: EMPTY
68765: LIST
68766: LIST
68767: PUSH
68768: LD_INT 1
68770: PUSH
68771: LD_INT 2
68773: PUSH
68774: EMPTY
68775: LIST
68776: LIST
68777: PUSH
68778: LD_INT 0
68780: PUSH
68781: LD_INT 2
68783: PUSH
68784: EMPTY
68785: LIST
68786: LIST
68787: PUSH
68788: LD_INT 1
68790: NEG
68791: PUSH
68792: LD_INT 1
68794: PUSH
68795: EMPTY
68796: LIST
68797: LIST
68798: PUSH
68799: LD_INT 2
68801: NEG
68802: PUSH
68803: LD_INT 0
68805: PUSH
68806: EMPTY
68807: LIST
68808: LIST
68809: PUSH
68810: LD_INT 2
68812: NEG
68813: PUSH
68814: LD_INT 1
68816: NEG
68817: PUSH
68818: EMPTY
68819: LIST
68820: LIST
68821: PUSH
68822: LD_INT 2
68824: NEG
68825: PUSH
68826: LD_INT 2
68828: NEG
68829: PUSH
68830: EMPTY
68831: LIST
68832: LIST
68833: PUSH
68834: EMPTY
68835: LIST
68836: LIST
68837: LIST
68838: LIST
68839: LIST
68840: LIST
68841: LIST
68842: LIST
68843: LIST
68844: LIST
68845: LIST
68846: LIST
68847: LIST
68848: LIST
68849: LIST
68850: LIST
68851: LIST
68852: LIST
68853: LIST
68854: ST_TO_ADDR
// fDepotRu0 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ - 2 , - 3 ] , [ - 1 , - 3 ] , [ 1 , - 2 ] , [ 2 , - 1 ] ] ;
68855: LD_ADDR_VAR 0 23
68859: PUSH
68860: LD_INT 0
68862: PUSH
68863: LD_INT 0
68865: PUSH
68866: EMPTY
68867: LIST
68868: LIST
68869: PUSH
68870: LD_INT 0
68872: PUSH
68873: LD_INT 1
68875: NEG
68876: PUSH
68877: EMPTY
68878: LIST
68879: LIST
68880: PUSH
68881: LD_INT 1
68883: PUSH
68884: LD_INT 0
68886: PUSH
68887: EMPTY
68888: LIST
68889: LIST
68890: PUSH
68891: LD_INT 1
68893: PUSH
68894: LD_INT 1
68896: PUSH
68897: EMPTY
68898: LIST
68899: LIST
68900: PUSH
68901: LD_INT 0
68903: PUSH
68904: LD_INT 1
68906: PUSH
68907: EMPTY
68908: LIST
68909: LIST
68910: PUSH
68911: LD_INT 1
68913: NEG
68914: PUSH
68915: LD_INT 0
68917: PUSH
68918: EMPTY
68919: LIST
68920: LIST
68921: PUSH
68922: LD_INT 1
68924: NEG
68925: PUSH
68926: LD_INT 1
68928: NEG
68929: PUSH
68930: EMPTY
68931: LIST
68932: LIST
68933: PUSH
68934: LD_INT 1
68936: NEG
68937: PUSH
68938: LD_INT 2
68940: NEG
68941: PUSH
68942: EMPTY
68943: LIST
68944: LIST
68945: PUSH
68946: LD_INT 0
68948: PUSH
68949: LD_INT 2
68951: NEG
68952: PUSH
68953: EMPTY
68954: LIST
68955: LIST
68956: PUSH
68957: LD_INT 1
68959: PUSH
68960: LD_INT 1
68962: NEG
68963: PUSH
68964: EMPTY
68965: LIST
68966: LIST
68967: PUSH
68968: LD_INT 2
68970: PUSH
68971: LD_INT 0
68973: PUSH
68974: EMPTY
68975: LIST
68976: LIST
68977: PUSH
68978: LD_INT 2
68980: PUSH
68981: LD_INT 1
68983: PUSH
68984: EMPTY
68985: LIST
68986: LIST
68987: PUSH
68988: LD_INT 2
68990: PUSH
68991: LD_INT 2
68993: PUSH
68994: EMPTY
68995: LIST
68996: LIST
68997: PUSH
68998: LD_INT 1
69000: PUSH
69001: LD_INT 2
69003: PUSH
69004: EMPTY
69005: LIST
69006: LIST
69007: PUSH
69008: LD_INT 0
69010: PUSH
69011: LD_INT 2
69013: PUSH
69014: EMPTY
69015: LIST
69016: LIST
69017: PUSH
69018: LD_INT 1
69020: NEG
69021: PUSH
69022: LD_INT 1
69024: PUSH
69025: EMPTY
69026: LIST
69027: LIST
69028: PUSH
69029: LD_INT 2
69031: NEG
69032: PUSH
69033: LD_INT 0
69035: PUSH
69036: EMPTY
69037: LIST
69038: LIST
69039: PUSH
69040: LD_INT 2
69042: NEG
69043: PUSH
69044: LD_INT 1
69046: NEG
69047: PUSH
69048: EMPTY
69049: LIST
69050: LIST
69051: PUSH
69052: LD_INT 2
69054: NEG
69055: PUSH
69056: LD_INT 2
69058: NEG
69059: PUSH
69060: EMPTY
69061: LIST
69062: LIST
69063: PUSH
69064: LD_INT 2
69066: NEG
69067: PUSH
69068: LD_INT 3
69070: NEG
69071: PUSH
69072: EMPTY
69073: LIST
69074: LIST
69075: PUSH
69076: LD_INT 1
69078: NEG
69079: PUSH
69080: LD_INT 3
69082: NEG
69083: PUSH
69084: EMPTY
69085: LIST
69086: LIST
69087: PUSH
69088: LD_INT 1
69090: PUSH
69091: LD_INT 2
69093: NEG
69094: PUSH
69095: EMPTY
69096: LIST
69097: LIST
69098: PUSH
69099: LD_INT 2
69101: PUSH
69102: LD_INT 1
69104: NEG
69105: PUSH
69106: EMPTY
69107: LIST
69108: LIST
69109: PUSH
69110: EMPTY
69111: LIST
69112: LIST
69113: LIST
69114: LIST
69115: LIST
69116: LIST
69117: LIST
69118: LIST
69119: LIST
69120: LIST
69121: LIST
69122: LIST
69123: LIST
69124: LIST
69125: LIST
69126: LIST
69127: LIST
69128: LIST
69129: LIST
69130: LIST
69131: LIST
69132: LIST
69133: LIST
69134: ST_TO_ADDR
// fDepotRu1 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ 1 , - 2 ] , [ 2 , - 1 ] , [ 3 , 1 ] , [ 3 , 2 ] ] ;
69135: LD_ADDR_VAR 0 24
69139: PUSH
69140: LD_INT 0
69142: PUSH
69143: LD_INT 0
69145: PUSH
69146: EMPTY
69147: LIST
69148: LIST
69149: PUSH
69150: LD_INT 0
69152: PUSH
69153: LD_INT 1
69155: NEG
69156: PUSH
69157: EMPTY
69158: LIST
69159: LIST
69160: PUSH
69161: LD_INT 1
69163: PUSH
69164: LD_INT 0
69166: PUSH
69167: EMPTY
69168: LIST
69169: LIST
69170: PUSH
69171: LD_INT 1
69173: PUSH
69174: LD_INT 1
69176: PUSH
69177: EMPTY
69178: LIST
69179: LIST
69180: PUSH
69181: LD_INT 0
69183: PUSH
69184: LD_INT 1
69186: PUSH
69187: EMPTY
69188: LIST
69189: LIST
69190: PUSH
69191: LD_INT 1
69193: NEG
69194: PUSH
69195: LD_INT 0
69197: PUSH
69198: EMPTY
69199: LIST
69200: LIST
69201: PUSH
69202: LD_INT 1
69204: NEG
69205: PUSH
69206: LD_INT 1
69208: NEG
69209: PUSH
69210: EMPTY
69211: LIST
69212: LIST
69213: PUSH
69214: LD_INT 1
69216: NEG
69217: PUSH
69218: LD_INT 2
69220: NEG
69221: PUSH
69222: EMPTY
69223: LIST
69224: LIST
69225: PUSH
69226: LD_INT 0
69228: PUSH
69229: LD_INT 2
69231: NEG
69232: PUSH
69233: EMPTY
69234: LIST
69235: LIST
69236: PUSH
69237: LD_INT 1
69239: PUSH
69240: LD_INT 1
69242: NEG
69243: PUSH
69244: EMPTY
69245: LIST
69246: LIST
69247: PUSH
69248: LD_INT 2
69250: PUSH
69251: LD_INT 0
69253: PUSH
69254: EMPTY
69255: LIST
69256: LIST
69257: PUSH
69258: LD_INT 2
69260: PUSH
69261: LD_INT 1
69263: PUSH
69264: EMPTY
69265: LIST
69266: LIST
69267: PUSH
69268: LD_INT 2
69270: PUSH
69271: LD_INT 2
69273: PUSH
69274: EMPTY
69275: LIST
69276: LIST
69277: PUSH
69278: LD_INT 1
69280: PUSH
69281: LD_INT 2
69283: PUSH
69284: EMPTY
69285: LIST
69286: LIST
69287: PUSH
69288: LD_INT 0
69290: PUSH
69291: LD_INT 2
69293: PUSH
69294: EMPTY
69295: LIST
69296: LIST
69297: PUSH
69298: LD_INT 1
69300: NEG
69301: PUSH
69302: LD_INT 1
69304: PUSH
69305: EMPTY
69306: LIST
69307: LIST
69308: PUSH
69309: LD_INT 2
69311: NEG
69312: PUSH
69313: LD_INT 0
69315: PUSH
69316: EMPTY
69317: LIST
69318: LIST
69319: PUSH
69320: LD_INT 2
69322: NEG
69323: PUSH
69324: LD_INT 1
69326: NEG
69327: PUSH
69328: EMPTY
69329: LIST
69330: LIST
69331: PUSH
69332: LD_INT 2
69334: NEG
69335: PUSH
69336: LD_INT 2
69338: NEG
69339: PUSH
69340: EMPTY
69341: LIST
69342: LIST
69343: PUSH
69344: LD_INT 1
69346: PUSH
69347: LD_INT 2
69349: NEG
69350: PUSH
69351: EMPTY
69352: LIST
69353: LIST
69354: PUSH
69355: LD_INT 2
69357: PUSH
69358: LD_INT 1
69360: NEG
69361: PUSH
69362: EMPTY
69363: LIST
69364: LIST
69365: PUSH
69366: LD_INT 3
69368: PUSH
69369: LD_INT 1
69371: PUSH
69372: EMPTY
69373: LIST
69374: LIST
69375: PUSH
69376: LD_INT 3
69378: PUSH
69379: LD_INT 2
69381: PUSH
69382: EMPTY
69383: LIST
69384: LIST
69385: PUSH
69386: EMPTY
69387: LIST
69388: LIST
69389: LIST
69390: LIST
69391: LIST
69392: LIST
69393: LIST
69394: LIST
69395: LIST
69396: LIST
69397: LIST
69398: LIST
69399: LIST
69400: LIST
69401: LIST
69402: LIST
69403: LIST
69404: LIST
69405: LIST
69406: LIST
69407: LIST
69408: LIST
69409: LIST
69410: ST_TO_ADDR
// fDepotRu2 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ 3 , 1 ] , [ 3 , 2 ] , [ 2 , 3 ] , [ 1 , 3 ] ] ;
69411: LD_ADDR_VAR 0 25
69415: PUSH
69416: LD_INT 0
69418: PUSH
69419: LD_INT 0
69421: PUSH
69422: EMPTY
69423: LIST
69424: LIST
69425: PUSH
69426: LD_INT 0
69428: PUSH
69429: LD_INT 1
69431: NEG
69432: PUSH
69433: EMPTY
69434: LIST
69435: LIST
69436: PUSH
69437: LD_INT 1
69439: PUSH
69440: LD_INT 0
69442: PUSH
69443: EMPTY
69444: LIST
69445: LIST
69446: PUSH
69447: LD_INT 1
69449: PUSH
69450: LD_INT 1
69452: PUSH
69453: EMPTY
69454: LIST
69455: LIST
69456: PUSH
69457: LD_INT 0
69459: PUSH
69460: LD_INT 1
69462: PUSH
69463: EMPTY
69464: LIST
69465: LIST
69466: PUSH
69467: LD_INT 1
69469: NEG
69470: PUSH
69471: LD_INT 0
69473: PUSH
69474: EMPTY
69475: LIST
69476: LIST
69477: PUSH
69478: LD_INT 1
69480: NEG
69481: PUSH
69482: LD_INT 1
69484: NEG
69485: PUSH
69486: EMPTY
69487: LIST
69488: LIST
69489: PUSH
69490: LD_INT 1
69492: NEG
69493: PUSH
69494: LD_INT 2
69496: NEG
69497: PUSH
69498: EMPTY
69499: LIST
69500: LIST
69501: PUSH
69502: LD_INT 0
69504: PUSH
69505: LD_INT 2
69507: NEG
69508: PUSH
69509: EMPTY
69510: LIST
69511: LIST
69512: PUSH
69513: LD_INT 1
69515: PUSH
69516: LD_INT 1
69518: NEG
69519: PUSH
69520: EMPTY
69521: LIST
69522: LIST
69523: PUSH
69524: LD_INT 2
69526: PUSH
69527: LD_INT 0
69529: PUSH
69530: EMPTY
69531: LIST
69532: LIST
69533: PUSH
69534: LD_INT 2
69536: PUSH
69537: LD_INT 1
69539: PUSH
69540: EMPTY
69541: LIST
69542: LIST
69543: PUSH
69544: LD_INT 2
69546: PUSH
69547: LD_INT 2
69549: PUSH
69550: EMPTY
69551: LIST
69552: LIST
69553: PUSH
69554: LD_INT 1
69556: PUSH
69557: LD_INT 2
69559: PUSH
69560: EMPTY
69561: LIST
69562: LIST
69563: PUSH
69564: LD_INT 0
69566: PUSH
69567: LD_INT 2
69569: PUSH
69570: EMPTY
69571: LIST
69572: LIST
69573: PUSH
69574: LD_INT 1
69576: NEG
69577: PUSH
69578: LD_INT 1
69580: PUSH
69581: EMPTY
69582: LIST
69583: LIST
69584: PUSH
69585: LD_INT 2
69587: NEG
69588: PUSH
69589: LD_INT 0
69591: PUSH
69592: EMPTY
69593: LIST
69594: LIST
69595: PUSH
69596: LD_INT 2
69598: NEG
69599: PUSH
69600: LD_INT 1
69602: NEG
69603: PUSH
69604: EMPTY
69605: LIST
69606: LIST
69607: PUSH
69608: LD_INT 2
69610: NEG
69611: PUSH
69612: LD_INT 2
69614: NEG
69615: PUSH
69616: EMPTY
69617: LIST
69618: LIST
69619: PUSH
69620: LD_INT 3
69622: PUSH
69623: LD_INT 1
69625: PUSH
69626: EMPTY
69627: LIST
69628: LIST
69629: PUSH
69630: LD_INT 3
69632: PUSH
69633: LD_INT 2
69635: PUSH
69636: EMPTY
69637: LIST
69638: LIST
69639: PUSH
69640: LD_INT 2
69642: PUSH
69643: LD_INT 3
69645: PUSH
69646: EMPTY
69647: LIST
69648: LIST
69649: PUSH
69650: LD_INT 1
69652: PUSH
69653: LD_INT 3
69655: PUSH
69656: EMPTY
69657: LIST
69658: LIST
69659: PUSH
69660: EMPTY
69661: LIST
69662: LIST
69663: LIST
69664: LIST
69665: LIST
69666: LIST
69667: LIST
69668: LIST
69669: LIST
69670: LIST
69671: LIST
69672: LIST
69673: LIST
69674: LIST
69675: LIST
69676: LIST
69677: LIST
69678: LIST
69679: LIST
69680: LIST
69681: LIST
69682: LIST
69683: LIST
69684: ST_TO_ADDR
// fDepotRu3 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ 2 , 3 ] , [ 1 , 3 ] , [ - 1 , 2 ] , [ - 2 , 1 ] ] ;
69685: LD_ADDR_VAR 0 26
69689: PUSH
69690: LD_INT 0
69692: PUSH
69693: LD_INT 0
69695: PUSH
69696: EMPTY
69697: LIST
69698: LIST
69699: PUSH
69700: LD_INT 0
69702: PUSH
69703: LD_INT 1
69705: NEG
69706: PUSH
69707: EMPTY
69708: LIST
69709: LIST
69710: PUSH
69711: LD_INT 1
69713: PUSH
69714: LD_INT 0
69716: PUSH
69717: EMPTY
69718: LIST
69719: LIST
69720: PUSH
69721: LD_INT 1
69723: PUSH
69724: LD_INT 1
69726: PUSH
69727: EMPTY
69728: LIST
69729: LIST
69730: PUSH
69731: LD_INT 0
69733: PUSH
69734: LD_INT 1
69736: PUSH
69737: EMPTY
69738: LIST
69739: LIST
69740: PUSH
69741: LD_INT 1
69743: NEG
69744: PUSH
69745: LD_INT 0
69747: PUSH
69748: EMPTY
69749: LIST
69750: LIST
69751: PUSH
69752: LD_INT 1
69754: NEG
69755: PUSH
69756: LD_INT 1
69758: NEG
69759: PUSH
69760: EMPTY
69761: LIST
69762: LIST
69763: PUSH
69764: LD_INT 1
69766: NEG
69767: PUSH
69768: LD_INT 2
69770: NEG
69771: PUSH
69772: EMPTY
69773: LIST
69774: LIST
69775: PUSH
69776: LD_INT 0
69778: PUSH
69779: LD_INT 2
69781: NEG
69782: PUSH
69783: EMPTY
69784: LIST
69785: LIST
69786: PUSH
69787: LD_INT 1
69789: PUSH
69790: LD_INT 1
69792: NEG
69793: PUSH
69794: EMPTY
69795: LIST
69796: LIST
69797: PUSH
69798: LD_INT 2
69800: PUSH
69801: LD_INT 0
69803: PUSH
69804: EMPTY
69805: LIST
69806: LIST
69807: PUSH
69808: LD_INT 2
69810: PUSH
69811: LD_INT 1
69813: PUSH
69814: EMPTY
69815: LIST
69816: LIST
69817: PUSH
69818: LD_INT 2
69820: PUSH
69821: LD_INT 2
69823: PUSH
69824: EMPTY
69825: LIST
69826: LIST
69827: PUSH
69828: LD_INT 1
69830: PUSH
69831: LD_INT 2
69833: PUSH
69834: EMPTY
69835: LIST
69836: LIST
69837: PUSH
69838: LD_INT 0
69840: PUSH
69841: LD_INT 2
69843: PUSH
69844: EMPTY
69845: LIST
69846: LIST
69847: PUSH
69848: LD_INT 1
69850: NEG
69851: PUSH
69852: LD_INT 1
69854: PUSH
69855: EMPTY
69856: LIST
69857: LIST
69858: PUSH
69859: LD_INT 2
69861: NEG
69862: PUSH
69863: LD_INT 0
69865: PUSH
69866: EMPTY
69867: LIST
69868: LIST
69869: PUSH
69870: LD_INT 2
69872: NEG
69873: PUSH
69874: LD_INT 1
69876: NEG
69877: PUSH
69878: EMPTY
69879: LIST
69880: LIST
69881: PUSH
69882: LD_INT 2
69884: NEG
69885: PUSH
69886: LD_INT 2
69888: NEG
69889: PUSH
69890: EMPTY
69891: LIST
69892: LIST
69893: PUSH
69894: LD_INT 2
69896: PUSH
69897: LD_INT 3
69899: PUSH
69900: EMPTY
69901: LIST
69902: LIST
69903: PUSH
69904: LD_INT 1
69906: PUSH
69907: LD_INT 3
69909: PUSH
69910: EMPTY
69911: LIST
69912: LIST
69913: PUSH
69914: LD_INT 1
69916: NEG
69917: PUSH
69918: LD_INT 2
69920: PUSH
69921: EMPTY
69922: LIST
69923: LIST
69924: PUSH
69925: LD_INT 2
69927: NEG
69928: PUSH
69929: LD_INT 1
69931: PUSH
69932: EMPTY
69933: LIST
69934: LIST
69935: PUSH
69936: EMPTY
69937: LIST
69938: LIST
69939: LIST
69940: LIST
69941: LIST
69942: LIST
69943: LIST
69944: LIST
69945: LIST
69946: LIST
69947: LIST
69948: LIST
69949: LIST
69950: LIST
69951: LIST
69952: LIST
69953: LIST
69954: LIST
69955: LIST
69956: LIST
69957: LIST
69958: LIST
69959: LIST
69960: ST_TO_ADDR
// fDepotRu4 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ - 1 , 2 ] , [ - 2 , 1 ] , [ - 3 , - 1 ] , [ - 3 , - 2 ] ] ;
69961: LD_ADDR_VAR 0 27
69965: PUSH
69966: LD_INT 0
69968: PUSH
69969: LD_INT 0
69971: PUSH
69972: EMPTY
69973: LIST
69974: LIST
69975: PUSH
69976: LD_INT 0
69978: PUSH
69979: LD_INT 1
69981: NEG
69982: PUSH
69983: EMPTY
69984: LIST
69985: LIST
69986: PUSH
69987: LD_INT 1
69989: PUSH
69990: LD_INT 0
69992: PUSH
69993: EMPTY
69994: LIST
69995: LIST
69996: PUSH
69997: LD_INT 1
69999: PUSH
70000: LD_INT 1
70002: PUSH
70003: EMPTY
70004: LIST
70005: LIST
70006: PUSH
70007: LD_INT 0
70009: PUSH
70010: LD_INT 1
70012: PUSH
70013: EMPTY
70014: LIST
70015: LIST
70016: PUSH
70017: LD_INT 1
70019: NEG
70020: PUSH
70021: LD_INT 0
70023: PUSH
70024: EMPTY
70025: LIST
70026: LIST
70027: PUSH
70028: LD_INT 1
70030: NEG
70031: PUSH
70032: LD_INT 1
70034: NEG
70035: PUSH
70036: EMPTY
70037: LIST
70038: LIST
70039: PUSH
70040: LD_INT 1
70042: NEG
70043: PUSH
70044: LD_INT 2
70046: NEG
70047: PUSH
70048: EMPTY
70049: LIST
70050: LIST
70051: PUSH
70052: LD_INT 0
70054: PUSH
70055: LD_INT 2
70057: NEG
70058: PUSH
70059: EMPTY
70060: LIST
70061: LIST
70062: PUSH
70063: LD_INT 1
70065: PUSH
70066: LD_INT 1
70068: NEG
70069: PUSH
70070: EMPTY
70071: LIST
70072: LIST
70073: PUSH
70074: LD_INT 2
70076: PUSH
70077: LD_INT 0
70079: PUSH
70080: EMPTY
70081: LIST
70082: LIST
70083: PUSH
70084: LD_INT 2
70086: PUSH
70087: LD_INT 1
70089: PUSH
70090: EMPTY
70091: LIST
70092: LIST
70093: PUSH
70094: LD_INT 2
70096: PUSH
70097: LD_INT 2
70099: PUSH
70100: EMPTY
70101: LIST
70102: LIST
70103: PUSH
70104: LD_INT 1
70106: PUSH
70107: LD_INT 2
70109: PUSH
70110: EMPTY
70111: LIST
70112: LIST
70113: PUSH
70114: LD_INT 0
70116: PUSH
70117: LD_INT 2
70119: PUSH
70120: EMPTY
70121: LIST
70122: LIST
70123: PUSH
70124: LD_INT 1
70126: NEG
70127: PUSH
70128: LD_INT 1
70130: PUSH
70131: EMPTY
70132: LIST
70133: LIST
70134: PUSH
70135: LD_INT 2
70137: NEG
70138: PUSH
70139: LD_INT 0
70141: PUSH
70142: EMPTY
70143: LIST
70144: LIST
70145: PUSH
70146: LD_INT 2
70148: NEG
70149: PUSH
70150: LD_INT 1
70152: NEG
70153: PUSH
70154: EMPTY
70155: LIST
70156: LIST
70157: PUSH
70158: LD_INT 2
70160: NEG
70161: PUSH
70162: LD_INT 2
70164: NEG
70165: PUSH
70166: EMPTY
70167: LIST
70168: LIST
70169: PUSH
70170: LD_INT 1
70172: NEG
70173: PUSH
70174: LD_INT 2
70176: PUSH
70177: EMPTY
70178: LIST
70179: LIST
70180: PUSH
70181: LD_INT 2
70183: NEG
70184: PUSH
70185: LD_INT 1
70187: PUSH
70188: EMPTY
70189: LIST
70190: LIST
70191: PUSH
70192: LD_INT 3
70194: NEG
70195: PUSH
70196: LD_INT 1
70198: NEG
70199: PUSH
70200: EMPTY
70201: LIST
70202: LIST
70203: PUSH
70204: LD_INT 3
70206: NEG
70207: PUSH
70208: LD_INT 2
70210: NEG
70211: PUSH
70212: EMPTY
70213: LIST
70214: LIST
70215: PUSH
70216: EMPTY
70217: LIST
70218: LIST
70219: LIST
70220: LIST
70221: LIST
70222: LIST
70223: LIST
70224: LIST
70225: LIST
70226: LIST
70227: LIST
70228: LIST
70229: LIST
70230: LIST
70231: LIST
70232: LIST
70233: LIST
70234: LIST
70235: LIST
70236: LIST
70237: LIST
70238: LIST
70239: LIST
70240: ST_TO_ADDR
// fDepotRu5 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ - 2 , - 3 ] , [ - 1 , - 3 ] , [ - 3 , - 1 ] , [ - 3 , - 2 ] ] ;
70241: LD_ADDR_VAR 0 28
70245: PUSH
70246: LD_INT 0
70248: PUSH
70249: LD_INT 0
70251: PUSH
70252: EMPTY
70253: LIST
70254: LIST
70255: PUSH
70256: LD_INT 0
70258: PUSH
70259: LD_INT 1
70261: NEG
70262: PUSH
70263: EMPTY
70264: LIST
70265: LIST
70266: PUSH
70267: LD_INT 1
70269: PUSH
70270: LD_INT 0
70272: PUSH
70273: EMPTY
70274: LIST
70275: LIST
70276: PUSH
70277: LD_INT 1
70279: PUSH
70280: LD_INT 1
70282: PUSH
70283: EMPTY
70284: LIST
70285: LIST
70286: PUSH
70287: LD_INT 0
70289: PUSH
70290: LD_INT 1
70292: PUSH
70293: EMPTY
70294: LIST
70295: LIST
70296: PUSH
70297: LD_INT 1
70299: NEG
70300: PUSH
70301: LD_INT 0
70303: PUSH
70304: EMPTY
70305: LIST
70306: LIST
70307: PUSH
70308: LD_INT 1
70310: NEG
70311: PUSH
70312: LD_INT 1
70314: NEG
70315: PUSH
70316: EMPTY
70317: LIST
70318: LIST
70319: PUSH
70320: LD_INT 1
70322: NEG
70323: PUSH
70324: LD_INT 2
70326: NEG
70327: PUSH
70328: EMPTY
70329: LIST
70330: LIST
70331: PUSH
70332: LD_INT 0
70334: PUSH
70335: LD_INT 2
70337: NEG
70338: PUSH
70339: EMPTY
70340: LIST
70341: LIST
70342: PUSH
70343: LD_INT 1
70345: PUSH
70346: LD_INT 1
70348: NEG
70349: PUSH
70350: EMPTY
70351: LIST
70352: LIST
70353: PUSH
70354: LD_INT 2
70356: PUSH
70357: LD_INT 0
70359: PUSH
70360: EMPTY
70361: LIST
70362: LIST
70363: PUSH
70364: LD_INT 2
70366: PUSH
70367: LD_INT 1
70369: PUSH
70370: EMPTY
70371: LIST
70372: LIST
70373: PUSH
70374: LD_INT 2
70376: PUSH
70377: LD_INT 2
70379: PUSH
70380: EMPTY
70381: LIST
70382: LIST
70383: PUSH
70384: LD_INT 1
70386: PUSH
70387: LD_INT 2
70389: PUSH
70390: EMPTY
70391: LIST
70392: LIST
70393: PUSH
70394: LD_INT 0
70396: PUSH
70397: LD_INT 2
70399: PUSH
70400: EMPTY
70401: LIST
70402: LIST
70403: PUSH
70404: LD_INT 1
70406: NEG
70407: PUSH
70408: LD_INT 1
70410: PUSH
70411: EMPTY
70412: LIST
70413: LIST
70414: PUSH
70415: LD_INT 2
70417: NEG
70418: PUSH
70419: LD_INT 0
70421: PUSH
70422: EMPTY
70423: LIST
70424: LIST
70425: PUSH
70426: LD_INT 2
70428: NEG
70429: PUSH
70430: LD_INT 1
70432: NEG
70433: PUSH
70434: EMPTY
70435: LIST
70436: LIST
70437: PUSH
70438: LD_INT 2
70440: NEG
70441: PUSH
70442: LD_INT 2
70444: NEG
70445: PUSH
70446: EMPTY
70447: LIST
70448: LIST
70449: PUSH
70450: LD_INT 2
70452: NEG
70453: PUSH
70454: LD_INT 3
70456: NEG
70457: PUSH
70458: EMPTY
70459: LIST
70460: LIST
70461: PUSH
70462: LD_INT 1
70464: NEG
70465: PUSH
70466: LD_INT 3
70468: NEG
70469: PUSH
70470: EMPTY
70471: LIST
70472: LIST
70473: PUSH
70474: LD_INT 3
70476: NEG
70477: PUSH
70478: LD_INT 1
70480: NEG
70481: PUSH
70482: EMPTY
70483: LIST
70484: LIST
70485: PUSH
70486: LD_INT 3
70488: NEG
70489: PUSH
70490: LD_INT 2
70492: NEG
70493: PUSH
70494: EMPTY
70495: LIST
70496: LIST
70497: PUSH
70498: EMPTY
70499: LIST
70500: LIST
70501: LIST
70502: LIST
70503: LIST
70504: LIST
70505: LIST
70506: LIST
70507: LIST
70508: LIST
70509: LIST
70510: LIST
70511: LIST
70512: LIST
70513: LIST
70514: LIST
70515: LIST
70516: LIST
70517: LIST
70518: LIST
70519: LIST
70520: LIST
70521: LIST
70522: ST_TO_ADDR
// fFactory0 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ - 2 , - 3 ] , [ 2 , - 1 ] , [ 3 , 1 ] , [ 1 , 3 ] , [ - 1 , 2 ] , [ - 3 , - 2 ] ] ;
70523: LD_ADDR_VAR 0 29
70527: PUSH
70528: LD_INT 0
70530: PUSH
70531: LD_INT 0
70533: PUSH
70534: EMPTY
70535: LIST
70536: LIST
70537: PUSH
70538: LD_INT 0
70540: PUSH
70541: LD_INT 1
70543: NEG
70544: PUSH
70545: EMPTY
70546: LIST
70547: LIST
70548: PUSH
70549: LD_INT 1
70551: PUSH
70552: LD_INT 0
70554: PUSH
70555: EMPTY
70556: LIST
70557: LIST
70558: PUSH
70559: LD_INT 1
70561: PUSH
70562: LD_INT 1
70564: PUSH
70565: EMPTY
70566: LIST
70567: LIST
70568: PUSH
70569: LD_INT 0
70571: PUSH
70572: LD_INT 1
70574: PUSH
70575: EMPTY
70576: LIST
70577: LIST
70578: PUSH
70579: LD_INT 1
70581: NEG
70582: PUSH
70583: LD_INT 0
70585: PUSH
70586: EMPTY
70587: LIST
70588: LIST
70589: PUSH
70590: LD_INT 1
70592: NEG
70593: PUSH
70594: LD_INT 1
70596: NEG
70597: PUSH
70598: EMPTY
70599: LIST
70600: LIST
70601: PUSH
70602: LD_INT 1
70604: NEG
70605: PUSH
70606: LD_INT 2
70608: NEG
70609: PUSH
70610: EMPTY
70611: LIST
70612: LIST
70613: PUSH
70614: LD_INT 0
70616: PUSH
70617: LD_INT 2
70619: NEG
70620: PUSH
70621: EMPTY
70622: LIST
70623: LIST
70624: PUSH
70625: LD_INT 1
70627: PUSH
70628: LD_INT 1
70630: NEG
70631: PUSH
70632: EMPTY
70633: LIST
70634: LIST
70635: PUSH
70636: LD_INT 2
70638: PUSH
70639: LD_INT 0
70641: PUSH
70642: EMPTY
70643: LIST
70644: LIST
70645: PUSH
70646: LD_INT 2
70648: PUSH
70649: LD_INT 1
70651: PUSH
70652: EMPTY
70653: LIST
70654: LIST
70655: PUSH
70656: LD_INT 1
70658: PUSH
70659: LD_INT 2
70661: PUSH
70662: EMPTY
70663: LIST
70664: LIST
70665: PUSH
70666: LD_INT 0
70668: PUSH
70669: LD_INT 2
70671: PUSH
70672: EMPTY
70673: LIST
70674: LIST
70675: PUSH
70676: LD_INT 1
70678: NEG
70679: PUSH
70680: LD_INT 1
70682: PUSH
70683: EMPTY
70684: LIST
70685: LIST
70686: PUSH
70687: LD_INT 2
70689: NEG
70690: PUSH
70691: LD_INT 1
70693: NEG
70694: PUSH
70695: EMPTY
70696: LIST
70697: LIST
70698: PUSH
70699: LD_INT 2
70701: NEG
70702: PUSH
70703: LD_INT 2
70705: NEG
70706: PUSH
70707: EMPTY
70708: LIST
70709: LIST
70710: PUSH
70711: LD_INT 2
70713: NEG
70714: PUSH
70715: LD_INT 3
70717: NEG
70718: PUSH
70719: EMPTY
70720: LIST
70721: LIST
70722: PUSH
70723: LD_INT 2
70725: PUSH
70726: LD_INT 1
70728: NEG
70729: PUSH
70730: EMPTY
70731: LIST
70732: LIST
70733: PUSH
70734: LD_INT 3
70736: PUSH
70737: LD_INT 1
70739: PUSH
70740: EMPTY
70741: LIST
70742: LIST
70743: PUSH
70744: LD_INT 1
70746: PUSH
70747: LD_INT 3
70749: PUSH
70750: EMPTY
70751: LIST
70752: LIST
70753: PUSH
70754: LD_INT 1
70756: NEG
70757: PUSH
70758: LD_INT 2
70760: PUSH
70761: EMPTY
70762: LIST
70763: LIST
70764: PUSH
70765: LD_INT 3
70767: NEG
70768: PUSH
70769: LD_INT 2
70771: NEG
70772: PUSH
70773: EMPTY
70774: LIST
70775: LIST
70776: PUSH
70777: EMPTY
70778: LIST
70779: LIST
70780: LIST
70781: LIST
70782: LIST
70783: LIST
70784: LIST
70785: LIST
70786: LIST
70787: LIST
70788: LIST
70789: LIST
70790: LIST
70791: LIST
70792: LIST
70793: LIST
70794: LIST
70795: LIST
70796: LIST
70797: LIST
70798: LIST
70799: LIST
70800: LIST
70801: ST_TO_ADDR
// fFactory1 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 1 , - 3 ] , [ 1 , - 2 ] , [ 3 , 2 ] , [ 2 , 3 ] , [ - 2 , 1 ] , [ - 3 , - 1 ] ] ;
70802: LD_ADDR_VAR 0 30
70806: PUSH
70807: LD_INT 0
70809: PUSH
70810: LD_INT 0
70812: PUSH
70813: EMPTY
70814: LIST
70815: LIST
70816: PUSH
70817: LD_INT 0
70819: PUSH
70820: LD_INT 1
70822: NEG
70823: PUSH
70824: EMPTY
70825: LIST
70826: LIST
70827: PUSH
70828: LD_INT 1
70830: PUSH
70831: LD_INT 0
70833: PUSH
70834: EMPTY
70835: LIST
70836: LIST
70837: PUSH
70838: LD_INT 1
70840: PUSH
70841: LD_INT 1
70843: PUSH
70844: EMPTY
70845: LIST
70846: LIST
70847: PUSH
70848: LD_INT 0
70850: PUSH
70851: LD_INT 1
70853: PUSH
70854: EMPTY
70855: LIST
70856: LIST
70857: PUSH
70858: LD_INT 1
70860: NEG
70861: PUSH
70862: LD_INT 0
70864: PUSH
70865: EMPTY
70866: LIST
70867: LIST
70868: PUSH
70869: LD_INT 1
70871: NEG
70872: PUSH
70873: LD_INT 1
70875: NEG
70876: PUSH
70877: EMPTY
70878: LIST
70879: LIST
70880: PUSH
70881: LD_INT 1
70883: NEG
70884: PUSH
70885: LD_INT 2
70887: NEG
70888: PUSH
70889: EMPTY
70890: LIST
70891: LIST
70892: PUSH
70893: LD_INT 0
70895: PUSH
70896: LD_INT 2
70898: NEG
70899: PUSH
70900: EMPTY
70901: LIST
70902: LIST
70903: PUSH
70904: LD_INT 1
70906: PUSH
70907: LD_INT 1
70909: NEG
70910: PUSH
70911: EMPTY
70912: LIST
70913: LIST
70914: PUSH
70915: LD_INT 2
70917: PUSH
70918: LD_INT 0
70920: PUSH
70921: EMPTY
70922: LIST
70923: LIST
70924: PUSH
70925: LD_INT 2
70927: PUSH
70928: LD_INT 1
70930: PUSH
70931: EMPTY
70932: LIST
70933: LIST
70934: PUSH
70935: LD_INT 2
70937: PUSH
70938: LD_INT 2
70940: PUSH
70941: EMPTY
70942: LIST
70943: LIST
70944: PUSH
70945: LD_INT 1
70947: PUSH
70948: LD_INT 2
70950: PUSH
70951: EMPTY
70952: LIST
70953: LIST
70954: PUSH
70955: LD_INT 1
70957: NEG
70958: PUSH
70959: LD_INT 1
70961: PUSH
70962: EMPTY
70963: LIST
70964: LIST
70965: PUSH
70966: LD_INT 2
70968: NEG
70969: PUSH
70970: LD_INT 0
70972: PUSH
70973: EMPTY
70974: LIST
70975: LIST
70976: PUSH
70977: LD_INT 2
70979: NEG
70980: PUSH
70981: LD_INT 1
70983: NEG
70984: PUSH
70985: EMPTY
70986: LIST
70987: LIST
70988: PUSH
70989: LD_INT 1
70991: NEG
70992: PUSH
70993: LD_INT 3
70995: NEG
70996: PUSH
70997: EMPTY
70998: LIST
70999: LIST
71000: PUSH
71001: LD_INT 1
71003: PUSH
71004: LD_INT 2
71006: NEG
71007: PUSH
71008: EMPTY
71009: LIST
71010: LIST
71011: PUSH
71012: LD_INT 3
71014: PUSH
71015: LD_INT 2
71017: PUSH
71018: EMPTY
71019: LIST
71020: LIST
71021: PUSH
71022: LD_INT 2
71024: PUSH
71025: LD_INT 3
71027: PUSH
71028: EMPTY
71029: LIST
71030: LIST
71031: PUSH
71032: LD_INT 2
71034: NEG
71035: PUSH
71036: LD_INT 1
71038: PUSH
71039: EMPTY
71040: LIST
71041: LIST
71042: PUSH
71043: LD_INT 3
71045: NEG
71046: PUSH
71047: LD_INT 1
71049: NEG
71050: PUSH
71051: EMPTY
71052: LIST
71053: LIST
71054: PUSH
71055: EMPTY
71056: LIST
71057: LIST
71058: LIST
71059: LIST
71060: LIST
71061: LIST
71062: LIST
71063: LIST
71064: LIST
71065: LIST
71066: LIST
71067: LIST
71068: LIST
71069: LIST
71070: LIST
71071: LIST
71072: LIST
71073: LIST
71074: LIST
71075: LIST
71076: LIST
71077: LIST
71078: LIST
71079: ST_TO_ADDR
// fFactory2 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ - 2 , - 3 ] , [ 2 , - 1 ] , [ 3 , 1 ] , [ 1 , 3 ] , [ - 1 , 2 ] , [ - 3 , - 2 ] ] ;
71080: LD_ADDR_VAR 0 31
71084: PUSH
71085: LD_INT 0
71087: PUSH
71088: LD_INT 0
71090: PUSH
71091: EMPTY
71092: LIST
71093: LIST
71094: PUSH
71095: LD_INT 0
71097: PUSH
71098: LD_INT 1
71100: NEG
71101: PUSH
71102: EMPTY
71103: LIST
71104: LIST
71105: PUSH
71106: LD_INT 1
71108: PUSH
71109: LD_INT 0
71111: PUSH
71112: EMPTY
71113: LIST
71114: LIST
71115: PUSH
71116: LD_INT 1
71118: PUSH
71119: LD_INT 1
71121: PUSH
71122: EMPTY
71123: LIST
71124: LIST
71125: PUSH
71126: LD_INT 0
71128: PUSH
71129: LD_INT 1
71131: PUSH
71132: EMPTY
71133: LIST
71134: LIST
71135: PUSH
71136: LD_INT 1
71138: NEG
71139: PUSH
71140: LD_INT 0
71142: PUSH
71143: EMPTY
71144: LIST
71145: LIST
71146: PUSH
71147: LD_INT 1
71149: NEG
71150: PUSH
71151: LD_INT 1
71153: NEG
71154: PUSH
71155: EMPTY
71156: LIST
71157: LIST
71158: PUSH
71159: LD_INT 1
71161: NEG
71162: PUSH
71163: LD_INT 2
71165: NEG
71166: PUSH
71167: EMPTY
71168: LIST
71169: LIST
71170: PUSH
71171: LD_INT 1
71173: PUSH
71174: LD_INT 1
71176: NEG
71177: PUSH
71178: EMPTY
71179: LIST
71180: LIST
71181: PUSH
71182: LD_INT 2
71184: PUSH
71185: LD_INT 0
71187: PUSH
71188: EMPTY
71189: LIST
71190: LIST
71191: PUSH
71192: LD_INT 2
71194: PUSH
71195: LD_INT 1
71197: PUSH
71198: EMPTY
71199: LIST
71200: LIST
71201: PUSH
71202: LD_INT 2
71204: PUSH
71205: LD_INT 2
71207: PUSH
71208: EMPTY
71209: LIST
71210: LIST
71211: PUSH
71212: LD_INT 1
71214: PUSH
71215: LD_INT 2
71217: PUSH
71218: EMPTY
71219: LIST
71220: LIST
71221: PUSH
71222: LD_INT 0
71224: PUSH
71225: LD_INT 2
71227: PUSH
71228: EMPTY
71229: LIST
71230: LIST
71231: PUSH
71232: LD_INT 1
71234: NEG
71235: PUSH
71236: LD_INT 1
71238: PUSH
71239: EMPTY
71240: LIST
71241: LIST
71242: PUSH
71243: LD_INT 2
71245: NEG
71246: PUSH
71247: LD_INT 1
71249: NEG
71250: PUSH
71251: EMPTY
71252: LIST
71253: LIST
71254: PUSH
71255: LD_INT 2
71257: NEG
71258: PUSH
71259: LD_INT 2
71261: NEG
71262: PUSH
71263: EMPTY
71264: LIST
71265: LIST
71266: PUSH
71267: LD_INT 2
71269: NEG
71270: PUSH
71271: LD_INT 3
71273: NEG
71274: PUSH
71275: EMPTY
71276: LIST
71277: LIST
71278: PUSH
71279: LD_INT 2
71281: PUSH
71282: LD_INT 1
71284: NEG
71285: PUSH
71286: EMPTY
71287: LIST
71288: LIST
71289: PUSH
71290: LD_INT 3
71292: PUSH
71293: LD_INT 1
71295: PUSH
71296: EMPTY
71297: LIST
71298: LIST
71299: PUSH
71300: LD_INT 1
71302: PUSH
71303: LD_INT 3
71305: PUSH
71306: EMPTY
71307: LIST
71308: LIST
71309: PUSH
71310: LD_INT 1
71312: NEG
71313: PUSH
71314: LD_INT 2
71316: PUSH
71317: EMPTY
71318: LIST
71319: LIST
71320: PUSH
71321: LD_INT 3
71323: NEG
71324: PUSH
71325: LD_INT 2
71327: NEG
71328: PUSH
71329: EMPTY
71330: LIST
71331: LIST
71332: PUSH
71333: EMPTY
71334: LIST
71335: LIST
71336: LIST
71337: LIST
71338: LIST
71339: LIST
71340: LIST
71341: LIST
71342: LIST
71343: LIST
71344: LIST
71345: LIST
71346: LIST
71347: LIST
71348: LIST
71349: LIST
71350: LIST
71351: LIST
71352: LIST
71353: LIST
71354: LIST
71355: LIST
71356: LIST
71357: ST_TO_ADDR
// fFactory3 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 1 , - 3 ] , [ 1 , - 2 ] , [ 3 , 2 ] , [ 2 , 3 ] , [ - 2 , 1 ] , [ - 3 , - 1 ] ] ;
71358: LD_ADDR_VAR 0 32
71362: PUSH
71363: LD_INT 0
71365: PUSH
71366: LD_INT 0
71368: PUSH
71369: EMPTY
71370: LIST
71371: LIST
71372: PUSH
71373: LD_INT 0
71375: PUSH
71376: LD_INT 1
71378: NEG
71379: PUSH
71380: EMPTY
71381: LIST
71382: LIST
71383: PUSH
71384: LD_INT 1
71386: PUSH
71387: LD_INT 0
71389: PUSH
71390: EMPTY
71391: LIST
71392: LIST
71393: PUSH
71394: LD_INT 1
71396: PUSH
71397: LD_INT 1
71399: PUSH
71400: EMPTY
71401: LIST
71402: LIST
71403: PUSH
71404: LD_INT 0
71406: PUSH
71407: LD_INT 1
71409: PUSH
71410: EMPTY
71411: LIST
71412: LIST
71413: PUSH
71414: LD_INT 1
71416: NEG
71417: PUSH
71418: LD_INT 0
71420: PUSH
71421: EMPTY
71422: LIST
71423: LIST
71424: PUSH
71425: LD_INT 1
71427: NEG
71428: PUSH
71429: LD_INT 1
71431: NEG
71432: PUSH
71433: EMPTY
71434: LIST
71435: LIST
71436: PUSH
71437: LD_INT 1
71439: NEG
71440: PUSH
71441: LD_INT 2
71443: NEG
71444: PUSH
71445: EMPTY
71446: LIST
71447: LIST
71448: PUSH
71449: LD_INT 0
71451: PUSH
71452: LD_INT 2
71454: NEG
71455: PUSH
71456: EMPTY
71457: LIST
71458: LIST
71459: PUSH
71460: LD_INT 1
71462: PUSH
71463: LD_INT 1
71465: NEG
71466: PUSH
71467: EMPTY
71468: LIST
71469: LIST
71470: PUSH
71471: LD_INT 2
71473: PUSH
71474: LD_INT 1
71476: PUSH
71477: EMPTY
71478: LIST
71479: LIST
71480: PUSH
71481: LD_INT 2
71483: PUSH
71484: LD_INT 2
71486: PUSH
71487: EMPTY
71488: LIST
71489: LIST
71490: PUSH
71491: LD_INT 1
71493: PUSH
71494: LD_INT 2
71496: PUSH
71497: EMPTY
71498: LIST
71499: LIST
71500: PUSH
71501: LD_INT 0
71503: PUSH
71504: LD_INT 2
71506: PUSH
71507: EMPTY
71508: LIST
71509: LIST
71510: PUSH
71511: LD_INT 1
71513: NEG
71514: PUSH
71515: LD_INT 1
71517: PUSH
71518: EMPTY
71519: LIST
71520: LIST
71521: PUSH
71522: LD_INT 2
71524: NEG
71525: PUSH
71526: LD_INT 0
71528: PUSH
71529: EMPTY
71530: LIST
71531: LIST
71532: PUSH
71533: LD_INT 2
71535: NEG
71536: PUSH
71537: LD_INT 1
71539: NEG
71540: PUSH
71541: EMPTY
71542: LIST
71543: LIST
71544: PUSH
71545: LD_INT 1
71547: NEG
71548: PUSH
71549: LD_INT 3
71551: NEG
71552: PUSH
71553: EMPTY
71554: LIST
71555: LIST
71556: PUSH
71557: LD_INT 1
71559: PUSH
71560: LD_INT 2
71562: NEG
71563: PUSH
71564: EMPTY
71565: LIST
71566: LIST
71567: PUSH
71568: LD_INT 3
71570: PUSH
71571: LD_INT 2
71573: PUSH
71574: EMPTY
71575: LIST
71576: LIST
71577: PUSH
71578: LD_INT 2
71580: PUSH
71581: LD_INT 3
71583: PUSH
71584: EMPTY
71585: LIST
71586: LIST
71587: PUSH
71588: LD_INT 2
71590: NEG
71591: PUSH
71592: LD_INT 1
71594: PUSH
71595: EMPTY
71596: LIST
71597: LIST
71598: PUSH
71599: LD_INT 3
71601: NEG
71602: PUSH
71603: LD_INT 1
71605: NEG
71606: PUSH
71607: EMPTY
71608: LIST
71609: LIST
71610: PUSH
71611: EMPTY
71612: LIST
71613: LIST
71614: LIST
71615: LIST
71616: LIST
71617: LIST
71618: LIST
71619: LIST
71620: LIST
71621: LIST
71622: LIST
71623: LIST
71624: LIST
71625: LIST
71626: LIST
71627: LIST
71628: LIST
71629: LIST
71630: LIST
71631: LIST
71632: LIST
71633: LIST
71634: LIST
71635: ST_TO_ADDR
// fFactory4 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ - 2 , - 3 ] , [ 2 , - 1 ] , [ 3 , 1 ] , [ 1 , 3 ] , [ - 1 , 2 ] , [ - 3 , - 2 ] ] ;
71636: LD_ADDR_VAR 0 33
71640: PUSH
71641: LD_INT 0
71643: PUSH
71644: LD_INT 0
71646: PUSH
71647: EMPTY
71648: LIST
71649: LIST
71650: PUSH
71651: LD_INT 0
71653: PUSH
71654: LD_INT 1
71656: NEG
71657: PUSH
71658: EMPTY
71659: LIST
71660: LIST
71661: PUSH
71662: LD_INT 1
71664: PUSH
71665: LD_INT 0
71667: PUSH
71668: EMPTY
71669: LIST
71670: LIST
71671: PUSH
71672: LD_INT 1
71674: PUSH
71675: LD_INT 1
71677: PUSH
71678: EMPTY
71679: LIST
71680: LIST
71681: PUSH
71682: LD_INT 0
71684: PUSH
71685: LD_INT 1
71687: PUSH
71688: EMPTY
71689: LIST
71690: LIST
71691: PUSH
71692: LD_INT 1
71694: NEG
71695: PUSH
71696: LD_INT 0
71698: PUSH
71699: EMPTY
71700: LIST
71701: LIST
71702: PUSH
71703: LD_INT 1
71705: NEG
71706: PUSH
71707: LD_INT 1
71709: NEG
71710: PUSH
71711: EMPTY
71712: LIST
71713: LIST
71714: PUSH
71715: LD_INT 1
71717: NEG
71718: PUSH
71719: LD_INT 2
71721: NEG
71722: PUSH
71723: EMPTY
71724: LIST
71725: LIST
71726: PUSH
71727: LD_INT 1
71729: PUSH
71730: LD_INT 1
71732: NEG
71733: PUSH
71734: EMPTY
71735: LIST
71736: LIST
71737: PUSH
71738: LD_INT 2
71740: PUSH
71741: LD_INT 0
71743: PUSH
71744: EMPTY
71745: LIST
71746: LIST
71747: PUSH
71748: LD_INT 2
71750: PUSH
71751: LD_INT 1
71753: PUSH
71754: EMPTY
71755: LIST
71756: LIST
71757: PUSH
71758: LD_INT 1
71760: PUSH
71761: LD_INT 2
71763: PUSH
71764: EMPTY
71765: LIST
71766: LIST
71767: PUSH
71768: LD_INT 0
71770: PUSH
71771: LD_INT 2
71773: PUSH
71774: EMPTY
71775: LIST
71776: LIST
71777: PUSH
71778: LD_INT 1
71780: NEG
71781: PUSH
71782: LD_INT 1
71784: PUSH
71785: EMPTY
71786: LIST
71787: LIST
71788: PUSH
71789: LD_INT 2
71791: NEG
71792: PUSH
71793: LD_INT 0
71795: PUSH
71796: EMPTY
71797: LIST
71798: LIST
71799: PUSH
71800: LD_INT 2
71802: NEG
71803: PUSH
71804: LD_INT 1
71806: NEG
71807: PUSH
71808: EMPTY
71809: LIST
71810: LIST
71811: PUSH
71812: LD_INT 2
71814: NEG
71815: PUSH
71816: LD_INT 2
71818: NEG
71819: PUSH
71820: EMPTY
71821: LIST
71822: LIST
71823: PUSH
71824: LD_INT 2
71826: NEG
71827: PUSH
71828: LD_INT 3
71830: NEG
71831: PUSH
71832: EMPTY
71833: LIST
71834: LIST
71835: PUSH
71836: LD_INT 2
71838: PUSH
71839: LD_INT 1
71841: NEG
71842: PUSH
71843: EMPTY
71844: LIST
71845: LIST
71846: PUSH
71847: LD_INT 3
71849: PUSH
71850: LD_INT 1
71852: PUSH
71853: EMPTY
71854: LIST
71855: LIST
71856: PUSH
71857: LD_INT 1
71859: PUSH
71860: LD_INT 3
71862: PUSH
71863: EMPTY
71864: LIST
71865: LIST
71866: PUSH
71867: LD_INT 1
71869: NEG
71870: PUSH
71871: LD_INT 2
71873: PUSH
71874: EMPTY
71875: LIST
71876: LIST
71877: PUSH
71878: LD_INT 3
71880: NEG
71881: PUSH
71882: LD_INT 2
71884: NEG
71885: PUSH
71886: EMPTY
71887: LIST
71888: LIST
71889: PUSH
71890: EMPTY
71891: LIST
71892: LIST
71893: LIST
71894: LIST
71895: LIST
71896: LIST
71897: LIST
71898: LIST
71899: LIST
71900: LIST
71901: LIST
71902: LIST
71903: LIST
71904: LIST
71905: LIST
71906: LIST
71907: LIST
71908: LIST
71909: LIST
71910: LIST
71911: LIST
71912: LIST
71913: LIST
71914: ST_TO_ADDR
// fFactory5 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ - 1 , - 3 ] , [ 1 , - 2 ] , [ 3 , 2 ] , [ 2 , 3 ] , [ - 2 , 1 ] , [ - 3 , - 1 ] ] ;
71915: LD_ADDR_VAR 0 34
71919: PUSH
71920: LD_INT 0
71922: PUSH
71923: LD_INT 0
71925: PUSH
71926: EMPTY
71927: LIST
71928: LIST
71929: PUSH
71930: LD_INT 0
71932: PUSH
71933: LD_INT 1
71935: NEG
71936: PUSH
71937: EMPTY
71938: LIST
71939: LIST
71940: PUSH
71941: LD_INT 1
71943: PUSH
71944: LD_INT 0
71946: PUSH
71947: EMPTY
71948: LIST
71949: LIST
71950: PUSH
71951: LD_INT 1
71953: PUSH
71954: LD_INT 1
71956: PUSH
71957: EMPTY
71958: LIST
71959: LIST
71960: PUSH
71961: LD_INT 0
71963: PUSH
71964: LD_INT 1
71966: PUSH
71967: EMPTY
71968: LIST
71969: LIST
71970: PUSH
71971: LD_INT 1
71973: NEG
71974: PUSH
71975: LD_INT 0
71977: PUSH
71978: EMPTY
71979: LIST
71980: LIST
71981: PUSH
71982: LD_INT 1
71984: NEG
71985: PUSH
71986: LD_INT 1
71988: NEG
71989: PUSH
71990: EMPTY
71991: LIST
71992: LIST
71993: PUSH
71994: LD_INT 1
71996: NEG
71997: PUSH
71998: LD_INT 2
72000: NEG
72001: PUSH
72002: EMPTY
72003: LIST
72004: LIST
72005: PUSH
72006: LD_INT 0
72008: PUSH
72009: LD_INT 2
72011: NEG
72012: PUSH
72013: EMPTY
72014: LIST
72015: LIST
72016: PUSH
72017: LD_INT 1
72019: PUSH
72020: LD_INT 1
72022: NEG
72023: PUSH
72024: EMPTY
72025: LIST
72026: LIST
72027: PUSH
72028: LD_INT 2
72030: PUSH
72031: LD_INT 1
72033: PUSH
72034: EMPTY
72035: LIST
72036: LIST
72037: PUSH
72038: LD_INT 2
72040: PUSH
72041: LD_INT 2
72043: PUSH
72044: EMPTY
72045: LIST
72046: LIST
72047: PUSH
72048: LD_INT 1
72050: PUSH
72051: LD_INT 2
72053: PUSH
72054: EMPTY
72055: LIST
72056: LIST
72057: PUSH
72058: LD_INT 1
72060: NEG
72061: PUSH
72062: LD_INT 1
72064: PUSH
72065: EMPTY
72066: LIST
72067: LIST
72068: PUSH
72069: LD_INT 2
72071: NEG
72072: PUSH
72073: LD_INT 0
72075: PUSH
72076: EMPTY
72077: LIST
72078: LIST
72079: PUSH
72080: LD_INT 2
72082: NEG
72083: PUSH
72084: LD_INT 1
72086: NEG
72087: PUSH
72088: EMPTY
72089: LIST
72090: LIST
72091: PUSH
72092: LD_INT 2
72094: NEG
72095: PUSH
72096: LD_INT 2
72098: NEG
72099: PUSH
72100: EMPTY
72101: LIST
72102: LIST
72103: PUSH
72104: LD_INT 1
72106: NEG
72107: PUSH
72108: LD_INT 3
72110: NEG
72111: PUSH
72112: EMPTY
72113: LIST
72114: LIST
72115: PUSH
72116: LD_INT 1
72118: PUSH
72119: LD_INT 2
72121: NEG
72122: PUSH
72123: EMPTY
72124: LIST
72125: LIST
72126: PUSH
72127: LD_INT 3
72129: PUSH
72130: LD_INT 2
72132: PUSH
72133: EMPTY
72134: LIST
72135: LIST
72136: PUSH
72137: LD_INT 2
72139: PUSH
72140: LD_INT 3
72142: PUSH
72143: EMPTY
72144: LIST
72145: LIST
72146: PUSH
72147: LD_INT 2
72149: NEG
72150: PUSH
72151: LD_INT 1
72153: PUSH
72154: EMPTY
72155: LIST
72156: LIST
72157: PUSH
72158: LD_INT 3
72160: NEG
72161: PUSH
72162: LD_INT 1
72164: NEG
72165: PUSH
72166: EMPTY
72167: LIST
72168: LIST
72169: PUSH
72170: EMPTY
72171: LIST
72172: LIST
72173: LIST
72174: LIST
72175: LIST
72176: LIST
72177: LIST
72178: LIST
72179: LIST
72180: LIST
72181: LIST
72182: LIST
72183: LIST
72184: LIST
72185: LIST
72186: LIST
72187: LIST
72188: LIST
72189: LIST
72190: LIST
72191: LIST
72192: LIST
72193: LIST
72194: ST_TO_ADDR
// fExt0 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ 2 , 1 ] , [ - 2 , - 1 ] ] ;
72195: LD_ADDR_VAR 0 35
72199: PUSH
72200: LD_INT 0
72202: PUSH
72203: LD_INT 0
72205: PUSH
72206: EMPTY
72207: LIST
72208: LIST
72209: PUSH
72210: LD_INT 0
72212: PUSH
72213: LD_INT 1
72215: NEG
72216: PUSH
72217: EMPTY
72218: LIST
72219: LIST
72220: PUSH
72221: LD_INT 1
72223: PUSH
72224: LD_INT 0
72226: PUSH
72227: EMPTY
72228: LIST
72229: LIST
72230: PUSH
72231: LD_INT 1
72233: PUSH
72234: LD_INT 1
72236: PUSH
72237: EMPTY
72238: LIST
72239: LIST
72240: PUSH
72241: LD_INT 0
72243: PUSH
72244: LD_INT 1
72246: PUSH
72247: EMPTY
72248: LIST
72249: LIST
72250: PUSH
72251: LD_INT 1
72253: NEG
72254: PUSH
72255: LD_INT 0
72257: PUSH
72258: EMPTY
72259: LIST
72260: LIST
72261: PUSH
72262: LD_INT 1
72264: NEG
72265: PUSH
72266: LD_INT 1
72268: NEG
72269: PUSH
72270: EMPTY
72271: LIST
72272: LIST
72273: PUSH
72274: LD_INT 2
72276: PUSH
72277: LD_INT 1
72279: PUSH
72280: EMPTY
72281: LIST
72282: LIST
72283: PUSH
72284: LD_INT 2
72286: NEG
72287: PUSH
72288: LD_INT 1
72290: NEG
72291: PUSH
72292: EMPTY
72293: LIST
72294: LIST
72295: PUSH
72296: EMPTY
72297: LIST
72298: LIST
72299: LIST
72300: LIST
72301: LIST
72302: LIST
72303: LIST
72304: LIST
72305: LIST
72306: ST_TO_ADDR
// fExt1 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 1 , 2 ] ] ;
72307: LD_ADDR_VAR 0 36
72311: PUSH
72312: LD_INT 0
72314: PUSH
72315: LD_INT 0
72317: PUSH
72318: EMPTY
72319: LIST
72320: LIST
72321: PUSH
72322: LD_INT 0
72324: PUSH
72325: LD_INT 1
72327: NEG
72328: PUSH
72329: EMPTY
72330: LIST
72331: LIST
72332: PUSH
72333: LD_INT 1
72335: PUSH
72336: LD_INT 0
72338: PUSH
72339: EMPTY
72340: LIST
72341: LIST
72342: PUSH
72343: LD_INT 1
72345: PUSH
72346: LD_INT 1
72348: PUSH
72349: EMPTY
72350: LIST
72351: LIST
72352: PUSH
72353: LD_INT 0
72355: PUSH
72356: LD_INT 1
72358: PUSH
72359: EMPTY
72360: LIST
72361: LIST
72362: PUSH
72363: LD_INT 1
72365: NEG
72366: PUSH
72367: LD_INT 0
72369: PUSH
72370: EMPTY
72371: LIST
72372: LIST
72373: PUSH
72374: LD_INT 1
72376: NEG
72377: PUSH
72378: LD_INT 1
72380: NEG
72381: PUSH
72382: EMPTY
72383: LIST
72384: LIST
72385: PUSH
72386: LD_INT 1
72388: NEG
72389: PUSH
72390: LD_INT 2
72392: NEG
72393: PUSH
72394: EMPTY
72395: LIST
72396: LIST
72397: PUSH
72398: LD_INT 1
72400: PUSH
72401: LD_INT 2
72403: PUSH
72404: EMPTY
72405: LIST
72406: LIST
72407: PUSH
72408: EMPTY
72409: LIST
72410: LIST
72411: LIST
72412: LIST
72413: LIST
72414: LIST
72415: LIST
72416: LIST
72417: LIST
72418: ST_TO_ADDR
// fExt2 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ 1 , - 1 ] , [ - 1 , 1 ] ] ;
72419: LD_ADDR_VAR 0 37
72423: PUSH
72424: LD_INT 0
72426: PUSH
72427: LD_INT 0
72429: PUSH
72430: EMPTY
72431: LIST
72432: LIST
72433: PUSH
72434: LD_INT 0
72436: PUSH
72437: LD_INT 1
72439: NEG
72440: PUSH
72441: EMPTY
72442: LIST
72443: LIST
72444: PUSH
72445: LD_INT 1
72447: PUSH
72448: LD_INT 0
72450: PUSH
72451: EMPTY
72452: LIST
72453: LIST
72454: PUSH
72455: LD_INT 1
72457: PUSH
72458: LD_INT 1
72460: PUSH
72461: EMPTY
72462: LIST
72463: LIST
72464: PUSH
72465: LD_INT 0
72467: PUSH
72468: LD_INT 1
72470: PUSH
72471: EMPTY
72472: LIST
72473: LIST
72474: PUSH
72475: LD_INT 1
72477: NEG
72478: PUSH
72479: LD_INT 0
72481: PUSH
72482: EMPTY
72483: LIST
72484: LIST
72485: PUSH
72486: LD_INT 1
72488: NEG
72489: PUSH
72490: LD_INT 1
72492: NEG
72493: PUSH
72494: EMPTY
72495: LIST
72496: LIST
72497: PUSH
72498: LD_INT 1
72500: PUSH
72501: LD_INT 1
72503: NEG
72504: PUSH
72505: EMPTY
72506: LIST
72507: LIST
72508: PUSH
72509: LD_INT 1
72511: NEG
72512: PUSH
72513: LD_INT 1
72515: PUSH
72516: EMPTY
72517: LIST
72518: LIST
72519: PUSH
72520: EMPTY
72521: LIST
72522: LIST
72523: LIST
72524: LIST
72525: LIST
72526: LIST
72527: LIST
72528: LIST
72529: LIST
72530: ST_TO_ADDR
// fExt3 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ 2 , 1 ] , [ - 2 , - 1 ] ] ;
72531: LD_ADDR_VAR 0 38
72535: PUSH
72536: LD_INT 0
72538: PUSH
72539: LD_INT 0
72541: PUSH
72542: EMPTY
72543: LIST
72544: LIST
72545: PUSH
72546: LD_INT 0
72548: PUSH
72549: LD_INT 1
72551: NEG
72552: PUSH
72553: EMPTY
72554: LIST
72555: LIST
72556: PUSH
72557: LD_INT 1
72559: PUSH
72560: LD_INT 0
72562: PUSH
72563: EMPTY
72564: LIST
72565: LIST
72566: PUSH
72567: LD_INT 1
72569: PUSH
72570: LD_INT 1
72572: PUSH
72573: EMPTY
72574: LIST
72575: LIST
72576: PUSH
72577: LD_INT 0
72579: PUSH
72580: LD_INT 1
72582: PUSH
72583: EMPTY
72584: LIST
72585: LIST
72586: PUSH
72587: LD_INT 1
72589: NEG
72590: PUSH
72591: LD_INT 0
72593: PUSH
72594: EMPTY
72595: LIST
72596: LIST
72597: PUSH
72598: LD_INT 1
72600: NEG
72601: PUSH
72602: LD_INT 1
72604: NEG
72605: PUSH
72606: EMPTY
72607: LIST
72608: LIST
72609: PUSH
72610: LD_INT 2
72612: PUSH
72613: LD_INT 1
72615: PUSH
72616: EMPTY
72617: LIST
72618: LIST
72619: PUSH
72620: LD_INT 2
72622: NEG
72623: PUSH
72624: LD_INT 1
72626: NEG
72627: PUSH
72628: EMPTY
72629: LIST
72630: LIST
72631: PUSH
72632: EMPTY
72633: LIST
72634: LIST
72635: LIST
72636: LIST
72637: LIST
72638: LIST
72639: LIST
72640: LIST
72641: LIST
72642: ST_TO_ADDR
// fExt4 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 1 , 2 ] ] ;
72643: LD_ADDR_VAR 0 39
72647: PUSH
72648: LD_INT 0
72650: PUSH
72651: LD_INT 0
72653: PUSH
72654: EMPTY
72655: LIST
72656: LIST
72657: PUSH
72658: LD_INT 0
72660: PUSH
72661: LD_INT 1
72663: NEG
72664: PUSH
72665: EMPTY
72666: LIST
72667: LIST
72668: PUSH
72669: LD_INT 1
72671: PUSH
72672: LD_INT 0
72674: PUSH
72675: EMPTY
72676: LIST
72677: LIST
72678: PUSH
72679: LD_INT 1
72681: PUSH
72682: LD_INT 1
72684: PUSH
72685: EMPTY
72686: LIST
72687: LIST
72688: PUSH
72689: LD_INT 0
72691: PUSH
72692: LD_INT 1
72694: PUSH
72695: EMPTY
72696: LIST
72697: LIST
72698: PUSH
72699: LD_INT 1
72701: NEG
72702: PUSH
72703: LD_INT 0
72705: PUSH
72706: EMPTY
72707: LIST
72708: LIST
72709: PUSH
72710: LD_INT 1
72712: NEG
72713: PUSH
72714: LD_INT 1
72716: NEG
72717: PUSH
72718: EMPTY
72719: LIST
72720: LIST
72721: PUSH
72722: LD_INT 1
72724: NEG
72725: PUSH
72726: LD_INT 2
72728: NEG
72729: PUSH
72730: EMPTY
72731: LIST
72732: LIST
72733: PUSH
72734: LD_INT 1
72736: PUSH
72737: LD_INT 2
72739: PUSH
72740: EMPTY
72741: LIST
72742: LIST
72743: PUSH
72744: EMPTY
72745: LIST
72746: LIST
72747: LIST
72748: LIST
72749: LIST
72750: LIST
72751: LIST
72752: LIST
72753: LIST
72754: ST_TO_ADDR
// fExt5 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ 1 , - 1 ] , [ - 1 , 1 ] ] ;
72755: LD_ADDR_VAR 0 40
72759: PUSH
72760: LD_INT 0
72762: PUSH
72763: LD_INT 0
72765: PUSH
72766: EMPTY
72767: LIST
72768: LIST
72769: PUSH
72770: LD_INT 0
72772: PUSH
72773: LD_INT 1
72775: NEG
72776: PUSH
72777: EMPTY
72778: LIST
72779: LIST
72780: PUSH
72781: LD_INT 1
72783: PUSH
72784: LD_INT 0
72786: PUSH
72787: EMPTY
72788: LIST
72789: LIST
72790: PUSH
72791: LD_INT 1
72793: PUSH
72794: LD_INT 1
72796: PUSH
72797: EMPTY
72798: LIST
72799: LIST
72800: PUSH
72801: LD_INT 0
72803: PUSH
72804: LD_INT 1
72806: PUSH
72807: EMPTY
72808: LIST
72809: LIST
72810: PUSH
72811: LD_INT 1
72813: NEG
72814: PUSH
72815: LD_INT 0
72817: PUSH
72818: EMPTY
72819: LIST
72820: LIST
72821: PUSH
72822: LD_INT 1
72824: NEG
72825: PUSH
72826: LD_INT 1
72828: NEG
72829: PUSH
72830: EMPTY
72831: LIST
72832: LIST
72833: PUSH
72834: LD_INT 1
72836: PUSH
72837: LD_INT 1
72839: NEG
72840: PUSH
72841: EMPTY
72842: LIST
72843: LIST
72844: PUSH
72845: LD_INT 1
72847: NEG
72848: PUSH
72849: LD_INT 1
72851: PUSH
72852: EMPTY
72853: LIST
72854: LIST
72855: PUSH
72856: EMPTY
72857: LIST
72858: LIST
72859: LIST
72860: LIST
72861: LIST
72862: LIST
72863: LIST
72864: LIST
72865: LIST
72866: ST_TO_ADDR
// fLab0 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ - 2 , - 3 ] , [ 2 , - 1 ] , [ 3 , 0 ] , [ 3 , 1 ] , [ 3 , 2 ] , [ 3 , 3 ] , [ 2 , 3 ] , [ - 2 , 1 ] , [ - 3 , 0 ] , [ - 3 , - 1 ] , [ - 3 , - 2 ] , [ - 3 , - 3 ] ] ;
72867: LD_ADDR_VAR 0 41
72871: PUSH
72872: LD_INT 0
72874: PUSH
72875: LD_INT 0
72877: PUSH
72878: EMPTY
72879: LIST
72880: LIST
72881: PUSH
72882: LD_INT 0
72884: PUSH
72885: LD_INT 1
72887: NEG
72888: PUSH
72889: EMPTY
72890: LIST
72891: LIST
72892: PUSH
72893: LD_INT 1
72895: PUSH
72896: LD_INT 0
72898: PUSH
72899: EMPTY
72900: LIST
72901: LIST
72902: PUSH
72903: LD_INT 1
72905: PUSH
72906: LD_INT 1
72908: PUSH
72909: EMPTY
72910: LIST
72911: LIST
72912: PUSH
72913: LD_INT 0
72915: PUSH
72916: LD_INT 1
72918: PUSH
72919: EMPTY
72920: LIST
72921: LIST
72922: PUSH
72923: LD_INT 1
72925: NEG
72926: PUSH
72927: LD_INT 0
72929: PUSH
72930: EMPTY
72931: LIST
72932: LIST
72933: PUSH
72934: LD_INT 1
72936: NEG
72937: PUSH
72938: LD_INT 1
72940: NEG
72941: PUSH
72942: EMPTY
72943: LIST
72944: LIST
72945: PUSH
72946: LD_INT 1
72948: NEG
72949: PUSH
72950: LD_INT 2
72952: NEG
72953: PUSH
72954: EMPTY
72955: LIST
72956: LIST
72957: PUSH
72958: LD_INT 1
72960: PUSH
72961: LD_INT 1
72963: NEG
72964: PUSH
72965: EMPTY
72966: LIST
72967: LIST
72968: PUSH
72969: LD_INT 2
72971: PUSH
72972: LD_INT 0
72974: PUSH
72975: EMPTY
72976: LIST
72977: LIST
72978: PUSH
72979: LD_INT 2
72981: PUSH
72982: LD_INT 1
72984: PUSH
72985: EMPTY
72986: LIST
72987: LIST
72988: PUSH
72989: LD_INT 2
72991: PUSH
72992: LD_INT 2
72994: PUSH
72995: EMPTY
72996: LIST
72997: LIST
72998: PUSH
72999: LD_INT 1
73001: PUSH
73002: LD_INT 2
73004: PUSH
73005: EMPTY
73006: LIST
73007: LIST
73008: PUSH
73009: LD_INT 1
73011: NEG
73012: PUSH
73013: LD_INT 1
73015: PUSH
73016: EMPTY
73017: LIST
73018: LIST
73019: PUSH
73020: LD_INT 2
73022: NEG
73023: PUSH
73024: LD_INT 0
73026: PUSH
73027: EMPTY
73028: LIST
73029: LIST
73030: PUSH
73031: LD_INT 2
73033: NEG
73034: PUSH
73035: LD_INT 1
73037: NEG
73038: PUSH
73039: EMPTY
73040: LIST
73041: LIST
73042: PUSH
73043: LD_INT 2
73045: NEG
73046: PUSH
73047: LD_INT 2
73049: NEG
73050: PUSH
73051: EMPTY
73052: LIST
73053: LIST
73054: PUSH
73055: LD_INT 2
73057: NEG
73058: PUSH
73059: LD_INT 3
73061: NEG
73062: PUSH
73063: EMPTY
73064: LIST
73065: LIST
73066: PUSH
73067: LD_INT 2
73069: PUSH
73070: LD_INT 1
73072: NEG
73073: PUSH
73074: EMPTY
73075: LIST
73076: LIST
73077: PUSH
73078: LD_INT 3
73080: PUSH
73081: LD_INT 0
73083: PUSH
73084: EMPTY
73085: LIST
73086: LIST
73087: PUSH
73088: LD_INT 3
73090: PUSH
73091: LD_INT 1
73093: PUSH
73094: EMPTY
73095: LIST
73096: LIST
73097: PUSH
73098: LD_INT 3
73100: PUSH
73101: LD_INT 2
73103: PUSH
73104: EMPTY
73105: LIST
73106: LIST
73107: PUSH
73108: LD_INT 3
73110: PUSH
73111: LD_INT 3
73113: PUSH
73114: EMPTY
73115: LIST
73116: LIST
73117: PUSH
73118: LD_INT 2
73120: PUSH
73121: LD_INT 3
73123: PUSH
73124: EMPTY
73125: LIST
73126: LIST
73127: PUSH
73128: LD_INT 2
73130: NEG
73131: PUSH
73132: LD_INT 1
73134: PUSH
73135: EMPTY
73136: LIST
73137: LIST
73138: PUSH
73139: LD_INT 3
73141: NEG
73142: PUSH
73143: LD_INT 0
73145: PUSH
73146: EMPTY
73147: LIST
73148: LIST
73149: PUSH
73150: LD_INT 3
73152: NEG
73153: PUSH
73154: LD_INT 1
73156: NEG
73157: PUSH
73158: EMPTY
73159: LIST
73160: LIST
73161: PUSH
73162: LD_INT 3
73164: NEG
73165: PUSH
73166: LD_INT 2
73168: NEG
73169: PUSH
73170: EMPTY
73171: LIST
73172: LIST
73173: PUSH
73174: LD_INT 3
73176: NEG
73177: PUSH
73178: LD_INT 3
73180: NEG
73181: PUSH
73182: EMPTY
73183: LIST
73184: LIST
73185: PUSH
73186: EMPTY
73187: LIST
73188: LIST
73189: LIST
73190: LIST
73191: LIST
73192: LIST
73193: LIST
73194: LIST
73195: LIST
73196: LIST
73197: LIST
73198: LIST
73199: LIST
73200: LIST
73201: LIST
73202: LIST
73203: LIST
73204: LIST
73205: LIST
73206: LIST
73207: LIST
73208: LIST
73209: LIST
73210: LIST
73211: LIST
73212: LIST
73213: LIST
73214: LIST
73215: LIST
73216: ST_TO_ADDR
// fLab1 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ - 2 , - 3 ] , [ - 1 , - 3 ] , [ 0 , - 3 ] , [ 1 , - 2 ] , [ 3 , 2 ] , [ 3 , 3 ] , [ 2 , 3 ] , [ 1 , 3 ] , [ 0 , 3 ] , [ - 1 , 2 ] , [ - 3 , - 2 ] , [ - 3 , - 3 ] ] ;
73217: LD_ADDR_VAR 0 42
73221: PUSH
73222: LD_INT 0
73224: PUSH
73225: LD_INT 0
73227: PUSH
73228: EMPTY
73229: LIST
73230: LIST
73231: PUSH
73232: LD_INT 0
73234: PUSH
73235: LD_INT 1
73237: NEG
73238: PUSH
73239: EMPTY
73240: LIST
73241: LIST
73242: PUSH
73243: LD_INT 1
73245: PUSH
73246: LD_INT 0
73248: PUSH
73249: EMPTY
73250: LIST
73251: LIST
73252: PUSH
73253: LD_INT 1
73255: PUSH
73256: LD_INT 1
73258: PUSH
73259: EMPTY
73260: LIST
73261: LIST
73262: PUSH
73263: LD_INT 0
73265: PUSH
73266: LD_INT 1
73268: PUSH
73269: EMPTY
73270: LIST
73271: LIST
73272: PUSH
73273: LD_INT 1
73275: NEG
73276: PUSH
73277: LD_INT 0
73279: PUSH
73280: EMPTY
73281: LIST
73282: LIST
73283: PUSH
73284: LD_INT 1
73286: NEG
73287: PUSH
73288: LD_INT 1
73290: NEG
73291: PUSH
73292: EMPTY
73293: LIST
73294: LIST
73295: PUSH
73296: LD_INT 1
73298: NEG
73299: PUSH
73300: LD_INT 2
73302: NEG
73303: PUSH
73304: EMPTY
73305: LIST
73306: LIST
73307: PUSH
73308: LD_INT 0
73310: PUSH
73311: LD_INT 2
73313: NEG
73314: PUSH
73315: EMPTY
73316: LIST
73317: LIST
73318: PUSH
73319: LD_INT 1
73321: PUSH
73322: LD_INT 1
73324: NEG
73325: PUSH
73326: EMPTY
73327: LIST
73328: LIST
73329: PUSH
73330: LD_INT 2
73332: PUSH
73333: LD_INT 1
73335: PUSH
73336: EMPTY
73337: LIST
73338: LIST
73339: PUSH
73340: LD_INT 2
73342: PUSH
73343: LD_INT 2
73345: PUSH
73346: EMPTY
73347: LIST
73348: LIST
73349: PUSH
73350: LD_INT 1
73352: PUSH
73353: LD_INT 2
73355: PUSH
73356: EMPTY
73357: LIST
73358: LIST
73359: PUSH
73360: LD_INT 0
73362: PUSH
73363: LD_INT 2
73365: PUSH
73366: EMPTY
73367: LIST
73368: LIST
73369: PUSH
73370: LD_INT 1
73372: NEG
73373: PUSH
73374: LD_INT 1
73376: PUSH
73377: EMPTY
73378: LIST
73379: LIST
73380: PUSH
73381: LD_INT 2
73383: NEG
73384: PUSH
73385: LD_INT 1
73387: NEG
73388: PUSH
73389: EMPTY
73390: LIST
73391: LIST
73392: PUSH
73393: LD_INT 2
73395: NEG
73396: PUSH
73397: LD_INT 2
73399: NEG
73400: PUSH
73401: EMPTY
73402: LIST
73403: LIST
73404: PUSH
73405: LD_INT 2
73407: NEG
73408: PUSH
73409: LD_INT 3
73411: NEG
73412: PUSH
73413: EMPTY
73414: LIST
73415: LIST
73416: PUSH
73417: LD_INT 1
73419: NEG
73420: PUSH
73421: LD_INT 3
73423: NEG
73424: PUSH
73425: EMPTY
73426: LIST
73427: LIST
73428: PUSH
73429: LD_INT 0
73431: PUSH
73432: LD_INT 3
73434: NEG
73435: PUSH
73436: EMPTY
73437: LIST
73438: LIST
73439: PUSH
73440: LD_INT 1
73442: PUSH
73443: LD_INT 2
73445: NEG
73446: PUSH
73447: EMPTY
73448: LIST
73449: LIST
73450: PUSH
73451: LD_INT 3
73453: PUSH
73454: LD_INT 2
73456: PUSH
73457: EMPTY
73458: LIST
73459: LIST
73460: PUSH
73461: LD_INT 3
73463: PUSH
73464: LD_INT 3
73466: PUSH
73467: EMPTY
73468: LIST
73469: LIST
73470: PUSH
73471: LD_INT 2
73473: PUSH
73474: LD_INT 3
73476: PUSH
73477: EMPTY
73478: LIST
73479: LIST
73480: PUSH
73481: LD_INT 1
73483: PUSH
73484: LD_INT 3
73486: PUSH
73487: EMPTY
73488: LIST
73489: LIST
73490: PUSH
73491: LD_INT 0
73493: PUSH
73494: LD_INT 3
73496: PUSH
73497: EMPTY
73498: LIST
73499: LIST
73500: PUSH
73501: LD_INT 1
73503: NEG
73504: PUSH
73505: LD_INT 2
73507: PUSH
73508: EMPTY
73509: LIST
73510: LIST
73511: PUSH
73512: LD_INT 3
73514: NEG
73515: PUSH
73516: LD_INT 2
73518: NEG
73519: PUSH
73520: EMPTY
73521: LIST
73522: LIST
73523: PUSH
73524: LD_INT 3
73526: NEG
73527: PUSH
73528: LD_INT 3
73530: NEG
73531: PUSH
73532: EMPTY
73533: LIST
73534: LIST
73535: PUSH
73536: EMPTY
73537: LIST
73538: LIST
73539: LIST
73540: LIST
73541: LIST
73542: LIST
73543: LIST
73544: LIST
73545: LIST
73546: LIST
73547: LIST
73548: LIST
73549: LIST
73550: LIST
73551: LIST
73552: LIST
73553: LIST
73554: LIST
73555: LIST
73556: LIST
73557: LIST
73558: LIST
73559: LIST
73560: LIST
73561: LIST
73562: LIST
73563: LIST
73564: LIST
73565: LIST
73566: ST_TO_ADDR
// fLab2 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 1 , - 3 ] , [ 0 , - 3 ] , [ 1 , - 2 ] , [ 2 , - 1 ] , [ 3 , 0 ] , [ 3 , 1 ] , [ 1 , 3 ] , [ 0 , 3 ] , [ - 1 , 2 ] , [ - 2 , 1 ] , [ - 3 , 0 ] , [ - 3 , - 1 ] ] ;
73567: LD_ADDR_VAR 0 43
73571: PUSH
73572: LD_INT 0
73574: PUSH
73575: LD_INT 0
73577: PUSH
73578: EMPTY
73579: LIST
73580: LIST
73581: PUSH
73582: LD_INT 0
73584: PUSH
73585: LD_INT 1
73587: NEG
73588: PUSH
73589: EMPTY
73590: LIST
73591: LIST
73592: PUSH
73593: LD_INT 1
73595: PUSH
73596: LD_INT 0
73598: PUSH
73599: EMPTY
73600: LIST
73601: LIST
73602: PUSH
73603: LD_INT 1
73605: PUSH
73606: LD_INT 1
73608: PUSH
73609: EMPTY
73610: LIST
73611: LIST
73612: PUSH
73613: LD_INT 0
73615: PUSH
73616: LD_INT 1
73618: PUSH
73619: EMPTY
73620: LIST
73621: LIST
73622: PUSH
73623: LD_INT 1
73625: NEG
73626: PUSH
73627: LD_INT 0
73629: PUSH
73630: EMPTY
73631: LIST
73632: LIST
73633: PUSH
73634: LD_INT 1
73636: NEG
73637: PUSH
73638: LD_INT 1
73640: NEG
73641: PUSH
73642: EMPTY
73643: LIST
73644: LIST
73645: PUSH
73646: LD_INT 1
73648: NEG
73649: PUSH
73650: LD_INT 2
73652: NEG
73653: PUSH
73654: EMPTY
73655: LIST
73656: LIST
73657: PUSH
73658: LD_INT 0
73660: PUSH
73661: LD_INT 2
73663: NEG
73664: PUSH
73665: EMPTY
73666: LIST
73667: LIST
73668: PUSH
73669: LD_INT 1
73671: PUSH
73672: LD_INT 1
73674: NEG
73675: PUSH
73676: EMPTY
73677: LIST
73678: LIST
73679: PUSH
73680: LD_INT 2
73682: PUSH
73683: LD_INT 0
73685: PUSH
73686: EMPTY
73687: LIST
73688: LIST
73689: PUSH
73690: LD_INT 2
73692: PUSH
73693: LD_INT 1
73695: PUSH
73696: EMPTY
73697: LIST
73698: LIST
73699: PUSH
73700: LD_INT 1
73702: PUSH
73703: LD_INT 2
73705: PUSH
73706: EMPTY
73707: LIST
73708: LIST
73709: PUSH
73710: LD_INT 0
73712: PUSH
73713: LD_INT 2
73715: PUSH
73716: EMPTY
73717: LIST
73718: LIST
73719: PUSH
73720: LD_INT 1
73722: NEG
73723: PUSH
73724: LD_INT 1
73726: PUSH
73727: EMPTY
73728: LIST
73729: LIST
73730: PUSH
73731: LD_INT 2
73733: NEG
73734: PUSH
73735: LD_INT 0
73737: PUSH
73738: EMPTY
73739: LIST
73740: LIST
73741: PUSH
73742: LD_INT 2
73744: NEG
73745: PUSH
73746: LD_INT 1
73748: NEG
73749: PUSH
73750: EMPTY
73751: LIST
73752: LIST
73753: PUSH
73754: LD_INT 1
73756: NEG
73757: PUSH
73758: LD_INT 3
73760: NEG
73761: PUSH
73762: EMPTY
73763: LIST
73764: LIST
73765: PUSH
73766: LD_INT 0
73768: PUSH
73769: LD_INT 3
73771: NEG
73772: PUSH
73773: EMPTY
73774: LIST
73775: LIST
73776: PUSH
73777: LD_INT 1
73779: PUSH
73780: LD_INT 2
73782: NEG
73783: PUSH
73784: EMPTY
73785: LIST
73786: LIST
73787: PUSH
73788: LD_INT 2
73790: PUSH
73791: LD_INT 1
73793: NEG
73794: PUSH
73795: EMPTY
73796: LIST
73797: LIST
73798: PUSH
73799: LD_INT 3
73801: PUSH
73802: LD_INT 0
73804: PUSH
73805: EMPTY
73806: LIST
73807: LIST
73808: PUSH
73809: LD_INT 3
73811: PUSH
73812: LD_INT 1
73814: PUSH
73815: EMPTY
73816: LIST
73817: LIST
73818: PUSH
73819: LD_INT 1
73821: PUSH
73822: LD_INT 3
73824: PUSH
73825: EMPTY
73826: LIST
73827: LIST
73828: PUSH
73829: LD_INT 0
73831: PUSH
73832: LD_INT 3
73834: PUSH
73835: EMPTY
73836: LIST
73837: LIST
73838: PUSH
73839: LD_INT 1
73841: NEG
73842: PUSH
73843: LD_INT 2
73845: PUSH
73846: EMPTY
73847: LIST
73848: LIST
73849: PUSH
73850: LD_INT 2
73852: NEG
73853: PUSH
73854: LD_INT 1
73856: PUSH
73857: EMPTY
73858: LIST
73859: LIST
73860: PUSH
73861: LD_INT 3
73863: NEG
73864: PUSH
73865: LD_INT 0
73867: PUSH
73868: EMPTY
73869: LIST
73870: LIST
73871: PUSH
73872: LD_INT 3
73874: NEG
73875: PUSH
73876: LD_INT 1
73878: NEG
73879: PUSH
73880: EMPTY
73881: LIST
73882: LIST
73883: PUSH
73884: EMPTY
73885: LIST
73886: LIST
73887: LIST
73888: LIST
73889: LIST
73890: LIST
73891: LIST
73892: LIST
73893: LIST
73894: LIST
73895: LIST
73896: LIST
73897: LIST
73898: LIST
73899: LIST
73900: LIST
73901: LIST
73902: LIST
73903: LIST
73904: LIST
73905: LIST
73906: LIST
73907: LIST
73908: LIST
73909: LIST
73910: LIST
73911: LIST
73912: LIST
73913: LIST
73914: ST_TO_ADDR
// fLab3 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ - 2 , - 3 ] , [ 2 , - 1 ] , [ 3 , 0 ] , [ 3 , 1 ] , [ 3 , 2 ] , [ 3 , 3 ] , [ 2 , 3 ] , [ - 2 , 1 ] , [ - 3 , 0 ] , [ - 3 , - 1 ] , [ - 3 , - 2 ] , [ - 3 , - 3 ] ] ;
73915: LD_ADDR_VAR 0 44
73919: PUSH
73920: LD_INT 0
73922: PUSH
73923: LD_INT 0
73925: PUSH
73926: EMPTY
73927: LIST
73928: LIST
73929: PUSH
73930: LD_INT 0
73932: PUSH
73933: LD_INT 1
73935: NEG
73936: PUSH
73937: EMPTY
73938: LIST
73939: LIST
73940: PUSH
73941: LD_INT 1
73943: PUSH
73944: LD_INT 0
73946: PUSH
73947: EMPTY
73948: LIST
73949: LIST
73950: PUSH
73951: LD_INT 1
73953: PUSH
73954: LD_INT 1
73956: PUSH
73957: EMPTY
73958: LIST
73959: LIST
73960: PUSH
73961: LD_INT 0
73963: PUSH
73964: LD_INT 1
73966: PUSH
73967: EMPTY
73968: LIST
73969: LIST
73970: PUSH
73971: LD_INT 1
73973: NEG
73974: PUSH
73975: LD_INT 0
73977: PUSH
73978: EMPTY
73979: LIST
73980: LIST
73981: PUSH
73982: LD_INT 1
73984: NEG
73985: PUSH
73986: LD_INT 1
73988: NEG
73989: PUSH
73990: EMPTY
73991: LIST
73992: LIST
73993: PUSH
73994: LD_INT 1
73996: NEG
73997: PUSH
73998: LD_INT 2
74000: NEG
74001: PUSH
74002: EMPTY
74003: LIST
74004: LIST
74005: PUSH
74006: LD_INT 1
74008: PUSH
74009: LD_INT 1
74011: NEG
74012: PUSH
74013: EMPTY
74014: LIST
74015: LIST
74016: PUSH
74017: LD_INT 2
74019: PUSH
74020: LD_INT 0
74022: PUSH
74023: EMPTY
74024: LIST
74025: LIST
74026: PUSH
74027: LD_INT 2
74029: PUSH
74030: LD_INT 1
74032: PUSH
74033: EMPTY
74034: LIST
74035: LIST
74036: PUSH
74037: LD_INT 2
74039: PUSH
74040: LD_INT 2
74042: PUSH
74043: EMPTY
74044: LIST
74045: LIST
74046: PUSH
74047: LD_INT 1
74049: PUSH
74050: LD_INT 2
74052: PUSH
74053: EMPTY
74054: LIST
74055: LIST
74056: PUSH
74057: LD_INT 1
74059: NEG
74060: PUSH
74061: LD_INT 1
74063: PUSH
74064: EMPTY
74065: LIST
74066: LIST
74067: PUSH
74068: LD_INT 2
74070: NEG
74071: PUSH
74072: LD_INT 0
74074: PUSH
74075: EMPTY
74076: LIST
74077: LIST
74078: PUSH
74079: LD_INT 2
74081: NEG
74082: PUSH
74083: LD_INT 1
74085: NEG
74086: PUSH
74087: EMPTY
74088: LIST
74089: LIST
74090: PUSH
74091: LD_INT 2
74093: NEG
74094: PUSH
74095: LD_INT 2
74097: NEG
74098: PUSH
74099: EMPTY
74100: LIST
74101: LIST
74102: PUSH
74103: LD_INT 2
74105: NEG
74106: PUSH
74107: LD_INT 3
74109: NEG
74110: PUSH
74111: EMPTY
74112: LIST
74113: LIST
74114: PUSH
74115: LD_INT 2
74117: PUSH
74118: LD_INT 1
74120: NEG
74121: PUSH
74122: EMPTY
74123: LIST
74124: LIST
74125: PUSH
74126: LD_INT 3
74128: PUSH
74129: LD_INT 0
74131: PUSH
74132: EMPTY
74133: LIST
74134: LIST
74135: PUSH
74136: LD_INT 3
74138: PUSH
74139: LD_INT 1
74141: PUSH
74142: EMPTY
74143: LIST
74144: LIST
74145: PUSH
74146: LD_INT 3
74148: PUSH
74149: LD_INT 2
74151: PUSH
74152: EMPTY
74153: LIST
74154: LIST
74155: PUSH
74156: LD_INT 3
74158: PUSH
74159: LD_INT 3
74161: PUSH
74162: EMPTY
74163: LIST
74164: LIST
74165: PUSH
74166: LD_INT 2
74168: PUSH
74169: LD_INT 3
74171: PUSH
74172: EMPTY
74173: LIST
74174: LIST
74175: PUSH
74176: LD_INT 2
74178: NEG
74179: PUSH
74180: LD_INT 1
74182: PUSH
74183: EMPTY
74184: LIST
74185: LIST
74186: PUSH
74187: LD_INT 3
74189: NEG
74190: PUSH
74191: LD_INT 0
74193: PUSH
74194: EMPTY
74195: LIST
74196: LIST
74197: PUSH
74198: LD_INT 3
74200: NEG
74201: PUSH
74202: LD_INT 1
74204: NEG
74205: PUSH
74206: EMPTY
74207: LIST
74208: LIST
74209: PUSH
74210: LD_INT 3
74212: NEG
74213: PUSH
74214: LD_INT 2
74216: NEG
74217: PUSH
74218: EMPTY
74219: LIST
74220: LIST
74221: PUSH
74222: LD_INT 3
74224: NEG
74225: PUSH
74226: LD_INT 3
74228: NEG
74229: PUSH
74230: EMPTY
74231: LIST
74232: LIST
74233: PUSH
74234: EMPTY
74235: LIST
74236: LIST
74237: LIST
74238: LIST
74239: LIST
74240: LIST
74241: LIST
74242: LIST
74243: LIST
74244: LIST
74245: LIST
74246: LIST
74247: LIST
74248: LIST
74249: LIST
74250: LIST
74251: LIST
74252: LIST
74253: LIST
74254: LIST
74255: LIST
74256: LIST
74257: LIST
74258: LIST
74259: LIST
74260: LIST
74261: LIST
74262: LIST
74263: LIST
74264: ST_TO_ADDR
// fLab4 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ - 2 , - 3 ] , [ - 1 , - 3 ] , [ 0 , - 3 ] , [ 1 , - 2 ] , [ 3 , 2 ] , [ 3 , 3 ] , [ 2 , 3 ] , [ 1 , 3 ] , [ 0 , 3 ] , [ - 1 , 2 ] , [ - 3 , - 2 ] , [ - 3 , - 3 ] ] ;
74265: LD_ADDR_VAR 0 45
74269: PUSH
74270: LD_INT 0
74272: PUSH
74273: LD_INT 0
74275: PUSH
74276: EMPTY
74277: LIST
74278: LIST
74279: PUSH
74280: LD_INT 0
74282: PUSH
74283: LD_INT 1
74285: NEG
74286: PUSH
74287: EMPTY
74288: LIST
74289: LIST
74290: PUSH
74291: LD_INT 1
74293: PUSH
74294: LD_INT 0
74296: PUSH
74297: EMPTY
74298: LIST
74299: LIST
74300: PUSH
74301: LD_INT 1
74303: PUSH
74304: LD_INT 1
74306: PUSH
74307: EMPTY
74308: LIST
74309: LIST
74310: PUSH
74311: LD_INT 0
74313: PUSH
74314: LD_INT 1
74316: PUSH
74317: EMPTY
74318: LIST
74319: LIST
74320: PUSH
74321: LD_INT 1
74323: NEG
74324: PUSH
74325: LD_INT 0
74327: PUSH
74328: EMPTY
74329: LIST
74330: LIST
74331: PUSH
74332: LD_INT 1
74334: NEG
74335: PUSH
74336: LD_INT 1
74338: NEG
74339: PUSH
74340: EMPTY
74341: LIST
74342: LIST
74343: PUSH
74344: LD_INT 1
74346: NEG
74347: PUSH
74348: LD_INT 2
74350: NEG
74351: PUSH
74352: EMPTY
74353: LIST
74354: LIST
74355: PUSH
74356: LD_INT 0
74358: PUSH
74359: LD_INT 2
74361: NEG
74362: PUSH
74363: EMPTY
74364: LIST
74365: LIST
74366: PUSH
74367: LD_INT 1
74369: PUSH
74370: LD_INT 1
74372: NEG
74373: PUSH
74374: EMPTY
74375: LIST
74376: LIST
74377: PUSH
74378: LD_INT 2
74380: PUSH
74381: LD_INT 1
74383: PUSH
74384: EMPTY
74385: LIST
74386: LIST
74387: PUSH
74388: LD_INT 2
74390: PUSH
74391: LD_INT 2
74393: PUSH
74394: EMPTY
74395: LIST
74396: LIST
74397: PUSH
74398: LD_INT 1
74400: PUSH
74401: LD_INT 2
74403: PUSH
74404: EMPTY
74405: LIST
74406: LIST
74407: PUSH
74408: LD_INT 0
74410: PUSH
74411: LD_INT 2
74413: PUSH
74414: EMPTY
74415: LIST
74416: LIST
74417: PUSH
74418: LD_INT 1
74420: NEG
74421: PUSH
74422: LD_INT 1
74424: PUSH
74425: EMPTY
74426: LIST
74427: LIST
74428: PUSH
74429: LD_INT 2
74431: NEG
74432: PUSH
74433: LD_INT 1
74435: NEG
74436: PUSH
74437: EMPTY
74438: LIST
74439: LIST
74440: PUSH
74441: LD_INT 2
74443: NEG
74444: PUSH
74445: LD_INT 2
74447: NEG
74448: PUSH
74449: EMPTY
74450: LIST
74451: LIST
74452: PUSH
74453: LD_INT 2
74455: NEG
74456: PUSH
74457: LD_INT 3
74459: NEG
74460: PUSH
74461: EMPTY
74462: LIST
74463: LIST
74464: PUSH
74465: LD_INT 1
74467: NEG
74468: PUSH
74469: LD_INT 3
74471: NEG
74472: PUSH
74473: EMPTY
74474: LIST
74475: LIST
74476: PUSH
74477: LD_INT 0
74479: PUSH
74480: LD_INT 3
74482: NEG
74483: PUSH
74484: EMPTY
74485: LIST
74486: LIST
74487: PUSH
74488: LD_INT 1
74490: PUSH
74491: LD_INT 2
74493: NEG
74494: PUSH
74495: EMPTY
74496: LIST
74497: LIST
74498: PUSH
74499: LD_INT 3
74501: PUSH
74502: LD_INT 2
74504: PUSH
74505: EMPTY
74506: LIST
74507: LIST
74508: PUSH
74509: LD_INT 3
74511: PUSH
74512: LD_INT 3
74514: PUSH
74515: EMPTY
74516: LIST
74517: LIST
74518: PUSH
74519: LD_INT 2
74521: PUSH
74522: LD_INT 3
74524: PUSH
74525: EMPTY
74526: LIST
74527: LIST
74528: PUSH
74529: LD_INT 1
74531: PUSH
74532: LD_INT 3
74534: PUSH
74535: EMPTY
74536: LIST
74537: LIST
74538: PUSH
74539: LD_INT 0
74541: PUSH
74542: LD_INT 3
74544: PUSH
74545: EMPTY
74546: LIST
74547: LIST
74548: PUSH
74549: LD_INT 1
74551: NEG
74552: PUSH
74553: LD_INT 2
74555: PUSH
74556: EMPTY
74557: LIST
74558: LIST
74559: PUSH
74560: LD_INT 3
74562: NEG
74563: PUSH
74564: LD_INT 2
74566: NEG
74567: PUSH
74568: EMPTY
74569: LIST
74570: LIST
74571: PUSH
74572: LD_INT 3
74574: NEG
74575: PUSH
74576: LD_INT 3
74578: NEG
74579: PUSH
74580: EMPTY
74581: LIST
74582: LIST
74583: PUSH
74584: EMPTY
74585: LIST
74586: LIST
74587: LIST
74588: LIST
74589: LIST
74590: LIST
74591: LIST
74592: LIST
74593: LIST
74594: LIST
74595: LIST
74596: LIST
74597: LIST
74598: LIST
74599: LIST
74600: LIST
74601: LIST
74602: LIST
74603: LIST
74604: LIST
74605: LIST
74606: LIST
74607: LIST
74608: LIST
74609: LIST
74610: LIST
74611: LIST
74612: LIST
74613: LIST
74614: ST_TO_ADDR
// fLab5 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 1 , - 3 ] , [ 0 , - 3 ] , [ 1 , - 2 ] , [ 2 , - 1 ] , [ 3 , 0 ] , [ 3 , 1 ] , [ 1 , 3 ] , [ 0 , 3 ] , [ - 1 , 2 ] , [ - 2 , 1 ] , [ - 3 , 0 ] , [ - 3 , - 1 ] ] ;
74615: LD_ADDR_VAR 0 46
74619: PUSH
74620: LD_INT 0
74622: PUSH
74623: LD_INT 0
74625: PUSH
74626: EMPTY
74627: LIST
74628: LIST
74629: PUSH
74630: LD_INT 0
74632: PUSH
74633: LD_INT 1
74635: NEG
74636: PUSH
74637: EMPTY
74638: LIST
74639: LIST
74640: PUSH
74641: LD_INT 1
74643: PUSH
74644: LD_INT 0
74646: PUSH
74647: EMPTY
74648: LIST
74649: LIST
74650: PUSH
74651: LD_INT 1
74653: PUSH
74654: LD_INT 1
74656: PUSH
74657: EMPTY
74658: LIST
74659: LIST
74660: PUSH
74661: LD_INT 0
74663: PUSH
74664: LD_INT 1
74666: PUSH
74667: EMPTY
74668: LIST
74669: LIST
74670: PUSH
74671: LD_INT 1
74673: NEG
74674: PUSH
74675: LD_INT 0
74677: PUSH
74678: EMPTY
74679: LIST
74680: LIST
74681: PUSH
74682: LD_INT 1
74684: NEG
74685: PUSH
74686: LD_INT 1
74688: NEG
74689: PUSH
74690: EMPTY
74691: LIST
74692: LIST
74693: PUSH
74694: LD_INT 1
74696: NEG
74697: PUSH
74698: LD_INT 2
74700: NEG
74701: PUSH
74702: EMPTY
74703: LIST
74704: LIST
74705: PUSH
74706: LD_INT 0
74708: PUSH
74709: LD_INT 2
74711: NEG
74712: PUSH
74713: EMPTY
74714: LIST
74715: LIST
74716: PUSH
74717: LD_INT 1
74719: PUSH
74720: LD_INT 1
74722: NEG
74723: PUSH
74724: EMPTY
74725: LIST
74726: LIST
74727: PUSH
74728: LD_INT 2
74730: PUSH
74731: LD_INT 0
74733: PUSH
74734: EMPTY
74735: LIST
74736: LIST
74737: PUSH
74738: LD_INT 2
74740: PUSH
74741: LD_INT 1
74743: PUSH
74744: EMPTY
74745: LIST
74746: LIST
74747: PUSH
74748: LD_INT 1
74750: PUSH
74751: LD_INT 2
74753: PUSH
74754: EMPTY
74755: LIST
74756: LIST
74757: PUSH
74758: LD_INT 0
74760: PUSH
74761: LD_INT 2
74763: PUSH
74764: EMPTY
74765: LIST
74766: LIST
74767: PUSH
74768: LD_INT 1
74770: NEG
74771: PUSH
74772: LD_INT 1
74774: PUSH
74775: EMPTY
74776: LIST
74777: LIST
74778: PUSH
74779: LD_INT 2
74781: NEG
74782: PUSH
74783: LD_INT 0
74785: PUSH
74786: EMPTY
74787: LIST
74788: LIST
74789: PUSH
74790: LD_INT 2
74792: NEG
74793: PUSH
74794: LD_INT 1
74796: NEG
74797: PUSH
74798: EMPTY
74799: LIST
74800: LIST
74801: PUSH
74802: LD_INT 1
74804: NEG
74805: PUSH
74806: LD_INT 3
74808: NEG
74809: PUSH
74810: EMPTY
74811: LIST
74812: LIST
74813: PUSH
74814: LD_INT 0
74816: PUSH
74817: LD_INT 3
74819: NEG
74820: PUSH
74821: EMPTY
74822: LIST
74823: LIST
74824: PUSH
74825: LD_INT 1
74827: PUSH
74828: LD_INT 2
74830: NEG
74831: PUSH
74832: EMPTY
74833: LIST
74834: LIST
74835: PUSH
74836: LD_INT 2
74838: PUSH
74839: LD_INT 1
74841: NEG
74842: PUSH
74843: EMPTY
74844: LIST
74845: LIST
74846: PUSH
74847: LD_INT 3
74849: PUSH
74850: LD_INT 0
74852: PUSH
74853: EMPTY
74854: LIST
74855: LIST
74856: PUSH
74857: LD_INT 3
74859: PUSH
74860: LD_INT 1
74862: PUSH
74863: EMPTY
74864: LIST
74865: LIST
74866: PUSH
74867: LD_INT 1
74869: PUSH
74870: LD_INT 3
74872: PUSH
74873: EMPTY
74874: LIST
74875: LIST
74876: PUSH
74877: LD_INT 0
74879: PUSH
74880: LD_INT 3
74882: PUSH
74883: EMPTY
74884: LIST
74885: LIST
74886: PUSH
74887: LD_INT 1
74889: NEG
74890: PUSH
74891: LD_INT 2
74893: PUSH
74894: EMPTY
74895: LIST
74896: LIST
74897: PUSH
74898: LD_INT 2
74900: NEG
74901: PUSH
74902: LD_INT 1
74904: PUSH
74905: EMPTY
74906: LIST
74907: LIST
74908: PUSH
74909: LD_INT 3
74911: NEG
74912: PUSH
74913: LD_INT 0
74915: PUSH
74916: EMPTY
74917: LIST
74918: LIST
74919: PUSH
74920: LD_INT 3
74922: NEG
74923: PUSH
74924: LD_INT 1
74926: NEG
74927: PUSH
74928: EMPTY
74929: LIST
74930: LIST
74931: PUSH
74932: EMPTY
74933: LIST
74934: LIST
74935: LIST
74936: LIST
74937: LIST
74938: LIST
74939: LIST
74940: LIST
74941: LIST
74942: LIST
74943: LIST
74944: LIST
74945: LIST
74946: LIST
74947: LIST
74948: LIST
74949: LIST
74950: LIST
74951: LIST
74952: LIST
74953: LIST
74954: LIST
74955: LIST
74956: LIST
74957: LIST
74958: LIST
74959: LIST
74960: LIST
74961: LIST
74962: ST_TO_ADDR
// fControlTower0 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
74963: LD_ADDR_VAR 0 47
74967: PUSH
74968: LD_INT 0
74970: PUSH
74971: LD_INT 0
74973: PUSH
74974: EMPTY
74975: LIST
74976: LIST
74977: PUSH
74978: LD_INT 0
74980: PUSH
74981: LD_INT 1
74983: NEG
74984: PUSH
74985: EMPTY
74986: LIST
74987: LIST
74988: PUSH
74989: LD_INT 1
74991: PUSH
74992: LD_INT 0
74994: PUSH
74995: EMPTY
74996: LIST
74997: LIST
74998: PUSH
74999: LD_INT 1
75001: PUSH
75002: LD_INT 1
75004: PUSH
75005: EMPTY
75006: LIST
75007: LIST
75008: PUSH
75009: LD_INT 0
75011: PUSH
75012: LD_INT 1
75014: PUSH
75015: EMPTY
75016: LIST
75017: LIST
75018: PUSH
75019: LD_INT 1
75021: NEG
75022: PUSH
75023: LD_INT 0
75025: PUSH
75026: EMPTY
75027: LIST
75028: LIST
75029: PUSH
75030: LD_INT 1
75032: NEG
75033: PUSH
75034: LD_INT 1
75036: NEG
75037: PUSH
75038: EMPTY
75039: LIST
75040: LIST
75041: PUSH
75042: LD_INT 1
75044: NEG
75045: PUSH
75046: LD_INT 2
75048: NEG
75049: PUSH
75050: EMPTY
75051: LIST
75052: LIST
75053: PUSH
75054: LD_INT 0
75056: PUSH
75057: LD_INT 2
75059: NEG
75060: PUSH
75061: EMPTY
75062: LIST
75063: LIST
75064: PUSH
75065: LD_INT 1
75067: PUSH
75068: LD_INT 1
75070: NEG
75071: PUSH
75072: EMPTY
75073: LIST
75074: LIST
75075: PUSH
75076: LD_INT 2
75078: NEG
75079: PUSH
75080: LD_INT 1
75082: NEG
75083: PUSH
75084: EMPTY
75085: LIST
75086: LIST
75087: PUSH
75088: LD_INT 2
75090: NEG
75091: PUSH
75092: LD_INT 2
75094: NEG
75095: PUSH
75096: EMPTY
75097: LIST
75098: LIST
75099: PUSH
75100: EMPTY
75101: LIST
75102: LIST
75103: LIST
75104: LIST
75105: LIST
75106: LIST
75107: LIST
75108: LIST
75109: LIST
75110: LIST
75111: LIST
75112: LIST
75113: ST_TO_ADDR
// fControlTower1 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] ] ;
75114: LD_ADDR_VAR 0 48
75118: PUSH
75119: LD_INT 0
75121: PUSH
75122: LD_INT 0
75124: PUSH
75125: EMPTY
75126: LIST
75127: LIST
75128: PUSH
75129: LD_INT 0
75131: PUSH
75132: LD_INT 1
75134: NEG
75135: PUSH
75136: EMPTY
75137: LIST
75138: LIST
75139: PUSH
75140: LD_INT 1
75142: PUSH
75143: LD_INT 0
75145: PUSH
75146: EMPTY
75147: LIST
75148: LIST
75149: PUSH
75150: LD_INT 1
75152: PUSH
75153: LD_INT 1
75155: PUSH
75156: EMPTY
75157: LIST
75158: LIST
75159: PUSH
75160: LD_INT 0
75162: PUSH
75163: LD_INT 1
75165: PUSH
75166: EMPTY
75167: LIST
75168: LIST
75169: PUSH
75170: LD_INT 1
75172: NEG
75173: PUSH
75174: LD_INT 0
75176: PUSH
75177: EMPTY
75178: LIST
75179: LIST
75180: PUSH
75181: LD_INT 1
75183: NEG
75184: PUSH
75185: LD_INT 1
75187: NEG
75188: PUSH
75189: EMPTY
75190: LIST
75191: LIST
75192: PUSH
75193: LD_INT 1
75195: NEG
75196: PUSH
75197: LD_INT 2
75199: NEG
75200: PUSH
75201: EMPTY
75202: LIST
75203: LIST
75204: PUSH
75205: LD_INT 0
75207: PUSH
75208: LD_INT 2
75210: NEG
75211: PUSH
75212: EMPTY
75213: LIST
75214: LIST
75215: PUSH
75216: LD_INT 1
75218: PUSH
75219: LD_INT 1
75221: NEG
75222: PUSH
75223: EMPTY
75224: LIST
75225: LIST
75226: PUSH
75227: LD_INT 2
75229: PUSH
75230: LD_INT 0
75232: PUSH
75233: EMPTY
75234: LIST
75235: LIST
75236: PUSH
75237: LD_INT 2
75239: PUSH
75240: LD_INT 1
75242: PUSH
75243: EMPTY
75244: LIST
75245: LIST
75246: PUSH
75247: EMPTY
75248: LIST
75249: LIST
75250: LIST
75251: LIST
75252: LIST
75253: LIST
75254: LIST
75255: LIST
75256: LIST
75257: LIST
75258: LIST
75259: LIST
75260: ST_TO_ADDR
// fControlTower2 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] ] ;
75261: LD_ADDR_VAR 0 49
75265: PUSH
75266: LD_INT 0
75268: PUSH
75269: LD_INT 0
75271: PUSH
75272: EMPTY
75273: LIST
75274: LIST
75275: PUSH
75276: LD_INT 0
75278: PUSH
75279: LD_INT 1
75281: NEG
75282: PUSH
75283: EMPTY
75284: LIST
75285: LIST
75286: PUSH
75287: LD_INT 1
75289: PUSH
75290: LD_INT 0
75292: PUSH
75293: EMPTY
75294: LIST
75295: LIST
75296: PUSH
75297: LD_INT 1
75299: PUSH
75300: LD_INT 1
75302: PUSH
75303: EMPTY
75304: LIST
75305: LIST
75306: PUSH
75307: LD_INT 0
75309: PUSH
75310: LD_INT 1
75312: PUSH
75313: EMPTY
75314: LIST
75315: LIST
75316: PUSH
75317: LD_INT 1
75319: NEG
75320: PUSH
75321: LD_INT 0
75323: PUSH
75324: EMPTY
75325: LIST
75326: LIST
75327: PUSH
75328: LD_INT 1
75330: NEG
75331: PUSH
75332: LD_INT 1
75334: NEG
75335: PUSH
75336: EMPTY
75337: LIST
75338: LIST
75339: PUSH
75340: LD_INT 1
75342: PUSH
75343: LD_INT 1
75345: NEG
75346: PUSH
75347: EMPTY
75348: LIST
75349: LIST
75350: PUSH
75351: LD_INT 2
75353: PUSH
75354: LD_INT 0
75356: PUSH
75357: EMPTY
75358: LIST
75359: LIST
75360: PUSH
75361: LD_INT 2
75363: PUSH
75364: LD_INT 1
75366: PUSH
75367: EMPTY
75368: LIST
75369: LIST
75370: PUSH
75371: LD_INT 2
75373: PUSH
75374: LD_INT 2
75376: PUSH
75377: EMPTY
75378: LIST
75379: LIST
75380: PUSH
75381: LD_INT 1
75383: PUSH
75384: LD_INT 2
75386: PUSH
75387: EMPTY
75388: LIST
75389: LIST
75390: PUSH
75391: EMPTY
75392: LIST
75393: LIST
75394: LIST
75395: LIST
75396: LIST
75397: LIST
75398: LIST
75399: LIST
75400: LIST
75401: LIST
75402: LIST
75403: LIST
75404: ST_TO_ADDR
// fControlTower3 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] ] ;
75405: LD_ADDR_VAR 0 50
75409: PUSH
75410: LD_INT 0
75412: PUSH
75413: LD_INT 0
75415: PUSH
75416: EMPTY
75417: LIST
75418: LIST
75419: PUSH
75420: LD_INT 0
75422: PUSH
75423: LD_INT 1
75425: NEG
75426: PUSH
75427: EMPTY
75428: LIST
75429: LIST
75430: PUSH
75431: LD_INT 1
75433: PUSH
75434: LD_INT 0
75436: PUSH
75437: EMPTY
75438: LIST
75439: LIST
75440: PUSH
75441: LD_INT 1
75443: PUSH
75444: LD_INT 1
75446: PUSH
75447: EMPTY
75448: LIST
75449: LIST
75450: PUSH
75451: LD_INT 0
75453: PUSH
75454: LD_INT 1
75456: PUSH
75457: EMPTY
75458: LIST
75459: LIST
75460: PUSH
75461: LD_INT 1
75463: NEG
75464: PUSH
75465: LD_INT 0
75467: PUSH
75468: EMPTY
75469: LIST
75470: LIST
75471: PUSH
75472: LD_INT 1
75474: NEG
75475: PUSH
75476: LD_INT 1
75478: NEG
75479: PUSH
75480: EMPTY
75481: LIST
75482: LIST
75483: PUSH
75484: LD_INT 2
75486: PUSH
75487: LD_INT 1
75489: PUSH
75490: EMPTY
75491: LIST
75492: LIST
75493: PUSH
75494: LD_INT 2
75496: PUSH
75497: LD_INT 2
75499: PUSH
75500: EMPTY
75501: LIST
75502: LIST
75503: PUSH
75504: LD_INT 1
75506: PUSH
75507: LD_INT 2
75509: PUSH
75510: EMPTY
75511: LIST
75512: LIST
75513: PUSH
75514: LD_INT 0
75516: PUSH
75517: LD_INT 2
75519: PUSH
75520: EMPTY
75521: LIST
75522: LIST
75523: PUSH
75524: LD_INT 1
75526: NEG
75527: PUSH
75528: LD_INT 1
75530: PUSH
75531: EMPTY
75532: LIST
75533: LIST
75534: PUSH
75535: EMPTY
75536: LIST
75537: LIST
75538: LIST
75539: LIST
75540: LIST
75541: LIST
75542: LIST
75543: LIST
75544: LIST
75545: LIST
75546: LIST
75547: LIST
75548: ST_TO_ADDR
// fControlTower4 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] ] ;
75549: LD_ADDR_VAR 0 51
75553: PUSH
75554: LD_INT 0
75556: PUSH
75557: LD_INT 0
75559: PUSH
75560: EMPTY
75561: LIST
75562: LIST
75563: PUSH
75564: LD_INT 0
75566: PUSH
75567: LD_INT 1
75569: NEG
75570: PUSH
75571: EMPTY
75572: LIST
75573: LIST
75574: PUSH
75575: LD_INT 1
75577: PUSH
75578: LD_INT 0
75580: PUSH
75581: EMPTY
75582: LIST
75583: LIST
75584: PUSH
75585: LD_INT 1
75587: PUSH
75588: LD_INT 1
75590: PUSH
75591: EMPTY
75592: LIST
75593: LIST
75594: PUSH
75595: LD_INT 0
75597: PUSH
75598: LD_INT 1
75600: PUSH
75601: EMPTY
75602: LIST
75603: LIST
75604: PUSH
75605: LD_INT 1
75607: NEG
75608: PUSH
75609: LD_INT 0
75611: PUSH
75612: EMPTY
75613: LIST
75614: LIST
75615: PUSH
75616: LD_INT 1
75618: NEG
75619: PUSH
75620: LD_INT 1
75622: NEG
75623: PUSH
75624: EMPTY
75625: LIST
75626: LIST
75627: PUSH
75628: LD_INT 1
75630: PUSH
75631: LD_INT 2
75633: PUSH
75634: EMPTY
75635: LIST
75636: LIST
75637: PUSH
75638: LD_INT 0
75640: PUSH
75641: LD_INT 2
75643: PUSH
75644: EMPTY
75645: LIST
75646: LIST
75647: PUSH
75648: LD_INT 1
75650: NEG
75651: PUSH
75652: LD_INT 1
75654: PUSH
75655: EMPTY
75656: LIST
75657: LIST
75658: PUSH
75659: LD_INT 2
75661: NEG
75662: PUSH
75663: LD_INT 0
75665: PUSH
75666: EMPTY
75667: LIST
75668: LIST
75669: PUSH
75670: LD_INT 2
75672: NEG
75673: PUSH
75674: LD_INT 1
75676: NEG
75677: PUSH
75678: EMPTY
75679: LIST
75680: LIST
75681: PUSH
75682: EMPTY
75683: LIST
75684: LIST
75685: LIST
75686: LIST
75687: LIST
75688: LIST
75689: LIST
75690: LIST
75691: LIST
75692: LIST
75693: LIST
75694: LIST
75695: ST_TO_ADDR
// fControlTower5 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
75696: LD_ADDR_VAR 0 52
75700: PUSH
75701: LD_INT 0
75703: PUSH
75704: LD_INT 0
75706: PUSH
75707: EMPTY
75708: LIST
75709: LIST
75710: PUSH
75711: LD_INT 0
75713: PUSH
75714: LD_INT 1
75716: NEG
75717: PUSH
75718: EMPTY
75719: LIST
75720: LIST
75721: PUSH
75722: LD_INT 1
75724: PUSH
75725: LD_INT 0
75727: PUSH
75728: EMPTY
75729: LIST
75730: LIST
75731: PUSH
75732: LD_INT 1
75734: PUSH
75735: LD_INT 1
75737: PUSH
75738: EMPTY
75739: LIST
75740: LIST
75741: PUSH
75742: LD_INT 0
75744: PUSH
75745: LD_INT 1
75747: PUSH
75748: EMPTY
75749: LIST
75750: LIST
75751: PUSH
75752: LD_INT 1
75754: NEG
75755: PUSH
75756: LD_INT 0
75758: PUSH
75759: EMPTY
75760: LIST
75761: LIST
75762: PUSH
75763: LD_INT 1
75765: NEG
75766: PUSH
75767: LD_INT 1
75769: NEG
75770: PUSH
75771: EMPTY
75772: LIST
75773: LIST
75774: PUSH
75775: LD_INT 1
75777: NEG
75778: PUSH
75779: LD_INT 2
75781: NEG
75782: PUSH
75783: EMPTY
75784: LIST
75785: LIST
75786: PUSH
75787: LD_INT 1
75789: NEG
75790: PUSH
75791: LD_INT 1
75793: PUSH
75794: EMPTY
75795: LIST
75796: LIST
75797: PUSH
75798: LD_INT 2
75800: NEG
75801: PUSH
75802: LD_INT 0
75804: PUSH
75805: EMPTY
75806: LIST
75807: LIST
75808: PUSH
75809: LD_INT 2
75811: NEG
75812: PUSH
75813: LD_INT 1
75815: NEG
75816: PUSH
75817: EMPTY
75818: LIST
75819: LIST
75820: PUSH
75821: LD_INT 2
75823: NEG
75824: PUSH
75825: LD_INT 2
75827: NEG
75828: PUSH
75829: EMPTY
75830: LIST
75831: LIST
75832: PUSH
75833: EMPTY
75834: LIST
75835: LIST
75836: LIST
75837: LIST
75838: LIST
75839: LIST
75840: LIST
75841: LIST
75842: LIST
75843: LIST
75844: LIST
75845: LIST
75846: ST_TO_ADDR
// fBarracks0 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
75847: LD_ADDR_VAR 0 53
75851: PUSH
75852: LD_INT 0
75854: PUSH
75855: LD_INT 0
75857: PUSH
75858: EMPTY
75859: LIST
75860: LIST
75861: PUSH
75862: LD_INT 0
75864: PUSH
75865: LD_INT 1
75867: NEG
75868: PUSH
75869: EMPTY
75870: LIST
75871: LIST
75872: PUSH
75873: LD_INT 1
75875: PUSH
75876: LD_INT 0
75878: PUSH
75879: EMPTY
75880: LIST
75881: LIST
75882: PUSH
75883: LD_INT 1
75885: PUSH
75886: LD_INT 1
75888: PUSH
75889: EMPTY
75890: LIST
75891: LIST
75892: PUSH
75893: LD_INT 0
75895: PUSH
75896: LD_INT 1
75898: PUSH
75899: EMPTY
75900: LIST
75901: LIST
75902: PUSH
75903: LD_INT 1
75905: NEG
75906: PUSH
75907: LD_INT 0
75909: PUSH
75910: EMPTY
75911: LIST
75912: LIST
75913: PUSH
75914: LD_INT 1
75916: NEG
75917: PUSH
75918: LD_INT 1
75920: NEG
75921: PUSH
75922: EMPTY
75923: LIST
75924: LIST
75925: PUSH
75926: LD_INT 1
75928: NEG
75929: PUSH
75930: LD_INT 2
75932: NEG
75933: PUSH
75934: EMPTY
75935: LIST
75936: LIST
75937: PUSH
75938: LD_INT 0
75940: PUSH
75941: LD_INT 2
75943: NEG
75944: PUSH
75945: EMPTY
75946: LIST
75947: LIST
75948: PUSH
75949: LD_INT 1
75951: PUSH
75952: LD_INT 1
75954: NEG
75955: PUSH
75956: EMPTY
75957: LIST
75958: LIST
75959: PUSH
75960: LD_INT 2
75962: PUSH
75963: LD_INT 0
75965: PUSH
75966: EMPTY
75967: LIST
75968: LIST
75969: PUSH
75970: LD_INT 2
75972: PUSH
75973: LD_INT 1
75975: PUSH
75976: EMPTY
75977: LIST
75978: LIST
75979: PUSH
75980: LD_INT 2
75982: PUSH
75983: LD_INT 2
75985: PUSH
75986: EMPTY
75987: LIST
75988: LIST
75989: PUSH
75990: LD_INT 1
75992: PUSH
75993: LD_INT 2
75995: PUSH
75996: EMPTY
75997: LIST
75998: LIST
75999: PUSH
76000: LD_INT 0
76002: PUSH
76003: LD_INT 2
76005: PUSH
76006: EMPTY
76007: LIST
76008: LIST
76009: PUSH
76010: LD_INT 1
76012: NEG
76013: PUSH
76014: LD_INT 1
76016: PUSH
76017: EMPTY
76018: LIST
76019: LIST
76020: PUSH
76021: LD_INT 2
76023: NEG
76024: PUSH
76025: LD_INT 0
76027: PUSH
76028: EMPTY
76029: LIST
76030: LIST
76031: PUSH
76032: LD_INT 2
76034: NEG
76035: PUSH
76036: LD_INT 1
76038: NEG
76039: PUSH
76040: EMPTY
76041: LIST
76042: LIST
76043: PUSH
76044: LD_INT 2
76046: NEG
76047: PUSH
76048: LD_INT 2
76050: NEG
76051: PUSH
76052: EMPTY
76053: LIST
76054: LIST
76055: PUSH
76056: EMPTY
76057: LIST
76058: LIST
76059: LIST
76060: LIST
76061: LIST
76062: LIST
76063: LIST
76064: LIST
76065: LIST
76066: LIST
76067: LIST
76068: LIST
76069: LIST
76070: LIST
76071: LIST
76072: LIST
76073: LIST
76074: LIST
76075: LIST
76076: ST_TO_ADDR
// fBarracks1 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
76077: LD_ADDR_VAR 0 54
76081: PUSH
76082: LD_INT 0
76084: PUSH
76085: LD_INT 0
76087: PUSH
76088: EMPTY
76089: LIST
76090: LIST
76091: PUSH
76092: LD_INT 0
76094: PUSH
76095: LD_INT 1
76097: NEG
76098: PUSH
76099: EMPTY
76100: LIST
76101: LIST
76102: PUSH
76103: LD_INT 1
76105: PUSH
76106: LD_INT 0
76108: PUSH
76109: EMPTY
76110: LIST
76111: LIST
76112: PUSH
76113: LD_INT 1
76115: PUSH
76116: LD_INT 1
76118: PUSH
76119: EMPTY
76120: LIST
76121: LIST
76122: PUSH
76123: LD_INT 0
76125: PUSH
76126: LD_INT 1
76128: PUSH
76129: EMPTY
76130: LIST
76131: LIST
76132: PUSH
76133: LD_INT 1
76135: NEG
76136: PUSH
76137: LD_INT 0
76139: PUSH
76140: EMPTY
76141: LIST
76142: LIST
76143: PUSH
76144: LD_INT 1
76146: NEG
76147: PUSH
76148: LD_INT 1
76150: NEG
76151: PUSH
76152: EMPTY
76153: LIST
76154: LIST
76155: PUSH
76156: LD_INT 1
76158: NEG
76159: PUSH
76160: LD_INT 2
76162: NEG
76163: PUSH
76164: EMPTY
76165: LIST
76166: LIST
76167: PUSH
76168: LD_INT 0
76170: PUSH
76171: LD_INT 2
76173: NEG
76174: PUSH
76175: EMPTY
76176: LIST
76177: LIST
76178: PUSH
76179: LD_INT 1
76181: PUSH
76182: LD_INT 1
76184: NEG
76185: PUSH
76186: EMPTY
76187: LIST
76188: LIST
76189: PUSH
76190: LD_INT 2
76192: PUSH
76193: LD_INT 0
76195: PUSH
76196: EMPTY
76197: LIST
76198: LIST
76199: PUSH
76200: LD_INT 2
76202: PUSH
76203: LD_INT 1
76205: PUSH
76206: EMPTY
76207: LIST
76208: LIST
76209: PUSH
76210: LD_INT 2
76212: PUSH
76213: LD_INT 2
76215: PUSH
76216: EMPTY
76217: LIST
76218: LIST
76219: PUSH
76220: LD_INT 1
76222: PUSH
76223: LD_INT 2
76225: PUSH
76226: EMPTY
76227: LIST
76228: LIST
76229: PUSH
76230: LD_INT 0
76232: PUSH
76233: LD_INT 2
76235: PUSH
76236: EMPTY
76237: LIST
76238: LIST
76239: PUSH
76240: LD_INT 1
76242: NEG
76243: PUSH
76244: LD_INT 1
76246: PUSH
76247: EMPTY
76248: LIST
76249: LIST
76250: PUSH
76251: LD_INT 2
76253: NEG
76254: PUSH
76255: LD_INT 0
76257: PUSH
76258: EMPTY
76259: LIST
76260: LIST
76261: PUSH
76262: LD_INT 2
76264: NEG
76265: PUSH
76266: LD_INT 1
76268: NEG
76269: PUSH
76270: EMPTY
76271: LIST
76272: LIST
76273: PUSH
76274: LD_INT 2
76276: NEG
76277: PUSH
76278: LD_INT 2
76280: NEG
76281: PUSH
76282: EMPTY
76283: LIST
76284: LIST
76285: PUSH
76286: EMPTY
76287: LIST
76288: LIST
76289: LIST
76290: LIST
76291: LIST
76292: LIST
76293: LIST
76294: LIST
76295: LIST
76296: LIST
76297: LIST
76298: LIST
76299: LIST
76300: LIST
76301: LIST
76302: LIST
76303: LIST
76304: LIST
76305: LIST
76306: ST_TO_ADDR
// fBarracks2 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
76307: LD_ADDR_VAR 0 55
76311: PUSH
76312: LD_INT 0
76314: PUSH
76315: LD_INT 0
76317: PUSH
76318: EMPTY
76319: LIST
76320: LIST
76321: PUSH
76322: LD_INT 0
76324: PUSH
76325: LD_INT 1
76327: NEG
76328: PUSH
76329: EMPTY
76330: LIST
76331: LIST
76332: PUSH
76333: LD_INT 1
76335: PUSH
76336: LD_INT 0
76338: PUSH
76339: EMPTY
76340: LIST
76341: LIST
76342: PUSH
76343: LD_INT 1
76345: PUSH
76346: LD_INT 1
76348: PUSH
76349: EMPTY
76350: LIST
76351: LIST
76352: PUSH
76353: LD_INT 0
76355: PUSH
76356: LD_INT 1
76358: PUSH
76359: EMPTY
76360: LIST
76361: LIST
76362: PUSH
76363: LD_INT 1
76365: NEG
76366: PUSH
76367: LD_INT 0
76369: PUSH
76370: EMPTY
76371: LIST
76372: LIST
76373: PUSH
76374: LD_INT 1
76376: NEG
76377: PUSH
76378: LD_INT 1
76380: NEG
76381: PUSH
76382: EMPTY
76383: LIST
76384: LIST
76385: PUSH
76386: LD_INT 1
76388: NEG
76389: PUSH
76390: LD_INT 2
76392: NEG
76393: PUSH
76394: EMPTY
76395: LIST
76396: LIST
76397: PUSH
76398: LD_INT 0
76400: PUSH
76401: LD_INT 2
76403: NEG
76404: PUSH
76405: EMPTY
76406: LIST
76407: LIST
76408: PUSH
76409: LD_INT 1
76411: PUSH
76412: LD_INT 1
76414: NEG
76415: PUSH
76416: EMPTY
76417: LIST
76418: LIST
76419: PUSH
76420: LD_INT 2
76422: PUSH
76423: LD_INT 0
76425: PUSH
76426: EMPTY
76427: LIST
76428: LIST
76429: PUSH
76430: LD_INT 2
76432: PUSH
76433: LD_INT 1
76435: PUSH
76436: EMPTY
76437: LIST
76438: LIST
76439: PUSH
76440: LD_INT 2
76442: PUSH
76443: LD_INT 2
76445: PUSH
76446: EMPTY
76447: LIST
76448: LIST
76449: PUSH
76450: LD_INT 1
76452: PUSH
76453: LD_INT 2
76455: PUSH
76456: EMPTY
76457: LIST
76458: LIST
76459: PUSH
76460: LD_INT 0
76462: PUSH
76463: LD_INT 2
76465: PUSH
76466: EMPTY
76467: LIST
76468: LIST
76469: PUSH
76470: LD_INT 1
76472: NEG
76473: PUSH
76474: LD_INT 1
76476: PUSH
76477: EMPTY
76478: LIST
76479: LIST
76480: PUSH
76481: LD_INT 2
76483: NEG
76484: PUSH
76485: LD_INT 0
76487: PUSH
76488: EMPTY
76489: LIST
76490: LIST
76491: PUSH
76492: LD_INT 2
76494: NEG
76495: PUSH
76496: LD_INT 1
76498: NEG
76499: PUSH
76500: EMPTY
76501: LIST
76502: LIST
76503: PUSH
76504: LD_INT 2
76506: NEG
76507: PUSH
76508: LD_INT 2
76510: NEG
76511: PUSH
76512: EMPTY
76513: LIST
76514: LIST
76515: PUSH
76516: EMPTY
76517: LIST
76518: LIST
76519: LIST
76520: LIST
76521: LIST
76522: LIST
76523: LIST
76524: LIST
76525: LIST
76526: LIST
76527: LIST
76528: LIST
76529: LIST
76530: LIST
76531: LIST
76532: LIST
76533: LIST
76534: LIST
76535: LIST
76536: ST_TO_ADDR
// fBarracks3 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
76537: LD_ADDR_VAR 0 56
76541: PUSH
76542: LD_INT 0
76544: PUSH
76545: LD_INT 0
76547: PUSH
76548: EMPTY
76549: LIST
76550: LIST
76551: PUSH
76552: LD_INT 0
76554: PUSH
76555: LD_INT 1
76557: NEG
76558: PUSH
76559: EMPTY
76560: LIST
76561: LIST
76562: PUSH
76563: LD_INT 1
76565: PUSH
76566: LD_INT 0
76568: PUSH
76569: EMPTY
76570: LIST
76571: LIST
76572: PUSH
76573: LD_INT 1
76575: PUSH
76576: LD_INT 1
76578: PUSH
76579: EMPTY
76580: LIST
76581: LIST
76582: PUSH
76583: LD_INT 0
76585: PUSH
76586: LD_INT 1
76588: PUSH
76589: EMPTY
76590: LIST
76591: LIST
76592: PUSH
76593: LD_INT 1
76595: NEG
76596: PUSH
76597: LD_INT 0
76599: PUSH
76600: EMPTY
76601: LIST
76602: LIST
76603: PUSH
76604: LD_INT 1
76606: NEG
76607: PUSH
76608: LD_INT 1
76610: NEG
76611: PUSH
76612: EMPTY
76613: LIST
76614: LIST
76615: PUSH
76616: LD_INT 1
76618: NEG
76619: PUSH
76620: LD_INT 2
76622: NEG
76623: PUSH
76624: EMPTY
76625: LIST
76626: LIST
76627: PUSH
76628: LD_INT 0
76630: PUSH
76631: LD_INT 2
76633: NEG
76634: PUSH
76635: EMPTY
76636: LIST
76637: LIST
76638: PUSH
76639: LD_INT 1
76641: PUSH
76642: LD_INT 1
76644: NEG
76645: PUSH
76646: EMPTY
76647: LIST
76648: LIST
76649: PUSH
76650: LD_INT 2
76652: PUSH
76653: LD_INT 0
76655: PUSH
76656: EMPTY
76657: LIST
76658: LIST
76659: PUSH
76660: LD_INT 2
76662: PUSH
76663: LD_INT 1
76665: PUSH
76666: EMPTY
76667: LIST
76668: LIST
76669: PUSH
76670: LD_INT 2
76672: PUSH
76673: LD_INT 2
76675: PUSH
76676: EMPTY
76677: LIST
76678: LIST
76679: PUSH
76680: LD_INT 1
76682: PUSH
76683: LD_INT 2
76685: PUSH
76686: EMPTY
76687: LIST
76688: LIST
76689: PUSH
76690: LD_INT 0
76692: PUSH
76693: LD_INT 2
76695: PUSH
76696: EMPTY
76697: LIST
76698: LIST
76699: PUSH
76700: LD_INT 1
76702: NEG
76703: PUSH
76704: LD_INT 1
76706: PUSH
76707: EMPTY
76708: LIST
76709: LIST
76710: PUSH
76711: LD_INT 2
76713: NEG
76714: PUSH
76715: LD_INT 0
76717: PUSH
76718: EMPTY
76719: LIST
76720: LIST
76721: PUSH
76722: LD_INT 2
76724: NEG
76725: PUSH
76726: LD_INT 1
76728: NEG
76729: PUSH
76730: EMPTY
76731: LIST
76732: LIST
76733: PUSH
76734: LD_INT 2
76736: NEG
76737: PUSH
76738: LD_INT 2
76740: NEG
76741: PUSH
76742: EMPTY
76743: LIST
76744: LIST
76745: PUSH
76746: EMPTY
76747: LIST
76748: LIST
76749: LIST
76750: LIST
76751: LIST
76752: LIST
76753: LIST
76754: LIST
76755: LIST
76756: LIST
76757: LIST
76758: LIST
76759: LIST
76760: LIST
76761: LIST
76762: LIST
76763: LIST
76764: LIST
76765: LIST
76766: ST_TO_ADDR
// fBarracks4 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
76767: LD_ADDR_VAR 0 57
76771: PUSH
76772: LD_INT 0
76774: PUSH
76775: LD_INT 0
76777: PUSH
76778: EMPTY
76779: LIST
76780: LIST
76781: PUSH
76782: LD_INT 0
76784: PUSH
76785: LD_INT 1
76787: NEG
76788: PUSH
76789: EMPTY
76790: LIST
76791: LIST
76792: PUSH
76793: LD_INT 1
76795: PUSH
76796: LD_INT 0
76798: PUSH
76799: EMPTY
76800: LIST
76801: LIST
76802: PUSH
76803: LD_INT 1
76805: PUSH
76806: LD_INT 1
76808: PUSH
76809: EMPTY
76810: LIST
76811: LIST
76812: PUSH
76813: LD_INT 0
76815: PUSH
76816: LD_INT 1
76818: PUSH
76819: EMPTY
76820: LIST
76821: LIST
76822: PUSH
76823: LD_INT 1
76825: NEG
76826: PUSH
76827: LD_INT 0
76829: PUSH
76830: EMPTY
76831: LIST
76832: LIST
76833: PUSH
76834: LD_INT 1
76836: NEG
76837: PUSH
76838: LD_INT 1
76840: NEG
76841: PUSH
76842: EMPTY
76843: LIST
76844: LIST
76845: PUSH
76846: LD_INT 1
76848: NEG
76849: PUSH
76850: LD_INT 2
76852: NEG
76853: PUSH
76854: EMPTY
76855: LIST
76856: LIST
76857: PUSH
76858: LD_INT 0
76860: PUSH
76861: LD_INT 2
76863: NEG
76864: PUSH
76865: EMPTY
76866: LIST
76867: LIST
76868: PUSH
76869: LD_INT 1
76871: PUSH
76872: LD_INT 1
76874: NEG
76875: PUSH
76876: EMPTY
76877: LIST
76878: LIST
76879: PUSH
76880: LD_INT 2
76882: PUSH
76883: LD_INT 0
76885: PUSH
76886: EMPTY
76887: LIST
76888: LIST
76889: PUSH
76890: LD_INT 2
76892: PUSH
76893: LD_INT 1
76895: PUSH
76896: EMPTY
76897: LIST
76898: LIST
76899: PUSH
76900: LD_INT 2
76902: PUSH
76903: LD_INT 2
76905: PUSH
76906: EMPTY
76907: LIST
76908: LIST
76909: PUSH
76910: LD_INT 1
76912: PUSH
76913: LD_INT 2
76915: PUSH
76916: EMPTY
76917: LIST
76918: LIST
76919: PUSH
76920: LD_INT 0
76922: PUSH
76923: LD_INT 2
76925: PUSH
76926: EMPTY
76927: LIST
76928: LIST
76929: PUSH
76930: LD_INT 1
76932: NEG
76933: PUSH
76934: LD_INT 1
76936: PUSH
76937: EMPTY
76938: LIST
76939: LIST
76940: PUSH
76941: LD_INT 2
76943: NEG
76944: PUSH
76945: LD_INT 0
76947: PUSH
76948: EMPTY
76949: LIST
76950: LIST
76951: PUSH
76952: LD_INT 2
76954: NEG
76955: PUSH
76956: LD_INT 1
76958: NEG
76959: PUSH
76960: EMPTY
76961: LIST
76962: LIST
76963: PUSH
76964: LD_INT 2
76966: NEG
76967: PUSH
76968: LD_INT 2
76970: NEG
76971: PUSH
76972: EMPTY
76973: LIST
76974: LIST
76975: PUSH
76976: EMPTY
76977: LIST
76978: LIST
76979: LIST
76980: LIST
76981: LIST
76982: LIST
76983: LIST
76984: LIST
76985: LIST
76986: LIST
76987: LIST
76988: LIST
76989: LIST
76990: LIST
76991: LIST
76992: LIST
76993: LIST
76994: LIST
76995: LIST
76996: ST_TO_ADDR
// fBarracks5 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
76997: LD_ADDR_VAR 0 58
77001: PUSH
77002: LD_INT 0
77004: PUSH
77005: LD_INT 0
77007: PUSH
77008: EMPTY
77009: LIST
77010: LIST
77011: PUSH
77012: LD_INT 0
77014: PUSH
77015: LD_INT 1
77017: NEG
77018: PUSH
77019: EMPTY
77020: LIST
77021: LIST
77022: PUSH
77023: LD_INT 1
77025: PUSH
77026: LD_INT 0
77028: PUSH
77029: EMPTY
77030: LIST
77031: LIST
77032: PUSH
77033: LD_INT 1
77035: PUSH
77036: LD_INT 1
77038: PUSH
77039: EMPTY
77040: LIST
77041: LIST
77042: PUSH
77043: LD_INT 0
77045: PUSH
77046: LD_INT 1
77048: PUSH
77049: EMPTY
77050: LIST
77051: LIST
77052: PUSH
77053: LD_INT 1
77055: NEG
77056: PUSH
77057: LD_INT 0
77059: PUSH
77060: EMPTY
77061: LIST
77062: LIST
77063: PUSH
77064: LD_INT 1
77066: NEG
77067: PUSH
77068: LD_INT 1
77070: NEG
77071: PUSH
77072: EMPTY
77073: LIST
77074: LIST
77075: PUSH
77076: LD_INT 1
77078: NEG
77079: PUSH
77080: LD_INT 2
77082: NEG
77083: PUSH
77084: EMPTY
77085: LIST
77086: LIST
77087: PUSH
77088: LD_INT 0
77090: PUSH
77091: LD_INT 2
77093: NEG
77094: PUSH
77095: EMPTY
77096: LIST
77097: LIST
77098: PUSH
77099: LD_INT 1
77101: PUSH
77102: LD_INT 1
77104: NEG
77105: PUSH
77106: EMPTY
77107: LIST
77108: LIST
77109: PUSH
77110: LD_INT 2
77112: PUSH
77113: LD_INT 0
77115: PUSH
77116: EMPTY
77117: LIST
77118: LIST
77119: PUSH
77120: LD_INT 2
77122: PUSH
77123: LD_INT 1
77125: PUSH
77126: EMPTY
77127: LIST
77128: LIST
77129: PUSH
77130: LD_INT 2
77132: PUSH
77133: LD_INT 2
77135: PUSH
77136: EMPTY
77137: LIST
77138: LIST
77139: PUSH
77140: LD_INT 1
77142: PUSH
77143: LD_INT 2
77145: PUSH
77146: EMPTY
77147: LIST
77148: LIST
77149: PUSH
77150: LD_INT 0
77152: PUSH
77153: LD_INT 2
77155: PUSH
77156: EMPTY
77157: LIST
77158: LIST
77159: PUSH
77160: LD_INT 1
77162: NEG
77163: PUSH
77164: LD_INT 1
77166: PUSH
77167: EMPTY
77168: LIST
77169: LIST
77170: PUSH
77171: LD_INT 2
77173: NEG
77174: PUSH
77175: LD_INT 0
77177: PUSH
77178: EMPTY
77179: LIST
77180: LIST
77181: PUSH
77182: LD_INT 2
77184: NEG
77185: PUSH
77186: LD_INT 1
77188: NEG
77189: PUSH
77190: EMPTY
77191: LIST
77192: LIST
77193: PUSH
77194: LD_INT 2
77196: NEG
77197: PUSH
77198: LD_INT 2
77200: NEG
77201: PUSH
77202: EMPTY
77203: LIST
77204: LIST
77205: PUSH
77206: EMPTY
77207: LIST
77208: LIST
77209: LIST
77210: LIST
77211: LIST
77212: LIST
77213: LIST
77214: LIST
77215: LIST
77216: LIST
77217: LIST
77218: LIST
77219: LIST
77220: LIST
77221: LIST
77222: LIST
77223: LIST
77224: LIST
77225: LIST
77226: ST_TO_ADDR
// fBunker0 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] ] ;
77227: LD_ADDR_VAR 0 59
77231: PUSH
77232: LD_INT 0
77234: PUSH
77235: LD_INT 0
77237: PUSH
77238: EMPTY
77239: LIST
77240: LIST
77241: PUSH
77242: LD_INT 0
77244: PUSH
77245: LD_INT 1
77247: NEG
77248: PUSH
77249: EMPTY
77250: LIST
77251: LIST
77252: PUSH
77253: LD_INT 1
77255: PUSH
77256: LD_INT 0
77258: PUSH
77259: EMPTY
77260: LIST
77261: LIST
77262: PUSH
77263: LD_INT 1
77265: PUSH
77266: LD_INT 1
77268: PUSH
77269: EMPTY
77270: LIST
77271: LIST
77272: PUSH
77273: LD_INT 0
77275: PUSH
77276: LD_INT 1
77278: PUSH
77279: EMPTY
77280: LIST
77281: LIST
77282: PUSH
77283: LD_INT 1
77285: NEG
77286: PUSH
77287: LD_INT 0
77289: PUSH
77290: EMPTY
77291: LIST
77292: LIST
77293: PUSH
77294: LD_INT 1
77296: NEG
77297: PUSH
77298: LD_INT 1
77300: NEG
77301: PUSH
77302: EMPTY
77303: LIST
77304: LIST
77305: PUSH
77306: EMPTY
77307: LIST
77308: LIST
77309: LIST
77310: LIST
77311: LIST
77312: LIST
77313: LIST
77314: ST_TO_ADDR
// fBunker1 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] ] ;
77315: LD_ADDR_VAR 0 60
77319: PUSH
77320: LD_INT 0
77322: PUSH
77323: LD_INT 0
77325: PUSH
77326: EMPTY
77327: LIST
77328: LIST
77329: PUSH
77330: LD_INT 0
77332: PUSH
77333: LD_INT 1
77335: NEG
77336: PUSH
77337: EMPTY
77338: LIST
77339: LIST
77340: PUSH
77341: LD_INT 1
77343: PUSH
77344: LD_INT 0
77346: PUSH
77347: EMPTY
77348: LIST
77349: LIST
77350: PUSH
77351: LD_INT 1
77353: PUSH
77354: LD_INT 1
77356: PUSH
77357: EMPTY
77358: LIST
77359: LIST
77360: PUSH
77361: LD_INT 0
77363: PUSH
77364: LD_INT 1
77366: PUSH
77367: EMPTY
77368: LIST
77369: LIST
77370: PUSH
77371: LD_INT 1
77373: NEG
77374: PUSH
77375: LD_INT 0
77377: PUSH
77378: EMPTY
77379: LIST
77380: LIST
77381: PUSH
77382: LD_INT 1
77384: NEG
77385: PUSH
77386: LD_INT 1
77388: NEG
77389: PUSH
77390: EMPTY
77391: LIST
77392: LIST
77393: PUSH
77394: EMPTY
77395: LIST
77396: LIST
77397: LIST
77398: LIST
77399: LIST
77400: LIST
77401: LIST
77402: ST_TO_ADDR
// fBunker2 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] ] ;
77403: LD_ADDR_VAR 0 61
77407: PUSH
77408: LD_INT 0
77410: PUSH
77411: LD_INT 0
77413: PUSH
77414: EMPTY
77415: LIST
77416: LIST
77417: PUSH
77418: LD_INT 0
77420: PUSH
77421: LD_INT 1
77423: NEG
77424: PUSH
77425: EMPTY
77426: LIST
77427: LIST
77428: PUSH
77429: LD_INT 1
77431: PUSH
77432: LD_INT 0
77434: PUSH
77435: EMPTY
77436: LIST
77437: LIST
77438: PUSH
77439: LD_INT 1
77441: PUSH
77442: LD_INT 1
77444: PUSH
77445: EMPTY
77446: LIST
77447: LIST
77448: PUSH
77449: LD_INT 0
77451: PUSH
77452: LD_INT 1
77454: PUSH
77455: EMPTY
77456: LIST
77457: LIST
77458: PUSH
77459: LD_INT 1
77461: NEG
77462: PUSH
77463: LD_INT 0
77465: PUSH
77466: EMPTY
77467: LIST
77468: LIST
77469: PUSH
77470: LD_INT 1
77472: NEG
77473: PUSH
77474: LD_INT 1
77476: NEG
77477: PUSH
77478: EMPTY
77479: LIST
77480: LIST
77481: PUSH
77482: EMPTY
77483: LIST
77484: LIST
77485: LIST
77486: LIST
77487: LIST
77488: LIST
77489: LIST
77490: ST_TO_ADDR
// fBunker3 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] ] ;
77491: LD_ADDR_VAR 0 62
77495: PUSH
77496: LD_INT 0
77498: PUSH
77499: LD_INT 0
77501: PUSH
77502: EMPTY
77503: LIST
77504: LIST
77505: PUSH
77506: LD_INT 0
77508: PUSH
77509: LD_INT 1
77511: NEG
77512: PUSH
77513: EMPTY
77514: LIST
77515: LIST
77516: PUSH
77517: LD_INT 1
77519: PUSH
77520: LD_INT 0
77522: PUSH
77523: EMPTY
77524: LIST
77525: LIST
77526: PUSH
77527: LD_INT 1
77529: PUSH
77530: LD_INT 1
77532: PUSH
77533: EMPTY
77534: LIST
77535: LIST
77536: PUSH
77537: LD_INT 0
77539: PUSH
77540: LD_INT 1
77542: PUSH
77543: EMPTY
77544: LIST
77545: LIST
77546: PUSH
77547: LD_INT 1
77549: NEG
77550: PUSH
77551: LD_INT 0
77553: PUSH
77554: EMPTY
77555: LIST
77556: LIST
77557: PUSH
77558: LD_INT 1
77560: NEG
77561: PUSH
77562: LD_INT 1
77564: NEG
77565: PUSH
77566: EMPTY
77567: LIST
77568: LIST
77569: PUSH
77570: EMPTY
77571: LIST
77572: LIST
77573: LIST
77574: LIST
77575: LIST
77576: LIST
77577: LIST
77578: ST_TO_ADDR
// fBunker4 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] ] ;
77579: LD_ADDR_VAR 0 63
77583: PUSH
77584: LD_INT 0
77586: PUSH
77587: LD_INT 0
77589: PUSH
77590: EMPTY
77591: LIST
77592: LIST
77593: PUSH
77594: LD_INT 0
77596: PUSH
77597: LD_INT 1
77599: NEG
77600: PUSH
77601: EMPTY
77602: LIST
77603: LIST
77604: PUSH
77605: LD_INT 1
77607: PUSH
77608: LD_INT 0
77610: PUSH
77611: EMPTY
77612: LIST
77613: LIST
77614: PUSH
77615: LD_INT 1
77617: PUSH
77618: LD_INT 1
77620: PUSH
77621: EMPTY
77622: LIST
77623: LIST
77624: PUSH
77625: LD_INT 0
77627: PUSH
77628: LD_INT 1
77630: PUSH
77631: EMPTY
77632: LIST
77633: LIST
77634: PUSH
77635: LD_INT 1
77637: NEG
77638: PUSH
77639: LD_INT 0
77641: PUSH
77642: EMPTY
77643: LIST
77644: LIST
77645: PUSH
77646: LD_INT 1
77648: NEG
77649: PUSH
77650: LD_INT 1
77652: NEG
77653: PUSH
77654: EMPTY
77655: LIST
77656: LIST
77657: PUSH
77658: EMPTY
77659: LIST
77660: LIST
77661: LIST
77662: LIST
77663: LIST
77664: LIST
77665: LIST
77666: ST_TO_ADDR
// fBunker5 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] ] ;
77667: LD_ADDR_VAR 0 64
77671: PUSH
77672: LD_INT 0
77674: PUSH
77675: LD_INT 0
77677: PUSH
77678: EMPTY
77679: LIST
77680: LIST
77681: PUSH
77682: LD_INT 0
77684: PUSH
77685: LD_INT 1
77687: NEG
77688: PUSH
77689: EMPTY
77690: LIST
77691: LIST
77692: PUSH
77693: LD_INT 1
77695: PUSH
77696: LD_INT 0
77698: PUSH
77699: EMPTY
77700: LIST
77701: LIST
77702: PUSH
77703: LD_INT 1
77705: PUSH
77706: LD_INT 1
77708: PUSH
77709: EMPTY
77710: LIST
77711: LIST
77712: PUSH
77713: LD_INT 0
77715: PUSH
77716: LD_INT 1
77718: PUSH
77719: EMPTY
77720: LIST
77721: LIST
77722: PUSH
77723: LD_INT 1
77725: NEG
77726: PUSH
77727: LD_INT 0
77729: PUSH
77730: EMPTY
77731: LIST
77732: LIST
77733: PUSH
77734: LD_INT 1
77736: NEG
77737: PUSH
77738: LD_INT 1
77740: NEG
77741: PUSH
77742: EMPTY
77743: LIST
77744: LIST
77745: PUSH
77746: EMPTY
77747: LIST
77748: LIST
77749: LIST
77750: LIST
77751: LIST
77752: LIST
77753: LIST
77754: ST_TO_ADDR
// end ; 1 :
77755: GO 83652
77757: LD_INT 1
77759: DOUBLE
77760: EQUAL
77761: IFTRUE 77765
77763: GO 80388
77765: POP
// begin fDepotAm0 = [ [ - 1 , - 3 ] , [ 0 , - 3 ] , [ 1 , - 2 ] ] ;
77766: LD_ADDR_VAR 0 11
77770: PUSH
77771: LD_INT 1
77773: NEG
77774: PUSH
77775: LD_INT 3
77777: NEG
77778: PUSH
77779: EMPTY
77780: LIST
77781: LIST
77782: PUSH
77783: LD_INT 0
77785: PUSH
77786: LD_INT 3
77788: NEG
77789: PUSH
77790: EMPTY
77791: LIST
77792: LIST
77793: PUSH
77794: LD_INT 1
77796: PUSH
77797: LD_INT 2
77799: NEG
77800: PUSH
77801: EMPTY
77802: LIST
77803: LIST
77804: PUSH
77805: EMPTY
77806: LIST
77807: LIST
77808: LIST
77809: ST_TO_ADDR
// fDepotAm1 = [ [ 2 , - 1 ] , [ 3 , 0 ] , [ 3 , 1 ] ] ;
77810: LD_ADDR_VAR 0 12
77814: PUSH
77815: LD_INT 2
77817: PUSH
77818: LD_INT 1
77820: NEG
77821: PUSH
77822: EMPTY
77823: LIST
77824: LIST
77825: PUSH
77826: LD_INT 3
77828: PUSH
77829: LD_INT 0
77831: PUSH
77832: EMPTY
77833: LIST
77834: LIST
77835: PUSH
77836: LD_INT 3
77838: PUSH
77839: LD_INT 1
77841: PUSH
77842: EMPTY
77843: LIST
77844: LIST
77845: PUSH
77846: EMPTY
77847: LIST
77848: LIST
77849: LIST
77850: ST_TO_ADDR
// fDepotAm2 = [ [ 3 , 2 ] , [ 3 , 3 ] , [ 2 , 3 ] ] ;
77851: LD_ADDR_VAR 0 13
77855: PUSH
77856: LD_INT 3
77858: PUSH
77859: LD_INT 2
77861: PUSH
77862: EMPTY
77863: LIST
77864: LIST
77865: PUSH
77866: LD_INT 3
77868: PUSH
77869: LD_INT 3
77871: PUSH
77872: EMPTY
77873: LIST
77874: LIST
77875: PUSH
77876: LD_INT 2
77878: PUSH
77879: LD_INT 3
77881: PUSH
77882: EMPTY
77883: LIST
77884: LIST
77885: PUSH
77886: EMPTY
77887: LIST
77888: LIST
77889: LIST
77890: ST_TO_ADDR
// fDepotAm3 = [ [ 1 , 3 ] , [ 0 , 3 ] , [ - 1 , 2 ] ] ;
77891: LD_ADDR_VAR 0 14
77895: PUSH
77896: LD_INT 1
77898: PUSH
77899: LD_INT 3
77901: PUSH
77902: EMPTY
77903: LIST
77904: LIST
77905: PUSH
77906: LD_INT 0
77908: PUSH
77909: LD_INT 3
77911: PUSH
77912: EMPTY
77913: LIST
77914: LIST
77915: PUSH
77916: LD_INT 1
77918: NEG
77919: PUSH
77920: LD_INT 2
77922: PUSH
77923: EMPTY
77924: LIST
77925: LIST
77926: PUSH
77927: EMPTY
77928: LIST
77929: LIST
77930: LIST
77931: ST_TO_ADDR
// fDepotAm4 = [ [ - 2 , 1 ] , [ - 3 , 0 ] , [ - 3 , - 1 ] ] ;
77932: LD_ADDR_VAR 0 15
77936: PUSH
77937: LD_INT 2
77939: NEG
77940: PUSH
77941: LD_INT 1
77943: PUSH
77944: EMPTY
77945: LIST
77946: LIST
77947: PUSH
77948: LD_INT 3
77950: NEG
77951: PUSH
77952: LD_INT 0
77954: PUSH
77955: EMPTY
77956: LIST
77957: LIST
77958: PUSH
77959: LD_INT 3
77961: NEG
77962: PUSH
77963: LD_INT 1
77965: NEG
77966: PUSH
77967: EMPTY
77968: LIST
77969: LIST
77970: PUSH
77971: EMPTY
77972: LIST
77973: LIST
77974: LIST
77975: ST_TO_ADDR
// fDepotAm5 = [ [ - 2 , - 3 ] , [ - 3 , - 2 ] , [ - 3 , - 3 ] ] ;
77976: LD_ADDR_VAR 0 16
77980: PUSH
77981: LD_INT 2
77983: NEG
77984: PUSH
77985: LD_INT 3
77987: NEG
77988: PUSH
77989: EMPTY
77990: LIST
77991: LIST
77992: PUSH
77993: LD_INT 3
77995: NEG
77996: PUSH
77997: LD_INT 2
77999: NEG
78000: PUSH
78001: EMPTY
78002: LIST
78003: LIST
78004: PUSH
78005: LD_INT 3
78007: NEG
78008: PUSH
78009: LD_INT 3
78011: NEG
78012: PUSH
78013: EMPTY
78014: LIST
78015: LIST
78016: PUSH
78017: EMPTY
78018: LIST
78019: LIST
78020: LIST
78021: ST_TO_ADDR
// fDepotAr0 = [ [ - 1 , - 3 ] , [ 0 , - 3 ] , [ 1 , - 2 ] ] ;
78022: LD_ADDR_VAR 0 17
78026: PUSH
78027: LD_INT 1
78029: NEG
78030: PUSH
78031: LD_INT 3
78033: NEG
78034: PUSH
78035: EMPTY
78036: LIST
78037: LIST
78038: PUSH
78039: LD_INT 0
78041: PUSH
78042: LD_INT 3
78044: NEG
78045: PUSH
78046: EMPTY
78047: LIST
78048: LIST
78049: PUSH
78050: LD_INT 1
78052: PUSH
78053: LD_INT 2
78055: NEG
78056: PUSH
78057: EMPTY
78058: LIST
78059: LIST
78060: PUSH
78061: EMPTY
78062: LIST
78063: LIST
78064: LIST
78065: ST_TO_ADDR
// fDepotAr1 = [ [ 2 , - 1 ] , [ 3 , 0 ] , [ 3 , 1 ] ] ;
78066: LD_ADDR_VAR 0 18
78070: PUSH
78071: LD_INT 2
78073: PUSH
78074: LD_INT 1
78076: NEG
78077: PUSH
78078: EMPTY
78079: LIST
78080: LIST
78081: PUSH
78082: LD_INT 3
78084: PUSH
78085: LD_INT 0
78087: PUSH
78088: EMPTY
78089: LIST
78090: LIST
78091: PUSH
78092: LD_INT 3
78094: PUSH
78095: LD_INT 1
78097: PUSH
78098: EMPTY
78099: LIST
78100: LIST
78101: PUSH
78102: EMPTY
78103: LIST
78104: LIST
78105: LIST
78106: ST_TO_ADDR
// fDepotAr2 = [ [ 3 , 2 ] , [ 3 , 3 ] , [ 2 , 3 ] ] ;
78107: LD_ADDR_VAR 0 19
78111: PUSH
78112: LD_INT 3
78114: PUSH
78115: LD_INT 2
78117: PUSH
78118: EMPTY
78119: LIST
78120: LIST
78121: PUSH
78122: LD_INT 3
78124: PUSH
78125: LD_INT 3
78127: PUSH
78128: EMPTY
78129: LIST
78130: LIST
78131: PUSH
78132: LD_INT 2
78134: PUSH
78135: LD_INT 3
78137: PUSH
78138: EMPTY
78139: LIST
78140: LIST
78141: PUSH
78142: EMPTY
78143: LIST
78144: LIST
78145: LIST
78146: ST_TO_ADDR
// fDepotAr3 = [ [ 1 , 3 ] , [ 0 , 3 ] , [ - 1 , 2 ] ] ;
78147: LD_ADDR_VAR 0 20
78151: PUSH
78152: LD_INT 1
78154: PUSH
78155: LD_INT 3
78157: PUSH
78158: EMPTY
78159: LIST
78160: LIST
78161: PUSH
78162: LD_INT 0
78164: PUSH
78165: LD_INT 3
78167: PUSH
78168: EMPTY
78169: LIST
78170: LIST
78171: PUSH
78172: LD_INT 1
78174: NEG
78175: PUSH
78176: LD_INT 2
78178: PUSH
78179: EMPTY
78180: LIST
78181: LIST
78182: PUSH
78183: EMPTY
78184: LIST
78185: LIST
78186: LIST
78187: ST_TO_ADDR
// fDepotAr4 = [ [ - 2 , 1 ] , [ - 3 , 0 ] , [ - 3 , - 1 ] ] ;
78188: LD_ADDR_VAR 0 21
78192: PUSH
78193: LD_INT 2
78195: NEG
78196: PUSH
78197: LD_INT 1
78199: PUSH
78200: EMPTY
78201: LIST
78202: LIST
78203: PUSH
78204: LD_INT 3
78206: NEG
78207: PUSH
78208: LD_INT 0
78210: PUSH
78211: EMPTY
78212: LIST
78213: LIST
78214: PUSH
78215: LD_INT 3
78217: NEG
78218: PUSH
78219: LD_INT 1
78221: NEG
78222: PUSH
78223: EMPTY
78224: LIST
78225: LIST
78226: PUSH
78227: EMPTY
78228: LIST
78229: LIST
78230: LIST
78231: ST_TO_ADDR
// fDepotAr5 = [ [ - 2 , - 3 ] , [ - 3 , - 2 ] , [ - 3 , - 3 ] ] ;
78232: LD_ADDR_VAR 0 22
78236: PUSH
78237: LD_INT 2
78239: NEG
78240: PUSH
78241: LD_INT 3
78243: NEG
78244: PUSH
78245: EMPTY
78246: LIST
78247: LIST
78248: PUSH
78249: LD_INT 3
78251: NEG
78252: PUSH
78253: LD_INT 2
78255: NEG
78256: PUSH
78257: EMPTY
78258: LIST
78259: LIST
78260: PUSH
78261: LD_INT 3
78263: NEG
78264: PUSH
78265: LD_INT 3
78267: NEG
78268: PUSH
78269: EMPTY
78270: LIST
78271: LIST
78272: PUSH
78273: EMPTY
78274: LIST
78275: LIST
78276: LIST
78277: ST_TO_ADDR
// fDepotRu0 = [ [ 0 , - 3 ] , [ - 1 , - 4 ] , [ 1 , - 3 ] ] ;
78278: LD_ADDR_VAR 0 23
78282: PUSH
78283: LD_INT 0
78285: PUSH
78286: LD_INT 3
78288: NEG
78289: PUSH
78290: EMPTY
78291: LIST
78292: LIST
78293: PUSH
78294: LD_INT 1
78296: NEG
78297: PUSH
78298: LD_INT 4
78300: NEG
78301: PUSH
78302: EMPTY
78303: LIST
78304: LIST
78305: PUSH
78306: LD_INT 1
78308: PUSH
78309: LD_INT 3
78311: NEG
78312: PUSH
78313: EMPTY
78314: LIST
78315: LIST
78316: PUSH
78317: EMPTY
78318: LIST
78319: LIST
78320: LIST
78321: ST_TO_ADDR
// fDepotRu1 = [ [ 3 , 0 ] , [ 3 , - 1 ] , [ 4 , 1 ] ] ;
78322: LD_ADDR_VAR 0 24
78326: PUSH
78327: LD_INT 3
78329: PUSH
78330: LD_INT 0
78332: PUSH
78333: EMPTY
78334: LIST
78335: LIST
78336: PUSH
78337: LD_INT 3
78339: PUSH
78340: LD_INT 1
78342: NEG
78343: PUSH
78344: EMPTY
78345: LIST
78346: LIST
78347: PUSH
78348: LD_INT 4
78350: PUSH
78351: LD_INT 1
78353: PUSH
78354: EMPTY
78355: LIST
78356: LIST
78357: PUSH
78358: EMPTY
78359: LIST
78360: LIST
78361: LIST
78362: ST_TO_ADDR
// fDepotRu2 = [ [ 3 , 3 ] , [ 4 , 3 ] , [ 3 , 4 ] ] ;
78363: LD_ADDR_VAR 0 25
78367: PUSH
78368: LD_INT 3
78370: PUSH
78371: LD_INT 3
78373: PUSH
78374: EMPTY
78375: LIST
78376: LIST
78377: PUSH
78378: LD_INT 4
78380: PUSH
78381: LD_INT 3
78383: PUSH
78384: EMPTY
78385: LIST
78386: LIST
78387: PUSH
78388: LD_INT 3
78390: PUSH
78391: LD_INT 4
78393: PUSH
78394: EMPTY
78395: LIST
78396: LIST
78397: PUSH
78398: EMPTY
78399: LIST
78400: LIST
78401: LIST
78402: ST_TO_ADDR
// fDepotRu3 = [ [ 0 , 3 ] , [ 1 , 4 ] , [ - 1 , 3 ] ] ;
78403: LD_ADDR_VAR 0 26
78407: PUSH
78408: LD_INT 0
78410: PUSH
78411: LD_INT 3
78413: PUSH
78414: EMPTY
78415: LIST
78416: LIST
78417: PUSH
78418: LD_INT 1
78420: PUSH
78421: LD_INT 4
78423: PUSH
78424: EMPTY
78425: LIST
78426: LIST
78427: PUSH
78428: LD_INT 1
78430: NEG
78431: PUSH
78432: LD_INT 3
78434: PUSH
78435: EMPTY
78436: LIST
78437: LIST
78438: PUSH
78439: EMPTY
78440: LIST
78441: LIST
78442: LIST
78443: ST_TO_ADDR
// fDepotRu4 = [ [ - 3 , 0 ] , [ - 3 , 1 ] , [ - 4 , - 1 ] ] ;
78444: LD_ADDR_VAR 0 27
78448: PUSH
78449: LD_INT 3
78451: NEG
78452: PUSH
78453: LD_INT 0
78455: PUSH
78456: EMPTY
78457: LIST
78458: LIST
78459: PUSH
78460: LD_INT 3
78462: NEG
78463: PUSH
78464: LD_INT 1
78466: PUSH
78467: EMPTY
78468: LIST
78469: LIST
78470: PUSH
78471: LD_INT 4
78473: NEG
78474: PUSH
78475: LD_INT 1
78477: NEG
78478: PUSH
78479: EMPTY
78480: LIST
78481: LIST
78482: PUSH
78483: EMPTY
78484: LIST
78485: LIST
78486: LIST
78487: ST_TO_ADDR
// fDepotRu5 = [ [ - 3 , - 3 ] , [ - 3 , - 4 ] , [ - 4 , - 3 ] ] ;
78488: LD_ADDR_VAR 0 28
78492: PUSH
78493: LD_INT 3
78495: NEG
78496: PUSH
78497: LD_INT 3
78499: NEG
78500: PUSH
78501: EMPTY
78502: LIST
78503: LIST
78504: PUSH
78505: LD_INT 3
78507: NEG
78508: PUSH
78509: LD_INT 4
78511: NEG
78512: PUSH
78513: EMPTY
78514: LIST
78515: LIST
78516: PUSH
78517: LD_INT 4
78519: NEG
78520: PUSH
78521: LD_INT 3
78523: NEG
78524: PUSH
78525: EMPTY
78526: LIST
78527: LIST
78528: PUSH
78529: EMPTY
78530: LIST
78531: LIST
78532: LIST
78533: ST_TO_ADDR
// fFactory0 = [ [ - 1 , - 3 ] , [ 0 , - 3 ] , [ 1 , - 2 ] , [ - 1 , - 4 ] , [ 0 , - 4 ] , [ 1 , - 3 ] , [ - 1 , - 5 ] , [ 0 , - 5 ] , [ 1 , - 4 ] , [ - 1 , - 6 ] , [ 0 , - 6 ] , [ 1 , - 5 ] ] ;
78534: LD_ADDR_VAR 0 29
78538: PUSH
78539: LD_INT 1
78541: NEG
78542: PUSH
78543: LD_INT 3
78545: NEG
78546: PUSH
78547: EMPTY
78548: LIST
78549: LIST
78550: PUSH
78551: LD_INT 0
78553: PUSH
78554: LD_INT 3
78556: NEG
78557: PUSH
78558: EMPTY
78559: LIST
78560: LIST
78561: PUSH
78562: LD_INT 1
78564: PUSH
78565: LD_INT 2
78567: NEG
78568: PUSH
78569: EMPTY
78570: LIST
78571: LIST
78572: PUSH
78573: LD_INT 1
78575: NEG
78576: PUSH
78577: LD_INT 4
78579: NEG
78580: PUSH
78581: EMPTY
78582: LIST
78583: LIST
78584: PUSH
78585: LD_INT 0
78587: PUSH
78588: LD_INT 4
78590: NEG
78591: PUSH
78592: EMPTY
78593: LIST
78594: LIST
78595: PUSH
78596: LD_INT 1
78598: PUSH
78599: LD_INT 3
78601: NEG
78602: PUSH
78603: EMPTY
78604: LIST
78605: LIST
78606: PUSH
78607: LD_INT 1
78609: NEG
78610: PUSH
78611: LD_INT 5
78613: NEG
78614: PUSH
78615: EMPTY
78616: LIST
78617: LIST
78618: PUSH
78619: LD_INT 0
78621: PUSH
78622: LD_INT 5
78624: NEG
78625: PUSH
78626: EMPTY
78627: LIST
78628: LIST
78629: PUSH
78630: LD_INT 1
78632: PUSH
78633: LD_INT 4
78635: NEG
78636: PUSH
78637: EMPTY
78638: LIST
78639: LIST
78640: PUSH
78641: LD_INT 1
78643: NEG
78644: PUSH
78645: LD_INT 6
78647: NEG
78648: PUSH
78649: EMPTY
78650: LIST
78651: LIST
78652: PUSH
78653: LD_INT 0
78655: PUSH
78656: LD_INT 6
78658: NEG
78659: PUSH
78660: EMPTY
78661: LIST
78662: LIST
78663: PUSH
78664: LD_INT 1
78666: PUSH
78667: LD_INT 5
78669: NEG
78670: PUSH
78671: EMPTY
78672: LIST
78673: LIST
78674: PUSH
78675: EMPTY
78676: LIST
78677: LIST
78678: LIST
78679: LIST
78680: LIST
78681: LIST
78682: LIST
78683: LIST
78684: LIST
78685: LIST
78686: LIST
78687: LIST
78688: ST_TO_ADDR
// fFactory1 = [ [ 2 , - 1 ] , [ 3 , 0 ] , [ 3 , 1 ] , [ 3 , - 1 ] , [ 4 , 0 ] , [ 4 , 1 ] , [ 4 , - 1 ] , [ 5 , 0 ] , [ 5 , 1 ] , [ 5 , - 1 ] , [ 6 , 0 ] , [ 6 , 1 ] ] ;
78689: LD_ADDR_VAR 0 30
78693: PUSH
78694: LD_INT 2
78696: PUSH
78697: LD_INT 1
78699: NEG
78700: PUSH
78701: EMPTY
78702: LIST
78703: LIST
78704: PUSH
78705: LD_INT 3
78707: PUSH
78708: LD_INT 0
78710: PUSH
78711: EMPTY
78712: LIST
78713: LIST
78714: PUSH
78715: LD_INT 3
78717: PUSH
78718: LD_INT 1
78720: PUSH
78721: EMPTY
78722: LIST
78723: LIST
78724: PUSH
78725: LD_INT 3
78727: PUSH
78728: LD_INT 1
78730: NEG
78731: PUSH
78732: EMPTY
78733: LIST
78734: LIST
78735: PUSH
78736: LD_INT 4
78738: PUSH
78739: LD_INT 0
78741: PUSH
78742: EMPTY
78743: LIST
78744: LIST
78745: PUSH
78746: LD_INT 4
78748: PUSH
78749: LD_INT 1
78751: PUSH
78752: EMPTY
78753: LIST
78754: LIST
78755: PUSH
78756: LD_INT 4
78758: PUSH
78759: LD_INT 1
78761: NEG
78762: PUSH
78763: EMPTY
78764: LIST
78765: LIST
78766: PUSH
78767: LD_INT 5
78769: PUSH
78770: LD_INT 0
78772: PUSH
78773: EMPTY
78774: LIST
78775: LIST
78776: PUSH
78777: LD_INT 5
78779: PUSH
78780: LD_INT 1
78782: PUSH
78783: EMPTY
78784: LIST
78785: LIST
78786: PUSH
78787: LD_INT 5
78789: PUSH
78790: LD_INT 1
78792: NEG
78793: PUSH
78794: EMPTY
78795: LIST
78796: LIST
78797: PUSH
78798: LD_INT 6
78800: PUSH
78801: LD_INT 0
78803: PUSH
78804: EMPTY
78805: LIST
78806: LIST
78807: PUSH
78808: LD_INT 6
78810: PUSH
78811: LD_INT 1
78813: PUSH
78814: EMPTY
78815: LIST
78816: LIST
78817: PUSH
78818: EMPTY
78819: LIST
78820: LIST
78821: LIST
78822: LIST
78823: LIST
78824: LIST
78825: LIST
78826: LIST
78827: LIST
78828: LIST
78829: LIST
78830: LIST
78831: ST_TO_ADDR
// fFactory2 = [ [ 3 , 2 ] , [ 3 , 3 ] , [ 2 , 3 ] , [ 4 , 3 ] , [ 4 , 4 ] , [ 3 , 4 ] , [ 5 , 4 ] , [ 5 , 5 ] , [ 4 , 5 ] , [ 6 , 5 ] , [ 6 , 6 ] , [ 5 , 6 ] ] ;
78832: LD_ADDR_VAR 0 31
78836: PUSH
78837: LD_INT 3
78839: PUSH
78840: LD_INT 2
78842: PUSH
78843: EMPTY
78844: LIST
78845: LIST
78846: PUSH
78847: LD_INT 3
78849: PUSH
78850: LD_INT 3
78852: PUSH
78853: EMPTY
78854: LIST
78855: LIST
78856: PUSH
78857: LD_INT 2
78859: PUSH
78860: LD_INT 3
78862: PUSH
78863: EMPTY
78864: LIST
78865: LIST
78866: PUSH
78867: LD_INT 4
78869: PUSH
78870: LD_INT 3
78872: PUSH
78873: EMPTY
78874: LIST
78875: LIST
78876: PUSH
78877: LD_INT 4
78879: PUSH
78880: LD_INT 4
78882: PUSH
78883: EMPTY
78884: LIST
78885: LIST
78886: PUSH
78887: LD_INT 3
78889: PUSH
78890: LD_INT 4
78892: PUSH
78893: EMPTY
78894: LIST
78895: LIST
78896: PUSH
78897: LD_INT 5
78899: PUSH
78900: LD_INT 4
78902: PUSH
78903: EMPTY
78904: LIST
78905: LIST
78906: PUSH
78907: LD_INT 5
78909: PUSH
78910: LD_INT 5
78912: PUSH
78913: EMPTY
78914: LIST
78915: LIST
78916: PUSH
78917: LD_INT 4
78919: PUSH
78920: LD_INT 5
78922: PUSH
78923: EMPTY
78924: LIST
78925: LIST
78926: PUSH
78927: LD_INT 6
78929: PUSH
78930: LD_INT 5
78932: PUSH
78933: EMPTY
78934: LIST
78935: LIST
78936: PUSH
78937: LD_INT 6
78939: PUSH
78940: LD_INT 6
78942: PUSH
78943: EMPTY
78944: LIST
78945: LIST
78946: PUSH
78947: LD_INT 5
78949: PUSH
78950: LD_INT 6
78952: PUSH
78953: EMPTY
78954: LIST
78955: LIST
78956: PUSH
78957: EMPTY
78958: LIST
78959: LIST
78960: LIST
78961: LIST
78962: LIST
78963: LIST
78964: LIST
78965: LIST
78966: LIST
78967: LIST
78968: LIST
78969: LIST
78970: ST_TO_ADDR
// fFactory3 = [ [ 1 , 3 ] , [ 0 , 3 ] , [ - 1 , 2 ] , [ 1 , 4 ] , [ 0 , 4 ] , [ - 1 , 3 ] , [ 1 , 5 ] , [ 0 , 5 ] , [ - 1 , 4 ] , [ 1 , 6 ] , [ 0 , 6 ] , [ - 1 , 5 ] ] ;
78971: LD_ADDR_VAR 0 32
78975: PUSH
78976: LD_INT 1
78978: PUSH
78979: LD_INT 3
78981: PUSH
78982: EMPTY
78983: LIST
78984: LIST
78985: PUSH
78986: LD_INT 0
78988: PUSH
78989: LD_INT 3
78991: PUSH
78992: EMPTY
78993: LIST
78994: LIST
78995: PUSH
78996: LD_INT 1
78998: NEG
78999: PUSH
79000: LD_INT 2
79002: PUSH
79003: EMPTY
79004: LIST
79005: LIST
79006: PUSH
79007: LD_INT 1
79009: PUSH
79010: LD_INT 4
79012: PUSH
79013: EMPTY
79014: LIST
79015: LIST
79016: PUSH
79017: LD_INT 0
79019: PUSH
79020: LD_INT 4
79022: PUSH
79023: EMPTY
79024: LIST
79025: LIST
79026: PUSH
79027: LD_INT 1
79029: NEG
79030: PUSH
79031: LD_INT 3
79033: PUSH
79034: EMPTY
79035: LIST
79036: LIST
79037: PUSH
79038: LD_INT 1
79040: PUSH
79041: LD_INT 5
79043: PUSH
79044: EMPTY
79045: LIST
79046: LIST
79047: PUSH
79048: LD_INT 0
79050: PUSH
79051: LD_INT 5
79053: PUSH
79054: EMPTY
79055: LIST
79056: LIST
79057: PUSH
79058: LD_INT 1
79060: NEG
79061: PUSH
79062: LD_INT 4
79064: PUSH
79065: EMPTY
79066: LIST
79067: LIST
79068: PUSH
79069: LD_INT 1
79071: PUSH
79072: LD_INT 6
79074: PUSH
79075: EMPTY
79076: LIST
79077: LIST
79078: PUSH
79079: LD_INT 0
79081: PUSH
79082: LD_INT 6
79084: PUSH
79085: EMPTY
79086: LIST
79087: LIST
79088: PUSH
79089: LD_INT 1
79091: NEG
79092: PUSH
79093: LD_INT 5
79095: PUSH
79096: EMPTY
79097: LIST
79098: LIST
79099: PUSH
79100: EMPTY
79101: LIST
79102: LIST
79103: LIST
79104: LIST
79105: LIST
79106: LIST
79107: LIST
79108: LIST
79109: LIST
79110: LIST
79111: LIST
79112: LIST
79113: ST_TO_ADDR
// fFactory4 = [ [ - 2 , 1 ] , [ - 3 , 0 ] , [ - 3 , - 1 ] , [ - 3 , 1 ] , [ - 4 , 0 ] , [ - 4 , - 1 ] , [ - 4 , 1 ] , [ - 5 , 0 ] , [ - 5 , - 1 ] , [ - 5 , 1 ] , [ - 6 , 0 ] , [ - 6 , - 1 ] ] ;
79114: LD_ADDR_VAR 0 33
79118: PUSH
79119: LD_INT 2
79121: NEG
79122: PUSH
79123: LD_INT 1
79125: PUSH
79126: EMPTY
79127: LIST
79128: LIST
79129: PUSH
79130: LD_INT 3
79132: NEG
79133: PUSH
79134: LD_INT 0
79136: PUSH
79137: EMPTY
79138: LIST
79139: LIST
79140: PUSH
79141: LD_INT 3
79143: NEG
79144: PUSH
79145: LD_INT 1
79147: NEG
79148: PUSH
79149: EMPTY
79150: LIST
79151: LIST
79152: PUSH
79153: LD_INT 3
79155: NEG
79156: PUSH
79157: LD_INT 1
79159: PUSH
79160: EMPTY
79161: LIST
79162: LIST
79163: PUSH
79164: LD_INT 4
79166: NEG
79167: PUSH
79168: LD_INT 0
79170: PUSH
79171: EMPTY
79172: LIST
79173: LIST
79174: PUSH
79175: LD_INT 4
79177: NEG
79178: PUSH
79179: LD_INT 1
79181: NEG
79182: PUSH
79183: EMPTY
79184: LIST
79185: LIST
79186: PUSH
79187: LD_INT 4
79189: NEG
79190: PUSH
79191: LD_INT 1
79193: PUSH
79194: EMPTY
79195: LIST
79196: LIST
79197: PUSH
79198: LD_INT 5
79200: NEG
79201: PUSH
79202: LD_INT 0
79204: PUSH
79205: EMPTY
79206: LIST
79207: LIST
79208: PUSH
79209: LD_INT 5
79211: NEG
79212: PUSH
79213: LD_INT 1
79215: NEG
79216: PUSH
79217: EMPTY
79218: LIST
79219: LIST
79220: PUSH
79221: LD_INT 5
79223: NEG
79224: PUSH
79225: LD_INT 1
79227: PUSH
79228: EMPTY
79229: LIST
79230: LIST
79231: PUSH
79232: LD_INT 6
79234: NEG
79235: PUSH
79236: LD_INT 0
79238: PUSH
79239: EMPTY
79240: LIST
79241: LIST
79242: PUSH
79243: LD_INT 6
79245: NEG
79246: PUSH
79247: LD_INT 1
79249: NEG
79250: PUSH
79251: EMPTY
79252: LIST
79253: LIST
79254: PUSH
79255: EMPTY
79256: LIST
79257: LIST
79258: LIST
79259: LIST
79260: LIST
79261: LIST
79262: LIST
79263: LIST
79264: LIST
79265: LIST
79266: LIST
79267: LIST
79268: ST_TO_ADDR
// fFactory5 = [ [ - 2 , - 3 ] , [ - 3 , - 2 ] , [ - 3 , - 3 ] , [ - 3 , - 4 ] , [ - 4 , - 3 ] , [ - 4 , - 4 ] , [ - 4 , - 5 ] , [ - 5 , - 4 ] , [ - 5 , - 5 ] , [ - 5 , - 6 ] , [ - 6 , - 5 ] , [ - 6 , - 6 ] ] ;
79269: LD_ADDR_VAR 0 34
79273: PUSH
79274: LD_INT 2
79276: NEG
79277: PUSH
79278: LD_INT 3
79280: NEG
79281: PUSH
79282: EMPTY
79283: LIST
79284: LIST
79285: PUSH
79286: LD_INT 3
79288: NEG
79289: PUSH
79290: LD_INT 2
79292: NEG
79293: PUSH
79294: EMPTY
79295: LIST
79296: LIST
79297: PUSH
79298: LD_INT 3
79300: NEG
79301: PUSH
79302: LD_INT 3
79304: NEG
79305: PUSH
79306: EMPTY
79307: LIST
79308: LIST
79309: PUSH
79310: LD_INT 3
79312: NEG
79313: PUSH
79314: LD_INT 4
79316: NEG
79317: PUSH
79318: EMPTY
79319: LIST
79320: LIST
79321: PUSH
79322: LD_INT 4
79324: NEG
79325: PUSH
79326: LD_INT 3
79328: NEG
79329: PUSH
79330: EMPTY
79331: LIST
79332: LIST
79333: PUSH
79334: LD_INT 4
79336: NEG
79337: PUSH
79338: LD_INT 4
79340: NEG
79341: PUSH
79342: EMPTY
79343: LIST
79344: LIST
79345: PUSH
79346: LD_INT 4
79348: NEG
79349: PUSH
79350: LD_INT 5
79352: NEG
79353: PUSH
79354: EMPTY
79355: LIST
79356: LIST
79357: PUSH
79358: LD_INT 5
79360: NEG
79361: PUSH
79362: LD_INT 4
79364: NEG
79365: PUSH
79366: EMPTY
79367: LIST
79368: LIST
79369: PUSH
79370: LD_INT 5
79372: NEG
79373: PUSH
79374: LD_INT 5
79376: NEG
79377: PUSH
79378: EMPTY
79379: LIST
79380: LIST
79381: PUSH
79382: LD_INT 5
79384: NEG
79385: PUSH
79386: LD_INT 6
79388: NEG
79389: PUSH
79390: EMPTY
79391: LIST
79392: LIST
79393: PUSH
79394: LD_INT 6
79396: NEG
79397: PUSH
79398: LD_INT 5
79400: NEG
79401: PUSH
79402: EMPTY
79403: LIST
79404: LIST
79405: PUSH
79406: LD_INT 6
79408: NEG
79409: PUSH
79410: LD_INT 6
79412: NEG
79413: PUSH
79414: EMPTY
79415: LIST
79416: LIST
79417: PUSH
79418: EMPTY
79419: LIST
79420: LIST
79421: LIST
79422: LIST
79423: LIST
79424: LIST
79425: LIST
79426: LIST
79427: LIST
79428: LIST
79429: LIST
79430: LIST
79431: ST_TO_ADDR
// fLab0 = [ [ 0 , - 2 ] , [ - 1 , - 3 ] , [ 1 , - 2 ] ] ;
79432: LD_ADDR_VAR 0 41
79436: PUSH
79437: LD_INT 0
79439: PUSH
79440: LD_INT 2
79442: NEG
79443: PUSH
79444: EMPTY
79445: LIST
79446: LIST
79447: PUSH
79448: LD_INT 1
79450: NEG
79451: PUSH
79452: LD_INT 3
79454: NEG
79455: PUSH
79456: EMPTY
79457: LIST
79458: LIST
79459: PUSH
79460: LD_INT 1
79462: PUSH
79463: LD_INT 2
79465: NEG
79466: PUSH
79467: EMPTY
79468: LIST
79469: LIST
79470: PUSH
79471: EMPTY
79472: LIST
79473: LIST
79474: LIST
79475: ST_TO_ADDR
// fLab1 = [ [ 2 , 0 ] , [ 2 , - 1 ] , [ 3 , 1 ] ] ;
79476: LD_ADDR_VAR 0 42
79480: PUSH
79481: LD_INT 2
79483: PUSH
79484: LD_INT 0
79486: PUSH
79487: EMPTY
79488: LIST
79489: LIST
79490: PUSH
79491: LD_INT 2
79493: PUSH
79494: LD_INT 1
79496: NEG
79497: PUSH
79498: EMPTY
79499: LIST
79500: LIST
79501: PUSH
79502: LD_INT 3
79504: PUSH
79505: LD_INT 1
79507: PUSH
79508: EMPTY
79509: LIST
79510: LIST
79511: PUSH
79512: EMPTY
79513: LIST
79514: LIST
79515: LIST
79516: ST_TO_ADDR
// fLab2 = [ [ 2 , 2 ] , [ 3 , 2 ] , [ 2 , 3 ] ] ;
79517: LD_ADDR_VAR 0 43
79521: PUSH
79522: LD_INT 2
79524: PUSH
79525: LD_INT 2
79527: PUSH
79528: EMPTY
79529: LIST
79530: LIST
79531: PUSH
79532: LD_INT 3
79534: PUSH
79535: LD_INT 2
79537: PUSH
79538: EMPTY
79539: LIST
79540: LIST
79541: PUSH
79542: LD_INT 2
79544: PUSH
79545: LD_INT 3
79547: PUSH
79548: EMPTY
79549: LIST
79550: LIST
79551: PUSH
79552: EMPTY
79553: LIST
79554: LIST
79555: LIST
79556: ST_TO_ADDR
// fLab3 = [ [ 0 , 2 ] , [ 1 , 3 ] , [ - 1 , 2 ] ] ;
79557: LD_ADDR_VAR 0 44
79561: PUSH
79562: LD_INT 0
79564: PUSH
79565: LD_INT 2
79567: PUSH
79568: EMPTY
79569: LIST
79570: LIST
79571: PUSH
79572: LD_INT 1
79574: PUSH
79575: LD_INT 3
79577: PUSH
79578: EMPTY
79579: LIST
79580: LIST
79581: PUSH
79582: LD_INT 1
79584: NEG
79585: PUSH
79586: LD_INT 2
79588: PUSH
79589: EMPTY
79590: LIST
79591: LIST
79592: PUSH
79593: EMPTY
79594: LIST
79595: LIST
79596: LIST
79597: ST_TO_ADDR
// fLab4 = [ [ - 2 , 0 ] , [ - 2 , 1 ] , [ - 3 , - 1 ] ] ;
79598: LD_ADDR_VAR 0 45
79602: PUSH
79603: LD_INT 2
79605: NEG
79606: PUSH
79607: LD_INT 0
79609: PUSH
79610: EMPTY
79611: LIST
79612: LIST
79613: PUSH
79614: LD_INT 2
79616: NEG
79617: PUSH
79618: LD_INT 1
79620: PUSH
79621: EMPTY
79622: LIST
79623: LIST
79624: PUSH
79625: LD_INT 3
79627: NEG
79628: PUSH
79629: LD_INT 1
79631: NEG
79632: PUSH
79633: EMPTY
79634: LIST
79635: LIST
79636: PUSH
79637: EMPTY
79638: LIST
79639: LIST
79640: LIST
79641: ST_TO_ADDR
// fLab5 = [ [ - 2 , - 2 ] , [ - 2 , - 3 ] , [ - 3 , - 2 ] ] ;
79642: LD_ADDR_VAR 0 46
79646: PUSH
79647: LD_INT 2
79649: NEG
79650: PUSH
79651: LD_INT 2
79653: NEG
79654: PUSH
79655: EMPTY
79656: LIST
79657: LIST
79658: PUSH
79659: LD_INT 2
79661: NEG
79662: PUSH
79663: LD_INT 3
79665: NEG
79666: PUSH
79667: EMPTY
79668: LIST
79669: LIST
79670: PUSH
79671: LD_INT 3
79673: NEG
79674: PUSH
79675: LD_INT 2
79677: NEG
79678: PUSH
79679: EMPTY
79680: LIST
79681: LIST
79682: PUSH
79683: EMPTY
79684: LIST
79685: LIST
79686: LIST
79687: ST_TO_ADDR
// fControlTower0 = [ [ - 2 , - 3 ] , [ - 1 , - 3 ] ] ;
79688: LD_ADDR_VAR 0 47
79692: PUSH
79693: LD_INT 2
79695: NEG
79696: PUSH
79697: LD_INT 3
79699: NEG
79700: PUSH
79701: EMPTY
79702: LIST
79703: LIST
79704: PUSH
79705: LD_INT 1
79707: NEG
79708: PUSH
79709: LD_INT 3
79711: NEG
79712: PUSH
79713: EMPTY
79714: LIST
79715: LIST
79716: PUSH
79717: EMPTY
79718: LIST
79719: LIST
79720: ST_TO_ADDR
// fControlTower1 = [ [ 1 , - 2 ] , [ 2 , - 1 ] ] ;
79721: LD_ADDR_VAR 0 48
79725: PUSH
79726: LD_INT 1
79728: PUSH
79729: LD_INT 2
79731: NEG
79732: PUSH
79733: EMPTY
79734: LIST
79735: LIST
79736: PUSH
79737: LD_INT 2
79739: PUSH
79740: LD_INT 1
79742: NEG
79743: PUSH
79744: EMPTY
79745: LIST
79746: LIST
79747: PUSH
79748: EMPTY
79749: LIST
79750: LIST
79751: ST_TO_ADDR
// fControlTower2 = [ [ 3 , 1 ] , [ 3 , 2 ] ] ;
79752: LD_ADDR_VAR 0 49
79756: PUSH
79757: LD_INT 3
79759: PUSH
79760: LD_INT 1
79762: PUSH
79763: EMPTY
79764: LIST
79765: LIST
79766: PUSH
79767: LD_INT 3
79769: PUSH
79770: LD_INT 2
79772: PUSH
79773: EMPTY
79774: LIST
79775: LIST
79776: PUSH
79777: EMPTY
79778: LIST
79779: LIST
79780: ST_TO_ADDR
// fControlTower3 = [ [ 2 , 3 ] , [ 1 , 3 ] ] ;
79781: LD_ADDR_VAR 0 50
79785: PUSH
79786: LD_INT 2
79788: PUSH
79789: LD_INT 3
79791: PUSH
79792: EMPTY
79793: LIST
79794: LIST
79795: PUSH
79796: LD_INT 1
79798: PUSH
79799: LD_INT 3
79801: PUSH
79802: EMPTY
79803: LIST
79804: LIST
79805: PUSH
79806: EMPTY
79807: LIST
79808: LIST
79809: ST_TO_ADDR
// fControlTower4 = [ [ - 1 , 2 ] , [ - 2 , 1 ] ] ;
79810: LD_ADDR_VAR 0 51
79814: PUSH
79815: LD_INT 1
79817: NEG
79818: PUSH
79819: LD_INT 2
79821: PUSH
79822: EMPTY
79823: LIST
79824: LIST
79825: PUSH
79826: LD_INT 2
79828: NEG
79829: PUSH
79830: LD_INT 1
79832: PUSH
79833: EMPTY
79834: LIST
79835: LIST
79836: PUSH
79837: EMPTY
79838: LIST
79839: LIST
79840: ST_TO_ADDR
// fControlTower5 = [ [ - 3 , - 1 ] , [ - 3 , - 2 ] ] ;
79841: LD_ADDR_VAR 0 52
79845: PUSH
79846: LD_INT 3
79848: NEG
79849: PUSH
79850: LD_INT 1
79852: NEG
79853: PUSH
79854: EMPTY
79855: LIST
79856: LIST
79857: PUSH
79858: LD_INT 3
79860: NEG
79861: PUSH
79862: LD_INT 2
79864: NEG
79865: PUSH
79866: EMPTY
79867: LIST
79868: LIST
79869: PUSH
79870: EMPTY
79871: LIST
79872: LIST
79873: ST_TO_ADDR
// fBarracks0 = [ [ - 1 , - 3 ] , [ 0 , - 3 ] , [ 1 , - 2 ] ] ;
79874: LD_ADDR_VAR 0 53
79878: PUSH
79879: LD_INT 1
79881: NEG
79882: PUSH
79883: LD_INT 3
79885: NEG
79886: PUSH
79887: EMPTY
79888: LIST
79889: LIST
79890: PUSH
79891: LD_INT 0
79893: PUSH
79894: LD_INT 3
79896: NEG
79897: PUSH
79898: EMPTY
79899: LIST
79900: LIST
79901: PUSH
79902: LD_INT 1
79904: PUSH
79905: LD_INT 2
79907: NEG
79908: PUSH
79909: EMPTY
79910: LIST
79911: LIST
79912: PUSH
79913: EMPTY
79914: LIST
79915: LIST
79916: LIST
79917: ST_TO_ADDR
// fBarracks1 = [ [ 2 , - 1 ] , [ 3 , 0 ] , [ 3 , 1 ] ] ;
79918: LD_ADDR_VAR 0 54
79922: PUSH
79923: LD_INT 2
79925: PUSH
79926: LD_INT 1
79928: NEG
79929: PUSH
79930: EMPTY
79931: LIST
79932: LIST
79933: PUSH
79934: LD_INT 3
79936: PUSH
79937: LD_INT 0
79939: PUSH
79940: EMPTY
79941: LIST
79942: LIST
79943: PUSH
79944: LD_INT 3
79946: PUSH
79947: LD_INT 1
79949: PUSH
79950: EMPTY
79951: LIST
79952: LIST
79953: PUSH
79954: EMPTY
79955: LIST
79956: LIST
79957: LIST
79958: ST_TO_ADDR
// fBarracks2 = [ [ 3 , 2 ] , [ 3 , 3 ] , [ 2 , 3 ] ] ;
79959: LD_ADDR_VAR 0 55
79963: PUSH
79964: LD_INT 3
79966: PUSH
79967: LD_INT 2
79969: PUSH
79970: EMPTY
79971: LIST
79972: LIST
79973: PUSH
79974: LD_INT 3
79976: PUSH
79977: LD_INT 3
79979: PUSH
79980: EMPTY
79981: LIST
79982: LIST
79983: PUSH
79984: LD_INT 2
79986: PUSH
79987: LD_INT 3
79989: PUSH
79990: EMPTY
79991: LIST
79992: LIST
79993: PUSH
79994: EMPTY
79995: LIST
79996: LIST
79997: LIST
79998: ST_TO_ADDR
// fBarracks3 = [ [ 1 , 3 ] , [ 0 , 3 ] , [ - 1 , 2 ] ] ;
79999: LD_ADDR_VAR 0 56
80003: PUSH
80004: LD_INT 1
80006: PUSH
80007: LD_INT 3
80009: PUSH
80010: EMPTY
80011: LIST
80012: LIST
80013: PUSH
80014: LD_INT 0
80016: PUSH
80017: LD_INT 3
80019: PUSH
80020: EMPTY
80021: LIST
80022: LIST
80023: PUSH
80024: LD_INT 1
80026: NEG
80027: PUSH
80028: LD_INT 2
80030: PUSH
80031: EMPTY
80032: LIST
80033: LIST
80034: PUSH
80035: EMPTY
80036: LIST
80037: LIST
80038: LIST
80039: ST_TO_ADDR
// fBarracks4 = [ [ - 2 , 1 ] , [ - 3 , 0 ] , [ - 3 , - 1 ] ] ;
80040: LD_ADDR_VAR 0 57
80044: PUSH
80045: LD_INT 2
80047: NEG
80048: PUSH
80049: LD_INT 1
80051: PUSH
80052: EMPTY
80053: LIST
80054: LIST
80055: PUSH
80056: LD_INT 3
80058: NEG
80059: PUSH
80060: LD_INT 0
80062: PUSH
80063: EMPTY
80064: LIST
80065: LIST
80066: PUSH
80067: LD_INT 3
80069: NEG
80070: PUSH
80071: LD_INT 1
80073: NEG
80074: PUSH
80075: EMPTY
80076: LIST
80077: LIST
80078: PUSH
80079: EMPTY
80080: LIST
80081: LIST
80082: LIST
80083: ST_TO_ADDR
// fBarracks5 = [ [ - 2 , - 3 ] , [ - 3 , - 2 ] , [ - 3 , - 3 ] ] ;
80084: LD_ADDR_VAR 0 58
80088: PUSH
80089: LD_INT 2
80091: NEG
80092: PUSH
80093: LD_INT 3
80095: NEG
80096: PUSH
80097: EMPTY
80098: LIST
80099: LIST
80100: PUSH
80101: LD_INT 3
80103: NEG
80104: PUSH
80105: LD_INT 2
80107: NEG
80108: PUSH
80109: EMPTY
80110: LIST
80111: LIST
80112: PUSH
80113: LD_INT 3
80115: NEG
80116: PUSH
80117: LD_INT 3
80119: NEG
80120: PUSH
80121: EMPTY
80122: LIST
80123: LIST
80124: PUSH
80125: EMPTY
80126: LIST
80127: LIST
80128: LIST
80129: ST_TO_ADDR
// fBunker0 = [ [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] ] ;
80130: LD_ADDR_VAR 0 59
80134: PUSH
80135: LD_INT 1
80137: NEG
80138: PUSH
80139: LD_INT 2
80141: NEG
80142: PUSH
80143: EMPTY
80144: LIST
80145: LIST
80146: PUSH
80147: LD_INT 0
80149: PUSH
80150: LD_INT 2
80152: NEG
80153: PUSH
80154: EMPTY
80155: LIST
80156: LIST
80157: PUSH
80158: LD_INT 1
80160: PUSH
80161: LD_INT 1
80163: NEG
80164: PUSH
80165: EMPTY
80166: LIST
80167: LIST
80168: PUSH
80169: EMPTY
80170: LIST
80171: LIST
80172: LIST
80173: ST_TO_ADDR
// fBunker1 = [ [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] ] ;
80174: LD_ADDR_VAR 0 60
80178: PUSH
80179: LD_INT 1
80181: PUSH
80182: LD_INT 1
80184: NEG
80185: PUSH
80186: EMPTY
80187: LIST
80188: LIST
80189: PUSH
80190: LD_INT 2
80192: PUSH
80193: LD_INT 0
80195: PUSH
80196: EMPTY
80197: LIST
80198: LIST
80199: PUSH
80200: LD_INT 2
80202: PUSH
80203: LD_INT 1
80205: PUSH
80206: EMPTY
80207: LIST
80208: LIST
80209: PUSH
80210: EMPTY
80211: LIST
80212: LIST
80213: LIST
80214: ST_TO_ADDR
// fBunker2 = [ [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] ] ;
80215: LD_ADDR_VAR 0 61
80219: PUSH
80220: LD_INT 2
80222: PUSH
80223: LD_INT 1
80225: PUSH
80226: EMPTY
80227: LIST
80228: LIST
80229: PUSH
80230: LD_INT 2
80232: PUSH
80233: LD_INT 2
80235: PUSH
80236: EMPTY
80237: LIST
80238: LIST
80239: PUSH
80240: LD_INT 1
80242: PUSH
80243: LD_INT 2
80245: PUSH
80246: EMPTY
80247: LIST
80248: LIST
80249: PUSH
80250: EMPTY
80251: LIST
80252: LIST
80253: LIST
80254: ST_TO_ADDR
// fBunker3 = [ [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] ] ;
80255: LD_ADDR_VAR 0 62
80259: PUSH
80260: LD_INT 1
80262: PUSH
80263: LD_INT 2
80265: PUSH
80266: EMPTY
80267: LIST
80268: LIST
80269: PUSH
80270: LD_INT 0
80272: PUSH
80273: LD_INT 2
80275: PUSH
80276: EMPTY
80277: LIST
80278: LIST
80279: PUSH
80280: LD_INT 1
80282: NEG
80283: PUSH
80284: LD_INT 1
80286: PUSH
80287: EMPTY
80288: LIST
80289: LIST
80290: PUSH
80291: EMPTY
80292: LIST
80293: LIST
80294: LIST
80295: ST_TO_ADDR
// fBunker4 = [ [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] ] ;
80296: LD_ADDR_VAR 0 63
80300: PUSH
80301: LD_INT 1
80303: NEG
80304: PUSH
80305: LD_INT 1
80307: PUSH
80308: EMPTY
80309: LIST
80310: LIST
80311: PUSH
80312: LD_INT 2
80314: NEG
80315: PUSH
80316: LD_INT 0
80318: PUSH
80319: EMPTY
80320: LIST
80321: LIST
80322: PUSH
80323: LD_INT 2
80325: NEG
80326: PUSH
80327: LD_INT 1
80329: NEG
80330: PUSH
80331: EMPTY
80332: LIST
80333: LIST
80334: PUSH
80335: EMPTY
80336: LIST
80337: LIST
80338: LIST
80339: ST_TO_ADDR
// fBunker5 = [ [ - 1 , - 2 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
80340: LD_ADDR_VAR 0 64
80344: PUSH
80345: LD_INT 1
80347: NEG
80348: PUSH
80349: LD_INT 2
80351: NEG
80352: PUSH
80353: EMPTY
80354: LIST
80355: LIST
80356: PUSH
80357: LD_INT 2
80359: NEG
80360: PUSH
80361: LD_INT 1
80363: NEG
80364: PUSH
80365: EMPTY
80366: LIST
80367: LIST
80368: PUSH
80369: LD_INT 2
80371: NEG
80372: PUSH
80373: LD_INT 2
80375: NEG
80376: PUSH
80377: EMPTY
80378: LIST
80379: LIST
80380: PUSH
80381: EMPTY
80382: LIST
80383: LIST
80384: LIST
80385: ST_TO_ADDR
// end ; 2 :
80386: GO 83652
80388: LD_INT 2
80390: DOUBLE
80391: EQUAL
80392: IFTRUE 80396
80394: GO 83651
80396: POP
// begin fFactory0 = [ [ 4 , 0 ] , [ 4 , - 1 ] , [ 5 , 0 ] , [ 5 , 1 ] , [ 4 , 1 ] , [ 3 , 0 ] , [ 3 , - 1 ] , [ 3 , - 2 ] , [ 5 , 2 ] , [ 3 , 3 ] , [ 3 , 2 ] , [ 4 , 3 ] , [ 4 , 4 ] , [ 3 , 4 ] , [ 2 , 3 ] , [ 2 , 2 ] , [ 4 , 2 ] , [ 2 , 4 ] , [ 0 , 4 ] , [ 0 , 3 ] , [ 1 , 4 ] , [ 1 , 5 ] , [ 0 , 5 ] , [ - 1 , 4 ] , [ - 1 , 3 ] , [ 2 , 5 ] , [ - 2 , 3 ] , [ - 3 , 0 ] , [ - 3 , - 1 ] , [ - 2 , 0 ] , [ - 2 , 1 ] , [ - 3 , 1 ] , [ - 4 , 0 ] , [ - 4 , - 1 ] , [ - 4 , - 2 ] , [ - 2 , 2 ] , [ - 4 , - 4 ] , [ - 4 , - 5 ] , [ - 3 , - 4 ] , [ - 3 , - 3 ] , [ - 4 , - 3 ] , [ - 5 , - 4 ] , [ - 5 , - 5 ] , [ - 3 , - 5 ] , [ - 5 , - 3 ] ] ;
80397: LD_ADDR_VAR 0 29
80401: PUSH
80402: LD_INT 4
80404: PUSH
80405: LD_INT 0
80407: PUSH
80408: EMPTY
80409: LIST
80410: LIST
80411: PUSH
80412: LD_INT 4
80414: PUSH
80415: LD_INT 1
80417: NEG
80418: PUSH
80419: EMPTY
80420: LIST
80421: LIST
80422: PUSH
80423: LD_INT 5
80425: PUSH
80426: LD_INT 0
80428: PUSH
80429: EMPTY
80430: LIST
80431: LIST
80432: PUSH
80433: LD_INT 5
80435: PUSH
80436: LD_INT 1
80438: PUSH
80439: EMPTY
80440: LIST
80441: LIST
80442: PUSH
80443: LD_INT 4
80445: PUSH
80446: LD_INT 1
80448: PUSH
80449: EMPTY
80450: LIST
80451: LIST
80452: PUSH
80453: LD_INT 3
80455: PUSH
80456: LD_INT 0
80458: PUSH
80459: EMPTY
80460: LIST
80461: LIST
80462: PUSH
80463: LD_INT 3
80465: PUSH
80466: LD_INT 1
80468: NEG
80469: PUSH
80470: EMPTY
80471: LIST
80472: LIST
80473: PUSH
80474: LD_INT 3
80476: PUSH
80477: LD_INT 2
80479: NEG
80480: PUSH
80481: EMPTY
80482: LIST
80483: LIST
80484: PUSH
80485: LD_INT 5
80487: PUSH
80488: LD_INT 2
80490: PUSH
80491: EMPTY
80492: LIST
80493: LIST
80494: PUSH
80495: LD_INT 3
80497: PUSH
80498: LD_INT 3
80500: PUSH
80501: EMPTY
80502: LIST
80503: LIST
80504: PUSH
80505: LD_INT 3
80507: PUSH
80508: LD_INT 2
80510: PUSH
80511: EMPTY
80512: LIST
80513: LIST
80514: PUSH
80515: LD_INT 4
80517: PUSH
80518: LD_INT 3
80520: PUSH
80521: EMPTY
80522: LIST
80523: LIST
80524: PUSH
80525: LD_INT 4
80527: PUSH
80528: LD_INT 4
80530: PUSH
80531: EMPTY
80532: LIST
80533: LIST
80534: PUSH
80535: LD_INT 3
80537: PUSH
80538: LD_INT 4
80540: PUSH
80541: EMPTY
80542: LIST
80543: LIST
80544: PUSH
80545: LD_INT 2
80547: PUSH
80548: LD_INT 3
80550: PUSH
80551: EMPTY
80552: LIST
80553: LIST
80554: PUSH
80555: LD_INT 2
80557: PUSH
80558: LD_INT 2
80560: PUSH
80561: EMPTY
80562: LIST
80563: LIST
80564: PUSH
80565: LD_INT 4
80567: PUSH
80568: LD_INT 2
80570: PUSH
80571: EMPTY
80572: LIST
80573: LIST
80574: PUSH
80575: LD_INT 2
80577: PUSH
80578: LD_INT 4
80580: PUSH
80581: EMPTY
80582: LIST
80583: LIST
80584: PUSH
80585: LD_INT 0
80587: PUSH
80588: LD_INT 4
80590: PUSH
80591: EMPTY
80592: LIST
80593: LIST
80594: PUSH
80595: LD_INT 0
80597: PUSH
80598: LD_INT 3
80600: PUSH
80601: EMPTY
80602: LIST
80603: LIST
80604: PUSH
80605: LD_INT 1
80607: PUSH
80608: LD_INT 4
80610: PUSH
80611: EMPTY
80612: LIST
80613: LIST
80614: PUSH
80615: LD_INT 1
80617: PUSH
80618: LD_INT 5
80620: PUSH
80621: EMPTY
80622: LIST
80623: LIST
80624: PUSH
80625: LD_INT 0
80627: PUSH
80628: LD_INT 5
80630: PUSH
80631: EMPTY
80632: LIST
80633: LIST
80634: PUSH
80635: LD_INT 1
80637: NEG
80638: PUSH
80639: LD_INT 4
80641: PUSH
80642: EMPTY
80643: LIST
80644: LIST
80645: PUSH
80646: LD_INT 1
80648: NEG
80649: PUSH
80650: LD_INT 3
80652: PUSH
80653: EMPTY
80654: LIST
80655: LIST
80656: PUSH
80657: LD_INT 2
80659: PUSH
80660: LD_INT 5
80662: PUSH
80663: EMPTY
80664: LIST
80665: LIST
80666: PUSH
80667: LD_INT 2
80669: NEG
80670: PUSH
80671: LD_INT 3
80673: PUSH
80674: EMPTY
80675: LIST
80676: LIST
80677: PUSH
80678: LD_INT 3
80680: NEG
80681: PUSH
80682: LD_INT 0
80684: PUSH
80685: EMPTY
80686: LIST
80687: LIST
80688: PUSH
80689: LD_INT 3
80691: NEG
80692: PUSH
80693: LD_INT 1
80695: NEG
80696: PUSH
80697: EMPTY
80698: LIST
80699: LIST
80700: PUSH
80701: LD_INT 2
80703: NEG
80704: PUSH
80705: LD_INT 0
80707: PUSH
80708: EMPTY
80709: LIST
80710: LIST
80711: PUSH
80712: LD_INT 2
80714: NEG
80715: PUSH
80716: LD_INT 1
80718: PUSH
80719: EMPTY
80720: LIST
80721: LIST
80722: PUSH
80723: LD_INT 3
80725: NEG
80726: PUSH
80727: LD_INT 1
80729: PUSH
80730: EMPTY
80731: LIST
80732: LIST
80733: PUSH
80734: LD_INT 4
80736: NEG
80737: PUSH
80738: LD_INT 0
80740: PUSH
80741: EMPTY
80742: LIST
80743: LIST
80744: PUSH
80745: LD_INT 4
80747: NEG
80748: PUSH
80749: LD_INT 1
80751: NEG
80752: PUSH
80753: EMPTY
80754: LIST
80755: LIST
80756: PUSH
80757: LD_INT 4
80759: NEG
80760: PUSH
80761: LD_INT 2
80763: NEG
80764: PUSH
80765: EMPTY
80766: LIST
80767: LIST
80768: PUSH
80769: LD_INT 2
80771: NEG
80772: PUSH
80773: LD_INT 2
80775: PUSH
80776: EMPTY
80777: LIST
80778: LIST
80779: PUSH
80780: LD_INT 4
80782: NEG
80783: PUSH
80784: LD_INT 4
80786: NEG
80787: PUSH
80788: EMPTY
80789: LIST
80790: LIST
80791: PUSH
80792: LD_INT 4
80794: NEG
80795: PUSH
80796: LD_INT 5
80798: NEG
80799: PUSH
80800: EMPTY
80801: LIST
80802: LIST
80803: PUSH
80804: LD_INT 3
80806: NEG
80807: PUSH
80808: LD_INT 4
80810: NEG
80811: PUSH
80812: EMPTY
80813: LIST
80814: LIST
80815: PUSH
80816: LD_INT 3
80818: NEG
80819: PUSH
80820: LD_INT 3
80822: NEG
80823: PUSH
80824: EMPTY
80825: LIST
80826: LIST
80827: PUSH
80828: LD_INT 4
80830: NEG
80831: PUSH
80832: LD_INT 3
80834: NEG
80835: PUSH
80836: EMPTY
80837: LIST
80838: LIST
80839: PUSH
80840: LD_INT 5
80842: NEG
80843: PUSH
80844: LD_INT 4
80846: NEG
80847: PUSH
80848: EMPTY
80849: LIST
80850: LIST
80851: PUSH
80852: LD_INT 5
80854: NEG
80855: PUSH
80856: LD_INT 5
80858: NEG
80859: PUSH
80860: EMPTY
80861: LIST
80862: LIST
80863: PUSH
80864: LD_INT 3
80866: NEG
80867: PUSH
80868: LD_INT 5
80870: NEG
80871: PUSH
80872: EMPTY
80873: LIST
80874: LIST
80875: PUSH
80876: LD_INT 5
80878: NEG
80879: PUSH
80880: LD_INT 3
80882: NEG
80883: PUSH
80884: EMPTY
80885: LIST
80886: LIST
80887: PUSH
80888: EMPTY
80889: LIST
80890: LIST
80891: LIST
80892: LIST
80893: LIST
80894: LIST
80895: LIST
80896: LIST
80897: LIST
80898: LIST
80899: LIST
80900: LIST
80901: LIST
80902: LIST
80903: LIST
80904: LIST
80905: LIST
80906: LIST
80907: LIST
80908: LIST
80909: LIST
80910: LIST
80911: LIST
80912: LIST
80913: LIST
80914: LIST
80915: LIST
80916: LIST
80917: LIST
80918: LIST
80919: LIST
80920: LIST
80921: LIST
80922: LIST
80923: LIST
80924: LIST
80925: LIST
80926: LIST
80927: LIST
80928: LIST
80929: LIST
80930: LIST
80931: LIST
80932: LIST
80933: LIST
80934: ST_TO_ADDR
// fFactory1 = [ [ 4 , 4 ] , [ 4 , 3 ] , [ 5 , 4 ] , [ 5 , 5 ] , [ 4 , 5 ] , [ 3 , 4 ] , [ 3 , 3 ] , [ 5 , 3 ] , [ 3 , 5 ] , [ 0 , 3 ] , [ 0 , 2 ] , [ 1 , 3 ] , [ 1 , 4 ] , [ 0 , 4 ] , [ - 1 , 3 ] , [ - 1 , 2 ] , [ 2 , 4 ] , [ - 2 , 2 ] , [ - 4 , 0 ] , [ - 4 , - 1 ] , [ - 3 , 0 ] , [ - 3 , 1 ] , [ - 4 , 1 ] , [ - 5 , 0 ] , [ - 5 , - 1 ] , [ - 5 , - 2 ] , [ - 3 , 2 ] , [ - 3 , - 3 ] , [ - 3 , - 4 ] , [ - 2 , - 3 ] , [ - 2 , - 2 ] , [ - 3 , - 2 ] , [ - 4 , - 3 ] , [ - 4 , - 4 ] , [ - 2 , - 4 ] , [ - 4 , - 2 ] , [ 0 , - 4 ] , [ 0 , - 5 ] , [ 1 , - 4 ] , [ 1 , - 3 ] , [ 0 , - 3 ] , [ - 1 , - 4 ] , [ - 1 , - 5 ] , [ 2 , - 3 ] , [ - 2 , - 5 ] ] ;
80935: LD_ADDR_VAR 0 30
80939: PUSH
80940: LD_INT 4
80942: PUSH
80943: LD_INT 4
80945: PUSH
80946: EMPTY
80947: LIST
80948: LIST
80949: PUSH
80950: LD_INT 4
80952: PUSH
80953: LD_INT 3
80955: PUSH
80956: EMPTY
80957: LIST
80958: LIST
80959: PUSH
80960: LD_INT 5
80962: PUSH
80963: LD_INT 4
80965: PUSH
80966: EMPTY
80967: LIST
80968: LIST
80969: PUSH
80970: LD_INT 5
80972: PUSH
80973: LD_INT 5
80975: PUSH
80976: EMPTY
80977: LIST
80978: LIST
80979: PUSH
80980: LD_INT 4
80982: PUSH
80983: LD_INT 5
80985: PUSH
80986: EMPTY
80987: LIST
80988: LIST
80989: PUSH
80990: LD_INT 3
80992: PUSH
80993: LD_INT 4
80995: PUSH
80996: EMPTY
80997: LIST
80998: LIST
80999: PUSH
81000: LD_INT 3
81002: PUSH
81003: LD_INT 3
81005: PUSH
81006: EMPTY
81007: LIST
81008: LIST
81009: PUSH
81010: LD_INT 5
81012: PUSH
81013: LD_INT 3
81015: PUSH
81016: EMPTY
81017: LIST
81018: LIST
81019: PUSH
81020: LD_INT 3
81022: PUSH
81023: LD_INT 5
81025: PUSH
81026: EMPTY
81027: LIST
81028: LIST
81029: PUSH
81030: LD_INT 0
81032: PUSH
81033: LD_INT 3
81035: PUSH
81036: EMPTY
81037: LIST
81038: LIST
81039: PUSH
81040: LD_INT 0
81042: PUSH
81043: LD_INT 2
81045: PUSH
81046: EMPTY
81047: LIST
81048: LIST
81049: PUSH
81050: LD_INT 1
81052: PUSH
81053: LD_INT 3
81055: PUSH
81056: EMPTY
81057: LIST
81058: LIST
81059: PUSH
81060: LD_INT 1
81062: PUSH
81063: LD_INT 4
81065: PUSH
81066: EMPTY
81067: LIST
81068: LIST
81069: PUSH
81070: LD_INT 0
81072: PUSH
81073: LD_INT 4
81075: PUSH
81076: EMPTY
81077: LIST
81078: LIST
81079: PUSH
81080: LD_INT 1
81082: NEG
81083: PUSH
81084: LD_INT 3
81086: PUSH
81087: EMPTY
81088: LIST
81089: LIST
81090: PUSH
81091: LD_INT 1
81093: NEG
81094: PUSH
81095: LD_INT 2
81097: PUSH
81098: EMPTY
81099: LIST
81100: LIST
81101: PUSH
81102: LD_INT 2
81104: PUSH
81105: LD_INT 4
81107: PUSH
81108: EMPTY
81109: LIST
81110: LIST
81111: PUSH
81112: LD_INT 2
81114: NEG
81115: PUSH
81116: LD_INT 2
81118: PUSH
81119: EMPTY
81120: LIST
81121: LIST
81122: PUSH
81123: LD_INT 4
81125: NEG
81126: PUSH
81127: LD_INT 0
81129: PUSH
81130: EMPTY
81131: LIST
81132: LIST
81133: PUSH
81134: LD_INT 4
81136: NEG
81137: PUSH
81138: LD_INT 1
81140: NEG
81141: PUSH
81142: EMPTY
81143: LIST
81144: LIST
81145: PUSH
81146: LD_INT 3
81148: NEG
81149: PUSH
81150: LD_INT 0
81152: PUSH
81153: EMPTY
81154: LIST
81155: LIST
81156: PUSH
81157: LD_INT 3
81159: NEG
81160: PUSH
81161: LD_INT 1
81163: PUSH
81164: EMPTY
81165: LIST
81166: LIST
81167: PUSH
81168: LD_INT 4
81170: NEG
81171: PUSH
81172: LD_INT 1
81174: PUSH
81175: EMPTY
81176: LIST
81177: LIST
81178: PUSH
81179: LD_INT 5
81181: NEG
81182: PUSH
81183: LD_INT 0
81185: PUSH
81186: EMPTY
81187: LIST
81188: LIST
81189: PUSH
81190: LD_INT 5
81192: NEG
81193: PUSH
81194: LD_INT 1
81196: NEG
81197: PUSH
81198: EMPTY
81199: LIST
81200: LIST
81201: PUSH
81202: LD_INT 5
81204: NEG
81205: PUSH
81206: LD_INT 2
81208: NEG
81209: PUSH
81210: EMPTY
81211: LIST
81212: LIST
81213: PUSH
81214: LD_INT 3
81216: NEG
81217: PUSH
81218: LD_INT 2
81220: PUSH
81221: EMPTY
81222: LIST
81223: LIST
81224: PUSH
81225: LD_INT 3
81227: NEG
81228: PUSH
81229: LD_INT 3
81231: NEG
81232: PUSH
81233: EMPTY
81234: LIST
81235: LIST
81236: PUSH
81237: LD_INT 3
81239: NEG
81240: PUSH
81241: LD_INT 4
81243: NEG
81244: PUSH
81245: EMPTY
81246: LIST
81247: LIST
81248: PUSH
81249: LD_INT 2
81251: NEG
81252: PUSH
81253: LD_INT 3
81255: NEG
81256: PUSH
81257: EMPTY
81258: LIST
81259: LIST
81260: PUSH
81261: LD_INT 2
81263: NEG
81264: PUSH
81265: LD_INT 2
81267: NEG
81268: PUSH
81269: EMPTY
81270: LIST
81271: LIST
81272: PUSH
81273: LD_INT 3
81275: NEG
81276: PUSH
81277: LD_INT 2
81279: NEG
81280: PUSH
81281: EMPTY
81282: LIST
81283: LIST
81284: PUSH
81285: LD_INT 4
81287: NEG
81288: PUSH
81289: LD_INT 3
81291: NEG
81292: PUSH
81293: EMPTY
81294: LIST
81295: LIST
81296: PUSH
81297: LD_INT 4
81299: NEG
81300: PUSH
81301: LD_INT 4
81303: NEG
81304: PUSH
81305: EMPTY
81306: LIST
81307: LIST
81308: PUSH
81309: LD_INT 2
81311: NEG
81312: PUSH
81313: LD_INT 4
81315: NEG
81316: PUSH
81317: EMPTY
81318: LIST
81319: LIST
81320: PUSH
81321: LD_INT 4
81323: NEG
81324: PUSH
81325: LD_INT 2
81327: NEG
81328: PUSH
81329: EMPTY
81330: LIST
81331: LIST
81332: PUSH
81333: LD_INT 0
81335: PUSH
81336: LD_INT 4
81338: NEG
81339: PUSH
81340: EMPTY
81341: LIST
81342: LIST
81343: PUSH
81344: LD_INT 0
81346: PUSH
81347: LD_INT 5
81349: NEG
81350: PUSH
81351: EMPTY
81352: LIST
81353: LIST
81354: PUSH
81355: LD_INT 1
81357: PUSH
81358: LD_INT 4
81360: NEG
81361: PUSH
81362: EMPTY
81363: LIST
81364: LIST
81365: PUSH
81366: LD_INT 1
81368: PUSH
81369: LD_INT 3
81371: NEG
81372: PUSH
81373: EMPTY
81374: LIST
81375: LIST
81376: PUSH
81377: LD_INT 0
81379: PUSH
81380: LD_INT 3
81382: NEG
81383: PUSH
81384: EMPTY
81385: LIST
81386: LIST
81387: PUSH
81388: LD_INT 1
81390: NEG
81391: PUSH
81392: LD_INT 4
81394: NEG
81395: PUSH
81396: EMPTY
81397: LIST
81398: LIST
81399: PUSH
81400: LD_INT 1
81402: NEG
81403: PUSH
81404: LD_INT 5
81406: NEG
81407: PUSH
81408: EMPTY
81409: LIST
81410: LIST
81411: PUSH
81412: LD_INT 2
81414: PUSH
81415: LD_INT 3
81417: NEG
81418: PUSH
81419: EMPTY
81420: LIST
81421: LIST
81422: PUSH
81423: LD_INT 2
81425: NEG
81426: PUSH
81427: LD_INT 5
81429: NEG
81430: PUSH
81431: EMPTY
81432: LIST
81433: LIST
81434: PUSH
81435: EMPTY
81436: LIST
81437: LIST
81438: LIST
81439: LIST
81440: LIST
81441: LIST
81442: LIST
81443: LIST
81444: LIST
81445: LIST
81446: LIST
81447: LIST
81448: LIST
81449: LIST
81450: LIST
81451: LIST
81452: LIST
81453: LIST
81454: LIST
81455: LIST
81456: LIST
81457: LIST
81458: LIST
81459: LIST
81460: LIST
81461: LIST
81462: LIST
81463: LIST
81464: LIST
81465: LIST
81466: LIST
81467: LIST
81468: LIST
81469: LIST
81470: LIST
81471: LIST
81472: LIST
81473: LIST
81474: LIST
81475: LIST
81476: LIST
81477: LIST
81478: LIST
81479: LIST
81480: LIST
81481: ST_TO_ADDR
// fFactory2 = [ [ 0 , 4 ] , [ 0 , 3 ] , [ 1 , 4 ] , [ 1 , 5 ] , [ 0 , 5 ] , [ - 1 , 4 ] , [ - 1 , 3 ] , [ 2 , 5 ] , [ - 2 , 3 ] , [ - 3 , 0 ] , [ - 3 , - 1 ] , [ - 2 , 0 ] , [ - 2 , 1 ] , [ - 3 , 1 ] , [ - 4 , 0 ] , [ - 4 , - 1 ] , [ - 4 , - 2 ] , [ - 2 , 2 ] , [ - 4 , - 4 ] , [ - 4 , - 5 ] , [ - 3 , - 4 ] , [ - 3 , - 3 ] , [ - 4 , - 3 ] , [ - 5 , - 4 ] , [ - 5 , - 5 ] , [ - 3 , - 5 ] , [ - 5 , - 3 ] , [ 0 , - 3 ] , [ 0 , - 4 ] , [ 1 , - 3 ] , [ 1 , - 2 ] , [ 0 , - 2 ] , [ - 1 , - 3 ] , [ - 1 , - 4 ] , [ 2 , - 2 ] , [ - 2 , - 4 ] , [ 4 , 0 ] , [ 4 , - 1 ] , [ 5 , 0 ] , [ 5 , 1 ] , [ 4 , 1 ] , [ 3 , 0 ] , [ 3 , - 1 ] , [ 3 , - 2 ] , [ 5 , 2 ] ] ;
81482: LD_ADDR_VAR 0 31
81486: PUSH
81487: LD_INT 0
81489: PUSH
81490: LD_INT 4
81492: PUSH
81493: EMPTY
81494: LIST
81495: LIST
81496: PUSH
81497: LD_INT 0
81499: PUSH
81500: LD_INT 3
81502: PUSH
81503: EMPTY
81504: LIST
81505: LIST
81506: PUSH
81507: LD_INT 1
81509: PUSH
81510: LD_INT 4
81512: PUSH
81513: EMPTY
81514: LIST
81515: LIST
81516: PUSH
81517: LD_INT 1
81519: PUSH
81520: LD_INT 5
81522: PUSH
81523: EMPTY
81524: LIST
81525: LIST
81526: PUSH
81527: LD_INT 0
81529: PUSH
81530: LD_INT 5
81532: PUSH
81533: EMPTY
81534: LIST
81535: LIST
81536: PUSH
81537: LD_INT 1
81539: NEG
81540: PUSH
81541: LD_INT 4
81543: PUSH
81544: EMPTY
81545: LIST
81546: LIST
81547: PUSH
81548: LD_INT 1
81550: NEG
81551: PUSH
81552: LD_INT 3
81554: PUSH
81555: EMPTY
81556: LIST
81557: LIST
81558: PUSH
81559: LD_INT 2
81561: PUSH
81562: LD_INT 5
81564: PUSH
81565: EMPTY
81566: LIST
81567: LIST
81568: PUSH
81569: LD_INT 2
81571: NEG
81572: PUSH
81573: LD_INT 3
81575: PUSH
81576: EMPTY
81577: LIST
81578: LIST
81579: PUSH
81580: LD_INT 3
81582: NEG
81583: PUSH
81584: LD_INT 0
81586: PUSH
81587: EMPTY
81588: LIST
81589: LIST
81590: PUSH
81591: LD_INT 3
81593: NEG
81594: PUSH
81595: LD_INT 1
81597: NEG
81598: PUSH
81599: EMPTY
81600: LIST
81601: LIST
81602: PUSH
81603: LD_INT 2
81605: NEG
81606: PUSH
81607: LD_INT 0
81609: PUSH
81610: EMPTY
81611: LIST
81612: LIST
81613: PUSH
81614: LD_INT 2
81616: NEG
81617: PUSH
81618: LD_INT 1
81620: PUSH
81621: EMPTY
81622: LIST
81623: LIST
81624: PUSH
81625: LD_INT 3
81627: NEG
81628: PUSH
81629: LD_INT 1
81631: PUSH
81632: EMPTY
81633: LIST
81634: LIST
81635: PUSH
81636: LD_INT 4
81638: NEG
81639: PUSH
81640: LD_INT 0
81642: PUSH
81643: EMPTY
81644: LIST
81645: LIST
81646: PUSH
81647: LD_INT 4
81649: NEG
81650: PUSH
81651: LD_INT 1
81653: NEG
81654: PUSH
81655: EMPTY
81656: LIST
81657: LIST
81658: PUSH
81659: LD_INT 4
81661: NEG
81662: PUSH
81663: LD_INT 2
81665: NEG
81666: PUSH
81667: EMPTY
81668: LIST
81669: LIST
81670: PUSH
81671: LD_INT 2
81673: NEG
81674: PUSH
81675: LD_INT 2
81677: PUSH
81678: EMPTY
81679: LIST
81680: LIST
81681: PUSH
81682: LD_INT 4
81684: NEG
81685: PUSH
81686: LD_INT 4
81688: NEG
81689: PUSH
81690: EMPTY
81691: LIST
81692: LIST
81693: PUSH
81694: LD_INT 4
81696: NEG
81697: PUSH
81698: LD_INT 5
81700: NEG
81701: PUSH
81702: EMPTY
81703: LIST
81704: LIST
81705: PUSH
81706: LD_INT 3
81708: NEG
81709: PUSH
81710: LD_INT 4
81712: NEG
81713: PUSH
81714: EMPTY
81715: LIST
81716: LIST
81717: PUSH
81718: LD_INT 3
81720: NEG
81721: PUSH
81722: LD_INT 3
81724: NEG
81725: PUSH
81726: EMPTY
81727: LIST
81728: LIST
81729: PUSH
81730: LD_INT 4
81732: NEG
81733: PUSH
81734: LD_INT 3
81736: NEG
81737: PUSH
81738: EMPTY
81739: LIST
81740: LIST
81741: PUSH
81742: LD_INT 5
81744: NEG
81745: PUSH
81746: LD_INT 4
81748: NEG
81749: PUSH
81750: EMPTY
81751: LIST
81752: LIST
81753: PUSH
81754: LD_INT 5
81756: NEG
81757: PUSH
81758: LD_INT 5
81760: NEG
81761: PUSH
81762: EMPTY
81763: LIST
81764: LIST
81765: PUSH
81766: LD_INT 3
81768: NEG
81769: PUSH
81770: LD_INT 5
81772: NEG
81773: PUSH
81774: EMPTY
81775: LIST
81776: LIST
81777: PUSH
81778: LD_INT 5
81780: NEG
81781: PUSH
81782: LD_INT 3
81784: NEG
81785: PUSH
81786: EMPTY
81787: LIST
81788: LIST
81789: PUSH
81790: LD_INT 0
81792: PUSH
81793: LD_INT 3
81795: NEG
81796: PUSH
81797: EMPTY
81798: LIST
81799: LIST
81800: PUSH
81801: LD_INT 0
81803: PUSH
81804: LD_INT 4
81806: NEG
81807: PUSH
81808: EMPTY
81809: LIST
81810: LIST
81811: PUSH
81812: LD_INT 1
81814: PUSH
81815: LD_INT 3
81817: NEG
81818: PUSH
81819: EMPTY
81820: LIST
81821: LIST
81822: PUSH
81823: LD_INT 1
81825: PUSH
81826: LD_INT 2
81828: NEG
81829: PUSH
81830: EMPTY
81831: LIST
81832: LIST
81833: PUSH
81834: LD_INT 0
81836: PUSH
81837: LD_INT 2
81839: NEG
81840: PUSH
81841: EMPTY
81842: LIST
81843: LIST
81844: PUSH
81845: LD_INT 1
81847: NEG
81848: PUSH
81849: LD_INT 3
81851: NEG
81852: PUSH
81853: EMPTY
81854: LIST
81855: LIST
81856: PUSH
81857: LD_INT 1
81859: NEG
81860: PUSH
81861: LD_INT 4
81863: NEG
81864: PUSH
81865: EMPTY
81866: LIST
81867: LIST
81868: PUSH
81869: LD_INT 2
81871: PUSH
81872: LD_INT 2
81874: NEG
81875: PUSH
81876: EMPTY
81877: LIST
81878: LIST
81879: PUSH
81880: LD_INT 2
81882: NEG
81883: PUSH
81884: LD_INT 4
81886: NEG
81887: PUSH
81888: EMPTY
81889: LIST
81890: LIST
81891: PUSH
81892: LD_INT 4
81894: PUSH
81895: LD_INT 0
81897: PUSH
81898: EMPTY
81899: LIST
81900: LIST
81901: PUSH
81902: LD_INT 4
81904: PUSH
81905: LD_INT 1
81907: NEG
81908: PUSH
81909: EMPTY
81910: LIST
81911: LIST
81912: PUSH
81913: LD_INT 5
81915: PUSH
81916: LD_INT 0
81918: PUSH
81919: EMPTY
81920: LIST
81921: LIST
81922: PUSH
81923: LD_INT 5
81925: PUSH
81926: LD_INT 1
81928: PUSH
81929: EMPTY
81930: LIST
81931: LIST
81932: PUSH
81933: LD_INT 4
81935: PUSH
81936: LD_INT 1
81938: PUSH
81939: EMPTY
81940: LIST
81941: LIST
81942: PUSH
81943: LD_INT 3
81945: PUSH
81946: LD_INT 0
81948: PUSH
81949: EMPTY
81950: LIST
81951: LIST
81952: PUSH
81953: LD_INT 3
81955: PUSH
81956: LD_INT 1
81958: NEG
81959: PUSH
81960: EMPTY
81961: LIST
81962: LIST
81963: PUSH
81964: LD_INT 3
81966: PUSH
81967: LD_INT 2
81969: NEG
81970: PUSH
81971: EMPTY
81972: LIST
81973: LIST
81974: PUSH
81975: LD_INT 5
81977: PUSH
81978: LD_INT 2
81980: PUSH
81981: EMPTY
81982: LIST
81983: LIST
81984: PUSH
81985: EMPTY
81986: LIST
81987: LIST
81988: LIST
81989: LIST
81990: LIST
81991: LIST
81992: LIST
81993: LIST
81994: LIST
81995: LIST
81996: LIST
81997: LIST
81998: LIST
81999: LIST
82000: LIST
82001: LIST
82002: LIST
82003: LIST
82004: LIST
82005: LIST
82006: LIST
82007: LIST
82008: LIST
82009: LIST
82010: LIST
82011: LIST
82012: LIST
82013: LIST
82014: LIST
82015: LIST
82016: LIST
82017: LIST
82018: LIST
82019: LIST
82020: LIST
82021: LIST
82022: LIST
82023: LIST
82024: LIST
82025: LIST
82026: LIST
82027: LIST
82028: LIST
82029: LIST
82030: LIST
82031: ST_TO_ADDR
// fFactory3 = [ [ - 4 , 0 ] , [ - 4 , - 1 ] , [ - 3 , 0 ] , [ - 3 , 1 ] , [ - 4 , 1 ] , [ - 5 , 0 ] , [ - 5 , - 1 ] , [ - 5 , - 2 ] , [ - 3 , 2 ] , [ - 3 , - 3 ] , [ - 3 , - 4 ] , [ - 2 , - 3 ] , [ - 2 , - 2 ] , [ - 3 , - 2 ] , [ - 4 , - 3 ] , [ - 4 , - 4 ] , [ - 2 , - 4 ] , [ - 4 , - 2 ] , [ 0 , - 4 ] , [ 0 , - 5 ] , [ 1 , - 4 ] , [ 1 , - 3 ] , [ 0 , - 3 ] , [ - 1 , - 4 ] , [ - 1 , - 5 ] , [ 2 , - 3 ] , [ - 2 , - 5 ] , [ 3 , 0 ] , [ 3 , - 1 ] , [ 4 , 0 ] , [ 4 , 1 ] , [ 3 , 1 ] , [ 2 , 0 ] , [ 2 , - 1 ] , [ 2 , - 2 ] , [ 4 , 2 ] , [ 4 , 4 ] , [ 4 , 3 ] , [ 5 , 4 ] , [ 5 , 5 ] , [ 4 , 5 ] , [ 3 , 4 ] , [ 3 , 3 ] , [ 5 , 3 ] , [ 3 , 5 ] ] ;
82032: LD_ADDR_VAR 0 32
82036: PUSH
82037: LD_INT 4
82039: NEG
82040: PUSH
82041: LD_INT 0
82043: PUSH
82044: EMPTY
82045: LIST
82046: LIST
82047: PUSH
82048: LD_INT 4
82050: NEG
82051: PUSH
82052: LD_INT 1
82054: NEG
82055: PUSH
82056: EMPTY
82057: LIST
82058: LIST
82059: PUSH
82060: LD_INT 3
82062: NEG
82063: PUSH
82064: LD_INT 0
82066: PUSH
82067: EMPTY
82068: LIST
82069: LIST
82070: PUSH
82071: LD_INT 3
82073: NEG
82074: PUSH
82075: LD_INT 1
82077: PUSH
82078: EMPTY
82079: LIST
82080: LIST
82081: PUSH
82082: LD_INT 4
82084: NEG
82085: PUSH
82086: LD_INT 1
82088: PUSH
82089: EMPTY
82090: LIST
82091: LIST
82092: PUSH
82093: LD_INT 5
82095: NEG
82096: PUSH
82097: LD_INT 0
82099: PUSH
82100: EMPTY
82101: LIST
82102: LIST
82103: PUSH
82104: LD_INT 5
82106: NEG
82107: PUSH
82108: LD_INT 1
82110: NEG
82111: PUSH
82112: EMPTY
82113: LIST
82114: LIST
82115: PUSH
82116: LD_INT 5
82118: NEG
82119: PUSH
82120: LD_INT 2
82122: NEG
82123: PUSH
82124: EMPTY
82125: LIST
82126: LIST
82127: PUSH
82128: LD_INT 3
82130: NEG
82131: PUSH
82132: LD_INT 2
82134: PUSH
82135: EMPTY
82136: LIST
82137: LIST
82138: PUSH
82139: LD_INT 3
82141: NEG
82142: PUSH
82143: LD_INT 3
82145: NEG
82146: PUSH
82147: EMPTY
82148: LIST
82149: LIST
82150: PUSH
82151: LD_INT 3
82153: NEG
82154: PUSH
82155: LD_INT 4
82157: NEG
82158: PUSH
82159: EMPTY
82160: LIST
82161: LIST
82162: PUSH
82163: LD_INT 2
82165: NEG
82166: PUSH
82167: LD_INT 3
82169: NEG
82170: PUSH
82171: EMPTY
82172: LIST
82173: LIST
82174: PUSH
82175: LD_INT 2
82177: NEG
82178: PUSH
82179: LD_INT 2
82181: NEG
82182: PUSH
82183: EMPTY
82184: LIST
82185: LIST
82186: PUSH
82187: LD_INT 3
82189: NEG
82190: PUSH
82191: LD_INT 2
82193: NEG
82194: PUSH
82195: EMPTY
82196: LIST
82197: LIST
82198: PUSH
82199: LD_INT 4
82201: NEG
82202: PUSH
82203: LD_INT 3
82205: NEG
82206: PUSH
82207: EMPTY
82208: LIST
82209: LIST
82210: PUSH
82211: LD_INT 4
82213: NEG
82214: PUSH
82215: LD_INT 4
82217: NEG
82218: PUSH
82219: EMPTY
82220: LIST
82221: LIST
82222: PUSH
82223: LD_INT 2
82225: NEG
82226: PUSH
82227: LD_INT 4
82229: NEG
82230: PUSH
82231: EMPTY
82232: LIST
82233: LIST
82234: PUSH
82235: LD_INT 4
82237: NEG
82238: PUSH
82239: LD_INT 2
82241: NEG
82242: PUSH
82243: EMPTY
82244: LIST
82245: LIST
82246: PUSH
82247: LD_INT 0
82249: PUSH
82250: LD_INT 4
82252: NEG
82253: PUSH
82254: EMPTY
82255: LIST
82256: LIST
82257: PUSH
82258: LD_INT 0
82260: PUSH
82261: LD_INT 5
82263: NEG
82264: PUSH
82265: EMPTY
82266: LIST
82267: LIST
82268: PUSH
82269: LD_INT 1
82271: PUSH
82272: LD_INT 4
82274: NEG
82275: PUSH
82276: EMPTY
82277: LIST
82278: LIST
82279: PUSH
82280: LD_INT 1
82282: PUSH
82283: LD_INT 3
82285: NEG
82286: PUSH
82287: EMPTY
82288: LIST
82289: LIST
82290: PUSH
82291: LD_INT 0
82293: PUSH
82294: LD_INT 3
82296: NEG
82297: PUSH
82298: EMPTY
82299: LIST
82300: LIST
82301: PUSH
82302: LD_INT 1
82304: NEG
82305: PUSH
82306: LD_INT 4
82308: NEG
82309: PUSH
82310: EMPTY
82311: LIST
82312: LIST
82313: PUSH
82314: LD_INT 1
82316: NEG
82317: PUSH
82318: LD_INT 5
82320: NEG
82321: PUSH
82322: EMPTY
82323: LIST
82324: LIST
82325: PUSH
82326: LD_INT 2
82328: PUSH
82329: LD_INT 3
82331: NEG
82332: PUSH
82333: EMPTY
82334: LIST
82335: LIST
82336: PUSH
82337: LD_INT 2
82339: NEG
82340: PUSH
82341: LD_INT 5
82343: NEG
82344: PUSH
82345: EMPTY
82346: LIST
82347: LIST
82348: PUSH
82349: LD_INT 3
82351: PUSH
82352: LD_INT 0
82354: PUSH
82355: EMPTY
82356: LIST
82357: LIST
82358: PUSH
82359: LD_INT 3
82361: PUSH
82362: LD_INT 1
82364: NEG
82365: PUSH
82366: EMPTY
82367: LIST
82368: LIST
82369: PUSH
82370: LD_INT 4
82372: PUSH
82373: LD_INT 0
82375: PUSH
82376: EMPTY
82377: LIST
82378: LIST
82379: PUSH
82380: LD_INT 4
82382: PUSH
82383: LD_INT 1
82385: PUSH
82386: EMPTY
82387: LIST
82388: LIST
82389: PUSH
82390: LD_INT 3
82392: PUSH
82393: LD_INT 1
82395: PUSH
82396: EMPTY
82397: LIST
82398: LIST
82399: PUSH
82400: LD_INT 2
82402: PUSH
82403: LD_INT 0
82405: PUSH
82406: EMPTY
82407: LIST
82408: LIST
82409: PUSH
82410: LD_INT 2
82412: PUSH
82413: LD_INT 1
82415: NEG
82416: PUSH
82417: EMPTY
82418: LIST
82419: LIST
82420: PUSH
82421: LD_INT 2
82423: PUSH
82424: LD_INT 2
82426: NEG
82427: PUSH
82428: EMPTY
82429: LIST
82430: LIST
82431: PUSH
82432: LD_INT 4
82434: PUSH
82435: LD_INT 2
82437: PUSH
82438: EMPTY
82439: LIST
82440: LIST
82441: PUSH
82442: LD_INT 4
82444: PUSH
82445: LD_INT 4
82447: PUSH
82448: EMPTY
82449: LIST
82450: LIST
82451: PUSH
82452: LD_INT 4
82454: PUSH
82455: LD_INT 3
82457: PUSH
82458: EMPTY
82459: LIST
82460: LIST
82461: PUSH
82462: LD_INT 5
82464: PUSH
82465: LD_INT 4
82467: PUSH
82468: EMPTY
82469: LIST
82470: LIST
82471: PUSH
82472: LD_INT 5
82474: PUSH
82475: LD_INT 5
82477: PUSH
82478: EMPTY
82479: LIST
82480: LIST
82481: PUSH
82482: LD_INT 4
82484: PUSH
82485: LD_INT 5
82487: PUSH
82488: EMPTY
82489: LIST
82490: LIST
82491: PUSH
82492: LD_INT 3
82494: PUSH
82495: LD_INT 4
82497: PUSH
82498: EMPTY
82499: LIST
82500: LIST
82501: PUSH
82502: LD_INT 3
82504: PUSH
82505: LD_INT 3
82507: PUSH
82508: EMPTY
82509: LIST
82510: LIST
82511: PUSH
82512: LD_INT 5
82514: PUSH
82515: LD_INT 3
82517: PUSH
82518: EMPTY
82519: LIST
82520: LIST
82521: PUSH
82522: LD_INT 3
82524: PUSH
82525: LD_INT 5
82527: PUSH
82528: EMPTY
82529: LIST
82530: LIST
82531: PUSH
82532: EMPTY
82533: LIST
82534: LIST
82535: LIST
82536: LIST
82537: LIST
82538: LIST
82539: LIST
82540: LIST
82541: LIST
82542: LIST
82543: LIST
82544: LIST
82545: LIST
82546: LIST
82547: LIST
82548: LIST
82549: LIST
82550: LIST
82551: LIST
82552: LIST
82553: LIST
82554: LIST
82555: LIST
82556: LIST
82557: LIST
82558: LIST
82559: LIST
82560: LIST
82561: LIST
82562: LIST
82563: LIST
82564: LIST
82565: LIST
82566: LIST
82567: LIST
82568: LIST
82569: LIST
82570: LIST
82571: LIST
82572: LIST
82573: LIST
82574: LIST
82575: LIST
82576: LIST
82577: LIST
82578: ST_TO_ADDR
// fFactory4 = [ [ - 4 , - 4 ] , [ - 4 , - 5 ] , [ - 3 , - 4 ] , [ - 3 , - 3 ] , [ - 4 , - 3 ] , [ - 5 , - 4 ] , [ - 5 , - 5 ] , [ - 3 , - 5 ] , [ - 5 , - 3 ] , [ 0 , - 3 ] , [ 0 , - 4 ] , [ 1 , - 3 ] , [ 1 , - 2 ] , [ 0 , - 2 ] , [ - 1 , - 3 ] , [ - 1 , - 4 ] , [ 2 , - 2 ] , [ - 2 , - 4 ] , [ 4 , 0 ] , [ 4 , - 1 ] , [ 5 , 0 ] , [ 5 , 1 ] , [ 4 , 1 ] , [ 3 , 0 ] , [ 3 , - 1 ] , [ 3 , - 2 ] , [ 5 , 2 ] , [ 3 , 3 ] , [ 3 , 2 ] , [ 4 , 3 ] , [ 4 , 4 ] , [ 3 , 4 ] , [ 2 , 3 ] , [ 2 , 2 ] , [ 4 , 2 ] , [ 2 , 4 ] , [ 0 , 4 ] , [ 0 , 3 ] , [ 1 , 4 ] , [ 1 , 5 ] , [ 0 , 5 ] , [ - 1 , 4 ] , [ - 1 , 3 ] , [ 2 , 5 ] , [ - 2 , 3 ] ] ;
82579: LD_ADDR_VAR 0 33
82583: PUSH
82584: LD_INT 4
82586: NEG
82587: PUSH
82588: LD_INT 4
82590: NEG
82591: PUSH
82592: EMPTY
82593: LIST
82594: LIST
82595: PUSH
82596: LD_INT 4
82598: NEG
82599: PUSH
82600: LD_INT 5
82602: NEG
82603: PUSH
82604: EMPTY
82605: LIST
82606: LIST
82607: PUSH
82608: LD_INT 3
82610: NEG
82611: PUSH
82612: LD_INT 4
82614: NEG
82615: PUSH
82616: EMPTY
82617: LIST
82618: LIST
82619: PUSH
82620: LD_INT 3
82622: NEG
82623: PUSH
82624: LD_INT 3
82626: NEG
82627: PUSH
82628: EMPTY
82629: LIST
82630: LIST
82631: PUSH
82632: LD_INT 4
82634: NEG
82635: PUSH
82636: LD_INT 3
82638: NEG
82639: PUSH
82640: EMPTY
82641: LIST
82642: LIST
82643: PUSH
82644: LD_INT 5
82646: NEG
82647: PUSH
82648: LD_INT 4
82650: NEG
82651: PUSH
82652: EMPTY
82653: LIST
82654: LIST
82655: PUSH
82656: LD_INT 5
82658: NEG
82659: PUSH
82660: LD_INT 5
82662: NEG
82663: PUSH
82664: EMPTY
82665: LIST
82666: LIST
82667: PUSH
82668: LD_INT 3
82670: NEG
82671: PUSH
82672: LD_INT 5
82674: NEG
82675: PUSH
82676: EMPTY
82677: LIST
82678: LIST
82679: PUSH
82680: LD_INT 5
82682: NEG
82683: PUSH
82684: LD_INT 3
82686: NEG
82687: PUSH
82688: EMPTY
82689: LIST
82690: LIST
82691: PUSH
82692: LD_INT 0
82694: PUSH
82695: LD_INT 3
82697: NEG
82698: PUSH
82699: EMPTY
82700: LIST
82701: LIST
82702: PUSH
82703: LD_INT 0
82705: PUSH
82706: LD_INT 4
82708: NEG
82709: PUSH
82710: EMPTY
82711: LIST
82712: LIST
82713: PUSH
82714: LD_INT 1
82716: PUSH
82717: LD_INT 3
82719: NEG
82720: PUSH
82721: EMPTY
82722: LIST
82723: LIST
82724: PUSH
82725: LD_INT 1
82727: PUSH
82728: LD_INT 2
82730: NEG
82731: PUSH
82732: EMPTY
82733: LIST
82734: LIST
82735: PUSH
82736: LD_INT 0
82738: PUSH
82739: LD_INT 2
82741: NEG
82742: PUSH
82743: EMPTY
82744: LIST
82745: LIST
82746: PUSH
82747: LD_INT 1
82749: NEG
82750: PUSH
82751: LD_INT 3
82753: NEG
82754: PUSH
82755: EMPTY
82756: LIST
82757: LIST
82758: PUSH
82759: LD_INT 1
82761: NEG
82762: PUSH
82763: LD_INT 4
82765: NEG
82766: PUSH
82767: EMPTY
82768: LIST
82769: LIST
82770: PUSH
82771: LD_INT 2
82773: PUSH
82774: LD_INT 2
82776: NEG
82777: PUSH
82778: EMPTY
82779: LIST
82780: LIST
82781: PUSH
82782: LD_INT 2
82784: NEG
82785: PUSH
82786: LD_INT 4
82788: NEG
82789: PUSH
82790: EMPTY
82791: LIST
82792: LIST
82793: PUSH
82794: LD_INT 4
82796: PUSH
82797: LD_INT 0
82799: PUSH
82800: EMPTY
82801: LIST
82802: LIST
82803: PUSH
82804: LD_INT 4
82806: PUSH
82807: LD_INT 1
82809: NEG
82810: PUSH
82811: EMPTY
82812: LIST
82813: LIST
82814: PUSH
82815: LD_INT 5
82817: PUSH
82818: LD_INT 0
82820: PUSH
82821: EMPTY
82822: LIST
82823: LIST
82824: PUSH
82825: LD_INT 5
82827: PUSH
82828: LD_INT 1
82830: PUSH
82831: EMPTY
82832: LIST
82833: LIST
82834: PUSH
82835: LD_INT 4
82837: PUSH
82838: LD_INT 1
82840: PUSH
82841: EMPTY
82842: LIST
82843: LIST
82844: PUSH
82845: LD_INT 3
82847: PUSH
82848: LD_INT 0
82850: PUSH
82851: EMPTY
82852: LIST
82853: LIST
82854: PUSH
82855: LD_INT 3
82857: PUSH
82858: LD_INT 1
82860: NEG
82861: PUSH
82862: EMPTY
82863: LIST
82864: LIST
82865: PUSH
82866: LD_INT 3
82868: PUSH
82869: LD_INT 2
82871: NEG
82872: PUSH
82873: EMPTY
82874: LIST
82875: LIST
82876: PUSH
82877: LD_INT 5
82879: PUSH
82880: LD_INT 2
82882: PUSH
82883: EMPTY
82884: LIST
82885: LIST
82886: PUSH
82887: LD_INT 3
82889: PUSH
82890: LD_INT 3
82892: PUSH
82893: EMPTY
82894: LIST
82895: LIST
82896: PUSH
82897: LD_INT 3
82899: PUSH
82900: LD_INT 2
82902: PUSH
82903: EMPTY
82904: LIST
82905: LIST
82906: PUSH
82907: LD_INT 4
82909: PUSH
82910: LD_INT 3
82912: PUSH
82913: EMPTY
82914: LIST
82915: LIST
82916: PUSH
82917: LD_INT 4
82919: PUSH
82920: LD_INT 4
82922: PUSH
82923: EMPTY
82924: LIST
82925: LIST
82926: PUSH
82927: LD_INT 3
82929: PUSH
82930: LD_INT 4
82932: PUSH
82933: EMPTY
82934: LIST
82935: LIST
82936: PUSH
82937: LD_INT 2
82939: PUSH
82940: LD_INT 3
82942: PUSH
82943: EMPTY
82944: LIST
82945: LIST
82946: PUSH
82947: LD_INT 2
82949: PUSH
82950: LD_INT 2
82952: PUSH
82953: EMPTY
82954: LIST
82955: LIST
82956: PUSH
82957: LD_INT 4
82959: PUSH
82960: LD_INT 2
82962: PUSH
82963: EMPTY
82964: LIST
82965: LIST
82966: PUSH
82967: LD_INT 2
82969: PUSH
82970: LD_INT 4
82972: PUSH
82973: EMPTY
82974: LIST
82975: LIST
82976: PUSH
82977: LD_INT 0
82979: PUSH
82980: LD_INT 4
82982: PUSH
82983: EMPTY
82984: LIST
82985: LIST
82986: PUSH
82987: LD_INT 0
82989: PUSH
82990: LD_INT 3
82992: PUSH
82993: EMPTY
82994: LIST
82995: LIST
82996: PUSH
82997: LD_INT 1
82999: PUSH
83000: LD_INT 4
83002: PUSH
83003: EMPTY
83004: LIST
83005: LIST
83006: PUSH
83007: LD_INT 1
83009: PUSH
83010: LD_INT 5
83012: PUSH
83013: EMPTY
83014: LIST
83015: LIST
83016: PUSH
83017: LD_INT 0
83019: PUSH
83020: LD_INT 5
83022: PUSH
83023: EMPTY
83024: LIST
83025: LIST
83026: PUSH
83027: LD_INT 1
83029: NEG
83030: PUSH
83031: LD_INT 4
83033: PUSH
83034: EMPTY
83035: LIST
83036: LIST
83037: PUSH
83038: LD_INT 1
83040: NEG
83041: PUSH
83042: LD_INT 3
83044: PUSH
83045: EMPTY
83046: LIST
83047: LIST
83048: PUSH
83049: LD_INT 2
83051: PUSH
83052: LD_INT 5
83054: PUSH
83055: EMPTY
83056: LIST
83057: LIST
83058: PUSH
83059: LD_INT 2
83061: NEG
83062: PUSH
83063: LD_INT 3
83065: PUSH
83066: EMPTY
83067: LIST
83068: LIST
83069: PUSH
83070: EMPTY
83071: LIST
83072: LIST
83073: LIST
83074: LIST
83075: LIST
83076: LIST
83077: LIST
83078: LIST
83079: LIST
83080: LIST
83081: LIST
83082: LIST
83083: LIST
83084: LIST
83085: LIST
83086: LIST
83087: LIST
83088: LIST
83089: LIST
83090: LIST
83091: LIST
83092: LIST
83093: LIST
83094: LIST
83095: LIST
83096: LIST
83097: LIST
83098: LIST
83099: LIST
83100: LIST
83101: LIST
83102: LIST
83103: LIST
83104: LIST
83105: LIST
83106: LIST
83107: LIST
83108: LIST
83109: LIST
83110: LIST
83111: LIST
83112: LIST
83113: LIST
83114: LIST
83115: LIST
83116: ST_TO_ADDR
// fFactory5 = [ [ 0 , - 4 ] , [ 0 , - 5 ] , [ 1 , - 4 ] , [ 1 , - 3 ] , [ 0 , - 3 ] , [ - 1 , - 4 ] , [ - 1 , - 5 ] , [ 2 , - 3 ] , [ - 2 , - 5 ] , [ 3 , 0 ] , [ 3 , - 1 ] , [ 4 , 0 ] , [ 4 , 1 ] , [ 3 , 1 ] , [ 2 , 0 ] , [ 2 , - 1 ] , [ 2 , - 2 ] , [ 4 , 2 ] , [ 4 , 4 ] , [ 4 , 3 ] , [ 5 , 4 ] , [ 5 , 5 ] , [ 4 , 5 ] , [ 3 , 4 ] , [ 3 , 3 ] , [ 5 , 3 ] , [ 3 , 5 ] , [ 0 , 3 ] , [ 0 , 2 ] , [ 1 , 3 ] , [ 1 , 4 ] , [ 0 , 4 ] , [ - 1 , 3 ] , [ - 1 , 2 ] , [ 2 , 4 ] , [ - 2 , 2 ] , [ - 4 , 0 ] , [ - 4 , - 1 ] , [ - 3 , 0 ] , [ - 3 , 1 ] , [ - 4 , 1 ] , [ - 5 , 0 ] , [ - 5 , - 1 ] , [ - 5 , - 2 ] , [ - 3 , 2 ] ] ;
83117: LD_ADDR_VAR 0 34
83121: PUSH
83122: LD_INT 0
83124: PUSH
83125: LD_INT 4
83127: NEG
83128: PUSH
83129: EMPTY
83130: LIST
83131: LIST
83132: PUSH
83133: LD_INT 0
83135: PUSH
83136: LD_INT 5
83138: NEG
83139: PUSH
83140: EMPTY
83141: LIST
83142: LIST
83143: PUSH
83144: LD_INT 1
83146: PUSH
83147: LD_INT 4
83149: NEG
83150: PUSH
83151: EMPTY
83152: LIST
83153: LIST
83154: PUSH
83155: LD_INT 1
83157: PUSH
83158: LD_INT 3
83160: NEG
83161: PUSH
83162: EMPTY
83163: LIST
83164: LIST
83165: PUSH
83166: LD_INT 0
83168: PUSH
83169: LD_INT 3
83171: NEG
83172: PUSH
83173: EMPTY
83174: LIST
83175: LIST
83176: PUSH
83177: LD_INT 1
83179: NEG
83180: PUSH
83181: LD_INT 4
83183: NEG
83184: PUSH
83185: EMPTY
83186: LIST
83187: LIST
83188: PUSH
83189: LD_INT 1
83191: NEG
83192: PUSH
83193: LD_INT 5
83195: NEG
83196: PUSH
83197: EMPTY
83198: LIST
83199: LIST
83200: PUSH
83201: LD_INT 2
83203: PUSH
83204: LD_INT 3
83206: NEG
83207: PUSH
83208: EMPTY
83209: LIST
83210: LIST
83211: PUSH
83212: LD_INT 2
83214: NEG
83215: PUSH
83216: LD_INT 5
83218: NEG
83219: PUSH
83220: EMPTY
83221: LIST
83222: LIST
83223: PUSH
83224: LD_INT 3
83226: PUSH
83227: LD_INT 0
83229: PUSH
83230: EMPTY
83231: LIST
83232: LIST
83233: PUSH
83234: LD_INT 3
83236: PUSH
83237: LD_INT 1
83239: NEG
83240: PUSH
83241: EMPTY
83242: LIST
83243: LIST
83244: PUSH
83245: LD_INT 4
83247: PUSH
83248: LD_INT 0
83250: PUSH
83251: EMPTY
83252: LIST
83253: LIST
83254: PUSH
83255: LD_INT 4
83257: PUSH
83258: LD_INT 1
83260: PUSH
83261: EMPTY
83262: LIST
83263: LIST
83264: PUSH
83265: LD_INT 3
83267: PUSH
83268: LD_INT 1
83270: PUSH
83271: EMPTY
83272: LIST
83273: LIST
83274: PUSH
83275: LD_INT 2
83277: PUSH
83278: LD_INT 0
83280: PUSH
83281: EMPTY
83282: LIST
83283: LIST
83284: PUSH
83285: LD_INT 2
83287: PUSH
83288: LD_INT 1
83290: NEG
83291: PUSH
83292: EMPTY
83293: LIST
83294: LIST
83295: PUSH
83296: LD_INT 2
83298: PUSH
83299: LD_INT 2
83301: NEG
83302: PUSH
83303: EMPTY
83304: LIST
83305: LIST
83306: PUSH
83307: LD_INT 4
83309: PUSH
83310: LD_INT 2
83312: PUSH
83313: EMPTY
83314: LIST
83315: LIST
83316: PUSH
83317: LD_INT 4
83319: PUSH
83320: LD_INT 4
83322: PUSH
83323: EMPTY
83324: LIST
83325: LIST
83326: PUSH
83327: LD_INT 4
83329: PUSH
83330: LD_INT 3
83332: PUSH
83333: EMPTY
83334: LIST
83335: LIST
83336: PUSH
83337: LD_INT 5
83339: PUSH
83340: LD_INT 4
83342: PUSH
83343: EMPTY
83344: LIST
83345: LIST
83346: PUSH
83347: LD_INT 5
83349: PUSH
83350: LD_INT 5
83352: PUSH
83353: EMPTY
83354: LIST
83355: LIST
83356: PUSH
83357: LD_INT 4
83359: PUSH
83360: LD_INT 5
83362: PUSH
83363: EMPTY
83364: LIST
83365: LIST
83366: PUSH
83367: LD_INT 3
83369: PUSH
83370: LD_INT 4
83372: PUSH
83373: EMPTY
83374: LIST
83375: LIST
83376: PUSH
83377: LD_INT 3
83379: PUSH
83380: LD_INT 3
83382: PUSH
83383: EMPTY
83384: LIST
83385: LIST
83386: PUSH
83387: LD_INT 5
83389: PUSH
83390: LD_INT 3
83392: PUSH
83393: EMPTY
83394: LIST
83395: LIST
83396: PUSH
83397: LD_INT 3
83399: PUSH
83400: LD_INT 5
83402: PUSH
83403: EMPTY
83404: LIST
83405: LIST
83406: PUSH
83407: LD_INT 0
83409: PUSH
83410: LD_INT 3
83412: PUSH
83413: EMPTY
83414: LIST
83415: LIST
83416: PUSH
83417: LD_INT 0
83419: PUSH
83420: LD_INT 2
83422: PUSH
83423: EMPTY
83424: LIST
83425: LIST
83426: PUSH
83427: LD_INT 1
83429: PUSH
83430: LD_INT 3
83432: PUSH
83433: EMPTY
83434: LIST
83435: LIST
83436: PUSH
83437: LD_INT 1
83439: PUSH
83440: LD_INT 4
83442: PUSH
83443: EMPTY
83444: LIST
83445: LIST
83446: PUSH
83447: LD_INT 0
83449: PUSH
83450: LD_INT 4
83452: PUSH
83453: EMPTY
83454: LIST
83455: LIST
83456: PUSH
83457: LD_INT 1
83459: NEG
83460: PUSH
83461: LD_INT 3
83463: PUSH
83464: EMPTY
83465: LIST
83466: LIST
83467: PUSH
83468: LD_INT 1
83470: NEG
83471: PUSH
83472: LD_INT 2
83474: PUSH
83475: EMPTY
83476: LIST
83477: LIST
83478: PUSH
83479: LD_INT 2
83481: PUSH
83482: LD_INT 4
83484: PUSH
83485: EMPTY
83486: LIST
83487: LIST
83488: PUSH
83489: LD_INT 2
83491: NEG
83492: PUSH
83493: LD_INT 2
83495: PUSH
83496: EMPTY
83497: LIST
83498: LIST
83499: PUSH
83500: LD_INT 4
83502: NEG
83503: PUSH
83504: LD_INT 0
83506: PUSH
83507: EMPTY
83508: LIST
83509: LIST
83510: PUSH
83511: LD_INT 4
83513: NEG
83514: PUSH
83515: LD_INT 1
83517: NEG
83518: PUSH
83519: EMPTY
83520: LIST
83521: LIST
83522: PUSH
83523: LD_INT 3
83525: NEG
83526: PUSH
83527: LD_INT 0
83529: PUSH
83530: EMPTY
83531: LIST
83532: LIST
83533: PUSH
83534: LD_INT 3
83536: NEG
83537: PUSH
83538: LD_INT 1
83540: PUSH
83541: EMPTY
83542: LIST
83543: LIST
83544: PUSH
83545: LD_INT 4
83547: NEG
83548: PUSH
83549: LD_INT 1
83551: PUSH
83552: EMPTY
83553: LIST
83554: LIST
83555: PUSH
83556: LD_INT 5
83558: NEG
83559: PUSH
83560: LD_INT 0
83562: PUSH
83563: EMPTY
83564: LIST
83565: LIST
83566: PUSH
83567: LD_INT 5
83569: NEG
83570: PUSH
83571: LD_INT 1
83573: NEG
83574: PUSH
83575: EMPTY
83576: LIST
83577: LIST
83578: PUSH
83579: LD_INT 5
83581: NEG
83582: PUSH
83583: LD_INT 2
83585: NEG
83586: PUSH
83587: EMPTY
83588: LIST
83589: LIST
83590: PUSH
83591: LD_INT 3
83593: NEG
83594: PUSH
83595: LD_INT 2
83597: PUSH
83598: EMPTY
83599: LIST
83600: LIST
83601: PUSH
83602: EMPTY
83603: LIST
83604: LIST
83605: LIST
83606: LIST
83607: LIST
83608: LIST
83609: LIST
83610: LIST
83611: LIST
83612: LIST
83613: LIST
83614: LIST
83615: LIST
83616: LIST
83617: LIST
83618: LIST
83619: LIST
83620: LIST
83621: LIST
83622: LIST
83623: LIST
83624: LIST
83625: LIST
83626: LIST
83627: LIST
83628: LIST
83629: LIST
83630: LIST
83631: LIST
83632: LIST
83633: LIST
83634: LIST
83635: LIST
83636: LIST
83637: LIST
83638: LIST
83639: LIST
83640: LIST
83641: LIST
83642: LIST
83643: LIST
83644: LIST
83645: LIST
83646: LIST
83647: LIST
83648: ST_TO_ADDR
// end ; end ;
83649: GO 83652
83651: POP
// case btype of b_depot , b_warehouse :
83652: LD_VAR 0 1
83656: PUSH
83657: LD_INT 0
83659: DOUBLE
83660: EQUAL
83661: IFTRUE 83671
83663: LD_INT 1
83665: DOUBLE
83666: EQUAL
83667: IFTRUE 83671
83669: GO 83872
83671: POP
// case nation of nation_american :
83672: LD_VAR 0 5
83676: PUSH
83677: LD_INT 1
83679: DOUBLE
83680: EQUAL
83681: IFTRUE 83685
83683: GO 83741
83685: POP
// temp_list = [ fDepotAm0 , fDepotAm1 , fDepotAm2 , fDepotAm3 , fDepotAm4 , fDepotAm5 ] [ dir + 1 ] ; nation_arabian :
83686: LD_ADDR_VAR 0 9
83690: PUSH
83691: LD_VAR 0 11
83695: PUSH
83696: LD_VAR 0 12
83700: PUSH
83701: LD_VAR 0 13
83705: PUSH
83706: LD_VAR 0 14
83710: PUSH
83711: LD_VAR 0 15
83715: PUSH
83716: LD_VAR 0 16
83720: PUSH
83721: EMPTY
83722: LIST
83723: LIST
83724: LIST
83725: LIST
83726: LIST
83727: LIST
83728: PUSH
83729: LD_VAR 0 4
83733: PUSH
83734: LD_INT 1
83736: PLUS
83737: ARRAY
83738: ST_TO_ADDR
83739: GO 83870
83741: LD_INT 2
83743: DOUBLE
83744: EQUAL
83745: IFTRUE 83749
83747: GO 83805
83749: POP
// temp_list = [ fDepotAr0 , fDepotAr1 , fDepotAr2 , fDepotAr3 , fDepotAr4 , fDepotAr5 ] [ dir + 1 ] ; nation_russian :
83750: LD_ADDR_VAR 0 9
83754: PUSH
83755: LD_VAR 0 17
83759: PUSH
83760: LD_VAR 0 18
83764: PUSH
83765: LD_VAR 0 19
83769: PUSH
83770: LD_VAR 0 20
83774: PUSH
83775: LD_VAR 0 21
83779: PUSH
83780: LD_VAR 0 22
83784: PUSH
83785: EMPTY
83786: LIST
83787: LIST
83788: LIST
83789: LIST
83790: LIST
83791: LIST
83792: PUSH
83793: LD_VAR 0 4
83797: PUSH
83798: LD_INT 1
83800: PLUS
83801: ARRAY
83802: ST_TO_ADDR
83803: GO 83870
83805: LD_INT 3
83807: DOUBLE
83808: EQUAL
83809: IFTRUE 83813
83811: GO 83869
83813: POP
// temp_list = [ fDepotRu0 , fDepotRu1 , fDepotRu2 , fDepotRu3 , fDepotRu4 , fDepotRu5 ] [ dir + 1 ] ; end ; b_workshop , b_factory :
83814: LD_ADDR_VAR 0 9
83818: PUSH
83819: LD_VAR 0 23
83823: PUSH
83824: LD_VAR 0 24
83828: PUSH
83829: LD_VAR 0 25
83833: PUSH
83834: LD_VAR 0 26
83838: PUSH
83839: LD_VAR 0 27
83843: PUSH
83844: LD_VAR 0 28
83848: PUSH
83849: EMPTY
83850: LIST
83851: LIST
83852: LIST
83853: LIST
83854: LIST
83855: LIST
83856: PUSH
83857: LD_VAR 0 4
83861: PUSH
83862: LD_INT 1
83864: PLUS
83865: ARRAY
83866: ST_TO_ADDR
83867: GO 83870
83869: POP
83870: GO 84425
83872: LD_INT 2
83874: DOUBLE
83875: EQUAL
83876: IFTRUE 83886
83878: LD_INT 3
83880: DOUBLE
83881: EQUAL
83882: IFTRUE 83886
83884: GO 83942
83886: POP
// temp_list = [ fFactory0 , fFactory1 , fFactory2 , fFactory3 , fFactory4 , fFactory5 ] [ dir + 1 ] ; b_ext_track , b_ext_gun , b_ext_rocket , b_ext_noncombat , b_ext_radio , b_ext_radar , b_ext_siberium , b_ext_stitch , b_ext_computer , b_ext_laser :
83887: LD_ADDR_VAR 0 9
83891: PUSH
83892: LD_VAR 0 29
83896: PUSH
83897: LD_VAR 0 30
83901: PUSH
83902: LD_VAR 0 31
83906: PUSH
83907: LD_VAR 0 32
83911: PUSH
83912: LD_VAR 0 33
83916: PUSH
83917: LD_VAR 0 34
83921: PUSH
83922: EMPTY
83923: LIST
83924: LIST
83925: LIST
83926: LIST
83927: LIST
83928: LIST
83929: PUSH
83930: LD_VAR 0 4
83934: PUSH
83935: LD_INT 1
83937: PLUS
83938: ARRAY
83939: ST_TO_ADDR
83940: GO 84425
83942: LD_INT 16
83944: DOUBLE
83945: EQUAL
83946: IFTRUE 84004
83948: LD_INT 17
83950: DOUBLE
83951: EQUAL
83952: IFTRUE 84004
83954: LD_INT 18
83956: DOUBLE
83957: EQUAL
83958: IFTRUE 84004
83960: LD_INT 19
83962: DOUBLE
83963: EQUAL
83964: IFTRUE 84004
83966: LD_INT 22
83968: DOUBLE
83969: EQUAL
83970: IFTRUE 84004
83972: LD_INT 20
83974: DOUBLE
83975: EQUAL
83976: IFTRUE 84004
83978: LD_INT 21
83980: DOUBLE
83981: EQUAL
83982: IFTRUE 84004
83984: LD_INT 23
83986: DOUBLE
83987: EQUAL
83988: IFTRUE 84004
83990: LD_INT 24
83992: DOUBLE
83993: EQUAL
83994: IFTRUE 84004
83996: LD_INT 25
83998: DOUBLE
83999: EQUAL
84000: IFTRUE 84004
84002: GO 84060
84004: POP
// temp_list = [ fExt0 , fExt1 , fExt2 , fExt3 , fExt4 , fExt5 ] [ dir + 1 ] ; b_lab , b_lab_half , b_lab_full , b_lab_biological , b_lab_computer , b_lab_opto , b_lab_siberium , b_lab_spacetime , b_lab_weapon :
84005: LD_ADDR_VAR 0 9
84009: PUSH
84010: LD_VAR 0 35
84014: PUSH
84015: LD_VAR 0 36
84019: PUSH
84020: LD_VAR 0 37
84024: PUSH
84025: LD_VAR 0 38
84029: PUSH
84030: LD_VAR 0 39
84034: PUSH
84035: LD_VAR 0 40
84039: PUSH
84040: EMPTY
84041: LIST
84042: LIST
84043: LIST
84044: LIST
84045: LIST
84046: LIST
84047: PUSH
84048: LD_VAR 0 4
84052: PUSH
84053: LD_INT 1
84055: PLUS
84056: ARRAY
84057: ST_TO_ADDR
84058: GO 84425
84060: LD_INT 6
84062: DOUBLE
84063: EQUAL
84064: IFTRUE 84116
84066: LD_INT 7
84068: DOUBLE
84069: EQUAL
84070: IFTRUE 84116
84072: LD_INT 8
84074: DOUBLE
84075: EQUAL
84076: IFTRUE 84116
84078: LD_INT 13
84080: DOUBLE
84081: EQUAL
84082: IFTRUE 84116
84084: LD_INT 12
84086: DOUBLE
84087: EQUAL
84088: IFTRUE 84116
84090: LD_INT 15
84092: DOUBLE
84093: EQUAL
84094: IFTRUE 84116
84096: LD_INT 11
84098: DOUBLE
84099: EQUAL
84100: IFTRUE 84116
84102: LD_INT 14
84104: DOUBLE
84105: EQUAL
84106: IFTRUE 84116
84108: LD_INT 10
84110: DOUBLE
84111: EQUAL
84112: IFTRUE 84116
84114: GO 84172
84116: POP
// temp_list = [ fLab0 , fLab1 , fLab2 , fLab3 , fLab4 , fLab5 ] [ dir + 1 ] ; b_control_tower :
84117: LD_ADDR_VAR 0 9
84121: PUSH
84122: LD_VAR 0 41
84126: PUSH
84127: LD_VAR 0 42
84131: PUSH
84132: LD_VAR 0 43
84136: PUSH
84137: LD_VAR 0 44
84141: PUSH
84142: LD_VAR 0 45
84146: PUSH
84147: LD_VAR 0 46
84151: PUSH
84152: EMPTY
84153: LIST
84154: LIST
84155: LIST
84156: LIST
84157: LIST
84158: LIST
84159: PUSH
84160: LD_VAR 0 4
84164: PUSH
84165: LD_INT 1
84167: PLUS
84168: ARRAY
84169: ST_TO_ADDR
84170: GO 84425
84172: LD_INT 36
84174: DOUBLE
84175: EQUAL
84176: IFTRUE 84180
84178: GO 84236
84180: POP
// temp_list = [ fControlTower0 , fControlTower1 , fControlTower2 , fControlTower3 , fControlTower4 , fControlTower5 ] [ dir + 1 ] ; b_armoury , b_barracks , b_teleport , b_behemoth :
84181: LD_ADDR_VAR 0 9
84185: PUSH
84186: LD_VAR 0 47
84190: PUSH
84191: LD_VAR 0 48
84195: PUSH
84196: LD_VAR 0 49
84200: PUSH
84201: LD_VAR 0 50
84205: PUSH
84206: LD_VAR 0 51
84210: PUSH
84211: LD_VAR 0 52
84215: PUSH
84216: EMPTY
84217: LIST
84218: LIST
84219: LIST
84220: LIST
84221: LIST
84222: LIST
84223: PUSH
84224: LD_VAR 0 4
84228: PUSH
84229: LD_INT 1
84231: PLUS
84232: ARRAY
84233: ST_TO_ADDR
84234: GO 84425
84236: LD_INT 4
84238: DOUBLE
84239: EQUAL
84240: IFTRUE 84262
84242: LD_INT 5
84244: DOUBLE
84245: EQUAL
84246: IFTRUE 84262
84248: LD_INT 34
84250: DOUBLE
84251: EQUAL
84252: IFTRUE 84262
84254: LD_INT 37
84256: DOUBLE
84257: EQUAL
84258: IFTRUE 84262
84260: GO 84318
84262: POP
// temp_list = [ fBarracks0 , fBarracks1 , fBarracks2 , fBarracks3 , fBarracks4 , fBarracks5 ] [ dir + 1 ] ; b_breastwork , b_bunker , b_turret , b_solar_power , b_oil_power , b_siberite_power , b_oil_mine , b_siberite_mine :
84263: LD_ADDR_VAR 0 9
84267: PUSH
84268: LD_VAR 0 53
84272: PUSH
84273: LD_VAR 0 54
84277: PUSH
84278: LD_VAR 0 55
84282: PUSH
84283: LD_VAR 0 56
84287: PUSH
84288: LD_VAR 0 57
84292: PUSH
84293: LD_VAR 0 58
84297: PUSH
84298: EMPTY
84299: LIST
84300: LIST
84301: LIST
84302: LIST
84303: LIST
84304: LIST
84305: PUSH
84306: LD_VAR 0 4
84310: PUSH
84311: LD_INT 1
84313: PLUS
84314: ARRAY
84315: ST_TO_ADDR
84316: GO 84425
84318: LD_INT 31
84320: DOUBLE
84321: EQUAL
84322: IFTRUE 84368
84324: LD_INT 32
84326: DOUBLE
84327: EQUAL
84328: IFTRUE 84368
84330: LD_INT 33
84332: DOUBLE
84333: EQUAL
84334: IFTRUE 84368
84336: LD_INT 27
84338: DOUBLE
84339: EQUAL
84340: IFTRUE 84368
84342: LD_INT 26
84344: DOUBLE
84345: EQUAL
84346: IFTRUE 84368
84348: LD_INT 28
84350: DOUBLE
84351: EQUAL
84352: IFTRUE 84368
84354: LD_INT 29
84356: DOUBLE
84357: EQUAL
84358: IFTRUE 84368
84360: LD_INT 30
84362: DOUBLE
84363: EQUAL
84364: IFTRUE 84368
84366: GO 84424
84368: POP
// temp_list = [ fBunker0 , fBunker1 , fBunker2 , fBunker3 , fBunker4 , fBunker5 ] [ dir + 1 ] ; end ;
84369: LD_ADDR_VAR 0 9
84373: PUSH
84374: LD_VAR 0 59
84378: PUSH
84379: LD_VAR 0 60
84383: PUSH
84384: LD_VAR 0 61
84388: PUSH
84389: LD_VAR 0 62
84393: PUSH
84394: LD_VAR 0 63
84398: PUSH
84399: LD_VAR 0 64
84403: PUSH
84404: EMPTY
84405: LIST
84406: LIST
84407: LIST
84408: LIST
84409: LIST
84410: LIST
84411: PUSH
84412: LD_VAR 0 4
84416: PUSH
84417: LD_INT 1
84419: PLUS
84420: ARRAY
84421: ST_TO_ADDR
84422: GO 84425
84424: POP
// temp_list2 = [ ] ;
84425: LD_ADDR_VAR 0 10
84429: PUSH
84430: EMPTY
84431: ST_TO_ADDR
// for i in temp_list do
84432: LD_ADDR_VAR 0 8
84436: PUSH
84437: LD_VAR 0 9
84441: PUSH
84442: FOR_IN
84443: IFFALSE 84495
// temp_list2 = temp_list2 ^ [ [ i [ 1 ] + x , i [ 2 ] + y ] ] ;
84445: LD_ADDR_VAR 0 10
84449: PUSH
84450: LD_VAR 0 10
84454: PUSH
84455: LD_VAR 0 8
84459: PUSH
84460: LD_INT 1
84462: ARRAY
84463: PUSH
84464: LD_VAR 0 2
84468: PLUS
84469: PUSH
84470: LD_VAR 0 8
84474: PUSH
84475: LD_INT 2
84477: ARRAY
84478: PUSH
84479: LD_VAR 0 3
84483: PLUS
84484: PUSH
84485: EMPTY
84486: LIST
84487: LIST
84488: PUSH
84489: EMPTY
84490: LIST
84491: ADD
84492: ST_TO_ADDR
84493: GO 84442
84495: POP
84496: POP
// result = temp_list2 ;
84497: LD_ADDR_VAR 0 7
84501: PUSH
84502: LD_VAR 0 10
84506: ST_TO_ADDR
// end ;
84507: LD_VAR 0 7
84511: RET
// export function EnemyInRange ( unit , dist ) ; begin
84512: LD_INT 0
84514: PPUSH
// result := DangerAtRangeXY ( GetSide ( unit ) , GetX ( unit ) , GetY ( unit ) , dist ) [ 4 ] ;
84515: LD_ADDR_VAR 0 3
84519: PUSH
84520: LD_VAR 0 1
84524: PPUSH
84525: CALL_OW 255
84529: PPUSH
84530: LD_VAR 0 1
84534: PPUSH
84535: CALL_OW 250
84539: PPUSH
84540: LD_VAR 0 1
84544: PPUSH
84545: CALL_OW 251
84549: PPUSH
84550: LD_VAR 0 2
84554: PPUSH
84555: CALL 57908 0 4
84559: PUSH
84560: LD_INT 4
84562: ARRAY
84563: ST_TO_ADDR
// end ;
84564: LD_VAR 0 3
84568: RET
// export function PlayerSeeMe ( unit ) ; begin
84569: LD_INT 0
84571: PPUSH
// result := See ( your_side , unit ) ;
84572: LD_ADDR_VAR 0 2
84576: PUSH
84577: LD_OWVAR 2
84581: PPUSH
84582: LD_VAR 0 1
84586: PPUSH
84587: CALL_OW 292
84591: ST_TO_ADDR
// end ;
84592: LD_VAR 0 2
84596: RET
// export function ReverseDir ( unit ) ; begin
84597: LD_INT 0
84599: PPUSH
// if not unit then
84600: LD_VAR 0 1
84604: NOT
84605: IFFALSE 84609
// exit ;
84607: GO 84632
// result := ( GetDir ( unit ) + 3 ) mod 6 ;
84609: LD_ADDR_VAR 0 2
84613: PUSH
84614: LD_VAR 0 1
84618: PPUSH
84619: CALL_OW 254
84623: PUSH
84624: LD_INT 3
84626: PLUS
84627: PUSH
84628: LD_INT 6
84630: MOD
84631: ST_TO_ADDR
// end ;
84632: LD_VAR 0 2
84636: RET
// export function GetClosestHex ( unit , hexes ) ; var i , dist , tmp , hex ; begin
84637: LD_INT 0
84639: PPUSH
84640: PPUSH
84641: PPUSH
84642: PPUSH
84643: PPUSH
// if not hexes then
84644: LD_VAR 0 2
84648: NOT
84649: IFFALSE 84653
// exit ;
84651: GO 84801
// dist := 9999 ;
84653: LD_ADDR_VAR 0 5
84657: PUSH
84658: LD_INT 9999
84660: ST_TO_ADDR
// for i = 1 to hexes do
84661: LD_ADDR_VAR 0 4
84665: PUSH
84666: DOUBLE
84667: LD_INT 1
84669: DEC
84670: ST_TO_ADDR
84671: LD_VAR 0 2
84675: PUSH
84676: FOR_TO
84677: IFFALSE 84789
// begin if GetDistUnitXY ( unit , hexes [ i ] [ 1 ] , hexes [ i ] [ 2 ] ) < dist then
84679: LD_VAR 0 1
84683: PPUSH
84684: LD_VAR 0 2
84688: PUSH
84689: LD_VAR 0 4
84693: ARRAY
84694: PUSH
84695: LD_INT 1
84697: ARRAY
84698: PPUSH
84699: LD_VAR 0 2
84703: PUSH
84704: LD_VAR 0 4
84708: ARRAY
84709: PUSH
84710: LD_INT 2
84712: ARRAY
84713: PPUSH
84714: CALL_OW 297
84718: PUSH
84719: LD_VAR 0 5
84723: LESS
84724: IFFALSE 84787
// begin hex := hexes [ i ] ;
84726: LD_ADDR_VAR 0 7
84730: PUSH
84731: LD_VAR 0 2
84735: PUSH
84736: LD_VAR 0 4
84740: ARRAY
84741: ST_TO_ADDR
// dist := GetDistUnitXY ( unit , hexes [ i ] [ 1 ] , hexes [ i ] [ 2 ] ) ;
84742: LD_ADDR_VAR 0 5
84746: PUSH
84747: LD_VAR 0 1
84751: PPUSH
84752: LD_VAR 0 2
84756: PUSH
84757: LD_VAR 0 4
84761: ARRAY
84762: PUSH
84763: LD_INT 1
84765: ARRAY
84766: PPUSH
84767: LD_VAR 0 2
84771: PUSH
84772: LD_VAR 0 4
84776: ARRAY
84777: PUSH
84778: LD_INT 2
84780: ARRAY
84781: PPUSH
84782: CALL_OW 297
84786: ST_TO_ADDR
// end ; end ;
84787: GO 84676
84789: POP
84790: POP
// result := hex ;
84791: LD_ADDR_VAR 0 3
84795: PUSH
84796: LD_VAR 0 7
84800: ST_TO_ADDR
// end ;
84801: LD_VAR 0 3
84805: RET
// export function ComAutodestruct ( unit ) ; var i ; begin
84806: LD_INT 0
84808: PPUSH
84809: PPUSH
// if not unit or not unit in FilterAllUnits ( [ [ f_type , unit_vehicle ] , [ f_nation , 2 ] ] ) then
84810: LD_VAR 0 1
84814: NOT
84815: PUSH
84816: LD_VAR 0 1
84820: PUSH
84821: LD_INT 21
84823: PUSH
84824: LD_INT 2
84826: PUSH
84827: EMPTY
84828: LIST
84829: LIST
84830: PUSH
84831: LD_INT 23
84833: PUSH
84834: LD_INT 2
84836: PUSH
84837: EMPTY
84838: LIST
84839: LIST
84840: PUSH
84841: EMPTY
84842: LIST
84843: LIST
84844: PPUSH
84845: CALL_OW 69
84849: IN
84850: NOT
84851: OR
84852: IFFALSE 84856
// exit ;
84854: GO 84903
// for i = 1 to 3 do
84856: LD_ADDR_VAR 0 3
84860: PUSH
84861: DOUBLE
84862: LD_INT 1
84864: DEC
84865: ST_TO_ADDR
84866: LD_INT 3
84868: PUSH
84869: FOR_TO
84870: IFFALSE 84901
// MineExplosion ( GetX ( unit ) , GetY ( unit ) , 1 ) ;
84872: LD_VAR 0 1
84876: PPUSH
84877: CALL_OW 250
84881: PPUSH
84882: LD_VAR 0 1
84886: PPUSH
84887: CALL_OW 251
84891: PPUSH
84892: LD_INT 1
84894: PPUSH
84895: CALL_OW 453
84899: GO 84869
84901: POP
84902: POP
// end ;
84903: LD_VAR 0 2
84907: RET
// export function AttackHovercraft ( unit , enemy_unit ) ; var i , j , tmp , x , y ; begin
84908: LD_INT 0
84910: PPUSH
84911: PPUSH
84912: PPUSH
84913: PPUSH
84914: PPUSH
84915: PPUSH
// if not unit or not enemy_unit or HasTask ( unit ) then
84916: LD_VAR 0 1
84920: NOT
84921: PUSH
84922: LD_VAR 0 2
84926: NOT
84927: OR
84928: PUSH
84929: LD_VAR 0 1
84933: PPUSH
84934: CALL_OW 314
84938: OR
84939: IFFALSE 84943
// exit ;
84941: GO 85384
// x := GetX ( enemy_unit ) ;
84943: LD_ADDR_VAR 0 7
84947: PUSH
84948: LD_VAR 0 2
84952: PPUSH
84953: CALL_OW 250
84957: ST_TO_ADDR
// y := GetY ( enemy_unit ) ;
84958: LD_ADDR_VAR 0 8
84962: PUSH
84963: LD_VAR 0 2
84967: PPUSH
84968: CALL_OW 251
84972: ST_TO_ADDR
// if not x or not y then
84973: LD_VAR 0 7
84977: NOT
84978: PUSH
84979: LD_VAR 0 8
84983: NOT
84984: OR
84985: IFFALSE 84989
// exit ;
84987: GO 85384
// tmp := [ [ ShiftX ( x , 0 , 4 ) , ShiftY ( y , 0 , 4 ) ] , [ ShiftX ( x , 1 , 4 ) , ShiftY ( y , 1 , 4 ) ] , [ ShiftX ( x , 2 , 4 ) , ShiftY ( y , 2 , 4 ) ] , [ ShiftX ( x , 3 , 4 ) , ShiftY ( y , 3 , 4 ) ] , [ ShiftX ( x , 4 , 4 ) , ShiftY ( y , 4 , 4 ) ] , [ ShiftX ( x , 5 , 4 ) , ShiftY ( y , 5 , 4 ) ] ] ;
84989: LD_ADDR_VAR 0 6
84993: PUSH
84994: LD_VAR 0 7
84998: PPUSH
84999: LD_INT 0
85001: PPUSH
85002: LD_INT 4
85004: PPUSH
85005: CALL_OW 272
85009: PUSH
85010: LD_VAR 0 8
85014: PPUSH
85015: LD_INT 0
85017: PPUSH
85018: LD_INT 4
85020: PPUSH
85021: CALL_OW 273
85025: PUSH
85026: EMPTY
85027: LIST
85028: LIST
85029: PUSH
85030: LD_VAR 0 7
85034: PPUSH
85035: LD_INT 1
85037: PPUSH
85038: LD_INT 4
85040: PPUSH
85041: CALL_OW 272
85045: PUSH
85046: LD_VAR 0 8
85050: PPUSH
85051: LD_INT 1
85053: PPUSH
85054: LD_INT 4
85056: PPUSH
85057: CALL_OW 273
85061: PUSH
85062: EMPTY
85063: LIST
85064: LIST
85065: PUSH
85066: LD_VAR 0 7
85070: PPUSH
85071: LD_INT 2
85073: PPUSH
85074: LD_INT 4
85076: PPUSH
85077: CALL_OW 272
85081: PUSH
85082: LD_VAR 0 8
85086: PPUSH
85087: LD_INT 2
85089: PPUSH
85090: LD_INT 4
85092: PPUSH
85093: CALL_OW 273
85097: PUSH
85098: EMPTY
85099: LIST
85100: LIST
85101: PUSH
85102: LD_VAR 0 7
85106: PPUSH
85107: LD_INT 3
85109: PPUSH
85110: LD_INT 4
85112: PPUSH
85113: CALL_OW 272
85117: PUSH
85118: LD_VAR 0 8
85122: PPUSH
85123: LD_INT 3
85125: PPUSH
85126: LD_INT 4
85128: PPUSH
85129: CALL_OW 273
85133: PUSH
85134: EMPTY
85135: LIST
85136: LIST
85137: PUSH
85138: LD_VAR 0 7
85142: PPUSH
85143: LD_INT 4
85145: PPUSH
85146: LD_INT 4
85148: PPUSH
85149: CALL_OW 272
85153: PUSH
85154: LD_VAR 0 8
85158: PPUSH
85159: LD_INT 4
85161: PPUSH
85162: LD_INT 4
85164: PPUSH
85165: CALL_OW 273
85169: PUSH
85170: EMPTY
85171: LIST
85172: LIST
85173: PUSH
85174: LD_VAR 0 7
85178: PPUSH
85179: LD_INT 5
85181: PPUSH
85182: LD_INT 4
85184: PPUSH
85185: CALL_OW 272
85189: PUSH
85190: LD_VAR 0 8
85194: PPUSH
85195: LD_INT 5
85197: PPUSH
85198: LD_INT 4
85200: PPUSH
85201: CALL_OW 273
85205: PUSH
85206: EMPTY
85207: LIST
85208: LIST
85209: PUSH
85210: EMPTY
85211: LIST
85212: LIST
85213: LIST
85214: LIST
85215: LIST
85216: LIST
85217: ST_TO_ADDR
// for i = tmp downto 1 do
85218: LD_ADDR_VAR 0 4
85222: PUSH
85223: DOUBLE
85224: LD_VAR 0 6
85228: INC
85229: ST_TO_ADDR
85230: LD_INT 1
85232: PUSH
85233: FOR_DOWNTO
85234: IFFALSE 85335
// if not ValidHex ( tmp [ i ] [ 1 ] , tmp [ i ] [ 2 ] ) or HexInfo ( tmp [ i ] [ 1 ] , tmp [ i ] [ 2 ] ) <> 0 then
85236: LD_VAR 0 6
85240: PUSH
85241: LD_VAR 0 4
85245: ARRAY
85246: PUSH
85247: LD_INT 1
85249: ARRAY
85250: PPUSH
85251: LD_VAR 0 6
85255: PUSH
85256: LD_VAR 0 4
85260: ARRAY
85261: PUSH
85262: LD_INT 2
85264: ARRAY
85265: PPUSH
85266: CALL_OW 488
85270: NOT
85271: PUSH
85272: LD_VAR 0 6
85276: PUSH
85277: LD_VAR 0 4
85281: ARRAY
85282: PUSH
85283: LD_INT 1
85285: ARRAY
85286: PPUSH
85287: LD_VAR 0 6
85291: PUSH
85292: LD_VAR 0 4
85296: ARRAY
85297: PUSH
85298: LD_INT 2
85300: ARRAY
85301: PPUSH
85302: CALL_OW 428
85306: PUSH
85307: LD_INT 0
85309: NONEQUAL
85310: OR
85311: IFFALSE 85333
// tmp := Delete ( tmp , i ) ;
85313: LD_ADDR_VAR 0 6
85317: PUSH
85318: LD_VAR 0 6
85322: PPUSH
85323: LD_VAR 0 4
85327: PPUSH
85328: CALL_OW 3
85332: ST_TO_ADDR
85333: GO 85233
85335: POP
85336: POP
// j := GetClosestHex ( unit , tmp ) ;
85337: LD_ADDR_VAR 0 5
85341: PUSH
85342: LD_VAR 0 1
85346: PPUSH
85347: LD_VAR 0 6
85351: PPUSH
85352: CALL 84637 0 2
85356: ST_TO_ADDR
// ComMoveXY ( unit , j [ 1 ] , j [ 2 ] ) ;
85357: LD_VAR 0 1
85361: PPUSH
85362: LD_VAR 0 5
85366: PUSH
85367: LD_INT 1
85369: ARRAY
85370: PPUSH
85371: LD_VAR 0 5
85375: PUSH
85376: LD_INT 2
85378: ARRAY
85379: PPUSH
85380: CALL_OW 111
// end ;
85384: LD_VAR 0 3
85388: RET
// export function PrepareNature ( birds , tigers , apemans , enchidnas , horses , mastodonts , fishes , nat_area , wat_area ) ; var i , animal ; begin
85389: LD_INT 0
85391: PPUSH
85392: PPUSH
85393: PPUSH
// uc_side = 0 ;
85394: LD_ADDR_OWVAR 20
85398: PUSH
85399: LD_INT 0
85401: ST_TO_ADDR
// uc_nation = 0 ;
85402: LD_ADDR_OWVAR 21
85406: PUSH
85407: LD_INT 0
85409: ST_TO_ADDR
// InitHc_All ( ) ;
85410: CALL_OW 584
// InitVc ;
85414: CALL_OW 20
// if mastodonts then
85418: LD_VAR 0 6
85422: IFFALSE 85489
// for i = 1 to mastodonts do
85424: LD_ADDR_VAR 0 11
85428: PUSH
85429: DOUBLE
85430: LD_INT 1
85432: DEC
85433: ST_TO_ADDR
85434: LD_VAR 0 6
85438: PUSH
85439: FOR_TO
85440: IFFALSE 85487
// begin vc_chassis := 31 ;
85442: LD_ADDR_OWVAR 37
85446: PUSH
85447: LD_INT 31
85449: ST_TO_ADDR
// vc_control := control_rider ;
85450: LD_ADDR_OWVAR 38
85454: PUSH
85455: LD_INT 4
85457: ST_TO_ADDR
// animal := CreateVehicle ;
85458: LD_ADDR_VAR 0 12
85462: PUSH
85463: CALL_OW 45
85467: ST_TO_ADDR
// PlaceUnitInArea ( animal , nat_area , false ) ;
85468: LD_VAR 0 12
85472: PPUSH
85473: LD_VAR 0 8
85477: PPUSH
85478: LD_INT 0
85480: PPUSH
85481: CALL 87677 0 3
// end ;
85485: GO 85439
85487: POP
85488: POP
// if horses then
85489: LD_VAR 0 5
85493: IFFALSE 85560
// for i = 1 to horses do
85495: LD_ADDR_VAR 0 11
85499: PUSH
85500: DOUBLE
85501: LD_INT 1
85503: DEC
85504: ST_TO_ADDR
85505: LD_VAR 0 5
85509: PUSH
85510: FOR_TO
85511: IFFALSE 85558
// begin hc_class := 21 ;
85513: LD_ADDR_OWVAR 28
85517: PUSH
85518: LD_INT 21
85520: ST_TO_ADDR
// hc_gallery :=  ;
85521: LD_ADDR_OWVAR 33
85525: PUSH
85526: LD_STRING 
85528: ST_TO_ADDR
// animal := CreateHuman ;
85529: LD_ADDR_VAR 0 12
85533: PUSH
85534: CALL_OW 44
85538: ST_TO_ADDR
// PlaceUnitInArea ( animal , nat_area , false ) ;
85539: LD_VAR 0 12
85543: PPUSH
85544: LD_VAR 0 8
85548: PPUSH
85549: LD_INT 0
85551: PPUSH
85552: CALL 87677 0 3
// end ;
85556: GO 85510
85558: POP
85559: POP
// if birds then
85560: LD_VAR 0 1
85564: IFFALSE 85631
// for i = 1 to birds do
85566: LD_ADDR_VAR 0 11
85570: PUSH
85571: DOUBLE
85572: LD_INT 1
85574: DEC
85575: ST_TO_ADDR
85576: LD_VAR 0 1
85580: PUSH
85581: FOR_TO
85582: IFFALSE 85629
// begin hc_class = 18 ;
85584: LD_ADDR_OWVAR 28
85588: PUSH
85589: LD_INT 18
85591: ST_TO_ADDR
// hc_gallery =  ;
85592: LD_ADDR_OWVAR 33
85596: PUSH
85597: LD_STRING 
85599: ST_TO_ADDR
// animal := CreateHuman ;
85600: LD_ADDR_VAR 0 12
85604: PUSH
85605: CALL_OW 44
85609: ST_TO_ADDR
// PlaceUnitInArea ( animal , nat_area , false ) ;
85610: LD_VAR 0 12
85614: PPUSH
85615: LD_VAR 0 8
85619: PPUSH
85620: LD_INT 0
85622: PPUSH
85623: CALL 87677 0 3
// end ;
85627: GO 85581
85629: POP
85630: POP
// if tigers then
85631: LD_VAR 0 2
85635: IFFALSE 85719
// for i = 1 to tigers do
85637: LD_ADDR_VAR 0 11
85641: PUSH
85642: DOUBLE
85643: LD_INT 1
85645: DEC
85646: ST_TO_ADDR
85647: LD_VAR 0 2
85651: PUSH
85652: FOR_TO
85653: IFFALSE 85717
// begin hc_class = class_tiger ;
85655: LD_ADDR_OWVAR 28
85659: PUSH
85660: LD_INT 14
85662: ST_TO_ADDR
// hc_gallery =  ;
85663: LD_ADDR_OWVAR 33
85667: PUSH
85668: LD_STRING 
85670: ST_TO_ADDR
// hc_agressivity = Rand ( - 7 , 7 ) ;
85671: LD_ADDR_OWVAR 35
85675: PUSH
85676: LD_INT 7
85678: NEG
85679: PPUSH
85680: LD_INT 7
85682: PPUSH
85683: CALL_OW 12
85687: ST_TO_ADDR
// animal := CreateHuman ;
85688: LD_ADDR_VAR 0 12
85692: PUSH
85693: CALL_OW 44
85697: ST_TO_ADDR
// PlaceUnitInArea ( animal , nat_area , false ) ;
85698: LD_VAR 0 12
85702: PPUSH
85703: LD_VAR 0 8
85707: PPUSH
85708: LD_INT 0
85710: PPUSH
85711: CALL 87677 0 3
// end ;
85715: GO 85652
85717: POP
85718: POP
// if apemans then
85719: LD_VAR 0 3
85723: IFFALSE 85846
// for i = 1 to apemans do
85725: LD_ADDR_VAR 0 11
85729: PUSH
85730: DOUBLE
85731: LD_INT 1
85733: DEC
85734: ST_TO_ADDR
85735: LD_VAR 0 3
85739: PUSH
85740: FOR_TO
85741: IFFALSE 85844
// begin hc_class = class_apeman ;
85743: LD_ADDR_OWVAR 28
85747: PUSH
85748: LD_INT 12
85750: ST_TO_ADDR
// hc_gallery =  ;
85751: LD_ADDR_OWVAR 33
85755: PUSH
85756: LD_STRING 
85758: ST_TO_ADDR
// hc_agressivity = rand ( - 2 , 2 ) ;
85759: LD_ADDR_OWVAR 35
85763: PUSH
85764: LD_INT 2
85766: NEG
85767: PPUSH
85768: LD_INT 2
85770: PPUSH
85771: CALL_OW 12
85775: ST_TO_ADDR
// hc_skills := [ rand ( 1 , 3 ) , rand ( 1 , 3 ) , 0 , 0 ] ;
85776: LD_ADDR_OWVAR 31
85780: PUSH
85781: LD_INT 1
85783: PPUSH
85784: LD_INT 3
85786: PPUSH
85787: CALL_OW 12
85791: PUSH
85792: LD_INT 1
85794: PPUSH
85795: LD_INT 3
85797: PPUSH
85798: CALL_OW 12
85802: PUSH
85803: LD_INT 0
85805: PUSH
85806: LD_INT 0
85808: PUSH
85809: EMPTY
85810: LIST
85811: LIST
85812: LIST
85813: LIST
85814: ST_TO_ADDR
// animal := CreateHuman ;
85815: LD_ADDR_VAR 0 12
85819: PUSH
85820: CALL_OW 44
85824: ST_TO_ADDR
// PlaceUnitInArea ( animal , nat_area , false ) ;
85825: LD_VAR 0 12
85829: PPUSH
85830: LD_VAR 0 8
85834: PPUSH
85835: LD_INT 0
85837: PPUSH
85838: CALL 87677 0 3
// end ;
85842: GO 85740
85844: POP
85845: POP
// if enchidnas then
85846: LD_VAR 0 4
85850: IFFALSE 85917
// for i = 1 to enchidnas do
85852: LD_ADDR_VAR 0 11
85856: PUSH
85857: DOUBLE
85858: LD_INT 1
85860: DEC
85861: ST_TO_ADDR
85862: LD_VAR 0 4
85866: PUSH
85867: FOR_TO
85868: IFFALSE 85915
// begin hc_class = 13 ;
85870: LD_ADDR_OWVAR 28
85874: PUSH
85875: LD_INT 13
85877: ST_TO_ADDR
// hc_gallery =  ;
85878: LD_ADDR_OWVAR 33
85882: PUSH
85883: LD_STRING 
85885: ST_TO_ADDR
// animal := CreateHuman ;
85886: LD_ADDR_VAR 0 12
85890: PUSH
85891: CALL_OW 44
85895: ST_TO_ADDR
// PlaceUnitInArea ( animal , nat_area , false ) ;
85896: LD_VAR 0 12
85900: PPUSH
85901: LD_VAR 0 8
85905: PPUSH
85906: LD_INT 0
85908: PPUSH
85909: CALL 87677 0 3
// end ;
85913: GO 85867
85915: POP
85916: POP
// if fishes then
85917: LD_VAR 0 7
85921: IFFALSE 85988
// for i = 1 to fishes do
85923: LD_ADDR_VAR 0 11
85927: PUSH
85928: DOUBLE
85929: LD_INT 1
85931: DEC
85932: ST_TO_ADDR
85933: LD_VAR 0 7
85937: PUSH
85938: FOR_TO
85939: IFFALSE 85986
// begin hc_class = 20 ;
85941: LD_ADDR_OWVAR 28
85945: PUSH
85946: LD_INT 20
85948: ST_TO_ADDR
// hc_gallery =  ;
85949: LD_ADDR_OWVAR 33
85953: PUSH
85954: LD_STRING 
85956: ST_TO_ADDR
// animal := CreateHuman ;
85957: LD_ADDR_VAR 0 12
85961: PUSH
85962: CALL_OW 44
85966: ST_TO_ADDR
// PlaceUnitInArea ( animal , wat_area , false ) ;
85967: LD_VAR 0 12
85971: PPUSH
85972: LD_VAR 0 9
85976: PPUSH
85977: LD_INT 0
85979: PPUSH
85980: CALL 87677 0 3
// end ;
85984: GO 85938
85986: POP
85987: POP
// end ;
85988: LD_VAR 0 10
85992: RET
// export function WantHeal ( sci , unit ) ; begin
85993: LD_INT 0
85995: PPUSH
// if GetTaskList ( sci ) > 0 then
85996: LD_VAR 0 1
86000: PPUSH
86001: CALL_OW 437
86005: PUSH
86006: LD_INT 0
86008: GREATER
86009: IFFALSE 86079
// begin if GetTaskList ( sci ) [ 1 ] [ 1 ] = l and GetTaskList ( sci ) [ 1 ] [ 4 ] = unit then
86011: LD_VAR 0 1
86015: PPUSH
86016: CALL_OW 437
86020: PUSH
86021: LD_INT 1
86023: ARRAY
86024: PUSH
86025: LD_INT 1
86027: ARRAY
86028: PUSH
86029: LD_STRING l
86031: EQUAL
86032: PUSH
86033: LD_VAR 0 1
86037: PPUSH
86038: CALL_OW 437
86042: PUSH
86043: LD_INT 1
86045: ARRAY
86046: PUSH
86047: LD_INT 4
86049: ARRAY
86050: PUSH
86051: LD_VAR 0 2
86055: EQUAL
86056: AND
86057: IFFALSE 86069
// result := true else
86059: LD_ADDR_VAR 0 3
86063: PUSH
86064: LD_INT 1
86066: ST_TO_ADDR
86067: GO 86077
// result := false ;
86069: LD_ADDR_VAR 0 3
86073: PUSH
86074: LD_INT 0
86076: ST_TO_ADDR
// end else
86077: GO 86087
// result := false ;
86079: LD_ADDR_VAR 0 3
86083: PUSH
86084: LD_INT 0
86086: ST_TO_ADDR
// end ;
86087: LD_VAR 0 3
86091: RET
// export function HealTarget ( sci ) ; begin
86092: LD_INT 0
86094: PPUSH
// if not sci then
86095: LD_VAR 0 1
86099: NOT
86100: IFFALSE 86104
// exit ;
86102: GO 86169
// result := 0 ;
86104: LD_ADDR_VAR 0 2
86108: PUSH
86109: LD_INT 0
86111: ST_TO_ADDR
// if GetTaskList ( sci ) then
86112: LD_VAR 0 1
86116: PPUSH
86117: CALL_OW 437
86121: IFFALSE 86169
// if GetTaskList ( sci ) [ 1 ] [ 1 ] = l then
86123: LD_VAR 0 1
86127: PPUSH
86128: CALL_OW 437
86132: PUSH
86133: LD_INT 1
86135: ARRAY
86136: PUSH
86137: LD_INT 1
86139: ARRAY
86140: PUSH
86141: LD_STRING l
86143: EQUAL
86144: IFFALSE 86169
// result := GetTaskList ( sci ) [ 1 ] [ 4 ] ;
86146: LD_ADDR_VAR 0 2
86150: PUSH
86151: LD_VAR 0 1
86155: PPUSH
86156: CALL_OW 437
86160: PUSH
86161: LD_INT 1
86163: ARRAY
86164: PUSH
86165: LD_INT 4
86167: ARRAY
86168: ST_TO_ADDR
// end ;
86169: LD_VAR 0 2
86173: RET
// export function _ScanBase ( base_units ) ; var i , t , tmp ; begin
86174: LD_INT 0
86176: PPUSH
86177: PPUSH
86178: PPUSH
86179: PPUSH
// if not base_units then
86180: LD_VAR 0 1
86184: NOT
86185: IFFALSE 86189
// exit ;
86187: GO 86276
// result := false ;
86189: LD_ADDR_VAR 0 2
86193: PUSH
86194: LD_INT 0
86196: ST_TO_ADDR
// tmp := UnitFilter ( base_units , [ f_type , unit_building ] ) ;
86197: LD_ADDR_VAR 0 5
86201: PUSH
86202: LD_VAR 0 1
86206: PPUSH
86207: LD_INT 21
86209: PUSH
86210: LD_INT 3
86212: PUSH
86213: EMPTY
86214: LIST
86215: LIST
86216: PPUSH
86217: CALL_OW 72
86221: ST_TO_ADDR
// if not tmp then
86222: LD_VAR 0 5
86226: NOT
86227: IFFALSE 86231
// exit ;
86229: GO 86276
// for i in tmp do
86231: LD_ADDR_VAR 0 3
86235: PUSH
86236: LD_VAR 0 5
86240: PUSH
86241: FOR_IN
86242: IFFALSE 86274
// begin result := EnemyInRange ( i , 22 ) ;
86244: LD_ADDR_VAR 0 2
86248: PUSH
86249: LD_VAR 0 3
86253: PPUSH
86254: LD_INT 22
86256: PPUSH
86257: CALL 84512 0 2
86261: ST_TO_ADDR
// if result then
86262: LD_VAR 0 2
86266: IFFALSE 86272
// exit ;
86268: POP
86269: POP
86270: GO 86276
// end ;
86272: GO 86241
86274: POP
86275: POP
// end ;
86276: LD_VAR 0 2
86280: RET
// export function FilterByTag ( units , tag ) ; var i ; begin
86281: LD_INT 0
86283: PPUSH
86284: PPUSH
// if not units then
86285: LD_VAR 0 1
86289: NOT
86290: IFFALSE 86294
// exit ;
86292: GO 86364
// result := [ ] ;
86294: LD_ADDR_VAR 0 3
86298: PUSH
86299: EMPTY
86300: ST_TO_ADDR
// for i in units do
86301: LD_ADDR_VAR 0 4
86305: PUSH
86306: LD_VAR 0 1
86310: PUSH
86311: FOR_IN
86312: IFFALSE 86362
// if GetTag ( i ) = tag then
86314: LD_VAR 0 4
86318: PPUSH
86319: CALL_OW 110
86323: PUSH
86324: LD_VAR 0 2
86328: EQUAL
86329: IFFALSE 86360
// result := Replace ( result , result + 1 , i ) ;
86331: LD_ADDR_VAR 0 3
86335: PUSH
86336: LD_VAR 0 3
86340: PPUSH
86341: LD_VAR 0 3
86345: PUSH
86346: LD_INT 1
86348: PLUS
86349: PPUSH
86350: LD_VAR 0 4
86354: PPUSH
86355: CALL_OW 1
86359: ST_TO_ADDR
86360: GO 86311
86362: POP
86363: POP
// end ;
86364: LD_VAR 0 3
86368: RET
// export function IsDriver ( un ) ; begin
86369: LD_INT 0
86371: PPUSH
// result := un in FilterAllUnits ( [ f_driving ] ) ;
86372: LD_ADDR_VAR 0 2
86376: PUSH
86377: LD_VAR 0 1
86381: PUSH
86382: LD_INT 55
86384: PUSH
86385: EMPTY
86386: LIST
86387: PPUSH
86388: CALL_OW 69
86392: IN
86393: ST_TO_ADDR
// end ;
86394: LD_VAR 0 2
86398: RET
// export function GetFacExtXYD ( x , y , d ) ; var list ; begin
86399: LD_INT 0
86401: PPUSH
86402: PPUSH
// list := [ ] ;
86403: LD_ADDR_VAR 0 5
86407: PUSH
86408: EMPTY
86409: ST_TO_ADDR
// case d of 0 :
86410: LD_VAR 0 3
86414: PUSH
86415: LD_INT 0
86417: DOUBLE
86418: EQUAL
86419: IFTRUE 86423
86421: GO 86556
86423: POP
// begin list := [ [ x - 4 , y - 4 , 2 ] , [ x - 3 , y , 1 ] , [ x + 4 , y , 4 ] , [ x + 3 , y + 3 , 5 ] , [ x , y + 4 , 0 ] ] ;
86424: LD_ADDR_VAR 0 5
86428: PUSH
86429: LD_VAR 0 1
86433: PUSH
86434: LD_INT 4
86436: MINUS
86437: PUSH
86438: LD_VAR 0 2
86442: PUSH
86443: LD_INT 4
86445: MINUS
86446: PUSH
86447: LD_INT 2
86449: PUSH
86450: EMPTY
86451: LIST
86452: LIST
86453: LIST
86454: PUSH
86455: LD_VAR 0 1
86459: PUSH
86460: LD_INT 3
86462: MINUS
86463: PUSH
86464: LD_VAR 0 2
86468: PUSH
86469: LD_INT 1
86471: PUSH
86472: EMPTY
86473: LIST
86474: LIST
86475: LIST
86476: PUSH
86477: LD_VAR 0 1
86481: PUSH
86482: LD_INT 4
86484: PLUS
86485: PUSH
86486: LD_VAR 0 2
86490: PUSH
86491: LD_INT 4
86493: PUSH
86494: EMPTY
86495: LIST
86496: LIST
86497: LIST
86498: PUSH
86499: LD_VAR 0 1
86503: PUSH
86504: LD_INT 3
86506: PLUS
86507: PUSH
86508: LD_VAR 0 2
86512: PUSH
86513: LD_INT 3
86515: PLUS
86516: PUSH
86517: LD_INT 5
86519: PUSH
86520: EMPTY
86521: LIST
86522: LIST
86523: LIST
86524: PUSH
86525: LD_VAR 0 1
86529: PUSH
86530: LD_VAR 0 2
86534: PUSH
86535: LD_INT 4
86537: PLUS
86538: PUSH
86539: LD_INT 0
86541: PUSH
86542: EMPTY
86543: LIST
86544: LIST
86545: LIST
86546: PUSH
86547: EMPTY
86548: LIST
86549: LIST
86550: LIST
86551: LIST
86552: LIST
86553: ST_TO_ADDR
// end ; 1 :
86554: GO 87254
86556: LD_INT 1
86558: DOUBLE
86559: EQUAL
86560: IFTRUE 86564
86562: GO 86697
86564: POP
// begin list := [ [ x , y - 4 , 3 ] , [ x - 3 , y - 3 , 2 ] , [ x - 4 , y , 1 ] , [ x , y + 3 , 0 ] , [ x + 4 , y + 4 , 5 ] ] ;
86565: LD_ADDR_VAR 0 5
86569: PUSH
86570: LD_VAR 0 1
86574: PUSH
86575: LD_VAR 0 2
86579: PUSH
86580: LD_INT 4
86582: MINUS
86583: PUSH
86584: LD_INT 3
86586: PUSH
86587: EMPTY
86588: LIST
86589: LIST
86590: LIST
86591: PUSH
86592: LD_VAR 0 1
86596: PUSH
86597: LD_INT 3
86599: MINUS
86600: PUSH
86601: LD_VAR 0 2
86605: PUSH
86606: LD_INT 3
86608: MINUS
86609: PUSH
86610: LD_INT 2
86612: PUSH
86613: EMPTY
86614: LIST
86615: LIST
86616: LIST
86617: PUSH
86618: LD_VAR 0 1
86622: PUSH
86623: LD_INT 4
86625: MINUS
86626: PUSH
86627: LD_VAR 0 2
86631: PUSH
86632: LD_INT 1
86634: PUSH
86635: EMPTY
86636: LIST
86637: LIST
86638: LIST
86639: PUSH
86640: LD_VAR 0 1
86644: PUSH
86645: LD_VAR 0 2
86649: PUSH
86650: LD_INT 3
86652: PLUS
86653: PUSH
86654: LD_INT 0
86656: PUSH
86657: EMPTY
86658: LIST
86659: LIST
86660: LIST
86661: PUSH
86662: LD_VAR 0 1
86666: PUSH
86667: LD_INT 4
86669: PLUS
86670: PUSH
86671: LD_VAR 0 2
86675: PUSH
86676: LD_INT 4
86678: PLUS
86679: PUSH
86680: LD_INT 5
86682: PUSH
86683: EMPTY
86684: LIST
86685: LIST
86686: LIST
86687: PUSH
86688: EMPTY
86689: LIST
86690: LIST
86691: LIST
86692: LIST
86693: LIST
86694: ST_TO_ADDR
// end ; 2 :
86695: GO 87254
86697: LD_INT 2
86699: DOUBLE
86700: EQUAL
86701: IFTRUE 86705
86703: GO 86834
86705: POP
// begin list := [ [ x , y - 3 , 3 ] , [ x + 4 , y , 4 ] , [ x , y + 4 , 0 ] , [ x - 3 , y , 1 ] , [ x - 4 , y - 4 , 2 ] ] ;
86706: LD_ADDR_VAR 0 5
86710: PUSH
86711: LD_VAR 0 1
86715: PUSH
86716: LD_VAR 0 2
86720: PUSH
86721: LD_INT 3
86723: MINUS
86724: PUSH
86725: LD_INT 3
86727: PUSH
86728: EMPTY
86729: LIST
86730: LIST
86731: LIST
86732: PUSH
86733: LD_VAR 0 1
86737: PUSH
86738: LD_INT 4
86740: PLUS
86741: PUSH
86742: LD_VAR 0 2
86746: PUSH
86747: LD_INT 4
86749: PUSH
86750: EMPTY
86751: LIST
86752: LIST
86753: LIST
86754: PUSH
86755: LD_VAR 0 1
86759: PUSH
86760: LD_VAR 0 2
86764: PUSH
86765: LD_INT 4
86767: PLUS
86768: PUSH
86769: LD_INT 0
86771: PUSH
86772: EMPTY
86773: LIST
86774: LIST
86775: LIST
86776: PUSH
86777: LD_VAR 0 1
86781: PUSH
86782: LD_INT 3
86784: MINUS
86785: PUSH
86786: LD_VAR 0 2
86790: PUSH
86791: LD_INT 1
86793: PUSH
86794: EMPTY
86795: LIST
86796: LIST
86797: LIST
86798: PUSH
86799: LD_VAR 0 1
86803: PUSH
86804: LD_INT 4
86806: MINUS
86807: PUSH
86808: LD_VAR 0 2
86812: PUSH
86813: LD_INT 4
86815: MINUS
86816: PUSH
86817: LD_INT 2
86819: PUSH
86820: EMPTY
86821: LIST
86822: LIST
86823: LIST
86824: PUSH
86825: EMPTY
86826: LIST
86827: LIST
86828: LIST
86829: LIST
86830: LIST
86831: ST_TO_ADDR
// end ; 3 :
86832: GO 87254
86834: LD_INT 3
86836: DOUBLE
86837: EQUAL
86838: IFTRUE 86842
86840: GO 86975
86842: POP
// begin list := [ [ x + 3 , y , 4 ] , [ x + 4 , y + 4 , 5 ] , [ x - 4 , y , 1 ] , [ x , y - 4 , 3 ] , [ x - 3 , y - 3 , 2 ] ] ;
86843: LD_ADDR_VAR 0 5
86847: PUSH
86848: LD_VAR 0 1
86852: PUSH
86853: LD_INT 3
86855: PLUS
86856: PUSH
86857: LD_VAR 0 2
86861: PUSH
86862: LD_INT 4
86864: PUSH
86865: EMPTY
86866: LIST
86867: LIST
86868: LIST
86869: PUSH
86870: LD_VAR 0 1
86874: PUSH
86875: LD_INT 4
86877: PLUS
86878: PUSH
86879: LD_VAR 0 2
86883: PUSH
86884: LD_INT 4
86886: PLUS
86887: PUSH
86888: LD_INT 5
86890: PUSH
86891: EMPTY
86892: LIST
86893: LIST
86894: LIST
86895: PUSH
86896: LD_VAR 0 1
86900: PUSH
86901: LD_INT 4
86903: MINUS
86904: PUSH
86905: LD_VAR 0 2
86909: PUSH
86910: LD_INT 1
86912: PUSH
86913: EMPTY
86914: LIST
86915: LIST
86916: LIST
86917: PUSH
86918: LD_VAR 0 1
86922: PUSH
86923: LD_VAR 0 2
86927: PUSH
86928: LD_INT 4
86930: MINUS
86931: PUSH
86932: LD_INT 3
86934: PUSH
86935: EMPTY
86936: LIST
86937: LIST
86938: LIST
86939: PUSH
86940: LD_VAR 0 1
86944: PUSH
86945: LD_INT 3
86947: MINUS
86948: PUSH
86949: LD_VAR 0 2
86953: PUSH
86954: LD_INT 3
86956: MINUS
86957: PUSH
86958: LD_INT 2
86960: PUSH
86961: EMPTY
86962: LIST
86963: LIST
86964: LIST
86965: PUSH
86966: EMPTY
86967: LIST
86968: LIST
86969: LIST
86970: LIST
86971: LIST
86972: ST_TO_ADDR
// end ; 4 :
86973: GO 87254
86975: LD_INT 4
86977: DOUBLE
86978: EQUAL
86979: IFTRUE 86983
86981: GO 87116
86983: POP
// begin list := [ [ x , y + 4 , 0 ] , [ x + 3 , y + 3 , 5 ] , [ x + 4 , y , 4 ] , [ x , y - 3 , 3 ] , [ x - 4 , y - 4 , 2 ] ] ;
86984: LD_ADDR_VAR 0 5
86988: PUSH
86989: LD_VAR 0 1
86993: PUSH
86994: LD_VAR 0 2
86998: PUSH
86999: LD_INT 4
87001: PLUS
87002: PUSH
87003: LD_INT 0
87005: PUSH
87006: EMPTY
87007: LIST
87008: LIST
87009: LIST
87010: PUSH
87011: LD_VAR 0 1
87015: PUSH
87016: LD_INT 3
87018: PLUS
87019: PUSH
87020: LD_VAR 0 2
87024: PUSH
87025: LD_INT 3
87027: PLUS
87028: PUSH
87029: LD_INT 5
87031: PUSH
87032: EMPTY
87033: LIST
87034: LIST
87035: LIST
87036: PUSH
87037: LD_VAR 0 1
87041: PUSH
87042: LD_INT 4
87044: PLUS
87045: PUSH
87046: LD_VAR 0 2
87050: PUSH
87051: LD_INT 4
87053: PUSH
87054: EMPTY
87055: LIST
87056: LIST
87057: LIST
87058: PUSH
87059: LD_VAR 0 1
87063: PUSH
87064: LD_VAR 0 2
87068: PUSH
87069: LD_INT 3
87071: MINUS
87072: PUSH
87073: LD_INT 3
87075: PUSH
87076: EMPTY
87077: LIST
87078: LIST
87079: LIST
87080: PUSH
87081: LD_VAR 0 1
87085: PUSH
87086: LD_INT 4
87088: MINUS
87089: PUSH
87090: LD_VAR 0 2
87094: PUSH
87095: LD_INT 4
87097: MINUS
87098: PUSH
87099: LD_INT 2
87101: PUSH
87102: EMPTY
87103: LIST
87104: LIST
87105: LIST
87106: PUSH
87107: EMPTY
87108: LIST
87109: LIST
87110: LIST
87111: LIST
87112: LIST
87113: ST_TO_ADDR
// end ; 5 :
87114: GO 87254
87116: LD_INT 5
87118: DOUBLE
87119: EQUAL
87120: IFTRUE 87124
87122: GO 87253
87124: POP
// begin list := [ [ x - 4 , y , 1 ] , [ x , y - 4 , 3 ] , [ x + 4 , y + 4 , 5 ] , [ x + 3 , y , 4 ] , [ x , y + 3 , 0 ] ] ;
87125: LD_ADDR_VAR 0 5
87129: PUSH
87130: LD_VAR 0 1
87134: PUSH
87135: LD_INT 4
87137: MINUS
87138: PUSH
87139: LD_VAR 0 2
87143: PUSH
87144: LD_INT 1
87146: PUSH
87147: EMPTY
87148: LIST
87149: LIST
87150: LIST
87151: PUSH
87152: LD_VAR 0 1
87156: PUSH
87157: LD_VAR 0 2
87161: PUSH
87162: LD_INT 4
87164: MINUS
87165: PUSH
87166: LD_INT 3
87168: PUSH
87169: EMPTY
87170: LIST
87171: LIST
87172: LIST
87173: PUSH
87174: LD_VAR 0 1
87178: PUSH
87179: LD_INT 4
87181: PLUS
87182: PUSH
87183: LD_VAR 0 2
87187: PUSH
87188: LD_INT 4
87190: PLUS
87191: PUSH
87192: LD_INT 5
87194: PUSH
87195: EMPTY
87196: LIST
87197: LIST
87198: LIST
87199: PUSH
87200: LD_VAR 0 1
87204: PUSH
87205: LD_INT 3
87207: PLUS
87208: PUSH
87209: LD_VAR 0 2
87213: PUSH
87214: LD_INT 4
87216: PUSH
87217: EMPTY
87218: LIST
87219: LIST
87220: LIST
87221: PUSH
87222: LD_VAR 0 1
87226: PUSH
87227: LD_VAR 0 2
87231: PUSH
87232: LD_INT 3
87234: PLUS
87235: PUSH
87236: LD_INT 0
87238: PUSH
87239: EMPTY
87240: LIST
87241: LIST
87242: LIST
87243: PUSH
87244: EMPTY
87245: LIST
87246: LIST
87247: LIST
87248: LIST
87249: LIST
87250: ST_TO_ADDR
// end ; end ;
87251: GO 87254
87253: POP
// result := list ;
87254: LD_ADDR_VAR 0 4
87258: PUSH
87259: LD_VAR 0 5
87263: ST_TO_ADDR
// end ;
87264: LD_VAR 0 4
87268: RET
// export function SortBySkill ( units , class ) ; var i , tmp ; begin
87269: LD_INT 0
87271: PPUSH
87272: PPUSH
87273: PPUSH
// if not units or not class in [ 1 , 2 , 3 , 4 ] then
87274: LD_VAR 0 1
87278: NOT
87279: PUSH
87280: LD_VAR 0 2
87284: PUSH
87285: LD_INT 1
87287: PUSH
87288: LD_INT 2
87290: PUSH
87291: LD_INT 3
87293: PUSH
87294: LD_INT 4
87296: PUSH
87297: EMPTY
87298: LIST
87299: LIST
87300: LIST
87301: LIST
87302: IN
87303: NOT
87304: OR
87305: IFFALSE 87309
// exit ;
87307: GO 87401
// tmp := [ ] ;
87309: LD_ADDR_VAR 0 5
87313: PUSH
87314: EMPTY
87315: ST_TO_ADDR
// for i in units do
87316: LD_ADDR_VAR 0 4
87320: PUSH
87321: LD_VAR 0 1
87325: PUSH
87326: FOR_IN
87327: IFFALSE 87370
// tmp := Insert ( tmp , tmp + 1 , GetSkill ( i , class ) ) ;
87329: LD_ADDR_VAR 0 5
87333: PUSH
87334: LD_VAR 0 5
87338: PPUSH
87339: LD_VAR 0 5
87343: PUSH
87344: LD_INT 1
87346: PLUS
87347: PPUSH
87348: LD_VAR 0 4
87352: PPUSH
87353: LD_VAR 0 2
87357: PPUSH
87358: CALL_OW 259
87362: PPUSH
87363: CALL_OW 2
87367: ST_TO_ADDR
87368: GO 87326
87370: POP
87371: POP
// if not tmp then
87372: LD_VAR 0 5
87376: NOT
87377: IFFALSE 87381
// exit ;
87379: GO 87401
// result := SortListByListDesc ( units , tmp ) ;
87381: LD_ADDR_VAR 0 3
87385: PUSH
87386: LD_VAR 0 1
87390: PPUSH
87391: LD_VAR 0 5
87395: PPUSH
87396: CALL_OW 77
87400: ST_TO_ADDR
// end ;
87401: LD_VAR 0 3
87405: RET
// export function UnitGoingToBuilding ( unit , building ) ; var x , y ; begin
87406: LD_INT 0
87408: PPUSH
87409: PPUSH
87410: PPUSH
// result := false ;
87411: LD_ADDR_VAR 0 3
87415: PUSH
87416: LD_INT 0
87418: ST_TO_ADDR
// x := GetX ( building ) ;
87419: LD_ADDR_VAR 0 4
87423: PUSH
87424: LD_VAR 0 2
87428: PPUSH
87429: CALL_OW 250
87433: ST_TO_ADDR
// y := GetY ( building ) ;
87434: LD_ADDR_VAR 0 5
87438: PUSH
87439: LD_VAR 0 2
87443: PPUSH
87444: CALL_OW 251
87448: ST_TO_ADDR
// if not building or not x or not y then
87449: LD_VAR 0 2
87453: NOT
87454: PUSH
87455: LD_VAR 0 4
87459: NOT
87460: OR
87461: PUSH
87462: LD_VAR 0 5
87466: NOT
87467: OR
87468: IFFALSE 87472
// exit ;
87470: GO 87564
// if GetTaskList ( unit ) then
87472: LD_VAR 0 1
87476: PPUSH
87477: CALL_OW 437
87481: IFFALSE 87564
// begin if e = GetTaskList ( unit ) [ 1 ] [ 1 ] and x = GetTaskList ( unit ) [ 1 ] [ 2 ] and y = GetTaskList ( unit ) [ 1 ] [ 3 ] then
87483: LD_STRING e
87485: PUSH
87486: LD_VAR 0 1
87490: PPUSH
87491: CALL_OW 437
87495: PUSH
87496: LD_INT 1
87498: ARRAY
87499: PUSH
87500: LD_INT 1
87502: ARRAY
87503: EQUAL
87504: PUSH
87505: LD_VAR 0 4
87509: PUSH
87510: LD_VAR 0 1
87514: PPUSH
87515: CALL_OW 437
87519: PUSH
87520: LD_INT 1
87522: ARRAY
87523: PUSH
87524: LD_INT 2
87526: ARRAY
87527: EQUAL
87528: AND
87529: PUSH
87530: LD_VAR 0 5
87534: PUSH
87535: LD_VAR 0 1
87539: PPUSH
87540: CALL_OW 437
87544: PUSH
87545: LD_INT 1
87547: ARRAY
87548: PUSH
87549: LD_INT 3
87551: ARRAY
87552: EQUAL
87553: AND
87554: IFFALSE 87564
// result := true end ;
87556: LD_ADDR_VAR 0 3
87560: PUSH
87561: LD_INT 1
87563: ST_TO_ADDR
// end ;
87564: LD_VAR 0 3
87568: RET
// export function UnitGoingToXY ( unit , x , y ) ; begin
87569: LD_INT 0
87571: PPUSH
// result := false ;
87572: LD_ADDR_VAR 0 4
87576: PUSH
87577: LD_INT 0
87579: ST_TO_ADDR
// if GetTaskList ( unit ) then
87580: LD_VAR 0 1
87584: PPUSH
87585: CALL_OW 437
87589: IFFALSE 87672
// begin if M = GetTaskList ( unit ) [ 1 ] [ 1 ] and x = GetTaskList ( unit ) [ 1 ] [ 2 ] and y = GetTaskList ( unit ) [ 1 ] [ 3 ] then
87591: LD_STRING M
87593: PUSH
87594: LD_VAR 0 1
87598: PPUSH
87599: CALL_OW 437
87603: PUSH
87604: LD_INT 1
87606: ARRAY
87607: PUSH
87608: LD_INT 1
87610: ARRAY
87611: EQUAL
87612: PUSH
87613: LD_VAR 0 2
87617: PUSH
87618: LD_VAR 0 1
87622: PPUSH
87623: CALL_OW 437
87627: PUSH
87628: LD_INT 1
87630: ARRAY
87631: PUSH
87632: LD_INT 2
87634: ARRAY
87635: EQUAL
87636: AND
87637: PUSH
87638: LD_VAR 0 3
87642: PUSH
87643: LD_VAR 0 1
87647: PPUSH
87648: CALL_OW 437
87652: PUSH
87653: LD_INT 1
87655: ARRAY
87656: PUSH
87657: LD_INT 3
87659: ARRAY
87660: EQUAL
87661: AND
87662: IFFALSE 87672
// result := true ;
87664: LD_ADDR_VAR 0 4
87668: PUSH
87669: LD_INT 1
87671: ST_TO_ADDR
// end ; end ;
87672: LD_VAR 0 4
87676: RET
// export function PlaceUnitInArea ( unit , area , mode ) ; var i , tmp , hex ; begin
87677: LD_INT 0
87679: PPUSH
87680: PPUSH
87681: PPUSH
87682: PPUSH
// if not unit or not area then
87683: LD_VAR 0 1
87687: NOT
87688: PUSH
87689: LD_VAR 0 2
87693: NOT
87694: OR
87695: IFFALSE 87699
// exit ;
87697: GO 87863
// tmp := AreaToList ( area , i ) ;
87699: LD_ADDR_VAR 0 6
87703: PUSH
87704: LD_VAR 0 2
87708: PPUSH
87709: LD_VAR 0 5
87713: PPUSH
87714: CALL_OW 517
87718: ST_TO_ADDR
// for i = 1 to tmp [ 1 ] do
87719: LD_ADDR_VAR 0 5
87723: PUSH
87724: DOUBLE
87725: LD_INT 1
87727: DEC
87728: ST_TO_ADDR
87729: LD_VAR 0 6
87733: PUSH
87734: LD_INT 1
87736: ARRAY
87737: PUSH
87738: FOR_TO
87739: IFFALSE 87861
// begin hex := [ tmp [ 1 ] [ i ] , tmp [ 2 ] [ i ] ] ;
87741: LD_ADDR_VAR 0 7
87745: PUSH
87746: LD_VAR 0 6
87750: PUSH
87751: LD_INT 1
87753: ARRAY
87754: PUSH
87755: LD_VAR 0 5
87759: ARRAY
87760: PUSH
87761: LD_VAR 0 6
87765: PUSH
87766: LD_INT 2
87768: ARRAY
87769: PUSH
87770: LD_VAR 0 5
87774: ARRAY
87775: PUSH
87776: EMPTY
87777: LIST
87778: LIST
87779: ST_TO_ADDR
// if HexInfo ( hex [ 1 ] , hex [ 2 ] ) = 0 then
87780: LD_VAR 0 7
87784: PUSH
87785: LD_INT 1
87787: ARRAY
87788: PPUSH
87789: LD_VAR 0 7
87793: PUSH
87794: LD_INT 2
87796: ARRAY
87797: PPUSH
87798: CALL_OW 428
87802: PUSH
87803: LD_INT 0
87805: EQUAL
87806: IFFALSE 87859
// begin PlaceUnitXY ( unit , hex [ 1 ] , hex [ 2 ] , mode ) ;
87808: LD_VAR 0 1
87812: PPUSH
87813: LD_VAR 0 7
87817: PUSH
87818: LD_INT 1
87820: ARRAY
87821: PPUSH
87822: LD_VAR 0 7
87826: PUSH
87827: LD_INT 2
87829: ARRAY
87830: PPUSH
87831: LD_VAR 0 3
87835: PPUSH
87836: CALL_OW 48
// result := IsPlaced ( unit ) ;
87840: LD_ADDR_VAR 0 4
87844: PUSH
87845: LD_VAR 0 1
87849: PPUSH
87850: CALL_OW 305
87854: ST_TO_ADDR
// exit ;
87855: POP
87856: POP
87857: GO 87863
// end ; end ;
87859: GO 87738
87861: POP
87862: POP
// end ;
87863: LD_VAR 0 4
87867: RET
// export function BuildingsListDump ( side ) ; var i , tmp ; begin
87868: LD_INT 0
87870: PPUSH
87871: PPUSH
87872: PPUSH
// if not side or side > 8 then
87873: LD_VAR 0 1
87877: NOT
87878: PUSH
87879: LD_VAR 0 1
87883: PUSH
87884: LD_INT 8
87886: GREATER
87887: OR
87888: IFFALSE 87892
// exit ;
87890: GO 88079
// tmp := FilterAllUnits ( [ [ f_side , side ] , [ f_type , unit_building ] ] ) ;
87892: LD_ADDR_VAR 0 4
87896: PUSH
87897: LD_INT 22
87899: PUSH
87900: LD_VAR 0 1
87904: PUSH
87905: EMPTY
87906: LIST
87907: LIST
87908: PUSH
87909: LD_INT 21
87911: PUSH
87912: LD_INT 3
87914: PUSH
87915: EMPTY
87916: LIST
87917: LIST
87918: PUSH
87919: EMPTY
87920: LIST
87921: LIST
87922: PPUSH
87923: CALL_OW 69
87927: ST_TO_ADDR
// if not tmp then
87928: LD_VAR 0 4
87932: NOT
87933: IFFALSE 87937
// exit ;
87935: GO 88079
// enable_addtolog := true ;
87937: LD_ADDR_OWVAR 81
87941: PUSH
87942: LD_INT 1
87944: ST_TO_ADDR
// AddToLog ( [ ) ;
87945: LD_STRING [
87947: PPUSH
87948: CALL_OW 561
// for i in tmp do
87952: LD_ADDR_VAR 0 3
87956: PUSH
87957: LD_VAR 0 4
87961: PUSH
87962: FOR_IN
87963: IFFALSE 88070
// begin AddToLog ( [ & GetBType ( i ) & ,  & GetX ( i ) & ,  & GetY ( i ) & ,  & GetDir ( i ) & ,  & GetLabKind ( i , 1 ) & ,  & GetLabKind ( i , 2 ) & ], ) ;
87965: LD_STRING [
87967: PUSH
87968: LD_VAR 0 3
87972: PPUSH
87973: CALL_OW 266
87977: STR
87978: PUSH
87979: LD_STRING , 
87981: STR
87982: PUSH
87983: LD_VAR 0 3
87987: PPUSH
87988: CALL_OW 250
87992: STR
87993: PUSH
87994: LD_STRING , 
87996: STR
87997: PUSH
87998: LD_VAR 0 3
88002: PPUSH
88003: CALL_OW 251
88007: STR
88008: PUSH
88009: LD_STRING , 
88011: STR
88012: PUSH
88013: LD_VAR 0 3
88017: PPUSH
88018: CALL_OW 254
88022: STR
88023: PUSH
88024: LD_STRING , 
88026: STR
88027: PUSH
88028: LD_VAR 0 3
88032: PPUSH
88033: LD_INT 1
88035: PPUSH
88036: CALL_OW 268
88040: STR
88041: PUSH
88042: LD_STRING , 
88044: STR
88045: PUSH
88046: LD_VAR 0 3
88050: PPUSH
88051: LD_INT 2
88053: PPUSH
88054: CALL_OW 268
88058: STR
88059: PUSH
88060: LD_STRING ],
88062: STR
88063: PPUSH
88064: CALL_OW 561
// end ;
88068: GO 87962
88070: POP
88071: POP
// AddToLog ( ]; ) ;
88072: LD_STRING ];
88074: PPUSH
88075: CALL_OW 561
// end ;
88079: LD_VAR 0 2
88083: RET
// export function Crates ( area , rate , min , max ) ; var i , r , time , amount ; begin
88084: LD_INT 0
88086: PPUSH
88087: PPUSH
88088: PPUSH
88089: PPUSH
88090: PPUSH
// if not area or not rate or not max then
88091: LD_VAR 0 1
88095: NOT
88096: PUSH
88097: LD_VAR 0 2
88101: NOT
88102: OR
88103: PUSH
88104: LD_VAR 0 4
88108: NOT
88109: OR
88110: IFFALSE 88114
// exit ;
88112: GO 88306
// while 1 do
88114: LD_INT 1
88116: IFFALSE 88306
// begin amount := GetResourceArea ( area , mat_cans ) * 10 ;
88118: LD_ADDR_VAR 0 9
88122: PUSH
88123: LD_VAR 0 1
88127: PPUSH
88128: LD_INT 1
88130: PPUSH
88131: CALL_OW 287
88135: PUSH
88136: LD_INT 10
88138: MUL
88139: ST_TO_ADDR
// r := rate / 10 ;
88140: LD_ADDR_VAR 0 7
88144: PUSH
88145: LD_VAR 0 2
88149: PUSH
88150: LD_INT 10
88152: DIVREAL
88153: ST_TO_ADDR
// time := 1 1$00 ;
88154: LD_ADDR_VAR 0 8
88158: PUSH
88159: LD_INT 2100
88161: ST_TO_ADDR
// if amount < min then
88162: LD_VAR 0 9
88166: PUSH
88167: LD_VAR 0 3
88171: LESS
88172: IFFALSE 88190
// r := r * 2 else
88174: LD_ADDR_VAR 0 7
88178: PUSH
88179: LD_VAR 0 7
88183: PUSH
88184: LD_INT 2
88186: MUL
88187: ST_TO_ADDR
88188: GO 88216
// if amount > max then
88190: LD_VAR 0 9
88194: PUSH
88195: LD_VAR 0 4
88199: GREATER
88200: IFFALSE 88216
// r := r / 2 ;
88202: LD_ADDR_VAR 0 7
88206: PUSH
88207: LD_VAR 0 7
88211: PUSH
88212: LD_INT 2
88214: DIVREAL
88215: ST_TO_ADDR
// time := time / r ;
88216: LD_ADDR_VAR 0 8
88220: PUSH
88221: LD_VAR 0 8
88225: PUSH
88226: LD_VAR 0 7
88230: DIVREAL
88231: ST_TO_ADDR
// if time < 0 then
88232: LD_VAR 0 8
88236: PUSH
88237: LD_INT 0
88239: LESS
88240: IFFALSE 88257
// time := time * - 1 ;
88242: LD_ADDR_VAR 0 8
88246: PUSH
88247: LD_VAR 0 8
88251: PUSH
88252: LD_INT 1
88254: NEG
88255: MUL
88256: ST_TO_ADDR
// wait ( time ) ;
88257: LD_VAR 0 8
88261: PPUSH
88262: CALL_OW 67
// wait ( rand ( 0 0$01 , 0 0$25 ) ) ;
88266: LD_INT 35
88268: PPUSH
88269: LD_INT 875
88271: PPUSH
88272: CALL_OW 12
88276: PPUSH
88277: CALL_OW 67
// CreateCratesArea ( rand ( 1 , 5 ) , area , true ) ;
88281: LD_INT 1
88283: PPUSH
88284: LD_INT 5
88286: PPUSH
88287: CALL_OW 12
88291: PPUSH
88292: LD_VAR 0 1
88296: PPUSH
88297: LD_INT 1
88299: PPUSH
88300: CALL_OW 55
// end ;
88304: GO 88114
// end ;
88306: LD_VAR 0 5
88310: RET
// export function UpgradeTurretsWeapon ( turrets , factories ) ; var i , j , k , nat , weapon , weapons , list ; begin
88311: LD_INT 0
88313: PPUSH
88314: PPUSH
88315: PPUSH
88316: PPUSH
88317: PPUSH
88318: PPUSH
88319: PPUSH
88320: PPUSH
// if not turrets or not factories then
88321: LD_VAR 0 1
88325: NOT
88326: PUSH
88327: LD_VAR 0 2
88331: NOT
88332: OR
88333: IFFALSE 88337
// exit ;
88335: GO 88644
// list := [ [ [ us_double_gun , us_heavy_gun ] , [ us_machine_gun , us_gatling_gun ] , [ us_light_gun , us_double_gun ] ] , [ [ ar_double_machine_gun , ar_gatling_gun ] , [ ar_light_gun , ar_gun ] ] , [ [ ru_heavy_machine_gun , ru_gatling_gun ] , [ ru_gun , ru_heavy_gun ] , [ ru_rocket_launcher , ru_rocket ] ] , ] ;
88337: LD_ADDR_VAR 0 10
88341: PUSH
88342: LD_INT 5
88344: PUSH
88345: LD_INT 6
88347: PUSH
88348: EMPTY
88349: LIST
88350: LIST
88351: PUSH
88352: LD_INT 2
88354: PUSH
88355: LD_INT 4
88357: PUSH
88358: EMPTY
88359: LIST
88360: LIST
88361: PUSH
88362: LD_INT 3
88364: PUSH
88365: LD_INT 5
88367: PUSH
88368: EMPTY
88369: LIST
88370: LIST
88371: PUSH
88372: EMPTY
88373: LIST
88374: LIST
88375: LIST
88376: PUSH
88377: LD_INT 24
88379: PUSH
88380: LD_INT 25
88382: PUSH
88383: EMPTY
88384: LIST
88385: LIST
88386: PUSH
88387: LD_INT 23
88389: PUSH
88390: LD_INT 27
88392: PUSH
88393: EMPTY
88394: LIST
88395: LIST
88396: PUSH
88397: EMPTY
88398: LIST
88399: LIST
88400: PUSH
88401: LD_INT 42
88403: PUSH
88404: LD_INT 43
88406: PUSH
88407: EMPTY
88408: LIST
88409: LIST
88410: PUSH
88411: LD_INT 44
88413: PUSH
88414: LD_INT 46
88416: PUSH
88417: EMPTY
88418: LIST
88419: LIST
88420: PUSH
88421: LD_INT 45
88423: PUSH
88424: LD_INT 47
88426: PUSH
88427: EMPTY
88428: LIST
88429: LIST
88430: PUSH
88431: EMPTY
88432: LIST
88433: LIST
88434: LIST
88435: PUSH
88436: EMPTY
88437: LIST
88438: LIST
88439: LIST
88440: ST_TO_ADDR
// result := [ ] ;
88441: LD_ADDR_VAR 0 3
88445: PUSH
88446: EMPTY
88447: ST_TO_ADDR
// for i in turrets do
88448: LD_ADDR_VAR 0 4
88452: PUSH
88453: LD_VAR 0 1
88457: PUSH
88458: FOR_IN
88459: IFFALSE 88642
// begin nat := GetNation ( i ) ;
88461: LD_ADDR_VAR 0 7
88465: PUSH
88466: LD_VAR 0 4
88470: PPUSH
88471: CALL_OW 248
88475: ST_TO_ADDR
// weapon := 0 ;
88476: LD_ADDR_VAR 0 8
88480: PUSH
88481: LD_INT 0
88483: ST_TO_ADDR
// if not nat then
88484: LD_VAR 0 7
88488: NOT
88489: IFFALSE 88493
// continue ;
88491: GO 88458
// for j in list [ nat ] do
88493: LD_ADDR_VAR 0 5
88497: PUSH
88498: LD_VAR 0 10
88502: PUSH
88503: LD_VAR 0 7
88507: ARRAY
88508: PUSH
88509: FOR_IN
88510: IFFALSE 88551
// if GetBWeapon ( i ) = j [ 1 ] then
88512: LD_VAR 0 4
88516: PPUSH
88517: CALL_OW 269
88521: PUSH
88522: LD_VAR 0 5
88526: PUSH
88527: LD_INT 1
88529: ARRAY
88530: EQUAL
88531: IFFALSE 88549
// begin weapon := j [ 2 ] ;
88533: LD_ADDR_VAR 0 8
88537: PUSH
88538: LD_VAR 0 5
88542: PUSH
88543: LD_INT 2
88545: ARRAY
88546: ST_TO_ADDR
// break ;
88547: GO 88551
// end ;
88549: GO 88509
88551: POP
88552: POP
// if not weapon then
88553: LD_VAR 0 8
88557: NOT
88558: IFFALSE 88562
// continue ;
88560: GO 88458
// for k in factories do
88562: LD_ADDR_VAR 0 6
88566: PUSH
88567: LD_VAR 0 2
88571: PUSH
88572: FOR_IN
88573: IFFALSE 88638
// begin weapons := AvailableWeaponList ( k ) ;
88575: LD_ADDR_VAR 0 9
88579: PUSH
88580: LD_VAR 0 6
88584: PPUSH
88585: CALL_OW 478
88589: ST_TO_ADDR
// if not weapons then
88590: LD_VAR 0 9
88594: NOT
88595: IFFALSE 88599
// continue ;
88597: GO 88572
// if weapon in weapons then
88599: LD_VAR 0 8
88603: PUSH
88604: LD_VAR 0 9
88608: IN
88609: IFFALSE 88636
// begin result := [ i , weapon ] ;
88611: LD_ADDR_VAR 0 3
88615: PUSH
88616: LD_VAR 0 4
88620: PUSH
88621: LD_VAR 0 8
88625: PUSH
88626: EMPTY
88627: LIST
88628: LIST
88629: ST_TO_ADDR
// exit ;
88630: POP
88631: POP
88632: POP
88633: POP
88634: GO 88644
// end ; end ;
88636: GO 88572
88638: POP
88639: POP
// end ;
88640: GO 88458
88642: POP
88643: POP
// end ;
88644: LD_VAR 0 3
88648: RET
// export function RevealMapOnXY ( x , y , side , range ) ; begin
88649: LD_INT 0
88651: PPUSH
// if not side or side > 8 then
88652: LD_VAR 0 3
88656: NOT
88657: PUSH
88658: LD_VAR 0 3
88662: PUSH
88663: LD_INT 8
88665: GREATER
88666: OR
88667: IFFALSE 88671
// exit ;
88669: GO 88730
// if not range then
88671: LD_VAR 0 4
88675: NOT
88676: IFFALSE 88687
// range := - 12 ;
88678: LD_ADDR_VAR 0 4
88682: PUSH
88683: LD_INT 12
88685: NEG
88686: ST_TO_ADDR
// PlaceSeeing ( x , y , side , range ) ;
88687: LD_VAR 0 1
88691: PPUSH
88692: LD_VAR 0 2
88696: PPUSH
88697: LD_VAR 0 3
88701: PPUSH
88702: LD_VAR 0 4
88706: PPUSH
88707: CALL_OW 330
// RemoveSeeing ( x , y , side ) ;
88711: LD_VAR 0 1
88715: PPUSH
88716: LD_VAR 0 2
88720: PPUSH
88721: LD_VAR 0 3
88725: PPUSH
88726: CALL_OW 331
// end ;
88730: LD_VAR 0 5
88734: RET
// export function Video ( mode ) ; begin
88735: LD_INT 0
88737: PPUSH
// ingame_video = mode ;
88738: LD_ADDR_OWVAR 52
88742: PUSH
88743: LD_VAR 0 1
88747: ST_TO_ADDR
// interface_hidden = mode ;
88748: LD_ADDR_OWVAR 54
88752: PUSH
88753: LD_VAR 0 1
88757: ST_TO_ADDR
// end ;
88758: LD_VAR 0 2
88762: RET
// export function Join ( array , element ) ; begin
88763: LD_INT 0
88765: PPUSH
// result := Replace ( array , array + 1 , element ) ;
88766: LD_ADDR_VAR 0 3
88770: PUSH
88771: LD_VAR 0 1
88775: PPUSH
88776: LD_VAR 0 1
88780: PUSH
88781: LD_INT 1
88783: PLUS
88784: PPUSH
88785: LD_VAR 0 2
88789: PPUSH
88790: CALL_OW 1
88794: ST_TO_ADDR
// end ;
88795: LD_VAR 0 3
88799: RET
// export function JoinUnion ( array , element ) ; begin
88800: LD_INT 0
88802: PPUSH
// result := array union element ;
88803: LD_ADDR_VAR 0 3
88807: PUSH
88808: LD_VAR 0 1
88812: PUSH
88813: LD_VAR 0 2
88817: UNION
88818: ST_TO_ADDR
// end ;
88819: LD_VAR 0 3
88823: RET
// export function GetBehemoths ( side ) ; begin
88824: LD_INT 0
88826: PPUSH
// result := FilterAllUnits ( [ [ f_side , side ] , [ f_chassis , 25 ] ] ) ;
88827: LD_ADDR_VAR 0 2
88831: PUSH
88832: LD_INT 22
88834: PUSH
88835: LD_VAR 0 1
88839: PUSH
88840: EMPTY
88841: LIST
88842: LIST
88843: PUSH
88844: LD_INT 31
88846: PUSH
88847: LD_INT 25
88849: PUSH
88850: EMPTY
88851: LIST
88852: LIST
88853: PUSH
88854: EMPTY
88855: LIST
88856: LIST
88857: PPUSH
88858: CALL_OW 69
88862: ST_TO_ADDR
// end ;
88863: LD_VAR 0 2
88867: RET
// export function Shuffle ( array ) ; var i , index ; begin
88868: LD_INT 0
88870: PPUSH
88871: PPUSH
88872: PPUSH
// result := [ ] ;
88873: LD_ADDR_VAR 0 2
88877: PUSH
88878: EMPTY
88879: ST_TO_ADDR
// if not array then
88880: LD_VAR 0 1
88884: NOT
88885: IFFALSE 88889
// exit ;
88887: GO 88988
// Randomize ;
88889: CALL_OW 10
// for i = array downto 1 do
88893: LD_ADDR_VAR 0 3
88897: PUSH
88898: DOUBLE
88899: LD_VAR 0 1
88903: INC
88904: ST_TO_ADDR
88905: LD_INT 1
88907: PUSH
88908: FOR_DOWNTO
88909: IFFALSE 88986
// begin index := rand ( 1 , array ) ;
88911: LD_ADDR_VAR 0 4
88915: PUSH
88916: LD_INT 1
88918: PPUSH
88919: LD_VAR 0 1
88923: PPUSH
88924: CALL_OW 12
88928: ST_TO_ADDR
// result := Insert ( result , result + 1 , array [ index ] ) ;
88929: LD_ADDR_VAR 0 2
88933: PUSH
88934: LD_VAR 0 2
88938: PPUSH
88939: LD_VAR 0 2
88943: PUSH
88944: LD_INT 1
88946: PLUS
88947: PPUSH
88948: LD_VAR 0 1
88952: PUSH
88953: LD_VAR 0 4
88957: ARRAY
88958: PPUSH
88959: CALL_OW 2
88963: ST_TO_ADDR
// array := Delete ( array , index ) ;
88964: LD_ADDR_VAR 0 1
88968: PUSH
88969: LD_VAR 0 1
88973: PPUSH
88974: LD_VAR 0 4
88978: PPUSH
88979: CALL_OW 3
88983: ST_TO_ADDR
// end ;
88984: GO 88908
88986: POP
88987: POP
// end ;
88988: LD_VAR 0 2
88992: RET
// export function GetBaseMaterials ( base ) ; begin
88993: LD_INT 0
88995: PPUSH
// result := [ 0 , 0 , 0 ] ;
88996: LD_ADDR_VAR 0 2
89000: PUSH
89001: LD_INT 0
89003: PUSH
89004: LD_INT 0
89006: PUSH
89007: LD_INT 0
89009: PUSH
89010: EMPTY
89011: LIST
89012: LIST
89013: LIST
89014: ST_TO_ADDR
// if not base then
89015: LD_VAR 0 1
89019: NOT
89020: IFFALSE 89024
// exit ;
89022: GO 89073
// result := [ GetResourceType ( base , mat_cans ) , GetResourceType ( base , mat_oil ) , GetResourceType ( base , mat_siberit ) ] ;
89024: LD_ADDR_VAR 0 2
89028: PUSH
89029: LD_VAR 0 1
89033: PPUSH
89034: LD_INT 1
89036: PPUSH
89037: CALL_OW 275
89041: PUSH
89042: LD_VAR 0 1
89046: PPUSH
89047: LD_INT 2
89049: PPUSH
89050: CALL_OW 275
89054: PUSH
89055: LD_VAR 0 1
89059: PPUSH
89060: LD_INT 3
89062: PPUSH
89063: CALL_OW 275
89067: PUSH
89068: EMPTY
89069: LIST
89070: LIST
89071: LIST
89072: ST_TO_ADDR
// end ;
89073: LD_VAR 0 2
89077: RET
// export function ShrinkArray ( array , size ) ; var i ; begin
89078: LD_INT 0
89080: PPUSH
89081: PPUSH
// result := array ;
89082: LD_ADDR_VAR 0 3
89086: PUSH
89087: LD_VAR 0 1
89091: ST_TO_ADDR
// if size > 0 then
89092: LD_VAR 0 2
89096: PUSH
89097: LD_INT 0
89099: GREATER
89100: IFFALSE 89146
// for i := array downto size do
89102: LD_ADDR_VAR 0 4
89106: PUSH
89107: DOUBLE
89108: LD_VAR 0 1
89112: INC
89113: ST_TO_ADDR
89114: LD_VAR 0 2
89118: PUSH
89119: FOR_DOWNTO
89120: IFFALSE 89144
// result := Delete ( result , result ) ;
89122: LD_ADDR_VAR 0 3
89126: PUSH
89127: LD_VAR 0 3
89131: PPUSH
89132: LD_VAR 0 3
89136: PPUSH
89137: CALL_OW 3
89141: ST_TO_ADDR
89142: GO 89119
89144: POP
89145: POP
// end ;
89146: LD_VAR 0 3
89150: RET
// export function ComExit ( unit ) ; var tmp ; begin
89151: LD_INT 0
89153: PPUSH
89154: PPUSH
// if not IsInUnit ( unit ) then
89155: LD_VAR 0 1
89159: PPUSH
89160: CALL_OW 310
89164: NOT
89165: IFFALSE 89169
// exit ;
89167: GO 89229
// tmp := IsInUnit ( unit ) ;
89169: LD_ADDR_VAR 0 3
89173: PUSH
89174: LD_VAR 0 1
89178: PPUSH
89179: CALL_OW 310
89183: ST_TO_ADDR
// if GetType ( tmp ) = unit_vehicle then
89184: LD_VAR 0 3
89188: PPUSH
89189: CALL_OW 247
89193: PUSH
89194: LD_INT 2
89196: EQUAL
89197: IFFALSE 89210
// ComExitVehicle ( unit ) else
89199: LD_VAR 0 1
89203: PPUSH
89204: CALL_OW 121
89208: GO 89219
// ComExitBuilding ( unit ) ;
89210: LD_VAR 0 1
89214: PPUSH
89215: CALL_OW 122
// result := tmp ;
89219: LD_ADDR_VAR 0 2
89223: PUSH
89224: LD_VAR 0 3
89228: ST_TO_ADDR
// end ;
89229: LD_VAR 0 2
89233: RET
// export function ComExitAll ( units ) ; var i ; begin
89234: LD_INT 0
89236: PPUSH
89237: PPUSH
// if not units then
89238: LD_VAR 0 1
89242: NOT
89243: IFFALSE 89247
// exit ;
89245: GO 89273
// for i in units do
89247: LD_ADDR_VAR 0 3
89251: PUSH
89252: LD_VAR 0 1
89256: PUSH
89257: FOR_IN
89258: IFFALSE 89271
// ComExit ( i ) ;
89260: LD_VAR 0 3
89264: PPUSH
89265: CALL 89151 0 1
89269: GO 89257
89271: POP
89272: POP
// end ;
89273: LD_VAR 0 2
89277: RET
// export function ResetHc ; begin
89278: LD_INT 0
89280: PPUSH
// InitHc ;
89281: CALL_OW 19
// hc_importance := 0 ;
89285: LD_ADDR_OWVAR 32
89289: PUSH
89290: LD_INT 0
89292: ST_TO_ADDR
// end ;
89293: LD_VAR 0 1
89297: RET
// export function PointBetweenXY ( x1 , y1 , x2 , y2 ) ; var _x , _y ; begin
89298: LD_INT 0
89300: PPUSH
89301: PPUSH
89302: PPUSH
// _x := ( x1 + x2 ) div 2 ;
89303: LD_ADDR_VAR 0 6
89307: PUSH
89308: LD_VAR 0 1
89312: PUSH
89313: LD_VAR 0 3
89317: PLUS
89318: PUSH
89319: LD_INT 2
89321: DIV
89322: ST_TO_ADDR
// if _x < 0 then
89323: LD_VAR 0 6
89327: PUSH
89328: LD_INT 0
89330: LESS
89331: IFFALSE 89348
// _x := _x * - 1 ;
89333: LD_ADDR_VAR 0 6
89337: PUSH
89338: LD_VAR 0 6
89342: PUSH
89343: LD_INT 1
89345: NEG
89346: MUL
89347: ST_TO_ADDR
// _y := ( y1 + y2 ) div 2 ;
89348: LD_ADDR_VAR 0 7
89352: PUSH
89353: LD_VAR 0 2
89357: PUSH
89358: LD_VAR 0 4
89362: PLUS
89363: PUSH
89364: LD_INT 2
89366: DIV
89367: ST_TO_ADDR
// if _y < 0 then
89368: LD_VAR 0 7
89372: PUSH
89373: LD_INT 0
89375: LESS
89376: IFFALSE 89393
// _y := _y * - 1 ;
89378: LD_ADDR_VAR 0 7
89382: PUSH
89383: LD_VAR 0 7
89387: PUSH
89388: LD_INT 1
89390: NEG
89391: MUL
89392: ST_TO_ADDR
// result := [ _x , _y ] ;
89393: LD_ADDR_VAR 0 5
89397: PUSH
89398: LD_VAR 0 6
89402: PUSH
89403: LD_VAR 0 7
89407: PUSH
89408: EMPTY
89409: LIST
89410: LIST
89411: ST_TO_ADDR
// end ;
89412: LD_VAR 0 5
89416: RET
// export function NotGoToAreaUnit ( unit , area , goAway ) ; var x , y , task ; begin
89417: LD_INT 0
89419: PPUSH
89420: PPUSH
89421: PPUSH
89422: PPUSH
// task := GetTaskList ( unit ) ;
89423: LD_ADDR_VAR 0 7
89427: PUSH
89428: LD_VAR 0 1
89432: PPUSH
89433: CALL_OW 437
89437: ST_TO_ADDR
// if not task and not IsInArea ( unit , area ) then
89438: LD_VAR 0 7
89442: NOT
89443: PUSH
89444: LD_VAR 0 1
89448: PPUSH
89449: LD_VAR 0 2
89453: PPUSH
89454: CALL_OW 308
89458: NOT
89459: AND
89460: IFFALSE 89464
// exit ;
89462: GO 89582
// if IsInArea ( unit , area ) then
89464: LD_VAR 0 1
89468: PPUSH
89469: LD_VAR 0 2
89473: PPUSH
89474: CALL_OW 308
89478: IFFALSE 89496
// begin ComMoveToArea ( unit , goAway ) ;
89480: LD_VAR 0 1
89484: PPUSH
89485: LD_VAR 0 3
89489: PPUSH
89490: CALL_OW 113
// exit ;
89494: GO 89582
// end ; if task [ 1 ] [ 1 ] <> M then
89496: LD_VAR 0 7
89500: PUSH
89501: LD_INT 1
89503: ARRAY
89504: PUSH
89505: LD_INT 1
89507: ARRAY
89508: PUSH
89509: LD_STRING M
89511: NONEQUAL
89512: IFFALSE 89516
// exit ;
89514: GO 89582
// x := task [ 1 ] [ 2 ] ;
89516: LD_ADDR_VAR 0 5
89520: PUSH
89521: LD_VAR 0 7
89525: PUSH
89526: LD_INT 1
89528: ARRAY
89529: PUSH
89530: LD_INT 2
89532: ARRAY
89533: ST_TO_ADDR
// y := task [ 1 ] [ 3 ] ;
89534: LD_ADDR_VAR 0 6
89538: PUSH
89539: LD_VAR 0 7
89543: PUSH
89544: LD_INT 1
89546: ARRAY
89547: PUSH
89548: LD_INT 3
89550: ARRAY
89551: ST_TO_ADDR
// if InArea ( x , y , area ) then
89552: LD_VAR 0 5
89556: PPUSH
89557: LD_VAR 0 6
89561: PPUSH
89562: LD_VAR 0 2
89566: PPUSH
89567: CALL_OW 309
89571: IFFALSE 89582
// ComStop ( unit ) ;
89573: LD_VAR 0 1
89577: PPUSH
89578: CALL_OW 141
// end ;
89582: LD_VAR 0 4
89586: RET
// export function Abs ( value ) ; begin
89587: LD_INT 0
89589: PPUSH
// result := value ;
89590: LD_ADDR_VAR 0 2
89594: PUSH
89595: LD_VAR 0 1
89599: ST_TO_ADDR
// if value < 0 then
89600: LD_VAR 0 1
89604: PUSH
89605: LD_INT 0
89607: LESS
89608: IFFALSE 89625
// result := value * - 1 ;
89610: LD_ADDR_VAR 0 2
89614: PUSH
89615: LD_VAR 0 1
89619: PUSH
89620: LD_INT 1
89622: NEG
89623: MUL
89624: ST_TO_ADDR
// end ;
89625: LD_VAR 0 2
89629: RET
// export function ComMoveToNearbyEntrance ( unit , building ) ; var x , _x , y , _y , d , r , i ; begin
89630: LD_INT 0
89632: PPUSH
89633: PPUSH
89634: PPUSH
89635: PPUSH
89636: PPUSH
89637: PPUSH
89638: PPUSH
89639: PPUSH
// if not unit or not building then
89640: LD_VAR 0 1
89644: NOT
89645: PUSH
89646: LD_VAR 0 2
89650: NOT
89651: OR
89652: IFFALSE 89656
// exit ;
89654: GO 89882
// x := GetX ( building ) ;
89656: LD_ADDR_VAR 0 4
89660: PUSH
89661: LD_VAR 0 2
89665: PPUSH
89666: CALL_OW 250
89670: ST_TO_ADDR
// y := GetY ( building ) ;
89671: LD_ADDR_VAR 0 6
89675: PUSH
89676: LD_VAR 0 2
89680: PPUSH
89681: CALL_OW 251
89685: ST_TO_ADDR
// d := GetDir ( building ) ;
89686: LD_ADDR_VAR 0 8
89690: PUSH
89691: LD_VAR 0 2
89695: PPUSH
89696: CALL_OW 254
89700: ST_TO_ADDR
// r := 4 ;
89701: LD_ADDR_VAR 0 9
89705: PUSH
89706: LD_INT 4
89708: ST_TO_ADDR
// for i := 1 to 5 do
89709: LD_ADDR_VAR 0 10
89713: PUSH
89714: DOUBLE
89715: LD_INT 1
89717: DEC
89718: ST_TO_ADDR
89719: LD_INT 5
89721: PUSH
89722: FOR_TO
89723: IFFALSE 89880
// begin _x := ShiftX ( x , d , r + i ) ;
89725: LD_ADDR_VAR 0 5
89729: PUSH
89730: LD_VAR 0 4
89734: PPUSH
89735: LD_VAR 0 8
89739: PPUSH
89740: LD_VAR 0 9
89744: PUSH
89745: LD_VAR 0 10
89749: PLUS
89750: PPUSH
89751: CALL_OW 272
89755: ST_TO_ADDR
// _y := ShiftY ( y , d , r + i ) ;
89756: LD_ADDR_VAR 0 7
89760: PUSH
89761: LD_VAR 0 6
89765: PPUSH
89766: LD_VAR 0 8
89770: PPUSH
89771: LD_VAR 0 9
89775: PUSH
89776: LD_VAR 0 10
89780: PLUS
89781: PPUSH
89782: CALL_OW 273
89786: ST_TO_ADDR
// if ValidHex ( _x , _y ) and not GetType ( HexInfo ( _x , _y ) ) in [ unit_building , unit_vehicle ] then
89787: LD_VAR 0 5
89791: PPUSH
89792: LD_VAR 0 7
89796: PPUSH
89797: CALL_OW 488
89801: PUSH
89802: LD_VAR 0 5
89806: PPUSH
89807: LD_VAR 0 7
89811: PPUSH
89812: CALL_OW 428
89816: PPUSH
89817: CALL_OW 247
89821: PUSH
89822: LD_INT 3
89824: PUSH
89825: LD_INT 2
89827: PUSH
89828: EMPTY
89829: LIST
89830: LIST
89831: IN
89832: NOT
89833: AND
89834: IFFALSE 89878
// begin ComMoveXY ( unit , _x , _y ) ;
89836: LD_VAR 0 1
89840: PPUSH
89841: LD_VAR 0 5
89845: PPUSH
89846: LD_VAR 0 7
89850: PPUSH
89851: CALL_OW 111
// result := [ _x , _y ] ;
89855: LD_ADDR_VAR 0 3
89859: PUSH
89860: LD_VAR 0 5
89864: PUSH
89865: LD_VAR 0 7
89869: PUSH
89870: EMPTY
89871: LIST
89872: LIST
89873: ST_TO_ADDR
// exit ;
89874: POP
89875: POP
89876: GO 89882
// end ; end ;
89878: GO 89722
89880: POP
89881: POP
// end ;
89882: LD_VAR 0 3
89886: RET
// export function SideAttackedSide ( side1 , side2 ) ; var i , un ; begin
89887: LD_INT 0
89889: PPUSH
89890: PPUSH
89891: PPUSH
// result := 0 ;
89892: LD_ADDR_VAR 0 3
89896: PUSH
89897: LD_INT 0
89899: ST_TO_ADDR
// if side1 < 0 or side1 > 8 or side2 < 0 or side2 > 8 then
89900: LD_VAR 0 1
89904: PUSH
89905: LD_INT 0
89907: LESS
89908: PUSH
89909: LD_VAR 0 1
89913: PUSH
89914: LD_INT 8
89916: GREATER
89917: OR
89918: PUSH
89919: LD_VAR 0 2
89923: PUSH
89924: LD_INT 0
89926: LESS
89927: OR
89928: PUSH
89929: LD_VAR 0 2
89933: PUSH
89934: LD_INT 8
89936: GREATER
89937: OR
89938: IFFALSE 89942
// exit ;
89940: GO 90017
// for i in FilterAllUnits ( [ f_side , side2 ] ) do
89942: LD_ADDR_VAR 0 4
89946: PUSH
89947: LD_INT 22
89949: PUSH
89950: LD_VAR 0 2
89954: PUSH
89955: EMPTY
89956: LIST
89957: LIST
89958: PPUSH
89959: CALL_OW 69
89963: PUSH
89964: FOR_IN
89965: IFFALSE 90015
// begin un := UnitShoot ( i ) ;
89967: LD_ADDR_VAR 0 5
89971: PUSH
89972: LD_VAR 0 4
89976: PPUSH
89977: CALL_OW 504
89981: ST_TO_ADDR
// if GetSide ( un ) = side1 then
89982: LD_VAR 0 5
89986: PPUSH
89987: CALL_OW 255
89991: PUSH
89992: LD_VAR 0 1
89996: EQUAL
89997: IFFALSE 90013
// begin result := un ;
89999: LD_ADDR_VAR 0 3
90003: PUSH
90004: LD_VAR 0 5
90008: ST_TO_ADDR
// exit ;
90009: POP
90010: POP
90011: GO 90017
// end ; end ;
90013: GO 89964
90015: POP
90016: POP
// end ;
90017: LD_VAR 0 3
90021: RET
// export function GetCargoBay ( units ) ; begin
90022: LD_INT 0
90024: PPUSH
// result := UnitFilter ( units , [ f_or , [ f_weapon , us_cargo_bay ] , [ f_weapon , ru_cargo_bay ] , [ f_weapon , ar_cargo_bay ] , [ f_weapon , ru_big_cargo_bay ] ] ) ;
90025: LD_ADDR_VAR 0 2
90029: PUSH
90030: LD_VAR 0 1
90034: PPUSH
90035: LD_INT 2
90037: PUSH
90038: LD_INT 34
90040: PUSH
90041: LD_INT 12
90043: PUSH
90044: EMPTY
90045: LIST
90046: LIST
90047: PUSH
90048: LD_INT 34
90050: PUSH
90051: LD_INT 51
90053: PUSH
90054: EMPTY
90055: LIST
90056: LIST
90057: PUSH
90058: LD_INT 34
90060: PUSH
90061: LD_INT 32
90063: PUSH
90064: EMPTY
90065: LIST
90066: LIST
90067: PUSH
90068: LD_INT 34
90070: PUSH
90071: LD_EXP 75
90075: PUSH
90076: EMPTY
90077: LIST
90078: LIST
90079: PUSH
90080: EMPTY
90081: LIST
90082: LIST
90083: LIST
90084: LIST
90085: LIST
90086: PPUSH
90087: CALL_OW 72
90091: ST_TO_ADDR
// end ;
90092: LD_VAR 0 2
90096: RET
// export function Negate ( value ) ; begin
90097: LD_INT 0
90099: PPUSH
// result := not value ;
90100: LD_ADDR_VAR 0 2
90104: PUSH
90105: LD_VAR 0 1
90109: NOT
90110: ST_TO_ADDR
// end ;
90111: LD_VAR 0 2
90115: RET
// export function Inc ( value ) ; begin
90116: LD_INT 0
90118: PPUSH
// result := value + 1 ;
90119: LD_ADDR_VAR 0 2
90123: PUSH
90124: LD_VAR 0 1
90128: PUSH
90129: LD_INT 1
90131: PLUS
90132: ST_TO_ADDR
// end ;
90133: LD_VAR 0 2
90137: RET
// export function Dec ( value ) ; begin
90138: LD_INT 0
90140: PPUSH
// result := value - 1 ;
90141: LD_ADDR_VAR 0 2
90145: PUSH
90146: LD_VAR 0 1
90150: PUSH
90151: LD_INT 1
90153: MINUS
90154: ST_TO_ADDR
// end ;
90155: LD_VAR 0 2
90159: RET
// export function GetDirFromHex ( x1 , y1 , x2 , y2 ) ; var i , _x , _y , tmp , distance , centerDist , centerPoint ; begin
90160: LD_INT 0
90162: PPUSH
90163: PPUSH
90164: PPUSH
90165: PPUSH
90166: PPUSH
90167: PPUSH
90168: PPUSH
90169: PPUSH
// if not ValidHex ( x1 , y1 ) or not ValidHex ( x2 , y2 ) then
90170: LD_VAR 0 1
90174: PPUSH
90175: LD_VAR 0 2
90179: PPUSH
90180: CALL_OW 488
90184: NOT
90185: PUSH
90186: LD_VAR 0 3
90190: PPUSH
90191: LD_VAR 0 4
90195: PPUSH
90196: CALL_OW 488
90200: NOT
90201: OR
90202: IFFALSE 90215
// begin result := - 1 ;
90204: LD_ADDR_VAR 0 5
90208: PUSH
90209: LD_INT 1
90211: NEG
90212: ST_TO_ADDR
// exit ;
90213: GO 90450
// end ; centerPoint := PointBetweenXY ( x1 , y1 , x2 , y2 ) ;
90215: LD_ADDR_VAR 0 12
90219: PUSH
90220: LD_VAR 0 1
90224: PPUSH
90225: LD_VAR 0 2
90229: PPUSH
90230: LD_VAR 0 3
90234: PPUSH
90235: LD_VAR 0 4
90239: PPUSH
90240: CALL 89298 0 4
90244: ST_TO_ADDR
// centerDist := GetDistXY ( x1 , y1 , centerPoint [ 1 ] , centerPoint [ 2 ] ) ;
90245: LD_ADDR_VAR 0 11
90249: PUSH
90250: LD_VAR 0 1
90254: PPUSH
90255: LD_VAR 0 2
90259: PPUSH
90260: LD_VAR 0 12
90264: PUSH
90265: LD_INT 1
90267: ARRAY
90268: PPUSH
90269: LD_VAR 0 12
90273: PUSH
90274: LD_INT 2
90276: ARRAY
90277: PPUSH
90278: CALL_OW 298
90282: ST_TO_ADDR
// distance := 9999 ;
90283: LD_ADDR_VAR 0 10
90287: PUSH
90288: LD_INT 9999
90290: ST_TO_ADDR
// for i := 0 to 5 do
90291: LD_ADDR_VAR 0 6
90295: PUSH
90296: DOUBLE
90297: LD_INT 0
90299: DEC
90300: ST_TO_ADDR
90301: LD_INT 5
90303: PUSH
90304: FOR_TO
90305: IFFALSE 90448
// begin _x := ShiftX ( x1 , i , centerDist ) ;
90307: LD_ADDR_VAR 0 7
90311: PUSH
90312: LD_VAR 0 1
90316: PPUSH
90317: LD_VAR 0 6
90321: PPUSH
90322: LD_VAR 0 11
90326: PPUSH
90327: CALL_OW 272
90331: ST_TO_ADDR
// _y := ShiftY ( y1 , i , centerDist ) ;
90332: LD_ADDR_VAR 0 8
90336: PUSH
90337: LD_VAR 0 2
90341: PPUSH
90342: LD_VAR 0 6
90346: PPUSH
90347: LD_VAR 0 11
90351: PPUSH
90352: CALL_OW 273
90356: ST_TO_ADDR
// if not ValidHex ( _x , _y ) then
90357: LD_VAR 0 7
90361: PPUSH
90362: LD_VAR 0 8
90366: PPUSH
90367: CALL_OW 488
90371: NOT
90372: IFFALSE 90376
// continue ;
90374: GO 90304
// tmp := GetDistXY ( centerPoint [ 1 ] , centerPoint [ 2 ] , _x , _y ) ;
90376: LD_ADDR_VAR 0 9
90380: PUSH
90381: LD_VAR 0 12
90385: PUSH
90386: LD_INT 1
90388: ARRAY
90389: PPUSH
90390: LD_VAR 0 12
90394: PUSH
90395: LD_INT 2
90397: ARRAY
90398: PPUSH
90399: LD_VAR 0 7
90403: PPUSH
90404: LD_VAR 0 8
90408: PPUSH
90409: CALL_OW 298
90413: ST_TO_ADDR
// if tmp < distance then
90414: LD_VAR 0 9
90418: PUSH
90419: LD_VAR 0 10
90423: LESS
90424: IFFALSE 90446
// begin result := i ;
90426: LD_ADDR_VAR 0 5
90430: PUSH
90431: LD_VAR 0 6
90435: ST_TO_ADDR
// distance := tmp ;
90436: LD_ADDR_VAR 0 10
90440: PUSH
90441: LD_VAR 0 9
90445: ST_TO_ADDR
// end ; end ;
90446: GO 90304
90448: POP
90449: POP
// end ;
90450: LD_VAR 0 5
90454: RET
// export function ComRepairVehicleAndReturn ( driver ) ; var vehicle ; begin
90455: LD_INT 0
90457: PPUSH
90458: PPUSH
// if not driver or not IsInUnit ( driver ) then
90459: LD_VAR 0 1
90463: NOT
90464: PUSH
90465: LD_VAR 0 1
90469: PPUSH
90470: CALL_OW 310
90474: NOT
90475: OR
90476: IFFALSE 90480
// exit ;
90478: GO 90570
// vehicle := IsInUnit ( driver ) ;
90480: LD_ADDR_VAR 0 3
90484: PUSH
90485: LD_VAR 0 1
90489: PPUSH
90490: CALL_OW 310
90494: ST_TO_ADDR
// SetTaskList ( driver , [ [ \ , 0 , 0 , 0 , 0 , 0 , 0 ] , [ E , 0 , 0 , vehicle , 0 , 0 , 0 ] ] ) ;
90495: LD_VAR 0 1
90499: PPUSH
90500: LD_STRING \
90502: PUSH
90503: LD_INT 0
90505: PUSH
90506: LD_INT 0
90508: PUSH
90509: LD_INT 0
90511: PUSH
90512: LD_INT 0
90514: PUSH
90515: LD_INT 0
90517: PUSH
90518: LD_INT 0
90520: PUSH
90521: EMPTY
90522: LIST
90523: LIST
90524: LIST
90525: LIST
90526: LIST
90527: LIST
90528: LIST
90529: PUSH
90530: LD_STRING E
90532: PUSH
90533: LD_INT 0
90535: PUSH
90536: LD_INT 0
90538: PUSH
90539: LD_VAR 0 3
90543: PUSH
90544: LD_INT 0
90546: PUSH
90547: LD_INT 0
90549: PUSH
90550: LD_INT 0
90552: PUSH
90553: EMPTY
90554: LIST
90555: LIST
90556: LIST
90557: LIST
90558: LIST
90559: LIST
90560: LIST
90561: PUSH
90562: EMPTY
90563: LIST
90564: LIST
90565: PPUSH
90566: CALL_OW 446
// end ;
90570: LD_VAR 0 2
90574: RET
// export function AddComRepairVehicleAndReturn ( driver ) ; var vehicle ; begin
90575: LD_INT 0
90577: PPUSH
90578: PPUSH
// if not driver or not IsInUnit ( driver ) then
90579: LD_VAR 0 1
90583: NOT
90584: PUSH
90585: LD_VAR 0 1
90589: PPUSH
90590: CALL_OW 310
90594: NOT
90595: OR
90596: IFFALSE 90600
// exit ;
90598: GO 90690
// vehicle := IsInUnit ( driver ) ;
90600: LD_ADDR_VAR 0 3
90604: PUSH
90605: LD_VAR 0 1
90609: PPUSH
90610: CALL_OW 310
90614: ST_TO_ADDR
// AddTaskList ( driver , [ [ \ , 0 , 0 , 0 , 0 , 0 , 0 ] , [ E , 0 , 0 , vehicle , 0 , 0 , 0 ] ] ) ;
90615: LD_VAR 0 1
90619: PPUSH
90620: LD_STRING \
90622: PUSH
90623: LD_INT 0
90625: PUSH
90626: LD_INT 0
90628: PUSH
90629: LD_INT 0
90631: PUSH
90632: LD_INT 0
90634: PUSH
90635: LD_INT 0
90637: PUSH
90638: LD_INT 0
90640: PUSH
90641: EMPTY
90642: LIST
90643: LIST
90644: LIST
90645: LIST
90646: LIST
90647: LIST
90648: LIST
90649: PUSH
90650: LD_STRING E
90652: PUSH
90653: LD_INT 0
90655: PUSH
90656: LD_INT 0
90658: PUSH
90659: LD_VAR 0 3
90663: PUSH
90664: LD_INT 0
90666: PUSH
90667: LD_INT 0
90669: PUSH
90670: LD_INT 0
90672: PUSH
90673: EMPTY
90674: LIST
90675: LIST
90676: LIST
90677: LIST
90678: LIST
90679: LIST
90680: LIST
90681: PUSH
90682: EMPTY
90683: LIST
90684: LIST
90685: PPUSH
90686: CALL_OW 447
// end ;
90690: LD_VAR 0 2
90694: RET
// export function SortByHealth ( units , asc ) ; var i , tmp ; begin
90695: LD_INT 0
90697: PPUSH
90698: PPUSH
90699: PPUSH
// tmp := [ ] ;
90700: LD_ADDR_VAR 0 5
90704: PUSH
90705: EMPTY
90706: ST_TO_ADDR
// for i in units do
90707: LD_ADDR_VAR 0 4
90711: PUSH
90712: LD_VAR 0 1
90716: PUSH
90717: FOR_IN
90718: IFFALSE 90756
// tmp := Insert ( tmp , tmp + 1 , GetLives ( i ) ) ;
90720: LD_ADDR_VAR 0 5
90724: PUSH
90725: LD_VAR 0 5
90729: PPUSH
90730: LD_VAR 0 5
90734: PUSH
90735: LD_INT 1
90737: PLUS
90738: PPUSH
90739: LD_VAR 0 4
90743: PPUSH
90744: CALL_OW 256
90748: PPUSH
90749: CALL_OW 2
90753: ST_TO_ADDR
90754: GO 90717
90756: POP
90757: POP
// if not tmp then
90758: LD_VAR 0 5
90762: NOT
90763: IFFALSE 90767
// exit ;
90765: GO 90815
// if asc then
90767: LD_VAR 0 2
90771: IFFALSE 90795
// result := SortListByListAsc ( units , tmp ) else
90773: LD_ADDR_VAR 0 3
90777: PUSH
90778: LD_VAR 0 1
90782: PPUSH
90783: LD_VAR 0 5
90787: PPUSH
90788: CALL_OW 76
90792: ST_TO_ADDR
90793: GO 90815
// result := SortListByListDesc ( units , tmp ) ;
90795: LD_ADDR_VAR 0 3
90799: PUSH
90800: LD_VAR 0 1
90804: PPUSH
90805: LD_VAR 0 5
90809: PPUSH
90810: CALL_OW 77
90814: ST_TO_ADDR
// end ;
90815: LD_VAR 0 3
90819: RET
// export function WantToRepairVehicle ( mech , vehicle ) ; var task ; begin
90820: LD_INT 0
90822: PPUSH
90823: PPUSH
// task := GetTaskList ( mech ) ;
90824: LD_ADDR_VAR 0 4
90828: PUSH
90829: LD_VAR 0 1
90833: PPUSH
90834: CALL_OW 437
90838: ST_TO_ADDR
// if not task then
90839: LD_VAR 0 4
90843: NOT
90844: IFFALSE 90848
// exit ;
90846: GO 90890
// result := task [ 1 ] [ 1 ] = r and task [ 1 ] [ 4 ] = vehicle ;
90848: LD_ADDR_VAR 0 3
90852: PUSH
90853: LD_VAR 0 4
90857: PUSH
90858: LD_INT 1
90860: ARRAY
90861: PUSH
90862: LD_INT 1
90864: ARRAY
90865: PUSH
90866: LD_STRING r
90868: EQUAL
90869: PUSH
90870: LD_VAR 0 4
90874: PUSH
90875: LD_INT 1
90877: ARRAY
90878: PUSH
90879: LD_INT 4
90881: ARRAY
90882: PUSH
90883: LD_VAR 0 2
90887: EQUAL
90888: AND
90889: ST_TO_ADDR
// end ;
90890: LD_VAR 0 3
90894: RET
// export function PlaceUnitXYD ( unit , x , y , d , mode ) ; begin
90895: LD_INT 0
90897: PPUSH
// SetDir ( unit , d ) ;
90898: LD_VAR 0 1
90902: PPUSH
90903: LD_VAR 0 4
90907: PPUSH
90908: CALL_OW 233
// PlaceUnitXY ( unit , x , y , mode ) ;
90912: LD_VAR 0 1
90916: PPUSH
90917: LD_VAR 0 2
90921: PPUSH
90922: LD_VAR 0 3
90926: PPUSH
90927: LD_VAR 0 5
90931: PPUSH
90932: CALL_OW 48
// end ;
90936: LD_VAR 0 6
90940: RET
// export function ToNaturalNumber ( number ) ; begin
90941: LD_INT 0
90943: PPUSH
// result := number div 1 ;
90944: LD_ADDR_VAR 0 2
90948: PUSH
90949: LD_VAR 0 1
90953: PUSH
90954: LD_INT 1
90956: DIV
90957: ST_TO_ADDR
// if number < 0 then
90958: LD_VAR 0 1
90962: PUSH
90963: LD_INT 0
90965: LESS
90966: IFFALSE 90976
// result := 0 ;
90968: LD_ADDR_VAR 0 2
90972: PUSH
90973: LD_INT 0
90975: ST_TO_ADDR
// end ;
90976: LD_VAR 0 2
90980: RET
// export function SortByClass ( units , class ) ; var un ; begin
90981: LD_INT 0
90983: PPUSH
90984: PPUSH
// if not units or not class then
90985: LD_VAR 0 1
90989: NOT
90990: PUSH
90991: LD_VAR 0 2
90995: NOT
90996: OR
90997: IFFALSE 91001
// exit ;
90999: GO 91096
// result := [ ] ;
91001: LD_ADDR_VAR 0 3
91005: PUSH
91006: EMPTY
91007: ST_TO_ADDR
// for un in units do
91008: LD_ADDR_VAR 0 4
91012: PUSH
91013: LD_VAR 0 1
91017: PUSH
91018: FOR_IN
91019: IFFALSE 91094
// if GetClass ( un ) = class then
91021: LD_VAR 0 4
91025: PPUSH
91026: CALL_OW 257
91030: PUSH
91031: LD_VAR 0 2
91035: EQUAL
91036: IFFALSE 91063
// result := Insert ( result , 1 , un ) else
91038: LD_ADDR_VAR 0 3
91042: PUSH
91043: LD_VAR 0 3
91047: PPUSH
91048: LD_INT 1
91050: PPUSH
91051: LD_VAR 0 4
91055: PPUSH
91056: CALL_OW 2
91060: ST_TO_ADDR
91061: GO 91092
// result := Replace ( result , result + 1 , un ) ;
91063: LD_ADDR_VAR 0 3
91067: PUSH
91068: LD_VAR 0 3
91072: PPUSH
91073: LD_VAR 0 3
91077: PUSH
91078: LD_INT 1
91080: PLUS
91081: PPUSH
91082: LD_VAR 0 4
91086: PPUSH
91087: CALL_OW 1
91091: ST_TO_ADDR
91092: GO 91018
91094: POP
91095: POP
// end ;
91096: LD_VAR 0 3
91100: RET
// export function GetCratesNearbyXY ( x , y , r ) ; var _x , _y , min_y , min_x , max_x , max_y ; begin
91101: LD_INT 0
91103: PPUSH
91104: PPUSH
91105: PPUSH
91106: PPUSH
91107: PPUSH
91108: PPUSH
91109: PPUSH
// result := [ ] ;
91110: LD_ADDR_VAR 0 4
91114: PUSH
91115: EMPTY
91116: ST_TO_ADDR
// if x - r < 0 then
91117: LD_VAR 0 1
91121: PUSH
91122: LD_VAR 0 3
91126: MINUS
91127: PUSH
91128: LD_INT 0
91130: LESS
91131: IFFALSE 91143
// min_x := 0 else
91133: LD_ADDR_VAR 0 8
91137: PUSH
91138: LD_INT 0
91140: ST_TO_ADDR
91141: GO 91159
// min_x := x - r ;
91143: LD_ADDR_VAR 0 8
91147: PUSH
91148: LD_VAR 0 1
91152: PUSH
91153: LD_VAR 0 3
91157: MINUS
91158: ST_TO_ADDR
// if y - r < 0 then
91159: LD_VAR 0 2
91163: PUSH
91164: LD_VAR 0 3
91168: MINUS
91169: PUSH
91170: LD_INT 0
91172: LESS
91173: IFFALSE 91185
// min_y := 0 else
91175: LD_ADDR_VAR 0 7
91179: PUSH
91180: LD_INT 0
91182: ST_TO_ADDR
91183: GO 91201
// min_y := y - r ;
91185: LD_ADDR_VAR 0 7
91189: PUSH
91190: LD_VAR 0 2
91194: PUSH
91195: LD_VAR 0 3
91199: MINUS
91200: ST_TO_ADDR
// max_x := x + r ;
91201: LD_ADDR_VAR 0 9
91205: PUSH
91206: LD_VAR 0 1
91210: PUSH
91211: LD_VAR 0 3
91215: PLUS
91216: ST_TO_ADDR
// max_y := y + r ;
91217: LD_ADDR_VAR 0 10
91221: PUSH
91222: LD_VAR 0 2
91226: PUSH
91227: LD_VAR 0 3
91231: PLUS
91232: ST_TO_ADDR
// for _x = min_x to max_x do
91233: LD_ADDR_VAR 0 5
91237: PUSH
91238: DOUBLE
91239: LD_VAR 0 8
91243: DEC
91244: ST_TO_ADDR
91245: LD_VAR 0 9
91249: PUSH
91250: FOR_TO
91251: IFFALSE 91352
// for _y = min_y to max_y do
91253: LD_ADDR_VAR 0 6
91257: PUSH
91258: DOUBLE
91259: LD_VAR 0 7
91263: DEC
91264: ST_TO_ADDR
91265: LD_VAR 0 10
91269: PUSH
91270: FOR_TO
91271: IFFALSE 91348
// begin if not ValidHex ( _x , _y ) then
91273: LD_VAR 0 5
91277: PPUSH
91278: LD_VAR 0 6
91282: PPUSH
91283: CALL_OW 488
91287: NOT
91288: IFFALSE 91292
// continue ;
91290: GO 91270
// if GetResourceTypeXY ( _x , _y ) then
91292: LD_VAR 0 5
91296: PPUSH
91297: LD_VAR 0 6
91301: PPUSH
91302: CALL_OW 283
91306: IFFALSE 91346
// result := Replace ( result , result + 1 , [ _x , _y ] ) ;
91308: LD_ADDR_VAR 0 4
91312: PUSH
91313: LD_VAR 0 4
91317: PPUSH
91318: LD_VAR 0 4
91322: PUSH
91323: LD_INT 1
91325: PLUS
91326: PPUSH
91327: LD_VAR 0 5
91331: PUSH
91332: LD_VAR 0 6
91336: PUSH
91337: EMPTY
91338: LIST
91339: LIST
91340: PPUSH
91341: CALL_OW 1
91345: ST_TO_ADDR
// end ;
91346: GO 91270
91348: POP
91349: POP
91350: GO 91250
91352: POP
91353: POP
// end ;
91354: LD_VAR 0 4
91358: RET
// export function AgressiveMove ( units , path ) ; var i , enemy , nearEnemy , cr , side , tag , ignoreCratesWeapon ; begin
91359: LD_INT 0
91361: PPUSH
91362: PPUSH
91363: PPUSH
91364: PPUSH
91365: PPUSH
91366: PPUSH
91367: PPUSH
91368: PPUSH
// if not units then
91369: LD_VAR 0 1
91373: NOT
91374: IFFALSE 91378
// exit ;
91376: GO 91803
// result := UnitFilter ( units , [ f_ok ] ) ;
91378: LD_ADDR_VAR 0 3
91382: PUSH
91383: LD_VAR 0 1
91387: PPUSH
91388: LD_INT 50
91390: PUSH
91391: EMPTY
91392: LIST
91393: PPUSH
91394: CALL_OW 72
91398: ST_TO_ADDR
// side := GetSide ( units [ 1 ] ) ;
91399: LD_ADDR_VAR 0 8
91403: PUSH
91404: LD_VAR 0 1
91408: PUSH
91409: LD_INT 1
91411: ARRAY
91412: PPUSH
91413: CALL_OW 255
91417: ST_TO_ADDR
// ignoreCratesWeapon := [ ar_selfpropelled_bomb , ar_bio_bomb ] ;
91418: LD_ADDR_VAR 0 10
91422: PUSH
91423: LD_INT 29
91425: PUSH
91426: LD_EXP 78
91430: PUSH
91431: EMPTY
91432: LIST
91433: LIST
91434: ST_TO_ADDR
// if not result then
91435: LD_VAR 0 3
91439: NOT
91440: IFFALSE 91444
// exit ;
91442: GO 91803
// enemy := FilterAllUnits ( [ f_enemy , side ] ) ;
91444: LD_ADDR_VAR 0 5
91448: PUSH
91449: LD_INT 81
91451: PUSH
91452: LD_VAR 0 8
91456: PUSH
91457: EMPTY
91458: LIST
91459: LIST
91460: PPUSH
91461: CALL_OW 69
91465: ST_TO_ADDR
// for i in result do
91466: LD_ADDR_VAR 0 4
91470: PUSH
91471: LD_VAR 0 3
91475: PUSH
91476: FOR_IN
91477: IFFALSE 91801
// begin tag := GetTag ( i ) + 1 ;
91479: LD_ADDR_VAR 0 9
91483: PUSH
91484: LD_VAR 0 4
91488: PPUSH
91489: CALL_OW 110
91493: PUSH
91494: LD_INT 1
91496: PLUS
91497: ST_TO_ADDR
// cr := GetCratesNearbyXY ( GetX ( i ) , GetY ( i ) , 6 ) ;
91498: LD_ADDR_VAR 0 7
91502: PUSH
91503: LD_VAR 0 4
91507: PPUSH
91508: CALL_OW 250
91512: PPUSH
91513: LD_VAR 0 4
91517: PPUSH
91518: CALL_OW 251
91522: PPUSH
91523: LD_INT 6
91525: PPUSH
91526: CALL 91101 0 3
91530: ST_TO_ADDR
// if cr and not GetWeapon ( i ) in ignoreCratesWeapon then
91531: LD_VAR 0 7
91535: PUSH
91536: LD_VAR 0 4
91540: PPUSH
91541: CALL_OW 264
91545: PUSH
91546: LD_VAR 0 10
91550: IN
91551: NOT
91552: AND
91553: IFFALSE 91592
// ComAttackPlace ( i , cr [ 1 ] [ 1 ] , cr [ 1 ] [ 2 ] ) else
91555: LD_VAR 0 4
91559: PPUSH
91560: LD_VAR 0 7
91564: PUSH
91565: LD_INT 1
91567: ARRAY
91568: PUSH
91569: LD_INT 1
91571: ARRAY
91572: PPUSH
91573: LD_VAR 0 7
91577: PUSH
91578: LD_INT 1
91580: ARRAY
91581: PUSH
91582: LD_INT 2
91584: ARRAY
91585: PPUSH
91586: CALL_OW 116
91590: GO 91799
// if path > tag then
91592: LD_VAR 0 2
91596: PUSH
91597: LD_VAR 0 9
91601: GREATER
91602: IFFALSE 91769
// begin nearEnemy := UnitFilter ( enemy , [ f_dist , i , 12 ] ) ;
91604: LD_ADDR_VAR 0 6
91608: PUSH
91609: LD_VAR 0 5
91613: PPUSH
91614: LD_INT 91
91616: PUSH
91617: LD_VAR 0 4
91621: PUSH
91622: LD_INT 12
91624: PUSH
91625: EMPTY
91626: LIST
91627: LIST
91628: LIST
91629: PPUSH
91630: CALL_OW 72
91634: ST_TO_ADDR
// if nearEnemy then
91635: LD_VAR 0 6
91639: IFFALSE 91667
// ComAttackUnit ( i , NearestUnitToUnit ( nearEnemy , i ) ) else
91641: LD_VAR 0 4
91645: PPUSH
91646: LD_VAR 0 6
91650: PPUSH
91651: LD_VAR 0 4
91655: PPUSH
91656: CALL_OW 74
91660: PPUSH
91661: CALL_OW 115
91665: GO 91767
// if GetDistUnitXY ( i , path [ tag ] [ 1 ] , path [ tag ] [ 2 ] ) > 6 then
91667: LD_VAR 0 4
91671: PPUSH
91672: LD_VAR 0 2
91676: PUSH
91677: LD_VAR 0 9
91681: ARRAY
91682: PUSH
91683: LD_INT 1
91685: ARRAY
91686: PPUSH
91687: LD_VAR 0 2
91691: PUSH
91692: LD_VAR 0 9
91696: ARRAY
91697: PUSH
91698: LD_INT 2
91700: ARRAY
91701: PPUSH
91702: CALL_OW 297
91706: PUSH
91707: LD_INT 6
91709: GREATER
91710: IFFALSE 91753
// ComAgressiveMove ( i , path [ tag ] [ 1 ] , path [ tag ] [ 2 ] ) else
91712: LD_VAR 0 4
91716: PPUSH
91717: LD_VAR 0 2
91721: PUSH
91722: LD_VAR 0 9
91726: ARRAY
91727: PUSH
91728: LD_INT 1
91730: ARRAY
91731: PPUSH
91732: LD_VAR 0 2
91736: PUSH
91737: LD_VAR 0 9
91741: ARRAY
91742: PUSH
91743: LD_INT 2
91745: ARRAY
91746: PPUSH
91747: CALL_OW 114
91751: GO 91767
// SetTag ( i , tag ) ;
91753: LD_VAR 0 4
91757: PPUSH
91758: LD_VAR 0 9
91762: PPUSH
91763: CALL_OW 109
// end else
91767: GO 91799
// if enemy then
91769: LD_VAR 0 5
91773: IFFALSE 91799
// ComAttackUnit ( i , NearestUnitToUnit ( enemy , i ) ) ;
91775: LD_VAR 0 4
91779: PPUSH
91780: LD_VAR 0 5
91784: PPUSH
91785: LD_VAR 0 4
91789: PPUSH
91790: CALL_OW 74
91794: PPUSH
91795: CALL_OW 115
// end ;
91799: GO 91476
91801: POP
91802: POP
// end ;
91803: LD_VAR 0 3
91807: RET
// export function ComLookAtDir ( unit , direction ) ; var x , y ; begin
91808: LD_INT 0
91810: PPUSH
91811: PPUSH
91812: PPUSH
// if not unit or IsInUnit ( unit ) then
91813: LD_VAR 0 1
91817: NOT
91818: PUSH
91819: LD_VAR 0 1
91823: PPUSH
91824: CALL_OW 310
91828: OR
91829: IFFALSE 91833
// exit ;
91831: GO 91924
// x := ShiftX ( GetX ( unit ) , direction , 1 ) ;
91833: LD_ADDR_VAR 0 4
91837: PUSH
91838: LD_VAR 0 1
91842: PPUSH
91843: CALL_OW 250
91847: PPUSH
91848: LD_VAR 0 2
91852: PPUSH
91853: LD_INT 1
91855: PPUSH
91856: CALL_OW 272
91860: ST_TO_ADDR
// y := ShiftY ( GetY ( unit ) , direction , 1 ) ;
91861: LD_ADDR_VAR 0 5
91865: PUSH
91866: LD_VAR 0 1
91870: PPUSH
91871: CALL_OW 251
91875: PPUSH
91876: LD_VAR 0 2
91880: PPUSH
91881: LD_INT 1
91883: PPUSH
91884: CALL_OW 273
91888: ST_TO_ADDR
// if ValidHex ( x , y ) then
91889: LD_VAR 0 4
91893: PPUSH
91894: LD_VAR 0 5
91898: PPUSH
91899: CALL_OW 488
91903: IFFALSE 91924
// ComTurnXY ( unit , x , y ) ;
91905: LD_VAR 0 1
91909: PPUSH
91910: LD_VAR 0 4
91914: PPUSH
91915: LD_VAR 0 5
91919: PPUSH
91920: CALL_OW 118
// end ;
91924: LD_VAR 0 3
91928: RET
// export function SeeUnits ( side , units ) ; var i ; begin
91929: LD_INT 0
91931: PPUSH
91932: PPUSH
// result := false ;
91933: LD_ADDR_VAR 0 3
91937: PUSH
91938: LD_INT 0
91940: ST_TO_ADDR
// if not units then
91941: LD_VAR 0 2
91945: NOT
91946: IFFALSE 91950
// exit ;
91948: GO 91995
// for i in units do
91950: LD_ADDR_VAR 0 4
91954: PUSH
91955: LD_VAR 0 2
91959: PUSH
91960: FOR_IN
91961: IFFALSE 91993
// if See ( side , i ) then
91963: LD_VAR 0 1
91967: PPUSH
91968: LD_VAR 0 4
91972: PPUSH
91973: CALL_OW 292
91977: IFFALSE 91991
// begin result := true ;
91979: LD_ADDR_VAR 0 3
91983: PUSH
91984: LD_INT 1
91986: ST_TO_ADDR
// exit ;
91987: POP
91988: POP
91989: GO 91995
// end ;
91991: GO 91960
91993: POP
91994: POP
// end ;
91995: LD_VAR 0 3
91999: RET
// export function GetNearestPoint ( unit , points ) ; var i , dist , tmpDist ; begin
92000: LD_INT 0
92002: PPUSH
92003: PPUSH
92004: PPUSH
92005: PPUSH
// if not unit or not points then
92006: LD_VAR 0 1
92010: NOT
92011: PUSH
92012: LD_VAR 0 2
92016: NOT
92017: OR
92018: IFFALSE 92022
// exit ;
92020: GO 92112
// dist := 99999 ;
92022: LD_ADDR_VAR 0 5
92026: PUSH
92027: LD_INT 99999
92029: ST_TO_ADDR
// for i in points do
92030: LD_ADDR_VAR 0 4
92034: PUSH
92035: LD_VAR 0 2
92039: PUSH
92040: FOR_IN
92041: IFFALSE 92110
// begin tmpDist := GetDistUnitXY ( unit , i [ 1 ] , i [ 2 ] ) ;
92043: LD_ADDR_VAR 0 6
92047: PUSH
92048: LD_VAR 0 1
92052: PPUSH
92053: LD_VAR 0 4
92057: PUSH
92058: LD_INT 1
92060: ARRAY
92061: PPUSH
92062: LD_VAR 0 4
92066: PUSH
92067: LD_INT 2
92069: ARRAY
92070: PPUSH
92071: CALL_OW 297
92075: ST_TO_ADDR
// if tmpDist < dist then
92076: LD_VAR 0 6
92080: PUSH
92081: LD_VAR 0 5
92085: LESS
92086: IFFALSE 92108
// begin result := i ;
92088: LD_ADDR_VAR 0 3
92092: PUSH
92093: LD_VAR 0 4
92097: ST_TO_ADDR
// dist := tmpDist ;
92098: LD_ADDR_VAR 0 5
92102: PUSH
92103: LD_VAR 0 6
92107: ST_TO_ADDR
// end ; end ;
92108: GO 92040
92110: POP
92111: POP
// end ; end_of_file end_of_file
92112: LD_VAR 0 3
92116: RET
// every 0 0$1 do
92117: GO 92119
92119: DISABLE
// begin enable ;
92120: ENABLE
// ToLua ( updateTimer( & tick & ); ) ;
92121: LD_STRING updateTimer(
92123: PUSH
92124: LD_OWVAR 1
92128: STR
92129: PUSH
92130: LD_STRING );
92132: STR
92133: PPUSH
92134: CALL_OW 559
// end ;
92138: END
// on MapStart ( p ) do begin if streamModeActive then
92139: LD_EXP 139
92143: IFFALSE 92152
// DefineStreamItems ( true ) ;
92145: LD_INT 1
92147: PPUSH
92148: CALL 93800 0 1
// UpdateFactoryWaypoints ( ) ;
92152: CALL 107384 0 0
// end ;
92156: PPOPN 1
92158: END
// export function SOS_CustomCommand ( p1 , p2 , p3 , p4 , p5 , p6 ) ; begin
92159: LD_INT 0
92161: PPUSH
// if p2 = 100 then
92162: LD_VAR 0 2
92166: PUSH
92167: LD_INT 100
92169: EQUAL
92170: IFFALSE 93173
// begin if not StreamModeActive then
92172: LD_EXP 139
92176: NOT
92177: IFFALSE 92187
// StreamModeActive := true ;
92179: LD_ADDR_EXP 139
92183: PUSH
92184: LD_INT 1
92186: ST_TO_ADDR
// if p3 = 0 then
92187: LD_VAR 0 3
92191: PUSH
92192: LD_INT 0
92194: EQUAL
92195: IFFALSE 92201
// InitStreamMode ;
92197: CALL 93336 0 0
// if p3 = 1 then
92201: LD_VAR 0 3
92205: PUSH
92206: LD_INT 1
92208: EQUAL
92209: IFFALSE 92219
// sRocket := true ;
92211: LD_ADDR_EXP 144
92215: PUSH
92216: LD_INT 1
92218: ST_TO_ADDR
// if p3 = 2 then
92219: LD_VAR 0 3
92223: PUSH
92224: LD_INT 2
92226: EQUAL
92227: IFFALSE 92237
// sSpeed := true ;
92229: LD_ADDR_EXP 143
92233: PUSH
92234: LD_INT 1
92236: ST_TO_ADDR
// if p3 = 3 then
92237: LD_VAR 0 3
92241: PUSH
92242: LD_INT 3
92244: EQUAL
92245: IFFALSE 92255
// sEngine := true ;
92247: LD_ADDR_EXP 145
92251: PUSH
92252: LD_INT 1
92254: ST_TO_ADDR
// if p3 = 4 then
92255: LD_VAR 0 3
92259: PUSH
92260: LD_INT 4
92262: EQUAL
92263: IFFALSE 92273
// sSpec := true ;
92265: LD_ADDR_EXP 142
92269: PUSH
92270: LD_INT 1
92272: ST_TO_ADDR
// if p3 = 5 then
92273: LD_VAR 0 3
92277: PUSH
92278: LD_INT 5
92280: EQUAL
92281: IFFALSE 92291
// sLevel := true ;
92283: LD_ADDR_EXP 146
92287: PUSH
92288: LD_INT 1
92290: ST_TO_ADDR
// if p3 = 6 then
92291: LD_VAR 0 3
92295: PUSH
92296: LD_INT 6
92298: EQUAL
92299: IFFALSE 92309
// sArmoury := true ;
92301: LD_ADDR_EXP 147
92305: PUSH
92306: LD_INT 1
92308: ST_TO_ADDR
// if p3 = 7 then
92309: LD_VAR 0 3
92313: PUSH
92314: LD_INT 7
92316: EQUAL
92317: IFFALSE 92327
// sRadar := true ;
92319: LD_ADDR_EXP 148
92323: PUSH
92324: LD_INT 1
92326: ST_TO_ADDR
// if p3 = 8 then
92327: LD_VAR 0 3
92331: PUSH
92332: LD_INT 8
92334: EQUAL
92335: IFFALSE 92345
// sBunker := true ;
92337: LD_ADDR_EXP 149
92341: PUSH
92342: LD_INT 1
92344: ST_TO_ADDR
// if p3 = 9 then
92345: LD_VAR 0 3
92349: PUSH
92350: LD_INT 9
92352: EQUAL
92353: IFFALSE 92363
// sHack := true ;
92355: LD_ADDR_EXP 150
92359: PUSH
92360: LD_INT 1
92362: ST_TO_ADDR
// if p3 = 10 then
92363: LD_VAR 0 3
92367: PUSH
92368: LD_INT 10
92370: EQUAL
92371: IFFALSE 92381
// sFire := true ;
92373: LD_ADDR_EXP 151
92377: PUSH
92378: LD_INT 1
92380: ST_TO_ADDR
// if p3 = 11 then
92381: LD_VAR 0 3
92385: PUSH
92386: LD_INT 11
92388: EQUAL
92389: IFFALSE 92399
// sRefresh := true ;
92391: LD_ADDR_EXP 152
92395: PUSH
92396: LD_INT 1
92398: ST_TO_ADDR
// if p3 = 12 then
92399: LD_VAR 0 3
92403: PUSH
92404: LD_INT 12
92406: EQUAL
92407: IFFALSE 92417
// sExp := true ;
92409: LD_ADDR_EXP 153
92413: PUSH
92414: LD_INT 1
92416: ST_TO_ADDR
// if p3 = 13 then
92417: LD_VAR 0 3
92421: PUSH
92422: LD_INT 13
92424: EQUAL
92425: IFFALSE 92435
// sDepot := true ;
92427: LD_ADDR_EXP 154
92431: PUSH
92432: LD_INT 1
92434: ST_TO_ADDR
// if p3 = 14 then
92435: LD_VAR 0 3
92439: PUSH
92440: LD_INT 14
92442: EQUAL
92443: IFFALSE 92453
// sFlag := true ;
92445: LD_ADDR_EXP 155
92449: PUSH
92450: LD_INT 1
92452: ST_TO_ADDR
// if p3 = 15 then
92453: LD_VAR 0 3
92457: PUSH
92458: LD_INT 15
92460: EQUAL
92461: IFFALSE 92471
// sKamikadze := true ;
92463: LD_ADDR_EXP 163
92467: PUSH
92468: LD_INT 1
92470: ST_TO_ADDR
// if p3 = 16 then
92471: LD_VAR 0 3
92475: PUSH
92476: LD_INT 16
92478: EQUAL
92479: IFFALSE 92489
// sTroll := true ;
92481: LD_ADDR_EXP 164
92485: PUSH
92486: LD_INT 1
92488: ST_TO_ADDR
// if p3 = 17 then
92489: LD_VAR 0 3
92493: PUSH
92494: LD_INT 17
92496: EQUAL
92497: IFFALSE 92507
// sSlow := true ;
92499: LD_ADDR_EXP 165
92503: PUSH
92504: LD_INT 1
92506: ST_TO_ADDR
// if p3 = 18 then
92507: LD_VAR 0 3
92511: PUSH
92512: LD_INT 18
92514: EQUAL
92515: IFFALSE 92525
// sLack := true ;
92517: LD_ADDR_EXP 166
92521: PUSH
92522: LD_INT 1
92524: ST_TO_ADDR
// if p3 = 19 then
92525: LD_VAR 0 3
92529: PUSH
92530: LD_INT 19
92532: EQUAL
92533: IFFALSE 92543
// sTank := true ;
92535: LD_ADDR_EXP 168
92539: PUSH
92540: LD_INT 1
92542: ST_TO_ADDR
// if p3 = 20 then
92543: LD_VAR 0 3
92547: PUSH
92548: LD_INT 20
92550: EQUAL
92551: IFFALSE 92561
// sRemote := true ;
92553: LD_ADDR_EXP 169
92557: PUSH
92558: LD_INT 1
92560: ST_TO_ADDR
// if p3 = 21 then
92561: LD_VAR 0 3
92565: PUSH
92566: LD_INT 21
92568: EQUAL
92569: IFFALSE 92579
// sPowell := true ;
92571: LD_ADDR_EXP 170
92575: PUSH
92576: LD_INT 1
92578: ST_TO_ADDR
// if p3 = 22 then
92579: LD_VAR 0 3
92583: PUSH
92584: LD_INT 22
92586: EQUAL
92587: IFFALSE 92597
// sTeleport := true ;
92589: LD_ADDR_EXP 173
92593: PUSH
92594: LD_INT 1
92596: ST_TO_ADDR
// if p3 = 23 then
92597: LD_VAR 0 3
92601: PUSH
92602: LD_INT 23
92604: EQUAL
92605: IFFALSE 92615
// sOilTower := true ;
92607: LD_ADDR_EXP 175
92611: PUSH
92612: LD_INT 1
92614: ST_TO_ADDR
// if p3 = 24 then
92615: LD_VAR 0 3
92619: PUSH
92620: LD_INT 24
92622: EQUAL
92623: IFFALSE 92633
// sShovel := true ;
92625: LD_ADDR_EXP 176
92629: PUSH
92630: LD_INT 1
92632: ST_TO_ADDR
// if p3 = 25 then
92633: LD_VAR 0 3
92637: PUSH
92638: LD_INT 25
92640: EQUAL
92641: IFFALSE 92651
// sSheik := true ;
92643: LD_ADDR_EXP 177
92647: PUSH
92648: LD_INT 1
92650: ST_TO_ADDR
// if p3 = 26 then
92651: LD_VAR 0 3
92655: PUSH
92656: LD_INT 26
92658: EQUAL
92659: IFFALSE 92669
// sEarthquake := true ;
92661: LD_ADDR_EXP 179
92665: PUSH
92666: LD_INT 1
92668: ST_TO_ADDR
// if p3 = 27 then
92669: LD_VAR 0 3
92673: PUSH
92674: LD_INT 27
92676: EQUAL
92677: IFFALSE 92687
// sAI := true ;
92679: LD_ADDR_EXP 180
92683: PUSH
92684: LD_INT 1
92686: ST_TO_ADDR
// if p3 = 28 then
92687: LD_VAR 0 3
92691: PUSH
92692: LD_INT 28
92694: EQUAL
92695: IFFALSE 92705
// sCargo := true ;
92697: LD_ADDR_EXP 183
92701: PUSH
92702: LD_INT 1
92704: ST_TO_ADDR
// if p3 = 29 then
92705: LD_VAR 0 3
92709: PUSH
92710: LD_INT 29
92712: EQUAL
92713: IFFALSE 92723
// sDLaser := true ;
92715: LD_ADDR_EXP 184
92719: PUSH
92720: LD_INT 1
92722: ST_TO_ADDR
// if p3 = 30 then
92723: LD_VAR 0 3
92727: PUSH
92728: LD_INT 30
92730: EQUAL
92731: IFFALSE 92741
// sExchange := true ;
92733: LD_ADDR_EXP 185
92737: PUSH
92738: LD_INT 1
92740: ST_TO_ADDR
// if p3 = 31 then
92741: LD_VAR 0 3
92745: PUSH
92746: LD_INT 31
92748: EQUAL
92749: IFFALSE 92759
// sFac := true ;
92751: LD_ADDR_EXP 186
92755: PUSH
92756: LD_INT 1
92758: ST_TO_ADDR
// if p3 = 32 then
92759: LD_VAR 0 3
92763: PUSH
92764: LD_INT 32
92766: EQUAL
92767: IFFALSE 92777
// sPower := true ;
92769: LD_ADDR_EXP 187
92773: PUSH
92774: LD_INT 1
92776: ST_TO_ADDR
// if p3 = 33 then
92777: LD_VAR 0 3
92781: PUSH
92782: LD_INT 33
92784: EQUAL
92785: IFFALSE 92795
// sRandom := true ;
92787: LD_ADDR_EXP 188
92791: PUSH
92792: LD_INT 1
92794: ST_TO_ADDR
// if p3 = 34 then
92795: LD_VAR 0 3
92799: PUSH
92800: LD_INT 34
92802: EQUAL
92803: IFFALSE 92813
// sShield := true ;
92805: LD_ADDR_EXP 189
92809: PUSH
92810: LD_INT 1
92812: ST_TO_ADDR
// if p3 = 35 then
92813: LD_VAR 0 3
92817: PUSH
92818: LD_INT 35
92820: EQUAL
92821: IFFALSE 92831
// sTime := true ;
92823: LD_ADDR_EXP 190
92827: PUSH
92828: LD_INT 1
92830: ST_TO_ADDR
// if p3 = 36 then
92831: LD_VAR 0 3
92835: PUSH
92836: LD_INT 36
92838: EQUAL
92839: IFFALSE 92849
// sTools := true ;
92841: LD_ADDR_EXP 191
92845: PUSH
92846: LD_INT 1
92848: ST_TO_ADDR
// if p3 = 101 then
92849: LD_VAR 0 3
92853: PUSH
92854: LD_INT 101
92856: EQUAL
92857: IFFALSE 92867
// sSold := true ;
92859: LD_ADDR_EXP 156
92863: PUSH
92864: LD_INT 1
92866: ST_TO_ADDR
// if p3 = 102 then
92867: LD_VAR 0 3
92871: PUSH
92872: LD_INT 102
92874: EQUAL
92875: IFFALSE 92885
// sDiff := true ;
92877: LD_ADDR_EXP 157
92881: PUSH
92882: LD_INT 1
92884: ST_TO_ADDR
// if p3 = 103 then
92885: LD_VAR 0 3
92889: PUSH
92890: LD_INT 103
92892: EQUAL
92893: IFFALSE 92903
// sFog := true ;
92895: LD_ADDR_EXP 160
92899: PUSH
92900: LD_INT 1
92902: ST_TO_ADDR
// if p3 = 104 then
92903: LD_VAR 0 3
92907: PUSH
92908: LD_INT 104
92910: EQUAL
92911: IFFALSE 92921
// sReset := true ;
92913: LD_ADDR_EXP 161
92917: PUSH
92918: LD_INT 1
92920: ST_TO_ADDR
// if p3 = 105 then
92921: LD_VAR 0 3
92925: PUSH
92926: LD_INT 105
92928: EQUAL
92929: IFFALSE 92939
// sSun := true ;
92931: LD_ADDR_EXP 162
92935: PUSH
92936: LD_INT 1
92938: ST_TO_ADDR
// if p3 = 106 then
92939: LD_VAR 0 3
92943: PUSH
92944: LD_INT 106
92946: EQUAL
92947: IFFALSE 92957
// sTiger := true ;
92949: LD_ADDR_EXP 158
92953: PUSH
92954: LD_INT 1
92956: ST_TO_ADDR
// if p3 = 107 then
92957: LD_VAR 0 3
92961: PUSH
92962: LD_INT 107
92964: EQUAL
92965: IFFALSE 92975
// sBomb := true ;
92967: LD_ADDR_EXP 159
92971: PUSH
92972: LD_INT 1
92974: ST_TO_ADDR
// if p3 = 108 then
92975: LD_VAR 0 3
92979: PUSH
92980: LD_INT 108
92982: EQUAL
92983: IFFALSE 92993
// sWound := true ;
92985: LD_ADDR_EXP 167
92989: PUSH
92990: LD_INT 1
92992: ST_TO_ADDR
// if p3 = 109 then
92993: LD_VAR 0 3
92997: PUSH
92998: LD_INT 109
93000: EQUAL
93001: IFFALSE 93011
// sBetray := true ;
93003: LD_ADDR_EXP 171
93007: PUSH
93008: LD_INT 1
93010: ST_TO_ADDR
// if p3 = 110 then
93011: LD_VAR 0 3
93015: PUSH
93016: LD_INT 110
93018: EQUAL
93019: IFFALSE 93029
// sContamin := true ;
93021: LD_ADDR_EXP 172
93025: PUSH
93026: LD_INT 1
93028: ST_TO_ADDR
// if p3 = 111 then
93029: LD_VAR 0 3
93033: PUSH
93034: LD_INT 111
93036: EQUAL
93037: IFFALSE 93047
// sOil := true ;
93039: LD_ADDR_EXP 174
93043: PUSH
93044: LD_INT 1
93046: ST_TO_ADDR
// if p3 = 112 then
93047: LD_VAR 0 3
93051: PUSH
93052: LD_INT 112
93054: EQUAL
93055: IFFALSE 93065
// sStu := true ;
93057: LD_ADDR_EXP 178
93061: PUSH
93062: LD_INT 1
93064: ST_TO_ADDR
// if p3 = 113 then
93065: LD_VAR 0 3
93069: PUSH
93070: LD_INT 113
93072: EQUAL
93073: IFFALSE 93083
// sBazooka := true ;
93075: LD_ADDR_EXP 181
93079: PUSH
93080: LD_INT 1
93082: ST_TO_ADDR
// if p3 = 114 then
93083: LD_VAR 0 3
93087: PUSH
93088: LD_INT 114
93090: EQUAL
93091: IFFALSE 93101
// sMortar := true ;
93093: LD_ADDR_EXP 182
93097: PUSH
93098: LD_INT 1
93100: ST_TO_ADDR
// if p3 = 115 then
93101: LD_VAR 0 3
93105: PUSH
93106: LD_INT 115
93108: EQUAL
93109: IFFALSE 93119
// sRanger := true ;
93111: LD_ADDR_EXP 192
93115: PUSH
93116: LD_INT 1
93118: ST_TO_ADDR
// if p3 = 116 then
93119: LD_VAR 0 3
93123: PUSH
93124: LD_INT 116
93126: EQUAL
93127: IFFALSE 93137
// sComputer := true ;
93129: LD_ADDR_EXP 193
93133: PUSH
93134: LD_INT 1
93136: ST_TO_ADDR
// if p3 = 117 then
93137: LD_VAR 0 3
93141: PUSH
93142: LD_INT 117
93144: EQUAL
93145: IFFALSE 93155
// s30 := true ;
93147: LD_ADDR_EXP 194
93151: PUSH
93152: LD_INT 1
93154: ST_TO_ADDR
// if p3 = 118 then
93155: LD_VAR 0 3
93159: PUSH
93160: LD_INT 118
93162: EQUAL
93163: IFFALSE 93173
// s60 := true ;
93165: LD_ADDR_EXP 195
93169: PUSH
93170: LD_INT 1
93172: ST_TO_ADDR
// end ; if p2 = 101 then
93173: LD_VAR 0 2
93177: PUSH
93178: LD_INT 101
93180: EQUAL
93181: IFFALSE 93309
// begin case p3 of 1 :
93183: LD_VAR 0 3
93187: PUSH
93188: LD_INT 1
93190: DOUBLE
93191: EQUAL
93192: IFTRUE 93196
93194: GO 93203
93196: POP
// hHackUnlimitedResources ; 2 :
93197: CALL 105407 0 0
93201: GO 93309
93203: LD_INT 2
93205: DOUBLE
93206: EQUAL
93207: IFTRUE 93211
93209: GO 93218
93211: POP
// hHackSetLevel10 ; 3 :
93212: CALL 105540 0 0
93216: GO 93309
93218: LD_INT 3
93220: DOUBLE
93221: EQUAL
93222: IFTRUE 93226
93224: GO 93233
93226: POP
// hHackSetLevel10YourUnits ; 4 :
93227: CALL 105625 0 0
93231: GO 93309
93233: LD_INT 4
93235: DOUBLE
93236: EQUAL
93237: IFTRUE 93241
93239: GO 93248
93241: POP
// hHackInvincible ; 5 :
93242: CALL 106073 0 0
93246: GO 93309
93248: LD_INT 5
93250: DOUBLE
93251: EQUAL
93252: IFTRUE 93256
93254: GO 93263
93256: POP
// hHackInvisible ; 6 :
93257: CALL 106184 0 0
93261: GO 93309
93263: LD_INT 6
93265: DOUBLE
93266: EQUAL
93267: IFTRUE 93271
93269: GO 93278
93271: POP
// hHackChangeYourSide ; 7 :
93272: CALL 106241 0 0
93276: GO 93309
93278: LD_INT 7
93280: DOUBLE
93281: EQUAL
93282: IFTRUE 93286
93284: GO 93293
93286: POP
// hHackChangeUnitSide ; 8 :
93287: CALL 106283 0 0
93291: GO 93309
93293: LD_INT 8
93295: DOUBLE
93296: EQUAL
93297: IFTRUE 93301
93299: GO 93308
93301: POP
// hHackFog ; end ;
93302: CALL 106384 0 0
93306: GO 93309
93308: POP
// end ; end ;
93309: LD_VAR 0 7
93313: RET
// export StreamModeActive , normalCounter , hardcoreCounter , sSpec , sSpeed , sRocket , sEngine , sLevel , sArmoury , sRadar , sBunker , sHack , sFire , sRefresh , sExp , sDepot , sFlag , sSold , sDiff , sTiger , sBomb , sFog , sReset , sSun , sKamikadze , sTroll , sSlow , sLack , sWound , sTank , sRemote , sPowell , sBetray , sContamin , sTeleport , sOil , sOilTower , sShovel , sSheik , sStu , sEarthquake , sAI , sBazooka , sMortar , sCargo , sDLaser , sExchange , sFac , sPower , sRandom , sShield , sTime , sTools , sRanger , sComputer , s30 , s60 ; every 0 0$1 do
93314: GO 93316
93316: DISABLE
// begin ToLua ( initStreamRollete(); ) ;
93317: LD_STRING initStreamRollete();
93319: PPUSH
93320: CALL_OW 559
// InitStreamMode ;
93324: CALL 93336 0 0
// DefineStreamItems ( false ) ;
93328: LD_INT 0
93330: PPUSH
93331: CALL 93800 0 1
// end ;
93335: END
// function InitStreamMode ; begin
93336: LD_INT 0
93338: PPUSH
// streamModeActive := false ;
93339: LD_ADDR_EXP 139
93343: PUSH
93344: LD_INT 0
93346: ST_TO_ADDR
// normalCounter := 36 ;
93347: LD_ADDR_EXP 140
93351: PUSH
93352: LD_INT 36
93354: ST_TO_ADDR
// hardcoreCounter := 18 ;
93355: LD_ADDR_EXP 141
93359: PUSH
93360: LD_INT 18
93362: ST_TO_ADDR
// sRocket := false ;
93363: LD_ADDR_EXP 144
93367: PUSH
93368: LD_INT 0
93370: ST_TO_ADDR
// sSpeed := false ;
93371: LD_ADDR_EXP 143
93375: PUSH
93376: LD_INT 0
93378: ST_TO_ADDR
// sEngine := false ;
93379: LD_ADDR_EXP 145
93383: PUSH
93384: LD_INT 0
93386: ST_TO_ADDR
// sSpec := false ;
93387: LD_ADDR_EXP 142
93391: PUSH
93392: LD_INT 0
93394: ST_TO_ADDR
// sLevel := false ;
93395: LD_ADDR_EXP 146
93399: PUSH
93400: LD_INT 0
93402: ST_TO_ADDR
// sArmoury := false ;
93403: LD_ADDR_EXP 147
93407: PUSH
93408: LD_INT 0
93410: ST_TO_ADDR
// sRadar := false ;
93411: LD_ADDR_EXP 148
93415: PUSH
93416: LD_INT 0
93418: ST_TO_ADDR
// sBunker := false ;
93419: LD_ADDR_EXP 149
93423: PUSH
93424: LD_INT 0
93426: ST_TO_ADDR
// sHack := false ;
93427: LD_ADDR_EXP 150
93431: PUSH
93432: LD_INT 0
93434: ST_TO_ADDR
// sFire := false ;
93435: LD_ADDR_EXP 151
93439: PUSH
93440: LD_INT 0
93442: ST_TO_ADDR
// sRefresh := false ;
93443: LD_ADDR_EXP 152
93447: PUSH
93448: LD_INT 0
93450: ST_TO_ADDR
// sExp := false ;
93451: LD_ADDR_EXP 153
93455: PUSH
93456: LD_INT 0
93458: ST_TO_ADDR
// sDepot := false ;
93459: LD_ADDR_EXP 154
93463: PUSH
93464: LD_INT 0
93466: ST_TO_ADDR
// sFlag := false ;
93467: LD_ADDR_EXP 155
93471: PUSH
93472: LD_INT 0
93474: ST_TO_ADDR
// sKamikadze := false ;
93475: LD_ADDR_EXP 163
93479: PUSH
93480: LD_INT 0
93482: ST_TO_ADDR
// sTroll := false ;
93483: LD_ADDR_EXP 164
93487: PUSH
93488: LD_INT 0
93490: ST_TO_ADDR
// sSlow := false ;
93491: LD_ADDR_EXP 165
93495: PUSH
93496: LD_INT 0
93498: ST_TO_ADDR
// sLack := false ;
93499: LD_ADDR_EXP 166
93503: PUSH
93504: LD_INT 0
93506: ST_TO_ADDR
// sTank := false ;
93507: LD_ADDR_EXP 168
93511: PUSH
93512: LD_INT 0
93514: ST_TO_ADDR
// sRemote := false ;
93515: LD_ADDR_EXP 169
93519: PUSH
93520: LD_INT 0
93522: ST_TO_ADDR
// sPowell := false ;
93523: LD_ADDR_EXP 170
93527: PUSH
93528: LD_INT 0
93530: ST_TO_ADDR
// sTeleport := false ;
93531: LD_ADDR_EXP 173
93535: PUSH
93536: LD_INT 0
93538: ST_TO_ADDR
// sOilTower := false ;
93539: LD_ADDR_EXP 175
93543: PUSH
93544: LD_INT 0
93546: ST_TO_ADDR
// sShovel := false ;
93547: LD_ADDR_EXP 176
93551: PUSH
93552: LD_INT 0
93554: ST_TO_ADDR
// sSheik := false ;
93555: LD_ADDR_EXP 177
93559: PUSH
93560: LD_INT 0
93562: ST_TO_ADDR
// sEarthquake := false ;
93563: LD_ADDR_EXP 179
93567: PUSH
93568: LD_INT 0
93570: ST_TO_ADDR
// sAI := false ;
93571: LD_ADDR_EXP 180
93575: PUSH
93576: LD_INT 0
93578: ST_TO_ADDR
// sCargo := false ;
93579: LD_ADDR_EXP 183
93583: PUSH
93584: LD_INT 0
93586: ST_TO_ADDR
// sDLaser := false ;
93587: LD_ADDR_EXP 184
93591: PUSH
93592: LD_INT 0
93594: ST_TO_ADDR
// sExchange := false ;
93595: LD_ADDR_EXP 185
93599: PUSH
93600: LD_INT 0
93602: ST_TO_ADDR
// sFac := false ;
93603: LD_ADDR_EXP 186
93607: PUSH
93608: LD_INT 0
93610: ST_TO_ADDR
// sPower := false ;
93611: LD_ADDR_EXP 187
93615: PUSH
93616: LD_INT 0
93618: ST_TO_ADDR
// sRandom := false ;
93619: LD_ADDR_EXP 188
93623: PUSH
93624: LD_INT 0
93626: ST_TO_ADDR
// sShield := false ;
93627: LD_ADDR_EXP 189
93631: PUSH
93632: LD_INT 0
93634: ST_TO_ADDR
// sTime := false ;
93635: LD_ADDR_EXP 190
93639: PUSH
93640: LD_INT 0
93642: ST_TO_ADDR
// sTools := false ;
93643: LD_ADDR_EXP 191
93647: PUSH
93648: LD_INT 0
93650: ST_TO_ADDR
// sSold := false ;
93651: LD_ADDR_EXP 156
93655: PUSH
93656: LD_INT 0
93658: ST_TO_ADDR
// sDiff := false ;
93659: LD_ADDR_EXP 157
93663: PUSH
93664: LD_INT 0
93666: ST_TO_ADDR
// sFog := false ;
93667: LD_ADDR_EXP 160
93671: PUSH
93672: LD_INT 0
93674: ST_TO_ADDR
// sReset := false ;
93675: LD_ADDR_EXP 161
93679: PUSH
93680: LD_INT 0
93682: ST_TO_ADDR
// sSun := false ;
93683: LD_ADDR_EXP 162
93687: PUSH
93688: LD_INT 0
93690: ST_TO_ADDR
// sTiger := false ;
93691: LD_ADDR_EXP 158
93695: PUSH
93696: LD_INT 0
93698: ST_TO_ADDR
// sBomb := false ;
93699: LD_ADDR_EXP 159
93703: PUSH
93704: LD_INT 0
93706: ST_TO_ADDR
// sWound := false ;
93707: LD_ADDR_EXP 167
93711: PUSH
93712: LD_INT 0
93714: ST_TO_ADDR
// sBetray := false ;
93715: LD_ADDR_EXP 171
93719: PUSH
93720: LD_INT 0
93722: ST_TO_ADDR
// sContamin := false ;
93723: LD_ADDR_EXP 172
93727: PUSH
93728: LD_INT 0
93730: ST_TO_ADDR
// sOil := false ;
93731: LD_ADDR_EXP 174
93735: PUSH
93736: LD_INT 0
93738: ST_TO_ADDR
// sStu := false ;
93739: LD_ADDR_EXP 178
93743: PUSH
93744: LD_INT 0
93746: ST_TO_ADDR
// sBazooka := false ;
93747: LD_ADDR_EXP 181
93751: PUSH
93752: LD_INT 0
93754: ST_TO_ADDR
// sMortar := false ;
93755: LD_ADDR_EXP 182
93759: PUSH
93760: LD_INT 0
93762: ST_TO_ADDR
// sRanger := false ;
93763: LD_ADDR_EXP 192
93767: PUSH
93768: LD_INT 0
93770: ST_TO_ADDR
// sComputer := false ;
93771: LD_ADDR_EXP 193
93775: PUSH
93776: LD_INT 0
93778: ST_TO_ADDR
// s30 := false ;
93779: LD_ADDR_EXP 194
93783: PUSH
93784: LD_INT 0
93786: ST_TO_ADDR
// s60 := false ;
93787: LD_ADDR_EXP 195
93791: PUSH
93792: LD_INT 0
93794: ST_TO_ADDR
// end ;
93795: LD_VAR 0 1
93799: RET
// function DefineStreamItems ( isGameLoad ) ; var tmp , flags , normal , hardcore , active , i ; begin
93800: LD_INT 0
93802: PPUSH
93803: PPUSH
93804: PPUSH
93805: PPUSH
93806: PPUSH
93807: PPUSH
93808: PPUSH
// result := [ ] ;
93809: LD_ADDR_VAR 0 2
93813: PUSH
93814: EMPTY
93815: ST_TO_ADDR
// if campaign_id = 1 then
93816: LD_OWVAR 69
93820: PUSH
93821: LD_INT 1
93823: EQUAL
93824: IFFALSE 96990
// begin case mission_number of 1 :
93826: LD_OWVAR 70
93830: PUSH
93831: LD_INT 1
93833: DOUBLE
93834: EQUAL
93835: IFTRUE 93839
93837: GO 93915
93839: POP
// result := [ [ 2 , 4 , 11 , 12 , 15 , 16 , 22 , 23 , 26 ] , [ 101 , 102 , 106 , 116 , 117 , 118 ] ] ; 2 :
93840: LD_ADDR_VAR 0 2
93844: PUSH
93845: LD_INT 2
93847: PUSH
93848: LD_INT 4
93850: PUSH
93851: LD_INT 11
93853: PUSH
93854: LD_INT 12
93856: PUSH
93857: LD_INT 15
93859: PUSH
93860: LD_INT 16
93862: PUSH
93863: LD_INT 22
93865: PUSH
93866: LD_INT 23
93868: PUSH
93869: LD_INT 26
93871: PUSH
93872: EMPTY
93873: LIST
93874: LIST
93875: LIST
93876: LIST
93877: LIST
93878: LIST
93879: LIST
93880: LIST
93881: LIST
93882: PUSH
93883: LD_INT 101
93885: PUSH
93886: LD_INT 102
93888: PUSH
93889: LD_INT 106
93891: PUSH
93892: LD_INT 116
93894: PUSH
93895: LD_INT 117
93897: PUSH
93898: LD_INT 118
93900: PUSH
93901: EMPTY
93902: LIST
93903: LIST
93904: LIST
93905: LIST
93906: LIST
93907: LIST
93908: PUSH
93909: EMPTY
93910: LIST
93911: LIST
93912: ST_TO_ADDR
93913: GO 96988
93915: LD_INT 2
93917: DOUBLE
93918: EQUAL
93919: IFTRUE 93923
93921: GO 94007
93923: POP
// result := [ [ 2 , 4 , 11 , 12 , 15 , 16 , 22 , 23 , 26 ] , [ 101 , 102 , 105 , 106 , 108 , 116 , 117 , 118 ] ] ; 3 :
93924: LD_ADDR_VAR 0 2
93928: PUSH
93929: LD_INT 2
93931: PUSH
93932: LD_INT 4
93934: PUSH
93935: LD_INT 11
93937: PUSH
93938: LD_INT 12
93940: PUSH
93941: LD_INT 15
93943: PUSH
93944: LD_INT 16
93946: PUSH
93947: LD_INT 22
93949: PUSH
93950: LD_INT 23
93952: PUSH
93953: LD_INT 26
93955: PUSH
93956: EMPTY
93957: LIST
93958: LIST
93959: LIST
93960: LIST
93961: LIST
93962: LIST
93963: LIST
93964: LIST
93965: LIST
93966: PUSH
93967: LD_INT 101
93969: PUSH
93970: LD_INT 102
93972: PUSH
93973: LD_INT 105
93975: PUSH
93976: LD_INT 106
93978: PUSH
93979: LD_INT 108
93981: PUSH
93982: LD_INT 116
93984: PUSH
93985: LD_INT 117
93987: PUSH
93988: LD_INT 118
93990: PUSH
93991: EMPTY
93992: LIST
93993: LIST
93994: LIST
93995: LIST
93996: LIST
93997: LIST
93998: LIST
93999: LIST
94000: PUSH
94001: EMPTY
94002: LIST
94003: LIST
94004: ST_TO_ADDR
94005: GO 96988
94007: LD_INT 3
94009: DOUBLE
94010: EQUAL
94011: IFTRUE 94015
94013: GO 94103
94015: POP
// result := [ [ 2 , 4 , 5 , 11 , 12 , 15 , 16 , 22 , 26 , 36 ] , [ 101 , 102 , 105 , 106 , 108 , 116 , 117 , 118 ] ] ; 4 :
94016: LD_ADDR_VAR 0 2
94020: PUSH
94021: LD_INT 2
94023: PUSH
94024: LD_INT 4
94026: PUSH
94027: LD_INT 5
94029: PUSH
94030: LD_INT 11
94032: PUSH
94033: LD_INT 12
94035: PUSH
94036: LD_INT 15
94038: PUSH
94039: LD_INT 16
94041: PUSH
94042: LD_INT 22
94044: PUSH
94045: LD_INT 26
94047: PUSH
94048: LD_INT 36
94050: PUSH
94051: EMPTY
94052: LIST
94053: LIST
94054: LIST
94055: LIST
94056: LIST
94057: LIST
94058: LIST
94059: LIST
94060: LIST
94061: LIST
94062: PUSH
94063: LD_INT 101
94065: PUSH
94066: LD_INT 102
94068: PUSH
94069: LD_INT 105
94071: PUSH
94072: LD_INT 106
94074: PUSH
94075: LD_INT 108
94077: PUSH
94078: LD_INT 116
94080: PUSH
94081: LD_INT 117
94083: PUSH
94084: LD_INT 118
94086: PUSH
94087: EMPTY
94088: LIST
94089: LIST
94090: LIST
94091: LIST
94092: LIST
94093: LIST
94094: LIST
94095: LIST
94096: PUSH
94097: EMPTY
94098: LIST
94099: LIST
94100: ST_TO_ADDR
94101: GO 96988
94103: LD_INT 4
94105: DOUBLE
94106: EQUAL
94107: IFTRUE 94111
94109: GO 94207
94111: POP
// result := [ [ 2 , 4 , 5 , 8 , 11 , 12 , 15 , 16 , 22 , 23 , 26 , 36 ] , [ 101 , 102 , 105 , 106 , 108 , 116 , 117 , 118 ] ] ; 5 :
94112: LD_ADDR_VAR 0 2
94116: PUSH
94117: LD_INT 2
94119: PUSH
94120: LD_INT 4
94122: PUSH
94123: LD_INT 5
94125: PUSH
94126: LD_INT 8
94128: PUSH
94129: LD_INT 11
94131: PUSH
94132: LD_INT 12
94134: PUSH
94135: LD_INT 15
94137: PUSH
94138: LD_INT 16
94140: PUSH
94141: LD_INT 22
94143: PUSH
94144: LD_INT 23
94146: PUSH
94147: LD_INT 26
94149: PUSH
94150: LD_INT 36
94152: PUSH
94153: EMPTY
94154: LIST
94155: LIST
94156: LIST
94157: LIST
94158: LIST
94159: LIST
94160: LIST
94161: LIST
94162: LIST
94163: LIST
94164: LIST
94165: LIST
94166: PUSH
94167: LD_INT 101
94169: PUSH
94170: LD_INT 102
94172: PUSH
94173: LD_INT 105
94175: PUSH
94176: LD_INT 106
94178: PUSH
94179: LD_INT 108
94181: PUSH
94182: LD_INT 116
94184: PUSH
94185: LD_INT 117
94187: PUSH
94188: LD_INT 118
94190: PUSH
94191: EMPTY
94192: LIST
94193: LIST
94194: LIST
94195: LIST
94196: LIST
94197: LIST
94198: LIST
94199: LIST
94200: PUSH
94201: EMPTY
94202: LIST
94203: LIST
94204: ST_TO_ADDR
94205: GO 96988
94207: LD_INT 5
94209: DOUBLE
94210: EQUAL
94211: IFTRUE 94215
94213: GO 94327
94215: POP
// result := [ [ 2 , 4 , 5 , 6 , 8 , 11 , 12 , 15 , 16 , 22 , 23 , 25 , 26 , 36 ] , [ 101 , 102 , 105 , 106 , 108 , 109 , 112 , 116 , 117 , 118 ] ] ; 6 :
94216: LD_ADDR_VAR 0 2
94220: PUSH
94221: LD_INT 2
94223: PUSH
94224: LD_INT 4
94226: PUSH
94227: LD_INT 5
94229: PUSH
94230: LD_INT 6
94232: PUSH
94233: LD_INT 8
94235: PUSH
94236: LD_INT 11
94238: PUSH
94239: LD_INT 12
94241: PUSH
94242: LD_INT 15
94244: PUSH
94245: LD_INT 16
94247: PUSH
94248: LD_INT 22
94250: PUSH
94251: LD_INT 23
94253: PUSH
94254: LD_INT 25
94256: PUSH
94257: LD_INT 26
94259: PUSH
94260: LD_INT 36
94262: PUSH
94263: EMPTY
94264: LIST
94265: LIST
94266: LIST
94267: LIST
94268: LIST
94269: LIST
94270: LIST
94271: LIST
94272: LIST
94273: LIST
94274: LIST
94275: LIST
94276: LIST
94277: LIST
94278: PUSH
94279: LD_INT 101
94281: PUSH
94282: LD_INT 102
94284: PUSH
94285: LD_INT 105
94287: PUSH
94288: LD_INT 106
94290: PUSH
94291: LD_INT 108
94293: PUSH
94294: LD_INT 109
94296: PUSH
94297: LD_INT 112
94299: PUSH
94300: LD_INT 116
94302: PUSH
94303: LD_INT 117
94305: PUSH
94306: LD_INT 118
94308: PUSH
94309: EMPTY
94310: LIST
94311: LIST
94312: LIST
94313: LIST
94314: LIST
94315: LIST
94316: LIST
94317: LIST
94318: LIST
94319: LIST
94320: PUSH
94321: EMPTY
94322: LIST
94323: LIST
94324: ST_TO_ADDR
94325: GO 96988
94327: LD_INT 6
94329: DOUBLE
94330: EQUAL
94331: IFTRUE 94335
94333: GO 94467
94335: POP
// result := [ [ 2 , 4 , 5 , 6 , 8 , 11 , 12 , 15 , 16 , 20 , 21 , 22 , 23 , 25 , 26 , 30 , 31 , 32 , 36 ] , [ 101 , 102 , 105 , 106 , 108 , 109 , 112 , 116 , 117 , 118 ] ] ; 7 :
94336: LD_ADDR_VAR 0 2
94340: PUSH
94341: LD_INT 2
94343: PUSH
94344: LD_INT 4
94346: PUSH
94347: LD_INT 5
94349: PUSH
94350: LD_INT 6
94352: PUSH
94353: LD_INT 8
94355: PUSH
94356: LD_INT 11
94358: PUSH
94359: LD_INT 12
94361: PUSH
94362: LD_INT 15
94364: PUSH
94365: LD_INT 16
94367: PUSH
94368: LD_INT 20
94370: PUSH
94371: LD_INT 21
94373: PUSH
94374: LD_INT 22
94376: PUSH
94377: LD_INT 23
94379: PUSH
94380: LD_INT 25
94382: PUSH
94383: LD_INT 26
94385: PUSH
94386: LD_INT 30
94388: PUSH
94389: LD_INT 31
94391: PUSH
94392: LD_INT 32
94394: PUSH
94395: LD_INT 36
94397: PUSH
94398: EMPTY
94399: LIST
94400: LIST
94401: LIST
94402: LIST
94403: LIST
94404: LIST
94405: LIST
94406: LIST
94407: LIST
94408: LIST
94409: LIST
94410: LIST
94411: LIST
94412: LIST
94413: LIST
94414: LIST
94415: LIST
94416: LIST
94417: LIST
94418: PUSH
94419: LD_INT 101
94421: PUSH
94422: LD_INT 102
94424: PUSH
94425: LD_INT 105
94427: PUSH
94428: LD_INT 106
94430: PUSH
94431: LD_INT 108
94433: PUSH
94434: LD_INT 109
94436: PUSH
94437: LD_INT 112
94439: PUSH
94440: LD_INT 116
94442: PUSH
94443: LD_INT 117
94445: PUSH
94446: LD_INT 118
94448: PUSH
94449: EMPTY
94450: LIST
94451: LIST
94452: LIST
94453: LIST
94454: LIST
94455: LIST
94456: LIST
94457: LIST
94458: LIST
94459: LIST
94460: PUSH
94461: EMPTY
94462: LIST
94463: LIST
94464: ST_TO_ADDR
94465: GO 96988
94467: LD_INT 7
94469: DOUBLE
94470: EQUAL
94471: IFTRUE 94475
94473: GO 94587
94475: POP
// result := [ [ 2 , 4 , 5 , 7 , 11 , 12 , 15 , 16 , 20 , 21 , 22 , 23 , 25 , 26 ] , [ 101 , 102 , 103 , 105 , 106 , 108 , 112 , 116 , 117 , 118 ] ] ; 8 :
94476: LD_ADDR_VAR 0 2
94480: PUSH
94481: LD_INT 2
94483: PUSH
94484: LD_INT 4
94486: PUSH
94487: LD_INT 5
94489: PUSH
94490: LD_INT 7
94492: PUSH
94493: LD_INT 11
94495: PUSH
94496: LD_INT 12
94498: PUSH
94499: LD_INT 15
94501: PUSH
94502: LD_INT 16
94504: PUSH
94505: LD_INT 20
94507: PUSH
94508: LD_INT 21
94510: PUSH
94511: LD_INT 22
94513: PUSH
94514: LD_INT 23
94516: PUSH
94517: LD_INT 25
94519: PUSH
94520: LD_INT 26
94522: PUSH
94523: EMPTY
94524: LIST
94525: LIST
94526: LIST
94527: LIST
94528: LIST
94529: LIST
94530: LIST
94531: LIST
94532: LIST
94533: LIST
94534: LIST
94535: LIST
94536: LIST
94537: LIST
94538: PUSH
94539: LD_INT 101
94541: PUSH
94542: LD_INT 102
94544: PUSH
94545: LD_INT 103
94547: PUSH
94548: LD_INT 105
94550: PUSH
94551: LD_INT 106
94553: PUSH
94554: LD_INT 108
94556: PUSH
94557: LD_INT 112
94559: PUSH
94560: LD_INT 116
94562: PUSH
94563: LD_INT 117
94565: PUSH
94566: LD_INT 118
94568: PUSH
94569: EMPTY
94570: LIST
94571: LIST
94572: LIST
94573: LIST
94574: LIST
94575: LIST
94576: LIST
94577: LIST
94578: LIST
94579: LIST
94580: PUSH
94581: EMPTY
94582: LIST
94583: LIST
94584: ST_TO_ADDR
94585: GO 96988
94587: LD_INT 8
94589: DOUBLE
94590: EQUAL
94591: IFTRUE 94595
94593: GO 94735
94595: POP
// result := [ [ 2 , 4 , 5 , 6 , 7 , 8 , 11 , 12 , 15 , 16 , 20 , 21 , 22 , 23 , 25 , 26 , 30 , 31 , 32 , 36 ] , [ 101 , 102 , 103 , 105 , 106 , 108 , 109 , 112 , 116 , 117 , 118 ] ] ; 9 :
94596: LD_ADDR_VAR 0 2
94600: PUSH
94601: LD_INT 2
94603: PUSH
94604: LD_INT 4
94606: PUSH
94607: LD_INT 5
94609: PUSH
94610: LD_INT 6
94612: PUSH
94613: LD_INT 7
94615: PUSH
94616: LD_INT 8
94618: PUSH
94619: LD_INT 11
94621: PUSH
94622: LD_INT 12
94624: PUSH
94625: LD_INT 15
94627: PUSH
94628: LD_INT 16
94630: PUSH
94631: LD_INT 20
94633: PUSH
94634: LD_INT 21
94636: PUSH
94637: LD_INT 22
94639: PUSH
94640: LD_INT 23
94642: PUSH
94643: LD_INT 25
94645: PUSH
94646: LD_INT 26
94648: PUSH
94649: LD_INT 30
94651: PUSH
94652: LD_INT 31
94654: PUSH
94655: LD_INT 32
94657: PUSH
94658: LD_INT 36
94660: PUSH
94661: EMPTY
94662: LIST
94663: LIST
94664: LIST
94665: LIST
94666: LIST
94667: LIST
94668: LIST
94669: LIST
94670: LIST
94671: LIST
94672: LIST
94673: LIST
94674: LIST
94675: LIST
94676: LIST
94677: LIST
94678: LIST
94679: LIST
94680: LIST
94681: LIST
94682: PUSH
94683: LD_INT 101
94685: PUSH
94686: LD_INT 102
94688: PUSH
94689: LD_INT 103
94691: PUSH
94692: LD_INT 105
94694: PUSH
94695: LD_INT 106
94697: PUSH
94698: LD_INT 108
94700: PUSH
94701: LD_INT 109
94703: PUSH
94704: LD_INT 112
94706: PUSH
94707: LD_INT 116
94709: PUSH
94710: LD_INT 117
94712: PUSH
94713: LD_INT 118
94715: PUSH
94716: EMPTY
94717: LIST
94718: LIST
94719: LIST
94720: LIST
94721: LIST
94722: LIST
94723: LIST
94724: LIST
94725: LIST
94726: LIST
94727: LIST
94728: PUSH
94729: EMPTY
94730: LIST
94731: LIST
94732: ST_TO_ADDR
94733: GO 96988
94735: LD_INT 9
94737: DOUBLE
94738: EQUAL
94739: IFTRUE 94743
94741: GO 94891
94743: POP
// result := [ [ 2 , 4 , 5 , 6 , 7 , 8 , 11 , 12 , 15 , 16 , 20 , 21 , 22 , 23 , 25 , 26 , 28 , 30 , 31 , 32 , 36 ] , [ 101 , 102 , 103 , 105 , 106 , 108 , 109 , 112 , 114 , 116 , 117 , 118 ] ] ; 10 :
94744: LD_ADDR_VAR 0 2
94748: PUSH
94749: LD_INT 2
94751: PUSH
94752: LD_INT 4
94754: PUSH
94755: LD_INT 5
94757: PUSH
94758: LD_INT 6
94760: PUSH
94761: LD_INT 7
94763: PUSH
94764: LD_INT 8
94766: PUSH
94767: LD_INT 11
94769: PUSH
94770: LD_INT 12
94772: PUSH
94773: LD_INT 15
94775: PUSH
94776: LD_INT 16
94778: PUSH
94779: LD_INT 20
94781: PUSH
94782: LD_INT 21
94784: PUSH
94785: LD_INT 22
94787: PUSH
94788: LD_INT 23
94790: PUSH
94791: LD_INT 25
94793: PUSH
94794: LD_INT 26
94796: PUSH
94797: LD_INT 28
94799: PUSH
94800: LD_INT 30
94802: PUSH
94803: LD_INT 31
94805: PUSH
94806: LD_INT 32
94808: PUSH
94809: LD_INT 36
94811: PUSH
94812: EMPTY
94813: LIST
94814: LIST
94815: LIST
94816: LIST
94817: LIST
94818: LIST
94819: LIST
94820: LIST
94821: LIST
94822: LIST
94823: LIST
94824: LIST
94825: LIST
94826: LIST
94827: LIST
94828: LIST
94829: LIST
94830: LIST
94831: LIST
94832: LIST
94833: LIST
94834: PUSH
94835: LD_INT 101
94837: PUSH
94838: LD_INT 102
94840: PUSH
94841: LD_INT 103
94843: PUSH
94844: LD_INT 105
94846: PUSH
94847: LD_INT 106
94849: PUSH
94850: LD_INT 108
94852: PUSH
94853: LD_INT 109
94855: PUSH
94856: LD_INT 112
94858: PUSH
94859: LD_INT 114
94861: PUSH
94862: LD_INT 116
94864: PUSH
94865: LD_INT 117
94867: PUSH
94868: LD_INT 118
94870: PUSH
94871: EMPTY
94872: LIST
94873: LIST
94874: LIST
94875: LIST
94876: LIST
94877: LIST
94878: LIST
94879: LIST
94880: LIST
94881: LIST
94882: LIST
94883: LIST
94884: PUSH
94885: EMPTY
94886: LIST
94887: LIST
94888: ST_TO_ADDR
94889: GO 96988
94891: LD_INT 10
94893: DOUBLE
94894: EQUAL
94895: IFTRUE 94899
94897: GO 95095
94899: POP
// result := [ [ 2 , 4 , 5 , 6 , 7 , 8 , 9 , 10 , 11 , 12 , 13 , 14 , 15 , 16 , 17 , 18 , 19 , 20 , 21 , 22 , 23 , 24 , 25 , 26 , 28 , 30 , 31 , 32 , 36 ] , [ 101 , 102 , 103 , 104 , 105 , 106 , 107 , 108 , 109 , 110 , 111 , 112 , 114 , 116 , 117 , 118 ] ] ; 11 :
94900: LD_ADDR_VAR 0 2
94904: PUSH
94905: LD_INT 2
94907: PUSH
94908: LD_INT 4
94910: PUSH
94911: LD_INT 5
94913: PUSH
94914: LD_INT 6
94916: PUSH
94917: LD_INT 7
94919: PUSH
94920: LD_INT 8
94922: PUSH
94923: LD_INT 9
94925: PUSH
94926: LD_INT 10
94928: PUSH
94929: LD_INT 11
94931: PUSH
94932: LD_INT 12
94934: PUSH
94935: LD_INT 13
94937: PUSH
94938: LD_INT 14
94940: PUSH
94941: LD_INT 15
94943: PUSH
94944: LD_INT 16
94946: PUSH
94947: LD_INT 17
94949: PUSH
94950: LD_INT 18
94952: PUSH
94953: LD_INT 19
94955: PUSH
94956: LD_INT 20
94958: PUSH
94959: LD_INT 21
94961: PUSH
94962: LD_INT 22
94964: PUSH
94965: LD_INT 23
94967: PUSH
94968: LD_INT 24
94970: PUSH
94971: LD_INT 25
94973: PUSH
94974: LD_INT 26
94976: PUSH
94977: LD_INT 28
94979: PUSH
94980: LD_INT 30
94982: PUSH
94983: LD_INT 31
94985: PUSH
94986: LD_INT 32
94988: PUSH
94989: LD_INT 36
94991: PUSH
94992: EMPTY
94993: LIST
94994: LIST
94995: LIST
94996: LIST
94997: LIST
94998: LIST
94999: LIST
95000: LIST
95001: LIST
95002: LIST
95003: LIST
95004: LIST
95005: LIST
95006: LIST
95007: LIST
95008: LIST
95009: LIST
95010: LIST
95011: LIST
95012: LIST
95013: LIST
95014: LIST
95015: LIST
95016: LIST
95017: LIST
95018: LIST
95019: LIST
95020: LIST
95021: LIST
95022: PUSH
95023: LD_INT 101
95025: PUSH
95026: LD_INT 102
95028: PUSH
95029: LD_INT 103
95031: PUSH
95032: LD_INT 104
95034: PUSH
95035: LD_INT 105
95037: PUSH
95038: LD_INT 106
95040: PUSH
95041: LD_INT 107
95043: PUSH
95044: LD_INT 108
95046: PUSH
95047: LD_INT 109
95049: PUSH
95050: LD_INT 110
95052: PUSH
95053: LD_INT 111
95055: PUSH
95056: LD_INT 112
95058: PUSH
95059: LD_INT 114
95061: PUSH
95062: LD_INT 116
95064: PUSH
95065: LD_INT 117
95067: PUSH
95068: LD_INT 118
95070: PUSH
95071: EMPTY
95072: LIST
95073: LIST
95074: LIST
95075: LIST
95076: LIST
95077: LIST
95078: LIST
95079: LIST
95080: LIST
95081: LIST
95082: LIST
95083: LIST
95084: LIST
95085: LIST
95086: LIST
95087: LIST
95088: PUSH
95089: EMPTY
95090: LIST
95091: LIST
95092: ST_TO_ADDR
95093: GO 96988
95095: LD_INT 11
95097: DOUBLE
95098: EQUAL
95099: IFTRUE 95103
95101: GO 95307
95103: POP
// result := [ [ 2 , 3 , 4 , 5 , 6 , 7 , 8 , 9 , 10 , 11 , 12 , 13 , 14 , 15 , 16 , 17 , 18 , 19 , 20 , 21 , 22 , 23 , 24 , 25 , 26 , 28 , 30 , 31 , 32 , 34 , 36 ] , [ 101 , 102 , 103 , 104 , 105 , 106 , 107 , 108 , 109 , 110 , 111 , 112 , 114 , 116 , 117 , 118 ] ] ; 12 :
95104: LD_ADDR_VAR 0 2
95108: PUSH
95109: LD_INT 2
95111: PUSH
95112: LD_INT 3
95114: PUSH
95115: LD_INT 4
95117: PUSH
95118: LD_INT 5
95120: PUSH
95121: LD_INT 6
95123: PUSH
95124: LD_INT 7
95126: PUSH
95127: LD_INT 8
95129: PUSH
95130: LD_INT 9
95132: PUSH
95133: LD_INT 10
95135: PUSH
95136: LD_INT 11
95138: PUSH
95139: LD_INT 12
95141: PUSH
95142: LD_INT 13
95144: PUSH
95145: LD_INT 14
95147: PUSH
95148: LD_INT 15
95150: PUSH
95151: LD_INT 16
95153: PUSH
95154: LD_INT 17
95156: PUSH
95157: LD_INT 18
95159: PUSH
95160: LD_INT 19
95162: PUSH
95163: LD_INT 20
95165: PUSH
95166: LD_INT 21
95168: PUSH
95169: LD_INT 22
95171: PUSH
95172: LD_INT 23
95174: PUSH
95175: LD_INT 24
95177: PUSH
95178: LD_INT 25
95180: PUSH
95181: LD_INT 26
95183: PUSH
95184: LD_INT 28
95186: PUSH
95187: LD_INT 30
95189: PUSH
95190: LD_INT 31
95192: PUSH
95193: LD_INT 32
95195: PUSH
95196: LD_INT 34
95198: PUSH
95199: LD_INT 36
95201: PUSH
95202: EMPTY
95203: LIST
95204: LIST
95205: LIST
95206: LIST
95207: LIST
95208: LIST
95209: LIST
95210: LIST
95211: LIST
95212: LIST
95213: LIST
95214: LIST
95215: LIST
95216: LIST
95217: LIST
95218: LIST
95219: LIST
95220: LIST
95221: LIST
95222: LIST
95223: LIST
95224: LIST
95225: LIST
95226: LIST
95227: LIST
95228: LIST
95229: LIST
95230: LIST
95231: LIST
95232: LIST
95233: LIST
95234: PUSH
95235: LD_INT 101
95237: PUSH
95238: LD_INT 102
95240: PUSH
95241: LD_INT 103
95243: PUSH
95244: LD_INT 104
95246: PUSH
95247: LD_INT 105
95249: PUSH
95250: LD_INT 106
95252: PUSH
95253: LD_INT 107
95255: PUSH
95256: LD_INT 108
95258: PUSH
95259: LD_INT 109
95261: PUSH
95262: LD_INT 110
95264: PUSH
95265: LD_INT 111
95267: PUSH
95268: LD_INT 112
95270: PUSH
95271: LD_INT 114
95273: PUSH
95274: LD_INT 116
95276: PUSH
95277: LD_INT 117
95279: PUSH
95280: LD_INT 118
95282: PUSH
95283: EMPTY
95284: LIST
95285: LIST
95286: LIST
95287: LIST
95288: LIST
95289: LIST
95290: LIST
95291: LIST
95292: LIST
95293: LIST
95294: LIST
95295: LIST
95296: LIST
95297: LIST
95298: LIST
95299: LIST
95300: PUSH
95301: EMPTY
95302: LIST
95303: LIST
95304: ST_TO_ADDR
95305: GO 96988
95307: LD_INT 12
95309: DOUBLE
95310: EQUAL
95311: IFTRUE 95315
95313: GO 95535
95315: POP
// result := [ [ 1 , 2 , 3 , 4 , 5 , 6 , 7 , 8 , 9 , 10 , 11 , 12 , 13 , 14 , 15 , 16 , 17 , 18 , 19 , 20 , 21 , 22 , 23 , 24 , 25 , 26 , 27 , 28 , 30 , 31 , 32 , 33 , 34 , 36 ] , [ 101 , 102 , 103 , 104 , 105 , 106 , 107 , 108 , 109 , 110 , 111 , 112 , 113 , 114 , 116 , 117 , 118 ] ] ; 13 :
95316: LD_ADDR_VAR 0 2
95320: PUSH
95321: LD_INT 1
95323: PUSH
95324: LD_INT 2
95326: PUSH
95327: LD_INT 3
95329: PUSH
95330: LD_INT 4
95332: PUSH
95333: LD_INT 5
95335: PUSH
95336: LD_INT 6
95338: PUSH
95339: LD_INT 7
95341: PUSH
95342: LD_INT 8
95344: PUSH
95345: LD_INT 9
95347: PUSH
95348: LD_INT 10
95350: PUSH
95351: LD_INT 11
95353: PUSH
95354: LD_INT 12
95356: PUSH
95357: LD_INT 13
95359: PUSH
95360: LD_INT 14
95362: PUSH
95363: LD_INT 15
95365: PUSH
95366: LD_INT 16
95368: PUSH
95369: LD_INT 17
95371: PUSH
95372: LD_INT 18
95374: PUSH
95375: LD_INT 19
95377: PUSH
95378: LD_INT 20
95380: PUSH
95381: LD_INT 21
95383: PUSH
95384: LD_INT 22
95386: PUSH
95387: LD_INT 23
95389: PUSH
95390: LD_INT 24
95392: PUSH
95393: LD_INT 25
95395: PUSH
95396: LD_INT 26
95398: PUSH
95399: LD_INT 27
95401: PUSH
95402: LD_INT 28
95404: PUSH
95405: LD_INT 30
95407: PUSH
95408: LD_INT 31
95410: PUSH
95411: LD_INT 32
95413: PUSH
95414: LD_INT 33
95416: PUSH
95417: LD_INT 34
95419: PUSH
95420: LD_INT 36
95422: PUSH
95423: EMPTY
95424: LIST
95425: LIST
95426: LIST
95427: LIST
95428: LIST
95429: LIST
95430: LIST
95431: LIST
95432: LIST
95433: LIST
95434: LIST
95435: LIST
95436: LIST
95437: LIST
95438: LIST
95439: LIST
95440: LIST
95441: LIST
95442: LIST
95443: LIST
95444: LIST
95445: LIST
95446: LIST
95447: LIST
95448: LIST
95449: LIST
95450: LIST
95451: LIST
95452: LIST
95453: LIST
95454: LIST
95455: LIST
95456: LIST
95457: LIST
95458: PUSH
95459: LD_INT 101
95461: PUSH
95462: LD_INT 102
95464: PUSH
95465: LD_INT 103
95467: PUSH
95468: LD_INT 104
95470: PUSH
95471: LD_INT 105
95473: PUSH
95474: LD_INT 106
95476: PUSH
95477: LD_INT 107
95479: PUSH
95480: LD_INT 108
95482: PUSH
95483: LD_INT 109
95485: PUSH
95486: LD_INT 110
95488: PUSH
95489: LD_INT 111
95491: PUSH
95492: LD_INT 112
95494: PUSH
95495: LD_INT 113
95497: PUSH
95498: LD_INT 114
95500: PUSH
95501: LD_INT 116
95503: PUSH
95504: LD_INT 117
95506: PUSH
95507: LD_INT 118
95509: PUSH
95510: EMPTY
95511: LIST
95512: LIST
95513: LIST
95514: LIST
95515: LIST
95516: LIST
95517: LIST
95518: LIST
95519: LIST
95520: LIST
95521: LIST
95522: LIST
95523: LIST
95524: LIST
95525: LIST
95526: LIST
95527: LIST
95528: PUSH
95529: EMPTY
95530: LIST
95531: LIST
95532: ST_TO_ADDR
95533: GO 96988
95535: LD_INT 13
95537: DOUBLE
95538: EQUAL
95539: IFTRUE 95543
95541: GO 95751
95543: POP
// result := [ [ 1 , 2 , 3 , 4 , 5 , 8 , 9 , 10 , 11 , 12 , 14 , 15 , 16 , 17 , 18 , 19 , 20 , 21 , 22 , 23 , 24 , 25 , 26 , 27 , 28 , 30 , 31 , 32 , 33 , 34 , 36 ] , [ 101 , 102 , 103 , 104 , 105 , 106 , 107 , 108 , 109 , 110 , 111 , 112 , 113 , 114 , 116 , 117 , 118 ] ] ; 14 :
95544: LD_ADDR_VAR 0 2
95548: PUSH
95549: LD_INT 1
95551: PUSH
95552: LD_INT 2
95554: PUSH
95555: LD_INT 3
95557: PUSH
95558: LD_INT 4
95560: PUSH
95561: LD_INT 5
95563: PUSH
95564: LD_INT 8
95566: PUSH
95567: LD_INT 9
95569: PUSH
95570: LD_INT 10
95572: PUSH
95573: LD_INT 11
95575: PUSH
95576: LD_INT 12
95578: PUSH
95579: LD_INT 14
95581: PUSH
95582: LD_INT 15
95584: PUSH
95585: LD_INT 16
95587: PUSH
95588: LD_INT 17
95590: PUSH
95591: LD_INT 18
95593: PUSH
95594: LD_INT 19
95596: PUSH
95597: LD_INT 20
95599: PUSH
95600: LD_INT 21
95602: PUSH
95603: LD_INT 22
95605: PUSH
95606: LD_INT 23
95608: PUSH
95609: LD_INT 24
95611: PUSH
95612: LD_INT 25
95614: PUSH
95615: LD_INT 26
95617: PUSH
95618: LD_INT 27
95620: PUSH
95621: LD_INT 28
95623: PUSH
95624: LD_INT 30
95626: PUSH
95627: LD_INT 31
95629: PUSH
95630: LD_INT 32
95632: PUSH
95633: LD_INT 33
95635: PUSH
95636: LD_INT 34
95638: PUSH
95639: LD_INT 36
95641: PUSH
95642: EMPTY
95643: LIST
95644: LIST
95645: LIST
95646: LIST
95647: LIST
95648: LIST
95649: LIST
95650: LIST
95651: LIST
95652: LIST
95653: LIST
95654: LIST
95655: LIST
95656: LIST
95657: LIST
95658: LIST
95659: LIST
95660: LIST
95661: LIST
95662: LIST
95663: LIST
95664: LIST
95665: LIST
95666: LIST
95667: LIST
95668: LIST
95669: LIST
95670: LIST
95671: LIST
95672: LIST
95673: LIST
95674: PUSH
95675: LD_INT 101
95677: PUSH
95678: LD_INT 102
95680: PUSH
95681: LD_INT 103
95683: PUSH
95684: LD_INT 104
95686: PUSH
95687: LD_INT 105
95689: PUSH
95690: LD_INT 106
95692: PUSH
95693: LD_INT 107
95695: PUSH
95696: LD_INT 108
95698: PUSH
95699: LD_INT 109
95701: PUSH
95702: LD_INT 110
95704: PUSH
95705: LD_INT 111
95707: PUSH
95708: LD_INT 112
95710: PUSH
95711: LD_INT 113
95713: PUSH
95714: LD_INT 114
95716: PUSH
95717: LD_INT 116
95719: PUSH
95720: LD_INT 117
95722: PUSH
95723: LD_INT 118
95725: PUSH
95726: EMPTY
95727: LIST
95728: LIST
95729: LIST
95730: LIST
95731: LIST
95732: LIST
95733: LIST
95734: LIST
95735: LIST
95736: LIST
95737: LIST
95738: LIST
95739: LIST
95740: LIST
95741: LIST
95742: LIST
95743: LIST
95744: PUSH
95745: EMPTY
95746: LIST
95747: LIST
95748: ST_TO_ADDR
95749: GO 96988
95751: LD_INT 14
95753: DOUBLE
95754: EQUAL
95755: IFTRUE 95759
95757: GO 95983
95759: POP
// result := [ [ 1 , 2 , 3 , 4 , 5 , 6 , 7 , 8 , 9 , 10 , 11 , 12 , 13 , 14 , 15 , 16 , 17 , 18 , 19 , 20 , 21 , 22 , 23 , 24 , 25 , 26 , 27 , 28 , 29 , 30 , 31 , 32 , 33 , 34 , 36 ] , [ 101 , 102 , 103 , 104 , 105 , 106 , 107 , 108 , 109 , 110 , 111 , 112 , 113 , 114 , 116 , 117 , 118 ] ] ; 15 :
95760: LD_ADDR_VAR 0 2
95764: PUSH
95765: LD_INT 1
95767: PUSH
95768: LD_INT 2
95770: PUSH
95771: LD_INT 3
95773: PUSH
95774: LD_INT 4
95776: PUSH
95777: LD_INT 5
95779: PUSH
95780: LD_INT 6
95782: PUSH
95783: LD_INT 7
95785: PUSH
95786: LD_INT 8
95788: PUSH
95789: LD_INT 9
95791: PUSH
95792: LD_INT 10
95794: PUSH
95795: LD_INT 11
95797: PUSH
95798: LD_INT 12
95800: PUSH
95801: LD_INT 13
95803: PUSH
95804: LD_INT 14
95806: PUSH
95807: LD_INT 15
95809: PUSH
95810: LD_INT 16
95812: PUSH
95813: LD_INT 17
95815: PUSH
95816: LD_INT 18
95818: PUSH
95819: LD_INT 19
95821: PUSH
95822: LD_INT 20
95824: PUSH
95825: LD_INT 21
95827: PUSH
95828: LD_INT 22
95830: PUSH
95831: LD_INT 23
95833: PUSH
95834: LD_INT 24
95836: PUSH
95837: LD_INT 25
95839: PUSH
95840: LD_INT 26
95842: PUSH
95843: LD_INT 27
95845: PUSH
95846: LD_INT 28
95848: PUSH
95849: LD_INT 29
95851: PUSH
95852: LD_INT 30
95854: PUSH
95855: LD_INT 31
95857: PUSH
95858: LD_INT 32
95860: PUSH
95861: LD_INT 33
95863: PUSH
95864: LD_INT 34
95866: PUSH
95867: LD_INT 36
95869: PUSH
95870: EMPTY
95871: LIST
95872: LIST
95873: LIST
95874: LIST
95875: LIST
95876: LIST
95877: LIST
95878: LIST
95879: LIST
95880: LIST
95881: LIST
95882: LIST
95883: LIST
95884: LIST
95885: LIST
95886: LIST
95887: LIST
95888: LIST
95889: LIST
95890: LIST
95891: LIST
95892: LIST
95893: LIST
95894: LIST
95895: LIST
95896: LIST
95897: LIST
95898: LIST
95899: LIST
95900: LIST
95901: LIST
95902: LIST
95903: LIST
95904: LIST
95905: LIST
95906: PUSH
95907: LD_INT 101
95909: PUSH
95910: LD_INT 102
95912: PUSH
95913: LD_INT 103
95915: PUSH
95916: LD_INT 104
95918: PUSH
95919: LD_INT 105
95921: PUSH
95922: LD_INT 106
95924: PUSH
95925: LD_INT 107
95927: PUSH
95928: LD_INT 108
95930: PUSH
95931: LD_INT 109
95933: PUSH
95934: LD_INT 110
95936: PUSH
95937: LD_INT 111
95939: PUSH
95940: LD_INT 112
95942: PUSH
95943: LD_INT 113
95945: PUSH
95946: LD_INT 114
95948: PUSH
95949: LD_INT 116
95951: PUSH
95952: LD_INT 117
95954: PUSH
95955: LD_INT 118
95957: PUSH
95958: EMPTY
95959: LIST
95960: LIST
95961: LIST
95962: LIST
95963: LIST
95964: LIST
95965: LIST
95966: LIST
95967: LIST
95968: LIST
95969: LIST
95970: LIST
95971: LIST
95972: LIST
95973: LIST
95974: LIST
95975: LIST
95976: PUSH
95977: EMPTY
95978: LIST
95979: LIST
95980: ST_TO_ADDR
95981: GO 96988
95983: LD_INT 15
95985: DOUBLE
95986: EQUAL
95987: IFTRUE 95991
95989: GO 96215
95991: POP
// result := [ [ 1 , 2 , 3 , 4 , 5 , 6 , 7 , 8 , 9 , 10 , 11 , 12 , 13 , 14 , 15 , 16 , 17 , 18 , 19 , 20 , 21 , 22 , 23 , 24 , 25 , 26 , 27 , 28 , 29 , 30 , 31 , 32 , 33 , 34 , 36 ] , [ 101 , 102 , 103 , 104 , 105 , 106 , 107 , 108 , 109 , 110 , 111 , 112 , 113 , 114 , 116 , 117 , 118 ] ] ; 16 :
95992: LD_ADDR_VAR 0 2
95996: PUSH
95997: LD_INT 1
95999: PUSH
96000: LD_INT 2
96002: PUSH
96003: LD_INT 3
96005: PUSH
96006: LD_INT 4
96008: PUSH
96009: LD_INT 5
96011: PUSH
96012: LD_INT 6
96014: PUSH
96015: LD_INT 7
96017: PUSH
96018: LD_INT 8
96020: PUSH
96021: LD_INT 9
96023: PUSH
96024: LD_INT 10
96026: PUSH
96027: LD_INT 11
96029: PUSH
96030: LD_INT 12
96032: PUSH
96033: LD_INT 13
96035: PUSH
96036: LD_INT 14
96038: PUSH
96039: LD_INT 15
96041: PUSH
96042: LD_INT 16
96044: PUSH
96045: LD_INT 17
96047: PUSH
96048: LD_INT 18
96050: PUSH
96051: LD_INT 19
96053: PUSH
96054: LD_INT 20
96056: PUSH
96057: LD_INT 21
96059: PUSH
96060: LD_INT 22
96062: PUSH
96063: LD_INT 23
96065: PUSH
96066: LD_INT 24
96068: PUSH
96069: LD_INT 25
96071: PUSH
96072: LD_INT 26
96074: PUSH
96075: LD_INT 27
96077: PUSH
96078: LD_INT 28
96080: PUSH
96081: LD_INT 29
96083: PUSH
96084: LD_INT 30
96086: PUSH
96087: LD_INT 31
96089: PUSH
96090: LD_INT 32
96092: PUSH
96093: LD_INT 33
96095: PUSH
96096: LD_INT 34
96098: PUSH
96099: LD_INT 36
96101: PUSH
96102: EMPTY
96103: LIST
96104: LIST
96105: LIST
96106: LIST
96107: LIST
96108: LIST
96109: LIST
96110: LIST
96111: LIST
96112: LIST
96113: LIST
96114: LIST
96115: LIST
96116: LIST
96117: LIST
96118: LIST
96119: LIST
96120: LIST
96121: LIST
96122: LIST
96123: LIST
96124: LIST
96125: LIST
96126: LIST
96127: LIST
96128: LIST
96129: LIST
96130: LIST
96131: LIST
96132: LIST
96133: LIST
96134: LIST
96135: LIST
96136: LIST
96137: LIST
96138: PUSH
96139: LD_INT 101
96141: PUSH
96142: LD_INT 102
96144: PUSH
96145: LD_INT 103
96147: PUSH
96148: LD_INT 104
96150: PUSH
96151: LD_INT 105
96153: PUSH
96154: LD_INT 106
96156: PUSH
96157: LD_INT 107
96159: PUSH
96160: LD_INT 108
96162: PUSH
96163: LD_INT 109
96165: PUSH
96166: LD_INT 110
96168: PUSH
96169: LD_INT 111
96171: PUSH
96172: LD_INT 112
96174: PUSH
96175: LD_INT 113
96177: PUSH
96178: LD_INT 114
96180: PUSH
96181: LD_INT 116
96183: PUSH
96184: LD_INT 117
96186: PUSH
96187: LD_INT 118
96189: PUSH
96190: EMPTY
96191: LIST
96192: LIST
96193: LIST
96194: LIST
96195: LIST
96196: LIST
96197: LIST
96198: LIST
96199: LIST
96200: LIST
96201: LIST
96202: LIST
96203: LIST
96204: LIST
96205: LIST
96206: LIST
96207: LIST
96208: PUSH
96209: EMPTY
96210: LIST
96211: LIST
96212: ST_TO_ADDR
96213: GO 96988
96215: LD_INT 16
96217: DOUBLE
96218: EQUAL
96219: IFTRUE 96223
96221: GO 96359
96223: POP
// result := [ [ 2 , 4 , 5 , 7 , 11 , 12 , 15 , 16 , 20 , 21 , 22 , 23 , 25 , 26 , 30 , 31 , 32 , 33 , 34 ] , [ 101 , 102 , 103 , 106 , 108 , 112 , 113 , 114 , 116 , 117 , 118 ] ] ; 17 :
96224: LD_ADDR_VAR 0 2
96228: PUSH
96229: LD_INT 2
96231: PUSH
96232: LD_INT 4
96234: PUSH
96235: LD_INT 5
96237: PUSH
96238: LD_INT 7
96240: PUSH
96241: LD_INT 11
96243: PUSH
96244: LD_INT 12
96246: PUSH
96247: LD_INT 15
96249: PUSH
96250: LD_INT 16
96252: PUSH
96253: LD_INT 20
96255: PUSH
96256: LD_INT 21
96258: PUSH
96259: LD_INT 22
96261: PUSH
96262: LD_INT 23
96264: PUSH
96265: LD_INT 25
96267: PUSH
96268: LD_INT 26
96270: PUSH
96271: LD_INT 30
96273: PUSH
96274: LD_INT 31
96276: PUSH
96277: LD_INT 32
96279: PUSH
96280: LD_INT 33
96282: PUSH
96283: LD_INT 34
96285: PUSH
96286: EMPTY
96287: LIST
96288: LIST
96289: LIST
96290: LIST
96291: LIST
96292: LIST
96293: LIST
96294: LIST
96295: LIST
96296: LIST
96297: LIST
96298: LIST
96299: LIST
96300: LIST
96301: LIST
96302: LIST
96303: LIST
96304: LIST
96305: LIST
96306: PUSH
96307: LD_INT 101
96309: PUSH
96310: LD_INT 102
96312: PUSH
96313: LD_INT 103
96315: PUSH
96316: LD_INT 106
96318: PUSH
96319: LD_INT 108
96321: PUSH
96322: LD_INT 112
96324: PUSH
96325: LD_INT 113
96327: PUSH
96328: LD_INT 114
96330: PUSH
96331: LD_INT 116
96333: PUSH
96334: LD_INT 117
96336: PUSH
96337: LD_INT 118
96339: PUSH
96340: EMPTY
96341: LIST
96342: LIST
96343: LIST
96344: LIST
96345: LIST
96346: LIST
96347: LIST
96348: LIST
96349: LIST
96350: LIST
96351: LIST
96352: PUSH
96353: EMPTY
96354: LIST
96355: LIST
96356: ST_TO_ADDR
96357: GO 96988
96359: LD_INT 17
96361: DOUBLE
96362: EQUAL
96363: IFTRUE 96367
96365: GO 96591
96367: POP
// result := [ [ 1 , 2 , 3 , 4 , 5 , 6 , 7 , 8 , 9 , 10 , 11 , 12 , 13 , 14 , 15 , 16 , 17 , 18 , 19 , 20 , 21 , 22 , 23 , 24 , 25 , 26 , 27 , 28 , 29 , 30 , 31 , 32 , 33 , 34 , 36 ] , [ 101 , 102 , 103 , 104 , 105 , 106 , 107 , 108 , 109 , 110 , 111 , 112 , 113 , 114 , 116 , 117 , 118 ] ] ; 18 :
96368: LD_ADDR_VAR 0 2
96372: PUSH
96373: LD_INT 1
96375: PUSH
96376: LD_INT 2
96378: PUSH
96379: LD_INT 3
96381: PUSH
96382: LD_INT 4
96384: PUSH
96385: LD_INT 5
96387: PUSH
96388: LD_INT 6
96390: PUSH
96391: LD_INT 7
96393: PUSH
96394: LD_INT 8
96396: PUSH
96397: LD_INT 9
96399: PUSH
96400: LD_INT 10
96402: PUSH
96403: LD_INT 11
96405: PUSH
96406: LD_INT 12
96408: PUSH
96409: LD_INT 13
96411: PUSH
96412: LD_INT 14
96414: PUSH
96415: LD_INT 15
96417: PUSH
96418: LD_INT 16
96420: PUSH
96421: LD_INT 17
96423: PUSH
96424: LD_INT 18
96426: PUSH
96427: LD_INT 19
96429: PUSH
96430: LD_INT 20
96432: PUSH
96433: LD_INT 21
96435: PUSH
96436: LD_INT 22
96438: PUSH
96439: LD_INT 23
96441: PUSH
96442: LD_INT 24
96444: PUSH
96445: LD_INT 25
96447: PUSH
96448: LD_INT 26
96450: PUSH
96451: LD_INT 27
96453: PUSH
96454: LD_INT 28
96456: PUSH
96457: LD_INT 29
96459: PUSH
96460: LD_INT 30
96462: PUSH
96463: LD_INT 31
96465: PUSH
96466: LD_INT 32
96468: PUSH
96469: LD_INT 33
96471: PUSH
96472: LD_INT 34
96474: PUSH
96475: LD_INT 36
96477: PUSH
96478: EMPTY
96479: LIST
96480: LIST
96481: LIST
96482: LIST
96483: LIST
96484: LIST
96485: LIST
96486: LIST
96487: LIST
96488: LIST
96489: LIST
96490: LIST
96491: LIST
96492: LIST
96493: LIST
96494: LIST
96495: LIST
96496: LIST
96497: LIST
96498: LIST
96499: LIST
96500: LIST
96501: LIST
96502: LIST
96503: LIST
96504: LIST
96505: LIST
96506: LIST
96507: LIST
96508: LIST
96509: LIST
96510: LIST
96511: LIST
96512: LIST
96513: LIST
96514: PUSH
96515: LD_INT 101
96517: PUSH
96518: LD_INT 102
96520: PUSH
96521: LD_INT 103
96523: PUSH
96524: LD_INT 104
96526: PUSH
96527: LD_INT 105
96529: PUSH
96530: LD_INT 106
96532: PUSH
96533: LD_INT 107
96535: PUSH
96536: LD_INT 108
96538: PUSH
96539: LD_INT 109
96541: PUSH
96542: LD_INT 110
96544: PUSH
96545: LD_INT 111
96547: PUSH
96548: LD_INT 112
96550: PUSH
96551: LD_INT 113
96553: PUSH
96554: LD_INT 114
96556: PUSH
96557: LD_INT 116
96559: PUSH
96560: LD_INT 117
96562: PUSH
96563: LD_INT 118
96565: PUSH
96566: EMPTY
96567: LIST
96568: LIST
96569: LIST
96570: LIST
96571: LIST
96572: LIST
96573: LIST
96574: LIST
96575: LIST
96576: LIST
96577: LIST
96578: LIST
96579: LIST
96580: LIST
96581: LIST
96582: LIST
96583: LIST
96584: PUSH
96585: EMPTY
96586: LIST
96587: LIST
96588: ST_TO_ADDR
96589: GO 96988
96591: LD_INT 18
96593: DOUBLE
96594: EQUAL
96595: IFTRUE 96599
96597: GO 96747
96599: POP
// result := [ [ 2 , 4 , 5 , 7 , 11 , 12 , 15 , 16 , 20 , 21 , 22 , 23 , 25 , 26 , 30 , 31 , 32 , 33 , 34 , 35 , 36 ] , [ 101 , 102 , 103 , 106 , 108 , 112 , 113 , 114 , 115 , 116 , 117 , 118 ] ] ; 19 :
96600: LD_ADDR_VAR 0 2
96604: PUSH
96605: LD_INT 2
96607: PUSH
96608: LD_INT 4
96610: PUSH
96611: LD_INT 5
96613: PUSH
96614: LD_INT 7
96616: PUSH
96617: LD_INT 11
96619: PUSH
96620: LD_INT 12
96622: PUSH
96623: LD_INT 15
96625: PUSH
96626: LD_INT 16
96628: PUSH
96629: LD_INT 20
96631: PUSH
96632: LD_INT 21
96634: PUSH
96635: LD_INT 22
96637: PUSH
96638: LD_INT 23
96640: PUSH
96641: LD_INT 25
96643: PUSH
96644: LD_INT 26
96646: PUSH
96647: LD_INT 30
96649: PUSH
96650: LD_INT 31
96652: PUSH
96653: LD_INT 32
96655: PUSH
96656: LD_INT 33
96658: PUSH
96659: LD_INT 34
96661: PUSH
96662: LD_INT 35
96664: PUSH
96665: LD_INT 36
96667: PUSH
96668: EMPTY
96669: LIST
96670: LIST
96671: LIST
96672: LIST
96673: LIST
96674: LIST
96675: LIST
96676: LIST
96677: LIST
96678: LIST
96679: LIST
96680: LIST
96681: LIST
96682: LIST
96683: LIST
96684: LIST
96685: LIST
96686: LIST
96687: LIST
96688: LIST
96689: LIST
96690: PUSH
96691: LD_INT 101
96693: PUSH
96694: LD_INT 102
96696: PUSH
96697: LD_INT 103
96699: PUSH
96700: LD_INT 106
96702: PUSH
96703: LD_INT 108
96705: PUSH
96706: LD_INT 112
96708: PUSH
96709: LD_INT 113
96711: PUSH
96712: LD_INT 114
96714: PUSH
96715: LD_INT 115
96717: PUSH
96718: LD_INT 116
96720: PUSH
96721: LD_INT 117
96723: PUSH
96724: LD_INT 118
96726: PUSH
96727: EMPTY
96728: LIST
96729: LIST
96730: LIST
96731: LIST
96732: LIST
96733: LIST
96734: LIST
96735: LIST
96736: LIST
96737: LIST
96738: LIST
96739: LIST
96740: PUSH
96741: EMPTY
96742: LIST
96743: LIST
96744: ST_TO_ADDR
96745: GO 96988
96747: LD_INT 19
96749: DOUBLE
96750: EQUAL
96751: IFTRUE 96755
96753: GO 96987
96755: POP
// result := [ [ 1 , 2 , 3 , 4 , 5 , 6 , 7 , 8 , 9 , 10 , 11 , 12 , 13 , 14 , 15 , 16 , 17 , 18 , 19 , 20 , 21 , 22 , 23 , 24 , 25 , 26 , 27 , 28 , 29 , 30 , 31 , 32 , 33 , 34 , 35 , 36 ] , [ 101 , 102 , 103 , 104 , 105 , 106 , 107 , 108 , 109 , 110 , 111 , 112 , 113 , 114 , 115 , 116 , 117 , 118 ] ] ; end ;
96756: LD_ADDR_VAR 0 2
96760: PUSH
96761: LD_INT 1
96763: PUSH
96764: LD_INT 2
96766: PUSH
96767: LD_INT 3
96769: PUSH
96770: LD_INT 4
96772: PUSH
96773: LD_INT 5
96775: PUSH
96776: LD_INT 6
96778: PUSH
96779: LD_INT 7
96781: PUSH
96782: LD_INT 8
96784: PUSH
96785: LD_INT 9
96787: PUSH
96788: LD_INT 10
96790: PUSH
96791: LD_INT 11
96793: PUSH
96794: LD_INT 12
96796: PUSH
96797: LD_INT 13
96799: PUSH
96800: LD_INT 14
96802: PUSH
96803: LD_INT 15
96805: PUSH
96806: LD_INT 16
96808: PUSH
96809: LD_INT 17
96811: PUSH
96812: LD_INT 18
96814: PUSH
96815: LD_INT 19
96817: PUSH
96818: LD_INT 20
96820: PUSH
96821: LD_INT 21
96823: PUSH
96824: LD_INT 22
96826: PUSH
96827: LD_INT 23
96829: PUSH
96830: LD_INT 24
96832: PUSH
96833: LD_INT 25
96835: PUSH
96836: LD_INT 26
96838: PUSH
96839: LD_INT 27
96841: PUSH
96842: LD_INT 28
96844: PUSH
96845: LD_INT 29
96847: PUSH
96848: LD_INT 30
96850: PUSH
96851: LD_INT 31
96853: PUSH
96854: LD_INT 32
96856: PUSH
96857: LD_INT 33
96859: PUSH
96860: LD_INT 34
96862: PUSH
96863: LD_INT 35
96865: PUSH
96866: LD_INT 36
96868: PUSH
96869: EMPTY
96870: LIST
96871: LIST
96872: LIST
96873: LIST
96874: LIST
96875: LIST
96876: LIST
96877: LIST
96878: LIST
96879: LIST
96880: LIST
96881: LIST
96882: LIST
96883: LIST
96884: LIST
96885: LIST
96886: LIST
96887: LIST
96888: LIST
96889: LIST
96890: LIST
96891: LIST
96892: LIST
96893: LIST
96894: LIST
96895: LIST
96896: LIST
96897: LIST
96898: LIST
96899: LIST
96900: LIST
96901: LIST
96902: LIST
96903: LIST
96904: LIST
96905: LIST
96906: PUSH
96907: LD_INT 101
96909: PUSH
96910: LD_INT 102
96912: PUSH
96913: LD_INT 103
96915: PUSH
96916: LD_INT 104
96918: PUSH
96919: LD_INT 105
96921: PUSH
96922: LD_INT 106
96924: PUSH
96925: LD_INT 107
96927: PUSH
96928: LD_INT 108
96930: PUSH
96931: LD_INT 109
96933: PUSH
96934: LD_INT 110
96936: PUSH
96937: LD_INT 111
96939: PUSH
96940: LD_INT 112
96942: PUSH
96943: LD_INT 113
96945: PUSH
96946: LD_INT 114
96948: PUSH
96949: LD_INT 115
96951: PUSH
96952: LD_INT 116
96954: PUSH
96955: LD_INT 117
96957: PUSH
96958: LD_INT 118
96960: PUSH
96961: EMPTY
96962: LIST
96963: LIST
96964: LIST
96965: LIST
96966: LIST
96967: LIST
96968: LIST
96969: LIST
96970: LIST
96971: LIST
96972: LIST
96973: LIST
96974: LIST
96975: LIST
96976: LIST
96977: LIST
96978: LIST
96979: LIST
96980: PUSH
96981: EMPTY
96982: LIST
96983: LIST
96984: ST_TO_ADDR
96985: GO 96988
96987: POP
// end else
96988: GO 97219
// result := [ [ 1 , 2 , 3 , 4 , 5 , 6 , 7 , 8 , 9 , 10 , 11 , 12 , 13 , 14 , 15 , 16 , 17 , 18 , 19 , 20 , 21 , 22 , 23 , 24 , 25 , 26 , 27 , 28 , 29 , 30 , 31 , 32 , 33 , 34 , 35 , 36 ] , [ 101 , 102 , 103 , 104 , 105 , 106 , 107 , 108 , 109 , 110 , 111 , 112 , 113 , 114 , 115 , 116 , 117 , 118 ] ] ;
96990: LD_ADDR_VAR 0 2
96994: PUSH
96995: LD_INT 1
96997: PUSH
96998: LD_INT 2
97000: PUSH
97001: LD_INT 3
97003: PUSH
97004: LD_INT 4
97006: PUSH
97007: LD_INT 5
97009: PUSH
97010: LD_INT 6
97012: PUSH
97013: LD_INT 7
97015: PUSH
97016: LD_INT 8
97018: PUSH
97019: LD_INT 9
97021: PUSH
97022: LD_INT 10
97024: PUSH
97025: LD_INT 11
97027: PUSH
97028: LD_INT 12
97030: PUSH
97031: LD_INT 13
97033: PUSH
97034: LD_INT 14
97036: PUSH
97037: LD_INT 15
97039: PUSH
97040: LD_INT 16
97042: PUSH
97043: LD_INT 17
97045: PUSH
97046: LD_INT 18
97048: PUSH
97049: LD_INT 19
97051: PUSH
97052: LD_INT 20
97054: PUSH
97055: LD_INT 21
97057: PUSH
97058: LD_INT 22
97060: PUSH
97061: LD_INT 23
97063: PUSH
97064: LD_INT 24
97066: PUSH
97067: LD_INT 25
97069: PUSH
97070: LD_INT 26
97072: PUSH
97073: LD_INT 27
97075: PUSH
97076: LD_INT 28
97078: PUSH
97079: LD_INT 29
97081: PUSH
97082: LD_INT 30
97084: PUSH
97085: LD_INT 31
97087: PUSH
97088: LD_INT 32
97090: PUSH
97091: LD_INT 33
97093: PUSH
97094: LD_INT 34
97096: PUSH
97097: LD_INT 35
97099: PUSH
97100: LD_INT 36
97102: PUSH
97103: EMPTY
97104: LIST
97105: LIST
97106: LIST
97107: LIST
97108: LIST
97109: LIST
97110: LIST
97111: LIST
97112: LIST
97113: LIST
97114: LIST
97115: LIST
97116: LIST
97117: LIST
97118: LIST
97119: LIST
97120: LIST
97121: LIST
97122: LIST
97123: LIST
97124: LIST
97125: LIST
97126: LIST
97127: LIST
97128: LIST
97129: LIST
97130: LIST
97131: LIST
97132: LIST
97133: LIST
97134: LIST
97135: LIST
97136: LIST
97137: LIST
97138: LIST
97139: LIST
97140: PUSH
97141: LD_INT 101
97143: PUSH
97144: LD_INT 102
97146: PUSH
97147: LD_INT 103
97149: PUSH
97150: LD_INT 104
97152: PUSH
97153: LD_INT 105
97155: PUSH
97156: LD_INT 106
97158: PUSH
97159: LD_INT 107
97161: PUSH
97162: LD_INT 108
97164: PUSH
97165: LD_INT 109
97167: PUSH
97168: LD_INT 110
97170: PUSH
97171: LD_INT 111
97173: PUSH
97174: LD_INT 112
97176: PUSH
97177: LD_INT 113
97179: PUSH
97180: LD_INT 114
97182: PUSH
97183: LD_INT 115
97185: PUSH
97186: LD_INT 116
97188: PUSH
97189: LD_INT 117
97191: PUSH
97192: LD_INT 118
97194: PUSH
97195: EMPTY
97196: LIST
97197: LIST
97198: LIST
97199: LIST
97200: LIST
97201: LIST
97202: LIST
97203: LIST
97204: LIST
97205: LIST
97206: LIST
97207: LIST
97208: LIST
97209: LIST
97210: LIST
97211: LIST
97212: LIST
97213: LIST
97214: PUSH
97215: EMPTY
97216: LIST
97217: LIST
97218: ST_TO_ADDR
// if result then
97219: LD_VAR 0 2
97223: IFFALSE 98009
// begin normal :=  ;
97225: LD_ADDR_VAR 0 5
97229: PUSH
97230: LD_STRING 
97232: ST_TO_ADDR
// hardcore :=  ;
97233: LD_ADDR_VAR 0 6
97237: PUSH
97238: LD_STRING 
97240: ST_TO_ADDR
// active :=  ;
97241: LD_ADDR_VAR 0 7
97245: PUSH
97246: LD_STRING 
97248: ST_TO_ADDR
// for i = 1 to normalCounter do
97249: LD_ADDR_VAR 0 8
97253: PUSH
97254: DOUBLE
97255: LD_INT 1
97257: DEC
97258: ST_TO_ADDR
97259: LD_EXP 140
97263: PUSH
97264: FOR_TO
97265: IFFALSE 97366
// begin tmp := 0 ;
97267: LD_ADDR_VAR 0 3
97271: PUSH
97272: LD_STRING 0
97274: ST_TO_ADDR
// if result [ 1 ] then
97275: LD_VAR 0 2
97279: PUSH
97280: LD_INT 1
97282: ARRAY
97283: IFFALSE 97348
// if result [ 1 ] [ 1 ] = i then
97285: LD_VAR 0 2
97289: PUSH
97290: LD_INT 1
97292: ARRAY
97293: PUSH
97294: LD_INT 1
97296: ARRAY
97297: PUSH
97298: LD_VAR 0 8
97302: EQUAL
97303: IFFALSE 97348
// begin result := Replace ( result , 1 , Delete ( result [ 1 ] , 1 ) ) ;
97305: LD_ADDR_VAR 0 2
97309: PUSH
97310: LD_VAR 0 2
97314: PPUSH
97315: LD_INT 1
97317: PPUSH
97318: LD_VAR 0 2
97322: PUSH
97323: LD_INT 1
97325: ARRAY
97326: PPUSH
97327: LD_INT 1
97329: PPUSH
97330: CALL_OW 3
97334: PPUSH
97335: CALL_OW 1
97339: ST_TO_ADDR
// tmp := 1 ;
97340: LD_ADDR_VAR 0 3
97344: PUSH
97345: LD_STRING 1
97347: ST_TO_ADDR
// end ; normal := normal & tmp ;
97348: LD_ADDR_VAR 0 5
97352: PUSH
97353: LD_VAR 0 5
97357: PUSH
97358: LD_VAR 0 3
97362: STR
97363: ST_TO_ADDR
// end ;
97364: GO 97264
97366: POP
97367: POP
// for i = 1 to hardcoreCounter do
97368: LD_ADDR_VAR 0 8
97372: PUSH
97373: DOUBLE
97374: LD_INT 1
97376: DEC
97377: ST_TO_ADDR
97378: LD_EXP 141
97382: PUSH
97383: FOR_TO
97384: IFFALSE 97489
// begin tmp := 0 ;
97386: LD_ADDR_VAR 0 3
97390: PUSH
97391: LD_STRING 0
97393: ST_TO_ADDR
// if result [ 2 ] then
97394: LD_VAR 0 2
97398: PUSH
97399: LD_INT 2
97401: ARRAY
97402: IFFALSE 97471
// if result [ 2 ] [ 1 ] = 100 + i then
97404: LD_VAR 0 2
97408: PUSH
97409: LD_INT 2
97411: ARRAY
97412: PUSH
97413: LD_INT 1
97415: ARRAY
97416: PUSH
97417: LD_INT 100
97419: PUSH
97420: LD_VAR 0 8
97424: PLUS
97425: EQUAL
97426: IFFALSE 97471
// begin result := Replace ( result , 2 , Delete ( result [ 2 ] , 1 ) ) ;
97428: LD_ADDR_VAR 0 2
97432: PUSH
97433: LD_VAR 0 2
97437: PPUSH
97438: LD_INT 2
97440: PPUSH
97441: LD_VAR 0 2
97445: PUSH
97446: LD_INT 2
97448: ARRAY
97449: PPUSH
97450: LD_INT 1
97452: PPUSH
97453: CALL_OW 3
97457: PPUSH
97458: CALL_OW 1
97462: ST_TO_ADDR
// tmp := 1 ;
97463: LD_ADDR_VAR 0 3
97467: PUSH
97468: LD_STRING 1
97470: ST_TO_ADDR
// end ; hardcore := hardcore & tmp ;
97471: LD_ADDR_VAR 0 6
97475: PUSH
97476: LD_VAR 0 6
97480: PUSH
97481: LD_VAR 0 3
97485: STR
97486: ST_TO_ADDR
// end ;
97487: GO 97383
97489: POP
97490: POP
// if isGameLoad then
97491: LD_VAR 0 1
97495: IFFALSE 97970
// begin flags := [ sRocket , sSpeed , sEngine , sSpec , sLevel , sArmoury , sRadar , sBunker , sHack , sFire , sRefresh , sExp , sDepot , sFlag , sKamikadze , sTroll , sSlow , sLack , sTank , sRemote , sPowell , sTeleport , sOilTower , sShovel , sSheik , sEarthquake , sAI , sCargo , sDLaser , sExchange , sFac , sPower , sRandom , sShield , sTime , sTools , sSold , sDiff , sFog , sReset , sSun , sTiger , sBomb , sWound , sBetray , sContamin , sOil , sStu , sBazooka , sMortar , sRanger , sComputer , s30 , s60 ] ;
97497: LD_ADDR_VAR 0 4
97501: PUSH
97502: LD_EXP 144
97506: PUSH
97507: LD_EXP 143
97511: PUSH
97512: LD_EXP 145
97516: PUSH
97517: LD_EXP 142
97521: PUSH
97522: LD_EXP 146
97526: PUSH
97527: LD_EXP 147
97531: PUSH
97532: LD_EXP 148
97536: PUSH
97537: LD_EXP 149
97541: PUSH
97542: LD_EXP 150
97546: PUSH
97547: LD_EXP 151
97551: PUSH
97552: LD_EXP 152
97556: PUSH
97557: LD_EXP 153
97561: PUSH
97562: LD_EXP 154
97566: PUSH
97567: LD_EXP 155
97571: PUSH
97572: LD_EXP 163
97576: PUSH
97577: LD_EXP 164
97581: PUSH
97582: LD_EXP 165
97586: PUSH
97587: LD_EXP 166
97591: PUSH
97592: LD_EXP 168
97596: PUSH
97597: LD_EXP 169
97601: PUSH
97602: LD_EXP 170
97606: PUSH
97607: LD_EXP 173
97611: PUSH
97612: LD_EXP 175
97616: PUSH
97617: LD_EXP 176
97621: PUSH
97622: LD_EXP 177
97626: PUSH
97627: LD_EXP 179
97631: PUSH
97632: LD_EXP 180
97636: PUSH
97637: LD_EXP 183
97641: PUSH
97642: LD_EXP 184
97646: PUSH
97647: LD_EXP 185
97651: PUSH
97652: LD_EXP 186
97656: PUSH
97657: LD_EXP 187
97661: PUSH
97662: LD_EXP 188
97666: PUSH
97667: LD_EXP 189
97671: PUSH
97672: LD_EXP 190
97676: PUSH
97677: LD_EXP 191
97681: PUSH
97682: LD_EXP 156
97686: PUSH
97687: LD_EXP 157
97691: PUSH
97692: LD_EXP 160
97696: PUSH
97697: LD_EXP 161
97701: PUSH
97702: LD_EXP 162
97706: PUSH
97707: LD_EXP 158
97711: PUSH
97712: LD_EXP 159
97716: PUSH
97717: LD_EXP 167
97721: PUSH
97722: LD_EXP 171
97726: PUSH
97727: LD_EXP 172
97731: PUSH
97732: LD_EXP 174
97736: PUSH
97737: LD_EXP 178
97741: PUSH
97742: LD_EXP 181
97746: PUSH
97747: LD_EXP 182
97751: PUSH
97752: LD_EXP 192
97756: PUSH
97757: LD_EXP 193
97761: PUSH
97762: LD_EXP 194
97766: PUSH
97767: LD_EXP 195
97771: PUSH
97772: EMPTY
97773: LIST
97774: LIST
97775: LIST
97776: LIST
97777: LIST
97778: LIST
97779: LIST
97780: LIST
97781: LIST
97782: LIST
97783: LIST
97784: LIST
97785: LIST
97786: LIST
97787: LIST
97788: LIST
97789: LIST
97790: LIST
97791: LIST
97792: LIST
97793: LIST
97794: LIST
97795: LIST
97796: LIST
97797: LIST
97798: LIST
97799: LIST
97800: LIST
97801: LIST
97802: LIST
97803: LIST
97804: LIST
97805: LIST
97806: LIST
97807: LIST
97808: LIST
97809: LIST
97810: LIST
97811: LIST
97812: LIST
97813: LIST
97814: LIST
97815: LIST
97816: LIST
97817: LIST
97818: LIST
97819: LIST
97820: LIST
97821: LIST
97822: LIST
97823: LIST
97824: LIST
97825: LIST
97826: LIST
97827: ST_TO_ADDR
// tmp :=  ;
97828: LD_ADDR_VAR 0 3
97832: PUSH
97833: LD_STRING 
97835: ST_TO_ADDR
// for i = 1 to normalCounter do
97836: LD_ADDR_VAR 0 8
97840: PUSH
97841: DOUBLE
97842: LD_INT 1
97844: DEC
97845: ST_TO_ADDR
97846: LD_EXP 140
97850: PUSH
97851: FOR_TO
97852: IFFALSE 97888
// begin if flags [ i ] then
97854: LD_VAR 0 4
97858: PUSH
97859: LD_VAR 0 8
97863: ARRAY
97864: IFFALSE 97886
// tmp := tmp & i & ; ;
97866: LD_ADDR_VAR 0 3
97870: PUSH
97871: LD_VAR 0 3
97875: PUSH
97876: LD_VAR 0 8
97880: STR
97881: PUSH
97882: LD_STRING ;
97884: STR
97885: ST_TO_ADDR
// end ;
97886: GO 97851
97888: POP
97889: POP
// for i = 1 to hardcoreCounter do
97890: LD_ADDR_VAR 0 8
97894: PUSH
97895: DOUBLE
97896: LD_INT 1
97898: DEC
97899: ST_TO_ADDR
97900: LD_EXP 141
97904: PUSH
97905: FOR_TO
97906: IFFALSE 97952
// begin if flags [ normalCounter + i ] then
97908: LD_VAR 0 4
97912: PUSH
97913: LD_EXP 140
97917: PUSH
97918: LD_VAR 0 8
97922: PLUS
97923: ARRAY
97924: IFFALSE 97950
// tmp := tmp & ( 100 + i ) & ; ;
97926: LD_ADDR_VAR 0 3
97930: PUSH
97931: LD_VAR 0 3
97935: PUSH
97936: LD_INT 100
97938: PUSH
97939: LD_VAR 0 8
97943: PLUS
97944: STR
97945: PUSH
97946: LD_STRING ;
97948: STR
97949: ST_TO_ADDR
// end ;
97950: GO 97905
97952: POP
97953: POP
// if tmp then
97954: LD_VAR 0 3
97958: IFFALSE 97970
// active := tmp ;
97960: LD_ADDR_VAR 0 7
97964: PUSH
97965: LD_VAR 0 3
97969: ST_TO_ADDR
// end ; ToLua ( getStreamItemsFromMission(" & normal & "," & hardcore & "," & active & ") ) ;
97970: LD_STRING getStreamItemsFromMission("
97972: PUSH
97973: LD_VAR 0 5
97977: STR
97978: PUSH
97979: LD_STRING ","
97981: STR
97982: PUSH
97983: LD_VAR 0 6
97987: STR
97988: PUSH
97989: LD_STRING ","
97991: STR
97992: PUSH
97993: LD_VAR 0 7
97997: STR
97998: PUSH
97999: LD_STRING ")
98001: STR
98002: PPUSH
98003: CALL_OW 559
// end else
98007: GO 98016
// ToLua ( getStreamItemsFromMission("","","") ) ;
98009: LD_STRING getStreamItemsFromMission("","","")
98011: PPUSH
98012: CALL_OW 559
// end ;
98016: LD_VAR 0 2
98020: RET
// every 0 0$2 trigger StreamModeActive and sRocket do var i , tmp ;
98021: LD_EXP 139
98025: PUSH
98026: LD_EXP 144
98030: AND
98031: IFFALSE 98155
98033: GO 98035
98035: DISABLE
98036: LD_INT 0
98038: PPUSH
98039: PPUSH
// begin enable ;
98040: ENABLE
// tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_or , [ f_weapon , us_rocket_launcher ] , [ f_weapon , ru_rocket_launcher ] , [ f_weapon , ar_rocket_launcher ] , [ f_weapon , ru_rocket ] ] ] ) ;
98041: LD_ADDR_VAR 0 2
98045: PUSH
98046: LD_INT 22
98048: PUSH
98049: LD_OWVAR 2
98053: PUSH
98054: EMPTY
98055: LIST
98056: LIST
98057: PUSH
98058: LD_INT 2
98060: PUSH
98061: LD_INT 34
98063: PUSH
98064: LD_INT 7
98066: PUSH
98067: EMPTY
98068: LIST
98069: LIST
98070: PUSH
98071: LD_INT 34
98073: PUSH
98074: LD_INT 45
98076: PUSH
98077: EMPTY
98078: LIST
98079: LIST
98080: PUSH
98081: LD_INT 34
98083: PUSH
98084: LD_INT 28
98086: PUSH
98087: EMPTY
98088: LIST
98089: LIST
98090: PUSH
98091: LD_INT 34
98093: PUSH
98094: LD_INT 47
98096: PUSH
98097: EMPTY
98098: LIST
98099: LIST
98100: PUSH
98101: EMPTY
98102: LIST
98103: LIST
98104: LIST
98105: LIST
98106: LIST
98107: PUSH
98108: EMPTY
98109: LIST
98110: LIST
98111: PPUSH
98112: CALL_OW 69
98116: ST_TO_ADDR
// if not tmp then
98117: LD_VAR 0 2
98121: NOT
98122: IFFALSE 98126
// exit ;
98124: GO 98155
// for i in tmp do
98126: LD_ADDR_VAR 0 1
98130: PUSH
98131: LD_VAR 0 2
98135: PUSH
98136: FOR_IN
98137: IFFALSE 98153
// begin SetLives ( i , 0 ) ;
98139: LD_VAR 0 1
98143: PPUSH
98144: LD_INT 0
98146: PPUSH
98147: CALL_OW 234
// end ;
98151: GO 98136
98153: POP
98154: POP
// end ;
98155: PPOPN 2
98157: END
// every 0 0$2 trigger StreamModeActive and sEngine do var i , tmp ;
98158: LD_EXP 139
98162: PUSH
98163: LD_EXP 145
98167: AND
98168: IFFALSE 98252
98170: GO 98172
98172: DISABLE
98173: LD_INT 0
98175: PPUSH
98176: PPUSH
// begin enable ;
98177: ENABLE
// tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_engine , engine_siberite ] ] ) ;
98178: LD_ADDR_VAR 0 2
98182: PUSH
98183: LD_INT 22
98185: PUSH
98186: LD_OWVAR 2
98190: PUSH
98191: EMPTY
98192: LIST
98193: LIST
98194: PUSH
98195: LD_INT 32
98197: PUSH
98198: LD_INT 3
98200: PUSH
98201: EMPTY
98202: LIST
98203: LIST
98204: PUSH
98205: EMPTY
98206: LIST
98207: LIST
98208: PPUSH
98209: CALL_OW 69
98213: ST_TO_ADDR
// if not tmp then
98214: LD_VAR 0 2
98218: NOT
98219: IFFALSE 98223
// exit ;
98221: GO 98252
// for i in tmp do
98223: LD_ADDR_VAR 0 1
98227: PUSH
98228: LD_VAR 0 2
98232: PUSH
98233: FOR_IN
98234: IFFALSE 98250
// begin SetLives ( i , 0 ) ;
98236: LD_VAR 0 1
98240: PPUSH
98241: LD_INT 0
98243: PPUSH
98244: CALL_OW 234
// end ;
98248: GO 98233
98250: POP
98251: POP
// end ;
98252: PPOPN 2
98254: END
// every 0 0$1 trigger StreamModeActive and sSpec do var i ;
98255: LD_EXP 139
98259: PUSH
98260: LD_EXP 142
98264: AND
98265: IFFALSE 98358
98267: GO 98269
98269: DISABLE
98270: LD_INT 0
98272: PPUSH
// begin enable ;
98273: ENABLE
// for i in FilterAllUnits ( [ [ f_side , your_side ] , [ f_or , [ f_class , class_sniper ] , [ f_class , class_bazooker ] , [ f_class , class_mortar ] ] ] ) do
98274: LD_ADDR_VAR 0 1
98278: PUSH
98279: LD_INT 22
98281: PUSH
98282: LD_OWVAR 2
98286: PUSH
98287: EMPTY
98288: LIST
98289: LIST
98290: PUSH
98291: LD_INT 2
98293: PUSH
98294: LD_INT 25
98296: PUSH
98297: LD_INT 5
98299: PUSH
98300: EMPTY
98301: LIST
98302: LIST
98303: PUSH
98304: LD_INT 25
98306: PUSH
98307: LD_INT 9
98309: PUSH
98310: EMPTY
98311: LIST
98312: LIST
98313: PUSH
98314: LD_INT 25
98316: PUSH
98317: LD_INT 8
98319: PUSH
98320: EMPTY
98321: LIST
98322: LIST
98323: PUSH
98324: EMPTY
98325: LIST
98326: LIST
98327: LIST
98328: LIST
98329: PUSH
98330: EMPTY
98331: LIST
98332: LIST
98333: PPUSH
98334: CALL_OW 69
98338: PUSH
98339: FOR_IN
98340: IFFALSE 98356
// begin SetClass ( i , 1 ) ;
98342: LD_VAR 0 1
98346: PPUSH
98347: LD_INT 1
98349: PPUSH
98350: CALL_OW 336
// end ;
98354: GO 98339
98356: POP
98357: POP
// end ;
98358: PPOPN 1
98360: END
// every 0 0$1 trigger StreamModeActive and sSpeed and game_speed < 7 do
98361: LD_EXP 139
98365: PUSH
98366: LD_EXP 143
98370: AND
98371: PUSH
98372: LD_OWVAR 65
98376: PUSH
98377: LD_INT 7
98379: LESS
98380: AND
98381: IFFALSE 98395
98383: GO 98385
98385: DISABLE
// begin enable ;
98386: ENABLE
// game_speed := 7 ;
98387: LD_ADDR_OWVAR 65
98391: PUSH
98392: LD_INT 7
98394: ST_TO_ADDR
// end ;
98395: END
// every 0 0$1 trigger StreamModeActive and sLevel do var i , k , tmp ;
98396: LD_EXP 139
98400: PUSH
98401: LD_EXP 146
98405: AND
98406: IFFALSE 98608
98408: GO 98410
98410: DISABLE
98411: LD_INT 0
98413: PPUSH
98414: PPUSH
98415: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_enemy , your_side ] , [ f_type , unit_human ] ] ) ;
98416: LD_ADDR_VAR 0 3
98420: PUSH
98421: LD_INT 81
98423: PUSH
98424: LD_OWVAR 2
98428: PUSH
98429: EMPTY
98430: LIST
98431: LIST
98432: PUSH
98433: LD_INT 21
98435: PUSH
98436: LD_INT 1
98438: PUSH
98439: EMPTY
98440: LIST
98441: LIST
98442: PUSH
98443: EMPTY
98444: LIST
98445: LIST
98446: PPUSH
98447: CALL_OW 69
98451: ST_TO_ADDR
// if not tmp then
98452: LD_VAR 0 3
98456: NOT
98457: IFFALSE 98461
// exit ;
98459: GO 98608
// if tmp > 5 then
98461: LD_VAR 0 3
98465: PUSH
98466: LD_INT 5
98468: GREATER
98469: IFFALSE 98481
// k := 5 else
98471: LD_ADDR_VAR 0 2
98475: PUSH
98476: LD_INT 5
98478: ST_TO_ADDR
98479: GO 98491
// k := tmp ;
98481: LD_ADDR_VAR 0 2
98485: PUSH
98486: LD_VAR 0 3
98490: ST_TO_ADDR
// for i := 1 to k do
98491: LD_ADDR_VAR 0 1
98495: PUSH
98496: DOUBLE
98497: LD_INT 1
98499: DEC
98500: ST_TO_ADDR
98501: LD_VAR 0 2
98505: PUSH
98506: FOR_TO
98507: IFFALSE 98606
// if GetSkill ( tmp [ i ] , i mod 4 + 1 ) < 10 then
98509: LD_VAR 0 3
98513: PUSH
98514: LD_VAR 0 1
98518: ARRAY
98519: PPUSH
98520: LD_VAR 0 1
98524: PUSH
98525: LD_INT 4
98527: MOD
98528: PUSH
98529: LD_INT 1
98531: PLUS
98532: PPUSH
98533: CALL_OW 259
98537: PUSH
98538: LD_INT 10
98540: LESS
98541: IFFALSE 98604
// SetSkill ( tmp [ i ] , i mod 4 + 1 , GetSkill ( tmp [ i ] , i mod 4 + 1 ) + 1 ) ;
98543: LD_VAR 0 3
98547: PUSH
98548: LD_VAR 0 1
98552: ARRAY
98553: PPUSH
98554: LD_VAR 0 1
98558: PUSH
98559: LD_INT 4
98561: MOD
98562: PUSH
98563: LD_INT 1
98565: PLUS
98566: PPUSH
98567: LD_VAR 0 3
98571: PUSH
98572: LD_VAR 0 1
98576: ARRAY
98577: PPUSH
98578: LD_VAR 0 1
98582: PUSH
98583: LD_INT 4
98585: MOD
98586: PUSH
98587: LD_INT 1
98589: PLUS
98590: PPUSH
98591: CALL_OW 259
98595: PUSH
98596: LD_INT 1
98598: PLUS
98599: PPUSH
98600: CALL_OW 237
98604: GO 98506
98606: POP
98607: POP
// end ;
98608: PPOPN 3
98610: END
// every 0 0$1 trigger StreamModeActive and sArmoury do
98611: LD_EXP 139
98615: PUSH
98616: LD_EXP 147
98620: AND
98621: IFFALSE 98641
98623: GO 98625
98625: DISABLE
// SetRestrict ( b_armoury , your_side , false ) ;
98626: LD_INT 4
98628: PPUSH
98629: LD_OWVAR 2
98633: PPUSH
98634: LD_INT 0
98636: PPUSH
98637: CALL_OW 324
98641: END
// every 0 0$1 trigger StreamModeActive and sShovel do
98642: LD_EXP 139
98646: PUSH
98647: LD_EXP 176
98651: AND
98652: IFFALSE 98672
98654: GO 98656
98656: DISABLE
// SetRestrict ( b_ext_noncombat , your_side , false ) ;
98657: LD_INT 19
98659: PPUSH
98660: LD_OWVAR 2
98664: PPUSH
98665: LD_INT 0
98667: PPUSH
98668: CALL_OW 324
98672: END
// every 0 0$1 trigger StreamModeActive and sRadar do var i , tmp ;
98673: LD_EXP 139
98677: PUSH
98678: LD_EXP 148
98682: AND
98683: IFFALSE 98785
98685: GO 98687
98687: DISABLE
98688: LD_INT 0
98690: PPUSH
98691: PPUSH
// begin enable ;
98692: ENABLE
// tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_or , [ f_weapon , us_radar ] , [ f_weapon , ar_radar ] ] ] ) ;
98693: LD_ADDR_VAR 0 2
98697: PUSH
98698: LD_INT 22
98700: PUSH
98701: LD_OWVAR 2
98705: PUSH
98706: EMPTY
98707: LIST
98708: LIST
98709: PUSH
98710: LD_INT 2
98712: PUSH
98713: LD_INT 34
98715: PUSH
98716: LD_INT 11
98718: PUSH
98719: EMPTY
98720: LIST
98721: LIST
98722: PUSH
98723: LD_INT 34
98725: PUSH
98726: LD_INT 30
98728: PUSH
98729: EMPTY
98730: LIST
98731: LIST
98732: PUSH
98733: EMPTY
98734: LIST
98735: LIST
98736: LIST
98737: PUSH
98738: EMPTY
98739: LIST
98740: LIST
98741: PPUSH
98742: CALL_OW 69
98746: ST_TO_ADDR
// if not tmp then
98747: LD_VAR 0 2
98751: NOT
98752: IFFALSE 98756
// exit ;
98754: GO 98785
// for i in tmp do
98756: LD_ADDR_VAR 0 1
98760: PUSH
98761: LD_VAR 0 2
98765: PUSH
98766: FOR_IN
98767: IFFALSE 98783
// begin SetLives ( i , 0 ) ;
98769: LD_VAR 0 1
98773: PPUSH
98774: LD_INT 0
98776: PPUSH
98777: CALL_OW 234
// end ;
98781: GO 98766
98783: POP
98784: POP
// end ;
98785: PPOPN 2
98787: END
// every 0 0$1 trigger StreamModeActive and sBunker do
98788: LD_EXP 139
98792: PUSH
98793: LD_EXP 149
98797: AND
98798: IFFALSE 98818
98800: GO 98802
98802: DISABLE
// SetRestrict ( b_bunker , your_side , false ) ;
98803: LD_INT 32
98805: PPUSH
98806: LD_OWVAR 2
98810: PPUSH
98811: LD_INT 0
98813: PPUSH
98814: CALL_OW 324
98818: END
// every 0 0$1 trigger StreamModeActive and sHack do var i , tmp , side ;
98819: LD_EXP 139
98823: PUSH
98824: LD_EXP 150
98828: AND
98829: IFFALSE 99010
98831: GO 98833
98833: DISABLE
98834: LD_INT 0
98836: PPUSH
98837: PPUSH
98838: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_control , control_computer ] ] ) ;
98839: LD_ADDR_VAR 0 2
98843: PUSH
98844: LD_INT 22
98846: PUSH
98847: LD_OWVAR 2
98851: PUSH
98852: EMPTY
98853: LIST
98854: LIST
98855: PUSH
98856: LD_INT 33
98858: PUSH
98859: LD_INT 3
98861: PUSH
98862: EMPTY
98863: LIST
98864: LIST
98865: PUSH
98866: EMPTY
98867: LIST
98868: LIST
98869: PPUSH
98870: CALL_OW 69
98874: ST_TO_ADDR
// if not tmp then
98875: LD_VAR 0 2
98879: NOT
98880: IFFALSE 98884
// exit ;
98882: GO 99010
// side := 0 ;
98884: LD_ADDR_VAR 0 3
98888: PUSH
98889: LD_INT 0
98891: ST_TO_ADDR
// for i := 1 to 8 do
98892: LD_ADDR_VAR 0 1
98896: PUSH
98897: DOUBLE
98898: LD_INT 1
98900: DEC
98901: ST_TO_ADDR
98902: LD_INT 8
98904: PUSH
98905: FOR_TO
98906: IFFALSE 98954
// if your_side <> i and GetAttitude ( your_side , i ) = att_enemy then
98908: LD_OWVAR 2
98912: PUSH
98913: LD_VAR 0 1
98917: NONEQUAL
98918: PUSH
98919: LD_OWVAR 2
98923: PPUSH
98924: LD_VAR 0 1
98928: PPUSH
98929: CALL_OW 81
98933: PUSH
98934: LD_INT 2
98936: EQUAL
98937: AND
98938: IFFALSE 98952
// begin side := i ;
98940: LD_ADDR_VAR 0 3
98944: PUSH
98945: LD_VAR 0 1
98949: ST_TO_ADDR
// break ;
98950: GO 98954
// end ;
98952: GO 98905
98954: POP
98955: POP
// if not side then
98956: LD_VAR 0 3
98960: NOT
98961: IFFALSE 98965
// exit ;
98963: GO 99010
// for i := 1 to tmp do
98965: LD_ADDR_VAR 0 1
98969: PUSH
98970: DOUBLE
98971: LD_INT 1
98973: DEC
98974: ST_TO_ADDR
98975: LD_VAR 0 2
98979: PUSH
98980: FOR_TO
98981: IFFALSE 99008
// if Prob ( 60 ) then
98983: LD_INT 60
98985: PPUSH
98986: CALL_OW 13
98990: IFFALSE 99006
// SetSide ( i , side ) ;
98992: LD_VAR 0 1
98996: PPUSH
98997: LD_VAR 0 3
99001: PPUSH
99002: CALL_OW 235
99006: GO 98980
99008: POP
99009: POP
// end ;
99010: PPOPN 3
99012: END
// every 0 0$1 trigger StreamModeActive and sRefresh do var un ;
99013: LD_EXP 139
99017: PUSH
99018: LD_EXP 152
99022: AND
99023: IFFALSE 99142
99025: GO 99027
99027: DISABLE
99028: LD_INT 0
99030: PPUSH
// begin for un in FilterAllUnits ( [ [ f_side , your_side ] , [ f_type , unit_human ] , [ f_not , [ f_nation , 0 ] ] ] ) do
99031: LD_ADDR_VAR 0 1
99035: PUSH
99036: LD_INT 22
99038: PUSH
99039: LD_OWVAR 2
99043: PUSH
99044: EMPTY
99045: LIST
99046: LIST
99047: PUSH
99048: LD_INT 21
99050: PUSH
99051: LD_INT 1
99053: PUSH
99054: EMPTY
99055: LIST
99056: LIST
99057: PUSH
99058: LD_INT 3
99060: PUSH
99061: LD_INT 23
99063: PUSH
99064: LD_INT 0
99066: PUSH
99067: EMPTY
99068: LIST
99069: LIST
99070: PUSH
99071: EMPTY
99072: LIST
99073: LIST
99074: PUSH
99075: EMPTY
99076: LIST
99077: LIST
99078: LIST
99079: PPUSH
99080: CALL_OW 69
99084: PUSH
99085: FOR_IN
99086: IFFALSE 99140
// if GetClass ( un ) in [ 1 , 2 , 3 , 4 ] then
99088: LD_VAR 0 1
99092: PPUSH
99093: CALL_OW 257
99097: PUSH
99098: LD_INT 1
99100: PUSH
99101: LD_INT 2
99103: PUSH
99104: LD_INT 3
99106: PUSH
99107: LD_INT 4
99109: PUSH
99110: EMPTY
99111: LIST
99112: LIST
99113: LIST
99114: LIST
99115: IN
99116: IFFALSE 99138
// SetClass ( un , rand ( 1 , 4 ) ) ;
99118: LD_VAR 0 1
99122: PPUSH
99123: LD_INT 1
99125: PPUSH
99126: LD_INT 4
99128: PPUSH
99129: CALL_OW 12
99133: PPUSH
99134: CALL_OW 336
99138: GO 99085
99140: POP
99141: POP
// end ;
99142: PPOPN 1
99144: END
// every 0 0$1 trigger StreamModeActive and sFire do var tmp ;
99145: LD_EXP 139
99149: PUSH
99150: LD_EXP 151
99154: AND
99155: IFFALSE 99234
99157: GO 99159
99159: DISABLE
99160: LD_INT 0
99162: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_type , unit_building ] ] ) ;
99163: LD_ADDR_VAR 0 1
99167: PUSH
99168: LD_INT 22
99170: PUSH
99171: LD_OWVAR 2
99175: PUSH
99176: EMPTY
99177: LIST
99178: LIST
99179: PUSH
99180: LD_INT 21
99182: PUSH
99183: LD_INT 3
99185: PUSH
99186: EMPTY
99187: LIST
99188: LIST
99189: PUSH
99190: EMPTY
99191: LIST
99192: LIST
99193: PPUSH
99194: CALL_OW 69
99198: ST_TO_ADDR
// if not tmp then
99199: LD_VAR 0 1
99203: NOT
99204: IFFALSE 99208
// exit ;
99206: GO 99234
// SetLives ( tmp [ rand ( 1 , tmp ) ] , 100 ) ;
99208: LD_VAR 0 1
99212: PUSH
99213: LD_INT 1
99215: PPUSH
99216: LD_VAR 0 1
99220: PPUSH
99221: CALL_OW 12
99225: ARRAY
99226: PPUSH
99227: LD_INT 100
99229: PPUSH
99230: CALL_OW 234
// end ;
99234: PPOPN 1
99236: END
// every 0 0$1 trigger StreamModeActive and sExp do var tmp ;
99237: LD_EXP 139
99241: PUSH
99242: LD_EXP 153
99246: AND
99247: IFFALSE 99345
99249: GO 99251
99251: DISABLE
99252: LD_INT 0
99254: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_type , unit_human ] ] ) ;
99255: LD_ADDR_VAR 0 1
99259: PUSH
99260: LD_INT 22
99262: PUSH
99263: LD_OWVAR 2
99267: PUSH
99268: EMPTY
99269: LIST
99270: LIST
99271: PUSH
99272: LD_INT 21
99274: PUSH
99275: LD_INT 1
99277: PUSH
99278: EMPTY
99279: LIST
99280: LIST
99281: PUSH
99282: EMPTY
99283: LIST
99284: LIST
99285: PPUSH
99286: CALL_OW 69
99290: ST_TO_ADDR
// if not tmp then
99291: LD_VAR 0 1
99295: NOT
99296: IFFALSE 99300
// exit ;
99298: GO 99345
// AddExperience ( tmp [ rand ( 1 , tmp ) ] , rand ( 1 , 4 ) , rand ( 3000 , 9000 ) ) ;
99300: LD_VAR 0 1
99304: PUSH
99305: LD_INT 1
99307: PPUSH
99308: LD_VAR 0 1
99312: PPUSH
99313: CALL_OW 12
99317: ARRAY
99318: PPUSH
99319: LD_INT 1
99321: PPUSH
99322: LD_INT 4
99324: PPUSH
99325: CALL_OW 12
99329: PPUSH
99330: LD_INT 3000
99332: PPUSH
99333: LD_INT 9000
99335: PPUSH
99336: CALL_OW 12
99340: PPUSH
99341: CALL_OW 492
// end ;
99345: PPOPN 1
99347: END
// every 0 0$1 trigger StreamModeActive and sDepot do
99348: LD_EXP 139
99352: PUSH
99353: LD_EXP 154
99357: AND
99358: IFFALSE 99378
99360: GO 99362
99362: DISABLE
// SetRestrict ( b_warehouse , your_side , false ) ;
99363: LD_INT 1
99365: PPUSH
99366: LD_OWVAR 2
99370: PPUSH
99371: LD_INT 0
99373: PPUSH
99374: CALL_OW 324
99378: END
// every 0 0$1 trigger StreamModeActive and sFlag do var i , tmp ;
99379: LD_EXP 139
99383: PUSH
99384: LD_EXP 155
99388: AND
99389: IFFALSE 99472
99391: GO 99393
99393: DISABLE
99394: LD_INT 0
99396: PPUSH
99397: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_type , unit_building ] ] ) ;
99398: LD_ADDR_VAR 0 2
99402: PUSH
99403: LD_INT 22
99405: PUSH
99406: LD_OWVAR 2
99410: PUSH
99411: EMPTY
99412: LIST
99413: LIST
99414: PUSH
99415: LD_INT 21
99417: PUSH
99418: LD_INT 3
99420: PUSH
99421: EMPTY
99422: LIST
99423: LIST
99424: PUSH
99425: EMPTY
99426: LIST
99427: LIST
99428: PPUSH
99429: CALL_OW 69
99433: ST_TO_ADDR
// if not tmp then
99434: LD_VAR 0 2
99438: NOT
99439: IFFALSE 99443
// exit ;
99441: GO 99472
// for i in tmp do
99443: LD_ADDR_VAR 0 1
99447: PUSH
99448: LD_VAR 0 2
99452: PUSH
99453: FOR_IN
99454: IFFALSE 99470
// SetBLevel ( i , 10 ) ;
99456: LD_VAR 0 1
99460: PPUSH
99461: LD_INT 10
99463: PPUSH
99464: CALL_OW 241
99468: GO 99453
99470: POP
99471: POP
// end ;
99472: PPOPN 2
99474: END
// every 0 0$1 trigger StreamModeActive and sSold do var i , un , tmp ;
99475: LD_EXP 139
99479: PUSH
99480: LD_EXP 156
99484: AND
99485: IFFALSE 99596
99487: GO 99489
99489: DISABLE
99490: LD_INT 0
99492: PPUSH
99493: PPUSH
99494: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_class , 1 ] ] ) ;
99495: LD_ADDR_VAR 0 3
99499: PUSH
99500: LD_INT 22
99502: PUSH
99503: LD_OWVAR 2
99507: PUSH
99508: EMPTY
99509: LIST
99510: LIST
99511: PUSH
99512: LD_INT 25
99514: PUSH
99515: LD_INT 1
99517: PUSH
99518: EMPTY
99519: LIST
99520: LIST
99521: PUSH
99522: EMPTY
99523: LIST
99524: LIST
99525: PPUSH
99526: CALL_OW 69
99530: ST_TO_ADDR
// if not tmp then
99531: LD_VAR 0 3
99535: NOT
99536: IFFALSE 99540
// exit ;
99538: GO 99596
// un := tmp [ rand ( 1 , tmp ) ] ;
99540: LD_ADDR_VAR 0 2
99544: PUSH
99545: LD_VAR 0 3
99549: PUSH
99550: LD_INT 1
99552: PPUSH
99553: LD_VAR 0 3
99557: PPUSH
99558: CALL_OW 12
99562: ARRAY
99563: ST_TO_ADDR
// if Crawls ( un ) then
99564: LD_VAR 0 2
99568: PPUSH
99569: CALL_OW 318
99573: IFFALSE 99584
// ComWalk ( un ) ;
99575: LD_VAR 0 2
99579: PPUSH
99580: CALL_OW 138
// SetClass ( un , class_sniper ) ;
99584: LD_VAR 0 2
99588: PPUSH
99589: LD_INT 5
99591: PPUSH
99592: CALL_OW 336
// end ;
99596: PPOPN 3
99598: END
// every 0 0$1 trigger StreamModeActive and sDiff and Difficulty < 4 do
99599: LD_EXP 139
99603: PUSH
99604: LD_EXP 157
99608: AND
99609: PUSH
99610: LD_OWVAR 67
99614: PUSH
99615: LD_INT 4
99617: LESS
99618: AND
99619: IFFALSE 99638
99621: GO 99623
99623: DISABLE
// begin Difficulty := Difficulty + 1 ;
99624: LD_ADDR_OWVAR 67
99628: PUSH
99629: LD_OWVAR 67
99633: PUSH
99634: LD_INT 1
99636: PLUS
99637: ST_TO_ADDR
// end ;
99638: END
// every 0 0$1 trigger StreamModeActive and sTiger do var i ;
99639: LD_EXP 139
99643: PUSH
99644: LD_EXP 158
99648: AND
99649: IFFALSE 99752
99651: GO 99653
99653: DISABLE
99654: LD_INT 0
99656: PPUSH
// begin for i := 1 to 5 do
99657: LD_ADDR_VAR 0 1
99661: PUSH
99662: DOUBLE
99663: LD_INT 1
99665: DEC
99666: ST_TO_ADDR
99667: LD_INT 5
99669: PUSH
99670: FOR_TO
99671: IFFALSE 99750
// begin uc_nation := nation_nature ;
99673: LD_ADDR_OWVAR 21
99677: PUSH
99678: LD_INT 0
99680: ST_TO_ADDR
// uc_side := 0 ;
99681: LD_ADDR_OWVAR 20
99685: PUSH
99686: LD_INT 0
99688: ST_TO_ADDR
// hc_attr := [ 12 , 12 ] ;
99689: LD_ADDR_OWVAR 29
99693: PUSH
99694: LD_INT 12
99696: PUSH
99697: LD_INT 12
99699: PUSH
99700: EMPTY
99701: LIST
99702: LIST
99703: ST_TO_ADDR
// hc_agressivity := 20 ;
99704: LD_ADDR_OWVAR 35
99708: PUSH
99709: LD_INT 20
99711: ST_TO_ADDR
// hc_class := class_tiger ;
99712: LD_ADDR_OWVAR 28
99716: PUSH
99717: LD_INT 14
99719: ST_TO_ADDR
// hc_gallery :=  ;
99720: LD_ADDR_OWVAR 33
99724: PUSH
99725: LD_STRING 
99727: ST_TO_ADDR
// hc_name :=  ;
99728: LD_ADDR_OWVAR 26
99732: PUSH
99733: LD_STRING 
99735: ST_TO_ADDR
// PlaceUnitAnyWhere ( CreateHuman , false ) ;
99736: CALL_OW 44
99740: PPUSH
99741: LD_INT 0
99743: PPUSH
99744: CALL_OW 51
// end ;
99748: GO 99670
99750: POP
99751: POP
// end ;
99752: PPOPN 1
99754: END
// every 0 0$1 trigger StreamModeActive and sBomb do
99755: LD_EXP 139
99759: PUSH
99760: LD_EXP 159
99764: AND
99765: IFFALSE 99774
99767: GO 99769
99769: DISABLE
// StreamSibBomb ;
99770: CALL 99775 0 0
99774: END
// export function StreamSibBomb ; var i , x , y ; begin
99775: LD_INT 0
99777: PPUSH
99778: PPUSH
99779: PPUSH
99780: PPUSH
// result := false ;
99781: LD_ADDR_VAR 0 1
99785: PUSH
99786: LD_INT 0
99788: ST_TO_ADDR
// for i := 1 to 16 do
99789: LD_ADDR_VAR 0 2
99793: PUSH
99794: DOUBLE
99795: LD_INT 1
99797: DEC
99798: ST_TO_ADDR
99799: LD_INT 16
99801: PUSH
99802: FOR_TO
99803: IFFALSE 100002
// begin x := [ 10 , 20 , 30 , 40 , 50 , 60 , 70 , 80 , 90 , 100 , 110 , 120 , 130 , 140 , 150 ] [ rand ( 1 , 15 ) ] ;
99805: LD_ADDR_VAR 0 3
99809: PUSH
99810: LD_INT 10
99812: PUSH
99813: LD_INT 20
99815: PUSH
99816: LD_INT 30
99818: PUSH
99819: LD_INT 40
99821: PUSH
99822: LD_INT 50
99824: PUSH
99825: LD_INT 60
99827: PUSH
99828: LD_INT 70
99830: PUSH
99831: LD_INT 80
99833: PUSH
99834: LD_INT 90
99836: PUSH
99837: LD_INT 100
99839: PUSH
99840: LD_INT 110
99842: PUSH
99843: LD_INT 120
99845: PUSH
99846: LD_INT 130
99848: PUSH
99849: LD_INT 140
99851: PUSH
99852: LD_INT 150
99854: PUSH
99855: EMPTY
99856: LIST
99857: LIST
99858: LIST
99859: LIST
99860: LIST
99861: LIST
99862: LIST
99863: LIST
99864: LIST
99865: LIST
99866: LIST
99867: LIST
99868: LIST
99869: LIST
99870: LIST
99871: PUSH
99872: LD_INT 1
99874: PPUSH
99875: LD_INT 15
99877: PPUSH
99878: CALL_OW 12
99882: ARRAY
99883: ST_TO_ADDR
// y := [ 10 , 20 , 30 , 40 , 50 , 60 , 70 , 80 , 90 , 100 , 110 , 120 , 130 , 140 , 150 ] [ rand ( 1 , 15 ) ] ;
99884: LD_ADDR_VAR 0 4
99888: PUSH
99889: LD_INT 10
99891: PUSH
99892: LD_INT 20
99894: PUSH
99895: LD_INT 30
99897: PUSH
99898: LD_INT 40
99900: PUSH
99901: LD_INT 50
99903: PUSH
99904: LD_INT 60
99906: PUSH
99907: LD_INT 70
99909: PUSH
99910: LD_INT 80
99912: PUSH
99913: LD_INT 90
99915: PUSH
99916: LD_INT 100
99918: PUSH
99919: LD_INT 110
99921: PUSH
99922: LD_INT 120
99924: PUSH
99925: LD_INT 130
99927: PUSH
99928: LD_INT 140
99930: PUSH
99931: LD_INT 150
99933: PUSH
99934: EMPTY
99935: LIST
99936: LIST
99937: LIST
99938: LIST
99939: LIST
99940: LIST
99941: LIST
99942: LIST
99943: LIST
99944: LIST
99945: LIST
99946: LIST
99947: LIST
99948: LIST
99949: LIST
99950: PUSH
99951: LD_INT 1
99953: PPUSH
99954: LD_INT 15
99956: PPUSH
99957: CALL_OW 12
99961: ARRAY
99962: ST_TO_ADDR
// if ValidHex ( x , y ) then
99963: LD_VAR 0 3
99967: PPUSH
99968: LD_VAR 0 4
99972: PPUSH
99973: CALL_OW 488
99977: IFFALSE 100000
// begin result := [ x , y ] ;
99979: LD_ADDR_VAR 0 1
99983: PUSH
99984: LD_VAR 0 3
99988: PUSH
99989: LD_VAR 0 4
99993: PUSH
99994: EMPTY
99995: LIST
99996: LIST
99997: ST_TO_ADDR
// break ;
99998: GO 100002
// end ; end ;
100000: GO 99802
100002: POP
100003: POP
// if result then
100004: LD_VAR 0 1
100008: IFFALSE 100068
// begin ToLua ( playSibBomb() ) ;
100010: LD_STRING playSibBomb()
100012: PPUSH
100013: CALL_OW 559
// wait ( 0 0$14 ) ;
100017: LD_INT 490
100019: PPUSH
100020: CALL_OW 67
// CenterNowOnXY ( result [ 1 ] , result [ 2 ] ) ;
100024: LD_VAR 0 1
100028: PUSH
100029: LD_INT 1
100031: ARRAY
100032: PPUSH
100033: LD_VAR 0 1
100037: PUSH
100038: LD_INT 2
100040: ARRAY
100041: PPUSH
100042: CALL_OW 86
// SendSiberiteRocket ( result [ 1 ] , result [ 2 ] ) ;
100046: LD_VAR 0 1
100050: PUSH
100051: LD_INT 1
100053: ARRAY
100054: PPUSH
100055: LD_VAR 0 1
100059: PUSH
100060: LD_INT 2
100062: ARRAY
100063: PPUSH
100064: CALL_OW 429
// end ; end ;
100068: LD_VAR 0 1
100072: RET
// every 0 0$1 trigger StreamModeActive and sReset do
100073: LD_EXP 139
100077: PUSH
100078: LD_EXP 161
100082: AND
100083: IFFALSE 100095
100085: GO 100087
100087: DISABLE
// YouLost (  ) ;
100088: LD_STRING 
100090: PPUSH
100091: CALL_OW 104
100095: END
// every 0 0$1 trigger StreamModeActive and sFog do
100096: LD_EXP 139
100100: PUSH
100101: LD_EXP 160
100105: AND
100106: IFFALSE 100120
100108: GO 100110
100110: DISABLE
// FogOff ( your_side ) ;
100111: LD_OWVAR 2
100115: PPUSH
100116: CALL_OW 344
100120: END
// every 0 0$1 trigger StreamModeActive and sSun do
100121: LD_EXP 139
100125: PUSH
100126: LD_EXP 162
100130: AND
100131: IFFALSE 100159
100133: GO 100135
100135: DISABLE
// begin solar_recharge_percent := 0 ;
100136: LD_ADDR_OWVAR 79
100140: PUSH
100141: LD_INT 0
100143: ST_TO_ADDR
// wait ( 5 5$00 ) ;
100144: LD_INT 10500
100146: PPUSH
100147: CALL_OW 67
// solar_recharge_percent := 100 ;
100151: LD_ADDR_OWVAR 79
100155: PUSH
100156: LD_INT 100
100158: ST_TO_ADDR
// end ;
100159: END
// every 0 0$1 trigger StreamModeActive and sKamikadze do var i , un , tmp ;
100160: LD_EXP 139
100164: PUSH
100165: LD_EXP 163
100169: AND
100170: IFFALSE 100409
100172: GO 100174
100174: DISABLE
100175: LD_INT 0
100177: PPUSH
100178: PPUSH
100179: PPUSH
// begin tmp := [ ] ;
100180: LD_ADDR_VAR 0 3
100184: PUSH
100185: EMPTY
100186: ST_TO_ADDR
// for i := 1 to 6 do
100187: LD_ADDR_VAR 0 1
100191: PUSH
100192: DOUBLE
100193: LD_INT 1
100195: DEC
100196: ST_TO_ADDR
100197: LD_INT 6
100199: PUSH
100200: FOR_TO
100201: IFFALSE 100306
// begin uc_nation := nation_nature ;
100203: LD_ADDR_OWVAR 21
100207: PUSH
100208: LD_INT 0
100210: ST_TO_ADDR
// uc_side := 0 ;
100211: LD_ADDR_OWVAR 20
100215: PUSH
100216: LD_INT 0
100218: ST_TO_ADDR
// hc_attr := [ 12 , 12 ] ;
100219: LD_ADDR_OWVAR 29
100223: PUSH
100224: LD_INT 12
100226: PUSH
100227: LD_INT 12
100229: PUSH
100230: EMPTY
100231: LIST
100232: LIST
100233: ST_TO_ADDR
// hc_agressivity := 20 ;
100234: LD_ADDR_OWVAR 35
100238: PUSH
100239: LD_INT 20
100241: ST_TO_ADDR
// hc_class := class_apeman_kamikaze ;
100242: LD_ADDR_OWVAR 28
100246: PUSH
100247: LD_INT 17
100249: ST_TO_ADDR
// hc_gallery :=  ;
100250: LD_ADDR_OWVAR 33
100254: PUSH
100255: LD_STRING 
100257: ST_TO_ADDR
// hc_name :=  ;
100258: LD_ADDR_OWVAR 26
100262: PUSH
100263: LD_STRING 
100265: ST_TO_ADDR
// un := CreateHuman ;
100266: LD_ADDR_VAR 0 2
100270: PUSH
100271: CALL_OW 44
100275: ST_TO_ADDR
// PlaceUnitAnyWhere ( un , true ) ;
100276: LD_VAR 0 2
100280: PPUSH
100281: LD_INT 1
100283: PPUSH
100284: CALL_OW 51
// tmp := tmp ^ un ;
100288: LD_ADDR_VAR 0 3
100292: PUSH
100293: LD_VAR 0 3
100297: PUSH
100298: LD_VAR 0 2
100302: ADD
100303: ST_TO_ADDR
// end ;
100304: GO 100200
100306: POP
100307: POP
// repeat wait ( 0 0$1 ) ;
100308: LD_INT 35
100310: PPUSH
100311: CALL_OW 67
// for un in tmp do
100315: LD_ADDR_VAR 0 2
100319: PUSH
100320: LD_VAR 0 3
100324: PUSH
100325: FOR_IN
100326: IFFALSE 100400
// begin if IsDead ( un ) then
100328: LD_VAR 0 2
100332: PPUSH
100333: CALL_OW 301
100337: IFFALSE 100357
// begin tmp := tmp diff un ;
100339: LD_ADDR_VAR 0 3
100343: PUSH
100344: LD_VAR 0 3
100348: PUSH
100349: LD_VAR 0 2
100353: DIFF
100354: ST_TO_ADDR
// continue ;
100355: GO 100325
// end ; ComAttackUnit ( un , NearestUnitToUnit ( FilterAllUnits ( [ f_not , [ f_side , 0 ] ] ) , un ) ) ;
100357: LD_VAR 0 2
100361: PPUSH
100362: LD_INT 3
100364: PUSH
100365: LD_INT 22
100367: PUSH
100368: LD_INT 0
100370: PUSH
100371: EMPTY
100372: LIST
100373: LIST
100374: PUSH
100375: EMPTY
100376: LIST
100377: LIST
100378: PPUSH
100379: CALL_OW 69
100383: PPUSH
100384: LD_VAR 0 2
100388: PPUSH
100389: CALL_OW 74
100393: PPUSH
100394: CALL_OW 115
// end ;
100398: GO 100325
100400: POP
100401: POP
// until not tmp ;
100402: LD_VAR 0 3
100406: NOT
100407: IFFALSE 100308
// end ;
100409: PPOPN 3
100411: END
// every 0 0$1 trigger StreamModeActive and sTroll do
100412: LD_EXP 139
100416: PUSH
100417: LD_EXP 164
100421: AND
100422: IFFALSE 100476
100424: GO 100426
100426: DISABLE
// begin ToLua ( displayTroll(); ) ;
100427: LD_STRING displayTroll();
100429: PPUSH
100430: CALL_OW 559
// wait ( 3 3$00 ) ;
100434: LD_INT 6300
100436: PPUSH
100437: CALL_OW 67
// ToLua ( hideTroll(); ) ;
100441: LD_STRING hideTroll();
100443: PPUSH
100444: CALL_OW 559
// wait ( 1 1$00 ) ;
100448: LD_INT 2100
100450: PPUSH
100451: CALL_OW 67
// ToLua ( displayTroll(); ) ;
100455: LD_STRING displayTroll();
100457: PPUSH
100458: CALL_OW 559
// wait ( 1 1$00 ) ;
100462: LD_INT 2100
100464: PPUSH
100465: CALL_OW 67
// ToLua ( hideTroll(); ) ;
100469: LD_STRING hideTroll();
100471: PPUSH
100472: CALL_OW 559
// end ;
100476: END
// every 0 0$1 trigger StreamModeActive and sSlow do var p ;
100477: LD_EXP 139
100481: PUSH
100482: LD_EXP 165
100486: AND
100487: IFFALSE 100550
100489: GO 100491
100491: DISABLE
100492: LD_INT 0
100494: PPUSH
// begin p := 0 ;
100495: LD_ADDR_VAR 0 1
100499: PUSH
100500: LD_INT 0
100502: ST_TO_ADDR
// repeat game_speed := 1 ;
100503: LD_ADDR_OWVAR 65
100507: PUSH
100508: LD_INT 1
100510: ST_TO_ADDR
// wait ( 0 0$1 ) ;
100511: LD_INT 35
100513: PPUSH
100514: CALL_OW 67
// p := p + 1 ;
100518: LD_ADDR_VAR 0 1
100522: PUSH
100523: LD_VAR 0 1
100527: PUSH
100528: LD_INT 1
100530: PLUS
100531: ST_TO_ADDR
// until p >= 60 ;
100532: LD_VAR 0 1
100536: PUSH
100537: LD_INT 60
100539: GREATEREQUAL
100540: IFFALSE 100503
// game_speed := 4 ;
100542: LD_ADDR_OWVAR 65
100546: PUSH
100547: LD_INT 4
100549: ST_TO_ADDR
// end ;
100550: PPOPN 1
100552: END
// every 0 0$1 trigger StreamModeActive and sLack do var depot , base ;
100553: LD_EXP 139
100557: PUSH
100558: LD_EXP 166
100562: AND
100563: IFFALSE 100709
100565: GO 100567
100567: DISABLE
100568: LD_INT 0
100570: PPUSH
100571: PPUSH
// begin depot := FilterAllUnits ( [ [ f_side , your_side ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ] ) ;
100572: LD_ADDR_VAR 0 1
100576: PUSH
100577: LD_INT 22
100579: PUSH
100580: LD_OWVAR 2
100584: PUSH
100585: EMPTY
100586: LIST
100587: LIST
100588: PUSH
100589: LD_INT 2
100591: PUSH
100592: LD_INT 30
100594: PUSH
100595: LD_INT 0
100597: PUSH
100598: EMPTY
100599: LIST
100600: LIST
100601: PUSH
100602: LD_INT 30
100604: PUSH
100605: LD_INT 1
100607: PUSH
100608: EMPTY
100609: LIST
100610: LIST
100611: PUSH
100612: EMPTY
100613: LIST
100614: LIST
100615: LIST
100616: PUSH
100617: EMPTY
100618: LIST
100619: LIST
100620: PPUSH
100621: CALL_OW 69
100625: ST_TO_ADDR
// if not depot then
100626: LD_VAR 0 1
100630: NOT
100631: IFFALSE 100635
// exit ;
100633: GO 100709
// base := GetBase ( depot [ rand ( 1 , depot ) ] ) ;
100635: LD_ADDR_VAR 0 2
100639: PUSH
100640: LD_VAR 0 1
100644: PUSH
100645: LD_INT 1
100647: PPUSH
100648: LD_VAR 0 1
100652: PPUSH
100653: CALL_OW 12
100657: ARRAY
100658: PPUSH
100659: CALL_OW 274
100663: ST_TO_ADDR
// SetResourceType ( base , mat_cans , 0 ) ;
100664: LD_VAR 0 2
100668: PPUSH
100669: LD_INT 1
100671: PPUSH
100672: LD_INT 0
100674: PPUSH
100675: CALL_OW 277
// SetResourceType ( base , mat_oil , 0 ) ;
100679: LD_VAR 0 2
100683: PPUSH
100684: LD_INT 2
100686: PPUSH
100687: LD_INT 0
100689: PPUSH
100690: CALL_OW 277
// SetResourceType ( base , mat_siberit , 0 ) ;
100694: LD_VAR 0 2
100698: PPUSH
100699: LD_INT 3
100701: PPUSH
100702: LD_INT 0
100704: PPUSH
100705: CALL_OW 277
// end ;
100709: PPOPN 2
100711: END
// every 0 0$1 trigger StreamModeActive and sWound do var tmp ;
100712: LD_EXP 139
100716: PUSH
100717: LD_EXP 167
100721: AND
100722: IFFALSE 100819
100724: GO 100726
100726: DISABLE
100727: LD_INT 0
100729: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_type , unit_human ] , [ f_not , [ f_nation , 0 ] ] ] ) ;
100730: LD_ADDR_VAR 0 1
100734: PUSH
100735: LD_INT 22
100737: PUSH
100738: LD_OWVAR 2
100742: PUSH
100743: EMPTY
100744: LIST
100745: LIST
100746: PUSH
100747: LD_INT 21
100749: PUSH
100750: LD_INT 1
100752: PUSH
100753: EMPTY
100754: LIST
100755: LIST
100756: PUSH
100757: LD_INT 3
100759: PUSH
100760: LD_INT 23
100762: PUSH
100763: LD_INT 0
100765: PUSH
100766: EMPTY
100767: LIST
100768: LIST
100769: PUSH
100770: EMPTY
100771: LIST
100772: LIST
100773: PUSH
100774: EMPTY
100775: LIST
100776: LIST
100777: LIST
100778: PPUSH
100779: CALL_OW 69
100783: ST_TO_ADDR
// if not tmp then
100784: LD_VAR 0 1
100788: NOT
100789: IFFALSE 100793
// exit ;
100791: GO 100819
// SetLives ( tmp [ rand ( 1 , tmp ) ] , 200 ) ;
100793: LD_VAR 0 1
100797: PUSH
100798: LD_INT 1
100800: PPUSH
100801: LD_VAR 0 1
100805: PPUSH
100806: CALL_OW 12
100810: ARRAY
100811: PPUSH
100812: LD_INT 200
100814: PPUSH
100815: CALL_OW 234
// end ;
100819: PPOPN 1
100821: END
// every 0 0$1 trigger StreamModeActive and sTank do var tmp ;
100822: LD_EXP 139
100826: PUSH
100827: LD_EXP 168
100831: AND
100832: IFFALSE 100911
100834: GO 100836
100836: DISABLE
100837: LD_INT 0
100839: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_type , unit_vehicle ] ] ) ;
100840: LD_ADDR_VAR 0 1
100844: PUSH
100845: LD_INT 22
100847: PUSH
100848: LD_OWVAR 2
100852: PUSH
100853: EMPTY
100854: LIST
100855: LIST
100856: PUSH
100857: LD_INT 21
100859: PUSH
100860: LD_INT 2
100862: PUSH
100863: EMPTY
100864: LIST
100865: LIST
100866: PUSH
100867: EMPTY
100868: LIST
100869: LIST
100870: PPUSH
100871: CALL_OW 69
100875: ST_TO_ADDR
// if not tmp then
100876: LD_VAR 0 1
100880: NOT
100881: IFFALSE 100885
// exit ;
100883: GO 100911
// SetLives ( tmp [ rand ( 1 , tmp ) ] , 60 ) ;
100885: LD_VAR 0 1
100889: PUSH
100890: LD_INT 1
100892: PPUSH
100893: LD_VAR 0 1
100897: PPUSH
100898: CALL_OW 12
100902: ARRAY
100903: PPUSH
100904: LD_INT 60
100906: PPUSH
100907: CALL_OW 234
// end ;
100911: PPOPN 1
100913: END
// every 0 0$1 trigger StreamModeActive and sRemote do var tmp , i ;
100914: LD_EXP 139
100918: PUSH
100919: LD_EXP 169
100923: AND
100924: IFFALSE 101023
100926: GO 100928
100928: DISABLE
100929: LD_INT 0
100931: PPUSH
100932: PPUSH
// begin enable ;
100933: ENABLE
// tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_linked ] , [ f_control , control_remote ] ] ) ;
100934: LD_ADDR_VAR 0 1
100938: PUSH
100939: LD_INT 22
100941: PUSH
100942: LD_OWVAR 2
100946: PUSH
100947: EMPTY
100948: LIST
100949: LIST
100950: PUSH
100951: LD_INT 61
100953: PUSH
100954: EMPTY
100955: LIST
100956: PUSH
100957: LD_INT 33
100959: PUSH
100960: LD_INT 2
100962: PUSH
100963: EMPTY
100964: LIST
100965: LIST
100966: PUSH
100967: EMPTY
100968: LIST
100969: LIST
100970: LIST
100971: PPUSH
100972: CALL_OW 69
100976: ST_TO_ADDR
// if not tmp then
100977: LD_VAR 0 1
100981: NOT
100982: IFFALSE 100986
// exit ;
100984: GO 101023
// for i in tmp do
100986: LD_ADDR_VAR 0 2
100990: PUSH
100991: LD_VAR 0 1
100995: PUSH
100996: FOR_IN
100997: IFFALSE 101021
// if IsControledBy ( i ) then
100999: LD_VAR 0 2
101003: PPUSH
101004: CALL_OW 312
101008: IFFALSE 101019
// ComUnlink ( i ) ;
101010: LD_VAR 0 2
101014: PPUSH
101015: CALL_OW 136
101019: GO 100996
101021: POP
101022: POP
// end ;
101023: PPOPN 2
101025: END
// every 0 0$1 trigger StreamModeActive and sPowell do var i , un ;
101026: LD_EXP 139
101030: PUSH
101031: LD_EXP 170
101035: AND
101036: IFFALSE 101176
101038: GO 101040
101040: DISABLE
101041: LD_INT 0
101043: PPUSH
101044: PPUSH
// begin ToLua ( displayPowell(); ) ;
101045: LD_STRING displayPowell();
101047: PPUSH
101048: CALL_OW 559
// uc_side := 0 ;
101052: LD_ADDR_OWVAR 20
101056: PUSH
101057: LD_INT 0
101059: ST_TO_ADDR
// uc_nation := 2 ;
101060: LD_ADDR_OWVAR 21
101064: PUSH
101065: LD_INT 2
101067: ST_TO_ADDR
// vc_chassis := ar_half_tracked ;
101068: LD_ADDR_OWVAR 37
101072: PUSH
101073: LD_INT 14
101075: ST_TO_ADDR
// vc_engine := engine_siberite ;
101076: LD_ADDR_OWVAR 39
101080: PUSH
101081: LD_INT 3
101083: ST_TO_ADDR
// vc_control := control_apeman ;
101084: LD_ADDR_OWVAR 38
101088: PUSH
101089: LD_INT 5
101091: ST_TO_ADDR
// vc_weapon := ar_selfpropelled_bomb ;
101092: LD_ADDR_OWVAR 40
101096: PUSH
101097: LD_INT 29
101099: ST_TO_ADDR
// un := CreateVehicle ;
101100: LD_ADDR_VAR 0 2
101104: PUSH
101105: CALL_OW 45
101109: ST_TO_ADDR
// PlaceUnitAnywhere ( un , true ) ;
101110: LD_VAR 0 2
101114: PPUSH
101115: LD_INT 1
101117: PPUSH
101118: CALL_OW 51
// repeat wait ( 0 0$1 ) ;
101122: LD_INT 35
101124: PPUSH
101125: CALL_OW 67
// ComAttackUnit ( un , NearestUnitToUnit ( FilterAllUnits ( [ f_side , your_side ] ) , un ) ) ;
101129: LD_VAR 0 2
101133: PPUSH
101134: LD_INT 22
101136: PUSH
101137: LD_OWVAR 2
101141: PUSH
101142: EMPTY
101143: LIST
101144: LIST
101145: PPUSH
101146: CALL_OW 69
101150: PPUSH
101151: LD_VAR 0 2
101155: PPUSH
101156: CALL_OW 74
101160: PPUSH
101161: CALL_OW 115
// until IsDead ( un ) ;
101165: LD_VAR 0 2
101169: PPUSH
101170: CALL_OW 301
101174: IFFALSE 101122
// end ;
101176: PPOPN 2
101178: END
// every 0 0$1 trigger StreamModeActive and sStu do
101179: LD_EXP 139
101183: PUSH
101184: LD_EXP 178
101188: AND
101189: IFFALSE 101205
101191: GO 101193
101193: DISABLE
// begin ToLua ( displayStucuk(); ) ;
101194: LD_STRING displayStucuk();
101196: PPUSH
101197: CALL_OW 559
// ResetFog ;
101201: CALL_OW 335
// end ;
101205: END
// every 0 0$1 trigger StreamModeActive and sBetray do var un , tmp ;
101206: LD_EXP 139
101210: PUSH
101211: LD_EXP 171
101215: AND
101216: IFFALSE 101357
101218: GO 101220
101220: DISABLE
101221: LD_INT 0
101223: PPUSH
101224: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_type , unit_human ] ] ) ;
101225: LD_ADDR_VAR 0 2
101229: PUSH
101230: LD_INT 22
101232: PUSH
101233: LD_OWVAR 2
101237: PUSH
101238: EMPTY
101239: LIST
101240: LIST
101241: PUSH
101242: LD_INT 21
101244: PUSH
101245: LD_INT 1
101247: PUSH
101248: EMPTY
101249: LIST
101250: LIST
101251: PUSH
101252: EMPTY
101253: LIST
101254: LIST
101255: PPUSH
101256: CALL_OW 69
101260: ST_TO_ADDR
// if not tmp then
101261: LD_VAR 0 2
101265: NOT
101266: IFFALSE 101270
// exit ;
101268: GO 101357
// un := tmp [ rand ( 1 , tmp ) ] ;
101270: LD_ADDR_VAR 0 1
101274: PUSH
101275: LD_VAR 0 2
101279: PUSH
101280: LD_INT 1
101282: PPUSH
101283: LD_VAR 0 2
101287: PPUSH
101288: CALL_OW 12
101292: ARRAY
101293: ST_TO_ADDR
// SetSide ( un , 0 ) ;
101294: LD_VAR 0 1
101298: PPUSH
101299: LD_INT 0
101301: PPUSH
101302: CALL_OW 235
// ComAttackUnit ( un , NearestUnitToUnit ( all_units diff un , un ) ) ;
101306: LD_VAR 0 1
101310: PPUSH
101311: LD_OWVAR 3
101315: PUSH
101316: LD_VAR 0 1
101320: DIFF
101321: PPUSH
101322: LD_VAR 0 1
101326: PPUSH
101327: CALL_OW 74
101331: PPUSH
101332: CALL_OW 115
// wait ( 0 0$20 ) ;
101336: LD_INT 700
101338: PPUSH
101339: CALL_OW 67
// SetSide ( un , your_side ) ;
101343: LD_VAR 0 1
101347: PPUSH
101348: LD_OWVAR 2
101352: PPUSH
101353: CALL_OW 235
// end ;
101357: PPOPN 2
101359: END
// every 0 0$1 trigger StreamModeActive and sContamin do var depot ;
101360: LD_EXP 139
101364: PUSH
101365: LD_EXP 172
101369: AND
101370: IFFALSE 101476
101372: GO 101374
101374: DISABLE
101375: LD_INT 0
101377: PPUSH
// begin depot := FilterAllUnits ( [ [ f_side , your_side ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ] ) ;
101378: LD_ADDR_VAR 0 1
101382: PUSH
101383: LD_INT 22
101385: PUSH
101386: LD_OWVAR 2
101390: PUSH
101391: EMPTY
101392: LIST
101393: LIST
101394: PUSH
101395: LD_INT 2
101397: PUSH
101398: LD_INT 30
101400: PUSH
101401: LD_INT 0
101403: PUSH
101404: EMPTY
101405: LIST
101406: LIST
101407: PUSH
101408: LD_INT 30
101410: PUSH
101411: LD_INT 1
101413: PUSH
101414: EMPTY
101415: LIST
101416: LIST
101417: PUSH
101418: EMPTY
101419: LIST
101420: LIST
101421: LIST
101422: PUSH
101423: EMPTY
101424: LIST
101425: LIST
101426: PPUSH
101427: CALL_OW 69
101431: ST_TO_ADDR
// if not depot then
101432: LD_VAR 0 1
101436: NOT
101437: IFFALSE 101441
// exit ;
101439: GO 101476
// ArtContamination ( GetX ( depot [ 1 ] ) , GetY ( depot [ 1 ] ) , 70 ) ;
101441: LD_VAR 0 1
101445: PUSH
101446: LD_INT 1
101448: ARRAY
101449: PPUSH
101450: CALL_OW 250
101454: PPUSH
101455: LD_VAR 0 1
101459: PUSH
101460: LD_INT 1
101462: ARRAY
101463: PPUSH
101464: CALL_OW 251
101468: PPUSH
101469: LD_INT 70
101471: PPUSH
101472: CALL_OW 495
// end ;
101476: PPOPN 1
101478: END
// every 0 0$1 trigger StreamModeActive and sTeleport do var i , x , y , d , tmp ;
101479: LD_EXP 139
101483: PUSH
101484: LD_EXP 173
101488: AND
101489: IFFALSE 101700
101491: GO 101493
101493: DISABLE
101494: LD_INT 0
101496: PPUSH
101497: PPUSH
101498: PPUSH
101499: PPUSH
101500: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_type , unit_human ] ] ) ;
101501: LD_ADDR_VAR 0 5
101505: PUSH
101506: LD_INT 22
101508: PUSH
101509: LD_OWVAR 2
101513: PUSH
101514: EMPTY
101515: LIST
101516: LIST
101517: PUSH
101518: LD_INT 21
101520: PUSH
101521: LD_INT 1
101523: PUSH
101524: EMPTY
101525: LIST
101526: LIST
101527: PUSH
101528: EMPTY
101529: LIST
101530: LIST
101531: PPUSH
101532: CALL_OW 69
101536: ST_TO_ADDR
// if not tmp then
101537: LD_VAR 0 5
101541: NOT
101542: IFFALSE 101546
// exit ;
101544: GO 101700
// for i in tmp do
101546: LD_ADDR_VAR 0 1
101550: PUSH
101551: LD_VAR 0 5
101555: PUSH
101556: FOR_IN
101557: IFFALSE 101698
// begin d := rand ( 0 , 5 ) ;
101559: LD_ADDR_VAR 0 4
101563: PUSH
101564: LD_INT 0
101566: PPUSH
101567: LD_INT 5
101569: PPUSH
101570: CALL_OW 12
101574: ST_TO_ADDR
// x := ShiftX ( GetX ( i ) , d , rand ( 3 , 12 ) ) ;
101575: LD_ADDR_VAR 0 2
101579: PUSH
101580: LD_VAR 0 1
101584: PPUSH
101585: CALL_OW 250
101589: PPUSH
101590: LD_VAR 0 4
101594: PPUSH
101595: LD_INT 3
101597: PPUSH
101598: LD_INT 12
101600: PPUSH
101601: CALL_OW 12
101605: PPUSH
101606: CALL_OW 272
101610: ST_TO_ADDR
// y := ShiftY ( GetY ( i ) , d , rand ( 3 , 12 ) ) ;
101611: LD_ADDR_VAR 0 3
101615: PUSH
101616: LD_VAR 0 1
101620: PPUSH
101621: CALL_OW 251
101625: PPUSH
101626: LD_VAR 0 4
101630: PPUSH
101631: LD_INT 3
101633: PPUSH
101634: LD_INT 12
101636: PPUSH
101637: CALL_OW 12
101641: PPUSH
101642: CALL_OW 273
101646: ST_TO_ADDR
// if ValidHex ( x , y ) then
101647: LD_VAR 0 2
101651: PPUSH
101652: LD_VAR 0 3
101656: PPUSH
101657: CALL_OW 488
101661: IFFALSE 101696
// TeleportUnit ( i , x , y , rand ( 3 , 6 ) , true ) ;
101663: LD_VAR 0 1
101667: PPUSH
101668: LD_VAR 0 2
101672: PPUSH
101673: LD_VAR 0 3
101677: PPUSH
101678: LD_INT 3
101680: PPUSH
101681: LD_INT 6
101683: PPUSH
101684: CALL_OW 12
101688: PPUSH
101689: LD_INT 1
101691: PPUSH
101692: CALL_OW 483
// end ;
101696: GO 101556
101698: POP
101699: POP
// end ;
101700: PPOPN 5
101702: END
// every 0 0$1 trigger StreamModeActive and sOil do var i , tmp ;
101703: LD_EXP 139
101707: PUSH
101708: LD_EXP 174
101712: AND
101713: IFFALSE 101807
101715: GO 101717
101717: DISABLE
101718: LD_INT 0
101720: PPUSH
101721: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_engine , engine_combustion ] , [ f_type , unit_vehicle ] ] ) ;
101722: LD_ADDR_VAR 0 2
101726: PUSH
101727: LD_INT 22
101729: PUSH
101730: LD_OWVAR 2
101734: PUSH
101735: EMPTY
101736: LIST
101737: LIST
101738: PUSH
101739: LD_INT 32
101741: PUSH
101742: LD_INT 1
101744: PUSH
101745: EMPTY
101746: LIST
101747: LIST
101748: PUSH
101749: LD_INT 21
101751: PUSH
101752: LD_INT 2
101754: PUSH
101755: EMPTY
101756: LIST
101757: LIST
101758: PUSH
101759: EMPTY
101760: LIST
101761: LIST
101762: LIST
101763: PPUSH
101764: CALL_OW 69
101768: ST_TO_ADDR
// if not tmp then
101769: LD_VAR 0 2
101773: NOT
101774: IFFALSE 101778
// exit ;
101776: GO 101807
// for i in tmp do
101778: LD_ADDR_VAR 0 1
101782: PUSH
101783: LD_VAR 0 2
101787: PUSH
101788: FOR_IN
101789: IFFALSE 101805
// SetFuel ( i , 0 ) ;
101791: LD_VAR 0 1
101795: PPUSH
101796: LD_INT 0
101798: PPUSH
101799: CALL_OW 240
101803: GO 101788
101805: POP
101806: POP
// end ;
101807: PPOPN 2
101809: END
// every 0 0$1 trigger StreamModeActive and sOilTower do var tmp ;
101810: LD_EXP 139
101814: PUSH
101815: LD_EXP 175
101819: AND
101820: IFFALSE 101886
101822: GO 101824
101824: DISABLE
101825: LD_INT 0
101827: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_btype , b_oil_mine ] ] ) ;
101828: LD_ADDR_VAR 0 1
101832: PUSH
101833: LD_INT 22
101835: PUSH
101836: LD_OWVAR 2
101840: PUSH
101841: EMPTY
101842: LIST
101843: LIST
101844: PUSH
101845: LD_INT 30
101847: PUSH
101848: LD_INT 29
101850: PUSH
101851: EMPTY
101852: LIST
101853: LIST
101854: PUSH
101855: EMPTY
101856: LIST
101857: LIST
101858: PPUSH
101859: CALL_OW 69
101863: ST_TO_ADDR
// if not tmp then
101864: LD_VAR 0 1
101868: NOT
101869: IFFALSE 101873
// exit ;
101871: GO 101886
// DestroyUnit ( tmp [ 1 ] ) ;
101873: LD_VAR 0 1
101877: PUSH
101878: LD_INT 1
101880: ARRAY
101881: PPUSH
101882: CALL_OW 65
// end ;
101886: PPOPN 1
101888: END
// every 0 0$1 trigger StreamModeActive and sSheik do var un ;
101889: LD_EXP 139
101893: PUSH
101894: LD_EXP 177
101898: AND
101899: IFFALSE 102028
101901: GO 101903
101903: DISABLE
101904: LD_INT 0
101906: PPUSH
// begin uc_side := 0 ;
101907: LD_ADDR_OWVAR 20
101911: PUSH
101912: LD_INT 0
101914: ST_TO_ADDR
// uc_nation := nation_arabian ;
101915: LD_ADDR_OWVAR 21
101919: PUSH
101920: LD_INT 2
101922: ST_TO_ADDR
// hc_gallery :=  ;
101923: LD_ADDR_OWVAR 33
101927: PUSH
101928: LD_STRING 
101930: ST_TO_ADDR
// hc_name :=  ;
101931: LD_ADDR_OWVAR 26
101935: PUSH
101936: LD_STRING 
101938: ST_TO_ADDR
// PrepareHuman ( sex_male , class_desert_warior , 10 ) ;
101939: LD_INT 1
101941: PPUSH
101942: LD_INT 11
101944: PPUSH
101945: LD_INT 10
101947: PPUSH
101948: CALL_OW 380
// un := CreateHuman ;
101952: LD_ADDR_VAR 0 1
101956: PUSH
101957: CALL_OW 44
101961: ST_TO_ADDR
// PlaceUnitAnywhere ( un , true ) ;
101962: LD_VAR 0 1
101966: PPUSH
101967: LD_INT 1
101969: PPUSH
101970: CALL_OW 51
// repeat wait ( 0 0$1 ) ;
101974: LD_INT 35
101976: PPUSH
101977: CALL_OW 67
// ComAttackUnit ( un , NearestUnitToUnit ( FilterAllUnits ( [ f_side , your_side ] ) , un ) ) ;
101981: LD_VAR 0 1
101985: PPUSH
101986: LD_INT 22
101988: PUSH
101989: LD_OWVAR 2
101993: PUSH
101994: EMPTY
101995: LIST
101996: LIST
101997: PPUSH
101998: CALL_OW 69
102002: PPUSH
102003: LD_VAR 0 1
102007: PPUSH
102008: CALL_OW 74
102012: PPUSH
102013: CALL_OW 115
// until IsDead ( un ) ;
102017: LD_VAR 0 1
102021: PPUSH
102022: CALL_OW 301
102026: IFFALSE 101974
// end ;
102028: PPOPN 1
102030: END
// every 0 0$1 trigger StreamModeActive and sEarthquake do
102031: LD_EXP 139
102035: PUSH
102036: LD_EXP 179
102040: AND
102041: IFFALSE 102053
102043: GO 102045
102045: DISABLE
// ToLua ( earthquake(getX(game), 0, 32) ) ;
102046: LD_STRING earthquake(getX(game), 0, 32)
102048: PPUSH
102049: CALL_OW 559
102053: END
// every 0 0$1 trigger StreamModeActive and sAI do var tmp ;
102054: LD_EXP 139
102058: PUSH
102059: LD_EXP 180
102063: AND
102064: IFFALSE 102155
102066: GO 102068
102068: DISABLE
102069: LD_INT 0
102071: PPUSH
// begin enable ;
102072: ENABLE
// tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_type , unit_vehicle ] , [ f_control , control_computer ] ] ) ;
102073: LD_ADDR_VAR 0 1
102077: PUSH
102078: LD_INT 22
102080: PUSH
102081: LD_OWVAR 2
102085: PUSH
102086: EMPTY
102087: LIST
102088: LIST
102089: PUSH
102090: LD_INT 21
102092: PUSH
102093: LD_INT 2
102095: PUSH
102096: EMPTY
102097: LIST
102098: LIST
102099: PUSH
102100: LD_INT 33
102102: PUSH
102103: LD_INT 3
102105: PUSH
102106: EMPTY
102107: LIST
102108: LIST
102109: PUSH
102110: EMPTY
102111: LIST
102112: LIST
102113: LIST
102114: PPUSH
102115: CALL_OW 69
102119: ST_TO_ADDR
// if not tmp then
102120: LD_VAR 0 1
102124: NOT
102125: IFFALSE 102129
// exit ;
102127: GO 102155
// SetLives ( tmp [ rand ( 1 , tmp ) ] , 1 ) ;
102129: LD_VAR 0 1
102133: PUSH
102134: LD_INT 1
102136: PPUSH
102137: LD_VAR 0 1
102141: PPUSH
102142: CALL_OW 12
102146: ARRAY
102147: PPUSH
102148: LD_INT 1
102150: PPUSH
102151: CALL_OW 234
// end ;
102155: PPOPN 1
102157: END
// every 0 0$1 trigger StreamModeActive and sBazooka do var i , un , tmp ;
102158: LD_EXP 139
102162: PUSH
102163: LD_EXP 181
102167: AND
102168: IFFALSE 102309
102170: GO 102172
102172: DISABLE
102173: LD_INT 0
102175: PPUSH
102176: PPUSH
102177: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_class , 1 ] ] ) ;
102178: LD_ADDR_VAR 0 3
102182: PUSH
102183: LD_INT 22
102185: PUSH
102186: LD_OWVAR 2
102190: PUSH
102191: EMPTY
102192: LIST
102193: LIST
102194: PUSH
102195: LD_INT 25
102197: PUSH
102198: LD_INT 1
102200: PUSH
102201: EMPTY
102202: LIST
102203: LIST
102204: PUSH
102205: EMPTY
102206: LIST
102207: LIST
102208: PPUSH
102209: CALL_OW 69
102213: ST_TO_ADDR
// if not tmp then
102214: LD_VAR 0 3
102218: NOT
102219: IFFALSE 102223
// exit ;
102221: GO 102309
// un := tmp [ rand ( 1 , tmp ) ] ;
102223: LD_ADDR_VAR 0 2
102227: PUSH
102228: LD_VAR 0 3
102232: PUSH
102233: LD_INT 1
102235: PPUSH
102236: LD_VAR 0 3
102240: PPUSH
102241: CALL_OW 12
102245: ARRAY
102246: ST_TO_ADDR
// if Crawls ( un ) then
102247: LD_VAR 0 2
102251: PPUSH
102252: CALL_OW 318
102256: IFFALSE 102267
// ComWalk ( un ) ;
102258: LD_VAR 0 2
102262: PPUSH
102263: CALL_OW 138
// SetClass ( un , class_bazooker ) ;
102267: LD_VAR 0 2
102271: PPUSH
102272: LD_INT 9
102274: PPUSH
102275: CALL_OW 336
// SetTech ( tech_tauRad , your_side , state_researched ) ;
102279: LD_INT 28
102281: PPUSH
102282: LD_OWVAR 2
102286: PPUSH
102287: LD_INT 2
102289: PPUSH
102290: CALL_OW 322
// SetTech ( tech_spacAnom , your_side , state_researched ) ;
102294: LD_INT 29
102296: PPUSH
102297: LD_OWVAR 2
102301: PPUSH
102302: LD_INT 2
102304: PPUSH
102305: CALL_OW 322
// end ;
102309: PPOPN 3
102311: END
// every 0 0$1 trigger StreamModeActive and sMortar do var i , un , tmp ;
102312: LD_EXP 139
102316: PUSH
102317: LD_EXP 182
102321: AND
102322: IFFALSE 102433
102324: GO 102326
102326: DISABLE
102327: LD_INT 0
102329: PPUSH
102330: PPUSH
102331: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_class , 1 ] ] ) ;
102332: LD_ADDR_VAR 0 3
102336: PUSH
102337: LD_INT 22
102339: PUSH
102340: LD_OWVAR 2
102344: PUSH
102345: EMPTY
102346: LIST
102347: LIST
102348: PUSH
102349: LD_INT 25
102351: PUSH
102352: LD_INT 1
102354: PUSH
102355: EMPTY
102356: LIST
102357: LIST
102358: PUSH
102359: EMPTY
102360: LIST
102361: LIST
102362: PPUSH
102363: CALL_OW 69
102367: ST_TO_ADDR
// if not tmp then
102368: LD_VAR 0 3
102372: NOT
102373: IFFALSE 102377
// exit ;
102375: GO 102433
// un := tmp [ rand ( 1 , tmp ) ] ;
102377: LD_ADDR_VAR 0 2
102381: PUSH
102382: LD_VAR 0 3
102386: PUSH
102387: LD_INT 1
102389: PPUSH
102390: LD_VAR 0 3
102394: PPUSH
102395: CALL_OW 12
102399: ARRAY
102400: ST_TO_ADDR
// if Crawls ( un ) then
102401: LD_VAR 0 2
102405: PPUSH
102406: CALL_OW 318
102410: IFFALSE 102421
// ComWalk ( un ) ;
102412: LD_VAR 0 2
102416: PPUSH
102417: CALL_OW 138
// SetClass ( un , class_mortar ) ;
102421: LD_VAR 0 2
102425: PPUSH
102426: LD_INT 8
102428: PPUSH
102429: CALL_OW 336
// end ;
102433: PPOPN 3
102435: END
// every 0 0$1 trigger StreamModeActive and sCargo do var i , tmp ;
102436: LD_EXP 139
102440: PUSH
102441: LD_EXP 183
102445: AND
102446: IFFALSE 102590
102448: GO 102450
102450: DISABLE
102451: LD_INT 0
102453: PPUSH
102454: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_type , unit_vehicle ] , [ f_or , [ f_weapon , us_cargo_bay ] , [ f_weapon , ru_cargo_bay ] , [ f_weapon , ar_cargo_bay ] ] ] ) ;
102455: LD_ADDR_VAR 0 2
102459: PUSH
102460: LD_INT 22
102462: PUSH
102463: LD_OWVAR 2
102467: PUSH
102468: EMPTY
102469: LIST
102470: LIST
102471: PUSH
102472: LD_INT 21
102474: PUSH
102475: LD_INT 2
102477: PUSH
102478: EMPTY
102479: LIST
102480: LIST
102481: PUSH
102482: LD_INT 2
102484: PUSH
102485: LD_INT 34
102487: PUSH
102488: LD_INT 12
102490: PUSH
102491: EMPTY
102492: LIST
102493: LIST
102494: PUSH
102495: LD_INT 34
102497: PUSH
102498: LD_INT 51
102500: PUSH
102501: EMPTY
102502: LIST
102503: LIST
102504: PUSH
102505: LD_INT 34
102507: PUSH
102508: LD_INT 32
102510: PUSH
102511: EMPTY
102512: LIST
102513: LIST
102514: PUSH
102515: EMPTY
102516: LIST
102517: LIST
102518: LIST
102519: LIST
102520: PUSH
102521: EMPTY
102522: LIST
102523: LIST
102524: LIST
102525: PPUSH
102526: CALL_OW 69
102530: ST_TO_ADDR
// if not tmp then
102531: LD_VAR 0 2
102535: NOT
102536: IFFALSE 102540
// exit ;
102538: GO 102590
// for i in tmp do
102540: LD_ADDR_VAR 0 1
102544: PUSH
102545: LD_VAR 0 2
102549: PUSH
102550: FOR_IN
102551: IFFALSE 102588
// if GetCargo ( i , mat_artifact ) = 0 then
102553: LD_VAR 0 1
102557: PPUSH
102558: LD_INT 4
102560: PPUSH
102561: CALL_OW 289
102565: PUSH
102566: LD_INT 0
102568: EQUAL
102569: IFFALSE 102586
// SetCargo ( i , mat_siberit , 100 ) ;
102571: LD_VAR 0 1
102575: PPUSH
102576: LD_INT 3
102578: PPUSH
102579: LD_INT 100
102581: PPUSH
102582: CALL_OW 290
102586: GO 102550
102588: POP
102589: POP
// end ;
102590: PPOPN 2
102592: END
// every 0 0$1 trigger StreamModeActive and sDLaser do var i , tmp ;
102593: LD_EXP 139
102597: PUSH
102598: LD_EXP 184
102602: AND
102603: IFFALSE 102786
102605: GO 102607
102607: DISABLE
102608: LD_INT 0
102610: PPUSH
102611: PPUSH
// begin tmp := FilterAllUnits ( [ f_side , your_side ] ) ;
102612: LD_ADDR_VAR 0 2
102616: PUSH
102617: LD_INT 22
102619: PUSH
102620: LD_OWVAR 2
102624: PUSH
102625: EMPTY
102626: LIST
102627: LIST
102628: PPUSH
102629: CALL_OW 69
102633: ST_TO_ADDR
// if not tmp then
102634: LD_VAR 0 2
102638: NOT
102639: IFFALSE 102643
// exit ;
102641: GO 102786
// for i := 1 to 2 do
102643: LD_ADDR_VAR 0 1
102647: PUSH
102648: DOUBLE
102649: LD_INT 1
102651: DEC
102652: ST_TO_ADDR
102653: LD_INT 2
102655: PUSH
102656: FOR_TO
102657: IFFALSE 102784
// begin uc_side := your_side ;
102659: LD_ADDR_OWVAR 20
102663: PUSH
102664: LD_OWVAR 2
102668: ST_TO_ADDR
// uc_nation := nation_american ;
102669: LD_ADDR_OWVAR 21
102673: PUSH
102674: LD_INT 1
102676: ST_TO_ADDR
// vc_chassis := us_morphling ;
102677: LD_ADDR_OWVAR 37
102681: PUSH
102682: LD_INT 5
102684: ST_TO_ADDR
// vc_engine := engine_siberite ;
102685: LD_ADDR_OWVAR 39
102689: PUSH
102690: LD_INT 3
102692: ST_TO_ADDR
// vc_control := control_computer ;
102693: LD_ADDR_OWVAR 38
102697: PUSH
102698: LD_INT 3
102700: ST_TO_ADDR
// vc_weapon := us_double_laser ;
102701: LD_ADDR_OWVAR 40
102705: PUSH
102706: LD_INT 10
102708: ST_TO_ADDR
// if not IsInUnit ( tmp [ 1 ] ) then
102709: LD_VAR 0 2
102713: PUSH
102714: LD_INT 1
102716: ARRAY
102717: PPUSH
102718: CALL_OW 310
102722: NOT
102723: IFFALSE 102770
// PlaceUnitXYR ( CreateVehicle , GetX ( tmp [ 1 ] ) , GetY ( tmp [ 1 ] ) , 12 , true ) else
102725: CALL_OW 45
102729: PPUSH
102730: LD_VAR 0 2
102734: PUSH
102735: LD_INT 1
102737: ARRAY
102738: PPUSH
102739: CALL_OW 250
102743: PPUSH
102744: LD_VAR 0 2
102748: PUSH
102749: LD_INT 1
102751: ARRAY
102752: PPUSH
102753: CALL_OW 251
102757: PPUSH
102758: LD_INT 12
102760: PPUSH
102761: LD_INT 1
102763: PPUSH
102764: CALL_OW 50
102768: GO 102782
// PlaceUnitAnywhere ( CreateVehicle , true ) ;
102770: CALL_OW 45
102774: PPUSH
102775: LD_INT 1
102777: PPUSH
102778: CALL_OW 51
// end ;
102782: GO 102656
102784: POP
102785: POP
// end ;
102786: PPOPN 2
102788: END
// every 0 0$1 trigger StreamModeActive and sExchange do var i , s1 , s2 , sk1 , sk2 , tmp ;
102789: LD_EXP 139
102793: PUSH
102794: LD_EXP 185
102798: AND
102799: IFFALSE 103021
102801: GO 102803
102803: DISABLE
102804: LD_INT 0
102806: PPUSH
102807: PPUSH
102808: PPUSH
102809: PPUSH
102810: PPUSH
102811: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_type , unit_human ] , [ f_not , [ f_nation , 0 ] ] ] ) ;
102812: LD_ADDR_VAR 0 6
102816: PUSH
102817: LD_INT 22
102819: PUSH
102820: LD_OWVAR 2
102824: PUSH
102825: EMPTY
102826: LIST
102827: LIST
102828: PUSH
102829: LD_INT 21
102831: PUSH
102832: LD_INT 1
102834: PUSH
102835: EMPTY
102836: LIST
102837: LIST
102838: PUSH
102839: LD_INT 3
102841: PUSH
102842: LD_INT 23
102844: PUSH
102845: LD_INT 0
102847: PUSH
102848: EMPTY
102849: LIST
102850: LIST
102851: PUSH
102852: EMPTY
102853: LIST
102854: LIST
102855: PUSH
102856: EMPTY
102857: LIST
102858: LIST
102859: LIST
102860: PPUSH
102861: CALL_OW 69
102865: ST_TO_ADDR
// if not tmp then
102866: LD_VAR 0 6
102870: NOT
102871: IFFALSE 102875
// exit ;
102873: GO 103021
// s1 := rand ( 1 , 4 ) ;
102875: LD_ADDR_VAR 0 2
102879: PUSH
102880: LD_INT 1
102882: PPUSH
102883: LD_INT 4
102885: PPUSH
102886: CALL_OW 12
102890: ST_TO_ADDR
// sk1 := GetSkill ( tmp [ 1 ] , s1 ) ;
102891: LD_ADDR_VAR 0 4
102895: PUSH
102896: LD_VAR 0 6
102900: PUSH
102901: LD_INT 1
102903: ARRAY
102904: PPUSH
102905: LD_VAR 0 2
102909: PPUSH
102910: CALL_OW 259
102914: ST_TO_ADDR
// if s1 = 1 then
102915: LD_VAR 0 2
102919: PUSH
102920: LD_INT 1
102922: EQUAL
102923: IFFALSE 102943
// s2 := rand ( 2 , 4 ) else
102925: LD_ADDR_VAR 0 3
102929: PUSH
102930: LD_INT 2
102932: PPUSH
102933: LD_INT 4
102935: PPUSH
102936: CALL_OW 12
102940: ST_TO_ADDR
102941: GO 102951
// s2 := 1 ;
102943: LD_ADDR_VAR 0 3
102947: PUSH
102948: LD_INT 1
102950: ST_TO_ADDR
// sk2 := GetSkill ( tmp [ 1 ] , s2 ) ;
102951: LD_ADDR_VAR 0 5
102955: PUSH
102956: LD_VAR 0 6
102960: PUSH
102961: LD_INT 1
102963: ARRAY
102964: PPUSH
102965: LD_VAR 0 3
102969: PPUSH
102970: CALL_OW 259
102974: ST_TO_ADDR
// SetSkill ( tmp [ 1 ] , s1 , sk2 ) ;
102975: LD_VAR 0 6
102979: PUSH
102980: LD_INT 1
102982: ARRAY
102983: PPUSH
102984: LD_VAR 0 2
102988: PPUSH
102989: LD_VAR 0 5
102993: PPUSH
102994: CALL_OW 237
// SetSkill ( tmp [ 1 ] , s2 , sk1 ) ;
102998: LD_VAR 0 6
103002: PUSH
103003: LD_INT 1
103005: ARRAY
103006: PPUSH
103007: LD_VAR 0 3
103011: PPUSH
103012: LD_VAR 0 4
103016: PPUSH
103017: CALL_OW 237
// end ;
103021: PPOPN 6
103023: END
// every 0 0$1 trigger StreamModeActive and sFac do var tmp ;
103024: LD_EXP 139
103028: PUSH
103029: LD_EXP 186
103033: AND
103034: IFFALSE 103113
103036: GO 103038
103038: DISABLE
103039: LD_INT 0
103041: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_btype , b_factory ] ] ) ;
103042: LD_ADDR_VAR 0 1
103046: PUSH
103047: LD_INT 22
103049: PUSH
103050: LD_OWVAR 2
103054: PUSH
103055: EMPTY
103056: LIST
103057: LIST
103058: PUSH
103059: LD_INT 30
103061: PUSH
103062: LD_INT 3
103064: PUSH
103065: EMPTY
103066: LIST
103067: LIST
103068: PUSH
103069: EMPTY
103070: LIST
103071: LIST
103072: PPUSH
103073: CALL_OW 69
103077: ST_TO_ADDR
// if not tmp then
103078: LD_VAR 0 1
103082: NOT
103083: IFFALSE 103087
// exit ;
103085: GO 103113
// SetLives ( tmp [ rand ( 1 , tmp ) ] , 1 ) ;
103087: LD_VAR 0 1
103091: PUSH
103092: LD_INT 1
103094: PPUSH
103095: LD_VAR 0 1
103099: PPUSH
103100: CALL_OW 12
103104: ARRAY
103105: PPUSH
103106: LD_INT 1
103108: PPUSH
103109: CALL_OW 234
// end ;
103113: PPOPN 1
103115: END
// every 0 0$1 trigger StreamModeActive and sPower do var i , tmp ;
103116: LD_EXP 139
103120: PUSH
103121: LD_EXP 187
103125: AND
103126: IFFALSE 103238
103128: GO 103130
103130: DISABLE
103131: LD_INT 0
103133: PPUSH
103134: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_or , [ f_btype , b_solar_power ] , [ f_btype , b_oil_power ] , [ f_btype , b_siberite_power ] ] ] ) ;
103135: LD_ADDR_VAR 0 2
103139: PUSH
103140: LD_INT 22
103142: PUSH
103143: LD_OWVAR 2
103147: PUSH
103148: EMPTY
103149: LIST
103150: LIST
103151: PUSH
103152: LD_INT 2
103154: PUSH
103155: LD_INT 30
103157: PUSH
103158: LD_INT 27
103160: PUSH
103161: EMPTY
103162: LIST
103163: LIST
103164: PUSH
103165: LD_INT 30
103167: PUSH
103168: LD_INT 26
103170: PUSH
103171: EMPTY
103172: LIST
103173: LIST
103174: PUSH
103175: LD_INT 30
103177: PUSH
103178: LD_INT 28
103180: PUSH
103181: EMPTY
103182: LIST
103183: LIST
103184: PUSH
103185: EMPTY
103186: LIST
103187: LIST
103188: LIST
103189: LIST
103190: PUSH
103191: EMPTY
103192: LIST
103193: LIST
103194: PPUSH
103195: CALL_OW 69
103199: ST_TO_ADDR
// if not tmp then
103200: LD_VAR 0 2
103204: NOT
103205: IFFALSE 103209
// exit ;
103207: GO 103238
// for i in tmp do
103209: LD_ADDR_VAR 0 1
103213: PUSH
103214: LD_VAR 0 2
103218: PUSH
103219: FOR_IN
103220: IFFALSE 103236
// SetLives ( i , 1 ) ;
103222: LD_VAR 0 1
103226: PPUSH
103227: LD_INT 1
103229: PPUSH
103230: CALL_OW 234
103234: GO 103219
103236: POP
103237: POP
// end ;
103238: PPOPN 2
103240: END
// every 0 0$1 trigger StreamModeActive and sRandom do var i , tmp , un ;
103241: LD_EXP 139
103245: PUSH
103246: LD_EXP 188
103250: AND
103251: IFFALSE 103538
103253: GO 103255
103255: DISABLE
103256: LD_INT 0
103258: PPUSH
103259: PPUSH
103260: PPUSH
// begin i := rand ( 1 , 7 ) ;
103261: LD_ADDR_VAR 0 1
103265: PUSH
103266: LD_INT 1
103268: PPUSH
103269: LD_INT 7
103271: PPUSH
103272: CALL_OW 12
103276: ST_TO_ADDR
// case i of 1 :
103277: LD_VAR 0 1
103281: PUSH
103282: LD_INT 1
103284: DOUBLE
103285: EQUAL
103286: IFTRUE 103290
103288: GO 103300
103290: POP
// ToLua ( earthquake(getX(game), 0, 32) ) ; 2 :
103291: LD_STRING earthquake(getX(game), 0, 32)
103293: PPUSH
103294: CALL_OW 559
103298: GO 103538
103300: LD_INT 2
103302: DOUBLE
103303: EQUAL
103304: IFTRUE 103308
103306: GO 103322
103308: POP
// begin ToLua ( displayStucuk(); ) ;
103309: LD_STRING displayStucuk();
103311: PPUSH
103312: CALL_OW 559
// ResetFog ;
103316: CALL_OW 335
// end ; 3 :
103320: GO 103538
103322: LD_INT 3
103324: DOUBLE
103325: EQUAL
103326: IFTRUE 103330
103328: GO 103434
103330: POP
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_class , 1 ] ] ) ;
103331: LD_ADDR_VAR 0 2
103335: PUSH
103336: LD_INT 22
103338: PUSH
103339: LD_OWVAR 2
103343: PUSH
103344: EMPTY
103345: LIST
103346: LIST
103347: PUSH
103348: LD_INT 25
103350: PUSH
103351: LD_INT 1
103353: PUSH
103354: EMPTY
103355: LIST
103356: LIST
103357: PUSH
103358: EMPTY
103359: LIST
103360: LIST
103361: PPUSH
103362: CALL_OW 69
103366: ST_TO_ADDR
// if not tmp then
103367: LD_VAR 0 2
103371: NOT
103372: IFFALSE 103376
// exit ;
103374: GO 103538
// un := tmp [ rand ( 1 , tmp ) ] ;
103376: LD_ADDR_VAR 0 3
103380: PUSH
103381: LD_VAR 0 2
103385: PUSH
103386: LD_INT 1
103388: PPUSH
103389: LD_VAR 0 2
103393: PPUSH
103394: CALL_OW 12
103398: ARRAY
103399: ST_TO_ADDR
// if Crawls ( un ) then
103400: LD_VAR 0 3
103404: PPUSH
103405: CALL_OW 318
103409: IFFALSE 103420
// ComWalk ( un ) ;
103411: LD_VAR 0 3
103415: PPUSH
103416: CALL_OW 138
// SetClass ( un , class_mortar ) ;
103420: LD_VAR 0 3
103424: PPUSH
103425: LD_INT 8
103427: PPUSH
103428: CALL_OW 336
// end ; 4 :
103432: GO 103538
103434: LD_INT 4
103436: DOUBLE
103437: EQUAL
103438: IFTRUE 103442
103440: GO 103516
103442: POP
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_btype , b_oil_mine ] ] ) ;
103443: LD_ADDR_VAR 0 2
103447: PUSH
103448: LD_INT 22
103450: PUSH
103451: LD_OWVAR 2
103455: PUSH
103456: EMPTY
103457: LIST
103458: LIST
103459: PUSH
103460: LD_INT 30
103462: PUSH
103463: LD_INT 29
103465: PUSH
103466: EMPTY
103467: LIST
103468: LIST
103469: PUSH
103470: EMPTY
103471: LIST
103472: LIST
103473: PPUSH
103474: CALL_OW 69
103478: ST_TO_ADDR
// if not tmp then
103479: LD_VAR 0 2
103483: NOT
103484: IFFALSE 103488
// exit ;
103486: GO 103538
// CenterNowOnUnits ( tmp [ 1 ] ) ;
103488: LD_VAR 0 2
103492: PUSH
103493: LD_INT 1
103495: ARRAY
103496: PPUSH
103497: CALL_OW 87
// DestroyUnit ( tmp [ 1 ] ) ;
103501: LD_VAR 0 2
103505: PUSH
103506: LD_INT 1
103508: ARRAY
103509: PPUSH
103510: CALL_OW 65
// end ; 5 .. 7 :
103514: GO 103538
103516: LD_INT 5
103518: DOUBLE
103519: GREATEREQUAL
103520: IFFALSE 103528
103522: LD_INT 7
103524: DOUBLE
103525: LESSEQUAL
103526: IFTRUE 103530
103528: GO 103537
103530: POP
// StreamSibBomb ; end ;
103531: CALL 99775 0 0
103535: GO 103538
103537: POP
// end ;
103538: PPOPN 3
103540: END
// every 0 0$1 trigger StreamModeActive and sShield do var i , tmp , p ;
103541: LD_EXP 139
103545: PUSH
103546: LD_EXP 189
103550: AND
103551: IFFALSE 103707
103553: GO 103555
103555: DISABLE
103556: LD_INT 0
103558: PPUSH
103559: PPUSH
103560: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_enemy , your_side ] , [ f_or , [ f_type , unit_human ] , [ f_type , unit_vehicle ] ] ] ) ;
103561: LD_ADDR_VAR 0 2
103565: PUSH
103566: LD_INT 81
103568: PUSH
103569: LD_OWVAR 2
103573: PUSH
103574: EMPTY
103575: LIST
103576: LIST
103577: PUSH
103578: LD_INT 2
103580: PUSH
103581: LD_INT 21
103583: PUSH
103584: LD_INT 1
103586: PUSH
103587: EMPTY
103588: LIST
103589: LIST
103590: PUSH
103591: LD_INT 21
103593: PUSH
103594: LD_INT 2
103596: PUSH
103597: EMPTY
103598: LIST
103599: LIST
103600: PUSH
103601: EMPTY
103602: LIST
103603: LIST
103604: LIST
103605: PUSH
103606: EMPTY
103607: LIST
103608: LIST
103609: PPUSH
103610: CALL_OW 69
103614: ST_TO_ADDR
// if not tmp then
103615: LD_VAR 0 2
103619: NOT
103620: IFFALSE 103624
// exit ;
103622: GO 103707
// p := 0 ;
103624: LD_ADDR_VAR 0 3
103628: PUSH
103629: LD_INT 0
103631: ST_TO_ADDR
// repeat wait ( 0 0$1 ) ;
103632: LD_INT 35
103634: PPUSH
103635: CALL_OW 67
// p := p + 1 ;
103639: LD_ADDR_VAR 0 3
103643: PUSH
103644: LD_VAR 0 3
103648: PUSH
103649: LD_INT 1
103651: PLUS
103652: ST_TO_ADDR
// for i in tmp do
103653: LD_ADDR_VAR 0 1
103657: PUSH
103658: LD_VAR 0 2
103662: PUSH
103663: FOR_IN
103664: IFFALSE 103695
// if GetLives ( i ) < 1000 then
103666: LD_VAR 0 1
103670: PPUSH
103671: CALL_OW 256
103675: PUSH
103676: LD_INT 1000
103678: LESS
103679: IFFALSE 103693
// SetLives ( i , 1000 ) ;
103681: LD_VAR 0 1
103685: PPUSH
103686: LD_INT 1000
103688: PPUSH
103689: CALL_OW 234
103693: GO 103663
103695: POP
103696: POP
// until p > 20 ;
103697: LD_VAR 0 3
103701: PUSH
103702: LD_INT 20
103704: GREATER
103705: IFFALSE 103632
// end ;
103707: PPOPN 3
103709: END
// every 0 0$1 trigger StreamModeActive and sTime do
103710: LD_EXP 139
103714: PUSH
103715: LD_EXP 190
103719: AND
103720: IFFALSE 103755
103722: GO 103724
103724: DISABLE
// begin SetTech ( tech_tauRad , your_side , state_researched ) ;
103725: LD_INT 28
103727: PPUSH
103728: LD_OWVAR 2
103732: PPUSH
103733: LD_INT 2
103735: PPUSH
103736: CALL_OW 322
// SetTech ( tech_tauField , your_side , state_researched ) ;
103740: LD_INT 30
103742: PPUSH
103743: LD_OWVAR 2
103747: PPUSH
103748: LD_INT 2
103750: PPUSH
103751: CALL_OW 322
// end ;
103755: END
// every 0 0$1 trigger StreamModeActive and sTools do var i , tmp ;
103756: LD_EXP 139
103760: PUSH
103761: LD_EXP 191
103765: AND
103766: IFFALSE 103887
103768: GO 103770
103770: DISABLE
103771: LD_INT 0
103773: PPUSH
103774: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_type , unit_human ] , [ f_not , [ f_nation , 0 ] ] ] ) ;
103775: LD_ADDR_VAR 0 2
103779: PUSH
103780: LD_INT 22
103782: PUSH
103783: LD_OWVAR 2
103787: PUSH
103788: EMPTY
103789: LIST
103790: LIST
103791: PUSH
103792: LD_INT 21
103794: PUSH
103795: LD_INT 1
103797: PUSH
103798: EMPTY
103799: LIST
103800: LIST
103801: PUSH
103802: LD_INT 3
103804: PUSH
103805: LD_INT 23
103807: PUSH
103808: LD_INT 0
103810: PUSH
103811: EMPTY
103812: LIST
103813: LIST
103814: PUSH
103815: EMPTY
103816: LIST
103817: LIST
103818: PUSH
103819: EMPTY
103820: LIST
103821: LIST
103822: LIST
103823: PPUSH
103824: CALL_OW 69
103828: ST_TO_ADDR
// if not tmp then
103829: LD_VAR 0 2
103833: NOT
103834: IFFALSE 103838
// exit ;
103836: GO 103887
// for i in tmp do
103838: LD_ADDR_VAR 0 1
103842: PUSH
103843: LD_VAR 0 2
103847: PUSH
103848: FOR_IN
103849: IFFALSE 103885
// begin if Crawls ( i ) then
103851: LD_VAR 0 1
103855: PPUSH
103856: CALL_OW 318
103860: IFFALSE 103871
// ComWalk ( i ) ;
103862: LD_VAR 0 1
103866: PPUSH
103867: CALL_OW 138
// SetClass ( i , 2 ) ;
103871: LD_VAR 0 1
103875: PPUSH
103876: LD_INT 2
103878: PPUSH
103879: CALL_OW 336
// end ;
103883: GO 103848
103885: POP
103886: POP
// end ;
103887: PPOPN 2
103889: END
// every 0 0$1 trigger StreamModeActive and sRanger do var i , p , un ;
103890: LD_EXP 139
103894: PUSH
103895: LD_EXP 192
103899: AND
103900: IFFALSE 104188
103902: GO 103904
103904: DISABLE
103905: LD_INT 0
103907: PPUSH
103908: PPUSH
103909: PPUSH
// begin SetAttitude ( your_side , 9 , att_friend , true ) ;
103910: LD_OWVAR 2
103914: PPUSH
103915: LD_INT 9
103917: PPUSH
103918: LD_INT 1
103920: PPUSH
103921: LD_INT 1
103923: PPUSH
103924: CALL_OW 80
// ChangeSideFog ( 9 , your_side ) ;
103928: LD_INT 9
103930: PPUSH
103931: LD_OWVAR 2
103935: PPUSH
103936: CALL_OW 343
// uc_side := 9 ;
103940: LD_ADDR_OWVAR 20
103944: PUSH
103945: LD_INT 9
103947: ST_TO_ADDR
// uc_nation := 2 ;
103948: LD_ADDR_OWVAR 21
103952: PUSH
103953: LD_INT 2
103955: ST_TO_ADDR
// hc_name := Dark Warrior ;
103956: LD_ADDR_OWVAR 26
103960: PUSH
103961: LD_STRING Dark Warrior
103963: ST_TO_ADDR
// hc_gallery :=  ;
103964: LD_ADDR_OWVAR 33
103968: PUSH
103969: LD_STRING 
103971: ST_TO_ADDR
// hc_noskilllimit := true ;
103972: LD_ADDR_OWVAR 76
103976: PUSH
103977: LD_INT 1
103979: ST_TO_ADDR
// hc_skills := [ 30 , 30 , 30 , 30 ] ;
103980: LD_ADDR_OWVAR 31
103984: PUSH
103985: LD_INT 30
103987: PUSH
103988: LD_INT 30
103990: PUSH
103991: LD_INT 30
103993: PUSH
103994: LD_INT 30
103996: PUSH
103997: EMPTY
103998: LIST
103999: LIST
104000: LIST
104001: LIST
104002: ST_TO_ADDR
// un := CreateHuman ;
104003: LD_ADDR_VAR 0 3
104007: PUSH
104008: CALL_OW 44
104012: ST_TO_ADDR
// hc_noskilllimit := false ;
104013: LD_ADDR_OWVAR 76
104017: PUSH
104018: LD_INT 0
104020: ST_TO_ADDR
// PlaceUnitAnywhere ( un , true ) ;
104021: LD_VAR 0 3
104025: PPUSH
104026: LD_INT 1
104028: PPUSH
104029: CALL_OW 51
// ToLua ( playRanger() ) ;
104033: LD_STRING playRanger()
104035: PPUSH
104036: CALL_OW 559
// p := 0 ;
104040: LD_ADDR_VAR 0 2
104044: PUSH
104045: LD_INT 0
104047: ST_TO_ADDR
// repeat wait ( 0 0$1 ) ;
104048: LD_INT 35
104050: PPUSH
104051: CALL_OW 67
// p := p + 1 ;
104055: LD_ADDR_VAR 0 2
104059: PUSH
104060: LD_VAR 0 2
104064: PUSH
104065: LD_INT 1
104067: PLUS
104068: ST_TO_ADDR
// if GetLives ( un ) < 1000 then
104069: LD_VAR 0 3
104073: PPUSH
104074: CALL_OW 256
104078: PUSH
104079: LD_INT 1000
104081: LESS
104082: IFFALSE 104096
// SetLives ( un , 1000 ) ;
104084: LD_VAR 0 3
104088: PPUSH
104089: LD_INT 1000
104091: PPUSH
104092: CALL_OW 234
// ComAttackUnit ( un , NearestUnitToUnit ( FilterAllUnits ( [ [ f_enemy , your_side ] , [ f_dist , un , 30 ] ] ) , un ) ) ;
104096: LD_VAR 0 3
104100: PPUSH
104101: LD_INT 81
104103: PUSH
104104: LD_OWVAR 2
104108: PUSH
104109: EMPTY
104110: LIST
104111: LIST
104112: PUSH
104113: LD_INT 91
104115: PUSH
104116: LD_VAR 0 3
104120: PUSH
104121: LD_INT 30
104123: PUSH
104124: EMPTY
104125: LIST
104126: LIST
104127: LIST
104128: PUSH
104129: EMPTY
104130: LIST
104131: LIST
104132: PPUSH
104133: CALL_OW 69
104137: PPUSH
104138: LD_VAR 0 3
104142: PPUSH
104143: CALL_OW 74
104147: PPUSH
104148: CALL_OW 115
// until p > 80 or IsDead ( un ) ;
104152: LD_VAR 0 2
104156: PUSH
104157: LD_INT 80
104159: GREATER
104160: PUSH
104161: LD_VAR 0 3
104165: PPUSH
104166: CALL_OW 301
104170: OR
104171: IFFALSE 104048
// if un then
104173: LD_VAR 0 3
104177: IFFALSE 104188
// RemoveUnit ( un ) ;
104179: LD_VAR 0 3
104183: PPUSH
104184: CALL_OW 64
// end ;
104188: PPOPN 3
104190: END
// every 0 0$1 trigger sComputer do var i , tmp , j ;
104191: LD_EXP 193
104195: IFFALSE 104311
104197: GO 104199
104199: DISABLE
104200: LD_INT 0
104202: PPUSH
104203: PPUSH
104204: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_enemy , your_side ] , [ f_type , unit_human ] ] ) ;
104205: LD_ADDR_VAR 0 2
104209: PUSH
104210: LD_INT 81
104212: PUSH
104213: LD_OWVAR 2
104217: PUSH
104218: EMPTY
104219: LIST
104220: LIST
104221: PUSH
104222: LD_INT 21
104224: PUSH
104225: LD_INT 1
104227: PUSH
104228: EMPTY
104229: LIST
104230: LIST
104231: PUSH
104232: EMPTY
104233: LIST
104234: LIST
104235: PPUSH
104236: CALL_OW 69
104240: ST_TO_ADDR
// ToLua ( playComputer() ) ;
104241: LD_STRING playComputer()
104243: PPUSH
104244: CALL_OW 559
// if not tmp then
104248: LD_VAR 0 2
104252: NOT
104253: IFFALSE 104257
// exit ;
104255: GO 104311
// for i in tmp do
104257: LD_ADDR_VAR 0 1
104261: PUSH
104262: LD_VAR 0 2
104266: PUSH
104267: FOR_IN
104268: IFFALSE 104309
// for j := 1 to 4 do
104270: LD_ADDR_VAR 0 3
104274: PUSH
104275: DOUBLE
104276: LD_INT 1
104278: DEC
104279: ST_TO_ADDR
104280: LD_INT 4
104282: PUSH
104283: FOR_TO
104284: IFFALSE 104305
// SetSkill ( i , j , 10 ) ;
104286: LD_VAR 0 1
104290: PPUSH
104291: LD_VAR 0 3
104295: PPUSH
104296: LD_INT 10
104298: PPUSH
104299: CALL_OW 237
104303: GO 104283
104305: POP
104306: POP
104307: GO 104267
104309: POP
104310: POP
// end ;
104311: PPOPN 3
104313: END
// every 0 0$1 trigger s30 do var i , tmp ;
104314: LD_EXP 194
104318: IFFALSE 104387
104320: GO 104322
104322: DISABLE
104323: LD_INT 0
104325: PPUSH
104326: PPUSH
// begin tmp := FilterAllUnits ( [ f_side , your_side ] ) ;
104327: LD_ADDR_VAR 0 2
104331: PUSH
104332: LD_INT 22
104334: PUSH
104335: LD_OWVAR 2
104339: PUSH
104340: EMPTY
104341: LIST
104342: LIST
104343: PPUSH
104344: CALL_OW 69
104348: ST_TO_ADDR
// if not tmp then
104349: LD_VAR 0 2
104353: NOT
104354: IFFALSE 104358
// exit ;
104356: GO 104387
// for i in tmp do
104358: LD_ADDR_VAR 0 1
104362: PUSH
104363: LD_VAR 0 2
104367: PUSH
104368: FOR_IN
104369: IFFALSE 104385
// SetLives ( i , 300 ) ;
104371: LD_VAR 0 1
104375: PPUSH
104376: LD_INT 300
104378: PPUSH
104379: CALL_OW 234
104383: GO 104368
104385: POP
104386: POP
// end ;
104387: PPOPN 2
104389: END
// every 0 0$1 trigger s60 do var i , tmp ;
104390: LD_EXP 195
104394: IFFALSE 104463
104396: GO 104398
104398: DISABLE
104399: LD_INT 0
104401: PPUSH
104402: PPUSH
// begin tmp := FilterAllUnits ( [ f_side , your_side ] ) ;
104403: LD_ADDR_VAR 0 2
104407: PUSH
104408: LD_INT 22
104410: PUSH
104411: LD_OWVAR 2
104415: PUSH
104416: EMPTY
104417: LIST
104418: LIST
104419: PPUSH
104420: CALL_OW 69
104424: ST_TO_ADDR
// if not tmp then
104425: LD_VAR 0 2
104429: NOT
104430: IFFALSE 104434
// exit ;
104432: GO 104463
// for i in tmp do
104434: LD_ADDR_VAR 0 1
104438: PUSH
104439: LD_VAR 0 2
104443: PUSH
104444: FOR_IN
104445: IFFALSE 104461
// SetLives ( i , 600 ) ;
104447: LD_VAR 0 1
104451: PPUSH
104452: LD_INT 600
104454: PPUSH
104455: CALL_OW 234
104459: GO 104444
104461: POP
104462: POP
// end ;
104463: PPOPN 2
104465: END
// export function SOS_TargetableHack ( cmd , unit , selectedUnit , x , y , p1 , p2 , p3 , p4 , p5 , p6 ) ; begin
104466: LD_INT 0
104468: PPUSH
// case cmd of 301 :
104469: LD_VAR 0 1
104473: PUSH
104474: LD_INT 301
104476: DOUBLE
104477: EQUAL
104478: IFTRUE 104482
104480: GO 104514
104482: POP
// hHackSpawnHuman ( p1 , p2 , p3 , x , y ) ; 302 :
104483: LD_VAR 0 6
104487: PPUSH
104488: LD_VAR 0 7
104492: PPUSH
104493: LD_VAR 0 8
104497: PPUSH
104498: LD_VAR 0 4
104502: PPUSH
104503: LD_VAR 0 5
104507: PPUSH
104508: CALL 105715 0 5
104512: GO 104635
104514: LD_INT 302
104516: DOUBLE
104517: EQUAL
104518: IFTRUE 104522
104520: GO 104559
104522: POP
// hHackSpawnVehicle ( p1 , p2 , p3 , p4 , x , y ) ; 303 :
104523: LD_VAR 0 6
104527: PPUSH
104528: LD_VAR 0 7
104532: PPUSH
104533: LD_VAR 0 8
104537: PPUSH
104538: LD_VAR 0 9
104542: PPUSH
104543: LD_VAR 0 4
104547: PPUSH
104548: LD_VAR 0 5
104552: PPUSH
104553: CALL 105806 0 6
104557: GO 104635
104559: LD_INT 303
104561: DOUBLE
104562: EQUAL
104563: IFTRUE 104567
104565: GO 104604
104567: POP
// hHackSpawnBuilding ( p1 , p2 , p3 , p4 , x , y ) ; 304 :
104568: LD_VAR 0 6
104572: PPUSH
104573: LD_VAR 0 7
104577: PPUSH
104578: LD_VAR 0 8
104582: PPUSH
104583: LD_VAR 0 9
104587: PPUSH
104588: LD_VAR 0 4
104592: PPUSH
104593: LD_VAR 0 5
104597: PPUSH
104598: CALL 104640 0 6
104602: GO 104635
104604: LD_INT 304
104606: DOUBLE
104607: EQUAL
104608: IFTRUE 104612
104610: GO 104634
104612: POP
// hHackTeleport ( unit , x , y ) ; end ;
104613: LD_VAR 0 2
104617: PPUSH
104618: LD_VAR 0 4
104622: PPUSH
104623: LD_VAR 0 5
104627: PPUSH
104628: CALL 106399 0 3
104632: GO 104635
104634: POP
// end ;
104635: LD_VAR 0 12
104639: RET
// export function hHackSpawnBuilding ( nation , btype , dir , weapon , x , y ) ; var b ; begin
104640: LD_INT 0
104642: PPUSH
104643: PPUSH
// if nation < 1 or nation > 3 or HexInfo ( x , y ) then
104644: LD_VAR 0 1
104648: PUSH
104649: LD_INT 1
104651: LESS
104652: PUSH
104653: LD_VAR 0 1
104657: PUSH
104658: LD_INT 3
104660: GREATER
104661: OR
104662: PUSH
104663: LD_VAR 0 5
104667: PPUSH
104668: LD_VAR 0 6
104672: PPUSH
104673: CALL_OW 428
104677: OR
104678: IFFALSE 104682
// exit ;
104680: GO 105402
// uc_side := your_side ;
104682: LD_ADDR_OWVAR 20
104686: PUSH
104687: LD_OWVAR 2
104691: ST_TO_ADDR
// uc_nation := nation ;
104692: LD_ADDR_OWVAR 21
104696: PUSH
104697: LD_VAR 0 1
104701: ST_TO_ADDR
// bc_level = 1 ;
104702: LD_ADDR_OWVAR 43
104706: PUSH
104707: LD_INT 1
104709: ST_TO_ADDR
// case btype of 1 :
104710: LD_VAR 0 2
104714: PUSH
104715: LD_INT 1
104717: DOUBLE
104718: EQUAL
104719: IFTRUE 104723
104721: GO 104734
104723: POP
// bc_type := b_depot ; 2 :
104724: LD_ADDR_OWVAR 42
104728: PUSH
104729: LD_INT 0
104731: ST_TO_ADDR
104732: GO 105346
104734: LD_INT 2
104736: DOUBLE
104737: EQUAL
104738: IFTRUE 104742
104740: GO 104753
104742: POP
// bc_type := b_warehouse ; 3 :
104743: LD_ADDR_OWVAR 42
104747: PUSH
104748: LD_INT 1
104750: ST_TO_ADDR
104751: GO 105346
104753: LD_INT 3
104755: DOUBLE
104756: EQUAL
104757: IFTRUE 104761
104759: GO 104772
104761: POP
// bc_type := b_lab ; 4 .. 9 :
104762: LD_ADDR_OWVAR 42
104766: PUSH
104767: LD_INT 6
104769: ST_TO_ADDR
104770: GO 105346
104772: LD_INT 4
104774: DOUBLE
104775: GREATEREQUAL
104776: IFFALSE 104784
104778: LD_INT 9
104780: DOUBLE
104781: LESSEQUAL
104782: IFTRUE 104786
104784: GO 104838
104786: POP
// begin bc_type := b_lab_half ;
104787: LD_ADDR_OWVAR 42
104791: PUSH
104792: LD_INT 7
104794: ST_TO_ADDR
// bc_kind1 := [ b_lab_weapon , b_lab_siberium , b_lab_computer , b_lab_opto , b_lab_spacetime , b_lab_biological ] [ btype - 3 ] ;
104795: LD_ADDR_OWVAR 44
104799: PUSH
104800: LD_INT 10
104802: PUSH
104803: LD_INT 11
104805: PUSH
104806: LD_INT 12
104808: PUSH
104809: LD_INT 15
104811: PUSH
104812: LD_INT 14
104814: PUSH
104815: LD_INT 13
104817: PUSH
104818: EMPTY
104819: LIST
104820: LIST
104821: LIST
104822: LIST
104823: LIST
104824: LIST
104825: PUSH
104826: LD_VAR 0 2
104830: PUSH
104831: LD_INT 3
104833: MINUS
104834: ARRAY
104835: ST_TO_ADDR
// end ; 10 .. 13 :
104836: GO 105346
104838: LD_INT 10
104840: DOUBLE
104841: GREATEREQUAL
104842: IFFALSE 104850
104844: LD_INT 13
104846: DOUBLE
104847: LESSEQUAL
104848: IFTRUE 104852
104850: GO 104929
104852: POP
// begin bc_type := b_lab_full ;
104853: LD_ADDR_OWVAR 42
104857: PUSH
104858: LD_INT 8
104860: ST_TO_ADDR
// bc_kind1 := [ b_lab_weapon , b_lab_computer , b_lab_spacetime , b_lab_biological ] [ btype - 9 ] ;
104861: LD_ADDR_OWVAR 44
104865: PUSH
104866: LD_INT 10
104868: PUSH
104869: LD_INT 12
104871: PUSH
104872: LD_INT 14
104874: PUSH
104875: LD_INT 13
104877: PUSH
104878: EMPTY
104879: LIST
104880: LIST
104881: LIST
104882: LIST
104883: PUSH
104884: LD_VAR 0 2
104888: PUSH
104889: LD_INT 9
104891: MINUS
104892: ARRAY
104893: ST_TO_ADDR
// bc_kind2 := [ b_lab_siberium , b_lab_opto , b_lab_computer , b_lab_opto ] [ btype - 9 ] ;
104894: LD_ADDR_OWVAR 45
104898: PUSH
104899: LD_INT 11
104901: PUSH
104902: LD_INT 15
104904: PUSH
104905: LD_INT 12
104907: PUSH
104908: LD_INT 15
104910: PUSH
104911: EMPTY
104912: LIST
104913: LIST
104914: LIST
104915: LIST
104916: PUSH
104917: LD_VAR 0 2
104921: PUSH
104922: LD_INT 9
104924: MINUS
104925: ARRAY
104926: ST_TO_ADDR
// end ; 14 :
104927: GO 105346
104929: LD_INT 14
104931: DOUBLE
104932: EQUAL
104933: IFTRUE 104937
104935: GO 104948
104937: POP
// bc_type := b_workshop ; 15 :
104938: LD_ADDR_OWVAR 42
104942: PUSH
104943: LD_INT 2
104945: ST_TO_ADDR
104946: GO 105346
104948: LD_INT 15
104950: DOUBLE
104951: EQUAL
104952: IFTRUE 104956
104954: GO 104967
104956: POP
// bc_type := b_factory ; 16 :
104957: LD_ADDR_OWVAR 42
104961: PUSH
104962: LD_INT 3
104964: ST_TO_ADDR
104965: GO 105346
104967: LD_INT 16
104969: DOUBLE
104970: EQUAL
104971: IFTRUE 104975
104973: GO 104986
104975: POP
// bc_type := b_ext_gun ; 17 :
104976: LD_ADDR_OWVAR 42
104980: PUSH
104981: LD_INT 17
104983: ST_TO_ADDR
104984: GO 105346
104986: LD_INT 17
104988: DOUBLE
104989: EQUAL
104990: IFTRUE 104994
104992: GO 105022
104994: POP
// bc_type := [ b_ext_noncombat , b_ext_stitch , b_ext_noncombat ] [ nation ] ; 18 :
104995: LD_ADDR_OWVAR 42
104999: PUSH
105000: LD_INT 19
105002: PUSH
105003: LD_INT 23
105005: PUSH
105006: LD_INT 19
105008: PUSH
105009: EMPTY
105010: LIST
105011: LIST
105012: LIST
105013: PUSH
105014: LD_VAR 0 1
105018: ARRAY
105019: ST_TO_ADDR
105020: GO 105346
105022: LD_INT 18
105024: DOUBLE
105025: EQUAL
105026: IFTRUE 105030
105028: GO 105041
105030: POP
// bc_type := b_ext_radar ; 19 :
105031: LD_ADDR_OWVAR 42
105035: PUSH
105036: LD_INT 20
105038: ST_TO_ADDR
105039: GO 105346
105041: LD_INT 19
105043: DOUBLE
105044: EQUAL
105045: IFTRUE 105049
105047: GO 105060
105049: POP
// bc_type := b_ext_radio ; 20 :
105050: LD_ADDR_OWVAR 42
105054: PUSH
105055: LD_INT 22
105057: ST_TO_ADDR
105058: GO 105346
105060: LD_INT 20
105062: DOUBLE
105063: EQUAL
105064: IFTRUE 105068
105066: GO 105079
105068: POP
// bc_type := b_ext_siberium ; 21 :
105069: LD_ADDR_OWVAR 42
105073: PUSH
105074: LD_INT 21
105076: ST_TO_ADDR
105077: GO 105346
105079: LD_INT 21
105081: DOUBLE
105082: EQUAL
105083: IFTRUE 105087
105085: GO 105098
105087: POP
// bc_type := b_ext_computer ; 22 :
105088: LD_ADDR_OWVAR 42
105092: PUSH
105093: LD_INT 24
105095: ST_TO_ADDR
105096: GO 105346
105098: LD_INT 22
105100: DOUBLE
105101: EQUAL
105102: IFTRUE 105106
105104: GO 105117
105106: POP
// bc_type := b_ext_track ; 23 :
105107: LD_ADDR_OWVAR 42
105111: PUSH
105112: LD_INT 16
105114: ST_TO_ADDR
105115: GO 105346
105117: LD_INT 23
105119: DOUBLE
105120: EQUAL
105121: IFTRUE 105125
105123: GO 105136
105125: POP
// bc_type := b_ext_laser ; 24 :
105126: LD_ADDR_OWVAR 42
105130: PUSH
105131: LD_INT 25
105133: ST_TO_ADDR
105134: GO 105346
105136: LD_INT 24
105138: DOUBLE
105139: EQUAL
105140: IFTRUE 105144
105142: GO 105155
105144: POP
// bc_type := b_control_tower ; 25 :
105145: LD_ADDR_OWVAR 42
105149: PUSH
105150: LD_INT 36
105152: ST_TO_ADDR
105153: GO 105346
105155: LD_INT 25
105157: DOUBLE
105158: EQUAL
105159: IFTRUE 105163
105161: GO 105174
105163: POP
// bc_type := b_breastwork ; 26 :
105164: LD_ADDR_OWVAR 42
105168: PUSH
105169: LD_INT 31
105171: ST_TO_ADDR
105172: GO 105346
105174: LD_INT 26
105176: DOUBLE
105177: EQUAL
105178: IFTRUE 105182
105180: GO 105193
105182: POP
// bc_type := b_bunker ; 27 :
105183: LD_ADDR_OWVAR 42
105187: PUSH
105188: LD_INT 32
105190: ST_TO_ADDR
105191: GO 105346
105193: LD_INT 27
105195: DOUBLE
105196: EQUAL
105197: IFTRUE 105201
105199: GO 105212
105201: POP
// bc_type := b_turret ; 28 :
105202: LD_ADDR_OWVAR 42
105206: PUSH
105207: LD_INT 33
105209: ST_TO_ADDR
105210: GO 105346
105212: LD_INT 28
105214: DOUBLE
105215: EQUAL
105216: IFTRUE 105220
105218: GO 105231
105220: POP
// bc_type := b_armoury ; 29 :
105221: LD_ADDR_OWVAR 42
105225: PUSH
105226: LD_INT 4
105228: ST_TO_ADDR
105229: GO 105346
105231: LD_INT 29
105233: DOUBLE
105234: EQUAL
105235: IFTRUE 105239
105237: GO 105250
105239: POP
// bc_type := b_barracks ; 30 :
105240: LD_ADDR_OWVAR 42
105244: PUSH
105245: LD_INT 5
105247: ST_TO_ADDR
105248: GO 105346
105250: LD_INT 30
105252: DOUBLE
105253: EQUAL
105254: IFTRUE 105258
105256: GO 105269
105258: POP
// bc_type := b_solar_power ; 31 :
105259: LD_ADDR_OWVAR 42
105263: PUSH
105264: LD_INT 27
105266: ST_TO_ADDR
105267: GO 105346
105269: LD_INT 31
105271: DOUBLE
105272: EQUAL
105273: IFTRUE 105277
105275: GO 105288
105277: POP
// bc_type := b_oil_power ; 32 :
105278: LD_ADDR_OWVAR 42
105282: PUSH
105283: LD_INT 26
105285: ST_TO_ADDR
105286: GO 105346
105288: LD_INT 32
105290: DOUBLE
105291: EQUAL
105292: IFTRUE 105296
105294: GO 105307
105296: POP
// bc_type := b_siberite_power ; 33 :
105297: LD_ADDR_OWVAR 42
105301: PUSH
105302: LD_INT 28
105304: ST_TO_ADDR
105305: GO 105346
105307: LD_INT 33
105309: DOUBLE
105310: EQUAL
105311: IFTRUE 105315
105313: GO 105326
105315: POP
// bc_type := b_oil_mine ; 34 :
105316: LD_ADDR_OWVAR 42
105320: PUSH
105321: LD_INT 29
105323: ST_TO_ADDR
105324: GO 105346
105326: LD_INT 34
105328: DOUBLE
105329: EQUAL
105330: IFTRUE 105334
105332: GO 105345
105334: POP
// bc_type := b_siberite_mine ; end ;
105335: LD_ADDR_OWVAR 42
105339: PUSH
105340: LD_INT 30
105342: ST_TO_ADDR
105343: GO 105346
105345: POP
// b := CreateAndPlaceBuildingXYD ( x , y , dir ) ;
105346: LD_ADDR_VAR 0 8
105350: PUSH
105351: LD_VAR 0 5
105355: PPUSH
105356: LD_VAR 0 6
105360: PPUSH
105361: LD_VAR 0 3
105365: PPUSH
105366: CALL_OW 47
105370: ST_TO_ADDR
// if bc_type in [ b_bunker , b_turret ] then
105371: LD_OWVAR 42
105375: PUSH
105376: LD_INT 32
105378: PUSH
105379: LD_INT 33
105381: PUSH
105382: EMPTY
105383: LIST
105384: LIST
105385: IN
105386: IFFALSE 105402
// PlaceWeaponTurret ( b , weapon ) ;
105388: LD_VAR 0 8
105392: PPUSH
105393: LD_VAR 0 4
105397: PPUSH
105398: CALL_OW 431
// end ;
105402: LD_VAR 0 7
105406: RET
// export function hHackUnlimitedResources ; var i , j , tmp ; begin
105407: LD_INT 0
105409: PPUSH
105410: PPUSH
105411: PPUSH
105412: PPUSH
// tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ] ) ;
105413: LD_ADDR_VAR 0 4
105417: PUSH
105418: LD_INT 22
105420: PUSH
105421: LD_OWVAR 2
105425: PUSH
105426: EMPTY
105427: LIST
105428: LIST
105429: PUSH
105430: LD_INT 2
105432: PUSH
105433: LD_INT 30
105435: PUSH
105436: LD_INT 0
105438: PUSH
105439: EMPTY
105440: LIST
105441: LIST
105442: PUSH
105443: LD_INT 30
105445: PUSH
105446: LD_INT 1
105448: PUSH
105449: EMPTY
105450: LIST
105451: LIST
105452: PUSH
105453: EMPTY
105454: LIST
105455: LIST
105456: LIST
105457: PUSH
105458: EMPTY
105459: LIST
105460: LIST
105461: PPUSH
105462: CALL_OW 69
105466: ST_TO_ADDR
// if not tmp then
105467: LD_VAR 0 4
105471: NOT
105472: IFFALSE 105476
// exit ;
105474: GO 105535
// for i in tmp do
105476: LD_ADDR_VAR 0 2
105480: PUSH
105481: LD_VAR 0 4
105485: PUSH
105486: FOR_IN
105487: IFFALSE 105533
// for j = 1 to 3 do
105489: LD_ADDR_VAR 0 3
105493: PUSH
105494: DOUBLE
105495: LD_INT 1
105497: DEC
105498: ST_TO_ADDR
105499: LD_INT 3
105501: PUSH
105502: FOR_TO
105503: IFFALSE 105529
// SetResourceType ( GetBase ( i ) , j , 99999 ) ;
105505: LD_VAR 0 2
105509: PPUSH
105510: CALL_OW 274
105514: PPUSH
105515: LD_VAR 0 3
105519: PPUSH
105520: LD_INT 99999
105522: PPUSH
105523: CALL_OW 277
105527: GO 105502
105529: POP
105530: POP
105531: GO 105486
105533: POP
105534: POP
// end ;
105535: LD_VAR 0 1
105539: RET
// export function hHackSetLevel10 ; var i , j ; begin
105540: LD_INT 0
105542: PPUSH
105543: PPUSH
105544: PPUSH
// for i in FilterAllUnits ( [ f_type , unit_human ] ) do
105545: LD_ADDR_VAR 0 2
105549: PUSH
105550: LD_INT 21
105552: PUSH
105553: LD_INT 1
105555: PUSH
105556: EMPTY
105557: LIST
105558: LIST
105559: PPUSH
105560: CALL_OW 69
105564: PUSH
105565: FOR_IN
105566: IFFALSE 105618
// if IsSelected ( i ) then
105568: LD_VAR 0 2
105572: PPUSH
105573: CALL_OW 306
105577: IFFALSE 105616
// begin for j := 1 to 4 do
105579: LD_ADDR_VAR 0 3
105583: PUSH
105584: DOUBLE
105585: LD_INT 1
105587: DEC
105588: ST_TO_ADDR
105589: LD_INT 4
105591: PUSH
105592: FOR_TO
105593: IFFALSE 105614
// SetSkill ( i , j , 10 ) ;
105595: LD_VAR 0 2
105599: PPUSH
105600: LD_VAR 0 3
105604: PPUSH
105605: LD_INT 10
105607: PPUSH
105608: CALL_OW 237
105612: GO 105592
105614: POP
105615: POP
// end ;
105616: GO 105565
105618: POP
105619: POP
// end ;
105620: LD_VAR 0 1
105624: RET
// export function hHackSetLevel10YourUnits ; var i , j ; begin
105625: LD_INT 0
105627: PPUSH
105628: PPUSH
105629: PPUSH
// for i in FilterAllUnits ( [ [ f_side , your_side ] , [ f_type , unit_human ] ] ) do
105630: LD_ADDR_VAR 0 2
105634: PUSH
105635: LD_INT 22
105637: PUSH
105638: LD_OWVAR 2
105642: PUSH
105643: EMPTY
105644: LIST
105645: LIST
105646: PUSH
105647: LD_INT 21
105649: PUSH
105650: LD_INT 1
105652: PUSH
105653: EMPTY
105654: LIST
105655: LIST
105656: PUSH
105657: EMPTY
105658: LIST
105659: LIST
105660: PPUSH
105661: CALL_OW 69
105665: PUSH
105666: FOR_IN
105667: IFFALSE 105708
// begin for j := 1 to 4 do
105669: LD_ADDR_VAR 0 3
105673: PUSH
105674: DOUBLE
105675: LD_INT 1
105677: DEC
105678: ST_TO_ADDR
105679: LD_INT 4
105681: PUSH
105682: FOR_TO
105683: IFFALSE 105704
// SetSkill ( i , j , 10 ) ;
105685: LD_VAR 0 2
105689: PPUSH
105690: LD_VAR 0 3
105694: PPUSH
105695: LD_INT 10
105697: PPUSH
105698: CALL_OW 237
105702: GO 105682
105704: POP
105705: POP
// end ;
105706: GO 105666
105708: POP
105709: POP
// end ;
105710: LD_VAR 0 1
105714: RET
// export function hHackSpawnHuman ( nation , class , skill , x , y ) ; begin
105715: LD_INT 0
105717: PPUSH
// uc_side := your_side ;
105718: LD_ADDR_OWVAR 20
105722: PUSH
105723: LD_OWVAR 2
105727: ST_TO_ADDR
// uc_nation := nation ;
105728: LD_ADDR_OWVAR 21
105732: PUSH
105733: LD_VAR 0 1
105737: ST_TO_ADDR
// InitHc ;
105738: CALL_OW 19
// PrepareHuman ( false , class , skill ) ;
105742: LD_INT 0
105744: PPUSH
105745: LD_VAR 0 2
105749: PPUSH
105750: LD_VAR 0 3
105754: PPUSH
105755: CALL_OW 380
// if HexInfo ( x , y ) = 0 then
105759: LD_VAR 0 4
105763: PPUSH
105764: LD_VAR 0 5
105768: PPUSH
105769: CALL_OW 428
105773: PUSH
105774: LD_INT 0
105776: EQUAL
105777: IFFALSE 105801
// PlaceUnitXY ( CreateHuman , x , y , true ) ;
105779: CALL_OW 44
105783: PPUSH
105784: LD_VAR 0 4
105788: PPUSH
105789: LD_VAR 0 5
105793: PPUSH
105794: LD_INT 1
105796: PPUSH
105797: CALL_OW 48
// end ;
105801: LD_VAR 0 6
105805: RET
// export function hHackSpawnVehicle ( chassis , engine , control , weapon , x , y ) ; var un ; begin
105806: LD_INT 0
105808: PPUSH
105809: PPUSH
// uc_side := your_side ;
105810: LD_ADDR_OWVAR 20
105814: PUSH
105815: LD_OWVAR 2
105819: ST_TO_ADDR
// if chassis in [ 1 , 2 , 3 , 4 , 5 ] then
105820: LD_VAR 0 1
105824: PUSH
105825: LD_INT 1
105827: PUSH
105828: LD_INT 2
105830: PUSH
105831: LD_INT 3
105833: PUSH
105834: LD_INT 4
105836: PUSH
105837: LD_INT 5
105839: PUSH
105840: EMPTY
105841: LIST
105842: LIST
105843: LIST
105844: LIST
105845: LIST
105846: IN
105847: IFFALSE 105859
// uc_nation := nation_american else
105849: LD_ADDR_OWVAR 21
105853: PUSH
105854: LD_INT 1
105856: ST_TO_ADDR
105857: GO 105902
// if chassis in [ 11 , 12 , 13 , 14 ] then
105859: LD_VAR 0 1
105863: PUSH
105864: LD_INT 11
105866: PUSH
105867: LD_INT 12
105869: PUSH
105870: LD_INT 13
105872: PUSH
105873: LD_INT 14
105875: PUSH
105876: EMPTY
105877: LIST
105878: LIST
105879: LIST
105880: LIST
105881: IN
105882: IFFALSE 105894
// uc_nation := nation_arabian else
105884: LD_ADDR_OWVAR 21
105888: PUSH
105889: LD_INT 2
105891: ST_TO_ADDR
105892: GO 105902
// uc_nation := nation_russian ;
105894: LD_ADDR_OWVAR 21
105898: PUSH
105899: LD_INT 3
105901: ST_TO_ADDR
// vc_chassis := chassis ;
105902: LD_ADDR_OWVAR 37
105906: PUSH
105907: LD_VAR 0 1
105911: ST_TO_ADDR
// vc_engine := engine ;
105912: LD_ADDR_OWVAR 39
105916: PUSH
105917: LD_VAR 0 2
105921: ST_TO_ADDR
// vc_control := control ;
105922: LD_ADDR_OWVAR 38
105926: PUSH
105927: LD_VAR 0 3
105931: ST_TO_ADDR
// vc_weapon := weapon ;
105932: LD_ADDR_OWVAR 40
105936: PUSH
105937: LD_VAR 0 4
105941: ST_TO_ADDR
// un := CreateVehicle ;
105942: LD_ADDR_VAR 0 8
105946: PUSH
105947: CALL_OW 45
105951: ST_TO_ADDR
// SetDir ( un , rand ( 0 , 5 ) ) ;
105952: LD_VAR 0 8
105956: PPUSH
105957: LD_INT 0
105959: PPUSH
105960: LD_INT 5
105962: PPUSH
105963: CALL_OW 12
105967: PPUSH
105968: CALL_OW 233
// PlaceUnitXY ( un , x , y , true ) ;
105972: LD_VAR 0 8
105976: PPUSH
105977: LD_VAR 0 5
105981: PPUSH
105982: LD_VAR 0 6
105986: PPUSH
105987: LD_INT 1
105989: PPUSH
105990: CALL_OW 48
// end ;
105994: LD_VAR 0 7
105998: RET
// export hInvincible ; every 1 do
105999: GO 106001
106001: DISABLE
// hInvincible := [ ] ;
106002: LD_ADDR_EXP 196
106006: PUSH
106007: EMPTY
106008: ST_TO_ADDR
106009: END
// every 10 do var i ;
106010: GO 106012
106012: DISABLE
106013: LD_INT 0
106015: PPUSH
// begin enable ;
106016: ENABLE
// if not hInvincible then
106017: LD_EXP 196
106021: NOT
106022: IFFALSE 106026
// exit ;
106024: GO 106070
// for i in hInvincible do
106026: LD_ADDR_VAR 0 1
106030: PUSH
106031: LD_EXP 196
106035: PUSH
106036: FOR_IN
106037: IFFALSE 106068
// if GetLives ( i ) < 1000 then
106039: LD_VAR 0 1
106043: PPUSH
106044: CALL_OW 256
106048: PUSH
106049: LD_INT 1000
106051: LESS
106052: IFFALSE 106066
// SetLives ( i , 1000 ) ;
106054: LD_VAR 0 1
106058: PPUSH
106059: LD_INT 1000
106061: PPUSH
106062: CALL_OW 234
106066: GO 106036
106068: POP
106069: POP
// end ;
106070: PPOPN 1
106072: END
// export function hHackInvincible ; var i ; begin
106073: LD_INT 0
106075: PPUSH
106076: PPUSH
// for i in FilterAllUnits ( [ f_or , [ f_type , unit_human ] , [ f_type , unit_vehicle ] ] ) do
106077: LD_ADDR_VAR 0 2
106081: PUSH
106082: LD_INT 2
106084: PUSH
106085: LD_INT 21
106087: PUSH
106088: LD_INT 1
106090: PUSH
106091: EMPTY
106092: LIST
106093: LIST
106094: PUSH
106095: LD_INT 21
106097: PUSH
106098: LD_INT 2
106100: PUSH
106101: EMPTY
106102: LIST
106103: LIST
106104: PUSH
106105: EMPTY
106106: LIST
106107: LIST
106108: LIST
106109: PPUSH
106110: CALL_OW 69
106114: PUSH
106115: FOR_IN
106116: IFFALSE 106177
// if IsSelected ( i ) then
106118: LD_VAR 0 2
106122: PPUSH
106123: CALL_OW 306
106127: IFFALSE 106175
// begin if i in hInvincible then
106129: LD_VAR 0 2
106133: PUSH
106134: LD_EXP 196
106138: IN
106139: IFFALSE 106159
// hInvincible := hInvincible diff i else
106141: LD_ADDR_EXP 196
106145: PUSH
106146: LD_EXP 196
106150: PUSH
106151: LD_VAR 0 2
106155: DIFF
106156: ST_TO_ADDR
106157: GO 106175
// hInvincible := hInvincible union i ;
106159: LD_ADDR_EXP 196
106163: PUSH
106164: LD_EXP 196
106168: PUSH
106169: LD_VAR 0 2
106173: UNION
106174: ST_TO_ADDR
// end ;
106175: GO 106115
106177: POP
106178: POP
// end ;
106179: LD_VAR 0 1
106183: RET
// export function hHackInvisible ; var i , j ; begin
106184: LD_INT 0
106186: PPUSH
106187: PPUSH
106188: PPUSH
// for i in FilterAllUnits ( [ f_type , unit_human ] ) do
106189: LD_ADDR_VAR 0 2
106193: PUSH
106194: LD_INT 21
106196: PUSH
106197: LD_INT 1
106199: PUSH
106200: EMPTY
106201: LIST
106202: LIST
106203: PPUSH
106204: CALL_OW 69
106208: PUSH
106209: FOR_IN
106210: IFFALSE 106234
// if IsSelected ( i ) then
106212: LD_VAR 0 2
106216: PPUSH
106217: CALL_OW 306
106221: IFFALSE 106232
// ComForceInvisible ( i ) ;
106223: LD_VAR 0 2
106227: PPUSH
106228: CALL_OW 496
106232: GO 106209
106234: POP
106235: POP
// end ;
106236: LD_VAR 0 1
106240: RET
// export function hHackChangeYourSide ; begin
106241: LD_INT 0
106243: PPUSH
// if your_side = 8 then
106244: LD_OWVAR 2
106248: PUSH
106249: LD_INT 8
106251: EQUAL
106252: IFFALSE 106264
// your_side := 0 else
106254: LD_ADDR_OWVAR 2
106258: PUSH
106259: LD_INT 0
106261: ST_TO_ADDR
106262: GO 106278
// your_side := your_side + 1 ;
106264: LD_ADDR_OWVAR 2
106268: PUSH
106269: LD_OWVAR 2
106273: PUSH
106274: LD_INT 1
106276: PLUS
106277: ST_TO_ADDR
// end ;
106278: LD_VAR 0 1
106282: RET
// export function hHackChangeUnitSide ; var i , j ; begin
106283: LD_INT 0
106285: PPUSH
106286: PPUSH
106287: PPUSH
// for i in all_units do
106288: LD_ADDR_VAR 0 2
106292: PUSH
106293: LD_OWVAR 3
106297: PUSH
106298: FOR_IN
106299: IFFALSE 106377
// if IsSelected ( i ) then
106301: LD_VAR 0 2
106305: PPUSH
106306: CALL_OW 306
106310: IFFALSE 106375
// begin j := GetSide ( i ) ;
106312: LD_ADDR_VAR 0 3
106316: PUSH
106317: LD_VAR 0 2
106321: PPUSH
106322: CALL_OW 255
106326: ST_TO_ADDR
// if j = 8 then
106327: LD_VAR 0 3
106331: PUSH
106332: LD_INT 8
106334: EQUAL
106335: IFFALSE 106347
// j := 0 else
106337: LD_ADDR_VAR 0 3
106341: PUSH
106342: LD_INT 0
106344: ST_TO_ADDR
106345: GO 106361
// j := j + 1 ;
106347: LD_ADDR_VAR 0 3
106351: PUSH
106352: LD_VAR 0 3
106356: PUSH
106357: LD_INT 1
106359: PLUS
106360: ST_TO_ADDR
// SetSide ( i , j ) ;
106361: LD_VAR 0 2
106365: PPUSH
106366: LD_VAR 0 3
106370: PPUSH
106371: CALL_OW 235
// end ;
106375: GO 106298
106377: POP
106378: POP
// end ;
106379: LD_VAR 0 1
106383: RET
// export function hHackFog ; begin
106384: LD_INT 0
106386: PPUSH
// FogOff ( true ) ;
106387: LD_INT 1
106389: PPUSH
106390: CALL_OW 344
// end ;
106394: LD_VAR 0 1
106398: RET
// export function hHackTeleport ( unit , x , y ) ; begin
106399: LD_INT 0
106401: PPUSH
// TeleportUnit ( unit , x , y , 1 , true ) ;
106402: LD_VAR 0 1
106406: PPUSH
106407: LD_VAR 0 2
106411: PPUSH
106412: LD_VAR 0 3
106416: PPUSH
106417: LD_INT 1
106419: PPUSH
106420: LD_INT 1
106422: PPUSH
106423: CALL_OW 483
// CenterOnXY ( x , y ) ;
106427: LD_VAR 0 2
106431: PPUSH
106432: LD_VAR 0 3
106436: PPUSH
106437: CALL_OW 84
// end ; end_of_file
106441: LD_VAR 0 4
106445: RET
// export function SOS_UnitDestroyed ( un ) ; var i , eff , side ; begin
106446: LD_INT 0
106448: PPUSH
106449: PPUSH
106450: PPUSH
106451: PPUSH
// if GetWeapon ( un ) = ar_bio_bomb then
106452: LD_VAR 0 1
106456: PPUSH
106457: CALL_OW 264
106461: PUSH
106462: LD_EXP 78
106466: EQUAL
106467: IFFALSE 106539
// begin if GetTech ( tech_bio3 , GetSide ( un ) ) = state_researched then
106469: LD_INT 68
106471: PPUSH
106472: LD_VAR 0 1
106476: PPUSH
106477: CALL_OW 255
106481: PPUSH
106482: CALL_OW 321
106486: PUSH
106487: LD_INT 2
106489: EQUAL
106490: IFFALSE 106502
// eff := 70 else
106492: LD_ADDR_VAR 0 4
106496: PUSH
106497: LD_INT 70
106499: ST_TO_ADDR
106500: GO 106510
// eff := 30 ;
106502: LD_ADDR_VAR 0 4
106506: PUSH
106507: LD_INT 30
106509: ST_TO_ADDR
// ArtContamination ( GetX ( un ) , GetY ( un ) , eff ) ;
106510: LD_VAR 0 1
106514: PPUSH
106515: CALL_OW 250
106519: PPUSH
106520: LD_VAR 0 1
106524: PPUSH
106525: CALL_OW 251
106529: PPUSH
106530: LD_VAR 0 4
106534: PPUSH
106535: CALL_OW 495
// end ; end ;
106539: LD_VAR 0 2
106543: RET
// export function SOS_UnitExtraDestroyed ( un , killerSide , killerUnit ) ; begin
106544: LD_INT 0
106546: PPUSH
// end ;
106547: LD_VAR 0 4
106551: RET
// export function SOS_Command ( cmd ) ; begin
106552: LD_INT 0
106554: PPUSH
// end ;
106555: LD_VAR 0 2
106559: RET
// export function SOS_CommandUnitXY ( cmd , un , target , x , y ) ; begin
106560: LD_INT 0
106562: PPUSH
// end ;
106563: LD_VAR 0 6
106567: RET
// export function SOS_VehicleConstructed ( vehicle , factory ) ; var driver ; begin
106568: LD_INT 0
106570: PPUSH
106571: PPUSH
// if not vehicle or not factory then
106572: LD_VAR 0 1
106576: NOT
106577: PUSH
106578: LD_VAR 0 2
106582: NOT
106583: OR
106584: IFFALSE 106588
// exit ;
106586: GO 106819
// if factoryWaypoints >= factory then
106588: LD_EXP 197
106592: PUSH
106593: LD_VAR 0 2
106597: GREATEREQUAL
106598: IFFALSE 106819
// if factoryWaypoints [ factory ] then
106600: LD_EXP 197
106604: PUSH
106605: LD_VAR 0 2
106609: ARRAY
106610: IFFALSE 106819
// begin if GetControl ( vehicle ) = control_manual then
106612: LD_VAR 0 1
106616: PPUSH
106617: CALL_OW 263
106621: PUSH
106622: LD_INT 1
106624: EQUAL
106625: IFFALSE 106706
// begin driver := IsDrivenBy ( vehicle ) ;
106627: LD_ADDR_VAR 0 4
106631: PUSH
106632: LD_VAR 0 1
106636: PPUSH
106637: CALL_OW 311
106641: ST_TO_ADDR
// AddComMoveXY ( driver , factoryWaypoints [ factory ] [ 1 ] , factoryWaypoints [ factory ] [ 2 ] ) ;
106642: LD_VAR 0 4
106646: PPUSH
106647: LD_EXP 197
106651: PUSH
106652: LD_VAR 0 2
106656: ARRAY
106657: PUSH
106658: LD_INT 1
106660: ARRAY
106661: PPUSH
106662: LD_EXP 197
106666: PUSH
106667: LD_VAR 0 2
106671: ARRAY
106672: PUSH
106673: LD_INT 2
106675: ARRAY
106676: PPUSH
106677: CALL_OW 171
// AddComExitVehicle ( driver ) ;
106681: LD_VAR 0 4
106685: PPUSH
106686: CALL_OW 181
// AddComEnterUnit ( driver , factory ) ;
106690: LD_VAR 0 4
106694: PPUSH
106695: LD_VAR 0 2
106699: PPUSH
106700: CALL_OW 180
// end else
106704: GO 106819
// if GetControl ( vehicle ) = control_remote then
106706: LD_VAR 0 1
106710: PPUSH
106711: CALL_OW 263
106715: PUSH
106716: LD_INT 2
106718: EQUAL
106719: IFFALSE 106780
// begin wait ( 0 0$2 ) ;
106721: LD_INT 70
106723: PPUSH
106724: CALL_OW 67
// if Connect ( vehicle ) then
106728: LD_VAR 0 1
106732: PPUSH
106733: CALL 59983 0 1
106737: IFFALSE 106778
// AddComMoveXY ( vehicle , factoryWaypoints [ factory ] [ 1 ] , factoryWaypoints [ factory ] [ 2 ] ) ;
106739: LD_VAR 0 1
106743: PPUSH
106744: LD_EXP 197
106748: PUSH
106749: LD_VAR 0 2
106753: ARRAY
106754: PUSH
106755: LD_INT 1
106757: ARRAY
106758: PPUSH
106759: LD_EXP 197
106763: PUSH
106764: LD_VAR 0 2
106768: ARRAY
106769: PUSH
106770: LD_INT 2
106772: ARRAY
106773: PPUSH
106774: CALL_OW 171
// end else
106778: GO 106819
// AddComMoveXY ( vehicle , factoryWaypoints [ factory ] [ 1 ] , factoryWaypoints [ factory ] [ 2 ] ) ;
106780: LD_VAR 0 1
106784: PPUSH
106785: LD_EXP 197
106789: PUSH
106790: LD_VAR 0 2
106794: ARRAY
106795: PUSH
106796: LD_INT 1
106798: ARRAY
106799: PPUSH
106800: LD_EXP 197
106804: PUSH
106805: LD_VAR 0 2
106809: ARRAY
106810: PUSH
106811: LD_INT 2
106813: ARRAY
106814: PPUSH
106815: CALL_OW 171
// end ; end ;
106819: LD_VAR 0 3
106823: RET
// export function SOS_TargetableSAIL ( cmd , unit , selectedUnit , x , y ) ; begin
106824: LD_INT 0
106826: PPUSH
// if cmd = 250 and GetWeapon ( unit ) = ar_miner then
106827: LD_VAR 0 1
106831: PUSH
106832: LD_INT 250
106834: EQUAL
106835: PUSH
106836: LD_VAR 0 2
106840: PPUSH
106841: CALL_OW 264
106845: PUSH
106846: LD_EXP 81
106850: EQUAL
106851: AND
106852: IFFALSE 106873
// MinerPlaceMine ( unit , x , y ) ;
106854: LD_VAR 0 2
106858: PPUSH
106859: LD_VAR 0 4
106863: PPUSH
106864: LD_VAR 0 5
106868: PPUSH
106869: CALL 109601 0 3
// if cmd = 251 and GetWeapon ( unit ) = ar_miner then
106873: LD_VAR 0 1
106877: PUSH
106878: LD_INT 251
106880: EQUAL
106881: PUSH
106882: LD_VAR 0 2
106886: PPUSH
106887: CALL_OW 264
106891: PUSH
106892: LD_EXP 81
106896: EQUAL
106897: AND
106898: IFFALSE 106919
// MinerDetonateMine ( unit , x , y ) ;
106900: LD_VAR 0 2
106904: PPUSH
106905: LD_VAR 0 4
106909: PPUSH
106910: LD_VAR 0 5
106914: PPUSH
106915: CALL 109878 0 3
// if cmd = 252 and GetWeapon ( unit ) = ar_miner then
106919: LD_VAR 0 1
106923: PUSH
106924: LD_INT 252
106926: EQUAL
106927: PUSH
106928: LD_VAR 0 2
106932: PPUSH
106933: CALL_OW 264
106937: PUSH
106938: LD_EXP 81
106942: EQUAL
106943: AND
106944: IFFALSE 106965
// MinerCreateMinefield ( unit , x , y ) ;
106946: LD_VAR 0 2
106950: PPUSH
106951: LD_VAR 0 4
106955: PPUSH
106956: LD_VAR 0 5
106960: PPUSH
106961: CALL 110295 0 3
// if cmd = 253 and GetClass ( unit ) = class_sniper then
106965: LD_VAR 0 1
106969: PUSH
106970: LD_INT 253
106972: EQUAL
106973: PUSH
106974: LD_VAR 0 2
106978: PPUSH
106979: CALL_OW 257
106983: PUSH
106984: LD_INT 5
106986: EQUAL
106987: AND
106988: IFFALSE 107009
// ComBinocular ( unit , x , y ) ;
106990: LD_VAR 0 2
106994: PPUSH
106995: LD_VAR 0 4
106999: PPUSH
107000: LD_VAR 0 5
107004: PPUSH
107005: CALL 110666 0 3
// if cmd = 254 and GetWeapon ( unit ) = us_hack and GetControl ( selectedUnit ) = control_computer then
107009: LD_VAR 0 1
107013: PUSH
107014: LD_INT 254
107016: EQUAL
107017: PUSH
107018: LD_VAR 0 2
107022: PPUSH
107023: CALL_OW 264
107027: PUSH
107028: LD_EXP 76
107032: EQUAL
107033: AND
107034: PUSH
107035: LD_VAR 0 3
107039: PPUSH
107040: CALL_OW 263
107044: PUSH
107045: LD_INT 3
107047: EQUAL
107048: AND
107049: IFFALSE 107065
// HackDestroyVehicle ( unit , selectedUnit ) ;
107051: LD_VAR 0 2
107055: PPUSH
107056: LD_VAR 0 3
107060: PPUSH
107061: CALL 108961 0 2
// if cmd = 255 and GetWeapon ( unit ) in [ us_bulldozer , ru_bulldozer ] and ValidHex ( x , y ) then
107065: LD_VAR 0 1
107069: PUSH
107070: LD_INT 255
107072: EQUAL
107073: PUSH
107074: LD_VAR 0 2
107078: PPUSH
107079: CALL_OW 264
107083: PUSH
107084: LD_INT 14
107086: PUSH
107087: LD_INT 53
107089: PUSH
107090: EMPTY
107091: LIST
107092: LIST
107093: IN
107094: AND
107095: PUSH
107096: LD_VAR 0 4
107100: PPUSH
107101: LD_VAR 0 5
107105: PPUSH
107106: CALL_OW 488
107110: AND
107111: IFFALSE 107135
// CutTreeXYR ( unit , x , y , 12 ) ;
107113: LD_VAR 0 2
107117: PPUSH
107118: LD_VAR 0 4
107122: PPUSH
107123: LD_VAR 0 5
107127: PPUSH
107128: LD_INT 12
107130: PPUSH
107131: CALL 107527 0 4
// if cmd = 256 then
107135: LD_VAR 0 1
107139: PUSH
107140: LD_INT 256
107142: EQUAL
107143: IFFALSE 107164
// SetFactoryWaypoint ( unit , x , y ) ;
107145: LD_VAR 0 2
107149: PPUSH
107150: LD_VAR 0 4
107154: PPUSH
107155: LD_VAR 0 5
107159: PPUSH
107160: CALL 107169 0 3
// end ;
107164: LD_VAR 0 6
107168: RET
// export factoryWaypoints ; export function SetFactoryWaypoint ( factory , x , y ) ; var i ; begin
107169: LD_INT 0
107171: PPUSH
107172: PPUSH
// if not factory or not ValidHex ( x , y ) or ( GetBType ( factory ) <> b_factory and not GetType ( factory ) = unit_human ) then
107173: LD_VAR 0 1
107177: NOT
107178: PUSH
107179: LD_VAR 0 2
107183: PPUSH
107184: LD_VAR 0 3
107188: PPUSH
107189: CALL_OW 488
107193: NOT
107194: OR
107195: PUSH
107196: LD_VAR 0 1
107200: PPUSH
107201: CALL_OW 266
107205: PUSH
107206: LD_INT 3
107208: NONEQUAL
107209: PUSH
107210: LD_VAR 0 1
107214: PPUSH
107215: CALL_OW 247
107219: PUSH
107220: LD_INT 1
107222: EQUAL
107223: NOT
107224: AND
107225: OR
107226: IFFALSE 107230
// exit ;
107228: GO 107379
// if GetType ( factory ) = unit_human then
107230: LD_VAR 0 1
107234: PPUSH
107235: CALL_OW 247
107239: PUSH
107240: LD_INT 1
107242: EQUAL
107243: IFFALSE 107260
// factory := IsInUnit ( factory ) ;
107245: LD_ADDR_VAR 0 1
107249: PUSH
107250: LD_VAR 0 1
107254: PPUSH
107255: CALL_OW 310
107259: ST_TO_ADDR
// if GetBType ( factory ) <> b_factory then
107260: LD_VAR 0 1
107264: PPUSH
107265: CALL_OW 266
107269: PUSH
107270: LD_INT 3
107272: NONEQUAL
107273: IFFALSE 107277
// exit ;
107275: GO 107379
// if HexInfo ( x , y ) = factory then
107277: LD_VAR 0 2
107281: PPUSH
107282: LD_VAR 0 3
107286: PPUSH
107287: CALL_OW 428
107291: PUSH
107292: LD_VAR 0 1
107296: EQUAL
107297: IFFALSE 107324
// factoryWaypoints := Replace ( factoryWaypoints , factory , 0 ) else
107299: LD_ADDR_EXP 197
107303: PUSH
107304: LD_EXP 197
107308: PPUSH
107309: LD_VAR 0 1
107313: PPUSH
107314: LD_INT 0
107316: PPUSH
107317: CALL_OW 1
107321: ST_TO_ADDR
107322: GO 107375
// factoryWaypoints := Replace ( factoryWaypoints , factory , [ GetSide ( factory ) , factory , x , y ] ) ;
107324: LD_ADDR_EXP 197
107328: PUSH
107329: LD_EXP 197
107333: PPUSH
107334: LD_VAR 0 1
107338: PPUSH
107339: LD_VAR 0 1
107343: PPUSH
107344: CALL_OW 255
107348: PUSH
107349: LD_VAR 0 1
107353: PUSH
107354: LD_VAR 0 2
107358: PUSH
107359: LD_VAR 0 3
107363: PUSH
107364: EMPTY
107365: LIST
107366: LIST
107367: LIST
107368: LIST
107369: PPUSH
107370: CALL_OW 1
107374: ST_TO_ADDR
// UpdateFactoryWaypoints ;
107375: CALL 107384 0 0
// end ;
107379: LD_VAR 0 4
107383: RET
// export function UpdateFactoryWaypoints ( ) ; var i ; begin
107384: LD_INT 0
107386: PPUSH
107387: PPUSH
// ToLua ( resetFactoryWaypoint(); ) ;
107388: LD_STRING resetFactoryWaypoint();
107390: PPUSH
107391: CALL_OW 559
// if factoryWaypoints then
107395: LD_EXP 197
107399: IFFALSE 107522
// begin for i := 1 to factoryWaypoints do
107401: LD_ADDR_VAR 0 2
107405: PUSH
107406: DOUBLE
107407: LD_INT 1
107409: DEC
107410: ST_TO_ADDR
107411: LD_EXP 197
107415: PUSH
107416: FOR_TO
107417: IFFALSE 107520
// if factoryWaypoints [ i ] then
107419: LD_EXP 197
107423: PUSH
107424: LD_VAR 0 2
107428: ARRAY
107429: IFFALSE 107518
// ToLua ( setFactoryWaypointXY( & factoryWaypoints [ i ] [ 1 ] & , & factoryWaypoints [ i ] [ 2 ] & , & factoryWaypoints [ i ] [ 3 ] & , & factoryWaypoints [ i ] [ 4 ] & ) ) ;
107431: LD_STRING setFactoryWaypointXY(
107433: PUSH
107434: LD_EXP 197
107438: PUSH
107439: LD_VAR 0 2
107443: ARRAY
107444: PUSH
107445: LD_INT 1
107447: ARRAY
107448: STR
107449: PUSH
107450: LD_STRING ,
107452: STR
107453: PUSH
107454: LD_EXP 197
107458: PUSH
107459: LD_VAR 0 2
107463: ARRAY
107464: PUSH
107465: LD_INT 2
107467: ARRAY
107468: STR
107469: PUSH
107470: LD_STRING ,
107472: STR
107473: PUSH
107474: LD_EXP 197
107478: PUSH
107479: LD_VAR 0 2
107483: ARRAY
107484: PUSH
107485: LD_INT 3
107487: ARRAY
107488: STR
107489: PUSH
107490: LD_STRING ,
107492: STR
107493: PUSH
107494: LD_EXP 197
107498: PUSH
107499: LD_VAR 0 2
107503: ARRAY
107504: PUSH
107505: LD_INT 4
107507: ARRAY
107508: STR
107509: PUSH
107510: LD_STRING )
107512: STR
107513: PPUSH
107514: CALL_OW 559
107518: GO 107416
107520: POP
107521: POP
// end ; end ;
107522: LD_VAR 0 1
107526: RET
// function CutTreeXYR ( bulldozer , x , y , r ) ; var i , min_x , min_y , max_x , max_y , _x , _y , list ; begin
107527: LD_INT 0
107529: PPUSH
107530: PPUSH
107531: PPUSH
107532: PPUSH
107533: PPUSH
107534: PPUSH
107535: PPUSH
107536: PPUSH
107537: PPUSH
// if not bulldozer or not ValidHex ( x , y ) or not r then
107538: LD_VAR 0 1
107542: NOT
107543: PUSH
107544: LD_VAR 0 2
107548: PPUSH
107549: LD_VAR 0 3
107553: PPUSH
107554: CALL_OW 488
107558: NOT
107559: OR
107560: PUSH
107561: LD_VAR 0 4
107565: NOT
107566: OR
107567: IFFALSE 107571
// exit ;
107569: GO 107911
// list := [ ] ;
107571: LD_ADDR_VAR 0 13
107575: PUSH
107576: EMPTY
107577: ST_TO_ADDR
// if x - r < 0 then
107578: LD_VAR 0 2
107582: PUSH
107583: LD_VAR 0 4
107587: MINUS
107588: PUSH
107589: LD_INT 0
107591: LESS
107592: IFFALSE 107604
// min_x := 0 else
107594: LD_ADDR_VAR 0 7
107598: PUSH
107599: LD_INT 0
107601: ST_TO_ADDR
107602: GO 107620
// min_x := x - r ;
107604: LD_ADDR_VAR 0 7
107608: PUSH
107609: LD_VAR 0 2
107613: PUSH
107614: LD_VAR 0 4
107618: MINUS
107619: ST_TO_ADDR
// if y - r < 0 then
107620: LD_VAR 0 3
107624: PUSH
107625: LD_VAR 0 4
107629: MINUS
107630: PUSH
107631: LD_INT 0
107633: LESS
107634: IFFALSE 107646
// min_y := 0 else
107636: LD_ADDR_VAR 0 8
107640: PUSH
107641: LD_INT 0
107643: ST_TO_ADDR
107644: GO 107662
// min_y := y - r ;
107646: LD_ADDR_VAR 0 8
107650: PUSH
107651: LD_VAR 0 3
107655: PUSH
107656: LD_VAR 0 4
107660: MINUS
107661: ST_TO_ADDR
// max_x := x + r ;
107662: LD_ADDR_VAR 0 9
107666: PUSH
107667: LD_VAR 0 2
107671: PUSH
107672: LD_VAR 0 4
107676: PLUS
107677: ST_TO_ADDR
// max_y := y + r ;
107678: LD_ADDR_VAR 0 10
107682: PUSH
107683: LD_VAR 0 3
107687: PUSH
107688: LD_VAR 0 4
107692: PLUS
107693: ST_TO_ADDR
// for _x = min_x to max_x do
107694: LD_ADDR_VAR 0 11
107698: PUSH
107699: DOUBLE
107700: LD_VAR 0 7
107704: DEC
107705: ST_TO_ADDR
107706: LD_VAR 0 9
107710: PUSH
107711: FOR_TO
107712: IFFALSE 107829
// for _y = min_y to max_y do
107714: LD_ADDR_VAR 0 12
107718: PUSH
107719: DOUBLE
107720: LD_VAR 0 8
107724: DEC
107725: ST_TO_ADDR
107726: LD_VAR 0 10
107730: PUSH
107731: FOR_TO
107732: IFFALSE 107825
// begin if not ValidHex ( _x , _y ) then
107734: LD_VAR 0 11
107738: PPUSH
107739: LD_VAR 0 12
107743: PPUSH
107744: CALL_OW 488
107748: NOT
107749: IFFALSE 107753
// continue ;
107751: GO 107731
// if IsEnvironment ( _x , _y ) and IsEnvironmentDestroyable ( _x , _y ) then
107753: LD_VAR 0 11
107757: PPUSH
107758: LD_VAR 0 12
107762: PPUSH
107763: CALL_OW 351
107767: PUSH
107768: LD_VAR 0 11
107772: PPUSH
107773: LD_VAR 0 12
107777: PPUSH
107778: CALL_OW 554
107782: AND
107783: IFFALSE 107823
// list := Insert ( list , list + 1 , [ _x , _y ] ) ;
107785: LD_ADDR_VAR 0 13
107789: PUSH
107790: LD_VAR 0 13
107794: PPUSH
107795: LD_VAR 0 13
107799: PUSH
107800: LD_INT 1
107802: PLUS
107803: PPUSH
107804: LD_VAR 0 11
107808: PUSH
107809: LD_VAR 0 12
107813: PUSH
107814: EMPTY
107815: LIST
107816: LIST
107817: PPUSH
107818: CALL_OW 2
107822: ST_TO_ADDR
// end ;
107823: GO 107731
107825: POP
107826: POP
107827: GO 107711
107829: POP
107830: POP
// if not list then
107831: LD_VAR 0 13
107835: NOT
107836: IFFALSE 107840
// exit ;
107838: GO 107911
// for i in list do
107840: LD_ADDR_VAR 0 6
107844: PUSH
107845: LD_VAR 0 13
107849: PUSH
107850: FOR_IN
107851: IFFALSE 107909
// AddTaskList ( bulldozer , [ [ M , i [ 1 ] , i [ 2 ] , 0 , 0 , 0 , 0 ] ] ) ;
107853: LD_VAR 0 1
107857: PPUSH
107858: LD_STRING M
107860: PUSH
107861: LD_VAR 0 6
107865: PUSH
107866: LD_INT 1
107868: ARRAY
107869: PUSH
107870: LD_VAR 0 6
107874: PUSH
107875: LD_INT 2
107877: ARRAY
107878: PUSH
107879: LD_INT 0
107881: PUSH
107882: LD_INT 0
107884: PUSH
107885: LD_INT 0
107887: PUSH
107888: LD_INT 0
107890: PUSH
107891: EMPTY
107892: LIST
107893: LIST
107894: LIST
107895: LIST
107896: LIST
107897: LIST
107898: LIST
107899: PUSH
107900: EMPTY
107901: LIST
107902: PPUSH
107903: CALL_OW 447
107907: GO 107850
107909: POP
107910: POP
// end ;
107911: LD_VAR 0 5
107915: RET
// export initHack , hackTanks , hackTanksCaptured , hackLimit , hackDist , hackCounter ; every 0 0$1 trigger not initHack do
107916: LD_EXP 198
107920: NOT
107921: IFFALSE 107971
107923: GO 107925
107925: DISABLE
// begin initHack := true ;
107926: LD_ADDR_EXP 198
107930: PUSH
107931: LD_INT 1
107933: ST_TO_ADDR
// hackTanks := [ ] ;
107934: LD_ADDR_EXP 199
107938: PUSH
107939: EMPTY
107940: ST_TO_ADDR
// hackTanksCaptured := [ ] ;
107941: LD_ADDR_EXP 200
107945: PUSH
107946: EMPTY
107947: ST_TO_ADDR
// hackLimit := 3 ;
107948: LD_ADDR_EXP 201
107952: PUSH
107953: LD_INT 3
107955: ST_TO_ADDR
// hackDist := 12 ;
107956: LD_ADDR_EXP 202
107960: PUSH
107961: LD_INT 12
107963: ST_TO_ADDR
// hackCounter := [ ] ;
107964: LD_ADDR_EXP 203
107968: PUSH
107969: EMPTY
107970: ST_TO_ADDR
// end ;
107971: END
// every 0 0$1 trigger initHack and FilterAllUnits ( [ f_weapon , us_hack ] ) do var i , tmp ;
107972: LD_EXP 198
107976: PUSH
107977: LD_INT 34
107979: PUSH
107980: LD_EXP 76
107984: PUSH
107985: EMPTY
107986: LIST
107987: LIST
107988: PPUSH
107989: CALL_OW 69
107993: AND
107994: IFFALSE 108249
107996: GO 107998
107998: DISABLE
107999: LD_INT 0
108001: PPUSH
108002: PPUSH
// begin enable ;
108003: ENABLE
// for i in FilterAllUnits ( [ f_weapon , us_hack ] ) do
108004: LD_ADDR_VAR 0 1
108008: PUSH
108009: LD_INT 34
108011: PUSH
108012: LD_EXP 76
108016: PUSH
108017: EMPTY
108018: LIST
108019: LIST
108020: PPUSH
108021: CALL_OW 69
108025: PUSH
108026: FOR_IN
108027: IFFALSE 108247
// begin if not i in hackTanks then
108029: LD_VAR 0 1
108033: PUSH
108034: LD_EXP 199
108038: IN
108039: NOT
108040: IFFALSE 108123
// begin hackTanks := Replace ( hackTanks , hackTanks + 1 , i ) ;
108042: LD_ADDR_EXP 199
108046: PUSH
108047: LD_EXP 199
108051: PPUSH
108052: LD_EXP 199
108056: PUSH
108057: LD_INT 1
108059: PLUS
108060: PPUSH
108061: LD_VAR 0 1
108065: PPUSH
108066: CALL_OW 1
108070: ST_TO_ADDR
// hackTanksCaptured := Replace ( hackTanksCaptured , hackTanksCaptured + 1 , [ ] ) ;
108071: LD_ADDR_EXP 200
108075: PUSH
108076: LD_EXP 200
108080: PPUSH
108081: LD_EXP 200
108085: PUSH
108086: LD_INT 1
108088: PLUS
108089: PPUSH
108090: EMPTY
108091: PPUSH
108092: CALL_OW 1
108096: ST_TO_ADDR
// hackCounter := Replace ( hackCounter , hackCounter + 1 , [ ] ) ;
108097: LD_ADDR_EXP 203
108101: PUSH
108102: LD_EXP 203
108106: PPUSH
108107: LD_EXP 203
108111: PUSH
108112: LD_INT 1
108114: PLUS
108115: PPUSH
108116: EMPTY
108117: PPUSH
108118: CALL_OW 1
108122: ST_TO_ADDR
// end ; if not IsOk ( i ) then
108123: LD_VAR 0 1
108127: PPUSH
108128: CALL_OW 302
108132: NOT
108133: IFFALSE 108146
// begin HackUnlinkAll ( i ) ;
108135: LD_VAR 0 1
108139: PPUSH
108140: CALL 108252 0 1
// continue ;
108144: GO 108026
// end ; HackCheckCapturedStatus ( i ) ;
108146: LD_VAR 0 1
108150: PPUSH
108151: CALL 108695 0 1
// tmp := FilterAllUnits ( [ [ f_enemy , GetSide ( i ) ] , [ f_control , control_computer ] , [ f_dist , i , hackDist ] , [ f_ok ] ] ) ;
108155: LD_ADDR_VAR 0 2
108159: PUSH
108160: LD_INT 81
108162: PUSH
108163: LD_VAR 0 1
108167: PPUSH
108168: CALL_OW 255
108172: PUSH
108173: EMPTY
108174: LIST
108175: LIST
108176: PUSH
108177: LD_INT 33
108179: PUSH
108180: LD_INT 3
108182: PUSH
108183: EMPTY
108184: LIST
108185: LIST
108186: PUSH
108187: LD_INT 91
108189: PUSH
108190: LD_VAR 0 1
108194: PUSH
108195: LD_EXP 202
108199: PUSH
108200: EMPTY
108201: LIST
108202: LIST
108203: LIST
108204: PUSH
108205: LD_INT 50
108207: PUSH
108208: EMPTY
108209: LIST
108210: PUSH
108211: EMPTY
108212: LIST
108213: LIST
108214: LIST
108215: LIST
108216: PPUSH
108217: CALL_OW 69
108221: ST_TO_ADDR
// if not tmp then
108222: LD_VAR 0 2
108226: NOT
108227: IFFALSE 108231
// continue ;
108229: GO 108026
// HackLink ( i , tmp ) ;
108231: LD_VAR 0 1
108235: PPUSH
108236: LD_VAR 0 2
108240: PPUSH
108241: CALL 108388 0 2
// end ;
108245: GO 108026
108247: POP
108248: POP
// end ;
108249: PPOPN 2
108251: END
// function HackUnlinkAll ( hack ) ; var i , index ; begin
108252: LD_INT 0
108254: PPUSH
108255: PPUSH
108256: PPUSH
// if not hack in hackTanks then
108257: LD_VAR 0 1
108261: PUSH
108262: LD_EXP 199
108266: IN
108267: NOT
108268: IFFALSE 108272
// exit ;
108270: GO 108383
// index := GetElementIndex ( hackTanks , hack ) ;
108272: LD_ADDR_VAR 0 4
108276: PUSH
108277: LD_EXP 199
108281: PPUSH
108282: LD_VAR 0 1
108286: PPUSH
108287: CALL 56797 0 2
108291: ST_TO_ADDR
// if hackTanksCaptured [ index ] then
108292: LD_EXP 200
108296: PUSH
108297: LD_VAR 0 4
108301: ARRAY
108302: IFFALSE 108383
// begin for i in hackTanksCaptured [ index ] do
108304: LD_ADDR_VAR 0 3
108308: PUSH
108309: LD_EXP 200
108313: PUSH
108314: LD_VAR 0 4
108318: ARRAY
108319: PUSH
108320: FOR_IN
108321: IFFALSE 108347
// SetSide ( i [ 1 ] , i [ 2 ] ) ;
108323: LD_VAR 0 3
108327: PUSH
108328: LD_INT 1
108330: ARRAY
108331: PPUSH
108332: LD_VAR 0 3
108336: PUSH
108337: LD_INT 2
108339: ARRAY
108340: PPUSH
108341: CALL_OW 235
108345: GO 108320
108347: POP
108348: POP
// hackTanksCaptured := Replace ( hackTanksCaptured , index , [ ] ) ;
108349: LD_ADDR_EXP 200
108353: PUSH
108354: LD_EXP 200
108358: PPUSH
108359: LD_VAR 0 4
108363: PPUSH
108364: EMPTY
108365: PPUSH
108366: CALL_OW 1
108370: ST_TO_ADDR
// SetUnitDisplayNumber ( hack , 0 ) ;
108371: LD_VAR 0 1
108375: PPUSH
108376: LD_INT 0
108378: PPUSH
108379: CALL_OW 505
// end ; end ;
108383: LD_VAR 0 2
108387: RET
// function HackLink ( hack , vehicles ) ; var i , index ; begin
108388: LD_INT 0
108390: PPUSH
108391: PPUSH
108392: PPUSH
// if not hack in hackTanks or not vehicles then
108393: LD_VAR 0 1
108397: PUSH
108398: LD_EXP 199
108402: IN
108403: NOT
108404: PUSH
108405: LD_VAR 0 2
108409: NOT
108410: OR
108411: IFFALSE 108415
// exit ;
108413: GO 108690
// vehicles := SortByDistanceUnit ( hack , vehicles , true , true ) ;
108415: LD_ADDR_VAR 0 2
108419: PUSH
108420: LD_VAR 0 1
108424: PPUSH
108425: LD_VAR 0 2
108429: PPUSH
108430: LD_INT 1
108432: PPUSH
108433: LD_INT 1
108435: PPUSH
108436: CALL 57447 0 4
108440: ST_TO_ADDR
// index := GetElementIndex ( hackTanks , hack ) ;
108441: LD_ADDR_VAR 0 5
108445: PUSH
108446: LD_EXP 199
108450: PPUSH
108451: LD_VAR 0 1
108455: PPUSH
108456: CALL 56797 0 2
108460: ST_TO_ADDR
// if hackTanksCaptured [ index ] < hackLimit then
108461: LD_EXP 200
108465: PUSH
108466: LD_VAR 0 5
108470: ARRAY
108471: PUSH
108472: LD_EXP 201
108476: LESS
108477: IFFALSE 108666
// begin for i := 1 to vehicles do
108479: LD_ADDR_VAR 0 4
108483: PUSH
108484: DOUBLE
108485: LD_INT 1
108487: DEC
108488: ST_TO_ADDR
108489: LD_VAR 0 2
108493: PUSH
108494: FOR_TO
108495: IFFALSE 108664
// begin if hackTanksCaptured [ index ] = hackLimit then
108497: LD_EXP 200
108501: PUSH
108502: LD_VAR 0 5
108506: ARRAY
108507: PUSH
108508: LD_EXP 201
108512: EQUAL
108513: IFFALSE 108517
// break ;
108515: GO 108664
// hackCounter := Replace ( hackCounter , index , hackCounter [ index ] + 1 ) ;
108517: LD_ADDR_EXP 203
108521: PUSH
108522: LD_EXP 203
108526: PPUSH
108527: LD_VAR 0 5
108531: PPUSH
108532: LD_EXP 203
108536: PUSH
108537: LD_VAR 0 5
108541: ARRAY
108542: PUSH
108543: LD_INT 1
108545: PLUS
108546: PPUSH
108547: CALL_OW 1
108551: ST_TO_ADDR
// hackTanksCaptured := ReplaceIn ( hackTanksCaptured , [ index , hackTanksCaptured [ index ] + 1 ] , [ vehicles [ i ] , GetSide ( vehicles [ i ] ) ] ) ;
108552: LD_ADDR_EXP 200
108556: PUSH
108557: LD_EXP 200
108561: PPUSH
108562: LD_VAR 0 5
108566: PUSH
108567: LD_EXP 200
108571: PUSH
108572: LD_VAR 0 5
108576: ARRAY
108577: PUSH
108578: LD_INT 1
108580: PLUS
108581: PUSH
108582: EMPTY
108583: LIST
108584: LIST
108585: PPUSH
108586: LD_VAR 0 2
108590: PUSH
108591: LD_VAR 0 4
108595: ARRAY
108596: PUSH
108597: LD_VAR 0 2
108601: PUSH
108602: LD_VAR 0 4
108606: ARRAY
108607: PPUSH
108608: CALL_OW 255
108612: PUSH
108613: EMPTY
108614: LIST
108615: LIST
108616: PPUSH
108617: CALL 57012 0 3
108621: ST_TO_ADDR
// SetSide ( vehicles [ i ] , GetSide ( hack ) ) ;
108622: LD_VAR 0 2
108626: PUSH
108627: LD_VAR 0 4
108631: ARRAY
108632: PPUSH
108633: LD_VAR 0 1
108637: PPUSH
108638: CALL_OW 255
108642: PPUSH
108643: CALL_OW 235
// ComStop ( vehicles [ i ] ) ;
108647: LD_VAR 0 2
108651: PUSH
108652: LD_VAR 0 4
108656: ARRAY
108657: PPUSH
108658: CALL_OW 141
// end ;
108662: GO 108494
108664: POP
108665: POP
// end ; SetUnitDisplayNumber ( hack , hackTanksCaptured [ index ] + 0 ) ;
108666: LD_VAR 0 1
108670: PPUSH
108671: LD_EXP 200
108675: PUSH
108676: LD_VAR 0 5
108680: ARRAY
108681: PUSH
108682: LD_INT 0
108684: PLUS
108685: PPUSH
108686: CALL_OW 505
// end ;
108690: LD_VAR 0 3
108694: RET
// function HackCheckCapturedStatus ( hack ) ; var i , index , tmp ; begin
108695: LD_INT 0
108697: PPUSH
108698: PPUSH
108699: PPUSH
108700: PPUSH
// if not hack in hackTanks then
108701: LD_VAR 0 1
108705: PUSH
108706: LD_EXP 199
108710: IN
108711: NOT
108712: IFFALSE 108716
// exit ;
108714: GO 108956
// index := GetElementIndex ( hackTanks , hack ) ;
108716: LD_ADDR_VAR 0 4
108720: PUSH
108721: LD_EXP 199
108725: PPUSH
108726: LD_VAR 0 1
108730: PPUSH
108731: CALL 56797 0 2
108735: ST_TO_ADDR
// for i := hackTanksCaptured [ index ] downto 1 do
108736: LD_ADDR_VAR 0 3
108740: PUSH
108741: DOUBLE
108742: LD_EXP 200
108746: PUSH
108747: LD_VAR 0 4
108751: ARRAY
108752: INC
108753: ST_TO_ADDR
108754: LD_INT 1
108756: PUSH
108757: FOR_DOWNTO
108758: IFFALSE 108930
// begin tmp := hackTanksCaptured [ index ] [ i ] ;
108760: LD_ADDR_VAR 0 5
108764: PUSH
108765: LD_EXP 200
108769: PUSH
108770: LD_VAR 0 4
108774: ARRAY
108775: PUSH
108776: LD_VAR 0 3
108780: ARRAY
108781: ST_TO_ADDR
// if not IsOk ( tmp [ 1 ] ) or GetSide ( tmp [ 1 ] ) <> GetSide ( hack ) then
108782: LD_VAR 0 5
108786: PUSH
108787: LD_INT 1
108789: ARRAY
108790: PPUSH
108791: CALL_OW 302
108795: NOT
108796: PUSH
108797: LD_VAR 0 5
108801: PUSH
108802: LD_INT 1
108804: ARRAY
108805: PPUSH
108806: CALL_OW 255
108810: PUSH
108811: LD_VAR 0 1
108815: PPUSH
108816: CALL_OW 255
108820: NONEQUAL
108821: OR
108822: IFFALSE 108928
// begin if IsPlaced ( tmp [ 1 ] ) and GetSide ( tmp [ 1 ] ) = GetSide ( hack ) then
108824: LD_VAR 0 5
108828: PUSH
108829: LD_INT 1
108831: ARRAY
108832: PPUSH
108833: CALL_OW 305
108837: PUSH
108838: LD_VAR 0 5
108842: PUSH
108843: LD_INT 1
108845: ARRAY
108846: PPUSH
108847: CALL_OW 255
108851: PUSH
108852: LD_VAR 0 1
108856: PPUSH
108857: CALL_OW 255
108861: EQUAL
108862: AND
108863: IFFALSE 108887
// SetSide ( tmp [ 1 ] , tmp [ 2 ] ) ;
108865: LD_VAR 0 5
108869: PUSH
108870: LD_INT 1
108872: ARRAY
108873: PPUSH
108874: LD_VAR 0 5
108878: PUSH
108879: LD_INT 2
108881: ARRAY
108882: PPUSH
108883: CALL_OW 235
// hackTanksCaptured := Replace ( hackTanksCaptured , index , Delete ( hackTanksCaptured [ index ] , i ) ) ;
108887: LD_ADDR_EXP 200
108891: PUSH
108892: LD_EXP 200
108896: PPUSH
108897: LD_VAR 0 4
108901: PPUSH
108902: LD_EXP 200
108906: PUSH
108907: LD_VAR 0 4
108911: ARRAY
108912: PPUSH
108913: LD_VAR 0 3
108917: PPUSH
108918: CALL_OW 3
108922: PPUSH
108923: CALL_OW 1
108927: ST_TO_ADDR
// end ; end ;
108928: GO 108757
108930: POP
108931: POP
// SetUnitDisplayNumber ( hack , hackTanksCaptured [ index ] + 0 ) ;
108932: LD_VAR 0 1
108936: PPUSH
108937: LD_EXP 200
108941: PUSH
108942: LD_VAR 0 4
108946: ARRAY
108947: PUSH
108948: LD_INT 0
108950: PLUS
108951: PPUSH
108952: CALL_OW 505
// end ;
108956: LD_VAR 0 2
108960: RET
// export function HackDestroyVehicle ( hack , vehicle ) ; var i , index , tmp ; begin
108961: LD_INT 0
108963: PPUSH
108964: PPUSH
108965: PPUSH
108966: PPUSH
// if not hack in hackTanks then
108967: LD_VAR 0 1
108971: PUSH
108972: LD_EXP 199
108976: IN
108977: NOT
108978: IFFALSE 108982
// exit ;
108980: GO 109067
// index := GetElementIndex ( hackTanks , hack ) ;
108982: LD_ADDR_VAR 0 5
108986: PUSH
108987: LD_EXP 199
108991: PPUSH
108992: LD_VAR 0 1
108996: PPUSH
108997: CALL 56797 0 2
109001: ST_TO_ADDR
// for i := 1 to hackTanksCaptured [ index ] do
109002: LD_ADDR_VAR 0 4
109006: PUSH
109007: DOUBLE
109008: LD_INT 1
109010: DEC
109011: ST_TO_ADDR
109012: LD_EXP 200
109016: PUSH
109017: LD_VAR 0 5
109021: ARRAY
109022: PUSH
109023: FOR_TO
109024: IFFALSE 109065
// if hackTanksCaptured [ index ] [ i ] [ 1 ] = vehicle then
109026: LD_EXP 200
109030: PUSH
109031: LD_VAR 0 5
109035: ARRAY
109036: PUSH
109037: LD_VAR 0 4
109041: ARRAY
109042: PUSH
109043: LD_INT 1
109045: ARRAY
109046: PUSH
109047: LD_VAR 0 2
109051: EQUAL
109052: IFFALSE 109063
// KillUnit ( vehicle ) ;
109054: LD_VAR 0 2
109058: PPUSH
109059: CALL_OW 66
109063: GO 109023
109065: POP
109066: POP
// end ;
109067: LD_VAR 0 3
109071: RET
// export initMiner , minersList , minerMinesList , minesLimitPerVehicle ; every 0 0$1 trigger not initMiner do
109072: LD_EXP 204
109076: NOT
109077: IFFALSE 109112
109079: GO 109081
109081: DISABLE
// begin initMiner := true ;
109082: LD_ADDR_EXP 204
109086: PUSH
109087: LD_INT 1
109089: ST_TO_ADDR
// minersList := [ ] ;
109090: LD_ADDR_EXP 205
109094: PUSH
109095: EMPTY
109096: ST_TO_ADDR
// minerMinesList := [ ] ;
109097: LD_ADDR_EXP 206
109101: PUSH
109102: EMPTY
109103: ST_TO_ADDR
// minesLimitPerVehicle := 5 ;
109104: LD_ADDR_EXP 207
109108: PUSH
109109: LD_INT 5
109111: ST_TO_ADDR
// end ;
109112: END
// every 0 0$1 trigger initMiner and FilterAllUnits ( [ f_weapon , ar_miner ] ) do var i , j , side , tmp ;
109113: LD_EXP 204
109117: PUSH
109118: LD_INT 34
109120: PUSH
109121: LD_EXP 81
109125: PUSH
109126: EMPTY
109127: LIST
109128: LIST
109129: PPUSH
109130: CALL_OW 69
109134: AND
109135: IFFALSE 109598
109137: GO 109139
109139: DISABLE
109140: LD_INT 0
109142: PPUSH
109143: PPUSH
109144: PPUSH
109145: PPUSH
// begin enable ;
109146: ENABLE
// for i in FilterAllUnits ( [ f_weapon , ar_miner ] ) do
109147: LD_ADDR_VAR 0 1
109151: PUSH
109152: LD_INT 34
109154: PUSH
109155: LD_EXP 81
109159: PUSH
109160: EMPTY
109161: LIST
109162: LIST
109163: PPUSH
109164: CALL_OW 69
109168: PUSH
109169: FOR_IN
109170: IFFALSE 109242
// begin if not i in minersList then
109172: LD_VAR 0 1
109176: PUSH
109177: LD_EXP 205
109181: IN
109182: NOT
109183: IFFALSE 109240
// begin minersList := Replace ( minersList , minersList + 1 , i ) ;
109185: LD_ADDR_EXP 205
109189: PUSH
109190: LD_EXP 205
109194: PPUSH
109195: LD_EXP 205
109199: PUSH
109200: LD_INT 1
109202: PLUS
109203: PPUSH
109204: LD_VAR 0 1
109208: PPUSH
109209: CALL_OW 1
109213: ST_TO_ADDR
// minerMinesList := Replace ( minerMinesList , minerMinesList + 1 , [ ] ) ;
109214: LD_ADDR_EXP 206
109218: PUSH
109219: LD_EXP 206
109223: PPUSH
109224: LD_EXP 206
109228: PUSH
109229: LD_INT 1
109231: PLUS
109232: PPUSH
109233: EMPTY
109234: PPUSH
109235: CALL_OW 1
109239: ST_TO_ADDR
// end end ;
109240: GO 109169
109242: POP
109243: POP
// for i := minerMinesList downto 1 do
109244: LD_ADDR_VAR 0 1
109248: PUSH
109249: DOUBLE
109250: LD_EXP 206
109254: INC
109255: ST_TO_ADDR
109256: LD_INT 1
109258: PUSH
109259: FOR_DOWNTO
109260: IFFALSE 109596
// begin if IsLive ( minersList [ i ] ) then
109262: LD_EXP 205
109266: PUSH
109267: LD_VAR 0 1
109271: ARRAY
109272: PPUSH
109273: CALL_OW 300
109277: IFFALSE 109305
// SetUnitDisplayNumber ( minersList [ i ] , minerMinesList [ i ] ) ;
109279: LD_EXP 205
109283: PUSH
109284: LD_VAR 0 1
109288: ARRAY
109289: PPUSH
109290: LD_EXP 206
109294: PUSH
109295: LD_VAR 0 1
109299: ARRAY
109300: PPUSH
109301: CALL_OW 505
// if not minerMinesList [ i ] then
109305: LD_EXP 206
109309: PUSH
109310: LD_VAR 0 1
109314: ARRAY
109315: NOT
109316: IFFALSE 109320
// continue ;
109318: GO 109259
// for j := minerMinesList [ i ] downto 1 do
109320: LD_ADDR_VAR 0 2
109324: PUSH
109325: DOUBLE
109326: LD_EXP 206
109330: PUSH
109331: LD_VAR 0 1
109335: ARRAY
109336: INC
109337: ST_TO_ADDR
109338: LD_INT 1
109340: PUSH
109341: FOR_DOWNTO
109342: IFFALSE 109592
// begin side := GetSide ( minersList [ i ] ) ;
109344: LD_ADDR_VAR 0 3
109348: PUSH
109349: LD_EXP 205
109353: PUSH
109354: LD_VAR 0 1
109358: ARRAY
109359: PPUSH
109360: CALL_OW 255
109364: ST_TO_ADDR
// tmp := HexInfo ( minerMinesList [ i ] [ j ] [ 1 ] , minerMinesList [ i ] [ j ] [ 2 ] ) ;
109365: LD_ADDR_VAR 0 4
109369: PUSH
109370: LD_EXP 206
109374: PUSH
109375: LD_VAR 0 1
109379: ARRAY
109380: PUSH
109381: LD_VAR 0 2
109385: ARRAY
109386: PUSH
109387: LD_INT 1
109389: ARRAY
109390: PPUSH
109391: LD_EXP 206
109395: PUSH
109396: LD_VAR 0 1
109400: ARRAY
109401: PUSH
109402: LD_VAR 0 2
109406: ARRAY
109407: PUSH
109408: LD_INT 2
109410: ARRAY
109411: PPUSH
109412: CALL_OW 428
109416: ST_TO_ADDR
// if not tmp then
109417: LD_VAR 0 4
109421: NOT
109422: IFFALSE 109426
// continue ;
109424: GO 109341
// if tmp in FilterAllUnits ( [ f_enemy , side ] ) and MineAtPos ( minerMinesList [ i ] [ j ] [ 1 ] , minerMinesList [ i ] [ j ] [ 2 ] ) then
109426: LD_VAR 0 4
109430: PUSH
109431: LD_INT 81
109433: PUSH
109434: LD_VAR 0 3
109438: PUSH
109439: EMPTY
109440: LIST
109441: LIST
109442: PPUSH
109443: CALL_OW 69
109447: IN
109448: PUSH
109449: LD_EXP 206
109453: PUSH
109454: LD_VAR 0 1
109458: ARRAY
109459: PUSH
109460: LD_VAR 0 2
109464: ARRAY
109465: PUSH
109466: LD_INT 1
109468: ARRAY
109469: PPUSH
109470: LD_EXP 206
109474: PUSH
109475: LD_VAR 0 1
109479: ARRAY
109480: PUSH
109481: LD_VAR 0 2
109485: ARRAY
109486: PUSH
109487: LD_INT 2
109489: ARRAY
109490: PPUSH
109491: CALL_OW 458
109495: AND
109496: IFFALSE 109590
// begin LaunchMineAtPos ( minerMinesList [ i ] [ j ] [ 1 ] , minerMinesList [ i ] [ j ] [ 2 ] , side ) ;
109498: LD_EXP 206
109502: PUSH
109503: LD_VAR 0 1
109507: ARRAY
109508: PUSH
109509: LD_VAR 0 2
109513: ARRAY
109514: PUSH
109515: LD_INT 1
109517: ARRAY
109518: PPUSH
109519: LD_EXP 206
109523: PUSH
109524: LD_VAR 0 1
109528: ARRAY
109529: PUSH
109530: LD_VAR 0 2
109534: ARRAY
109535: PUSH
109536: LD_INT 2
109538: ARRAY
109539: PPUSH
109540: LD_VAR 0 3
109544: PPUSH
109545: CALL_OW 456
// minerMinesList := Replace ( minerMinesList , i , Delete ( minerMinesList [ i ] , j ) ) ;
109549: LD_ADDR_EXP 206
109553: PUSH
109554: LD_EXP 206
109558: PPUSH
109559: LD_VAR 0 1
109563: PPUSH
109564: LD_EXP 206
109568: PUSH
109569: LD_VAR 0 1
109573: ARRAY
109574: PPUSH
109575: LD_VAR 0 2
109579: PPUSH
109580: CALL_OW 3
109584: PPUSH
109585: CALL_OW 1
109589: ST_TO_ADDR
// end ; end ;
109590: GO 109341
109592: POP
109593: POP
// end ;
109594: GO 109259
109596: POP
109597: POP
// end ;
109598: PPOPN 4
109600: END
// export function MinerPlaceMine ( unit , x , y ) ; var index ; begin
109601: LD_INT 0
109603: PPUSH
109604: PPUSH
// result := false ;
109605: LD_ADDR_VAR 0 4
109609: PUSH
109610: LD_INT 0
109612: ST_TO_ADDR
// if not GetWeapon ( unit ) = ar_miner then
109613: LD_VAR 0 1
109617: PPUSH
109618: CALL_OW 264
109622: PUSH
109623: LD_EXP 81
109627: EQUAL
109628: NOT
109629: IFFALSE 109633
// exit ;
109631: GO 109873
// index := GetElementIndex ( minersList , unit ) ;
109633: LD_ADDR_VAR 0 5
109637: PUSH
109638: LD_EXP 205
109642: PPUSH
109643: LD_VAR 0 1
109647: PPUSH
109648: CALL 56797 0 2
109652: ST_TO_ADDR
// if minerMinesList [ index ] >= minesLimitPerVehicle then
109653: LD_EXP 206
109657: PUSH
109658: LD_VAR 0 5
109662: ARRAY
109663: PUSH
109664: LD_EXP 207
109668: GREATEREQUAL
109669: IFFALSE 109673
// exit ;
109671: GO 109873
// ComMoveXY ( unit , x , y ) ;
109673: LD_VAR 0 1
109677: PPUSH
109678: LD_VAR 0 2
109682: PPUSH
109683: LD_VAR 0 3
109687: PPUSH
109688: CALL_OW 111
// repeat wait ( 0 0$1 ) ;
109692: LD_INT 35
109694: PPUSH
109695: CALL_OW 67
// if not UnitGoingToXY ( unit , x , y ) and HasTask ( unit ) then
109699: LD_VAR 0 1
109703: PPUSH
109704: LD_VAR 0 2
109708: PPUSH
109709: LD_VAR 0 3
109713: PPUSH
109714: CALL 87569 0 3
109718: NOT
109719: PUSH
109720: LD_VAR 0 1
109724: PPUSH
109725: CALL_OW 314
109729: AND
109730: IFFALSE 109734
// exit ;
109732: GO 109873
// until HexInfo ( x , y ) = unit and not HasTask ( unit ) ;
109734: LD_VAR 0 2
109738: PPUSH
109739: LD_VAR 0 3
109743: PPUSH
109744: CALL_OW 428
109748: PUSH
109749: LD_VAR 0 1
109753: EQUAL
109754: PUSH
109755: LD_VAR 0 1
109759: PPUSH
109760: CALL_OW 314
109764: NOT
109765: AND
109766: IFFALSE 109692
// PlaySoundXY ( x , y , PlantMine ) ;
109768: LD_VAR 0 2
109772: PPUSH
109773: LD_VAR 0 3
109777: PPUSH
109778: LD_STRING PlantMine
109780: PPUSH
109781: CALL_OW 366
// PlaceMine ( x , y , GetSide ( unit ) , 0 ) ;
109785: LD_VAR 0 2
109789: PPUSH
109790: LD_VAR 0 3
109794: PPUSH
109795: LD_VAR 0 1
109799: PPUSH
109800: CALL_OW 255
109804: PPUSH
109805: LD_INT 0
109807: PPUSH
109808: CALL_OW 454
// minerMinesList := ReplaceIn ( minerMinesList , [ index , minerMinesList [ index ] + 1 ] , [ x , y ] ) ;
109812: LD_ADDR_EXP 206
109816: PUSH
109817: LD_EXP 206
109821: PPUSH
109822: LD_VAR 0 5
109826: PUSH
109827: LD_EXP 206
109831: PUSH
109832: LD_VAR 0 5
109836: ARRAY
109837: PUSH
109838: LD_INT 1
109840: PLUS
109841: PUSH
109842: EMPTY
109843: LIST
109844: LIST
109845: PPUSH
109846: LD_VAR 0 2
109850: PUSH
109851: LD_VAR 0 3
109855: PUSH
109856: EMPTY
109857: LIST
109858: LIST
109859: PPUSH
109860: CALL 57012 0 3
109864: ST_TO_ADDR
// result := true ;
109865: LD_ADDR_VAR 0 4
109869: PUSH
109870: LD_INT 1
109872: ST_TO_ADDR
// end ;
109873: LD_VAR 0 4
109877: RET
// export function MinerDetonateMine ( unit , x , y ) ; var i , index ; begin
109878: LD_INT 0
109880: PPUSH
109881: PPUSH
109882: PPUSH
// if not unit in minersList then
109883: LD_VAR 0 1
109887: PUSH
109888: LD_EXP 205
109892: IN
109893: NOT
109894: IFFALSE 109898
// exit ;
109896: GO 110290
// index := GetElementIndex ( minersList , unit ) ;
109898: LD_ADDR_VAR 0 6
109902: PUSH
109903: LD_EXP 205
109907: PPUSH
109908: LD_VAR 0 1
109912: PPUSH
109913: CALL 56797 0 2
109917: ST_TO_ADDR
// for i := minerMinesList [ index ] downto 1 do
109918: LD_ADDR_VAR 0 5
109922: PUSH
109923: DOUBLE
109924: LD_EXP 206
109928: PUSH
109929: LD_VAR 0 6
109933: ARRAY
109934: INC
109935: ST_TO_ADDR
109936: LD_INT 1
109938: PUSH
109939: FOR_DOWNTO
109940: IFFALSE 110101
// begin if minerMinesList [ index ] [ i ] [ 1 ] = x and minerMinesList [ index ] [ i ] [ 2 ] = y then
109942: LD_EXP 206
109946: PUSH
109947: LD_VAR 0 6
109951: ARRAY
109952: PUSH
109953: LD_VAR 0 5
109957: ARRAY
109958: PUSH
109959: LD_INT 1
109961: ARRAY
109962: PUSH
109963: LD_VAR 0 2
109967: EQUAL
109968: PUSH
109969: LD_EXP 206
109973: PUSH
109974: LD_VAR 0 6
109978: ARRAY
109979: PUSH
109980: LD_VAR 0 5
109984: ARRAY
109985: PUSH
109986: LD_INT 2
109988: ARRAY
109989: PUSH
109990: LD_VAR 0 3
109994: EQUAL
109995: AND
109996: IFFALSE 110099
// begin LaunchMineAtPos ( minerMinesList [ index ] [ i ] [ 1 ] , minerMinesList [ index ] [ i ] [ 2 ] , GetSide ( unit ) ) ;
109998: LD_EXP 206
110002: PUSH
110003: LD_VAR 0 6
110007: ARRAY
110008: PUSH
110009: LD_VAR 0 5
110013: ARRAY
110014: PUSH
110015: LD_INT 1
110017: ARRAY
110018: PPUSH
110019: LD_EXP 206
110023: PUSH
110024: LD_VAR 0 6
110028: ARRAY
110029: PUSH
110030: LD_VAR 0 5
110034: ARRAY
110035: PUSH
110036: LD_INT 2
110038: ARRAY
110039: PPUSH
110040: LD_VAR 0 1
110044: PPUSH
110045: CALL_OW 255
110049: PPUSH
110050: CALL_OW 456
// minerMinesList := Replace ( minerMinesList , index , Delete ( minerMinesList [ index ] , i ) ) ;
110054: LD_ADDR_EXP 206
110058: PUSH
110059: LD_EXP 206
110063: PPUSH
110064: LD_VAR 0 6
110068: PPUSH
110069: LD_EXP 206
110073: PUSH
110074: LD_VAR 0 6
110078: ARRAY
110079: PPUSH
110080: LD_VAR 0 5
110084: PPUSH
110085: CALL_OW 3
110089: PPUSH
110090: CALL_OW 1
110094: ST_TO_ADDR
// exit ;
110095: POP
110096: POP
110097: GO 110290
// end ; end ;
110099: GO 109939
110101: POP
110102: POP
// for i := minerMinesList [ index ] downto 1 do
110103: LD_ADDR_VAR 0 5
110107: PUSH
110108: DOUBLE
110109: LD_EXP 206
110113: PUSH
110114: LD_VAR 0 6
110118: ARRAY
110119: INC
110120: ST_TO_ADDR
110121: LD_INT 1
110123: PUSH
110124: FOR_DOWNTO
110125: IFFALSE 110288
// begin if GetDistXY ( minerMinesList [ index ] [ i ] [ 1 ] , minerMinesList [ index ] [ i ] [ 2 ] , x , y ) < 6 then
110127: LD_EXP 206
110131: PUSH
110132: LD_VAR 0 6
110136: ARRAY
110137: PUSH
110138: LD_VAR 0 5
110142: ARRAY
110143: PUSH
110144: LD_INT 1
110146: ARRAY
110147: PPUSH
110148: LD_EXP 206
110152: PUSH
110153: LD_VAR 0 6
110157: ARRAY
110158: PUSH
110159: LD_VAR 0 5
110163: ARRAY
110164: PUSH
110165: LD_INT 2
110167: ARRAY
110168: PPUSH
110169: LD_VAR 0 2
110173: PPUSH
110174: LD_VAR 0 3
110178: PPUSH
110179: CALL_OW 298
110183: PUSH
110184: LD_INT 6
110186: LESS
110187: IFFALSE 110286
// begin LaunchMineAtPos ( minerMinesList [ index ] [ i ] [ 1 ] , minerMinesList [ index ] [ i ] [ 2 ] , GetSide ( unit ) ) ;
110189: LD_EXP 206
110193: PUSH
110194: LD_VAR 0 6
110198: ARRAY
110199: PUSH
110200: LD_VAR 0 5
110204: ARRAY
110205: PUSH
110206: LD_INT 1
110208: ARRAY
110209: PPUSH
110210: LD_EXP 206
110214: PUSH
110215: LD_VAR 0 6
110219: ARRAY
110220: PUSH
110221: LD_VAR 0 5
110225: ARRAY
110226: PUSH
110227: LD_INT 2
110229: ARRAY
110230: PPUSH
110231: LD_VAR 0 1
110235: PPUSH
110236: CALL_OW 255
110240: PPUSH
110241: CALL_OW 456
// minerMinesList := Replace ( minerMinesList , index , Delete ( minerMinesList [ index ] , i ) ) ;
110245: LD_ADDR_EXP 206
110249: PUSH
110250: LD_EXP 206
110254: PPUSH
110255: LD_VAR 0 6
110259: PPUSH
110260: LD_EXP 206
110264: PUSH
110265: LD_VAR 0 6
110269: ARRAY
110270: PPUSH
110271: LD_VAR 0 5
110275: PPUSH
110276: CALL_OW 3
110280: PPUSH
110281: CALL_OW 1
110285: ST_TO_ADDR
// end ; end ;
110286: GO 110124
110288: POP
110289: POP
// end ;
110290: LD_VAR 0 4
110294: RET
// export function MinerCreateMinefield ( unit , x , y ) ; var i , index , tmp , minesFreeAmount , _x , _y , _d , _r ; begin
110295: LD_INT 0
110297: PPUSH
110298: PPUSH
110299: PPUSH
110300: PPUSH
110301: PPUSH
110302: PPUSH
110303: PPUSH
110304: PPUSH
110305: PPUSH
// if not GetWeapon ( unit ) = ar_miner or not unit in minersList then
110306: LD_VAR 0 1
110310: PPUSH
110311: CALL_OW 264
110315: PUSH
110316: LD_EXP 81
110320: EQUAL
110321: NOT
110322: PUSH
110323: LD_VAR 0 1
110327: PUSH
110328: LD_EXP 205
110332: IN
110333: NOT
110334: OR
110335: IFFALSE 110339
// exit ;
110337: GO 110661
// index := GetElementIndex ( minersList , unit ) ;
110339: LD_ADDR_VAR 0 6
110343: PUSH
110344: LD_EXP 205
110348: PPUSH
110349: LD_VAR 0 1
110353: PPUSH
110354: CALL 56797 0 2
110358: ST_TO_ADDR
// minesFreeAmount := minesLimitPerVehicle - minerMinesList [ index ] ;
110359: LD_ADDR_VAR 0 8
110363: PUSH
110364: LD_EXP 207
110368: PUSH
110369: LD_EXP 206
110373: PUSH
110374: LD_VAR 0 6
110378: ARRAY
110379: MINUS
110380: ST_TO_ADDR
// if not minesFreeAmount then
110381: LD_VAR 0 8
110385: NOT
110386: IFFALSE 110390
// exit ;
110388: GO 110661
// tmp := [ ] ;
110390: LD_ADDR_VAR 0 7
110394: PUSH
110395: EMPTY
110396: ST_TO_ADDR
// for i := 1 to minesFreeAmount do
110397: LD_ADDR_VAR 0 5
110401: PUSH
110402: DOUBLE
110403: LD_INT 1
110405: DEC
110406: ST_TO_ADDR
110407: LD_VAR 0 8
110411: PUSH
110412: FOR_TO
110413: IFFALSE 110608
// begin _d := rand ( 0 , 5 ) ;
110415: LD_ADDR_VAR 0 11
110419: PUSH
110420: LD_INT 0
110422: PPUSH
110423: LD_INT 5
110425: PPUSH
110426: CALL_OW 12
110430: ST_TO_ADDR
// _r := rand ( 2 , 6 ) ;
110431: LD_ADDR_VAR 0 12
110435: PUSH
110436: LD_INT 2
110438: PPUSH
110439: LD_INT 6
110441: PPUSH
110442: CALL_OW 12
110446: ST_TO_ADDR
// _x := ShiftX ( x , _d , _r ) ;
110447: LD_ADDR_VAR 0 9
110451: PUSH
110452: LD_VAR 0 2
110456: PPUSH
110457: LD_VAR 0 11
110461: PPUSH
110462: LD_VAR 0 12
110466: PPUSH
110467: CALL_OW 272
110471: ST_TO_ADDR
// _y := ShiftY ( y , _d , _r ) ;
110472: LD_ADDR_VAR 0 10
110476: PUSH
110477: LD_VAR 0 3
110481: PPUSH
110482: LD_VAR 0 11
110486: PPUSH
110487: LD_VAR 0 12
110491: PPUSH
110492: CALL_OW 273
110496: ST_TO_ADDR
// if ValidHex ( _x , _y ) and not [ _x , _y ] in tmp and not MineAtPos ( _x , _y ) then
110497: LD_VAR 0 9
110501: PPUSH
110502: LD_VAR 0 10
110506: PPUSH
110507: CALL_OW 488
110511: PUSH
110512: LD_VAR 0 9
110516: PUSH
110517: LD_VAR 0 10
110521: PUSH
110522: EMPTY
110523: LIST
110524: LIST
110525: PUSH
110526: LD_VAR 0 7
110530: IN
110531: NOT
110532: AND
110533: PUSH
110534: LD_VAR 0 9
110538: PPUSH
110539: LD_VAR 0 10
110543: PPUSH
110544: CALL_OW 458
110548: NOT
110549: AND
110550: IFFALSE 110592
// tmp := Replace ( tmp , tmp + 1 , [ _x , _y ] ) else
110552: LD_ADDR_VAR 0 7
110556: PUSH
110557: LD_VAR 0 7
110561: PPUSH
110562: LD_VAR 0 7
110566: PUSH
110567: LD_INT 1
110569: PLUS
110570: PPUSH
110571: LD_VAR 0 9
110575: PUSH
110576: LD_VAR 0 10
110580: PUSH
110581: EMPTY
110582: LIST
110583: LIST
110584: PPUSH
110585: CALL_OW 1
110589: ST_TO_ADDR
110590: GO 110606
// i := i - 1 ;
110592: LD_ADDR_VAR 0 5
110596: PUSH
110597: LD_VAR 0 5
110601: PUSH
110602: LD_INT 1
110604: MINUS
110605: ST_TO_ADDR
// end ;
110606: GO 110412
110608: POP
110609: POP
// for i in tmp do
110610: LD_ADDR_VAR 0 5
110614: PUSH
110615: LD_VAR 0 7
110619: PUSH
110620: FOR_IN
110621: IFFALSE 110659
// if not MinerPlaceMine ( unit , i [ 1 ] , i [ 2 ] ) then
110623: LD_VAR 0 1
110627: PPUSH
110628: LD_VAR 0 5
110632: PUSH
110633: LD_INT 1
110635: ARRAY
110636: PPUSH
110637: LD_VAR 0 5
110641: PUSH
110642: LD_INT 2
110644: ARRAY
110645: PPUSH
110646: CALL 109601 0 3
110650: NOT
110651: IFFALSE 110657
// exit ;
110653: POP
110654: POP
110655: GO 110661
110657: GO 110620
110659: POP
110660: POP
// end ;
110661: LD_VAR 0 4
110665: RET
// export function ComBinocular ( unit , x , y ) ; var dist , side , viewRange , _x , _y , _d ; begin
110666: LD_INT 0
110668: PPUSH
110669: PPUSH
110670: PPUSH
110671: PPUSH
110672: PPUSH
110673: PPUSH
110674: PPUSH
// if not GetClass ( unit ) = class_sniper then
110675: LD_VAR 0 1
110679: PPUSH
110680: CALL_OW 257
110684: PUSH
110685: LD_INT 5
110687: EQUAL
110688: NOT
110689: IFFALSE 110693
// exit ;
110691: GO 111081
// dist := 8 ;
110693: LD_ADDR_VAR 0 5
110697: PUSH
110698: LD_INT 8
110700: ST_TO_ADDR
// viewRange := 12 ;
110701: LD_ADDR_VAR 0 7
110705: PUSH
110706: LD_INT 12
110708: ST_TO_ADDR
// side := GetSide ( unit ) ;
110709: LD_ADDR_VAR 0 6
110713: PUSH
110714: LD_VAR 0 1
110718: PPUSH
110719: CALL_OW 255
110723: ST_TO_ADDR
// if GetTech ( tech_opto2 , side ) = state_researched then
110724: LD_INT 61
110726: PPUSH
110727: LD_VAR 0 6
110731: PPUSH
110732: CALL_OW 321
110736: PUSH
110737: LD_INT 2
110739: EQUAL
110740: IFFALSE 110750
// viewRange := 16 ;
110742: LD_ADDR_VAR 0 7
110746: PUSH
110747: LD_INT 16
110749: ST_TO_ADDR
// if GetDistUnitXY ( unit , x , y ) > dist then
110750: LD_VAR 0 1
110754: PPUSH
110755: LD_VAR 0 2
110759: PPUSH
110760: LD_VAR 0 3
110764: PPUSH
110765: CALL_OW 297
110769: PUSH
110770: LD_VAR 0 5
110774: GREATER
110775: IFFALSE 110854
// begin ComMoveXY ( unit , x , y ) ;
110777: LD_VAR 0 1
110781: PPUSH
110782: LD_VAR 0 2
110786: PPUSH
110787: LD_VAR 0 3
110791: PPUSH
110792: CALL_OW 111
// repeat wait ( 0 0$1 ) ;
110796: LD_INT 35
110798: PPUSH
110799: CALL_OW 67
// if not UnitGoingToXY ( unit , x , y ) then
110803: LD_VAR 0 1
110807: PPUSH
110808: LD_VAR 0 2
110812: PPUSH
110813: LD_VAR 0 3
110817: PPUSH
110818: CALL 87569 0 3
110822: NOT
110823: IFFALSE 110827
// exit ;
110825: GO 111081
// until GetDistUnitXY ( unit , x , y ) < dist ;
110827: LD_VAR 0 1
110831: PPUSH
110832: LD_VAR 0 2
110836: PPUSH
110837: LD_VAR 0 3
110841: PPUSH
110842: CALL_OW 297
110846: PUSH
110847: LD_VAR 0 5
110851: LESS
110852: IFFALSE 110796
// end ; ComTurnXY ( unit , x , y ) ;
110854: LD_VAR 0 1
110858: PPUSH
110859: LD_VAR 0 2
110863: PPUSH
110864: LD_VAR 0 3
110868: PPUSH
110869: CALL_OW 118
// wait ( 5 ) ;
110873: LD_INT 5
110875: PPUSH
110876: CALL_OW 67
// _d := GetDir ( unit ) ;
110880: LD_ADDR_VAR 0 10
110884: PUSH
110885: LD_VAR 0 1
110889: PPUSH
110890: CALL_OW 254
110894: ST_TO_ADDR
// _x := ShiftX ( GetX ( unit ) , _d , dist ) ;
110895: LD_ADDR_VAR 0 8
110899: PUSH
110900: LD_VAR 0 1
110904: PPUSH
110905: CALL_OW 250
110909: PPUSH
110910: LD_VAR 0 10
110914: PPUSH
110915: LD_VAR 0 5
110919: PPUSH
110920: CALL_OW 272
110924: ST_TO_ADDR
// _y := ShiftY ( GetY ( unit ) , _d , dist ) ;
110925: LD_ADDR_VAR 0 9
110929: PUSH
110930: LD_VAR 0 1
110934: PPUSH
110935: CALL_OW 251
110939: PPUSH
110940: LD_VAR 0 10
110944: PPUSH
110945: LD_VAR 0 5
110949: PPUSH
110950: CALL_OW 273
110954: ST_TO_ADDR
// if not ValidHex ( _x , _y ) then
110955: LD_VAR 0 8
110959: PPUSH
110960: LD_VAR 0 9
110964: PPUSH
110965: CALL_OW 488
110969: NOT
110970: IFFALSE 110974
// exit ;
110972: GO 111081
// ComAnimCustom ( unit , 1 ) ;
110974: LD_VAR 0 1
110978: PPUSH
110979: LD_INT 1
110981: PPUSH
110982: CALL_OW 592
// PlaceSeeing ( _x , _y , side , viewRange ) ;
110986: LD_VAR 0 8
110990: PPUSH
110991: LD_VAR 0 9
110995: PPUSH
110996: LD_VAR 0 6
111000: PPUSH
111001: LD_VAR 0 7
111005: PPUSH
111006: CALL_OW 330
// repeat wait ( 1 ) ;
111010: LD_INT 1
111012: PPUSH
111013: CALL_OW 67
// until IsIdle ( unit ) or HasTask ( unit ) or not IsOk ( unit ) or IsDead ( unit ) ;
111017: LD_VAR 0 1
111021: PPUSH
111022: CALL_OW 316
111026: PUSH
111027: LD_VAR 0 1
111031: PPUSH
111032: CALL_OW 314
111036: OR
111037: PUSH
111038: LD_VAR 0 1
111042: PPUSH
111043: CALL_OW 302
111047: NOT
111048: OR
111049: PUSH
111050: LD_VAR 0 1
111054: PPUSH
111055: CALL_OW 301
111059: OR
111060: IFFALSE 111010
// RemoveSeeing ( _x , _y , side ) ;
111062: LD_VAR 0 8
111066: PPUSH
111067: LD_VAR 0 9
111071: PPUSH
111072: LD_VAR 0 6
111076: PPUSH
111077: CALL_OW 331
// end ; end_of_file
111081: LD_VAR 0 4
111085: RET
// export function Attack ( list ) ; var base , group , path , flags , i , j , k , x , y , d , z , tmp , tmp2 , units_path , f_ignore_area , f_capture , f_ignore_civ , f_murder , f_mines , f_repair , f_heal , f_spacetime , f_attack_depot , f_crawl , mined , bombed , attacking , to_heal , healers , to_repair , repairs , empty_vehs , side ; begin
111086: LD_INT 0
111088: PPUSH
111089: PPUSH
111090: PPUSH
111091: PPUSH
111092: PPUSH
111093: PPUSH
111094: PPUSH
111095: PPUSH
111096: PPUSH
111097: PPUSH
111098: PPUSH
111099: PPUSH
111100: PPUSH
111101: PPUSH
111102: PPUSH
111103: PPUSH
111104: PPUSH
111105: PPUSH
111106: PPUSH
111107: PPUSH
111108: PPUSH
111109: PPUSH
111110: PPUSH
111111: PPUSH
111112: PPUSH
111113: PPUSH
111114: PPUSH
111115: PPUSH
111116: PPUSH
111117: PPUSH
111118: PPUSH
111119: PPUSH
111120: PPUSH
111121: PPUSH
// if not list then
111122: LD_VAR 0 1
111126: NOT
111127: IFFALSE 111131
// exit ;
111129: GO 115790
// base := list [ 1 ] ;
111131: LD_ADDR_VAR 0 3
111135: PUSH
111136: LD_VAR 0 1
111140: PUSH
111141: LD_INT 1
111143: ARRAY
111144: ST_TO_ADDR
// group := list [ 2 ] ;
111145: LD_ADDR_VAR 0 4
111149: PUSH
111150: LD_VAR 0 1
111154: PUSH
111155: LD_INT 2
111157: ARRAY
111158: ST_TO_ADDR
// path := list [ 3 ] ;
111159: LD_ADDR_VAR 0 5
111163: PUSH
111164: LD_VAR 0 1
111168: PUSH
111169: LD_INT 3
111171: ARRAY
111172: ST_TO_ADDR
// flags := list [ 4 ] ;
111173: LD_ADDR_VAR 0 6
111177: PUSH
111178: LD_VAR 0 1
111182: PUSH
111183: LD_INT 4
111185: ARRAY
111186: ST_TO_ADDR
// mined := [ ] ;
111187: LD_ADDR_VAR 0 27
111191: PUSH
111192: EMPTY
111193: ST_TO_ADDR
// bombed := [ ] ;
111194: LD_ADDR_VAR 0 28
111198: PUSH
111199: EMPTY
111200: ST_TO_ADDR
// healers := [ ] ;
111201: LD_ADDR_VAR 0 31
111205: PUSH
111206: EMPTY
111207: ST_TO_ADDR
// to_heal := [ ] ;
111208: LD_ADDR_VAR 0 30
111212: PUSH
111213: EMPTY
111214: ST_TO_ADDR
// repairs := [ ] ;
111215: LD_ADDR_VAR 0 33
111219: PUSH
111220: EMPTY
111221: ST_TO_ADDR
// to_repair := [ ] ;
111222: LD_ADDR_VAR 0 32
111226: PUSH
111227: EMPTY
111228: ST_TO_ADDR
// if not group or not path then
111229: LD_VAR 0 4
111233: NOT
111234: PUSH
111235: LD_VAR 0 5
111239: NOT
111240: OR
111241: IFFALSE 111245
// exit ;
111243: GO 115790
// side := GetSide ( group [ 1 ] ) ;
111245: LD_ADDR_VAR 0 35
111249: PUSH
111250: LD_VAR 0 4
111254: PUSH
111255: LD_INT 1
111257: ARRAY
111258: PPUSH
111259: CALL_OW 255
111263: ST_TO_ADDR
// if flags then
111264: LD_VAR 0 6
111268: IFFALSE 111412
// begin f_ignore_area := flags [ 1 ] ;
111270: LD_ADDR_VAR 0 17
111274: PUSH
111275: LD_VAR 0 6
111279: PUSH
111280: LD_INT 1
111282: ARRAY
111283: ST_TO_ADDR
// f_capture := flags [ 2 ] ;
111284: LD_ADDR_VAR 0 18
111288: PUSH
111289: LD_VAR 0 6
111293: PUSH
111294: LD_INT 2
111296: ARRAY
111297: ST_TO_ADDR
// f_ignore_civ := flags [ 3 ] ;
111298: LD_ADDR_VAR 0 19
111302: PUSH
111303: LD_VAR 0 6
111307: PUSH
111308: LD_INT 3
111310: ARRAY
111311: ST_TO_ADDR
// f_murder := flags [ 4 ] ;
111312: LD_ADDR_VAR 0 20
111316: PUSH
111317: LD_VAR 0 6
111321: PUSH
111322: LD_INT 4
111324: ARRAY
111325: ST_TO_ADDR
// f_mines := flags [ 5 ] ;
111326: LD_ADDR_VAR 0 21
111330: PUSH
111331: LD_VAR 0 6
111335: PUSH
111336: LD_INT 5
111338: ARRAY
111339: ST_TO_ADDR
// f_repair := flags [ 6 ] ;
111340: LD_ADDR_VAR 0 22
111344: PUSH
111345: LD_VAR 0 6
111349: PUSH
111350: LD_INT 6
111352: ARRAY
111353: ST_TO_ADDR
// f_heal := flags [ 7 ] ;
111354: LD_ADDR_VAR 0 23
111358: PUSH
111359: LD_VAR 0 6
111363: PUSH
111364: LD_INT 7
111366: ARRAY
111367: ST_TO_ADDR
// f_spacetime := flags [ 8 ] ;
111368: LD_ADDR_VAR 0 24
111372: PUSH
111373: LD_VAR 0 6
111377: PUSH
111378: LD_INT 8
111380: ARRAY
111381: ST_TO_ADDR
// f_attack_depot := flags [ 9 ] ;
111382: LD_ADDR_VAR 0 25
111386: PUSH
111387: LD_VAR 0 6
111391: PUSH
111392: LD_INT 9
111394: ARRAY
111395: ST_TO_ADDR
// f_crawl := flags [ 10 ] ;
111396: LD_ADDR_VAR 0 26
111400: PUSH
111401: LD_VAR 0 6
111405: PUSH
111406: LD_INT 10
111408: ARRAY
111409: ST_TO_ADDR
// end else
111410: GO 111492
// begin f_ignore_area := false ;
111412: LD_ADDR_VAR 0 17
111416: PUSH
111417: LD_INT 0
111419: ST_TO_ADDR
// f_capture := false ;
111420: LD_ADDR_VAR 0 18
111424: PUSH
111425: LD_INT 0
111427: ST_TO_ADDR
// f_ignore_civ := false ;
111428: LD_ADDR_VAR 0 19
111432: PUSH
111433: LD_INT 0
111435: ST_TO_ADDR
// f_murder := false ;
111436: LD_ADDR_VAR 0 20
111440: PUSH
111441: LD_INT 0
111443: ST_TO_ADDR
// f_mines := false ;
111444: LD_ADDR_VAR 0 21
111448: PUSH
111449: LD_INT 0
111451: ST_TO_ADDR
// f_repair := false ;
111452: LD_ADDR_VAR 0 22
111456: PUSH
111457: LD_INT 0
111459: ST_TO_ADDR
// f_heal := false ;
111460: LD_ADDR_VAR 0 23
111464: PUSH
111465: LD_INT 0
111467: ST_TO_ADDR
// f_spacetime := false ;
111468: LD_ADDR_VAR 0 24
111472: PUSH
111473: LD_INT 0
111475: ST_TO_ADDR
// f_attack_depot := false ;
111476: LD_ADDR_VAR 0 25
111480: PUSH
111481: LD_INT 0
111483: ST_TO_ADDR
// f_crawl := false ;
111484: LD_ADDR_VAR 0 26
111488: PUSH
111489: LD_INT 0
111491: ST_TO_ADDR
// end ; if f_heal then
111492: LD_VAR 0 23
111496: IFFALSE 111523
// healers := UnitFilter ( group , [ f_class , 4 ] ) ;
111498: LD_ADDR_VAR 0 31
111502: PUSH
111503: LD_VAR 0 4
111507: PPUSH
111508: LD_INT 25
111510: PUSH
111511: LD_INT 4
111513: PUSH
111514: EMPTY
111515: LIST
111516: LIST
111517: PPUSH
111518: CALL_OW 72
111522: ST_TO_ADDR
// if f_repair then
111523: LD_VAR 0 22
111527: IFFALSE 111554
// repairs := UnitFilter ( group , [ f_class , 3 ] ) ;
111529: LD_ADDR_VAR 0 33
111533: PUSH
111534: LD_VAR 0 4
111538: PPUSH
111539: LD_INT 25
111541: PUSH
111542: LD_INT 3
111544: PUSH
111545: EMPTY
111546: LIST
111547: LIST
111548: PPUSH
111549: CALL_OW 72
111553: ST_TO_ADDR
// units_path := [ ] ;
111554: LD_ADDR_VAR 0 16
111558: PUSH
111559: EMPTY
111560: ST_TO_ADDR
// for i = 1 to group do
111561: LD_ADDR_VAR 0 7
111565: PUSH
111566: DOUBLE
111567: LD_INT 1
111569: DEC
111570: ST_TO_ADDR
111571: LD_VAR 0 4
111575: PUSH
111576: FOR_TO
111577: IFFALSE 111606
// units_path := Replace ( units_path , i , path ) ;
111579: LD_ADDR_VAR 0 16
111583: PUSH
111584: LD_VAR 0 16
111588: PPUSH
111589: LD_VAR 0 7
111593: PPUSH
111594: LD_VAR 0 5
111598: PPUSH
111599: CALL_OW 1
111603: ST_TO_ADDR
111604: GO 111576
111606: POP
111607: POP
// repeat for i = group downto 1 do
111608: LD_ADDR_VAR 0 7
111612: PUSH
111613: DOUBLE
111614: LD_VAR 0 4
111618: INC
111619: ST_TO_ADDR
111620: LD_INT 1
111622: PUSH
111623: FOR_DOWNTO
111624: IFFALSE 115746
// begin wait ( 5 ) ;
111626: LD_INT 5
111628: PPUSH
111629: CALL_OW 67
// tmp := [ ] ;
111633: LD_ADDR_VAR 0 14
111637: PUSH
111638: EMPTY
111639: ST_TO_ADDR
// attacking := false ;
111640: LD_ADDR_VAR 0 29
111644: PUSH
111645: LD_INT 0
111647: ST_TO_ADDR
// if IsDead ( group [ i ] ) or not group [ i ] then
111648: LD_VAR 0 4
111652: PUSH
111653: LD_VAR 0 7
111657: ARRAY
111658: PPUSH
111659: CALL_OW 301
111663: PUSH
111664: LD_VAR 0 4
111668: PUSH
111669: LD_VAR 0 7
111673: ARRAY
111674: NOT
111675: OR
111676: IFFALSE 111785
// begin if GetType ( group [ i ] ) = unit_human then
111678: LD_VAR 0 4
111682: PUSH
111683: LD_VAR 0 7
111687: ARRAY
111688: PPUSH
111689: CALL_OW 247
111693: PUSH
111694: LD_INT 1
111696: EQUAL
111697: IFFALSE 111743
// begin to_heal := to_heal diff group [ i ] ;
111699: LD_ADDR_VAR 0 30
111703: PUSH
111704: LD_VAR 0 30
111708: PUSH
111709: LD_VAR 0 4
111713: PUSH
111714: LD_VAR 0 7
111718: ARRAY
111719: DIFF
111720: ST_TO_ADDR
// healers := healers diff group [ i ] ;
111721: LD_ADDR_VAR 0 31
111725: PUSH
111726: LD_VAR 0 31
111730: PUSH
111731: LD_VAR 0 4
111735: PUSH
111736: LD_VAR 0 7
111740: ARRAY
111741: DIFF
111742: ST_TO_ADDR
// end ; group := Delete ( group , i ) ;
111743: LD_ADDR_VAR 0 4
111747: PUSH
111748: LD_VAR 0 4
111752: PPUSH
111753: LD_VAR 0 7
111757: PPUSH
111758: CALL_OW 3
111762: ST_TO_ADDR
// units_path := Delete ( units_path , i ) ;
111763: LD_ADDR_VAR 0 16
111767: PUSH
111768: LD_VAR 0 16
111772: PPUSH
111773: LD_VAR 0 7
111777: PPUSH
111778: CALL_OW 3
111782: ST_TO_ADDR
// continue ;
111783: GO 111623
// end ; if f_repair then
111785: LD_VAR 0 22
111789: IFFALSE 112278
// begin if GetType ( group [ i ] ) = unit_vehicle then
111791: LD_VAR 0 4
111795: PUSH
111796: LD_VAR 0 7
111800: ARRAY
111801: PPUSH
111802: CALL_OW 247
111806: PUSH
111807: LD_INT 2
111809: EQUAL
111810: IFFALSE 112000
// begin if GetLives ( group [ i ] ) < 700 and not group [ i ] in to_repair then
111812: LD_VAR 0 4
111816: PUSH
111817: LD_VAR 0 7
111821: ARRAY
111822: PPUSH
111823: CALL_OW 256
111827: PUSH
111828: LD_INT 700
111830: LESS
111831: PUSH
111832: LD_VAR 0 4
111836: PUSH
111837: LD_VAR 0 7
111841: ARRAY
111842: PUSH
111843: LD_VAR 0 32
111847: IN
111848: NOT
111849: AND
111850: IFFALSE 111874
// to_repair := to_repair union group [ i ] ;
111852: LD_ADDR_VAR 0 32
111856: PUSH
111857: LD_VAR 0 32
111861: PUSH
111862: LD_VAR 0 4
111866: PUSH
111867: LD_VAR 0 7
111871: ARRAY
111872: UNION
111873: ST_TO_ADDR
// if GetLives ( group [ i ] ) = 1000 and group [ i ] in to_repair then
111874: LD_VAR 0 4
111878: PUSH
111879: LD_VAR 0 7
111883: ARRAY
111884: PPUSH
111885: CALL_OW 256
111889: PUSH
111890: LD_INT 1000
111892: EQUAL
111893: PUSH
111894: LD_VAR 0 4
111898: PUSH
111899: LD_VAR 0 7
111903: ARRAY
111904: PUSH
111905: LD_VAR 0 32
111909: IN
111910: AND
111911: IFFALSE 111935
// to_repair := to_repair diff group [ i ] ;
111913: LD_ADDR_VAR 0 32
111917: PUSH
111918: LD_VAR 0 32
111922: PUSH
111923: LD_VAR 0 4
111927: PUSH
111928: LD_VAR 0 7
111932: ARRAY
111933: DIFF
111934: ST_TO_ADDR
// if group [ i ] in to_repair then
111935: LD_VAR 0 4
111939: PUSH
111940: LD_VAR 0 7
111944: ARRAY
111945: PUSH
111946: LD_VAR 0 32
111950: IN
111951: IFFALSE 111998
// begin if not IsInArea ( group [ i ] , f_repair ) then
111953: LD_VAR 0 4
111957: PUSH
111958: LD_VAR 0 7
111962: ARRAY
111963: PPUSH
111964: LD_VAR 0 22
111968: PPUSH
111969: CALL_OW 308
111973: NOT
111974: IFFALSE 111996
// ComMoveToArea ( group [ i ] , f_repair ) ;
111976: LD_VAR 0 4
111980: PUSH
111981: LD_VAR 0 7
111985: ARRAY
111986: PPUSH
111987: LD_VAR 0 22
111991: PPUSH
111992: CALL_OW 113
// continue ;
111996: GO 111623
// end ; end else
111998: GO 112278
// if group [ i ] in repairs then
112000: LD_VAR 0 4
112004: PUSH
112005: LD_VAR 0 7
112009: ARRAY
112010: PUSH
112011: LD_VAR 0 33
112015: IN
112016: IFFALSE 112278
// begin if IsInUnit ( group [ i ] ) then
112018: LD_VAR 0 4
112022: PUSH
112023: LD_VAR 0 7
112027: ARRAY
112028: PPUSH
112029: CALL_OW 310
112033: IFFALSE 112101
// begin z := IsInUnit ( group [ i ] ) ;
112035: LD_ADDR_VAR 0 13
112039: PUSH
112040: LD_VAR 0 4
112044: PUSH
112045: LD_VAR 0 7
112049: ARRAY
112050: PPUSH
112051: CALL_OW 310
112055: ST_TO_ADDR
// if z in to_repair and IsInArea ( z , f_repair ) then
112056: LD_VAR 0 13
112060: PUSH
112061: LD_VAR 0 32
112065: IN
112066: PUSH
112067: LD_VAR 0 13
112071: PPUSH
112072: LD_VAR 0 22
112076: PPUSH
112077: CALL_OW 308
112081: AND
112082: IFFALSE 112099
// ComExitVehicle ( group [ i ] ) ;
112084: LD_VAR 0 4
112088: PUSH
112089: LD_VAR 0 7
112093: ARRAY
112094: PPUSH
112095: CALL_OW 121
// end else
112099: GO 112278
// begin z := UnitFilter ( group , [ [ f_inarea , f_repair ] , [ f_empty ] ] ) ;
112101: LD_ADDR_VAR 0 13
112105: PUSH
112106: LD_VAR 0 4
112110: PPUSH
112111: LD_INT 95
112113: PUSH
112114: LD_VAR 0 22
112118: PUSH
112119: EMPTY
112120: LIST
112121: LIST
112122: PUSH
112123: LD_INT 58
112125: PUSH
112126: EMPTY
112127: LIST
112128: PUSH
112129: EMPTY
112130: LIST
112131: LIST
112132: PPUSH
112133: CALL_OW 72
112137: ST_TO_ADDR
// if not HasTask ( group [ i ] ) then
112138: LD_VAR 0 4
112142: PUSH
112143: LD_VAR 0 7
112147: ARRAY
112148: PPUSH
112149: CALL_OW 314
112153: NOT
112154: IFFALSE 112276
// begin x := NearestUnitToUnit ( z , group [ i ] ) ;
112156: LD_ADDR_VAR 0 10
112160: PUSH
112161: LD_VAR 0 13
112165: PPUSH
112166: LD_VAR 0 4
112170: PUSH
112171: LD_VAR 0 7
112175: ARRAY
112176: PPUSH
112177: CALL_OW 74
112181: ST_TO_ADDR
// if not x then
112182: LD_VAR 0 10
112186: NOT
112187: IFFALSE 112191
// continue ;
112189: GO 111623
// if GetLives ( x ) < 1000 then
112191: LD_VAR 0 10
112195: PPUSH
112196: CALL_OW 256
112200: PUSH
112201: LD_INT 1000
112203: LESS
112204: IFFALSE 112228
// ComRepairVehicle ( group [ i ] , x ) else
112206: LD_VAR 0 4
112210: PUSH
112211: LD_VAR 0 7
112215: ARRAY
112216: PPUSH
112217: LD_VAR 0 10
112221: PPUSH
112222: CALL_OW 129
112226: GO 112276
// if not ( f_heal and GetLives ( group [ i ] ) < 1000 ) then
112228: LD_VAR 0 23
112232: PUSH
112233: LD_VAR 0 4
112237: PUSH
112238: LD_VAR 0 7
112242: ARRAY
112243: PPUSH
112244: CALL_OW 256
112248: PUSH
112249: LD_INT 1000
112251: LESS
112252: AND
112253: NOT
112254: IFFALSE 112276
// ComEnterUnit ( group [ i ] , x ) ;
112256: LD_VAR 0 4
112260: PUSH
112261: LD_VAR 0 7
112265: ARRAY
112266: PPUSH
112267: LD_VAR 0 10
112271: PPUSH
112272: CALL_OW 120
// end ; continue ;
112276: GO 111623
// end ; end ; end ; if f_heal and GetType ( group [ i ] ) = unit_human then
112278: LD_VAR 0 23
112282: PUSH
112283: LD_VAR 0 4
112287: PUSH
112288: LD_VAR 0 7
112292: ARRAY
112293: PPUSH
112294: CALL_OW 247
112298: PUSH
112299: LD_INT 1
112301: EQUAL
112302: AND
112303: IFFALSE 112781
// begin if group [ i ] in healers then
112305: LD_VAR 0 4
112309: PUSH
112310: LD_VAR 0 7
112314: ARRAY
112315: PUSH
112316: LD_VAR 0 31
112320: IN
112321: IFFALSE 112594
// begin if not IsInArea ( group [ i ] , f_heal ) and not HasTask ( group [ i ] ) then
112323: LD_VAR 0 4
112327: PUSH
112328: LD_VAR 0 7
112332: ARRAY
112333: PPUSH
112334: LD_VAR 0 23
112338: PPUSH
112339: CALL_OW 308
112343: NOT
112344: PUSH
112345: LD_VAR 0 4
112349: PUSH
112350: LD_VAR 0 7
112354: ARRAY
112355: PPUSH
112356: CALL_OW 314
112360: NOT
112361: AND
112362: IFFALSE 112386
// ComMoveToArea ( group [ i ] , f_heal ) else
112364: LD_VAR 0 4
112368: PUSH
112369: LD_VAR 0 7
112373: ARRAY
112374: PPUSH
112375: LD_VAR 0 23
112379: PPUSH
112380: CALL_OW 113
112384: GO 112592
// if GetLives ( HealTarget ( group [ i ] ) ) = 1000 then
112386: LD_VAR 0 4
112390: PUSH
112391: LD_VAR 0 7
112395: ARRAY
112396: PPUSH
112397: CALL 86092 0 1
112401: PPUSH
112402: CALL_OW 256
112406: PUSH
112407: LD_INT 1000
112409: EQUAL
112410: IFFALSE 112429
// ComStop ( group [ i ] ) else
112412: LD_VAR 0 4
112416: PUSH
112417: LD_VAR 0 7
112421: ARRAY
112422: PPUSH
112423: CALL_OW 141
112427: GO 112592
// if not HasTask ( group [ i ] ) and to_heal then
112429: LD_VAR 0 4
112433: PUSH
112434: LD_VAR 0 7
112438: ARRAY
112439: PPUSH
112440: CALL_OW 314
112444: NOT
112445: PUSH
112446: LD_VAR 0 30
112450: AND
112451: IFFALSE 112592
// begin z := NearestUnitToUnit ( UnitFilter ( to_heal , [ f_not , [ f_inside ] ] ) , group [ i ] ) ;
112453: LD_ADDR_VAR 0 13
112457: PUSH
112458: LD_VAR 0 30
112462: PPUSH
112463: LD_INT 3
112465: PUSH
112466: LD_INT 54
112468: PUSH
112469: EMPTY
112470: LIST
112471: PUSH
112472: EMPTY
112473: LIST
112474: LIST
112475: PPUSH
112476: CALL_OW 72
112480: PPUSH
112481: LD_VAR 0 4
112485: PUSH
112486: LD_VAR 0 7
112490: ARRAY
112491: PPUSH
112492: CALL_OW 74
112496: ST_TO_ADDR
// if z then
112497: LD_VAR 0 13
112501: IFFALSE 112592
// if FilterAllUnits ( [ [ f_dist , z , 10 ] , [ f_enemy , GetSide ( z ) ] ] ) = 0 then
112503: LD_INT 91
112505: PUSH
112506: LD_VAR 0 13
112510: PUSH
112511: LD_INT 10
112513: PUSH
112514: EMPTY
112515: LIST
112516: LIST
112517: LIST
112518: PUSH
112519: LD_INT 81
112521: PUSH
112522: LD_VAR 0 13
112526: PPUSH
112527: CALL_OW 255
112531: PUSH
112532: EMPTY
112533: LIST
112534: LIST
112535: PUSH
112536: EMPTY
112537: LIST
112538: LIST
112539: PPUSH
112540: CALL_OW 69
112544: PUSH
112545: LD_INT 0
112547: EQUAL
112548: IFFALSE 112572
// ComHeal ( group [ i ] , z ) else
112550: LD_VAR 0 4
112554: PUSH
112555: LD_VAR 0 7
112559: ARRAY
112560: PPUSH
112561: LD_VAR 0 13
112565: PPUSH
112566: CALL_OW 128
112570: GO 112592
// ComMoveToArea ( group [ i ] , f_heal ) ;
112572: LD_VAR 0 4
112576: PUSH
112577: LD_VAR 0 7
112581: ARRAY
112582: PPUSH
112583: LD_VAR 0 23
112587: PPUSH
112588: CALL_OW 113
// end ; continue ;
112592: GO 111623
// end ; if GetLives ( group [ i ] ) < 700 and not group [ i ] in to_heal then
112594: LD_VAR 0 4
112598: PUSH
112599: LD_VAR 0 7
112603: ARRAY
112604: PPUSH
112605: CALL_OW 256
112609: PUSH
112610: LD_INT 700
112612: LESS
112613: PUSH
112614: LD_VAR 0 4
112618: PUSH
112619: LD_VAR 0 7
112623: ARRAY
112624: PUSH
112625: LD_VAR 0 30
112629: IN
112630: NOT
112631: AND
112632: IFFALSE 112656
// to_heal := to_heal union group [ i ] ;
112634: LD_ADDR_VAR 0 30
112638: PUSH
112639: LD_VAR 0 30
112643: PUSH
112644: LD_VAR 0 4
112648: PUSH
112649: LD_VAR 0 7
112653: ARRAY
112654: UNION
112655: ST_TO_ADDR
// if group [ i ] in to_heal then
112656: LD_VAR 0 4
112660: PUSH
112661: LD_VAR 0 7
112665: ARRAY
112666: PUSH
112667: LD_VAR 0 30
112671: IN
112672: IFFALSE 112781
// begin if GetLives ( group [ i ] ) = 1000 then
112674: LD_VAR 0 4
112678: PUSH
112679: LD_VAR 0 7
112683: ARRAY
112684: PPUSH
112685: CALL_OW 256
112689: PUSH
112690: LD_INT 1000
112692: EQUAL
112693: IFFALSE 112719
// to_heal := to_heal diff group [ i ] else
112695: LD_ADDR_VAR 0 30
112699: PUSH
112700: LD_VAR 0 30
112704: PUSH
112705: LD_VAR 0 4
112709: PUSH
112710: LD_VAR 0 7
112714: ARRAY
112715: DIFF
112716: ST_TO_ADDR
112717: GO 112781
// begin if not IsInArea ( group [ i ] , to_heal ) then
112719: LD_VAR 0 4
112723: PUSH
112724: LD_VAR 0 7
112728: ARRAY
112729: PPUSH
112730: LD_VAR 0 30
112734: PPUSH
112735: CALL_OW 308
112739: NOT
112740: IFFALSE 112764
// ComMoveToArea ( group [ i ] , f_heal ) else
112742: LD_VAR 0 4
112746: PUSH
112747: LD_VAR 0 7
112751: ARRAY
112752: PPUSH
112753: LD_VAR 0 23
112757: PPUSH
112758: CALL_OW 113
112762: GO 112779
// ComHold ( group [ i ] ) ;
112764: LD_VAR 0 4
112768: PUSH
112769: LD_VAR 0 7
112773: ARRAY
112774: PPUSH
112775: CALL_OW 140
// continue ;
112779: GO 111623
// end ; end ; end ; if not EnemyInRange ( group [ i ] , 10 ) and not units_path [ i ] = [ ] then
112781: LD_VAR 0 4
112785: PUSH
112786: LD_VAR 0 7
112790: ARRAY
112791: PPUSH
112792: LD_INT 10
112794: PPUSH
112795: CALL 84512 0 2
112799: NOT
112800: PUSH
112801: LD_VAR 0 16
112805: PUSH
112806: LD_VAR 0 7
112810: ARRAY
112811: PUSH
112812: EMPTY
112813: EQUAL
112814: NOT
112815: AND
112816: IFFALSE 113082
// begin if GetEngine ( group [ i ] ) in [ engine_combustion , engine_solar ] then
112818: LD_VAR 0 4
112822: PUSH
112823: LD_VAR 0 7
112827: ARRAY
112828: PPUSH
112829: CALL_OW 262
112833: PUSH
112834: LD_INT 1
112836: PUSH
112837: LD_INT 2
112839: PUSH
112840: EMPTY
112841: LIST
112842: LIST
112843: IN
112844: IFFALSE 112885
// if GetFuel ( group [ i ] ) < 10 then
112846: LD_VAR 0 4
112850: PUSH
112851: LD_VAR 0 7
112855: ARRAY
112856: PPUSH
112857: CALL_OW 261
112861: PUSH
112862: LD_INT 10
112864: LESS
112865: IFFALSE 112885
// SetFuel ( group [ i ] , 12 ) ;
112867: LD_VAR 0 4
112871: PUSH
112872: LD_VAR 0 7
112876: ARRAY
112877: PPUSH
112878: LD_INT 12
112880: PPUSH
112881: CALL_OW 240
// if units_path [ i ] then
112885: LD_VAR 0 16
112889: PUSH
112890: LD_VAR 0 7
112894: ARRAY
112895: IFFALSE 113080
// begin if GetDistUnitXY ( group [ i ] , units_path [ i ] [ 1 ] [ 1 ] , units_path [ i ] [ 1 ] [ 2 ] ) > 6 then
112897: LD_VAR 0 4
112901: PUSH
112902: LD_VAR 0 7
112906: ARRAY
112907: PPUSH
112908: LD_VAR 0 16
112912: PUSH
112913: LD_VAR 0 7
112917: ARRAY
112918: PUSH
112919: LD_INT 1
112921: ARRAY
112922: PUSH
112923: LD_INT 1
112925: ARRAY
112926: PPUSH
112927: LD_VAR 0 16
112931: PUSH
112932: LD_VAR 0 7
112936: ARRAY
112937: PUSH
112938: LD_INT 1
112940: ARRAY
112941: PUSH
112942: LD_INT 2
112944: ARRAY
112945: PPUSH
112946: CALL_OW 297
112950: PUSH
112951: LD_INT 6
112953: GREATER
112954: IFFALSE 113029
// begin if not HasTask ( group [ i ] ) then
112956: LD_VAR 0 4
112960: PUSH
112961: LD_VAR 0 7
112965: ARRAY
112966: PPUSH
112967: CALL_OW 314
112971: NOT
112972: IFFALSE 113027
// ComAgressiveMove ( group [ i ] , units_path [ i ] [ 1 ] [ 1 ] , units_path [ i ] [ 1 ] [ 2 ] ) ;
112974: LD_VAR 0 4
112978: PUSH
112979: LD_VAR 0 7
112983: ARRAY
112984: PPUSH
112985: LD_VAR 0 16
112989: PUSH
112990: LD_VAR 0 7
112994: ARRAY
112995: PUSH
112996: LD_INT 1
112998: ARRAY
112999: PUSH
113000: LD_INT 1
113002: ARRAY
113003: PPUSH
113004: LD_VAR 0 16
113008: PUSH
113009: LD_VAR 0 7
113013: ARRAY
113014: PUSH
113015: LD_INT 1
113017: ARRAY
113018: PUSH
113019: LD_INT 2
113021: ARRAY
113022: PPUSH
113023: CALL_OW 114
// end else
113027: GO 113080
// begin tmp2 := Delete ( units_path [ i ] , 1 ) ;
113029: LD_ADDR_VAR 0 15
113033: PUSH
113034: LD_VAR 0 16
113038: PUSH
113039: LD_VAR 0 7
113043: ARRAY
113044: PPUSH
113045: LD_INT 1
113047: PPUSH
113048: CALL_OW 3
113052: ST_TO_ADDR
// units_path := Replace ( units_path , i , tmp2 ) ;
113053: LD_ADDR_VAR 0 16
113057: PUSH
113058: LD_VAR 0 16
113062: PPUSH
113063: LD_VAR 0 7
113067: PPUSH
113068: LD_VAR 0 15
113072: PPUSH
113073: CALL_OW 1
113077: ST_TO_ADDR
// continue ;
113078: GO 111623
// end ; end ; end else
113080: GO 115744
// begin tmp := FilterAllUnits ( [ f_enemy , GetSide ( group [ i ] ) ] ) ;
113082: LD_ADDR_VAR 0 14
113086: PUSH
113087: LD_INT 81
113089: PUSH
113090: LD_VAR 0 4
113094: PUSH
113095: LD_VAR 0 7
113099: ARRAY
113100: PPUSH
113101: CALL_OW 255
113105: PUSH
113106: EMPTY
113107: LIST
113108: LIST
113109: PPUSH
113110: CALL_OW 69
113114: ST_TO_ADDR
// if not tmp then
113115: LD_VAR 0 14
113119: NOT
113120: IFFALSE 113124
// continue ;
113122: GO 111623
// if f_ignore_area then
113124: LD_VAR 0 17
113128: IFFALSE 113216
// begin tmp2 := UnitFilter ( tmp , [ f_not , [ f_distxy , f_ignore_area [ 1 ] , f_ignore_area [ 2 ] , f_ignore_area [ 3 ] ] ] ) ;
113130: LD_ADDR_VAR 0 15
113134: PUSH
113135: LD_VAR 0 14
113139: PPUSH
113140: LD_INT 3
113142: PUSH
113143: LD_INT 92
113145: PUSH
113146: LD_VAR 0 17
113150: PUSH
113151: LD_INT 1
113153: ARRAY
113154: PUSH
113155: LD_VAR 0 17
113159: PUSH
113160: LD_INT 2
113162: ARRAY
113163: PUSH
113164: LD_VAR 0 17
113168: PUSH
113169: LD_INT 3
113171: ARRAY
113172: PUSH
113173: EMPTY
113174: LIST
113175: LIST
113176: LIST
113177: LIST
113178: PUSH
113179: EMPTY
113180: LIST
113181: LIST
113182: PPUSH
113183: CALL_OW 72
113187: ST_TO_ADDR
// if ( tmp diff tmp2 ) then
113188: LD_VAR 0 14
113192: PUSH
113193: LD_VAR 0 15
113197: DIFF
113198: IFFALSE 113216
// tmp := tmp diff tmp2 ;
113200: LD_ADDR_VAR 0 14
113204: PUSH
113205: LD_VAR 0 14
113209: PUSH
113210: LD_VAR 0 15
113214: DIFF
113215: ST_TO_ADDR
// end ; if not f_murder then
113216: LD_VAR 0 20
113220: NOT
113221: IFFALSE 113279
// begin tmp2 := UnitFilter ( tmp , [ f_not , [ f_ok ] ] ) ;
113223: LD_ADDR_VAR 0 15
113227: PUSH
113228: LD_VAR 0 14
113232: PPUSH
113233: LD_INT 3
113235: PUSH
113236: LD_INT 50
113238: PUSH
113239: EMPTY
113240: LIST
113241: PUSH
113242: EMPTY
113243: LIST
113244: LIST
113245: PPUSH
113246: CALL_OW 72
113250: ST_TO_ADDR
// if ( tmp diff tmp2 ) then
113251: LD_VAR 0 14
113255: PUSH
113256: LD_VAR 0 15
113260: DIFF
113261: IFFALSE 113279
// tmp := tmp diff tmp2 ;
113263: LD_ADDR_VAR 0 14
113267: PUSH
113268: LD_VAR 0 14
113272: PUSH
113273: LD_VAR 0 15
113277: DIFF
113278: ST_TO_ADDR
// end ; tmp := SortByDistanceUnit ( group [ i ] , tmp , true , true ) ;
113279: LD_ADDR_VAR 0 14
113283: PUSH
113284: LD_VAR 0 4
113288: PUSH
113289: LD_VAR 0 7
113293: ARRAY
113294: PPUSH
113295: LD_VAR 0 14
113299: PPUSH
113300: LD_INT 1
113302: PPUSH
113303: LD_INT 1
113305: PPUSH
113306: CALL 57447 0 4
113310: ST_TO_ADDR
// if GetClass ( group [ i ] ) = 1 then
113311: LD_VAR 0 4
113315: PUSH
113316: LD_VAR 0 7
113320: ARRAY
113321: PPUSH
113322: CALL_OW 257
113326: PUSH
113327: LD_INT 1
113329: EQUAL
113330: IFFALSE 113778
// begin if WantPlant ( group [ i ] ) then
113332: LD_VAR 0 4
113336: PUSH
113337: LD_VAR 0 7
113341: ARRAY
113342: PPUSH
113343: CALL 56948 0 1
113347: IFFALSE 113351
// continue ;
113349: GO 111623
// if f_capture and not IsInUnit ( group [ i ] ) and tmp [ 1 ] in UnitFilter ( tmp , [ [ f_type , unit_vehicle ] , [ f_empty ] ] ) then
113351: LD_VAR 0 18
113355: PUSH
113356: LD_VAR 0 4
113360: PUSH
113361: LD_VAR 0 7
113365: ARRAY
113366: PPUSH
113367: CALL_OW 310
113371: NOT
113372: AND
113373: PUSH
113374: LD_VAR 0 14
113378: PUSH
113379: LD_INT 1
113381: ARRAY
113382: PUSH
113383: LD_VAR 0 14
113387: PPUSH
113388: LD_INT 21
113390: PUSH
113391: LD_INT 2
113393: PUSH
113394: EMPTY
113395: LIST
113396: LIST
113397: PUSH
113398: LD_INT 58
113400: PUSH
113401: EMPTY
113402: LIST
113403: PUSH
113404: EMPTY
113405: LIST
113406: LIST
113407: PPUSH
113408: CALL_OW 72
113412: IN
113413: AND
113414: IFFALSE 113450
// begin ComEnterUnit ( group [ i ] , tmp [ 1 ] ) ;
113416: LD_VAR 0 4
113420: PUSH
113421: LD_VAR 0 7
113425: ARRAY
113426: PPUSH
113427: LD_VAR 0 14
113431: PUSH
113432: LD_INT 1
113434: ARRAY
113435: PPUSH
113436: CALL_OW 120
// attacking := true ;
113440: LD_ADDR_VAR 0 29
113444: PUSH
113445: LD_INT 1
113447: ST_TO_ADDR
// continue ;
113448: GO 111623
// end ; if f_crawl and GetClass ( group [ i ] ) = 1 and GetLives ( group [ i ] ) < 800 and not Crawls ( group [ i ] ) then
113450: LD_VAR 0 26
113454: PUSH
113455: LD_VAR 0 4
113459: PUSH
113460: LD_VAR 0 7
113464: ARRAY
113465: PPUSH
113466: CALL_OW 257
113470: PUSH
113471: LD_INT 1
113473: EQUAL
113474: AND
113475: PUSH
113476: LD_VAR 0 4
113480: PUSH
113481: LD_VAR 0 7
113485: ARRAY
113486: PPUSH
113487: CALL_OW 256
113491: PUSH
113492: LD_INT 800
113494: LESS
113495: AND
113496: PUSH
113497: LD_VAR 0 4
113501: PUSH
113502: LD_VAR 0 7
113506: ARRAY
113507: PPUSH
113508: CALL_OW 318
113512: NOT
113513: AND
113514: IFFALSE 113531
// ComCrawl ( group [ i ] ) ;
113516: LD_VAR 0 4
113520: PUSH
113521: LD_VAR 0 7
113525: ARRAY
113526: PPUSH
113527: CALL_OW 137
// if f_mines then
113531: LD_VAR 0 21
113535: IFFALSE 113778
// begin if GetType ( tmp [ 1 ] ) = unit_building and not tmp [ 1 ] in mined then
113537: LD_VAR 0 14
113541: PUSH
113542: LD_INT 1
113544: ARRAY
113545: PPUSH
113546: CALL_OW 247
113550: PUSH
113551: LD_INT 3
113553: EQUAL
113554: PUSH
113555: LD_VAR 0 14
113559: PUSH
113560: LD_INT 1
113562: ARRAY
113563: PUSH
113564: LD_VAR 0 27
113568: IN
113569: NOT
113570: AND
113571: IFFALSE 113778
// begin x := GetX ( tmp [ 1 ] ) ;
113573: LD_ADDR_VAR 0 10
113577: PUSH
113578: LD_VAR 0 14
113582: PUSH
113583: LD_INT 1
113585: ARRAY
113586: PPUSH
113587: CALL_OW 250
113591: ST_TO_ADDR
// y := GetY ( tmp [ 1 ] ) ;
113592: LD_ADDR_VAR 0 11
113596: PUSH
113597: LD_VAR 0 14
113601: PUSH
113602: LD_INT 1
113604: ARRAY
113605: PPUSH
113606: CALL_OW 251
113610: ST_TO_ADDR
// d := ReverseDir ( group [ i ] ) ;
113611: LD_ADDR_VAR 0 12
113615: PUSH
113616: LD_VAR 0 4
113620: PUSH
113621: LD_VAR 0 7
113625: ARRAY
113626: PPUSH
113627: CALL 84597 0 1
113631: ST_TO_ADDR
// ComPlaceDelayedCharge ( group [ i ] , x , y , tmp [ 1 ] ) ;
113632: LD_VAR 0 4
113636: PUSH
113637: LD_VAR 0 7
113641: ARRAY
113642: PPUSH
113643: LD_VAR 0 10
113647: PPUSH
113648: LD_VAR 0 11
113652: PPUSH
113653: LD_VAR 0 14
113657: PUSH
113658: LD_INT 1
113660: ARRAY
113661: PPUSH
113662: CALL_OW 132
// AddComMoveXY ( group [ i ] , ShiftX ( x , d , 7 ) , ShiftY ( y , d , 7 ) ) ;
113666: LD_VAR 0 4
113670: PUSH
113671: LD_VAR 0 7
113675: ARRAY
113676: PPUSH
113677: LD_VAR 0 10
113681: PPUSH
113682: LD_VAR 0 12
113686: PPUSH
113687: LD_INT 7
113689: PPUSH
113690: CALL_OW 272
113694: PPUSH
113695: LD_VAR 0 11
113699: PPUSH
113700: LD_VAR 0 12
113704: PPUSH
113705: LD_INT 7
113707: PPUSH
113708: CALL_OW 273
113712: PPUSH
113713: CALL_OW 171
// SetTag ( group [ i ] , 71 ) ;
113717: LD_VAR 0 4
113721: PUSH
113722: LD_VAR 0 7
113726: ARRAY
113727: PPUSH
113728: LD_INT 71
113730: PPUSH
113731: CALL_OW 109
// mined := Replace ( mined , mined + 1 , tmp [ 1 ] ) ;
113735: LD_ADDR_VAR 0 27
113739: PUSH
113740: LD_VAR 0 27
113744: PPUSH
113745: LD_VAR 0 27
113749: PUSH
113750: LD_INT 1
113752: PLUS
113753: PPUSH
113754: LD_VAR 0 14
113758: PUSH
113759: LD_INT 1
113761: ARRAY
113762: PPUSH
113763: CALL_OW 1
113767: ST_TO_ADDR
// attacking := true ;
113768: LD_ADDR_VAR 0 29
113772: PUSH
113773: LD_INT 1
113775: ST_TO_ADDR
// continue ;
113776: GO 111623
// end ; end ; end ; if GetClass ( group [ i ] ) = 17 and not GetTag ( group [ i ] ) = 71 then
113778: LD_VAR 0 4
113782: PUSH
113783: LD_VAR 0 7
113787: ARRAY
113788: PPUSH
113789: CALL_OW 257
113793: PUSH
113794: LD_INT 17
113796: EQUAL
113797: PUSH
113798: LD_VAR 0 4
113802: PUSH
113803: LD_VAR 0 7
113807: ARRAY
113808: PPUSH
113809: CALL_OW 110
113813: PUSH
113814: LD_INT 71
113816: EQUAL
113817: NOT
113818: AND
113819: IFFALSE 113965
// begin attacking := false ;
113821: LD_ADDR_VAR 0 29
113825: PUSH
113826: LD_INT 0
113828: ST_TO_ADDR
// k := 5 ;
113829: LD_ADDR_VAR 0 9
113833: PUSH
113834: LD_INT 5
113836: ST_TO_ADDR
// if tmp < k then
113837: LD_VAR 0 14
113841: PUSH
113842: LD_VAR 0 9
113846: LESS
113847: IFFALSE 113859
// k := tmp ;
113849: LD_ADDR_VAR 0 9
113853: PUSH
113854: LD_VAR 0 14
113858: ST_TO_ADDR
// for j = 1 to k do
113859: LD_ADDR_VAR 0 8
113863: PUSH
113864: DOUBLE
113865: LD_INT 1
113867: DEC
113868: ST_TO_ADDR
113869: LD_VAR 0 9
113873: PUSH
113874: FOR_TO
113875: IFFALSE 113963
// begin if not tmp [ j ] in UnitFilter ( tmp , [ f_empty ] ) then
113877: LD_VAR 0 14
113881: PUSH
113882: LD_VAR 0 8
113886: ARRAY
113887: PUSH
113888: LD_VAR 0 14
113892: PPUSH
113893: LD_INT 58
113895: PUSH
113896: EMPTY
113897: LIST
113898: PPUSH
113899: CALL_OW 72
113903: IN
113904: NOT
113905: IFFALSE 113961
// begin ComAttackUnit ( group [ i ] , tmp [ j ] ) ;
113907: LD_VAR 0 4
113911: PUSH
113912: LD_VAR 0 7
113916: ARRAY
113917: PPUSH
113918: LD_VAR 0 14
113922: PUSH
113923: LD_VAR 0 8
113927: ARRAY
113928: PPUSH
113929: CALL_OW 115
// attacking := true ;
113933: LD_ADDR_VAR 0 29
113937: PUSH
113938: LD_INT 1
113940: ST_TO_ADDR
// SetTag ( group [ i ] , 71 ) ;
113941: LD_VAR 0 4
113945: PUSH
113946: LD_VAR 0 7
113950: ARRAY
113951: PPUSH
113952: LD_INT 71
113954: PPUSH
113955: CALL_OW 109
// continue ;
113959: GO 113874
// end ; end ;
113961: GO 113874
113963: POP
113964: POP
// end ; if GetClass ( group [ i ] ) = 8 or GetWeapon ( group [ i ] ) in [ ar_rocket_launcher , ru_rocket_launcher , us_rocket_launcher , ru_rocket ] then
113965: LD_VAR 0 4
113969: PUSH
113970: LD_VAR 0 7
113974: ARRAY
113975: PPUSH
113976: CALL_OW 257
113980: PUSH
113981: LD_INT 8
113983: EQUAL
113984: PUSH
113985: LD_VAR 0 4
113989: PUSH
113990: LD_VAR 0 7
113994: ARRAY
113995: PPUSH
113996: CALL_OW 264
114000: PUSH
114001: LD_INT 28
114003: PUSH
114004: LD_INT 45
114006: PUSH
114007: LD_INT 7
114009: PUSH
114010: LD_INT 47
114012: PUSH
114013: EMPTY
114014: LIST
114015: LIST
114016: LIST
114017: LIST
114018: IN
114019: OR
114020: IFFALSE 114276
// begin attacking := false ;
114022: LD_ADDR_VAR 0 29
114026: PUSH
114027: LD_INT 0
114029: ST_TO_ADDR
// if GetBType ( tmp [ 1 ] ) in [ b_bunker , b_breastwork , b_turret , b_armoury , b_barracks ] then
114030: LD_VAR 0 14
114034: PUSH
114035: LD_INT 1
114037: ARRAY
114038: PPUSH
114039: CALL_OW 266
114043: PUSH
114044: LD_INT 32
114046: PUSH
114047: LD_INT 31
114049: PUSH
114050: LD_INT 33
114052: PUSH
114053: LD_INT 4
114055: PUSH
114056: LD_INT 5
114058: PUSH
114059: EMPTY
114060: LIST
114061: LIST
114062: LIST
114063: LIST
114064: LIST
114065: IN
114066: IFFALSE 114252
// begin k := GetBuildingHexes ( GetBType ( tmp [ 1 ] ) , GetX ( tmp [ 1 ] ) , GetY ( tmp [ 1 ] ) , GetDir ( tmp [ 1 ] ) , GetNation ( tmp [ 1 ] ) , 0 ) ;
114068: LD_ADDR_VAR 0 9
114072: PUSH
114073: LD_VAR 0 14
114077: PUSH
114078: LD_INT 1
114080: ARRAY
114081: PPUSH
114082: CALL_OW 266
114086: PPUSH
114087: LD_VAR 0 14
114091: PUSH
114092: LD_INT 1
114094: ARRAY
114095: PPUSH
114096: CALL_OW 250
114100: PPUSH
114101: LD_VAR 0 14
114105: PUSH
114106: LD_INT 1
114108: ARRAY
114109: PPUSH
114110: CALL_OW 251
114114: PPUSH
114115: LD_VAR 0 14
114119: PUSH
114120: LD_INT 1
114122: ARRAY
114123: PPUSH
114124: CALL_OW 254
114128: PPUSH
114129: LD_VAR 0 14
114133: PUSH
114134: LD_INT 1
114136: ARRAY
114137: PPUSH
114138: CALL_OW 248
114142: PPUSH
114143: LD_INT 0
114145: PPUSH
114146: CALL 65967 0 6
114150: ST_TO_ADDR
// j := GetClosestHex ( group [ i ] , k ) ;
114151: LD_ADDR_VAR 0 8
114155: PUSH
114156: LD_VAR 0 4
114160: PUSH
114161: LD_VAR 0 7
114165: ARRAY
114166: PPUSH
114167: LD_VAR 0 9
114171: PPUSH
114172: CALL 84637 0 2
114176: ST_TO_ADDR
// if j then
114177: LD_VAR 0 8
114181: IFFALSE 114250
// if ValidHex ( j [ 1 ] , j [ 2 ] ) then
114183: LD_VAR 0 8
114187: PUSH
114188: LD_INT 1
114190: ARRAY
114191: PPUSH
114192: LD_VAR 0 8
114196: PUSH
114197: LD_INT 2
114199: ARRAY
114200: PPUSH
114201: CALL_OW 488
114205: IFFALSE 114250
// begin ComAttackPlace ( group [ i ] , j [ 1 ] , j [ 2 ] ) ;
114207: LD_VAR 0 4
114211: PUSH
114212: LD_VAR 0 7
114216: ARRAY
114217: PPUSH
114218: LD_VAR 0 8
114222: PUSH
114223: LD_INT 1
114225: ARRAY
114226: PPUSH
114227: LD_VAR 0 8
114231: PUSH
114232: LD_INT 2
114234: ARRAY
114235: PPUSH
114236: CALL_OW 116
// attacking := true ;
114240: LD_ADDR_VAR 0 29
114244: PUSH
114245: LD_INT 1
114247: ST_TO_ADDR
// continue ;
114248: GO 111623
// end ; end else
114250: GO 114276
// ComAttackUnit ( group [ i ] , tmp [ 1 ] ) ;
114252: LD_VAR 0 4
114256: PUSH
114257: LD_VAR 0 7
114261: ARRAY
114262: PPUSH
114263: LD_VAR 0 14
114267: PUSH
114268: LD_INT 1
114270: ARRAY
114271: PPUSH
114272: CALL_OW 115
// end ; if GetChassis ( group [ i ] ) = ar_hovercraft then
114276: LD_VAR 0 4
114280: PUSH
114281: LD_VAR 0 7
114285: ARRAY
114286: PPUSH
114287: CALL_OW 265
114291: PUSH
114292: LD_INT 11
114294: EQUAL
114295: IFFALSE 114573
// begin k := 10 ;
114297: LD_ADDR_VAR 0 9
114301: PUSH
114302: LD_INT 10
114304: ST_TO_ADDR
// x := 0 ;
114305: LD_ADDR_VAR 0 10
114309: PUSH
114310: LD_INT 0
114312: ST_TO_ADDR
// if tmp < k then
114313: LD_VAR 0 14
114317: PUSH
114318: LD_VAR 0 9
114322: LESS
114323: IFFALSE 114335
// k := tmp ;
114325: LD_ADDR_VAR 0 9
114329: PUSH
114330: LD_VAR 0 14
114334: ST_TO_ADDR
// for j = k downto 1 do
114335: LD_ADDR_VAR 0 8
114339: PUSH
114340: DOUBLE
114341: LD_VAR 0 9
114345: INC
114346: ST_TO_ADDR
114347: LD_INT 1
114349: PUSH
114350: FOR_DOWNTO
114351: IFFALSE 114426
// begin if GetType ( tmp [ j ] ) = unit_human then
114353: LD_VAR 0 14
114357: PUSH
114358: LD_VAR 0 8
114362: ARRAY
114363: PPUSH
114364: CALL_OW 247
114368: PUSH
114369: LD_INT 1
114371: EQUAL
114372: IFFALSE 114424
// begin AttackHovercraft ( group [ i ] , tmp [ j ] ) ;
114374: LD_VAR 0 4
114378: PUSH
114379: LD_VAR 0 7
114383: ARRAY
114384: PPUSH
114385: LD_VAR 0 14
114389: PUSH
114390: LD_VAR 0 8
114394: ARRAY
114395: PPUSH
114396: CALL 84908 0 2
// x := tmp [ j ] ;
114400: LD_ADDR_VAR 0 10
114404: PUSH
114405: LD_VAR 0 14
114409: PUSH
114410: LD_VAR 0 8
114414: ARRAY
114415: ST_TO_ADDR
// attacking := true ;
114416: LD_ADDR_VAR 0 29
114420: PUSH
114421: LD_INT 1
114423: ST_TO_ADDR
// end ; end ;
114424: GO 114350
114426: POP
114427: POP
// if not x then
114428: LD_VAR 0 10
114432: NOT
114433: IFFALSE 114573
// begin attacking := true ;
114435: LD_ADDR_VAR 0 29
114439: PUSH
114440: LD_INT 1
114442: ST_TO_ADDR
// if GetHexInfo ( GetX ( group [ i ] ) , GetY ( group [ i ] ) ) [ 2 ] = GetHexInfo ( GetX ( tmp [ 1 ] ) , GetY ( tmp [ 1 ] ) ) [ 2 ] then
114443: LD_VAR 0 4
114447: PUSH
114448: LD_VAR 0 7
114452: ARRAY
114453: PPUSH
114454: CALL_OW 250
114458: PPUSH
114459: LD_VAR 0 4
114463: PUSH
114464: LD_VAR 0 7
114468: ARRAY
114469: PPUSH
114470: CALL_OW 251
114474: PPUSH
114475: CALL_OW 546
114479: PUSH
114480: LD_INT 2
114482: ARRAY
114483: PUSH
114484: LD_VAR 0 14
114488: PUSH
114489: LD_INT 1
114491: ARRAY
114492: PPUSH
114493: CALL_OW 250
114497: PPUSH
114498: LD_VAR 0 14
114502: PUSH
114503: LD_INT 1
114505: ARRAY
114506: PPUSH
114507: CALL_OW 251
114511: PPUSH
114512: CALL_OW 546
114516: PUSH
114517: LD_INT 2
114519: ARRAY
114520: EQUAL
114521: IFFALSE 114549
// AttackHovercraft ( group [ i ] , tmp [ 1 ] ) else
114523: LD_VAR 0 4
114527: PUSH
114528: LD_VAR 0 7
114532: ARRAY
114533: PPUSH
114534: LD_VAR 0 14
114538: PUSH
114539: LD_INT 1
114541: ARRAY
114542: PPUSH
114543: CALL 84908 0 2
114547: GO 114573
// ComAttackUnit ( group [ i ] , tmp [ 1 ] ) ;
114549: LD_VAR 0 4
114553: PUSH
114554: LD_VAR 0 7
114558: ARRAY
114559: PPUSH
114560: LD_VAR 0 14
114564: PUSH
114565: LD_INT 1
114567: ARRAY
114568: PPUSH
114569: CALL_OW 115
// end ; end ; if GetWeapon ( group [ i ] ) = ar_selfpropelled_bomb then
114573: LD_VAR 0 4
114577: PUSH
114578: LD_VAR 0 7
114582: ARRAY
114583: PPUSH
114584: CALL_OW 264
114588: PUSH
114589: LD_INT 29
114591: EQUAL
114592: IFFALSE 114958
// begin if WantsToAttack ( group [ i ] ) in bombed then
114594: LD_VAR 0 4
114598: PUSH
114599: LD_VAR 0 7
114603: ARRAY
114604: PPUSH
114605: CALL_OW 319
114609: PUSH
114610: LD_VAR 0 28
114614: IN
114615: IFFALSE 114619
// continue ;
114617: GO 111623
// k := 8 ;
114619: LD_ADDR_VAR 0 9
114623: PUSH
114624: LD_INT 8
114626: ST_TO_ADDR
// x := 0 ;
114627: LD_ADDR_VAR 0 10
114631: PUSH
114632: LD_INT 0
114634: ST_TO_ADDR
// if tmp < k then
114635: LD_VAR 0 14
114639: PUSH
114640: LD_VAR 0 9
114644: LESS
114645: IFFALSE 114657
// k := tmp ;
114647: LD_ADDR_VAR 0 9
114651: PUSH
114652: LD_VAR 0 14
114656: ST_TO_ADDR
// for j = 1 to k do
114657: LD_ADDR_VAR 0 8
114661: PUSH
114662: DOUBLE
114663: LD_INT 1
114665: DEC
114666: ST_TO_ADDR
114667: LD_VAR 0 9
114671: PUSH
114672: FOR_TO
114673: IFFALSE 114805
// begin if GetType ( tmp [ j ] ) = unit_building then
114675: LD_VAR 0 14
114679: PUSH
114680: LD_VAR 0 8
114684: ARRAY
114685: PPUSH
114686: CALL_OW 247
114690: PUSH
114691: LD_INT 3
114693: EQUAL
114694: IFFALSE 114803
// if not tmp [ j ] in bombed and UnitsInside ( tmp [ j ] ) then
114696: LD_VAR 0 14
114700: PUSH
114701: LD_VAR 0 8
114705: ARRAY
114706: PUSH
114707: LD_VAR 0 28
114711: IN
114712: NOT
114713: PUSH
114714: LD_VAR 0 14
114718: PUSH
114719: LD_VAR 0 8
114723: ARRAY
114724: PPUSH
114725: CALL_OW 313
114729: AND
114730: IFFALSE 114803
// begin ComAttackUnit ( group [ i ] , tmp [ j ] ) ;
114732: LD_VAR 0 4
114736: PUSH
114737: LD_VAR 0 7
114741: ARRAY
114742: PPUSH
114743: LD_VAR 0 14
114747: PUSH
114748: LD_VAR 0 8
114752: ARRAY
114753: PPUSH
114754: CALL_OW 115
// bombed := Replace ( bombed , bombed + 1 , tmp [ j ] ) ;
114758: LD_ADDR_VAR 0 28
114762: PUSH
114763: LD_VAR 0 28
114767: PPUSH
114768: LD_VAR 0 28
114772: PUSH
114773: LD_INT 1
114775: PLUS
114776: PPUSH
114777: LD_VAR 0 14
114781: PUSH
114782: LD_VAR 0 8
114786: ARRAY
114787: PPUSH
114788: CALL_OW 1
114792: ST_TO_ADDR
// attacking := true ;
114793: LD_ADDR_VAR 0 29
114797: PUSH
114798: LD_INT 1
114800: ST_TO_ADDR
// break ;
114801: GO 114805
// end ; end ;
114803: GO 114672
114805: POP
114806: POP
// if not attacking and f_attack_depot then
114807: LD_VAR 0 29
114811: NOT
114812: PUSH
114813: LD_VAR 0 25
114817: AND
114818: IFFALSE 114913
// begin z := UnitFilter ( tmp , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) ;
114820: LD_ADDR_VAR 0 13
114824: PUSH
114825: LD_VAR 0 14
114829: PPUSH
114830: LD_INT 2
114832: PUSH
114833: LD_INT 30
114835: PUSH
114836: LD_INT 0
114838: PUSH
114839: EMPTY
114840: LIST
114841: LIST
114842: PUSH
114843: LD_INT 30
114845: PUSH
114846: LD_INT 1
114848: PUSH
114849: EMPTY
114850: LIST
114851: LIST
114852: PUSH
114853: EMPTY
114854: LIST
114855: LIST
114856: LIST
114857: PPUSH
114858: CALL_OW 72
114862: ST_TO_ADDR
// if z then
114863: LD_VAR 0 13
114867: IFFALSE 114913
// begin ComAttackUnit ( group [ i ] , NearestUnitToUnit ( z , group [ i ] ) ) ;
114869: LD_VAR 0 4
114873: PUSH
114874: LD_VAR 0 7
114878: ARRAY
114879: PPUSH
114880: LD_VAR 0 13
114884: PPUSH
114885: LD_VAR 0 4
114889: PUSH
114890: LD_VAR 0 7
114894: ARRAY
114895: PPUSH
114896: CALL_OW 74
114900: PPUSH
114901: CALL_OW 115
// attacking := true ;
114905: LD_ADDR_VAR 0 29
114909: PUSH
114910: LD_INT 1
114912: ST_TO_ADDR
// end ; end ; if GetLives ( group [ i ] ) < 500 then
114913: LD_VAR 0 4
114917: PUSH
114918: LD_VAR 0 7
114922: ARRAY
114923: PPUSH
114924: CALL_OW 256
114928: PUSH
114929: LD_INT 500
114931: LESS
114932: IFFALSE 114958
// ComAttackUnit ( group [ i ] , tmp [ 1 ] ) ;
114934: LD_VAR 0 4
114938: PUSH
114939: LD_VAR 0 7
114943: ARRAY
114944: PPUSH
114945: LD_VAR 0 14
114949: PUSH
114950: LD_INT 1
114952: ARRAY
114953: PPUSH
114954: CALL_OW 115
// end ; if GetWeapon ( group [ i ] ) = ru_time_lapser then
114958: LD_VAR 0 4
114962: PUSH
114963: LD_VAR 0 7
114967: ARRAY
114968: PPUSH
114969: CALL_OW 264
114973: PUSH
114974: LD_INT 49
114976: EQUAL
114977: IFFALSE 115098
// begin if not HasTask ( group [ i ] ) then
114979: LD_VAR 0 4
114983: PUSH
114984: LD_VAR 0 7
114988: ARRAY
114989: PPUSH
114990: CALL_OW 314
114994: NOT
114995: IFFALSE 115098
// begin k := NearestUnitToUnit ( FilterAllUnits ( [ f_enemy , GetSide ( group [ i ] ) ] ) , group [ i ] ) ;
114997: LD_ADDR_VAR 0 9
115001: PUSH
115002: LD_INT 81
115004: PUSH
115005: LD_VAR 0 4
115009: PUSH
115010: LD_VAR 0 7
115014: ARRAY
115015: PPUSH
115016: CALL_OW 255
115020: PUSH
115021: EMPTY
115022: LIST
115023: LIST
115024: PPUSH
115025: CALL_OW 69
115029: PPUSH
115030: LD_VAR 0 4
115034: PUSH
115035: LD_VAR 0 7
115039: ARRAY
115040: PPUSH
115041: CALL_OW 74
115045: ST_TO_ADDR
// if k then
115046: LD_VAR 0 9
115050: IFFALSE 115098
// if GetDistUnits ( group [ i ] , k ) > 10 then
115052: LD_VAR 0 4
115056: PUSH
115057: LD_VAR 0 7
115061: ARRAY
115062: PPUSH
115063: LD_VAR 0 9
115067: PPUSH
115068: CALL_OW 296
115072: PUSH
115073: LD_INT 10
115075: GREATER
115076: IFFALSE 115098
// ComMoveUnit ( group [ i ] , k ) ;
115078: LD_VAR 0 4
115082: PUSH
115083: LD_VAR 0 7
115087: ARRAY
115088: PPUSH
115089: LD_VAR 0 9
115093: PPUSH
115094: CALL_OW 112
// end ; end ; if GetLives ( group [ i ] ) < 250 and group [ i ] in FilterAllUnits ( [ [ f_type , unit_vehicle ] , [ f_nation , 2 ] ] ) then
115098: LD_VAR 0 4
115102: PUSH
115103: LD_VAR 0 7
115107: ARRAY
115108: PPUSH
115109: CALL_OW 256
115113: PUSH
115114: LD_INT 250
115116: LESS
115117: PUSH
115118: LD_VAR 0 4
115122: PUSH
115123: LD_VAR 0 7
115127: ARRAY
115128: PUSH
115129: LD_INT 21
115131: PUSH
115132: LD_INT 2
115134: PUSH
115135: EMPTY
115136: LIST
115137: LIST
115138: PUSH
115139: LD_INT 23
115141: PUSH
115142: LD_INT 2
115144: PUSH
115145: EMPTY
115146: LIST
115147: LIST
115148: PUSH
115149: EMPTY
115150: LIST
115151: LIST
115152: PPUSH
115153: CALL_OW 69
115157: IN
115158: AND
115159: IFFALSE 115284
// begin k := NearestUnitToUnit ( all_units diff group [ i ] , group [ i ] ) ;
115161: LD_ADDR_VAR 0 9
115165: PUSH
115166: LD_OWVAR 3
115170: PUSH
115171: LD_VAR 0 4
115175: PUSH
115176: LD_VAR 0 7
115180: ARRAY
115181: DIFF
115182: PPUSH
115183: LD_VAR 0 4
115187: PUSH
115188: LD_VAR 0 7
115192: ARRAY
115193: PPUSH
115194: CALL_OW 74
115198: ST_TO_ADDR
// if not k then
115199: LD_VAR 0 9
115203: NOT
115204: IFFALSE 115208
// continue ;
115206: GO 111623
// if k in FilterAllUnits ( [ f_enemy , GetSide ( group [ i ] ) ] ) and GetDistUnits ( k , group [ i ] ) < 5 then
115208: LD_VAR 0 9
115212: PUSH
115213: LD_INT 81
115215: PUSH
115216: LD_VAR 0 4
115220: PUSH
115221: LD_VAR 0 7
115225: ARRAY
115226: PPUSH
115227: CALL_OW 255
115231: PUSH
115232: EMPTY
115233: LIST
115234: LIST
115235: PPUSH
115236: CALL_OW 69
115240: IN
115241: PUSH
115242: LD_VAR 0 9
115246: PPUSH
115247: LD_VAR 0 4
115251: PUSH
115252: LD_VAR 0 7
115256: ARRAY
115257: PPUSH
115258: CALL_OW 296
115262: PUSH
115263: LD_INT 5
115265: LESS
115266: AND
115267: IFFALSE 115284
// ComAutodestruct ( group [ i ] ) ;
115269: LD_VAR 0 4
115273: PUSH
115274: LD_VAR 0 7
115278: ARRAY
115279: PPUSH
115280: CALL 84806 0 1
// end ; if f_attack_depot then
115284: LD_VAR 0 25
115288: IFFALSE 115400
// begin k := 6 ;
115290: LD_ADDR_VAR 0 9
115294: PUSH
115295: LD_INT 6
115297: ST_TO_ADDR
// if tmp < k then
115298: LD_VAR 0 14
115302: PUSH
115303: LD_VAR 0 9
115307: LESS
115308: IFFALSE 115320
// k := tmp ;
115310: LD_ADDR_VAR 0 9
115314: PUSH
115315: LD_VAR 0 14
115319: ST_TO_ADDR
// for j = 1 to k do
115320: LD_ADDR_VAR 0 8
115324: PUSH
115325: DOUBLE
115326: LD_INT 1
115328: DEC
115329: ST_TO_ADDR
115330: LD_VAR 0 9
115334: PUSH
115335: FOR_TO
115336: IFFALSE 115398
// if GetBType ( j ) in [ b_depot , b_warehouse ] then
115338: LD_VAR 0 8
115342: PPUSH
115343: CALL_OW 266
115347: PUSH
115348: LD_INT 0
115350: PUSH
115351: LD_INT 1
115353: PUSH
115354: EMPTY
115355: LIST
115356: LIST
115357: IN
115358: IFFALSE 115396
// begin ComAttackUnit ( group [ i ] , tmp [ j ] ) ;
115360: LD_VAR 0 4
115364: PUSH
115365: LD_VAR 0 7
115369: ARRAY
115370: PPUSH
115371: LD_VAR 0 14
115375: PUSH
115376: LD_VAR 0 8
115380: ARRAY
115381: PPUSH
115382: CALL_OW 115
// attacking := true ;
115386: LD_ADDR_VAR 0 29
115390: PUSH
115391: LD_INT 1
115393: ST_TO_ADDR
// break ;
115394: GO 115398
// end ;
115396: GO 115335
115398: POP
115399: POP
// end ; if IsOk ( group [ i ] ) and not attacking then
115400: LD_VAR 0 4
115404: PUSH
115405: LD_VAR 0 7
115409: ARRAY
115410: PPUSH
115411: CALL_OW 302
115415: PUSH
115416: LD_VAR 0 29
115420: NOT
115421: AND
115422: IFFALSE 115744
// begin if GetTag ( group [ i ] ) = 71 then
115424: LD_VAR 0 4
115428: PUSH
115429: LD_VAR 0 7
115433: ARRAY
115434: PPUSH
115435: CALL_OW 110
115439: PUSH
115440: LD_INT 71
115442: EQUAL
115443: IFFALSE 115484
// begin if HasTask ( group [ i ] ) then
115445: LD_VAR 0 4
115449: PUSH
115450: LD_VAR 0 7
115454: ARRAY
115455: PPUSH
115456: CALL_OW 314
115460: IFFALSE 115466
// continue else
115462: GO 111623
115464: GO 115484
// SetTag ( group [ i ] , 0 ) ;
115466: LD_VAR 0 4
115470: PUSH
115471: LD_VAR 0 7
115475: ARRAY
115476: PPUSH
115477: LD_INT 0
115479: PPUSH
115480: CALL_OW 109
// end ; k := 8 ;
115484: LD_ADDR_VAR 0 9
115488: PUSH
115489: LD_INT 8
115491: ST_TO_ADDR
// x := 0 ;
115492: LD_ADDR_VAR 0 10
115496: PUSH
115497: LD_INT 0
115499: ST_TO_ADDR
// if tmp < k then
115500: LD_VAR 0 14
115504: PUSH
115505: LD_VAR 0 9
115509: LESS
115510: IFFALSE 115522
// k := tmp ;
115512: LD_ADDR_VAR 0 9
115516: PUSH
115517: LD_VAR 0 14
115521: ST_TO_ADDR
// for j = 1 to k do
115522: LD_ADDR_VAR 0 8
115526: PUSH
115527: DOUBLE
115528: LD_INT 1
115530: DEC
115531: ST_TO_ADDR
115532: LD_VAR 0 9
115536: PUSH
115537: FOR_TO
115538: IFFALSE 115636
// if GetType ( tmp [ j ] ) = unit_human and ( ( GetLives ( tmp [ j ] ) < 250 and f_murder ) or ( not f_murder and GetLives ( tmp [ j ] ) >= 250 ) ) then
115540: LD_VAR 0 14
115544: PUSH
115545: LD_VAR 0 8
115549: ARRAY
115550: PPUSH
115551: CALL_OW 247
115555: PUSH
115556: LD_INT 1
115558: EQUAL
115559: PUSH
115560: LD_VAR 0 14
115564: PUSH
115565: LD_VAR 0 8
115569: ARRAY
115570: PPUSH
115571: CALL_OW 256
115575: PUSH
115576: LD_INT 250
115578: LESS
115579: PUSH
115580: LD_VAR 0 20
115584: AND
115585: PUSH
115586: LD_VAR 0 20
115590: NOT
115591: PUSH
115592: LD_VAR 0 14
115596: PUSH
115597: LD_VAR 0 8
115601: ARRAY
115602: PPUSH
115603: CALL_OW 256
115607: PUSH
115608: LD_INT 250
115610: GREATEREQUAL
115611: AND
115612: OR
115613: AND
115614: IFFALSE 115634
// begin x := tmp [ j ] ;
115616: LD_ADDR_VAR 0 10
115620: PUSH
115621: LD_VAR 0 14
115625: PUSH
115626: LD_VAR 0 8
115630: ARRAY
115631: ST_TO_ADDR
// break ;
115632: GO 115636
// end ;
115634: GO 115537
115636: POP
115637: POP
// if x then
115638: LD_VAR 0 10
115642: IFFALSE 115666
// ComAttackUnit ( group [ i ] , x ) else
115644: LD_VAR 0 4
115648: PUSH
115649: LD_VAR 0 7
115653: ARRAY
115654: PPUSH
115655: LD_VAR 0 10
115659: PPUSH
115660: CALL_OW 115
115664: GO 115690
// ComAttackUnit ( group [ i ] , tmp [ 1 ] ) ;
115666: LD_VAR 0 4
115670: PUSH
115671: LD_VAR 0 7
115675: ARRAY
115676: PPUSH
115677: LD_VAR 0 14
115681: PUSH
115682: LD_INT 1
115684: ARRAY
115685: PPUSH
115686: CALL_OW 115
// if not HasTask ( group [ i ] ) then
115690: LD_VAR 0 4
115694: PUSH
115695: LD_VAR 0 7
115699: ARRAY
115700: PPUSH
115701: CALL_OW 314
115705: NOT
115706: IFFALSE 115744
// ComAttackUnit ( group [ i ] , NearestUnitToUnit ( tmp , group [ i ] ) ) ;
115708: LD_VAR 0 4
115712: PUSH
115713: LD_VAR 0 7
115717: ARRAY
115718: PPUSH
115719: LD_VAR 0 14
115723: PPUSH
115724: LD_VAR 0 4
115728: PUSH
115729: LD_VAR 0 7
115733: ARRAY
115734: PPUSH
115735: CALL_OW 74
115739: PPUSH
115740: CALL_OW 115
// end ; end ; end ;
115744: GO 111623
115746: POP
115747: POP
// wait ( 0 0$2 ) ;
115748: LD_INT 70
115750: PPUSH
115751: CALL_OW 67
// until not group or group = [ ] or not FilterAllUnits ( [ f_enemy , side ] ) ;
115755: LD_VAR 0 4
115759: NOT
115760: PUSH
115761: LD_VAR 0 4
115765: PUSH
115766: EMPTY
115767: EQUAL
115768: OR
115769: PUSH
115770: LD_INT 81
115772: PUSH
115773: LD_VAR 0 35
115777: PUSH
115778: EMPTY
115779: LIST
115780: LIST
115781: PPUSH
115782: CALL_OW 69
115786: NOT
115787: OR
115788: IFFALSE 111608
// end ;
115790: LD_VAR 0 2
115794: RET
// export function BasicDefend ( base , solds ) ; var enemy , e , side , i , hex ; begin
115795: LD_INT 0
115797: PPUSH
115798: PPUSH
115799: PPUSH
115800: PPUSH
115801: PPUSH
115802: PPUSH
// if not base or not mc_bases [ base ] or not solds then
115803: LD_VAR 0 1
115807: NOT
115808: PUSH
115809: LD_EXP 95
115813: PUSH
115814: LD_VAR 0 1
115818: ARRAY
115819: NOT
115820: OR
115821: PUSH
115822: LD_VAR 0 2
115826: NOT
115827: OR
115828: IFFALSE 115832
// exit ;
115830: GO 116386
// side := mc_sides [ base ] ;
115832: LD_ADDR_VAR 0 6
115836: PUSH
115837: LD_EXP 121
115841: PUSH
115842: LD_VAR 0 1
115846: ARRAY
115847: ST_TO_ADDR
// if not side then
115848: LD_VAR 0 6
115852: NOT
115853: IFFALSE 115857
// exit ;
115855: GO 116386
// for i in solds do
115857: LD_ADDR_VAR 0 7
115861: PUSH
115862: LD_VAR 0 2
115866: PUSH
115867: FOR_IN
115868: IFFALSE 115929
// if GetBType ( IsInUnit ( i ) ) in [ b_bunker , b_breastwork ] then
115870: LD_VAR 0 7
115874: PPUSH
115875: CALL_OW 310
115879: PPUSH
115880: CALL_OW 266
115884: PUSH
115885: LD_INT 32
115887: PUSH
115888: LD_INT 31
115890: PUSH
115891: EMPTY
115892: LIST
115893: LIST
115894: IN
115895: IFFALSE 115915
// solds := solds diff i else
115897: LD_ADDR_VAR 0 2
115901: PUSH
115902: LD_VAR 0 2
115906: PUSH
115907: LD_VAR 0 7
115911: DIFF
115912: ST_TO_ADDR
115913: GO 115927
// SetTag ( i , 18 ) ;
115915: LD_VAR 0 7
115919: PPUSH
115920: LD_INT 18
115922: PPUSH
115923: CALL_OW 109
115927: GO 115867
115929: POP
115930: POP
// if not solds then
115931: LD_VAR 0 2
115935: NOT
115936: IFFALSE 115940
// exit ;
115938: GO 116386
// repeat wait ( 0 0$2 ) ;
115940: LD_INT 70
115942: PPUSH
115943: CALL_OW 67
// enemy := mc_scan [ base ] ;
115947: LD_ADDR_VAR 0 4
115951: PUSH
115952: LD_EXP 118
115956: PUSH
115957: LD_VAR 0 1
115961: ARRAY
115962: ST_TO_ADDR
// if not mc_bases [ base ] or mc_bases [ base ] = [ ] then
115963: LD_EXP 95
115967: PUSH
115968: LD_VAR 0 1
115972: ARRAY
115973: NOT
115974: PUSH
115975: LD_EXP 95
115979: PUSH
115980: LD_VAR 0 1
115984: ARRAY
115985: PUSH
115986: EMPTY
115987: EQUAL
115988: OR
115989: IFFALSE 116026
// begin for i in solds do
115991: LD_ADDR_VAR 0 7
115995: PUSH
115996: LD_VAR 0 2
116000: PUSH
116001: FOR_IN
116002: IFFALSE 116015
// ComStop ( i ) ;
116004: LD_VAR 0 7
116008: PPUSH
116009: CALL_OW 141
116013: GO 116001
116015: POP
116016: POP
// solds := [ ] ;
116017: LD_ADDR_VAR 0 2
116021: PUSH
116022: EMPTY
116023: ST_TO_ADDR
// exit ;
116024: GO 116386
// end ; for i in solds do
116026: LD_ADDR_VAR 0 7
116030: PUSH
116031: LD_VAR 0 2
116035: PUSH
116036: FOR_IN
116037: IFFALSE 116358
// begin if IsInUnit ( i ) then
116039: LD_VAR 0 7
116043: PPUSH
116044: CALL_OW 310
116048: IFFALSE 116059
// ComExitBuilding ( i ) ;
116050: LD_VAR 0 7
116054: PPUSH
116055: CALL_OW 122
// if GetLives ( i ) > 500 then
116059: LD_VAR 0 7
116063: PPUSH
116064: CALL_OW 256
116068: PUSH
116069: LD_INT 500
116071: GREATER
116072: IFFALSE 116125
// begin e := NearestUnitToUnit ( enemy , i ) ;
116074: LD_ADDR_VAR 0 5
116078: PUSH
116079: LD_VAR 0 4
116083: PPUSH
116084: LD_VAR 0 7
116088: PPUSH
116089: CALL_OW 74
116093: ST_TO_ADDR
// ComAgressiveMove ( i , GetX ( e ) , GetY ( e ) ) ;
116094: LD_VAR 0 7
116098: PPUSH
116099: LD_VAR 0 5
116103: PPUSH
116104: CALL_OW 250
116108: PPUSH
116109: LD_VAR 0 5
116113: PPUSH
116114: CALL_OW 251
116118: PPUSH
116119: CALL_OW 114
// end else
116123: GO 116356
// if GetDistUnits ( i , NearestUnitToUnit ( UnitFilter ( mc_bases [ base ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] , [ f_btype , b_lab ] ] ) , i ) ) > 10 then
116125: LD_VAR 0 7
116129: PPUSH
116130: LD_EXP 95
116134: PUSH
116135: LD_VAR 0 1
116139: ARRAY
116140: PPUSH
116141: LD_INT 2
116143: PUSH
116144: LD_INT 30
116146: PUSH
116147: LD_INT 0
116149: PUSH
116150: EMPTY
116151: LIST
116152: LIST
116153: PUSH
116154: LD_INT 30
116156: PUSH
116157: LD_INT 1
116159: PUSH
116160: EMPTY
116161: LIST
116162: LIST
116163: PUSH
116164: LD_INT 30
116166: PUSH
116167: LD_INT 6
116169: PUSH
116170: EMPTY
116171: LIST
116172: LIST
116173: PUSH
116174: EMPTY
116175: LIST
116176: LIST
116177: LIST
116178: LIST
116179: PPUSH
116180: CALL_OW 72
116184: PPUSH
116185: LD_VAR 0 7
116189: PPUSH
116190: CALL_OW 74
116194: PPUSH
116195: CALL_OW 296
116199: PUSH
116200: LD_INT 10
116202: GREATER
116203: IFFALSE 116356
// begin hex := NearestUnitToUnit ( UnitFilter ( mc_bases [ base ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] , [ f_btype , b_lab ] ] ) , i ) ;
116205: LD_ADDR_VAR 0 8
116209: PUSH
116210: LD_EXP 95
116214: PUSH
116215: LD_VAR 0 1
116219: ARRAY
116220: PPUSH
116221: LD_INT 2
116223: PUSH
116224: LD_INT 30
116226: PUSH
116227: LD_INT 0
116229: PUSH
116230: EMPTY
116231: LIST
116232: LIST
116233: PUSH
116234: LD_INT 30
116236: PUSH
116237: LD_INT 1
116239: PUSH
116240: EMPTY
116241: LIST
116242: LIST
116243: PUSH
116244: LD_INT 30
116246: PUSH
116247: LD_INT 6
116249: PUSH
116250: EMPTY
116251: LIST
116252: LIST
116253: PUSH
116254: EMPTY
116255: LIST
116256: LIST
116257: LIST
116258: LIST
116259: PPUSH
116260: CALL_OW 72
116264: PPUSH
116265: LD_VAR 0 7
116269: PPUSH
116270: CALL_OW 74
116274: ST_TO_ADDR
// ComMoveXY ( i , ShiftX ( GetX ( hex ) , 3 , 5 ) , ShiftY ( GetY ( hex ) , 3 , 5 ) ) ;
116275: LD_VAR 0 7
116279: PPUSH
116280: LD_VAR 0 8
116284: PPUSH
116285: CALL_OW 250
116289: PPUSH
116290: LD_INT 3
116292: PPUSH
116293: LD_INT 5
116295: PPUSH
116296: CALL_OW 272
116300: PPUSH
116301: LD_VAR 0 8
116305: PPUSH
116306: CALL_OW 251
116310: PPUSH
116311: LD_INT 3
116313: PPUSH
116314: LD_INT 5
116316: PPUSH
116317: CALL_OW 273
116321: PPUSH
116322: CALL_OW 111
// SetTag ( i , 0 ) ;
116326: LD_VAR 0 7
116330: PPUSH
116331: LD_INT 0
116333: PPUSH
116334: CALL_OW 109
// solds := solds diff i ;
116338: LD_ADDR_VAR 0 2
116342: PUSH
116343: LD_VAR 0 2
116347: PUSH
116348: LD_VAR 0 7
116352: DIFF
116353: ST_TO_ADDR
// continue ;
116354: GO 116036
// end ; end ;
116356: GO 116036
116358: POP
116359: POP
// until not solds or not enemy ;
116360: LD_VAR 0 2
116364: NOT
116365: PUSH
116366: LD_VAR 0 4
116370: NOT
116371: OR
116372: IFFALSE 115940
// MC_Reset ( base , 18 ) ;
116374: LD_VAR 0 1
116378: PPUSH
116379: LD_INT 18
116381: PPUSH
116382: CALL 25554 0 2
// end ;
116386: LD_VAR 0 3
116390: RET
// export function Defend ( base , defenders ) ; var i , j , x , depot , solds , mech , un , tmp , mechs , e , fac , components , depot_under_attack , sold_defenders , b , can_defend , class , enemy ; begin
116391: LD_INT 0
116393: PPUSH
116394: PPUSH
116395: PPUSH
116396: PPUSH
116397: PPUSH
116398: PPUSH
116399: PPUSH
116400: PPUSH
116401: PPUSH
116402: PPUSH
116403: PPUSH
116404: PPUSH
116405: PPUSH
116406: PPUSH
116407: PPUSH
116408: PPUSH
116409: PPUSH
116410: PPUSH
116411: PPUSH
// mechs := UnitFilter ( mc_bases [ base ] , [ f_class , 3 ] ) ;
116412: LD_ADDR_VAR 0 12
116416: PUSH
116417: LD_EXP 95
116421: PUSH
116422: LD_VAR 0 1
116426: ARRAY
116427: PPUSH
116428: LD_INT 25
116430: PUSH
116431: LD_INT 3
116433: PUSH
116434: EMPTY
116435: LIST
116436: LIST
116437: PPUSH
116438: CALL_OW 72
116442: ST_TO_ADDR
// if mc_remote_driver [ base ] then
116443: LD_EXP 135
116447: PUSH
116448: LD_VAR 0 1
116452: ARRAY
116453: IFFALSE 116477
// mechs := mechs diff mc_remote_driver [ base ] ;
116455: LD_ADDR_VAR 0 12
116459: PUSH
116460: LD_VAR 0 12
116464: PUSH
116465: LD_EXP 135
116469: PUSH
116470: LD_VAR 0 1
116474: ARRAY
116475: DIFF
116476: ST_TO_ADDR
// for i in mechs do
116477: LD_ADDR_VAR 0 4
116481: PUSH
116482: LD_VAR 0 12
116486: PUSH
116487: FOR_IN
116488: IFFALSE 116523
// if GetTag ( i ) > 0 then
116490: LD_VAR 0 4
116494: PPUSH
116495: CALL_OW 110
116499: PUSH
116500: LD_INT 0
116502: GREATER
116503: IFFALSE 116521
// mechs := mechs diff i ;
116505: LD_ADDR_VAR 0 12
116509: PUSH
116510: LD_VAR 0 12
116514: PUSH
116515: LD_VAR 0 4
116519: DIFF
116520: ST_TO_ADDR
116521: GO 116487
116523: POP
116524: POP
// solds := UnitFilter ( mc_bases [ base ] , [ f_or , [ f_class , 1 ] , [ f_class , 5 ] , [ f_class , 8 ] , [ f_class , 9 ] ] ) ;
116525: LD_ADDR_VAR 0 8
116529: PUSH
116530: LD_EXP 95
116534: PUSH
116535: LD_VAR 0 1
116539: ARRAY
116540: PPUSH
116541: LD_INT 2
116543: PUSH
116544: LD_INT 25
116546: PUSH
116547: LD_INT 1
116549: PUSH
116550: EMPTY
116551: LIST
116552: LIST
116553: PUSH
116554: LD_INT 25
116556: PUSH
116557: LD_INT 5
116559: PUSH
116560: EMPTY
116561: LIST
116562: LIST
116563: PUSH
116564: LD_INT 25
116566: PUSH
116567: LD_INT 8
116569: PUSH
116570: EMPTY
116571: LIST
116572: LIST
116573: PUSH
116574: LD_INT 25
116576: PUSH
116577: LD_INT 9
116579: PUSH
116580: EMPTY
116581: LIST
116582: LIST
116583: PUSH
116584: EMPTY
116585: LIST
116586: LIST
116587: LIST
116588: LIST
116589: LIST
116590: PPUSH
116591: CALL_OW 72
116595: ST_TO_ADDR
// if not defenders and not solds then
116596: LD_VAR 0 2
116600: NOT
116601: PUSH
116602: LD_VAR 0 8
116606: NOT
116607: AND
116608: IFFALSE 116612
// exit ;
116610: GO 118382
// depot_under_attack := false ;
116612: LD_ADDR_VAR 0 16
116616: PUSH
116617: LD_INT 0
116619: ST_TO_ADDR
// sold_defenders := [ ] ;
116620: LD_ADDR_VAR 0 17
116624: PUSH
116625: EMPTY
116626: ST_TO_ADDR
// if mechs then
116627: LD_VAR 0 12
116631: IFFALSE 116784
// for i in UnitFilter ( defenders , [ f_type , unit_vehicle ] ) do
116633: LD_ADDR_VAR 0 4
116637: PUSH
116638: LD_VAR 0 2
116642: PPUSH
116643: LD_INT 21
116645: PUSH
116646: LD_INT 2
116648: PUSH
116649: EMPTY
116650: LIST
116651: LIST
116652: PPUSH
116653: CALL_OW 72
116657: PUSH
116658: FOR_IN
116659: IFFALSE 116782
// begin if GetTag ( i ) <> 20 then
116661: LD_VAR 0 4
116665: PPUSH
116666: CALL_OW 110
116670: PUSH
116671: LD_INT 20
116673: NONEQUAL
116674: IFFALSE 116688
// SetTag ( i , 20 ) ;
116676: LD_VAR 0 4
116680: PPUSH
116681: LD_INT 20
116683: PPUSH
116684: CALL_OW 109
// if GetControl ( i ) = control_manual and not IsDrivenBy ( i ) then
116688: LD_VAR 0 4
116692: PPUSH
116693: CALL_OW 263
116697: PUSH
116698: LD_INT 1
116700: EQUAL
116701: PUSH
116702: LD_VAR 0 4
116706: PPUSH
116707: CALL_OW 311
116711: NOT
116712: AND
116713: IFFALSE 116780
// begin un := mechs [ 1 ] ;
116715: LD_ADDR_VAR 0 10
116719: PUSH
116720: LD_VAR 0 12
116724: PUSH
116725: LD_INT 1
116727: ARRAY
116728: ST_TO_ADDR
// ComExit ( un ) ;
116729: LD_VAR 0 10
116733: PPUSH
116734: CALL 89151 0 1
// AddComEnterUnit ( un , i ) ;
116738: LD_VAR 0 10
116742: PPUSH
116743: LD_VAR 0 4
116747: PPUSH
116748: CALL_OW 180
// SetTag ( un , 19 ) ;
116752: LD_VAR 0 10
116756: PPUSH
116757: LD_INT 19
116759: PPUSH
116760: CALL_OW 109
// mechs := mechs diff un ;
116764: LD_ADDR_VAR 0 12
116768: PUSH
116769: LD_VAR 0 12
116773: PUSH
116774: LD_VAR 0 10
116778: DIFF
116779: ST_TO_ADDR
// end ; end ;
116780: GO 116658
116782: POP
116783: POP
// if solds then
116784: LD_VAR 0 8
116788: IFFALSE 116847
// for i in solds do
116790: LD_ADDR_VAR 0 4
116794: PUSH
116795: LD_VAR 0 8
116799: PUSH
116800: FOR_IN
116801: IFFALSE 116845
// if not GetTag ( i ) then
116803: LD_VAR 0 4
116807: PPUSH
116808: CALL_OW 110
116812: NOT
116813: IFFALSE 116843
// begin defenders := defenders union i ;
116815: LD_ADDR_VAR 0 2
116819: PUSH
116820: LD_VAR 0 2
116824: PUSH
116825: LD_VAR 0 4
116829: UNION
116830: ST_TO_ADDR
// SetTag ( i , 18 ) ;
116831: LD_VAR 0 4
116835: PPUSH
116836: LD_INT 18
116838: PPUSH
116839: CALL_OW 109
// end ;
116843: GO 116800
116845: POP
116846: POP
// repeat wait ( 0 0$2 ) ;
116847: LD_INT 70
116849: PPUSH
116850: CALL_OW 67
// enemy := mc_scan [ base ] ;
116854: LD_ADDR_VAR 0 21
116858: PUSH
116859: LD_EXP 118
116863: PUSH
116864: LD_VAR 0 1
116868: ARRAY
116869: ST_TO_ADDR
// if not mc_bases [ base ] or mc_bases [ base ] = [ ] then
116870: LD_EXP 95
116874: PUSH
116875: LD_VAR 0 1
116879: ARRAY
116880: NOT
116881: PUSH
116882: LD_EXP 95
116886: PUSH
116887: LD_VAR 0 1
116891: ARRAY
116892: PUSH
116893: EMPTY
116894: EQUAL
116895: OR
116896: IFFALSE 116933
// begin for i in defenders do
116898: LD_ADDR_VAR 0 4
116902: PUSH
116903: LD_VAR 0 2
116907: PUSH
116908: FOR_IN
116909: IFFALSE 116922
// ComStop ( i ) ;
116911: LD_VAR 0 4
116915: PPUSH
116916: CALL_OW 141
116920: GO 116908
116922: POP
116923: POP
// defenders := [ ] ;
116924: LD_ADDR_VAR 0 2
116928: PUSH
116929: EMPTY
116930: ST_TO_ADDR
// exit ;
116931: GO 118382
// end ; for i in defenders do
116933: LD_ADDR_VAR 0 4
116937: PUSH
116938: LD_VAR 0 2
116942: PUSH
116943: FOR_IN
116944: IFFALSE 117842
// begin e := NearestUnitToUnit ( enemy , i ) ;
116946: LD_ADDR_VAR 0 13
116950: PUSH
116951: LD_VAR 0 21
116955: PPUSH
116956: LD_VAR 0 4
116960: PPUSH
116961: CALL_OW 74
116965: ST_TO_ADDR
// depot := UnitFilter ( mc_bases [ base ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) ;
116966: LD_ADDR_VAR 0 7
116970: PUSH
116971: LD_EXP 95
116975: PUSH
116976: LD_VAR 0 1
116980: ARRAY
116981: PPUSH
116982: LD_INT 2
116984: PUSH
116985: LD_INT 30
116987: PUSH
116988: LD_INT 0
116990: PUSH
116991: EMPTY
116992: LIST
116993: LIST
116994: PUSH
116995: LD_INT 30
116997: PUSH
116998: LD_INT 1
117000: PUSH
117001: EMPTY
117002: LIST
117003: LIST
117004: PUSH
117005: EMPTY
117006: LIST
117007: LIST
117008: LIST
117009: PPUSH
117010: CALL_OW 72
117014: ST_TO_ADDR
// depot_under_attack := ( not depot or UnitFilter ( depot , [ f_not , [ f_lives , 600 ] ] ) ) ;
117015: LD_ADDR_VAR 0 16
117019: PUSH
117020: LD_VAR 0 7
117024: NOT
117025: PUSH
117026: LD_VAR 0 7
117030: PPUSH
117031: LD_INT 3
117033: PUSH
117034: LD_INT 24
117036: PUSH
117037: LD_INT 600
117039: PUSH
117040: EMPTY
117041: LIST
117042: LIST
117043: PUSH
117044: EMPTY
117045: LIST
117046: LIST
117047: PPUSH
117048: CALL_OW 72
117052: OR
117053: ST_TO_ADDR
// case GetType ( i ) of unit_vehicle :
117054: LD_VAR 0 4
117058: PPUSH
117059: CALL_OW 247
117063: PUSH
117064: LD_INT 2
117066: DOUBLE
117067: EQUAL
117068: IFTRUE 117072
117070: GO 117468
117072: POP
// begin if GetLives ( i ) = 1000 and ( GetDistUnits ( i , e ) < 40 or IsInArea ( e , mc_scan_area [ base ] ) ) then
117073: LD_VAR 0 4
117077: PPUSH
117078: CALL_OW 256
117082: PUSH
117083: LD_INT 1000
117085: EQUAL
117086: PUSH
117087: LD_VAR 0 4
117091: PPUSH
117092: LD_VAR 0 13
117096: PPUSH
117097: CALL_OW 296
117101: PUSH
117102: LD_INT 40
117104: LESS
117105: PUSH
117106: LD_VAR 0 13
117110: PPUSH
117111: LD_EXP 120
117115: PUSH
117116: LD_VAR 0 1
117120: ARRAY
117121: PPUSH
117122: CALL_OW 308
117126: OR
117127: AND
117128: IFFALSE 117250
// begin if GetEngine ( i ) = engine_combustion and GetFuel ( i ) < 30 and depot then
117130: LD_VAR 0 4
117134: PPUSH
117135: CALL_OW 262
117139: PUSH
117140: LD_INT 1
117142: EQUAL
117143: PUSH
117144: LD_VAR 0 4
117148: PPUSH
117149: CALL_OW 261
117153: PUSH
117154: LD_INT 30
117156: LESS
117157: AND
117158: PUSH
117159: LD_VAR 0 7
117163: AND
117164: IFFALSE 117234
// begin ComMoveUnit ( i , NearestUnitToUnit ( depot , i ) ) ;
117166: LD_VAR 0 4
117170: PPUSH
117171: LD_VAR 0 7
117175: PPUSH
117176: LD_VAR 0 4
117180: PPUSH
117181: CALL_OW 74
117185: PPUSH
117186: CALL_OW 112
// if GetDistUnits ( i , NearestUnitToUnit ( depot , i ) ) < 6 then
117190: LD_VAR 0 4
117194: PPUSH
117195: LD_VAR 0 7
117199: PPUSH
117200: LD_VAR 0 4
117204: PPUSH
117205: CALL_OW 74
117209: PPUSH
117210: CALL_OW 296
117214: PUSH
117215: LD_INT 6
117217: LESS
117218: IFFALSE 117232
// SetFuel ( i , 100 ) ;
117220: LD_VAR 0 4
117224: PPUSH
117225: LD_INT 100
117227: PPUSH
117228: CALL_OW 240
// end else
117232: GO 117248
// ComAttackUnit ( i , e ) ;
117234: LD_VAR 0 4
117238: PPUSH
117239: LD_VAR 0 13
117243: PPUSH
117244: CALL_OW 115
// end else
117248: GO 117351
// if ( ( not IsInArea ( e , mc_scan_area [ base ] ) and GetDistUnits ( i , e ) >= 40 ) or GetLives ( i ) <= 650 ) and not IsInArea ( i , mc_parking [ base ] ) then
117250: LD_VAR 0 13
117254: PPUSH
117255: LD_EXP 120
117259: PUSH
117260: LD_VAR 0 1
117264: ARRAY
117265: PPUSH
117266: CALL_OW 308
117270: NOT
117271: PUSH
117272: LD_VAR 0 4
117276: PPUSH
117277: LD_VAR 0 13
117281: PPUSH
117282: CALL_OW 296
117286: PUSH
117287: LD_INT 40
117289: GREATEREQUAL
117290: AND
117291: PUSH
117292: LD_VAR 0 4
117296: PPUSH
117297: CALL_OW 256
117301: PUSH
117302: LD_INT 650
117304: LESSEQUAL
117305: OR
117306: PUSH
117307: LD_VAR 0 4
117311: PPUSH
117312: LD_EXP 119
117316: PUSH
117317: LD_VAR 0 1
117321: ARRAY
117322: PPUSH
117323: CALL_OW 308
117327: NOT
117328: AND
117329: IFFALSE 117351
// ComMoveToArea ( i , mc_parking [ base ] ) ;
117331: LD_VAR 0 4
117335: PPUSH
117336: LD_EXP 119
117340: PUSH
117341: LD_VAR 0 1
117345: ARRAY
117346: PPUSH
117347: CALL_OW 113
// if GetLives ( i ) < 1000 and GetControl ( i ) = control_manual and IsDrivenBy ( i ) and IsInArea ( i , mc_parking [ base ] ) then
117351: LD_VAR 0 4
117355: PPUSH
117356: CALL_OW 256
117360: PUSH
117361: LD_INT 1000
117363: LESS
117364: PUSH
117365: LD_VAR 0 4
117369: PPUSH
117370: CALL_OW 263
117374: PUSH
117375: LD_INT 1
117377: EQUAL
117378: AND
117379: PUSH
117380: LD_VAR 0 4
117384: PPUSH
117385: CALL_OW 311
117389: AND
117390: PUSH
117391: LD_VAR 0 4
117395: PPUSH
117396: LD_EXP 119
117400: PUSH
117401: LD_VAR 0 1
117405: ARRAY
117406: PPUSH
117407: CALL_OW 308
117411: AND
117412: IFFALSE 117466
// begin mech := IsDrivenBy ( i ) ;
117414: LD_ADDR_VAR 0 9
117418: PUSH
117419: LD_VAR 0 4
117423: PPUSH
117424: CALL_OW 311
117428: ST_TO_ADDR
// ComExitVehicle ( mech ) ;
117429: LD_VAR 0 9
117433: PPUSH
117434: CALL_OW 121
// AddComRepairVehicle ( mech , i ) ;
117438: LD_VAR 0 9
117442: PPUSH
117443: LD_VAR 0 4
117447: PPUSH
117448: CALL_OW 189
// AddComEnterUnit ( mech , i ) ;
117452: LD_VAR 0 9
117456: PPUSH
117457: LD_VAR 0 4
117461: PPUSH
117462: CALL_OW 180
// end ; end ; unit_human :
117466: GO 117813
117468: LD_INT 1
117470: DOUBLE
117471: EQUAL
117472: IFTRUE 117476
117474: GO 117812
117476: POP
// begin b := IsInUnit ( i ) ;
117477: LD_ADDR_VAR 0 18
117481: PUSH
117482: LD_VAR 0 4
117486: PPUSH
117487: CALL_OW 310
117491: ST_TO_ADDR
// can_defend := ( not b or GetBType ( b ) in [ b_bunker , b_breastwork ] ) ;
117492: LD_ADDR_VAR 0 19
117496: PUSH
117497: LD_VAR 0 18
117501: NOT
117502: PUSH
117503: LD_VAR 0 18
117507: PPUSH
117508: CALL_OW 266
117512: PUSH
117513: LD_INT 32
117515: PUSH
117516: LD_INT 31
117518: PUSH
117519: EMPTY
117520: LIST
117521: LIST
117522: IN
117523: OR
117524: ST_TO_ADDR
// if GetBType ( b ) = b_barracks and GetClass ( i ) in [ 1 , 2 , 3 , 4 ] then
117525: LD_VAR 0 18
117529: PPUSH
117530: CALL_OW 266
117534: PUSH
117535: LD_INT 5
117537: EQUAL
117538: PUSH
117539: LD_VAR 0 4
117543: PPUSH
117544: CALL_OW 257
117548: PUSH
117549: LD_INT 1
117551: PUSH
117552: LD_INT 2
117554: PUSH
117555: LD_INT 3
117557: PUSH
117558: LD_INT 4
117560: PUSH
117561: EMPTY
117562: LIST
117563: LIST
117564: LIST
117565: LIST
117566: IN
117567: AND
117568: IFFALSE 117605
// begin class := AllowSpecClass ( i ) ;
117570: LD_ADDR_VAR 0 20
117574: PUSH
117575: LD_VAR 0 4
117579: PPUSH
117580: CALL 53812 0 1
117584: ST_TO_ADDR
// if class then
117585: LD_VAR 0 20
117589: IFFALSE 117605
// ComChangeProfession ( i , class ) ;
117591: LD_VAR 0 4
117595: PPUSH
117596: LD_VAR 0 20
117600: PPUSH
117601: CALL_OW 123
// end ; if ( depot_under_attack or UnitFilter ( defenders , [ f_type , unit_vehicle ] ) <= 1 ) and can_defend and not i in sold_defenders then
117605: LD_VAR 0 16
117609: PUSH
117610: LD_VAR 0 2
117614: PPUSH
117615: LD_INT 21
117617: PUSH
117618: LD_INT 2
117620: PUSH
117621: EMPTY
117622: LIST
117623: LIST
117624: PPUSH
117625: CALL_OW 72
117629: PUSH
117630: LD_INT 1
117632: LESSEQUAL
117633: OR
117634: PUSH
117635: LD_VAR 0 19
117639: AND
117640: PUSH
117641: LD_VAR 0 4
117645: PUSH
117646: LD_VAR 0 17
117650: IN
117651: NOT
117652: AND
117653: IFFALSE 117746
// begin if b then
117655: LD_VAR 0 18
117659: IFFALSE 117708
// if GetDistUnits ( b , NearestUnitToUnit ( enemy , b ) ) < 10 and BuildingStatus ( b ) <> bs_need_power then
117661: LD_VAR 0 18
117665: PPUSH
117666: LD_VAR 0 21
117670: PPUSH
117671: LD_VAR 0 18
117675: PPUSH
117676: CALL_OW 74
117680: PPUSH
117681: CALL_OW 296
117685: PUSH
117686: LD_INT 10
117688: LESS
117689: PUSH
117690: LD_VAR 0 18
117694: PPUSH
117695: CALL_OW 461
117699: PUSH
117700: LD_INT 7
117702: NONEQUAL
117703: AND
117704: IFFALSE 117708
// continue ;
117706: GO 116943
// sold_defenders := Replace ( sold_defenders , sold_defenders + 1 , i ) ;
117708: LD_ADDR_VAR 0 17
117712: PUSH
117713: LD_VAR 0 17
117717: PPUSH
117718: LD_VAR 0 17
117722: PUSH
117723: LD_INT 1
117725: PLUS
117726: PPUSH
117727: LD_VAR 0 4
117731: PPUSH
117732: CALL_OW 1
117736: ST_TO_ADDR
// ComExitBuilding ( i ) ;
117737: LD_VAR 0 4
117741: PPUSH
117742: CALL_OW 122
// end ; if sold_defenders then
117746: LD_VAR 0 17
117750: IFFALSE 117810
// if i in sold_defenders then
117752: LD_VAR 0 4
117756: PUSH
117757: LD_VAR 0 17
117761: IN
117762: IFFALSE 117810
// begin if not HasTask ( i ) and GetDistUnits ( i , e ) < 30 then
117764: LD_VAR 0 4
117768: PPUSH
117769: CALL_OW 314
117773: NOT
117774: PUSH
117775: LD_VAR 0 4
117779: PPUSH
117780: LD_VAR 0 13
117784: PPUSH
117785: CALL_OW 296
117789: PUSH
117790: LD_INT 30
117792: LESS
117793: AND
117794: IFFALSE 117810
// ComAttackUnit ( i , e ) ;
117796: LD_VAR 0 4
117800: PPUSH
117801: LD_VAR 0 13
117805: PPUSH
117806: CALL_OW 115
// end ; end ; end ;
117810: GO 117813
117812: POP
// if IsDead ( i ) then
117813: LD_VAR 0 4
117817: PPUSH
117818: CALL_OW 301
117822: IFFALSE 117840
// defenders := defenders diff i ;
117824: LD_ADDR_VAR 0 2
117828: PUSH
117829: LD_VAR 0 2
117833: PUSH
117834: LD_VAR 0 4
117838: DIFF
117839: ST_TO_ADDR
// end ;
117840: GO 116943
117842: POP
117843: POP
// until not enemy or not defenders or not mc_bases [ base ] ;
117844: LD_VAR 0 21
117848: NOT
117849: PUSH
117850: LD_VAR 0 2
117854: NOT
117855: OR
117856: PUSH
117857: LD_EXP 95
117861: PUSH
117862: LD_VAR 0 1
117866: ARRAY
117867: NOT
117868: OR
117869: IFFALSE 116847
// MC_Reset ( base , 18 ) ;
117871: LD_VAR 0 1
117875: PPUSH
117876: LD_INT 18
117878: PPUSH
117879: CALL 25554 0 2
// defenders := defenders diff UnitFilter ( defenders , [ f_or , [ f_class , 1 ] , [ f_class , 5 ] , [ f_class , 8 ] , [ f_class , 9 ] ] ) ;
117883: LD_ADDR_VAR 0 2
117887: PUSH
117888: LD_VAR 0 2
117892: PUSH
117893: LD_VAR 0 2
117897: PPUSH
117898: LD_INT 2
117900: PUSH
117901: LD_INT 25
117903: PUSH
117904: LD_INT 1
117906: PUSH
117907: EMPTY
117908: LIST
117909: LIST
117910: PUSH
117911: LD_INT 25
117913: PUSH
117914: LD_INT 5
117916: PUSH
117917: EMPTY
117918: LIST
117919: LIST
117920: PUSH
117921: LD_INT 25
117923: PUSH
117924: LD_INT 8
117926: PUSH
117927: EMPTY
117928: LIST
117929: LIST
117930: PUSH
117931: LD_INT 25
117933: PUSH
117934: LD_INT 9
117936: PUSH
117937: EMPTY
117938: LIST
117939: LIST
117940: PUSH
117941: EMPTY
117942: LIST
117943: LIST
117944: LIST
117945: LIST
117946: LIST
117947: PPUSH
117948: CALL_OW 72
117952: DIFF
117953: ST_TO_ADDR
// if not enemy and UnitFilter ( defenders , [ f_type , unit_vehicle ] ) then
117954: LD_VAR 0 21
117958: NOT
117959: PUSH
117960: LD_VAR 0 2
117964: PPUSH
117965: LD_INT 21
117967: PUSH
117968: LD_INT 2
117970: PUSH
117971: EMPTY
117972: LIST
117973: LIST
117974: PPUSH
117975: CALL_OW 72
117979: AND
117980: IFFALSE 118318
// begin tmp := FilterByTag ( defenders , 19 ) ;
117982: LD_ADDR_VAR 0 11
117986: PUSH
117987: LD_VAR 0 2
117991: PPUSH
117992: LD_INT 19
117994: PPUSH
117995: CALL 86281 0 2
117999: ST_TO_ADDR
// if tmp then
118000: LD_VAR 0 11
118004: IFFALSE 118074
// begin tmp := UnitFilter ( tmp , [ f_class , 3 ] ) ;
118006: LD_ADDR_VAR 0 11
118010: PUSH
118011: LD_VAR 0 11
118015: PPUSH
118016: LD_INT 25
118018: PUSH
118019: LD_INT 3
118021: PUSH
118022: EMPTY
118023: LIST
118024: LIST
118025: PPUSH
118026: CALL_OW 72
118030: ST_TO_ADDR
// if tmp then
118031: LD_VAR 0 11
118035: IFFALSE 118074
// mc_repair_vehicle := Replace ( mc_repair_vehicle , base , mc_repair_vehicle [ base ] union tmp ) ;
118037: LD_ADDR_EXP 107
118041: PUSH
118042: LD_EXP 107
118046: PPUSH
118047: LD_VAR 0 1
118051: PPUSH
118052: LD_EXP 107
118056: PUSH
118057: LD_VAR 0 1
118061: ARRAY
118062: PUSH
118063: LD_VAR 0 11
118067: UNION
118068: PPUSH
118069: CALL_OW 1
118073: ST_TO_ADDR
// end ; MC_Reset ( base , 19 ) ;
118074: LD_VAR 0 1
118078: PPUSH
118079: LD_INT 19
118081: PPUSH
118082: CALL 25554 0 2
// repeat wait ( 0 0$1 ) ;
118086: LD_INT 35
118088: PPUSH
118089: CALL_OW 67
// if not mc_bases [ base ] or mc_bases [ base ] = [ ] then
118093: LD_EXP 95
118097: PUSH
118098: LD_VAR 0 1
118102: ARRAY
118103: NOT
118104: PUSH
118105: LD_EXP 95
118109: PUSH
118110: LD_VAR 0 1
118114: ARRAY
118115: PUSH
118116: EMPTY
118117: EQUAL
118118: OR
118119: IFFALSE 118156
// begin for i in defenders do
118121: LD_ADDR_VAR 0 4
118125: PUSH
118126: LD_VAR 0 2
118130: PUSH
118131: FOR_IN
118132: IFFALSE 118145
// ComStop ( i ) ;
118134: LD_VAR 0 4
118138: PPUSH
118139: CALL_OW 141
118143: GO 118131
118145: POP
118146: POP
// defenders := [ ] ;
118147: LD_ADDR_VAR 0 2
118151: PUSH
118152: EMPTY
118153: ST_TO_ADDR
// exit ;
118154: GO 118382
// end ; for i in defenders do
118156: LD_ADDR_VAR 0 4
118160: PUSH
118161: LD_VAR 0 2
118165: PUSH
118166: FOR_IN
118167: IFFALSE 118256
// begin if not IsInArea ( i , mc_parking [ base ] ) then
118169: LD_VAR 0 4
118173: PPUSH
118174: LD_EXP 119
118178: PUSH
118179: LD_VAR 0 1
118183: ARRAY
118184: PPUSH
118185: CALL_OW 308
118189: NOT
118190: IFFALSE 118214
// ComMoveToArea ( i , mc_parking [ base ] ) else
118192: LD_VAR 0 4
118196: PPUSH
118197: LD_EXP 119
118201: PUSH
118202: LD_VAR 0 1
118206: ARRAY
118207: PPUSH
118208: CALL_OW 113
118212: GO 118254
// if GetControl ( i ) = control_manual then
118214: LD_VAR 0 4
118218: PPUSH
118219: CALL_OW 263
118223: PUSH
118224: LD_INT 1
118226: EQUAL
118227: IFFALSE 118254
// if IsDrivenBy ( i ) then
118229: LD_VAR 0 4
118233: PPUSH
118234: CALL_OW 311
118238: IFFALSE 118254
// ComExitVehicle ( IsDrivenBy ( i ) ) ;
118240: LD_VAR 0 4
118244: PPUSH
118245: CALL_OW 311
118249: PPUSH
118250: CALL_OW 121
// end ;
118254: GO 118166
118256: POP
118257: POP
// until UnitFilter ( defenders , [ f_inarea , mc_parking [ base ] ] ) = defenders or mc_scan [ base ] or not mc_bases [ base ] ;
118258: LD_VAR 0 2
118262: PPUSH
118263: LD_INT 95
118265: PUSH
118266: LD_EXP 119
118270: PUSH
118271: LD_VAR 0 1
118275: ARRAY
118276: PUSH
118277: EMPTY
118278: LIST
118279: LIST
118280: PPUSH
118281: CALL_OW 72
118285: PUSH
118286: LD_VAR 0 2
118290: EQUAL
118291: PUSH
118292: LD_EXP 118
118296: PUSH
118297: LD_VAR 0 1
118301: ARRAY
118302: OR
118303: PUSH
118304: LD_EXP 95
118308: PUSH
118309: LD_VAR 0 1
118313: ARRAY
118314: NOT
118315: OR
118316: IFFALSE 118086
// end ; mc_defender := Replace ( mc_defender , base , UnitFilter ( defenders , [ f_type , unit_vehicle ] ) ) ;
118318: LD_ADDR_EXP 117
118322: PUSH
118323: LD_EXP 117
118327: PPUSH
118328: LD_VAR 0 1
118332: PPUSH
118333: LD_VAR 0 2
118337: PPUSH
118338: LD_INT 21
118340: PUSH
118341: LD_INT 2
118343: PUSH
118344: EMPTY
118345: LIST
118346: LIST
118347: PPUSH
118348: CALL_OW 72
118352: PPUSH
118353: CALL_OW 1
118357: ST_TO_ADDR
// MC_Reset ( base , 19 ) ;
118358: LD_VAR 0 1
118362: PPUSH
118363: LD_INT 19
118365: PPUSH
118366: CALL 25554 0 2
// MC_Reset ( base , 20 ) ;
118370: LD_VAR 0 1
118374: PPUSH
118375: LD_INT 20
118377: PPUSH
118378: CALL 25554 0 2
// end ; end_of_file
118382: LD_VAR 0 3
118386: RET
// on TargetableSAIL ( cmd , unit , selectedUnit , x , y , p1 , p2 , p3 , p4 , p5 , p6 ) do begin case cmd of 200 .. 299 :
118387: LD_VAR 0 1
118391: PUSH
118392: LD_INT 200
118394: DOUBLE
118395: GREATEREQUAL
118396: IFFALSE 118404
118398: LD_INT 299
118400: DOUBLE
118401: LESSEQUAL
118402: IFTRUE 118406
118404: GO 118438
118406: POP
// SOS_TargetableSAIL ( cmd , unit , selectedUnit , x , y ) ; 300 .. 399 :
118407: LD_VAR 0 1
118411: PPUSH
118412: LD_VAR 0 2
118416: PPUSH
118417: LD_VAR 0 3
118421: PPUSH
118422: LD_VAR 0 4
118426: PPUSH
118427: LD_VAR 0 5
118431: PPUSH
118432: CALL 106824 0 5
118436: GO 118515
118438: LD_INT 300
118440: DOUBLE
118441: GREATEREQUAL
118442: IFFALSE 118450
118444: LD_INT 399
118446: DOUBLE
118447: LESSEQUAL
118448: IFTRUE 118452
118450: GO 118514
118452: POP
// SOS_TargetableHack ( cmd , unit , selectedUnit , x , y , p1 , p2 , p3 , p4 , p5 , p6 ) ; end ;
118453: LD_VAR 0 1
118457: PPUSH
118458: LD_VAR 0 2
118462: PPUSH
118463: LD_VAR 0 3
118467: PPUSH
118468: LD_VAR 0 4
118472: PPUSH
118473: LD_VAR 0 5
118477: PPUSH
118478: LD_VAR 0 6
118482: PPUSH
118483: LD_VAR 0 7
118487: PPUSH
118488: LD_VAR 0 8
118492: PPUSH
118493: LD_VAR 0 9
118497: PPUSH
118498: LD_VAR 0 10
118502: PPUSH
118503: LD_VAR 0 11
118507: PPUSH
118508: CALL 104466 0 11
118512: GO 118515
118514: POP
// end ;
118515: PPOPN 11
118517: END
// on CommandUnitXY ( cmd , un , target , x , y ) do begin SOS_CommandUnitXY ( cmd , un , target , x , y ) ;
118518: LD_VAR 0 1
118522: PPUSH
118523: LD_VAR 0 2
118527: PPUSH
118528: LD_VAR 0 3
118532: PPUSH
118533: LD_VAR 0 4
118537: PPUSH
118538: LD_VAR 0 5
118542: PPUSH
118543: CALL 106560 0 5
// end ; end_of_file
118547: PPOPN 5
118549: END
// on CustomCommand ( p1 , p2 , p3 , p4 , p5 , p6 ) do begin SOS_CustomCommand ( p1 , p2 , p3 , p4 , p5 , p6 ) ;
118550: LD_VAR 0 1
118554: PPUSH
118555: LD_VAR 0 2
118559: PPUSH
118560: LD_VAR 0 3
118564: PPUSH
118565: LD_VAR 0 4
118569: PPUSH
118570: LD_VAR 0 5
118574: PPUSH
118575: LD_VAR 0 6
118579: PPUSH
118580: CALL 92159 0 6
// end ;
118584: PPOPN 6
118586: END
