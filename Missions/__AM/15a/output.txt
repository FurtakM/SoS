// starting begin ResetFog ;
   0: CALL_OW 335
// AnimateTrees ( true ) ;
   4: LD_INT 1
   6: PPUSH
   7: CALL_OW 573
// InitVariables ;
  11: CALL 73 0 0
// InitGlobalVariables ;
  15: CALL 21237 0 0
// InitMacro ;
  19: CALL 21405 0 0
// InitNature ;
  23: CALL 17903 0 0
// InitArtifact ;
  27: CALL 18520 0 0
// if debug then
  31: LD_EXP 1
  35: IFFALSE 44
// FogOff ( 1 ) ;
  37: LD_INT 1
  39: PPUSH
  40: CALL_OW 344
// PrepareAmerican ;
  44: CALL 5067 0 0
// PrepareAlliance ;
  48: CALL 1444 0 0
// PrepareArabian ;
  52: CALL 6839 0 0
// PrepareRussian ;
  56: CALL 8848 0 0
// PrepareLegion ;
  60: CALL 7271 0 0
// Action ;
  64: CALL 11466 0 0
// MC_Start ( ) ;
  68: CALL 23570 0 0
// end ;
  72: END
// export debug ; export russianDestroyed , legionDestroyed , americanDestroyed , arabianDestroyed ; export americanCapitulated , russianCapitulated , legionCapitulated ; export artifactArCaptured , alienSpotted , spawnOmar ; export artifactIResearched , artifactIIResearched , artifactIIIResearched ; export vehicleLostCounter , artifactDestroyCounter ; export allianceTeam , arabianAttacked ; export function InitVariables ; begin
  73: LD_INT 0
  75: PPUSH
// debug := false ;
  76: LD_ADDR_EXP 1
  80: PUSH
  81: LD_INT 0
  83: ST_TO_ADDR
// artifactArCaptured := LoadVariable ( 11_artifact_captured , 0 ) ;
  84: LD_ADDR_EXP 9
  88: PUSH
  89: LD_STRING 11_artifact_captured
  91: PPUSH
  92: LD_INT 0
  94: PPUSH
  95: CALL_OW 30
  99: ST_TO_ADDR
// russianDestroyed := false ;
 100: LD_ADDR_EXP 2
 104: PUSH
 105: LD_INT 0
 107: ST_TO_ADDR
// legionDestroyed := false ;
 108: LD_ADDR_EXP 3
 112: PUSH
 113: LD_INT 0
 115: ST_TO_ADDR
// americanDestroyed := false ;
 116: LD_ADDR_EXP 4
 120: PUSH
 121: LD_INT 0
 123: ST_TO_ADDR
// arabianDestroyed := false ;
 124: LD_ADDR_EXP 5
 128: PUSH
 129: LD_INT 0
 131: ST_TO_ADDR
// americanCapitulated := false ;
 132: LD_ADDR_EXP 6
 136: PUSH
 137: LD_INT 0
 139: ST_TO_ADDR
// russianCapitulated := false ;
 140: LD_ADDR_EXP 7
 144: PUSH
 145: LD_INT 0
 147: ST_TO_ADDR
// legionCapitulated := false ;
 148: LD_ADDR_EXP 8
 152: PUSH
 153: LD_INT 0
 155: ST_TO_ADDR
// artifactIResearched := false ;
 156: LD_ADDR_EXP 12
 160: PUSH
 161: LD_INT 0
 163: ST_TO_ADDR
// artifactIIResearched := false ;
 164: LD_ADDR_EXP 13
 168: PUSH
 169: LD_INT 0
 171: ST_TO_ADDR
// artifactIIIResearched := false ;
 172: LD_ADDR_EXP 14
 176: PUSH
 177: LD_INT 0
 179: ST_TO_ADDR
// alienSpotted := false ;
 180: LD_ADDR_EXP 10
 184: PUSH
 185: LD_INT 0
 187: ST_TO_ADDR
// spawnOmar := false ;
 188: LD_ADDR_EXP 11
 192: PUSH
 193: LD_INT 0
 195: ST_TO_ADDR
// vehicleLostCounter := 0 ;
 196: LD_ADDR_EXP 15
 200: PUSH
 201: LD_INT 0
 203: ST_TO_ADDR
// artifactDestroyCounter := 0 ;
 204: LD_ADDR_EXP 16
 208: PUSH
 209: LD_INT 0
 211: ST_TO_ADDR
// allianceTeam := [ ] ;
 212: LD_ADDR_EXP 17
 216: PUSH
 217: EMPTY
 218: ST_TO_ADDR
// arabianAttacked := false ;
 219: LD_ADDR_EXP 18
 223: PUSH
 224: LD_INT 0
 226: ST_TO_ADDR
// end ;
 227: LD_VAR 0 1
 231: RET
// export function CustomInitMacro ( ) ; begin
 232: LD_INT 0
 234: PPUSH
// mc_parking := [ arabianParkingArea , russianParkingArea , legionParkingArea , powellParking ] ;
 235: LD_ADDR_EXP 119
 239: PUSH
 240: LD_INT 26
 242: PUSH
 243: LD_INT 1
 245: PUSH
 246: LD_INT 4
 248: PUSH
 249: LD_INT 8
 251: PUSH
 252: EMPTY
 253: LIST
 254: LIST
 255: LIST
 256: LIST
 257: ST_TO_ADDR
// mc_scan_area := [ arabianBaseArea , russianBaseArea , legionBaseArea , powellBase ] ;
 258: LD_ADDR_EXP 120
 262: PUSH
 263: LD_INT 27
 265: PUSH
 266: LD_INT 2
 268: PUSH
 269: LD_INT 3
 271: PUSH
 272: LD_INT 7
 274: PUSH
 275: EMPTY
 276: LIST
 277: LIST
 278: LIST
 279: LIST
 280: ST_TO_ADDR
// MC_SetMinesField ( 1 , [ 6 , 7 , 9 , 10 ] [ Difficulty ] , arabianMinefield ) ;
 281: LD_INT 1
 283: PPUSH
 284: LD_INT 6
 286: PUSH
 287: LD_INT 7
 289: PUSH
 290: LD_INT 9
 292: PUSH
 293: LD_INT 10
 295: PUSH
 296: EMPTY
 297: LIST
 298: LIST
 299: LIST
 300: LIST
 301: PUSH
 302: LD_OWVAR 67
 306: ARRAY
 307: PPUSH
 308: LD_INT 28
 310: PPUSH
 311: CALL 45259 0 3
// MC_SetLabKind ( 1 , [ b_lab_weapon , b_lab_siberium , b_lab_biological , b_lab_opto ] ) ;
 315: LD_INT 1
 317: PPUSH
 318: LD_INT 10
 320: PUSH
 321: LD_INT 11
 323: PUSH
 324: LD_INT 13
 326: PUSH
 327: LD_INT 15
 329: PUSH
 330: EMPTY
 331: LIST
 332: LIST
 333: LIST
 334: LIST
 335: PPUSH
 336: CALL 46319 0 2
// MC_SetCratesArea ( 1 , [ arabianCratesArea ] ) ;
 340: LD_INT 1
 342: PPUSH
 343: LD_INT 29
 345: PUSH
 346: EMPTY
 347: LIST
 348: PPUSH
 349: CALL 46412 0 2
// mc_ape := Replace ( mc_ape , 1 , FilterAllUnits ( [ [ f_side , 2 ] , [ f_class , class_apeman_soldier ] ] ) ) ;
 353: LD_ADDR_EXP 124
 357: PUSH
 358: LD_EXP 124
 362: PPUSH
 363: LD_INT 1
 365: PPUSH
 366: LD_INT 22
 368: PUSH
 369: LD_INT 2
 371: PUSH
 372: EMPTY
 373: LIST
 374: LIST
 375: PUSH
 376: LD_INT 25
 378: PUSH
 379: LD_INT 15
 381: PUSH
 382: EMPTY
 383: LIST
 384: LIST
 385: PUSH
 386: EMPTY
 387: LIST
 388: LIST
 389: PPUSH
 390: CALL_OW 69
 394: PPUSH
 395: CALL_OW 1
 399: ST_TO_ADDR
// MC_SetProduceList ( 1 , [ [ ar_medium_trike , engine_solar , control_manual , ar_control_tower ] , [ ar_medium_trike , engine_solar , control_manual , ar_control_tower ] , [ ar_medium_trike , engine_combustion , control_manual , ar_rocket_launcher ] , [ ar_medium_trike , engine_combustion , control_manual , ar_rocket_launcher ] , [ ar_medium_trike , engine_combustion , control_manual , ar_rocket_launcher ] , [ ar_medium_trike , engine_combustion , control_manual , ar_rocket_launcher ] , [ ar_medium_trike , engine_combustion , control_remote , ar_crane ] ] ) ;
 400: LD_INT 1
 402: PPUSH
 403: LD_INT 13
 405: PUSH
 406: LD_INT 2
 408: PUSH
 409: LD_INT 1
 411: PUSH
 412: LD_INT 31
 414: PUSH
 415: EMPTY
 416: LIST
 417: LIST
 418: LIST
 419: LIST
 420: PUSH
 421: LD_INT 13
 423: PUSH
 424: LD_INT 2
 426: PUSH
 427: LD_INT 1
 429: PUSH
 430: LD_INT 31
 432: PUSH
 433: EMPTY
 434: LIST
 435: LIST
 436: LIST
 437: LIST
 438: PUSH
 439: LD_INT 13
 441: PUSH
 442: LD_INT 1
 444: PUSH
 445: LD_INT 1
 447: PUSH
 448: LD_INT 28
 450: PUSH
 451: EMPTY
 452: LIST
 453: LIST
 454: LIST
 455: LIST
 456: PUSH
 457: LD_INT 13
 459: PUSH
 460: LD_INT 1
 462: PUSH
 463: LD_INT 1
 465: PUSH
 466: LD_INT 28
 468: PUSH
 469: EMPTY
 470: LIST
 471: LIST
 472: LIST
 473: LIST
 474: PUSH
 475: LD_INT 13
 477: PUSH
 478: LD_INT 1
 480: PUSH
 481: LD_INT 1
 483: PUSH
 484: LD_INT 28
 486: PUSH
 487: EMPTY
 488: LIST
 489: LIST
 490: LIST
 491: LIST
 492: PUSH
 493: LD_INT 13
 495: PUSH
 496: LD_INT 1
 498: PUSH
 499: LD_INT 1
 501: PUSH
 502: LD_INT 28
 504: PUSH
 505: EMPTY
 506: LIST
 507: LIST
 508: LIST
 509: LIST
 510: PUSH
 511: LD_INT 13
 513: PUSH
 514: LD_INT 1
 516: PUSH
 517: LD_INT 2
 519: PUSH
 520: LD_EXP 80
 524: PUSH
 525: EMPTY
 526: LIST
 527: LIST
 528: LIST
 529: LIST
 530: PUSH
 531: EMPTY
 532: LIST
 533: LIST
 534: LIST
 535: LIST
 536: LIST
 537: LIST
 538: LIST
 539: PPUSH
 540: CALL 45577 0 2
// MC_SetDefenderLimit ( 1 , 4 ) ;
 544: LD_INT 1
 546: PPUSH
 547: LD_INT 4
 549: PPUSH
 550: CALL 45762 0 2
// MC_SetLabKind ( 2 , [ b_lab_weapon , b_lab_siberium , b_lab_computer , b_lab_spacetime ] ) ;
 554: LD_INT 2
 556: PPUSH
 557: LD_INT 10
 559: PUSH
 560: LD_INT 11
 562: PUSH
 563: LD_INT 12
 565: PUSH
 566: LD_INT 14
 568: PUSH
 569: EMPTY
 570: LIST
 571: LIST
 572: LIST
 573: LIST
 574: PPUSH
 575: CALL 46319 0 2
// MC_SetCratesArea ( 2 , [ russianCratesArea ] ) ;
 579: LD_INT 2
 581: PPUSH
 582: LD_INT 14
 584: PUSH
 585: EMPTY
 586: LIST
 587: PPUSH
 588: CALL 46412 0 2
// MC_SetProduceList ( 2 , [ [ ru_medium_wheeled , engine_siberite , control_computer , ru_cargo_bay ] , [ ru_medium_tracked , engine_siberite , control_computer , ru_crane ] , [ ru_medium_tracked , engine_siberite , control_computer , ru_crane ] , [ ru_heavy_tracked , engine_siberite , control_computer , ru_rocket ] , [ ru_heavy_tracked , engine_siberite , control_computer , ru_rocket ] , [ ru_heavy_tracked , engine_siberite , control_computer , ru_rocket ] , [ ru_heavy_tracked , engine_siberite , control_computer , ru_rocket ] , [ ru_heavy_tracked , engine_siberite , control_computer , ru_rocket ] ] ) ;
 592: LD_INT 2
 594: PPUSH
 595: LD_INT 21
 597: PUSH
 598: LD_INT 3
 600: PUSH
 601: LD_INT 3
 603: PUSH
 604: LD_INT 51
 606: PUSH
 607: EMPTY
 608: LIST
 609: LIST
 610: LIST
 611: LIST
 612: PUSH
 613: LD_INT 22
 615: PUSH
 616: LD_INT 3
 618: PUSH
 619: LD_INT 3
 621: PUSH
 622: LD_INT 52
 624: PUSH
 625: EMPTY
 626: LIST
 627: LIST
 628: LIST
 629: LIST
 630: PUSH
 631: LD_INT 22
 633: PUSH
 634: LD_INT 3
 636: PUSH
 637: LD_INT 3
 639: PUSH
 640: LD_INT 52
 642: PUSH
 643: EMPTY
 644: LIST
 645: LIST
 646: LIST
 647: LIST
 648: PUSH
 649: LD_INT 24
 651: PUSH
 652: LD_INT 3
 654: PUSH
 655: LD_INT 3
 657: PUSH
 658: LD_INT 47
 660: PUSH
 661: EMPTY
 662: LIST
 663: LIST
 664: LIST
 665: LIST
 666: PUSH
 667: LD_INT 24
 669: PUSH
 670: LD_INT 3
 672: PUSH
 673: LD_INT 3
 675: PUSH
 676: LD_INT 47
 678: PUSH
 679: EMPTY
 680: LIST
 681: LIST
 682: LIST
 683: LIST
 684: PUSH
 685: LD_INT 24
 687: PUSH
 688: LD_INT 3
 690: PUSH
 691: LD_INT 3
 693: PUSH
 694: LD_INT 47
 696: PUSH
 697: EMPTY
 698: LIST
 699: LIST
 700: LIST
 701: LIST
 702: PUSH
 703: LD_INT 24
 705: PUSH
 706: LD_INT 3
 708: PUSH
 709: LD_INT 3
 711: PUSH
 712: LD_INT 47
 714: PUSH
 715: EMPTY
 716: LIST
 717: LIST
 718: LIST
 719: LIST
 720: PUSH
 721: LD_INT 24
 723: PUSH
 724: LD_INT 3
 726: PUSH
 727: LD_INT 3
 729: PUSH
 730: LD_INT 47
 732: PUSH
 733: EMPTY
 734: LIST
 735: LIST
 736: LIST
 737: LIST
 738: PUSH
 739: EMPTY
 740: LIST
 741: LIST
 742: LIST
 743: LIST
 744: LIST
 745: LIST
 746: LIST
 747: LIST
 748: PPUSH
 749: CALL 45577 0 2
// MC_SetDefenderLimit ( 2 , 5 ) ;
 753: LD_INT 2
 755: PPUSH
 756: LD_INT 5
 758: PPUSH
 759: CALL 45762 0 2
// MC_SetUpgradeBuilding ( 2 , b_depot ) ;
 763: LD_INT 2
 765: PPUSH
 766: LD_INT 0
 768: PPUSH
 769: CALL 46192 0 2
// MC_SetMinesField ( 3 , [ 10 , 12 , 14 , 15 ] [ Difficulty ] , legionMinefield ) ;
 773: LD_INT 3
 775: PPUSH
 776: LD_INT 10
 778: PUSH
 779: LD_INT 12
 781: PUSH
 782: LD_INT 14
 784: PUSH
 785: LD_INT 15
 787: PUSH
 788: EMPTY
 789: LIST
 790: LIST
 791: LIST
 792: LIST
 793: PUSH
 794: LD_OWVAR 67
 798: ARRAY
 799: PPUSH
 800: LD_INT 24
 802: PPUSH
 803: CALL 45259 0 3
// MC_SetLabKind ( 3 , [ b_lab_weapon , b_lab_siberium , b_lab_biological , b_lab_opto ] ) ;
 807: LD_INT 3
 809: PPUSH
 810: LD_INT 10
 812: PUSH
 813: LD_INT 11
 815: PUSH
 816: LD_INT 13
 818: PUSH
 819: LD_INT 15
 821: PUSH
 822: EMPTY
 823: LIST
 824: LIST
 825: LIST
 826: LIST
 827: PPUSH
 828: CALL 46319 0 2
// MC_SetCratesArea ( 3 , [ legionCratesArea ] ) ;
 832: LD_INT 3
 834: PPUSH
 835: LD_INT 13
 837: PUSH
 838: EMPTY
 839: LIST
 840: PPUSH
 841: CALL 46412 0 2
// mc_ape := Replace ( mc_ape , 3 , FilterAllUnits ( [ [ f_side , 8 ] , [ f_class , class_apeman_soldier ] ] ) ) ;
 845: LD_ADDR_EXP 124
 849: PUSH
 850: LD_EXP 124
 854: PPUSH
 855: LD_INT 3
 857: PPUSH
 858: LD_INT 22
 860: PUSH
 861: LD_INT 8
 863: PUSH
 864: EMPTY
 865: LIST
 866: LIST
 867: PUSH
 868: LD_INT 25
 870: PUSH
 871: LD_INT 15
 873: PUSH
 874: EMPTY
 875: LIST
 876: LIST
 877: PUSH
 878: EMPTY
 879: LIST
 880: LIST
 881: PPUSH
 882: CALL_OW 69
 886: PPUSH
 887: CALL_OW 1
 891: ST_TO_ADDR
// MC_SetProduceList ( 3 , [ [ ar_medium_trike , engine_solar , control_manual , ar_control_tower ] , [ ar_medium_trike , engine_solar , control_manual , ar_control_tower ] , [ ar_medium_trike , engine_siberite , control_remote , ar_cargo_bay ] , [ ar_half_tracked , engine_combustion , control_manual , ar_rocket_launcher ] , [ ar_half_tracked , engine_combustion , control_manual , ar_rocket_launcher ] , [ ar_half_tracked , engine_combustion , control_manual , ar_rocket_launcher ] , [ ar_half_tracked , engine_combustion , control_manual , ar_rocket_launcher ] , [ ar_half_tracked , engine_combustion , control_remote , ar_crane ] ] ) ;
 892: LD_INT 3
 894: PPUSH
 895: LD_INT 13
 897: PUSH
 898: LD_INT 2
 900: PUSH
 901: LD_INT 1
 903: PUSH
 904: LD_INT 31
 906: PUSH
 907: EMPTY
 908: LIST
 909: LIST
 910: LIST
 911: LIST
 912: PUSH
 913: LD_INT 13
 915: PUSH
 916: LD_INT 2
 918: PUSH
 919: LD_INT 1
 921: PUSH
 922: LD_INT 31
 924: PUSH
 925: EMPTY
 926: LIST
 927: LIST
 928: LIST
 929: LIST
 930: PUSH
 931: LD_INT 13
 933: PUSH
 934: LD_INT 3
 936: PUSH
 937: LD_INT 2
 939: PUSH
 940: LD_INT 32
 942: PUSH
 943: EMPTY
 944: LIST
 945: LIST
 946: LIST
 947: LIST
 948: PUSH
 949: LD_INT 14
 951: PUSH
 952: LD_INT 1
 954: PUSH
 955: LD_INT 1
 957: PUSH
 958: LD_INT 28
 960: PUSH
 961: EMPTY
 962: LIST
 963: LIST
 964: LIST
 965: LIST
 966: PUSH
 967: LD_INT 14
 969: PUSH
 970: LD_INT 1
 972: PUSH
 973: LD_INT 1
 975: PUSH
 976: LD_INT 28
 978: PUSH
 979: EMPTY
 980: LIST
 981: LIST
 982: LIST
 983: LIST
 984: PUSH
 985: LD_INT 14
 987: PUSH
 988: LD_INT 1
 990: PUSH
 991: LD_INT 1
 993: PUSH
 994: LD_INT 28
 996: PUSH
 997: EMPTY
 998: LIST
 999: LIST
1000: LIST
1001: LIST
1002: PUSH
1003: LD_INT 14
1005: PUSH
1006: LD_INT 1
1008: PUSH
1009: LD_INT 1
1011: PUSH
1012: LD_INT 28
1014: PUSH
1015: EMPTY
1016: LIST
1017: LIST
1018: LIST
1019: LIST
1020: PUSH
1021: LD_INT 14
1023: PUSH
1024: LD_INT 1
1026: PUSH
1027: LD_INT 2
1029: PUSH
1030: LD_EXP 80
1034: PUSH
1035: EMPTY
1036: LIST
1037: LIST
1038: LIST
1039: LIST
1040: PUSH
1041: EMPTY
1042: LIST
1043: LIST
1044: LIST
1045: LIST
1046: LIST
1047: LIST
1048: LIST
1049: LIST
1050: PPUSH
1051: CALL 45577 0 2
// MC_SetDefenderLimit ( 3 , 4 ) ;
1055: LD_INT 3
1057: PPUSH
1058: LD_INT 4
1060: PPUSH
1061: CALL 45762 0 2
// MC_SetLabKind ( 4 , [ b_lab_weapon , b_lab_computer , b_lab_siberium , b_lab_opto ] ) ;
1065: LD_INT 4
1067: PPUSH
1068: LD_INT 10
1070: PUSH
1071: LD_INT 12
1073: PUSH
1074: LD_INT 11
1076: PUSH
1077: LD_INT 15
1079: PUSH
1080: EMPTY
1081: LIST
1082: LIST
1083: LIST
1084: LIST
1085: PPUSH
1086: CALL 46319 0 2
// MC_SetCratesArea ( 4 , [ americanCratesArea ] ) ;
1090: LD_INT 4
1092: PPUSH
1093: LD_INT 33
1095: PUSH
1096: EMPTY
1097: LIST
1098: PPUSH
1099: CALL 46412 0 2
// MC_SetAllowedTurretWeapons ( 4 , [ us_double_gun , us_heavy_gun , us_rocket_launcher , us_laser , us_double_laser ] ) ;
1103: LD_INT 4
1105: PPUSH
1106: LD_INT 5
1108: PUSH
1109: LD_INT 6
1111: PUSH
1112: LD_INT 7
1114: PUSH
1115: LD_INT 9
1117: PUSH
1118: LD_INT 10
1120: PUSH
1121: EMPTY
1122: LIST
1123: LIST
1124: LIST
1125: LIST
1126: LIST
1127: PPUSH
1128: CALL 46730 0 2
// MC_SetFactoryExtension ( 4 , 54 , 85 , 2 , [ b_ext_laser , b_ext_track , b_ext_gun , b_ext_rocket , b_ext_radio ] ) ;
1132: LD_INT 4
1134: PPUSH
1135: LD_INT 54
1137: PPUSH
1138: LD_INT 85
1140: PPUSH
1141: LD_INT 2
1143: PPUSH
1144: LD_INT 25
1146: PUSH
1147: LD_INT 16
1149: PUSH
1150: LD_INT 17
1152: PUSH
1153: LD_INT 18
1155: PUSH
1156: LD_INT 22
1158: PUSH
1159: EMPTY
1160: LIST
1161: LIST
1162: LIST
1163: LIST
1164: LIST
1165: PPUSH
1166: CALL 46524 0 5
// MC_SetProduceList ( 4 , [ [ us_morphling , engine_combustion , control_manual , us_rocket_launcher ] , [ us_morphling , engine_combustion , control_manual , us_heavy_gun ] , [ us_morphling , engine_combustion , control_manual , us_rocket_launcher ] , [ us_morphling , engine_combustion , control_manual , us_heavy_gun ] , [ us_morphling , engine_combustion , control_computer , us_cargo_bay ] , [ us_medium_tracked , engine_combustion , control_computer , us_crane ] ] ) ;
1170: LD_INT 4
1172: PPUSH
1173: LD_INT 5
1175: PUSH
1176: LD_INT 1
1178: PUSH
1179: LD_INT 1
1181: PUSH
1182: LD_INT 7
1184: PUSH
1185: EMPTY
1186: LIST
1187: LIST
1188: LIST
1189: LIST
1190: PUSH
1191: LD_INT 5
1193: PUSH
1194: LD_INT 1
1196: PUSH
1197: LD_INT 1
1199: PUSH
1200: LD_INT 6
1202: PUSH
1203: EMPTY
1204: LIST
1205: LIST
1206: LIST
1207: LIST
1208: PUSH
1209: LD_INT 5
1211: PUSH
1212: LD_INT 1
1214: PUSH
1215: LD_INT 1
1217: PUSH
1218: LD_INT 7
1220: PUSH
1221: EMPTY
1222: LIST
1223: LIST
1224: LIST
1225: LIST
1226: PUSH
1227: LD_INT 5
1229: PUSH
1230: LD_INT 1
1232: PUSH
1233: LD_INT 1
1235: PUSH
1236: LD_INT 6
1238: PUSH
1239: EMPTY
1240: LIST
1241: LIST
1242: LIST
1243: LIST
1244: PUSH
1245: LD_INT 5
1247: PUSH
1248: LD_INT 1
1250: PUSH
1251: LD_INT 3
1253: PUSH
1254: LD_INT 12
1256: PUSH
1257: EMPTY
1258: LIST
1259: LIST
1260: LIST
1261: LIST
1262: PUSH
1263: LD_INT 3
1265: PUSH
1266: LD_INT 1
1268: PUSH
1269: LD_INT 3
1271: PUSH
1272: LD_INT 13
1274: PUSH
1275: EMPTY
1276: LIST
1277: LIST
1278: LIST
1279: LIST
1280: PUSH
1281: EMPTY
1282: LIST
1283: LIST
1284: LIST
1285: LIST
1286: LIST
1287: LIST
1288: PPUSH
1289: CALL 45577 0 2
// MC_SetDefenderLimit ( 4 , 4 ) ;
1293: LD_INT 4
1295: PPUSH
1296: LD_INT 4
1298: PPUSH
1299: CALL 45762 0 2
// MC_SetTame ( 4 , powellApe ) ;
1303: LD_INT 4
1305: PPUSH
1306: LD_INT 11
1308: PPUSH
1309: CALL 46143 0 2
// end ;
1313: LD_VAR 0 1
1317: RET
// every 0 0$1 trigger debug do var i ;
1318: LD_EXP 1
1322: IFFALSE 1420
1324: GO 1326
1326: DISABLE
1327: LD_INT 0
1329: PPUSH
// begin enable ;
1330: ENABLE
// for i in FilterAllUnits ( [ [ f_side , 7 ] , [ f_or , [ f_type , unit_human ] , [ f_type , unit_vehicle ] ] , [ f_not , [ f_lives , 1000 ] ] ] ) do
1331: LD_ADDR_VAR 0 1
1335: PUSH
1336: LD_INT 22
1338: PUSH
1339: LD_INT 7
1341: PUSH
1342: EMPTY
1343: LIST
1344: LIST
1345: PUSH
1346: LD_INT 2
1348: PUSH
1349: LD_INT 21
1351: PUSH
1352: LD_INT 1
1354: PUSH
1355: EMPTY
1356: LIST
1357: LIST
1358: PUSH
1359: LD_INT 21
1361: PUSH
1362: LD_INT 2
1364: PUSH
1365: EMPTY
1366: LIST
1367: LIST
1368: PUSH
1369: EMPTY
1370: LIST
1371: LIST
1372: LIST
1373: PUSH
1374: LD_INT 3
1376: PUSH
1377: LD_INT 24
1379: PUSH
1380: LD_INT 1000
1382: PUSH
1383: EMPTY
1384: LIST
1385: LIST
1386: PUSH
1387: EMPTY
1388: LIST
1389: LIST
1390: PUSH
1391: EMPTY
1392: LIST
1393: LIST
1394: LIST
1395: PPUSH
1396: CALL_OW 69
1400: PUSH
1401: FOR_IN
1402: IFFALSE 1418
// SetLives ( i , 1000 ) ;
1404: LD_VAR 0 1
1408: PPUSH
1409: LD_INT 1000
1411: PPUSH
1412: CALL_OW 234
1416: GO 1401
1418: POP
1419: POP
// end ;
1420: PPOPN 1
1422: END
// every 0 0$1 trigger artifactDestroyCounter >= 5 do
1423: LD_EXP 16
1427: PUSH
1428: LD_INT 5
1430: GREATEREQUAL
1431: IFFALSE 1443
1433: GO 1435
1435: DISABLE
// SetAchievement ( ACH_ARTIFACT ) ; end_of_file
1436: LD_STRING ACH_ARTIFACT
1438: PPUSH
1439: CALL_OW 543
1443: END
// export JMM , Roth , Lisa , Donaldson , Bobby , Cyrus , Denis , Brown , Gladstone , Houten , Cornel , Gary , Frank , Kikuchi , Simms , Joan , DeltaDoctor , Connie ; export Gossudarov , Kirilenkova , Titov , Fadeev , Dolgov , Petrosyan , Scholtze , Oblukov , Kapitsova , Lipshchin , Petrovova , Kovalyuk , Kuzmov , Karamazov ; export Burlak , Belkov , Gnyevko ; export function PrepareAlliance ; var i , veh , selected , tmp ; begin
1444: LD_INT 0
1446: PPUSH
1447: PPUSH
1448: PPUSH
1449: PPUSH
1450: PPUSH
// uc_side := 7 ;
1451: LD_ADDR_OWVAR 20
1455: PUSH
1456: LD_INT 7
1458: ST_TO_ADDR
// tmp := [ ] ;
1459: LD_ADDR_VAR 0 5
1463: PUSH
1464: EMPTY
1465: ST_TO_ADDR
// JMM := PrepareUnit ( JMM , ( not debug ) , 14a_ ) ;
1466: LD_ADDR_EXP 19
1470: PUSH
1471: LD_STRING JMM
1473: PPUSH
1474: LD_EXP 1
1478: NOT
1479: PPUSH
1480: LD_STRING 14a_
1482: PPUSH
1483: CALL 52031 0 3
1487: ST_TO_ADDR
// Burlak := PrepareUnit ( Burlak , ( not debug ) , 14a_ ) ;
1488: LD_ADDR_EXP 51
1492: PUSH
1493: LD_STRING Burlak
1495: PPUSH
1496: LD_EXP 1
1500: NOT
1501: PPUSH
1502: LD_STRING 14a_
1504: PPUSH
1505: CALL 52031 0 3
1509: ST_TO_ADDR
// Joan := PrepareUnit ( Joan , ( not debug ) , 13a_ ) ;
1510: LD_ADDR_EXP 34
1514: PUSH
1515: LD_STRING Joan
1517: PPUSH
1518: LD_EXP 1
1522: NOT
1523: PPUSH
1524: LD_STRING 13a_
1526: PPUSH
1527: CALL 52031 0 3
1531: ST_TO_ADDR
// Roth := PrepareUnit ( Roth , ( not debug ) , 13a_ ) ;
1532: LD_ADDR_EXP 20
1536: PUSH
1537: LD_STRING Roth
1539: PPUSH
1540: LD_EXP 1
1544: NOT
1545: PPUSH
1546: LD_STRING 13a_
1548: PPUSH
1549: CALL 52031 0 3
1553: ST_TO_ADDR
// Gossudarov := PrepareUnit ( Gossudarov , ( not debug ) , 13a_ ) ;
1554: LD_ADDR_EXP 37
1558: PUSH
1559: LD_STRING Gossudarov
1561: PPUSH
1562: LD_EXP 1
1566: NOT
1567: PPUSH
1568: LD_STRING 13a_
1570: PPUSH
1571: CALL 52031 0 3
1575: ST_TO_ADDR
// Denis := PrepareUnit ( Denis , ( not debug ) , 13a_ ) ;
1576: LD_ADDR_EXP 25
1580: PUSH
1581: LD_STRING Denis
1583: PPUSH
1584: LD_EXP 1
1588: NOT
1589: PPUSH
1590: LD_STRING 13a_
1592: PPUSH
1593: CALL 52031 0 3
1597: ST_TO_ADDR
// DeltaDoctor := PrepareUnit ( DeltaDoctor , ( not debug ) , 13a_ ) ;
1598: LD_ADDR_EXP 35
1602: PUSH
1603: LD_STRING DeltaDoctor
1605: PPUSH
1606: LD_EXP 1
1610: NOT
1611: PPUSH
1612: LD_STRING 13a_
1614: PPUSH
1615: CALL 52031 0 3
1619: ST_TO_ADDR
// if DeltaDoctor then
1620: LD_EXP 35
1624: IFFALSE 1642
// tmp := tmp ^ DeltaDoctor ;
1626: LD_ADDR_VAR 0 5
1630: PUSH
1631: LD_VAR 0 5
1635: PUSH
1636: LD_EXP 35
1640: ADD
1641: ST_TO_ADDR
// Simms := PrepareUnit ( Simms , ( not debug ) , 13a_ ) ;
1642: LD_ADDR_EXP 33
1646: PUSH
1647: LD_STRING Simms
1649: PPUSH
1650: LD_EXP 1
1654: NOT
1655: PPUSH
1656: LD_STRING 13a_
1658: PPUSH
1659: CALL 52031 0 3
1663: ST_TO_ADDR
// if Simms then
1664: LD_EXP 33
1668: IFFALSE 1686
// tmp := tmp ^ Simms ;
1670: LD_ADDR_VAR 0 5
1674: PUSH
1675: LD_VAR 0 5
1679: PUSH
1680: LD_EXP 33
1684: ADD
1685: ST_TO_ADDR
// Frank := PrepareUnit ( Frank , ( not debug ) , 13a_ ) ;
1686: LD_ADDR_EXP 31
1690: PUSH
1691: LD_STRING Frank
1693: PPUSH
1694: LD_EXP 1
1698: NOT
1699: PPUSH
1700: LD_STRING 13a_
1702: PPUSH
1703: CALL 52031 0 3
1707: ST_TO_ADDR
// if Frank then
1708: LD_EXP 31
1712: IFFALSE 1730
// tmp := tmp ^ Frank ;
1714: LD_ADDR_VAR 0 5
1718: PUSH
1719: LD_VAR 0 5
1723: PUSH
1724: LD_EXP 31
1728: ADD
1729: ST_TO_ADDR
// Kirilenkova := PrepareUnit ( Kirilenkova , ( not debug ) , 13a_ ) ;
1730: LD_ADDR_EXP 38
1734: PUSH
1735: LD_STRING Kirilenkova
1737: PPUSH
1738: LD_EXP 1
1742: NOT
1743: PPUSH
1744: LD_STRING 13a_
1746: PPUSH
1747: CALL 52031 0 3
1751: ST_TO_ADDR
// if Kirilenkova then
1752: LD_EXP 38
1756: IFFALSE 1774
// tmp := tmp ^ Kirilenkova ;
1758: LD_ADDR_VAR 0 5
1762: PUSH
1763: LD_VAR 0 5
1767: PUSH
1768: LD_EXP 38
1772: ADD
1773: ST_TO_ADDR
// Titov := PrepareUnit ( Titov , ( not debug ) , 13a_ ) ;
1774: LD_ADDR_EXP 39
1778: PUSH
1779: LD_STRING Titov
1781: PPUSH
1782: LD_EXP 1
1786: NOT
1787: PPUSH
1788: LD_STRING 13a_
1790: PPUSH
1791: CALL 52031 0 3
1795: ST_TO_ADDR
// if Titov then
1796: LD_EXP 39
1800: IFFALSE 1818
// tmp := tmp ^ Titov ;
1802: LD_ADDR_VAR 0 5
1806: PUSH
1807: LD_VAR 0 5
1811: PUSH
1812: LD_EXP 39
1816: ADD
1817: ST_TO_ADDR
// Fadeev := PrepareUnit ( Fadeev , ( not debug ) , 13a_ ) ;
1818: LD_ADDR_EXP 40
1822: PUSH
1823: LD_STRING Fadeev
1825: PPUSH
1826: LD_EXP 1
1830: NOT
1831: PPUSH
1832: LD_STRING 13a_
1834: PPUSH
1835: CALL 52031 0 3
1839: ST_TO_ADDR
// if Fadeev then
1840: LD_EXP 40
1844: IFFALSE 1862
// tmp := tmp ^ Fadeev ;
1846: LD_ADDR_VAR 0 5
1850: PUSH
1851: LD_VAR 0 5
1855: PUSH
1856: LD_EXP 40
1860: ADD
1861: ST_TO_ADDR
// Dolgov := PrepareUnit ( Dolgov , ( not debug ) , 13a_ ) ;
1862: LD_ADDR_EXP 41
1866: PUSH
1867: LD_STRING Dolgov
1869: PPUSH
1870: LD_EXP 1
1874: NOT
1875: PPUSH
1876: LD_STRING 13a_
1878: PPUSH
1879: CALL 52031 0 3
1883: ST_TO_ADDR
// if Dolgov then
1884: LD_EXP 41
1888: IFFALSE 1906
// tmp := tmp ^ Dolgov ;
1890: LD_ADDR_VAR 0 5
1894: PUSH
1895: LD_VAR 0 5
1899: PUSH
1900: LD_EXP 41
1904: ADD
1905: ST_TO_ADDR
// Petrosyan := PrepareUnit ( Petrosyan , ( not debug ) , 13a_ ) ;
1906: LD_ADDR_EXP 42
1910: PUSH
1911: LD_STRING Petrosyan
1913: PPUSH
1914: LD_EXP 1
1918: NOT
1919: PPUSH
1920: LD_STRING 13a_
1922: PPUSH
1923: CALL 52031 0 3
1927: ST_TO_ADDR
// if Petrosyan then
1928: LD_EXP 42
1932: IFFALSE 1950
// tmp := tmp ^ Petrosyan ;
1934: LD_ADDR_VAR 0 5
1938: PUSH
1939: LD_VAR 0 5
1943: PUSH
1944: LD_EXP 42
1948: ADD
1949: ST_TO_ADDR
// Scholtze := PrepareUnit ( Scholtze , ( not debug ) , 13a_ ) ;
1950: LD_ADDR_EXP 43
1954: PUSH
1955: LD_STRING Scholtze
1957: PPUSH
1958: LD_EXP 1
1962: NOT
1963: PPUSH
1964: LD_STRING 13a_
1966: PPUSH
1967: CALL 52031 0 3
1971: ST_TO_ADDR
// if Scholtze then
1972: LD_EXP 43
1976: IFFALSE 1994
// tmp := tmp ^ Scholtze ;
1978: LD_ADDR_VAR 0 5
1982: PUSH
1983: LD_VAR 0 5
1987: PUSH
1988: LD_EXP 43
1992: ADD
1993: ST_TO_ADDR
// Oblukov := PrepareUnit ( Oblukov , ( not debug ) , 13a_ ) ;
1994: LD_ADDR_EXP 44
1998: PUSH
1999: LD_STRING Oblukov
2001: PPUSH
2002: LD_EXP 1
2006: NOT
2007: PPUSH
2008: LD_STRING 13a_
2010: PPUSH
2011: CALL 52031 0 3
2015: ST_TO_ADDR
// if Oblukov then
2016: LD_EXP 44
2020: IFFALSE 2038
// tmp := tmp ^ Oblukov ;
2022: LD_ADDR_VAR 0 5
2026: PUSH
2027: LD_VAR 0 5
2031: PUSH
2032: LD_EXP 44
2036: ADD
2037: ST_TO_ADDR
// Kapitsova := PrepareUnit ( Kapitsova , ( not debug ) , 13a_ ) ;
2038: LD_ADDR_EXP 45
2042: PUSH
2043: LD_STRING Kapitsova
2045: PPUSH
2046: LD_EXP 1
2050: NOT
2051: PPUSH
2052: LD_STRING 13a_
2054: PPUSH
2055: CALL 52031 0 3
2059: ST_TO_ADDR
// if Kapitsova then
2060: LD_EXP 45
2064: IFFALSE 2082
// tmp := tmp ^ Kapitsova ;
2066: LD_ADDR_VAR 0 5
2070: PUSH
2071: LD_VAR 0 5
2075: PUSH
2076: LD_EXP 45
2080: ADD
2081: ST_TO_ADDR
// Lipshchin := PrepareUnit ( Lipshchin , ( not debug ) , 13a_ ) ;
2082: LD_ADDR_EXP 46
2086: PUSH
2087: LD_STRING Lipshchin
2089: PPUSH
2090: LD_EXP 1
2094: NOT
2095: PPUSH
2096: LD_STRING 13a_
2098: PPUSH
2099: CALL 52031 0 3
2103: ST_TO_ADDR
// if Lipshchin then
2104: LD_EXP 46
2108: IFFALSE 2126
// tmp := tmp ^ Lipshchin ;
2110: LD_ADDR_VAR 0 5
2114: PUSH
2115: LD_VAR 0 5
2119: PUSH
2120: LD_EXP 46
2124: ADD
2125: ST_TO_ADDR
// Petrovova := PrepareUnit ( Petrovova , ( not debug ) , 13a_ ) ;
2126: LD_ADDR_EXP 47
2130: PUSH
2131: LD_STRING Petrovova
2133: PPUSH
2134: LD_EXP 1
2138: NOT
2139: PPUSH
2140: LD_STRING 13a_
2142: PPUSH
2143: CALL 52031 0 3
2147: ST_TO_ADDR
// if Petrovova then
2148: LD_EXP 47
2152: IFFALSE 2170
// tmp := tmp ^ Petrovova ;
2154: LD_ADDR_VAR 0 5
2158: PUSH
2159: LD_VAR 0 5
2163: PUSH
2164: LD_EXP 47
2168: ADD
2169: ST_TO_ADDR
// Kovalyuk := PrepareUnit ( Kovalyuk , ( not debug ) , 13a_ ) ;
2170: LD_ADDR_EXP 48
2174: PUSH
2175: LD_STRING Kovalyuk
2177: PPUSH
2178: LD_EXP 1
2182: NOT
2183: PPUSH
2184: LD_STRING 13a_
2186: PPUSH
2187: CALL 52031 0 3
2191: ST_TO_ADDR
// if Kovalyuk then
2192: LD_EXP 48
2196: IFFALSE 2214
// tmp := tmp ^ Kovalyuk ;
2198: LD_ADDR_VAR 0 5
2202: PUSH
2203: LD_VAR 0 5
2207: PUSH
2208: LD_EXP 48
2212: ADD
2213: ST_TO_ADDR
// Kuzmov := PrepareUnit ( Kuzmov , ( not debug ) , 13a_ ) ;
2214: LD_ADDR_EXP 49
2218: PUSH
2219: LD_STRING Kuzmov
2221: PPUSH
2222: LD_EXP 1
2226: NOT
2227: PPUSH
2228: LD_STRING 13a_
2230: PPUSH
2231: CALL 52031 0 3
2235: ST_TO_ADDR
// if Kuzmov then
2236: LD_EXP 49
2240: IFFALSE 2258
// tmp := tmp ^ Kuzmov ;
2242: LD_ADDR_VAR 0 5
2246: PUSH
2247: LD_VAR 0 5
2251: PUSH
2252: LD_EXP 49
2256: ADD
2257: ST_TO_ADDR
// Karamazov := PrepareUnit ( Karamazov , ( not debug ) , 13a_ ) ;
2258: LD_ADDR_EXP 50
2262: PUSH
2263: LD_STRING Karamazov
2265: PPUSH
2266: LD_EXP 1
2270: NOT
2271: PPUSH
2272: LD_STRING 13a_
2274: PPUSH
2275: CALL 52031 0 3
2279: ST_TO_ADDR
// if Karamazov then
2280: LD_EXP 50
2284: IFFALSE 2302
// tmp := tmp ^ Karamazov ;
2286: LD_ADDR_VAR 0 5
2290: PUSH
2291: LD_VAR 0 5
2295: PUSH
2296: LD_EXP 50
2300: ADD
2301: ST_TO_ADDR
// Belkov := PrepareUnit ( Belkov , ( not debug ) , 13a_ ) ;
2302: LD_ADDR_EXP 52
2306: PUSH
2307: LD_STRING Belkov
2309: PPUSH
2310: LD_EXP 1
2314: NOT
2315: PPUSH
2316: LD_STRING 13a_
2318: PPUSH
2319: CALL 52031 0 3
2323: ST_TO_ADDR
// if Belkov then
2324: LD_EXP 52
2328: IFFALSE 2346
// tmp := tmp ^ Belkov ;
2330: LD_ADDR_VAR 0 5
2334: PUSH
2335: LD_VAR 0 5
2339: PUSH
2340: LD_EXP 52
2344: ADD
2345: ST_TO_ADDR
// Gnyevko := PrepareUnit ( Gnyevko , ( not debug ) , 13a_ ) ;
2346: LD_ADDR_EXP 53
2350: PUSH
2351: LD_STRING Gnyevko
2353: PPUSH
2354: LD_EXP 1
2358: NOT
2359: PPUSH
2360: LD_STRING 13a_
2362: PPUSH
2363: CALL 52031 0 3
2367: ST_TO_ADDR
// if Gnyevko then
2368: LD_EXP 53
2372: IFFALSE 2390
// tmp := tmp ^ Gnyevko ;
2374: LD_ADDR_VAR 0 5
2378: PUSH
2379: LD_VAR 0 5
2383: PUSH
2384: LD_EXP 53
2388: ADD
2389: ST_TO_ADDR
// Connie = NewCharacter ( Coonie ) ;
2390: LD_ADDR_EXP 36
2394: PUSH
2395: LD_STRING Coonie
2397: PPUSH
2398: CALL_OW 25
2402: ST_TO_ADDR
// if not Lisa then
2403: LD_EXP 21
2407: NOT
2408: IFFALSE 2454
// begin Lisa := PrepareUnit ( Lisa , ( not debug ) , 13a_ ) ;
2410: LD_ADDR_EXP 21
2414: PUSH
2415: LD_STRING Lisa
2417: PPUSH
2418: LD_EXP 1
2422: NOT
2423: PPUSH
2424: LD_STRING 13a_
2426: PPUSH
2427: CALL 52031 0 3
2431: ST_TO_ADDR
// if Lisa then
2432: LD_EXP 21
2436: IFFALSE 2454
// tmp := tmp ^ Lisa ;
2438: LD_ADDR_VAR 0 5
2442: PUSH
2443: LD_VAR 0 5
2447: PUSH
2448: LD_EXP 21
2452: ADD
2453: ST_TO_ADDR
// end ; if not Donaldson then
2454: LD_EXP 22
2458: NOT
2459: IFFALSE 2505
// begin Donaldson := PrepareUnit ( Donaldson , ( not debug ) , 13a_ ) ;
2461: LD_ADDR_EXP 22
2465: PUSH
2466: LD_STRING Donaldson
2468: PPUSH
2469: LD_EXP 1
2473: NOT
2474: PPUSH
2475: LD_STRING 13a_
2477: PPUSH
2478: CALL 52031 0 3
2482: ST_TO_ADDR
// if Donaldson then
2483: LD_EXP 22
2487: IFFALSE 2505
// tmp := tmp ^ Donaldson ;
2489: LD_ADDR_VAR 0 5
2493: PUSH
2494: LD_VAR 0 5
2498: PUSH
2499: LD_EXP 22
2503: ADD
2504: ST_TO_ADDR
// end ; if not Bobby then
2505: LD_EXP 23
2509: NOT
2510: IFFALSE 2556
// begin Bobby := PrepareUnit ( Bobby , ( not debug ) , 13a_ ) ;
2512: LD_ADDR_EXP 23
2516: PUSH
2517: LD_STRING Bobby
2519: PPUSH
2520: LD_EXP 1
2524: NOT
2525: PPUSH
2526: LD_STRING 13a_
2528: PPUSH
2529: CALL 52031 0 3
2533: ST_TO_ADDR
// if Bobby then
2534: LD_EXP 23
2538: IFFALSE 2556
// tmp := tmp ^ Bobby ;
2540: LD_ADDR_VAR 0 5
2544: PUSH
2545: LD_VAR 0 5
2549: PUSH
2550: LD_EXP 23
2554: ADD
2555: ST_TO_ADDR
// end ; if not Cyrus then
2556: LD_EXP 24
2560: NOT
2561: IFFALSE 2607
// begin Cyrus := PrepareUnit ( Cyrus , ( not debug ) , 13a_ ) ;
2563: LD_ADDR_EXP 24
2567: PUSH
2568: LD_STRING Cyrus
2570: PPUSH
2571: LD_EXP 1
2575: NOT
2576: PPUSH
2577: LD_STRING 13a_
2579: PPUSH
2580: CALL 52031 0 3
2584: ST_TO_ADDR
// if Cyrus then
2585: LD_EXP 24
2589: IFFALSE 2607
// tmp := tmp ^ Cyrus ;
2591: LD_ADDR_VAR 0 5
2595: PUSH
2596: LD_VAR 0 5
2600: PUSH
2601: LD_EXP 24
2605: ADD
2606: ST_TO_ADDR
// end ; if not Brown then
2607: LD_EXP 26
2611: NOT
2612: IFFALSE 2658
// begin Brown := PrepareUnit ( Brown , ( not debug ) , 13a_ ) ;
2614: LD_ADDR_EXP 26
2618: PUSH
2619: LD_STRING Brown
2621: PPUSH
2622: LD_EXP 1
2626: NOT
2627: PPUSH
2628: LD_STRING 13a_
2630: PPUSH
2631: CALL 52031 0 3
2635: ST_TO_ADDR
// if Brown then
2636: LD_EXP 26
2640: IFFALSE 2658
// tmp := tmp ^ Brown ;
2642: LD_ADDR_VAR 0 5
2646: PUSH
2647: LD_VAR 0 5
2651: PUSH
2652: LD_EXP 26
2656: ADD
2657: ST_TO_ADDR
// end ; if not Gladstone then
2658: LD_EXP 27
2662: NOT
2663: IFFALSE 2709
// begin Gladstone := PrepareUnit ( Gladstone , ( not debug ) , 13a_ ) ;
2665: LD_ADDR_EXP 27
2669: PUSH
2670: LD_STRING Gladstone
2672: PPUSH
2673: LD_EXP 1
2677: NOT
2678: PPUSH
2679: LD_STRING 13a_
2681: PPUSH
2682: CALL 52031 0 3
2686: ST_TO_ADDR
// if Gladstone then
2687: LD_EXP 27
2691: IFFALSE 2709
// tmp := tmp ^ Gladstone ;
2693: LD_ADDR_VAR 0 5
2697: PUSH
2698: LD_VAR 0 5
2702: PUSH
2703: LD_EXP 27
2707: ADD
2708: ST_TO_ADDR
// end ; if not Cornel then
2709: LD_EXP 29
2713: NOT
2714: IFFALSE 2760
// begin Cornel := PrepareUnit ( Cornel , ( not debug ) , 13a_ ) ;
2716: LD_ADDR_EXP 29
2720: PUSH
2721: LD_STRING Cornel
2723: PPUSH
2724: LD_EXP 1
2728: NOT
2729: PPUSH
2730: LD_STRING 13a_
2732: PPUSH
2733: CALL 52031 0 3
2737: ST_TO_ADDR
// if Cornel then
2738: LD_EXP 29
2742: IFFALSE 2760
// tmp := tmp ^ Cornel ;
2744: LD_ADDR_VAR 0 5
2748: PUSH
2749: LD_VAR 0 5
2753: PUSH
2754: LD_EXP 29
2758: ADD
2759: ST_TO_ADDR
// end ; if not Houten then
2760: LD_EXP 28
2764: NOT
2765: IFFALSE 2811
// begin Houten := PrepareUnit ( Houten , ( not debug ) , 13a_ ) ;
2767: LD_ADDR_EXP 28
2771: PUSH
2772: LD_STRING Houten
2774: PPUSH
2775: LD_EXP 1
2779: NOT
2780: PPUSH
2781: LD_STRING 13a_
2783: PPUSH
2784: CALL 52031 0 3
2788: ST_TO_ADDR
// if Houten then
2789: LD_EXP 28
2793: IFFALSE 2811
// tmp := tmp ^ Houten ;
2795: LD_ADDR_VAR 0 5
2799: PUSH
2800: LD_VAR 0 5
2804: PUSH
2805: LD_EXP 28
2809: ADD
2810: ST_TO_ADDR
// end ; if not Gary then
2811: LD_EXP 30
2815: NOT
2816: IFFALSE 2862
// begin Gary := PrepareUnit ( Gary , ( not debug ) , 13a_ ) ;
2818: LD_ADDR_EXP 30
2822: PUSH
2823: LD_STRING Gary
2825: PPUSH
2826: LD_EXP 1
2830: NOT
2831: PPUSH
2832: LD_STRING 13a_
2834: PPUSH
2835: CALL 52031 0 3
2839: ST_TO_ADDR
// if Gary then
2840: LD_EXP 30
2844: IFFALSE 2862
// tmp := tmp ^ Gary ;
2846: LD_ADDR_VAR 0 5
2850: PUSH
2851: LD_VAR 0 5
2855: PUSH
2856: LD_EXP 30
2860: ADD
2861: ST_TO_ADDR
// end ; if not Kikuchi then
2862: LD_EXP 32
2866: NOT
2867: IFFALSE 2913
// begin Kikuchi := PrepareUnit ( Kikuchi , ( not debug ) , 13a_ ) ;
2869: LD_ADDR_EXP 32
2873: PUSH
2874: LD_STRING Kikuchi
2876: PPUSH
2877: LD_EXP 1
2881: NOT
2882: PPUSH
2883: LD_STRING 13a_
2885: PPUSH
2886: CALL 52031 0 3
2890: ST_TO_ADDR
// if Kikuchi then
2891: LD_EXP 32
2895: IFFALSE 2913
// tmp := tmp ^ Kikuchi ;
2897: LD_ADDR_VAR 0 5
2901: PUSH
2902: LD_VAR 0 5
2906: PUSH
2907: LD_EXP 32
2911: ADD
2912: ST_TO_ADDR
// end ; tmp := tmp union CreateCharacterSet ( 13a_others ) ;
2913: LD_ADDR_VAR 0 5
2917: PUSH
2918: LD_VAR 0 5
2922: PUSH
2923: LD_STRING 13a_others
2925: PPUSH
2926: CALL_OW 31
2930: UNION
2931: ST_TO_ADDR
// tmp := tmp diff 0 ;
2932: LD_ADDR_VAR 0 5
2936: PUSH
2937: LD_VAR 0 5
2941: PUSH
2942: LD_INT 0
2944: DIFF
2945: ST_TO_ADDR
// if tmp < 15 then
2946: LD_VAR 0 5
2950: PUSH
2951: LD_INT 15
2953: LESS
2954: IFFALSE 3042
// for i = 15 downto tmp do
2956: LD_ADDR_VAR 0 2
2960: PUSH
2961: DOUBLE
2962: LD_INT 15
2964: INC
2965: ST_TO_ADDR
2966: LD_VAR 0 5
2970: PUSH
2971: FOR_DOWNTO
2972: IFFALSE 3040
// begin uc_nation := [ 1 , 3 ] [ rand ( 1 , 2 ) ] ;
2974: LD_ADDR_OWVAR 21
2978: PUSH
2979: LD_INT 1
2981: PUSH
2982: LD_INT 3
2984: PUSH
2985: EMPTY
2986: LIST
2987: LIST
2988: PUSH
2989: LD_INT 1
2991: PPUSH
2992: LD_INT 2
2994: PPUSH
2995: CALL_OW 12
2999: ARRAY
3000: ST_TO_ADDR
// PrepareHuman ( false , rand ( 1 , 4 ) , 8 ) ;
3001: LD_INT 0
3003: PPUSH
3004: LD_INT 1
3006: PPUSH
3007: LD_INT 4
3009: PPUSH
3010: CALL_OW 12
3014: PPUSH
3015: LD_INT 8
3017: PPUSH
3018: CALL_OW 380
// tmp := tmp ^ CreateHuman ;
3022: LD_ADDR_VAR 0 5
3026: PUSH
3027: LD_VAR 0 5
3031: PUSH
3032: CALL_OW 44
3036: ADD
3037: ST_TO_ADDR
// end ;
3038: GO 2971
3040: POP
3041: POP
// if not debug then
3042: LD_EXP 1
3046: NOT
3047: IFFALSE 3227
// selected = CharacterSelection (  , [ 14 , 14 , 13 , 12 ] [ Difficulty ] , [ 14 , 14 , 13 , 12 ] [ Difficulty ] , [ sel_change_class , JMM , Burlak , Roth , Joan , Denis , Gossudarov , sel_not_hired , sel_changeable , sel_change_class ] ^ tmp , [ class_soldier , class_scientistic , [ class_engineer , 1 ] , class_mechanic , [ class_sniper , 0 , 3 ] , [ class_bazooker , 0 , 3 ] ] ) else
3049: LD_ADDR_VAR 0 4
3053: PUSH
3054: LD_STRING 
3056: PPUSH
3057: LD_INT 14
3059: PUSH
3060: LD_INT 14
3062: PUSH
3063: LD_INT 13
3065: PUSH
3066: LD_INT 12
3068: PUSH
3069: EMPTY
3070: LIST
3071: LIST
3072: LIST
3073: LIST
3074: PUSH
3075: LD_OWVAR 67
3079: ARRAY
3080: PPUSH
3081: LD_INT 14
3083: PUSH
3084: LD_INT 14
3086: PUSH
3087: LD_INT 13
3089: PUSH
3090: LD_INT 12
3092: PUSH
3093: EMPTY
3094: LIST
3095: LIST
3096: LIST
3097: LIST
3098: PUSH
3099: LD_OWVAR 67
3103: ARRAY
3104: PPUSH
3105: LD_INT -5
3107: PUSH
3108: LD_EXP 19
3112: PUSH
3113: LD_EXP 51
3117: PUSH
3118: LD_EXP 20
3122: PUSH
3123: LD_EXP 34
3127: PUSH
3128: LD_EXP 25
3132: PUSH
3133: LD_EXP 37
3137: PUSH
3138: LD_INT -2
3140: PUSH
3141: LD_INT -3
3143: PUSH
3144: LD_INT -5
3146: PUSH
3147: EMPTY
3148: LIST
3149: LIST
3150: LIST
3151: LIST
3152: LIST
3153: LIST
3154: LIST
3155: LIST
3156: LIST
3157: LIST
3158: PUSH
3159: LD_VAR 0 5
3163: ADD
3164: PPUSH
3165: LD_INT 1
3167: PUSH
3168: LD_INT 4
3170: PUSH
3171: LD_INT 2
3173: PUSH
3174: LD_INT 1
3176: PUSH
3177: EMPTY
3178: LIST
3179: LIST
3180: PUSH
3181: LD_INT 3
3183: PUSH
3184: LD_INT 5
3186: PUSH
3187: LD_INT 0
3189: PUSH
3190: LD_INT 3
3192: PUSH
3193: EMPTY
3194: LIST
3195: LIST
3196: LIST
3197: PUSH
3198: LD_INT 9
3200: PUSH
3201: LD_INT 0
3203: PUSH
3204: LD_INT 3
3206: PUSH
3207: EMPTY
3208: LIST
3209: LIST
3210: LIST
3211: PUSH
3212: EMPTY
3213: LIST
3214: LIST
3215: LIST
3216: LIST
3217: LIST
3218: LIST
3219: PPUSH
3220: CALL_OW 42
3224: ST_TO_ADDR
3225: GO 3276
// selected := [ Titov , Fadeev , Dolgov , Petrosyan , Scholtze , Oblukov , Kapitsova ] ;
3227: LD_ADDR_VAR 0 4
3231: PUSH
3232: LD_EXP 39
3236: PUSH
3237: LD_EXP 40
3241: PUSH
3242: LD_EXP 41
3246: PUSH
3247: LD_EXP 42
3251: PUSH
3252: LD_EXP 43
3256: PUSH
3257: LD_EXP 44
3261: PUSH
3262: LD_EXP 45
3266: PUSH
3267: EMPTY
3268: LIST
3269: LIST
3270: LIST
3271: LIST
3272: LIST
3273: LIST
3274: LIST
3275: ST_TO_ADDR
// allianceTeam := tmp diff selected ;
3276: LD_ADDR_EXP 17
3280: PUSH
3281: LD_VAR 0 5
3285: PUSH
3286: LD_VAR 0 4
3290: DIFF
3291: ST_TO_ADDR
// uc_nation := 1 ;
3292: LD_ADDR_OWVAR 21
3296: PUSH
3297: LD_INT 1
3299: ST_TO_ADDR
// PrepareVehicle ( us_morphling , engine_siberite , control_manual , us_heavy_gun , 100 ) ;
3300: LD_INT 5
3302: PPUSH
3303: LD_INT 3
3305: PPUSH
3306: LD_INT 1
3308: PPUSH
3309: LD_INT 6
3311: PPUSH
3312: LD_INT 100
3314: PPUSH
3315: CALL 56895 0 5
// veh := CreateVehicle ;
3319: LD_ADDR_VAR 0 3
3323: PUSH
3324: CALL_OW 45
3328: ST_TO_ADDR
// SetMark ( veh , - 7 ) ;
3329: LD_VAR 0 3
3333: PPUSH
3334: LD_INT 7
3336: NEG
3337: PPUSH
3338: CALL_OW 242
// SetDir ( veh , 3 ) ;
3342: LD_VAR 0 3
3346: PPUSH
3347: LD_INT 3
3349: PPUSH
3350: CALL_OW 233
// PlaceUnitArea ( veh , allianceJMMSpawnArea , false ) ;
3354: LD_VAR 0 3
3358: PPUSH
3359: LD_INT 31
3361: PPUSH
3362: LD_INT 0
3364: PPUSH
3365: CALL_OW 49
// PlaceHumanInUnit ( JMM , veh ) ;
3369: LD_EXP 19
3373: PPUSH
3374: LD_VAR 0 3
3378: PPUSH
3379: CALL_OW 52
// if Joan then
3383: LD_EXP 34
3387: IFFALSE 3459
// begin PrepareVehicle ( us_medium_tracked , engine_siberite , control_manual , us_radar , 100 ) ;
3389: LD_INT 3
3391: PPUSH
3392: LD_INT 3
3394: PPUSH
3395: LD_INT 1
3397: PPUSH
3398: LD_INT 11
3400: PPUSH
3401: LD_INT 100
3403: PPUSH
3404: CALL 56895 0 5
// veh := CreateVehicle ;
3408: LD_ADDR_VAR 0 3
3412: PUSH
3413: CALL_OW 45
3417: ST_TO_ADDR
// SetDir ( veh , 3 ) ;
3418: LD_VAR 0 3
3422: PPUSH
3423: LD_INT 3
3425: PPUSH
3426: CALL_OW 233
// PlaceUnitArea ( veh , allianceSpawnArea , false ) ;
3430: LD_VAR 0 3
3434: PPUSH
3435: LD_INT 30
3437: PPUSH
3438: LD_INT 0
3440: PPUSH
3441: CALL_OW 49
// PlaceHumanInUnit ( Joan , veh ) ;
3445: LD_EXP 34
3449: PPUSH
3450: LD_VAR 0 3
3454: PPUSH
3455: CALL_OW 52
// end ; if Roth then
3459: LD_EXP 20
3463: IFFALSE 3535
// begin PrepareVehicle ( us_medium_tracked , engine_siberite , control_manual , us_radar , 100 ) ;
3465: LD_INT 3
3467: PPUSH
3468: LD_INT 3
3470: PPUSH
3471: LD_INT 1
3473: PPUSH
3474: LD_INT 11
3476: PPUSH
3477: LD_INT 100
3479: PPUSH
3480: CALL 56895 0 5
// veh := CreateVehicle ;
3484: LD_ADDR_VAR 0 3
3488: PUSH
3489: CALL_OW 45
3493: ST_TO_ADDR
// SetDir ( veh , 3 ) ;
3494: LD_VAR 0 3
3498: PPUSH
3499: LD_INT 3
3501: PPUSH
3502: CALL_OW 233
// PlaceUnitArea ( veh , allianceSpawnArea , false ) ;
3506: LD_VAR 0 3
3510: PPUSH
3511: LD_INT 30
3513: PPUSH
3514: LD_INT 0
3516: PPUSH
3517: CALL_OW 49
// PlaceHumanInUnit ( Roth , veh ) ;
3521: LD_EXP 20
3525: PPUSH
3526: LD_VAR 0 3
3530: PPUSH
3531: CALL_OW 52
// end ; if Denis then
3535: LD_EXP 25
3539: IFFALSE 3611
// begin PrepareVehicle ( us_morphling , engine_siberite , control_manual , us_laser , 100 ) ;
3541: LD_INT 5
3543: PPUSH
3544: LD_INT 3
3546: PPUSH
3547: LD_INT 1
3549: PPUSH
3550: LD_INT 9
3552: PPUSH
3553: LD_INT 100
3555: PPUSH
3556: CALL 56895 0 5
// veh := CreateVehicle ;
3560: LD_ADDR_VAR 0 3
3564: PUSH
3565: CALL_OW 45
3569: ST_TO_ADDR
// SetDir ( veh , 3 ) ;
3570: LD_VAR 0 3
3574: PPUSH
3575: LD_INT 3
3577: PPUSH
3578: CALL_OW 233
// PlaceUnitArea ( veh , allianceSpawnArea , false ) ;
3582: LD_VAR 0 3
3586: PPUSH
3587: LD_INT 30
3589: PPUSH
3590: LD_INT 0
3592: PPUSH
3593: CALL_OW 49
// PlaceHumanInUnit ( Denis , veh ) ;
3597: LD_EXP 25
3601: PPUSH
3602: LD_VAR 0 3
3606: PPUSH
3607: CALL_OW 52
// end ; uc_nation := 3 ;
3611: LD_ADDR_OWVAR 21
3615: PUSH
3616: LD_INT 3
3618: ST_TO_ADDR
// PrepareVehicle ( ru_medium_tracked , engine_siberite , control_manual , ru_rocket_launcher , 100 ) ;
3619: LD_INT 22
3621: PPUSH
3622: LD_INT 3
3624: PPUSH
3625: LD_INT 1
3627: PPUSH
3628: LD_INT 45
3630: PPUSH
3631: LD_INT 100
3633: PPUSH
3634: CALL 56895 0 5
// veh := CreateVehicle ;
3638: LD_ADDR_VAR 0 3
3642: PUSH
3643: CALL_OW 45
3647: ST_TO_ADDR
// SetMark ( veh , - 7 ) ;
3648: LD_VAR 0 3
3652: PPUSH
3653: LD_INT 7
3655: NEG
3656: PPUSH
3657: CALL_OW 242
// SetDir ( veh , 3 ) ;
3661: LD_VAR 0 3
3665: PPUSH
3666: LD_INT 3
3668: PPUSH
3669: CALL_OW 233
// PlaceUnitArea ( veh , allianceJMMSpawnArea , false ) ;
3673: LD_VAR 0 3
3677: PPUSH
3678: LD_INT 31
3680: PPUSH
3681: LD_INT 0
3683: PPUSH
3684: CALL_OW 49
// PlaceHumanInUnit ( Burlak , veh ) ;
3688: LD_EXP 51
3692: PPUSH
3693: LD_VAR 0 3
3697: PPUSH
3698: CALL_OW 52
// if Gossudarov then
3702: LD_EXP 37
3706: IFFALSE 3793
// begin PrepareVehicle ( ru_medium_tracked , engine_siberite , control_manual , ru_cargo_bay , 100 ) ;
3708: LD_INT 22
3710: PPUSH
3711: LD_INT 3
3713: PPUSH
3714: LD_INT 1
3716: PPUSH
3717: LD_INT 51
3719: PPUSH
3720: LD_INT 100
3722: PPUSH
3723: CALL 56895 0 5
// veh := CreateVehicle ;
3727: LD_ADDR_VAR 0 3
3731: PUSH
3732: CALL_OW 45
3736: ST_TO_ADDR
// SetDir ( veh , 3 ) ;
3737: LD_VAR 0 3
3741: PPUSH
3742: LD_INT 3
3744: PPUSH
3745: CALL_OW 233
// PlaceUnitArea ( veh , allianceSpawnArea , false ) ;
3749: LD_VAR 0 3
3753: PPUSH
3754: LD_INT 30
3756: PPUSH
3757: LD_INT 0
3759: PPUSH
3760: CALL_OW 49
// PlaceHumanInUnit ( Gossudarov , veh ) ;
3764: LD_EXP 37
3768: PPUSH
3769: LD_VAR 0 3
3773: PPUSH
3774: CALL_OW 52
// SetCargo ( veh , mat_cans , 100 ) ;
3778: LD_VAR 0 3
3782: PPUSH
3783: LD_INT 1
3785: PPUSH
3786: LD_INT 100
3788: PPUSH
3789: CALL_OW 290
// end ; for i in selected do
3793: LD_ADDR_VAR 0 2
3797: PUSH
3798: LD_VAR 0 4
3802: PUSH
3803: FOR_IN
3804: IFFALSE 4362
// begin uc_nation := GetNation ( i ) ;
3806: LD_ADDR_OWVAR 21
3810: PUSH
3811: LD_VAR 0 2
3815: PPUSH
3816: CALL_OW 248
3820: ST_TO_ADDR
// if i in [ Lisa , Donaldson , Cyrus , Bobby ] then
3821: LD_VAR 0 2
3825: PUSH
3826: LD_EXP 21
3830: PUSH
3831: LD_EXP 22
3835: PUSH
3836: LD_EXP 24
3840: PUSH
3841: LD_EXP 23
3845: PUSH
3846: EMPTY
3847: LIST
3848: LIST
3849: LIST
3850: LIST
3851: IN
3852: IFFALSE 3875
// PrepareVehicle ( us_morphling , engine_siberite , control_manual , us_heavy_gun , 100 ) else
3854: LD_INT 5
3856: PPUSH
3857: LD_INT 3
3859: PPUSH
3860: LD_INT 1
3862: PPUSH
3863: LD_INT 6
3865: PPUSH
3866: LD_INT 100
3868: PPUSH
3869: CALL 56895 0 5
3873: GO 4309
// if i in [ Oblukov , Kuzmov , Petrovova , Titov ] then
3875: LD_VAR 0 2
3879: PUSH
3880: LD_EXP 44
3884: PUSH
3885: LD_EXP 49
3889: PUSH
3890: LD_EXP 47
3894: PUSH
3895: LD_EXP 39
3899: PUSH
3900: EMPTY
3901: LIST
3902: LIST
3903: LIST
3904: LIST
3905: IN
3906: IFFALSE 3937
// PrepareVehicle ( ru_heavy_tracked , engine_combustion , control_manual , ru_heavy_gun , rand ( 65 , 75 ) ) else
3908: LD_INT 24
3910: PPUSH
3911: LD_INT 1
3913: PPUSH
3914: LD_INT 1
3916: PPUSH
3917: LD_INT 46
3919: PPUSH
3920: LD_INT 65
3922: PPUSH
3923: LD_INT 75
3925: PPUSH
3926: CALL_OW 12
3930: PPUSH
3931: CALL 56895 0 5
3935: GO 4309
// if i = Karamazov then
3937: LD_VAR 0 2
3941: PUSH
3942: LD_EXP 50
3946: EQUAL
3947: IFFALSE 3970
// PrepareVehicle ( ru_medium_tracked , engine_siberite , control_manual , ru_crane , 100 ) else
3949: LD_INT 22
3951: PPUSH
3952: LD_INT 3
3954: PPUSH
3955: LD_INT 1
3957: PPUSH
3958: LD_INT 52
3960: PPUSH
3961: LD_INT 100
3963: PPUSH
3964: CALL 56895 0 5
3968: GO 4309
// if i = Brown then
3970: LD_VAR 0 2
3974: PUSH
3975: LD_EXP 26
3979: EQUAL
3980: IFFALSE 4003
// PrepareVehicle ( us_medium_tracked , engine_siberite , control_manual , us_crane , 100 ) else
3982: LD_INT 3
3984: PPUSH
3985: LD_INT 3
3987: PPUSH
3988: LD_INT 1
3990: PPUSH
3991: LD_INT 13
3993: PPUSH
3994: LD_INT 100
3996: PPUSH
3997: CALL 56895 0 5
4001: GO 4309
// if uc_nation = nation_american then
4003: LD_OWVAR 21
4007: PUSH
4008: LD_INT 1
4010: EQUAL
4011: IFFALSE 4162
// begin PrepareVehicle ( [ us_medium_tracked , us_morphling , us_morphling ] [ uc_nation mod 3 + 1 ] , [ engine_combustion , engine_siberite , engine_combustion ] [ uc_nation mod 3 + 1 ] , control_manual , [ [ us_radar , us_gatling_gun , us_double_gun ] , [ us_heavy_gun , us_rocket_launcher , us_laser ] , [ us_heavy_gun , us_laser , us_cargo_bay ] ] [ uc_nation mod 3 + 1 ] [ rand ( 1 , 3 ) ] , rand ( 65 , 75 ) ) ;
4013: LD_INT 3
4015: PUSH
4016: LD_INT 5
4018: PUSH
4019: LD_INT 5
4021: PUSH
4022: EMPTY
4023: LIST
4024: LIST
4025: LIST
4026: PUSH
4027: LD_OWVAR 21
4031: PUSH
4032: LD_INT 3
4034: MOD
4035: PUSH
4036: LD_INT 1
4038: PLUS
4039: ARRAY
4040: PPUSH
4041: LD_INT 1
4043: PUSH
4044: LD_INT 3
4046: PUSH
4047: LD_INT 1
4049: PUSH
4050: EMPTY
4051: LIST
4052: LIST
4053: LIST
4054: PUSH
4055: LD_OWVAR 21
4059: PUSH
4060: LD_INT 3
4062: MOD
4063: PUSH
4064: LD_INT 1
4066: PLUS
4067: ARRAY
4068: PPUSH
4069: LD_INT 1
4071: PPUSH
4072: LD_INT 11
4074: PUSH
4075: LD_INT 4
4077: PUSH
4078: LD_INT 5
4080: PUSH
4081: EMPTY
4082: LIST
4083: LIST
4084: LIST
4085: PUSH
4086: LD_INT 6
4088: PUSH
4089: LD_INT 7
4091: PUSH
4092: LD_INT 9
4094: PUSH
4095: EMPTY
4096: LIST
4097: LIST
4098: LIST
4099: PUSH
4100: LD_INT 6
4102: PUSH
4103: LD_INT 9
4105: PUSH
4106: LD_INT 12
4108: PUSH
4109: EMPTY
4110: LIST
4111: LIST
4112: LIST
4113: PUSH
4114: EMPTY
4115: LIST
4116: LIST
4117: LIST
4118: PUSH
4119: LD_OWVAR 21
4123: PUSH
4124: LD_INT 3
4126: MOD
4127: PUSH
4128: LD_INT 1
4130: PLUS
4131: ARRAY
4132: PUSH
4133: LD_INT 1
4135: PPUSH
4136: LD_INT 3
4138: PPUSH
4139: CALL_OW 12
4143: ARRAY
4144: PPUSH
4145: LD_INT 65
4147: PPUSH
4148: LD_INT 75
4150: PPUSH
4151: CALL_OW 12
4155: PPUSH
4156: CALL 56895 0 5
// end else
4160: GO 4309
// begin PrepareVehicle ( [ ru_medium_tracked , ru_heavy_wheeled , ru_heavy_wheeled ] [ uc_nation mod 3 + 1 ] , [ engine_combustion , engine_siberite , engine_combustion ] [ uc_nation mod 3 + 1 ] , control_manual , [ [ ru_rocket_launcher , ru_gatling_gun , ru_gun ] , [ ru_heavy_gun , ru_rocket_launcher , ru_gun ] , [ ru_heavy_gun , ru_gatling_gun , ru_rocket_launcher ] ] [ uc_nation mod 3 + 1 ] [ rand ( 1 , 3 ) ] , rand ( 65 , 75 ) ) ;
4162: LD_INT 22
4164: PUSH
4165: LD_INT 23
4167: PUSH
4168: LD_INT 23
4170: PUSH
4171: EMPTY
4172: LIST
4173: LIST
4174: LIST
4175: PUSH
4176: LD_OWVAR 21
4180: PUSH
4181: LD_INT 3
4183: MOD
4184: PUSH
4185: LD_INT 1
4187: PLUS
4188: ARRAY
4189: PPUSH
4190: LD_INT 1
4192: PUSH
4193: LD_INT 3
4195: PUSH
4196: LD_INT 1
4198: PUSH
4199: EMPTY
4200: LIST
4201: LIST
4202: LIST
4203: PUSH
4204: LD_OWVAR 21
4208: PUSH
4209: LD_INT 3
4211: MOD
4212: PUSH
4213: LD_INT 1
4215: PLUS
4216: ARRAY
4217: PPUSH
4218: LD_INT 1
4220: PPUSH
4221: LD_INT 45
4223: PUSH
4224: LD_INT 43
4226: PUSH
4227: LD_INT 44
4229: PUSH
4230: EMPTY
4231: LIST
4232: LIST
4233: LIST
4234: PUSH
4235: LD_INT 46
4237: PUSH
4238: LD_INT 45
4240: PUSH
4241: LD_INT 44
4243: PUSH
4244: EMPTY
4245: LIST
4246: LIST
4247: LIST
4248: PUSH
4249: LD_INT 46
4251: PUSH
4252: LD_INT 43
4254: PUSH
4255: LD_INT 45
4257: PUSH
4258: EMPTY
4259: LIST
4260: LIST
4261: LIST
4262: PUSH
4263: EMPTY
4264: LIST
4265: LIST
4266: LIST
4267: PUSH
4268: LD_OWVAR 21
4272: PUSH
4273: LD_INT 3
4275: MOD
4276: PUSH
4277: LD_INT 1
4279: PLUS
4280: ARRAY
4281: PUSH
4282: LD_INT 1
4284: PPUSH
4285: LD_INT 3
4287: PPUSH
4288: CALL_OW 12
4292: ARRAY
4293: PPUSH
4294: LD_INT 65
4296: PPUSH
4297: LD_INT 75
4299: PPUSH
4300: CALL_OW 12
4304: PPUSH
4305: CALL 56895 0 5
// end ; veh := CreateVehicle ;
4309: LD_ADDR_VAR 0 3
4313: PUSH
4314: CALL_OW 45
4318: ST_TO_ADDR
// SetDir ( veh , 3 ) ;
4319: LD_VAR 0 3
4323: PPUSH
4324: LD_INT 3
4326: PPUSH
4327: CALL_OW 233
// PlaceUnitArea ( veh , allianceSpawnArea , false ) ;
4331: LD_VAR 0 3
4335: PPUSH
4336: LD_INT 30
4338: PPUSH
4339: LD_INT 0
4341: PPUSH
4342: CALL_OW 49
// PlaceHumanInUnit ( i , veh ) ;
4346: LD_VAR 0 2
4350: PPUSH
4351: LD_VAR 0 3
4355: PPUSH
4356: CALL_OW 52
// end ;
4360: GO 3803
4362: POP
4363: POP
// if artifactArCaptured then
4364: LD_EXP 9
4368: IFFALSE 4454
// begin uc_nation := nation_american ;
4370: LD_ADDR_OWVAR 21
4374: PUSH
4375: LD_INT 1
4377: ST_TO_ADDR
// PrepareVehicle ( us_medium_tracked , engine_siberite , control_computer , us_cargo_bay , 100 ) ;
4378: LD_INT 3
4380: PPUSH
4381: LD_INT 3
4383: PPUSH
4384: LD_INT 3
4386: PPUSH
4387: LD_INT 12
4389: PPUSH
4390: LD_INT 100
4392: PPUSH
4393: CALL 56895 0 5
// veh := CreateVehicle ;
4397: LD_ADDR_VAR 0 3
4401: PUSH
4402: CALL_OW 45
4406: ST_TO_ADDR
// SetDir ( veh , 3 ) ;
4407: LD_VAR 0 3
4411: PPUSH
4412: LD_INT 3
4414: PPUSH
4415: CALL_OW 233
// PlaceUnitXY ( veh , 198 , 22 , false ) ;
4419: LD_VAR 0 3
4423: PPUSH
4424: LD_INT 198
4426: PPUSH
4427: LD_INT 22
4429: PPUSH
4430: LD_INT 0
4432: PPUSH
4433: CALL_OW 48
// SetCargo ( veh , mat_artifact , 50 ) ;
4437: LD_VAR 0 3
4441: PPUSH
4442: LD_INT 4
4444: PPUSH
4445: LD_INT 50
4447: PPUSH
4448: CALL_OW 290
// end else
4452: GO 4473
// begin CreateResourcesXY ( mat_artifact , 5 , 267 , 226 , false ) ;
4454: LD_INT 4
4456: PPUSH
4457: LD_INT 5
4459: PPUSH
4460: LD_INT 267
4462: PPUSH
4463: LD_INT 226
4465: PPUSH
4466: LD_INT 0
4468: PPUSH
4469: CALL_OW 58
// end ; uc_nation := nation_american ;
4473: LD_ADDR_OWVAR 21
4477: PUSH
4478: LD_INT 1
4480: ST_TO_ADDR
// PrepareVehicle ( us_medium_tracked , engine_siberite , control_computer , us_cargo_bay , 100 ) ;
4481: LD_INT 3
4483: PPUSH
4484: LD_INT 3
4486: PPUSH
4487: LD_INT 3
4489: PPUSH
4490: LD_INT 12
4492: PPUSH
4493: LD_INT 100
4495: PPUSH
4496: CALL 56895 0 5
// veh := CreateVehicle ;
4500: LD_ADDR_VAR 0 3
4504: PUSH
4505: CALL_OW 45
4509: ST_TO_ADDR
// SetDir ( veh , 3 ) ;
4510: LD_VAR 0 3
4514: PPUSH
4515: LD_INT 3
4517: PPUSH
4518: CALL_OW 233
// PlaceUnitXY ( veh , 218 , 23 , false ) ;
4522: LD_VAR 0 3
4526: PPUSH
4527: LD_INT 218
4529: PPUSH
4530: LD_INT 23
4532: PPUSH
4533: LD_INT 0
4535: PPUSH
4536: CALL_OW 48
// SetCargo ( veh , mat_artifact , 30 ) ;
4540: LD_VAR 0 3
4544: PPUSH
4545: LD_INT 4
4547: PPUSH
4548: LD_INT 30
4550: PPUSH
4551: CALL_OW 290
// uc_nation := nation_russian ;
4555: LD_ADDR_OWVAR 21
4559: PUSH
4560: LD_INT 3
4562: ST_TO_ADDR
// PrepareVehicle ( ru_medium_tracked , engine_siberite , control_computer , ru_cargo_bay , 100 ) ;
4563: LD_INT 22
4565: PPUSH
4566: LD_INT 3
4568: PPUSH
4569: LD_INT 3
4571: PPUSH
4572: LD_INT 51
4574: PPUSH
4575: LD_INT 100
4577: PPUSH
4578: CALL 56895 0 5
// veh := CreateVehicle ;
4582: LD_ADDR_VAR 0 3
4586: PUSH
4587: CALL_OW 45
4591: ST_TO_ADDR
// SetDir ( veh , 3 ) ;
4592: LD_VAR 0 3
4596: PPUSH
4597: LD_INT 3
4599: PPUSH
4600: CALL_OW 233
// PlaceUnitXY ( veh , 214 , 20 , false ) ;
4604: LD_VAR 0 3
4608: PPUSH
4609: LD_INT 214
4611: PPUSH
4612: LD_INT 20
4614: PPUSH
4615: LD_INT 0
4617: PPUSH
4618: CALL_OW 48
// SetCargo ( veh , mat_artifact , 40 ) ;
4622: LD_VAR 0 3
4626: PPUSH
4627: LD_INT 4
4629: PPUSH
4630: LD_INT 40
4632: PPUSH
4633: CALL_OW 290
// end ;
4637: LD_VAR 0 1
4641: RET
// export function AllianceSupport ; var i , veh ; begin
4642: LD_INT 0
4644: PPUSH
4645: PPUSH
4646: PPUSH
// if not allianceTeam then
4647: LD_EXP 17
4651: NOT
4652: IFFALSE 4656
// exit ;
4654: GO 5062
// for i := 1 to 6 do
4656: LD_ADDR_VAR 0 2
4660: PUSH
4661: DOUBLE
4662: LD_INT 1
4664: DEC
4665: ST_TO_ADDR
4666: LD_INT 6
4668: PUSH
4669: FOR_TO
4670: IFFALSE 4966
// begin uc_side := 7 ;
4672: LD_ADDR_OWVAR 20
4676: PUSH
4677: LD_INT 7
4679: ST_TO_ADDR
// uc_nation := [ 1 , 3 ] [ i mod 2 + 1 ] ;
4680: LD_ADDR_OWVAR 21
4684: PUSH
4685: LD_INT 1
4687: PUSH
4688: LD_INT 3
4690: PUSH
4691: EMPTY
4692: LIST
4693: LIST
4694: PUSH
4695: LD_VAR 0 2
4699: PUSH
4700: LD_INT 2
4702: MOD
4703: PUSH
4704: LD_INT 1
4706: PLUS
4707: ARRAY
4708: ST_TO_ADDR
// if uc_nation = 1 then
4709: LD_OWVAR 21
4713: PUSH
4714: LD_INT 1
4716: EQUAL
4717: IFFALSE 4759
// PrepareVehicle ( us_morphling , engine_siberite , control_manual , [ us_heavy_gun , us_rocket_launcher ] [ rand ( 1 , 2 ) ] , 100 ) else
4719: LD_INT 5
4721: PPUSH
4722: LD_INT 3
4724: PPUSH
4725: LD_INT 1
4727: PPUSH
4728: LD_INT 6
4730: PUSH
4731: LD_INT 7
4733: PUSH
4734: EMPTY
4735: LIST
4736: LIST
4737: PUSH
4738: LD_INT 1
4740: PPUSH
4741: LD_INT 2
4743: PPUSH
4744: CALL_OW 12
4748: ARRAY
4749: PPUSH
4750: LD_INT 100
4752: PPUSH
4753: CALL 56895 0 5
4757: GO 4797
// PrepareVehicle ( ru_heavy_wheeled , engine_siberite , control_manual , [ ru_heavy_gun , ru_rocket ] [ rand ( 1 , 2 ) ] , 100 ) ;
4759: LD_INT 23
4761: PPUSH
4762: LD_INT 3
4764: PPUSH
4765: LD_INT 1
4767: PPUSH
4768: LD_INT 46
4770: PUSH
4771: LD_INT 47
4773: PUSH
4774: EMPTY
4775: LIST
4776: LIST
4777: PUSH
4778: LD_INT 1
4780: PPUSH
4781: LD_INT 2
4783: PPUSH
4784: CALL_OW 12
4788: ARRAY
4789: PPUSH
4790: LD_INT 100
4792: PPUSH
4793: CALL 56895 0 5
// if not allianceTeam then
4797: LD_EXP 17
4801: NOT
4802: IFFALSE 4806
// break ;
4804: GO 4966
// veh := CreateVehicle ;
4806: LD_ADDR_VAR 0 3
4810: PUSH
4811: CALL_OW 45
4815: ST_TO_ADDR
// SetDir ( veh , 4 ) ;
4816: LD_VAR 0 3
4820: PPUSH
4821: LD_INT 4
4823: PPUSH
4824: CALL_OW 233
// PlaceUnitArea ( veh , allianceSouthSupp , false ) ;
4828: LD_VAR 0 3
4832: PPUSH
4833: LD_INT 38
4835: PPUSH
4836: LD_INT 0
4838: PPUSH
4839: CALL_OW 49
// if GetSkill ( allianceTeam [ 1 ] , class_mechanic ) > 4 then
4843: LD_EXP 17
4847: PUSH
4848: LD_INT 1
4850: ARRAY
4851: PPUSH
4852: LD_INT 3
4854: PPUSH
4855: CALL_OW 259
4859: PUSH
4860: LD_INT 4
4862: GREATER
4863: IFFALSE 4881
// SetClass ( allianceTeam [ 1 ] , class_mechanic ) ;
4865: LD_EXP 17
4869: PUSH
4870: LD_INT 1
4872: ARRAY
4873: PPUSH
4874: LD_INT 3
4876: PPUSH
4877: CALL_OW 336
// if GetSkill ( allianceTeam [ 1 ] , class_scientistic ) > 8 then
4881: LD_EXP 17
4885: PUSH
4886: LD_INT 1
4888: ARRAY
4889: PPUSH
4890: LD_INT 4
4892: PPUSH
4893: CALL_OW 259
4897: PUSH
4898: LD_INT 8
4900: GREATER
4901: IFFALSE 4919
// SetClass ( allianceTeam [ 1 ] , class_scientistic ) ;
4903: LD_EXP 17
4907: PUSH
4908: LD_INT 1
4910: ARRAY
4911: PPUSH
4912: LD_INT 4
4914: PPUSH
4915: CALL_OW 336
// PlaceHumanInUnit ( allianceTeam [ 1 ] , veh ) ;
4919: LD_EXP 17
4923: PUSH
4924: LD_INT 1
4926: ARRAY
4927: PPUSH
4928: LD_VAR 0 3
4932: PPUSH
4933: CALL_OW 52
// allianceTeam := Delete ( allianceTeam , 1 ) ;
4937: LD_ADDR_EXP 17
4941: PUSH
4942: LD_EXP 17
4946: PPUSH
4947: LD_INT 1
4949: PPUSH
4950: CALL_OW 3
4954: ST_TO_ADDR
// ComHold ( veh ) ;
4955: LD_VAR 0 3
4959: PPUSH
4960: CALL_OW 140
// end ;
4964: GO 4669
4966: POP
4967: POP
// uc_side := 7 ;
4968: LD_ADDR_OWVAR 20
4972: PUSH
4973: LD_INT 7
4975: ST_TO_ADDR
// uc_nation := 1 ;
4976: LD_ADDR_OWVAR 21
4980: PUSH
4981: LD_INT 1
4983: ST_TO_ADDR
// PrepareVehicle ( us_morphling , engine_siberite , control_computer , us_radar , 100 ) ;
4984: LD_INT 5
4986: PPUSH
4987: LD_INT 3
4989: PPUSH
4990: LD_INT 3
4992: PPUSH
4993: LD_INT 11
4995: PPUSH
4996: LD_INT 100
4998: PPUSH
4999: CALL 56895 0 5
// veh := CreateVehicle ;
5003: LD_ADDR_VAR 0 3
5007: PUSH
5008: CALL_OW 45
5012: ST_TO_ADDR
// SetDir ( veh , 4 ) ;
5013: LD_VAR 0 3
5017: PPUSH
5018: LD_INT 4
5020: PPUSH
5021: CALL_OW 233
// PlaceUnitXY ( veh , 305 , 218 , false ) ;
5025: LD_VAR 0 3
5029: PPUSH
5030: LD_INT 305
5032: PPUSH
5033: LD_INT 218
5035: PPUSH
5036: LD_INT 0
5038: PPUSH
5039: CALL_OW 48
// ComHold ( veh ) ;
5043: LD_VAR 0 3
5047: PPUSH
5048: CALL_OW 140
// CenterNowOnXY ( 313 , 220 ) ;
5052: LD_INT 313
5054: PPUSH
5055: LD_INT 220
5057: PPUSH
5058: CALL_OW 86
// end ; end_of_file
5062: LD_VAR 0 1
5066: RET
// export Powell ; export function PrepareAmerican ; var i , b , veh , cl , tmp , depot , lab , armoury , workshop ; begin
5067: LD_INT 0
5069: PPUSH
5070: PPUSH
5071: PPUSH
5072: PPUSH
5073: PPUSH
5074: PPUSH
5075: PPUSH
5076: PPUSH
5077: PPUSH
5078: PPUSH
// InitHc ;
5079: CALL_OW 19
// uc_side := 1 ;
5083: LD_ADDR_OWVAR 20
5087: PUSH
5088: LD_INT 1
5090: ST_TO_ADDR
// uc_nation := 1 ;
5091: LD_ADDR_OWVAR 21
5095: PUSH
5096: LD_INT 1
5098: ST_TO_ADDR
// for i in FilterAllUnits ( [ [ f_side , 1 ] , [ f_type , unit_building ] ] ) do
5099: LD_ADDR_VAR 0 2
5103: PUSH
5104: LD_INT 22
5106: PUSH
5107: LD_INT 1
5109: PUSH
5110: EMPTY
5111: LIST
5112: LIST
5113: PUSH
5114: LD_INT 21
5116: PUSH
5117: LD_INT 3
5119: PUSH
5120: EMPTY
5121: LIST
5122: LIST
5123: PUSH
5124: EMPTY
5125: LIST
5126: LIST
5127: PPUSH
5128: CALL_OW 69
5132: PUSH
5133: FOR_IN
5134: IFFALSE 5150
// SetBLevel ( i , 10 ) ;
5136: LD_VAR 0 2
5140: PPUSH
5141: LD_INT 10
5143: PPUSH
5144: CALL_OW 241
5148: GO 5133
5150: POP
5151: POP
// SetResourceType ( GetBase ( am_depot ) , mat_cans , 7500 ) ;
5152: LD_INT 387
5154: PPUSH
5155: CALL_OW 274
5159: PPUSH
5160: LD_INT 1
5162: PPUSH
5163: LD_INT 7500
5165: PPUSH
5166: CALL_OW 277
// SetResourceType ( GetBase ( am_depot ) , mat_oil , 4000 ) ;
5170: LD_INT 387
5172: PPUSH
5173: CALL_OW 274
5177: PPUSH
5178: LD_INT 2
5180: PPUSH
5181: LD_INT 4000
5183: PPUSH
5184: CALL_OW 277
// SetResourceType ( GetBase ( am_depot ) , mat_siberit , 50 ) ;
5188: LD_INT 387
5190: PPUSH
5191: CALL_OW 274
5195: PPUSH
5196: LD_INT 3
5198: PPUSH
5199: LD_INT 50
5201: PPUSH
5202: CALL_OW 277
// SetResourceType ( GetBase ( am_depot2 ) , mat_cans , 5500 ) ;
5206: LD_INT 476
5208: PPUSH
5209: CALL_OW 274
5213: PPUSH
5214: LD_INT 1
5216: PPUSH
5217: LD_INT 5500
5219: PPUSH
5220: CALL_OW 277
// SetResourceType ( GetBase ( am_depot2 ) , mat_oil , 4000 ) ;
5224: LD_INT 476
5226: PPUSH
5227: CALL_OW 274
5231: PPUSH
5232: LD_INT 2
5234: PPUSH
5235: LD_INT 4000
5237: PPUSH
5238: CALL_OW 277
// SetResourceType ( GetBase ( am_depot2 ) , mat_siberit , 10 ) ;
5242: LD_INT 476
5244: PPUSH
5245: CALL_OW 274
5249: PPUSH
5250: LD_INT 3
5252: PPUSH
5253: LD_INT 10
5255: PPUSH
5256: CALL_OW 277
// Powell := NewCharacter ( Powell ) ;
5260: LD_ADDR_EXP 54
5264: PUSH
5265: LD_STRING Powell
5267: PPUSH
5268: CALL_OW 25
5272: ST_TO_ADDR
// PlaceHumanInUnit ( Powell , am_depot ) ;
5273: LD_EXP 54
5277: PPUSH
5278: LD_INT 387
5280: PPUSH
5281: CALL_OW 52
// tmp := [ ] ;
5285: LD_ADDR_VAR 0 6
5289: PUSH
5290: EMPTY
5291: ST_TO_ADDR
// Lisa := PrepareUnit ( Lisa , ( not debug ) , 12p_ ) ;
5292: LD_ADDR_EXP 21
5296: PUSH
5297: LD_STRING Lisa
5299: PPUSH
5300: LD_EXP 1
5304: NOT
5305: PPUSH
5306: LD_STRING 12p_
5308: PPUSH
5309: CALL 52031 0 3
5313: ST_TO_ADDR
// if Lisa then
5314: LD_EXP 21
5318: IFFALSE 5336
// tmp := tmp ^ Lisa ;
5320: LD_ADDR_VAR 0 6
5324: PUSH
5325: LD_VAR 0 6
5329: PUSH
5330: LD_EXP 21
5334: ADD
5335: ST_TO_ADDR
// Donaldson := PrepareUnit ( Donaldson , ( not debug ) , 12p_ ) ;
5336: LD_ADDR_EXP 22
5340: PUSH
5341: LD_STRING Donaldson
5343: PPUSH
5344: LD_EXP 1
5348: NOT
5349: PPUSH
5350: LD_STRING 12p_
5352: PPUSH
5353: CALL 52031 0 3
5357: ST_TO_ADDR
// if Donaldson then
5358: LD_EXP 22
5362: IFFALSE 5380
// tmp := tmp ^ Donaldson ;
5364: LD_ADDR_VAR 0 6
5368: PUSH
5369: LD_VAR 0 6
5373: PUSH
5374: LD_EXP 22
5378: ADD
5379: ST_TO_ADDR
// Bobby := PrepareUnit ( Bobby , ( not debug ) , 12p_ ) ;
5380: LD_ADDR_EXP 23
5384: PUSH
5385: LD_STRING Bobby
5387: PPUSH
5388: LD_EXP 1
5392: NOT
5393: PPUSH
5394: LD_STRING 12p_
5396: PPUSH
5397: CALL 52031 0 3
5401: ST_TO_ADDR
// if Bobby then
5402: LD_EXP 23
5406: IFFALSE 5424
// tmp := tmp ^ Bobby ;
5408: LD_ADDR_VAR 0 6
5412: PUSH
5413: LD_VAR 0 6
5417: PUSH
5418: LD_EXP 23
5422: ADD
5423: ST_TO_ADDR
// Cyrus := PrepareUnit ( Cyrus , ( not debug ) , 12p_ ) ;
5424: LD_ADDR_EXP 24
5428: PUSH
5429: LD_STRING Cyrus
5431: PPUSH
5432: LD_EXP 1
5436: NOT
5437: PPUSH
5438: LD_STRING 12p_
5440: PPUSH
5441: CALL 52031 0 3
5445: ST_TO_ADDR
// if Cyrus then
5446: LD_EXP 24
5450: IFFALSE 5468
// tmp := tmp ^ Cyrus ;
5452: LD_ADDR_VAR 0 6
5456: PUSH
5457: LD_VAR 0 6
5461: PUSH
5462: LD_EXP 24
5466: ADD
5467: ST_TO_ADDR
// Brown := PrepareUnit ( Brown , ( not debug ) , 12p_ ) ;
5468: LD_ADDR_EXP 26
5472: PUSH
5473: LD_STRING Brown
5475: PPUSH
5476: LD_EXP 1
5480: NOT
5481: PPUSH
5482: LD_STRING 12p_
5484: PPUSH
5485: CALL 52031 0 3
5489: ST_TO_ADDR
// if Brown then
5490: LD_EXP 26
5494: IFFALSE 5512
// tmp := tmp ^ Brown ;
5496: LD_ADDR_VAR 0 6
5500: PUSH
5501: LD_VAR 0 6
5505: PUSH
5506: LD_EXP 26
5510: ADD
5511: ST_TO_ADDR
// Gladstone := PrepareUnit ( Gladstone , ( not debug ) , 12p_ ) ;
5512: LD_ADDR_EXP 27
5516: PUSH
5517: LD_STRING Gladstone
5519: PPUSH
5520: LD_EXP 1
5524: NOT
5525: PPUSH
5526: LD_STRING 12p_
5528: PPUSH
5529: CALL 52031 0 3
5533: ST_TO_ADDR
// if Gladstone then
5534: LD_EXP 27
5538: IFFALSE 5556
// tmp := tmp ^ Gladstone ;
5540: LD_ADDR_VAR 0 6
5544: PUSH
5545: LD_VAR 0 6
5549: PUSH
5550: LD_EXP 27
5554: ADD
5555: ST_TO_ADDR
// Houten := PrepareUnit ( Houten , ( not debug ) , 12p_ ) ;
5556: LD_ADDR_EXP 28
5560: PUSH
5561: LD_STRING Houten
5563: PPUSH
5564: LD_EXP 1
5568: NOT
5569: PPUSH
5570: LD_STRING 12p_
5572: PPUSH
5573: CALL 52031 0 3
5577: ST_TO_ADDR
// if Houten then
5578: LD_EXP 28
5582: IFFALSE 5600
// tmp := tmp ^ Houten ;
5584: LD_ADDR_VAR 0 6
5588: PUSH
5589: LD_VAR 0 6
5593: PUSH
5594: LD_EXP 28
5598: ADD
5599: ST_TO_ADDR
// Cornel := PrepareUnit ( Cornel , ( not debug ) , 12p_ ) ;
5600: LD_ADDR_EXP 29
5604: PUSH
5605: LD_STRING Cornel
5607: PPUSH
5608: LD_EXP 1
5612: NOT
5613: PPUSH
5614: LD_STRING 12p_
5616: PPUSH
5617: CALL 52031 0 3
5621: ST_TO_ADDR
// if Cornel then
5622: LD_EXP 29
5626: IFFALSE 5644
// tmp := tmp ^ Cornel ;
5628: LD_ADDR_VAR 0 6
5632: PUSH
5633: LD_VAR 0 6
5637: PUSH
5638: LD_EXP 29
5642: ADD
5643: ST_TO_ADDR
// Gary := PrepareUnit ( Gary , ( not debug ) , 12p_ ) ;
5644: LD_ADDR_EXP 30
5648: PUSH
5649: LD_STRING Gary
5651: PPUSH
5652: LD_EXP 1
5656: NOT
5657: PPUSH
5658: LD_STRING 12p_
5660: PPUSH
5661: CALL 52031 0 3
5665: ST_TO_ADDR
// if Gary then
5666: LD_EXP 30
5670: IFFALSE 5688
// tmp := tmp ^ Gary ;
5672: LD_ADDR_VAR 0 6
5676: PUSH
5677: LD_VAR 0 6
5681: PUSH
5682: LD_EXP 30
5686: ADD
5687: ST_TO_ADDR
// Kikuchi := PrepareUnit ( Kikuchi , ( not debug ) , 12p_ ) ;
5688: LD_ADDR_EXP 32
5692: PUSH
5693: LD_STRING Kikuchi
5695: PPUSH
5696: LD_EXP 1
5700: NOT
5701: PPUSH
5702: LD_STRING 12p_
5704: PPUSH
5705: CALL 52031 0 3
5709: ST_TO_ADDR
// if Kikuchi then
5710: LD_EXP 32
5714: IFFALSE 5732
// tmp := tmp ^ Kikuchi ;
5716: LD_ADDR_VAR 0 6
5720: PUSH
5721: LD_VAR 0 6
5725: PUSH
5726: LD_EXP 32
5730: ADD
5731: ST_TO_ADDR
// tmp := tmp union CreateCharacterSet ( 12p_others ) ;
5732: LD_ADDR_VAR 0 6
5736: PUSH
5737: LD_VAR 0 6
5741: PUSH
5742: LD_STRING 12p_others
5744: PPUSH
5745: CALL_OW 31
5749: UNION
5750: ST_TO_ADDR
// if tmp < 36 then
5751: LD_VAR 0 6
5755: PUSH
5756: LD_INT 36
5758: LESS
5759: IFFALSE 5826
// for i = 1 to 36 - tmp do
5761: LD_ADDR_VAR 0 2
5765: PUSH
5766: DOUBLE
5767: LD_INT 1
5769: DEC
5770: ST_TO_ADDR
5771: LD_INT 36
5773: PUSH
5774: LD_VAR 0 6
5778: MINUS
5779: PUSH
5780: FOR_TO
5781: IFFALSE 5824
// begin PrepareHuman ( sex_male , i mod 4 + 1 , 10 ) ;
5783: LD_INT 1
5785: PPUSH
5786: LD_VAR 0 2
5790: PUSH
5791: LD_INT 4
5793: MOD
5794: PUSH
5795: LD_INT 1
5797: PLUS
5798: PPUSH
5799: LD_INT 10
5801: PPUSH
5802: CALL_OW 380
// tmp := tmp ^ CreateHuman ;
5806: LD_ADDR_VAR 0 6
5810: PUSH
5811: LD_VAR 0 6
5815: PUSH
5816: CALL_OW 44
5820: ADD
5821: ST_TO_ADDR
// end ;
5822: GO 5780
5824: POP
5825: POP
// for i in tmp do
5826: LD_ADDR_VAR 0 2
5830: PUSH
5831: LD_VAR 0 6
5835: PUSH
5836: FOR_IN
5837: IFFALSE 5862
// PlaceUnitXYR ( i , 62 , 93 , 9 , false ) ;
5839: LD_VAR 0 2
5843: PPUSH
5844: LD_INT 62
5846: PPUSH
5847: LD_INT 93
5849: PPUSH
5850: LD_INT 9
5852: PPUSH
5853: LD_INT 0
5855: PPUSH
5856: CALL_OW 50
5860: GO 5836
5862: POP
5863: POP
// mc_bases := Replace ( mc_bases , 4 , FilterAllUnits ( [ f_side , 1 ] ) diff Powell ) ;
5864: LD_ADDR_EXP 95
5868: PUSH
5869: LD_EXP 95
5873: PPUSH
5874: LD_INT 4
5876: PPUSH
5877: LD_INT 22
5879: PUSH
5880: LD_INT 1
5882: PUSH
5883: EMPTY
5884: LIST
5885: LIST
5886: PPUSH
5887: CALL_OW 69
5891: PUSH
5892: LD_EXP 54
5896: DIFF
5897: PPUSH
5898: CALL_OW 1
5902: ST_TO_ADDR
// uc_side := 0 ;
5903: LD_ADDR_OWVAR 20
5907: PUSH
5908: LD_INT 0
5910: ST_TO_ADDR
// uc_nation := 0 ;
5911: LD_ADDR_OWVAR 21
5915: PUSH
5916: LD_INT 0
5918: ST_TO_ADDR
// for i = 1 to 4 do
5919: LD_ADDR_VAR 0 2
5923: PUSH
5924: DOUBLE
5925: LD_INT 1
5927: DEC
5928: ST_TO_ADDR
5929: LD_INT 4
5931: PUSH
5932: FOR_TO
5933: IFFALSE 5964
// begin InitHc ;
5935: CALL_OW 19
// hc_class := class_apeman ;
5939: LD_ADDR_OWVAR 28
5943: PUSH
5944: LD_INT 12
5946: ST_TO_ADDR
// PlaceUnitArea ( CreateHuman , powellApe , false ) ;
5947: CALL_OW 44
5951: PPUSH
5952: LD_INT 11
5954: PPUSH
5955: LD_INT 0
5957: PPUSH
5958: CALL_OW 49
// end ;
5962: GO 5932
5964: POP
5965: POP
// end ;
5966: LD_VAR 0 1
5970: RET
// every 11 11$30 trigger not americanDestroyed and not MC_GetVehicles ( 4 , true ) do var i , tmp , target ;
5971: LD_EXP 4
5975: NOT
5976: PUSH
5977: LD_INT 4
5979: PPUSH
5980: LD_INT 1
5982: PPUSH
5983: CALL 47043 0 2
5987: NOT
5988: AND
5989: IFFALSE 6761
5991: GO 5993
5993: DISABLE
5994: LD_INT 0
5996: PPUSH
5997: PPUSH
5998: PPUSH
// begin enable ;
5999: ENABLE
// if not FilterAllUnits ( [ [ f_side , 1 ] , [ f_nation , 1 ] , [ f_btype , b_factory ] ] ) then
6000: LD_INT 22
6002: PUSH
6003: LD_INT 1
6005: PUSH
6006: EMPTY
6007: LIST
6008: LIST
6009: PUSH
6010: LD_INT 23
6012: PUSH
6013: LD_INT 1
6015: PUSH
6016: EMPTY
6017: LIST
6018: LIST
6019: PUSH
6020: LD_INT 30
6022: PUSH
6023: LD_INT 3
6025: PUSH
6026: EMPTY
6027: LIST
6028: LIST
6029: PUSH
6030: EMPTY
6031: LIST
6032: LIST
6033: LIST
6034: PPUSH
6035: CALL_OW 69
6039: NOT
6040: IFFALSE 6044
// exit ;
6042: GO 6761
// if Prob ( 40 ) then
6044: LD_INT 40
6046: PPUSH
6047: CALL_OW 13
6051: IFFALSE 6178
// begin MC_InsertProduceList ( 4 , [ [ us_morphling , engine_combustion , control_remote , us_rocket_launcher ] , [ us_morphling , engine_combustion , control_remote , us_rocket_launcher ] , [ us_morphling , engine_combustion , control_remote , us_rocket_launcher ] , [ us_morphling , engine_combustion , control_remote , us_heavy_gun ] , [ us_morphling , engine_combustion , control_remote , us_heavy_gun ] , [ us_morphling , engine_combustion , control_remote , us_heavy_gun ] , ] ) ;
6053: LD_INT 4
6055: PPUSH
6056: LD_INT 5
6058: PUSH
6059: LD_INT 1
6061: PUSH
6062: LD_INT 2
6064: PUSH
6065: LD_INT 7
6067: PUSH
6068: EMPTY
6069: LIST
6070: LIST
6071: LIST
6072: LIST
6073: PUSH
6074: LD_INT 5
6076: PUSH
6077: LD_INT 1
6079: PUSH
6080: LD_INT 2
6082: PUSH
6083: LD_INT 7
6085: PUSH
6086: EMPTY
6087: LIST
6088: LIST
6089: LIST
6090: LIST
6091: PUSH
6092: LD_INT 5
6094: PUSH
6095: LD_INT 1
6097: PUSH
6098: LD_INT 2
6100: PUSH
6101: LD_INT 7
6103: PUSH
6104: EMPTY
6105: LIST
6106: LIST
6107: LIST
6108: LIST
6109: PUSH
6110: LD_INT 5
6112: PUSH
6113: LD_INT 1
6115: PUSH
6116: LD_INT 2
6118: PUSH
6119: LD_INT 6
6121: PUSH
6122: EMPTY
6123: LIST
6124: LIST
6125: LIST
6126: LIST
6127: PUSH
6128: LD_INT 5
6130: PUSH
6131: LD_INT 1
6133: PUSH
6134: LD_INT 2
6136: PUSH
6137: LD_INT 6
6139: PUSH
6140: EMPTY
6141: LIST
6142: LIST
6143: LIST
6144: LIST
6145: PUSH
6146: LD_INT 5
6148: PUSH
6149: LD_INT 1
6151: PUSH
6152: LD_INT 2
6154: PUSH
6155: LD_INT 6
6157: PUSH
6158: EMPTY
6159: LIST
6160: LIST
6161: LIST
6162: LIST
6163: PUSH
6164: EMPTY
6165: LIST
6166: LIST
6167: LIST
6168: LIST
6169: LIST
6170: LIST
6171: PPUSH
6172: CALL 45625 0 2
// end else
6176: GO 6301
// begin MC_InsertProduceList ( 4 , [ [ us_morphling , engine_combustion , control_remote , us_rocket_launcher ] , [ us_morphling , engine_combustion , control_remote , us_laser ] , [ us_morphling , engine_combustion , control_remote , us_laser ] , [ us_morphling , engine_combustion , control_remote , us_heavy_gun ] , [ us_morphling , engine_combustion , control_remote , us_heavy_gun ] , [ us_morphling , engine_combustion , control_remote , us_heavy_gun ] , ] ) ;
6178: LD_INT 4
6180: PPUSH
6181: LD_INT 5
6183: PUSH
6184: LD_INT 1
6186: PUSH
6187: LD_INT 2
6189: PUSH
6190: LD_INT 7
6192: PUSH
6193: EMPTY
6194: LIST
6195: LIST
6196: LIST
6197: LIST
6198: PUSH
6199: LD_INT 5
6201: PUSH
6202: LD_INT 1
6204: PUSH
6205: LD_INT 2
6207: PUSH
6208: LD_INT 9
6210: PUSH
6211: EMPTY
6212: LIST
6213: LIST
6214: LIST
6215: LIST
6216: PUSH
6217: LD_INT 5
6219: PUSH
6220: LD_INT 1
6222: PUSH
6223: LD_INT 2
6225: PUSH
6226: LD_INT 9
6228: PUSH
6229: EMPTY
6230: LIST
6231: LIST
6232: LIST
6233: LIST
6234: PUSH
6235: LD_INT 5
6237: PUSH
6238: LD_INT 1
6240: PUSH
6241: LD_INT 2
6243: PUSH
6244: LD_INT 6
6246: PUSH
6247: EMPTY
6248: LIST
6249: LIST
6250: LIST
6251: LIST
6252: PUSH
6253: LD_INT 5
6255: PUSH
6256: LD_INT 1
6258: PUSH
6259: LD_INT 2
6261: PUSH
6262: LD_INT 6
6264: PUSH
6265: EMPTY
6266: LIST
6267: LIST
6268: LIST
6269: LIST
6270: PUSH
6271: LD_INT 5
6273: PUSH
6274: LD_INT 1
6276: PUSH
6277: LD_INT 2
6279: PUSH
6280: LD_INT 6
6282: PUSH
6283: EMPTY
6284: LIST
6285: LIST
6286: LIST
6287: LIST
6288: PUSH
6289: EMPTY
6290: LIST
6291: LIST
6292: LIST
6293: LIST
6294: LIST
6295: LIST
6296: PPUSH
6297: CALL 45625 0 2
// end ; repeat wait ( 0 0$1 ) ;
6301: LD_INT 35
6303: PPUSH
6304: CALL_OW 67
// until MC_GetVehicles ( 4 , true ) >= 6 ;
6308: LD_INT 4
6310: PPUSH
6311: LD_INT 1
6313: PPUSH
6314: CALL 47043 0 2
6318: PUSH
6319: LD_INT 6
6321: GREATEREQUAL
6322: IFFALSE 6301
// wait ( 0 0$30 ) ;
6324: LD_INT 1050
6326: PPUSH
6327: CALL_OW 67
// tmp := MC_GetVehicles ( 4 , true ) ;
6331: LD_ADDR_VAR 0 2
6335: PUSH
6336: LD_INT 4
6338: PPUSH
6339: LD_INT 1
6341: PPUSH
6342: CALL 47043 0 2
6346: ST_TO_ADDR
// mc_vehicles := Replace ( mc_vehicles , 4 , mc_vehicles [ 4 ] diff tmp ) ;
6347: LD_ADDR_EXP 114
6351: PUSH
6352: LD_EXP 114
6356: PPUSH
6357: LD_INT 4
6359: PPUSH
6360: LD_EXP 114
6364: PUSH
6365: LD_INT 4
6367: ARRAY
6368: PUSH
6369: LD_VAR 0 2
6373: DIFF
6374: PPUSH
6375: CALL_OW 1
6379: ST_TO_ADDR
// target := rand ( 0 , 2 ) ;
6380: LD_ADDR_VAR 0 3
6384: PUSH
6385: LD_INT 0
6387: PPUSH
6388: LD_INT 2
6390: PPUSH
6391: CALL_OW 12
6395: ST_TO_ADDR
// if target then
6396: LD_VAR 0 3
6400: IFFALSE 6528
// begin repeat tmp := UnitFilter ( tmp , [ f_lives , 250 ] ) ;
6402: LD_ADDR_VAR 0 2
6406: PUSH
6407: LD_VAR 0 2
6411: PPUSH
6412: LD_INT 24
6414: PUSH
6415: LD_INT 250
6417: PUSH
6418: EMPTY
6419: LIST
6420: LIST
6421: PPUSH
6422: CALL_OW 72
6426: ST_TO_ADDR
// for i in tmp do
6427: LD_ADDR_VAR 0 1
6431: PUSH
6432: LD_VAR 0 2
6436: PUSH
6437: FOR_IN
6438: IFFALSE 6478
// if GetDistUnitXY ( i , 114 , 108 ) > 9 then
6440: LD_VAR 0 1
6444: PPUSH
6445: LD_INT 114
6447: PPUSH
6448: LD_INT 108
6450: PPUSH
6451: CALL_OW 297
6455: PUSH
6456: LD_INT 9
6458: GREATER
6459: IFFALSE 6476
// ComMoveXY ( i , 114 , 108 ) ;
6461: LD_VAR 0 1
6465: PPUSH
6466: LD_INT 114
6468: PPUSH
6469: LD_INT 108
6471: PPUSH
6472: CALL_OW 111
6476: GO 6437
6478: POP
6479: POP
// wait ( 0 0$1 ) ;
6480: LD_INT 35
6482: PPUSH
6483: CALL_OW 67
// until UnitFilter ( tmp , [ f_distxy , 114 , 108 , 9 ] ) >= ( tmp - 1 ) ;
6487: LD_VAR 0 2
6491: PPUSH
6492: LD_INT 92
6494: PUSH
6495: LD_INT 114
6497: PUSH
6498: LD_INT 108
6500: PUSH
6501: LD_INT 9
6503: PUSH
6504: EMPTY
6505: LIST
6506: LIST
6507: LIST
6508: LIST
6509: PPUSH
6510: CALL_OW 72
6514: PUSH
6515: LD_VAR 0 2
6519: PUSH
6520: LD_INT 1
6522: MINUS
6523: GREATEREQUAL
6524: IFFALSE 6402
// end else
6526: GO 6652
// begin repeat tmp := UnitFilter ( tmp , [ f_lives , 250 ] ) ;
6528: LD_ADDR_VAR 0 2
6532: PUSH
6533: LD_VAR 0 2
6537: PPUSH
6538: LD_INT 24
6540: PUSH
6541: LD_INT 250
6543: PUSH
6544: EMPTY
6545: LIST
6546: LIST
6547: PPUSH
6548: CALL_OW 72
6552: ST_TO_ADDR
// for i in tmp do
6553: LD_ADDR_VAR 0 1
6557: PUSH
6558: LD_VAR 0 2
6562: PUSH
6563: FOR_IN
6564: IFFALSE 6604
// if GetDistUnitXY ( i , 129 , 139 ) > 9 then
6566: LD_VAR 0 1
6570: PPUSH
6571: LD_INT 129
6573: PPUSH
6574: LD_INT 139
6576: PPUSH
6577: CALL_OW 297
6581: PUSH
6582: LD_INT 9
6584: GREATER
6585: IFFALSE 6602
// ComMoveXY ( i , 129 , 139 ) ;
6587: LD_VAR 0 1
6591: PPUSH
6592: LD_INT 129
6594: PPUSH
6595: LD_INT 139
6597: PPUSH
6598: CALL_OW 111
6602: GO 6563
6604: POP
6605: POP
// wait ( 0 0$1 ) ;
6606: LD_INT 35
6608: PPUSH
6609: CALL_OW 67
// until UnitFilter ( tmp , [ f_distxy , 129 , 139 , 9 ] ) >= ( tmp - 1 ) ;
6613: LD_VAR 0 2
6617: PPUSH
6618: LD_INT 92
6620: PUSH
6621: LD_INT 129
6623: PUSH
6624: LD_INT 139
6626: PUSH
6627: LD_INT 9
6629: PUSH
6630: EMPTY
6631: LIST
6632: LIST
6633: LIST
6634: LIST
6635: PPUSH
6636: CALL_OW 72
6640: PUSH
6641: LD_VAR 0 2
6645: PUSH
6646: LD_INT 1
6648: MINUS
6649: GREATEREQUAL
6650: IFFALSE 6528
// end ; repeat wait ( 0 0$1 ) ;
6652: LD_INT 35
6654: PPUSH
6655: CALL_OW 67
// for i in tmp do
6659: LD_ADDR_VAR 0 1
6663: PUSH
6664: LD_VAR 0 2
6668: PUSH
6669: FOR_IN
6670: IFFALSE 6752
// begin if GetLives ( i ) > 251 then
6672: LD_VAR 0 1
6676: PPUSH
6677: CALL_OW 256
6681: PUSH
6682: LD_INT 251
6684: GREATER
6685: IFFALSE 6723
// ComAttackUnit ( i , NearestUnitToUnit ( FilterAllUnits ( [ f_enemy , 1 ] ) , i ) ) else
6687: LD_VAR 0 1
6691: PPUSH
6692: LD_INT 81
6694: PUSH
6695: LD_INT 1
6697: PUSH
6698: EMPTY
6699: LIST
6700: LIST
6701: PPUSH
6702: CALL_OW 69
6706: PPUSH
6707: LD_VAR 0 1
6711: PPUSH
6712: CALL_OW 74
6716: PPUSH
6717: CALL_OW 115
6721: GO 6750
// if IsDead ( i ) then
6723: LD_VAR 0 1
6727: PPUSH
6728: CALL_OW 301
6732: IFFALSE 6750
// tmp := tmp diff i ;
6734: LD_ADDR_VAR 0 2
6738: PUSH
6739: LD_VAR 0 2
6743: PUSH
6744: LD_VAR 0 1
6748: DIFF
6749: ST_TO_ADDR
// end ;
6750: GO 6669
6752: POP
6753: POP
// until not tmp ;
6754: LD_VAR 0 2
6758: NOT
6759: IFFALSE 6652
// end ;
6761: PPOPN 3
6763: END
// every 30 30$00 trigger not americanDestroyed do
6764: LD_EXP 4
6768: NOT
6769: IFFALSE 6838
6771: GO 6773
6773: DISABLE
// begin wait ( [ 30 30$00 , 20 20$00 , 15 15$00 , 10 10$00 ] [ Difficulty ] ) ;
6774: LD_INT 63000
6776: PUSH
6777: LD_INT 42000
6779: PUSH
6780: LD_INT 31500
6782: PUSH
6783: LD_INT 21000
6785: PUSH
6786: EMPTY
6787: LIST
6788: LIST
6789: LIST
6790: LIST
6791: PUSH
6792: LD_OWVAR 67
6796: ARRAY
6797: PPUSH
6798: CALL_OW 67
// if americanDestroyed then
6802: LD_EXP 4
6806: IFFALSE 6810
// exit ;
6808: GO 6838
// MC_InsertProduceList ( 4 , [ [ us_morphling , engine_siberite , control_manual , us_siberium_rocket ] ] ) ;
6810: LD_INT 4
6812: PPUSH
6813: LD_INT 5
6815: PUSH
6816: LD_INT 3
6818: PUSH
6819: LD_INT 1
6821: PUSH
6822: LD_INT 8
6824: PUSH
6825: EMPTY
6826: LIST
6827: LIST
6828: LIST
6829: LIST
6830: PUSH
6831: EMPTY
6832: LIST
6833: PPUSH
6834: CALL 45625 0 2
// end ; end_of_file
6838: END
// export function PrepareArabian ; var i , un , tmp , side ; begin
6839: LD_INT 0
6841: PPUSH
6842: PPUSH
6843: PPUSH
6844: PPUSH
6845: PPUSH
// side := 2 ;
6846: LD_ADDR_VAR 0 5
6850: PUSH
6851: LD_INT 2
6853: ST_TO_ADDR
// InitHc ;
6854: CALL_OW 19
// uc_side := side ;
6858: LD_ADDR_OWVAR 20
6862: PUSH
6863: LD_VAR 0 5
6867: ST_TO_ADDR
// uc_nation := 2 ;
6868: LD_ADDR_OWVAR 21
6872: PUSH
6873: LD_INT 2
6875: ST_TO_ADDR
// for i in FilterAllUnits ( [ [ f_side , 2 ] , [ f_type , unit_building ] ] ) do
6876: LD_ADDR_VAR 0 2
6880: PUSH
6881: LD_INT 22
6883: PUSH
6884: LD_INT 2
6886: PUSH
6887: EMPTY
6888: LIST
6889: LIST
6890: PUSH
6891: LD_INT 21
6893: PUSH
6894: LD_INT 3
6896: PUSH
6897: EMPTY
6898: LIST
6899: LIST
6900: PUSH
6901: EMPTY
6902: LIST
6903: LIST
6904: PPUSH
6905: CALL_OW 69
6909: PUSH
6910: FOR_IN
6911: IFFALSE 6927
// SetBLevel ( i , 10 ) ;
6913: LD_VAR 0 2
6917: PPUSH
6918: LD_INT 10
6920: PPUSH
6921: CALL_OW 241
6925: GO 6910
6927: POP
6928: POP
// tmp := FilterAllUnits ( [ [ f_side , side ] , [ f_btype , b_bunker ] , [ f_empty ] ] ) ;
6929: LD_ADDR_VAR 0 4
6933: PUSH
6934: LD_INT 22
6936: PUSH
6937: LD_VAR 0 5
6941: PUSH
6942: EMPTY
6943: LIST
6944: LIST
6945: PUSH
6946: LD_INT 30
6948: PUSH
6949: LD_INT 32
6951: PUSH
6952: EMPTY
6953: LIST
6954: LIST
6955: PUSH
6956: LD_INT 58
6958: PUSH
6959: EMPTY
6960: LIST
6961: PUSH
6962: EMPTY
6963: LIST
6964: LIST
6965: LIST
6966: PPUSH
6967: CALL_OW 69
6971: ST_TO_ADDR
// for i = 1 to 10 do
6972: LD_ADDR_VAR 0 2
6976: PUSH
6977: DOUBLE
6978: LD_INT 1
6980: DEC
6981: ST_TO_ADDR
6982: LD_INT 10
6984: PUSH
6985: FOR_TO
6986: IFFALSE 7058
// begin uc_nation := nation_nature ;
6988: LD_ADDR_OWVAR 21
6992: PUSH
6993: LD_INT 0
6995: ST_TO_ADDR
// hc_class := class_apeman_soldier ;
6996: LD_ADDR_OWVAR 28
7000: PUSH
7001: LD_INT 15
7003: ST_TO_ADDR
// hc_gallery :=  ;
7004: LD_ADDR_OWVAR 33
7008: PUSH
7009: LD_STRING 
7011: ST_TO_ADDR
// hc_name :=  ;
7012: LD_ADDR_OWVAR 26
7016: PUSH
7017: LD_STRING 
7019: ST_TO_ADDR
// un := CreateHuman ;
7020: LD_ADDR_VAR 0 3
7024: PUSH
7025: CALL_OW 44
7029: ST_TO_ADDR
// PlaceHumanInUnit ( un , tmp [ tmp - i ] ) ;
7030: LD_VAR 0 3
7034: PPUSH
7035: LD_VAR 0 4
7039: PUSH
7040: LD_VAR 0 4
7044: PUSH
7045: LD_VAR 0 2
7049: MINUS
7050: ARRAY
7051: PPUSH
7052: CALL_OW 52
// end ;
7056: GO 6985
7058: POP
7059: POP
// PrepareBase ( ar_depot , arabianBaseArea ,  , [ 8 , 9 , 10 , 10 ] [ Difficulty ] , [ 3000 , 500 , 150 ] , [ 16 , 6 , 6 , 6 ] ) ;
7060: LD_INT 503
7062: PPUSH
7063: LD_INT 27
7065: PPUSH
7066: LD_STRING 
7068: PPUSH
7069: LD_INT 8
7071: PUSH
7072: LD_INT 9
7074: PUSH
7075: LD_INT 10
7077: PUSH
7078: LD_INT 10
7080: PUSH
7081: EMPTY
7082: LIST
7083: LIST
7084: LIST
7085: LIST
7086: PUSH
7087: LD_OWVAR 67
7091: ARRAY
7092: PPUSH
7093: LD_INT 3000
7095: PUSH
7096: LD_INT 500
7098: PUSH
7099: LD_INT 150
7101: PUSH
7102: EMPTY
7103: LIST
7104: LIST
7105: LIST
7106: PPUSH
7107: LD_INT 16
7109: PUSH
7110: LD_INT 6
7112: PUSH
7113: LD_INT 6
7115: PUSH
7116: LD_INT 6
7118: PUSH
7119: EMPTY
7120: LIST
7121: LIST
7122: LIST
7123: LIST
7124: PPUSH
7125: CALL 60341 0 6
// mc_bases := Replace ( mc_bases , 1 , FilterAllUnits ( [ [ f_side , side ] , [ f_nation , 2 ] , [ f_not , [ f_type , unit_vehicle ] ] ] ) ) ;
7129: LD_ADDR_EXP 95
7133: PUSH
7134: LD_EXP 95
7138: PPUSH
7139: LD_INT 1
7141: PPUSH
7142: LD_INT 22
7144: PUSH
7145: LD_VAR 0 5
7149: PUSH
7150: EMPTY
7151: LIST
7152: LIST
7153: PUSH
7154: LD_INT 23
7156: PUSH
7157: LD_INT 2
7159: PUSH
7160: EMPTY
7161: LIST
7162: LIST
7163: PUSH
7164: LD_INT 3
7166: PUSH
7167: LD_INT 21
7169: PUSH
7170: LD_INT 2
7172: PUSH
7173: EMPTY
7174: LIST
7175: LIST
7176: PUSH
7177: EMPTY
7178: LIST
7179: LIST
7180: PUSH
7181: EMPTY
7182: LIST
7183: LIST
7184: LIST
7185: PPUSH
7186: CALL_OW 69
7190: PPUSH
7191: CALL_OW 1
7195: ST_TO_ADDR
// end ;
7196: LD_VAR 0 1
7200: RET
// export Omar ; export function PrepareOmarAli ; begin
7201: LD_INT 0
7203: PPUSH
// uc_side := 5 ;
7204: LD_ADDR_OWVAR 20
7208: PUSH
7209: LD_INT 5
7211: ST_TO_ADDR
// uc_nation := 2 ;
7212: LD_ADDR_OWVAR 21
7216: PUSH
7217: LD_INT 2
7219: ST_TO_ADDR
// Omar := NewCharacter ( Omar ) ;
7220: LD_ADDR_EXP 55
7224: PUSH
7225: LD_STRING Omar
7227: PPUSH
7228: CALL_OW 25
7232: ST_TO_ADDR
// PlaceUnitXY ( Omar , 330 , 244 , false ) ;
7233: LD_EXP 55
7237: PPUSH
7238: LD_INT 330
7240: PPUSH
7241: LD_INT 244
7243: PPUSH
7244: LD_INT 0
7246: PPUSH
7247: CALL_OW 48
// ComMoveXY ( Omar , 252 , 220 ) ;
7251: LD_EXP 55
7255: PPUSH
7256: LD_INT 252
7258: PPUSH
7259: LD_INT 220
7261: PPUSH
7262: CALL_OW 111
// end ; end_of_file
7266: LD_VAR 0 1
7270: RET
// export Schulz , Kozlov ; export function PrepareLegion ; var i , side , un , tmp ; begin
7271: LD_INT 0
7273: PPUSH
7274: PPUSH
7275: PPUSH
7276: PPUSH
7277: PPUSH
// side := 8 ;
7278: LD_ADDR_VAR 0 3
7282: PUSH
7283: LD_INT 8
7285: ST_TO_ADDR
// InitHc ;
7286: CALL_OW 19
// uc_side := side ;
7290: LD_ADDR_OWVAR 20
7294: PUSH
7295: LD_VAR 0 3
7299: ST_TO_ADDR
// uc_nation := 2 ;
7300: LD_ADDR_OWVAR 21
7304: PUSH
7305: LD_INT 2
7307: ST_TO_ADDR
// for i in FilterAllUnits ( [ [ f_side , side ] , [ f_type , unit_building ] ] ) do
7308: LD_ADDR_VAR 0 2
7312: PUSH
7313: LD_INT 22
7315: PUSH
7316: LD_VAR 0 3
7320: PUSH
7321: EMPTY
7322: LIST
7323: LIST
7324: PUSH
7325: LD_INT 21
7327: PUSH
7328: LD_INT 3
7330: PUSH
7331: EMPTY
7332: LIST
7333: LIST
7334: PUSH
7335: EMPTY
7336: LIST
7337: LIST
7338: PPUSH
7339: CALL_OW 69
7343: PUSH
7344: FOR_IN
7345: IFFALSE 7361
// SetBLevel ( i , 10 ) ;
7347: LD_VAR 0 2
7351: PPUSH
7352: LD_INT 10
7354: PPUSH
7355: CALL_OW 241
7359: GO 7344
7361: POP
7362: POP
// Schulz := NewCharacter ( Schulz ) ;
7363: LD_ADDR_EXP 56
7367: PUSH
7368: LD_STRING Schulz
7370: PPUSH
7371: CALL_OW 25
7375: ST_TO_ADDR
// Kozlov := PrepareUnit ( Kozlov , false ,  ) ;
7376: LD_ADDR_EXP 57
7380: PUSH
7381: LD_STRING Kozlov
7383: PPUSH
7384: LD_INT 0
7386: PPUSH
7387: LD_STRING 
7389: PPUSH
7390: CALL 52031 0 3
7394: ST_TO_ADDR
// PlaceHumanInUnit ( Kozlov , FilterAllUnits ( [ [ f_side , 8 ] , [ f_nation , 3 ] , [ f_btype , b_lab_full ] ] ) [ 1 ] ) ;
7395: LD_EXP 57
7399: PPUSH
7400: LD_INT 22
7402: PUSH
7403: LD_INT 8
7405: PUSH
7406: EMPTY
7407: LIST
7408: LIST
7409: PUSH
7410: LD_INT 23
7412: PUSH
7413: LD_INT 3
7415: PUSH
7416: EMPTY
7417: LIST
7418: LIST
7419: PUSH
7420: LD_INT 30
7422: PUSH
7423: LD_INT 8
7425: PUSH
7426: EMPTY
7427: LIST
7428: LIST
7429: PUSH
7430: EMPTY
7431: LIST
7432: LIST
7433: LIST
7434: PPUSH
7435: CALL_OW 69
7439: PUSH
7440: LD_INT 1
7442: ARRAY
7443: PPUSH
7444: CALL_OW 52
// SetSkill ( Kozlov , class_mechanic , 10 ) ;
7448: LD_EXP 57
7452: PPUSH
7453: LD_INT 3
7455: PPUSH
7456: LD_INT 10
7458: PPUSH
7459: CALL_OW 237
// tmp := FilterAllUnits ( [ [ f_side , side ] , [ f_btype , b_bunker ] , [ f_empty ] ] ) ;
7463: LD_ADDR_VAR 0 5
7467: PUSH
7468: LD_INT 22
7470: PUSH
7471: LD_VAR 0 3
7475: PUSH
7476: EMPTY
7477: LIST
7478: LIST
7479: PUSH
7480: LD_INT 30
7482: PUSH
7483: LD_INT 32
7485: PUSH
7486: EMPTY
7487: LIST
7488: LIST
7489: PUSH
7490: LD_INT 58
7492: PUSH
7493: EMPTY
7494: LIST
7495: PUSH
7496: EMPTY
7497: LIST
7498: LIST
7499: LIST
7500: PPUSH
7501: CALL_OW 69
7505: ST_TO_ADDR
// for i = 1 to 10 do
7506: LD_ADDR_VAR 0 2
7510: PUSH
7511: DOUBLE
7512: LD_INT 1
7514: DEC
7515: ST_TO_ADDR
7516: LD_INT 10
7518: PUSH
7519: FOR_TO
7520: IFFALSE 7592
// begin uc_nation := nation_nature ;
7522: LD_ADDR_OWVAR 21
7526: PUSH
7527: LD_INT 0
7529: ST_TO_ADDR
// hc_class := class_apeman_soldier ;
7530: LD_ADDR_OWVAR 28
7534: PUSH
7535: LD_INT 15
7537: ST_TO_ADDR
// hc_gallery :=  ;
7538: LD_ADDR_OWVAR 33
7542: PUSH
7543: LD_STRING 
7545: ST_TO_ADDR
// hc_name :=  ;
7546: LD_ADDR_OWVAR 26
7550: PUSH
7551: LD_STRING 
7553: ST_TO_ADDR
// un := CreateHuman ;
7554: LD_ADDR_VAR 0 4
7558: PUSH
7559: CALL_OW 44
7563: ST_TO_ADDR
// PlaceHumanInUnit ( un , tmp [ tmp - i ] ) ;
7564: LD_VAR 0 4
7568: PPUSH
7569: LD_VAR 0 5
7573: PUSH
7574: LD_VAR 0 5
7578: PUSH
7579: LD_VAR 0 2
7583: MINUS
7584: ARRAY
7585: PPUSH
7586: CALL_OW 52
// end ;
7590: GO 7519
7592: POP
7593: POP
// PrepareBase ( ar_depot1 , legionBaseArea ,  , [ 8 , 9 , 10 , 10 ] [ Difficulty ] , [ 3000 , 500 , 150 ] , [ 16 , 6 , 6 , 8 ] ) ;
7594: LD_INT 324
7596: PPUSH
7597: LD_INT 3
7599: PPUSH
7600: LD_STRING 
7602: PPUSH
7603: LD_INT 8
7605: PUSH
7606: LD_INT 9
7608: PUSH
7609: LD_INT 10
7611: PUSH
7612: LD_INT 10
7614: PUSH
7615: EMPTY
7616: LIST
7617: LIST
7618: LIST
7619: LIST
7620: PUSH
7621: LD_OWVAR 67
7625: ARRAY
7626: PPUSH
7627: LD_INT 3000
7629: PUSH
7630: LD_INT 500
7632: PUSH
7633: LD_INT 150
7635: PUSH
7636: EMPTY
7637: LIST
7638: LIST
7639: LIST
7640: PPUSH
7641: LD_INT 16
7643: PUSH
7644: LD_INT 6
7646: PUSH
7647: LD_INT 6
7649: PUSH
7650: LD_INT 8
7652: PUSH
7653: EMPTY
7654: LIST
7655: LIST
7656: LIST
7657: LIST
7658: PPUSH
7659: CALL 60341 0 6
// mc_bases := Replace ( mc_bases , 3 , FilterAllUnits ( [ [ f_side , side ] , [ f_nation , 2 ] , [ f_not , [ f_type , unit_vehicle ] ] ] ) diff Schulz ) ;
7663: LD_ADDR_EXP 95
7667: PUSH
7668: LD_EXP 95
7672: PPUSH
7673: LD_INT 3
7675: PPUSH
7676: LD_INT 22
7678: PUSH
7679: LD_VAR 0 3
7683: PUSH
7684: EMPTY
7685: LIST
7686: LIST
7687: PUSH
7688: LD_INT 23
7690: PUSH
7691: LD_INT 2
7693: PUSH
7694: EMPTY
7695: LIST
7696: LIST
7697: PUSH
7698: LD_INT 3
7700: PUSH
7701: LD_INT 21
7703: PUSH
7704: LD_INT 2
7706: PUSH
7707: EMPTY
7708: LIST
7709: LIST
7710: PUSH
7711: EMPTY
7712: LIST
7713: LIST
7714: PUSH
7715: EMPTY
7716: LIST
7717: LIST
7718: LIST
7719: PPUSH
7720: CALL_OW 69
7724: PUSH
7725: LD_EXP 56
7729: DIFF
7730: PPUSH
7731: CALL_OW 1
7735: ST_TO_ADDR
// end ;
7736: LD_VAR 0 1
7740: RET
// export function BuildKozlovBomb ; begin
7741: LD_INT 0
7743: PPUSH
// if not IsOk ( kozlov_fac ) or not IsOk ( kozlov_lab ) then
7744: LD_INT 332
7746: PPUSH
7747: CALL_OW 302
7751: NOT
7752: PUSH
7753: LD_INT 336
7755: PPUSH
7756: CALL_OW 302
7760: NOT
7761: OR
7762: IFFALSE 7766
// exit ;
7764: GO 7863
// ComChangeProfession ( Kozlov , 4 ) ;
7766: LD_EXP 57
7770: PPUSH
7771: LD_INT 4
7773: PPUSH
7774: CALL_OW 123
// ComResearch ( kozlov_lab , tech_sibFiss ) ;
7778: LD_INT 336
7780: PPUSH
7781: LD_INT 25
7783: PPUSH
7784: CALL_OW 124
// repeat wait ( 0 0$1 ) ;
7788: LD_INT 35
7790: PPUSH
7791: CALL_OW 67
// until GetTech ( tech_sibFiss , 8 ) = state_researched ;
7795: LD_INT 25
7797: PPUSH
7798: LD_INT 8
7800: PPUSH
7801: CALL_OW 321
7805: PUSH
7806: LD_INT 2
7808: EQUAL
7809: IFFALSE 7788
// ComExitBuilding ( Kozlov ) ;
7811: LD_EXP 57
7815: PPUSH
7816: CALL_OW 122
// AddComEnterUnit ( Kozlov , kozlov_fac ) ;
7820: LD_EXP 57
7824: PPUSH
7825: LD_INT 332
7827: PPUSH
7828: CALL_OW 180
// AddComChangeProfession ( Kozlov , 3 ) ;
7832: LD_EXP 57
7836: PPUSH
7837: LD_INT 3
7839: PPUSH
7840: CALL_OW 183
// ComConstruct ( kozlov_fac , ru_heavy_wheeled , engine_siberite , control_manual , ru_siberium_rocket ) ;
7844: LD_INT 332
7846: PPUSH
7847: LD_INT 23
7849: PPUSH
7850: LD_INT 3
7852: PPUSH
7853: LD_INT 1
7855: PPUSH
7856: LD_INT 48
7858: PPUSH
7859: CALL_OW 125
// end ;
7863: LD_VAR 0 1
7867: RET
// every 11 11$30 trigger not legionDestroyed and not MC_GetVehicles ( 3 , true ) do var i , tmp , target ;
7868: LD_EXP 3
7872: NOT
7873: PUSH
7874: LD_INT 3
7876: PPUSH
7877: LD_INT 1
7879: PPUSH
7880: CALL 47043 0 2
7884: NOT
7885: AND
7886: IFFALSE 8742
7888: GO 7890
7890: DISABLE
7891: LD_INT 0
7893: PPUSH
7894: PPUSH
7895: PPUSH
// begin enable ;
7896: ENABLE
// if not FilterAllUnits ( [ [ f_side , 8 ] , [ f_nation , 2 ] , [ f_btype , b_factory ] ] ) then
7897: LD_INT 22
7899: PUSH
7900: LD_INT 8
7902: PUSH
7903: EMPTY
7904: LIST
7905: LIST
7906: PUSH
7907: LD_INT 23
7909: PUSH
7910: LD_INT 2
7912: PUSH
7913: EMPTY
7914: LIST
7915: LIST
7916: PUSH
7917: LD_INT 30
7919: PUSH
7920: LD_INT 3
7922: PUSH
7923: EMPTY
7924: LIST
7925: LIST
7926: PUSH
7927: EMPTY
7928: LIST
7929: LIST
7930: LIST
7931: PPUSH
7932: CALL_OW 69
7936: NOT
7937: IFFALSE 7941
// exit ;
7939: GO 8742
// if Prob ( 40 ) then
7941: LD_INT 40
7943: PPUSH
7944: CALL_OW 13
7948: IFFALSE 8075
// begin MC_InsertProduceList ( 3 , [ [ ar_half_tracked , engine_combustion , control_remote , ar_rocket_launcher ] , [ ar_half_tracked , engine_combustion , control_remote , ar_rocket_launcher ] , [ ar_half_tracked , engine_combustion , control_remote , ar_rocket_launcher ] , [ ar_half_tracked , engine_combustion , control_remote , ar_rocket_launcher ] , [ ar_half_tracked , engine_combustion , control_remote , ar_rocket_launcher ] , [ ar_half_tracked , engine_combustion , control_remote , ar_flame_thrower ] , ] ) ;
7950: LD_INT 3
7952: PPUSH
7953: LD_INT 14
7955: PUSH
7956: LD_INT 1
7958: PUSH
7959: LD_INT 2
7961: PUSH
7962: LD_INT 28
7964: PUSH
7965: EMPTY
7966: LIST
7967: LIST
7968: LIST
7969: LIST
7970: PUSH
7971: LD_INT 14
7973: PUSH
7974: LD_INT 1
7976: PUSH
7977: LD_INT 2
7979: PUSH
7980: LD_INT 28
7982: PUSH
7983: EMPTY
7984: LIST
7985: LIST
7986: LIST
7987: LIST
7988: PUSH
7989: LD_INT 14
7991: PUSH
7992: LD_INT 1
7994: PUSH
7995: LD_INT 2
7997: PUSH
7998: LD_INT 28
8000: PUSH
8001: EMPTY
8002: LIST
8003: LIST
8004: LIST
8005: LIST
8006: PUSH
8007: LD_INT 14
8009: PUSH
8010: LD_INT 1
8012: PUSH
8013: LD_INT 2
8015: PUSH
8016: LD_INT 28
8018: PUSH
8019: EMPTY
8020: LIST
8021: LIST
8022: LIST
8023: LIST
8024: PUSH
8025: LD_INT 14
8027: PUSH
8028: LD_INT 1
8030: PUSH
8031: LD_INT 2
8033: PUSH
8034: LD_INT 28
8036: PUSH
8037: EMPTY
8038: LIST
8039: LIST
8040: LIST
8041: LIST
8042: PUSH
8043: LD_INT 14
8045: PUSH
8046: LD_INT 1
8048: PUSH
8049: LD_INT 2
8051: PUSH
8052: LD_INT 26
8054: PUSH
8055: EMPTY
8056: LIST
8057: LIST
8058: LIST
8059: LIST
8060: PUSH
8061: EMPTY
8062: LIST
8063: LIST
8064: LIST
8065: LIST
8066: LIST
8067: LIST
8068: PPUSH
8069: CALL 45625 0 2
// end else
8073: GO 8282
// begin MC_InsertProduceList ( 3 , [ [ ar_half_tracked , engine_combustion , control_remote , [ ar_gun , ar_flame_thrower , ar_flame_thrower , ar_rocket_launcher ] [ Difficulty ] ] , [ ar_half_tracked , engine_combustion , control_remote , [ ar_gun , ar_flame_thrower , ar_flame_thrower , ar_flame_thrower ] [ Difficulty ] ] , [ ar_half_tracked , engine_combustion , control_remote , [ ar_flame_thrower , ar_flame_thrower , ar_selfpropelled_bomb , ar_selfpropelled_bomb ] [ Difficulty ] ] , [ ar_medium_trike , engine_combustion , control_remote , [ ar_flame_thrower , ar_selfpropelled_bomb , ar_selfpropelled_bomb , ar_selfpropelled_bomb ] [ Difficulty ] ] , [ ar_medium_trike , engine_combustion , control_remote , ar_selfpropelled_bomb ] , [ ar_half_tracked , engine_combustion , control_remote , ar_flame_thrower ] , ] ) ;
8075: LD_INT 3
8077: PPUSH
8078: LD_INT 14
8080: PUSH
8081: LD_INT 1
8083: PUSH
8084: LD_INT 2
8086: PUSH
8087: LD_INT 27
8089: PUSH
8090: LD_INT 26
8092: PUSH
8093: LD_INT 26
8095: PUSH
8096: LD_INT 28
8098: PUSH
8099: EMPTY
8100: LIST
8101: LIST
8102: LIST
8103: LIST
8104: PUSH
8105: LD_OWVAR 67
8109: ARRAY
8110: PUSH
8111: EMPTY
8112: LIST
8113: LIST
8114: LIST
8115: LIST
8116: PUSH
8117: LD_INT 14
8119: PUSH
8120: LD_INT 1
8122: PUSH
8123: LD_INT 2
8125: PUSH
8126: LD_INT 27
8128: PUSH
8129: LD_INT 26
8131: PUSH
8132: LD_INT 26
8134: PUSH
8135: LD_INT 26
8137: PUSH
8138: EMPTY
8139: LIST
8140: LIST
8141: LIST
8142: LIST
8143: PUSH
8144: LD_OWVAR 67
8148: ARRAY
8149: PUSH
8150: EMPTY
8151: LIST
8152: LIST
8153: LIST
8154: LIST
8155: PUSH
8156: LD_INT 14
8158: PUSH
8159: LD_INT 1
8161: PUSH
8162: LD_INT 2
8164: PUSH
8165: LD_INT 26
8167: PUSH
8168: LD_INT 26
8170: PUSH
8171: LD_INT 29
8173: PUSH
8174: LD_INT 29
8176: PUSH
8177: EMPTY
8178: LIST
8179: LIST
8180: LIST
8181: LIST
8182: PUSH
8183: LD_OWVAR 67
8187: ARRAY
8188: PUSH
8189: EMPTY
8190: LIST
8191: LIST
8192: LIST
8193: LIST
8194: PUSH
8195: LD_INT 13
8197: PUSH
8198: LD_INT 1
8200: PUSH
8201: LD_INT 2
8203: PUSH
8204: LD_INT 26
8206: PUSH
8207: LD_INT 29
8209: PUSH
8210: LD_INT 29
8212: PUSH
8213: LD_INT 29
8215: PUSH
8216: EMPTY
8217: LIST
8218: LIST
8219: LIST
8220: LIST
8221: PUSH
8222: LD_OWVAR 67
8226: ARRAY
8227: PUSH
8228: EMPTY
8229: LIST
8230: LIST
8231: LIST
8232: LIST
8233: PUSH
8234: LD_INT 13
8236: PUSH
8237: LD_INT 1
8239: PUSH
8240: LD_INT 2
8242: PUSH
8243: LD_INT 29
8245: PUSH
8246: EMPTY
8247: LIST
8248: LIST
8249: LIST
8250: LIST
8251: PUSH
8252: LD_INT 14
8254: PUSH
8255: LD_INT 1
8257: PUSH
8258: LD_INT 2
8260: PUSH
8261: LD_INT 26
8263: PUSH
8264: EMPTY
8265: LIST
8266: LIST
8267: LIST
8268: LIST
8269: PUSH
8270: EMPTY
8271: LIST
8272: LIST
8273: LIST
8274: LIST
8275: LIST
8276: LIST
8277: PPUSH
8278: CALL 45625 0 2
// end ; repeat wait ( 0 0$1 ) ;
8282: LD_INT 35
8284: PPUSH
8285: CALL_OW 67
// until MC_GetVehicles ( 3 , true ) >= 6 ;
8289: LD_INT 3
8291: PPUSH
8292: LD_INT 1
8294: PPUSH
8295: CALL 47043 0 2
8299: PUSH
8300: LD_INT 6
8302: GREATEREQUAL
8303: IFFALSE 8282
// wait ( 0 0$30 ) ;
8305: LD_INT 1050
8307: PPUSH
8308: CALL_OW 67
// tmp := MC_GetVehicles ( 3 , true ) ;
8312: LD_ADDR_VAR 0 2
8316: PUSH
8317: LD_INT 3
8319: PPUSH
8320: LD_INT 1
8322: PPUSH
8323: CALL 47043 0 2
8327: ST_TO_ADDR
// mc_vehicles := Replace ( mc_vehicles , 3 , mc_vehicles [ 3 ] diff tmp ) ;
8328: LD_ADDR_EXP 114
8332: PUSH
8333: LD_EXP 114
8337: PPUSH
8338: LD_INT 3
8340: PPUSH
8341: LD_EXP 114
8345: PUSH
8346: LD_INT 3
8348: ARRAY
8349: PUSH
8350: LD_VAR 0 2
8354: DIFF
8355: PPUSH
8356: CALL_OW 1
8360: ST_TO_ADDR
// target := rand ( 0 , 2 ) ;
8361: LD_ADDR_VAR 0 3
8365: PUSH
8366: LD_INT 0
8368: PPUSH
8369: LD_INT 2
8371: PPUSH
8372: CALL_OW 12
8376: ST_TO_ADDR
// if target then
8377: LD_VAR 0 3
8381: IFFALSE 8509
// begin repeat tmp := UnitFilter ( tmp , [ f_lives , 250 ] ) ;
8383: LD_ADDR_VAR 0 2
8387: PUSH
8388: LD_VAR 0 2
8392: PPUSH
8393: LD_INT 24
8395: PUSH
8396: LD_INT 250
8398: PUSH
8399: EMPTY
8400: LIST
8401: LIST
8402: PPUSH
8403: CALL_OW 72
8407: ST_TO_ADDR
// for i in tmp do
8408: LD_ADDR_VAR 0 1
8412: PUSH
8413: LD_VAR 0 2
8417: PUSH
8418: FOR_IN
8419: IFFALSE 8459
// if GetDistUnitXY ( i , 89 , 71 ) > 9 then
8421: LD_VAR 0 1
8425: PPUSH
8426: LD_INT 89
8428: PPUSH
8429: LD_INT 71
8431: PPUSH
8432: CALL_OW 297
8436: PUSH
8437: LD_INT 9
8439: GREATER
8440: IFFALSE 8457
// ComMoveXY ( i , 89 , 71 ) ;
8442: LD_VAR 0 1
8446: PPUSH
8447: LD_INT 89
8449: PPUSH
8450: LD_INT 71
8452: PPUSH
8453: CALL_OW 111
8457: GO 8418
8459: POP
8460: POP
// wait ( 0 0$1 ) ;
8461: LD_INT 35
8463: PPUSH
8464: CALL_OW 67
// until UnitFilter ( tmp , [ f_distxy , 89 , 71 , 9 ] ) >= ( tmp - 1 ) ;
8468: LD_VAR 0 2
8472: PPUSH
8473: LD_INT 92
8475: PUSH
8476: LD_INT 89
8478: PUSH
8479: LD_INT 71
8481: PUSH
8482: LD_INT 9
8484: PUSH
8485: EMPTY
8486: LIST
8487: LIST
8488: LIST
8489: LIST
8490: PPUSH
8491: CALL_OW 72
8495: PUSH
8496: LD_VAR 0 2
8500: PUSH
8501: LD_INT 1
8503: MINUS
8504: GREATEREQUAL
8505: IFFALSE 8383
// end else
8507: GO 8633
// begin repeat tmp := UnitFilter ( tmp , [ f_lives , 250 ] ) ;
8509: LD_ADDR_VAR 0 2
8513: PUSH
8514: LD_VAR 0 2
8518: PPUSH
8519: LD_INT 24
8521: PUSH
8522: LD_INT 250
8524: PUSH
8525: EMPTY
8526: LIST
8527: LIST
8528: PPUSH
8529: CALL_OW 72
8533: ST_TO_ADDR
// for i in tmp do
8534: LD_ADDR_VAR 0 1
8538: PUSH
8539: LD_VAR 0 2
8543: PUSH
8544: FOR_IN
8545: IFFALSE 8585
// if GetDistUnitXY ( i , 147 , 4 ) > 9 then
8547: LD_VAR 0 1
8551: PPUSH
8552: LD_INT 147
8554: PPUSH
8555: LD_INT 4
8557: PPUSH
8558: CALL_OW 297
8562: PUSH
8563: LD_INT 9
8565: GREATER
8566: IFFALSE 8583
// ComMoveXY ( i , 147 , 4 ) ;
8568: LD_VAR 0 1
8572: PPUSH
8573: LD_INT 147
8575: PPUSH
8576: LD_INT 4
8578: PPUSH
8579: CALL_OW 111
8583: GO 8544
8585: POP
8586: POP
// wait ( 0 0$1 ) ;
8587: LD_INT 35
8589: PPUSH
8590: CALL_OW 67
// until UnitFilter ( tmp , [ f_distxy , 147 , 4 , 9 ] ) >= ( tmp - 1 ) ;
8594: LD_VAR 0 2
8598: PPUSH
8599: LD_INT 92
8601: PUSH
8602: LD_INT 147
8604: PUSH
8605: LD_INT 4
8607: PUSH
8608: LD_INT 9
8610: PUSH
8611: EMPTY
8612: LIST
8613: LIST
8614: LIST
8615: LIST
8616: PPUSH
8617: CALL_OW 72
8621: PUSH
8622: LD_VAR 0 2
8626: PUSH
8627: LD_INT 1
8629: MINUS
8630: GREATEREQUAL
8631: IFFALSE 8509
// end ; repeat wait ( 0 0$1 ) ;
8633: LD_INT 35
8635: PPUSH
8636: CALL_OW 67
// for i in tmp do
8640: LD_ADDR_VAR 0 1
8644: PUSH
8645: LD_VAR 0 2
8649: PUSH
8650: FOR_IN
8651: IFFALSE 8733
// begin if GetLives ( i ) > 251 then
8653: LD_VAR 0 1
8657: PPUSH
8658: CALL_OW 256
8662: PUSH
8663: LD_INT 251
8665: GREATER
8666: IFFALSE 8704
// ComAttackUnit ( i , NearestUnitToUnit ( FilterAllUnits ( [ f_enemy , 8 ] ) , i ) ) else
8668: LD_VAR 0 1
8672: PPUSH
8673: LD_INT 81
8675: PUSH
8676: LD_INT 8
8678: PUSH
8679: EMPTY
8680: LIST
8681: LIST
8682: PPUSH
8683: CALL_OW 69
8687: PPUSH
8688: LD_VAR 0 1
8692: PPUSH
8693: CALL_OW 74
8697: PPUSH
8698: CALL_OW 115
8702: GO 8731
// if IsDead ( i ) then
8704: LD_VAR 0 1
8708: PPUSH
8709: CALL_OW 301
8713: IFFALSE 8731
// tmp := tmp diff i ;
8715: LD_ADDR_VAR 0 2
8719: PUSH
8720: LD_VAR 0 2
8724: PUSH
8725: LD_VAR 0 1
8729: DIFF
8730: ST_TO_ADDR
// end ;
8731: GO 8650
8733: POP
8734: POP
// until not tmp ;
8735: LD_VAR 0 2
8739: NOT
8740: IFFALSE 8633
// end ;
8742: PPOPN 3
8744: END
// every 0 0$1 trigger IsOk ( Kozlov ) and not legionDestroyed do
8745: LD_EXP 57
8749: PPUSH
8750: CALL_OW 302
8754: PUSH
8755: LD_EXP 3
8759: NOT
8760: AND
8761: IFFALSE 8770
8763: GO 8765
8765: DISABLE
// BuildKozlovBomb ;
8766: CALL 7741 0 0
8770: END
// every 0 0$3 trigger FilterAllUnits ( [ [ f_side , 8 ] , [ f_weapon , ru_siberium_rocket ] ] ) do
8771: LD_INT 22
8773: PUSH
8774: LD_INT 8
8776: PUSH
8777: EMPTY
8778: LIST
8779: LIST
8780: PUSH
8781: LD_INT 34
8783: PUSH
8784: LD_INT 48
8786: PUSH
8787: EMPTY
8788: LIST
8789: LIST
8790: PUSH
8791: EMPTY
8792: LIST
8793: LIST
8794: PPUSH
8795: CALL_OW 69
8799: IFFALSE 8847
8801: GO 8803
8803: DISABLE
// begin ComAttackPlace ( FilterAllUnits ( [ [ f_side , 8 ] , [ f_weapon , ru_siberium_rocket ] ] ) [ 1 ] , 173 , 96 ) ;
8804: LD_INT 22
8806: PUSH
8807: LD_INT 8
8809: PUSH
8810: EMPTY
8811: LIST
8812: LIST
8813: PUSH
8814: LD_INT 34
8816: PUSH
8817: LD_INT 48
8819: PUSH
8820: EMPTY
8821: LIST
8822: LIST
8823: PUSH
8824: EMPTY
8825: LIST
8826: LIST
8827: PPUSH
8828: CALL_OW 69
8832: PUSH
8833: LD_INT 1
8835: ARRAY
8836: PPUSH
8837: LD_INT 173
8839: PPUSH
8840: LD_INT 96
8842: PPUSH
8843: CALL_OW 116
// end ; end_of_file
8847: END
// export Platonov , Yakotich , Gleb , Bierezov ; export behemoths , behemothBuilders ; export function PrepareRussian ; var i , j , base , tmp , side , xy , b , teleport ; begin
8848: LD_INT 0
8850: PPUSH
8851: PPUSH
8852: PPUSH
8853: PPUSH
8854: PPUSH
8855: PPUSH
8856: PPUSH
8857: PPUSH
8858: PPUSH
// side := 3 ;
8859: LD_ADDR_VAR 0 6
8863: PUSH
8864: LD_INT 3
8866: ST_TO_ADDR
// InitHc ;
8867: CALL_OW 19
// uc_side := side ;
8871: LD_ADDR_OWVAR 20
8875: PUSH
8876: LD_VAR 0 6
8880: ST_TO_ADDR
// uc_nation := 3 ;
8881: LD_ADDR_OWVAR 21
8885: PUSH
8886: LD_INT 3
8888: ST_TO_ADDR
// for i in FilterAllUnits ( [ [ f_side , side ] , [ f_type , unit_building ] ] ) do
8889: LD_ADDR_VAR 0 2
8893: PUSH
8894: LD_INT 22
8896: PUSH
8897: LD_VAR 0 6
8901: PUSH
8902: EMPTY
8903: LIST
8904: LIST
8905: PUSH
8906: LD_INT 21
8908: PUSH
8909: LD_INT 3
8911: PUSH
8912: EMPTY
8913: LIST
8914: LIST
8915: PUSH
8916: EMPTY
8917: LIST
8918: LIST
8919: PPUSH
8920: CALL_OW 69
8924: PUSH
8925: FOR_IN
8926: IFFALSE 8942
// SetBLevel ( i , 10 ) ;
8928: LD_VAR 0 2
8932: PPUSH
8933: LD_INT 10
8935: PPUSH
8936: CALL_OW 241
8940: GO 8925
8942: POP
8943: POP
// teleport := FilterAllUnits ( [ [ f_side , side ] , [ f_btype , b_teleport ] ] ) ;
8944: LD_ADDR_VAR 0 9
8948: PUSH
8949: LD_INT 22
8951: PUSH
8952: LD_VAR 0 6
8956: PUSH
8957: EMPTY
8958: LIST
8959: LIST
8960: PUSH
8961: LD_INT 30
8963: PUSH
8964: LD_INT 34
8966: PUSH
8967: EMPTY
8968: LIST
8969: LIST
8970: PUSH
8971: EMPTY
8972: LIST
8973: LIST
8974: PPUSH
8975: CALL_OW 69
8979: ST_TO_ADDR
// if teleport then
8980: LD_VAR 0 9
8984: IFFALSE 9005
// TeleportExit ( teleport [ 1 ] , 123 , 122 ) ;
8986: LD_VAR 0 9
8990: PUSH
8991: LD_INT 1
8993: ARRAY
8994: PPUSH
8995: LD_INT 123
8997: PPUSH
8998: LD_INT 122
9000: PPUSH
9001: CALL_OW 243
// hc_importance := 0 ;
9005: LD_ADDR_OWVAR 32
9009: PUSH
9010: LD_INT 0
9012: ST_TO_ADDR
// Platonov := NewCharacter ( Platonov ) ;
9013: LD_ADDR_EXP 58
9017: PUSH
9018: LD_STRING Platonov
9020: PPUSH
9021: CALL_OW 25
9025: ST_TO_ADDR
// Yakotich := NewCharacter ( Yakotich ) ;
9026: LD_ADDR_EXP 59
9030: PUSH
9031: LD_STRING Yakotich
9033: PPUSH
9034: CALL_OW 25
9038: ST_TO_ADDR
// Gleb := NewCharacter ( Gleb ) ;
9039: LD_ADDR_EXP 60
9043: PUSH
9044: LD_STRING Gleb
9046: PPUSH
9047: CALL_OW 25
9051: ST_TO_ADDR
// if TestCharacters ( 03_Cornel ) then
9052: LD_STRING 03_Cornel
9054: PPUSH
9055: CALL_OW 28
9059: IFFALSE 9107
// begin Bierezov := NewCharacter ( Mikhail ) ;
9061: LD_ADDR_EXP 61
9065: PUSH
9066: LD_STRING Mikhail
9068: PPUSH
9069: CALL_OW 25
9073: ST_TO_ADDR
// PlaceUnitXYR ( Bierezov , 197 , 111 , 9 , false ) ;
9074: LD_EXP 61
9078: PPUSH
9079: LD_INT 197
9081: PPUSH
9082: LD_INT 111
9084: PPUSH
9085: LD_INT 9
9087: PPUSH
9088: LD_INT 0
9090: PPUSH
9091: CALL_OW 50
// SetClass ( Bierezov , 3 ) ;
9095: LD_EXP 61
9099: PPUSH
9100: LD_INT 3
9102: PPUSH
9103: CALL_OW 336
// end ; PlaceHumanInUnit ( Platonov , ru_depot ) ;
9107: LD_EXP 58
9111: PPUSH
9112: LD_INT 126
9114: PPUSH
9115: CALL_OW 52
// PlaceUnitXYR ( Yakotich , 197 , 111 , 9 , false ) ;
9119: LD_EXP 59
9123: PPUSH
9124: LD_INT 197
9126: PPUSH
9127: LD_INT 111
9129: PPUSH
9130: LD_INT 9
9132: PPUSH
9133: LD_INT 0
9135: PPUSH
9136: CALL_OW 50
// PlaceUnitXYR ( Gleb , 197 , 111 , 9 , false ) ;
9140: LD_EXP 60
9144: PPUSH
9145: LD_INT 197
9147: PPUSH
9148: LD_INT 111
9150: PPUSH
9151: LD_INT 9
9153: PPUSH
9154: LD_INT 0
9156: PPUSH
9157: CALL_OW 50
// tmp := PrepareBase ( ru_depot , russianBaseArea , zhukov , [ 9 , 10 , 10 , 10 ] [ Difficulty ] , [ 9000 , 1000 , 300 ] , [ 21 , 8 , 13 , 8 ] ) ;
9161: LD_ADDR_VAR 0 5
9165: PUSH
9166: LD_INT 126
9168: PPUSH
9169: LD_INT 2
9171: PPUSH
9172: LD_STRING zhukov
9174: PPUSH
9175: LD_INT 9
9177: PUSH
9178: LD_INT 10
9180: PUSH
9181: LD_INT 10
9183: PUSH
9184: LD_INT 10
9186: PUSH
9187: EMPTY
9188: LIST
9189: LIST
9190: LIST
9191: LIST
9192: PUSH
9193: LD_OWVAR 67
9197: ARRAY
9198: PPUSH
9199: LD_INT 9000
9201: PUSH
9202: LD_INT 1000
9204: PUSH
9205: LD_INT 300
9207: PUSH
9208: EMPTY
9209: LIST
9210: LIST
9211: LIST
9212: PPUSH
9213: LD_INT 21
9215: PUSH
9216: LD_INT 8
9218: PUSH
9219: LD_INT 13
9221: PUSH
9222: LD_INT 8
9224: PUSH
9225: EMPTY
9226: LIST
9227: LIST
9228: LIST
9229: LIST
9230: PPUSH
9231: CALL 60341 0 6
9235: ST_TO_ADDR
// base := GetBase ( ru_depot2 ) ;
9236: LD_ADDR_VAR 0 4
9240: PUSH
9241: LD_INT 267
9243: PPUSH
9244: CALL_OW 274
9248: ST_TO_ADDR
// SetResourceType ( base , mat_cans , 5000 ) ;
9249: LD_VAR 0 4
9253: PPUSH
9254: LD_INT 1
9256: PPUSH
9257: LD_INT 5000
9259: PPUSH
9260: CALL_OW 277
// SetResourceType ( base , mat_oil , 200 ) ;
9264: LD_VAR 0 4
9268: PPUSH
9269: LD_INT 2
9271: PPUSH
9272: LD_INT 200
9274: PPUSH
9275: CALL_OW 277
// SetResourceType ( base , mat_siberit , 200 ) ;
9279: LD_VAR 0 4
9283: PPUSH
9284: LD_INT 3
9286: PPUSH
9287: LD_INT 200
9289: PPUSH
9290: CALL_OW 277
// mc_bases := Replace ( mc_bases , 2 , tmp union FilterAllUnits ( [ [ f_side , side ] , [ f_not , [ f_type , unit_vehicle ] ] ] ) diff Platonov ) ;
9294: LD_ADDR_EXP 95
9298: PUSH
9299: LD_EXP 95
9303: PPUSH
9304: LD_INT 2
9306: PPUSH
9307: LD_VAR 0 5
9311: PUSH
9312: LD_INT 22
9314: PUSH
9315: LD_VAR 0 6
9319: PUSH
9320: EMPTY
9321: LIST
9322: LIST
9323: PUSH
9324: LD_INT 3
9326: PUSH
9327: LD_INT 21
9329: PUSH
9330: LD_INT 2
9332: PUSH
9333: EMPTY
9334: LIST
9335: LIST
9336: PUSH
9337: EMPTY
9338: LIST
9339: LIST
9340: PUSH
9341: EMPTY
9342: LIST
9343: LIST
9344: PPUSH
9345: CALL_OW 69
9349: UNION
9350: PUSH
9351: LD_EXP 58
9355: DIFF
9356: PPUSH
9357: CALL_OW 1
9361: ST_TO_ADDR
// behemoths := [ ] ;
9362: LD_ADDR_EXP 62
9366: PUSH
9367: EMPTY
9368: ST_TO_ADDR
// behemothBuilders := [ ] ;
9369: LD_ADDR_EXP 63
9373: PUSH
9374: EMPTY
9375: ST_TO_ADDR
// j := 3 ;
9376: LD_ADDR_VAR 0 3
9380: PUSH
9381: LD_INT 3
9383: ST_TO_ADDR
// for i in FilterAllUnits ( [ [ f_side , 3 ] , [ f_class , 3 ] ] ) do
9384: LD_ADDR_VAR 0 2
9388: PUSH
9389: LD_INT 22
9391: PUSH
9392: LD_INT 3
9394: PUSH
9395: EMPTY
9396: LIST
9397: LIST
9398: PUSH
9399: LD_INT 25
9401: PUSH
9402: LD_INT 3
9404: PUSH
9405: EMPTY
9406: LIST
9407: LIST
9408: PUSH
9409: EMPTY
9410: LIST
9411: LIST
9412: PPUSH
9413: CALL_OW 69
9417: PUSH
9418: FOR_IN
9419: IFFALSE 9469
// begin behemothBuilders := Join ( behemothBuilders , i ) ;
9421: LD_ADDR_EXP 63
9425: PUSH
9426: LD_EXP 63
9430: PPUSH
9431: LD_VAR 0 2
9435: PPUSH
9436: CALL 88712 0 2
9440: ST_TO_ADDR
// j := j - 1 ;
9441: LD_ADDR_VAR 0 3
9445: PUSH
9446: LD_VAR 0 3
9450: PUSH
9451: LD_INT 1
9453: MINUS
9454: ST_TO_ADDR
// if j = 0 then
9455: LD_VAR 0 3
9459: PUSH
9460: LD_INT 0
9462: EQUAL
9463: IFFALSE 9467
// break ;
9465: GO 9469
// end ;
9467: GO 9418
9469: POP
9470: POP
// end ;
9471: LD_VAR 0 1
9475: RET
// export function BuildBehemoths ; var i , j , xy , tmp ; begin
9476: LD_INT 0
9478: PPUSH
9479: PPUSH
9480: PPUSH
9481: PPUSH
9482: PPUSH
// xy := [ [ 209 , 149 ] , [ 219 , 154 ] , [ 223 , 149 ] , [ 232 , 155 ] ] ;
9483: LD_ADDR_VAR 0 4
9487: PUSH
9488: LD_INT 209
9490: PUSH
9491: LD_INT 149
9493: PUSH
9494: EMPTY
9495: LIST
9496: LIST
9497: PUSH
9498: LD_INT 219
9500: PUSH
9501: LD_INT 154
9503: PUSH
9504: EMPTY
9505: LIST
9506: LIST
9507: PUSH
9508: LD_INT 223
9510: PUSH
9511: LD_INT 149
9513: PUSH
9514: EMPTY
9515: LIST
9516: LIST
9517: PUSH
9518: LD_INT 232
9520: PUSH
9521: LD_INT 155
9523: PUSH
9524: EMPTY
9525: LIST
9526: LIST
9527: PUSH
9528: EMPTY
9529: LIST
9530: LIST
9531: LIST
9532: LIST
9533: ST_TO_ADDR
// if not behemothBuilders then
9534: LD_EXP 63
9538: NOT
9539: IFFALSE 9543
// exit ;
9541: GO 9647
// j := 1 ;
9543: LD_ADDR_VAR 0 3
9547: PUSH
9548: LD_INT 1
9550: ST_TO_ADDR
// for i in behemothBuilders do
9551: LD_ADDR_VAR 0 2
9555: PUSH
9556: LD_EXP 63
9560: PUSH
9561: FOR_IN
9562: IFFALSE 9645
// begin if IsInUnit ( i ) then
9564: LD_VAR 0 2
9568: PPUSH
9569: CALL_OW 310
9573: IFFALSE 9584
// ComExitBuilding ( i ) ;
9575: LD_VAR 0 2
9579: PPUSH
9580: CALL_OW 122
// AddComBuildBehemoth ( i , b_behemoth , xy [ j ] [ 1 ] , xy [ j ] [ 2 ] , 0 ) ;
9584: LD_VAR 0 2
9588: PPUSH
9589: LD_INT 37
9591: PPUSH
9592: LD_VAR 0 4
9596: PUSH
9597: LD_VAR 0 3
9601: ARRAY
9602: PUSH
9603: LD_INT 1
9605: ARRAY
9606: PPUSH
9607: LD_VAR 0 4
9611: PUSH
9612: LD_VAR 0 3
9616: ARRAY
9617: PUSH
9618: LD_INT 2
9620: ARRAY
9621: PPUSH
9622: LD_INT 0
9624: PPUSH
9625: CALL_OW 230
// j := j + 1 ;
9629: LD_ADDR_VAR 0 3
9633: PUSH
9634: LD_VAR 0 3
9638: PUSH
9639: LD_INT 1
9641: PLUS
9642: ST_TO_ADDR
// end ;
9643: GO 9561
9645: POP
9646: POP
// end ;
9647: LD_VAR 0 1
9651: RET
// every 0 0$3 trigger GetBehemoths ( 3 ) and not FilterAllUnits ( [ [ f_side , 3 ] , [ f_btype , b_behemoth ] ] ) do var i , tmp ;
9652: LD_INT 3
9654: PPUSH
9655: CALL 88773 0 1
9659: PUSH
9660: LD_INT 22
9662: PUSH
9663: LD_INT 3
9665: PUSH
9666: EMPTY
9667: LIST
9668: LIST
9669: PUSH
9670: LD_INT 30
9672: PUSH
9673: LD_INT 37
9675: PUSH
9676: EMPTY
9677: LIST
9678: LIST
9679: PUSH
9680: EMPTY
9681: LIST
9682: LIST
9683: PPUSH
9684: CALL_OW 69
9688: NOT
9689: AND
9690: IFFALSE 9876
9692: GO 9694
9694: DISABLE
9695: LD_INT 0
9697: PPUSH
9698: PPUSH
// begin enable ;
9699: ENABLE
// tmp := GetBehemoths ( 3 ) ;
9700: LD_ADDR_VAR 0 2
9704: PUSH
9705: LD_INT 3
9707: PPUSH
9708: CALL 88773 0 1
9712: ST_TO_ADDR
// for i in tmp do
9713: LD_ADDR_VAR 0 1
9717: PUSH
9718: LD_VAR 0 2
9722: PUSH
9723: FOR_IN
9724: IFFALSE 9874
// begin if IsInArea ( i , powellBase ) and not GetTag ( i ) = 2 then
9726: LD_VAR 0 1
9730: PPUSH
9731: LD_INT 7
9733: PPUSH
9734: CALL_OW 308
9738: PUSH
9739: LD_VAR 0 1
9743: PPUSH
9744: CALL_OW 110
9748: PUSH
9749: LD_INT 2
9751: EQUAL
9752: NOT
9753: AND
9754: IFFALSE 9768
// SetTag ( i , 2 ) ;
9756: LD_VAR 0 1
9760: PPUSH
9761: LD_INT 2
9763: PPUSH
9764: CALL_OW 109
// if not FilterAllUnits ( [ [ f_enemy , 3 ] , [ f_dist , i , 12 ] ] ) and not GetTag ( i ) = 2 then
9768: LD_INT 81
9770: PUSH
9771: LD_INT 3
9773: PUSH
9774: EMPTY
9775: LIST
9776: LIST
9777: PUSH
9778: LD_INT 91
9780: PUSH
9781: LD_VAR 0 1
9785: PUSH
9786: LD_INT 12
9788: PUSH
9789: EMPTY
9790: LIST
9791: LIST
9792: LIST
9793: PUSH
9794: EMPTY
9795: LIST
9796: LIST
9797: PPUSH
9798: CALL_OW 69
9802: NOT
9803: PUSH
9804: LD_VAR 0 1
9808: PPUSH
9809: CALL_OW 110
9813: PUSH
9814: LD_INT 2
9816: EQUAL
9817: NOT
9818: AND
9819: IFFALSE 9838
// ComAgressiveMove ( i , 64 , 93 ) else
9821: LD_VAR 0 1
9825: PPUSH
9826: LD_INT 64
9828: PPUSH
9829: LD_INT 93
9831: PPUSH
9832: CALL_OW 114
9836: GO 9872
// ComAttackUnit ( i , NearestUnitToUnit ( FilterAllUnits ( [ f_enemy , 3 ] ) , i ) ) ;
9838: LD_VAR 0 1
9842: PPUSH
9843: LD_INT 81
9845: PUSH
9846: LD_INT 3
9848: PUSH
9849: EMPTY
9850: LIST
9851: LIST
9852: PPUSH
9853: CALL_OW 69
9857: PPUSH
9858: LD_VAR 0 1
9862: PPUSH
9863: CALL_OW 74
9867: PPUSH
9868: CALL_OW 115
// end ;
9872: GO 9723
9874: POP
9875: POP
// end ;
9876: PPOPN 2
9878: END
// every 11 11$30 trigger not russianDestroyed and not MC_GetVehicles ( 2 , true ) do var i , tmp , target , teleport ;
9879: LD_EXP 2
9883: NOT
9884: PUSH
9885: LD_INT 2
9887: PPUSH
9888: LD_INT 1
9890: PPUSH
9891: CALL 47043 0 2
9895: NOT
9896: AND
9897: IFFALSE 10821
9899: GO 9901
9901: DISABLE
9902: LD_INT 0
9904: PPUSH
9905: PPUSH
9906: PPUSH
9907: PPUSH
// begin enable ;
9908: ENABLE
// if not FilterAllUnits ( [ [ f_side , 3 ] , [ f_btype , b_factory ] ] ) then
9909: LD_INT 22
9911: PUSH
9912: LD_INT 3
9914: PUSH
9915: EMPTY
9916: LIST
9917: LIST
9918: PUSH
9919: LD_INT 30
9921: PUSH
9922: LD_INT 3
9924: PUSH
9925: EMPTY
9926: LIST
9927: LIST
9928: PUSH
9929: EMPTY
9930: LIST
9931: LIST
9932: PPUSH
9933: CALL_OW 69
9937: NOT
9938: IFFALSE 9942
// exit ;
9940: GO 10821
// teleport := FilterAllUnits ( [ [ f_side , 3 ] , [ f_btype , b_teleport ] ] ) ;
9942: LD_ADDR_VAR 0 4
9946: PUSH
9947: LD_INT 22
9949: PUSH
9950: LD_INT 3
9952: PUSH
9953: EMPTY
9954: LIST
9955: LIST
9956: PUSH
9957: LD_INT 30
9959: PUSH
9960: LD_INT 34
9962: PUSH
9963: EMPTY
9964: LIST
9965: LIST
9966: PUSH
9967: EMPTY
9968: LIST
9969: LIST
9970: PPUSH
9971: CALL_OW 69
9975: ST_TO_ADDR
// if Prob ( 40 ) then
9976: LD_INT 40
9978: PPUSH
9979: CALL_OW 13
9983: IFFALSE 10110
// begin MC_InsertProduceList ( 2 , [ [ ru_medium_tracked , engine_siberite , control_computer , ru_time_lapser ] , [ ru_medium_tracked , engine_siberite , control_computer , ru_time_lapser ] , [ ru_medium_tracked , engine_siberite , control_computer , ru_time_lapser ] , [ ru_heavy_tracked , engine_siberite , control_computer , ru_heavy_gun ] , [ ru_heavy_tracked , engine_siberite , control_computer , ru_heavy_gun ] , [ ru_heavy_tracked , engine_siberite , control_computer , ru_heavy_gun ] ] ) ;
9985: LD_INT 2
9987: PPUSH
9988: LD_INT 22
9990: PUSH
9991: LD_INT 3
9993: PUSH
9994: LD_INT 3
9996: PUSH
9997: LD_INT 49
9999: PUSH
10000: EMPTY
10001: LIST
10002: LIST
10003: LIST
10004: LIST
10005: PUSH
10006: LD_INT 22
10008: PUSH
10009: LD_INT 3
10011: PUSH
10012: LD_INT 3
10014: PUSH
10015: LD_INT 49
10017: PUSH
10018: EMPTY
10019: LIST
10020: LIST
10021: LIST
10022: LIST
10023: PUSH
10024: LD_INT 22
10026: PUSH
10027: LD_INT 3
10029: PUSH
10030: LD_INT 3
10032: PUSH
10033: LD_INT 49
10035: PUSH
10036: EMPTY
10037: LIST
10038: LIST
10039: LIST
10040: LIST
10041: PUSH
10042: LD_INT 24
10044: PUSH
10045: LD_INT 3
10047: PUSH
10048: LD_INT 3
10050: PUSH
10051: LD_INT 46
10053: PUSH
10054: EMPTY
10055: LIST
10056: LIST
10057: LIST
10058: LIST
10059: PUSH
10060: LD_INT 24
10062: PUSH
10063: LD_INT 3
10065: PUSH
10066: LD_INT 3
10068: PUSH
10069: LD_INT 46
10071: PUSH
10072: EMPTY
10073: LIST
10074: LIST
10075: LIST
10076: LIST
10077: PUSH
10078: LD_INT 24
10080: PUSH
10081: LD_INT 3
10083: PUSH
10084: LD_INT 3
10086: PUSH
10087: LD_INT 46
10089: PUSH
10090: EMPTY
10091: LIST
10092: LIST
10093: LIST
10094: LIST
10095: PUSH
10096: EMPTY
10097: LIST
10098: LIST
10099: LIST
10100: LIST
10101: LIST
10102: LIST
10103: PPUSH
10104: CALL 45625 0 2
// end else
10108: GO 10233
// begin MC_InsertProduceList ( 2 , [ [ ru_heavy_tracked , engine_siberite , control_computer , ru_rocket ] , [ ru_heavy_tracked , engine_siberite , control_computer , ru_rocket ] , [ ru_heavy_tracked , engine_siberite , control_computer , ru_rocket ] , [ ru_heavy_tracked , engine_siberite , control_computer , ru_heavy_gun ] , [ ru_heavy_tracked , engine_siberite , control_computer , ru_heavy_gun ] , [ ru_heavy_tracked , engine_siberite , control_computer , ru_heavy_gun ] ] ) ;
10110: LD_INT 2
10112: PPUSH
10113: LD_INT 24
10115: PUSH
10116: LD_INT 3
10118: PUSH
10119: LD_INT 3
10121: PUSH
10122: LD_INT 47
10124: PUSH
10125: EMPTY
10126: LIST
10127: LIST
10128: LIST
10129: LIST
10130: PUSH
10131: LD_INT 24
10133: PUSH
10134: LD_INT 3
10136: PUSH
10137: LD_INT 3
10139: PUSH
10140: LD_INT 47
10142: PUSH
10143: EMPTY
10144: LIST
10145: LIST
10146: LIST
10147: LIST
10148: PUSH
10149: LD_INT 24
10151: PUSH
10152: LD_INT 3
10154: PUSH
10155: LD_INT 3
10157: PUSH
10158: LD_INT 47
10160: PUSH
10161: EMPTY
10162: LIST
10163: LIST
10164: LIST
10165: LIST
10166: PUSH
10167: LD_INT 24
10169: PUSH
10170: LD_INT 3
10172: PUSH
10173: LD_INT 3
10175: PUSH
10176: LD_INT 46
10178: PUSH
10179: EMPTY
10180: LIST
10181: LIST
10182: LIST
10183: LIST
10184: PUSH
10185: LD_INT 24
10187: PUSH
10188: LD_INT 3
10190: PUSH
10191: LD_INT 3
10193: PUSH
10194: LD_INT 46
10196: PUSH
10197: EMPTY
10198: LIST
10199: LIST
10200: LIST
10201: LIST
10202: PUSH
10203: LD_INT 24
10205: PUSH
10206: LD_INT 3
10208: PUSH
10209: LD_INT 3
10211: PUSH
10212: LD_INT 46
10214: PUSH
10215: EMPTY
10216: LIST
10217: LIST
10218: LIST
10219: LIST
10220: PUSH
10221: EMPTY
10222: LIST
10223: LIST
10224: LIST
10225: LIST
10226: LIST
10227: LIST
10228: PPUSH
10229: CALL 45625 0 2
// end ; if Difficulty > 1 then
10233: LD_OWVAR 67
10237: PUSH
10238: LD_INT 1
10240: GREATER
10241: IFFALSE 10271
// MC_InsertProduceList ( 2 , [ [ ru_heavy_tracked , engine_siberite , control_computer , ru_rocket ] ] ) ;
10243: LD_INT 2
10245: PPUSH
10246: LD_INT 24
10248: PUSH
10249: LD_INT 3
10251: PUSH
10252: LD_INT 3
10254: PUSH
10255: LD_INT 47
10257: PUSH
10258: EMPTY
10259: LIST
10260: LIST
10261: LIST
10262: LIST
10263: PUSH
10264: EMPTY
10265: LIST
10266: PPUSH
10267: CALL 45625 0 2
// repeat wait ( 0 0$1 ) ;
10271: LD_INT 35
10273: PPUSH
10274: CALL_OW 67
// until MC_GetVehicles ( 2 , true ) >= [ 6 , 7 , 7 , 7 ] [ Difficulty ] ;
10278: LD_INT 2
10280: PPUSH
10281: LD_INT 1
10283: PPUSH
10284: CALL 47043 0 2
10288: PUSH
10289: LD_INT 6
10291: PUSH
10292: LD_INT 7
10294: PUSH
10295: LD_INT 7
10297: PUSH
10298: LD_INT 7
10300: PUSH
10301: EMPTY
10302: LIST
10303: LIST
10304: LIST
10305: LIST
10306: PUSH
10307: LD_OWVAR 67
10311: ARRAY
10312: GREATEREQUAL
10313: IFFALSE 10271
// wait ( 0 0$30 ) ;
10315: LD_INT 1050
10317: PPUSH
10318: CALL_OW 67
// tmp := MC_GetVehicles ( 2 , true ) ;
10322: LD_ADDR_VAR 0 2
10326: PUSH
10327: LD_INT 2
10329: PPUSH
10330: LD_INT 1
10332: PPUSH
10333: CALL 47043 0 2
10337: ST_TO_ADDR
// mc_vehicles := Replace ( mc_vehicles , 2 , mc_vehicles [ 2 ] diff tmp ) ;
10338: LD_ADDR_EXP 114
10342: PUSH
10343: LD_EXP 114
10347: PPUSH
10348: LD_INT 2
10350: PPUSH
10351: LD_EXP 114
10355: PUSH
10356: LD_INT 2
10358: ARRAY
10359: PUSH
10360: LD_VAR 0 2
10364: DIFF
10365: PPUSH
10366: CALL_OW 1
10370: ST_TO_ADDR
// target := rand ( 0 , 1 ) ;
10371: LD_ADDR_VAR 0 3
10375: PUSH
10376: LD_INT 0
10378: PPUSH
10379: LD_INT 1
10381: PPUSH
10382: CALL_OW 12
10386: ST_TO_ADDR
// if target then
10387: LD_VAR 0 3
10391: IFFALSE 10519
// begin repeat tmp := UnitFilter ( tmp , [ f_lives , 250 ] ) ;
10393: LD_ADDR_VAR 0 2
10397: PUSH
10398: LD_VAR 0 2
10402: PPUSH
10403: LD_INT 24
10405: PUSH
10406: LD_INT 250
10408: PUSH
10409: EMPTY
10410: LIST
10411: LIST
10412: PPUSH
10413: CALL_OW 72
10417: ST_TO_ADDR
// for i in tmp do
10418: LD_ADDR_VAR 0 1
10422: PUSH
10423: LD_VAR 0 2
10427: PUSH
10428: FOR_IN
10429: IFFALSE 10469
// if GetDistUnitXY ( i , 139 , 89 ) > 9 then
10431: LD_VAR 0 1
10435: PPUSH
10436: LD_INT 139
10438: PPUSH
10439: LD_INT 89
10441: PPUSH
10442: CALL_OW 297
10446: PUSH
10447: LD_INT 9
10449: GREATER
10450: IFFALSE 10467
// ComMoveXY ( i , 139 , 89 ) ;
10452: LD_VAR 0 1
10456: PPUSH
10457: LD_INT 139
10459: PPUSH
10460: LD_INT 89
10462: PPUSH
10463: CALL_OW 111
10467: GO 10428
10469: POP
10470: POP
// wait ( 0 0$1 ) ;
10471: LD_INT 35
10473: PPUSH
10474: CALL_OW 67
// until UnitFilter ( tmp , [ f_distxy , 139 , 89 , 9 ] ) >= ( tmp - 1 ) ;
10478: LD_VAR 0 2
10482: PPUSH
10483: LD_INT 92
10485: PUSH
10486: LD_INT 139
10488: PUSH
10489: LD_INT 89
10491: PUSH
10492: LD_INT 9
10494: PUSH
10495: EMPTY
10496: LIST
10497: LIST
10498: LIST
10499: LIST
10500: PPUSH
10501: CALL_OW 72
10505: PUSH
10506: LD_VAR 0 2
10510: PUSH
10511: LD_INT 1
10513: MINUS
10514: GREATEREQUAL
10515: IFFALSE 10393
// end else
10517: GO 10661
// begin ComEnterUnit ( tmp , teleport [ 1 ] ) ;
10519: LD_VAR 0 2
10523: PPUSH
10524: LD_VAR 0 4
10528: PUSH
10529: LD_INT 1
10531: ARRAY
10532: PPUSH
10533: CALL_OW 120
// repeat tmp := UnitFilter ( tmp , [ f_lives , 250 ] ) ;
10537: LD_ADDR_VAR 0 2
10541: PUSH
10542: LD_VAR 0 2
10546: PPUSH
10547: LD_INT 24
10549: PUSH
10550: LD_INT 250
10552: PUSH
10553: EMPTY
10554: LIST
10555: LIST
10556: PPUSH
10557: CALL_OW 72
10561: ST_TO_ADDR
// for i in tmp do
10562: LD_ADDR_VAR 0 1
10566: PUSH
10567: LD_VAR 0 2
10571: PUSH
10572: FOR_IN
10573: IFFALSE 10613
// if GetDistUnitXY ( i , 124 , 139 ) > 9 then
10575: LD_VAR 0 1
10579: PPUSH
10580: LD_INT 124
10582: PPUSH
10583: LD_INT 139
10585: PPUSH
10586: CALL_OW 297
10590: PUSH
10591: LD_INT 9
10593: GREATER
10594: IFFALSE 10611
// ComMoveXY ( i , 124 , 139 ) ;
10596: LD_VAR 0 1
10600: PPUSH
10601: LD_INT 124
10603: PPUSH
10604: LD_INT 139
10606: PPUSH
10607: CALL_OW 111
10611: GO 10572
10613: POP
10614: POP
// wait ( 0 0$1 ) ;
10615: LD_INT 35
10617: PPUSH
10618: CALL_OW 67
// until UnitFilter ( tmp , [ f_distxy , 124 , 139 , 9 ] ) >= ( tmp - 1 ) ;
10622: LD_VAR 0 2
10626: PPUSH
10627: LD_INT 92
10629: PUSH
10630: LD_INT 124
10632: PUSH
10633: LD_INT 139
10635: PUSH
10636: LD_INT 9
10638: PUSH
10639: EMPTY
10640: LIST
10641: LIST
10642: LIST
10643: LIST
10644: PPUSH
10645: CALL_OW 72
10649: PUSH
10650: LD_VAR 0 2
10654: PUSH
10655: LD_INT 1
10657: MINUS
10658: GREATEREQUAL
10659: IFFALSE 10537
// end ; repeat wait ( 0 0$1 ) ;
10661: LD_INT 35
10663: PPUSH
10664: CALL_OW 67
// for i in tmp do
10668: LD_ADDR_VAR 0 1
10672: PUSH
10673: LD_VAR 0 2
10677: PUSH
10678: FOR_IN
10679: IFFALSE 10812
// begin if GetLives ( i ) > 251 then
10681: LD_VAR 0 1
10685: PPUSH
10686: CALL_OW 256
10690: PUSH
10691: LD_INT 251
10693: GREATER
10694: IFFALSE 10783
// begin if GetWeapon ( i ) = ru_time_lapser then
10696: LD_VAR 0 1
10700: PPUSH
10701: CALL_OW 264
10705: PUSH
10706: LD_INT 49
10708: EQUAL
10709: IFFALSE 10747
// ComMoveUnit ( i , NearestUnitToUnit ( FilterAllUnits ( [ f_enemy , 3 ] ) , i ) ) else
10711: LD_VAR 0 1
10715: PPUSH
10716: LD_INT 81
10718: PUSH
10719: LD_INT 3
10721: PUSH
10722: EMPTY
10723: LIST
10724: LIST
10725: PPUSH
10726: CALL_OW 69
10730: PPUSH
10731: LD_VAR 0 1
10735: PPUSH
10736: CALL_OW 74
10740: PPUSH
10741: CALL_OW 112
10745: GO 10781
// ComAttackUnit ( i , NearestUnitToUnit ( FilterAllUnits ( [ f_enemy , 3 ] ) , i ) ) ;
10747: LD_VAR 0 1
10751: PPUSH
10752: LD_INT 81
10754: PUSH
10755: LD_INT 3
10757: PUSH
10758: EMPTY
10759: LIST
10760: LIST
10761: PPUSH
10762: CALL_OW 69
10766: PPUSH
10767: LD_VAR 0 1
10771: PPUSH
10772: CALL_OW 74
10776: PPUSH
10777: CALL_OW 115
// end else
10781: GO 10810
// if IsDead ( i ) then
10783: LD_VAR 0 1
10787: PPUSH
10788: CALL_OW 301
10792: IFFALSE 10810
// tmp := tmp diff i ;
10794: LD_ADDR_VAR 0 2
10798: PUSH
10799: LD_VAR 0 2
10803: PUSH
10804: LD_VAR 0 1
10808: DIFF
10809: ST_TO_ADDR
// end ;
10810: GO 10678
10812: POP
10813: POP
// until not tmp ;
10814: LD_VAR 0 2
10818: NOT
10819: IFFALSE 10661
// end ;
10821: PPOPN 4
10823: END
// every 30 30$00 trigger not russianDestroyed do
10824: LD_EXP 2
10828: NOT
10829: IFFALSE 10898
10831: GO 10833
10833: DISABLE
// begin wait ( [ 50 50$00 , 40 40$00 , 30 30$00 , 25 25$00 ] [ Difficulty ] ) ;
10834: LD_INT 105000
10836: PUSH
10837: LD_INT 84000
10839: PUSH
10840: LD_INT 63000
10842: PUSH
10843: LD_INT 52500
10845: PUSH
10846: EMPTY
10847: LIST
10848: LIST
10849: LIST
10850: LIST
10851: PUSH
10852: LD_OWVAR 67
10856: ARRAY
10857: PPUSH
10858: CALL_OW 67
// if russianDestroyed then
10862: LD_EXP 2
10866: IFFALSE 10870
// exit ;
10868: GO 10898
// MC_InsertProduceList ( 2 , [ [ ru_heavy_wheeled , engine_siberite , control_manual , ru_siberium_rocket ] ] ) ;
10870: LD_INT 2
10872: PPUSH
10873: LD_INT 23
10875: PUSH
10876: LD_INT 3
10878: PUSH
10879: LD_INT 1
10881: PUSH
10882: LD_INT 48
10884: PUSH
10885: EMPTY
10886: LIST
10887: LIST
10888: LIST
10889: LIST
10890: PUSH
10891: EMPTY
10892: LIST
10893: PPUSH
10894: CALL 45625 0 2
// end ; end_of_file
10898: END
// export function CustomEvent ( event ) ; begin
10899: LD_INT 0
10901: PPUSH
// end ;
10902: LD_VAR 0 2
10906: RET
// on SibDepositContaminated ( unit , x , y ) do begin if InArea ( x , y , motherLodeArea ) then
10907: LD_VAR 0 2
10911: PPUSH
10912: LD_VAR 0 3
10916: PPUSH
10917: LD_INT 15
10919: PPUSH
10920: CALL_OW 309
10924: IFFALSE 10933
// YouLost ( MothContaminate ) ;
10926: LD_STRING MothContaminate
10928: PPUSH
10929: CALL_OW 104
// end ;
10933: PPOPN 3
10935: END
// on SiberiteRocketExploded ( unit , x , y ) do begin if InArea ( x , y , motherLodeArea ) then
10936: LD_VAR 0 2
10940: PPUSH
10941: LD_VAR 0 3
10945: PPUSH
10946: LD_INT 15
10948: PPUSH
10949: CALL_OW 309
10953: IFFALSE 10969
// begin wait ( 0 0$6 ) ;
10955: LD_INT 210
10957: PPUSH
10958: CALL_OW 67
// YouLost ( MothContaminateBomb ) ;
10962: LD_STRING MothContaminateBomb
10964: PPUSH
10965: CALL_OW 104
// end ; end ;
10969: PPOPN 3
10971: END
// on UnitDestroyed ( un ) do begin SOS_UnitDestroyed ( un ) ;
10972: LD_VAR 0 1
10976: PPUSH
10977: CALL 106400 0 1
// if un = JMM then
10981: LD_VAR 0 1
10985: PUSH
10986: LD_EXP 19
10990: EQUAL
10991: IFFALSE 11002
// begin YouLost ( JMM ) ;
10993: LD_STRING JMM
10995: PPUSH
10996: CALL_OW 104
// exit ;
11000: GO 11131
// end ; if GetSide ( un ) = 2 and not arabianAttacked then
11002: LD_VAR 0 1
11006: PPUSH
11007: CALL_OW 255
11011: PUSH
11012: LD_INT 2
11014: EQUAL
11015: PUSH
11016: LD_EXP 18
11020: NOT
11021: AND
11022: IFFALSE 11032
// arabianAttacked := true ;
11024: LD_ADDR_EXP 18
11028: PUSH
11029: LD_INT 1
11031: ST_TO_ADDR
// if un = Powell then
11032: LD_VAR 0 1
11036: PUSH
11037: LD_EXP 54
11041: EQUAL
11042: IFFALSE 11052
// americanDestroyed := true ;
11044: LD_ADDR_EXP 4
11048: PUSH
11049: LD_INT 1
11051: ST_TO_ADDR
// if un = Platonov then
11052: LD_VAR 0 1
11056: PUSH
11057: LD_EXP 58
11061: EQUAL
11062: IFFALSE 11072
// russianDestroyed := true ;
11064: LD_ADDR_EXP 2
11068: PUSH
11069: LD_INT 1
11071: ST_TO_ADDR
// if un in FilterAllUnits ( [ [ f_side , 7 ] , [ f_type , unit_vehicle ] ] ) then
11072: LD_VAR 0 1
11076: PUSH
11077: LD_INT 22
11079: PUSH
11080: LD_INT 7
11082: PUSH
11083: EMPTY
11084: LIST
11085: LIST
11086: PUSH
11087: LD_INT 21
11089: PUSH
11090: LD_INT 2
11092: PUSH
11093: EMPTY
11094: LIST
11095: LIST
11096: PUSH
11097: EMPTY
11098: LIST
11099: LIST
11100: PPUSH
11101: CALL_OW 69
11105: IN
11106: IFFALSE 11122
// vehicleLostCounter := vehicleLostCounter + 1 ;
11108: LD_ADDR_EXP 15
11112: PUSH
11113: LD_EXP 15
11117: PUSH
11118: LD_INT 1
11120: PLUS
11121: ST_TO_ADDR
// MCE_UnitDestroyed ( un ) ;
11122: LD_VAR 0 1
11126: PPUSH
11127: CALL 49045 0 1
// end ;
11131: PPOPN 1
11133: END
// on BuildingStarted ( building , builder ) do begin MCE_BuildingStarted ( building , builder ) ;
11134: LD_VAR 0 1
11138: PPUSH
11139: LD_VAR 0 2
11143: PPUSH
11144: CALL 51379 0 2
// end ;
11148: PPOPN 2
11150: END
// on UpgradeComplete ( building ) do begin MCE_UpgradeComplete ( building ) ;
11151: LD_VAR 0 1
11155: PPUSH
11156: CALL 50447 0 1
// end ;
11160: PPOPN 1
11162: END
// on BuildingComplete ( building ) do begin if building in FilterAllUnits ( [ [ f_side , 8 ] , [ f_btype , b_workshop ] , [ f_nation , 3 ] ] ) then
11163: LD_VAR 0 1
11167: PUSH
11168: LD_INT 22
11170: PUSH
11171: LD_INT 8
11173: PUSH
11174: EMPTY
11175: LIST
11176: LIST
11177: PUSH
11178: LD_INT 30
11180: PUSH
11181: LD_INT 2
11183: PUSH
11184: EMPTY
11185: LIST
11186: LIST
11187: PUSH
11188: LD_INT 23
11190: PUSH
11191: LD_INT 3
11193: PUSH
11194: EMPTY
11195: LIST
11196: LIST
11197: PUSH
11198: EMPTY
11199: LIST
11200: LIST
11201: LIST
11202: PPUSH
11203: CALL_OW 69
11207: IN
11208: IFFALSE 11235
// begin ComUpgrade ( building ) ;
11210: LD_VAR 0 1
11214: PPUSH
11215: CALL_OW 146
// ComComplete ( Kozlov , building ) ;
11219: LD_EXP 57
11223: PPUSH
11224: LD_VAR 0 1
11228: PPUSH
11229: CALL 59880 0 2
// exit ;
11233: GO 11244
// end ; MCE_BuildingComplete ( building ) ;
11235: LD_VAR 0 1
11239: PPUSH
11240: CALL 50688 0 1
// end ;
11244: PPOPN 1
11246: END
// on ResearchComplete ( tech , lab ) do begin MCE_ResearchComplete ( tech , lab ) ;
11247: LD_VAR 0 1
11251: PPUSH
11252: LD_VAR 0 2
11256: PPUSH
11257: CALL 48741 0 2
// end ;
11261: PPOPN 2
11263: END
// on CrateSpawn ( id , x , y , amount , mode ) do begin MCE_CrateSpawn ( id , x , y , amount , mode ) ;
11264: LD_VAR 0 1
11268: PPUSH
11269: LD_VAR 0 2
11273: PPUSH
11274: LD_VAR 0 3
11278: PPUSH
11279: LD_VAR 0 4
11283: PPUSH
11284: LD_VAR 0 5
11288: PPUSH
11289: CALL 48361 0 5
// end ;
11293: PPOPN 5
11295: END
// on VehicleConstructed ( vehicle , factory ) do begin SOS_VehicleConstructed ( vehicle , factory ) ;
11296: LD_VAR 0 1
11300: PPUSH
11301: LD_VAR 0 2
11305: PPUSH
11306: CALL 106522 0 2
// MCE_VehicleConstructed ( vehicle , factory ) ;
11310: LD_VAR 0 1
11314: PPUSH
11315: LD_VAR 0 2
11319: PPUSH
11320: CALL 47942 0 2
// end ;
11324: PPOPN 2
11326: END
// on VehicleCaptured ( new , old , side , capturing_unit ) do begin MCE_VehicleCaptured ( new , old , side , capturing_unit ) ;
11327: LD_VAR 0 1
11331: PPUSH
11332: LD_VAR 0 2
11336: PPUSH
11337: LD_VAR 0 3
11341: PPUSH
11342: LD_VAR 0 4
11346: PPUSH
11347: CALL 47780 0 4
// end ;
11351: PPOPN 4
11353: END
// on BuildingCaptured ( building , side , capturning_unit ) do begin MCE_BuildingCaptured ( building , side , capturning_unit ) ;
11354: LD_VAR 0 1
11358: PPUSH
11359: LD_VAR 0 2
11363: PPUSH
11364: LD_VAR 0 3
11368: PPUSH
11369: CALL 47555 0 3
// end ;
11373: PPOPN 3
11375: END
// on EnterBuilding ( building , unit ) do begin MCE_EnterBuilding ( building , unit ) ;
11376: LD_VAR 0 1
11380: PPUSH
11381: LD_VAR 0 2
11385: PPUSH
11386: CALL 47440 0 2
// end ;
11390: PPOPN 2
11392: END
// on LeaveBuilding ( building , unit ) do begin MCE_LeaveBuilding ( building , unit ) ;
11393: LD_VAR 0 1
11397: PPUSH
11398: LD_VAR 0 2
11402: PPUSH
11403: CALL 51674 0 2
// end ;
11407: PPOPN 2
11409: END
// on EvacuateVehicle ( driver , abandoned_vehicle , unknown1 , unknown2 ) do begin MCE_EvacuateVehicle ( driver , abandoned_vehicle , unknown1 , unknown2 ) ;
11410: LD_VAR 0 1
11414: PPUSH
11415: LD_VAR 0 2
11419: PPUSH
11420: LD_VAR 0 3
11424: PPUSH
11425: LD_VAR 0 4
11429: PPUSH
11430: CALL 51890 0 4
// end ;
11434: PPOPN 4
11436: END
// on ApemanTamed ( ape , sci ) do begin MCE_ApemanTamed ( ape , sci ) ;
11437: LD_VAR 0 1
11441: PPUSH
11442: LD_VAR 0 2
11446: PPUSH
11447: CALL 47249 0 2
// end ;
11451: PPOPN 2
11453: END
// on Command ( cmd ) do begin SOS_Command ( cmd ) ;
11454: LD_VAR 0 1
11458: PPUSH
11459: CALL 106506 0 1
// end ; end_of_file
11463: PPOPN 1
11465: END
// export function Action ; begin
11466: LD_INT 0
11468: PPUSH
// InGameOn ;
11469: CALL_OW 8
// CenterNowOnXY ( 206 , 11 ) ;
11473: LD_INT 206
11475: PPUSH
11476: LD_INT 11
11478: PPUSH
11479: CALL_OW 86
// wait ( 0 0$1 ) ;
11483: LD_INT 35
11485: PPUSH
11486: CALL_OW 67
// Say ( JMM , DStart-JMM-JMM-1 ) ;
11490: LD_EXP 19
11494: PPUSH
11495: LD_STRING DStart-JMM-JMM-1
11497: PPUSH
11498: CALL_OW 88
// Say ( Burlak , DStart-JMM-Bur-1 ) ;
11502: LD_EXP 51
11506: PPUSH
11507: LD_STRING DStart-JMM-Bur-1
11509: PPUSH
11510: CALL_OW 88
// Say ( JMM , DStart-JMM-JMM-2 ) ;
11514: LD_EXP 19
11518: PPUSH
11519: LD_STRING DStart-JMM-JMM-2
11521: PPUSH
11522: CALL_OW 88
// Say ( Burlak , DStart-JMM-Bur-2 ) ;
11526: LD_EXP 51
11530: PPUSH
11531: LD_STRING DStart-JMM-Bur-2
11533: PPUSH
11534: CALL_OW 88
// InGameOff ;
11538: CALL_OW 9
// ChangeMissionObjectives ( MStart ) ;
11542: LD_STRING MStart
11544: PPUSH
11545: CALL_OW 337
// SaveForQuickRestart ;
11549: CALL_OW 22
// end ;
11553: LD_VAR 0 1
11557: RET
// every 0 0$2 trigger SeeXY ( 7 , 255 , 219 ) do var speaker ;
11558: LD_INT 7
11560: PPUSH
11561: LD_INT 255
11563: PPUSH
11564: LD_INT 219
11566: PPUSH
11567: CALL_OW 293
11571: IFFALSE 12180
11573: GO 11575
11575: DISABLE
11576: LD_INT 0
11578: PPUSH
// begin wait ( 0 0$3 ) ;
11579: LD_INT 105
11581: PPUSH
11582: CALL_OW 67
// alienSpotted := true ;
11586: LD_ADDR_EXP 10
11590: PUSH
11591: LD_INT 1
11593: ST_TO_ADDR
// speaker := FilterAllUnits ( [ [ f_side , 7 ] , [ f_nation , 3 ] , [ f_type , unit_human ] , [ f_sex , sex_male ] ] ) diff [ Burlak , Titov , Dolgov , Petrosyan , Kuzmov , Kovalyuk , Scholtze ] ;
11594: LD_ADDR_VAR 0 1
11598: PUSH
11599: LD_INT 22
11601: PUSH
11602: LD_INT 7
11604: PUSH
11605: EMPTY
11606: LIST
11607: LIST
11608: PUSH
11609: LD_INT 23
11611: PUSH
11612: LD_INT 3
11614: PUSH
11615: EMPTY
11616: LIST
11617: LIST
11618: PUSH
11619: LD_INT 21
11621: PUSH
11622: LD_INT 1
11624: PUSH
11625: EMPTY
11626: LIST
11627: LIST
11628: PUSH
11629: LD_INT 26
11631: PUSH
11632: LD_INT 1
11634: PUSH
11635: EMPTY
11636: LIST
11637: LIST
11638: PUSH
11639: EMPTY
11640: LIST
11641: LIST
11642: LIST
11643: LIST
11644: PPUSH
11645: CALL_OW 69
11649: PUSH
11650: LD_EXP 51
11654: PUSH
11655: LD_EXP 39
11659: PUSH
11660: LD_EXP 41
11664: PUSH
11665: LD_EXP 42
11669: PUSH
11670: LD_EXP 49
11674: PUSH
11675: LD_EXP 48
11679: PUSH
11680: LD_EXP 43
11684: PUSH
11685: EMPTY
11686: LIST
11687: LIST
11688: LIST
11689: LIST
11690: LIST
11691: LIST
11692: LIST
11693: DIFF
11694: ST_TO_ADDR
// DialogueOn ;
11695: CALL_OW 6
// PlaceSeeing ( 255 , 219 , 7 , - 20 ) ;
11699: LD_INT 255
11701: PPUSH
11702: LD_INT 219
11704: PPUSH
11705: LD_INT 7
11707: PPUSH
11708: LD_INT 20
11710: NEG
11711: PPUSH
11712: CALL_OW 330
// CenterNowOnXY ( 255 , 219 ) ;
11716: LD_INT 255
11718: PPUSH
11719: LD_INT 219
11721: PPUSH
11722: CALL_OW 86
// if speaker then
11726: LD_VAR 0 1
11730: IFFALSE 11748
// Say ( speaker [ 1 ] , DAlienBase-RSol1-1 ) ;
11732: LD_VAR 0 1
11736: PUSH
11737: LD_INT 1
11739: ARRAY
11740: PPUSH
11741: LD_STRING DAlienBase-RSol1-1
11743: PPUSH
11744: CALL_OW 88
// Say ( JMM , DAlienBase-JMM-1 ) ;
11748: LD_EXP 19
11752: PPUSH
11753: LD_STRING DAlienBase-JMM-1
11755: PPUSH
11756: CALL_OW 88
// if IsOk ( Burlak ) then
11760: LD_EXP 51
11764: PPUSH
11765: CALL_OW 302
11769: IFFALSE 11790
// begin dwait ( 0 0$1 ) ;
11771: LD_INT 35
11773: PPUSH
11774: CALL_OW 68
// Say ( Burlak , DAlienBase-Bur-1 ) ;
11778: LD_EXP 51
11782: PPUSH
11783: LD_STRING DAlienBase-Bur-1
11785: PPUSH
11786: CALL_OW 88
// end ; if IsOk ( Roth ) then
11790: LD_EXP 20
11794: PPUSH
11795: CALL_OW 302
11799: IFFALSE 11813
// Say ( Roth , DAlienBase-Roth-1 ) ;
11801: LD_EXP 20
11805: PPUSH
11806: LD_STRING DAlienBase-Roth-1
11808: PPUSH
11809: CALL_OW 88
// if IsOk ( Gossudarov ) then
11813: LD_EXP 37
11817: PPUSH
11818: CALL_OW 302
11822: IFFALSE 11838
// Say ( Gossudarov , DAlienBase-Gos-1 ) else
11824: LD_EXP 37
11828: PPUSH
11829: LD_STRING DAlienBase-Gos-1
11831: PPUSH
11832: CALL_OW 88
11836: GO 11955
// begin speaker := FilterAllUnits ( [ [ f_side , 7 ] , [ f_class , 4 ] , [ f_type , unit_human ] , [ f_sex , sex_male ] ] ) diff [ Roth , JMM , Burlak , Titov , Kuzmov , Kovalyuk ] ;
11838: LD_ADDR_VAR 0 1
11842: PUSH
11843: LD_INT 22
11845: PUSH
11846: LD_INT 7
11848: PUSH
11849: EMPTY
11850: LIST
11851: LIST
11852: PUSH
11853: LD_INT 25
11855: PUSH
11856: LD_INT 4
11858: PUSH
11859: EMPTY
11860: LIST
11861: LIST
11862: PUSH
11863: LD_INT 21
11865: PUSH
11866: LD_INT 1
11868: PUSH
11869: EMPTY
11870: LIST
11871: LIST
11872: PUSH
11873: LD_INT 26
11875: PUSH
11876: LD_INT 1
11878: PUSH
11879: EMPTY
11880: LIST
11881: LIST
11882: PUSH
11883: EMPTY
11884: LIST
11885: LIST
11886: LIST
11887: LIST
11888: PPUSH
11889: CALL_OW 69
11893: PUSH
11894: LD_EXP 20
11898: PUSH
11899: LD_EXP 19
11903: PUSH
11904: LD_EXP 51
11908: PUSH
11909: LD_EXP 39
11913: PUSH
11914: LD_EXP 49
11918: PUSH
11919: LD_EXP 48
11923: PUSH
11924: EMPTY
11925: LIST
11926: LIST
11927: LIST
11928: LIST
11929: LIST
11930: LIST
11931: DIFF
11932: ST_TO_ADDR
// if speaker then
11933: LD_VAR 0 1
11937: IFFALSE 11955
// Say ( speaker [ 1 ] , DAlienBase-Sci1-1 ) ;
11939: LD_VAR 0 1
11943: PUSH
11944: LD_INT 1
11946: ARRAY
11947: PPUSH
11948: LD_STRING DAlienBase-Sci1-1
11950: PPUSH
11951: CALL_OW 88
// end ; RemoveSeeing ( 255 , 219 , 7 ) ;
11955: LD_INT 255
11957: PPUSH
11958: LD_INT 219
11960: PPUSH
11961: LD_INT 7
11963: PPUSH
11964: CALL_OW 331
// DialogueOff ;
11968: CALL_OW 7
// repeat wait ( 0 0$1 ) ;
11972: LD_INT 35
11974: PPUSH
11975: CALL_OW 67
// until IsSelected ( alien ) ;
11979: LD_INT 1
11981: PPUSH
11982: CALL_OW 306
11986: IFFALSE 11972
// if not artifactIResearched or not artifactIIResearched then
11988: LD_EXP 12
11992: NOT
11993: PUSH
11994: LD_EXP 13
11998: NOT
11999: OR
12000: IFFALSE 12180
// begin if IsOk ( Roth ) then
12002: LD_EXP 20
12006: PPUSH
12007: CALL_OW 302
12011: IFFALSE 12027
// Say ( Roth , DAlieBaseNotReady-Roth-1 ) else
12013: LD_EXP 20
12017: PPUSH
12018: LD_STRING DAlieBaseNotReady-Roth-1
12020: PPUSH
12021: CALL_OW 88
12025: GO 12180
// if IsOk ( Gossudarov ) then
12027: LD_EXP 37
12031: PPUSH
12032: CALL_OW 302
12036: IFFALSE 12052
// Say ( Gossudarov , DAlieBaseNotReady-Gos-1 ) else
12038: LD_EXP 37
12042: PPUSH
12043: LD_STRING DAlieBaseNotReady-Gos-1
12045: PPUSH
12046: CALL_OW 88
12050: GO 12180
// begin speaker := FilterAllUnits ( [ [ f_side , 7 ] , [ f_nation , 3 ] , [ f_class , 4 ] , [ f_type , unit_human ] , [ f_sex , sex_male ] ] ) diff [ Roth , JMM , Burlak , Titov , Kuzmov , Kovalyuk ] ;
12052: LD_ADDR_VAR 0 1
12056: PUSH
12057: LD_INT 22
12059: PUSH
12060: LD_INT 7
12062: PUSH
12063: EMPTY
12064: LIST
12065: LIST
12066: PUSH
12067: LD_INT 23
12069: PUSH
12070: LD_INT 3
12072: PUSH
12073: EMPTY
12074: LIST
12075: LIST
12076: PUSH
12077: LD_INT 25
12079: PUSH
12080: LD_INT 4
12082: PUSH
12083: EMPTY
12084: LIST
12085: LIST
12086: PUSH
12087: LD_INT 21
12089: PUSH
12090: LD_INT 1
12092: PUSH
12093: EMPTY
12094: LIST
12095: LIST
12096: PUSH
12097: LD_INT 26
12099: PUSH
12100: LD_INT 1
12102: PUSH
12103: EMPTY
12104: LIST
12105: LIST
12106: PUSH
12107: EMPTY
12108: LIST
12109: LIST
12110: LIST
12111: LIST
12112: LIST
12113: PPUSH
12114: CALL_OW 69
12118: PUSH
12119: LD_EXP 20
12123: PUSH
12124: LD_EXP 19
12128: PUSH
12129: LD_EXP 51
12133: PUSH
12134: LD_EXP 39
12138: PUSH
12139: LD_EXP 49
12143: PUSH
12144: LD_EXP 48
12148: PUSH
12149: EMPTY
12150: LIST
12151: LIST
12152: LIST
12153: LIST
12154: LIST
12155: LIST
12156: DIFF
12157: ST_TO_ADDR
// if speaker then
12158: LD_VAR 0 1
12162: IFFALSE 12180
// Say ( speaker [ 1 ] , DAlieBaseNotReady-RSci1-1 ) ;
12164: LD_VAR 0 1
12168: PUSH
12169: LD_INT 1
12171: ARRAY
12172: PPUSH
12173: LD_STRING DAlieBaseNotReady-RSci1-1
12175: PPUSH
12176: CALL_OW 88
// end ; end ; end ;
12180: PPOPN 1
12182: END
// every 0 0$1 trigger GetTech ( tech_Artifact , 7 ) = state_researched do var speaker ;
12183: LD_INT 24
12185: PPUSH
12186: LD_INT 7
12188: PPUSH
12189: CALL_OW 321
12193: PUSH
12194: LD_INT 2
12196: EQUAL
12197: IFFALSE 12888
12199: GO 12201
12201: DISABLE
12202: LD_INT 0
12204: PPUSH
// begin speaker := FilterAllUnits ( [ [ f_side , 7 ] , [ f_nation , 3 ] , [ f_class , 4 ] , [ f_type , unit_human ] , [ f_sex , sex_male ] ] ) diff [ Roth , JMM , Burlak , Titov , Kuzmov , Kovalyuk ] ;
12205: LD_ADDR_VAR 0 1
12209: PUSH
12210: LD_INT 22
12212: PUSH
12213: LD_INT 7
12215: PUSH
12216: EMPTY
12217: LIST
12218: LIST
12219: PUSH
12220: LD_INT 23
12222: PUSH
12223: LD_INT 3
12225: PUSH
12226: EMPTY
12227: LIST
12228: LIST
12229: PUSH
12230: LD_INT 25
12232: PUSH
12233: LD_INT 4
12235: PUSH
12236: EMPTY
12237: LIST
12238: LIST
12239: PUSH
12240: LD_INT 21
12242: PUSH
12243: LD_INT 1
12245: PUSH
12246: EMPTY
12247: LIST
12248: LIST
12249: PUSH
12250: LD_INT 26
12252: PUSH
12253: LD_INT 1
12255: PUSH
12256: EMPTY
12257: LIST
12258: LIST
12259: PUSH
12260: EMPTY
12261: LIST
12262: LIST
12263: LIST
12264: LIST
12265: LIST
12266: PPUSH
12267: CALL_OW 69
12271: PUSH
12272: LD_EXP 20
12276: PUSH
12277: LD_EXP 19
12281: PUSH
12282: LD_EXP 51
12286: PUSH
12287: LD_EXP 39
12291: PUSH
12292: LD_EXP 49
12296: PUSH
12297: LD_EXP 48
12301: PUSH
12302: EMPTY
12303: LIST
12304: LIST
12305: LIST
12306: LIST
12307: LIST
12308: LIST
12309: DIFF
12310: ST_TO_ADDR
// if not speaker then
12311: LD_VAR 0 1
12315: NOT
12316: IFFALSE 12320
// exit ;
12318: GO 12888
// DialogueOn ;
12320: CALL_OW 6
// Say ( speaker [ 1 ] , DArtefTechnology-RSci1-1 ) ;
12324: LD_VAR 0 1
12328: PUSH
12329: LD_INT 1
12331: ARRAY
12332: PPUSH
12333: LD_STRING DArtefTechnology-RSci1-1
12335: PPUSH
12336: CALL_OW 88
// if IsOk ( Burlak ) then
12340: LD_EXP 51
12344: PPUSH
12345: CALL_OW 302
12349: IFFALSE 12363
// Say ( Burlak , DArtefTechnology-Bur-1 ) ;
12351: LD_EXP 51
12355: PPUSH
12356: LD_STRING DArtefTechnology-Bur-1
12358: PPUSH
12359: CALL_OW 88
// Say ( speaker [ 1 ] , DArtefTechnology-RSci1-2 ) ;
12363: LD_VAR 0 1
12367: PUSH
12368: LD_INT 1
12370: ARRAY
12371: PPUSH
12372: LD_STRING DArtefTechnology-RSci1-2
12374: PPUSH
12375: CALL_OW 88
// if Denis then
12379: LD_EXP 25
12383: IFFALSE 12400
// speaker := [ Denis ] else
12385: LD_ADDR_VAR 0 1
12389: PUSH
12390: LD_EXP 25
12394: PUSH
12395: EMPTY
12396: LIST
12397: ST_TO_ADDR
12398: GO 12506
// speaker := FilterAllUnits ( [ [ f_side , 7 ] , [ f_nation , 1 ] , [ f_class , 4 ] , [ f_type , unit_human ] , [ f_sex , sex_male ] ] ) diff [ Roth , JMM , Burlak , Titov , Kuzmov , Kovalyuk ] ;
12400: LD_ADDR_VAR 0 1
12404: PUSH
12405: LD_INT 22
12407: PUSH
12408: LD_INT 7
12410: PUSH
12411: EMPTY
12412: LIST
12413: LIST
12414: PUSH
12415: LD_INT 23
12417: PUSH
12418: LD_INT 1
12420: PUSH
12421: EMPTY
12422: LIST
12423: LIST
12424: PUSH
12425: LD_INT 25
12427: PUSH
12428: LD_INT 4
12430: PUSH
12431: EMPTY
12432: LIST
12433: LIST
12434: PUSH
12435: LD_INT 21
12437: PUSH
12438: LD_INT 1
12440: PUSH
12441: EMPTY
12442: LIST
12443: LIST
12444: PUSH
12445: LD_INT 26
12447: PUSH
12448: LD_INT 1
12450: PUSH
12451: EMPTY
12452: LIST
12453: LIST
12454: PUSH
12455: EMPTY
12456: LIST
12457: LIST
12458: LIST
12459: LIST
12460: LIST
12461: PPUSH
12462: CALL_OW 69
12466: PUSH
12467: LD_EXP 20
12471: PUSH
12472: LD_EXP 19
12476: PUSH
12477: LD_EXP 51
12481: PUSH
12482: LD_EXP 39
12486: PUSH
12487: LD_EXP 49
12491: PUSH
12492: LD_EXP 48
12496: PUSH
12497: EMPTY
12498: LIST
12499: LIST
12500: LIST
12501: LIST
12502: LIST
12503: LIST
12504: DIFF
12505: ST_TO_ADDR
// if speaker then
12506: LD_VAR 0 1
12510: IFFALSE 12528
// Say ( speaker [ 1 ] , DArtefTechnology-Sci1-2 ) ;
12512: LD_VAR 0 1
12516: PUSH
12517: LD_INT 1
12519: ARRAY
12520: PPUSH
12521: LD_STRING DArtefTechnology-Sci1-2
12523: PPUSH
12524: CALL_OW 88
// speaker := FilterAllUnits ( [ [ f_side , 7 ] , [ f_nation , 3 ] , [ f_class , 4 ] , [ f_type , unit_human ] , [ f_sex , sex_male ] ] ) diff [ Roth , JMM , Burlak , Titov , Kuzmov , Kovalyuk ] ;
12528: LD_ADDR_VAR 0 1
12532: PUSH
12533: LD_INT 22
12535: PUSH
12536: LD_INT 7
12538: PUSH
12539: EMPTY
12540: LIST
12541: LIST
12542: PUSH
12543: LD_INT 23
12545: PUSH
12546: LD_INT 3
12548: PUSH
12549: EMPTY
12550: LIST
12551: LIST
12552: PUSH
12553: LD_INT 25
12555: PUSH
12556: LD_INT 4
12558: PUSH
12559: EMPTY
12560: LIST
12561: LIST
12562: PUSH
12563: LD_INT 21
12565: PUSH
12566: LD_INT 1
12568: PUSH
12569: EMPTY
12570: LIST
12571: LIST
12572: PUSH
12573: LD_INT 26
12575: PUSH
12576: LD_INT 1
12578: PUSH
12579: EMPTY
12580: LIST
12581: LIST
12582: PUSH
12583: EMPTY
12584: LIST
12585: LIST
12586: LIST
12587: LIST
12588: LIST
12589: PPUSH
12590: CALL_OW 69
12594: PUSH
12595: LD_EXP 20
12599: PUSH
12600: LD_EXP 19
12604: PUSH
12605: LD_EXP 51
12609: PUSH
12610: LD_EXP 39
12614: PUSH
12615: LD_EXP 49
12619: PUSH
12620: LD_EXP 48
12624: PUSH
12625: EMPTY
12626: LIST
12627: LIST
12628: LIST
12629: LIST
12630: LIST
12631: LIST
12632: DIFF
12633: ST_TO_ADDR
// if speaker and ( artifactArCaptured or arabianDestroyed ) then
12634: LD_VAR 0 1
12638: PUSH
12639: LD_EXP 9
12643: PUSH
12644: LD_EXP 5
12648: OR
12649: AND
12650: IFFALSE 12884
// begin if arabianDestroyed and IsOk ( Burlak ) then
12652: LD_EXP 5
12656: PUSH
12657: LD_EXP 51
12661: PPUSH
12662: CALL_OW 302
12666: AND
12667: IFFALSE 12683
// Say ( Burlak , DArtefTechnology-Bur-2 ) else
12669: LD_EXP 51
12673: PPUSH
12674: LD_STRING DArtefTechnology-Bur-2
12676: PPUSH
12677: CALL_OW 88
12681: GO 12695
// Say ( JMM , DArtefTechnology-JMM-2 ) ;
12683: LD_EXP 19
12687: PPUSH
12688: LD_STRING DArtefTechnology-JMM-2
12690: PPUSH
12691: CALL_OW 88
// Say ( speaker [ 1 ] , DArtefTechnology-RSci1-3 ) ;
12695: LD_VAR 0 1
12699: PUSH
12700: LD_INT 1
12702: ARRAY
12703: PPUSH
12704: LD_STRING DArtefTechnology-RSci1-3
12706: PPUSH
12707: CALL_OW 88
// if Denis then
12711: LD_EXP 25
12715: IFFALSE 12732
// speaker := [ Denis ] else
12717: LD_ADDR_VAR 0 1
12721: PUSH
12722: LD_EXP 25
12726: PUSH
12727: EMPTY
12728: LIST
12729: ST_TO_ADDR
12730: GO 12838
// speaker := FilterAllUnits ( [ [ f_side , 7 ] , [ f_nation , 1 ] , [ f_class , 4 ] , [ f_type , unit_human ] , [ f_sex , sex_male ] ] ) diff [ Roth , JMM , Burlak , Titov , Kuzmov , Kovalyuk ] ;
12732: LD_ADDR_VAR 0 1
12736: PUSH
12737: LD_INT 22
12739: PUSH
12740: LD_INT 7
12742: PUSH
12743: EMPTY
12744: LIST
12745: LIST
12746: PUSH
12747: LD_INT 23
12749: PUSH
12750: LD_INT 1
12752: PUSH
12753: EMPTY
12754: LIST
12755: LIST
12756: PUSH
12757: LD_INT 25
12759: PUSH
12760: LD_INT 4
12762: PUSH
12763: EMPTY
12764: LIST
12765: LIST
12766: PUSH
12767: LD_INT 21
12769: PUSH
12770: LD_INT 1
12772: PUSH
12773: EMPTY
12774: LIST
12775: LIST
12776: PUSH
12777: LD_INT 26
12779: PUSH
12780: LD_INT 1
12782: PUSH
12783: EMPTY
12784: LIST
12785: LIST
12786: PUSH
12787: EMPTY
12788: LIST
12789: LIST
12790: LIST
12791: LIST
12792: LIST
12793: PPUSH
12794: CALL_OW 69
12798: PUSH
12799: LD_EXP 20
12803: PUSH
12804: LD_EXP 19
12808: PUSH
12809: LD_EXP 51
12813: PUSH
12814: LD_EXP 39
12818: PUSH
12819: LD_EXP 49
12823: PUSH
12824: LD_EXP 48
12828: PUSH
12829: EMPTY
12830: LIST
12831: LIST
12832: LIST
12833: LIST
12834: LIST
12835: LIST
12836: DIFF
12837: ST_TO_ADDR
// if speaker then
12838: LD_VAR 0 1
12842: IFFALSE 12884
// if alienSpotted then
12844: LD_EXP 10
12848: IFFALSE 12868
// Say ( speaker [ 1 ] , DArtefTechnology-Sci1-3 ) else
12850: LD_VAR 0 1
12854: PUSH
12855: LD_INT 1
12857: ARRAY
12858: PPUSH
12859: LD_STRING DArtefTechnology-Sci1-3
12861: PPUSH
12862: CALL_OW 88
12866: GO 12884
// Say ( speaker [ 1 ] , DArtefTechnology-Sci1-3a ) ;
12868: LD_VAR 0 1
12872: PUSH
12873: LD_INT 1
12875: ARRAY
12876: PPUSH
12877: LD_STRING DArtefTechnology-Sci1-3a
12879: PPUSH
12880: CALL_OW 88
// end ; DialogueOff ;
12884: CALL_OW 7
// end ;
12888: PPOPN 1
12890: END
// every 0 0$1 trigger artifactIResearched do var speaker ;
12891: LD_EXP 12
12895: IFFALSE 13098
12897: GO 12899
12899: DISABLE
12900: LD_INT 0
12902: PPUSH
// begin if Denis then
12903: LD_EXP 25
12907: IFFALSE 12924
// speaker := [ Denis ] else
12909: LD_ADDR_VAR 0 1
12913: PUSH
12914: LD_EXP 25
12918: PUSH
12919: EMPTY
12920: LIST
12921: ST_TO_ADDR
12922: GO 13030
// speaker := FilterAllUnits ( [ [ f_side , 7 ] , [ f_nation , 1 ] , [ f_class , 4 ] , [ f_type , unit_human ] , [ f_sex , sex_male ] ] ) diff [ Roth , JMM , Burlak , Titov , Kuzmov , Kovalyuk ] ;
12924: LD_ADDR_VAR 0 1
12928: PUSH
12929: LD_INT 22
12931: PUSH
12932: LD_INT 7
12934: PUSH
12935: EMPTY
12936: LIST
12937: LIST
12938: PUSH
12939: LD_INT 23
12941: PUSH
12942: LD_INT 1
12944: PUSH
12945: EMPTY
12946: LIST
12947: LIST
12948: PUSH
12949: LD_INT 25
12951: PUSH
12952: LD_INT 4
12954: PUSH
12955: EMPTY
12956: LIST
12957: LIST
12958: PUSH
12959: LD_INT 21
12961: PUSH
12962: LD_INT 1
12964: PUSH
12965: EMPTY
12966: LIST
12967: LIST
12968: PUSH
12969: LD_INT 26
12971: PUSH
12972: LD_INT 1
12974: PUSH
12975: EMPTY
12976: LIST
12977: LIST
12978: PUSH
12979: EMPTY
12980: LIST
12981: LIST
12982: LIST
12983: LIST
12984: LIST
12985: PPUSH
12986: CALL_OW 69
12990: PUSH
12991: LD_EXP 20
12995: PUSH
12996: LD_EXP 19
13000: PUSH
13001: LD_EXP 51
13005: PUSH
13006: LD_EXP 39
13010: PUSH
13011: LD_EXP 49
13015: PUSH
13016: LD_EXP 48
13020: PUSH
13021: EMPTY
13022: LIST
13023: LIST
13024: LIST
13025: LIST
13026: LIST
13027: LIST
13028: DIFF
13029: ST_TO_ADDR
// if not speaker then
13030: LD_VAR 0 1
13034: NOT
13035: IFFALSE 13039
// exit ;
13037: GO 13098
// DialogueOn ;
13039: CALL_OW 6
// Say ( speaker [ 1 ] , DArtefTechnologyAm-Sci1-1 ) ;
13043: LD_VAR 0 1
13047: PUSH
13048: LD_INT 1
13050: ARRAY
13051: PPUSH
13052: LD_STRING DArtefTechnologyAm-Sci1-1
13054: PPUSH
13055: CALL_OW 88
// if IsOk ( Burlak ) then
13059: LD_EXP 51
13063: PPUSH
13064: CALL_OW 302
13068: IFFALSE 13082
// Say ( Burlak , DArtefTechnologyAm-Bur-1 ) ;
13070: LD_EXP 51
13074: PPUSH
13075: LD_STRING DArtefTechnologyAm-Bur-1
13077: PPUSH
13078: CALL_OW 88
// Say ( JMM , DArtefTechnologyAm-JMM-1 ) ;
13082: LD_EXP 19
13086: PPUSH
13087: LD_STRING DArtefTechnologyAm-JMM-1
13089: PPUSH
13090: CALL_OW 88
// DialogueOff ;
13094: CALL_OW 7
// end ;
13098: PPOPN 1
13100: END
// every 0 0$1 trigger artifactIIResearched do var speaker ;
13101: LD_EXP 13
13105: IFFALSE 13307
13107: GO 13109
13109: DISABLE
13110: LD_INT 0
13112: PPUSH
// begin speaker := FilterAllUnits ( [ [ f_side , 7 ] , [ f_nation , 3 ] , [ f_class , 4 ] , [ f_type , unit_human ] , [ f_sex , sex_male ] ] ) diff [ Roth , JMM , Burlak , Titov , Kuzmov , Kovalyuk ] ;
13113: LD_ADDR_VAR 0 1
13117: PUSH
13118: LD_INT 22
13120: PUSH
13121: LD_INT 7
13123: PUSH
13124: EMPTY
13125: LIST
13126: LIST
13127: PUSH
13128: LD_INT 23
13130: PUSH
13131: LD_INT 3
13133: PUSH
13134: EMPTY
13135: LIST
13136: LIST
13137: PUSH
13138: LD_INT 25
13140: PUSH
13141: LD_INT 4
13143: PUSH
13144: EMPTY
13145: LIST
13146: LIST
13147: PUSH
13148: LD_INT 21
13150: PUSH
13151: LD_INT 1
13153: PUSH
13154: EMPTY
13155: LIST
13156: LIST
13157: PUSH
13158: LD_INT 26
13160: PUSH
13161: LD_INT 1
13163: PUSH
13164: EMPTY
13165: LIST
13166: LIST
13167: PUSH
13168: EMPTY
13169: LIST
13170: LIST
13171: LIST
13172: LIST
13173: LIST
13174: PPUSH
13175: CALL_OW 69
13179: PUSH
13180: LD_EXP 20
13184: PUSH
13185: LD_EXP 19
13189: PUSH
13190: LD_EXP 51
13194: PUSH
13195: LD_EXP 39
13199: PUSH
13200: LD_EXP 49
13204: PUSH
13205: LD_EXP 48
13209: PUSH
13210: EMPTY
13211: LIST
13212: LIST
13213: LIST
13214: LIST
13215: LIST
13216: LIST
13217: DIFF
13218: ST_TO_ADDR
// if not speaker then
13219: LD_VAR 0 1
13223: NOT
13224: IFFALSE 13228
// exit ;
13226: GO 13307
// DialogueOn ;
13228: CALL_OW 6
// Say ( speaker [ speaker ] , DArtefTechnologyRu-RSci1-1 ) ;
13232: LD_VAR 0 1
13236: PUSH
13237: LD_VAR 0 1
13241: ARRAY
13242: PPUSH
13243: LD_STRING DArtefTechnologyRu-RSci1-1
13245: PPUSH
13246: CALL_OW 88
// if IsOk ( Burlak ) then
13250: LD_EXP 51
13254: PPUSH
13255: CALL_OW 302
13259: IFFALSE 13273
// Say ( Burlak , DArtefTechnologyRu-Bur-1 ) ;
13261: LD_EXP 51
13265: PPUSH
13266: LD_STRING DArtefTechnologyRu-Bur-1
13268: PPUSH
13269: CALL_OW 88
// Say ( speaker [ speaker ] , DArtefTechnologyRu-RSci1-2 ) ;
13273: LD_VAR 0 1
13277: PUSH
13278: LD_VAR 0 1
13282: ARRAY
13283: PPUSH
13284: LD_STRING DArtefTechnologyRu-RSci1-2
13286: PPUSH
13287: CALL_OW 88
// Say ( JMM , DArtefTechnologyRu-JMM-1 ) ;
13291: LD_EXP 19
13295: PPUSH
13296: LD_STRING DArtefTechnologyRu-JMM-1
13298: PPUSH
13299: CALL_OW 88
// DialogueOff ;
13303: CALL_OW 7
// end ;
13307: PPOPN 1
13309: END
// every 0 0$1 trigger GetTech ( tech_Artifact , 7 ) = state_researched and GetSide ( alien ) = 7 do var speaker ;
13310: LD_INT 24
13312: PPUSH
13313: LD_INT 7
13315: PPUSH
13316: CALL_OW 321
13320: PUSH
13321: LD_INT 2
13323: EQUAL
13324: PUSH
13325: LD_INT 1
13327: PPUSH
13328: CALL_OW 255
13332: PUSH
13333: LD_INT 7
13335: EQUAL
13336: AND
13337: IFFALSE 13505
13339: GO 13341
13341: DISABLE
13342: LD_INT 0
13344: PPUSH
// begin if Denis then
13345: LD_EXP 25
13349: IFFALSE 13366
// speaker := [ Denis ] else
13351: LD_ADDR_VAR 0 1
13355: PUSH
13356: LD_EXP 25
13360: PUSH
13361: EMPTY
13362: LIST
13363: ST_TO_ADDR
13364: GO 13472
// speaker := FilterAllUnits ( [ [ f_side , 7 ] , [ f_nation , 1 ] , [ f_class , 4 ] , [ f_type , unit_human ] , [ f_sex , sex_male ] ] ) diff [ Roth , JMM , Burlak , Titov , Kuzmov , Kovalyuk ] ;
13366: LD_ADDR_VAR 0 1
13370: PUSH
13371: LD_INT 22
13373: PUSH
13374: LD_INT 7
13376: PUSH
13377: EMPTY
13378: LIST
13379: LIST
13380: PUSH
13381: LD_INT 23
13383: PUSH
13384: LD_INT 1
13386: PUSH
13387: EMPTY
13388: LIST
13389: LIST
13390: PUSH
13391: LD_INT 25
13393: PUSH
13394: LD_INT 4
13396: PUSH
13397: EMPTY
13398: LIST
13399: LIST
13400: PUSH
13401: LD_INT 21
13403: PUSH
13404: LD_INT 1
13406: PUSH
13407: EMPTY
13408: LIST
13409: LIST
13410: PUSH
13411: LD_INT 26
13413: PUSH
13414: LD_INT 1
13416: PUSH
13417: EMPTY
13418: LIST
13419: LIST
13420: PUSH
13421: EMPTY
13422: LIST
13423: LIST
13424: LIST
13425: LIST
13426: LIST
13427: PPUSH
13428: CALL_OW 69
13432: PUSH
13433: LD_EXP 20
13437: PUSH
13438: LD_EXP 19
13442: PUSH
13443: LD_EXP 51
13447: PUSH
13448: LD_EXP 39
13452: PUSH
13453: LD_EXP 49
13457: PUSH
13458: LD_EXP 48
13462: PUSH
13463: EMPTY
13464: LIST
13465: LIST
13466: LIST
13467: LIST
13468: LIST
13469: LIST
13470: DIFF
13471: ST_TO_ADDR
// if not speaker then
13472: LD_VAR 0 1
13476: NOT
13477: IFFALSE 13481
// exit ;
13479: GO 13505
// DialogueOn ;
13481: CALL_OW 6
// Say ( speaker [ 1 ] , DArtefTechnologyArStart-Sci1-1 ) ;
13485: LD_VAR 0 1
13489: PUSH
13490: LD_INT 1
13492: ARRAY
13493: PPUSH
13494: LD_STRING DArtefTechnologyArStart-Sci1-1
13496: PPUSH
13497: CALL_OW 88
// DialogueOff ;
13501: CALL_OW 7
// end ;
13505: PPOPN 1
13507: END
// every 0 0$1 trigger artifactIIIResearched do var speaker ;
13508: LD_EXP 14
13512: IFFALSE 13793
13514: GO 13516
13516: DISABLE
13517: LD_INT 0
13519: PPUSH
// begin speaker := FilterAllUnits ( [ [ f_side , 7 ] , [ f_nation , 3 ] , [ f_class , 4 ] , [ f_type , unit_human ] , [ f_sex , sex_male ] ] ) diff [ Roth , JMM , Burlak , Titov , Kuzmov , Kovalyuk ] ;
13520: LD_ADDR_VAR 0 1
13524: PUSH
13525: LD_INT 22
13527: PUSH
13528: LD_INT 7
13530: PUSH
13531: EMPTY
13532: LIST
13533: LIST
13534: PUSH
13535: LD_INT 23
13537: PUSH
13538: LD_INT 3
13540: PUSH
13541: EMPTY
13542: LIST
13543: LIST
13544: PUSH
13545: LD_INT 25
13547: PUSH
13548: LD_INT 4
13550: PUSH
13551: EMPTY
13552: LIST
13553: LIST
13554: PUSH
13555: LD_INT 21
13557: PUSH
13558: LD_INT 1
13560: PUSH
13561: EMPTY
13562: LIST
13563: LIST
13564: PUSH
13565: LD_INT 26
13567: PUSH
13568: LD_INT 1
13570: PUSH
13571: EMPTY
13572: LIST
13573: LIST
13574: PUSH
13575: EMPTY
13576: LIST
13577: LIST
13578: LIST
13579: LIST
13580: LIST
13581: PPUSH
13582: CALL_OW 69
13586: PUSH
13587: LD_EXP 20
13591: PUSH
13592: LD_EXP 19
13596: PUSH
13597: LD_EXP 51
13601: PUSH
13602: LD_EXP 39
13606: PUSH
13607: LD_EXP 49
13611: PUSH
13612: LD_EXP 48
13616: PUSH
13617: EMPTY
13618: LIST
13619: LIST
13620: LIST
13621: LIST
13622: LIST
13623: LIST
13624: DIFF
13625: ST_TO_ADDR
// if not speaker then
13626: LD_VAR 0 1
13630: NOT
13631: IFFALSE 13635
// exit ;
13633: GO 13793
// DialogueOn ;
13635: CALL_OW 6
// Say ( speaker [ 1 ] , DArtefTechnologyAr-RSci1-1 ) ;
13639: LD_VAR 0 1
13643: PUSH
13644: LD_INT 1
13646: ARRAY
13647: PPUSH
13648: LD_STRING DArtefTechnologyAr-RSci1-1
13650: PPUSH
13651: CALL_OW 88
// Say ( JMM , DArtefTechnologyAr-JMM-1 ) ;
13655: LD_EXP 19
13659: PPUSH
13660: LD_STRING DArtefTechnologyAr-JMM-1
13662: PPUSH
13663: CALL_OW 88
// Say ( speaker [ 1 ] , DArtefTechnologyAr-RSci1-2 ) ;
13667: LD_VAR 0 1
13671: PUSH
13672: LD_INT 1
13674: ARRAY
13675: PPUSH
13676: LD_STRING DArtefTechnologyAr-RSci1-2
13678: PPUSH
13679: CALL_OW 88
// Say ( JMM , DArtefTechnologyAr-JMM-2 ) ;
13683: LD_EXP 19
13687: PPUSH
13688: LD_STRING DArtefTechnologyAr-JMM-2
13690: PPUSH
13691: CALL_OW 88
// Say ( speaker [ 1 ] , DArtefTechnologyAr-RSci1-3 ) ;
13695: LD_VAR 0 1
13699: PUSH
13700: LD_INT 1
13702: ARRAY
13703: PPUSH
13704: LD_STRING DArtefTechnologyAr-RSci1-3
13706: PPUSH
13707: CALL_OW 88
// Say ( JMM , DArtefTechnologyAr-JMM-3 ) ;
13711: LD_EXP 19
13715: PPUSH
13716: LD_STRING DArtefTechnologyAr-JMM-3
13718: PPUSH
13719: CALL_OW 88
// Say ( speaker [ 1 ] , DArtefTechnologyAr-RSci1-4 ) ;
13723: LD_VAR 0 1
13727: PUSH
13728: LD_INT 1
13730: ARRAY
13731: PPUSH
13732: LD_STRING DArtefTechnologyAr-RSci1-4
13734: PPUSH
13735: CALL_OW 88
// if IsOk ( Burlak ) then
13739: LD_EXP 51
13743: PPUSH
13744: CALL_OW 302
13748: IFFALSE 13762
// Say ( Burlak , DArtefTechnologyAr-Bur-4 ) ;
13750: LD_EXP 51
13754: PPUSH
13755: LD_STRING DArtefTechnologyAr-Bur-4
13757: PPUSH
13758: CALL_OW 88
// Say ( JMM , DArtefTechnologyAr-JMM-4 ) ;
13762: LD_EXP 19
13766: PPUSH
13767: LD_STRING DArtefTechnologyAr-JMM-4
13769: PPUSH
13770: CALL_OW 88
// DialogueOff ;
13774: CALL_OW 7
// wait ( 0 0$45 ) ;
13778: LD_INT 1575
13780: PPUSH
13781: CALL_OW 67
// spawnOmar := true ;
13785: LD_ADDR_EXP 11
13789: PUSH
13790: LD_INT 1
13792: ST_TO_ADDR
// end ;
13793: PPOPN 1
13795: END
// every 0 0$1 trigger spawnOmar do
13796: LD_EXP 11
13800: IFFALSE 14180
13802: GO 13804
13804: DISABLE
// begin PrepareOmarAli ;
13805: CALL 7201 0 0
// if not HasTask ( Omar ) then
13809: LD_EXP 55
13813: PPUSH
13814: CALL_OW 314
13818: NOT
13819: IFFALSE 13836
// ComMoveXY ( Omar , 252 , 220 ) ;
13821: LD_EXP 55
13825: PPUSH
13826: LD_INT 252
13828: PPUSH
13829: LD_INT 220
13831: PPUSH
13832: CALL_OW 111
// if not Omar then
13836: LD_EXP 55
13840: NOT
13841: IFFALSE 13845
// exit ;
13843: GO 14180
// repeat wait ( 0 0$1 ) ;
13845: LD_INT 35
13847: PPUSH
13848: CALL_OW 67
// if not HasTask ( Omar ) and GetDistUnitXY ( Omar , 252 , 220 ) > 6 then
13852: LD_EXP 55
13856: PPUSH
13857: CALL_OW 314
13861: NOT
13862: PUSH
13863: LD_EXP 55
13867: PPUSH
13868: LD_INT 252
13870: PPUSH
13871: LD_INT 220
13873: PPUSH
13874: CALL_OW 297
13878: PUSH
13879: LD_INT 6
13881: GREATER
13882: AND
13883: IFFALSE 13900
// ComMoveXY ( Omar , 252 , 220 ) ;
13885: LD_EXP 55
13889: PPUSH
13890: LD_INT 252
13892: PPUSH
13893: LD_INT 220
13895: PPUSH
13896: CALL_OW 111
// until See ( 7 , Omar ) ;
13900: LD_INT 7
13902: PPUSH
13903: LD_EXP 55
13907: PPUSH
13908: CALL_OW 292
13912: IFFALSE 13845
// CenterNowOnUnits ( Omar ) ;
13914: LD_EXP 55
13918: PPUSH
13919: CALL_OW 87
// DialogueOn ;
13923: CALL_OW 6
// Say ( Omar , DOmar-Omar-1 ) ;
13927: LD_EXP 55
13931: PPUSH
13932: LD_STRING DOmar-Omar-1
13934: PPUSH
13935: CALL_OW 88
// Say ( JMM , DOmar-JMM-1 ) ;
13939: LD_EXP 19
13943: PPUSH
13944: LD_STRING DOmar-JMM-1
13946: PPUSH
13947: CALL_OW 88
// Say ( Omar , DOmar-Omar-2 ) ;
13951: LD_EXP 55
13955: PPUSH
13956: LD_STRING DOmar-Omar-2
13958: PPUSH
13959: CALL_OW 88
// Say ( JMM , DOmar-JMM-2 ) ;
13963: LD_EXP 19
13967: PPUSH
13968: LD_STRING DOmar-JMM-2
13970: PPUSH
13971: CALL_OW 88
// Say ( Omar , DOmar-Omar-3 ) ;
13975: LD_EXP 55
13979: PPUSH
13980: LD_STRING DOmar-Omar-3
13982: PPUSH
13983: CALL_OW 88
// if IsOk ( Burlak ) then
13987: LD_EXP 51
13991: PPUSH
13992: CALL_OW 302
13996: IFFALSE 14012
// Say ( Burlak , DOmar-Bur-3 ) else
13998: LD_EXP 51
14002: PPUSH
14003: LD_STRING DOmar-Bur-3
14005: PPUSH
14006: CALL_OW 88
14010: GO 14024
// Say ( JMM , DOmar-JMM-3 ) ;
14012: LD_EXP 19
14016: PPUSH
14017: LD_STRING DOmar-JMM-3
14019: PPUSH
14020: CALL_OW 88
// Say ( Omar , DOmar-Omar-4 ) ;
14024: LD_EXP 55
14028: PPUSH
14029: LD_STRING DOmar-Omar-4
14031: PPUSH
14032: CALL_OW 88
// case Query ( QAccept ) of 1 :
14036: LD_STRING QAccept
14038: PPUSH
14039: CALL_OW 97
14043: PUSH
14044: LD_INT 1
14046: DOUBLE
14047: EQUAL
14048: IFTRUE 14052
14050: GO 14088
14052: POP
// begin Say ( JMM , DQrAccept#1-JMM-1 ) ;
14053: LD_EXP 19
14057: PPUSH
14058: LD_STRING DQrAccept#1-JMM-1
14060: PPUSH
14061: CALL_OW 88
// SetSide ( Omar , 7 ) ;
14065: LD_EXP 55
14069: PPUSH
14070: LD_INT 7
14072: PPUSH
14073: CALL_OW 235
// ComStop ( Omar ) ;
14077: LD_EXP 55
14081: PPUSH
14082: CALL_OW 141
// end ; 2 :
14086: GO 14137
14088: LD_INT 2
14090: DOUBLE
14091: EQUAL
14092: IFTRUE 14096
14094: GO 14136
14096: POP
// begin if IsOk ( Burlak ) then
14097: LD_EXP 51
14101: PPUSH
14102: CALL_OW 302
14106: IFFALSE 14122
// Say ( Burlak , DQrAccept#2-Bur-1 ) else
14108: LD_EXP 51
14112: PPUSH
14113: LD_STRING DQrAccept#2-Bur-1
14115: PPUSH
14116: CALL_OW 88
14120: GO 14134
// Say ( JMM , DQrAccept#2-JMM-1 ) ;
14122: LD_EXP 19
14126: PPUSH
14127: LD_STRING DQrAccept#2-JMM-1
14129: PPUSH
14130: CALL_OW 88
// end ; end ;
14134: GO 14137
14136: POP
// DialogueOff ;
14137: CALL_OW 7
// if GetSide ( Omar ) = 7 then
14141: LD_EXP 55
14145: PPUSH
14146: CALL_OW 255
14150: PUSH
14151: LD_INT 7
14153: EQUAL
14154: IFFALSE 14165
// begin SetAchievement ( ACH_OMAR ) ;
14156: LD_STRING ACH_OMAR
14158: PPUSH
14159: CALL_OW 543
// exit ;
14163: GO 14180
// end ; ComMoveXY ( Omar , 202 , 115 ) ;
14165: LD_EXP 55
14169: PPUSH
14170: LD_INT 202
14172: PPUSH
14173: LD_INT 115
14175: PPUSH
14176: CALL_OW 111
// end ;
14180: END
// every 0 0$1 trigger GetDistUnitXY ( Omar , 200 , 98 ) < 40 and russianDestroyed do
14181: LD_EXP 55
14185: PPUSH
14186: LD_INT 200
14188: PPUSH
14189: LD_INT 98
14191: PPUSH
14192: CALL_OW 297
14196: PUSH
14197: LD_INT 40
14199: LESS
14200: PUSH
14201: LD_EXP 2
14205: AND
14206: IFFALSE 14424
14208: GO 14210
14210: DISABLE
// begin SetSide ( Omar , 5 ) ;
14211: LD_EXP 55
14215: PPUSH
14216: LD_INT 5
14218: PPUSH
14219: CALL_OW 235
// if IsInUnit ( Omar ) then
14223: LD_EXP 55
14227: PPUSH
14228: CALL_OW 310
14232: IFFALSE 14243
// ComExitVehicle ( Omar ) ;
14234: LD_EXP 55
14238: PPUSH
14239: CALL_OW 121
// if IsInUnit ( Omar ) then
14243: LD_EXP 55
14247: PPUSH
14248: CALL_OW 310
14252: IFFALSE 14263
// ComExitBuilding ( Omar ) ;
14254: LD_EXP 55
14258: PPUSH
14259: CALL_OW 122
// wait ( 0 0$1 ) ;
14263: LD_INT 35
14265: PPUSH
14266: CALL_OW 67
// ComMoveXY ( Omar , 203 , 120 ) ;
14270: LD_EXP 55
14274: PPUSH
14275: LD_INT 203
14277: PPUSH
14278: LD_INT 120
14280: PPUSH
14281: CALL_OW 111
// repeat wait ( 0 0$1 ) ;
14285: LD_INT 35
14287: PPUSH
14288: CALL_OW 67
// until IsSelected ( Omar ) or GetDistUnitXY ( Omar , 203 , 120 ) < 6 ;
14292: LD_EXP 55
14296: PPUSH
14297: CALL_OW 306
14301: PUSH
14302: LD_EXP 55
14306: PPUSH
14307: LD_INT 203
14309: PPUSH
14310: LD_INT 120
14312: PPUSH
14313: CALL_OW 297
14317: PUSH
14318: LD_INT 6
14320: LESS
14321: OR
14322: IFFALSE 14285
// CenterNowOnUnits ( Omar ) ;
14324: LD_EXP 55
14328: PPUSH
14329: CALL_OW 87
// DialogueOn ;
14333: CALL_OW 6
// Say ( JMM , DOmarContam-JMM-1 ) ;
14337: LD_EXP 19
14341: PPUSH
14342: LD_STRING DOmarContam-JMM-1
14344: PPUSH
14345: CALL_OW 88
// Say ( Omar , DOmarContam-Omar-1 ) ;
14349: LD_EXP 55
14353: PPUSH
14354: LD_STRING DOmarContam-Omar-1
14356: PPUSH
14357: CALL_OW 88
// Say ( JMM , DOmarContam-JMM-2 ) ;
14361: LD_EXP 19
14365: PPUSH
14366: LD_STRING DOmarContam-JMM-2
14368: PPUSH
14369: CALL_OW 88
// DialogueOff ;
14373: CALL_OW 7
// SetAttitude ( 5 , 7 , att_enemy , true ) ;
14377: LD_INT 5
14379: PPUSH
14380: LD_INT 7
14382: PPUSH
14383: LD_INT 2
14385: PPUSH
14386: LD_INT 1
14388: PPUSH
14389: CALL_OW 80
// repeat wait ( 0 0$3 ) ;
14393: LD_INT 105
14395: PPUSH
14396: CALL_OW 67
// until IsAt ( Omar , 203 , 120 ) ;
14400: LD_EXP 55
14404: PPUSH
14405: LD_INT 203
14407: PPUSH
14408: LD_INT 120
14410: PPUSH
14411: CALL_OW 307
14415: IFFALSE 14393
// YouLost ( MothContaminate ) ;
14417: LD_STRING MothContaminate
14419: PPUSH
14420: CALL_OW 104
// end ;
14424: END
// every 0 0$2 trigger not americanDestroyed and FilterAllUnits ( [ [ f_side , 1 ] , [ f_weapon , us_siberium_rocket ] ] ) do
14425: LD_EXP 4
14429: NOT
14430: PUSH
14431: LD_INT 22
14433: PUSH
14434: LD_INT 1
14436: PUSH
14437: EMPTY
14438: LIST
14439: LIST
14440: PUSH
14441: LD_INT 34
14443: PUSH
14444: LD_INT 8
14446: PUSH
14447: EMPTY
14448: LIST
14449: LIST
14450: PUSH
14451: EMPTY
14452: LIST
14453: LIST
14454: PPUSH
14455: CALL_OW 69
14459: AND
14460: IFFALSE 14579
14462: GO 14464
14464: DISABLE
// begin wait ( 0 0$5 ) ;
14465: LD_INT 175
14467: PPUSH
14468: CALL_OW 67
// if not IsOk ( Powell ) or not FilterAllUnits ( [ [ f_side , 1 ] , [ f_weapon , us_siberium_rocket ] ] ) then
14472: LD_EXP 54
14476: PPUSH
14477: CALL_OW 302
14481: NOT
14482: PUSH
14483: LD_INT 22
14485: PUSH
14486: LD_INT 1
14488: PUSH
14489: EMPTY
14490: LIST
14491: LIST
14492: PUSH
14493: LD_INT 34
14495: PUSH
14496: LD_INT 8
14498: PUSH
14499: EMPTY
14500: LIST
14501: LIST
14502: PUSH
14503: EMPTY
14504: LIST
14505: LIST
14506: PPUSH
14507: CALL_OW 69
14511: NOT
14512: OR
14513: IFFALSE 14517
// exit ;
14515: GO 14579
// DialogueOn ;
14517: CALL_OW 6
// SayRadio ( Powell , DWinAmericans-Pow-1 ) ;
14521: LD_EXP 54
14525: PPUSH
14526: LD_STRING DWinAmericans-Pow-1
14528: PPUSH
14529: CALL_OW 94
// if IsOk ( Burlak ) then
14533: LD_EXP 51
14537: PPUSH
14538: CALL_OW 302
14542: IFFALSE 14556
// Say ( Burlak , DWinAmericans-Bur-1 ) ;
14544: LD_EXP 51
14548: PPUSH
14549: LD_STRING DWinAmericans-Bur-1
14551: PPUSH
14552: CALL_OW 88
// Say ( JMM , DWinAmericans-JMM-1 ) ;
14556: LD_EXP 19
14560: PPUSH
14561: LD_STRING DWinAmericans-JMM-1
14563: PPUSH
14564: CALL_OW 88
// DialogueOff ;
14568: CALL_OW 7
// YouLost ( AmBomb ) ;
14572: LD_STRING AmBomb
14574: PPUSH
14575: CALL_OW 104
// end ;
14579: END
// every 0 0$2 trigger not russianDestroyed and FilterAllUnits ( [ [ f_side , 3 ] , [ f_weapon , ru_siberium_rocket ] ] ) do
14580: LD_EXP 2
14584: NOT
14585: PUSH
14586: LD_INT 22
14588: PUSH
14589: LD_INT 3
14591: PUSH
14592: EMPTY
14593: LIST
14594: LIST
14595: PUSH
14596: LD_INT 34
14598: PUSH
14599: LD_INT 48
14601: PUSH
14602: EMPTY
14603: LIST
14604: LIST
14605: PUSH
14606: EMPTY
14607: LIST
14608: LIST
14609: PPUSH
14610: CALL_OW 69
14614: AND
14615: IFFALSE 14734
14617: GO 14619
14619: DISABLE
// begin wait ( 0 0$5 ) ;
14620: LD_INT 175
14622: PPUSH
14623: CALL_OW 67
// if not IsOk ( Platonov ) or not FilterAllUnits ( [ [ f_side , 3 ] , [ f_weapon , ru_siberium_rocket ] ] ) then
14627: LD_EXP 58
14631: PPUSH
14632: CALL_OW 302
14636: NOT
14637: PUSH
14638: LD_INT 22
14640: PUSH
14641: LD_INT 3
14643: PUSH
14644: EMPTY
14645: LIST
14646: LIST
14647: PUSH
14648: LD_INT 34
14650: PUSH
14651: LD_INT 48
14653: PUSH
14654: EMPTY
14655: LIST
14656: LIST
14657: PUSH
14658: EMPTY
14659: LIST
14660: LIST
14661: PPUSH
14662: CALL_OW 69
14666: NOT
14667: OR
14668: IFFALSE 14672
// exit ;
14670: GO 14734
// DialogueOn ;
14672: CALL_OW 6
// SayRadio ( Platonov , DWinRussians-Pla-1 ) ;
14676: LD_EXP 58
14680: PPUSH
14681: LD_STRING DWinRussians-Pla-1
14683: PPUSH
14684: CALL_OW 94
// if IsOk ( Burlak ) then
14688: LD_EXP 51
14692: PPUSH
14693: CALL_OW 302
14697: IFFALSE 14711
// Say ( Burlak , DWinRussians-Bur-1 ) ;
14699: LD_EXP 51
14703: PPUSH
14704: LD_STRING DWinRussians-Bur-1
14706: PPUSH
14707: CALL_OW 88
// Say ( JMM , DWinRussians-JMM-1 ) ;
14711: LD_EXP 19
14715: PPUSH
14716: LD_STRING DWinRussians-JMM-1
14718: PPUSH
14719: CALL_OW 88
// DialogueOff ;
14723: CALL_OW 7
// YouLost ( RuBomb ) ;
14727: LD_STRING RuBomb
14729: PPUSH
14730: CALL_OW 104
// end ;
14734: END
// every 0 0$20 trigger FilterUnitsInArea ( powellBase , [ f_side , 7 ] ) and not americanDestroyed do
14735: LD_INT 7
14737: PPUSH
14738: LD_INT 22
14740: PUSH
14741: LD_INT 7
14743: PUSH
14744: EMPTY
14745: LIST
14746: LIST
14747: PPUSH
14748: CALL_OW 70
14752: PUSH
14753: LD_EXP 4
14757: NOT
14758: AND
14759: IFFALSE 14788
14761: GO 14763
14763: DISABLE
// begin SayRadio ( Powell , DSurrenderAmericans-Pow-1 ) ;
14764: LD_EXP 54
14768: PPUSH
14769: LD_STRING DSurrenderAmericans-Pow-1
14771: PPUSH
14772: CALL_OW 94
// Say ( JMM , DSurrenderAmericans-JMM-1 ) ;
14776: LD_EXP 19
14780: PPUSH
14781: LD_STRING DSurrenderAmericans-JMM-1
14783: PPUSH
14784: CALL_OW 88
// end ;
14788: END
// every 0 0$20 trigger FilterUnitsInArea ( russianBaseArea , [ f_side , 7 ] ) and not russianDestroyed and Burlak do
14789: LD_INT 2
14791: PPUSH
14792: LD_INT 22
14794: PUSH
14795: LD_INT 7
14797: PUSH
14798: EMPTY
14799: LIST
14800: LIST
14801: PPUSH
14802: CALL_OW 70
14806: PUSH
14807: LD_EXP 2
14811: NOT
14812: AND
14813: PUSH
14814: LD_EXP 51
14818: AND
14819: IFFALSE 14848
14821: GO 14823
14823: DISABLE
// begin SayRadio ( Platonov , DSurrenderRussians-Pla-1 ) ;
14824: LD_EXP 58
14828: PPUSH
14829: LD_STRING DSurrenderRussians-Pla-1
14831: PPUSH
14832: CALL_OW 94
// Say ( Burlak , DSurrenderRussians-Bur-1 ) ;
14836: LD_EXP 51
14840: PPUSH
14841: LD_STRING DSurrenderRussians-Bur-1
14843: PPUSH
14844: CALL_OW 88
// end ;
14848: END
// every 0 0$2 + 0 0$5 trigger americanDestroyed do var i , tmp , speaker ;
14849: LD_EXP 4
14853: IFFALSE 15236
14855: GO 14857
14857: DISABLE
14858: LD_INT 0
14860: PPUSH
14861: PPUSH
14862: PPUSH
// begin MC_Kill ( 4 ) ;
14863: LD_INT 4
14865: PPUSH
14866: CALL 21647 0 1
// SetAttitude ( 1 , 7 , att_friend , true ) ;
14870: LD_INT 1
14872: PPUSH
14873: LD_INT 7
14875: PPUSH
14876: LD_INT 1
14878: PPUSH
14879: LD_INT 1
14881: PPUSH
14882: CALL_OW 80
// speaker := FilterAllUnits ( [ [ f_side , 1 ] , [ f_sex , sex_male ] , [ f_nation , 1 ] ] ) diff [ Powell , Gladstone , Cyrus , Bobby , Gary , Houten ] ;
14886: LD_ADDR_VAR 0 3
14890: PUSH
14891: LD_INT 22
14893: PUSH
14894: LD_INT 1
14896: PUSH
14897: EMPTY
14898: LIST
14899: LIST
14900: PUSH
14901: LD_INT 26
14903: PUSH
14904: LD_INT 1
14906: PUSH
14907: EMPTY
14908: LIST
14909: LIST
14910: PUSH
14911: LD_INT 23
14913: PUSH
14914: LD_INT 1
14916: PUSH
14917: EMPTY
14918: LIST
14919: LIST
14920: PUSH
14921: EMPTY
14922: LIST
14923: LIST
14924: LIST
14925: PPUSH
14926: CALL_OW 69
14930: PUSH
14931: LD_EXP 54
14935: PUSH
14936: LD_EXP 27
14940: PUSH
14941: LD_EXP 24
14945: PUSH
14946: LD_EXP 23
14950: PUSH
14951: LD_EXP 30
14955: PUSH
14956: LD_EXP 28
14960: PUSH
14961: EMPTY
14962: LIST
14963: LIST
14964: LIST
14965: LIST
14966: LIST
14967: LIST
14968: DIFF
14969: ST_TO_ADDR
// if speaker then
14970: LD_VAR 0 3
14974: IFFALSE 15000
// begin DialogueOn ;
14976: CALL_OW 6
// SayRadio ( speaker [ 1 ] , DSurrenderAmericans-Sol1-1a ) ;
14980: LD_VAR 0 3
14984: PUSH
14985: LD_INT 1
14987: ARRAY
14988: PPUSH
14989: LD_STRING DSurrenderAmericans-Sol1-1a
14991: PPUSH
14992: CALL_OW 94
// DialogueOff ;
14996: CALL_OW 7
// end ; americanCapitulated := true ;
15000: LD_ADDR_EXP 6
15004: PUSH
15005: LD_INT 1
15007: ST_TO_ADDR
// tmp := FilterAllUnits ( [ [ f_side , 1 ] , [ f_type , unit_human ] ] ) ^ FilterAllUnits ( [ [ f_side , 1 ] , [ f_type , unit_vehicle ] , [ control_manual ] ] ) ;
15008: LD_ADDR_VAR 0 2
15012: PUSH
15013: LD_INT 22
15015: PUSH
15016: LD_INT 1
15018: PUSH
15019: EMPTY
15020: LIST
15021: LIST
15022: PUSH
15023: LD_INT 21
15025: PUSH
15026: LD_INT 1
15028: PUSH
15029: EMPTY
15030: LIST
15031: LIST
15032: PUSH
15033: EMPTY
15034: LIST
15035: LIST
15036: PPUSH
15037: CALL_OW 69
15041: PUSH
15042: LD_INT 22
15044: PUSH
15045: LD_INT 1
15047: PUSH
15048: EMPTY
15049: LIST
15050: LIST
15051: PUSH
15052: LD_INT 21
15054: PUSH
15055: LD_INT 2
15057: PUSH
15058: EMPTY
15059: LIST
15060: LIST
15061: PUSH
15062: LD_INT 1
15064: PUSH
15065: EMPTY
15066: LIST
15067: PUSH
15068: EMPTY
15069: LIST
15070: LIST
15071: LIST
15072: PPUSH
15073: CALL_OW 69
15077: ADD
15078: ST_TO_ADDR
// if tmp then
15079: LD_VAR 0 2
15083: IFFALSE 15236
// repeat wait ( 0 0$1 ) ;
15085: LD_INT 35
15087: PPUSH
15088: CALL_OW 67
// for i in tmp do
15092: LD_ADDR_VAR 0 1
15096: PUSH
15097: LD_VAR 0 2
15101: PUSH
15102: FOR_IN
15103: IFFALSE 15185
// begin if IsInUnit ( i ) and GetType ( IsInUnit ( i ) ) = unit_building then
15105: LD_VAR 0 1
15109: PPUSH
15110: CALL_OW 310
15114: PUSH
15115: LD_VAR 0 1
15119: PPUSH
15120: CALL_OW 310
15124: PPUSH
15125: CALL_OW 247
15129: PUSH
15130: LD_INT 3
15132: EQUAL
15133: AND
15134: IFFALSE 15145
// ComExitBuilding ( i ) ;
15136: LD_VAR 0 1
15140: PPUSH
15141: CALL_OW 122
// AddComMoveXY ( i , 122 , 242 ) ;
15145: LD_VAR 0 1
15149: PPUSH
15150: LD_INT 122
15152: PPUSH
15153: LD_INT 242
15155: PPUSH
15156: CALL_OW 171
// if IsInArea ( i , americanEscape ) then
15160: LD_VAR 0 1
15164: PPUSH
15165: LD_INT 35
15167: PPUSH
15168: CALL_OW 308
15172: IFFALSE 15183
// RemoveUnit ( i ) ;
15174: LD_VAR 0 1
15178: PPUSH
15179: CALL_OW 64
// end ;
15183: GO 15102
15185: POP
15186: POP
// until not FilterAllUnits ( [ [ f_side , 1 ] , [ f_or , [ f_type , unit_human ] , [ f_control , control_manual ] ] ] ) ;
15187: LD_INT 22
15189: PUSH
15190: LD_INT 1
15192: PUSH
15193: EMPTY
15194: LIST
15195: LIST
15196: PUSH
15197: LD_INT 2
15199: PUSH
15200: LD_INT 21
15202: PUSH
15203: LD_INT 1
15205: PUSH
15206: EMPTY
15207: LIST
15208: LIST
15209: PUSH
15210: LD_INT 33
15212: PUSH
15213: LD_INT 1
15215: PUSH
15216: EMPTY
15217: LIST
15218: LIST
15219: PUSH
15220: EMPTY
15221: LIST
15222: LIST
15223: LIST
15224: PUSH
15225: EMPTY
15226: LIST
15227: LIST
15228: PPUSH
15229: CALL_OW 69
15233: NOT
15234: IFFALSE 15085
// end ;
15236: PPOPN 3
15238: END
// every 0 0$2 + 0 0$5 trigger russianDestroyed do var i , tmp , speaker ;
15239: LD_EXP 2
15243: IFFALSE 15644
15245: GO 15247
15247: DISABLE
15248: LD_INT 0
15250: PPUSH
15251: PPUSH
15252: PPUSH
// begin repeat wait ( 0 0$1 ) ;
15253: LD_INT 35
15255: PPUSH
15256: CALL_OW 67
// until IsDead ( Yakotich ) ;
15260: LD_EXP 59
15264: PPUSH
15265: CALL_OW 301
15269: IFFALSE 15253
// MC_Kill ( 2 ) ;
15271: LD_INT 2
15273: PPUSH
15274: CALL 21647 0 1
// SetAttitude ( 3 , 7 , att_friend , true ) ;
15278: LD_INT 3
15280: PPUSH
15281: LD_INT 7
15283: PPUSH
15284: LD_INT 1
15286: PPUSH
15287: LD_INT 1
15289: PPUSH
15290: CALL_OW 80
// speaker := FilterAllUnits ( [ [ f_side , 3 ] , [ f_sex , sex_male ] , [ f_nation , 3 ] ] ) diff [ Platonov , Yakotich ] ;
15294: LD_ADDR_VAR 0 3
15298: PUSH
15299: LD_INT 22
15301: PUSH
15302: LD_INT 3
15304: PUSH
15305: EMPTY
15306: LIST
15307: LIST
15308: PUSH
15309: LD_INT 26
15311: PUSH
15312: LD_INT 1
15314: PUSH
15315: EMPTY
15316: LIST
15317: LIST
15318: PUSH
15319: LD_INT 23
15321: PUSH
15322: LD_INT 3
15324: PUSH
15325: EMPTY
15326: LIST
15327: LIST
15328: PUSH
15329: EMPTY
15330: LIST
15331: LIST
15332: LIST
15333: PPUSH
15334: CALL_OW 69
15338: PUSH
15339: LD_EXP 58
15343: PUSH
15344: LD_EXP 59
15348: PUSH
15349: EMPTY
15350: LIST
15351: LIST
15352: DIFF
15353: ST_TO_ADDR
// if speaker then
15354: LD_VAR 0 3
15358: IFFALSE 15408
// begin DialogueOn ;
15360: CALL_OW 6
// if Burlak then
15364: LD_EXP 51
15368: IFFALSE 15388
// SayRadio ( speaker [ 1 ] , DSurrenderRussians-RSol1-1 ) else
15370: LD_VAR 0 3
15374: PUSH
15375: LD_INT 1
15377: ARRAY
15378: PPUSH
15379: LD_STRING DSurrenderRussians-RSol1-1
15381: PPUSH
15382: CALL_OW 94
15386: GO 15404
// SayRadio ( speaker [ 1 ] , DSurrenderRussians-RSol1-1a ) ;
15388: LD_VAR 0 3
15392: PUSH
15393: LD_INT 1
15395: ARRAY
15396: PPUSH
15397: LD_STRING DSurrenderRussians-RSol1-1a
15399: PPUSH
15400: CALL_OW 94
// DialogueOff ;
15404: CALL_OW 7
// end ; russianCapitulated := true ;
15408: LD_ADDR_EXP 7
15412: PUSH
15413: LD_INT 1
15415: ST_TO_ADDR
// tmp := FilterAllUnits ( [ [ f_side , 3 ] , [ f_type , unit_human ] ] ) ^ FilterAllUnits ( [ [ f_side , 3 ] , [ f_type , unit_vehicle ] , [ control_manual ] ] ) ;
15416: LD_ADDR_VAR 0 2
15420: PUSH
15421: LD_INT 22
15423: PUSH
15424: LD_INT 3
15426: PUSH
15427: EMPTY
15428: LIST
15429: LIST
15430: PUSH
15431: LD_INT 21
15433: PUSH
15434: LD_INT 1
15436: PUSH
15437: EMPTY
15438: LIST
15439: LIST
15440: PUSH
15441: EMPTY
15442: LIST
15443: LIST
15444: PPUSH
15445: CALL_OW 69
15449: PUSH
15450: LD_INT 22
15452: PUSH
15453: LD_INT 3
15455: PUSH
15456: EMPTY
15457: LIST
15458: LIST
15459: PUSH
15460: LD_INT 21
15462: PUSH
15463: LD_INT 2
15465: PUSH
15466: EMPTY
15467: LIST
15468: LIST
15469: PUSH
15470: LD_INT 1
15472: PUSH
15473: EMPTY
15474: LIST
15475: PUSH
15476: EMPTY
15477: LIST
15478: LIST
15479: LIST
15480: PPUSH
15481: CALL_OW 69
15485: ADD
15486: ST_TO_ADDR
// if tmp then
15487: LD_VAR 0 2
15491: IFFALSE 15644
// repeat wait ( 0 0$1 ) ;
15493: LD_INT 35
15495: PPUSH
15496: CALL_OW 67
// for i in tmp do
15500: LD_ADDR_VAR 0 1
15504: PUSH
15505: LD_VAR 0 2
15509: PUSH
15510: FOR_IN
15511: IFFALSE 15593
// begin if IsInUnit ( i ) and GetType ( IsInUnit ( i ) ) = unit_building then
15513: LD_VAR 0 1
15517: PPUSH
15518: CALL_OW 310
15522: PUSH
15523: LD_VAR 0 1
15527: PPUSH
15528: CALL_OW 310
15532: PPUSH
15533: CALL_OW 247
15537: PUSH
15538: LD_INT 3
15540: EQUAL
15541: AND
15542: IFFALSE 15553
// ComExitBuilding ( i ) ;
15544: LD_VAR 0 1
15548: PPUSH
15549: CALL_OW 122
// AddComMoveXY ( i , 154 , 1 ) ;
15553: LD_VAR 0 1
15557: PPUSH
15558: LD_INT 154
15560: PPUSH
15561: LD_INT 1
15563: PPUSH
15564: CALL_OW 171
// if IsInArea ( i , russianEscape ) then
15568: LD_VAR 0 1
15572: PPUSH
15573: LD_INT 36
15575: PPUSH
15576: CALL_OW 308
15580: IFFALSE 15591
// RemoveUnit ( i ) ;
15582: LD_VAR 0 1
15586: PPUSH
15587: CALL_OW 64
// end ;
15591: GO 15510
15593: POP
15594: POP
// until not FilterAllUnits ( [ [ f_side , 3 ] , [ f_or , [ f_type , unit_human ] , [ f_control , control_manual ] ] ] ) ;
15595: LD_INT 22
15597: PUSH
15598: LD_INT 3
15600: PUSH
15601: EMPTY
15602: LIST
15603: LIST
15604: PUSH
15605: LD_INT 2
15607: PUSH
15608: LD_INT 21
15610: PUSH
15611: LD_INT 1
15613: PUSH
15614: EMPTY
15615: LIST
15616: LIST
15617: PUSH
15618: LD_INT 33
15620: PUSH
15621: LD_INT 1
15623: PUSH
15624: EMPTY
15625: LIST
15626: LIST
15627: PUSH
15628: EMPTY
15629: LIST
15630: LIST
15631: LIST
15632: PUSH
15633: EMPTY
15634: LIST
15635: LIST
15636: PPUSH
15637: CALL_OW 69
15641: NOT
15642: IFFALSE 15493
// end ;
15644: PPOPN 3
15646: END
// every 0 0$3 trigger FilterAllUnits ( [ [ f_side , 8 ] , [ f_type , unit_human ] , [ f_nation , 2 ] ] ) < 18 or IsDead ( Kozlov ) or GetSide ( ar_depot1 ) = 7 do
15647: LD_INT 22
15649: PUSH
15650: LD_INT 8
15652: PUSH
15653: EMPTY
15654: LIST
15655: LIST
15656: PUSH
15657: LD_INT 21
15659: PUSH
15660: LD_INT 1
15662: PUSH
15663: EMPTY
15664: LIST
15665: LIST
15666: PUSH
15667: LD_INT 23
15669: PUSH
15670: LD_INT 2
15672: PUSH
15673: EMPTY
15674: LIST
15675: LIST
15676: PUSH
15677: EMPTY
15678: LIST
15679: LIST
15680: LIST
15681: PPUSH
15682: CALL_OW 69
15686: PUSH
15687: LD_INT 18
15689: LESS
15690: PUSH
15691: LD_EXP 57
15695: PPUSH
15696: CALL_OW 301
15700: OR
15701: PUSH
15702: LD_INT 324
15704: PPUSH
15705: CALL_OW 255
15709: PUSH
15710: LD_INT 7
15712: EQUAL
15713: OR
15714: IFFALSE 15727
15716: GO 15718
15718: DISABLE
// legionDestroyed := true ;
15719: LD_ADDR_EXP 3
15723: PUSH
15724: LD_INT 1
15726: ST_TO_ADDR
15727: END
// every 0 0$3 trigger FilterAllUnits ( [ [ f_side , 2 ] , [ f_type , unit_human ] , [ f_nation , 2 ] ] ) < 9 do
15728: LD_INT 22
15730: PUSH
15731: LD_INT 2
15733: PUSH
15734: EMPTY
15735: LIST
15736: LIST
15737: PUSH
15738: LD_INT 21
15740: PUSH
15741: LD_INT 1
15743: PUSH
15744: EMPTY
15745: LIST
15746: LIST
15747: PUSH
15748: LD_INT 23
15750: PUSH
15751: LD_INT 2
15753: PUSH
15754: EMPTY
15755: LIST
15756: LIST
15757: PUSH
15758: EMPTY
15759: LIST
15760: LIST
15761: LIST
15762: PPUSH
15763: CALL_OW 69
15767: PUSH
15768: LD_INT 9
15770: LESS
15771: IFFALSE 15784
15773: GO 15775
15775: DISABLE
// arabianDestroyed := true ;
15776: LD_ADDR_EXP 5
15780: PUSH
15781: LD_INT 1
15783: ST_TO_ADDR
15784: END
// every 0 0$1 trigger arabianDestroyed do var i , tmp ;
15785: LD_EXP 5
15789: IFFALSE 16033
15791: GO 15793
15793: DISABLE
15794: LD_INT 0
15796: PPUSH
15797: PPUSH
// begin MC_Kill ( 1 ) ;
15798: LD_INT 1
15800: PPUSH
15801: CALL 21647 0 1
// tmp := FilterAllUnits ( [ [ f_side , 2 ] , [ f_type , unit_human ] ] ) ^ FilterAllUnits ( [ [ f_side , 8 ] , [ f_type , unit_vehicle ] , [ control_manual ] ] ) ;
15805: LD_ADDR_VAR 0 2
15809: PUSH
15810: LD_INT 22
15812: PUSH
15813: LD_INT 2
15815: PUSH
15816: EMPTY
15817: LIST
15818: LIST
15819: PUSH
15820: LD_INT 21
15822: PUSH
15823: LD_INT 1
15825: PUSH
15826: EMPTY
15827: LIST
15828: LIST
15829: PUSH
15830: EMPTY
15831: LIST
15832: LIST
15833: PPUSH
15834: CALL_OW 69
15838: PUSH
15839: LD_INT 22
15841: PUSH
15842: LD_INT 8
15844: PUSH
15845: EMPTY
15846: LIST
15847: LIST
15848: PUSH
15849: LD_INT 21
15851: PUSH
15852: LD_INT 2
15854: PUSH
15855: EMPTY
15856: LIST
15857: LIST
15858: PUSH
15859: LD_INT 1
15861: PUSH
15862: EMPTY
15863: LIST
15864: PUSH
15865: EMPTY
15866: LIST
15867: LIST
15868: LIST
15869: PPUSH
15870: CALL_OW 69
15874: ADD
15875: ST_TO_ADDR
// if tmp then
15876: LD_VAR 0 2
15880: IFFALSE 16033
// repeat wait ( 0 0$1 ) ;
15882: LD_INT 35
15884: PPUSH
15885: CALL_OW 67
// for i in tmp do
15889: LD_ADDR_VAR 0 1
15893: PUSH
15894: LD_VAR 0 2
15898: PUSH
15899: FOR_IN
15900: IFFALSE 15982
// begin if IsInUnit ( i ) and GetType ( IsInUnit ( i ) ) = unit_building then
15902: LD_VAR 0 1
15906: PPUSH
15907: CALL_OW 310
15911: PUSH
15912: LD_VAR 0 1
15916: PPUSH
15917: CALL_OW 310
15921: PPUSH
15922: CALL_OW 247
15926: PUSH
15927: LD_INT 3
15929: EQUAL
15930: AND
15931: IFFALSE 15942
// ComExitBuilding ( i ) ;
15933: LD_VAR 0 1
15937: PPUSH
15938: CALL_OW 122
// AddComMoveXY ( i , 254 , 268 ) ;
15942: LD_VAR 0 1
15946: PPUSH
15947: LD_INT 254
15949: PPUSH
15950: LD_INT 268
15952: PPUSH
15953: CALL_OW 171
// if IsInArea ( i , arabEscape ) then
15957: LD_VAR 0 1
15961: PPUSH
15962: LD_INT 34
15964: PPUSH
15965: CALL_OW 308
15969: IFFALSE 15980
// RemoveUnit ( i ) ;
15971: LD_VAR 0 1
15975: PPUSH
15976: CALL_OW 64
// end ;
15980: GO 15899
15982: POP
15983: POP
// until not FilterAllUnits ( [ [ f_side , 2 ] , [ f_or , [ f_type , unit_human ] , [ f_control , control_manual ] ] ] ) ;
15984: LD_INT 22
15986: PUSH
15987: LD_INT 2
15989: PUSH
15990: EMPTY
15991: LIST
15992: LIST
15993: PUSH
15994: LD_INT 2
15996: PUSH
15997: LD_INT 21
15999: PUSH
16000: LD_INT 1
16002: PUSH
16003: EMPTY
16004: LIST
16005: LIST
16006: PUSH
16007: LD_INT 33
16009: PUSH
16010: LD_INT 1
16012: PUSH
16013: EMPTY
16014: LIST
16015: LIST
16016: PUSH
16017: EMPTY
16018: LIST
16019: LIST
16020: LIST
16021: PUSH
16022: EMPTY
16023: LIST
16024: LIST
16025: PPUSH
16026: CALL_OW 69
16030: NOT
16031: IFFALSE 15882
// end ;
16033: PPOPN 2
16035: END
// every 0 0$1 trigger legionDestroyed do var i , tmp ;
16036: LD_EXP 3
16040: IFFALSE 16392
16042: GO 16044
16044: DISABLE
16045: LD_INT 0
16047: PPUSH
16048: PPUSH
// begin MC_Kill ( 3 ) ;
16049: LD_INT 3
16051: PPUSH
16052: CALL 21647 0 1
// SetAttitude ( 8 , 7 , att_friend , true ) ;
16056: LD_INT 8
16058: PPUSH
16059: LD_INT 7
16061: PPUSH
16062: LD_INT 1
16064: PPUSH
16065: LD_INT 1
16067: PPUSH
16068: CALL_OW 80
// DialogueOn ;
16072: CALL_OW 6
// SayRadio ( Schulz , D15-Szulc-1 ) ;
16076: LD_EXP 56
16080: PPUSH
16081: LD_STRING D15-Szulc-1
16083: PPUSH
16084: CALL_OW 94
// DialogueOff ;
16088: CALL_OW 7
// legionCapitulated := true ;
16092: LD_ADDR_EXP 8
16096: PUSH
16097: LD_INT 1
16099: ST_TO_ADDR
// for i in FilterAllUnits ( [ [ f_side , 8 ] , [ f_type , unit_building ] , [ f_nation , 3 ] ] ) do
16100: LD_ADDR_VAR 0 1
16104: PUSH
16105: LD_INT 22
16107: PUSH
16108: LD_INT 8
16110: PUSH
16111: EMPTY
16112: LIST
16113: LIST
16114: PUSH
16115: LD_INT 21
16117: PUSH
16118: LD_INT 3
16120: PUSH
16121: EMPTY
16122: LIST
16123: LIST
16124: PUSH
16125: LD_INT 23
16127: PUSH
16128: LD_INT 3
16130: PUSH
16131: EMPTY
16132: LIST
16133: LIST
16134: PUSH
16135: EMPTY
16136: LIST
16137: LIST
16138: LIST
16139: PPUSH
16140: CALL_OW 69
16144: PUSH
16145: FOR_IN
16146: IFFALSE 16162
// SetLives ( i , 3 ) ;
16148: LD_VAR 0 1
16152: PPUSH
16153: LD_INT 3
16155: PPUSH
16156: CALL_OW 234
16160: GO 16145
16162: POP
16163: POP
// tmp := FilterAllUnits ( [ [ f_side , 8 ] , [ f_type , unit_human ] ] ) ^ FilterAllUnits ( [ [ f_side , 8 ] , [ f_type , unit_vehicle ] , [ control_manual ] ] ) ;
16164: LD_ADDR_VAR 0 2
16168: PUSH
16169: LD_INT 22
16171: PUSH
16172: LD_INT 8
16174: PUSH
16175: EMPTY
16176: LIST
16177: LIST
16178: PUSH
16179: LD_INT 21
16181: PUSH
16182: LD_INT 1
16184: PUSH
16185: EMPTY
16186: LIST
16187: LIST
16188: PUSH
16189: EMPTY
16190: LIST
16191: LIST
16192: PPUSH
16193: CALL_OW 69
16197: PUSH
16198: LD_INT 22
16200: PUSH
16201: LD_INT 8
16203: PUSH
16204: EMPTY
16205: LIST
16206: LIST
16207: PUSH
16208: LD_INT 21
16210: PUSH
16211: LD_INT 2
16213: PUSH
16214: EMPTY
16215: LIST
16216: LIST
16217: PUSH
16218: LD_INT 1
16220: PUSH
16221: EMPTY
16222: LIST
16223: PUSH
16224: EMPTY
16225: LIST
16226: LIST
16227: LIST
16228: PPUSH
16229: CALL_OW 69
16233: ADD
16234: ST_TO_ADDR
// if tmp then
16235: LD_VAR 0 2
16239: IFFALSE 16392
// repeat wait ( 0 0$1 ) ;
16241: LD_INT 35
16243: PPUSH
16244: CALL_OW 67
// for i in tmp do
16248: LD_ADDR_VAR 0 1
16252: PUSH
16253: LD_VAR 0 2
16257: PUSH
16258: FOR_IN
16259: IFFALSE 16341
// begin if IsInUnit ( i ) and GetType ( IsInUnit ( i ) ) = unit_building then
16261: LD_VAR 0 1
16265: PPUSH
16266: CALL_OW 310
16270: PUSH
16271: LD_VAR 0 1
16275: PPUSH
16276: CALL_OW 310
16280: PPUSH
16281: CALL_OW 247
16285: PUSH
16286: LD_INT 3
16288: EQUAL
16289: AND
16290: IFFALSE 16301
// ComExitBuilding ( i ) ;
16292: LD_VAR 0 1
16296: PPUSH
16297: CALL_OW 122
// AddComMoveXY ( i , 10 , 1 ) ;
16301: LD_VAR 0 1
16305: PPUSH
16306: LD_INT 10
16308: PPUSH
16309: LD_INT 1
16311: PPUSH
16312: CALL_OW 171
// if IsInArea ( i , legionEscape ) then
16316: LD_VAR 0 1
16320: PPUSH
16321: LD_INT 32
16323: PPUSH
16324: CALL_OW 308
16328: IFFALSE 16339
// RemoveUnit ( i ) ;
16330: LD_VAR 0 1
16334: PPUSH
16335: CALL_OW 64
// end ;
16339: GO 16258
16341: POP
16342: POP
// until not FilterAllUnits ( [ [ f_side , 8 ] , [ f_or , [ f_type , unit_human ] , [ f_control , control_manual ] ] ] ) ;
16343: LD_INT 22
16345: PUSH
16346: LD_INT 8
16348: PUSH
16349: EMPTY
16350: LIST
16351: LIST
16352: PUSH
16353: LD_INT 2
16355: PUSH
16356: LD_INT 21
16358: PUSH
16359: LD_INT 1
16361: PUSH
16362: EMPTY
16363: LIST
16364: LIST
16365: PUSH
16366: LD_INT 33
16368: PUSH
16369: LD_INT 1
16371: PUSH
16372: EMPTY
16373: LIST
16374: LIST
16375: PUSH
16376: EMPTY
16377: LIST
16378: LIST
16379: LIST
16380: PUSH
16381: EMPTY
16382: LIST
16383: LIST
16384: PPUSH
16385: CALL_OW 69
16389: NOT
16390: IFFALSE 16241
// end ;
16392: PPOPN 2
16394: END
// every 0 0$10 trigger not arabianDestroyed and tick >= 30 30$00 do
16395: LD_EXP 5
16399: NOT
16400: PUSH
16401: LD_OWVAR 1
16405: PUSH
16406: LD_INT 63000
16408: GREATEREQUAL
16409: AND
16410: IFFALSE 16419
16412: GO 16414
16414: DISABLE
// AllianceSupport ;
16415: CALL 4642 0 0
16419: END
// every 0 0$5 trigger americanDestroyed and russianDestroyed and legionDestroyed and arabianDestroyed and americanCapitulated and russianCapitulated and legionCapitulated and ( GetSide ( Omar ) <> 5 or IsDead ( Omar ) or not IsPlaced ( Omar ) ) do var med1 , med2 ;
16420: LD_EXP 4
16424: PUSH
16425: LD_EXP 2
16429: AND
16430: PUSH
16431: LD_EXP 3
16435: AND
16436: PUSH
16437: LD_EXP 5
16441: AND
16442: PUSH
16443: LD_EXP 6
16447: AND
16448: PUSH
16449: LD_EXP 7
16453: AND
16454: PUSH
16455: LD_EXP 8
16459: AND
16460: PUSH
16461: LD_EXP 55
16465: PPUSH
16466: CALL_OW 255
16470: PUSH
16471: LD_INT 5
16473: NONEQUAL
16474: PUSH
16475: LD_EXP 55
16479: PPUSH
16480: CALL_OW 301
16484: OR
16485: PUSH
16486: LD_EXP 55
16490: PPUSH
16491: CALL_OW 305
16495: NOT
16496: OR
16497: AND
16498: IFFALSE 17900
16500: GO 16502
16502: DISABLE
16503: LD_INT 0
16505: PPUSH
16506: PPUSH
// begin wait ( 0 0$5 ) ;
16507: LD_INT 175
16509: PPUSH
16510: CALL_OW 67
// music_class := 5 ;
16514: LD_ADDR_OWVAR 72
16518: PUSH
16519: LD_INT 5
16521: ST_TO_ADDR
// music_nat := 5 ;
16522: LD_ADDR_OWVAR 71
16526: PUSH
16527: LD_INT 5
16529: ST_TO_ADDR
// if vehicleLostCounter < 3 then
16530: LD_EXP 15
16534: PUSH
16535: LD_INT 3
16537: LESS
16538: IFFALSE 16547
// SetAchievement ( ACH_ECONOMY ) ;
16540: LD_STRING ACH_ECONOMY
16542: PPUSH
16543: CALL_OW 543
// if tick < 60 60$00 then
16547: LD_OWVAR 1
16551: PUSH
16552: LD_INT 126000
16554: LESS
16555: IFFALSE 16571
// begin wait ( 3 ) ;
16557: LD_INT 3
16559: PPUSH
16560: CALL_OW 67
// SetAchievement ( ACH_ASPEED_19 ) ;
16564: LD_STRING ACH_ASPEED_19
16566: PPUSH
16567: CALL_OW 543
// end ; CenterNowOnUnits ( JMM ) ;
16571: LD_EXP 19
16575: PPUSH
16576: CALL_OW 87
// InGameOn ;
16580: CALL_OW 8
// DialogueOn ;
16584: CALL_OW 6
// Say ( JMM , DEnd-JMM-JMM-1 ) ;
16588: LD_EXP 19
16592: PPUSH
16593: LD_STRING DEnd-JMM-JMM-1
16595: PPUSH
16596: CALL_OW 88
// if Joan then
16600: LD_EXP 34
16604: IFFALSE 16620
// Say ( Joan , DEnd-JMM-Joan-1 ) else
16606: LD_EXP 34
16610: PPUSH
16611: LD_STRING DEnd-JMM-Joan-1
16613: PPUSH
16614: CALL_OW 88
16618: GO 16664
// if Lisa and GetSide ( Lisa ) = 7 and IsPlaced ( Lisa ) then
16620: LD_EXP 21
16624: PUSH
16625: LD_EXP 21
16629: PPUSH
16630: CALL_OW 255
16634: PUSH
16635: LD_INT 7
16637: EQUAL
16638: AND
16639: PUSH
16640: LD_EXP 21
16644: PPUSH
16645: CALL_OW 305
16649: AND
16650: IFFALSE 16664
// Say ( Lisa , DEnd-JMM-Lisa-1 ) ;
16652: LD_EXP 21
16656: PPUSH
16657: LD_STRING DEnd-JMM-Lisa-1
16659: PPUSH
16660: CALL_OW 88
// if Frank and IsPlaced ( Frank ) then
16664: LD_EXP 31
16668: PUSH
16669: LD_EXP 31
16673: PPUSH
16674: CALL_OW 305
16678: AND
16679: IFFALSE 16693
// Say ( Frank , DEnd-JMM-Frank-1 ) ;
16681: LD_EXP 31
16685: PPUSH
16686: LD_STRING DEnd-JMM-Frank-1
16688: PPUSH
16689: CALL_OW 88
// if Cyrus and GetSide ( Cyrus ) = 7 and IsPlaced ( Cyrus ) then
16693: LD_EXP 24
16697: PUSH
16698: LD_EXP 24
16702: PPUSH
16703: CALL_OW 255
16707: PUSH
16708: LD_INT 7
16710: EQUAL
16711: AND
16712: PUSH
16713: LD_EXP 24
16717: PPUSH
16718: CALL_OW 305
16722: AND
16723: IFFALSE 16737
// Say ( Cyrus , DEnd-JMM-Cyrus-1 ) ;
16725: LD_EXP 24
16729: PPUSH
16730: LD_STRING DEnd-JMM-Cyrus-1
16732: PPUSH
16733: CALL_OW 88
// if Burlak then
16737: LD_EXP 51
16741: IFFALSE 16755
// Say ( Burlak , DEnd-JMM-Bur-1 ) ;
16743: LD_EXP 51
16747: PPUSH
16748: LD_STRING DEnd-JMM-Bur-1
16750: PPUSH
16751: CALL_OW 88
// if Joan and Lisa and GetSide ( Lisa ) = 7 and IsPlaced ( Lisa ) and IsOk ( Burlak ) then
16755: LD_EXP 34
16759: PUSH
16760: LD_EXP 21
16764: AND
16765: PUSH
16766: LD_EXP 21
16770: PPUSH
16771: CALL_OW 255
16775: PUSH
16776: LD_INT 7
16778: EQUAL
16779: AND
16780: PUSH
16781: LD_EXP 21
16785: PPUSH
16786: CALL_OW 305
16790: AND
16791: PUSH
16792: LD_EXP 51
16796: PPUSH
16797: CALL_OW 302
16801: AND
16802: IFFALSE 16816
// Say ( Lisa , DEnd-Burlak-Lisa-1 ) ;
16804: LD_EXP 21
16808: PPUSH
16809: LD_STRING DEnd-Burlak-Lisa-1
16811: PPUSH
16812: CALL_OW 88
// if Belkov and IsPlaced ( Belkov ) then
16816: LD_EXP 52
16820: PUSH
16821: LD_EXP 52
16825: PPUSH
16826: CALL_OW 305
16830: AND
16831: IFFALSE 16845
// Say ( Belkov , DEnd-JMM-Bel-1 ) ;
16833: LD_EXP 52
16837: PPUSH
16838: LD_STRING DEnd-JMM-Bel-1
16840: PPUSH
16841: CALL_OW 88
// if Gnyevko and IsPlaced ( Gnyevko ) then
16845: LD_EXP 53
16849: PUSH
16850: LD_EXP 53
16854: PPUSH
16855: CALL_OW 305
16859: AND
16860: IFFALSE 16874
// Say ( Gnyevko , DEnd-JMM-Gny-1 ) ;
16862: LD_EXP 53
16866: PPUSH
16867: LD_STRING DEnd-JMM-Gny-1
16869: PPUSH
16870: CALL_OW 88
// if Cornel and GetSide ( Cornel ) = 7 and IsPlaced ( Cornel ) then
16874: LD_EXP 29
16878: PUSH
16879: LD_EXP 29
16883: PPUSH
16884: CALL_OW 255
16888: PUSH
16889: LD_INT 7
16891: EQUAL
16892: AND
16893: PUSH
16894: LD_EXP 29
16898: PPUSH
16899: CALL_OW 305
16903: AND
16904: IFFALSE 16918
// Say ( Cornel , DEnd-JMM-Corn-1 ) ;
16906: LD_EXP 29
16910: PPUSH
16911: LD_STRING DEnd-JMM-Corn-1
16913: PPUSH
16914: CALL_OW 88
// if Donaldson and GetSide ( Donaldson ) = 7 and IsPlaced ( Donaldson ) then
16918: LD_EXP 22
16922: PUSH
16923: LD_EXP 22
16927: PPUSH
16928: CALL_OW 255
16932: PUSH
16933: LD_INT 7
16935: EQUAL
16936: AND
16937: PUSH
16938: LD_EXP 22
16942: PPUSH
16943: CALL_OW 305
16947: AND
16948: IFFALSE 16962
// Say ( Donaldson , DEnd-JMM-Don-1 ) ;
16950: LD_EXP 22
16954: PPUSH
16955: LD_STRING DEnd-JMM-Don-1
16957: PPUSH
16958: CALL_OW 88
// if Bobby and GetSide ( Bobby ) = 7 and IsPlaced ( Bobby ) then
16962: LD_EXP 23
16966: PUSH
16967: LD_EXP 23
16971: PPUSH
16972: CALL_OW 255
16976: PUSH
16977: LD_INT 7
16979: EQUAL
16980: AND
16981: PUSH
16982: LD_EXP 23
16986: PPUSH
16987: CALL_OW 305
16991: AND
16992: IFFALSE 17006
// Say ( Bobby , DEnd-JMM-Bobby-1 ) ;
16994: LD_EXP 23
16998: PPUSH
16999: LD_STRING DEnd-JMM-Bobby-1
17001: PPUSH
17002: CALL_OW 88
// if Denis and GetSide ( Denis ) = 7 and IsPlaced ( Denis ) then
17006: LD_EXP 25
17010: PUSH
17011: LD_EXP 25
17015: PPUSH
17016: CALL_OW 255
17020: PUSH
17021: LD_INT 7
17023: EQUAL
17024: AND
17025: PUSH
17026: LD_EXP 25
17030: PPUSH
17031: CALL_OW 305
17035: AND
17036: IFFALSE 17050
// Say ( Denis , DEnd-JMM-Den-1 ) ;
17038: LD_EXP 25
17042: PPUSH
17043: LD_STRING DEnd-JMM-Den-1
17045: PPUSH
17046: CALL_OW 88
// if Gladstone and GetSide ( Gladstone ) = 7 and IsPlaced ( Gladstone ) then
17050: LD_EXP 27
17054: PUSH
17055: LD_EXP 27
17059: PPUSH
17060: CALL_OW 255
17064: PUSH
17065: LD_INT 7
17067: EQUAL
17068: AND
17069: PUSH
17070: LD_EXP 27
17074: PPUSH
17075: CALL_OW 305
17079: AND
17080: IFFALSE 17094
// Say ( Gladstone , DEnd-JMM-Glad-1 ) ;
17082: LD_EXP 27
17086: PPUSH
17087: LD_STRING DEnd-JMM-Glad-1
17089: PPUSH
17090: CALL_OW 88
// if Kikuchi and GetSide ( Kikuchi ) = 7 and IsPlaced ( Kikuchi ) then
17094: LD_EXP 32
17098: PUSH
17099: LD_EXP 32
17103: PPUSH
17104: CALL_OW 255
17108: PUSH
17109: LD_INT 7
17111: EQUAL
17112: AND
17113: PUSH
17114: LD_EXP 32
17118: PPUSH
17119: CALL_OW 305
17123: AND
17124: IFFALSE 17138
// Say ( Kikuchi , DEnd-JMM-Yam-1 ) ;
17126: LD_EXP 32
17130: PPUSH
17131: LD_STRING DEnd-JMM-Yam-1
17133: PPUSH
17134: CALL_OW 88
// if Brown and GetSide ( Brown ) = 7 and IsPlaced ( Brown ) then
17138: LD_EXP 26
17142: PUSH
17143: LD_EXP 26
17147: PPUSH
17148: CALL_OW 255
17152: PUSH
17153: LD_INT 7
17155: EQUAL
17156: AND
17157: PUSH
17158: LD_EXP 26
17162: PPUSH
17163: CALL_OW 305
17167: AND
17168: IFFALSE 17182
// Say ( Brown , DEnd-JMM-Brown-1 ) ;
17170: LD_EXP 26
17174: PPUSH
17175: LD_STRING DEnd-JMM-Brown-1
17177: PPUSH
17178: CALL_OW 88
// if Connie and GetSide ( Connie ) = 7 and IsPlaced ( Connie ) then
17182: LD_EXP 36
17186: PUSH
17187: LD_EXP 36
17191: PPUSH
17192: CALL_OW 255
17196: PUSH
17197: LD_INT 7
17199: EQUAL
17200: AND
17201: PUSH
17202: LD_EXP 36
17206: PPUSH
17207: CALL_OW 305
17211: AND
17212: IFFALSE 17226
// Say ( Connie , DEnd-JMM-Con-1 ) ;
17214: LD_EXP 36
17218: PPUSH
17219: LD_STRING DEnd-JMM-Con-1
17221: PPUSH
17222: CALL_OW 88
// if Gary and GetSide ( Gary ) = 7 and IsPlaced ( Gary ) then
17226: LD_EXP 30
17230: PUSH
17231: LD_EXP 30
17235: PPUSH
17236: CALL_OW 255
17240: PUSH
17241: LD_INT 7
17243: EQUAL
17244: AND
17245: PUSH
17246: LD_EXP 30
17250: PPUSH
17251: CALL_OW 305
17255: AND
17256: IFFALSE 17270
// Say ( Gary , DEnd-JMM-Gary-1 ) ;
17258: LD_EXP 30
17262: PPUSH
17263: LD_STRING DEnd-JMM-Gary-1
17265: PPUSH
17266: CALL_OW 88
// if Simms and Roth and IsPlaced ( Simms ) then
17270: LD_EXP 33
17274: PUSH
17275: LD_EXP 20
17279: AND
17280: PUSH
17281: LD_EXP 33
17285: PPUSH
17286: CALL_OW 305
17290: AND
17291: IFFALSE 17305
// Say ( Simms , DEnd-JMM-Sim-1 ) ;
17293: LD_EXP 33
17297: PPUSH
17298: LD_STRING DEnd-JMM-Sim-1
17300: PPUSH
17301: CALL_OW 88
// if Houten and GetSide ( Houten ) = 7 and IsPlaced ( Houten ) then
17305: LD_EXP 28
17309: PUSH
17310: LD_EXP 28
17314: PPUSH
17315: CALL_OW 255
17319: PUSH
17320: LD_INT 7
17322: EQUAL
17323: AND
17324: PUSH
17325: LD_EXP 28
17329: PPUSH
17330: CALL_OW 305
17334: AND
17335: IFFALSE 17349
// Say ( Houten , DEnd-JMM-VanH-1 ) ;
17337: LD_EXP 28
17341: PPUSH
17342: LD_STRING DEnd-JMM-VanH-1
17344: PPUSH
17345: CALL_OW 88
// if Dolgov and IsPlaced ( Dolgov ) then
17349: LD_EXP 41
17353: PUSH
17354: LD_EXP 41
17358: PPUSH
17359: CALL_OW 305
17363: AND
17364: IFFALSE 17378
// Say ( Dolgov , DEnd-JMM-Dol-1 ) ;
17366: LD_EXP 41
17370: PPUSH
17371: LD_STRING DEnd-JMM-Dol-1
17373: PPUSH
17374: CALL_OW 88
// if Kapitsova and IsPlaced ( Kapitsova ) then
17378: LD_EXP 45
17382: PUSH
17383: LD_EXP 45
17387: PPUSH
17388: CALL_OW 305
17392: AND
17393: IFFALSE 17407
// Say ( Kapitsova , DEnd-JMM-Kap-1 ) ;
17395: LD_EXP 45
17399: PPUSH
17400: LD_STRING DEnd-JMM-Kap-1
17402: PPUSH
17403: CALL_OW 88
// if Kovalyuk and IsPlaced ( Kovalyuk ) then
17407: LD_EXP 48
17411: PUSH
17412: LD_EXP 48
17416: PPUSH
17417: CALL_OW 305
17421: AND
17422: IFFALSE 17436
// Say ( Kovalyuk , DEnd-JMM-Kov-1 ) ;
17424: LD_EXP 48
17428: PPUSH
17429: LD_STRING DEnd-JMM-Kov-1
17431: PPUSH
17432: CALL_OW 88
// if Scholtze and IsPlaced ( Scholtze ) then
17436: LD_EXP 43
17440: PUSH
17441: LD_EXP 43
17445: PPUSH
17446: CALL_OW 305
17450: AND
17451: IFFALSE 17465
// Say ( Scholtze , DEnd-JMM-Sch-1 ) ;
17453: LD_EXP 43
17457: PPUSH
17458: LD_STRING DEnd-JMM-Sch-1
17460: PPUSH
17461: CALL_OW 88
// if Titov and IsPlaced ( Titov ) then
17465: LD_EXP 39
17469: PUSH
17470: LD_EXP 39
17474: PPUSH
17475: CALL_OW 305
17479: AND
17480: IFFALSE 17494
// Say ( Titov , DEnd-JMM-Tit-1 ) ;
17482: LD_EXP 39
17486: PPUSH
17487: LD_STRING DEnd-JMM-Tit-1
17489: PPUSH
17490: CALL_OW 88
// if Oblukov and IsPlaced ( Oblukov ) then
17494: LD_EXP 44
17498: PUSH
17499: LD_EXP 44
17503: PPUSH
17504: CALL_OW 305
17508: AND
17509: IFFALSE 17523
// Say ( Oblukov , DEnd-JMM-Obl-1 ) ;
17511: LD_EXP 44
17515: PPUSH
17516: LD_STRING DEnd-JMM-Obl-1
17518: PPUSH
17519: CALL_OW 88
// if Lipshchin and IsPlaced ( Lipshchin ) then
17523: LD_EXP 46
17527: PUSH
17528: LD_EXP 46
17532: PPUSH
17533: CALL_OW 305
17537: AND
17538: IFFALSE 17552
// Say ( Lipshchin , DEnd-JMM-Lip-1 ) ;
17540: LD_EXP 46
17544: PPUSH
17545: LD_STRING DEnd-JMM-Lip-1
17547: PPUSH
17548: CALL_OW 88
// if Fadeev and IsPlaced ( Fadeev ) and Burlak then
17552: LD_EXP 40
17556: PUSH
17557: LD_EXP 40
17561: PPUSH
17562: CALL_OW 305
17566: AND
17567: PUSH
17568: LD_EXP 51
17572: AND
17573: IFFALSE 17587
// Say ( Fadeev , DEnd-Burlak-Fad-1 ) ;
17575: LD_EXP 40
17579: PPUSH
17580: LD_STRING DEnd-Burlak-Fad-1
17582: PPUSH
17583: CALL_OW 88
// if Petrovova and IsPlaced ( Petrovova ) then
17587: LD_EXP 47
17591: PUSH
17592: LD_EXP 47
17596: PPUSH
17597: CALL_OW 305
17601: AND
17602: IFFALSE 17616
// Say ( Petrovova , DEnd-Burlak-Ptr-1 ) ;
17604: LD_EXP 47
17608: PPUSH
17609: LD_STRING DEnd-Burlak-Ptr-1
17611: PPUSH
17612: CALL_OW 88
// if Kuzmov and IsPlaced ( Kuzmov ) then
17616: LD_EXP 49
17620: PUSH
17621: LD_EXP 49
17625: PPUSH
17626: CALL_OW 305
17630: AND
17631: IFFALSE 17645
// Say ( Kuzmov , DEnd-Burlak-Kuz-1 ) ;
17633: LD_EXP 49
17637: PPUSH
17638: LD_STRING DEnd-Burlak-Kuz-1
17640: PPUSH
17641: CALL_OW 88
// if Kirilenkova and IsPlaced ( Kirilenkova ) and Burlak then
17645: LD_EXP 38
17649: PUSH
17650: LD_EXP 38
17654: PPUSH
17655: CALL_OW 305
17659: AND
17660: PUSH
17661: LD_EXP 51
17665: AND
17666: IFFALSE 17680
// Say ( Kirilenkova , DEnd-Burlak-Kir-1 ) ;
17668: LD_EXP 38
17672: PPUSH
17673: LD_STRING DEnd-Burlak-Kir-1
17675: PPUSH
17676: CALL_OW 88
// if Burlak then
17680: LD_EXP 51
17684: IFFALSE 17698
// Say ( JMM , DEnd-Burlak-JMM-1 ) ;
17686: LD_EXP 19
17690: PPUSH
17691: LD_STRING DEnd-Burlak-JMM-1
17693: PPUSH
17694: CALL_OW 88
// dwait ( 0 0$2 ) ;
17698: LD_INT 70
17700: PPUSH
17701: CALL_OW 68
// SayRadio ( Schulz , DEnd-Szulc ) ;
17705: LD_EXP 56
17709: PPUSH
17710: LD_STRING DEnd-Szulc
17712: PPUSH
17713: CALL_OW 94
// dwait ( 0 0$1 ) ;
17717: LD_INT 35
17719: PPUSH
17720: CALL_OW 68
// if IsLive ( Burlak ) then
17724: LD_EXP 51
17728: PPUSH
17729: CALL_OW 300
17733: IFFALSE 17745
// med1 := 1 else
17735: LD_ADDR_VAR 0 1
17739: PUSH
17740: LD_INT 1
17742: ST_TO_ADDR
17743: GO 17754
// med1 := - 1 ;
17745: LD_ADDR_VAR 0 1
17749: PUSH
17750: LD_INT 1
17752: NEG
17753: ST_TO_ADDR
// if artifactIResearched and artifactIIResearched and artifactIIIResearched then
17754: LD_EXP 12
17758: PUSH
17759: LD_EXP 13
17763: AND
17764: PUSH
17765: LD_EXP 14
17769: AND
17770: IFFALSE 17782
// med2 := 1 else
17772: LD_ADDR_VAR 0 2
17776: PUSH
17777: LD_INT 1
17779: ST_TO_ADDR
17780: GO 17791
// med2 := - 1 ;
17782: LD_ADDR_VAR 0 2
17786: PUSH
17787: LD_INT 1
17789: NEG
17790: ST_TO_ADDR
// AddMedal ( Hero , 1 ) ;
17791: LD_STRING Hero
17793: PPUSH
17794: LD_INT 1
17796: PPUSH
17797: CALL_OW 101
// AddMedal ( Artefact , med2 ) ;
17801: LD_STRING Artefact
17803: PPUSH
17804: LD_VAR 0 2
17808: PPUSH
17809: CALL_OW 101
// AddMedal ( ReconcileBurlak , med1 ) ;
17813: LD_STRING ReconcileBurlak
17815: PPUSH
17816: LD_VAR 0 1
17820: PPUSH
17821: CALL_OW 101
// if Difficulty >= 3 and med1 = 1 and med2 = 1 then
17825: LD_OWVAR 67
17829: PUSH
17830: LD_INT 3
17832: GREATEREQUAL
17833: PUSH
17834: LD_VAR 0 1
17838: PUSH
17839: LD_INT 1
17841: EQUAL
17842: AND
17843: PUSH
17844: LD_VAR 0 2
17848: PUSH
17849: LD_INT 1
17851: EQUAL
17852: AND
17853: IFFALSE 17865
// SetAchievementEX ( ACH_AMER , 19 ) ;
17855: LD_STRING ACH_AMER
17857: PPUSH
17858: LD_INT 19
17860: PPUSH
17861: CALL_OW 564
// GiveMedals ( MAIN ) ;
17865: LD_STRING MAIN
17867: PPUSH
17868: CALL_OW 102
// InGameOff ;
17872: CALL_OW 9
// DialogueOff ;
17876: CALL_OW 7
// music_nat := 1 ;
17880: LD_ADDR_OWVAR 71
17884: PUSH
17885: LD_INT 1
17887: ST_TO_ADDR
// music_class := 4 ;
17888: LD_ADDR_OWVAR 72
17892: PUSH
17893: LD_INT 4
17895: ST_TO_ADDR
// YouWin ;
17896: CALL_OW 103
// end ; end_of_file
17900: PPOPN 2
17902: END
// export function InitNature ; begin
17903: LD_INT 0
17905: PPUSH
// PrepareNature ( 3 , 3 , 2 , 1 , 1 , 0 , 0 , natureArea1 , 0 ) ;
17906: LD_INT 3
17908: PPUSH
17909: LD_INT 3
17911: PPUSH
17912: LD_INT 2
17914: PPUSH
17915: LD_INT 1
17917: PPUSH
17918: LD_INT 1
17920: PPUSH
17921: LD_INT 0
17923: PPUSH
17924: LD_INT 0
17926: PPUSH
17927: LD_INT 17
17929: PPUSH
17930: LD_INT 0
17932: PPUSH
17933: CALL 85394 0 9
// PrepareNature ( 2 , 1 , 1 , 1 , 1 , 0 , 0 , natureArea2 , 0 ) ;
17937: LD_INT 2
17939: PPUSH
17940: LD_INT 1
17942: PPUSH
17943: LD_INT 1
17945: PPUSH
17946: LD_INT 1
17948: PPUSH
17949: LD_INT 1
17951: PPUSH
17952: LD_INT 0
17954: PPUSH
17955: LD_INT 0
17957: PPUSH
17958: LD_INT 18
17960: PPUSH
17961: LD_INT 0
17963: PPUSH
17964: CALL 85394 0 9
// PrepareNature ( 4 , 1 , 2 , 4 , 2 , 1 , 0 , natureArea3 , 0 ) ;
17968: LD_INT 4
17970: PPUSH
17971: LD_INT 1
17973: PPUSH
17974: LD_INT 2
17976: PPUSH
17977: LD_INT 4
17979: PPUSH
17980: LD_INT 2
17982: PPUSH
17983: LD_INT 1
17985: PPUSH
17986: LD_INT 0
17988: PPUSH
17989: LD_INT 19
17991: PPUSH
17992: LD_INT 0
17994: PPUSH
17995: CALL 85394 0 9
// PrepareNature ( 0 , 0 , 0 , 0 , 0 , 0 , 9 , 0 , natureWaterArea ) ;
17999: LD_INT 0
18001: PPUSH
18002: LD_INT 0
18004: PPUSH
18005: LD_INT 0
18007: PPUSH
18008: LD_INT 0
18010: PPUSH
18011: LD_INT 0
18013: PPUSH
18014: LD_INT 0
18016: PPUSH
18017: LD_INT 9
18019: PPUSH
18020: LD_INT 0
18022: PPUSH
18023: LD_INT 20
18025: PPUSH
18026: CALL 85394 0 9
// end ; end_of_file
18030: LD_VAR 0 1
18034: RET
// every 0 0$30 do var time ;
18035: GO 18037
18037: DISABLE
18038: LD_INT 0
18040: PPUSH
// begin time := 0 0$30 ;
18041: LD_ADDR_VAR 0 1
18045: PUSH
18046: LD_INT 1050
18048: ST_TO_ADDR
// repeat wait ( time ) ;
18049: LD_VAR 0 1
18053: PPUSH
18054: CALL_OW 67
// if Prob ( 50 ) then
18058: LD_INT 50
18060: PPUSH
18061: CALL_OW 13
18065: IFFALSE 18094
// CreateCratesXYR ( rand ( 1 , 5 ) , 106 , 89 , 45 , true ) ;
18067: LD_INT 1
18069: PPUSH
18070: LD_INT 5
18072: PPUSH
18073: CALL_OW 12
18077: PPUSH
18078: LD_INT 106
18080: PPUSH
18081: LD_INT 89
18083: PPUSH
18084: LD_INT 45
18086: PPUSH
18087: LD_INT 1
18089: PPUSH
18090: CALL_OW 56
// time := time + 0 0$3 ;
18094: LD_ADDR_VAR 0 1
18098: PUSH
18099: LD_VAR 0 1
18103: PUSH
18104: LD_INT 105
18106: PLUS
18107: ST_TO_ADDR
// if Prob ( 30 ) then
18108: LD_INT 30
18110: PPUSH
18111: CALL_OW 13
18115: IFFALSE 18161
// begin wait ( rand ( 0 0$15 , 0 0$21 ) ) ;
18117: LD_INT 525
18119: PPUSH
18120: LD_INT 735
18122: PPUSH
18123: CALL_OW 12
18127: PPUSH
18128: CALL_OW 67
// CreateCratesXYR ( rand ( 1 , 5 ) , 21 , 26 , 12 , true ) ;
18132: LD_INT 1
18134: PPUSH
18135: LD_INT 5
18137: PPUSH
18138: CALL_OW 12
18142: PPUSH
18143: LD_INT 21
18145: PPUSH
18146: LD_INT 26
18148: PPUSH
18149: LD_INT 12
18151: PPUSH
18152: LD_INT 1
18154: PPUSH
18155: CALL_OW 56
// end else
18159: GO 18197
// begin wait ( rand ( 0 0$20 , 0 0$35 ) ) ;
18161: LD_INT 700
18163: PPUSH
18164: LD_INT 1225
18166: PPUSH
18167: CALL_OW 12
18171: PPUSH
18172: CALL_OW 67
// CreateCratesArea ( rand ( 1 , 5 ) , russianCratesArea , true ) ;
18176: LD_INT 1
18178: PPUSH
18179: LD_INT 5
18181: PPUSH
18182: CALL_OW 12
18186: PPUSH
18187: LD_INT 14
18189: PPUSH
18190: LD_INT 1
18192: PPUSH
18193: CALL_OW 55
// end ; if Prob ( 50 ) then
18197: LD_INT 50
18199: PPUSH
18200: CALL_OW 13
18204: IFFALSE 18250
// begin wait ( rand ( 0 0$20 , 0 0$30 ) ) ;
18206: LD_INT 700
18208: PPUSH
18209: LD_INT 1050
18211: PPUSH
18212: CALL_OW 12
18216: PPUSH
18217: CALL_OW 67
// CreateCratesXYR ( rand ( 1 , 5 ) , 181 , 218 , 16 , true ) ;
18221: LD_INT 1
18223: PPUSH
18224: LD_INT 5
18226: PPUSH
18227: CALL_OW 12
18231: PPUSH
18232: LD_INT 181
18234: PPUSH
18235: LD_INT 218
18237: PPUSH
18238: LD_INT 16
18240: PPUSH
18241: LD_INT 1
18243: PPUSH
18244: CALL_OW 56
// end else
18248: GO 18322
// begin wait ( rand ( 0 0$10 , 0 0$15 ) ) ;
18250: LD_INT 350
18252: PPUSH
18253: LD_INT 525
18255: PPUSH
18256: CALL_OW 12
18260: PPUSH
18261: CALL_OW 67
// CreateCratesArea ( rand ( 1 , 5 ) , legionCratesArea , true ) ;
18265: LD_INT 1
18267: PPUSH
18268: LD_INT 5
18270: PPUSH
18271: CALL_OW 12
18275: PPUSH
18276: LD_INT 13
18278: PPUSH
18279: LD_INT 1
18281: PPUSH
18282: CALL_OW 55
// wait ( rand ( 0 0$10 , 0 0$20 ) ) ;
18286: LD_INT 350
18288: PPUSH
18289: LD_INT 700
18291: PPUSH
18292: CALL_OW 12
18296: PPUSH
18297: CALL_OW 67
// CreateCratesArea ( rand ( 1 , 5 ) , americanCratesArea , true ) ;
18301: LD_INT 1
18303: PPUSH
18304: LD_INT 5
18306: PPUSH
18307: CALL_OW 12
18311: PPUSH
18312: LD_INT 33
18314: PPUSH
18315: LD_INT 1
18317: PPUSH
18318: CALL_OW 55
// end ; if Prob ( [ 65 , 62 , 55 , 50 ] [ Difficulty ] ) then
18322: LD_INT 65
18324: PUSH
18325: LD_INT 62
18327: PUSH
18328: LD_INT 55
18330: PUSH
18331: LD_INT 50
18333: PUSH
18334: EMPTY
18335: LIST
18336: LIST
18337: LIST
18338: LIST
18339: PUSH
18340: LD_OWVAR 67
18344: ARRAY
18345: PPUSH
18346: CALL_OW 13
18350: IFFALSE 18396
// begin wait ( rand ( 0 0$15 , 0 0$25 ) ) ;
18352: LD_INT 525
18354: PPUSH
18355: LD_INT 875
18357: PPUSH
18358: CALL_OW 12
18362: PPUSH
18363: CALL_OW 67
// CreateCratesXYR ( rand ( 1 , 5 ) , 294 , 211 , 30 , true ) ;
18367: LD_INT 1
18369: PPUSH
18370: LD_INT 5
18372: PPUSH
18373: CALL_OW 12
18377: PPUSH
18378: LD_INT 294
18380: PPUSH
18381: LD_INT 211
18383: PPUSH
18384: LD_INT 30
18386: PPUSH
18387: LD_INT 1
18389: PPUSH
18390: CALL_OW 56
// end else
18394: GO 18438
// begin wait ( rand ( 0 0$12 , 0 0$22 ) ) ;
18396: LD_INT 420
18398: PPUSH
18399: LD_INT 770
18401: PPUSH
18402: CALL_OW 12
18406: PPUSH
18407: CALL_OW 67
// CreateCratesXYR ( rand ( 1 , 5 ) , 294 , 211 , 30 , true ) ;
18411: LD_INT 1
18413: PPUSH
18414: LD_INT 5
18416: PPUSH
18417: CALL_OW 12
18421: PPUSH
18422: LD_INT 294
18424: PPUSH
18425: LD_INT 211
18427: PPUSH
18428: LD_INT 30
18430: PPUSH
18431: LD_INT 1
18433: PPUSH
18434: CALL_OW 56
// end ; if time > 2 2$20 then
18438: LD_VAR 0 1
18442: PUSH
18443: LD_INT 4900
18445: GREATER
18446: IFFALSE 18456
// time := 0 0$50 ;
18448: LD_ADDR_VAR 0 1
18452: PUSH
18453: LD_INT 1750
18455: ST_TO_ADDR
// until false ;
18456: LD_INT 0
18458: IFFALSE 18049
// end ;
18460: PPOPN 1
18462: END
// every 0 0$45 trigger tick < 10 10$00 do
18463: LD_OWVAR 1
18467: PUSH
18468: LD_INT 21000
18470: LESS
18471: IFFALSE 18519
18473: GO 18475
18475: DISABLE
// begin enable ;
18476: ENABLE
// wait ( rand ( 0 0$10 , 0 0$20 ) ) ;
18477: LD_INT 350
18479: PPUSH
18480: LD_INT 700
18482: PPUSH
18483: CALL_OW 12
18487: PPUSH
18488: CALL_OW 67
// CreateCratesXYR ( rand ( 3 , 5 ) , 181 , 13 , 20 , true ) ;
18492: LD_INT 3
18494: PPUSH
18495: LD_INT 5
18497: PPUSH
18498: CALL_OW 12
18502: PPUSH
18503: LD_INT 181
18505: PPUSH
18506: LD_INT 13
18508: PPUSH
18509: LD_INT 20
18511: PPUSH
18512: LD_INT 1
18514: PPUSH
18515: CALL_OW 56
// end ; end_of_file
18519: END
// export artifactsPos , artifactsRecharge , artifactsSibCost , artifactsResearched , artifactsLabsWorking ; export artifactsResDifficulty , artifactsResProgress , artifactsLabs , artifactsButtons , artifactsReady ; export function InitArtifact ; begin
18520: LD_INT 0
18522: PPUSH
// SetArtifactRes ( 7 , true ) ;
18523: LD_INT 7
18525: PPUSH
18526: LD_INT 1
18528: PPUSH
18529: CALL_OW 467
// artifactsPos := [ [ ] , [ ] , [ ] ] ;
18533: LD_ADDR_EXP 64
18537: PUSH
18538: EMPTY
18539: PUSH
18540: EMPTY
18541: PUSH
18542: EMPTY
18543: PUSH
18544: EMPTY
18545: LIST
18546: LIST
18547: LIST
18548: ST_TO_ADDR
// artifactsRecharge := [ 0 0$30 * Difficulty , 1 1$20 * Difficulty , - 1 ] ;
18549: LD_ADDR_EXP 65
18553: PUSH
18554: LD_INT 1050
18556: PUSH
18557: LD_OWVAR 67
18561: MUL
18562: PUSH
18563: LD_INT 2800
18565: PUSH
18566: LD_OWVAR 67
18570: MUL
18571: PUSH
18572: LD_INT 1
18574: NEG
18575: PUSH
18576: EMPTY
18577: LIST
18578: LIST
18579: LIST
18580: ST_TO_ADDR
// artifactsSibCost := [ 10 , 35 , 100 ] ;
18581: LD_ADDR_EXP 66
18585: PUSH
18586: LD_INT 10
18588: PUSH
18589: LD_INT 35
18591: PUSH
18592: LD_INT 100
18594: PUSH
18595: EMPTY
18596: LIST
18597: LIST
18598: LIST
18599: ST_TO_ADDR
// artifactsResearched := [ 0 , 0 , 0 ] ;
18600: LD_ADDR_EXP 67
18604: PUSH
18605: LD_INT 0
18607: PUSH
18608: LD_INT 0
18610: PUSH
18611: LD_INT 0
18613: PUSH
18614: EMPTY
18615: LIST
18616: LIST
18617: LIST
18618: ST_TO_ADDR
// artifactsResDifficulty := [ 300 , 500 , 800 ] ;
18619: LD_ADDR_EXP 69
18623: PUSH
18624: LD_INT 300
18626: PUSH
18627: LD_INT 500
18629: PUSH
18630: LD_INT 800
18632: PUSH
18633: EMPTY
18634: LIST
18635: LIST
18636: LIST
18637: ST_TO_ADDR
// artifactsResProgress := [ 0 , 0 , 0 ] ;
18638: LD_ADDR_EXP 70
18642: PUSH
18643: LD_INT 0
18645: PUSH
18646: LD_INT 0
18648: PUSH
18649: LD_INT 0
18651: PUSH
18652: EMPTY
18653: LIST
18654: LIST
18655: LIST
18656: ST_TO_ADDR
// artifactsLabs := [ 0 , 0 , 0 ] ;
18657: LD_ADDR_EXP 71
18661: PUSH
18662: LD_INT 0
18664: PUSH
18665: LD_INT 0
18667: PUSH
18668: LD_INT 0
18670: PUSH
18671: EMPTY
18672: LIST
18673: LIST
18674: LIST
18675: ST_TO_ADDR
// artifactsLabsWorking := [ 0 , 0 , 0 ] ;
18676: LD_ADDR_EXP 68
18680: PUSH
18681: LD_INT 0
18683: PUSH
18684: LD_INT 0
18686: PUSH
18687: LD_INT 0
18689: PUSH
18690: EMPTY
18691: LIST
18692: LIST
18693: LIST
18694: ST_TO_ADDR
// artifactsButtons := [ [ art_use_eye , art_place , art_exp_left ] , [ art_use_sibexplosion , art_unit , art_exp_mid ] , [ art_use_teleport , art_place , art_exp_right ] ] ;
18695: LD_ADDR_EXP 72
18699: PUSH
18700: LD_INT 4
18702: PUSH
18703: LD_INT 3
18705: PUSH
18706: LD_INT 1
18708: PUSH
18709: EMPTY
18710: LIST
18711: LIST
18712: LIST
18713: PUSH
18714: LD_INT 5
18716: PUSH
18717: LD_INT 4
18719: PUSH
18720: LD_INT 2
18722: PUSH
18723: EMPTY
18724: LIST
18725: LIST
18726: LIST
18727: PUSH
18728: LD_INT 6
18730: PUSH
18731: LD_INT 3
18733: PUSH
18734: LD_INT 3
18736: PUSH
18737: EMPTY
18738: LIST
18739: LIST
18740: LIST
18741: PUSH
18742: EMPTY
18743: LIST
18744: LIST
18745: LIST
18746: ST_TO_ADDR
// artifactsReady := [ 0 , 0 , 0 ] ;
18747: LD_ADDR_EXP 73
18751: PUSH
18752: LD_INT 0
18754: PUSH
18755: LD_INT 0
18757: PUSH
18758: LD_INT 0
18760: PUSH
18761: EMPTY
18762: LIST
18763: LIST
18764: LIST
18765: ST_TO_ADDR
// end ;
18766: LD_VAR 0 1
18770: RET
// every 0 0$1 trigger GetTech ( tech_artifact , 7 ) = state_researched do var i , pos , j , labs , nearestLab ;
18771: LD_INT 24
18773: PPUSH
18774: LD_INT 7
18776: PPUSH
18777: CALL_OW 321
18781: PUSH
18782: LD_INT 2
18784: EQUAL
18785: IFFALSE 19711
18787: GO 18789
18789: DISABLE
18790: LD_INT 0
18792: PPUSH
18793: PPUSH
18794: PPUSH
18795: PPUSH
18796: PPUSH
// begin enable ;
18797: ENABLE
// for i = 1 to 3 do
18798: LD_ADDR_VAR 0 1
18802: PUSH
18803: DOUBLE
18804: LD_INT 1
18806: DEC
18807: ST_TO_ADDR
18808: LD_INT 3
18810: PUSH
18811: FOR_TO
18812: IFFALSE 19709
// begin pos := FindArtifact ( i + 2 ) ;
18814: LD_ADDR_VAR 0 2
18818: PUSH
18819: LD_VAR 0 1
18823: PUSH
18824: LD_INT 2
18826: PLUS
18827: PPUSH
18828: CALL_OW 469
18832: ST_TO_ADDR
// artifactsPos := Replace ( artifactsPos , i , pos ) ;
18833: LD_ADDR_EXP 64
18837: PUSH
18838: LD_EXP 64
18842: PPUSH
18843: LD_VAR 0 1
18847: PPUSH
18848: LD_VAR 0 2
18852: PPUSH
18853: CALL_OW 1
18857: ST_TO_ADDR
// if pos then
18858: LD_VAR 0 2
18862: IFFALSE 19570
// begin case i of 1 :
18864: LD_VAR 0 1
18868: PUSH
18869: LD_INT 1
18871: DOUBLE
18872: EQUAL
18873: IFTRUE 18877
18875: GO 18954
18877: POP
// labs := FilterAllUnits ( [ [ f_side , 7 ] , [ f_nation , 1 ] , [ f_or , [ f_btype , b_lab_full ] , [ f_btype , b_lab_half ] , [ f_btype , b_lab_siberium ] ] ] ) ; 2 :
18878: LD_ADDR_VAR 0 4
18882: PUSH
18883: LD_INT 22
18885: PUSH
18886: LD_INT 7
18888: PUSH
18889: EMPTY
18890: LIST
18891: LIST
18892: PUSH
18893: LD_INT 23
18895: PUSH
18896: LD_INT 1
18898: PUSH
18899: EMPTY
18900: LIST
18901: LIST
18902: PUSH
18903: LD_INT 2
18905: PUSH
18906: LD_INT 30
18908: PUSH
18909: LD_INT 8
18911: PUSH
18912: EMPTY
18913: LIST
18914: LIST
18915: PUSH
18916: LD_INT 30
18918: PUSH
18919: LD_INT 7
18921: PUSH
18922: EMPTY
18923: LIST
18924: LIST
18925: PUSH
18926: LD_INT 30
18928: PUSH
18929: LD_INT 11
18931: PUSH
18932: EMPTY
18933: LIST
18934: LIST
18935: PUSH
18936: EMPTY
18937: LIST
18938: LIST
18939: LIST
18940: LIST
18941: PUSH
18942: EMPTY
18943: LIST
18944: LIST
18945: LIST
18946: PPUSH
18947: CALL_OW 69
18951: ST_TO_ADDR
18952: GO 19062
18954: LD_INT 2
18956: DOUBLE
18957: EQUAL
18958: IFTRUE 18962
18960: GO 19039
18962: POP
// labs := FilterAllUnits ( [ [ f_side , 7 ] , [ f_nation , 3 ] , [ f_or , [ f_btype , b_lab_full ] , [ f_btype , b_lab_half ] , [ f_btype , b_lab_siberium ] ] ] ) ; 3 :
18963: LD_ADDR_VAR 0 4
18967: PUSH
18968: LD_INT 22
18970: PUSH
18971: LD_INT 7
18973: PUSH
18974: EMPTY
18975: LIST
18976: LIST
18977: PUSH
18978: LD_INT 23
18980: PUSH
18981: LD_INT 3
18983: PUSH
18984: EMPTY
18985: LIST
18986: LIST
18987: PUSH
18988: LD_INT 2
18990: PUSH
18991: LD_INT 30
18993: PUSH
18994: LD_INT 8
18996: PUSH
18997: EMPTY
18998: LIST
18999: LIST
19000: PUSH
19001: LD_INT 30
19003: PUSH
19004: LD_INT 7
19006: PUSH
19007: EMPTY
19008: LIST
19009: LIST
19010: PUSH
19011: LD_INT 30
19013: PUSH
19014: LD_INT 11
19016: PUSH
19017: EMPTY
19018: LIST
19019: LIST
19020: PUSH
19021: EMPTY
19022: LIST
19023: LIST
19024: LIST
19025: LIST
19026: PUSH
19027: EMPTY
19028: LIST
19029: LIST
19030: LIST
19031: PPUSH
19032: CALL_OW 69
19036: ST_TO_ADDR
19037: GO 19062
19039: LD_INT 3
19041: DOUBLE
19042: EQUAL
19043: IFTRUE 19047
19045: GO 19061
19047: POP
// labs := [ alien ] ; end ;
19048: LD_ADDR_VAR 0 4
19052: PUSH
19053: LD_INT 1
19055: PUSH
19056: EMPTY
19057: LIST
19058: ST_TO_ADDR
19059: GO 19062
19061: POP
// if not labs then
19062: LD_VAR 0 4
19066: NOT
19067: IFFALSE 19071
// continue ;
19069: GO 18811
// nearestLab := NearestUnitToXY ( labs , artifactsPos [ i ] [ 1 ] , artifactsPos [ i ] [ 2 ] ) ;
19071: LD_ADDR_VAR 0 5
19075: PUSH
19076: LD_VAR 0 4
19080: PPUSH
19081: LD_EXP 64
19085: PUSH
19086: LD_VAR 0 1
19090: ARRAY
19091: PUSH
19092: LD_INT 1
19094: ARRAY
19095: PPUSH
19096: LD_EXP 64
19100: PUSH
19101: LD_VAR 0 1
19105: ARRAY
19106: PUSH
19107: LD_INT 2
19109: ARRAY
19110: PPUSH
19111: CALL_OW 73
19115: ST_TO_ADDR
// if not nearestLab or nearestLab <> artifactsLabs [ i ] then
19116: LD_VAR 0 5
19120: NOT
19121: PUSH
19122: LD_VAR 0 5
19126: PUSH
19127: LD_EXP 71
19131: PUSH
19132: LD_VAR 0 1
19136: ARRAY
19137: NONEQUAL
19138: OR
19139: IFFALSE 19244
// begin SetArtifactUse ( 7 , artifactsButtons [ i ] [ 3 ] , art_no , artifactsLabs [ i ] ) ;
19141: LD_INT 7
19143: PPUSH
19144: LD_EXP 72
19148: PUSH
19149: LD_VAR 0 1
19153: ARRAY
19154: PUSH
19155: LD_INT 3
19157: ARRAY
19158: PPUSH
19159: LD_INT 0
19161: PPUSH
19162: LD_EXP 71
19166: PUSH
19167: LD_VAR 0 1
19171: ARRAY
19172: PPUSH
19173: CALL_OW 468
// SetArtifactUse ( 7 , artifactsButtons [ i ] [ 1 ] , art_no , artifactsLabs [ i ] ) ;
19177: LD_INT 7
19179: PPUSH
19180: LD_EXP 72
19184: PUSH
19185: LD_VAR 0 1
19189: ARRAY
19190: PUSH
19191: LD_INT 1
19193: ARRAY
19194: PPUSH
19195: LD_INT 0
19197: PPUSH
19198: LD_EXP 71
19202: PUSH
19203: LD_VAR 0 1
19207: ARRAY
19208: PPUSH
19209: CALL_OW 468
// if nearestLab then
19213: LD_VAR 0 5
19217: IFFALSE 19244
// artifactsLabs := Replace ( artifactsLabs , i , nearestLab ) ;
19219: LD_ADDR_EXP 71
19223: PUSH
19224: LD_EXP 71
19228: PPUSH
19229: LD_VAR 0 1
19233: PPUSH
19234: LD_VAR 0 5
19238: PPUSH
19239: CALL_OW 1
19243: ST_TO_ADDR
// end ; if not nearestLab then
19244: LD_VAR 0 5
19248: NOT
19249: IFFALSE 19253
// continue ;
19251: GO 18811
// if GetDistUnitXY ( nearestLab , artifactsPos [ i ] [ 1 ] , artifactsPos [ i ] [ 2 ] ) < 8 then
19253: LD_VAR 0 5
19257: PPUSH
19258: LD_EXP 64
19262: PUSH
19263: LD_VAR 0 1
19267: ARRAY
19268: PUSH
19269: LD_INT 1
19271: ARRAY
19272: PPUSH
19273: LD_EXP 64
19277: PUSH
19278: LD_VAR 0 1
19282: ARRAY
19283: PUSH
19284: LD_INT 2
19286: ARRAY
19287: PPUSH
19288: CALL_OW 297
19292: PUSH
19293: LD_INT 8
19295: LESS
19296: IFFALSE 19493
// begin if not artifactsResearched [ i ] then
19298: LD_EXP 67
19302: PUSH
19303: LD_VAR 0 1
19307: ARRAY
19308: NOT
19309: IFFALSE 19390
// begin if BuildingStatus ( nearestLab ) = bs_idle then
19311: LD_VAR 0 5
19315: PPUSH
19316: CALL_OW 461
19320: PUSH
19321: LD_INT 2
19323: EQUAL
19324: IFFALSE 19358
// SetArtifactUse ( 7 , artifactsButtons [ i ] [ 3 ] , art_instant , nearestLab ) else
19326: LD_INT 7
19328: PPUSH
19329: LD_EXP 72
19333: PUSH
19334: LD_VAR 0 1
19338: ARRAY
19339: PUSH
19340: LD_INT 3
19342: ARRAY
19343: PPUSH
19344: LD_INT 2
19346: PPUSH
19347: LD_VAR 0 5
19351: PPUSH
19352: CALL_OW 468
19356: GO 19388
// SetArtifactUse ( 7 , artifactsButtons [ i ] [ 3 ] , art_gray , nearestLab ) ;
19358: LD_INT 7
19360: PPUSH
19361: LD_EXP 72
19365: PUSH
19366: LD_VAR 0 1
19370: ARRAY
19371: PUSH
19372: LD_INT 3
19374: ARRAY
19375: PPUSH
19376: LD_INT 1
19378: PPUSH
19379: LD_VAR 0 5
19383: PPUSH
19384: CALL_OW 468
// end else
19388: GO 19491
// begin if BuildingStatus ( nearestLab ) = bs_idle and artifactsReady [ i ] then
19390: LD_VAR 0 5
19394: PPUSH
19395: CALL_OW 461
19399: PUSH
19400: LD_INT 2
19402: EQUAL
19403: PUSH
19404: LD_EXP 73
19408: PUSH
19409: LD_VAR 0 1
19413: ARRAY
19414: AND
19415: IFFALSE 19461
// SetArtifactUse ( 7 , artifactsButtons [ i ] [ 1 ] , artifactsButtons [ i ] [ 2 ] , nearestLab ) else
19417: LD_INT 7
19419: PPUSH
19420: LD_EXP 72
19424: PUSH
19425: LD_VAR 0 1
19429: ARRAY
19430: PUSH
19431: LD_INT 1
19433: ARRAY
19434: PPUSH
19435: LD_EXP 72
19439: PUSH
19440: LD_VAR 0 1
19444: ARRAY
19445: PUSH
19446: LD_INT 2
19448: ARRAY
19449: PPUSH
19450: LD_VAR 0 5
19454: PPUSH
19455: CALL_OW 468
19459: GO 19491
// SetArtifactUse ( 7 , artifactsButtons [ i ] [ 1 ] , art_gray , nearestLab ) end ;
19461: LD_INT 7
19463: PPUSH
19464: LD_EXP 72
19468: PUSH
19469: LD_VAR 0 1
19473: ARRAY
19474: PUSH
19475: LD_INT 1
19477: ARRAY
19478: PPUSH
19479: LD_INT 1
19481: PPUSH
19482: LD_VAR 0 5
19486: PPUSH
19487: CALL_OW 468
// end else
19491: GO 19568
// begin if not artifactsResearched [ i ] then
19493: LD_EXP 67
19497: PUSH
19498: LD_VAR 0 1
19502: ARRAY
19503: NOT
19504: IFFALSE 19538
// SetArtifactUse ( 7 , artifactsButtons [ i ] [ 3 ] , art_no , nearestLab ) else
19506: LD_INT 7
19508: PPUSH
19509: LD_EXP 72
19513: PUSH
19514: LD_VAR 0 1
19518: ARRAY
19519: PUSH
19520: LD_INT 3
19522: ARRAY
19523: PPUSH
19524: LD_INT 0
19526: PPUSH
19527: LD_VAR 0 5
19531: PPUSH
19532: CALL_OW 468
19536: GO 19568
// SetArtifactUse ( 7 , artifactsButtons [ i ] [ 1 ] , art_no , nearestLab ) ;
19538: LD_INT 7
19540: PPUSH
19541: LD_EXP 72
19545: PUSH
19546: LD_VAR 0 1
19550: ARRAY
19551: PUSH
19552: LD_INT 1
19554: ARRAY
19555: PPUSH
19556: LD_INT 0
19558: PPUSH
19559: LD_VAR 0 5
19563: PPUSH
19564: CALL_OW 468
// end ; end else
19568: GO 19707
// begin if not artifactsLabs [ i ] then
19570: LD_EXP 71
19574: PUSH
19575: LD_VAR 0 1
19579: ARRAY
19580: NOT
19581: IFFALSE 19585
// continue ;
19583: GO 18811
// SetArtifactUse ( 7 , artifactsButtons [ i ] [ 3 ] , art_no , artifactsLabs [ i ] ) ;
19585: LD_INT 7
19587: PPUSH
19588: LD_EXP 72
19592: PUSH
19593: LD_VAR 0 1
19597: ARRAY
19598: PUSH
19599: LD_INT 3
19601: ARRAY
19602: PPUSH
19603: LD_INT 0
19605: PPUSH
19606: LD_EXP 71
19610: PUSH
19611: LD_VAR 0 1
19615: ARRAY
19616: PPUSH
19617: CALL_OW 468
// SetArtifactUse ( 7 , artifactsButtons [ i ] [ 1 ] , art_no , artifactsLabs [ i ] ) ;
19621: LD_INT 7
19623: PPUSH
19624: LD_EXP 72
19628: PUSH
19629: LD_VAR 0 1
19633: ARRAY
19634: PUSH
19635: LD_INT 1
19637: ARRAY
19638: PPUSH
19639: LD_INT 0
19641: PPUSH
19642: LD_EXP 71
19646: PUSH
19647: LD_VAR 0 1
19651: ARRAY
19652: PPUSH
19653: CALL_OW 468
// if artifactsLabsWorking [ i ] then
19657: LD_EXP 68
19661: PUSH
19662: LD_VAR 0 1
19666: ARRAY
19667: IFFALSE 19707
// begin artifactsLabsWorking := Replace ( artifactsLabsWorking , i , false ) ;
19669: LD_ADDR_EXP 68
19673: PUSH
19674: LD_EXP 68
19678: PPUSH
19679: LD_VAR 0 1
19683: PPUSH
19684: LD_INT 0
19686: PPUSH
19687: CALL_OW 1
19691: ST_TO_ADDR
// ComCancel ( artifactsLabs [ i ] ) ;
19692: LD_EXP 71
19696: PUSH
19697: LD_VAR 0 1
19701: ARRAY
19702: PPUSH
19703: CALL_OW 127
// end ; end ; end ;
19707: GO 18811
19709: POP
19710: POP
// end ;
19711: PPOPN 5
19713: END
// on ArtifactUsed ( side , icon , x , y ) do var i , lab , time , list , un ;
19714: LD_INT 0
19716: PPUSH
19717: PPUSH
19718: PPUSH
19719: PPUSH
19720: PPUSH
// begin if icon = artifactsButtons [ 1 ] [ 3 ] then
19721: LD_VAR 0 2
19725: PUSH
19726: LD_EXP 72
19730: PUSH
19731: LD_INT 1
19733: ARRAY
19734: PUSH
19735: LD_INT 3
19737: ARRAY
19738: EQUAL
19739: IFFALSE 19862
// begin lab := artifactsLabs [ 1 ] ;
19741: LD_ADDR_VAR 0 6
19745: PUSH
19746: LD_EXP 71
19750: PUSH
19751: LD_INT 1
19753: ARRAY
19754: ST_TO_ADDR
// if not lab then
19755: LD_VAR 0 6
19759: NOT
19760: IFFALSE 19764
// exit ;
19762: GO 20842
// SetSpecResearch ( lab , artifactsResDifficulty [ 1 ] , true ) ;
19764: LD_VAR 0 6
19768: PPUSH
19769: LD_EXP 69
19773: PUSH
19774: LD_INT 1
19776: ARRAY
19777: PPUSH
19778: LD_INT 1
19780: PPUSH
19781: CALL_OW 486
// if artifactsResProgress [ 1 ] then
19785: LD_EXP 70
19789: PUSH
19790: LD_INT 1
19792: ARRAY
19793: IFFALSE 19813
// SetWorkingProgress ( lab , artifactsResProgress [ 1 ] ) ;
19795: LD_VAR 0 6
19799: PPUSH
19800: LD_EXP 70
19804: PUSH
19805: LD_INT 1
19807: ARRAY
19808: PPUSH
19809: CALL_OW 329
// artifactsLabsWorking := Replace ( artifactsLabsWorking , 1 , 1 ) ;
19813: LD_ADDR_EXP 68
19817: PUSH
19818: LD_EXP 68
19822: PPUSH
19823: LD_INT 1
19825: PPUSH
19826: LD_INT 1
19828: PPUSH
19829: CALL_OW 1
19833: ST_TO_ADDR
// SetArtifactUse ( 7 , artifactsButtons [ 1 ] [ 3 ] , art_no , lab ) ;
19834: LD_INT 7
19836: PPUSH
19837: LD_EXP 72
19841: PUSH
19842: LD_INT 1
19844: ARRAY
19845: PUSH
19846: LD_INT 3
19848: ARRAY
19849: PPUSH
19850: LD_INT 0
19852: PPUSH
19853: LD_VAR 0 6
19857: PPUSH
19858: CALL_OW 468
// end ; if icon = artifactsButtons [ 2 ] [ 3 ] then
19862: LD_VAR 0 2
19866: PUSH
19867: LD_EXP 72
19871: PUSH
19872: LD_INT 2
19874: ARRAY
19875: PUSH
19876: LD_INT 3
19878: ARRAY
19879: EQUAL
19880: IFFALSE 20003
// begin lab := artifactsLabs [ 2 ] ;
19882: LD_ADDR_VAR 0 6
19886: PUSH
19887: LD_EXP 71
19891: PUSH
19892: LD_INT 2
19894: ARRAY
19895: ST_TO_ADDR
// if not lab then
19896: LD_VAR 0 6
19900: NOT
19901: IFFALSE 19905
// exit ;
19903: GO 20842
// SetSpecResearch ( lab , artifactsResDifficulty [ 2 ] , true ) ;
19905: LD_VAR 0 6
19909: PPUSH
19910: LD_EXP 69
19914: PUSH
19915: LD_INT 2
19917: ARRAY
19918: PPUSH
19919: LD_INT 1
19921: PPUSH
19922: CALL_OW 486
// if artifactsResProgress [ 2 ] then
19926: LD_EXP 70
19930: PUSH
19931: LD_INT 2
19933: ARRAY
19934: IFFALSE 19954
// SetWorkingProgress ( lab , artifactsResProgress [ 2 ] ) ;
19936: LD_VAR 0 6
19940: PPUSH
19941: LD_EXP 70
19945: PUSH
19946: LD_INT 2
19948: ARRAY
19949: PPUSH
19950: CALL_OW 329
// artifactsLabsWorking := Replace ( artifactsLabsWorking , 2 , 1 ) ;
19954: LD_ADDR_EXP 68
19958: PUSH
19959: LD_EXP 68
19963: PPUSH
19964: LD_INT 2
19966: PPUSH
19967: LD_INT 1
19969: PPUSH
19970: CALL_OW 1
19974: ST_TO_ADDR
// SetArtifactUse ( 7 , artifactsButtons [ 2 ] [ 3 ] , art_no , lab ) ;
19975: LD_INT 7
19977: PPUSH
19978: LD_EXP 72
19982: PUSH
19983: LD_INT 2
19985: ARRAY
19986: PUSH
19987: LD_INT 3
19989: ARRAY
19990: PPUSH
19991: LD_INT 0
19993: PPUSH
19994: LD_VAR 0 6
19998: PPUSH
19999: CALL_OW 468
// end ; if icon = artifactsButtons [ 3 ] [ 3 ] then
20003: LD_VAR 0 2
20007: PUSH
20008: LD_EXP 72
20012: PUSH
20013: LD_INT 3
20015: ARRAY
20016: PUSH
20017: LD_INT 3
20019: ARRAY
20020: EQUAL
20021: IFFALSE 20144
// begin lab := artifactsLabs [ 3 ] ;
20023: LD_ADDR_VAR 0 6
20027: PUSH
20028: LD_EXP 71
20032: PUSH
20033: LD_INT 3
20035: ARRAY
20036: ST_TO_ADDR
// if not lab then
20037: LD_VAR 0 6
20041: NOT
20042: IFFALSE 20046
// exit ;
20044: GO 20842
// SetSpecResearch ( lab , artifactsResDifficulty [ 3 ] , true ) ;
20046: LD_VAR 0 6
20050: PPUSH
20051: LD_EXP 69
20055: PUSH
20056: LD_INT 3
20058: ARRAY
20059: PPUSH
20060: LD_INT 1
20062: PPUSH
20063: CALL_OW 486
// if artifactsResProgress [ 3 ] then
20067: LD_EXP 70
20071: PUSH
20072: LD_INT 3
20074: ARRAY
20075: IFFALSE 20095
// SetWorkingProgress ( lab , artifactsResProgress [ 3 ] ) ;
20077: LD_VAR 0 6
20081: PPUSH
20082: LD_EXP 70
20086: PUSH
20087: LD_INT 3
20089: ARRAY
20090: PPUSH
20091: CALL_OW 329
// artifactsLabsWorking := Replace ( artifactsLabsWorking , 3 , 1 ) ;
20095: LD_ADDR_EXP 68
20099: PUSH
20100: LD_EXP 68
20104: PPUSH
20105: LD_INT 3
20107: PPUSH
20108: LD_INT 1
20110: PPUSH
20111: CALL_OW 1
20115: ST_TO_ADDR
// SetArtifactUse ( 7 , artifactsButtons [ 3 ] [ 3 ] , art_no , lab ) ;
20116: LD_INT 7
20118: PPUSH
20119: LD_EXP 72
20123: PUSH
20124: LD_INT 3
20126: ARRAY
20127: PUSH
20128: LD_INT 3
20130: ARRAY
20131: PPUSH
20132: LD_INT 0
20134: PPUSH
20135: LD_VAR 0 6
20139: PPUSH
20140: CALL_OW 468
// end ; if icon = artifactsButtons [ 1 ] [ 1 ] then
20144: LD_VAR 0 2
20148: PUSH
20149: LD_EXP 72
20153: PUSH
20154: LD_INT 1
20156: ARRAY
20157: PUSH
20158: LD_INT 1
20160: ARRAY
20161: EQUAL
20162: IFFALSE 20320
// begin lab := artifactsLabs [ 1 ] ;
20164: LD_ADDR_VAR 0 6
20168: PUSH
20169: LD_EXP 71
20173: PUSH
20174: LD_INT 1
20176: ARRAY
20177: ST_TO_ADDR
// if GetBaseMaterials ( GetBase ( lab ) ) [ 3 ] < artifactsSibCost [ 1 ] then
20178: LD_VAR 0 6
20182: PPUSH
20183: CALL_OW 274
20187: PPUSH
20188: CALL 88942 0 1
20192: PUSH
20193: LD_INT 3
20195: ARRAY
20196: PUSH
20197: LD_EXP 66
20201: PUSH
20202: LD_INT 1
20204: ARRAY
20205: LESS
20206: IFFALSE 20220
// begin HintSpec ( ArtifactCost , 2 ) ;
20208: LD_STRING ArtifactCost
20210: PPUSH
20211: LD_INT 2
20213: PPUSH
20214: CALL_OW 338
// exit ;
20218: GO 20842
// end ; artifactsReady := Replace ( artifactsReady , 1 , false ) ;
20220: LD_ADDR_EXP 73
20224: PUSH
20225: LD_EXP 73
20229: PPUSH
20230: LD_INT 1
20232: PPUSH
20233: LD_INT 0
20235: PPUSH
20236: CALL_OW 1
20240: ST_TO_ADDR
// PlaceSeeing ( x , y , 7 , - 12 ) ;
20241: LD_VAR 0 3
20245: PPUSH
20246: LD_VAR 0 4
20250: PPUSH
20251: LD_INT 7
20253: PPUSH
20254: LD_INT 12
20256: NEG
20257: PPUSH
20258: CALL_OW 330
// wait ( 0 0$30 ) ;
20262: LD_INT 1050
20264: PPUSH
20265: CALL_OW 67
// RemoveSeeing ( x , y , 7 ) ;
20269: LD_VAR 0 3
20273: PPUSH
20274: LD_VAR 0 4
20278: PPUSH
20279: LD_INT 7
20281: PPUSH
20282: CALL_OW 331
// wait ( artifactsRecharge [ 1 ] ) ;
20286: LD_EXP 65
20290: PUSH
20291: LD_INT 1
20293: ARRAY
20294: PPUSH
20295: CALL_OW 67
// artifactsReady := Replace ( artifactsReady , 1 , true ) ;
20299: LD_ADDR_EXP 73
20303: PUSH
20304: LD_EXP 73
20308: PPUSH
20309: LD_INT 1
20311: PPUSH
20312: LD_INT 1
20314: PPUSH
20315: CALL_OW 1
20319: ST_TO_ADDR
// end ; if icon = artifactsButtons [ 2 ] [ 1 ] then
20320: LD_VAR 0 2
20324: PUSH
20325: LD_EXP 72
20329: PUSH
20330: LD_INT 2
20332: ARRAY
20333: PUSH
20334: LD_INT 1
20336: ARRAY
20337: EQUAL
20338: IFFALSE 20575
// begin lab := artifactsLabs [ 2 ] ;
20340: LD_ADDR_VAR 0 6
20344: PUSH
20345: LD_EXP 71
20349: PUSH
20350: LD_INT 2
20352: ARRAY
20353: ST_TO_ADDR
// if not x in FilterAllUnits ( [ [ f_enemy , 7 ] , [ f_or , [ f_engine , engine_siberite ] , [ f_btype , b_siberite_power ] , [ f_btype , b_siberite_mine ] , [ f_bweapon , ru_time_lapser ] , [ f_weapon , ru_time_lapser ] , [ f_btype , b_ext_siberium ] ] ] ) then
20354: LD_VAR 0 3
20358: PUSH
20359: LD_INT 81
20361: PUSH
20362: LD_INT 7
20364: PUSH
20365: EMPTY
20366: LIST
20367: LIST
20368: PUSH
20369: LD_INT 2
20371: PUSH
20372: LD_INT 32
20374: PUSH
20375: LD_INT 3
20377: PUSH
20378: EMPTY
20379: LIST
20380: LIST
20381: PUSH
20382: LD_INT 30
20384: PUSH
20385: LD_INT 28
20387: PUSH
20388: EMPTY
20389: LIST
20390: LIST
20391: PUSH
20392: LD_INT 30
20394: PUSH
20395: LD_INT 30
20397: PUSH
20398: EMPTY
20399: LIST
20400: LIST
20401: PUSH
20402: LD_INT 35
20404: PUSH
20405: LD_INT 49
20407: PUSH
20408: EMPTY
20409: LIST
20410: LIST
20411: PUSH
20412: LD_INT 34
20414: PUSH
20415: LD_INT 49
20417: PUSH
20418: EMPTY
20419: LIST
20420: LIST
20421: PUSH
20422: LD_INT 30
20424: PUSH
20425: LD_INT 21
20427: PUSH
20428: EMPTY
20429: LIST
20430: LIST
20431: PUSH
20432: EMPTY
20433: LIST
20434: LIST
20435: LIST
20436: LIST
20437: LIST
20438: LIST
20439: LIST
20440: PUSH
20441: EMPTY
20442: LIST
20443: LIST
20444: PPUSH
20445: CALL_OW 69
20449: IN
20450: NOT
20451: IFFALSE 20455
// exit ;
20453: GO 20842
// if GetBaseMaterials ( GetBase ( lab ) ) [ 3 ] < artifactsSibCost [ 2 ] then
20455: LD_VAR 0 6
20459: PPUSH
20460: CALL_OW 274
20464: PPUSH
20465: CALL 88942 0 1
20469: PUSH
20470: LD_INT 3
20472: ARRAY
20473: PUSH
20474: LD_EXP 66
20478: PUSH
20479: LD_INT 2
20481: ARRAY
20482: LESS
20483: IFFALSE 20497
// begin HintSpec ( ArtifactCost , 2 ) ;
20485: LD_STRING ArtifactCost
20487: PPUSH
20488: LD_INT 2
20490: PPUSH
20491: CALL_OW 338
// exit ;
20495: GO 20842
// end ; artifactsReady := Replace ( artifactsReady , 2 , false ) ;
20497: LD_ADDR_EXP 73
20501: PUSH
20502: LD_EXP 73
20506: PPUSH
20507: LD_INT 2
20509: PPUSH
20510: LD_INT 0
20512: PPUSH
20513: CALL_OW 1
20517: ST_TO_ADDR
// KillUnit ( x ) ;
20518: LD_VAR 0 3
20522: PPUSH
20523: CALL_OW 66
// artifactDestroyCounter := artifactDestroyCounter + 1 ;
20527: LD_ADDR_EXP 16
20531: PUSH
20532: LD_EXP 16
20536: PUSH
20537: LD_INT 1
20539: PLUS
20540: ST_TO_ADDR
// wait ( artifactsRecharge [ 2 ] ) ;
20541: LD_EXP 65
20545: PUSH
20546: LD_INT 2
20548: ARRAY
20549: PPUSH
20550: CALL_OW 67
// artifactsReady := Replace ( artifactsReady , 2 , true ) ;
20554: LD_ADDR_EXP 73
20558: PUSH
20559: LD_EXP 73
20563: PPUSH
20564: LD_INT 2
20566: PPUSH
20567: LD_INT 1
20569: PPUSH
20570: CALL_OW 1
20574: ST_TO_ADDR
// end ; if icon = artifactsButtons [ 3 ] [ 1 ] then
20575: LD_VAR 0 2
20579: PUSH
20580: LD_EXP 72
20584: PUSH
20585: LD_INT 3
20587: ARRAY
20588: PUSH
20589: LD_INT 1
20591: ARRAY
20592: EQUAL
20593: IFFALSE 20842
// begin lab := artifactsLabs [ 3 ] ;
20595: LD_ADDR_VAR 0 6
20599: PUSH
20600: LD_EXP 71
20604: PUSH
20605: LD_INT 3
20607: ARRAY
20608: ST_TO_ADDR
// if GetBaseMaterials ( GetBase ( lab ) ) [ 3 ] < artifactsSibCost [ 3 ] then
20609: LD_VAR 0 6
20613: PPUSH
20614: CALL_OW 274
20618: PPUSH
20619: CALL 88942 0 1
20623: PUSH
20624: LD_INT 3
20626: ARRAY
20627: PUSH
20628: LD_EXP 66
20632: PUSH
20633: LD_INT 3
20635: ARRAY
20636: LESS
20637: IFFALSE 20651
// begin HintSpec ( ArtifactCost , 2 ) ;
20639: LD_STRING ArtifactCost
20641: PPUSH
20642: LD_INT 2
20644: PPUSH
20645: CALL_OW 338
// exit ;
20649: GO 20842
// end ; SetAreaMapShow ( teleportArea , 1 ) ;
20651: LD_INT 37
20653: PPUSH
20654: LD_INT 1
20656: PPUSH
20657: CALL_OW 424
// time := 0 0$30 ;
20661: LD_ADDR_VAR 0 7
20665: PUSH
20666: LD_INT 1050
20668: ST_TO_ADDR
// artifactsReady := Replace ( artifactsReady , 3 , false ) ;
20669: LD_ADDR_EXP 73
20673: PUSH
20674: LD_EXP 73
20678: PPUSH
20679: LD_INT 3
20681: PPUSH
20682: LD_INT 0
20684: PPUSH
20685: CALL_OW 1
20689: ST_TO_ADDR
// repeat display_strings := [ #Am15a-1 , time ] ;
20690: LD_ADDR_OWVAR 47
20694: PUSH
20695: LD_STRING #Am15a-1
20697: PUSH
20698: LD_VAR 0 7
20702: PUSH
20703: EMPTY
20704: LIST
20705: LIST
20706: ST_TO_ADDR
// wait ( 0 0$1 ) ;
20707: LD_INT 35
20709: PPUSH
20710: CALL_OW 67
// time := time - 0 0$1 ;
20714: LD_ADDR_VAR 0 7
20718: PUSH
20719: LD_VAR 0 7
20723: PUSH
20724: LD_INT 35
20726: MINUS
20727: ST_TO_ADDR
// until time = 0 0$00 ;
20728: LD_VAR 0 7
20732: PUSH
20733: LD_INT 0
20735: EQUAL
20736: IFFALSE 20690
// display_strings :=  ;
20738: LD_ADDR_OWVAR 47
20742: PUSH
20743: LD_STRING 
20745: ST_TO_ADDR
// SetAreaMapShow ( teleportArea , 0 ) ;
20746: LD_INT 37
20748: PPUSH
20749: LD_INT 0
20751: PPUSH
20752: CALL_OW 424
// list := FilterUnitsInArea ( teleportArea , [ f_not , [ f_type , unit_building ] ] ) ;
20756: LD_ADDR_VAR 0 8
20760: PUSH
20761: LD_INT 37
20763: PPUSH
20764: LD_INT 3
20766: PUSH
20767: LD_INT 21
20769: PUSH
20770: LD_INT 3
20772: PUSH
20773: EMPTY
20774: LIST
20775: LIST
20776: PUSH
20777: EMPTY
20778: LIST
20779: LIST
20780: PPUSH
20781: CALL_OW 70
20785: ST_TO_ADDR
// CenterOnXY ( x , y ) ;
20786: LD_VAR 0 3
20790: PPUSH
20791: LD_VAR 0 4
20795: PPUSH
20796: CALL_OW 84
// for un in list do
20800: LD_ADDR_VAR 0 9
20804: PUSH
20805: LD_VAR 0 8
20809: PUSH
20810: FOR_IN
20811: IFFALSE 20840
// TeleportUnit ( un , x , y , 12 , true ) ;
20813: LD_VAR 0 9
20817: PPUSH
20818: LD_VAR 0 3
20822: PPUSH
20823: LD_VAR 0 4
20827: PPUSH
20828: LD_INT 12
20830: PPUSH
20831: LD_INT 1
20833: PPUSH
20834: CALL_OW 483
20838: GO 20810
20840: POP
20841: POP
// end ; end ;
20842: PPOPN 9
20844: END
// on SpecResearchCancel ( lab , progress ) do var i , labNum ;
20845: LD_INT 0
20847: PPUSH
20848: PPUSH
// begin labNum := 0 ;
20849: LD_ADDR_VAR 0 4
20853: PUSH
20854: LD_INT 0
20856: ST_TO_ADDR
// for i = 1 to artifactsLabs do
20857: LD_ADDR_VAR 0 3
20861: PUSH
20862: DOUBLE
20863: LD_INT 1
20865: DEC
20866: ST_TO_ADDR
20867: LD_EXP 71
20871: PUSH
20872: FOR_TO
20873: IFFALSE 20907
// if artifactsLabs [ i ] = lab then
20875: LD_EXP 71
20879: PUSH
20880: LD_VAR 0 3
20884: ARRAY
20885: PUSH
20886: LD_VAR 0 1
20890: EQUAL
20891: IFFALSE 20905
// begin labNum := i ;
20893: LD_ADDR_VAR 0 4
20897: PUSH
20898: LD_VAR 0 3
20902: ST_TO_ADDR
// break ;
20903: GO 20907
// end ;
20905: GO 20872
20907: POP
20908: POP
// if not labNum then
20909: LD_VAR 0 4
20913: NOT
20914: IFFALSE 20918
// exit ;
20916: GO 20996
// SetArtifactUse ( 7 , artifactsButtons [ labNum ] [ 3 ] , art_instant , lab ) ;
20918: LD_INT 7
20920: PPUSH
20921: LD_EXP 72
20925: PUSH
20926: LD_VAR 0 4
20930: ARRAY
20931: PUSH
20932: LD_INT 3
20934: ARRAY
20935: PPUSH
20936: LD_INT 2
20938: PPUSH
20939: LD_VAR 0 1
20943: PPUSH
20944: CALL_OW 468
// artifactsResProgress := Replace ( artifactsResProgress , labNum , progress ) ;
20948: LD_ADDR_EXP 70
20952: PUSH
20953: LD_EXP 70
20957: PPUSH
20958: LD_VAR 0 4
20962: PPUSH
20963: LD_VAR 0 2
20967: PPUSH
20968: CALL_OW 1
20972: ST_TO_ADDR
// artifactsLabsWorking := Replace ( artifactsLabsWorking , labNum , 0 ) ;
20973: LD_ADDR_EXP 68
20977: PUSH
20978: LD_EXP 68
20982: PPUSH
20983: LD_VAR 0 4
20987: PPUSH
20988: LD_INT 0
20990: PPUSH
20991: CALL_OW 1
20995: ST_TO_ADDR
// end ;
20996: PPOPN 4
20998: END
// on SpecResearchComplete ( lab ) do var i , labNum ;
20999: LD_INT 0
21001: PPUSH
21002: PPUSH
// begin labNum := 0 ;
21003: LD_ADDR_VAR 0 3
21007: PUSH
21008: LD_INT 0
21010: ST_TO_ADDR
// for i = 1 to artifactsLabs do
21011: LD_ADDR_VAR 0 2
21015: PUSH
21016: DOUBLE
21017: LD_INT 1
21019: DEC
21020: ST_TO_ADDR
21021: LD_EXP 71
21025: PUSH
21026: FOR_TO
21027: IFFALSE 21061
// if artifactsLabs [ i ] = lab then
21029: LD_EXP 71
21033: PUSH
21034: LD_VAR 0 2
21038: ARRAY
21039: PUSH
21040: LD_VAR 0 1
21044: EQUAL
21045: IFFALSE 21059
// begin labNum := i ;
21047: LD_ADDR_VAR 0 3
21051: PUSH
21052: LD_VAR 0 2
21056: ST_TO_ADDR
// break ;
21057: GO 21061
// end ;
21059: GO 21026
21061: POP
21062: POP
// if not labNum then
21063: LD_VAR 0 3
21067: NOT
21068: IFFALSE 21072
// exit ;
21070: GO 21234
// SetArtifactUse ( 7 , artifactsButtons [ labNum ] [ 3 ] , art_no , lab ) ;
21072: LD_INT 7
21074: PPUSH
21075: LD_EXP 72
21079: PUSH
21080: LD_VAR 0 3
21084: ARRAY
21085: PUSH
21086: LD_INT 3
21088: ARRAY
21089: PPUSH
21090: LD_INT 0
21092: PPUSH
21093: LD_VAR 0 1
21097: PPUSH
21098: CALL_OW 468
// artifactsResearched := Replace ( artifactsResearched , labNum , true ) ;
21102: LD_ADDR_EXP 67
21106: PUSH
21107: LD_EXP 67
21111: PPUSH
21112: LD_VAR 0 3
21116: PPUSH
21117: LD_INT 1
21119: PPUSH
21120: CALL_OW 1
21124: ST_TO_ADDR
// artifactsReady := Replace ( artifactsReady , labNum , true ) ;
21125: LD_ADDR_EXP 73
21129: PUSH
21130: LD_EXP 73
21134: PPUSH
21135: LD_VAR 0 3
21139: PPUSH
21140: LD_INT 1
21142: PPUSH
21143: CALL_OW 1
21147: ST_TO_ADDR
// artifactsLabsWorking := Replace ( artifactsLabsWorking , labNum , false ) ;
21148: LD_ADDR_EXP 68
21152: PUSH
21153: LD_EXP 68
21157: PPUSH
21158: LD_VAR 0 3
21162: PPUSH
21163: LD_INT 0
21165: PPUSH
21166: CALL_OW 1
21170: ST_TO_ADDR
// case labNum of 1 :
21171: LD_VAR 0 3
21175: PUSH
21176: LD_INT 1
21178: DOUBLE
21179: EQUAL
21180: IFTRUE 21184
21182: GO 21195
21184: POP
// artifactIResearched := true ; 2 :
21185: LD_ADDR_EXP 12
21189: PUSH
21190: LD_INT 1
21192: ST_TO_ADDR
21193: GO 21234
21195: LD_INT 2
21197: DOUBLE
21198: EQUAL
21199: IFTRUE 21203
21201: GO 21214
21203: POP
// artifactIIResearched := true ; 3 :
21204: LD_ADDR_EXP 13
21208: PUSH
21209: LD_INT 1
21211: ST_TO_ADDR
21212: GO 21234
21214: LD_INT 3
21216: DOUBLE
21217: EQUAL
21218: IFTRUE 21222
21220: GO 21233
21222: POP
// artifactIIIResearched := true ; end ;
21223: LD_ADDR_EXP 14
21227: PUSH
21228: LD_INT 1
21230: ST_TO_ADDR
21231: GO 21234
21233: POP
// end ; end_of_file
21234: PPOPN 3
21236: END
// export ru_radar , ru_big_cargo_bay , us_hack , us_artillery , ar_bio_bomb , ar_mortar , ar_crane , ar_miner ; export tech_Artillery , tech_RadMat , tech_BasicTools , tech_Cargo , tech_Track , tech_Crane , tech_Bulldozer , tech_Hovercraft , tech_MultiBarrels ; export class_mastodont , class_horse ; export function InitGlobalVariables ; begin
21237: LD_INT 0
21239: PPUSH
// ar_miner := 81 ;
21240: LD_ADDR_EXP 81
21244: PUSH
21245: LD_INT 81
21247: ST_TO_ADDR
// ar_crane := 88 ;
21248: LD_ADDR_EXP 80
21252: PUSH
21253: LD_INT 88
21255: ST_TO_ADDR
// ru_big_cargo_bay := 89 ;
21256: LD_ADDR_EXP 75
21260: PUSH
21261: LD_INT 89
21263: ST_TO_ADDR
// us_hack := 99 ;
21264: LD_ADDR_EXP 76
21268: PUSH
21269: LD_INT 99
21271: ST_TO_ADDR
// us_artillery := 97 ;
21272: LD_ADDR_EXP 77
21276: PUSH
21277: LD_INT 97
21279: ST_TO_ADDR
// ar_bio_bomb := 91 ;
21280: LD_ADDR_EXP 78
21284: PUSH
21285: LD_INT 91
21287: ST_TO_ADDR
// ar_mortar := 92 ;
21288: LD_ADDR_EXP 79
21292: PUSH
21293: LD_INT 92
21295: ST_TO_ADDR
// ru_radar := 98 ;
21296: LD_ADDR_EXP 74
21300: PUSH
21301: LD_INT 98
21303: ST_TO_ADDR
// tech_Artillery := 80 ;
21304: LD_ADDR_EXP 82
21308: PUSH
21309: LD_INT 80
21311: ST_TO_ADDR
// tech_RadMat := 81 ;
21312: LD_ADDR_EXP 83
21316: PUSH
21317: LD_INT 81
21319: ST_TO_ADDR
// tech_BasicTools := 82 ;
21320: LD_ADDR_EXP 84
21324: PUSH
21325: LD_INT 82
21327: ST_TO_ADDR
// tech_Cargo := 83 ;
21328: LD_ADDR_EXP 85
21332: PUSH
21333: LD_INT 83
21335: ST_TO_ADDR
// tech_Track := 84 ;
21336: LD_ADDR_EXP 86
21340: PUSH
21341: LD_INT 84
21343: ST_TO_ADDR
// tech_Crane := 85 ;
21344: LD_ADDR_EXP 87
21348: PUSH
21349: LD_INT 85
21351: ST_TO_ADDR
// tech_Bulldozer := 86 ;
21352: LD_ADDR_EXP 88
21356: PUSH
21357: LD_INT 86
21359: ST_TO_ADDR
// tech_Hovercraft := 87 ;
21360: LD_ADDR_EXP 89
21364: PUSH
21365: LD_INT 87
21367: ST_TO_ADDR
// tech_MultiBarrels := 88 ;
21368: LD_ADDR_EXP 90
21372: PUSH
21373: LD_INT 88
21375: ST_TO_ADDR
// class_mastodont := 31 ;
21376: LD_ADDR_EXP 91
21380: PUSH
21381: LD_INT 31
21383: ST_TO_ADDR
// class_horse := 21 ;
21384: LD_ADDR_EXP 92
21388: PUSH
21389: LD_INT 21
21391: ST_TO_ADDR
// end ;
21392: LD_VAR 0 1
21396: RET
// every 1 do
21397: GO 21399
21399: DISABLE
// InitGlobalVariables ; end_of_file
21400: CALL 21237 0 0
21404: END
// export skirmish , debug_mc ; export mc_bases , mc_building_need_repair , mc_building_repairs , mc_need_heal , mc_healers , mc_build_list , mc_builders , mc_construct_list , mc_turret_list , mc_empty_turret_list , mc_busy_turret_list , mc_defender_limit , mc_repair_vehicle , mc_mines , mc_miners , mc_minefields , mc_crates , mc_crates_collector , mc_crates_area , mc_vehicles , mc_attack , mc_produce , mc_defender , mc_scan , mc_parking , mc_scan_area , mc_sides , mc_tech , mc_can_tame , mc_ape , mc_ape_in_lab , mc_taming , mc_build_upgrade , mc_lab , mc_lab_upgrade , mc_teleport_exit , mc_teleport_exit_set , mc_deposits_xy , mc_deposits_finder , mc_allowed_tower_weapons , mc_remote_driver , mc_class , mc_class_case_use , mc_is_defending ; export function InitMacro ; var i ; begin
21405: LD_INT 0
21407: PPUSH
21408: PPUSH
// skirmish := false ;
21409: LD_ADDR_EXP 93
21413: PUSH
21414: LD_INT 0
21416: ST_TO_ADDR
// debug_mc := false ;
21417: LD_ADDR_EXP 94
21421: PUSH
21422: LD_INT 0
21424: ST_TO_ADDR
// mc_bases := [ ] ;
21425: LD_ADDR_EXP 95
21429: PUSH
21430: EMPTY
21431: ST_TO_ADDR
// mc_sides := [ ] ;
21432: LD_ADDR_EXP 121
21436: PUSH
21437: EMPTY
21438: ST_TO_ADDR
// mc_building_need_repair := [ ] ;
21439: LD_ADDR_EXP 96
21443: PUSH
21444: EMPTY
21445: ST_TO_ADDR
// mc_building_repairs := [ ] ;
21446: LD_ADDR_EXP 97
21450: PUSH
21451: EMPTY
21452: ST_TO_ADDR
// mc_need_heal := [ ] ;
21453: LD_ADDR_EXP 98
21457: PUSH
21458: EMPTY
21459: ST_TO_ADDR
// mc_healers := [ ] ;
21460: LD_ADDR_EXP 99
21464: PUSH
21465: EMPTY
21466: ST_TO_ADDR
// mc_build_list := [ ] ;
21467: LD_ADDR_EXP 100
21471: PUSH
21472: EMPTY
21473: ST_TO_ADDR
// mc_build_upgrade := [ ] ;
21474: LD_ADDR_EXP 127
21478: PUSH
21479: EMPTY
21480: ST_TO_ADDR
// mc_builders := [ ] ;
21481: LD_ADDR_EXP 101
21485: PUSH
21486: EMPTY
21487: ST_TO_ADDR
// mc_construct_list := [ ] ;
21488: LD_ADDR_EXP 102
21492: PUSH
21493: EMPTY
21494: ST_TO_ADDR
// mc_turret_list := [ ] ;
21495: LD_ADDR_EXP 103
21499: PUSH
21500: EMPTY
21501: ST_TO_ADDR
// mc_empty_turret_list := [ ] ;
21502: LD_ADDR_EXP 104
21506: PUSH
21507: EMPTY
21508: ST_TO_ADDR
// mc_miners := [ ] ;
21509: LD_ADDR_EXP 109
21513: PUSH
21514: EMPTY
21515: ST_TO_ADDR
// mc_mines := [ ] ;
21516: LD_ADDR_EXP 108
21520: PUSH
21521: EMPTY
21522: ST_TO_ADDR
// mc_minefields := [ ] ;
21523: LD_ADDR_EXP 110
21527: PUSH
21528: EMPTY
21529: ST_TO_ADDR
// mc_crates := [ ] ;
21530: LD_ADDR_EXP 111
21534: PUSH
21535: EMPTY
21536: ST_TO_ADDR
// mc_crates_collector := [ ] ;
21537: LD_ADDR_EXP 112
21541: PUSH
21542: EMPTY
21543: ST_TO_ADDR
// mc_crates_area := [ ] ;
21544: LD_ADDR_EXP 113
21548: PUSH
21549: EMPTY
21550: ST_TO_ADDR
// mc_vehicles := [ ] ;
21551: LD_ADDR_EXP 114
21555: PUSH
21556: EMPTY
21557: ST_TO_ADDR
// mc_attack := [ ] ;
21558: LD_ADDR_EXP 115
21562: PUSH
21563: EMPTY
21564: ST_TO_ADDR
// mc_produce := [ ] ;
21565: LD_ADDR_EXP 116
21569: PUSH
21570: EMPTY
21571: ST_TO_ADDR
// mc_defender := [ ] ;
21572: LD_ADDR_EXP 117
21576: PUSH
21577: EMPTY
21578: ST_TO_ADDR
// mc_parking := [ ] ;
21579: LD_ADDR_EXP 119
21583: PUSH
21584: EMPTY
21585: ST_TO_ADDR
// mc_busy_turret_list := [ ] ;
21586: LD_ADDR_EXP 105
21590: PUSH
21591: EMPTY
21592: ST_TO_ADDR
// mc_repair_vehicle := [ ] ;
21593: LD_ADDR_EXP 107
21597: PUSH
21598: EMPTY
21599: ST_TO_ADDR
// mc_scan := [ ] ;
21600: LD_ADDR_EXP 118
21604: PUSH
21605: EMPTY
21606: ST_TO_ADDR
// mc_scan_area := [ ] ;
21607: LD_ADDR_EXP 120
21611: PUSH
21612: EMPTY
21613: ST_TO_ADDR
// mc_tech := [ ] ;
21614: LD_ADDR_EXP 122
21618: PUSH
21619: EMPTY
21620: ST_TO_ADDR
// mc_class := [ ] ;
21621: LD_ADDR_EXP 136
21625: PUSH
21626: EMPTY
21627: ST_TO_ADDR
// mc_class_case_use := [ ] ;
21628: LD_ADDR_EXP 137
21632: PUSH
21633: EMPTY
21634: ST_TO_ADDR
// mc_is_defending := [ ] ;
21635: LD_ADDR_EXP 138
21639: PUSH
21640: EMPTY
21641: ST_TO_ADDR
// end ;
21642: LD_VAR 0 1
21646: RET
// export function MC_Kill ( base ) ; begin
21647: LD_INT 0
21649: PPUSH
// mc_bases := Replace ( mc_bases , base , [ ] ) ;
21650: LD_ADDR_EXP 95
21654: PUSH
21655: LD_EXP 95
21659: PPUSH
21660: LD_VAR 0 1
21664: PPUSH
21665: EMPTY
21666: PPUSH
21667: CALL_OW 1
21671: ST_TO_ADDR
// mc_building_need_repair := Replace ( mc_building_need_repair , base , [ ] ) ;
21672: LD_ADDR_EXP 96
21676: PUSH
21677: LD_EXP 96
21681: PPUSH
21682: LD_VAR 0 1
21686: PPUSH
21687: EMPTY
21688: PPUSH
21689: CALL_OW 1
21693: ST_TO_ADDR
// mc_building_repairs := Replace ( mc_building_repairs , base , [ ] ) ;
21694: LD_ADDR_EXP 97
21698: PUSH
21699: LD_EXP 97
21703: PPUSH
21704: LD_VAR 0 1
21708: PPUSH
21709: EMPTY
21710: PPUSH
21711: CALL_OW 1
21715: ST_TO_ADDR
// mc_need_heal := Replace ( mc_need_heal , base , [ ] ) ;
21716: LD_ADDR_EXP 98
21720: PUSH
21721: LD_EXP 98
21725: PPUSH
21726: LD_VAR 0 1
21730: PPUSH
21731: EMPTY
21732: PPUSH
21733: CALL_OW 1
21737: ST_TO_ADDR
// mc_healers := Replace ( mc_healers , base , [ ] ) ;
21738: LD_ADDR_EXP 99
21742: PUSH
21743: LD_EXP 99
21747: PPUSH
21748: LD_VAR 0 1
21752: PPUSH
21753: EMPTY
21754: PPUSH
21755: CALL_OW 1
21759: ST_TO_ADDR
// mc_build_list := Replace ( mc_build_list , base , [ ] ) ;
21760: LD_ADDR_EXP 100
21764: PUSH
21765: LD_EXP 100
21769: PPUSH
21770: LD_VAR 0 1
21774: PPUSH
21775: EMPTY
21776: PPUSH
21777: CALL_OW 1
21781: ST_TO_ADDR
// mc_builders := Replace ( mc_builders , base , [ ] ) ;
21782: LD_ADDR_EXP 101
21786: PUSH
21787: LD_EXP 101
21791: PPUSH
21792: LD_VAR 0 1
21796: PPUSH
21797: EMPTY
21798: PPUSH
21799: CALL_OW 1
21803: ST_TO_ADDR
// mc_construct_list := Replace ( mc_construct_list , base , [ ] ) ;
21804: LD_ADDR_EXP 102
21808: PUSH
21809: LD_EXP 102
21813: PPUSH
21814: LD_VAR 0 1
21818: PPUSH
21819: EMPTY
21820: PPUSH
21821: CALL_OW 1
21825: ST_TO_ADDR
// mc_turret_list := Replace ( mc_turret_list , base , [ ] ) ;
21826: LD_ADDR_EXP 103
21830: PUSH
21831: LD_EXP 103
21835: PPUSH
21836: LD_VAR 0 1
21840: PPUSH
21841: EMPTY
21842: PPUSH
21843: CALL_OW 1
21847: ST_TO_ADDR
// mc_empty_turret_list := Replace ( mc_empty_turret_list , base , [ ] ) ;
21848: LD_ADDR_EXP 104
21852: PUSH
21853: LD_EXP 104
21857: PPUSH
21858: LD_VAR 0 1
21862: PPUSH
21863: EMPTY
21864: PPUSH
21865: CALL_OW 1
21869: ST_TO_ADDR
// mc_busy_turret_list := Replace ( mc_busy_turret_list , base , [ ] ) ;
21870: LD_ADDR_EXP 105
21874: PUSH
21875: LD_EXP 105
21879: PPUSH
21880: LD_VAR 0 1
21884: PPUSH
21885: EMPTY
21886: PPUSH
21887: CALL_OW 1
21891: ST_TO_ADDR
// mc_defender_limit := Replace ( mc_defender_limit , base , 0 ) ;
21892: LD_ADDR_EXP 106
21896: PUSH
21897: LD_EXP 106
21901: PPUSH
21902: LD_VAR 0 1
21906: PPUSH
21907: LD_INT 0
21909: PPUSH
21910: CALL_OW 1
21914: ST_TO_ADDR
// mc_repair_vehicle := Replace ( mc_repair_vehicle , base , [ ] ) ;
21915: LD_ADDR_EXP 107
21919: PUSH
21920: LD_EXP 107
21924: PPUSH
21925: LD_VAR 0 1
21929: PPUSH
21930: EMPTY
21931: PPUSH
21932: CALL_OW 1
21936: ST_TO_ADDR
// mc_mines := Replace ( mc_mines , base , [ ] ) ;
21937: LD_ADDR_EXP 108
21941: PUSH
21942: LD_EXP 108
21946: PPUSH
21947: LD_VAR 0 1
21951: PPUSH
21952: EMPTY
21953: PPUSH
21954: CALL_OW 1
21958: ST_TO_ADDR
// mc_miners := Replace ( mc_miners , base , [ ] ) ;
21959: LD_ADDR_EXP 109
21963: PUSH
21964: LD_EXP 109
21968: PPUSH
21969: LD_VAR 0 1
21973: PPUSH
21974: EMPTY
21975: PPUSH
21976: CALL_OW 1
21980: ST_TO_ADDR
// mc_minefields := Replace ( mc_minefields , base , [ ] ) ;
21981: LD_ADDR_EXP 110
21985: PUSH
21986: LD_EXP 110
21990: PPUSH
21991: LD_VAR 0 1
21995: PPUSH
21996: EMPTY
21997: PPUSH
21998: CALL_OW 1
22002: ST_TO_ADDR
// mc_crates := Replace ( mc_crates , base , [ ] ) ;
22003: LD_ADDR_EXP 111
22007: PUSH
22008: LD_EXP 111
22012: PPUSH
22013: LD_VAR 0 1
22017: PPUSH
22018: EMPTY
22019: PPUSH
22020: CALL_OW 1
22024: ST_TO_ADDR
// mc_crates_collector := Replace ( mc_crates_collector , base , [ ] ) ;
22025: LD_ADDR_EXP 112
22029: PUSH
22030: LD_EXP 112
22034: PPUSH
22035: LD_VAR 0 1
22039: PPUSH
22040: EMPTY
22041: PPUSH
22042: CALL_OW 1
22046: ST_TO_ADDR
// mc_crates_area := Replace ( mc_crates_area , base , [ ] ) ;
22047: LD_ADDR_EXP 113
22051: PUSH
22052: LD_EXP 113
22056: PPUSH
22057: LD_VAR 0 1
22061: PPUSH
22062: EMPTY
22063: PPUSH
22064: CALL_OW 1
22068: ST_TO_ADDR
// mc_vehicles := Replace ( mc_vehicles , base , [ ] ) ;
22069: LD_ADDR_EXP 114
22073: PUSH
22074: LD_EXP 114
22078: PPUSH
22079: LD_VAR 0 1
22083: PPUSH
22084: EMPTY
22085: PPUSH
22086: CALL_OW 1
22090: ST_TO_ADDR
// mc_attack := Replace ( mc_attack , base , [ ] ) ;
22091: LD_ADDR_EXP 115
22095: PUSH
22096: LD_EXP 115
22100: PPUSH
22101: LD_VAR 0 1
22105: PPUSH
22106: EMPTY
22107: PPUSH
22108: CALL_OW 1
22112: ST_TO_ADDR
// mc_produce := Replace ( mc_produce , base , [ ] ) ;
22113: LD_ADDR_EXP 116
22117: PUSH
22118: LD_EXP 116
22122: PPUSH
22123: LD_VAR 0 1
22127: PPUSH
22128: EMPTY
22129: PPUSH
22130: CALL_OW 1
22134: ST_TO_ADDR
// mc_defender := Replace ( mc_defender , base , [ ] ) ;
22135: LD_ADDR_EXP 117
22139: PUSH
22140: LD_EXP 117
22144: PPUSH
22145: LD_VAR 0 1
22149: PPUSH
22150: EMPTY
22151: PPUSH
22152: CALL_OW 1
22156: ST_TO_ADDR
// mc_scan := Replace ( mc_scan , base , [ ] ) ;
22157: LD_ADDR_EXP 118
22161: PUSH
22162: LD_EXP 118
22166: PPUSH
22167: LD_VAR 0 1
22171: PPUSH
22172: EMPTY
22173: PPUSH
22174: CALL_OW 1
22178: ST_TO_ADDR
// mc_parking := Replace ( mc_parking , base , [ ] ) ;
22179: LD_ADDR_EXP 119
22183: PUSH
22184: LD_EXP 119
22188: PPUSH
22189: LD_VAR 0 1
22193: PPUSH
22194: EMPTY
22195: PPUSH
22196: CALL_OW 1
22200: ST_TO_ADDR
// mc_scan_area := Replace ( mc_scan_area , base , [ ] ) ;
22201: LD_ADDR_EXP 120
22205: PUSH
22206: LD_EXP 120
22210: PPUSH
22211: LD_VAR 0 1
22215: PPUSH
22216: EMPTY
22217: PPUSH
22218: CALL_OW 1
22222: ST_TO_ADDR
// mc_tech := Replace ( mc_tech , base , [ ] ) ;
22223: LD_ADDR_EXP 122
22227: PUSH
22228: LD_EXP 122
22232: PPUSH
22233: LD_VAR 0 1
22237: PPUSH
22238: EMPTY
22239: PPUSH
22240: CALL_OW 1
22244: ST_TO_ADDR
// mc_ape := Replace ( mc_ape , base , [ ] ) ;
22245: LD_ADDR_EXP 124
22249: PUSH
22250: LD_EXP 124
22254: PPUSH
22255: LD_VAR 0 1
22259: PPUSH
22260: EMPTY
22261: PPUSH
22262: CALL_OW 1
22266: ST_TO_ADDR
// mc_ape_in_lab := Replace ( mc_ape_in_lab , base , [ ] ) ;
22267: LD_ADDR_EXP 125
22271: PUSH
22272: LD_EXP 125
22276: PPUSH
22277: LD_VAR 0 1
22281: PPUSH
22282: EMPTY
22283: PPUSH
22284: CALL_OW 1
22288: ST_TO_ADDR
// mc_taming := Replace ( mc_taming , base , [ ] ) ;
22289: LD_ADDR_EXP 126
22293: PUSH
22294: LD_EXP 126
22298: PPUSH
22299: LD_VAR 0 1
22303: PPUSH
22304: EMPTY
22305: PPUSH
22306: CALL_OW 1
22310: ST_TO_ADDR
// mc_build_upgrade := Replace ( mc_build_upgrade , base , [ ] ) ;
22311: LD_ADDR_EXP 127
22315: PUSH
22316: LD_EXP 127
22320: PPUSH
22321: LD_VAR 0 1
22325: PPUSH
22326: EMPTY
22327: PPUSH
22328: CALL_OW 1
22332: ST_TO_ADDR
// mc_lab := Replace ( mc_lab , base , [ ] ) ;
22333: LD_ADDR_EXP 128
22337: PUSH
22338: LD_EXP 128
22342: PPUSH
22343: LD_VAR 0 1
22347: PPUSH
22348: EMPTY
22349: PPUSH
22350: CALL_OW 1
22354: ST_TO_ADDR
// mc_lab_upgrade := Replace ( mc_lab_upgrade , base , [ ] ) ;
22355: LD_ADDR_EXP 129
22359: PUSH
22360: LD_EXP 129
22364: PPUSH
22365: LD_VAR 0 1
22369: PPUSH
22370: EMPTY
22371: PPUSH
22372: CALL_OW 1
22376: ST_TO_ADDR
// mc_teleport_exit := Replace ( mc_teleport_exit , base , [ ] ) ;
22377: LD_ADDR_EXP 130
22381: PUSH
22382: LD_EXP 130
22386: PPUSH
22387: LD_VAR 0 1
22391: PPUSH
22392: EMPTY
22393: PPUSH
22394: CALL_OW 1
22398: ST_TO_ADDR
// mc_teleport_exit_set := Replace ( mc_teleport_exit_set , base , [ ] ) ;
22399: LD_ADDR_EXP 131
22403: PUSH
22404: LD_EXP 131
22408: PPUSH
22409: LD_VAR 0 1
22413: PPUSH
22414: EMPTY
22415: PPUSH
22416: CALL_OW 1
22420: ST_TO_ADDR
// mc_deposits_xy := Replace ( mc_deposits_xy , base , [ ] ) ;
22421: LD_ADDR_EXP 132
22425: PUSH
22426: LD_EXP 132
22430: PPUSH
22431: LD_VAR 0 1
22435: PPUSH
22436: EMPTY
22437: PPUSH
22438: CALL_OW 1
22442: ST_TO_ADDR
// mc_deposits_finder := Replace ( mc_deposits_finder , base , [ ] ) ;
22443: LD_ADDR_EXP 133
22447: PUSH
22448: LD_EXP 133
22452: PPUSH
22453: LD_VAR 0 1
22457: PPUSH
22458: EMPTY
22459: PPUSH
22460: CALL_OW 1
22464: ST_TO_ADDR
// mc_allowed_tower_weapons := Replace ( mc_allowed_tower_weapons , base , [ ] ) ;
22465: LD_ADDR_EXP 134
22469: PUSH
22470: LD_EXP 134
22474: PPUSH
22475: LD_VAR 0 1
22479: PPUSH
22480: EMPTY
22481: PPUSH
22482: CALL_OW 1
22486: ST_TO_ADDR
// mc_remote_driver := Replace ( mc_remote_driver , base , [ ] ) ;
22487: LD_ADDR_EXP 135
22491: PUSH
22492: LD_EXP 135
22496: PPUSH
22497: LD_VAR 0 1
22501: PPUSH
22502: EMPTY
22503: PPUSH
22504: CALL_OW 1
22508: ST_TO_ADDR
// mc_class := Replace ( mc_class , base , [ ] ) ;
22509: LD_ADDR_EXP 136
22513: PUSH
22514: LD_EXP 136
22518: PPUSH
22519: LD_VAR 0 1
22523: PPUSH
22524: EMPTY
22525: PPUSH
22526: CALL_OW 1
22530: ST_TO_ADDR
// mc_class_case_use := Replace ( mc_class_case_use , base , 0 ) ;
22531: LD_ADDR_EXP 137
22535: PUSH
22536: LD_EXP 137
22540: PPUSH
22541: LD_VAR 0 1
22545: PPUSH
22546: LD_INT 0
22548: PPUSH
22549: CALL_OW 1
22553: ST_TO_ADDR
// mc_is_defending := Replace ( mc_is_defending , base , false ) ;
22554: LD_ADDR_EXP 138
22558: PUSH
22559: LD_EXP 138
22563: PPUSH
22564: LD_VAR 0 1
22568: PPUSH
22569: LD_INT 0
22571: PPUSH
22572: CALL_OW 1
22576: ST_TO_ADDR
// end ;
22577: LD_VAR 0 2
22581: RET
// export function MC_Add ( side , units ) ; var base ; begin
22582: LD_INT 0
22584: PPUSH
22585: PPUSH
// base := mc_bases + 1 ;
22586: LD_ADDR_VAR 0 4
22590: PUSH
22591: LD_EXP 95
22595: PUSH
22596: LD_INT 1
22598: PLUS
22599: ST_TO_ADDR
// mc_sides := Replace ( mc_sides , base , side ) ;
22600: LD_ADDR_EXP 121
22604: PUSH
22605: LD_EXP 121
22609: PPUSH
22610: LD_VAR 0 4
22614: PPUSH
22615: LD_VAR 0 1
22619: PPUSH
22620: CALL_OW 1
22624: ST_TO_ADDR
// mc_bases := Replace ( mc_bases , base , units ) ;
22625: LD_ADDR_EXP 95
22629: PUSH
22630: LD_EXP 95
22634: PPUSH
22635: LD_VAR 0 4
22639: PPUSH
22640: LD_VAR 0 2
22644: PPUSH
22645: CALL_OW 1
22649: ST_TO_ADDR
// mc_building_need_repair := Replace ( mc_building_need_repair , base , [ ] ) ;
22650: LD_ADDR_EXP 96
22654: PUSH
22655: LD_EXP 96
22659: PPUSH
22660: LD_VAR 0 4
22664: PPUSH
22665: EMPTY
22666: PPUSH
22667: CALL_OW 1
22671: ST_TO_ADDR
// mc_building_repairs := Replace ( mc_building_repairs , base , [ ] ) ;
22672: LD_ADDR_EXP 97
22676: PUSH
22677: LD_EXP 97
22681: PPUSH
22682: LD_VAR 0 4
22686: PPUSH
22687: EMPTY
22688: PPUSH
22689: CALL_OW 1
22693: ST_TO_ADDR
// mc_need_heal := Replace ( mc_need_heal , base , [ ] ) ;
22694: LD_ADDR_EXP 98
22698: PUSH
22699: LD_EXP 98
22703: PPUSH
22704: LD_VAR 0 4
22708: PPUSH
22709: EMPTY
22710: PPUSH
22711: CALL_OW 1
22715: ST_TO_ADDR
// mc_healers := Replace ( mc_healers , base , [ ] ) ;
22716: LD_ADDR_EXP 99
22720: PUSH
22721: LD_EXP 99
22725: PPUSH
22726: LD_VAR 0 4
22730: PPUSH
22731: EMPTY
22732: PPUSH
22733: CALL_OW 1
22737: ST_TO_ADDR
// mc_build_list := Replace ( mc_build_list , base , [ ] ) ;
22738: LD_ADDR_EXP 100
22742: PUSH
22743: LD_EXP 100
22747: PPUSH
22748: LD_VAR 0 4
22752: PPUSH
22753: EMPTY
22754: PPUSH
22755: CALL_OW 1
22759: ST_TO_ADDR
// mc_builders := Replace ( mc_builders , base , [ ] ) ;
22760: LD_ADDR_EXP 101
22764: PUSH
22765: LD_EXP 101
22769: PPUSH
22770: LD_VAR 0 4
22774: PPUSH
22775: EMPTY
22776: PPUSH
22777: CALL_OW 1
22781: ST_TO_ADDR
// mc_construct_list := Replace ( mc_construct_list , base , [ ] ) ;
22782: LD_ADDR_EXP 102
22786: PUSH
22787: LD_EXP 102
22791: PPUSH
22792: LD_VAR 0 4
22796: PPUSH
22797: EMPTY
22798: PPUSH
22799: CALL_OW 1
22803: ST_TO_ADDR
// mc_turret_list := Replace ( mc_turret_list , base , [ ] ) ;
22804: LD_ADDR_EXP 103
22808: PUSH
22809: LD_EXP 103
22813: PPUSH
22814: LD_VAR 0 4
22818: PPUSH
22819: EMPTY
22820: PPUSH
22821: CALL_OW 1
22825: ST_TO_ADDR
// mc_empty_turret_list := Replace ( mc_empty_turret_list , base , [ ] ) ;
22826: LD_ADDR_EXP 104
22830: PUSH
22831: LD_EXP 104
22835: PPUSH
22836: LD_VAR 0 4
22840: PPUSH
22841: EMPTY
22842: PPUSH
22843: CALL_OW 1
22847: ST_TO_ADDR
// mc_busy_turret_list := Replace ( mc_busy_turret_list , base , [ ] ) ;
22848: LD_ADDR_EXP 105
22852: PUSH
22853: LD_EXP 105
22857: PPUSH
22858: LD_VAR 0 4
22862: PPUSH
22863: EMPTY
22864: PPUSH
22865: CALL_OW 1
22869: ST_TO_ADDR
// mc_defender_limit := Replace ( mc_defender_limit , base , 0 ) ;
22870: LD_ADDR_EXP 106
22874: PUSH
22875: LD_EXP 106
22879: PPUSH
22880: LD_VAR 0 4
22884: PPUSH
22885: LD_INT 0
22887: PPUSH
22888: CALL_OW 1
22892: ST_TO_ADDR
// mc_repair_vehicle := Replace ( mc_repair_vehicle , base , [ ] ) ;
22893: LD_ADDR_EXP 107
22897: PUSH
22898: LD_EXP 107
22902: PPUSH
22903: LD_VAR 0 4
22907: PPUSH
22908: EMPTY
22909: PPUSH
22910: CALL_OW 1
22914: ST_TO_ADDR
// mc_mines := Replace ( mc_mines , base , [ ] ) ;
22915: LD_ADDR_EXP 108
22919: PUSH
22920: LD_EXP 108
22924: PPUSH
22925: LD_VAR 0 4
22929: PPUSH
22930: EMPTY
22931: PPUSH
22932: CALL_OW 1
22936: ST_TO_ADDR
// mc_miners := Replace ( mc_miners , base , [ ] ) ;
22937: LD_ADDR_EXP 109
22941: PUSH
22942: LD_EXP 109
22946: PPUSH
22947: LD_VAR 0 4
22951: PPUSH
22952: EMPTY
22953: PPUSH
22954: CALL_OW 1
22958: ST_TO_ADDR
// mc_minefields := Replace ( mc_minefields , base , [ ] ) ;
22959: LD_ADDR_EXP 110
22963: PUSH
22964: LD_EXP 110
22968: PPUSH
22969: LD_VAR 0 4
22973: PPUSH
22974: EMPTY
22975: PPUSH
22976: CALL_OW 1
22980: ST_TO_ADDR
// mc_crates := Replace ( mc_crates , base , [ ] ) ;
22981: LD_ADDR_EXP 111
22985: PUSH
22986: LD_EXP 111
22990: PPUSH
22991: LD_VAR 0 4
22995: PPUSH
22996: EMPTY
22997: PPUSH
22998: CALL_OW 1
23002: ST_TO_ADDR
// mc_crates_collector := Replace ( mc_crates_collector , base , [ ] ) ;
23003: LD_ADDR_EXP 112
23007: PUSH
23008: LD_EXP 112
23012: PPUSH
23013: LD_VAR 0 4
23017: PPUSH
23018: EMPTY
23019: PPUSH
23020: CALL_OW 1
23024: ST_TO_ADDR
// mc_crates_area := Replace ( mc_crates_area , base , [ ] ) ;
23025: LD_ADDR_EXP 113
23029: PUSH
23030: LD_EXP 113
23034: PPUSH
23035: LD_VAR 0 4
23039: PPUSH
23040: EMPTY
23041: PPUSH
23042: CALL_OW 1
23046: ST_TO_ADDR
// mc_vehicles := Replace ( mc_vehicles , base , [ ] ) ;
23047: LD_ADDR_EXP 114
23051: PUSH
23052: LD_EXP 114
23056: PPUSH
23057: LD_VAR 0 4
23061: PPUSH
23062: EMPTY
23063: PPUSH
23064: CALL_OW 1
23068: ST_TO_ADDR
// mc_attack := Replace ( mc_attack , base , [ ] ) ;
23069: LD_ADDR_EXP 115
23073: PUSH
23074: LD_EXP 115
23078: PPUSH
23079: LD_VAR 0 4
23083: PPUSH
23084: EMPTY
23085: PPUSH
23086: CALL_OW 1
23090: ST_TO_ADDR
// mc_produce := Replace ( mc_produce , base , [ ] ) ;
23091: LD_ADDR_EXP 116
23095: PUSH
23096: LD_EXP 116
23100: PPUSH
23101: LD_VAR 0 4
23105: PPUSH
23106: EMPTY
23107: PPUSH
23108: CALL_OW 1
23112: ST_TO_ADDR
// mc_defender := Replace ( mc_defender , base , [ ] ) ;
23113: LD_ADDR_EXP 117
23117: PUSH
23118: LD_EXP 117
23122: PPUSH
23123: LD_VAR 0 4
23127: PPUSH
23128: EMPTY
23129: PPUSH
23130: CALL_OW 1
23134: ST_TO_ADDR
// mc_scan := Replace ( mc_scan , base , [ ] ) ;
23135: LD_ADDR_EXP 118
23139: PUSH
23140: LD_EXP 118
23144: PPUSH
23145: LD_VAR 0 4
23149: PPUSH
23150: EMPTY
23151: PPUSH
23152: CALL_OW 1
23156: ST_TO_ADDR
// mc_parking := Replace ( mc_parking , base , [ ] ) ;
23157: LD_ADDR_EXP 119
23161: PUSH
23162: LD_EXP 119
23166: PPUSH
23167: LD_VAR 0 4
23171: PPUSH
23172: EMPTY
23173: PPUSH
23174: CALL_OW 1
23178: ST_TO_ADDR
// mc_scan_area := Replace ( mc_scan_area , base , [ ] ) ;
23179: LD_ADDR_EXP 120
23183: PUSH
23184: LD_EXP 120
23188: PPUSH
23189: LD_VAR 0 4
23193: PPUSH
23194: EMPTY
23195: PPUSH
23196: CALL_OW 1
23200: ST_TO_ADDR
// mc_tech := Replace ( mc_tech , base , [ ] ) ;
23201: LD_ADDR_EXP 122
23205: PUSH
23206: LD_EXP 122
23210: PPUSH
23211: LD_VAR 0 4
23215: PPUSH
23216: EMPTY
23217: PPUSH
23218: CALL_OW 1
23222: ST_TO_ADDR
// mc_ape := Replace ( mc_ape , base , [ ] ) ;
23223: LD_ADDR_EXP 124
23227: PUSH
23228: LD_EXP 124
23232: PPUSH
23233: LD_VAR 0 4
23237: PPUSH
23238: EMPTY
23239: PPUSH
23240: CALL_OW 1
23244: ST_TO_ADDR
// mc_ape_in_lab := Replace ( mc_ape_in_lab , base , [ ] ) ;
23245: LD_ADDR_EXP 125
23249: PUSH
23250: LD_EXP 125
23254: PPUSH
23255: LD_VAR 0 4
23259: PPUSH
23260: EMPTY
23261: PPUSH
23262: CALL_OW 1
23266: ST_TO_ADDR
// mc_taming := Replace ( mc_taming , base , [ ] ) ;
23267: LD_ADDR_EXP 126
23271: PUSH
23272: LD_EXP 126
23276: PPUSH
23277: LD_VAR 0 4
23281: PPUSH
23282: EMPTY
23283: PPUSH
23284: CALL_OW 1
23288: ST_TO_ADDR
// mc_build_upgrade := Replace ( mc_build_upgrade , base , [ ] ) ;
23289: LD_ADDR_EXP 127
23293: PUSH
23294: LD_EXP 127
23298: PPUSH
23299: LD_VAR 0 4
23303: PPUSH
23304: EMPTY
23305: PPUSH
23306: CALL_OW 1
23310: ST_TO_ADDR
// mc_lab := Replace ( mc_lab , base , [ ] ) ;
23311: LD_ADDR_EXP 128
23315: PUSH
23316: LD_EXP 128
23320: PPUSH
23321: LD_VAR 0 4
23325: PPUSH
23326: EMPTY
23327: PPUSH
23328: CALL_OW 1
23332: ST_TO_ADDR
// mc_lab_upgrade := Replace ( mc_lab_upgrade , base , [ ] ) ;
23333: LD_ADDR_EXP 129
23337: PUSH
23338: LD_EXP 129
23342: PPUSH
23343: LD_VAR 0 4
23347: PPUSH
23348: EMPTY
23349: PPUSH
23350: CALL_OW 1
23354: ST_TO_ADDR
// mc_teleport_exit := Replace ( mc_teleport_exit , base , [ ] ) ;
23355: LD_ADDR_EXP 130
23359: PUSH
23360: LD_EXP 130
23364: PPUSH
23365: LD_VAR 0 4
23369: PPUSH
23370: EMPTY
23371: PPUSH
23372: CALL_OW 1
23376: ST_TO_ADDR
// mc_teleport_exit_set := Replace ( mc_teleport_exit_set , base , [ ] ) ;
23377: LD_ADDR_EXP 131
23381: PUSH
23382: LD_EXP 131
23386: PPUSH
23387: LD_VAR 0 4
23391: PPUSH
23392: EMPTY
23393: PPUSH
23394: CALL_OW 1
23398: ST_TO_ADDR
// mc_deposits_xy := Replace ( mc_deposits_xy , base , [ ] ) ;
23399: LD_ADDR_EXP 132
23403: PUSH
23404: LD_EXP 132
23408: PPUSH
23409: LD_VAR 0 4
23413: PPUSH
23414: EMPTY
23415: PPUSH
23416: CALL_OW 1
23420: ST_TO_ADDR
// mc_deposits_finder := Replace ( mc_deposits_finder , base , [ ] ) ;
23421: LD_ADDR_EXP 133
23425: PUSH
23426: LD_EXP 133
23430: PPUSH
23431: LD_VAR 0 4
23435: PPUSH
23436: EMPTY
23437: PPUSH
23438: CALL_OW 1
23442: ST_TO_ADDR
// mc_allowed_tower_weapons := Replace ( mc_allowed_tower_weapons , base , [ ] ) ;
23443: LD_ADDR_EXP 134
23447: PUSH
23448: LD_EXP 134
23452: PPUSH
23453: LD_VAR 0 4
23457: PPUSH
23458: EMPTY
23459: PPUSH
23460: CALL_OW 1
23464: ST_TO_ADDR
// mc_remote_driver := Replace ( mc_remote_driver , base , [ ] ) ;
23465: LD_ADDR_EXP 135
23469: PUSH
23470: LD_EXP 135
23474: PPUSH
23475: LD_VAR 0 4
23479: PPUSH
23480: EMPTY
23481: PPUSH
23482: CALL_OW 1
23486: ST_TO_ADDR
// mc_class := Replace ( mc_class , base , [ ] ) ;
23487: LD_ADDR_EXP 136
23491: PUSH
23492: LD_EXP 136
23496: PPUSH
23497: LD_VAR 0 4
23501: PPUSH
23502: EMPTY
23503: PPUSH
23504: CALL_OW 1
23508: ST_TO_ADDR
// mc_class_case_use := Replace ( mc_class_case_use , base , 0 ) ;
23509: LD_ADDR_EXP 137
23513: PUSH
23514: LD_EXP 137
23518: PPUSH
23519: LD_VAR 0 4
23523: PPUSH
23524: LD_INT 0
23526: PPUSH
23527: CALL_OW 1
23531: ST_TO_ADDR
// mc_is_defending := Replace ( mc_is_defending , base , false ) ;
23532: LD_ADDR_EXP 138
23536: PUSH
23537: LD_EXP 138
23541: PPUSH
23542: LD_VAR 0 4
23546: PPUSH
23547: LD_INT 0
23549: PPUSH
23550: CALL_OW 1
23554: ST_TO_ADDR
// result := base ;
23555: LD_ADDR_VAR 0 3
23559: PUSH
23560: LD_VAR 0 4
23564: ST_TO_ADDR
// end ;
23565: LD_VAR 0 3
23569: RET
// export function MC_Start ( ) ; var i ; begin
23570: LD_INT 0
23572: PPUSH
23573: PPUSH
// for i = 1 to mc_bases do
23574: LD_ADDR_VAR 0 2
23578: PUSH
23579: DOUBLE
23580: LD_INT 1
23582: DEC
23583: ST_TO_ADDR
23584: LD_EXP 95
23588: PUSH
23589: FOR_TO
23590: IFFALSE 24690
// begin mc_bases := Replace ( mc_bases , i , mc_bases [ i ] diff 0 ) ;
23592: LD_ADDR_EXP 95
23596: PUSH
23597: LD_EXP 95
23601: PPUSH
23602: LD_VAR 0 2
23606: PPUSH
23607: LD_EXP 95
23611: PUSH
23612: LD_VAR 0 2
23616: ARRAY
23617: PUSH
23618: LD_INT 0
23620: DIFF
23621: PPUSH
23622: CALL_OW 1
23626: ST_TO_ADDR
// mc_building_need_repair := Replace ( mc_building_need_repair , i , [ ] ) ;
23627: LD_ADDR_EXP 96
23631: PUSH
23632: LD_EXP 96
23636: PPUSH
23637: LD_VAR 0 2
23641: PPUSH
23642: EMPTY
23643: PPUSH
23644: CALL_OW 1
23648: ST_TO_ADDR
// mc_building_repairs := Replace ( mc_building_repairs , i , [ ] ) ;
23649: LD_ADDR_EXP 97
23653: PUSH
23654: LD_EXP 97
23658: PPUSH
23659: LD_VAR 0 2
23663: PPUSH
23664: EMPTY
23665: PPUSH
23666: CALL_OW 1
23670: ST_TO_ADDR
// mc_need_heal := Replace ( mc_need_heal , i , [ ] ) ;
23671: LD_ADDR_EXP 98
23675: PUSH
23676: LD_EXP 98
23680: PPUSH
23681: LD_VAR 0 2
23685: PPUSH
23686: EMPTY
23687: PPUSH
23688: CALL_OW 1
23692: ST_TO_ADDR
// mc_healers := Replace ( mc_healers , i , [ [ ] , [ ] ] ) ;
23693: LD_ADDR_EXP 99
23697: PUSH
23698: LD_EXP 99
23702: PPUSH
23703: LD_VAR 0 2
23707: PPUSH
23708: EMPTY
23709: PUSH
23710: EMPTY
23711: PUSH
23712: EMPTY
23713: LIST
23714: LIST
23715: PPUSH
23716: CALL_OW 1
23720: ST_TO_ADDR
// mc_build_list := Replace ( mc_build_list , i , [ ] ) ;
23721: LD_ADDR_EXP 100
23725: PUSH
23726: LD_EXP 100
23730: PPUSH
23731: LD_VAR 0 2
23735: PPUSH
23736: EMPTY
23737: PPUSH
23738: CALL_OW 1
23742: ST_TO_ADDR
// mc_build_upgrade := Replace ( mc_build_upgrade , i , [ ] ) ;
23743: LD_ADDR_EXP 127
23747: PUSH
23748: LD_EXP 127
23752: PPUSH
23753: LD_VAR 0 2
23757: PPUSH
23758: EMPTY
23759: PPUSH
23760: CALL_OW 1
23764: ST_TO_ADDR
// mc_builders := Replace ( mc_builders , i , [ ] ) ;
23765: LD_ADDR_EXP 101
23769: PUSH
23770: LD_EXP 101
23774: PPUSH
23775: LD_VAR 0 2
23779: PPUSH
23780: EMPTY
23781: PPUSH
23782: CALL_OW 1
23786: ST_TO_ADDR
// mc_construct_list := Replace ( mc_construct_list , i , [ ] ) ;
23787: LD_ADDR_EXP 102
23791: PUSH
23792: LD_EXP 102
23796: PPUSH
23797: LD_VAR 0 2
23801: PPUSH
23802: EMPTY
23803: PPUSH
23804: CALL_OW 1
23808: ST_TO_ADDR
// mc_turret_list := Replace ( mc_turret_list , i , UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_bunker ] , [ f_btype , b_turret ] ] ) ) ;
23809: LD_ADDR_EXP 103
23813: PUSH
23814: LD_EXP 103
23818: PPUSH
23819: LD_VAR 0 2
23823: PPUSH
23824: LD_EXP 95
23828: PUSH
23829: LD_VAR 0 2
23833: ARRAY
23834: PPUSH
23835: LD_INT 2
23837: PUSH
23838: LD_INT 30
23840: PUSH
23841: LD_INT 32
23843: PUSH
23844: EMPTY
23845: LIST
23846: LIST
23847: PUSH
23848: LD_INT 30
23850: PUSH
23851: LD_INT 33
23853: PUSH
23854: EMPTY
23855: LIST
23856: LIST
23857: PUSH
23858: EMPTY
23859: LIST
23860: LIST
23861: LIST
23862: PPUSH
23863: CALL_OW 72
23867: PPUSH
23868: CALL_OW 1
23872: ST_TO_ADDR
// mc_empty_turret_list := Replace ( mc_empty_turret_list , i , UnitFilter ( mc_bases [ i ] , [ [ f_or , [ f_btype , b_bunker ] , [ f_btype , b_breastwork ] ] , [ f_empty ] ] ) ) ;
23873: LD_ADDR_EXP 104
23877: PUSH
23878: LD_EXP 104
23882: PPUSH
23883: LD_VAR 0 2
23887: PPUSH
23888: LD_EXP 95
23892: PUSH
23893: LD_VAR 0 2
23897: ARRAY
23898: PPUSH
23899: LD_INT 2
23901: PUSH
23902: LD_INT 30
23904: PUSH
23905: LD_INT 32
23907: PUSH
23908: EMPTY
23909: LIST
23910: LIST
23911: PUSH
23912: LD_INT 30
23914: PUSH
23915: LD_INT 31
23917: PUSH
23918: EMPTY
23919: LIST
23920: LIST
23921: PUSH
23922: EMPTY
23923: LIST
23924: LIST
23925: LIST
23926: PUSH
23927: LD_INT 58
23929: PUSH
23930: EMPTY
23931: LIST
23932: PUSH
23933: EMPTY
23934: LIST
23935: LIST
23936: PPUSH
23937: CALL_OW 72
23941: PPUSH
23942: CALL_OW 1
23946: ST_TO_ADDR
// mc_busy_turret_list := Replace ( mc_busy_turret_list , i , [ ] ) ;
23947: LD_ADDR_EXP 105
23951: PUSH
23952: LD_EXP 105
23956: PPUSH
23957: LD_VAR 0 2
23961: PPUSH
23962: EMPTY
23963: PPUSH
23964: CALL_OW 1
23968: ST_TO_ADDR
// mc_miners := Replace ( mc_miners , i , [ ] ) ;
23969: LD_ADDR_EXP 109
23973: PUSH
23974: LD_EXP 109
23978: PPUSH
23979: LD_VAR 0 2
23983: PPUSH
23984: EMPTY
23985: PPUSH
23986: CALL_OW 1
23990: ST_TO_ADDR
// mc_mines := Replace ( mc_mines , i , [ ] ) ;
23991: LD_ADDR_EXP 108
23995: PUSH
23996: LD_EXP 108
24000: PPUSH
24001: LD_VAR 0 2
24005: PPUSH
24006: EMPTY
24007: PPUSH
24008: CALL_OW 1
24012: ST_TO_ADDR
// mc_minefields := Replace ( mc_minefields , i , [ ] ) ;
24013: LD_ADDR_EXP 110
24017: PUSH
24018: LD_EXP 110
24022: PPUSH
24023: LD_VAR 0 2
24027: PPUSH
24028: EMPTY
24029: PPUSH
24030: CALL_OW 1
24034: ST_TO_ADDR
// mc_crates := Replace ( mc_crates , i , [ ] ) ;
24035: LD_ADDR_EXP 111
24039: PUSH
24040: LD_EXP 111
24044: PPUSH
24045: LD_VAR 0 2
24049: PPUSH
24050: EMPTY
24051: PPUSH
24052: CALL_OW 1
24056: ST_TO_ADDR
// mc_crates_collector := Replace ( mc_crates_collector , i , [ ] ) ;
24057: LD_ADDR_EXP 112
24061: PUSH
24062: LD_EXP 112
24066: PPUSH
24067: LD_VAR 0 2
24071: PPUSH
24072: EMPTY
24073: PPUSH
24074: CALL_OW 1
24078: ST_TO_ADDR
// mc_crates_area := Replace ( mc_crates_area , i , [ ] ) ;
24079: LD_ADDR_EXP 113
24083: PUSH
24084: LD_EXP 113
24088: PPUSH
24089: LD_VAR 0 2
24093: PPUSH
24094: EMPTY
24095: PPUSH
24096: CALL_OW 1
24100: ST_TO_ADDR
// mc_vehicles := Replace ( mc_vehicles , i , [ ] ) ;
24101: LD_ADDR_EXP 114
24105: PUSH
24106: LD_EXP 114
24110: PPUSH
24111: LD_VAR 0 2
24115: PPUSH
24116: EMPTY
24117: PPUSH
24118: CALL_OW 1
24122: ST_TO_ADDR
// mc_attack := Replace ( mc_attack , i , [ ] ) ;
24123: LD_ADDR_EXP 115
24127: PUSH
24128: LD_EXP 115
24132: PPUSH
24133: LD_VAR 0 2
24137: PPUSH
24138: EMPTY
24139: PPUSH
24140: CALL_OW 1
24144: ST_TO_ADDR
// mc_produce := Replace ( mc_produce , i , [ ] ) ;
24145: LD_ADDR_EXP 116
24149: PUSH
24150: LD_EXP 116
24154: PPUSH
24155: LD_VAR 0 2
24159: PPUSH
24160: EMPTY
24161: PPUSH
24162: CALL_OW 1
24166: ST_TO_ADDR
// mc_defender := Replace ( mc_defender , i , [ ] ) ;
24167: LD_ADDR_EXP 117
24171: PUSH
24172: LD_EXP 117
24176: PPUSH
24177: LD_VAR 0 2
24181: PPUSH
24182: EMPTY
24183: PPUSH
24184: CALL_OW 1
24188: ST_TO_ADDR
// mc_defender_limit := Replace ( mc_defender_limit , i , 0 ) ;
24189: LD_ADDR_EXP 106
24193: PUSH
24194: LD_EXP 106
24198: PPUSH
24199: LD_VAR 0 2
24203: PPUSH
24204: LD_INT 0
24206: PPUSH
24207: CALL_OW 1
24211: ST_TO_ADDR
// mc_parking := Replace ( mc_parking , i , 0 ) ;
24212: LD_ADDR_EXP 119
24216: PUSH
24217: LD_EXP 119
24221: PPUSH
24222: LD_VAR 0 2
24226: PPUSH
24227: LD_INT 0
24229: PPUSH
24230: CALL_OW 1
24234: ST_TO_ADDR
// mc_repair_vehicle := Replace ( mc_repair_vehicle , i , [ ] ) ;
24235: LD_ADDR_EXP 107
24239: PUSH
24240: LD_EXP 107
24244: PPUSH
24245: LD_VAR 0 2
24249: PPUSH
24250: EMPTY
24251: PPUSH
24252: CALL_OW 1
24256: ST_TO_ADDR
// mc_scan := Replace ( mc_scan , i , 0 ) ;
24257: LD_ADDR_EXP 118
24261: PUSH
24262: LD_EXP 118
24266: PPUSH
24267: LD_VAR 0 2
24271: PPUSH
24272: LD_INT 0
24274: PPUSH
24275: CALL_OW 1
24279: ST_TO_ADDR
// mc_scan_area := Replace ( mc_scan_area , i , [ ] ) ;
24280: LD_ADDR_EXP 120
24284: PUSH
24285: LD_EXP 120
24289: PPUSH
24290: LD_VAR 0 2
24294: PPUSH
24295: EMPTY
24296: PPUSH
24297: CALL_OW 1
24301: ST_TO_ADDR
// mc_can_tame := Replace ( mc_can_tame , i , 0 ) ;
24302: LD_ADDR_EXP 123
24306: PUSH
24307: LD_EXP 123
24311: PPUSH
24312: LD_VAR 0 2
24316: PPUSH
24317: LD_INT 0
24319: PPUSH
24320: CALL_OW 1
24324: ST_TO_ADDR
// mc_ape := Replace ( mc_ape , i , [ ] ) ;
24325: LD_ADDR_EXP 124
24329: PUSH
24330: LD_EXP 124
24334: PPUSH
24335: LD_VAR 0 2
24339: PPUSH
24340: EMPTY
24341: PPUSH
24342: CALL_OW 1
24346: ST_TO_ADDR
// mc_ape_in_lab := Replace ( mc_ape_in_lab , i , [ ] ) ;
24347: LD_ADDR_EXP 125
24351: PUSH
24352: LD_EXP 125
24356: PPUSH
24357: LD_VAR 0 2
24361: PPUSH
24362: EMPTY
24363: PPUSH
24364: CALL_OW 1
24368: ST_TO_ADDR
// mc_taming := Replace ( mc_taming , i , [ ] ) ;
24369: LD_ADDR_EXP 126
24373: PUSH
24374: LD_EXP 126
24378: PPUSH
24379: LD_VAR 0 2
24383: PPUSH
24384: EMPTY
24385: PPUSH
24386: CALL_OW 1
24390: ST_TO_ADDR
// mc_lab := Replace ( mc_lab , i , UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_lab ] , [ f_btype , b_lab_half ] , [ f_btype , b_lab_full ] ] ) ) ;
24391: LD_ADDR_EXP 128
24395: PUSH
24396: LD_EXP 128
24400: PPUSH
24401: LD_VAR 0 2
24405: PPUSH
24406: LD_EXP 95
24410: PUSH
24411: LD_VAR 0 2
24415: ARRAY
24416: PPUSH
24417: LD_INT 2
24419: PUSH
24420: LD_INT 30
24422: PUSH
24423: LD_INT 6
24425: PUSH
24426: EMPTY
24427: LIST
24428: LIST
24429: PUSH
24430: LD_INT 30
24432: PUSH
24433: LD_INT 7
24435: PUSH
24436: EMPTY
24437: LIST
24438: LIST
24439: PUSH
24440: LD_INT 30
24442: PUSH
24443: LD_INT 8
24445: PUSH
24446: EMPTY
24447: LIST
24448: LIST
24449: PUSH
24450: EMPTY
24451: LIST
24452: LIST
24453: LIST
24454: LIST
24455: PPUSH
24456: CALL_OW 72
24460: PPUSH
24461: CALL_OW 1
24465: ST_TO_ADDR
// mc_lab_upgrade := Replace ( mc_lab_upgrade , i , [ ] ) ;
24466: LD_ADDR_EXP 129
24470: PUSH
24471: LD_EXP 129
24475: PPUSH
24476: LD_VAR 0 2
24480: PPUSH
24481: EMPTY
24482: PPUSH
24483: CALL_OW 1
24487: ST_TO_ADDR
// mc_teleport_exit := Replace ( mc_teleport_exit , i , [ ] ) ;
24488: LD_ADDR_EXP 130
24492: PUSH
24493: LD_EXP 130
24497: PPUSH
24498: LD_VAR 0 2
24502: PPUSH
24503: EMPTY
24504: PPUSH
24505: CALL_OW 1
24509: ST_TO_ADDR
// mc_teleport_exit_set := Replace ( mc_teleport_exit_set , i , [ ] ) ;
24510: LD_ADDR_EXP 131
24514: PUSH
24515: LD_EXP 131
24519: PPUSH
24520: LD_VAR 0 2
24524: PPUSH
24525: EMPTY
24526: PPUSH
24527: CALL_OW 1
24531: ST_TO_ADDR
// mc_deposits_xy := Replace ( mc_deposits_xy , i , [ ] ) ;
24532: LD_ADDR_EXP 132
24536: PUSH
24537: LD_EXP 132
24541: PPUSH
24542: LD_VAR 0 2
24546: PPUSH
24547: EMPTY
24548: PPUSH
24549: CALL_OW 1
24553: ST_TO_ADDR
// mc_deposits_finder := Replace ( mc_deposits_finder , i , [ ] ) ;
24554: LD_ADDR_EXP 133
24558: PUSH
24559: LD_EXP 133
24563: PPUSH
24564: LD_VAR 0 2
24568: PPUSH
24569: EMPTY
24570: PPUSH
24571: CALL_OW 1
24575: ST_TO_ADDR
// mc_allowed_tower_weapons := Replace ( mc_allowed_tower_weapons , i , [ ] ) ;
24576: LD_ADDR_EXP 134
24580: PUSH
24581: LD_EXP 134
24585: PPUSH
24586: LD_VAR 0 2
24590: PPUSH
24591: EMPTY
24592: PPUSH
24593: CALL_OW 1
24597: ST_TO_ADDR
// mc_remote_driver := Replace ( mc_remote_driver , i , [ ] ) ;
24598: LD_ADDR_EXP 135
24602: PUSH
24603: LD_EXP 135
24607: PPUSH
24608: LD_VAR 0 2
24612: PPUSH
24613: EMPTY
24614: PPUSH
24615: CALL_OW 1
24619: ST_TO_ADDR
// mc_class := Replace ( mc_class , i , [ ] ) ;
24620: LD_ADDR_EXP 136
24624: PUSH
24625: LD_EXP 136
24629: PPUSH
24630: LD_VAR 0 2
24634: PPUSH
24635: EMPTY
24636: PPUSH
24637: CALL_OW 1
24641: ST_TO_ADDR
// mc_class_case_use := Replace ( mc_class_case_use , i , 0 ) ;
24642: LD_ADDR_EXP 137
24646: PUSH
24647: LD_EXP 137
24651: PPUSH
24652: LD_VAR 0 2
24656: PPUSH
24657: LD_INT 0
24659: PPUSH
24660: CALL_OW 1
24664: ST_TO_ADDR
// mc_is_defending := Replace ( mc_is_defending , i , false ) ;
24665: LD_ADDR_EXP 138
24669: PUSH
24670: LD_EXP 138
24674: PPUSH
24675: LD_VAR 0 2
24679: PPUSH
24680: LD_INT 0
24682: PPUSH
24683: CALL_OW 1
24687: ST_TO_ADDR
// end ;
24688: GO 23589
24690: POP
24691: POP
// MC_InitSides ( ) ;
24692: CALL 24978 0 0
// MC_InitResearch ( ) ;
24696: CALL 24717 0 0
// CustomInitMacro ( ) ;
24700: CALL 232 0 0
// skirmish := true ;
24704: LD_ADDR_EXP 93
24708: PUSH
24709: LD_INT 1
24711: ST_TO_ADDR
// end ;
24712: LD_VAR 0 1
24716: RET
// export function MC_InitResearch ( ) ; var i , j , nation , tmp , un ; begin
24717: LD_INT 0
24719: PPUSH
24720: PPUSH
24721: PPUSH
24722: PPUSH
24723: PPUSH
24724: PPUSH
// if not mc_bases then
24725: LD_EXP 95
24729: NOT
24730: IFFALSE 24734
// exit ;
24732: GO 24973
// for i = 1 to 8 do
24734: LD_ADDR_VAR 0 2
24738: PUSH
24739: DOUBLE
24740: LD_INT 1
24742: DEC
24743: ST_TO_ADDR
24744: LD_INT 8
24746: PUSH
24747: FOR_TO
24748: IFFALSE 24774
// mc_tech := Replace ( mc_tech , i , [ ] ) ;
24750: LD_ADDR_EXP 122
24754: PUSH
24755: LD_EXP 122
24759: PPUSH
24760: LD_VAR 0 2
24764: PPUSH
24765: EMPTY
24766: PPUSH
24767: CALL_OW 1
24771: ST_TO_ADDR
24772: GO 24747
24774: POP
24775: POP
// tmp := [ ] ;
24776: LD_ADDR_VAR 0 5
24780: PUSH
24781: EMPTY
24782: ST_TO_ADDR
// for i = 1 to mc_sides do
24783: LD_ADDR_VAR 0 2
24787: PUSH
24788: DOUBLE
24789: LD_INT 1
24791: DEC
24792: ST_TO_ADDR
24793: LD_EXP 121
24797: PUSH
24798: FOR_TO
24799: IFFALSE 24857
// if not mc_sides [ i ] in tmp then
24801: LD_EXP 121
24805: PUSH
24806: LD_VAR 0 2
24810: ARRAY
24811: PUSH
24812: LD_VAR 0 5
24816: IN
24817: NOT
24818: IFFALSE 24855
// tmp := Insert ( tmp , tmp + 1 , mc_sides [ i ] ) ;
24820: LD_ADDR_VAR 0 5
24824: PUSH
24825: LD_VAR 0 5
24829: PPUSH
24830: LD_VAR 0 5
24834: PUSH
24835: LD_INT 1
24837: PLUS
24838: PPUSH
24839: LD_EXP 121
24843: PUSH
24844: LD_VAR 0 2
24848: ARRAY
24849: PPUSH
24850: CALL_OW 2
24854: ST_TO_ADDR
24855: GO 24798
24857: POP
24858: POP
// if not tmp then
24859: LD_VAR 0 5
24863: NOT
24864: IFFALSE 24868
// exit ;
24866: GO 24973
// for j in tmp do
24868: LD_ADDR_VAR 0 3
24872: PUSH
24873: LD_VAR 0 5
24877: PUSH
24878: FOR_IN
24879: IFFALSE 24971
// begin un := FilterAllUnits ( [ f_side , j ] ) ;
24881: LD_ADDR_VAR 0 6
24885: PUSH
24886: LD_INT 22
24888: PUSH
24889: LD_VAR 0 3
24893: PUSH
24894: EMPTY
24895: LIST
24896: LIST
24897: PPUSH
24898: CALL_OW 69
24902: ST_TO_ADDR
// if not un then
24903: LD_VAR 0 6
24907: NOT
24908: IFFALSE 24912
// continue ;
24910: GO 24878
// nation := GetNation ( un [ 1 ] ) ;
24912: LD_ADDR_VAR 0 4
24916: PUSH
24917: LD_VAR 0 6
24921: PUSH
24922: LD_INT 1
24924: ARRAY
24925: PPUSH
24926: CALL_OW 248
24930: ST_TO_ADDR
// mc_tech := Replace ( mc_tech , j , GetTechNation ( j , nation , state_enabled ) ) ;
24931: LD_ADDR_EXP 122
24935: PUSH
24936: LD_EXP 122
24940: PPUSH
24941: LD_VAR 0 3
24945: PPUSH
24946: LD_VAR 0 3
24950: PPUSH
24951: LD_VAR 0 4
24955: PPUSH
24956: LD_INT 1
24958: PPUSH
24959: CALL 52094 0 3
24963: PPUSH
24964: CALL_OW 1
24968: ST_TO_ADDR
// end ;
24969: GO 24878
24971: POP
24972: POP
// end ;
24973: LD_VAR 0 1
24977: RET
// export function MC_InitSides ( ) ; var i ; begin
24978: LD_INT 0
24980: PPUSH
24981: PPUSH
// if not mc_bases then
24982: LD_EXP 95
24986: NOT
24987: IFFALSE 24991
// exit ;
24989: GO 25065
// for i = 1 to mc_bases do
24991: LD_ADDR_VAR 0 2
24995: PUSH
24996: DOUBLE
24997: LD_INT 1
24999: DEC
25000: ST_TO_ADDR
25001: LD_EXP 95
25005: PUSH
25006: FOR_TO
25007: IFFALSE 25063
// if mc_bases [ i ] then
25009: LD_EXP 95
25013: PUSH
25014: LD_VAR 0 2
25018: ARRAY
25019: IFFALSE 25061
// mc_sides := Replace ( mc_sides , i , GetSide ( mc_bases [ i ] [ 1 ] ) ) ;
25021: LD_ADDR_EXP 121
25025: PUSH
25026: LD_EXP 121
25030: PPUSH
25031: LD_VAR 0 2
25035: PPUSH
25036: LD_EXP 95
25040: PUSH
25041: LD_VAR 0 2
25045: ARRAY
25046: PUSH
25047: LD_INT 1
25049: ARRAY
25050: PPUSH
25051: CALL_OW 255
25055: PPUSH
25056: CALL_OW 1
25060: ST_TO_ADDR
25061: GO 25006
25063: POP
25064: POP
// end ;
25065: LD_VAR 0 1
25069: RET
// every 0 0$03 trigger skirmish do
25070: LD_EXP 93
25074: IFFALSE 25228
25076: GO 25078
25078: DISABLE
// begin enable ;
25079: ENABLE
// MC_CheckBuildings ( ) ;
25080: CALL 29726 0 0
// MC_CheckPeopleLife ( ) ;
25084: CALL 29887 0 0
// RaiseSailEvent ( 100 ) ;
25088: LD_INT 100
25090: PPUSH
25091: CALL_OW 427
// RaiseSailEvent ( 103 ) ;
25095: LD_INT 103
25097: PPUSH
25098: CALL_OW 427
// RaiseSailEvent ( 104 ) ;
25102: LD_INT 104
25104: PPUSH
25105: CALL_OW 427
// RaiseSailEvent ( 105 ) ;
25109: LD_INT 105
25111: PPUSH
25112: CALL_OW 427
// RaiseSailEvent ( 106 ) ;
25116: LD_INT 106
25118: PPUSH
25119: CALL_OW 427
// RaiseSailEvent ( 107 ) ;
25123: LD_INT 107
25125: PPUSH
25126: CALL_OW 427
// RaiseSailEvent ( 108 ) ;
25130: LD_INT 108
25132: PPUSH
25133: CALL_OW 427
// RaiseSailEvent ( 109 ) ;
25137: LD_INT 109
25139: PPUSH
25140: CALL_OW 427
// RaiseSailEvent ( 110 ) ;
25144: LD_INT 110
25146: PPUSH
25147: CALL_OW 427
// RaiseSailEvent ( 111 ) ;
25151: LD_INT 111
25153: PPUSH
25154: CALL_OW 427
// RaiseSailEvent ( 112 ) ;
25158: LD_INT 112
25160: PPUSH
25161: CALL_OW 427
// RaiseSailEvent ( 113 ) ;
25165: LD_INT 113
25167: PPUSH
25168: CALL_OW 427
// RaiseSailEvent ( 120 ) ;
25172: LD_INT 120
25174: PPUSH
25175: CALL_OW 427
// RaiseSailEvent ( 121 ) ;
25179: LD_INT 121
25181: PPUSH
25182: CALL_OW 427
// RaiseSailEvent ( 122 ) ;
25186: LD_INT 122
25188: PPUSH
25189: CALL_OW 427
// RaiseSailEvent ( 123 ) ;
25193: LD_INT 123
25195: PPUSH
25196: CALL_OW 427
// RaiseSailEvent ( 124 ) ;
25200: LD_INT 124
25202: PPUSH
25203: CALL_OW 427
// RaiseSailEvent ( 125 ) ;
25207: LD_INT 125
25209: PPUSH
25210: CALL_OW 427
// RaiseSailEvent ( 126 ) ;
25214: LD_INT 126
25216: PPUSH
25217: CALL_OW 427
// RaiseSailEvent ( 200 ) ;
25221: LD_INT 200
25223: PPUSH
25224: CALL_OW 427
// end ;
25228: END
// on SailEvent ( event ) do begin if event < 100 then
25229: LD_VAR 0 1
25233: PUSH
25234: LD_INT 100
25236: LESS
25237: IFFALSE 25248
// CustomEvent ( event ) ;
25239: LD_VAR 0 1
25243: PPUSH
25244: CALL 10899 0 1
// if event = 100 then
25248: LD_VAR 0 1
25252: PUSH
25253: LD_INT 100
25255: EQUAL
25256: IFFALSE 25262
// MC_ClassManager ( ) ;
25258: CALL 25654 0 0
// if event = 101 then
25262: LD_VAR 0 1
25266: PUSH
25267: LD_INT 101
25269: EQUAL
25270: IFFALSE 25276
// MC_RepairBuildings ( ) ;
25272: CALL 30472 0 0
// if event = 102 then
25276: LD_VAR 0 1
25280: PUSH
25281: LD_INT 102
25283: EQUAL
25284: IFFALSE 25290
// MC_Heal ( ) ;
25286: CALL 31379 0 0
// if event = 103 then
25290: LD_VAR 0 1
25294: PUSH
25295: LD_INT 103
25297: EQUAL
25298: IFFALSE 25304
// MC_Build ( ) ;
25300: CALL 31801 0 0
// if event = 104 then
25304: LD_VAR 0 1
25308: PUSH
25309: LD_INT 104
25311: EQUAL
25312: IFFALSE 25318
// MC_TurretWeapon ( ) ;
25314: CALL 33442 0 0
// if event = 105 then
25318: LD_VAR 0 1
25322: PUSH
25323: LD_INT 105
25325: EQUAL
25326: IFFALSE 25332
// MC_BuildUpgrade ( ) ;
25328: CALL 32993 0 0
// if event = 106 then
25332: LD_VAR 0 1
25336: PUSH
25337: LD_INT 106
25339: EQUAL
25340: IFFALSE 25346
// MC_PlantMines ( ) ;
25342: CALL 33872 0 0
// if event = 107 then
25346: LD_VAR 0 1
25350: PUSH
25351: LD_INT 107
25353: EQUAL
25354: IFFALSE 25360
// MC_CollectCrates ( ) ;
25356: CALL 34663 0 0
// if event = 108 then
25360: LD_VAR 0 1
25364: PUSH
25365: LD_INT 108
25367: EQUAL
25368: IFFALSE 25374
// MC_LinkRemoteControl ( ) ;
25370: CALL 36513 0 0
// if event = 109 then
25374: LD_VAR 0 1
25378: PUSH
25379: LD_INT 109
25381: EQUAL
25382: IFFALSE 25388
// MC_ProduceVehicle ( ) ;
25384: CALL 36694 0 0
// if event = 110 then
25388: LD_VAR 0 1
25392: PUSH
25393: LD_INT 110
25395: EQUAL
25396: IFFALSE 25402
// MC_SendAttack ( ) ;
25398: CALL 37160 0 0
// if event = 111 then
25402: LD_VAR 0 1
25406: PUSH
25407: LD_INT 111
25409: EQUAL
25410: IFFALSE 25416
// MC_Defend ( ) ;
25412: CALL 37268 0 0
// if event = 112 then
25416: LD_VAR 0 1
25420: PUSH
25421: LD_INT 112
25423: EQUAL
25424: IFFALSE 25430
// MC_Research ( ) ;
25426: CALL 38148 0 0
// if event = 113 then
25430: LD_VAR 0 1
25434: PUSH
25435: LD_INT 113
25437: EQUAL
25438: IFFALSE 25444
// MC_MinesTrigger ( ) ;
25440: CALL 39262 0 0
// if event = 120 then
25444: LD_VAR 0 1
25448: PUSH
25449: LD_INT 120
25451: EQUAL
25452: IFFALSE 25458
// MC_RepairVehicle ( ) ;
25454: CALL 39361 0 0
// if event = 121 then
25458: LD_VAR 0 1
25462: PUSH
25463: LD_INT 121
25465: EQUAL
25466: IFFALSE 25472
// MC_TameApe ( ) ;
25468: CALL 40102 0 0
// if event = 122 then
25472: LD_VAR 0 1
25476: PUSH
25477: LD_INT 122
25479: EQUAL
25480: IFFALSE 25486
// MC_ChangeApeClass ( ) ;
25482: CALL 40931 0 0
// if event = 123 then
25486: LD_VAR 0 1
25490: PUSH
25491: LD_INT 123
25493: EQUAL
25494: IFFALSE 25500
// MC_Bazooka ( ) ;
25496: CALL 41581 0 0
// if event = 124 then
25500: LD_VAR 0 1
25504: PUSH
25505: LD_INT 124
25507: EQUAL
25508: IFFALSE 25514
// MC_TeleportExit ( ) ;
25510: CALL 41779 0 0
// if event = 125 then
25514: LD_VAR 0 1
25518: PUSH
25519: LD_INT 125
25521: EQUAL
25522: IFFALSE 25528
// MC_Deposits ( ) ;
25524: CALL 42426 0 0
// if event = 126 then
25528: LD_VAR 0 1
25532: PUSH
25533: LD_INT 126
25535: EQUAL
25536: IFFALSE 25542
// MC_RemoteDriver ( ) ;
25538: CALL 43051 0 0
// if event = 200 then
25542: LD_VAR 0 1
25546: PUSH
25547: LD_INT 200
25549: EQUAL
25550: IFFALSE 25556
// MC_Idle ( ) ;
25552: CALL 45000 0 0
// end ;
25556: PPOPN 1
25558: END
// export function MC_Reset ( base , tag ) ; var i ; begin
25559: LD_INT 0
25561: PPUSH
25562: PPUSH
// if not mc_bases [ base ] or not tag then
25563: LD_EXP 95
25567: PUSH
25568: LD_VAR 0 1
25572: ARRAY
25573: NOT
25574: PUSH
25575: LD_VAR 0 2
25579: NOT
25580: OR
25581: IFFALSE 25585
// exit ;
25583: GO 25649
// for i in mc_bases [ base ] union mc_ape [ base ] do
25585: LD_ADDR_VAR 0 4
25589: PUSH
25590: LD_EXP 95
25594: PUSH
25595: LD_VAR 0 1
25599: ARRAY
25600: PUSH
25601: LD_EXP 124
25605: PUSH
25606: LD_VAR 0 1
25610: ARRAY
25611: UNION
25612: PUSH
25613: FOR_IN
25614: IFFALSE 25647
// if GetTag ( i ) = tag then
25616: LD_VAR 0 4
25620: PPUSH
25621: CALL_OW 110
25625: PUSH
25626: LD_VAR 0 2
25630: EQUAL
25631: IFFALSE 25645
// SetTag ( i , 0 ) ;
25633: LD_VAR 0 4
25637: PPUSH
25638: LD_INT 0
25640: PPUSH
25641: CALL_OW 109
25645: GO 25613
25647: POP
25648: POP
// end ;
25649: LD_VAR 0 3
25653: RET
// export function MC_ClassManager ( ) ; var i , j , tmp , p , b , e , k ; begin
25654: LD_INT 0
25656: PPUSH
25657: PPUSH
25658: PPUSH
25659: PPUSH
25660: PPUSH
25661: PPUSH
25662: PPUSH
25663: PPUSH
// if not mc_bases then
25664: LD_EXP 95
25668: NOT
25669: IFFALSE 25673
// exit ;
25671: GO 26131
// for i = 1 to mc_bases do
25673: LD_ADDR_VAR 0 2
25677: PUSH
25678: DOUBLE
25679: LD_INT 1
25681: DEC
25682: ST_TO_ADDR
25683: LD_EXP 95
25687: PUSH
25688: FOR_TO
25689: IFFALSE 26129
// begin tmp := MC_ClassCheckReq ( i ) ;
25691: LD_ADDR_VAR 0 4
25695: PUSH
25696: LD_VAR 0 2
25700: PPUSH
25701: CALL 26136 0 1
25705: ST_TO_ADDR
// mc_class := Replace ( mc_class , i , tmp ) ;
25706: LD_ADDR_EXP 136
25710: PUSH
25711: LD_EXP 136
25715: PPUSH
25716: LD_VAR 0 2
25720: PPUSH
25721: LD_VAR 0 4
25725: PPUSH
25726: CALL_OW 1
25730: ST_TO_ADDR
// if not tmp then
25731: LD_VAR 0 4
25735: NOT
25736: IFFALSE 25740
// continue ;
25738: GO 25688
// b := [ UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_armoury ] , [ f_btype , b_barracks ] ] ) , UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) , UnitFilter ( mc_bases [ i ] , [ f_btype , b_factory ] ) , UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_lab ] , [ f_btype , b_lab_half ] , [ f_btype , b_lab_full ] ] ) ] ;
25740: LD_ADDR_VAR 0 6
25744: PUSH
25745: LD_EXP 95
25749: PUSH
25750: LD_VAR 0 2
25754: ARRAY
25755: PPUSH
25756: LD_INT 2
25758: PUSH
25759: LD_INT 30
25761: PUSH
25762: LD_INT 4
25764: PUSH
25765: EMPTY
25766: LIST
25767: LIST
25768: PUSH
25769: LD_INT 30
25771: PUSH
25772: LD_INT 5
25774: PUSH
25775: EMPTY
25776: LIST
25777: LIST
25778: PUSH
25779: EMPTY
25780: LIST
25781: LIST
25782: LIST
25783: PPUSH
25784: CALL_OW 72
25788: PUSH
25789: LD_EXP 95
25793: PUSH
25794: LD_VAR 0 2
25798: ARRAY
25799: PPUSH
25800: LD_INT 2
25802: PUSH
25803: LD_INT 30
25805: PUSH
25806: LD_INT 0
25808: PUSH
25809: EMPTY
25810: LIST
25811: LIST
25812: PUSH
25813: LD_INT 30
25815: PUSH
25816: LD_INT 1
25818: PUSH
25819: EMPTY
25820: LIST
25821: LIST
25822: PUSH
25823: EMPTY
25824: LIST
25825: LIST
25826: LIST
25827: PPUSH
25828: CALL_OW 72
25832: PUSH
25833: LD_EXP 95
25837: PUSH
25838: LD_VAR 0 2
25842: ARRAY
25843: PPUSH
25844: LD_INT 30
25846: PUSH
25847: LD_INT 3
25849: PUSH
25850: EMPTY
25851: LIST
25852: LIST
25853: PPUSH
25854: CALL_OW 72
25858: PUSH
25859: LD_EXP 95
25863: PUSH
25864: LD_VAR 0 2
25868: ARRAY
25869: PPUSH
25870: LD_INT 2
25872: PUSH
25873: LD_INT 30
25875: PUSH
25876: LD_INT 6
25878: PUSH
25879: EMPTY
25880: LIST
25881: LIST
25882: PUSH
25883: LD_INT 30
25885: PUSH
25886: LD_INT 7
25888: PUSH
25889: EMPTY
25890: LIST
25891: LIST
25892: PUSH
25893: LD_INT 30
25895: PUSH
25896: LD_INT 8
25898: PUSH
25899: EMPTY
25900: LIST
25901: LIST
25902: PUSH
25903: EMPTY
25904: LIST
25905: LIST
25906: LIST
25907: LIST
25908: PPUSH
25909: CALL_OW 72
25913: PUSH
25914: EMPTY
25915: LIST
25916: LIST
25917: LIST
25918: LIST
25919: ST_TO_ADDR
// for j = 1 to 4 do
25920: LD_ADDR_VAR 0 3
25924: PUSH
25925: DOUBLE
25926: LD_INT 1
25928: DEC
25929: ST_TO_ADDR
25930: LD_INT 4
25932: PUSH
25933: FOR_TO
25934: IFFALSE 26125
// begin if not tmp [ j ] then
25936: LD_VAR 0 4
25940: PUSH
25941: LD_VAR 0 3
25945: ARRAY
25946: NOT
25947: IFFALSE 25951
// continue ;
25949: GO 25933
// for p in tmp [ j ] do
25951: LD_ADDR_VAR 0 5
25955: PUSH
25956: LD_VAR 0 4
25960: PUSH
25961: LD_VAR 0 3
25965: ARRAY
25966: PUSH
25967: FOR_IN
25968: IFFALSE 26121
// begin if not b [ j ] then
25970: LD_VAR 0 6
25974: PUSH
25975: LD_VAR 0 3
25979: ARRAY
25980: NOT
25981: IFFALSE 25985
// break ;
25983: GO 26121
// e := 0 ;
25985: LD_ADDR_VAR 0 7
25989: PUSH
25990: LD_INT 0
25992: ST_TO_ADDR
// for k in b [ j ] do
25993: LD_ADDR_VAR 0 8
25997: PUSH
25998: LD_VAR 0 6
26002: PUSH
26003: LD_VAR 0 3
26007: ARRAY
26008: PUSH
26009: FOR_IN
26010: IFFALSE 26037
// if IsNotFull ( k ) then
26012: LD_VAR 0 8
26016: PPUSH
26017: CALL 54247 0 1
26021: IFFALSE 26035
// begin e := k ;
26023: LD_ADDR_VAR 0 7
26027: PUSH
26028: LD_VAR 0 8
26032: ST_TO_ADDR
// break ;
26033: GO 26037
// end ;
26035: GO 26009
26037: POP
26038: POP
// if e and not UnitGoingToBuilding ( p , e ) then
26039: LD_VAR 0 7
26043: PUSH
26044: LD_VAR 0 5
26048: PPUSH
26049: LD_VAR 0 7
26053: PPUSH
26054: CALL 87358 0 2
26058: NOT
26059: AND
26060: IFFALSE 26119
// begin if IsInUnit ( p ) then
26062: LD_VAR 0 5
26066: PPUSH
26067: CALL_OW 310
26071: IFFALSE 26082
// ComExitBuilding ( p ) ;
26073: LD_VAR 0 5
26077: PPUSH
26078: CALL_OW 122
// ComEnterUnit ( p , e ) ;
26082: LD_VAR 0 5
26086: PPUSH
26087: LD_VAR 0 7
26091: PPUSH
26092: CALL_OW 120
// AddComChangeProfession ( p , j ) ;
26096: LD_VAR 0 5
26100: PPUSH
26101: LD_VAR 0 3
26105: PPUSH
26106: CALL_OW 183
// AddComExitBuilding ( p ) ;
26110: LD_VAR 0 5
26114: PPUSH
26115: CALL_OW 182
// end ; end ;
26119: GO 25967
26121: POP
26122: POP
// end ;
26123: GO 25933
26125: POP
26126: POP
// end ;
26127: GO 25688
26129: POP
26130: POP
// end ;
26131: LD_VAR 0 1
26135: RET
// export function MC_ClassCheckReq ( base ) ; var i , tmp , sol , eng , mech , sci , sort , j , p , b , bcount ; begin
26136: LD_INT 0
26138: PPUSH
26139: PPUSH
26140: PPUSH
26141: PPUSH
26142: PPUSH
26143: PPUSH
26144: PPUSH
26145: PPUSH
26146: PPUSH
26147: PPUSH
26148: PPUSH
26149: PPUSH
// if not base or not mc_bases [ base ] or not UnitFilter ( mc_bases [ base ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) then
26150: LD_VAR 0 1
26154: NOT
26155: PUSH
26156: LD_EXP 95
26160: PUSH
26161: LD_VAR 0 1
26165: ARRAY
26166: NOT
26167: OR
26168: PUSH
26169: LD_EXP 95
26173: PUSH
26174: LD_VAR 0 1
26178: ARRAY
26179: PPUSH
26180: LD_INT 2
26182: PUSH
26183: LD_INT 30
26185: PUSH
26186: LD_INT 0
26188: PUSH
26189: EMPTY
26190: LIST
26191: LIST
26192: PUSH
26193: LD_INT 30
26195: PUSH
26196: LD_INT 1
26198: PUSH
26199: EMPTY
26200: LIST
26201: LIST
26202: PUSH
26203: EMPTY
26204: LIST
26205: LIST
26206: LIST
26207: PPUSH
26208: CALL_OW 72
26212: NOT
26213: OR
26214: IFFALSE 26218
// exit ;
26216: GO 29721
// tmp := UnitFilter ( mc_bases [ base ] , [ f_or , [ f_class , 1 ] , [ f_class , 2 ] , [ f_class , 3 ] , [ f_class , 4 ] , [ f_class , 5 ] , [ f_class , 8 ] , [ f_class , 9 ] ] ) ;
26218: LD_ADDR_VAR 0 4
26222: PUSH
26223: LD_EXP 95
26227: PUSH
26228: LD_VAR 0 1
26232: ARRAY
26233: PPUSH
26234: LD_INT 2
26236: PUSH
26237: LD_INT 25
26239: PUSH
26240: LD_INT 1
26242: PUSH
26243: EMPTY
26244: LIST
26245: LIST
26246: PUSH
26247: LD_INT 25
26249: PUSH
26250: LD_INT 2
26252: PUSH
26253: EMPTY
26254: LIST
26255: LIST
26256: PUSH
26257: LD_INT 25
26259: PUSH
26260: LD_INT 3
26262: PUSH
26263: EMPTY
26264: LIST
26265: LIST
26266: PUSH
26267: LD_INT 25
26269: PUSH
26270: LD_INT 4
26272: PUSH
26273: EMPTY
26274: LIST
26275: LIST
26276: PUSH
26277: LD_INT 25
26279: PUSH
26280: LD_INT 5
26282: PUSH
26283: EMPTY
26284: LIST
26285: LIST
26286: PUSH
26287: LD_INT 25
26289: PUSH
26290: LD_INT 8
26292: PUSH
26293: EMPTY
26294: LIST
26295: LIST
26296: PUSH
26297: LD_INT 25
26299: PUSH
26300: LD_INT 9
26302: PUSH
26303: EMPTY
26304: LIST
26305: LIST
26306: PUSH
26307: EMPTY
26308: LIST
26309: LIST
26310: LIST
26311: LIST
26312: LIST
26313: LIST
26314: LIST
26315: LIST
26316: PPUSH
26317: CALL_OW 72
26321: ST_TO_ADDR
// if not tmp then
26322: LD_VAR 0 4
26326: NOT
26327: IFFALSE 26331
// exit ;
26329: GO 29721
// for i in tmp do
26331: LD_ADDR_VAR 0 3
26335: PUSH
26336: LD_VAR 0 4
26340: PUSH
26341: FOR_IN
26342: IFFALSE 26373
// if GetTag ( i ) then
26344: LD_VAR 0 3
26348: PPUSH
26349: CALL_OW 110
26353: IFFALSE 26371
// tmp := tmp diff i ;
26355: LD_ADDR_VAR 0 4
26359: PUSH
26360: LD_VAR 0 4
26364: PUSH
26365: LD_VAR 0 3
26369: DIFF
26370: ST_TO_ADDR
26371: GO 26341
26373: POP
26374: POP
// if not tmp then
26375: LD_VAR 0 4
26379: NOT
26380: IFFALSE 26384
// exit ;
26382: GO 29721
// sol := UnitFilter ( mc_bases [ base ] , [ f_or , [ f_class , 1 ] , [ f_class , 5 ] , [ f_class , 8 ] , [ f_class , 9 ] ] ) ;
26384: LD_ADDR_VAR 0 5
26388: PUSH
26389: LD_EXP 95
26393: PUSH
26394: LD_VAR 0 1
26398: ARRAY
26399: PPUSH
26400: LD_INT 2
26402: PUSH
26403: LD_INT 25
26405: PUSH
26406: LD_INT 1
26408: PUSH
26409: EMPTY
26410: LIST
26411: LIST
26412: PUSH
26413: LD_INT 25
26415: PUSH
26416: LD_INT 5
26418: PUSH
26419: EMPTY
26420: LIST
26421: LIST
26422: PUSH
26423: LD_INT 25
26425: PUSH
26426: LD_INT 8
26428: PUSH
26429: EMPTY
26430: LIST
26431: LIST
26432: PUSH
26433: LD_INT 25
26435: PUSH
26436: LD_INT 9
26438: PUSH
26439: EMPTY
26440: LIST
26441: LIST
26442: PUSH
26443: EMPTY
26444: LIST
26445: LIST
26446: LIST
26447: LIST
26448: LIST
26449: PPUSH
26450: CALL_OW 72
26454: ST_TO_ADDR
// eng := UnitFilter ( mc_bases [ base ] , [ f_class , 2 ] ) ;
26455: LD_ADDR_VAR 0 6
26459: PUSH
26460: LD_EXP 95
26464: PUSH
26465: LD_VAR 0 1
26469: ARRAY
26470: PPUSH
26471: LD_INT 25
26473: PUSH
26474: LD_INT 2
26476: PUSH
26477: EMPTY
26478: LIST
26479: LIST
26480: PPUSH
26481: CALL_OW 72
26485: ST_TO_ADDR
// mech := UnitFilter ( mc_bases [ base ] , [ f_class , 3 ] ) ;
26486: LD_ADDR_VAR 0 7
26490: PUSH
26491: LD_EXP 95
26495: PUSH
26496: LD_VAR 0 1
26500: ARRAY
26501: PPUSH
26502: LD_INT 25
26504: PUSH
26505: LD_INT 3
26507: PUSH
26508: EMPTY
26509: LIST
26510: LIST
26511: PPUSH
26512: CALL_OW 72
26516: ST_TO_ADDR
// sci := UnitFilter ( mc_bases [ base ] , [ [ f_class , 4 ] , [ f_lives , 251 ] ] ) ;
26517: LD_ADDR_VAR 0 8
26521: PUSH
26522: LD_EXP 95
26526: PUSH
26527: LD_VAR 0 1
26531: ARRAY
26532: PPUSH
26533: LD_INT 25
26535: PUSH
26536: LD_INT 4
26538: PUSH
26539: EMPTY
26540: LIST
26541: LIST
26542: PUSH
26543: LD_INT 24
26545: PUSH
26546: LD_INT 251
26548: PUSH
26549: EMPTY
26550: LIST
26551: LIST
26552: PUSH
26553: EMPTY
26554: LIST
26555: LIST
26556: PPUSH
26557: CALL_OW 72
26561: ST_TO_ADDR
// if mc_is_defending [ base ] then
26562: LD_EXP 138
26566: PUSH
26567: LD_VAR 0 1
26571: ARRAY
26572: IFFALSE 27033
// begin mc_class_case_use := Replace ( mc_class_case_use , base , 4 ) ;
26574: LD_ADDR_EXP 137
26578: PUSH
26579: LD_EXP 137
26583: PPUSH
26584: LD_VAR 0 1
26588: PPUSH
26589: LD_INT 4
26591: PPUSH
26592: CALL_OW 1
26596: ST_TO_ADDR
// b := UnitFilter ( mc_bases [ base ] , [ f_or , [ f_btype , b_armoury ] , [ f_btype , b_barracks ] ] ) ;
26597: LD_ADDR_VAR 0 12
26601: PUSH
26602: LD_EXP 95
26606: PUSH
26607: LD_VAR 0 1
26611: ARRAY
26612: PPUSH
26613: LD_INT 2
26615: PUSH
26616: LD_INT 30
26618: PUSH
26619: LD_INT 4
26621: PUSH
26622: EMPTY
26623: LIST
26624: LIST
26625: PUSH
26626: LD_INT 30
26628: PUSH
26629: LD_INT 5
26631: PUSH
26632: EMPTY
26633: LIST
26634: LIST
26635: PUSH
26636: EMPTY
26637: LIST
26638: LIST
26639: LIST
26640: PPUSH
26641: CALL_OW 72
26645: ST_TO_ADDR
// if not b then
26646: LD_VAR 0 12
26650: NOT
26651: IFFALSE 26655
// exit ;
26653: GO 29721
// p := [ ] ;
26655: LD_ADDR_VAR 0 11
26659: PUSH
26660: EMPTY
26661: ST_TO_ADDR
// if sci >= 2 then
26662: LD_VAR 0 8
26666: PUSH
26667: LD_INT 2
26669: GREATEREQUAL
26670: IFFALSE 26701
// sci := [ sci [ 1 ] , sci [ 2 ] ] else
26672: LD_ADDR_VAR 0 8
26676: PUSH
26677: LD_VAR 0 8
26681: PUSH
26682: LD_INT 1
26684: ARRAY
26685: PUSH
26686: LD_VAR 0 8
26690: PUSH
26691: LD_INT 2
26693: ARRAY
26694: PUSH
26695: EMPTY
26696: LIST
26697: LIST
26698: ST_TO_ADDR
26699: GO 26762
// if sci = 1 then
26701: LD_VAR 0 8
26705: PUSH
26706: LD_INT 1
26708: EQUAL
26709: IFFALSE 26730
// sci := [ sci [ 1 ] ] else
26711: LD_ADDR_VAR 0 8
26715: PUSH
26716: LD_VAR 0 8
26720: PUSH
26721: LD_INT 1
26723: ARRAY
26724: PUSH
26725: EMPTY
26726: LIST
26727: ST_TO_ADDR
26728: GO 26762
// if sci = 0 then
26730: LD_VAR 0 8
26734: PUSH
26735: LD_INT 0
26737: EQUAL
26738: IFFALSE 26762
// p := SortBySkill ( tmp , 4 ) [ 1 ] ;
26740: LD_ADDR_VAR 0 11
26744: PUSH
26745: LD_VAR 0 4
26749: PPUSH
26750: LD_INT 4
26752: PPUSH
26753: CALL 87221 0 2
26757: PUSH
26758: LD_INT 1
26760: ARRAY
26761: ST_TO_ADDR
// if eng > 4 then
26762: LD_VAR 0 6
26766: PUSH
26767: LD_INT 4
26769: GREATER
26770: IFFALSE 26816
// for i = eng downto 4 do
26772: LD_ADDR_VAR 0 3
26776: PUSH
26777: DOUBLE
26778: LD_VAR 0 6
26782: INC
26783: ST_TO_ADDR
26784: LD_INT 4
26786: PUSH
26787: FOR_DOWNTO
26788: IFFALSE 26814
// eng := eng diff eng [ i ] ;
26790: LD_ADDR_VAR 0 6
26794: PUSH
26795: LD_VAR 0 6
26799: PUSH
26800: LD_VAR 0 6
26804: PUSH
26805: LD_VAR 0 3
26809: ARRAY
26810: DIFF
26811: ST_TO_ADDR
26812: GO 26787
26814: POP
26815: POP
// tmp := tmp diff ( sol union eng union mech union sci ) ;
26816: LD_ADDR_VAR 0 4
26820: PUSH
26821: LD_VAR 0 4
26825: PUSH
26826: LD_VAR 0 5
26830: PUSH
26831: LD_VAR 0 6
26835: UNION
26836: PUSH
26837: LD_VAR 0 7
26841: UNION
26842: PUSH
26843: LD_VAR 0 8
26847: UNION
26848: DIFF
26849: ST_TO_ADDR
// bcount := UnitFilter ( mc_bases [ base ] , [ f_or , [ f_btype , b_bunker ] , [ f_btype , b_breastwork ] ] ) + UnitFilter ( mc_bases [ base ] , [ f_or , [ f_btype , b_armoury ] , [ f_btype , b_barracks ] ] ) * 6 ;
26850: LD_ADDR_VAR 0 13
26854: PUSH
26855: LD_EXP 95
26859: PUSH
26860: LD_VAR 0 1
26864: ARRAY
26865: PPUSH
26866: LD_INT 2
26868: PUSH
26869: LD_INT 30
26871: PUSH
26872: LD_INT 32
26874: PUSH
26875: EMPTY
26876: LIST
26877: LIST
26878: PUSH
26879: LD_INT 30
26881: PUSH
26882: LD_INT 31
26884: PUSH
26885: EMPTY
26886: LIST
26887: LIST
26888: PUSH
26889: EMPTY
26890: LIST
26891: LIST
26892: LIST
26893: PPUSH
26894: CALL_OW 72
26898: PUSH
26899: LD_EXP 95
26903: PUSH
26904: LD_VAR 0 1
26908: ARRAY
26909: PPUSH
26910: LD_INT 2
26912: PUSH
26913: LD_INT 30
26915: PUSH
26916: LD_INT 4
26918: PUSH
26919: EMPTY
26920: LIST
26921: LIST
26922: PUSH
26923: LD_INT 30
26925: PUSH
26926: LD_INT 5
26928: PUSH
26929: EMPTY
26930: LIST
26931: LIST
26932: PUSH
26933: EMPTY
26934: LIST
26935: LIST
26936: LIST
26937: PPUSH
26938: CALL_OW 72
26942: PUSH
26943: LD_INT 6
26945: MUL
26946: PLUS
26947: ST_TO_ADDR
// if bcount < tmp then
26948: LD_VAR 0 13
26952: PUSH
26953: LD_VAR 0 4
26957: LESS
26958: IFFALSE 27004
// for i = tmp downto bcount do
26960: LD_ADDR_VAR 0 3
26964: PUSH
26965: DOUBLE
26966: LD_VAR 0 4
26970: INC
26971: ST_TO_ADDR
26972: LD_VAR 0 13
26976: PUSH
26977: FOR_DOWNTO
26978: IFFALSE 27002
// tmp := Delete ( tmp , tmp ) ;
26980: LD_ADDR_VAR 0 4
26984: PUSH
26985: LD_VAR 0 4
26989: PPUSH
26990: LD_VAR 0 4
26994: PPUSH
26995: CALL_OW 3
26999: ST_TO_ADDR
27000: GO 26977
27002: POP
27003: POP
// result := [ tmp , 0 , 0 , p ] ;
27004: LD_ADDR_VAR 0 2
27008: PUSH
27009: LD_VAR 0 4
27013: PUSH
27014: LD_INT 0
27016: PUSH
27017: LD_INT 0
27019: PUSH
27020: LD_VAR 0 11
27024: PUSH
27025: EMPTY
27026: LIST
27027: LIST
27028: LIST
27029: LIST
27030: ST_TO_ADDR
// exit ;
27031: GO 29721
// end ; if not UnitFilter ( mc_bases [ base ] , [ f_or , [ f_btype , b_lab ] , [ f_btype , b_lab_half ] , [ f_btype , b_lab_full ] ] ) and not UnitFilter ( mc_bases [ base ] , [ f_btype , b_factory ] ) then
27033: LD_EXP 95
27037: PUSH
27038: LD_VAR 0 1
27042: ARRAY
27043: PPUSH
27044: LD_INT 2
27046: PUSH
27047: LD_INT 30
27049: PUSH
27050: LD_INT 6
27052: PUSH
27053: EMPTY
27054: LIST
27055: LIST
27056: PUSH
27057: LD_INT 30
27059: PUSH
27060: LD_INT 7
27062: PUSH
27063: EMPTY
27064: LIST
27065: LIST
27066: PUSH
27067: LD_INT 30
27069: PUSH
27070: LD_INT 8
27072: PUSH
27073: EMPTY
27074: LIST
27075: LIST
27076: PUSH
27077: EMPTY
27078: LIST
27079: LIST
27080: LIST
27081: LIST
27082: PPUSH
27083: CALL_OW 72
27087: NOT
27088: PUSH
27089: LD_EXP 95
27093: PUSH
27094: LD_VAR 0 1
27098: ARRAY
27099: PPUSH
27100: LD_INT 30
27102: PUSH
27103: LD_INT 3
27105: PUSH
27106: EMPTY
27107: LIST
27108: LIST
27109: PPUSH
27110: CALL_OW 72
27114: NOT
27115: AND
27116: IFFALSE 27188
// begin if eng = tmp then
27118: LD_VAR 0 6
27122: PUSH
27123: LD_VAR 0 4
27127: EQUAL
27128: IFFALSE 27132
// exit ;
27130: GO 29721
// mc_class_case_use := Replace ( mc_class_case_use , base , 1 ) ;
27132: LD_ADDR_EXP 137
27136: PUSH
27137: LD_EXP 137
27141: PPUSH
27142: LD_VAR 0 1
27146: PPUSH
27147: LD_INT 1
27149: PPUSH
27150: CALL_OW 1
27154: ST_TO_ADDR
// result := [ 0 , tmp diff eng , 0 , 0 ] ;
27155: LD_ADDR_VAR 0 2
27159: PUSH
27160: LD_INT 0
27162: PUSH
27163: LD_VAR 0 4
27167: PUSH
27168: LD_VAR 0 6
27172: DIFF
27173: PUSH
27174: LD_INT 0
27176: PUSH
27177: LD_INT 0
27179: PUSH
27180: EMPTY
27181: LIST
27182: LIST
27183: LIST
27184: LIST
27185: ST_TO_ADDR
// exit ;
27186: GO 29721
// end ; if mc_tech [ mc_sides [ base ] ] and UnitFilter ( mc_bases [ base ] , [ f_or , [ f_btype , b_lab ] , [ f_btype , b_lab_half ] , [ f_btype , b_lab_full ] ] ) and not UnitFilter ( mc_bases [ base ] , [ f_btype , b_factory ] ) then
27188: LD_EXP 122
27192: PUSH
27193: LD_EXP 121
27197: PUSH
27198: LD_VAR 0 1
27202: ARRAY
27203: ARRAY
27204: PUSH
27205: LD_EXP 95
27209: PUSH
27210: LD_VAR 0 1
27214: ARRAY
27215: PPUSH
27216: LD_INT 2
27218: PUSH
27219: LD_INT 30
27221: PUSH
27222: LD_INT 6
27224: PUSH
27225: EMPTY
27226: LIST
27227: LIST
27228: PUSH
27229: LD_INT 30
27231: PUSH
27232: LD_INT 7
27234: PUSH
27235: EMPTY
27236: LIST
27237: LIST
27238: PUSH
27239: LD_INT 30
27241: PUSH
27242: LD_INT 8
27244: PUSH
27245: EMPTY
27246: LIST
27247: LIST
27248: PUSH
27249: EMPTY
27250: LIST
27251: LIST
27252: LIST
27253: LIST
27254: PPUSH
27255: CALL_OW 72
27259: AND
27260: PUSH
27261: LD_EXP 95
27265: PUSH
27266: LD_VAR 0 1
27270: ARRAY
27271: PPUSH
27272: LD_INT 30
27274: PUSH
27275: LD_INT 3
27277: PUSH
27278: EMPTY
27279: LIST
27280: LIST
27281: PPUSH
27282: CALL_OW 72
27286: NOT
27287: AND
27288: IFFALSE 27502
// begin if sci >= 6 then
27290: LD_VAR 0 8
27294: PUSH
27295: LD_INT 6
27297: GREATEREQUAL
27298: IFFALSE 27302
// exit ;
27300: GO 29721
// mc_class_case_use := Replace ( mc_class_case_use , base , 2 ) ;
27302: LD_ADDR_EXP 137
27306: PUSH
27307: LD_EXP 137
27311: PPUSH
27312: LD_VAR 0 1
27316: PPUSH
27317: LD_INT 2
27319: PPUSH
27320: CALL_OW 1
27324: ST_TO_ADDR
// sort := SortBySkill ( tmp diff sci , 4 ) ;
27325: LD_ADDR_VAR 0 9
27329: PUSH
27330: LD_VAR 0 4
27334: PUSH
27335: LD_VAR 0 8
27339: DIFF
27340: PPUSH
27341: LD_INT 4
27343: PPUSH
27344: CALL 87221 0 2
27348: ST_TO_ADDR
// p := [ ] ;
27349: LD_ADDR_VAR 0 11
27353: PUSH
27354: EMPTY
27355: ST_TO_ADDR
// if sci < 6 and sort > 6 then
27356: LD_VAR 0 8
27360: PUSH
27361: LD_INT 6
27363: LESS
27364: PUSH
27365: LD_VAR 0 9
27369: PUSH
27370: LD_INT 6
27372: GREATER
27373: AND
27374: IFFALSE 27455
// begin for i = 1 to 6 - sci do
27376: LD_ADDR_VAR 0 3
27380: PUSH
27381: DOUBLE
27382: LD_INT 1
27384: DEC
27385: ST_TO_ADDR
27386: LD_INT 6
27388: PUSH
27389: LD_VAR 0 8
27393: MINUS
27394: PUSH
27395: FOR_TO
27396: IFFALSE 27451
// begin p := Insert ( p , p + 1 , sort [ 1 ] ) ;
27398: LD_ADDR_VAR 0 11
27402: PUSH
27403: LD_VAR 0 11
27407: PPUSH
27408: LD_VAR 0 11
27412: PUSH
27413: LD_INT 1
27415: PLUS
27416: PPUSH
27417: LD_VAR 0 9
27421: PUSH
27422: LD_INT 1
27424: ARRAY
27425: PPUSH
27426: CALL_OW 2
27430: ST_TO_ADDR
// sort := Delete ( sort , 1 ) ;
27431: LD_ADDR_VAR 0 9
27435: PUSH
27436: LD_VAR 0 9
27440: PPUSH
27441: LD_INT 1
27443: PPUSH
27444: CALL_OW 3
27448: ST_TO_ADDR
// end ;
27449: GO 27395
27451: POP
27452: POP
// end else
27453: GO 27475
// if sort then
27455: LD_VAR 0 9
27459: IFFALSE 27475
// p := sort [ 1 ] ;
27461: LD_ADDR_VAR 0 11
27465: PUSH
27466: LD_VAR 0 9
27470: PUSH
27471: LD_INT 1
27473: ARRAY
27474: ST_TO_ADDR
// result := [ 0 , 0 , 0 , p ] ;
27475: LD_ADDR_VAR 0 2
27479: PUSH
27480: LD_INT 0
27482: PUSH
27483: LD_INT 0
27485: PUSH
27486: LD_INT 0
27488: PUSH
27489: LD_VAR 0 11
27493: PUSH
27494: EMPTY
27495: LIST
27496: LIST
27497: LIST
27498: LIST
27499: ST_TO_ADDR
// exit ;
27500: GO 29721
// end ; if mc_tech [ mc_sides [ base ] ] and UnitFilter ( mc_bases [ base ] , [ f_or , [ f_btype , b_lab ] , [ f_btype , b_lab_half ] , [ f_btype , b_lab_full ] ] ) and UnitFilter ( mc_bases [ base ] , [ f_btype , b_factory ] ) then
27502: LD_EXP 122
27506: PUSH
27507: LD_EXP 121
27511: PUSH
27512: LD_VAR 0 1
27516: ARRAY
27517: ARRAY
27518: PUSH
27519: LD_EXP 95
27523: PUSH
27524: LD_VAR 0 1
27528: ARRAY
27529: PPUSH
27530: LD_INT 2
27532: PUSH
27533: LD_INT 30
27535: PUSH
27536: LD_INT 6
27538: PUSH
27539: EMPTY
27540: LIST
27541: LIST
27542: PUSH
27543: LD_INT 30
27545: PUSH
27546: LD_INT 7
27548: PUSH
27549: EMPTY
27550: LIST
27551: LIST
27552: PUSH
27553: LD_INT 30
27555: PUSH
27556: LD_INT 8
27558: PUSH
27559: EMPTY
27560: LIST
27561: LIST
27562: PUSH
27563: EMPTY
27564: LIST
27565: LIST
27566: LIST
27567: LIST
27568: PPUSH
27569: CALL_OW 72
27573: AND
27574: PUSH
27575: LD_EXP 95
27579: PUSH
27580: LD_VAR 0 1
27584: ARRAY
27585: PPUSH
27586: LD_INT 30
27588: PUSH
27589: LD_INT 3
27591: PUSH
27592: EMPTY
27593: LIST
27594: LIST
27595: PPUSH
27596: CALL_OW 72
27600: AND
27601: IFFALSE 28335
// begin mc_class_case_use := Replace ( mc_class_case_use , base , 3 ) ;
27603: LD_ADDR_EXP 137
27607: PUSH
27608: LD_EXP 137
27612: PPUSH
27613: LD_VAR 0 1
27617: PPUSH
27618: LD_INT 3
27620: PPUSH
27621: CALL_OW 1
27625: ST_TO_ADDR
// result := [ 0 , 0 , 0 , 0 ] ;
27626: LD_ADDR_VAR 0 2
27630: PUSH
27631: LD_INT 0
27633: PUSH
27634: LD_INT 0
27636: PUSH
27637: LD_INT 0
27639: PUSH
27640: LD_INT 0
27642: PUSH
27643: EMPTY
27644: LIST
27645: LIST
27646: LIST
27647: LIST
27648: ST_TO_ADDR
// if not eng then
27649: LD_VAR 0 6
27653: NOT
27654: IFFALSE 27717
// begin p := SortBySkill ( tmp , 2 ) [ 1 ] ;
27656: LD_ADDR_VAR 0 11
27660: PUSH
27661: LD_VAR 0 4
27665: PPUSH
27666: LD_INT 2
27668: PPUSH
27669: CALL 87221 0 2
27673: PUSH
27674: LD_INT 1
27676: ARRAY
27677: ST_TO_ADDR
// result := Replace ( result , 2 , p ) ;
27678: LD_ADDR_VAR 0 2
27682: PUSH
27683: LD_VAR 0 2
27687: PPUSH
27688: LD_INT 2
27690: PPUSH
27691: LD_VAR 0 11
27695: PPUSH
27696: CALL_OW 1
27700: ST_TO_ADDR
// tmp := tmp diff p ;
27701: LD_ADDR_VAR 0 4
27705: PUSH
27706: LD_VAR 0 4
27710: PUSH
27711: LD_VAR 0 11
27715: DIFF
27716: ST_TO_ADDR
// end ; if tmp and sci < 6 then
27717: LD_VAR 0 4
27721: PUSH
27722: LD_VAR 0 8
27726: PUSH
27727: LD_INT 6
27729: LESS
27730: AND
27731: IFFALSE 27919
// begin sort := SortBySkill ( tmp diff ( sci union mech ) , 4 ) ;
27733: LD_ADDR_VAR 0 9
27737: PUSH
27738: LD_VAR 0 4
27742: PUSH
27743: LD_VAR 0 8
27747: PUSH
27748: LD_VAR 0 7
27752: UNION
27753: DIFF
27754: PPUSH
27755: LD_INT 4
27757: PPUSH
27758: CALL 87221 0 2
27762: ST_TO_ADDR
// p := [ ] ;
27763: LD_ADDR_VAR 0 11
27767: PUSH
27768: EMPTY
27769: ST_TO_ADDR
// if sort then
27770: LD_VAR 0 9
27774: IFFALSE 27890
// for i = 1 to 6 - sci do
27776: LD_ADDR_VAR 0 3
27780: PUSH
27781: DOUBLE
27782: LD_INT 1
27784: DEC
27785: ST_TO_ADDR
27786: LD_INT 6
27788: PUSH
27789: LD_VAR 0 8
27793: MINUS
27794: PUSH
27795: FOR_TO
27796: IFFALSE 27888
// begin if i = sort then
27798: LD_VAR 0 3
27802: PUSH
27803: LD_VAR 0 9
27807: EQUAL
27808: IFFALSE 27812
// break ;
27810: GO 27888
// if GetClass ( i ) = 4 then
27812: LD_VAR 0 3
27816: PPUSH
27817: CALL_OW 257
27821: PUSH
27822: LD_INT 4
27824: EQUAL
27825: IFFALSE 27829
// continue ;
27827: GO 27795
// p := Insert ( p , p + 1 , sort [ i ] ) ;
27829: LD_ADDR_VAR 0 11
27833: PUSH
27834: LD_VAR 0 11
27838: PPUSH
27839: LD_VAR 0 11
27843: PUSH
27844: LD_INT 1
27846: PLUS
27847: PPUSH
27848: LD_VAR 0 9
27852: PUSH
27853: LD_VAR 0 3
27857: ARRAY
27858: PPUSH
27859: CALL_OW 2
27863: ST_TO_ADDR
// tmp := tmp diff sort [ i ] ;
27864: LD_ADDR_VAR 0 4
27868: PUSH
27869: LD_VAR 0 4
27873: PUSH
27874: LD_VAR 0 9
27878: PUSH
27879: LD_VAR 0 3
27883: ARRAY
27884: DIFF
27885: ST_TO_ADDR
// end ;
27886: GO 27795
27888: POP
27889: POP
// if p then
27890: LD_VAR 0 11
27894: IFFALSE 27919
// result := Replace ( result , 4 , p ) ;
27896: LD_ADDR_VAR 0 2
27900: PUSH
27901: LD_VAR 0 2
27905: PPUSH
27906: LD_INT 4
27908: PPUSH
27909: LD_VAR 0 11
27913: PPUSH
27914: CALL_OW 1
27918: ST_TO_ADDR
// end ; if tmp and mech < 6 then
27919: LD_VAR 0 4
27923: PUSH
27924: LD_VAR 0 7
27928: PUSH
27929: LD_INT 6
27931: LESS
27932: AND
27933: IFFALSE 28121
// begin sort := SortBySkill ( tmp diff ( sci union mech ) , 3 ) ;
27935: LD_ADDR_VAR 0 9
27939: PUSH
27940: LD_VAR 0 4
27944: PUSH
27945: LD_VAR 0 8
27949: PUSH
27950: LD_VAR 0 7
27954: UNION
27955: DIFF
27956: PPUSH
27957: LD_INT 3
27959: PPUSH
27960: CALL 87221 0 2
27964: ST_TO_ADDR
// p := [ ] ;
27965: LD_ADDR_VAR 0 11
27969: PUSH
27970: EMPTY
27971: ST_TO_ADDR
// if sort then
27972: LD_VAR 0 9
27976: IFFALSE 28092
// for i = 1 to 6 - mech do
27978: LD_ADDR_VAR 0 3
27982: PUSH
27983: DOUBLE
27984: LD_INT 1
27986: DEC
27987: ST_TO_ADDR
27988: LD_INT 6
27990: PUSH
27991: LD_VAR 0 7
27995: MINUS
27996: PUSH
27997: FOR_TO
27998: IFFALSE 28090
// begin if i = sort then
28000: LD_VAR 0 3
28004: PUSH
28005: LD_VAR 0 9
28009: EQUAL
28010: IFFALSE 28014
// break ;
28012: GO 28090
// if GetClass ( i ) = 3 then
28014: LD_VAR 0 3
28018: PPUSH
28019: CALL_OW 257
28023: PUSH
28024: LD_INT 3
28026: EQUAL
28027: IFFALSE 28031
// continue ;
28029: GO 27997
// p := Insert ( p , p + 1 , sort [ i ] ) ;
28031: LD_ADDR_VAR 0 11
28035: PUSH
28036: LD_VAR 0 11
28040: PPUSH
28041: LD_VAR 0 11
28045: PUSH
28046: LD_INT 1
28048: PLUS
28049: PPUSH
28050: LD_VAR 0 9
28054: PUSH
28055: LD_VAR 0 3
28059: ARRAY
28060: PPUSH
28061: CALL_OW 2
28065: ST_TO_ADDR
// tmp := tmp diff sort [ i ] ;
28066: LD_ADDR_VAR 0 4
28070: PUSH
28071: LD_VAR 0 4
28075: PUSH
28076: LD_VAR 0 9
28080: PUSH
28081: LD_VAR 0 3
28085: ARRAY
28086: DIFF
28087: ST_TO_ADDR
// end ;
28088: GO 27997
28090: POP
28091: POP
// if p then
28092: LD_VAR 0 11
28096: IFFALSE 28121
// result := Replace ( result , 3 , p ) ;
28098: LD_ADDR_VAR 0 2
28102: PUSH
28103: LD_VAR 0 2
28107: PPUSH
28108: LD_INT 3
28110: PPUSH
28111: LD_VAR 0 11
28115: PPUSH
28116: CALL_OW 1
28120: ST_TO_ADDR
// end ; if tmp > 6 and eng < 6 then
28121: LD_VAR 0 4
28125: PUSH
28126: LD_INT 6
28128: GREATER
28129: PUSH
28130: LD_VAR 0 6
28134: PUSH
28135: LD_INT 6
28137: LESS
28138: AND
28139: IFFALSE 28333
// begin sort := SortBySkill ( tmp diff ( sci union mech union eng ) , 2 ) ;
28141: LD_ADDR_VAR 0 9
28145: PUSH
28146: LD_VAR 0 4
28150: PUSH
28151: LD_VAR 0 8
28155: PUSH
28156: LD_VAR 0 7
28160: UNION
28161: PUSH
28162: LD_VAR 0 6
28166: UNION
28167: DIFF
28168: PPUSH
28169: LD_INT 2
28171: PPUSH
28172: CALL 87221 0 2
28176: ST_TO_ADDR
// p := [ ] ;
28177: LD_ADDR_VAR 0 11
28181: PUSH
28182: EMPTY
28183: ST_TO_ADDR
// if sort then
28184: LD_VAR 0 9
28188: IFFALSE 28304
// for i = 1 to 6 - eng do
28190: LD_ADDR_VAR 0 3
28194: PUSH
28195: DOUBLE
28196: LD_INT 1
28198: DEC
28199: ST_TO_ADDR
28200: LD_INT 6
28202: PUSH
28203: LD_VAR 0 6
28207: MINUS
28208: PUSH
28209: FOR_TO
28210: IFFALSE 28302
// begin if i = sort then
28212: LD_VAR 0 3
28216: PUSH
28217: LD_VAR 0 9
28221: EQUAL
28222: IFFALSE 28226
// break ;
28224: GO 28302
// if GetClass ( i ) = 2 then
28226: LD_VAR 0 3
28230: PPUSH
28231: CALL_OW 257
28235: PUSH
28236: LD_INT 2
28238: EQUAL
28239: IFFALSE 28243
// continue ;
28241: GO 28209
// p := Insert ( p , p + 1 , sort [ i ] ) ;
28243: LD_ADDR_VAR 0 11
28247: PUSH
28248: LD_VAR 0 11
28252: PPUSH
28253: LD_VAR 0 11
28257: PUSH
28258: LD_INT 1
28260: PLUS
28261: PPUSH
28262: LD_VAR 0 9
28266: PUSH
28267: LD_VAR 0 3
28271: ARRAY
28272: PPUSH
28273: CALL_OW 2
28277: ST_TO_ADDR
// tmp := tmp diff sort [ i ] ;
28278: LD_ADDR_VAR 0 4
28282: PUSH
28283: LD_VAR 0 4
28287: PUSH
28288: LD_VAR 0 9
28292: PUSH
28293: LD_VAR 0 3
28297: ARRAY
28298: DIFF
28299: ST_TO_ADDR
// end ;
28300: GO 28209
28302: POP
28303: POP
// if p then
28304: LD_VAR 0 11
28308: IFFALSE 28333
// result := Replace ( result , 2 , p ) ;
28310: LD_ADDR_VAR 0 2
28314: PUSH
28315: LD_VAR 0 2
28319: PPUSH
28320: LD_INT 2
28322: PPUSH
28323: LD_VAR 0 11
28327: PPUSH
28328: CALL_OW 1
28332: ST_TO_ADDR
// end ; exit ;
28333: GO 29721
// end ; if not mc_tech [ mc_sides [ base ] ] and UnitFilter ( mc_bases [ base ] , [ f_btype , b_factory ] ) and mc_build_list [ base ] then
28335: LD_EXP 122
28339: PUSH
28340: LD_EXP 121
28344: PUSH
28345: LD_VAR 0 1
28349: ARRAY
28350: ARRAY
28351: NOT
28352: PUSH
28353: LD_EXP 95
28357: PUSH
28358: LD_VAR 0 1
28362: ARRAY
28363: PPUSH
28364: LD_INT 30
28366: PUSH
28367: LD_INT 3
28369: PUSH
28370: EMPTY
28371: LIST
28372: LIST
28373: PPUSH
28374: CALL_OW 72
28378: AND
28379: PUSH
28380: LD_EXP 100
28384: PUSH
28385: LD_VAR 0 1
28389: ARRAY
28390: AND
28391: IFFALSE 28999
// begin mc_class_case_use := Replace ( mc_class_case_use , base , 5 ) ;
28393: LD_ADDR_EXP 137
28397: PUSH
28398: LD_EXP 137
28402: PPUSH
28403: LD_VAR 0 1
28407: PPUSH
28408: LD_INT 5
28410: PPUSH
28411: CALL_OW 1
28415: ST_TO_ADDR
// result := [ 0 , 0 , 0 , 0 ] ;
28416: LD_ADDR_VAR 0 2
28420: PUSH
28421: LD_INT 0
28423: PUSH
28424: LD_INT 0
28426: PUSH
28427: LD_INT 0
28429: PUSH
28430: LD_INT 0
28432: PUSH
28433: EMPTY
28434: LIST
28435: LIST
28436: LIST
28437: LIST
28438: ST_TO_ADDR
// if sci > 1 then
28439: LD_VAR 0 8
28443: PUSH
28444: LD_INT 1
28446: GREATER
28447: IFFALSE 28475
// tmp := tmp diff ( sci diff sci [ 1 ] ) ;
28449: LD_ADDR_VAR 0 4
28453: PUSH
28454: LD_VAR 0 4
28458: PUSH
28459: LD_VAR 0 8
28463: PUSH
28464: LD_VAR 0 8
28468: PUSH
28469: LD_INT 1
28471: ARRAY
28472: DIFF
28473: DIFF
28474: ST_TO_ADDR
// if tmp and not sci then
28475: LD_VAR 0 4
28479: PUSH
28480: LD_VAR 0 8
28484: NOT
28485: AND
28486: IFFALSE 28555
// begin sort := SortBySkill ( tmp , 4 ) ;
28488: LD_ADDR_VAR 0 9
28492: PUSH
28493: LD_VAR 0 4
28497: PPUSH
28498: LD_INT 4
28500: PPUSH
28501: CALL 87221 0 2
28505: ST_TO_ADDR
// if sort then
28506: LD_VAR 0 9
28510: IFFALSE 28526
// p := sort [ 1 ] ;
28512: LD_ADDR_VAR 0 11
28516: PUSH
28517: LD_VAR 0 9
28521: PUSH
28522: LD_INT 1
28524: ARRAY
28525: ST_TO_ADDR
// if p then
28526: LD_VAR 0 11
28530: IFFALSE 28555
// result := Replace ( result , 4 , p ) ;
28532: LD_ADDR_VAR 0 2
28536: PUSH
28537: LD_VAR 0 2
28541: PPUSH
28542: LD_INT 4
28544: PPUSH
28545: LD_VAR 0 11
28549: PPUSH
28550: CALL_OW 1
28554: ST_TO_ADDR
// end ; tmp := tmp diff mech ;
28555: LD_ADDR_VAR 0 4
28559: PUSH
28560: LD_VAR 0 4
28564: PUSH
28565: LD_VAR 0 7
28569: DIFF
28570: ST_TO_ADDR
// if tmp and mech < 6 then
28571: LD_VAR 0 4
28575: PUSH
28576: LD_VAR 0 7
28580: PUSH
28581: LD_INT 6
28583: LESS
28584: AND
28585: IFFALSE 28773
// begin sort := SortBySkill ( tmp diff ( sci union mech ) , 3 ) ;
28587: LD_ADDR_VAR 0 9
28591: PUSH
28592: LD_VAR 0 4
28596: PUSH
28597: LD_VAR 0 8
28601: PUSH
28602: LD_VAR 0 7
28606: UNION
28607: DIFF
28608: PPUSH
28609: LD_INT 3
28611: PPUSH
28612: CALL 87221 0 2
28616: ST_TO_ADDR
// p := [ ] ;
28617: LD_ADDR_VAR 0 11
28621: PUSH
28622: EMPTY
28623: ST_TO_ADDR
// if sort then
28624: LD_VAR 0 9
28628: IFFALSE 28744
// for i = 1 to 6 - mech do
28630: LD_ADDR_VAR 0 3
28634: PUSH
28635: DOUBLE
28636: LD_INT 1
28638: DEC
28639: ST_TO_ADDR
28640: LD_INT 6
28642: PUSH
28643: LD_VAR 0 7
28647: MINUS
28648: PUSH
28649: FOR_TO
28650: IFFALSE 28742
// begin if i = sort then
28652: LD_VAR 0 3
28656: PUSH
28657: LD_VAR 0 9
28661: EQUAL
28662: IFFALSE 28666
// break ;
28664: GO 28742
// if GetClass ( i ) = 3 then
28666: LD_VAR 0 3
28670: PPUSH
28671: CALL_OW 257
28675: PUSH
28676: LD_INT 3
28678: EQUAL
28679: IFFALSE 28683
// continue ;
28681: GO 28649
// p := Insert ( p , p + 1 , sort [ i ] ) ;
28683: LD_ADDR_VAR 0 11
28687: PUSH
28688: LD_VAR 0 11
28692: PPUSH
28693: LD_VAR 0 11
28697: PUSH
28698: LD_INT 1
28700: PLUS
28701: PPUSH
28702: LD_VAR 0 9
28706: PUSH
28707: LD_VAR 0 3
28711: ARRAY
28712: PPUSH
28713: CALL_OW 2
28717: ST_TO_ADDR
// tmp := tmp diff sort [ i ] ;
28718: LD_ADDR_VAR 0 4
28722: PUSH
28723: LD_VAR 0 4
28727: PUSH
28728: LD_VAR 0 9
28732: PUSH
28733: LD_VAR 0 3
28737: ARRAY
28738: DIFF
28739: ST_TO_ADDR
// end ;
28740: GO 28649
28742: POP
28743: POP
// if p then
28744: LD_VAR 0 11
28748: IFFALSE 28773
// result := Replace ( result , 3 , p ) ;
28750: LD_ADDR_VAR 0 2
28754: PUSH
28755: LD_VAR 0 2
28759: PPUSH
28760: LD_INT 3
28762: PPUSH
28763: LD_VAR 0 11
28767: PPUSH
28768: CALL_OW 1
28772: ST_TO_ADDR
// end ; tmp := tmp diff eng ;
28773: LD_ADDR_VAR 0 4
28777: PUSH
28778: LD_VAR 0 4
28782: PUSH
28783: LD_VAR 0 6
28787: DIFF
28788: ST_TO_ADDR
// if tmp and eng < 6 then
28789: LD_VAR 0 4
28793: PUSH
28794: LD_VAR 0 6
28798: PUSH
28799: LD_INT 6
28801: LESS
28802: AND
28803: IFFALSE 28997
// begin sort := SortBySkill ( tmp diff ( sci union mech union eng ) , 2 ) ;
28805: LD_ADDR_VAR 0 9
28809: PUSH
28810: LD_VAR 0 4
28814: PUSH
28815: LD_VAR 0 8
28819: PUSH
28820: LD_VAR 0 7
28824: UNION
28825: PUSH
28826: LD_VAR 0 6
28830: UNION
28831: DIFF
28832: PPUSH
28833: LD_INT 2
28835: PPUSH
28836: CALL 87221 0 2
28840: ST_TO_ADDR
// p := [ ] ;
28841: LD_ADDR_VAR 0 11
28845: PUSH
28846: EMPTY
28847: ST_TO_ADDR
// if sort then
28848: LD_VAR 0 9
28852: IFFALSE 28968
// for i = 1 to 6 - eng do
28854: LD_ADDR_VAR 0 3
28858: PUSH
28859: DOUBLE
28860: LD_INT 1
28862: DEC
28863: ST_TO_ADDR
28864: LD_INT 6
28866: PUSH
28867: LD_VAR 0 6
28871: MINUS
28872: PUSH
28873: FOR_TO
28874: IFFALSE 28966
// begin if i = sort then
28876: LD_VAR 0 3
28880: PUSH
28881: LD_VAR 0 9
28885: EQUAL
28886: IFFALSE 28890
// break ;
28888: GO 28966
// if GetClass ( i ) = 2 then
28890: LD_VAR 0 3
28894: PPUSH
28895: CALL_OW 257
28899: PUSH
28900: LD_INT 2
28902: EQUAL
28903: IFFALSE 28907
// continue ;
28905: GO 28873
// p := Insert ( p , p + 1 , sort [ i ] ) ;
28907: LD_ADDR_VAR 0 11
28911: PUSH
28912: LD_VAR 0 11
28916: PPUSH
28917: LD_VAR 0 11
28921: PUSH
28922: LD_INT 1
28924: PLUS
28925: PPUSH
28926: LD_VAR 0 9
28930: PUSH
28931: LD_VAR 0 3
28935: ARRAY
28936: PPUSH
28937: CALL_OW 2
28941: ST_TO_ADDR
// tmp := tmp diff sort [ i ] ;
28942: LD_ADDR_VAR 0 4
28946: PUSH
28947: LD_VAR 0 4
28951: PUSH
28952: LD_VAR 0 9
28956: PUSH
28957: LD_VAR 0 3
28961: ARRAY
28962: DIFF
28963: ST_TO_ADDR
// end ;
28964: GO 28873
28966: POP
28967: POP
// if p then
28968: LD_VAR 0 11
28972: IFFALSE 28997
// result := Replace ( result , 2 , p ) ;
28974: LD_ADDR_VAR 0 2
28978: PUSH
28979: LD_VAR 0 2
28983: PPUSH
28984: LD_INT 2
28986: PPUSH
28987: LD_VAR 0 11
28991: PPUSH
28992: CALL_OW 1
28996: ST_TO_ADDR
// end ; exit ;
28997: GO 29721
// end ; if not mc_tech [ mc_sides [ base ] ] and UnitFilter ( mc_bases [ base ] , [ f_btype , b_factory ] ) and not mc_build_list [ base ] then
28999: LD_EXP 122
29003: PUSH
29004: LD_EXP 121
29008: PUSH
29009: LD_VAR 0 1
29013: ARRAY
29014: ARRAY
29015: NOT
29016: PUSH
29017: LD_EXP 95
29021: PUSH
29022: LD_VAR 0 1
29026: ARRAY
29027: PPUSH
29028: LD_INT 30
29030: PUSH
29031: LD_INT 3
29033: PUSH
29034: EMPTY
29035: LIST
29036: LIST
29037: PPUSH
29038: CALL_OW 72
29042: AND
29043: PUSH
29044: LD_EXP 100
29048: PUSH
29049: LD_VAR 0 1
29053: ARRAY
29054: NOT
29055: AND
29056: IFFALSE 29721
// begin mc_class_case_use := Replace ( mc_class_case_use , base , 6 ) ;
29058: LD_ADDR_EXP 137
29062: PUSH
29063: LD_EXP 137
29067: PPUSH
29068: LD_VAR 0 1
29072: PPUSH
29073: LD_INT 6
29075: PPUSH
29076: CALL_OW 1
29080: ST_TO_ADDR
// result := [ 0 , 0 , 0 , 0 ] ;
29081: LD_ADDR_VAR 0 2
29085: PUSH
29086: LD_INT 0
29088: PUSH
29089: LD_INT 0
29091: PUSH
29092: LD_INT 0
29094: PUSH
29095: LD_INT 0
29097: PUSH
29098: EMPTY
29099: LIST
29100: LIST
29101: LIST
29102: LIST
29103: ST_TO_ADDR
// if sci >= 1 then
29104: LD_VAR 0 8
29108: PUSH
29109: LD_INT 1
29111: GREATEREQUAL
29112: IFFALSE 29134
// tmp := tmp diff sci [ 1 ] ;
29114: LD_ADDR_VAR 0 4
29118: PUSH
29119: LD_VAR 0 4
29123: PUSH
29124: LD_VAR 0 8
29128: PUSH
29129: LD_INT 1
29131: ARRAY
29132: DIFF
29133: ST_TO_ADDR
// if tmp and not sci then
29134: LD_VAR 0 4
29138: PUSH
29139: LD_VAR 0 8
29143: NOT
29144: AND
29145: IFFALSE 29214
// begin sort := SortBySkill ( tmp , 4 ) ;
29147: LD_ADDR_VAR 0 9
29151: PUSH
29152: LD_VAR 0 4
29156: PPUSH
29157: LD_INT 4
29159: PPUSH
29160: CALL 87221 0 2
29164: ST_TO_ADDR
// if sort then
29165: LD_VAR 0 9
29169: IFFALSE 29185
// p := sort [ 1 ] ;
29171: LD_ADDR_VAR 0 11
29175: PUSH
29176: LD_VAR 0 9
29180: PUSH
29181: LD_INT 1
29183: ARRAY
29184: ST_TO_ADDR
// if p then
29185: LD_VAR 0 11
29189: IFFALSE 29214
// result := Replace ( result , 4 , p ) ;
29191: LD_ADDR_VAR 0 2
29195: PUSH
29196: LD_VAR 0 2
29200: PPUSH
29201: LD_INT 4
29203: PPUSH
29204: LD_VAR 0 11
29208: PPUSH
29209: CALL_OW 1
29213: ST_TO_ADDR
// end ; tmp := tmp diff mech ;
29214: LD_ADDR_VAR 0 4
29218: PUSH
29219: LD_VAR 0 4
29223: PUSH
29224: LD_VAR 0 7
29228: DIFF
29229: ST_TO_ADDR
// if tmp and mech < 6 then
29230: LD_VAR 0 4
29234: PUSH
29235: LD_VAR 0 7
29239: PUSH
29240: LD_INT 6
29242: LESS
29243: AND
29244: IFFALSE 29426
// begin sort := SortBySkill ( tmp diff mech , 3 ) ;
29246: LD_ADDR_VAR 0 9
29250: PUSH
29251: LD_VAR 0 4
29255: PUSH
29256: LD_VAR 0 7
29260: DIFF
29261: PPUSH
29262: LD_INT 3
29264: PPUSH
29265: CALL 87221 0 2
29269: ST_TO_ADDR
// p := [ ] ;
29270: LD_ADDR_VAR 0 11
29274: PUSH
29275: EMPTY
29276: ST_TO_ADDR
// if sort then
29277: LD_VAR 0 9
29281: IFFALSE 29397
// for i = 1 to 6 - mech do
29283: LD_ADDR_VAR 0 3
29287: PUSH
29288: DOUBLE
29289: LD_INT 1
29291: DEC
29292: ST_TO_ADDR
29293: LD_INT 6
29295: PUSH
29296: LD_VAR 0 7
29300: MINUS
29301: PUSH
29302: FOR_TO
29303: IFFALSE 29395
// begin if i = sort then
29305: LD_VAR 0 3
29309: PUSH
29310: LD_VAR 0 9
29314: EQUAL
29315: IFFALSE 29319
// break ;
29317: GO 29395
// if GetClass ( i ) = 3 then
29319: LD_VAR 0 3
29323: PPUSH
29324: CALL_OW 257
29328: PUSH
29329: LD_INT 3
29331: EQUAL
29332: IFFALSE 29336
// continue ;
29334: GO 29302
// p := Insert ( p , p + 1 , sort [ i ] ) ;
29336: LD_ADDR_VAR 0 11
29340: PUSH
29341: LD_VAR 0 11
29345: PPUSH
29346: LD_VAR 0 11
29350: PUSH
29351: LD_INT 1
29353: PLUS
29354: PPUSH
29355: LD_VAR 0 9
29359: PUSH
29360: LD_VAR 0 3
29364: ARRAY
29365: PPUSH
29366: CALL_OW 2
29370: ST_TO_ADDR
// tmp := tmp diff sort [ i ] ;
29371: LD_ADDR_VAR 0 4
29375: PUSH
29376: LD_VAR 0 4
29380: PUSH
29381: LD_VAR 0 9
29385: PUSH
29386: LD_VAR 0 3
29390: ARRAY
29391: DIFF
29392: ST_TO_ADDR
// end ;
29393: GO 29302
29395: POP
29396: POP
// if p then
29397: LD_VAR 0 11
29401: IFFALSE 29426
// result := Replace ( result , 3 , p ) ;
29403: LD_ADDR_VAR 0 2
29407: PUSH
29408: LD_VAR 0 2
29412: PPUSH
29413: LD_INT 3
29415: PPUSH
29416: LD_VAR 0 11
29420: PPUSH
29421: CALL_OW 1
29425: ST_TO_ADDR
// end ; tmp := tmp diff eng ;
29426: LD_ADDR_VAR 0 4
29430: PUSH
29431: LD_VAR 0 4
29435: PUSH
29436: LD_VAR 0 6
29440: DIFF
29441: ST_TO_ADDR
// if tmp and eng < 4 then
29442: LD_VAR 0 4
29446: PUSH
29447: LD_VAR 0 6
29451: PUSH
29452: LD_INT 4
29454: LESS
29455: AND
29456: IFFALSE 29646
// begin sort := SortBySkill ( tmp diff ( mech union eng ) , 2 ) ;
29458: LD_ADDR_VAR 0 9
29462: PUSH
29463: LD_VAR 0 4
29467: PUSH
29468: LD_VAR 0 7
29472: PUSH
29473: LD_VAR 0 6
29477: UNION
29478: DIFF
29479: PPUSH
29480: LD_INT 2
29482: PPUSH
29483: CALL 87221 0 2
29487: ST_TO_ADDR
// p := [ ] ;
29488: LD_ADDR_VAR 0 11
29492: PUSH
29493: EMPTY
29494: ST_TO_ADDR
// if sort then
29495: LD_VAR 0 9
29499: IFFALSE 29615
// for i = 1 to 4 - eng do
29501: LD_ADDR_VAR 0 3
29505: PUSH
29506: DOUBLE
29507: LD_INT 1
29509: DEC
29510: ST_TO_ADDR
29511: LD_INT 4
29513: PUSH
29514: LD_VAR 0 6
29518: MINUS
29519: PUSH
29520: FOR_TO
29521: IFFALSE 29613
// begin if i = sort then
29523: LD_VAR 0 3
29527: PUSH
29528: LD_VAR 0 9
29532: EQUAL
29533: IFFALSE 29537
// break ;
29535: GO 29613
// if GetClass ( i ) = 2 then
29537: LD_VAR 0 3
29541: PPUSH
29542: CALL_OW 257
29546: PUSH
29547: LD_INT 2
29549: EQUAL
29550: IFFALSE 29554
// continue ;
29552: GO 29520
// p := Insert ( p , p + 1 , sort [ i ] ) ;
29554: LD_ADDR_VAR 0 11
29558: PUSH
29559: LD_VAR 0 11
29563: PPUSH
29564: LD_VAR 0 11
29568: PUSH
29569: LD_INT 1
29571: PLUS
29572: PPUSH
29573: LD_VAR 0 9
29577: PUSH
29578: LD_VAR 0 3
29582: ARRAY
29583: PPUSH
29584: CALL_OW 2
29588: ST_TO_ADDR
// tmp := tmp diff sort [ i ] ;
29589: LD_ADDR_VAR 0 4
29593: PUSH
29594: LD_VAR 0 4
29598: PUSH
29599: LD_VAR 0 9
29603: PUSH
29604: LD_VAR 0 3
29608: ARRAY
29609: DIFF
29610: ST_TO_ADDR
// end ;
29611: GO 29520
29613: POP
29614: POP
// if p then
29615: LD_VAR 0 11
29619: IFFALSE 29644
// result := Replace ( result , 2 , p ) ;
29621: LD_ADDR_VAR 0 2
29625: PUSH
29626: LD_VAR 0 2
29630: PPUSH
29631: LD_INT 2
29633: PPUSH
29634: LD_VAR 0 11
29638: PPUSH
29639: CALL_OW 1
29643: ST_TO_ADDR
// end else
29644: GO 29690
// for i = eng downto 5 do
29646: LD_ADDR_VAR 0 3
29650: PUSH
29651: DOUBLE
29652: LD_VAR 0 6
29656: INC
29657: ST_TO_ADDR
29658: LD_INT 5
29660: PUSH
29661: FOR_DOWNTO
29662: IFFALSE 29688
// tmp := tmp union eng [ i ] ;
29664: LD_ADDR_VAR 0 4
29668: PUSH
29669: LD_VAR 0 4
29673: PUSH
29674: LD_VAR 0 6
29678: PUSH
29679: LD_VAR 0 3
29683: ARRAY
29684: UNION
29685: ST_TO_ADDR
29686: GO 29661
29688: POP
29689: POP
// result := Replace ( result , 1 , tmp diff sol ) ;
29690: LD_ADDR_VAR 0 2
29694: PUSH
29695: LD_VAR 0 2
29699: PPUSH
29700: LD_INT 1
29702: PPUSH
29703: LD_VAR 0 4
29707: PUSH
29708: LD_VAR 0 5
29712: DIFF
29713: PPUSH
29714: CALL_OW 1
29718: ST_TO_ADDR
// exit ;
29719: GO 29721
// end ; end ;
29721: LD_VAR 0 2
29725: RET
// export function MC_CheckBuildings ( ) ; var i , tmp ; begin
29726: LD_INT 0
29728: PPUSH
29729: PPUSH
29730: PPUSH
// if not mc_bases then
29731: LD_EXP 95
29735: NOT
29736: IFFALSE 29740
// exit ;
29738: GO 29882
// for i = 1 to mc_bases do
29740: LD_ADDR_VAR 0 2
29744: PUSH
29745: DOUBLE
29746: LD_INT 1
29748: DEC
29749: ST_TO_ADDR
29750: LD_EXP 95
29754: PUSH
29755: FOR_TO
29756: IFFALSE 29873
// begin tmp := UnitFilter ( mc_bases [ i ] , [ [ f_type , unit_building ] , [ f_not , [ f_or , [ f_btype , b_oil_mine ] , [ f_btype , b_siberite_mine ] ] ] , [ f_not , [ f_lives , 1000 ] ] ] ) ;
29758: LD_ADDR_VAR 0 3
29762: PUSH
29763: LD_EXP 95
29767: PUSH
29768: LD_VAR 0 2
29772: ARRAY
29773: PPUSH
29774: LD_INT 21
29776: PUSH
29777: LD_INT 3
29779: PUSH
29780: EMPTY
29781: LIST
29782: LIST
29783: PUSH
29784: LD_INT 3
29786: PUSH
29787: LD_INT 2
29789: PUSH
29790: LD_INT 30
29792: PUSH
29793: LD_INT 29
29795: PUSH
29796: EMPTY
29797: LIST
29798: LIST
29799: PUSH
29800: LD_INT 30
29802: PUSH
29803: LD_INT 30
29805: PUSH
29806: EMPTY
29807: LIST
29808: LIST
29809: PUSH
29810: EMPTY
29811: LIST
29812: LIST
29813: LIST
29814: PUSH
29815: EMPTY
29816: LIST
29817: LIST
29818: PUSH
29819: LD_INT 3
29821: PUSH
29822: LD_INT 24
29824: PUSH
29825: LD_INT 1000
29827: PUSH
29828: EMPTY
29829: LIST
29830: LIST
29831: PUSH
29832: EMPTY
29833: LIST
29834: LIST
29835: PUSH
29836: EMPTY
29837: LIST
29838: LIST
29839: LIST
29840: PPUSH
29841: CALL_OW 72
29845: ST_TO_ADDR
// mc_building_need_repair := Replace ( mc_building_need_repair , i , tmp ) ;
29846: LD_ADDR_EXP 96
29850: PUSH
29851: LD_EXP 96
29855: PPUSH
29856: LD_VAR 0 2
29860: PPUSH
29861: LD_VAR 0 3
29865: PPUSH
29866: CALL_OW 1
29870: ST_TO_ADDR
// end ;
29871: GO 29755
29873: POP
29874: POP
// RaiseSailEvent ( 101 ) ;
29875: LD_INT 101
29877: PPUSH
29878: CALL_OW 427
// end ;
29882: LD_VAR 0 1
29886: RET
// export function MC_CheckPeopleLife ( ) ; var i , j , k , tmp , need_heal_1 , need_heal_2 ; begin
29887: LD_INT 0
29889: PPUSH
29890: PPUSH
29891: PPUSH
29892: PPUSH
29893: PPUSH
29894: PPUSH
29895: PPUSH
// if not mc_bases then
29896: LD_EXP 95
29900: NOT
29901: IFFALSE 29905
// exit ;
29903: GO 30467
// for i = 1 to mc_bases do
29905: LD_ADDR_VAR 0 2
29909: PUSH
29910: DOUBLE
29911: LD_INT 1
29913: DEC
29914: ST_TO_ADDR
29915: LD_EXP 95
29919: PUSH
29920: FOR_TO
29921: IFFALSE 30458
// begin tmp := UnitFilter ( mc_bases [ i ] union mc_ape [ i ] , [ [ f_type , unit_human ] , [ f_and , [ f_not , [ f_inside ] ] , [ f_not , [ f_lives , 1000 ] ] ] ] ) ;
29923: LD_ADDR_VAR 0 5
29927: PUSH
29928: LD_EXP 95
29932: PUSH
29933: LD_VAR 0 2
29937: ARRAY
29938: PUSH
29939: LD_EXP 124
29943: PUSH
29944: LD_VAR 0 2
29948: ARRAY
29949: UNION
29950: PPUSH
29951: LD_INT 21
29953: PUSH
29954: LD_INT 1
29956: PUSH
29957: EMPTY
29958: LIST
29959: LIST
29960: PUSH
29961: LD_INT 1
29963: PUSH
29964: LD_INT 3
29966: PUSH
29967: LD_INT 54
29969: PUSH
29970: EMPTY
29971: LIST
29972: PUSH
29973: EMPTY
29974: LIST
29975: LIST
29976: PUSH
29977: LD_INT 3
29979: PUSH
29980: LD_INT 24
29982: PUSH
29983: LD_INT 1000
29985: PUSH
29986: EMPTY
29987: LIST
29988: LIST
29989: PUSH
29990: EMPTY
29991: LIST
29992: LIST
29993: PUSH
29994: EMPTY
29995: LIST
29996: LIST
29997: LIST
29998: PUSH
29999: EMPTY
30000: LIST
30001: LIST
30002: PPUSH
30003: CALL_OW 72
30007: ST_TO_ADDR
// need_heal_1 := UnitFilter ( mc_bases [ i ] , [ [ f_type , unit_human ] , [ f_and , [ f_not , [ f_inside ] ] , [ f_not , [ f_lives , 250 ] ] ] ] ) ;
30008: LD_ADDR_VAR 0 6
30012: PUSH
30013: LD_EXP 95
30017: PUSH
30018: LD_VAR 0 2
30022: ARRAY
30023: PPUSH
30024: LD_INT 21
30026: PUSH
30027: LD_INT 1
30029: PUSH
30030: EMPTY
30031: LIST
30032: LIST
30033: PUSH
30034: LD_INT 1
30036: PUSH
30037: LD_INT 3
30039: PUSH
30040: LD_INT 54
30042: PUSH
30043: EMPTY
30044: LIST
30045: PUSH
30046: EMPTY
30047: LIST
30048: LIST
30049: PUSH
30050: LD_INT 3
30052: PUSH
30053: LD_INT 24
30055: PUSH
30056: LD_INT 250
30058: PUSH
30059: EMPTY
30060: LIST
30061: LIST
30062: PUSH
30063: EMPTY
30064: LIST
30065: LIST
30066: PUSH
30067: EMPTY
30068: LIST
30069: LIST
30070: LIST
30071: PUSH
30072: EMPTY
30073: LIST
30074: LIST
30075: PPUSH
30076: CALL_OW 72
30080: ST_TO_ADDR
// need_heal_2 := tmp diff need_heal_1 ;
30081: LD_ADDR_VAR 0 7
30085: PUSH
30086: LD_VAR 0 5
30090: PUSH
30091: LD_VAR 0 6
30095: DIFF
30096: ST_TO_ADDR
// if not need_heal_1 then
30097: LD_VAR 0 6
30101: NOT
30102: IFFALSE 30135
// mc_need_heal := ReplaceIn ( mc_need_heal , [ i , 1 ] , [ ] ) else
30104: LD_ADDR_EXP 98
30108: PUSH
30109: LD_EXP 98
30113: PPUSH
30114: LD_VAR 0 2
30118: PUSH
30119: LD_INT 1
30121: PUSH
30122: EMPTY
30123: LIST
30124: LIST
30125: PPUSH
30126: EMPTY
30127: PPUSH
30128: CALL 57017 0 3
30132: ST_TO_ADDR
30133: GO 30205
// mc_need_heal := ReplaceIn ( mc_need_heal , [ i , 1 ] , UnitFilter ( mc_need_heal [ i ] [ 1 ] , [ f_not , [ f_lives , 1000 ] ] ) union need_heal_1 ) ;
30135: LD_ADDR_EXP 98
30139: PUSH
30140: LD_EXP 98
30144: PPUSH
30145: LD_VAR 0 2
30149: PUSH
30150: LD_INT 1
30152: PUSH
30153: EMPTY
30154: LIST
30155: LIST
30156: PPUSH
30157: LD_EXP 98
30161: PUSH
30162: LD_VAR 0 2
30166: ARRAY
30167: PUSH
30168: LD_INT 1
30170: ARRAY
30171: PPUSH
30172: LD_INT 3
30174: PUSH
30175: LD_INT 24
30177: PUSH
30178: LD_INT 1000
30180: PUSH
30181: EMPTY
30182: LIST
30183: LIST
30184: PUSH
30185: EMPTY
30186: LIST
30187: LIST
30188: PPUSH
30189: CALL_OW 72
30193: PUSH
30194: LD_VAR 0 6
30198: UNION
30199: PPUSH
30200: CALL 57017 0 3
30204: ST_TO_ADDR
// if not need_heal_2 then
30205: LD_VAR 0 7
30209: NOT
30210: IFFALSE 30243
// mc_need_heal := ReplaceIn ( mc_need_heal , [ i , 2 ] , [ ] ) else
30212: LD_ADDR_EXP 98
30216: PUSH
30217: LD_EXP 98
30221: PPUSH
30222: LD_VAR 0 2
30226: PUSH
30227: LD_INT 2
30229: PUSH
30230: EMPTY
30231: LIST
30232: LIST
30233: PPUSH
30234: EMPTY
30235: PPUSH
30236: CALL 57017 0 3
30240: ST_TO_ADDR
30241: GO 30275
// mc_need_heal := ReplaceIn ( mc_need_heal , [ i , 2 ] , need_heal_2 ) ;
30243: LD_ADDR_EXP 98
30247: PUSH
30248: LD_EXP 98
30252: PPUSH
30253: LD_VAR 0 2
30257: PUSH
30258: LD_INT 2
30260: PUSH
30261: EMPTY
30262: LIST
30263: LIST
30264: PPUSH
30265: LD_VAR 0 7
30269: PPUSH
30270: CALL 57017 0 3
30274: ST_TO_ADDR
// if need_heal_2 then
30275: LD_VAR 0 7
30279: IFFALSE 30440
// for j in need_heal_2 do
30281: LD_ADDR_VAR 0 3
30285: PUSH
30286: LD_VAR 0 7
30290: PUSH
30291: FOR_IN
30292: IFFALSE 30438
// begin tmp := UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_lab ] , [ f_btype , b_lab_half ] , [ f_btype , b_lab_full ] , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) ;
30294: LD_ADDR_VAR 0 5
30298: PUSH
30299: LD_EXP 95
30303: PUSH
30304: LD_VAR 0 2
30308: ARRAY
30309: PPUSH
30310: LD_INT 2
30312: PUSH
30313: LD_INT 30
30315: PUSH
30316: LD_INT 6
30318: PUSH
30319: EMPTY
30320: LIST
30321: LIST
30322: PUSH
30323: LD_INT 30
30325: PUSH
30326: LD_INT 7
30328: PUSH
30329: EMPTY
30330: LIST
30331: LIST
30332: PUSH
30333: LD_INT 30
30335: PUSH
30336: LD_INT 8
30338: PUSH
30339: EMPTY
30340: LIST
30341: LIST
30342: PUSH
30343: LD_INT 30
30345: PUSH
30346: LD_INT 0
30348: PUSH
30349: EMPTY
30350: LIST
30351: LIST
30352: PUSH
30353: LD_INT 30
30355: PUSH
30356: LD_INT 1
30358: PUSH
30359: EMPTY
30360: LIST
30361: LIST
30362: PUSH
30363: EMPTY
30364: LIST
30365: LIST
30366: LIST
30367: LIST
30368: LIST
30369: LIST
30370: PPUSH
30371: CALL_OW 72
30375: ST_TO_ADDR
// if tmp then
30376: LD_VAR 0 5
30380: IFFALSE 30436
// begin k := NearestUnitToUnit ( tmp , j ) ;
30382: LD_ADDR_VAR 0 4
30386: PUSH
30387: LD_VAR 0 5
30391: PPUSH
30392: LD_VAR 0 3
30396: PPUSH
30397: CALL_OW 74
30401: ST_TO_ADDR
// if GetDistUnits ( j , k ) > 5 then
30402: LD_VAR 0 3
30406: PPUSH
30407: LD_VAR 0 4
30411: PPUSH
30412: CALL_OW 296
30416: PUSH
30417: LD_INT 5
30419: GREATER
30420: IFFALSE 30436
// ComMoveToNearbyEntrance ( j , k ) ;
30422: LD_VAR 0 3
30426: PPUSH
30427: LD_VAR 0 4
30431: PPUSH
30432: CALL 89579 0 2
// end ; end ;
30436: GO 30291
30438: POP
30439: POP
// if not need_heal_1 and not need_heal_2 then
30440: LD_VAR 0 6
30444: NOT
30445: PUSH
30446: LD_VAR 0 7
30450: NOT
30451: AND
30452: IFFALSE 30456
// continue ;
30454: GO 29920
// end ;
30456: GO 29920
30458: POP
30459: POP
// RaiseSailEvent ( 102 ) ;
30460: LD_INT 102
30462: PPUSH
30463: CALL_OW 427
// end ;
30467: LD_VAR 0 1
30471: RET
// export function MC_RepairBuildings ( ) ; var i , j , un , tmp , cranes , to_repair_tmp , to_repair ; begin
30472: LD_INT 0
30474: PPUSH
30475: PPUSH
30476: PPUSH
30477: PPUSH
30478: PPUSH
30479: PPUSH
30480: PPUSH
30481: PPUSH
// if not mc_bases then
30482: LD_EXP 95
30486: NOT
30487: IFFALSE 30491
// exit ;
30489: GO 31374
// for i = 1 to mc_bases do
30491: LD_ADDR_VAR 0 2
30495: PUSH
30496: DOUBLE
30497: LD_INT 1
30499: DEC
30500: ST_TO_ADDR
30501: LD_EXP 95
30505: PUSH
30506: FOR_TO
30507: IFFALSE 31372
// begin if not mc_building_need_repair [ i ] then
30509: LD_EXP 96
30513: PUSH
30514: LD_VAR 0 2
30518: ARRAY
30519: NOT
30520: IFFALSE 30707
// begin cranes := UnitFilter ( mc_vehicles [ i ] , [ [ f_not , [ f_lives , 1000 ] ] , [ f_or , [ f_weapon , us_crane ] , [ f_weapon , ru_crane ] , [ f_weapon , ar_crane ] ] ] ) ;
30522: LD_ADDR_VAR 0 6
30526: PUSH
30527: LD_EXP 114
30531: PUSH
30532: LD_VAR 0 2
30536: ARRAY
30537: PPUSH
30538: LD_INT 3
30540: PUSH
30541: LD_INT 24
30543: PUSH
30544: LD_INT 1000
30546: PUSH
30547: EMPTY
30548: LIST
30549: LIST
30550: PUSH
30551: EMPTY
30552: LIST
30553: LIST
30554: PUSH
30555: LD_INT 2
30557: PUSH
30558: LD_INT 34
30560: PUSH
30561: LD_INT 13
30563: PUSH
30564: EMPTY
30565: LIST
30566: LIST
30567: PUSH
30568: LD_INT 34
30570: PUSH
30571: LD_INT 52
30573: PUSH
30574: EMPTY
30575: LIST
30576: LIST
30577: PUSH
30578: LD_INT 34
30580: PUSH
30581: LD_EXP 80
30585: PUSH
30586: EMPTY
30587: LIST
30588: LIST
30589: PUSH
30590: EMPTY
30591: LIST
30592: LIST
30593: LIST
30594: LIST
30595: PUSH
30596: EMPTY
30597: LIST
30598: LIST
30599: PPUSH
30600: CALL_OW 72
30604: ST_TO_ADDR
// if cranes then
30605: LD_VAR 0 6
30609: IFFALSE 30671
// for j in cranes do
30611: LD_ADDR_VAR 0 3
30615: PUSH
30616: LD_VAR 0 6
30620: PUSH
30621: FOR_IN
30622: IFFALSE 30669
// if not IsInArea ( j , mc_parking [ i ] ) then
30624: LD_VAR 0 3
30628: PPUSH
30629: LD_EXP 119
30633: PUSH
30634: LD_VAR 0 2
30638: ARRAY
30639: PPUSH
30640: CALL_OW 308
30644: NOT
30645: IFFALSE 30667
// ComMoveToArea ( j , mc_parking [ i ] ) ;
30647: LD_VAR 0 3
30651: PPUSH
30652: LD_EXP 119
30656: PUSH
30657: LD_VAR 0 2
30661: ARRAY
30662: PPUSH
30663: CALL_OW 113
30667: GO 30621
30669: POP
30670: POP
// mc_building_repairs := Replace ( mc_building_repairs , i , [ ] ) ;
30671: LD_ADDR_EXP 97
30675: PUSH
30676: LD_EXP 97
30680: PPUSH
30681: LD_VAR 0 2
30685: PPUSH
30686: EMPTY
30687: PPUSH
30688: CALL_OW 1
30692: ST_TO_ADDR
// MC_Reset ( i , 101 ) ;
30693: LD_VAR 0 2
30697: PPUSH
30698: LD_INT 101
30700: PPUSH
30701: CALL 25559 0 2
// continue ;
30705: GO 30506
// end ; mc_builders := Replace ( mc_builders , i , [ ] ) ;
30707: LD_ADDR_EXP 101
30711: PUSH
30712: LD_EXP 101
30716: PPUSH
30717: LD_VAR 0 2
30721: PPUSH
30722: EMPTY
30723: PPUSH
30724: CALL_OW 1
30728: ST_TO_ADDR
// MC_Reset ( i , 103 ) ;
30729: LD_VAR 0 2
30733: PPUSH
30734: LD_INT 103
30736: PPUSH
30737: CALL 25559 0 2
// tmp := UnitFilter ( mc_bases [ i ] union mc_ape [ i ] , [ [ f_or , [ f_class , 2 ] , [ f_class , 16 ] ] ] ) ;
30741: LD_ADDR_VAR 0 5
30745: PUSH
30746: LD_EXP 95
30750: PUSH
30751: LD_VAR 0 2
30755: ARRAY
30756: PUSH
30757: LD_EXP 124
30761: PUSH
30762: LD_VAR 0 2
30766: ARRAY
30767: UNION
30768: PPUSH
30769: LD_INT 2
30771: PUSH
30772: LD_INT 25
30774: PUSH
30775: LD_INT 2
30777: PUSH
30778: EMPTY
30779: LIST
30780: LIST
30781: PUSH
30782: LD_INT 25
30784: PUSH
30785: LD_INT 16
30787: PUSH
30788: EMPTY
30789: LIST
30790: LIST
30791: PUSH
30792: EMPTY
30793: LIST
30794: LIST
30795: LIST
30796: PUSH
30797: EMPTY
30798: LIST
30799: PPUSH
30800: CALL_OW 72
30804: ST_TO_ADDR
// if mc_need_heal [ i ] then
30805: LD_EXP 98
30809: PUSH
30810: LD_VAR 0 2
30814: ARRAY
30815: IFFALSE 30859
// tmp := tmp diff ( mc_need_heal [ i ] [ 1 ] union mc_need_heal [ i ] [ 2 ] ) ;
30817: LD_ADDR_VAR 0 5
30821: PUSH
30822: LD_VAR 0 5
30826: PUSH
30827: LD_EXP 98
30831: PUSH
30832: LD_VAR 0 2
30836: ARRAY
30837: PUSH
30838: LD_INT 1
30840: ARRAY
30841: PUSH
30842: LD_EXP 98
30846: PUSH
30847: LD_VAR 0 2
30851: ARRAY
30852: PUSH
30853: LD_INT 2
30855: ARRAY
30856: UNION
30857: DIFF
30858: ST_TO_ADDR
// cranes := UnitFilter ( mc_vehicles [ i ] , [ f_or , [ f_weapon , us_crane ] , [ f_weapon , ru_crane ] , [ f_weapon , ar_crane ] ] ) ;
30859: LD_ADDR_VAR 0 6
30863: PUSH
30864: LD_EXP 114
30868: PUSH
30869: LD_VAR 0 2
30873: ARRAY
30874: PPUSH
30875: LD_INT 2
30877: PUSH
30878: LD_INT 34
30880: PUSH
30881: LD_INT 13
30883: PUSH
30884: EMPTY
30885: LIST
30886: LIST
30887: PUSH
30888: LD_INT 34
30890: PUSH
30891: LD_INT 52
30893: PUSH
30894: EMPTY
30895: LIST
30896: LIST
30897: PUSH
30898: LD_INT 34
30900: PUSH
30901: LD_EXP 80
30905: PUSH
30906: EMPTY
30907: LIST
30908: LIST
30909: PUSH
30910: EMPTY
30911: LIST
30912: LIST
30913: LIST
30914: LIST
30915: PPUSH
30916: CALL_OW 72
30920: ST_TO_ADDR
// if cranes then
30921: LD_VAR 0 6
30925: IFFALSE 31061
// begin for j in cranes do
30927: LD_ADDR_VAR 0 3
30931: PUSH
30932: LD_VAR 0 6
30936: PUSH
30937: FOR_IN
30938: IFFALSE 31059
// begin if GetLives ( j ) = 1000 and not HasTask ( j ) then
30940: LD_VAR 0 3
30944: PPUSH
30945: CALL_OW 256
30949: PUSH
30950: LD_INT 1000
30952: EQUAL
30953: PUSH
30954: LD_VAR 0 3
30958: PPUSH
30959: CALL_OW 314
30963: NOT
30964: AND
30965: IFFALSE 30999
// ComRepairBuilding ( j , NearestUnitToUnit ( mc_building_need_repair [ i ] , j ) ) else
30967: LD_VAR 0 3
30971: PPUSH
30972: LD_EXP 96
30976: PUSH
30977: LD_VAR 0 2
30981: ARRAY
30982: PPUSH
30983: LD_VAR 0 3
30987: PPUSH
30988: CALL_OW 74
30992: PPUSH
30993: CALL_OW 130
30997: GO 31057
// if GetLives ( j ) < 500 and not IsInArea ( j , mc_parking [ i ] ) then
30999: LD_VAR 0 3
31003: PPUSH
31004: CALL_OW 256
31008: PUSH
31009: LD_INT 500
31011: LESS
31012: PUSH
31013: LD_VAR 0 3
31017: PPUSH
31018: LD_EXP 119
31022: PUSH
31023: LD_VAR 0 2
31027: ARRAY
31028: PPUSH
31029: CALL_OW 308
31033: NOT
31034: AND
31035: IFFALSE 31057
// ComMoveToArea ( j , mc_parking [ i ] ) ;
31037: LD_VAR 0 3
31041: PPUSH
31042: LD_EXP 119
31046: PUSH
31047: LD_VAR 0 2
31051: ARRAY
31052: PPUSH
31053: CALL_OW 113
// end ;
31057: GO 30937
31059: POP
31060: POP
// end ; if tmp > 3 then
31061: LD_VAR 0 5
31065: PUSH
31066: LD_INT 3
31068: GREATER
31069: IFFALSE 31089
// tmp := ShrinkArray ( tmp , 4 ) ;
31071: LD_ADDR_VAR 0 5
31075: PUSH
31076: LD_VAR 0 5
31080: PPUSH
31081: LD_INT 4
31083: PPUSH
31084: CALL 89027 0 2
31088: ST_TO_ADDR
// if not tmp then
31089: LD_VAR 0 5
31093: NOT
31094: IFFALSE 31098
// continue ;
31096: GO 30506
// for j in tmp do
31098: LD_ADDR_VAR 0 3
31102: PUSH
31103: LD_VAR 0 5
31107: PUSH
31108: FOR_IN
31109: IFFALSE 31368
// begin if IsInUnit ( j ) then
31111: LD_VAR 0 3
31115: PPUSH
31116: CALL_OW 310
31120: IFFALSE 31131
// ComExitBuilding ( j ) ;
31122: LD_VAR 0 3
31126: PPUSH
31127: CALL_OW 122
// if not j in mc_building_repairs [ i ] then
31131: LD_VAR 0 3
31135: PUSH
31136: LD_EXP 97
31140: PUSH
31141: LD_VAR 0 2
31145: ARRAY
31146: IN
31147: NOT
31148: IFFALSE 31206
// begin SetTag ( j , 101 ) ;
31150: LD_VAR 0 3
31154: PPUSH
31155: LD_INT 101
31157: PPUSH
31158: CALL_OW 109
// mc_building_repairs := ReplaceIn ( mc_building_repairs , [ i , mc_building_repairs [ i ] + 1 ] , j ) ;
31162: LD_ADDR_EXP 97
31166: PUSH
31167: LD_EXP 97
31171: PPUSH
31172: LD_VAR 0 2
31176: PUSH
31177: LD_EXP 97
31181: PUSH
31182: LD_VAR 0 2
31186: ARRAY
31187: PUSH
31188: LD_INT 1
31190: PLUS
31191: PUSH
31192: EMPTY
31193: LIST
31194: LIST
31195: PPUSH
31196: LD_VAR 0 3
31200: PPUSH
31201: CALL 57017 0 3
31205: ST_TO_ADDR
// end ; wait ( 1 ) ;
31206: LD_INT 1
31208: PPUSH
31209: CALL_OW 67
// to_repair_tmp := mc_building_need_repair [ i ] ;
31213: LD_ADDR_VAR 0 7
31217: PUSH
31218: LD_EXP 96
31222: PUSH
31223: LD_VAR 0 2
31227: ARRAY
31228: ST_TO_ADDR
// if mc_scan [ i ] then
31229: LD_EXP 118
31233: PUSH
31234: LD_VAR 0 2
31238: ARRAY
31239: IFFALSE 31301
// to_repair_tmp := UnitFilter ( mc_building_need_repair [ i ] , [ f_not , [ f_btype , b_bunker ] , [ f_btype , b_turret ] , [ f_btype , b_breastwork ] ] ) ;
31241: LD_ADDR_VAR 0 7
31245: PUSH
31246: LD_EXP 96
31250: PUSH
31251: LD_VAR 0 2
31255: ARRAY
31256: PPUSH
31257: LD_INT 3
31259: PUSH
31260: LD_INT 30
31262: PUSH
31263: LD_INT 32
31265: PUSH
31266: EMPTY
31267: LIST
31268: LIST
31269: PUSH
31270: LD_INT 30
31272: PUSH
31273: LD_INT 33
31275: PUSH
31276: EMPTY
31277: LIST
31278: LIST
31279: PUSH
31280: LD_INT 30
31282: PUSH
31283: LD_INT 31
31285: PUSH
31286: EMPTY
31287: LIST
31288: LIST
31289: PUSH
31290: EMPTY
31291: LIST
31292: LIST
31293: LIST
31294: LIST
31295: PPUSH
31296: CALL_OW 72
31300: ST_TO_ADDR
// if not to_repair_tmp then
31301: LD_VAR 0 7
31305: NOT
31306: IFFALSE 31310
// continue ;
31308: GO 31108
// to_repair := NearestUnitToUnit ( to_repair_tmp , j ) ;
31310: LD_ADDR_VAR 0 8
31314: PUSH
31315: LD_VAR 0 7
31319: PPUSH
31320: LD_VAR 0 3
31324: PPUSH
31325: CALL_OW 74
31329: ST_TO_ADDR
// if DangerAtRange ( to_repair , 16 ) [ 4 ] < 10 then
31330: LD_VAR 0 8
31334: PPUSH
31335: LD_INT 16
31337: PPUSH
31338: CALL 59616 0 2
31342: PUSH
31343: LD_INT 4
31345: ARRAY
31346: PUSH
31347: LD_INT 10
31349: LESS
31350: IFFALSE 31366
// ComRepairBuilding ( j , to_repair ) ;
31352: LD_VAR 0 3
31356: PPUSH
31357: LD_VAR 0 8
31361: PPUSH
31362: CALL_OW 130
// end ;
31366: GO 31108
31368: POP
31369: POP
// end ;
31370: GO 30506
31372: POP
31373: POP
// end ;
31374: LD_VAR 0 1
31378: RET
// export function MC_Heal ; var i , j , tmp ; begin
31379: LD_INT 0
31381: PPUSH
31382: PPUSH
31383: PPUSH
31384: PPUSH
// if not mc_bases then
31385: LD_EXP 95
31389: NOT
31390: IFFALSE 31394
// exit ;
31392: GO 31796
// for i = 1 to mc_bases do
31394: LD_ADDR_VAR 0 2
31398: PUSH
31399: DOUBLE
31400: LD_INT 1
31402: DEC
31403: ST_TO_ADDR
31404: LD_EXP 95
31408: PUSH
31409: FOR_TO
31410: IFFALSE 31794
// begin if not mc_need_heal [ i ] [ 1 ] and not mc_need_heal [ i ] [ 2 ] then
31412: LD_EXP 98
31416: PUSH
31417: LD_VAR 0 2
31421: ARRAY
31422: PUSH
31423: LD_INT 1
31425: ARRAY
31426: NOT
31427: PUSH
31428: LD_EXP 98
31432: PUSH
31433: LD_VAR 0 2
31437: ARRAY
31438: PUSH
31439: LD_INT 2
31441: ARRAY
31442: NOT
31443: AND
31444: IFFALSE 31482
// begin mc_healers := Replace ( mc_healers , i , [ ] ) ;
31446: LD_ADDR_EXP 99
31450: PUSH
31451: LD_EXP 99
31455: PPUSH
31456: LD_VAR 0 2
31460: PPUSH
31461: EMPTY
31462: PPUSH
31463: CALL_OW 1
31467: ST_TO_ADDR
// MC_Reset ( i , 102 ) ;
31468: LD_VAR 0 2
31472: PPUSH
31473: LD_INT 102
31475: PPUSH
31476: CALL 25559 0 2
// continue ;
31480: GO 31409
// end ; tmp := UnitFilter ( mc_bases [ i ] , [ f_class , 4 ] ) ;
31482: LD_ADDR_VAR 0 4
31486: PUSH
31487: LD_EXP 95
31491: PUSH
31492: LD_VAR 0 2
31496: ARRAY
31497: PPUSH
31498: LD_INT 25
31500: PUSH
31501: LD_INT 4
31503: PUSH
31504: EMPTY
31505: LIST
31506: LIST
31507: PPUSH
31508: CALL_OW 72
31512: ST_TO_ADDR
// if not tmp then
31513: LD_VAR 0 4
31517: NOT
31518: IFFALSE 31522
// continue ;
31520: GO 31409
// if mc_taming [ i ] then
31522: LD_EXP 126
31526: PUSH
31527: LD_VAR 0 2
31531: ARRAY
31532: IFFALSE 31556
// mc_taming := Replace ( mc_taming , i , [ ] ) ;
31534: LD_ADDR_EXP 126
31538: PUSH
31539: LD_EXP 126
31543: PPUSH
31544: LD_VAR 0 2
31548: PPUSH
31549: EMPTY
31550: PPUSH
31551: CALL_OW 1
31555: ST_TO_ADDR
// for j in tmp do
31556: LD_ADDR_VAR 0 3
31560: PUSH
31561: LD_VAR 0 4
31565: PUSH
31566: FOR_IN
31567: IFFALSE 31790
// begin if IsInUnit ( j ) then
31569: LD_VAR 0 3
31573: PPUSH
31574: CALL_OW 310
31578: IFFALSE 31589
// ComExitBuilding ( j ) ;
31580: LD_VAR 0 3
31584: PPUSH
31585: CALL_OW 122
// if not j in mc_healers [ i ] then
31589: LD_VAR 0 3
31593: PUSH
31594: LD_EXP 99
31598: PUSH
31599: LD_VAR 0 2
31603: ARRAY
31604: IN
31605: NOT
31606: IFFALSE 31652
// mc_healers := ReplaceIn ( mc_healers , [ i , mc_healers [ i ] + 1 ] , j ) ;
31608: LD_ADDR_EXP 99
31612: PUSH
31613: LD_EXP 99
31617: PPUSH
31618: LD_VAR 0 2
31622: PUSH
31623: LD_EXP 99
31627: PUSH
31628: LD_VAR 0 2
31632: ARRAY
31633: PUSH
31634: LD_INT 1
31636: PLUS
31637: PUSH
31638: EMPTY
31639: LIST
31640: LIST
31641: PPUSH
31642: LD_VAR 0 3
31646: PPUSH
31647: CALL 57017 0 3
31651: ST_TO_ADDR
// if GetTag ( j ) <> 102 then
31652: LD_VAR 0 3
31656: PPUSH
31657: CALL_OW 110
31661: PUSH
31662: LD_INT 102
31664: NONEQUAL
31665: IFFALSE 31679
// SetTag ( j , 102 ) ;
31667: LD_VAR 0 3
31671: PPUSH
31672: LD_INT 102
31674: PPUSH
31675: CALL_OW 109
// Wait ( 3 ) ;
31679: LD_INT 3
31681: PPUSH
31682: CALL_OW 67
// if mc_need_heal [ i ] [ 1 ] then
31686: LD_EXP 98
31690: PUSH
31691: LD_VAR 0 2
31695: ARRAY
31696: PUSH
31697: LD_INT 1
31699: ARRAY
31700: IFFALSE 31732
// ComHeal ( j , mc_need_heal [ i ] [ 1 ] [ 1 ] ) else
31702: LD_VAR 0 3
31706: PPUSH
31707: LD_EXP 98
31711: PUSH
31712: LD_VAR 0 2
31716: ARRAY
31717: PUSH
31718: LD_INT 1
31720: ARRAY
31721: PUSH
31722: LD_INT 1
31724: ARRAY
31725: PPUSH
31726: CALL_OW 128
31730: GO 31788
// if not HasTask ( j ) and mc_need_heal [ i ] [ 2 ] then
31732: LD_VAR 0 3
31736: PPUSH
31737: CALL_OW 314
31741: NOT
31742: PUSH
31743: LD_EXP 98
31747: PUSH
31748: LD_VAR 0 2
31752: ARRAY
31753: PUSH
31754: LD_INT 2
31756: ARRAY
31757: AND
31758: IFFALSE 31788
// ComHeal ( j , mc_need_heal [ i ] [ 2 ] [ 1 ] ) ;
31760: LD_VAR 0 3
31764: PPUSH
31765: LD_EXP 98
31769: PUSH
31770: LD_VAR 0 2
31774: ARRAY
31775: PUSH
31776: LD_INT 2
31778: ARRAY
31779: PUSH
31780: LD_INT 1
31782: ARRAY
31783: PPUSH
31784: CALL_OW 128
// end ;
31788: GO 31566
31790: POP
31791: POP
// end ;
31792: GO 31409
31794: POP
31795: POP
// end ;
31796: LD_VAR 0 1
31800: RET
// export function MC_Build ( ) ; var i , j , tmp , depot ; begin
31801: LD_INT 0
31803: PPUSH
31804: PPUSH
31805: PPUSH
31806: PPUSH
31807: PPUSH
// if not mc_bases then
31808: LD_EXP 95
31812: NOT
31813: IFFALSE 31817
// exit ;
31815: GO 32988
// for i = 1 to mc_bases do
31817: LD_ADDR_VAR 0 2
31821: PUSH
31822: DOUBLE
31823: LD_INT 1
31825: DEC
31826: ST_TO_ADDR
31827: LD_EXP 95
31831: PUSH
31832: FOR_TO
31833: IFFALSE 32986
// begin if mc_scan [ i ] then
31835: LD_EXP 118
31839: PUSH
31840: LD_VAR 0 2
31844: ARRAY
31845: IFFALSE 31849
// continue ;
31847: GO 31832
// if not mc_build_list [ i ] and not mc_construct_list [ i ] and mc_builders [ i ] then
31849: LD_EXP 100
31853: PUSH
31854: LD_VAR 0 2
31858: ARRAY
31859: NOT
31860: PUSH
31861: LD_EXP 102
31865: PUSH
31866: LD_VAR 0 2
31870: ARRAY
31871: NOT
31872: AND
31873: PUSH
31874: LD_EXP 101
31878: PUSH
31879: LD_VAR 0 2
31883: ARRAY
31884: AND
31885: IFFALSE 31923
// begin mc_builders := Replace ( mc_builders , i , [ ] ) ;
31887: LD_ADDR_EXP 101
31891: PUSH
31892: LD_EXP 101
31896: PPUSH
31897: LD_VAR 0 2
31901: PPUSH
31902: EMPTY
31903: PPUSH
31904: CALL_OW 1
31908: ST_TO_ADDR
// MC_Reset ( i , 103 ) ;
31909: LD_VAR 0 2
31913: PPUSH
31914: LD_INT 103
31916: PPUSH
31917: CALL 25559 0 2
// continue ;
31921: GO 31832
// end ; if mc_construct_list [ i ] then
31923: LD_EXP 102
31927: PUSH
31928: LD_VAR 0 2
31932: ARRAY
31933: IFFALSE 32153
// begin tmp := UnitFilter ( mc_bases [ i ] , [ f_class , 2 ] ) diff mc_building_repairs [ i ] ;
31935: LD_ADDR_VAR 0 4
31939: PUSH
31940: LD_EXP 95
31944: PUSH
31945: LD_VAR 0 2
31949: ARRAY
31950: PPUSH
31951: LD_INT 25
31953: PUSH
31954: LD_INT 2
31956: PUSH
31957: EMPTY
31958: LIST
31959: LIST
31960: PPUSH
31961: CALL_OW 72
31965: PUSH
31966: LD_EXP 97
31970: PUSH
31971: LD_VAR 0 2
31975: ARRAY
31976: DIFF
31977: ST_TO_ADDR
// if not tmp then
31978: LD_VAR 0 4
31982: NOT
31983: IFFALSE 31987
// continue ;
31985: GO 31832
// for j in tmp do
31987: LD_ADDR_VAR 0 3
31991: PUSH
31992: LD_VAR 0 4
31996: PUSH
31997: FOR_IN
31998: IFFALSE 32149
// begin if not mc_builders [ i ] then
32000: LD_EXP 101
32004: PUSH
32005: LD_VAR 0 2
32009: ARRAY
32010: NOT
32011: IFFALSE 32069
// begin SetTag ( j , 103 ) ;
32013: LD_VAR 0 3
32017: PPUSH
32018: LD_INT 103
32020: PPUSH
32021: CALL_OW 109
// mc_builders := ReplaceIn ( mc_builders , [ i , mc_builders [ i ] + 1 ] , j ) ;
32025: LD_ADDR_EXP 101
32029: PUSH
32030: LD_EXP 101
32034: PPUSH
32035: LD_VAR 0 2
32039: PUSH
32040: LD_EXP 101
32044: PUSH
32045: LD_VAR 0 2
32049: ARRAY
32050: PUSH
32051: LD_INT 1
32053: PLUS
32054: PUSH
32055: EMPTY
32056: LIST
32057: LIST
32058: PPUSH
32059: LD_VAR 0 3
32063: PPUSH
32064: CALL 57017 0 3
32068: ST_TO_ADDR
// end ; if IsInUnit ( j ) then
32069: LD_VAR 0 3
32073: PPUSH
32074: CALL_OW 310
32078: IFFALSE 32089
// ComExitBuilding ( j ) ;
32080: LD_VAR 0 3
32084: PPUSH
32085: CALL_OW 122
// wait ( 3 ) ;
32089: LD_INT 3
32091: PPUSH
32092: CALL_OW 67
// if not mc_construct_list [ i ] then
32096: LD_EXP 102
32100: PUSH
32101: LD_VAR 0 2
32105: ARRAY
32106: NOT
32107: IFFALSE 32111
// break ;
32109: GO 32149
// if not HasTask ( j ) then
32111: LD_VAR 0 3
32115: PPUSH
32116: CALL_OW 314
32120: NOT
32121: IFFALSE 32147
// ComComplete ( j , mc_construct_list [ i ] [ 1 ] ) ;
32123: LD_VAR 0 3
32127: PPUSH
32128: LD_EXP 102
32132: PUSH
32133: LD_VAR 0 2
32137: ARRAY
32138: PUSH
32139: LD_INT 1
32141: ARRAY
32142: PPUSH
32143: CALL 59880 0 2
// end ;
32147: GO 31997
32149: POP
32150: POP
// end else
32151: GO 32984
// if mc_build_list [ i ] then
32153: LD_EXP 100
32157: PUSH
32158: LD_VAR 0 2
32162: ARRAY
32163: IFFALSE 32984
// begin depot := UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) ;
32165: LD_ADDR_VAR 0 5
32169: PUSH
32170: LD_EXP 95
32174: PUSH
32175: LD_VAR 0 2
32179: ARRAY
32180: PPUSH
32181: LD_INT 2
32183: PUSH
32184: LD_INT 30
32186: PUSH
32187: LD_INT 0
32189: PUSH
32190: EMPTY
32191: LIST
32192: LIST
32193: PUSH
32194: LD_INT 30
32196: PUSH
32197: LD_INT 1
32199: PUSH
32200: EMPTY
32201: LIST
32202: LIST
32203: PUSH
32204: EMPTY
32205: LIST
32206: LIST
32207: LIST
32208: PPUSH
32209: CALL_OW 72
32213: ST_TO_ADDR
// if depot then
32214: LD_VAR 0 5
32218: IFFALSE 32236
// depot := depot [ 1 ] else
32220: LD_ADDR_VAR 0 5
32224: PUSH
32225: LD_VAR 0 5
32229: PUSH
32230: LD_INT 1
32232: ARRAY
32233: ST_TO_ADDR
32234: GO 32244
// depot := 0 ;
32236: LD_ADDR_VAR 0 5
32240: PUSH
32241: LD_INT 0
32243: ST_TO_ADDR
// if IsExtension ( mc_build_list [ i ] [ 1 ] [ 1 ] ) and not UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_workshop ] , [ f_btype , b_factory ] ] ) then
32244: LD_EXP 100
32248: PUSH
32249: LD_VAR 0 2
32253: ARRAY
32254: PUSH
32255: LD_INT 1
32257: ARRAY
32258: PUSH
32259: LD_INT 1
32261: ARRAY
32262: PPUSH
32263: CALL 59704 0 1
32267: PUSH
32268: LD_EXP 95
32272: PUSH
32273: LD_VAR 0 2
32277: ARRAY
32278: PPUSH
32279: LD_INT 2
32281: PUSH
32282: LD_INT 30
32284: PUSH
32285: LD_INT 2
32287: PUSH
32288: EMPTY
32289: LIST
32290: LIST
32291: PUSH
32292: LD_INT 30
32294: PUSH
32295: LD_INT 3
32297: PUSH
32298: EMPTY
32299: LIST
32300: LIST
32301: PUSH
32302: EMPTY
32303: LIST
32304: LIST
32305: LIST
32306: PPUSH
32307: CALL_OW 72
32311: NOT
32312: AND
32313: IFFALSE 32418
// begin for j = 1 to mc_build_list [ i ] do
32315: LD_ADDR_VAR 0 3
32319: PUSH
32320: DOUBLE
32321: LD_INT 1
32323: DEC
32324: ST_TO_ADDR
32325: LD_EXP 100
32329: PUSH
32330: LD_VAR 0 2
32334: ARRAY
32335: PUSH
32336: FOR_TO
32337: IFFALSE 32416
// if mc_build_list [ i ] [ j ] [ 1 ] = b_workshop then
32339: LD_EXP 100
32343: PUSH
32344: LD_VAR 0 2
32348: ARRAY
32349: PUSH
32350: LD_VAR 0 3
32354: ARRAY
32355: PUSH
32356: LD_INT 1
32358: ARRAY
32359: PUSH
32360: LD_INT 2
32362: EQUAL
32363: IFFALSE 32414
// begin mc_build_list := Replace ( mc_build_list , i , Reindex ( mc_build_list [ i ] , j , 1 , false ) ) ;
32365: LD_ADDR_EXP 100
32369: PUSH
32370: LD_EXP 100
32374: PPUSH
32375: LD_VAR 0 2
32379: PPUSH
32380: LD_EXP 100
32384: PUSH
32385: LD_VAR 0 2
32389: ARRAY
32390: PPUSH
32391: LD_VAR 0 3
32395: PPUSH
32396: LD_INT 1
32398: PPUSH
32399: LD_INT 0
32401: PPUSH
32402: CALL 56435 0 4
32406: PPUSH
32407: CALL_OW 1
32411: ST_TO_ADDR
// break ;
32412: GO 32416
// end ;
32414: GO 32336
32416: POP
32417: POP
// end ; if mc_build_list [ i ] [ 1 ] [ 1 ] = b_depot or ( depot and CanBeBuilt ( depot , mc_build_list [ i ] [ 1 ] [ 1 ] , mc_build_list [ i ] [ 1 ] [ 2 ] , mc_build_list [ i ] [ 1 ] [ 3 ] , mc_build_list [ i ] [ 1 ] [ 4 ] ) ) then
32418: LD_EXP 100
32422: PUSH
32423: LD_VAR 0 2
32427: ARRAY
32428: PUSH
32429: LD_INT 1
32431: ARRAY
32432: PUSH
32433: LD_INT 1
32435: ARRAY
32436: PUSH
32437: LD_INT 0
32439: EQUAL
32440: PUSH
32441: LD_VAR 0 5
32445: PUSH
32446: LD_VAR 0 5
32450: PPUSH
32451: LD_EXP 100
32455: PUSH
32456: LD_VAR 0 2
32460: ARRAY
32461: PUSH
32462: LD_INT 1
32464: ARRAY
32465: PUSH
32466: LD_INT 1
32468: ARRAY
32469: PPUSH
32470: LD_EXP 100
32474: PUSH
32475: LD_VAR 0 2
32479: ARRAY
32480: PUSH
32481: LD_INT 1
32483: ARRAY
32484: PUSH
32485: LD_INT 2
32487: ARRAY
32488: PPUSH
32489: LD_EXP 100
32493: PUSH
32494: LD_VAR 0 2
32498: ARRAY
32499: PUSH
32500: LD_INT 1
32502: ARRAY
32503: PUSH
32504: LD_INT 3
32506: ARRAY
32507: PPUSH
32508: LD_EXP 100
32512: PUSH
32513: LD_VAR 0 2
32517: ARRAY
32518: PUSH
32519: LD_INT 1
32521: ARRAY
32522: PUSH
32523: LD_INT 4
32525: ARRAY
32526: PPUSH
32527: CALL 65120 0 5
32531: AND
32532: OR
32533: IFFALSE 32814
// begin tmp := UnitFilter ( mc_bases [ i ] , [ f_class , 2 ] ) diff mc_building_repairs [ i ] ;
32535: LD_ADDR_VAR 0 4
32539: PUSH
32540: LD_EXP 95
32544: PUSH
32545: LD_VAR 0 2
32549: ARRAY
32550: PPUSH
32551: LD_INT 25
32553: PUSH
32554: LD_INT 2
32556: PUSH
32557: EMPTY
32558: LIST
32559: LIST
32560: PPUSH
32561: CALL_OW 72
32565: PUSH
32566: LD_EXP 97
32570: PUSH
32571: LD_VAR 0 2
32575: ARRAY
32576: DIFF
32577: ST_TO_ADDR
// if not tmp then
32578: LD_VAR 0 4
32582: NOT
32583: IFFALSE 32587
// continue ;
32585: GO 31832
// for j in tmp do
32587: LD_ADDR_VAR 0 3
32591: PUSH
32592: LD_VAR 0 4
32596: PUSH
32597: FOR_IN
32598: IFFALSE 32810
// begin if not mc_builders [ i ] then
32600: LD_EXP 101
32604: PUSH
32605: LD_VAR 0 2
32609: ARRAY
32610: NOT
32611: IFFALSE 32669
// begin SetTag ( j , 103 ) ;
32613: LD_VAR 0 3
32617: PPUSH
32618: LD_INT 103
32620: PPUSH
32621: CALL_OW 109
// mc_builders := ReplaceIn ( mc_builders , [ i , mc_builders [ i ] + 1 ] , j ) ;
32625: LD_ADDR_EXP 101
32629: PUSH
32630: LD_EXP 101
32634: PPUSH
32635: LD_VAR 0 2
32639: PUSH
32640: LD_EXP 101
32644: PUSH
32645: LD_VAR 0 2
32649: ARRAY
32650: PUSH
32651: LD_INT 1
32653: PLUS
32654: PUSH
32655: EMPTY
32656: LIST
32657: LIST
32658: PPUSH
32659: LD_VAR 0 3
32663: PPUSH
32664: CALL 57017 0 3
32668: ST_TO_ADDR
// end ; if IsInUnit ( j ) then
32669: LD_VAR 0 3
32673: PPUSH
32674: CALL_OW 310
32678: IFFALSE 32689
// ComExitBuilding ( j ) ;
32680: LD_VAR 0 3
32684: PPUSH
32685: CALL_OW 122
// wait ( 3 ) ;
32689: LD_INT 3
32691: PPUSH
32692: CALL_OW 67
// if not mc_build_list [ i ] then
32696: LD_EXP 100
32700: PUSH
32701: LD_VAR 0 2
32705: ARRAY
32706: NOT
32707: IFFALSE 32711
// break ;
32709: GO 32810
// if not HasTask ( j ) then
32711: LD_VAR 0 3
32715: PPUSH
32716: CALL_OW 314
32720: NOT
32721: IFFALSE 32808
// ComBuild ( j , mc_build_list [ i ] [ 1 ] [ 1 ] , mc_build_list [ i ] [ 1 ] [ 2 ] , mc_build_list [ i ] [ 1 ] [ 3 ] , mc_build_list [ i ] [ 1 ] [ 4 ] ) ;
32723: LD_VAR 0 3
32727: PPUSH
32728: LD_EXP 100
32732: PUSH
32733: LD_VAR 0 2
32737: ARRAY
32738: PUSH
32739: LD_INT 1
32741: ARRAY
32742: PUSH
32743: LD_INT 1
32745: ARRAY
32746: PPUSH
32747: LD_EXP 100
32751: PUSH
32752: LD_VAR 0 2
32756: ARRAY
32757: PUSH
32758: LD_INT 1
32760: ARRAY
32761: PUSH
32762: LD_INT 2
32764: ARRAY
32765: PPUSH
32766: LD_EXP 100
32770: PUSH
32771: LD_VAR 0 2
32775: ARRAY
32776: PUSH
32777: LD_INT 1
32779: ARRAY
32780: PUSH
32781: LD_INT 3
32783: ARRAY
32784: PPUSH
32785: LD_EXP 100
32789: PUSH
32790: LD_VAR 0 2
32794: ARRAY
32795: PUSH
32796: LD_INT 1
32798: ARRAY
32799: PUSH
32800: LD_INT 4
32802: ARRAY
32803: PPUSH
32804: CALL_OW 145
// end ;
32808: GO 32597
32810: POP
32811: POP
// end else
32812: GO 32984
// if not TryClearPlaceForBuilding ( mc_bases [ i ] , mc_build_list [ i ] [ 1 ] [ 1 ] , mc_build_list [ i ] [ 1 ] [ 2 ] , mc_build_list [ i ] [ 1 ] [ 3 ] , mc_build_list [ i ] [ 1 ] [ 4 ] , UnitFilter ( mc_bases [ i ] , [ f_type , unit_building ] ) , [ ] ) then
32814: LD_EXP 95
32818: PUSH
32819: LD_VAR 0 2
32823: ARRAY
32824: PPUSH
32825: LD_EXP 100
32829: PUSH
32830: LD_VAR 0 2
32834: ARRAY
32835: PUSH
32836: LD_INT 1
32838: ARRAY
32839: PUSH
32840: LD_INT 1
32842: ARRAY
32843: PPUSH
32844: LD_EXP 100
32848: PUSH
32849: LD_VAR 0 2
32853: ARRAY
32854: PUSH
32855: LD_INT 1
32857: ARRAY
32858: PUSH
32859: LD_INT 2
32861: ARRAY
32862: PPUSH
32863: LD_EXP 100
32867: PUSH
32868: LD_VAR 0 2
32872: ARRAY
32873: PUSH
32874: LD_INT 1
32876: ARRAY
32877: PUSH
32878: LD_INT 3
32880: ARRAY
32881: PPUSH
32882: LD_EXP 100
32886: PUSH
32887: LD_VAR 0 2
32891: ARRAY
32892: PUSH
32893: LD_INT 1
32895: ARRAY
32896: PUSH
32897: LD_INT 4
32899: ARRAY
32900: PPUSH
32901: LD_EXP 95
32905: PUSH
32906: LD_VAR 0 2
32910: ARRAY
32911: PPUSH
32912: LD_INT 21
32914: PUSH
32915: LD_INT 3
32917: PUSH
32918: EMPTY
32919: LIST
32920: LIST
32921: PPUSH
32922: CALL_OW 72
32926: PPUSH
32927: EMPTY
32928: PPUSH
32929: CALL 63870 0 7
32933: NOT
32934: IFFALSE 32984
// begin mc_build_list := Replace ( mc_build_list , i , Reindex ( mc_build_list [ i ] , 1 , - 1 , false ) ) ;
32936: LD_ADDR_EXP 100
32940: PUSH
32941: LD_EXP 100
32945: PPUSH
32946: LD_VAR 0 2
32950: PPUSH
32951: LD_EXP 100
32955: PUSH
32956: LD_VAR 0 2
32960: ARRAY
32961: PPUSH
32962: LD_INT 1
32964: PPUSH
32965: LD_INT 1
32967: NEG
32968: PPUSH
32969: LD_INT 0
32971: PPUSH
32972: CALL 56435 0 4
32976: PPUSH
32977: CALL_OW 1
32981: ST_TO_ADDR
// continue ;
32982: GO 31832
// end ; end ; end ;
32984: GO 31832
32986: POP
32987: POP
// end ;
32988: LD_VAR 0 1
32992: RET
// export function MC_BuildUpgrade ( ) ; var i , j , tmp , depot , lab ; begin
32993: LD_INT 0
32995: PPUSH
32996: PPUSH
32997: PPUSH
32998: PPUSH
32999: PPUSH
33000: PPUSH
// if not mc_bases then
33001: LD_EXP 95
33005: NOT
33006: IFFALSE 33010
// exit ;
33008: GO 33437
// for i = 1 to mc_bases do
33010: LD_ADDR_VAR 0 2
33014: PUSH
33015: DOUBLE
33016: LD_INT 1
33018: DEC
33019: ST_TO_ADDR
33020: LD_EXP 95
33024: PUSH
33025: FOR_TO
33026: IFFALSE 33435
// begin tmp := mc_build_upgrade [ i ] ;
33028: LD_ADDR_VAR 0 4
33032: PUSH
33033: LD_EXP 127
33037: PUSH
33038: LD_VAR 0 2
33042: ARRAY
33043: ST_TO_ADDR
// lab := UnitFilter ( mc_lab [ i ] , [ f_or , [ f_btype , b_lab ] , [ f_btype , b_lab_half ] ] ) ;
33044: LD_ADDR_VAR 0 6
33048: PUSH
33049: LD_EXP 128
33053: PUSH
33054: LD_VAR 0 2
33058: ARRAY
33059: PPUSH
33060: LD_INT 2
33062: PUSH
33063: LD_INT 30
33065: PUSH
33066: LD_INT 6
33068: PUSH
33069: EMPTY
33070: LIST
33071: LIST
33072: PUSH
33073: LD_INT 30
33075: PUSH
33076: LD_INT 7
33078: PUSH
33079: EMPTY
33080: LIST
33081: LIST
33082: PUSH
33083: EMPTY
33084: LIST
33085: LIST
33086: LIST
33087: PPUSH
33088: CALL_OW 72
33092: ST_TO_ADDR
// if not tmp and not lab then
33093: LD_VAR 0 4
33097: NOT
33098: PUSH
33099: LD_VAR 0 6
33103: NOT
33104: AND
33105: IFFALSE 33109
// continue ;
33107: GO 33025
// if tmp then
33109: LD_VAR 0 4
33113: IFFALSE 33233
// for j in tmp do
33115: LD_ADDR_VAR 0 3
33119: PUSH
33120: LD_VAR 0 4
33124: PUSH
33125: FOR_IN
33126: IFFALSE 33231
// begin if UpgradeCost ( j ) then
33128: LD_VAR 0 3
33132: PPUSH
33133: CALL 63530 0 1
33137: IFFALSE 33229
// begin ComUpgrade ( j ) ;
33139: LD_VAR 0 3
33143: PPUSH
33144: CALL_OW 146
// mc_build_upgrade := Replace ( mc_build_upgrade , i , mc_build_upgrade [ i ] diff j ) ;
33148: LD_ADDR_EXP 127
33152: PUSH
33153: LD_EXP 127
33157: PPUSH
33158: LD_VAR 0 2
33162: PPUSH
33163: LD_EXP 127
33167: PUSH
33168: LD_VAR 0 2
33172: ARRAY
33173: PUSH
33174: LD_VAR 0 3
33178: DIFF
33179: PPUSH
33180: CALL_OW 1
33184: ST_TO_ADDR
// mc_construct_list := ReplaceIn ( mc_construct_list , [ i , mc_construct_list [ i ] + 1 ] , j ) ;
33185: LD_ADDR_EXP 102
33189: PUSH
33190: LD_EXP 102
33194: PPUSH
33195: LD_VAR 0 2
33199: PUSH
33200: LD_EXP 102
33204: PUSH
33205: LD_VAR 0 2
33209: ARRAY
33210: PUSH
33211: LD_INT 1
33213: PLUS
33214: PUSH
33215: EMPTY
33216: LIST
33217: LIST
33218: PPUSH
33219: LD_VAR 0 3
33223: PPUSH
33224: CALL 57017 0 3
33228: ST_TO_ADDR
// end ; end ;
33229: GO 33125
33231: POP
33232: POP
// if not lab or not mc_lab_upgrade [ i ] then
33233: LD_VAR 0 6
33237: NOT
33238: PUSH
33239: LD_EXP 129
33243: PUSH
33244: LD_VAR 0 2
33248: ARRAY
33249: NOT
33250: OR
33251: IFFALSE 33255
// continue ;
33253: GO 33025
// for j in lab do
33255: LD_ADDR_VAR 0 3
33259: PUSH
33260: LD_VAR 0 6
33264: PUSH
33265: FOR_IN
33266: IFFALSE 33431
// begin if GetBType ( j ) in [ b_lab , b_lab_half ] and BuildingStatus ( j ) <> bs_build then
33268: LD_VAR 0 3
33272: PPUSH
33273: CALL_OW 266
33277: PUSH
33278: LD_INT 6
33280: PUSH
33281: LD_INT 7
33283: PUSH
33284: EMPTY
33285: LIST
33286: LIST
33287: IN
33288: PUSH
33289: LD_VAR 0 3
33293: PPUSH
33294: CALL_OW 461
33298: PUSH
33299: LD_INT 1
33301: NONEQUAL
33302: AND
33303: IFFALSE 33429
// begin if UpgradeLabCost ( j , mc_lab_upgrade [ i ] [ 1 ] ) then
33305: LD_VAR 0 3
33309: PPUSH
33310: LD_EXP 129
33314: PUSH
33315: LD_VAR 0 2
33319: ARRAY
33320: PUSH
33321: LD_INT 1
33323: ARRAY
33324: PPUSH
33325: CALL 63735 0 2
33329: IFFALSE 33429
// begin ComCancel ( j ) ;
33331: LD_VAR 0 3
33335: PPUSH
33336: CALL_OW 127
// AddComUpgradeLab ( j , mc_lab_upgrade [ i ] [ 1 ] ) ;
33340: LD_VAR 0 3
33344: PPUSH
33345: LD_EXP 129
33349: PUSH
33350: LD_VAR 0 2
33354: ARRAY
33355: PUSH
33356: LD_INT 1
33358: ARRAY
33359: PPUSH
33360: CALL_OW 207
// if not j in mc_construct_list [ i ] then
33364: LD_VAR 0 3
33368: PUSH
33369: LD_EXP 102
33373: PUSH
33374: LD_VAR 0 2
33378: ARRAY
33379: IN
33380: NOT
33381: IFFALSE 33427
// mc_construct_list := ReplaceIn ( mc_construct_list , [ i , mc_construct_list [ i ] + 1 ] , j ) ;
33383: LD_ADDR_EXP 102
33387: PUSH
33388: LD_EXP 102
33392: PPUSH
33393: LD_VAR 0 2
33397: PUSH
33398: LD_EXP 102
33402: PUSH
33403: LD_VAR 0 2
33407: ARRAY
33408: PUSH
33409: LD_INT 1
33411: PLUS
33412: PUSH
33413: EMPTY
33414: LIST
33415: LIST
33416: PPUSH
33417: LD_VAR 0 3
33421: PPUSH
33422: CALL 57017 0 3
33426: ST_TO_ADDR
// break ;
33427: GO 33431
// end ; end ; end ;
33429: GO 33265
33431: POP
33432: POP
// end ;
33433: GO 33025
33435: POP
33436: POP
// end ;
33437: LD_VAR 0 1
33441: RET
// export function MC_TurretWeapon ( ) ; var i , j , tmp , tmp2 , t , tw , busy , weapon ; begin
33442: LD_INT 0
33444: PPUSH
33445: PPUSH
33446: PPUSH
33447: PPUSH
33448: PPUSH
33449: PPUSH
33450: PPUSH
33451: PPUSH
33452: PPUSH
// if not mc_bases then
33453: LD_EXP 95
33457: NOT
33458: IFFALSE 33462
// exit ;
33460: GO 33867
// for i = 1 to mc_bases do
33462: LD_ADDR_VAR 0 2
33466: PUSH
33467: DOUBLE
33468: LD_INT 1
33470: DEC
33471: ST_TO_ADDR
33472: LD_EXP 95
33476: PUSH
33477: FOR_TO
33478: IFFALSE 33865
// begin if not mc_turret_list [ i ] or not UnitFilter ( mc_bases [ i ] , [ f_btype , b_factory ] ) then
33480: LD_EXP 103
33484: PUSH
33485: LD_VAR 0 2
33489: ARRAY
33490: NOT
33491: PUSH
33492: LD_EXP 95
33496: PUSH
33497: LD_VAR 0 2
33501: ARRAY
33502: PPUSH
33503: LD_INT 30
33505: PUSH
33506: LD_INT 3
33508: PUSH
33509: EMPTY
33510: LIST
33511: LIST
33512: PPUSH
33513: CALL_OW 72
33517: NOT
33518: OR
33519: IFFALSE 33523
// continue ;
33521: GO 33477
// busy := false ;
33523: LD_ADDR_VAR 0 8
33527: PUSH
33528: LD_INT 0
33530: ST_TO_ADDR
// tmp := UnitFilter ( mc_bases [ i ] , [ f_btype , b_factory ] ) ;
33531: LD_ADDR_VAR 0 4
33535: PUSH
33536: LD_EXP 95
33540: PUSH
33541: LD_VAR 0 2
33545: ARRAY
33546: PPUSH
33547: LD_INT 30
33549: PUSH
33550: LD_INT 3
33552: PUSH
33553: EMPTY
33554: LIST
33555: LIST
33556: PPUSH
33557: CALL_OW 72
33561: ST_TO_ADDR
// t := UnitFilter ( mc_turret_list [ i ] , [ f_or , [ f_btype , b_bunker ] , [ f_btype , b_turret ] ] ) ;
33562: LD_ADDR_VAR 0 6
33566: PUSH
33567: LD_EXP 103
33571: PUSH
33572: LD_VAR 0 2
33576: ARRAY
33577: PPUSH
33578: LD_INT 2
33580: PUSH
33581: LD_INT 30
33583: PUSH
33584: LD_INT 32
33586: PUSH
33587: EMPTY
33588: LIST
33589: LIST
33590: PUSH
33591: LD_INT 30
33593: PUSH
33594: LD_INT 33
33596: PUSH
33597: EMPTY
33598: LIST
33599: LIST
33600: PUSH
33601: EMPTY
33602: LIST
33603: LIST
33604: LIST
33605: PPUSH
33606: CALL_OW 72
33610: ST_TO_ADDR
// if not t then
33611: LD_VAR 0 6
33615: NOT
33616: IFFALSE 33620
// continue ;
33618: GO 33477
// for j in tmp do
33620: LD_ADDR_VAR 0 3
33624: PUSH
33625: LD_VAR 0 4
33629: PUSH
33630: FOR_IN
33631: IFFALSE 33661
// if not BuildingStatus ( j ) = bs_idle then
33633: LD_VAR 0 3
33637: PPUSH
33638: CALL_OW 461
33642: PUSH
33643: LD_INT 2
33645: EQUAL
33646: NOT
33647: IFFALSE 33659
// begin busy := true ;
33649: LD_ADDR_VAR 0 8
33653: PUSH
33654: LD_INT 1
33656: ST_TO_ADDR
// break ;
33657: GO 33661
// end ;
33659: GO 33630
33661: POP
33662: POP
// if busy then
33663: LD_VAR 0 8
33667: IFFALSE 33671
// continue ;
33669: GO 33477
// tw := UnitFilter ( t , [ f_bweapon , 0 ] ) ;
33671: LD_ADDR_VAR 0 7
33675: PUSH
33676: LD_VAR 0 6
33680: PPUSH
33681: LD_INT 35
33683: PUSH
33684: LD_INT 0
33686: PUSH
33687: EMPTY
33688: LIST
33689: LIST
33690: PPUSH
33691: CALL_OW 72
33695: ST_TO_ADDR
// if tw then
33696: LD_VAR 0 7
33700: IFFALSE 33777
// begin tw := tw [ 1 ] ;
33702: LD_ADDR_VAR 0 7
33706: PUSH
33707: LD_VAR 0 7
33711: PUSH
33712: LD_INT 1
33714: ARRAY
33715: ST_TO_ADDR
// weapon := GetTurretWeapon ( tw , mc_scan_area [ i ] ) ;
33716: LD_ADDR_VAR 0 9
33720: PUSH
33721: LD_VAR 0 7
33725: PPUSH
33726: LD_EXP 120
33730: PUSH
33731: LD_VAR 0 2
33735: ARRAY
33736: PPUSH
33737: CALL 62027 0 2
33741: ST_TO_ADDR
// if mc_allowed_tower_weapons [ i ] then
33742: LD_EXP 134
33746: PUSH
33747: LD_VAR 0 2
33751: ARRAY
33752: IFFALSE 33775
// if not weapon in mc_allowed_tower_weapons [ i ] then
33754: LD_VAR 0 9
33758: PUSH
33759: LD_EXP 134
33763: PUSH
33764: LD_VAR 0 2
33768: ARRAY
33769: IN
33770: NOT
33771: IFFALSE 33775
// continue ;
33773: GO 33477
// end else
33775: GO 33840
// begin tmp2 := UpgradeTurretsWeapon ( mc_turret_list [ i ] , tmp ) ;
33777: LD_ADDR_VAR 0 5
33781: PUSH
33782: LD_EXP 103
33786: PUSH
33787: LD_VAR 0 2
33791: ARRAY
33792: PPUSH
33793: LD_VAR 0 4
33797: PPUSH
33798: CALL 88260 0 2
33802: ST_TO_ADDR
// if not tmp2 then
33803: LD_VAR 0 5
33807: NOT
33808: IFFALSE 33812
// continue ;
33810: GO 33477
// tw := tmp2 [ 1 ] ;
33812: LD_ADDR_VAR 0 7
33816: PUSH
33817: LD_VAR 0 5
33821: PUSH
33822: LD_INT 1
33824: ARRAY
33825: ST_TO_ADDR
// weapon := tmp2 [ 2 ] ;
33826: LD_ADDR_VAR 0 9
33830: PUSH
33831: LD_VAR 0 5
33835: PUSH
33836: LD_INT 2
33838: ARRAY
33839: ST_TO_ADDR
// end ; if not weapon then
33840: LD_VAR 0 9
33844: NOT
33845: IFFALSE 33849
// continue ;
33847: GO 33477
// ComPlaceWeapon ( tw , weapon ) ;
33849: LD_VAR 0 7
33853: PPUSH
33854: LD_VAR 0 9
33858: PPUSH
33859: CALL_OW 148
// end ;
33863: GO 33477
33865: POP
33866: POP
// end ;
33867: LD_VAR 0 1
33871: RET
// export function MC_PlantMines ( ) ; var i , j , k , tmp , list , r ; begin
33872: LD_INT 0
33874: PPUSH
33875: PPUSH
33876: PPUSH
33877: PPUSH
33878: PPUSH
33879: PPUSH
33880: PPUSH
// if not mc_bases then
33881: LD_EXP 95
33885: NOT
33886: IFFALSE 33890
// exit ;
33888: GO 34658
// for i = 1 to mc_bases do
33890: LD_ADDR_VAR 0 2
33894: PUSH
33895: DOUBLE
33896: LD_INT 1
33898: DEC
33899: ST_TO_ADDR
33900: LD_EXP 95
33904: PUSH
33905: FOR_TO
33906: IFFALSE 34656
// begin if not mc_mines [ i ] or mc_mines [ i ] = mc_miners [ i ] or mc_scan [ i ] then
33908: LD_EXP 108
33912: PUSH
33913: LD_VAR 0 2
33917: ARRAY
33918: NOT
33919: PUSH
33920: LD_EXP 108
33924: PUSH
33925: LD_VAR 0 2
33929: ARRAY
33930: PUSH
33931: LD_EXP 109
33935: PUSH
33936: LD_VAR 0 2
33940: ARRAY
33941: EQUAL
33942: OR
33943: PUSH
33944: LD_EXP 118
33948: PUSH
33949: LD_VAR 0 2
33953: ARRAY
33954: OR
33955: IFFALSE 33959
// continue ;
33957: GO 33905
// if mc_miners [ i ] then
33959: LD_EXP 109
33963: PUSH
33964: LD_VAR 0 2
33968: ARRAY
33969: IFFALSE 34343
// begin for j = mc_miners [ i ] downto 1 do
33971: LD_ADDR_VAR 0 3
33975: PUSH
33976: DOUBLE
33977: LD_EXP 109
33981: PUSH
33982: LD_VAR 0 2
33986: ARRAY
33987: INC
33988: ST_TO_ADDR
33989: LD_INT 1
33991: PUSH
33992: FOR_DOWNTO
33993: IFFALSE 34341
// begin if IsDead ( mc_miners [ i ] [ j ] ) or GetClass ( mc_miners [ i ] [ j ] ) <> 1 then
33995: LD_EXP 109
33999: PUSH
34000: LD_VAR 0 2
34004: ARRAY
34005: PUSH
34006: LD_VAR 0 3
34010: ARRAY
34011: PPUSH
34012: CALL_OW 301
34016: PUSH
34017: LD_EXP 109
34021: PUSH
34022: LD_VAR 0 2
34026: ARRAY
34027: PUSH
34028: LD_VAR 0 3
34032: ARRAY
34033: PPUSH
34034: CALL_OW 257
34038: PUSH
34039: LD_INT 1
34041: NONEQUAL
34042: OR
34043: IFFALSE 34106
// begin tmp := mc_miners [ i ] diff mc_miners [ i ] [ j ] ;
34045: LD_ADDR_VAR 0 5
34049: PUSH
34050: LD_EXP 109
34054: PUSH
34055: LD_VAR 0 2
34059: ARRAY
34060: PUSH
34061: LD_EXP 109
34065: PUSH
34066: LD_VAR 0 2
34070: ARRAY
34071: PUSH
34072: LD_VAR 0 3
34076: ARRAY
34077: DIFF
34078: ST_TO_ADDR
// mc_miners := Replace ( mc_miners , i , tmp ) ;
34079: LD_ADDR_EXP 109
34083: PUSH
34084: LD_EXP 109
34088: PPUSH
34089: LD_VAR 0 2
34093: PPUSH
34094: LD_VAR 0 5
34098: PPUSH
34099: CALL_OW 1
34103: ST_TO_ADDR
// continue ;
34104: GO 33992
// end ; if GetClass ( mc_miners [ i ] [ j ] ) = 1 and not MineOfUnit ( mc_miners [ i ] [ j ] ) and not HasTask ( mc_miners [ i ] [ j ] ) then
34106: LD_EXP 109
34110: PUSH
34111: LD_VAR 0 2
34115: ARRAY
34116: PUSH
34117: LD_VAR 0 3
34121: ARRAY
34122: PPUSH
34123: CALL_OW 257
34127: PUSH
34128: LD_INT 1
34130: EQUAL
34131: PUSH
34132: LD_EXP 109
34136: PUSH
34137: LD_VAR 0 2
34141: ARRAY
34142: PUSH
34143: LD_VAR 0 3
34147: ARRAY
34148: PPUSH
34149: CALL_OW 459
34153: NOT
34154: AND
34155: PUSH
34156: LD_EXP 109
34160: PUSH
34161: LD_VAR 0 2
34165: ARRAY
34166: PUSH
34167: LD_VAR 0 3
34171: ARRAY
34172: PPUSH
34173: CALL_OW 314
34177: NOT
34178: AND
34179: IFFALSE 34339
// begin if IsInUnit ( mc_miners [ i ] [ j ] ) then
34181: LD_EXP 109
34185: PUSH
34186: LD_VAR 0 2
34190: ARRAY
34191: PUSH
34192: LD_VAR 0 3
34196: ARRAY
34197: PPUSH
34198: CALL_OW 310
34202: IFFALSE 34225
// ComExitBuilding ( mc_miners [ i ] [ j ] ) ;
34204: LD_EXP 109
34208: PUSH
34209: LD_VAR 0 2
34213: ARRAY
34214: PUSH
34215: LD_VAR 0 3
34219: ARRAY
34220: PPUSH
34221: CALL_OW 122
// if not HasTask ( mc_miners [ i ] [ j ] ) then
34225: LD_EXP 109
34229: PUSH
34230: LD_VAR 0 2
34234: ARRAY
34235: PUSH
34236: LD_VAR 0 3
34240: ARRAY
34241: PPUSH
34242: CALL_OW 314
34246: NOT
34247: IFFALSE 34339
// begin r := rand ( 1 , mc_mines [ i ] ) ;
34249: LD_ADDR_VAR 0 7
34253: PUSH
34254: LD_INT 1
34256: PPUSH
34257: LD_EXP 108
34261: PUSH
34262: LD_VAR 0 2
34266: ARRAY
34267: PPUSH
34268: CALL_OW 12
34272: ST_TO_ADDR
// AddComPlaceRemoteCharge ( mc_miners [ i ] [ j ] , mc_mines [ i ] [ r ] [ 1 ] , mc_mines [ i ] [ r ] [ 2 ] , 0 ) ;
34273: LD_EXP 109
34277: PUSH
34278: LD_VAR 0 2
34282: ARRAY
34283: PUSH
34284: LD_VAR 0 3
34288: ARRAY
34289: PPUSH
34290: LD_EXP 108
34294: PUSH
34295: LD_VAR 0 2
34299: ARRAY
34300: PUSH
34301: LD_VAR 0 7
34305: ARRAY
34306: PUSH
34307: LD_INT 1
34309: ARRAY
34310: PPUSH
34311: LD_EXP 108
34315: PUSH
34316: LD_VAR 0 2
34320: ARRAY
34321: PUSH
34322: LD_VAR 0 7
34326: ARRAY
34327: PUSH
34328: LD_INT 2
34330: ARRAY
34331: PPUSH
34332: LD_INT 0
34334: PPUSH
34335: CALL_OW 193
// end ; end ; end ;
34339: GO 33992
34341: POP
34342: POP
// end ; tmp := UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_armoury ] , [ f_btype , b_barracks ] , [ f_btype , b_bunker ] ] ) ;
34343: LD_ADDR_VAR 0 5
34347: PUSH
34348: LD_EXP 95
34352: PUSH
34353: LD_VAR 0 2
34357: ARRAY
34358: PPUSH
34359: LD_INT 2
34361: PUSH
34362: LD_INT 30
34364: PUSH
34365: LD_INT 4
34367: PUSH
34368: EMPTY
34369: LIST
34370: LIST
34371: PUSH
34372: LD_INT 30
34374: PUSH
34375: LD_INT 5
34377: PUSH
34378: EMPTY
34379: LIST
34380: LIST
34381: PUSH
34382: LD_INT 30
34384: PUSH
34385: LD_INT 32
34387: PUSH
34388: EMPTY
34389: LIST
34390: LIST
34391: PUSH
34392: EMPTY
34393: LIST
34394: LIST
34395: LIST
34396: LIST
34397: PPUSH
34398: CALL_OW 72
34402: ST_TO_ADDR
// if not tmp then
34403: LD_VAR 0 5
34407: NOT
34408: IFFALSE 34412
// continue ;
34410: GO 33905
// list := [ ] ;
34412: LD_ADDR_VAR 0 6
34416: PUSH
34417: EMPTY
34418: ST_TO_ADDR
// for j in tmp do
34419: LD_ADDR_VAR 0 3
34423: PUSH
34424: LD_VAR 0 5
34428: PUSH
34429: FOR_IN
34430: IFFALSE 34499
// begin for k in UnitsInside ( j ) do
34432: LD_ADDR_VAR 0 4
34436: PUSH
34437: LD_VAR 0 3
34441: PPUSH
34442: CALL_OW 313
34446: PUSH
34447: FOR_IN
34448: IFFALSE 34495
// if GetClass ( k ) = 1 and not MineOfUnit ( k ) then
34450: LD_VAR 0 4
34454: PPUSH
34455: CALL_OW 257
34459: PUSH
34460: LD_INT 1
34462: EQUAL
34463: PUSH
34464: LD_VAR 0 4
34468: PPUSH
34469: CALL_OW 459
34473: NOT
34474: AND
34475: IFFALSE 34493
// list := list ^ k ;
34477: LD_ADDR_VAR 0 6
34481: PUSH
34482: LD_VAR 0 6
34486: PUSH
34487: LD_VAR 0 4
34491: ADD
34492: ST_TO_ADDR
34493: GO 34447
34495: POP
34496: POP
// end ;
34497: GO 34429
34499: POP
34500: POP
// list := list diff mc_miners [ i ] ;
34501: LD_ADDR_VAR 0 6
34505: PUSH
34506: LD_VAR 0 6
34510: PUSH
34511: LD_EXP 109
34515: PUSH
34516: LD_VAR 0 2
34520: ARRAY
34521: DIFF
34522: ST_TO_ADDR
// if not list then
34523: LD_VAR 0 6
34527: NOT
34528: IFFALSE 34532
// continue ;
34530: GO 33905
// k := mc_mines [ i ] - mc_miners [ i ] ;
34532: LD_ADDR_VAR 0 4
34536: PUSH
34537: LD_EXP 108
34541: PUSH
34542: LD_VAR 0 2
34546: ARRAY
34547: PUSH
34548: LD_EXP 109
34552: PUSH
34553: LD_VAR 0 2
34557: ARRAY
34558: MINUS
34559: ST_TO_ADDR
// if k > list then
34560: LD_VAR 0 4
34564: PUSH
34565: LD_VAR 0 6
34569: GREATER
34570: IFFALSE 34582
// k := list ;
34572: LD_ADDR_VAR 0 4
34576: PUSH
34577: LD_VAR 0 6
34581: ST_TO_ADDR
// for j = 1 to k do
34582: LD_ADDR_VAR 0 3
34586: PUSH
34587: DOUBLE
34588: LD_INT 1
34590: DEC
34591: ST_TO_ADDR
34592: LD_VAR 0 4
34596: PUSH
34597: FOR_TO
34598: IFFALSE 34652
// mc_miners := ReplaceIn ( mc_miners , [ i , mc_miners [ i ] + 1 ] , list [ j ] ) ;
34600: LD_ADDR_EXP 109
34604: PUSH
34605: LD_EXP 109
34609: PPUSH
34610: LD_VAR 0 2
34614: PUSH
34615: LD_EXP 109
34619: PUSH
34620: LD_VAR 0 2
34624: ARRAY
34625: PUSH
34626: LD_INT 1
34628: PLUS
34629: PUSH
34630: EMPTY
34631: LIST
34632: LIST
34633: PPUSH
34634: LD_VAR 0 6
34638: PUSH
34639: LD_VAR 0 3
34643: ARRAY
34644: PPUSH
34645: CALL 57017 0 3
34649: ST_TO_ADDR
34650: GO 34597
34652: POP
34653: POP
// end ;
34654: GO 33905
34656: POP
34657: POP
// end ;
34658: LD_VAR 0 1
34662: RET
// export function MC_CollectCrates ( ) ; var i , j , k , tmp , side , target , cargo , depot , fac , components ; begin
34663: LD_INT 0
34665: PPUSH
34666: PPUSH
34667: PPUSH
34668: PPUSH
34669: PPUSH
34670: PPUSH
34671: PPUSH
34672: PPUSH
34673: PPUSH
34674: PPUSH
34675: PPUSH
// if not mc_bases then
34676: LD_EXP 95
34680: NOT
34681: IFFALSE 34685
// exit ;
34683: GO 36508
// for i = 1 to mc_bases do
34685: LD_ADDR_VAR 0 2
34689: PUSH
34690: DOUBLE
34691: LD_INT 1
34693: DEC
34694: ST_TO_ADDR
34695: LD_EXP 95
34699: PUSH
34700: FOR_TO
34701: IFFALSE 36506
// begin if not mc_bases [ i ] or mc_construct_list [ i ] then
34703: LD_EXP 95
34707: PUSH
34708: LD_VAR 0 2
34712: ARRAY
34713: NOT
34714: PUSH
34715: LD_EXP 102
34719: PUSH
34720: LD_VAR 0 2
34724: ARRAY
34725: OR
34726: IFFALSE 34730
// continue ;
34728: GO 34700
// if not mc_crates [ i ] and mc_crates_collector [ i ] then
34730: LD_EXP 111
34734: PUSH
34735: LD_VAR 0 2
34739: ARRAY
34740: NOT
34741: PUSH
34742: LD_EXP 112
34746: PUSH
34747: LD_VAR 0 2
34751: ARRAY
34752: AND
34753: IFFALSE 34791
// begin mc_crates_collector := Replace ( mc_crates_collector , i , [ ] ) ;
34755: LD_ADDR_EXP 112
34759: PUSH
34760: LD_EXP 112
34764: PPUSH
34765: LD_VAR 0 2
34769: PPUSH
34770: EMPTY
34771: PPUSH
34772: CALL_OW 1
34776: ST_TO_ADDR
// MC_Reset ( i , 107 ) ;
34777: LD_VAR 0 2
34781: PPUSH
34782: LD_INT 107
34784: PPUSH
34785: CALL 25559 0 2
// continue ;
34789: GO 34700
// end ; target := [ ] ;
34791: LD_ADDR_VAR 0 7
34795: PUSH
34796: EMPTY
34797: ST_TO_ADDR
// side := GetSide ( mc_bases [ i ] [ 1 ] ) ;
34798: LD_ADDR_VAR 0 6
34802: PUSH
34803: LD_EXP 95
34807: PUSH
34808: LD_VAR 0 2
34812: ARRAY
34813: PUSH
34814: LD_INT 1
34816: ARRAY
34817: PPUSH
34818: CALL_OW 255
34822: ST_TO_ADDR
// depot := UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) ;
34823: LD_ADDR_VAR 0 9
34827: PUSH
34828: LD_EXP 95
34832: PUSH
34833: LD_VAR 0 2
34837: ARRAY
34838: PPUSH
34839: LD_INT 2
34841: PUSH
34842: LD_INT 30
34844: PUSH
34845: LD_INT 0
34847: PUSH
34848: EMPTY
34849: LIST
34850: LIST
34851: PUSH
34852: LD_INT 30
34854: PUSH
34855: LD_INT 1
34857: PUSH
34858: EMPTY
34859: LIST
34860: LIST
34861: PUSH
34862: EMPTY
34863: LIST
34864: LIST
34865: LIST
34866: PPUSH
34867: CALL_OW 72
34871: ST_TO_ADDR
// for j = mc_crates [ i ] downto 1 do
34872: LD_ADDR_VAR 0 3
34876: PUSH
34877: DOUBLE
34878: LD_EXP 111
34882: PUSH
34883: LD_VAR 0 2
34887: ARRAY
34888: INC
34889: ST_TO_ADDR
34890: LD_INT 1
34892: PUSH
34893: FOR_DOWNTO
34894: IFFALSE 35139
// begin if ValidHex ( mc_crates [ i ] [ j ] [ 2 ] , mc_crates [ i ] [ j ] [ 3 ] ) and GetResourceAmountXY ( mc_crates [ i ] [ j ] [ 2 ] , mc_crates [ i ] [ j ] [ 3 ] ) = 0 then
34896: LD_EXP 111
34900: PUSH
34901: LD_VAR 0 2
34905: ARRAY
34906: PUSH
34907: LD_VAR 0 3
34911: ARRAY
34912: PUSH
34913: LD_INT 2
34915: ARRAY
34916: PPUSH
34917: LD_EXP 111
34921: PUSH
34922: LD_VAR 0 2
34926: ARRAY
34927: PUSH
34928: LD_VAR 0 3
34932: ARRAY
34933: PUSH
34934: LD_INT 3
34936: ARRAY
34937: PPUSH
34938: CALL_OW 488
34942: PUSH
34943: LD_EXP 111
34947: PUSH
34948: LD_VAR 0 2
34952: ARRAY
34953: PUSH
34954: LD_VAR 0 3
34958: ARRAY
34959: PUSH
34960: LD_INT 2
34962: ARRAY
34963: PPUSH
34964: LD_EXP 111
34968: PUSH
34969: LD_VAR 0 2
34973: ARRAY
34974: PUSH
34975: LD_VAR 0 3
34979: ARRAY
34980: PUSH
34981: LD_INT 3
34983: ARRAY
34984: PPUSH
34985: CALL_OW 284
34989: PUSH
34990: LD_INT 0
34992: EQUAL
34993: AND
34994: IFFALSE 35049
// begin tmp := Delete ( mc_crates [ i ] , j ) ;
34996: LD_ADDR_VAR 0 5
35000: PUSH
35001: LD_EXP 111
35005: PUSH
35006: LD_VAR 0 2
35010: ARRAY
35011: PPUSH
35012: LD_VAR 0 3
35016: PPUSH
35017: CALL_OW 3
35021: ST_TO_ADDR
// mc_crates := Replace ( mc_crates , i , tmp ) ;
35022: LD_ADDR_EXP 111
35026: PUSH
35027: LD_EXP 111
35031: PPUSH
35032: LD_VAR 0 2
35036: PPUSH
35037: LD_VAR 0 5
35041: PPUSH
35042: CALL_OW 1
35046: ST_TO_ADDR
// continue ;
35047: GO 34893
// end ; if DangerAtRangeXY ( side , mc_crates [ i ] [ j ] [ 2 ] , mc_crates [ i ] [ j ] [ 3 ] , 30 ) [ 4 ] = 0 then
35049: LD_VAR 0 6
35053: PPUSH
35054: LD_EXP 111
35058: PUSH
35059: LD_VAR 0 2
35063: ARRAY
35064: PUSH
35065: LD_VAR 0 3
35069: ARRAY
35070: PUSH
35071: LD_INT 2
35073: ARRAY
35074: PPUSH
35075: LD_EXP 111
35079: PUSH
35080: LD_VAR 0 2
35084: ARRAY
35085: PUSH
35086: LD_VAR 0 3
35090: ARRAY
35091: PUSH
35092: LD_INT 3
35094: ARRAY
35095: PPUSH
35096: LD_INT 30
35098: PPUSH
35099: CALL 57913 0 4
35103: PUSH
35104: LD_INT 4
35106: ARRAY
35107: PUSH
35108: LD_INT 0
35110: EQUAL
35111: IFFALSE 35137
// begin target := mc_crates [ i ] [ j ] ;
35113: LD_ADDR_VAR 0 7
35117: PUSH
35118: LD_EXP 111
35122: PUSH
35123: LD_VAR 0 2
35127: ARRAY
35128: PUSH
35129: LD_VAR 0 3
35133: ARRAY
35134: ST_TO_ADDR
// break ;
35135: GO 35139
// end ; end ;
35137: GO 34893
35139: POP
35140: POP
// if not target then
35141: LD_VAR 0 7
35145: NOT
35146: IFFALSE 35150
// continue ;
35148: GO 34700
// cargo := UnitFilter ( mc_vehicles [ i ] , [ [ f_or , [ f_not , [ f_empty ] ] , [ f_linked ] , [ f_control , control_apeman ] , [ f_control , control_computer ] ] , [ f_or , [ f_weapon , ar_cargo_bay ] , [ f_weapon , ru_cargo_bay ] , [ f_weapon , us_cargo_bay ] ] ] ) ;
35150: LD_ADDR_VAR 0 8
35154: PUSH
35155: LD_EXP 114
35159: PUSH
35160: LD_VAR 0 2
35164: ARRAY
35165: PPUSH
35166: LD_INT 2
35168: PUSH
35169: LD_INT 3
35171: PUSH
35172: LD_INT 58
35174: PUSH
35175: EMPTY
35176: LIST
35177: PUSH
35178: EMPTY
35179: LIST
35180: LIST
35181: PUSH
35182: LD_INT 61
35184: PUSH
35185: EMPTY
35186: LIST
35187: PUSH
35188: LD_INT 33
35190: PUSH
35191: LD_INT 5
35193: PUSH
35194: EMPTY
35195: LIST
35196: LIST
35197: PUSH
35198: LD_INT 33
35200: PUSH
35201: LD_INT 3
35203: PUSH
35204: EMPTY
35205: LIST
35206: LIST
35207: PUSH
35208: EMPTY
35209: LIST
35210: LIST
35211: LIST
35212: LIST
35213: LIST
35214: PUSH
35215: LD_INT 2
35217: PUSH
35218: LD_INT 34
35220: PUSH
35221: LD_INT 32
35223: PUSH
35224: EMPTY
35225: LIST
35226: LIST
35227: PUSH
35228: LD_INT 34
35230: PUSH
35231: LD_INT 51
35233: PUSH
35234: EMPTY
35235: LIST
35236: LIST
35237: PUSH
35238: LD_INT 34
35240: PUSH
35241: LD_INT 12
35243: PUSH
35244: EMPTY
35245: LIST
35246: LIST
35247: PUSH
35248: EMPTY
35249: LIST
35250: LIST
35251: LIST
35252: LIST
35253: PUSH
35254: EMPTY
35255: LIST
35256: LIST
35257: PPUSH
35258: CALL_OW 72
35262: ST_TO_ADDR
// if not cargo then
35263: LD_VAR 0 8
35267: NOT
35268: IFFALSE 35974
// begin if mc_crates_collector [ i ] < 5 then
35270: LD_EXP 112
35274: PUSH
35275: LD_VAR 0 2
35279: ARRAY
35280: PUSH
35281: LD_INT 5
35283: LESS
35284: IFFALSE 35650
// begin if mc_ape [ i ] then
35286: LD_EXP 124
35290: PUSH
35291: LD_VAR 0 2
35295: ARRAY
35296: IFFALSE 35343
// tmp := UnitFilter ( mc_ape [ i ] , [ [ f_class , 16 ] , [ f_lives , 750 ] ] ) ;
35298: LD_ADDR_VAR 0 5
35302: PUSH
35303: LD_EXP 124
35307: PUSH
35308: LD_VAR 0 2
35312: ARRAY
35313: PPUSH
35314: LD_INT 25
35316: PUSH
35317: LD_INT 16
35319: PUSH
35320: EMPTY
35321: LIST
35322: LIST
35323: PUSH
35324: LD_INT 24
35326: PUSH
35327: LD_INT 750
35329: PUSH
35330: EMPTY
35331: LIST
35332: LIST
35333: PUSH
35334: EMPTY
35335: LIST
35336: LIST
35337: PPUSH
35338: CALL_OW 72
35342: ST_TO_ADDR
// if not tmp then
35343: LD_VAR 0 5
35347: NOT
35348: IFFALSE 35395
// tmp := UnitFilter ( mc_bases [ i ] , [ [ f_class , 2 ] , [ f_lives , 750 ] ] ) ;
35350: LD_ADDR_VAR 0 5
35354: PUSH
35355: LD_EXP 95
35359: PUSH
35360: LD_VAR 0 2
35364: ARRAY
35365: PPUSH
35366: LD_INT 25
35368: PUSH
35369: LD_INT 2
35371: PUSH
35372: EMPTY
35373: LIST
35374: LIST
35375: PUSH
35376: LD_INT 24
35378: PUSH
35379: LD_INT 750
35381: PUSH
35382: EMPTY
35383: LIST
35384: LIST
35385: PUSH
35386: EMPTY
35387: LIST
35388: LIST
35389: PPUSH
35390: CALL_OW 72
35394: ST_TO_ADDR
// if mc_ape [ i ] and UnitFilter ( mc_bases [ i ] , [ [ f_class , 2 ] , [ f_lives , 750 ] ] ) and tmp < 5 then
35395: LD_EXP 124
35399: PUSH
35400: LD_VAR 0 2
35404: ARRAY
35405: PUSH
35406: LD_EXP 95
35410: PUSH
35411: LD_VAR 0 2
35415: ARRAY
35416: PPUSH
35417: LD_INT 25
35419: PUSH
35420: LD_INT 2
35422: PUSH
35423: EMPTY
35424: LIST
35425: LIST
35426: PUSH
35427: LD_INT 24
35429: PUSH
35430: LD_INT 750
35432: PUSH
35433: EMPTY
35434: LIST
35435: LIST
35436: PUSH
35437: EMPTY
35438: LIST
35439: LIST
35440: PPUSH
35441: CALL_OW 72
35445: AND
35446: PUSH
35447: LD_VAR 0 5
35451: PUSH
35452: LD_INT 5
35454: LESS
35455: AND
35456: IFFALSE 35538
// begin for j in UnitFilter ( mc_bases [ i ] , [ [ f_class , 2 ] , [ f_lives , 750 ] ] ) do
35458: LD_ADDR_VAR 0 3
35462: PUSH
35463: LD_EXP 95
35467: PUSH
35468: LD_VAR 0 2
35472: ARRAY
35473: PPUSH
35474: LD_INT 25
35476: PUSH
35477: LD_INT 2
35479: PUSH
35480: EMPTY
35481: LIST
35482: LIST
35483: PUSH
35484: LD_INT 24
35486: PUSH
35487: LD_INT 750
35489: PUSH
35490: EMPTY
35491: LIST
35492: LIST
35493: PUSH
35494: EMPTY
35495: LIST
35496: LIST
35497: PPUSH
35498: CALL_OW 72
35502: PUSH
35503: FOR_IN
35504: IFFALSE 35536
// begin tmp := tmp union j ;
35506: LD_ADDR_VAR 0 5
35510: PUSH
35511: LD_VAR 0 5
35515: PUSH
35516: LD_VAR 0 3
35520: UNION
35521: ST_TO_ADDR
// if tmp >= 5 then
35522: LD_VAR 0 5
35526: PUSH
35527: LD_INT 5
35529: GREATEREQUAL
35530: IFFALSE 35534
// break ;
35532: GO 35536
// end ;
35534: GO 35503
35536: POP
35537: POP
// end ; if not tmp then
35538: LD_VAR 0 5
35542: NOT
35543: IFFALSE 35547
// continue ;
35545: GO 34700
// for j in tmp do
35547: LD_ADDR_VAR 0 3
35551: PUSH
35552: LD_VAR 0 5
35556: PUSH
35557: FOR_IN
35558: IFFALSE 35648
// if not GetTag ( j ) then
35560: LD_VAR 0 3
35564: PPUSH
35565: CALL_OW 110
35569: NOT
35570: IFFALSE 35646
// begin mc_crates_collector := ReplaceIn ( mc_crates_collector , [ i , mc_crates_collector [ i ] + 1 ] , j ) ;
35572: LD_ADDR_EXP 112
35576: PUSH
35577: LD_EXP 112
35581: PPUSH
35582: LD_VAR 0 2
35586: PUSH
35587: LD_EXP 112
35591: PUSH
35592: LD_VAR 0 2
35596: ARRAY
35597: PUSH
35598: LD_INT 1
35600: PLUS
35601: PUSH
35602: EMPTY
35603: LIST
35604: LIST
35605: PPUSH
35606: LD_VAR 0 3
35610: PPUSH
35611: CALL 57017 0 3
35615: ST_TO_ADDR
// SetTag ( j , 107 ) ;
35616: LD_VAR 0 3
35620: PPUSH
35621: LD_INT 107
35623: PPUSH
35624: CALL_OW 109
// if mc_crates_collector [ i ] >= 5 then
35628: LD_EXP 112
35632: PUSH
35633: LD_VAR 0 2
35637: ARRAY
35638: PUSH
35639: LD_INT 5
35641: GREATEREQUAL
35642: IFFALSE 35646
// break ;
35644: GO 35648
// end ;
35646: GO 35557
35648: POP
35649: POP
// end ; if mc_crates_collector [ i ] and target then
35650: LD_EXP 112
35654: PUSH
35655: LD_VAR 0 2
35659: ARRAY
35660: PUSH
35661: LD_VAR 0 7
35665: AND
35666: IFFALSE 35972
// begin if mc_crates_collector [ i ] < target [ 1 ] then
35668: LD_EXP 112
35672: PUSH
35673: LD_VAR 0 2
35677: ARRAY
35678: PUSH
35679: LD_VAR 0 7
35683: PUSH
35684: LD_INT 1
35686: ARRAY
35687: LESS
35688: IFFALSE 35708
// tmp := mc_crates_collector [ i ] else
35690: LD_ADDR_VAR 0 5
35694: PUSH
35695: LD_EXP 112
35699: PUSH
35700: LD_VAR 0 2
35704: ARRAY
35705: ST_TO_ADDR
35706: GO 35722
// tmp := target [ 1 ] ;
35708: LD_ADDR_VAR 0 5
35712: PUSH
35713: LD_VAR 0 7
35717: PUSH
35718: LD_INT 1
35720: ARRAY
35721: ST_TO_ADDR
// k := 0 ;
35722: LD_ADDR_VAR 0 4
35726: PUSH
35727: LD_INT 0
35729: ST_TO_ADDR
// for j in mc_crates_collector [ i ] do
35730: LD_ADDR_VAR 0 3
35734: PUSH
35735: LD_EXP 112
35739: PUSH
35740: LD_VAR 0 2
35744: ARRAY
35745: PUSH
35746: FOR_IN
35747: IFFALSE 35970
// begin k := k + 1 ;
35749: LD_ADDR_VAR 0 4
35753: PUSH
35754: LD_VAR 0 4
35758: PUSH
35759: LD_INT 1
35761: PLUS
35762: ST_TO_ADDR
// if k > tmp then
35763: LD_VAR 0 4
35767: PUSH
35768: LD_VAR 0 5
35772: GREATER
35773: IFFALSE 35777
// break ;
35775: GO 35970
// if not GetClass ( j ) in [ 2 , 16 ] then
35777: LD_VAR 0 3
35781: PPUSH
35782: CALL_OW 257
35786: PUSH
35787: LD_INT 2
35789: PUSH
35790: LD_INT 16
35792: PUSH
35793: EMPTY
35794: LIST
35795: LIST
35796: IN
35797: NOT
35798: IFFALSE 35851
// begin mc_crates_collector := Replace ( mc_crates_collector , i , mc_crates_collector [ i ] diff j ) ;
35800: LD_ADDR_EXP 112
35804: PUSH
35805: LD_EXP 112
35809: PPUSH
35810: LD_VAR 0 2
35814: PPUSH
35815: LD_EXP 112
35819: PUSH
35820: LD_VAR 0 2
35824: ARRAY
35825: PUSH
35826: LD_VAR 0 3
35830: DIFF
35831: PPUSH
35832: CALL_OW 1
35836: ST_TO_ADDR
// SetTag ( j , 0 ) ;
35837: LD_VAR 0 3
35841: PPUSH
35842: LD_INT 0
35844: PPUSH
35845: CALL_OW 109
// continue ;
35849: GO 35746
// end ; if IsInUnit ( j ) then
35851: LD_VAR 0 3
35855: PPUSH
35856: CALL_OW 310
35860: IFFALSE 35871
// ComExitBuilding ( j ) ;
35862: LD_VAR 0 3
35866: PPUSH
35867: CALL_OW 122
// wait ( 3 ) ;
35871: LD_INT 3
35873: PPUSH
35874: CALL_OW 67
// if HasTask ( j ) and DangerAtRangeXY ( side , target [ 2 ] , target [ 3 ] , 30 ) [ 4 ] then
35878: LD_VAR 0 3
35882: PPUSH
35883: CALL_OW 314
35887: PUSH
35888: LD_VAR 0 6
35892: PPUSH
35893: LD_VAR 0 7
35897: PUSH
35898: LD_INT 2
35900: ARRAY
35901: PPUSH
35902: LD_VAR 0 7
35906: PUSH
35907: LD_INT 3
35909: ARRAY
35910: PPUSH
35911: LD_INT 30
35913: PPUSH
35914: CALL 57913 0 4
35918: PUSH
35919: LD_INT 4
35921: ARRAY
35922: AND
35923: IFFALSE 35941
// ComStandNearbyBuilding ( j , depot ) else
35925: LD_VAR 0 3
35929: PPUSH
35930: LD_VAR 0 9
35934: PPUSH
35935: CALL 53595 0 2
35939: GO 35968
// ComCollect ( j , target [ 2 ] , target [ 3 ] ) ;
35941: LD_VAR 0 3
35945: PPUSH
35946: LD_VAR 0 7
35950: PUSH
35951: LD_INT 2
35953: ARRAY
35954: PPUSH
35955: LD_VAR 0 7
35959: PUSH
35960: LD_INT 3
35962: ARRAY
35963: PPUSH
35964: CALL_OW 117
// end ;
35968: GO 35746
35970: POP
35971: POP
// end ; end else
35972: GO 36504
// begin for j in cargo do
35974: LD_ADDR_VAR 0 3
35978: PUSH
35979: LD_VAR 0 8
35983: PUSH
35984: FOR_IN
35985: IFFALSE 36502
// begin if GetTag ( j ) <> 0 then
35987: LD_VAR 0 3
35991: PPUSH
35992: CALL_OW 110
35996: PUSH
35997: LD_INT 0
35999: NONEQUAL
36000: IFFALSE 36004
// continue ;
36002: GO 35984
// if GetLives ( j ) < 1000 and not IsInArea ( j , mc_parking [ i ] ) then
36004: LD_VAR 0 3
36008: PPUSH
36009: CALL_OW 256
36013: PUSH
36014: LD_INT 1000
36016: LESS
36017: PUSH
36018: LD_VAR 0 3
36022: PPUSH
36023: LD_EXP 119
36027: PUSH
36028: LD_VAR 0 2
36032: ARRAY
36033: PPUSH
36034: CALL_OW 308
36038: NOT
36039: AND
36040: IFFALSE 36062
// ComMoveToArea ( j , mc_parking [ i ] ) ;
36042: LD_VAR 0 3
36046: PPUSH
36047: LD_EXP 119
36051: PUSH
36052: LD_VAR 0 2
36056: ARRAY
36057: PPUSH
36058: CALL_OW 113
// if GetLives ( j ) < 1000 and IsInArea ( j , mc_parking [ i ] ) then
36062: LD_VAR 0 3
36066: PPUSH
36067: CALL_OW 256
36071: PUSH
36072: LD_INT 1000
36074: LESS
36075: PUSH
36076: LD_VAR 0 3
36080: PPUSH
36081: LD_EXP 119
36085: PUSH
36086: LD_VAR 0 2
36090: ARRAY
36091: PPUSH
36092: CALL_OW 308
36096: AND
36097: IFFALSE 36101
// continue ;
36099: GO 35984
// if GetEngine ( j ) = engine_solar and GetFuel ( j ) < 15 then
36101: LD_VAR 0 3
36105: PPUSH
36106: CALL_OW 262
36110: PUSH
36111: LD_INT 2
36113: EQUAL
36114: PUSH
36115: LD_VAR 0 3
36119: PPUSH
36120: CALL_OW 261
36124: PUSH
36125: LD_INT 15
36127: LESS
36128: AND
36129: IFFALSE 36133
// continue ;
36131: GO 35984
// if GetEngine ( j ) = engine_combustion and GetFuel ( j ) < 10 then
36133: LD_VAR 0 3
36137: PPUSH
36138: CALL_OW 262
36142: PUSH
36143: LD_INT 1
36145: EQUAL
36146: PUSH
36147: LD_VAR 0 3
36151: PPUSH
36152: CALL_OW 261
36156: PUSH
36157: LD_INT 10
36159: LESS
36160: AND
36161: IFFALSE 36441
// begin if not depot then
36163: LD_VAR 0 9
36167: NOT
36168: IFFALSE 36172
// continue ;
36170: GO 35984
// if GetDistUnits ( j , NearestUnitToUnit ( depot , j ) ) < 6 then
36172: LD_VAR 0 3
36176: PPUSH
36177: LD_VAR 0 9
36181: PPUSH
36182: LD_VAR 0 3
36186: PPUSH
36187: CALL_OW 74
36191: PPUSH
36192: CALL_OW 296
36196: PUSH
36197: LD_INT 6
36199: LESS
36200: IFFALSE 36216
// SetFuel ( j , 100 ) else
36202: LD_VAR 0 3
36206: PPUSH
36207: LD_INT 100
36209: PPUSH
36210: CALL_OW 240
36214: GO 36441
// if GetFuel ( j ) = 0 then
36216: LD_VAR 0 3
36220: PPUSH
36221: CALL_OW 261
36225: PUSH
36226: LD_INT 0
36228: EQUAL
36229: IFFALSE 36441
// begin mc_vehicles := Replace ( mc_vehicles , i , mc_vehicles [ i ] diff j ) ;
36231: LD_ADDR_EXP 114
36235: PUSH
36236: LD_EXP 114
36240: PPUSH
36241: LD_VAR 0 2
36245: PPUSH
36246: LD_EXP 114
36250: PUSH
36251: LD_VAR 0 2
36255: ARRAY
36256: PUSH
36257: LD_VAR 0 3
36261: DIFF
36262: PPUSH
36263: CALL_OW 1
36267: ST_TO_ADDR
// if GetControl ( j ) = control_manual then
36268: LD_VAR 0 3
36272: PPUSH
36273: CALL_OW 263
36277: PUSH
36278: LD_INT 1
36280: EQUAL
36281: IFFALSE 36297
// ComExitVehicle ( IsInUnit ( j ) ) ;
36283: LD_VAR 0 3
36287: PPUSH
36288: CALL_OW 310
36292: PPUSH
36293: CALL_OW 121
// if GetControl ( j ) = control_remote then
36297: LD_VAR 0 3
36301: PPUSH
36302: CALL_OW 263
36306: PUSH
36307: LD_INT 2
36309: EQUAL
36310: IFFALSE 36321
// ComUnlink ( j ) ;
36312: LD_VAR 0 3
36316: PPUSH
36317: CALL_OW 136
// fac := MC_GetBuildings ( i , b_factory ) ;
36321: LD_ADDR_VAR 0 10
36325: PUSH
36326: LD_VAR 0 2
36330: PPUSH
36331: LD_INT 3
36333: PPUSH
36334: CALL 46080 0 2
36338: ST_TO_ADDR
// if fac then
36339: LD_VAR 0 10
36343: IFFALSE 36439
// begin for k in fac do
36345: LD_ADDR_VAR 0 4
36349: PUSH
36350: LD_VAR 0 10
36354: PUSH
36355: FOR_IN
36356: IFFALSE 36437
// begin components := Produce ( fac , GetChassis ( j ) , GetEngine ( j ) , GetControl ( j ) , GetWeapon ( j ) ) ;
36358: LD_ADDR_VAR 0 11
36362: PUSH
36363: LD_VAR 0 10
36367: PPUSH
36368: LD_VAR 0 3
36372: PPUSH
36373: CALL_OW 265
36377: PPUSH
36378: LD_VAR 0 3
36382: PPUSH
36383: CALL_OW 262
36387: PPUSH
36388: LD_VAR 0 3
36392: PPUSH
36393: CALL_OW 263
36397: PPUSH
36398: LD_VAR 0 3
36402: PPUSH
36403: CALL_OW 264
36407: PPUSH
36408: CALL 54513 0 5
36412: ST_TO_ADDR
// if components then
36413: LD_VAR 0 11
36417: IFFALSE 36435
// begin MC_InsertProduceList ( i , components ) ;
36419: LD_VAR 0 2
36423: PPUSH
36424: LD_VAR 0 11
36428: PPUSH
36429: CALL 45625 0 2
// break ;
36433: GO 36437
// end ; end ;
36435: GO 36355
36437: POP
36438: POP
// end ; continue ;
36439: GO 35984
// end ; end ; if GetCargo ( j , mat_cans ) < 100 and not HasTask ( j ) then
36441: LD_VAR 0 3
36445: PPUSH
36446: LD_INT 1
36448: PPUSH
36449: CALL_OW 289
36453: PUSH
36454: LD_INT 100
36456: LESS
36457: PUSH
36458: LD_VAR 0 3
36462: PPUSH
36463: CALL_OW 314
36467: NOT
36468: AND
36469: IFFALSE 36498
// ComCollect ( j , target [ 2 ] , target [ 3 ] ) ;
36471: LD_VAR 0 3
36475: PPUSH
36476: LD_VAR 0 7
36480: PUSH
36481: LD_INT 2
36483: ARRAY
36484: PPUSH
36485: LD_VAR 0 7
36489: PUSH
36490: LD_INT 3
36492: ARRAY
36493: PPUSH
36494: CALL_OW 117
// break ;
36498: GO 36502
// end ;
36500: GO 35984
36502: POP
36503: POP
// end ; end ;
36504: GO 34700
36506: POP
36507: POP
// end ;
36508: LD_VAR 0 1
36512: RET
// export function MC_LinkRemoteControl ( ) ; var i , j , tmp ; begin
36513: LD_INT 0
36515: PPUSH
36516: PPUSH
36517: PPUSH
36518: PPUSH
// if not mc_bases then
36519: LD_EXP 95
36523: NOT
36524: IFFALSE 36528
// exit ;
36526: GO 36689
// for i = 1 to mc_bases do
36528: LD_ADDR_VAR 0 2
36532: PUSH
36533: DOUBLE
36534: LD_INT 1
36536: DEC
36537: ST_TO_ADDR
36538: LD_EXP 95
36542: PUSH
36543: FOR_TO
36544: IFFALSE 36687
// begin tmp := UnitFilter ( mc_vehicles [ i ] union mc_defender [ i ] , [ f_control , control_remote ] ) ;
36546: LD_ADDR_VAR 0 4
36550: PUSH
36551: LD_EXP 114
36555: PUSH
36556: LD_VAR 0 2
36560: ARRAY
36561: PUSH
36562: LD_EXP 117
36566: PUSH
36567: LD_VAR 0 2
36571: ARRAY
36572: UNION
36573: PPUSH
36574: LD_INT 33
36576: PUSH
36577: LD_INT 2
36579: PUSH
36580: EMPTY
36581: LIST
36582: LIST
36583: PPUSH
36584: CALL_OW 72
36588: ST_TO_ADDR
// if tmp then
36589: LD_VAR 0 4
36593: IFFALSE 36685
// for j in tmp do
36595: LD_ADDR_VAR 0 3
36599: PUSH
36600: LD_VAR 0 4
36604: PUSH
36605: FOR_IN
36606: IFFALSE 36683
// if not IsControledBy ( j ) and GetLives ( j ) >= 250 then
36608: LD_VAR 0 3
36612: PPUSH
36613: CALL_OW 312
36617: NOT
36618: PUSH
36619: LD_VAR 0 3
36623: PPUSH
36624: CALL_OW 256
36628: PUSH
36629: LD_INT 250
36631: GREATEREQUAL
36632: AND
36633: IFFALSE 36646
// Connect ( j ) else
36635: LD_VAR 0 3
36639: PPUSH
36640: CALL 59988 0 1
36644: GO 36681
// if GetLives ( j ) < 250 and IsControledBy ( j ) then
36646: LD_VAR 0 3
36650: PPUSH
36651: CALL_OW 256
36655: PUSH
36656: LD_INT 250
36658: LESS
36659: PUSH
36660: LD_VAR 0 3
36664: PPUSH
36665: CALL_OW 312
36669: AND
36670: IFFALSE 36681
// ComUnlink ( j ) ;
36672: LD_VAR 0 3
36676: PPUSH
36677: CALL_OW 136
36681: GO 36605
36683: POP
36684: POP
// end ;
36685: GO 36543
36687: POP
36688: POP
// end ;
36689: LD_VAR 0 1
36693: RET
// export function MC_ProduceVehicle ( ) ; var i , j , tmp , fac ; begin
36694: LD_INT 0
36696: PPUSH
36697: PPUSH
36698: PPUSH
36699: PPUSH
36700: PPUSH
// if not mc_bases then
36701: LD_EXP 95
36705: NOT
36706: IFFALSE 36710
// exit ;
36708: GO 37155
// for i = 1 to mc_bases do
36710: LD_ADDR_VAR 0 2
36714: PUSH
36715: DOUBLE
36716: LD_INT 1
36718: DEC
36719: ST_TO_ADDR
36720: LD_EXP 95
36724: PUSH
36725: FOR_TO
36726: IFFALSE 37153
// begin if not mc_produce [ i ] then
36728: LD_EXP 116
36732: PUSH
36733: LD_VAR 0 2
36737: ARRAY
36738: NOT
36739: IFFALSE 36743
// continue ;
36741: GO 36725
// fac := UnitFilter ( mc_bases [ i ] , [ f_btype , b_factory ] ) ;
36743: LD_ADDR_VAR 0 5
36747: PUSH
36748: LD_EXP 95
36752: PUSH
36753: LD_VAR 0 2
36757: ARRAY
36758: PPUSH
36759: LD_INT 30
36761: PUSH
36762: LD_INT 3
36764: PUSH
36765: EMPTY
36766: LIST
36767: LIST
36768: PPUSH
36769: CALL_OW 72
36773: ST_TO_ADDR
// if not fac then
36774: LD_VAR 0 5
36778: NOT
36779: IFFALSE 36783
// continue ;
36781: GO 36725
// for j in fac do
36783: LD_ADDR_VAR 0 3
36787: PUSH
36788: LD_VAR 0 5
36792: PUSH
36793: FOR_IN
36794: IFFALSE 37149
// begin if BuildingStatus ( j ) <> bs_idle or DangerAtRange ( j , 15 ) [ 4 ] then
36796: LD_VAR 0 3
36800: PPUSH
36801: CALL_OW 461
36805: PUSH
36806: LD_INT 2
36808: NONEQUAL
36809: PUSH
36810: LD_VAR 0 3
36814: PPUSH
36815: LD_INT 15
36817: PPUSH
36818: CALL 59616 0 2
36822: PUSH
36823: LD_INT 4
36825: ARRAY
36826: OR
36827: IFFALSE 36831
// continue ;
36829: GO 36793
// if CanBeConstructed ( j , mc_produce [ i ] [ 1 ] [ 1 ] , mc_produce [ i ] [ 1 ] [ 2 ] , mc_produce [ i ] [ 1 ] [ 3 ] , mc_produce [ i ] [ 1 ] [ 4 ] ) and VehicleCost ( j , [ mc_produce [ i ] [ 1 ] [ 1 ] , mc_produce [ i ] [ 1 ] [ 2 ] , mc_produce [ i ] [ 1 ] [ 3 ] , mc_produce [ i ] [ 1 ] [ 4 ] ] ) then
36831: LD_VAR 0 3
36835: PPUSH
36836: LD_EXP 116
36840: PUSH
36841: LD_VAR 0 2
36845: ARRAY
36846: PUSH
36847: LD_INT 1
36849: ARRAY
36850: PUSH
36851: LD_INT 1
36853: ARRAY
36854: PPUSH
36855: LD_EXP 116
36859: PUSH
36860: LD_VAR 0 2
36864: ARRAY
36865: PUSH
36866: LD_INT 1
36868: ARRAY
36869: PUSH
36870: LD_INT 2
36872: ARRAY
36873: PPUSH
36874: LD_EXP 116
36878: PUSH
36879: LD_VAR 0 2
36883: ARRAY
36884: PUSH
36885: LD_INT 1
36887: ARRAY
36888: PUSH
36889: LD_INT 3
36891: ARRAY
36892: PPUSH
36893: LD_EXP 116
36897: PUSH
36898: LD_VAR 0 2
36902: ARRAY
36903: PUSH
36904: LD_INT 1
36906: ARRAY
36907: PUSH
36908: LD_INT 4
36910: ARRAY
36911: PPUSH
36912: CALL_OW 448
36916: PUSH
36917: LD_VAR 0 3
36921: PPUSH
36922: LD_EXP 116
36926: PUSH
36927: LD_VAR 0 2
36931: ARRAY
36932: PUSH
36933: LD_INT 1
36935: ARRAY
36936: PUSH
36937: LD_INT 1
36939: ARRAY
36940: PUSH
36941: LD_EXP 116
36945: PUSH
36946: LD_VAR 0 2
36950: ARRAY
36951: PUSH
36952: LD_INT 1
36954: ARRAY
36955: PUSH
36956: LD_INT 2
36958: ARRAY
36959: PUSH
36960: LD_EXP 116
36964: PUSH
36965: LD_VAR 0 2
36969: ARRAY
36970: PUSH
36971: LD_INT 1
36973: ARRAY
36974: PUSH
36975: LD_INT 3
36977: ARRAY
36978: PUSH
36979: LD_EXP 116
36983: PUSH
36984: LD_VAR 0 2
36988: ARRAY
36989: PUSH
36990: LD_INT 1
36992: ARRAY
36993: PUSH
36994: LD_INT 4
36996: ARRAY
36997: PUSH
36998: EMPTY
36999: LIST
37000: LIST
37001: LIST
37002: LIST
37003: PPUSH
37004: CALL 63383 0 2
37008: AND
37009: IFFALSE 37147
// begin AddComConstruct ( j , mc_produce [ i ] [ 1 ] [ 1 ] , mc_produce [ i ] [ 1 ] [ 2 ] , mc_produce [ i ] [ 1 ] [ 3 ] , mc_produce [ i ] [ 1 ] [ 4 ] ) ;
37011: LD_VAR 0 3
37015: PPUSH
37016: LD_EXP 116
37020: PUSH
37021: LD_VAR 0 2
37025: ARRAY
37026: PUSH
37027: LD_INT 1
37029: ARRAY
37030: PUSH
37031: LD_INT 1
37033: ARRAY
37034: PPUSH
37035: LD_EXP 116
37039: PUSH
37040: LD_VAR 0 2
37044: ARRAY
37045: PUSH
37046: LD_INT 1
37048: ARRAY
37049: PUSH
37050: LD_INT 2
37052: ARRAY
37053: PPUSH
37054: LD_EXP 116
37058: PUSH
37059: LD_VAR 0 2
37063: ARRAY
37064: PUSH
37065: LD_INT 1
37067: ARRAY
37068: PUSH
37069: LD_INT 3
37071: ARRAY
37072: PPUSH
37073: LD_EXP 116
37077: PUSH
37078: LD_VAR 0 2
37082: ARRAY
37083: PUSH
37084: LD_INT 1
37086: ARRAY
37087: PUSH
37088: LD_INT 4
37090: ARRAY
37091: PPUSH
37092: CALL_OW 185
// tmp := Delete ( mc_produce [ i ] , 1 ) ;
37096: LD_ADDR_VAR 0 4
37100: PUSH
37101: LD_EXP 116
37105: PUSH
37106: LD_VAR 0 2
37110: ARRAY
37111: PPUSH
37112: LD_INT 1
37114: PPUSH
37115: CALL_OW 3
37119: ST_TO_ADDR
// mc_produce := Replace ( mc_produce , i , tmp ) ;
37120: LD_ADDR_EXP 116
37124: PUSH
37125: LD_EXP 116
37129: PPUSH
37130: LD_VAR 0 2
37134: PPUSH
37135: LD_VAR 0 4
37139: PPUSH
37140: CALL_OW 1
37144: ST_TO_ADDR
// break ;
37145: GO 37149
// end ; end ;
37147: GO 36793
37149: POP
37150: POP
// end ;
37151: GO 36725
37153: POP
37154: POP
// end ;
37155: LD_VAR 0 1
37159: RET
// export function MC_SendAttack ( ) ; var i , tmp ; begin
37160: LD_INT 0
37162: PPUSH
37163: PPUSH
37164: PPUSH
// if not mc_bases then
37165: LD_EXP 95
37169: NOT
37170: IFFALSE 37174
// exit ;
37172: GO 37263
// for i = 1 to mc_bases do
37174: LD_ADDR_VAR 0 2
37178: PUSH
37179: DOUBLE
37180: LD_INT 1
37182: DEC
37183: ST_TO_ADDR
37184: LD_EXP 95
37188: PUSH
37189: FOR_TO
37190: IFFALSE 37261
// begin if mc_attack [ i ] then
37192: LD_EXP 115
37196: PUSH
37197: LD_VAR 0 2
37201: ARRAY
37202: IFFALSE 37259
// begin tmp := mc_attack [ i ] [ 1 ] ;
37204: LD_ADDR_VAR 0 3
37208: PUSH
37209: LD_EXP 115
37213: PUSH
37214: LD_VAR 0 2
37218: ARRAY
37219: PUSH
37220: LD_INT 1
37222: ARRAY
37223: ST_TO_ADDR
// mc_attack := Replace ( mc_attack , i , [ ] ) ;
37224: LD_ADDR_EXP 115
37228: PUSH
37229: LD_EXP 115
37233: PPUSH
37234: LD_VAR 0 2
37238: PPUSH
37239: EMPTY
37240: PPUSH
37241: CALL_OW 1
37245: ST_TO_ADDR
// Attack ( tmp ) ;
37246: LD_VAR 0 3
37250: PPUSH
37251: CALL 111040 0 1
// exit ;
37255: POP
37256: POP
37257: GO 37263
// end ; end ;
37259: GO 37189
37261: POP
37262: POP
// end ;
37263: LD_VAR 0 1
37267: RET
// export function MC_Defend ( ) ; var i , j , tmp , t , x , class ; begin
37268: LD_INT 0
37270: PPUSH
37271: PPUSH
37272: PPUSH
37273: PPUSH
37274: PPUSH
37275: PPUSH
37276: PPUSH
// if not mc_bases then
37277: LD_EXP 95
37281: NOT
37282: IFFALSE 37286
// exit ;
37284: GO 38143
// for i = 1 to mc_bases do
37286: LD_ADDR_VAR 0 2
37290: PUSH
37291: DOUBLE
37292: LD_INT 1
37294: DEC
37295: ST_TO_ADDR
37296: LD_EXP 95
37300: PUSH
37301: FOR_TO
37302: IFFALSE 38141
// begin if not mc_bases [ i ] then
37304: LD_EXP 95
37308: PUSH
37309: LD_VAR 0 2
37313: ARRAY
37314: NOT
37315: IFFALSE 37319
// continue ;
37317: GO 37301
// class := AllowSpecClass ( mc_bases [ i ] [ 1 ] ) ;
37319: LD_ADDR_VAR 0 7
37323: PUSH
37324: LD_EXP 95
37328: PUSH
37329: LD_VAR 0 2
37333: ARRAY
37334: PUSH
37335: LD_INT 1
37337: ARRAY
37338: PPUSH
37339: CALL 53817 0 1
37343: ST_TO_ADDR
// mc_scan := Replace ( mc_scan , i , ScanBase ( GetSide ( mc_bases [ i ] [ 1 ] ) , mc_scan_area [ i ] ) ) ;
37344: LD_ADDR_EXP 118
37348: PUSH
37349: LD_EXP 118
37353: PPUSH
37354: LD_VAR 0 2
37358: PPUSH
37359: LD_EXP 95
37363: PUSH
37364: LD_VAR 0 2
37368: ARRAY
37369: PUSH
37370: LD_INT 1
37372: ARRAY
37373: PPUSH
37374: CALL_OW 255
37378: PPUSH
37379: LD_EXP 120
37383: PUSH
37384: LD_VAR 0 2
37388: ARRAY
37389: PPUSH
37390: CALL 53782 0 2
37394: PPUSH
37395: CALL_OW 1
37399: ST_TO_ADDR
// if not mc_scan [ i ] then
37400: LD_EXP 118
37404: PUSH
37405: LD_VAR 0 2
37409: ARRAY
37410: NOT
37411: IFFALSE 37589
// begin mc_is_defending := Replace ( mc_is_defending , i , false ) ;
37413: LD_ADDR_EXP 138
37417: PUSH
37418: LD_EXP 138
37422: PPUSH
37423: LD_VAR 0 2
37427: PPUSH
37428: LD_INT 0
37430: PPUSH
37431: CALL_OW 1
37435: ST_TO_ADDR
// tmp := UnitFilter ( mc_bases [ i ] , [ f_or , [ f_class , 5 ] , [ f_class , 8 ] , [ f_class , 9 ] ] ) ;
37436: LD_ADDR_VAR 0 4
37440: PUSH
37441: LD_EXP 95
37445: PUSH
37446: LD_VAR 0 2
37450: ARRAY
37451: PPUSH
37452: LD_INT 2
37454: PUSH
37455: LD_INT 25
37457: PUSH
37458: LD_INT 5
37460: PUSH
37461: EMPTY
37462: LIST
37463: LIST
37464: PUSH
37465: LD_INT 25
37467: PUSH
37468: LD_INT 8
37470: PUSH
37471: EMPTY
37472: LIST
37473: LIST
37474: PUSH
37475: LD_INT 25
37477: PUSH
37478: LD_INT 9
37480: PUSH
37481: EMPTY
37482: LIST
37483: LIST
37484: PUSH
37485: EMPTY
37486: LIST
37487: LIST
37488: LIST
37489: LIST
37490: PPUSH
37491: CALL_OW 72
37495: ST_TO_ADDR
// if not tmp then
37496: LD_VAR 0 4
37500: NOT
37501: IFFALSE 37505
// continue ;
37503: GO 37301
// for j in tmp do
37505: LD_ADDR_VAR 0 3
37509: PUSH
37510: LD_VAR 0 4
37514: PUSH
37515: FOR_IN
37516: IFFALSE 37587
// if GetBType ( IsInUnit ( j ) ) = b_barracks and GetClass ( j ) = 1 and not MineOfUnit ( j ) and class then
37518: LD_VAR 0 3
37522: PPUSH
37523: CALL_OW 310
37527: PPUSH
37528: CALL_OW 266
37532: PUSH
37533: LD_INT 5
37535: EQUAL
37536: PUSH
37537: LD_VAR 0 3
37541: PPUSH
37542: CALL_OW 257
37546: PUSH
37547: LD_INT 1
37549: EQUAL
37550: AND
37551: PUSH
37552: LD_VAR 0 3
37556: PPUSH
37557: CALL_OW 459
37561: NOT
37562: AND
37563: PUSH
37564: LD_VAR 0 7
37568: AND
37569: IFFALSE 37585
// ComChangeProfession ( j , class ) ;
37571: LD_VAR 0 3
37575: PPUSH
37576: LD_VAR 0 7
37580: PPUSH
37581: CALL_OW 123
37585: GO 37515
37587: POP
37588: POP
// end ; if mc_scan [ i ] and not mc_is_defending [ i ] and not mc_defender [ i ] and ( UnitFilter ( mc_bases [ i ] , [ [ f_ok ] , [ f_or , [ f_btype , b_bunker ] , [ f_btype , b_turret ] , [ f_btype , b_armoury ] , [ f_btype , b_barracks ] ] ] ) < 4 or UnitFilter ( mc_bases [ i ] , [ [ f_not , [ f_lives , 1000 ] ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ] ) ) then
37589: LD_EXP 118
37593: PUSH
37594: LD_VAR 0 2
37598: ARRAY
37599: PUSH
37600: LD_EXP 138
37604: PUSH
37605: LD_VAR 0 2
37609: ARRAY
37610: NOT
37611: AND
37612: PUSH
37613: LD_EXP 117
37617: PUSH
37618: LD_VAR 0 2
37622: ARRAY
37623: NOT
37624: AND
37625: PUSH
37626: LD_EXP 95
37630: PUSH
37631: LD_VAR 0 2
37635: ARRAY
37636: PPUSH
37637: LD_INT 50
37639: PUSH
37640: EMPTY
37641: LIST
37642: PUSH
37643: LD_INT 2
37645: PUSH
37646: LD_INT 30
37648: PUSH
37649: LD_INT 32
37651: PUSH
37652: EMPTY
37653: LIST
37654: LIST
37655: PUSH
37656: LD_INT 30
37658: PUSH
37659: LD_INT 33
37661: PUSH
37662: EMPTY
37663: LIST
37664: LIST
37665: PUSH
37666: LD_INT 30
37668: PUSH
37669: LD_INT 4
37671: PUSH
37672: EMPTY
37673: LIST
37674: LIST
37675: PUSH
37676: LD_INT 30
37678: PUSH
37679: LD_INT 5
37681: PUSH
37682: EMPTY
37683: LIST
37684: LIST
37685: PUSH
37686: EMPTY
37687: LIST
37688: LIST
37689: LIST
37690: LIST
37691: LIST
37692: PUSH
37693: EMPTY
37694: LIST
37695: LIST
37696: PPUSH
37697: CALL_OW 72
37701: PUSH
37702: LD_INT 4
37704: LESS
37705: PUSH
37706: LD_EXP 95
37710: PUSH
37711: LD_VAR 0 2
37715: ARRAY
37716: PPUSH
37717: LD_INT 3
37719: PUSH
37720: LD_INT 24
37722: PUSH
37723: LD_INT 1000
37725: PUSH
37726: EMPTY
37727: LIST
37728: LIST
37729: PUSH
37730: EMPTY
37731: LIST
37732: LIST
37733: PUSH
37734: LD_INT 2
37736: PUSH
37737: LD_INT 30
37739: PUSH
37740: LD_INT 0
37742: PUSH
37743: EMPTY
37744: LIST
37745: LIST
37746: PUSH
37747: LD_INT 30
37749: PUSH
37750: LD_INT 1
37752: PUSH
37753: EMPTY
37754: LIST
37755: LIST
37756: PUSH
37757: EMPTY
37758: LIST
37759: LIST
37760: LIST
37761: PUSH
37762: EMPTY
37763: LIST
37764: LIST
37765: PPUSH
37766: CALL_OW 72
37770: OR
37771: AND
37772: IFFALSE 38023
// begin mc_is_defending := Replace ( mc_is_defending , i , true ) ;
37774: LD_ADDR_EXP 138
37778: PUSH
37779: LD_EXP 138
37783: PPUSH
37784: LD_VAR 0 2
37788: PPUSH
37789: LD_INT 1
37791: PPUSH
37792: CALL_OW 1
37796: ST_TO_ADDR
// tmp := UnitFilter ( mc_bases [ i ] , [ f_or , [ f_class , 1 ] , [ f_class , 5 ] , [ f_class , 8 ] , [ f_class , 9 ] ] ) ;
37797: LD_ADDR_VAR 0 4
37801: PUSH
37802: LD_EXP 95
37806: PUSH
37807: LD_VAR 0 2
37811: ARRAY
37812: PPUSH
37813: LD_INT 2
37815: PUSH
37816: LD_INT 25
37818: PUSH
37819: LD_INT 1
37821: PUSH
37822: EMPTY
37823: LIST
37824: LIST
37825: PUSH
37826: LD_INT 25
37828: PUSH
37829: LD_INT 5
37831: PUSH
37832: EMPTY
37833: LIST
37834: LIST
37835: PUSH
37836: LD_INT 25
37838: PUSH
37839: LD_INT 8
37841: PUSH
37842: EMPTY
37843: LIST
37844: LIST
37845: PUSH
37846: LD_INT 25
37848: PUSH
37849: LD_INT 9
37851: PUSH
37852: EMPTY
37853: LIST
37854: LIST
37855: PUSH
37856: EMPTY
37857: LIST
37858: LIST
37859: LIST
37860: LIST
37861: LIST
37862: PPUSH
37863: CALL_OW 72
37867: ST_TO_ADDR
// tmp := tmp diff FilterByTag ( tmp , 18 ) ;
37868: LD_ADDR_VAR 0 4
37872: PUSH
37873: LD_VAR 0 4
37877: PUSH
37878: LD_VAR 0 4
37882: PPUSH
37883: LD_INT 18
37885: PPUSH
37886: CALL 86286 0 2
37890: DIFF
37891: ST_TO_ADDR
// if not tmp and not UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_armoury ] , [ f_btype , b_barracks ] ] ) then
37892: LD_VAR 0 4
37896: NOT
37897: PUSH
37898: LD_EXP 95
37902: PUSH
37903: LD_VAR 0 2
37907: ARRAY
37908: PPUSH
37909: LD_INT 2
37911: PUSH
37912: LD_INT 30
37914: PUSH
37915: LD_INT 4
37917: PUSH
37918: EMPTY
37919: LIST
37920: LIST
37921: PUSH
37922: LD_INT 30
37924: PUSH
37925: LD_INT 5
37927: PUSH
37928: EMPTY
37929: LIST
37930: LIST
37931: PUSH
37932: EMPTY
37933: LIST
37934: LIST
37935: LIST
37936: PPUSH
37937: CALL_OW 72
37941: NOT
37942: AND
37943: IFFALSE 38005
// tmp := UnitFilter ( mc_bases [ i ] , [ f_or , [ f_class , 2 ] , [ f_class , 3 ] , [ f_class , 4 ] ] ) ;
37945: LD_ADDR_VAR 0 4
37949: PUSH
37950: LD_EXP 95
37954: PUSH
37955: LD_VAR 0 2
37959: ARRAY
37960: PPUSH
37961: LD_INT 2
37963: PUSH
37964: LD_INT 25
37966: PUSH
37967: LD_INT 2
37969: PUSH
37970: EMPTY
37971: LIST
37972: LIST
37973: PUSH
37974: LD_INT 25
37976: PUSH
37977: LD_INT 3
37979: PUSH
37980: EMPTY
37981: LIST
37982: LIST
37983: PUSH
37984: LD_INT 25
37986: PUSH
37987: LD_INT 4
37989: PUSH
37990: EMPTY
37991: LIST
37992: LIST
37993: PUSH
37994: EMPTY
37995: LIST
37996: LIST
37997: LIST
37998: LIST
37999: PPUSH
38000: CALL_OW 72
38004: ST_TO_ADDR
// BasicDefend ( i , tmp ) ;
38005: LD_VAR 0 2
38009: PPUSH
38010: LD_VAR 0 4
38014: PPUSH
38015: CALL 115749 0 2
// exit ;
38019: POP
38020: POP
38021: GO 38143
// end ; if mc_scan [ i ] and not mc_is_defending [ i ] and mc_defender [ i ] then
38023: LD_EXP 118
38027: PUSH
38028: LD_VAR 0 2
38032: ARRAY
38033: PUSH
38034: LD_EXP 138
38038: PUSH
38039: LD_VAR 0 2
38043: ARRAY
38044: NOT
38045: AND
38046: PUSH
38047: LD_EXP 117
38051: PUSH
38052: LD_VAR 0 2
38056: ARRAY
38057: AND
38058: IFFALSE 38139
// begin mc_is_defending := Replace ( mc_is_defending , i , true ) ;
38060: LD_ADDR_EXP 138
38064: PUSH
38065: LD_EXP 138
38069: PPUSH
38070: LD_VAR 0 2
38074: PPUSH
38075: LD_INT 1
38077: PPUSH
38078: CALL_OW 1
38082: ST_TO_ADDR
// tmp := mc_defender [ i ] ;
38083: LD_ADDR_VAR 0 4
38087: PUSH
38088: LD_EXP 117
38092: PUSH
38093: LD_VAR 0 2
38097: ARRAY
38098: ST_TO_ADDR
// mc_defender := Replace ( mc_defender , i , [ ] ) ;
38099: LD_ADDR_EXP 117
38103: PUSH
38104: LD_EXP 117
38108: PPUSH
38109: LD_VAR 0 2
38113: PPUSH
38114: EMPTY
38115: PPUSH
38116: CALL_OW 1
38120: ST_TO_ADDR
// Defend ( i , tmp ) ;
38121: LD_VAR 0 2
38125: PPUSH
38126: LD_VAR 0 4
38130: PPUSH
38131: CALL 116345 0 2
// exit ;
38135: POP
38136: POP
38137: GO 38143
// end ; end ;
38139: GO 37301
38141: POP
38142: POP
// end ;
38143: LD_VAR 0 1
38147: RET
// export function MC_Research ( ) ; var i , j , side , t , tmp , x , sci , tmp2 , researching , idle_lab ; begin
38148: LD_INT 0
38150: PPUSH
38151: PPUSH
38152: PPUSH
38153: PPUSH
38154: PPUSH
38155: PPUSH
38156: PPUSH
38157: PPUSH
38158: PPUSH
38159: PPUSH
38160: PPUSH
// if not mc_bases then
38161: LD_EXP 95
38165: NOT
38166: IFFALSE 38170
// exit ;
38168: GO 39257
// for i = 1 to mc_bases do
38170: LD_ADDR_VAR 0 2
38174: PUSH
38175: DOUBLE
38176: LD_INT 1
38178: DEC
38179: ST_TO_ADDR
38180: LD_EXP 95
38184: PUSH
38185: FOR_TO
38186: IFFALSE 39255
// begin tmp := mc_lab [ i ] ;
38188: LD_ADDR_VAR 0 6
38192: PUSH
38193: LD_EXP 128
38197: PUSH
38198: LD_VAR 0 2
38202: ARRAY
38203: ST_TO_ADDR
// if not tmp then
38204: LD_VAR 0 6
38208: NOT
38209: IFFALSE 38213
// continue ;
38211: GO 38185
// idle_lab := 0 ;
38213: LD_ADDR_VAR 0 11
38217: PUSH
38218: LD_INT 0
38220: ST_TO_ADDR
// for j in tmp do
38221: LD_ADDR_VAR 0 3
38225: PUSH
38226: LD_VAR 0 6
38230: PUSH
38231: FOR_IN
38232: IFFALSE 39251
// begin researching := false ;
38234: LD_ADDR_VAR 0 10
38238: PUSH
38239: LD_INT 0
38241: ST_TO_ADDR
// side := GetSide ( j ) ;
38242: LD_ADDR_VAR 0 4
38246: PUSH
38247: LD_VAR 0 3
38251: PPUSH
38252: CALL_OW 255
38256: ST_TO_ADDR
// if not mc_tech [ side ] then
38257: LD_EXP 122
38261: PUSH
38262: LD_VAR 0 4
38266: ARRAY
38267: NOT
38268: IFFALSE 38272
// continue ;
38270: GO 38231
// if BuildingStatus ( j ) = bs_idle then
38272: LD_VAR 0 3
38276: PPUSH
38277: CALL_OW 461
38281: PUSH
38282: LD_INT 2
38284: EQUAL
38285: IFFALSE 38473
// begin if idle_lab and UnitsInside ( j ) < 6 then
38287: LD_VAR 0 11
38291: PUSH
38292: LD_VAR 0 3
38296: PPUSH
38297: CALL_OW 313
38301: PUSH
38302: LD_INT 6
38304: LESS
38305: AND
38306: IFFALSE 38377
// begin tmp2 := UnitsInside ( idle_lab ) ;
38308: LD_ADDR_VAR 0 9
38312: PUSH
38313: LD_VAR 0 11
38317: PPUSH
38318: CALL_OW 313
38322: ST_TO_ADDR
// if tmp2 then
38323: LD_VAR 0 9
38327: IFFALSE 38369
// for x in tmp2 do
38329: LD_ADDR_VAR 0 7
38333: PUSH
38334: LD_VAR 0 9
38338: PUSH
38339: FOR_IN
38340: IFFALSE 38367
// begin ComExitBuilding ( x ) ;
38342: LD_VAR 0 7
38346: PPUSH
38347: CALL_OW 122
// AddComEnterUnit ( x , j ) ;
38351: LD_VAR 0 7
38355: PPUSH
38356: LD_VAR 0 3
38360: PPUSH
38361: CALL_OW 180
// end ;
38365: GO 38339
38367: POP
38368: POP
// idle_lab := 0 ;
38369: LD_ADDR_VAR 0 11
38373: PUSH
38374: LD_INT 0
38376: ST_TO_ADDR
// end ; for t in mc_tech [ side ] do
38377: LD_ADDR_VAR 0 5
38381: PUSH
38382: LD_EXP 122
38386: PUSH
38387: LD_VAR 0 4
38391: ARRAY
38392: PUSH
38393: FOR_IN
38394: IFFALSE 38454
// if CanBeResearched ( j , t ) and TechCanBeResearch ( side , t ) then
38396: LD_VAR 0 3
38400: PPUSH
38401: LD_VAR 0 5
38405: PPUSH
38406: CALL_OW 430
38410: PUSH
38411: LD_VAR 0 4
38415: PPUSH
38416: LD_VAR 0 5
38420: PPUSH
38421: CALL 52887 0 2
38425: AND
38426: IFFALSE 38452
// begin researching := true ;
38428: LD_ADDR_VAR 0 10
38432: PUSH
38433: LD_INT 1
38435: ST_TO_ADDR
// ComResearch ( j , t ) ;
38436: LD_VAR 0 3
38440: PPUSH
38441: LD_VAR 0 5
38445: PPUSH
38446: CALL_OW 124
// break ;
38450: GO 38454
// end ;
38452: GO 38393
38454: POP
38455: POP
// if not researching then
38456: LD_VAR 0 10
38460: NOT
38461: IFFALSE 38473
// idle_lab := j ;
38463: LD_ADDR_VAR 0 11
38467: PUSH
38468: LD_VAR 0 3
38472: ST_TO_ADDR
// end ; if BuildingStatus ( j ) = bs_need_ape then
38473: LD_VAR 0 3
38477: PPUSH
38478: CALL_OW 461
38482: PUSH
38483: LD_INT 10
38485: EQUAL
38486: IFFALSE 39074
// begin if not mc_ape [ i ] and not mc_ape_in_lab [ i ] and mc_tech [ side ] > 1 then
38488: LD_EXP 124
38492: PUSH
38493: LD_VAR 0 2
38497: ARRAY
38498: NOT
38499: PUSH
38500: LD_EXP 125
38504: PUSH
38505: LD_VAR 0 2
38509: ARRAY
38510: NOT
38511: AND
38512: PUSH
38513: LD_EXP 122
38517: PUSH
38518: LD_VAR 0 4
38522: ARRAY
38523: PUSH
38524: LD_INT 1
38526: GREATER
38527: AND
38528: IFFALSE 38659
// begin ComCancel ( j ) ;
38530: LD_VAR 0 3
38534: PPUSH
38535: CALL_OW 127
// mc_tech := Replace ( mc_tech , side , Reindex ( mc_tech [ side ] , mc_tech [ side ] - 1 , mc_tech [ side ] , false ) ) ;
38539: LD_ADDR_EXP 122
38543: PUSH
38544: LD_EXP 122
38548: PPUSH
38549: LD_VAR 0 4
38553: PPUSH
38554: LD_EXP 122
38558: PUSH
38559: LD_VAR 0 4
38563: ARRAY
38564: PPUSH
38565: LD_EXP 122
38569: PUSH
38570: LD_VAR 0 4
38574: ARRAY
38575: PUSH
38576: LD_INT 1
38578: MINUS
38579: PPUSH
38580: LD_EXP 122
38584: PUSH
38585: LD_VAR 0 4
38589: ARRAY
38590: PPUSH
38591: LD_INT 0
38593: PPUSH
38594: CALL 56435 0 4
38598: PPUSH
38599: CALL_OW 1
38603: ST_TO_ADDR
// mc_tech := Replace ( mc_tech , side , Reindex ( mc_tech [ side ] , mc_tech [ side ] , 1 , false ) ) ;
38604: LD_ADDR_EXP 122
38608: PUSH
38609: LD_EXP 122
38613: PPUSH
38614: LD_VAR 0 4
38618: PPUSH
38619: LD_EXP 122
38623: PUSH
38624: LD_VAR 0 4
38628: ARRAY
38629: PPUSH
38630: LD_EXP 122
38634: PUSH
38635: LD_VAR 0 4
38639: ARRAY
38640: PPUSH
38641: LD_INT 1
38643: PPUSH
38644: LD_INT 0
38646: PPUSH
38647: CALL 56435 0 4
38651: PPUSH
38652: CALL_OW 1
38656: ST_TO_ADDR
// continue ;
38657: GO 38231
// end ; if mc_ape [ i ] and not mc_ape_in_lab [ i ] then
38659: LD_EXP 124
38663: PUSH
38664: LD_VAR 0 2
38668: ARRAY
38669: PUSH
38670: LD_EXP 125
38674: PUSH
38675: LD_VAR 0 2
38679: ARRAY
38680: NOT
38681: AND
38682: IFFALSE 38809
// begin mc_ape_in_lab := ReplaceIn ( mc_ape_in_lab , [ i , mc_ape_in_lab [ i ] + 1 ] , mc_ape [ i ] [ 1 ] ) ;
38684: LD_ADDR_EXP 125
38688: PUSH
38689: LD_EXP 125
38693: PPUSH
38694: LD_VAR 0 2
38698: PUSH
38699: LD_EXP 125
38703: PUSH
38704: LD_VAR 0 2
38708: ARRAY
38709: PUSH
38710: LD_INT 1
38712: PLUS
38713: PUSH
38714: EMPTY
38715: LIST
38716: LIST
38717: PPUSH
38718: LD_EXP 124
38722: PUSH
38723: LD_VAR 0 2
38727: ARRAY
38728: PUSH
38729: LD_INT 1
38731: ARRAY
38732: PPUSH
38733: CALL 57017 0 3
38737: ST_TO_ADDR
// SetTag ( mc_ape [ i ] [ 1 ] , 112 ) ;
38738: LD_EXP 124
38742: PUSH
38743: LD_VAR 0 2
38747: ARRAY
38748: PUSH
38749: LD_INT 1
38751: ARRAY
38752: PPUSH
38753: LD_INT 112
38755: PPUSH
38756: CALL_OW 109
// tmp2 := Delete ( mc_ape [ i ] , 1 ) ;
38760: LD_ADDR_VAR 0 9
38764: PUSH
38765: LD_EXP 124
38769: PUSH
38770: LD_VAR 0 2
38774: ARRAY
38775: PPUSH
38776: LD_INT 1
38778: PPUSH
38779: CALL_OW 3
38783: ST_TO_ADDR
// mc_ape := Replace ( mc_ape , i , tmp2 ) ;
38784: LD_ADDR_EXP 124
38788: PUSH
38789: LD_EXP 124
38793: PPUSH
38794: LD_VAR 0 2
38798: PPUSH
38799: LD_VAR 0 9
38803: PPUSH
38804: CALL_OW 1
38808: ST_TO_ADDR
// end ; if mc_ape [ i ] and mc_ape_in_lab [ i ] and not IsInUnit ( mc_ape_in_lab [ i ] [ 1 ] ) and UnitsInside ( j ) = 6 then
38809: LD_EXP 124
38813: PUSH
38814: LD_VAR 0 2
38818: ARRAY
38819: PUSH
38820: LD_EXP 125
38824: PUSH
38825: LD_VAR 0 2
38829: ARRAY
38830: AND
38831: PUSH
38832: LD_EXP 125
38836: PUSH
38837: LD_VAR 0 2
38841: ARRAY
38842: PUSH
38843: LD_INT 1
38845: ARRAY
38846: PPUSH
38847: CALL_OW 310
38851: NOT
38852: AND
38853: PUSH
38854: LD_VAR 0 3
38858: PPUSH
38859: CALL_OW 313
38863: PUSH
38864: LD_INT 6
38866: EQUAL
38867: AND
38868: IFFALSE 38924
// begin tmp2 := UnitsInside ( j ) ;
38870: LD_ADDR_VAR 0 9
38874: PUSH
38875: LD_VAR 0 3
38879: PPUSH
38880: CALL_OW 313
38884: ST_TO_ADDR
// if tmp2 = 6 then
38885: LD_VAR 0 9
38889: PUSH
38890: LD_INT 6
38892: EQUAL
38893: IFFALSE 38924
// begin SetTag ( tmp2 [ 1 ] , 112 ) ;
38895: LD_VAR 0 9
38899: PUSH
38900: LD_INT 1
38902: ARRAY
38903: PPUSH
38904: LD_INT 112
38906: PPUSH
38907: CALL_OW 109
// ComExitBuilding ( tmp2 [ 1 ] ) ;
38911: LD_VAR 0 9
38915: PUSH
38916: LD_INT 1
38918: ARRAY
38919: PPUSH
38920: CALL_OW 122
// end ; end ; if mc_ape_in_lab [ i ] and not HasTask ( mc_ape_in_lab [ i ] [ 1 ] ) and not IsInUnit ( mc_ape_in_lab [ i ] [ 1 ] ) then
38924: LD_EXP 125
38928: PUSH
38929: LD_VAR 0 2
38933: ARRAY
38934: PUSH
38935: LD_EXP 125
38939: PUSH
38940: LD_VAR 0 2
38944: ARRAY
38945: PUSH
38946: LD_INT 1
38948: ARRAY
38949: PPUSH
38950: CALL_OW 314
38954: NOT
38955: AND
38956: PUSH
38957: LD_EXP 125
38961: PUSH
38962: LD_VAR 0 2
38966: ARRAY
38967: PUSH
38968: LD_INT 1
38970: ARRAY
38971: PPUSH
38972: CALL_OW 310
38976: NOT
38977: AND
38978: IFFALSE 39004
// ComEnterUnit ( mc_ape_in_lab [ i ] [ 1 ] , j ) ;
38980: LD_EXP 125
38984: PUSH
38985: LD_VAR 0 2
38989: ARRAY
38990: PUSH
38991: LD_INT 1
38993: ARRAY
38994: PPUSH
38995: LD_VAR 0 3
38999: PPUSH
39000: CALL_OW 120
// if IsInUnit ( mc_ape_in_lab [ i ] [ 1 ] ) and BuildingStatus ( IsInUnit ( mc_ape_in_lab [ i ] [ 1 ] ) ) <> bs_working then
39004: LD_EXP 125
39008: PUSH
39009: LD_VAR 0 2
39013: ARRAY
39014: PUSH
39015: LD_INT 1
39017: ARRAY
39018: PPUSH
39019: CALL_OW 310
39023: PUSH
39024: LD_EXP 125
39028: PUSH
39029: LD_VAR 0 2
39033: ARRAY
39034: PUSH
39035: LD_INT 1
39037: ARRAY
39038: PPUSH
39039: CALL_OW 310
39043: PPUSH
39044: CALL_OW 461
39048: PUSH
39049: LD_INT 3
39051: NONEQUAL
39052: AND
39053: IFFALSE 39074
// ComExitBuilding ( mc_ape_in_lab [ i ] [ 1 ] ) ;
39055: LD_EXP 125
39059: PUSH
39060: LD_VAR 0 2
39064: ARRAY
39065: PUSH
39066: LD_INT 1
39068: ARRAY
39069: PPUSH
39070: CALL_OW 122
// end ; if BuildingStatus ( j ) = bs_need_people and tmp > 1 then
39074: LD_VAR 0 3
39078: PPUSH
39079: CALL_OW 461
39083: PUSH
39084: LD_INT 6
39086: EQUAL
39087: PUSH
39088: LD_VAR 0 6
39092: PUSH
39093: LD_INT 1
39095: GREATER
39096: AND
39097: IFFALSE 39249
// begin sci := [ ] ;
39099: LD_ADDR_VAR 0 8
39103: PUSH
39104: EMPTY
39105: ST_TO_ADDR
// for x in ( tmp diff j ) do
39106: LD_ADDR_VAR 0 7
39110: PUSH
39111: LD_VAR 0 6
39115: PUSH
39116: LD_VAR 0 3
39120: DIFF
39121: PUSH
39122: FOR_IN
39123: IFFALSE 39175
// begin if sci = 6 then
39125: LD_VAR 0 8
39129: PUSH
39130: LD_INT 6
39132: EQUAL
39133: IFFALSE 39137
// break ;
39135: GO 39175
// if BuildingStatus ( x ) = bs_idle then
39137: LD_VAR 0 7
39141: PPUSH
39142: CALL_OW 461
39146: PUSH
39147: LD_INT 2
39149: EQUAL
39150: IFFALSE 39173
// sci := sci ^ UnitsInside ( x ) ;
39152: LD_ADDR_VAR 0 8
39156: PUSH
39157: LD_VAR 0 8
39161: PUSH
39162: LD_VAR 0 7
39166: PPUSH
39167: CALL_OW 313
39171: ADD
39172: ST_TO_ADDR
// end ;
39173: GO 39122
39175: POP
39176: POP
// if not sci then
39177: LD_VAR 0 8
39181: NOT
39182: IFFALSE 39186
// continue ;
39184: GO 38231
// for x in sci do
39186: LD_ADDR_VAR 0 7
39190: PUSH
39191: LD_VAR 0 8
39195: PUSH
39196: FOR_IN
39197: IFFALSE 39247
// if IsInUnit ( x ) and not HasTask ( x ) then
39199: LD_VAR 0 7
39203: PPUSH
39204: CALL_OW 310
39208: PUSH
39209: LD_VAR 0 7
39213: PPUSH
39214: CALL_OW 314
39218: NOT
39219: AND
39220: IFFALSE 39245
// begin ComExitBuilding ( x ) ;
39222: LD_VAR 0 7
39226: PPUSH
39227: CALL_OW 122
// AddComEnterUnit ( x , j ) ;
39231: LD_VAR 0 7
39235: PPUSH
39236: LD_VAR 0 3
39240: PPUSH
39241: CALL_OW 180
// end ;
39245: GO 39196
39247: POP
39248: POP
// end ; end ;
39249: GO 38231
39251: POP
39252: POP
// end ;
39253: GO 38185
39255: POP
39256: POP
// end ;
39257: LD_VAR 0 1
39261: RET
// export function MC_MinesTrigger ( ) ; var i ; begin
39262: LD_INT 0
39264: PPUSH
39265: PPUSH
// if not mc_bases then
39266: LD_EXP 95
39270: NOT
39271: IFFALSE 39275
// exit ;
39273: GO 39356
// for i = 1 to mc_bases do
39275: LD_ADDR_VAR 0 2
39279: PUSH
39280: DOUBLE
39281: LD_INT 1
39283: DEC
39284: ST_TO_ADDR
39285: LD_EXP 95
39289: PUSH
39290: FOR_TO
39291: IFFALSE 39354
// if mc_mines [ i ] and mc_miners [ i ] then
39293: LD_EXP 108
39297: PUSH
39298: LD_VAR 0 2
39302: ARRAY
39303: PUSH
39304: LD_EXP 109
39308: PUSH
39309: LD_VAR 0 2
39313: ARRAY
39314: AND
39315: IFFALSE 39352
// DetonateMines ( GetSide ( mc_miners [ i ] [ 1 ] ) , mc_mines [ i ] ) ;
39317: LD_EXP 109
39321: PUSH
39322: LD_VAR 0 2
39326: ARRAY
39327: PUSH
39328: LD_INT 1
39330: ARRAY
39331: PPUSH
39332: CALL_OW 255
39336: PPUSH
39337: LD_EXP 108
39341: PUSH
39342: LD_VAR 0 2
39346: ARRAY
39347: PPUSH
39348: CALL 53970 0 2
39352: GO 39290
39354: POP
39355: POP
// end ;
39356: LD_VAR 0 1
39360: RET
// export function MC_RepairVehicle ( ) ; var i , j , k , side , fac , vehs , tmp ; begin
39361: LD_INT 0
39363: PPUSH
39364: PPUSH
39365: PPUSH
39366: PPUSH
39367: PPUSH
39368: PPUSH
39369: PPUSH
39370: PPUSH
// if not mc_bases or not mc_parking then
39371: LD_EXP 95
39375: NOT
39376: PUSH
39377: LD_EXP 119
39381: NOT
39382: OR
39383: IFFALSE 39387
// exit ;
39385: GO 40097
// for i = 1 to mc_bases do
39387: LD_ADDR_VAR 0 2
39391: PUSH
39392: DOUBLE
39393: LD_INT 1
39395: DEC
39396: ST_TO_ADDR
39397: LD_EXP 95
39401: PUSH
39402: FOR_TO
39403: IFFALSE 40095
// begin if not mc_bases [ i ] or not mc_parking [ i ] then
39405: LD_EXP 95
39409: PUSH
39410: LD_VAR 0 2
39414: ARRAY
39415: NOT
39416: PUSH
39417: LD_EXP 119
39421: PUSH
39422: LD_VAR 0 2
39426: ARRAY
39427: NOT
39428: OR
39429: IFFALSE 39433
// continue ;
39431: GO 39402
// side := GetSide ( mc_bases [ i ] [ 1 ] ) ;
39433: LD_ADDR_VAR 0 5
39437: PUSH
39438: LD_EXP 95
39442: PUSH
39443: LD_VAR 0 2
39447: ARRAY
39448: PUSH
39449: LD_INT 1
39451: ARRAY
39452: PPUSH
39453: CALL_OW 255
39457: ST_TO_ADDR
// fac := UnitFilter ( mc_bases [ i ] , [ f_btype , b_factory ] ) ;
39458: LD_ADDR_VAR 0 6
39462: PUSH
39463: LD_EXP 95
39467: PUSH
39468: LD_VAR 0 2
39472: ARRAY
39473: PPUSH
39474: LD_INT 30
39476: PUSH
39477: LD_INT 3
39479: PUSH
39480: EMPTY
39481: LIST
39482: LIST
39483: PPUSH
39484: CALL_OW 72
39488: ST_TO_ADDR
// if not fac then
39489: LD_VAR 0 6
39493: NOT
39494: IFFALSE 39545
// fac := UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) ;
39496: LD_ADDR_VAR 0 6
39500: PUSH
39501: LD_EXP 95
39505: PUSH
39506: LD_VAR 0 2
39510: ARRAY
39511: PPUSH
39512: LD_INT 2
39514: PUSH
39515: LD_INT 30
39517: PUSH
39518: LD_INT 0
39520: PUSH
39521: EMPTY
39522: LIST
39523: LIST
39524: PUSH
39525: LD_INT 30
39527: PUSH
39528: LD_INT 1
39530: PUSH
39531: EMPTY
39532: LIST
39533: LIST
39534: PUSH
39535: EMPTY
39536: LIST
39537: LIST
39538: LIST
39539: PPUSH
39540: CALL_OW 72
39544: ST_TO_ADDR
// if not fac then
39545: LD_VAR 0 6
39549: NOT
39550: IFFALSE 39554
// continue ;
39552: GO 39402
// vehs := FilterUnitsInArea ( mc_parking [ i ] , [ [ f_side , side ] , [ f_type , unit_vehicle ] , [ f_not , [ f_lives , 1000 ] ] ] ) ;
39554: LD_ADDR_VAR 0 7
39558: PUSH
39559: LD_EXP 119
39563: PUSH
39564: LD_VAR 0 2
39568: ARRAY
39569: PPUSH
39570: LD_INT 22
39572: PUSH
39573: LD_VAR 0 5
39577: PUSH
39578: EMPTY
39579: LIST
39580: LIST
39581: PUSH
39582: LD_INT 21
39584: PUSH
39585: LD_INT 2
39587: PUSH
39588: EMPTY
39589: LIST
39590: LIST
39591: PUSH
39592: LD_INT 3
39594: PUSH
39595: LD_INT 24
39597: PUSH
39598: LD_INT 1000
39600: PUSH
39601: EMPTY
39602: LIST
39603: LIST
39604: PUSH
39605: EMPTY
39606: LIST
39607: LIST
39608: PUSH
39609: EMPTY
39610: LIST
39611: LIST
39612: LIST
39613: PPUSH
39614: CALL_OW 70
39618: ST_TO_ADDR
// for j in fac do
39619: LD_ADDR_VAR 0 3
39623: PUSH
39624: LD_VAR 0 6
39628: PUSH
39629: FOR_IN
39630: IFFALSE 39711
// vehs := vehs union FilterAllUnits ( [ [ f_side , side ] , [ f_dist , j , 15 ] , [ f_type , unit_vehicle ] , [ f_not , [ f_lives , 1000 ] ] ] ) ;
39632: LD_ADDR_VAR 0 7
39636: PUSH
39637: LD_VAR 0 7
39641: PUSH
39642: LD_INT 22
39644: PUSH
39645: LD_VAR 0 5
39649: PUSH
39650: EMPTY
39651: LIST
39652: LIST
39653: PUSH
39654: LD_INT 91
39656: PUSH
39657: LD_VAR 0 3
39661: PUSH
39662: LD_INT 15
39664: PUSH
39665: EMPTY
39666: LIST
39667: LIST
39668: LIST
39669: PUSH
39670: LD_INT 21
39672: PUSH
39673: LD_INT 2
39675: PUSH
39676: EMPTY
39677: LIST
39678: LIST
39679: PUSH
39680: LD_INT 3
39682: PUSH
39683: LD_INT 24
39685: PUSH
39686: LD_INT 1000
39688: PUSH
39689: EMPTY
39690: LIST
39691: LIST
39692: PUSH
39693: EMPTY
39694: LIST
39695: LIST
39696: PUSH
39697: EMPTY
39698: LIST
39699: LIST
39700: LIST
39701: LIST
39702: PPUSH
39703: CALL_OW 69
39707: UNION
39708: ST_TO_ADDR
39709: GO 39629
39711: POP
39712: POP
// if not vehs then
39713: LD_VAR 0 7
39717: NOT
39718: IFFALSE 39744
// begin mc_repair_vehicle := Replace ( mc_repair_vehicle , i , [ ] ) ;
39720: LD_ADDR_EXP 107
39724: PUSH
39725: LD_EXP 107
39729: PPUSH
39730: LD_VAR 0 2
39734: PPUSH
39735: EMPTY
39736: PPUSH
39737: CALL_OW 1
39741: ST_TO_ADDR
// continue ;
39742: GO 39402
// end ; tmp := UnitFilter ( mc_bases [ i ] , [ f_btype , b_factory ] ) ;
39744: LD_ADDR_VAR 0 8
39748: PUSH
39749: LD_EXP 95
39753: PUSH
39754: LD_VAR 0 2
39758: ARRAY
39759: PPUSH
39760: LD_INT 30
39762: PUSH
39763: LD_INT 3
39765: PUSH
39766: EMPTY
39767: LIST
39768: LIST
39769: PPUSH
39770: CALL_OW 72
39774: ST_TO_ADDR
// if tmp then
39775: LD_VAR 0 8
39779: IFFALSE 39882
// begin for j in tmp do
39781: LD_ADDR_VAR 0 3
39785: PUSH
39786: LD_VAR 0 8
39790: PUSH
39791: FOR_IN
39792: IFFALSE 39880
// for k in UnitsInside ( j ) do
39794: LD_ADDR_VAR 0 4
39798: PUSH
39799: LD_VAR 0 3
39803: PPUSH
39804: CALL_OW 313
39808: PUSH
39809: FOR_IN
39810: IFFALSE 39876
// if k then
39812: LD_VAR 0 4
39816: IFFALSE 39874
// if not k in mc_repair_vehicle [ i ] then
39818: LD_VAR 0 4
39822: PUSH
39823: LD_EXP 107
39827: PUSH
39828: LD_VAR 0 2
39832: ARRAY
39833: IN
39834: NOT
39835: IFFALSE 39874
// mc_repair_vehicle := Replace ( mc_repair_vehicle , i , mc_repair_vehicle [ i ] union k ) ;
39837: LD_ADDR_EXP 107
39841: PUSH
39842: LD_EXP 107
39846: PPUSH
39847: LD_VAR 0 2
39851: PPUSH
39852: LD_EXP 107
39856: PUSH
39857: LD_VAR 0 2
39861: ARRAY
39862: PUSH
39863: LD_VAR 0 4
39867: UNION
39868: PPUSH
39869: CALL_OW 1
39873: ST_TO_ADDR
39874: GO 39809
39876: POP
39877: POP
39878: GO 39791
39880: POP
39881: POP
// end ; if not mc_repair_vehicle [ i ] then
39882: LD_EXP 107
39886: PUSH
39887: LD_VAR 0 2
39891: ARRAY
39892: NOT
39893: IFFALSE 39897
// continue ;
39895: GO 39402
// for j in mc_repair_vehicle [ i ] do
39897: LD_ADDR_VAR 0 3
39901: PUSH
39902: LD_EXP 107
39906: PUSH
39907: LD_VAR 0 2
39911: ARRAY
39912: PUSH
39913: FOR_IN
39914: IFFALSE 40091
// begin if GetClass ( j ) <> 3 then
39916: LD_VAR 0 3
39920: PPUSH
39921: CALL_OW 257
39925: PUSH
39926: LD_INT 3
39928: NONEQUAL
39929: IFFALSE 39970
// begin mc_repair_vehicle := Replace ( mc_repair_vehicle , i , mc_repair_vehicle [ i ] diff j ) ;
39931: LD_ADDR_EXP 107
39935: PUSH
39936: LD_EXP 107
39940: PPUSH
39941: LD_VAR 0 2
39945: PPUSH
39946: LD_EXP 107
39950: PUSH
39951: LD_VAR 0 2
39955: ARRAY
39956: PUSH
39957: LD_VAR 0 3
39961: DIFF
39962: PPUSH
39963: CALL_OW 1
39967: ST_TO_ADDR
// continue ;
39968: GO 39913
// end ; if not IsDrivenBy ( j ) and not j in mc_need_heal [ i ] [ 1 ] and not j in mc_need_heal [ i ] [ 2 ] then
39970: LD_VAR 0 3
39974: PPUSH
39975: CALL_OW 311
39979: NOT
39980: PUSH
39981: LD_VAR 0 3
39985: PUSH
39986: LD_EXP 98
39990: PUSH
39991: LD_VAR 0 2
39995: ARRAY
39996: PUSH
39997: LD_INT 1
39999: ARRAY
40000: IN
40001: NOT
40002: AND
40003: PUSH
40004: LD_VAR 0 3
40008: PUSH
40009: LD_EXP 98
40013: PUSH
40014: LD_VAR 0 2
40018: ARRAY
40019: PUSH
40020: LD_INT 2
40022: ARRAY
40023: IN
40024: NOT
40025: AND
40026: IFFALSE 40089
// begin if IsInUnit ( j ) then
40028: LD_VAR 0 3
40032: PPUSH
40033: CALL_OW 310
40037: IFFALSE 40050
// ComExitBuilding ( j ) else
40039: LD_VAR 0 3
40043: PPUSH
40044: CALL_OW 122
40048: GO 40089
// if not WantToRepairVehicle ( j , vehs [ 1 ] ) then
40050: LD_VAR 0 3
40054: PPUSH
40055: LD_VAR 0 7
40059: PUSH
40060: LD_INT 1
40062: ARRAY
40063: PPUSH
40064: CALL 90769 0 2
40068: NOT
40069: IFFALSE 40089
// ComRepairVehicle ( j , vehs [ 1 ] ) ;
40071: LD_VAR 0 3
40075: PPUSH
40076: LD_VAR 0 7
40080: PUSH
40081: LD_INT 1
40083: ARRAY
40084: PPUSH
40085: CALL_OW 129
// end ; end ;
40089: GO 39913
40091: POP
40092: POP
// end ;
40093: GO 39402
40095: POP
40096: POP
// end ;
40097: LD_VAR 0 1
40101: RET
// export function MC_TameApe ( ) ; var i , j , x , y , ape , apes , tmp , dep , danger_at_area , side ; begin
40102: LD_INT 0
40104: PPUSH
40105: PPUSH
40106: PPUSH
40107: PPUSH
40108: PPUSH
40109: PPUSH
40110: PPUSH
40111: PPUSH
40112: PPUSH
40113: PPUSH
40114: PPUSH
// if not mc_bases then
40115: LD_EXP 95
40119: NOT
40120: IFFALSE 40124
// exit ;
40122: GO 40926
// for i = 1 to mc_bases do
40124: LD_ADDR_VAR 0 2
40128: PUSH
40129: DOUBLE
40130: LD_INT 1
40132: DEC
40133: ST_TO_ADDR
40134: LD_EXP 95
40138: PUSH
40139: FOR_TO
40140: IFFALSE 40924
// begin if not mc_can_tame [ i ] or mc_need_heal [ i ] [ 1 ] or mc_need_heal [ i ] [ 2 ] or not Researched ( mc_sides [ i ] , tech_apelang ) or mc_scan [ i ] then
40142: LD_EXP 123
40146: PUSH
40147: LD_VAR 0 2
40151: ARRAY
40152: NOT
40153: PUSH
40154: LD_EXP 98
40158: PUSH
40159: LD_VAR 0 2
40163: ARRAY
40164: PUSH
40165: LD_INT 1
40167: ARRAY
40168: OR
40169: PUSH
40170: LD_EXP 98
40174: PUSH
40175: LD_VAR 0 2
40179: ARRAY
40180: PUSH
40181: LD_INT 2
40183: ARRAY
40184: OR
40185: PUSH
40186: LD_EXP 121
40190: PUSH
40191: LD_VAR 0 2
40195: ARRAY
40196: PPUSH
40197: LD_INT 1
40199: PPUSH
40200: CALL_OW 325
40204: NOT
40205: OR
40206: PUSH
40207: LD_EXP 118
40211: PUSH
40212: LD_VAR 0 2
40216: ARRAY
40217: OR
40218: IFFALSE 40222
// continue ;
40220: GO 40139
// tmp := UnitFilter ( mc_bases [ i ] , [ [ f_class , 4 ] , [ f_ok ] , [ f_not , [ f_hastask ] ] ] ) diff mc_healers [ i ] ;
40222: LD_ADDR_VAR 0 8
40226: PUSH
40227: LD_EXP 95
40231: PUSH
40232: LD_VAR 0 2
40236: ARRAY
40237: PPUSH
40238: LD_INT 25
40240: PUSH
40241: LD_INT 4
40243: PUSH
40244: EMPTY
40245: LIST
40246: LIST
40247: PUSH
40248: LD_INT 50
40250: PUSH
40251: EMPTY
40252: LIST
40253: PUSH
40254: LD_INT 3
40256: PUSH
40257: LD_INT 60
40259: PUSH
40260: EMPTY
40261: LIST
40262: PUSH
40263: EMPTY
40264: LIST
40265: LIST
40266: PUSH
40267: EMPTY
40268: LIST
40269: LIST
40270: LIST
40271: PPUSH
40272: CALL_OW 72
40276: PUSH
40277: LD_EXP 99
40281: PUSH
40282: LD_VAR 0 2
40286: ARRAY
40287: DIFF
40288: ST_TO_ADDR
// dep := UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) ;
40289: LD_ADDR_VAR 0 9
40293: PUSH
40294: LD_EXP 95
40298: PUSH
40299: LD_VAR 0 2
40303: ARRAY
40304: PPUSH
40305: LD_INT 2
40307: PUSH
40308: LD_INT 30
40310: PUSH
40311: LD_INT 0
40313: PUSH
40314: EMPTY
40315: LIST
40316: LIST
40317: PUSH
40318: LD_INT 30
40320: PUSH
40321: LD_INT 1
40323: PUSH
40324: EMPTY
40325: LIST
40326: LIST
40327: PUSH
40328: EMPTY
40329: LIST
40330: LIST
40331: LIST
40332: PPUSH
40333: CALL_OW 72
40337: ST_TO_ADDR
// if not tmp or not dep then
40338: LD_VAR 0 8
40342: NOT
40343: PUSH
40344: LD_VAR 0 9
40348: NOT
40349: OR
40350: IFFALSE 40354
// continue ;
40352: GO 40139
// side := GetSide ( tmp [ 1 ] ) ;
40354: LD_ADDR_VAR 0 11
40358: PUSH
40359: LD_VAR 0 8
40363: PUSH
40364: LD_INT 1
40366: ARRAY
40367: PPUSH
40368: CALL_OW 255
40372: ST_TO_ADDR
// dep := dep [ 1 ] ;
40373: LD_ADDR_VAR 0 9
40377: PUSH
40378: LD_VAR 0 9
40382: PUSH
40383: LD_INT 1
40385: ARRAY
40386: ST_TO_ADDR
// apes := FilterUnitsInArea ( mc_can_tame [ i ] , [ [ f_side , 0 ] , [ f_class , class_apeman ] ] ) union FilterAllUnits ( [ [ f_side , 0 ] , [ f_class , class_apeman ] , [ f_dist , dep , 20 ] ] ) ;
40387: LD_ADDR_VAR 0 7
40391: PUSH
40392: LD_EXP 123
40396: PUSH
40397: LD_VAR 0 2
40401: ARRAY
40402: PPUSH
40403: LD_INT 22
40405: PUSH
40406: LD_INT 0
40408: PUSH
40409: EMPTY
40410: LIST
40411: LIST
40412: PUSH
40413: LD_INT 25
40415: PUSH
40416: LD_INT 12
40418: PUSH
40419: EMPTY
40420: LIST
40421: LIST
40422: PUSH
40423: EMPTY
40424: LIST
40425: LIST
40426: PPUSH
40427: CALL_OW 70
40431: PUSH
40432: LD_INT 22
40434: PUSH
40435: LD_INT 0
40437: PUSH
40438: EMPTY
40439: LIST
40440: LIST
40441: PUSH
40442: LD_INT 25
40444: PUSH
40445: LD_INT 12
40447: PUSH
40448: EMPTY
40449: LIST
40450: LIST
40451: PUSH
40452: LD_INT 91
40454: PUSH
40455: LD_VAR 0 9
40459: PUSH
40460: LD_INT 20
40462: PUSH
40463: EMPTY
40464: LIST
40465: LIST
40466: LIST
40467: PUSH
40468: EMPTY
40469: LIST
40470: LIST
40471: LIST
40472: PPUSH
40473: CALL_OW 69
40477: UNION
40478: ST_TO_ADDR
// danger_at_area := FilterUnitsInArea ( mc_can_tame [ i ] , [ f_enemy , side ] ) ;
40479: LD_ADDR_VAR 0 10
40483: PUSH
40484: LD_EXP 123
40488: PUSH
40489: LD_VAR 0 2
40493: ARRAY
40494: PPUSH
40495: LD_INT 81
40497: PUSH
40498: LD_VAR 0 11
40502: PUSH
40503: EMPTY
40504: LIST
40505: LIST
40506: PPUSH
40507: CALL_OW 70
40511: ST_TO_ADDR
// if not apes or danger_at_area then
40512: LD_VAR 0 7
40516: NOT
40517: PUSH
40518: LD_VAR 0 10
40522: OR
40523: IFFALSE 40573
// begin if mc_taming [ i ] then
40525: LD_EXP 126
40529: PUSH
40530: LD_VAR 0 2
40534: ARRAY
40535: IFFALSE 40571
// begin MC_Reset ( i , 121 ) ;
40537: LD_VAR 0 2
40541: PPUSH
40542: LD_INT 121
40544: PPUSH
40545: CALL 25559 0 2
// mc_taming := Replace ( mc_taming , i , [ ] ) ;
40549: LD_ADDR_EXP 126
40553: PUSH
40554: LD_EXP 126
40558: PPUSH
40559: LD_VAR 0 2
40563: PPUSH
40564: EMPTY
40565: PPUSH
40566: CALL_OW 1
40570: ST_TO_ADDR
// end ; continue ;
40571: GO 40139
// end ; for j in tmp do
40573: LD_ADDR_VAR 0 3
40577: PUSH
40578: LD_VAR 0 8
40582: PUSH
40583: FOR_IN
40584: IFFALSE 40920
// begin if not j in mc_taming [ i ] and mc_taming [ i ] < 3 then
40586: LD_VAR 0 3
40590: PUSH
40591: LD_EXP 126
40595: PUSH
40596: LD_VAR 0 2
40600: ARRAY
40601: IN
40602: NOT
40603: PUSH
40604: LD_EXP 126
40608: PUSH
40609: LD_VAR 0 2
40613: ARRAY
40614: PUSH
40615: LD_INT 3
40617: LESS
40618: AND
40619: IFFALSE 40677
// begin SetTag ( j , 121 ) ;
40621: LD_VAR 0 3
40625: PPUSH
40626: LD_INT 121
40628: PPUSH
40629: CALL_OW 109
// mc_taming := ReplaceIn ( mc_taming , [ i , mc_taming [ i ] + 1 ] , j ) ;
40633: LD_ADDR_EXP 126
40637: PUSH
40638: LD_EXP 126
40642: PPUSH
40643: LD_VAR 0 2
40647: PUSH
40648: LD_EXP 126
40652: PUSH
40653: LD_VAR 0 2
40657: ARRAY
40658: PUSH
40659: LD_INT 1
40661: PLUS
40662: PUSH
40663: EMPTY
40664: LIST
40665: LIST
40666: PPUSH
40667: LD_VAR 0 3
40671: PPUSH
40672: CALL 57017 0 3
40676: ST_TO_ADDR
// end ; if j in mc_taming [ i ] then
40677: LD_VAR 0 3
40681: PUSH
40682: LD_EXP 126
40686: PUSH
40687: LD_VAR 0 2
40691: ARRAY
40692: IN
40693: IFFALSE 40918
// begin if GetClass ( j ) <> 4 then
40695: LD_VAR 0 3
40699: PPUSH
40700: CALL_OW 257
40704: PUSH
40705: LD_INT 4
40707: NONEQUAL
40708: IFFALSE 40761
// begin mc_taming := Replace ( mc_taming , i , mc_taming [ i ] diff j ) ;
40710: LD_ADDR_EXP 126
40714: PUSH
40715: LD_EXP 126
40719: PPUSH
40720: LD_VAR 0 2
40724: PPUSH
40725: LD_EXP 126
40729: PUSH
40730: LD_VAR 0 2
40734: ARRAY
40735: PUSH
40736: LD_VAR 0 3
40740: DIFF
40741: PPUSH
40742: CALL_OW 1
40746: ST_TO_ADDR
// SetTag ( j , 0 ) ;
40747: LD_VAR 0 3
40751: PPUSH
40752: LD_INT 0
40754: PPUSH
40755: CALL_OW 109
// continue ;
40759: GO 40583
// end ; if IsInUnit ( j ) then
40761: LD_VAR 0 3
40765: PPUSH
40766: CALL_OW 310
40770: IFFALSE 40781
// ComExitBuilding ( j ) ;
40772: LD_VAR 0 3
40776: PPUSH
40777: CALL_OW 122
// ape := NearestUnitToUnit ( apes , j ) ;
40781: LD_ADDR_VAR 0 6
40785: PUSH
40786: LD_VAR 0 7
40790: PPUSH
40791: LD_VAR 0 3
40795: PPUSH
40796: CALL_OW 74
40800: ST_TO_ADDR
// if not ape then
40801: LD_VAR 0 6
40805: NOT
40806: IFFALSE 40810
// break ;
40808: GO 40920
// x := GetX ( ape ) ;
40810: LD_ADDR_VAR 0 4
40814: PUSH
40815: LD_VAR 0 6
40819: PPUSH
40820: CALL_OW 250
40824: ST_TO_ADDR
// y := GetY ( ape ) ;
40825: LD_ADDR_VAR 0 5
40829: PUSH
40830: LD_VAR 0 6
40834: PPUSH
40835: CALL_OW 251
40839: ST_TO_ADDR
// if not ValidHex ( x , y ) or DangerAtRangeXY ( side , x , y , 20 ) [ 4 ] then
40840: LD_VAR 0 4
40844: PPUSH
40845: LD_VAR 0 5
40849: PPUSH
40850: CALL_OW 488
40854: NOT
40855: PUSH
40856: LD_VAR 0 11
40860: PPUSH
40861: LD_VAR 0 4
40865: PPUSH
40866: LD_VAR 0 5
40870: PPUSH
40871: LD_INT 20
40873: PPUSH
40874: CALL 57913 0 4
40878: PUSH
40879: LD_INT 4
40881: ARRAY
40882: OR
40883: IFFALSE 40887
// break ;
40885: GO 40920
// if not HasTask ( j ) then
40887: LD_VAR 0 3
40891: PPUSH
40892: CALL_OW 314
40896: NOT
40897: IFFALSE 40918
// ComTameXY ( j , x , y ) ;
40899: LD_VAR 0 3
40903: PPUSH
40904: LD_VAR 0 4
40908: PPUSH
40909: LD_VAR 0 5
40913: PPUSH
40914: CALL_OW 131
// end ; end ;
40918: GO 40583
40920: POP
40921: POP
// end ;
40922: GO 40139
40924: POP
40925: POP
// end ;
40926: LD_VAR 0 1
40930: RET
// export function MC_ChangeApeClass ( ) ; var i , j , tmp , side , depot , selected , barracks ; begin
40931: LD_INT 0
40933: PPUSH
40934: PPUSH
40935: PPUSH
40936: PPUSH
40937: PPUSH
40938: PPUSH
40939: PPUSH
40940: PPUSH
// if not mc_bases then
40941: LD_EXP 95
40945: NOT
40946: IFFALSE 40950
// exit ;
40948: GO 41576
// for i = 1 to mc_bases do
40950: LD_ADDR_VAR 0 2
40954: PUSH
40955: DOUBLE
40956: LD_INT 1
40958: DEC
40959: ST_TO_ADDR
40960: LD_EXP 95
40964: PUSH
40965: FOR_TO
40966: IFFALSE 41574
// begin if not mc_ape [ i ] or not UnitFilter ( mc_ape [ i ] , [ f_class , 12 ] ) then
40968: LD_EXP 124
40972: PUSH
40973: LD_VAR 0 2
40977: ARRAY
40978: NOT
40979: PUSH
40980: LD_EXP 124
40984: PUSH
40985: LD_VAR 0 2
40989: ARRAY
40990: PPUSH
40991: LD_INT 25
40993: PUSH
40994: LD_INT 12
40996: PUSH
40997: EMPTY
40998: LIST
40999: LIST
41000: PPUSH
41001: CALL_OW 72
41005: NOT
41006: OR
41007: IFFALSE 41011
// continue ;
41009: GO 40965
// side := GetSide ( mc_ape [ i ] [ 1 ] ) ;
41011: LD_ADDR_VAR 0 5
41015: PUSH
41016: LD_EXP 124
41020: PUSH
41021: LD_VAR 0 2
41025: ARRAY
41026: PUSH
41027: LD_INT 1
41029: ARRAY
41030: PPUSH
41031: CALL_OW 255
41035: ST_TO_ADDR
// if Researched ( side , tech_apepsych ) then
41036: LD_VAR 0 5
41040: PPUSH
41041: LD_INT 2
41043: PPUSH
41044: CALL_OW 325
41048: IFFALSE 41301
// begin tmp := UnitFilter ( mc_ape [ i ] , [ f_class , 16 ] ) ;
41050: LD_ADDR_VAR 0 4
41054: PUSH
41055: LD_EXP 124
41059: PUSH
41060: LD_VAR 0 2
41064: ARRAY
41065: PPUSH
41066: LD_INT 25
41068: PUSH
41069: LD_INT 16
41071: PUSH
41072: EMPTY
41073: LIST
41074: LIST
41075: PPUSH
41076: CALL_OW 72
41080: ST_TO_ADDR
// if tmp < 6 then
41081: LD_VAR 0 4
41085: PUSH
41086: LD_INT 6
41088: LESS
41089: IFFALSE 41301
// begin depot := UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) ;
41091: LD_ADDR_VAR 0 6
41095: PUSH
41096: LD_EXP 95
41100: PUSH
41101: LD_VAR 0 2
41105: ARRAY
41106: PPUSH
41107: LD_INT 2
41109: PUSH
41110: LD_INT 30
41112: PUSH
41113: LD_INT 0
41115: PUSH
41116: EMPTY
41117: LIST
41118: LIST
41119: PUSH
41120: LD_INT 30
41122: PUSH
41123: LD_INT 1
41125: PUSH
41126: EMPTY
41127: LIST
41128: LIST
41129: PUSH
41130: EMPTY
41131: LIST
41132: LIST
41133: LIST
41134: PPUSH
41135: CALL_OW 72
41139: ST_TO_ADDR
// if depot then
41140: LD_VAR 0 6
41144: IFFALSE 41301
// begin selected := 0 ;
41146: LD_ADDR_VAR 0 7
41150: PUSH
41151: LD_INT 0
41153: ST_TO_ADDR
// for j in depot do
41154: LD_ADDR_VAR 0 3
41158: PUSH
41159: LD_VAR 0 6
41163: PUSH
41164: FOR_IN
41165: IFFALSE 41196
// begin if UnitsInside ( j ) < 6 then
41167: LD_VAR 0 3
41171: PPUSH
41172: CALL_OW 313
41176: PUSH
41177: LD_INT 6
41179: LESS
41180: IFFALSE 41194
// begin selected := j ;
41182: LD_ADDR_VAR 0 7
41186: PUSH
41187: LD_VAR 0 3
41191: ST_TO_ADDR
// break ;
41192: GO 41196
// end ; end ;
41194: GO 41164
41196: POP
41197: POP
// if selected then
41198: LD_VAR 0 7
41202: IFFALSE 41301
// begin for j in UnitFilter ( mc_ape [ i ] , [ f_class , 12 ] ) do
41204: LD_ADDR_VAR 0 3
41208: PUSH
41209: LD_EXP 124
41213: PUSH
41214: LD_VAR 0 2
41218: ARRAY
41219: PPUSH
41220: LD_INT 25
41222: PUSH
41223: LD_INT 12
41225: PUSH
41226: EMPTY
41227: LIST
41228: LIST
41229: PPUSH
41230: CALL_OW 72
41234: PUSH
41235: FOR_IN
41236: IFFALSE 41299
// if not HasTask ( j ) then
41238: LD_VAR 0 3
41242: PPUSH
41243: CALL_OW 314
41247: NOT
41248: IFFALSE 41297
// begin if not IsInUnit ( j ) then
41250: LD_VAR 0 3
41254: PPUSH
41255: CALL_OW 310
41259: NOT
41260: IFFALSE 41276
// ComEnterUnit ( j , selected ) ;
41262: LD_VAR 0 3
41266: PPUSH
41267: LD_VAR 0 7
41271: PPUSH
41272: CALL_OW 120
// AddComChangeProfession ( j , 16 ) ;
41276: LD_VAR 0 3
41280: PPUSH
41281: LD_INT 16
41283: PPUSH
41284: CALL_OW 183
// AddComExitBuilding ( j ) ;
41288: LD_VAR 0 3
41292: PPUSH
41293: CALL_OW 182
// end ;
41297: GO 41235
41299: POP
41300: POP
// end ; end ; end ; end ; if Researched ( side , tech_apeagres ) then
41301: LD_VAR 0 5
41305: PPUSH
41306: LD_INT 11
41308: PPUSH
41309: CALL_OW 325
41313: IFFALSE 41572
// begin tmp := UnitFilter ( mc_ape [ i ] , [ f_class , 16 ] ) ;
41315: LD_ADDR_VAR 0 4
41319: PUSH
41320: LD_EXP 124
41324: PUSH
41325: LD_VAR 0 2
41329: ARRAY
41330: PPUSH
41331: LD_INT 25
41333: PUSH
41334: LD_INT 16
41336: PUSH
41337: EMPTY
41338: LIST
41339: LIST
41340: PPUSH
41341: CALL_OW 72
41345: ST_TO_ADDR
// if tmp >= 6 or not Researched ( side , tech_apepsych ) then
41346: LD_VAR 0 4
41350: PUSH
41351: LD_INT 6
41353: GREATEREQUAL
41354: PUSH
41355: LD_VAR 0 5
41359: PPUSH
41360: LD_INT 2
41362: PPUSH
41363: CALL_OW 325
41367: NOT
41368: OR
41369: IFFALSE 41572
// begin barracks := UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_armoury ] , [ f_btype , b_barracks ] ] ) ;
41371: LD_ADDR_VAR 0 8
41375: PUSH
41376: LD_EXP 95
41380: PUSH
41381: LD_VAR 0 2
41385: ARRAY
41386: PPUSH
41387: LD_INT 2
41389: PUSH
41390: LD_INT 30
41392: PUSH
41393: LD_INT 4
41395: PUSH
41396: EMPTY
41397: LIST
41398: LIST
41399: PUSH
41400: LD_INT 30
41402: PUSH
41403: LD_INT 5
41405: PUSH
41406: EMPTY
41407: LIST
41408: LIST
41409: PUSH
41410: EMPTY
41411: LIST
41412: LIST
41413: LIST
41414: PPUSH
41415: CALL_OW 72
41419: ST_TO_ADDR
// if barracks then
41420: LD_VAR 0 8
41424: IFFALSE 41572
// begin selected := 0 ;
41426: LD_ADDR_VAR 0 7
41430: PUSH
41431: LD_INT 0
41433: ST_TO_ADDR
// for j in barracks do
41434: LD_ADDR_VAR 0 3
41438: PUSH
41439: LD_VAR 0 8
41443: PUSH
41444: FOR_IN
41445: IFFALSE 41476
// begin if UnitsInside ( j ) < 6 then
41447: LD_VAR 0 3
41451: PPUSH
41452: CALL_OW 313
41456: PUSH
41457: LD_INT 6
41459: LESS
41460: IFFALSE 41474
// begin selected := j ;
41462: LD_ADDR_VAR 0 7
41466: PUSH
41467: LD_VAR 0 3
41471: ST_TO_ADDR
// break ;
41472: GO 41476
// end ; end ;
41474: GO 41444
41476: POP
41477: POP
// if selected then
41478: LD_VAR 0 7
41482: IFFALSE 41572
// begin for j in UnitFilter ( mc_ape [ i ] , [ f_class , 12 ] ) do
41484: LD_ADDR_VAR 0 3
41488: PUSH
41489: LD_EXP 124
41493: PUSH
41494: LD_VAR 0 2
41498: ARRAY
41499: PPUSH
41500: LD_INT 25
41502: PUSH
41503: LD_INT 12
41505: PUSH
41506: EMPTY
41507: LIST
41508: LIST
41509: PPUSH
41510: CALL_OW 72
41514: PUSH
41515: FOR_IN
41516: IFFALSE 41570
// if not IsInUnit ( j ) and not HasTask ( j ) then
41518: LD_VAR 0 3
41522: PPUSH
41523: CALL_OW 310
41527: NOT
41528: PUSH
41529: LD_VAR 0 3
41533: PPUSH
41534: CALL_OW 314
41538: NOT
41539: AND
41540: IFFALSE 41568
// begin ComEnterUnit ( j , selected ) ;
41542: LD_VAR 0 3
41546: PPUSH
41547: LD_VAR 0 7
41551: PPUSH
41552: CALL_OW 120
// AddComChangeProfession ( j , 15 ) ;
41556: LD_VAR 0 3
41560: PPUSH
41561: LD_INT 15
41563: PPUSH
41564: CALL_OW 183
// end ;
41568: GO 41515
41570: POP
41571: POP
// end ; end ; end ; end ; end ;
41572: GO 40965
41574: POP
41575: POP
// end ;
41576: LD_VAR 0 1
41580: RET
// export function MC_Bazooka ( ) ; var i , j , tmp ; begin
41581: LD_INT 0
41583: PPUSH
41584: PPUSH
41585: PPUSH
41586: PPUSH
// if not mc_bases then
41587: LD_EXP 95
41591: NOT
41592: IFFALSE 41596
// exit ;
41594: GO 41774
// for i = 1 to mc_bases do
41596: LD_ADDR_VAR 0 2
41600: PUSH
41601: DOUBLE
41602: LD_INT 1
41604: DEC
41605: ST_TO_ADDR
41606: LD_EXP 95
41610: PUSH
41611: FOR_TO
41612: IFFALSE 41772
// begin tmp := UnitFilter ( mc_bases [ i ] , [ f_class , class_bazooker ] ) ;
41614: LD_ADDR_VAR 0 4
41618: PUSH
41619: LD_EXP 95
41623: PUSH
41624: LD_VAR 0 2
41628: ARRAY
41629: PPUSH
41630: LD_INT 25
41632: PUSH
41633: LD_INT 9
41635: PUSH
41636: EMPTY
41637: LIST
41638: LIST
41639: PPUSH
41640: CALL_OW 72
41644: ST_TO_ADDR
// if not tmp then
41645: LD_VAR 0 4
41649: NOT
41650: IFFALSE 41654
// continue ;
41652: GO 41611
// if not Researched ( mc_sides [ i ] , tech_spacanom ) and not Researched ( mc_sides [ i ] , tech_taurad ) then
41654: LD_EXP 121
41658: PUSH
41659: LD_VAR 0 2
41663: ARRAY
41664: PPUSH
41665: LD_INT 29
41667: PPUSH
41668: CALL_OW 325
41672: NOT
41673: PUSH
41674: LD_EXP 121
41678: PUSH
41679: LD_VAR 0 2
41683: ARRAY
41684: PPUSH
41685: LD_INT 28
41687: PPUSH
41688: CALL_OW 325
41692: NOT
41693: AND
41694: IFFALSE 41698
// continue ;
41696: GO 41611
// for j in tmp do
41698: LD_ADDR_VAR 0 3
41702: PUSH
41703: LD_VAR 0 4
41707: PUSH
41708: FOR_IN
41709: IFFALSE 41768
// if not j in mc_need_heal [ i ] [ 1 ] and not j in mc_need_heal [ i ] [ 2 ] then
41711: LD_VAR 0 3
41715: PUSH
41716: LD_EXP 98
41720: PUSH
41721: LD_VAR 0 2
41725: ARRAY
41726: PUSH
41727: LD_INT 1
41729: ARRAY
41730: IN
41731: NOT
41732: PUSH
41733: LD_VAR 0 3
41737: PUSH
41738: LD_EXP 98
41742: PUSH
41743: LD_VAR 0 2
41747: ARRAY
41748: PUSH
41749: LD_INT 2
41751: ARRAY
41752: IN
41753: NOT
41754: AND
41755: IFFALSE 41766
// ComSpaceTimeShoot ( j ) ;
41757: LD_VAR 0 3
41761: PPUSH
41762: CALL 52978 0 1
41766: GO 41708
41768: POP
41769: POP
// end ;
41770: GO 41611
41772: POP
41773: POP
// end ;
41774: LD_VAR 0 1
41778: RET
// export function MC_TeleportExit ( ) ; var i , j , x , y , save_point , tmp , teleports , sci ; begin
41779: LD_INT 0
41781: PPUSH
41782: PPUSH
41783: PPUSH
41784: PPUSH
41785: PPUSH
41786: PPUSH
41787: PPUSH
41788: PPUSH
41789: PPUSH
// if not mc_bases then
41790: LD_EXP 95
41794: NOT
41795: IFFALSE 41799
// exit ;
41797: GO 42421
// for i = 1 to mc_bases do
41799: LD_ADDR_VAR 0 2
41803: PUSH
41804: DOUBLE
41805: LD_INT 1
41807: DEC
41808: ST_TO_ADDR
41809: LD_EXP 95
41813: PUSH
41814: FOR_TO
41815: IFFALSE 42419
// begin if not mc_teleport_exit [ i ] or GetTech ( tech_targTeleport , mc_sides [ i ] ) <> state_researched then
41817: LD_EXP 130
41821: PUSH
41822: LD_VAR 0 2
41826: ARRAY
41827: NOT
41828: PUSH
41829: LD_INT 38
41831: PPUSH
41832: LD_EXP 121
41836: PUSH
41837: LD_VAR 0 2
41841: ARRAY
41842: PPUSH
41843: CALL_OW 321
41847: PUSH
41848: LD_INT 2
41850: NONEQUAL
41851: OR
41852: IFFALSE 41856
// continue ;
41854: GO 41814
// teleports := UnitFilter ( mc_bases [ i ] , [ f_btype , b_teleport ] ) ;
41856: LD_ADDR_VAR 0 8
41860: PUSH
41861: LD_EXP 95
41865: PUSH
41866: LD_VAR 0 2
41870: ARRAY
41871: PPUSH
41872: LD_INT 30
41874: PUSH
41875: LD_INT 34
41877: PUSH
41878: EMPTY
41879: LIST
41880: LIST
41881: PPUSH
41882: CALL_OW 72
41886: ST_TO_ADDR
// sci := FilterByTag ( UnitFilter ( mc_bases [ i ] , [ f_class , 4 ] ) , 0 ) ;
41887: LD_ADDR_VAR 0 9
41891: PUSH
41892: LD_EXP 95
41896: PUSH
41897: LD_VAR 0 2
41901: ARRAY
41902: PPUSH
41903: LD_INT 25
41905: PUSH
41906: LD_INT 4
41908: PUSH
41909: EMPTY
41910: LIST
41911: LIST
41912: PPUSH
41913: CALL_OW 72
41917: PPUSH
41918: LD_INT 0
41920: PPUSH
41921: CALL 86286 0 2
41925: ST_TO_ADDR
// if not sci or not teleports or FilterByTag ( mc_bases [ i ] , 124 ) then
41926: LD_VAR 0 9
41930: NOT
41931: PUSH
41932: LD_VAR 0 8
41936: NOT
41937: OR
41938: PUSH
41939: LD_EXP 95
41943: PUSH
41944: LD_VAR 0 2
41948: ARRAY
41949: PPUSH
41950: LD_INT 124
41952: PPUSH
41953: CALL 86286 0 2
41957: OR
41958: IFFALSE 41962
// continue ;
41960: GO 41814
// if mc_teleport_exit_set [ i ] < mc_teleport_exit [ i ] and mc_teleport_exit_set [ i ] < teleports then
41962: LD_EXP 131
41966: PUSH
41967: LD_VAR 0 2
41971: ARRAY
41972: PUSH
41973: LD_EXP 130
41977: PUSH
41978: LD_VAR 0 2
41982: ARRAY
41983: LESS
41984: PUSH
41985: LD_EXP 131
41989: PUSH
41990: LD_VAR 0 2
41994: ARRAY
41995: PUSH
41996: LD_VAR 0 8
42000: LESS
42001: AND
42002: IFFALSE 42417
// begin tmp := sci [ 1 ] ;
42004: LD_ADDR_VAR 0 7
42008: PUSH
42009: LD_VAR 0 9
42013: PUSH
42014: LD_INT 1
42016: ARRAY
42017: ST_TO_ADDR
// SetTag ( tmp , 124 ) ;
42018: LD_VAR 0 7
42022: PPUSH
42023: LD_INT 124
42025: PPUSH
42026: CALL_OW 109
// for j = mc_teleport_exit [ i ] downto mc_teleport_exit [ i ] do
42030: LD_ADDR_VAR 0 3
42034: PUSH
42035: DOUBLE
42036: LD_EXP 130
42040: PUSH
42041: LD_VAR 0 2
42045: ARRAY
42046: INC
42047: ST_TO_ADDR
42048: LD_EXP 130
42052: PUSH
42053: LD_VAR 0 2
42057: ARRAY
42058: PUSH
42059: FOR_DOWNTO
42060: IFFALSE 42403
// begin if IsInUnit ( tmp ) then
42062: LD_VAR 0 7
42066: PPUSH
42067: CALL_OW 310
42071: IFFALSE 42082
// ComExitBuilding ( tmp ) ;
42073: LD_VAR 0 7
42077: PPUSH
42078: CALL_OW 122
// repeat wait ( 0 0$1 ) ;
42082: LD_INT 35
42084: PPUSH
42085: CALL_OW 67
// until not IsInUnit ( tmp ) and not HasTask ( tmp ) ;
42089: LD_VAR 0 7
42093: PPUSH
42094: CALL_OW 310
42098: NOT
42099: PUSH
42100: LD_VAR 0 7
42104: PPUSH
42105: CALL_OW 314
42109: NOT
42110: AND
42111: IFFALSE 42082
// save_point := [ GetX ( tmp ) , GetY ( tmp ) ] ;
42113: LD_ADDR_VAR 0 6
42117: PUSH
42118: LD_VAR 0 7
42122: PPUSH
42123: CALL_OW 250
42127: PUSH
42128: LD_VAR 0 7
42132: PPUSH
42133: CALL_OW 251
42137: PUSH
42138: EMPTY
42139: LIST
42140: LIST
42141: ST_TO_ADDR
// repeat wait ( 0 0$1 ) ;
42142: LD_INT 35
42144: PPUSH
42145: CALL_OW 67
// x := mc_teleport_exit [ i ] [ j ] [ 1 ] ;
42149: LD_ADDR_VAR 0 4
42153: PUSH
42154: LD_EXP 130
42158: PUSH
42159: LD_VAR 0 2
42163: ARRAY
42164: PUSH
42165: LD_VAR 0 3
42169: ARRAY
42170: PUSH
42171: LD_INT 1
42173: ARRAY
42174: ST_TO_ADDR
// y := mc_teleport_exit [ i ] [ j ] [ 2 ] ;
42175: LD_ADDR_VAR 0 5
42179: PUSH
42180: LD_EXP 130
42184: PUSH
42185: LD_VAR 0 2
42189: ARRAY
42190: PUSH
42191: LD_VAR 0 3
42195: ARRAY
42196: PUSH
42197: LD_INT 2
42199: ARRAY
42200: ST_TO_ADDR
// if DangerAtRange ( tmp , 10 ) [ 4 ] then
42201: LD_VAR 0 7
42205: PPUSH
42206: LD_INT 10
42208: PPUSH
42209: CALL 59616 0 2
42213: PUSH
42214: LD_INT 4
42216: ARRAY
42217: IFFALSE 42255
// begin ComMoveXY ( tmp , save_point [ 1 ] , save_point [ 2 ] ) ;
42219: LD_VAR 0 7
42223: PPUSH
42224: LD_VAR 0 6
42228: PUSH
42229: LD_INT 1
42231: ARRAY
42232: PPUSH
42233: LD_VAR 0 6
42237: PUSH
42238: LD_INT 2
42240: ARRAY
42241: PPUSH
42242: CALL_OW 111
// wait ( 0 0$10 ) ;
42246: LD_INT 350
42248: PPUSH
42249: CALL_OW 67
// end else
42253: GO 42281
// begin ComMoveXY ( tmp , x , y ) ;
42255: LD_VAR 0 7
42259: PPUSH
42260: LD_VAR 0 4
42264: PPUSH
42265: LD_VAR 0 5
42269: PPUSH
42270: CALL_OW 111
// wait ( 0 0$3 ) ;
42274: LD_INT 105
42276: PPUSH
42277: CALL_OW 67
// end ; until IsAt ( tmp , x , y ) ;
42281: LD_VAR 0 7
42285: PPUSH
42286: LD_VAR 0 4
42290: PPUSH
42291: LD_VAR 0 5
42295: PPUSH
42296: CALL_OW 307
42300: IFFALSE 42142
// ComTeleportExit ( tmp , x , y , teleports [ j ] ) ;
42302: LD_VAR 0 7
42306: PPUSH
42307: LD_VAR 0 4
42311: PPUSH
42312: LD_VAR 0 5
42316: PPUSH
42317: LD_VAR 0 8
42321: PUSH
42322: LD_VAR 0 3
42326: ARRAY
42327: PPUSH
42328: CALL_OW 156
// repeat wait ( 0 0$1 ) ;
42332: LD_INT 35
42334: PPUSH
42335: CALL_OW 67
// until not HasTask ( tmp ) ;
42339: LD_VAR 0 7
42343: PPUSH
42344: CALL_OW 314
42348: NOT
42349: IFFALSE 42332
// mc_teleport_exit_set := ReplaceIn ( mc_teleport_exit_set , [ i , mc_teleport_exit_set [ i ] + 1 ] , teleports [ j ] ) ;
42351: LD_ADDR_EXP 131
42355: PUSH
42356: LD_EXP 131
42360: PPUSH
42361: LD_VAR 0 2
42365: PUSH
42366: LD_EXP 131
42370: PUSH
42371: LD_VAR 0 2
42375: ARRAY
42376: PUSH
42377: LD_INT 1
42379: PLUS
42380: PUSH
42381: EMPTY
42382: LIST
42383: LIST
42384: PPUSH
42385: LD_VAR 0 8
42389: PUSH
42390: LD_VAR 0 3
42394: ARRAY
42395: PPUSH
42396: CALL 57017 0 3
42400: ST_TO_ADDR
// end ;
42401: GO 42059
42403: POP
42404: POP
// MC_Reset ( i , 124 ) ;
42405: LD_VAR 0 2
42409: PPUSH
42410: LD_INT 124
42412: PPUSH
42413: CALL 25559 0 2
// end ; end ;
42417: GO 41814
42419: POP
42420: POP
// end ;
42421: LD_VAR 0 1
42425: RET
// export function MC_Deposits ( ) ; var i , tmp ; begin
42426: LD_INT 0
42428: PPUSH
42429: PPUSH
42430: PPUSH
// if not mc_bases then
42431: LD_EXP 95
42435: NOT
42436: IFFALSE 42440
// exit ;
42438: GO 43046
// for i = 1 to mc_bases do
42440: LD_ADDR_VAR 0 2
42444: PUSH
42445: DOUBLE
42446: LD_INT 1
42448: DEC
42449: ST_TO_ADDR
42450: LD_EXP 95
42454: PUSH
42455: FOR_TO
42456: IFFALSE 43044
// begin tmp := UnitFilter ( mc_bases [ i ] , [ f_class , 4 ] ) ;
42458: LD_ADDR_VAR 0 3
42462: PUSH
42463: LD_EXP 95
42467: PUSH
42468: LD_VAR 0 2
42472: ARRAY
42473: PPUSH
42474: LD_INT 25
42476: PUSH
42477: LD_INT 4
42479: PUSH
42480: EMPTY
42481: LIST
42482: LIST
42483: PPUSH
42484: CALL_OW 72
42488: ST_TO_ADDR
// if not tmp or not mc_deposits_xy [ i ] or not UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) then
42489: LD_VAR 0 3
42493: NOT
42494: PUSH
42495: LD_EXP 132
42499: PUSH
42500: LD_VAR 0 2
42504: ARRAY
42505: NOT
42506: OR
42507: PUSH
42508: LD_EXP 95
42512: PUSH
42513: LD_VAR 0 2
42517: ARRAY
42518: PPUSH
42519: LD_INT 2
42521: PUSH
42522: LD_INT 30
42524: PUSH
42525: LD_INT 0
42527: PUSH
42528: EMPTY
42529: LIST
42530: LIST
42531: PUSH
42532: LD_INT 30
42534: PUSH
42535: LD_INT 1
42537: PUSH
42538: EMPTY
42539: LIST
42540: LIST
42541: PUSH
42542: EMPTY
42543: LIST
42544: LIST
42545: LIST
42546: PPUSH
42547: CALL_OW 72
42551: NOT
42552: OR
42553: IFFALSE 42603
// begin if mc_deposits_finder [ i ] then
42555: LD_EXP 133
42559: PUSH
42560: LD_VAR 0 2
42564: ARRAY
42565: IFFALSE 42601
// begin MC_Reset ( i , 125 ) ;
42567: LD_VAR 0 2
42571: PPUSH
42572: LD_INT 125
42574: PPUSH
42575: CALL 25559 0 2
// mc_deposits_finder := Replace ( mc_deposits_finder , i , [ ] ) ;
42579: LD_ADDR_EXP 133
42583: PUSH
42584: LD_EXP 133
42588: PPUSH
42589: LD_VAR 0 2
42593: PPUSH
42594: EMPTY
42595: PPUSH
42596: CALL_OW 1
42600: ST_TO_ADDR
// end ; continue ;
42601: GO 42455
// end ; if mc_deposits_xy [ i ] [ 1 ] [ 3 ] = 1 and GetTech ( tech_sibdet , mc_sides [ i ] ) <> state_researched then
42603: LD_EXP 132
42607: PUSH
42608: LD_VAR 0 2
42612: ARRAY
42613: PUSH
42614: LD_INT 1
42616: ARRAY
42617: PUSH
42618: LD_INT 3
42620: ARRAY
42621: PUSH
42622: LD_INT 1
42624: EQUAL
42625: PUSH
42626: LD_INT 20
42628: PPUSH
42629: LD_EXP 121
42633: PUSH
42634: LD_VAR 0 2
42638: ARRAY
42639: PPUSH
42640: CALL_OW 321
42644: PUSH
42645: LD_INT 2
42647: NONEQUAL
42648: AND
42649: IFFALSE 42699
// begin if mc_deposits_finder [ i ] then
42651: LD_EXP 133
42655: PUSH
42656: LD_VAR 0 2
42660: ARRAY
42661: IFFALSE 42697
// begin MC_Reset ( i , 125 ) ;
42663: LD_VAR 0 2
42667: PPUSH
42668: LD_INT 125
42670: PPUSH
42671: CALL 25559 0 2
// mc_deposits_finder := Replace ( mc_deposits_finder , i , [ ] ) ;
42675: LD_ADDR_EXP 133
42679: PUSH
42680: LD_EXP 133
42684: PPUSH
42685: LD_VAR 0 2
42689: PPUSH
42690: EMPTY
42691: PPUSH
42692: CALL_OW 1
42696: ST_TO_ADDR
// end ; continue ;
42697: GO 42455
// end ; if GetResourceVisibility ( mc_deposits_xy [ i ] [ 1 ] [ 1 ] , mc_deposits_xy [ i ] [ 1 ] [ 2 ] , mc_sides [ i ] ) then
42699: LD_EXP 132
42703: PUSH
42704: LD_VAR 0 2
42708: ARRAY
42709: PUSH
42710: LD_INT 1
42712: ARRAY
42713: PUSH
42714: LD_INT 1
42716: ARRAY
42717: PPUSH
42718: LD_EXP 132
42722: PUSH
42723: LD_VAR 0 2
42727: ARRAY
42728: PUSH
42729: LD_INT 1
42731: ARRAY
42732: PUSH
42733: LD_INT 2
42735: ARRAY
42736: PPUSH
42737: LD_EXP 121
42741: PUSH
42742: LD_VAR 0 2
42746: ARRAY
42747: PPUSH
42748: CALL_OW 440
42752: IFFALSE 42795
// mc_deposits_xy := Replace ( mc_deposits_xy , i , Delete ( mc_deposits_xy [ i ] , 1 ) ) else
42754: LD_ADDR_EXP 132
42758: PUSH
42759: LD_EXP 132
42763: PPUSH
42764: LD_VAR 0 2
42768: PPUSH
42769: LD_EXP 132
42773: PUSH
42774: LD_VAR 0 2
42778: ARRAY
42779: PPUSH
42780: LD_INT 1
42782: PPUSH
42783: CALL_OW 3
42787: PPUSH
42788: CALL_OW 1
42792: ST_TO_ADDR
42793: GO 43042
// begin if not mc_deposits_finder [ i ] then
42795: LD_EXP 133
42799: PUSH
42800: LD_VAR 0 2
42804: ARRAY
42805: NOT
42806: IFFALSE 42858
// begin mc_deposits_finder := Replace ( mc_deposits_finder , i , [ tmp [ 1 ] ] ) ;
42808: LD_ADDR_EXP 133
42812: PUSH
42813: LD_EXP 133
42817: PPUSH
42818: LD_VAR 0 2
42822: PPUSH
42823: LD_VAR 0 3
42827: PUSH
42828: LD_INT 1
42830: ARRAY
42831: PUSH
42832: EMPTY
42833: LIST
42834: PPUSH
42835: CALL_OW 1
42839: ST_TO_ADDR
// SetTag ( tmp [ 1 ] , 125 ) ;
42840: LD_VAR 0 3
42844: PUSH
42845: LD_INT 1
42847: ARRAY
42848: PPUSH
42849: LD_INT 125
42851: PPUSH
42852: CALL_OW 109
// end else
42856: GO 43042
// begin if IsInUnit ( mc_deposits_finder [ i ] [ 1 ] ) then
42858: LD_EXP 133
42862: PUSH
42863: LD_VAR 0 2
42867: ARRAY
42868: PUSH
42869: LD_INT 1
42871: ARRAY
42872: PPUSH
42873: CALL_OW 310
42877: IFFALSE 42900
// ComExitBuilding ( mc_deposits_finder [ i ] [ 1 ] ) else
42879: LD_EXP 133
42883: PUSH
42884: LD_VAR 0 2
42888: ARRAY
42889: PUSH
42890: LD_INT 1
42892: ARRAY
42893: PPUSH
42894: CALL_OW 122
42898: GO 43042
// if not HasTask ( mc_deposits_finder [ i ] [ 1 ] ) and GetDistUnitXY ( mc_deposits_finder [ i ] [ 1 ] , mc_deposits_xy [ i ] [ 1 ] [ 1 ] , mc_deposits_xy [ i ] [ 1 ] [ 2 ] ) > 6 then
42900: LD_EXP 133
42904: PUSH
42905: LD_VAR 0 2
42909: ARRAY
42910: PUSH
42911: LD_INT 1
42913: ARRAY
42914: PPUSH
42915: CALL_OW 314
42919: NOT
42920: PUSH
42921: LD_EXP 133
42925: PUSH
42926: LD_VAR 0 2
42930: ARRAY
42931: PUSH
42932: LD_INT 1
42934: ARRAY
42935: PPUSH
42936: LD_EXP 132
42940: PUSH
42941: LD_VAR 0 2
42945: ARRAY
42946: PUSH
42947: LD_INT 1
42949: ARRAY
42950: PUSH
42951: LD_INT 1
42953: ARRAY
42954: PPUSH
42955: LD_EXP 132
42959: PUSH
42960: LD_VAR 0 2
42964: ARRAY
42965: PUSH
42966: LD_INT 1
42968: ARRAY
42969: PUSH
42970: LD_INT 2
42972: ARRAY
42973: PPUSH
42974: CALL_OW 297
42978: PUSH
42979: LD_INT 6
42981: GREATER
42982: AND
42983: IFFALSE 43042
// ComMoveXY ( mc_deposits_finder [ i ] [ 1 ] , mc_deposits_xy [ i ] [ 1 ] [ 1 ] , mc_deposits_xy [ i ] [ 1 ] [ 2 ] ) ;
42985: LD_EXP 133
42989: PUSH
42990: LD_VAR 0 2
42994: ARRAY
42995: PUSH
42996: LD_INT 1
42998: ARRAY
42999: PPUSH
43000: LD_EXP 132
43004: PUSH
43005: LD_VAR 0 2
43009: ARRAY
43010: PUSH
43011: LD_INT 1
43013: ARRAY
43014: PUSH
43015: LD_INT 1
43017: ARRAY
43018: PPUSH
43019: LD_EXP 132
43023: PUSH
43024: LD_VAR 0 2
43028: ARRAY
43029: PUSH
43030: LD_INT 1
43032: ARRAY
43033: PUSH
43034: LD_INT 2
43036: ARRAY
43037: PPUSH
43038: CALL_OW 111
// end ; end ; end ;
43042: GO 42455
43044: POP
43045: POP
// end ;
43046: LD_VAR 0 1
43050: RET
// export function MC_RemoteDriver ( ) ; var i , j , k , places , tmp , nation , ct , cts , mcts , x ; begin
43051: LD_INT 0
43053: PPUSH
43054: PPUSH
43055: PPUSH
43056: PPUSH
43057: PPUSH
43058: PPUSH
43059: PPUSH
43060: PPUSH
43061: PPUSH
43062: PPUSH
43063: PPUSH
// if not mc_bases then
43064: LD_EXP 95
43068: NOT
43069: IFFALSE 43073
// exit ;
43071: GO 44013
// for i = 1 to mc_bases do
43073: LD_ADDR_VAR 0 2
43077: PUSH
43078: DOUBLE
43079: LD_INT 1
43081: DEC
43082: ST_TO_ADDR
43083: LD_EXP 95
43087: PUSH
43088: FOR_TO
43089: IFFALSE 44011
// begin if not mc_bases [ i ] or mc_scan [ i ] then
43091: LD_EXP 95
43095: PUSH
43096: LD_VAR 0 2
43100: ARRAY
43101: NOT
43102: PUSH
43103: LD_EXP 118
43107: PUSH
43108: LD_VAR 0 2
43112: ARRAY
43113: OR
43114: IFFALSE 43118
// continue ;
43116: GO 43088
// nation := GetNation ( mc_bases [ i ] [ 1 ] ) ;
43118: LD_ADDR_VAR 0 7
43122: PUSH
43123: LD_EXP 95
43127: PUSH
43128: LD_VAR 0 2
43132: ARRAY
43133: PUSH
43134: LD_INT 1
43136: ARRAY
43137: PPUSH
43138: CALL_OW 248
43142: ST_TO_ADDR
// if nation = 3 or not UnitFilter ( mc_vehicles [ i ] union mc_defender [ i ] , [ f_control , control_remote ] ) then
43143: LD_VAR 0 7
43147: PUSH
43148: LD_INT 3
43150: EQUAL
43151: PUSH
43152: LD_EXP 114
43156: PUSH
43157: LD_VAR 0 2
43161: ARRAY
43162: PUSH
43163: LD_EXP 117
43167: PUSH
43168: LD_VAR 0 2
43172: ARRAY
43173: UNION
43174: PPUSH
43175: LD_INT 33
43177: PUSH
43178: LD_INT 2
43180: PUSH
43181: EMPTY
43182: LIST
43183: LIST
43184: PPUSH
43185: CALL_OW 72
43189: NOT
43190: OR
43191: IFFALSE 43195
// continue ;
43193: GO 43088
// cts := UnitFilter ( mc_bases [ i ] , [ f_btype , b_control_tower ] ) ;
43195: LD_ADDR_VAR 0 9
43199: PUSH
43200: LD_EXP 95
43204: PUSH
43205: LD_VAR 0 2
43209: ARRAY
43210: PPUSH
43211: LD_INT 30
43213: PUSH
43214: LD_INT 36
43216: PUSH
43217: EMPTY
43218: LIST
43219: LIST
43220: PPUSH
43221: CALL_OW 72
43225: ST_TO_ADDR
// mcts := UnitFilter ( mc_vehicles [ i ] , [ f_weapon , ar_control_tower ] ) ;
43226: LD_ADDR_VAR 0 10
43230: PUSH
43231: LD_EXP 114
43235: PUSH
43236: LD_VAR 0 2
43240: ARRAY
43241: PPUSH
43242: LD_INT 34
43244: PUSH
43245: LD_INT 31
43247: PUSH
43248: EMPTY
43249: LIST
43250: LIST
43251: PPUSH
43252: CALL_OW 72
43256: ST_TO_ADDR
// if not cts and not mcts then
43257: LD_VAR 0 9
43261: NOT
43262: PUSH
43263: LD_VAR 0 10
43267: NOT
43268: AND
43269: IFFALSE 43273
// continue ;
43271: GO 43088
// x := cts ;
43273: LD_ADDR_VAR 0 11
43277: PUSH
43278: LD_VAR 0 9
43282: ST_TO_ADDR
// if not x then
43283: LD_VAR 0 11
43287: NOT
43288: IFFALSE 43300
// x := mcts ;
43290: LD_ADDR_VAR 0 11
43294: PUSH
43295: LD_VAR 0 10
43299: ST_TO_ADDR
// if not x then
43300: LD_VAR 0 11
43304: NOT
43305: IFFALSE 43309
// continue ;
43307: GO 43088
// if mc_remote_driver [ i ] then
43309: LD_EXP 135
43313: PUSH
43314: LD_VAR 0 2
43318: ARRAY
43319: IFFALSE 43706
// for j in mc_remote_driver [ i ] do
43321: LD_ADDR_VAR 0 3
43325: PUSH
43326: LD_EXP 135
43330: PUSH
43331: LD_VAR 0 2
43335: ARRAY
43336: PUSH
43337: FOR_IN
43338: IFFALSE 43704
// begin if GetClass ( j ) <> 3 then
43340: LD_VAR 0 3
43344: PPUSH
43345: CALL_OW 257
43349: PUSH
43350: LD_INT 3
43352: NONEQUAL
43353: IFFALSE 43406
// begin mc_remote_driver := Replace ( mc_remote_driver , i , mc_remote_driver [ i ] diff j ) ;
43355: LD_ADDR_EXP 135
43359: PUSH
43360: LD_EXP 135
43364: PPUSH
43365: LD_VAR 0 2
43369: PPUSH
43370: LD_EXP 135
43374: PUSH
43375: LD_VAR 0 2
43379: ARRAY
43380: PUSH
43381: LD_VAR 0 3
43385: DIFF
43386: PPUSH
43387: CALL_OW 1
43391: ST_TO_ADDR
// SetTag ( j , 0 ) ;
43392: LD_VAR 0 3
43396: PPUSH
43397: LD_INT 0
43399: PPUSH
43400: CALL_OW 109
// continue ;
43404: GO 43337
// end ; if UnitFilter ( mc_vehicles [ i ] , [ [ f_weapon , ar_control_tower ] , [ f_empty ] ] ) and not IsDriver ( j ) then
43406: LD_EXP 114
43410: PUSH
43411: LD_VAR 0 2
43415: ARRAY
43416: PPUSH
43417: LD_INT 34
43419: PUSH
43420: LD_INT 31
43422: PUSH
43423: EMPTY
43424: LIST
43425: LIST
43426: PUSH
43427: LD_INT 58
43429: PUSH
43430: EMPTY
43431: LIST
43432: PUSH
43433: EMPTY
43434: LIST
43435: LIST
43436: PPUSH
43437: CALL_OW 72
43441: PUSH
43442: LD_VAR 0 3
43446: PPUSH
43447: CALL 86321 0 1
43451: NOT
43452: AND
43453: IFFALSE 43524
// begin if IsInUnit ( j ) then
43455: LD_VAR 0 3
43459: PPUSH
43460: CALL_OW 310
43464: IFFALSE 43475
// ComExitBuilding ( j ) ;
43466: LD_VAR 0 3
43470: PPUSH
43471: CALL_OW 122
// AddComEnterUnit ( j , UnitFilter ( mc_vehicles [ i ] , [ [ f_weapon , ar_control_tower ] , [ f_empty ] ] ) [ 1 ] ) ;
43475: LD_VAR 0 3
43479: PPUSH
43480: LD_EXP 114
43484: PUSH
43485: LD_VAR 0 2
43489: ARRAY
43490: PPUSH
43491: LD_INT 34
43493: PUSH
43494: LD_INT 31
43496: PUSH
43497: EMPTY
43498: LIST
43499: LIST
43500: PUSH
43501: LD_INT 58
43503: PUSH
43504: EMPTY
43505: LIST
43506: PUSH
43507: EMPTY
43508: LIST
43509: LIST
43510: PPUSH
43511: CALL_OW 72
43515: PUSH
43516: LD_INT 1
43518: ARRAY
43519: PPUSH
43520: CALL_OW 180
// end ; if not IsInUnit ( j ) or ( GetBType ( IsInUnit ( j ) ) <> b_control_tower and not IsDriver ( j ) ) then
43524: LD_VAR 0 3
43528: PPUSH
43529: CALL_OW 310
43533: NOT
43534: PUSH
43535: LD_VAR 0 3
43539: PPUSH
43540: CALL_OW 310
43544: PPUSH
43545: CALL_OW 266
43549: PUSH
43550: LD_INT 36
43552: NONEQUAL
43553: PUSH
43554: LD_VAR 0 3
43558: PPUSH
43559: CALL 86321 0 1
43563: NOT
43564: AND
43565: OR
43566: IFFALSE 43702
// begin if IsInUnit ( j ) then
43568: LD_VAR 0 3
43572: PPUSH
43573: CALL_OW 310
43577: IFFALSE 43588
// ComExitBuilding ( j ) ;
43579: LD_VAR 0 3
43583: PPUSH
43584: CALL_OW 122
// ct := 0 ;
43588: LD_ADDR_VAR 0 8
43592: PUSH
43593: LD_INT 0
43595: ST_TO_ADDR
// for k in x do
43596: LD_ADDR_VAR 0 4
43600: PUSH
43601: LD_VAR 0 11
43605: PUSH
43606: FOR_IN
43607: IFFALSE 43680
// if ( GetWeapon ( k ) = ar_control_tower and not IsDrivenBy ( k ) ) or ( GetBType ( k ) = b_control_tower and UnitsInside ( k ) < 3 ) then
43609: LD_VAR 0 4
43613: PPUSH
43614: CALL_OW 264
43618: PUSH
43619: LD_INT 31
43621: EQUAL
43622: PUSH
43623: LD_VAR 0 4
43627: PPUSH
43628: CALL_OW 311
43632: NOT
43633: AND
43634: PUSH
43635: LD_VAR 0 4
43639: PPUSH
43640: CALL_OW 266
43644: PUSH
43645: LD_INT 36
43647: EQUAL
43648: PUSH
43649: LD_VAR 0 4
43653: PPUSH
43654: CALL_OW 313
43658: PUSH
43659: LD_INT 3
43661: LESS
43662: AND
43663: OR
43664: IFFALSE 43678
// begin ct := k ;
43666: LD_ADDR_VAR 0 8
43670: PUSH
43671: LD_VAR 0 4
43675: ST_TO_ADDR
// break ;
43676: GO 43680
// end ;
43678: GO 43606
43680: POP
43681: POP
// if ct then
43682: LD_VAR 0 8
43686: IFFALSE 43702
// ComEnterUnit ( j , ct ) ;
43688: LD_VAR 0 3
43692: PPUSH
43693: LD_VAR 0 8
43697: PPUSH
43698: CALL_OW 120
// end ; end ;
43702: GO 43337
43704: POP
43705: POP
// places := 0 ;
43706: LD_ADDR_VAR 0 5
43710: PUSH
43711: LD_INT 0
43713: ST_TO_ADDR
// for j = 1 to x do
43714: LD_ADDR_VAR 0 3
43718: PUSH
43719: DOUBLE
43720: LD_INT 1
43722: DEC
43723: ST_TO_ADDR
43724: LD_VAR 0 11
43728: PUSH
43729: FOR_TO
43730: IFFALSE 43806
// if GetWeapon ( x [ j ] ) = ar_control_tower then
43732: LD_VAR 0 11
43736: PUSH
43737: LD_VAR 0 3
43741: ARRAY
43742: PPUSH
43743: CALL_OW 264
43747: PUSH
43748: LD_INT 31
43750: EQUAL
43751: IFFALSE 43769
// places := places + 1 else
43753: LD_ADDR_VAR 0 5
43757: PUSH
43758: LD_VAR 0 5
43762: PUSH
43763: LD_INT 1
43765: PLUS
43766: ST_TO_ADDR
43767: GO 43804
// if GetBType ( x [ j ] ) = b_control_tower then
43769: LD_VAR 0 11
43773: PUSH
43774: LD_VAR 0 3
43778: ARRAY
43779: PPUSH
43780: CALL_OW 266
43784: PUSH
43785: LD_INT 36
43787: EQUAL
43788: IFFALSE 43804
// places := places + 3 ;
43790: LD_ADDR_VAR 0 5
43794: PUSH
43795: LD_VAR 0 5
43799: PUSH
43800: LD_INT 3
43802: PLUS
43803: ST_TO_ADDR
43804: GO 43729
43806: POP
43807: POP
// if places = 0 or places <= mc_remote_driver [ i ] then
43808: LD_VAR 0 5
43812: PUSH
43813: LD_INT 0
43815: EQUAL
43816: PUSH
43817: LD_VAR 0 5
43821: PUSH
43822: LD_EXP 135
43826: PUSH
43827: LD_VAR 0 2
43831: ARRAY
43832: LESSEQUAL
43833: OR
43834: IFFALSE 43838
// continue ;
43836: GO 43088
// tmp := SortBySkill ( UnitFilter ( mc_bases [ i ] , [ f_class , 3 ] ) diff mc_remote_driver [ i ] , 3 ) ;
43838: LD_ADDR_VAR 0 6
43842: PUSH
43843: LD_EXP 95
43847: PUSH
43848: LD_VAR 0 2
43852: ARRAY
43853: PPUSH
43854: LD_INT 25
43856: PUSH
43857: LD_INT 3
43859: PUSH
43860: EMPTY
43861: LIST
43862: LIST
43863: PPUSH
43864: CALL_OW 72
43868: PUSH
43869: LD_EXP 135
43873: PUSH
43874: LD_VAR 0 2
43878: ARRAY
43879: DIFF
43880: PPUSH
43881: LD_INT 3
43883: PPUSH
43884: CALL 87221 0 2
43888: ST_TO_ADDR
// for j in tmp do
43889: LD_ADDR_VAR 0 3
43893: PUSH
43894: LD_VAR 0 6
43898: PUSH
43899: FOR_IN
43900: IFFALSE 43935
// if GetTag ( j ) > 0 then
43902: LD_VAR 0 3
43906: PPUSH
43907: CALL_OW 110
43911: PUSH
43912: LD_INT 0
43914: GREATER
43915: IFFALSE 43933
// tmp := tmp diff j ;
43917: LD_ADDR_VAR 0 6
43921: PUSH
43922: LD_VAR 0 6
43926: PUSH
43927: LD_VAR 0 3
43931: DIFF
43932: ST_TO_ADDR
43933: GO 43899
43935: POP
43936: POP
// if not tmp then
43937: LD_VAR 0 6
43941: NOT
43942: IFFALSE 43946
// continue ;
43944: GO 43088
// if places then
43946: LD_VAR 0 5
43950: IFFALSE 44009
// begin mc_remote_driver := Replace ( mc_remote_driver , i , mc_remote_driver [ i ] union tmp [ 1 ] ) ;
43952: LD_ADDR_EXP 135
43956: PUSH
43957: LD_EXP 135
43961: PPUSH
43962: LD_VAR 0 2
43966: PPUSH
43967: LD_EXP 135
43971: PUSH
43972: LD_VAR 0 2
43976: ARRAY
43977: PUSH
43978: LD_VAR 0 6
43982: PUSH
43983: LD_INT 1
43985: ARRAY
43986: UNION
43987: PPUSH
43988: CALL_OW 1
43992: ST_TO_ADDR
// SetTag ( tmp [ 1 ] , 126 ) ;
43993: LD_VAR 0 6
43997: PUSH
43998: LD_INT 1
44000: ARRAY
44001: PPUSH
44002: LD_INT 126
44004: PPUSH
44005: CALL_OW 109
// end ; end ;
44009: GO 43088
44011: POP
44012: POP
// end ;
44013: LD_VAR 0 1
44017: RET
// export function MC_Back ( base , base_unit_list , unit , class ) ; var i , j , tmp , x , depot ; begin
44018: LD_INT 0
44020: PPUSH
44021: PPUSH
44022: PPUSH
44023: PPUSH
44024: PPUSH
44025: PPUSH
// if not base or not base_unit_list or not unit or not class in [ 1 , 2 , 3 , 4 , 5 , 8 , 9 , 15 , 16 ] then
44026: LD_VAR 0 1
44030: NOT
44031: PUSH
44032: LD_VAR 0 2
44036: NOT
44037: OR
44038: PUSH
44039: LD_VAR 0 3
44043: NOT
44044: OR
44045: PUSH
44046: LD_VAR 0 4
44050: PUSH
44051: LD_INT 1
44053: PUSH
44054: LD_INT 2
44056: PUSH
44057: LD_INT 3
44059: PUSH
44060: LD_INT 4
44062: PUSH
44063: LD_INT 5
44065: PUSH
44066: LD_INT 8
44068: PUSH
44069: LD_INT 9
44071: PUSH
44072: LD_INT 15
44074: PUSH
44075: LD_INT 16
44077: PUSH
44078: EMPTY
44079: LIST
44080: LIST
44081: LIST
44082: LIST
44083: LIST
44084: LIST
44085: LIST
44086: LIST
44087: LIST
44088: IN
44089: NOT
44090: OR
44091: IFFALSE 44095
// exit ;
44093: GO 44995
// base_unit_list := UnitFilter ( base_unit_list , [ [ f_type , unit_building ] , [ f_lives , 250 ] ] ) ;
44095: LD_ADDR_VAR 0 2
44099: PUSH
44100: LD_VAR 0 2
44104: PPUSH
44105: LD_INT 21
44107: PUSH
44108: LD_INT 3
44110: PUSH
44111: EMPTY
44112: LIST
44113: LIST
44114: PUSH
44115: LD_INT 24
44117: PUSH
44118: LD_INT 250
44120: PUSH
44121: EMPTY
44122: LIST
44123: LIST
44124: PUSH
44125: EMPTY
44126: LIST
44127: LIST
44128: PPUSH
44129: CALL_OW 72
44133: ST_TO_ADDR
// case class of 1 , 15 :
44134: LD_VAR 0 4
44138: PUSH
44139: LD_INT 1
44141: DOUBLE
44142: EQUAL
44143: IFTRUE 44153
44145: LD_INT 15
44147: DOUBLE
44148: EQUAL
44149: IFTRUE 44153
44151: GO 44238
44153: POP
// tmp := UnitFilter ( base_unit_list , [ f_or , [ f_btype , b_bunker ] , [ f_btype , b_breastwork ] ] ) ^ UnitFilter ( base_unit_list , [ f_or , [ f_btype , b_armoury ] , [ f_btype , b_barracks ] ] ) ; 2 , 16 :
44154: LD_ADDR_VAR 0 8
44158: PUSH
44159: LD_VAR 0 2
44163: PPUSH
44164: LD_INT 2
44166: PUSH
44167: LD_INT 30
44169: PUSH
44170: LD_INT 32
44172: PUSH
44173: EMPTY
44174: LIST
44175: LIST
44176: PUSH
44177: LD_INT 30
44179: PUSH
44180: LD_INT 31
44182: PUSH
44183: EMPTY
44184: LIST
44185: LIST
44186: PUSH
44187: EMPTY
44188: LIST
44189: LIST
44190: LIST
44191: PPUSH
44192: CALL_OW 72
44196: PUSH
44197: LD_VAR 0 2
44201: PPUSH
44202: LD_INT 2
44204: PUSH
44205: LD_INT 30
44207: PUSH
44208: LD_INT 4
44210: PUSH
44211: EMPTY
44212: LIST
44213: LIST
44214: PUSH
44215: LD_INT 30
44217: PUSH
44218: LD_INT 5
44220: PUSH
44221: EMPTY
44222: LIST
44223: LIST
44224: PUSH
44225: EMPTY
44226: LIST
44227: LIST
44228: LIST
44229: PPUSH
44230: CALL_OW 72
44234: ADD
44235: ST_TO_ADDR
44236: GO 44484
44238: LD_INT 2
44240: DOUBLE
44241: EQUAL
44242: IFTRUE 44252
44244: LD_INT 16
44246: DOUBLE
44247: EQUAL
44248: IFTRUE 44252
44250: GO 44298
44252: POP
// tmp := UnitFilter ( base_unit_list , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) ; 3 :
44253: LD_ADDR_VAR 0 8
44257: PUSH
44258: LD_VAR 0 2
44262: PPUSH
44263: LD_INT 2
44265: PUSH
44266: LD_INT 30
44268: PUSH
44269: LD_INT 0
44271: PUSH
44272: EMPTY
44273: LIST
44274: LIST
44275: PUSH
44276: LD_INT 30
44278: PUSH
44279: LD_INT 1
44281: PUSH
44282: EMPTY
44283: LIST
44284: LIST
44285: PUSH
44286: EMPTY
44287: LIST
44288: LIST
44289: LIST
44290: PPUSH
44291: CALL_OW 72
44295: ST_TO_ADDR
44296: GO 44484
44298: LD_INT 3
44300: DOUBLE
44301: EQUAL
44302: IFTRUE 44306
44304: GO 44352
44306: POP
// tmp := UnitFilter ( base_unit_list , [ f_or , [ f_btype , b_workshop ] , [ f_btype , b_factory ] ] ) ; 4 :
44307: LD_ADDR_VAR 0 8
44311: PUSH
44312: LD_VAR 0 2
44316: PPUSH
44317: LD_INT 2
44319: PUSH
44320: LD_INT 30
44322: PUSH
44323: LD_INT 2
44325: PUSH
44326: EMPTY
44327: LIST
44328: LIST
44329: PUSH
44330: LD_INT 30
44332: PUSH
44333: LD_INT 3
44335: PUSH
44336: EMPTY
44337: LIST
44338: LIST
44339: PUSH
44340: EMPTY
44341: LIST
44342: LIST
44343: LIST
44344: PPUSH
44345: CALL_OW 72
44349: ST_TO_ADDR
44350: GO 44484
44352: LD_INT 4
44354: DOUBLE
44355: EQUAL
44356: IFTRUE 44360
44358: GO 44417
44360: POP
// tmp := UnitFilter ( base_unit_list , [ f_or , [ f_btype , b_lab ] , [ f_btype , b_lab_half ] , [ f_btype , b_lab_full ] ] ) ; 5 , 8 , 9 :
44361: LD_ADDR_VAR 0 8
44365: PUSH
44366: LD_VAR 0 2
44370: PPUSH
44371: LD_INT 2
44373: PUSH
44374: LD_INT 30
44376: PUSH
44377: LD_INT 6
44379: PUSH
44380: EMPTY
44381: LIST
44382: LIST
44383: PUSH
44384: LD_INT 30
44386: PUSH
44387: LD_INT 7
44389: PUSH
44390: EMPTY
44391: LIST
44392: LIST
44393: PUSH
44394: LD_INT 30
44396: PUSH
44397: LD_INT 8
44399: PUSH
44400: EMPTY
44401: LIST
44402: LIST
44403: PUSH
44404: EMPTY
44405: LIST
44406: LIST
44407: LIST
44408: LIST
44409: PPUSH
44410: CALL_OW 72
44414: ST_TO_ADDR
44415: GO 44484
44417: LD_INT 5
44419: DOUBLE
44420: EQUAL
44421: IFTRUE 44437
44423: LD_INT 8
44425: DOUBLE
44426: EQUAL
44427: IFTRUE 44437
44429: LD_INT 9
44431: DOUBLE
44432: EQUAL
44433: IFTRUE 44437
44435: GO 44483
44437: POP
// tmp := UnitFilter ( base_unit_list , [ f_or , [ f_btype , b_armoury ] , [ f_btype , b_barracks ] ] ) ; end ;
44438: LD_ADDR_VAR 0 8
44442: PUSH
44443: LD_VAR 0 2
44447: PPUSH
44448: LD_INT 2
44450: PUSH
44451: LD_INT 30
44453: PUSH
44454: LD_INT 4
44456: PUSH
44457: EMPTY
44458: LIST
44459: LIST
44460: PUSH
44461: LD_INT 30
44463: PUSH
44464: LD_INT 5
44466: PUSH
44467: EMPTY
44468: LIST
44469: LIST
44470: PUSH
44471: EMPTY
44472: LIST
44473: LIST
44474: LIST
44475: PPUSH
44476: CALL_OW 72
44480: ST_TO_ADDR
44481: GO 44484
44483: POP
// if not tmp then
44484: LD_VAR 0 8
44488: NOT
44489: IFFALSE 44493
// exit ;
44491: GO 44995
// if class in [ 1 , 15 ] and mc_empty_turret_list [ base ] then
44493: LD_VAR 0 4
44497: PUSH
44498: LD_INT 1
44500: PUSH
44501: LD_INT 15
44503: PUSH
44504: EMPTY
44505: LIST
44506: LIST
44507: IN
44508: PUSH
44509: LD_EXP 104
44513: PUSH
44514: LD_VAR 0 1
44518: ARRAY
44519: AND
44520: IFFALSE 44676
// begin x := mc_empty_turret_list [ base ] [ 1 ] ;
44522: LD_ADDR_VAR 0 9
44526: PUSH
44527: LD_EXP 104
44531: PUSH
44532: LD_VAR 0 1
44536: ARRAY
44537: PUSH
44538: LD_INT 1
44540: ARRAY
44541: ST_TO_ADDR
// if not x in mc_busy_turret_list [ base ] then
44542: LD_VAR 0 9
44546: PUSH
44547: LD_EXP 105
44551: PUSH
44552: LD_VAR 0 1
44556: ARRAY
44557: IN
44558: NOT
44559: IFFALSE 44674
// begin mc_busy_turret_list := ReplaceIn ( mc_busy_turret_list , [ base , mc_busy_turret_list [ base ] + 1 ] , x ) ;
44561: LD_ADDR_EXP 105
44565: PUSH
44566: LD_EXP 105
44570: PPUSH
44571: LD_VAR 0 1
44575: PUSH
44576: LD_EXP 105
44580: PUSH
44581: LD_VAR 0 1
44585: ARRAY
44586: PUSH
44587: LD_INT 1
44589: PLUS
44590: PUSH
44591: EMPTY
44592: LIST
44593: LIST
44594: PPUSH
44595: LD_VAR 0 9
44599: PPUSH
44600: CALL 57017 0 3
44604: ST_TO_ADDR
// mc_empty_turret_list := Replace ( mc_empty_turret_list , base , mc_empty_turret_list [ base ] diff x ) ;
44605: LD_ADDR_EXP 104
44609: PUSH
44610: LD_EXP 104
44614: PPUSH
44615: LD_VAR 0 1
44619: PPUSH
44620: LD_EXP 104
44624: PUSH
44625: LD_VAR 0 1
44629: ARRAY
44630: PUSH
44631: LD_VAR 0 9
44635: DIFF
44636: PPUSH
44637: CALL_OW 1
44641: ST_TO_ADDR
// ComEnterUnit ( unit , mc_busy_turret_list [ base ] [ mc_busy_turret_list [ base ] ] ) ;
44642: LD_VAR 0 3
44646: PPUSH
44647: LD_EXP 105
44651: PUSH
44652: LD_VAR 0 1
44656: ARRAY
44657: PUSH
44658: LD_EXP 105
44662: PUSH
44663: LD_VAR 0 1
44667: ARRAY
44668: ARRAY
44669: PPUSH
44670: CALL_OW 120
// end ; exit ;
44674: GO 44995
// end ; if tmp > 1 then
44676: LD_VAR 0 8
44680: PUSH
44681: LD_INT 1
44683: GREATER
44684: IFFALSE 44788
// for i = 2 to tmp do
44686: LD_ADDR_VAR 0 6
44690: PUSH
44691: DOUBLE
44692: LD_INT 2
44694: DEC
44695: ST_TO_ADDR
44696: LD_VAR 0 8
44700: PUSH
44701: FOR_TO
44702: IFFALSE 44786
// if BuildingStatus ( tmp [ i ] ) = bs_need_people then
44704: LD_VAR 0 8
44708: PUSH
44709: LD_VAR 0 6
44713: ARRAY
44714: PPUSH
44715: CALL_OW 461
44719: PUSH
44720: LD_INT 6
44722: EQUAL
44723: IFFALSE 44784
// begin x := tmp [ i ] ;
44725: LD_ADDR_VAR 0 9
44729: PUSH
44730: LD_VAR 0 8
44734: PUSH
44735: LD_VAR 0 6
44739: ARRAY
44740: ST_TO_ADDR
// tmp := Delete ( tmp , i ) ;
44741: LD_ADDR_VAR 0 8
44745: PUSH
44746: LD_VAR 0 8
44750: PPUSH
44751: LD_VAR 0 6
44755: PPUSH
44756: CALL_OW 3
44760: ST_TO_ADDR
// tmp := Insert ( tmp , 1 , x ) ;
44761: LD_ADDR_VAR 0 8
44765: PUSH
44766: LD_VAR 0 8
44770: PPUSH
44771: LD_INT 1
44773: PPUSH
44774: LD_VAR 0 9
44778: PPUSH
44779: CALL_OW 2
44783: ST_TO_ADDR
// end ;
44784: GO 44701
44786: POP
44787: POP
// for i in tmp do
44788: LD_ADDR_VAR 0 6
44792: PUSH
44793: LD_VAR 0 8
44797: PUSH
44798: FOR_IN
44799: IFFALSE 44868
// begin if ( UnitsInside ( i ) < 6 and not GetBType ( i ) in [ b_breastwork , b_bunker ] ) or UnitsInside ( i ) = 0 then
44801: LD_VAR 0 6
44805: PPUSH
44806: CALL_OW 313
44810: PUSH
44811: LD_INT 6
44813: LESS
44814: PUSH
44815: LD_VAR 0 6
44819: PPUSH
44820: CALL_OW 266
44824: PUSH
44825: LD_INT 31
44827: PUSH
44828: LD_INT 32
44830: PUSH
44831: EMPTY
44832: LIST
44833: LIST
44834: IN
44835: NOT
44836: AND
44837: PUSH
44838: LD_VAR 0 6
44842: PPUSH
44843: CALL_OW 313
44847: PUSH
44848: LD_INT 0
44850: EQUAL
44851: OR
44852: IFFALSE 44866
// begin j := i ;
44854: LD_ADDR_VAR 0 7
44858: PUSH
44859: LD_VAR 0 6
44863: ST_TO_ADDR
// break ;
44864: GO 44868
// end ; end ;
44866: GO 44798
44868: POP
44869: POP
// if j then
44870: LD_VAR 0 7
44874: IFFALSE 44892
// ComEnterUnit ( unit , j ) else
44876: LD_VAR 0 3
44880: PPUSH
44881: LD_VAR 0 7
44885: PPUSH
44886: CALL_OW 120
44890: GO 44995
// begin depot := UnitFilter ( base_unit_list , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) ;
44892: LD_ADDR_VAR 0 10
44896: PUSH
44897: LD_VAR 0 2
44901: PPUSH
44902: LD_INT 2
44904: PUSH
44905: LD_INT 30
44907: PUSH
44908: LD_INT 0
44910: PUSH
44911: EMPTY
44912: LIST
44913: LIST
44914: PUSH
44915: LD_INT 30
44917: PUSH
44918: LD_INT 1
44920: PUSH
44921: EMPTY
44922: LIST
44923: LIST
44924: PUSH
44925: EMPTY
44926: LIST
44927: LIST
44928: LIST
44929: PPUSH
44930: CALL_OW 72
44934: ST_TO_ADDR
// if depot then
44935: LD_VAR 0 10
44939: IFFALSE 44995
// begin depot := NearestUnitToUnit ( depot , unit ) ;
44941: LD_ADDR_VAR 0 10
44945: PUSH
44946: LD_VAR 0 10
44950: PPUSH
44951: LD_VAR 0 3
44955: PPUSH
44956: CALL_OW 74
44960: ST_TO_ADDR
// if GetDistUnits ( unit , depot ) > 10 then
44961: LD_VAR 0 3
44965: PPUSH
44966: LD_VAR 0 10
44970: PPUSH
44971: CALL_OW 296
44975: PUSH
44976: LD_INT 10
44978: GREATER
44979: IFFALSE 44995
// ComStandNearbyBuilding ( unit , depot ) ;
44981: LD_VAR 0 3
44985: PPUSH
44986: LD_VAR 0 10
44990: PPUSH
44991: CALL 53595 0 2
// end ; end ; end ;
44995: LD_VAR 0 5
44999: RET
// export function MC_Idle ( ) ; var i , j , tmp ; begin
45000: LD_INT 0
45002: PPUSH
45003: PPUSH
45004: PPUSH
45005: PPUSH
// if not mc_bases then
45006: LD_EXP 95
45010: NOT
45011: IFFALSE 45015
// exit ;
45013: GO 45254
// for i = 1 to mc_bases do
45015: LD_ADDR_VAR 0 2
45019: PUSH
45020: DOUBLE
45021: LD_INT 1
45023: DEC
45024: ST_TO_ADDR
45025: LD_EXP 95
45029: PUSH
45030: FOR_TO
45031: IFFALSE 45252
// begin tmp := UnitFilter ( mc_bases [ i ] , [ f_type , unit_human ] ) union mc_ape [ i ] ;
45033: LD_ADDR_VAR 0 4
45037: PUSH
45038: LD_EXP 95
45042: PUSH
45043: LD_VAR 0 2
45047: ARRAY
45048: PPUSH
45049: LD_INT 21
45051: PUSH
45052: LD_INT 1
45054: PUSH
45055: EMPTY
45056: LIST
45057: LIST
45058: PPUSH
45059: CALL_OW 72
45063: PUSH
45064: LD_EXP 124
45068: PUSH
45069: LD_VAR 0 2
45073: ARRAY
45074: UNION
45075: ST_TO_ADDR
// if not tmp then
45076: LD_VAR 0 4
45080: NOT
45081: IFFALSE 45085
// continue ;
45083: GO 45030
// for j in tmp do
45085: LD_ADDR_VAR 0 3
45089: PUSH
45090: LD_VAR 0 4
45094: PUSH
45095: FOR_IN
45096: IFFALSE 45248
// begin if not GetTag ( j ) and not HasTask ( j ) and not IsDrivenBy ( j ) and not IsInUnit ( j ) and not j in mc_need_heal [ i ] [ 1 ] and not j in mc_need_heal [ i ] [ 2 ] and not j in mc_repair_vehicle [ i ] then
45098: LD_VAR 0 3
45102: PPUSH
45103: CALL_OW 110
45107: NOT
45108: PUSH
45109: LD_VAR 0 3
45113: PPUSH
45114: CALL_OW 314
45118: NOT
45119: AND
45120: PUSH
45121: LD_VAR 0 3
45125: PPUSH
45126: CALL_OW 311
45130: NOT
45131: AND
45132: PUSH
45133: LD_VAR 0 3
45137: PPUSH
45138: CALL_OW 310
45142: NOT
45143: AND
45144: PUSH
45145: LD_VAR 0 3
45149: PUSH
45150: LD_EXP 98
45154: PUSH
45155: LD_VAR 0 2
45159: ARRAY
45160: PUSH
45161: LD_INT 1
45163: ARRAY
45164: IN
45165: NOT
45166: AND
45167: PUSH
45168: LD_VAR 0 3
45172: PUSH
45173: LD_EXP 98
45177: PUSH
45178: LD_VAR 0 2
45182: ARRAY
45183: PUSH
45184: LD_INT 2
45186: ARRAY
45187: IN
45188: NOT
45189: AND
45190: PUSH
45191: LD_VAR 0 3
45195: PUSH
45196: LD_EXP 107
45200: PUSH
45201: LD_VAR 0 2
45205: ARRAY
45206: IN
45207: NOT
45208: AND
45209: IFFALSE 45246
// MC_Back ( i , mc_bases [ i ] , j , GetClass ( j ) ) ;
45211: LD_VAR 0 2
45215: PPUSH
45216: LD_EXP 95
45220: PUSH
45221: LD_VAR 0 2
45225: ARRAY
45226: PPUSH
45227: LD_VAR 0 3
45231: PPUSH
45232: LD_VAR 0 3
45236: PPUSH
45237: CALL_OW 257
45241: PPUSH
45242: CALL 44018 0 4
// end ;
45246: GO 45095
45248: POP
45249: POP
// end ;
45250: GO 45030
45252: POP
45253: POP
// end ;
45254: LD_VAR 0 1
45258: RET
// export function MC_SetMinesField ( base , amount , area ) ; var i , tmp , list , x , j ; begin
45259: LD_INT 0
45261: PPUSH
45262: PPUSH
45263: PPUSH
45264: PPUSH
45265: PPUSH
45266: PPUSH
// if not mc_bases [ base ] then
45267: LD_EXP 95
45271: PUSH
45272: LD_VAR 0 1
45276: ARRAY
45277: NOT
45278: IFFALSE 45282
// exit ;
45280: GO 45464
// tmp := [ ] ;
45282: LD_ADDR_VAR 0 6
45286: PUSH
45287: EMPTY
45288: ST_TO_ADDR
// list := AreaToList ( area , 0 ) ;
45289: LD_ADDR_VAR 0 7
45293: PUSH
45294: LD_VAR 0 3
45298: PPUSH
45299: LD_INT 0
45301: PPUSH
45302: CALL_OW 517
45306: ST_TO_ADDR
// if not list then
45307: LD_VAR 0 7
45311: NOT
45312: IFFALSE 45316
// exit ;
45314: GO 45464
// for i = 1 to amount do
45316: LD_ADDR_VAR 0 5
45320: PUSH
45321: DOUBLE
45322: LD_INT 1
45324: DEC
45325: ST_TO_ADDR
45326: LD_VAR 0 2
45330: PUSH
45331: FOR_TO
45332: IFFALSE 45412
// begin x := rand ( 1 , list [ 1 ] ) ;
45334: LD_ADDR_VAR 0 8
45338: PUSH
45339: LD_INT 1
45341: PPUSH
45342: LD_VAR 0 7
45346: PUSH
45347: LD_INT 1
45349: ARRAY
45350: PPUSH
45351: CALL_OW 12
45355: ST_TO_ADDR
// tmp := Replace ( tmp , i , [ list [ 1 ] [ x ] , list [ 2 ] [ x ] ] ) ;
45356: LD_ADDR_VAR 0 6
45360: PUSH
45361: LD_VAR 0 6
45365: PPUSH
45366: LD_VAR 0 5
45370: PPUSH
45371: LD_VAR 0 7
45375: PUSH
45376: LD_INT 1
45378: ARRAY
45379: PUSH
45380: LD_VAR 0 8
45384: ARRAY
45385: PUSH
45386: LD_VAR 0 7
45390: PUSH
45391: LD_INT 2
45393: ARRAY
45394: PUSH
45395: LD_VAR 0 8
45399: ARRAY
45400: PUSH
45401: EMPTY
45402: LIST
45403: LIST
45404: PPUSH
45405: CALL_OW 1
45409: ST_TO_ADDR
// end ;
45410: GO 45331
45412: POP
45413: POP
// mc_mines := Replace ( mc_mines , base , tmp ) ;
45414: LD_ADDR_EXP 108
45418: PUSH
45419: LD_EXP 108
45423: PPUSH
45424: LD_VAR 0 1
45428: PPUSH
45429: LD_VAR 0 6
45433: PPUSH
45434: CALL_OW 1
45438: ST_TO_ADDR
// mc_minefields := Replace ( mc_minefields , base , area ) ;
45439: LD_ADDR_EXP 110
45443: PUSH
45444: LD_EXP 110
45448: PPUSH
45449: LD_VAR 0 1
45453: PPUSH
45454: LD_VAR 0 3
45458: PPUSH
45459: CALL_OW 1
45463: ST_TO_ADDR
// end ;
45464: LD_VAR 0 4
45468: RET
// export function MC_SetBuildingList ( base , construct_list ) ; begin
45469: LD_INT 0
45471: PPUSH
// if not mc_bases [ base ] then
45472: LD_EXP 95
45476: PUSH
45477: LD_VAR 0 1
45481: ARRAY
45482: NOT
45483: IFFALSE 45487
// exit ;
45485: GO 45512
// mc_build_list := Replace ( mc_build_list , base , construct_list ) ;
45487: LD_ADDR_EXP 100
45491: PUSH
45492: LD_EXP 100
45496: PPUSH
45497: LD_VAR 0 1
45501: PPUSH
45502: LD_VAR 0 2
45506: PPUSH
45507: CALL_OW 1
45511: ST_TO_ADDR
// end ;
45512: LD_VAR 0 3
45516: RET
// export function MC_InsertBuildingList ( base , list ) ; begin
45517: LD_INT 0
45519: PPUSH
// if not mc_bases [ base ] then
45520: LD_EXP 95
45524: PUSH
45525: LD_VAR 0 1
45529: ARRAY
45530: NOT
45531: IFFALSE 45535
// exit ;
45533: GO 45572
// mc_build_list := Replace ( mc_build_list , base , mc_build_list [ base ] union list ) ;
45535: LD_ADDR_EXP 100
45539: PUSH
45540: LD_EXP 100
45544: PPUSH
45545: LD_VAR 0 1
45549: PPUSH
45550: LD_EXP 100
45554: PUSH
45555: LD_VAR 0 1
45559: ARRAY
45560: PUSH
45561: LD_VAR 0 2
45565: UNION
45566: PPUSH
45567: CALL_OW 1
45571: ST_TO_ADDR
// end ;
45572: LD_VAR 0 3
45576: RET
// export function MC_SetProduceList ( base , produce_list ) ; begin
45577: LD_INT 0
45579: PPUSH
// if not mc_bases [ base ] then
45580: LD_EXP 95
45584: PUSH
45585: LD_VAR 0 1
45589: ARRAY
45590: NOT
45591: IFFALSE 45595
// exit ;
45593: GO 45620
// mc_produce := Replace ( mc_produce , base , produce_list ) ;
45595: LD_ADDR_EXP 116
45599: PUSH
45600: LD_EXP 116
45604: PPUSH
45605: LD_VAR 0 1
45609: PPUSH
45610: LD_VAR 0 2
45614: PPUSH
45615: CALL_OW 1
45619: ST_TO_ADDR
// end ;
45620: LD_VAR 0 3
45624: RET
// export function MC_InsertProduceList ( base , components ) ; begin
45625: LD_INT 0
45627: PPUSH
// if not mc_bases [ base ] then
45628: LD_EXP 95
45632: PUSH
45633: LD_VAR 0 1
45637: ARRAY
45638: NOT
45639: IFFALSE 45643
// exit ;
45641: GO 45680
// mc_produce := Replace ( mc_produce , base , mc_produce [ base ] ^ components ) ;
45643: LD_ADDR_EXP 116
45647: PUSH
45648: LD_EXP 116
45652: PPUSH
45653: LD_VAR 0 1
45657: PPUSH
45658: LD_EXP 116
45662: PUSH
45663: LD_VAR 0 1
45667: ARRAY
45668: PUSH
45669: LD_VAR 0 2
45673: ADD
45674: PPUSH
45675: CALL_OW 1
45679: ST_TO_ADDR
// end ;
45680: LD_VAR 0 3
45684: RET
// export function MC_SetDefenderList ( base , deflist ) ; begin
45685: LD_INT 0
45687: PPUSH
// if not mc_bases [ base ] then
45688: LD_EXP 95
45692: PUSH
45693: LD_VAR 0 1
45697: ARRAY
45698: NOT
45699: IFFALSE 45703
// exit ;
45701: GO 45757
// mc_defender := Replace ( mc_defender , base , deflist ) ;
45703: LD_ADDR_EXP 117
45707: PUSH
45708: LD_EXP 117
45712: PPUSH
45713: LD_VAR 0 1
45717: PPUSH
45718: LD_VAR 0 2
45722: PPUSH
45723: CALL_OW 1
45727: ST_TO_ADDR
// mc_defender_limit := Replace ( mc_defender_limit , base , deflist + 0 ) ;
45728: LD_ADDR_EXP 106
45732: PUSH
45733: LD_EXP 106
45737: PPUSH
45738: LD_VAR 0 1
45742: PPUSH
45743: LD_VAR 0 2
45747: PUSH
45748: LD_INT 0
45750: PLUS
45751: PPUSH
45752: CALL_OW 1
45756: ST_TO_ADDR
// end ;
45757: LD_VAR 0 3
45761: RET
// export function MC_SetDefenderLimit ( base , limit ) ; begin
45762: LD_INT 0
45764: PPUSH
// if not mc_bases [ base ] then
45765: LD_EXP 95
45769: PUSH
45770: LD_VAR 0 1
45774: ARRAY
45775: NOT
45776: IFFALSE 45780
// exit ;
45778: GO 45805
// mc_defender_limit := Replace ( mc_defender_limit , base , limit ) ;
45780: LD_ADDR_EXP 106
45784: PUSH
45785: LD_EXP 106
45789: PPUSH
45790: LD_VAR 0 1
45794: PPUSH
45795: LD_VAR 0 2
45799: PPUSH
45800: CALL_OW 1
45804: ST_TO_ADDR
// end ;
45805: LD_VAR 0 3
45809: RET
// export function MC_PrepareAttack ( base , group , path , flags ) ; var i , j , tmp ; begin
45810: LD_INT 0
45812: PPUSH
45813: PPUSH
45814: PPUSH
45815: PPUSH
// if not mc_bases [ base ] then
45816: LD_EXP 95
45820: PUSH
45821: LD_VAR 0 1
45825: ARRAY
45826: NOT
45827: IFFALSE 45831
// exit ;
45829: GO 45896
// mc_attack := ReplaceIn ( mc_attack , [ base , mc_attack [ base ] + 1 ] , [ base , group , path , flags ] ) ;
45831: LD_ADDR_EXP 115
45835: PUSH
45836: LD_EXP 115
45840: PPUSH
45841: LD_VAR 0 1
45845: PUSH
45846: LD_EXP 115
45850: PUSH
45851: LD_VAR 0 1
45855: ARRAY
45856: PUSH
45857: LD_INT 1
45859: PLUS
45860: PUSH
45861: EMPTY
45862: LIST
45863: LIST
45864: PPUSH
45865: LD_VAR 0 1
45869: PUSH
45870: LD_VAR 0 2
45874: PUSH
45875: LD_VAR 0 3
45879: PUSH
45880: LD_VAR 0 4
45884: PUSH
45885: EMPTY
45886: LIST
45887: LIST
45888: LIST
45889: LIST
45890: PPUSH
45891: CALL 57017 0 3
45895: ST_TO_ADDR
// end ;
45896: LD_VAR 0 5
45900: RET
// export function MC_SetDepositsXY ( base , deposits_list ) ; begin
45901: LD_INT 0
45903: PPUSH
// if not mc_bases [ base ] then
45904: LD_EXP 95
45908: PUSH
45909: LD_VAR 0 1
45913: ARRAY
45914: NOT
45915: IFFALSE 45919
// exit ;
45917: GO 45944
// mc_deposits_xy := Replace ( mc_deposits_xy , base , deposits_list ) ;
45919: LD_ADDR_EXP 132
45923: PUSH
45924: LD_EXP 132
45928: PPUSH
45929: LD_VAR 0 1
45933: PPUSH
45934: LD_VAR 0 2
45938: PPUSH
45939: CALL_OW 1
45943: ST_TO_ADDR
// end ;
45944: LD_VAR 0 3
45948: RET
// export function MC_GetMinesField ( base ) ; begin
45949: LD_INT 0
45951: PPUSH
// result := mc_mines [ base ] ;
45952: LD_ADDR_VAR 0 2
45956: PUSH
45957: LD_EXP 108
45961: PUSH
45962: LD_VAR 0 1
45966: ARRAY
45967: ST_TO_ADDR
// end ;
45968: LD_VAR 0 2
45972: RET
// export function MC_GetProduceList ( base ) ; begin
45973: LD_INT 0
45975: PPUSH
// result := mc_produce [ base ] ;
45976: LD_ADDR_VAR 0 2
45980: PUSH
45981: LD_EXP 116
45985: PUSH
45986: LD_VAR 0 1
45990: ARRAY
45991: ST_TO_ADDR
// end ;
45992: LD_VAR 0 2
45996: RET
// export function MC_GetBuilding ( base , btype ) ; var i ; begin
45997: LD_INT 0
45999: PPUSH
46000: PPUSH
// if not mc_bases then
46001: LD_EXP 95
46005: NOT
46006: IFFALSE 46010
// exit ;
46008: GO 46075
// if mc_bases [ base ] then
46010: LD_EXP 95
46014: PUSH
46015: LD_VAR 0 1
46019: ARRAY
46020: IFFALSE 46075
// begin result := UnitFilter ( mc_bases [ base ] , [ f_btype , btype ] ) ;
46022: LD_ADDR_VAR 0 3
46026: PUSH
46027: LD_EXP 95
46031: PUSH
46032: LD_VAR 0 1
46036: ARRAY
46037: PPUSH
46038: LD_INT 30
46040: PUSH
46041: LD_VAR 0 2
46045: PUSH
46046: EMPTY
46047: LIST
46048: LIST
46049: PPUSH
46050: CALL_OW 72
46054: ST_TO_ADDR
// if result then
46055: LD_VAR 0 3
46059: IFFALSE 46075
// result := result [ 1 ] ;
46061: LD_ADDR_VAR 0 3
46065: PUSH
46066: LD_VAR 0 3
46070: PUSH
46071: LD_INT 1
46073: ARRAY
46074: ST_TO_ADDR
// end ; end ;
46075: LD_VAR 0 3
46079: RET
// export function MC_GetBuildings ( base , btype ) ; var i ; begin
46080: LD_INT 0
46082: PPUSH
46083: PPUSH
// if not mc_bases then
46084: LD_EXP 95
46088: NOT
46089: IFFALSE 46093
// exit ;
46091: GO 46138
// if mc_bases [ base ] then
46093: LD_EXP 95
46097: PUSH
46098: LD_VAR 0 1
46102: ARRAY
46103: IFFALSE 46138
// result := UnitFilter ( mc_bases [ base ] , [ f_btype , btype ] ) ;
46105: LD_ADDR_VAR 0 3
46109: PUSH
46110: LD_EXP 95
46114: PUSH
46115: LD_VAR 0 1
46119: ARRAY
46120: PPUSH
46121: LD_INT 30
46123: PUSH
46124: LD_VAR 0 2
46128: PUSH
46129: EMPTY
46130: LIST
46131: LIST
46132: PPUSH
46133: CALL_OW 72
46137: ST_TO_ADDR
// end ;
46138: LD_VAR 0 3
46142: RET
// export function MC_SetTame ( base , area ) ; begin
46143: LD_INT 0
46145: PPUSH
// if not mc_bases or not base then
46146: LD_EXP 95
46150: NOT
46151: PUSH
46152: LD_VAR 0 1
46156: NOT
46157: OR
46158: IFFALSE 46162
// exit ;
46160: GO 46187
// mc_can_tame := Replace ( mc_can_tame , base , area ) ;
46162: LD_ADDR_EXP 123
46166: PUSH
46167: LD_EXP 123
46171: PPUSH
46172: LD_VAR 0 1
46176: PPUSH
46177: LD_VAR 0 2
46181: PPUSH
46182: CALL_OW 1
46186: ST_TO_ADDR
// end ;
46187: LD_VAR 0 3
46191: RET
// export function MC_SetUpgradeBuilding ( base , btype ) ; var tmp ; begin
46192: LD_INT 0
46194: PPUSH
46195: PPUSH
// if not mc_bases or not base then
46196: LD_EXP 95
46200: NOT
46201: PUSH
46202: LD_VAR 0 1
46206: NOT
46207: OR
46208: IFFALSE 46212
// exit ;
46210: GO 46314
// tmp := UnitFilter ( mc_bases [ base ] , [ f_btype , btype ] ) ;
46212: LD_ADDR_VAR 0 4
46216: PUSH
46217: LD_EXP 95
46221: PUSH
46222: LD_VAR 0 1
46226: ARRAY
46227: PPUSH
46228: LD_INT 30
46230: PUSH
46231: LD_VAR 0 2
46235: PUSH
46236: EMPTY
46237: LIST
46238: LIST
46239: PPUSH
46240: CALL_OW 72
46244: ST_TO_ADDR
// if not tmp then
46245: LD_VAR 0 4
46249: NOT
46250: IFFALSE 46254
// exit ;
46252: GO 46314
// mc_build_upgrade := Replace ( mc_build_upgrade , base , Insert ( mc_build_upgrade [ base ] , mc_build_upgrade [ base ] + 1 , tmp [ 1 ] ) ) ;
46254: LD_ADDR_EXP 127
46258: PUSH
46259: LD_EXP 127
46263: PPUSH
46264: LD_VAR 0 1
46268: PPUSH
46269: LD_EXP 127
46273: PUSH
46274: LD_VAR 0 1
46278: ARRAY
46279: PPUSH
46280: LD_EXP 127
46284: PUSH
46285: LD_VAR 0 1
46289: ARRAY
46290: PUSH
46291: LD_INT 1
46293: PLUS
46294: PPUSH
46295: LD_VAR 0 4
46299: PUSH
46300: LD_INT 1
46302: ARRAY
46303: PPUSH
46304: CALL_OW 2
46308: PPUSH
46309: CALL_OW 1
46313: ST_TO_ADDR
// end ;
46314: LD_VAR 0 3
46318: RET
// export function MC_SetLabKind ( base , kinds ) ; var i ; begin
46319: LD_INT 0
46321: PPUSH
46322: PPUSH
// if not mc_bases or not base or not kinds then
46323: LD_EXP 95
46327: NOT
46328: PUSH
46329: LD_VAR 0 1
46333: NOT
46334: OR
46335: PUSH
46336: LD_VAR 0 2
46340: NOT
46341: OR
46342: IFFALSE 46346
// exit ;
46344: GO 46407
// for i in kinds do
46346: LD_ADDR_VAR 0 4
46350: PUSH
46351: LD_VAR 0 2
46355: PUSH
46356: FOR_IN
46357: IFFALSE 46405
// mc_lab_upgrade := ReplaceIn ( mc_lab_upgrade , [ base , mc_lab_upgrade [ base ] + 1 ] , i ) ;
46359: LD_ADDR_EXP 129
46363: PUSH
46364: LD_EXP 129
46368: PPUSH
46369: LD_VAR 0 1
46373: PUSH
46374: LD_EXP 129
46378: PUSH
46379: LD_VAR 0 1
46383: ARRAY
46384: PUSH
46385: LD_INT 1
46387: PLUS
46388: PUSH
46389: EMPTY
46390: LIST
46391: LIST
46392: PPUSH
46393: LD_VAR 0 4
46397: PPUSH
46398: CALL 57017 0 3
46402: ST_TO_ADDR
46403: GO 46356
46405: POP
46406: POP
// end ;
46407: LD_VAR 0 3
46411: RET
// export function MC_SetCratesArea ( base , areas ) ; begin
46412: LD_INT 0
46414: PPUSH
// if not mc_bases or not base or not areas then
46415: LD_EXP 95
46419: NOT
46420: PUSH
46421: LD_VAR 0 1
46425: NOT
46426: OR
46427: PUSH
46428: LD_VAR 0 2
46432: NOT
46433: OR
46434: IFFALSE 46438
// exit ;
46436: GO 46463
// mc_crates_area := Replace ( mc_crates_area , base , areas ) ;
46438: LD_ADDR_EXP 113
46442: PUSH
46443: LD_EXP 113
46447: PPUSH
46448: LD_VAR 0 1
46452: PPUSH
46453: LD_VAR 0 2
46457: PPUSH
46458: CALL_OW 1
46462: ST_TO_ADDR
// end ;
46463: LD_VAR 0 3
46467: RET
// export function MC_SetTeleportExit ( base , teleports_exit ) ; begin
46468: LD_INT 0
46470: PPUSH
// if not mc_bases or not base or not teleports_exit then
46471: LD_EXP 95
46475: NOT
46476: PUSH
46477: LD_VAR 0 1
46481: NOT
46482: OR
46483: PUSH
46484: LD_VAR 0 2
46488: NOT
46489: OR
46490: IFFALSE 46494
// exit ;
46492: GO 46519
// mc_teleport_exit := Replace ( mc_teleport_exit , base , teleports_exit ) ;
46494: LD_ADDR_EXP 130
46498: PUSH
46499: LD_EXP 130
46503: PPUSH
46504: LD_VAR 0 1
46508: PPUSH
46509: LD_VAR 0 2
46513: PPUSH
46514: CALL_OW 1
46518: ST_TO_ADDR
// end ;
46519: LD_VAR 0 3
46523: RET
// export function MC_SetFactoryExtension ( base , x , y , d , ext_list ) ; var i , tmp ; begin
46524: LD_INT 0
46526: PPUSH
46527: PPUSH
46528: PPUSH
// if not mc_bases or not base or not ext_list then
46529: LD_EXP 95
46533: NOT
46534: PUSH
46535: LD_VAR 0 1
46539: NOT
46540: OR
46541: PUSH
46542: LD_VAR 0 5
46546: NOT
46547: OR
46548: IFFALSE 46552
// exit ;
46550: GO 46725
// tmp := GetFacExtXYD ( x , y , d ) ;
46552: LD_ADDR_VAR 0 8
46556: PUSH
46557: LD_VAR 0 2
46561: PPUSH
46562: LD_VAR 0 3
46566: PPUSH
46567: LD_VAR 0 4
46571: PPUSH
46572: CALL 86351 0 3
46576: ST_TO_ADDR
// if not tmp then
46577: LD_VAR 0 8
46581: NOT
46582: IFFALSE 46586
// exit ;
46584: GO 46725
// for i in tmp do
46586: LD_ADDR_VAR 0 7
46590: PUSH
46591: LD_VAR 0 8
46595: PUSH
46596: FOR_IN
46597: IFFALSE 46723
// begin mc_build_list := Replace ( mc_build_list , base , Insert ( mc_build_list [ base ] , mc_build_list [ base ] + 1 , [ ext_list [ 1 ] , i [ 1 ] , i [ 2 ] , i [ 3 ] ] ) ) ;
46599: LD_ADDR_EXP 100
46603: PUSH
46604: LD_EXP 100
46608: PPUSH
46609: LD_VAR 0 1
46613: PPUSH
46614: LD_EXP 100
46618: PUSH
46619: LD_VAR 0 1
46623: ARRAY
46624: PPUSH
46625: LD_EXP 100
46629: PUSH
46630: LD_VAR 0 1
46634: ARRAY
46635: PUSH
46636: LD_INT 1
46638: PLUS
46639: PPUSH
46640: LD_VAR 0 5
46644: PUSH
46645: LD_INT 1
46647: ARRAY
46648: PUSH
46649: LD_VAR 0 7
46653: PUSH
46654: LD_INT 1
46656: ARRAY
46657: PUSH
46658: LD_VAR 0 7
46662: PUSH
46663: LD_INT 2
46665: ARRAY
46666: PUSH
46667: LD_VAR 0 7
46671: PUSH
46672: LD_INT 3
46674: ARRAY
46675: PUSH
46676: EMPTY
46677: LIST
46678: LIST
46679: LIST
46680: LIST
46681: PPUSH
46682: CALL_OW 2
46686: PPUSH
46687: CALL_OW 1
46691: ST_TO_ADDR
// ext_list := Delete ( ext_list , 1 ) ;
46692: LD_ADDR_VAR 0 5
46696: PUSH
46697: LD_VAR 0 5
46701: PPUSH
46702: LD_INT 1
46704: PPUSH
46705: CALL_OW 3
46709: ST_TO_ADDR
// if not ext_list then
46710: LD_VAR 0 5
46714: NOT
46715: IFFALSE 46721
// exit ;
46717: POP
46718: POP
46719: GO 46725
// end ;
46721: GO 46596
46723: POP
46724: POP
// end ;
46725: LD_VAR 0 6
46729: RET
// export function MC_SetAllowedTurretWeapons ( base , weapon_list ) ; begin
46730: LD_INT 0
46732: PPUSH
// if not mc_bases or not base or not weapon_list then
46733: LD_EXP 95
46737: NOT
46738: PUSH
46739: LD_VAR 0 1
46743: NOT
46744: OR
46745: PUSH
46746: LD_VAR 0 2
46750: NOT
46751: OR
46752: IFFALSE 46756
// exit ;
46754: GO 46781
// mc_allowed_tower_weapons := Replace ( mc_allowed_tower_weapons , base , weapon_list ) ;
46756: LD_ADDR_EXP 134
46760: PUSH
46761: LD_EXP 134
46765: PPUSH
46766: LD_VAR 0 1
46770: PPUSH
46771: LD_VAR 0 2
46775: PPUSH
46776: CALL_OW 1
46780: ST_TO_ADDR
// end ;
46781: LD_VAR 0 3
46785: RET
// export function MC_SetTechList ( base , tech_list ) ; begin
46786: LD_INT 0
46788: PPUSH
// if not mc_bases or not base or not tech_list then
46789: LD_EXP 95
46793: NOT
46794: PUSH
46795: LD_VAR 0 1
46799: NOT
46800: OR
46801: PUSH
46802: LD_VAR 0 2
46806: NOT
46807: OR
46808: IFFALSE 46812
// exit ;
46810: GO 46837
// mc_tech := Replace ( mc_tech , base , tech_list ) ;
46812: LD_ADDR_EXP 122
46816: PUSH
46817: LD_EXP 122
46821: PPUSH
46822: LD_VAR 0 1
46826: PPUSH
46827: LD_VAR 0 2
46831: PPUSH
46832: CALL_OW 1
46836: ST_TO_ADDR
// end ;
46837: LD_VAR 0 3
46841: RET
// export function MC_SetParkingArea ( base , parking_area ) ; begin
46842: LD_INT 0
46844: PPUSH
// if not mc_bases or not parking_area or not base then
46845: LD_EXP 95
46849: NOT
46850: PUSH
46851: LD_VAR 0 2
46855: NOT
46856: OR
46857: PUSH
46858: LD_VAR 0 1
46862: NOT
46863: OR
46864: IFFALSE 46868
// exit ;
46866: GO 46893
// mc_parking := Replace ( mc_parking , base , parking_area ) ;
46868: LD_ADDR_EXP 119
46872: PUSH
46873: LD_EXP 119
46877: PPUSH
46878: LD_VAR 0 1
46882: PPUSH
46883: LD_VAR 0 2
46887: PPUSH
46888: CALL_OW 1
46892: ST_TO_ADDR
// end ;
46893: LD_VAR 0 3
46897: RET
// export function MC_SetScanArea ( base , scan_area ) ; begin
46898: LD_INT 0
46900: PPUSH
// if not mc_bases or not base or not scan_area then
46901: LD_EXP 95
46905: NOT
46906: PUSH
46907: LD_VAR 0 1
46911: NOT
46912: OR
46913: PUSH
46914: LD_VAR 0 2
46918: NOT
46919: OR
46920: IFFALSE 46924
// exit ;
46922: GO 46949
// mc_scan_area := Replace ( mc_scan_area , base , scan_area ) ;
46924: LD_ADDR_EXP 120
46928: PUSH
46929: LD_EXP 120
46933: PPUSH
46934: LD_VAR 0 1
46938: PPUSH
46939: LD_VAR 0 2
46943: PPUSH
46944: CALL_OW 1
46948: ST_TO_ADDR
// end ;
46949: LD_VAR 0 3
46953: RET
// export function MC_NotTameApeman ( base ) ; var ape_techs ; begin
46954: LD_INT 0
46956: PPUSH
46957: PPUSH
// if not mc_bases or not base then
46958: LD_EXP 95
46962: NOT
46963: PUSH
46964: LD_VAR 0 1
46968: NOT
46969: OR
46970: IFFALSE 46974
// exit ;
46972: GO 47038
// ape_techs := [ 1 , 2 , 3 , 4 , 11 ] ;
46974: LD_ADDR_VAR 0 3
46978: PUSH
46979: LD_INT 1
46981: PUSH
46982: LD_INT 2
46984: PUSH
46985: LD_INT 3
46987: PUSH
46988: LD_INT 4
46990: PUSH
46991: LD_INT 11
46993: PUSH
46994: EMPTY
46995: LIST
46996: LIST
46997: LIST
46998: LIST
46999: LIST
47000: ST_TO_ADDR
// mc_tech := Replace ( mc_tech , base , mc_tech [ base ] diff ape_techs ) ;
47001: LD_ADDR_EXP 122
47005: PUSH
47006: LD_EXP 122
47010: PPUSH
47011: LD_VAR 0 1
47015: PPUSH
47016: LD_EXP 122
47020: PUSH
47021: LD_VAR 0 1
47025: ARRAY
47026: PUSH
47027: LD_VAR 0 3
47031: DIFF
47032: PPUSH
47033: CALL_OW 1
47037: ST_TO_ADDR
// end ;
47038: LD_VAR 0 2
47042: RET
// export function MC_GetVehicles ( base , onlyCombat ) ; begin
47043: LD_INT 0
47045: PPUSH
// result := mc_vehicles [ base ] ;
47046: LD_ADDR_VAR 0 3
47050: PUSH
47051: LD_EXP 114
47055: PUSH
47056: LD_VAR 0 1
47060: ARRAY
47061: ST_TO_ADDR
// if onlyCombat then
47062: LD_VAR 0 2
47066: IFFALSE 47244
// result := result diff UnitFilter ( result , [ f_or , [ f_weapon , us_cargo_bay ] , [ f_weapon , ru_cargo_bay ] , [ f_weapon , ru_big_cargo_bay ] , [ f_weapon , ar_cargo_bay ] , [ f_weapon , us_crane ] , [ f_weapon , ru_crane ] , [ f_weapon , ar_crane ] , [ f_weapon , us_bulldozer ] , [ f_weapon , ru_bulldozer ] , [ f_weapon , ru_radar ] , [ f_weapon , ar_control_tower ] , [ f_weapon , ru_siberium_rocket ] , [ f_weapon , us_siberium_rocket ] ] ) ;
47068: LD_ADDR_VAR 0 3
47072: PUSH
47073: LD_VAR 0 3
47077: PUSH
47078: LD_VAR 0 3
47082: PPUSH
47083: LD_INT 2
47085: PUSH
47086: LD_INT 34
47088: PUSH
47089: LD_INT 12
47091: PUSH
47092: EMPTY
47093: LIST
47094: LIST
47095: PUSH
47096: LD_INT 34
47098: PUSH
47099: LD_INT 51
47101: PUSH
47102: EMPTY
47103: LIST
47104: LIST
47105: PUSH
47106: LD_INT 34
47108: PUSH
47109: LD_EXP 75
47113: PUSH
47114: EMPTY
47115: LIST
47116: LIST
47117: PUSH
47118: LD_INT 34
47120: PUSH
47121: LD_INT 32
47123: PUSH
47124: EMPTY
47125: LIST
47126: LIST
47127: PUSH
47128: LD_INT 34
47130: PUSH
47131: LD_INT 13
47133: PUSH
47134: EMPTY
47135: LIST
47136: LIST
47137: PUSH
47138: LD_INT 34
47140: PUSH
47141: LD_INT 52
47143: PUSH
47144: EMPTY
47145: LIST
47146: LIST
47147: PUSH
47148: LD_INT 34
47150: PUSH
47151: LD_EXP 80
47155: PUSH
47156: EMPTY
47157: LIST
47158: LIST
47159: PUSH
47160: LD_INT 34
47162: PUSH
47163: LD_INT 14
47165: PUSH
47166: EMPTY
47167: LIST
47168: LIST
47169: PUSH
47170: LD_INT 34
47172: PUSH
47173: LD_INT 53
47175: PUSH
47176: EMPTY
47177: LIST
47178: LIST
47179: PUSH
47180: LD_INT 34
47182: PUSH
47183: LD_EXP 74
47187: PUSH
47188: EMPTY
47189: LIST
47190: LIST
47191: PUSH
47192: LD_INT 34
47194: PUSH
47195: LD_INT 31
47197: PUSH
47198: EMPTY
47199: LIST
47200: LIST
47201: PUSH
47202: LD_INT 34
47204: PUSH
47205: LD_INT 48
47207: PUSH
47208: EMPTY
47209: LIST
47210: LIST
47211: PUSH
47212: LD_INT 34
47214: PUSH
47215: LD_INT 8
47217: PUSH
47218: EMPTY
47219: LIST
47220: LIST
47221: PUSH
47222: EMPTY
47223: LIST
47224: LIST
47225: LIST
47226: LIST
47227: LIST
47228: LIST
47229: LIST
47230: LIST
47231: LIST
47232: LIST
47233: LIST
47234: LIST
47235: LIST
47236: LIST
47237: PPUSH
47238: CALL_OW 72
47242: DIFF
47243: ST_TO_ADDR
// end ; end_of_file
47244: LD_VAR 0 3
47248: RET
// export function MCE_ApemanTamed ( ape , sci ) ; var i , tmp ; begin
47249: LD_INT 0
47251: PPUSH
47252: PPUSH
47253: PPUSH
// if not mc_bases or not skirmish then
47254: LD_EXP 95
47258: NOT
47259: PUSH
47260: LD_EXP 93
47264: NOT
47265: OR
47266: IFFALSE 47270
// exit ;
47268: GO 47435
// for i = 1 to mc_bases do
47270: LD_ADDR_VAR 0 4
47274: PUSH
47275: DOUBLE
47276: LD_INT 1
47278: DEC
47279: ST_TO_ADDR
47280: LD_EXP 95
47284: PUSH
47285: FOR_TO
47286: IFFALSE 47433
// begin if sci in mc_bases [ i ] then
47288: LD_VAR 0 2
47292: PUSH
47293: LD_EXP 95
47297: PUSH
47298: LD_VAR 0 4
47302: ARRAY
47303: IN
47304: IFFALSE 47431
// begin mc_ape := ReplaceIn ( mc_ape , [ i , mc_ape [ i ] + 1 ] , ape ) ;
47306: LD_ADDR_EXP 124
47310: PUSH
47311: LD_EXP 124
47315: PPUSH
47316: LD_VAR 0 4
47320: PUSH
47321: LD_EXP 124
47325: PUSH
47326: LD_VAR 0 4
47330: ARRAY
47331: PUSH
47332: LD_INT 1
47334: PLUS
47335: PUSH
47336: EMPTY
47337: LIST
47338: LIST
47339: PPUSH
47340: LD_VAR 0 1
47344: PPUSH
47345: CALL 57017 0 3
47349: ST_TO_ADDR
// tmp := NearestUnitToUnit ( UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) , ape ) ;
47350: LD_ADDR_VAR 0 5
47354: PUSH
47355: LD_EXP 95
47359: PUSH
47360: LD_VAR 0 4
47364: ARRAY
47365: PPUSH
47366: LD_INT 2
47368: PUSH
47369: LD_INT 30
47371: PUSH
47372: LD_INT 0
47374: PUSH
47375: EMPTY
47376: LIST
47377: LIST
47378: PUSH
47379: LD_INT 30
47381: PUSH
47382: LD_INT 1
47384: PUSH
47385: EMPTY
47386: LIST
47387: LIST
47388: PUSH
47389: EMPTY
47390: LIST
47391: LIST
47392: LIST
47393: PPUSH
47394: CALL_OW 72
47398: PPUSH
47399: LD_VAR 0 1
47403: PPUSH
47404: CALL_OW 74
47408: ST_TO_ADDR
// if tmp then
47409: LD_VAR 0 5
47413: IFFALSE 47429
// ComStandNearbyBuilding ( ape , tmp ) ;
47415: LD_VAR 0 1
47419: PPUSH
47420: LD_VAR 0 5
47424: PPUSH
47425: CALL 53595 0 2
// break ;
47429: GO 47433
// end ; end ;
47431: GO 47285
47433: POP
47434: POP
// end ;
47435: LD_VAR 0 3
47439: RET
// export function MCE_EnterBuilding ( building , unit ) ; var i , tmp ; begin
47440: LD_INT 0
47442: PPUSH
47443: PPUSH
47444: PPUSH
// if not mc_bases or not skirmish then
47445: LD_EXP 95
47449: NOT
47450: PUSH
47451: LD_EXP 93
47455: NOT
47456: OR
47457: IFFALSE 47461
// exit ;
47459: GO 47550
// for i = 1 to mc_bases do
47461: LD_ADDR_VAR 0 4
47465: PUSH
47466: DOUBLE
47467: LD_INT 1
47469: DEC
47470: ST_TO_ADDR
47471: LD_EXP 95
47475: PUSH
47476: FOR_TO
47477: IFFALSE 47548
// begin if building in mc_busy_turret_list [ i ] then
47479: LD_VAR 0 1
47483: PUSH
47484: LD_EXP 105
47488: PUSH
47489: LD_VAR 0 4
47493: ARRAY
47494: IN
47495: IFFALSE 47546
// begin tmp := mc_busy_turret_list [ i ] diff building ;
47497: LD_ADDR_VAR 0 5
47501: PUSH
47502: LD_EXP 105
47506: PUSH
47507: LD_VAR 0 4
47511: ARRAY
47512: PUSH
47513: LD_VAR 0 1
47517: DIFF
47518: ST_TO_ADDR
// mc_busy_turret_list := Replace ( mc_busy_turret_list , i , tmp ) ;
47519: LD_ADDR_EXP 105
47523: PUSH
47524: LD_EXP 105
47528: PPUSH
47529: LD_VAR 0 4
47533: PPUSH
47534: LD_VAR 0 5
47538: PPUSH
47539: CALL_OW 1
47543: ST_TO_ADDR
// break ;
47544: GO 47548
// end ; end ;
47546: GO 47476
47548: POP
47549: POP
// end ;
47550: LD_VAR 0 3
47554: RET
// export function MCE_BuildingCaptured ( building , side , capturning_unit ) ; var i , tmp ; begin
47555: LD_INT 0
47557: PPUSH
47558: PPUSH
47559: PPUSH
// if not mc_bases or not skirmish then
47560: LD_EXP 95
47564: NOT
47565: PUSH
47566: LD_EXP 93
47570: NOT
47571: OR
47572: IFFALSE 47576
// exit ;
47574: GO 47775
// for i = 1 to mc_bases do
47576: LD_ADDR_VAR 0 5
47580: PUSH
47581: DOUBLE
47582: LD_INT 1
47584: DEC
47585: ST_TO_ADDR
47586: LD_EXP 95
47590: PUSH
47591: FOR_TO
47592: IFFALSE 47773
// if building in mc_bases [ i ] then
47594: LD_VAR 0 1
47598: PUSH
47599: LD_EXP 95
47603: PUSH
47604: LD_VAR 0 5
47608: ARRAY
47609: IN
47610: IFFALSE 47771
// begin tmp := mc_bases [ i ] diff building ;
47612: LD_ADDR_VAR 0 6
47616: PUSH
47617: LD_EXP 95
47621: PUSH
47622: LD_VAR 0 5
47626: ARRAY
47627: PUSH
47628: LD_VAR 0 1
47632: DIFF
47633: ST_TO_ADDR
// mc_bases := Replace ( mc_bases , i , tmp ) ;
47634: LD_ADDR_EXP 95
47638: PUSH
47639: LD_EXP 95
47643: PPUSH
47644: LD_VAR 0 5
47648: PPUSH
47649: LD_VAR 0 6
47653: PPUSH
47654: CALL_OW 1
47658: ST_TO_ADDR
// if building in mc_turret_list [ i ] then
47659: LD_VAR 0 1
47663: PUSH
47664: LD_EXP 103
47668: PUSH
47669: LD_VAR 0 5
47673: ARRAY
47674: IN
47675: IFFALSE 47714
// mc_turret_list := Replace ( mc_turret_list , i , mc_turret_list [ i ] diff building ) ;
47677: LD_ADDR_EXP 103
47681: PUSH
47682: LD_EXP 103
47686: PPUSH
47687: LD_VAR 0 5
47691: PPUSH
47692: LD_EXP 103
47696: PUSH
47697: LD_VAR 0 5
47701: ARRAY
47702: PUSH
47703: LD_VAR 0 1
47707: DIFF
47708: PPUSH
47709: CALL_OW 1
47713: ST_TO_ADDR
// if building in mc_empty_turret_list [ i ] then
47714: LD_VAR 0 1
47718: PUSH
47719: LD_EXP 104
47723: PUSH
47724: LD_VAR 0 5
47728: ARRAY
47729: IN
47730: IFFALSE 47769
// mc_empty_turret_list := Replace ( mc_empty_turret_list , i , mc_empty_turret_list [ i ] diff building ) ;
47732: LD_ADDR_EXP 104
47736: PUSH
47737: LD_EXP 104
47741: PPUSH
47742: LD_VAR 0 5
47746: PPUSH
47747: LD_EXP 104
47751: PUSH
47752: LD_VAR 0 5
47756: ARRAY
47757: PUSH
47758: LD_VAR 0 1
47762: DIFF
47763: PPUSH
47764: CALL_OW 1
47768: ST_TO_ADDR
// break ;
47769: GO 47773
// end ;
47771: GO 47591
47773: POP
47774: POP
// end ;
47775: LD_VAR 0 4
47779: RET
// export function MCE_VehicleCaptured ( new , old , side , capturing_unit ) ; var i , tmp ; begin
47780: LD_INT 0
47782: PPUSH
47783: PPUSH
47784: PPUSH
// if not mc_bases or not skirmish or not side in mc_sides then
47785: LD_EXP 95
47789: NOT
47790: PUSH
47791: LD_EXP 93
47795: NOT
47796: OR
47797: PUSH
47798: LD_VAR 0 3
47802: PUSH
47803: LD_EXP 121
47807: IN
47808: NOT
47809: OR
47810: IFFALSE 47814
// exit ;
47812: GO 47937
// for i = 1 to mc_vehicles do
47814: LD_ADDR_VAR 0 6
47818: PUSH
47819: DOUBLE
47820: LD_INT 1
47822: DEC
47823: ST_TO_ADDR
47824: LD_EXP 114
47828: PUSH
47829: FOR_TO
47830: IFFALSE 47935
// if old in mc_vehicles [ i ] or new in mc_vehicles [ i ] then
47832: LD_VAR 0 2
47836: PUSH
47837: LD_EXP 114
47841: PUSH
47842: LD_VAR 0 6
47846: ARRAY
47847: IN
47848: PUSH
47849: LD_VAR 0 1
47853: PUSH
47854: LD_EXP 114
47858: PUSH
47859: LD_VAR 0 6
47863: ARRAY
47864: IN
47865: OR
47866: IFFALSE 47933
// begin tmp := mc_vehicles [ i ] diff old ;
47868: LD_ADDR_VAR 0 7
47872: PUSH
47873: LD_EXP 114
47877: PUSH
47878: LD_VAR 0 6
47882: ARRAY
47883: PUSH
47884: LD_VAR 0 2
47888: DIFF
47889: ST_TO_ADDR
// tmp := tmp diff new ;
47890: LD_ADDR_VAR 0 7
47894: PUSH
47895: LD_VAR 0 7
47899: PUSH
47900: LD_VAR 0 1
47904: DIFF
47905: ST_TO_ADDR
// mc_vehicles := Replace ( mc_vehicles , i , tmp ) ;
47906: LD_ADDR_EXP 114
47910: PUSH
47911: LD_EXP 114
47915: PPUSH
47916: LD_VAR 0 6
47920: PPUSH
47921: LD_VAR 0 7
47925: PPUSH
47926: CALL_OW 1
47930: ST_TO_ADDR
// break ;
47931: GO 47935
// end ;
47933: GO 47829
47935: POP
47936: POP
// end ;
47937: LD_VAR 0 5
47941: RET
// export function MCE_VehicleConstructed ( vehicle , factory ) ; var i , side , tmp ; begin
47942: LD_INT 0
47944: PPUSH
47945: PPUSH
47946: PPUSH
47947: PPUSH
// if not mc_bases or not skirmish then
47948: LD_EXP 95
47952: NOT
47953: PUSH
47954: LD_EXP 93
47958: NOT
47959: OR
47960: IFFALSE 47964
// exit ;
47962: GO 48356
// side := GetSide ( vehicle ) ;
47964: LD_ADDR_VAR 0 5
47968: PUSH
47969: LD_VAR 0 1
47973: PPUSH
47974: CALL_OW 255
47978: ST_TO_ADDR
// for i = 1 to mc_bases do
47979: LD_ADDR_VAR 0 4
47983: PUSH
47984: DOUBLE
47985: LD_INT 1
47987: DEC
47988: ST_TO_ADDR
47989: LD_EXP 95
47993: PUSH
47994: FOR_TO
47995: IFFALSE 48354
// begin if factory in mc_bases [ i ] then
47997: LD_VAR 0 2
48001: PUSH
48002: LD_EXP 95
48006: PUSH
48007: LD_VAR 0 4
48011: ARRAY
48012: IN
48013: IFFALSE 48352
// begin if mc_defender [ i ] < mc_defender_limit [ i ] and not GetWeapon ( vehicle ) in [ ar_control_tower , ar_cargo_bay , ru_cargo_bay , ru_big_cargo_bay , us_cargo_bay , ar_radar , ru_radar , us_radar , ru_bulldozer , us_bulldozer , ar_bio_bomb , ar_selfpropelled_bomb , us_hack , us_crane , ru_crane , ar_crane , ru_siberium_rocket , us_siberium_rocket ] then
48015: LD_EXP 117
48019: PUSH
48020: LD_VAR 0 4
48024: ARRAY
48025: PUSH
48026: LD_EXP 106
48030: PUSH
48031: LD_VAR 0 4
48035: ARRAY
48036: LESS
48037: PUSH
48038: LD_VAR 0 1
48042: PPUSH
48043: CALL_OW 264
48047: PUSH
48048: LD_INT 31
48050: PUSH
48051: LD_INT 32
48053: PUSH
48054: LD_INT 51
48056: PUSH
48057: LD_EXP 75
48061: PUSH
48062: LD_INT 12
48064: PUSH
48065: LD_INT 30
48067: PUSH
48068: LD_EXP 74
48072: PUSH
48073: LD_INT 11
48075: PUSH
48076: LD_INT 53
48078: PUSH
48079: LD_INT 14
48081: PUSH
48082: LD_EXP 78
48086: PUSH
48087: LD_INT 29
48089: PUSH
48090: LD_EXP 76
48094: PUSH
48095: LD_INT 13
48097: PUSH
48098: LD_INT 52
48100: PUSH
48101: LD_EXP 80
48105: PUSH
48106: LD_INT 48
48108: PUSH
48109: LD_INT 8
48111: PUSH
48112: EMPTY
48113: LIST
48114: LIST
48115: LIST
48116: LIST
48117: LIST
48118: LIST
48119: LIST
48120: LIST
48121: LIST
48122: LIST
48123: LIST
48124: LIST
48125: LIST
48126: LIST
48127: LIST
48128: LIST
48129: LIST
48130: LIST
48131: IN
48132: NOT
48133: AND
48134: IFFALSE 48182
// mc_defender := ReplaceIn ( mc_defender , [ i , mc_defender [ i ] + 1 ] , vehicle ) else
48136: LD_ADDR_EXP 117
48140: PUSH
48141: LD_EXP 117
48145: PPUSH
48146: LD_VAR 0 4
48150: PUSH
48151: LD_EXP 117
48155: PUSH
48156: LD_VAR 0 4
48160: ARRAY
48161: PUSH
48162: LD_INT 1
48164: PLUS
48165: PUSH
48166: EMPTY
48167: LIST
48168: LIST
48169: PPUSH
48170: LD_VAR 0 1
48174: PPUSH
48175: CALL 57017 0 3
48179: ST_TO_ADDR
48180: GO 48226
// mc_vehicles := ReplaceIn ( mc_vehicles , [ i , mc_vehicles [ i ] + 1 ] , vehicle ) ;
48182: LD_ADDR_EXP 114
48186: PUSH
48187: LD_EXP 114
48191: PPUSH
48192: LD_VAR 0 4
48196: PUSH
48197: LD_EXP 114
48201: PUSH
48202: LD_VAR 0 4
48206: ARRAY
48207: PUSH
48208: LD_INT 1
48210: PLUS
48211: PUSH
48212: EMPTY
48213: LIST
48214: LIST
48215: PPUSH
48216: LD_VAR 0 1
48220: PPUSH
48221: CALL 57017 0 3
48225: ST_TO_ADDR
// if GetControl ( vehicle ) = control_remote then
48226: LD_VAR 0 1
48230: PPUSH
48231: CALL_OW 263
48235: PUSH
48236: LD_INT 2
48238: EQUAL
48239: IFFALSE 48268
// begin repeat wait ( 0 0$3 ) ;
48241: LD_INT 105
48243: PPUSH
48244: CALL_OW 67
// Connect ( vehicle ) ;
48248: LD_VAR 0 1
48252: PPUSH
48253: CALL 59988 0 1
// until IsControledBy ( vehicle ) ;
48257: LD_VAR 0 1
48261: PPUSH
48262: CALL_OW 312
48266: IFFALSE 48241
// end ; ComMoveToArea ( vehicle , mc_parking [ i ] ) ;
48268: LD_VAR 0 1
48272: PPUSH
48273: LD_EXP 119
48277: PUSH
48278: LD_VAR 0 4
48282: ARRAY
48283: PPUSH
48284: CALL_OW 113
// if GetControl ( vehicle ) <> control_manual then
48288: LD_VAR 0 1
48292: PPUSH
48293: CALL_OW 263
48297: PUSH
48298: LD_INT 1
48300: NONEQUAL
48301: IFFALSE 48305
// break ;
48303: GO 48354
// repeat wait ( 0 0$1 ) ;
48305: LD_INT 35
48307: PPUSH
48308: CALL_OW 67
// until IsInArea ( vehicle , mc_parking [ i ] ) ;
48312: LD_VAR 0 1
48316: PPUSH
48317: LD_EXP 119
48321: PUSH
48322: LD_VAR 0 4
48326: ARRAY
48327: PPUSH
48328: CALL_OW 308
48332: IFFALSE 48305
// ComExitVehicle ( IsDrivenBy ( vehicle ) ) ;
48334: LD_VAR 0 1
48338: PPUSH
48339: CALL_OW 311
48343: PPUSH
48344: CALL_OW 121
// exit ;
48348: POP
48349: POP
48350: GO 48356
// end ; end ;
48352: GO 47994
48354: POP
48355: POP
// end ;
48356: LD_VAR 0 3
48360: RET
// export function MCE_CrateSpawn ( id , x , y , amount , mode ) ; var i , j , depot ; begin
48361: LD_INT 0
48363: PPUSH
48364: PPUSH
48365: PPUSH
48366: PPUSH
// if not mc_bases or not skirmish then
48367: LD_EXP 95
48371: NOT
48372: PUSH
48373: LD_EXP 93
48377: NOT
48378: OR
48379: IFFALSE 48383
// exit ;
48381: GO 48736
// repeat wait ( 0 0$1 ) ;
48383: LD_INT 35
48385: PPUSH
48386: CALL_OW 67
// until GetResourceAmountXY ( x , y ) ;
48390: LD_VAR 0 2
48394: PPUSH
48395: LD_VAR 0 3
48399: PPUSH
48400: CALL_OW 284
48404: IFFALSE 48383
// if GetResourceTypeXY ( x , y ) = mat_artefact then
48406: LD_VAR 0 2
48410: PPUSH
48411: LD_VAR 0 3
48415: PPUSH
48416: CALL_OW 283
48420: PUSH
48421: LD_INT 4
48423: EQUAL
48424: IFFALSE 48428
// exit ;
48426: GO 48736
// for i = 1 to mc_bases do
48428: LD_ADDR_VAR 0 7
48432: PUSH
48433: DOUBLE
48434: LD_INT 1
48436: DEC
48437: ST_TO_ADDR
48438: LD_EXP 95
48442: PUSH
48443: FOR_TO
48444: IFFALSE 48734
// begin if mc_crates_area [ i ] then
48446: LD_EXP 113
48450: PUSH
48451: LD_VAR 0 7
48455: ARRAY
48456: IFFALSE 48567
// for j in mc_crates_area [ i ] do
48458: LD_ADDR_VAR 0 8
48462: PUSH
48463: LD_EXP 113
48467: PUSH
48468: LD_VAR 0 7
48472: ARRAY
48473: PUSH
48474: FOR_IN
48475: IFFALSE 48565
// if InArea ( x , y , j ) then
48477: LD_VAR 0 2
48481: PPUSH
48482: LD_VAR 0 3
48486: PPUSH
48487: LD_VAR 0 8
48491: PPUSH
48492: CALL_OW 309
48496: IFFALSE 48563
// begin mc_crates := ReplaceIn ( mc_crates , [ i , mc_crates [ i ] + 1 ] , [ amount , x , y ] ) ;
48498: LD_ADDR_EXP 111
48502: PUSH
48503: LD_EXP 111
48507: PPUSH
48508: LD_VAR 0 7
48512: PUSH
48513: LD_EXP 111
48517: PUSH
48518: LD_VAR 0 7
48522: ARRAY
48523: PUSH
48524: LD_INT 1
48526: PLUS
48527: PUSH
48528: EMPTY
48529: LIST
48530: LIST
48531: PPUSH
48532: LD_VAR 0 4
48536: PUSH
48537: LD_VAR 0 2
48541: PUSH
48542: LD_VAR 0 3
48546: PUSH
48547: EMPTY
48548: LIST
48549: LIST
48550: LIST
48551: PPUSH
48552: CALL 57017 0 3
48556: ST_TO_ADDR
// exit ;
48557: POP
48558: POP
48559: POP
48560: POP
48561: GO 48736
// end ;
48563: GO 48474
48565: POP
48566: POP
// depot := UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) ;
48567: LD_ADDR_VAR 0 9
48571: PUSH
48572: LD_EXP 95
48576: PUSH
48577: LD_VAR 0 7
48581: ARRAY
48582: PPUSH
48583: LD_INT 2
48585: PUSH
48586: LD_INT 30
48588: PUSH
48589: LD_INT 0
48591: PUSH
48592: EMPTY
48593: LIST
48594: LIST
48595: PUSH
48596: LD_INT 30
48598: PUSH
48599: LD_INT 1
48601: PUSH
48602: EMPTY
48603: LIST
48604: LIST
48605: PUSH
48606: EMPTY
48607: LIST
48608: LIST
48609: LIST
48610: PPUSH
48611: CALL_OW 72
48615: ST_TO_ADDR
// if not depot then
48616: LD_VAR 0 9
48620: NOT
48621: IFFALSE 48625
// continue ;
48623: GO 48443
// for j in depot do
48625: LD_ADDR_VAR 0 8
48629: PUSH
48630: LD_VAR 0 9
48634: PUSH
48635: FOR_IN
48636: IFFALSE 48730
// if GetDistUnitXY ( j , x , y ) < 30 then
48638: LD_VAR 0 8
48642: PPUSH
48643: LD_VAR 0 2
48647: PPUSH
48648: LD_VAR 0 3
48652: PPUSH
48653: CALL_OW 297
48657: PUSH
48658: LD_INT 30
48660: LESS
48661: IFFALSE 48728
// begin mc_crates := ReplaceIn ( mc_crates , [ i , mc_crates [ i ] + 1 ] , [ amount , x , y ] ) ;
48663: LD_ADDR_EXP 111
48667: PUSH
48668: LD_EXP 111
48672: PPUSH
48673: LD_VAR 0 7
48677: PUSH
48678: LD_EXP 111
48682: PUSH
48683: LD_VAR 0 7
48687: ARRAY
48688: PUSH
48689: LD_INT 1
48691: PLUS
48692: PUSH
48693: EMPTY
48694: LIST
48695: LIST
48696: PPUSH
48697: LD_VAR 0 4
48701: PUSH
48702: LD_VAR 0 2
48706: PUSH
48707: LD_VAR 0 3
48711: PUSH
48712: EMPTY
48713: LIST
48714: LIST
48715: LIST
48716: PPUSH
48717: CALL 57017 0 3
48721: ST_TO_ADDR
// exit ;
48722: POP
48723: POP
48724: POP
48725: POP
48726: GO 48736
// end ;
48728: GO 48635
48730: POP
48731: POP
// end ;
48732: GO 48443
48734: POP
48735: POP
// end ;
48736: LD_VAR 0 6
48740: RET
// export function MCE_ResearchComplete ( tech , lab ) ; var side , i , tmp ; begin
48741: LD_INT 0
48743: PPUSH
48744: PPUSH
48745: PPUSH
48746: PPUSH
// if not mc_bases or not skirmish then
48747: LD_EXP 95
48751: NOT
48752: PUSH
48753: LD_EXP 93
48757: NOT
48758: OR
48759: IFFALSE 48763
// exit ;
48761: GO 49040
// side := GetSide ( lab ) ;
48763: LD_ADDR_VAR 0 4
48767: PUSH
48768: LD_VAR 0 2
48772: PPUSH
48773: CALL_OW 255
48777: ST_TO_ADDR
// if not side in mc_sides or not mc_tech or not mc_bases then
48778: LD_VAR 0 4
48782: PUSH
48783: LD_EXP 121
48787: IN
48788: NOT
48789: PUSH
48790: LD_EXP 122
48794: NOT
48795: OR
48796: PUSH
48797: LD_EXP 95
48801: NOT
48802: OR
48803: IFFALSE 48807
// exit ;
48805: GO 49040
// mc_tech := Replace ( mc_tech , side , mc_tech [ side ] diff tech ) ;
48807: LD_ADDR_EXP 122
48811: PUSH
48812: LD_EXP 122
48816: PPUSH
48817: LD_VAR 0 4
48821: PPUSH
48822: LD_EXP 122
48826: PUSH
48827: LD_VAR 0 4
48831: ARRAY
48832: PUSH
48833: LD_VAR 0 1
48837: DIFF
48838: PPUSH
48839: CALL_OW 1
48843: ST_TO_ADDR
// for i = 1 to mc_bases do
48844: LD_ADDR_VAR 0 5
48848: PUSH
48849: DOUBLE
48850: LD_INT 1
48852: DEC
48853: ST_TO_ADDR
48854: LD_EXP 95
48858: PUSH
48859: FOR_TO
48860: IFFALSE 49038
// begin if lab in mc_bases [ i ] then
48862: LD_VAR 0 2
48866: PUSH
48867: LD_EXP 95
48871: PUSH
48872: LD_VAR 0 5
48876: ARRAY
48877: IN
48878: IFFALSE 49036
// begin if tech in [ tech_apeagres , tech_apebrain , tech_apeneural , tech_apepsych ] and mc_ape_in_lab [ i ] then
48880: LD_VAR 0 1
48884: PUSH
48885: LD_INT 11
48887: PUSH
48888: LD_INT 4
48890: PUSH
48891: LD_INT 3
48893: PUSH
48894: LD_INT 2
48896: PUSH
48897: EMPTY
48898: LIST
48899: LIST
48900: LIST
48901: LIST
48902: IN
48903: PUSH
48904: LD_EXP 125
48908: PUSH
48909: LD_VAR 0 5
48913: ARRAY
48914: AND
48915: IFFALSE 49036
// begin tmp := mc_ape_in_lab [ i ] [ 1 ] ;
48917: LD_ADDR_VAR 0 6
48921: PUSH
48922: LD_EXP 125
48926: PUSH
48927: LD_VAR 0 5
48931: ARRAY
48932: PUSH
48933: LD_INT 1
48935: ARRAY
48936: ST_TO_ADDR
// mc_ape_in_lab := Replace ( mc_ape_in_lab , i , [ ] ) ;
48937: LD_ADDR_EXP 125
48941: PUSH
48942: LD_EXP 125
48946: PPUSH
48947: LD_VAR 0 5
48951: PPUSH
48952: EMPTY
48953: PPUSH
48954: CALL_OW 1
48958: ST_TO_ADDR
// SetTag ( tmp , 0 ) ;
48959: LD_VAR 0 6
48963: PPUSH
48964: LD_INT 0
48966: PPUSH
48967: CALL_OW 109
// ComExitBuilding ( tmp ) ;
48971: LD_VAR 0 6
48975: PPUSH
48976: CALL_OW 122
// mc_ape := Replace ( mc_ape , i , Insert ( mc_ape [ i ] , 1 , tmp ) ) ;
48980: LD_ADDR_EXP 124
48984: PUSH
48985: LD_EXP 124
48989: PPUSH
48990: LD_VAR 0 5
48994: PPUSH
48995: LD_EXP 124
48999: PUSH
49000: LD_VAR 0 5
49004: ARRAY
49005: PPUSH
49006: LD_INT 1
49008: PPUSH
49009: LD_VAR 0 6
49013: PPUSH
49014: CALL_OW 2
49018: PPUSH
49019: CALL_OW 1
49023: ST_TO_ADDR
// MC_Reset ( i , 112 ) ;
49024: LD_VAR 0 5
49028: PPUSH
49029: LD_INT 112
49031: PPUSH
49032: CALL 25559 0 2
// end ; end ; end ;
49036: GO 48859
49038: POP
49039: POP
// end ;
49040: LD_VAR 0 3
49044: RET
// export function MCE_UnitDestroyed ( un ) ; var i , j , btype , pos , tmp , fac , components ; begin
49045: LD_INT 0
49047: PPUSH
49048: PPUSH
49049: PPUSH
49050: PPUSH
49051: PPUSH
49052: PPUSH
49053: PPUSH
49054: PPUSH
// if not mc_bases or not skirmish then
49055: LD_EXP 95
49059: NOT
49060: PUSH
49061: LD_EXP 93
49065: NOT
49066: OR
49067: IFFALSE 49071
// exit ;
49069: GO 50442
// for i = 1 to mc_bases do
49071: LD_ADDR_VAR 0 3
49075: PUSH
49076: DOUBLE
49077: LD_INT 1
49079: DEC
49080: ST_TO_ADDR
49081: LD_EXP 95
49085: PUSH
49086: FOR_TO
49087: IFFALSE 50440
// if un in mc_bases [ i ] or un in mc_construct_list [ i ] or un in mc_defender [ i ] or un in mc_vehicles [ i ] or un in mc_ape [ i ] or un in mc_ape_in_lab [ i ] then
49089: LD_VAR 0 1
49093: PUSH
49094: LD_EXP 95
49098: PUSH
49099: LD_VAR 0 3
49103: ARRAY
49104: IN
49105: PUSH
49106: LD_VAR 0 1
49110: PUSH
49111: LD_EXP 102
49115: PUSH
49116: LD_VAR 0 3
49120: ARRAY
49121: IN
49122: OR
49123: PUSH
49124: LD_VAR 0 1
49128: PUSH
49129: LD_EXP 117
49133: PUSH
49134: LD_VAR 0 3
49138: ARRAY
49139: IN
49140: OR
49141: PUSH
49142: LD_VAR 0 1
49146: PUSH
49147: LD_EXP 114
49151: PUSH
49152: LD_VAR 0 3
49156: ARRAY
49157: IN
49158: OR
49159: PUSH
49160: LD_VAR 0 1
49164: PUSH
49165: LD_EXP 124
49169: PUSH
49170: LD_VAR 0 3
49174: ARRAY
49175: IN
49176: OR
49177: PUSH
49178: LD_VAR 0 1
49182: PUSH
49183: LD_EXP 125
49187: PUSH
49188: LD_VAR 0 3
49192: ARRAY
49193: IN
49194: OR
49195: IFFALSE 50438
// begin if un in mc_ape [ i ] then
49197: LD_VAR 0 1
49201: PUSH
49202: LD_EXP 124
49206: PUSH
49207: LD_VAR 0 3
49211: ARRAY
49212: IN
49213: IFFALSE 49252
// begin mc_ape := Replace ( mc_ape , i , mc_ape [ i ] diff un ) ;
49215: LD_ADDR_EXP 124
49219: PUSH
49220: LD_EXP 124
49224: PPUSH
49225: LD_VAR 0 3
49229: PPUSH
49230: LD_EXP 124
49234: PUSH
49235: LD_VAR 0 3
49239: ARRAY
49240: PUSH
49241: LD_VAR 0 1
49245: DIFF
49246: PPUSH
49247: CALL_OW 1
49251: ST_TO_ADDR
// end ; if un in mc_ape_in_lab [ i ] then
49252: LD_VAR 0 1
49256: PUSH
49257: LD_EXP 125
49261: PUSH
49262: LD_VAR 0 3
49266: ARRAY
49267: IN
49268: IFFALSE 49292
// begin mc_ape_in_lab := Replace ( mc_ape_in_lab , i , [ ] ) ;
49270: LD_ADDR_EXP 125
49274: PUSH
49275: LD_EXP 125
49279: PPUSH
49280: LD_VAR 0 3
49284: PPUSH
49285: EMPTY
49286: PPUSH
49287: CALL_OW 1
49291: ST_TO_ADDR
// end ; if GetType ( un ) = unit_vehicle and ( GetTag ( un ) = 20 or un in mc_defender [ i ] or GetWeapon ( un ) in [ us_cargo_bay , ru_cargo_bay , ru_big_cargo_bay , ar_cargo_bay , us_crane , ru_crane , ar_control_tower ] ) then
49292: LD_VAR 0 1
49296: PPUSH
49297: CALL_OW 247
49301: PUSH
49302: LD_INT 2
49304: EQUAL
49305: PUSH
49306: LD_VAR 0 1
49310: PPUSH
49311: CALL_OW 110
49315: PUSH
49316: LD_INT 20
49318: EQUAL
49319: PUSH
49320: LD_VAR 0 1
49324: PUSH
49325: LD_EXP 117
49329: PUSH
49330: LD_VAR 0 3
49334: ARRAY
49335: IN
49336: OR
49337: PUSH
49338: LD_VAR 0 1
49342: PPUSH
49343: CALL_OW 264
49347: PUSH
49348: LD_INT 12
49350: PUSH
49351: LD_INT 51
49353: PUSH
49354: LD_EXP 75
49358: PUSH
49359: LD_INT 32
49361: PUSH
49362: LD_INT 13
49364: PUSH
49365: LD_INT 52
49367: PUSH
49368: LD_INT 31
49370: PUSH
49371: EMPTY
49372: LIST
49373: LIST
49374: LIST
49375: LIST
49376: LIST
49377: LIST
49378: LIST
49379: IN
49380: OR
49381: AND
49382: IFFALSE 49690
// begin if un in mc_defender [ i ] then
49384: LD_VAR 0 1
49388: PUSH
49389: LD_EXP 117
49393: PUSH
49394: LD_VAR 0 3
49398: ARRAY
49399: IN
49400: IFFALSE 49439
// mc_defender := Replace ( mc_defender , i , mc_defender [ i ] diff un ) ;
49402: LD_ADDR_EXP 117
49406: PUSH
49407: LD_EXP 117
49411: PPUSH
49412: LD_VAR 0 3
49416: PPUSH
49417: LD_EXP 117
49421: PUSH
49422: LD_VAR 0 3
49426: ARRAY
49427: PUSH
49428: LD_VAR 0 1
49432: DIFF
49433: PPUSH
49434: CALL_OW 1
49438: ST_TO_ADDR
// fac := MC_GetBuildings ( i , b_factory ) ;
49439: LD_ADDR_VAR 0 8
49443: PUSH
49444: LD_VAR 0 3
49448: PPUSH
49449: LD_INT 3
49451: PPUSH
49452: CALL 46080 0 2
49456: ST_TO_ADDR
// if fac then
49457: LD_VAR 0 8
49461: IFFALSE 49690
// begin for j in fac do
49463: LD_ADDR_VAR 0 4
49467: PUSH
49468: LD_VAR 0 8
49472: PUSH
49473: FOR_IN
49474: IFFALSE 49688
// begin components := Produce ( fac , GetChassis ( un ) , GetEngine ( un ) , GetControl ( un ) , GetWeapon ( un ) ) ;
49476: LD_ADDR_VAR 0 9
49480: PUSH
49481: LD_VAR 0 8
49485: PPUSH
49486: LD_VAR 0 1
49490: PPUSH
49491: CALL_OW 265
49495: PPUSH
49496: LD_VAR 0 1
49500: PPUSH
49501: CALL_OW 262
49505: PPUSH
49506: LD_VAR 0 1
49510: PPUSH
49511: CALL_OW 263
49515: PPUSH
49516: LD_VAR 0 1
49520: PPUSH
49521: CALL_OW 264
49525: PPUSH
49526: CALL 54513 0 5
49530: ST_TO_ADDR
// if components then
49531: LD_VAR 0 9
49535: IFFALSE 49686
// begin if GetWeapon ( un ) = ar_control_tower then
49537: LD_VAR 0 1
49541: PPUSH
49542: CALL_OW 264
49546: PUSH
49547: LD_INT 31
49549: EQUAL
49550: IFFALSE 49667
// begin SetTag ( IsDrivenBy ( un ) , 0 ) ;
49552: LD_VAR 0 1
49556: PPUSH
49557: CALL_OW 311
49561: PPUSH
49562: LD_INT 0
49564: PPUSH
49565: CALL_OW 109
// mc_remote_driver := Replace ( mc_remote_driver , i , mc_remote_driver [ i ] diff IsDrivenBy ( un ) ) ;
49569: LD_ADDR_EXP 135
49573: PUSH
49574: LD_EXP 135
49578: PPUSH
49579: LD_VAR 0 3
49583: PPUSH
49584: LD_EXP 135
49588: PUSH
49589: LD_VAR 0 3
49593: ARRAY
49594: PUSH
49595: LD_VAR 0 1
49599: PPUSH
49600: CALL_OW 311
49604: DIFF
49605: PPUSH
49606: CALL_OW 1
49610: ST_TO_ADDR
// tmp := Insert ( mc_produce [ i ] , 1 , components ) ;
49611: LD_ADDR_VAR 0 7
49615: PUSH
49616: LD_EXP 116
49620: PUSH
49621: LD_VAR 0 3
49625: ARRAY
49626: PPUSH
49627: LD_INT 1
49629: PPUSH
49630: LD_VAR 0 9
49634: PPUSH
49635: CALL_OW 2
49639: ST_TO_ADDR
// mc_produce := Replace ( mc_produce , i , tmp ) ;
49640: LD_ADDR_EXP 116
49644: PUSH
49645: LD_EXP 116
49649: PPUSH
49650: LD_VAR 0 3
49654: PPUSH
49655: LD_VAR 0 7
49659: PPUSH
49660: CALL_OW 1
49664: ST_TO_ADDR
// end else
49665: GO 49684
// MC_InsertProduceList ( i , [ components ] ) ;
49667: LD_VAR 0 3
49671: PPUSH
49672: LD_VAR 0 9
49676: PUSH
49677: EMPTY
49678: LIST
49679: PPUSH
49680: CALL 45625 0 2
// break ;
49684: GO 49688
// end ; end ;
49686: GO 49473
49688: POP
49689: POP
// end ; end ; if GetType ( un ) = unit_building then
49690: LD_VAR 0 1
49694: PPUSH
49695: CALL_OW 247
49699: PUSH
49700: LD_INT 3
49702: EQUAL
49703: IFFALSE 50106
// begin btype := GetBType ( un ) ;
49705: LD_ADDR_VAR 0 5
49709: PUSH
49710: LD_VAR 0 1
49714: PPUSH
49715: CALL_OW 266
49719: ST_TO_ADDR
// if btype in [ b_oil_mine , b_siberite_mine ] then
49720: LD_VAR 0 5
49724: PUSH
49725: LD_INT 29
49727: PUSH
49728: LD_INT 30
49730: PUSH
49731: EMPTY
49732: LIST
49733: LIST
49734: IN
49735: IFFALSE 49808
// begin if not GetResourceVisibility ( GetX ( un ) , GetY ( un ) , GetSide ( un ) ) then
49737: LD_VAR 0 1
49741: PPUSH
49742: CALL_OW 250
49746: PPUSH
49747: LD_VAR 0 1
49751: PPUSH
49752: CALL_OW 251
49756: PPUSH
49757: LD_VAR 0 1
49761: PPUSH
49762: CALL_OW 255
49766: PPUSH
49767: CALL_OW 440
49771: NOT
49772: IFFALSE 49808
// SetResourceVisibility ( GetX ( un ) , GetY ( un ) , GetSide ( un ) ) ;
49774: LD_VAR 0 1
49778: PPUSH
49779: CALL_OW 250
49783: PPUSH
49784: LD_VAR 0 1
49788: PPUSH
49789: CALL_OW 251
49793: PPUSH
49794: LD_VAR 0 1
49798: PPUSH
49799: CALL_OW 255
49803: PPUSH
49804: CALL_OW 441
// end ; if btype = b_warehouse then
49808: LD_VAR 0 5
49812: PUSH
49813: LD_INT 1
49815: EQUAL
49816: IFFALSE 49834
// begin btype := b_depot ;
49818: LD_ADDR_VAR 0 5
49822: PUSH
49823: LD_INT 0
49825: ST_TO_ADDR
// pos := 1 ;
49826: LD_ADDR_VAR 0 6
49830: PUSH
49831: LD_INT 1
49833: ST_TO_ADDR
// end ; if btype = b_factory then
49834: LD_VAR 0 5
49838: PUSH
49839: LD_INT 3
49841: EQUAL
49842: IFFALSE 49860
// begin btype := b_workshop ;
49844: LD_ADDR_VAR 0 5
49848: PUSH
49849: LD_INT 2
49851: ST_TO_ADDR
// pos := 1 ;
49852: LD_ADDR_VAR 0 6
49856: PUSH
49857: LD_INT 1
49859: ST_TO_ADDR
// end ; if btype = b_barracks then
49860: LD_VAR 0 5
49864: PUSH
49865: LD_INT 5
49867: EQUAL
49868: IFFALSE 49878
// btype := b_armoury ;
49870: LD_ADDR_VAR 0 5
49874: PUSH
49875: LD_INT 4
49877: ST_TO_ADDR
// if btype in [ b_lab_half , b_lab_full ] then
49878: LD_VAR 0 5
49882: PUSH
49883: LD_INT 7
49885: PUSH
49886: LD_INT 8
49888: PUSH
49889: EMPTY
49890: LIST
49891: LIST
49892: IN
49893: IFFALSE 49903
// btype := b_lab ;
49895: LD_ADDR_VAR 0 5
49899: PUSH
49900: LD_INT 6
49902: ST_TO_ADDR
// mc_build_list := ReplaceIn ( mc_build_list , [ i , mc_build_list [ i ] + 1 ] , [ btype , GetX ( un ) , GetY ( un ) , GetDir ( un ) ] ) ;
49903: LD_ADDR_EXP 100
49907: PUSH
49908: LD_EXP 100
49912: PPUSH
49913: LD_VAR 0 3
49917: PUSH
49918: LD_EXP 100
49922: PUSH
49923: LD_VAR 0 3
49927: ARRAY
49928: PUSH
49929: LD_INT 1
49931: PLUS
49932: PUSH
49933: EMPTY
49934: LIST
49935: LIST
49936: PPUSH
49937: LD_VAR 0 5
49941: PUSH
49942: LD_VAR 0 1
49946: PPUSH
49947: CALL_OW 250
49951: PUSH
49952: LD_VAR 0 1
49956: PPUSH
49957: CALL_OW 251
49961: PUSH
49962: LD_VAR 0 1
49966: PPUSH
49967: CALL_OW 254
49971: PUSH
49972: EMPTY
49973: LIST
49974: LIST
49975: LIST
49976: LIST
49977: PPUSH
49978: CALL 57017 0 3
49982: ST_TO_ADDR
// if pos = 1 then
49983: LD_VAR 0 6
49987: PUSH
49988: LD_INT 1
49990: EQUAL
49991: IFFALSE 50106
// begin tmp := mc_build_list [ i ] ;
49993: LD_ADDR_VAR 0 7
49997: PUSH
49998: LD_EXP 100
50002: PUSH
50003: LD_VAR 0 3
50007: ARRAY
50008: ST_TO_ADDR
// if UnitFilter ( tmp , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) then
50009: LD_VAR 0 7
50013: PPUSH
50014: LD_INT 2
50016: PUSH
50017: LD_INT 30
50019: PUSH
50020: LD_INT 0
50022: PUSH
50023: EMPTY
50024: LIST
50025: LIST
50026: PUSH
50027: LD_INT 30
50029: PUSH
50030: LD_INT 1
50032: PUSH
50033: EMPTY
50034: LIST
50035: LIST
50036: PUSH
50037: EMPTY
50038: LIST
50039: LIST
50040: LIST
50041: PPUSH
50042: CALL_OW 72
50046: IFFALSE 50056
// pos := 2 ;
50048: LD_ADDR_VAR 0 6
50052: PUSH
50053: LD_INT 2
50055: ST_TO_ADDR
// tmp := ReplaceWith ( tmp , pos , tmp ) ;
50056: LD_ADDR_VAR 0 7
50060: PUSH
50061: LD_VAR 0 7
50065: PPUSH
50066: LD_VAR 0 6
50070: PPUSH
50071: LD_VAR 0 7
50075: PPUSH
50076: CALL 57343 0 3
50080: ST_TO_ADDR
// mc_build_list := Replace ( mc_build_list , i , tmp ) ;
50081: LD_ADDR_EXP 100
50085: PUSH
50086: LD_EXP 100
50090: PPUSH
50091: LD_VAR 0 3
50095: PPUSH
50096: LD_VAR 0 7
50100: PPUSH
50101: CALL_OW 1
50105: ST_TO_ADDR
// end ; end ; if un in mc_bases [ i ] then
50106: LD_VAR 0 1
50110: PUSH
50111: LD_EXP 95
50115: PUSH
50116: LD_VAR 0 3
50120: ARRAY
50121: IN
50122: IFFALSE 50161
// begin mc_bases := Replace ( mc_bases , i , mc_bases [ i ] diff un ) ;
50124: LD_ADDR_EXP 95
50128: PUSH
50129: LD_EXP 95
50133: PPUSH
50134: LD_VAR 0 3
50138: PPUSH
50139: LD_EXP 95
50143: PUSH
50144: LD_VAR 0 3
50148: ARRAY
50149: PUSH
50150: LD_VAR 0 1
50154: DIFF
50155: PPUSH
50156: CALL_OW 1
50160: ST_TO_ADDR
// end ; if un in mc_construct_list [ i ] then
50161: LD_VAR 0 1
50165: PUSH
50166: LD_EXP 102
50170: PUSH
50171: LD_VAR 0 3
50175: ARRAY
50176: IN
50177: IFFALSE 50216
// begin mc_construct_list := Replace ( mc_construct_list , i , mc_construct_list [ i ] diff un ) ;
50179: LD_ADDR_EXP 102
50183: PUSH
50184: LD_EXP 102
50188: PPUSH
50189: LD_VAR 0 3
50193: PPUSH
50194: LD_EXP 102
50198: PUSH
50199: LD_VAR 0 3
50203: ARRAY
50204: PUSH
50205: LD_VAR 0 1
50209: DIFF
50210: PPUSH
50211: CALL_OW 1
50215: ST_TO_ADDR
// end ; if un in mc_vehicles [ i ] then
50216: LD_VAR 0 1
50220: PUSH
50221: LD_EXP 114
50225: PUSH
50226: LD_VAR 0 3
50230: ARRAY
50231: IN
50232: IFFALSE 50271
// begin mc_vehicles := Replace ( mc_vehicles , i , mc_vehicles [ i ] diff un ) ;
50234: LD_ADDR_EXP 114
50238: PUSH
50239: LD_EXP 114
50243: PPUSH
50244: LD_VAR 0 3
50248: PPUSH
50249: LD_EXP 114
50253: PUSH
50254: LD_VAR 0 3
50258: ARRAY
50259: PUSH
50260: LD_VAR 0 1
50264: DIFF
50265: PPUSH
50266: CALL_OW 1
50270: ST_TO_ADDR
// end ; if un in mc_defender [ i ] then
50271: LD_VAR 0 1
50275: PUSH
50276: LD_EXP 117
50280: PUSH
50281: LD_VAR 0 3
50285: ARRAY
50286: IN
50287: IFFALSE 50326
// begin mc_defender := Replace ( mc_defender , i , mc_defender [ i ] diff un ) ;
50289: LD_ADDR_EXP 117
50293: PUSH
50294: LD_EXP 117
50298: PPUSH
50299: LD_VAR 0 3
50303: PPUSH
50304: LD_EXP 117
50308: PUSH
50309: LD_VAR 0 3
50313: ARRAY
50314: PUSH
50315: LD_VAR 0 1
50319: DIFF
50320: PPUSH
50321: CALL_OW 1
50325: ST_TO_ADDR
// end ; if un in mc_empty_turret_list [ i ] then
50326: LD_VAR 0 1
50330: PUSH
50331: LD_EXP 104
50335: PUSH
50336: LD_VAR 0 3
50340: ARRAY
50341: IN
50342: IFFALSE 50381
// begin mc_empty_turret_list := Replace ( mc_empty_turret_list , i , mc_empty_turret_list [ i ] diff un ) ;
50344: LD_ADDR_EXP 104
50348: PUSH
50349: LD_EXP 104
50353: PPUSH
50354: LD_VAR 0 3
50358: PPUSH
50359: LD_EXP 104
50363: PUSH
50364: LD_VAR 0 3
50368: ARRAY
50369: PUSH
50370: LD_VAR 0 1
50374: DIFF
50375: PPUSH
50376: CALL_OW 1
50380: ST_TO_ADDR
// end ; if un in mc_turret_list [ i ] then
50381: LD_VAR 0 1
50385: PUSH
50386: LD_EXP 103
50390: PUSH
50391: LD_VAR 0 3
50395: ARRAY
50396: IN
50397: IFFALSE 50436
// begin mc_turret_list := Replace ( mc_turret_list , i , mc_turret_list [ i ] diff un ) ;
50399: LD_ADDR_EXP 103
50403: PUSH
50404: LD_EXP 103
50408: PPUSH
50409: LD_VAR 0 3
50413: PPUSH
50414: LD_EXP 103
50418: PUSH
50419: LD_VAR 0 3
50423: ARRAY
50424: PUSH
50425: LD_VAR 0 1
50429: DIFF
50430: PPUSH
50431: CALL_OW 1
50435: ST_TO_ADDR
// end ; break ;
50436: GO 50440
// end ;
50438: GO 49086
50440: POP
50441: POP
// end ;
50442: LD_VAR 0 2
50446: RET
// export function MCE_UpgradeComplete ( building ) ; var i , j ; begin
50447: LD_INT 0
50449: PPUSH
50450: PPUSH
50451: PPUSH
// if not mc_bases or not skirmish then
50452: LD_EXP 95
50456: NOT
50457: PUSH
50458: LD_EXP 93
50462: NOT
50463: OR
50464: IFFALSE 50468
// exit ;
50466: GO 50683
// for i = 1 to mc_bases do
50468: LD_ADDR_VAR 0 3
50472: PUSH
50473: DOUBLE
50474: LD_INT 1
50476: DEC
50477: ST_TO_ADDR
50478: LD_EXP 95
50482: PUSH
50483: FOR_TO
50484: IFFALSE 50681
// begin if building in mc_construct_list [ i ] then
50486: LD_VAR 0 1
50490: PUSH
50491: LD_EXP 102
50495: PUSH
50496: LD_VAR 0 3
50500: ARRAY
50501: IN
50502: IFFALSE 50679
// begin mc_construct_list := Replace ( mc_construct_list , i , mc_construct_list [ i ] diff building ) ;
50504: LD_ADDR_EXP 102
50508: PUSH
50509: LD_EXP 102
50513: PPUSH
50514: LD_VAR 0 3
50518: PPUSH
50519: LD_EXP 102
50523: PUSH
50524: LD_VAR 0 3
50528: ARRAY
50529: PUSH
50530: LD_VAR 0 1
50534: DIFF
50535: PPUSH
50536: CALL_OW 1
50540: ST_TO_ADDR
// if building in mc_lab [ i ] then
50541: LD_VAR 0 1
50545: PUSH
50546: LD_EXP 128
50550: PUSH
50551: LD_VAR 0 3
50555: ARRAY
50556: IN
50557: IFFALSE 50612
// mc_lab_upgrade := Replace ( mc_lab_upgrade , i , Reindex ( mc_lab_upgrade [ i ] , 1 , mc_lab_upgrade [ i ] , false ) ) ;
50559: LD_ADDR_EXP 129
50563: PUSH
50564: LD_EXP 129
50568: PPUSH
50569: LD_VAR 0 3
50573: PPUSH
50574: LD_EXP 129
50578: PUSH
50579: LD_VAR 0 3
50583: ARRAY
50584: PPUSH
50585: LD_INT 1
50587: PPUSH
50588: LD_EXP 129
50592: PUSH
50593: LD_VAR 0 3
50597: ARRAY
50598: PPUSH
50599: LD_INT 0
50601: PPUSH
50602: CALL 56435 0 4
50606: PPUSH
50607: CALL_OW 1
50611: ST_TO_ADDR
// if not building in mc_bases [ i ] then
50612: LD_VAR 0 1
50616: PUSH
50617: LD_EXP 95
50621: PUSH
50622: LD_VAR 0 3
50626: ARRAY
50627: IN
50628: NOT
50629: IFFALSE 50675
// mc_bases := ReplaceIn ( mc_bases , [ i , mc_bases [ i ] + 1 ] , building ) ;
50631: LD_ADDR_EXP 95
50635: PUSH
50636: LD_EXP 95
50640: PPUSH
50641: LD_VAR 0 3
50645: PUSH
50646: LD_EXP 95
50650: PUSH
50651: LD_VAR 0 3
50655: ARRAY
50656: PUSH
50657: LD_INT 1
50659: PLUS
50660: PUSH
50661: EMPTY
50662: LIST
50663: LIST
50664: PPUSH
50665: LD_VAR 0 1
50669: PPUSH
50670: CALL 57017 0 3
50674: ST_TO_ADDR
// exit ;
50675: POP
50676: POP
50677: GO 50683
// end ; end ;
50679: GO 50483
50681: POP
50682: POP
// end ;
50683: LD_VAR 0 2
50687: RET
// export function MCE_BuildingComplete ( building ) ; var i , j , btype , tmp , units , side ; begin
50688: LD_INT 0
50690: PPUSH
50691: PPUSH
50692: PPUSH
50693: PPUSH
50694: PPUSH
50695: PPUSH
50696: PPUSH
// if not mc_bases or not skirmish then
50697: LD_EXP 95
50701: NOT
50702: PUSH
50703: LD_EXP 93
50707: NOT
50708: OR
50709: IFFALSE 50713
// exit ;
50711: GO 51374
// for i = 1 to mc_bases do
50713: LD_ADDR_VAR 0 3
50717: PUSH
50718: DOUBLE
50719: LD_INT 1
50721: DEC
50722: ST_TO_ADDR
50723: LD_EXP 95
50727: PUSH
50728: FOR_TO
50729: IFFALSE 51372
// begin if building in mc_construct_list [ i ] then
50731: LD_VAR 0 1
50735: PUSH
50736: LD_EXP 102
50740: PUSH
50741: LD_VAR 0 3
50745: ARRAY
50746: IN
50747: IFFALSE 51370
// begin mc_construct_list := Replace ( mc_construct_list , i , mc_construct_list [ i ] diff building ) ;
50749: LD_ADDR_EXP 102
50753: PUSH
50754: LD_EXP 102
50758: PPUSH
50759: LD_VAR 0 3
50763: PPUSH
50764: LD_EXP 102
50768: PUSH
50769: LD_VAR 0 3
50773: ARRAY
50774: PUSH
50775: LD_VAR 0 1
50779: DIFF
50780: PPUSH
50781: CALL_OW 1
50785: ST_TO_ADDR
// mc_bases := ReplaceIn ( mc_bases , [ i , mc_bases [ i ] + 1 ] , building ) ;
50786: LD_ADDR_EXP 95
50790: PUSH
50791: LD_EXP 95
50795: PPUSH
50796: LD_VAR 0 3
50800: PUSH
50801: LD_EXP 95
50805: PUSH
50806: LD_VAR 0 3
50810: ARRAY
50811: PUSH
50812: LD_INT 1
50814: PLUS
50815: PUSH
50816: EMPTY
50817: LIST
50818: LIST
50819: PPUSH
50820: LD_VAR 0 1
50824: PPUSH
50825: CALL 57017 0 3
50829: ST_TO_ADDR
// btype := GetBType ( building ) ;
50830: LD_ADDR_VAR 0 5
50834: PUSH
50835: LD_VAR 0 1
50839: PPUSH
50840: CALL_OW 266
50844: ST_TO_ADDR
// side := GetSide ( building ) ;
50845: LD_ADDR_VAR 0 8
50849: PUSH
50850: LD_VAR 0 1
50854: PPUSH
50855: CALL_OW 255
50859: ST_TO_ADDR
// if btype = b_lab then
50860: LD_VAR 0 5
50864: PUSH
50865: LD_INT 6
50867: EQUAL
50868: IFFALSE 50918
// begin mc_lab := ReplaceIn ( mc_lab , [ i , mc_lab [ i ] + 1 ] , building ) ;
50870: LD_ADDR_EXP 128
50874: PUSH
50875: LD_EXP 128
50879: PPUSH
50880: LD_VAR 0 3
50884: PUSH
50885: LD_EXP 128
50889: PUSH
50890: LD_VAR 0 3
50894: ARRAY
50895: PUSH
50896: LD_INT 1
50898: PLUS
50899: PUSH
50900: EMPTY
50901: LIST
50902: LIST
50903: PPUSH
50904: LD_VAR 0 1
50908: PPUSH
50909: CALL 57017 0 3
50913: ST_TO_ADDR
// exit ;
50914: POP
50915: POP
50916: GO 51374
// end ; if btype in [ b_depot , b_workshop , b_armoury ] then
50918: LD_VAR 0 5
50922: PUSH
50923: LD_INT 0
50925: PUSH
50926: LD_INT 2
50928: PUSH
50929: LD_INT 4
50931: PUSH
50932: EMPTY
50933: LIST
50934: LIST
50935: LIST
50936: IN
50937: IFFALSE 51061
// begin if btype = b_armoury then
50939: LD_VAR 0 5
50943: PUSH
50944: LD_INT 4
50946: EQUAL
50947: IFFALSE 50957
// btype := b_barracks ;
50949: LD_ADDR_VAR 0 5
50953: PUSH
50954: LD_INT 5
50956: ST_TO_ADDR
// if btype = b_depot then
50957: LD_VAR 0 5
50961: PUSH
50962: LD_INT 0
50964: EQUAL
50965: IFFALSE 50975
// btype := b_warehouse ;
50967: LD_ADDR_VAR 0 5
50971: PUSH
50972: LD_INT 1
50974: ST_TO_ADDR
// if btype = b_workshop then
50975: LD_VAR 0 5
50979: PUSH
50980: LD_INT 2
50982: EQUAL
50983: IFFALSE 50993
// btype := b_factory ;
50985: LD_ADDR_VAR 0 5
50989: PUSH
50990: LD_INT 3
50992: ST_TO_ADDR
// if GetRestrict ( btype , side ) = state_enabled then
50993: LD_VAR 0 5
50997: PPUSH
50998: LD_VAR 0 8
51002: PPUSH
51003: CALL_OW 323
51007: PUSH
51008: LD_INT 1
51010: EQUAL
51011: IFFALSE 51057
// mc_build_upgrade := ReplaceIn ( mc_build_upgrade , [ i , mc_build_upgrade [ i ] + 1 ] , building ) ;
51013: LD_ADDR_EXP 127
51017: PUSH
51018: LD_EXP 127
51022: PPUSH
51023: LD_VAR 0 3
51027: PUSH
51028: LD_EXP 127
51032: PUSH
51033: LD_VAR 0 3
51037: ARRAY
51038: PUSH
51039: LD_INT 1
51041: PLUS
51042: PUSH
51043: EMPTY
51044: LIST
51045: LIST
51046: PPUSH
51047: LD_VAR 0 1
51051: PPUSH
51052: CALL 57017 0 3
51056: ST_TO_ADDR
// exit ;
51057: POP
51058: POP
51059: GO 51374
// end ; if btype in [ b_bunker , b_turret ] then
51061: LD_VAR 0 5
51065: PUSH
51066: LD_INT 32
51068: PUSH
51069: LD_INT 33
51071: PUSH
51072: EMPTY
51073: LIST
51074: LIST
51075: IN
51076: IFFALSE 51366
// begin mc_turret_list := ReplaceIn ( mc_turret_list , [ i , mc_turret_list [ i ] + 1 ] , building ) ;
51078: LD_ADDR_EXP 103
51082: PUSH
51083: LD_EXP 103
51087: PPUSH
51088: LD_VAR 0 3
51092: PUSH
51093: LD_EXP 103
51097: PUSH
51098: LD_VAR 0 3
51102: ARRAY
51103: PUSH
51104: LD_INT 1
51106: PLUS
51107: PUSH
51108: EMPTY
51109: LIST
51110: LIST
51111: PPUSH
51112: LD_VAR 0 1
51116: PPUSH
51117: CALL 57017 0 3
51121: ST_TO_ADDR
// if btype = b_bunker then
51122: LD_VAR 0 5
51126: PUSH
51127: LD_INT 32
51129: EQUAL
51130: IFFALSE 51366
// begin mc_empty_turret_list := ReplaceIn ( mc_empty_turret_list , [ i , mc_empty_turret_list [ i ] + 1 ] , building ) ;
51132: LD_ADDR_EXP 104
51136: PUSH
51137: LD_EXP 104
51141: PPUSH
51142: LD_VAR 0 3
51146: PUSH
51147: LD_EXP 104
51151: PUSH
51152: LD_VAR 0 3
51156: ARRAY
51157: PUSH
51158: LD_INT 1
51160: PLUS
51161: PUSH
51162: EMPTY
51163: LIST
51164: LIST
51165: PPUSH
51166: LD_VAR 0 1
51170: PPUSH
51171: CALL 57017 0 3
51175: ST_TO_ADDR
// tmp := UnitFilter ( mc_bases [ i ] , [ [ f_class , 1 ] , [ f_not , [ f_inside ] ] ] ) ;
51176: LD_ADDR_VAR 0 6
51180: PUSH
51181: LD_EXP 95
51185: PUSH
51186: LD_VAR 0 3
51190: ARRAY
51191: PPUSH
51192: LD_INT 25
51194: PUSH
51195: LD_INT 1
51197: PUSH
51198: EMPTY
51199: LIST
51200: LIST
51201: PUSH
51202: LD_INT 3
51204: PUSH
51205: LD_INT 54
51207: PUSH
51208: EMPTY
51209: LIST
51210: PUSH
51211: EMPTY
51212: LIST
51213: LIST
51214: PUSH
51215: EMPTY
51216: LIST
51217: LIST
51218: PPUSH
51219: CALL_OW 72
51223: ST_TO_ADDR
// if tmp then
51224: LD_VAR 0 6
51228: IFFALSE 51234
// exit ;
51230: POP
51231: POP
51232: GO 51374
// tmp := UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_armoury ] , [ f_btype , b_barracks ] ] ) ;
51234: LD_ADDR_VAR 0 6
51238: PUSH
51239: LD_EXP 95
51243: PUSH
51244: LD_VAR 0 3
51248: ARRAY
51249: PPUSH
51250: LD_INT 2
51252: PUSH
51253: LD_INT 30
51255: PUSH
51256: LD_INT 4
51258: PUSH
51259: EMPTY
51260: LIST
51261: LIST
51262: PUSH
51263: LD_INT 30
51265: PUSH
51266: LD_INT 5
51268: PUSH
51269: EMPTY
51270: LIST
51271: LIST
51272: PUSH
51273: EMPTY
51274: LIST
51275: LIST
51276: LIST
51277: PPUSH
51278: CALL_OW 72
51282: ST_TO_ADDR
// if not tmp then
51283: LD_VAR 0 6
51287: NOT
51288: IFFALSE 51294
// exit ;
51290: POP
51291: POP
51292: GO 51374
// for j in tmp do
51294: LD_ADDR_VAR 0 4
51298: PUSH
51299: LD_VAR 0 6
51303: PUSH
51304: FOR_IN
51305: IFFALSE 51364
// begin units := UnitFilter ( UnitsInside ( j ) , [ f_class , 1 ] ) ;
51307: LD_ADDR_VAR 0 7
51311: PUSH
51312: LD_VAR 0 4
51316: PPUSH
51317: CALL_OW 313
51321: PPUSH
51322: LD_INT 25
51324: PUSH
51325: LD_INT 1
51327: PUSH
51328: EMPTY
51329: LIST
51330: LIST
51331: PPUSH
51332: CALL_OW 72
51336: ST_TO_ADDR
// if units then
51337: LD_VAR 0 7
51341: IFFALSE 51362
// begin ComExitBuilding ( units [ 1 ] ) ;
51343: LD_VAR 0 7
51347: PUSH
51348: LD_INT 1
51350: ARRAY
51351: PPUSH
51352: CALL_OW 122
// exit ;
51356: POP
51357: POP
51358: POP
51359: POP
51360: GO 51374
// end ; end ;
51362: GO 51304
51364: POP
51365: POP
// end ; end ; exit ;
51366: POP
51367: POP
51368: GO 51374
// end ; end ;
51370: GO 50728
51372: POP
51373: POP
// end ;
51374: LD_VAR 0 2
51378: RET
// export function MCE_BuildingStarted ( building , builder ) ; var i , j , btype , x , y , d ; begin
51379: LD_INT 0
51381: PPUSH
51382: PPUSH
51383: PPUSH
51384: PPUSH
51385: PPUSH
51386: PPUSH
51387: PPUSH
// if not mc_bases or not skirmish then
51388: LD_EXP 95
51392: NOT
51393: PUSH
51394: LD_EXP 93
51398: NOT
51399: OR
51400: IFFALSE 51404
// exit ;
51402: GO 51669
// btype := GetBType ( building ) ;
51404: LD_ADDR_VAR 0 6
51408: PUSH
51409: LD_VAR 0 1
51413: PPUSH
51414: CALL_OW 266
51418: ST_TO_ADDR
// x := GetX ( building ) ;
51419: LD_ADDR_VAR 0 7
51423: PUSH
51424: LD_VAR 0 1
51428: PPUSH
51429: CALL_OW 250
51433: ST_TO_ADDR
// y := GetY ( building ) ;
51434: LD_ADDR_VAR 0 8
51438: PUSH
51439: LD_VAR 0 1
51443: PPUSH
51444: CALL_OW 251
51448: ST_TO_ADDR
// d := GetDir ( building ) ;
51449: LD_ADDR_VAR 0 9
51453: PUSH
51454: LD_VAR 0 1
51458: PPUSH
51459: CALL_OW 254
51463: ST_TO_ADDR
// for i = 1 to mc_bases do
51464: LD_ADDR_VAR 0 4
51468: PUSH
51469: DOUBLE
51470: LD_INT 1
51472: DEC
51473: ST_TO_ADDR
51474: LD_EXP 95
51478: PUSH
51479: FOR_TO
51480: IFFALSE 51667
// begin if not mc_build_list [ i ] then
51482: LD_EXP 100
51486: PUSH
51487: LD_VAR 0 4
51491: ARRAY
51492: NOT
51493: IFFALSE 51497
// continue ;
51495: GO 51479
// for j := 1 to mc_build_list [ i ] do
51497: LD_ADDR_VAR 0 5
51501: PUSH
51502: DOUBLE
51503: LD_INT 1
51505: DEC
51506: ST_TO_ADDR
51507: LD_EXP 100
51511: PUSH
51512: LD_VAR 0 4
51516: ARRAY
51517: PUSH
51518: FOR_TO
51519: IFFALSE 51663
// if CompareArray ( [ btype , x , y , d ] , mc_build_list [ i ] [ j ] ) then
51521: LD_VAR 0 6
51525: PUSH
51526: LD_VAR 0 7
51530: PUSH
51531: LD_VAR 0 8
51535: PUSH
51536: LD_VAR 0 9
51540: PUSH
51541: EMPTY
51542: LIST
51543: LIST
51544: LIST
51545: LIST
51546: PPUSH
51547: LD_EXP 100
51551: PUSH
51552: LD_VAR 0 4
51556: ARRAY
51557: PUSH
51558: LD_VAR 0 5
51562: ARRAY
51563: PPUSH
51564: CALL 63199 0 2
51568: IFFALSE 51661
// begin mc_build_list := Replace ( mc_build_list , i , Delete ( mc_build_list [ i ] , j ) ) ;
51570: LD_ADDR_EXP 100
51574: PUSH
51575: LD_EXP 100
51579: PPUSH
51580: LD_VAR 0 4
51584: PPUSH
51585: LD_EXP 100
51589: PUSH
51590: LD_VAR 0 4
51594: ARRAY
51595: PPUSH
51596: LD_VAR 0 5
51600: PPUSH
51601: CALL_OW 3
51605: PPUSH
51606: CALL_OW 1
51610: ST_TO_ADDR
// mc_construct_list := ReplaceIn ( mc_construct_list , [ i , mc_construct_list [ i ] + 1 ] , building ) ;
51611: LD_ADDR_EXP 102
51615: PUSH
51616: LD_EXP 102
51620: PPUSH
51621: LD_VAR 0 4
51625: PUSH
51626: LD_EXP 102
51630: PUSH
51631: LD_VAR 0 4
51635: ARRAY
51636: PUSH
51637: LD_INT 1
51639: PLUS
51640: PUSH
51641: EMPTY
51642: LIST
51643: LIST
51644: PPUSH
51645: LD_VAR 0 1
51649: PPUSH
51650: CALL 57017 0 3
51654: ST_TO_ADDR
// exit ;
51655: POP
51656: POP
51657: POP
51658: POP
51659: GO 51669
// end ;
51661: GO 51518
51663: POP
51664: POP
// end ;
51665: GO 51479
51667: POP
51668: POP
// end ;
51669: LD_VAR 0 3
51673: RET
// export function MCE_LeaveBuilding ( building , unit ) ; var i , tmp ; begin
51674: LD_INT 0
51676: PPUSH
51677: PPUSH
51678: PPUSH
// if not mc_bases or not skirmish then
51679: LD_EXP 95
51683: NOT
51684: PUSH
51685: LD_EXP 93
51689: NOT
51690: OR
51691: IFFALSE 51695
// exit ;
51693: GO 51885
// for i = 1 to mc_bases do
51695: LD_ADDR_VAR 0 4
51699: PUSH
51700: DOUBLE
51701: LD_INT 1
51703: DEC
51704: ST_TO_ADDR
51705: LD_EXP 95
51709: PUSH
51710: FOR_TO
51711: IFFALSE 51798
// begin if building in mc_turret_list [ i ] and not building in mc_empty_turret_list [ i ] then
51713: LD_VAR 0 1
51717: PUSH
51718: LD_EXP 103
51722: PUSH
51723: LD_VAR 0 4
51727: ARRAY
51728: IN
51729: PUSH
51730: LD_VAR 0 1
51734: PUSH
51735: LD_EXP 104
51739: PUSH
51740: LD_VAR 0 4
51744: ARRAY
51745: IN
51746: NOT
51747: AND
51748: IFFALSE 51796
// begin mc_empty_turret_list := ReplaceIn ( mc_empty_turret_list , [ i , mc_empty_turret_list [ i ] + 1 ] , building ) ;
51750: LD_ADDR_EXP 104
51754: PUSH
51755: LD_EXP 104
51759: PPUSH
51760: LD_VAR 0 4
51764: PUSH
51765: LD_EXP 104
51769: PUSH
51770: LD_VAR 0 4
51774: ARRAY
51775: PUSH
51776: LD_INT 1
51778: PLUS
51779: PUSH
51780: EMPTY
51781: LIST
51782: LIST
51783: PPUSH
51784: LD_VAR 0 1
51788: PPUSH
51789: CALL 57017 0 3
51793: ST_TO_ADDR
// break ;
51794: GO 51798
// end ; end ;
51796: GO 51710
51798: POP
51799: POP
// if GetClass ( building ) in mc_sides and GetBType ( building ) = b_barracks and GetTag ( unit ) <> 18 then
51800: LD_VAR 0 1
51804: PPUSH
51805: CALL_OW 257
51809: PUSH
51810: LD_EXP 121
51814: IN
51815: PUSH
51816: LD_VAR 0 1
51820: PPUSH
51821: CALL_OW 266
51825: PUSH
51826: LD_INT 5
51828: EQUAL
51829: AND
51830: PUSH
51831: LD_VAR 0 2
51835: PPUSH
51836: CALL_OW 110
51840: PUSH
51841: LD_INT 18
51843: NONEQUAL
51844: AND
51845: IFFALSE 51885
// if GetClass ( unit ) in [ 5 , 8 , 9 ] then
51847: LD_VAR 0 2
51851: PPUSH
51852: CALL_OW 257
51856: PUSH
51857: LD_INT 5
51859: PUSH
51860: LD_INT 8
51862: PUSH
51863: LD_INT 9
51865: PUSH
51866: EMPTY
51867: LIST
51868: LIST
51869: LIST
51870: IN
51871: IFFALSE 51885
// SetClass ( unit , 1 ) ;
51873: LD_VAR 0 2
51877: PPUSH
51878: LD_INT 1
51880: PPUSH
51881: CALL_OW 336
// end ;
51885: LD_VAR 0 3
51889: RET
// export function MCE_EvacuateVehicle ( driver , abandoned_vehicle , unknown1 , unknown2 ) ; var i ; begin
51890: LD_INT 0
51892: PPUSH
51893: PPUSH
// if not mc_bases or not skirmish then
51894: LD_EXP 95
51898: NOT
51899: PUSH
51900: LD_EXP 93
51904: NOT
51905: OR
51906: IFFALSE 51910
// exit ;
51908: GO 52026
// if GetLives ( abandoned_vehicle ) > 250 then
51910: LD_VAR 0 2
51914: PPUSH
51915: CALL_OW 256
51919: PUSH
51920: LD_INT 250
51922: GREATER
51923: IFFALSE 51927
// exit ;
51925: GO 52026
// for i = 1 to mc_bases do
51927: LD_ADDR_VAR 0 6
51931: PUSH
51932: DOUBLE
51933: LD_INT 1
51935: DEC
51936: ST_TO_ADDR
51937: LD_EXP 95
51941: PUSH
51942: FOR_TO
51943: IFFALSE 52024
// begin if driver in mc_bases [ i ] then
51945: LD_VAR 0 1
51949: PUSH
51950: LD_EXP 95
51954: PUSH
51955: LD_VAR 0 6
51959: ARRAY
51960: IN
51961: IFFALSE 52022
// begin ComMoveToNearbyEntrance ( driver , UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) [ 1 ] ) ;
51963: LD_VAR 0 1
51967: PPUSH
51968: LD_EXP 95
51972: PUSH
51973: LD_VAR 0 6
51977: ARRAY
51978: PPUSH
51979: LD_INT 2
51981: PUSH
51982: LD_INT 30
51984: PUSH
51985: LD_INT 0
51987: PUSH
51988: EMPTY
51989: LIST
51990: LIST
51991: PUSH
51992: LD_INT 30
51994: PUSH
51995: LD_INT 1
51997: PUSH
51998: EMPTY
51999: LIST
52000: LIST
52001: PUSH
52002: EMPTY
52003: LIST
52004: LIST
52005: LIST
52006: PPUSH
52007: CALL_OW 72
52011: PUSH
52012: LD_INT 1
52014: ARRAY
52015: PPUSH
52016: CALL 89579 0 2
// break ;
52020: GO 52024
// end ; end ;
52022: GO 51942
52024: POP
52025: POP
// end ; end_of_file
52026: LD_VAR 0 5
52030: RET
// export function PrepareUnit ( ident , exist_mode , prefix ) ; var unit ; begin
52031: LD_INT 0
52033: PPUSH
52034: PPUSH
// if exist_mode then
52035: LD_VAR 0 2
52039: IFFALSE 52064
// unit := CreateCharacter ( prefix & ident ) else
52041: LD_ADDR_VAR 0 5
52045: PUSH
52046: LD_VAR 0 3
52050: PUSH
52051: LD_VAR 0 1
52055: STR
52056: PPUSH
52057: CALL_OW 34
52061: ST_TO_ADDR
52062: GO 52079
// unit := NewCharacter ( ident ) ;
52064: LD_ADDR_VAR 0 5
52068: PUSH
52069: LD_VAR 0 1
52073: PPUSH
52074: CALL_OW 25
52078: ST_TO_ADDR
// result := unit ;
52079: LD_ADDR_VAR 0 4
52083: PUSH
52084: LD_VAR 0 5
52088: ST_TO_ADDR
// end ;
52089: LD_VAR 0 4
52093: RET
// export function GetTechNation ( side , nation , state ) ; var i ; begin
52094: LD_INT 0
52096: PPUSH
52097: PPUSH
// if not side or not nation then
52098: LD_VAR 0 1
52102: NOT
52103: PUSH
52104: LD_VAR 0 2
52108: NOT
52109: OR
52110: IFFALSE 52114
// exit ;
52112: GO 52882
// case nation of nation_american :
52114: LD_VAR 0 2
52118: PUSH
52119: LD_INT 1
52121: DOUBLE
52122: EQUAL
52123: IFTRUE 52127
52125: GO 52341
52127: POP
// result := [ 35 , 45 , 46 , 47 , 82 , 83 , 84 , 85 , 86 , 1 , 2 , 6 , 15 , 16 , 7 , 12 , 13 , 10 , 14 , 20 , 21 , 22 , 25 , 32 , 27 , 36 , 69 , 39 , 34 , 40 , 48 , 49 , 50 , 51 , 52 , 53 , 54 , 55 , 56 , 57 , 58 , 59 , 60 , 61 , 62 , 80 , 82 , 83 , 84 , 85 , 86 ] ; nation_arabian :
52128: LD_ADDR_VAR 0 4
52132: PUSH
52133: LD_INT 35
52135: PUSH
52136: LD_INT 45
52138: PUSH
52139: LD_INT 46
52141: PUSH
52142: LD_INT 47
52144: PUSH
52145: LD_INT 82
52147: PUSH
52148: LD_INT 83
52150: PUSH
52151: LD_INT 84
52153: PUSH
52154: LD_INT 85
52156: PUSH
52157: LD_INT 86
52159: PUSH
52160: LD_INT 1
52162: PUSH
52163: LD_INT 2
52165: PUSH
52166: LD_INT 6
52168: PUSH
52169: LD_INT 15
52171: PUSH
52172: LD_INT 16
52174: PUSH
52175: LD_INT 7
52177: PUSH
52178: LD_INT 12
52180: PUSH
52181: LD_INT 13
52183: PUSH
52184: LD_INT 10
52186: PUSH
52187: LD_INT 14
52189: PUSH
52190: LD_INT 20
52192: PUSH
52193: LD_INT 21
52195: PUSH
52196: LD_INT 22
52198: PUSH
52199: LD_INT 25
52201: PUSH
52202: LD_INT 32
52204: PUSH
52205: LD_INT 27
52207: PUSH
52208: LD_INT 36
52210: PUSH
52211: LD_INT 69
52213: PUSH
52214: LD_INT 39
52216: PUSH
52217: LD_INT 34
52219: PUSH
52220: LD_INT 40
52222: PUSH
52223: LD_INT 48
52225: PUSH
52226: LD_INT 49
52228: PUSH
52229: LD_INT 50
52231: PUSH
52232: LD_INT 51
52234: PUSH
52235: LD_INT 52
52237: PUSH
52238: LD_INT 53
52240: PUSH
52241: LD_INT 54
52243: PUSH
52244: LD_INT 55
52246: PUSH
52247: LD_INT 56
52249: PUSH
52250: LD_INT 57
52252: PUSH
52253: LD_INT 58
52255: PUSH
52256: LD_INT 59
52258: PUSH
52259: LD_INT 60
52261: PUSH
52262: LD_INT 61
52264: PUSH
52265: LD_INT 62
52267: PUSH
52268: LD_INT 80
52270: PUSH
52271: LD_INT 82
52273: PUSH
52274: LD_INT 83
52276: PUSH
52277: LD_INT 84
52279: PUSH
52280: LD_INT 85
52282: PUSH
52283: LD_INT 86
52285: PUSH
52286: EMPTY
52287: LIST
52288: LIST
52289: LIST
52290: LIST
52291: LIST
52292: LIST
52293: LIST
52294: LIST
52295: LIST
52296: LIST
52297: LIST
52298: LIST
52299: LIST
52300: LIST
52301: LIST
52302: LIST
52303: LIST
52304: LIST
52305: LIST
52306: LIST
52307: LIST
52308: LIST
52309: LIST
52310: LIST
52311: LIST
52312: LIST
52313: LIST
52314: LIST
52315: LIST
52316: LIST
52317: LIST
52318: LIST
52319: LIST
52320: LIST
52321: LIST
52322: LIST
52323: LIST
52324: LIST
52325: LIST
52326: LIST
52327: LIST
52328: LIST
52329: LIST
52330: LIST
52331: LIST
52332: LIST
52333: LIST
52334: LIST
52335: LIST
52336: LIST
52337: LIST
52338: ST_TO_ADDR
52339: GO 52806
52341: LD_INT 2
52343: DOUBLE
52344: EQUAL
52345: IFTRUE 52349
52347: GO 52575
52349: POP
// result := [ 35 , 45 , 46 , 47 , 82 , 83 , 84 , 85 , 87 , 70 , 1 , 11 , 3 , 4 , 5 , 6 , 15 , 18 , 7 , 17 , 8 , 20 , 21 , 22 , 72 , 26 , 69 , 39 , 40 , 41 , 42 , 43 , 48 , 49 , 50 , 51 , 52 , 53 , 54 , 55 , 56 , 60 , 61 , 62 , 66 , 67 , 68 , 81 , 82 , 83 , 84 , 85 , 87 , 88 ] ; nation_russian :
52350: LD_ADDR_VAR 0 4
52354: PUSH
52355: LD_INT 35
52357: PUSH
52358: LD_INT 45
52360: PUSH
52361: LD_INT 46
52363: PUSH
52364: LD_INT 47
52366: PUSH
52367: LD_INT 82
52369: PUSH
52370: LD_INT 83
52372: PUSH
52373: LD_INT 84
52375: PUSH
52376: LD_INT 85
52378: PUSH
52379: LD_INT 87
52381: PUSH
52382: LD_INT 70
52384: PUSH
52385: LD_INT 1
52387: PUSH
52388: LD_INT 11
52390: PUSH
52391: LD_INT 3
52393: PUSH
52394: LD_INT 4
52396: PUSH
52397: LD_INT 5
52399: PUSH
52400: LD_INT 6
52402: PUSH
52403: LD_INT 15
52405: PUSH
52406: LD_INT 18
52408: PUSH
52409: LD_INT 7
52411: PUSH
52412: LD_INT 17
52414: PUSH
52415: LD_INT 8
52417: PUSH
52418: LD_INT 20
52420: PUSH
52421: LD_INT 21
52423: PUSH
52424: LD_INT 22
52426: PUSH
52427: LD_INT 72
52429: PUSH
52430: LD_INT 26
52432: PUSH
52433: LD_INT 69
52435: PUSH
52436: LD_INT 39
52438: PUSH
52439: LD_INT 40
52441: PUSH
52442: LD_INT 41
52444: PUSH
52445: LD_INT 42
52447: PUSH
52448: LD_INT 43
52450: PUSH
52451: LD_INT 48
52453: PUSH
52454: LD_INT 49
52456: PUSH
52457: LD_INT 50
52459: PUSH
52460: LD_INT 51
52462: PUSH
52463: LD_INT 52
52465: PUSH
52466: LD_INT 53
52468: PUSH
52469: LD_INT 54
52471: PUSH
52472: LD_INT 55
52474: PUSH
52475: LD_INT 56
52477: PUSH
52478: LD_INT 60
52480: PUSH
52481: LD_INT 61
52483: PUSH
52484: LD_INT 62
52486: PUSH
52487: LD_INT 66
52489: PUSH
52490: LD_INT 67
52492: PUSH
52493: LD_INT 68
52495: PUSH
52496: LD_INT 81
52498: PUSH
52499: LD_INT 82
52501: PUSH
52502: LD_INT 83
52504: PUSH
52505: LD_INT 84
52507: PUSH
52508: LD_INT 85
52510: PUSH
52511: LD_INT 87
52513: PUSH
52514: LD_INT 88
52516: PUSH
52517: EMPTY
52518: LIST
52519: LIST
52520: LIST
52521: LIST
52522: LIST
52523: LIST
52524: LIST
52525: LIST
52526: LIST
52527: LIST
52528: LIST
52529: LIST
52530: LIST
52531: LIST
52532: LIST
52533: LIST
52534: LIST
52535: LIST
52536: LIST
52537: LIST
52538: LIST
52539: LIST
52540: LIST
52541: LIST
52542: LIST
52543: LIST
52544: LIST
52545: LIST
52546: LIST
52547: LIST
52548: LIST
52549: LIST
52550: LIST
52551: LIST
52552: LIST
52553: LIST
52554: LIST
52555: LIST
52556: LIST
52557: LIST
52558: LIST
52559: LIST
52560: LIST
52561: LIST
52562: LIST
52563: LIST
52564: LIST
52565: LIST
52566: LIST
52567: LIST
52568: LIST
52569: LIST
52570: LIST
52571: LIST
52572: ST_TO_ADDR
52573: GO 52806
52575: LD_INT 3
52577: DOUBLE
52578: EQUAL
52579: IFTRUE 52583
52581: GO 52805
52583: POP
// result := [ 46 , 47 , 1 , 2 , 82 , 83 , 84 , 85 , 86 , 11 , 9 , 20 , 19 , 21 , 24 , 22 , 25 , 28 , 29 , 30 , 31 , 37 , 38 , 32 , 27 , 33 , 69 , 39 , 34 , 40 , 71 , 23 , 44 , 48 , 49 , 50 , 51 , 52 , 53 , 54 , 55 , 56 , 57 , 58 , 59 , 63 , 64 , 65 , 82 , 83 , 84 , 85 , 86 ] ; end ;
52584: LD_ADDR_VAR 0 4
52588: PUSH
52589: LD_INT 46
52591: PUSH
52592: LD_INT 47
52594: PUSH
52595: LD_INT 1
52597: PUSH
52598: LD_INT 2
52600: PUSH
52601: LD_INT 82
52603: PUSH
52604: LD_INT 83
52606: PUSH
52607: LD_INT 84
52609: PUSH
52610: LD_INT 85
52612: PUSH
52613: LD_INT 86
52615: PUSH
52616: LD_INT 11
52618: PUSH
52619: LD_INT 9
52621: PUSH
52622: LD_INT 20
52624: PUSH
52625: LD_INT 19
52627: PUSH
52628: LD_INT 21
52630: PUSH
52631: LD_INT 24
52633: PUSH
52634: LD_INT 22
52636: PUSH
52637: LD_INT 25
52639: PUSH
52640: LD_INT 28
52642: PUSH
52643: LD_INT 29
52645: PUSH
52646: LD_INT 30
52648: PUSH
52649: LD_INT 31
52651: PUSH
52652: LD_INT 37
52654: PUSH
52655: LD_INT 38
52657: PUSH
52658: LD_INT 32
52660: PUSH
52661: LD_INT 27
52663: PUSH
52664: LD_INT 33
52666: PUSH
52667: LD_INT 69
52669: PUSH
52670: LD_INT 39
52672: PUSH
52673: LD_INT 34
52675: PUSH
52676: LD_INT 40
52678: PUSH
52679: LD_INT 71
52681: PUSH
52682: LD_INT 23
52684: PUSH
52685: LD_INT 44
52687: PUSH
52688: LD_INT 48
52690: PUSH
52691: LD_INT 49
52693: PUSH
52694: LD_INT 50
52696: PUSH
52697: LD_INT 51
52699: PUSH
52700: LD_INT 52
52702: PUSH
52703: LD_INT 53
52705: PUSH
52706: LD_INT 54
52708: PUSH
52709: LD_INT 55
52711: PUSH
52712: LD_INT 56
52714: PUSH
52715: LD_INT 57
52717: PUSH
52718: LD_INT 58
52720: PUSH
52721: LD_INT 59
52723: PUSH
52724: LD_INT 63
52726: PUSH
52727: LD_INT 64
52729: PUSH
52730: LD_INT 65
52732: PUSH
52733: LD_INT 82
52735: PUSH
52736: LD_INT 83
52738: PUSH
52739: LD_INT 84
52741: PUSH
52742: LD_INT 85
52744: PUSH
52745: LD_INT 86
52747: PUSH
52748: EMPTY
52749: LIST
52750: LIST
52751: LIST
52752: LIST
52753: LIST
52754: LIST
52755: LIST
52756: LIST
52757: LIST
52758: LIST
52759: LIST
52760: LIST
52761: LIST
52762: LIST
52763: LIST
52764: LIST
52765: LIST
52766: LIST
52767: LIST
52768: LIST
52769: LIST
52770: LIST
52771: LIST
52772: LIST
52773: LIST
52774: LIST
52775: LIST
52776: LIST
52777: LIST
52778: LIST
52779: LIST
52780: LIST
52781: LIST
52782: LIST
52783: LIST
52784: LIST
52785: LIST
52786: LIST
52787: LIST
52788: LIST
52789: LIST
52790: LIST
52791: LIST
52792: LIST
52793: LIST
52794: LIST
52795: LIST
52796: LIST
52797: LIST
52798: LIST
52799: LIST
52800: LIST
52801: LIST
52802: ST_TO_ADDR
52803: GO 52806
52805: POP
// if state > - 1 and state < 3 then
52806: LD_VAR 0 3
52810: PUSH
52811: LD_INT 1
52813: NEG
52814: GREATER
52815: PUSH
52816: LD_VAR 0 3
52820: PUSH
52821: LD_INT 3
52823: LESS
52824: AND
52825: IFFALSE 52882
// for i in result do
52827: LD_ADDR_VAR 0 5
52831: PUSH
52832: LD_VAR 0 4
52836: PUSH
52837: FOR_IN
52838: IFFALSE 52880
// if GetTech ( i , side ) <> state then
52840: LD_VAR 0 5
52844: PPUSH
52845: LD_VAR 0 1
52849: PPUSH
52850: CALL_OW 321
52854: PUSH
52855: LD_VAR 0 3
52859: NONEQUAL
52860: IFFALSE 52878
// result := result diff i ;
52862: LD_ADDR_VAR 0 4
52866: PUSH
52867: LD_VAR 0 4
52871: PUSH
52872: LD_VAR 0 5
52876: DIFF
52877: ST_TO_ADDR
52878: GO 52837
52880: POP
52881: POP
// end ;
52882: LD_VAR 0 4
52886: RET
// export function TechCanBeResearch ( side , tech ) ; var i , tmp ; begin
52887: LD_INT 0
52889: PPUSH
52890: PPUSH
52891: PPUSH
// result := true ;
52892: LD_ADDR_VAR 0 3
52896: PUSH
52897: LD_INT 1
52899: ST_TO_ADDR
// tmp := GetTechTechsReq ( tech ) ;
52900: LD_ADDR_VAR 0 5
52904: PUSH
52905: LD_VAR 0 2
52909: PPUSH
52910: CALL_OW 480
52914: ST_TO_ADDR
// if not tmp then
52915: LD_VAR 0 5
52919: NOT
52920: IFFALSE 52924
// exit ;
52922: GO 52973
// for i in tmp do
52924: LD_ADDR_VAR 0 4
52928: PUSH
52929: LD_VAR 0 5
52933: PUSH
52934: FOR_IN
52935: IFFALSE 52971
// if GetTech ( i , side ) <> state_researched then
52937: LD_VAR 0 4
52941: PPUSH
52942: LD_VAR 0 1
52946: PPUSH
52947: CALL_OW 321
52951: PUSH
52952: LD_INT 2
52954: NONEQUAL
52955: IFFALSE 52969
// begin result := false ;
52957: LD_ADDR_VAR 0 3
52961: PUSH
52962: LD_INT 0
52964: ST_TO_ADDR
// exit ;
52965: POP
52966: POP
52967: GO 52973
// end ;
52969: GO 52934
52971: POP
52972: POP
// end ;
52973: LD_VAR 0 3
52977: RET
// export function ComSpaceTimeShoot ( unit ) ; var i , x , y , _x , _y , tmp , side , enemy , in_unit , tech_space , tech_time , missile ; begin
52978: LD_INT 0
52980: PPUSH
52981: PPUSH
52982: PPUSH
52983: PPUSH
52984: PPUSH
52985: PPUSH
52986: PPUSH
52987: PPUSH
52988: PPUSH
52989: PPUSH
52990: PPUSH
52991: PPUSH
52992: PPUSH
// if not unit or GetClass ( unit ) <> class_bazooker then
52993: LD_VAR 0 1
52997: NOT
52998: PUSH
52999: LD_VAR 0 1
53003: PPUSH
53004: CALL_OW 257
53008: PUSH
53009: LD_INT 9
53011: NONEQUAL
53012: OR
53013: IFFALSE 53017
// exit ;
53015: GO 53590
// side := GetSide ( unit ) ;
53017: LD_ADDR_VAR 0 9
53021: PUSH
53022: LD_VAR 0 1
53026: PPUSH
53027: CALL_OW 255
53031: ST_TO_ADDR
// tech_space := tech_spacanom ;
53032: LD_ADDR_VAR 0 12
53036: PUSH
53037: LD_INT 29
53039: ST_TO_ADDR
// tech_time := tech_taurad ;
53040: LD_ADDR_VAR 0 13
53044: PUSH
53045: LD_INT 28
53047: ST_TO_ADDR
// in_unit := IsInUnit ( unit ) ;
53048: LD_ADDR_VAR 0 11
53052: PUSH
53053: LD_VAR 0 1
53057: PPUSH
53058: CALL_OW 310
53062: ST_TO_ADDR
// if GetType ( in_unit ) = unit_vehicle then
53063: LD_VAR 0 11
53067: PPUSH
53068: CALL_OW 247
53072: PUSH
53073: LD_INT 2
53075: EQUAL
53076: IFFALSE 53080
// exit ;
53078: GO 53590
// tmp := FilterAllUnits ( [ [ f_enemy , side ] , [ f_not , [ f_type , unit_building ] ] ] ) ;
53080: LD_ADDR_VAR 0 8
53084: PUSH
53085: LD_INT 81
53087: PUSH
53088: LD_VAR 0 9
53092: PUSH
53093: EMPTY
53094: LIST
53095: LIST
53096: PUSH
53097: LD_INT 3
53099: PUSH
53100: LD_INT 21
53102: PUSH
53103: LD_INT 3
53105: PUSH
53106: EMPTY
53107: LIST
53108: LIST
53109: PUSH
53110: EMPTY
53111: LIST
53112: LIST
53113: PUSH
53114: EMPTY
53115: LIST
53116: LIST
53117: PPUSH
53118: CALL_OW 69
53122: ST_TO_ADDR
// if not tmp then
53123: LD_VAR 0 8
53127: NOT
53128: IFFALSE 53132
// exit ;
53130: GO 53590
// if in_unit then
53132: LD_VAR 0 11
53136: IFFALSE 53160
// enemy := NearestUnitToUnit ( tmp , in_unit ) else
53138: LD_ADDR_VAR 0 10
53142: PUSH
53143: LD_VAR 0 8
53147: PPUSH
53148: LD_VAR 0 11
53152: PPUSH
53153: CALL_OW 74
53157: ST_TO_ADDR
53158: GO 53180
// enemy := NearestUnitToUnit ( tmp , unit ) ;
53160: LD_ADDR_VAR 0 10
53164: PUSH
53165: LD_VAR 0 8
53169: PPUSH
53170: LD_VAR 0 1
53174: PPUSH
53175: CALL_OW 74
53179: ST_TO_ADDR
// if not enemy then
53180: LD_VAR 0 10
53184: NOT
53185: IFFALSE 53189
// exit ;
53187: GO 53590
// if ( in_unit and GetDistUnits ( in_unit , enemy ) > 13 ) or GetDistUnits ( unit , enemy ) > 12 then
53189: LD_VAR 0 11
53193: PUSH
53194: LD_VAR 0 11
53198: PPUSH
53199: LD_VAR 0 10
53203: PPUSH
53204: CALL_OW 296
53208: PUSH
53209: LD_INT 13
53211: GREATER
53212: AND
53213: PUSH
53214: LD_VAR 0 1
53218: PPUSH
53219: LD_VAR 0 10
53223: PPUSH
53224: CALL_OW 296
53228: PUSH
53229: LD_INT 12
53231: GREATER
53232: OR
53233: IFFALSE 53237
// exit ;
53235: GO 53590
// missile := [ 1 ] ;
53237: LD_ADDR_VAR 0 14
53241: PUSH
53242: LD_INT 1
53244: PUSH
53245: EMPTY
53246: LIST
53247: ST_TO_ADDR
// if Researched ( side , tech_space ) then
53248: LD_VAR 0 9
53252: PPUSH
53253: LD_VAR 0 12
53257: PPUSH
53258: CALL_OW 325
53262: IFFALSE 53291
// missile := Replace ( missile , missile + 1 , 2 ) ;
53264: LD_ADDR_VAR 0 14
53268: PUSH
53269: LD_VAR 0 14
53273: PPUSH
53274: LD_VAR 0 14
53278: PUSH
53279: LD_INT 1
53281: PLUS
53282: PPUSH
53283: LD_INT 2
53285: PPUSH
53286: CALL_OW 1
53290: ST_TO_ADDR
// if Researched ( side , tech_time ) and not Researched ( GetSide ( enemy ) , tech_time ) then
53291: LD_VAR 0 9
53295: PPUSH
53296: LD_VAR 0 13
53300: PPUSH
53301: CALL_OW 325
53305: PUSH
53306: LD_VAR 0 10
53310: PPUSH
53311: CALL_OW 255
53315: PPUSH
53316: LD_VAR 0 13
53320: PPUSH
53321: CALL_OW 325
53325: NOT
53326: AND
53327: IFFALSE 53356
// missile := Replace ( missile , missile + 1 , 3 ) ;
53329: LD_ADDR_VAR 0 14
53333: PUSH
53334: LD_VAR 0 14
53338: PPUSH
53339: LD_VAR 0 14
53343: PUSH
53344: LD_INT 1
53346: PLUS
53347: PPUSH
53348: LD_INT 3
53350: PPUSH
53351: CALL_OW 1
53355: ST_TO_ADDR
// if missile < 2 then
53356: LD_VAR 0 14
53360: PUSH
53361: LD_INT 2
53363: LESS
53364: IFFALSE 53368
// exit ;
53366: GO 53590
// x := GetX ( enemy ) ;
53368: LD_ADDR_VAR 0 4
53372: PUSH
53373: LD_VAR 0 10
53377: PPUSH
53378: CALL_OW 250
53382: ST_TO_ADDR
// y := GetY ( enemy ) ;
53383: LD_ADDR_VAR 0 5
53387: PUSH
53388: LD_VAR 0 10
53392: PPUSH
53393: CALL_OW 251
53397: ST_TO_ADDR
// _x := x + rand ( - 1 , 1 ) ;
53398: LD_ADDR_VAR 0 6
53402: PUSH
53403: LD_VAR 0 4
53407: PUSH
53408: LD_INT 1
53410: NEG
53411: PPUSH
53412: LD_INT 1
53414: PPUSH
53415: CALL_OW 12
53419: PLUS
53420: ST_TO_ADDR
// _y := y + rand ( - 1 , 1 ) ;
53421: LD_ADDR_VAR 0 7
53425: PUSH
53426: LD_VAR 0 5
53430: PUSH
53431: LD_INT 1
53433: NEG
53434: PPUSH
53435: LD_INT 1
53437: PPUSH
53438: CALL_OW 12
53442: PLUS
53443: ST_TO_ADDR
// if not ValidHex ( _x , _y ) then
53444: LD_VAR 0 6
53448: PPUSH
53449: LD_VAR 0 7
53453: PPUSH
53454: CALL_OW 488
53458: NOT
53459: IFFALSE 53481
// begin _x := x ;
53461: LD_ADDR_VAR 0 6
53465: PUSH
53466: LD_VAR 0 4
53470: ST_TO_ADDR
// _y := y ;
53471: LD_ADDR_VAR 0 7
53475: PUSH
53476: LD_VAR 0 5
53480: ST_TO_ADDR
// end ; i := rand ( 1 , missile ) ;
53481: LD_ADDR_VAR 0 3
53485: PUSH
53486: LD_INT 1
53488: PPUSH
53489: LD_VAR 0 14
53493: PPUSH
53494: CALL_OW 12
53498: ST_TO_ADDR
// case i of 1 :
53499: LD_VAR 0 3
53503: PUSH
53504: LD_INT 1
53506: DOUBLE
53507: EQUAL
53508: IFTRUE 53512
53510: GO 53529
53512: POP
// ComAttackUnit ( unit , enemy ) ; 2 :
53513: LD_VAR 0 1
53517: PPUSH
53518: LD_VAR 0 10
53522: PPUSH
53523: CALL_OW 115
53527: GO 53590
53529: LD_INT 2
53531: DOUBLE
53532: EQUAL
53533: IFTRUE 53537
53535: GO 53559
53537: POP
// ComSpaceShift ( unit , _x , _y ) ; 3 :
53538: LD_VAR 0 1
53542: PPUSH
53543: LD_VAR 0 6
53547: PPUSH
53548: LD_VAR 0 7
53552: PPUSH
53553: CALL_OW 153
53557: GO 53590
53559: LD_INT 3
53561: DOUBLE
53562: EQUAL
53563: IFTRUE 53567
53565: GO 53589
53567: POP
// ComTimeShift ( unit , _x , _y ) ; end ;
53568: LD_VAR 0 1
53572: PPUSH
53573: LD_VAR 0 6
53577: PPUSH
53578: LD_VAR 0 7
53582: PPUSH
53583: CALL_OW 154
53587: GO 53590
53589: POP
// end ;
53590: LD_VAR 0 2
53594: RET
// export function ComStandNearbyBuilding ( unit , building ) ; var i , x , y , _x , _y ; begin
53595: LD_INT 0
53597: PPUSH
53598: PPUSH
53599: PPUSH
53600: PPUSH
53601: PPUSH
53602: PPUSH
// if not unit or not building then
53603: LD_VAR 0 1
53607: NOT
53608: PUSH
53609: LD_VAR 0 2
53613: NOT
53614: OR
53615: IFFALSE 53619
// exit ;
53617: GO 53777
// x := GetX ( building ) ;
53619: LD_ADDR_VAR 0 5
53623: PUSH
53624: LD_VAR 0 2
53628: PPUSH
53629: CALL_OW 250
53633: ST_TO_ADDR
// y := GetY ( building ) ;
53634: LD_ADDR_VAR 0 6
53638: PUSH
53639: LD_VAR 0 2
53643: PPUSH
53644: CALL_OW 251
53648: ST_TO_ADDR
// for i = 0 to 5 do
53649: LD_ADDR_VAR 0 4
53653: PUSH
53654: DOUBLE
53655: LD_INT 0
53657: DEC
53658: ST_TO_ADDR
53659: LD_INT 5
53661: PUSH
53662: FOR_TO
53663: IFFALSE 53775
// begin _x := ShiftX ( x , i , 3 ) ;
53665: LD_ADDR_VAR 0 7
53669: PUSH
53670: LD_VAR 0 5
53674: PPUSH
53675: LD_VAR 0 4
53679: PPUSH
53680: LD_INT 3
53682: PPUSH
53683: CALL_OW 272
53687: ST_TO_ADDR
// _y := ShiftY ( y , i , 3 ) ;
53688: LD_ADDR_VAR 0 8
53692: PUSH
53693: LD_VAR 0 6
53697: PPUSH
53698: LD_VAR 0 4
53702: PPUSH
53703: LD_INT 3
53705: PPUSH
53706: CALL_OW 273
53710: ST_TO_ADDR
// if not ValidHex ( _x , _y ) then
53711: LD_VAR 0 7
53715: PPUSH
53716: LD_VAR 0 8
53720: PPUSH
53721: CALL_OW 488
53725: NOT
53726: IFFALSE 53730
// continue ;
53728: GO 53662
// if HexInfo ( _x , _y ) = 0 then
53730: LD_VAR 0 7
53734: PPUSH
53735: LD_VAR 0 8
53739: PPUSH
53740: CALL_OW 428
53744: PUSH
53745: LD_INT 0
53747: EQUAL
53748: IFFALSE 53773
// begin ComMoveXY ( unit , _x , _y ) ;
53750: LD_VAR 0 1
53754: PPUSH
53755: LD_VAR 0 7
53759: PPUSH
53760: LD_VAR 0 8
53764: PPUSH
53765: CALL_OW 111
// exit ;
53769: POP
53770: POP
53771: GO 53777
// end ; end ;
53773: GO 53662
53775: POP
53776: POP
// end ;
53777: LD_VAR 0 3
53781: RET
// export function ScanBase ( side , base_area ) ; begin
53782: LD_INT 0
53784: PPUSH
// result := FilterUnitsInArea ( base_area , [ f_enemy , side ] ) ;
53785: LD_ADDR_VAR 0 3
53789: PUSH
53790: LD_VAR 0 2
53794: PPUSH
53795: LD_INT 81
53797: PUSH
53798: LD_VAR 0 1
53802: PUSH
53803: EMPTY
53804: LIST
53805: LIST
53806: PPUSH
53807: CALL_OW 70
53811: ST_TO_ADDR
// end ;
53812: LD_VAR 0 3
53816: RET
// export function AllowSpecClass ( unit ) ; var side , nat , tech ; begin
53817: LD_INT 0
53819: PPUSH
53820: PPUSH
53821: PPUSH
53822: PPUSH
// result := false ;
53823: LD_ADDR_VAR 0 2
53827: PUSH
53828: LD_INT 0
53830: ST_TO_ADDR
// side := GetSide ( unit ) ;
53831: LD_ADDR_VAR 0 3
53835: PUSH
53836: LD_VAR 0 1
53840: PPUSH
53841: CALL_OW 255
53845: ST_TO_ADDR
// nat := GetNation ( unit ) ;
53846: LD_ADDR_VAR 0 4
53850: PUSH
53851: LD_VAR 0 1
53855: PPUSH
53856: CALL_OW 248
53860: ST_TO_ADDR
// case nat of 1 :
53861: LD_VAR 0 4
53865: PUSH
53866: LD_INT 1
53868: DOUBLE
53869: EQUAL
53870: IFTRUE 53874
53872: GO 53885
53874: POP
// tech := tech_lassight ; 2 :
53875: LD_ADDR_VAR 0 5
53879: PUSH
53880: LD_INT 12
53882: ST_TO_ADDR
53883: GO 53924
53885: LD_INT 2
53887: DOUBLE
53888: EQUAL
53889: IFTRUE 53893
53891: GO 53904
53893: POP
// tech := tech_mortar ; 3 :
53894: LD_ADDR_VAR 0 5
53898: PUSH
53899: LD_INT 41
53901: ST_TO_ADDR
53902: GO 53924
53904: LD_INT 3
53906: DOUBLE
53907: EQUAL
53908: IFTRUE 53912
53910: GO 53923
53912: POP
// tech := tech_bazooka ; end ;
53913: LD_ADDR_VAR 0 5
53917: PUSH
53918: LD_INT 44
53920: ST_TO_ADDR
53921: GO 53924
53923: POP
// if Researched ( side , tech ) then
53924: LD_VAR 0 3
53928: PPUSH
53929: LD_VAR 0 5
53933: PPUSH
53934: CALL_OW 325
53938: IFFALSE 53965
// result := [ class_sniper , class_mortar , class_bazooker ] [ nat ] ;
53940: LD_ADDR_VAR 0 2
53944: PUSH
53945: LD_INT 5
53947: PUSH
53948: LD_INT 8
53950: PUSH
53951: LD_INT 9
53953: PUSH
53954: EMPTY
53955: LIST
53956: LIST
53957: LIST
53958: PUSH
53959: LD_VAR 0 4
53963: ARRAY
53964: ST_TO_ADDR
// end ;
53965: LD_VAR 0 2
53969: RET
// export function DetonateMines ( side , mines ) ; var i , tmp ; begin
53970: LD_INT 0
53972: PPUSH
53973: PPUSH
53974: PPUSH
// if not mines then
53975: LD_VAR 0 2
53979: NOT
53980: IFFALSE 53984
// exit ;
53982: GO 54128
// tmp := FilterAllUnits ( [ [ f_enemy , side ] , [ f_not , [ f_type , unit_building ] ] ] ) ;
53984: LD_ADDR_VAR 0 5
53988: PUSH
53989: LD_INT 81
53991: PUSH
53992: LD_VAR 0 1
53996: PUSH
53997: EMPTY
53998: LIST
53999: LIST
54000: PUSH
54001: LD_INT 3
54003: PUSH
54004: LD_INT 21
54006: PUSH
54007: LD_INT 3
54009: PUSH
54010: EMPTY
54011: LIST
54012: LIST
54013: PUSH
54014: EMPTY
54015: LIST
54016: LIST
54017: PUSH
54018: EMPTY
54019: LIST
54020: LIST
54021: PPUSH
54022: CALL_OW 69
54026: ST_TO_ADDR
// for i in mines do
54027: LD_ADDR_VAR 0 4
54031: PUSH
54032: LD_VAR 0 2
54036: PUSH
54037: FOR_IN
54038: IFFALSE 54126
// begin if not MineAtPos ( i [ 1 ] , i [ 2 ] ) then
54040: LD_VAR 0 4
54044: PUSH
54045: LD_INT 1
54047: ARRAY
54048: PPUSH
54049: LD_VAR 0 4
54053: PUSH
54054: LD_INT 2
54056: ARRAY
54057: PPUSH
54058: CALL_OW 458
54062: NOT
54063: IFFALSE 54067
// continue ;
54065: GO 54037
// if HexInfo ( i [ 1 ] , i [ 2 ] ) in tmp then
54067: LD_VAR 0 4
54071: PUSH
54072: LD_INT 1
54074: ARRAY
54075: PPUSH
54076: LD_VAR 0 4
54080: PUSH
54081: LD_INT 2
54083: ARRAY
54084: PPUSH
54085: CALL_OW 428
54089: PUSH
54090: LD_VAR 0 5
54094: IN
54095: IFFALSE 54124
// LaunchMineAtPos ( i [ 1 ] , i [ 2 ] , side ) ;
54097: LD_VAR 0 4
54101: PUSH
54102: LD_INT 1
54104: ARRAY
54105: PPUSH
54106: LD_VAR 0 4
54110: PUSH
54111: LD_INT 2
54113: ARRAY
54114: PPUSH
54115: LD_VAR 0 1
54119: PPUSH
54120: CALL_OW 456
// end ;
54124: GO 54037
54126: POP
54127: POP
// end ;
54128: LD_VAR 0 3
54132: RET
// export function Count ( array ) ; var i ; begin
54133: LD_INT 0
54135: PPUSH
54136: PPUSH
// result := 0 ;
54137: LD_ADDR_VAR 0 2
54141: PUSH
54142: LD_INT 0
54144: ST_TO_ADDR
// for i in array do
54145: LD_ADDR_VAR 0 3
54149: PUSH
54150: LD_VAR 0 1
54154: PUSH
54155: FOR_IN
54156: IFFALSE 54180
// if i then
54158: LD_VAR 0 3
54162: IFFALSE 54178
// result := result + 1 ;
54164: LD_ADDR_VAR 0 2
54168: PUSH
54169: LD_VAR 0 2
54173: PUSH
54174: LD_INT 1
54176: PLUS
54177: ST_TO_ADDR
54178: GO 54155
54180: POP
54181: POP
// end ;
54182: LD_VAR 0 2
54186: RET
// export function IsEmpty ( building ) ; begin
54187: LD_INT 0
54189: PPUSH
// if not building then
54190: LD_VAR 0 1
54194: NOT
54195: IFFALSE 54199
// exit ;
54197: GO 54242
// result := building in FilterAllUnits ( [ [ f_side , GetSide ( building ) ] , [ f_empty ] ] ) ;
54199: LD_ADDR_VAR 0 2
54203: PUSH
54204: LD_VAR 0 1
54208: PUSH
54209: LD_INT 22
54211: PUSH
54212: LD_VAR 0 1
54216: PPUSH
54217: CALL_OW 255
54221: PUSH
54222: EMPTY
54223: LIST
54224: LIST
54225: PUSH
54226: LD_INT 58
54228: PUSH
54229: EMPTY
54230: LIST
54231: PUSH
54232: EMPTY
54233: LIST
54234: LIST
54235: PPUSH
54236: CALL_OW 69
54240: IN
54241: ST_TO_ADDR
// end ;
54242: LD_VAR 0 2
54246: RET
// export function IsNotFull ( building ) ; begin
54247: LD_INT 0
54249: PPUSH
// if not building then
54250: LD_VAR 0 1
54254: NOT
54255: IFFALSE 54259
// exit ;
54257: GO 54278
// result := UnitsInside ( building ) < 6 ;
54259: LD_ADDR_VAR 0 2
54263: PUSH
54264: LD_VAR 0 1
54268: PPUSH
54269: CALL_OW 313
54273: PUSH
54274: LD_INT 6
54276: LESS
54277: ST_TO_ADDR
// end ;
54278: LD_VAR 0 2
54282: RET
// export function GetFacExt ( factory ) ; var tmp , i , list ; begin
54283: LD_INT 0
54285: PPUSH
54286: PPUSH
54287: PPUSH
54288: PPUSH
// tmp := [ ] ;
54289: LD_ADDR_VAR 0 3
54293: PUSH
54294: EMPTY
54295: ST_TO_ADDR
// list := [ ] ;
54296: LD_ADDR_VAR 0 5
54300: PUSH
54301: EMPTY
54302: ST_TO_ADDR
// for i = 16 to 25 do
54303: LD_ADDR_VAR 0 4
54307: PUSH
54308: DOUBLE
54309: LD_INT 16
54311: DEC
54312: ST_TO_ADDR
54313: LD_INT 25
54315: PUSH
54316: FOR_TO
54317: IFFALSE 54390
// tmp := tmp ^ FilterAllUnits ( [ [ [ f_side , GetSide ( factory ) ] , [ f_dist , factory , 6 ] , [ f_btype , i ] ] ] ) ;
54319: LD_ADDR_VAR 0 3
54323: PUSH
54324: LD_VAR 0 3
54328: PUSH
54329: LD_INT 22
54331: PUSH
54332: LD_VAR 0 1
54336: PPUSH
54337: CALL_OW 255
54341: PUSH
54342: EMPTY
54343: LIST
54344: LIST
54345: PUSH
54346: LD_INT 91
54348: PUSH
54349: LD_VAR 0 1
54353: PUSH
54354: LD_INT 6
54356: PUSH
54357: EMPTY
54358: LIST
54359: LIST
54360: LIST
54361: PUSH
54362: LD_INT 30
54364: PUSH
54365: LD_VAR 0 4
54369: PUSH
54370: EMPTY
54371: LIST
54372: LIST
54373: PUSH
54374: EMPTY
54375: LIST
54376: LIST
54377: LIST
54378: PUSH
54379: EMPTY
54380: LIST
54381: PPUSH
54382: CALL_OW 69
54386: ADD
54387: ST_TO_ADDR
54388: GO 54316
54390: POP
54391: POP
// for i = 1 to tmp do
54392: LD_ADDR_VAR 0 4
54396: PUSH
54397: DOUBLE
54398: LD_INT 1
54400: DEC
54401: ST_TO_ADDR
54402: LD_VAR 0 3
54406: PUSH
54407: FOR_TO
54408: IFFALSE 54496
// list := list ^ [ [ GetBType ( tmp [ i ] ) , GetX ( tmp [ i ] ) , GetY ( tmp [ i ] ) , GetDir ( tmp [ i ] ) ] ] ;
54410: LD_ADDR_VAR 0 5
54414: PUSH
54415: LD_VAR 0 5
54419: PUSH
54420: LD_VAR 0 3
54424: PUSH
54425: LD_VAR 0 4
54429: ARRAY
54430: PPUSH
54431: CALL_OW 266
54435: PUSH
54436: LD_VAR 0 3
54440: PUSH
54441: LD_VAR 0 4
54445: ARRAY
54446: PPUSH
54447: CALL_OW 250
54451: PUSH
54452: LD_VAR 0 3
54456: PUSH
54457: LD_VAR 0 4
54461: ARRAY
54462: PPUSH
54463: CALL_OW 251
54467: PUSH
54468: LD_VAR 0 3
54472: PUSH
54473: LD_VAR 0 4
54477: ARRAY
54478: PPUSH
54479: CALL_OW 254
54483: PUSH
54484: EMPTY
54485: LIST
54486: LIST
54487: LIST
54488: LIST
54489: PUSH
54490: EMPTY
54491: LIST
54492: ADD
54493: ST_TO_ADDR
54494: GO 54407
54496: POP
54497: POP
// result := list ;
54498: LD_ADDR_VAR 0 2
54502: PUSH
54503: LD_VAR 0 5
54507: ST_TO_ADDR
// end ;
54508: LD_VAR 0 2
54512: RET
// export function Produce ( factory , chassis , engine , control , weapon ) ; var i , tmp , _chassis , _weapon , _engine , _control ; begin
54513: LD_INT 0
54515: PPUSH
54516: PPUSH
54517: PPUSH
54518: PPUSH
54519: PPUSH
54520: PPUSH
54521: PPUSH
// if not factory then
54522: LD_VAR 0 1
54526: NOT
54527: IFFALSE 54531
// exit ;
54529: GO 55124
// if control = control_apeman then
54531: LD_VAR 0 4
54535: PUSH
54536: LD_INT 5
54538: EQUAL
54539: IFFALSE 54648
// begin tmp := UnitsInside ( factory ) ;
54541: LD_ADDR_VAR 0 8
54545: PUSH
54546: LD_VAR 0 1
54550: PPUSH
54551: CALL_OW 313
54555: ST_TO_ADDR
// if not UnitFilter ( tmp , [ f_class , class_apeman ] ) then
54556: LD_VAR 0 8
54560: PPUSH
54561: LD_INT 25
54563: PUSH
54564: LD_INT 12
54566: PUSH
54567: EMPTY
54568: LIST
54569: LIST
54570: PPUSH
54571: CALL_OW 72
54575: NOT
54576: IFFALSE 54586
// control := control_manual ;
54578: LD_ADDR_VAR 0 4
54582: PUSH
54583: LD_INT 1
54585: ST_TO_ADDR
// tmp := GetFacExt ( factory ) ;
54586: LD_ADDR_VAR 0 8
54590: PUSH
54591: LD_VAR 0 1
54595: PPUSH
54596: CALL 54283 0 1
54600: ST_TO_ADDR
// if tmp then
54601: LD_VAR 0 8
54605: IFFALSE 54648
// begin for i in tmp do
54607: LD_ADDR_VAR 0 7
54611: PUSH
54612: LD_VAR 0 8
54616: PUSH
54617: FOR_IN
54618: IFFALSE 54646
// if i [ 1 ] = b_ext_radio then
54620: LD_VAR 0 7
54624: PUSH
54625: LD_INT 1
54627: ARRAY
54628: PUSH
54629: LD_INT 22
54631: EQUAL
54632: IFFALSE 54644
// begin control := control_remote ;
54634: LD_ADDR_VAR 0 4
54638: PUSH
54639: LD_INT 2
54641: ST_TO_ADDR
// break ;
54642: GO 54646
// end ;
54644: GO 54617
54646: POP
54647: POP
// end ; end ; if CanBeConstructed ( factory , chassis , engine , control , weapon ) then
54648: LD_VAR 0 1
54652: PPUSH
54653: LD_VAR 0 2
54657: PPUSH
54658: LD_VAR 0 3
54662: PPUSH
54663: LD_VAR 0 4
54667: PPUSH
54668: LD_VAR 0 5
54672: PPUSH
54673: CALL_OW 448
54677: IFFALSE 54712
// begin result := [ chassis , engine , control , weapon ] ;
54679: LD_ADDR_VAR 0 6
54683: PUSH
54684: LD_VAR 0 2
54688: PUSH
54689: LD_VAR 0 3
54693: PUSH
54694: LD_VAR 0 4
54698: PUSH
54699: LD_VAR 0 5
54703: PUSH
54704: EMPTY
54705: LIST
54706: LIST
54707: LIST
54708: LIST
54709: ST_TO_ADDR
// exit ;
54710: GO 55124
// end ; _chassis := AvailableChassisList ( factory ) ;
54712: LD_ADDR_VAR 0 9
54716: PUSH
54717: LD_VAR 0 1
54721: PPUSH
54722: CALL_OW 475
54726: ST_TO_ADDR
// _engine := AvailableEngineList ( factory ) ;
54727: LD_ADDR_VAR 0 11
54731: PUSH
54732: LD_VAR 0 1
54736: PPUSH
54737: CALL_OW 476
54741: ST_TO_ADDR
// _control := AvailableControlList ( factory ) ;
54742: LD_ADDR_VAR 0 12
54746: PUSH
54747: LD_VAR 0 1
54751: PPUSH
54752: CALL_OW 477
54756: ST_TO_ADDR
// _weapon := AvailableWeaponList ( factory ) ;
54757: LD_ADDR_VAR 0 10
54761: PUSH
54762: LD_VAR 0 1
54766: PPUSH
54767: CALL_OW 478
54771: ST_TO_ADDR
// if not _chassis or not _engine or not _control or not _weapon then
54772: LD_VAR 0 9
54776: NOT
54777: PUSH
54778: LD_VAR 0 11
54782: NOT
54783: OR
54784: PUSH
54785: LD_VAR 0 12
54789: NOT
54790: OR
54791: PUSH
54792: LD_VAR 0 10
54796: NOT
54797: OR
54798: IFFALSE 54833
// begin result := [ chassis , engine , control , weapon ] ;
54800: LD_ADDR_VAR 0 6
54804: PUSH
54805: LD_VAR 0 2
54809: PUSH
54810: LD_VAR 0 3
54814: PUSH
54815: LD_VAR 0 4
54819: PUSH
54820: LD_VAR 0 5
54824: PUSH
54825: EMPTY
54826: LIST
54827: LIST
54828: LIST
54829: LIST
54830: ST_TO_ADDR
// exit ;
54831: GO 55124
// end ; if not chassis in _chassis then
54833: LD_VAR 0 2
54837: PUSH
54838: LD_VAR 0 9
54842: IN
54843: NOT
54844: IFFALSE 54870
// chassis := _chassis [ rand ( 1 , _chassis ) ] ;
54846: LD_ADDR_VAR 0 2
54850: PUSH
54851: LD_VAR 0 9
54855: PUSH
54856: LD_INT 1
54858: PPUSH
54859: LD_VAR 0 9
54863: PPUSH
54864: CALL_OW 12
54868: ARRAY
54869: ST_TO_ADDR
// if not EngineCanBeMount ( chassis , engine ) then
54870: LD_VAR 0 2
54874: PPUSH
54875: LD_VAR 0 3
54879: PPUSH
54880: CALL 55129 0 2
54884: NOT
54885: IFFALSE 54944
// repeat engine := _engine [ 1 ] ;
54887: LD_ADDR_VAR 0 3
54891: PUSH
54892: LD_VAR 0 11
54896: PUSH
54897: LD_INT 1
54899: ARRAY
54900: ST_TO_ADDR
// _engine := Delete ( _engine , 1 ) ;
54901: LD_ADDR_VAR 0 11
54905: PUSH
54906: LD_VAR 0 11
54910: PPUSH
54911: LD_INT 1
54913: PPUSH
54914: CALL_OW 3
54918: ST_TO_ADDR
// until EngineCanBeMount ( chassis , engine ) or _engine = [ ] ;
54919: LD_VAR 0 2
54923: PPUSH
54924: LD_VAR 0 3
54928: PPUSH
54929: CALL 55129 0 2
54933: PUSH
54934: LD_VAR 0 11
54938: PUSH
54939: EMPTY
54940: EQUAL
54941: OR
54942: IFFALSE 54887
// if not control in _control then
54944: LD_VAR 0 4
54948: PUSH
54949: LD_VAR 0 12
54953: IN
54954: NOT
54955: IFFALSE 54981
// control := _control [ rand ( 1 , _control ) ] ;
54957: LD_ADDR_VAR 0 4
54961: PUSH
54962: LD_VAR 0 12
54966: PUSH
54967: LD_INT 1
54969: PPUSH
54970: LD_VAR 0 12
54974: PPUSH
54975: CALL_OW 12
54979: ARRAY
54980: ST_TO_ADDR
// if not WeaponCanBeMount ( chassis , weapon ) then
54981: LD_VAR 0 2
54985: PPUSH
54986: LD_VAR 0 5
54990: PPUSH
54991: CALL 55349 0 2
54995: NOT
54996: IFFALSE 55055
// repeat weapon := _weapon [ 1 ] ;
54998: LD_ADDR_VAR 0 5
55002: PUSH
55003: LD_VAR 0 10
55007: PUSH
55008: LD_INT 1
55010: ARRAY
55011: ST_TO_ADDR
// _weapon := Delete ( _weapon , 1 ) ;
55012: LD_ADDR_VAR 0 10
55016: PUSH
55017: LD_VAR 0 10
55021: PPUSH
55022: LD_INT 1
55024: PPUSH
55025: CALL_OW 3
55029: ST_TO_ADDR
// until WeaponCanBeMount ( chassis , weapon ) or _weapon = [ ] ;
55030: LD_VAR 0 2
55034: PPUSH
55035: LD_VAR 0 5
55039: PPUSH
55040: CALL 55349 0 2
55044: PUSH
55045: LD_VAR 0 10
55049: PUSH
55050: EMPTY
55051: EQUAL
55052: OR
55053: IFFALSE 54998
// result := [ ] ;
55055: LD_ADDR_VAR 0 6
55059: PUSH
55060: EMPTY
55061: ST_TO_ADDR
// if CanBeConstructed ( factory , chassis , engine , control , weapon ) then
55062: LD_VAR 0 1
55066: PPUSH
55067: LD_VAR 0 2
55071: PPUSH
55072: LD_VAR 0 3
55076: PPUSH
55077: LD_VAR 0 4
55081: PPUSH
55082: LD_VAR 0 5
55086: PPUSH
55087: CALL_OW 448
55091: IFFALSE 55124
// result := [ chassis , engine , control , weapon ] ;
55093: LD_ADDR_VAR 0 6
55097: PUSH
55098: LD_VAR 0 2
55102: PUSH
55103: LD_VAR 0 3
55107: PUSH
55108: LD_VAR 0 4
55112: PUSH
55113: LD_VAR 0 5
55117: PUSH
55118: EMPTY
55119: LIST
55120: LIST
55121: LIST
55122: LIST
55123: ST_TO_ADDR
// end ;
55124: LD_VAR 0 6
55128: RET
// export function EngineCanBeMount ( chassis , engine ) ; begin
55129: LD_INT 0
55131: PPUSH
// if not chassis or not engine then
55132: LD_VAR 0 1
55136: NOT
55137: PUSH
55138: LD_VAR 0 2
55142: NOT
55143: OR
55144: IFFALSE 55148
// exit ;
55146: GO 55344
// case engine of engine_solar :
55148: LD_VAR 0 2
55152: PUSH
55153: LD_INT 2
55155: DOUBLE
55156: EQUAL
55157: IFTRUE 55161
55159: GO 55199
55161: POP
// result := [ ar_hovercraft , ar_light_trike , ar_medium_trike , ar_half_tracked , us_light_wheeled , us_medium_wheeled , us_medium_tracked ] ; engine_combustion :
55162: LD_ADDR_VAR 0 3
55166: PUSH
55167: LD_INT 11
55169: PUSH
55170: LD_INT 12
55172: PUSH
55173: LD_INT 13
55175: PUSH
55176: LD_INT 14
55178: PUSH
55179: LD_INT 1
55181: PUSH
55182: LD_INT 2
55184: PUSH
55185: LD_INT 3
55187: PUSH
55188: EMPTY
55189: LIST
55190: LIST
55191: LIST
55192: LIST
55193: LIST
55194: LIST
55195: LIST
55196: ST_TO_ADDR
55197: GO 55328
55199: LD_INT 1
55201: DOUBLE
55202: EQUAL
55203: IFTRUE 55207
55205: GO 55269
55207: POP
// result := [ ar_hovercraft , ar_light_trike , ar_medium_trike , ar_half_tracked , us_light_wheeled , us_medium_wheeled , us_medium_tracked , us_heavy_tracked , us_morphling , ru_medium_wheeled , ru_heavy_wheeled , ru_medium_tracked , ru_heavy_tracked ] ; engine_siberite :
55208: LD_ADDR_VAR 0 3
55212: PUSH
55213: LD_INT 11
55215: PUSH
55216: LD_INT 12
55218: PUSH
55219: LD_INT 13
55221: PUSH
55222: LD_INT 14
55224: PUSH
55225: LD_INT 1
55227: PUSH
55228: LD_INT 2
55230: PUSH
55231: LD_INT 3
55233: PUSH
55234: LD_INT 4
55236: PUSH
55237: LD_INT 5
55239: PUSH
55240: LD_INT 21
55242: PUSH
55243: LD_INT 23
55245: PUSH
55246: LD_INT 22
55248: PUSH
55249: LD_INT 24
55251: PUSH
55252: EMPTY
55253: LIST
55254: LIST
55255: LIST
55256: LIST
55257: LIST
55258: LIST
55259: LIST
55260: LIST
55261: LIST
55262: LIST
55263: LIST
55264: LIST
55265: LIST
55266: ST_TO_ADDR
55267: GO 55328
55269: LD_INT 3
55271: DOUBLE
55272: EQUAL
55273: IFTRUE 55277
55275: GO 55327
55277: POP
// result := [ ar_medium_trike , ar_half_tracked , us_medium_wheeled , us_medium_tracked , us_heavy_tracked , us_morphling , ru_medium_wheeled , ru_medium_tracked , ru_heavy_wheeled , ru_heavy_tracked ] ; end ;
55278: LD_ADDR_VAR 0 3
55282: PUSH
55283: LD_INT 13
55285: PUSH
55286: LD_INT 14
55288: PUSH
55289: LD_INT 2
55291: PUSH
55292: LD_INT 3
55294: PUSH
55295: LD_INT 4
55297: PUSH
55298: LD_INT 5
55300: PUSH
55301: LD_INT 21
55303: PUSH
55304: LD_INT 22
55306: PUSH
55307: LD_INT 23
55309: PUSH
55310: LD_INT 24
55312: PUSH
55313: EMPTY
55314: LIST
55315: LIST
55316: LIST
55317: LIST
55318: LIST
55319: LIST
55320: LIST
55321: LIST
55322: LIST
55323: LIST
55324: ST_TO_ADDR
55325: GO 55328
55327: POP
// result := ( chassis in result ) ;
55328: LD_ADDR_VAR 0 3
55332: PUSH
55333: LD_VAR 0 1
55337: PUSH
55338: LD_VAR 0 3
55342: IN
55343: ST_TO_ADDR
// end ;
55344: LD_VAR 0 3
55348: RET
// export function WeaponCanBeMount ( chassis , weapon ) ; begin
55349: LD_INT 0
55351: PPUSH
// if not chassis or not weapon then
55352: LD_VAR 0 1
55356: NOT
55357: PUSH
55358: LD_VAR 0 2
55362: NOT
55363: OR
55364: IFFALSE 55368
// exit ;
55366: GO 56430
// case weapon of us_machine_gun :
55368: LD_VAR 0 2
55372: PUSH
55373: LD_INT 2
55375: DOUBLE
55376: EQUAL
55377: IFTRUE 55381
55379: GO 55411
55381: POP
// result := [ us_light_wheeled , us_medium_wheeled , us_medium_tracked , us_heavy_tracked , us_morphling ] ; us_light_gun :
55382: LD_ADDR_VAR 0 3
55386: PUSH
55387: LD_INT 1
55389: PUSH
55390: LD_INT 2
55392: PUSH
55393: LD_INT 3
55395: PUSH
55396: LD_INT 4
55398: PUSH
55399: LD_INT 5
55401: PUSH
55402: EMPTY
55403: LIST
55404: LIST
55405: LIST
55406: LIST
55407: LIST
55408: ST_TO_ADDR
55409: GO 56414
55411: LD_INT 3
55413: DOUBLE
55414: EQUAL
55415: IFTRUE 55419
55417: GO 55449
55419: POP
// result := [ us_light_wheeled , us_medium_wheeled , us_medium_tracked , us_heavy_tracked , us_morphling ] ; us_radar :
55420: LD_ADDR_VAR 0 3
55424: PUSH
55425: LD_INT 1
55427: PUSH
55428: LD_INT 2
55430: PUSH
55431: LD_INT 3
55433: PUSH
55434: LD_INT 4
55436: PUSH
55437: LD_INT 5
55439: PUSH
55440: EMPTY
55441: LIST
55442: LIST
55443: LIST
55444: LIST
55445: LIST
55446: ST_TO_ADDR
55447: GO 56414
55449: LD_INT 11
55451: DOUBLE
55452: EQUAL
55453: IFTRUE 55457
55455: GO 55487
55457: POP
// result := [ us_light_wheeled , us_medium_wheeled , us_medium_tracked , us_heavy_tracked , us_morphling ] ; us_gatling_gun :
55458: LD_ADDR_VAR 0 3
55462: PUSH
55463: LD_INT 1
55465: PUSH
55466: LD_INT 2
55468: PUSH
55469: LD_INT 3
55471: PUSH
55472: LD_INT 4
55474: PUSH
55475: LD_INT 5
55477: PUSH
55478: EMPTY
55479: LIST
55480: LIST
55481: LIST
55482: LIST
55483: LIST
55484: ST_TO_ADDR
55485: GO 56414
55487: LD_INT 4
55489: DOUBLE
55490: EQUAL
55491: IFTRUE 55495
55493: GO 55521
55495: POP
// result := [ us_medium_wheeled , us_medium_tracked , us_heavy_tracked , us_morphling ] ; us_double_gun :
55496: LD_ADDR_VAR 0 3
55500: PUSH
55501: LD_INT 2
55503: PUSH
55504: LD_INT 3
55506: PUSH
55507: LD_INT 4
55509: PUSH
55510: LD_INT 5
55512: PUSH
55513: EMPTY
55514: LIST
55515: LIST
55516: LIST
55517: LIST
55518: ST_TO_ADDR
55519: GO 56414
55521: LD_INT 5
55523: DOUBLE
55524: EQUAL
55525: IFTRUE 55529
55527: GO 55555
55529: POP
// result := [ us_medium_wheeled , us_medium_tracked , us_heavy_tracked , us_morphling ] ; us_laser :
55530: LD_ADDR_VAR 0 3
55534: PUSH
55535: LD_INT 2
55537: PUSH
55538: LD_INT 3
55540: PUSH
55541: LD_INT 4
55543: PUSH
55544: LD_INT 5
55546: PUSH
55547: EMPTY
55548: LIST
55549: LIST
55550: LIST
55551: LIST
55552: ST_TO_ADDR
55553: GO 56414
55555: LD_INT 9
55557: DOUBLE
55558: EQUAL
55559: IFTRUE 55563
55561: GO 55589
55563: POP
// result := [ us_medium_wheeled , us_medium_tracked , us_heavy_tracked , us_morphling ] ; us_rocket_launcher :
55564: LD_ADDR_VAR 0 3
55568: PUSH
55569: LD_INT 2
55571: PUSH
55572: LD_INT 3
55574: PUSH
55575: LD_INT 4
55577: PUSH
55578: LD_INT 5
55580: PUSH
55581: EMPTY
55582: LIST
55583: LIST
55584: LIST
55585: LIST
55586: ST_TO_ADDR
55587: GO 56414
55589: LD_INT 7
55591: DOUBLE
55592: EQUAL
55593: IFTRUE 55597
55595: GO 55623
55597: POP
// result := [ us_medium_wheeled , us_medium_tracked , us_heavy_tracked , us_morphling ] ; us_cargo_bay :
55598: LD_ADDR_VAR 0 3
55602: PUSH
55603: LD_INT 2
55605: PUSH
55606: LD_INT 3
55608: PUSH
55609: LD_INT 4
55611: PUSH
55612: LD_INT 5
55614: PUSH
55615: EMPTY
55616: LIST
55617: LIST
55618: LIST
55619: LIST
55620: ST_TO_ADDR
55621: GO 56414
55623: LD_INT 12
55625: DOUBLE
55626: EQUAL
55627: IFTRUE 55631
55629: GO 55657
55631: POP
// result := [ us_medium_wheeled , us_medium_tracked , us_heavy_tracked , us_morphling ] ; us_crane :
55632: LD_ADDR_VAR 0 3
55636: PUSH
55637: LD_INT 2
55639: PUSH
55640: LD_INT 3
55642: PUSH
55643: LD_INT 4
55645: PUSH
55646: LD_INT 5
55648: PUSH
55649: EMPTY
55650: LIST
55651: LIST
55652: LIST
55653: LIST
55654: ST_TO_ADDR
55655: GO 56414
55657: LD_INT 13
55659: DOUBLE
55660: EQUAL
55661: IFTRUE 55665
55663: GO 55691
55665: POP
// result := [ us_medium_wheeled , us_medium_tracked , us_heavy_tracked , us_morphling ] ; us_bulldozer :
55666: LD_ADDR_VAR 0 3
55670: PUSH
55671: LD_INT 2
55673: PUSH
55674: LD_INT 3
55676: PUSH
55677: LD_INT 4
55679: PUSH
55680: LD_INT 5
55682: PUSH
55683: EMPTY
55684: LIST
55685: LIST
55686: LIST
55687: LIST
55688: ST_TO_ADDR
55689: GO 56414
55691: LD_INT 14
55693: DOUBLE
55694: EQUAL
55695: IFTRUE 55699
55697: GO 55717
55699: POP
// result := [ us_heavy_tracked , us_morphling ] ; us_heavy_gun :
55700: LD_ADDR_VAR 0 3
55704: PUSH
55705: LD_INT 4
55707: PUSH
55708: LD_INT 5
55710: PUSH
55711: EMPTY
55712: LIST
55713: LIST
55714: ST_TO_ADDR
55715: GO 56414
55717: LD_INT 6
55719: DOUBLE
55720: EQUAL
55721: IFTRUE 55725
55723: GO 55743
55725: POP
// result := [ us_heavy_tracked , us_morphling ] ; us_double_laser :
55726: LD_ADDR_VAR 0 3
55730: PUSH
55731: LD_INT 4
55733: PUSH
55734: LD_INT 5
55736: PUSH
55737: EMPTY
55738: LIST
55739: LIST
55740: ST_TO_ADDR
55741: GO 56414
55743: LD_INT 10
55745: DOUBLE
55746: EQUAL
55747: IFTRUE 55751
55749: GO 55769
55751: POP
// result := [ us_heavy_tracked , us_morphling ] ; ar_multimissile_ballista :
55752: LD_ADDR_VAR 0 3
55756: PUSH
55757: LD_INT 4
55759: PUSH
55760: LD_INT 5
55762: PUSH
55763: EMPTY
55764: LIST
55765: LIST
55766: ST_TO_ADDR
55767: GO 56414
55769: LD_INT 22
55771: DOUBLE
55772: EQUAL
55773: IFTRUE 55777
55775: GO 55803
55777: POP
// result := [ ar_hovercraft , ar_light_trike , ar_medium_trike , ar_half_tracked ] ; ar_light_gun :
55778: LD_ADDR_VAR 0 3
55782: PUSH
55783: LD_INT 11
55785: PUSH
55786: LD_INT 12
55788: PUSH
55789: LD_INT 13
55791: PUSH
55792: LD_INT 14
55794: PUSH
55795: EMPTY
55796: LIST
55797: LIST
55798: LIST
55799: LIST
55800: ST_TO_ADDR
55801: GO 56414
55803: LD_INT 23
55805: DOUBLE
55806: EQUAL
55807: IFTRUE 55811
55809: GO 55837
55811: POP
// result := [ ar_hovercraft , ar_light_trike , ar_medium_trike , ar_half_tracked ] ; ar_double_machine_gun :
55812: LD_ADDR_VAR 0 3
55816: PUSH
55817: LD_INT 11
55819: PUSH
55820: LD_INT 12
55822: PUSH
55823: LD_INT 13
55825: PUSH
55826: LD_INT 14
55828: PUSH
55829: EMPTY
55830: LIST
55831: LIST
55832: LIST
55833: LIST
55834: ST_TO_ADDR
55835: GO 56414
55837: LD_INT 24
55839: DOUBLE
55840: EQUAL
55841: IFTRUE 55845
55843: GO 55871
55845: POP
// result := [ ar_hovercraft , ar_light_trike , ar_medium_trike , ar_half_tracked ] ; ar_radar :
55846: LD_ADDR_VAR 0 3
55850: PUSH
55851: LD_INT 11
55853: PUSH
55854: LD_INT 12
55856: PUSH
55857: LD_INT 13
55859: PUSH
55860: LD_INT 14
55862: PUSH
55863: EMPTY
55864: LIST
55865: LIST
55866: LIST
55867: LIST
55868: ST_TO_ADDR
55869: GO 56414
55871: LD_INT 30
55873: DOUBLE
55874: EQUAL
55875: IFTRUE 55879
55877: GO 55905
55879: POP
// result := [ ar_hovercraft , ar_light_trike , ar_medium_trike , ar_half_tracked ] ; ar_gatling_gun :
55880: LD_ADDR_VAR 0 3
55884: PUSH
55885: LD_INT 11
55887: PUSH
55888: LD_INT 12
55890: PUSH
55891: LD_INT 13
55893: PUSH
55894: LD_INT 14
55896: PUSH
55897: EMPTY
55898: LIST
55899: LIST
55900: LIST
55901: LIST
55902: ST_TO_ADDR
55903: GO 56414
55905: LD_INT 25
55907: DOUBLE
55908: EQUAL
55909: IFTRUE 55913
55911: GO 55931
55913: POP
// result := [ ar_medium_trike , ar_half_tracked ] ; ar_gun :
55914: LD_ADDR_VAR 0 3
55918: PUSH
55919: LD_INT 13
55921: PUSH
55922: LD_INT 14
55924: PUSH
55925: EMPTY
55926: LIST
55927: LIST
55928: ST_TO_ADDR
55929: GO 56414
55931: LD_INT 27
55933: DOUBLE
55934: EQUAL
55935: IFTRUE 55939
55937: GO 55957
55939: POP
// result := [ ar_medium_trike , ar_half_tracked ] ; ar_mortar :
55940: LD_ADDR_VAR 0 3
55944: PUSH
55945: LD_INT 13
55947: PUSH
55948: LD_INT 14
55950: PUSH
55951: EMPTY
55952: LIST
55953: LIST
55954: ST_TO_ADDR
55955: GO 56414
55957: LD_EXP 79
55961: DOUBLE
55962: EQUAL
55963: IFTRUE 55967
55965: GO 55993
55967: POP
// result := [ ar_hovercraft , ar_light_trike , ar_medium_trike , ar_half_tracked ] ; ar_rocket_launcher :
55968: LD_ADDR_VAR 0 3
55972: PUSH
55973: LD_INT 11
55975: PUSH
55976: LD_INT 12
55978: PUSH
55979: LD_INT 13
55981: PUSH
55982: LD_INT 14
55984: PUSH
55985: EMPTY
55986: LIST
55987: LIST
55988: LIST
55989: LIST
55990: ST_TO_ADDR
55991: GO 56414
55993: LD_INT 28
55995: DOUBLE
55996: EQUAL
55997: IFTRUE 56001
55999: GO 56019
56001: POP
// result := [ ar_medium_trike , ar_half_tracked ] ; ar_selfpropelled_bomb :
56002: LD_ADDR_VAR 0 3
56006: PUSH
56007: LD_INT 13
56009: PUSH
56010: LD_INT 14
56012: PUSH
56013: EMPTY
56014: LIST
56015: LIST
56016: ST_TO_ADDR
56017: GO 56414
56019: LD_INT 29
56021: DOUBLE
56022: EQUAL
56023: IFTRUE 56027
56025: GO 56045
56027: POP
// result := [ ar_medium_trike , ar_half_tracked ] ; ar_control_tower :
56028: LD_ADDR_VAR 0 3
56032: PUSH
56033: LD_INT 13
56035: PUSH
56036: LD_INT 14
56038: PUSH
56039: EMPTY
56040: LIST
56041: LIST
56042: ST_TO_ADDR
56043: GO 56414
56045: LD_INT 31
56047: DOUBLE
56048: EQUAL
56049: IFTRUE 56053
56051: GO 56071
56053: POP
// result := [ ar_medium_trike , ar_half_tracked ] ; ar_flame_thrower :
56054: LD_ADDR_VAR 0 3
56058: PUSH
56059: LD_INT 13
56061: PUSH
56062: LD_INT 14
56064: PUSH
56065: EMPTY
56066: LIST
56067: LIST
56068: ST_TO_ADDR
56069: GO 56414
56071: LD_INT 26
56073: DOUBLE
56074: EQUAL
56075: IFTRUE 56079
56077: GO 56097
56079: POP
// result := [ ar_medium_trike , ar_half_tracked ] ; ru_heavy_machine_gun :
56080: LD_ADDR_VAR 0 3
56084: PUSH
56085: LD_INT 13
56087: PUSH
56088: LD_INT 14
56090: PUSH
56091: EMPTY
56092: LIST
56093: LIST
56094: ST_TO_ADDR
56095: GO 56414
56097: LD_INT 42
56099: DOUBLE
56100: EQUAL
56101: IFTRUE 56105
56103: GO 56131
56105: POP
// result := [ ru_medium_wheeled , ru_medium_tracked , ru_heavy_wheeled , ru_heavy_tracked ] ; ru_gatling_gun :
56106: LD_ADDR_VAR 0 3
56110: PUSH
56111: LD_INT 21
56113: PUSH
56114: LD_INT 22
56116: PUSH
56117: LD_INT 23
56119: PUSH
56120: LD_INT 24
56122: PUSH
56123: EMPTY
56124: LIST
56125: LIST
56126: LIST
56127: LIST
56128: ST_TO_ADDR
56129: GO 56414
56131: LD_INT 43
56133: DOUBLE
56134: EQUAL
56135: IFTRUE 56139
56137: GO 56165
56139: POP
// result := [ ru_medium_wheeled , ru_medium_tracked , ru_heavy_wheeled , ru_heavy_tracked ] ; ru_gun :
56140: LD_ADDR_VAR 0 3
56144: PUSH
56145: LD_INT 21
56147: PUSH
56148: LD_INT 22
56150: PUSH
56151: LD_INT 23
56153: PUSH
56154: LD_INT 24
56156: PUSH
56157: EMPTY
56158: LIST
56159: LIST
56160: LIST
56161: LIST
56162: ST_TO_ADDR
56163: GO 56414
56165: LD_INT 44
56167: DOUBLE
56168: EQUAL
56169: IFTRUE 56173
56171: GO 56199
56173: POP
// result := [ ru_medium_wheeled , ru_medium_tracked , ru_heavy_wheeled , ru_heavy_tracked ] ; ru_rocket_launcher :
56174: LD_ADDR_VAR 0 3
56178: PUSH
56179: LD_INT 21
56181: PUSH
56182: LD_INT 22
56184: PUSH
56185: LD_INT 23
56187: PUSH
56188: LD_INT 24
56190: PUSH
56191: EMPTY
56192: LIST
56193: LIST
56194: LIST
56195: LIST
56196: ST_TO_ADDR
56197: GO 56414
56199: LD_INT 45
56201: DOUBLE
56202: EQUAL
56203: IFTRUE 56207
56205: GO 56233
56207: POP
// result := [ ru_medium_wheeled , ru_medium_tracked , ru_heavy_wheeled , ru_heavy_tracked ] ; ru_time_lapser :
56208: LD_ADDR_VAR 0 3
56212: PUSH
56213: LD_INT 21
56215: PUSH
56216: LD_INT 22
56218: PUSH
56219: LD_INT 23
56221: PUSH
56222: LD_INT 24
56224: PUSH
56225: EMPTY
56226: LIST
56227: LIST
56228: LIST
56229: LIST
56230: ST_TO_ADDR
56231: GO 56414
56233: LD_INT 49
56235: DOUBLE
56236: EQUAL
56237: IFTRUE 56241
56239: GO 56267
56241: POP
// result := [ ru_medium_wheeled , ru_medium_tracked , ru_heavy_wheeled , ru_heavy_tracked ] ; ru_cargo_bay :
56242: LD_ADDR_VAR 0 3
56246: PUSH
56247: LD_INT 21
56249: PUSH
56250: LD_INT 22
56252: PUSH
56253: LD_INT 23
56255: PUSH
56256: LD_INT 24
56258: PUSH
56259: EMPTY
56260: LIST
56261: LIST
56262: LIST
56263: LIST
56264: ST_TO_ADDR
56265: GO 56414
56267: LD_INT 51
56269: DOUBLE
56270: EQUAL
56271: IFTRUE 56275
56273: GO 56301
56275: POP
// result := [ ru_medium_wheeled , ru_medium_tracked , ru_heavy_wheeled , ru_heavy_tracked ] ; ru_crane :
56276: LD_ADDR_VAR 0 3
56280: PUSH
56281: LD_INT 21
56283: PUSH
56284: LD_INT 22
56286: PUSH
56287: LD_INT 23
56289: PUSH
56290: LD_INT 24
56292: PUSH
56293: EMPTY
56294: LIST
56295: LIST
56296: LIST
56297: LIST
56298: ST_TO_ADDR
56299: GO 56414
56301: LD_INT 52
56303: DOUBLE
56304: EQUAL
56305: IFTRUE 56309
56307: GO 56335
56309: POP
// result := [ ru_medium_wheeled , ru_medium_tracked , ru_heavy_wheeled , ru_heavy_tracked ] ; ru_bulldozer :
56310: LD_ADDR_VAR 0 3
56314: PUSH
56315: LD_INT 21
56317: PUSH
56318: LD_INT 22
56320: PUSH
56321: LD_INT 23
56323: PUSH
56324: LD_INT 24
56326: PUSH
56327: EMPTY
56328: LIST
56329: LIST
56330: LIST
56331: LIST
56332: ST_TO_ADDR
56333: GO 56414
56335: LD_INT 53
56337: DOUBLE
56338: EQUAL
56339: IFTRUE 56343
56341: GO 56361
56343: POP
// result := [ ru_heavy_wheeled , ru_heavy_tracked ] ; ru_heavy_gun :
56344: LD_ADDR_VAR 0 3
56348: PUSH
56349: LD_INT 23
56351: PUSH
56352: LD_INT 24
56354: PUSH
56355: EMPTY
56356: LIST
56357: LIST
56358: ST_TO_ADDR
56359: GO 56414
56361: LD_INT 46
56363: DOUBLE
56364: EQUAL
56365: IFTRUE 56369
56367: GO 56387
56369: POP
// result := [ ru_heavy_wheeled , ru_heavy_tracked ] ; ru_rocket :
56370: LD_ADDR_VAR 0 3
56374: PUSH
56375: LD_INT 23
56377: PUSH
56378: LD_INT 24
56380: PUSH
56381: EMPTY
56382: LIST
56383: LIST
56384: ST_TO_ADDR
56385: GO 56414
56387: LD_INT 47
56389: DOUBLE
56390: EQUAL
56391: IFTRUE 56395
56393: GO 56413
56395: POP
// result := [ ru_heavy_wheeled , ru_heavy_tracked ] ; end ;
56396: LD_ADDR_VAR 0 3
56400: PUSH
56401: LD_INT 23
56403: PUSH
56404: LD_INT 24
56406: PUSH
56407: EMPTY
56408: LIST
56409: LIST
56410: ST_TO_ADDR
56411: GO 56414
56413: POP
// result := ( chassis in result ) ;
56414: LD_ADDR_VAR 0 3
56418: PUSH
56419: LD_VAR 0 1
56423: PUSH
56424: LD_VAR 0 3
56428: IN
56429: ST_TO_ADDR
// end ;
56430: LD_VAR 0 3
56434: RET
// export function Reindex ( array , i_from , i_to , direction ) ; var i , j , k , d , tmp , length ; begin
56435: LD_INT 0
56437: PPUSH
56438: PPUSH
56439: PPUSH
56440: PPUSH
56441: PPUSH
56442: PPUSH
56443: PPUSH
// result := array ;
56444: LD_ADDR_VAR 0 5
56448: PUSH
56449: LD_VAR 0 1
56453: ST_TO_ADDR
// if not array or not i_from or not i_to or i_from > array or i_to > array then
56454: LD_VAR 0 1
56458: NOT
56459: PUSH
56460: LD_VAR 0 2
56464: NOT
56465: OR
56466: PUSH
56467: LD_VAR 0 3
56471: NOT
56472: OR
56473: PUSH
56474: LD_VAR 0 2
56478: PUSH
56479: LD_VAR 0 1
56483: GREATER
56484: OR
56485: PUSH
56486: LD_VAR 0 3
56490: PUSH
56491: LD_VAR 0 1
56495: GREATER
56496: OR
56497: IFFALSE 56501
// exit ;
56499: GO 56797
// if direction then
56501: LD_VAR 0 4
56505: IFFALSE 56569
// begin d := 1 ;
56507: LD_ADDR_VAR 0 9
56511: PUSH
56512: LD_INT 1
56514: ST_TO_ADDR
// if i_from > i_to then
56515: LD_VAR 0 2
56519: PUSH
56520: LD_VAR 0 3
56524: GREATER
56525: IFFALSE 56551
// length := ( array - i_from ) + i_to else
56527: LD_ADDR_VAR 0 11
56531: PUSH
56532: LD_VAR 0 1
56536: PUSH
56537: LD_VAR 0 2
56541: MINUS
56542: PUSH
56543: LD_VAR 0 3
56547: PLUS
56548: ST_TO_ADDR
56549: GO 56567
// length := i_to - i_from ;
56551: LD_ADDR_VAR 0 11
56555: PUSH
56556: LD_VAR 0 3
56560: PUSH
56561: LD_VAR 0 2
56565: MINUS
56566: ST_TO_ADDR
// end else
56567: GO 56630
// begin d := - 1 ;
56569: LD_ADDR_VAR 0 9
56573: PUSH
56574: LD_INT 1
56576: NEG
56577: ST_TO_ADDR
// if i_from > i_to then
56578: LD_VAR 0 2
56582: PUSH
56583: LD_VAR 0 3
56587: GREATER
56588: IFFALSE 56608
// length := i_from - i_to else
56590: LD_ADDR_VAR 0 11
56594: PUSH
56595: LD_VAR 0 2
56599: PUSH
56600: LD_VAR 0 3
56604: MINUS
56605: ST_TO_ADDR
56606: GO 56630
// length := ( array - i_to ) + i_from ;
56608: LD_ADDR_VAR 0 11
56612: PUSH
56613: LD_VAR 0 1
56617: PUSH
56618: LD_VAR 0 3
56622: MINUS
56623: PUSH
56624: LD_VAR 0 2
56628: PLUS
56629: ST_TO_ADDR
// end ; if not length then
56630: LD_VAR 0 11
56634: NOT
56635: IFFALSE 56639
// exit ;
56637: GO 56797
// tmp := array ;
56639: LD_ADDR_VAR 0 10
56643: PUSH
56644: LD_VAR 0 1
56648: ST_TO_ADDR
// for i = 1 to length do
56649: LD_ADDR_VAR 0 6
56653: PUSH
56654: DOUBLE
56655: LD_INT 1
56657: DEC
56658: ST_TO_ADDR
56659: LD_VAR 0 11
56663: PUSH
56664: FOR_TO
56665: IFFALSE 56785
// begin for j = 1 to array do
56667: LD_ADDR_VAR 0 7
56671: PUSH
56672: DOUBLE
56673: LD_INT 1
56675: DEC
56676: ST_TO_ADDR
56677: LD_VAR 0 1
56681: PUSH
56682: FOR_TO
56683: IFFALSE 56771
// begin k := j + d ;
56685: LD_ADDR_VAR 0 8
56689: PUSH
56690: LD_VAR 0 7
56694: PUSH
56695: LD_VAR 0 9
56699: PLUS
56700: ST_TO_ADDR
// if k > array then
56701: LD_VAR 0 8
56705: PUSH
56706: LD_VAR 0 1
56710: GREATER
56711: IFFALSE 56721
// k := 1 ;
56713: LD_ADDR_VAR 0 8
56717: PUSH
56718: LD_INT 1
56720: ST_TO_ADDR
// if not k then
56721: LD_VAR 0 8
56725: NOT
56726: IFFALSE 56738
// k := array ;
56728: LD_ADDR_VAR 0 8
56732: PUSH
56733: LD_VAR 0 1
56737: ST_TO_ADDR
// tmp := Replace ( tmp , k , array [ j ] ) ;
56738: LD_ADDR_VAR 0 10
56742: PUSH
56743: LD_VAR 0 10
56747: PPUSH
56748: LD_VAR 0 8
56752: PPUSH
56753: LD_VAR 0 1
56757: PUSH
56758: LD_VAR 0 7
56762: ARRAY
56763: PPUSH
56764: CALL_OW 1
56768: ST_TO_ADDR
// end ;
56769: GO 56682
56771: POP
56772: POP
// array := tmp ;
56773: LD_ADDR_VAR 0 1
56777: PUSH
56778: LD_VAR 0 10
56782: ST_TO_ADDR
// end ;
56783: GO 56664
56785: POP
56786: POP
// result := array ;
56787: LD_ADDR_VAR 0 5
56791: PUSH
56792: LD_VAR 0 1
56796: ST_TO_ADDR
// end ;
56797: LD_VAR 0 5
56801: RET
// export function GetElementIndex ( array , value ) ; var i ; begin
56802: LD_INT 0
56804: PPUSH
56805: PPUSH
// result := 0 ;
56806: LD_ADDR_VAR 0 3
56810: PUSH
56811: LD_INT 0
56813: ST_TO_ADDR
// if not array or not value in array then
56814: LD_VAR 0 1
56818: NOT
56819: PUSH
56820: LD_VAR 0 2
56824: PUSH
56825: LD_VAR 0 1
56829: IN
56830: NOT
56831: OR
56832: IFFALSE 56836
// exit ;
56834: GO 56890
// for i = 1 to array do
56836: LD_ADDR_VAR 0 4
56840: PUSH
56841: DOUBLE
56842: LD_INT 1
56844: DEC
56845: ST_TO_ADDR
56846: LD_VAR 0 1
56850: PUSH
56851: FOR_TO
56852: IFFALSE 56888
// if value = array [ i ] then
56854: LD_VAR 0 2
56858: PUSH
56859: LD_VAR 0 1
56863: PUSH
56864: LD_VAR 0 4
56868: ARRAY
56869: EQUAL
56870: IFFALSE 56886
// begin result := i ;
56872: LD_ADDR_VAR 0 3
56876: PUSH
56877: LD_VAR 0 4
56881: ST_TO_ADDR
// exit ;
56882: POP
56883: POP
56884: GO 56890
// end ;
56886: GO 56851
56888: POP
56889: POP
// end ;
56890: LD_VAR 0 3
56894: RET
// export function PrepareVehicle ( chassis , engine , control , weapon , fuel ) ; begin
56895: LD_INT 0
56897: PPUSH
// vc_chassis := chassis ;
56898: LD_ADDR_OWVAR 37
56902: PUSH
56903: LD_VAR 0 1
56907: ST_TO_ADDR
// vc_engine := engine ;
56908: LD_ADDR_OWVAR 39
56912: PUSH
56913: LD_VAR 0 2
56917: ST_TO_ADDR
// vc_control := control ;
56918: LD_ADDR_OWVAR 38
56922: PUSH
56923: LD_VAR 0 3
56927: ST_TO_ADDR
// vc_weapon := weapon ;
56928: LD_ADDR_OWVAR 40
56932: PUSH
56933: LD_VAR 0 4
56937: ST_TO_ADDR
// vc_fuel_battery := fuel ;
56938: LD_ADDR_OWVAR 41
56942: PUSH
56943: LD_VAR 0 5
56947: ST_TO_ADDR
// end ;
56948: LD_VAR 0 6
56952: RET
// export function WantPlant ( unit ) ; var task ; begin
56953: LD_INT 0
56955: PPUSH
56956: PPUSH
// result := false ;
56957: LD_ADDR_VAR 0 2
56961: PUSH
56962: LD_INT 0
56964: ST_TO_ADDR
// task := GetTaskList ( unit ) ;
56965: LD_ADDR_VAR 0 3
56969: PUSH
56970: LD_VAR 0 1
56974: PPUSH
56975: CALL_OW 437
56979: ST_TO_ADDR
// if task then
56980: LD_VAR 0 3
56984: IFFALSE 57012
// if task [ 1 ] [ 1 ] = p then
56986: LD_VAR 0 3
56990: PUSH
56991: LD_INT 1
56993: ARRAY
56994: PUSH
56995: LD_INT 1
56997: ARRAY
56998: PUSH
56999: LD_STRING p
57001: EQUAL
57002: IFFALSE 57012
// result := true ;
57004: LD_ADDR_VAR 0 2
57008: PUSH
57009: LD_INT 1
57011: ST_TO_ADDR
// end ;
57012: LD_VAR 0 2
57016: RET
// export function ReplaceIn ( arr , pos , value ) ; var i , tmp , s_arr ; begin
57017: LD_INT 0
57019: PPUSH
57020: PPUSH
57021: PPUSH
57022: PPUSH
// if pos < 1 then
57023: LD_VAR 0 2
57027: PUSH
57028: LD_INT 1
57030: LESS
57031: IFFALSE 57035
// exit ;
57033: GO 57338
// if pos = 1 then
57035: LD_VAR 0 2
57039: PUSH
57040: LD_INT 1
57042: EQUAL
57043: IFFALSE 57076
// result := Replace ( arr , pos [ 1 ] , value ) else
57045: LD_ADDR_VAR 0 4
57049: PUSH
57050: LD_VAR 0 1
57054: PPUSH
57055: LD_VAR 0 2
57059: PUSH
57060: LD_INT 1
57062: ARRAY
57063: PPUSH
57064: LD_VAR 0 3
57068: PPUSH
57069: CALL_OW 1
57073: ST_TO_ADDR
57074: GO 57338
// begin tmp := arr ;
57076: LD_ADDR_VAR 0 6
57080: PUSH
57081: LD_VAR 0 1
57085: ST_TO_ADDR
// s_arr := [ tmp ] ;
57086: LD_ADDR_VAR 0 7
57090: PUSH
57091: LD_VAR 0 6
57095: PUSH
57096: EMPTY
57097: LIST
57098: ST_TO_ADDR
// for i = 1 to pos - 1 do
57099: LD_ADDR_VAR 0 5
57103: PUSH
57104: DOUBLE
57105: LD_INT 1
57107: DEC
57108: ST_TO_ADDR
57109: LD_VAR 0 2
57113: PUSH
57114: LD_INT 1
57116: MINUS
57117: PUSH
57118: FOR_TO
57119: IFFALSE 57164
// begin tmp := tmp [ pos [ i ] ] ;
57121: LD_ADDR_VAR 0 6
57125: PUSH
57126: LD_VAR 0 6
57130: PUSH
57131: LD_VAR 0 2
57135: PUSH
57136: LD_VAR 0 5
57140: ARRAY
57141: ARRAY
57142: ST_TO_ADDR
// s_arr := s_arr ^ [ tmp ] ;
57143: LD_ADDR_VAR 0 7
57147: PUSH
57148: LD_VAR 0 7
57152: PUSH
57153: LD_VAR 0 6
57157: PUSH
57158: EMPTY
57159: LIST
57160: ADD
57161: ST_TO_ADDR
// end ;
57162: GO 57118
57164: POP
57165: POP
// tmp := Replace ( tmp , pos [ pos ] , value ) ;
57166: LD_ADDR_VAR 0 6
57170: PUSH
57171: LD_VAR 0 6
57175: PPUSH
57176: LD_VAR 0 2
57180: PUSH
57181: LD_VAR 0 2
57185: ARRAY
57186: PPUSH
57187: LD_VAR 0 3
57191: PPUSH
57192: CALL_OW 1
57196: ST_TO_ADDR
// s_arr := Replace ( s_arr , s_arr , tmp ) ;
57197: LD_ADDR_VAR 0 7
57201: PUSH
57202: LD_VAR 0 7
57206: PPUSH
57207: LD_VAR 0 7
57211: PPUSH
57212: LD_VAR 0 6
57216: PPUSH
57217: CALL_OW 1
57221: ST_TO_ADDR
// for i = s_arr downto 2 do
57222: LD_ADDR_VAR 0 5
57226: PUSH
57227: DOUBLE
57228: LD_VAR 0 7
57232: INC
57233: ST_TO_ADDR
57234: LD_INT 2
57236: PUSH
57237: FOR_DOWNTO
57238: IFFALSE 57322
// begin tmp := Replace ( s_arr [ i - 1 ] , pos [ i - 1 ] , s_arr [ i ] ) ;
57240: LD_ADDR_VAR 0 6
57244: PUSH
57245: LD_VAR 0 7
57249: PUSH
57250: LD_VAR 0 5
57254: PUSH
57255: LD_INT 1
57257: MINUS
57258: ARRAY
57259: PPUSH
57260: LD_VAR 0 2
57264: PUSH
57265: LD_VAR 0 5
57269: PUSH
57270: LD_INT 1
57272: MINUS
57273: ARRAY
57274: PPUSH
57275: LD_VAR 0 7
57279: PUSH
57280: LD_VAR 0 5
57284: ARRAY
57285: PPUSH
57286: CALL_OW 1
57290: ST_TO_ADDR
// s_arr := Replace ( s_arr , i - 1 , tmp ) ;
57291: LD_ADDR_VAR 0 7
57295: PUSH
57296: LD_VAR 0 7
57300: PPUSH
57301: LD_VAR 0 5
57305: PUSH
57306: LD_INT 1
57308: MINUS
57309: PPUSH
57310: LD_VAR 0 6
57314: PPUSH
57315: CALL_OW 1
57319: ST_TO_ADDR
// end ;
57320: GO 57237
57322: POP
57323: POP
// result := s_arr [ 1 ] ;
57324: LD_ADDR_VAR 0 4
57328: PUSH
57329: LD_VAR 0 7
57333: PUSH
57334: LD_INT 1
57336: ARRAY
57337: ST_TO_ADDR
// end ; end ;
57338: LD_VAR 0 4
57342: RET
// export function ReplaceWith ( list , pos1 , pos2 ) ; var i ; begin
57343: LD_INT 0
57345: PPUSH
57346: PPUSH
// if not list then
57347: LD_VAR 0 1
57351: NOT
57352: IFFALSE 57356
// exit ;
57354: GO 57447
// i := list [ pos1 ] ;
57356: LD_ADDR_VAR 0 5
57360: PUSH
57361: LD_VAR 0 1
57365: PUSH
57366: LD_VAR 0 2
57370: ARRAY
57371: ST_TO_ADDR
// if not i then
57372: LD_VAR 0 5
57376: NOT
57377: IFFALSE 57381
// exit ;
57379: GO 57447
// list := Replace ( list , pos1 , list [ pos2 ] ) ;
57381: LD_ADDR_VAR 0 1
57385: PUSH
57386: LD_VAR 0 1
57390: PPUSH
57391: LD_VAR 0 2
57395: PPUSH
57396: LD_VAR 0 1
57400: PUSH
57401: LD_VAR 0 3
57405: ARRAY
57406: PPUSH
57407: CALL_OW 1
57411: ST_TO_ADDR
// list := Replace ( list , pos2 , i ) ;
57412: LD_ADDR_VAR 0 1
57416: PUSH
57417: LD_VAR 0 1
57421: PPUSH
57422: LD_VAR 0 3
57426: PPUSH
57427: LD_VAR 0 5
57431: PPUSH
57432: CALL_OW 1
57436: ST_TO_ADDR
// result := list ;
57437: LD_ADDR_VAR 0 4
57441: PUSH
57442: LD_VAR 0 1
57446: ST_TO_ADDR
// end ;
57447: LD_VAR 0 4
57451: RET
// export function SortByDistanceUnit ( unit , list , asc , mode ) ; begin
57452: LD_INT 0
57454: PPUSH
// result := SortByDistanceXY ( GetX ( unit ) , GetY ( unit ) , list , asc , mode ) ;
57455: LD_ADDR_VAR 0 5
57459: PUSH
57460: LD_VAR 0 1
57464: PPUSH
57465: CALL_OW 250
57469: PPUSH
57470: LD_VAR 0 1
57474: PPUSH
57475: CALL_OW 251
57479: PPUSH
57480: LD_VAR 0 2
57484: PPUSH
57485: LD_VAR 0 3
57489: PPUSH
57490: LD_VAR 0 4
57494: PPUSH
57495: CALL 57505 0 5
57499: ST_TO_ADDR
// end ;
57500: LD_VAR 0 5
57504: RET
// export function SortByDistanceXY ( x , y , list , asc , mode ) ; var i , j , tmp ; begin
57505: LD_INT 0
57507: PPUSH
57508: PPUSH
57509: PPUSH
57510: PPUSH
// if not list then
57511: LD_VAR 0 3
57515: NOT
57516: IFFALSE 57520
// exit ;
57518: GO 57908
// result := [ ] ;
57520: LD_ADDR_VAR 0 6
57524: PUSH
57525: EMPTY
57526: ST_TO_ADDR
// for i in list do
57527: LD_ADDR_VAR 0 7
57531: PUSH
57532: LD_VAR 0 3
57536: PUSH
57537: FOR_IN
57538: IFFALSE 57740
// begin tmp := GetDistUnitXY ( i , x , y ) ;
57540: LD_ADDR_VAR 0 9
57544: PUSH
57545: LD_VAR 0 7
57549: PPUSH
57550: LD_VAR 0 1
57554: PPUSH
57555: LD_VAR 0 2
57559: PPUSH
57560: CALL_OW 297
57564: ST_TO_ADDR
// if not result then
57565: LD_VAR 0 6
57569: NOT
57570: IFFALSE 57596
// result := [ [ i , tmp ] ] else
57572: LD_ADDR_VAR 0 6
57576: PUSH
57577: LD_VAR 0 7
57581: PUSH
57582: LD_VAR 0 9
57586: PUSH
57587: EMPTY
57588: LIST
57589: LIST
57590: PUSH
57591: EMPTY
57592: LIST
57593: ST_TO_ADDR
57594: GO 57738
// begin if result [ result ] [ 2 ] < tmp then
57596: LD_VAR 0 6
57600: PUSH
57601: LD_VAR 0 6
57605: ARRAY
57606: PUSH
57607: LD_INT 2
57609: ARRAY
57610: PUSH
57611: LD_VAR 0 9
57615: LESS
57616: IFFALSE 57658
// result := Insert ( result , result + 1 , [ i , tmp ] ) else
57618: LD_ADDR_VAR 0 6
57622: PUSH
57623: LD_VAR 0 6
57627: PPUSH
57628: LD_VAR 0 6
57632: PUSH
57633: LD_INT 1
57635: PLUS
57636: PPUSH
57637: LD_VAR 0 7
57641: PUSH
57642: LD_VAR 0 9
57646: PUSH
57647: EMPTY
57648: LIST
57649: LIST
57650: PPUSH
57651: CALL_OW 2
57655: ST_TO_ADDR
57656: GO 57738
// for j = 1 to result do
57658: LD_ADDR_VAR 0 8
57662: PUSH
57663: DOUBLE
57664: LD_INT 1
57666: DEC
57667: ST_TO_ADDR
57668: LD_VAR 0 6
57672: PUSH
57673: FOR_TO
57674: IFFALSE 57736
// begin if tmp < result [ j ] [ 2 ] then
57676: LD_VAR 0 9
57680: PUSH
57681: LD_VAR 0 6
57685: PUSH
57686: LD_VAR 0 8
57690: ARRAY
57691: PUSH
57692: LD_INT 2
57694: ARRAY
57695: LESS
57696: IFFALSE 57734
// begin result := Insert ( result , j , [ i , tmp ] ) ;
57698: LD_ADDR_VAR 0 6
57702: PUSH
57703: LD_VAR 0 6
57707: PPUSH
57708: LD_VAR 0 8
57712: PPUSH
57713: LD_VAR 0 7
57717: PUSH
57718: LD_VAR 0 9
57722: PUSH
57723: EMPTY
57724: LIST
57725: LIST
57726: PPUSH
57727: CALL_OW 2
57731: ST_TO_ADDR
// break ;
57732: GO 57736
// end ; end ;
57734: GO 57673
57736: POP
57737: POP
// end ; end ;
57738: GO 57537
57740: POP
57741: POP
// if result and not asc then
57742: LD_VAR 0 6
57746: PUSH
57747: LD_VAR 0 4
57751: NOT
57752: AND
57753: IFFALSE 57828
// begin tmp := result ;
57755: LD_ADDR_VAR 0 9
57759: PUSH
57760: LD_VAR 0 6
57764: ST_TO_ADDR
// for i = tmp downto 1 do
57765: LD_ADDR_VAR 0 7
57769: PUSH
57770: DOUBLE
57771: LD_VAR 0 9
57775: INC
57776: ST_TO_ADDR
57777: LD_INT 1
57779: PUSH
57780: FOR_DOWNTO
57781: IFFALSE 57826
// result := Replace ( result , tmp - i + 1 , tmp [ i ] ) ;
57783: LD_ADDR_VAR 0 6
57787: PUSH
57788: LD_VAR 0 6
57792: PPUSH
57793: LD_VAR 0 9
57797: PUSH
57798: LD_VAR 0 7
57802: MINUS
57803: PUSH
57804: LD_INT 1
57806: PLUS
57807: PPUSH
57808: LD_VAR 0 9
57812: PUSH
57813: LD_VAR 0 7
57817: ARRAY
57818: PPUSH
57819: CALL_OW 1
57823: ST_TO_ADDR
57824: GO 57780
57826: POP
57827: POP
// end ; tmp := [ ] ;
57828: LD_ADDR_VAR 0 9
57832: PUSH
57833: EMPTY
57834: ST_TO_ADDR
// if mode then
57835: LD_VAR 0 5
57839: IFFALSE 57908
// begin for i = 1 to result do
57841: LD_ADDR_VAR 0 7
57845: PUSH
57846: DOUBLE
57847: LD_INT 1
57849: DEC
57850: ST_TO_ADDR
57851: LD_VAR 0 6
57855: PUSH
57856: FOR_TO
57857: IFFALSE 57896
// tmp := Replace ( tmp , i , result [ i ] [ 1 ] ) ;
57859: LD_ADDR_VAR 0 9
57863: PUSH
57864: LD_VAR 0 9
57868: PPUSH
57869: LD_VAR 0 7
57873: PPUSH
57874: LD_VAR 0 6
57878: PUSH
57879: LD_VAR 0 7
57883: ARRAY
57884: PUSH
57885: LD_INT 1
57887: ARRAY
57888: PPUSH
57889: CALL_OW 1
57893: ST_TO_ADDR
57894: GO 57856
57896: POP
57897: POP
// result := tmp ;
57898: LD_ADDR_VAR 0 6
57902: PUSH
57903: LD_VAR 0 9
57907: ST_TO_ADDR
// end ; end ;
57908: LD_VAR 0 6
57912: RET
// export function DangerAtRangeXY ( side , x , y , range ) ; var i , j , tmp , points , bpoints ; begin
57913: LD_INT 0
57915: PPUSH
57916: PPUSH
57917: PPUSH
57918: PPUSH
57919: PPUSH
57920: PPUSH
// result := [ 0 , 0 , 0 , [ ] ] ;
57921: LD_ADDR_VAR 0 5
57925: PUSH
57926: LD_INT 0
57928: PUSH
57929: LD_INT 0
57931: PUSH
57932: LD_INT 0
57934: PUSH
57935: EMPTY
57936: PUSH
57937: EMPTY
57938: LIST
57939: LIST
57940: LIST
57941: LIST
57942: ST_TO_ADDR
// if not x or not y then
57943: LD_VAR 0 2
57947: NOT
57948: PUSH
57949: LD_VAR 0 3
57953: NOT
57954: OR
57955: IFFALSE 57959
// exit ;
57957: GO 59611
// if not range then
57959: LD_VAR 0 4
57963: NOT
57964: IFFALSE 57974
// range := 10 ;
57966: LD_ADDR_VAR 0 4
57970: PUSH
57971: LD_INT 10
57973: ST_TO_ADDR
// tmp := FilterAllUnits ( [ [ f_enemy , side ] , [ f_distxy , x , y , range ] , [ f_not , [ f_type , unit_building ] ] ] ) ;
57974: LD_ADDR_VAR 0 8
57978: PUSH
57979: LD_INT 81
57981: PUSH
57982: LD_VAR 0 1
57986: PUSH
57987: EMPTY
57988: LIST
57989: LIST
57990: PUSH
57991: LD_INT 92
57993: PUSH
57994: LD_VAR 0 2
57998: PUSH
57999: LD_VAR 0 3
58003: PUSH
58004: LD_VAR 0 4
58008: PUSH
58009: EMPTY
58010: LIST
58011: LIST
58012: LIST
58013: LIST
58014: PUSH
58015: LD_INT 3
58017: PUSH
58018: LD_INT 21
58020: PUSH
58021: LD_INT 3
58023: PUSH
58024: EMPTY
58025: LIST
58026: LIST
58027: PUSH
58028: EMPTY
58029: LIST
58030: LIST
58031: PUSH
58032: EMPTY
58033: LIST
58034: LIST
58035: LIST
58036: PPUSH
58037: CALL_OW 69
58041: ST_TO_ADDR
// if not tmp then
58042: LD_VAR 0 8
58046: NOT
58047: IFFALSE 58051
// exit ;
58049: GO 59611
// for i in tmp do
58051: LD_ADDR_VAR 0 6
58055: PUSH
58056: LD_VAR 0 8
58060: PUSH
58061: FOR_IN
58062: IFFALSE 59586
// begin points := [ 0 , 0 , 0 ] ;
58064: LD_ADDR_VAR 0 9
58068: PUSH
58069: LD_INT 0
58071: PUSH
58072: LD_INT 0
58074: PUSH
58075: LD_INT 0
58077: PUSH
58078: EMPTY
58079: LIST
58080: LIST
58081: LIST
58082: ST_TO_ADDR
// bpoints := 1 ;
58083: LD_ADDR_VAR 0 10
58087: PUSH
58088: LD_INT 1
58090: ST_TO_ADDR
// case GetType ( i ) of unit_human :
58091: LD_VAR 0 6
58095: PPUSH
58096: CALL_OW 247
58100: PUSH
58101: LD_INT 1
58103: DOUBLE
58104: EQUAL
58105: IFTRUE 58109
58107: GO 58687
58109: POP
// begin if GetClass ( i ) = 1 then
58110: LD_VAR 0 6
58114: PPUSH
58115: CALL_OW 257
58119: PUSH
58120: LD_INT 1
58122: EQUAL
58123: IFFALSE 58144
// points := [ 10 , 5 , 3 ] ;
58125: LD_ADDR_VAR 0 9
58129: PUSH
58130: LD_INT 10
58132: PUSH
58133: LD_INT 5
58135: PUSH
58136: LD_INT 3
58138: PUSH
58139: EMPTY
58140: LIST
58141: LIST
58142: LIST
58143: ST_TO_ADDR
// if GetClass ( i ) in [ 2 , 3 , 4 ] then
58144: LD_VAR 0 6
58148: PPUSH
58149: CALL_OW 257
58153: PUSH
58154: LD_INT 2
58156: PUSH
58157: LD_INT 3
58159: PUSH
58160: LD_INT 4
58162: PUSH
58163: EMPTY
58164: LIST
58165: LIST
58166: LIST
58167: IN
58168: IFFALSE 58189
// points := [ 3 , 2 , 1 ] ;
58170: LD_ADDR_VAR 0 9
58174: PUSH
58175: LD_INT 3
58177: PUSH
58178: LD_INT 2
58180: PUSH
58181: LD_INT 1
58183: PUSH
58184: EMPTY
58185: LIST
58186: LIST
58187: LIST
58188: ST_TO_ADDR
// if GetClass ( i ) = 5 then
58189: LD_VAR 0 6
58193: PPUSH
58194: CALL_OW 257
58198: PUSH
58199: LD_INT 5
58201: EQUAL
58202: IFFALSE 58223
// points := [ 130 , 5 , 2 ] ;
58204: LD_ADDR_VAR 0 9
58208: PUSH
58209: LD_INT 130
58211: PUSH
58212: LD_INT 5
58214: PUSH
58215: LD_INT 2
58217: PUSH
58218: EMPTY
58219: LIST
58220: LIST
58221: LIST
58222: ST_TO_ADDR
// if GetClass ( i ) = 8 then
58223: LD_VAR 0 6
58227: PPUSH
58228: CALL_OW 257
58232: PUSH
58233: LD_INT 8
58235: EQUAL
58236: IFFALSE 58257
// points := [ 35 , 35 , 30 ] ;
58238: LD_ADDR_VAR 0 9
58242: PUSH
58243: LD_INT 35
58245: PUSH
58246: LD_INT 35
58248: PUSH
58249: LD_INT 30
58251: PUSH
58252: EMPTY
58253: LIST
58254: LIST
58255: LIST
58256: ST_TO_ADDR
// if GetClass ( i ) = 9 then
58257: LD_VAR 0 6
58261: PPUSH
58262: CALL_OW 257
58266: PUSH
58267: LD_INT 9
58269: EQUAL
58270: IFFALSE 58291
// points := [ 20 , 55 , 40 ] ;
58272: LD_ADDR_VAR 0 9
58276: PUSH
58277: LD_INT 20
58279: PUSH
58280: LD_INT 55
58282: PUSH
58283: LD_INT 40
58285: PUSH
58286: EMPTY
58287: LIST
58288: LIST
58289: LIST
58290: ST_TO_ADDR
// if GetClass ( i ) in [ 12 , 16 ] then
58291: LD_VAR 0 6
58295: PPUSH
58296: CALL_OW 257
58300: PUSH
58301: LD_INT 12
58303: PUSH
58304: LD_INT 16
58306: PUSH
58307: EMPTY
58308: LIST
58309: LIST
58310: IN
58311: IFFALSE 58332
// points := [ 5 , 3 , 2 ] ;
58313: LD_ADDR_VAR 0 9
58317: PUSH
58318: LD_INT 5
58320: PUSH
58321: LD_INT 3
58323: PUSH
58324: LD_INT 2
58326: PUSH
58327: EMPTY
58328: LIST
58329: LIST
58330: LIST
58331: ST_TO_ADDR
// if GetClass ( i ) = 17 then
58332: LD_VAR 0 6
58336: PPUSH
58337: CALL_OW 257
58341: PUSH
58342: LD_INT 17
58344: EQUAL
58345: IFFALSE 58366
// points := [ 100 , 50 , 75 ] ;
58347: LD_ADDR_VAR 0 9
58351: PUSH
58352: LD_INT 100
58354: PUSH
58355: LD_INT 50
58357: PUSH
58358: LD_INT 75
58360: PUSH
58361: EMPTY
58362: LIST
58363: LIST
58364: LIST
58365: ST_TO_ADDR
// if GetClass ( i ) = 15 then
58366: LD_VAR 0 6
58370: PPUSH
58371: CALL_OW 257
58375: PUSH
58376: LD_INT 15
58378: EQUAL
58379: IFFALSE 58400
// points := [ 10 , 5 , 3 ] ;
58381: LD_ADDR_VAR 0 9
58385: PUSH
58386: LD_INT 10
58388: PUSH
58389: LD_INT 5
58391: PUSH
58392: LD_INT 3
58394: PUSH
58395: EMPTY
58396: LIST
58397: LIST
58398: LIST
58399: ST_TO_ADDR
// if GetClass ( i ) = 14 then
58400: LD_VAR 0 6
58404: PPUSH
58405: CALL_OW 257
58409: PUSH
58410: LD_INT 14
58412: EQUAL
58413: IFFALSE 58434
// points := [ 10 , 0 , 0 ] ;
58415: LD_ADDR_VAR 0 9
58419: PUSH
58420: LD_INT 10
58422: PUSH
58423: LD_INT 0
58425: PUSH
58426: LD_INT 0
58428: PUSH
58429: EMPTY
58430: LIST
58431: LIST
58432: LIST
58433: ST_TO_ADDR
// if GetClass ( i ) = 11 then
58434: LD_VAR 0 6
58438: PPUSH
58439: CALL_OW 257
58443: PUSH
58444: LD_INT 11
58446: EQUAL
58447: IFFALSE 58468
// points := [ 30 , 10 , 5 ] ;
58449: LD_ADDR_VAR 0 9
58453: PUSH
58454: LD_INT 30
58456: PUSH
58457: LD_INT 10
58459: PUSH
58460: LD_INT 5
58462: PUSH
58463: EMPTY
58464: LIST
58465: LIST
58466: LIST
58467: ST_TO_ADDR
// if GetTech ( side , tech_stimdrugs ) = state_researched then
58468: LD_VAR 0 1
58472: PPUSH
58473: LD_INT 5
58475: PPUSH
58476: CALL_OW 321
58480: PUSH
58481: LD_INT 2
58483: EQUAL
58484: IFFALSE 58501
// bpoints := bpoints * 1.8 ;
58486: LD_ADDR_VAR 0 10
58490: PUSH
58491: LD_VAR 0 10
58495: PUSH
58496: LD_REAL  1.80000000000000E+0000
58499: MUL
58500: ST_TO_ADDR
// if GetClass ( i ) in [ 1 , 2 , 3 , 4 ] and GetTech ( side , tech_weap1 ) = state_researched then
58501: LD_VAR 0 6
58505: PPUSH
58506: CALL_OW 257
58510: PUSH
58511: LD_INT 1
58513: PUSH
58514: LD_INT 2
58516: PUSH
58517: LD_INT 3
58519: PUSH
58520: LD_INT 4
58522: PUSH
58523: EMPTY
58524: LIST
58525: LIST
58526: LIST
58527: LIST
58528: IN
58529: PUSH
58530: LD_VAR 0 1
58534: PPUSH
58535: LD_INT 51
58537: PPUSH
58538: CALL_OW 321
58542: PUSH
58543: LD_INT 2
58545: EQUAL
58546: AND
58547: IFFALSE 58564
// bpoints := bpoints * 1.2 ;
58549: LD_ADDR_VAR 0 10
58553: PUSH
58554: LD_VAR 0 10
58558: PUSH
58559: LD_REAL  1.20000000000000E+0000
58562: MUL
58563: ST_TO_ADDR
// if GetClass ( i ) in [ 5 , 7 , 9 ] and GetTech ( side , tech_weap2 ) = state_researched then
58564: LD_VAR 0 6
58568: PPUSH
58569: CALL_OW 257
58573: PUSH
58574: LD_INT 5
58576: PUSH
58577: LD_INT 7
58579: PUSH
58580: LD_INT 9
58582: PUSH
58583: EMPTY
58584: LIST
58585: LIST
58586: LIST
58587: IN
58588: PUSH
58589: LD_VAR 0 1
58593: PPUSH
58594: LD_INT 52
58596: PPUSH
58597: CALL_OW 321
58601: PUSH
58602: LD_INT 2
58604: EQUAL
58605: AND
58606: IFFALSE 58623
// bpoints := bpoints * 1.5 ;
58608: LD_ADDR_VAR 0 10
58612: PUSH
58613: LD_VAR 0 10
58617: PUSH
58618: LD_REAL  1.50000000000000E+0000
58621: MUL
58622: ST_TO_ADDR
// if GetTech ( side , tech_bio1 ) = state_researched then
58623: LD_VAR 0 1
58627: PPUSH
58628: LD_INT 66
58630: PPUSH
58631: CALL_OW 321
58635: PUSH
58636: LD_INT 2
58638: EQUAL
58639: IFFALSE 58656
// bpoints := bpoints * 1.1 ;
58641: LD_ADDR_VAR 0 10
58645: PUSH
58646: LD_VAR 0 10
58650: PUSH
58651: LD_REAL  1.10000000000000E+0000
58654: MUL
58655: ST_TO_ADDR
// bpoints := bpoints * ( GetSkill ( i , 1 ) * 1.15 ) ;
58656: LD_ADDR_VAR 0 10
58660: PUSH
58661: LD_VAR 0 10
58665: PUSH
58666: LD_VAR 0 6
58670: PPUSH
58671: LD_INT 1
58673: PPUSH
58674: CALL_OW 259
58678: PUSH
58679: LD_REAL  1.15000000000000E+0000
58682: MUL
58683: MUL
58684: ST_TO_ADDR
// end ; unit_vehicle :
58685: GO 59515
58687: LD_INT 2
58689: DOUBLE
58690: EQUAL
58691: IFTRUE 58695
58693: GO 59503
58695: POP
// begin if GetWeapon ( i ) in [ us_machine_gun , ru_heavy_machine_gun , ar_double_machine_gun ] then
58696: LD_VAR 0 6
58700: PPUSH
58701: CALL_OW 264
58705: PUSH
58706: LD_INT 2
58708: PUSH
58709: LD_INT 42
58711: PUSH
58712: LD_INT 24
58714: PUSH
58715: EMPTY
58716: LIST
58717: LIST
58718: LIST
58719: IN
58720: IFFALSE 58741
// points := [ 25 , 5 , 3 ] ;
58722: LD_ADDR_VAR 0 9
58726: PUSH
58727: LD_INT 25
58729: PUSH
58730: LD_INT 5
58732: PUSH
58733: LD_INT 3
58735: PUSH
58736: EMPTY
58737: LIST
58738: LIST
58739: LIST
58740: ST_TO_ADDR
// if GetWeapon ( i ) in [ us_gatling_gun , ru_gatling_gun , ar_gatling_gun ] then
58741: LD_VAR 0 6
58745: PPUSH
58746: CALL_OW 264
58750: PUSH
58751: LD_INT 4
58753: PUSH
58754: LD_INT 43
58756: PUSH
58757: LD_INT 25
58759: PUSH
58760: EMPTY
58761: LIST
58762: LIST
58763: LIST
58764: IN
58765: IFFALSE 58786
// points := [ 40 , 15 , 5 ] ;
58767: LD_ADDR_VAR 0 9
58771: PUSH
58772: LD_INT 40
58774: PUSH
58775: LD_INT 15
58777: PUSH
58778: LD_INT 5
58780: PUSH
58781: EMPTY
58782: LIST
58783: LIST
58784: LIST
58785: ST_TO_ADDR
// if GetWeapon ( i ) in [ us_light_gun , ar_light_gun ] then
58786: LD_VAR 0 6
58790: PPUSH
58791: CALL_OW 264
58795: PUSH
58796: LD_INT 3
58798: PUSH
58799: LD_INT 23
58801: PUSH
58802: EMPTY
58803: LIST
58804: LIST
58805: IN
58806: IFFALSE 58827
// points := [ 7 , 25 , 8 ] ;
58808: LD_ADDR_VAR 0 9
58812: PUSH
58813: LD_INT 7
58815: PUSH
58816: LD_INT 25
58818: PUSH
58819: LD_INT 8
58821: PUSH
58822: EMPTY
58823: LIST
58824: LIST
58825: LIST
58826: ST_TO_ADDR
// if GetWeapon ( i ) in [ us_double_gun , ar_gun , ru_gun ] then
58827: LD_VAR 0 6
58831: PPUSH
58832: CALL_OW 264
58836: PUSH
58837: LD_INT 5
58839: PUSH
58840: LD_INT 27
58842: PUSH
58843: LD_INT 44
58845: PUSH
58846: EMPTY
58847: LIST
58848: LIST
58849: LIST
58850: IN
58851: IFFALSE 58872
// points := [ 14 , 50 , 16 ] ;
58853: LD_ADDR_VAR 0 9
58857: PUSH
58858: LD_INT 14
58860: PUSH
58861: LD_INT 50
58863: PUSH
58864: LD_INT 16
58866: PUSH
58867: EMPTY
58868: LIST
58869: LIST
58870: LIST
58871: ST_TO_ADDR
// if GetWeapon ( i ) in [ us_heavy_gun , ru_heavy_gun ] then
58872: LD_VAR 0 6
58876: PPUSH
58877: CALL_OW 264
58881: PUSH
58882: LD_INT 6
58884: PUSH
58885: LD_INT 46
58887: PUSH
58888: EMPTY
58889: LIST
58890: LIST
58891: IN
58892: IFFALSE 58913
// points := [ 32 , 120 , 70 ] ;
58894: LD_ADDR_VAR 0 9
58898: PUSH
58899: LD_INT 32
58901: PUSH
58902: LD_INT 120
58904: PUSH
58905: LD_INT 70
58907: PUSH
58908: EMPTY
58909: LIST
58910: LIST
58911: LIST
58912: ST_TO_ADDR
// if GetWeapon ( i ) in [ us_rocket_launcher , ar_rocket_launcher , ru_rocket_launcher , ar_mortar ] then
58913: LD_VAR 0 6
58917: PPUSH
58918: CALL_OW 264
58922: PUSH
58923: LD_INT 7
58925: PUSH
58926: LD_INT 28
58928: PUSH
58929: LD_INT 45
58931: PUSH
58932: LD_EXP 79
58936: PUSH
58937: EMPTY
58938: LIST
58939: LIST
58940: LIST
58941: LIST
58942: IN
58943: IFFALSE 58964
// points := [ 35 , 20 , 45 ] ;
58945: LD_ADDR_VAR 0 9
58949: PUSH
58950: LD_INT 35
58952: PUSH
58953: LD_INT 20
58955: PUSH
58956: LD_INT 45
58958: PUSH
58959: EMPTY
58960: LIST
58961: LIST
58962: LIST
58963: ST_TO_ADDR
// if GetWeapon ( i ) in [ ru_rocket ] then
58964: LD_VAR 0 6
58968: PPUSH
58969: CALL_OW 264
58973: PUSH
58974: LD_INT 47
58976: PUSH
58977: EMPTY
58978: LIST
58979: IN
58980: IFFALSE 59001
// points := [ 67 , 45 , 75 ] ;
58982: LD_ADDR_VAR 0 9
58986: PUSH
58987: LD_INT 67
58989: PUSH
58990: LD_INT 45
58992: PUSH
58993: LD_INT 75
58995: PUSH
58996: EMPTY
58997: LIST
58998: LIST
58999: LIST
59000: ST_TO_ADDR
// if GetWeapon ( i ) in [ ar_flame_thrower ] then
59001: LD_VAR 0 6
59005: PPUSH
59006: CALL_OW 264
59010: PUSH
59011: LD_INT 26
59013: PUSH
59014: EMPTY
59015: LIST
59016: IN
59017: IFFALSE 59038
// points := [ 120 , 30 , 80 ] ;
59019: LD_ADDR_VAR 0 9
59023: PUSH
59024: LD_INT 120
59026: PUSH
59027: LD_INT 30
59029: PUSH
59030: LD_INT 80
59032: PUSH
59033: EMPTY
59034: LIST
59035: LIST
59036: LIST
59037: ST_TO_ADDR
// if GetWeapon ( i ) in [ ar_multimissile_ballista ] then
59038: LD_VAR 0 6
59042: PPUSH
59043: CALL_OW 264
59047: PUSH
59048: LD_INT 22
59050: PUSH
59051: EMPTY
59052: LIST
59053: IN
59054: IFFALSE 59075
// points := [ 40 , 1 , 1 ] ;
59056: LD_ADDR_VAR 0 9
59060: PUSH
59061: LD_INT 40
59063: PUSH
59064: LD_INT 1
59066: PUSH
59067: LD_INT 1
59069: PUSH
59070: EMPTY
59071: LIST
59072: LIST
59073: LIST
59074: ST_TO_ADDR
// if GetWeapon ( i ) in [ ar_selfpropelled_bomb ] then
59075: LD_VAR 0 6
59079: PPUSH
59080: CALL_OW 264
59084: PUSH
59085: LD_INT 29
59087: PUSH
59088: EMPTY
59089: LIST
59090: IN
59091: IFFALSE 59112
// points := [ 70 , 200 , 400 ] ;
59093: LD_ADDR_VAR 0 9
59097: PUSH
59098: LD_INT 70
59100: PUSH
59101: LD_INT 200
59103: PUSH
59104: LD_INT 400
59106: PUSH
59107: EMPTY
59108: LIST
59109: LIST
59110: LIST
59111: ST_TO_ADDR
// if GetWeapon ( i ) in [ us_bulldozer , ru_bulldozer ] then
59112: LD_VAR 0 6
59116: PPUSH
59117: CALL_OW 264
59121: PUSH
59122: LD_INT 14
59124: PUSH
59125: LD_INT 53
59127: PUSH
59128: EMPTY
59129: LIST
59130: LIST
59131: IN
59132: IFFALSE 59153
// points := [ 40 , 10 , 20 ] ;
59134: LD_ADDR_VAR 0 9
59138: PUSH
59139: LD_INT 40
59141: PUSH
59142: LD_INT 10
59144: PUSH
59145: LD_INT 20
59147: PUSH
59148: EMPTY
59149: LIST
59150: LIST
59151: LIST
59152: ST_TO_ADDR
// if GetWeapon ( i ) in [ us_laser ] then
59153: LD_VAR 0 6
59157: PPUSH
59158: CALL_OW 264
59162: PUSH
59163: LD_INT 9
59165: PUSH
59166: EMPTY
59167: LIST
59168: IN
59169: IFFALSE 59190
// points := [ 5 , 70 , 20 ] ;
59171: LD_ADDR_VAR 0 9
59175: PUSH
59176: LD_INT 5
59178: PUSH
59179: LD_INT 70
59181: PUSH
59182: LD_INT 20
59184: PUSH
59185: EMPTY
59186: LIST
59187: LIST
59188: LIST
59189: ST_TO_ADDR
// if GetWeapon ( i ) in [ us_double_laser ] then
59190: LD_VAR 0 6
59194: PPUSH
59195: CALL_OW 264
59199: PUSH
59200: LD_INT 10
59202: PUSH
59203: EMPTY
59204: LIST
59205: IN
59206: IFFALSE 59227
// points := [ 35 , 110 , 70 ] ;
59208: LD_ADDR_VAR 0 9
59212: PUSH
59213: LD_INT 35
59215: PUSH
59216: LD_INT 110
59218: PUSH
59219: LD_INT 70
59221: PUSH
59222: EMPTY
59223: LIST
59224: LIST
59225: LIST
59226: ST_TO_ADDR
// if GetChassis ( i ) = 25 then
59227: LD_VAR 0 6
59231: PPUSH
59232: CALL_OW 265
59236: PUSH
59237: LD_INT 25
59239: EQUAL
59240: IFFALSE 59261
// points := [ 80 , 65 , 100 ] ;
59242: LD_ADDR_VAR 0 9
59246: PUSH
59247: LD_INT 80
59249: PUSH
59250: LD_INT 65
59252: PUSH
59253: LD_INT 100
59255: PUSH
59256: EMPTY
59257: LIST
59258: LIST
59259: LIST
59260: ST_TO_ADDR
// if GetControl ( i ) = control_manual then
59261: LD_VAR 0 6
59265: PPUSH
59266: CALL_OW 263
59270: PUSH
59271: LD_INT 1
59273: EQUAL
59274: IFFALSE 59309
// bpoints := bpoints * ( GetSkill ( IsDrivenBy ( i ) , 3 ) * 4 ) ;
59276: LD_ADDR_VAR 0 10
59280: PUSH
59281: LD_VAR 0 10
59285: PUSH
59286: LD_VAR 0 6
59290: PPUSH
59291: CALL_OW 311
59295: PPUSH
59296: LD_INT 3
59298: PPUSH
59299: CALL_OW 259
59303: PUSH
59304: LD_INT 4
59306: MUL
59307: MUL
59308: ST_TO_ADDR
// if GetControl ( i ) = control_remote then
59309: LD_VAR 0 6
59313: PPUSH
59314: CALL_OW 263
59318: PUSH
59319: LD_INT 2
59321: EQUAL
59322: IFFALSE 59373
// begin j := IsControledBy ( i ) ;
59324: LD_ADDR_VAR 0 7
59328: PUSH
59329: LD_VAR 0 6
59333: PPUSH
59334: CALL_OW 312
59338: ST_TO_ADDR
// if j then
59339: LD_VAR 0 7
59343: IFFALSE 59373
// bpoints := bpoints * ( GetSkill ( j , 3 ) * 3 ) ;
59345: LD_ADDR_VAR 0 10
59349: PUSH
59350: LD_VAR 0 10
59354: PUSH
59355: LD_VAR 0 7
59359: PPUSH
59360: LD_INT 3
59362: PPUSH
59363: CALL_OW 259
59367: PUSH
59368: LD_INT 3
59370: MUL
59371: MUL
59372: ST_TO_ADDR
// end ; if GetWeapon ( i ) in [ us_double_gun , us_heavy_gun , ru_heavy_gun , ru_gun , ru_rocket , ru_rocket_launcher , ar_rocket_launcher , us_rocket_launcher , ar_gun , ar_selfpropelled_bomb ] and GetTech ( side , tech_weap2 ) = state_researched then
59373: LD_VAR 0 6
59377: PPUSH
59378: CALL_OW 264
59382: PUSH
59383: LD_INT 5
59385: PUSH
59386: LD_INT 6
59388: PUSH
59389: LD_INT 46
59391: PUSH
59392: LD_INT 44
59394: PUSH
59395: LD_INT 47
59397: PUSH
59398: LD_INT 45
59400: PUSH
59401: LD_INT 28
59403: PUSH
59404: LD_INT 7
59406: PUSH
59407: LD_INT 27
59409: PUSH
59410: LD_INT 29
59412: PUSH
59413: EMPTY
59414: LIST
59415: LIST
59416: LIST
59417: LIST
59418: LIST
59419: LIST
59420: LIST
59421: LIST
59422: LIST
59423: LIST
59424: IN
59425: PUSH
59426: LD_VAR 0 1
59430: PPUSH
59431: LD_INT 52
59433: PPUSH
59434: CALL_OW 321
59438: PUSH
59439: LD_INT 2
59441: EQUAL
59442: AND
59443: IFFALSE 59460
// bpoints := bpoints * 1.2 ;
59445: LD_ADDR_VAR 0 10
59449: PUSH
59450: LD_VAR 0 10
59454: PUSH
59455: LD_REAL  1.20000000000000E+0000
59458: MUL
59459: ST_TO_ADDR
// if GetWeapon ( i ) in [ us_heavy_gun , ru_heavy_gun , ru_rocket ] then
59460: LD_VAR 0 6
59464: PPUSH
59465: CALL_OW 264
59469: PUSH
59470: LD_INT 6
59472: PUSH
59473: LD_INT 46
59475: PUSH
59476: LD_INT 47
59478: PUSH
59479: EMPTY
59480: LIST
59481: LIST
59482: LIST
59483: IN
59484: IFFALSE 59501
// bpoints := bpoints * 1.2 ;
59486: LD_ADDR_VAR 0 10
59490: PUSH
59491: LD_VAR 0 10
59495: PUSH
59496: LD_REAL  1.20000000000000E+0000
59499: MUL
59500: ST_TO_ADDR
// end ; unit_building :
59501: GO 59515
59503: LD_INT 3
59505: DOUBLE
59506: EQUAL
59507: IFTRUE 59511
59509: GO 59514
59511: POP
// ; end ;
59512: GO 59515
59514: POP
// for j = 1 to 3 do
59515: LD_ADDR_VAR 0 7
59519: PUSH
59520: DOUBLE
59521: LD_INT 1
59523: DEC
59524: ST_TO_ADDR
59525: LD_INT 3
59527: PUSH
59528: FOR_TO
59529: IFFALSE 59582
// result := Replace ( result , j , result [ j ] + ( points [ j ] * bpoints ) ) ;
59531: LD_ADDR_VAR 0 5
59535: PUSH
59536: LD_VAR 0 5
59540: PPUSH
59541: LD_VAR 0 7
59545: PPUSH
59546: LD_VAR 0 5
59550: PUSH
59551: LD_VAR 0 7
59555: ARRAY
59556: PUSH
59557: LD_VAR 0 9
59561: PUSH
59562: LD_VAR 0 7
59566: ARRAY
59567: PUSH
59568: LD_VAR 0 10
59572: MUL
59573: PLUS
59574: PPUSH
59575: CALL_OW 1
59579: ST_TO_ADDR
59580: GO 59528
59582: POP
59583: POP
// end ;
59584: GO 58061
59586: POP
59587: POP
// result := Replace ( result , 4 , tmp ) ;
59588: LD_ADDR_VAR 0 5
59592: PUSH
59593: LD_VAR 0 5
59597: PPUSH
59598: LD_INT 4
59600: PPUSH
59601: LD_VAR 0 8
59605: PPUSH
59606: CALL_OW 1
59610: ST_TO_ADDR
// end ;
59611: LD_VAR 0 5
59615: RET
// export function DangerAtRange ( unit , range ) ; begin
59616: LD_INT 0
59618: PPUSH
// result := DangerAtRangeXY ( GetSide ( unit ) , GetX ( unit ) , GetY ( unit ) , range ) ;
59619: LD_ADDR_VAR 0 3
59623: PUSH
59624: LD_VAR 0 1
59628: PPUSH
59629: CALL_OW 255
59633: PPUSH
59634: LD_VAR 0 1
59638: PPUSH
59639: CALL_OW 250
59643: PPUSH
59644: LD_VAR 0 1
59648: PPUSH
59649: CALL_OW 251
59653: PPUSH
59654: LD_VAR 0 2
59658: PPUSH
59659: CALL 57913 0 4
59663: ST_TO_ADDR
// end ;
59664: LD_VAR 0 3
59668: RET
// export function DangerInArea ( side , area ) ; begin
59669: LD_INT 0
59671: PPUSH
// result := FilterUnitsInArea ( area , [ f_enemy , side ] ) ;
59672: LD_ADDR_VAR 0 3
59676: PUSH
59677: LD_VAR 0 2
59681: PPUSH
59682: LD_INT 81
59684: PUSH
59685: LD_VAR 0 1
59689: PUSH
59690: EMPTY
59691: LIST
59692: LIST
59693: PPUSH
59694: CALL_OW 70
59698: ST_TO_ADDR
// end ;
59699: LD_VAR 0 3
59703: RET
// export function IsExtension ( b ) ; begin
59704: LD_INT 0
59706: PPUSH
// result := b in [ b_ext_stitch , b_ext_radar , b_ext_radio , b_ext_gun , b_ext_computer , b_ext_siberium , b_ext_noncombat , b_ext_track , b_ext_laser , b_ext_rocket ] ;
59707: LD_ADDR_VAR 0 2
59711: PUSH
59712: LD_VAR 0 1
59716: PUSH
59717: LD_INT 23
59719: PUSH
59720: LD_INT 20
59722: PUSH
59723: LD_INT 22
59725: PUSH
59726: LD_INT 17
59728: PUSH
59729: LD_INT 24
59731: PUSH
59732: LD_INT 21
59734: PUSH
59735: LD_INT 19
59737: PUSH
59738: LD_INT 16
59740: PUSH
59741: LD_INT 25
59743: PUSH
59744: LD_INT 18
59746: PUSH
59747: EMPTY
59748: LIST
59749: LIST
59750: LIST
59751: LIST
59752: LIST
59753: LIST
59754: LIST
59755: LIST
59756: LIST
59757: LIST
59758: IN
59759: ST_TO_ADDR
// end ;
59760: LD_VAR 0 2
59764: RET
// export function GetBaseBuildings ( base , area , checkLink ) ; var tmp , i ; begin
59765: LD_INT 0
59767: PPUSH
59768: PPUSH
59769: PPUSH
// result := [ ] ;
59770: LD_ADDR_VAR 0 4
59774: PUSH
59775: EMPTY
59776: ST_TO_ADDR
// tmp := FilterUnitsInArea ( area , [ f_type , unit_building ] ) ;
59777: LD_ADDR_VAR 0 5
59781: PUSH
59782: LD_VAR 0 2
59786: PPUSH
59787: LD_INT 21
59789: PUSH
59790: LD_INT 3
59792: PUSH
59793: EMPTY
59794: LIST
59795: LIST
59796: PPUSH
59797: CALL_OW 70
59801: ST_TO_ADDR
// if not tmp then
59802: LD_VAR 0 5
59806: NOT
59807: IFFALSE 59811
// exit ;
59809: GO 59875
// if checkLink then
59811: LD_VAR 0 3
59815: IFFALSE 59865
// begin for i in tmp do
59817: LD_ADDR_VAR 0 6
59821: PUSH
59822: LD_VAR 0 5
59826: PUSH
59827: FOR_IN
59828: IFFALSE 59863
// if GetBase ( i ) <> base then
59830: LD_VAR 0 6
59834: PPUSH
59835: CALL_OW 274
59839: PUSH
59840: LD_VAR 0 1
59844: NONEQUAL
59845: IFFALSE 59861
// ComLinkToBase ( base , i ) ;
59847: LD_VAR 0 1
59851: PPUSH
59852: LD_VAR 0 6
59856: PPUSH
59857: CALL_OW 169
59861: GO 59827
59863: POP
59864: POP
// end ; result := tmp ;
59865: LD_ADDR_VAR 0 4
59869: PUSH
59870: LD_VAR 0 5
59874: ST_TO_ADDR
// end ;
59875: LD_VAR 0 4
59879: RET
// export function ComComplete ( units , b ) ; var i ; begin
59880: LD_INT 0
59882: PPUSH
59883: PPUSH
// if not units then
59884: LD_VAR 0 1
59888: NOT
59889: IFFALSE 59893
// exit ;
59891: GO 59983
// for i in units do
59893: LD_ADDR_VAR 0 4
59897: PUSH
59898: LD_VAR 0 1
59902: PUSH
59903: FOR_IN
59904: IFFALSE 59981
// if BuildingStatus ( b ) = bs_build then
59906: LD_VAR 0 2
59910: PPUSH
59911: CALL_OW 461
59915: PUSH
59916: LD_INT 1
59918: EQUAL
59919: IFFALSE 59979
// SetTaskList ( i , [ [ h , GetX ( b ) , GetY ( b ) , b , 0 , 0 , 0 ] ] ) ;
59921: LD_VAR 0 4
59925: PPUSH
59926: LD_STRING h
59928: PUSH
59929: LD_VAR 0 2
59933: PPUSH
59934: CALL_OW 250
59938: PUSH
59939: LD_VAR 0 2
59943: PPUSH
59944: CALL_OW 251
59948: PUSH
59949: LD_VAR 0 2
59953: PUSH
59954: LD_INT 0
59956: PUSH
59957: LD_INT 0
59959: PUSH
59960: LD_INT 0
59962: PUSH
59963: EMPTY
59964: LIST
59965: LIST
59966: LIST
59967: LIST
59968: LIST
59969: LIST
59970: LIST
59971: PUSH
59972: EMPTY
59973: LIST
59974: PPUSH
59975: CALL_OW 446
59979: GO 59903
59981: POP
59982: POP
// end ;
59983: LD_VAR 0 3
59987: RET
// export function Connect ( vehicle ) ; var i , t , mech , tmp , j ; begin
59988: LD_INT 0
59990: PPUSH
59991: PPUSH
59992: PPUSH
59993: PPUSH
59994: PPUSH
59995: PPUSH
// if not vehicle or GetControl ( vehicle ) <> control_remote then
59996: LD_VAR 0 1
60000: NOT
60001: PUSH
60002: LD_VAR 0 1
60006: PPUSH
60007: CALL_OW 263
60011: PUSH
60012: LD_INT 2
60014: NONEQUAL
60015: OR
60016: IFFALSE 60020
// exit ;
60018: GO 60336
// tmp := FilterAllUnits ( [ [ f_side , GetSide ( vehicle ) ] , [ f_or , [ f_btype , b_control_tower ] , [ f_weapon , ar_control_tower ] ] ] ) ;
60020: LD_ADDR_VAR 0 6
60024: PUSH
60025: LD_INT 22
60027: PUSH
60028: LD_VAR 0 1
60032: PPUSH
60033: CALL_OW 255
60037: PUSH
60038: EMPTY
60039: LIST
60040: LIST
60041: PUSH
60042: LD_INT 2
60044: PUSH
60045: LD_INT 30
60047: PUSH
60048: LD_INT 36
60050: PUSH
60051: EMPTY
60052: LIST
60053: LIST
60054: PUSH
60055: LD_INT 34
60057: PUSH
60058: LD_INT 31
60060: PUSH
60061: EMPTY
60062: LIST
60063: LIST
60064: PUSH
60065: EMPTY
60066: LIST
60067: LIST
60068: LIST
60069: PUSH
60070: EMPTY
60071: LIST
60072: LIST
60073: PPUSH
60074: CALL_OW 69
60078: ST_TO_ADDR
// if not tmp then
60079: LD_VAR 0 6
60083: NOT
60084: IFFALSE 60088
// exit ;
60086: GO 60336
// result := [ ] ;
60088: LD_ADDR_VAR 0 2
60092: PUSH
60093: EMPTY
60094: ST_TO_ADDR
// for i in tmp do
60095: LD_ADDR_VAR 0 3
60099: PUSH
60100: LD_VAR 0 6
60104: PUSH
60105: FOR_IN
60106: IFFALSE 60177
// begin t := UnitsInside ( i ) ;
60108: LD_ADDR_VAR 0 4
60112: PUSH
60113: LD_VAR 0 3
60117: PPUSH
60118: CALL_OW 313
60122: ST_TO_ADDR
// if t then
60123: LD_VAR 0 4
60127: IFFALSE 60175
// for j in t do
60129: LD_ADDR_VAR 0 7
60133: PUSH
60134: LD_VAR 0 4
60138: PUSH
60139: FOR_IN
60140: IFFALSE 60173
// result := Replace ( result , result + 1 , j ) ;
60142: LD_ADDR_VAR 0 2
60146: PUSH
60147: LD_VAR 0 2
60151: PPUSH
60152: LD_VAR 0 2
60156: PUSH
60157: LD_INT 1
60159: PLUS
60160: PPUSH
60161: LD_VAR 0 7
60165: PPUSH
60166: CALL_OW 1
60170: ST_TO_ADDR
60171: GO 60139
60173: POP
60174: POP
// end ;
60175: GO 60105
60177: POP
60178: POP
// if not result then
60179: LD_VAR 0 2
60183: NOT
60184: IFFALSE 60188
// exit ;
60186: GO 60336
// mech := result [ 1 ] ;
60188: LD_ADDR_VAR 0 5
60192: PUSH
60193: LD_VAR 0 2
60197: PUSH
60198: LD_INT 1
60200: ARRAY
60201: ST_TO_ADDR
// if result > 1 then
60202: LD_VAR 0 2
60206: PUSH
60207: LD_INT 1
60209: GREATER
60210: IFFALSE 60322
// begin for i = 2 to result do
60212: LD_ADDR_VAR 0 3
60216: PUSH
60217: DOUBLE
60218: LD_INT 2
60220: DEC
60221: ST_TO_ADDR
60222: LD_VAR 0 2
60226: PUSH
60227: FOR_TO
60228: IFFALSE 60320
// begin t := GetSkill ( result [ i ] , 3 ) - UnitsLinked ( result [ i ] ) ;
60230: LD_ADDR_VAR 0 4
60234: PUSH
60235: LD_VAR 0 2
60239: PUSH
60240: LD_VAR 0 3
60244: ARRAY
60245: PPUSH
60246: LD_INT 3
60248: PPUSH
60249: CALL_OW 259
60253: PUSH
60254: LD_VAR 0 2
60258: PUSH
60259: LD_VAR 0 3
60263: ARRAY
60264: PPUSH
60265: CALL_OW 432
60269: MINUS
60270: ST_TO_ADDR
// if t >= ( GetSkill ( mech , 3 ) - UnitsLinked ( mech ) ) then
60271: LD_VAR 0 4
60275: PUSH
60276: LD_VAR 0 5
60280: PPUSH
60281: LD_INT 3
60283: PPUSH
60284: CALL_OW 259
60288: PUSH
60289: LD_VAR 0 5
60293: PPUSH
60294: CALL_OW 432
60298: MINUS
60299: GREATEREQUAL
60300: IFFALSE 60318
// mech := result [ i ] ;
60302: LD_ADDR_VAR 0 5
60306: PUSH
60307: LD_VAR 0 2
60311: PUSH
60312: LD_VAR 0 3
60316: ARRAY
60317: ST_TO_ADDR
// end ;
60318: GO 60227
60320: POP
60321: POP
// end ; ComLinkTo ( vehicle , mech ) ;
60322: LD_VAR 0 1
60326: PPUSH
60327: LD_VAR 0 5
60331: PPUSH
60332: CALL_OW 135
// end ;
60336: LD_VAR 0 2
60340: RET
// export function PrepareBase ( base_dep , area , name , skill , sources , personel ) ; var i , j , d , b , f , x , un , base , side , nation , buildings , tmp ; begin
60341: LD_INT 0
60343: PPUSH
60344: PPUSH
60345: PPUSH
60346: PPUSH
60347: PPUSH
60348: PPUSH
60349: PPUSH
60350: PPUSH
60351: PPUSH
60352: PPUSH
60353: PPUSH
60354: PPUSH
60355: PPUSH
// result := [ ] ;
60356: LD_ADDR_VAR 0 7
60360: PUSH
60361: EMPTY
60362: ST_TO_ADDR
// if not GetBType ( base_dep ) in [ b_depot , b_warehouse ] then
60363: LD_VAR 0 1
60367: PPUSH
60368: CALL_OW 266
60372: PUSH
60373: LD_INT 0
60375: PUSH
60376: LD_INT 1
60378: PUSH
60379: EMPTY
60380: LIST
60381: LIST
60382: IN
60383: NOT
60384: IFFALSE 60388
// exit ;
60386: GO 62022
// if name then
60388: LD_VAR 0 3
60392: IFFALSE 60408
// SetBName ( base_dep , name ) ;
60394: LD_VAR 0 1
60398: PPUSH
60399: LD_VAR 0 3
60403: PPUSH
60404: CALL_OW 500
// base := GetBase ( base_dep ) ;
60408: LD_ADDR_VAR 0 15
60412: PUSH
60413: LD_VAR 0 1
60417: PPUSH
60418: CALL_OW 274
60422: ST_TO_ADDR
// side := GetSide ( base_dep ) ;
60423: LD_ADDR_VAR 0 16
60427: PUSH
60428: LD_VAR 0 1
60432: PPUSH
60433: CALL_OW 255
60437: ST_TO_ADDR
// nation := GetNation ( base_dep ) ;
60438: LD_ADDR_VAR 0 17
60442: PUSH
60443: LD_VAR 0 1
60447: PPUSH
60448: CALL_OW 248
60452: ST_TO_ADDR
// if sources then
60453: LD_VAR 0 5
60457: IFFALSE 60504
// for i = 1 to 3 do
60459: LD_ADDR_VAR 0 8
60463: PUSH
60464: DOUBLE
60465: LD_INT 1
60467: DEC
60468: ST_TO_ADDR
60469: LD_INT 3
60471: PUSH
60472: FOR_TO
60473: IFFALSE 60502
// AddResourceType ( base , i , sources [ i ] ) ;
60475: LD_VAR 0 15
60479: PPUSH
60480: LD_VAR 0 8
60484: PPUSH
60485: LD_VAR 0 5
60489: PUSH
60490: LD_VAR 0 8
60494: ARRAY
60495: PPUSH
60496: CALL_OW 276
60500: GO 60472
60502: POP
60503: POP
// buildings := GetBaseBuildings ( base , area , true ) ;
60504: LD_ADDR_VAR 0 18
60508: PUSH
60509: LD_VAR 0 15
60513: PPUSH
60514: LD_VAR 0 2
60518: PPUSH
60519: LD_INT 1
60521: PPUSH
60522: CALL 59765 0 3
60526: ST_TO_ADDR
// InitHc ;
60527: CALL_OW 19
// InitUc ;
60531: CALL_OW 18
// uc_side := side ;
60535: LD_ADDR_OWVAR 20
60539: PUSH
60540: LD_VAR 0 16
60544: ST_TO_ADDR
// uc_nation := nation ;
60545: LD_ADDR_OWVAR 21
60549: PUSH
60550: LD_VAR 0 17
60554: ST_TO_ADDR
// if buildings then
60555: LD_VAR 0 18
60559: IFFALSE 61881
// begin tmp := UnitFilter ( buildings , [ f_or , [ f_btype , b_oil_mine ] , [ f_btype , b_siberite_mine ] ] ) ;
60561: LD_ADDR_VAR 0 19
60565: PUSH
60566: LD_VAR 0 18
60570: PPUSH
60571: LD_INT 2
60573: PUSH
60574: LD_INT 30
60576: PUSH
60577: LD_INT 29
60579: PUSH
60580: EMPTY
60581: LIST
60582: LIST
60583: PUSH
60584: LD_INT 30
60586: PUSH
60587: LD_INT 30
60589: PUSH
60590: EMPTY
60591: LIST
60592: LIST
60593: PUSH
60594: EMPTY
60595: LIST
60596: LIST
60597: LIST
60598: PPUSH
60599: CALL_OW 72
60603: ST_TO_ADDR
// if tmp then
60604: LD_VAR 0 19
60608: IFFALSE 60656
// for i in tmp do
60610: LD_ADDR_VAR 0 8
60614: PUSH
60615: LD_VAR 0 19
60619: PUSH
60620: FOR_IN
60621: IFFALSE 60654
// SetResourceVisibility ( GetX ( i ) , GetY ( i ) , side ) ;
60623: LD_VAR 0 8
60627: PPUSH
60628: CALL_OW 250
60632: PPUSH
60633: LD_VAR 0 8
60637: PPUSH
60638: CALL_OW 251
60642: PPUSH
60643: LD_VAR 0 16
60647: PPUSH
60648: CALL_OW 441
60652: GO 60620
60654: POP
60655: POP
// if UnitFilter ( buildings , [ f_or , [ f_btype , b_bunker ] , [ f_btype , b_turret ] ] ) then
60656: LD_VAR 0 18
60660: PPUSH
60661: LD_INT 2
60663: PUSH
60664: LD_INT 30
60666: PUSH
60667: LD_INT 32
60669: PUSH
60670: EMPTY
60671: LIST
60672: LIST
60673: PUSH
60674: LD_INT 30
60676: PUSH
60677: LD_INT 33
60679: PUSH
60680: EMPTY
60681: LIST
60682: LIST
60683: PUSH
60684: EMPTY
60685: LIST
60686: LIST
60687: LIST
60688: PPUSH
60689: CALL_OW 72
60693: IFFALSE 60781
// begin for i in UnitFilter ( buildings , [ f_or , [ f_btype , b_bunker ] , [ f_btype , b_turret ] ] ) do
60695: LD_ADDR_VAR 0 8
60699: PUSH
60700: LD_VAR 0 18
60704: PPUSH
60705: LD_INT 2
60707: PUSH
60708: LD_INT 30
60710: PUSH
60711: LD_INT 32
60713: PUSH
60714: EMPTY
60715: LIST
60716: LIST
60717: PUSH
60718: LD_INT 30
60720: PUSH
60721: LD_INT 33
60723: PUSH
60724: EMPTY
60725: LIST
60726: LIST
60727: PUSH
60728: EMPTY
60729: LIST
60730: LIST
60731: LIST
60732: PPUSH
60733: CALL_OW 72
60737: PUSH
60738: FOR_IN
60739: IFFALSE 60779
// begin if not GetBWeapon ( i ) then
60741: LD_VAR 0 8
60745: PPUSH
60746: CALL_OW 269
60750: NOT
60751: IFFALSE 60777
// PlaceWeaponTurret ( i , GetTurretWeapon ( i , area ) ) ;
60753: LD_VAR 0 8
60757: PPUSH
60758: LD_VAR 0 8
60762: PPUSH
60763: LD_VAR 0 2
60767: PPUSH
60768: CALL 62027 0 2
60772: PPUSH
60773: CALL_OW 431
// end ;
60777: GO 60738
60779: POP
60780: POP
// end ; for i = 1 to personel do
60781: LD_ADDR_VAR 0 8
60785: PUSH
60786: DOUBLE
60787: LD_INT 1
60789: DEC
60790: ST_TO_ADDR
60791: LD_VAR 0 6
60795: PUSH
60796: FOR_TO
60797: IFFALSE 61861
// begin if i > 4 then
60799: LD_VAR 0 8
60803: PUSH
60804: LD_INT 4
60806: GREATER
60807: IFFALSE 60811
// break ;
60809: GO 61861
// case i of 1 :
60811: LD_VAR 0 8
60815: PUSH
60816: LD_INT 1
60818: DOUBLE
60819: EQUAL
60820: IFTRUE 60824
60822: GO 60904
60824: POP
// f := UnitFilter ( buildings , [ [ f_side , side ] , [ f_empty ] , [ f_or , [ f_btype , b_bunker ] , [ f_btype , b_armoury ] , [ f_btype , b_barracks ] ] ] ) ; 2 :
60825: LD_ADDR_VAR 0 12
60829: PUSH
60830: LD_VAR 0 18
60834: PPUSH
60835: LD_INT 22
60837: PUSH
60838: LD_VAR 0 16
60842: PUSH
60843: EMPTY
60844: LIST
60845: LIST
60846: PUSH
60847: LD_INT 58
60849: PUSH
60850: EMPTY
60851: LIST
60852: PUSH
60853: LD_INT 2
60855: PUSH
60856: LD_INT 30
60858: PUSH
60859: LD_INT 32
60861: PUSH
60862: EMPTY
60863: LIST
60864: LIST
60865: PUSH
60866: LD_INT 30
60868: PUSH
60869: LD_INT 4
60871: PUSH
60872: EMPTY
60873: LIST
60874: LIST
60875: PUSH
60876: LD_INT 30
60878: PUSH
60879: LD_INT 5
60881: PUSH
60882: EMPTY
60883: LIST
60884: LIST
60885: PUSH
60886: EMPTY
60887: LIST
60888: LIST
60889: LIST
60890: LIST
60891: PUSH
60892: EMPTY
60893: LIST
60894: LIST
60895: LIST
60896: PPUSH
60897: CALL_OW 72
60901: ST_TO_ADDR
60902: GO 61126
60904: LD_INT 2
60906: DOUBLE
60907: EQUAL
60908: IFTRUE 60912
60910: GO 60974
60912: POP
// f := UnitFilter ( buildings , [ [ f_side , side ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ] ) ; 3 :
60913: LD_ADDR_VAR 0 12
60917: PUSH
60918: LD_VAR 0 18
60922: PPUSH
60923: LD_INT 22
60925: PUSH
60926: LD_VAR 0 16
60930: PUSH
60931: EMPTY
60932: LIST
60933: LIST
60934: PUSH
60935: LD_INT 2
60937: PUSH
60938: LD_INT 30
60940: PUSH
60941: LD_INT 0
60943: PUSH
60944: EMPTY
60945: LIST
60946: LIST
60947: PUSH
60948: LD_INT 30
60950: PUSH
60951: LD_INT 1
60953: PUSH
60954: EMPTY
60955: LIST
60956: LIST
60957: PUSH
60958: EMPTY
60959: LIST
60960: LIST
60961: LIST
60962: PUSH
60963: EMPTY
60964: LIST
60965: LIST
60966: PPUSH
60967: CALL_OW 72
60971: ST_TO_ADDR
60972: GO 61126
60974: LD_INT 3
60976: DOUBLE
60977: EQUAL
60978: IFTRUE 60982
60980: GO 61044
60982: POP
// f := UnitFilter ( buildings , [ [ f_side , side ] , [ f_or , [ f_btype , b_workshop ] , [ f_btype , b_factory ] ] ] ) ; 4 :
60983: LD_ADDR_VAR 0 12
60987: PUSH
60988: LD_VAR 0 18
60992: PPUSH
60993: LD_INT 22
60995: PUSH
60996: LD_VAR 0 16
61000: PUSH
61001: EMPTY
61002: LIST
61003: LIST
61004: PUSH
61005: LD_INT 2
61007: PUSH
61008: LD_INT 30
61010: PUSH
61011: LD_INT 2
61013: PUSH
61014: EMPTY
61015: LIST
61016: LIST
61017: PUSH
61018: LD_INT 30
61020: PUSH
61021: LD_INT 3
61023: PUSH
61024: EMPTY
61025: LIST
61026: LIST
61027: PUSH
61028: EMPTY
61029: LIST
61030: LIST
61031: LIST
61032: PUSH
61033: EMPTY
61034: LIST
61035: LIST
61036: PPUSH
61037: CALL_OW 72
61041: ST_TO_ADDR
61042: GO 61126
61044: LD_INT 4
61046: DOUBLE
61047: EQUAL
61048: IFTRUE 61052
61050: GO 61125
61052: POP
// f := UnitFilter ( buildings , [ [ f_side , side ] , [ f_or , [ f_btype , b_lab ] , [ f_btype , b_lab_half ] , [ f_btype , b_lab_full ] ] ] ) ; end ;
61053: LD_ADDR_VAR 0 12
61057: PUSH
61058: LD_VAR 0 18
61062: PPUSH
61063: LD_INT 22
61065: PUSH
61066: LD_VAR 0 16
61070: PUSH
61071: EMPTY
61072: LIST
61073: LIST
61074: PUSH
61075: LD_INT 2
61077: PUSH
61078: LD_INT 30
61080: PUSH
61081: LD_INT 6
61083: PUSH
61084: EMPTY
61085: LIST
61086: LIST
61087: PUSH
61088: LD_INT 30
61090: PUSH
61091: LD_INT 7
61093: PUSH
61094: EMPTY
61095: LIST
61096: LIST
61097: PUSH
61098: LD_INT 30
61100: PUSH
61101: LD_INT 8
61103: PUSH
61104: EMPTY
61105: LIST
61106: LIST
61107: PUSH
61108: EMPTY
61109: LIST
61110: LIST
61111: LIST
61112: LIST
61113: PUSH
61114: EMPTY
61115: LIST
61116: LIST
61117: PPUSH
61118: CALL_OW 72
61122: ST_TO_ADDR
61123: GO 61126
61125: POP
// if i = 1 then
61126: LD_VAR 0 8
61130: PUSH
61131: LD_INT 1
61133: EQUAL
61134: IFFALSE 61245
// begin tmp := [ ] ;
61136: LD_ADDR_VAR 0 19
61140: PUSH
61141: EMPTY
61142: ST_TO_ADDR
// for j in f do
61143: LD_ADDR_VAR 0 9
61147: PUSH
61148: LD_VAR 0 12
61152: PUSH
61153: FOR_IN
61154: IFFALSE 61227
// if GetBType ( j ) = b_bunker then
61156: LD_VAR 0 9
61160: PPUSH
61161: CALL_OW 266
61165: PUSH
61166: LD_INT 32
61168: EQUAL
61169: IFFALSE 61196
// tmp := Insert ( tmp , 1 , j ) else
61171: LD_ADDR_VAR 0 19
61175: PUSH
61176: LD_VAR 0 19
61180: PPUSH
61181: LD_INT 1
61183: PPUSH
61184: LD_VAR 0 9
61188: PPUSH
61189: CALL_OW 2
61193: ST_TO_ADDR
61194: GO 61225
// tmp := Insert ( tmp , tmp + 1 , j ) ;
61196: LD_ADDR_VAR 0 19
61200: PUSH
61201: LD_VAR 0 19
61205: PPUSH
61206: LD_VAR 0 19
61210: PUSH
61211: LD_INT 1
61213: PLUS
61214: PPUSH
61215: LD_VAR 0 9
61219: PPUSH
61220: CALL_OW 2
61224: ST_TO_ADDR
61225: GO 61153
61227: POP
61228: POP
// if tmp then
61229: LD_VAR 0 19
61233: IFFALSE 61245
// f := tmp ;
61235: LD_ADDR_VAR 0 12
61239: PUSH
61240: LD_VAR 0 19
61244: ST_TO_ADDR
// end ; x := personel [ i ] ;
61245: LD_ADDR_VAR 0 13
61249: PUSH
61250: LD_VAR 0 6
61254: PUSH
61255: LD_VAR 0 8
61259: ARRAY
61260: ST_TO_ADDR
// if x = - 1 then
61261: LD_VAR 0 13
61265: PUSH
61266: LD_INT 1
61268: NEG
61269: EQUAL
61270: IFFALSE 61479
// begin for j in f do
61272: LD_ADDR_VAR 0 9
61276: PUSH
61277: LD_VAR 0 12
61281: PUSH
61282: FOR_IN
61283: IFFALSE 61475
// repeat InitHc ;
61285: CALL_OW 19
// if GetBType ( j ) = b_barracks then
61289: LD_VAR 0 9
61293: PPUSH
61294: CALL_OW 266
61298: PUSH
61299: LD_INT 5
61301: EQUAL
61302: IFFALSE 61372
// begin if UnitsInside ( j ) < 3 then
61304: LD_VAR 0 9
61308: PPUSH
61309: CALL_OW 313
61313: PUSH
61314: LD_INT 3
61316: LESS
61317: IFFALSE 61353
// PrepareHuman ( false , [ class_sniper , class_mortar , class_bazooker ] [ nation ] , skill ) else
61319: LD_INT 0
61321: PPUSH
61322: LD_INT 5
61324: PUSH
61325: LD_INT 8
61327: PUSH
61328: LD_INT 9
61330: PUSH
61331: EMPTY
61332: LIST
61333: LIST
61334: LIST
61335: PUSH
61336: LD_VAR 0 17
61340: ARRAY
61341: PPUSH
61342: LD_VAR 0 4
61346: PPUSH
61347: CALL_OW 380
61351: GO 61370
// PrepareHuman ( false , i , skill ) ;
61353: LD_INT 0
61355: PPUSH
61356: LD_VAR 0 8
61360: PPUSH
61361: LD_VAR 0 4
61365: PPUSH
61366: CALL_OW 380
// end else
61370: GO 61389
// PrepareHuman ( false , i , skill ) ;
61372: LD_INT 0
61374: PPUSH
61375: LD_VAR 0 8
61379: PPUSH
61380: LD_VAR 0 4
61384: PPUSH
61385: CALL_OW 380
// un := CreateHuman ;
61389: LD_ADDR_VAR 0 14
61393: PUSH
61394: CALL_OW 44
61398: ST_TO_ADDR
// result := Insert ( result , 1 , un ) ;
61399: LD_ADDR_VAR 0 7
61403: PUSH
61404: LD_VAR 0 7
61408: PPUSH
61409: LD_INT 1
61411: PPUSH
61412: LD_VAR 0 14
61416: PPUSH
61417: CALL_OW 2
61421: ST_TO_ADDR
// PlaceHumanInUnit ( un , j ) ;
61422: LD_VAR 0 14
61426: PPUSH
61427: LD_VAR 0 9
61431: PPUSH
61432: CALL_OW 52
// until UnitsInside ( j ) = 6 or GetBType ( j ) in [ b_bunker , b_breastwork ] ;
61436: LD_VAR 0 9
61440: PPUSH
61441: CALL_OW 313
61445: PUSH
61446: LD_INT 6
61448: EQUAL
61449: PUSH
61450: LD_VAR 0 9
61454: PPUSH
61455: CALL_OW 266
61459: PUSH
61460: LD_INT 32
61462: PUSH
61463: LD_INT 31
61465: PUSH
61466: EMPTY
61467: LIST
61468: LIST
61469: IN
61470: OR
61471: IFFALSE 61285
61473: GO 61282
61475: POP
61476: POP
// end else
61477: GO 61859
// for j = 1 to x do
61479: LD_ADDR_VAR 0 9
61483: PUSH
61484: DOUBLE
61485: LD_INT 1
61487: DEC
61488: ST_TO_ADDR
61489: LD_VAR 0 13
61493: PUSH
61494: FOR_TO
61495: IFFALSE 61857
// begin InitHc ;
61497: CALL_OW 19
// if not f then
61501: LD_VAR 0 12
61505: NOT
61506: IFFALSE 61595
// begin PrepareHuman ( false , i , skill ) ;
61508: LD_INT 0
61510: PPUSH
61511: LD_VAR 0 8
61515: PPUSH
61516: LD_VAR 0 4
61520: PPUSH
61521: CALL_OW 380
// un := CreateHuman ;
61525: LD_ADDR_VAR 0 14
61529: PUSH
61530: CALL_OW 44
61534: ST_TO_ADDR
// result := Insert ( result , 1 , un ) ;
61535: LD_ADDR_VAR 0 7
61539: PUSH
61540: LD_VAR 0 7
61544: PPUSH
61545: LD_INT 1
61547: PPUSH
61548: LD_VAR 0 14
61552: PPUSH
61553: CALL_OW 2
61557: ST_TO_ADDR
// PlaceUnitXYR ( un , GetX ( base_dep ) , GetY ( base_dep ) , 10 , false ) ;
61558: LD_VAR 0 14
61562: PPUSH
61563: LD_VAR 0 1
61567: PPUSH
61568: CALL_OW 250
61572: PPUSH
61573: LD_VAR 0 1
61577: PPUSH
61578: CALL_OW 251
61582: PPUSH
61583: LD_INT 10
61585: PPUSH
61586: LD_INT 0
61588: PPUSH
61589: CALL_OW 50
// continue ;
61593: GO 61494
// end ; if ( UnitsInside ( f [ 1 ] ) and GetBType ( f [ 1 ] ) in [ b_bunker , b_breastwork ] ) or ( UnitsInside ( f [ 1 ] ) = 6 ) then
61595: LD_VAR 0 12
61599: PUSH
61600: LD_INT 1
61602: ARRAY
61603: PPUSH
61604: CALL_OW 313
61608: PUSH
61609: LD_VAR 0 12
61613: PUSH
61614: LD_INT 1
61616: ARRAY
61617: PPUSH
61618: CALL_OW 266
61622: PUSH
61623: LD_INT 32
61625: PUSH
61626: LD_INT 31
61628: PUSH
61629: EMPTY
61630: LIST
61631: LIST
61632: IN
61633: AND
61634: PUSH
61635: LD_VAR 0 12
61639: PUSH
61640: LD_INT 1
61642: ARRAY
61643: PPUSH
61644: CALL_OW 313
61648: PUSH
61649: LD_INT 6
61651: EQUAL
61652: OR
61653: IFFALSE 61673
// f := Delete ( f , 1 ) ;
61655: LD_ADDR_VAR 0 12
61659: PUSH
61660: LD_VAR 0 12
61664: PPUSH
61665: LD_INT 1
61667: PPUSH
61668: CALL_OW 3
61672: ST_TO_ADDR
// if not f then
61673: LD_VAR 0 12
61677: NOT
61678: IFFALSE 61696
// begin x := x + 2 ;
61680: LD_ADDR_VAR 0 13
61684: PUSH
61685: LD_VAR 0 13
61689: PUSH
61690: LD_INT 2
61692: PLUS
61693: ST_TO_ADDR
// continue ;
61694: GO 61494
// end ; if GetBType ( f [ 1 ] ) = b_barracks then
61696: LD_VAR 0 12
61700: PUSH
61701: LD_INT 1
61703: ARRAY
61704: PPUSH
61705: CALL_OW 266
61709: PUSH
61710: LD_INT 5
61712: EQUAL
61713: IFFALSE 61787
// begin if UnitsInside ( f [ 1 ] ) < 3 then
61715: LD_VAR 0 12
61719: PUSH
61720: LD_INT 1
61722: ARRAY
61723: PPUSH
61724: CALL_OW 313
61728: PUSH
61729: LD_INT 3
61731: LESS
61732: IFFALSE 61768
// PrepareHuman ( false , [ class_sniper , class_mortar , class_bazooker ] [ nation ] , skill ) else
61734: LD_INT 0
61736: PPUSH
61737: LD_INT 5
61739: PUSH
61740: LD_INT 8
61742: PUSH
61743: LD_INT 9
61745: PUSH
61746: EMPTY
61747: LIST
61748: LIST
61749: LIST
61750: PUSH
61751: LD_VAR 0 17
61755: ARRAY
61756: PPUSH
61757: LD_VAR 0 4
61761: PPUSH
61762: CALL_OW 380
61766: GO 61785
// PrepareHuman ( false , i , skill ) ;
61768: LD_INT 0
61770: PPUSH
61771: LD_VAR 0 8
61775: PPUSH
61776: LD_VAR 0 4
61780: PPUSH
61781: CALL_OW 380
// end else
61785: GO 61804
// PrepareHuman ( false , i , skill ) ;
61787: LD_INT 0
61789: PPUSH
61790: LD_VAR 0 8
61794: PPUSH
61795: LD_VAR 0 4
61799: PPUSH
61800: CALL_OW 380
// un := CreateHuman ;
61804: LD_ADDR_VAR 0 14
61808: PUSH
61809: CALL_OW 44
61813: ST_TO_ADDR
// result := Insert ( result , 1 , un ) ;
61814: LD_ADDR_VAR 0 7
61818: PUSH
61819: LD_VAR 0 7
61823: PPUSH
61824: LD_INT 1
61826: PPUSH
61827: LD_VAR 0 14
61831: PPUSH
61832: CALL_OW 2
61836: ST_TO_ADDR
// PlaceHumanInUnit ( un , f [ 1 ] ) ;
61837: LD_VAR 0 14
61841: PPUSH
61842: LD_VAR 0 12
61846: PUSH
61847: LD_INT 1
61849: ARRAY
61850: PPUSH
61851: CALL_OW 52
// end ;
61855: GO 61494
61857: POP
61858: POP
// end ;
61859: GO 60796
61861: POP
61862: POP
// result := result ^ buildings ;
61863: LD_ADDR_VAR 0 7
61867: PUSH
61868: LD_VAR 0 7
61872: PUSH
61873: LD_VAR 0 18
61877: ADD
61878: ST_TO_ADDR
// end else
61879: GO 62022
// begin for i = 1 to personel do
61881: LD_ADDR_VAR 0 8
61885: PUSH
61886: DOUBLE
61887: LD_INT 1
61889: DEC
61890: ST_TO_ADDR
61891: LD_VAR 0 6
61895: PUSH
61896: FOR_TO
61897: IFFALSE 62020
// begin if i > 4 then
61899: LD_VAR 0 8
61903: PUSH
61904: LD_INT 4
61906: GREATER
61907: IFFALSE 61911
// break ;
61909: GO 62020
// x := personel [ i ] ;
61911: LD_ADDR_VAR 0 13
61915: PUSH
61916: LD_VAR 0 6
61920: PUSH
61921: LD_VAR 0 8
61925: ARRAY
61926: ST_TO_ADDR
// if x = - 1 then
61927: LD_VAR 0 13
61931: PUSH
61932: LD_INT 1
61934: NEG
61935: EQUAL
61936: IFFALSE 61940
// continue ;
61938: GO 61896
// PrepareHuman ( false , i , skill ) ;
61940: LD_INT 0
61942: PPUSH
61943: LD_VAR 0 8
61947: PPUSH
61948: LD_VAR 0 4
61952: PPUSH
61953: CALL_OW 380
// un := CreateHuman ;
61957: LD_ADDR_VAR 0 14
61961: PUSH
61962: CALL_OW 44
61966: ST_TO_ADDR
// PlaceUnitXYR ( un , GetX ( base_dep ) , GetY ( base_dep ) , 10 , false ) ;
61967: LD_VAR 0 14
61971: PPUSH
61972: LD_VAR 0 1
61976: PPUSH
61977: CALL_OW 250
61981: PPUSH
61982: LD_VAR 0 1
61986: PPUSH
61987: CALL_OW 251
61991: PPUSH
61992: LD_INT 10
61994: PPUSH
61995: LD_INT 0
61997: PPUSH
61998: CALL_OW 50
// result := result ^ un ;
62002: LD_ADDR_VAR 0 7
62006: PUSH
62007: LD_VAR 0 7
62011: PUSH
62012: LD_VAR 0 14
62016: ADD
62017: ST_TO_ADDR
// end ;
62018: GO 61896
62020: POP
62021: POP
// end ; end ;
62022: LD_VAR 0 7
62026: RET
// export function GetTurretWeapon ( tower , area ) ; var hex , list , factories , base , i , j , x , y , nat , h , tmp , height , side , fac_list , weapon ; begin
62027: LD_INT 0
62029: PPUSH
62030: PPUSH
62031: PPUSH
62032: PPUSH
62033: PPUSH
62034: PPUSH
62035: PPUSH
62036: PPUSH
62037: PPUSH
62038: PPUSH
62039: PPUSH
62040: PPUSH
62041: PPUSH
62042: PPUSH
62043: PPUSH
62044: PPUSH
// result := false ;
62045: LD_ADDR_VAR 0 3
62049: PUSH
62050: LD_INT 0
62052: ST_TO_ADDR
// if not tower or not GetBType ( tower ) in [ b_bunker , b_turret ] then
62053: LD_VAR 0 1
62057: NOT
62058: PUSH
62059: LD_VAR 0 1
62063: PPUSH
62064: CALL_OW 266
62068: PUSH
62069: LD_INT 32
62071: PUSH
62072: LD_INT 33
62074: PUSH
62075: EMPTY
62076: LIST
62077: LIST
62078: IN
62079: NOT
62080: OR
62081: IFFALSE 62085
// exit ;
62083: GO 63194
// nat := GetNation ( tower ) ;
62085: LD_ADDR_VAR 0 12
62089: PUSH
62090: LD_VAR 0 1
62094: PPUSH
62095: CALL_OW 248
62099: ST_TO_ADDR
// side := GetSide ( tower ) ;
62100: LD_ADDR_VAR 0 16
62104: PUSH
62105: LD_VAR 0 1
62109: PPUSH
62110: CALL_OW 255
62114: ST_TO_ADDR
// x := GetX ( tower ) ;
62115: LD_ADDR_VAR 0 10
62119: PUSH
62120: LD_VAR 0 1
62124: PPUSH
62125: CALL_OW 250
62129: ST_TO_ADDR
// y := GetY ( tower ) ;
62130: LD_ADDR_VAR 0 11
62134: PUSH
62135: LD_VAR 0 1
62139: PPUSH
62140: CALL_OW 251
62144: ST_TO_ADDR
// if not x or not y then
62145: LD_VAR 0 10
62149: NOT
62150: PUSH
62151: LD_VAR 0 11
62155: NOT
62156: OR
62157: IFFALSE 62161
// exit ;
62159: GO 63194
// weapon := 0 ;
62161: LD_ADDR_VAR 0 18
62165: PUSH
62166: LD_INT 0
62168: ST_TO_ADDR
// fac_list := [ ] ;
62169: LD_ADDR_VAR 0 17
62173: PUSH
62174: EMPTY
62175: ST_TO_ADDR
// factories := UnitFilter ( GetBaseBuildings ( GetBase ( tower ) , area , false ) , [ f_btype , b_factory ] ) ;
62176: LD_ADDR_VAR 0 6
62180: PUSH
62181: LD_VAR 0 1
62185: PPUSH
62186: CALL_OW 274
62190: PPUSH
62191: LD_VAR 0 2
62195: PPUSH
62196: LD_INT 0
62198: PPUSH
62199: CALL 59765 0 3
62203: PPUSH
62204: LD_INT 30
62206: PUSH
62207: LD_INT 3
62209: PUSH
62210: EMPTY
62211: LIST
62212: LIST
62213: PPUSH
62214: CALL_OW 72
62218: ST_TO_ADDR
// if not factories then
62219: LD_VAR 0 6
62223: NOT
62224: IFFALSE 62228
// exit ;
62226: GO 63194
// for i in factories do
62228: LD_ADDR_VAR 0 8
62232: PUSH
62233: LD_VAR 0 6
62237: PUSH
62238: FOR_IN
62239: IFFALSE 62264
// fac_list := fac_list union AvailableWeaponList ( i ) ;
62241: LD_ADDR_VAR 0 17
62245: PUSH
62246: LD_VAR 0 17
62250: PUSH
62251: LD_VAR 0 8
62255: PPUSH
62256: CALL_OW 478
62260: UNION
62261: ST_TO_ADDR
62262: GO 62238
62264: POP
62265: POP
// if not fac_list then
62266: LD_VAR 0 17
62270: NOT
62271: IFFALSE 62275
// exit ;
62273: GO 63194
// list := [ [ us_gatling_gun , us_double_gun , us_laser , us_double_laser , us_heavy_gun , us_rocket_launcher , us_radar ] , [ ar_gun , ar_rocket_launcher , ar_flame_thrower , ar_radar ] , [ ru_gatling_gun , ru_gun , ru_heavy_gun , ru_rocket_launcher , ru_rocket , ru_time_lapser ] ] [ nat ] ;
62275: LD_ADDR_VAR 0 5
62279: PUSH
62280: LD_INT 4
62282: PUSH
62283: LD_INT 5
62285: PUSH
62286: LD_INT 9
62288: PUSH
62289: LD_INT 10
62291: PUSH
62292: LD_INT 6
62294: PUSH
62295: LD_INT 7
62297: PUSH
62298: LD_INT 11
62300: PUSH
62301: EMPTY
62302: LIST
62303: LIST
62304: LIST
62305: LIST
62306: LIST
62307: LIST
62308: LIST
62309: PUSH
62310: LD_INT 27
62312: PUSH
62313: LD_INT 28
62315: PUSH
62316: LD_INT 26
62318: PUSH
62319: LD_INT 30
62321: PUSH
62322: EMPTY
62323: LIST
62324: LIST
62325: LIST
62326: LIST
62327: PUSH
62328: LD_INT 43
62330: PUSH
62331: LD_INT 44
62333: PUSH
62334: LD_INT 46
62336: PUSH
62337: LD_INT 45
62339: PUSH
62340: LD_INT 47
62342: PUSH
62343: LD_INT 49
62345: PUSH
62346: EMPTY
62347: LIST
62348: LIST
62349: LIST
62350: LIST
62351: LIST
62352: LIST
62353: PUSH
62354: EMPTY
62355: LIST
62356: LIST
62357: LIST
62358: PUSH
62359: LD_VAR 0 12
62363: ARRAY
62364: ST_TO_ADDR
// list := list isect fac_list ;
62365: LD_ADDR_VAR 0 5
62369: PUSH
62370: LD_VAR 0 5
62374: PUSH
62375: LD_VAR 0 17
62379: ISECT
62380: ST_TO_ADDR
// if not list then
62381: LD_VAR 0 5
62385: NOT
62386: IFFALSE 62390
// exit ;
62388: GO 63194
// if nat = nation_russian and ru_time_lapser in list and GetTech ( tech_lapser , side ) = state_researched then
62390: LD_VAR 0 12
62394: PUSH
62395: LD_INT 3
62397: EQUAL
62398: PUSH
62399: LD_INT 49
62401: PUSH
62402: LD_VAR 0 5
62406: IN
62407: AND
62408: PUSH
62409: LD_INT 31
62411: PPUSH
62412: LD_VAR 0 16
62416: PPUSH
62417: CALL_OW 321
62421: PUSH
62422: LD_INT 2
62424: EQUAL
62425: AND
62426: IFFALSE 62486
// begin if not FilterAllUnits ( [ [ f_side , side ] , [ f_bweapon , ru_time_lapser ] , [ f_dist , tower , 10 ] ] ) then
62428: LD_INT 22
62430: PUSH
62431: LD_VAR 0 16
62435: PUSH
62436: EMPTY
62437: LIST
62438: LIST
62439: PUSH
62440: LD_INT 35
62442: PUSH
62443: LD_INT 49
62445: PUSH
62446: EMPTY
62447: LIST
62448: LIST
62449: PUSH
62450: LD_INT 91
62452: PUSH
62453: LD_VAR 0 1
62457: PUSH
62458: LD_INT 10
62460: PUSH
62461: EMPTY
62462: LIST
62463: LIST
62464: LIST
62465: PUSH
62466: EMPTY
62467: LIST
62468: LIST
62469: LIST
62470: PPUSH
62471: CALL_OW 69
62475: NOT
62476: IFFALSE 62486
// weapon := ru_time_lapser ;
62478: LD_ADDR_VAR 0 18
62482: PUSH
62483: LD_INT 49
62485: ST_TO_ADDR
// end ; if nat in [ 1 , 2 ] and ( us_radar in list or ar_radar in list ) and GetTech ( tech_radar , side ) = state_researched then
62486: LD_VAR 0 12
62490: PUSH
62491: LD_INT 1
62493: PUSH
62494: LD_INT 2
62496: PUSH
62497: EMPTY
62498: LIST
62499: LIST
62500: IN
62501: PUSH
62502: LD_INT 11
62504: PUSH
62505: LD_VAR 0 5
62509: IN
62510: PUSH
62511: LD_INT 30
62513: PUSH
62514: LD_VAR 0 5
62518: IN
62519: OR
62520: AND
62521: PUSH
62522: LD_INT 6
62524: PPUSH
62525: LD_VAR 0 16
62529: PPUSH
62530: CALL_OW 321
62534: PUSH
62535: LD_INT 2
62537: EQUAL
62538: AND
62539: IFFALSE 62704
// begin if not FilterAllUnits ( [ [ f_side , side ] , [ f_or , [ f_bweapon , us_radar ] , [ f_bweapon , ar_radar ] ] , [ f_dist , tower , 18 ] ] ) and FilterAllUnits ( [ [ [ f_side , side ] , [ f_or , [ f_btype , b_bunker ] , [ f_btype , b_turret ] ] , [ f_dist , tower , 12 ] ] ] ) > 2 then
62541: LD_INT 22
62543: PUSH
62544: LD_VAR 0 16
62548: PUSH
62549: EMPTY
62550: LIST
62551: LIST
62552: PUSH
62553: LD_INT 2
62555: PUSH
62556: LD_INT 35
62558: PUSH
62559: LD_INT 11
62561: PUSH
62562: EMPTY
62563: LIST
62564: LIST
62565: PUSH
62566: LD_INT 35
62568: PUSH
62569: LD_INT 30
62571: PUSH
62572: EMPTY
62573: LIST
62574: LIST
62575: PUSH
62576: EMPTY
62577: LIST
62578: LIST
62579: LIST
62580: PUSH
62581: LD_INT 91
62583: PUSH
62584: LD_VAR 0 1
62588: PUSH
62589: LD_INT 18
62591: PUSH
62592: EMPTY
62593: LIST
62594: LIST
62595: LIST
62596: PUSH
62597: EMPTY
62598: LIST
62599: LIST
62600: LIST
62601: PPUSH
62602: CALL_OW 69
62606: NOT
62607: PUSH
62608: LD_INT 22
62610: PUSH
62611: LD_VAR 0 16
62615: PUSH
62616: EMPTY
62617: LIST
62618: LIST
62619: PUSH
62620: LD_INT 2
62622: PUSH
62623: LD_INT 30
62625: PUSH
62626: LD_INT 32
62628: PUSH
62629: EMPTY
62630: LIST
62631: LIST
62632: PUSH
62633: LD_INT 30
62635: PUSH
62636: LD_INT 33
62638: PUSH
62639: EMPTY
62640: LIST
62641: LIST
62642: PUSH
62643: EMPTY
62644: LIST
62645: LIST
62646: LIST
62647: PUSH
62648: LD_INT 91
62650: PUSH
62651: LD_VAR 0 1
62655: PUSH
62656: LD_INT 12
62658: PUSH
62659: EMPTY
62660: LIST
62661: LIST
62662: LIST
62663: PUSH
62664: EMPTY
62665: LIST
62666: LIST
62667: LIST
62668: PUSH
62669: EMPTY
62670: LIST
62671: PPUSH
62672: CALL_OW 69
62676: PUSH
62677: LD_INT 2
62679: GREATER
62680: AND
62681: IFFALSE 62704
// weapon := [ us_radar , ar_radar ] [ nat ] ;
62683: LD_ADDR_VAR 0 18
62687: PUSH
62688: LD_INT 11
62690: PUSH
62691: LD_INT 30
62693: PUSH
62694: EMPTY
62695: LIST
62696: LIST
62697: PUSH
62698: LD_VAR 0 12
62702: ARRAY
62703: ST_TO_ADDR
// end ; if not weapon and GetTech ( tech_rocket , side ) = state_researched and ( us_rocket_launcher in list or ar_rocket_launcher in list or ru_rocket_launcher in list ) then
62704: LD_VAR 0 18
62708: NOT
62709: PUSH
62710: LD_INT 40
62712: PPUSH
62713: LD_VAR 0 16
62717: PPUSH
62718: CALL_OW 321
62722: PUSH
62723: LD_INT 2
62725: EQUAL
62726: AND
62727: PUSH
62728: LD_INT 7
62730: PUSH
62731: LD_VAR 0 5
62735: IN
62736: PUSH
62737: LD_INT 28
62739: PUSH
62740: LD_VAR 0 5
62744: IN
62745: OR
62746: PUSH
62747: LD_INT 45
62749: PUSH
62750: LD_VAR 0 5
62754: IN
62755: OR
62756: AND
62757: IFFALSE 63011
// begin hex := GetHexInfo ( x , y ) ;
62759: LD_ADDR_VAR 0 4
62763: PUSH
62764: LD_VAR 0 10
62768: PPUSH
62769: LD_VAR 0 11
62773: PPUSH
62774: CALL_OW 546
62778: ST_TO_ADDR
// if hex [ 1 ] then
62779: LD_VAR 0 4
62783: PUSH
62784: LD_INT 1
62786: ARRAY
62787: IFFALSE 62791
// exit ;
62789: GO 63194
// height := hex [ 2 ] ;
62791: LD_ADDR_VAR 0 15
62795: PUSH
62796: LD_VAR 0 4
62800: PUSH
62801: LD_INT 2
62803: ARRAY
62804: ST_TO_ADDR
// tmp := [ 0 , 2 , 3 , 5 ] ;
62805: LD_ADDR_VAR 0 14
62809: PUSH
62810: LD_INT 0
62812: PUSH
62813: LD_INT 2
62815: PUSH
62816: LD_INT 3
62818: PUSH
62819: LD_INT 5
62821: PUSH
62822: EMPTY
62823: LIST
62824: LIST
62825: LIST
62826: LIST
62827: ST_TO_ADDR
// for i in tmp do
62828: LD_ADDR_VAR 0 8
62832: PUSH
62833: LD_VAR 0 14
62837: PUSH
62838: FOR_IN
62839: IFFALSE 63009
// begin j := [ ShiftX ( x , i , 5 ) , ShiftY ( y , i , 5 ) ] ;
62841: LD_ADDR_VAR 0 9
62845: PUSH
62846: LD_VAR 0 10
62850: PPUSH
62851: LD_VAR 0 8
62855: PPUSH
62856: LD_INT 5
62858: PPUSH
62859: CALL_OW 272
62863: PUSH
62864: LD_VAR 0 11
62868: PPUSH
62869: LD_VAR 0 8
62873: PPUSH
62874: LD_INT 5
62876: PPUSH
62877: CALL_OW 273
62881: PUSH
62882: EMPTY
62883: LIST
62884: LIST
62885: ST_TO_ADDR
// if ValidHex ( j [ 1 ] , j [ 2 ] ) then
62886: LD_VAR 0 9
62890: PUSH
62891: LD_INT 1
62893: ARRAY
62894: PPUSH
62895: LD_VAR 0 9
62899: PUSH
62900: LD_INT 2
62902: ARRAY
62903: PPUSH
62904: CALL_OW 488
62908: IFFALSE 63007
// begin hex := GetHexInfo ( j [ 1 ] , j [ 2 ] ) ;
62910: LD_ADDR_VAR 0 4
62914: PUSH
62915: LD_VAR 0 9
62919: PUSH
62920: LD_INT 1
62922: ARRAY
62923: PPUSH
62924: LD_VAR 0 9
62928: PUSH
62929: LD_INT 2
62931: ARRAY
62932: PPUSH
62933: CALL_OW 546
62937: ST_TO_ADDR
// if hex [ 1 ] then
62938: LD_VAR 0 4
62942: PUSH
62943: LD_INT 1
62945: ARRAY
62946: IFFALSE 62950
// continue ;
62948: GO 62838
// h := hex [ 2 ] ;
62950: LD_ADDR_VAR 0 13
62954: PUSH
62955: LD_VAR 0 4
62959: PUSH
62960: LD_INT 2
62962: ARRAY
62963: ST_TO_ADDR
// if h + 7 < height then
62964: LD_VAR 0 13
62968: PUSH
62969: LD_INT 7
62971: PLUS
62972: PUSH
62973: LD_VAR 0 15
62977: LESS
62978: IFFALSE 63007
// begin weapon := [ us_rocket_launcher , ar_rocket_launcher , ru_rocket_launcher ] [ nat ] ;
62980: LD_ADDR_VAR 0 18
62984: PUSH
62985: LD_INT 7
62987: PUSH
62988: LD_INT 28
62990: PUSH
62991: LD_INT 45
62993: PUSH
62994: EMPTY
62995: LIST
62996: LIST
62997: LIST
62998: PUSH
62999: LD_VAR 0 12
63003: ARRAY
63004: ST_TO_ADDR
// break ;
63005: GO 63009
// end ; end ; end ;
63007: GO 62838
63009: POP
63010: POP
// end ; if not weapon then
63011: LD_VAR 0 18
63015: NOT
63016: IFFALSE 63076
// begin list := list diff [ us_radar , ar_radar , ru_time_lapser ] ;
63018: LD_ADDR_VAR 0 5
63022: PUSH
63023: LD_VAR 0 5
63027: PUSH
63028: LD_INT 11
63030: PUSH
63031: LD_INT 30
63033: PUSH
63034: LD_INT 49
63036: PUSH
63037: EMPTY
63038: LIST
63039: LIST
63040: LIST
63041: DIFF
63042: ST_TO_ADDR
// if not list then
63043: LD_VAR 0 5
63047: NOT
63048: IFFALSE 63052
// exit ;
63050: GO 63194
// weapon := list [ rand ( 1 , list ) ] ;
63052: LD_ADDR_VAR 0 18
63056: PUSH
63057: LD_VAR 0 5
63061: PUSH
63062: LD_INT 1
63064: PPUSH
63065: LD_VAR 0 5
63069: PPUSH
63070: CALL_OW 12
63074: ARRAY
63075: ST_TO_ADDR
// end ; if weapon then
63076: LD_VAR 0 18
63080: IFFALSE 63194
// begin tmp := CostOfWeapon ( weapon ) ;
63082: LD_ADDR_VAR 0 14
63086: PUSH
63087: LD_VAR 0 18
63091: PPUSH
63092: CALL_OW 451
63096: ST_TO_ADDR
// j := GetBase ( tower ) ;
63097: LD_ADDR_VAR 0 9
63101: PUSH
63102: LD_VAR 0 1
63106: PPUSH
63107: CALL_OW 274
63111: ST_TO_ADDR
// if GetResourceType ( j , mat_cans ) >= tmp [ 1 ] and GetResourceType ( j , mat_oil ) >= tmp [ 2 ] and GetResourceType ( j , mat_siberit ) >= tmp [ 3 ] then
63112: LD_VAR 0 9
63116: PPUSH
63117: LD_INT 1
63119: PPUSH
63120: CALL_OW 275
63124: PUSH
63125: LD_VAR 0 14
63129: PUSH
63130: LD_INT 1
63132: ARRAY
63133: GREATEREQUAL
63134: PUSH
63135: LD_VAR 0 9
63139: PPUSH
63140: LD_INT 2
63142: PPUSH
63143: CALL_OW 275
63147: PUSH
63148: LD_VAR 0 14
63152: PUSH
63153: LD_INT 2
63155: ARRAY
63156: GREATEREQUAL
63157: AND
63158: PUSH
63159: LD_VAR 0 9
63163: PPUSH
63164: LD_INT 3
63166: PPUSH
63167: CALL_OW 275
63171: PUSH
63172: LD_VAR 0 14
63176: PUSH
63177: LD_INT 3
63179: ARRAY
63180: GREATEREQUAL
63181: AND
63182: IFFALSE 63194
// result := weapon ;
63184: LD_ADDR_VAR 0 3
63188: PUSH
63189: LD_VAR 0 18
63193: ST_TO_ADDR
// end ; end ;
63194: LD_VAR 0 3
63198: RET
// export function CompareArray ( array1 , array2 ) ; var i ; begin
63199: LD_INT 0
63201: PPUSH
63202: PPUSH
// result := true ;
63203: LD_ADDR_VAR 0 3
63207: PUSH
63208: LD_INT 1
63210: ST_TO_ADDR
// if array1 = array2 then
63211: LD_VAR 0 1
63215: PUSH
63216: LD_VAR 0 2
63220: EQUAL
63221: IFFALSE 63281
// begin for i = 1 to array1 do
63223: LD_ADDR_VAR 0 4
63227: PUSH
63228: DOUBLE
63229: LD_INT 1
63231: DEC
63232: ST_TO_ADDR
63233: LD_VAR 0 1
63237: PUSH
63238: FOR_TO
63239: IFFALSE 63277
// if array1 [ i ] <> array2 [ i ] then
63241: LD_VAR 0 1
63245: PUSH
63246: LD_VAR 0 4
63250: ARRAY
63251: PUSH
63252: LD_VAR 0 2
63256: PUSH
63257: LD_VAR 0 4
63261: ARRAY
63262: NONEQUAL
63263: IFFALSE 63275
// begin result := false ;
63265: LD_ADDR_VAR 0 3
63269: PUSH
63270: LD_INT 0
63272: ST_TO_ADDR
// break ;
63273: GO 63277
// end ;
63275: GO 63238
63277: POP
63278: POP
// end else
63279: GO 63289
// result := false ;
63281: LD_ADDR_VAR 0 3
63285: PUSH
63286: LD_INT 0
63288: ST_TO_ADDR
// end ;
63289: LD_VAR 0 3
63293: RET
// export function CompareArrayValues ( array1 , array2 ) ; var i ; begin
63294: LD_INT 0
63296: PPUSH
63297: PPUSH
// if not array1 or not array2 then
63298: LD_VAR 0 1
63302: NOT
63303: PUSH
63304: LD_VAR 0 2
63308: NOT
63309: OR
63310: IFFALSE 63314
// exit ;
63312: GO 63378
// result := true ;
63314: LD_ADDR_VAR 0 3
63318: PUSH
63319: LD_INT 1
63321: ST_TO_ADDR
// for i = 1 to array1 do
63322: LD_ADDR_VAR 0 4
63326: PUSH
63327: DOUBLE
63328: LD_INT 1
63330: DEC
63331: ST_TO_ADDR
63332: LD_VAR 0 1
63336: PUSH
63337: FOR_TO
63338: IFFALSE 63376
// if array1 [ i ] <> array2 [ i ] then
63340: LD_VAR 0 1
63344: PUSH
63345: LD_VAR 0 4
63349: ARRAY
63350: PUSH
63351: LD_VAR 0 2
63355: PUSH
63356: LD_VAR 0 4
63360: ARRAY
63361: NONEQUAL
63362: IFFALSE 63374
// begin result := false ;
63364: LD_ADDR_VAR 0 3
63368: PUSH
63369: LD_INT 0
63371: ST_TO_ADDR
// break ;
63372: GO 63376
// end ;
63374: GO 63337
63376: POP
63377: POP
// end ;
63378: LD_VAR 0 3
63382: RET
// export function VehicleCost ( fac , list ) ; var cost , pom ; begin
63383: LD_INT 0
63385: PPUSH
63386: PPUSH
63387: PPUSH
// pom := GetBase ( fac ) ;
63388: LD_ADDR_VAR 0 5
63392: PUSH
63393: LD_VAR 0 1
63397: PPUSH
63398: CALL_OW 274
63402: ST_TO_ADDR
// cost := CostOfVehicle ( list [ 1 ] , list [ 2 ] , list [ 3 ] , list [ 4 ] ) ;
63403: LD_ADDR_VAR 0 4
63407: PUSH
63408: LD_VAR 0 2
63412: PUSH
63413: LD_INT 1
63415: ARRAY
63416: PPUSH
63417: LD_VAR 0 2
63421: PUSH
63422: LD_INT 2
63424: ARRAY
63425: PPUSH
63426: LD_VAR 0 2
63430: PUSH
63431: LD_INT 3
63433: ARRAY
63434: PPUSH
63435: LD_VAR 0 2
63439: PUSH
63440: LD_INT 4
63442: ARRAY
63443: PPUSH
63444: CALL_OW 449
63448: ST_TO_ADDR
// result := GetResourceType ( pom , mat_cans ) >= cost [ 1 ] and GetResourceType ( pom , mat_oil ) >= cost [ 2 ] and GetResourceType ( pom , mat_siberit ) >= cost [ 3 ] ;
63449: LD_ADDR_VAR 0 3
63453: PUSH
63454: LD_VAR 0 5
63458: PPUSH
63459: LD_INT 1
63461: PPUSH
63462: CALL_OW 275
63466: PUSH
63467: LD_VAR 0 4
63471: PUSH
63472: LD_INT 1
63474: ARRAY
63475: GREATEREQUAL
63476: PUSH
63477: LD_VAR 0 5
63481: PPUSH
63482: LD_INT 2
63484: PPUSH
63485: CALL_OW 275
63489: PUSH
63490: LD_VAR 0 4
63494: PUSH
63495: LD_INT 2
63497: ARRAY
63498: GREATEREQUAL
63499: AND
63500: PUSH
63501: LD_VAR 0 5
63505: PPUSH
63506: LD_INT 3
63508: PPUSH
63509: CALL_OW 275
63513: PUSH
63514: LD_VAR 0 4
63518: PUSH
63519: LD_INT 3
63521: ARRAY
63522: GREATEREQUAL
63523: AND
63524: ST_TO_ADDR
// end ;
63525: LD_VAR 0 3
63529: RET
// export function UpgradeCost ( building ) ; var pom , cost , btype ; begin
63530: LD_INT 0
63532: PPUSH
63533: PPUSH
63534: PPUSH
63535: PPUSH
// pom := GetBase ( building ) ;
63536: LD_ADDR_VAR 0 3
63540: PUSH
63541: LD_VAR 0 1
63545: PPUSH
63546: CALL_OW 274
63550: ST_TO_ADDR
// if not pom then
63551: LD_VAR 0 3
63555: NOT
63556: IFFALSE 63560
// exit ;
63558: GO 63730
// btype := GetBType ( building ) ;
63560: LD_ADDR_VAR 0 5
63564: PUSH
63565: LD_VAR 0 1
63569: PPUSH
63570: CALL_OW 266
63574: ST_TO_ADDR
// if btype = b_armoury then
63575: LD_VAR 0 5
63579: PUSH
63580: LD_INT 4
63582: EQUAL
63583: IFFALSE 63593
// btype := b_barracks ;
63585: LD_ADDR_VAR 0 5
63589: PUSH
63590: LD_INT 5
63592: ST_TO_ADDR
// if btype = b_depot then
63593: LD_VAR 0 5
63597: PUSH
63598: LD_INT 0
63600: EQUAL
63601: IFFALSE 63611
// btype := b_warehouse ;
63603: LD_ADDR_VAR 0 5
63607: PUSH
63608: LD_INT 1
63610: ST_TO_ADDR
// if btype = b_workshop then
63611: LD_VAR 0 5
63615: PUSH
63616: LD_INT 2
63618: EQUAL
63619: IFFALSE 63629
// btype := b_factory ;
63621: LD_ADDR_VAR 0 5
63625: PUSH
63626: LD_INT 3
63628: ST_TO_ADDR
// cost := CostOfBuilding ( btype , GetNation ( building ) ) ;
63629: LD_ADDR_VAR 0 4
63633: PUSH
63634: LD_VAR 0 5
63638: PPUSH
63639: LD_VAR 0 1
63643: PPUSH
63644: CALL_OW 248
63648: PPUSH
63649: CALL_OW 450
63653: ST_TO_ADDR
// result := GetResourceType ( pom , mat_cans ) >= cost [ 1 ] and GetResourceType ( pom , mat_oil ) >= cost [ 2 ] and GetResourceType ( pom , mat_siberit ) >= cost [ 3 ] ;
63654: LD_ADDR_VAR 0 2
63658: PUSH
63659: LD_VAR 0 3
63663: PPUSH
63664: LD_INT 1
63666: PPUSH
63667: CALL_OW 275
63671: PUSH
63672: LD_VAR 0 4
63676: PUSH
63677: LD_INT 1
63679: ARRAY
63680: GREATEREQUAL
63681: PUSH
63682: LD_VAR 0 3
63686: PPUSH
63687: LD_INT 2
63689: PPUSH
63690: CALL_OW 275
63694: PUSH
63695: LD_VAR 0 4
63699: PUSH
63700: LD_INT 2
63702: ARRAY
63703: GREATEREQUAL
63704: AND
63705: PUSH
63706: LD_VAR 0 3
63710: PPUSH
63711: LD_INT 3
63713: PPUSH
63714: CALL_OW 275
63718: PUSH
63719: LD_VAR 0 4
63723: PUSH
63724: LD_INT 3
63726: ARRAY
63727: GREATEREQUAL
63728: AND
63729: ST_TO_ADDR
// end ;
63730: LD_VAR 0 2
63734: RET
// export function UpgradeLabCost ( building , btype ) ; var pom , cost ; begin
63735: LD_INT 0
63737: PPUSH
63738: PPUSH
63739: PPUSH
// pom := GetBase ( building ) ;
63740: LD_ADDR_VAR 0 4
63744: PUSH
63745: LD_VAR 0 1
63749: PPUSH
63750: CALL_OW 274
63754: ST_TO_ADDR
// if not pom then
63755: LD_VAR 0 4
63759: NOT
63760: IFFALSE 63764
// exit ;
63762: GO 63865
// cost := CostOfBuilding ( btype , GetNation ( building ) ) ;
63764: LD_ADDR_VAR 0 5
63768: PUSH
63769: LD_VAR 0 2
63773: PPUSH
63774: LD_VAR 0 1
63778: PPUSH
63779: CALL_OW 248
63783: PPUSH
63784: CALL_OW 450
63788: ST_TO_ADDR
// result := GetResourceType ( pom , mat_cans ) >= cost [ 1 ] and GetResourceType ( pom , mat_oil ) >= cost [ 2 ] and GetResourceType ( pom , mat_siberit ) >= cost [ 3 ] ;
63789: LD_ADDR_VAR 0 3
63793: PUSH
63794: LD_VAR 0 4
63798: PPUSH
63799: LD_INT 1
63801: PPUSH
63802: CALL_OW 275
63806: PUSH
63807: LD_VAR 0 5
63811: PUSH
63812: LD_INT 1
63814: ARRAY
63815: GREATEREQUAL
63816: PUSH
63817: LD_VAR 0 4
63821: PPUSH
63822: LD_INT 2
63824: PPUSH
63825: CALL_OW 275
63829: PUSH
63830: LD_VAR 0 5
63834: PUSH
63835: LD_INT 2
63837: ARRAY
63838: GREATEREQUAL
63839: AND
63840: PUSH
63841: LD_VAR 0 4
63845: PPUSH
63846: LD_INT 3
63848: PPUSH
63849: CALL_OW 275
63853: PUSH
63854: LD_VAR 0 5
63858: PUSH
63859: LD_INT 3
63861: ARRAY
63862: GREATEREQUAL
63863: AND
63864: ST_TO_ADDR
// end ;
63865: LD_VAR 0 3
63869: RET
// export function TryClearPlaceForBuilding ( btype , x , y , d , buildings , cleaners , parking ) ; var i , j , _x , _y , tmp , hexes , r , xy , dep , driver ; begin
63870: LD_INT 0
63872: PPUSH
63873: PPUSH
63874: PPUSH
63875: PPUSH
63876: PPUSH
63877: PPUSH
63878: PPUSH
63879: PPUSH
63880: PPUSH
63881: PPUSH
63882: PPUSH
// result := false ;
63883: LD_ADDR_VAR 0 8
63887: PUSH
63888: LD_INT 0
63890: ST_TO_ADDR
// if not buildings or not btype or not x or not y then
63891: LD_VAR 0 5
63895: NOT
63896: PUSH
63897: LD_VAR 0 1
63901: NOT
63902: OR
63903: PUSH
63904: LD_VAR 0 2
63908: NOT
63909: OR
63910: PUSH
63911: LD_VAR 0 3
63915: NOT
63916: OR
63917: IFFALSE 63921
// exit ;
63919: GO 64735
// hexes := GetBuildingHexes ( btype , x , y , d , GetNation ( buildings [ 1 ] ) , 0 ) ;
63921: LD_ADDR_VAR 0 14
63925: PUSH
63926: LD_VAR 0 1
63930: PPUSH
63931: LD_VAR 0 2
63935: PPUSH
63936: LD_VAR 0 3
63940: PPUSH
63941: LD_VAR 0 4
63945: PPUSH
63946: LD_VAR 0 5
63950: PUSH
63951: LD_INT 1
63953: ARRAY
63954: PPUSH
63955: CALL_OW 248
63959: PPUSH
63960: LD_INT 0
63962: PPUSH
63963: CALL 65972 0 6
63967: ST_TO_ADDR
// if not hexes then
63968: LD_VAR 0 14
63972: NOT
63973: IFFALSE 63977
// exit ;
63975: GO 64735
// dep := UnitFilter ( buildings , [ [ f_side , GetSide ( tmp ) ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ] ) ;
63977: LD_ADDR_VAR 0 17
63981: PUSH
63982: LD_VAR 0 5
63986: PPUSH
63987: LD_INT 22
63989: PUSH
63990: LD_VAR 0 13
63994: PPUSH
63995: CALL_OW 255
63999: PUSH
64000: EMPTY
64001: LIST
64002: LIST
64003: PUSH
64004: LD_INT 2
64006: PUSH
64007: LD_INT 30
64009: PUSH
64010: LD_INT 0
64012: PUSH
64013: EMPTY
64014: LIST
64015: LIST
64016: PUSH
64017: LD_INT 30
64019: PUSH
64020: LD_INT 1
64022: PUSH
64023: EMPTY
64024: LIST
64025: LIST
64026: PUSH
64027: EMPTY
64028: LIST
64029: LIST
64030: LIST
64031: PUSH
64032: EMPTY
64033: LIST
64034: LIST
64035: PPUSH
64036: CALL_OW 72
64040: ST_TO_ADDR
// for i = 1 to hexes do
64041: LD_ADDR_VAR 0 9
64045: PUSH
64046: DOUBLE
64047: LD_INT 1
64049: DEC
64050: ST_TO_ADDR
64051: LD_VAR 0 14
64055: PUSH
64056: FOR_TO
64057: IFFALSE 64733
// begin tmp := HexInfo ( hexes [ i ] [ 1 ] , hexes [ i ] [ 2 ] ) ;
64059: LD_ADDR_VAR 0 13
64063: PUSH
64064: LD_VAR 0 14
64068: PUSH
64069: LD_VAR 0 9
64073: ARRAY
64074: PUSH
64075: LD_INT 1
64077: ARRAY
64078: PPUSH
64079: LD_VAR 0 14
64083: PUSH
64084: LD_VAR 0 9
64088: ARRAY
64089: PUSH
64090: LD_INT 2
64092: ARRAY
64093: PPUSH
64094: CALL_OW 428
64098: ST_TO_ADDR
// if IsEnvironment ( hexes [ i ] [ 1 ] , hexes [ i ] [ 2 ] ) or not ValidHex ( hexes [ i ] [ 1 ] , hexes [ i ] [ 2 ] ) or GetType ( tmp ) = unit_building then
64099: LD_VAR 0 14
64103: PUSH
64104: LD_VAR 0 9
64108: ARRAY
64109: PUSH
64110: LD_INT 1
64112: ARRAY
64113: PPUSH
64114: LD_VAR 0 14
64118: PUSH
64119: LD_VAR 0 9
64123: ARRAY
64124: PUSH
64125: LD_INT 2
64127: ARRAY
64128: PPUSH
64129: CALL_OW 351
64133: PUSH
64134: LD_VAR 0 14
64138: PUSH
64139: LD_VAR 0 9
64143: ARRAY
64144: PUSH
64145: LD_INT 1
64147: ARRAY
64148: PPUSH
64149: LD_VAR 0 14
64153: PUSH
64154: LD_VAR 0 9
64158: ARRAY
64159: PUSH
64160: LD_INT 2
64162: ARRAY
64163: PPUSH
64164: CALL_OW 488
64168: NOT
64169: OR
64170: PUSH
64171: LD_VAR 0 13
64175: PPUSH
64176: CALL_OW 247
64180: PUSH
64181: LD_INT 3
64183: EQUAL
64184: OR
64185: IFFALSE 64191
// exit ;
64187: POP
64188: POP
64189: GO 64735
// if not tmp then
64191: LD_VAR 0 13
64195: NOT
64196: IFFALSE 64200
// continue ;
64198: GO 64056
// result := true ;
64200: LD_ADDR_VAR 0 8
64204: PUSH
64205: LD_INT 1
64207: ST_TO_ADDR
// if cleaners and GetType ( tmp ) = unit_vehicle and GetControl ( tmp ) = control_manual then
64208: LD_VAR 0 6
64212: PUSH
64213: LD_VAR 0 13
64217: PPUSH
64218: CALL_OW 247
64222: PUSH
64223: LD_INT 2
64225: EQUAL
64226: AND
64227: PUSH
64228: LD_VAR 0 13
64232: PPUSH
64233: CALL_OW 263
64237: PUSH
64238: LD_INT 1
64240: EQUAL
64241: AND
64242: IFFALSE 64406
// begin if IsDrivenBy ( tmp ) then
64244: LD_VAR 0 13
64248: PPUSH
64249: CALL_OW 311
64253: IFFALSE 64257
// continue ;
64255: GO 64056
// if UnitFilter ( cleaners , [ [ f_not , [ f_hastask ] ] , [ f_not , [ f_driving ] ] ] ) then
64257: LD_VAR 0 6
64261: PPUSH
64262: LD_INT 3
64264: PUSH
64265: LD_INT 60
64267: PUSH
64268: EMPTY
64269: LIST
64270: PUSH
64271: EMPTY
64272: LIST
64273: LIST
64274: PUSH
64275: LD_INT 3
64277: PUSH
64278: LD_INT 55
64280: PUSH
64281: EMPTY
64282: LIST
64283: PUSH
64284: EMPTY
64285: LIST
64286: LIST
64287: PUSH
64288: EMPTY
64289: LIST
64290: LIST
64291: PPUSH
64292: CALL_OW 72
64296: IFFALSE 64404
// begin driver := UnitFilter ( cleaners , [ [ f_not , [ f_hastask ] ] , [ f_not , [ f_driving ] ] ] ) [ 1 ] ;
64298: LD_ADDR_VAR 0 18
64302: PUSH
64303: LD_VAR 0 6
64307: PPUSH
64308: LD_INT 3
64310: PUSH
64311: LD_INT 60
64313: PUSH
64314: EMPTY
64315: LIST
64316: PUSH
64317: EMPTY
64318: LIST
64319: LIST
64320: PUSH
64321: LD_INT 3
64323: PUSH
64324: LD_INT 55
64326: PUSH
64327: EMPTY
64328: LIST
64329: PUSH
64330: EMPTY
64331: LIST
64332: LIST
64333: PUSH
64334: EMPTY
64335: LIST
64336: LIST
64337: PPUSH
64338: CALL_OW 72
64342: PUSH
64343: LD_INT 1
64345: ARRAY
64346: ST_TO_ADDR
// if IsInUnit ( driver ) then
64347: LD_VAR 0 18
64351: PPUSH
64352: CALL_OW 310
64356: IFFALSE 64367
// ComExit ( driver ) ;
64358: LD_VAR 0 18
64362: PPUSH
64363: CALL 89100 0 1
// AddComEnterUnit ( driver , tmp ) ;
64367: LD_VAR 0 18
64371: PPUSH
64372: LD_VAR 0 13
64376: PPUSH
64377: CALL_OW 180
// AddComMoveToArea ( driver , parking ) ;
64381: LD_VAR 0 18
64385: PPUSH
64386: LD_VAR 0 7
64390: PPUSH
64391: CALL_OW 173
// AddComExitVehicle ( driver ) ;
64395: LD_VAR 0 18
64399: PPUSH
64400: CALL_OW 181
// end ; continue ;
64404: GO 64056
// end ; if not cleaners or not tmp in cleaners then
64406: LD_VAR 0 6
64410: NOT
64411: PUSH
64412: LD_VAR 0 13
64416: PUSH
64417: LD_VAR 0 6
64421: IN
64422: NOT
64423: OR
64424: IFFALSE 64731
// begin if dep then
64426: LD_VAR 0 17
64430: IFFALSE 64566
// begin xy := [ ShiftX ( GetX ( dep [ 1 ] ) , GetDir ( dep [ 1 ] ) , 5 ) , ShiftY ( GetY ( dep [ 1 ] ) , GetDir ( dep [ 1 ] ) , 5 ) ] ;
64432: LD_ADDR_VAR 0 16
64436: PUSH
64437: LD_VAR 0 17
64441: PUSH
64442: LD_INT 1
64444: ARRAY
64445: PPUSH
64446: CALL_OW 250
64450: PPUSH
64451: LD_VAR 0 17
64455: PUSH
64456: LD_INT 1
64458: ARRAY
64459: PPUSH
64460: CALL_OW 254
64464: PPUSH
64465: LD_INT 5
64467: PPUSH
64468: CALL_OW 272
64472: PUSH
64473: LD_VAR 0 17
64477: PUSH
64478: LD_INT 1
64480: ARRAY
64481: PPUSH
64482: CALL_OW 251
64486: PPUSH
64487: LD_VAR 0 17
64491: PUSH
64492: LD_INT 1
64494: ARRAY
64495: PPUSH
64496: CALL_OW 254
64500: PPUSH
64501: LD_INT 5
64503: PPUSH
64504: CALL_OW 273
64508: PUSH
64509: EMPTY
64510: LIST
64511: LIST
64512: ST_TO_ADDR
// if ValidHex ( xy [ 1 ] , xy [ 2 ] ) then
64513: LD_VAR 0 16
64517: PUSH
64518: LD_INT 1
64520: ARRAY
64521: PPUSH
64522: LD_VAR 0 16
64526: PUSH
64527: LD_INT 2
64529: ARRAY
64530: PPUSH
64531: CALL_OW 488
64535: IFFALSE 64566
// begin ComMoveXY ( tmp , xy [ 1 ] , xy [ 2 ] ) ;
64537: LD_VAR 0 13
64541: PPUSH
64542: LD_VAR 0 16
64546: PUSH
64547: LD_INT 1
64549: ARRAY
64550: PPUSH
64551: LD_VAR 0 16
64555: PUSH
64556: LD_INT 2
64558: ARRAY
64559: PPUSH
64560: CALL_OW 111
// continue ;
64564: GO 64056
// end ; end ; r := GetDir ( tmp ) ;
64566: LD_ADDR_VAR 0 15
64570: PUSH
64571: LD_VAR 0 13
64575: PPUSH
64576: CALL_OW 254
64580: ST_TO_ADDR
// if r = 5 then
64581: LD_VAR 0 15
64585: PUSH
64586: LD_INT 5
64588: EQUAL
64589: IFFALSE 64599
// r := 0 ;
64591: LD_ADDR_VAR 0 15
64595: PUSH
64596: LD_INT 0
64598: ST_TO_ADDR
// for j = r to 5 do
64599: LD_ADDR_VAR 0 10
64603: PUSH
64604: DOUBLE
64605: LD_VAR 0 15
64609: DEC
64610: ST_TO_ADDR
64611: LD_INT 5
64613: PUSH
64614: FOR_TO
64615: IFFALSE 64729
// begin _x := ShiftX ( GetX ( tmp ) , j , 2 ) ;
64617: LD_ADDR_VAR 0 11
64621: PUSH
64622: LD_VAR 0 13
64626: PPUSH
64627: CALL_OW 250
64631: PPUSH
64632: LD_VAR 0 10
64636: PPUSH
64637: LD_INT 2
64639: PPUSH
64640: CALL_OW 272
64644: ST_TO_ADDR
// _y := ShiftY ( GetY ( tmp ) , j , 2 ) ;
64645: LD_ADDR_VAR 0 12
64649: PUSH
64650: LD_VAR 0 13
64654: PPUSH
64655: CALL_OW 251
64659: PPUSH
64660: LD_VAR 0 10
64664: PPUSH
64665: LD_INT 2
64667: PPUSH
64668: CALL_OW 273
64672: ST_TO_ADDR
// if ValidHex ( _x , _y ) and not HexInfo ( _x , _y ) then
64673: LD_VAR 0 11
64677: PPUSH
64678: LD_VAR 0 12
64682: PPUSH
64683: CALL_OW 488
64687: PUSH
64688: LD_VAR 0 11
64692: PPUSH
64693: LD_VAR 0 12
64697: PPUSH
64698: CALL_OW 428
64702: NOT
64703: AND
64704: IFFALSE 64727
// begin ComMoveXY ( tmp , _x , _y ) ;
64706: LD_VAR 0 13
64710: PPUSH
64711: LD_VAR 0 11
64715: PPUSH
64716: LD_VAR 0 12
64720: PPUSH
64721: CALL_OW 111
// break ;
64725: GO 64729
// end ; end ;
64727: GO 64614
64729: POP
64730: POP
// end ; end ;
64731: GO 64056
64733: POP
64734: POP
// end ;
64735: LD_VAR 0 8
64739: RET
// export function BuildingTechInvented ( side , btype ) ; begin
64740: LD_INT 0
64742: PPUSH
// result := true ;
64743: LD_ADDR_VAR 0 3
64747: PUSH
64748: LD_INT 1
64750: ST_TO_ADDR
// case btype of b_ext_computer , b_turret :
64751: LD_VAR 0 2
64755: PUSH
64756: LD_INT 24
64758: DOUBLE
64759: EQUAL
64760: IFTRUE 64770
64762: LD_INT 33
64764: DOUBLE
64765: EQUAL
64766: IFTRUE 64770
64768: GO 64795
64770: POP
// result := ( GetTech ( tech_ai , side ) = state_researched ) ; b_ext_radar :
64771: LD_ADDR_VAR 0 3
64775: PUSH
64776: LD_INT 32
64778: PPUSH
64779: LD_VAR 0 1
64783: PPUSH
64784: CALL_OW 321
64788: PUSH
64789: LD_INT 2
64791: EQUAL
64792: ST_TO_ADDR
64793: GO 65115
64795: LD_INT 20
64797: DOUBLE
64798: EQUAL
64799: IFTRUE 64803
64801: GO 64828
64803: POP
// result := ( GetTech ( tech_radar , side ) = state_researched ) ; b_ext_radio , b_control_tower :
64804: LD_ADDR_VAR 0 3
64808: PUSH
64809: LD_INT 6
64811: PPUSH
64812: LD_VAR 0 1
64816: PPUSH
64817: CALL_OW 321
64821: PUSH
64822: LD_INT 2
64824: EQUAL
64825: ST_TO_ADDR
64826: GO 65115
64828: LD_INT 22
64830: DOUBLE
64831: EQUAL
64832: IFTRUE 64842
64834: LD_INT 36
64836: DOUBLE
64837: EQUAL
64838: IFTRUE 64842
64840: GO 64867
64842: POP
// result := ( GetTech ( tech_remcont , side ) = state_researched ) ; b_siberite_mine :
64843: LD_ADDR_VAR 0 3
64847: PUSH
64848: LD_INT 15
64850: PPUSH
64851: LD_VAR 0 1
64855: PPUSH
64856: CALL_OW 321
64860: PUSH
64861: LD_INT 2
64863: EQUAL
64864: ST_TO_ADDR
64865: GO 65115
64867: LD_INT 30
64869: DOUBLE
64870: EQUAL
64871: IFTRUE 64875
64873: GO 64900
64875: POP
// result := ( GetTech ( tech_sibdet , side ) = state_researched ) ; b_siberite_power , b_ext_siberium :
64876: LD_ADDR_VAR 0 3
64880: PUSH
64881: LD_INT 20
64883: PPUSH
64884: LD_VAR 0 1
64888: PPUSH
64889: CALL_OW 321
64893: PUSH
64894: LD_INT 2
64896: EQUAL
64897: ST_TO_ADDR
64898: GO 65115
64900: LD_INT 28
64902: DOUBLE
64903: EQUAL
64904: IFTRUE 64914
64906: LD_INT 21
64908: DOUBLE
64909: EQUAL
64910: IFTRUE 64914
64912: GO 64939
64914: POP
// result := ( GetTech ( tech_sibpow , side ) = state_researched ) ; b_ext_track :
64915: LD_ADDR_VAR 0 3
64919: PUSH
64920: LD_INT 21
64922: PPUSH
64923: LD_VAR 0 1
64927: PPUSH
64928: CALL_OW 321
64932: PUSH
64933: LD_INT 2
64935: EQUAL
64936: ST_TO_ADDR
64937: GO 65115
64939: LD_INT 16
64941: DOUBLE
64942: EQUAL
64943: IFTRUE 64947
64945: GO 64974
64947: POP
// result := ( GetTech ( tech_track , side ) = state_researched ) ; b_ext_noncombat , b_ext_stitch :
64948: LD_ADDR_VAR 0 3
64952: PUSH
64953: LD_EXP 86
64957: PPUSH
64958: LD_VAR 0 1
64962: PPUSH
64963: CALL_OW 321
64967: PUSH
64968: LD_INT 2
64970: EQUAL
64971: ST_TO_ADDR
64972: GO 65115
64974: LD_INT 19
64976: DOUBLE
64977: EQUAL
64978: IFTRUE 64988
64980: LD_INT 23
64982: DOUBLE
64983: EQUAL
64984: IFTRUE 64988
64986: GO 65015
64988: POP
// result := ( GetTech ( tech_cargo , side ) = state_researched ) ; b_ext_gun :
64989: LD_ADDR_VAR 0 3
64993: PUSH
64994: LD_EXP 85
64998: PPUSH
64999: LD_VAR 0 1
65003: PPUSH
65004: CALL_OW 321
65008: PUSH
65009: LD_INT 2
65011: EQUAL
65012: ST_TO_ADDR
65013: GO 65115
65015: LD_INT 17
65017: DOUBLE
65018: EQUAL
65019: IFTRUE 65023
65021: GO 65048
65023: POP
// result := ( GetTech ( tech_gun , side ) = state_researched ) ; b_ext_rocket :
65024: LD_ADDR_VAR 0 3
65028: PUSH
65029: LD_INT 39
65031: PPUSH
65032: LD_VAR 0 1
65036: PPUSH
65037: CALL_OW 321
65041: PUSH
65042: LD_INT 2
65044: EQUAL
65045: ST_TO_ADDR
65046: GO 65115
65048: LD_INT 18
65050: DOUBLE
65051: EQUAL
65052: IFTRUE 65056
65054: GO 65081
65056: POP
// result := ( GetTech ( tech_rocket , side ) = state_researched ) ; b_solar_power :
65057: LD_ADDR_VAR 0 3
65061: PUSH
65062: LD_INT 40
65064: PPUSH
65065: LD_VAR 0 1
65069: PPUSH
65070: CALL_OW 321
65074: PUSH
65075: LD_INT 2
65077: EQUAL
65078: ST_TO_ADDR
65079: GO 65115
65081: LD_INT 27
65083: DOUBLE
65084: EQUAL
65085: IFTRUE 65089
65087: GO 65114
65089: POP
// result := ( GetTech ( tech_solpow , side ) = state_researched ) ; end ;
65090: LD_ADDR_VAR 0 3
65094: PUSH
65095: LD_INT 35
65097: PPUSH
65098: LD_VAR 0 1
65102: PPUSH
65103: CALL_OW 321
65107: PUSH
65108: LD_INT 2
65110: EQUAL
65111: ST_TO_ADDR
65112: GO 65115
65114: POP
// end ;
65115: LD_VAR 0 3
65119: RET
// export function CanBeBuilt ( depot , btype , x , y , d ) ; var i , j , side , pom , cost , hexes , height , dist , hex , tech ; begin
65120: LD_INT 0
65122: PPUSH
65123: PPUSH
65124: PPUSH
65125: PPUSH
65126: PPUSH
65127: PPUSH
65128: PPUSH
65129: PPUSH
65130: PPUSH
65131: PPUSH
65132: PPUSH
// result := false ;
65133: LD_ADDR_VAR 0 6
65137: PUSH
65138: LD_INT 0
65140: ST_TO_ADDR
// if not depot or not GetBType ( depot ) in [ b_depot , b_warehouse ] or not btype or not d in [ 0 , 1 , 2 , 3 , 4 , 5 ] or not ValidHex ( x , y ) then
65141: LD_VAR 0 1
65145: NOT
65146: PUSH
65147: LD_VAR 0 1
65151: PPUSH
65152: CALL_OW 266
65156: PUSH
65157: LD_INT 0
65159: PUSH
65160: LD_INT 1
65162: PUSH
65163: EMPTY
65164: LIST
65165: LIST
65166: IN
65167: NOT
65168: OR
65169: PUSH
65170: LD_VAR 0 2
65174: NOT
65175: OR
65176: PUSH
65177: LD_VAR 0 5
65181: PUSH
65182: LD_INT 0
65184: PUSH
65185: LD_INT 1
65187: PUSH
65188: LD_INT 2
65190: PUSH
65191: LD_INT 3
65193: PUSH
65194: LD_INT 4
65196: PUSH
65197: LD_INT 5
65199: PUSH
65200: EMPTY
65201: LIST
65202: LIST
65203: LIST
65204: LIST
65205: LIST
65206: LIST
65207: IN
65208: NOT
65209: OR
65210: PUSH
65211: LD_VAR 0 3
65215: PPUSH
65216: LD_VAR 0 4
65220: PPUSH
65221: CALL_OW 488
65225: NOT
65226: OR
65227: IFFALSE 65231
// exit ;
65229: GO 65967
// side := GetSide ( depot ) ;
65231: LD_ADDR_VAR 0 9
65235: PUSH
65236: LD_VAR 0 1
65240: PPUSH
65241: CALL_OW 255
65245: ST_TO_ADDR
// if not BuildingTechInvented ( side , btype ) then
65246: LD_VAR 0 9
65250: PPUSH
65251: LD_VAR 0 2
65255: PPUSH
65256: CALL 64740 0 2
65260: NOT
65261: IFFALSE 65265
// exit ;
65263: GO 65967
// pom := GetBase ( depot ) ;
65265: LD_ADDR_VAR 0 10
65269: PUSH
65270: LD_VAR 0 1
65274: PPUSH
65275: CALL_OW 274
65279: ST_TO_ADDR
// cost := CostOfBuilding ( btype , GetNation ( depot ) ) ;
65280: LD_ADDR_VAR 0 11
65284: PUSH
65285: LD_VAR 0 2
65289: PPUSH
65290: LD_VAR 0 1
65294: PPUSH
65295: CALL_OW 248
65299: PPUSH
65300: CALL_OW 450
65304: ST_TO_ADDR
// if not ( GetResourceType ( pom , mat_cans ) >= cost [ 1 ] and GetResourceType ( pom , mat_oil ) >= cost [ 2 ] and GetResourceType ( pom , mat_siberit ) >= cost [ 3 ] ) then
65305: LD_VAR 0 10
65309: PPUSH
65310: LD_INT 1
65312: PPUSH
65313: CALL_OW 275
65317: PUSH
65318: LD_VAR 0 11
65322: PUSH
65323: LD_INT 1
65325: ARRAY
65326: GREATEREQUAL
65327: PUSH
65328: LD_VAR 0 10
65332: PPUSH
65333: LD_INT 2
65335: PPUSH
65336: CALL_OW 275
65340: PUSH
65341: LD_VAR 0 11
65345: PUSH
65346: LD_INT 2
65348: ARRAY
65349: GREATEREQUAL
65350: AND
65351: PUSH
65352: LD_VAR 0 10
65356: PPUSH
65357: LD_INT 3
65359: PPUSH
65360: CALL_OW 275
65364: PUSH
65365: LD_VAR 0 11
65369: PUSH
65370: LD_INT 3
65372: ARRAY
65373: GREATEREQUAL
65374: AND
65375: NOT
65376: IFFALSE 65380
// exit ;
65378: GO 65967
// if GetBType ( depot ) = b_depot then
65380: LD_VAR 0 1
65384: PPUSH
65385: CALL_OW 266
65389: PUSH
65390: LD_INT 0
65392: EQUAL
65393: IFFALSE 65405
// dist := 28 else
65395: LD_ADDR_VAR 0 14
65399: PUSH
65400: LD_INT 28
65402: ST_TO_ADDR
65403: GO 65413
// dist := 36 ;
65405: LD_ADDR_VAR 0 14
65409: PUSH
65410: LD_INT 36
65412: ST_TO_ADDR
// if GetDistUnitXY ( depot , x , y ) > dist then
65413: LD_VAR 0 1
65417: PPUSH
65418: LD_VAR 0 3
65422: PPUSH
65423: LD_VAR 0 4
65427: PPUSH
65428: CALL_OW 297
65432: PUSH
65433: LD_VAR 0 14
65437: GREATER
65438: IFFALSE 65442
// exit ;
65440: GO 65967
// hexes := GetBuildingHexes ( btype , x , y , d , GetNation ( depot ) , 0 ) ;
65442: LD_ADDR_VAR 0 12
65446: PUSH
65447: LD_VAR 0 2
65451: PPUSH
65452: LD_VAR 0 3
65456: PPUSH
65457: LD_VAR 0 4
65461: PPUSH
65462: LD_VAR 0 5
65466: PPUSH
65467: LD_VAR 0 1
65471: PPUSH
65472: CALL_OW 248
65476: PPUSH
65477: LD_INT 0
65479: PPUSH
65480: CALL 65972 0 6
65484: ST_TO_ADDR
// if not hexes then
65485: LD_VAR 0 12
65489: NOT
65490: IFFALSE 65494
// exit ;
65492: GO 65967
// hex := GetHexInfo ( x , y ) ;
65494: LD_ADDR_VAR 0 15
65498: PUSH
65499: LD_VAR 0 3
65503: PPUSH
65504: LD_VAR 0 4
65508: PPUSH
65509: CALL_OW 546
65513: ST_TO_ADDR
// if hex [ 1 ] then
65514: LD_VAR 0 15
65518: PUSH
65519: LD_INT 1
65521: ARRAY
65522: IFFALSE 65526
// exit ;
65524: GO 65967
// height := hex [ 2 ] ;
65526: LD_ADDR_VAR 0 13
65530: PUSH
65531: LD_VAR 0 15
65535: PUSH
65536: LD_INT 2
65538: ARRAY
65539: ST_TO_ADDR
// for i = 1 to hexes do
65540: LD_ADDR_VAR 0 7
65544: PUSH
65545: DOUBLE
65546: LD_INT 1
65548: DEC
65549: ST_TO_ADDR
65550: LD_VAR 0 12
65554: PUSH
65555: FOR_TO
65556: IFFALSE 65886
// begin if not ValidHex ( hexes [ i ] [ 1 ] , hexes [ i ] [ 2 ] ) or HexInfo ( hexes [ i ] [ 1 ] , hexes [ i ] [ 2 ] ) > 0 or IsEnvironment ( hexes [ i ] [ 1 ] , hexes [ i ] [ 2 ] ) then
65558: LD_VAR 0 12
65562: PUSH
65563: LD_VAR 0 7
65567: ARRAY
65568: PUSH
65569: LD_INT 1
65571: ARRAY
65572: PPUSH
65573: LD_VAR 0 12
65577: PUSH
65578: LD_VAR 0 7
65582: ARRAY
65583: PUSH
65584: LD_INT 2
65586: ARRAY
65587: PPUSH
65588: CALL_OW 488
65592: NOT
65593: PUSH
65594: LD_VAR 0 12
65598: PUSH
65599: LD_VAR 0 7
65603: ARRAY
65604: PUSH
65605: LD_INT 1
65607: ARRAY
65608: PPUSH
65609: LD_VAR 0 12
65613: PUSH
65614: LD_VAR 0 7
65618: ARRAY
65619: PUSH
65620: LD_INT 2
65622: ARRAY
65623: PPUSH
65624: CALL_OW 428
65628: PUSH
65629: LD_INT 0
65631: GREATER
65632: OR
65633: PUSH
65634: LD_VAR 0 12
65638: PUSH
65639: LD_VAR 0 7
65643: ARRAY
65644: PUSH
65645: LD_INT 1
65647: ARRAY
65648: PPUSH
65649: LD_VAR 0 12
65653: PUSH
65654: LD_VAR 0 7
65658: ARRAY
65659: PUSH
65660: LD_INT 2
65662: ARRAY
65663: PPUSH
65664: CALL_OW 351
65668: OR
65669: IFFALSE 65675
// exit ;
65671: POP
65672: POP
65673: GO 65967
// j := GetHexInfo ( hexes [ i ] [ 1 ] , hexes [ i ] [ 2 ] ) ;
65675: LD_ADDR_VAR 0 8
65679: PUSH
65680: LD_VAR 0 12
65684: PUSH
65685: LD_VAR 0 7
65689: ARRAY
65690: PUSH
65691: LD_INT 1
65693: ARRAY
65694: PPUSH
65695: LD_VAR 0 12
65699: PUSH
65700: LD_VAR 0 7
65704: ARRAY
65705: PUSH
65706: LD_INT 2
65708: ARRAY
65709: PPUSH
65710: CALL_OW 546
65714: ST_TO_ADDR
// if j [ 1 ] or j [ 2 ] > height + 2 or j [ 2 ] < height - 2 or not j [ 3 ] in [ 0 , 8 , 9 , 10 , 11 , 12 , 13 , 16 , 17 , 18 , 19 , 20 , 21 ] or not j [ 5 ] or not j [ 6 ] in [ 1 , 2 , 7 , 9 , 10 , 11 ] then
65715: LD_VAR 0 8
65719: PUSH
65720: LD_INT 1
65722: ARRAY
65723: PUSH
65724: LD_VAR 0 8
65728: PUSH
65729: LD_INT 2
65731: ARRAY
65732: PUSH
65733: LD_VAR 0 13
65737: PUSH
65738: LD_INT 2
65740: PLUS
65741: GREATER
65742: OR
65743: PUSH
65744: LD_VAR 0 8
65748: PUSH
65749: LD_INT 2
65751: ARRAY
65752: PUSH
65753: LD_VAR 0 13
65757: PUSH
65758: LD_INT 2
65760: MINUS
65761: LESS
65762: OR
65763: PUSH
65764: LD_VAR 0 8
65768: PUSH
65769: LD_INT 3
65771: ARRAY
65772: PUSH
65773: LD_INT 0
65775: PUSH
65776: LD_INT 8
65778: PUSH
65779: LD_INT 9
65781: PUSH
65782: LD_INT 10
65784: PUSH
65785: LD_INT 11
65787: PUSH
65788: LD_INT 12
65790: PUSH
65791: LD_INT 13
65793: PUSH
65794: LD_INT 16
65796: PUSH
65797: LD_INT 17
65799: PUSH
65800: LD_INT 18
65802: PUSH
65803: LD_INT 19
65805: PUSH
65806: LD_INT 20
65808: PUSH
65809: LD_INT 21
65811: PUSH
65812: EMPTY
65813: LIST
65814: LIST
65815: LIST
65816: LIST
65817: LIST
65818: LIST
65819: LIST
65820: LIST
65821: LIST
65822: LIST
65823: LIST
65824: LIST
65825: LIST
65826: IN
65827: NOT
65828: OR
65829: PUSH
65830: LD_VAR 0 8
65834: PUSH
65835: LD_INT 5
65837: ARRAY
65838: NOT
65839: OR
65840: PUSH
65841: LD_VAR 0 8
65845: PUSH
65846: LD_INT 6
65848: ARRAY
65849: PUSH
65850: LD_INT 1
65852: PUSH
65853: LD_INT 2
65855: PUSH
65856: LD_INT 7
65858: PUSH
65859: LD_INT 9
65861: PUSH
65862: LD_INT 10
65864: PUSH
65865: LD_INT 11
65867: PUSH
65868: EMPTY
65869: LIST
65870: LIST
65871: LIST
65872: LIST
65873: LIST
65874: LIST
65875: IN
65876: NOT
65877: OR
65878: IFFALSE 65884
// exit ;
65880: POP
65881: POP
65882: GO 65967
// end ;
65884: GO 65555
65886: POP
65887: POP
// if DangerAtRangeXY ( side , x , y , 20 ) [ 4 ] then
65888: LD_VAR 0 9
65892: PPUSH
65893: LD_VAR 0 3
65897: PPUSH
65898: LD_VAR 0 4
65902: PPUSH
65903: LD_INT 20
65905: PPUSH
65906: CALL 57913 0 4
65910: PUSH
65911: LD_INT 4
65913: ARRAY
65914: IFFALSE 65918
// exit ;
65916: GO 65967
// if btype in [ b_oil_mine , b_siberite_mine ] and not GetResourceVisibility ( x , y , side ) then
65918: LD_VAR 0 2
65922: PUSH
65923: LD_INT 29
65925: PUSH
65926: LD_INT 30
65928: PUSH
65929: EMPTY
65930: LIST
65931: LIST
65932: IN
65933: PUSH
65934: LD_VAR 0 3
65938: PPUSH
65939: LD_VAR 0 4
65943: PPUSH
65944: LD_VAR 0 9
65948: PPUSH
65949: CALL_OW 440
65953: NOT
65954: AND
65955: IFFALSE 65959
// exit ;
65957: GO 65967
// result := true ;
65959: LD_ADDR_VAR 0 6
65963: PUSH
65964: LD_INT 1
65966: ST_TO_ADDR
// end ;
65967: LD_VAR 0 6
65971: RET
// export function GetBuildingHexes ( btype , x , y , dir , nation , mode ) ; var i , temp_list , temp_list2 ; var fDepotAm0 , fDepotAm1 , fDepotAm2 , fDepotAm3 , fDepotAm4 , fDepotAm5 , fDepotAr0 , fDepotAr1 , fDepotAr2 , fDepotAr3 , fDepotAr4 , fDepotAr5 , fDepotRu0 , fDepotRu1 , fDepotRu2 , fDepotRu3 , fDepotRu4 , fDepotRu5 ; var fFactory0 , fFactory1 , fFactory2 , fFactory3 , fFactory4 , fFactory5 , fExt0 , fExt1 , fExt2 , fExt3 , fExt4 , fExt5 ; var fLab0 , fLab1 , fLab2 , fLab3 , fLab4 , fLab5 , fControlTower0 , fControlTower1 , fControlTower2 , fControlTower3 , fControlTower4 , fControlTower5 ; var fBarracks0 , fBarracks1 , fBarracks2 , fBarracks3 , fBarracks4 , fBarracks5 , fBunker0 , fBunker1 , fBunker2 , fBunker3 , fBunker4 , fBunker5 ; begin
65972: LD_INT 0
65974: PPUSH
65975: PPUSH
65976: PPUSH
65977: PPUSH
65978: PPUSH
65979: PPUSH
65980: PPUSH
65981: PPUSH
65982: PPUSH
65983: PPUSH
65984: PPUSH
65985: PPUSH
65986: PPUSH
65987: PPUSH
65988: PPUSH
65989: PPUSH
65990: PPUSH
65991: PPUSH
65992: PPUSH
65993: PPUSH
65994: PPUSH
65995: PPUSH
65996: PPUSH
65997: PPUSH
65998: PPUSH
65999: PPUSH
66000: PPUSH
66001: PPUSH
66002: PPUSH
66003: PPUSH
66004: PPUSH
66005: PPUSH
66006: PPUSH
66007: PPUSH
66008: PPUSH
66009: PPUSH
66010: PPUSH
66011: PPUSH
66012: PPUSH
66013: PPUSH
66014: PPUSH
66015: PPUSH
66016: PPUSH
66017: PPUSH
66018: PPUSH
66019: PPUSH
66020: PPUSH
66021: PPUSH
66022: PPUSH
66023: PPUSH
66024: PPUSH
66025: PPUSH
66026: PPUSH
66027: PPUSH
66028: PPUSH
66029: PPUSH
66030: PPUSH
66031: PPUSH
// result = [ ] ;
66032: LD_ADDR_VAR 0 7
66036: PUSH
66037: EMPTY
66038: ST_TO_ADDR
// temp_list = [ ] ;
66039: LD_ADDR_VAR 0 9
66043: PUSH
66044: EMPTY
66045: ST_TO_ADDR
// if not dir in [ 0 , 1 , 2 , 3 , 4 , 5 ] or ( btype in [ b_depot , b_warehouse ] and not nation in [ nation_american , nation_arabian , nation_russian ] ) then
66046: LD_VAR 0 4
66050: PUSH
66051: LD_INT 0
66053: PUSH
66054: LD_INT 1
66056: PUSH
66057: LD_INT 2
66059: PUSH
66060: LD_INT 3
66062: PUSH
66063: LD_INT 4
66065: PUSH
66066: LD_INT 5
66068: PUSH
66069: EMPTY
66070: LIST
66071: LIST
66072: LIST
66073: LIST
66074: LIST
66075: LIST
66076: IN
66077: NOT
66078: PUSH
66079: LD_VAR 0 1
66083: PUSH
66084: LD_INT 0
66086: PUSH
66087: LD_INT 1
66089: PUSH
66090: EMPTY
66091: LIST
66092: LIST
66093: IN
66094: PUSH
66095: LD_VAR 0 5
66099: PUSH
66100: LD_INT 1
66102: PUSH
66103: LD_INT 2
66105: PUSH
66106: LD_INT 3
66108: PUSH
66109: EMPTY
66110: LIST
66111: LIST
66112: LIST
66113: IN
66114: NOT
66115: AND
66116: OR
66117: IFFALSE 66121
// exit ;
66119: GO 84512
// if btype in [ b_lab , b_lab_half , b_lab_full , b_lab_biological , b_lab_computer , b_lab_opto , b_lab_siberium , b_lab_spacetime , b_lab_weapon ] then
66121: LD_VAR 0 1
66125: PUSH
66126: LD_INT 6
66128: PUSH
66129: LD_INT 7
66131: PUSH
66132: LD_INT 8
66134: PUSH
66135: LD_INT 13
66137: PUSH
66138: LD_INT 12
66140: PUSH
66141: LD_INT 15
66143: PUSH
66144: LD_INT 11
66146: PUSH
66147: LD_INT 14
66149: PUSH
66150: LD_INT 10
66152: PUSH
66153: EMPTY
66154: LIST
66155: LIST
66156: LIST
66157: LIST
66158: LIST
66159: LIST
66160: LIST
66161: LIST
66162: LIST
66163: IN
66164: IFFALSE 66174
// btype = b_lab ;
66166: LD_ADDR_VAR 0 1
66170: PUSH
66171: LD_INT 6
66173: ST_TO_ADDR
// if not mode in [ 0 , 1 , 2 ] or ( not btype in [ b_depot , b_warehouse , b_workshop , b_factory , b_lab , b_control_tower , b_armoury , b_barracks , b_breastwork , b_bunker , b_turret ] and mode = 1 ) or ( not btype in [ b_workshop , b_factory ] and mode = 2 ) then
66174: LD_VAR 0 6
66178: PUSH
66179: LD_INT 0
66181: PUSH
66182: LD_INT 1
66184: PUSH
66185: LD_INT 2
66187: PUSH
66188: EMPTY
66189: LIST
66190: LIST
66191: LIST
66192: IN
66193: NOT
66194: PUSH
66195: LD_VAR 0 1
66199: PUSH
66200: LD_INT 0
66202: PUSH
66203: LD_INT 1
66205: PUSH
66206: LD_INT 2
66208: PUSH
66209: LD_INT 3
66211: PUSH
66212: LD_INT 6
66214: PUSH
66215: LD_INT 36
66217: PUSH
66218: LD_INT 4
66220: PUSH
66221: LD_INT 5
66223: PUSH
66224: LD_INT 31
66226: PUSH
66227: LD_INT 32
66229: PUSH
66230: LD_INT 33
66232: PUSH
66233: EMPTY
66234: LIST
66235: LIST
66236: LIST
66237: LIST
66238: LIST
66239: LIST
66240: LIST
66241: LIST
66242: LIST
66243: LIST
66244: LIST
66245: IN
66246: NOT
66247: PUSH
66248: LD_VAR 0 6
66252: PUSH
66253: LD_INT 1
66255: EQUAL
66256: AND
66257: OR
66258: PUSH
66259: LD_VAR 0 1
66263: PUSH
66264: LD_INT 2
66266: PUSH
66267: LD_INT 3
66269: PUSH
66270: EMPTY
66271: LIST
66272: LIST
66273: IN
66274: NOT
66275: PUSH
66276: LD_VAR 0 6
66280: PUSH
66281: LD_INT 2
66283: EQUAL
66284: AND
66285: OR
66286: IFFALSE 66296
// mode = 0 ;
66288: LD_ADDR_VAR 0 6
66292: PUSH
66293: LD_INT 0
66295: ST_TO_ADDR
// case mode of 0 :
66296: LD_VAR 0 6
66300: PUSH
66301: LD_INT 0
66303: DOUBLE
66304: EQUAL
66305: IFTRUE 66309
66307: GO 77762
66309: POP
// begin fDepotAm0 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ 1 , 3 ] , [ 0 , 3 ] , [ - 1 , 2 ] ] ;
66310: LD_ADDR_VAR 0 11
66314: PUSH
66315: LD_INT 0
66317: PUSH
66318: LD_INT 0
66320: PUSH
66321: EMPTY
66322: LIST
66323: LIST
66324: PUSH
66325: LD_INT 0
66327: PUSH
66328: LD_INT 1
66330: NEG
66331: PUSH
66332: EMPTY
66333: LIST
66334: LIST
66335: PUSH
66336: LD_INT 1
66338: PUSH
66339: LD_INT 0
66341: PUSH
66342: EMPTY
66343: LIST
66344: LIST
66345: PUSH
66346: LD_INT 1
66348: PUSH
66349: LD_INT 1
66351: PUSH
66352: EMPTY
66353: LIST
66354: LIST
66355: PUSH
66356: LD_INT 0
66358: PUSH
66359: LD_INT 1
66361: PUSH
66362: EMPTY
66363: LIST
66364: LIST
66365: PUSH
66366: LD_INT 1
66368: NEG
66369: PUSH
66370: LD_INT 0
66372: PUSH
66373: EMPTY
66374: LIST
66375: LIST
66376: PUSH
66377: LD_INT 1
66379: NEG
66380: PUSH
66381: LD_INT 1
66383: NEG
66384: PUSH
66385: EMPTY
66386: LIST
66387: LIST
66388: PUSH
66389: LD_INT 1
66391: NEG
66392: PUSH
66393: LD_INT 2
66395: NEG
66396: PUSH
66397: EMPTY
66398: LIST
66399: LIST
66400: PUSH
66401: LD_INT 0
66403: PUSH
66404: LD_INT 2
66406: NEG
66407: PUSH
66408: EMPTY
66409: LIST
66410: LIST
66411: PUSH
66412: LD_INT 1
66414: PUSH
66415: LD_INT 1
66417: NEG
66418: PUSH
66419: EMPTY
66420: LIST
66421: LIST
66422: PUSH
66423: LD_INT 1
66425: PUSH
66426: LD_INT 2
66428: PUSH
66429: EMPTY
66430: LIST
66431: LIST
66432: PUSH
66433: LD_INT 0
66435: PUSH
66436: LD_INT 2
66438: PUSH
66439: EMPTY
66440: LIST
66441: LIST
66442: PUSH
66443: LD_INT 1
66445: NEG
66446: PUSH
66447: LD_INT 1
66449: PUSH
66450: EMPTY
66451: LIST
66452: LIST
66453: PUSH
66454: LD_INT 1
66456: PUSH
66457: LD_INT 3
66459: PUSH
66460: EMPTY
66461: LIST
66462: LIST
66463: PUSH
66464: LD_INT 0
66466: PUSH
66467: LD_INT 3
66469: PUSH
66470: EMPTY
66471: LIST
66472: LIST
66473: PUSH
66474: LD_INT 1
66476: NEG
66477: PUSH
66478: LD_INT 2
66480: PUSH
66481: EMPTY
66482: LIST
66483: LIST
66484: PUSH
66485: EMPTY
66486: LIST
66487: LIST
66488: LIST
66489: LIST
66490: LIST
66491: LIST
66492: LIST
66493: LIST
66494: LIST
66495: LIST
66496: LIST
66497: LIST
66498: LIST
66499: LIST
66500: LIST
66501: LIST
66502: ST_TO_ADDR
// fDepotAm1 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , 1 ] , [ - 3 , 0 ] , [ - 3 , - 1 ] ] ;
66503: LD_ADDR_VAR 0 12
66507: PUSH
66508: LD_INT 0
66510: PUSH
66511: LD_INT 0
66513: PUSH
66514: EMPTY
66515: LIST
66516: LIST
66517: PUSH
66518: LD_INT 0
66520: PUSH
66521: LD_INT 1
66523: NEG
66524: PUSH
66525: EMPTY
66526: LIST
66527: LIST
66528: PUSH
66529: LD_INT 1
66531: PUSH
66532: LD_INT 0
66534: PUSH
66535: EMPTY
66536: LIST
66537: LIST
66538: PUSH
66539: LD_INT 1
66541: PUSH
66542: LD_INT 1
66544: PUSH
66545: EMPTY
66546: LIST
66547: LIST
66548: PUSH
66549: LD_INT 0
66551: PUSH
66552: LD_INT 1
66554: PUSH
66555: EMPTY
66556: LIST
66557: LIST
66558: PUSH
66559: LD_INT 1
66561: NEG
66562: PUSH
66563: LD_INT 0
66565: PUSH
66566: EMPTY
66567: LIST
66568: LIST
66569: PUSH
66570: LD_INT 1
66572: NEG
66573: PUSH
66574: LD_INT 1
66576: NEG
66577: PUSH
66578: EMPTY
66579: LIST
66580: LIST
66581: PUSH
66582: LD_INT 1
66584: PUSH
66585: LD_INT 1
66587: NEG
66588: PUSH
66589: EMPTY
66590: LIST
66591: LIST
66592: PUSH
66593: LD_INT 2
66595: PUSH
66596: LD_INT 0
66598: PUSH
66599: EMPTY
66600: LIST
66601: LIST
66602: PUSH
66603: LD_INT 2
66605: PUSH
66606: LD_INT 1
66608: PUSH
66609: EMPTY
66610: LIST
66611: LIST
66612: PUSH
66613: LD_INT 1
66615: NEG
66616: PUSH
66617: LD_INT 1
66619: PUSH
66620: EMPTY
66621: LIST
66622: LIST
66623: PUSH
66624: LD_INT 2
66626: NEG
66627: PUSH
66628: LD_INT 0
66630: PUSH
66631: EMPTY
66632: LIST
66633: LIST
66634: PUSH
66635: LD_INT 2
66637: NEG
66638: PUSH
66639: LD_INT 1
66641: NEG
66642: PUSH
66643: EMPTY
66644: LIST
66645: LIST
66646: PUSH
66647: LD_INT 2
66649: NEG
66650: PUSH
66651: LD_INT 1
66653: PUSH
66654: EMPTY
66655: LIST
66656: LIST
66657: PUSH
66658: LD_INT 3
66660: NEG
66661: PUSH
66662: LD_INT 0
66664: PUSH
66665: EMPTY
66666: LIST
66667: LIST
66668: PUSH
66669: LD_INT 3
66671: NEG
66672: PUSH
66673: LD_INT 1
66675: NEG
66676: PUSH
66677: EMPTY
66678: LIST
66679: LIST
66680: PUSH
66681: EMPTY
66682: LIST
66683: LIST
66684: LIST
66685: LIST
66686: LIST
66687: LIST
66688: LIST
66689: LIST
66690: LIST
66691: LIST
66692: LIST
66693: LIST
66694: LIST
66695: LIST
66696: LIST
66697: LIST
66698: ST_TO_ADDR
// fDepotAm2 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ - 2 , - 3 ] , [ - 3 , - 2 ] , [ - 3 , - 3 ] ] ;
66699: LD_ADDR_VAR 0 13
66703: PUSH
66704: LD_INT 0
66706: PUSH
66707: LD_INT 0
66709: PUSH
66710: EMPTY
66711: LIST
66712: LIST
66713: PUSH
66714: LD_INT 0
66716: PUSH
66717: LD_INT 1
66719: NEG
66720: PUSH
66721: EMPTY
66722: LIST
66723: LIST
66724: PUSH
66725: LD_INT 1
66727: PUSH
66728: LD_INT 0
66730: PUSH
66731: EMPTY
66732: LIST
66733: LIST
66734: PUSH
66735: LD_INT 1
66737: PUSH
66738: LD_INT 1
66740: PUSH
66741: EMPTY
66742: LIST
66743: LIST
66744: PUSH
66745: LD_INT 0
66747: PUSH
66748: LD_INT 1
66750: PUSH
66751: EMPTY
66752: LIST
66753: LIST
66754: PUSH
66755: LD_INT 1
66757: NEG
66758: PUSH
66759: LD_INT 0
66761: PUSH
66762: EMPTY
66763: LIST
66764: LIST
66765: PUSH
66766: LD_INT 1
66768: NEG
66769: PUSH
66770: LD_INT 1
66772: NEG
66773: PUSH
66774: EMPTY
66775: LIST
66776: LIST
66777: PUSH
66778: LD_INT 1
66780: NEG
66781: PUSH
66782: LD_INT 2
66784: NEG
66785: PUSH
66786: EMPTY
66787: LIST
66788: LIST
66789: PUSH
66790: LD_INT 2
66792: PUSH
66793: LD_INT 1
66795: PUSH
66796: EMPTY
66797: LIST
66798: LIST
66799: PUSH
66800: LD_INT 2
66802: PUSH
66803: LD_INT 2
66805: PUSH
66806: EMPTY
66807: LIST
66808: LIST
66809: PUSH
66810: LD_INT 1
66812: PUSH
66813: LD_INT 2
66815: PUSH
66816: EMPTY
66817: LIST
66818: LIST
66819: PUSH
66820: LD_INT 2
66822: NEG
66823: PUSH
66824: LD_INT 1
66826: NEG
66827: PUSH
66828: EMPTY
66829: LIST
66830: LIST
66831: PUSH
66832: LD_INT 2
66834: NEG
66835: PUSH
66836: LD_INT 2
66838: NEG
66839: PUSH
66840: EMPTY
66841: LIST
66842: LIST
66843: PUSH
66844: LD_INT 2
66846: NEG
66847: PUSH
66848: LD_INT 3
66850: NEG
66851: PUSH
66852: EMPTY
66853: LIST
66854: LIST
66855: PUSH
66856: LD_INT 3
66858: NEG
66859: PUSH
66860: LD_INT 2
66862: NEG
66863: PUSH
66864: EMPTY
66865: LIST
66866: LIST
66867: PUSH
66868: LD_INT 3
66870: NEG
66871: PUSH
66872: LD_INT 3
66874: NEG
66875: PUSH
66876: EMPTY
66877: LIST
66878: LIST
66879: PUSH
66880: EMPTY
66881: LIST
66882: LIST
66883: LIST
66884: LIST
66885: LIST
66886: LIST
66887: LIST
66888: LIST
66889: LIST
66890: LIST
66891: LIST
66892: LIST
66893: LIST
66894: LIST
66895: LIST
66896: LIST
66897: ST_TO_ADDR
// fDepotAm3 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 1 , - 3 ] , [ 0 , - 3 ] , [ 1 , - 2 ] ] ;
66898: LD_ADDR_VAR 0 14
66902: PUSH
66903: LD_INT 0
66905: PUSH
66906: LD_INT 0
66908: PUSH
66909: EMPTY
66910: LIST
66911: LIST
66912: PUSH
66913: LD_INT 0
66915: PUSH
66916: LD_INT 1
66918: NEG
66919: PUSH
66920: EMPTY
66921: LIST
66922: LIST
66923: PUSH
66924: LD_INT 1
66926: PUSH
66927: LD_INT 0
66929: PUSH
66930: EMPTY
66931: LIST
66932: LIST
66933: PUSH
66934: LD_INT 1
66936: PUSH
66937: LD_INT 1
66939: PUSH
66940: EMPTY
66941: LIST
66942: LIST
66943: PUSH
66944: LD_INT 0
66946: PUSH
66947: LD_INT 1
66949: PUSH
66950: EMPTY
66951: LIST
66952: LIST
66953: PUSH
66954: LD_INT 1
66956: NEG
66957: PUSH
66958: LD_INT 0
66960: PUSH
66961: EMPTY
66962: LIST
66963: LIST
66964: PUSH
66965: LD_INT 1
66967: NEG
66968: PUSH
66969: LD_INT 1
66971: NEG
66972: PUSH
66973: EMPTY
66974: LIST
66975: LIST
66976: PUSH
66977: LD_INT 1
66979: NEG
66980: PUSH
66981: LD_INT 2
66983: NEG
66984: PUSH
66985: EMPTY
66986: LIST
66987: LIST
66988: PUSH
66989: LD_INT 0
66991: PUSH
66992: LD_INT 2
66994: NEG
66995: PUSH
66996: EMPTY
66997: LIST
66998: LIST
66999: PUSH
67000: LD_INT 1
67002: PUSH
67003: LD_INT 1
67005: NEG
67006: PUSH
67007: EMPTY
67008: LIST
67009: LIST
67010: PUSH
67011: LD_INT 1
67013: PUSH
67014: LD_INT 2
67016: PUSH
67017: EMPTY
67018: LIST
67019: LIST
67020: PUSH
67021: LD_INT 0
67023: PUSH
67024: LD_INT 2
67026: PUSH
67027: EMPTY
67028: LIST
67029: LIST
67030: PUSH
67031: LD_INT 1
67033: NEG
67034: PUSH
67035: LD_INT 1
67037: PUSH
67038: EMPTY
67039: LIST
67040: LIST
67041: PUSH
67042: LD_INT 1
67044: NEG
67045: PUSH
67046: LD_INT 3
67048: NEG
67049: PUSH
67050: EMPTY
67051: LIST
67052: LIST
67053: PUSH
67054: LD_INT 0
67056: PUSH
67057: LD_INT 3
67059: NEG
67060: PUSH
67061: EMPTY
67062: LIST
67063: LIST
67064: PUSH
67065: LD_INT 1
67067: PUSH
67068: LD_INT 2
67070: NEG
67071: PUSH
67072: EMPTY
67073: LIST
67074: LIST
67075: PUSH
67076: EMPTY
67077: LIST
67078: LIST
67079: LIST
67080: LIST
67081: LIST
67082: LIST
67083: LIST
67084: LIST
67085: LIST
67086: LIST
67087: LIST
67088: LIST
67089: LIST
67090: LIST
67091: LIST
67092: LIST
67093: ST_TO_ADDR
// fDepotAm4 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ 2 , - 1 ] , [ 3 , 0 ] , [ 3 , 1 ] ] ;
67094: LD_ADDR_VAR 0 15
67098: PUSH
67099: LD_INT 0
67101: PUSH
67102: LD_INT 0
67104: PUSH
67105: EMPTY
67106: LIST
67107: LIST
67108: PUSH
67109: LD_INT 0
67111: PUSH
67112: LD_INT 1
67114: NEG
67115: PUSH
67116: EMPTY
67117: LIST
67118: LIST
67119: PUSH
67120: LD_INT 1
67122: PUSH
67123: LD_INT 0
67125: PUSH
67126: EMPTY
67127: LIST
67128: LIST
67129: PUSH
67130: LD_INT 1
67132: PUSH
67133: LD_INT 1
67135: PUSH
67136: EMPTY
67137: LIST
67138: LIST
67139: PUSH
67140: LD_INT 0
67142: PUSH
67143: LD_INT 1
67145: PUSH
67146: EMPTY
67147: LIST
67148: LIST
67149: PUSH
67150: LD_INT 1
67152: NEG
67153: PUSH
67154: LD_INT 0
67156: PUSH
67157: EMPTY
67158: LIST
67159: LIST
67160: PUSH
67161: LD_INT 1
67163: NEG
67164: PUSH
67165: LD_INT 1
67167: NEG
67168: PUSH
67169: EMPTY
67170: LIST
67171: LIST
67172: PUSH
67173: LD_INT 1
67175: PUSH
67176: LD_INT 1
67178: NEG
67179: PUSH
67180: EMPTY
67181: LIST
67182: LIST
67183: PUSH
67184: LD_INT 2
67186: PUSH
67187: LD_INT 0
67189: PUSH
67190: EMPTY
67191: LIST
67192: LIST
67193: PUSH
67194: LD_INT 2
67196: PUSH
67197: LD_INT 1
67199: PUSH
67200: EMPTY
67201: LIST
67202: LIST
67203: PUSH
67204: LD_INT 1
67206: NEG
67207: PUSH
67208: LD_INT 1
67210: PUSH
67211: EMPTY
67212: LIST
67213: LIST
67214: PUSH
67215: LD_INT 2
67217: NEG
67218: PUSH
67219: LD_INT 0
67221: PUSH
67222: EMPTY
67223: LIST
67224: LIST
67225: PUSH
67226: LD_INT 2
67228: NEG
67229: PUSH
67230: LD_INT 1
67232: NEG
67233: PUSH
67234: EMPTY
67235: LIST
67236: LIST
67237: PUSH
67238: LD_INT 2
67240: PUSH
67241: LD_INT 1
67243: NEG
67244: PUSH
67245: EMPTY
67246: LIST
67247: LIST
67248: PUSH
67249: LD_INT 3
67251: PUSH
67252: LD_INT 0
67254: PUSH
67255: EMPTY
67256: LIST
67257: LIST
67258: PUSH
67259: LD_INT 3
67261: PUSH
67262: LD_INT 1
67264: PUSH
67265: EMPTY
67266: LIST
67267: LIST
67268: PUSH
67269: EMPTY
67270: LIST
67271: LIST
67272: LIST
67273: LIST
67274: LIST
67275: LIST
67276: LIST
67277: LIST
67278: LIST
67279: LIST
67280: LIST
67281: LIST
67282: LIST
67283: LIST
67284: LIST
67285: LIST
67286: ST_TO_ADDR
// fDepotAm5 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ 3 , 2 ] , [ 3 , 3 ] , [ 2 , 3 ] ] ;
67287: LD_ADDR_VAR 0 16
67291: PUSH
67292: LD_INT 0
67294: PUSH
67295: LD_INT 0
67297: PUSH
67298: EMPTY
67299: LIST
67300: LIST
67301: PUSH
67302: LD_INT 0
67304: PUSH
67305: LD_INT 1
67307: NEG
67308: PUSH
67309: EMPTY
67310: LIST
67311: LIST
67312: PUSH
67313: LD_INT 1
67315: PUSH
67316: LD_INT 0
67318: PUSH
67319: EMPTY
67320: LIST
67321: LIST
67322: PUSH
67323: LD_INT 1
67325: PUSH
67326: LD_INT 1
67328: PUSH
67329: EMPTY
67330: LIST
67331: LIST
67332: PUSH
67333: LD_INT 0
67335: PUSH
67336: LD_INT 1
67338: PUSH
67339: EMPTY
67340: LIST
67341: LIST
67342: PUSH
67343: LD_INT 1
67345: NEG
67346: PUSH
67347: LD_INT 0
67349: PUSH
67350: EMPTY
67351: LIST
67352: LIST
67353: PUSH
67354: LD_INT 1
67356: NEG
67357: PUSH
67358: LD_INT 1
67360: NEG
67361: PUSH
67362: EMPTY
67363: LIST
67364: LIST
67365: PUSH
67366: LD_INT 1
67368: NEG
67369: PUSH
67370: LD_INT 2
67372: NEG
67373: PUSH
67374: EMPTY
67375: LIST
67376: LIST
67377: PUSH
67378: LD_INT 2
67380: PUSH
67381: LD_INT 1
67383: PUSH
67384: EMPTY
67385: LIST
67386: LIST
67387: PUSH
67388: LD_INT 2
67390: PUSH
67391: LD_INT 2
67393: PUSH
67394: EMPTY
67395: LIST
67396: LIST
67397: PUSH
67398: LD_INT 1
67400: PUSH
67401: LD_INT 2
67403: PUSH
67404: EMPTY
67405: LIST
67406: LIST
67407: PUSH
67408: LD_INT 2
67410: NEG
67411: PUSH
67412: LD_INT 1
67414: NEG
67415: PUSH
67416: EMPTY
67417: LIST
67418: LIST
67419: PUSH
67420: LD_INT 2
67422: NEG
67423: PUSH
67424: LD_INT 2
67426: NEG
67427: PUSH
67428: EMPTY
67429: LIST
67430: LIST
67431: PUSH
67432: LD_INT 3
67434: PUSH
67435: LD_INT 2
67437: PUSH
67438: EMPTY
67439: LIST
67440: LIST
67441: PUSH
67442: LD_INT 3
67444: PUSH
67445: LD_INT 3
67447: PUSH
67448: EMPTY
67449: LIST
67450: LIST
67451: PUSH
67452: LD_INT 2
67454: PUSH
67455: LD_INT 3
67457: PUSH
67458: EMPTY
67459: LIST
67460: LIST
67461: PUSH
67462: EMPTY
67463: LIST
67464: LIST
67465: LIST
67466: LIST
67467: LIST
67468: LIST
67469: LIST
67470: LIST
67471: LIST
67472: LIST
67473: LIST
67474: LIST
67475: LIST
67476: LIST
67477: LIST
67478: LIST
67479: ST_TO_ADDR
// fDepotAr0 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
67480: LD_ADDR_VAR 0 17
67484: PUSH
67485: LD_INT 0
67487: PUSH
67488: LD_INT 0
67490: PUSH
67491: EMPTY
67492: LIST
67493: LIST
67494: PUSH
67495: LD_INT 0
67497: PUSH
67498: LD_INT 1
67500: NEG
67501: PUSH
67502: EMPTY
67503: LIST
67504: LIST
67505: PUSH
67506: LD_INT 1
67508: PUSH
67509: LD_INT 0
67511: PUSH
67512: EMPTY
67513: LIST
67514: LIST
67515: PUSH
67516: LD_INT 1
67518: PUSH
67519: LD_INT 1
67521: PUSH
67522: EMPTY
67523: LIST
67524: LIST
67525: PUSH
67526: LD_INT 0
67528: PUSH
67529: LD_INT 1
67531: PUSH
67532: EMPTY
67533: LIST
67534: LIST
67535: PUSH
67536: LD_INT 1
67538: NEG
67539: PUSH
67540: LD_INT 0
67542: PUSH
67543: EMPTY
67544: LIST
67545: LIST
67546: PUSH
67547: LD_INT 1
67549: NEG
67550: PUSH
67551: LD_INT 1
67553: NEG
67554: PUSH
67555: EMPTY
67556: LIST
67557: LIST
67558: PUSH
67559: LD_INT 1
67561: NEG
67562: PUSH
67563: LD_INT 2
67565: NEG
67566: PUSH
67567: EMPTY
67568: LIST
67569: LIST
67570: PUSH
67571: LD_INT 0
67573: PUSH
67574: LD_INT 2
67576: NEG
67577: PUSH
67578: EMPTY
67579: LIST
67580: LIST
67581: PUSH
67582: LD_INT 1
67584: PUSH
67585: LD_INT 1
67587: NEG
67588: PUSH
67589: EMPTY
67590: LIST
67591: LIST
67592: PUSH
67593: LD_INT 2
67595: PUSH
67596: LD_INT 0
67598: PUSH
67599: EMPTY
67600: LIST
67601: LIST
67602: PUSH
67603: LD_INT 2
67605: PUSH
67606: LD_INT 1
67608: PUSH
67609: EMPTY
67610: LIST
67611: LIST
67612: PUSH
67613: LD_INT 2
67615: PUSH
67616: LD_INT 2
67618: PUSH
67619: EMPTY
67620: LIST
67621: LIST
67622: PUSH
67623: LD_INT 1
67625: PUSH
67626: LD_INT 2
67628: PUSH
67629: EMPTY
67630: LIST
67631: LIST
67632: PUSH
67633: LD_INT 0
67635: PUSH
67636: LD_INT 2
67638: PUSH
67639: EMPTY
67640: LIST
67641: LIST
67642: PUSH
67643: LD_INT 1
67645: NEG
67646: PUSH
67647: LD_INT 1
67649: PUSH
67650: EMPTY
67651: LIST
67652: LIST
67653: PUSH
67654: LD_INT 2
67656: NEG
67657: PUSH
67658: LD_INT 0
67660: PUSH
67661: EMPTY
67662: LIST
67663: LIST
67664: PUSH
67665: LD_INT 2
67667: NEG
67668: PUSH
67669: LD_INT 1
67671: NEG
67672: PUSH
67673: EMPTY
67674: LIST
67675: LIST
67676: PUSH
67677: LD_INT 2
67679: NEG
67680: PUSH
67681: LD_INT 2
67683: NEG
67684: PUSH
67685: EMPTY
67686: LIST
67687: LIST
67688: PUSH
67689: EMPTY
67690: LIST
67691: LIST
67692: LIST
67693: LIST
67694: LIST
67695: LIST
67696: LIST
67697: LIST
67698: LIST
67699: LIST
67700: LIST
67701: LIST
67702: LIST
67703: LIST
67704: LIST
67705: LIST
67706: LIST
67707: LIST
67708: LIST
67709: ST_TO_ADDR
// fDepotAr1 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
67710: LD_ADDR_VAR 0 18
67714: PUSH
67715: LD_INT 0
67717: PUSH
67718: LD_INT 0
67720: PUSH
67721: EMPTY
67722: LIST
67723: LIST
67724: PUSH
67725: LD_INT 0
67727: PUSH
67728: LD_INT 1
67730: NEG
67731: PUSH
67732: EMPTY
67733: LIST
67734: LIST
67735: PUSH
67736: LD_INT 1
67738: PUSH
67739: LD_INT 0
67741: PUSH
67742: EMPTY
67743: LIST
67744: LIST
67745: PUSH
67746: LD_INT 1
67748: PUSH
67749: LD_INT 1
67751: PUSH
67752: EMPTY
67753: LIST
67754: LIST
67755: PUSH
67756: LD_INT 0
67758: PUSH
67759: LD_INT 1
67761: PUSH
67762: EMPTY
67763: LIST
67764: LIST
67765: PUSH
67766: LD_INT 1
67768: NEG
67769: PUSH
67770: LD_INT 0
67772: PUSH
67773: EMPTY
67774: LIST
67775: LIST
67776: PUSH
67777: LD_INT 1
67779: NEG
67780: PUSH
67781: LD_INT 1
67783: NEG
67784: PUSH
67785: EMPTY
67786: LIST
67787: LIST
67788: PUSH
67789: LD_INT 1
67791: NEG
67792: PUSH
67793: LD_INT 2
67795: NEG
67796: PUSH
67797: EMPTY
67798: LIST
67799: LIST
67800: PUSH
67801: LD_INT 0
67803: PUSH
67804: LD_INT 2
67806: NEG
67807: PUSH
67808: EMPTY
67809: LIST
67810: LIST
67811: PUSH
67812: LD_INT 1
67814: PUSH
67815: LD_INT 1
67817: NEG
67818: PUSH
67819: EMPTY
67820: LIST
67821: LIST
67822: PUSH
67823: LD_INT 2
67825: PUSH
67826: LD_INT 0
67828: PUSH
67829: EMPTY
67830: LIST
67831: LIST
67832: PUSH
67833: LD_INT 2
67835: PUSH
67836: LD_INT 1
67838: PUSH
67839: EMPTY
67840: LIST
67841: LIST
67842: PUSH
67843: LD_INT 2
67845: PUSH
67846: LD_INT 2
67848: PUSH
67849: EMPTY
67850: LIST
67851: LIST
67852: PUSH
67853: LD_INT 1
67855: PUSH
67856: LD_INT 2
67858: PUSH
67859: EMPTY
67860: LIST
67861: LIST
67862: PUSH
67863: LD_INT 0
67865: PUSH
67866: LD_INT 2
67868: PUSH
67869: EMPTY
67870: LIST
67871: LIST
67872: PUSH
67873: LD_INT 1
67875: NEG
67876: PUSH
67877: LD_INT 1
67879: PUSH
67880: EMPTY
67881: LIST
67882: LIST
67883: PUSH
67884: LD_INT 2
67886: NEG
67887: PUSH
67888: LD_INT 0
67890: PUSH
67891: EMPTY
67892: LIST
67893: LIST
67894: PUSH
67895: LD_INT 2
67897: NEG
67898: PUSH
67899: LD_INT 1
67901: NEG
67902: PUSH
67903: EMPTY
67904: LIST
67905: LIST
67906: PUSH
67907: LD_INT 2
67909: NEG
67910: PUSH
67911: LD_INT 2
67913: NEG
67914: PUSH
67915: EMPTY
67916: LIST
67917: LIST
67918: PUSH
67919: EMPTY
67920: LIST
67921: LIST
67922: LIST
67923: LIST
67924: LIST
67925: LIST
67926: LIST
67927: LIST
67928: LIST
67929: LIST
67930: LIST
67931: LIST
67932: LIST
67933: LIST
67934: LIST
67935: LIST
67936: LIST
67937: LIST
67938: LIST
67939: ST_TO_ADDR
// fDepotAr2 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
67940: LD_ADDR_VAR 0 19
67944: PUSH
67945: LD_INT 0
67947: PUSH
67948: LD_INT 0
67950: PUSH
67951: EMPTY
67952: LIST
67953: LIST
67954: PUSH
67955: LD_INT 0
67957: PUSH
67958: LD_INT 1
67960: NEG
67961: PUSH
67962: EMPTY
67963: LIST
67964: LIST
67965: PUSH
67966: LD_INT 1
67968: PUSH
67969: LD_INT 0
67971: PUSH
67972: EMPTY
67973: LIST
67974: LIST
67975: PUSH
67976: LD_INT 1
67978: PUSH
67979: LD_INT 1
67981: PUSH
67982: EMPTY
67983: LIST
67984: LIST
67985: PUSH
67986: LD_INT 0
67988: PUSH
67989: LD_INT 1
67991: PUSH
67992: EMPTY
67993: LIST
67994: LIST
67995: PUSH
67996: LD_INT 1
67998: NEG
67999: PUSH
68000: LD_INT 0
68002: PUSH
68003: EMPTY
68004: LIST
68005: LIST
68006: PUSH
68007: LD_INT 1
68009: NEG
68010: PUSH
68011: LD_INT 1
68013: NEG
68014: PUSH
68015: EMPTY
68016: LIST
68017: LIST
68018: PUSH
68019: LD_INT 1
68021: NEG
68022: PUSH
68023: LD_INT 2
68025: NEG
68026: PUSH
68027: EMPTY
68028: LIST
68029: LIST
68030: PUSH
68031: LD_INT 0
68033: PUSH
68034: LD_INT 2
68036: NEG
68037: PUSH
68038: EMPTY
68039: LIST
68040: LIST
68041: PUSH
68042: LD_INT 1
68044: PUSH
68045: LD_INT 1
68047: NEG
68048: PUSH
68049: EMPTY
68050: LIST
68051: LIST
68052: PUSH
68053: LD_INT 2
68055: PUSH
68056: LD_INT 0
68058: PUSH
68059: EMPTY
68060: LIST
68061: LIST
68062: PUSH
68063: LD_INT 2
68065: PUSH
68066: LD_INT 1
68068: PUSH
68069: EMPTY
68070: LIST
68071: LIST
68072: PUSH
68073: LD_INT 2
68075: PUSH
68076: LD_INT 2
68078: PUSH
68079: EMPTY
68080: LIST
68081: LIST
68082: PUSH
68083: LD_INT 1
68085: PUSH
68086: LD_INT 2
68088: PUSH
68089: EMPTY
68090: LIST
68091: LIST
68092: PUSH
68093: LD_INT 0
68095: PUSH
68096: LD_INT 2
68098: PUSH
68099: EMPTY
68100: LIST
68101: LIST
68102: PUSH
68103: LD_INT 1
68105: NEG
68106: PUSH
68107: LD_INT 1
68109: PUSH
68110: EMPTY
68111: LIST
68112: LIST
68113: PUSH
68114: LD_INT 2
68116: NEG
68117: PUSH
68118: LD_INT 0
68120: PUSH
68121: EMPTY
68122: LIST
68123: LIST
68124: PUSH
68125: LD_INT 2
68127: NEG
68128: PUSH
68129: LD_INT 1
68131: NEG
68132: PUSH
68133: EMPTY
68134: LIST
68135: LIST
68136: PUSH
68137: LD_INT 2
68139: NEG
68140: PUSH
68141: LD_INT 2
68143: NEG
68144: PUSH
68145: EMPTY
68146: LIST
68147: LIST
68148: PUSH
68149: EMPTY
68150: LIST
68151: LIST
68152: LIST
68153: LIST
68154: LIST
68155: LIST
68156: LIST
68157: LIST
68158: LIST
68159: LIST
68160: LIST
68161: LIST
68162: LIST
68163: LIST
68164: LIST
68165: LIST
68166: LIST
68167: LIST
68168: LIST
68169: ST_TO_ADDR
// fDepotAr3 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
68170: LD_ADDR_VAR 0 20
68174: PUSH
68175: LD_INT 0
68177: PUSH
68178: LD_INT 0
68180: PUSH
68181: EMPTY
68182: LIST
68183: LIST
68184: PUSH
68185: LD_INT 0
68187: PUSH
68188: LD_INT 1
68190: NEG
68191: PUSH
68192: EMPTY
68193: LIST
68194: LIST
68195: PUSH
68196: LD_INT 1
68198: PUSH
68199: LD_INT 0
68201: PUSH
68202: EMPTY
68203: LIST
68204: LIST
68205: PUSH
68206: LD_INT 1
68208: PUSH
68209: LD_INT 1
68211: PUSH
68212: EMPTY
68213: LIST
68214: LIST
68215: PUSH
68216: LD_INT 0
68218: PUSH
68219: LD_INT 1
68221: PUSH
68222: EMPTY
68223: LIST
68224: LIST
68225: PUSH
68226: LD_INT 1
68228: NEG
68229: PUSH
68230: LD_INT 0
68232: PUSH
68233: EMPTY
68234: LIST
68235: LIST
68236: PUSH
68237: LD_INT 1
68239: NEG
68240: PUSH
68241: LD_INT 1
68243: NEG
68244: PUSH
68245: EMPTY
68246: LIST
68247: LIST
68248: PUSH
68249: LD_INT 1
68251: NEG
68252: PUSH
68253: LD_INT 2
68255: NEG
68256: PUSH
68257: EMPTY
68258: LIST
68259: LIST
68260: PUSH
68261: LD_INT 0
68263: PUSH
68264: LD_INT 2
68266: NEG
68267: PUSH
68268: EMPTY
68269: LIST
68270: LIST
68271: PUSH
68272: LD_INT 1
68274: PUSH
68275: LD_INT 1
68277: NEG
68278: PUSH
68279: EMPTY
68280: LIST
68281: LIST
68282: PUSH
68283: LD_INT 2
68285: PUSH
68286: LD_INT 0
68288: PUSH
68289: EMPTY
68290: LIST
68291: LIST
68292: PUSH
68293: LD_INT 2
68295: PUSH
68296: LD_INT 1
68298: PUSH
68299: EMPTY
68300: LIST
68301: LIST
68302: PUSH
68303: LD_INT 2
68305: PUSH
68306: LD_INT 2
68308: PUSH
68309: EMPTY
68310: LIST
68311: LIST
68312: PUSH
68313: LD_INT 1
68315: PUSH
68316: LD_INT 2
68318: PUSH
68319: EMPTY
68320: LIST
68321: LIST
68322: PUSH
68323: LD_INT 0
68325: PUSH
68326: LD_INT 2
68328: PUSH
68329: EMPTY
68330: LIST
68331: LIST
68332: PUSH
68333: LD_INT 1
68335: NEG
68336: PUSH
68337: LD_INT 1
68339: PUSH
68340: EMPTY
68341: LIST
68342: LIST
68343: PUSH
68344: LD_INT 2
68346: NEG
68347: PUSH
68348: LD_INT 0
68350: PUSH
68351: EMPTY
68352: LIST
68353: LIST
68354: PUSH
68355: LD_INT 2
68357: NEG
68358: PUSH
68359: LD_INT 1
68361: NEG
68362: PUSH
68363: EMPTY
68364: LIST
68365: LIST
68366: PUSH
68367: LD_INT 2
68369: NEG
68370: PUSH
68371: LD_INT 2
68373: NEG
68374: PUSH
68375: EMPTY
68376: LIST
68377: LIST
68378: PUSH
68379: EMPTY
68380: LIST
68381: LIST
68382: LIST
68383: LIST
68384: LIST
68385: LIST
68386: LIST
68387: LIST
68388: LIST
68389: LIST
68390: LIST
68391: LIST
68392: LIST
68393: LIST
68394: LIST
68395: LIST
68396: LIST
68397: LIST
68398: LIST
68399: ST_TO_ADDR
// fDepotAr4 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
68400: LD_ADDR_VAR 0 21
68404: PUSH
68405: LD_INT 0
68407: PUSH
68408: LD_INT 0
68410: PUSH
68411: EMPTY
68412: LIST
68413: LIST
68414: PUSH
68415: LD_INT 0
68417: PUSH
68418: LD_INT 1
68420: NEG
68421: PUSH
68422: EMPTY
68423: LIST
68424: LIST
68425: PUSH
68426: LD_INT 1
68428: PUSH
68429: LD_INT 0
68431: PUSH
68432: EMPTY
68433: LIST
68434: LIST
68435: PUSH
68436: LD_INT 1
68438: PUSH
68439: LD_INT 1
68441: PUSH
68442: EMPTY
68443: LIST
68444: LIST
68445: PUSH
68446: LD_INT 0
68448: PUSH
68449: LD_INT 1
68451: PUSH
68452: EMPTY
68453: LIST
68454: LIST
68455: PUSH
68456: LD_INT 1
68458: NEG
68459: PUSH
68460: LD_INT 0
68462: PUSH
68463: EMPTY
68464: LIST
68465: LIST
68466: PUSH
68467: LD_INT 1
68469: NEG
68470: PUSH
68471: LD_INT 1
68473: NEG
68474: PUSH
68475: EMPTY
68476: LIST
68477: LIST
68478: PUSH
68479: LD_INT 1
68481: NEG
68482: PUSH
68483: LD_INT 2
68485: NEG
68486: PUSH
68487: EMPTY
68488: LIST
68489: LIST
68490: PUSH
68491: LD_INT 0
68493: PUSH
68494: LD_INT 2
68496: NEG
68497: PUSH
68498: EMPTY
68499: LIST
68500: LIST
68501: PUSH
68502: LD_INT 1
68504: PUSH
68505: LD_INT 1
68507: NEG
68508: PUSH
68509: EMPTY
68510: LIST
68511: LIST
68512: PUSH
68513: LD_INT 2
68515: PUSH
68516: LD_INT 0
68518: PUSH
68519: EMPTY
68520: LIST
68521: LIST
68522: PUSH
68523: LD_INT 2
68525: PUSH
68526: LD_INT 1
68528: PUSH
68529: EMPTY
68530: LIST
68531: LIST
68532: PUSH
68533: LD_INT 2
68535: PUSH
68536: LD_INT 2
68538: PUSH
68539: EMPTY
68540: LIST
68541: LIST
68542: PUSH
68543: LD_INT 1
68545: PUSH
68546: LD_INT 2
68548: PUSH
68549: EMPTY
68550: LIST
68551: LIST
68552: PUSH
68553: LD_INT 0
68555: PUSH
68556: LD_INT 2
68558: PUSH
68559: EMPTY
68560: LIST
68561: LIST
68562: PUSH
68563: LD_INT 1
68565: NEG
68566: PUSH
68567: LD_INT 1
68569: PUSH
68570: EMPTY
68571: LIST
68572: LIST
68573: PUSH
68574: LD_INT 2
68576: NEG
68577: PUSH
68578: LD_INT 0
68580: PUSH
68581: EMPTY
68582: LIST
68583: LIST
68584: PUSH
68585: LD_INT 2
68587: NEG
68588: PUSH
68589: LD_INT 1
68591: NEG
68592: PUSH
68593: EMPTY
68594: LIST
68595: LIST
68596: PUSH
68597: LD_INT 2
68599: NEG
68600: PUSH
68601: LD_INT 2
68603: NEG
68604: PUSH
68605: EMPTY
68606: LIST
68607: LIST
68608: PUSH
68609: EMPTY
68610: LIST
68611: LIST
68612: LIST
68613: LIST
68614: LIST
68615: LIST
68616: LIST
68617: LIST
68618: LIST
68619: LIST
68620: LIST
68621: LIST
68622: LIST
68623: LIST
68624: LIST
68625: LIST
68626: LIST
68627: LIST
68628: LIST
68629: ST_TO_ADDR
// fDepotAr5 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
68630: LD_ADDR_VAR 0 22
68634: PUSH
68635: LD_INT 0
68637: PUSH
68638: LD_INT 0
68640: PUSH
68641: EMPTY
68642: LIST
68643: LIST
68644: PUSH
68645: LD_INT 0
68647: PUSH
68648: LD_INT 1
68650: NEG
68651: PUSH
68652: EMPTY
68653: LIST
68654: LIST
68655: PUSH
68656: LD_INT 1
68658: PUSH
68659: LD_INT 0
68661: PUSH
68662: EMPTY
68663: LIST
68664: LIST
68665: PUSH
68666: LD_INT 1
68668: PUSH
68669: LD_INT 1
68671: PUSH
68672: EMPTY
68673: LIST
68674: LIST
68675: PUSH
68676: LD_INT 0
68678: PUSH
68679: LD_INT 1
68681: PUSH
68682: EMPTY
68683: LIST
68684: LIST
68685: PUSH
68686: LD_INT 1
68688: NEG
68689: PUSH
68690: LD_INT 0
68692: PUSH
68693: EMPTY
68694: LIST
68695: LIST
68696: PUSH
68697: LD_INT 1
68699: NEG
68700: PUSH
68701: LD_INT 1
68703: NEG
68704: PUSH
68705: EMPTY
68706: LIST
68707: LIST
68708: PUSH
68709: LD_INT 1
68711: NEG
68712: PUSH
68713: LD_INT 2
68715: NEG
68716: PUSH
68717: EMPTY
68718: LIST
68719: LIST
68720: PUSH
68721: LD_INT 0
68723: PUSH
68724: LD_INT 2
68726: NEG
68727: PUSH
68728: EMPTY
68729: LIST
68730: LIST
68731: PUSH
68732: LD_INT 1
68734: PUSH
68735: LD_INT 1
68737: NEG
68738: PUSH
68739: EMPTY
68740: LIST
68741: LIST
68742: PUSH
68743: LD_INT 2
68745: PUSH
68746: LD_INT 0
68748: PUSH
68749: EMPTY
68750: LIST
68751: LIST
68752: PUSH
68753: LD_INT 2
68755: PUSH
68756: LD_INT 1
68758: PUSH
68759: EMPTY
68760: LIST
68761: LIST
68762: PUSH
68763: LD_INT 2
68765: PUSH
68766: LD_INT 2
68768: PUSH
68769: EMPTY
68770: LIST
68771: LIST
68772: PUSH
68773: LD_INT 1
68775: PUSH
68776: LD_INT 2
68778: PUSH
68779: EMPTY
68780: LIST
68781: LIST
68782: PUSH
68783: LD_INT 0
68785: PUSH
68786: LD_INT 2
68788: PUSH
68789: EMPTY
68790: LIST
68791: LIST
68792: PUSH
68793: LD_INT 1
68795: NEG
68796: PUSH
68797: LD_INT 1
68799: PUSH
68800: EMPTY
68801: LIST
68802: LIST
68803: PUSH
68804: LD_INT 2
68806: NEG
68807: PUSH
68808: LD_INT 0
68810: PUSH
68811: EMPTY
68812: LIST
68813: LIST
68814: PUSH
68815: LD_INT 2
68817: NEG
68818: PUSH
68819: LD_INT 1
68821: NEG
68822: PUSH
68823: EMPTY
68824: LIST
68825: LIST
68826: PUSH
68827: LD_INT 2
68829: NEG
68830: PUSH
68831: LD_INT 2
68833: NEG
68834: PUSH
68835: EMPTY
68836: LIST
68837: LIST
68838: PUSH
68839: EMPTY
68840: LIST
68841: LIST
68842: LIST
68843: LIST
68844: LIST
68845: LIST
68846: LIST
68847: LIST
68848: LIST
68849: LIST
68850: LIST
68851: LIST
68852: LIST
68853: LIST
68854: LIST
68855: LIST
68856: LIST
68857: LIST
68858: LIST
68859: ST_TO_ADDR
// fDepotRu0 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ - 2 , - 3 ] , [ - 1 , - 3 ] , [ 1 , - 2 ] , [ 2 , - 1 ] ] ;
68860: LD_ADDR_VAR 0 23
68864: PUSH
68865: LD_INT 0
68867: PUSH
68868: LD_INT 0
68870: PUSH
68871: EMPTY
68872: LIST
68873: LIST
68874: PUSH
68875: LD_INT 0
68877: PUSH
68878: LD_INT 1
68880: NEG
68881: PUSH
68882: EMPTY
68883: LIST
68884: LIST
68885: PUSH
68886: LD_INT 1
68888: PUSH
68889: LD_INT 0
68891: PUSH
68892: EMPTY
68893: LIST
68894: LIST
68895: PUSH
68896: LD_INT 1
68898: PUSH
68899: LD_INT 1
68901: PUSH
68902: EMPTY
68903: LIST
68904: LIST
68905: PUSH
68906: LD_INT 0
68908: PUSH
68909: LD_INT 1
68911: PUSH
68912: EMPTY
68913: LIST
68914: LIST
68915: PUSH
68916: LD_INT 1
68918: NEG
68919: PUSH
68920: LD_INT 0
68922: PUSH
68923: EMPTY
68924: LIST
68925: LIST
68926: PUSH
68927: LD_INT 1
68929: NEG
68930: PUSH
68931: LD_INT 1
68933: NEG
68934: PUSH
68935: EMPTY
68936: LIST
68937: LIST
68938: PUSH
68939: LD_INT 1
68941: NEG
68942: PUSH
68943: LD_INT 2
68945: NEG
68946: PUSH
68947: EMPTY
68948: LIST
68949: LIST
68950: PUSH
68951: LD_INT 0
68953: PUSH
68954: LD_INT 2
68956: NEG
68957: PUSH
68958: EMPTY
68959: LIST
68960: LIST
68961: PUSH
68962: LD_INT 1
68964: PUSH
68965: LD_INT 1
68967: NEG
68968: PUSH
68969: EMPTY
68970: LIST
68971: LIST
68972: PUSH
68973: LD_INT 2
68975: PUSH
68976: LD_INT 0
68978: PUSH
68979: EMPTY
68980: LIST
68981: LIST
68982: PUSH
68983: LD_INT 2
68985: PUSH
68986: LD_INT 1
68988: PUSH
68989: EMPTY
68990: LIST
68991: LIST
68992: PUSH
68993: LD_INT 2
68995: PUSH
68996: LD_INT 2
68998: PUSH
68999: EMPTY
69000: LIST
69001: LIST
69002: PUSH
69003: LD_INT 1
69005: PUSH
69006: LD_INT 2
69008: PUSH
69009: EMPTY
69010: LIST
69011: LIST
69012: PUSH
69013: LD_INT 0
69015: PUSH
69016: LD_INT 2
69018: PUSH
69019: EMPTY
69020: LIST
69021: LIST
69022: PUSH
69023: LD_INT 1
69025: NEG
69026: PUSH
69027: LD_INT 1
69029: PUSH
69030: EMPTY
69031: LIST
69032: LIST
69033: PUSH
69034: LD_INT 2
69036: NEG
69037: PUSH
69038: LD_INT 0
69040: PUSH
69041: EMPTY
69042: LIST
69043: LIST
69044: PUSH
69045: LD_INT 2
69047: NEG
69048: PUSH
69049: LD_INT 1
69051: NEG
69052: PUSH
69053: EMPTY
69054: LIST
69055: LIST
69056: PUSH
69057: LD_INT 2
69059: NEG
69060: PUSH
69061: LD_INT 2
69063: NEG
69064: PUSH
69065: EMPTY
69066: LIST
69067: LIST
69068: PUSH
69069: LD_INT 2
69071: NEG
69072: PUSH
69073: LD_INT 3
69075: NEG
69076: PUSH
69077: EMPTY
69078: LIST
69079: LIST
69080: PUSH
69081: LD_INT 1
69083: NEG
69084: PUSH
69085: LD_INT 3
69087: NEG
69088: PUSH
69089: EMPTY
69090: LIST
69091: LIST
69092: PUSH
69093: LD_INT 1
69095: PUSH
69096: LD_INT 2
69098: NEG
69099: PUSH
69100: EMPTY
69101: LIST
69102: LIST
69103: PUSH
69104: LD_INT 2
69106: PUSH
69107: LD_INT 1
69109: NEG
69110: PUSH
69111: EMPTY
69112: LIST
69113: LIST
69114: PUSH
69115: EMPTY
69116: LIST
69117: LIST
69118: LIST
69119: LIST
69120: LIST
69121: LIST
69122: LIST
69123: LIST
69124: LIST
69125: LIST
69126: LIST
69127: LIST
69128: LIST
69129: LIST
69130: LIST
69131: LIST
69132: LIST
69133: LIST
69134: LIST
69135: LIST
69136: LIST
69137: LIST
69138: LIST
69139: ST_TO_ADDR
// fDepotRu1 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ 1 , - 2 ] , [ 2 , - 1 ] , [ 3 , 1 ] , [ 3 , 2 ] ] ;
69140: LD_ADDR_VAR 0 24
69144: PUSH
69145: LD_INT 0
69147: PUSH
69148: LD_INT 0
69150: PUSH
69151: EMPTY
69152: LIST
69153: LIST
69154: PUSH
69155: LD_INT 0
69157: PUSH
69158: LD_INT 1
69160: NEG
69161: PUSH
69162: EMPTY
69163: LIST
69164: LIST
69165: PUSH
69166: LD_INT 1
69168: PUSH
69169: LD_INT 0
69171: PUSH
69172: EMPTY
69173: LIST
69174: LIST
69175: PUSH
69176: LD_INT 1
69178: PUSH
69179: LD_INT 1
69181: PUSH
69182: EMPTY
69183: LIST
69184: LIST
69185: PUSH
69186: LD_INT 0
69188: PUSH
69189: LD_INT 1
69191: PUSH
69192: EMPTY
69193: LIST
69194: LIST
69195: PUSH
69196: LD_INT 1
69198: NEG
69199: PUSH
69200: LD_INT 0
69202: PUSH
69203: EMPTY
69204: LIST
69205: LIST
69206: PUSH
69207: LD_INT 1
69209: NEG
69210: PUSH
69211: LD_INT 1
69213: NEG
69214: PUSH
69215: EMPTY
69216: LIST
69217: LIST
69218: PUSH
69219: LD_INT 1
69221: NEG
69222: PUSH
69223: LD_INT 2
69225: NEG
69226: PUSH
69227: EMPTY
69228: LIST
69229: LIST
69230: PUSH
69231: LD_INT 0
69233: PUSH
69234: LD_INT 2
69236: NEG
69237: PUSH
69238: EMPTY
69239: LIST
69240: LIST
69241: PUSH
69242: LD_INT 1
69244: PUSH
69245: LD_INT 1
69247: NEG
69248: PUSH
69249: EMPTY
69250: LIST
69251: LIST
69252: PUSH
69253: LD_INT 2
69255: PUSH
69256: LD_INT 0
69258: PUSH
69259: EMPTY
69260: LIST
69261: LIST
69262: PUSH
69263: LD_INT 2
69265: PUSH
69266: LD_INT 1
69268: PUSH
69269: EMPTY
69270: LIST
69271: LIST
69272: PUSH
69273: LD_INT 2
69275: PUSH
69276: LD_INT 2
69278: PUSH
69279: EMPTY
69280: LIST
69281: LIST
69282: PUSH
69283: LD_INT 1
69285: PUSH
69286: LD_INT 2
69288: PUSH
69289: EMPTY
69290: LIST
69291: LIST
69292: PUSH
69293: LD_INT 0
69295: PUSH
69296: LD_INT 2
69298: PUSH
69299: EMPTY
69300: LIST
69301: LIST
69302: PUSH
69303: LD_INT 1
69305: NEG
69306: PUSH
69307: LD_INT 1
69309: PUSH
69310: EMPTY
69311: LIST
69312: LIST
69313: PUSH
69314: LD_INT 2
69316: NEG
69317: PUSH
69318: LD_INT 0
69320: PUSH
69321: EMPTY
69322: LIST
69323: LIST
69324: PUSH
69325: LD_INT 2
69327: NEG
69328: PUSH
69329: LD_INT 1
69331: NEG
69332: PUSH
69333: EMPTY
69334: LIST
69335: LIST
69336: PUSH
69337: LD_INT 2
69339: NEG
69340: PUSH
69341: LD_INT 2
69343: NEG
69344: PUSH
69345: EMPTY
69346: LIST
69347: LIST
69348: PUSH
69349: LD_INT 1
69351: PUSH
69352: LD_INT 2
69354: NEG
69355: PUSH
69356: EMPTY
69357: LIST
69358: LIST
69359: PUSH
69360: LD_INT 2
69362: PUSH
69363: LD_INT 1
69365: NEG
69366: PUSH
69367: EMPTY
69368: LIST
69369: LIST
69370: PUSH
69371: LD_INT 3
69373: PUSH
69374: LD_INT 1
69376: PUSH
69377: EMPTY
69378: LIST
69379: LIST
69380: PUSH
69381: LD_INT 3
69383: PUSH
69384: LD_INT 2
69386: PUSH
69387: EMPTY
69388: LIST
69389: LIST
69390: PUSH
69391: EMPTY
69392: LIST
69393: LIST
69394: LIST
69395: LIST
69396: LIST
69397: LIST
69398: LIST
69399: LIST
69400: LIST
69401: LIST
69402: LIST
69403: LIST
69404: LIST
69405: LIST
69406: LIST
69407: LIST
69408: LIST
69409: LIST
69410: LIST
69411: LIST
69412: LIST
69413: LIST
69414: LIST
69415: ST_TO_ADDR
// fDepotRu2 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ 3 , 1 ] , [ 3 , 2 ] , [ 2 , 3 ] , [ 1 , 3 ] ] ;
69416: LD_ADDR_VAR 0 25
69420: PUSH
69421: LD_INT 0
69423: PUSH
69424: LD_INT 0
69426: PUSH
69427: EMPTY
69428: LIST
69429: LIST
69430: PUSH
69431: LD_INT 0
69433: PUSH
69434: LD_INT 1
69436: NEG
69437: PUSH
69438: EMPTY
69439: LIST
69440: LIST
69441: PUSH
69442: LD_INT 1
69444: PUSH
69445: LD_INT 0
69447: PUSH
69448: EMPTY
69449: LIST
69450: LIST
69451: PUSH
69452: LD_INT 1
69454: PUSH
69455: LD_INT 1
69457: PUSH
69458: EMPTY
69459: LIST
69460: LIST
69461: PUSH
69462: LD_INT 0
69464: PUSH
69465: LD_INT 1
69467: PUSH
69468: EMPTY
69469: LIST
69470: LIST
69471: PUSH
69472: LD_INT 1
69474: NEG
69475: PUSH
69476: LD_INT 0
69478: PUSH
69479: EMPTY
69480: LIST
69481: LIST
69482: PUSH
69483: LD_INT 1
69485: NEG
69486: PUSH
69487: LD_INT 1
69489: NEG
69490: PUSH
69491: EMPTY
69492: LIST
69493: LIST
69494: PUSH
69495: LD_INT 1
69497: NEG
69498: PUSH
69499: LD_INT 2
69501: NEG
69502: PUSH
69503: EMPTY
69504: LIST
69505: LIST
69506: PUSH
69507: LD_INT 0
69509: PUSH
69510: LD_INT 2
69512: NEG
69513: PUSH
69514: EMPTY
69515: LIST
69516: LIST
69517: PUSH
69518: LD_INT 1
69520: PUSH
69521: LD_INT 1
69523: NEG
69524: PUSH
69525: EMPTY
69526: LIST
69527: LIST
69528: PUSH
69529: LD_INT 2
69531: PUSH
69532: LD_INT 0
69534: PUSH
69535: EMPTY
69536: LIST
69537: LIST
69538: PUSH
69539: LD_INT 2
69541: PUSH
69542: LD_INT 1
69544: PUSH
69545: EMPTY
69546: LIST
69547: LIST
69548: PUSH
69549: LD_INT 2
69551: PUSH
69552: LD_INT 2
69554: PUSH
69555: EMPTY
69556: LIST
69557: LIST
69558: PUSH
69559: LD_INT 1
69561: PUSH
69562: LD_INT 2
69564: PUSH
69565: EMPTY
69566: LIST
69567: LIST
69568: PUSH
69569: LD_INT 0
69571: PUSH
69572: LD_INT 2
69574: PUSH
69575: EMPTY
69576: LIST
69577: LIST
69578: PUSH
69579: LD_INT 1
69581: NEG
69582: PUSH
69583: LD_INT 1
69585: PUSH
69586: EMPTY
69587: LIST
69588: LIST
69589: PUSH
69590: LD_INT 2
69592: NEG
69593: PUSH
69594: LD_INT 0
69596: PUSH
69597: EMPTY
69598: LIST
69599: LIST
69600: PUSH
69601: LD_INT 2
69603: NEG
69604: PUSH
69605: LD_INT 1
69607: NEG
69608: PUSH
69609: EMPTY
69610: LIST
69611: LIST
69612: PUSH
69613: LD_INT 2
69615: NEG
69616: PUSH
69617: LD_INT 2
69619: NEG
69620: PUSH
69621: EMPTY
69622: LIST
69623: LIST
69624: PUSH
69625: LD_INT 3
69627: PUSH
69628: LD_INT 1
69630: PUSH
69631: EMPTY
69632: LIST
69633: LIST
69634: PUSH
69635: LD_INT 3
69637: PUSH
69638: LD_INT 2
69640: PUSH
69641: EMPTY
69642: LIST
69643: LIST
69644: PUSH
69645: LD_INT 2
69647: PUSH
69648: LD_INT 3
69650: PUSH
69651: EMPTY
69652: LIST
69653: LIST
69654: PUSH
69655: LD_INT 1
69657: PUSH
69658: LD_INT 3
69660: PUSH
69661: EMPTY
69662: LIST
69663: LIST
69664: PUSH
69665: EMPTY
69666: LIST
69667: LIST
69668: LIST
69669: LIST
69670: LIST
69671: LIST
69672: LIST
69673: LIST
69674: LIST
69675: LIST
69676: LIST
69677: LIST
69678: LIST
69679: LIST
69680: LIST
69681: LIST
69682: LIST
69683: LIST
69684: LIST
69685: LIST
69686: LIST
69687: LIST
69688: LIST
69689: ST_TO_ADDR
// fDepotRu3 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ 2 , 3 ] , [ 1 , 3 ] , [ - 1 , 2 ] , [ - 2 , 1 ] ] ;
69690: LD_ADDR_VAR 0 26
69694: PUSH
69695: LD_INT 0
69697: PUSH
69698: LD_INT 0
69700: PUSH
69701: EMPTY
69702: LIST
69703: LIST
69704: PUSH
69705: LD_INT 0
69707: PUSH
69708: LD_INT 1
69710: NEG
69711: PUSH
69712: EMPTY
69713: LIST
69714: LIST
69715: PUSH
69716: LD_INT 1
69718: PUSH
69719: LD_INT 0
69721: PUSH
69722: EMPTY
69723: LIST
69724: LIST
69725: PUSH
69726: LD_INT 1
69728: PUSH
69729: LD_INT 1
69731: PUSH
69732: EMPTY
69733: LIST
69734: LIST
69735: PUSH
69736: LD_INT 0
69738: PUSH
69739: LD_INT 1
69741: PUSH
69742: EMPTY
69743: LIST
69744: LIST
69745: PUSH
69746: LD_INT 1
69748: NEG
69749: PUSH
69750: LD_INT 0
69752: PUSH
69753: EMPTY
69754: LIST
69755: LIST
69756: PUSH
69757: LD_INT 1
69759: NEG
69760: PUSH
69761: LD_INT 1
69763: NEG
69764: PUSH
69765: EMPTY
69766: LIST
69767: LIST
69768: PUSH
69769: LD_INT 1
69771: NEG
69772: PUSH
69773: LD_INT 2
69775: NEG
69776: PUSH
69777: EMPTY
69778: LIST
69779: LIST
69780: PUSH
69781: LD_INT 0
69783: PUSH
69784: LD_INT 2
69786: NEG
69787: PUSH
69788: EMPTY
69789: LIST
69790: LIST
69791: PUSH
69792: LD_INT 1
69794: PUSH
69795: LD_INT 1
69797: NEG
69798: PUSH
69799: EMPTY
69800: LIST
69801: LIST
69802: PUSH
69803: LD_INT 2
69805: PUSH
69806: LD_INT 0
69808: PUSH
69809: EMPTY
69810: LIST
69811: LIST
69812: PUSH
69813: LD_INT 2
69815: PUSH
69816: LD_INT 1
69818: PUSH
69819: EMPTY
69820: LIST
69821: LIST
69822: PUSH
69823: LD_INT 2
69825: PUSH
69826: LD_INT 2
69828: PUSH
69829: EMPTY
69830: LIST
69831: LIST
69832: PUSH
69833: LD_INT 1
69835: PUSH
69836: LD_INT 2
69838: PUSH
69839: EMPTY
69840: LIST
69841: LIST
69842: PUSH
69843: LD_INT 0
69845: PUSH
69846: LD_INT 2
69848: PUSH
69849: EMPTY
69850: LIST
69851: LIST
69852: PUSH
69853: LD_INT 1
69855: NEG
69856: PUSH
69857: LD_INT 1
69859: PUSH
69860: EMPTY
69861: LIST
69862: LIST
69863: PUSH
69864: LD_INT 2
69866: NEG
69867: PUSH
69868: LD_INT 0
69870: PUSH
69871: EMPTY
69872: LIST
69873: LIST
69874: PUSH
69875: LD_INT 2
69877: NEG
69878: PUSH
69879: LD_INT 1
69881: NEG
69882: PUSH
69883: EMPTY
69884: LIST
69885: LIST
69886: PUSH
69887: LD_INT 2
69889: NEG
69890: PUSH
69891: LD_INT 2
69893: NEG
69894: PUSH
69895: EMPTY
69896: LIST
69897: LIST
69898: PUSH
69899: LD_INT 2
69901: PUSH
69902: LD_INT 3
69904: PUSH
69905: EMPTY
69906: LIST
69907: LIST
69908: PUSH
69909: LD_INT 1
69911: PUSH
69912: LD_INT 3
69914: PUSH
69915: EMPTY
69916: LIST
69917: LIST
69918: PUSH
69919: LD_INT 1
69921: NEG
69922: PUSH
69923: LD_INT 2
69925: PUSH
69926: EMPTY
69927: LIST
69928: LIST
69929: PUSH
69930: LD_INT 2
69932: NEG
69933: PUSH
69934: LD_INT 1
69936: PUSH
69937: EMPTY
69938: LIST
69939: LIST
69940: PUSH
69941: EMPTY
69942: LIST
69943: LIST
69944: LIST
69945: LIST
69946: LIST
69947: LIST
69948: LIST
69949: LIST
69950: LIST
69951: LIST
69952: LIST
69953: LIST
69954: LIST
69955: LIST
69956: LIST
69957: LIST
69958: LIST
69959: LIST
69960: LIST
69961: LIST
69962: LIST
69963: LIST
69964: LIST
69965: ST_TO_ADDR
// fDepotRu4 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ - 1 , 2 ] , [ - 2 , 1 ] , [ - 3 , - 1 ] , [ - 3 , - 2 ] ] ;
69966: LD_ADDR_VAR 0 27
69970: PUSH
69971: LD_INT 0
69973: PUSH
69974: LD_INT 0
69976: PUSH
69977: EMPTY
69978: LIST
69979: LIST
69980: PUSH
69981: LD_INT 0
69983: PUSH
69984: LD_INT 1
69986: NEG
69987: PUSH
69988: EMPTY
69989: LIST
69990: LIST
69991: PUSH
69992: LD_INT 1
69994: PUSH
69995: LD_INT 0
69997: PUSH
69998: EMPTY
69999: LIST
70000: LIST
70001: PUSH
70002: LD_INT 1
70004: PUSH
70005: LD_INT 1
70007: PUSH
70008: EMPTY
70009: LIST
70010: LIST
70011: PUSH
70012: LD_INT 0
70014: PUSH
70015: LD_INT 1
70017: PUSH
70018: EMPTY
70019: LIST
70020: LIST
70021: PUSH
70022: LD_INT 1
70024: NEG
70025: PUSH
70026: LD_INT 0
70028: PUSH
70029: EMPTY
70030: LIST
70031: LIST
70032: PUSH
70033: LD_INT 1
70035: NEG
70036: PUSH
70037: LD_INT 1
70039: NEG
70040: PUSH
70041: EMPTY
70042: LIST
70043: LIST
70044: PUSH
70045: LD_INT 1
70047: NEG
70048: PUSH
70049: LD_INT 2
70051: NEG
70052: PUSH
70053: EMPTY
70054: LIST
70055: LIST
70056: PUSH
70057: LD_INT 0
70059: PUSH
70060: LD_INT 2
70062: NEG
70063: PUSH
70064: EMPTY
70065: LIST
70066: LIST
70067: PUSH
70068: LD_INT 1
70070: PUSH
70071: LD_INT 1
70073: NEG
70074: PUSH
70075: EMPTY
70076: LIST
70077: LIST
70078: PUSH
70079: LD_INT 2
70081: PUSH
70082: LD_INT 0
70084: PUSH
70085: EMPTY
70086: LIST
70087: LIST
70088: PUSH
70089: LD_INT 2
70091: PUSH
70092: LD_INT 1
70094: PUSH
70095: EMPTY
70096: LIST
70097: LIST
70098: PUSH
70099: LD_INT 2
70101: PUSH
70102: LD_INT 2
70104: PUSH
70105: EMPTY
70106: LIST
70107: LIST
70108: PUSH
70109: LD_INT 1
70111: PUSH
70112: LD_INT 2
70114: PUSH
70115: EMPTY
70116: LIST
70117: LIST
70118: PUSH
70119: LD_INT 0
70121: PUSH
70122: LD_INT 2
70124: PUSH
70125: EMPTY
70126: LIST
70127: LIST
70128: PUSH
70129: LD_INT 1
70131: NEG
70132: PUSH
70133: LD_INT 1
70135: PUSH
70136: EMPTY
70137: LIST
70138: LIST
70139: PUSH
70140: LD_INT 2
70142: NEG
70143: PUSH
70144: LD_INT 0
70146: PUSH
70147: EMPTY
70148: LIST
70149: LIST
70150: PUSH
70151: LD_INT 2
70153: NEG
70154: PUSH
70155: LD_INT 1
70157: NEG
70158: PUSH
70159: EMPTY
70160: LIST
70161: LIST
70162: PUSH
70163: LD_INT 2
70165: NEG
70166: PUSH
70167: LD_INT 2
70169: NEG
70170: PUSH
70171: EMPTY
70172: LIST
70173: LIST
70174: PUSH
70175: LD_INT 1
70177: NEG
70178: PUSH
70179: LD_INT 2
70181: PUSH
70182: EMPTY
70183: LIST
70184: LIST
70185: PUSH
70186: LD_INT 2
70188: NEG
70189: PUSH
70190: LD_INT 1
70192: PUSH
70193: EMPTY
70194: LIST
70195: LIST
70196: PUSH
70197: LD_INT 3
70199: NEG
70200: PUSH
70201: LD_INT 1
70203: NEG
70204: PUSH
70205: EMPTY
70206: LIST
70207: LIST
70208: PUSH
70209: LD_INT 3
70211: NEG
70212: PUSH
70213: LD_INT 2
70215: NEG
70216: PUSH
70217: EMPTY
70218: LIST
70219: LIST
70220: PUSH
70221: EMPTY
70222: LIST
70223: LIST
70224: LIST
70225: LIST
70226: LIST
70227: LIST
70228: LIST
70229: LIST
70230: LIST
70231: LIST
70232: LIST
70233: LIST
70234: LIST
70235: LIST
70236: LIST
70237: LIST
70238: LIST
70239: LIST
70240: LIST
70241: LIST
70242: LIST
70243: LIST
70244: LIST
70245: ST_TO_ADDR
// fDepotRu5 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ - 2 , - 3 ] , [ - 1 , - 3 ] , [ - 3 , - 1 ] , [ - 3 , - 2 ] ] ;
70246: LD_ADDR_VAR 0 28
70250: PUSH
70251: LD_INT 0
70253: PUSH
70254: LD_INT 0
70256: PUSH
70257: EMPTY
70258: LIST
70259: LIST
70260: PUSH
70261: LD_INT 0
70263: PUSH
70264: LD_INT 1
70266: NEG
70267: PUSH
70268: EMPTY
70269: LIST
70270: LIST
70271: PUSH
70272: LD_INT 1
70274: PUSH
70275: LD_INT 0
70277: PUSH
70278: EMPTY
70279: LIST
70280: LIST
70281: PUSH
70282: LD_INT 1
70284: PUSH
70285: LD_INT 1
70287: PUSH
70288: EMPTY
70289: LIST
70290: LIST
70291: PUSH
70292: LD_INT 0
70294: PUSH
70295: LD_INT 1
70297: PUSH
70298: EMPTY
70299: LIST
70300: LIST
70301: PUSH
70302: LD_INT 1
70304: NEG
70305: PUSH
70306: LD_INT 0
70308: PUSH
70309: EMPTY
70310: LIST
70311: LIST
70312: PUSH
70313: LD_INT 1
70315: NEG
70316: PUSH
70317: LD_INT 1
70319: NEG
70320: PUSH
70321: EMPTY
70322: LIST
70323: LIST
70324: PUSH
70325: LD_INT 1
70327: NEG
70328: PUSH
70329: LD_INT 2
70331: NEG
70332: PUSH
70333: EMPTY
70334: LIST
70335: LIST
70336: PUSH
70337: LD_INT 0
70339: PUSH
70340: LD_INT 2
70342: NEG
70343: PUSH
70344: EMPTY
70345: LIST
70346: LIST
70347: PUSH
70348: LD_INT 1
70350: PUSH
70351: LD_INT 1
70353: NEG
70354: PUSH
70355: EMPTY
70356: LIST
70357: LIST
70358: PUSH
70359: LD_INT 2
70361: PUSH
70362: LD_INT 0
70364: PUSH
70365: EMPTY
70366: LIST
70367: LIST
70368: PUSH
70369: LD_INT 2
70371: PUSH
70372: LD_INT 1
70374: PUSH
70375: EMPTY
70376: LIST
70377: LIST
70378: PUSH
70379: LD_INT 2
70381: PUSH
70382: LD_INT 2
70384: PUSH
70385: EMPTY
70386: LIST
70387: LIST
70388: PUSH
70389: LD_INT 1
70391: PUSH
70392: LD_INT 2
70394: PUSH
70395: EMPTY
70396: LIST
70397: LIST
70398: PUSH
70399: LD_INT 0
70401: PUSH
70402: LD_INT 2
70404: PUSH
70405: EMPTY
70406: LIST
70407: LIST
70408: PUSH
70409: LD_INT 1
70411: NEG
70412: PUSH
70413: LD_INT 1
70415: PUSH
70416: EMPTY
70417: LIST
70418: LIST
70419: PUSH
70420: LD_INT 2
70422: NEG
70423: PUSH
70424: LD_INT 0
70426: PUSH
70427: EMPTY
70428: LIST
70429: LIST
70430: PUSH
70431: LD_INT 2
70433: NEG
70434: PUSH
70435: LD_INT 1
70437: NEG
70438: PUSH
70439: EMPTY
70440: LIST
70441: LIST
70442: PUSH
70443: LD_INT 2
70445: NEG
70446: PUSH
70447: LD_INT 2
70449: NEG
70450: PUSH
70451: EMPTY
70452: LIST
70453: LIST
70454: PUSH
70455: LD_INT 2
70457: NEG
70458: PUSH
70459: LD_INT 3
70461: NEG
70462: PUSH
70463: EMPTY
70464: LIST
70465: LIST
70466: PUSH
70467: LD_INT 1
70469: NEG
70470: PUSH
70471: LD_INT 3
70473: NEG
70474: PUSH
70475: EMPTY
70476: LIST
70477: LIST
70478: PUSH
70479: LD_INT 3
70481: NEG
70482: PUSH
70483: LD_INT 1
70485: NEG
70486: PUSH
70487: EMPTY
70488: LIST
70489: LIST
70490: PUSH
70491: LD_INT 3
70493: NEG
70494: PUSH
70495: LD_INT 2
70497: NEG
70498: PUSH
70499: EMPTY
70500: LIST
70501: LIST
70502: PUSH
70503: EMPTY
70504: LIST
70505: LIST
70506: LIST
70507: LIST
70508: LIST
70509: LIST
70510: LIST
70511: LIST
70512: LIST
70513: LIST
70514: LIST
70515: LIST
70516: LIST
70517: LIST
70518: LIST
70519: LIST
70520: LIST
70521: LIST
70522: LIST
70523: LIST
70524: LIST
70525: LIST
70526: LIST
70527: ST_TO_ADDR
// fFactory0 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ - 2 , - 3 ] , [ 2 , - 1 ] , [ 3 , 1 ] , [ 1 , 3 ] , [ - 1 , 2 ] , [ - 3 , - 2 ] ] ;
70528: LD_ADDR_VAR 0 29
70532: PUSH
70533: LD_INT 0
70535: PUSH
70536: LD_INT 0
70538: PUSH
70539: EMPTY
70540: LIST
70541: LIST
70542: PUSH
70543: LD_INT 0
70545: PUSH
70546: LD_INT 1
70548: NEG
70549: PUSH
70550: EMPTY
70551: LIST
70552: LIST
70553: PUSH
70554: LD_INT 1
70556: PUSH
70557: LD_INT 0
70559: PUSH
70560: EMPTY
70561: LIST
70562: LIST
70563: PUSH
70564: LD_INT 1
70566: PUSH
70567: LD_INT 1
70569: PUSH
70570: EMPTY
70571: LIST
70572: LIST
70573: PUSH
70574: LD_INT 0
70576: PUSH
70577: LD_INT 1
70579: PUSH
70580: EMPTY
70581: LIST
70582: LIST
70583: PUSH
70584: LD_INT 1
70586: NEG
70587: PUSH
70588: LD_INT 0
70590: PUSH
70591: EMPTY
70592: LIST
70593: LIST
70594: PUSH
70595: LD_INT 1
70597: NEG
70598: PUSH
70599: LD_INT 1
70601: NEG
70602: PUSH
70603: EMPTY
70604: LIST
70605: LIST
70606: PUSH
70607: LD_INT 1
70609: NEG
70610: PUSH
70611: LD_INT 2
70613: NEG
70614: PUSH
70615: EMPTY
70616: LIST
70617: LIST
70618: PUSH
70619: LD_INT 0
70621: PUSH
70622: LD_INT 2
70624: NEG
70625: PUSH
70626: EMPTY
70627: LIST
70628: LIST
70629: PUSH
70630: LD_INT 1
70632: PUSH
70633: LD_INT 1
70635: NEG
70636: PUSH
70637: EMPTY
70638: LIST
70639: LIST
70640: PUSH
70641: LD_INT 2
70643: PUSH
70644: LD_INT 0
70646: PUSH
70647: EMPTY
70648: LIST
70649: LIST
70650: PUSH
70651: LD_INT 2
70653: PUSH
70654: LD_INT 1
70656: PUSH
70657: EMPTY
70658: LIST
70659: LIST
70660: PUSH
70661: LD_INT 1
70663: PUSH
70664: LD_INT 2
70666: PUSH
70667: EMPTY
70668: LIST
70669: LIST
70670: PUSH
70671: LD_INT 0
70673: PUSH
70674: LD_INT 2
70676: PUSH
70677: EMPTY
70678: LIST
70679: LIST
70680: PUSH
70681: LD_INT 1
70683: NEG
70684: PUSH
70685: LD_INT 1
70687: PUSH
70688: EMPTY
70689: LIST
70690: LIST
70691: PUSH
70692: LD_INT 2
70694: NEG
70695: PUSH
70696: LD_INT 1
70698: NEG
70699: PUSH
70700: EMPTY
70701: LIST
70702: LIST
70703: PUSH
70704: LD_INT 2
70706: NEG
70707: PUSH
70708: LD_INT 2
70710: NEG
70711: PUSH
70712: EMPTY
70713: LIST
70714: LIST
70715: PUSH
70716: LD_INT 2
70718: NEG
70719: PUSH
70720: LD_INT 3
70722: NEG
70723: PUSH
70724: EMPTY
70725: LIST
70726: LIST
70727: PUSH
70728: LD_INT 2
70730: PUSH
70731: LD_INT 1
70733: NEG
70734: PUSH
70735: EMPTY
70736: LIST
70737: LIST
70738: PUSH
70739: LD_INT 3
70741: PUSH
70742: LD_INT 1
70744: PUSH
70745: EMPTY
70746: LIST
70747: LIST
70748: PUSH
70749: LD_INT 1
70751: PUSH
70752: LD_INT 3
70754: PUSH
70755: EMPTY
70756: LIST
70757: LIST
70758: PUSH
70759: LD_INT 1
70761: NEG
70762: PUSH
70763: LD_INT 2
70765: PUSH
70766: EMPTY
70767: LIST
70768: LIST
70769: PUSH
70770: LD_INT 3
70772: NEG
70773: PUSH
70774: LD_INT 2
70776: NEG
70777: PUSH
70778: EMPTY
70779: LIST
70780: LIST
70781: PUSH
70782: EMPTY
70783: LIST
70784: LIST
70785: LIST
70786: LIST
70787: LIST
70788: LIST
70789: LIST
70790: LIST
70791: LIST
70792: LIST
70793: LIST
70794: LIST
70795: LIST
70796: LIST
70797: LIST
70798: LIST
70799: LIST
70800: LIST
70801: LIST
70802: LIST
70803: LIST
70804: LIST
70805: LIST
70806: ST_TO_ADDR
// fFactory1 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 1 , - 3 ] , [ 1 , - 2 ] , [ 3 , 2 ] , [ 2 , 3 ] , [ - 2 , 1 ] , [ - 3 , - 1 ] ] ;
70807: LD_ADDR_VAR 0 30
70811: PUSH
70812: LD_INT 0
70814: PUSH
70815: LD_INT 0
70817: PUSH
70818: EMPTY
70819: LIST
70820: LIST
70821: PUSH
70822: LD_INT 0
70824: PUSH
70825: LD_INT 1
70827: NEG
70828: PUSH
70829: EMPTY
70830: LIST
70831: LIST
70832: PUSH
70833: LD_INT 1
70835: PUSH
70836: LD_INT 0
70838: PUSH
70839: EMPTY
70840: LIST
70841: LIST
70842: PUSH
70843: LD_INT 1
70845: PUSH
70846: LD_INT 1
70848: PUSH
70849: EMPTY
70850: LIST
70851: LIST
70852: PUSH
70853: LD_INT 0
70855: PUSH
70856: LD_INT 1
70858: PUSH
70859: EMPTY
70860: LIST
70861: LIST
70862: PUSH
70863: LD_INT 1
70865: NEG
70866: PUSH
70867: LD_INT 0
70869: PUSH
70870: EMPTY
70871: LIST
70872: LIST
70873: PUSH
70874: LD_INT 1
70876: NEG
70877: PUSH
70878: LD_INT 1
70880: NEG
70881: PUSH
70882: EMPTY
70883: LIST
70884: LIST
70885: PUSH
70886: LD_INT 1
70888: NEG
70889: PUSH
70890: LD_INT 2
70892: NEG
70893: PUSH
70894: EMPTY
70895: LIST
70896: LIST
70897: PUSH
70898: LD_INT 0
70900: PUSH
70901: LD_INT 2
70903: NEG
70904: PUSH
70905: EMPTY
70906: LIST
70907: LIST
70908: PUSH
70909: LD_INT 1
70911: PUSH
70912: LD_INT 1
70914: NEG
70915: PUSH
70916: EMPTY
70917: LIST
70918: LIST
70919: PUSH
70920: LD_INT 2
70922: PUSH
70923: LD_INT 0
70925: PUSH
70926: EMPTY
70927: LIST
70928: LIST
70929: PUSH
70930: LD_INT 2
70932: PUSH
70933: LD_INT 1
70935: PUSH
70936: EMPTY
70937: LIST
70938: LIST
70939: PUSH
70940: LD_INT 2
70942: PUSH
70943: LD_INT 2
70945: PUSH
70946: EMPTY
70947: LIST
70948: LIST
70949: PUSH
70950: LD_INT 1
70952: PUSH
70953: LD_INT 2
70955: PUSH
70956: EMPTY
70957: LIST
70958: LIST
70959: PUSH
70960: LD_INT 1
70962: NEG
70963: PUSH
70964: LD_INT 1
70966: PUSH
70967: EMPTY
70968: LIST
70969: LIST
70970: PUSH
70971: LD_INT 2
70973: NEG
70974: PUSH
70975: LD_INT 0
70977: PUSH
70978: EMPTY
70979: LIST
70980: LIST
70981: PUSH
70982: LD_INT 2
70984: NEG
70985: PUSH
70986: LD_INT 1
70988: NEG
70989: PUSH
70990: EMPTY
70991: LIST
70992: LIST
70993: PUSH
70994: LD_INT 1
70996: NEG
70997: PUSH
70998: LD_INT 3
71000: NEG
71001: PUSH
71002: EMPTY
71003: LIST
71004: LIST
71005: PUSH
71006: LD_INT 1
71008: PUSH
71009: LD_INT 2
71011: NEG
71012: PUSH
71013: EMPTY
71014: LIST
71015: LIST
71016: PUSH
71017: LD_INT 3
71019: PUSH
71020: LD_INT 2
71022: PUSH
71023: EMPTY
71024: LIST
71025: LIST
71026: PUSH
71027: LD_INT 2
71029: PUSH
71030: LD_INT 3
71032: PUSH
71033: EMPTY
71034: LIST
71035: LIST
71036: PUSH
71037: LD_INT 2
71039: NEG
71040: PUSH
71041: LD_INT 1
71043: PUSH
71044: EMPTY
71045: LIST
71046: LIST
71047: PUSH
71048: LD_INT 3
71050: NEG
71051: PUSH
71052: LD_INT 1
71054: NEG
71055: PUSH
71056: EMPTY
71057: LIST
71058: LIST
71059: PUSH
71060: EMPTY
71061: LIST
71062: LIST
71063: LIST
71064: LIST
71065: LIST
71066: LIST
71067: LIST
71068: LIST
71069: LIST
71070: LIST
71071: LIST
71072: LIST
71073: LIST
71074: LIST
71075: LIST
71076: LIST
71077: LIST
71078: LIST
71079: LIST
71080: LIST
71081: LIST
71082: LIST
71083: LIST
71084: ST_TO_ADDR
// fFactory2 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ - 2 , - 3 ] , [ 2 , - 1 ] , [ 3 , 1 ] , [ 1 , 3 ] , [ - 1 , 2 ] , [ - 3 , - 2 ] ] ;
71085: LD_ADDR_VAR 0 31
71089: PUSH
71090: LD_INT 0
71092: PUSH
71093: LD_INT 0
71095: PUSH
71096: EMPTY
71097: LIST
71098: LIST
71099: PUSH
71100: LD_INT 0
71102: PUSH
71103: LD_INT 1
71105: NEG
71106: PUSH
71107: EMPTY
71108: LIST
71109: LIST
71110: PUSH
71111: LD_INT 1
71113: PUSH
71114: LD_INT 0
71116: PUSH
71117: EMPTY
71118: LIST
71119: LIST
71120: PUSH
71121: LD_INT 1
71123: PUSH
71124: LD_INT 1
71126: PUSH
71127: EMPTY
71128: LIST
71129: LIST
71130: PUSH
71131: LD_INT 0
71133: PUSH
71134: LD_INT 1
71136: PUSH
71137: EMPTY
71138: LIST
71139: LIST
71140: PUSH
71141: LD_INT 1
71143: NEG
71144: PUSH
71145: LD_INT 0
71147: PUSH
71148: EMPTY
71149: LIST
71150: LIST
71151: PUSH
71152: LD_INT 1
71154: NEG
71155: PUSH
71156: LD_INT 1
71158: NEG
71159: PUSH
71160: EMPTY
71161: LIST
71162: LIST
71163: PUSH
71164: LD_INT 1
71166: NEG
71167: PUSH
71168: LD_INT 2
71170: NEG
71171: PUSH
71172: EMPTY
71173: LIST
71174: LIST
71175: PUSH
71176: LD_INT 1
71178: PUSH
71179: LD_INT 1
71181: NEG
71182: PUSH
71183: EMPTY
71184: LIST
71185: LIST
71186: PUSH
71187: LD_INT 2
71189: PUSH
71190: LD_INT 0
71192: PUSH
71193: EMPTY
71194: LIST
71195: LIST
71196: PUSH
71197: LD_INT 2
71199: PUSH
71200: LD_INT 1
71202: PUSH
71203: EMPTY
71204: LIST
71205: LIST
71206: PUSH
71207: LD_INT 2
71209: PUSH
71210: LD_INT 2
71212: PUSH
71213: EMPTY
71214: LIST
71215: LIST
71216: PUSH
71217: LD_INT 1
71219: PUSH
71220: LD_INT 2
71222: PUSH
71223: EMPTY
71224: LIST
71225: LIST
71226: PUSH
71227: LD_INT 0
71229: PUSH
71230: LD_INT 2
71232: PUSH
71233: EMPTY
71234: LIST
71235: LIST
71236: PUSH
71237: LD_INT 1
71239: NEG
71240: PUSH
71241: LD_INT 1
71243: PUSH
71244: EMPTY
71245: LIST
71246: LIST
71247: PUSH
71248: LD_INT 2
71250: NEG
71251: PUSH
71252: LD_INT 1
71254: NEG
71255: PUSH
71256: EMPTY
71257: LIST
71258: LIST
71259: PUSH
71260: LD_INT 2
71262: NEG
71263: PUSH
71264: LD_INT 2
71266: NEG
71267: PUSH
71268: EMPTY
71269: LIST
71270: LIST
71271: PUSH
71272: LD_INT 2
71274: NEG
71275: PUSH
71276: LD_INT 3
71278: NEG
71279: PUSH
71280: EMPTY
71281: LIST
71282: LIST
71283: PUSH
71284: LD_INT 2
71286: PUSH
71287: LD_INT 1
71289: NEG
71290: PUSH
71291: EMPTY
71292: LIST
71293: LIST
71294: PUSH
71295: LD_INT 3
71297: PUSH
71298: LD_INT 1
71300: PUSH
71301: EMPTY
71302: LIST
71303: LIST
71304: PUSH
71305: LD_INT 1
71307: PUSH
71308: LD_INT 3
71310: PUSH
71311: EMPTY
71312: LIST
71313: LIST
71314: PUSH
71315: LD_INT 1
71317: NEG
71318: PUSH
71319: LD_INT 2
71321: PUSH
71322: EMPTY
71323: LIST
71324: LIST
71325: PUSH
71326: LD_INT 3
71328: NEG
71329: PUSH
71330: LD_INT 2
71332: NEG
71333: PUSH
71334: EMPTY
71335: LIST
71336: LIST
71337: PUSH
71338: EMPTY
71339: LIST
71340: LIST
71341: LIST
71342: LIST
71343: LIST
71344: LIST
71345: LIST
71346: LIST
71347: LIST
71348: LIST
71349: LIST
71350: LIST
71351: LIST
71352: LIST
71353: LIST
71354: LIST
71355: LIST
71356: LIST
71357: LIST
71358: LIST
71359: LIST
71360: LIST
71361: LIST
71362: ST_TO_ADDR
// fFactory3 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 1 , - 3 ] , [ 1 , - 2 ] , [ 3 , 2 ] , [ 2 , 3 ] , [ - 2 , 1 ] , [ - 3 , - 1 ] ] ;
71363: LD_ADDR_VAR 0 32
71367: PUSH
71368: LD_INT 0
71370: PUSH
71371: LD_INT 0
71373: PUSH
71374: EMPTY
71375: LIST
71376: LIST
71377: PUSH
71378: LD_INT 0
71380: PUSH
71381: LD_INT 1
71383: NEG
71384: PUSH
71385: EMPTY
71386: LIST
71387: LIST
71388: PUSH
71389: LD_INT 1
71391: PUSH
71392: LD_INT 0
71394: PUSH
71395: EMPTY
71396: LIST
71397: LIST
71398: PUSH
71399: LD_INT 1
71401: PUSH
71402: LD_INT 1
71404: PUSH
71405: EMPTY
71406: LIST
71407: LIST
71408: PUSH
71409: LD_INT 0
71411: PUSH
71412: LD_INT 1
71414: PUSH
71415: EMPTY
71416: LIST
71417: LIST
71418: PUSH
71419: LD_INT 1
71421: NEG
71422: PUSH
71423: LD_INT 0
71425: PUSH
71426: EMPTY
71427: LIST
71428: LIST
71429: PUSH
71430: LD_INT 1
71432: NEG
71433: PUSH
71434: LD_INT 1
71436: NEG
71437: PUSH
71438: EMPTY
71439: LIST
71440: LIST
71441: PUSH
71442: LD_INT 1
71444: NEG
71445: PUSH
71446: LD_INT 2
71448: NEG
71449: PUSH
71450: EMPTY
71451: LIST
71452: LIST
71453: PUSH
71454: LD_INT 0
71456: PUSH
71457: LD_INT 2
71459: NEG
71460: PUSH
71461: EMPTY
71462: LIST
71463: LIST
71464: PUSH
71465: LD_INT 1
71467: PUSH
71468: LD_INT 1
71470: NEG
71471: PUSH
71472: EMPTY
71473: LIST
71474: LIST
71475: PUSH
71476: LD_INT 2
71478: PUSH
71479: LD_INT 1
71481: PUSH
71482: EMPTY
71483: LIST
71484: LIST
71485: PUSH
71486: LD_INT 2
71488: PUSH
71489: LD_INT 2
71491: PUSH
71492: EMPTY
71493: LIST
71494: LIST
71495: PUSH
71496: LD_INT 1
71498: PUSH
71499: LD_INT 2
71501: PUSH
71502: EMPTY
71503: LIST
71504: LIST
71505: PUSH
71506: LD_INT 0
71508: PUSH
71509: LD_INT 2
71511: PUSH
71512: EMPTY
71513: LIST
71514: LIST
71515: PUSH
71516: LD_INT 1
71518: NEG
71519: PUSH
71520: LD_INT 1
71522: PUSH
71523: EMPTY
71524: LIST
71525: LIST
71526: PUSH
71527: LD_INT 2
71529: NEG
71530: PUSH
71531: LD_INT 0
71533: PUSH
71534: EMPTY
71535: LIST
71536: LIST
71537: PUSH
71538: LD_INT 2
71540: NEG
71541: PUSH
71542: LD_INT 1
71544: NEG
71545: PUSH
71546: EMPTY
71547: LIST
71548: LIST
71549: PUSH
71550: LD_INT 1
71552: NEG
71553: PUSH
71554: LD_INT 3
71556: NEG
71557: PUSH
71558: EMPTY
71559: LIST
71560: LIST
71561: PUSH
71562: LD_INT 1
71564: PUSH
71565: LD_INT 2
71567: NEG
71568: PUSH
71569: EMPTY
71570: LIST
71571: LIST
71572: PUSH
71573: LD_INT 3
71575: PUSH
71576: LD_INT 2
71578: PUSH
71579: EMPTY
71580: LIST
71581: LIST
71582: PUSH
71583: LD_INT 2
71585: PUSH
71586: LD_INT 3
71588: PUSH
71589: EMPTY
71590: LIST
71591: LIST
71592: PUSH
71593: LD_INT 2
71595: NEG
71596: PUSH
71597: LD_INT 1
71599: PUSH
71600: EMPTY
71601: LIST
71602: LIST
71603: PUSH
71604: LD_INT 3
71606: NEG
71607: PUSH
71608: LD_INT 1
71610: NEG
71611: PUSH
71612: EMPTY
71613: LIST
71614: LIST
71615: PUSH
71616: EMPTY
71617: LIST
71618: LIST
71619: LIST
71620: LIST
71621: LIST
71622: LIST
71623: LIST
71624: LIST
71625: LIST
71626: LIST
71627: LIST
71628: LIST
71629: LIST
71630: LIST
71631: LIST
71632: LIST
71633: LIST
71634: LIST
71635: LIST
71636: LIST
71637: LIST
71638: LIST
71639: LIST
71640: ST_TO_ADDR
// fFactory4 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ - 2 , - 3 ] , [ 2 , - 1 ] , [ 3 , 1 ] , [ 1 , 3 ] , [ - 1 , 2 ] , [ - 3 , - 2 ] ] ;
71641: LD_ADDR_VAR 0 33
71645: PUSH
71646: LD_INT 0
71648: PUSH
71649: LD_INT 0
71651: PUSH
71652: EMPTY
71653: LIST
71654: LIST
71655: PUSH
71656: LD_INT 0
71658: PUSH
71659: LD_INT 1
71661: NEG
71662: PUSH
71663: EMPTY
71664: LIST
71665: LIST
71666: PUSH
71667: LD_INT 1
71669: PUSH
71670: LD_INT 0
71672: PUSH
71673: EMPTY
71674: LIST
71675: LIST
71676: PUSH
71677: LD_INT 1
71679: PUSH
71680: LD_INT 1
71682: PUSH
71683: EMPTY
71684: LIST
71685: LIST
71686: PUSH
71687: LD_INT 0
71689: PUSH
71690: LD_INT 1
71692: PUSH
71693: EMPTY
71694: LIST
71695: LIST
71696: PUSH
71697: LD_INT 1
71699: NEG
71700: PUSH
71701: LD_INT 0
71703: PUSH
71704: EMPTY
71705: LIST
71706: LIST
71707: PUSH
71708: LD_INT 1
71710: NEG
71711: PUSH
71712: LD_INT 1
71714: NEG
71715: PUSH
71716: EMPTY
71717: LIST
71718: LIST
71719: PUSH
71720: LD_INT 1
71722: NEG
71723: PUSH
71724: LD_INT 2
71726: NEG
71727: PUSH
71728: EMPTY
71729: LIST
71730: LIST
71731: PUSH
71732: LD_INT 1
71734: PUSH
71735: LD_INT 1
71737: NEG
71738: PUSH
71739: EMPTY
71740: LIST
71741: LIST
71742: PUSH
71743: LD_INT 2
71745: PUSH
71746: LD_INT 0
71748: PUSH
71749: EMPTY
71750: LIST
71751: LIST
71752: PUSH
71753: LD_INT 2
71755: PUSH
71756: LD_INT 1
71758: PUSH
71759: EMPTY
71760: LIST
71761: LIST
71762: PUSH
71763: LD_INT 1
71765: PUSH
71766: LD_INT 2
71768: PUSH
71769: EMPTY
71770: LIST
71771: LIST
71772: PUSH
71773: LD_INT 0
71775: PUSH
71776: LD_INT 2
71778: PUSH
71779: EMPTY
71780: LIST
71781: LIST
71782: PUSH
71783: LD_INT 1
71785: NEG
71786: PUSH
71787: LD_INT 1
71789: PUSH
71790: EMPTY
71791: LIST
71792: LIST
71793: PUSH
71794: LD_INT 2
71796: NEG
71797: PUSH
71798: LD_INT 0
71800: PUSH
71801: EMPTY
71802: LIST
71803: LIST
71804: PUSH
71805: LD_INT 2
71807: NEG
71808: PUSH
71809: LD_INT 1
71811: NEG
71812: PUSH
71813: EMPTY
71814: LIST
71815: LIST
71816: PUSH
71817: LD_INT 2
71819: NEG
71820: PUSH
71821: LD_INT 2
71823: NEG
71824: PUSH
71825: EMPTY
71826: LIST
71827: LIST
71828: PUSH
71829: LD_INT 2
71831: NEG
71832: PUSH
71833: LD_INT 3
71835: NEG
71836: PUSH
71837: EMPTY
71838: LIST
71839: LIST
71840: PUSH
71841: LD_INT 2
71843: PUSH
71844: LD_INT 1
71846: NEG
71847: PUSH
71848: EMPTY
71849: LIST
71850: LIST
71851: PUSH
71852: LD_INT 3
71854: PUSH
71855: LD_INT 1
71857: PUSH
71858: EMPTY
71859: LIST
71860: LIST
71861: PUSH
71862: LD_INT 1
71864: PUSH
71865: LD_INT 3
71867: PUSH
71868: EMPTY
71869: LIST
71870: LIST
71871: PUSH
71872: LD_INT 1
71874: NEG
71875: PUSH
71876: LD_INT 2
71878: PUSH
71879: EMPTY
71880: LIST
71881: LIST
71882: PUSH
71883: LD_INT 3
71885: NEG
71886: PUSH
71887: LD_INT 2
71889: NEG
71890: PUSH
71891: EMPTY
71892: LIST
71893: LIST
71894: PUSH
71895: EMPTY
71896: LIST
71897: LIST
71898: LIST
71899: LIST
71900: LIST
71901: LIST
71902: LIST
71903: LIST
71904: LIST
71905: LIST
71906: LIST
71907: LIST
71908: LIST
71909: LIST
71910: LIST
71911: LIST
71912: LIST
71913: LIST
71914: LIST
71915: LIST
71916: LIST
71917: LIST
71918: LIST
71919: ST_TO_ADDR
// fFactory5 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ - 1 , - 3 ] , [ 1 , - 2 ] , [ 3 , 2 ] , [ 2 , 3 ] , [ - 2 , 1 ] , [ - 3 , - 1 ] ] ;
71920: LD_ADDR_VAR 0 34
71924: PUSH
71925: LD_INT 0
71927: PUSH
71928: LD_INT 0
71930: PUSH
71931: EMPTY
71932: LIST
71933: LIST
71934: PUSH
71935: LD_INT 0
71937: PUSH
71938: LD_INT 1
71940: NEG
71941: PUSH
71942: EMPTY
71943: LIST
71944: LIST
71945: PUSH
71946: LD_INT 1
71948: PUSH
71949: LD_INT 0
71951: PUSH
71952: EMPTY
71953: LIST
71954: LIST
71955: PUSH
71956: LD_INT 1
71958: PUSH
71959: LD_INT 1
71961: PUSH
71962: EMPTY
71963: LIST
71964: LIST
71965: PUSH
71966: LD_INT 0
71968: PUSH
71969: LD_INT 1
71971: PUSH
71972: EMPTY
71973: LIST
71974: LIST
71975: PUSH
71976: LD_INT 1
71978: NEG
71979: PUSH
71980: LD_INT 0
71982: PUSH
71983: EMPTY
71984: LIST
71985: LIST
71986: PUSH
71987: LD_INT 1
71989: NEG
71990: PUSH
71991: LD_INT 1
71993: NEG
71994: PUSH
71995: EMPTY
71996: LIST
71997: LIST
71998: PUSH
71999: LD_INT 1
72001: NEG
72002: PUSH
72003: LD_INT 2
72005: NEG
72006: PUSH
72007: EMPTY
72008: LIST
72009: LIST
72010: PUSH
72011: LD_INT 0
72013: PUSH
72014: LD_INT 2
72016: NEG
72017: PUSH
72018: EMPTY
72019: LIST
72020: LIST
72021: PUSH
72022: LD_INT 1
72024: PUSH
72025: LD_INT 1
72027: NEG
72028: PUSH
72029: EMPTY
72030: LIST
72031: LIST
72032: PUSH
72033: LD_INT 2
72035: PUSH
72036: LD_INT 1
72038: PUSH
72039: EMPTY
72040: LIST
72041: LIST
72042: PUSH
72043: LD_INT 2
72045: PUSH
72046: LD_INT 2
72048: PUSH
72049: EMPTY
72050: LIST
72051: LIST
72052: PUSH
72053: LD_INT 1
72055: PUSH
72056: LD_INT 2
72058: PUSH
72059: EMPTY
72060: LIST
72061: LIST
72062: PUSH
72063: LD_INT 1
72065: NEG
72066: PUSH
72067: LD_INT 1
72069: PUSH
72070: EMPTY
72071: LIST
72072: LIST
72073: PUSH
72074: LD_INT 2
72076: NEG
72077: PUSH
72078: LD_INT 0
72080: PUSH
72081: EMPTY
72082: LIST
72083: LIST
72084: PUSH
72085: LD_INT 2
72087: NEG
72088: PUSH
72089: LD_INT 1
72091: NEG
72092: PUSH
72093: EMPTY
72094: LIST
72095: LIST
72096: PUSH
72097: LD_INT 2
72099: NEG
72100: PUSH
72101: LD_INT 2
72103: NEG
72104: PUSH
72105: EMPTY
72106: LIST
72107: LIST
72108: PUSH
72109: LD_INT 1
72111: NEG
72112: PUSH
72113: LD_INT 3
72115: NEG
72116: PUSH
72117: EMPTY
72118: LIST
72119: LIST
72120: PUSH
72121: LD_INT 1
72123: PUSH
72124: LD_INT 2
72126: NEG
72127: PUSH
72128: EMPTY
72129: LIST
72130: LIST
72131: PUSH
72132: LD_INT 3
72134: PUSH
72135: LD_INT 2
72137: PUSH
72138: EMPTY
72139: LIST
72140: LIST
72141: PUSH
72142: LD_INT 2
72144: PUSH
72145: LD_INT 3
72147: PUSH
72148: EMPTY
72149: LIST
72150: LIST
72151: PUSH
72152: LD_INT 2
72154: NEG
72155: PUSH
72156: LD_INT 1
72158: PUSH
72159: EMPTY
72160: LIST
72161: LIST
72162: PUSH
72163: LD_INT 3
72165: NEG
72166: PUSH
72167: LD_INT 1
72169: NEG
72170: PUSH
72171: EMPTY
72172: LIST
72173: LIST
72174: PUSH
72175: EMPTY
72176: LIST
72177: LIST
72178: LIST
72179: LIST
72180: LIST
72181: LIST
72182: LIST
72183: LIST
72184: LIST
72185: LIST
72186: LIST
72187: LIST
72188: LIST
72189: LIST
72190: LIST
72191: LIST
72192: LIST
72193: LIST
72194: LIST
72195: LIST
72196: LIST
72197: LIST
72198: LIST
72199: ST_TO_ADDR
// fExt0 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ 2 , 1 ] , [ - 2 , - 1 ] ] ;
72200: LD_ADDR_VAR 0 35
72204: PUSH
72205: LD_INT 0
72207: PUSH
72208: LD_INT 0
72210: PUSH
72211: EMPTY
72212: LIST
72213: LIST
72214: PUSH
72215: LD_INT 0
72217: PUSH
72218: LD_INT 1
72220: NEG
72221: PUSH
72222: EMPTY
72223: LIST
72224: LIST
72225: PUSH
72226: LD_INT 1
72228: PUSH
72229: LD_INT 0
72231: PUSH
72232: EMPTY
72233: LIST
72234: LIST
72235: PUSH
72236: LD_INT 1
72238: PUSH
72239: LD_INT 1
72241: PUSH
72242: EMPTY
72243: LIST
72244: LIST
72245: PUSH
72246: LD_INT 0
72248: PUSH
72249: LD_INT 1
72251: PUSH
72252: EMPTY
72253: LIST
72254: LIST
72255: PUSH
72256: LD_INT 1
72258: NEG
72259: PUSH
72260: LD_INT 0
72262: PUSH
72263: EMPTY
72264: LIST
72265: LIST
72266: PUSH
72267: LD_INT 1
72269: NEG
72270: PUSH
72271: LD_INT 1
72273: NEG
72274: PUSH
72275: EMPTY
72276: LIST
72277: LIST
72278: PUSH
72279: LD_INT 2
72281: PUSH
72282: LD_INT 1
72284: PUSH
72285: EMPTY
72286: LIST
72287: LIST
72288: PUSH
72289: LD_INT 2
72291: NEG
72292: PUSH
72293: LD_INT 1
72295: NEG
72296: PUSH
72297: EMPTY
72298: LIST
72299: LIST
72300: PUSH
72301: EMPTY
72302: LIST
72303: LIST
72304: LIST
72305: LIST
72306: LIST
72307: LIST
72308: LIST
72309: LIST
72310: LIST
72311: ST_TO_ADDR
// fExt1 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 1 , 2 ] ] ;
72312: LD_ADDR_VAR 0 36
72316: PUSH
72317: LD_INT 0
72319: PUSH
72320: LD_INT 0
72322: PUSH
72323: EMPTY
72324: LIST
72325: LIST
72326: PUSH
72327: LD_INT 0
72329: PUSH
72330: LD_INT 1
72332: NEG
72333: PUSH
72334: EMPTY
72335: LIST
72336: LIST
72337: PUSH
72338: LD_INT 1
72340: PUSH
72341: LD_INT 0
72343: PUSH
72344: EMPTY
72345: LIST
72346: LIST
72347: PUSH
72348: LD_INT 1
72350: PUSH
72351: LD_INT 1
72353: PUSH
72354: EMPTY
72355: LIST
72356: LIST
72357: PUSH
72358: LD_INT 0
72360: PUSH
72361: LD_INT 1
72363: PUSH
72364: EMPTY
72365: LIST
72366: LIST
72367: PUSH
72368: LD_INT 1
72370: NEG
72371: PUSH
72372: LD_INT 0
72374: PUSH
72375: EMPTY
72376: LIST
72377: LIST
72378: PUSH
72379: LD_INT 1
72381: NEG
72382: PUSH
72383: LD_INT 1
72385: NEG
72386: PUSH
72387: EMPTY
72388: LIST
72389: LIST
72390: PUSH
72391: LD_INT 1
72393: NEG
72394: PUSH
72395: LD_INT 2
72397: NEG
72398: PUSH
72399: EMPTY
72400: LIST
72401: LIST
72402: PUSH
72403: LD_INT 1
72405: PUSH
72406: LD_INT 2
72408: PUSH
72409: EMPTY
72410: LIST
72411: LIST
72412: PUSH
72413: EMPTY
72414: LIST
72415: LIST
72416: LIST
72417: LIST
72418: LIST
72419: LIST
72420: LIST
72421: LIST
72422: LIST
72423: ST_TO_ADDR
// fExt2 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ 1 , - 1 ] , [ - 1 , 1 ] ] ;
72424: LD_ADDR_VAR 0 37
72428: PUSH
72429: LD_INT 0
72431: PUSH
72432: LD_INT 0
72434: PUSH
72435: EMPTY
72436: LIST
72437: LIST
72438: PUSH
72439: LD_INT 0
72441: PUSH
72442: LD_INT 1
72444: NEG
72445: PUSH
72446: EMPTY
72447: LIST
72448: LIST
72449: PUSH
72450: LD_INT 1
72452: PUSH
72453: LD_INT 0
72455: PUSH
72456: EMPTY
72457: LIST
72458: LIST
72459: PUSH
72460: LD_INT 1
72462: PUSH
72463: LD_INT 1
72465: PUSH
72466: EMPTY
72467: LIST
72468: LIST
72469: PUSH
72470: LD_INT 0
72472: PUSH
72473: LD_INT 1
72475: PUSH
72476: EMPTY
72477: LIST
72478: LIST
72479: PUSH
72480: LD_INT 1
72482: NEG
72483: PUSH
72484: LD_INT 0
72486: PUSH
72487: EMPTY
72488: LIST
72489: LIST
72490: PUSH
72491: LD_INT 1
72493: NEG
72494: PUSH
72495: LD_INT 1
72497: NEG
72498: PUSH
72499: EMPTY
72500: LIST
72501: LIST
72502: PUSH
72503: LD_INT 1
72505: PUSH
72506: LD_INT 1
72508: NEG
72509: PUSH
72510: EMPTY
72511: LIST
72512: LIST
72513: PUSH
72514: LD_INT 1
72516: NEG
72517: PUSH
72518: LD_INT 1
72520: PUSH
72521: EMPTY
72522: LIST
72523: LIST
72524: PUSH
72525: EMPTY
72526: LIST
72527: LIST
72528: LIST
72529: LIST
72530: LIST
72531: LIST
72532: LIST
72533: LIST
72534: LIST
72535: ST_TO_ADDR
// fExt3 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ 2 , 1 ] , [ - 2 , - 1 ] ] ;
72536: LD_ADDR_VAR 0 38
72540: PUSH
72541: LD_INT 0
72543: PUSH
72544: LD_INT 0
72546: PUSH
72547: EMPTY
72548: LIST
72549: LIST
72550: PUSH
72551: LD_INT 0
72553: PUSH
72554: LD_INT 1
72556: NEG
72557: PUSH
72558: EMPTY
72559: LIST
72560: LIST
72561: PUSH
72562: LD_INT 1
72564: PUSH
72565: LD_INT 0
72567: PUSH
72568: EMPTY
72569: LIST
72570: LIST
72571: PUSH
72572: LD_INT 1
72574: PUSH
72575: LD_INT 1
72577: PUSH
72578: EMPTY
72579: LIST
72580: LIST
72581: PUSH
72582: LD_INT 0
72584: PUSH
72585: LD_INT 1
72587: PUSH
72588: EMPTY
72589: LIST
72590: LIST
72591: PUSH
72592: LD_INT 1
72594: NEG
72595: PUSH
72596: LD_INT 0
72598: PUSH
72599: EMPTY
72600: LIST
72601: LIST
72602: PUSH
72603: LD_INT 1
72605: NEG
72606: PUSH
72607: LD_INT 1
72609: NEG
72610: PUSH
72611: EMPTY
72612: LIST
72613: LIST
72614: PUSH
72615: LD_INT 2
72617: PUSH
72618: LD_INT 1
72620: PUSH
72621: EMPTY
72622: LIST
72623: LIST
72624: PUSH
72625: LD_INT 2
72627: NEG
72628: PUSH
72629: LD_INT 1
72631: NEG
72632: PUSH
72633: EMPTY
72634: LIST
72635: LIST
72636: PUSH
72637: EMPTY
72638: LIST
72639: LIST
72640: LIST
72641: LIST
72642: LIST
72643: LIST
72644: LIST
72645: LIST
72646: LIST
72647: ST_TO_ADDR
// fExt4 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 1 , 2 ] ] ;
72648: LD_ADDR_VAR 0 39
72652: PUSH
72653: LD_INT 0
72655: PUSH
72656: LD_INT 0
72658: PUSH
72659: EMPTY
72660: LIST
72661: LIST
72662: PUSH
72663: LD_INT 0
72665: PUSH
72666: LD_INT 1
72668: NEG
72669: PUSH
72670: EMPTY
72671: LIST
72672: LIST
72673: PUSH
72674: LD_INT 1
72676: PUSH
72677: LD_INT 0
72679: PUSH
72680: EMPTY
72681: LIST
72682: LIST
72683: PUSH
72684: LD_INT 1
72686: PUSH
72687: LD_INT 1
72689: PUSH
72690: EMPTY
72691: LIST
72692: LIST
72693: PUSH
72694: LD_INT 0
72696: PUSH
72697: LD_INT 1
72699: PUSH
72700: EMPTY
72701: LIST
72702: LIST
72703: PUSH
72704: LD_INT 1
72706: NEG
72707: PUSH
72708: LD_INT 0
72710: PUSH
72711: EMPTY
72712: LIST
72713: LIST
72714: PUSH
72715: LD_INT 1
72717: NEG
72718: PUSH
72719: LD_INT 1
72721: NEG
72722: PUSH
72723: EMPTY
72724: LIST
72725: LIST
72726: PUSH
72727: LD_INT 1
72729: NEG
72730: PUSH
72731: LD_INT 2
72733: NEG
72734: PUSH
72735: EMPTY
72736: LIST
72737: LIST
72738: PUSH
72739: LD_INT 1
72741: PUSH
72742: LD_INT 2
72744: PUSH
72745: EMPTY
72746: LIST
72747: LIST
72748: PUSH
72749: EMPTY
72750: LIST
72751: LIST
72752: LIST
72753: LIST
72754: LIST
72755: LIST
72756: LIST
72757: LIST
72758: LIST
72759: ST_TO_ADDR
// fExt5 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ 1 , - 1 ] , [ - 1 , 1 ] ] ;
72760: LD_ADDR_VAR 0 40
72764: PUSH
72765: LD_INT 0
72767: PUSH
72768: LD_INT 0
72770: PUSH
72771: EMPTY
72772: LIST
72773: LIST
72774: PUSH
72775: LD_INT 0
72777: PUSH
72778: LD_INT 1
72780: NEG
72781: PUSH
72782: EMPTY
72783: LIST
72784: LIST
72785: PUSH
72786: LD_INT 1
72788: PUSH
72789: LD_INT 0
72791: PUSH
72792: EMPTY
72793: LIST
72794: LIST
72795: PUSH
72796: LD_INT 1
72798: PUSH
72799: LD_INT 1
72801: PUSH
72802: EMPTY
72803: LIST
72804: LIST
72805: PUSH
72806: LD_INT 0
72808: PUSH
72809: LD_INT 1
72811: PUSH
72812: EMPTY
72813: LIST
72814: LIST
72815: PUSH
72816: LD_INT 1
72818: NEG
72819: PUSH
72820: LD_INT 0
72822: PUSH
72823: EMPTY
72824: LIST
72825: LIST
72826: PUSH
72827: LD_INT 1
72829: NEG
72830: PUSH
72831: LD_INT 1
72833: NEG
72834: PUSH
72835: EMPTY
72836: LIST
72837: LIST
72838: PUSH
72839: LD_INT 1
72841: PUSH
72842: LD_INT 1
72844: NEG
72845: PUSH
72846: EMPTY
72847: LIST
72848: LIST
72849: PUSH
72850: LD_INT 1
72852: NEG
72853: PUSH
72854: LD_INT 1
72856: PUSH
72857: EMPTY
72858: LIST
72859: LIST
72860: PUSH
72861: EMPTY
72862: LIST
72863: LIST
72864: LIST
72865: LIST
72866: LIST
72867: LIST
72868: LIST
72869: LIST
72870: LIST
72871: ST_TO_ADDR
// fLab0 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ - 2 , - 3 ] , [ 2 , - 1 ] , [ 3 , 0 ] , [ 3 , 1 ] , [ 3 , 2 ] , [ 3 , 3 ] , [ 2 , 3 ] , [ - 2 , 1 ] , [ - 3 , 0 ] , [ - 3 , - 1 ] , [ - 3 , - 2 ] , [ - 3 , - 3 ] ] ;
72872: LD_ADDR_VAR 0 41
72876: PUSH
72877: LD_INT 0
72879: PUSH
72880: LD_INT 0
72882: PUSH
72883: EMPTY
72884: LIST
72885: LIST
72886: PUSH
72887: LD_INT 0
72889: PUSH
72890: LD_INT 1
72892: NEG
72893: PUSH
72894: EMPTY
72895: LIST
72896: LIST
72897: PUSH
72898: LD_INT 1
72900: PUSH
72901: LD_INT 0
72903: PUSH
72904: EMPTY
72905: LIST
72906: LIST
72907: PUSH
72908: LD_INT 1
72910: PUSH
72911: LD_INT 1
72913: PUSH
72914: EMPTY
72915: LIST
72916: LIST
72917: PUSH
72918: LD_INT 0
72920: PUSH
72921: LD_INT 1
72923: PUSH
72924: EMPTY
72925: LIST
72926: LIST
72927: PUSH
72928: LD_INT 1
72930: NEG
72931: PUSH
72932: LD_INT 0
72934: PUSH
72935: EMPTY
72936: LIST
72937: LIST
72938: PUSH
72939: LD_INT 1
72941: NEG
72942: PUSH
72943: LD_INT 1
72945: NEG
72946: PUSH
72947: EMPTY
72948: LIST
72949: LIST
72950: PUSH
72951: LD_INT 1
72953: NEG
72954: PUSH
72955: LD_INT 2
72957: NEG
72958: PUSH
72959: EMPTY
72960: LIST
72961: LIST
72962: PUSH
72963: LD_INT 1
72965: PUSH
72966: LD_INT 1
72968: NEG
72969: PUSH
72970: EMPTY
72971: LIST
72972: LIST
72973: PUSH
72974: LD_INT 2
72976: PUSH
72977: LD_INT 0
72979: PUSH
72980: EMPTY
72981: LIST
72982: LIST
72983: PUSH
72984: LD_INT 2
72986: PUSH
72987: LD_INT 1
72989: PUSH
72990: EMPTY
72991: LIST
72992: LIST
72993: PUSH
72994: LD_INT 2
72996: PUSH
72997: LD_INT 2
72999: PUSH
73000: EMPTY
73001: LIST
73002: LIST
73003: PUSH
73004: LD_INT 1
73006: PUSH
73007: LD_INT 2
73009: PUSH
73010: EMPTY
73011: LIST
73012: LIST
73013: PUSH
73014: LD_INT 1
73016: NEG
73017: PUSH
73018: LD_INT 1
73020: PUSH
73021: EMPTY
73022: LIST
73023: LIST
73024: PUSH
73025: LD_INT 2
73027: NEG
73028: PUSH
73029: LD_INT 0
73031: PUSH
73032: EMPTY
73033: LIST
73034: LIST
73035: PUSH
73036: LD_INT 2
73038: NEG
73039: PUSH
73040: LD_INT 1
73042: NEG
73043: PUSH
73044: EMPTY
73045: LIST
73046: LIST
73047: PUSH
73048: LD_INT 2
73050: NEG
73051: PUSH
73052: LD_INT 2
73054: NEG
73055: PUSH
73056: EMPTY
73057: LIST
73058: LIST
73059: PUSH
73060: LD_INT 2
73062: NEG
73063: PUSH
73064: LD_INT 3
73066: NEG
73067: PUSH
73068: EMPTY
73069: LIST
73070: LIST
73071: PUSH
73072: LD_INT 2
73074: PUSH
73075: LD_INT 1
73077: NEG
73078: PUSH
73079: EMPTY
73080: LIST
73081: LIST
73082: PUSH
73083: LD_INT 3
73085: PUSH
73086: LD_INT 0
73088: PUSH
73089: EMPTY
73090: LIST
73091: LIST
73092: PUSH
73093: LD_INT 3
73095: PUSH
73096: LD_INT 1
73098: PUSH
73099: EMPTY
73100: LIST
73101: LIST
73102: PUSH
73103: LD_INT 3
73105: PUSH
73106: LD_INT 2
73108: PUSH
73109: EMPTY
73110: LIST
73111: LIST
73112: PUSH
73113: LD_INT 3
73115: PUSH
73116: LD_INT 3
73118: PUSH
73119: EMPTY
73120: LIST
73121: LIST
73122: PUSH
73123: LD_INT 2
73125: PUSH
73126: LD_INT 3
73128: PUSH
73129: EMPTY
73130: LIST
73131: LIST
73132: PUSH
73133: LD_INT 2
73135: NEG
73136: PUSH
73137: LD_INT 1
73139: PUSH
73140: EMPTY
73141: LIST
73142: LIST
73143: PUSH
73144: LD_INT 3
73146: NEG
73147: PUSH
73148: LD_INT 0
73150: PUSH
73151: EMPTY
73152: LIST
73153: LIST
73154: PUSH
73155: LD_INT 3
73157: NEG
73158: PUSH
73159: LD_INT 1
73161: NEG
73162: PUSH
73163: EMPTY
73164: LIST
73165: LIST
73166: PUSH
73167: LD_INT 3
73169: NEG
73170: PUSH
73171: LD_INT 2
73173: NEG
73174: PUSH
73175: EMPTY
73176: LIST
73177: LIST
73178: PUSH
73179: LD_INT 3
73181: NEG
73182: PUSH
73183: LD_INT 3
73185: NEG
73186: PUSH
73187: EMPTY
73188: LIST
73189: LIST
73190: PUSH
73191: EMPTY
73192: LIST
73193: LIST
73194: LIST
73195: LIST
73196: LIST
73197: LIST
73198: LIST
73199: LIST
73200: LIST
73201: LIST
73202: LIST
73203: LIST
73204: LIST
73205: LIST
73206: LIST
73207: LIST
73208: LIST
73209: LIST
73210: LIST
73211: LIST
73212: LIST
73213: LIST
73214: LIST
73215: LIST
73216: LIST
73217: LIST
73218: LIST
73219: LIST
73220: LIST
73221: ST_TO_ADDR
// fLab1 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ - 2 , - 3 ] , [ - 1 , - 3 ] , [ 0 , - 3 ] , [ 1 , - 2 ] , [ 3 , 2 ] , [ 3 , 3 ] , [ 2 , 3 ] , [ 1 , 3 ] , [ 0 , 3 ] , [ - 1 , 2 ] , [ - 3 , - 2 ] , [ - 3 , - 3 ] ] ;
73222: LD_ADDR_VAR 0 42
73226: PUSH
73227: LD_INT 0
73229: PUSH
73230: LD_INT 0
73232: PUSH
73233: EMPTY
73234: LIST
73235: LIST
73236: PUSH
73237: LD_INT 0
73239: PUSH
73240: LD_INT 1
73242: NEG
73243: PUSH
73244: EMPTY
73245: LIST
73246: LIST
73247: PUSH
73248: LD_INT 1
73250: PUSH
73251: LD_INT 0
73253: PUSH
73254: EMPTY
73255: LIST
73256: LIST
73257: PUSH
73258: LD_INT 1
73260: PUSH
73261: LD_INT 1
73263: PUSH
73264: EMPTY
73265: LIST
73266: LIST
73267: PUSH
73268: LD_INT 0
73270: PUSH
73271: LD_INT 1
73273: PUSH
73274: EMPTY
73275: LIST
73276: LIST
73277: PUSH
73278: LD_INT 1
73280: NEG
73281: PUSH
73282: LD_INT 0
73284: PUSH
73285: EMPTY
73286: LIST
73287: LIST
73288: PUSH
73289: LD_INT 1
73291: NEG
73292: PUSH
73293: LD_INT 1
73295: NEG
73296: PUSH
73297: EMPTY
73298: LIST
73299: LIST
73300: PUSH
73301: LD_INT 1
73303: NEG
73304: PUSH
73305: LD_INT 2
73307: NEG
73308: PUSH
73309: EMPTY
73310: LIST
73311: LIST
73312: PUSH
73313: LD_INT 0
73315: PUSH
73316: LD_INT 2
73318: NEG
73319: PUSH
73320: EMPTY
73321: LIST
73322: LIST
73323: PUSH
73324: LD_INT 1
73326: PUSH
73327: LD_INT 1
73329: NEG
73330: PUSH
73331: EMPTY
73332: LIST
73333: LIST
73334: PUSH
73335: LD_INT 2
73337: PUSH
73338: LD_INT 1
73340: PUSH
73341: EMPTY
73342: LIST
73343: LIST
73344: PUSH
73345: LD_INT 2
73347: PUSH
73348: LD_INT 2
73350: PUSH
73351: EMPTY
73352: LIST
73353: LIST
73354: PUSH
73355: LD_INT 1
73357: PUSH
73358: LD_INT 2
73360: PUSH
73361: EMPTY
73362: LIST
73363: LIST
73364: PUSH
73365: LD_INT 0
73367: PUSH
73368: LD_INT 2
73370: PUSH
73371: EMPTY
73372: LIST
73373: LIST
73374: PUSH
73375: LD_INT 1
73377: NEG
73378: PUSH
73379: LD_INT 1
73381: PUSH
73382: EMPTY
73383: LIST
73384: LIST
73385: PUSH
73386: LD_INT 2
73388: NEG
73389: PUSH
73390: LD_INT 1
73392: NEG
73393: PUSH
73394: EMPTY
73395: LIST
73396: LIST
73397: PUSH
73398: LD_INT 2
73400: NEG
73401: PUSH
73402: LD_INT 2
73404: NEG
73405: PUSH
73406: EMPTY
73407: LIST
73408: LIST
73409: PUSH
73410: LD_INT 2
73412: NEG
73413: PUSH
73414: LD_INT 3
73416: NEG
73417: PUSH
73418: EMPTY
73419: LIST
73420: LIST
73421: PUSH
73422: LD_INT 1
73424: NEG
73425: PUSH
73426: LD_INT 3
73428: NEG
73429: PUSH
73430: EMPTY
73431: LIST
73432: LIST
73433: PUSH
73434: LD_INT 0
73436: PUSH
73437: LD_INT 3
73439: NEG
73440: PUSH
73441: EMPTY
73442: LIST
73443: LIST
73444: PUSH
73445: LD_INT 1
73447: PUSH
73448: LD_INT 2
73450: NEG
73451: PUSH
73452: EMPTY
73453: LIST
73454: LIST
73455: PUSH
73456: LD_INT 3
73458: PUSH
73459: LD_INT 2
73461: PUSH
73462: EMPTY
73463: LIST
73464: LIST
73465: PUSH
73466: LD_INT 3
73468: PUSH
73469: LD_INT 3
73471: PUSH
73472: EMPTY
73473: LIST
73474: LIST
73475: PUSH
73476: LD_INT 2
73478: PUSH
73479: LD_INT 3
73481: PUSH
73482: EMPTY
73483: LIST
73484: LIST
73485: PUSH
73486: LD_INT 1
73488: PUSH
73489: LD_INT 3
73491: PUSH
73492: EMPTY
73493: LIST
73494: LIST
73495: PUSH
73496: LD_INT 0
73498: PUSH
73499: LD_INT 3
73501: PUSH
73502: EMPTY
73503: LIST
73504: LIST
73505: PUSH
73506: LD_INT 1
73508: NEG
73509: PUSH
73510: LD_INT 2
73512: PUSH
73513: EMPTY
73514: LIST
73515: LIST
73516: PUSH
73517: LD_INT 3
73519: NEG
73520: PUSH
73521: LD_INT 2
73523: NEG
73524: PUSH
73525: EMPTY
73526: LIST
73527: LIST
73528: PUSH
73529: LD_INT 3
73531: NEG
73532: PUSH
73533: LD_INT 3
73535: NEG
73536: PUSH
73537: EMPTY
73538: LIST
73539: LIST
73540: PUSH
73541: EMPTY
73542: LIST
73543: LIST
73544: LIST
73545: LIST
73546: LIST
73547: LIST
73548: LIST
73549: LIST
73550: LIST
73551: LIST
73552: LIST
73553: LIST
73554: LIST
73555: LIST
73556: LIST
73557: LIST
73558: LIST
73559: LIST
73560: LIST
73561: LIST
73562: LIST
73563: LIST
73564: LIST
73565: LIST
73566: LIST
73567: LIST
73568: LIST
73569: LIST
73570: LIST
73571: ST_TO_ADDR
// fLab2 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 1 , - 3 ] , [ 0 , - 3 ] , [ 1 , - 2 ] , [ 2 , - 1 ] , [ 3 , 0 ] , [ 3 , 1 ] , [ 1 , 3 ] , [ 0 , 3 ] , [ - 1 , 2 ] , [ - 2 , 1 ] , [ - 3 , 0 ] , [ - 3 , - 1 ] ] ;
73572: LD_ADDR_VAR 0 43
73576: PUSH
73577: LD_INT 0
73579: PUSH
73580: LD_INT 0
73582: PUSH
73583: EMPTY
73584: LIST
73585: LIST
73586: PUSH
73587: LD_INT 0
73589: PUSH
73590: LD_INT 1
73592: NEG
73593: PUSH
73594: EMPTY
73595: LIST
73596: LIST
73597: PUSH
73598: LD_INT 1
73600: PUSH
73601: LD_INT 0
73603: PUSH
73604: EMPTY
73605: LIST
73606: LIST
73607: PUSH
73608: LD_INT 1
73610: PUSH
73611: LD_INT 1
73613: PUSH
73614: EMPTY
73615: LIST
73616: LIST
73617: PUSH
73618: LD_INT 0
73620: PUSH
73621: LD_INT 1
73623: PUSH
73624: EMPTY
73625: LIST
73626: LIST
73627: PUSH
73628: LD_INT 1
73630: NEG
73631: PUSH
73632: LD_INT 0
73634: PUSH
73635: EMPTY
73636: LIST
73637: LIST
73638: PUSH
73639: LD_INT 1
73641: NEG
73642: PUSH
73643: LD_INT 1
73645: NEG
73646: PUSH
73647: EMPTY
73648: LIST
73649: LIST
73650: PUSH
73651: LD_INT 1
73653: NEG
73654: PUSH
73655: LD_INT 2
73657: NEG
73658: PUSH
73659: EMPTY
73660: LIST
73661: LIST
73662: PUSH
73663: LD_INT 0
73665: PUSH
73666: LD_INT 2
73668: NEG
73669: PUSH
73670: EMPTY
73671: LIST
73672: LIST
73673: PUSH
73674: LD_INT 1
73676: PUSH
73677: LD_INT 1
73679: NEG
73680: PUSH
73681: EMPTY
73682: LIST
73683: LIST
73684: PUSH
73685: LD_INT 2
73687: PUSH
73688: LD_INT 0
73690: PUSH
73691: EMPTY
73692: LIST
73693: LIST
73694: PUSH
73695: LD_INT 2
73697: PUSH
73698: LD_INT 1
73700: PUSH
73701: EMPTY
73702: LIST
73703: LIST
73704: PUSH
73705: LD_INT 1
73707: PUSH
73708: LD_INT 2
73710: PUSH
73711: EMPTY
73712: LIST
73713: LIST
73714: PUSH
73715: LD_INT 0
73717: PUSH
73718: LD_INT 2
73720: PUSH
73721: EMPTY
73722: LIST
73723: LIST
73724: PUSH
73725: LD_INT 1
73727: NEG
73728: PUSH
73729: LD_INT 1
73731: PUSH
73732: EMPTY
73733: LIST
73734: LIST
73735: PUSH
73736: LD_INT 2
73738: NEG
73739: PUSH
73740: LD_INT 0
73742: PUSH
73743: EMPTY
73744: LIST
73745: LIST
73746: PUSH
73747: LD_INT 2
73749: NEG
73750: PUSH
73751: LD_INT 1
73753: NEG
73754: PUSH
73755: EMPTY
73756: LIST
73757: LIST
73758: PUSH
73759: LD_INT 1
73761: NEG
73762: PUSH
73763: LD_INT 3
73765: NEG
73766: PUSH
73767: EMPTY
73768: LIST
73769: LIST
73770: PUSH
73771: LD_INT 0
73773: PUSH
73774: LD_INT 3
73776: NEG
73777: PUSH
73778: EMPTY
73779: LIST
73780: LIST
73781: PUSH
73782: LD_INT 1
73784: PUSH
73785: LD_INT 2
73787: NEG
73788: PUSH
73789: EMPTY
73790: LIST
73791: LIST
73792: PUSH
73793: LD_INT 2
73795: PUSH
73796: LD_INT 1
73798: NEG
73799: PUSH
73800: EMPTY
73801: LIST
73802: LIST
73803: PUSH
73804: LD_INT 3
73806: PUSH
73807: LD_INT 0
73809: PUSH
73810: EMPTY
73811: LIST
73812: LIST
73813: PUSH
73814: LD_INT 3
73816: PUSH
73817: LD_INT 1
73819: PUSH
73820: EMPTY
73821: LIST
73822: LIST
73823: PUSH
73824: LD_INT 1
73826: PUSH
73827: LD_INT 3
73829: PUSH
73830: EMPTY
73831: LIST
73832: LIST
73833: PUSH
73834: LD_INT 0
73836: PUSH
73837: LD_INT 3
73839: PUSH
73840: EMPTY
73841: LIST
73842: LIST
73843: PUSH
73844: LD_INT 1
73846: NEG
73847: PUSH
73848: LD_INT 2
73850: PUSH
73851: EMPTY
73852: LIST
73853: LIST
73854: PUSH
73855: LD_INT 2
73857: NEG
73858: PUSH
73859: LD_INT 1
73861: PUSH
73862: EMPTY
73863: LIST
73864: LIST
73865: PUSH
73866: LD_INT 3
73868: NEG
73869: PUSH
73870: LD_INT 0
73872: PUSH
73873: EMPTY
73874: LIST
73875: LIST
73876: PUSH
73877: LD_INT 3
73879: NEG
73880: PUSH
73881: LD_INT 1
73883: NEG
73884: PUSH
73885: EMPTY
73886: LIST
73887: LIST
73888: PUSH
73889: EMPTY
73890: LIST
73891: LIST
73892: LIST
73893: LIST
73894: LIST
73895: LIST
73896: LIST
73897: LIST
73898: LIST
73899: LIST
73900: LIST
73901: LIST
73902: LIST
73903: LIST
73904: LIST
73905: LIST
73906: LIST
73907: LIST
73908: LIST
73909: LIST
73910: LIST
73911: LIST
73912: LIST
73913: LIST
73914: LIST
73915: LIST
73916: LIST
73917: LIST
73918: LIST
73919: ST_TO_ADDR
// fLab3 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ - 2 , - 3 ] , [ 2 , - 1 ] , [ 3 , 0 ] , [ 3 , 1 ] , [ 3 , 2 ] , [ 3 , 3 ] , [ 2 , 3 ] , [ - 2 , 1 ] , [ - 3 , 0 ] , [ - 3 , - 1 ] , [ - 3 , - 2 ] , [ - 3 , - 3 ] ] ;
73920: LD_ADDR_VAR 0 44
73924: PUSH
73925: LD_INT 0
73927: PUSH
73928: LD_INT 0
73930: PUSH
73931: EMPTY
73932: LIST
73933: LIST
73934: PUSH
73935: LD_INT 0
73937: PUSH
73938: LD_INT 1
73940: NEG
73941: PUSH
73942: EMPTY
73943: LIST
73944: LIST
73945: PUSH
73946: LD_INT 1
73948: PUSH
73949: LD_INT 0
73951: PUSH
73952: EMPTY
73953: LIST
73954: LIST
73955: PUSH
73956: LD_INT 1
73958: PUSH
73959: LD_INT 1
73961: PUSH
73962: EMPTY
73963: LIST
73964: LIST
73965: PUSH
73966: LD_INT 0
73968: PUSH
73969: LD_INT 1
73971: PUSH
73972: EMPTY
73973: LIST
73974: LIST
73975: PUSH
73976: LD_INT 1
73978: NEG
73979: PUSH
73980: LD_INT 0
73982: PUSH
73983: EMPTY
73984: LIST
73985: LIST
73986: PUSH
73987: LD_INT 1
73989: NEG
73990: PUSH
73991: LD_INT 1
73993: NEG
73994: PUSH
73995: EMPTY
73996: LIST
73997: LIST
73998: PUSH
73999: LD_INT 1
74001: NEG
74002: PUSH
74003: LD_INT 2
74005: NEG
74006: PUSH
74007: EMPTY
74008: LIST
74009: LIST
74010: PUSH
74011: LD_INT 1
74013: PUSH
74014: LD_INT 1
74016: NEG
74017: PUSH
74018: EMPTY
74019: LIST
74020: LIST
74021: PUSH
74022: LD_INT 2
74024: PUSH
74025: LD_INT 0
74027: PUSH
74028: EMPTY
74029: LIST
74030: LIST
74031: PUSH
74032: LD_INT 2
74034: PUSH
74035: LD_INT 1
74037: PUSH
74038: EMPTY
74039: LIST
74040: LIST
74041: PUSH
74042: LD_INT 2
74044: PUSH
74045: LD_INT 2
74047: PUSH
74048: EMPTY
74049: LIST
74050: LIST
74051: PUSH
74052: LD_INT 1
74054: PUSH
74055: LD_INT 2
74057: PUSH
74058: EMPTY
74059: LIST
74060: LIST
74061: PUSH
74062: LD_INT 1
74064: NEG
74065: PUSH
74066: LD_INT 1
74068: PUSH
74069: EMPTY
74070: LIST
74071: LIST
74072: PUSH
74073: LD_INT 2
74075: NEG
74076: PUSH
74077: LD_INT 0
74079: PUSH
74080: EMPTY
74081: LIST
74082: LIST
74083: PUSH
74084: LD_INT 2
74086: NEG
74087: PUSH
74088: LD_INT 1
74090: NEG
74091: PUSH
74092: EMPTY
74093: LIST
74094: LIST
74095: PUSH
74096: LD_INT 2
74098: NEG
74099: PUSH
74100: LD_INT 2
74102: NEG
74103: PUSH
74104: EMPTY
74105: LIST
74106: LIST
74107: PUSH
74108: LD_INT 2
74110: NEG
74111: PUSH
74112: LD_INT 3
74114: NEG
74115: PUSH
74116: EMPTY
74117: LIST
74118: LIST
74119: PUSH
74120: LD_INT 2
74122: PUSH
74123: LD_INT 1
74125: NEG
74126: PUSH
74127: EMPTY
74128: LIST
74129: LIST
74130: PUSH
74131: LD_INT 3
74133: PUSH
74134: LD_INT 0
74136: PUSH
74137: EMPTY
74138: LIST
74139: LIST
74140: PUSH
74141: LD_INT 3
74143: PUSH
74144: LD_INT 1
74146: PUSH
74147: EMPTY
74148: LIST
74149: LIST
74150: PUSH
74151: LD_INT 3
74153: PUSH
74154: LD_INT 2
74156: PUSH
74157: EMPTY
74158: LIST
74159: LIST
74160: PUSH
74161: LD_INT 3
74163: PUSH
74164: LD_INT 3
74166: PUSH
74167: EMPTY
74168: LIST
74169: LIST
74170: PUSH
74171: LD_INT 2
74173: PUSH
74174: LD_INT 3
74176: PUSH
74177: EMPTY
74178: LIST
74179: LIST
74180: PUSH
74181: LD_INT 2
74183: NEG
74184: PUSH
74185: LD_INT 1
74187: PUSH
74188: EMPTY
74189: LIST
74190: LIST
74191: PUSH
74192: LD_INT 3
74194: NEG
74195: PUSH
74196: LD_INT 0
74198: PUSH
74199: EMPTY
74200: LIST
74201: LIST
74202: PUSH
74203: LD_INT 3
74205: NEG
74206: PUSH
74207: LD_INT 1
74209: NEG
74210: PUSH
74211: EMPTY
74212: LIST
74213: LIST
74214: PUSH
74215: LD_INT 3
74217: NEG
74218: PUSH
74219: LD_INT 2
74221: NEG
74222: PUSH
74223: EMPTY
74224: LIST
74225: LIST
74226: PUSH
74227: LD_INT 3
74229: NEG
74230: PUSH
74231: LD_INT 3
74233: NEG
74234: PUSH
74235: EMPTY
74236: LIST
74237: LIST
74238: PUSH
74239: EMPTY
74240: LIST
74241: LIST
74242: LIST
74243: LIST
74244: LIST
74245: LIST
74246: LIST
74247: LIST
74248: LIST
74249: LIST
74250: LIST
74251: LIST
74252: LIST
74253: LIST
74254: LIST
74255: LIST
74256: LIST
74257: LIST
74258: LIST
74259: LIST
74260: LIST
74261: LIST
74262: LIST
74263: LIST
74264: LIST
74265: LIST
74266: LIST
74267: LIST
74268: LIST
74269: ST_TO_ADDR
// fLab4 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ - 2 , - 3 ] , [ - 1 , - 3 ] , [ 0 , - 3 ] , [ 1 , - 2 ] , [ 3 , 2 ] , [ 3 , 3 ] , [ 2 , 3 ] , [ 1 , 3 ] , [ 0 , 3 ] , [ - 1 , 2 ] , [ - 3 , - 2 ] , [ - 3 , - 3 ] ] ;
74270: LD_ADDR_VAR 0 45
74274: PUSH
74275: LD_INT 0
74277: PUSH
74278: LD_INT 0
74280: PUSH
74281: EMPTY
74282: LIST
74283: LIST
74284: PUSH
74285: LD_INT 0
74287: PUSH
74288: LD_INT 1
74290: NEG
74291: PUSH
74292: EMPTY
74293: LIST
74294: LIST
74295: PUSH
74296: LD_INT 1
74298: PUSH
74299: LD_INT 0
74301: PUSH
74302: EMPTY
74303: LIST
74304: LIST
74305: PUSH
74306: LD_INT 1
74308: PUSH
74309: LD_INT 1
74311: PUSH
74312: EMPTY
74313: LIST
74314: LIST
74315: PUSH
74316: LD_INT 0
74318: PUSH
74319: LD_INT 1
74321: PUSH
74322: EMPTY
74323: LIST
74324: LIST
74325: PUSH
74326: LD_INT 1
74328: NEG
74329: PUSH
74330: LD_INT 0
74332: PUSH
74333: EMPTY
74334: LIST
74335: LIST
74336: PUSH
74337: LD_INT 1
74339: NEG
74340: PUSH
74341: LD_INT 1
74343: NEG
74344: PUSH
74345: EMPTY
74346: LIST
74347: LIST
74348: PUSH
74349: LD_INT 1
74351: NEG
74352: PUSH
74353: LD_INT 2
74355: NEG
74356: PUSH
74357: EMPTY
74358: LIST
74359: LIST
74360: PUSH
74361: LD_INT 0
74363: PUSH
74364: LD_INT 2
74366: NEG
74367: PUSH
74368: EMPTY
74369: LIST
74370: LIST
74371: PUSH
74372: LD_INT 1
74374: PUSH
74375: LD_INT 1
74377: NEG
74378: PUSH
74379: EMPTY
74380: LIST
74381: LIST
74382: PUSH
74383: LD_INT 2
74385: PUSH
74386: LD_INT 1
74388: PUSH
74389: EMPTY
74390: LIST
74391: LIST
74392: PUSH
74393: LD_INT 2
74395: PUSH
74396: LD_INT 2
74398: PUSH
74399: EMPTY
74400: LIST
74401: LIST
74402: PUSH
74403: LD_INT 1
74405: PUSH
74406: LD_INT 2
74408: PUSH
74409: EMPTY
74410: LIST
74411: LIST
74412: PUSH
74413: LD_INT 0
74415: PUSH
74416: LD_INT 2
74418: PUSH
74419: EMPTY
74420: LIST
74421: LIST
74422: PUSH
74423: LD_INT 1
74425: NEG
74426: PUSH
74427: LD_INT 1
74429: PUSH
74430: EMPTY
74431: LIST
74432: LIST
74433: PUSH
74434: LD_INT 2
74436: NEG
74437: PUSH
74438: LD_INT 1
74440: NEG
74441: PUSH
74442: EMPTY
74443: LIST
74444: LIST
74445: PUSH
74446: LD_INT 2
74448: NEG
74449: PUSH
74450: LD_INT 2
74452: NEG
74453: PUSH
74454: EMPTY
74455: LIST
74456: LIST
74457: PUSH
74458: LD_INT 2
74460: NEG
74461: PUSH
74462: LD_INT 3
74464: NEG
74465: PUSH
74466: EMPTY
74467: LIST
74468: LIST
74469: PUSH
74470: LD_INT 1
74472: NEG
74473: PUSH
74474: LD_INT 3
74476: NEG
74477: PUSH
74478: EMPTY
74479: LIST
74480: LIST
74481: PUSH
74482: LD_INT 0
74484: PUSH
74485: LD_INT 3
74487: NEG
74488: PUSH
74489: EMPTY
74490: LIST
74491: LIST
74492: PUSH
74493: LD_INT 1
74495: PUSH
74496: LD_INT 2
74498: NEG
74499: PUSH
74500: EMPTY
74501: LIST
74502: LIST
74503: PUSH
74504: LD_INT 3
74506: PUSH
74507: LD_INT 2
74509: PUSH
74510: EMPTY
74511: LIST
74512: LIST
74513: PUSH
74514: LD_INT 3
74516: PUSH
74517: LD_INT 3
74519: PUSH
74520: EMPTY
74521: LIST
74522: LIST
74523: PUSH
74524: LD_INT 2
74526: PUSH
74527: LD_INT 3
74529: PUSH
74530: EMPTY
74531: LIST
74532: LIST
74533: PUSH
74534: LD_INT 1
74536: PUSH
74537: LD_INT 3
74539: PUSH
74540: EMPTY
74541: LIST
74542: LIST
74543: PUSH
74544: LD_INT 0
74546: PUSH
74547: LD_INT 3
74549: PUSH
74550: EMPTY
74551: LIST
74552: LIST
74553: PUSH
74554: LD_INT 1
74556: NEG
74557: PUSH
74558: LD_INT 2
74560: PUSH
74561: EMPTY
74562: LIST
74563: LIST
74564: PUSH
74565: LD_INT 3
74567: NEG
74568: PUSH
74569: LD_INT 2
74571: NEG
74572: PUSH
74573: EMPTY
74574: LIST
74575: LIST
74576: PUSH
74577: LD_INT 3
74579: NEG
74580: PUSH
74581: LD_INT 3
74583: NEG
74584: PUSH
74585: EMPTY
74586: LIST
74587: LIST
74588: PUSH
74589: EMPTY
74590: LIST
74591: LIST
74592: LIST
74593: LIST
74594: LIST
74595: LIST
74596: LIST
74597: LIST
74598: LIST
74599: LIST
74600: LIST
74601: LIST
74602: LIST
74603: LIST
74604: LIST
74605: LIST
74606: LIST
74607: LIST
74608: LIST
74609: LIST
74610: LIST
74611: LIST
74612: LIST
74613: LIST
74614: LIST
74615: LIST
74616: LIST
74617: LIST
74618: LIST
74619: ST_TO_ADDR
// fLab5 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 1 , - 3 ] , [ 0 , - 3 ] , [ 1 , - 2 ] , [ 2 , - 1 ] , [ 3 , 0 ] , [ 3 , 1 ] , [ 1 , 3 ] , [ 0 , 3 ] , [ - 1 , 2 ] , [ - 2 , 1 ] , [ - 3 , 0 ] , [ - 3 , - 1 ] ] ;
74620: LD_ADDR_VAR 0 46
74624: PUSH
74625: LD_INT 0
74627: PUSH
74628: LD_INT 0
74630: PUSH
74631: EMPTY
74632: LIST
74633: LIST
74634: PUSH
74635: LD_INT 0
74637: PUSH
74638: LD_INT 1
74640: NEG
74641: PUSH
74642: EMPTY
74643: LIST
74644: LIST
74645: PUSH
74646: LD_INT 1
74648: PUSH
74649: LD_INT 0
74651: PUSH
74652: EMPTY
74653: LIST
74654: LIST
74655: PUSH
74656: LD_INT 1
74658: PUSH
74659: LD_INT 1
74661: PUSH
74662: EMPTY
74663: LIST
74664: LIST
74665: PUSH
74666: LD_INT 0
74668: PUSH
74669: LD_INT 1
74671: PUSH
74672: EMPTY
74673: LIST
74674: LIST
74675: PUSH
74676: LD_INT 1
74678: NEG
74679: PUSH
74680: LD_INT 0
74682: PUSH
74683: EMPTY
74684: LIST
74685: LIST
74686: PUSH
74687: LD_INT 1
74689: NEG
74690: PUSH
74691: LD_INT 1
74693: NEG
74694: PUSH
74695: EMPTY
74696: LIST
74697: LIST
74698: PUSH
74699: LD_INT 1
74701: NEG
74702: PUSH
74703: LD_INT 2
74705: NEG
74706: PUSH
74707: EMPTY
74708: LIST
74709: LIST
74710: PUSH
74711: LD_INT 0
74713: PUSH
74714: LD_INT 2
74716: NEG
74717: PUSH
74718: EMPTY
74719: LIST
74720: LIST
74721: PUSH
74722: LD_INT 1
74724: PUSH
74725: LD_INT 1
74727: NEG
74728: PUSH
74729: EMPTY
74730: LIST
74731: LIST
74732: PUSH
74733: LD_INT 2
74735: PUSH
74736: LD_INT 0
74738: PUSH
74739: EMPTY
74740: LIST
74741: LIST
74742: PUSH
74743: LD_INT 2
74745: PUSH
74746: LD_INT 1
74748: PUSH
74749: EMPTY
74750: LIST
74751: LIST
74752: PUSH
74753: LD_INT 1
74755: PUSH
74756: LD_INT 2
74758: PUSH
74759: EMPTY
74760: LIST
74761: LIST
74762: PUSH
74763: LD_INT 0
74765: PUSH
74766: LD_INT 2
74768: PUSH
74769: EMPTY
74770: LIST
74771: LIST
74772: PUSH
74773: LD_INT 1
74775: NEG
74776: PUSH
74777: LD_INT 1
74779: PUSH
74780: EMPTY
74781: LIST
74782: LIST
74783: PUSH
74784: LD_INT 2
74786: NEG
74787: PUSH
74788: LD_INT 0
74790: PUSH
74791: EMPTY
74792: LIST
74793: LIST
74794: PUSH
74795: LD_INT 2
74797: NEG
74798: PUSH
74799: LD_INT 1
74801: NEG
74802: PUSH
74803: EMPTY
74804: LIST
74805: LIST
74806: PUSH
74807: LD_INT 1
74809: NEG
74810: PUSH
74811: LD_INT 3
74813: NEG
74814: PUSH
74815: EMPTY
74816: LIST
74817: LIST
74818: PUSH
74819: LD_INT 0
74821: PUSH
74822: LD_INT 3
74824: NEG
74825: PUSH
74826: EMPTY
74827: LIST
74828: LIST
74829: PUSH
74830: LD_INT 1
74832: PUSH
74833: LD_INT 2
74835: NEG
74836: PUSH
74837: EMPTY
74838: LIST
74839: LIST
74840: PUSH
74841: LD_INT 2
74843: PUSH
74844: LD_INT 1
74846: NEG
74847: PUSH
74848: EMPTY
74849: LIST
74850: LIST
74851: PUSH
74852: LD_INT 3
74854: PUSH
74855: LD_INT 0
74857: PUSH
74858: EMPTY
74859: LIST
74860: LIST
74861: PUSH
74862: LD_INT 3
74864: PUSH
74865: LD_INT 1
74867: PUSH
74868: EMPTY
74869: LIST
74870: LIST
74871: PUSH
74872: LD_INT 1
74874: PUSH
74875: LD_INT 3
74877: PUSH
74878: EMPTY
74879: LIST
74880: LIST
74881: PUSH
74882: LD_INT 0
74884: PUSH
74885: LD_INT 3
74887: PUSH
74888: EMPTY
74889: LIST
74890: LIST
74891: PUSH
74892: LD_INT 1
74894: NEG
74895: PUSH
74896: LD_INT 2
74898: PUSH
74899: EMPTY
74900: LIST
74901: LIST
74902: PUSH
74903: LD_INT 2
74905: NEG
74906: PUSH
74907: LD_INT 1
74909: PUSH
74910: EMPTY
74911: LIST
74912: LIST
74913: PUSH
74914: LD_INT 3
74916: NEG
74917: PUSH
74918: LD_INT 0
74920: PUSH
74921: EMPTY
74922: LIST
74923: LIST
74924: PUSH
74925: LD_INT 3
74927: NEG
74928: PUSH
74929: LD_INT 1
74931: NEG
74932: PUSH
74933: EMPTY
74934: LIST
74935: LIST
74936: PUSH
74937: EMPTY
74938: LIST
74939: LIST
74940: LIST
74941: LIST
74942: LIST
74943: LIST
74944: LIST
74945: LIST
74946: LIST
74947: LIST
74948: LIST
74949: LIST
74950: LIST
74951: LIST
74952: LIST
74953: LIST
74954: LIST
74955: LIST
74956: LIST
74957: LIST
74958: LIST
74959: LIST
74960: LIST
74961: LIST
74962: LIST
74963: LIST
74964: LIST
74965: LIST
74966: LIST
74967: ST_TO_ADDR
// fControlTower0 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
74968: LD_ADDR_VAR 0 47
74972: PUSH
74973: LD_INT 0
74975: PUSH
74976: LD_INT 0
74978: PUSH
74979: EMPTY
74980: LIST
74981: LIST
74982: PUSH
74983: LD_INT 0
74985: PUSH
74986: LD_INT 1
74988: NEG
74989: PUSH
74990: EMPTY
74991: LIST
74992: LIST
74993: PUSH
74994: LD_INT 1
74996: PUSH
74997: LD_INT 0
74999: PUSH
75000: EMPTY
75001: LIST
75002: LIST
75003: PUSH
75004: LD_INT 1
75006: PUSH
75007: LD_INT 1
75009: PUSH
75010: EMPTY
75011: LIST
75012: LIST
75013: PUSH
75014: LD_INT 0
75016: PUSH
75017: LD_INT 1
75019: PUSH
75020: EMPTY
75021: LIST
75022: LIST
75023: PUSH
75024: LD_INT 1
75026: NEG
75027: PUSH
75028: LD_INT 0
75030: PUSH
75031: EMPTY
75032: LIST
75033: LIST
75034: PUSH
75035: LD_INT 1
75037: NEG
75038: PUSH
75039: LD_INT 1
75041: NEG
75042: PUSH
75043: EMPTY
75044: LIST
75045: LIST
75046: PUSH
75047: LD_INT 1
75049: NEG
75050: PUSH
75051: LD_INT 2
75053: NEG
75054: PUSH
75055: EMPTY
75056: LIST
75057: LIST
75058: PUSH
75059: LD_INT 0
75061: PUSH
75062: LD_INT 2
75064: NEG
75065: PUSH
75066: EMPTY
75067: LIST
75068: LIST
75069: PUSH
75070: LD_INT 1
75072: PUSH
75073: LD_INT 1
75075: NEG
75076: PUSH
75077: EMPTY
75078: LIST
75079: LIST
75080: PUSH
75081: LD_INT 2
75083: NEG
75084: PUSH
75085: LD_INT 1
75087: NEG
75088: PUSH
75089: EMPTY
75090: LIST
75091: LIST
75092: PUSH
75093: LD_INT 2
75095: NEG
75096: PUSH
75097: LD_INT 2
75099: NEG
75100: PUSH
75101: EMPTY
75102: LIST
75103: LIST
75104: PUSH
75105: EMPTY
75106: LIST
75107: LIST
75108: LIST
75109: LIST
75110: LIST
75111: LIST
75112: LIST
75113: LIST
75114: LIST
75115: LIST
75116: LIST
75117: LIST
75118: ST_TO_ADDR
// fControlTower1 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] ] ;
75119: LD_ADDR_VAR 0 48
75123: PUSH
75124: LD_INT 0
75126: PUSH
75127: LD_INT 0
75129: PUSH
75130: EMPTY
75131: LIST
75132: LIST
75133: PUSH
75134: LD_INT 0
75136: PUSH
75137: LD_INT 1
75139: NEG
75140: PUSH
75141: EMPTY
75142: LIST
75143: LIST
75144: PUSH
75145: LD_INT 1
75147: PUSH
75148: LD_INT 0
75150: PUSH
75151: EMPTY
75152: LIST
75153: LIST
75154: PUSH
75155: LD_INT 1
75157: PUSH
75158: LD_INT 1
75160: PUSH
75161: EMPTY
75162: LIST
75163: LIST
75164: PUSH
75165: LD_INT 0
75167: PUSH
75168: LD_INT 1
75170: PUSH
75171: EMPTY
75172: LIST
75173: LIST
75174: PUSH
75175: LD_INT 1
75177: NEG
75178: PUSH
75179: LD_INT 0
75181: PUSH
75182: EMPTY
75183: LIST
75184: LIST
75185: PUSH
75186: LD_INT 1
75188: NEG
75189: PUSH
75190: LD_INT 1
75192: NEG
75193: PUSH
75194: EMPTY
75195: LIST
75196: LIST
75197: PUSH
75198: LD_INT 1
75200: NEG
75201: PUSH
75202: LD_INT 2
75204: NEG
75205: PUSH
75206: EMPTY
75207: LIST
75208: LIST
75209: PUSH
75210: LD_INT 0
75212: PUSH
75213: LD_INT 2
75215: NEG
75216: PUSH
75217: EMPTY
75218: LIST
75219: LIST
75220: PUSH
75221: LD_INT 1
75223: PUSH
75224: LD_INT 1
75226: NEG
75227: PUSH
75228: EMPTY
75229: LIST
75230: LIST
75231: PUSH
75232: LD_INT 2
75234: PUSH
75235: LD_INT 0
75237: PUSH
75238: EMPTY
75239: LIST
75240: LIST
75241: PUSH
75242: LD_INT 2
75244: PUSH
75245: LD_INT 1
75247: PUSH
75248: EMPTY
75249: LIST
75250: LIST
75251: PUSH
75252: EMPTY
75253: LIST
75254: LIST
75255: LIST
75256: LIST
75257: LIST
75258: LIST
75259: LIST
75260: LIST
75261: LIST
75262: LIST
75263: LIST
75264: LIST
75265: ST_TO_ADDR
// fControlTower2 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] ] ;
75266: LD_ADDR_VAR 0 49
75270: PUSH
75271: LD_INT 0
75273: PUSH
75274: LD_INT 0
75276: PUSH
75277: EMPTY
75278: LIST
75279: LIST
75280: PUSH
75281: LD_INT 0
75283: PUSH
75284: LD_INT 1
75286: NEG
75287: PUSH
75288: EMPTY
75289: LIST
75290: LIST
75291: PUSH
75292: LD_INT 1
75294: PUSH
75295: LD_INT 0
75297: PUSH
75298: EMPTY
75299: LIST
75300: LIST
75301: PUSH
75302: LD_INT 1
75304: PUSH
75305: LD_INT 1
75307: PUSH
75308: EMPTY
75309: LIST
75310: LIST
75311: PUSH
75312: LD_INT 0
75314: PUSH
75315: LD_INT 1
75317: PUSH
75318: EMPTY
75319: LIST
75320: LIST
75321: PUSH
75322: LD_INT 1
75324: NEG
75325: PUSH
75326: LD_INT 0
75328: PUSH
75329: EMPTY
75330: LIST
75331: LIST
75332: PUSH
75333: LD_INT 1
75335: NEG
75336: PUSH
75337: LD_INT 1
75339: NEG
75340: PUSH
75341: EMPTY
75342: LIST
75343: LIST
75344: PUSH
75345: LD_INT 1
75347: PUSH
75348: LD_INT 1
75350: NEG
75351: PUSH
75352: EMPTY
75353: LIST
75354: LIST
75355: PUSH
75356: LD_INT 2
75358: PUSH
75359: LD_INT 0
75361: PUSH
75362: EMPTY
75363: LIST
75364: LIST
75365: PUSH
75366: LD_INT 2
75368: PUSH
75369: LD_INT 1
75371: PUSH
75372: EMPTY
75373: LIST
75374: LIST
75375: PUSH
75376: LD_INT 2
75378: PUSH
75379: LD_INT 2
75381: PUSH
75382: EMPTY
75383: LIST
75384: LIST
75385: PUSH
75386: LD_INT 1
75388: PUSH
75389: LD_INT 2
75391: PUSH
75392: EMPTY
75393: LIST
75394: LIST
75395: PUSH
75396: EMPTY
75397: LIST
75398: LIST
75399: LIST
75400: LIST
75401: LIST
75402: LIST
75403: LIST
75404: LIST
75405: LIST
75406: LIST
75407: LIST
75408: LIST
75409: ST_TO_ADDR
// fControlTower3 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] ] ;
75410: LD_ADDR_VAR 0 50
75414: PUSH
75415: LD_INT 0
75417: PUSH
75418: LD_INT 0
75420: PUSH
75421: EMPTY
75422: LIST
75423: LIST
75424: PUSH
75425: LD_INT 0
75427: PUSH
75428: LD_INT 1
75430: NEG
75431: PUSH
75432: EMPTY
75433: LIST
75434: LIST
75435: PUSH
75436: LD_INT 1
75438: PUSH
75439: LD_INT 0
75441: PUSH
75442: EMPTY
75443: LIST
75444: LIST
75445: PUSH
75446: LD_INT 1
75448: PUSH
75449: LD_INT 1
75451: PUSH
75452: EMPTY
75453: LIST
75454: LIST
75455: PUSH
75456: LD_INT 0
75458: PUSH
75459: LD_INT 1
75461: PUSH
75462: EMPTY
75463: LIST
75464: LIST
75465: PUSH
75466: LD_INT 1
75468: NEG
75469: PUSH
75470: LD_INT 0
75472: PUSH
75473: EMPTY
75474: LIST
75475: LIST
75476: PUSH
75477: LD_INT 1
75479: NEG
75480: PUSH
75481: LD_INT 1
75483: NEG
75484: PUSH
75485: EMPTY
75486: LIST
75487: LIST
75488: PUSH
75489: LD_INT 2
75491: PUSH
75492: LD_INT 1
75494: PUSH
75495: EMPTY
75496: LIST
75497: LIST
75498: PUSH
75499: LD_INT 2
75501: PUSH
75502: LD_INT 2
75504: PUSH
75505: EMPTY
75506: LIST
75507: LIST
75508: PUSH
75509: LD_INT 1
75511: PUSH
75512: LD_INT 2
75514: PUSH
75515: EMPTY
75516: LIST
75517: LIST
75518: PUSH
75519: LD_INT 0
75521: PUSH
75522: LD_INT 2
75524: PUSH
75525: EMPTY
75526: LIST
75527: LIST
75528: PUSH
75529: LD_INT 1
75531: NEG
75532: PUSH
75533: LD_INT 1
75535: PUSH
75536: EMPTY
75537: LIST
75538: LIST
75539: PUSH
75540: EMPTY
75541: LIST
75542: LIST
75543: LIST
75544: LIST
75545: LIST
75546: LIST
75547: LIST
75548: LIST
75549: LIST
75550: LIST
75551: LIST
75552: LIST
75553: ST_TO_ADDR
// fControlTower4 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] ] ;
75554: LD_ADDR_VAR 0 51
75558: PUSH
75559: LD_INT 0
75561: PUSH
75562: LD_INT 0
75564: PUSH
75565: EMPTY
75566: LIST
75567: LIST
75568: PUSH
75569: LD_INT 0
75571: PUSH
75572: LD_INT 1
75574: NEG
75575: PUSH
75576: EMPTY
75577: LIST
75578: LIST
75579: PUSH
75580: LD_INT 1
75582: PUSH
75583: LD_INT 0
75585: PUSH
75586: EMPTY
75587: LIST
75588: LIST
75589: PUSH
75590: LD_INT 1
75592: PUSH
75593: LD_INT 1
75595: PUSH
75596: EMPTY
75597: LIST
75598: LIST
75599: PUSH
75600: LD_INT 0
75602: PUSH
75603: LD_INT 1
75605: PUSH
75606: EMPTY
75607: LIST
75608: LIST
75609: PUSH
75610: LD_INT 1
75612: NEG
75613: PUSH
75614: LD_INT 0
75616: PUSH
75617: EMPTY
75618: LIST
75619: LIST
75620: PUSH
75621: LD_INT 1
75623: NEG
75624: PUSH
75625: LD_INT 1
75627: NEG
75628: PUSH
75629: EMPTY
75630: LIST
75631: LIST
75632: PUSH
75633: LD_INT 1
75635: PUSH
75636: LD_INT 2
75638: PUSH
75639: EMPTY
75640: LIST
75641: LIST
75642: PUSH
75643: LD_INT 0
75645: PUSH
75646: LD_INT 2
75648: PUSH
75649: EMPTY
75650: LIST
75651: LIST
75652: PUSH
75653: LD_INT 1
75655: NEG
75656: PUSH
75657: LD_INT 1
75659: PUSH
75660: EMPTY
75661: LIST
75662: LIST
75663: PUSH
75664: LD_INT 2
75666: NEG
75667: PUSH
75668: LD_INT 0
75670: PUSH
75671: EMPTY
75672: LIST
75673: LIST
75674: PUSH
75675: LD_INT 2
75677: NEG
75678: PUSH
75679: LD_INT 1
75681: NEG
75682: PUSH
75683: EMPTY
75684: LIST
75685: LIST
75686: PUSH
75687: EMPTY
75688: LIST
75689: LIST
75690: LIST
75691: LIST
75692: LIST
75693: LIST
75694: LIST
75695: LIST
75696: LIST
75697: LIST
75698: LIST
75699: LIST
75700: ST_TO_ADDR
// fControlTower5 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
75701: LD_ADDR_VAR 0 52
75705: PUSH
75706: LD_INT 0
75708: PUSH
75709: LD_INT 0
75711: PUSH
75712: EMPTY
75713: LIST
75714: LIST
75715: PUSH
75716: LD_INT 0
75718: PUSH
75719: LD_INT 1
75721: NEG
75722: PUSH
75723: EMPTY
75724: LIST
75725: LIST
75726: PUSH
75727: LD_INT 1
75729: PUSH
75730: LD_INT 0
75732: PUSH
75733: EMPTY
75734: LIST
75735: LIST
75736: PUSH
75737: LD_INT 1
75739: PUSH
75740: LD_INT 1
75742: PUSH
75743: EMPTY
75744: LIST
75745: LIST
75746: PUSH
75747: LD_INT 0
75749: PUSH
75750: LD_INT 1
75752: PUSH
75753: EMPTY
75754: LIST
75755: LIST
75756: PUSH
75757: LD_INT 1
75759: NEG
75760: PUSH
75761: LD_INT 0
75763: PUSH
75764: EMPTY
75765: LIST
75766: LIST
75767: PUSH
75768: LD_INT 1
75770: NEG
75771: PUSH
75772: LD_INT 1
75774: NEG
75775: PUSH
75776: EMPTY
75777: LIST
75778: LIST
75779: PUSH
75780: LD_INT 1
75782: NEG
75783: PUSH
75784: LD_INT 2
75786: NEG
75787: PUSH
75788: EMPTY
75789: LIST
75790: LIST
75791: PUSH
75792: LD_INT 1
75794: NEG
75795: PUSH
75796: LD_INT 1
75798: PUSH
75799: EMPTY
75800: LIST
75801: LIST
75802: PUSH
75803: LD_INT 2
75805: NEG
75806: PUSH
75807: LD_INT 0
75809: PUSH
75810: EMPTY
75811: LIST
75812: LIST
75813: PUSH
75814: LD_INT 2
75816: NEG
75817: PUSH
75818: LD_INT 1
75820: NEG
75821: PUSH
75822: EMPTY
75823: LIST
75824: LIST
75825: PUSH
75826: LD_INT 2
75828: NEG
75829: PUSH
75830: LD_INT 2
75832: NEG
75833: PUSH
75834: EMPTY
75835: LIST
75836: LIST
75837: PUSH
75838: EMPTY
75839: LIST
75840: LIST
75841: LIST
75842: LIST
75843: LIST
75844: LIST
75845: LIST
75846: LIST
75847: LIST
75848: LIST
75849: LIST
75850: LIST
75851: ST_TO_ADDR
// fBarracks0 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
75852: LD_ADDR_VAR 0 53
75856: PUSH
75857: LD_INT 0
75859: PUSH
75860: LD_INT 0
75862: PUSH
75863: EMPTY
75864: LIST
75865: LIST
75866: PUSH
75867: LD_INT 0
75869: PUSH
75870: LD_INT 1
75872: NEG
75873: PUSH
75874: EMPTY
75875: LIST
75876: LIST
75877: PUSH
75878: LD_INT 1
75880: PUSH
75881: LD_INT 0
75883: PUSH
75884: EMPTY
75885: LIST
75886: LIST
75887: PUSH
75888: LD_INT 1
75890: PUSH
75891: LD_INT 1
75893: PUSH
75894: EMPTY
75895: LIST
75896: LIST
75897: PUSH
75898: LD_INT 0
75900: PUSH
75901: LD_INT 1
75903: PUSH
75904: EMPTY
75905: LIST
75906: LIST
75907: PUSH
75908: LD_INT 1
75910: NEG
75911: PUSH
75912: LD_INT 0
75914: PUSH
75915: EMPTY
75916: LIST
75917: LIST
75918: PUSH
75919: LD_INT 1
75921: NEG
75922: PUSH
75923: LD_INT 1
75925: NEG
75926: PUSH
75927: EMPTY
75928: LIST
75929: LIST
75930: PUSH
75931: LD_INT 1
75933: NEG
75934: PUSH
75935: LD_INT 2
75937: NEG
75938: PUSH
75939: EMPTY
75940: LIST
75941: LIST
75942: PUSH
75943: LD_INT 0
75945: PUSH
75946: LD_INT 2
75948: NEG
75949: PUSH
75950: EMPTY
75951: LIST
75952: LIST
75953: PUSH
75954: LD_INT 1
75956: PUSH
75957: LD_INT 1
75959: NEG
75960: PUSH
75961: EMPTY
75962: LIST
75963: LIST
75964: PUSH
75965: LD_INT 2
75967: PUSH
75968: LD_INT 0
75970: PUSH
75971: EMPTY
75972: LIST
75973: LIST
75974: PUSH
75975: LD_INT 2
75977: PUSH
75978: LD_INT 1
75980: PUSH
75981: EMPTY
75982: LIST
75983: LIST
75984: PUSH
75985: LD_INT 2
75987: PUSH
75988: LD_INT 2
75990: PUSH
75991: EMPTY
75992: LIST
75993: LIST
75994: PUSH
75995: LD_INT 1
75997: PUSH
75998: LD_INT 2
76000: PUSH
76001: EMPTY
76002: LIST
76003: LIST
76004: PUSH
76005: LD_INT 0
76007: PUSH
76008: LD_INT 2
76010: PUSH
76011: EMPTY
76012: LIST
76013: LIST
76014: PUSH
76015: LD_INT 1
76017: NEG
76018: PUSH
76019: LD_INT 1
76021: PUSH
76022: EMPTY
76023: LIST
76024: LIST
76025: PUSH
76026: LD_INT 2
76028: NEG
76029: PUSH
76030: LD_INT 0
76032: PUSH
76033: EMPTY
76034: LIST
76035: LIST
76036: PUSH
76037: LD_INT 2
76039: NEG
76040: PUSH
76041: LD_INT 1
76043: NEG
76044: PUSH
76045: EMPTY
76046: LIST
76047: LIST
76048: PUSH
76049: LD_INT 2
76051: NEG
76052: PUSH
76053: LD_INT 2
76055: NEG
76056: PUSH
76057: EMPTY
76058: LIST
76059: LIST
76060: PUSH
76061: EMPTY
76062: LIST
76063: LIST
76064: LIST
76065: LIST
76066: LIST
76067: LIST
76068: LIST
76069: LIST
76070: LIST
76071: LIST
76072: LIST
76073: LIST
76074: LIST
76075: LIST
76076: LIST
76077: LIST
76078: LIST
76079: LIST
76080: LIST
76081: ST_TO_ADDR
// fBarracks1 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
76082: LD_ADDR_VAR 0 54
76086: PUSH
76087: LD_INT 0
76089: PUSH
76090: LD_INT 0
76092: PUSH
76093: EMPTY
76094: LIST
76095: LIST
76096: PUSH
76097: LD_INT 0
76099: PUSH
76100: LD_INT 1
76102: NEG
76103: PUSH
76104: EMPTY
76105: LIST
76106: LIST
76107: PUSH
76108: LD_INT 1
76110: PUSH
76111: LD_INT 0
76113: PUSH
76114: EMPTY
76115: LIST
76116: LIST
76117: PUSH
76118: LD_INT 1
76120: PUSH
76121: LD_INT 1
76123: PUSH
76124: EMPTY
76125: LIST
76126: LIST
76127: PUSH
76128: LD_INT 0
76130: PUSH
76131: LD_INT 1
76133: PUSH
76134: EMPTY
76135: LIST
76136: LIST
76137: PUSH
76138: LD_INT 1
76140: NEG
76141: PUSH
76142: LD_INT 0
76144: PUSH
76145: EMPTY
76146: LIST
76147: LIST
76148: PUSH
76149: LD_INT 1
76151: NEG
76152: PUSH
76153: LD_INT 1
76155: NEG
76156: PUSH
76157: EMPTY
76158: LIST
76159: LIST
76160: PUSH
76161: LD_INT 1
76163: NEG
76164: PUSH
76165: LD_INT 2
76167: NEG
76168: PUSH
76169: EMPTY
76170: LIST
76171: LIST
76172: PUSH
76173: LD_INT 0
76175: PUSH
76176: LD_INT 2
76178: NEG
76179: PUSH
76180: EMPTY
76181: LIST
76182: LIST
76183: PUSH
76184: LD_INT 1
76186: PUSH
76187: LD_INT 1
76189: NEG
76190: PUSH
76191: EMPTY
76192: LIST
76193: LIST
76194: PUSH
76195: LD_INT 2
76197: PUSH
76198: LD_INT 0
76200: PUSH
76201: EMPTY
76202: LIST
76203: LIST
76204: PUSH
76205: LD_INT 2
76207: PUSH
76208: LD_INT 1
76210: PUSH
76211: EMPTY
76212: LIST
76213: LIST
76214: PUSH
76215: LD_INT 2
76217: PUSH
76218: LD_INT 2
76220: PUSH
76221: EMPTY
76222: LIST
76223: LIST
76224: PUSH
76225: LD_INT 1
76227: PUSH
76228: LD_INT 2
76230: PUSH
76231: EMPTY
76232: LIST
76233: LIST
76234: PUSH
76235: LD_INT 0
76237: PUSH
76238: LD_INT 2
76240: PUSH
76241: EMPTY
76242: LIST
76243: LIST
76244: PUSH
76245: LD_INT 1
76247: NEG
76248: PUSH
76249: LD_INT 1
76251: PUSH
76252: EMPTY
76253: LIST
76254: LIST
76255: PUSH
76256: LD_INT 2
76258: NEG
76259: PUSH
76260: LD_INT 0
76262: PUSH
76263: EMPTY
76264: LIST
76265: LIST
76266: PUSH
76267: LD_INT 2
76269: NEG
76270: PUSH
76271: LD_INT 1
76273: NEG
76274: PUSH
76275: EMPTY
76276: LIST
76277: LIST
76278: PUSH
76279: LD_INT 2
76281: NEG
76282: PUSH
76283: LD_INT 2
76285: NEG
76286: PUSH
76287: EMPTY
76288: LIST
76289: LIST
76290: PUSH
76291: EMPTY
76292: LIST
76293: LIST
76294: LIST
76295: LIST
76296: LIST
76297: LIST
76298: LIST
76299: LIST
76300: LIST
76301: LIST
76302: LIST
76303: LIST
76304: LIST
76305: LIST
76306: LIST
76307: LIST
76308: LIST
76309: LIST
76310: LIST
76311: ST_TO_ADDR
// fBarracks2 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
76312: LD_ADDR_VAR 0 55
76316: PUSH
76317: LD_INT 0
76319: PUSH
76320: LD_INT 0
76322: PUSH
76323: EMPTY
76324: LIST
76325: LIST
76326: PUSH
76327: LD_INT 0
76329: PUSH
76330: LD_INT 1
76332: NEG
76333: PUSH
76334: EMPTY
76335: LIST
76336: LIST
76337: PUSH
76338: LD_INT 1
76340: PUSH
76341: LD_INT 0
76343: PUSH
76344: EMPTY
76345: LIST
76346: LIST
76347: PUSH
76348: LD_INT 1
76350: PUSH
76351: LD_INT 1
76353: PUSH
76354: EMPTY
76355: LIST
76356: LIST
76357: PUSH
76358: LD_INT 0
76360: PUSH
76361: LD_INT 1
76363: PUSH
76364: EMPTY
76365: LIST
76366: LIST
76367: PUSH
76368: LD_INT 1
76370: NEG
76371: PUSH
76372: LD_INT 0
76374: PUSH
76375: EMPTY
76376: LIST
76377: LIST
76378: PUSH
76379: LD_INT 1
76381: NEG
76382: PUSH
76383: LD_INT 1
76385: NEG
76386: PUSH
76387: EMPTY
76388: LIST
76389: LIST
76390: PUSH
76391: LD_INT 1
76393: NEG
76394: PUSH
76395: LD_INT 2
76397: NEG
76398: PUSH
76399: EMPTY
76400: LIST
76401: LIST
76402: PUSH
76403: LD_INT 0
76405: PUSH
76406: LD_INT 2
76408: NEG
76409: PUSH
76410: EMPTY
76411: LIST
76412: LIST
76413: PUSH
76414: LD_INT 1
76416: PUSH
76417: LD_INT 1
76419: NEG
76420: PUSH
76421: EMPTY
76422: LIST
76423: LIST
76424: PUSH
76425: LD_INT 2
76427: PUSH
76428: LD_INT 0
76430: PUSH
76431: EMPTY
76432: LIST
76433: LIST
76434: PUSH
76435: LD_INT 2
76437: PUSH
76438: LD_INT 1
76440: PUSH
76441: EMPTY
76442: LIST
76443: LIST
76444: PUSH
76445: LD_INT 2
76447: PUSH
76448: LD_INT 2
76450: PUSH
76451: EMPTY
76452: LIST
76453: LIST
76454: PUSH
76455: LD_INT 1
76457: PUSH
76458: LD_INT 2
76460: PUSH
76461: EMPTY
76462: LIST
76463: LIST
76464: PUSH
76465: LD_INT 0
76467: PUSH
76468: LD_INT 2
76470: PUSH
76471: EMPTY
76472: LIST
76473: LIST
76474: PUSH
76475: LD_INT 1
76477: NEG
76478: PUSH
76479: LD_INT 1
76481: PUSH
76482: EMPTY
76483: LIST
76484: LIST
76485: PUSH
76486: LD_INT 2
76488: NEG
76489: PUSH
76490: LD_INT 0
76492: PUSH
76493: EMPTY
76494: LIST
76495: LIST
76496: PUSH
76497: LD_INT 2
76499: NEG
76500: PUSH
76501: LD_INT 1
76503: NEG
76504: PUSH
76505: EMPTY
76506: LIST
76507: LIST
76508: PUSH
76509: LD_INT 2
76511: NEG
76512: PUSH
76513: LD_INT 2
76515: NEG
76516: PUSH
76517: EMPTY
76518: LIST
76519: LIST
76520: PUSH
76521: EMPTY
76522: LIST
76523: LIST
76524: LIST
76525: LIST
76526: LIST
76527: LIST
76528: LIST
76529: LIST
76530: LIST
76531: LIST
76532: LIST
76533: LIST
76534: LIST
76535: LIST
76536: LIST
76537: LIST
76538: LIST
76539: LIST
76540: LIST
76541: ST_TO_ADDR
// fBarracks3 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
76542: LD_ADDR_VAR 0 56
76546: PUSH
76547: LD_INT 0
76549: PUSH
76550: LD_INT 0
76552: PUSH
76553: EMPTY
76554: LIST
76555: LIST
76556: PUSH
76557: LD_INT 0
76559: PUSH
76560: LD_INT 1
76562: NEG
76563: PUSH
76564: EMPTY
76565: LIST
76566: LIST
76567: PUSH
76568: LD_INT 1
76570: PUSH
76571: LD_INT 0
76573: PUSH
76574: EMPTY
76575: LIST
76576: LIST
76577: PUSH
76578: LD_INT 1
76580: PUSH
76581: LD_INT 1
76583: PUSH
76584: EMPTY
76585: LIST
76586: LIST
76587: PUSH
76588: LD_INT 0
76590: PUSH
76591: LD_INT 1
76593: PUSH
76594: EMPTY
76595: LIST
76596: LIST
76597: PUSH
76598: LD_INT 1
76600: NEG
76601: PUSH
76602: LD_INT 0
76604: PUSH
76605: EMPTY
76606: LIST
76607: LIST
76608: PUSH
76609: LD_INT 1
76611: NEG
76612: PUSH
76613: LD_INT 1
76615: NEG
76616: PUSH
76617: EMPTY
76618: LIST
76619: LIST
76620: PUSH
76621: LD_INT 1
76623: NEG
76624: PUSH
76625: LD_INT 2
76627: NEG
76628: PUSH
76629: EMPTY
76630: LIST
76631: LIST
76632: PUSH
76633: LD_INT 0
76635: PUSH
76636: LD_INT 2
76638: NEG
76639: PUSH
76640: EMPTY
76641: LIST
76642: LIST
76643: PUSH
76644: LD_INT 1
76646: PUSH
76647: LD_INT 1
76649: NEG
76650: PUSH
76651: EMPTY
76652: LIST
76653: LIST
76654: PUSH
76655: LD_INT 2
76657: PUSH
76658: LD_INT 0
76660: PUSH
76661: EMPTY
76662: LIST
76663: LIST
76664: PUSH
76665: LD_INT 2
76667: PUSH
76668: LD_INT 1
76670: PUSH
76671: EMPTY
76672: LIST
76673: LIST
76674: PUSH
76675: LD_INT 2
76677: PUSH
76678: LD_INT 2
76680: PUSH
76681: EMPTY
76682: LIST
76683: LIST
76684: PUSH
76685: LD_INT 1
76687: PUSH
76688: LD_INT 2
76690: PUSH
76691: EMPTY
76692: LIST
76693: LIST
76694: PUSH
76695: LD_INT 0
76697: PUSH
76698: LD_INT 2
76700: PUSH
76701: EMPTY
76702: LIST
76703: LIST
76704: PUSH
76705: LD_INT 1
76707: NEG
76708: PUSH
76709: LD_INT 1
76711: PUSH
76712: EMPTY
76713: LIST
76714: LIST
76715: PUSH
76716: LD_INT 2
76718: NEG
76719: PUSH
76720: LD_INT 0
76722: PUSH
76723: EMPTY
76724: LIST
76725: LIST
76726: PUSH
76727: LD_INT 2
76729: NEG
76730: PUSH
76731: LD_INT 1
76733: NEG
76734: PUSH
76735: EMPTY
76736: LIST
76737: LIST
76738: PUSH
76739: LD_INT 2
76741: NEG
76742: PUSH
76743: LD_INT 2
76745: NEG
76746: PUSH
76747: EMPTY
76748: LIST
76749: LIST
76750: PUSH
76751: EMPTY
76752: LIST
76753: LIST
76754: LIST
76755: LIST
76756: LIST
76757: LIST
76758: LIST
76759: LIST
76760: LIST
76761: LIST
76762: LIST
76763: LIST
76764: LIST
76765: LIST
76766: LIST
76767: LIST
76768: LIST
76769: LIST
76770: LIST
76771: ST_TO_ADDR
// fBarracks4 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
76772: LD_ADDR_VAR 0 57
76776: PUSH
76777: LD_INT 0
76779: PUSH
76780: LD_INT 0
76782: PUSH
76783: EMPTY
76784: LIST
76785: LIST
76786: PUSH
76787: LD_INT 0
76789: PUSH
76790: LD_INT 1
76792: NEG
76793: PUSH
76794: EMPTY
76795: LIST
76796: LIST
76797: PUSH
76798: LD_INT 1
76800: PUSH
76801: LD_INT 0
76803: PUSH
76804: EMPTY
76805: LIST
76806: LIST
76807: PUSH
76808: LD_INT 1
76810: PUSH
76811: LD_INT 1
76813: PUSH
76814: EMPTY
76815: LIST
76816: LIST
76817: PUSH
76818: LD_INT 0
76820: PUSH
76821: LD_INT 1
76823: PUSH
76824: EMPTY
76825: LIST
76826: LIST
76827: PUSH
76828: LD_INT 1
76830: NEG
76831: PUSH
76832: LD_INT 0
76834: PUSH
76835: EMPTY
76836: LIST
76837: LIST
76838: PUSH
76839: LD_INT 1
76841: NEG
76842: PUSH
76843: LD_INT 1
76845: NEG
76846: PUSH
76847: EMPTY
76848: LIST
76849: LIST
76850: PUSH
76851: LD_INT 1
76853: NEG
76854: PUSH
76855: LD_INT 2
76857: NEG
76858: PUSH
76859: EMPTY
76860: LIST
76861: LIST
76862: PUSH
76863: LD_INT 0
76865: PUSH
76866: LD_INT 2
76868: NEG
76869: PUSH
76870: EMPTY
76871: LIST
76872: LIST
76873: PUSH
76874: LD_INT 1
76876: PUSH
76877: LD_INT 1
76879: NEG
76880: PUSH
76881: EMPTY
76882: LIST
76883: LIST
76884: PUSH
76885: LD_INT 2
76887: PUSH
76888: LD_INT 0
76890: PUSH
76891: EMPTY
76892: LIST
76893: LIST
76894: PUSH
76895: LD_INT 2
76897: PUSH
76898: LD_INT 1
76900: PUSH
76901: EMPTY
76902: LIST
76903: LIST
76904: PUSH
76905: LD_INT 2
76907: PUSH
76908: LD_INT 2
76910: PUSH
76911: EMPTY
76912: LIST
76913: LIST
76914: PUSH
76915: LD_INT 1
76917: PUSH
76918: LD_INT 2
76920: PUSH
76921: EMPTY
76922: LIST
76923: LIST
76924: PUSH
76925: LD_INT 0
76927: PUSH
76928: LD_INT 2
76930: PUSH
76931: EMPTY
76932: LIST
76933: LIST
76934: PUSH
76935: LD_INT 1
76937: NEG
76938: PUSH
76939: LD_INT 1
76941: PUSH
76942: EMPTY
76943: LIST
76944: LIST
76945: PUSH
76946: LD_INT 2
76948: NEG
76949: PUSH
76950: LD_INT 0
76952: PUSH
76953: EMPTY
76954: LIST
76955: LIST
76956: PUSH
76957: LD_INT 2
76959: NEG
76960: PUSH
76961: LD_INT 1
76963: NEG
76964: PUSH
76965: EMPTY
76966: LIST
76967: LIST
76968: PUSH
76969: LD_INT 2
76971: NEG
76972: PUSH
76973: LD_INT 2
76975: NEG
76976: PUSH
76977: EMPTY
76978: LIST
76979: LIST
76980: PUSH
76981: EMPTY
76982: LIST
76983: LIST
76984: LIST
76985: LIST
76986: LIST
76987: LIST
76988: LIST
76989: LIST
76990: LIST
76991: LIST
76992: LIST
76993: LIST
76994: LIST
76995: LIST
76996: LIST
76997: LIST
76998: LIST
76999: LIST
77000: LIST
77001: ST_TO_ADDR
// fBarracks5 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
77002: LD_ADDR_VAR 0 58
77006: PUSH
77007: LD_INT 0
77009: PUSH
77010: LD_INT 0
77012: PUSH
77013: EMPTY
77014: LIST
77015: LIST
77016: PUSH
77017: LD_INT 0
77019: PUSH
77020: LD_INT 1
77022: NEG
77023: PUSH
77024: EMPTY
77025: LIST
77026: LIST
77027: PUSH
77028: LD_INT 1
77030: PUSH
77031: LD_INT 0
77033: PUSH
77034: EMPTY
77035: LIST
77036: LIST
77037: PUSH
77038: LD_INT 1
77040: PUSH
77041: LD_INT 1
77043: PUSH
77044: EMPTY
77045: LIST
77046: LIST
77047: PUSH
77048: LD_INT 0
77050: PUSH
77051: LD_INT 1
77053: PUSH
77054: EMPTY
77055: LIST
77056: LIST
77057: PUSH
77058: LD_INT 1
77060: NEG
77061: PUSH
77062: LD_INT 0
77064: PUSH
77065: EMPTY
77066: LIST
77067: LIST
77068: PUSH
77069: LD_INT 1
77071: NEG
77072: PUSH
77073: LD_INT 1
77075: NEG
77076: PUSH
77077: EMPTY
77078: LIST
77079: LIST
77080: PUSH
77081: LD_INT 1
77083: NEG
77084: PUSH
77085: LD_INT 2
77087: NEG
77088: PUSH
77089: EMPTY
77090: LIST
77091: LIST
77092: PUSH
77093: LD_INT 0
77095: PUSH
77096: LD_INT 2
77098: NEG
77099: PUSH
77100: EMPTY
77101: LIST
77102: LIST
77103: PUSH
77104: LD_INT 1
77106: PUSH
77107: LD_INT 1
77109: NEG
77110: PUSH
77111: EMPTY
77112: LIST
77113: LIST
77114: PUSH
77115: LD_INT 2
77117: PUSH
77118: LD_INT 0
77120: PUSH
77121: EMPTY
77122: LIST
77123: LIST
77124: PUSH
77125: LD_INT 2
77127: PUSH
77128: LD_INT 1
77130: PUSH
77131: EMPTY
77132: LIST
77133: LIST
77134: PUSH
77135: LD_INT 2
77137: PUSH
77138: LD_INT 2
77140: PUSH
77141: EMPTY
77142: LIST
77143: LIST
77144: PUSH
77145: LD_INT 1
77147: PUSH
77148: LD_INT 2
77150: PUSH
77151: EMPTY
77152: LIST
77153: LIST
77154: PUSH
77155: LD_INT 0
77157: PUSH
77158: LD_INT 2
77160: PUSH
77161: EMPTY
77162: LIST
77163: LIST
77164: PUSH
77165: LD_INT 1
77167: NEG
77168: PUSH
77169: LD_INT 1
77171: PUSH
77172: EMPTY
77173: LIST
77174: LIST
77175: PUSH
77176: LD_INT 2
77178: NEG
77179: PUSH
77180: LD_INT 0
77182: PUSH
77183: EMPTY
77184: LIST
77185: LIST
77186: PUSH
77187: LD_INT 2
77189: NEG
77190: PUSH
77191: LD_INT 1
77193: NEG
77194: PUSH
77195: EMPTY
77196: LIST
77197: LIST
77198: PUSH
77199: LD_INT 2
77201: NEG
77202: PUSH
77203: LD_INT 2
77205: NEG
77206: PUSH
77207: EMPTY
77208: LIST
77209: LIST
77210: PUSH
77211: EMPTY
77212: LIST
77213: LIST
77214: LIST
77215: LIST
77216: LIST
77217: LIST
77218: LIST
77219: LIST
77220: LIST
77221: LIST
77222: LIST
77223: LIST
77224: LIST
77225: LIST
77226: LIST
77227: LIST
77228: LIST
77229: LIST
77230: LIST
77231: ST_TO_ADDR
// fBunker0 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] ] ;
77232: LD_ADDR_VAR 0 59
77236: PUSH
77237: LD_INT 0
77239: PUSH
77240: LD_INT 0
77242: PUSH
77243: EMPTY
77244: LIST
77245: LIST
77246: PUSH
77247: LD_INT 0
77249: PUSH
77250: LD_INT 1
77252: NEG
77253: PUSH
77254: EMPTY
77255: LIST
77256: LIST
77257: PUSH
77258: LD_INT 1
77260: PUSH
77261: LD_INT 0
77263: PUSH
77264: EMPTY
77265: LIST
77266: LIST
77267: PUSH
77268: LD_INT 1
77270: PUSH
77271: LD_INT 1
77273: PUSH
77274: EMPTY
77275: LIST
77276: LIST
77277: PUSH
77278: LD_INT 0
77280: PUSH
77281: LD_INT 1
77283: PUSH
77284: EMPTY
77285: LIST
77286: LIST
77287: PUSH
77288: LD_INT 1
77290: NEG
77291: PUSH
77292: LD_INT 0
77294: PUSH
77295: EMPTY
77296: LIST
77297: LIST
77298: PUSH
77299: LD_INT 1
77301: NEG
77302: PUSH
77303: LD_INT 1
77305: NEG
77306: PUSH
77307: EMPTY
77308: LIST
77309: LIST
77310: PUSH
77311: EMPTY
77312: LIST
77313: LIST
77314: LIST
77315: LIST
77316: LIST
77317: LIST
77318: LIST
77319: ST_TO_ADDR
// fBunker1 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] ] ;
77320: LD_ADDR_VAR 0 60
77324: PUSH
77325: LD_INT 0
77327: PUSH
77328: LD_INT 0
77330: PUSH
77331: EMPTY
77332: LIST
77333: LIST
77334: PUSH
77335: LD_INT 0
77337: PUSH
77338: LD_INT 1
77340: NEG
77341: PUSH
77342: EMPTY
77343: LIST
77344: LIST
77345: PUSH
77346: LD_INT 1
77348: PUSH
77349: LD_INT 0
77351: PUSH
77352: EMPTY
77353: LIST
77354: LIST
77355: PUSH
77356: LD_INT 1
77358: PUSH
77359: LD_INT 1
77361: PUSH
77362: EMPTY
77363: LIST
77364: LIST
77365: PUSH
77366: LD_INT 0
77368: PUSH
77369: LD_INT 1
77371: PUSH
77372: EMPTY
77373: LIST
77374: LIST
77375: PUSH
77376: LD_INT 1
77378: NEG
77379: PUSH
77380: LD_INT 0
77382: PUSH
77383: EMPTY
77384: LIST
77385: LIST
77386: PUSH
77387: LD_INT 1
77389: NEG
77390: PUSH
77391: LD_INT 1
77393: NEG
77394: PUSH
77395: EMPTY
77396: LIST
77397: LIST
77398: PUSH
77399: EMPTY
77400: LIST
77401: LIST
77402: LIST
77403: LIST
77404: LIST
77405: LIST
77406: LIST
77407: ST_TO_ADDR
// fBunker2 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] ] ;
77408: LD_ADDR_VAR 0 61
77412: PUSH
77413: LD_INT 0
77415: PUSH
77416: LD_INT 0
77418: PUSH
77419: EMPTY
77420: LIST
77421: LIST
77422: PUSH
77423: LD_INT 0
77425: PUSH
77426: LD_INT 1
77428: NEG
77429: PUSH
77430: EMPTY
77431: LIST
77432: LIST
77433: PUSH
77434: LD_INT 1
77436: PUSH
77437: LD_INT 0
77439: PUSH
77440: EMPTY
77441: LIST
77442: LIST
77443: PUSH
77444: LD_INT 1
77446: PUSH
77447: LD_INT 1
77449: PUSH
77450: EMPTY
77451: LIST
77452: LIST
77453: PUSH
77454: LD_INT 0
77456: PUSH
77457: LD_INT 1
77459: PUSH
77460: EMPTY
77461: LIST
77462: LIST
77463: PUSH
77464: LD_INT 1
77466: NEG
77467: PUSH
77468: LD_INT 0
77470: PUSH
77471: EMPTY
77472: LIST
77473: LIST
77474: PUSH
77475: LD_INT 1
77477: NEG
77478: PUSH
77479: LD_INT 1
77481: NEG
77482: PUSH
77483: EMPTY
77484: LIST
77485: LIST
77486: PUSH
77487: EMPTY
77488: LIST
77489: LIST
77490: LIST
77491: LIST
77492: LIST
77493: LIST
77494: LIST
77495: ST_TO_ADDR
// fBunker3 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] ] ;
77496: LD_ADDR_VAR 0 62
77500: PUSH
77501: LD_INT 0
77503: PUSH
77504: LD_INT 0
77506: PUSH
77507: EMPTY
77508: LIST
77509: LIST
77510: PUSH
77511: LD_INT 0
77513: PUSH
77514: LD_INT 1
77516: NEG
77517: PUSH
77518: EMPTY
77519: LIST
77520: LIST
77521: PUSH
77522: LD_INT 1
77524: PUSH
77525: LD_INT 0
77527: PUSH
77528: EMPTY
77529: LIST
77530: LIST
77531: PUSH
77532: LD_INT 1
77534: PUSH
77535: LD_INT 1
77537: PUSH
77538: EMPTY
77539: LIST
77540: LIST
77541: PUSH
77542: LD_INT 0
77544: PUSH
77545: LD_INT 1
77547: PUSH
77548: EMPTY
77549: LIST
77550: LIST
77551: PUSH
77552: LD_INT 1
77554: NEG
77555: PUSH
77556: LD_INT 0
77558: PUSH
77559: EMPTY
77560: LIST
77561: LIST
77562: PUSH
77563: LD_INT 1
77565: NEG
77566: PUSH
77567: LD_INT 1
77569: NEG
77570: PUSH
77571: EMPTY
77572: LIST
77573: LIST
77574: PUSH
77575: EMPTY
77576: LIST
77577: LIST
77578: LIST
77579: LIST
77580: LIST
77581: LIST
77582: LIST
77583: ST_TO_ADDR
// fBunker4 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] ] ;
77584: LD_ADDR_VAR 0 63
77588: PUSH
77589: LD_INT 0
77591: PUSH
77592: LD_INT 0
77594: PUSH
77595: EMPTY
77596: LIST
77597: LIST
77598: PUSH
77599: LD_INT 0
77601: PUSH
77602: LD_INT 1
77604: NEG
77605: PUSH
77606: EMPTY
77607: LIST
77608: LIST
77609: PUSH
77610: LD_INT 1
77612: PUSH
77613: LD_INT 0
77615: PUSH
77616: EMPTY
77617: LIST
77618: LIST
77619: PUSH
77620: LD_INT 1
77622: PUSH
77623: LD_INT 1
77625: PUSH
77626: EMPTY
77627: LIST
77628: LIST
77629: PUSH
77630: LD_INT 0
77632: PUSH
77633: LD_INT 1
77635: PUSH
77636: EMPTY
77637: LIST
77638: LIST
77639: PUSH
77640: LD_INT 1
77642: NEG
77643: PUSH
77644: LD_INT 0
77646: PUSH
77647: EMPTY
77648: LIST
77649: LIST
77650: PUSH
77651: LD_INT 1
77653: NEG
77654: PUSH
77655: LD_INT 1
77657: NEG
77658: PUSH
77659: EMPTY
77660: LIST
77661: LIST
77662: PUSH
77663: EMPTY
77664: LIST
77665: LIST
77666: LIST
77667: LIST
77668: LIST
77669: LIST
77670: LIST
77671: ST_TO_ADDR
// fBunker5 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] ] ;
77672: LD_ADDR_VAR 0 64
77676: PUSH
77677: LD_INT 0
77679: PUSH
77680: LD_INT 0
77682: PUSH
77683: EMPTY
77684: LIST
77685: LIST
77686: PUSH
77687: LD_INT 0
77689: PUSH
77690: LD_INT 1
77692: NEG
77693: PUSH
77694: EMPTY
77695: LIST
77696: LIST
77697: PUSH
77698: LD_INT 1
77700: PUSH
77701: LD_INT 0
77703: PUSH
77704: EMPTY
77705: LIST
77706: LIST
77707: PUSH
77708: LD_INT 1
77710: PUSH
77711: LD_INT 1
77713: PUSH
77714: EMPTY
77715: LIST
77716: LIST
77717: PUSH
77718: LD_INT 0
77720: PUSH
77721: LD_INT 1
77723: PUSH
77724: EMPTY
77725: LIST
77726: LIST
77727: PUSH
77728: LD_INT 1
77730: NEG
77731: PUSH
77732: LD_INT 0
77734: PUSH
77735: EMPTY
77736: LIST
77737: LIST
77738: PUSH
77739: LD_INT 1
77741: NEG
77742: PUSH
77743: LD_INT 1
77745: NEG
77746: PUSH
77747: EMPTY
77748: LIST
77749: LIST
77750: PUSH
77751: EMPTY
77752: LIST
77753: LIST
77754: LIST
77755: LIST
77756: LIST
77757: LIST
77758: LIST
77759: ST_TO_ADDR
// end ; 1 :
77760: GO 83657
77762: LD_INT 1
77764: DOUBLE
77765: EQUAL
77766: IFTRUE 77770
77768: GO 80393
77770: POP
// begin fDepotAm0 = [ [ - 1 , - 3 ] , [ 0 , - 3 ] , [ 1 , - 2 ] ] ;
77771: LD_ADDR_VAR 0 11
77775: PUSH
77776: LD_INT 1
77778: NEG
77779: PUSH
77780: LD_INT 3
77782: NEG
77783: PUSH
77784: EMPTY
77785: LIST
77786: LIST
77787: PUSH
77788: LD_INT 0
77790: PUSH
77791: LD_INT 3
77793: NEG
77794: PUSH
77795: EMPTY
77796: LIST
77797: LIST
77798: PUSH
77799: LD_INT 1
77801: PUSH
77802: LD_INT 2
77804: NEG
77805: PUSH
77806: EMPTY
77807: LIST
77808: LIST
77809: PUSH
77810: EMPTY
77811: LIST
77812: LIST
77813: LIST
77814: ST_TO_ADDR
// fDepotAm1 = [ [ 2 , - 1 ] , [ 3 , 0 ] , [ 3 , 1 ] ] ;
77815: LD_ADDR_VAR 0 12
77819: PUSH
77820: LD_INT 2
77822: PUSH
77823: LD_INT 1
77825: NEG
77826: PUSH
77827: EMPTY
77828: LIST
77829: LIST
77830: PUSH
77831: LD_INT 3
77833: PUSH
77834: LD_INT 0
77836: PUSH
77837: EMPTY
77838: LIST
77839: LIST
77840: PUSH
77841: LD_INT 3
77843: PUSH
77844: LD_INT 1
77846: PUSH
77847: EMPTY
77848: LIST
77849: LIST
77850: PUSH
77851: EMPTY
77852: LIST
77853: LIST
77854: LIST
77855: ST_TO_ADDR
// fDepotAm2 = [ [ 3 , 2 ] , [ 3 , 3 ] , [ 2 , 3 ] ] ;
77856: LD_ADDR_VAR 0 13
77860: PUSH
77861: LD_INT 3
77863: PUSH
77864: LD_INT 2
77866: PUSH
77867: EMPTY
77868: LIST
77869: LIST
77870: PUSH
77871: LD_INT 3
77873: PUSH
77874: LD_INT 3
77876: PUSH
77877: EMPTY
77878: LIST
77879: LIST
77880: PUSH
77881: LD_INT 2
77883: PUSH
77884: LD_INT 3
77886: PUSH
77887: EMPTY
77888: LIST
77889: LIST
77890: PUSH
77891: EMPTY
77892: LIST
77893: LIST
77894: LIST
77895: ST_TO_ADDR
// fDepotAm3 = [ [ 1 , 3 ] , [ 0 , 3 ] , [ - 1 , 2 ] ] ;
77896: LD_ADDR_VAR 0 14
77900: PUSH
77901: LD_INT 1
77903: PUSH
77904: LD_INT 3
77906: PUSH
77907: EMPTY
77908: LIST
77909: LIST
77910: PUSH
77911: LD_INT 0
77913: PUSH
77914: LD_INT 3
77916: PUSH
77917: EMPTY
77918: LIST
77919: LIST
77920: PUSH
77921: LD_INT 1
77923: NEG
77924: PUSH
77925: LD_INT 2
77927: PUSH
77928: EMPTY
77929: LIST
77930: LIST
77931: PUSH
77932: EMPTY
77933: LIST
77934: LIST
77935: LIST
77936: ST_TO_ADDR
// fDepotAm4 = [ [ - 2 , 1 ] , [ - 3 , 0 ] , [ - 3 , - 1 ] ] ;
77937: LD_ADDR_VAR 0 15
77941: PUSH
77942: LD_INT 2
77944: NEG
77945: PUSH
77946: LD_INT 1
77948: PUSH
77949: EMPTY
77950: LIST
77951: LIST
77952: PUSH
77953: LD_INT 3
77955: NEG
77956: PUSH
77957: LD_INT 0
77959: PUSH
77960: EMPTY
77961: LIST
77962: LIST
77963: PUSH
77964: LD_INT 3
77966: NEG
77967: PUSH
77968: LD_INT 1
77970: NEG
77971: PUSH
77972: EMPTY
77973: LIST
77974: LIST
77975: PUSH
77976: EMPTY
77977: LIST
77978: LIST
77979: LIST
77980: ST_TO_ADDR
// fDepotAm5 = [ [ - 2 , - 3 ] , [ - 3 , - 2 ] , [ - 3 , - 3 ] ] ;
77981: LD_ADDR_VAR 0 16
77985: PUSH
77986: LD_INT 2
77988: NEG
77989: PUSH
77990: LD_INT 3
77992: NEG
77993: PUSH
77994: EMPTY
77995: LIST
77996: LIST
77997: PUSH
77998: LD_INT 3
78000: NEG
78001: PUSH
78002: LD_INT 2
78004: NEG
78005: PUSH
78006: EMPTY
78007: LIST
78008: LIST
78009: PUSH
78010: LD_INT 3
78012: NEG
78013: PUSH
78014: LD_INT 3
78016: NEG
78017: PUSH
78018: EMPTY
78019: LIST
78020: LIST
78021: PUSH
78022: EMPTY
78023: LIST
78024: LIST
78025: LIST
78026: ST_TO_ADDR
// fDepotAr0 = [ [ - 1 , - 3 ] , [ 0 , - 3 ] , [ 1 , - 2 ] ] ;
78027: LD_ADDR_VAR 0 17
78031: PUSH
78032: LD_INT 1
78034: NEG
78035: PUSH
78036: LD_INT 3
78038: NEG
78039: PUSH
78040: EMPTY
78041: LIST
78042: LIST
78043: PUSH
78044: LD_INT 0
78046: PUSH
78047: LD_INT 3
78049: NEG
78050: PUSH
78051: EMPTY
78052: LIST
78053: LIST
78054: PUSH
78055: LD_INT 1
78057: PUSH
78058: LD_INT 2
78060: NEG
78061: PUSH
78062: EMPTY
78063: LIST
78064: LIST
78065: PUSH
78066: EMPTY
78067: LIST
78068: LIST
78069: LIST
78070: ST_TO_ADDR
// fDepotAr1 = [ [ 2 , - 1 ] , [ 3 , 0 ] , [ 3 , 1 ] ] ;
78071: LD_ADDR_VAR 0 18
78075: PUSH
78076: LD_INT 2
78078: PUSH
78079: LD_INT 1
78081: NEG
78082: PUSH
78083: EMPTY
78084: LIST
78085: LIST
78086: PUSH
78087: LD_INT 3
78089: PUSH
78090: LD_INT 0
78092: PUSH
78093: EMPTY
78094: LIST
78095: LIST
78096: PUSH
78097: LD_INT 3
78099: PUSH
78100: LD_INT 1
78102: PUSH
78103: EMPTY
78104: LIST
78105: LIST
78106: PUSH
78107: EMPTY
78108: LIST
78109: LIST
78110: LIST
78111: ST_TO_ADDR
// fDepotAr2 = [ [ 3 , 2 ] , [ 3 , 3 ] , [ 2 , 3 ] ] ;
78112: LD_ADDR_VAR 0 19
78116: PUSH
78117: LD_INT 3
78119: PUSH
78120: LD_INT 2
78122: PUSH
78123: EMPTY
78124: LIST
78125: LIST
78126: PUSH
78127: LD_INT 3
78129: PUSH
78130: LD_INT 3
78132: PUSH
78133: EMPTY
78134: LIST
78135: LIST
78136: PUSH
78137: LD_INT 2
78139: PUSH
78140: LD_INT 3
78142: PUSH
78143: EMPTY
78144: LIST
78145: LIST
78146: PUSH
78147: EMPTY
78148: LIST
78149: LIST
78150: LIST
78151: ST_TO_ADDR
// fDepotAr3 = [ [ 1 , 3 ] , [ 0 , 3 ] , [ - 1 , 2 ] ] ;
78152: LD_ADDR_VAR 0 20
78156: PUSH
78157: LD_INT 1
78159: PUSH
78160: LD_INT 3
78162: PUSH
78163: EMPTY
78164: LIST
78165: LIST
78166: PUSH
78167: LD_INT 0
78169: PUSH
78170: LD_INT 3
78172: PUSH
78173: EMPTY
78174: LIST
78175: LIST
78176: PUSH
78177: LD_INT 1
78179: NEG
78180: PUSH
78181: LD_INT 2
78183: PUSH
78184: EMPTY
78185: LIST
78186: LIST
78187: PUSH
78188: EMPTY
78189: LIST
78190: LIST
78191: LIST
78192: ST_TO_ADDR
// fDepotAr4 = [ [ - 2 , 1 ] , [ - 3 , 0 ] , [ - 3 , - 1 ] ] ;
78193: LD_ADDR_VAR 0 21
78197: PUSH
78198: LD_INT 2
78200: NEG
78201: PUSH
78202: LD_INT 1
78204: PUSH
78205: EMPTY
78206: LIST
78207: LIST
78208: PUSH
78209: LD_INT 3
78211: NEG
78212: PUSH
78213: LD_INT 0
78215: PUSH
78216: EMPTY
78217: LIST
78218: LIST
78219: PUSH
78220: LD_INT 3
78222: NEG
78223: PUSH
78224: LD_INT 1
78226: NEG
78227: PUSH
78228: EMPTY
78229: LIST
78230: LIST
78231: PUSH
78232: EMPTY
78233: LIST
78234: LIST
78235: LIST
78236: ST_TO_ADDR
// fDepotAr5 = [ [ - 2 , - 3 ] , [ - 3 , - 2 ] , [ - 3 , - 3 ] ] ;
78237: LD_ADDR_VAR 0 22
78241: PUSH
78242: LD_INT 2
78244: NEG
78245: PUSH
78246: LD_INT 3
78248: NEG
78249: PUSH
78250: EMPTY
78251: LIST
78252: LIST
78253: PUSH
78254: LD_INT 3
78256: NEG
78257: PUSH
78258: LD_INT 2
78260: NEG
78261: PUSH
78262: EMPTY
78263: LIST
78264: LIST
78265: PUSH
78266: LD_INT 3
78268: NEG
78269: PUSH
78270: LD_INT 3
78272: NEG
78273: PUSH
78274: EMPTY
78275: LIST
78276: LIST
78277: PUSH
78278: EMPTY
78279: LIST
78280: LIST
78281: LIST
78282: ST_TO_ADDR
// fDepotRu0 = [ [ 0 , - 3 ] , [ - 1 , - 4 ] , [ 1 , - 3 ] ] ;
78283: LD_ADDR_VAR 0 23
78287: PUSH
78288: LD_INT 0
78290: PUSH
78291: LD_INT 3
78293: NEG
78294: PUSH
78295: EMPTY
78296: LIST
78297: LIST
78298: PUSH
78299: LD_INT 1
78301: NEG
78302: PUSH
78303: LD_INT 4
78305: NEG
78306: PUSH
78307: EMPTY
78308: LIST
78309: LIST
78310: PUSH
78311: LD_INT 1
78313: PUSH
78314: LD_INT 3
78316: NEG
78317: PUSH
78318: EMPTY
78319: LIST
78320: LIST
78321: PUSH
78322: EMPTY
78323: LIST
78324: LIST
78325: LIST
78326: ST_TO_ADDR
// fDepotRu1 = [ [ 3 , 0 ] , [ 3 , - 1 ] , [ 4 , 1 ] ] ;
78327: LD_ADDR_VAR 0 24
78331: PUSH
78332: LD_INT 3
78334: PUSH
78335: LD_INT 0
78337: PUSH
78338: EMPTY
78339: LIST
78340: LIST
78341: PUSH
78342: LD_INT 3
78344: PUSH
78345: LD_INT 1
78347: NEG
78348: PUSH
78349: EMPTY
78350: LIST
78351: LIST
78352: PUSH
78353: LD_INT 4
78355: PUSH
78356: LD_INT 1
78358: PUSH
78359: EMPTY
78360: LIST
78361: LIST
78362: PUSH
78363: EMPTY
78364: LIST
78365: LIST
78366: LIST
78367: ST_TO_ADDR
// fDepotRu2 = [ [ 3 , 3 ] , [ 4 , 3 ] , [ 3 , 4 ] ] ;
78368: LD_ADDR_VAR 0 25
78372: PUSH
78373: LD_INT 3
78375: PUSH
78376: LD_INT 3
78378: PUSH
78379: EMPTY
78380: LIST
78381: LIST
78382: PUSH
78383: LD_INT 4
78385: PUSH
78386: LD_INT 3
78388: PUSH
78389: EMPTY
78390: LIST
78391: LIST
78392: PUSH
78393: LD_INT 3
78395: PUSH
78396: LD_INT 4
78398: PUSH
78399: EMPTY
78400: LIST
78401: LIST
78402: PUSH
78403: EMPTY
78404: LIST
78405: LIST
78406: LIST
78407: ST_TO_ADDR
// fDepotRu3 = [ [ 0 , 3 ] , [ 1 , 4 ] , [ - 1 , 3 ] ] ;
78408: LD_ADDR_VAR 0 26
78412: PUSH
78413: LD_INT 0
78415: PUSH
78416: LD_INT 3
78418: PUSH
78419: EMPTY
78420: LIST
78421: LIST
78422: PUSH
78423: LD_INT 1
78425: PUSH
78426: LD_INT 4
78428: PUSH
78429: EMPTY
78430: LIST
78431: LIST
78432: PUSH
78433: LD_INT 1
78435: NEG
78436: PUSH
78437: LD_INT 3
78439: PUSH
78440: EMPTY
78441: LIST
78442: LIST
78443: PUSH
78444: EMPTY
78445: LIST
78446: LIST
78447: LIST
78448: ST_TO_ADDR
// fDepotRu4 = [ [ - 3 , 0 ] , [ - 3 , 1 ] , [ - 4 , - 1 ] ] ;
78449: LD_ADDR_VAR 0 27
78453: PUSH
78454: LD_INT 3
78456: NEG
78457: PUSH
78458: LD_INT 0
78460: PUSH
78461: EMPTY
78462: LIST
78463: LIST
78464: PUSH
78465: LD_INT 3
78467: NEG
78468: PUSH
78469: LD_INT 1
78471: PUSH
78472: EMPTY
78473: LIST
78474: LIST
78475: PUSH
78476: LD_INT 4
78478: NEG
78479: PUSH
78480: LD_INT 1
78482: NEG
78483: PUSH
78484: EMPTY
78485: LIST
78486: LIST
78487: PUSH
78488: EMPTY
78489: LIST
78490: LIST
78491: LIST
78492: ST_TO_ADDR
// fDepotRu5 = [ [ - 3 , - 3 ] , [ - 3 , - 4 ] , [ - 4 , - 3 ] ] ;
78493: LD_ADDR_VAR 0 28
78497: PUSH
78498: LD_INT 3
78500: NEG
78501: PUSH
78502: LD_INT 3
78504: NEG
78505: PUSH
78506: EMPTY
78507: LIST
78508: LIST
78509: PUSH
78510: LD_INT 3
78512: NEG
78513: PUSH
78514: LD_INT 4
78516: NEG
78517: PUSH
78518: EMPTY
78519: LIST
78520: LIST
78521: PUSH
78522: LD_INT 4
78524: NEG
78525: PUSH
78526: LD_INT 3
78528: NEG
78529: PUSH
78530: EMPTY
78531: LIST
78532: LIST
78533: PUSH
78534: EMPTY
78535: LIST
78536: LIST
78537: LIST
78538: ST_TO_ADDR
// fFactory0 = [ [ - 1 , - 3 ] , [ 0 , - 3 ] , [ 1 , - 2 ] , [ - 1 , - 4 ] , [ 0 , - 4 ] , [ 1 , - 3 ] , [ - 1 , - 5 ] , [ 0 , - 5 ] , [ 1 , - 4 ] , [ - 1 , - 6 ] , [ 0 , - 6 ] , [ 1 , - 5 ] ] ;
78539: LD_ADDR_VAR 0 29
78543: PUSH
78544: LD_INT 1
78546: NEG
78547: PUSH
78548: LD_INT 3
78550: NEG
78551: PUSH
78552: EMPTY
78553: LIST
78554: LIST
78555: PUSH
78556: LD_INT 0
78558: PUSH
78559: LD_INT 3
78561: NEG
78562: PUSH
78563: EMPTY
78564: LIST
78565: LIST
78566: PUSH
78567: LD_INT 1
78569: PUSH
78570: LD_INT 2
78572: NEG
78573: PUSH
78574: EMPTY
78575: LIST
78576: LIST
78577: PUSH
78578: LD_INT 1
78580: NEG
78581: PUSH
78582: LD_INT 4
78584: NEG
78585: PUSH
78586: EMPTY
78587: LIST
78588: LIST
78589: PUSH
78590: LD_INT 0
78592: PUSH
78593: LD_INT 4
78595: NEG
78596: PUSH
78597: EMPTY
78598: LIST
78599: LIST
78600: PUSH
78601: LD_INT 1
78603: PUSH
78604: LD_INT 3
78606: NEG
78607: PUSH
78608: EMPTY
78609: LIST
78610: LIST
78611: PUSH
78612: LD_INT 1
78614: NEG
78615: PUSH
78616: LD_INT 5
78618: NEG
78619: PUSH
78620: EMPTY
78621: LIST
78622: LIST
78623: PUSH
78624: LD_INT 0
78626: PUSH
78627: LD_INT 5
78629: NEG
78630: PUSH
78631: EMPTY
78632: LIST
78633: LIST
78634: PUSH
78635: LD_INT 1
78637: PUSH
78638: LD_INT 4
78640: NEG
78641: PUSH
78642: EMPTY
78643: LIST
78644: LIST
78645: PUSH
78646: LD_INT 1
78648: NEG
78649: PUSH
78650: LD_INT 6
78652: NEG
78653: PUSH
78654: EMPTY
78655: LIST
78656: LIST
78657: PUSH
78658: LD_INT 0
78660: PUSH
78661: LD_INT 6
78663: NEG
78664: PUSH
78665: EMPTY
78666: LIST
78667: LIST
78668: PUSH
78669: LD_INT 1
78671: PUSH
78672: LD_INT 5
78674: NEG
78675: PUSH
78676: EMPTY
78677: LIST
78678: LIST
78679: PUSH
78680: EMPTY
78681: LIST
78682: LIST
78683: LIST
78684: LIST
78685: LIST
78686: LIST
78687: LIST
78688: LIST
78689: LIST
78690: LIST
78691: LIST
78692: LIST
78693: ST_TO_ADDR
// fFactory1 = [ [ 2 , - 1 ] , [ 3 , 0 ] , [ 3 , 1 ] , [ 3 , - 1 ] , [ 4 , 0 ] , [ 4 , 1 ] , [ 4 , - 1 ] , [ 5 , 0 ] , [ 5 , 1 ] , [ 5 , - 1 ] , [ 6 , 0 ] , [ 6 , 1 ] ] ;
78694: LD_ADDR_VAR 0 30
78698: PUSH
78699: LD_INT 2
78701: PUSH
78702: LD_INT 1
78704: NEG
78705: PUSH
78706: EMPTY
78707: LIST
78708: LIST
78709: PUSH
78710: LD_INT 3
78712: PUSH
78713: LD_INT 0
78715: PUSH
78716: EMPTY
78717: LIST
78718: LIST
78719: PUSH
78720: LD_INT 3
78722: PUSH
78723: LD_INT 1
78725: PUSH
78726: EMPTY
78727: LIST
78728: LIST
78729: PUSH
78730: LD_INT 3
78732: PUSH
78733: LD_INT 1
78735: NEG
78736: PUSH
78737: EMPTY
78738: LIST
78739: LIST
78740: PUSH
78741: LD_INT 4
78743: PUSH
78744: LD_INT 0
78746: PUSH
78747: EMPTY
78748: LIST
78749: LIST
78750: PUSH
78751: LD_INT 4
78753: PUSH
78754: LD_INT 1
78756: PUSH
78757: EMPTY
78758: LIST
78759: LIST
78760: PUSH
78761: LD_INT 4
78763: PUSH
78764: LD_INT 1
78766: NEG
78767: PUSH
78768: EMPTY
78769: LIST
78770: LIST
78771: PUSH
78772: LD_INT 5
78774: PUSH
78775: LD_INT 0
78777: PUSH
78778: EMPTY
78779: LIST
78780: LIST
78781: PUSH
78782: LD_INT 5
78784: PUSH
78785: LD_INT 1
78787: PUSH
78788: EMPTY
78789: LIST
78790: LIST
78791: PUSH
78792: LD_INT 5
78794: PUSH
78795: LD_INT 1
78797: NEG
78798: PUSH
78799: EMPTY
78800: LIST
78801: LIST
78802: PUSH
78803: LD_INT 6
78805: PUSH
78806: LD_INT 0
78808: PUSH
78809: EMPTY
78810: LIST
78811: LIST
78812: PUSH
78813: LD_INT 6
78815: PUSH
78816: LD_INT 1
78818: PUSH
78819: EMPTY
78820: LIST
78821: LIST
78822: PUSH
78823: EMPTY
78824: LIST
78825: LIST
78826: LIST
78827: LIST
78828: LIST
78829: LIST
78830: LIST
78831: LIST
78832: LIST
78833: LIST
78834: LIST
78835: LIST
78836: ST_TO_ADDR
// fFactory2 = [ [ 3 , 2 ] , [ 3 , 3 ] , [ 2 , 3 ] , [ 4 , 3 ] , [ 4 , 4 ] , [ 3 , 4 ] , [ 5 , 4 ] , [ 5 , 5 ] , [ 4 , 5 ] , [ 6 , 5 ] , [ 6 , 6 ] , [ 5 , 6 ] ] ;
78837: LD_ADDR_VAR 0 31
78841: PUSH
78842: LD_INT 3
78844: PUSH
78845: LD_INT 2
78847: PUSH
78848: EMPTY
78849: LIST
78850: LIST
78851: PUSH
78852: LD_INT 3
78854: PUSH
78855: LD_INT 3
78857: PUSH
78858: EMPTY
78859: LIST
78860: LIST
78861: PUSH
78862: LD_INT 2
78864: PUSH
78865: LD_INT 3
78867: PUSH
78868: EMPTY
78869: LIST
78870: LIST
78871: PUSH
78872: LD_INT 4
78874: PUSH
78875: LD_INT 3
78877: PUSH
78878: EMPTY
78879: LIST
78880: LIST
78881: PUSH
78882: LD_INT 4
78884: PUSH
78885: LD_INT 4
78887: PUSH
78888: EMPTY
78889: LIST
78890: LIST
78891: PUSH
78892: LD_INT 3
78894: PUSH
78895: LD_INT 4
78897: PUSH
78898: EMPTY
78899: LIST
78900: LIST
78901: PUSH
78902: LD_INT 5
78904: PUSH
78905: LD_INT 4
78907: PUSH
78908: EMPTY
78909: LIST
78910: LIST
78911: PUSH
78912: LD_INT 5
78914: PUSH
78915: LD_INT 5
78917: PUSH
78918: EMPTY
78919: LIST
78920: LIST
78921: PUSH
78922: LD_INT 4
78924: PUSH
78925: LD_INT 5
78927: PUSH
78928: EMPTY
78929: LIST
78930: LIST
78931: PUSH
78932: LD_INT 6
78934: PUSH
78935: LD_INT 5
78937: PUSH
78938: EMPTY
78939: LIST
78940: LIST
78941: PUSH
78942: LD_INT 6
78944: PUSH
78945: LD_INT 6
78947: PUSH
78948: EMPTY
78949: LIST
78950: LIST
78951: PUSH
78952: LD_INT 5
78954: PUSH
78955: LD_INT 6
78957: PUSH
78958: EMPTY
78959: LIST
78960: LIST
78961: PUSH
78962: EMPTY
78963: LIST
78964: LIST
78965: LIST
78966: LIST
78967: LIST
78968: LIST
78969: LIST
78970: LIST
78971: LIST
78972: LIST
78973: LIST
78974: LIST
78975: ST_TO_ADDR
// fFactory3 = [ [ 1 , 3 ] , [ 0 , 3 ] , [ - 1 , 2 ] , [ 1 , 4 ] , [ 0 , 4 ] , [ - 1 , 3 ] , [ 1 , 5 ] , [ 0 , 5 ] , [ - 1 , 4 ] , [ 1 , 6 ] , [ 0 , 6 ] , [ - 1 , 5 ] ] ;
78976: LD_ADDR_VAR 0 32
78980: PUSH
78981: LD_INT 1
78983: PUSH
78984: LD_INT 3
78986: PUSH
78987: EMPTY
78988: LIST
78989: LIST
78990: PUSH
78991: LD_INT 0
78993: PUSH
78994: LD_INT 3
78996: PUSH
78997: EMPTY
78998: LIST
78999: LIST
79000: PUSH
79001: LD_INT 1
79003: NEG
79004: PUSH
79005: LD_INT 2
79007: PUSH
79008: EMPTY
79009: LIST
79010: LIST
79011: PUSH
79012: LD_INT 1
79014: PUSH
79015: LD_INT 4
79017: PUSH
79018: EMPTY
79019: LIST
79020: LIST
79021: PUSH
79022: LD_INT 0
79024: PUSH
79025: LD_INT 4
79027: PUSH
79028: EMPTY
79029: LIST
79030: LIST
79031: PUSH
79032: LD_INT 1
79034: NEG
79035: PUSH
79036: LD_INT 3
79038: PUSH
79039: EMPTY
79040: LIST
79041: LIST
79042: PUSH
79043: LD_INT 1
79045: PUSH
79046: LD_INT 5
79048: PUSH
79049: EMPTY
79050: LIST
79051: LIST
79052: PUSH
79053: LD_INT 0
79055: PUSH
79056: LD_INT 5
79058: PUSH
79059: EMPTY
79060: LIST
79061: LIST
79062: PUSH
79063: LD_INT 1
79065: NEG
79066: PUSH
79067: LD_INT 4
79069: PUSH
79070: EMPTY
79071: LIST
79072: LIST
79073: PUSH
79074: LD_INT 1
79076: PUSH
79077: LD_INT 6
79079: PUSH
79080: EMPTY
79081: LIST
79082: LIST
79083: PUSH
79084: LD_INT 0
79086: PUSH
79087: LD_INT 6
79089: PUSH
79090: EMPTY
79091: LIST
79092: LIST
79093: PUSH
79094: LD_INT 1
79096: NEG
79097: PUSH
79098: LD_INT 5
79100: PUSH
79101: EMPTY
79102: LIST
79103: LIST
79104: PUSH
79105: EMPTY
79106: LIST
79107: LIST
79108: LIST
79109: LIST
79110: LIST
79111: LIST
79112: LIST
79113: LIST
79114: LIST
79115: LIST
79116: LIST
79117: LIST
79118: ST_TO_ADDR
// fFactory4 = [ [ - 2 , 1 ] , [ - 3 , 0 ] , [ - 3 , - 1 ] , [ - 3 , 1 ] , [ - 4 , 0 ] , [ - 4 , - 1 ] , [ - 4 , 1 ] , [ - 5 , 0 ] , [ - 5 , - 1 ] , [ - 5 , 1 ] , [ - 6 , 0 ] , [ - 6 , - 1 ] ] ;
79119: LD_ADDR_VAR 0 33
79123: PUSH
79124: LD_INT 2
79126: NEG
79127: PUSH
79128: LD_INT 1
79130: PUSH
79131: EMPTY
79132: LIST
79133: LIST
79134: PUSH
79135: LD_INT 3
79137: NEG
79138: PUSH
79139: LD_INT 0
79141: PUSH
79142: EMPTY
79143: LIST
79144: LIST
79145: PUSH
79146: LD_INT 3
79148: NEG
79149: PUSH
79150: LD_INT 1
79152: NEG
79153: PUSH
79154: EMPTY
79155: LIST
79156: LIST
79157: PUSH
79158: LD_INT 3
79160: NEG
79161: PUSH
79162: LD_INT 1
79164: PUSH
79165: EMPTY
79166: LIST
79167: LIST
79168: PUSH
79169: LD_INT 4
79171: NEG
79172: PUSH
79173: LD_INT 0
79175: PUSH
79176: EMPTY
79177: LIST
79178: LIST
79179: PUSH
79180: LD_INT 4
79182: NEG
79183: PUSH
79184: LD_INT 1
79186: NEG
79187: PUSH
79188: EMPTY
79189: LIST
79190: LIST
79191: PUSH
79192: LD_INT 4
79194: NEG
79195: PUSH
79196: LD_INT 1
79198: PUSH
79199: EMPTY
79200: LIST
79201: LIST
79202: PUSH
79203: LD_INT 5
79205: NEG
79206: PUSH
79207: LD_INT 0
79209: PUSH
79210: EMPTY
79211: LIST
79212: LIST
79213: PUSH
79214: LD_INT 5
79216: NEG
79217: PUSH
79218: LD_INT 1
79220: NEG
79221: PUSH
79222: EMPTY
79223: LIST
79224: LIST
79225: PUSH
79226: LD_INT 5
79228: NEG
79229: PUSH
79230: LD_INT 1
79232: PUSH
79233: EMPTY
79234: LIST
79235: LIST
79236: PUSH
79237: LD_INT 6
79239: NEG
79240: PUSH
79241: LD_INT 0
79243: PUSH
79244: EMPTY
79245: LIST
79246: LIST
79247: PUSH
79248: LD_INT 6
79250: NEG
79251: PUSH
79252: LD_INT 1
79254: NEG
79255: PUSH
79256: EMPTY
79257: LIST
79258: LIST
79259: PUSH
79260: EMPTY
79261: LIST
79262: LIST
79263: LIST
79264: LIST
79265: LIST
79266: LIST
79267: LIST
79268: LIST
79269: LIST
79270: LIST
79271: LIST
79272: LIST
79273: ST_TO_ADDR
// fFactory5 = [ [ - 2 , - 3 ] , [ - 3 , - 2 ] , [ - 3 , - 3 ] , [ - 3 , - 4 ] , [ - 4 , - 3 ] , [ - 4 , - 4 ] , [ - 4 , - 5 ] , [ - 5 , - 4 ] , [ - 5 , - 5 ] , [ - 5 , - 6 ] , [ - 6 , - 5 ] , [ - 6 , - 6 ] ] ;
79274: LD_ADDR_VAR 0 34
79278: PUSH
79279: LD_INT 2
79281: NEG
79282: PUSH
79283: LD_INT 3
79285: NEG
79286: PUSH
79287: EMPTY
79288: LIST
79289: LIST
79290: PUSH
79291: LD_INT 3
79293: NEG
79294: PUSH
79295: LD_INT 2
79297: NEG
79298: PUSH
79299: EMPTY
79300: LIST
79301: LIST
79302: PUSH
79303: LD_INT 3
79305: NEG
79306: PUSH
79307: LD_INT 3
79309: NEG
79310: PUSH
79311: EMPTY
79312: LIST
79313: LIST
79314: PUSH
79315: LD_INT 3
79317: NEG
79318: PUSH
79319: LD_INT 4
79321: NEG
79322: PUSH
79323: EMPTY
79324: LIST
79325: LIST
79326: PUSH
79327: LD_INT 4
79329: NEG
79330: PUSH
79331: LD_INT 3
79333: NEG
79334: PUSH
79335: EMPTY
79336: LIST
79337: LIST
79338: PUSH
79339: LD_INT 4
79341: NEG
79342: PUSH
79343: LD_INT 4
79345: NEG
79346: PUSH
79347: EMPTY
79348: LIST
79349: LIST
79350: PUSH
79351: LD_INT 4
79353: NEG
79354: PUSH
79355: LD_INT 5
79357: NEG
79358: PUSH
79359: EMPTY
79360: LIST
79361: LIST
79362: PUSH
79363: LD_INT 5
79365: NEG
79366: PUSH
79367: LD_INT 4
79369: NEG
79370: PUSH
79371: EMPTY
79372: LIST
79373: LIST
79374: PUSH
79375: LD_INT 5
79377: NEG
79378: PUSH
79379: LD_INT 5
79381: NEG
79382: PUSH
79383: EMPTY
79384: LIST
79385: LIST
79386: PUSH
79387: LD_INT 5
79389: NEG
79390: PUSH
79391: LD_INT 6
79393: NEG
79394: PUSH
79395: EMPTY
79396: LIST
79397: LIST
79398: PUSH
79399: LD_INT 6
79401: NEG
79402: PUSH
79403: LD_INT 5
79405: NEG
79406: PUSH
79407: EMPTY
79408: LIST
79409: LIST
79410: PUSH
79411: LD_INT 6
79413: NEG
79414: PUSH
79415: LD_INT 6
79417: NEG
79418: PUSH
79419: EMPTY
79420: LIST
79421: LIST
79422: PUSH
79423: EMPTY
79424: LIST
79425: LIST
79426: LIST
79427: LIST
79428: LIST
79429: LIST
79430: LIST
79431: LIST
79432: LIST
79433: LIST
79434: LIST
79435: LIST
79436: ST_TO_ADDR
// fLab0 = [ [ 0 , - 2 ] , [ - 1 , - 3 ] , [ 1 , - 2 ] ] ;
79437: LD_ADDR_VAR 0 41
79441: PUSH
79442: LD_INT 0
79444: PUSH
79445: LD_INT 2
79447: NEG
79448: PUSH
79449: EMPTY
79450: LIST
79451: LIST
79452: PUSH
79453: LD_INT 1
79455: NEG
79456: PUSH
79457: LD_INT 3
79459: NEG
79460: PUSH
79461: EMPTY
79462: LIST
79463: LIST
79464: PUSH
79465: LD_INT 1
79467: PUSH
79468: LD_INT 2
79470: NEG
79471: PUSH
79472: EMPTY
79473: LIST
79474: LIST
79475: PUSH
79476: EMPTY
79477: LIST
79478: LIST
79479: LIST
79480: ST_TO_ADDR
// fLab1 = [ [ 2 , 0 ] , [ 2 , - 1 ] , [ 3 , 1 ] ] ;
79481: LD_ADDR_VAR 0 42
79485: PUSH
79486: LD_INT 2
79488: PUSH
79489: LD_INT 0
79491: PUSH
79492: EMPTY
79493: LIST
79494: LIST
79495: PUSH
79496: LD_INT 2
79498: PUSH
79499: LD_INT 1
79501: NEG
79502: PUSH
79503: EMPTY
79504: LIST
79505: LIST
79506: PUSH
79507: LD_INT 3
79509: PUSH
79510: LD_INT 1
79512: PUSH
79513: EMPTY
79514: LIST
79515: LIST
79516: PUSH
79517: EMPTY
79518: LIST
79519: LIST
79520: LIST
79521: ST_TO_ADDR
// fLab2 = [ [ 2 , 2 ] , [ 3 , 2 ] , [ 2 , 3 ] ] ;
79522: LD_ADDR_VAR 0 43
79526: PUSH
79527: LD_INT 2
79529: PUSH
79530: LD_INT 2
79532: PUSH
79533: EMPTY
79534: LIST
79535: LIST
79536: PUSH
79537: LD_INT 3
79539: PUSH
79540: LD_INT 2
79542: PUSH
79543: EMPTY
79544: LIST
79545: LIST
79546: PUSH
79547: LD_INT 2
79549: PUSH
79550: LD_INT 3
79552: PUSH
79553: EMPTY
79554: LIST
79555: LIST
79556: PUSH
79557: EMPTY
79558: LIST
79559: LIST
79560: LIST
79561: ST_TO_ADDR
// fLab3 = [ [ 0 , 2 ] , [ 1 , 3 ] , [ - 1 , 2 ] ] ;
79562: LD_ADDR_VAR 0 44
79566: PUSH
79567: LD_INT 0
79569: PUSH
79570: LD_INT 2
79572: PUSH
79573: EMPTY
79574: LIST
79575: LIST
79576: PUSH
79577: LD_INT 1
79579: PUSH
79580: LD_INT 3
79582: PUSH
79583: EMPTY
79584: LIST
79585: LIST
79586: PUSH
79587: LD_INT 1
79589: NEG
79590: PUSH
79591: LD_INT 2
79593: PUSH
79594: EMPTY
79595: LIST
79596: LIST
79597: PUSH
79598: EMPTY
79599: LIST
79600: LIST
79601: LIST
79602: ST_TO_ADDR
// fLab4 = [ [ - 2 , 0 ] , [ - 2 , 1 ] , [ - 3 , - 1 ] ] ;
79603: LD_ADDR_VAR 0 45
79607: PUSH
79608: LD_INT 2
79610: NEG
79611: PUSH
79612: LD_INT 0
79614: PUSH
79615: EMPTY
79616: LIST
79617: LIST
79618: PUSH
79619: LD_INT 2
79621: NEG
79622: PUSH
79623: LD_INT 1
79625: PUSH
79626: EMPTY
79627: LIST
79628: LIST
79629: PUSH
79630: LD_INT 3
79632: NEG
79633: PUSH
79634: LD_INT 1
79636: NEG
79637: PUSH
79638: EMPTY
79639: LIST
79640: LIST
79641: PUSH
79642: EMPTY
79643: LIST
79644: LIST
79645: LIST
79646: ST_TO_ADDR
// fLab5 = [ [ - 2 , - 2 ] , [ - 2 , - 3 ] , [ - 3 , - 2 ] ] ;
79647: LD_ADDR_VAR 0 46
79651: PUSH
79652: LD_INT 2
79654: NEG
79655: PUSH
79656: LD_INT 2
79658: NEG
79659: PUSH
79660: EMPTY
79661: LIST
79662: LIST
79663: PUSH
79664: LD_INT 2
79666: NEG
79667: PUSH
79668: LD_INT 3
79670: NEG
79671: PUSH
79672: EMPTY
79673: LIST
79674: LIST
79675: PUSH
79676: LD_INT 3
79678: NEG
79679: PUSH
79680: LD_INT 2
79682: NEG
79683: PUSH
79684: EMPTY
79685: LIST
79686: LIST
79687: PUSH
79688: EMPTY
79689: LIST
79690: LIST
79691: LIST
79692: ST_TO_ADDR
// fControlTower0 = [ [ - 2 , - 3 ] , [ - 1 , - 3 ] ] ;
79693: LD_ADDR_VAR 0 47
79697: PUSH
79698: LD_INT 2
79700: NEG
79701: PUSH
79702: LD_INT 3
79704: NEG
79705: PUSH
79706: EMPTY
79707: LIST
79708: LIST
79709: PUSH
79710: LD_INT 1
79712: NEG
79713: PUSH
79714: LD_INT 3
79716: NEG
79717: PUSH
79718: EMPTY
79719: LIST
79720: LIST
79721: PUSH
79722: EMPTY
79723: LIST
79724: LIST
79725: ST_TO_ADDR
// fControlTower1 = [ [ 1 , - 2 ] , [ 2 , - 1 ] ] ;
79726: LD_ADDR_VAR 0 48
79730: PUSH
79731: LD_INT 1
79733: PUSH
79734: LD_INT 2
79736: NEG
79737: PUSH
79738: EMPTY
79739: LIST
79740: LIST
79741: PUSH
79742: LD_INT 2
79744: PUSH
79745: LD_INT 1
79747: NEG
79748: PUSH
79749: EMPTY
79750: LIST
79751: LIST
79752: PUSH
79753: EMPTY
79754: LIST
79755: LIST
79756: ST_TO_ADDR
// fControlTower2 = [ [ 3 , 1 ] , [ 3 , 2 ] ] ;
79757: LD_ADDR_VAR 0 49
79761: PUSH
79762: LD_INT 3
79764: PUSH
79765: LD_INT 1
79767: PUSH
79768: EMPTY
79769: LIST
79770: LIST
79771: PUSH
79772: LD_INT 3
79774: PUSH
79775: LD_INT 2
79777: PUSH
79778: EMPTY
79779: LIST
79780: LIST
79781: PUSH
79782: EMPTY
79783: LIST
79784: LIST
79785: ST_TO_ADDR
// fControlTower3 = [ [ 2 , 3 ] , [ 1 , 3 ] ] ;
79786: LD_ADDR_VAR 0 50
79790: PUSH
79791: LD_INT 2
79793: PUSH
79794: LD_INT 3
79796: PUSH
79797: EMPTY
79798: LIST
79799: LIST
79800: PUSH
79801: LD_INT 1
79803: PUSH
79804: LD_INT 3
79806: PUSH
79807: EMPTY
79808: LIST
79809: LIST
79810: PUSH
79811: EMPTY
79812: LIST
79813: LIST
79814: ST_TO_ADDR
// fControlTower4 = [ [ - 1 , 2 ] , [ - 2 , 1 ] ] ;
79815: LD_ADDR_VAR 0 51
79819: PUSH
79820: LD_INT 1
79822: NEG
79823: PUSH
79824: LD_INT 2
79826: PUSH
79827: EMPTY
79828: LIST
79829: LIST
79830: PUSH
79831: LD_INT 2
79833: NEG
79834: PUSH
79835: LD_INT 1
79837: PUSH
79838: EMPTY
79839: LIST
79840: LIST
79841: PUSH
79842: EMPTY
79843: LIST
79844: LIST
79845: ST_TO_ADDR
// fControlTower5 = [ [ - 3 , - 1 ] , [ - 3 , - 2 ] ] ;
79846: LD_ADDR_VAR 0 52
79850: PUSH
79851: LD_INT 3
79853: NEG
79854: PUSH
79855: LD_INT 1
79857: NEG
79858: PUSH
79859: EMPTY
79860: LIST
79861: LIST
79862: PUSH
79863: LD_INT 3
79865: NEG
79866: PUSH
79867: LD_INT 2
79869: NEG
79870: PUSH
79871: EMPTY
79872: LIST
79873: LIST
79874: PUSH
79875: EMPTY
79876: LIST
79877: LIST
79878: ST_TO_ADDR
// fBarracks0 = [ [ - 1 , - 3 ] , [ 0 , - 3 ] , [ 1 , - 2 ] ] ;
79879: LD_ADDR_VAR 0 53
79883: PUSH
79884: LD_INT 1
79886: NEG
79887: PUSH
79888: LD_INT 3
79890: NEG
79891: PUSH
79892: EMPTY
79893: LIST
79894: LIST
79895: PUSH
79896: LD_INT 0
79898: PUSH
79899: LD_INT 3
79901: NEG
79902: PUSH
79903: EMPTY
79904: LIST
79905: LIST
79906: PUSH
79907: LD_INT 1
79909: PUSH
79910: LD_INT 2
79912: NEG
79913: PUSH
79914: EMPTY
79915: LIST
79916: LIST
79917: PUSH
79918: EMPTY
79919: LIST
79920: LIST
79921: LIST
79922: ST_TO_ADDR
// fBarracks1 = [ [ 2 , - 1 ] , [ 3 , 0 ] , [ 3 , 1 ] ] ;
79923: LD_ADDR_VAR 0 54
79927: PUSH
79928: LD_INT 2
79930: PUSH
79931: LD_INT 1
79933: NEG
79934: PUSH
79935: EMPTY
79936: LIST
79937: LIST
79938: PUSH
79939: LD_INT 3
79941: PUSH
79942: LD_INT 0
79944: PUSH
79945: EMPTY
79946: LIST
79947: LIST
79948: PUSH
79949: LD_INT 3
79951: PUSH
79952: LD_INT 1
79954: PUSH
79955: EMPTY
79956: LIST
79957: LIST
79958: PUSH
79959: EMPTY
79960: LIST
79961: LIST
79962: LIST
79963: ST_TO_ADDR
// fBarracks2 = [ [ 3 , 2 ] , [ 3 , 3 ] , [ 2 , 3 ] ] ;
79964: LD_ADDR_VAR 0 55
79968: PUSH
79969: LD_INT 3
79971: PUSH
79972: LD_INT 2
79974: PUSH
79975: EMPTY
79976: LIST
79977: LIST
79978: PUSH
79979: LD_INT 3
79981: PUSH
79982: LD_INT 3
79984: PUSH
79985: EMPTY
79986: LIST
79987: LIST
79988: PUSH
79989: LD_INT 2
79991: PUSH
79992: LD_INT 3
79994: PUSH
79995: EMPTY
79996: LIST
79997: LIST
79998: PUSH
79999: EMPTY
80000: LIST
80001: LIST
80002: LIST
80003: ST_TO_ADDR
// fBarracks3 = [ [ 1 , 3 ] , [ 0 , 3 ] , [ - 1 , 2 ] ] ;
80004: LD_ADDR_VAR 0 56
80008: PUSH
80009: LD_INT 1
80011: PUSH
80012: LD_INT 3
80014: PUSH
80015: EMPTY
80016: LIST
80017: LIST
80018: PUSH
80019: LD_INT 0
80021: PUSH
80022: LD_INT 3
80024: PUSH
80025: EMPTY
80026: LIST
80027: LIST
80028: PUSH
80029: LD_INT 1
80031: NEG
80032: PUSH
80033: LD_INT 2
80035: PUSH
80036: EMPTY
80037: LIST
80038: LIST
80039: PUSH
80040: EMPTY
80041: LIST
80042: LIST
80043: LIST
80044: ST_TO_ADDR
// fBarracks4 = [ [ - 2 , 1 ] , [ - 3 , 0 ] , [ - 3 , - 1 ] ] ;
80045: LD_ADDR_VAR 0 57
80049: PUSH
80050: LD_INT 2
80052: NEG
80053: PUSH
80054: LD_INT 1
80056: PUSH
80057: EMPTY
80058: LIST
80059: LIST
80060: PUSH
80061: LD_INT 3
80063: NEG
80064: PUSH
80065: LD_INT 0
80067: PUSH
80068: EMPTY
80069: LIST
80070: LIST
80071: PUSH
80072: LD_INT 3
80074: NEG
80075: PUSH
80076: LD_INT 1
80078: NEG
80079: PUSH
80080: EMPTY
80081: LIST
80082: LIST
80083: PUSH
80084: EMPTY
80085: LIST
80086: LIST
80087: LIST
80088: ST_TO_ADDR
// fBarracks5 = [ [ - 2 , - 3 ] , [ - 3 , - 2 ] , [ - 3 , - 3 ] ] ;
80089: LD_ADDR_VAR 0 58
80093: PUSH
80094: LD_INT 2
80096: NEG
80097: PUSH
80098: LD_INT 3
80100: NEG
80101: PUSH
80102: EMPTY
80103: LIST
80104: LIST
80105: PUSH
80106: LD_INT 3
80108: NEG
80109: PUSH
80110: LD_INT 2
80112: NEG
80113: PUSH
80114: EMPTY
80115: LIST
80116: LIST
80117: PUSH
80118: LD_INT 3
80120: NEG
80121: PUSH
80122: LD_INT 3
80124: NEG
80125: PUSH
80126: EMPTY
80127: LIST
80128: LIST
80129: PUSH
80130: EMPTY
80131: LIST
80132: LIST
80133: LIST
80134: ST_TO_ADDR
// fBunker0 = [ [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] ] ;
80135: LD_ADDR_VAR 0 59
80139: PUSH
80140: LD_INT 1
80142: NEG
80143: PUSH
80144: LD_INT 2
80146: NEG
80147: PUSH
80148: EMPTY
80149: LIST
80150: LIST
80151: PUSH
80152: LD_INT 0
80154: PUSH
80155: LD_INT 2
80157: NEG
80158: PUSH
80159: EMPTY
80160: LIST
80161: LIST
80162: PUSH
80163: LD_INT 1
80165: PUSH
80166: LD_INT 1
80168: NEG
80169: PUSH
80170: EMPTY
80171: LIST
80172: LIST
80173: PUSH
80174: EMPTY
80175: LIST
80176: LIST
80177: LIST
80178: ST_TO_ADDR
// fBunker1 = [ [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] ] ;
80179: LD_ADDR_VAR 0 60
80183: PUSH
80184: LD_INT 1
80186: PUSH
80187: LD_INT 1
80189: NEG
80190: PUSH
80191: EMPTY
80192: LIST
80193: LIST
80194: PUSH
80195: LD_INT 2
80197: PUSH
80198: LD_INT 0
80200: PUSH
80201: EMPTY
80202: LIST
80203: LIST
80204: PUSH
80205: LD_INT 2
80207: PUSH
80208: LD_INT 1
80210: PUSH
80211: EMPTY
80212: LIST
80213: LIST
80214: PUSH
80215: EMPTY
80216: LIST
80217: LIST
80218: LIST
80219: ST_TO_ADDR
// fBunker2 = [ [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] ] ;
80220: LD_ADDR_VAR 0 61
80224: PUSH
80225: LD_INT 2
80227: PUSH
80228: LD_INT 1
80230: PUSH
80231: EMPTY
80232: LIST
80233: LIST
80234: PUSH
80235: LD_INT 2
80237: PUSH
80238: LD_INT 2
80240: PUSH
80241: EMPTY
80242: LIST
80243: LIST
80244: PUSH
80245: LD_INT 1
80247: PUSH
80248: LD_INT 2
80250: PUSH
80251: EMPTY
80252: LIST
80253: LIST
80254: PUSH
80255: EMPTY
80256: LIST
80257: LIST
80258: LIST
80259: ST_TO_ADDR
// fBunker3 = [ [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] ] ;
80260: LD_ADDR_VAR 0 62
80264: PUSH
80265: LD_INT 1
80267: PUSH
80268: LD_INT 2
80270: PUSH
80271: EMPTY
80272: LIST
80273: LIST
80274: PUSH
80275: LD_INT 0
80277: PUSH
80278: LD_INT 2
80280: PUSH
80281: EMPTY
80282: LIST
80283: LIST
80284: PUSH
80285: LD_INT 1
80287: NEG
80288: PUSH
80289: LD_INT 1
80291: PUSH
80292: EMPTY
80293: LIST
80294: LIST
80295: PUSH
80296: EMPTY
80297: LIST
80298: LIST
80299: LIST
80300: ST_TO_ADDR
// fBunker4 = [ [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] ] ;
80301: LD_ADDR_VAR 0 63
80305: PUSH
80306: LD_INT 1
80308: NEG
80309: PUSH
80310: LD_INT 1
80312: PUSH
80313: EMPTY
80314: LIST
80315: LIST
80316: PUSH
80317: LD_INT 2
80319: NEG
80320: PUSH
80321: LD_INT 0
80323: PUSH
80324: EMPTY
80325: LIST
80326: LIST
80327: PUSH
80328: LD_INT 2
80330: NEG
80331: PUSH
80332: LD_INT 1
80334: NEG
80335: PUSH
80336: EMPTY
80337: LIST
80338: LIST
80339: PUSH
80340: EMPTY
80341: LIST
80342: LIST
80343: LIST
80344: ST_TO_ADDR
// fBunker5 = [ [ - 1 , - 2 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
80345: LD_ADDR_VAR 0 64
80349: PUSH
80350: LD_INT 1
80352: NEG
80353: PUSH
80354: LD_INT 2
80356: NEG
80357: PUSH
80358: EMPTY
80359: LIST
80360: LIST
80361: PUSH
80362: LD_INT 2
80364: NEG
80365: PUSH
80366: LD_INT 1
80368: NEG
80369: PUSH
80370: EMPTY
80371: LIST
80372: LIST
80373: PUSH
80374: LD_INT 2
80376: NEG
80377: PUSH
80378: LD_INT 2
80380: NEG
80381: PUSH
80382: EMPTY
80383: LIST
80384: LIST
80385: PUSH
80386: EMPTY
80387: LIST
80388: LIST
80389: LIST
80390: ST_TO_ADDR
// end ; 2 :
80391: GO 83657
80393: LD_INT 2
80395: DOUBLE
80396: EQUAL
80397: IFTRUE 80401
80399: GO 83656
80401: POP
// begin fFactory0 = [ [ 4 , 0 ] , [ 4 , - 1 ] , [ 5 , 0 ] , [ 5 , 1 ] , [ 4 , 1 ] , [ 3 , 0 ] , [ 3 , - 1 ] , [ 3 , - 2 ] , [ 5 , 2 ] , [ 3 , 3 ] , [ 3 , 2 ] , [ 4 , 3 ] , [ 4 , 4 ] , [ 3 , 4 ] , [ 2 , 3 ] , [ 2 , 2 ] , [ 4 , 2 ] , [ 2 , 4 ] , [ 0 , 4 ] , [ 0 , 3 ] , [ 1 , 4 ] , [ 1 , 5 ] , [ 0 , 5 ] , [ - 1 , 4 ] , [ - 1 , 3 ] , [ 2 , 5 ] , [ - 2 , 3 ] , [ - 3 , 0 ] , [ - 3 , - 1 ] , [ - 2 , 0 ] , [ - 2 , 1 ] , [ - 3 , 1 ] , [ - 4 , 0 ] , [ - 4 , - 1 ] , [ - 4 , - 2 ] , [ - 2 , 2 ] , [ - 4 , - 4 ] , [ - 4 , - 5 ] , [ - 3 , - 4 ] , [ - 3 , - 3 ] , [ - 4 , - 3 ] , [ - 5 , - 4 ] , [ - 5 , - 5 ] , [ - 3 , - 5 ] , [ - 5 , - 3 ] ] ;
80402: LD_ADDR_VAR 0 29
80406: PUSH
80407: LD_INT 4
80409: PUSH
80410: LD_INT 0
80412: PUSH
80413: EMPTY
80414: LIST
80415: LIST
80416: PUSH
80417: LD_INT 4
80419: PUSH
80420: LD_INT 1
80422: NEG
80423: PUSH
80424: EMPTY
80425: LIST
80426: LIST
80427: PUSH
80428: LD_INT 5
80430: PUSH
80431: LD_INT 0
80433: PUSH
80434: EMPTY
80435: LIST
80436: LIST
80437: PUSH
80438: LD_INT 5
80440: PUSH
80441: LD_INT 1
80443: PUSH
80444: EMPTY
80445: LIST
80446: LIST
80447: PUSH
80448: LD_INT 4
80450: PUSH
80451: LD_INT 1
80453: PUSH
80454: EMPTY
80455: LIST
80456: LIST
80457: PUSH
80458: LD_INT 3
80460: PUSH
80461: LD_INT 0
80463: PUSH
80464: EMPTY
80465: LIST
80466: LIST
80467: PUSH
80468: LD_INT 3
80470: PUSH
80471: LD_INT 1
80473: NEG
80474: PUSH
80475: EMPTY
80476: LIST
80477: LIST
80478: PUSH
80479: LD_INT 3
80481: PUSH
80482: LD_INT 2
80484: NEG
80485: PUSH
80486: EMPTY
80487: LIST
80488: LIST
80489: PUSH
80490: LD_INT 5
80492: PUSH
80493: LD_INT 2
80495: PUSH
80496: EMPTY
80497: LIST
80498: LIST
80499: PUSH
80500: LD_INT 3
80502: PUSH
80503: LD_INT 3
80505: PUSH
80506: EMPTY
80507: LIST
80508: LIST
80509: PUSH
80510: LD_INT 3
80512: PUSH
80513: LD_INT 2
80515: PUSH
80516: EMPTY
80517: LIST
80518: LIST
80519: PUSH
80520: LD_INT 4
80522: PUSH
80523: LD_INT 3
80525: PUSH
80526: EMPTY
80527: LIST
80528: LIST
80529: PUSH
80530: LD_INT 4
80532: PUSH
80533: LD_INT 4
80535: PUSH
80536: EMPTY
80537: LIST
80538: LIST
80539: PUSH
80540: LD_INT 3
80542: PUSH
80543: LD_INT 4
80545: PUSH
80546: EMPTY
80547: LIST
80548: LIST
80549: PUSH
80550: LD_INT 2
80552: PUSH
80553: LD_INT 3
80555: PUSH
80556: EMPTY
80557: LIST
80558: LIST
80559: PUSH
80560: LD_INT 2
80562: PUSH
80563: LD_INT 2
80565: PUSH
80566: EMPTY
80567: LIST
80568: LIST
80569: PUSH
80570: LD_INT 4
80572: PUSH
80573: LD_INT 2
80575: PUSH
80576: EMPTY
80577: LIST
80578: LIST
80579: PUSH
80580: LD_INT 2
80582: PUSH
80583: LD_INT 4
80585: PUSH
80586: EMPTY
80587: LIST
80588: LIST
80589: PUSH
80590: LD_INT 0
80592: PUSH
80593: LD_INT 4
80595: PUSH
80596: EMPTY
80597: LIST
80598: LIST
80599: PUSH
80600: LD_INT 0
80602: PUSH
80603: LD_INT 3
80605: PUSH
80606: EMPTY
80607: LIST
80608: LIST
80609: PUSH
80610: LD_INT 1
80612: PUSH
80613: LD_INT 4
80615: PUSH
80616: EMPTY
80617: LIST
80618: LIST
80619: PUSH
80620: LD_INT 1
80622: PUSH
80623: LD_INT 5
80625: PUSH
80626: EMPTY
80627: LIST
80628: LIST
80629: PUSH
80630: LD_INT 0
80632: PUSH
80633: LD_INT 5
80635: PUSH
80636: EMPTY
80637: LIST
80638: LIST
80639: PUSH
80640: LD_INT 1
80642: NEG
80643: PUSH
80644: LD_INT 4
80646: PUSH
80647: EMPTY
80648: LIST
80649: LIST
80650: PUSH
80651: LD_INT 1
80653: NEG
80654: PUSH
80655: LD_INT 3
80657: PUSH
80658: EMPTY
80659: LIST
80660: LIST
80661: PUSH
80662: LD_INT 2
80664: PUSH
80665: LD_INT 5
80667: PUSH
80668: EMPTY
80669: LIST
80670: LIST
80671: PUSH
80672: LD_INT 2
80674: NEG
80675: PUSH
80676: LD_INT 3
80678: PUSH
80679: EMPTY
80680: LIST
80681: LIST
80682: PUSH
80683: LD_INT 3
80685: NEG
80686: PUSH
80687: LD_INT 0
80689: PUSH
80690: EMPTY
80691: LIST
80692: LIST
80693: PUSH
80694: LD_INT 3
80696: NEG
80697: PUSH
80698: LD_INT 1
80700: NEG
80701: PUSH
80702: EMPTY
80703: LIST
80704: LIST
80705: PUSH
80706: LD_INT 2
80708: NEG
80709: PUSH
80710: LD_INT 0
80712: PUSH
80713: EMPTY
80714: LIST
80715: LIST
80716: PUSH
80717: LD_INT 2
80719: NEG
80720: PUSH
80721: LD_INT 1
80723: PUSH
80724: EMPTY
80725: LIST
80726: LIST
80727: PUSH
80728: LD_INT 3
80730: NEG
80731: PUSH
80732: LD_INT 1
80734: PUSH
80735: EMPTY
80736: LIST
80737: LIST
80738: PUSH
80739: LD_INT 4
80741: NEG
80742: PUSH
80743: LD_INT 0
80745: PUSH
80746: EMPTY
80747: LIST
80748: LIST
80749: PUSH
80750: LD_INT 4
80752: NEG
80753: PUSH
80754: LD_INT 1
80756: NEG
80757: PUSH
80758: EMPTY
80759: LIST
80760: LIST
80761: PUSH
80762: LD_INT 4
80764: NEG
80765: PUSH
80766: LD_INT 2
80768: NEG
80769: PUSH
80770: EMPTY
80771: LIST
80772: LIST
80773: PUSH
80774: LD_INT 2
80776: NEG
80777: PUSH
80778: LD_INT 2
80780: PUSH
80781: EMPTY
80782: LIST
80783: LIST
80784: PUSH
80785: LD_INT 4
80787: NEG
80788: PUSH
80789: LD_INT 4
80791: NEG
80792: PUSH
80793: EMPTY
80794: LIST
80795: LIST
80796: PUSH
80797: LD_INT 4
80799: NEG
80800: PUSH
80801: LD_INT 5
80803: NEG
80804: PUSH
80805: EMPTY
80806: LIST
80807: LIST
80808: PUSH
80809: LD_INT 3
80811: NEG
80812: PUSH
80813: LD_INT 4
80815: NEG
80816: PUSH
80817: EMPTY
80818: LIST
80819: LIST
80820: PUSH
80821: LD_INT 3
80823: NEG
80824: PUSH
80825: LD_INT 3
80827: NEG
80828: PUSH
80829: EMPTY
80830: LIST
80831: LIST
80832: PUSH
80833: LD_INT 4
80835: NEG
80836: PUSH
80837: LD_INT 3
80839: NEG
80840: PUSH
80841: EMPTY
80842: LIST
80843: LIST
80844: PUSH
80845: LD_INT 5
80847: NEG
80848: PUSH
80849: LD_INT 4
80851: NEG
80852: PUSH
80853: EMPTY
80854: LIST
80855: LIST
80856: PUSH
80857: LD_INT 5
80859: NEG
80860: PUSH
80861: LD_INT 5
80863: NEG
80864: PUSH
80865: EMPTY
80866: LIST
80867: LIST
80868: PUSH
80869: LD_INT 3
80871: NEG
80872: PUSH
80873: LD_INT 5
80875: NEG
80876: PUSH
80877: EMPTY
80878: LIST
80879: LIST
80880: PUSH
80881: LD_INT 5
80883: NEG
80884: PUSH
80885: LD_INT 3
80887: NEG
80888: PUSH
80889: EMPTY
80890: LIST
80891: LIST
80892: PUSH
80893: EMPTY
80894: LIST
80895: LIST
80896: LIST
80897: LIST
80898: LIST
80899: LIST
80900: LIST
80901: LIST
80902: LIST
80903: LIST
80904: LIST
80905: LIST
80906: LIST
80907: LIST
80908: LIST
80909: LIST
80910: LIST
80911: LIST
80912: LIST
80913: LIST
80914: LIST
80915: LIST
80916: LIST
80917: LIST
80918: LIST
80919: LIST
80920: LIST
80921: LIST
80922: LIST
80923: LIST
80924: LIST
80925: LIST
80926: LIST
80927: LIST
80928: LIST
80929: LIST
80930: LIST
80931: LIST
80932: LIST
80933: LIST
80934: LIST
80935: LIST
80936: LIST
80937: LIST
80938: LIST
80939: ST_TO_ADDR
// fFactory1 = [ [ 4 , 4 ] , [ 4 , 3 ] , [ 5 , 4 ] , [ 5 , 5 ] , [ 4 , 5 ] , [ 3 , 4 ] , [ 3 , 3 ] , [ 5 , 3 ] , [ 3 , 5 ] , [ 0 , 3 ] , [ 0 , 2 ] , [ 1 , 3 ] , [ 1 , 4 ] , [ 0 , 4 ] , [ - 1 , 3 ] , [ - 1 , 2 ] , [ 2 , 4 ] , [ - 2 , 2 ] , [ - 4 , 0 ] , [ - 4 , - 1 ] , [ - 3 , 0 ] , [ - 3 , 1 ] , [ - 4 , 1 ] , [ - 5 , 0 ] , [ - 5 , - 1 ] , [ - 5 , - 2 ] , [ - 3 , 2 ] , [ - 3 , - 3 ] , [ - 3 , - 4 ] , [ - 2 , - 3 ] , [ - 2 , - 2 ] , [ - 3 , - 2 ] , [ - 4 , - 3 ] , [ - 4 , - 4 ] , [ - 2 , - 4 ] , [ - 4 , - 2 ] , [ 0 , - 4 ] , [ 0 , - 5 ] , [ 1 , - 4 ] , [ 1 , - 3 ] , [ 0 , - 3 ] , [ - 1 , - 4 ] , [ - 1 , - 5 ] , [ 2 , - 3 ] , [ - 2 , - 5 ] ] ;
80940: LD_ADDR_VAR 0 30
80944: PUSH
80945: LD_INT 4
80947: PUSH
80948: LD_INT 4
80950: PUSH
80951: EMPTY
80952: LIST
80953: LIST
80954: PUSH
80955: LD_INT 4
80957: PUSH
80958: LD_INT 3
80960: PUSH
80961: EMPTY
80962: LIST
80963: LIST
80964: PUSH
80965: LD_INT 5
80967: PUSH
80968: LD_INT 4
80970: PUSH
80971: EMPTY
80972: LIST
80973: LIST
80974: PUSH
80975: LD_INT 5
80977: PUSH
80978: LD_INT 5
80980: PUSH
80981: EMPTY
80982: LIST
80983: LIST
80984: PUSH
80985: LD_INT 4
80987: PUSH
80988: LD_INT 5
80990: PUSH
80991: EMPTY
80992: LIST
80993: LIST
80994: PUSH
80995: LD_INT 3
80997: PUSH
80998: LD_INT 4
81000: PUSH
81001: EMPTY
81002: LIST
81003: LIST
81004: PUSH
81005: LD_INT 3
81007: PUSH
81008: LD_INT 3
81010: PUSH
81011: EMPTY
81012: LIST
81013: LIST
81014: PUSH
81015: LD_INT 5
81017: PUSH
81018: LD_INT 3
81020: PUSH
81021: EMPTY
81022: LIST
81023: LIST
81024: PUSH
81025: LD_INT 3
81027: PUSH
81028: LD_INT 5
81030: PUSH
81031: EMPTY
81032: LIST
81033: LIST
81034: PUSH
81035: LD_INT 0
81037: PUSH
81038: LD_INT 3
81040: PUSH
81041: EMPTY
81042: LIST
81043: LIST
81044: PUSH
81045: LD_INT 0
81047: PUSH
81048: LD_INT 2
81050: PUSH
81051: EMPTY
81052: LIST
81053: LIST
81054: PUSH
81055: LD_INT 1
81057: PUSH
81058: LD_INT 3
81060: PUSH
81061: EMPTY
81062: LIST
81063: LIST
81064: PUSH
81065: LD_INT 1
81067: PUSH
81068: LD_INT 4
81070: PUSH
81071: EMPTY
81072: LIST
81073: LIST
81074: PUSH
81075: LD_INT 0
81077: PUSH
81078: LD_INT 4
81080: PUSH
81081: EMPTY
81082: LIST
81083: LIST
81084: PUSH
81085: LD_INT 1
81087: NEG
81088: PUSH
81089: LD_INT 3
81091: PUSH
81092: EMPTY
81093: LIST
81094: LIST
81095: PUSH
81096: LD_INT 1
81098: NEG
81099: PUSH
81100: LD_INT 2
81102: PUSH
81103: EMPTY
81104: LIST
81105: LIST
81106: PUSH
81107: LD_INT 2
81109: PUSH
81110: LD_INT 4
81112: PUSH
81113: EMPTY
81114: LIST
81115: LIST
81116: PUSH
81117: LD_INT 2
81119: NEG
81120: PUSH
81121: LD_INT 2
81123: PUSH
81124: EMPTY
81125: LIST
81126: LIST
81127: PUSH
81128: LD_INT 4
81130: NEG
81131: PUSH
81132: LD_INT 0
81134: PUSH
81135: EMPTY
81136: LIST
81137: LIST
81138: PUSH
81139: LD_INT 4
81141: NEG
81142: PUSH
81143: LD_INT 1
81145: NEG
81146: PUSH
81147: EMPTY
81148: LIST
81149: LIST
81150: PUSH
81151: LD_INT 3
81153: NEG
81154: PUSH
81155: LD_INT 0
81157: PUSH
81158: EMPTY
81159: LIST
81160: LIST
81161: PUSH
81162: LD_INT 3
81164: NEG
81165: PUSH
81166: LD_INT 1
81168: PUSH
81169: EMPTY
81170: LIST
81171: LIST
81172: PUSH
81173: LD_INT 4
81175: NEG
81176: PUSH
81177: LD_INT 1
81179: PUSH
81180: EMPTY
81181: LIST
81182: LIST
81183: PUSH
81184: LD_INT 5
81186: NEG
81187: PUSH
81188: LD_INT 0
81190: PUSH
81191: EMPTY
81192: LIST
81193: LIST
81194: PUSH
81195: LD_INT 5
81197: NEG
81198: PUSH
81199: LD_INT 1
81201: NEG
81202: PUSH
81203: EMPTY
81204: LIST
81205: LIST
81206: PUSH
81207: LD_INT 5
81209: NEG
81210: PUSH
81211: LD_INT 2
81213: NEG
81214: PUSH
81215: EMPTY
81216: LIST
81217: LIST
81218: PUSH
81219: LD_INT 3
81221: NEG
81222: PUSH
81223: LD_INT 2
81225: PUSH
81226: EMPTY
81227: LIST
81228: LIST
81229: PUSH
81230: LD_INT 3
81232: NEG
81233: PUSH
81234: LD_INT 3
81236: NEG
81237: PUSH
81238: EMPTY
81239: LIST
81240: LIST
81241: PUSH
81242: LD_INT 3
81244: NEG
81245: PUSH
81246: LD_INT 4
81248: NEG
81249: PUSH
81250: EMPTY
81251: LIST
81252: LIST
81253: PUSH
81254: LD_INT 2
81256: NEG
81257: PUSH
81258: LD_INT 3
81260: NEG
81261: PUSH
81262: EMPTY
81263: LIST
81264: LIST
81265: PUSH
81266: LD_INT 2
81268: NEG
81269: PUSH
81270: LD_INT 2
81272: NEG
81273: PUSH
81274: EMPTY
81275: LIST
81276: LIST
81277: PUSH
81278: LD_INT 3
81280: NEG
81281: PUSH
81282: LD_INT 2
81284: NEG
81285: PUSH
81286: EMPTY
81287: LIST
81288: LIST
81289: PUSH
81290: LD_INT 4
81292: NEG
81293: PUSH
81294: LD_INT 3
81296: NEG
81297: PUSH
81298: EMPTY
81299: LIST
81300: LIST
81301: PUSH
81302: LD_INT 4
81304: NEG
81305: PUSH
81306: LD_INT 4
81308: NEG
81309: PUSH
81310: EMPTY
81311: LIST
81312: LIST
81313: PUSH
81314: LD_INT 2
81316: NEG
81317: PUSH
81318: LD_INT 4
81320: NEG
81321: PUSH
81322: EMPTY
81323: LIST
81324: LIST
81325: PUSH
81326: LD_INT 4
81328: NEG
81329: PUSH
81330: LD_INT 2
81332: NEG
81333: PUSH
81334: EMPTY
81335: LIST
81336: LIST
81337: PUSH
81338: LD_INT 0
81340: PUSH
81341: LD_INT 4
81343: NEG
81344: PUSH
81345: EMPTY
81346: LIST
81347: LIST
81348: PUSH
81349: LD_INT 0
81351: PUSH
81352: LD_INT 5
81354: NEG
81355: PUSH
81356: EMPTY
81357: LIST
81358: LIST
81359: PUSH
81360: LD_INT 1
81362: PUSH
81363: LD_INT 4
81365: NEG
81366: PUSH
81367: EMPTY
81368: LIST
81369: LIST
81370: PUSH
81371: LD_INT 1
81373: PUSH
81374: LD_INT 3
81376: NEG
81377: PUSH
81378: EMPTY
81379: LIST
81380: LIST
81381: PUSH
81382: LD_INT 0
81384: PUSH
81385: LD_INT 3
81387: NEG
81388: PUSH
81389: EMPTY
81390: LIST
81391: LIST
81392: PUSH
81393: LD_INT 1
81395: NEG
81396: PUSH
81397: LD_INT 4
81399: NEG
81400: PUSH
81401: EMPTY
81402: LIST
81403: LIST
81404: PUSH
81405: LD_INT 1
81407: NEG
81408: PUSH
81409: LD_INT 5
81411: NEG
81412: PUSH
81413: EMPTY
81414: LIST
81415: LIST
81416: PUSH
81417: LD_INT 2
81419: PUSH
81420: LD_INT 3
81422: NEG
81423: PUSH
81424: EMPTY
81425: LIST
81426: LIST
81427: PUSH
81428: LD_INT 2
81430: NEG
81431: PUSH
81432: LD_INT 5
81434: NEG
81435: PUSH
81436: EMPTY
81437: LIST
81438: LIST
81439: PUSH
81440: EMPTY
81441: LIST
81442: LIST
81443: LIST
81444: LIST
81445: LIST
81446: LIST
81447: LIST
81448: LIST
81449: LIST
81450: LIST
81451: LIST
81452: LIST
81453: LIST
81454: LIST
81455: LIST
81456: LIST
81457: LIST
81458: LIST
81459: LIST
81460: LIST
81461: LIST
81462: LIST
81463: LIST
81464: LIST
81465: LIST
81466: LIST
81467: LIST
81468: LIST
81469: LIST
81470: LIST
81471: LIST
81472: LIST
81473: LIST
81474: LIST
81475: LIST
81476: LIST
81477: LIST
81478: LIST
81479: LIST
81480: LIST
81481: LIST
81482: LIST
81483: LIST
81484: LIST
81485: LIST
81486: ST_TO_ADDR
// fFactory2 = [ [ 0 , 4 ] , [ 0 , 3 ] , [ 1 , 4 ] , [ 1 , 5 ] , [ 0 , 5 ] , [ - 1 , 4 ] , [ - 1 , 3 ] , [ 2 , 5 ] , [ - 2 , 3 ] , [ - 3 , 0 ] , [ - 3 , - 1 ] , [ - 2 , 0 ] , [ - 2 , 1 ] , [ - 3 , 1 ] , [ - 4 , 0 ] , [ - 4 , - 1 ] , [ - 4 , - 2 ] , [ - 2 , 2 ] , [ - 4 , - 4 ] , [ - 4 , - 5 ] , [ - 3 , - 4 ] , [ - 3 , - 3 ] , [ - 4 , - 3 ] , [ - 5 , - 4 ] , [ - 5 , - 5 ] , [ - 3 , - 5 ] , [ - 5 , - 3 ] , [ 0 , - 3 ] , [ 0 , - 4 ] , [ 1 , - 3 ] , [ 1 , - 2 ] , [ 0 , - 2 ] , [ - 1 , - 3 ] , [ - 1 , - 4 ] , [ 2 , - 2 ] , [ - 2 , - 4 ] , [ 4 , 0 ] , [ 4 , - 1 ] , [ 5 , 0 ] , [ 5 , 1 ] , [ 4 , 1 ] , [ 3 , 0 ] , [ 3 , - 1 ] , [ 3 , - 2 ] , [ 5 , 2 ] ] ;
81487: LD_ADDR_VAR 0 31
81491: PUSH
81492: LD_INT 0
81494: PUSH
81495: LD_INT 4
81497: PUSH
81498: EMPTY
81499: LIST
81500: LIST
81501: PUSH
81502: LD_INT 0
81504: PUSH
81505: LD_INT 3
81507: PUSH
81508: EMPTY
81509: LIST
81510: LIST
81511: PUSH
81512: LD_INT 1
81514: PUSH
81515: LD_INT 4
81517: PUSH
81518: EMPTY
81519: LIST
81520: LIST
81521: PUSH
81522: LD_INT 1
81524: PUSH
81525: LD_INT 5
81527: PUSH
81528: EMPTY
81529: LIST
81530: LIST
81531: PUSH
81532: LD_INT 0
81534: PUSH
81535: LD_INT 5
81537: PUSH
81538: EMPTY
81539: LIST
81540: LIST
81541: PUSH
81542: LD_INT 1
81544: NEG
81545: PUSH
81546: LD_INT 4
81548: PUSH
81549: EMPTY
81550: LIST
81551: LIST
81552: PUSH
81553: LD_INT 1
81555: NEG
81556: PUSH
81557: LD_INT 3
81559: PUSH
81560: EMPTY
81561: LIST
81562: LIST
81563: PUSH
81564: LD_INT 2
81566: PUSH
81567: LD_INT 5
81569: PUSH
81570: EMPTY
81571: LIST
81572: LIST
81573: PUSH
81574: LD_INT 2
81576: NEG
81577: PUSH
81578: LD_INT 3
81580: PUSH
81581: EMPTY
81582: LIST
81583: LIST
81584: PUSH
81585: LD_INT 3
81587: NEG
81588: PUSH
81589: LD_INT 0
81591: PUSH
81592: EMPTY
81593: LIST
81594: LIST
81595: PUSH
81596: LD_INT 3
81598: NEG
81599: PUSH
81600: LD_INT 1
81602: NEG
81603: PUSH
81604: EMPTY
81605: LIST
81606: LIST
81607: PUSH
81608: LD_INT 2
81610: NEG
81611: PUSH
81612: LD_INT 0
81614: PUSH
81615: EMPTY
81616: LIST
81617: LIST
81618: PUSH
81619: LD_INT 2
81621: NEG
81622: PUSH
81623: LD_INT 1
81625: PUSH
81626: EMPTY
81627: LIST
81628: LIST
81629: PUSH
81630: LD_INT 3
81632: NEG
81633: PUSH
81634: LD_INT 1
81636: PUSH
81637: EMPTY
81638: LIST
81639: LIST
81640: PUSH
81641: LD_INT 4
81643: NEG
81644: PUSH
81645: LD_INT 0
81647: PUSH
81648: EMPTY
81649: LIST
81650: LIST
81651: PUSH
81652: LD_INT 4
81654: NEG
81655: PUSH
81656: LD_INT 1
81658: NEG
81659: PUSH
81660: EMPTY
81661: LIST
81662: LIST
81663: PUSH
81664: LD_INT 4
81666: NEG
81667: PUSH
81668: LD_INT 2
81670: NEG
81671: PUSH
81672: EMPTY
81673: LIST
81674: LIST
81675: PUSH
81676: LD_INT 2
81678: NEG
81679: PUSH
81680: LD_INT 2
81682: PUSH
81683: EMPTY
81684: LIST
81685: LIST
81686: PUSH
81687: LD_INT 4
81689: NEG
81690: PUSH
81691: LD_INT 4
81693: NEG
81694: PUSH
81695: EMPTY
81696: LIST
81697: LIST
81698: PUSH
81699: LD_INT 4
81701: NEG
81702: PUSH
81703: LD_INT 5
81705: NEG
81706: PUSH
81707: EMPTY
81708: LIST
81709: LIST
81710: PUSH
81711: LD_INT 3
81713: NEG
81714: PUSH
81715: LD_INT 4
81717: NEG
81718: PUSH
81719: EMPTY
81720: LIST
81721: LIST
81722: PUSH
81723: LD_INT 3
81725: NEG
81726: PUSH
81727: LD_INT 3
81729: NEG
81730: PUSH
81731: EMPTY
81732: LIST
81733: LIST
81734: PUSH
81735: LD_INT 4
81737: NEG
81738: PUSH
81739: LD_INT 3
81741: NEG
81742: PUSH
81743: EMPTY
81744: LIST
81745: LIST
81746: PUSH
81747: LD_INT 5
81749: NEG
81750: PUSH
81751: LD_INT 4
81753: NEG
81754: PUSH
81755: EMPTY
81756: LIST
81757: LIST
81758: PUSH
81759: LD_INT 5
81761: NEG
81762: PUSH
81763: LD_INT 5
81765: NEG
81766: PUSH
81767: EMPTY
81768: LIST
81769: LIST
81770: PUSH
81771: LD_INT 3
81773: NEG
81774: PUSH
81775: LD_INT 5
81777: NEG
81778: PUSH
81779: EMPTY
81780: LIST
81781: LIST
81782: PUSH
81783: LD_INT 5
81785: NEG
81786: PUSH
81787: LD_INT 3
81789: NEG
81790: PUSH
81791: EMPTY
81792: LIST
81793: LIST
81794: PUSH
81795: LD_INT 0
81797: PUSH
81798: LD_INT 3
81800: NEG
81801: PUSH
81802: EMPTY
81803: LIST
81804: LIST
81805: PUSH
81806: LD_INT 0
81808: PUSH
81809: LD_INT 4
81811: NEG
81812: PUSH
81813: EMPTY
81814: LIST
81815: LIST
81816: PUSH
81817: LD_INT 1
81819: PUSH
81820: LD_INT 3
81822: NEG
81823: PUSH
81824: EMPTY
81825: LIST
81826: LIST
81827: PUSH
81828: LD_INT 1
81830: PUSH
81831: LD_INT 2
81833: NEG
81834: PUSH
81835: EMPTY
81836: LIST
81837: LIST
81838: PUSH
81839: LD_INT 0
81841: PUSH
81842: LD_INT 2
81844: NEG
81845: PUSH
81846: EMPTY
81847: LIST
81848: LIST
81849: PUSH
81850: LD_INT 1
81852: NEG
81853: PUSH
81854: LD_INT 3
81856: NEG
81857: PUSH
81858: EMPTY
81859: LIST
81860: LIST
81861: PUSH
81862: LD_INT 1
81864: NEG
81865: PUSH
81866: LD_INT 4
81868: NEG
81869: PUSH
81870: EMPTY
81871: LIST
81872: LIST
81873: PUSH
81874: LD_INT 2
81876: PUSH
81877: LD_INT 2
81879: NEG
81880: PUSH
81881: EMPTY
81882: LIST
81883: LIST
81884: PUSH
81885: LD_INT 2
81887: NEG
81888: PUSH
81889: LD_INT 4
81891: NEG
81892: PUSH
81893: EMPTY
81894: LIST
81895: LIST
81896: PUSH
81897: LD_INT 4
81899: PUSH
81900: LD_INT 0
81902: PUSH
81903: EMPTY
81904: LIST
81905: LIST
81906: PUSH
81907: LD_INT 4
81909: PUSH
81910: LD_INT 1
81912: NEG
81913: PUSH
81914: EMPTY
81915: LIST
81916: LIST
81917: PUSH
81918: LD_INT 5
81920: PUSH
81921: LD_INT 0
81923: PUSH
81924: EMPTY
81925: LIST
81926: LIST
81927: PUSH
81928: LD_INT 5
81930: PUSH
81931: LD_INT 1
81933: PUSH
81934: EMPTY
81935: LIST
81936: LIST
81937: PUSH
81938: LD_INT 4
81940: PUSH
81941: LD_INT 1
81943: PUSH
81944: EMPTY
81945: LIST
81946: LIST
81947: PUSH
81948: LD_INT 3
81950: PUSH
81951: LD_INT 0
81953: PUSH
81954: EMPTY
81955: LIST
81956: LIST
81957: PUSH
81958: LD_INT 3
81960: PUSH
81961: LD_INT 1
81963: NEG
81964: PUSH
81965: EMPTY
81966: LIST
81967: LIST
81968: PUSH
81969: LD_INT 3
81971: PUSH
81972: LD_INT 2
81974: NEG
81975: PUSH
81976: EMPTY
81977: LIST
81978: LIST
81979: PUSH
81980: LD_INT 5
81982: PUSH
81983: LD_INT 2
81985: PUSH
81986: EMPTY
81987: LIST
81988: LIST
81989: PUSH
81990: EMPTY
81991: LIST
81992: LIST
81993: LIST
81994: LIST
81995: LIST
81996: LIST
81997: LIST
81998: LIST
81999: LIST
82000: LIST
82001: LIST
82002: LIST
82003: LIST
82004: LIST
82005: LIST
82006: LIST
82007: LIST
82008: LIST
82009: LIST
82010: LIST
82011: LIST
82012: LIST
82013: LIST
82014: LIST
82015: LIST
82016: LIST
82017: LIST
82018: LIST
82019: LIST
82020: LIST
82021: LIST
82022: LIST
82023: LIST
82024: LIST
82025: LIST
82026: LIST
82027: LIST
82028: LIST
82029: LIST
82030: LIST
82031: LIST
82032: LIST
82033: LIST
82034: LIST
82035: LIST
82036: ST_TO_ADDR
// fFactory3 = [ [ - 4 , 0 ] , [ - 4 , - 1 ] , [ - 3 , 0 ] , [ - 3 , 1 ] , [ - 4 , 1 ] , [ - 5 , 0 ] , [ - 5 , - 1 ] , [ - 5 , - 2 ] , [ - 3 , 2 ] , [ - 3 , - 3 ] , [ - 3 , - 4 ] , [ - 2 , - 3 ] , [ - 2 , - 2 ] , [ - 3 , - 2 ] , [ - 4 , - 3 ] , [ - 4 , - 4 ] , [ - 2 , - 4 ] , [ - 4 , - 2 ] , [ 0 , - 4 ] , [ 0 , - 5 ] , [ 1 , - 4 ] , [ 1 , - 3 ] , [ 0 , - 3 ] , [ - 1 , - 4 ] , [ - 1 , - 5 ] , [ 2 , - 3 ] , [ - 2 , - 5 ] , [ 3 , 0 ] , [ 3 , - 1 ] , [ 4 , 0 ] , [ 4 , 1 ] , [ 3 , 1 ] , [ 2 , 0 ] , [ 2 , - 1 ] , [ 2 , - 2 ] , [ 4 , 2 ] , [ 4 , 4 ] , [ 4 , 3 ] , [ 5 , 4 ] , [ 5 , 5 ] , [ 4 , 5 ] , [ 3 , 4 ] , [ 3 , 3 ] , [ 5 , 3 ] , [ 3 , 5 ] ] ;
82037: LD_ADDR_VAR 0 32
82041: PUSH
82042: LD_INT 4
82044: NEG
82045: PUSH
82046: LD_INT 0
82048: PUSH
82049: EMPTY
82050: LIST
82051: LIST
82052: PUSH
82053: LD_INT 4
82055: NEG
82056: PUSH
82057: LD_INT 1
82059: NEG
82060: PUSH
82061: EMPTY
82062: LIST
82063: LIST
82064: PUSH
82065: LD_INT 3
82067: NEG
82068: PUSH
82069: LD_INT 0
82071: PUSH
82072: EMPTY
82073: LIST
82074: LIST
82075: PUSH
82076: LD_INT 3
82078: NEG
82079: PUSH
82080: LD_INT 1
82082: PUSH
82083: EMPTY
82084: LIST
82085: LIST
82086: PUSH
82087: LD_INT 4
82089: NEG
82090: PUSH
82091: LD_INT 1
82093: PUSH
82094: EMPTY
82095: LIST
82096: LIST
82097: PUSH
82098: LD_INT 5
82100: NEG
82101: PUSH
82102: LD_INT 0
82104: PUSH
82105: EMPTY
82106: LIST
82107: LIST
82108: PUSH
82109: LD_INT 5
82111: NEG
82112: PUSH
82113: LD_INT 1
82115: NEG
82116: PUSH
82117: EMPTY
82118: LIST
82119: LIST
82120: PUSH
82121: LD_INT 5
82123: NEG
82124: PUSH
82125: LD_INT 2
82127: NEG
82128: PUSH
82129: EMPTY
82130: LIST
82131: LIST
82132: PUSH
82133: LD_INT 3
82135: NEG
82136: PUSH
82137: LD_INT 2
82139: PUSH
82140: EMPTY
82141: LIST
82142: LIST
82143: PUSH
82144: LD_INT 3
82146: NEG
82147: PUSH
82148: LD_INT 3
82150: NEG
82151: PUSH
82152: EMPTY
82153: LIST
82154: LIST
82155: PUSH
82156: LD_INT 3
82158: NEG
82159: PUSH
82160: LD_INT 4
82162: NEG
82163: PUSH
82164: EMPTY
82165: LIST
82166: LIST
82167: PUSH
82168: LD_INT 2
82170: NEG
82171: PUSH
82172: LD_INT 3
82174: NEG
82175: PUSH
82176: EMPTY
82177: LIST
82178: LIST
82179: PUSH
82180: LD_INT 2
82182: NEG
82183: PUSH
82184: LD_INT 2
82186: NEG
82187: PUSH
82188: EMPTY
82189: LIST
82190: LIST
82191: PUSH
82192: LD_INT 3
82194: NEG
82195: PUSH
82196: LD_INT 2
82198: NEG
82199: PUSH
82200: EMPTY
82201: LIST
82202: LIST
82203: PUSH
82204: LD_INT 4
82206: NEG
82207: PUSH
82208: LD_INT 3
82210: NEG
82211: PUSH
82212: EMPTY
82213: LIST
82214: LIST
82215: PUSH
82216: LD_INT 4
82218: NEG
82219: PUSH
82220: LD_INT 4
82222: NEG
82223: PUSH
82224: EMPTY
82225: LIST
82226: LIST
82227: PUSH
82228: LD_INT 2
82230: NEG
82231: PUSH
82232: LD_INT 4
82234: NEG
82235: PUSH
82236: EMPTY
82237: LIST
82238: LIST
82239: PUSH
82240: LD_INT 4
82242: NEG
82243: PUSH
82244: LD_INT 2
82246: NEG
82247: PUSH
82248: EMPTY
82249: LIST
82250: LIST
82251: PUSH
82252: LD_INT 0
82254: PUSH
82255: LD_INT 4
82257: NEG
82258: PUSH
82259: EMPTY
82260: LIST
82261: LIST
82262: PUSH
82263: LD_INT 0
82265: PUSH
82266: LD_INT 5
82268: NEG
82269: PUSH
82270: EMPTY
82271: LIST
82272: LIST
82273: PUSH
82274: LD_INT 1
82276: PUSH
82277: LD_INT 4
82279: NEG
82280: PUSH
82281: EMPTY
82282: LIST
82283: LIST
82284: PUSH
82285: LD_INT 1
82287: PUSH
82288: LD_INT 3
82290: NEG
82291: PUSH
82292: EMPTY
82293: LIST
82294: LIST
82295: PUSH
82296: LD_INT 0
82298: PUSH
82299: LD_INT 3
82301: NEG
82302: PUSH
82303: EMPTY
82304: LIST
82305: LIST
82306: PUSH
82307: LD_INT 1
82309: NEG
82310: PUSH
82311: LD_INT 4
82313: NEG
82314: PUSH
82315: EMPTY
82316: LIST
82317: LIST
82318: PUSH
82319: LD_INT 1
82321: NEG
82322: PUSH
82323: LD_INT 5
82325: NEG
82326: PUSH
82327: EMPTY
82328: LIST
82329: LIST
82330: PUSH
82331: LD_INT 2
82333: PUSH
82334: LD_INT 3
82336: NEG
82337: PUSH
82338: EMPTY
82339: LIST
82340: LIST
82341: PUSH
82342: LD_INT 2
82344: NEG
82345: PUSH
82346: LD_INT 5
82348: NEG
82349: PUSH
82350: EMPTY
82351: LIST
82352: LIST
82353: PUSH
82354: LD_INT 3
82356: PUSH
82357: LD_INT 0
82359: PUSH
82360: EMPTY
82361: LIST
82362: LIST
82363: PUSH
82364: LD_INT 3
82366: PUSH
82367: LD_INT 1
82369: NEG
82370: PUSH
82371: EMPTY
82372: LIST
82373: LIST
82374: PUSH
82375: LD_INT 4
82377: PUSH
82378: LD_INT 0
82380: PUSH
82381: EMPTY
82382: LIST
82383: LIST
82384: PUSH
82385: LD_INT 4
82387: PUSH
82388: LD_INT 1
82390: PUSH
82391: EMPTY
82392: LIST
82393: LIST
82394: PUSH
82395: LD_INT 3
82397: PUSH
82398: LD_INT 1
82400: PUSH
82401: EMPTY
82402: LIST
82403: LIST
82404: PUSH
82405: LD_INT 2
82407: PUSH
82408: LD_INT 0
82410: PUSH
82411: EMPTY
82412: LIST
82413: LIST
82414: PUSH
82415: LD_INT 2
82417: PUSH
82418: LD_INT 1
82420: NEG
82421: PUSH
82422: EMPTY
82423: LIST
82424: LIST
82425: PUSH
82426: LD_INT 2
82428: PUSH
82429: LD_INT 2
82431: NEG
82432: PUSH
82433: EMPTY
82434: LIST
82435: LIST
82436: PUSH
82437: LD_INT 4
82439: PUSH
82440: LD_INT 2
82442: PUSH
82443: EMPTY
82444: LIST
82445: LIST
82446: PUSH
82447: LD_INT 4
82449: PUSH
82450: LD_INT 4
82452: PUSH
82453: EMPTY
82454: LIST
82455: LIST
82456: PUSH
82457: LD_INT 4
82459: PUSH
82460: LD_INT 3
82462: PUSH
82463: EMPTY
82464: LIST
82465: LIST
82466: PUSH
82467: LD_INT 5
82469: PUSH
82470: LD_INT 4
82472: PUSH
82473: EMPTY
82474: LIST
82475: LIST
82476: PUSH
82477: LD_INT 5
82479: PUSH
82480: LD_INT 5
82482: PUSH
82483: EMPTY
82484: LIST
82485: LIST
82486: PUSH
82487: LD_INT 4
82489: PUSH
82490: LD_INT 5
82492: PUSH
82493: EMPTY
82494: LIST
82495: LIST
82496: PUSH
82497: LD_INT 3
82499: PUSH
82500: LD_INT 4
82502: PUSH
82503: EMPTY
82504: LIST
82505: LIST
82506: PUSH
82507: LD_INT 3
82509: PUSH
82510: LD_INT 3
82512: PUSH
82513: EMPTY
82514: LIST
82515: LIST
82516: PUSH
82517: LD_INT 5
82519: PUSH
82520: LD_INT 3
82522: PUSH
82523: EMPTY
82524: LIST
82525: LIST
82526: PUSH
82527: LD_INT 3
82529: PUSH
82530: LD_INT 5
82532: PUSH
82533: EMPTY
82534: LIST
82535: LIST
82536: PUSH
82537: EMPTY
82538: LIST
82539: LIST
82540: LIST
82541: LIST
82542: LIST
82543: LIST
82544: LIST
82545: LIST
82546: LIST
82547: LIST
82548: LIST
82549: LIST
82550: LIST
82551: LIST
82552: LIST
82553: LIST
82554: LIST
82555: LIST
82556: LIST
82557: LIST
82558: LIST
82559: LIST
82560: LIST
82561: LIST
82562: LIST
82563: LIST
82564: LIST
82565: LIST
82566: LIST
82567: LIST
82568: LIST
82569: LIST
82570: LIST
82571: LIST
82572: LIST
82573: LIST
82574: LIST
82575: LIST
82576: LIST
82577: LIST
82578: LIST
82579: LIST
82580: LIST
82581: LIST
82582: LIST
82583: ST_TO_ADDR
// fFactory4 = [ [ - 4 , - 4 ] , [ - 4 , - 5 ] , [ - 3 , - 4 ] , [ - 3 , - 3 ] , [ - 4 , - 3 ] , [ - 5 , - 4 ] , [ - 5 , - 5 ] , [ - 3 , - 5 ] , [ - 5 , - 3 ] , [ 0 , - 3 ] , [ 0 , - 4 ] , [ 1 , - 3 ] , [ 1 , - 2 ] , [ 0 , - 2 ] , [ - 1 , - 3 ] , [ - 1 , - 4 ] , [ 2 , - 2 ] , [ - 2 , - 4 ] , [ 4 , 0 ] , [ 4 , - 1 ] , [ 5 , 0 ] , [ 5 , 1 ] , [ 4 , 1 ] , [ 3 , 0 ] , [ 3 , - 1 ] , [ 3 , - 2 ] , [ 5 , 2 ] , [ 3 , 3 ] , [ 3 , 2 ] , [ 4 , 3 ] , [ 4 , 4 ] , [ 3 , 4 ] , [ 2 , 3 ] , [ 2 , 2 ] , [ 4 , 2 ] , [ 2 , 4 ] , [ 0 , 4 ] , [ 0 , 3 ] , [ 1 , 4 ] , [ 1 , 5 ] , [ 0 , 5 ] , [ - 1 , 4 ] , [ - 1 , 3 ] , [ 2 , 5 ] , [ - 2 , 3 ] ] ;
82584: LD_ADDR_VAR 0 33
82588: PUSH
82589: LD_INT 4
82591: NEG
82592: PUSH
82593: LD_INT 4
82595: NEG
82596: PUSH
82597: EMPTY
82598: LIST
82599: LIST
82600: PUSH
82601: LD_INT 4
82603: NEG
82604: PUSH
82605: LD_INT 5
82607: NEG
82608: PUSH
82609: EMPTY
82610: LIST
82611: LIST
82612: PUSH
82613: LD_INT 3
82615: NEG
82616: PUSH
82617: LD_INT 4
82619: NEG
82620: PUSH
82621: EMPTY
82622: LIST
82623: LIST
82624: PUSH
82625: LD_INT 3
82627: NEG
82628: PUSH
82629: LD_INT 3
82631: NEG
82632: PUSH
82633: EMPTY
82634: LIST
82635: LIST
82636: PUSH
82637: LD_INT 4
82639: NEG
82640: PUSH
82641: LD_INT 3
82643: NEG
82644: PUSH
82645: EMPTY
82646: LIST
82647: LIST
82648: PUSH
82649: LD_INT 5
82651: NEG
82652: PUSH
82653: LD_INT 4
82655: NEG
82656: PUSH
82657: EMPTY
82658: LIST
82659: LIST
82660: PUSH
82661: LD_INT 5
82663: NEG
82664: PUSH
82665: LD_INT 5
82667: NEG
82668: PUSH
82669: EMPTY
82670: LIST
82671: LIST
82672: PUSH
82673: LD_INT 3
82675: NEG
82676: PUSH
82677: LD_INT 5
82679: NEG
82680: PUSH
82681: EMPTY
82682: LIST
82683: LIST
82684: PUSH
82685: LD_INT 5
82687: NEG
82688: PUSH
82689: LD_INT 3
82691: NEG
82692: PUSH
82693: EMPTY
82694: LIST
82695: LIST
82696: PUSH
82697: LD_INT 0
82699: PUSH
82700: LD_INT 3
82702: NEG
82703: PUSH
82704: EMPTY
82705: LIST
82706: LIST
82707: PUSH
82708: LD_INT 0
82710: PUSH
82711: LD_INT 4
82713: NEG
82714: PUSH
82715: EMPTY
82716: LIST
82717: LIST
82718: PUSH
82719: LD_INT 1
82721: PUSH
82722: LD_INT 3
82724: NEG
82725: PUSH
82726: EMPTY
82727: LIST
82728: LIST
82729: PUSH
82730: LD_INT 1
82732: PUSH
82733: LD_INT 2
82735: NEG
82736: PUSH
82737: EMPTY
82738: LIST
82739: LIST
82740: PUSH
82741: LD_INT 0
82743: PUSH
82744: LD_INT 2
82746: NEG
82747: PUSH
82748: EMPTY
82749: LIST
82750: LIST
82751: PUSH
82752: LD_INT 1
82754: NEG
82755: PUSH
82756: LD_INT 3
82758: NEG
82759: PUSH
82760: EMPTY
82761: LIST
82762: LIST
82763: PUSH
82764: LD_INT 1
82766: NEG
82767: PUSH
82768: LD_INT 4
82770: NEG
82771: PUSH
82772: EMPTY
82773: LIST
82774: LIST
82775: PUSH
82776: LD_INT 2
82778: PUSH
82779: LD_INT 2
82781: NEG
82782: PUSH
82783: EMPTY
82784: LIST
82785: LIST
82786: PUSH
82787: LD_INT 2
82789: NEG
82790: PUSH
82791: LD_INT 4
82793: NEG
82794: PUSH
82795: EMPTY
82796: LIST
82797: LIST
82798: PUSH
82799: LD_INT 4
82801: PUSH
82802: LD_INT 0
82804: PUSH
82805: EMPTY
82806: LIST
82807: LIST
82808: PUSH
82809: LD_INT 4
82811: PUSH
82812: LD_INT 1
82814: NEG
82815: PUSH
82816: EMPTY
82817: LIST
82818: LIST
82819: PUSH
82820: LD_INT 5
82822: PUSH
82823: LD_INT 0
82825: PUSH
82826: EMPTY
82827: LIST
82828: LIST
82829: PUSH
82830: LD_INT 5
82832: PUSH
82833: LD_INT 1
82835: PUSH
82836: EMPTY
82837: LIST
82838: LIST
82839: PUSH
82840: LD_INT 4
82842: PUSH
82843: LD_INT 1
82845: PUSH
82846: EMPTY
82847: LIST
82848: LIST
82849: PUSH
82850: LD_INT 3
82852: PUSH
82853: LD_INT 0
82855: PUSH
82856: EMPTY
82857: LIST
82858: LIST
82859: PUSH
82860: LD_INT 3
82862: PUSH
82863: LD_INT 1
82865: NEG
82866: PUSH
82867: EMPTY
82868: LIST
82869: LIST
82870: PUSH
82871: LD_INT 3
82873: PUSH
82874: LD_INT 2
82876: NEG
82877: PUSH
82878: EMPTY
82879: LIST
82880: LIST
82881: PUSH
82882: LD_INT 5
82884: PUSH
82885: LD_INT 2
82887: PUSH
82888: EMPTY
82889: LIST
82890: LIST
82891: PUSH
82892: LD_INT 3
82894: PUSH
82895: LD_INT 3
82897: PUSH
82898: EMPTY
82899: LIST
82900: LIST
82901: PUSH
82902: LD_INT 3
82904: PUSH
82905: LD_INT 2
82907: PUSH
82908: EMPTY
82909: LIST
82910: LIST
82911: PUSH
82912: LD_INT 4
82914: PUSH
82915: LD_INT 3
82917: PUSH
82918: EMPTY
82919: LIST
82920: LIST
82921: PUSH
82922: LD_INT 4
82924: PUSH
82925: LD_INT 4
82927: PUSH
82928: EMPTY
82929: LIST
82930: LIST
82931: PUSH
82932: LD_INT 3
82934: PUSH
82935: LD_INT 4
82937: PUSH
82938: EMPTY
82939: LIST
82940: LIST
82941: PUSH
82942: LD_INT 2
82944: PUSH
82945: LD_INT 3
82947: PUSH
82948: EMPTY
82949: LIST
82950: LIST
82951: PUSH
82952: LD_INT 2
82954: PUSH
82955: LD_INT 2
82957: PUSH
82958: EMPTY
82959: LIST
82960: LIST
82961: PUSH
82962: LD_INT 4
82964: PUSH
82965: LD_INT 2
82967: PUSH
82968: EMPTY
82969: LIST
82970: LIST
82971: PUSH
82972: LD_INT 2
82974: PUSH
82975: LD_INT 4
82977: PUSH
82978: EMPTY
82979: LIST
82980: LIST
82981: PUSH
82982: LD_INT 0
82984: PUSH
82985: LD_INT 4
82987: PUSH
82988: EMPTY
82989: LIST
82990: LIST
82991: PUSH
82992: LD_INT 0
82994: PUSH
82995: LD_INT 3
82997: PUSH
82998: EMPTY
82999: LIST
83000: LIST
83001: PUSH
83002: LD_INT 1
83004: PUSH
83005: LD_INT 4
83007: PUSH
83008: EMPTY
83009: LIST
83010: LIST
83011: PUSH
83012: LD_INT 1
83014: PUSH
83015: LD_INT 5
83017: PUSH
83018: EMPTY
83019: LIST
83020: LIST
83021: PUSH
83022: LD_INT 0
83024: PUSH
83025: LD_INT 5
83027: PUSH
83028: EMPTY
83029: LIST
83030: LIST
83031: PUSH
83032: LD_INT 1
83034: NEG
83035: PUSH
83036: LD_INT 4
83038: PUSH
83039: EMPTY
83040: LIST
83041: LIST
83042: PUSH
83043: LD_INT 1
83045: NEG
83046: PUSH
83047: LD_INT 3
83049: PUSH
83050: EMPTY
83051: LIST
83052: LIST
83053: PUSH
83054: LD_INT 2
83056: PUSH
83057: LD_INT 5
83059: PUSH
83060: EMPTY
83061: LIST
83062: LIST
83063: PUSH
83064: LD_INT 2
83066: NEG
83067: PUSH
83068: LD_INT 3
83070: PUSH
83071: EMPTY
83072: LIST
83073: LIST
83074: PUSH
83075: EMPTY
83076: LIST
83077: LIST
83078: LIST
83079: LIST
83080: LIST
83081: LIST
83082: LIST
83083: LIST
83084: LIST
83085: LIST
83086: LIST
83087: LIST
83088: LIST
83089: LIST
83090: LIST
83091: LIST
83092: LIST
83093: LIST
83094: LIST
83095: LIST
83096: LIST
83097: LIST
83098: LIST
83099: LIST
83100: LIST
83101: LIST
83102: LIST
83103: LIST
83104: LIST
83105: LIST
83106: LIST
83107: LIST
83108: LIST
83109: LIST
83110: LIST
83111: LIST
83112: LIST
83113: LIST
83114: LIST
83115: LIST
83116: LIST
83117: LIST
83118: LIST
83119: LIST
83120: LIST
83121: ST_TO_ADDR
// fFactory5 = [ [ 0 , - 4 ] , [ 0 , - 5 ] , [ 1 , - 4 ] , [ 1 , - 3 ] , [ 0 , - 3 ] , [ - 1 , - 4 ] , [ - 1 , - 5 ] , [ 2 , - 3 ] , [ - 2 , - 5 ] , [ 3 , 0 ] , [ 3 , - 1 ] , [ 4 , 0 ] , [ 4 , 1 ] , [ 3 , 1 ] , [ 2 , 0 ] , [ 2 , - 1 ] , [ 2 , - 2 ] , [ 4 , 2 ] , [ 4 , 4 ] , [ 4 , 3 ] , [ 5 , 4 ] , [ 5 , 5 ] , [ 4 , 5 ] , [ 3 , 4 ] , [ 3 , 3 ] , [ 5 , 3 ] , [ 3 , 5 ] , [ 0 , 3 ] , [ 0 , 2 ] , [ 1 , 3 ] , [ 1 , 4 ] , [ 0 , 4 ] , [ - 1 , 3 ] , [ - 1 , 2 ] , [ 2 , 4 ] , [ - 2 , 2 ] , [ - 4 , 0 ] , [ - 4 , - 1 ] , [ - 3 , 0 ] , [ - 3 , 1 ] , [ - 4 , 1 ] , [ - 5 , 0 ] , [ - 5 , - 1 ] , [ - 5 , - 2 ] , [ - 3 , 2 ] ] ;
83122: LD_ADDR_VAR 0 34
83126: PUSH
83127: LD_INT 0
83129: PUSH
83130: LD_INT 4
83132: NEG
83133: PUSH
83134: EMPTY
83135: LIST
83136: LIST
83137: PUSH
83138: LD_INT 0
83140: PUSH
83141: LD_INT 5
83143: NEG
83144: PUSH
83145: EMPTY
83146: LIST
83147: LIST
83148: PUSH
83149: LD_INT 1
83151: PUSH
83152: LD_INT 4
83154: NEG
83155: PUSH
83156: EMPTY
83157: LIST
83158: LIST
83159: PUSH
83160: LD_INT 1
83162: PUSH
83163: LD_INT 3
83165: NEG
83166: PUSH
83167: EMPTY
83168: LIST
83169: LIST
83170: PUSH
83171: LD_INT 0
83173: PUSH
83174: LD_INT 3
83176: NEG
83177: PUSH
83178: EMPTY
83179: LIST
83180: LIST
83181: PUSH
83182: LD_INT 1
83184: NEG
83185: PUSH
83186: LD_INT 4
83188: NEG
83189: PUSH
83190: EMPTY
83191: LIST
83192: LIST
83193: PUSH
83194: LD_INT 1
83196: NEG
83197: PUSH
83198: LD_INT 5
83200: NEG
83201: PUSH
83202: EMPTY
83203: LIST
83204: LIST
83205: PUSH
83206: LD_INT 2
83208: PUSH
83209: LD_INT 3
83211: NEG
83212: PUSH
83213: EMPTY
83214: LIST
83215: LIST
83216: PUSH
83217: LD_INT 2
83219: NEG
83220: PUSH
83221: LD_INT 5
83223: NEG
83224: PUSH
83225: EMPTY
83226: LIST
83227: LIST
83228: PUSH
83229: LD_INT 3
83231: PUSH
83232: LD_INT 0
83234: PUSH
83235: EMPTY
83236: LIST
83237: LIST
83238: PUSH
83239: LD_INT 3
83241: PUSH
83242: LD_INT 1
83244: NEG
83245: PUSH
83246: EMPTY
83247: LIST
83248: LIST
83249: PUSH
83250: LD_INT 4
83252: PUSH
83253: LD_INT 0
83255: PUSH
83256: EMPTY
83257: LIST
83258: LIST
83259: PUSH
83260: LD_INT 4
83262: PUSH
83263: LD_INT 1
83265: PUSH
83266: EMPTY
83267: LIST
83268: LIST
83269: PUSH
83270: LD_INT 3
83272: PUSH
83273: LD_INT 1
83275: PUSH
83276: EMPTY
83277: LIST
83278: LIST
83279: PUSH
83280: LD_INT 2
83282: PUSH
83283: LD_INT 0
83285: PUSH
83286: EMPTY
83287: LIST
83288: LIST
83289: PUSH
83290: LD_INT 2
83292: PUSH
83293: LD_INT 1
83295: NEG
83296: PUSH
83297: EMPTY
83298: LIST
83299: LIST
83300: PUSH
83301: LD_INT 2
83303: PUSH
83304: LD_INT 2
83306: NEG
83307: PUSH
83308: EMPTY
83309: LIST
83310: LIST
83311: PUSH
83312: LD_INT 4
83314: PUSH
83315: LD_INT 2
83317: PUSH
83318: EMPTY
83319: LIST
83320: LIST
83321: PUSH
83322: LD_INT 4
83324: PUSH
83325: LD_INT 4
83327: PUSH
83328: EMPTY
83329: LIST
83330: LIST
83331: PUSH
83332: LD_INT 4
83334: PUSH
83335: LD_INT 3
83337: PUSH
83338: EMPTY
83339: LIST
83340: LIST
83341: PUSH
83342: LD_INT 5
83344: PUSH
83345: LD_INT 4
83347: PUSH
83348: EMPTY
83349: LIST
83350: LIST
83351: PUSH
83352: LD_INT 5
83354: PUSH
83355: LD_INT 5
83357: PUSH
83358: EMPTY
83359: LIST
83360: LIST
83361: PUSH
83362: LD_INT 4
83364: PUSH
83365: LD_INT 5
83367: PUSH
83368: EMPTY
83369: LIST
83370: LIST
83371: PUSH
83372: LD_INT 3
83374: PUSH
83375: LD_INT 4
83377: PUSH
83378: EMPTY
83379: LIST
83380: LIST
83381: PUSH
83382: LD_INT 3
83384: PUSH
83385: LD_INT 3
83387: PUSH
83388: EMPTY
83389: LIST
83390: LIST
83391: PUSH
83392: LD_INT 5
83394: PUSH
83395: LD_INT 3
83397: PUSH
83398: EMPTY
83399: LIST
83400: LIST
83401: PUSH
83402: LD_INT 3
83404: PUSH
83405: LD_INT 5
83407: PUSH
83408: EMPTY
83409: LIST
83410: LIST
83411: PUSH
83412: LD_INT 0
83414: PUSH
83415: LD_INT 3
83417: PUSH
83418: EMPTY
83419: LIST
83420: LIST
83421: PUSH
83422: LD_INT 0
83424: PUSH
83425: LD_INT 2
83427: PUSH
83428: EMPTY
83429: LIST
83430: LIST
83431: PUSH
83432: LD_INT 1
83434: PUSH
83435: LD_INT 3
83437: PUSH
83438: EMPTY
83439: LIST
83440: LIST
83441: PUSH
83442: LD_INT 1
83444: PUSH
83445: LD_INT 4
83447: PUSH
83448: EMPTY
83449: LIST
83450: LIST
83451: PUSH
83452: LD_INT 0
83454: PUSH
83455: LD_INT 4
83457: PUSH
83458: EMPTY
83459: LIST
83460: LIST
83461: PUSH
83462: LD_INT 1
83464: NEG
83465: PUSH
83466: LD_INT 3
83468: PUSH
83469: EMPTY
83470: LIST
83471: LIST
83472: PUSH
83473: LD_INT 1
83475: NEG
83476: PUSH
83477: LD_INT 2
83479: PUSH
83480: EMPTY
83481: LIST
83482: LIST
83483: PUSH
83484: LD_INT 2
83486: PUSH
83487: LD_INT 4
83489: PUSH
83490: EMPTY
83491: LIST
83492: LIST
83493: PUSH
83494: LD_INT 2
83496: NEG
83497: PUSH
83498: LD_INT 2
83500: PUSH
83501: EMPTY
83502: LIST
83503: LIST
83504: PUSH
83505: LD_INT 4
83507: NEG
83508: PUSH
83509: LD_INT 0
83511: PUSH
83512: EMPTY
83513: LIST
83514: LIST
83515: PUSH
83516: LD_INT 4
83518: NEG
83519: PUSH
83520: LD_INT 1
83522: NEG
83523: PUSH
83524: EMPTY
83525: LIST
83526: LIST
83527: PUSH
83528: LD_INT 3
83530: NEG
83531: PUSH
83532: LD_INT 0
83534: PUSH
83535: EMPTY
83536: LIST
83537: LIST
83538: PUSH
83539: LD_INT 3
83541: NEG
83542: PUSH
83543: LD_INT 1
83545: PUSH
83546: EMPTY
83547: LIST
83548: LIST
83549: PUSH
83550: LD_INT 4
83552: NEG
83553: PUSH
83554: LD_INT 1
83556: PUSH
83557: EMPTY
83558: LIST
83559: LIST
83560: PUSH
83561: LD_INT 5
83563: NEG
83564: PUSH
83565: LD_INT 0
83567: PUSH
83568: EMPTY
83569: LIST
83570: LIST
83571: PUSH
83572: LD_INT 5
83574: NEG
83575: PUSH
83576: LD_INT 1
83578: NEG
83579: PUSH
83580: EMPTY
83581: LIST
83582: LIST
83583: PUSH
83584: LD_INT 5
83586: NEG
83587: PUSH
83588: LD_INT 2
83590: NEG
83591: PUSH
83592: EMPTY
83593: LIST
83594: LIST
83595: PUSH
83596: LD_INT 3
83598: NEG
83599: PUSH
83600: LD_INT 2
83602: PUSH
83603: EMPTY
83604: LIST
83605: LIST
83606: PUSH
83607: EMPTY
83608: LIST
83609: LIST
83610: LIST
83611: LIST
83612: LIST
83613: LIST
83614: LIST
83615: LIST
83616: LIST
83617: LIST
83618: LIST
83619: LIST
83620: LIST
83621: LIST
83622: LIST
83623: LIST
83624: LIST
83625: LIST
83626: LIST
83627: LIST
83628: LIST
83629: LIST
83630: LIST
83631: LIST
83632: LIST
83633: LIST
83634: LIST
83635: LIST
83636: LIST
83637: LIST
83638: LIST
83639: LIST
83640: LIST
83641: LIST
83642: LIST
83643: LIST
83644: LIST
83645: LIST
83646: LIST
83647: LIST
83648: LIST
83649: LIST
83650: LIST
83651: LIST
83652: LIST
83653: ST_TO_ADDR
// end ; end ;
83654: GO 83657
83656: POP
// case btype of b_depot , b_warehouse :
83657: LD_VAR 0 1
83661: PUSH
83662: LD_INT 0
83664: DOUBLE
83665: EQUAL
83666: IFTRUE 83676
83668: LD_INT 1
83670: DOUBLE
83671: EQUAL
83672: IFTRUE 83676
83674: GO 83877
83676: POP
// case nation of nation_american :
83677: LD_VAR 0 5
83681: PUSH
83682: LD_INT 1
83684: DOUBLE
83685: EQUAL
83686: IFTRUE 83690
83688: GO 83746
83690: POP
// temp_list = [ fDepotAm0 , fDepotAm1 , fDepotAm2 , fDepotAm3 , fDepotAm4 , fDepotAm5 ] [ dir + 1 ] ; nation_arabian :
83691: LD_ADDR_VAR 0 9
83695: PUSH
83696: LD_VAR 0 11
83700: PUSH
83701: LD_VAR 0 12
83705: PUSH
83706: LD_VAR 0 13
83710: PUSH
83711: LD_VAR 0 14
83715: PUSH
83716: LD_VAR 0 15
83720: PUSH
83721: LD_VAR 0 16
83725: PUSH
83726: EMPTY
83727: LIST
83728: LIST
83729: LIST
83730: LIST
83731: LIST
83732: LIST
83733: PUSH
83734: LD_VAR 0 4
83738: PUSH
83739: LD_INT 1
83741: PLUS
83742: ARRAY
83743: ST_TO_ADDR
83744: GO 83875
83746: LD_INT 2
83748: DOUBLE
83749: EQUAL
83750: IFTRUE 83754
83752: GO 83810
83754: POP
// temp_list = [ fDepotAr0 , fDepotAr1 , fDepotAr2 , fDepotAr3 , fDepotAr4 , fDepotAr5 ] [ dir + 1 ] ; nation_russian :
83755: LD_ADDR_VAR 0 9
83759: PUSH
83760: LD_VAR 0 17
83764: PUSH
83765: LD_VAR 0 18
83769: PUSH
83770: LD_VAR 0 19
83774: PUSH
83775: LD_VAR 0 20
83779: PUSH
83780: LD_VAR 0 21
83784: PUSH
83785: LD_VAR 0 22
83789: PUSH
83790: EMPTY
83791: LIST
83792: LIST
83793: LIST
83794: LIST
83795: LIST
83796: LIST
83797: PUSH
83798: LD_VAR 0 4
83802: PUSH
83803: LD_INT 1
83805: PLUS
83806: ARRAY
83807: ST_TO_ADDR
83808: GO 83875
83810: LD_INT 3
83812: DOUBLE
83813: EQUAL
83814: IFTRUE 83818
83816: GO 83874
83818: POP
// temp_list = [ fDepotRu0 , fDepotRu1 , fDepotRu2 , fDepotRu3 , fDepotRu4 , fDepotRu5 ] [ dir + 1 ] ; end ; b_workshop , b_factory :
83819: LD_ADDR_VAR 0 9
83823: PUSH
83824: LD_VAR 0 23
83828: PUSH
83829: LD_VAR 0 24
83833: PUSH
83834: LD_VAR 0 25
83838: PUSH
83839: LD_VAR 0 26
83843: PUSH
83844: LD_VAR 0 27
83848: PUSH
83849: LD_VAR 0 28
83853: PUSH
83854: EMPTY
83855: LIST
83856: LIST
83857: LIST
83858: LIST
83859: LIST
83860: LIST
83861: PUSH
83862: LD_VAR 0 4
83866: PUSH
83867: LD_INT 1
83869: PLUS
83870: ARRAY
83871: ST_TO_ADDR
83872: GO 83875
83874: POP
83875: GO 84430
83877: LD_INT 2
83879: DOUBLE
83880: EQUAL
83881: IFTRUE 83891
83883: LD_INT 3
83885: DOUBLE
83886: EQUAL
83887: IFTRUE 83891
83889: GO 83947
83891: POP
// temp_list = [ fFactory0 , fFactory1 , fFactory2 , fFactory3 , fFactory4 , fFactory5 ] [ dir + 1 ] ; b_ext_track , b_ext_gun , b_ext_rocket , b_ext_noncombat , b_ext_radio , b_ext_radar , b_ext_siberium , b_ext_stitch , b_ext_computer , b_ext_laser :
83892: LD_ADDR_VAR 0 9
83896: PUSH
83897: LD_VAR 0 29
83901: PUSH
83902: LD_VAR 0 30
83906: PUSH
83907: LD_VAR 0 31
83911: PUSH
83912: LD_VAR 0 32
83916: PUSH
83917: LD_VAR 0 33
83921: PUSH
83922: LD_VAR 0 34
83926: PUSH
83927: EMPTY
83928: LIST
83929: LIST
83930: LIST
83931: LIST
83932: LIST
83933: LIST
83934: PUSH
83935: LD_VAR 0 4
83939: PUSH
83940: LD_INT 1
83942: PLUS
83943: ARRAY
83944: ST_TO_ADDR
83945: GO 84430
83947: LD_INT 16
83949: DOUBLE
83950: EQUAL
83951: IFTRUE 84009
83953: LD_INT 17
83955: DOUBLE
83956: EQUAL
83957: IFTRUE 84009
83959: LD_INT 18
83961: DOUBLE
83962: EQUAL
83963: IFTRUE 84009
83965: LD_INT 19
83967: DOUBLE
83968: EQUAL
83969: IFTRUE 84009
83971: LD_INT 22
83973: DOUBLE
83974: EQUAL
83975: IFTRUE 84009
83977: LD_INT 20
83979: DOUBLE
83980: EQUAL
83981: IFTRUE 84009
83983: LD_INT 21
83985: DOUBLE
83986: EQUAL
83987: IFTRUE 84009
83989: LD_INT 23
83991: DOUBLE
83992: EQUAL
83993: IFTRUE 84009
83995: LD_INT 24
83997: DOUBLE
83998: EQUAL
83999: IFTRUE 84009
84001: LD_INT 25
84003: DOUBLE
84004: EQUAL
84005: IFTRUE 84009
84007: GO 84065
84009: POP
// temp_list = [ fExt0 , fExt1 , fExt2 , fExt3 , fExt4 , fExt5 ] [ dir + 1 ] ; b_lab , b_lab_half , b_lab_full , b_lab_biological , b_lab_computer , b_lab_opto , b_lab_siberium , b_lab_spacetime , b_lab_weapon :
84010: LD_ADDR_VAR 0 9
84014: PUSH
84015: LD_VAR 0 35
84019: PUSH
84020: LD_VAR 0 36
84024: PUSH
84025: LD_VAR 0 37
84029: PUSH
84030: LD_VAR 0 38
84034: PUSH
84035: LD_VAR 0 39
84039: PUSH
84040: LD_VAR 0 40
84044: PUSH
84045: EMPTY
84046: LIST
84047: LIST
84048: LIST
84049: LIST
84050: LIST
84051: LIST
84052: PUSH
84053: LD_VAR 0 4
84057: PUSH
84058: LD_INT 1
84060: PLUS
84061: ARRAY
84062: ST_TO_ADDR
84063: GO 84430
84065: LD_INT 6
84067: DOUBLE
84068: EQUAL
84069: IFTRUE 84121
84071: LD_INT 7
84073: DOUBLE
84074: EQUAL
84075: IFTRUE 84121
84077: LD_INT 8
84079: DOUBLE
84080: EQUAL
84081: IFTRUE 84121
84083: LD_INT 13
84085: DOUBLE
84086: EQUAL
84087: IFTRUE 84121
84089: LD_INT 12
84091: DOUBLE
84092: EQUAL
84093: IFTRUE 84121
84095: LD_INT 15
84097: DOUBLE
84098: EQUAL
84099: IFTRUE 84121
84101: LD_INT 11
84103: DOUBLE
84104: EQUAL
84105: IFTRUE 84121
84107: LD_INT 14
84109: DOUBLE
84110: EQUAL
84111: IFTRUE 84121
84113: LD_INT 10
84115: DOUBLE
84116: EQUAL
84117: IFTRUE 84121
84119: GO 84177
84121: POP
// temp_list = [ fLab0 , fLab1 , fLab2 , fLab3 , fLab4 , fLab5 ] [ dir + 1 ] ; b_control_tower :
84122: LD_ADDR_VAR 0 9
84126: PUSH
84127: LD_VAR 0 41
84131: PUSH
84132: LD_VAR 0 42
84136: PUSH
84137: LD_VAR 0 43
84141: PUSH
84142: LD_VAR 0 44
84146: PUSH
84147: LD_VAR 0 45
84151: PUSH
84152: LD_VAR 0 46
84156: PUSH
84157: EMPTY
84158: LIST
84159: LIST
84160: LIST
84161: LIST
84162: LIST
84163: LIST
84164: PUSH
84165: LD_VAR 0 4
84169: PUSH
84170: LD_INT 1
84172: PLUS
84173: ARRAY
84174: ST_TO_ADDR
84175: GO 84430
84177: LD_INT 36
84179: DOUBLE
84180: EQUAL
84181: IFTRUE 84185
84183: GO 84241
84185: POP
// temp_list = [ fControlTower0 , fControlTower1 , fControlTower2 , fControlTower3 , fControlTower4 , fControlTower5 ] [ dir + 1 ] ; b_armoury , b_barracks , b_teleport , b_behemoth :
84186: LD_ADDR_VAR 0 9
84190: PUSH
84191: LD_VAR 0 47
84195: PUSH
84196: LD_VAR 0 48
84200: PUSH
84201: LD_VAR 0 49
84205: PUSH
84206: LD_VAR 0 50
84210: PUSH
84211: LD_VAR 0 51
84215: PUSH
84216: LD_VAR 0 52
84220: PUSH
84221: EMPTY
84222: LIST
84223: LIST
84224: LIST
84225: LIST
84226: LIST
84227: LIST
84228: PUSH
84229: LD_VAR 0 4
84233: PUSH
84234: LD_INT 1
84236: PLUS
84237: ARRAY
84238: ST_TO_ADDR
84239: GO 84430
84241: LD_INT 4
84243: DOUBLE
84244: EQUAL
84245: IFTRUE 84267
84247: LD_INT 5
84249: DOUBLE
84250: EQUAL
84251: IFTRUE 84267
84253: LD_INT 34
84255: DOUBLE
84256: EQUAL
84257: IFTRUE 84267
84259: LD_INT 37
84261: DOUBLE
84262: EQUAL
84263: IFTRUE 84267
84265: GO 84323
84267: POP
// temp_list = [ fBarracks0 , fBarracks1 , fBarracks2 , fBarracks3 , fBarracks4 , fBarracks5 ] [ dir + 1 ] ; b_breastwork , b_bunker , b_turret , b_solar_power , b_oil_power , b_siberite_power , b_oil_mine , b_siberite_mine :
84268: LD_ADDR_VAR 0 9
84272: PUSH
84273: LD_VAR 0 53
84277: PUSH
84278: LD_VAR 0 54
84282: PUSH
84283: LD_VAR 0 55
84287: PUSH
84288: LD_VAR 0 56
84292: PUSH
84293: LD_VAR 0 57
84297: PUSH
84298: LD_VAR 0 58
84302: PUSH
84303: EMPTY
84304: LIST
84305: LIST
84306: LIST
84307: LIST
84308: LIST
84309: LIST
84310: PUSH
84311: LD_VAR 0 4
84315: PUSH
84316: LD_INT 1
84318: PLUS
84319: ARRAY
84320: ST_TO_ADDR
84321: GO 84430
84323: LD_INT 31
84325: DOUBLE
84326: EQUAL
84327: IFTRUE 84373
84329: LD_INT 32
84331: DOUBLE
84332: EQUAL
84333: IFTRUE 84373
84335: LD_INT 33
84337: DOUBLE
84338: EQUAL
84339: IFTRUE 84373
84341: LD_INT 27
84343: DOUBLE
84344: EQUAL
84345: IFTRUE 84373
84347: LD_INT 26
84349: DOUBLE
84350: EQUAL
84351: IFTRUE 84373
84353: LD_INT 28
84355: DOUBLE
84356: EQUAL
84357: IFTRUE 84373
84359: LD_INT 29
84361: DOUBLE
84362: EQUAL
84363: IFTRUE 84373
84365: LD_INT 30
84367: DOUBLE
84368: EQUAL
84369: IFTRUE 84373
84371: GO 84429
84373: POP
// temp_list = [ fBunker0 , fBunker1 , fBunker2 , fBunker3 , fBunker4 , fBunker5 ] [ dir + 1 ] ; end ;
84374: LD_ADDR_VAR 0 9
84378: PUSH
84379: LD_VAR 0 59
84383: PUSH
84384: LD_VAR 0 60
84388: PUSH
84389: LD_VAR 0 61
84393: PUSH
84394: LD_VAR 0 62
84398: PUSH
84399: LD_VAR 0 63
84403: PUSH
84404: LD_VAR 0 64
84408: PUSH
84409: EMPTY
84410: LIST
84411: LIST
84412: LIST
84413: LIST
84414: LIST
84415: LIST
84416: PUSH
84417: LD_VAR 0 4
84421: PUSH
84422: LD_INT 1
84424: PLUS
84425: ARRAY
84426: ST_TO_ADDR
84427: GO 84430
84429: POP
// temp_list2 = [ ] ;
84430: LD_ADDR_VAR 0 10
84434: PUSH
84435: EMPTY
84436: ST_TO_ADDR
// for i in temp_list do
84437: LD_ADDR_VAR 0 8
84441: PUSH
84442: LD_VAR 0 9
84446: PUSH
84447: FOR_IN
84448: IFFALSE 84500
// temp_list2 = temp_list2 ^ [ [ i [ 1 ] + x , i [ 2 ] + y ] ] ;
84450: LD_ADDR_VAR 0 10
84454: PUSH
84455: LD_VAR 0 10
84459: PUSH
84460: LD_VAR 0 8
84464: PUSH
84465: LD_INT 1
84467: ARRAY
84468: PUSH
84469: LD_VAR 0 2
84473: PLUS
84474: PUSH
84475: LD_VAR 0 8
84479: PUSH
84480: LD_INT 2
84482: ARRAY
84483: PUSH
84484: LD_VAR 0 3
84488: PLUS
84489: PUSH
84490: EMPTY
84491: LIST
84492: LIST
84493: PUSH
84494: EMPTY
84495: LIST
84496: ADD
84497: ST_TO_ADDR
84498: GO 84447
84500: POP
84501: POP
// result = temp_list2 ;
84502: LD_ADDR_VAR 0 7
84506: PUSH
84507: LD_VAR 0 10
84511: ST_TO_ADDR
// end ;
84512: LD_VAR 0 7
84516: RET
// export function EnemyInRange ( unit , dist ) ; begin
84517: LD_INT 0
84519: PPUSH
// result := DangerAtRangeXY ( GetSide ( unit ) , GetX ( unit ) , GetY ( unit ) , dist ) [ 4 ] ;
84520: LD_ADDR_VAR 0 3
84524: PUSH
84525: LD_VAR 0 1
84529: PPUSH
84530: CALL_OW 255
84534: PPUSH
84535: LD_VAR 0 1
84539: PPUSH
84540: CALL_OW 250
84544: PPUSH
84545: LD_VAR 0 1
84549: PPUSH
84550: CALL_OW 251
84554: PPUSH
84555: LD_VAR 0 2
84559: PPUSH
84560: CALL 57913 0 4
84564: PUSH
84565: LD_INT 4
84567: ARRAY
84568: ST_TO_ADDR
// end ;
84569: LD_VAR 0 3
84573: RET
// export function PlayerSeeMe ( unit ) ; begin
84574: LD_INT 0
84576: PPUSH
// result := See ( your_side , unit ) ;
84577: LD_ADDR_VAR 0 2
84581: PUSH
84582: LD_OWVAR 2
84586: PPUSH
84587: LD_VAR 0 1
84591: PPUSH
84592: CALL_OW 292
84596: ST_TO_ADDR
// end ;
84597: LD_VAR 0 2
84601: RET
// export function ReverseDir ( unit ) ; begin
84602: LD_INT 0
84604: PPUSH
// if not unit then
84605: LD_VAR 0 1
84609: NOT
84610: IFFALSE 84614
// exit ;
84612: GO 84637
// result := ( GetDir ( unit ) + 3 ) mod 6 ;
84614: LD_ADDR_VAR 0 2
84618: PUSH
84619: LD_VAR 0 1
84623: PPUSH
84624: CALL_OW 254
84628: PUSH
84629: LD_INT 3
84631: PLUS
84632: PUSH
84633: LD_INT 6
84635: MOD
84636: ST_TO_ADDR
// end ;
84637: LD_VAR 0 2
84641: RET
// export function GetClosestHex ( unit , hexes ) ; var i , dist , tmp , hex ; begin
84642: LD_INT 0
84644: PPUSH
84645: PPUSH
84646: PPUSH
84647: PPUSH
84648: PPUSH
// if not hexes then
84649: LD_VAR 0 2
84653: NOT
84654: IFFALSE 84658
// exit ;
84656: GO 84806
// dist := 9999 ;
84658: LD_ADDR_VAR 0 5
84662: PUSH
84663: LD_INT 9999
84665: ST_TO_ADDR
// for i = 1 to hexes do
84666: LD_ADDR_VAR 0 4
84670: PUSH
84671: DOUBLE
84672: LD_INT 1
84674: DEC
84675: ST_TO_ADDR
84676: LD_VAR 0 2
84680: PUSH
84681: FOR_TO
84682: IFFALSE 84794
// begin if GetDistUnitXY ( unit , hexes [ i ] [ 1 ] , hexes [ i ] [ 2 ] ) < dist then
84684: LD_VAR 0 1
84688: PPUSH
84689: LD_VAR 0 2
84693: PUSH
84694: LD_VAR 0 4
84698: ARRAY
84699: PUSH
84700: LD_INT 1
84702: ARRAY
84703: PPUSH
84704: LD_VAR 0 2
84708: PUSH
84709: LD_VAR 0 4
84713: ARRAY
84714: PUSH
84715: LD_INT 2
84717: ARRAY
84718: PPUSH
84719: CALL_OW 297
84723: PUSH
84724: LD_VAR 0 5
84728: LESS
84729: IFFALSE 84792
// begin hex := hexes [ i ] ;
84731: LD_ADDR_VAR 0 7
84735: PUSH
84736: LD_VAR 0 2
84740: PUSH
84741: LD_VAR 0 4
84745: ARRAY
84746: ST_TO_ADDR
// dist := GetDistUnitXY ( unit , hexes [ i ] [ 1 ] , hexes [ i ] [ 2 ] ) ;
84747: LD_ADDR_VAR 0 5
84751: PUSH
84752: LD_VAR 0 1
84756: PPUSH
84757: LD_VAR 0 2
84761: PUSH
84762: LD_VAR 0 4
84766: ARRAY
84767: PUSH
84768: LD_INT 1
84770: ARRAY
84771: PPUSH
84772: LD_VAR 0 2
84776: PUSH
84777: LD_VAR 0 4
84781: ARRAY
84782: PUSH
84783: LD_INT 2
84785: ARRAY
84786: PPUSH
84787: CALL_OW 297
84791: ST_TO_ADDR
// end ; end ;
84792: GO 84681
84794: POP
84795: POP
// result := hex ;
84796: LD_ADDR_VAR 0 3
84800: PUSH
84801: LD_VAR 0 7
84805: ST_TO_ADDR
// end ;
84806: LD_VAR 0 3
84810: RET
// export function ComAutodestruct ( unit ) ; var i ; begin
84811: LD_INT 0
84813: PPUSH
84814: PPUSH
// if not unit or not unit in FilterAllUnits ( [ [ f_type , unit_vehicle ] , [ f_nation , 2 ] ] ) then
84815: LD_VAR 0 1
84819: NOT
84820: PUSH
84821: LD_VAR 0 1
84825: PUSH
84826: LD_INT 21
84828: PUSH
84829: LD_INT 2
84831: PUSH
84832: EMPTY
84833: LIST
84834: LIST
84835: PUSH
84836: LD_INT 23
84838: PUSH
84839: LD_INT 2
84841: PUSH
84842: EMPTY
84843: LIST
84844: LIST
84845: PUSH
84846: EMPTY
84847: LIST
84848: LIST
84849: PPUSH
84850: CALL_OW 69
84854: IN
84855: NOT
84856: OR
84857: IFFALSE 84861
// exit ;
84859: GO 84908
// for i = 1 to 3 do
84861: LD_ADDR_VAR 0 3
84865: PUSH
84866: DOUBLE
84867: LD_INT 1
84869: DEC
84870: ST_TO_ADDR
84871: LD_INT 3
84873: PUSH
84874: FOR_TO
84875: IFFALSE 84906
// MineExplosion ( GetX ( unit ) , GetY ( unit ) , 1 ) ;
84877: LD_VAR 0 1
84881: PPUSH
84882: CALL_OW 250
84886: PPUSH
84887: LD_VAR 0 1
84891: PPUSH
84892: CALL_OW 251
84896: PPUSH
84897: LD_INT 1
84899: PPUSH
84900: CALL_OW 453
84904: GO 84874
84906: POP
84907: POP
// end ;
84908: LD_VAR 0 2
84912: RET
// export function AttackHovercraft ( unit , enemy_unit ) ; var i , j , tmp , x , y ; begin
84913: LD_INT 0
84915: PPUSH
84916: PPUSH
84917: PPUSH
84918: PPUSH
84919: PPUSH
84920: PPUSH
// if not unit or not enemy_unit or HasTask ( unit ) then
84921: LD_VAR 0 1
84925: NOT
84926: PUSH
84927: LD_VAR 0 2
84931: NOT
84932: OR
84933: PUSH
84934: LD_VAR 0 1
84938: PPUSH
84939: CALL_OW 314
84943: OR
84944: IFFALSE 84948
// exit ;
84946: GO 85389
// x := GetX ( enemy_unit ) ;
84948: LD_ADDR_VAR 0 7
84952: PUSH
84953: LD_VAR 0 2
84957: PPUSH
84958: CALL_OW 250
84962: ST_TO_ADDR
// y := GetY ( enemy_unit ) ;
84963: LD_ADDR_VAR 0 8
84967: PUSH
84968: LD_VAR 0 2
84972: PPUSH
84973: CALL_OW 251
84977: ST_TO_ADDR
// if not x or not y then
84978: LD_VAR 0 7
84982: NOT
84983: PUSH
84984: LD_VAR 0 8
84988: NOT
84989: OR
84990: IFFALSE 84994
// exit ;
84992: GO 85389
// tmp := [ [ ShiftX ( x , 0 , 4 ) , ShiftY ( y , 0 , 4 ) ] , [ ShiftX ( x , 1 , 4 ) , ShiftY ( y , 1 , 4 ) ] , [ ShiftX ( x , 2 , 4 ) , ShiftY ( y , 2 , 4 ) ] , [ ShiftX ( x , 3 , 4 ) , ShiftY ( y , 3 , 4 ) ] , [ ShiftX ( x , 4 , 4 ) , ShiftY ( y , 4 , 4 ) ] , [ ShiftX ( x , 5 , 4 ) , ShiftY ( y , 5 , 4 ) ] ] ;
84994: LD_ADDR_VAR 0 6
84998: PUSH
84999: LD_VAR 0 7
85003: PPUSH
85004: LD_INT 0
85006: PPUSH
85007: LD_INT 4
85009: PPUSH
85010: CALL_OW 272
85014: PUSH
85015: LD_VAR 0 8
85019: PPUSH
85020: LD_INT 0
85022: PPUSH
85023: LD_INT 4
85025: PPUSH
85026: CALL_OW 273
85030: PUSH
85031: EMPTY
85032: LIST
85033: LIST
85034: PUSH
85035: LD_VAR 0 7
85039: PPUSH
85040: LD_INT 1
85042: PPUSH
85043: LD_INT 4
85045: PPUSH
85046: CALL_OW 272
85050: PUSH
85051: LD_VAR 0 8
85055: PPUSH
85056: LD_INT 1
85058: PPUSH
85059: LD_INT 4
85061: PPUSH
85062: CALL_OW 273
85066: PUSH
85067: EMPTY
85068: LIST
85069: LIST
85070: PUSH
85071: LD_VAR 0 7
85075: PPUSH
85076: LD_INT 2
85078: PPUSH
85079: LD_INT 4
85081: PPUSH
85082: CALL_OW 272
85086: PUSH
85087: LD_VAR 0 8
85091: PPUSH
85092: LD_INT 2
85094: PPUSH
85095: LD_INT 4
85097: PPUSH
85098: CALL_OW 273
85102: PUSH
85103: EMPTY
85104: LIST
85105: LIST
85106: PUSH
85107: LD_VAR 0 7
85111: PPUSH
85112: LD_INT 3
85114: PPUSH
85115: LD_INT 4
85117: PPUSH
85118: CALL_OW 272
85122: PUSH
85123: LD_VAR 0 8
85127: PPUSH
85128: LD_INT 3
85130: PPUSH
85131: LD_INT 4
85133: PPUSH
85134: CALL_OW 273
85138: PUSH
85139: EMPTY
85140: LIST
85141: LIST
85142: PUSH
85143: LD_VAR 0 7
85147: PPUSH
85148: LD_INT 4
85150: PPUSH
85151: LD_INT 4
85153: PPUSH
85154: CALL_OW 272
85158: PUSH
85159: LD_VAR 0 8
85163: PPUSH
85164: LD_INT 4
85166: PPUSH
85167: LD_INT 4
85169: PPUSH
85170: CALL_OW 273
85174: PUSH
85175: EMPTY
85176: LIST
85177: LIST
85178: PUSH
85179: LD_VAR 0 7
85183: PPUSH
85184: LD_INT 5
85186: PPUSH
85187: LD_INT 4
85189: PPUSH
85190: CALL_OW 272
85194: PUSH
85195: LD_VAR 0 8
85199: PPUSH
85200: LD_INT 5
85202: PPUSH
85203: LD_INT 4
85205: PPUSH
85206: CALL_OW 273
85210: PUSH
85211: EMPTY
85212: LIST
85213: LIST
85214: PUSH
85215: EMPTY
85216: LIST
85217: LIST
85218: LIST
85219: LIST
85220: LIST
85221: LIST
85222: ST_TO_ADDR
// for i = tmp downto 1 do
85223: LD_ADDR_VAR 0 4
85227: PUSH
85228: DOUBLE
85229: LD_VAR 0 6
85233: INC
85234: ST_TO_ADDR
85235: LD_INT 1
85237: PUSH
85238: FOR_DOWNTO
85239: IFFALSE 85340
// if not ValidHex ( tmp [ i ] [ 1 ] , tmp [ i ] [ 2 ] ) or HexInfo ( tmp [ i ] [ 1 ] , tmp [ i ] [ 2 ] ) <> 0 then
85241: LD_VAR 0 6
85245: PUSH
85246: LD_VAR 0 4
85250: ARRAY
85251: PUSH
85252: LD_INT 1
85254: ARRAY
85255: PPUSH
85256: LD_VAR 0 6
85260: PUSH
85261: LD_VAR 0 4
85265: ARRAY
85266: PUSH
85267: LD_INT 2
85269: ARRAY
85270: PPUSH
85271: CALL_OW 488
85275: NOT
85276: PUSH
85277: LD_VAR 0 6
85281: PUSH
85282: LD_VAR 0 4
85286: ARRAY
85287: PUSH
85288: LD_INT 1
85290: ARRAY
85291: PPUSH
85292: LD_VAR 0 6
85296: PUSH
85297: LD_VAR 0 4
85301: ARRAY
85302: PUSH
85303: LD_INT 2
85305: ARRAY
85306: PPUSH
85307: CALL_OW 428
85311: PUSH
85312: LD_INT 0
85314: NONEQUAL
85315: OR
85316: IFFALSE 85338
// tmp := Delete ( tmp , i ) ;
85318: LD_ADDR_VAR 0 6
85322: PUSH
85323: LD_VAR 0 6
85327: PPUSH
85328: LD_VAR 0 4
85332: PPUSH
85333: CALL_OW 3
85337: ST_TO_ADDR
85338: GO 85238
85340: POP
85341: POP
// j := GetClosestHex ( unit , tmp ) ;
85342: LD_ADDR_VAR 0 5
85346: PUSH
85347: LD_VAR 0 1
85351: PPUSH
85352: LD_VAR 0 6
85356: PPUSH
85357: CALL 84642 0 2
85361: ST_TO_ADDR
// ComMoveXY ( unit , j [ 1 ] , j [ 2 ] ) ;
85362: LD_VAR 0 1
85366: PPUSH
85367: LD_VAR 0 5
85371: PUSH
85372: LD_INT 1
85374: ARRAY
85375: PPUSH
85376: LD_VAR 0 5
85380: PUSH
85381: LD_INT 2
85383: ARRAY
85384: PPUSH
85385: CALL_OW 111
// end ;
85389: LD_VAR 0 3
85393: RET
// export function PrepareNature ( birds , tigers , apemans , enchidnas , horses , mastodonts , fishes , nat_area , wat_area ) ; var i , animal ; begin
85394: LD_INT 0
85396: PPUSH
85397: PPUSH
85398: PPUSH
// uc_side = 0 ;
85399: LD_ADDR_OWVAR 20
85403: PUSH
85404: LD_INT 0
85406: ST_TO_ADDR
// uc_nation = 0 ;
85407: LD_ADDR_OWVAR 21
85411: PUSH
85412: LD_INT 0
85414: ST_TO_ADDR
// InitHc_All ( ) ;
85415: CALL_OW 584
// InitVc ;
85419: CALL_OW 20
// if mastodonts then
85423: LD_VAR 0 6
85427: IFFALSE 85494
// for i = 1 to mastodonts do
85429: LD_ADDR_VAR 0 11
85433: PUSH
85434: DOUBLE
85435: LD_INT 1
85437: DEC
85438: ST_TO_ADDR
85439: LD_VAR 0 6
85443: PUSH
85444: FOR_TO
85445: IFFALSE 85492
// begin vc_chassis := 31 ;
85447: LD_ADDR_OWVAR 37
85451: PUSH
85452: LD_INT 31
85454: ST_TO_ADDR
// vc_control := control_rider ;
85455: LD_ADDR_OWVAR 38
85459: PUSH
85460: LD_INT 4
85462: ST_TO_ADDR
// animal := CreateVehicle ;
85463: LD_ADDR_VAR 0 12
85467: PUSH
85468: CALL_OW 45
85472: ST_TO_ADDR
// PlaceUnitInArea ( animal , nat_area , false ) ;
85473: LD_VAR 0 12
85477: PPUSH
85478: LD_VAR 0 8
85482: PPUSH
85483: LD_INT 0
85485: PPUSH
85486: CALL 87629 0 3
// end ;
85490: GO 85444
85492: POP
85493: POP
// if horses then
85494: LD_VAR 0 5
85498: IFFALSE 85565
// for i = 1 to horses do
85500: LD_ADDR_VAR 0 11
85504: PUSH
85505: DOUBLE
85506: LD_INT 1
85508: DEC
85509: ST_TO_ADDR
85510: LD_VAR 0 5
85514: PUSH
85515: FOR_TO
85516: IFFALSE 85563
// begin hc_class := 21 ;
85518: LD_ADDR_OWVAR 28
85522: PUSH
85523: LD_INT 21
85525: ST_TO_ADDR
// hc_gallery :=  ;
85526: LD_ADDR_OWVAR 33
85530: PUSH
85531: LD_STRING 
85533: ST_TO_ADDR
// animal := CreateHuman ;
85534: LD_ADDR_VAR 0 12
85538: PUSH
85539: CALL_OW 44
85543: ST_TO_ADDR
// PlaceUnitInArea ( animal , nat_area , false ) ;
85544: LD_VAR 0 12
85548: PPUSH
85549: LD_VAR 0 8
85553: PPUSH
85554: LD_INT 0
85556: PPUSH
85557: CALL 87629 0 3
// end ;
85561: GO 85515
85563: POP
85564: POP
// if birds then
85565: LD_VAR 0 1
85569: IFFALSE 85636
// for i = 1 to birds do
85571: LD_ADDR_VAR 0 11
85575: PUSH
85576: DOUBLE
85577: LD_INT 1
85579: DEC
85580: ST_TO_ADDR
85581: LD_VAR 0 1
85585: PUSH
85586: FOR_TO
85587: IFFALSE 85634
// begin hc_class = 18 ;
85589: LD_ADDR_OWVAR 28
85593: PUSH
85594: LD_INT 18
85596: ST_TO_ADDR
// hc_gallery =  ;
85597: LD_ADDR_OWVAR 33
85601: PUSH
85602: LD_STRING 
85604: ST_TO_ADDR
// animal := CreateHuman ;
85605: LD_ADDR_VAR 0 12
85609: PUSH
85610: CALL_OW 44
85614: ST_TO_ADDR
// PlaceUnitInArea ( animal , nat_area , false ) ;
85615: LD_VAR 0 12
85619: PPUSH
85620: LD_VAR 0 8
85624: PPUSH
85625: LD_INT 0
85627: PPUSH
85628: CALL 87629 0 3
// end ;
85632: GO 85586
85634: POP
85635: POP
// if tigers then
85636: LD_VAR 0 2
85640: IFFALSE 85724
// for i = 1 to tigers do
85642: LD_ADDR_VAR 0 11
85646: PUSH
85647: DOUBLE
85648: LD_INT 1
85650: DEC
85651: ST_TO_ADDR
85652: LD_VAR 0 2
85656: PUSH
85657: FOR_TO
85658: IFFALSE 85722
// begin hc_class = class_tiger ;
85660: LD_ADDR_OWVAR 28
85664: PUSH
85665: LD_INT 14
85667: ST_TO_ADDR
// hc_gallery =  ;
85668: LD_ADDR_OWVAR 33
85672: PUSH
85673: LD_STRING 
85675: ST_TO_ADDR
// hc_agressivity = Rand ( - 7 , 7 ) ;
85676: LD_ADDR_OWVAR 35
85680: PUSH
85681: LD_INT 7
85683: NEG
85684: PPUSH
85685: LD_INT 7
85687: PPUSH
85688: CALL_OW 12
85692: ST_TO_ADDR
// animal := CreateHuman ;
85693: LD_ADDR_VAR 0 12
85697: PUSH
85698: CALL_OW 44
85702: ST_TO_ADDR
// PlaceUnitInArea ( animal , nat_area , false ) ;
85703: LD_VAR 0 12
85707: PPUSH
85708: LD_VAR 0 8
85712: PPUSH
85713: LD_INT 0
85715: PPUSH
85716: CALL 87629 0 3
// end ;
85720: GO 85657
85722: POP
85723: POP
// if apemans then
85724: LD_VAR 0 3
85728: IFFALSE 85851
// for i = 1 to apemans do
85730: LD_ADDR_VAR 0 11
85734: PUSH
85735: DOUBLE
85736: LD_INT 1
85738: DEC
85739: ST_TO_ADDR
85740: LD_VAR 0 3
85744: PUSH
85745: FOR_TO
85746: IFFALSE 85849
// begin hc_class = class_apeman ;
85748: LD_ADDR_OWVAR 28
85752: PUSH
85753: LD_INT 12
85755: ST_TO_ADDR
// hc_gallery =  ;
85756: LD_ADDR_OWVAR 33
85760: PUSH
85761: LD_STRING 
85763: ST_TO_ADDR
// hc_agressivity = rand ( - 2 , 2 ) ;
85764: LD_ADDR_OWVAR 35
85768: PUSH
85769: LD_INT 2
85771: NEG
85772: PPUSH
85773: LD_INT 2
85775: PPUSH
85776: CALL_OW 12
85780: ST_TO_ADDR
// hc_skills := [ rand ( 1 , 3 ) , rand ( 1 , 3 ) , 0 , 0 ] ;
85781: LD_ADDR_OWVAR 31
85785: PUSH
85786: LD_INT 1
85788: PPUSH
85789: LD_INT 3
85791: PPUSH
85792: CALL_OW 12
85796: PUSH
85797: LD_INT 1
85799: PPUSH
85800: LD_INT 3
85802: PPUSH
85803: CALL_OW 12
85807: PUSH
85808: LD_INT 0
85810: PUSH
85811: LD_INT 0
85813: PUSH
85814: EMPTY
85815: LIST
85816: LIST
85817: LIST
85818: LIST
85819: ST_TO_ADDR
// animal := CreateHuman ;
85820: LD_ADDR_VAR 0 12
85824: PUSH
85825: CALL_OW 44
85829: ST_TO_ADDR
// PlaceUnitInArea ( animal , nat_area , false ) ;
85830: LD_VAR 0 12
85834: PPUSH
85835: LD_VAR 0 8
85839: PPUSH
85840: LD_INT 0
85842: PPUSH
85843: CALL 87629 0 3
// end ;
85847: GO 85745
85849: POP
85850: POP
// if enchidnas then
85851: LD_VAR 0 4
85855: IFFALSE 85922
// for i = 1 to enchidnas do
85857: LD_ADDR_VAR 0 11
85861: PUSH
85862: DOUBLE
85863: LD_INT 1
85865: DEC
85866: ST_TO_ADDR
85867: LD_VAR 0 4
85871: PUSH
85872: FOR_TO
85873: IFFALSE 85920
// begin hc_class = 13 ;
85875: LD_ADDR_OWVAR 28
85879: PUSH
85880: LD_INT 13
85882: ST_TO_ADDR
// hc_gallery =  ;
85883: LD_ADDR_OWVAR 33
85887: PUSH
85888: LD_STRING 
85890: ST_TO_ADDR
// animal := CreateHuman ;
85891: LD_ADDR_VAR 0 12
85895: PUSH
85896: CALL_OW 44
85900: ST_TO_ADDR
// PlaceUnitInArea ( animal , nat_area , false ) ;
85901: LD_VAR 0 12
85905: PPUSH
85906: LD_VAR 0 8
85910: PPUSH
85911: LD_INT 0
85913: PPUSH
85914: CALL 87629 0 3
// end ;
85918: GO 85872
85920: POP
85921: POP
// if fishes then
85922: LD_VAR 0 7
85926: IFFALSE 85993
// for i = 1 to fishes do
85928: LD_ADDR_VAR 0 11
85932: PUSH
85933: DOUBLE
85934: LD_INT 1
85936: DEC
85937: ST_TO_ADDR
85938: LD_VAR 0 7
85942: PUSH
85943: FOR_TO
85944: IFFALSE 85991
// begin hc_class = 20 ;
85946: LD_ADDR_OWVAR 28
85950: PUSH
85951: LD_INT 20
85953: ST_TO_ADDR
// hc_gallery =  ;
85954: LD_ADDR_OWVAR 33
85958: PUSH
85959: LD_STRING 
85961: ST_TO_ADDR
// animal := CreateHuman ;
85962: LD_ADDR_VAR 0 12
85966: PUSH
85967: CALL_OW 44
85971: ST_TO_ADDR
// PlaceUnitInArea ( animal , wat_area , false ) ;
85972: LD_VAR 0 12
85976: PPUSH
85977: LD_VAR 0 9
85981: PPUSH
85982: LD_INT 0
85984: PPUSH
85985: CALL 87629 0 3
// end ;
85989: GO 85943
85991: POP
85992: POP
// end ;
85993: LD_VAR 0 10
85997: RET
// export function WantHeal ( sci , unit ) ; begin
85998: LD_INT 0
86000: PPUSH
// if GetTaskList ( sci ) > 0 then
86001: LD_VAR 0 1
86005: PPUSH
86006: CALL_OW 437
86010: PUSH
86011: LD_INT 0
86013: GREATER
86014: IFFALSE 86084
// begin if GetTaskList ( sci ) [ 1 ] [ 1 ] = l and GetTaskList ( sci ) [ 1 ] [ 4 ] = unit then
86016: LD_VAR 0 1
86020: PPUSH
86021: CALL_OW 437
86025: PUSH
86026: LD_INT 1
86028: ARRAY
86029: PUSH
86030: LD_INT 1
86032: ARRAY
86033: PUSH
86034: LD_STRING l
86036: EQUAL
86037: PUSH
86038: LD_VAR 0 1
86042: PPUSH
86043: CALL_OW 437
86047: PUSH
86048: LD_INT 1
86050: ARRAY
86051: PUSH
86052: LD_INT 4
86054: ARRAY
86055: PUSH
86056: LD_VAR 0 2
86060: EQUAL
86061: AND
86062: IFFALSE 86074
// result := true else
86064: LD_ADDR_VAR 0 3
86068: PUSH
86069: LD_INT 1
86071: ST_TO_ADDR
86072: GO 86082
// result := false ;
86074: LD_ADDR_VAR 0 3
86078: PUSH
86079: LD_INT 0
86081: ST_TO_ADDR
// end else
86082: GO 86092
// result := false ;
86084: LD_ADDR_VAR 0 3
86088: PUSH
86089: LD_INT 0
86091: ST_TO_ADDR
// end ;
86092: LD_VAR 0 3
86096: RET
// export function HealTarget ( sci ) ; begin
86097: LD_INT 0
86099: PPUSH
// if not sci then
86100: LD_VAR 0 1
86104: NOT
86105: IFFALSE 86109
// exit ;
86107: GO 86174
// result := 0 ;
86109: LD_ADDR_VAR 0 2
86113: PUSH
86114: LD_INT 0
86116: ST_TO_ADDR
// if GetTaskList ( sci ) then
86117: LD_VAR 0 1
86121: PPUSH
86122: CALL_OW 437
86126: IFFALSE 86174
// if GetTaskList ( sci ) [ 1 ] [ 1 ] = l then
86128: LD_VAR 0 1
86132: PPUSH
86133: CALL_OW 437
86137: PUSH
86138: LD_INT 1
86140: ARRAY
86141: PUSH
86142: LD_INT 1
86144: ARRAY
86145: PUSH
86146: LD_STRING l
86148: EQUAL
86149: IFFALSE 86174
// result := GetTaskList ( sci ) [ 1 ] [ 4 ] ;
86151: LD_ADDR_VAR 0 2
86155: PUSH
86156: LD_VAR 0 1
86160: PPUSH
86161: CALL_OW 437
86165: PUSH
86166: LD_INT 1
86168: ARRAY
86169: PUSH
86170: LD_INT 4
86172: ARRAY
86173: ST_TO_ADDR
// end ;
86174: LD_VAR 0 2
86178: RET
// export function _ScanBase ( base_units ) ; var i , t , tmp ; begin
86179: LD_INT 0
86181: PPUSH
86182: PPUSH
86183: PPUSH
86184: PPUSH
// if not base_units then
86185: LD_VAR 0 1
86189: NOT
86190: IFFALSE 86194
// exit ;
86192: GO 86281
// result := false ;
86194: LD_ADDR_VAR 0 2
86198: PUSH
86199: LD_INT 0
86201: ST_TO_ADDR
// tmp := UnitFilter ( base_units , [ f_type , unit_building ] ) ;
86202: LD_ADDR_VAR 0 5
86206: PUSH
86207: LD_VAR 0 1
86211: PPUSH
86212: LD_INT 21
86214: PUSH
86215: LD_INT 3
86217: PUSH
86218: EMPTY
86219: LIST
86220: LIST
86221: PPUSH
86222: CALL_OW 72
86226: ST_TO_ADDR
// if not tmp then
86227: LD_VAR 0 5
86231: NOT
86232: IFFALSE 86236
// exit ;
86234: GO 86281
// for i in tmp do
86236: LD_ADDR_VAR 0 3
86240: PUSH
86241: LD_VAR 0 5
86245: PUSH
86246: FOR_IN
86247: IFFALSE 86279
// begin result := EnemyInRange ( i , 22 ) ;
86249: LD_ADDR_VAR 0 2
86253: PUSH
86254: LD_VAR 0 3
86258: PPUSH
86259: LD_INT 22
86261: PPUSH
86262: CALL 84517 0 2
86266: ST_TO_ADDR
// if result then
86267: LD_VAR 0 2
86271: IFFALSE 86277
// exit ;
86273: POP
86274: POP
86275: GO 86281
// end ;
86277: GO 86246
86279: POP
86280: POP
// end ;
86281: LD_VAR 0 2
86285: RET
// export function FilterByTag ( units , tag ) ; begin
86286: LD_INT 0
86288: PPUSH
// result := UnitFilter ( units , [ f_tag , tag ] ) ;
86289: LD_ADDR_VAR 0 3
86293: PUSH
86294: LD_VAR 0 1
86298: PPUSH
86299: LD_INT 120
86301: PUSH
86302: LD_VAR 0 2
86306: PUSH
86307: EMPTY
86308: LIST
86309: LIST
86310: PPUSH
86311: CALL_OW 72
86315: ST_TO_ADDR
// end ;
86316: LD_VAR 0 3
86320: RET
// export function IsDriver ( un ) ; begin
86321: LD_INT 0
86323: PPUSH
// result := un in FilterAllUnits ( [ f_driving ] ) ;
86324: LD_ADDR_VAR 0 2
86328: PUSH
86329: LD_VAR 0 1
86333: PUSH
86334: LD_INT 55
86336: PUSH
86337: EMPTY
86338: LIST
86339: PPUSH
86340: CALL_OW 69
86344: IN
86345: ST_TO_ADDR
// end ;
86346: LD_VAR 0 2
86350: RET
// export function GetFacExtXYD ( x , y , d ) ; var list ; begin
86351: LD_INT 0
86353: PPUSH
86354: PPUSH
// list := [ ] ;
86355: LD_ADDR_VAR 0 5
86359: PUSH
86360: EMPTY
86361: ST_TO_ADDR
// case d of 0 :
86362: LD_VAR 0 3
86366: PUSH
86367: LD_INT 0
86369: DOUBLE
86370: EQUAL
86371: IFTRUE 86375
86373: GO 86508
86375: POP
// begin list := [ [ x - 4 , y - 4 , 2 ] , [ x - 3 , y , 1 ] , [ x + 4 , y , 4 ] , [ x + 3 , y + 3 , 5 ] , [ x , y + 4 , 0 ] ] ;
86376: LD_ADDR_VAR 0 5
86380: PUSH
86381: LD_VAR 0 1
86385: PUSH
86386: LD_INT 4
86388: MINUS
86389: PUSH
86390: LD_VAR 0 2
86394: PUSH
86395: LD_INT 4
86397: MINUS
86398: PUSH
86399: LD_INT 2
86401: PUSH
86402: EMPTY
86403: LIST
86404: LIST
86405: LIST
86406: PUSH
86407: LD_VAR 0 1
86411: PUSH
86412: LD_INT 3
86414: MINUS
86415: PUSH
86416: LD_VAR 0 2
86420: PUSH
86421: LD_INT 1
86423: PUSH
86424: EMPTY
86425: LIST
86426: LIST
86427: LIST
86428: PUSH
86429: LD_VAR 0 1
86433: PUSH
86434: LD_INT 4
86436: PLUS
86437: PUSH
86438: LD_VAR 0 2
86442: PUSH
86443: LD_INT 4
86445: PUSH
86446: EMPTY
86447: LIST
86448: LIST
86449: LIST
86450: PUSH
86451: LD_VAR 0 1
86455: PUSH
86456: LD_INT 3
86458: PLUS
86459: PUSH
86460: LD_VAR 0 2
86464: PUSH
86465: LD_INT 3
86467: PLUS
86468: PUSH
86469: LD_INT 5
86471: PUSH
86472: EMPTY
86473: LIST
86474: LIST
86475: LIST
86476: PUSH
86477: LD_VAR 0 1
86481: PUSH
86482: LD_VAR 0 2
86486: PUSH
86487: LD_INT 4
86489: PLUS
86490: PUSH
86491: LD_INT 0
86493: PUSH
86494: EMPTY
86495: LIST
86496: LIST
86497: LIST
86498: PUSH
86499: EMPTY
86500: LIST
86501: LIST
86502: LIST
86503: LIST
86504: LIST
86505: ST_TO_ADDR
// end ; 1 :
86506: GO 87206
86508: LD_INT 1
86510: DOUBLE
86511: EQUAL
86512: IFTRUE 86516
86514: GO 86649
86516: POP
// begin list := [ [ x , y - 4 , 3 ] , [ x - 3 , y - 3 , 2 ] , [ x - 4 , y , 1 ] , [ x , y + 3 , 0 ] , [ x + 4 , y + 4 , 5 ] ] ;
86517: LD_ADDR_VAR 0 5
86521: PUSH
86522: LD_VAR 0 1
86526: PUSH
86527: LD_VAR 0 2
86531: PUSH
86532: LD_INT 4
86534: MINUS
86535: PUSH
86536: LD_INT 3
86538: PUSH
86539: EMPTY
86540: LIST
86541: LIST
86542: LIST
86543: PUSH
86544: LD_VAR 0 1
86548: PUSH
86549: LD_INT 3
86551: MINUS
86552: PUSH
86553: LD_VAR 0 2
86557: PUSH
86558: LD_INT 3
86560: MINUS
86561: PUSH
86562: LD_INT 2
86564: PUSH
86565: EMPTY
86566: LIST
86567: LIST
86568: LIST
86569: PUSH
86570: LD_VAR 0 1
86574: PUSH
86575: LD_INT 4
86577: MINUS
86578: PUSH
86579: LD_VAR 0 2
86583: PUSH
86584: LD_INT 1
86586: PUSH
86587: EMPTY
86588: LIST
86589: LIST
86590: LIST
86591: PUSH
86592: LD_VAR 0 1
86596: PUSH
86597: LD_VAR 0 2
86601: PUSH
86602: LD_INT 3
86604: PLUS
86605: PUSH
86606: LD_INT 0
86608: PUSH
86609: EMPTY
86610: LIST
86611: LIST
86612: LIST
86613: PUSH
86614: LD_VAR 0 1
86618: PUSH
86619: LD_INT 4
86621: PLUS
86622: PUSH
86623: LD_VAR 0 2
86627: PUSH
86628: LD_INT 4
86630: PLUS
86631: PUSH
86632: LD_INT 5
86634: PUSH
86635: EMPTY
86636: LIST
86637: LIST
86638: LIST
86639: PUSH
86640: EMPTY
86641: LIST
86642: LIST
86643: LIST
86644: LIST
86645: LIST
86646: ST_TO_ADDR
// end ; 2 :
86647: GO 87206
86649: LD_INT 2
86651: DOUBLE
86652: EQUAL
86653: IFTRUE 86657
86655: GO 86786
86657: POP
// begin list := [ [ x , y - 3 , 3 ] , [ x + 4 , y , 4 ] , [ x , y + 4 , 0 ] , [ x - 3 , y , 1 ] , [ x - 4 , y - 4 , 2 ] ] ;
86658: LD_ADDR_VAR 0 5
86662: PUSH
86663: LD_VAR 0 1
86667: PUSH
86668: LD_VAR 0 2
86672: PUSH
86673: LD_INT 3
86675: MINUS
86676: PUSH
86677: LD_INT 3
86679: PUSH
86680: EMPTY
86681: LIST
86682: LIST
86683: LIST
86684: PUSH
86685: LD_VAR 0 1
86689: PUSH
86690: LD_INT 4
86692: PLUS
86693: PUSH
86694: LD_VAR 0 2
86698: PUSH
86699: LD_INT 4
86701: PUSH
86702: EMPTY
86703: LIST
86704: LIST
86705: LIST
86706: PUSH
86707: LD_VAR 0 1
86711: PUSH
86712: LD_VAR 0 2
86716: PUSH
86717: LD_INT 4
86719: PLUS
86720: PUSH
86721: LD_INT 0
86723: PUSH
86724: EMPTY
86725: LIST
86726: LIST
86727: LIST
86728: PUSH
86729: LD_VAR 0 1
86733: PUSH
86734: LD_INT 3
86736: MINUS
86737: PUSH
86738: LD_VAR 0 2
86742: PUSH
86743: LD_INT 1
86745: PUSH
86746: EMPTY
86747: LIST
86748: LIST
86749: LIST
86750: PUSH
86751: LD_VAR 0 1
86755: PUSH
86756: LD_INT 4
86758: MINUS
86759: PUSH
86760: LD_VAR 0 2
86764: PUSH
86765: LD_INT 4
86767: MINUS
86768: PUSH
86769: LD_INT 2
86771: PUSH
86772: EMPTY
86773: LIST
86774: LIST
86775: LIST
86776: PUSH
86777: EMPTY
86778: LIST
86779: LIST
86780: LIST
86781: LIST
86782: LIST
86783: ST_TO_ADDR
// end ; 3 :
86784: GO 87206
86786: LD_INT 3
86788: DOUBLE
86789: EQUAL
86790: IFTRUE 86794
86792: GO 86927
86794: POP
// begin list := [ [ x + 3 , y , 4 ] , [ x + 4 , y + 4 , 5 ] , [ x - 4 , y , 1 ] , [ x , y - 4 , 3 ] , [ x - 3 , y - 3 , 2 ] ] ;
86795: LD_ADDR_VAR 0 5
86799: PUSH
86800: LD_VAR 0 1
86804: PUSH
86805: LD_INT 3
86807: PLUS
86808: PUSH
86809: LD_VAR 0 2
86813: PUSH
86814: LD_INT 4
86816: PUSH
86817: EMPTY
86818: LIST
86819: LIST
86820: LIST
86821: PUSH
86822: LD_VAR 0 1
86826: PUSH
86827: LD_INT 4
86829: PLUS
86830: PUSH
86831: LD_VAR 0 2
86835: PUSH
86836: LD_INT 4
86838: PLUS
86839: PUSH
86840: LD_INT 5
86842: PUSH
86843: EMPTY
86844: LIST
86845: LIST
86846: LIST
86847: PUSH
86848: LD_VAR 0 1
86852: PUSH
86853: LD_INT 4
86855: MINUS
86856: PUSH
86857: LD_VAR 0 2
86861: PUSH
86862: LD_INT 1
86864: PUSH
86865: EMPTY
86866: LIST
86867: LIST
86868: LIST
86869: PUSH
86870: LD_VAR 0 1
86874: PUSH
86875: LD_VAR 0 2
86879: PUSH
86880: LD_INT 4
86882: MINUS
86883: PUSH
86884: LD_INT 3
86886: PUSH
86887: EMPTY
86888: LIST
86889: LIST
86890: LIST
86891: PUSH
86892: LD_VAR 0 1
86896: PUSH
86897: LD_INT 3
86899: MINUS
86900: PUSH
86901: LD_VAR 0 2
86905: PUSH
86906: LD_INT 3
86908: MINUS
86909: PUSH
86910: LD_INT 2
86912: PUSH
86913: EMPTY
86914: LIST
86915: LIST
86916: LIST
86917: PUSH
86918: EMPTY
86919: LIST
86920: LIST
86921: LIST
86922: LIST
86923: LIST
86924: ST_TO_ADDR
// end ; 4 :
86925: GO 87206
86927: LD_INT 4
86929: DOUBLE
86930: EQUAL
86931: IFTRUE 86935
86933: GO 87068
86935: POP
// begin list := [ [ x , y + 4 , 0 ] , [ x + 3 , y + 3 , 5 ] , [ x + 4 , y , 4 ] , [ x , y - 3 , 3 ] , [ x - 4 , y - 4 , 2 ] ] ;
86936: LD_ADDR_VAR 0 5
86940: PUSH
86941: LD_VAR 0 1
86945: PUSH
86946: LD_VAR 0 2
86950: PUSH
86951: LD_INT 4
86953: PLUS
86954: PUSH
86955: LD_INT 0
86957: PUSH
86958: EMPTY
86959: LIST
86960: LIST
86961: LIST
86962: PUSH
86963: LD_VAR 0 1
86967: PUSH
86968: LD_INT 3
86970: PLUS
86971: PUSH
86972: LD_VAR 0 2
86976: PUSH
86977: LD_INT 3
86979: PLUS
86980: PUSH
86981: LD_INT 5
86983: PUSH
86984: EMPTY
86985: LIST
86986: LIST
86987: LIST
86988: PUSH
86989: LD_VAR 0 1
86993: PUSH
86994: LD_INT 4
86996: PLUS
86997: PUSH
86998: LD_VAR 0 2
87002: PUSH
87003: LD_INT 4
87005: PUSH
87006: EMPTY
87007: LIST
87008: LIST
87009: LIST
87010: PUSH
87011: LD_VAR 0 1
87015: PUSH
87016: LD_VAR 0 2
87020: PUSH
87021: LD_INT 3
87023: MINUS
87024: PUSH
87025: LD_INT 3
87027: PUSH
87028: EMPTY
87029: LIST
87030: LIST
87031: LIST
87032: PUSH
87033: LD_VAR 0 1
87037: PUSH
87038: LD_INT 4
87040: MINUS
87041: PUSH
87042: LD_VAR 0 2
87046: PUSH
87047: LD_INT 4
87049: MINUS
87050: PUSH
87051: LD_INT 2
87053: PUSH
87054: EMPTY
87055: LIST
87056: LIST
87057: LIST
87058: PUSH
87059: EMPTY
87060: LIST
87061: LIST
87062: LIST
87063: LIST
87064: LIST
87065: ST_TO_ADDR
// end ; 5 :
87066: GO 87206
87068: LD_INT 5
87070: DOUBLE
87071: EQUAL
87072: IFTRUE 87076
87074: GO 87205
87076: POP
// begin list := [ [ x - 4 , y , 1 ] , [ x , y - 4 , 3 ] , [ x + 4 , y + 4 , 5 ] , [ x + 3 , y , 4 ] , [ x , y + 3 , 0 ] ] ;
87077: LD_ADDR_VAR 0 5
87081: PUSH
87082: LD_VAR 0 1
87086: PUSH
87087: LD_INT 4
87089: MINUS
87090: PUSH
87091: LD_VAR 0 2
87095: PUSH
87096: LD_INT 1
87098: PUSH
87099: EMPTY
87100: LIST
87101: LIST
87102: LIST
87103: PUSH
87104: LD_VAR 0 1
87108: PUSH
87109: LD_VAR 0 2
87113: PUSH
87114: LD_INT 4
87116: MINUS
87117: PUSH
87118: LD_INT 3
87120: PUSH
87121: EMPTY
87122: LIST
87123: LIST
87124: LIST
87125: PUSH
87126: LD_VAR 0 1
87130: PUSH
87131: LD_INT 4
87133: PLUS
87134: PUSH
87135: LD_VAR 0 2
87139: PUSH
87140: LD_INT 4
87142: PLUS
87143: PUSH
87144: LD_INT 5
87146: PUSH
87147: EMPTY
87148: LIST
87149: LIST
87150: LIST
87151: PUSH
87152: LD_VAR 0 1
87156: PUSH
87157: LD_INT 3
87159: PLUS
87160: PUSH
87161: LD_VAR 0 2
87165: PUSH
87166: LD_INT 4
87168: PUSH
87169: EMPTY
87170: LIST
87171: LIST
87172: LIST
87173: PUSH
87174: LD_VAR 0 1
87178: PUSH
87179: LD_VAR 0 2
87183: PUSH
87184: LD_INT 3
87186: PLUS
87187: PUSH
87188: LD_INT 0
87190: PUSH
87191: EMPTY
87192: LIST
87193: LIST
87194: LIST
87195: PUSH
87196: EMPTY
87197: LIST
87198: LIST
87199: LIST
87200: LIST
87201: LIST
87202: ST_TO_ADDR
// end ; end ;
87203: GO 87206
87205: POP
// result := list ;
87206: LD_ADDR_VAR 0 4
87210: PUSH
87211: LD_VAR 0 5
87215: ST_TO_ADDR
// end ;
87216: LD_VAR 0 4
87220: RET
// export function SortBySkill ( units , class ) ; var i , tmp ; begin
87221: LD_INT 0
87223: PPUSH
87224: PPUSH
87225: PPUSH
// if not units or not class in [ 1 , 2 , 3 , 4 ] then
87226: LD_VAR 0 1
87230: NOT
87231: PUSH
87232: LD_VAR 0 2
87236: PUSH
87237: LD_INT 1
87239: PUSH
87240: LD_INT 2
87242: PUSH
87243: LD_INT 3
87245: PUSH
87246: LD_INT 4
87248: PUSH
87249: EMPTY
87250: LIST
87251: LIST
87252: LIST
87253: LIST
87254: IN
87255: NOT
87256: OR
87257: IFFALSE 87261
// exit ;
87259: GO 87353
// tmp := [ ] ;
87261: LD_ADDR_VAR 0 5
87265: PUSH
87266: EMPTY
87267: ST_TO_ADDR
// for i in units do
87268: LD_ADDR_VAR 0 4
87272: PUSH
87273: LD_VAR 0 1
87277: PUSH
87278: FOR_IN
87279: IFFALSE 87322
// tmp := Insert ( tmp , tmp + 1 , GetSkill ( i , class ) ) ;
87281: LD_ADDR_VAR 0 5
87285: PUSH
87286: LD_VAR 0 5
87290: PPUSH
87291: LD_VAR 0 5
87295: PUSH
87296: LD_INT 1
87298: PLUS
87299: PPUSH
87300: LD_VAR 0 4
87304: PPUSH
87305: LD_VAR 0 2
87309: PPUSH
87310: CALL_OW 259
87314: PPUSH
87315: CALL_OW 2
87319: ST_TO_ADDR
87320: GO 87278
87322: POP
87323: POP
// if not tmp then
87324: LD_VAR 0 5
87328: NOT
87329: IFFALSE 87333
// exit ;
87331: GO 87353
// result := SortListByListDesc ( units , tmp ) ;
87333: LD_ADDR_VAR 0 3
87337: PUSH
87338: LD_VAR 0 1
87342: PPUSH
87343: LD_VAR 0 5
87347: PPUSH
87348: CALL_OW 77
87352: ST_TO_ADDR
// end ;
87353: LD_VAR 0 3
87357: RET
// export function UnitGoingToBuilding ( unit , building ) ; var x , y ; begin
87358: LD_INT 0
87360: PPUSH
87361: PPUSH
87362: PPUSH
// result := false ;
87363: LD_ADDR_VAR 0 3
87367: PUSH
87368: LD_INT 0
87370: ST_TO_ADDR
// x := GetX ( building ) ;
87371: LD_ADDR_VAR 0 4
87375: PUSH
87376: LD_VAR 0 2
87380: PPUSH
87381: CALL_OW 250
87385: ST_TO_ADDR
// y := GetY ( building ) ;
87386: LD_ADDR_VAR 0 5
87390: PUSH
87391: LD_VAR 0 2
87395: PPUSH
87396: CALL_OW 251
87400: ST_TO_ADDR
// if not building or not x or not y then
87401: LD_VAR 0 2
87405: NOT
87406: PUSH
87407: LD_VAR 0 4
87411: NOT
87412: OR
87413: PUSH
87414: LD_VAR 0 5
87418: NOT
87419: OR
87420: IFFALSE 87424
// exit ;
87422: GO 87516
// if GetTaskList ( unit ) then
87424: LD_VAR 0 1
87428: PPUSH
87429: CALL_OW 437
87433: IFFALSE 87516
// begin if e = GetTaskList ( unit ) [ 1 ] [ 1 ] and x = GetTaskList ( unit ) [ 1 ] [ 2 ] and y = GetTaskList ( unit ) [ 1 ] [ 3 ] then
87435: LD_STRING e
87437: PUSH
87438: LD_VAR 0 1
87442: PPUSH
87443: CALL_OW 437
87447: PUSH
87448: LD_INT 1
87450: ARRAY
87451: PUSH
87452: LD_INT 1
87454: ARRAY
87455: EQUAL
87456: PUSH
87457: LD_VAR 0 4
87461: PUSH
87462: LD_VAR 0 1
87466: PPUSH
87467: CALL_OW 437
87471: PUSH
87472: LD_INT 1
87474: ARRAY
87475: PUSH
87476: LD_INT 2
87478: ARRAY
87479: EQUAL
87480: AND
87481: PUSH
87482: LD_VAR 0 5
87486: PUSH
87487: LD_VAR 0 1
87491: PPUSH
87492: CALL_OW 437
87496: PUSH
87497: LD_INT 1
87499: ARRAY
87500: PUSH
87501: LD_INT 3
87503: ARRAY
87504: EQUAL
87505: AND
87506: IFFALSE 87516
// result := true end ;
87508: LD_ADDR_VAR 0 3
87512: PUSH
87513: LD_INT 1
87515: ST_TO_ADDR
// end ;
87516: LD_VAR 0 3
87520: RET
// export function UnitGoingToXY ( unit , x , y ) ; begin
87521: LD_INT 0
87523: PPUSH
// result := false ;
87524: LD_ADDR_VAR 0 4
87528: PUSH
87529: LD_INT 0
87531: ST_TO_ADDR
// if GetTaskList ( unit ) then
87532: LD_VAR 0 1
87536: PPUSH
87537: CALL_OW 437
87541: IFFALSE 87624
// begin if M = GetTaskList ( unit ) [ 1 ] [ 1 ] and x = GetTaskList ( unit ) [ 1 ] [ 2 ] and y = GetTaskList ( unit ) [ 1 ] [ 3 ] then
87543: LD_STRING M
87545: PUSH
87546: LD_VAR 0 1
87550: PPUSH
87551: CALL_OW 437
87555: PUSH
87556: LD_INT 1
87558: ARRAY
87559: PUSH
87560: LD_INT 1
87562: ARRAY
87563: EQUAL
87564: PUSH
87565: LD_VAR 0 2
87569: PUSH
87570: LD_VAR 0 1
87574: PPUSH
87575: CALL_OW 437
87579: PUSH
87580: LD_INT 1
87582: ARRAY
87583: PUSH
87584: LD_INT 2
87586: ARRAY
87587: EQUAL
87588: AND
87589: PUSH
87590: LD_VAR 0 3
87594: PUSH
87595: LD_VAR 0 1
87599: PPUSH
87600: CALL_OW 437
87604: PUSH
87605: LD_INT 1
87607: ARRAY
87608: PUSH
87609: LD_INT 3
87611: ARRAY
87612: EQUAL
87613: AND
87614: IFFALSE 87624
// result := true ;
87616: LD_ADDR_VAR 0 4
87620: PUSH
87621: LD_INT 1
87623: ST_TO_ADDR
// end ; end ;
87624: LD_VAR 0 4
87628: RET
// export function PlaceUnitInArea ( unit , area , mode ) ; var i , tmp , hex ; begin
87629: LD_INT 0
87631: PPUSH
87632: PPUSH
87633: PPUSH
87634: PPUSH
// if not unit or not area then
87635: LD_VAR 0 1
87639: NOT
87640: PUSH
87641: LD_VAR 0 2
87645: NOT
87646: OR
87647: IFFALSE 87651
// exit ;
87649: GO 87815
// tmp := AreaToList ( area , i ) ;
87651: LD_ADDR_VAR 0 6
87655: PUSH
87656: LD_VAR 0 2
87660: PPUSH
87661: LD_VAR 0 5
87665: PPUSH
87666: CALL_OW 517
87670: ST_TO_ADDR
// for i = 1 to tmp [ 1 ] do
87671: LD_ADDR_VAR 0 5
87675: PUSH
87676: DOUBLE
87677: LD_INT 1
87679: DEC
87680: ST_TO_ADDR
87681: LD_VAR 0 6
87685: PUSH
87686: LD_INT 1
87688: ARRAY
87689: PUSH
87690: FOR_TO
87691: IFFALSE 87813
// begin hex := [ tmp [ 1 ] [ i ] , tmp [ 2 ] [ i ] ] ;
87693: LD_ADDR_VAR 0 7
87697: PUSH
87698: LD_VAR 0 6
87702: PUSH
87703: LD_INT 1
87705: ARRAY
87706: PUSH
87707: LD_VAR 0 5
87711: ARRAY
87712: PUSH
87713: LD_VAR 0 6
87717: PUSH
87718: LD_INT 2
87720: ARRAY
87721: PUSH
87722: LD_VAR 0 5
87726: ARRAY
87727: PUSH
87728: EMPTY
87729: LIST
87730: LIST
87731: ST_TO_ADDR
// if HexInfo ( hex [ 1 ] , hex [ 2 ] ) = 0 then
87732: LD_VAR 0 7
87736: PUSH
87737: LD_INT 1
87739: ARRAY
87740: PPUSH
87741: LD_VAR 0 7
87745: PUSH
87746: LD_INT 2
87748: ARRAY
87749: PPUSH
87750: CALL_OW 428
87754: PUSH
87755: LD_INT 0
87757: EQUAL
87758: IFFALSE 87811
// begin PlaceUnitXY ( unit , hex [ 1 ] , hex [ 2 ] , mode ) ;
87760: LD_VAR 0 1
87764: PPUSH
87765: LD_VAR 0 7
87769: PUSH
87770: LD_INT 1
87772: ARRAY
87773: PPUSH
87774: LD_VAR 0 7
87778: PUSH
87779: LD_INT 2
87781: ARRAY
87782: PPUSH
87783: LD_VAR 0 3
87787: PPUSH
87788: CALL_OW 48
// result := IsPlaced ( unit ) ;
87792: LD_ADDR_VAR 0 4
87796: PUSH
87797: LD_VAR 0 1
87801: PPUSH
87802: CALL_OW 305
87806: ST_TO_ADDR
// exit ;
87807: POP
87808: POP
87809: GO 87815
// end ; end ;
87811: GO 87690
87813: POP
87814: POP
// end ;
87815: LD_VAR 0 4
87819: RET
// export function BuildingsListDump ( side ) ; var i , tmp ; begin
87820: LD_INT 0
87822: PPUSH
87823: PPUSH
87824: PPUSH
// if not side or side > 8 then
87825: LD_VAR 0 1
87829: NOT
87830: PUSH
87831: LD_VAR 0 1
87835: PUSH
87836: LD_INT 8
87838: GREATER
87839: OR
87840: IFFALSE 87844
// exit ;
87842: GO 88031
// tmp := FilterAllUnits ( [ [ f_side , side ] , [ f_type , unit_building ] ] ) ;
87844: LD_ADDR_VAR 0 4
87848: PUSH
87849: LD_INT 22
87851: PUSH
87852: LD_VAR 0 1
87856: PUSH
87857: EMPTY
87858: LIST
87859: LIST
87860: PUSH
87861: LD_INT 21
87863: PUSH
87864: LD_INT 3
87866: PUSH
87867: EMPTY
87868: LIST
87869: LIST
87870: PUSH
87871: EMPTY
87872: LIST
87873: LIST
87874: PPUSH
87875: CALL_OW 69
87879: ST_TO_ADDR
// if not tmp then
87880: LD_VAR 0 4
87884: NOT
87885: IFFALSE 87889
// exit ;
87887: GO 88031
// enable_addtolog := true ;
87889: LD_ADDR_OWVAR 81
87893: PUSH
87894: LD_INT 1
87896: ST_TO_ADDR
// AddToLog ( [ ) ;
87897: LD_STRING [
87899: PPUSH
87900: CALL_OW 561
// for i in tmp do
87904: LD_ADDR_VAR 0 3
87908: PUSH
87909: LD_VAR 0 4
87913: PUSH
87914: FOR_IN
87915: IFFALSE 88022
// begin AddToLog ( [ & GetBType ( i ) & ,  & GetX ( i ) & ,  & GetY ( i ) & ,  & GetDir ( i ) & ,  & GetLabKind ( i , 1 ) & ,  & GetLabKind ( i , 2 ) & ], ) ;
87917: LD_STRING [
87919: PUSH
87920: LD_VAR 0 3
87924: PPUSH
87925: CALL_OW 266
87929: STR
87930: PUSH
87931: LD_STRING , 
87933: STR
87934: PUSH
87935: LD_VAR 0 3
87939: PPUSH
87940: CALL_OW 250
87944: STR
87945: PUSH
87946: LD_STRING , 
87948: STR
87949: PUSH
87950: LD_VAR 0 3
87954: PPUSH
87955: CALL_OW 251
87959: STR
87960: PUSH
87961: LD_STRING , 
87963: STR
87964: PUSH
87965: LD_VAR 0 3
87969: PPUSH
87970: CALL_OW 254
87974: STR
87975: PUSH
87976: LD_STRING , 
87978: STR
87979: PUSH
87980: LD_VAR 0 3
87984: PPUSH
87985: LD_INT 1
87987: PPUSH
87988: CALL_OW 268
87992: STR
87993: PUSH
87994: LD_STRING , 
87996: STR
87997: PUSH
87998: LD_VAR 0 3
88002: PPUSH
88003: LD_INT 2
88005: PPUSH
88006: CALL_OW 268
88010: STR
88011: PUSH
88012: LD_STRING ],
88014: STR
88015: PPUSH
88016: CALL_OW 561
// end ;
88020: GO 87914
88022: POP
88023: POP
// AddToLog ( ]; ) ;
88024: LD_STRING ];
88026: PPUSH
88027: CALL_OW 561
// end ;
88031: LD_VAR 0 2
88035: RET
// export function Crates ( area , rate , min , max ) ; var i , r , time , amount ; begin
88036: LD_INT 0
88038: PPUSH
88039: PPUSH
88040: PPUSH
88041: PPUSH
88042: PPUSH
// if not area or not rate or not max then
88043: LD_VAR 0 1
88047: NOT
88048: PUSH
88049: LD_VAR 0 2
88053: NOT
88054: OR
88055: PUSH
88056: LD_VAR 0 4
88060: NOT
88061: OR
88062: IFFALSE 88066
// exit ;
88064: GO 88255
// while 1 do
88066: LD_INT 1
88068: IFFALSE 88255
// begin amount := GetResourceArea ( area , mat_cans ) * 10 ;
88070: LD_ADDR_VAR 0 9
88074: PUSH
88075: LD_VAR 0 1
88079: PPUSH
88080: LD_INT 1
88082: PPUSH
88083: CALL_OW 287
88087: PUSH
88088: LD_INT 10
88090: MUL
88091: ST_TO_ADDR
// r := rate / 10 ;
88092: LD_ADDR_VAR 0 7
88096: PUSH
88097: LD_VAR 0 2
88101: PUSH
88102: LD_INT 10
88104: DIVREAL
88105: ST_TO_ADDR
// time := 1 1$00 ;
88106: LD_ADDR_VAR 0 8
88110: PUSH
88111: LD_INT 2100
88113: ST_TO_ADDR
// if amount < min then
88114: LD_VAR 0 9
88118: PUSH
88119: LD_VAR 0 3
88123: LESS
88124: IFFALSE 88142
// r := r * 2 else
88126: LD_ADDR_VAR 0 7
88130: PUSH
88131: LD_VAR 0 7
88135: PUSH
88136: LD_INT 2
88138: MUL
88139: ST_TO_ADDR
88140: GO 88168
// if amount > max then
88142: LD_VAR 0 9
88146: PUSH
88147: LD_VAR 0 4
88151: GREATER
88152: IFFALSE 88168
// r := r / 2 ;
88154: LD_ADDR_VAR 0 7
88158: PUSH
88159: LD_VAR 0 7
88163: PUSH
88164: LD_INT 2
88166: DIVREAL
88167: ST_TO_ADDR
// time := time / r ;
88168: LD_ADDR_VAR 0 8
88172: PUSH
88173: LD_VAR 0 8
88177: PUSH
88178: LD_VAR 0 7
88182: DIVREAL
88183: ST_TO_ADDR
// if time < 0 then
88184: LD_VAR 0 8
88188: PUSH
88189: LD_INT 0
88191: LESS
88192: IFFALSE 88209
// time := time * - 1 ;
88194: LD_ADDR_VAR 0 8
88198: PUSH
88199: LD_VAR 0 8
88203: PUSH
88204: LD_INT 1
88206: NEG
88207: MUL
88208: ST_TO_ADDR
// wait ( time + rand ( 0 0$01 , 0 0$25 ) ) ;
88209: LD_VAR 0 8
88213: PUSH
88214: LD_INT 35
88216: PPUSH
88217: LD_INT 875
88219: PPUSH
88220: CALL_OW 12
88224: PLUS
88225: PPUSH
88226: CALL_OW 67
// CreateCratesArea ( rand ( 1 , 5 ) , area , true ) ;
88230: LD_INT 1
88232: PPUSH
88233: LD_INT 5
88235: PPUSH
88236: CALL_OW 12
88240: PPUSH
88241: LD_VAR 0 1
88245: PPUSH
88246: LD_INT 1
88248: PPUSH
88249: CALL_OW 55
// end ;
88253: GO 88066
// end ;
88255: LD_VAR 0 5
88259: RET
// export function UpgradeTurretsWeapon ( turrets , factories ) ; var i , j , k , nat , weapon , weapons , list ; begin
88260: LD_INT 0
88262: PPUSH
88263: PPUSH
88264: PPUSH
88265: PPUSH
88266: PPUSH
88267: PPUSH
88268: PPUSH
88269: PPUSH
// if not turrets or not factories then
88270: LD_VAR 0 1
88274: NOT
88275: PUSH
88276: LD_VAR 0 2
88280: NOT
88281: OR
88282: IFFALSE 88286
// exit ;
88284: GO 88593
// list := [ [ [ us_double_gun , us_heavy_gun ] , [ us_machine_gun , us_gatling_gun ] , [ us_light_gun , us_double_gun ] ] , [ [ ar_double_machine_gun , ar_gatling_gun ] , [ ar_light_gun , ar_gun ] ] , [ [ ru_heavy_machine_gun , ru_gatling_gun ] , [ ru_gun , ru_heavy_gun ] , [ ru_rocket_launcher , ru_rocket ] ] , ] ;
88286: LD_ADDR_VAR 0 10
88290: PUSH
88291: LD_INT 5
88293: PUSH
88294: LD_INT 6
88296: PUSH
88297: EMPTY
88298: LIST
88299: LIST
88300: PUSH
88301: LD_INT 2
88303: PUSH
88304: LD_INT 4
88306: PUSH
88307: EMPTY
88308: LIST
88309: LIST
88310: PUSH
88311: LD_INT 3
88313: PUSH
88314: LD_INT 5
88316: PUSH
88317: EMPTY
88318: LIST
88319: LIST
88320: PUSH
88321: EMPTY
88322: LIST
88323: LIST
88324: LIST
88325: PUSH
88326: LD_INT 24
88328: PUSH
88329: LD_INT 25
88331: PUSH
88332: EMPTY
88333: LIST
88334: LIST
88335: PUSH
88336: LD_INT 23
88338: PUSH
88339: LD_INT 27
88341: PUSH
88342: EMPTY
88343: LIST
88344: LIST
88345: PUSH
88346: EMPTY
88347: LIST
88348: LIST
88349: PUSH
88350: LD_INT 42
88352: PUSH
88353: LD_INT 43
88355: PUSH
88356: EMPTY
88357: LIST
88358: LIST
88359: PUSH
88360: LD_INT 44
88362: PUSH
88363: LD_INT 46
88365: PUSH
88366: EMPTY
88367: LIST
88368: LIST
88369: PUSH
88370: LD_INT 45
88372: PUSH
88373: LD_INT 47
88375: PUSH
88376: EMPTY
88377: LIST
88378: LIST
88379: PUSH
88380: EMPTY
88381: LIST
88382: LIST
88383: LIST
88384: PUSH
88385: EMPTY
88386: LIST
88387: LIST
88388: LIST
88389: ST_TO_ADDR
// result := [ ] ;
88390: LD_ADDR_VAR 0 3
88394: PUSH
88395: EMPTY
88396: ST_TO_ADDR
// for i in turrets do
88397: LD_ADDR_VAR 0 4
88401: PUSH
88402: LD_VAR 0 1
88406: PUSH
88407: FOR_IN
88408: IFFALSE 88591
// begin nat := GetNation ( i ) ;
88410: LD_ADDR_VAR 0 7
88414: PUSH
88415: LD_VAR 0 4
88419: PPUSH
88420: CALL_OW 248
88424: ST_TO_ADDR
// weapon := 0 ;
88425: LD_ADDR_VAR 0 8
88429: PUSH
88430: LD_INT 0
88432: ST_TO_ADDR
// if not nat then
88433: LD_VAR 0 7
88437: NOT
88438: IFFALSE 88442
// continue ;
88440: GO 88407
// for j in list [ nat ] do
88442: LD_ADDR_VAR 0 5
88446: PUSH
88447: LD_VAR 0 10
88451: PUSH
88452: LD_VAR 0 7
88456: ARRAY
88457: PUSH
88458: FOR_IN
88459: IFFALSE 88500
// if GetBWeapon ( i ) = j [ 1 ] then
88461: LD_VAR 0 4
88465: PPUSH
88466: CALL_OW 269
88470: PUSH
88471: LD_VAR 0 5
88475: PUSH
88476: LD_INT 1
88478: ARRAY
88479: EQUAL
88480: IFFALSE 88498
// begin weapon := j [ 2 ] ;
88482: LD_ADDR_VAR 0 8
88486: PUSH
88487: LD_VAR 0 5
88491: PUSH
88492: LD_INT 2
88494: ARRAY
88495: ST_TO_ADDR
// break ;
88496: GO 88500
// end ;
88498: GO 88458
88500: POP
88501: POP
// if not weapon then
88502: LD_VAR 0 8
88506: NOT
88507: IFFALSE 88511
// continue ;
88509: GO 88407
// for k in factories do
88511: LD_ADDR_VAR 0 6
88515: PUSH
88516: LD_VAR 0 2
88520: PUSH
88521: FOR_IN
88522: IFFALSE 88587
// begin weapons := AvailableWeaponList ( k ) ;
88524: LD_ADDR_VAR 0 9
88528: PUSH
88529: LD_VAR 0 6
88533: PPUSH
88534: CALL_OW 478
88538: ST_TO_ADDR
// if not weapons then
88539: LD_VAR 0 9
88543: NOT
88544: IFFALSE 88548
// continue ;
88546: GO 88521
// if weapon in weapons then
88548: LD_VAR 0 8
88552: PUSH
88553: LD_VAR 0 9
88557: IN
88558: IFFALSE 88585
// begin result := [ i , weapon ] ;
88560: LD_ADDR_VAR 0 3
88564: PUSH
88565: LD_VAR 0 4
88569: PUSH
88570: LD_VAR 0 8
88574: PUSH
88575: EMPTY
88576: LIST
88577: LIST
88578: ST_TO_ADDR
// exit ;
88579: POP
88580: POP
88581: POP
88582: POP
88583: GO 88593
// end ; end ;
88585: GO 88521
88587: POP
88588: POP
// end ;
88589: GO 88407
88591: POP
88592: POP
// end ;
88593: LD_VAR 0 3
88597: RET
// export function RevealMapOnXY ( x , y , side , range ) ; begin
88598: LD_INT 0
88600: PPUSH
// if not side or side > 8 then
88601: LD_VAR 0 3
88605: NOT
88606: PUSH
88607: LD_VAR 0 3
88611: PUSH
88612: LD_INT 8
88614: GREATER
88615: OR
88616: IFFALSE 88620
// exit ;
88618: GO 88679
// if not range then
88620: LD_VAR 0 4
88624: NOT
88625: IFFALSE 88636
// range := - 12 ;
88627: LD_ADDR_VAR 0 4
88631: PUSH
88632: LD_INT 12
88634: NEG
88635: ST_TO_ADDR
// PlaceSeeing ( x , y , side , range ) ;
88636: LD_VAR 0 1
88640: PPUSH
88641: LD_VAR 0 2
88645: PPUSH
88646: LD_VAR 0 3
88650: PPUSH
88651: LD_VAR 0 4
88655: PPUSH
88656: CALL_OW 330
// RemoveSeeing ( x , y , side ) ;
88660: LD_VAR 0 1
88664: PPUSH
88665: LD_VAR 0 2
88669: PPUSH
88670: LD_VAR 0 3
88674: PPUSH
88675: CALL_OW 331
// end ;
88679: LD_VAR 0 5
88683: RET
// export function Video ( mode ) ; begin
88684: LD_INT 0
88686: PPUSH
// ingame_video = mode ;
88687: LD_ADDR_OWVAR 52
88691: PUSH
88692: LD_VAR 0 1
88696: ST_TO_ADDR
// interface_hidden = mode ;
88697: LD_ADDR_OWVAR 54
88701: PUSH
88702: LD_VAR 0 1
88706: ST_TO_ADDR
// end ;
88707: LD_VAR 0 2
88711: RET
// export function Join ( array , element ) ; begin
88712: LD_INT 0
88714: PPUSH
// result := Replace ( array , array + 1 , element ) ;
88715: LD_ADDR_VAR 0 3
88719: PUSH
88720: LD_VAR 0 1
88724: PPUSH
88725: LD_VAR 0 1
88729: PUSH
88730: LD_INT 1
88732: PLUS
88733: PPUSH
88734: LD_VAR 0 2
88738: PPUSH
88739: CALL_OW 1
88743: ST_TO_ADDR
// end ;
88744: LD_VAR 0 3
88748: RET
// export function JoinUnion ( array , element ) ; begin
88749: LD_INT 0
88751: PPUSH
// result := array union element ;
88752: LD_ADDR_VAR 0 3
88756: PUSH
88757: LD_VAR 0 1
88761: PUSH
88762: LD_VAR 0 2
88766: UNION
88767: ST_TO_ADDR
// end ;
88768: LD_VAR 0 3
88772: RET
// export function GetBehemoths ( side ) ; begin
88773: LD_INT 0
88775: PPUSH
// result := FilterAllUnits ( [ [ f_side , side ] , [ f_chassis , 25 ] ] ) ;
88776: LD_ADDR_VAR 0 2
88780: PUSH
88781: LD_INT 22
88783: PUSH
88784: LD_VAR 0 1
88788: PUSH
88789: EMPTY
88790: LIST
88791: LIST
88792: PUSH
88793: LD_INT 31
88795: PUSH
88796: LD_INT 25
88798: PUSH
88799: EMPTY
88800: LIST
88801: LIST
88802: PUSH
88803: EMPTY
88804: LIST
88805: LIST
88806: PPUSH
88807: CALL_OW 69
88811: ST_TO_ADDR
// end ;
88812: LD_VAR 0 2
88816: RET
// export function Shuffle ( array ) ; var i , index ; begin
88817: LD_INT 0
88819: PPUSH
88820: PPUSH
88821: PPUSH
// result := [ ] ;
88822: LD_ADDR_VAR 0 2
88826: PUSH
88827: EMPTY
88828: ST_TO_ADDR
// if not array then
88829: LD_VAR 0 1
88833: NOT
88834: IFFALSE 88838
// exit ;
88836: GO 88937
// Randomize ;
88838: CALL_OW 10
// for i = array downto 1 do
88842: LD_ADDR_VAR 0 3
88846: PUSH
88847: DOUBLE
88848: LD_VAR 0 1
88852: INC
88853: ST_TO_ADDR
88854: LD_INT 1
88856: PUSH
88857: FOR_DOWNTO
88858: IFFALSE 88935
// begin index := rand ( 1 , array ) ;
88860: LD_ADDR_VAR 0 4
88864: PUSH
88865: LD_INT 1
88867: PPUSH
88868: LD_VAR 0 1
88872: PPUSH
88873: CALL_OW 12
88877: ST_TO_ADDR
// result := Insert ( result , result + 1 , array [ index ] ) ;
88878: LD_ADDR_VAR 0 2
88882: PUSH
88883: LD_VAR 0 2
88887: PPUSH
88888: LD_VAR 0 2
88892: PUSH
88893: LD_INT 1
88895: PLUS
88896: PPUSH
88897: LD_VAR 0 1
88901: PUSH
88902: LD_VAR 0 4
88906: ARRAY
88907: PPUSH
88908: CALL_OW 2
88912: ST_TO_ADDR
// array := Delete ( array , index ) ;
88913: LD_ADDR_VAR 0 1
88917: PUSH
88918: LD_VAR 0 1
88922: PPUSH
88923: LD_VAR 0 4
88927: PPUSH
88928: CALL_OW 3
88932: ST_TO_ADDR
// end ;
88933: GO 88857
88935: POP
88936: POP
// end ;
88937: LD_VAR 0 2
88941: RET
// export function GetBaseMaterials ( base ) ; begin
88942: LD_INT 0
88944: PPUSH
// result := [ 0 , 0 , 0 ] ;
88945: LD_ADDR_VAR 0 2
88949: PUSH
88950: LD_INT 0
88952: PUSH
88953: LD_INT 0
88955: PUSH
88956: LD_INT 0
88958: PUSH
88959: EMPTY
88960: LIST
88961: LIST
88962: LIST
88963: ST_TO_ADDR
// if not base then
88964: LD_VAR 0 1
88968: NOT
88969: IFFALSE 88973
// exit ;
88971: GO 89022
// result := [ GetResourceType ( base , mat_cans ) , GetResourceType ( base , mat_oil ) , GetResourceType ( base , mat_siberit ) ] ;
88973: LD_ADDR_VAR 0 2
88977: PUSH
88978: LD_VAR 0 1
88982: PPUSH
88983: LD_INT 1
88985: PPUSH
88986: CALL_OW 275
88990: PUSH
88991: LD_VAR 0 1
88995: PPUSH
88996: LD_INT 2
88998: PPUSH
88999: CALL_OW 275
89003: PUSH
89004: LD_VAR 0 1
89008: PPUSH
89009: LD_INT 3
89011: PPUSH
89012: CALL_OW 275
89016: PUSH
89017: EMPTY
89018: LIST
89019: LIST
89020: LIST
89021: ST_TO_ADDR
// end ;
89022: LD_VAR 0 2
89026: RET
// export function ShrinkArray ( array , size ) ; var i ; begin
89027: LD_INT 0
89029: PPUSH
89030: PPUSH
// result := array ;
89031: LD_ADDR_VAR 0 3
89035: PUSH
89036: LD_VAR 0 1
89040: ST_TO_ADDR
// if size > 0 then
89041: LD_VAR 0 2
89045: PUSH
89046: LD_INT 0
89048: GREATER
89049: IFFALSE 89095
// for i := array downto size do
89051: LD_ADDR_VAR 0 4
89055: PUSH
89056: DOUBLE
89057: LD_VAR 0 1
89061: INC
89062: ST_TO_ADDR
89063: LD_VAR 0 2
89067: PUSH
89068: FOR_DOWNTO
89069: IFFALSE 89093
// result := Delete ( result , result ) ;
89071: LD_ADDR_VAR 0 3
89075: PUSH
89076: LD_VAR 0 3
89080: PPUSH
89081: LD_VAR 0 3
89085: PPUSH
89086: CALL_OW 3
89090: ST_TO_ADDR
89091: GO 89068
89093: POP
89094: POP
// end ;
89095: LD_VAR 0 3
89099: RET
// export function ComExit ( unit ) ; var tmp ; begin
89100: LD_INT 0
89102: PPUSH
89103: PPUSH
// if not IsInUnit ( unit ) then
89104: LD_VAR 0 1
89108: PPUSH
89109: CALL_OW 310
89113: NOT
89114: IFFALSE 89118
// exit ;
89116: GO 89178
// tmp := IsInUnit ( unit ) ;
89118: LD_ADDR_VAR 0 3
89122: PUSH
89123: LD_VAR 0 1
89127: PPUSH
89128: CALL_OW 310
89132: ST_TO_ADDR
// if GetType ( tmp ) = unit_vehicle then
89133: LD_VAR 0 3
89137: PPUSH
89138: CALL_OW 247
89142: PUSH
89143: LD_INT 2
89145: EQUAL
89146: IFFALSE 89159
// ComExitVehicle ( unit ) else
89148: LD_VAR 0 1
89152: PPUSH
89153: CALL_OW 121
89157: GO 89168
// ComExitBuilding ( unit ) ;
89159: LD_VAR 0 1
89163: PPUSH
89164: CALL_OW 122
// result := tmp ;
89168: LD_ADDR_VAR 0 2
89172: PUSH
89173: LD_VAR 0 3
89177: ST_TO_ADDR
// end ;
89178: LD_VAR 0 2
89182: RET
// export function ComExitAll ( units ) ; var i ; begin
89183: LD_INT 0
89185: PPUSH
89186: PPUSH
// if not units then
89187: LD_VAR 0 1
89191: NOT
89192: IFFALSE 89196
// exit ;
89194: GO 89222
// for i in units do
89196: LD_ADDR_VAR 0 3
89200: PUSH
89201: LD_VAR 0 1
89205: PUSH
89206: FOR_IN
89207: IFFALSE 89220
// ComExit ( i ) ;
89209: LD_VAR 0 3
89213: PPUSH
89214: CALL 89100 0 1
89218: GO 89206
89220: POP
89221: POP
// end ;
89222: LD_VAR 0 2
89226: RET
// export function ResetHc ; begin
89227: LD_INT 0
89229: PPUSH
// InitHc ;
89230: CALL_OW 19
// hc_importance := 0 ;
89234: LD_ADDR_OWVAR 32
89238: PUSH
89239: LD_INT 0
89241: ST_TO_ADDR
// end ;
89242: LD_VAR 0 1
89246: RET
// export function PointBetweenXY ( x1 , y1 , x2 , y2 ) ; var _x , _y ; begin
89247: LD_INT 0
89249: PPUSH
89250: PPUSH
89251: PPUSH
// _x := ( x1 + x2 ) div 2 ;
89252: LD_ADDR_VAR 0 6
89256: PUSH
89257: LD_VAR 0 1
89261: PUSH
89262: LD_VAR 0 3
89266: PLUS
89267: PUSH
89268: LD_INT 2
89270: DIV
89271: ST_TO_ADDR
// if _x < 0 then
89272: LD_VAR 0 6
89276: PUSH
89277: LD_INT 0
89279: LESS
89280: IFFALSE 89297
// _x := _x * - 1 ;
89282: LD_ADDR_VAR 0 6
89286: PUSH
89287: LD_VAR 0 6
89291: PUSH
89292: LD_INT 1
89294: NEG
89295: MUL
89296: ST_TO_ADDR
// _y := ( y1 + y2 ) div 2 ;
89297: LD_ADDR_VAR 0 7
89301: PUSH
89302: LD_VAR 0 2
89306: PUSH
89307: LD_VAR 0 4
89311: PLUS
89312: PUSH
89313: LD_INT 2
89315: DIV
89316: ST_TO_ADDR
// if _y < 0 then
89317: LD_VAR 0 7
89321: PUSH
89322: LD_INT 0
89324: LESS
89325: IFFALSE 89342
// _y := _y * - 1 ;
89327: LD_ADDR_VAR 0 7
89331: PUSH
89332: LD_VAR 0 7
89336: PUSH
89337: LD_INT 1
89339: NEG
89340: MUL
89341: ST_TO_ADDR
// result := [ _x , _y ] ;
89342: LD_ADDR_VAR 0 5
89346: PUSH
89347: LD_VAR 0 6
89351: PUSH
89352: LD_VAR 0 7
89356: PUSH
89357: EMPTY
89358: LIST
89359: LIST
89360: ST_TO_ADDR
// end ;
89361: LD_VAR 0 5
89365: RET
// export function NotGoToAreaUnit ( unit , area , goAway ) ; var x , y , task ; begin
89366: LD_INT 0
89368: PPUSH
89369: PPUSH
89370: PPUSH
89371: PPUSH
// task := GetTaskList ( unit ) ;
89372: LD_ADDR_VAR 0 7
89376: PUSH
89377: LD_VAR 0 1
89381: PPUSH
89382: CALL_OW 437
89386: ST_TO_ADDR
// if not task and not IsInArea ( unit , area ) then
89387: LD_VAR 0 7
89391: NOT
89392: PUSH
89393: LD_VAR 0 1
89397: PPUSH
89398: LD_VAR 0 2
89402: PPUSH
89403: CALL_OW 308
89407: NOT
89408: AND
89409: IFFALSE 89413
// exit ;
89411: GO 89531
// if IsInArea ( unit , area ) then
89413: LD_VAR 0 1
89417: PPUSH
89418: LD_VAR 0 2
89422: PPUSH
89423: CALL_OW 308
89427: IFFALSE 89445
// begin ComMoveToArea ( unit , goAway ) ;
89429: LD_VAR 0 1
89433: PPUSH
89434: LD_VAR 0 3
89438: PPUSH
89439: CALL_OW 113
// exit ;
89443: GO 89531
// end ; if task [ 1 ] [ 1 ] <> M then
89445: LD_VAR 0 7
89449: PUSH
89450: LD_INT 1
89452: ARRAY
89453: PUSH
89454: LD_INT 1
89456: ARRAY
89457: PUSH
89458: LD_STRING M
89460: NONEQUAL
89461: IFFALSE 89465
// exit ;
89463: GO 89531
// x := task [ 1 ] [ 2 ] ;
89465: LD_ADDR_VAR 0 5
89469: PUSH
89470: LD_VAR 0 7
89474: PUSH
89475: LD_INT 1
89477: ARRAY
89478: PUSH
89479: LD_INT 2
89481: ARRAY
89482: ST_TO_ADDR
// y := task [ 1 ] [ 3 ] ;
89483: LD_ADDR_VAR 0 6
89487: PUSH
89488: LD_VAR 0 7
89492: PUSH
89493: LD_INT 1
89495: ARRAY
89496: PUSH
89497: LD_INT 3
89499: ARRAY
89500: ST_TO_ADDR
// if InArea ( x , y , area ) then
89501: LD_VAR 0 5
89505: PPUSH
89506: LD_VAR 0 6
89510: PPUSH
89511: LD_VAR 0 2
89515: PPUSH
89516: CALL_OW 309
89520: IFFALSE 89531
// ComStop ( unit ) ;
89522: LD_VAR 0 1
89526: PPUSH
89527: CALL_OW 141
// end ;
89531: LD_VAR 0 4
89535: RET
// export function Abs ( value ) ; begin
89536: LD_INT 0
89538: PPUSH
// result := value ;
89539: LD_ADDR_VAR 0 2
89543: PUSH
89544: LD_VAR 0 1
89548: ST_TO_ADDR
// if value < 0 then
89549: LD_VAR 0 1
89553: PUSH
89554: LD_INT 0
89556: LESS
89557: IFFALSE 89574
// result := value * - 1 ;
89559: LD_ADDR_VAR 0 2
89563: PUSH
89564: LD_VAR 0 1
89568: PUSH
89569: LD_INT 1
89571: NEG
89572: MUL
89573: ST_TO_ADDR
// end ;
89574: LD_VAR 0 2
89578: RET
// export function ComMoveToNearbyEntrance ( unit , building ) ; var x , _x , y , _y , d , r , i ; begin
89579: LD_INT 0
89581: PPUSH
89582: PPUSH
89583: PPUSH
89584: PPUSH
89585: PPUSH
89586: PPUSH
89587: PPUSH
89588: PPUSH
// if not unit or not building then
89589: LD_VAR 0 1
89593: NOT
89594: PUSH
89595: LD_VAR 0 2
89599: NOT
89600: OR
89601: IFFALSE 89605
// exit ;
89603: GO 89831
// x := GetX ( building ) ;
89605: LD_ADDR_VAR 0 4
89609: PUSH
89610: LD_VAR 0 2
89614: PPUSH
89615: CALL_OW 250
89619: ST_TO_ADDR
// y := GetY ( building ) ;
89620: LD_ADDR_VAR 0 6
89624: PUSH
89625: LD_VAR 0 2
89629: PPUSH
89630: CALL_OW 251
89634: ST_TO_ADDR
// d := GetDir ( building ) ;
89635: LD_ADDR_VAR 0 8
89639: PUSH
89640: LD_VAR 0 2
89644: PPUSH
89645: CALL_OW 254
89649: ST_TO_ADDR
// r := 4 ;
89650: LD_ADDR_VAR 0 9
89654: PUSH
89655: LD_INT 4
89657: ST_TO_ADDR
// for i := 1 to 5 do
89658: LD_ADDR_VAR 0 10
89662: PUSH
89663: DOUBLE
89664: LD_INT 1
89666: DEC
89667: ST_TO_ADDR
89668: LD_INT 5
89670: PUSH
89671: FOR_TO
89672: IFFALSE 89829
// begin _x := ShiftX ( x , d , r + i ) ;
89674: LD_ADDR_VAR 0 5
89678: PUSH
89679: LD_VAR 0 4
89683: PPUSH
89684: LD_VAR 0 8
89688: PPUSH
89689: LD_VAR 0 9
89693: PUSH
89694: LD_VAR 0 10
89698: PLUS
89699: PPUSH
89700: CALL_OW 272
89704: ST_TO_ADDR
// _y := ShiftY ( y , d , r + i ) ;
89705: LD_ADDR_VAR 0 7
89709: PUSH
89710: LD_VAR 0 6
89714: PPUSH
89715: LD_VAR 0 8
89719: PPUSH
89720: LD_VAR 0 9
89724: PUSH
89725: LD_VAR 0 10
89729: PLUS
89730: PPUSH
89731: CALL_OW 273
89735: ST_TO_ADDR
// if ValidHex ( _x , _y ) and not GetType ( HexInfo ( _x , _y ) ) in [ unit_building , unit_vehicle ] then
89736: LD_VAR 0 5
89740: PPUSH
89741: LD_VAR 0 7
89745: PPUSH
89746: CALL_OW 488
89750: PUSH
89751: LD_VAR 0 5
89755: PPUSH
89756: LD_VAR 0 7
89760: PPUSH
89761: CALL_OW 428
89765: PPUSH
89766: CALL_OW 247
89770: PUSH
89771: LD_INT 3
89773: PUSH
89774: LD_INT 2
89776: PUSH
89777: EMPTY
89778: LIST
89779: LIST
89780: IN
89781: NOT
89782: AND
89783: IFFALSE 89827
// begin ComMoveXY ( unit , _x , _y ) ;
89785: LD_VAR 0 1
89789: PPUSH
89790: LD_VAR 0 5
89794: PPUSH
89795: LD_VAR 0 7
89799: PPUSH
89800: CALL_OW 111
// result := [ _x , _y ] ;
89804: LD_ADDR_VAR 0 3
89808: PUSH
89809: LD_VAR 0 5
89813: PUSH
89814: LD_VAR 0 7
89818: PUSH
89819: EMPTY
89820: LIST
89821: LIST
89822: ST_TO_ADDR
// exit ;
89823: POP
89824: POP
89825: GO 89831
// end ; end ;
89827: GO 89671
89829: POP
89830: POP
// end ;
89831: LD_VAR 0 3
89835: RET
// export function SideAttackedSide ( side1 , side2 ) ; var i , un ; begin
89836: LD_INT 0
89838: PPUSH
89839: PPUSH
89840: PPUSH
// result := 0 ;
89841: LD_ADDR_VAR 0 3
89845: PUSH
89846: LD_INT 0
89848: ST_TO_ADDR
// if side1 < 0 or side1 > 8 or side2 < 0 or side2 > 8 then
89849: LD_VAR 0 1
89853: PUSH
89854: LD_INT 0
89856: LESS
89857: PUSH
89858: LD_VAR 0 1
89862: PUSH
89863: LD_INT 8
89865: GREATER
89866: OR
89867: PUSH
89868: LD_VAR 0 2
89872: PUSH
89873: LD_INT 0
89875: LESS
89876: OR
89877: PUSH
89878: LD_VAR 0 2
89882: PUSH
89883: LD_INT 8
89885: GREATER
89886: OR
89887: IFFALSE 89891
// exit ;
89889: GO 89966
// for i in FilterAllUnits ( [ f_side , side2 ] ) do
89891: LD_ADDR_VAR 0 4
89895: PUSH
89896: LD_INT 22
89898: PUSH
89899: LD_VAR 0 2
89903: PUSH
89904: EMPTY
89905: LIST
89906: LIST
89907: PPUSH
89908: CALL_OW 69
89912: PUSH
89913: FOR_IN
89914: IFFALSE 89964
// begin un := UnitShoot ( i ) ;
89916: LD_ADDR_VAR 0 5
89920: PUSH
89921: LD_VAR 0 4
89925: PPUSH
89926: CALL_OW 504
89930: ST_TO_ADDR
// if GetSide ( un ) = side1 then
89931: LD_VAR 0 5
89935: PPUSH
89936: CALL_OW 255
89940: PUSH
89941: LD_VAR 0 1
89945: EQUAL
89946: IFFALSE 89962
// begin result := un ;
89948: LD_ADDR_VAR 0 3
89952: PUSH
89953: LD_VAR 0 5
89957: ST_TO_ADDR
// exit ;
89958: POP
89959: POP
89960: GO 89966
// end ; end ;
89962: GO 89913
89964: POP
89965: POP
// end ;
89966: LD_VAR 0 3
89970: RET
// export function GetCargoBay ( units ) ; begin
89971: LD_INT 0
89973: PPUSH
// result := UnitFilter ( units , [ f_or , [ f_weapon , us_cargo_bay ] , [ f_weapon , ru_cargo_bay ] , [ f_weapon , ar_cargo_bay ] , [ f_weapon , ru_big_cargo_bay ] ] ) ;
89974: LD_ADDR_VAR 0 2
89978: PUSH
89979: LD_VAR 0 1
89983: PPUSH
89984: LD_INT 2
89986: PUSH
89987: LD_INT 34
89989: PUSH
89990: LD_INT 12
89992: PUSH
89993: EMPTY
89994: LIST
89995: LIST
89996: PUSH
89997: LD_INT 34
89999: PUSH
90000: LD_INT 51
90002: PUSH
90003: EMPTY
90004: LIST
90005: LIST
90006: PUSH
90007: LD_INT 34
90009: PUSH
90010: LD_INT 32
90012: PUSH
90013: EMPTY
90014: LIST
90015: LIST
90016: PUSH
90017: LD_INT 34
90019: PUSH
90020: LD_EXP 75
90024: PUSH
90025: EMPTY
90026: LIST
90027: LIST
90028: PUSH
90029: EMPTY
90030: LIST
90031: LIST
90032: LIST
90033: LIST
90034: LIST
90035: PPUSH
90036: CALL_OW 72
90040: ST_TO_ADDR
// end ;
90041: LD_VAR 0 2
90045: RET
// export function Negate ( value ) ; begin
90046: LD_INT 0
90048: PPUSH
// result := not value ;
90049: LD_ADDR_VAR 0 2
90053: PUSH
90054: LD_VAR 0 1
90058: NOT
90059: ST_TO_ADDR
// end ;
90060: LD_VAR 0 2
90064: RET
// export function Inc ( value ) ; begin
90065: LD_INT 0
90067: PPUSH
// result := value + 1 ;
90068: LD_ADDR_VAR 0 2
90072: PUSH
90073: LD_VAR 0 1
90077: PUSH
90078: LD_INT 1
90080: PLUS
90081: ST_TO_ADDR
// end ;
90082: LD_VAR 0 2
90086: RET
// export function Dec ( value ) ; begin
90087: LD_INT 0
90089: PPUSH
// result := value - 1 ;
90090: LD_ADDR_VAR 0 2
90094: PUSH
90095: LD_VAR 0 1
90099: PUSH
90100: LD_INT 1
90102: MINUS
90103: ST_TO_ADDR
// end ;
90104: LD_VAR 0 2
90108: RET
// export function GetDirFromHex ( x1 , y1 , x2 , y2 ) ; var i , _x , _y , tmp , distance , centerDist , centerPoint ; begin
90109: LD_INT 0
90111: PPUSH
90112: PPUSH
90113: PPUSH
90114: PPUSH
90115: PPUSH
90116: PPUSH
90117: PPUSH
90118: PPUSH
// if not ValidHex ( x1 , y1 ) or not ValidHex ( x2 , y2 ) then
90119: LD_VAR 0 1
90123: PPUSH
90124: LD_VAR 0 2
90128: PPUSH
90129: CALL_OW 488
90133: NOT
90134: PUSH
90135: LD_VAR 0 3
90139: PPUSH
90140: LD_VAR 0 4
90144: PPUSH
90145: CALL_OW 488
90149: NOT
90150: OR
90151: IFFALSE 90164
// begin result := - 1 ;
90153: LD_ADDR_VAR 0 5
90157: PUSH
90158: LD_INT 1
90160: NEG
90161: ST_TO_ADDR
// exit ;
90162: GO 90399
// end ; centerPoint := PointBetweenXY ( x1 , y1 , x2 , y2 ) ;
90164: LD_ADDR_VAR 0 12
90168: PUSH
90169: LD_VAR 0 1
90173: PPUSH
90174: LD_VAR 0 2
90178: PPUSH
90179: LD_VAR 0 3
90183: PPUSH
90184: LD_VAR 0 4
90188: PPUSH
90189: CALL 89247 0 4
90193: ST_TO_ADDR
// centerDist := GetDistXY ( x1 , y1 , centerPoint [ 1 ] , centerPoint [ 2 ] ) ;
90194: LD_ADDR_VAR 0 11
90198: PUSH
90199: LD_VAR 0 1
90203: PPUSH
90204: LD_VAR 0 2
90208: PPUSH
90209: LD_VAR 0 12
90213: PUSH
90214: LD_INT 1
90216: ARRAY
90217: PPUSH
90218: LD_VAR 0 12
90222: PUSH
90223: LD_INT 2
90225: ARRAY
90226: PPUSH
90227: CALL_OW 298
90231: ST_TO_ADDR
// distance := 9999 ;
90232: LD_ADDR_VAR 0 10
90236: PUSH
90237: LD_INT 9999
90239: ST_TO_ADDR
// for i := 0 to 5 do
90240: LD_ADDR_VAR 0 6
90244: PUSH
90245: DOUBLE
90246: LD_INT 0
90248: DEC
90249: ST_TO_ADDR
90250: LD_INT 5
90252: PUSH
90253: FOR_TO
90254: IFFALSE 90397
// begin _x := ShiftX ( x1 , i , centerDist ) ;
90256: LD_ADDR_VAR 0 7
90260: PUSH
90261: LD_VAR 0 1
90265: PPUSH
90266: LD_VAR 0 6
90270: PPUSH
90271: LD_VAR 0 11
90275: PPUSH
90276: CALL_OW 272
90280: ST_TO_ADDR
// _y := ShiftY ( y1 , i , centerDist ) ;
90281: LD_ADDR_VAR 0 8
90285: PUSH
90286: LD_VAR 0 2
90290: PPUSH
90291: LD_VAR 0 6
90295: PPUSH
90296: LD_VAR 0 11
90300: PPUSH
90301: CALL_OW 273
90305: ST_TO_ADDR
// if not ValidHex ( _x , _y ) then
90306: LD_VAR 0 7
90310: PPUSH
90311: LD_VAR 0 8
90315: PPUSH
90316: CALL_OW 488
90320: NOT
90321: IFFALSE 90325
// continue ;
90323: GO 90253
// tmp := GetDistXY ( centerPoint [ 1 ] , centerPoint [ 2 ] , _x , _y ) ;
90325: LD_ADDR_VAR 0 9
90329: PUSH
90330: LD_VAR 0 12
90334: PUSH
90335: LD_INT 1
90337: ARRAY
90338: PPUSH
90339: LD_VAR 0 12
90343: PUSH
90344: LD_INT 2
90346: ARRAY
90347: PPUSH
90348: LD_VAR 0 7
90352: PPUSH
90353: LD_VAR 0 8
90357: PPUSH
90358: CALL_OW 298
90362: ST_TO_ADDR
// if tmp < distance then
90363: LD_VAR 0 9
90367: PUSH
90368: LD_VAR 0 10
90372: LESS
90373: IFFALSE 90395
// begin result := i ;
90375: LD_ADDR_VAR 0 5
90379: PUSH
90380: LD_VAR 0 6
90384: ST_TO_ADDR
// distance := tmp ;
90385: LD_ADDR_VAR 0 10
90389: PUSH
90390: LD_VAR 0 9
90394: ST_TO_ADDR
// end ; end ;
90395: GO 90253
90397: POP
90398: POP
// end ;
90399: LD_VAR 0 5
90403: RET
// export function ComRepairVehicleAndReturn ( driver ) ; var vehicle ; begin
90404: LD_INT 0
90406: PPUSH
90407: PPUSH
// if not driver or not IsInUnit ( driver ) then
90408: LD_VAR 0 1
90412: NOT
90413: PUSH
90414: LD_VAR 0 1
90418: PPUSH
90419: CALL_OW 310
90423: NOT
90424: OR
90425: IFFALSE 90429
// exit ;
90427: GO 90519
// vehicle := IsInUnit ( driver ) ;
90429: LD_ADDR_VAR 0 3
90433: PUSH
90434: LD_VAR 0 1
90438: PPUSH
90439: CALL_OW 310
90443: ST_TO_ADDR
// SetTaskList ( driver , [ [ \ , 0 , 0 , 0 , 0 , 0 , 0 ] , [ E , 0 , 0 , vehicle , 0 , 0 , 0 ] ] ) ;
90444: LD_VAR 0 1
90448: PPUSH
90449: LD_STRING \
90451: PUSH
90452: LD_INT 0
90454: PUSH
90455: LD_INT 0
90457: PUSH
90458: LD_INT 0
90460: PUSH
90461: LD_INT 0
90463: PUSH
90464: LD_INT 0
90466: PUSH
90467: LD_INT 0
90469: PUSH
90470: EMPTY
90471: LIST
90472: LIST
90473: LIST
90474: LIST
90475: LIST
90476: LIST
90477: LIST
90478: PUSH
90479: LD_STRING E
90481: PUSH
90482: LD_INT 0
90484: PUSH
90485: LD_INT 0
90487: PUSH
90488: LD_VAR 0 3
90492: PUSH
90493: LD_INT 0
90495: PUSH
90496: LD_INT 0
90498: PUSH
90499: LD_INT 0
90501: PUSH
90502: EMPTY
90503: LIST
90504: LIST
90505: LIST
90506: LIST
90507: LIST
90508: LIST
90509: LIST
90510: PUSH
90511: EMPTY
90512: LIST
90513: LIST
90514: PPUSH
90515: CALL_OW 446
// end ;
90519: LD_VAR 0 2
90523: RET
// export function AddComRepairVehicleAndReturn ( driver ) ; var vehicle ; begin
90524: LD_INT 0
90526: PPUSH
90527: PPUSH
// if not driver or not IsInUnit ( driver ) then
90528: LD_VAR 0 1
90532: NOT
90533: PUSH
90534: LD_VAR 0 1
90538: PPUSH
90539: CALL_OW 310
90543: NOT
90544: OR
90545: IFFALSE 90549
// exit ;
90547: GO 90639
// vehicle := IsInUnit ( driver ) ;
90549: LD_ADDR_VAR 0 3
90553: PUSH
90554: LD_VAR 0 1
90558: PPUSH
90559: CALL_OW 310
90563: ST_TO_ADDR
// AddTaskList ( driver , [ [ \ , 0 , 0 , 0 , 0 , 0 , 0 ] , [ E , 0 , 0 , vehicle , 0 , 0 , 0 ] ] ) ;
90564: LD_VAR 0 1
90568: PPUSH
90569: LD_STRING \
90571: PUSH
90572: LD_INT 0
90574: PUSH
90575: LD_INT 0
90577: PUSH
90578: LD_INT 0
90580: PUSH
90581: LD_INT 0
90583: PUSH
90584: LD_INT 0
90586: PUSH
90587: LD_INT 0
90589: PUSH
90590: EMPTY
90591: LIST
90592: LIST
90593: LIST
90594: LIST
90595: LIST
90596: LIST
90597: LIST
90598: PUSH
90599: LD_STRING E
90601: PUSH
90602: LD_INT 0
90604: PUSH
90605: LD_INT 0
90607: PUSH
90608: LD_VAR 0 3
90612: PUSH
90613: LD_INT 0
90615: PUSH
90616: LD_INT 0
90618: PUSH
90619: LD_INT 0
90621: PUSH
90622: EMPTY
90623: LIST
90624: LIST
90625: LIST
90626: LIST
90627: LIST
90628: LIST
90629: LIST
90630: PUSH
90631: EMPTY
90632: LIST
90633: LIST
90634: PPUSH
90635: CALL_OW 447
// end ;
90639: LD_VAR 0 2
90643: RET
// export function SortByHealth ( units , asc ) ; var i , tmp ; begin
90644: LD_INT 0
90646: PPUSH
90647: PPUSH
90648: PPUSH
// tmp := [ ] ;
90649: LD_ADDR_VAR 0 5
90653: PUSH
90654: EMPTY
90655: ST_TO_ADDR
// for i in units do
90656: LD_ADDR_VAR 0 4
90660: PUSH
90661: LD_VAR 0 1
90665: PUSH
90666: FOR_IN
90667: IFFALSE 90705
// tmp := Insert ( tmp , tmp + 1 , GetLives ( i ) ) ;
90669: LD_ADDR_VAR 0 5
90673: PUSH
90674: LD_VAR 0 5
90678: PPUSH
90679: LD_VAR 0 5
90683: PUSH
90684: LD_INT 1
90686: PLUS
90687: PPUSH
90688: LD_VAR 0 4
90692: PPUSH
90693: CALL_OW 256
90697: PPUSH
90698: CALL_OW 2
90702: ST_TO_ADDR
90703: GO 90666
90705: POP
90706: POP
// if not tmp then
90707: LD_VAR 0 5
90711: NOT
90712: IFFALSE 90716
// exit ;
90714: GO 90764
// if asc then
90716: LD_VAR 0 2
90720: IFFALSE 90744
// result := SortListByListAsc ( units , tmp ) else
90722: LD_ADDR_VAR 0 3
90726: PUSH
90727: LD_VAR 0 1
90731: PPUSH
90732: LD_VAR 0 5
90736: PPUSH
90737: CALL_OW 76
90741: ST_TO_ADDR
90742: GO 90764
// result := SortListByListDesc ( units , tmp ) ;
90744: LD_ADDR_VAR 0 3
90748: PUSH
90749: LD_VAR 0 1
90753: PPUSH
90754: LD_VAR 0 5
90758: PPUSH
90759: CALL_OW 77
90763: ST_TO_ADDR
// end ;
90764: LD_VAR 0 3
90768: RET
// export function WantToRepairVehicle ( mech , vehicle ) ; var task ; begin
90769: LD_INT 0
90771: PPUSH
90772: PPUSH
// task := GetTaskList ( mech ) ;
90773: LD_ADDR_VAR 0 4
90777: PUSH
90778: LD_VAR 0 1
90782: PPUSH
90783: CALL_OW 437
90787: ST_TO_ADDR
// if not task then
90788: LD_VAR 0 4
90792: NOT
90793: IFFALSE 90797
// exit ;
90795: GO 90839
// result := task [ 1 ] [ 1 ] = r and task [ 1 ] [ 4 ] = vehicle ;
90797: LD_ADDR_VAR 0 3
90801: PUSH
90802: LD_VAR 0 4
90806: PUSH
90807: LD_INT 1
90809: ARRAY
90810: PUSH
90811: LD_INT 1
90813: ARRAY
90814: PUSH
90815: LD_STRING r
90817: EQUAL
90818: PUSH
90819: LD_VAR 0 4
90823: PUSH
90824: LD_INT 1
90826: ARRAY
90827: PUSH
90828: LD_INT 4
90830: ARRAY
90831: PUSH
90832: LD_VAR 0 2
90836: EQUAL
90837: AND
90838: ST_TO_ADDR
// end ;
90839: LD_VAR 0 3
90843: RET
// export function PlaceUnitXYD ( unit , x , y , d , mode ) ; begin
90844: LD_INT 0
90846: PPUSH
// SetDir ( unit , d ) ;
90847: LD_VAR 0 1
90851: PPUSH
90852: LD_VAR 0 4
90856: PPUSH
90857: CALL_OW 233
// PlaceUnitXY ( unit , x , y , mode ) ;
90861: LD_VAR 0 1
90865: PPUSH
90866: LD_VAR 0 2
90870: PPUSH
90871: LD_VAR 0 3
90875: PPUSH
90876: LD_VAR 0 5
90880: PPUSH
90881: CALL_OW 48
// end ;
90885: LD_VAR 0 6
90889: RET
// export function ToNaturalNumber ( number ) ; begin
90890: LD_INT 0
90892: PPUSH
// result := number div 1 ;
90893: LD_ADDR_VAR 0 2
90897: PUSH
90898: LD_VAR 0 1
90902: PUSH
90903: LD_INT 1
90905: DIV
90906: ST_TO_ADDR
// if number < 0 then
90907: LD_VAR 0 1
90911: PUSH
90912: LD_INT 0
90914: LESS
90915: IFFALSE 90925
// result := 0 ;
90917: LD_ADDR_VAR 0 2
90921: PUSH
90922: LD_INT 0
90924: ST_TO_ADDR
// end ;
90925: LD_VAR 0 2
90929: RET
// export function SortByClass ( units , class ) ; var un ; begin
90930: LD_INT 0
90932: PPUSH
90933: PPUSH
// if not units or not class then
90934: LD_VAR 0 1
90938: NOT
90939: PUSH
90940: LD_VAR 0 2
90944: NOT
90945: OR
90946: IFFALSE 90950
// exit ;
90948: GO 91045
// result := [ ] ;
90950: LD_ADDR_VAR 0 3
90954: PUSH
90955: EMPTY
90956: ST_TO_ADDR
// for un in units do
90957: LD_ADDR_VAR 0 4
90961: PUSH
90962: LD_VAR 0 1
90966: PUSH
90967: FOR_IN
90968: IFFALSE 91043
// if GetClass ( un ) = class then
90970: LD_VAR 0 4
90974: PPUSH
90975: CALL_OW 257
90979: PUSH
90980: LD_VAR 0 2
90984: EQUAL
90985: IFFALSE 91012
// result := Insert ( result , 1 , un ) else
90987: LD_ADDR_VAR 0 3
90991: PUSH
90992: LD_VAR 0 3
90996: PPUSH
90997: LD_INT 1
90999: PPUSH
91000: LD_VAR 0 4
91004: PPUSH
91005: CALL_OW 2
91009: ST_TO_ADDR
91010: GO 91041
// result := Replace ( result , result + 1 , un ) ;
91012: LD_ADDR_VAR 0 3
91016: PUSH
91017: LD_VAR 0 3
91021: PPUSH
91022: LD_VAR 0 3
91026: PUSH
91027: LD_INT 1
91029: PLUS
91030: PPUSH
91031: LD_VAR 0 4
91035: PPUSH
91036: CALL_OW 1
91040: ST_TO_ADDR
91041: GO 90967
91043: POP
91044: POP
// end ;
91045: LD_VAR 0 3
91049: RET
// export function GetCratesNearbyXY ( x , y , r ) ; var _x , _y , min_y , min_x , max_x , max_y ; begin
91050: LD_INT 0
91052: PPUSH
91053: PPUSH
91054: PPUSH
91055: PPUSH
91056: PPUSH
91057: PPUSH
91058: PPUSH
// result := [ ] ;
91059: LD_ADDR_VAR 0 4
91063: PUSH
91064: EMPTY
91065: ST_TO_ADDR
// if x - r < 0 then
91066: LD_VAR 0 1
91070: PUSH
91071: LD_VAR 0 3
91075: MINUS
91076: PUSH
91077: LD_INT 0
91079: LESS
91080: IFFALSE 91092
// min_x := 0 else
91082: LD_ADDR_VAR 0 8
91086: PUSH
91087: LD_INT 0
91089: ST_TO_ADDR
91090: GO 91108
// min_x := x - r ;
91092: LD_ADDR_VAR 0 8
91096: PUSH
91097: LD_VAR 0 1
91101: PUSH
91102: LD_VAR 0 3
91106: MINUS
91107: ST_TO_ADDR
// if y - r < 0 then
91108: LD_VAR 0 2
91112: PUSH
91113: LD_VAR 0 3
91117: MINUS
91118: PUSH
91119: LD_INT 0
91121: LESS
91122: IFFALSE 91134
// min_y := 0 else
91124: LD_ADDR_VAR 0 7
91128: PUSH
91129: LD_INT 0
91131: ST_TO_ADDR
91132: GO 91150
// min_y := y - r ;
91134: LD_ADDR_VAR 0 7
91138: PUSH
91139: LD_VAR 0 2
91143: PUSH
91144: LD_VAR 0 3
91148: MINUS
91149: ST_TO_ADDR
// max_x := x + r ;
91150: LD_ADDR_VAR 0 9
91154: PUSH
91155: LD_VAR 0 1
91159: PUSH
91160: LD_VAR 0 3
91164: PLUS
91165: ST_TO_ADDR
// max_y := y + r ;
91166: LD_ADDR_VAR 0 10
91170: PUSH
91171: LD_VAR 0 2
91175: PUSH
91176: LD_VAR 0 3
91180: PLUS
91181: ST_TO_ADDR
// for _x = min_x to max_x do
91182: LD_ADDR_VAR 0 5
91186: PUSH
91187: DOUBLE
91188: LD_VAR 0 8
91192: DEC
91193: ST_TO_ADDR
91194: LD_VAR 0 9
91198: PUSH
91199: FOR_TO
91200: IFFALSE 91301
// for _y = min_y to max_y do
91202: LD_ADDR_VAR 0 6
91206: PUSH
91207: DOUBLE
91208: LD_VAR 0 7
91212: DEC
91213: ST_TO_ADDR
91214: LD_VAR 0 10
91218: PUSH
91219: FOR_TO
91220: IFFALSE 91297
// begin if not ValidHex ( _x , _y ) then
91222: LD_VAR 0 5
91226: PPUSH
91227: LD_VAR 0 6
91231: PPUSH
91232: CALL_OW 488
91236: NOT
91237: IFFALSE 91241
// continue ;
91239: GO 91219
// if GetResourceTypeXY ( _x , _y ) then
91241: LD_VAR 0 5
91245: PPUSH
91246: LD_VAR 0 6
91250: PPUSH
91251: CALL_OW 283
91255: IFFALSE 91295
// result := Replace ( result , result + 1 , [ _x , _y ] ) ;
91257: LD_ADDR_VAR 0 4
91261: PUSH
91262: LD_VAR 0 4
91266: PPUSH
91267: LD_VAR 0 4
91271: PUSH
91272: LD_INT 1
91274: PLUS
91275: PPUSH
91276: LD_VAR 0 5
91280: PUSH
91281: LD_VAR 0 6
91285: PUSH
91286: EMPTY
91287: LIST
91288: LIST
91289: PPUSH
91290: CALL_OW 1
91294: ST_TO_ADDR
// end ;
91295: GO 91219
91297: POP
91298: POP
91299: GO 91199
91301: POP
91302: POP
// end ;
91303: LD_VAR 0 4
91307: RET
// export function AgressiveMove ( units , path ) ; var i , enemy , nearEnemy , cr , side , tag , ignoreCratesWeapon ; begin
91308: LD_INT 0
91310: PPUSH
91311: PPUSH
91312: PPUSH
91313: PPUSH
91314: PPUSH
91315: PPUSH
91316: PPUSH
91317: PPUSH
// if not units then
91318: LD_VAR 0 1
91322: NOT
91323: IFFALSE 91327
// exit ;
91325: GO 91752
// result := UnitFilter ( units , [ f_ok ] ) ;
91327: LD_ADDR_VAR 0 3
91331: PUSH
91332: LD_VAR 0 1
91336: PPUSH
91337: LD_INT 50
91339: PUSH
91340: EMPTY
91341: LIST
91342: PPUSH
91343: CALL_OW 72
91347: ST_TO_ADDR
// side := GetSide ( units [ 1 ] ) ;
91348: LD_ADDR_VAR 0 8
91352: PUSH
91353: LD_VAR 0 1
91357: PUSH
91358: LD_INT 1
91360: ARRAY
91361: PPUSH
91362: CALL_OW 255
91366: ST_TO_ADDR
// ignoreCratesWeapon := [ ar_selfpropelled_bomb , ar_bio_bomb ] ;
91367: LD_ADDR_VAR 0 10
91371: PUSH
91372: LD_INT 29
91374: PUSH
91375: LD_EXP 78
91379: PUSH
91380: EMPTY
91381: LIST
91382: LIST
91383: ST_TO_ADDR
// if not result then
91384: LD_VAR 0 3
91388: NOT
91389: IFFALSE 91393
// exit ;
91391: GO 91752
// enemy := FilterAllUnits ( [ f_enemy , side ] ) ;
91393: LD_ADDR_VAR 0 5
91397: PUSH
91398: LD_INT 81
91400: PUSH
91401: LD_VAR 0 8
91405: PUSH
91406: EMPTY
91407: LIST
91408: LIST
91409: PPUSH
91410: CALL_OW 69
91414: ST_TO_ADDR
// for i in result do
91415: LD_ADDR_VAR 0 4
91419: PUSH
91420: LD_VAR 0 3
91424: PUSH
91425: FOR_IN
91426: IFFALSE 91750
// begin tag := GetTag ( i ) + 1 ;
91428: LD_ADDR_VAR 0 9
91432: PUSH
91433: LD_VAR 0 4
91437: PPUSH
91438: CALL_OW 110
91442: PUSH
91443: LD_INT 1
91445: PLUS
91446: ST_TO_ADDR
// cr := GetCratesNearbyXY ( GetX ( i ) , GetY ( i ) , 6 ) ;
91447: LD_ADDR_VAR 0 7
91451: PUSH
91452: LD_VAR 0 4
91456: PPUSH
91457: CALL_OW 250
91461: PPUSH
91462: LD_VAR 0 4
91466: PPUSH
91467: CALL_OW 251
91471: PPUSH
91472: LD_INT 6
91474: PPUSH
91475: CALL 91050 0 3
91479: ST_TO_ADDR
// if cr and not GetWeapon ( i ) in ignoreCratesWeapon then
91480: LD_VAR 0 7
91484: PUSH
91485: LD_VAR 0 4
91489: PPUSH
91490: CALL_OW 264
91494: PUSH
91495: LD_VAR 0 10
91499: IN
91500: NOT
91501: AND
91502: IFFALSE 91541
// ComAttackPlace ( i , cr [ 1 ] [ 1 ] , cr [ 1 ] [ 2 ] ) else
91504: LD_VAR 0 4
91508: PPUSH
91509: LD_VAR 0 7
91513: PUSH
91514: LD_INT 1
91516: ARRAY
91517: PUSH
91518: LD_INT 1
91520: ARRAY
91521: PPUSH
91522: LD_VAR 0 7
91526: PUSH
91527: LD_INT 1
91529: ARRAY
91530: PUSH
91531: LD_INT 2
91533: ARRAY
91534: PPUSH
91535: CALL_OW 116
91539: GO 91748
// if path > tag then
91541: LD_VAR 0 2
91545: PUSH
91546: LD_VAR 0 9
91550: GREATER
91551: IFFALSE 91718
// begin nearEnemy := UnitFilter ( enemy , [ f_dist , i , 12 ] ) ;
91553: LD_ADDR_VAR 0 6
91557: PUSH
91558: LD_VAR 0 5
91562: PPUSH
91563: LD_INT 91
91565: PUSH
91566: LD_VAR 0 4
91570: PUSH
91571: LD_INT 12
91573: PUSH
91574: EMPTY
91575: LIST
91576: LIST
91577: LIST
91578: PPUSH
91579: CALL_OW 72
91583: ST_TO_ADDR
// if nearEnemy then
91584: LD_VAR 0 6
91588: IFFALSE 91616
// ComAttackUnit ( i , NearestUnitToUnit ( nearEnemy , i ) ) else
91590: LD_VAR 0 4
91594: PPUSH
91595: LD_VAR 0 6
91599: PPUSH
91600: LD_VAR 0 4
91604: PPUSH
91605: CALL_OW 74
91609: PPUSH
91610: CALL_OW 115
91614: GO 91716
// if GetDistUnitXY ( i , path [ tag ] [ 1 ] , path [ tag ] [ 2 ] ) > 6 then
91616: LD_VAR 0 4
91620: PPUSH
91621: LD_VAR 0 2
91625: PUSH
91626: LD_VAR 0 9
91630: ARRAY
91631: PUSH
91632: LD_INT 1
91634: ARRAY
91635: PPUSH
91636: LD_VAR 0 2
91640: PUSH
91641: LD_VAR 0 9
91645: ARRAY
91646: PUSH
91647: LD_INT 2
91649: ARRAY
91650: PPUSH
91651: CALL_OW 297
91655: PUSH
91656: LD_INT 6
91658: GREATER
91659: IFFALSE 91702
// ComAgressiveMove ( i , path [ tag ] [ 1 ] , path [ tag ] [ 2 ] ) else
91661: LD_VAR 0 4
91665: PPUSH
91666: LD_VAR 0 2
91670: PUSH
91671: LD_VAR 0 9
91675: ARRAY
91676: PUSH
91677: LD_INT 1
91679: ARRAY
91680: PPUSH
91681: LD_VAR 0 2
91685: PUSH
91686: LD_VAR 0 9
91690: ARRAY
91691: PUSH
91692: LD_INT 2
91694: ARRAY
91695: PPUSH
91696: CALL_OW 114
91700: GO 91716
// SetTag ( i , tag ) ;
91702: LD_VAR 0 4
91706: PPUSH
91707: LD_VAR 0 9
91711: PPUSH
91712: CALL_OW 109
// end else
91716: GO 91748
// if enemy then
91718: LD_VAR 0 5
91722: IFFALSE 91748
// ComAttackUnit ( i , NearestUnitToUnit ( enemy , i ) ) ;
91724: LD_VAR 0 4
91728: PPUSH
91729: LD_VAR 0 5
91733: PPUSH
91734: LD_VAR 0 4
91738: PPUSH
91739: CALL_OW 74
91743: PPUSH
91744: CALL_OW 115
// end ;
91748: GO 91425
91750: POP
91751: POP
// end ;
91752: LD_VAR 0 3
91756: RET
// export function ComLookAtDir ( unit , direction ) ; var x , y ; begin
91757: LD_INT 0
91759: PPUSH
91760: PPUSH
91761: PPUSH
// if not unit or IsInUnit ( unit ) then
91762: LD_VAR 0 1
91766: NOT
91767: PUSH
91768: LD_VAR 0 1
91772: PPUSH
91773: CALL_OW 310
91777: OR
91778: IFFALSE 91782
// exit ;
91780: GO 91873
// x := ShiftX ( GetX ( unit ) , direction , 1 ) ;
91782: LD_ADDR_VAR 0 4
91786: PUSH
91787: LD_VAR 0 1
91791: PPUSH
91792: CALL_OW 250
91796: PPUSH
91797: LD_VAR 0 2
91801: PPUSH
91802: LD_INT 1
91804: PPUSH
91805: CALL_OW 272
91809: ST_TO_ADDR
// y := ShiftY ( GetY ( unit ) , direction , 1 ) ;
91810: LD_ADDR_VAR 0 5
91814: PUSH
91815: LD_VAR 0 1
91819: PPUSH
91820: CALL_OW 251
91824: PPUSH
91825: LD_VAR 0 2
91829: PPUSH
91830: LD_INT 1
91832: PPUSH
91833: CALL_OW 273
91837: ST_TO_ADDR
// if ValidHex ( x , y ) then
91838: LD_VAR 0 4
91842: PPUSH
91843: LD_VAR 0 5
91847: PPUSH
91848: CALL_OW 488
91852: IFFALSE 91873
// ComTurnXY ( unit , x , y ) ;
91854: LD_VAR 0 1
91858: PPUSH
91859: LD_VAR 0 4
91863: PPUSH
91864: LD_VAR 0 5
91868: PPUSH
91869: CALL_OW 118
// end ;
91873: LD_VAR 0 3
91877: RET
// export function SeeUnits ( side , units ) ; var i ; begin
91878: LD_INT 0
91880: PPUSH
91881: PPUSH
// result := false ;
91882: LD_ADDR_VAR 0 3
91886: PUSH
91887: LD_INT 0
91889: ST_TO_ADDR
// if not units then
91890: LD_VAR 0 2
91894: NOT
91895: IFFALSE 91899
// exit ;
91897: GO 91944
// for i in units do
91899: LD_ADDR_VAR 0 4
91903: PUSH
91904: LD_VAR 0 2
91908: PUSH
91909: FOR_IN
91910: IFFALSE 91942
// if See ( side , i ) then
91912: LD_VAR 0 1
91916: PPUSH
91917: LD_VAR 0 4
91921: PPUSH
91922: CALL_OW 292
91926: IFFALSE 91940
// begin result := true ;
91928: LD_ADDR_VAR 0 3
91932: PUSH
91933: LD_INT 1
91935: ST_TO_ADDR
// exit ;
91936: POP
91937: POP
91938: GO 91944
// end ;
91940: GO 91909
91942: POP
91943: POP
// end ;
91944: LD_VAR 0 3
91948: RET
// export function GetNearestPoint ( unit , points ) ; var i , dist , tmpDist ; begin
91949: LD_INT 0
91951: PPUSH
91952: PPUSH
91953: PPUSH
91954: PPUSH
// if not unit or not points then
91955: LD_VAR 0 1
91959: NOT
91960: PUSH
91961: LD_VAR 0 2
91965: NOT
91966: OR
91967: IFFALSE 91971
// exit ;
91969: GO 92061
// dist := 99999 ;
91971: LD_ADDR_VAR 0 5
91975: PUSH
91976: LD_INT 99999
91978: ST_TO_ADDR
// for i in points do
91979: LD_ADDR_VAR 0 4
91983: PUSH
91984: LD_VAR 0 2
91988: PUSH
91989: FOR_IN
91990: IFFALSE 92059
// begin tmpDist := GetDistUnitXY ( unit , i [ 1 ] , i [ 2 ] ) ;
91992: LD_ADDR_VAR 0 6
91996: PUSH
91997: LD_VAR 0 1
92001: PPUSH
92002: LD_VAR 0 4
92006: PUSH
92007: LD_INT 1
92009: ARRAY
92010: PPUSH
92011: LD_VAR 0 4
92015: PUSH
92016: LD_INT 2
92018: ARRAY
92019: PPUSH
92020: CALL_OW 297
92024: ST_TO_ADDR
// if tmpDist < dist then
92025: LD_VAR 0 6
92029: PUSH
92030: LD_VAR 0 5
92034: LESS
92035: IFFALSE 92057
// begin result := i ;
92037: LD_ADDR_VAR 0 3
92041: PUSH
92042: LD_VAR 0 4
92046: ST_TO_ADDR
// dist := tmpDist ;
92047: LD_ADDR_VAR 0 5
92051: PUSH
92052: LD_VAR 0 6
92056: ST_TO_ADDR
// end ; end ;
92057: GO 91989
92059: POP
92060: POP
// end ; end_of_file end_of_file
92061: LD_VAR 0 3
92065: RET
// every 0 0$1 do
92066: GO 92068
92068: DISABLE
// begin enable ;
92069: ENABLE
// ToLua ( updateTimer( & tick & ); ) ;
92070: LD_STRING updateTimer(
92072: PUSH
92073: LD_OWVAR 1
92077: STR
92078: PUSH
92079: LD_STRING );
92081: STR
92082: PPUSH
92083: CALL_OW 559
// end ;
92087: END
// export function SOS_MapStart ( ) ; begin
92088: LD_INT 0
92090: PPUSH
// if streamModeActive then
92091: LD_EXP 139
92095: IFFALSE 92104
// DefineStreamItems ( true ) ;
92097: LD_INT 1
92099: PPUSH
92100: CALL 93754 0 1
// UpdateFactoryWaypoints ( ) ;
92104: CALL 107338 0 0
// end ;
92108: LD_VAR 0 1
92112: RET
// export function SOS_CustomCommand ( p1 , p2 , p3 , p4 , p5 , p6 ) ; begin
92113: LD_INT 0
92115: PPUSH
// if p2 = 100 then
92116: LD_VAR 0 2
92120: PUSH
92121: LD_INT 100
92123: EQUAL
92124: IFFALSE 93127
// begin if not StreamModeActive then
92126: LD_EXP 139
92130: NOT
92131: IFFALSE 92141
// StreamModeActive := true ;
92133: LD_ADDR_EXP 139
92137: PUSH
92138: LD_INT 1
92140: ST_TO_ADDR
// if p3 = 0 then
92141: LD_VAR 0 3
92145: PUSH
92146: LD_INT 0
92148: EQUAL
92149: IFFALSE 92155
// InitStreamMode ;
92151: CALL 93290 0 0
// if p3 = 1 then
92155: LD_VAR 0 3
92159: PUSH
92160: LD_INT 1
92162: EQUAL
92163: IFFALSE 92173
// sRocket := true ;
92165: LD_ADDR_EXP 144
92169: PUSH
92170: LD_INT 1
92172: ST_TO_ADDR
// if p3 = 2 then
92173: LD_VAR 0 3
92177: PUSH
92178: LD_INT 2
92180: EQUAL
92181: IFFALSE 92191
// sSpeed := true ;
92183: LD_ADDR_EXP 143
92187: PUSH
92188: LD_INT 1
92190: ST_TO_ADDR
// if p3 = 3 then
92191: LD_VAR 0 3
92195: PUSH
92196: LD_INT 3
92198: EQUAL
92199: IFFALSE 92209
// sEngine := true ;
92201: LD_ADDR_EXP 145
92205: PUSH
92206: LD_INT 1
92208: ST_TO_ADDR
// if p3 = 4 then
92209: LD_VAR 0 3
92213: PUSH
92214: LD_INT 4
92216: EQUAL
92217: IFFALSE 92227
// sSpec := true ;
92219: LD_ADDR_EXP 142
92223: PUSH
92224: LD_INT 1
92226: ST_TO_ADDR
// if p3 = 5 then
92227: LD_VAR 0 3
92231: PUSH
92232: LD_INT 5
92234: EQUAL
92235: IFFALSE 92245
// sLevel := true ;
92237: LD_ADDR_EXP 146
92241: PUSH
92242: LD_INT 1
92244: ST_TO_ADDR
// if p3 = 6 then
92245: LD_VAR 0 3
92249: PUSH
92250: LD_INT 6
92252: EQUAL
92253: IFFALSE 92263
// sArmoury := true ;
92255: LD_ADDR_EXP 147
92259: PUSH
92260: LD_INT 1
92262: ST_TO_ADDR
// if p3 = 7 then
92263: LD_VAR 0 3
92267: PUSH
92268: LD_INT 7
92270: EQUAL
92271: IFFALSE 92281
// sRadar := true ;
92273: LD_ADDR_EXP 148
92277: PUSH
92278: LD_INT 1
92280: ST_TO_ADDR
// if p3 = 8 then
92281: LD_VAR 0 3
92285: PUSH
92286: LD_INT 8
92288: EQUAL
92289: IFFALSE 92299
// sBunker := true ;
92291: LD_ADDR_EXP 149
92295: PUSH
92296: LD_INT 1
92298: ST_TO_ADDR
// if p3 = 9 then
92299: LD_VAR 0 3
92303: PUSH
92304: LD_INT 9
92306: EQUAL
92307: IFFALSE 92317
// sHack := true ;
92309: LD_ADDR_EXP 150
92313: PUSH
92314: LD_INT 1
92316: ST_TO_ADDR
// if p3 = 10 then
92317: LD_VAR 0 3
92321: PUSH
92322: LD_INT 10
92324: EQUAL
92325: IFFALSE 92335
// sFire := true ;
92327: LD_ADDR_EXP 151
92331: PUSH
92332: LD_INT 1
92334: ST_TO_ADDR
// if p3 = 11 then
92335: LD_VAR 0 3
92339: PUSH
92340: LD_INT 11
92342: EQUAL
92343: IFFALSE 92353
// sRefresh := true ;
92345: LD_ADDR_EXP 152
92349: PUSH
92350: LD_INT 1
92352: ST_TO_ADDR
// if p3 = 12 then
92353: LD_VAR 0 3
92357: PUSH
92358: LD_INT 12
92360: EQUAL
92361: IFFALSE 92371
// sExp := true ;
92363: LD_ADDR_EXP 153
92367: PUSH
92368: LD_INT 1
92370: ST_TO_ADDR
// if p3 = 13 then
92371: LD_VAR 0 3
92375: PUSH
92376: LD_INT 13
92378: EQUAL
92379: IFFALSE 92389
// sDepot := true ;
92381: LD_ADDR_EXP 154
92385: PUSH
92386: LD_INT 1
92388: ST_TO_ADDR
// if p3 = 14 then
92389: LD_VAR 0 3
92393: PUSH
92394: LD_INT 14
92396: EQUAL
92397: IFFALSE 92407
// sFlag := true ;
92399: LD_ADDR_EXP 155
92403: PUSH
92404: LD_INT 1
92406: ST_TO_ADDR
// if p3 = 15 then
92407: LD_VAR 0 3
92411: PUSH
92412: LD_INT 15
92414: EQUAL
92415: IFFALSE 92425
// sKamikadze := true ;
92417: LD_ADDR_EXP 163
92421: PUSH
92422: LD_INT 1
92424: ST_TO_ADDR
// if p3 = 16 then
92425: LD_VAR 0 3
92429: PUSH
92430: LD_INT 16
92432: EQUAL
92433: IFFALSE 92443
// sTroll := true ;
92435: LD_ADDR_EXP 164
92439: PUSH
92440: LD_INT 1
92442: ST_TO_ADDR
// if p3 = 17 then
92443: LD_VAR 0 3
92447: PUSH
92448: LD_INT 17
92450: EQUAL
92451: IFFALSE 92461
// sSlow := true ;
92453: LD_ADDR_EXP 165
92457: PUSH
92458: LD_INT 1
92460: ST_TO_ADDR
// if p3 = 18 then
92461: LD_VAR 0 3
92465: PUSH
92466: LD_INT 18
92468: EQUAL
92469: IFFALSE 92479
// sLack := true ;
92471: LD_ADDR_EXP 166
92475: PUSH
92476: LD_INT 1
92478: ST_TO_ADDR
// if p3 = 19 then
92479: LD_VAR 0 3
92483: PUSH
92484: LD_INT 19
92486: EQUAL
92487: IFFALSE 92497
// sTank := true ;
92489: LD_ADDR_EXP 168
92493: PUSH
92494: LD_INT 1
92496: ST_TO_ADDR
// if p3 = 20 then
92497: LD_VAR 0 3
92501: PUSH
92502: LD_INT 20
92504: EQUAL
92505: IFFALSE 92515
// sRemote := true ;
92507: LD_ADDR_EXP 169
92511: PUSH
92512: LD_INT 1
92514: ST_TO_ADDR
// if p3 = 21 then
92515: LD_VAR 0 3
92519: PUSH
92520: LD_INT 21
92522: EQUAL
92523: IFFALSE 92533
// sPowell := true ;
92525: LD_ADDR_EXP 170
92529: PUSH
92530: LD_INT 1
92532: ST_TO_ADDR
// if p3 = 22 then
92533: LD_VAR 0 3
92537: PUSH
92538: LD_INT 22
92540: EQUAL
92541: IFFALSE 92551
// sTeleport := true ;
92543: LD_ADDR_EXP 173
92547: PUSH
92548: LD_INT 1
92550: ST_TO_ADDR
// if p3 = 23 then
92551: LD_VAR 0 3
92555: PUSH
92556: LD_INT 23
92558: EQUAL
92559: IFFALSE 92569
// sOilTower := true ;
92561: LD_ADDR_EXP 175
92565: PUSH
92566: LD_INT 1
92568: ST_TO_ADDR
// if p3 = 24 then
92569: LD_VAR 0 3
92573: PUSH
92574: LD_INT 24
92576: EQUAL
92577: IFFALSE 92587
// sShovel := true ;
92579: LD_ADDR_EXP 176
92583: PUSH
92584: LD_INT 1
92586: ST_TO_ADDR
// if p3 = 25 then
92587: LD_VAR 0 3
92591: PUSH
92592: LD_INT 25
92594: EQUAL
92595: IFFALSE 92605
// sSheik := true ;
92597: LD_ADDR_EXP 177
92601: PUSH
92602: LD_INT 1
92604: ST_TO_ADDR
// if p3 = 26 then
92605: LD_VAR 0 3
92609: PUSH
92610: LD_INT 26
92612: EQUAL
92613: IFFALSE 92623
// sEarthquake := true ;
92615: LD_ADDR_EXP 179
92619: PUSH
92620: LD_INT 1
92622: ST_TO_ADDR
// if p3 = 27 then
92623: LD_VAR 0 3
92627: PUSH
92628: LD_INT 27
92630: EQUAL
92631: IFFALSE 92641
// sAI := true ;
92633: LD_ADDR_EXP 180
92637: PUSH
92638: LD_INT 1
92640: ST_TO_ADDR
// if p3 = 28 then
92641: LD_VAR 0 3
92645: PUSH
92646: LD_INT 28
92648: EQUAL
92649: IFFALSE 92659
// sCargo := true ;
92651: LD_ADDR_EXP 183
92655: PUSH
92656: LD_INT 1
92658: ST_TO_ADDR
// if p3 = 29 then
92659: LD_VAR 0 3
92663: PUSH
92664: LD_INT 29
92666: EQUAL
92667: IFFALSE 92677
// sDLaser := true ;
92669: LD_ADDR_EXP 184
92673: PUSH
92674: LD_INT 1
92676: ST_TO_ADDR
// if p3 = 30 then
92677: LD_VAR 0 3
92681: PUSH
92682: LD_INT 30
92684: EQUAL
92685: IFFALSE 92695
// sExchange := true ;
92687: LD_ADDR_EXP 185
92691: PUSH
92692: LD_INT 1
92694: ST_TO_ADDR
// if p3 = 31 then
92695: LD_VAR 0 3
92699: PUSH
92700: LD_INT 31
92702: EQUAL
92703: IFFALSE 92713
// sFac := true ;
92705: LD_ADDR_EXP 186
92709: PUSH
92710: LD_INT 1
92712: ST_TO_ADDR
// if p3 = 32 then
92713: LD_VAR 0 3
92717: PUSH
92718: LD_INT 32
92720: EQUAL
92721: IFFALSE 92731
// sPower := true ;
92723: LD_ADDR_EXP 187
92727: PUSH
92728: LD_INT 1
92730: ST_TO_ADDR
// if p3 = 33 then
92731: LD_VAR 0 3
92735: PUSH
92736: LD_INT 33
92738: EQUAL
92739: IFFALSE 92749
// sRandom := true ;
92741: LD_ADDR_EXP 188
92745: PUSH
92746: LD_INT 1
92748: ST_TO_ADDR
// if p3 = 34 then
92749: LD_VAR 0 3
92753: PUSH
92754: LD_INT 34
92756: EQUAL
92757: IFFALSE 92767
// sShield := true ;
92759: LD_ADDR_EXP 189
92763: PUSH
92764: LD_INT 1
92766: ST_TO_ADDR
// if p3 = 35 then
92767: LD_VAR 0 3
92771: PUSH
92772: LD_INT 35
92774: EQUAL
92775: IFFALSE 92785
// sTime := true ;
92777: LD_ADDR_EXP 190
92781: PUSH
92782: LD_INT 1
92784: ST_TO_ADDR
// if p3 = 36 then
92785: LD_VAR 0 3
92789: PUSH
92790: LD_INT 36
92792: EQUAL
92793: IFFALSE 92803
// sTools := true ;
92795: LD_ADDR_EXP 191
92799: PUSH
92800: LD_INT 1
92802: ST_TO_ADDR
// if p3 = 101 then
92803: LD_VAR 0 3
92807: PUSH
92808: LD_INT 101
92810: EQUAL
92811: IFFALSE 92821
// sSold := true ;
92813: LD_ADDR_EXP 156
92817: PUSH
92818: LD_INT 1
92820: ST_TO_ADDR
// if p3 = 102 then
92821: LD_VAR 0 3
92825: PUSH
92826: LD_INT 102
92828: EQUAL
92829: IFFALSE 92839
// sDiff := true ;
92831: LD_ADDR_EXP 157
92835: PUSH
92836: LD_INT 1
92838: ST_TO_ADDR
// if p3 = 103 then
92839: LD_VAR 0 3
92843: PUSH
92844: LD_INT 103
92846: EQUAL
92847: IFFALSE 92857
// sFog := true ;
92849: LD_ADDR_EXP 160
92853: PUSH
92854: LD_INT 1
92856: ST_TO_ADDR
// if p3 = 104 then
92857: LD_VAR 0 3
92861: PUSH
92862: LD_INT 104
92864: EQUAL
92865: IFFALSE 92875
// sReset := true ;
92867: LD_ADDR_EXP 161
92871: PUSH
92872: LD_INT 1
92874: ST_TO_ADDR
// if p3 = 105 then
92875: LD_VAR 0 3
92879: PUSH
92880: LD_INT 105
92882: EQUAL
92883: IFFALSE 92893
// sSun := true ;
92885: LD_ADDR_EXP 162
92889: PUSH
92890: LD_INT 1
92892: ST_TO_ADDR
// if p3 = 106 then
92893: LD_VAR 0 3
92897: PUSH
92898: LD_INT 106
92900: EQUAL
92901: IFFALSE 92911
// sTiger := true ;
92903: LD_ADDR_EXP 158
92907: PUSH
92908: LD_INT 1
92910: ST_TO_ADDR
// if p3 = 107 then
92911: LD_VAR 0 3
92915: PUSH
92916: LD_INT 107
92918: EQUAL
92919: IFFALSE 92929
// sBomb := true ;
92921: LD_ADDR_EXP 159
92925: PUSH
92926: LD_INT 1
92928: ST_TO_ADDR
// if p3 = 108 then
92929: LD_VAR 0 3
92933: PUSH
92934: LD_INT 108
92936: EQUAL
92937: IFFALSE 92947
// sWound := true ;
92939: LD_ADDR_EXP 167
92943: PUSH
92944: LD_INT 1
92946: ST_TO_ADDR
// if p3 = 109 then
92947: LD_VAR 0 3
92951: PUSH
92952: LD_INT 109
92954: EQUAL
92955: IFFALSE 92965
// sBetray := true ;
92957: LD_ADDR_EXP 171
92961: PUSH
92962: LD_INT 1
92964: ST_TO_ADDR
// if p3 = 110 then
92965: LD_VAR 0 3
92969: PUSH
92970: LD_INT 110
92972: EQUAL
92973: IFFALSE 92983
// sContamin := true ;
92975: LD_ADDR_EXP 172
92979: PUSH
92980: LD_INT 1
92982: ST_TO_ADDR
// if p3 = 111 then
92983: LD_VAR 0 3
92987: PUSH
92988: LD_INT 111
92990: EQUAL
92991: IFFALSE 93001
// sOil := true ;
92993: LD_ADDR_EXP 174
92997: PUSH
92998: LD_INT 1
93000: ST_TO_ADDR
// if p3 = 112 then
93001: LD_VAR 0 3
93005: PUSH
93006: LD_INT 112
93008: EQUAL
93009: IFFALSE 93019
// sStu := true ;
93011: LD_ADDR_EXP 178
93015: PUSH
93016: LD_INT 1
93018: ST_TO_ADDR
// if p3 = 113 then
93019: LD_VAR 0 3
93023: PUSH
93024: LD_INT 113
93026: EQUAL
93027: IFFALSE 93037
// sBazooka := true ;
93029: LD_ADDR_EXP 181
93033: PUSH
93034: LD_INT 1
93036: ST_TO_ADDR
// if p3 = 114 then
93037: LD_VAR 0 3
93041: PUSH
93042: LD_INT 114
93044: EQUAL
93045: IFFALSE 93055
// sMortar := true ;
93047: LD_ADDR_EXP 182
93051: PUSH
93052: LD_INT 1
93054: ST_TO_ADDR
// if p3 = 115 then
93055: LD_VAR 0 3
93059: PUSH
93060: LD_INT 115
93062: EQUAL
93063: IFFALSE 93073
// sRanger := true ;
93065: LD_ADDR_EXP 192
93069: PUSH
93070: LD_INT 1
93072: ST_TO_ADDR
// if p3 = 116 then
93073: LD_VAR 0 3
93077: PUSH
93078: LD_INT 116
93080: EQUAL
93081: IFFALSE 93091
// sComputer := true ;
93083: LD_ADDR_EXP 193
93087: PUSH
93088: LD_INT 1
93090: ST_TO_ADDR
// if p3 = 117 then
93091: LD_VAR 0 3
93095: PUSH
93096: LD_INT 117
93098: EQUAL
93099: IFFALSE 93109
// s30 := true ;
93101: LD_ADDR_EXP 194
93105: PUSH
93106: LD_INT 1
93108: ST_TO_ADDR
// if p3 = 118 then
93109: LD_VAR 0 3
93113: PUSH
93114: LD_INT 118
93116: EQUAL
93117: IFFALSE 93127
// s60 := true ;
93119: LD_ADDR_EXP 195
93123: PUSH
93124: LD_INT 1
93126: ST_TO_ADDR
// end ; if p2 = 101 then
93127: LD_VAR 0 2
93131: PUSH
93132: LD_INT 101
93134: EQUAL
93135: IFFALSE 93263
// begin case p3 of 1 :
93137: LD_VAR 0 3
93141: PUSH
93142: LD_INT 1
93144: DOUBLE
93145: EQUAL
93146: IFTRUE 93150
93148: GO 93157
93150: POP
// hHackUnlimitedResources ; 2 :
93151: CALL 105361 0 0
93155: GO 93263
93157: LD_INT 2
93159: DOUBLE
93160: EQUAL
93161: IFTRUE 93165
93163: GO 93172
93165: POP
// hHackSetLevel10 ; 3 :
93166: CALL 105494 0 0
93170: GO 93263
93172: LD_INT 3
93174: DOUBLE
93175: EQUAL
93176: IFTRUE 93180
93178: GO 93187
93180: POP
// hHackSetLevel10YourUnits ; 4 :
93181: CALL 105579 0 0
93185: GO 93263
93187: LD_INT 4
93189: DOUBLE
93190: EQUAL
93191: IFTRUE 93195
93193: GO 93202
93195: POP
// hHackInvincible ; 5 :
93196: CALL 106027 0 0
93200: GO 93263
93202: LD_INT 5
93204: DOUBLE
93205: EQUAL
93206: IFTRUE 93210
93208: GO 93217
93210: POP
// hHackInvisible ; 6 :
93211: CALL 106138 0 0
93215: GO 93263
93217: LD_INT 6
93219: DOUBLE
93220: EQUAL
93221: IFTRUE 93225
93223: GO 93232
93225: POP
// hHackChangeYourSide ; 7 :
93226: CALL 106195 0 0
93230: GO 93263
93232: LD_INT 7
93234: DOUBLE
93235: EQUAL
93236: IFTRUE 93240
93238: GO 93247
93240: POP
// hHackChangeUnitSide ; 8 :
93241: CALL 106237 0 0
93245: GO 93263
93247: LD_INT 8
93249: DOUBLE
93250: EQUAL
93251: IFTRUE 93255
93253: GO 93262
93255: POP
// hHackFog ; end ;
93256: CALL 106338 0 0
93260: GO 93263
93262: POP
// end ; end ;
93263: LD_VAR 0 7
93267: RET
// export StreamModeActive , normalCounter , hardcoreCounter , sSpec , sSpeed , sRocket , sEngine , sLevel , sArmoury , sRadar , sBunker , sHack , sFire , sRefresh , sExp , sDepot , sFlag , sSold , sDiff , sTiger , sBomb , sFog , sReset , sSun , sKamikadze , sTroll , sSlow , sLack , sWound , sTank , sRemote , sPowell , sBetray , sContamin , sTeleport , sOil , sOilTower , sShovel , sSheik , sStu , sEarthquake , sAI , sBazooka , sMortar , sCargo , sDLaser , sExchange , sFac , sPower , sRandom , sShield , sTime , sTools , sRanger , sComputer , s30 , s60 ; every 0 0$1 do
93268: GO 93270
93270: DISABLE
// begin ToLua ( initStreamRollete(); ) ;
93271: LD_STRING initStreamRollete();
93273: PPUSH
93274: CALL_OW 559
// InitStreamMode ;
93278: CALL 93290 0 0
// DefineStreamItems ( false ) ;
93282: LD_INT 0
93284: PPUSH
93285: CALL 93754 0 1
// end ;
93289: END
// function InitStreamMode ; begin
93290: LD_INT 0
93292: PPUSH
// streamModeActive := false ;
93293: LD_ADDR_EXP 139
93297: PUSH
93298: LD_INT 0
93300: ST_TO_ADDR
// normalCounter := 36 ;
93301: LD_ADDR_EXP 140
93305: PUSH
93306: LD_INT 36
93308: ST_TO_ADDR
// hardcoreCounter := 18 ;
93309: LD_ADDR_EXP 141
93313: PUSH
93314: LD_INT 18
93316: ST_TO_ADDR
// sRocket := false ;
93317: LD_ADDR_EXP 144
93321: PUSH
93322: LD_INT 0
93324: ST_TO_ADDR
// sSpeed := false ;
93325: LD_ADDR_EXP 143
93329: PUSH
93330: LD_INT 0
93332: ST_TO_ADDR
// sEngine := false ;
93333: LD_ADDR_EXP 145
93337: PUSH
93338: LD_INT 0
93340: ST_TO_ADDR
// sSpec := false ;
93341: LD_ADDR_EXP 142
93345: PUSH
93346: LD_INT 0
93348: ST_TO_ADDR
// sLevel := false ;
93349: LD_ADDR_EXP 146
93353: PUSH
93354: LD_INT 0
93356: ST_TO_ADDR
// sArmoury := false ;
93357: LD_ADDR_EXP 147
93361: PUSH
93362: LD_INT 0
93364: ST_TO_ADDR
// sRadar := false ;
93365: LD_ADDR_EXP 148
93369: PUSH
93370: LD_INT 0
93372: ST_TO_ADDR
// sBunker := false ;
93373: LD_ADDR_EXP 149
93377: PUSH
93378: LD_INT 0
93380: ST_TO_ADDR
// sHack := false ;
93381: LD_ADDR_EXP 150
93385: PUSH
93386: LD_INT 0
93388: ST_TO_ADDR
// sFire := false ;
93389: LD_ADDR_EXP 151
93393: PUSH
93394: LD_INT 0
93396: ST_TO_ADDR
// sRefresh := false ;
93397: LD_ADDR_EXP 152
93401: PUSH
93402: LD_INT 0
93404: ST_TO_ADDR
// sExp := false ;
93405: LD_ADDR_EXP 153
93409: PUSH
93410: LD_INT 0
93412: ST_TO_ADDR
// sDepot := false ;
93413: LD_ADDR_EXP 154
93417: PUSH
93418: LD_INT 0
93420: ST_TO_ADDR
// sFlag := false ;
93421: LD_ADDR_EXP 155
93425: PUSH
93426: LD_INT 0
93428: ST_TO_ADDR
// sKamikadze := false ;
93429: LD_ADDR_EXP 163
93433: PUSH
93434: LD_INT 0
93436: ST_TO_ADDR
// sTroll := false ;
93437: LD_ADDR_EXP 164
93441: PUSH
93442: LD_INT 0
93444: ST_TO_ADDR
// sSlow := false ;
93445: LD_ADDR_EXP 165
93449: PUSH
93450: LD_INT 0
93452: ST_TO_ADDR
// sLack := false ;
93453: LD_ADDR_EXP 166
93457: PUSH
93458: LD_INT 0
93460: ST_TO_ADDR
// sTank := false ;
93461: LD_ADDR_EXP 168
93465: PUSH
93466: LD_INT 0
93468: ST_TO_ADDR
// sRemote := false ;
93469: LD_ADDR_EXP 169
93473: PUSH
93474: LD_INT 0
93476: ST_TO_ADDR
// sPowell := false ;
93477: LD_ADDR_EXP 170
93481: PUSH
93482: LD_INT 0
93484: ST_TO_ADDR
// sTeleport := false ;
93485: LD_ADDR_EXP 173
93489: PUSH
93490: LD_INT 0
93492: ST_TO_ADDR
// sOilTower := false ;
93493: LD_ADDR_EXP 175
93497: PUSH
93498: LD_INT 0
93500: ST_TO_ADDR
// sShovel := false ;
93501: LD_ADDR_EXP 176
93505: PUSH
93506: LD_INT 0
93508: ST_TO_ADDR
// sSheik := false ;
93509: LD_ADDR_EXP 177
93513: PUSH
93514: LD_INT 0
93516: ST_TO_ADDR
// sEarthquake := false ;
93517: LD_ADDR_EXP 179
93521: PUSH
93522: LD_INT 0
93524: ST_TO_ADDR
// sAI := false ;
93525: LD_ADDR_EXP 180
93529: PUSH
93530: LD_INT 0
93532: ST_TO_ADDR
// sCargo := false ;
93533: LD_ADDR_EXP 183
93537: PUSH
93538: LD_INT 0
93540: ST_TO_ADDR
// sDLaser := false ;
93541: LD_ADDR_EXP 184
93545: PUSH
93546: LD_INT 0
93548: ST_TO_ADDR
// sExchange := false ;
93549: LD_ADDR_EXP 185
93553: PUSH
93554: LD_INT 0
93556: ST_TO_ADDR
// sFac := false ;
93557: LD_ADDR_EXP 186
93561: PUSH
93562: LD_INT 0
93564: ST_TO_ADDR
// sPower := false ;
93565: LD_ADDR_EXP 187
93569: PUSH
93570: LD_INT 0
93572: ST_TO_ADDR
// sRandom := false ;
93573: LD_ADDR_EXP 188
93577: PUSH
93578: LD_INT 0
93580: ST_TO_ADDR
// sShield := false ;
93581: LD_ADDR_EXP 189
93585: PUSH
93586: LD_INT 0
93588: ST_TO_ADDR
// sTime := false ;
93589: LD_ADDR_EXP 190
93593: PUSH
93594: LD_INT 0
93596: ST_TO_ADDR
// sTools := false ;
93597: LD_ADDR_EXP 191
93601: PUSH
93602: LD_INT 0
93604: ST_TO_ADDR
// sSold := false ;
93605: LD_ADDR_EXP 156
93609: PUSH
93610: LD_INT 0
93612: ST_TO_ADDR
// sDiff := false ;
93613: LD_ADDR_EXP 157
93617: PUSH
93618: LD_INT 0
93620: ST_TO_ADDR
// sFog := false ;
93621: LD_ADDR_EXP 160
93625: PUSH
93626: LD_INT 0
93628: ST_TO_ADDR
// sReset := false ;
93629: LD_ADDR_EXP 161
93633: PUSH
93634: LD_INT 0
93636: ST_TO_ADDR
// sSun := false ;
93637: LD_ADDR_EXP 162
93641: PUSH
93642: LD_INT 0
93644: ST_TO_ADDR
// sTiger := false ;
93645: LD_ADDR_EXP 158
93649: PUSH
93650: LD_INT 0
93652: ST_TO_ADDR
// sBomb := false ;
93653: LD_ADDR_EXP 159
93657: PUSH
93658: LD_INT 0
93660: ST_TO_ADDR
// sWound := false ;
93661: LD_ADDR_EXP 167
93665: PUSH
93666: LD_INT 0
93668: ST_TO_ADDR
// sBetray := false ;
93669: LD_ADDR_EXP 171
93673: PUSH
93674: LD_INT 0
93676: ST_TO_ADDR
// sContamin := false ;
93677: LD_ADDR_EXP 172
93681: PUSH
93682: LD_INT 0
93684: ST_TO_ADDR
// sOil := false ;
93685: LD_ADDR_EXP 174
93689: PUSH
93690: LD_INT 0
93692: ST_TO_ADDR
// sStu := false ;
93693: LD_ADDR_EXP 178
93697: PUSH
93698: LD_INT 0
93700: ST_TO_ADDR
// sBazooka := false ;
93701: LD_ADDR_EXP 181
93705: PUSH
93706: LD_INT 0
93708: ST_TO_ADDR
// sMortar := false ;
93709: LD_ADDR_EXP 182
93713: PUSH
93714: LD_INT 0
93716: ST_TO_ADDR
// sRanger := false ;
93717: LD_ADDR_EXP 192
93721: PUSH
93722: LD_INT 0
93724: ST_TO_ADDR
// sComputer := false ;
93725: LD_ADDR_EXP 193
93729: PUSH
93730: LD_INT 0
93732: ST_TO_ADDR
// s30 := false ;
93733: LD_ADDR_EXP 194
93737: PUSH
93738: LD_INT 0
93740: ST_TO_ADDR
// s60 := false ;
93741: LD_ADDR_EXP 195
93745: PUSH
93746: LD_INT 0
93748: ST_TO_ADDR
// end ;
93749: LD_VAR 0 1
93753: RET
// function DefineStreamItems ( isGameLoad ) ; var tmp , flags , normal , hardcore , active , i ; begin
93754: LD_INT 0
93756: PPUSH
93757: PPUSH
93758: PPUSH
93759: PPUSH
93760: PPUSH
93761: PPUSH
93762: PPUSH
// result := [ ] ;
93763: LD_ADDR_VAR 0 2
93767: PUSH
93768: EMPTY
93769: ST_TO_ADDR
// if campaign_id = 1 then
93770: LD_OWVAR 69
93774: PUSH
93775: LD_INT 1
93777: EQUAL
93778: IFFALSE 96944
// begin case mission_number of 1 :
93780: LD_OWVAR 70
93784: PUSH
93785: LD_INT 1
93787: DOUBLE
93788: EQUAL
93789: IFTRUE 93793
93791: GO 93869
93793: POP
// result := [ [ 2 , 4 , 11 , 12 , 15 , 16 , 22 , 23 , 26 ] , [ 101 , 102 , 106 , 116 , 117 , 118 ] ] ; 2 :
93794: LD_ADDR_VAR 0 2
93798: PUSH
93799: LD_INT 2
93801: PUSH
93802: LD_INT 4
93804: PUSH
93805: LD_INT 11
93807: PUSH
93808: LD_INT 12
93810: PUSH
93811: LD_INT 15
93813: PUSH
93814: LD_INT 16
93816: PUSH
93817: LD_INT 22
93819: PUSH
93820: LD_INT 23
93822: PUSH
93823: LD_INT 26
93825: PUSH
93826: EMPTY
93827: LIST
93828: LIST
93829: LIST
93830: LIST
93831: LIST
93832: LIST
93833: LIST
93834: LIST
93835: LIST
93836: PUSH
93837: LD_INT 101
93839: PUSH
93840: LD_INT 102
93842: PUSH
93843: LD_INT 106
93845: PUSH
93846: LD_INT 116
93848: PUSH
93849: LD_INT 117
93851: PUSH
93852: LD_INT 118
93854: PUSH
93855: EMPTY
93856: LIST
93857: LIST
93858: LIST
93859: LIST
93860: LIST
93861: LIST
93862: PUSH
93863: EMPTY
93864: LIST
93865: LIST
93866: ST_TO_ADDR
93867: GO 96942
93869: LD_INT 2
93871: DOUBLE
93872: EQUAL
93873: IFTRUE 93877
93875: GO 93961
93877: POP
// result := [ [ 2 , 4 , 11 , 12 , 15 , 16 , 22 , 23 , 26 ] , [ 101 , 102 , 105 , 106 , 108 , 116 , 117 , 118 ] ] ; 3 :
93878: LD_ADDR_VAR 0 2
93882: PUSH
93883: LD_INT 2
93885: PUSH
93886: LD_INT 4
93888: PUSH
93889: LD_INT 11
93891: PUSH
93892: LD_INT 12
93894: PUSH
93895: LD_INT 15
93897: PUSH
93898: LD_INT 16
93900: PUSH
93901: LD_INT 22
93903: PUSH
93904: LD_INT 23
93906: PUSH
93907: LD_INT 26
93909: PUSH
93910: EMPTY
93911: LIST
93912: LIST
93913: LIST
93914: LIST
93915: LIST
93916: LIST
93917: LIST
93918: LIST
93919: LIST
93920: PUSH
93921: LD_INT 101
93923: PUSH
93924: LD_INT 102
93926: PUSH
93927: LD_INT 105
93929: PUSH
93930: LD_INT 106
93932: PUSH
93933: LD_INT 108
93935: PUSH
93936: LD_INT 116
93938: PUSH
93939: LD_INT 117
93941: PUSH
93942: LD_INT 118
93944: PUSH
93945: EMPTY
93946: LIST
93947: LIST
93948: LIST
93949: LIST
93950: LIST
93951: LIST
93952: LIST
93953: LIST
93954: PUSH
93955: EMPTY
93956: LIST
93957: LIST
93958: ST_TO_ADDR
93959: GO 96942
93961: LD_INT 3
93963: DOUBLE
93964: EQUAL
93965: IFTRUE 93969
93967: GO 94057
93969: POP
// result := [ [ 2 , 4 , 5 , 11 , 12 , 15 , 16 , 22 , 26 , 36 ] , [ 101 , 102 , 105 , 106 , 108 , 116 , 117 , 118 ] ] ; 4 :
93970: LD_ADDR_VAR 0 2
93974: PUSH
93975: LD_INT 2
93977: PUSH
93978: LD_INT 4
93980: PUSH
93981: LD_INT 5
93983: PUSH
93984: LD_INT 11
93986: PUSH
93987: LD_INT 12
93989: PUSH
93990: LD_INT 15
93992: PUSH
93993: LD_INT 16
93995: PUSH
93996: LD_INT 22
93998: PUSH
93999: LD_INT 26
94001: PUSH
94002: LD_INT 36
94004: PUSH
94005: EMPTY
94006: LIST
94007: LIST
94008: LIST
94009: LIST
94010: LIST
94011: LIST
94012: LIST
94013: LIST
94014: LIST
94015: LIST
94016: PUSH
94017: LD_INT 101
94019: PUSH
94020: LD_INT 102
94022: PUSH
94023: LD_INT 105
94025: PUSH
94026: LD_INT 106
94028: PUSH
94029: LD_INT 108
94031: PUSH
94032: LD_INT 116
94034: PUSH
94035: LD_INT 117
94037: PUSH
94038: LD_INT 118
94040: PUSH
94041: EMPTY
94042: LIST
94043: LIST
94044: LIST
94045: LIST
94046: LIST
94047: LIST
94048: LIST
94049: LIST
94050: PUSH
94051: EMPTY
94052: LIST
94053: LIST
94054: ST_TO_ADDR
94055: GO 96942
94057: LD_INT 4
94059: DOUBLE
94060: EQUAL
94061: IFTRUE 94065
94063: GO 94161
94065: POP
// result := [ [ 2 , 4 , 5 , 8 , 11 , 12 , 15 , 16 , 22 , 23 , 26 , 36 ] , [ 101 , 102 , 105 , 106 , 108 , 116 , 117 , 118 ] ] ; 5 :
94066: LD_ADDR_VAR 0 2
94070: PUSH
94071: LD_INT 2
94073: PUSH
94074: LD_INT 4
94076: PUSH
94077: LD_INT 5
94079: PUSH
94080: LD_INT 8
94082: PUSH
94083: LD_INT 11
94085: PUSH
94086: LD_INT 12
94088: PUSH
94089: LD_INT 15
94091: PUSH
94092: LD_INT 16
94094: PUSH
94095: LD_INT 22
94097: PUSH
94098: LD_INT 23
94100: PUSH
94101: LD_INT 26
94103: PUSH
94104: LD_INT 36
94106: PUSH
94107: EMPTY
94108: LIST
94109: LIST
94110: LIST
94111: LIST
94112: LIST
94113: LIST
94114: LIST
94115: LIST
94116: LIST
94117: LIST
94118: LIST
94119: LIST
94120: PUSH
94121: LD_INT 101
94123: PUSH
94124: LD_INT 102
94126: PUSH
94127: LD_INT 105
94129: PUSH
94130: LD_INT 106
94132: PUSH
94133: LD_INT 108
94135: PUSH
94136: LD_INT 116
94138: PUSH
94139: LD_INT 117
94141: PUSH
94142: LD_INT 118
94144: PUSH
94145: EMPTY
94146: LIST
94147: LIST
94148: LIST
94149: LIST
94150: LIST
94151: LIST
94152: LIST
94153: LIST
94154: PUSH
94155: EMPTY
94156: LIST
94157: LIST
94158: ST_TO_ADDR
94159: GO 96942
94161: LD_INT 5
94163: DOUBLE
94164: EQUAL
94165: IFTRUE 94169
94167: GO 94281
94169: POP
// result := [ [ 2 , 4 , 5 , 6 , 8 , 11 , 12 , 15 , 16 , 22 , 23 , 25 , 26 , 36 ] , [ 101 , 102 , 105 , 106 , 108 , 109 , 112 , 116 , 117 , 118 ] ] ; 6 :
94170: LD_ADDR_VAR 0 2
94174: PUSH
94175: LD_INT 2
94177: PUSH
94178: LD_INT 4
94180: PUSH
94181: LD_INT 5
94183: PUSH
94184: LD_INT 6
94186: PUSH
94187: LD_INT 8
94189: PUSH
94190: LD_INT 11
94192: PUSH
94193: LD_INT 12
94195: PUSH
94196: LD_INT 15
94198: PUSH
94199: LD_INT 16
94201: PUSH
94202: LD_INT 22
94204: PUSH
94205: LD_INT 23
94207: PUSH
94208: LD_INT 25
94210: PUSH
94211: LD_INT 26
94213: PUSH
94214: LD_INT 36
94216: PUSH
94217: EMPTY
94218: LIST
94219: LIST
94220: LIST
94221: LIST
94222: LIST
94223: LIST
94224: LIST
94225: LIST
94226: LIST
94227: LIST
94228: LIST
94229: LIST
94230: LIST
94231: LIST
94232: PUSH
94233: LD_INT 101
94235: PUSH
94236: LD_INT 102
94238: PUSH
94239: LD_INT 105
94241: PUSH
94242: LD_INT 106
94244: PUSH
94245: LD_INT 108
94247: PUSH
94248: LD_INT 109
94250: PUSH
94251: LD_INT 112
94253: PUSH
94254: LD_INT 116
94256: PUSH
94257: LD_INT 117
94259: PUSH
94260: LD_INT 118
94262: PUSH
94263: EMPTY
94264: LIST
94265: LIST
94266: LIST
94267: LIST
94268: LIST
94269: LIST
94270: LIST
94271: LIST
94272: LIST
94273: LIST
94274: PUSH
94275: EMPTY
94276: LIST
94277: LIST
94278: ST_TO_ADDR
94279: GO 96942
94281: LD_INT 6
94283: DOUBLE
94284: EQUAL
94285: IFTRUE 94289
94287: GO 94421
94289: POP
// result := [ [ 2 , 4 , 5 , 6 , 8 , 11 , 12 , 15 , 16 , 20 , 21 , 22 , 23 , 25 , 26 , 30 , 31 , 32 , 36 ] , [ 101 , 102 , 105 , 106 , 108 , 109 , 112 , 116 , 117 , 118 ] ] ; 7 :
94290: LD_ADDR_VAR 0 2
94294: PUSH
94295: LD_INT 2
94297: PUSH
94298: LD_INT 4
94300: PUSH
94301: LD_INT 5
94303: PUSH
94304: LD_INT 6
94306: PUSH
94307: LD_INT 8
94309: PUSH
94310: LD_INT 11
94312: PUSH
94313: LD_INT 12
94315: PUSH
94316: LD_INT 15
94318: PUSH
94319: LD_INT 16
94321: PUSH
94322: LD_INT 20
94324: PUSH
94325: LD_INT 21
94327: PUSH
94328: LD_INT 22
94330: PUSH
94331: LD_INT 23
94333: PUSH
94334: LD_INT 25
94336: PUSH
94337: LD_INT 26
94339: PUSH
94340: LD_INT 30
94342: PUSH
94343: LD_INT 31
94345: PUSH
94346: LD_INT 32
94348: PUSH
94349: LD_INT 36
94351: PUSH
94352: EMPTY
94353: LIST
94354: LIST
94355: LIST
94356: LIST
94357: LIST
94358: LIST
94359: LIST
94360: LIST
94361: LIST
94362: LIST
94363: LIST
94364: LIST
94365: LIST
94366: LIST
94367: LIST
94368: LIST
94369: LIST
94370: LIST
94371: LIST
94372: PUSH
94373: LD_INT 101
94375: PUSH
94376: LD_INT 102
94378: PUSH
94379: LD_INT 105
94381: PUSH
94382: LD_INT 106
94384: PUSH
94385: LD_INT 108
94387: PUSH
94388: LD_INT 109
94390: PUSH
94391: LD_INT 112
94393: PUSH
94394: LD_INT 116
94396: PUSH
94397: LD_INT 117
94399: PUSH
94400: LD_INT 118
94402: PUSH
94403: EMPTY
94404: LIST
94405: LIST
94406: LIST
94407: LIST
94408: LIST
94409: LIST
94410: LIST
94411: LIST
94412: LIST
94413: LIST
94414: PUSH
94415: EMPTY
94416: LIST
94417: LIST
94418: ST_TO_ADDR
94419: GO 96942
94421: LD_INT 7
94423: DOUBLE
94424: EQUAL
94425: IFTRUE 94429
94427: GO 94541
94429: POP
// result := [ [ 2 , 4 , 5 , 7 , 11 , 12 , 15 , 16 , 20 , 21 , 22 , 23 , 25 , 26 ] , [ 101 , 102 , 103 , 105 , 106 , 108 , 112 , 116 , 117 , 118 ] ] ; 8 :
94430: LD_ADDR_VAR 0 2
94434: PUSH
94435: LD_INT 2
94437: PUSH
94438: LD_INT 4
94440: PUSH
94441: LD_INT 5
94443: PUSH
94444: LD_INT 7
94446: PUSH
94447: LD_INT 11
94449: PUSH
94450: LD_INT 12
94452: PUSH
94453: LD_INT 15
94455: PUSH
94456: LD_INT 16
94458: PUSH
94459: LD_INT 20
94461: PUSH
94462: LD_INT 21
94464: PUSH
94465: LD_INT 22
94467: PUSH
94468: LD_INT 23
94470: PUSH
94471: LD_INT 25
94473: PUSH
94474: LD_INT 26
94476: PUSH
94477: EMPTY
94478: LIST
94479: LIST
94480: LIST
94481: LIST
94482: LIST
94483: LIST
94484: LIST
94485: LIST
94486: LIST
94487: LIST
94488: LIST
94489: LIST
94490: LIST
94491: LIST
94492: PUSH
94493: LD_INT 101
94495: PUSH
94496: LD_INT 102
94498: PUSH
94499: LD_INT 103
94501: PUSH
94502: LD_INT 105
94504: PUSH
94505: LD_INT 106
94507: PUSH
94508: LD_INT 108
94510: PUSH
94511: LD_INT 112
94513: PUSH
94514: LD_INT 116
94516: PUSH
94517: LD_INT 117
94519: PUSH
94520: LD_INT 118
94522: PUSH
94523: EMPTY
94524: LIST
94525: LIST
94526: LIST
94527: LIST
94528: LIST
94529: LIST
94530: LIST
94531: LIST
94532: LIST
94533: LIST
94534: PUSH
94535: EMPTY
94536: LIST
94537: LIST
94538: ST_TO_ADDR
94539: GO 96942
94541: LD_INT 8
94543: DOUBLE
94544: EQUAL
94545: IFTRUE 94549
94547: GO 94689
94549: POP
// result := [ [ 2 , 4 , 5 , 6 , 7 , 8 , 11 , 12 , 15 , 16 , 20 , 21 , 22 , 23 , 25 , 26 , 30 , 31 , 32 , 36 ] , [ 101 , 102 , 103 , 105 , 106 , 108 , 109 , 112 , 116 , 117 , 118 ] ] ; 9 :
94550: LD_ADDR_VAR 0 2
94554: PUSH
94555: LD_INT 2
94557: PUSH
94558: LD_INT 4
94560: PUSH
94561: LD_INT 5
94563: PUSH
94564: LD_INT 6
94566: PUSH
94567: LD_INT 7
94569: PUSH
94570: LD_INT 8
94572: PUSH
94573: LD_INT 11
94575: PUSH
94576: LD_INT 12
94578: PUSH
94579: LD_INT 15
94581: PUSH
94582: LD_INT 16
94584: PUSH
94585: LD_INT 20
94587: PUSH
94588: LD_INT 21
94590: PUSH
94591: LD_INT 22
94593: PUSH
94594: LD_INT 23
94596: PUSH
94597: LD_INT 25
94599: PUSH
94600: LD_INT 26
94602: PUSH
94603: LD_INT 30
94605: PUSH
94606: LD_INT 31
94608: PUSH
94609: LD_INT 32
94611: PUSH
94612: LD_INT 36
94614: PUSH
94615: EMPTY
94616: LIST
94617: LIST
94618: LIST
94619: LIST
94620: LIST
94621: LIST
94622: LIST
94623: LIST
94624: LIST
94625: LIST
94626: LIST
94627: LIST
94628: LIST
94629: LIST
94630: LIST
94631: LIST
94632: LIST
94633: LIST
94634: LIST
94635: LIST
94636: PUSH
94637: LD_INT 101
94639: PUSH
94640: LD_INT 102
94642: PUSH
94643: LD_INT 103
94645: PUSH
94646: LD_INT 105
94648: PUSH
94649: LD_INT 106
94651: PUSH
94652: LD_INT 108
94654: PUSH
94655: LD_INT 109
94657: PUSH
94658: LD_INT 112
94660: PUSH
94661: LD_INT 116
94663: PUSH
94664: LD_INT 117
94666: PUSH
94667: LD_INT 118
94669: PUSH
94670: EMPTY
94671: LIST
94672: LIST
94673: LIST
94674: LIST
94675: LIST
94676: LIST
94677: LIST
94678: LIST
94679: LIST
94680: LIST
94681: LIST
94682: PUSH
94683: EMPTY
94684: LIST
94685: LIST
94686: ST_TO_ADDR
94687: GO 96942
94689: LD_INT 9
94691: DOUBLE
94692: EQUAL
94693: IFTRUE 94697
94695: GO 94845
94697: POP
// result := [ [ 2 , 4 , 5 , 6 , 7 , 8 , 11 , 12 , 15 , 16 , 20 , 21 , 22 , 23 , 25 , 26 , 28 , 30 , 31 , 32 , 36 ] , [ 101 , 102 , 103 , 105 , 106 , 108 , 109 , 112 , 114 , 116 , 117 , 118 ] ] ; 10 :
94698: LD_ADDR_VAR 0 2
94702: PUSH
94703: LD_INT 2
94705: PUSH
94706: LD_INT 4
94708: PUSH
94709: LD_INT 5
94711: PUSH
94712: LD_INT 6
94714: PUSH
94715: LD_INT 7
94717: PUSH
94718: LD_INT 8
94720: PUSH
94721: LD_INT 11
94723: PUSH
94724: LD_INT 12
94726: PUSH
94727: LD_INT 15
94729: PUSH
94730: LD_INT 16
94732: PUSH
94733: LD_INT 20
94735: PUSH
94736: LD_INT 21
94738: PUSH
94739: LD_INT 22
94741: PUSH
94742: LD_INT 23
94744: PUSH
94745: LD_INT 25
94747: PUSH
94748: LD_INT 26
94750: PUSH
94751: LD_INT 28
94753: PUSH
94754: LD_INT 30
94756: PUSH
94757: LD_INT 31
94759: PUSH
94760: LD_INT 32
94762: PUSH
94763: LD_INT 36
94765: PUSH
94766: EMPTY
94767: LIST
94768: LIST
94769: LIST
94770: LIST
94771: LIST
94772: LIST
94773: LIST
94774: LIST
94775: LIST
94776: LIST
94777: LIST
94778: LIST
94779: LIST
94780: LIST
94781: LIST
94782: LIST
94783: LIST
94784: LIST
94785: LIST
94786: LIST
94787: LIST
94788: PUSH
94789: LD_INT 101
94791: PUSH
94792: LD_INT 102
94794: PUSH
94795: LD_INT 103
94797: PUSH
94798: LD_INT 105
94800: PUSH
94801: LD_INT 106
94803: PUSH
94804: LD_INT 108
94806: PUSH
94807: LD_INT 109
94809: PUSH
94810: LD_INT 112
94812: PUSH
94813: LD_INT 114
94815: PUSH
94816: LD_INT 116
94818: PUSH
94819: LD_INT 117
94821: PUSH
94822: LD_INT 118
94824: PUSH
94825: EMPTY
94826: LIST
94827: LIST
94828: LIST
94829: LIST
94830: LIST
94831: LIST
94832: LIST
94833: LIST
94834: LIST
94835: LIST
94836: LIST
94837: LIST
94838: PUSH
94839: EMPTY
94840: LIST
94841: LIST
94842: ST_TO_ADDR
94843: GO 96942
94845: LD_INT 10
94847: DOUBLE
94848: EQUAL
94849: IFTRUE 94853
94851: GO 95049
94853: POP
// result := [ [ 2 , 4 , 5 , 6 , 7 , 8 , 9 , 10 , 11 , 12 , 13 , 14 , 15 , 16 , 17 , 18 , 19 , 20 , 21 , 22 , 23 , 24 , 25 , 26 , 28 , 30 , 31 , 32 , 36 ] , [ 101 , 102 , 103 , 104 , 105 , 106 , 107 , 108 , 109 , 110 , 111 , 112 , 114 , 116 , 117 , 118 ] ] ; 11 :
94854: LD_ADDR_VAR 0 2
94858: PUSH
94859: LD_INT 2
94861: PUSH
94862: LD_INT 4
94864: PUSH
94865: LD_INT 5
94867: PUSH
94868: LD_INT 6
94870: PUSH
94871: LD_INT 7
94873: PUSH
94874: LD_INT 8
94876: PUSH
94877: LD_INT 9
94879: PUSH
94880: LD_INT 10
94882: PUSH
94883: LD_INT 11
94885: PUSH
94886: LD_INT 12
94888: PUSH
94889: LD_INT 13
94891: PUSH
94892: LD_INT 14
94894: PUSH
94895: LD_INT 15
94897: PUSH
94898: LD_INT 16
94900: PUSH
94901: LD_INT 17
94903: PUSH
94904: LD_INT 18
94906: PUSH
94907: LD_INT 19
94909: PUSH
94910: LD_INT 20
94912: PUSH
94913: LD_INT 21
94915: PUSH
94916: LD_INT 22
94918: PUSH
94919: LD_INT 23
94921: PUSH
94922: LD_INT 24
94924: PUSH
94925: LD_INT 25
94927: PUSH
94928: LD_INT 26
94930: PUSH
94931: LD_INT 28
94933: PUSH
94934: LD_INT 30
94936: PUSH
94937: LD_INT 31
94939: PUSH
94940: LD_INT 32
94942: PUSH
94943: LD_INT 36
94945: PUSH
94946: EMPTY
94947: LIST
94948: LIST
94949: LIST
94950: LIST
94951: LIST
94952: LIST
94953: LIST
94954: LIST
94955: LIST
94956: LIST
94957: LIST
94958: LIST
94959: LIST
94960: LIST
94961: LIST
94962: LIST
94963: LIST
94964: LIST
94965: LIST
94966: LIST
94967: LIST
94968: LIST
94969: LIST
94970: LIST
94971: LIST
94972: LIST
94973: LIST
94974: LIST
94975: LIST
94976: PUSH
94977: LD_INT 101
94979: PUSH
94980: LD_INT 102
94982: PUSH
94983: LD_INT 103
94985: PUSH
94986: LD_INT 104
94988: PUSH
94989: LD_INT 105
94991: PUSH
94992: LD_INT 106
94994: PUSH
94995: LD_INT 107
94997: PUSH
94998: LD_INT 108
95000: PUSH
95001: LD_INT 109
95003: PUSH
95004: LD_INT 110
95006: PUSH
95007: LD_INT 111
95009: PUSH
95010: LD_INT 112
95012: PUSH
95013: LD_INT 114
95015: PUSH
95016: LD_INT 116
95018: PUSH
95019: LD_INT 117
95021: PUSH
95022: LD_INT 118
95024: PUSH
95025: EMPTY
95026: LIST
95027: LIST
95028: LIST
95029: LIST
95030: LIST
95031: LIST
95032: LIST
95033: LIST
95034: LIST
95035: LIST
95036: LIST
95037: LIST
95038: LIST
95039: LIST
95040: LIST
95041: LIST
95042: PUSH
95043: EMPTY
95044: LIST
95045: LIST
95046: ST_TO_ADDR
95047: GO 96942
95049: LD_INT 11
95051: DOUBLE
95052: EQUAL
95053: IFTRUE 95057
95055: GO 95261
95057: POP
// result := [ [ 2 , 3 , 4 , 5 , 6 , 7 , 8 , 9 , 10 , 11 , 12 , 13 , 14 , 15 , 16 , 17 , 18 , 19 , 20 , 21 , 22 , 23 , 24 , 25 , 26 , 28 , 30 , 31 , 32 , 34 , 36 ] , [ 101 , 102 , 103 , 104 , 105 , 106 , 107 , 108 , 109 , 110 , 111 , 112 , 114 , 116 , 117 , 118 ] ] ; 12 :
95058: LD_ADDR_VAR 0 2
95062: PUSH
95063: LD_INT 2
95065: PUSH
95066: LD_INT 3
95068: PUSH
95069: LD_INT 4
95071: PUSH
95072: LD_INT 5
95074: PUSH
95075: LD_INT 6
95077: PUSH
95078: LD_INT 7
95080: PUSH
95081: LD_INT 8
95083: PUSH
95084: LD_INT 9
95086: PUSH
95087: LD_INT 10
95089: PUSH
95090: LD_INT 11
95092: PUSH
95093: LD_INT 12
95095: PUSH
95096: LD_INT 13
95098: PUSH
95099: LD_INT 14
95101: PUSH
95102: LD_INT 15
95104: PUSH
95105: LD_INT 16
95107: PUSH
95108: LD_INT 17
95110: PUSH
95111: LD_INT 18
95113: PUSH
95114: LD_INT 19
95116: PUSH
95117: LD_INT 20
95119: PUSH
95120: LD_INT 21
95122: PUSH
95123: LD_INT 22
95125: PUSH
95126: LD_INT 23
95128: PUSH
95129: LD_INT 24
95131: PUSH
95132: LD_INT 25
95134: PUSH
95135: LD_INT 26
95137: PUSH
95138: LD_INT 28
95140: PUSH
95141: LD_INT 30
95143: PUSH
95144: LD_INT 31
95146: PUSH
95147: LD_INT 32
95149: PUSH
95150: LD_INT 34
95152: PUSH
95153: LD_INT 36
95155: PUSH
95156: EMPTY
95157: LIST
95158: LIST
95159: LIST
95160: LIST
95161: LIST
95162: LIST
95163: LIST
95164: LIST
95165: LIST
95166: LIST
95167: LIST
95168: LIST
95169: LIST
95170: LIST
95171: LIST
95172: LIST
95173: LIST
95174: LIST
95175: LIST
95176: LIST
95177: LIST
95178: LIST
95179: LIST
95180: LIST
95181: LIST
95182: LIST
95183: LIST
95184: LIST
95185: LIST
95186: LIST
95187: LIST
95188: PUSH
95189: LD_INT 101
95191: PUSH
95192: LD_INT 102
95194: PUSH
95195: LD_INT 103
95197: PUSH
95198: LD_INT 104
95200: PUSH
95201: LD_INT 105
95203: PUSH
95204: LD_INT 106
95206: PUSH
95207: LD_INT 107
95209: PUSH
95210: LD_INT 108
95212: PUSH
95213: LD_INT 109
95215: PUSH
95216: LD_INT 110
95218: PUSH
95219: LD_INT 111
95221: PUSH
95222: LD_INT 112
95224: PUSH
95225: LD_INT 114
95227: PUSH
95228: LD_INT 116
95230: PUSH
95231: LD_INT 117
95233: PUSH
95234: LD_INT 118
95236: PUSH
95237: EMPTY
95238: LIST
95239: LIST
95240: LIST
95241: LIST
95242: LIST
95243: LIST
95244: LIST
95245: LIST
95246: LIST
95247: LIST
95248: LIST
95249: LIST
95250: LIST
95251: LIST
95252: LIST
95253: LIST
95254: PUSH
95255: EMPTY
95256: LIST
95257: LIST
95258: ST_TO_ADDR
95259: GO 96942
95261: LD_INT 12
95263: DOUBLE
95264: EQUAL
95265: IFTRUE 95269
95267: GO 95489
95269: POP
// result := [ [ 1 , 2 , 3 , 4 , 5 , 6 , 7 , 8 , 9 , 10 , 11 , 12 , 13 , 14 , 15 , 16 , 17 , 18 , 19 , 20 , 21 , 22 , 23 , 24 , 25 , 26 , 27 , 28 , 30 , 31 , 32 , 33 , 34 , 36 ] , [ 101 , 102 , 103 , 104 , 105 , 106 , 107 , 108 , 109 , 110 , 111 , 112 , 113 , 114 , 116 , 117 , 118 ] ] ; 13 :
95270: LD_ADDR_VAR 0 2
95274: PUSH
95275: LD_INT 1
95277: PUSH
95278: LD_INT 2
95280: PUSH
95281: LD_INT 3
95283: PUSH
95284: LD_INT 4
95286: PUSH
95287: LD_INT 5
95289: PUSH
95290: LD_INT 6
95292: PUSH
95293: LD_INT 7
95295: PUSH
95296: LD_INT 8
95298: PUSH
95299: LD_INT 9
95301: PUSH
95302: LD_INT 10
95304: PUSH
95305: LD_INT 11
95307: PUSH
95308: LD_INT 12
95310: PUSH
95311: LD_INT 13
95313: PUSH
95314: LD_INT 14
95316: PUSH
95317: LD_INT 15
95319: PUSH
95320: LD_INT 16
95322: PUSH
95323: LD_INT 17
95325: PUSH
95326: LD_INT 18
95328: PUSH
95329: LD_INT 19
95331: PUSH
95332: LD_INT 20
95334: PUSH
95335: LD_INT 21
95337: PUSH
95338: LD_INT 22
95340: PUSH
95341: LD_INT 23
95343: PUSH
95344: LD_INT 24
95346: PUSH
95347: LD_INT 25
95349: PUSH
95350: LD_INT 26
95352: PUSH
95353: LD_INT 27
95355: PUSH
95356: LD_INT 28
95358: PUSH
95359: LD_INT 30
95361: PUSH
95362: LD_INT 31
95364: PUSH
95365: LD_INT 32
95367: PUSH
95368: LD_INT 33
95370: PUSH
95371: LD_INT 34
95373: PUSH
95374: LD_INT 36
95376: PUSH
95377: EMPTY
95378: LIST
95379: LIST
95380: LIST
95381: LIST
95382: LIST
95383: LIST
95384: LIST
95385: LIST
95386: LIST
95387: LIST
95388: LIST
95389: LIST
95390: LIST
95391: LIST
95392: LIST
95393: LIST
95394: LIST
95395: LIST
95396: LIST
95397: LIST
95398: LIST
95399: LIST
95400: LIST
95401: LIST
95402: LIST
95403: LIST
95404: LIST
95405: LIST
95406: LIST
95407: LIST
95408: LIST
95409: LIST
95410: LIST
95411: LIST
95412: PUSH
95413: LD_INT 101
95415: PUSH
95416: LD_INT 102
95418: PUSH
95419: LD_INT 103
95421: PUSH
95422: LD_INT 104
95424: PUSH
95425: LD_INT 105
95427: PUSH
95428: LD_INT 106
95430: PUSH
95431: LD_INT 107
95433: PUSH
95434: LD_INT 108
95436: PUSH
95437: LD_INT 109
95439: PUSH
95440: LD_INT 110
95442: PUSH
95443: LD_INT 111
95445: PUSH
95446: LD_INT 112
95448: PUSH
95449: LD_INT 113
95451: PUSH
95452: LD_INT 114
95454: PUSH
95455: LD_INT 116
95457: PUSH
95458: LD_INT 117
95460: PUSH
95461: LD_INT 118
95463: PUSH
95464: EMPTY
95465: LIST
95466: LIST
95467: LIST
95468: LIST
95469: LIST
95470: LIST
95471: LIST
95472: LIST
95473: LIST
95474: LIST
95475: LIST
95476: LIST
95477: LIST
95478: LIST
95479: LIST
95480: LIST
95481: LIST
95482: PUSH
95483: EMPTY
95484: LIST
95485: LIST
95486: ST_TO_ADDR
95487: GO 96942
95489: LD_INT 13
95491: DOUBLE
95492: EQUAL
95493: IFTRUE 95497
95495: GO 95705
95497: POP
// result := [ [ 1 , 2 , 3 , 4 , 5 , 8 , 9 , 10 , 11 , 12 , 14 , 15 , 16 , 17 , 18 , 19 , 20 , 21 , 22 , 23 , 24 , 25 , 26 , 27 , 28 , 30 , 31 , 32 , 33 , 34 , 36 ] , [ 101 , 102 , 103 , 104 , 105 , 106 , 107 , 108 , 109 , 110 , 111 , 112 , 113 , 114 , 116 , 117 , 118 ] ] ; 14 :
95498: LD_ADDR_VAR 0 2
95502: PUSH
95503: LD_INT 1
95505: PUSH
95506: LD_INT 2
95508: PUSH
95509: LD_INT 3
95511: PUSH
95512: LD_INT 4
95514: PUSH
95515: LD_INT 5
95517: PUSH
95518: LD_INT 8
95520: PUSH
95521: LD_INT 9
95523: PUSH
95524: LD_INT 10
95526: PUSH
95527: LD_INT 11
95529: PUSH
95530: LD_INT 12
95532: PUSH
95533: LD_INT 14
95535: PUSH
95536: LD_INT 15
95538: PUSH
95539: LD_INT 16
95541: PUSH
95542: LD_INT 17
95544: PUSH
95545: LD_INT 18
95547: PUSH
95548: LD_INT 19
95550: PUSH
95551: LD_INT 20
95553: PUSH
95554: LD_INT 21
95556: PUSH
95557: LD_INT 22
95559: PUSH
95560: LD_INT 23
95562: PUSH
95563: LD_INT 24
95565: PUSH
95566: LD_INT 25
95568: PUSH
95569: LD_INT 26
95571: PUSH
95572: LD_INT 27
95574: PUSH
95575: LD_INT 28
95577: PUSH
95578: LD_INT 30
95580: PUSH
95581: LD_INT 31
95583: PUSH
95584: LD_INT 32
95586: PUSH
95587: LD_INT 33
95589: PUSH
95590: LD_INT 34
95592: PUSH
95593: LD_INT 36
95595: PUSH
95596: EMPTY
95597: LIST
95598: LIST
95599: LIST
95600: LIST
95601: LIST
95602: LIST
95603: LIST
95604: LIST
95605: LIST
95606: LIST
95607: LIST
95608: LIST
95609: LIST
95610: LIST
95611: LIST
95612: LIST
95613: LIST
95614: LIST
95615: LIST
95616: LIST
95617: LIST
95618: LIST
95619: LIST
95620: LIST
95621: LIST
95622: LIST
95623: LIST
95624: LIST
95625: LIST
95626: LIST
95627: LIST
95628: PUSH
95629: LD_INT 101
95631: PUSH
95632: LD_INT 102
95634: PUSH
95635: LD_INT 103
95637: PUSH
95638: LD_INT 104
95640: PUSH
95641: LD_INT 105
95643: PUSH
95644: LD_INT 106
95646: PUSH
95647: LD_INT 107
95649: PUSH
95650: LD_INT 108
95652: PUSH
95653: LD_INT 109
95655: PUSH
95656: LD_INT 110
95658: PUSH
95659: LD_INT 111
95661: PUSH
95662: LD_INT 112
95664: PUSH
95665: LD_INT 113
95667: PUSH
95668: LD_INT 114
95670: PUSH
95671: LD_INT 116
95673: PUSH
95674: LD_INT 117
95676: PUSH
95677: LD_INT 118
95679: PUSH
95680: EMPTY
95681: LIST
95682: LIST
95683: LIST
95684: LIST
95685: LIST
95686: LIST
95687: LIST
95688: LIST
95689: LIST
95690: LIST
95691: LIST
95692: LIST
95693: LIST
95694: LIST
95695: LIST
95696: LIST
95697: LIST
95698: PUSH
95699: EMPTY
95700: LIST
95701: LIST
95702: ST_TO_ADDR
95703: GO 96942
95705: LD_INT 14
95707: DOUBLE
95708: EQUAL
95709: IFTRUE 95713
95711: GO 95937
95713: POP
// result := [ [ 1 , 2 , 3 , 4 , 5 , 6 , 7 , 8 , 9 , 10 , 11 , 12 , 13 , 14 , 15 , 16 , 17 , 18 , 19 , 20 , 21 , 22 , 23 , 24 , 25 , 26 , 27 , 28 , 29 , 30 , 31 , 32 , 33 , 34 , 36 ] , [ 101 , 102 , 103 , 104 , 105 , 106 , 107 , 108 , 109 , 110 , 111 , 112 , 113 , 114 , 116 , 117 , 118 ] ] ; 15 :
95714: LD_ADDR_VAR 0 2
95718: PUSH
95719: LD_INT 1
95721: PUSH
95722: LD_INT 2
95724: PUSH
95725: LD_INT 3
95727: PUSH
95728: LD_INT 4
95730: PUSH
95731: LD_INT 5
95733: PUSH
95734: LD_INT 6
95736: PUSH
95737: LD_INT 7
95739: PUSH
95740: LD_INT 8
95742: PUSH
95743: LD_INT 9
95745: PUSH
95746: LD_INT 10
95748: PUSH
95749: LD_INT 11
95751: PUSH
95752: LD_INT 12
95754: PUSH
95755: LD_INT 13
95757: PUSH
95758: LD_INT 14
95760: PUSH
95761: LD_INT 15
95763: PUSH
95764: LD_INT 16
95766: PUSH
95767: LD_INT 17
95769: PUSH
95770: LD_INT 18
95772: PUSH
95773: LD_INT 19
95775: PUSH
95776: LD_INT 20
95778: PUSH
95779: LD_INT 21
95781: PUSH
95782: LD_INT 22
95784: PUSH
95785: LD_INT 23
95787: PUSH
95788: LD_INT 24
95790: PUSH
95791: LD_INT 25
95793: PUSH
95794: LD_INT 26
95796: PUSH
95797: LD_INT 27
95799: PUSH
95800: LD_INT 28
95802: PUSH
95803: LD_INT 29
95805: PUSH
95806: LD_INT 30
95808: PUSH
95809: LD_INT 31
95811: PUSH
95812: LD_INT 32
95814: PUSH
95815: LD_INT 33
95817: PUSH
95818: LD_INT 34
95820: PUSH
95821: LD_INT 36
95823: PUSH
95824: EMPTY
95825: LIST
95826: LIST
95827: LIST
95828: LIST
95829: LIST
95830: LIST
95831: LIST
95832: LIST
95833: LIST
95834: LIST
95835: LIST
95836: LIST
95837: LIST
95838: LIST
95839: LIST
95840: LIST
95841: LIST
95842: LIST
95843: LIST
95844: LIST
95845: LIST
95846: LIST
95847: LIST
95848: LIST
95849: LIST
95850: LIST
95851: LIST
95852: LIST
95853: LIST
95854: LIST
95855: LIST
95856: LIST
95857: LIST
95858: LIST
95859: LIST
95860: PUSH
95861: LD_INT 101
95863: PUSH
95864: LD_INT 102
95866: PUSH
95867: LD_INT 103
95869: PUSH
95870: LD_INT 104
95872: PUSH
95873: LD_INT 105
95875: PUSH
95876: LD_INT 106
95878: PUSH
95879: LD_INT 107
95881: PUSH
95882: LD_INT 108
95884: PUSH
95885: LD_INT 109
95887: PUSH
95888: LD_INT 110
95890: PUSH
95891: LD_INT 111
95893: PUSH
95894: LD_INT 112
95896: PUSH
95897: LD_INT 113
95899: PUSH
95900: LD_INT 114
95902: PUSH
95903: LD_INT 116
95905: PUSH
95906: LD_INT 117
95908: PUSH
95909: LD_INT 118
95911: PUSH
95912: EMPTY
95913: LIST
95914: LIST
95915: LIST
95916: LIST
95917: LIST
95918: LIST
95919: LIST
95920: LIST
95921: LIST
95922: LIST
95923: LIST
95924: LIST
95925: LIST
95926: LIST
95927: LIST
95928: LIST
95929: LIST
95930: PUSH
95931: EMPTY
95932: LIST
95933: LIST
95934: ST_TO_ADDR
95935: GO 96942
95937: LD_INT 15
95939: DOUBLE
95940: EQUAL
95941: IFTRUE 95945
95943: GO 96169
95945: POP
// result := [ [ 1 , 2 , 3 , 4 , 5 , 6 , 7 , 8 , 9 , 10 , 11 , 12 , 13 , 14 , 15 , 16 , 17 , 18 , 19 , 20 , 21 , 22 , 23 , 24 , 25 , 26 , 27 , 28 , 29 , 30 , 31 , 32 , 33 , 34 , 36 ] , [ 101 , 102 , 103 , 104 , 105 , 106 , 107 , 108 , 109 , 110 , 111 , 112 , 113 , 114 , 116 , 117 , 118 ] ] ; 16 :
95946: LD_ADDR_VAR 0 2
95950: PUSH
95951: LD_INT 1
95953: PUSH
95954: LD_INT 2
95956: PUSH
95957: LD_INT 3
95959: PUSH
95960: LD_INT 4
95962: PUSH
95963: LD_INT 5
95965: PUSH
95966: LD_INT 6
95968: PUSH
95969: LD_INT 7
95971: PUSH
95972: LD_INT 8
95974: PUSH
95975: LD_INT 9
95977: PUSH
95978: LD_INT 10
95980: PUSH
95981: LD_INT 11
95983: PUSH
95984: LD_INT 12
95986: PUSH
95987: LD_INT 13
95989: PUSH
95990: LD_INT 14
95992: PUSH
95993: LD_INT 15
95995: PUSH
95996: LD_INT 16
95998: PUSH
95999: LD_INT 17
96001: PUSH
96002: LD_INT 18
96004: PUSH
96005: LD_INT 19
96007: PUSH
96008: LD_INT 20
96010: PUSH
96011: LD_INT 21
96013: PUSH
96014: LD_INT 22
96016: PUSH
96017: LD_INT 23
96019: PUSH
96020: LD_INT 24
96022: PUSH
96023: LD_INT 25
96025: PUSH
96026: LD_INT 26
96028: PUSH
96029: LD_INT 27
96031: PUSH
96032: LD_INT 28
96034: PUSH
96035: LD_INT 29
96037: PUSH
96038: LD_INT 30
96040: PUSH
96041: LD_INT 31
96043: PUSH
96044: LD_INT 32
96046: PUSH
96047: LD_INT 33
96049: PUSH
96050: LD_INT 34
96052: PUSH
96053: LD_INT 36
96055: PUSH
96056: EMPTY
96057: LIST
96058: LIST
96059: LIST
96060: LIST
96061: LIST
96062: LIST
96063: LIST
96064: LIST
96065: LIST
96066: LIST
96067: LIST
96068: LIST
96069: LIST
96070: LIST
96071: LIST
96072: LIST
96073: LIST
96074: LIST
96075: LIST
96076: LIST
96077: LIST
96078: LIST
96079: LIST
96080: LIST
96081: LIST
96082: LIST
96083: LIST
96084: LIST
96085: LIST
96086: LIST
96087: LIST
96088: LIST
96089: LIST
96090: LIST
96091: LIST
96092: PUSH
96093: LD_INT 101
96095: PUSH
96096: LD_INT 102
96098: PUSH
96099: LD_INT 103
96101: PUSH
96102: LD_INT 104
96104: PUSH
96105: LD_INT 105
96107: PUSH
96108: LD_INT 106
96110: PUSH
96111: LD_INT 107
96113: PUSH
96114: LD_INT 108
96116: PUSH
96117: LD_INT 109
96119: PUSH
96120: LD_INT 110
96122: PUSH
96123: LD_INT 111
96125: PUSH
96126: LD_INT 112
96128: PUSH
96129: LD_INT 113
96131: PUSH
96132: LD_INT 114
96134: PUSH
96135: LD_INT 116
96137: PUSH
96138: LD_INT 117
96140: PUSH
96141: LD_INT 118
96143: PUSH
96144: EMPTY
96145: LIST
96146: LIST
96147: LIST
96148: LIST
96149: LIST
96150: LIST
96151: LIST
96152: LIST
96153: LIST
96154: LIST
96155: LIST
96156: LIST
96157: LIST
96158: LIST
96159: LIST
96160: LIST
96161: LIST
96162: PUSH
96163: EMPTY
96164: LIST
96165: LIST
96166: ST_TO_ADDR
96167: GO 96942
96169: LD_INT 16
96171: DOUBLE
96172: EQUAL
96173: IFTRUE 96177
96175: GO 96313
96177: POP
// result := [ [ 2 , 4 , 5 , 7 , 11 , 12 , 15 , 16 , 20 , 21 , 22 , 23 , 25 , 26 , 30 , 31 , 32 , 33 , 34 ] , [ 101 , 102 , 103 , 106 , 108 , 112 , 113 , 114 , 116 , 117 , 118 ] ] ; 17 :
96178: LD_ADDR_VAR 0 2
96182: PUSH
96183: LD_INT 2
96185: PUSH
96186: LD_INT 4
96188: PUSH
96189: LD_INT 5
96191: PUSH
96192: LD_INT 7
96194: PUSH
96195: LD_INT 11
96197: PUSH
96198: LD_INT 12
96200: PUSH
96201: LD_INT 15
96203: PUSH
96204: LD_INT 16
96206: PUSH
96207: LD_INT 20
96209: PUSH
96210: LD_INT 21
96212: PUSH
96213: LD_INT 22
96215: PUSH
96216: LD_INT 23
96218: PUSH
96219: LD_INT 25
96221: PUSH
96222: LD_INT 26
96224: PUSH
96225: LD_INT 30
96227: PUSH
96228: LD_INT 31
96230: PUSH
96231: LD_INT 32
96233: PUSH
96234: LD_INT 33
96236: PUSH
96237: LD_INT 34
96239: PUSH
96240: EMPTY
96241: LIST
96242: LIST
96243: LIST
96244: LIST
96245: LIST
96246: LIST
96247: LIST
96248: LIST
96249: LIST
96250: LIST
96251: LIST
96252: LIST
96253: LIST
96254: LIST
96255: LIST
96256: LIST
96257: LIST
96258: LIST
96259: LIST
96260: PUSH
96261: LD_INT 101
96263: PUSH
96264: LD_INT 102
96266: PUSH
96267: LD_INT 103
96269: PUSH
96270: LD_INT 106
96272: PUSH
96273: LD_INT 108
96275: PUSH
96276: LD_INT 112
96278: PUSH
96279: LD_INT 113
96281: PUSH
96282: LD_INT 114
96284: PUSH
96285: LD_INT 116
96287: PUSH
96288: LD_INT 117
96290: PUSH
96291: LD_INT 118
96293: PUSH
96294: EMPTY
96295: LIST
96296: LIST
96297: LIST
96298: LIST
96299: LIST
96300: LIST
96301: LIST
96302: LIST
96303: LIST
96304: LIST
96305: LIST
96306: PUSH
96307: EMPTY
96308: LIST
96309: LIST
96310: ST_TO_ADDR
96311: GO 96942
96313: LD_INT 17
96315: DOUBLE
96316: EQUAL
96317: IFTRUE 96321
96319: GO 96545
96321: POP
// result := [ [ 1 , 2 , 3 , 4 , 5 , 6 , 7 , 8 , 9 , 10 , 11 , 12 , 13 , 14 , 15 , 16 , 17 , 18 , 19 , 20 , 21 , 22 , 23 , 24 , 25 , 26 , 27 , 28 , 29 , 30 , 31 , 32 , 33 , 34 , 36 ] , [ 101 , 102 , 103 , 104 , 105 , 106 , 107 , 108 , 109 , 110 , 111 , 112 , 113 , 114 , 116 , 117 , 118 ] ] ; 18 :
96322: LD_ADDR_VAR 0 2
96326: PUSH
96327: LD_INT 1
96329: PUSH
96330: LD_INT 2
96332: PUSH
96333: LD_INT 3
96335: PUSH
96336: LD_INT 4
96338: PUSH
96339: LD_INT 5
96341: PUSH
96342: LD_INT 6
96344: PUSH
96345: LD_INT 7
96347: PUSH
96348: LD_INT 8
96350: PUSH
96351: LD_INT 9
96353: PUSH
96354: LD_INT 10
96356: PUSH
96357: LD_INT 11
96359: PUSH
96360: LD_INT 12
96362: PUSH
96363: LD_INT 13
96365: PUSH
96366: LD_INT 14
96368: PUSH
96369: LD_INT 15
96371: PUSH
96372: LD_INT 16
96374: PUSH
96375: LD_INT 17
96377: PUSH
96378: LD_INT 18
96380: PUSH
96381: LD_INT 19
96383: PUSH
96384: LD_INT 20
96386: PUSH
96387: LD_INT 21
96389: PUSH
96390: LD_INT 22
96392: PUSH
96393: LD_INT 23
96395: PUSH
96396: LD_INT 24
96398: PUSH
96399: LD_INT 25
96401: PUSH
96402: LD_INT 26
96404: PUSH
96405: LD_INT 27
96407: PUSH
96408: LD_INT 28
96410: PUSH
96411: LD_INT 29
96413: PUSH
96414: LD_INT 30
96416: PUSH
96417: LD_INT 31
96419: PUSH
96420: LD_INT 32
96422: PUSH
96423: LD_INT 33
96425: PUSH
96426: LD_INT 34
96428: PUSH
96429: LD_INT 36
96431: PUSH
96432: EMPTY
96433: LIST
96434: LIST
96435: LIST
96436: LIST
96437: LIST
96438: LIST
96439: LIST
96440: LIST
96441: LIST
96442: LIST
96443: LIST
96444: LIST
96445: LIST
96446: LIST
96447: LIST
96448: LIST
96449: LIST
96450: LIST
96451: LIST
96452: LIST
96453: LIST
96454: LIST
96455: LIST
96456: LIST
96457: LIST
96458: LIST
96459: LIST
96460: LIST
96461: LIST
96462: LIST
96463: LIST
96464: LIST
96465: LIST
96466: LIST
96467: LIST
96468: PUSH
96469: LD_INT 101
96471: PUSH
96472: LD_INT 102
96474: PUSH
96475: LD_INT 103
96477: PUSH
96478: LD_INT 104
96480: PUSH
96481: LD_INT 105
96483: PUSH
96484: LD_INT 106
96486: PUSH
96487: LD_INT 107
96489: PUSH
96490: LD_INT 108
96492: PUSH
96493: LD_INT 109
96495: PUSH
96496: LD_INT 110
96498: PUSH
96499: LD_INT 111
96501: PUSH
96502: LD_INT 112
96504: PUSH
96505: LD_INT 113
96507: PUSH
96508: LD_INT 114
96510: PUSH
96511: LD_INT 116
96513: PUSH
96514: LD_INT 117
96516: PUSH
96517: LD_INT 118
96519: PUSH
96520: EMPTY
96521: LIST
96522: LIST
96523: LIST
96524: LIST
96525: LIST
96526: LIST
96527: LIST
96528: LIST
96529: LIST
96530: LIST
96531: LIST
96532: LIST
96533: LIST
96534: LIST
96535: LIST
96536: LIST
96537: LIST
96538: PUSH
96539: EMPTY
96540: LIST
96541: LIST
96542: ST_TO_ADDR
96543: GO 96942
96545: LD_INT 18
96547: DOUBLE
96548: EQUAL
96549: IFTRUE 96553
96551: GO 96701
96553: POP
// result := [ [ 2 , 4 , 5 , 7 , 11 , 12 , 15 , 16 , 20 , 21 , 22 , 23 , 25 , 26 , 30 , 31 , 32 , 33 , 34 , 35 , 36 ] , [ 101 , 102 , 103 , 106 , 108 , 112 , 113 , 114 , 115 , 116 , 117 , 118 ] ] ; 19 :
96554: LD_ADDR_VAR 0 2
96558: PUSH
96559: LD_INT 2
96561: PUSH
96562: LD_INT 4
96564: PUSH
96565: LD_INT 5
96567: PUSH
96568: LD_INT 7
96570: PUSH
96571: LD_INT 11
96573: PUSH
96574: LD_INT 12
96576: PUSH
96577: LD_INT 15
96579: PUSH
96580: LD_INT 16
96582: PUSH
96583: LD_INT 20
96585: PUSH
96586: LD_INT 21
96588: PUSH
96589: LD_INT 22
96591: PUSH
96592: LD_INT 23
96594: PUSH
96595: LD_INT 25
96597: PUSH
96598: LD_INT 26
96600: PUSH
96601: LD_INT 30
96603: PUSH
96604: LD_INT 31
96606: PUSH
96607: LD_INT 32
96609: PUSH
96610: LD_INT 33
96612: PUSH
96613: LD_INT 34
96615: PUSH
96616: LD_INT 35
96618: PUSH
96619: LD_INT 36
96621: PUSH
96622: EMPTY
96623: LIST
96624: LIST
96625: LIST
96626: LIST
96627: LIST
96628: LIST
96629: LIST
96630: LIST
96631: LIST
96632: LIST
96633: LIST
96634: LIST
96635: LIST
96636: LIST
96637: LIST
96638: LIST
96639: LIST
96640: LIST
96641: LIST
96642: LIST
96643: LIST
96644: PUSH
96645: LD_INT 101
96647: PUSH
96648: LD_INT 102
96650: PUSH
96651: LD_INT 103
96653: PUSH
96654: LD_INT 106
96656: PUSH
96657: LD_INT 108
96659: PUSH
96660: LD_INT 112
96662: PUSH
96663: LD_INT 113
96665: PUSH
96666: LD_INT 114
96668: PUSH
96669: LD_INT 115
96671: PUSH
96672: LD_INT 116
96674: PUSH
96675: LD_INT 117
96677: PUSH
96678: LD_INT 118
96680: PUSH
96681: EMPTY
96682: LIST
96683: LIST
96684: LIST
96685: LIST
96686: LIST
96687: LIST
96688: LIST
96689: LIST
96690: LIST
96691: LIST
96692: LIST
96693: LIST
96694: PUSH
96695: EMPTY
96696: LIST
96697: LIST
96698: ST_TO_ADDR
96699: GO 96942
96701: LD_INT 19
96703: DOUBLE
96704: EQUAL
96705: IFTRUE 96709
96707: GO 96941
96709: POP
// result := [ [ 1 , 2 , 3 , 4 , 5 , 6 , 7 , 8 , 9 , 10 , 11 , 12 , 13 , 14 , 15 , 16 , 17 , 18 , 19 , 20 , 21 , 22 , 23 , 24 , 25 , 26 , 27 , 28 , 29 , 30 , 31 , 32 , 33 , 34 , 35 , 36 ] , [ 101 , 102 , 103 , 104 , 105 , 106 , 107 , 108 , 109 , 110 , 111 , 112 , 113 , 114 , 115 , 116 , 117 , 118 ] ] ; end ;
96710: LD_ADDR_VAR 0 2
96714: PUSH
96715: LD_INT 1
96717: PUSH
96718: LD_INT 2
96720: PUSH
96721: LD_INT 3
96723: PUSH
96724: LD_INT 4
96726: PUSH
96727: LD_INT 5
96729: PUSH
96730: LD_INT 6
96732: PUSH
96733: LD_INT 7
96735: PUSH
96736: LD_INT 8
96738: PUSH
96739: LD_INT 9
96741: PUSH
96742: LD_INT 10
96744: PUSH
96745: LD_INT 11
96747: PUSH
96748: LD_INT 12
96750: PUSH
96751: LD_INT 13
96753: PUSH
96754: LD_INT 14
96756: PUSH
96757: LD_INT 15
96759: PUSH
96760: LD_INT 16
96762: PUSH
96763: LD_INT 17
96765: PUSH
96766: LD_INT 18
96768: PUSH
96769: LD_INT 19
96771: PUSH
96772: LD_INT 20
96774: PUSH
96775: LD_INT 21
96777: PUSH
96778: LD_INT 22
96780: PUSH
96781: LD_INT 23
96783: PUSH
96784: LD_INT 24
96786: PUSH
96787: LD_INT 25
96789: PUSH
96790: LD_INT 26
96792: PUSH
96793: LD_INT 27
96795: PUSH
96796: LD_INT 28
96798: PUSH
96799: LD_INT 29
96801: PUSH
96802: LD_INT 30
96804: PUSH
96805: LD_INT 31
96807: PUSH
96808: LD_INT 32
96810: PUSH
96811: LD_INT 33
96813: PUSH
96814: LD_INT 34
96816: PUSH
96817: LD_INT 35
96819: PUSH
96820: LD_INT 36
96822: PUSH
96823: EMPTY
96824: LIST
96825: LIST
96826: LIST
96827: LIST
96828: LIST
96829: LIST
96830: LIST
96831: LIST
96832: LIST
96833: LIST
96834: LIST
96835: LIST
96836: LIST
96837: LIST
96838: LIST
96839: LIST
96840: LIST
96841: LIST
96842: LIST
96843: LIST
96844: LIST
96845: LIST
96846: LIST
96847: LIST
96848: LIST
96849: LIST
96850: LIST
96851: LIST
96852: LIST
96853: LIST
96854: LIST
96855: LIST
96856: LIST
96857: LIST
96858: LIST
96859: LIST
96860: PUSH
96861: LD_INT 101
96863: PUSH
96864: LD_INT 102
96866: PUSH
96867: LD_INT 103
96869: PUSH
96870: LD_INT 104
96872: PUSH
96873: LD_INT 105
96875: PUSH
96876: LD_INT 106
96878: PUSH
96879: LD_INT 107
96881: PUSH
96882: LD_INT 108
96884: PUSH
96885: LD_INT 109
96887: PUSH
96888: LD_INT 110
96890: PUSH
96891: LD_INT 111
96893: PUSH
96894: LD_INT 112
96896: PUSH
96897: LD_INT 113
96899: PUSH
96900: LD_INT 114
96902: PUSH
96903: LD_INT 115
96905: PUSH
96906: LD_INT 116
96908: PUSH
96909: LD_INT 117
96911: PUSH
96912: LD_INT 118
96914: PUSH
96915: EMPTY
96916: LIST
96917: LIST
96918: LIST
96919: LIST
96920: LIST
96921: LIST
96922: LIST
96923: LIST
96924: LIST
96925: LIST
96926: LIST
96927: LIST
96928: LIST
96929: LIST
96930: LIST
96931: LIST
96932: LIST
96933: LIST
96934: PUSH
96935: EMPTY
96936: LIST
96937: LIST
96938: ST_TO_ADDR
96939: GO 96942
96941: POP
// end else
96942: GO 97173
// result := [ [ 1 , 2 , 3 , 4 , 5 , 6 , 7 , 8 , 9 , 10 , 11 , 12 , 13 , 14 , 15 , 16 , 17 , 18 , 19 , 20 , 21 , 22 , 23 , 24 , 25 , 26 , 27 , 28 , 29 , 30 , 31 , 32 , 33 , 34 , 35 , 36 ] , [ 101 , 102 , 103 , 104 , 105 , 106 , 107 , 108 , 109 , 110 , 111 , 112 , 113 , 114 , 115 , 116 , 117 , 118 ] ] ;
96944: LD_ADDR_VAR 0 2
96948: PUSH
96949: LD_INT 1
96951: PUSH
96952: LD_INT 2
96954: PUSH
96955: LD_INT 3
96957: PUSH
96958: LD_INT 4
96960: PUSH
96961: LD_INT 5
96963: PUSH
96964: LD_INT 6
96966: PUSH
96967: LD_INT 7
96969: PUSH
96970: LD_INT 8
96972: PUSH
96973: LD_INT 9
96975: PUSH
96976: LD_INT 10
96978: PUSH
96979: LD_INT 11
96981: PUSH
96982: LD_INT 12
96984: PUSH
96985: LD_INT 13
96987: PUSH
96988: LD_INT 14
96990: PUSH
96991: LD_INT 15
96993: PUSH
96994: LD_INT 16
96996: PUSH
96997: LD_INT 17
96999: PUSH
97000: LD_INT 18
97002: PUSH
97003: LD_INT 19
97005: PUSH
97006: LD_INT 20
97008: PUSH
97009: LD_INT 21
97011: PUSH
97012: LD_INT 22
97014: PUSH
97015: LD_INT 23
97017: PUSH
97018: LD_INT 24
97020: PUSH
97021: LD_INT 25
97023: PUSH
97024: LD_INT 26
97026: PUSH
97027: LD_INT 27
97029: PUSH
97030: LD_INT 28
97032: PUSH
97033: LD_INT 29
97035: PUSH
97036: LD_INT 30
97038: PUSH
97039: LD_INT 31
97041: PUSH
97042: LD_INT 32
97044: PUSH
97045: LD_INT 33
97047: PUSH
97048: LD_INT 34
97050: PUSH
97051: LD_INT 35
97053: PUSH
97054: LD_INT 36
97056: PUSH
97057: EMPTY
97058: LIST
97059: LIST
97060: LIST
97061: LIST
97062: LIST
97063: LIST
97064: LIST
97065: LIST
97066: LIST
97067: LIST
97068: LIST
97069: LIST
97070: LIST
97071: LIST
97072: LIST
97073: LIST
97074: LIST
97075: LIST
97076: LIST
97077: LIST
97078: LIST
97079: LIST
97080: LIST
97081: LIST
97082: LIST
97083: LIST
97084: LIST
97085: LIST
97086: LIST
97087: LIST
97088: LIST
97089: LIST
97090: LIST
97091: LIST
97092: LIST
97093: LIST
97094: PUSH
97095: LD_INT 101
97097: PUSH
97098: LD_INT 102
97100: PUSH
97101: LD_INT 103
97103: PUSH
97104: LD_INT 104
97106: PUSH
97107: LD_INT 105
97109: PUSH
97110: LD_INT 106
97112: PUSH
97113: LD_INT 107
97115: PUSH
97116: LD_INT 108
97118: PUSH
97119: LD_INT 109
97121: PUSH
97122: LD_INT 110
97124: PUSH
97125: LD_INT 111
97127: PUSH
97128: LD_INT 112
97130: PUSH
97131: LD_INT 113
97133: PUSH
97134: LD_INT 114
97136: PUSH
97137: LD_INT 115
97139: PUSH
97140: LD_INT 116
97142: PUSH
97143: LD_INT 117
97145: PUSH
97146: LD_INT 118
97148: PUSH
97149: EMPTY
97150: LIST
97151: LIST
97152: LIST
97153: LIST
97154: LIST
97155: LIST
97156: LIST
97157: LIST
97158: LIST
97159: LIST
97160: LIST
97161: LIST
97162: LIST
97163: LIST
97164: LIST
97165: LIST
97166: LIST
97167: LIST
97168: PUSH
97169: EMPTY
97170: LIST
97171: LIST
97172: ST_TO_ADDR
// if result then
97173: LD_VAR 0 2
97177: IFFALSE 97963
// begin normal :=  ;
97179: LD_ADDR_VAR 0 5
97183: PUSH
97184: LD_STRING 
97186: ST_TO_ADDR
// hardcore :=  ;
97187: LD_ADDR_VAR 0 6
97191: PUSH
97192: LD_STRING 
97194: ST_TO_ADDR
// active :=  ;
97195: LD_ADDR_VAR 0 7
97199: PUSH
97200: LD_STRING 
97202: ST_TO_ADDR
// for i = 1 to normalCounter do
97203: LD_ADDR_VAR 0 8
97207: PUSH
97208: DOUBLE
97209: LD_INT 1
97211: DEC
97212: ST_TO_ADDR
97213: LD_EXP 140
97217: PUSH
97218: FOR_TO
97219: IFFALSE 97320
// begin tmp := 0 ;
97221: LD_ADDR_VAR 0 3
97225: PUSH
97226: LD_STRING 0
97228: ST_TO_ADDR
// if result [ 1 ] then
97229: LD_VAR 0 2
97233: PUSH
97234: LD_INT 1
97236: ARRAY
97237: IFFALSE 97302
// if result [ 1 ] [ 1 ] = i then
97239: LD_VAR 0 2
97243: PUSH
97244: LD_INT 1
97246: ARRAY
97247: PUSH
97248: LD_INT 1
97250: ARRAY
97251: PUSH
97252: LD_VAR 0 8
97256: EQUAL
97257: IFFALSE 97302
// begin result := Replace ( result , 1 , Delete ( result [ 1 ] , 1 ) ) ;
97259: LD_ADDR_VAR 0 2
97263: PUSH
97264: LD_VAR 0 2
97268: PPUSH
97269: LD_INT 1
97271: PPUSH
97272: LD_VAR 0 2
97276: PUSH
97277: LD_INT 1
97279: ARRAY
97280: PPUSH
97281: LD_INT 1
97283: PPUSH
97284: CALL_OW 3
97288: PPUSH
97289: CALL_OW 1
97293: ST_TO_ADDR
// tmp := 1 ;
97294: LD_ADDR_VAR 0 3
97298: PUSH
97299: LD_STRING 1
97301: ST_TO_ADDR
// end ; normal := normal & tmp ;
97302: LD_ADDR_VAR 0 5
97306: PUSH
97307: LD_VAR 0 5
97311: PUSH
97312: LD_VAR 0 3
97316: STR
97317: ST_TO_ADDR
// end ;
97318: GO 97218
97320: POP
97321: POP
// for i = 1 to hardcoreCounter do
97322: LD_ADDR_VAR 0 8
97326: PUSH
97327: DOUBLE
97328: LD_INT 1
97330: DEC
97331: ST_TO_ADDR
97332: LD_EXP 141
97336: PUSH
97337: FOR_TO
97338: IFFALSE 97443
// begin tmp := 0 ;
97340: LD_ADDR_VAR 0 3
97344: PUSH
97345: LD_STRING 0
97347: ST_TO_ADDR
// if result [ 2 ] then
97348: LD_VAR 0 2
97352: PUSH
97353: LD_INT 2
97355: ARRAY
97356: IFFALSE 97425
// if result [ 2 ] [ 1 ] = 100 + i then
97358: LD_VAR 0 2
97362: PUSH
97363: LD_INT 2
97365: ARRAY
97366: PUSH
97367: LD_INT 1
97369: ARRAY
97370: PUSH
97371: LD_INT 100
97373: PUSH
97374: LD_VAR 0 8
97378: PLUS
97379: EQUAL
97380: IFFALSE 97425
// begin result := Replace ( result , 2 , Delete ( result [ 2 ] , 1 ) ) ;
97382: LD_ADDR_VAR 0 2
97386: PUSH
97387: LD_VAR 0 2
97391: PPUSH
97392: LD_INT 2
97394: PPUSH
97395: LD_VAR 0 2
97399: PUSH
97400: LD_INT 2
97402: ARRAY
97403: PPUSH
97404: LD_INT 1
97406: PPUSH
97407: CALL_OW 3
97411: PPUSH
97412: CALL_OW 1
97416: ST_TO_ADDR
// tmp := 1 ;
97417: LD_ADDR_VAR 0 3
97421: PUSH
97422: LD_STRING 1
97424: ST_TO_ADDR
// end ; hardcore := hardcore & tmp ;
97425: LD_ADDR_VAR 0 6
97429: PUSH
97430: LD_VAR 0 6
97434: PUSH
97435: LD_VAR 0 3
97439: STR
97440: ST_TO_ADDR
// end ;
97441: GO 97337
97443: POP
97444: POP
// if isGameLoad then
97445: LD_VAR 0 1
97449: IFFALSE 97924
// begin flags := [ sRocket , sSpeed , sEngine , sSpec , sLevel , sArmoury , sRadar , sBunker , sHack , sFire , sRefresh , sExp , sDepot , sFlag , sKamikadze , sTroll , sSlow , sLack , sTank , sRemote , sPowell , sTeleport , sOilTower , sShovel , sSheik , sEarthquake , sAI , sCargo , sDLaser , sExchange , sFac , sPower , sRandom , sShield , sTime , sTools , sSold , sDiff , sFog , sReset , sSun , sTiger , sBomb , sWound , sBetray , sContamin , sOil , sStu , sBazooka , sMortar , sRanger , sComputer , s30 , s60 ] ;
97451: LD_ADDR_VAR 0 4
97455: PUSH
97456: LD_EXP 144
97460: PUSH
97461: LD_EXP 143
97465: PUSH
97466: LD_EXP 145
97470: PUSH
97471: LD_EXP 142
97475: PUSH
97476: LD_EXP 146
97480: PUSH
97481: LD_EXP 147
97485: PUSH
97486: LD_EXP 148
97490: PUSH
97491: LD_EXP 149
97495: PUSH
97496: LD_EXP 150
97500: PUSH
97501: LD_EXP 151
97505: PUSH
97506: LD_EXP 152
97510: PUSH
97511: LD_EXP 153
97515: PUSH
97516: LD_EXP 154
97520: PUSH
97521: LD_EXP 155
97525: PUSH
97526: LD_EXP 163
97530: PUSH
97531: LD_EXP 164
97535: PUSH
97536: LD_EXP 165
97540: PUSH
97541: LD_EXP 166
97545: PUSH
97546: LD_EXP 168
97550: PUSH
97551: LD_EXP 169
97555: PUSH
97556: LD_EXP 170
97560: PUSH
97561: LD_EXP 173
97565: PUSH
97566: LD_EXP 175
97570: PUSH
97571: LD_EXP 176
97575: PUSH
97576: LD_EXP 177
97580: PUSH
97581: LD_EXP 179
97585: PUSH
97586: LD_EXP 180
97590: PUSH
97591: LD_EXP 183
97595: PUSH
97596: LD_EXP 184
97600: PUSH
97601: LD_EXP 185
97605: PUSH
97606: LD_EXP 186
97610: PUSH
97611: LD_EXP 187
97615: PUSH
97616: LD_EXP 188
97620: PUSH
97621: LD_EXP 189
97625: PUSH
97626: LD_EXP 190
97630: PUSH
97631: LD_EXP 191
97635: PUSH
97636: LD_EXP 156
97640: PUSH
97641: LD_EXP 157
97645: PUSH
97646: LD_EXP 160
97650: PUSH
97651: LD_EXP 161
97655: PUSH
97656: LD_EXP 162
97660: PUSH
97661: LD_EXP 158
97665: PUSH
97666: LD_EXP 159
97670: PUSH
97671: LD_EXP 167
97675: PUSH
97676: LD_EXP 171
97680: PUSH
97681: LD_EXP 172
97685: PUSH
97686: LD_EXP 174
97690: PUSH
97691: LD_EXP 178
97695: PUSH
97696: LD_EXP 181
97700: PUSH
97701: LD_EXP 182
97705: PUSH
97706: LD_EXP 192
97710: PUSH
97711: LD_EXP 193
97715: PUSH
97716: LD_EXP 194
97720: PUSH
97721: LD_EXP 195
97725: PUSH
97726: EMPTY
97727: LIST
97728: LIST
97729: LIST
97730: LIST
97731: LIST
97732: LIST
97733: LIST
97734: LIST
97735: LIST
97736: LIST
97737: LIST
97738: LIST
97739: LIST
97740: LIST
97741: LIST
97742: LIST
97743: LIST
97744: LIST
97745: LIST
97746: LIST
97747: LIST
97748: LIST
97749: LIST
97750: LIST
97751: LIST
97752: LIST
97753: LIST
97754: LIST
97755: LIST
97756: LIST
97757: LIST
97758: LIST
97759: LIST
97760: LIST
97761: LIST
97762: LIST
97763: LIST
97764: LIST
97765: LIST
97766: LIST
97767: LIST
97768: LIST
97769: LIST
97770: LIST
97771: LIST
97772: LIST
97773: LIST
97774: LIST
97775: LIST
97776: LIST
97777: LIST
97778: LIST
97779: LIST
97780: LIST
97781: ST_TO_ADDR
// tmp :=  ;
97782: LD_ADDR_VAR 0 3
97786: PUSH
97787: LD_STRING 
97789: ST_TO_ADDR
// for i = 1 to normalCounter do
97790: LD_ADDR_VAR 0 8
97794: PUSH
97795: DOUBLE
97796: LD_INT 1
97798: DEC
97799: ST_TO_ADDR
97800: LD_EXP 140
97804: PUSH
97805: FOR_TO
97806: IFFALSE 97842
// begin if flags [ i ] then
97808: LD_VAR 0 4
97812: PUSH
97813: LD_VAR 0 8
97817: ARRAY
97818: IFFALSE 97840
// tmp := tmp & i & ; ;
97820: LD_ADDR_VAR 0 3
97824: PUSH
97825: LD_VAR 0 3
97829: PUSH
97830: LD_VAR 0 8
97834: STR
97835: PUSH
97836: LD_STRING ;
97838: STR
97839: ST_TO_ADDR
// end ;
97840: GO 97805
97842: POP
97843: POP
// for i = 1 to hardcoreCounter do
97844: LD_ADDR_VAR 0 8
97848: PUSH
97849: DOUBLE
97850: LD_INT 1
97852: DEC
97853: ST_TO_ADDR
97854: LD_EXP 141
97858: PUSH
97859: FOR_TO
97860: IFFALSE 97906
// begin if flags [ normalCounter + i ] then
97862: LD_VAR 0 4
97866: PUSH
97867: LD_EXP 140
97871: PUSH
97872: LD_VAR 0 8
97876: PLUS
97877: ARRAY
97878: IFFALSE 97904
// tmp := tmp & ( 100 + i ) & ; ;
97880: LD_ADDR_VAR 0 3
97884: PUSH
97885: LD_VAR 0 3
97889: PUSH
97890: LD_INT 100
97892: PUSH
97893: LD_VAR 0 8
97897: PLUS
97898: STR
97899: PUSH
97900: LD_STRING ;
97902: STR
97903: ST_TO_ADDR
// end ;
97904: GO 97859
97906: POP
97907: POP
// if tmp then
97908: LD_VAR 0 3
97912: IFFALSE 97924
// active := tmp ;
97914: LD_ADDR_VAR 0 7
97918: PUSH
97919: LD_VAR 0 3
97923: ST_TO_ADDR
// end ; ToLua ( getStreamItemsFromMission(" & normal & "," & hardcore & "," & active & ") ) ;
97924: LD_STRING getStreamItemsFromMission("
97926: PUSH
97927: LD_VAR 0 5
97931: STR
97932: PUSH
97933: LD_STRING ","
97935: STR
97936: PUSH
97937: LD_VAR 0 6
97941: STR
97942: PUSH
97943: LD_STRING ","
97945: STR
97946: PUSH
97947: LD_VAR 0 7
97951: STR
97952: PUSH
97953: LD_STRING ")
97955: STR
97956: PPUSH
97957: CALL_OW 559
// end else
97961: GO 97970
// ToLua ( getStreamItemsFromMission("","","") ) ;
97963: LD_STRING getStreamItemsFromMission("","","")
97965: PPUSH
97966: CALL_OW 559
// end ;
97970: LD_VAR 0 2
97974: RET
// every 0 0$2 trigger StreamModeActive and sRocket do var i , tmp ;
97975: LD_EXP 139
97979: PUSH
97980: LD_EXP 144
97984: AND
97985: IFFALSE 98109
97987: GO 97989
97989: DISABLE
97990: LD_INT 0
97992: PPUSH
97993: PPUSH
// begin enable ;
97994: ENABLE
// tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_or , [ f_weapon , us_rocket_launcher ] , [ f_weapon , ru_rocket_launcher ] , [ f_weapon , ar_rocket_launcher ] , [ f_weapon , ru_rocket ] ] ] ) ;
97995: LD_ADDR_VAR 0 2
97999: PUSH
98000: LD_INT 22
98002: PUSH
98003: LD_OWVAR 2
98007: PUSH
98008: EMPTY
98009: LIST
98010: LIST
98011: PUSH
98012: LD_INT 2
98014: PUSH
98015: LD_INT 34
98017: PUSH
98018: LD_INT 7
98020: PUSH
98021: EMPTY
98022: LIST
98023: LIST
98024: PUSH
98025: LD_INT 34
98027: PUSH
98028: LD_INT 45
98030: PUSH
98031: EMPTY
98032: LIST
98033: LIST
98034: PUSH
98035: LD_INT 34
98037: PUSH
98038: LD_INT 28
98040: PUSH
98041: EMPTY
98042: LIST
98043: LIST
98044: PUSH
98045: LD_INT 34
98047: PUSH
98048: LD_INT 47
98050: PUSH
98051: EMPTY
98052: LIST
98053: LIST
98054: PUSH
98055: EMPTY
98056: LIST
98057: LIST
98058: LIST
98059: LIST
98060: LIST
98061: PUSH
98062: EMPTY
98063: LIST
98064: LIST
98065: PPUSH
98066: CALL_OW 69
98070: ST_TO_ADDR
// if not tmp then
98071: LD_VAR 0 2
98075: NOT
98076: IFFALSE 98080
// exit ;
98078: GO 98109
// for i in tmp do
98080: LD_ADDR_VAR 0 1
98084: PUSH
98085: LD_VAR 0 2
98089: PUSH
98090: FOR_IN
98091: IFFALSE 98107
// begin SetLives ( i , 0 ) ;
98093: LD_VAR 0 1
98097: PPUSH
98098: LD_INT 0
98100: PPUSH
98101: CALL_OW 234
// end ;
98105: GO 98090
98107: POP
98108: POP
// end ;
98109: PPOPN 2
98111: END
// every 0 0$2 trigger StreamModeActive and sEngine do var i , tmp ;
98112: LD_EXP 139
98116: PUSH
98117: LD_EXP 145
98121: AND
98122: IFFALSE 98206
98124: GO 98126
98126: DISABLE
98127: LD_INT 0
98129: PPUSH
98130: PPUSH
// begin enable ;
98131: ENABLE
// tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_engine , engine_siberite ] ] ) ;
98132: LD_ADDR_VAR 0 2
98136: PUSH
98137: LD_INT 22
98139: PUSH
98140: LD_OWVAR 2
98144: PUSH
98145: EMPTY
98146: LIST
98147: LIST
98148: PUSH
98149: LD_INT 32
98151: PUSH
98152: LD_INT 3
98154: PUSH
98155: EMPTY
98156: LIST
98157: LIST
98158: PUSH
98159: EMPTY
98160: LIST
98161: LIST
98162: PPUSH
98163: CALL_OW 69
98167: ST_TO_ADDR
// if not tmp then
98168: LD_VAR 0 2
98172: NOT
98173: IFFALSE 98177
// exit ;
98175: GO 98206
// for i in tmp do
98177: LD_ADDR_VAR 0 1
98181: PUSH
98182: LD_VAR 0 2
98186: PUSH
98187: FOR_IN
98188: IFFALSE 98204
// begin SetLives ( i , 0 ) ;
98190: LD_VAR 0 1
98194: PPUSH
98195: LD_INT 0
98197: PPUSH
98198: CALL_OW 234
// end ;
98202: GO 98187
98204: POP
98205: POP
// end ;
98206: PPOPN 2
98208: END
// every 0 0$1 trigger StreamModeActive and sSpec do var i ;
98209: LD_EXP 139
98213: PUSH
98214: LD_EXP 142
98218: AND
98219: IFFALSE 98312
98221: GO 98223
98223: DISABLE
98224: LD_INT 0
98226: PPUSH
// begin enable ;
98227: ENABLE
// for i in FilterAllUnits ( [ [ f_side , your_side ] , [ f_or , [ f_class , class_sniper ] , [ f_class , class_bazooker ] , [ f_class , class_mortar ] ] ] ) do
98228: LD_ADDR_VAR 0 1
98232: PUSH
98233: LD_INT 22
98235: PUSH
98236: LD_OWVAR 2
98240: PUSH
98241: EMPTY
98242: LIST
98243: LIST
98244: PUSH
98245: LD_INT 2
98247: PUSH
98248: LD_INT 25
98250: PUSH
98251: LD_INT 5
98253: PUSH
98254: EMPTY
98255: LIST
98256: LIST
98257: PUSH
98258: LD_INT 25
98260: PUSH
98261: LD_INT 9
98263: PUSH
98264: EMPTY
98265: LIST
98266: LIST
98267: PUSH
98268: LD_INT 25
98270: PUSH
98271: LD_INT 8
98273: PUSH
98274: EMPTY
98275: LIST
98276: LIST
98277: PUSH
98278: EMPTY
98279: LIST
98280: LIST
98281: LIST
98282: LIST
98283: PUSH
98284: EMPTY
98285: LIST
98286: LIST
98287: PPUSH
98288: CALL_OW 69
98292: PUSH
98293: FOR_IN
98294: IFFALSE 98310
// begin SetClass ( i , 1 ) ;
98296: LD_VAR 0 1
98300: PPUSH
98301: LD_INT 1
98303: PPUSH
98304: CALL_OW 336
// end ;
98308: GO 98293
98310: POP
98311: POP
// end ;
98312: PPOPN 1
98314: END
// every 0 0$1 trigger StreamModeActive and sSpeed and game_speed < 7 do
98315: LD_EXP 139
98319: PUSH
98320: LD_EXP 143
98324: AND
98325: PUSH
98326: LD_OWVAR 65
98330: PUSH
98331: LD_INT 7
98333: LESS
98334: AND
98335: IFFALSE 98349
98337: GO 98339
98339: DISABLE
// begin enable ;
98340: ENABLE
// game_speed := 7 ;
98341: LD_ADDR_OWVAR 65
98345: PUSH
98346: LD_INT 7
98348: ST_TO_ADDR
// end ;
98349: END
// every 0 0$1 trigger StreamModeActive and sLevel do var i , k , tmp ;
98350: LD_EXP 139
98354: PUSH
98355: LD_EXP 146
98359: AND
98360: IFFALSE 98562
98362: GO 98364
98364: DISABLE
98365: LD_INT 0
98367: PPUSH
98368: PPUSH
98369: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_enemy , your_side ] , [ f_type , unit_human ] ] ) ;
98370: LD_ADDR_VAR 0 3
98374: PUSH
98375: LD_INT 81
98377: PUSH
98378: LD_OWVAR 2
98382: PUSH
98383: EMPTY
98384: LIST
98385: LIST
98386: PUSH
98387: LD_INT 21
98389: PUSH
98390: LD_INT 1
98392: PUSH
98393: EMPTY
98394: LIST
98395: LIST
98396: PUSH
98397: EMPTY
98398: LIST
98399: LIST
98400: PPUSH
98401: CALL_OW 69
98405: ST_TO_ADDR
// if not tmp then
98406: LD_VAR 0 3
98410: NOT
98411: IFFALSE 98415
// exit ;
98413: GO 98562
// if tmp > 5 then
98415: LD_VAR 0 3
98419: PUSH
98420: LD_INT 5
98422: GREATER
98423: IFFALSE 98435
// k := 5 else
98425: LD_ADDR_VAR 0 2
98429: PUSH
98430: LD_INT 5
98432: ST_TO_ADDR
98433: GO 98445
// k := tmp ;
98435: LD_ADDR_VAR 0 2
98439: PUSH
98440: LD_VAR 0 3
98444: ST_TO_ADDR
// for i := 1 to k do
98445: LD_ADDR_VAR 0 1
98449: PUSH
98450: DOUBLE
98451: LD_INT 1
98453: DEC
98454: ST_TO_ADDR
98455: LD_VAR 0 2
98459: PUSH
98460: FOR_TO
98461: IFFALSE 98560
// if GetSkill ( tmp [ i ] , i mod 4 + 1 ) < 10 then
98463: LD_VAR 0 3
98467: PUSH
98468: LD_VAR 0 1
98472: ARRAY
98473: PPUSH
98474: LD_VAR 0 1
98478: PUSH
98479: LD_INT 4
98481: MOD
98482: PUSH
98483: LD_INT 1
98485: PLUS
98486: PPUSH
98487: CALL_OW 259
98491: PUSH
98492: LD_INT 10
98494: LESS
98495: IFFALSE 98558
// SetSkill ( tmp [ i ] , i mod 4 + 1 , GetSkill ( tmp [ i ] , i mod 4 + 1 ) + 1 ) ;
98497: LD_VAR 0 3
98501: PUSH
98502: LD_VAR 0 1
98506: ARRAY
98507: PPUSH
98508: LD_VAR 0 1
98512: PUSH
98513: LD_INT 4
98515: MOD
98516: PUSH
98517: LD_INT 1
98519: PLUS
98520: PPUSH
98521: LD_VAR 0 3
98525: PUSH
98526: LD_VAR 0 1
98530: ARRAY
98531: PPUSH
98532: LD_VAR 0 1
98536: PUSH
98537: LD_INT 4
98539: MOD
98540: PUSH
98541: LD_INT 1
98543: PLUS
98544: PPUSH
98545: CALL_OW 259
98549: PUSH
98550: LD_INT 1
98552: PLUS
98553: PPUSH
98554: CALL_OW 237
98558: GO 98460
98560: POP
98561: POP
// end ;
98562: PPOPN 3
98564: END
// every 0 0$1 trigger StreamModeActive and sArmoury do
98565: LD_EXP 139
98569: PUSH
98570: LD_EXP 147
98574: AND
98575: IFFALSE 98595
98577: GO 98579
98579: DISABLE
// SetRestrict ( b_armoury , your_side , false ) ;
98580: LD_INT 4
98582: PPUSH
98583: LD_OWVAR 2
98587: PPUSH
98588: LD_INT 0
98590: PPUSH
98591: CALL_OW 324
98595: END
// every 0 0$1 trigger StreamModeActive and sShovel do
98596: LD_EXP 139
98600: PUSH
98601: LD_EXP 176
98605: AND
98606: IFFALSE 98626
98608: GO 98610
98610: DISABLE
// SetRestrict ( b_ext_noncombat , your_side , false ) ;
98611: LD_INT 19
98613: PPUSH
98614: LD_OWVAR 2
98618: PPUSH
98619: LD_INT 0
98621: PPUSH
98622: CALL_OW 324
98626: END
// every 0 0$1 trigger StreamModeActive and sRadar do var i , tmp ;
98627: LD_EXP 139
98631: PUSH
98632: LD_EXP 148
98636: AND
98637: IFFALSE 98739
98639: GO 98641
98641: DISABLE
98642: LD_INT 0
98644: PPUSH
98645: PPUSH
// begin enable ;
98646: ENABLE
// tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_or , [ f_weapon , us_radar ] , [ f_weapon , ar_radar ] ] ] ) ;
98647: LD_ADDR_VAR 0 2
98651: PUSH
98652: LD_INT 22
98654: PUSH
98655: LD_OWVAR 2
98659: PUSH
98660: EMPTY
98661: LIST
98662: LIST
98663: PUSH
98664: LD_INT 2
98666: PUSH
98667: LD_INT 34
98669: PUSH
98670: LD_INT 11
98672: PUSH
98673: EMPTY
98674: LIST
98675: LIST
98676: PUSH
98677: LD_INT 34
98679: PUSH
98680: LD_INT 30
98682: PUSH
98683: EMPTY
98684: LIST
98685: LIST
98686: PUSH
98687: EMPTY
98688: LIST
98689: LIST
98690: LIST
98691: PUSH
98692: EMPTY
98693: LIST
98694: LIST
98695: PPUSH
98696: CALL_OW 69
98700: ST_TO_ADDR
// if not tmp then
98701: LD_VAR 0 2
98705: NOT
98706: IFFALSE 98710
// exit ;
98708: GO 98739
// for i in tmp do
98710: LD_ADDR_VAR 0 1
98714: PUSH
98715: LD_VAR 0 2
98719: PUSH
98720: FOR_IN
98721: IFFALSE 98737
// begin SetLives ( i , 0 ) ;
98723: LD_VAR 0 1
98727: PPUSH
98728: LD_INT 0
98730: PPUSH
98731: CALL_OW 234
// end ;
98735: GO 98720
98737: POP
98738: POP
// end ;
98739: PPOPN 2
98741: END
// every 0 0$1 trigger StreamModeActive and sBunker do
98742: LD_EXP 139
98746: PUSH
98747: LD_EXP 149
98751: AND
98752: IFFALSE 98772
98754: GO 98756
98756: DISABLE
// SetRestrict ( b_bunker , your_side , false ) ;
98757: LD_INT 32
98759: PPUSH
98760: LD_OWVAR 2
98764: PPUSH
98765: LD_INT 0
98767: PPUSH
98768: CALL_OW 324
98772: END
// every 0 0$1 trigger StreamModeActive and sHack do var i , tmp , side ;
98773: LD_EXP 139
98777: PUSH
98778: LD_EXP 150
98782: AND
98783: IFFALSE 98964
98785: GO 98787
98787: DISABLE
98788: LD_INT 0
98790: PPUSH
98791: PPUSH
98792: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_control , control_computer ] ] ) ;
98793: LD_ADDR_VAR 0 2
98797: PUSH
98798: LD_INT 22
98800: PUSH
98801: LD_OWVAR 2
98805: PUSH
98806: EMPTY
98807: LIST
98808: LIST
98809: PUSH
98810: LD_INT 33
98812: PUSH
98813: LD_INT 3
98815: PUSH
98816: EMPTY
98817: LIST
98818: LIST
98819: PUSH
98820: EMPTY
98821: LIST
98822: LIST
98823: PPUSH
98824: CALL_OW 69
98828: ST_TO_ADDR
// if not tmp then
98829: LD_VAR 0 2
98833: NOT
98834: IFFALSE 98838
// exit ;
98836: GO 98964
// side := 0 ;
98838: LD_ADDR_VAR 0 3
98842: PUSH
98843: LD_INT 0
98845: ST_TO_ADDR
// for i := 1 to 8 do
98846: LD_ADDR_VAR 0 1
98850: PUSH
98851: DOUBLE
98852: LD_INT 1
98854: DEC
98855: ST_TO_ADDR
98856: LD_INT 8
98858: PUSH
98859: FOR_TO
98860: IFFALSE 98908
// if your_side <> i and GetAttitude ( your_side , i ) = att_enemy then
98862: LD_OWVAR 2
98866: PUSH
98867: LD_VAR 0 1
98871: NONEQUAL
98872: PUSH
98873: LD_OWVAR 2
98877: PPUSH
98878: LD_VAR 0 1
98882: PPUSH
98883: CALL_OW 81
98887: PUSH
98888: LD_INT 2
98890: EQUAL
98891: AND
98892: IFFALSE 98906
// begin side := i ;
98894: LD_ADDR_VAR 0 3
98898: PUSH
98899: LD_VAR 0 1
98903: ST_TO_ADDR
// break ;
98904: GO 98908
// end ;
98906: GO 98859
98908: POP
98909: POP
// if not side then
98910: LD_VAR 0 3
98914: NOT
98915: IFFALSE 98919
// exit ;
98917: GO 98964
// for i := 1 to tmp do
98919: LD_ADDR_VAR 0 1
98923: PUSH
98924: DOUBLE
98925: LD_INT 1
98927: DEC
98928: ST_TO_ADDR
98929: LD_VAR 0 2
98933: PUSH
98934: FOR_TO
98935: IFFALSE 98962
// if Prob ( 60 ) then
98937: LD_INT 60
98939: PPUSH
98940: CALL_OW 13
98944: IFFALSE 98960
// SetSide ( i , side ) ;
98946: LD_VAR 0 1
98950: PPUSH
98951: LD_VAR 0 3
98955: PPUSH
98956: CALL_OW 235
98960: GO 98934
98962: POP
98963: POP
// end ;
98964: PPOPN 3
98966: END
// every 0 0$1 trigger StreamModeActive and sRefresh do var un ;
98967: LD_EXP 139
98971: PUSH
98972: LD_EXP 152
98976: AND
98977: IFFALSE 99096
98979: GO 98981
98981: DISABLE
98982: LD_INT 0
98984: PPUSH
// begin for un in FilterAllUnits ( [ [ f_side , your_side ] , [ f_type , unit_human ] , [ f_not , [ f_nation , 0 ] ] ] ) do
98985: LD_ADDR_VAR 0 1
98989: PUSH
98990: LD_INT 22
98992: PUSH
98993: LD_OWVAR 2
98997: PUSH
98998: EMPTY
98999: LIST
99000: LIST
99001: PUSH
99002: LD_INT 21
99004: PUSH
99005: LD_INT 1
99007: PUSH
99008: EMPTY
99009: LIST
99010: LIST
99011: PUSH
99012: LD_INT 3
99014: PUSH
99015: LD_INT 23
99017: PUSH
99018: LD_INT 0
99020: PUSH
99021: EMPTY
99022: LIST
99023: LIST
99024: PUSH
99025: EMPTY
99026: LIST
99027: LIST
99028: PUSH
99029: EMPTY
99030: LIST
99031: LIST
99032: LIST
99033: PPUSH
99034: CALL_OW 69
99038: PUSH
99039: FOR_IN
99040: IFFALSE 99094
// if GetClass ( un ) in [ 1 , 2 , 3 , 4 ] then
99042: LD_VAR 0 1
99046: PPUSH
99047: CALL_OW 257
99051: PUSH
99052: LD_INT 1
99054: PUSH
99055: LD_INT 2
99057: PUSH
99058: LD_INT 3
99060: PUSH
99061: LD_INT 4
99063: PUSH
99064: EMPTY
99065: LIST
99066: LIST
99067: LIST
99068: LIST
99069: IN
99070: IFFALSE 99092
// SetClass ( un , rand ( 1 , 4 ) ) ;
99072: LD_VAR 0 1
99076: PPUSH
99077: LD_INT 1
99079: PPUSH
99080: LD_INT 4
99082: PPUSH
99083: CALL_OW 12
99087: PPUSH
99088: CALL_OW 336
99092: GO 99039
99094: POP
99095: POP
// end ;
99096: PPOPN 1
99098: END
// every 0 0$1 trigger StreamModeActive and sFire do var tmp ;
99099: LD_EXP 139
99103: PUSH
99104: LD_EXP 151
99108: AND
99109: IFFALSE 99188
99111: GO 99113
99113: DISABLE
99114: LD_INT 0
99116: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_type , unit_building ] ] ) ;
99117: LD_ADDR_VAR 0 1
99121: PUSH
99122: LD_INT 22
99124: PUSH
99125: LD_OWVAR 2
99129: PUSH
99130: EMPTY
99131: LIST
99132: LIST
99133: PUSH
99134: LD_INT 21
99136: PUSH
99137: LD_INT 3
99139: PUSH
99140: EMPTY
99141: LIST
99142: LIST
99143: PUSH
99144: EMPTY
99145: LIST
99146: LIST
99147: PPUSH
99148: CALL_OW 69
99152: ST_TO_ADDR
// if not tmp then
99153: LD_VAR 0 1
99157: NOT
99158: IFFALSE 99162
// exit ;
99160: GO 99188
// SetLives ( tmp [ rand ( 1 , tmp ) ] , 100 ) ;
99162: LD_VAR 0 1
99166: PUSH
99167: LD_INT 1
99169: PPUSH
99170: LD_VAR 0 1
99174: PPUSH
99175: CALL_OW 12
99179: ARRAY
99180: PPUSH
99181: LD_INT 100
99183: PPUSH
99184: CALL_OW 234
// end ;
99188: PPOPN 1
99190: END
// every 0 0$1 trigger StreamModeActive and sExp do var tmp ;
99191: LD_EXP 139
99195: PUSH
99196: LD_EXP 153
99200: AND
99201: IFFALSE 99299
99203: GO 99205
99205: DISABLE
99206: LD_INT 0
99208: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_type , unit_human ] ] ) ;
99209: LD_ADDR_VAR 0 1
99213: PUSH
99214: LD_INT 22
99216: PUSH
99217: LD_OWVAR 2
99221: PUSH
99222: EMPTY
99223: LIST
99224: LIST
99225: PUSH
99226: LD_INT 21
99228: PUSH
99229: LD_INT 1
99231: PUSH
99232: EMPTY
99233: LIST
99234: LIST
99235: PUSH
99236: EMPTY
99237: LIST
99238: LIST
99239: PPUSH
99240: CALL_OW 69
99244: ST_TO_ADDR
// if not tmp then
99245: LD_VAR 0 1
99249: NOT
99250: IFFALSE 99254
// exit ;
99252: GO 99299
// AddExperience ( tmp [ rand ( 1 , tmp ) ] , rand ( 1 , 4 ) , rand ( 3000 , 9000 ) ) ;
99254: LD_VAR 0 1
99258: PUSH
99259: LD_INT 1
99261: PPUSH
99262: LD_VAR 0 1
99266: PPUSH
99267: CALL_OW 12
99271: ARRAY
99272: PPUSH
99273: LD_INT 1
99275: PPUSH
99276: LD_INT 4
99278: PPUSH
99279: CALL_OW 12
99283: PPUSH
99284: LD_INT 3000
99286: PPUSH
99287: LD_INT 9000
99289: PPUSH
99290: CALL_OW 12
99294: PPUSH
99295: CALL_OW 492
// end ;
99299: PPOPN 1
99301: END
// every 0 0$1 trigger StreamModeActive and sDepot do
99302: LD_EXP 139
99306: PUSH
99307: LD_EXP 154
99311: AND
99312: IFFALSE 99332
99314: GO 99316
99316: DISABLE
// SetRestrict ( b_warehouse , your_side , false ) ;
99317: LD_INT 1
99319: PPUSH
99320: LD_OWVAR 2
99324: PPUSH
99325: LD_INT 0
99327: PPUSH
99328: CALL_OW 324
99332: END
// every 0 0$1 trigger StreamModeActive and sFlag do var i , tmp ;
99333: LD_EXP 139
99337: PUSH
99338: LD_EXP 155
99342: AND
99343: IFFALSE 99426
99345: GO 99347
99347: DISABLE
99348: LD_INT 0
99350: PPUSH
99351: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_type , unit_building ] ] ) ;
99352: LD_ADDR_VAR 0 2
99356: PUSH
99357: LD_INT 22
99359: PUSH
99360: LD_OWVAR 2
99364: PUSH
99365: EMPTY
99366: LIST
99367: LIST
99368: PUSH
99369: LD_INT 21
99371: PUSH
99372: LD_INT 3
99374: PUSH
99375: EMPTY
99376: LIST
99377: LIST
99378: PUSH
99379: EMPTY
99380: LIST
99381: LIST
99382: PPUSH
99383: CALL_OW 69
99387: ST_TO_ADDR
// if not tmp then
99388: LD_VAR 0 2
99392: NOT
99393: IFFALSE 99397
// exit ;
99395: GO 99426
// for i in tmp do
99397: LD_ADDR_VAR 0 1
99401: PUSH
99402: LD_VAR 0 2
99406: PUSH
99407: FOR_IN
99408: IFFALSE 99424
// SetBLevel ( i , 10 ) ;
99410: LD_VAR 0 1
99414: PPUSH
99415: LD_INT 10
99417: PPUSH
99418: CALL_OW 241
99422: GO 99407
99424: POP
99425: POP
// end ;
99426: PPOPN 2
99428: END
// every 0 0$1 trigger StreamModeActive and sSold do var i , un , tmp ;
99429: LD_EXP 139
99433: PUSH
99434: LD_EXP 156
99438: AND
99439: IFFALSE 99550
99441: GO 99443
99443: DISABLE
99444: LD_INT 0
99446: PPUSH
99447: PPUSH
99448: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_class , 1 ] ] ) ;
99449: LD_ADDR_VAR 0 3
99453: PUSH
99454: LD_INT 22
99456: PUSH
99457: LD_OWVAR 2
99461: PUSH
99462: EMPTY
99463: LIST
99464: LIST
99465: PUSH
99466: LD_INT 25
99468: PUSH
99469: LD_INT 1
99471: PUSH
99472: EMPTY
99473: LIST
99474: LIST
99475: PUSH
99476: EMPTY
99477: LIST
99478: LIST
99479: PPUSH
99480: CALL_OW 69
99484: ST_TO_ADDR
// if not tmp then
99485: LD_VAR 0 3
99489: NOT
99490: IFFALSE 99494
// exit ;
99492: GO 99550
// un := tmp [ rand ( 1 , tmp ) ] ;
99494: LD_ADDR_VAR 0 2
99498: PUSH
99499: LD_VAR 0 3
99503: PUSH
99504: LD_INT 1
99506: PPUSH
99507: LD_VAR 0 3
99511: PPUSH
99512: CALL_OW 12
99516: ARRAY
99517: ST_TO_ADDR
// if Crawls ( un ) then
99518: LD_VAR 0 2
99522: PPUSH
99523: CALL_OW 318
99527: IFFALSE 99538
// ComWalk ( un ) ;
99529: LD_VAR 0 2
99533: PPUSH
99534: CALL_OW 138
// SetClass ( un , class_sniper ) ;
99538: LD_VAR 0 2
99542: PPUSH
99543: LD_INT 5
99545: PPUSH
99546: CALL_OW 336
// end ;
99550: PPOPN 3
99552: END
// every 0 0$1 trigger StreamModeActive and sDiff and Difficulty < 4 do
99553: LD_EXP 139
99557: PUSH
99558: LD_EXP 157
99562: AND
99563: PUSH
99564: LD_OWVAR 67
99568: PUSH
99569: LD_INT 4
99571: LESS
99572: AND
99573: IFFALSE 99592
99575: GO 99577
99577: DISABLE
// begin Difficulty := Difficulty + 1 ;
99578: LD_ADDR_OWVAR 67
99582: PUSH
99583: LD_OWVAR 67
99587: PUSH
99588: LD_INT 1
99590: PLUS
99591: ST_TO_ADDR
// end ;
99592: END
// every 0 0$1 trigger StreamModeActive and sTiger do var i ;
99593: LD_EXP 139
99597: PUSH
99598: LD_EXP 158
99602: AND
99603: IFFALSE 99706
99605: GO 99607
99607: DISABLE
99608: LD_INT 0
99610: PPUSH
// begin for i := 1 to 5 do
99611: LD_ADDR_VAR 0 1
99615: PUSH
99616: DOUBLE
99617: LD_INT 1
99619: DEC
99620: ST_TO_ADDR
99621: LD_INT 5
99623: PUSH
99624: FOR_TO
99625: IFFALSE 99704
// begin uc_nation := nation_nature ;
99627: LD_ADDR_OWVAR 21
99631: PUSH
99632: LD_INT 0
99634: ST_TO_ADDR
// uc_side := 0 ;
99635: LD_ADDR_OWVAR 20
99639: PUSH
99640: LD_INT 0
99642: ST_TO_ADDR
// hc_attr := [ 12 , 12 ] ;
99643: LD_ADDR_OWVAR 29
99647: PUSH
99648: LD_INT 12
99650: PUSH
99651: LD_INT 12
99653: PUSH
99654: EMPTY
99655: LIST
99656: LIST
99657: ST_TO_ADDR
// hc_agressivity := 20 ;
99658: LD_ADDR_OWVAR 35
99662: PUSH
99663: LD_INT 20
99665: ST_TO_ADDR
// hc_class := class_tiger ;
99666: LD_ADDR_OWVAR 28
99670: PUSH
99671: LD_INT 14
99673: ST_TO_ADDR
// hc_gallery :=  ;
99674: LD_ADDR_OWVAR 33
99678: PUSH
99679: LD_STRING 
99681: ST_TO_ADDR
// hc_name :=  ;
99682: LD_ADDR_OWVAR 26
99686: PUSH
99687: LD_STRING 
99689: ST_TO_ADDR
// PlaceUnitAnyWhere ( CreateHuman , false ) ;
99690: CALL_OW 44
99694: PPUSH
99695: LD_INT 0
99697: PPUSH
99698: CALL_OW 51
// end ;
99702: GO 99624
99704: POP
99705: POP
// end ;
99706: PPOPN 1
99708: END
// every 0 0$1 trigger StreamModeActive and sBomb do
99709: LD_EXP 139
99713: PUSH
99714: LD_EXP 159
99718: AND
99719: IFFALSE 99728
99721: GO 99723
99723: DISABLE
// StreamSibBomb ;
99724: CALL 99729 0 0
99728: END
// export function StreamSibBomb ; var i , x , y ; begin
99729: LD_INT 0
99731: PPUSH
99732: PPUSH
99733: PPUSH
99734: PPUSH
// result := false ;
99735: LD_ADDR_VAR 0 1
99739: PUSH
99740: LD_INT 0
99742: ST_TO_ADDR
// for i := 1 to 16 do
99743: LD_ADDR_VAR 0 2
99747: PUSH
99748: DOUBLE
99749: LD_INT 1
99751: DEC
99752: ST_TO_ADDR
99753: LD_INT 16
99755: PUSH
99756: FOR_TO
99757: IFFALSE 99956
// begin x := [ 10 , 20 , 30 , 40 , 50 , 60 , 70 , 80 , 90 , 100 , 110 , 120 , 130 , 140 , 150 ] [ rand ( 1 , 15 ) ] ;
99759: LD_ADDR_VAR 0 3
99763: PUSH
99764: LD_INT 10
99766: PUSH
99767: LD_INT 20
99769: PUSH
99770: LD_INT 30
99772: PUSH
99773: LD_INT 40
99775: PUSH
99776: LD_INT 50
99778: PUSH
99779: LD_INT 60
99781: PUSH
99782: LD_INT 70
99784: PUSH
99785: LD_INT 80
99787: PUSH
99788: LD_INT 90
99790: PUSH
99791: LD_INT 100
99793: PUSH
99794: LD_INT 110
99796: PUSH
99797: LD_INT 120
99799: PUSH
99800: LD_INT 130
99802: PUSH
99803: LD_INT 140
99805: PUSH
99806: LD_INT 150
99808: PUSH
99809: EMPTY
99810: LIST
99811: LIST
99812: LIST
99813: LIST
99814: LIST
99815: LIST
99816: LIST
99817: LIST
99818: LIST
99819: LIST
99820: LIST
99821: LIST
99822: LIST
99823: LIST
99824: LIST
99825: PUSH
99826: LD_INT 1
99828: PPUSH
99829: LD_INT 15
99831: PPUSH
99832: CALL_OW 12
99836: ARRAY
99837: ST_TO_ADDR
// y := [ 10 , 20 , 30 , 40 , 50 , 60 , 70 , 80 , 90 , 100 , 110 , 120 , 130 , 140 , 150 ] [ rand ( 1 , 15 ) ] ;
99838: LD_ADDR_VAR 0 4
99842: PUSH
99843: LD_INT 10
99845: PUSH
99846: LD_INT 20
99848: PUSH
99849: LD_INT 30
99851: PUSH
99852: LD_INT 40
99854: PUSH
99855: LD_INT 50
99857: PUSH
99858: LD_INT 60
99860: PUSH
99861: LD_INT 70
99863: PUSH
99864: LD_INT 80
99866: PUSH
99867: LD_INT 90
99869: PUSH
99870: LD_INT 100
99872: PUSH
99873: LD_INT 110
99875: PUSH
99876: LD_INT 120
99878: PUSH
99879: LD_INT 130
99881: PUSH
99882: LD_INT 140
99884: PUSH
99885: LD_INT 150
99887: PUSH
99888: EMPTY
99889: LIST
99890: LIST
99891: LIST
99892: LIST
99893: LIST
99894: LIST
99895: LIST
99896: LIST
99897: LIST
99898: LIST
99899: LIST
99900: LIST
99901: LIST
99902: LIST
99903: LIST
99904: PUSH
99905: LD_INT 1
99907: PPUSH
99908: LD_INT 15
99910: PPUSH
99911: CALL_OW 12
99915: ARRAY
99916: ST_TO_ADDR
// if ValidHex ( x , y ) then
99917: LD_VAR 0 3
99921: PPUSH
99922: LD_VAR 0 4
99926: PPUSH
99927: CALL_OW 488
99931: IFFALSE 99954
// begin result := [ x , y ] ;
99933: LD_ADDR_VAR 0 1
99937: PUSH
99938: LD_VAR 0 3
99942: PUSH
99943: LD_VAR 0 4
99947: PUSH
99948: EMPTY
99949: LIST
99950: LIST
99951: ST_TO_ADDR
// break ;
99952: GO 99956
// end ; end ;
99954: GO 99756
99956: POP
99957: POP
// if result then
99958: LD_VAR 0 1
99962: IFFALSE 100022
// begin ToLua ( playSibBomb() ) ;
99964: LD_STRING playSibBomb()
99966: PPUSH
99967: CALL_OW 559
// wait ( 0 0$14 ) ;
99971: LD_INT 490
99973: PPUSH
99974: CALL_OW 67
// CenterNowOnXY ( result [ 1 ] , result [ 2 ] ) ;
99978: LD_VAR 0 1
99982: PUSH
99983: LD_INT 1
99985: ARRAY
99986: PPUSH
99987: LD_VAR 0 1
99991: PUSH
99992: LD_INT 2
99994: ARRAY
99995: PPUSH
99996: CALL_OW 86
// SendSiberiteRocket ( result [ 1 ] , result [ 2 ] ) ;
100000: LD_VAR 0 1
100004: PUSH
100005: LD_INT 1
100007: ARRAY
100008: PPUSH
100009: LD_VAR 0 1
100013: PUSH
100014: LD_INT 2
100016: ARRAY
100017: PPUSH
100018: CALL_OW 429
// end ; end ;
100022: LD_VAR 0 1
100026: RET
// every 0 0$1 trigger StreamModeActive and sReset do
100027: LD_EXP 139
100031: PUSH
100032: LD_EXP 161
100036: AND
100037: IFFALSE 100049
100039: GO 100041
100041: DISABLE
// YouLost (  ) ;
100042: LD_STRING 
100044: PPUSH
100045: CALL_OW 104
100049: END
// every 0 0$1 trigger StreamModeActive and sFog do
100050: LD_EXP 139
100054: PUSH
100055: LD_EXP 160
100059: AND
100060: IFFALSE 100074
100062: GO 100064
100064: DISABLE
// FogOff ( your_side ) ;
100065: LD_OWVAR 2
100069: PPUSH
100070: CALL_OW 344
100074: END
// every 0 0$1 trigger StreamModeActive and sSun do
100075: LD_EXP 139
100079: PUSH
100080: LD_EXP 162
100084: AND
100085: IFFALSE 100113
100087: GO 100089
100089: DISABLE
// begin solar_recharge_percent := 0 ;
100090: LD_ADDR_OWVAR 79
100094: PUSH
100095: LD_INT 0
100097: ST_TO_ADDR
// wait ( 5 5$00 ) ;
100098: LD_INT 10500
100100: PPUSH
100101: CALL_OW 67
// solar_recharge_percent := 100 ;
100105: LD_ADDR_OWVAR 79
100109: PUSH
100110: LD_INT 100
100112: ST_TO_ADDR
// end ;
100113: END
// every 0 0$1 trigger StreamModeActive and sKamikadze do var i , un , tmp ;
100114: LD_EXP 139
100118: PUSH
100119: LD_EXP 163
100123: AND
100124: IFFALSE 100363
100126: GO 100128
100128: DISABLE
100129: LD_INT 0
100131: PPUSH
100132: PPUSH
100133: PPUSH
// begin tmp := [ ] ;
100134: LD_ADDR_VAR 0 3
100138: PUSH
100139: EMPTY
100140: ST_TO_ADDR
// for i := 1 to 6 do
100141: LD_ADDR_VAR 0 1
100145: PUSH
100146: DOUBLE
100147: LD_INT 1
100149: DEC
100150: ST_TO_ADDR
100151: LD_INT 6
100153: PUSH
100154: FOR_TO
100155: IFFALSE 100260
// begin uc_nation := nation_nature ;
100157: LD_ADDR_OWVAR 21
100161: PUSH
100162: LD_INT 0
100164: ST_TO_ADDR
// uc_side := 0 ;
100165: LD_ADDR_OWVAR 20
100169: PUSH
100170: LD_INT 0
100172: ST_TO_ADDR
// hc_attr := [ 12 , 12 ] ;
100173: LD_ADDR_OWVAR 29
100177: PUSH
100178: LD_INT 12
100180: PUSH
100181: LD_INT 12
100183: PUSH
100184: EMPTY
100185: LIST
100186: LIST
100187: ST_TO_ADDR
// hc_agressivity := 20 ;
100188: LD_ADDR_OWVAR 35
100192: PUSH
100193: LD_INT 20
100195: ST_TO_ADDR
// hc_class := class_apeman_kamikaze ;
100196: LD_ADDR_OWVAR 28
100200: PUSH
100201: LD_INT 17
100203: ST_TO_ADDR
// hc_gallery :=  ;
100204: LD_ADDR_OWVAR 33
100208: PUSH
100209: LD_STRING 
100211: ST_TO_ADDR
// hc_name :=  ;
100212: LD_ADDR_OWVAR 26
100216: PUSH
100217: LD_STRING 
100219: ST_TO_ADDR
// un := CreateHuman ;
100220: LD_ADDR_VAR 0 2
100224: PUSH
100225: CALL_OW 44
100229: ST_TO_ADDR
// PlaceUnitAnyWhere ( un , true ) ;
100230: LD_VAR 0 2
100234: PPUSH
100235: LD_INT 1
100237: PPUSH
100238: CALL_OW 51
// tmp := tmp ^ un ;
100242: LD_ADDR_VAR 0 3
100246: PUSH
100247: LD_VAR 0 3
100251: PUSH
100252: LD_VAR 0 2
100256: ADD
100257: ST_TO_ADDR
// end ;
100258: GO 100154
100260: POP
100261: POP
// repeat wait ( 0 0$1 ) ;
100262: LD_INT 35
100264: PPUSH
100265: CALL_OW 67
// for un in tmp do
100269: LD_ADDR_VAR 0 2
100273: PUSH
100274: LD_VAR 0 3
100278: PUSH
100279: FOR_IN
100280: IFFALSE 100354
// begin if IsDead ( un ) then
100282: LD_VAR 0 2
100286: PPUSH
100287: CALL_OW 301
100291: IFFALSE 100311
// begin tmp := tmp diff un ;
100293: LD_ADDR_VAR 0 3
100297: PUSH
100298: LD_VAR 0 3
100302: PUSH
100303: LD_VAR 0 2
100307: DIFF
100308: ST_TO_ADDR
// continue ;
100309: GO 100279
// end ; ComAttackUnit ( un , NearestUnitToUnit ( FilterAllUnits ( [ f_not , [ f_side , 0 ] ] ) , un ) ) ;
100311: LD_VAR 0 2
100315: PPUSH
100316: LD_INT 3
100318: PUSH
100319: LD_INT 22
100321: PUSH
100322: LD_INT 0
100324: PUSH
100325: EMPTY
100326: LIST
100327: LIST
100328: PUSH
100329: EMPTY
100330: LIST
100331: LIST
100332: PPUSH
100333: CALL_OW 69
100337: PPUSH
100338: LD_VAR 0 2
100342: PPUSH
100343: CALL_OW 74
100347: PPUSH
100348: CALL_OW 115
// end ;
100352: GO 100279
100354: POP
100355: POP
// until not tmp ;
100356: LD_VAR 0 3
100360: NOT
100361: IFFALSE 100262
// end ;
100363: PPOPN 3
100365: END
// every 0 0$1 trigger StreamModeActive and sTroll do
100366: LD_EXP 139
100370: PUSH
100371: LD_EXP 164
100375: AND
100376: IFFALSE 100430
100378: GO 100380
100380: DISABLE
// begin ToLua ( displayTroll(); ) ;
100381: LD_STRING displayTroll();
100383: PPUSH
100384: CALL_OW 559
// wait ( 3 3$00 ) ;
100388: LD_INT 6300
100390: PPUSH
100391: CALL_OW 67
// ToLua ( hideTroll(); ) ;
100395: LD_STRING hideTroll();
100397: PPUSH
100398: CALL_OW 559
// wait ( 1 1$00 ) ;
100402: LD_INT 2100
100404: PPUSH
100405: CALL_OW 67
// ToLua ( displayTroll(); ) ;
100409: LD_STRING displayTroll();
100411: PPUSH
100412: CALL_OW 559
// wait ( 1 1$00 ) ;
100416: LD_INT 2100
100418: PPUSH
100419: CALL_OW 67
// ToLua ( hideTroll(); ) ;
100423: LD_STRING hideTroll();
100425: PPUSH
100426: CALL_OW 559
// end ;
100430: END
// every 0 0$1 trigger StreamModeActive and sSlow do var p ;
100431: LD_EXP 139
100435: PUSH
100436: LD_EXP 165
100440: AND
100441: IFFALSE 100504
100443: GO 100445
100445: DISABLE
100446: LD_INT 0
100448: PPUSH
// begin p := 0 ;
100449: LD_ADDR_VAR 0 1
100453: PUSH
100454: LD_INT 0
100456: ST_TO_ADDR
// repeat game_speed := 1 ;
100457: LD_ADDR_OWVAR 65
100461: PUSH
100462: LD_INT 1
100464: ST_TO_ADDR
// wait ( 0 0$1 ) ;
100465: LD_INT 35
100467: PPUSH
100468: CALL_OW 67
// p := p + 1 ;
100472: LD_ADDR_VAR 0 1
100476: PUSH
100477: LD_VAR 0 1
100481: PUSH
100482: LD_INT 1
100484: PLUS
100485: ST_TO_ADDR
// until p >= 60 ;
100486: LD_VAR 0 1
100490: PUSH
100491: LD_INT 60
100493: GREATEREQUAL
100494: IFFALSE 100457
// game_speed := 4 ;
100496: LD_ADDR_OWVAR 65
100500: PUSH
100501: LD_INT 4
100503: ST_TO_ADDR
// end ;
100504: PPOPN 1
100506: END
// every 0 0$1 trigger StreamModeActive and sLack do var depot , base ;
100507: LD_EXP 139
100511: PUSH
100512: LD_EXP 166
100516: AND
100517: IFFALSE 100663
100519: GO 100521
100521: DISABLE
100522: LD_INT 0
100524: PPUSH
100525: PPUSH
// begin depot := FilterAllUnits ( [ [ f_side , your_side ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ] ) ;
100526: LD_ADDR_VAR 0 1
100530: PUSH
100531: LD_INT 22
100533: PUSH
100534: LD_OWVAR 2
100538: PUSH
100539: EMPTY
100540: LIST
100541: LIST
100542: PUSH
100543: LD_INT 2
100545: PUSH
100546: LD_INT 30
100548: PUSH
100549: LD_INT 0
100551: PUSH
100552: EMPTY
100553: LIST
100554: LIST
100555: PUSH
100556: LD_INT 30
100558: PUSH
100559: LD_INT 1
100561: PUSH
100562: EMPTY
100563: LIST
100564: LIST
100565: PUSH
100566: EMPTY
100567: LIST
100568: LIST
100569: LIST
100570: PUSH
100571: EMPTY
100572: LIST
100573: LIST
100574: PPUSH
100575: CALL_OW 69
100579: ST_TO_ADDR
// if not depot then
100580: LD_VAR 0 1
100584: NOT
100585: IFFALSE 100589
// exit ;
100587: GO 100663
// base := GetBase ( depot [ rand ( 1 , depot ) ] ) ;
100589: LD_ADDR_VAR 0 2
100593: PUSH
100594: LD_VAR 0 1
100598: PUSH
100599: LD_INT 1
100601: PPUSH
100602: LD_VAR 0 1
100606: PPUSH
100607: CALL_OW 12
100611: ARRAY
100612: PPUSH
100613: CALL_OW 274
100617: ST_TO_ADDR
// SetResourceType ( base , mat_cans , 0 ) ;
100618: LD_VAR 0 2
100622: PPUSH
100623: LD_INT 1
100625: PPUSH
100626: LD_INT 0
100628: PPUSH
100629: CALL_OW 277
// SetResourceType ( base , mat_oil , 0 ) ;
100633: LD_VAR 0 2
100637: PPUSH
100638: LD_INT 2
100640: PPUSH
100641: LD_INT 0
100643: PPUSH
100644: CALL_OW 277
// SetResourceType ( base , mat_siberit , 0 ) ;
100648: LD_VAR 0 2
100652: PPUSH
100653: LD_INT 3
100655: PPUSH
100656: LD_INT 0
100658: PPUSH
100659: CALL_OW 277
// end ;
100663: PPOPN 2
100665: END
// every 0 0$1 trigger StreamModeActive and sWound do var tmp ;
100666: LD_EXP 139
100670: PUSH
100671: LD_EXP 167
100675: AND
100676: IFFALSE 100773
100678: GO 100680
100680: DISABLE
100681: LD_INT 0
100683: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_type , unit_human ] , [ f_not , [ f_nation , 0 ] ] ] ) ;
100684: LD_ADDR_VAR 0 1
100688: PUSH
100689: LD_INT 22
100691: PUSH
100692: LD_OWVAR 2
100696: PUSH
100697: EMPTY
100698: LIST
100699: LIST
100700: PUSH
100701: LD_INT 21
100703: PUSH
100704: LD_INT 1
100706: PUSH
100707: EMPTY
100708: LIST
100709: LIST
100710: PUSH
100711: LD_INT 3
100713: PUSH
100714: LD_INT 23
100716: PUSH
100717: LD_INT 0
100719: PUSH
100720: EMPTY
100721: LIST
100722: LIST
100723: PUSH
100724: EMPTY
100725: LIST
100726: LIST
100727: PUSH
100728: EMPTY
100729: LIST
100730: LIST
100731: LIST
100732: PPUSH
100733: CALL_OW 69
100737: ST_TO_ADDR
// if not tmp then
100738: LD_VAR 0 1
100742: NOT
100743: IFFALSE 100747
// exit ;
100745: GO 100773
// SetLives ( tmp [ rand ( 1 , tmp ) ] , 200 ) ;
100747: LD_VAR 0 1
100751: PUSH
100752: LD_INT 1
100754: PPUSH
100755: LD_VAR 0 1
100759: PPUSH
100760: CALL_OW 12
100764: ARRAY
100765: PPUSH
100766: LD_INT 200
100768: PPUSH
100769: CALL_OW 234
// end ;
100773: PPOPN 1
100775: END
// every 0 0$1 trigger StreamModeActive and sTank do var tmp ;
100776: LD_EXP 139
100780: PUSH
100781: LD_EXP 168
100785: AND
100786: IFFALSE 100865
100788: GO 100790
100790: DISABLE
100791: LD_INT 0
100793: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_type , unit_vehicle ] ] ) ;
100794: LD_ADDR_VAR 0 1
100798: PUSH
100799: LD_INT 22
100801: PUSH
100802: LD_OWVAR 2
100806: PUSH
100807: EMPTY
100808: LIST
100809: LIST
100810: PUSH
100811: LD_INT 21
100813: PUSH
100814: LD_INT 2
100816: PUSH
100817: EMPTY
100818: LIST
100819: LIST
100820: PUSH
100821: EMPTY
100822: LIST
100823: LIST
100824: PPUSH
100825: CALL_OW 69
100829: ST_TO_ADDR
// if not tmp then
100830: LD_VAR 0 1
100834: NOT
100835: IFFALSE 100839
// exit ;
100837: GO 100865
// SetLives ( tmp [ rand ( 1 , tmp ) ] , 60 ) ;
100839: LD_VAR 0 1
100843: PUSH
100844: LD_INT 1
100846: PPUSH
100847: LD_VAR 0 1
100851: PPUSH
100852: CALL_OW 12
100856: ARRAY
100857: PPUSH
100858: LD_INT 60
100860: PPUSH
100861: CALL_OW 234
// end ;
100865: PPOPN 1
100867: END
// every 0 0$1 trigger StreamModeActive and sRemote do var tmp , i ;
100868: LD_EXP 139
100872: PUSH
100873: LD_EXP 169
100877: AND
100878: IFFALSE 100977
100880: GO 100882
100882: DISABLE
100883: LD_INT 0
100885: PPUSH
100886: PPUSH
// begin enable ;
100887: ENABLE
// tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_linked ] , [ f_control , control_remote ] ] ) ;
100888: LD_ADDR_VAR 0 1
100892: PUSH
100893: LD_INT 22
100895: PUSH
100896: LD_OWVAR 2
100900: PUSH
100901: EMPTY
100902: LIST
100903: LIST
100904: PUSH
100905: LD_INT 61
100907: PUSH
100908: EMPTY
100909: LIST
100910: PUSH
100911: LD_INT 33
100913: PUSH
100914: LD_INT 2
100916: PUSH
100917: EMPTY
100918: LIST
100919: LIST
100920: PUSH
100921: EMPTY
100922: LIST
100923: LIST
100924: LIST
100925: PPUSH
100926: CALL_OW 69
100930: ST_TO_ADDR
// if not tmp then
100931: LD_VAR 0 1
100935: NOT
100936: IFFALSE 100940
// exit ;
100938: GO 100977
// for i in tmp do
100940: LD_ADDR_VAR 0 2
100944: PUSH
100945: LD_VAR 0 1
100949: PUSH
100950: FOR_IN
100951: IFFALSE 100975
// if IsControledBy ( i ) then
100953: LD_VAR 0 2
100957: PPUSH
100958: CALL_OW 312
100962: IFFALSE 100973
// ComUnlink ( i ) ;
100964: LD_VAR 0 2
100968: PPUSH
100969: CALL_OW 136
100973: GO 100950
100975: POP
100976: POP
// end ;
100977: PPOPN 2
100979: END
// every 0 0$1 trigger StreamModeActive and sPowell do var i , un ;
100980: LD_EXP 139
100984: PUSH
100985: LD_EXP 170
100989: AND
100990: IFFALSE 101130
100992: GO 100994
100994: DISABLE
100995: LD_INT 0
100997: PPUSH
100998: PPUSH
// begin ToLua ( displayPowell(); ) ;
100999: LD_STRING displayPowell();
101001: PPUSH
101002: CALL_OW 559
// uc_side := 0 ;
101006: LD_ADDR_OWVAR 20
101010: PUSH
101011: LD_INT 0
101013: ST_TO_ADDR
// uc_nation := 2 ;
101014: LD_ADDR_OWVAR 21
101018: PUSH
101019: LD_INT 2
101021: ST_TO_ADDR
// vc_chassis := ar_half_tracked ;
101022: LD_ADDR_OWVAR 37
101026: PUSH
101027: LD_INT 14
101029: ST_TO_ADDR
// vc_engine := engine_siberite ;
101030: LD_ADDR_OWVAR 39
101034: PUSH
101035: LD_INT 3
101037: ST_TO_ADDR
// vc_control := control_apeman ;
101038: LD_ADDR_OWVAR 38
101042: PUSH
101043: LD_INT 5
101045: ST_TO_ADDR
// vc_weapon := ar_selfpropelled_bomb ;
101046: LD_ADDR_OWVAR 40
101050: PUSH
101051: LD_INT 29
101053: ST_TO_ADDR
// un := CreateVehicle ;
101054: LD_ADDR_VAR 0 2
101058: PUSH
101059: CALL_OW 45
101063: ST_TO_ADDR
// PlaceUnitAnywhere ( un , true ) ;
101064: LD_VAR 0 2
101068: PPUSH
101069: LD_INT 1
101071: PPUSH
101072: CALL_OW 51
// repeat wait ( 0 0$1 ) ;
101076: LD_INT 35
101078: PPUSH
101079: CALL_OW 67
// ComAttackUnit ( un , NearestUnitToUnit ( FilterAllUnits ( [ f_side , your_side ] ) , un ) ) ;
101083: LD_VAR 0 2
101087: PPUSH
101088: LD_INT 22
101090: PUSH
101091: LD_OWVAR 2
101095: PUSH
101096: EMPTY
101097: LIST
101098: LIST
101099: PPUSH
101100: CALL_OW 69
101104: PPUSH
101105: LD_VAR 0 2
101109: PPUSH
101110: CALL_OW 74
101114: PPUSH
101115: CALL_OW 115
// until IsDead ( un ) ;
101119: LD_VAR 0 2
101123: PPUSH
101124: CALL_OW 301
101128: IFFALSE 101076
// end ;
101130: PPOPN 2
101132: END
// every 0 0$1 trigger StreamModeActive and sStu do
101133: LD_EXP 139
101137: PUSH
101138: LD_EXP 178
101142: AND
101143: IFFALSE 101159
101145: GO 101147
101147: DISABLE
// begin ToLua ( displayStucuk(); ) ;
101148: LD_STRING displayStucuk();
101150: PPUSH
101151: CALL_OW 559
// ResetFog ;
101155: CALL_OW 335
// end ;
101159: END
// every 0 0$1 trigger StreamModeActive and sBetray do var un , tmp ;
101160: LD_EXP 139
101164: PUSH
101165: LD_EXP 171
101169: AND
101170: IFFALSE 101311
101172: GO 101174
101174: DISABLE
101175: LD_INT 0
101177: PPUSH
101178: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_type , unit_human ] ] ) ;
101179: LD_ADDR_VAR 0 2
101183: PUSH
101184: LD_INT 22
101186: PUSH
101187: LD_OWVAR 2
101191: PUSH
101192: EMPTY
101193: LIST
101194: LIST
101195: PUSH
101196: LD_INT 21
101198: PUSH
101199: LD_INT 1
101201: PUSH
101202: EMPTY
101203: LIST
101204: LIST
101205: PUSH
101206: EMPTY
101207: LIST
101208: LIST
101209: PPUSH
101210: CALL_OW 69
101214: ST_TO_ADDR
// if not tmp then
101215: LD_VAR 0 2
101219: NOT
101220: IFFALSE 101224
// exit ;
101222: GO 101311
// un := tmp [ rand ( 1 , tmp ) ] ;
101224: LD_ADDR_VAR 0 1
101228: PUSH
101229: LD_VAR 0 2
101233: PUSH
101234: LD_INT 1
101236: PPUSH
101237: LD_VAR 0 2
101241: PPUSH
101242: CALL_OW 12
101246: ARRAY
101247: ST_TO_ADDR
// SetSide ( un , 0 ) ;
101248: LD_VAR 0 1
101252: PPUSH
101253: LD_INT 0
101255: PPUSH
101256: CALL_OW 235
// ComAttackUnit ( un , NearestUnitToUnit ( all_units diff un , un ) ) ;
101260: LD_VAR 0 1
101264: PPUSH
101265: LD_OWVAR 3
101269: PUSH
101270: LD_VAR 0 1
101274: DIFF
101275: PPUSH
101276: LD_VAR 0 1
101280: PPUSH
101281: CALL_OW 74
101285: PPUSH
101286: CALL_OW 115
// wait ( 0 0$20 ) ;
101290: LD_INT 700
101292: PPUSH
101293: CALL_OW 67
// SetSide ( un , your_side ) ;
101297: LD_VAR 0 1
101301: PPUSH
101302: LD_OWVAR 2
101306: PPUSH
101307: CALL_OW 235
// end ;
101311: PPOPN 2
101313: END
// every 0 0$1 trigger StreamModeActive and sContamin do var depot ;
101314: LD_EXP 139
101318: PUSH
101319: LD_EXP 172
101323: AND
101324: IFFALSE 101430
101326: GO 101328
101328: DISABLE
101329: LD_INT 0
101331: PPUSH
// begin depot := FilterAllUnits ( [ [ f_side , your_side ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ] ) ;
101332: LD_ADDR_VAR 0 1
101336: PUSH
101337: LD_INT 22
101339: PUSH
101340: LD_OWVAR 2
101344: PUSH
101345: EMPTY
101346: LIST
101347: LIST
101348: PUSH
101349: LD_INT 2
101351: PUSH
101352: LD_INT 30
101354: PUSH
101355: LD_INT 0
101357: PUSH
101358: EMPTY
101359: LIST
101360: LIST
101361: PUSH
101362: LD_INT 30
101364: PUSH
101365: LD_INT 1
101367: PUSH
101368: EMPTY
101369: LIST
101370: LIST
101371: PUSH
101372: EMPTY
101373: LIST
101374: LIST
101375: LIST
101376: PUSH
101377: EMPTY
101378: LIST
101379: LIST
101380: PPUSH
101381: CALL_OW 69
101385: ST_TO_ADDR
// if not depot then
101386: LD_VAR 0 1
101390: NOT
101391: IFFALSE 101395
// exit ;
101393: GO 101430
// ArtContamination ( GetX ( depot [ 1 ] ) , GetY ( depot [ 1 ] ) , 70 ) ;
101395: LD_VAR 0 1
101399: PUSH
101400: LD_INT 1
101402: ARRAY
101403: PPUSH
101404: CALL_OW 250
101408: PPUSH
101409: LD_VAR 0 1
101413: PUSH
101414: LD_INT 1
101416: ARRAY
101417: PPUSH
101418: CALL_OW 251
101422: PPUSH
101423: LD_INT 70
101425: PPUSH
101426: CALL_OW 495
// end ;
101430: PPOPN 1
101432: END
// every 0 0$1 trigger StreamModeActive and sTeleport do var i , x , y , d , tmp ;
101433: LD_EXP 139
101437: PUSH
101438: LD_EXP 173
101442: AND
101443: IFFALSE 101654
101445: GO 101447
101447: DISABLE
101448: LD_INT 0
101450: PPUSH
101451: PPUSH
101452: PPUSH
101453: PPUSH
101454: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_type , unit_human ] ] ) ;
101455: LD_ADDR_VAR 0 5
101459: PUSH
101460: LD_INT 22
101462: PUSH
101463: LD_OWVAR 2
101467: PUSH
101468: EMPTY
101469: LIST
101470: LIST
101471: PUSH
101472: LD_INT 21
101474: PUSH
101475: LD_INT 1
101477: PUSH
101478: EMPTY
101479: LIST
101480: LIST
101481: PUSH
101482: EMPTY
101483: LIST
101484: LIST
101485: PPUSH
101486: CALL_OW 69
101490: ST_TO_ADDR
// if not tmp then
101491: LD_VAR 0 5
101495: NOT
101496: IFFALSE 101500
// exit ;
101498: GO 101654
// for i in tmp do
101500: LD_ADDR_VAR 0 1
101504: PUSH
101505: LD_VAR 0 5
101509: PUSH
101510: FOR_IN
101511: IFFALSE 101652
// begin d := rand ( 0 , 5 ) ;
101513: LD_ADDR_VAR 0 4
101517: PUSH
101518: LD_INT 0
101520: PPUSH
101521: LD_INT 5
101523: PPUSH
101524: CALL_OW 12
101528: ST_TO_ADDR
// x := ShiftX ( GetX ( i ) , d , rand ( 3 , 12 ) ) ;
101529: LD_ADDR_VAR 0 2
101533: PUSH
101534: LD_VAR 0 1
101538: PPUSH
101539: CALL_OW 250
101543: PPUSH
101544: LD_VAR 0 4
101548: PPUSH
101549: LD_INT 3
101551: PPUSH
101552: LD_INT 12
101554: PPUSH
101555: CALL_OW 12
101559: PPUSH
101560: CALL_OW 272
101564: ST_TO_ADDR
// y := ShiftY ( GetY ( i ) , d , rand ( 3 , 12 ) ) ;
101565: LD_ADDR_VAR 0 3
101569: PUSH
101570: LD_VAR 0 1
101574: PPUSH
101575: CALL_OW 251
101579: PPUSH
101580: LD_VAR 0 4
101584: PPUSH
101585: LD_INT 3
101587: PPUSH
101588: LD_INT 12
101590: PPUSH
101591: CALL_OW 12
101595: PPUSH
101596: CALL_OW 273
101600: ST_TO_ADDR
// if ValidHex ( x , y ) then
101601: LD_VAR 0 2
101605: PPUSH
101606: LD_VAR 0 3
101610: PPUSH
101611: CALL_OW 488
101615: IFFALSE 101650
// TeleportUnit ( i , x , y , rand ( 3 , 6 ) , true ) ;
101617: LD_VAR 0 1
101621: PPUSH
101622: LD_VAR 0 2
101626: PPUSH
101627: LD_VAR 0 3
101631: PPUSH
101632: LD_INT 3
101634: PPUSH
101635: LD_INT 6
101637: PPUSH
101638: CALL_OW 12
101642: PPUSH
101643: LD_INT 1
101645: PPUSH
101646: CALL_OW 483
// end ;
101650: GO 101510
101652: POP
101653: POP
// end ;
101654: PPOPN 5
101656: END
// every 0 0$1 trigger StreamModeActive and sOil do var i , tmp ;
101657: LD_EXP 139
101661: PUSH
101662: LD_EXP 174
101666: AND
101667: IFFALSE 101761
101669: GO 101671
101671: DISABLE
101672: LD_INT 0
101674: PPUSH
101675: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_engine , engine_combustion ] , [ f_type , unit_vehicle ] ] ) ;
101676: LD_ADDR_VAR 0 2
101680: PUSH
101681: LD_INT 22
101683: PUSH
101684: LD_OWVAR 2
101688: PUSH
101689: EMPTY
101690: LIST
101691: LIST
101692: PUSH
101693: LD_INT 32
101695: PUSH
101696: LD_INT 1
101698: PUSH
101699: EMPTY
101700: LIST
101701: LIST
101702: PUSH
101703: LD_INT 21
101705: PUSH
101706: LD_INT 2
101708: PUSH
101709: EMPTY
101710: LIST
101711: LIST
101712: PUSH
101713: EMPTY
101714: LIST
101715: LIST
101716: LIST
101717: PPUSH
101718: CALL_OW 69
101722: ST_TO_ADDR
// if not tmp then
101723: LD_VAR 0 2
101727: NOT
101728: IFFALSE 101732
// exit ;
101730: GO 101761
// for i in tmp do
101732: LD_ADDR_VAR 0 1
101736: PUSH
101737: LD_VAR 0 2
101741: PUSH
101742: FOR_IN
101743: IFFALSE 101759
// SetFuel ( i , 0 ) ;
101745: LD_VAR 0 1
101749: PPUSH
101750: LD_INT 0
101752: PPUSH
101753: CALL_OW 240
101757: GO 101742
101759: POP
101760: POP
// end ;
101761: PPOPN 2
101763: END
// every 0 0$1 trigger StreamModeActive and sOilTower do var tmp ;
101764: LD_EXP 139
101768: PUSH
101769: LD_EXP 175
101773: AND
101774: IFFALSE 101840
101776: GO 101778
101778: DISABLE
101779: LD_INT 0
101781: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_btype , b_oil_mine ] ] ) ;
101782: LD_ADDR_VAR 0 1
101786: PUSH
101787: LD_INT 22
101789: PUSH
101790: LD_OWVAR 2
101794: PUSH
101795: EMPTY
101796: LIST
101797: LIST
101798: PUSH
101799: LD_INT 30
101801: PUSH
101802: LD_INT 29
101804: PUSH
101805: EMPTY
101806: LIST
101807: LIST
101808: PUSH
101809: EMPTY
101810: LIST
101811: LIST
101812: PPUSH
101813: CALL_OW 69
101817: ST_TO_ADDR
// if not tmp then
101818: LD_VAR 0 1
101822: NOT
101823: IFFALSE 101827
// exit ;
101825: GO 101840
// DestroyUnit ( tmp [ 1 ] ) ;
101827: LD_VAR 0 1
101831: PUSH
101832: LD_INT 1
101834: ARRAY
101835: PPUSH
101836: CALL_OW 65
// end ;
101840: PPOPN 1
101842: END
// every 0 0$1 trigger StreamModeActive and sSheik do var un ;
101843: LD_EXP 139
101847: PUSH
101848: LD_EXP 177
101852: AND
101853: IFFALSE 101982
101855: GO 101857
101857: DISABLE
101858: LD_INT 0
101860: PPUSH
// begin uc_side := 0 ;
101861: LD_ADDR_OWVAR 20
101865: PUSH
101866: LD_INT 0
101868: ST_TO_ADDR
// uc_nation := nation_arabian ;
101869: LD_ADDR_OWVAR 21
101873: PUSH
101874: LD_INT 2
101876: ST_TO_ADDR
// hc_gallery :=  ;
101877: LD_ADDR_OWVAR 33
101881: PUSH
101882: LD_STRING 
101884: ST_TO_ADDR
// hc_name :=  ;
101885: LD_ADDR_OWVAR 26
101889: PUSH
101890: LD_STRING 
101892: ST_TO_ADDR
// PrepareHuman ( sex_male , class_desert_warior , 10 ) ;
101893: LD_INT 1
101895: PPUSH
101896: LD_INT 11
101898: PPUSH
101899: LD_INT 10
101901: PPUSH
101902: CALL_OW 380
// un := CreateHuman ;
101906: LD_ADDR_VAR 0 1
101910: PUSH
101911: CALL_OW 44
101915: ST_TO_ADDR
// PlaceUnitAnywhere ( un , true ) ;
101916: LD_VAR 0 1
101920: PPUSH
101921: LD_INT 1
101923: PPUSH
101924: CALL_OW 51
// repeat wait ( 0 0$1 ) ;
101928: LD_INT 35
101930: PPUSH
101931: CALL_OW 67
// ComAttackUnit ( un , NearestUnitToUnit ( FilterAllUnits ( [ f_side , your_side ] ) , un ) ) ;
101935: LD_VAR 0 1
101939: PPUSH
101940: LD_INT 22
101942: PUSH
101943: LD_OWVAR 2
101947: PUSH
101948: EMPTY
101949: LIST
101950: LIST
101951: PPUSH
101952: CALL_OW 69
101956: PPUSH
101957: LD_VAR 0 1
101961: PPUSH
101962: CALL_OW 74
101966: PPUSH
101967: CALL_OW 115
// until IsDead ( un ) ;
101971: LD_VAR 0 1
101975: PPUSH
101976: CALL_OW 301
101980: IFFALSE 101928
// end ;
101982: PPOPN 1
101984: END
// every 0 0$1 trigger StreamModeActive and sEarthquake do
101985: LD_EXP 139
101989: PUSH
101990: LD_EXP 179
101994: AND
101995: IFFALSE 102007
101997: GO 101999
101999: DISABLE
// ToLua ( earthquake(getX(game), 0, 32) ) ;
102000: LD_STRING earthquake(getX(game), 0, 32)
102002: PPUSH
102003: CALL_OW 559
102007: END
// every 0 0$1 trigger StreamModeActive and sAI do var tmp ;
102008: LD_EXP 139
102012: PUSH
102013: LD_EXP 180
102017: AND
102018: IFFALSE 102109
102020: GO 102022
102022: DISABLE
102023: LD_INT 0
102025: PPUSH
// begin enable ;
102026: ENABLE
// tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_type , unit_vehicle ] , [ f_control , control_computer ] ] ) ;
102027: LD_ADDR_VAR 0 1
102031: PUSH
102032: LD_INT 22
102034: PUSH
102035: LD_OWVAR 2
102039: PUSH
102040: EMPTY
102041: LIST
102042: LIST
102043: PUSH
102044: LD_INT 21
102046: PUSH
102047: LD_INT 2
102049: PUSH
102050: EMPTY
102051: LIST
102052: LIST
102053: PUSH
102054: LD_INT 33
102056: PUSH
102057: LD_INT 3
102059: PUSH
102060: EMPTY
102061: LIST
102062: LIST
102063: PUSH
102064: EMPTY
102065: LIST
102066: LIST
102067: LIST
102068: PPUSH
102069: CALL_OW 69
102073: ST_TO_ADDR
// if not tmp then
102074: LD_VAR 0 1
102078: NOT
102079: IFFALSE 102083
// exit ;
102081: GO 102109
// SetLives ( tmp [ rand ( 1 , tmp ) ] , 1 ) ;
102083: LD_VAR 0 1
102087: PUSH
102088: LD_INT 1
102090: PPUSH
102091: LD_VAR 0 1
102095: PPUSH
102096: CALL_OW 12
102100: ARRAY
102101: PPUSH
102102: LD_INT 1
102104: PPUSH
102105: CALL_OW 234
// end ;
102109: PPOPN 1
102111: END
// every 0 0$1 trigger StreamModeActive and sBazooka do var i , un , tmp ;
102112: LD_EXP 139
102116: PUSH
102117: LD_EXP 181
102121: AND
102122: IFFALSE 102263
102124: GO 102126
102126: DISABLE
102127: LD_INT 0
102129: PPUSH
102130: PPUSH
102131: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_class , 1 ] ] ) ;
102132: LD_ADDR_VAR 0 3
102136: PUSH
102137: LD_INT 22
102139: PUSH
102140: LD_OWVAR 2
102144: PUSH
102145: EMPTY
102146: LIST
102147: LIST
102148: PUSH
102149: LD_INT 25
102151: PUSH
102152: LD_INT 1
102154: PUSH
102155: EMPTY
102156: LIST
102157: LIST
102158: PUSH
102159: EMPTY
102160: LIST
102161: LIST
102162: PPUSH
102163: CALL_OW 69
102167: ST_TO_ADDR
// if not tmp then
102168: LD_VAR 0 3
102172: NOT
102173: IFFALSE 102177
// exit ;
102175: GO 102263
// un := tmp [ rand ( 1 , tmp ) ] ;
102177: LD_ADDR_VAR 0 2
102181: PUSH
102182: LD_VAR 0 3
102186: PUSH
102187: LD_INT 1
102189: PPUSH
102190: LD_VAR 0 3
102194: PPUSH
102195: CALL_OW 12
102199: ARRAY
102200: ST_TO_ADDR
// if Crawls ( un ) then
102201: LD_VAR 0 2
102205: PPUSH
102206: CALL_OW 318
102210: IFFALSE 102221
// ComWalk ( un ) ;
102212: LD_VAR 0 2
102216: PPUSH
102217: CALL_OW 138
// SetClass ( un , class_bazooker ) ;
102221: LD_VAR 0 2
102225: PPUSH
102226: LD_INT 9
102228: PPUSH
102229: CALL_OW 336
// SetTech ( tech_tauRad , your_side , state_researched ) ;
102233: LD_INT 28
102235: PPUSH
102236: LD_OWVAR 2
102240: PPUSH
102241: LD_INT 2
102243: PPUSH
102244: CALL_OW 322
// SetTech ( tech_spacAnom , your_side , state_researched ) ;
102248: LD_INT 29
102250: PPUSH
102251: LD_OWVAR 2
102255: PPUSH
102256: LD_INT 2
102258: PPUSH
102259: CALL_OW 322
// end ;
102263: PPOPN 3
102265: END
// every 0 0$1 trigger StreamModeActive and sMortar do var i , un , tmp ;
102266: LD_EXP 139
102270: PUSH
102271: LD_EXP 182
102275: AND
102276: IFFALSE 102387
102278: GO 102280
102280: DISABLE
102281: LD_INT 0
102283: PPUSH
102284: PPUSH
102285: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_class , 1 ] ] ) ;
102286: LD_ADDR_VAR 0 3
102290: PUSH
102291: LD_INT 22
102293: PUSH
102294: LD_OWVAR 2
102298: PUSH
102299: EMPTY
102300: LIST
102301: LIST
102302: PUSH
102303: LD_INT 25
102305: PUSH
102306: LD_INT 1
102308: PUSH
102309: EMPTY
102310: LIST
102311: LIST
102312: PUSH
102313: EMPTY
102314: LIST
102315: LIST
102316: PPUSH
102317: CALL_OW 69
102321: ST_TO_ADDR
// if not tmp then
102322: LD_VAR 0 3
102326: NOT
102327: IFFALSE 102331
// exit ;
102329: GO 102387
// un := tmp [ rand ( 1 , tmp ) ] ;
102331: LD_ADDR_VAR 0 2
102335: PUSH
102336: LD_VAR 0 3
102340: PUSH
102341: LD_INT 1
102343: PPUSH
102344: LD_VAR 0 3
102348: PPUSH
102349: CALL_OW 12
102353: ARRAY
102354: ST_TO_ADDR
// if Crawls ( un ) then
102355: LD_VAR 0 2
102359: PPUSH
102360: CALL_OW 318
102364: IFFALSE 102375
// ComWalk ( un ) ;
102366: LD_VAR 0 2
102370: PPUSH
102371: CALL_OW 138
// SetClass ( un , class_mortar ) ;
102375: LD_VAR 0 2
102379: PPUSH
102380: LD_INT 8
102382: PPUSH
102383: CALL_OW 336
// end ;
102387: PPOPN 3
102389: END
// every 0 0$1 trigger StreamModeActive and sCargo do var i , tmp ;
102390: LD_EXP 139
102394: PUSH
102395: LD_EXP 183
102399: AND
102400: IFFALSE 102544
102402: GO 102404
102404: DISABLE
102405: LD_INT 0
102407: PPUSH
102408: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_type , unit_vehicle ] , [ f_or , [ f_weapon , us_cargo_bay ] , [ f_weapon , ru_cargo_bay ] , [ f_weapon , ar_cargo_bay ] ] ] ) ;
102409: LD_ADDR_VAR 0 2
102413: PUSH
102414: LD_INT 22
102416: PUSH
102417: LD_OWVAR 2
102421: PUSH
102422: EMPTY
102423: LIST
102424: LIST
102425: PUSH
102426: LD_INT 21
102428: PUSH
102429: LD_INT 2
102431: PUSH
102432: EMPTY
102433: LIST
102434: LIST
102435: PUSH
102436: LD_INT 2
102438: PUSH
102439: LD_INT 34
102441: PUSH
102442: LD_INT 12
102444: PUSH
102445: EMPTY
102446: LIST
102447: LIST
102448: PUSH
102449: LD_INT 34
102451: PUSH
102452: LD_INT 51
102454: PUSH
102455: EMPTY
102456: LIST
102457: LIST
102458: PUSH
102459: LD_INT 34
102461: PUSH
102462: LD_INT 32
102464: PUSH
102465: EMPTY
102466: LIST
102467: LIST
102468: PUSH
102469: EMPTY
102470: LIST
102471: LIST
102472: LIST
102473: LIST
102474: PUSH
102475: EMPTY
102476: LIST
102477: LIST
102478: LIST
102479: PPUSH
102480: CALL_OW 69
102484: ST_TO_ADDR
// if not tmp then
102485: LD_VAR 0 2
102489: NOT
102490: IFFALSE 102494
// exit ;
102492: GO 102544
// for i in tmp do
102494: LD_ADDR_VAR 0 1
102498: PUSH
102499: LD_VAR 0 2
102503: PUSH
102504: FOR_IN
102505: IFFALSE 102542
// if GetCargo ( i , mat_artifact ) = 0 then
102507: LD_VAR 0 1
102511: PPUSH
102512: LD_INT 4
102514: PPUSH
102515: CALL_OW 289
102519: PUSH
102520: LD_INT 0
102522: EQUAL
102523: IFFALSE 102540
// SetCargo ( i , mat_siberit , 100 ) ;
102525: LD_VAR 0 1
102529: PPUSH
102530: LD_INT 3
102532: PPUSH
102533: LD_INT 100
102535: PPUSH
102536: CALL_OW 290
102540: GO 102504
102542: POP
102543: POP
// end ;
102544: PPOPN 2
102546: END
// every 0 0$1 trigger StreamModeActive and sDLaser do var i , tmp ;
102547: LD_EXP 139
102551: PUSH
102552: LD_EXP 184
102556: AND
102557: IFFALSE 102740
102559: GO 102561
102561: DISABLE
102562: LD_INT 0
102564: PPUSH
102565: PPUSH
// begin tmp := FilterAllUnits ( [ f_side , your_side ] ) ;
102566: LD_ADDR_VAR 0 2
102570: PUSH
102571: LD_INT 22
102573: PUSH
102574: LD_OWVAR 2
102578: PUSH
102579: EMPTY
102580: LIST
102581: LIST
102582: PPUSH
102583: CALL_OW 69
102587: ST_TO_ADDR
// if not tmp then
102588: LD_VAR 0 2
102592: NOT
102593: IFFALSE 102597
// exit ;
102595: GO 102740
// for i := 1 to 2 do
102597: LD_ADDR_VAR 0 1
102601: PUSH
102602: DOUBLE
102603: LD_INT 1
102605: DEC
102606: ST_TO_ADDR
102607: LD_INT 2
102609: PUSH
102610: FOR_TO
102611: IFFALSE 102738
// begin uc_side := your_side ;
102613: LD_ADDR_OWVAR 20
102617: PUSH
102618: LD_OWVAR 2
102622: ST_TO_ADDR
// uc_nation := nation_american ;
102623: LD_ADDR_OWVAR 21
102627: PUSH
102628: LD_INT 1
102630: ST_TO_ADDR
// vc_chassis := us_morphling ;
102631: LD_ADDR_OWVAR 37
102635: PUSH
102636: LD_INT 5
102638: ST_TO_ADDR
// vc_engine := engine_siberite ;
102639: LD_ADDR_OWVAR 39
102643: PUSH
102644: LD_INT 3
102646: ST_TO_ADDR
// vc_control := control_computer ;
102647: LD_ADDR_OWVAR 38
102651: PUSH
102652: LD_INT 3
102654: ST_TO_ADDR
// vc_weapon := us_double_laser ;
102655: LD_ADDR_OWVAR 40
102659: PUSH
102660: LD_INT 10
102662: ST_TO_ADDR
// if not IsInUnit ( tmp [ 1 ] ) then
102663: LD_VAR 0 2
102667: PUSH
102668: LD_INT 1
102670: ARRAY
102671: PPUSH
102672: CALL_OW 310
102676: NOT
102677: IFFALSE 102724
// PlaceUnitXYR ( CreateVehicle , GetX ( tmp [ 1 ] ) , GetY ( tmp [ 1 ] ) , 12 , true ) else
102679: CALL_OW 45
102683: PPUSH
102684: LD_VAR 0 2
102688: PUSH
102689: LD_INT 1
102691: ARRAY
102692: PPUSH
102693: CALL_OW 250
102697: PPUSH
102698: LD_VAR 0 2
102702: PUSH
102703: LD_INT 1
102705: ARRAY
102706: PPUSH
102707: CALL_OW 251
102711: PPUSH
102712: LD_INT 12
102714: PPUSH
102715: LD_INT 1
102717: PPUSH
102718: CALL_OW 50
102722: GO 102736
// PlaceUnitAnywhere ( CreateVehicle , true ) ;
102724: CALL_OW 45
102728: PPUSH
102729: LD_INT 1
102731: PPUSH
102732: CALL_OW 51
// end ;
102736: GO 102610
102738: POP
102739: POP
// end ;
102740: PPOPN 2
102742: END
// every 0 0$1 trigger StreamModeActive and sExchange do var i , s1 , s2 , sk1 , sk2 , tmp ;
102743: LD_EXP 139
102747: PUSH
102748: LD_EXP 185
102752: AND
102753: IFFALSE 102975
102755: GO 102757
102757: DISABLE
102758: LD_INT 0
102760: PPUSH
102761: PPUSH
102762: PPUSH
102763: PPUSH
102764: PPUSH
102765: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_type , unit_human ] , [ f_not , [ f_nation , 0 ] ] ] ) ;
102766: LD_ADDR_VAR 0 6
102770: PUSH
102771: LD_INT 22
102773: PUSH
102774: LD_OWVAR 2
102778: PUSH
102779: EMPTY
102780: LIST
102781: LIST
102782: PUSH
102783: LD_INT 21
102785: PUSH
102786: LD_INT 1
102788: PUSH
102789: EMPTY
102790: LIST
102791: LIST
102792: PUSH
102793: LD_INT 3
102795: PUSH
102796: LD_INT 23
102798: PUSH
102799: LD_INT 0
102801: PUSH
102802: EMPTY
102803: LIST
102804: LIST
102805: PUSH
102806: EMPTY
102807: LIST
102808: LIST
102809: PUSH
102810: EMPTY
102811: LIST
102812: LIST
102813: LIST
102814: PPUSH
102815: CALL_OW 69
102819: ST_TO_ADDR
// if not tmp then
102820: LD_VAR 0 6
102824: NOT
102825: IFFALSE 102829
// exit ;
102827: GO 102975
// s1 := rand ( 1 , 4 ) ;
102829: LD_ADDR_VAR 0 2
102833: PUSH
102834: LD_INT 1
102836: PPUSH
102837: LD_INT 4
102839: PPUSH
102840: CALL_OW 12
102844: ST_TO_ADDR
// sk1 := GetSkill ( tmp [ 1 ] , s1 ) ;
102845: LD_ADDR_VAR 0 4
102849: PUSH
102850: LD_VAR 0 6
102854: PUSH
102855: LD_INT 1
102857: ARRAY
102858: PPUSH
102859: LD_VAR 0 2
102863: PPUSH
102864: CALL_OW 259
102868: ST_TO_ADDR
// if s1 = 1 then
102869: LD_VAR 0 2
102873: PUSH
102874: LD_INT 1
102876: EQUAL
102877: IFFALSE 102897
// s2 := rand ( 2 , 4 ) else
102879: LD_ADDR_VAR 0 3
102883: PUSH
102884: LD_INT 2
102886: PPUSH
102887: LD_INT 4
102889: PPUSH
102890: CALL_OW 12
102894: ST_TO_ADDR
102895: GO 102905
// s2 := 1 ;
102897: LD_ADDR_VAR 0 3
102901: PUSH
102902: LD_INT 1
102904: ST_TO_ADDR
// sk2 := GetSkill ( tmp [ 1 ] , s2 ) ;
102905: LD_ADDR_VAR 0 5
102909: PUSH
102910: LD_VAR 0 6
102914: PUSH
102915: LD_INT 1
102917: ARRAY
102918: PPUSH
102919: LD_VAR 0 3
102923: PPUSH
102924: CALL_OW 259
102928: ST_TO_ADDR
// SetSkill ( tmp [ 1 ] , s1 , sk2 ) ;
102929: LD_VAR 0 6
102933: PUSH
102934: LD_INT 1
102936: ARRAY
102937: PPUSH
102938: LD_VAR 0 2
102942: PPUSH
102943: LD_VAR 0 5
102947: PPUSH
102948: CALL_OW 237
// SetSkill ( tmp [ 1 ] , s2 , sk1 ) ;
102952: LD_VAR 0 6
102956: PUSH
102957: LD_INT 1
102959: ARRAY
102960: PPUSH
102961: LD_VAR 0 3
102965: PPUSH
102966: LD_VAR 0 4
102970: PPUSH
102971: CALL_OW 237
// end ;
102975: PPOPN 6
102977: END
// every 0 0$1 trigger StreamModeActive and sFac do var tmp ;
102978: LD_EXP 139
102982: PUSH
102983: LD_EXP 186
102987: AND
102988: IFFALSE 103067
102990: GO 102992
102992: DISABLE
102993: LD_INT 0
102995: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_btype , b_factory ] ] ) ;
102996: LD_ADDR_VAR 0 1
103000: PUSH
103001: LD_INT 22
103003: PUSH
103004: LD_OWVAR 2
103008: PUSH
103009: EMPTY
103010: LIST
103011: LIST
103012: PUSH
103013: LD_INT 30
103015: PUSH
103016: LD_INT 3
103018: PUSH
103019: EMPTY
103020: LIST
103021: LIST
103022: PUSH
103023: EMPTY
103024: LIST
103025: LIST
103026: PPUSH
103027: CALL_OW 69
103031: ST_TO_ADDR
// if not tmp then
103032: LD_VAR 0 1
103036: NOT
103037: IFFALSE 103041
// exit ;
103039: GO 103067
// SetLives ( tmp [ rand ( 1 , tmp ) ] , 1 ) ;
103041: LD_VAR 0 1
103045: PUSH
103046: LD_INT 1
103048: PPUSH
103049: LD_VAR 0 1
103053: PPUSH
103054: CALL_OW 12
103058: ARRAY
103059: PPUSH
103060: LD_INT 1
103062: PPUSH
103063: CALL_OW 234
// end ;
103067: PPOPN 1
103069: END
// every 0 0$1 trigger StreamModeActive and sPower do var i , tmp ;
103070: LD_EXP 139
103074: PUSH
103075: LD_EXP 187
103079: AND
103080: IFFALSE 103192
103082: GO 103084
103084: DISABLE
103085: LD_INT 0
103087: PPUSH
103088: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_or , [ f_btype , b_solar_power ] , [ f_btype , b_oil_power ] , [ f_btype , b_siberite_power ] ] ] ) ;
103089: LD_ADDR_VAR 0 2
103093: PUSH
103094: LD_INT 22
103096: PUSH
103097: LD_OWVAR 2
103101: PUSH
103102: EMPTY
103103: LIST
103104: LIST
103105: PUSH
103106: LD_INT 2
103108: PUSH
103109: LD_INT 30
103111: PUSH
103112: LD_INT 27
103114: PUSH
103115: EMPTY
103116: LIST
103117: LIST
103118: PUSH
103119: LD_INT 30
103121: PUSH
103122: LD_INT 26
103124: PUSH
103125: EMPTY
103126: LIST
103127: LIST
103128: PUSH
103129: LD_INT 30
103131: PUSH
103132: LD_INT 28
103134: PUSH
103135: EMPTY
103136: LIST
103137: LIST
103138: PUSH
103139: EMPTY
103140: LIST
103141: LIST
103142: LIST
103143: LIST
103144: PUSH
103145: EMPTY
103146: LIST
103147: LIST
103148: PPUSH
103149: CALL_OW 69
103153: ST_TO_ADDR
// if not tmp then
103154: LD_VAR 0 2
103158: NOT
103159: IFFALSE 103163
// exit ;
103161: GO 103192
// for i in tmp do
103163: LD_ADDR_VAR 0 1
103167: PUSH
103168: LD_VAR 0 2
103172: PUSH
103173: FOR_IN
103174: IFFALSE 103190
// SetLives ( i , 1 ) ;
103176: LD_VAR 0 1
103180: PPUSH
103181: LD_INT 1
103183: PPUSH
103184: CALL_OW 234
103188: GO 103173
103190: POP
103191: POP
// end ;
103192: PPOPN 2
103194: END
// every 0 0$1 trigger StreamModeActive and sRandom do var i , tmp , un ;
103195: LD_EXP 139
103199: PUSH
103200: LD_EXP 188
103204: AND
103205: IFFALSE 103492
103207: GO 103209
103209: DISABLE
103210: LD_INT 0
103212: PPUSH
103213: PPUSH
103214: PPUSH
// begin i := rand ( 1 , 7 ) ;
103215: LD_ADDR_VAR 0 1
103219: PUSH
103220: LD_INT 1
103222: PPUSH
103223: LD_INT 7
103225: PPUSH
103226: CALL_OW 12
103230: ST_TO_ADDR
// case i of 1 :
103231: LD_VAR 0 1
103235: PUSH
103236: LD_INT 1
103238: DOUBLE
103239: EQUAL
103240: IFTRUE 103244
103242: GO 103254
103244: POP
// ToLua ( earthquake(getX(game), 0, 32) ) ; 2 :
103245: LD_STRING earthquake(getX(game), 0, 32)
103247: PPUSH
103248: CALL_OW 559
103252: GO 103492
103254: LD_INT 2
103256: DOUBLE
103257: EQUAL
103258: IFTRUE 103262
103260: GO 103276
103262: POP
// begin ToLua ( displayStucuk(); ) ;
103263: LD_STRING displayStucuk();
103265: PPUSH
103266: CALL_OW 559
// ResetFog ;
103270: CALL_OW 335
// end ; 3 :
103274: GO 103492
103276: LD_INT 3
103278: DOUBLE
103279: EQUAL
103280: IFTRUE 103284
103282: GO 103388
103284: POP
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_class , 1 ] ] ) ;
103285: LD_ADDR_VAR 0 2
103289: PUSH
103290: LD_INT 22
103292: PUSH
103293: LD_OWVAR 2
103297: PUSH
103298: EMPTY
103299: LIST
103300: LIST
103301: PUSH
103302: LD_INT 25
103304: PUSH
103305: LD_INT 1
103307: PUSH
103308: EMPTY
103309: LIST
103310: LIST
103311: PUSH
103312: EMPTY
103313: LIST
103314: LIST
103315: PPUSH
103316: CALL_OW 69
103320: ST_TO_ADDR
// if not tmp then
103321: LD_VAR 0 2
103325: NOT
103326: IFFALSE 103330
// exit ;
103328: GO 103492
// un := tmp [ rand ( 1 , tmp ) ] ;
103330: LD_ADDR_VAR 0 3
103334: PUSH
103335: LD_VAR 0 2
103339: PUSH
103340: LD_INT 1
103342: PPUSH
103343: LD_VAR 0 2
103347: PPUSH
103348: CALL_OW 12
103352: ARRAY
103353: ST_TO_ADDR
// if Crawls ( un ) then
103354: LD_VAR 0 3
103358: PPUSH
103359: CALL_OW 318
103363: IFFALSE 103374
// ComWalk ( un ) ;
103365: LD_VAR 0 3
103369: PPUSH
103370: CALL_OW 138
// SetClass ( un , class_mortar ) ;
103374: LD_VAR 0 3
103378: PPUSH
103379: LD_INT 8
103381: PPUSH
103382: CALL_OW 336
// end ; 4 :
103386: GO 103492
103388: LD_INT 4
103390: DOUBLE
103391: EQUAL
103392: IFTRUE 103396
103394: GO 103470
103396: POP
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_btype , b_oil_mine ] ] ) ;
103397: LD_ADDR_VAR 0 2
103401: PUSH
103402: LD_INT 22
103404: PUSH
103405: LD_OWVAR 2
103409: PUSH
103410: EMPTY
103411: LIST
103412: LIST
103413: PUSH
103414: LD_INT 30
103416: PUSH
103417: LD_INT 29
103419: PUSH
103420: EMPTY
103421: LIST
103422: LIST
103423: PUSH
103424: EMPTY
103425: LIST
103426: LIST
103427: PPUSH
103428: CALL_OW 69
103432: ST_TO_ADDR
// if not tmp then
103433: LD_VAR 0 2
103437: NOT
103438: IFFALSE 103442
// exit ;
103440: GO 103492
// CenterNowOnUnits ( tmp [ 1 ] ) ;
103442: LD_VAR 0 2
103446: PUSH
103447: LD_INT 1
103449: ARRAY
103450: PPUSH
103451: CALL_OW 87
// DestroyUnit ( tmp [ 1 ] ) ;
103455: LD_VAR 0 2
103459: PUSH
103460: LD_INT 1
103462: ARRAY
103463: PPUSH
103464: CALL_OW 65
// end ; 5 .. 7 :
103468: GO 103492
103470: LD_INT 5
103472: DOUBLE
103473: GREATEREQUAL
103474: IFFALSE 103482
103476: LD_INT 7
103478: DOUBLE
103479: LESSEQUAL
103480: IFTRUE 103484
103482: GO 103491
103484: POP
// StreamSibBomb ; end ;
103485: CALL 99729 0 0
103489: GO 103492
103491: POP
// end ;
103492: PPOPN 3
103494: END
// every 0 0$1 trigger StreamModeActive and sShield do var i , tmp , p ;
103495: LD_EXP 139
103499: PUSH
103500: LD_EXP 189
103504: AND
103505: IFFALSE 103661
103507: GO 103509
103509: DISABLE
103510: LD_INT 0
103512: PPUSH
103513: PPUSH
103514: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_enemy , your_side ] , [ f_or , [ f_type , unit_human ] , [ f_type , unit_vehicle ] ] ] ) ;
103515: LD_ADDR_VAR 0 2
103519: PUSH
103520: LD_INT 81
103522: PUSH
103523: LD_OWVAR 2
103527: PUSH
103528: EMPTY
103529: LIST
103530: LIST
103531: PUSH
103532: LD_INT 2
103534: PUSH
103535: LD_INT 21
103537: PUSH
103538: LD_INT 1
103540: PUSH
103541: EMPTY
103542: LIST
103543: LIST
103544: PUSH
103545: LD_INT 21
103547: PUSH
103548: LD_INT 2
103550: PUSH
103551: EMPTY
103552: LIST
103553: LIST
103554: PUSH
103555: EMPTY
103556: LIST
103557: LIST
103558: LIST
103559: PUSH
103560: EMPTY
103561: LIST
103562: LIST
103563: PPUSH
103564: CALL_OW 69
103568: ST_TO_ADDR
// if not tmp then
103569: LD_VAR 0 2
103573: NOT
103574: IFFALSE 103578
// exit ;
103576: GO 103661
// p := 0 ;
103578: LD_ADDR_VAR 0 3
103582: PUSH
103583: LD_INT 0
103585: ST_TO_ADDR
// repeat wait ( 0 0$1 ) ;
103586: LD_INT 35
103588: PPUSH
103589: CALL_OW 67
// p := p + 1 ;
103593: LD_ADDR_VAR 0 3
103597: PUSH
103598: LD_VAR 0 3
103602: PUSH
103603: LD_INT 1
103605: PLUS
103606: ST_TO_ADDR
// for i in tmp do
103607: LD_ADDR_VAR 0 1
103611: PUSH
103612: LD_VAR 0 2
103616: PUSH
103617: FOR_IN
103618: IFFALSE 103649
// if GetLives ( i ) < 1000 then
103620: LD_VAR 0 1
103624: PPUSH
103625: CALL_OW 256
103629: PUSH
103630: LD_INT 1000
103632: LESS
103633: IFFALSE 103647
// SetLives ( i , 1000 ) ;
103635: LD_VAR 0 1
103639: PPUSH
103640: LD_INT 1000
103642: PPUSH
103643: CALL_OW 234
103647: GO 103617
103649: POP
103650: POP
// until p > 20 ;
103651: LD_VAR 0 3
103655: PUSH
103656: LD_INT 20
103658: GREATER
103659: IFFALSE 103586
// end ;
103661: PPOPN 3
103663: END
// every 0 0$1 trigger StreamModeActive and sTime do
103664: LD_EXP 139
103668: PUSH
103669: LD_EXP 190
103673: AND
103674: IFFALSE 103709
103676: GO 103678
103678: DISABLE
// begin SetTech ( tech_tauRad , your_side , state_researched ) ;
103679: LD_INT 28
103681: PPUSH
103682: LD_OWVAR 2
103686: PPUSH
103687: LD_INT 2
103689: PPUSH
103690: CALL_OW 322
// SetTech ( tech_tauField , your_side , state_researched ) ;
103694: LD_INT 30
103696: PPUSH
103697: LD_OWVAR 2
103701: PPUSH
103702: LD_INT 2
103704: PPUSH
103705: CALL_OW 322
// end ;
103709: END
// every 0 0$1 trigger StreamModeActive and sTools do var i , tmp ;
103710: LD_EXP 139
103714: PUSH
103715: LD_EXP 191
103719: AND
103720: IFFALSE 103841
103722: GO 103724
103724: DISABLE
103725: LD_INT 0
103727: PPUSH
103728: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_type , unit_human ] , [ f_not , [ f_nation , 0 ] ] ] ) ;
103729: LD_ADDR_VAR 0 2
103733: PUSH
103734: LD_INT 22
103736: PUSH
103737: LD_OWVAR 2
103741: PUSH
103742: EMPTY
103743: LIST
103744: LIST
103745: PUSH
103746: LD_INT 21
103748: PUSH
103749: LD_INT 1
103751: PUSH
103752: EMPTY
103753: LIST
103754: LIST
103755: PUSH
103756: LD_INT 3
103758: PUSH
103759: LD_INT 23
103761: PUSH
103762: LD_INT 0
103764: PUSH
103765: EMPTY
103766: LIST
103767: LIST
103768: PUSH
103769: EMPTY
103770: LIST
103771: LIST
103772: PUSH
103773: EMPTY
103774: LIST
103775: LIST
103776: LIST
103777: PPUSH
103778: CALL_OW 69
103782: ST_TO_ADDR
// if not tmp then
103783: LD_VAR 0 2
103787: NOT
103788: IFFALSE 103792
// exit ;
103790: GO 103841
// for i in tmp do
103792: LD_ADDR_VAR 0 1
103796: PUSH
103797: LD_VAR 0 2
103801: PUSH
103802: FOR_IN
103803: IFFALSE 103839
// begin if Crawls ( i ) then
103805: LD_VAR 0 1
103809: PPUSH
103810: CALL_OW 318
103814: IFFALSE 103825
// ComWalk ( i ) ;
103816: LD_VAR 0 1
103820: PPUSH
103821: CALL_OW 138
// SetClass ( i , 2 ) ;
103825: LD_VAR 0 1
103829: PPUSH
103830: LD_INT 2
103832: PPUSH
103833: CALL_OW 336
// end ;
103837: GO 103802
103839: POP
103840: POP
// end ;
103841: PPOPN 2
103843: END
// every 0 0$1 trigger StreamModeActive and sRanger do var i , p , un ;
103844: LD_EXP 139
103848: PUSH
103849: LD_EXP 192
103853: AND
103854: IFFALSE 104142
103856: GO 103858
103858: DISABLE
103859: LD_INT 0
103861: PPUSH
103862: PPUSH
103863: PPUSH
// begin SetAttitude ( your_side , 9 , att_friend , true ) ;
103864: LD_OWVAR 2
103868: PPUSH
103869: LD_INT 9
103871: PPUSH
103872: LD_INT 1
103874: PPUSH
103875: LD_INT 1
103877: PPUSH
103878: CALL_OW 80
// ChangeSideFog ( 9 , your_side ) ;
103882: LD_INT 9
103884: PPUSH
103885: LD_OWVAR 2
103889: PPUSH
103890: CALL_OW 343
// uc_side := 9 ;
103894: LD_ADDR_OWVAR 20
103898: PUSH
103899: LD_INT 9
103901: ST_TO_ADDR
// uc_nation := 2 ;
103902: LD_ADDR_OWVAR 21
103906: PUSH
103907: LD_INT 2
103909: ST_TO_ADDR
// hc_name := Dark Warrior ;
103910: LD_ADDR_OWVAR 26
103914: PUSH
103915: LD_STRING Dark Warrior
103917: ST_TO_ADDR
// hc_gallery :=  ;
103918: LD_ADDR_OWVAR 33
103922: PUSH
103923: LD_STRING 
103925: ST_TO_ADDR
// hc_noskilllimit := true ;
103926: LD_ADDR_OWVAR 76
103930: PUSH
103931: LD_INT 1
103933: ST_TO_ADDR
// hc_skills := [ 30 , 30 , 30 , 30 ] ;
103934: LD_ADDR_OWVAR 31
103938: PUSH
103939: LD_INT 30
103941: PUSH
103942: LD_INT 30
103944: PUSH
103945: LD_INT 30
103947: PUSH
103948: LD_INT 30
103950: PUSH
103951: EMPTY
103952: LIST
103953: LIST
103954: LIST
103955: LIST
103956: ST_TO_ADDR
// un := CreateHuman ;
103957: LD_ADDR_VAR 0 3
103961: PUSH
103962: CALL_OW 44
103966: ST_TO_ADDR
// hc_noskilllimit := false ;
103967: LD_ADDR_OWVAR 76
103971: PUSH
103972: LD_INT 0
103974: ST_TO_ADDR
// PlaceUnitAnywhere ( un , true ) ;
103975: LD_VAR 0 3
103979: PPUSH
103980: LD_INT 1
103982: PPUSH
103983: CALL_OW 51
// ToLua ( playRanger() ) ;
103987: LD_STRING playRanger()
103989: PPUSH
103990: CALL_OW 559
// p := 0 ;
103994: LD_ADDR_VAR 0 2
103998: PUSH
103999: LD_INT 0
104001: ST_TO_ADDR
// repeat wait ( 0 0$1 ) ;
104002: LD_INT 35
104004: PPUSH
104005: CALL_OW 67
// p := p + 1 ;
104009: LD_ADDR_VAR 0 2
104013: PUSH
104014: LD_VAR 0 2
104018: PUSH
104019: LD_INT 1
104021: PLUS
104022: ST_TO_ADDR
// if GetLives ( un ) < 1000 then
104023: LD_VAR 0 3
104027: PPUSH
104028: CALL_OW 256
104032: PUSH
104033: LD_INT 1000
104035: LESS
104036: IFFALSE 104050
// SetLives ( un , 1000 ) ;
104038: LD_VAR 0 3
104042: PPUSH
104043: LD_INT 1000
104045: PPUSH
104046: CALL_OW 234
// ComAttackUnit ( un , NearestUnitToUnit ( FilterAllUnits ( [ [ f_enemy , your_side ] , [ f_dist , un , 30 ] ] ) , un ) ) ;
104050: LD_VAR 0 3
104054: PPUSH
104055: LD_INT 81
104057: PUSH
104058: LD_OWVAR 2
104062: PUSH
104063: EMPTY
104064: LIST
104065: LIST
104066: PUSH
104067: LD_INT 91
104069: PUSH
104070: LD_VAR 0 3
104074: PUSH
104075: LD_INT 30
104077: PUSH
104078: EMPTY
104079: LIST
104080: LIST
104081: LIST
104082: PUSH
104083: EMPTY
104084: LIST
104085: LIST
104086: PPUSH
104087: CALL_OW 69
104091: PPUSH
104092: LD_VAR 0 3
104096: PPUSH
104097: CALL_OW 74
104101: PPUSH
104102: CALL_OW 115
// until p > 80 or IsDead ( un ) ;
104106: LD_VAR 0 2
104110: PUSH
104111: LD_INT 80
104113: GREATER
104114: PUSH
104115: LD_VAR 0 3
104119: PPUSH
104120: CALL_OW 301
104124: OR
104125: IFFALSE 104002
// if un then
104127: LD_VAR 0 3
104131: IFFALSE 104142
// RemoveUnit ( un ) ;
104133: LD_VAR 0 3
104137: PPUSH
104138: CALL_OW 64
// end ;
104142: PPOPN 3
104144: END
// every 0 0$1 trigger sComputer do var i , tmp , j ;
104145: LD_EXP 193
104149: IFFALSE 104265
104151: GO 104153
104153: DISABLE
104154: LD_INT 0
104156: PPUSH
104157: PPUSH
104158: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_enemy , your_side ] , [ f_type , unit_human ] ] ) ;
104159: LD_ADDR_VAR 0 2
104163: PUSH
104164: LD_INT 81
104166: PUSH
104167: LD_OWVAR 2
104171: PUSH
104172: EMPTY
104173: LIST
104174: LIST
104175: PUSH
104176: LD_INT 21
104178: PUSH
104179: LD_INT 1
104181: PUSH
104182: EMPTY
104183: LIST
104184: LIST
104185: PUSH
104186: EMPTY
104187: LIST
104188: LIST
104189: PPUSH
104190: CALL_OW 69
104194: ST_TO_ADDR
// ToLua ( playComputer() ) ;
104195: LD_STRING playComputer()
104197: PPUSH
104198: CALL_OW 559
// if not tmp then
104202: LD_VAR 0 2
104206: NOT
104207: IFFALSE 104211
// exit ;
104209: GO 104265
// for i in tmp do
104211: LD_ADDR_VAR 0 1
104215: PUSH
104216: LD_VAR 0 2
104220: PUSH
104221: FOR_IN
104222: IFFALSE 104263
// for j := 1 to 4 do
104224: LD_ADDR_VAR 0 3
104228: PUSH
104229: DOUBLE
104230: LD_INT 1
104232: DEC
104233: ST_TO_ADDR
104234: LD_INT 4
104236: PUSH
104237: FOR_TO
104238: IFFALSE 104259
// SetSkill ( i , j , 10 ) ;
104240: LD_VAR 0 1
104244: PPUSH
104245: LD_VAR 0 3
104249: PPUSH
104250: LD_INT 10
104252: PPUSH
104253: CALL_OW 237
104257: GO 104237
104259: POP
104260: POP
104261: GO 104221
104263: POP
104264: POP
// end ;
104265: PPOPN 3
104267: END
// every 0 0$1 trigger s30 do var i , tmp ;
104268: LD_EXP 194
104272: IFFALSE 104341
104274: GO 104276
104276: DISABLE
104277: LD_INT 0
104279: PPUSH
104280: PPUSH
// begin tmp := FilterAllUnits ( [ f_side , your_side ] ) ;
104281: LD_ADDR_VAR 0 2
104285: PUSH
104286: LD_INT 22
104288: PUSH
104289: LD_OWVAR 2
104293: PUSH
104294: EMPTY
104295: LIST
104296: LIST
104297: PPUSH
104298: CALL_OW 69
104302: ST_TO_ADDR
// if not tmp then
104303: LD_VAR 0 2
104307: NOT
104308: IFFALSE 104312
// exit ;
104310: GO 104341
// for i in tmp do
104312: LD_ADDR_VAR 0 1
104316: PUSH
104317: LD_VAR 0 2
104321: PUSH
104322: FOR_IN
104323: IFFALSE 104339
// SetLives ( i , 300 ) ;
104325: LD_VAR 0 1
104329: PPUSH
104330: LD_INT 300
104332: PPUSH
104333: CALL_OW 234
104337: GO 104322
104339: POP
104340: POP
// end ;
104341: PPOPN 2
104343: END
// every 0 0$1 trigger s60 do var i , tmp ;
104344: LD_EXP 195
104348: IFFALSE 104417
104350: GO 104352
104352: DISABLE
104353: LD_INT 0
104355: PPUSH
104356: PPUSH
// begin tmp := FilterAllUnits ( [ f_side , your_side ] ) ;
104357: LD_ADDR_VAR 0 2
104361: PUSH
104362: LD_INT 22
104364: PUSH
104365: LD_OWVAR 2
104369: PUSH
104370: EMPTY
104371: LIST
104372: LIST
104373: PPUSH
104374: CALL_OW 69
104378: ST_TO_ADDR
// if not tmp then
104379: LD_VAR 0 2
104383: NOT
104384: IFFALSE 104388
// exit ;
104386: GO 104417
// for i in tmp do
104388: LD_ADDR_VAR 0 1
104392: PUSH
104393: LD_VAR 0 2
104397: PUSH
104398: FOR_IN
104399: IFFALSE 104415
// SetLives ( i , 600 ) ;
104401: LD_VAR 0 1
104405: PPUSH
104406: LD_INT 600
104408: PPUSH
104409: CALL_OW 234
104413: GO 104398
104415: POP
104416: POP
// end ;
104417: PPOPN 2
104419: END
// export function SOS_TargetableHack ( cmd , unit , selectedUnit , x , y , p1 , p2 , p3 , p4 , p5 , p6 ) ; begin
104420: LD_INT 0
104422: PPUSH
// case cmd of 301 :
104423: LD_VAR 0 1
104427: PUSH
104428: LD_INT 301
104430: DOUBLE
104431: EQUAL
104432: IFTRUE 104436
104434: GO 104468
104436: POP
// hHackSpawnHuman ( p1 , p2 , p3 , x , y ) ; 302 :
104437: LD_VAR 0 6
104441: PPUSH
104442: LD_VAR 0 7
104446: PPUSH
104447: LD_VAR 0 8
104451: PPUSH
104452: LD_VAR 0 4
104456: PPUSH
104457: LD_VAR 0 5
104461: PPUSH
104462: CALL 105669 0 5
104466: GO 104589
104468: LD_INT 302
104470: DOUBLE
104471: EQUAL
104472: IFTRUE 104476
104474: GO 104513
104476: POP
// hHackSpawnVehicle ( p1 , p2 , p3 , p4 , x , y ) ; 303 :
104477: LD_VAR 0 6
104481: PPUSH
104482: LD_VAR 0 7
104486: PPUSH
104487: LD_VAR 0 8
104491: PPUSH
104492: LD_VAR 0 9
104496: PPUSH
104497: LD_VAR 0 4
104501: PPUSH
104502: LD_VAR 0 5
104506: PPUSH
104507: CALL 105760 0 6
104511: GO 104589
104513: LD_INT 303
104515: DOUBLE
104516: EQUAL
104517: IFTRUE 104521
104519: GO 104558
104521: POP
// hHackSpawnBuilding ( p1 , p2 , p3 , p4 , x , y ) ; 304 :
104522: LD_VAR 0 6
104526: PPUSH
104527: LD_VAR 0 7
104531: PPUSH
104532: LD_VAR 0 8
104536: PPUSH
104537: LD_VAR 0 9
104541: PPUSH
104542: LD_VAR 0 4
104546: PPUSH
104547: LD_VAR 0 5
104551: PPUSH
104552: CALL 104594 0 6
104556: GO 104589
104558: LD_INT 304
104560: DOUBLE
104561: EQUAL
104562: IFTRUE 104566
104564: GO 104588
104566: POP
// hHackTeleport ( unit , x , y ) ; end ;
104567: LD_VAR 0 2
104571: PPUSH
104572: LD_VAR 0 4
104576: PPUSH
104577: LD_VAR 0 5
104581: PPUSH
104582: CALL 106353 0 3
104586: GO 104589
104588: POP
// end ;
104589: LD_VAR 0 12
104593: RET
// export function hHackSpawnBuilding ( nation , btype , dir , weapon , x , y ) ; var b ; begin
104594: LD_INT 0
104596: PPUSH
104597: PPUSH
// if nation < 1 or nation > 3 or HexInfo ( x , y ) then
104598: LD_VAR 0 1
104602: PUSH
104603: LD_INT 1
104605: LESS
104606: PUSH
104607: LD_VAR 0 1
104611: PUSH
104612: LD_INT 3
104614: GREATER
104615: OR
104616: PUSH
104617: LD_VAR 0 5
104621: PPUSH
104622: LD_VAR 0 6
104626: PPUSH
104627: CALL_OW 428
104631: OR
104632: IFFALSE 104636
// exit ;
104634: GO 105356
// uc_side := your_side ;
104636: LD_ADDR_OWVAR 20
104640: PUSH
104641: LD_OWVAR 2
104645: ST_TO_ADDR
// uc_nation := nation ;
104646: LD_ADDR_OWVAR 21
104650: PUSH
104651: LD_VAR 0 1
104655: ST_TO_ADDR
// bc_level = 1 ;
104656: LD_ADDR_OWVAR 43
104660: PUSH
104661: LD_INT 1
104663: ST_TO_ADDR
// case btype of 1 :
104664: LD_VAR 0 2
104668: PUSH
104669: LD_INT 1
104671: DOUBLE
104672: EQUAL
104673: IFTRUE 104677
104675: GO 104688
104677: POP
// bc_type := b_depot ; 2 :
104678: LD_ADDR_OWVAR 42
104682: PUSH
104683: LD_INT 0
104685: ST_TO_ADDR
104686: GO 105300
104688: LD_INT 2
104690: DOUBLE
104691: EQUAL
104692: IFTRUE 104696
104694: GO 104707
104696: POP
// bc_type := b_warehouse ; 3 :
104697: LD_ADDR_OWVAR 42
104701: PUSH
104702: LD_INT 1
104704: ST_TO_ADDR
104705: GO 105300
104707: LD_INT 3
104709: DOUBLE
104710: EQUAL
104711: IFTRUE 104715
104713: GO 104726
104715: POP
// bc_type := b_lab ; 4 .. 9 :
104716: LD_ADDR_OWVAR 42
104720: PUSH
104721: LD_INT 6
104723: ST_TO_ADDR
104724: GO 105300
104726: LD_INT 4
104728: DOUBLE
104729: GREATEREQUAL
104730: IFFALSE 104738
104732: LD_INT 9
104734: DOUBLE
104735: LESSEQUAL
104736: IFTRUE 104740
104738: GO 104792
104740: POP
// begin bc_type := b_lab_half ;
104741: LD_ADDR_OWVAR 42
104745: PUSH
104746: LD_INT 7
104748: ST_TO_ADDR
// bc_kind1 := [ b_lab_weapon , b_lab_siberium , b_lab_computer , b_lab_opto , b_lab_spacetime , b_lab_biological ] [ btype - 3 ] ;
104749: LD_ADDR_OWVAR 44
104753: PUSH
104754: LD_INT 10
104756: PUSH
104757: LD_INT 11
104759: PUSH
104760: LD_INT 12
104762: PUSH
104763: LD_INT 15
104765: PUSH
104766: LD_INT 14
104768: PUSH
104769: LD_INT 13
104771: PUSH
104772: EMPTY
104773: LIST
104774: LIST
104775: LIST
104776: LIST
104777: LIST
104778: LIST
104779: PUSH
104780: LD_VAR 0 2
104784: PUSH
104785: LD_INT 3
104787: MINUS
104788: ARRAY
104789: ST_TO_ADDR
// end ; 10 .. 13 :
104790: GO 105300
104792: LD_INT 10
104794: DOUBLE
104795: GREATEREQUAL
104796: IFFALSE 104804
104798: LD_INT 13
104800: DOUBLE
104801: LESSEQUAL
104802: IFTRUE 104806
104804: GO 104883
104806: POP
// begin bc_type := b_lab_full ;
104807: LD_ADDR_OWVAR 42
104811: PUSH
104812: LD_INT 8
104814: ST_TO_ADDR
// bc_kind1 := [ b_lab_weapon , b_lab_computer , b_lab_spacetime , b_lab_biological ] [ btype - 9 ] ;
104815: LD_ADDR_OWVAR 44
104819: PUSH
104820: LD_INT 10
104822: PUSH
104823: LD_INT 12
104825: PUSH
104826: LD_INT 14
104828: PUSH
104829: LD_INT 13
104831: PUSH
104832: EMPTY
104833: LIST
104834: LIST
104835: LIST
104836: LIST
104837: PUSH
104838: LD_VAR 0 2
104842: PUSH
104843: LD_INT 9
104845: MINUS
104846: ARRAY
104847: ST_TO_ADDR
// bc_kind2 := [ b_lab_siberium , b_lab_opto , b_lab_computer , b_lab_opto ] [ btype - 9 ] ;
104848: LD_ADDR_OWVAR 45
104852: PUSH
104853: LD_INT 11
104855: PUSH
104856: LD_INT 15
104858: PUSH
104859: LD_INT 12
104861: PUSH
104862: LD_INT 15
104864: PUSH
104865: EMPTY
104866: LIST
104867: LIST
104868: LIST
104869: LIST
104870: PUSH
104871: LD_VAR 0 2
104875: PUSH
104876: LD_INT 9
104878: MINUS
104879: ARRAY
104880: ST_TO_ADDR
// end ; 14 :
104881: GO 105300
104883: LD_INT 14
104885: DOUBLE
104886: EQUAL
104887: IFTRUE 104891
104889: GO 104902
104891: POP
// bc_type := b_workshop ; 15 :
104892: LD_ADDR_OWVAR 42
104896: PUSH
104897: LD_INT 2
104899: ST_TO_ADDR
104900: GO 105300
104902: LD_INT 15
104904: DOUBLE
104905: EQUAL
104906: IFTRUE 104910
104908: GO 104921
104910: POP
// bc_type := b_factory ; 16 :
104911: LD_ADDR_OWVAR 42
104915: PUSH
104916: LD_INT 3
104918: ST_TO_ADDR
104919: GO 105300
104921: LD_INT 16
104923: DOUBLE
104924: EQUAL
104925: IFTRUE 104929
104927: GO 104940
104929: POP
// bc_type := b_ext_gun ; 17 :
104930: LD_ADDR_OWVAR 42
104934: PUSH
104935: LD_INT 17
104937: ST_TO_ADDR
104938: GO 105300
104940: LD_INT 17
104942: DOUBLE
104943: EQUAL
104944: IFTRUE 104948
104946: GO 104976
104948: POP
// bc_type := [ b_ext_noncombat , b_ext_stitch , b_ext_noncombat ] [ nation ] ; 18 :
104949: LD_ADDR_OWVAR 42
104953: PUSH
104954: LD_INT 19
104956: PUSH
104957: LD_INT 23
104959: PUSH
104960: LD_INT 19
104962: PUSH
104963: EMPTY
104964: LIST
104965: LIST
104966: LIST
104967: PUSH
104968: LD_VAR 0 1
104972: ARRAY
104973: ST_TO_ADDR
104974: GO 105300
104976: LD_INT 18
104978: DOUBLE
104979: EQUAL
104980: IFTRUE 104984
104982: GO 104995
104984: POP
// bc_type := b_ext_radar ; 19 :
104985: LD_ADDR_OWVAR 42
104989: PUSH
104990: LD_INT 20
104992: ST_TO_ADDR
104993: GO 105300
104995: LD_INT 19
104997: DOUBLE
104998: EQUAL
104999: IFTRUE 105003
105001: GO 105014
105003: POP
// bc_type := b_ext_radio ; 20 :
105004: LD_ADDR_OWVAR 42
105008: PUSH
105009: LD_INT 22
105011: ST_TO_ADDR
105012: GO 105300
105014: LD_INT 20
105016: DOUBLE
105017: EQUAL
105018: IFTRUE 105022
105020: GO 105033
105022: POP
// bc_type := b_ext_siberium ; 21 :
105023: LD_ADDR_OWVAR 42
105027: PUSH
105028: LD_INT 21
105030: ST_TO_ADDR
105031: GO 105300
105033: LD_INT 21
105035: DOUBLE
105036: EQUAL
105037: IFTRUE 105041
105039: GO 105052
105041: POP
// bc_type := b_ext_computer ; 22 :
105042: LD_ADDR_OWVAR 42
105046: PUSH
105047: LD_INT 24
105049: ST_TO_ADDR
105050: GO 105300
105052: LD_INT 22
105054: DOUBLE
105055: EQUAL
105056: IFTRUE 105060
105058: GO 105071
105060: POP
// bc_type := b_ext_track ; 23 :
105061: LD_ADDR_OWVAR 42
105065: PUSH
105066: LD_INT 16
105068: ST_TO_ADDR
105069: GO 105300
105071: LD_INT 23
105073: DOUBLE
105074: EQUAL
105075: IFTRUE 105079
105077: GO 105090
105079: POP
// bc_type := b_ext_laser ; 24 :
105080: LD_ADDR_OWVAR 42
105084: PUSH
105085: LD_INT 25
105087: ST_TO_ADDR
105088: GO 105300
105090: LD_INT 24
105092: DOUBLE
105093: EQUAL
105094: IFTRUE 105098
105096: GO 105109
105098: POP
// bc_type := b_control_tower ; 25 :
105099: LD_ADDR_OWVAR 42
105103: PUSH
105104: LD_INT 36
105106: ST_TO_ADDR
105107: GO 105300
105109: LD_INT 25
105111: DOUBLE
105112: EQUAL
105113: IFTRUE 105117
105115: GO 105128
105117: POP
// bc_type := b_breastwork ; 26 :
105118: LD_ADDR_OWVAR 42
105122: PUSH
105123: LD_INT 31
105125: ST_TO_ADDR
105126: GO 105300
105128: LD_INT 26
105130: DOUBLE
105131: EQUAL
105132: IFTRUE 105136
105134: GO 105147
105136: POP
// bc_type := b_bunker ; 27 :
105137: LD_ADDR_OWVAR 42
105141: PUSH
105142: LD_INT 32
105144: ST_TO_ADDR
105145: GO 105300
105147: LD_INT 27
105149: DOUBLE
105150: EQUAL
105151: IFTRUE 105155
105153: GO 105166
105155: POP
// bc_type := b_turret ; 28 :
105156: LD_ADDR_OWVAR 42
105160: PUSH
105161: LD_INT 33
105163: ST_TO_ADDR
105164: GO 105300
105166: LD_INT 28
105168: DOUBLE
105169: EQUAL
105170: IFTRUE 105174
105172: GO 105185
105174: POP
// bc_type := b_armoury ; 29 :
105175: LD_ADDR_OWVAR 42
105179: PUSH
105180: LD_INT 4
105182: ST_TO_ADDR
105183: GO 105300
105185: LD_INT 29
105187: DOUBLE
105188: EQUAL
105189: IFTRUE 105193
105191: GO 105204
105193: POP
// bc_type := b_barracks ; 30 :
105194: LD_ADDR_OWVAR 42
105198: PUSH
105199: LD_INT 5
105201: ST_TO_ADDR
105202: GO 105300
105204: LD_INT 30
105206: DOUBLE
105207: EQUAL
105208: IFTRUE 105212
105210: GO 105223
105212: POP
// bc_type := b_solar_power ; 31 :
105213: LD_ADDR_OWVAR 42
105217: PUSH
105218: LD_INT 27
105220: ST_TO_ADDR
105221: GO 105300
105223: LD_INT 31
105225: DOUBLE
105226: EQUAL
105227: IFTRUE 105231
105229: GO 105242
105231: POP
// bc_type := b_oil_power ; 32 :
105232: LD_ADDR_OWVAR 42
105236: PUSH
105237: LD_INT 26
105239: ST_TO_ADDR
105240: GO 105300
105242: LD_INT 32
105244: DOUBLE
105245: EQUAL
105246: IFTRUE 105250
105248: GO 105261
105250: POP
// bc_type := b_siberite_power ; 33 :
105251: LD_ADDR_OWVAR 42
105255: PUSH
105256: LD_INT 28
105258: ST_TO_ADDR
105259: GO 105300
105261: LD_INT 33
105263: DOUBLE
105264: EQUAL
105265: IFTRUE 105269
105267: GO 105280
105269: POP
// bc_type := b_oil_mine ; 34 :
105270: LD_ADDR_OWVAR 42
105274: PUSH
105275: LD_INT 29
105277: ST_TO_ADDR
105278: GO 105300
105280: LD_INT 34
105282: DOUBLE
105283: EQUAL
105284: IFTRUE 105288
105286: GO 105299
105288: POP
// bc_type := b_siberite_mine ; end ;
105289: LD_ADDR_OWVAR 42
105293: PUSH
105294: LD_INT 30
105296: ST_TO_ADDR
105297: GO 105300
105299: POP
// b := CreateAndPlaceBuildingXYD ( x , y , dir ) ;
105300: LD_ADDR_VAR 0 8
105304: PUSH
105305: LD_VAR 0 5
105309: PPUSH
105310: LD_VAR 0 6
105314: PPUSH
105315: LD_VAR 0 3
105319: PPUSH
105320: CALL_OW 47
105324: ST_TO_ADDR
// if bc_type in [ b_bunker , b_turret ] then
105325: LD_OWVAR 42
105329: PUSH
105330: LD_INT 32
105332: PUSH
105333: LD_INT 33
105335: PUSH
105336: EMPTY
105337: LIST
105338: LIST
105339: IN
105340: IFFALSE 105356
// PlaceWeaponTurret ( b , weapon ) ;
105342: LD_VAR 0 8
105346: PPUSH
105347: LD_VAR 0 4
105351: PPUSH
105352: CALL_OW 431
// end ;
105356: LD_VAR 0 7
105360: RET
// export function hHackUnlimitedResources ; var i , j , tmp ; begin
105361: LD_INT 0
105363: PPUSH
105364: PPUSH
105365: PPUSH
105366: PPUSH
// tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ] ) ;
105367: LD_ADDR_VAR 0 4
105371: PUSH
105372: LD_INT 22
105374: PUSH
105375: LD_OWVAR 2
105379: PUSH
105380: EMPTY
105381: LIST
105382: LIST
105383: PUSH
105384: LD_INT 2
105386: PUSH
105387: LD_INT 30
105389: PUSH
105390: LD_INT 0
105392: PUSH
105393: EMPTY
105394: LIST
105395: LIST
105396: PUSH
105397: LD_INT 30
105399: PUSH
105400: LD_INT 1
105402: PUSH
105403: EMPTY
105404: LIST
105405: LIST
105406: PUSH
105407: EMPTY
105408: LIST
105409: LIST
105410: LIST
105411: PUSH
105412: EMPTY
105413: LIST
105414: LIST
105415: PPUSH
105416: CALL_OW 69
105420: ST_TO_ADDR
// if not tmp then
105421: LD_VAR 0 4
105425: NOT
105426: IFFALSE 105430
// exit ;
105428: GO 105489
// for i in tmp do
105430: LD_ADDR_VAR 0 2
105434: PUSH
105435: LD_VAR 0 4
105439: PUSH
105440: FOR_IN
105441: IFFALSE 105487
// for j = 1 to 3 do
105443: LD_ADDR_VAR 0 3
105447: PUSH
105448: DOUBLE
105449: LD_INT 1
105451: DEC
105452: ST_TO_ADDR
105453: LD_INT 3
105455: PUSH
105456: FOR_TO
105457: IFFALSE 105483
// SetResourceType ( GetBase ( i ) , j , 99999 ) ;
105459: LD_VAR 0 2
105463: PPUSH
105464: CALL_OW 274
105468: PPUSH
105469: LD_VAR 0 3
105473: PPUSH
105474: LD_INT 99999
105476: PPUSH
105477: CALL_OW 277
105481: GO 105456
105483: POP
105484: POP
105485: GO 105440
105487: POP
105488: POP
// end ;
105489: LD_VAR 0 1
105493: RET
// export function hHackSetLevel10 ; var i , j ; begin
105494: LD_INT 0
105496: PPUSH
105497: PPUSH
105498: PPUSH
// for i in FilterAllUnits ( [ f_type , unit_human ] ) do
105499: LD_ADDR_VAR 0 2
105503: PUSH
105504: LD_INT 21
105506: PUSH
105507: LD_INT 1
105509: PUSH
105510: EMPTY
105511: LIST
105512: LIST
105513: PPUSH
105514: CALL_OW 69
105518: PUSH
105519: FOR_IN
105520: IFFALSE 105572
// if IsSelected ( i ) then
105522: LD_VAR 0 2
105526: PPUSH
105527: CALL_OW 306
105531: IFFALSE 105570
// begin for j := 1 to 4 do
105533: LD_ADDR_VAR 0 3
105537: PUSH
105538: DOUBLE
105539: LD_INT 1
105541: DEC
105542: ST_TO_ADDR
105543: LD_INT 4
105545: PUSH
105546: FOR_TO
105547: IFFALSE 105568
// SetSkill ( i , j , 10 ) ;
105549: LD_VAR 0 2
105553: PPUSH
105554: LD_VAR 0 3
105558: PPUSH
105559: LD_INT 10
105561: PPUSH
105562: CALL_OW 237
105566: GO 105546
105568: POP
105569: POP
// end ;
105570: GO 105519
105572: POP
105573: POP
// end ;
105574: LD_VAR 0 1
105578: RET
// export function hHackSetLevel10YourUnits ; var i , j ; begin
105579: LD_INT 0
105581: PPUSH
105582: PPUSH
105583: PPUSH
// for i in FilterAllUnits ( [ [ f_side , your_side ] , [ f_type , unit_human ] ] ) do
105584: LD_ADDR_VAR 0 2
105588: PUSH
105589: LD_INT 22
105591: PUSH
105592: LD_OWVAR 2
105596: PUSH
105597: EMPTY
105598: LIST
105599: LIST
105600: PUSH
105601: LD_INT 21
105603: PUSH
105604: LD_INT 1
105606: PUSH
105607: EMPTY
105608: LIST
105609: LIST
105610: PUSH
105611: EMPTY
105612: LIST
105613: LIST
105614: PPUSH
105615: CALL_OW 69
105619: PUSH
105620: FOR_IN
105621: IFFALSE 105662
// begin for j := 1 to 4 do
105623: LD_ADDR_VAR 0 3
105627: PUSH
105628: DOUBLE
105629: LD_INT 1
105631: DEC
105632: ST_TO_ADDR
105633: LD_INT 4
105635: PUSH
105636: FOR_TO
105637: IFFALSE 105658
// SetSkill ( i , j , 10 ) ;
105639: LD_VAR 0 2
105643: PPUSH
105644: LD_VAR 0 3
105648: PPUSH
105649: LD_INT 10
105651: PPUSH
105652: CALL_OW 237
105656: GO 105636
105658: POP
105659: POP
// end ;
105660: GO 105620
105662: POP
105663: POP
// end ;
105664: LD_VAR 0 1
105668: RET
// export function hHackSpawnHuman ( nation , class , skill , x , y ) ; begin
105669: LD_INT 0
105671: PPUSH
// uc_side := your_side ;
105672: LD_ADDR_OWVAR 20
105676: PUSH
105677: LD_OWVAR 2
105681: ST_TO_ADDR
// uc_nation := nation ;
105682: LD_ADDR_OWVAR 21
105686: PUSH
105687: LD_VAR 0 1
105691: ST_TO_ADDR
// InitHc ;
105692: CALL_OW 19
// PrepareHuman ( false , class , skill ) ;
105696: LD_INT 0
105698: PPUSH
105699: LD_VAR 0 2
105703: PPUSH
105704: LD_VAR 0 3
105708: PPUSH
105709: CALL_OW 380
// if HexInfo ( x , y ) = 0 then
105713: LD_VAR 0 4
105717: PPUSH
105718: LD_VAR 0 5
105722: PPUSH
105723: CALL_OW 428
105727: PUSH
105728: LD_INT 0
105730: EQUAL
105731: IFFALSE 105755
// PlaceUnitXY ( CreateHuman , x , y , true ) ;
105733: CALL_OW 44
105737: PPUSH
105738: LD_VAR 0 4
105742: PPUSH
105743: LD_VAR 0 5
105747: PPUSH
105748: LD_INT 1
105750: PPUSH
105751: CALL_OW 48
// end ;
105755: LD_VAR 0 6
105759: RET
// export function hHackSpawnVehicle ( chassis , engine , control , weapon , x , y ) ; var un ; begin
105760: LD_INT 0
105762: PPUSH
105763: PPUSH
// uc_side := your_side ;
105764: LD_ADDR_OWVAR 20
105768: PUSH
105769: LD_OWVAR 2
105773: ST_TO_ADDR
// if chassis in [ 1 , 2 , 3 , 4 , 5 ] then
105774: LD_VAR 0 1
105778: PUSH
105779: LD_INT 1
105781: PUSH
105782: LD_INT 2
105784: PUSH
105785: LD_INT 3
105787: PUSH
105788: LD_INT 4
105790: PUSH
105791: LD_INT 5
105793: PUSH
105794: EMPTY
105795: LIST
105796: LIST
105797: LIST
105798: LIST
105799: LIST
105800: IN
105801: IFFALSE 105813
// uc_nation := nation_american else
105803: LD_ADDR_OWVAR 21
105807: PUSH
105808: LD_INT 1
105810: ST_TO_ADDR
105811: GO 105856
// if chassis in [ 11 , 12 , 13 , 14 ] then
105813: LD_VAR 0 1
105817: PUSH
105818: LD_INT 11
105820: PUSH
105821: LD_INT 12
105823: PUSH
105824: LD_INT 13
105826: PUSH
105827: LD_INT 14
105829: PUSH
105830: EMPTY
105831: LIST
105832: LIST
105833: LIST
105834: LIST
105835: IN
105836: IFFALSE 105848
// uc_nation := nation_arabian else
105838: LD_ADDR_OWVAR 21
105842: PUSH
105843: LD_INT 2
105845: ST_TO_ADDR
105846: GO 105856
// uc_nation := nation_russian ;
105848: LD_ADDR_OWVAR 21
105852: PUSH
105853: LD_INT 3
105855: ST_TO_ADDR
// vc_chassis := chassis ;
105856: LD_ADDR_OWVAR 37
105860: PUSH
105861: LD_VAR 0 1
105865: ST_TO_ADDR
// vc_engine := engine ;
105866: LD_ADDR_OWVAR 39
105870: PUSH
105871: LD_VAR 0 2
105875: ST_TO_ADDR
// vc_control := control ;
105876: LD_ADDR_OWVAR 38
105880: PUSH
105881: LD_VAR 0 3
105885: ST_TO_ADDR
// vc_weapon := weapon ;
105886: LD_ADDR_OWVAR 40
105890: PUSH
105891: LD_VAR 0 4
105895: ST_TO_ADDR
// un := CreateVehicle ;
105896: LD_ADDR_VAR 0 8
105900: PUSH
105901: CALL_OW 45
105905: ST_TO_ADDR
// SetDir ( un , rand ( 0 , 5 ) ) ;
105906: LD_VAR 0 8
105910: PPUSH
105911: LD_INT 0
105913: PPUSH
105914: LD_INT 5
105916: PPUSH
105917: CALL_OW 12
105921: PPUSH
105922: CALL_OW 233
// PlaceUnitXY ( un , x , y , true ) ;
105926: LD_VAR 0 8
105930: PPUSH
105931: LD_VAR 0 5
105935: PPUSH
105936: LD_VAR 0 6
105940: PPUSH
105941: LD_INT 1
105943: PPUSH
105944: CALL_OW 48
// end ;
105948: LD_VAR 0 7
105952: RET
// export hInvincible ; every 1 do
105953: GO 105955
105955: DISABLE
// hInvincible := [ ] ;
105956: LD_ADDR_EXP 196
105960: PUSH
105961: EMPTY
105962: ST_TO_ADDR
105963: END
// every 10 do var i ;
105964: GO 105966
105966: DISABLE
105967: LD_INT 0
105969: PPUSH
// begin enable ;
105970: ENABLE
// if not hInvincible then
105971: LD_EXP 196
105975: NOT
105976: IFFALSE 105980
// exit ;
105978: GO 106024
// for i in hInvincible do
105980: LD_ADDR_VAR 0 1
105984: PUSH
105985: LD_EXP 196
105989: PUSH
105990: FOR_IN
105991: IFFALSE 106022
// if GetLives ( i ) < 1000 then
105993: LD_VAR 0 1
105997: PPUSH
105998: CALL_OW 256
106002: PUSH
106003: LD_INT 1000
106005: LESS
106006: IFFALSE 106020
// SetLives ( i , 1000 ) ;
106008: LD_VAR 0 1
106012: PPUSH
106013: LD_INT 1000
106015: PPUSH
106016: CALL_OW 234
106020: GO 105990
106022: POP
106023: POP
// end ;
106024: PPOPN 1
106026: END
// export function hHackInvincible ; var i ; begin
106027: LD_INT 0
106029: PPUSH
106030: PPUSH
// for i in FilterAllUnits ( [ f_or , [ f_type , unit_human ] , [ f_type , unit_vehicle ] ] ) do
106031: LD_ADDR_VAR 0 2
106035: PUSH
106036: LD_INT 2
106038: PUSH
106039: LD_INT 21
106041: PUSH
106042: LD_INT 1
106044: PUSH
106045: EMPTY
106046: LIST
106047: LIST
106048: PUSH
106049: LD_INT 21
106051: PUSH
106052: LD_INT 2
106054: PUSH
106055: EMPTY
106056: LIST
106057: LIST
106058: PUSH
106059: EMPTY
106060: LIST
106061: LIST
106062: LIST
106063: PPUSH
106064: CALL_OW 69
106068: PUSH
106069: FOR_IN
106070: IFFALSE 106131
// if IsSelected ( i ) then
106072: LD_VAR 0 2
106076: PPUSH
106077: CALL_OW 306
106081: IFFALSE 106129
// begin if i in hInvincible then
106083: LD_VAR 0 2
106087: PUSH
106088: LD_EXP 196
106092: IN
106093: IFFALSE 106113
// hInvincible := hInvincible diff i else
106095: LD_ADDR_EXP 196
106099: PUSH
106100: LD_EXP 196
106104: PUSH
106105: LD_VAR 0 2
106109: DIFF
106110: ST_TO_ADDR
106111: GO 106129
// hInvincible := hInvincible union i ;
106113: LD_ADDR_EXP 196
106117: PUSH
106118: LD_EXP 196
106122: PUSH
106123: LD_VAR 0 2
106127: UNION
106128: ST_TO_ADDR
// end ;
106129: GO 106069
106131: POP
106132: POP
// end ;
106133: LD_VAR 0 1
106137: RET
// export function hHackInvisible ; var i , j ; begin
106138: LD_INT 0
106140: PPUSH
106141: PPUSH
106142: PPUSH
// for i in FilterAllUnits ( [ f_type , unit_human ] ) do
106143: LD_ADDR_VAR 0 2
106147: PUSH
106148: LD_INT 21
106150: PUSH
106151: LD_INT 1
106153: PUSH
106154: EMPTY
106155: LIST
106156: LIST
106157: PPUSH
106158: CALL_OW 69
106162: PUSH
106163: FOR_IN
106164: IFFALSE 106188
// if IsSelected ( i ) then
106166: LD_VAR 0 2
106170: PPUSH
106171: CALL_OW 306
106175: IFFALSE 106186
// ComForceInvisible ( i ) ;
106177: LD_VAR 0 2
106181: PPUSH
106182: CALL_OW 496
106186: GO 106163
106188: POP
106189: POP
// end ;
106190: LD_VAR 0 1
106194: RET
// export function hHackChangeYourSide ; begin
106195: LD_INT 0
106197: PPUSH
// if your_side = 8 then
106198: LD_OWVAR 2
106202: PUSH
106203: LD_INT 8
106205: EQUAL
106206: IFFALSE 106218
// your_side := 0 else
106208: LD_ADDR_OWVAR 2
106212: PUSH
106213: LD_INT 0
106215: ST_TO_ADDR
106216: GO 106232
// your_side := your_side + 1 ;
106218: LD_ADDR_OWVAR 2
106222: PUSH
106223: LD_OWVAR 2
106227: PUSH
106228: LD_INT 1
106230: PLUS
106231: ST_TO_ADDR
// end ;
106232: LD_VAR 0 1
106236: RET
// export function hHackChangeUnitSide ; var i , j ; begin
106237: LD_INT 0
106239: PPUSH
106240: PPUSH
106241: PPUSH
// for i in all_units do
106242: LD_ADDR_VAR 0 2
106246: PUSH
106247: LD_OWVAR 3
106251: PUSH
106252: FOR_IN
106253: IFFALSE 106331
// if IsSelected ( i ) then
106255: LD_VAR 0 2
106259: PPUSH
106260: CALL_OW 306
106264: IFFALSE 106329
// begin j := GetSide ( i ) ;
106266: LD_ADDR_VAR 0 3
106270: PUSH
106271: LD_VAR 0 2
106275: PPUSH
106276: CALL_OW 255
106280: ST_TO_ADDR
// if j = 8 then
106281: LD_VAR 0 3
106285: PUSH
106286: LD_INT 8
106288: EQUAL
106289: IFFALSE 106301
// j := 0 else
106291: LD_ADDR_VAR 0 3
106295: PUSH
106296: LD_INT 0
106298: ST_TO_ADDR
106299: GO 106315
// j := j + 1 ;
106301: LD_ADDR_VAR 0 3
106305: PUSH
106306: LD_VAR 0 3
106310: PUSH
106311: LD_INT 1
106313: PLUS
106314: ST_TO_ADDR
// SetSide ( i , j ) ;
106315: LD_VAR 0 2
106319: PPUSH
106320: LD_VAR 0 3
106324: PPUSH
106325: CALL_OW 235
// end ;
106329: GO 106252
106331: POP
106332: POP
// end ;
106333: LD_VAR 0 1
106337: RET
// export function hHackFog ; begin
106338: LD_INT 0
106340: PPUSH
// FogOff ( true ) ;
106341: LD_INT 1
106343: PPUSH
106344: CALL_OW 344
// end ;
106348: LD_VAR 0 1
106352: RET
// export function hHackTeleport ( unit , x , y ) ; begin
106353: LD_INT 0
106355: PPUSH
// TeleportUnit ( unit , x , y , 1 , true ) ;
106356: LD_VAR 0 1
106360: PPUSH
106361: LD_VAR 0 2
106365: PPUSH
106366: LD_VAR 0 3
106370: PPUSH
106371: LD_INT 1
106373: PPUSH
106374: LD_INT 1
106376: PPUSH
106377: CALL_OW 483
// CenterOnXY ( x , y ) ;
106381: LD_VAR 0 2
106385: PPUSH
106386: LD_VAR 0 3
106390: PPUSH
106391: CALL_OW 84
// end ; end_of_file
106395: LD_VAR 0 4
106399: RET
// export function SOS_UnitDestroyed ( un ) ; var i , eff , side ; begin
106400: LD_INT 0
106402: PPUSH
106403: PPUSH
106404: PPUSH
106405: PPUSH
// if GetWeapon ( un ) = ar_bio_bomb then
106406: LD_VAR 0 1
106410: PPUSH
106411: CALL_OW 264
106415: PUSH
106416: LD_EXP 78
106420: EQUAL
106421: IFFALSE 106493
// begin if GetTech ( tech_bio3 , GetSide ( un ) ) = state_researched then
106423: LD_INT 68
106425: PPUSH
106426: LD_VAR 0 1
106430: PPUSH
106431: CALL_OW 255
106435: PPUSH
106436: CALL_OW 321
106440: PUSH
106441: LD_INT 2
106443: EQUAL
106444: IFFALSE 106456
// eff := 70 else
106446: LD_ADDR_VAR 0 4
106450: PUSH
106451: LD_INT 70
106453: ST_TO_ADDR
106454: GO 106464
// eff := 30 ;
106456: LD_ADDR_VAR 0 4
106460: PUSH
106461: LD_INT 30
106463: ST_TO_ADDR
// ArtContamination ( GetX ( un ) , GetY ( un ) , eff ) ;
106464: LD_VAR 0 1
106468: PPUSH
106469: CALL_OW 250
106473: PPUSH
106474: LD_VAR 0 1
106478: PPUSH
106479: CALL_OW 251
106483: PPUSH
106484: LD_VAR 0 4
106488: PPUSH
106489: CALL_OW 495
// end ; end ;
106493: LD_VAR 0 2
106497: RET
// export function SOS_UnitExtraDestroyed ( un , killerSide , killerUnit ) ; begin
106498: LD_INT 0
106500: PPUSH
// end ;
106501: LD_VAR 0 4
106505: RET
// export function SOS_Command ( cmd ) ; begin
106506: LD_INT 0
106508: PPUSH
// end ;
106509: LD_VAR 0 2
106513: RET
// export function SOS_CommandUnitXY ( cmd , un , target , x , y ) ; begin
106514: LD_INT 0
106516: PPUSH
// end ;
106517: LD_VAR 0 6
106521: RET
// export function SOS_VehicleConstructed ( vehicle , factory ) ; var driver ; begin
106522: LD_INT 0
106524: PPUSH
106525: PPUSH
// if not vehicle or not factory then
106526: LD_VAR 0 1
106530: NOT
106531: PUSH
106532: LD_VAR 0 2
106536: NOT
106537: OR
106538: IFFALSE 106542
// exit ;
106540: GO 106773
// if factoryWaypoints >= factory then
106542: LD_EXP 197
106546: PUSH
106547: LD_VAR 0 2
106551: GREATEREQUAL
106552: IFFALSE 106773
// if factoryWaypoints [ factory ] then
106554: LD_EXP 197
106558: PUSH
106559: LD_VAR 0 2
106563: ARRAY
106564: IFFALSE 106773
// begin if GetControl ( vehicle ) = control_manual then
106566: LD_VAR 0 1
106570: PPUSH
106571: CALL_OW 263
106575: PUSH
106576: LD_INT 1
106578: EQUAL
106579: IFFALSE 106660
// begin driver := IsDrivenBy ( vehicle ) ;
106581: LD_ADDR_VAR 0 4
106585: PUSH
106586: LD_VAR 0 1
106590: PPUSH
106591: CALL_OW 311
106595: ST_TO_ADDR
// AddComMoveXY ( driver , factoryWaypoints [ factory ] [ 3 ] , factoryWaypoints [ factory ] [ 4 ] ) ;
106596: LD_VAR 0 4
106600: PPUSH
106601: LD_EXP 197
106605: PUSH
106606: LD_VAR 0 2
106610: ARRAY
106611: PUSH
106612: LD_INT 3
106614: ARRAY
106615: PPUSH
106616: LD_EXP 197
106620: PUSH
106621: LD_VAR 0 2
106625: ARRAY
106626: PUSH
106627: LD_INT 4
106629: ARRAY
106630: PPUSH
106631: CALL_OW 171
// AddComExitVehicle ( driver ) ;
106635: LD_VAR 0 4
106639: PPUSH
106640: CALL_OW 181
// AddComEnterUnit ( driver , factory ) ;
106644: LD_VAR 0 4
106648: PPUSH
106649: LD_VAR 0 2
106653: PPUSH
106654: CALL_OW 180
// end else
106658: GO 106773
// if GetControl ( vehicle ) = control_remote then
106660: LD_VAR 0 1
106664: PPUSH
106665: CALL_OW 263
106669: PUSH
106670: LD_INT 2
106672: EQUAL
106673: IFFALSE 106734
// begin wait ( 0 0$2 ) ;
106675: LD_INT 70
106677: PPUSH
106678: CALL_OW 67
// if Connect ( vehicle ) then
106682: LD_VAR 0 1
106686: PPUSH
106687: CALL 59988 0 1
106691: IFFALSE 106732
// AddComMoveXY ( vehicle , factoryWaypoints [ factory ] [ 3 ] , factoryWaypoints [ factory ] [ 4 ] ) ;
106693: LD_VAR 0 1
106697: PPUSH
106698: LD_EXP 197
106702: PUSH
106703: LD_VAR 0 2
106707: ARRAY
106708: PUSH
106709: LD_INT 3
106711: ARRAY
106712: PPUSH
106713: LD_EXP 197
106717: PUSH
106718: LD_VAR 0 2
106722: ARRAY
106723: PUSH
106724: LD_INT 4
106726: ARRAY
106727: PPUSH
106728: CALL_OW 171
// end else
106732: GO 106773
// AddComMoveXY ( vehicle , factoryWaypoints [ factory ] [ 3 ] , factoryWaypoints [ factory ] [ 4 ] ) ;
106734: LD_VAR 0 1
106738: PPUSH
106739: LD_EXP 197
106743: PUSH
106744: LD_VAR 0 2
106748: ARRAY
106749: PUSH
106750: LD_INT 3
106752: ARRAY
106753: PPUSH
106754: LD_EXP 197
106758: PUSH
106759: LD_VAR 0 2
106763: ARRAY
106764: PUSH
106765: LD_INT 4
106767: ARRAY
106768: PPUSH
106769: CALL_OW 171
// end ; end ;
106773: LD_VAR 0 3
106777: RET
// export function SOS_TargetableSAIL ( cmd , unit , selectedUnit , x , y ) ; begin
106778: LD_INT 0
106780: PPUSH
// if cmd = 250 and GetWeapon ( unit ) = ar_miner then
106781: LD_VAR 0 1
106785: PUSH
106786: LD_INT 250
106788: EQUAL
106789: PUSH
106790: LD_VAR 0 2
106794: PPUSH
106795: CALL_OW 264
106799: PUSH
106800: LD_EXP 81
106804: EQUAL
106805: AND
106806: IFFALSE 106827
// MinerPlaceMine ( unit , x , y ) ;
106808: LD_VAR 0 2
106812: PPUSH
106813: LD_VAR 0 4
106817: PPUSH
106818: LD_VAR 0 5
106822: PPUSH
106823: CALL 109555 0 3
// if cmd = 251 and GetWeapon ( unit ) = ar_miner then
106827: LD_VAR 0 1
106831: PUSH
106832: LD_INT 251
106834: EQUAL
106835: PUSH
106836: LD_VAR 0 2
106840: PPUSH
106841: CALL_OW 264
106845: PUSH
106846: LD_EXP 81
106850: EQUAL
106851: AND
106852: IFFALSE 106873
// MinerDetonateMine ( unit , x , y ) ;
106854: LD_VAR 0 2
106858: PPUSH
106859: LD_VAR 0 4
106863: PPUSH
106864: LD_VAR 0 5
106868: PPUSH
106869: CALL 109832 0 3
// if cmd = 252 and GetWeapon ( unit ) = ar_miner then
106873: LD_VAR 0 1
106877: PUSH
106878: LD_INT 252
106880: EQUAL
106881: PUSH
106882: LD_VAR 0 2
106886: PPUSH
106887: CALL_OW 264
106891: PUSH
106892: LD_EXP 81
106896: EQUAL
106897: AND
106898: IFFALSE 106919
// MinerCreateMinefield ( unit , x , y ) ;
106900: LD_VAR 0 2
106904: PPUSH
106905: LD_VAR 0 4
106909: PPUSH
106910: LD_VAR 0 5
106914: PPUSH
106915: CALL 110249 0 3
// if cmd = 253 and GetClass ( unit ) = class_sniper then
106919: LD_VAR 0 1
106923: PUSH
106924: LD_INT 253
106926: EQUAL
106927: PUSH
106928: LD_VAR 0 2
106932: PPUSH
106933: CALL_OW 257
106937: PUSH
106938: LD_INT 5
106940: EQUAL
106941: AND
106942: IFFALSE 106963
// ComBinocular ( unit , x , y ) ;
106944: LD_VAR 0 2
106948: PPUSH
106949: LD_VAR 0 4
106953: PPUSH
106954: LD_VAR 0 5
106958: PPUSH
106959: CALL 110620 0 3
// if cmd = 254 and GetWeapon ( unit ) = us_hack and GetControl ( selectedUnit ) = control_computer then
106963: LD_VAR 0 1
106967: PUSH
106968: LD_INT 254
106970: EQUAL
106971: PUSH
106972: LD_VAR 0 2
106976: PPUSH
106977: CALL_OW 264
106981: PUSH
106982: LD_EXP 76
106986: EQUAL
106987: AND
106988: PUSH
106989: LD_VAR 0 3
106993: PPUSH
106994: CALL_OW 263
106998: PUSH
106999: LD_INT 3
107001: EQUAL
107002: AND
107003: IFFALSE 107019
// HackDestroyVehicle ( unit , selectedUnit ) ;
107005: LD_VAR 0 2
107009: PPUSH
107010: LD_VAR 0 3
107014: PPUSH
107015: CALL 108915 0 2
// if cmd = 255 and GetWeapon ( unit ) in [ us_bulldozer , ru_bulldozer ] and ValidHex ( x , y ) then
107019: LD_VAR 0 1
107023: PUSH
107024: LD_INT 255
107026: EQUAL
107027: PUSH
107028: LD_VAR 0 2
107032: PPUSH
107033: CALL_OW 264
107037: PUSH
107038: LD_INT 14
107040: PUSH
107041: LD_INT 53
107043: PUSH
107044: EMPTY
107045: LIST
107046: LIST
107047: IN
107048: AND
107049: PUSH
107050: LD_VAR 0 4
107054: PPUSH
107055: LD_VAR 0 5
107059: PPUSH
107060: CALL_OW 488
107064: AND
107065: IFFALSE 107089
// CutTreeXYR ( unit , x , y , 12 ) ;
107067: LD_VAR 0 2
107071: PPUSH
107072: LD_VAR 0 4
107076: PPUSH
107077: LD_VAR 0 5
107081: PPUSH
107082: LD_INT 12
107084: PPUSH
107085: CALL 107481 0 4
// if cmd = 256 then
107089: LD_VAR 0 1
107093: PUSH
107094: LD_INT 256
107096: EQUAL
107097: IFFALSE 107118
// SetFactoryWaypoint ( unit , x , y ) ;
107099: LD_VAR 0 2
107103: PPUSH
107104: LD_VAR 0 4
107108: PPUSH
107109: LD_VAR 0 5
107113: PPUSH
107114: CALL 107123 0 3
// end ;
107118: LD_VAR 0 6
107122: RET
// export factoryWaypoints ; export function SetFactoryWaypoint ( factory , x , y ) ; var i ; begin
107123: LD_INT 0
107125: PPUSH
107126: PPUSH
// if not factory or not ValidHex ( x , y ) or ( GetBType ( factory ) <> b_factory and not GetType ( factory ) = unit_human ) then
107127: LD_VAR 0 1
107131: NOT
107132: PUSH
107133: LD_VAR 0 2
107137: PPUSH
107138: LD_VAR 0 3
107142: PPUSH
107143: CALL_OW 488
107147: NOT
107148: OR
107149: PUSH
107150: LD_VAR 0 1
107154: PPUSH
107155: CALL_OW 266
107159: PUSH
107160: LD_INT 3
107162: NONEQUAL
107163: PUSH
107164: LD_VAR 0 1
107168: PPUSH
107169: CALL_OW 247
107173: PUSH
107174: LD_INT 1
107176: EQUAL
107177: NOT
107178: AND
107179: OR
107180: IFFALSE 107184
// exit ;
107182: GO 107333
// if GetType ( factory ) = unit_human then
107184: LD_VAR 0 1
107188: PPUSH
107189: CALL_OW 247
107193: PUSH
107194: LD_INT 1
107196: EQUAL
107197: IFFALSE 107214
// factory := IsInUnit ( factory ) ;
107199: LD_ADDR_VAR 0 1
107203: PUSH
107204: LD_VAR 0 1
107208: PPUSH
107209: CALL_OW 310
107213: ST_TO_ADDR
// if GetBType ( factory ) <> b_factory then
107214: LD_VAR 0 1
107218: PPUSH
107219: CALL_OW 266
107223: PUSH
107224: LD_INT 3
107226: NONEQUAL
107227: IFFALSE 107231
// exit ;
107229: GO 107333
// if HexInfo ( x , y ) = factory then
107231: LD_VAR 0 2
107235: PPUSH
107236: LD_VAR 0 3
107240: PPUSH
107241: CALL_OW 428
107245: PUSH
107246: LD_VAR 0 1
107250: EQUAL
107251: IFFALSE 107278
// factoryWaypoints := Replace ( factoryWaypoints , factory , 0 ) else
107253: LD_ADDR_EXP 197
107257: PUSH
107258: LD_EXP 197
107262: PPUSH
107263: LD_VAR 0 1
107267: PPUSH
107268: LD_INT 0
107270: PPUSH
107271: CALL_OW 1
107275: ST_TO_ADDR
107276: GO 107329
// factoryWaypoints := Replace ( factoryWaypoints , factory , [ GetSide ( factory ) , factory , x , y ] ) ;
107278: LD_ADDR_EXP 197
107282: PUSH
107283: LD_EXP 197
107287: PPUSH
107288: LD_VAR 0 1
107292: PPUSH
107293: LD_VAR 0 1
107297: PPUSH
107298: CALL_OW 255
107302: PUSH
107303: LD_VAR 0 1
107307: PUSH
107308: LD_VAR 0 2
107312: PUSH
107313: LD_VAR 0 3
107317: PUSH
107318: EMPTY
107319: LIST
107320: LIST
107321: LIST
107322: LIST
107323: PPUSH
107324: CALL_OW 1
107328: ST_TO_ADDR
// UpdateFactoryWaypoints ;
107329: CALL 107338 0 0
// end ;
107333: LD_VAR 0 4
107337: RET
// export function UpdateFactoryWaypoints ( ) ; var i ; begin
107338: LD_INT 0
107340: PPUSH
107341: PPUSH
// ToLua ( resetFactoryWaypoint(); ) ;
107342: LD_STRING resetFactoryWaypoint();
107344: PPUSH
107345: CALL_OW 559
// if factoryWaypoints then
107349: LD_EXP 197
107353: IFFALSE 107476
// begin for i := 1 to factoryWaypoints do
107355: LD_ADDR_VAR 0 2
107359: PUSH
107360: DOUBLE
107361: LD_INT 1
107363: DEC
107364: ST_TO_ADDR
107365: LD_EXP 197
107369: PUSH
107370: FOR_TO
107371: IFFALSE 107474
// if factoryWaypoints [ i ] then
107373: LD_EXP 197
107377: PUSH
107378: LD_VAR 0 2
107382: ARRAY
107383: IFFALSE 107472
// ToLua ( setFactoryWaypointXY( & factoryWaypoints [ i ] [ 1 ] & , & factoryWaypoints [ i ] [ 2 ] & , & factoryWaypoints [ i ] [ 3 ] & , & factoryWaypoints [ i ] [ 4 ] & ) ) ;
107385: LD_STRING setFactoryWaypointXY(
107387: PUSH
107388: LD_EXP 197
107392: PUSH
107393: LD_VAR 0 2
107397: ARRAY
107398: PUSH
107399: LD_INT 1
107401: ARRAY
107402: STR
107403: PUSH
107404: LD_STRING ,
107406: STR
107407: PUSH
107408: LD_EXP 197
107412: PUSH
107413: LD_VAR 0 2
107417: ARRAY
107418: PUSH
107419: LD_INT 2
107421: ARRAY
107422: STR
107423: PUSH
107424: LD_STRING ,
107426: STR
107427: PUSH
107428: LD_EXP 197
107432: PUSH
107433: LD_VAR 0 2
107437: ARRAY
107438: PUSH
107439: LD_INT 3
107441: ARRAY
107442: STR
107443: PUSH
107444: LD_STRING ,
107446: STR
107447: PUSH
107448: LD_EXP 197
107452: PUSH
107453: LD_VAR 0 2
107457: ARRAY
107458: PUSH
107459: LD_INT 4
107461: ARRAY
107462: STR
107463: PUSH
107464: LD_STRING )
107466: STR
107467: PPUSH
107468: CALL_OW 559
107472: GO 107370
107474: POP
107475: POP
// end ; end ;
107476: LD_VAR 0 1
107480: RET
// function CutTreeXYR ( bulldozer , x , y , r ) ; var i , min_x , min_y , max_x , max_y , _x , _y , list ; begin
107481: LD_INT 0
107483: PPUSH
107484: PPUSH
107485: PPUSH
107486: PPUSH
107487: PPUSH
107488: PPUSH
107489: PPUSH
107490: PPUSH
107491: PPUSH
// if not bulldozer or not ValidHex ( x , y ) or not r then
107492: LD_VAR 0 1
107496: NOT
107497: PUSH
107498: LD_VAR 0 2
107502: PPUSH
107503: LD_VAR 0 3
107507: PPUSH
107508: CALL_OW 488
107512: NOT
107513: OR
107514: PUSH
107515: LD_VAR 0 4
107519: NOT
107520: OR
107521: IFFALSE 107525
// exit ;
107523: GO 107865
// list := [ ] ;
107525: LD_ADDR_VAR 0 13
107529: PUSH
107530: EMPTY
107531: ST_TO_ADDR
// if x - r < 0 then
107532: LD_VAR 0 2
107536: PUSH
107537: LD_VAR 0 4
107541: MINUS
107542: PUSH
107543: LD_INT 0
107545: LESS
107546: IFFALSE 107558
// min_x := 0 else
107548: LD_ADDR_VAR 0 7
107552: PUSH
107553: LD_INT 0
107555: ST_TO_ADDR
107556: GO 107574
// min_x := x - r ;
107558: LD_ADDR_VAR 0 7
107562: PUSH
107563: LD_VAR 0 2
107567: PUSH
107568: LD_VAR 0 4
107572: MINUS
107573: ST_TO_ADDR
// if y - r < 0 then
107574: LD_VAR 0 3
107578: PUSH
107579: LD_VAR 0 4
107583: MINUS
107584: PUSH
107585: LD_INT 0
107587: LESS
107588: IFFALSE 107600
// min_y := 0 else
107590: LD_ADDR_VAR 0 8
107594: PUSH
107595: LD_INT 0
107597: ST_TO_ADDR
107598: GO 107616
// min_y := y - r ;
107600: LD_ADDR_VAR 0 8
107604: PUSH
107605: LD_VAR 0 3
107609: PUSH
107610: LD_VAR 0 4
107614: MINUS
107615: ST_TO_ADDR
// max_x := x + r ;
107616: LD_ADDR_VAR 0 9
107620: PUSH
107621: LD_VAR 0 2
107625: PUSH
107626: LD_VAR 0 4
107630: PLUS
107631: ST_TO_ADDR
// max_y := y + r ;
107632: LD_ADDR_VAR 0 10
107636: PUSH
107637: LD_VAR 0 3
107641: PUSH
107642: LD_VAR 0 4
107646: PLUS
107647: ST_TO_ADDR
// for _x = min_x to max_x do
107648: LD_ADDR_VAR 0 11
107652: PUSH
107653: DOUBLE
107654: LD_VAR 0 7
107658: DEC
107659: ST_TO_ADDR
107660: LD_VAR 0 9
107664: PUSH
107665: FOR_TO
107666: IFFALSE 107783
// for _y = min_y to max_y do
107668: LD_ADDR_VAR 0 12
107672: PUSH
107673: DOUBLE
107674: LD_VAR 0 8
107678: DEC
107679: ST_TO_ADDR
107680: LD_VAR 0 10
107684: PUSH
107685: FOR_TO
107686: IFFALSE 107779
// begin if not ValidHex ( _x , _y ) then
107688: LD_VAR 0 11
107692: PPUSH
107693: LD_VAR 0 12
107697: PPUSH
107698: CALL_OW 488
107702: NOT
107703: IFFALSE 107707
// continue ;
107705: GO 107685
// if IsEnvironment ( _x , _y ) and IsEnvironmentDestroyable ( _x , _y ) then
107707: LD_VAR 0 11
107711: PPUSH
107712: LD_VAR 0 12
107716: PPUSH
107717: CALL_OW 351
107721: PUSH
107722: LD_VAR 0 11
107726: PPUSH
107727: LD_VAR 0 12
107731: PPUSH
107732: CALL_OW 554
107736: AND
107737: IFFALSE 107777
// list := Insert ( list , list + 1 , [ _x , _y ] ) ;
107739: LD_ADDR_VAR 0 13
107743: PUSH
107744: LD_VAR 0 13
107748: PPUSH
107749: LD_VAR 0 13
107753: PUSH
107754: LD_INT 1
107756: PLUS
107757: PPUSH
107758: LD_VAR 0 11
107762: PUSH
107763: LD_VAR 0 12
107767: PUSH
107768: EMPTY
107769: LIST
107770: LIST
107771: PPUSH
107772: CALL_OW 2
107776: ST_TO_ADDR
// end ;
107777: GO 107685
107779: POP
107780: POP
107781: GO 107665
107783: POP
107784: POP
// if not list then
107785: LD_VAR 0 13
107789: NOT
107790: IFFALSE 107794
// exit ;
107792: GO 107865
// for i in list do
107794: LD_ADDR_VAR 0 6
107798: PUSH
107799: LD_VAR 0 13
107803: PUSH
107804: FOR_IN
107805: IFFALSE 107863
// AddTaskList ( bulldozer , [ [ M , i [ 1 ] , i [ 2 ] , 0 , 0 , 0 , 0 ] ] ) ;
107807: LD_VAR 0 1
107811: PPUSH
107812: LD_STRING M
107814: PUSH
107815: LD_VAR 0 6
107819: PUSH
107820: LD_INT 1
107822: ARRAY
107823: PUSH
107824: LD_VAR 0 6
107828: PUSH
107829: LD_INT 2
107831: ARRAY
107832: PUSH
107833: LD_INT 0
107835: PUSH
107836: LD_INT 0
107838: PUSH
107839: LD_INT 0
107841: PUSH
107842: LD_INT 0
107844: PUSH
107845: EMPTY
107846: LIST
107847: LIST
107848: LIST
107849: LIST
107850: LIST
107851: LIST
107852: LIST
107853: PUSH
107854: EMPTY
107855: LIST
107856: PPUSH
107857: CALL_OW 447
107861: GO 107804
107863: POP
107864: POP
// end ;
107865: LD_VAR 0 5
107869: RET
// export initHack , hackTanks , hackTanksCaptured , hackLimit , hackDist , hackCounter ; every 0 0$1 trigger not initHack do
107870: LD_EXP 198
107874: NOT
107875: IFFALSE 107925
107877: GO 107879
107879: DISABLE
// begin initHack := true ;
107880: LD_ADDR_EXP 198
107884: PUSH
107885: LD_INT 1
107887: ST_TO_ADDR
// hackTanks := [ ] ;
107888: LD_ADDR_EXP 199
107892: PUSH
107893: EMPTY
107894: ST_TO_ADDR
// hackTanksCaptured := [ ] ;
107895: LD_ADDR_EXP 200
107899: PUSH
107900: EMPTY
107901: ST_TO_ADDR
// hackLimit := 3 ;
107902: LD_ADDR_EXP 201
107906: PUSH
107907: LD_INT 3
107909: ST_TO_ADDR
// hackDist := 12 ;
107910: LD_ADDR_EXP 202
107914: PUSH
107915: LD_INT 12
107917: ST_TO_ADDR
// hackCounter := [ ] ;
107918: LD_ADDR_EXP 203
107922: PUSH
107923: EMPTY
107924: ST_TO_ADDR
// end ;
107925: END
// every 0 0$1 trigger initHack and FilterAllUnits ( [ f_weapon , us_hack ] ) do var i , tmp ;
107926: LD_EXP 198
107930: PUSH
107931: LD_INT 34
107933: PUSH
107934: LD_EXP 76
107938: PUSH
107939: EMPTY
107940: LIST
107941: LIST
107942: PPUSH
107943: CALL_OW 69
107947: AND
107948: IFFALSE 108203
107950: GO 107952
107952: DISABLE
107953: LD_INT 0
107955: PPUSH
107956: PPUSH
// begin enable ;
107957: ENABLE
// for i in FilterAllUnits ( [ f_weapon , us_hack ] ) do
107958: LD_ADDR_VAR 0 1
107962: PUSH
107963: LD_INT 34
107965: PUSH
107966: LD_EXP 76
107970: PUSH
107971: EMPTY
107972: LIST
107973: LIST
107974: PPUSH
107975: CALL_OW 69
107979: PUSH
107980: FOR_IN
107981: IFFALSE 108201
// begin if not i in hackTanks then
107983: LD_VAR 0 1
107987: PUSH
107988: LD_EXP 199
107992: IN
107993: NOT
107994: IFFALSE 108077
// begin hackTanks := Replace ( hackTanks , hackTanks + 1 , i ) ;
107996: LD_ADDR_EXP 199
108000: PUSH
108001: LD_EXP 199
108005: PPUSH
108006: LD_EXP 199
108010: PUSH
108011: LD_INT 1
108013: PLUS
108014: PPUSH
108015: LD_VAR 0 1
108019: PPUSH
108020: CALL_OW 1
108024: ST_TO_ADDR
// hackTanksCaptured := Replace ( hackTanksCaptured , hackTanksCaptured + 1 , [ ] ) ;
108025: LD_ADDR_EXP 200
108029: PUSH
108030: LD_EXP 200
108034: PPUSH
108035: LD_EXP 200
108039: PUSH
108040: LD_INT 1
108042: PLUS
108043: PPUSH
108044: EMPTY
108045: PPUSH
108046: CALL_OW 1
108050: ST_TO_ADDR
// hackCounter := Replace ( hackCounter , hackCounter + 1 , [ ] ) ;
108051: LD_ADDR_EXP 203
108055: PUSH
108056: LD_EXP 203
108060: PPUSH
108061: LD_EXP 203
108065: PUSH
108066: LD_INT 1
108068: PLUS
108069: PPUSH
108070: EMPTY
108071: PPUSH
108072: CALL_OW 1
108076: ST_TO_ADDR
// end ; if not IsOk ( i ) then
108077: LD_VAR 0 1
108081: PPUSH
108082: CALL_OW 302
108086: NOT
108087: IFFALSE 108100
// begin HackUnlinkAll ( i ) ;
108089: LD_VAR 0 1
108093: PPUSH
108094: CALL 108206 0 1
// continue ;
108098: GO 107980
// end ; HackCheckCapturedStatus ( i ) ;
108100: LD_VAR 0 1
108104: PPUSH
108105: CALL 108649 0 1
// tmp := FilterAllUnits ( [ [ f_enemy , GetSide ( i ) ] , [ f_control , control_computer ] , [ f_dist , i , hackDist ] , [ f_ok ] ] ) ;
108109: LD_ADDR_VAR 0 2
108113: PUSH
108114: LD_INT 81
108116: PUSH
108117: LD_VAR 0 1
108121: PPUSH
108122: CALL_OW 255
108126: PUSH
108127: EMPTY
108128: LIST
108129: LIST
108130: PUSH
108131: LD_INT 33
108133: PUSH
108134: LD_INT 3
108136: PUSH
108137: EMPTY
108138: LIST
108139: LIST
108140: PUSH
108141: LD_INT 91
108143: PUSH
108144: LD_VAR 0 1
108148: PUSH
108149: LD_EXP 202
108153: PUSH
108154: EMPTY
108155: LIST
108156: LIST
108157: LIST
108158: PUSH
108159: LD_INT 50
108161: PUSH
108162: EMPTY
108163: LIST
108164: PUSH
108165: EMPTY
108166: LIST
108167: LIST
108168: LIST
108169: LIST
108170: PPUSH
108171: CALL_OW 69
108175: ST_TO_ADDR
// if not tmp then
108176: LD_VAR 0 2
108180: NOT
108181: IFFALSE 108185
// continue ;
108183: GO 107980
// HackLink ( i , tmp ) ;
108185: LD_VAR 0 1
108189: PPUSH
108190: LD_VAR 0 2
108194: PPUSH
108195: CALL 108342 0 2
// end ;
108199: GO 107980
108201: POP
108202: POP
// end ;
108203: PPOPN 2
108205: END
// function HackUnlinkAll ( hack ) ; var i , index ; begin
108206: LD_INT 0
108208: PPUSH
108209: PPUSH
108210: PPUSH
// if not hack in hackTanks then
108211: LD_VAR 0 1
108215: PUSH
108216: LD_EXP 199
108220: IN
108221: NOT
108222: IFFALSE 108226
// exit ;
108224: GO 108337
// index := GetElementIndex ( hackTanks , hack ) ;
108226: LD_ADDR_VAR 0 4
108230: PUSH
108231: LD_EXP 199
108235: PPUSH
108236: LD_VAR 0 1
108240: PPUSH
108241: CALL 56802 0 2
108245: ST_TO_ADDR
// if hackTanksCaptured [ index ] then
108246: LD_EXP 200
108250: PUSH
108251: LD_VAR 0 4
108255: ARRAY
108256: IFFALSE 108337
// begin for i in hackTanksCaptured [ index ] do
108258: LD_ADDR_VAR 0 3
108262: PUSH
108263: LD_EXP 200
108267: PUSH
108268: LD_VAR 0 4
108272: ARRAY
108273: PUSH
108274: FOR_IN
108275: IFFALSE 108301
// SetSide ( i [ 1 ] , i [ 2 ] ) ;
108277: LD_VAR 0 3
108281: PUSH
108282: LD_INT 1
108284: ARRAY
108285: PPUSH
108286: LD_VAR 0 3
108290: PUSH
108291: LD_INT 2
108293: ARRAY
108294: PPUSH
108295: CALL_OW 235
108299: GO 108274
108301: POP
108302: POP
// hackTanksCaptured := Replace ( hackTanksCaptured , index , [ ] ) ;
108303: LD_ADDR_EXP 200
108307: PUSH
108308: LD_EXP 200
108312: PPUSH
108313: LD_VAR 0 4
108317: PPUSH
108318: EMPTY
108319: PPUSH
108320: CALL_OW 1
108324: ST_TO_ADDR
// SetUnitDisplayNumber ( hack , 0 ) ;
108325: LD_VAR 0 1
108329: PPUSH
108330: LD_INT 0
108332: PPUSH
108333: CALL_OW 505
// end ; end ;
108337: LD_VAR 0 2
108341: RET
// function HackLink ( hack , vehicles ) ; var i , index ; begin
108342: LD_INT 0
108344: PPUSH
108345: PPUSH
108346: PPUSH
// if not hack in hackTanks or not vehicles then
108347: LD_VAR 0 1
108351: PUSH
108352: LD_EXP 199
108356: IN
108357: NOT
108358: PUSH
108359: LD_VAR 0 2
108363: NOT
108364: OR
108365: IFFALSE 108369
// exit ;
108367: GO 108644
// vehicles := SortByDistanceUnit ( hack , vehicles , true , true ) ;
108369: LD_ADDR_VAR 0 2
108373: PUSH
108374: LD_VAR 0 1
108378: PPUSH
108379: LD_VAR 0 2
108383: PPUSH
108384: LD_INT 1
108386: PPUSH
108387: LD_INT 1
108389: PPUSH
108390: CALL 57452 0 4
108394: ST_TO_ADDR
// index := GetElementIndex ( hackTanks , hack ) ;
108395: LD_ADDR_VAR 0 5
108399: PUSH
108400: LD_EXP 199
108404: PPUSH
108405: LD_VAR 0 1
108409: PPUSH
108410: CALL 56802 0 2
108414: ST_TO_ADDR
// if hackTanksCaptured [ index ] < hackLimit then
108415: LD_EXP 200
108419: PUSH
108420: LD_VAR 0 5
108424: ARRAY
108425: PUSH
108426: LD_EXP 201
108430: LESS
108431: IFFALSE 108620
// begin for i := 1 to vehicles do
108433: LD_ADDR_VAR 0 4
108437: PUSH
108438: DOUBLE
108439: LD_INT 1
108441: DEC
108442: ST_TO_ADDR
108443: LD_VAR 0 2
108447: PUSH
108448: FOR_TO
108449: IFFALSE 108618
// begin if hackTanksCaptured [ index ] = hackLimit then
108451: LD_EXP 200
108455: PUSH
108456: LD_VAR 0 5
108460: ARRAY
108461: PUSH
108462: LD_EXP 201
108466: EQUAL
108467: IFFALSE 108471
// break ;
108469: GO 108618
// hackCounter := Replace ( hackCounter , index , hackCounter [ index ] + 1 ) ;
108471: LD_ADDR_EXP 203
108475: PUSH
108476: LD_EXP 203
108480: PPUSH
108481: LD_VAR 0 5
108485: PPUSH
108486: LD_EXP 203
108490: PUSH
108491: LD_VAR 0 5
108495: ARRAY
108496: PUSH
108497: LD_INT 1
108499: PLUS
108500: PPUSH
108501: CALL_OW 1
108505: ST_TO_ADDR
// hackTanksCaptured := ReplaceIn ( hackTanksCaptured , [ index , hackTanksCaptured [ index ] + 1 ] , [ vehicles [ i ] , GetSide ( vehicles [ i ] ) ] ) ;
108506: LD_ADDR_EXP 200
108510: PUSH
108511: LD_EXP 200
108515: PPUSH
108516: LD_VAR 0 5
108520: PUSH
108521: LD_EXP 200
108525: PUSH
108526: LD_VAR 0 5
108530: ARRAY
108531: PUSH
108532: LD_INT 1
108534: PLUS
108535: PUSH
108536: EMPTY
108537: LIST
108538: LIST
108539: PPUSH
108540: LD_VAR 0 2
108544: PUSH
108545: LD_VAR 0 4
108549: ARRAY
108550: PUSH
108551: LD_VAR 0 2
108555: PUSH
108556: LD_VAR 0 4
108560: ARRAY
108561: PPUSH
108562: CALL_OW 255
108566: PUSH
108567: EMPTY
108568: LIST
108569: LIST
108570: PPUSH
108571: CALL 57017 0 3
108575: ST_TO_ADDR
// SetSide ( vehicles [ i ] , GetSide ( hack ) ) ;
108576: LD_VAR 0 2
108580: PUSH
108581: LD_VAR 0 4
108585: ARRAY
108586: PPUSH
108587: LD_VAR 0 1
108591: PPUSH
108592: CALL_OW 255
108596: PPUSH
108597: CALL_OW 235
// ComStop ( vehicles [ i ] ) ;
108601: LD_VAR 0 2
108605: PUSH
108606: LD_VAR 0 4
108610: ARRAY
108611: PPUSH
108612: CALL_OW 141
// end ;
108616: GO 108448
108618: POP
108619: POP
// end ; SetUnitDisplayNumber ( hack , hackTanksCaptured [ index ] + 0 ) ;
108620: LD_VAR 0 1
108624: PPUSH
108625: LD_EXP 200
108629: PUSH
108630: LD_VAR 0 5
108634: ARRAY
108635: PUSH
108636: LD_INT 0
108638: PLUS
108639: PPUSH
108640: CALL_OW 505
// end ;
108644: LD_VAR 0 3
108648: RET
// function HackCheckCapturedStatus ( hack ) ; var i , index , tmp ; begin
108649: LD_INT 0
108651: PPUSH
108652: PPUSH
108653: PPUSH
108654: PPUSH
// if not hack in hackTanks then
108655: LD_VAR 0 1
108659: PUSH
108660: LD_EXP 199
108664: IN
108665: NOT
108666: IFFALSE 108670
// exit ;
108668: GO 108910
// index := GetElementIndex ( hackTanks , hack ) ;
108670: LD_ADDR_VAR 0 4
108674: PUSH
108675: LD_EXP 199
108679: PPUSH
108680: LD_VAR 0 1
108684: PPUSH
108685: CALL 56802 0 2
108689: ST_TO_ADDR
// for i := hackTanksCaptured [ index ] downto 1 do
108690: LD_ADDR_VAR 0 3
108694: PUSH
108695: DOUBLE
108696: LD_EXP 200
108700: PUSH
108701: LD_VAR 0 4
108705: ARRAY
108706: INC
108707: ST_TO_ADDR
108708: LD_INT 1
108710: PUSH
108711: FOR_DOWNTO
108712: IFFALSE 108884
// begin tmp := hackTanksCaptured [ index ] [ i ] ;
108714: LD_ADDR_VAR 0 5
108718: PUSH
108719: LD_EXP 200
108723: PUSH
108724: LD_VAR 0 4
108728: ARRAY
108729: PUSH
108730: LD_VAR 0 3
108734: ARRAY
108735: ST_TO_ADDR
// if not IsOk ( tmp [ 1 ] ) or GetSide ( tmp [ 1 ] ) <> GetSide ( hack ) then
108736: LD_VAR 0 5
108740: PUSH
108741: LD_INT 1
108743: ARRAY
108744: PPUSH
108745: CALL_OW 302
108749: NOT
108750: PUSH
108751: LD_VAR 0 5
108755: PUSH
108756: LD_INT 1
108758: ARRAY
108759: PPUSH
108760: CALL_OW 255
108764: PUSH
108765: LD_VAR 0 1
108769: PPUSH
108770: CALL_OW 255
108774: NONEQUAL
108775: OR
108776: IFFALSE 108882
// begin if IsPlaced ( tmp [ 1 ] ) and GetSide ( tmp [ 1 ] ) = GetSide ( hack ) then
108778: LD_VAR 0 5
108782: PUSH
108783: LD_INT 1
108785: ARRAY
108786: PPUSH
108787: CALL_OW 305
108791: PUSH
108792: LD_VAR 0 5
108796: PUSH
108797: LD_INT 1
108799: ARRAY
108800: PPUSH
108801: CALL_OW 255
108805: PUSH
108806: LD_VAR 0 1
108810: PPUSH
108811: CALL_OW 255
108815: EQUAL
108816: AND
108817: IFFALSE 108841
// SetSide ( tmp [ 1 ] , tmp [ 2 ] ) ;
108819: LD_VAR 0 5
108823: PUSH
108824: LD_INT 1
108826: ARRAY
108827: PPUSH
108828: LD_VAR 0 5
108832: PUSH
108833: LD_INT 2
108835: ARRAY
108836: PPUSH
108837: CALL_OW 235
// hackTanksCaptured := Replace ( hackTanksCaptured , index , Delete ( hackTanksCaptured [ index ] , i ) ) ;
108841: LD_ADDR_EXP 200
108845: PUSH
108846: LD_EXP 200
108850: PPUSH
108851: LD_VAR 0 4
108855: PPUSH
108856: LD_EXP 200
108860: PUSH
108861: LD_VAR 0 4
108865: ARRAY
108866: PPUSH
108867: LD_VAR 0 3
108871: PPUSH
108872: CALL_OW 3
108876: PPUSH
108877: CALL_OW 1
108881: ST_TO_ADDR
// end ; end ;
108882: GO 108711
108884: POP
108885: POP
// SetUnitDisplayNumber ( hack , hackTanksCaptured [ index ] + 0 ) ;
108886: LD_VAR 0 1
108890: PPUSH
108891: LD_EXP 200
108895: PUSH
108896: LD_VAR 0 4
108900: ARRAY
108901: PUSH
108902: LD_INT 0
108904: PLUS
108905: PPUSH
108906: CALL_OW 505
// end ;
108910: LD_VAR 0 2
108914: RET
// export function HackDestroyVehicle ( hack , vehicle ) ; var i , index , tmp ; begin
108915: LD_INT 0
108917: PPUSH
108918: PPUSH
108919: PPUSH
108920: PPUSH
// if not hack in hackTanks then
108921: LD_VAR 0 1
108925: PUSH
108926: LD_EXP 199
108930: IN
108931: NOT
108932: IFFALSE 108936
// exit ;
108934: GO 109021
// index := GetElementIndex ( hackTanks , hack ) ;
108936: LD_ADDR_VAR 0 5
108940: PUSH
108941: LD_EXP 199
108945: PPUSH
108946: LD_VAR 0 1
108950: PPUSH
108951: CALL 56802 0 2
108955: ST_TO_ADDR
// for i := 1 to hackTanksCaptured [ index ] do
108956: LD_ADDR_VAR 0 4
108960: PUSH
108961: DOUBLE
108962: LD_INT 1
108964: DEC
108965: ST_TO_ADDR
108966: LD_EXP 200
108970: PUSH
108971: LD_VAR 0 5
108975: ARRAY
108976: PUSH
108977: FOR_TO
108978: IFFALSE 109019
// if hackTanksCaptured [ index ] [ i ] [ 1 ] = vehicle then
108980: LD_EXP 200
108984: PUSH
108985: LD_VAR 0 5
108989: ARRAY
108990: PUSH
108991: LD_VAR 0 4
108995: ARRAY
108996: PUSH
108997: LD_INT 1
108999: ARRAY
109000: PUSH
109001: LD_VAR 0 2
109005: EQUAL
109006: IFFALSE 109017
// KillUnit ( vehicle ) ;
109008: LD_VAR 0 2
109012: PPUSH
109013: CALL_OW 66
109017: GO 108977
109019: POP
109020: POP
// end ;
109021: LD_VAR 0 3
109025: RET
// export initMiner , minersList , minerMinesList , minesLimitPerVehicle ; every 0 0$1 trigger not initMiner do
109026: LD_EXP 204
109030: NOT
109031: IFFALSE 109066
109033: GO 109035
109035: DISABLE
// begin initMiner := true ;
109036: LD_ADDR_EXP 204
109040: PUSH
109041: LD_INT 1
109043: ST_TO_ADDR
// minersList := [ ] ;
109044: LD_ADDR_EXP 205
109048: PUSH
109049: EMPTY
109050: ST_TO_ADDR
// minerMinesList := [ ] ;
109051: LD_ADDR_EXP 206
109055: PUSH
109056: EMPTY
109057: ST_TO_ADDR
// minesLimitPerVehicle := 5 ;
109058: LD_ADDR_EXP 207
109062: PUSH
109063: LD_INT 5
109065: ST_TO_ADDR
// end ;
109066: END
// every 0 0$1 trigger initMiner and FilterAllUnits ( [ f_weapon , ar_miner ] ) do var i , j , side , tmp ;
109067: LD_EXP 204
109071: PUSH
109072: LD_INT 34
109074: PUSH
109075: LD_EXP 81
109079: PUSH
109080: EMPTY
109081: LIST
109082: LIST
109083: PPUSH
109084: CALL_OW 69
109088: AND
109089: IFFALSE 109552
109091: GO 109093
109093: DISABLE
109094: LD_INT 0
109096: PPUSH
109097: PPUSH
109098: PPUSH
109099: PPUSH
// begin enable ;
109100: ENABLE
// for i in FilterAllUnits ( [ f_weapon , ar_miner ] ) do
109101: LD_ADDR_VAR 0 1
109105: PUSH
109106: LD_INT 34
109108: PUSH
109109: LD_EXP 81
109113: PUSH
109114: EMPTY
109115: LIST
109116: LIST
109117: PPUSH
109118: CALL_OW 69
109122: PUSH
109123: FOR_IN
109124: IFFALSE 109196
// begin if not i in minersList then
109126: LD_VAR 0 1
109130: PUSH
109131: LD_EXP 205
109135: IN
109136: NOT
109137: IFFALSE 109194
// begin minersList := Replace ( minersList , minersList + 1 , i ) ;
109139: LD_ADDR_EXP 205
109143: PUSH
109144: LD_EXP 205
109148: PPUSH
109149: LD_EXP 205
109153: PUSH
109154: LD_INT 1
109156: PLUS
109157: PPUSH
109158: LD_VAR 0 1
109162: PPUSH
109163: CALL_OW 1
109167: ST_TO_ADDR
// minerMinesList := Replace ( minerMinesList , minerMinesList + 1 , [ ] ) ;
109168: LD_ADDR_EXP 206
109172: PUSH
109173: LD_EXP 206
109177: PPUSH
109178: LD_EXP 206
109182: PUSH
109183: LD_INT 1
109185: PLUS
109186: PPUSH
109187: EMPTY
109188: PPUSH
109189: CALL_OW 1
109193: ST_TO_ADDR
// end end ;
109194: GO 109123
109196: POP
109197: POP
// for i := minerMinesList downto 1 do
109198: LD_ADDR_VAR 0 1
109202: PUSH
109203: DOUBLE
109204: LD_EXP 206
109208: INC
109209: ST_TO_ADDR
109210: LD_INT 1
109212: PUSH
109213: FOR_DOWNTO
109214: IFFALSE 109550
// begin if IsLive ( minersList [ i ] ) then
109216: LD_EXP 205
109220: PUSH
109221: LD_VAR 0 1
109225: ARRAY
109226: PPUSH
109227: CALL_OW 300
109231: IFFALSE 109259
// SetUnitDisplayNumber ( minersList [ i ] , minerMinesList [ i ] ) ;
109233: LD_EXP 205
109237: PUSH
109238: LD_VAR 0 1
109242: ARRAY
109243: PPUSH
109244: LD_EXP 206
109248: PUSH
109249: LD_VAR 0 1
109253: ARRAY
109254: PPUSH
109255: CALL_OW 505
// if not minerMinesList [ i ] then
109259: LD_EXP 206
109263: PUSH
109264: LD_VAR 0 1
109268: ARRAY
109269: NOT
109270: IFFALSE 109274
// continue ;
109272: GO 109213
// for j := minerMinesList [ i ] downto 1 do
109274: LD_ADDR_VAR 0 2
109278: PUSH
109279: DOUBLE
109280: LD_EXP 206
109284: PUSH
109285: LD_VAR 0 1
109289: ARRAY
109290: INC
109291: ST_TO_ADDR
109292: LD_INT 1
109294: PUSH
109295: FOR_DOWNTO
109296: IFFALSE 109546
// begin side := GetSide ( minersList [ i ] ) ;
109298: LD_ADDR_VAR 0 3
109302: PUSH
109303: LD_EXP 205
109307: PUSH
109308: LD_VAR 0 1
109312: ARRAY
109313: PPUSH
109314: CALL_OW 255
109318: ST_TO_ADDR
// tmp := HexInfo ( minerMinesList [ i ] [ j ] [ 1 ] , minerMinesList [ i ] [ j ] [ 2 ] ) ;
109319: LD_ADDR_VAR 0 4
109323: PUSH
109324: LD_EXP 206
109328: PUSH
109329: LD_VAR 0 1
109333: ARRAY
109334: PUSH
109335: LD_VAR 0 2
109339: ARRAY
109340: PUSH
109341: LD_INT 1
109343: ARRAY
109344: PPUSH
109345: LD_EXP 206
109349: PUSH
109350: LD_VAR 0 1
109354: ARRAY
109355: PUSH
109356: LD_VAR 0 2
109360: ARRAY
109361: PUSH
109362: LD_INT 2
109364: ARRAY
109365: PPUSH
109366: CALL_OW 428
109370: ST_TO_ADDR
// if not tmp then
109371: LD_VAR 0 4
109375: NOT
109376: IFFALSE 109380
// continue ;
109378: GO 109295
// if tmp in FilterAllUnits ( [ f_enemy , side ] ) and MineAtPos ( minerMinesList [ i ] [ j ] [ 1 ] , minerMinesList [ i ] [ j ] [ 2 ] ) then
109380: LD_VAR 0 4
109384: PUSH
109385: LD_INT 81
109387: PUSH
109388: LD_VAR 0 3
109392: PUSH
109393: EMPTY
109394: LIST
109395: LIST
109396: PPUSH
109397: CALL_OW 69
109401: IN
109402: PUSH
109403: LD_EXP 206
109407: PUSH
109408: LD_VAR 0 1
109412: ARRAY
109413: PUSH
109414: LD_VAR 0 2
109418: ARRAY
109419: PUSH
109420: LD_INT 1
109422: ARRAY
109423: PPUSH
109424: LD_EXP 206
109428: PUSH
109429: LD_VAR 0 1
109433: ARRAY
109434: PUSH
109435: LD_VAR 0 2
109439: ARRAY
109440: PUSH
109441: LD_INT 2
109443: ARRAY
109444: PPUSH
109445: CALL_OW 458
109449: AND
109450: IFFALSE 109544
// begin LaunchMineAtPos ( minerMinesList [ i ] [ j ] [ 1 ] , minerMinesList [ i ] [ j ] [ 2 ] , side ) ;
109452: LD_EXP 206
109456: PUSH
109457: LD_VAR 0 1
109461: ARRAY
109462: PUSH
109463: LD_VAR 0 2
109467: ARRAY
109468: PUSH
109469: LD_INT 1
109471: ARRAY
109472: PPUSH
109473: LD_EXP 206
109477: PUSH
109478: LD_VAR 0 1
109482: ARRAY
109483: PUSH
109484: LD_VAR 0 2
109488: ARRAY
109489: PUSH
109490: LD_INT 2
109492: ARRAY
109493: PPUSH
109494: LD_VAR 0 3
109498: PPUSH
109499: CALL_OW 456
// minerMinesList := Replace ( minerMinesList , i , Delete ( minerMinesList [ i ] , j ) ) ;
109503: LD_ADDR_EXP 206
109507: PUSH
109508: LD_EXP 206
109512: PPUSH
109513: LD_VAR 0 1
109517: PPUSH
109518: LD_EXP 206
109522: PUSH
109523: LD_VAR 0 1
109527: ARRAY
109528: PPUSH
109529: LD_VAR 0 2
109533: PPUSH
109534: CALL_OW 3
109538: PPUSH
109539: CALL_OW 1
109543: ST_TO_ADDR
// end ; end ;
109544: GO 109295
109546: POP
109547: POP
// end ;
109548: GO 109213
109550: POP
109551: POP
// end ;
109552: PPOPN 4
109554: END
// export function MinerPlaceMine ( unit , x , y ) ; var index ; begin
109555: LD_INT 0
109557: PPUSH
109558: PPUSH
// result := false ;
109559: LD_ADDR_VAR 0 4
109563: PUSH
109564: LD_INT 0
109566: ST_TO_ADDR
// if not GetWeapon ( unit ) = ar_miner then
109567: LD_VAR 0 1
109571: PPUSH
109572: CALL_OW 264
109576: PUSH
109577: LD_EXP 81
109581: EQUAL
109582: NOT
109583: IFFALSE 109587
// exit ;
109585: GO 109827
// index := GetElementIndex ( minersList , unit ) ;
109587: LD_ADDR_VAR 0 5
109591: PUSH
109592: LD_EXP 205
109596: PPUSH
109597: LD_VAR 0 1
109601: PPUSH
109602: CALL 56802 0 2
109606: ST_TO_ADDR
// if minerMinesList [ index ] >= minesLimitPerVehicle then
109607: LD_EXP 206
109611: PUSH
109612: LD_VAR 0 5
109616: ARRAY
109617: PUSH
109618: LD_EXP 207
109622: GREATEREQUAL
109623: IFFALSE 109627
// exit ;
109625: GO 109827
// ComMoveXY ( unit , x , y ) ;
109627: LD_VAR 0 1
109631: PPUSH
109632: LD_VAR 0 2
109636: PPUSH
109637: LD_VAR 0 3
109641: PPUSH
109642: CALL_OW 111
// repeat wait ( 0 0$1 ) ;
109646: LD_INT 35
109648: PPUSH
109649: CALL_OW 67
// if not UnitGoingToXY ( unit , x , y ) and HasTask ( unit ) then
109653: LD_VAR 0 1
109657: PPUSH
109658: LD_VAR 0 2
109662: PPUSH
109663: LD_VAR 0 3
109667: PPUSH
109668: CALL 87521 0 3
109672: NOT
109673: PUSH
109674: LD_VAR 0 1
109678: PPUSH
109679: CALL_OW 314
109683: AND
109684: IFFALSE 109688
// exit ;
109686: GO 109827
// until HexInfo ( x , y ) = unit and not HasTask ( unit ) ;
109688: LD_VAR 0 2
109692: PPUSH
109693: LD_VAR 0 3
109697: PPUSH
109698: CALL_OW 428
109702: PUSH
109703: LD_VAR 0 1
109707: EQUAL
109708: PUSH
109709: LD_VAR 0 1
109713: PPUSH
109714: CALL_OW 314
109718: NOT
109719: AND
109720: IFFALSE 109646
// PlaySoundXY ( x , y , PlantMine ) ;
109722: LD_VAR 0 2
109726: PPUSH
109727: LD_VAR 0 3
109731: PPUSH
109732: LD_STRING PlantMine
109734: PPUSH
109735: CALL_OW 366
// PlaceMine ( x , y , GetSide ( unit ) , 0 ) ;
109739: LD_VAR 0 2
109743: PPUSH
109744: LD_VAR 0 3
109748: PPUSH
109749: LD_VAR 0 1
109753: PPUSH
109754: CALL_OW 255
109758: PPUSH
109759: LD_INT 0
109761: PPUSH
109762: CALL_OW 454
// minerMinesList := ReplaceIn ( minerMinesList , [ index , minerMinesList [ index ] + 1 ] , [ x , y ] ) ;
109766: LD_ADDR_EXP 206
109770: PUSH
109771: LD_EXP 206
109775: PPUSH
109776: LD_VAR 0 5
109780: PUSH
109781: LD_EXP 206
109785: PUSH
109786: LD_VAR 0 5
109790: ARRAY
109791: PUSH
109792: LD_INT 1
109794: PLUS
109795: PUSH
109796: EMPTY
109797: LIST
109798: LIST
109799: PPUSH
109800: LD_VAR 0 2
109804: PUSH
109805: LD_VAR 0 3
109809: PUSH
109810: EMPTY
109811: LIST
109812: LIST
109813: PPUSH
109814: CALL 57017 0 3
109818: ST_TO_ADDR
// result := true ;
109819: LD_ADDR_VAR 0 4
109823: PUSH
109824: LD_INT 1
109826: ST_TO_ADDR
// end ;
109827: LD_VAR 0 4
109831: RET
// export function MinerDetonateMine ( unit , x , y ) ; var i , index ; begin
109832: LD_INT 0
109834: PPUSH
109835: PPUSH
109836: PPUSH
// if not unit in minersList then
109837: LD_VAR 0 1
109841: PUSH
109842: LD_EXP 205
109846: IN
109847: NOT
109848: IFFALSE 109852
// exit ;
109850: GO 110244
// index := GetElementIndex ( minersList , unit ) ;
109852: LD_ADDR_VAR 0 6
109856: PUSH
109857: LD_EXP 205
109861: PPUSH
109862: LD_VAR 0 1
109866: PPUSH
109867: CALL 56802 0 2
109871: ST_TO_ADDR
// for i := minerMinesList [ index ] downto 1 do
109872: LD_ADDR_VAR 0 5
109876: PUSH
109877: DOUBLE
109878: LD_EXP 206
109882: PUSH
109883: LD_VAR 0 6
109887: ARRAY
109888: INC
109889: ST_TO_ADDR
109890: LD_INT 1
109892: PUSH
109893: FOR_DOWNTO
109894: IFFALSE 110055
// begin if minerMinesList [ index ] [ i ] [ 1 ] = x and minerMinesList [ index ] [ i ] [ 2 ] = y then
109896: LD_EXP 206
109900: PUSH
109901: LD_VAR 0 6
109905: ARRAY
109906: PUSH
109907: LD_VAR 0 5
109911: ARRAY
109912: PUSH
109913: LD_INT 1
109915: ARRAY
109916: PUSH
109917: LD_VAR 0 2
109921: EQUAL
109922: PUSH
109923: LD_EXP 206
109927: PUSH
109928: LD_VAR 0 6
109932: ARRAY
109933: PUSH
109934: LD_VAR 0 5
109938: ARRAY
109939: PUSH
109940: LD_INT 2
109942: ARRAY
109943: PUSH
109944: LD_VAR 0 3
109948: EQUAL
109949: AND
109950: IFFALSE 110053
// begin LaunchMineAtPos ( minerMinesList [ index ] [ i ] [ 1 ] , minerMinesList [ index ] [ i ] [ 2 ] , GetSide ( unit ) ) ;
109952: LD_EXP 206
109956: PUSH
109957: LD_VAR 0 6
109961: ARRAY
109962: PUSH
109963: LD_VAR 0 5
109967: ARRAY
109968: PUSH
109969: LD_INT 1
109971: ARRAY
109972: PPUSH
109973: LD_EXP 206
109977: PUSH
109978: LD_VAR 0 6
109982: ARRAY
109983: PUSH
109984: LD_VAR 0 5
109988: ARRAY
109989: PUSH
109990: LD_INT 2
109992: ARRAY
109993: PPUSH
109994: LD_VAR 0 1
109998: PPUSH
109999: CALL_OW 255
110003: PPUSH
110004: CALL_OW 456
// minerMinesList := Replace ( minerMinesList , index , Delete ( minerMinesList [ index ] , i ) ) ;
110008: LD_ADDR_EXP 206
110012: PUSH
110013: LD_EXP 206
110017: PPUSH
110018: LD_VAR 0 6
110022: PPUSH
110023: LD_EXP 206
110027: PUSH
110028: LD_VAR 0 6
110032: ARRAY
110033: PPUSH
110034: LD_VAR 0 5
110038: PPUSH
110039: CALL_OW 3
110043: PPUSH
110044: CALL_OW 1
110048: ST_TO_ADDR
// exit ;
110049: POP
110050: POP
110051: GO 110244
// end ; end ;
110053: GO 109893
110055: POP
110056: POP
// for i := minerMinesList [ index ] downto 1 do
110057: LD_ADDR_VAR 0 5
110061: PUSH
110062: DOUBLE
110063: LD_EXP 206
110067: PUSH
110068: LD_VAR 0 6
110072: ARRAY
110073: INC
110074: ST_TO_ADDR
110075: LD_INT 1
110077: PUSH
110078: FOR_DOWNTO
110079: IFFALSE 110242
// begin if GetDistXY ( minerMinesList [ index ] [ i ] [ 1 ] , minerMinesList [ index ] [ i ] [ 2 ] , x , y ) < 6 then
110081: LD_EXP 206
110085: PUSH
110086: LD_VAR 0 6
110090: ARRAY
110091: PUSH
110092: LD_VAR 0 5
110096: ARRAY
110097: PUSH
110098: LD_INT 1
110100: ARRAY
110101: PPUSH
110102: LD_EXP 206
110106: PUSH
110107: LD_VAR 0 6
110111: ARRAY
110112: PUSH
110113: LD_VAR 0 5
110117: ARRAY
110118: PUSH
110119: LD_INT 2
110121: ARRAY
110122: PPUSH
110123: LD_VAR 0 2
110127: PPUSH
110128: LD_VAR 0 3
110132: PPUSH
110133: CALL_OW 298
110137: PUSH
110138: LD_INT 6
110140: LESS
110141: IFFALSE 110240
// begin LaunchMineAtPos ( minerMinesList [ index ] [ i ] [ 1 ] , minerMinesList [ index ] [ i ] [ 2 ] , GetSide ( unit ) ) ;
110143: LD_EXP 206
110147: PUSH
110148: LD_VAR 0 6
110152: ARRAY
110153: PUSH
110154: LD_VAR 0 5
110158: ARRAY
110159: PUSH
110160: LD_INT 1
110162: ARRAY
110163: PPUSH
110164: LD_EXP 206
110168: PUSH
110169: LD_VAR 0 6
110173: ARRAY
110174: PUSH
110175: LD_VAR 0 5
110179: ARRAY
110180: PUSH
110181: LD_INT 2
110183: ARRAY
110184: PPUSH
110185: LD_VAR 0 1
110189: PPUSH
110190: CALL_OW 255
110194: PPUSH
110195: CALL_OW 456
// minerMinesList := Replace ( minerMinesList , index , Delete ( minerMinesList [ index ] , i ) ) ;
110199: LD_ADDR_EXP 206
110203: PUSH
110204: LD_EXP 206
110208: PPUSH
110209: LD_VAR 0 6
110213: PPUSH
110214: LD_EXP 206
110218: PUSH
110219: LD_VAR 0 6
110223: ARRAY
110224: PPUSH
110225: LD_VAR 0 5
110229: PPUSH
110230: CALL_OW 3
110234: PPUSH
110235: CALL_OW 1
110239: ST_TO_ADDR
// end ; end ;
110240: GO 110078
110242: POP
110243: POP
// end ;
110244: LD_VAR 0 4
110248: RET
// export function MinerCreateMinefield ( unit , x , y ) ; var i , index , tmp , minesFreeAmount , _x , _y , _d , _r ; begin
110249: LD_INT 0
110251: PPUSH
110252: PPUSH
110253: PPUSH
110254: PPUSH
110255: PPUSH
110256: PPUSH
110257: PPUSH
110258: PPUSH
110259: PPUSH
// if not GetWeapon ( unit ) = ar_miner or not unit in minersList then
110260: LD_VAR 0 1
110264: PPUSH
110265: CALL_OW 264
110269: PUSH
110270: LD_EXP 81
110274: EQUAL
110275: NOT
110276: PUSH
110277: LD_VAR 0 1
110281: PUSH
110282: LD_EXP 205
110286: IN
110287: NOT
110288: OR
110289: IFFALSE 110293
// exit ;
110291: GO 110615
// index := GetElementIndex ( minersList , unit ) ;
110293: LD_ADDR_VAR 0 6
110297: PUSH
110298: LD_EXP 205
110302: PPUSH
110303: LD_VAR 0 1
110307: PPUSH
110308: CALL 56802 0 2
110312: ST_TO_ADDR
// minesFreeAmount := minesLimitPerVehicle - minerMinesList [ index ] ;
110313: LD_ADDR_VAR 0 8
110317: PUSH
110318: LD_EXP 207
110322: PUSH
110323: LD_EXP 206
110327: PUSH
110328: LD_VAR 0 6
110332: ARRAY
110333: MINUS
110334: ST_TO_ADDR
// if not minesFreeAmount then
110335: LD_VAR 0 8
110339: NOT
110340: IFFALSE 110344
// exit ;
110342: GO 110615
// tmp := [ ] ;
110344: LD_ADDR_VAR 0 7
110348: PUSH
110349: EMPTY
110350: ST_TO_ADDR
// for i := 1 to minesFreeAmount do
110351: LD_ADDR_VAR 0 5
110355: PUSH
110356: DOUBLE
110357: LD_INT 1
110359: DEC
110360: ST_TO_ADDR
110361: LD_VAR 0 8
110365: PUSH
110366: FOR_TO
110367: IFFALSE 110562
// begin _d := rand ( 0 , 5 ) ;
110369: LD_ADDR_VAR 0 11
110373: PUSH
110374: LD_INT 0
110376: PPUSH
110377: LD_INT 5
110379: PPUSH
110380: CALL_OW 12
110384: ST_TO_ADDR
// _r := rand ( 2 , 6 ) ;
110385: LD_ADDR_VAR 0 12
110389: PUSH
110390: LD_INT 2
110392: PPUSH
110393: LD_INT 6
110395: PPUSH
110396: CALL_OW 12
110400: ST_TO_ADDR
// _x := ShiftX ( x , _d , _r ) ;
110401: LD_ADDR_VAR 0 9
110405: PUSH
110406: LD_VAR 0 2
110410: PPUSH
110411: LD_VAR 0 11
110415: PPUSH
110416: LD_VAR 0 12
110420: PPUSH
110421: CALL_OW 272
110425: ST_TO_ADDR
// _y := ShiftY ( y , _d , _r ) ;
110426: LD_ADDR_VAR 0 10
110430: PUSH
110431: LD_VAR 0 3
110435: PPUSH
110436: LD_VAR 0 11
110440: PPUSH
110441: LD_VAR 0 12
110445: PPUSH
110446: CALL_OW 273
110450: ST_TO_ADDR
// if ValidHex ( _x , _y ) and not [ _x , _y ] in tmp and not MineAtPos ( _x , _y ) then
110451: LD_VAR 0 9
110455: PPUSH
110456: LD_VAR 0 10
110460: PPUSH
110461: CALL_OW 488
110465: PUSH
110466: LD_VAR 0 9
110470: PUSH
110471: LD_VAR 0 10
110475: PUSH
110476: EMPTY
110477: LIST
110478: LIST
110479: PUSH
110480: LD_VAR 0 7
110484: IN
110485: NOT
110486: AND
110487: PUSH
110488: LD_VAR 0 9
110492: PPUSH
110493: LD_VAR 0 10
110497: PPUSH
110498: CALL_OW 458
110502: NOT
110503: AND
110504: IFFALSE 110546
// tmp := Replace ( tmp , tmp + 1 , [ _x , _y ] ) else
110506: LD_ADDR_VAR 0 7
110510: PUSH
110511: LD_VAR 0 7
110515: PPUSH
110516: LD_VAR 0 7
110520: PUSH
110521: LD_INT 1
110523: PLUS
110524: PPUSH
110525: LD_VAR 0 9
110529: PUSH
110530: LD_VAR 0 10
110534: PUSH
110535: EMPTY
110536: LIST
110537: LIST
110538: PPUSH
110539: CALL_OW 1
110543: ST_TO_ADDR
110544: GO 110560
// i := i - 1 ;
110546: LD_ADDR_VAR 0 5
110550: PUSH
110551: LD_VAR 0 5
110555: PUSH
110556: LD_INT 1
110558: MINUS
110559: ST_TO_ADDR
// end ;
110560: GO 110366
110562: POP
110563: POP
// for i in tmp do
110564: LD_ADDR_VAR 0 5
110568: PUSH
110569: LD_VAR 0 7
110573: PUSH
110574: FOR_IN
110575: IFFALSE 110613
// if not MinerPlaceMine ( unit , i [ 1 ] , i [ 2 ] ) then
110577: LD_VAR 0 1
110581: PPUSH
110582: LD_VAR 0 5
110586: PUSH
110587: LD_INT 1
110589: ARRAY
110590: PPUSH
110591: LD_VAR 0 5
110595: PUSH
110596: LD_INT 2
110598: ARRAY
110599: PPUSH
110600: CALL 109555 0 3
110604: NOT
110605: IFFALSE 110611
// exit ;
110607: POP
110608: POP
110609: GO 110615
110611: GO 110574
110613: POP
110614: POP
// end ;
110615: LD_VAR 0 4
110619: RET
// export function ComBinocular ( unit , x , y ) ; var dist , side , viewRange , _x , _y , _d ; begin
110620: LD_INT 0
110622: PPUSH
110623: PPUSH
110624: PPUSH
110625: PPUSH
110626: PPUSH
110627: PPUSH
110628: PPUSH
// if not GetClass ( unit ) = class_sniper then
110629: LD_VAR 0 1
110633: PPUSH
110634: CALL_OW 257
110638: PUSH
110639: LD_INT 5
110641: EQUAL
110642: NOT
110643: IFFALSE 110647
// exit ;
110645: GO 111035
// dist := 8 ;
110647: LD_ADDR_VAR 0 5
110651: PUSH
110652: LD_INT 8
110654: ST_TO_ADDR
// viewRange := 12 ;
110655: LD_ADDR_VAR 0 7
110659: PUSH
110660: LD_INT 12
110662: ST_TO_ADDR
// side := GetSide ( unit ) ;
110663: LD_ADDR_VAR 0 6
110667: PUSH
110668: LD_VAR 0 1
110672: PPUSH
110673: CALL_OW 255
110677: ST_TO_ADDR
// if GetTech ( tech_opto2 , side ) = state_researched then
110678: LD_INT 61
110680: PPUSH
110681: LD_VAR 0 6
110685: PPUSH
110686: CALL_OW 321
110690: PUSH
110691: LD_INT 2
110693: EQUAL
110694: IFFALSE 110704
// viewRange := 16 ;
110696: LD_ADDR_VAR 0 7
110700: PUSH
110701: LD_INT 16
110703: ST_TO_ADDR
// if GetDistUnitXY ( unit , x , y ) > dist then
110704: LD_VAR 0 1
110708: PPUSH
110709: LD_VAR 0 2
110713: PPUSH
110714: LD_VAR 0 3
110718: PPUSH
110719: CALL_OW 297
110723: PUSH
110724: LD_VAR 0 5
110728: GREATER
110729: IFFALSE 110808
// begin ComMoveXY ( unit , x , y ) ;
110731: LD_VAR 0 1
110735: PPUSH
110736: LD_VAR 0 2
110740: PPUSH
110741: LD_VAR 0 3
110745: PPUSH
110746: CALL_OW 111
// repeat wait ( 0 0$1 ) ;
110750: LD_INT 35
110752: PPUSH
110753: CALL_OW 67
// if not UnitGoingToXY ( unit , x , y ) then
110757: LD_VAR 0 1
110761: PPUSH
110762: LD_VAR 0 2
110766: PPUSH
110767: LD_VAR 0 3
110771: PPUSH
110772: CALL 87521 0 3
110776: NOT
110777: IFFALSE 110781
// exit ;
110779: GO 111035
// until GetDistUnitXY ( unit , x , y ) < dist ;
110781: LD_VAR 0 1
110785: PPUSH
110786: LD_VAR 0 2
110790: PPUSH
110791: LD_VAR 0 3
110795: PPUSH
110796: CALL_OW 297
110800: PUSH
110801: LD_VAR 0 5
110805: LESS
110806: IFFALSE 110750
// end ; ComTurnXY ( unit , x , y ) ;
110808: LD_VAR 0 1
110812: PPUSH
110813: LD_VAR 0 2
110817: PPUSH
110818: LD_VAR 0 3
110822: PPUSH
110823: CALL_OW 118
// wait ( 5 ) ;
110827: LD_INT 5
110829: PPUSH
110830: CALL_OW 67
// _d := GetDir ( unit ) ;
110834: LD_ADDR_VAR 0 10
110838: PUSH
110839: LD_VAR 0 1
110843: PPUSH
110844: CALL_OW 254
110848: ST_TO_ADDR
// _x := ShiftX ( GetX ( unit ) , _d , dist ) ;
110849: LD_ADDR_VAR 0 8
110853: PUSH
110854: LD_VAR 0 1
110858: PPUSH
110859: CALL_OW 250
110863: PPUSH
110864: LD_VAR 0 10
110868: PPUSH
110869: LD_VAR 0 5
110873: PPUSH
110874: CALL_OW 272
110878: ST_TO_ADDR
// _y := ShiftY ( GetY ( unit ) , _d , dist ) ;
110879: LD_ADDR_VAR 0 9
110883: PUSH
110884: LD_VAR 0 1
110888: PPUSH
110889: CALL_OW 251
110893: PPUSH
110894: LD_VAR 0 10
110898: PPUSH
110899: LD_VAR 0 5
110903: PPUSH
110904: CALL_OW 273
110908: ST_TO_ADDR
// if not ValidHex ( _x , _y ) then
110909: LD_VAR 0 8
110913: PPUSH
110914: LD_VAR 0 9
110918: PPUSH
110919: CALL_OW 488
110923: NOT
110924: IFFALSE 110928
// exit ;
110926: GO 111035
// ComAnimCustom ( unit , 1 ) ;
110928: LD_VAR 0 1
110932: PPUSH
110933: LD_INT 1
110935: PPUSH
110936: CALL_OW 592
// PlaceSeeing ( _x , _y , side , viewRange ) ;
110940: LD_VAR 0 8
110944: PPUSH
110945: LD_VAR 0 9
110949: PPUSH
110950: LD_VAR 0 6
110954: PPUSH
110955: LD_VAR 0 7
110959: PPUSH
110960: CALL_OW 330
// repeat wait ( 1 ) ;
110964: LD_INT 1
110966: PPUSH
110967: CALL_OW 67
// until IsIdle ( unit ) or HasTask ( unit ) or not IsOk ( unit ) or IsDead ( unit ) ;
110971: LD_VAR 0 1
110975: PPUSH
110976: CALL_OW 316
110980: PUSH
110981: LD_VAR 0 1
110985: PPUSH
110986: CALL_OW 314
110990: OR
110991: PUSH
110992: LD_VAR 0 1
110996: PPUSH
110997: CALL_OW 302
111001: NOT
111002: OR
111003: PUSH
111004: LD_VAR 0 1
111008: PPUSH
111009: CALL_OW 301
111013: OR
111014: IFFALSE 110964
// RemoveSeeing ( _x , _y , side ) ;
111016: LD_VAR 0 8
111020: PPUSH
111021: LD_VAR 0 9
111025: PPUSH
111026: LD_VAR 0 6
111030: PPUSH
111031: CALL_OW 331
// end ; end_of_file
111035: LD_VAR 0 4
111039: RET
// export function Attack ( list ) ; var base , group , path , flags , i , j , k , x , y , d , z , tmp , tmp2 , units_path , f_ignore_area , f_capture , f_ignore_civ , f_murder , f_mines , f_repair , f_heal , f_spacetime , f_attack_depot , f_crawl , mined , bombed , attacking , to_heal , healers , to_repair , repairs , empty_vehs , side ; begin
111040: LD_INT 0
111042: PPUSH
111043: PPUSH
111044: PPUSH
111045: PPUSH
111046: PPUSH
111047: PPUSH
111048: PPUSH
111049: PPUSH
111050: PPUSH
111051: PPUSH
111052: PPUSH
111053: PPUSH
111054: PPUSH
111055: PPUSH
111056: PPUSH
111057: PPUSH
111058: PPUSH
111059: PPUSH
111060: PPUSH
111061: PPUSH
111062: PPUSH
111063: PPUSH
111064: PPUSH
111065: PPUSH
111066: PPUSH
111067: PPUSH
111068: PPUSH
111069: PPUSH
111070: PPUSH
111071: PPUSH
111072: PPUSH
111073: PPUSH
111074: PPUSH
111075: PPUSH
// if not list then
111076: LD_VAR 0 1
111080: NOT
111081: IFFALSE 111085
// exit ;
111083: GO 115744
// base := list [ 1 ] ;
111085: LD_ADDR_VAR 0 3
111089: PUSH
111090: LD_VAR 0 1
111094: PUSH
111095: LD_INT 1
111097: ARRAY
111098: ST_TO_ADDR
// group := list [ 2 ] ;
111099: LD_ADDR_VAR 0 4
111103: PUSH
111104: LD_VAR 0 1
111108: PUSH
111109: LD_INT 2
111111: ARRAY
111112: ST_TO_ADDR
// path := list [ 3 ] ;
111113: LD_ADDR_VAR 0 5
111117: PUSH
111118: LD_VAR 0 1
111122: PUSH
111123: LD_INT 3
111125: ARRAY
111126: ST_TO_ADDR
// flags := list [ 4 ] ;
111127: LD_ADDR_VAR 0 6
111131: PUSH
111132: LD_VAR 0 1
111136: PUSH
111137: LD_INT 4
111139: ARRAY
111140: ST_TO_ADDR
// mined := [ ] ;
111141: LD_ADDR_VAR 0 27
111145: PUSH
111146: EMPTY
111147: ST_TO_ADDR
// bombed := [ ] ;
111148: LD_ADDR_VAR 0 28
111152: PUSH
111153: EMPTY
111154: ST_TO_ADDR
// healers := [ ] ;
111155: LD_ADDR_VAR 0 31
111159: PUSH
111160: EMPTY
111161: ST_TO_ADDR
// to_heal := [ ] ;
111162: LD_ADDR_VAR 0 30
111166: PUSH
111167: EMPTY
111168: ST_TO_ADDR
// repairs := [ ] ;
111169: LD_ADDR_VAR 0 33
111173: PUSH
111174: EMPTY
111175: ST_TO_ADDR
// to_repair := [ ] ;
111176: LD_ADDR_VAR 0 32
111180: PUSH
111181: EMPTY
111182: ST_TO_ADDR
// if not group or not path then
111183: LD_VAR 0 4
111187: NOT
111188: PUSH
111189: LD_VAR 0 5
111193: NOT
111194: OR
111195: IFFALSE 111199
// exit ;
111197: GO 115744
// side := GetSide ( group [ 1 ] ) ;
111199: LD_ADDR_VAR 0 35
111203: PUSH
111204: LD_VAR 0 4
111208: PUSH
111209: LD_INT 1
111211: ARRAY
111212: PPUSH
111213: CALL_OW 255
111217: ST_TO_ADDR
// if flags then
111218: LD_VAR 0 6
111222: IFFALSE 111366
// begin f_ignore_area := flags [ 1 ] ;
111224: LD_ADDR_VAR 0 17
111228: PUSH
111229: LD_VAR 0 6
111233: PUSH
111234: LD_INT 1
111236: ARRAY
111237: ST_TO_ADDR
// f_capture := flags [ 2 ] ;
111238: LD_ADDR_VAR 0 18
111242: PUSH
111243: LD_VAR 0 6
111247: PUSH
111248: LD_INT 2
111250: ARRAY
111251: ST_TO_ADDR
// f_ignore_civ := flags [ 3 ] ;
111252: LD_ADDR_VAR 0 19
111256: PUSH
111257: LD_VAR 0 6
111261: PUSH
111262: LD_INT 3
111264: ARRAY
111265: ST_TO_ADDR
// f_murder := flags [ 4 ] ;
111266: LD_ADDR_VAR 0 20
111270: PUSH
111271: LD_VAR 0 6
111275: PUSH
111276: LD_INT 4
111278: ARRAY
111279: ST_TO_ADDR
// f_mines := flags [ 5 ] ;
111280: LD_ADDR_VAR 0 21
111284: PUSH
111285: LD_VAR 0 6
111289: PUSH
111290: LD_INT 5
111292: ARRAY
111293: ST_TO_ADDR
// f_repair := flags [ 6 ] ;
111294: LD_ADDR_VAR 0 22
111298: PUSH
111299: LD_VAR 0 6
111303: PUSH
111304: LD_INT 6
111306: ARRAY
111307: ST_TO_ADDR
// f_heal := flags [ 7 ] ;
111308: LD_ADDR_VAR 0 23
111312: PUSH
111313: LD_VAR 0 6
111317: PUSH
111318: LD_INT 7
111320: ARRAY
111321: ST_TO_ADDR
// f_spacetime := flags [ 8 ] ;
111322: LD_ADDR_VAR 0 24
111326: PUSH
111327: LD_VAR 0 6
111331: PUSH
111332: LD_INT 8
111334: ARRAY
111335: ST_TO_ADDR
// f_attack_depot := flags [ 9 ] ;
111336: LD_ADDR_VAR 0 25
111340: PUSH
111341: LD_VAR 0 6
111345: PUSH
111346: LD_INT 9
111348: ARRAY
111349: ST_TO_ADDR
// f_crawl := flags [ 10 ] ;
111350: LD_ADDR_VAR 0 26
111354: PUSH
111355: LD_VAR 0 6
111359: PUSH
111360: LD_INT 10
111362: ARRAY
111363: ST_TO_ADDR
// end else
111364: GO 111446
// begin f_ignore_area := false ;
111366: LD_ADDR_VAR 0 17
111370: PUSH
111371: LD_INT 0
111373: ST_TO_ADDR
// f_capture := false ;
111374: LD_ADDR_VAR 0 18
111378: PUSH
111379: LD_INT 0
111381: ST_TO_ADDR
// f_ignore_civ := false ;
111382: LD_ADDR_VAR 0 19
111386: PUSH
111387: LD_INT 0
111389: ST_TO_ADDR
// f_murder := false ;
111390: LD_ADDR_VAR 0 20
111394: PUSH
111395: LD_INT 0
111397: ST_TO_ADDR
// f_mines := false ;
111398: LD_ADDR_VAR 0 21
111402: PUSH
111403: LD_INT 0
111405: ST_TO_ADDR
// f_repair := false ;
111406: LD_ADDR_VAR 0 22
111410: PUSH
111411: LD_INT 0
111413: ST_TO_ADDR
// f_heal := false ;
111414: LD_ADDR_VAR 0 23
111418: PUSH
111419: LD_INT 0
111421: ST_TO_ADDR
// f_spacetime := false ;
111422: LD_ADDR_VAR 0 24
111426: PUSH
111427: LD_INT 0
111429: ST_TO_ADDR
// f_attack_depot := false ;
111430: LD_ADDR_VAR 0 25
111434: PUSH
111435: LD_INT 0
111437: ST_TO_ADDR
// f_crawl := false ;
111438: LD_ADDR_VAR 0 26
111442: PUSH
111443: LD_INT 0
111445: ST_TO_ADDR
// end ; if f_heal then
111446: LD_VAR 0 23
111450: IFFALSE 111477
// healers := UnitFilter ( group , [ f_class , 4 ] ) ;
111452: LD_ADDR_VAR 0 31
111456: PUSH
111457: LD_VAR 0 4
111461: PPUSH
111462: LD_INT 25
111464: PUSH
111465: LD_INT 4
111467: PUSH
111468: EMPTY
111469: LIST
111470: LIST
111471: PPUSH
111472: CALL_OW 72
111476: ST_TO_ADDR
// if f_repair then
111477: LD_VAR 0 22
111481: IFFALSE 111508
// repairs := UnitFilter ( group , [ f_class , 3 ] ) ;
111483: LD_ADDR_VAR 0 33
111487: PUSH
111488: LD_VAR 0 4
111492: PPUSH
111493: LD_INT 25
111495: PUSH
111496: LD_INT 3
111498: PUSH
111499: EMPTY
111500: LIST
111501: LIST
111502: PPUSH
111503: CALL_OW 72
111507: ST_TO_ADDR
// units_path := [ ] ;
111508: LD_ADDR_VAR 0 16
111512: PUSH
111513: EMPTY
111514: ST_TO_ADDR
// for i = 1 to group do
111515: LD_ADDR_VAR 0 7
111519: PUSH
111520: DOUBLE
111521: LD_INT 1
111523: DEC
111524: ST_TO_ADDR
111525: LD_VAR 0 4
111529: PUSH
111530: FOR_TO
111531: IFFALSE 111560
// units_path := Replace ( units_path , i , path ) ;
111533: LD_ADDR_VAR 0 16
111537: PUSH
111538: LD_VAR 0 16
111542: PPUSH
111543: LD_VAR 0 7
111547: PPUSH
111548: LD_VAR 0 5
111552: PPUSH
111553: CALL_OW 1
111557: ST_TO_ADDR
111558: GO 111530
111560: POP
111561: POP
// repeat for i = group downto 1 do
111562: LD_ADDR_VAR 0 7
111566: PUSH
111567: DOUBLE
111568: LD_VAR 0 4
111572: INC
111573: ST_TO_ADDR
111574: LD_INT 1
111576: PUSH
111577: FOR_DOWNTO
111578: IFFALSE 115700
// begin wait ( 5 ) ;
111580: LD_INT 5
111582: PPUSH
111583: CALL_OW 67
// tmp := [ ] ;
111587: LD_ADDR_VAR 0 14
111591: PUSH
111592: EMPTY
111593: ST_TO_ADDR
// attacking := false ;
111594: LD_ADDR_VAR 0 29
111598: PUSH
111599: LD_INT 0
111601: ST_TO_ADDR
// if IsDead ( group [ i ] ) or not group [ i ] then
111602: LD_VAR 0 4
111606: PUSH
111607: LD_VAR 0 7
111611: ARRAY
111612: PPUSH
111613: CALL_OW 301
111617: PUSH
111618: LD_VAR 0 4
111622: PUSH
111623: LD_VAR 0 7
111627: ARRAY
111628: NOT
111629: OR
111630: IFFALSE 111739
// begin if GetType ( group [ i ] ) = unit_human then
111632: LD_VAR 0 4
111636: PUSH
111637: LD_VAR 0 7
111641: ARRAY
111642: PPUSH
111643: CALL_OW 247
111647: PUSH
111648: LD_INT 1
111650: EQUAL
111651: IFFALSE 111697
// begin to_heal := to_heal diff group [ i ] ;
111653: LD_ADDR_VAR 0 30
111657: PUSH
111658: LD_VAR 0 30
111662: PUSH
111663: LD_VAR 0 4
111667: PUSH
111668: LD_VAR 0 7
111672: ARRAY
111673: DIFF
111674: ST_TO_ADDR
// healers := healers diff group [ i ] ;
111675: LD_ADDR_VAR 0 31
111679: PUSH
111680: LD_VAR 0 31
111684: PUSH
111685: LD_VAR 0 4
111689: PUSH
111690: LD_VAR 0 7
111694: ARRAY
111695: DIFF
111696: ST_TO_ADDR
// end ; group := Delete ( group , i ) ;
111697: LD_ADDR_VAR 0 4
111701: PUSH
111702: LD_VAR 0 4
111706: PPUSH
111707: LD_VAR 0 7
111711: PPUSH
111712: CALL_OW 3
111716: ST_TO_ADDR
// units_path := Delete ( units_path , i ) ;
111717: LD_ADDR_VAR 0 16
111721: PUSH
111722: LD_VAR 0 16
111726: PPUSH
111727: LD_VAR 0 7
111731: PPUSH
111732: CALL_OW 3
111736: ST_TO_ADDR
// continue ;
111737: GO 111577
// end ; if f_repair then
111739: LD_VAR 0 22
111743: IFFALSE 112232
// begin if GetType ( group [ i ] ) = unit_vehicle then
111745: LD_VAR 0 4
111749: PUSH
111750: LD_VAR 0 7
111754: ARRAY
111755: PPUSH
111756: CALL_OW 247
111760: PUSH
111761: LD_INT 2
111763: EQUAL
111764: IFFALSE 111954
// begin if GetLives ( group [ i ] ) < 700 and not group [ i ] in to_repair then
111766: LD_VAR 0 4
111770: PUSH
111771: LD_VAR 0 7
111775: ARRAY
111776: PPUSH
111777: CALL_OW 256
111781: PUSH
111782: LD_INT 700
111784: LESS
111785: PUSH
111786: LD_VAR 0 4
111790: PUSH
111791: LD_VAR 0 7
111795: ARRAY
111796: PUSH
111797: LD_VAR 0 32
111801: IN
111802: NOT
111803: AND
111804: IFFALSE 111828
// to_repair := to_repair union group [ i ] ;
111806: LD_ADDR_VAR 0 32
111810: PUSH
111811: LD_VAR 0 32
111815: PUSH
111816: LD_VAR 0 4
111820: PUSH
111821: LD_VAR 0 7
111825: ARRAY
111826: UNION
111827: ST_TO_ADDR
// if GetLives ( group [ i ] ) = 1000 and group [ i ] in to_repair then
111828: LD_VAR 0 4
111832: PUSH
111833: LD_VAR 0 7
111837: ARRAY
111838: PPUSH
111839: CALL_OW 256
111843: PUSH
111844: LD_INT 1000
111846: EQUAL
111847: PUSH
111848: LD_VAR 0 4
111852: PUSH
111853: LD_VAR 0 7
111857: ARRAY
111858: PUSH
111859: LD_VAR 0 32
111863: IN
111864: AND
111865: IFFALSE 111889
// to_repair := to_repair diff group [ i ] ;
111867: LD_ADDR_VAR 0 32
111871: PUSH
111872: LD_VAR 0 32
111876: PUSH
111877: LD_VAR 0 4
111881: PUSH
111882: LD_VAR 0 7
111886: ARRAY
111887: DIFF
111888: ST_TO_ADDR
// if group [ i ] in to_repair then
111889: LD_VAR 0 4
111893: PUSH
111894: LD_VAR 0 7
111898: ARRAY
111899: PUSH
111900: LD_VAR 0 32
111904: IN
111905: IFFALSE 111952
// begin if not IsInArea ( group [ i ] , f_repair ) then
111907: LD_VAR 0 4
111911: PUSH
111912: LD_VAR 0 7
111916: ARRAY
111917: PPUSH
111918: LD_VAR 0 22
111922: PPUSH
111923: CALL_OW 308
111927: NOT
111928: IFFALSE 111950
// ComMoveToArea ( group [ i ] , f_repair ) ;
111930: LD_VAR 0 4
111934: PUSH
111935: LD_VAR 0 7
111939: ARRAY
111940: PPUSH
111941: LD_VAR 0 22
111945: PPUSH
111946: CALL_OW 113
// continue ;
111950: GO 111577
// end ; end else
111952: GO 112232
// if group [ i ] in repairs then
111954: LD_VAR 0 4
111958: PUSH
111959: LD_VAR 0 7
111963: ARRAY
111964: PUSH
111965: LD_VAR 0 33
111969: IN
111970: IFFALSE 112232
// begin if IsInUnit ( group [ i ] ) then
111972: LD_VAR 0 4
111976: PUSH
111977: LD_VAR 0 7
111981: ARRAY
111982: PPUSH
111983: CALL_OW 310
111987: IFFALSE 112055
// begin z := IsInUnit ( group [ i ] ) ;
111989: LD_ADDR_VAR 0 13
111993: PUSH
111994: LD_VAR 0 4
111998: PUSH
111999: LD_VAR 0 7
112003: ARRAY
112004: PPUSH
112005: CALL_OW 310
112009: ST_TO_ADDR
// if z in to_repair and IsInArea ( z , f_repair ) then
112010: LD_VAR 0 13
112014: PUSH
112015: LD_VAR 0 32
112019: IN
112020: PUSH
112021: LD_VAR 0 13
112025: PPUSH
112026: LD_VAR 0 22
112030: PPUSH
112031: CALL_OW 308
112035: AND
112036: IFFALSE 112053
// ComExitVehicle ( group [ i ] ) ;
112038: LD_VAR 0 4
112042: PUSH
112043: LD_VAR 0 7
112047: ARRAY
112048: PPUSH
112049: CALL_OW 121
// end else
112053: GO 112232
// begin z := UnitFilter ( group , [ [ f_inarea , f_repair ] , [ f_empty ] ] ) ;
112055: LD_ADDR_VAR 0 13
112059: PUSH
112060: LD_VAR 0 4
112064: PPUSH
112065: LD_INT 95
112067: PUSH
112068: LD_VAR 0 22
112072: PUSH
112073: EMPTY
112074: LIST
112075: LIST
112076: PUSH
112077: LD_INT 58
112079: PUSH
112080: EMPTY
112081: LIST
112082: PUSH
112083: EMPTY
112084: LIST
112085: LIST
112086: PPUSH
112087: CALL_OW 72
112091: ST_TO_ADDR
// if not HasTask ( group [ i ] ) then
112092: LD_VAR 0 4
112096: PUSH
112097: LD_VAR 0 7
112101: ARRAY
112102: PPUSH
112103: CALL_OW 314
112107: NOT
112108: IFFALSE 112230
// begin x := NearestUnitToUnit ( z , group [ i ] ) ;
112110: LD_ADDR_VAR 0 10
112114: PUSH
112115: LD_VAR 0 13
112119: PPUSH
112120: LD_VAR 0 4
112124: PUSH
112125: LD_VAR 0 7
112129: ARRAY
112130: PPUSH
112131: CALL_OW 74
112135: ST_TO_ADDR
// if not x then
112136: LD_VAR 0 10
112140: NOT
112141: IFFALSE 112145
// continue ;
112143: GO 111577
// if GetLives ( x ) < 1000 then
112145: LD_VAR 0 10
112149: PPUSH
112150: CALL_OW 256
112154: PUSH
112155: LD_INT 1000
112157: LESS
112158: IFFALSE 112182
// ComRepairVehicle ( group [ i ] , x ) else
112160: LD_VAR 0 4
112164: PUSH
112165: LD_VAR 0 7
112169: ARRAY
112170: PPUSH
112171: LD_VAR 0 10
112175: PPUSH
112176: CALL_OW 129
112180: GO 112230
// if not ( f_heal and GetLives ( group [ i ] ) < 1000 ) then
112182: LD_VAR 0 23
112186: PUSH
112187: LD_VAR 0 4
112191: PUSH
112192: LD_VAR 0 7
112196: ARRAY
112197: PPUSH
112198: CALL_OW 256
112202: PUSH
112203: LD_INT 1000
112205: LESS
112206: AND
112207: NOT
112208: IFFALSE 112230
// ComEnterUnit ( group [ i ] , x ) ;
112210: LD_VAR 0 4
112214: PUSH
112215: LD_VAR 0 7
112219: ARRAY
112220: PPUSH
112221: LD_VAR 0 10
112225: PPUSH
112226: CALL_OW 120
// end ; continue ;
112230: GO 111577
// end ; end ; end ; if f_heal and GetType ( group [ i ] ) = unit_human then
112232: LD_VAR 0 23
112236: PUSH
112237: LD_VAR 0 4
112241: PUSH
112242: LD_VAR 0 7
112246: ARRAY
112247: PPUSH
112248: CALL_OW 247
112252: PUSH
112253: LD_INT 1
112255: EQUAL
112256: AND
112257: IFFALSE 112735
// begin if group [ i ] in healers then
112259: LD_VAR 0 4
112263: PUSH
112264: LD_VAR 0 7
112268: ARRAY
112269: PUSH
112270: LD_VAR 0 31
112274: IN
112275: IFFALSE 112548
// begin if not IsInArea ( group [ i ] , f_heal ) and not HasTask ( group [ i ] ) then
112277: LD_VAR 0 4
112281: PUSH
112282: LD_VAR 0 7
112286: ARRAY
112287: PPUSH
112288: LD_VAR 0 23
112292: PPUSH
112293: CALL_OW 308
112297: NOT
112298: PUSH
112299: LD_VAR 0 4
112303: PUSH
112304: LD_VAR 0 7
112308: ARRAY
112309: PPUSH
112310: CALL_OW 314
112314: NOT
112315: AND
112316: IFFALSE 112340
// ComMoveToArea ( group [ i ] , f_heal ) else
112318: LD_VAR 0 4
112322: PUSH
112323: LD_VAR 0 7
112327: ARRAY
112328: PPUSH
112329: LD_VAR 0 23
112333: PPUSH
112334: CALL_OW 113
112338: GO 112546
// if GetLives ( HealTarget ( group [ i ] ) ) = 1000 then
112340: LD_VAR 0 4
112344: PUSH
112345: LD_VAR 0 7
112349: ARRAY
112350: PPUSH
112351: CALL 86097 0 1
112355: PPUSH
112356: CALL_OW 256
112360: PUSH
112361: LD_INT 1000
112363: EQUAL
112364: IFFALSE 112383
// ComStop ( group [ i ] ) else
112366: LD_VAR 0 4
112370: PUSH
112371: LD_VAR 0 7
112375: ARRAY
112376: PPUSH
112377: CALL_OW 141
112381: GO 112546
// if not HasTask ( group [ i ] ) and to_heal then
112383: LD_VAR 0 4
112387: PUSH
112388: LD_VAR 0 7
112392: ARRAY
112393: PPUSH
112394: CALL_OW 314
112398: NOT
112399: PUSH
112400: LD_VAR 0 30
112404: AND
112405: IFFALSE 112546
// begin z := NearestUnitToUnit ( UnitFilter ( to_heal , [ f_not , [ f_inside ] ] ) , group [ i ] ) ;
112407: LD_ADDR_VAR 0 13
112411: PUSH
112412: LD_VAR 0 30
112416: PPUSH
112417: LD_INT 3
112419: PUSH
112420: LD_INT 54
112422: PUSH
112423: EMPTY
112424: LIST
112425: PUSH
112426: EMPTY
112427: LIST
112428: LIST
112429: PPUSH
112430: CALL_OW 72
112434: PPUSH
112435: LD_VAR 0 4
112439: PUSH
112440: LD_VAR 0 7
112444: ARRAY
112445: PPUSH
112446: CALL_OW 74
112450: ST_TO_ADDR
// if z then
112451: LD_VAR 0 13
112455: IFFALSE 112546
// if FilterAllUnits ( [ [ f_dist , z , 10 ] , [ f_enemy , GetSide ( z ) ] ] ) = 0 then
112457: LD_INT 91
112459: PUSH
112460: LD_VAR 0 13
112464: PUSH
112465: LD_INT 10
112467: PUSH
112468: EMPTY
112469: LIST
112470: LIST
112471: LIST
112472: PUSH
112473: LD_INT 81
112475: PUSH
112476: LD_VAR 0 13
112480: PPUSH
112481: CALL_OW 255
112485: PUSH
112486: EMPTY
112487: LIST
112488: LIST
112489: PUSH
112490: EMPTY
112491: LIST
112492: LIST
112493: PPUSH
112494: CALL_OW 69
112498: PUSH
112499: LD_INT 0
112501: EQUAL
112502: IFFALSE 112526
// ComHeal ( group [ i ] , z ) else
112504: LD_VAR 0 4
112508: PUSH
112509: LD_VAR 0 7
112513: ARRAY
112514: PPUSH
112515: LD_VAR 0 13
112519: PPUSH
112520: CALL_OW 128
112524: GO 112546
// ComMoveToArea ( group [ i ] , f_heal ) ;
112526: LD_VAR 0 4
112530: PUSH
112531: LD_VAR 0 7
112535: ARRAY
112536: PPUSH
112537: LD_VAR 0 23
112541: PPUSH
112542: CALL_OW 113
// end ; continue ;
112546: GO 111577
// end ; if GetLives ( group [ i ] ) < 700 and not group [ i ] in to_heal then
112548: LD_VAR 0 4
112552: PUSH
112553: LD_VAR 0 7
112557: ARRAY
112558: PPUSH
112559: CALL_OW 256
112563: PUSH
112564: LD_INT 700
112566: LESS
112567: PUSH
112568: LD_VAR 0 4
112572: PUSH
112573: LD_VAR 0 7
112577: ARRAY
112578: PUSH
112579: LD_VAR 0 30
112583: IN
112584: NOT
112585: AND
112586: IFFALSE 112610
// to_heal := to_heal union group [ i ] ;
112588: LD_ADDR_VAR 0 30
112592: PUSH
112593: LD_VAR 0 30
112597: PUSH
112598: LD_VAR 0 4
112602: PUSH
112603: LD_VAR 0 7
112607: ARRAY
112608: UNION
112609: ST_TO_ADDR
// if group [ i ] in to_heal then
112610: LD_VAR 0 4
112614: PUSH
112615: LD_VAR 0 7
112619: ARRAY
112620: PUSH
112621: LD_VAR 0 30
112625: IN
112626: IFFALSE 112735
// begin if GetLives ( group [ i ] ) = 1000 then
112628: LD_VAR 0 4
112632: PUSH
112633: LD_VAR 0 7
112637: ARRAY
112638: PPUSH
112639: CALL_OW 256
112643: PUSH
112644: LD_INT 1000
112646: EQUAL
112647: IFFALSE 112673
// to_heal := to_heal diff group [ i ] else
112649: LD_ADDR_VAR 0 30
112653: PUSH
112654: LD_VAR 0 30
112658: PUSH
112659: LD_VAR 0 4
112663: PUSH
112664: LD_VAR 0 7
112668: ARRAY
112669: DIFF
112670: ST_TO_ADDR
112671: GO 112735
// begin if not IsInArea ( group [ i ] , to_heal ) then
112673: LD_VAR 0 4
112677: PUSH
112678: LD_VAR 0 7
112682: ARRAY
112683: PPUSH
112684: LD_VAR 0 30
112688: PPUSH
112689: CALL_OW 308
112693: NOT
112694: IFFALSE 112718
// ComMoveToArea ( group [ i ] , f_heal ) else
112696: LD_VAR 0 4
112700: PUSH
112701: LD_VAR 0 7
112705: ARRAY
112706: PPUSH
112707: LD_VAR 0 23
112711: PPUSH
112712: CALL_OW 113
112716: GO 112733
// ComHold ( group [ i ] ) ;
112718: LD_VAR 0 4
112722: PUSH
112723: LD_VAR 0 7
112727: ARRAY
112728: PPUSH
112729: CALL_OW 140
// continue ;
112733: GO 111577
// end ; end ; end ; if not EnemyInRange ( group [ i ] , 10 ) and not units_path [ i ] = [ ] then
112735: LD_VAR 0 4
112739: PUSH
112740: LD_VAR 0 7
112744: ARRAY
112745: PPUSH
112746: LD_INT 10
112748: PPUSH
112749: CALL 84517 0 2
112753: NOT
112754: PUSH
112755: LD_VAR 0 16
112759: PUSH
112760: LD_VAR 0 7
112764: ARRAY
112765: PUSH
112766: EMPTY
112767: EQUAL
112768: NOT
112769: AND
112770: IFFALSE 113036
// begin if GetEngine ( group [ i ] ) in [ engine_combustion , engine_solar ] then
112772: LD_VAR 0 4
112776: PUSH
112777: LD_VAR 0 7
112781: ARRAY
112782: PPUSH
112783: CALL_OW 262
112787: PUSH
112788: LD_INT 1
112790: PUSH
112791: LD_INT 2
112793: PUSH
112794: EMPTY
112795: LIST
112796: LIST
112797: IN
112798: IFFALSE 112839
// if GetFuel ( group [ i ] ) < 10 then
112800: LD_VAR 0 4
112804: PUSH
112805: LD_VAR 0 7
112809: ARRAY
112810: PPUSH
112811: CALL_OW 261
112815: PUSH
112816: LD_INT 10
112818: LESS
112819: IFFALSE 112839
// SetFuel ( group [ i ] , 12 ) ;
112821: LD_VAR 0 4
112825: PUSH
112826: LD_VAR 0 7
112830: ARRAY
112831: PPUSH
112832: LD_INT 12
112834: PPUSH
112835: CALL_OW 240
// if units_path [ i ] then
112839: LD_VAR 0 16
112843: PUSH
112844: LD_VAR 0 7
112848: ARRAY
112849: IFFALSE 113034
// begin if GetDistUnitXY ( group [ i ] , units_path [ i ] [ 1 ] [ 1 ] , units_path [ i ] [ 1 ] [ 2 ] ) > 6 then
112851: LD_VAR 0 4
112855: PUSH
112856: LD_VAR 0 7
112860: ARRAY
112861: PPUSH
112862: LD_VAR 0 16
112866: PUSH
112867: LD_VAR 0 7
112871: ARRAY
112872: PUSH
112873: LD_INT 1
112875: ARRAY
112876: PUSH
112877: LD_INT 1
112879: ARRAY
112880: PPUSH
112881: LD_VAR 0 16
112885: PUSH
112886: LD_VAR 0 7
112890: ARRAY
112891: PUSH
112892: LD_INT 1
112894: ARRAY
112895: PUSH
112896: LD_INT 2
112898: ARRAY
112899: PPUSH
112900: CALL_OW 297
112904: PUSH
112905: LD_INT 6
112907: GREATER
112908: IFFALSE 112983
// begin if not HasTask ( group [ i ] ) then
112910: LD_VAR 0 4
112914: PUSH
112915: LD_VAR 0 7
112919: ARRAY
112920: PPUSH
112921: CALL_OW 314
112925: NOT
112926: IFFALSE 112981
// ComAgressiveMove ( group [ i ] , units_path [ i ] [ 1 ] [ 1 ] , units_path [ i ] [ 1 ] [ 2 ] ) ;
112928: LD_VAR 0 4
112932: PUSH
112933: LD_VAR 0 7
112937: ARRAY
112938: PPUSH
112939: LD_VAR 0 16
112943: PUSH
112944: LD_VAR 0 7
112948: ARRAY
112949: PUSH
112950: LD_INT 1
112952: ARRAY
112953: PUSH
112954: LD_INT 1
112956: ARRAY
112957: PPUSH
112958: LD_VAR 0 16
112962: PUSH
112963: LD_VAR 0 7
112967: ARRAY
112968: PUSH
112969: LD_INT 1
112971: ARRAY
112972: PUSH
112973: LD_INT 2
112975: ARRAY
112976: PPUSH
112977: CALL_OW 114
// end else
112981: GO 113034
// begin tmp2 := Delete ( units_path [ i ] , 1 ) ;
112983: LD_ADDR_VAR 0 15
112987: PUSH
112988: LD_VAR 0 16
112992: PUSH
112993: LD_VAR 0 7
112997: ARRAY
112998: PPUSH
112999: LD_INT 1
113001: PPUSH
113002: CALL_OW 3
113006: ST_TO_ADDR
// units_path := Replace ( units_path , i , tmp2 ) ;
113007: LD_ADDR_VAR 0 16
113011: PUSH
113012: LD_VAR 0 16
113016: PPUSH
113017: LD_VAR 0 7
113021: PPUSH
113022: LD_VAR 0 15
113026: PPUSH
113027: CALL_OW 1
113031: ST_TO_ADDR
// continue ;
113032: GO 111577
// end ; end ; end else
113034: GO 115698
// begin tmp := FilterAllUnits ( [ f_enemy , GetSide ( group [ i ] ) ] ) ;
113036: LD_ADDR_VAR 0 14
113040: PUSH
113041: LD_INT 81
113043: PUSH
113044: LD_VAR 0 4
113048: PUSH
113049: LD_VAR 0 7
113053: ARRAY
113054: PPUSH
113055: CALL_OW 255
113059: PUSH
113060: EMPTY
113061: LIST
113062: LIST
113063: PPUSH
113064: CALL_OW 69
113068: ST_TO_ADDR
// if not tmp then
113069: LD_VAR 0 14
113073: NOT
113074: IFFALSE 113078
// continue ;
113076: GO 111577
// if f_ignore_area then
113078: LD_VAR 0 17
113082: IFFALSE 113170
// begin tmp2 := UnitFilter ( tmp , [ f_not , [ f_distxy , f_ignore_area [ 1 ] , f_ignore_area [ 2 ] , f_ignore_area [ 3 ] ] ] ) ;
113084: LD_ADDR_VAR 0 15
113088: PUSH
113089: LD_VAR 0 14
113093: PPUSH
113094: LD_INT 3
113096: PUSH
113097: LD_INT 92
113099: PUSH
113100: LD_VAR 0 17
113104: PUSH
113105: LD_INT 1
113107: ARRAY
113108: PUSH
113109: LD_VAR 0 17
113113: PUSH
113114: LD_INT 2
113116: ARRAY
113117: PUSH
113118: LD_VAR 0 17
113122: PUSH
113123: LD_INT 3
113125: ARRAY
113126: PUSH
113127: EMPTY
113128: LIST
113129: LIST
113130: LIST
113131: LIST
113132: PUSH
113133: EMPTY
113134: LIST
113135: LIST
113136: PPUSH
113137: CALL_OW 72
113141: ST_TO_ADDR
// if ( tmp diff tmp2 ) then
113142: LD_VAR 0 14
113146: PUSH
113147: LD_VAR 0 15
113151: DIFF
113152: IFFALSE 113170
// tmp := tmp diff tmp2 ;
113154: LD_ADDR_VAR 0 14
113158: PUSH
113159: LD_VAR 0 14
113163: PUSH
113164: LD_VAR 0 15
113168: DIFF
113169: ST_TO_ADDR
// end ; if not f_murder then
113170: LD_VAR 0 20
113174: NOT
113175: IFFALSE 113233
// begin tmp2 := UnitFilter ( tmp , [ f_not , [ f_ok ] ] ) ;
113177: LD_ADDR_VAR 0 15
113181: PUSH
113182: LD_VAR 0 14
113186: PPUSH
113187: LD_INT 3
113189: PUSH
113190: LD_INT 50
113192: PUSH
113193: EMPTY
113194: LIST
113195: PUSH
113196: EMPTY
113197: LIST
113198: LIST
113199: PPUSH
113200: CALL_OW 72
113204: ST_TO_ADDR
// if ( tmp diff tmp2 ) then
113205: LD_VAR 0 14
113209: PUSH
113210: LD_VAR 0 15
113214: DIFF
113215: IFFALSE 113233
// tmp := tmp diff tmp2 ;
113217: LD_ADDR_VAR 0 14
113221: PUSH
113222: LD_VAR 0 14
113226: PUSH
113227: LD_VAR 0 15
113231: DIFF
113232: ST_TO_ADDR
// end ; tmp := SortByDistanceUnit ( group [ i ] , tmp , true , true ) ;
113233: LD_ADDR_VAR 0 14
113237: PUSH
113238: LD_VAR 0 4
113242: PUSH
113243: LD_VAR 0 7
113247: ARRAY
113248: PPUSH
113249: LD_VAR 0 14
113253: PPUSH
113254: LD_INT 1
113256: PPUSH
113257: LD_INT 1
113259: PPUSH
113260: CALL 57452 0 4
113264: ST_TO_ADDR
// if GetClass ( group [ i ] ) = 1 then
113265: LD_VAR 0 4
113269: PUSH
113270: LD_VAR 0 7
113274: ARRAY
113275: PPUSH
113276: CALL_OW 257
113280: PUSH
113281: LD_INT 1
113283: EQUAL
113284: IFFALSE 113732
// begin if WantPlant ( group [ i ] ) then
113286: LD_VAR 0 4
113290: PUSH
113291: LD_VAR 0 7
113295: ARRAY
113296: PPUSH
113297: CALL 56953 0 1
113301: IFFALSE 113305
// continue ;
113303: GO 111577
// if f_capture and not IsInUnit ( group [ i ] ) and tmp [ 1 ] in UnitFilter ( tmp , [ [ f_type , unit_vehicle ] , [ f_empty ] ] ) then
113305: LD_VAR 0 18
113309: PUSH
113310: LD_VAR 0 4
113314: PUSH
113315: LD_VAR 0 7
113319: ARRAY
113320: PPUSH
113321: CALL_OW 310
113325: NOT
113326: AND
113327: PUSH
113328: LD_VAR 0 14
113332: PUSH
113333: LD_INT 1
113335: ARRAY
113336: PUSH
113337: LD_VAR 0 14
113341: PPUSH
113342: LD_INT 21
113344: PUSH
113345: LD_INT 2
113347: PUSH
113348: EMPTY
113349: LIST
113350: LIST
113351: PUSH
113352: LD_INT 58
113354: PUSH
113355: EMPTY
113356: LIST
113357: PUSH
113358: EMPTY
113359: LIST
113360: LIST
113361: PPUSH
113362: CALL_OW 72
113366: IN
113367: AND
113368: IFFALSE 113404
// begin ComEnterUnit ( group [ i ] , tmp [ 1 ] ) ;
113370: LD_VAR 0 4
113374: PUSH
113375: LD_VAR 0 7
113379: ARRAY
113380: PPUSH
113381: LD_VAR 0 14
113385: PUSH
113386: LD_INT 1
113388: ARRAY
113389: PPUSH
113390: CALL_OW 120
// attacking := true ;
113394: LD_ADDR_VAR 0 29
113398: PUSH
113399: LD_INT 1
113401: ST_TO_ADDR
// continue ;
113402: GO 111577
// end ; if f_crawl and GetClass ( group [ i ] ) = 1 and GetLives ( group [ i ] ) < 800 and not Crawls ( group [ i ] ) then
113404: LD_VAR 0 26
113408: PUSH
113409: LD_VAR 0 4
113413: PUSH
113414: LD_VAR 0 7
113418: ARRAY
113419: PPUSH
113420: CALL_OW 257
113424: PUSH
113425: LD_INT 1
113427: EQUAL
113428: AND
113429: PUSH
113430: LD_VAR 0 4
113434: PUSH
113435: LD_VAR 0 7
113439: ARRAY
113440: PPUSH
113441: CALL_OW 256
113445: PUSH
113446: LD_INT 800
113448: LESS
113449: AND
113450: PUSH
113451: LD_VAR 0 4
113455: PUSH
113456: LD_VAR 0 7
113460: ARRAY
113461: PPUSH
113462: CALL_OW 318
113466: NOT
113467: AND
113468: IFFALSE 113485
// ComCrawl ( group [ i ] ) ;
113470: LD_VAR 0 4
113474: PUSH
113475: LD_VAR 0 7
113479: ARRAY
113480: PPUSH
113481: CALL_OW 137
// if f_mines then
113485: LD_VAR 0 21
113489: IFFALSE 113732
// begin if GetType ( tmp [ 1 ] ) = unit_building and not tmp [ 1 ] in mined then
113491: LD_VAR 0 14
113495: PUSH
113496: LD_INT 1
113498: ARRAY
113499: PPUSH
113500: CALL_OW 247
113504: PUSH
113505: LD_INT 3
113507: EQUAL
113508: PUSH
113509: LD_VAR 0 14
113513: PUSH
113514: LD_INT 1
113516: ARRAY
113517: PUSH
113518: LD_VAR 0 27
113522: IN
113523: NOT
113524: AND
113525: IFFALSE 113732
// begin x := GetX ( tmp [ 1 ] ) ;
113527: LD_ADDR_VAR 0 10
113531: PUSH
113532: LD_VAR 0 14
113536: PUSH
113537: LD_INT 1
113539: ARRAY
113540: PPUSH
113541: CALL_OW 250
113545: ST_TO_ADDR
// y := GetY ( tmp [ 1 ] ) ;
113546: LD_ADDR_VAR 0 11
113550: PUSH
113551: LD_VAR 0 14
113555: PUSH
113556: LD_INT 1
113558: ARRAY
113559: PPUSH
113560: CALL_OW 251
113564: ST_TO_ADDR
// d := ReverseDir ( group [ i ] ) ;
113565: LD_ADDR_VAR 0 12
113569: PUSH
113570: LD_VAR 0 4
113574: PUSH
113575: LD_VAR 0 7
113579: ARRAY
113580: PPUSH
113581: CALL 84602 0 1
113585: ST_TO_ADDR
// ComPlaceDelayedCharge ( group [ i ] , x , y , tmp [ 1 ] ) ;
113586: LD_VAR 0 4
113590: PUSH
113591: LD_VAR 0 7
113595: ARRAY
113596: PPUSH
113597: LD_VAR 0 10
113601: PPUSH
113602: LD_VAR 0 11
113606: PPUSH
113607: LD_VAR 0 14
113611: PUSH
113612: LD_INT 1
113614: ARRAY
113615: PPUSH
113616: CALL_OW 132
// AddComMoveXY ( group [ i ] , ShiftX ( x , d , 7 ) , ShiftY ( y , d , 7 ) ) ;
113620: LD_VAR 0 4
113624: PUSH
113625: LD_VAR 0 7
113629: ARRAY
113630: PPUSH
113631: LD_VAR 0 10
113635: PPUSH
113636: LD_VAR 0 12
113640: PPUSH
113641: LD_INT 7
113643: PPUSH
113644: CALL_OW 272
113648: PPUSH
113649: LD_VAR 0 11
113653: PPUSH
113654: LD_VAR 0 12
113658: PPUSH
113659: LD_INT 7
113661: PPUSH
113662: CALL_OW 273
113666: PPUSH
113667: CALL_OW 171
// SetTag ( group [ i ] , 71 ) ;
113671: LD_VAR 0 4
113675: PUSH
113676: LD_VAR 0 7
113680: ARRAY
113681: PPUSH
113682: LD_INT 71
113684: PPUSH
113685: CALL_OW 109
// mined := Replace ( mined , mined + 1 , tmp [ 1 ] ) ;
113689: LD_ADDR_VAR 0 27
113693: PUSH
113694: LD_VAR 0 27
113698: PPUSH
113699: LD_VAR 0 27
113703: PUSH
113704: LD_INT 1
113706: PLUS
113707: PPUSH
113708: LD_VAR 0 14
113712: PUSH
113713: LD_INT 1
113715: ARRAY
113716: PPUSH
113717: CALL_OW 1
113721: ST_TO_ADDR
// attacking := true ;
113722: LD_ADDR_VAR 0 29
113726: PUSH
113727: LD_INT 1
113729: ST_TO_ADDR
// continue ;
113730: GO 111577
// end ; end ; end ; if GetClass ( group [ i ] ) = 17 and not GetTag ( group [ i ] ) = 71 then
113732: LD_VAR 0 4
113736: PUSH
113737: LD_VAR 0 7
113741: ARRAY
113742: PPUSH
113743: CALL_OW 257
113747: PUSH
113748: LD_INT 17
113750: EQUAL
113751: PUSH
113752: LD_VAR 0 4
113756: PUSH
113757: LD_VAR 0 7
113761: ARRAY
113762: PPUSH
113763: CALL_OW 110
113767: PUSH
113768: LD_INT 71
113770: EQUAL
113771: NOT
113772: AND
113773: IFFALSE 113919
// begin attacking := false ;
113775: LD_ADDR_VAR 0 29
113779: PUSH
113780: LD_INT 0
113782: ST_TO_ADDR
// k := 5 ;
113783: LD_ADDR_VAR 0 9
113787: PUSH
113788: LD_INT 5
113790: ST_TO_ADDR
// if tmp < k then
113791: LD_VAR 0 14
113795: PUSH
113796: LD_VAR 0 9
113800: LESS
113801: IFFALSE 113813
// k := tmp ;
113803: LD_ADDR_VAR 0 9
113807: PUSH
113808: LD_VAR 0 14
113812: ST_TO_ADDR
// for j = 1 to k do
113813: LD_ADDR_VAR 0 8
113817: PUSH
113818: DOUBLE
113819: LD_INT 1
113821: DEC
113822: ST_TO_ADDR
113823: LD_VAR 0 9
113827: PUSH
113828: FOR_TO
113829: IFFALSE 113917
// begin if not tmp [ j ] in UnitFilter ( tmp , [ f_empty ] ) then
113831: LD_VAR 0 14
113835: PUSH
113836: LD_VAR 0 8
113840: ARRAY
113841: PUSH
113842: LD_VAR 0 14
113846: PPUSH
113847: LD_INT 58
113849: PUSH
113850: EMPTY
113851: LIST
113852: PPUSH
113853: CALL_OW 72
113857: IN
113858: NOT
113859: IFFALSE 113915
// begin ComAttackUnit ( group [ i ] , tmp [ j ] ) ;
113861: LD_VAR 0 4
113865: PUSH
113866: LD_VAR 0 7
113870: ARRAY
113871: PPUSH
113872: LD_VAR 0 14
113876: PUSH
113877: LD_VAR 0 8
113881: ARRAY
113882: PPUSH
113883: CALL_OW 115
// attacking := true ;
113887: LD_ADDR_VAR 0 29
113891: PUSH
113892: LD_INT 1
113894: ST_TO_ADDR
// SetTag ( group [ i ] , 71 ) ;
113895: LD_VAR 0 4
113899: PUSH
113900: LD_VAR 0 7
113904: ARRAY
113905: PPUSH
113906: LD_INT 71
113908: PPUSH
113909: CALL_OW 109
// continue ;
113913: GO 113828
// end ; end ;
113915: GO 113828
113917: POP
113918: POP
// end ; if GetClass ( group [ i ] ) = 8 or GetWeapon ( group [ i ] ) in [ ar_rocket_launcher , ru_rocket_launcher , us_rocket_launcher , ru_rocket ] then
113919: LD_VAR 0 4
113923: PUSH
113924: LD_VAR 0 7
113928: ARRAY
113929: PPUSH
113930: CALL_OW 257
113934: PUSH
113935: LD_INT 8
113937: EQUAL
113938: PUSH
113939: LD_VAR 0 4
113943: PUSH
113944: LD_VAR 0 7
113948: ARRAY
113949: PPUSH
113950: CALL_OW 264
113954: PUSH
113955: LD_INT 28
113957: PUSH
113958: LD_INT 45
113960: PUSH
113961: LD_INT 7
113963: PUSH
113964: LD_INT 47
113966: PUSH
113967: EMPTY
113968: LIST
113969: LIST
113970: LIST
113971: LIST
113972: IN
113973: OR
113974: IFFALSE 114230
// begin attacking := false ;
113976: LD_ADDR_VAR 0 29
113980: PUSH
113981: LD_INT 0
113983: ST_TO_ADDR
// if GetBType ( tmp [ 1 ] ) in [ b_bunker , b_breastwork , b_turret , b_armoury , b_barracks ] then
113984: LD_VAR 0 14
113988: PUSH
113989: LD_INT 1
113991: ARRAY
113992: PPUSH
113993: CALL_OW 266
113997: PUSH
113998: LD_INT 32
114000: PUSH
114001: LD_INT 31
114003: PUSH
114004: LD_INT 33
114006: PUSH
114007: LD_INT 4
114009: PUSH
114010: LD_INT 5
114012: PUSH
114013: EMPTY
114014: LIST
114015: LIST
114016: LIST
114017: LIST
114018: LIST
114019: IN
114020: IFFALSE 114206
// begin k := GetBuildingHexes ( GetBType ( tmp [ 1 ] ) , GetX ( tmp [ 1 ] ) , GetY ( tmp [ 1 ] ) , GetDir ( tmp [ 1 ] ) , GetNation ( tmp [ 1 ] ) , 0 ) ;
114022: LD_ADDR_VAR 0 9
114026: PUSH
114027: LD_VAR 0 14
114031: PUSH
114032: LD_INT 1
114034: ARRAY
114035: PPUSH
114036: CALL_OW 266
114040: PPUSH
114041: LD_VAR 0 14
114045: PUSH
114046: LD_INT 1
114048: ARRAY
114049: PPUSH
114050: CALL_OW 250
114054: PPUSH
114055: LD_VAR 0 14
114059: PUSH
114060: LD_INT 1
114062: ARRAY
114063: PPUSH
114064: CALL_OW 251
114068: PPUSH
114069: LD_VAR 0 14
114073: PUSH
114074: LD_INT 1
114076: ARRAY
114077: PPUSH
114078: CALL_OW 254
114082: PPUSH
114083: LD_VAR 0 14
114087: PUSH
114088: LD_INT 1
114090: ARRAY
114091: PPUSH
114092: CALL_OW 248
114096: PPUSH
114097: LD_INT 0
114099: PPUSH
114100: CALL 65972 0 6
114104: ST_TO_ADDR
// j := GetClosestHex ( group [ i ] , k ) ;
114105: LD_ADDR_VAR 0 8
114109: PUSH
114110: LD_VAR 0 4
114114: PUSH
114115: LD_VAR 0 7
114119: ARRAY
114120: PPUSH
114121: LD_VAR 0 9
114125: PPUSH
114126: CALL 84642 0 2
114130: ST_TO_ADDR
// if j then
114131: LD_VAR 0 8
114135: IFFALSE 114204
// if ValidHex ( j [ 1 ] , j [ 2 ] ) then
114137: LD_VAR 0 8
114141: PUSH
114142: LD_INT 1
114144: ARRAY
114145: PPUSH
114146: LD_VAR 0 8
114150: PUSH
114151: LD_INT 2
114153: ARRAY
114154: PPUSH
114155: CALL_OW 488
114159: IFFALSE 114204
// begin ComAttackPlace ( group [ i ] , j [ 1 ] , j [ 2 ] ) ;
114161: LD_VAR 0 4
114165: PUSH
114166: LD_VAR 0 7
114170: ARRAY
114171: PPUSH
114172: LD_VAR 0 8
114176: PUSH
114177: LD_INT 1
114179: ARRAY
114180: PPUSH
114181: LD_VAR 0 8
114185: PUSH
114186: LD_INT 2
114188: ARRAY
114189: PPUSH
114190: CALL_OW 116
// attacking := true ;
114194: LD_ADDR_VAR 0 29
114198: PUSH
114199: LD_INT 1
114201: ST_TO_ADDR
// continue ;
114202: GO 111577
// end ; end else
114204: GO 114230
// ComAttackUnit ( group [ i ] , tmp [ 1 ] ) ;
114206: LD_VAR 0 4
114210: PUSH
114211: LD_VAR 0 7
114215: ARRAY
114216: PPUSH
114217: LD_VAR 0 14
114221: PUSH
114222: LD_INT 1
114224: ARRAY
114225: PPUSH
114226: CALL_OW 115
// end ; if GetChassis ( group [ i ] ) = ar_hovercraft then
114230: LD_VAR 0 4
114234: PUSH
114235: LD_VAR 0 7
114239: ARRAY
114240: PPUSH
114241: CALL_OW 265
114245: PUSH
114246: LD_INT 11
114248: EQUAL
114249: IFFALSE 114527
// begin k := 10 ;
114251: LD_ADDR_VAR 0 9
114255: PUSH
114256: LD_INT 10
114258: ST_TO_ADDR
// x := 0 ;
114259: LD_ADDR_VAR 0 10
114263: PUSH
114264: LD_INT 0
114266: ST_TO_ADDR
// if tmp < k then
114267: LD_VAR 0 14
114271: PUSH
114272: LD_VAR 0 9
114276: LESS
114277: IFFALSE 114289
// k := tmp ;
114279: LD_ADDR_VAR 0 9
114283: PUSH
114284: LD_VAR 0 14
114288: ST_TO_ADDR
// for j = k downto 1 do
114289: LD_ADDR_VAR 0 8
114293: PUSH
114294: DOUBLE
114295: LD_VAR 0 9
114299: INC
114300: ST_TO_ADDR
114301: LD_INT 1
114303: PUSH
114304: FOR_DOWNTO
114305: IFFALSE 114380
// begin if GetType ( tmp [ j ] ) = unit_human then
114307: LD_VAR 0 14
114311: PUSH
114312: LD_VAR 0 8
114316: ARRAY
114317: PPUSH
114318: CALL_OW 247
114322: PUSH
114323: LD_INT 1
114325: EQUAL
114326: IFFALSE 114378
// begin AttackHovercraft ( group [ i ] , tmp [ j ] ) ;
114328: LD_VAR 0 4
114332: PUSH
114333: LD_VAR 0 7
114337: ARRAY
114338: PPUSH
114339: LD_VAR 0 14
114343: PUSH
114344: LD_VAR 0 8
114348: ARRAY
114349: PPUSH
114350: CALL 84913 0 2
// x := tmp [ j ] ;
114354: LD_ADDR_VAR 0 10
114358: PUSH
114359: LD_VAR 0 14
114363: PUSH
114364: LD_VAR 0 8
114368: ARRAY
114369: ST_TO_ADDR
// attacking := true ;
114370: LD_ADDR_VAR 0 29
114374: PUSH
114375: LD_INT 1
114377: ST_TO_ADDR
// end ; end ;
114378: GO 114304
114380: POP
114381: POP
// if not x then
114382: LD_VAR 0 10
114386: NOT
114387: IFFALSE 114527
// begin attacking := true ;
114389: LD_ADDR_VAR 0 29
114393: PUSH
114394: LD_INT 1
114396: ST_TO_ADDR
// if GetHexInfo ( GetX ( group [ i ] ) , GetY ( group [ i ] ) ) [ 2 ] = GetHexInfo ( GetX ( tmp [ 1 ] ) , GetY ( tmp [ 1 ] ) ) [ 2 ] then
114397: LD_VAR 0 4
114401: PUSH
114402: LD_VAR 0 7
114406: ARRAY
114407: PPUSH
114408: CALL_OW 250
114412: PPUSH
114413: LD_VAR 0 4
114417: PUSH
114418: LD_VAR 0 7
114422: ARRAY
114423: PPUSH
114424: CALL_OW 251
114428: PPUSH
114429: CALL_OW 546
114433: PUSH
114434: LD_INT 2
114436: ARRAY
114437: PUSH
114438: LD_VAR 0 14
114442: PUSH
114443: LD_INT 1
114445: ARRAY
114446: PPUSH
114447: CALL_OW 250
114451: PPUSH
114452: LD_VAR 0 14
114456: PUSH
114457: LD_INT 1
114459: ARRAY
114460: PPUSH
114461: CALL_OW 251
114465: PPUSH
114466: CALL_OW 546
114470: PUSH
114471: LD_INT 2
114473: ARRAY
114474: EQUAL
114475: IFFALSE 114503
// AttackHovercraft ( group [ i ] , tmp [ 1 ] ) else
114477: LD_VAR 0 4
114481: PUSH
114482: LD_VAR 0 7
114486: ARRAY
114487: PPUSH
114488: LD_VAR 0 14
114492: PUSH
114493: LD_INT 1
114495: ARRAY
114496: PPUSH
114497: CALL 84913 0 2
114501: GO 114527
// ComAttackUnit ( group [ i ] , tmp [ 1 ] ) ;
114503: LD_VAR 0 4
114507: PUSH
114508: LD_VAR 0 7
114512: ARRAY
114513: PPUSH
114514: LD_VAR 0 14
114518: PUSH
114519: LD_INT 1
114521: ARRAY
114522: PPUSH
114523: CALL_OW 115
// end ; end ; if GetWeapon ( group [ i ] ) = ar_selfpropelled_bomb then
114527: LD_VAR 0 4
114531: PUSH
114532: LD_VAR 0 7
114536: ARRAY
114537: PPUSH
114538: CALL_OW 264
114542: PUSH
114543: LD_INT 29
114545: EQUAL
114546: IFFALSE 114912
// begin if WantsToAttack ( group [ i ] ) in bombed then
114548: LD_VAR 0 4
114552: PUSH
114553: LD_VAR 0 7
114557: ARRAY
114558: PPUSH
114559: CALL_OW 319
114563: PUSH
114564: LD_VAR 0 28
114568: IN
114569: IFFALSE 114573
// continue ;
114571: GO 111577
// k := 8 ;
114573: LD_ADDR_VAR 0 9
114577: PUSH
114578: LD_INT 8
114580: ST_TO_ADDR
// x := 0 ;
114581: LD_ADDR_VAR 0 10
114585: PUSH
114586: LD_INT 0
114588: ST_TO_ADDR
// if tmp < k then
114589: LD_VAR 0 14
114593: PUSH
114594: LD_VAR 0 9
114598: LESS
114599: IFFALSE 114611
// k := tmp ;
114601: LD_ADDR_VAR 0 9
114605: PUSH
114606: LD_VAR 0 14
114610: ST_TO_ADDR
// for j = 1 to k do
114611: LD_ADDR_VAR 0 8
114615: PUSH
114616: DOUBLE
114617: LD_INT 1
114619: DEC
114620: ST_TO_ADDR
114621: LD_VAR 0 9
114625: PUSH
114626: FOR_TO
114627: IFFALSE 114759
// begin if GetType ( tmp [ j ] ) = unit_building then
114629: LD_VAR 0 14
114633: PUSH
114634: LD_VAR 0 8
114638: ARRAY
114639: PPUSH
114640: CALL_OW 247
114644: PUSH
114645: LD_INT 3
114647: EQUAL
114648: IFFALSE 114757
// if not tmp [ j ] in bombed and UnitsInside ( tmp [ j ] ) then
114650: LD_VAR 0 14
114654: PUSH
114655: LD_VAR 0 8
114659: ARRAY
114660: PUSH
114661: LD_VAR 0 28
114665: IN
114666: NOT
114667: PUSH
114668: LD_VAR 0 14
114672: PUSH
114673: LD_VAR 0 8
114677: ARRAY
114678: PPUSH
114679: CALL_OW 313
114683: AND
114684: IFFALSE 114757
// begin ComAttackUnit ( group [ i ] , tmp [ j ] ) ;
114686: LD_VAR 0 4
114690: PUSH
114691: LD_VAR 0 7
114695: ARRAY
114696: PPUSH
114697: LD_VAR 0 14
114701: PUSH
114702: LD_VAR 0 8
114706: ARRAY
114707: PPUSH
114708: CALL_OW 115
// bombed := Replace ( bombed , bombed + 1 , tmp [ j ] ) ;
114712: LD_ADDR_VAR 0 28
114716: PUSH
114717: LD_VAR 0 28
114721: PPUSH
114722: LD_VAR 0 28
114726: PUSH
114727: LD_INT 1
114729: PLUS
114730: PPUSH
114731: LD_VAR 0 14
114735: PUSH
114736: LD_VAR 0 8
114740: ARRAY
114741: PPUSH
114742: CALL_OW 1
114746: ST_TO_ADDR
// attacking := true ;
114747: LD_ADDR_VAR 0 29
114751: PUSH
114752: LD_INT 1
114754: ST_TO_ADDR
// break ;
114755: GO 114759
// end ; end ;
114757: GO 114626
114759: POP
114760: POP
// if not attacking and f_attack_depot then
114761: LD_VAR 0 29
114765: NOT
114766: PUSH
114767: LD_VAR 0 25
114771: AND
114772: IFFALSE 114867
// begin z := UnitFilter ( tmp , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) ;
114774: LD_ADDR_VAR 0 13
114778: PUSH
114779: LD_VAR 0 14
114783: PPUSH
114784: LD_INT 2
114786: PUSH
114787: LD_INT 30
114789: PUSH
114790: LD_INT 0
114792: PUSH
114793: EMPTY
114794: LIST
114795: LIST
114796: PUSH
114797: LD_INT 30
114799: PUSH
114800: LD_INT 1
114802: PUSH
114803: EMPTY
114804: LIST
114805: LIST
114806: PUSH
114807: EMPTY
114808: LIST
114809: LIST
114810: LIST
114811: PPUSH
114812: CALL_OW 72
114816: ST_TO_ADDR
// if z then
114817: LD_VAR 0 13
114821: IFFALSE 114867
// begin ComAttackUnit ( group [ i ] , NearestUnitToUnit ( z , group [ i ] ) ) ;
114823: LD_VAR 0 4
114827: PUSH
114828: LD_VAR 0 7
114832: ARRAY
114833: PPUSH
114834: LD_VAR 0 13
114838: PPUSH
114839: LD_VAR 0 4
114843: PUSH
114844: LD_VAR 0 7
114848: ARRAY
114849: PPUSH
114850: CALL_OW 74
114854: PPUSH
114855: CALL_OW 115
// attacking := true ;
114859: LD_ADDR_VAR 0 29
114863: PUSH
114864: LD_INT 1
114866: ST_TO_ADDR
// end ; end ; if GetLives ( group [ i ] ) < 500 then
114867: LD_VAR 0 4
114871: PUSH
114872: LD_VAR 0 7
114876: ARRAY
114877: PPUSH
114878: CALL_OW 256
114882: PUSH
114883: LD_INT 500
114885: LESS
114886: IFFALSE 114912
// ComAttackUnit ( group [ i ] , tmp [ 1 ] ) ;
114888: LD_VAR 0 4
114892: PUSH
114893: LD_VAR 0 7
114897: ARRAY
114898: PPUSH
114899: LD_VAR 0 14
114903: PUSH
114904: LD_INT 1
114906: ARRAY
114907: PPUSH
114908: CALL_OW 115
// end ; if GetWeapon ( group [ i ] ) = ru_time_lapser then
114912: LD_VAR 0 4
114916: PUSH
114917: LD_VAR 0 7
114921: ARRAY
114922: PPUSH
114923: CALL_OW 264
114927: PUSH
114928: LD_INT 49
114930: EQUAL
114931: IFFALSE 115052
// begin if not HasTask ( group [ i ] ) then
114933: LD_VAR 0 4
114937: PUSH
114938: LD_VAR 0 7
114942: ARRAY
114943: PPUSH
114944: CALL_OW 314
114948: NOT
114949: IFFALSE 115052
// begin k := NearestUnitToUnit ( FilterAllUnits ( [ f_enemy , GetSide ( group [ i ] ) ] ) , group [ i ] ) ;
114951: LD_ADDR_VAR 0 9
114955: PUSH
114956: LD_INT 81
114958: PUSH
114959: LD_VAR 0 4
114963: PUSH
114964: LD_VAR 0 7
114968: ARRAY
114969: PPUSH
114970: CALL_OW 255
114974: PUSH
114975: EMPTY
114976: LIST
114977: LIST
114978: PPUSH
114979: CALL_OW 69
114983: PPUSH
114984: LD_VAR 0 4
114988: PUSH
114989: LD_VAR 0 7
114993: ARRAY
114994: PPUSH
114995: CALL_OW 74
114999: ST_TO_ADDR
// if k then
115000: LD_VAR 0 9
115004: IFFALSE 115052
// if GetDistUnits ( group [ i ] , k ) > 10 then
115006: LD_VAR 0 4
115010: PUSH
115011: LD_VAR 0 7
115015: ARRAY
115016: PPUSH
115017: LD_VAR 0 9
115021: PPUSH
115022: CALL_OW 296
115026: PUSH
115027: LD_INT 10
115029: GREATER
115030: IFFALSE 115052
// ComMoveUnit ( group [ i ] , k ) ;
115032: LD_VAR 0 4
115036: PUSH
115037: LD_VAR 0 7
115041: ARRAY
115042: PPUSH
115043: LD_VAR 0 9
115047: PPUSH
115048: CALL_OW 112
// end ; end ; if GetLives ( group [ i ] ) < 250 and group [ i ] in FilterAllUnits ( [ [ f_type , unit_vehicle ] , [ f_nation , 2 ] ] ) then
115052: LD_VAR 0 4
115056: PUSH
115057: LD_VAR 0 7
115061: ARRAY
115062: PPUSH
115063: CALL_OW 256
115067: PUSH
115068: LD_INT 250
115070: LESS
115071: PUSH
115072: LD_VAR 0 4
115076: PUSH
115077: LD_VAR 0 7
115081: ARRAY
115082: PUSH
115083: LD_INT 21
115085: PUSH
115086: LD_INT 2
115088: PUSH
115089: EMPTY
115090: LIST
115091: LIST
115092: PUSH
115093: LD_INT 23
115095: PUSH
115096: LD_INT 2
115098: PUSH
115099: EMPTY
115100: LIST
115101: LIST
115102: PUSH
115103: EMPTY
115104: LIST
115105: LIST
115106: PPUSH
115107: CALL_OW 69
115111: IN
115112: AND
115113: IFFALSE 115238
// begin k := NearestUnitToUnit ( all_units diff group [ i ] , group [ i ] ) ;
115115: LD_ADDR_VAR 0 9
115119: PUSH
115120: LD_OWVAR 3
115124: PUSH
115125: LD_VAR 0 4
115129: PUSH
115130: LD_VAR 0 7
115134: ARRAY
115135: DIFF
115136: PPUSH
115137: LD_VAR 0 4
115141: PUSH
115142: LD_VAR 0 7
115146: ARRAY
115147: PPUSH
115148: CALL_OW 74
115152: ST_TO_ADDR
// if not k then
115153: LD_VAR 0 9
115157: NOT
115158: IFFALSE 115162
// continue ;
115160: GO 111577
// if k in FilterAllUnits ( [ f_enemy , GetSide ( group [ i ] ) ] ) and GetDistUnits ( k , group [ i ] ) < 5 then
115162: LD_VAR 0 9
115166: PUSH
115167: LD_INT 81
115169: PUSH
115170: LD_VAR 0 4
115174: PUSH
115175: LD_VAR 0 7
115179: ARRAY
115180: PPUSH
115181: CALL_OW 255
115185: PUSH
115186: EMPTY
115187: LIST
115188: LIST
115189: PPUSH
115190: CALL_OW 69
115194: IN
115195: PUSH
115196: LD_VAR 0 9
115200: PPUSH
115201: LD_VAR 0 4
115205: PUSH
115206: LD_VAR 0 7
115210: ARRAY
115211: PPUSH
115212: CALL_OW 296
115216: PUSH
115217: LD_INT 5
115219: LESS
115220: AND
115221: IFFALSE 115238
// ComAutodestruct ( group [ i ] ) ;
115223: LD_VAR 0 4
115227: PUSH
115228: LD_VAR 0 7
115232: ARRAY
115233: PPUSH
115234: CALL 84811 0 1
// end ; if f_attack_depot then
115238: LD_VAR 0 25
115242: IFFALSE 115354
// begin k := 6 ;
115244: LD_ADDR_VAR 0 9
115248: PUSH
115249: LD_INT 6
115251: ST_TO_ADDR
// if tmp < k then
115252: LD_VAR 0 14
115256: PUSH
115257: LD_VAR 0 9
115261: LESS
115262: IFFALSE 115274
// k := tmp ;
115264: LD_ADDR_VAR 0 9
115268: PUSH
115269: LD_VAR 0 14
115273: ST_TO_ADDR
// for j = 1 to k do
115274: LD_ADDR_VAR 0 8
115278: PUSH
115279: DOUBLE
115280: LD_INT 1
115282: DEC
115283: ST_TO_ADDR
115284: LD_VAR 0 9
115288: PUSH
115289: FOR_TO
115290: IFFALSE 115352
// if GetBType ( j ) in [ b_depot , b_warehouse ] then
115292: LD_VAR 0 8
115296: PPUSH
115297: CALL_OW 266
115301: PUSH
115302: LD_INT 0
115304: PUSH
115305: LD_INT 1
115307: PUSH
115308: EMPTY
115309: LIST
115310: LIST
115311: IN
115312: IFFALSE 115350
// begin ComAttackUnit ( group [ i ] , tmp [ j ] ) ;
115314: LD_VAR 0 4
115318: PUSH
115319: LD_VAR 0 7
115323: ARRAY
115324: PPUSH
115325: LD_VAR 0 14
115329: PUSH
115330: LD_VAR 0 8
115334: ARRAY
115335: PPUSH
115336: CALL_OW 115
// attacking := true ;
115340: LD_ADDR_VAR 0 29
115344: PUSH
115345: LD_INT 1
115347: ST_TO_ADDR
// break ;
115348: GO 115352
// end ;
115350: GO 115289
115352: POP
115353: POP
// end ; if IsOk ( group [ i ] ) and not attacking then
115354: LD_VAR 0 4
115358: PUSH
115359: LD_VAR 0 7
115363: ARRAY
115364: PPUSH
115365: CALL_OW 302
115369: PUSH
115370: LD_VAR 0 29
115374: NOT
115375: AND
115376: IFFALSE 115698
// begin if GetTag ( group [ i ] ) = 71 then
115378: LD_VAR 0 4
115382: PUSH
115383: LD_VAR 0 7
115387: ARRAY
115388: PPUSH
115389: CALL_OW 110
115393: PUSH
115394: LD_INT 71
115396: EQUAL
115397: IFFALSE 115438
// begin if HasTask ( group [ i ] ) then
115399: LD_VAR 0 4
115403: PUSH
115404: LD_VAR 0 7
115408: ARRAY
115409: PPUSH
115410: CALL_OW 314
115414: IFFALSE 115420
// continue else
115416: GO 111577
115418: GO 115438
// SetTag ( group [ i ] , 0 ) ;
115420: LD_VAR 0 4
115424: PUSH
115425: LD_VAR 0 7
115429: ARRAY
115430: PPUSH
115431: LD_INT 0
115433: PPUSH
115434: CALL_OW 109
// end ; k := 8 ;
115438: LD_ADDR_VAR 0 9
115442: PUSH
115443: LD_INT 8
115445: ST_TO_ADDR
// x := 0 ;
115446: LD_ADDR_VAR 0 10
115450: PUSH
115451: LD_INT 0
115453: ST_TO_ADDR
// if tmp < k then
115454: LD_VAR 0 14
115458: PUSH
115459: LD_VAR 0 9
115463: LESS
115464: IFFALSE 115476
// k := tmp ;
115466: LD_ADDR_VAR 0 9
115470: PUSH
115471: LD_VAR 0 14
115475: ST_TO_ADDR
// for j = 1 to k do
115476: LD_ADDR_VAR 0 8
115480: PUSH
115481: DOUBLE
115482: LD_INT 1
115484: DEC
115485: ST_TO_ADDR
115486: LD_VAR 0 9
115490: PUSH
115491: FOR_TO
115492: IFFALSE 115590
// if GetType ( tmp [ j ] ) = unit_human and ( ( GetLives ( tmp [ j ] ) < 250 and f_murder ) or ( not f_murder and GetLives ( tmp [ j ] ) >= 250 ) ) then
115494: LD_VAR 0 14
115498: PUSH
115499: LD_VAR 0 8
115503: ARRAY
115504: PPUSH
115505: CALL_OW 247
115509: PUSH
115510: LD_INT 1
115512: EQUAL
115513: PUSH
115514: LD_VAR 0 14
115518: PUSH
115519: LD_VAR 0 8
115523: ARRAY
115524: PPUSH
115525: CALL_OW 256
115529: PUSH
115530: LD_INT 250
115532: LESS
115533: PUSH
115534: LD_VAR 0 20
115538: AND
115539: PUSH
115540: LD_VAR 0 20
115544: NOT
115545: PUSH
115546: LD_VAR 0 14
115550: PUSH
115551: LD_VAR 0 8
115555: ARRAY
115556: PPUSH
115557: CALL_OW 256
115561: PUSH
115562: LD_INT 250
115564: GREATEREQUAL
115565: AND
115566: OR
115567: AND
115568: IFFALSE 115588
// begin x := tmp [ j ] ;
115570: LD_ADDR_VAR 0 10
115574: PUSH
115575: LD_VAR 0 14
115579: PUSH
115580: LD_VAR 0 8
115584: ARRAY
115585: ST_TO_ADDR
// break ;
115586: GO 115590
// end ;
115588: GO 115491
115590: POP
115591: POP
// if x then
115592: LD_VAR 0 10
115596: IFFALSE 115620
// ComAttackUnit ( group [ i ] , x ) else
115598: LD_VAR 0 4
115602: PUSH
115603: LD_VAR 0 7
115607: ARRAY
115608: PPUSH
115609: LD_VAR 0 10
115613: PPUSH
115614: CALL_OW 115
115618: GO 115644
// ComAttackUnit ( group [ i ] , tmp [ 1 ] ) ;
115620: LD_VAR 0 4
115624: PUSH
115625: LD_VAR 0 7
115629: ARRAY
115630: PPUSH
115631: LD_VAR 0 14
115635: PUSH
115636: LD_INT 1
115638: ARRAY
115639: PPUSH
115640: CALL_OW 115
// if not HasTask ( group [ i ] ) then
115644: LD_VAR 0 4
115648: PUSH
115649: LD_VAR 0 7
115653: ARRAY
115654: PPUSH
115655: CALL_OW 314
115659: NOT
115660: IFFALSE 115698
// ComAttackUnit ( group [ i ] , NearestUnitToUnit ( tmp , group [ i ] ) ) ;
115662: LD_VAR 0 4
115666: PUSH
115667: LD_VAR 0 7
115671: ARRAY
115672: PPUSH
115673: LD_VAR 0 14
115677: PPUSH
115678: LD_VAR 0 4
115682: PUSH
115683: LD_VAR 0 7
115687: ARRAY
115688: PPUSH
115689: CALL_OW 74
115693: PPUSH
115694: CALL_OW 115
// end ; end ; end ;
115698: GO 111577
115700: POP
115701: POP
// wait ( 0 0$2 ) ;
115702: LD_INT 70
115704: PPUSH
115705: CALL_OW 67
// until not group or group = [ ] or not FilterAllUnits ( [ f_enemy , side ] ) ;
115709: LD_VAR 0 4
115713: NOT
115714: PUSH
115715: LD_VAR 0 4
115719: PUSH
115720: EMPTY
115721: EQUAL
115722: OR
115723: PUSH
115724: LD_INT 81
115726: PUSH
115727: LD_VAR 0 35
115731: PUSH
115732: EMPTY
115733: LIST
115734: LIST
115735: PPUSH
115736: CALL_OW 69
115740: NOT
115741: OR
115742: IFFALSE 111562
// end ;
115744: LD_VAR 0 2
115748: RET
// export function BasicDefend ( base , solds ) ; var enemy , e , side , i , hex ; begin
115749: LD_INT 0
115751: PPUSH
115752: PPUSH
115753: PPUSH
115754: PPUSH
115755: PPUSH
115756: PPUSH
// if not base or not mc_bases [ base ] or not solds then
115757: LD_VAR 0 1
115761: NOT
115762: PUSH
115763: LD_EXP 95
115767: PUSH
115768: LD_VAR 0 1
115772: ARRAY
115773: NOT
115774: OR
115775: PUSH
115776: LD_VAR 0 2
115780: NOT
115781: OR
115782: IFFALSE 115786
// exit ;
115784: GO 116340
// side := mc_sides [ base ] ;
115786: LD_ADDR_VAR 0 6
115790: PUSH
115791: LD_EXP 121
115795: PUSH
115796: LD_VAR 0 1
115800: ARRAY
115801: ST_TO_ADDR
// if not side then
115802: LD_VAR 0 6
115806: NOT
115807: IFFALSE 115811
// exit ;
115809: GO 116340
// for i in solds do
115811: LD_ADDR_VAR 0 7
115815: PUSH
115816: LD_VAR 0 2
115820: PUSH
115821: FOR_IN
115822: IFFALSE 115883
// if GetBType ( IsInUnit ( i ) ) in [ b_bunker , b_breastwork ] then
115824: LD_VAR 0 7
115828: PPUSH
115829: CALL_OW 310
115833: PPUSH
115834: CALL_OW 266
115838: PUSH
115839: LD_INT 32
115841: PUSH
115842: LD_INT 31
115844: PUSH
115845: EMPTY
115846: LIST
115847: LIST
115848: IN
115849: IFFALSE 115869
// solds := solds diff i else
115851: LD_ADDR_VAR 0 2
115855: PUSH
115856: LD_VAR 0 2
115860: PUSH
115861: LD_VAR 0 7
115865: DIFF
115866: ST_TO_ADDR
115867: GO 115881
// SetTag ( i , 18 ) ;
115869: LD_VAR 0 7
115873: PPUSH
115874: LD_INT 18
115876: PPUSH
115877: CALL_OW 109
115881: GO 115821
115883: POP
115884: POP
// if not solds then
115885: LD_VAR 0 2
115889: NOT
115890: IFFALSE 115894
// exit ;
115892: GO 116340
// repeat wait ( 0 0$2 ) ;
115894: LD_INT 70
115896: PPUSH
115897: CALL_OW 67
// enemy := mc_scan [ base ] ;
115901: LD_ADDR_VAR 0 4
115905: PUSH
115906: LD_EXP 118
115910: PUSH
115911: LD_VAR 0 1
115915: ARRAY
115916: ST_TO_ADDR
// if not mc_bases [ base ] or mc_bases [ base ] = [ ] then
115917: LD_EXP 95
115921: PUSH
115922: LD_VAR 0 1
115926: ARRAY
115927: NOT
115928: PUSH
115929: LD_EXP 95
115933: PUSH
115934: LD_VAR 0 1
115938: ARRAY
115939: PUSH
115940: EMPTY
115941: EQUAL
115942: OR
115943: IFFALSE 115980
// begin for i in solds do
115945: LD_ADDR_VAR 0 7
115949: PUSH
115950: LD_VAR 0 2
115954: PUSH
115955: FOR_IN
115956: IFFALSE 115969
// ComStop ( i ) ;
115958: LD_VAR 0 7
115962: PPUSH
115963: CALL_OW 141
115967: GO 115955
115969: POP
115970: POP
// solds := [ ] ;
115971: LD_ADDR_VAR 0 2
115975: PUSH
115976: EMPTY
115977: ST_TO_ADDR
// exit ;
115978: GO 116340
// end ; for i in solds do
115980: LD_ADDR_VAR 0 7
115984: PUSH
115985: LD_VAR 0 2
115989: PUSH
115990: FOR_IN
115991: IFFALSE 116312
// begin if IsInUnit ( i ) then
115993: LD_VAR 0 7
115997: PPUSH
115998: CALL_OW 310
116002: IFFALSE 116013
// ComExitBuilding ( i ) ;
116004: LD_VAR 0 7
116008: PPUSH
116009: CALL_OW 122
// if GetLives ( i ) > 500 then
116013: LD_VAR 0 7
116017: PPUSH
116018: CALL_OW 256
116022: PUSH
116023: LD_INT 500
116025: GREATER
116026: IFFALSE 116079
// begin e := NearestUnitToUnit ( enemy , i ) ;
116028: LD_ADDR_VAR 0 5
116032: PUSH
116033: LD_VAR 0 4
116037: PPUSH
116038: LD_VAR 0 7
116042: PPUSH
116043: CALL_OW 74
116047: ST_TO_ADDR
// ComAgressiveMove ( i , GetX ( e ) , GetY ( e ) ) ;
116048: LD_VAR 0 7
116052: PPUSH
116053: LD_VAR 0 5
116057: PPUSH
116058: CALL_OW 250
116062: PPUSH
116063: LD_VAR 0 5
116067: PPUSH
116068: CALL_OW 251
116072: PPUSH
116073: CALL_OW 114
// end else
116077: GO 116310
// if GetDistUnits ( i , NearestUnitToUnit ( UnitFilter ( mc_bases [ base ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] , [ f_btype , b_lab ] ] ) , i ) ) > 10 then
116079: LD_VAR 0 7
116083: PPUSH
116084: LD_EXP 95
116088: PUSH
116089: LD_VAR 0 1
116093: ARRAY
116094: PPUSH
116095: LD_INT 2
116097: PUSH
116098: LD_INT 30
116100: PUSH
116101: LD_INT 0
116103: PUSH
116104: EMPTY
116105: LIST
116106: LIST
116107: PUSH
116108: LD_INT 30
116110: PUSH
116111: LD_INT 1
116113: PUSH
116114: EMPTY
116115: LIST
116116: LIST
116117: PUSH
116118: LD_INT 30
116120: PUSH
116121: LD_INT 6
116123: PUSH
116124: EMPTY
116125: LIST
116126: LIST
116127: PUSH
116128: EMPTY
116129: LIST
116130: LIST
116131: LIST
116132: LIST
116133: PPUSH
116134: CALL_OW 72
116138: PPUSH
116139: LD_VAR 0 7
116143: PPUSH
116144: CALL_OW 74
116148: PPUSH
116149: CALL_OW 296
116153: PUSH
116154: LD_INT 10
116156: GREATER
116157: IFFALSE 116310
// begin hex := NearestUnitToUnit ( UnitFilter ( mc_bases [ base ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] , [ f_btype , b_lab ] ] ) , i ) ;
116159: LD_ADDR_VAR 0 8
116163: PUSH
116164: LD_EXP 95
116168: PUSH
116169: LD_VAR 0 1
116173: ARRAY
116174: PPUSH
116175: LD_INT 2
116177: PUSH
116178: LD_INT 30
116180: PUSH
116181: LD_INT 0
116183: PUSH
116184: EMPTY
116185: LIST
116186: LIST
116187: PUSH
116188: LD_INT 30
116190: PUSH
116191: LD_INT 1
116193: PUSH
116194: EMPTY
116195: LIST
116196: LIST
116197: PUSH
116198: LD_INT 30
116200: PUSH
116201: LD_INT 6
116203: PUSH
116204: EMPTY
116205: LIST
116206: LIST
116207: PUSH
116208: EMPTY
116209: LIST
116210: LIST
116211: LIST
116212: LIST
116213: PPUSH
116214: CALL_OW 72
116218: PPUSH
116219: LD_VAR 0 7
116223: PPUSH
116224: CALL_OW 74
116228: ST_TO_ADDR
// ComMoveXY ( i , ShiftX ( GetX ( hex ) , 3 , 5 ) , ShiftY ( GetY ( hex ) , 3 , 5 ) ) ;
116229: LD_VAR 0 7
116233: PPUSH
116234: LD_VAR 0 8
116238: PPUSH
116239: CALL_OW 250
116243: PPUSH
116244: LD_INT 3
116246: PPUSH
116247: LD_INT 5
116249: PPUSH
116250: CALL_OW 272
116254: PPUSH
116255: LD_VAR 0 8
116259: PPUSH
116260: CALL_OW 251
116264: PPUSH
116265: LD_INT 3
116267: PPUSH
116268: LD_INT 5
116270: PPUSH
116271: CALL_OW 273
116275: PPUSH
116276: CALL_OW 111
// SetTag ( i , 0 ) ;
116280: LD_VAR 0 7
116284: PPUSH
116285: LD_INT 0
116287: PPUSH
116288: CALL_OW 109
// solds := solds diff i ;
116292: LD_ADDR_VAR 0 2
116296: PUSH
116297: LD_VAR 0 2
116301: PUSH
116302: LD_VAR 0 7
116306: DIFF
116307: ST_TO_ADDR
// continue ;
116308: GO 115990
// end ; end ;
116310: GO 115990
116312: POP
116313: POP
// until not solds or not enemy ;
116314: LD_VAR 0 2
116318: NOT
116319: PUSH
116320: LD_VAR 0 4
116324: NOT
116325: OR
116326: IFFALSE 115894
// MC_Reset ( base , 18 ) ;
116328: LD_VAR 0 1
116332: PPUSH
116333: LD_INT 18
116335: PPUSH
116336: CALL 25559 0 2
// end ;
116340: LD_VAR 0 3
116344: RET
// export function Defend ( base , defenders ) ; var i , j , x , depot , solds , mech , un , tmp , mechs , e , fac , components , depot_under_attack , sold_defenders , b , can_defend , class , enemy ; begin
116345: LD_INT 0
116347: PPUSH
116348: PPUSH
116349: PPUSH
116350: PPUSH
116351: PPUSH
116352: PPUSH
116353: PPUSH
116354: PPUSH
116355: PPUSH
116356: PPUSH
116357: PPUSH
116358: PPUSH
116359: PPUSH
116360: PPUSH
116361: PPUSH
116362: PPUSH
116363: PPUSH
116364: PPUSH
116365: PPUSH
// mechs := UnitFilter ( mc_bases [ base ] , [ f_class , 3 ] ) ;
116366: LD_ADDR_VAR 0 12
116370: PUSH
116371: LD_EXP 95
116375: PUSH
116376: LD_VAR 0 1
116380: ARRAY
116381: PPUSH
116382: LD_INT 25
116384: PUSH
116385: LD_INT 3
116387: PUSH
116388: EMPTY
116389: LIST
116390: LIST
116391: PPUSH
116392: CALL_OW 72
116396: ST_TO_ADDR
// if mc_remote_driver [ base ] then
116397: LD_EXP 135
116401: PUSH
116402: LD_VAR 0 1
116406: ARRAY
116407: IFFALSE 116431
// mechs := mechs diff mc_remote_driver [ base ] ;
116409: LD_ADDR_VAR 0 12
116413: PUSH
116414: LD_VAR 0 12
116418: PUSH
116419: LD_EXP 135
116423: PUSH
116424: LD_VAR 0 1
116428: ARRAY
116429: DIFF
116430: ST_TO_ADDR
// for i in mechs do
116431: LD_ADDR_VAR 0 4
116435: PUSH
116436: LD_VAR 0 12
116440: PUSH
116441: FOR_IN
116442: IFFALSE 116477
// if GetTag ( i ) > 0 then
116444: LD_VAR 0 4
116448: PPUSH
116449: CALL_OW 110
116453: PUSH
116454: LD_INT 0
116456: GREATER
116457: IFFALSE 116475
// mechs := mechs diff i ;
116459: LD_ADDR_VAR 0 12
116463: PUSH
116464: LD_VAR 0 12
116468: PUSH
116469: LD_VAR 0 4
116473: DIFF
116474: ST_TO_ADDR
116475: GO 116441
116477: POP
116478: POP
// solds := UnitFilter ( mc_bases [ base ] , [ f_or , [ f_class , 1 ] , [ f_class , 5 ] , [ f_class , 8 ] , [ f_class , 9 ] ] ) ;
116479: LD_ADDR_VAR 0 8
116483: PUSH
116484: LD_EXP 95
116488: PUSH
116489: LD_VAR 0 1
116493: ARRAY
116494: PPUSH
116495: LD_INT 2
116497: PUSH
116498: LD_INT 25
116500: PUSH
116501: LD_INT 1
116503: PUSH
116504: EMPTY
116505: LIST
116506: LIST
116507: PUSH
116508: LD_INT 25
116510: PUSH
116511: LD_INT 5
116513: PUSH
116514: EMPTY
116515: LIST
116516: LIST
116517: PUSH
116518: LD_INT 25
116520: PUSH
116521: LD_INT 8
116523: PUSH
116524: EMPTY
116525: LIST
116526: LIST
116527: PUSH
116528: LD_INT 25
116530: PUSH
116531: LD_INT 9
116533: PUSH
116534: EMPTY
116535: LIST
116536: LIST
116537: PUSH
116538: EMPTY
116539: LIST
116540: LIST
116541: LIST
116542: LIST
116543: LIST
116544: PPUSH
116545: CALL_OW 72
116549: ST_TO_ADDR
// if not defenders and not solds then
116550: LD_VAR 0 2
116554: NOT
116555: PUSH
116556: LD_VAR 0 8
116560: NOT
116561: AND
116562: IFFALSE 116566
// exit ;
116564: GO 118336
// depot_under_attack := false ;
116566: LD_ADDR_VAR 0 16
116570: PUSH
116571: LD_INT 0
116573: ST_TO_ADDR
// sold_defenders := [ ] ;
116574: LD_ADDR_VAR 0 17
116578: PUSH
116579: EMPTY
116580: ST_TO_ADDR
// if mechs then
116581: LD_VAR 0 12
116585: IFFALSE 116738
// for i in UnitFilter ( defenders , [ f_type , unit_vehicle ] ) do
116587: LD_ADDR_VAR 0 4
116591: PUSH
116592: LD_VAR 0 2
116596: PPUSH
116597: LD_INT 21
116599: PUSH
116600: LD_INT 2
116602: PUSH
116603: EMPTY
116604: LIST
116605: LIST
116606: PPUSH
116607: CALL_OW 72
116611: PUSH
116612: FOR_IN
116613: IFFALSE 116736
// begin if GetTag ( i ) <> 20 then
116615: LD_VAR 0 4
116619: PPUSH
116620: CALL_OW 110
116624: PUSH
116625: LD_INT 20
116627: NONEQUAL
116628: IFFALSE 116642
// SetTag ( i , 20 ) ;
116630: LD_VAR 0 4
116634: PPUSH
116635: LD_INT 20
116637: PPUSH
116638: CALL_OW 109
// if GetControl ( i ) = control_manual and not IsDrivenBy ( i ) then
116642: LD_VAR 0 4
116646: PPUSH
116647: CALL_OW 263
116651: PUSH
116652: LD_INT 1
116654: EQUAL
116655: PUSH
116656: LD_VAR 0 4
116660: PPUSH
116661: CALL_OW 311
116665: NOT
116666: AND
116667: IFFALSE 116734
// begin un := mechs [ 1 ] ;
116669: LD_ADDR_VAR 0 10
116673: PUSH
116674: LD_VAR 0 12
116678: PUSH
116679: LD_INT 1
116681: ARRAY
116682: ST_TO_ADDR
// ComExit ( un ) ;
116683: LD_VAR 0 10
116687: PPUSH
116688: CALL 89100 0 1
// AddComEnterUnit ( un , i ) ;
116692: LD_VAR 0 10
116696: PPUSH
116697: LD_VAR 0 4
116701: PPUSH
116702: CALL_OW 180
// SetTag ( un , 19 ) ;
116706: LD_VAR 0 10
116710: PPUSH
116711: LD_INT 19
116713: PPUSH
116714: CALL_OW 109
// mechs := mechs diff un ;
116718: LD_ADDR_VAR 0 12
116722: PUSH
116723: LD_VAR 0 12
116727: PUSH
116728: LD_VAR 0 10
116732: DIFF
116733: ST_TO_ADDR
// end ; end ;
116734: GO 116612
116736: POP
116737: POP
// if solds then
116738: LD_VAR 0 8
116742: IFFALSE 116801
// for i in solds do
116744: LD_ADDR_VAR 0 4
116748: PUSH
116749: LD_VAR 0 8
116753: PUSH
116754: FOR_IN
116755: IFFALSE 116799
// if not GetTag ( i ) then
116757: LD_VAR 0 4
116761: PPUSH
116762: CALL_OW 110
116766: NOT
116767: IFFALSE 116797
// begin defenders := defenders union i ;
116769: LD_ADDR_VAR 0 2
116773: PUSH
116774: LD_VAR 0 2
116778: PUSH
116779: LD_VAR 0 4
116783: UNION
116784: ST_TO_ADDR
// SetTag ( i , 18 ) ;
116785: LD_VAR 0 4
116789: PPUSH
116790: LD_INT 18
116792: PPUSH
116793: CALL_OW 109
// end ;
116797: GO 116754
116799: POP
116800: POP
// repeat wait ( 0 0$2 ) ;
116801: LD_INT 70
116803: PPUSH
116804: CALL_OW 67
// enemy := mc_scan [ base ] ;
116808: LD_ADDR_VAR 0 21
116812: PUSH
116813: LD_EXP 118
116817: PUSH
116818: LD_VAR 0 1
116822: ARRAY
116823: ST_TO_ADDR
// if not mc_bases [ base ] or mc_bases [ base ] = [ ] then
116824: LD_EXP 95
116828: PUSH
116829: LD_VAR 0 1
116833: ARRAY
116834: NOT
116835: PUSH
116836: LD_EXP 95
116840: PUSH
116841: LD_VAR 0 1
116845: ARRAY
116846: PUSH
116847: EMPTY
116848: EQUAL
116849: OR
116850: IFFALSE 116887
// begin for i in defenders do
116852: LD_ADDR_VAR 0 4
116856: PUSH
116857: LD_VAR 0 2
116861: PUSH
116862: FOR_IN
116863: IFFALSE 116876
// ComStop ( i ) ;
116865: LD_VAR 0 4
116869: PPUSH
116870: CALL_OW 141
116874: GO 116862
116876: POP
116877: POP
// defenders := [ ] ;
116878: LD_ADDR_VAR 0 2
116882: PUSH
116883: EMPTY
116884: ST_TO_ADDR
// exit ;
116885: GO 118336
// end ; for i in defenders do
116887: LD_ADDR_VAR 0 4
116891: PUSH
116892: LD_VAR 0 2
116896: PUSH
116897: FOR_IN
116898: IFFALSE 117796
// begin e := NearestUnitToUnit ( enemy , i ) ;
116900: LD_ADDR_VAR 0 13
116904: PUSH
116905: LD_VAR 0 21
116909: PPUSH
116910: LD_VAR 0 4
116914: PPUSH
116915: CALL_OW 74
116919: ST_TO_ADDR
// depot := UnitFilter ( mc_bases [ base ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) ;
116920: LD_ADDR_VAR 0 7
116924: PUSH
116925: LD_EXP 95
116929: PUSH
116930: LD_VAR 0 1
116934: ARRAY
116935: PPUSH
116936: LD_INT 2
116938: PUSH
116939: LD_INT 30
116941: PUSH
116942: LD_INT 0
116944: PUSH
116945: EMPTY
116946: LIST
116947: LIST
116948: PUSH
116949: LD_INT 30
116951: PUSH
116952: LD_INT 1
116954: PUSH
116955: EMPTY
116956: LIST
116957: LIST
116958: PUSH
116959: EMPTY
116960: LIST
116961: LIST
116962: LIST
116963: PPUSH
116964: CALL_OW 72
116968: ST_TO_ADDR
// depot_under_attack := ( not depot or UnitFilter ( depot , [ f_not , [ f_lives , 600 ] ] ) ) ;
116969: LD_ADDR_VAR 0 16
116973: PUSH
116974: LD_VAR 0 7
116978: NOT
116979: PUSH
116980: LD_VAR 0 7
116984: PPUSH
116985: LD_INT 3
116987: PUSH
116988: LD_INT 24
116990: PUSH
116991: LD_INT 600
116993: PUSH
116994: EMPTY
116995: LIST
116996: LIST
116997: PUSH
116998: EMPTY
116999: LIST
117000: LIST
117001: PPUSH
117002: CALL_OW 72
117006: OR
117007: ST_TO_ADDR
// case GetType ( i ) of unit_vehicle :
117008: LD_VAR 0 4
117012: PPUSH
117013: CALL_OW 247
117017: PUSH
117018: LD_INT 2
117020: DOUBLE
117021: EQUAL
117022: IFTRUE 117026
117024: GO 117422
117026: POP
// begin if GetLives ( i ) = 1000 and ( GetDistUnits ( i , e ) < 40 or IsInArea ( e , mc_scan_area [ base ] ) ) then
117027: LD_VAR 0 4
117031: PPUSH
117032: CALL_OW 256
117036: PUSH
117037: LD_INT 1000
117039: EQUAL
117040: PUSH
117041: LD_VAR 0 4
117045: PPUSH
117046: LD_VAR 0 13
117050: PPUSH
117051: CALL_OW 296
117055: PUSH
117056: LD_INT 40
117058: LESS
117059: PUSH
117060: LD_VAR 0 13
117064: PPUSH
117065: LD_EXP 120
117069: PUSH
117070: LD_VAR 0 1
117074: ARRAY
117075: PPUSH
117076: CALL_OW 308
117080: OR
117081: AND
117082: IFFALSE 117204
// begin if GetEngine ( i ) = engine_combustion and GetFuel ( i ) < 30 and depot then
117084: LD_VAR 0 4
117088: PPUSH
117089: CALL_OW 262
117093: PUSH
117094: LD_INT 1
117096: EQUAL
117097: PUSH
117098: LD_VAR 0 4
117102: PPUSH
117103: CALL_OW 261
117107: PUSH
117108: LD_INT 30
117110: LESS
117111: AND
117112: PUSH
117113: LD_VAR 0 7
117117: AND
117118: IFFALSE 117188
// begin ComMoveUnit ( i , NearestUnitToUnit ( depot , i ) ) ;
117120: LD_VAR 0 4
117124: PPUSH
117125: LD_VAR 0 7
117129: PPUSH
117130: LD_VAR 0 4
117134: PPUSH
117135: CALL_OW 74
117139: PPUSH
117140: CALL_OW 112
// if GetDistUnits ( i , NearestUnitToUnit ( depot , i ) ) < 6 then
117144: LD_VAR 0 4
117148: PPUSH
117149: LD_VAR 0 7
117153: PPUSH
117154: LD_VAR 0 4
117158: PPUSH
117159: CALL_OW 74
117163: PPUSH
117164: CALL_OW 296
117168: PUSH
117169: LD_INT 6
117171: LESS
117172: IFFALSE 117186
// SetFuel ( i , 100 ) ;
117174: LD_VAR 0 4
117178: PPUSH
117179: LD_INT 100
117181: PPUSH
117182: CALL_OW 240
// end else
117186: GO 117202
// ComAttackUnit ( i , e ) ;
117188: LD_VAR 0 4
117192: PPUSH
117193: LD_VAR 0 13
117197: PPUSH
117198: CALL_OW 115
// end else
117202: GO 117305
// if ( ( not IsInArea ( e , mc_scan_area [ base ] ) and GetDistUnits ( i , e ) >= 40 ) or GetLives ( i ) <= 650 ) and not IsInArea ( i , mc_parking [ base ] ) then
117204: LD_VAR 0 13
117208: PPUSH
117209: LD_EXP 120
117213: PUSH
117214: LD_VAR 0 1
117218: ARRAY
117219: PPUSH
117220: CALL_OW 308
117224: NOT
117225: PUSH
117226: LD_VAR 0 4
117230: PPUSH
117231: LD_VAR 0 13
117235: PPUSH
117236: CALL_OW 296
117240: PUSH
117241: LD_INT 40
117243: GREATEREQUAL
117244: AND
117245: PUSH
117246: LD_VAR 0 4
117250: PPUSH
117251: CALL_OW 256
117255: PUSH
117256: LD_INT 650
117258: LESSEQUAL
117259: OR
117260: PUSH
117261: LD_VAR 0 4
117265: PPUSH
117266: LD_EXP 119
117270: PUSH
117271: LD_VAR 0 1
117275: ARRAY
117276: PPUSH
117277: CALL_OW 308
117281: NOT
117282: AND
117283: IFFALSE 117305
// ComMoveToArea ( i , mc_parking [ base ] ) ;
117285: LD_VAR 0 4
117289: PPUSH
117290: LD_EXP 119
117294: PUSH
117295: LD_VAR 0 1
117299: ARRAY
117300: PPUSH
117301: CALL_OW 113
// if GetLives ( i ) < 1000 and GetControl ( i ) = control_manual and IsDrivenBy ( i ) and IsInArea ( i , mc_parking [ base ] ) then
117305: LD_VAR 0 4
117309: PPUSH
117310: CALL_OW 256
117314: PUSH
117315: LD_INT 1000
117317: LESS
117318: PUSH
117319: LD_VAR 0 4
117323: PPUSH
117324: CALL_OW 263
117328: PUSH
117329: LD_INT 1
117331: EQUAL
117332: AND
117333: PUSH
117334: LD_VAR 0 4
117338: PPUSH
117339: CALL_OW 311
117343: AND
117344: PUSH
117345: LD_VAR 0 4
117349: PPUSH
117350: LD_EXP 119
117354: PUSH
117355: LD_VAR 0 1
117359: ARRAY
117360: PPUSH
117361: CALL_OW 308
117365: AND
117366: IFFALSE 117420
// begin mech := IsDrivenBy ( i ) ;
117368: LD_ADDR_VAR 0 9
117372: PUSH
117373: LD_VAR 0 4
117377: PPUSH
117378: CALL_OW 311
117382: ST_TO_ADDR
// ComExitVehicle ( mech ) ;
117383: LD_VAR 0 9
117387: PPUSH
117388: CALL_OW 121
// AddComRepairVehicle ( mech , i ) ;
117392: LD_VAR 0 9
117396: PPUSH
117397: LD_VAR 0 4
117401: PPUSH
117402: CALL_OW 189
// AddComEnterUnit ( mech , i ) ;
117406: LD_VAR 0 9
117410: PPUSH
117411: LD_VAR 0 4
117415: PPUSH
117416: CALL_OW 180
// end ; end ; unit_human :
117420: GO 117767
117422: LD_INT 1
117424: DOUBLE
117425: EQUAL
117426: IFTRUE 117430
117428: GO 117766
117430: POP
// begin b := IsInUnit ( i ) ;
117431: LD_ADDR_VAR 0 18
117435: PUSH
117436: LD_VAR 0 4
117440: PPUSH
117441: CALL_OW 310
117445: ST_TO_ADDR
// can_defend := ( not b or GetBType ( b ) in [ b_bunker , b_breastwork ] ) ;
117446: LD_ADDR_VAR 0 19
117450: PUSH
117451: LD_VAR 0 18
117455: NOT
117456: PUSH
117457: LD_VAR 0 18
117461: PPUSH
117462: CALL_OW 266
117466: PUSH
117467: LD_INT 32
117469: PUSH
117470: LD_INT 31
117472: PUSH
117473: EMPTY
117474: LIST
117475: LIST
117476: IN
117477: OR
117478: ST_TO_ADDR
// if GetBType ( b ) = b_barracks and GetClass ( i ) in [ 1 , 2 , 3 , 4 ] then
117479: LD_VAR 0 18
117483: PPUSH
117484: CALL_OW 266
117488: PUSH
117489: LD_INT 5
117491: EQUAL
117492: PUSH
117493: LD_VAR 0 4
117497: PPUSH
117498: CALL_OW 257
117502: PUSH
117503: LD_INT 1
117505: PUSH
117506: LD_INT 2
117508: PUSH
117509: LD_INT 3
117511: PUSH
117512: LD_INT 4
117514: PUSH
117515: EMPTY
117516: LIST
117517: LIST
117518: LIST
117519: LIST
117520: IN
117521: AND
117522: IFFALSE 117559
// begin class := AllowSpecClass ( i ) ;
117524: LD_ADDR_VAR 0 20
117528: PUSH
117529: LD_VAR 0 4
117533: PPUSH
117534: CALL 53817 0 1
117538: ST_TO_ADDR
// if class then
117539: LD_VAR 0 20
117543: IFFALSE 117559
// ComChangeProfession ( i , class ) ;
117545: LD_VAR 0 4
117549: PPUSH
117550: LD_VAR 0 20
117554: PPUSH
117555: CALL_OW 123
// end ; if ( depot_under_attack or UnitFilter ( defenders , [ f_type , unit_vehicle ] ) <= 1 ) and can_defend and not i in sold_defenders then
117559: LD_VAR 0 16
117563: PUSH
117564: LD_VAR 0 2
117568: PPUSH
117569: LD_INT 21
117571: PUSH
117572: LD_INT 2
117574: PUSH
117575: EMPTY
117576: LIST
117577: LIST
117578: PPUSH
117579: CALL_OW 72
117583: PUSH
117584: LD_INT 1
117586: LESSEQUAL
117587: OR
117588: PUSH
117589: LD_VAR 0 19
117593: AND
117594: PUSH
117595: LD_VAR 0 4
117599: PUSH
117600: LD_VAR 0 17
117604: IN
117605: NOT
117606: AND
117607: IFFALSE 117700
// begin if b then
117609: LD_VAR 0 18
117613: IFFALSE 117662
// if GetDistUnits ( b , NearestUnitToUnit ( enemy , b ) ) < 10 and BuildingStatus ( b ) <> bs_need_power then
117615: LD_VAR 0 18
117619: PPUSH
117620: LD_VAR 0 21
117624: PPUSH
117625: LD_VAR 0 18
117629: PPUSH
117630: CALL_OW 74
117634: PPUSH
117635: CALL_OW 296
117639: PUSH
117640: LD_INT 10
117642: LESS
117643: PUSH
117644: LD_VAR 0 18
117648: PPUSH
117649: CALL_OW 461
117653: PUSH
117654: LD_INT 7
117656: NONEQUAL
117657: AND
117658: IFFALSE 117662
// continue ;
117660: GO 116897
// sold_defenders := Replace ( sold_defenders , sold_defenders + 1 , i ) ;
117662: LD_ADDR_VAR 0 17
117666: PUSH
117667: LD_VAR 0 17
117671: PPUSH
117672: LD_VAR 0 17
117676: PUSH
117677: LD_INT 1
117679: PLUS
117680: PPUSH
117681: LD_VAR 0 4
117685: PPUSH
117686: CALL_OW 1
117690: ST_TO_ADDR
// ComExitBuilding ( i ) ;
117691: LD_VAR 0 4
117695: PPUSH
117696: CALL_OW 122
// end ; if sold_defenders then
117700: LD_VAR 0 17
117704: IFFALSE 117764
// if i in sold_defenders then
117706: LD_VAR 0 4
117710: PUSH
117711: LD_VAR 0 17
117715: IN
117716: IFFALSE 117764
// begin if not HasTask ( i ) and GetDistUnits ( i , e ) < 30 then
117718: LD_VAR 0 4
117722: PPUSH
117723: CALL_OW 314
117727: NOT
117728: PUSH
117729: LD_VAR 0 4
117733: PPUSH
117734: LD_VAR 0 13
117738: PPUSH
117739: CALL_OW 296
117743: PUSH
117744: LD_INT 30
117746: LESS
117747: AND
117748: IFFALSE 117764
// ComAttackUnit ( i , e ) ;
117750: LD_VAR 0 4
117754: PPUSH
117755: LD_VAR 0 13
117759: PPUSH
117760: CALL_OW 115
// end ; end ; end ;
117764: GO 117767
117766: POP
// if IsDead ( i ) then
117767: LD_VAR 0 4
117771: PPUSH
117772: CALL_OW 301
117776: IFFALSE 117794
// defenders := defenders diff i ;
117778: LD_ADDR_VAR 0 2
117782: PUSH
117783: LD_VAR 0 2
117787: PUSH
117788: LD_VAR 0 4
117792: DIFF
117793: ST_TO_ADDR
// end ;
117794: GO 116897
117796: POP
117797: POP
// until not enemy or not defenders or not mc_bases [ base ] ;
117798: LD_VAR 0 21
117802: NOT
117803: PUSH
117804: LD_VAR 0 2
117808: NOT
117809: OR
117810: PUSH
117811: LD_EXP 95
117815: PUSH
117816: LD_VAR 0 1
117820: ARRAY
117821: NOT
117822: OR
117823: IFFALSE 116801
// MC_Reset ( base , 18 ) ;
117825: LD_VAR 0 1
117829: PPUSH
117830: LD_INT 18
117832: PPUSH
117833: CALL 25559 0 2
// defenders := defenders diff UnitFilter ( defenders , [ f_or , [ f_class , 1 ] , [ f_class , 5 ] , [ f_class , 8 ] , [ f_class , 9 ] ] ) ;
117837: LD_ADDR_VAR 0 2
117841: PUSH
117842: LD_VAR 0 2
117846: PUSH
117847: LD_VAR 0 2
117851: PPUSH
117852: LD_INT 2
117854: PUSH
117855: LD_INT 25
117857: PUSH
117858: LD_INT 1
117860: PUSH
117861: EMPTY
117862: LIST
117863: LIST
117864: PUSH
117865: LD_INT 25
117867: PUSH
117868: LD_INT 5
117870: PUSH
117871: EMPTY
117872: LIST
117873: LIST
117874: PUSH
117875: LD_INT 25
117877: PUSH
117878: LD_INT 8
117880: PUSH
117881: EMPTY
117882: LIST
117883: LIST
117884: PUSH
117885: LD_INT 25
117887: PUSH
117888: LD_INT 9
117890: PUSH
117891: EMPTY
117892: LIST
117893: LIST
117894: PUSH
117895: EMPTY
117896: LIST
117897: LIST
117898: LIST
117899: LIST
117900: LIST
117901: PPUSH
117902: CALL_OW 72
117906: DIFF
117907: ST_TO_ADDR
// if not enemy and UnitFilter ( defenders , [ f_type , unit_vehicle ] ) then
117908: LD_VAR 0 21
117912: NOT
117913: PUSH
117914: LD_VAR 0 2
117918: PPUSH
117919: LD_INT 21
117921: PUSH
117922: LD_INT 2
117924: PUSH
117925: EMPTY
117926: LIST
117927: LIST
117928: PPUSH
117929: CALL_OW 72
117933: AND
117934: IFFALSE 118272
// begin tmp := FilterByTag ( defenders , 19 ) ;
117936: LD_ADDR_VAR 0 11
117940: PUSH
117941: LD_VAR 0 2
117945: PPUSH
117946: LD_INT 19
117948: PPUSH
117949: CALL 86286 0 2
117953: ST_TO_ADDR
// if tmp then
117954: LD_VAR 0 11
117958: IFFALSE 118028
// begin tmp := UnitFilter ( tmp , [ f_class , 3 ] ) ;
117960: LD_ADDR_VAR 0 11
117964: PUSH
117965: LD_VAR 0 11
117969: PPUSH
117970: LD_INT 25
117972: PUSH
117973: LD_INT 3
117975: PUSH
117976: EMPTY
117977: LIST
117978: LIST
117979: PPUSH
117980: CALL_OW 72
117984: ST_TO_ADDR
// if tmp then
117985: LD_VAR 0 11
117989: IFFALSE 118028
// mc_repair_vehicle := Replace ( mc_repair_vehicle , base , mc_repair_vehicle [ base ] union tmp ) ;
117991: LD_ADDR_EXP 107
117995: PUSH
117996: LD_EXP 107
118000: PPUSH
118001: LD_VAR 0 1
118005: PPUSH
118006: LD_EXP 107
118010: PUSH
118011: LD_VAR 0 1
118015: ARRAY
118016: PUSH
118017: LD_VAR 0 11
118021: UNION
118022: PPUSH
118023: CALL_OW 1
118027: ST_TO_ADDR
// end ; MC_Reset ( base , 19 ) ;
118028: LD_VAR 0 1
118032: PPUSH
118033: LD_INT 19
118035: PPUSH
118036: CALL 25559 0 2
// repeat wait ( 0 0$1 ) ;
118040: LD_INT 35
118042: PPUSH
118043: CALL_OW 67
// if not mc_bases [ base ] or mc_bases [ base ] = [ ] then
118047: LD_EXP 95
118051: PUSH
118052: LD_VAR 0 1
118056: ARRAY
118057: NOT
118058: PUSH
118059: LD_EXP 95
118063: PUSH
118064: LD_VAR 0 1
118068: ARRAY
118069: PUSH
118070: EMPTY
118071: EQUAL
118072: OR
118073: IFFALSE 118110
// begin for i in defenders do
118075: LD_ADDR_VAR 0 4
118079: PUSH
118080: LD_VAR 0 2
118084: PUSH
118085: FOR_IN
118086: IFFALSE 118099
// ComStop ( i ) ;
118088: LD_VAR 0 4
118092: PPUSH
118093: CALL_OW 141
118097: GO 118085
118099: POP
118100: POP
// defenders := [ ] ;
118101: LD_ADDR_VAR 0 2
118105: PUSH
118106: EMPTY
118107: ST_TO_ADDR
// exit ;
118108: GO 118336
// end ; for i in defenders do
118110: LD_ADDR_VAR 0 4
118114: PUSH
118115: LD_VAR 0 2
118119: PUSH
118120: FOR_IN
118121: IFFALSE 118210
// begin if not IsInArea ( i , mc_parking [ base ] ) then
118123: LD_VAR 0 4
118127: PPUSH
118128: LD_EXP 119
118132: PUSH
118133: LD_VAR 0 1
118137: ARRAY
118138: PPUSH
118139: CALL_OW 308
118143: NOT
118144: IFFALSE 118168
// ComMoveToArea ( i , mc_parking [ base ] ) else
118146: LD_VAR 0 4
118150: PPUSH
118151: LD_EXP 119
118155: PUSH
118156: LD_VAR 0 1
118160: ARRAY
118161: PPUSH
118162: CALL_OW 113
118166: GO 118208
// if GetControl ( i ) = control_manual then
118168: LD_VAR 0 4
118172: PPUSH
118173: CALL_OW 263
118177: PUSH
118178: LD_INT 1
118180: EQUAL
118181: IFFALSE 118208
// if IsDrivenBy ( i ) then
118183: LD_VAR 0 4
118187: PPUSH
118188: CALL_OW 311
118192: IFFALSE 118208
// ComExitVehicle ( IsDrivenBy ( i ) ) ;
118194: LD_VAR 0 4
118198: PPUSH
118199: CALL_OW 311
118203: PPUSH
118204: CALL_OW 121
// end ;
118208: GO 118120
118210: POP
118211: POP
// until UnitFilter ( defenders , [ f_inarea , mc_parking [ base ] ] ) = defenders or mc_scan [ base ] or not mc_bases [ base ] ;
118212: LD_VAR 0 2
118216: PPUSH
118217: LD_INT 95
118219: PUSH
118220: LD_EXP 119
118224: PUSH
118225: LD_VAR 0 1
118229: ARRAY
118230: PUSH
118231: EMPTY
118232: LIST
118233: LIST
118234: PPUSH
118235: CALL_OW 72
118239: PUSH
118240: LD_VAR 0 2
118244: EQUAL
118245: PUSH
118246: LD_EXP 118
118250: PUSH
118251: LD_VAR 0 1
118255: ARRAY
118256: OR
118257: PUSH
118258: LD_EXP 95
118262: PUSH
118263: LD_VAR 0 1
118267: ARRAY
118268: NOT
118269: OR
118270: IFFALSE 118040
// end ; mc_defender := Replace ( mc_defender , base , UnitFilter ( defenders , [ f_type , unit_vehicle ] ) ) ;
118272: LD_ADDR_EXP 117
118276: PUSH
118277: LD_EXP 117
118281: PPUSH
118282: LD_VAR 0 1
118286: PPUSH
118287: LD_VAR 0 2
118291: PPUSH
118292: LD_INT 21
118294: PUSH
118295: LD_INT 2
118297: PUSH
118298: EMPTY
118299: LIST
118300: LIST
118301: PPUSH
118302: CALL_OW 72
118306: PPUSH
118307: CALL_OW 1
118311: ST_TO_ADDR
// MC_Reset ( base , 19 ) ;
118312: LD_VAR 0 1
118316: PPUSH
118317: LD_INT 19
118319: PPUSH
118320: CALL 25559 0 2
// MC_Reset ( base , 20 ) ;
118324: LD_VAR 0 1
118328: PPUSH
118329: LD_INT 20
118331: PPUSH
118332: CALL 25559 0 2
// end ; end_of_file
118336: LD_VAR 0 3
118340: RET
// on TargetableSAIL ( cmd , unit , selectedUnit , x , y , p1 , p2 , p3 , p4 , p5 , p6 ) do begin case cmd of 200 .. 299 :
118341: LD_VAR 0 1
118345: PUSH
118346: LD_INT 200
118348: DOUBLE
118349: GREATEREQUAL
118350: IFFALSE 118358
118352: LD_INT 299
118354: DOUBLE
118355: LESSEQUAL
118356: IFTRUE 118360
118358: GO 118392
118360: POP
// SOS_TargetableSAIL ( cmd , unit , selectedUnit , x , y ) ; 300 .. 399 :
118361: LD_VAR 0 1
118365: PPUSH
118366: LD_VAR 0 2
118370: PPUSH
118371: LD_VAR 0 3
118375: PPUSH
118376: LD_VAR 0 4
118380: PPUSH
118381: LD_VAR 0 5
118385: PPUSH
118386: CALL 106778 0 5
118390: GO 118469
118392: LD_INT 300
118394: DOUBLE
118395: GREATEREQUAL
118396: IFFALSE 118404
118398: LD_INT 399
118400: DOUBLE
118401: LESSEQUAL
118402: IFTRUE 118406
118404: GO 118468
118406: POP
// SOS_TargetableHack ( cmd , unit , selectedUnit , x , y , p1 , p2 , p3 , p4 , p5 , p6 ) ; end ;
118407: LD_VAR 0 1
118411: PPUSH
118412: LD_VAR 0 2
118416: PPUSH
118417: LD_VAR 0 3
118421: PPUSH
118422: LD_VAR 0 4
118426: PPUSH
118427: LD_VAR 0 5
118431: PPUSH
118432: LD_VAR 0 6
118436: PPUSH
118437: LD_VAR 0 7
118441: PPUSH
118442: LD_VAR 0 8
118446: PPUSH
118447: LD_VAR 0 9
118451: PPUSH
118452: LD_VAR 0 10
118456: PPUSH
118457: LD_VAR 0 11
118461: PPUSH
118462: CALL 104420 0 11
118466: GO 118469
118468: POP
// end ;
118469: PPOPN 11
118471: END
// on CommandUnitXY ( cmd , un , target , x , y ) do begin SOS_CommandUnitXY ( cmd , un , target , x , y ) ;
118472: LD_VAR 0 1
118476: PPUSH
118477: LD_VAR 0 2
118481: PPUSH
118482: LD_VAR 0 3
118486: PPUSH
118487: LD_VAR 0 4
118491: PPUSH
118492: LD_VAR 0 5
118496: PPUSH
118497: CALL 106514 0 5
// end ; end_of_file
118501: PPOPN 5
118503: END
// on CustomCommand ( p1 , p2 , p3 , p4 , p5 , p6 ) do begin SOS_CustomCommand ( p1 , p2 , p3 , p4 , p5 , p6 ) ;
118504: LD_VAR 0 1
118508: PPUSH
118509: LD_VAR 0 2
118513: PPUSH
118514: LD_VAR 0 3
118518: PPUSH
118519: LD_VAR 0 4
118523: PPUSH
118524: LD_VAR 0 5
118528: PPUSH
118529: LD_VAR 0 6
118533: PPUSH
118534: CALL 92113 0 6
// end ;
118538: PPOPN 6
118540: END
// on MapStart ( p ) do begin SOS_MapStart ( ) ;
118541: CALL 92088 0 0
// end ;
118545: PPOPN 1
118547: END
