// starting begin ResetFog ;
   0: CALL_OW 335
// AnimateTrees ( true ) ;
   4: LD_INT 1
   6: PPUSH
   7: CALL_OW 573
// InitVariables ;
  11: CALL 69 0 0
// InitMacro ;
  15: CALL 20368 0 0
// InitNature ;
  19: CALL 17026 0 0
// InitArtifact ;
  23: CALL 17639 0 0
// if debug then
  27: LD_EXP 1
  31: IFFALSE 40
// FogOff ( 1 ) ;
  33: LD_INT 1
  35: PPUSH
  36: CALL_OW 344
// PrepareAmerican ;
  40: CALL 4533 0 0
// PrepareAlliance ;
  44: CALL 1351 0 0
// PrepareArabian ;
  48: CALL 6301 0 0
// PrepareRussian ;
  52: CALL 8305 0 0
// PrepareLegion ;
  56: CALL 6748 0 0
// Action ;
  60: CALL 10858 0 0
// MC_Start ( ) ;
  64: CALL 22480 0 0
// end ;
  68: END
// export debug ; export russianDestroyed , legionDestroyed , americanDestroyed , arabianDestroyed ; export artifactArCaptured , alienSpotted , spawnOmar ; export artifactIResearched , artifactIIResearched , artifactIIIResearched ; export vehicleLostCounter , artifactDestroyCounter ; export function InitVariables ; begin
  69: LD_INT 0
  71: PPUSH
// debug := false ;
  72: LD_ADDR_EXP 1
  76: PUSH
  77: LD_INT 0
  79: ST_TO_ADDR
// artifactArCaptured := LoadVariable ( 11_artifact_captured , 0 ) ;
  80: LD_ADDR_EXP 6
  84: PUSH
  85: LD_STRING 11_artifact_captured
  87: PPUSH
  88: LD_INT 0
  90: PPUSH
  91: CALL_OW 30
  95: ST_TO_ADDR
// russianDestroyed := false ;
  96: LD_ADDR_EXP 2
 100: PUSH
 101: LD_INT 0
 103: ST_TO_ADDR
// legionDestroyed := false ;
 104: LD_ADDR_EXP 3
 108: PUSH
 109: LD_INT 0
 111: ST_TO_ADDR
// americanDestroyed := false ;
 112: LD_ADDR_EXP 4
 116: PUSH
 117: LD_INT 0
 119: ST_TO_ADDR
// arabianDestroyed := false ;
 120: LD_ADDR_EXP 5
 124: PUSH
 125: LD_INT 0
 127: ST_TO_ADDR
// artifactIResearched := false ;
 128: LD_ADDR_EXP 9
 132: PUSH
 133: LD_INT 0
 135: ST_TO_ADDR
// artifactIIResearched := false ;
 136: LD_ADDR_EXP 10
 140: PUSH
 141: LD_INT 0
 143: ST_TO_ADDR
// artifactIIIResearched := false ;
 144: LD_ADDR_EXP 11
 148: PUSH
 149: LD_INT 0
 151: ST_TO_ADDR
// alienSpotted := false ;
 152: LD_ADDR_EXP 7
 156: PUSH
 157: LD_INT 0
 159: ST_TO_ADDR
// spawnOmar := false ;
 160: LD_ADDR_EXP 8
 164: PUSH
 165: LD_INT 0
 167: ST_TO_ADDR
// vehicleLostCounter := 0 ;
 168: LD_ADDR_EXP 12
 172: PUSH
 173: LD_INT 0
 175: ST_TO_ADDR
// artifactDestroyCounter := 0 ;
 176: LD_ADDR_EXP 13
 180: PUSH
 181: LD_INT 0
 183: ST_TO_ADDR
// end ;
 184: LD_VAR 0 1
 188: RET
// export function CustomInitMacro ( ) ; begin
 189: LD_INT 0
 191: PPUSH
// mc_parking := [ arabianParkingArea , russianParkingArea , legionParkingArea , powellParking ] ;
 192: LD_ADDR_EXP 100
 196: PUSH
 197: LD_INT 26
 199: PUSH
 200: LD_INT 1
 202: PUSH
 203: LD_INT 4
 205: PUSH
 206: LD_INT 8
 208: PUSH
 209: EMPTY
 210: LIST
 211: LIST
 212: LIST
 213: LIST
 214: ST_TO_ADDR
// mc_scan_area := [ arabianBaseArea , russianBaseArea , legionBaseArea , powellBase ] ;
 215: LD_ADDR_EXP 101
 219: PUSH
 220: LD_INT 27
 222: PUSH
 223: LD_INT 2
 225: PUSH
 226: LD_INT 3
 228: PUSH
 229: LD_INT 7
 231: PUSH
 232: EMPTY
 233: LIST
 234: LIST
 235: LIST
 236: LIST
 237: ST_TO_ADDR
// MC_SetMinesField ( 1 , [ 6 , 7 , 9 ] [ Difficulty ] , arabianMinefield ) ;
 238: LD_INT 1
 240: PPUSH
 241: LD_INT 6
 243: PUSH
 244: LD_INT 7
 246: PUSH
 247: LD_INT 9
 249: PUSH
 250: EMPTY
 251: LIST
 252: LIST
 253: LIST
 254: PUSH
 255: LD_OWVAR 67
 259: ARRAY
 260: PPUSH
 261: LD_INT 28
 263: PPUSH
 264: CALL 43697 0 3
// MC_SetLabKind ( 1 , [ b_lab_weapon , b_lab_siberium , b_lab_biological , b_lab_opto ] ) ;
 268: LD_INT 1
 270: PPUSH
 271: LD_INT 10
 273: PUSH
 274: LD_INT 11
 276: PUSH
 277: LD_INT 13
 279: PUSH
 280: LD_INT 15
 282: PUSH
 283: EMPTY
 284: LIST
 285: LIST
 286: LIST
 287: LIST
 288: PPUSH
 289: CALL 44757 0 2
// MC_SetCratesArea ( 1 , [ arabianCratesArea ] ) ;
 293: LD_INT 1
 295: PPUSH
 296: LD_INT 29
 298: PUSH
 299: EMPTY
 300: LIST
 301: PPUSH
 302: CALL 44850 0 2
// mc_ape := Replace ( mc_ape , 1 , FilterAllUnits ( [ [ f_side , 2 ] , [ f_class , class_apeman_soldier ] ] ) ) ;
 306: LD_ADDR_EXP 105
 310: PUSH
 311: LD_EXP 105
 315: PPUSH
 316: LD_INT 1
 318: PPUSH
 319: LD_INT 22
 321: PUSH
 322: LD_INT 2
 324: PUSH
 325: EMPTY
 326: LIST
 327: LIST
 328: PUSH
 329: LD_INT 25
 331: PUSH
 332: LD_INT 15
 334: PUSH
 335: EMPTY
 336: LIST
 337: LIST
 338: PUSH
 339: EMPTY
 340: LIST
 341: LIST
 342: PPUSH
 343: CALL_OW 69
 347: PPUSH
 348: CALL_OW 1
 352: ST_TO_ADDR
// MC_SetProduceList ( 1 , [ [ ar_medium_trike , engine_solar , control_manual , ar_control_tower ] , [ ar_medium_trike , engine_solar , control_manual , ar_control_tower ] , [ ar_medium_trike , engine_combustion , control_manual , ar_rocket_launcher ] , [ ar_medium_trike , engine_combustion , control_manual , ar_rocket_launcher ] , [ ar_medium_trike , engine_combustion , control_manual , ar_rocket_launcher ] , [ ar_medium_trike , engine_combustion , control_manual , ar_rocket_launcher ] ] ) ;
 353: LD_INT 1
 355: PPUSH
 356: LD_INT 13
 358: PUSH
 359: LD_INT 2
 361: PUSH
 362: LD_INT 1
 364: PUSH
 365: LD_INT 31
 367: PUSH
 368: EMPTY
 369: LIST
 370: LIST
 371: LIST
 372: LIST
 373: PUSH
 374: LD_INT 13
 376: PUSH
 377: LD_INT 2
 379: PUSH
 380: LD_INT 1
 382: PUSH
 383: LD_INT 31
 385: PUSH
 386: EMPTY
 387: LIST
 388: LIST
 389: LIST
 390: LIST
 391: PUSH
 392: LD_INT 13
 394: PUSH
 395: LD_INT 1
 397: PUSH
 398: LD_INT 1
 400: PUSH
 401: LD_INT 28
 403: PUSH
 404: EMPTY
 405: LIST
 406: LIST
 407: LIST
 408: LIST
 409: PUSH
 410: LD_INT 13
 412: PUSH
 413: LD_INT 1
 415: PUSH
 416: LD_INT 1
 418: PUSH
 419: LD_INT 28
 421: PUSH
 422: EMPTY
 423: LIST
 424: LIST
 425: LIST
 426: LIST
 427: PUSH
 428: LD_INT 13
 430: PUSH
 431: LD_INT 1
 433: PUSH
 434: LD_INT 1
 436: PUSH
 437: LD_INT 28
 439: PUSH
 440: EMPTY
 441: LIST
 442: LIST
 443: LIST
 444: LIST
 445: PUSH
 446: LD_INT 13
 448: PUSH
 449: LD_INT 1
 451: PUSH
 452: LD_INT 1
 454: PUSH
 455: LD_INT 28
 457: PUSH
 458: EMPTY
 459: LIST
 460: LIST
 461: LIST
 462: LIST
 463: PUSH
 464: EMPTY
 465: LIST
 466: LIST
 467: LIST
 468: LIST
 469: LIST
 470: LIST
 471: PPUSH
 472: CALL 44015 0 2
// MC_SetDefenderLimit ( 1 , 4 ) ;
 476: LD_INT 1
 478: PPUSH
 479: LD_INT 4
 481: PPUSH
 482: CALL 44200 0 2
// MC_SetLabKind ( 2 , [ b_lab_weapon , b_lab_siberium , b_lab_computer , b_lab_spacetime ] ) ;
 486: LD_INT 2
 488: PPUSH
 489: LD_INT 10
 491: PUSH
 492: LD_INT 11
 494: PUSH
 495: LD_INT 12
 497: PUSH
 498: LD_INT 14
 500: PUSH
 501: EMPTY
 502: LIST
 503: LIST
 504: LIST
 505: LIST
 506: PPUSH
 507: CALL 44757 0 2
// MC_SetCratesArea ( 2 , [ russianCratesArea ] ) ;
 511: LD_INT 2
 513: PPUSH
 514: LD_INT 14
 516: PUSH
 517: EMPTY
 518: LIST
 519: PPUSH
 520: CALL 44850 0 2
// MC_SetProduceList ( 2 , [ [ ru_medium_wheeled , engine_siberite , control_computer , ru_cargo_bay ] , [ ru_medium_tracked , engine_siberite , control_computer , ru_crane ] , [ ru_medium_tracked , engine_siberite , control_computer , ru_crane ] , [ ru_heavy_tracked , engine_siberite , control_computer , ru_rocket ] , [ ru_heavy_tracked , engine_siberite , control_computer , ru_rocket ] , [ ru_heavy_tracked , engine_siberite , control_computer , ru_rocket ] , [ ru_heavy_tracked , engine_siberite , control_computer , ru_rocket ] , [ ru_heavy_tracked , engine_siberite , control_computer , ru_rocket ] ] ) ;
 524: LD_INT 2
 526: PPUSH
 527: LD_INT 21
 529: PUSH
 530: LD_INT 3
 532: PUSH
 533: LD_INT 3
 535: PUSH
 536: LD_INT 51
 538: PUSH
 539: EMPTY
 540: LIST
 541: LIST
 542: LIST
 543: LIST
 544: PUSH
 545: LD_INT 22
 547: PUSH
 548: LD_INT 3
 550: PUSH
 551: LD_INT 3
 553: PUSH
 554: LD_INT 52
 556: PUSH
 557: EMPTY
 558: LIST
 559: LIST
 560: LIST
 561: LIST
 562: PUSH
 563: LD_INT 22
 565: PUSH
 566: LD_INT 3
 568: PUSH
 569: LD_INT 3
 571: PUSH
 572: LD_INT 52
 574: PUSH
 575: EMPTY
 576: LIST
 577: LIST
 578: LIST
 579: LIST
 580: PUSH
 581: LD_INT 24
 583: PUSH
 584: LD_INT 3
 586: PUSH
 587: LD_INT 3
 589: PUSH
 590: LD_INT 47
 592: PUSH
 593: EMPTY
 594: LIST
 595: LIST
 596: LIST
 597: LIST
 598: PUSH
 599: LD_INT 24
 601: PUSH
 602: LD_INT 3
 604: PUSH
 605: LD_INT 3
 607: PUSH
 608: LD_INT 47
 610: PUSH
 611: EMPTY
 612: LIST
 613: LIST
 614: LIST
 615: LIST
 616: PUSH
 617: LD_INT 24
 619: PUSH
 620: LD_INT 3
 622: PUSH
 623: LD_INT 3
 625: PUSH
 626: LD_INT 47
 628: PUSH
 629: EMPTY
 630: LIST
 631: LIST
 632: LIST
 633: LIST
 634: PUSH
 635: LD_INT 24
 637: PUSH
 638: LD_INT 3
 640: PUSH
 641: LD_INT 3
 643: PUSH
 644: LD_INT 47
 646: PUSH
 647: EMPTY
 648: LIST
 649: LIST
 650: LIST
 651: LIST
 652: PUSH
 653: LD_INT 24
 655: PUSH
 656: LD_INT 3
 658: PUSH
 659: LD_INT 3
 661: PUSH
 662: LD_INT 47
 664: PUSH
 665: EMPTY
 666: LIST
 667: LIST
 668: LIST
 669: LIST
 670: PUSH
 671: EMPTY
 672: LIST
 673: LIST
 674: LIST
 675: LIST
 676: LIST
 677: LIST
 678: LIST
 679: LIST
 680: PPUSH
 681: CALL 44015 0 2
// MC_SetDefenderLimit ( 2 , 5 ) ;
 685: LD_INT 2
 687: PPUSH
 688: LD_INT 5
 690: PPUSH
 691: CALL 44200 0 2
// MC_SetUpgradeBuilding ( 2 , b_depot ) ;
 695: LD_INT 2
 697: PPUSH
 698: LD_INT 0
 700: PPUSH
 701: CALL 44630 0 2
// MC_SetMinesField ( 3 , [ 10 , 12 , 15 ] [ Difficulty ] , legionMinefield ) ;
 705: LD_INT 3
 707: PPUSH
 708: LD_INT 10
 710: PUSH
 711: LD_INT 12
 713: PUSH
 714: LD_INT 15
 716: PUSH
 717: EMPTY
 718: LIST
 719: LIST
 720: LIST
 721: PUSH
 722: LD_OWVAR 67
 726: ARRAY
 727: PPUSH
 728: LD_INT 24
 730: PPUSH
 731: CALL 43697 0 3
// MC_SetLabKind ( 3 , [ b_lab_weapon , b_lab_siberium , b_lab_biological , b_lab_opto ] ) ;
 735: LD_INT 3
 737: PPUSH
 738: LD_INT 10
 740: PUSH
 741: LD_INT 11
 743: PUSH
 744: LD_INT 13
 746: PUSH
 747: LD_INT 15
 749: PUSH
 750: EMPTY
 751: LIST
 752: LIST
 753: LIST
 754: LIST
 755: PPUSH
 756: CALL 44757 0 2
// MC_SetCratesArea ( 3 , [ legionCratesArea ] ) ;
 760: LD_INT 3
 762: PPUSH
 763: LD_INT 13
 765: PUSH
 766: EMPTY
 767: LIST
 768: PPUSH
 769: CALL 44850 0 2
// mc_ape := Replace ( mc_ape , 3 , FilterAllUnits ( [ [ f_side , 8 ] , [ f_class , class_apeman_soldier ] ] ) ) ;
 773: LD_ADDR_EXP 105
 777: PUSH
 778: LD_EXP 105
 782: PPUSH
 783: LD_INT 3
 785: PPUSH
 786: LD_INT 22
 788: PUSH
 789: LD_INT 8
 791: PUSH
 792: EMPTY
 793: LIST
 794: LIST
 795: PUSH
 796: LD_INT 25
 798: PUSH
 799: LD_INT 15
 801: PUSH
 802: EMPTY
 803: LIST
 804: LIST
 805: PUSH
 806: EMPTY
 807: LIST
 808: LIST
 809: PPUSH
 810: CALL_OW 69
 814: PPUSH
 815: CALL_OW 1
 819: ST_TO_ADDR
// MC_SetProduceList ( 3 , [ [ ar_medium_trike , engine_solar , control_manual , ar_control_tower ] , [ ar_medium_trike , engine_solar , control_manual , ar_control_tower ] , [ ar_medium_trike , engine_siberite , control_remote , ar_cargo_bay ] , [ ar_half_tracked , engine_combustion , control_manual , ar_rocket_launcher ] , [ ar_half_tracked , engine_combustion , control_manual , ar_rocket_launcher ] , [ ar_half_tracked , engine_combustion , control_manual , ar_rocket_launcher ] , [ ar_half_tracked , engine_combustion , control_manual , ar_rocket_launcher ] ] ) ;
 820: LD_INT 3
 822: PPUSH
 823: LD_INT 13
 825: PUSH
 826: LD_INT 2
 828: PUSH
 829: LD_INT 1
 831: PUSH
 832: LD_INT 31
 834: PUSH
 835: EMPTY
 836: LIST
 837: LIST
 838: LIST
 839: LIST
 840: PUSH
 841: LD_INT 13
 843: PUSH
 844: LD_INT 2
 846: PUSH
 847: LD_INT 1
 849: PUSH
 850: LD_INT 31
 852: PUSH
 853: EMPTY
 854: LIST
 855: LIST
 856: LIST
 857: LIST
 858: PUSH
 859: LD_INT 13
 861: PUSH
 862: LD_INT 3
 864: PUSH
 865: LD_INT 2
 867: PUSH
 868: LD_INT 32
 870: PUSH
 871: EMPTY
 872: LIST
 873: LIST
 874: LIST
 875: LIST
 876: PUSH
 877: LD_INT 14
 879: PUSH
 880: LD_INT 1
 882: PUSH
 883: LD_INT 1
 885: PUSH
 886: LD_INT 28
 888: PUSH
 889: EMPTY
 890: LIST
 891: LIST
 892: LIST
 893: LIST
 894: PUSH
 895: LD_INT 14
 897: PUSH
 898: LD_INT 1
 900: PUSH
 901: LD_INT 1
 903: PUSH
 904: LD_INT 28
 906: PUSH
 907: EMPTY
 908: LIST
 909: LIST
 910: LIST
 911: LIST
 912: PUSH
 913: LD_INT 14
 915: PUSH
 916: LD_INT 1
 918: PUSH
 919: LD_INT 1
 921: PUSH
 922: LD_INT 28
 924: PUSH
 925: EMPTY
 926: LIST
 927: LIST
 928: LIST
 929: LIST
 930: PUSH
 931: LD_INT 14
 933: PUSH
 934: LD_INT 1
 936: PUSH
 937: LD_INT 1
 939: PUSH
 940: LD_INT 28
 942: PUSH
 943: EMPTY
 944: LIST
 945: LIST
 946: LIST
 947: LIST
 948: PUSH
 949: EMPTY
 950: LIST
 951: LIST
 952: LIST
 953: LIST
 954: LIST
 955: LIST
 956: LIST
 957: PPUSH
 958: CALL 44015 0 2
// MC_SetDefenderLimit ( 3 , 4 ) ;
 962: LD_INT 3
 964: PPUSH
 965: LD_INT 4
 967: PPUSH
 968: CALL 44200 0 2
// MC_SetLabKind ( 4 , [ b_lab_weapon , b_lab_computer , b_lab_siberium , b_lab_opto ] ) ;
 972: LD_INT 4
 974: PPUSH
 975: LD_INT 10
 977: PUSH
 978: LD_INT 12
 980: PUSH
 981: LD_INT 11
 983: PUSH
 984: LD_INT 15
 986: PUSH
 987: EMPTY
 988: LIST
 989: LIST
 990: LIST
 991: LIST
 992: PPUSH
 993: CALL 44757 0 2
// MC_SetCratesArea ( 4 , [ americanCratesArea ] ) ;
 997: LD_INT 4
 999: PPUSH
1000: LD_INT 33
1002: PUSH
1003: EMPTY
1004: LIST
1005: PPUSH
1006: CALL 44850 0 2
// MC_SetAllowedTurretWeapons ( 4 , [ us_double_gun , us_heavy_gun , us_rocket_launcher , us_laser , us_double_laser ] ) ;
1010: LD_INT 4
1012: PPUSH
1013: LD_INT 5
1015: PUSH
1016: LD_INT 6
1018: PUSH
1019: LD_INT 7
1021: PUSH
1022: LD_INT 9
1024: PUSH
1025: LD_INT 10
1027: PUSH
1028: EMPTY
1029: LIST
1030: LIST
1031: LIST
1032: LIST
1033: LIST
1034: PPUSH
1035: CALL 45168 0 2
// MC_SetFactoryExtension ( 4 , 54 , 85 , 2 , [ b_ext_laser , b_ext_track , b_ext_gun , b_ext_rocket , b_ext_radio ] ) ;
1039: LD_INT 4
1041: PPUSH
1042: LD_INT 54
1044: PPUSH
1045: LD_INT 85
1047: PPUSH
1048: LD_INT 2
1050: PPUSH
1051: LD_INT 25
1053: PUSH
1054: LD_INT 16
1056: PUSH
1057: LD_INT 17
1059: PUSH
1060: LD_INT 18
1062: PUSH
1063: LD_INT 22
1065: PUSH
1066: EMPTY
1067: LIST
1068: LIST
1069: LIST
1070: LIST
1071: LIST
1072: PPUSH
1073: CALL 44962 0 5
// MC_SetProduceList ( 4 , [ [ us_morphling , engine_combustion , control_manual , us_rocket_launcher ] , [ us_morphling , engine_combustion , control_manual , us_heavy_gun ] , [ us_morphling , engine_combustion , control_manual , us_rocket_launcher ] , [ us_morphling , engine_combustion , control_manual , us_heavy_gun ] , [ us_morphling , engine_combustion , control_computer , us_cargo_bay ] , [ us_medium_tracked , engine_combustion , control_computer , us_crane ] ] ) ;
1077: LD_INT 4
1079: PPUSH
1080: LD_INT 5
1082: PUSH
1083: LD_INT 1
1085: PUSH
1086: LD_INT 1
1088: PUSH
1089: LD_INT 7
1091: PUSH
1092: EMPTY
1093: LIST
1094: LIST
1095: LIST
1096: LIST
1097: PUSH
1098: LD_INT 5
1100: PUSH
1101: LD_INT 1
1103: PUSH
1104: LD_INT 1
1106: PUSH
1107: LD_INT 6
1109: PUSH
1110: EMPTY
1111: LIST
1112: LIST
1113: LIST
1114: LIST
1115: PUSH
1116: LD_INT 5
1118: PUSH
1119: LD_INT 1
1121: PUSH
1122: LD_INT 1
1124: PUSH
1125: LD_INT 7
1127: PUSH
1128: EMPTY
1129: LIST
1130: LIST
1131: LIST
1132: LIST
1133: PUSH
1134: LD_INT 5
1136: PUSH
1137: LD_INT 1
1139: PUSH
1140: LD_INT 1
1142: PUSH
1143: LD_INT 6
1145: PUSH
1146: EMPTY
1147: LIST
1148: LIST
1149: LIST
1150: LIST
1151: PUSH
1152: LD_INT 5
1154: PUSH
1155: LD_INT 1
1157: PUSH
1158: LD_INT 3
1160: PUSH
1161: LD_INT 12
1163: PUSH
1164: EMPTY
1165: LIST
1166: LIST
1167: LIST
1168: LIST
1169: PUSH
1170: LD_INT 3
1172: PUSH
1173: LD_INT 1
1175: PUSH
1176: LD_INT 3
1178: PUSH
1179: LD_INT 13
1181: PUSH
1182: EMPTY
1183: LIST
1184: LIST
1185: LIST
1186: LIST
1187: PUSH
1188: EMPTY
1189: LIST
1190: LIST
1191: LIST
1192: LIST
1193: LIST
1194: LIST
1195: PPUSH
1196: CALL 44015 0 2
// MC_SetDefenderLimit ( 4 , 4 ) ;
1200: LD_INT 4
1202: PPUSH
1203: LD_INT 4
1205: PPUSH
1206: CALL 44200 0 2
// MC_SetTame ( 4 , powellApe ) ;
1210: LD_INT 4
1212: PPUSH
1213: LD_INT 11
1215: PPUSH
1216: CALL 44581 0 2
// end ;
1220: LD_VAR 0 1
1224: RET
// every 0 0$1 trigger debug do var i ;
1225: LD_EXP 1
1229: IFFALSE 1327
1231: GO 1233
1233: DISABLE
1234: LD_INT 0
1236: PPUSH
// begin enable ;
1237: ENABLE
// for i in FilterAllUnits ( [ [ f_side , 7 ] , [ f_or , [ f_type , unit_human ] , [ f_type , unit_vehicle ] ] , [ f_not , [ f_lives , 1000 ] ] ] ) do
1238: LD_ADDR_VAR 0 1
1242: PUSH
1243: LD_INT 22
1245: PUSH
1246: LD_INT 7
1248: PUSH
1249: EMPTY
1250: LIST
1251: LIST
1252: PUSH
1253: LD_INT 2
1255: PUSH
1256: LD_INT 21
1258: PUSH
1259: LD_INT 1
1261: PUSH
1262: EMPTY
1263: LIST
1264: LIST
1265: PUSH
1266: LD_INT 21
1268: PUSH
1269: LD_INT 2
1271: PUSH
1272: EMPTY
1273: LIST
1274: LIST
1275: PUSH
1276: EMPTY
1277: LIST
1278: LIST
1279: LIST
1280: PUSH
1281: LD_INT 3
1283: PUSH
1284: LD_INT 24
1286: PUSH
1287: LD_INT 1000
1289: PUSH
1290: EMPTY
1291: LIST
1292: LIST
1293: PUSH
1294: EMPTY
1295: LIST
1296: LIST
1297: PUSH
1298: EMPTY
1299: LIST
1300: LIST
1301: LIST
1302: PPUSH
1303: CALL_OW 69
1307: PUSH
1308: FOR_IN
1309: IFFALSE 1325
// SetLives ( i , 1000 ) ;
1311: LD_VAR 0 1
1315: PPUSH
1316: LD_INT 1000
1318: PPUSH
1319: CALL_OW 234
1323: GO 1308
1325: POP
1326: POP
// end ;
1327: PPOPN 1
1329: END
// every 0 0$1 trigger artifactDestroyCounter >= 5 do
1330: LD_EXP 13
1334: PUSH
1335: LD_INT 5
1337: GREATEREQUAL
1338: IFFALSE 1350
1340: GO 1342
1342: DISABLE
// SetAchievement ( ACH_ARTIFACT ) ; end_of_file
1343: LD_STRING ACH_ARTIFACT
1345: PPUSH
1346: CALL_OW 543
1350: END
// export JMM , Roth , Lisa , Donaldson , Bobby , Cyrus , Denis , Brown , Gladstone , Houten , Cornel , Gary , Frank , Kikuchi , Simms , Joan , DeltaDoctor , Connie ; export Gossudarov , Kirilenkova , Titov , Fadeev , Dolgov , Petrosyan , Scholtze , Oblukov , Kapitsova , Lipshchin , Petrovova , Kovalyuk , Kuzmov , Karamazov ; export Burlak , Belkov , Gnyevko ; export function PrepareAlliance ; var i , veh , selected , tmp ; begin
1351: LD_INT 0
1353: PPUSH
1354: PPUSH
1355: PPUSH
1356: PPUSH
1357: PPUSH
// uc_side := 7 ;
1358: LD_ADDR_OWVAR 20
1362: PUSH
1363: LD_INT 7
1365: ST_TO_ADDR
// tmp := [ ] ;
1366: LD_ADDR_VAR 0 5
1370: PUSH
1371: EMPTY
1372: ST_TO_ADDR
// JMM := PrepareUnit ( JMM , ( not debug ) , 14a_ ) ;
1373: LD_ADDR_EXP 14
1377: PUSH
1378: LD_STRING JMM
1380: PPUSH
1381: LD_EXP 1
1385: NOT
1386: PPUSH
1387: LD_STRING 14a_
1389: PPUSH
1390: CALL 50407 0 3
1394: ST_TO_ADDR
// Burlak := PrepareUnit ( Burlak , ( not debug ) , 14a_ ) ;
1395: LD_ADDR_EXP 46
1399: PUSH
1400: LD_STRING Burlak
1402: PPUSH
1403: LD_EXP 1
1407: NOT
1408: PPUSH
1409: LD_STRING 14a_
1411: PPUSH
1412: CALL 50407 0 3
1416: ST_TO_ADDR
// Joan := PrepareUnit ( Joan , ( not debug ) , 13a_ ) ;
1417: LD_ADDR_EXP 29
1421: PUSH
1422: LD_STRING Joan
1424: PPUSH
1425: LD_EXP 1
1429: NOT
1430: PPUSH
1431: LD_STRING 13a_
1433: PPUSH
1434: CALL 50407 0 3
1438: ST_TO_ADDR
// Roth := PrepareUnit ( Roth , ( not debug ) , 13a_ ) ;
1439: LD_ADDR_EXP 15
1443: PUSH
1444: LD_STRING Roth
1446: PPUSH
1447: LD_EXP 1
1451: NOT
1452: PPUSH
1453: LD_STRING 13a_
1455: PPUSH
1456: CALL 50407 0 3
1460: ST_TO_ADDR
// Gossudarov := PrepareUnit ( Gossudarov , ( not debug ) , 13a_ ) ;
1461: LD_ADDR_EXP 32
1465: PUSH
1466: LD_STRING Gossudarov
1468: PPUSH
1469: LD_EXP 1
1473: NOT
1474: PPUSH
1475: LD_STRING 13a_
1477: PPUSH
1478: CALL 50407 0 3
1482: ST_TO_ADDR
// DeltaDoctor := PrepareUnit ( DeltaDoctor , ( not debug ) , 13a_ ) ;
1483: LD_ADDR_EXP 30
1487: PUSH
1488: LD_STRING DeltaDoctor
1490: PPUSH
1491: LD_EXP 1
1495: NOT
1496: PPUSH
1497: LD_STRING 13a_
1499: PPUSH
1500: CALL 50407 0 3
1504: ST_TO_ADDR
// if DeltaDoctor then
1505: LD_EXP 30
1509: IFFALSE 1527
// tmp := tmp ^ DeltaDoctor ;
1511: LD_ADDR_VAR 0 5
1515: PUSH
1516: LD_VAR 0 5
1520: PUSH
1521: LD_EXP 30
1525: ADD
1526: ST_TO_ADDR
// Simms := PrepareUnit ( Simms , ( not debug ) , 13a_ ) ;
1527: LD_ADDR_EXP 28
1531: PUSH
1532: LD_STRING Simms
1534: PPUSH
1535: LD_EXP 1
1539: NOT
1540: PPUSH
1541: LD_STRING 13a_
1543: PPUSH
1544: CALL 50407 0 3
1548: ST_TO_ADDR
// if Simms then
1549: LD_EXP 28
1553: IFFALSE 1571
// tmp := tmp ^ Simms ;
1555: LD_ADDR_VAR 0 5
1559: PUSH
1560: LD_VAR 0 5
1564: PUSH
1565: LD_EXP 28
1569: ADD
1570: ST_TO_ADDR
// Frank := PrepareUnit ( Frank , ( not debug ) , 13a_ ) ;
1571: LD_ADDR_EXP 26
1575: PUSH
1576: LD_STRING Frank
1578: PPUSH
1579: LD_EXP 1
1583: NOT
1584: PPUSH
1585: LD_STRING 13a_
1587: PPUSH
1588: CALL 50407 0 3
1592: ST_TO_ADDR
// if Frank then
1593: LD_EXP 26
1597: IFFALSE 1615
// tmp := tmp ^ Frank ;
1599: LD_ADDR_VAR 0 5
1603: PUSH
1604: LD_VAR 0 5
1608: PUSH
1609: LD_EXP 26
1613: ADD
1614: ST_TO_ADDR
// Kirilenkova := PrepareUnit ( Kirilenkova , ( not debug ) , 13a_ ) ;
1615: LD_ADDR_EXP 33
1619: PUSH
1620: LD_STRING Kirilenkova
1622: PPUSH
1623: LD_EXP 1
1627: NOT
1628: PPUSH
1629: LD_STRING 13a_
1631: PPUSH
1632: CALL 50407 0 3
1636: ST_TO_ADDR
// if Kirilenkova then
1637: LD_EXP 33
1641: IFFALSE 1659
// tmp := tmp ^ Kirilenkova ;
1643: LD_ADDR_VAR 0 5
1647: PUSH
1648: LD_VAR 0 5
1652: PUSH
1653: LD_EXP 33
1657: ADD
1658: ST_TO_ADDR
// Titov := PrepareUnit ( Titov , ( not debug ) , 13a_ ) ;
1659: LD_ADDR_EXP 34
1663: PUSH
1664: LD_STRING Titov
1666: PPUSH
1667: LD_EXP 1
1671: NOT
1672: PPUSH
1673: LD_STRING 13a_
1675: PPUSH
1676: CALL 50407 0 3
1680: ST_TO_ADDR
// if Titov then
1681: LD_EXP 34
1685: IFFALSE 1703
// tmp := tmp ^ Titov ;
1687: LD_ADDR_VAR 0 5
1691: PUSH
1692: LD_VAR 0 5
1696: PUSH
1697: LD_EXP 34
1701: ADD
1702: ST_TO_ADDR
// Fadeev := PrepareUnit ( Fadeev , ( not debug ) , 13a_ ) ;
1703: LD_ADDR_EXP 35
1707: PUSH
1708: LD_STRING Fadeev
1710: PPUSH
1711: LD_EXP 1
1715: NOT
1716: PPUSH
1717: LD_STRING 13a_
1719: PPUSH
1720: CALL 50407 0 3
1724: ST_TO_ADDR
// if Fadeev then
1725: LD_EXP 35
1729: IFFALSE 1747
// tmp := tmp ^ Fadeev ;
1731: LD_ADDR_VAR 0 5
1735: PUSH
1736: LD_VAR 0 5
1740: PUSH
1741: LD_EXP 35
1745: ADD
1746: ST_TO_ADDR
// Dolgov := PrepareUnit ( Dolgov , ( not debug ) , 13a_ ) ;
1747: LD_ADDR_EXP 36
1751: PUSH
1752: LD_STRING Dolgov
1754: PPUSH
1755: LD_EXP 1
1759: NOT
1760: PPUSH
1761: LD_STRING 13a_
1763: PPUSH
1764: CALL 50407 0 3
1768: ST_TO_ADDR
// if Dolgov then
1769: LD_EXP 36
1773: IFFALSE 1791
// tmp := tmp ^ Dolgov ;
1775: LD_ADDR_VAR 0 5
1779: PUSH
1780: LD_VAR 0 5
1784: PUSH
1785: LD_EXP 36
1789: ADD
1790: ST_TO_ADDR
// Petrosyan := PrepareUnit ( Petrosyan , ( not debug ) , 13a_ ) ;
1791: LD_ADDR_EXP 37
1795: PUSH
1796: LD_STRING Petrosyan
1798: PPUSH
1799: LD_EXP 1
1803: NOT
1804: PPUSH
1805: LD_STRING 13a_
1807: PPUSH
1808: CALL 50407 0 3
1812: ST_TO_ADDR
// if Petrosyan then
1813: LD_EXP 37
1817: IFFALSE 1835
// tmp := tmp ^ Petrosyan ;
1819: LD_ADDR_VAR 0 5
1823: PUSH
1824: LD_VAR 0 5
1828: PUSH
1829: LD_EXP 37
1833: ADD
1834: ST_TO_ADDR
// Scholtze := PrepareUnit ( Scholtze , ( not debug ) , 13a_ ) ;
1835: LD_ADDR_EXP 38
1839: PUSH
1840: LD_STRING Scholtze
1842: PPUSH
1843: LD_EXP 1
1847: NOT
1848: PPUSH
1849: LD_STRING 13a_
1851: PPUSH
1852: CALL 50407 0 3
1856: ST_TO_ADDR
// if Scholtze then
1857: LD_EXP 38
1861: IFFALSE 1879
// tmp := tmp ^ Scholtze ;
1863: LD_ADDR_VAR 0 5
1867: PUSH
1868: LD_VAR 0 5
1872: PUSH
1873: LD_EXP 38
1877: ADD
1878: ST_TO_ADDR
// Oblukov := PrepareUnit ( Oblukov , ( not debug ) , 13a_ ) ;
1879: LD_ADDR_EXP 39
1883: PUSH
1884: LD_STRING Oblukov
1886: PPUSH
1887: LD_EXP 1
1891: NOT
1892: PPUSH
1893: LD_STRING 13a_
1895: PPUSH
1896: CALL 50407 0 3
1900: ST_TO_ADDR
// if Oblukov then
1901: LD_EXP 39
1905: IFFALSE 1923
// tmp := tmp ^ Oblukov ;
1907: LD_ADDR_VAR 0 5
1911: PUSH
1912: LD_VAR 0 5
1916: PUSH
1917: LD_EXP 39
1921: ADD
1922: ST_TO_ADDR
// Kapitsova := PrepareUnit ( Kapitsova , ( not debug ) , 13a_ ) ;
1923: LD_ADDR_EXP 40
1927: PUSH
1928: LD_STRING Kapitsova
1930: PPUSH
1931: LD_EXP 1
1935: NOT
1936: PPUSH
1937: LD_STRING 13a_
1939: PPUSH
1940: CALL 50407 0 3
1944: ST_TO_ADDR
// if Kapitsova then
1945: LD_EXP 40
1949: IFFALSE 1967
// tmp := tmp ^ Kapitsova ;
1951: LD_ADDR_VAR 0 5
1955: PUSH
1956: LD_VAR 0 5
1960: PUSH
1961: LD_EXP 40
1965: ADD
1966: ST_TO_ADDR
// Lipshchin := PrepareUnit ( Lipshchin , ( not debug ) , 13a_ ) ;
1967: LD_ADDR_EXP 41
1971: PUSH
1972: LD_STRING Lipshchin
1974: PPUSH
1975: LD_EXP 1
1979: NOT
1980: PPUSH
1981: LD_STRING 13a_
1983: PPUSH
1984: CALL 50407 0 3
1988: ST_TO_ADDR
// if Lipshchin then
1989: LD_EXP 41
1993: IFFALSE 2011
// tmp := tmp ^ Lipshchin ;
1995: LD_ADDR_VAR 0 5
1999: PUSH
2000: LD_VAR 0 5
2004: PUSH
2005: LD_EXP 41
2009: ADD
2010: ST_TO_ADDR
// Petrovova := PrepareUnit ( Petrovova , ( not debug ) , 13a_ ) ;
2011: LD_ADDR_EXP 42
2015: PUSH
2016: LD_STRING Petrovova
2018: PPUSH
2019: LD_EXP 1
2023: NOT
2024: PPUSH
2025: LD_STRING 13a_
2027: PPUSH
2028: CALL 50407 0 3
2032: ST_TO_ADDR
// if Petrovova then
2033: LD_EXP 42
2037: IFFALSE 2055
// tmp := tmp ^ Petrovova ;
2039: LD_ADDR_VAR 0 5
2043: PUSH
2044: LD_VAR 0 5
2048: PUSH
2049: LD_EXP 42
2053: ADD
2054: ST_TO_ADDR
// Kovalyuk := PrepareUnit ( Kovalyuk , ( not debug ) , 13a_ ) ;
2055: LD_ADDR_EXP 43
2059: PUSH
2060: LD_STRING Kovalyuk
2062: PPUSH
2063: LD_EXP 1
2067: NOT
2068: PPUSH
2069: LD_STRING 13a_
2071: PPUSH
2072: CALL 50407 0 3
2076: ST_TO_ADDR
// if Kovalyuk then
2077: LD_EXP 43
2081: IFFALSE 2099
// tmp := tmp ^ Kovalyuk ;
2083: LD_ADDR_VAR 0 5
2087: PUSH
2088: LD_VAR 0 5
2092: PUSH
2093: LD_EXP 43
2097: ADD
2098: ST_TO_ADDR
// Kuzmov := PrepareUnit ( Kuzmov , ( not debug ) , 13a_ ) ;
2099: LD_ADDR_EXP 44
2103: PUSH
2104: LD_STRING Kuzmov
2106: PPUSH
2107: LD_EXP 1
2111: NOT
2112: PPUSH
2113: LD_STRING 13a_
2115: PPUSH
2116: CALL 50407 0 3
2120: ST_TO_ADDR
// if Kuzmov then
2121: LD_EXP 44
2125: IFFALSE 2143
// tmp := tmp ^ Kuzmov ;
2127: LD_ADDR_VAR 0 5
2131: PUSH
2132: LD_VAR 0 5
2136: PUSH
2137: LD_EXP 44
2141: ADD
2142: ST_TO_ADDR
// Karamazov := PrepareUnit ( Karamazov , ( not debug ) , 13a_ ) ;
2143: LD_ADDR_EXP 45
2147: PUSH
2148: LD_STRING Karamazov
2150: PPUSH
2151: LD_EXP 1
2155: NOT
2156: PPUSH
2157: LD_STRING 13a_
2159: PPUSH
2160: CALL 50407 0 3
2164: ST_TO_ADDR
// if Karamazov then
2165: LD_EXP 45
2169: IFFALSE 2187
// tmp := tmp ^ Karamazov ;
2171: LD_ADDR_VAR 0 5
2175: PUSH
2176: LD_VAR 0 5
2180: PUSH
2181: LD_EXP 45
2185: ADD
2186: ST_TO_ADDR
// Belkov := PrepareUnit ( Belkov , ( not debug ) , 13a_ ) ;
2187: LD_ADDR_EXP 47
2191: PUSH
2192: LD_STRING Belkov
2194: PPUSH
2195: LD_EXP 1
2199: NOT
2200: PPUSH
2201: LD_STRING 13a_
2203: PPUSH
2204: CALL 50407 0 3
2208: ST_TO_ADDR
// if Belkov then
2209: LD_EXP 47
2213: IFFALSE 2231
// tmp := tmp ^ Belkov ;
2215: LD_ADDR_VAR 0 5
2219: PUSH
2220: LD_VAR 0 5
2224: PUSH
2225: LD_EXP 47
2229: ADD
2230: ST_TO_ADDR
// Gnyevko := PrepareUnit ( Gnyevko , ( not debug ) , 13a_ ) ;
2231: LD_ADDR_EXP 48
2235: PUSH
2236: LD_STRING Gnyevko
2238: PPUSH
2239: LD_EXP 1
2243: NOT
2244: PPUSH
2245: LD_STRING 13a_
2247: PPUSH
2248: CALL 50407 0 3
2252: ST_TO_ADDR
// if Gnyevko then
2253: LD_EXP 48
2257: IFFALSE 2275
// tmp := tmp ^ Gnyevko ;
2259: LD_ADDR_VAR 0 5
2263: PUSH
2264: LD_VAR 0 5
2268: PUSH
2269: LD_EXP 48
2273: ADD
2274: ST_TO_ADDR
// Connie = NewCharacter ( Coonie ) ;
2275: LD_ADDR_EXP 31
2279: PUSH
2280: LD_STRING Coonie
2282: PPUSH
2283: CALL_OW 25
2287: ST_TO_ADDR
// if not Lisa then
2288: LD_EXP 16
2292: NOT
2293: IFFALSE 2339
// begin Lisa := PrepareUnit ( Lisa , ( not debug ) , 13a_ ) ;
2295: LD_ADDR_EXP 16
2299: PUSH
2300: LD_STRING Lisa
2302: PPUSH
2303: LD_EXP 1
2307: NOT
2308: PPUSH
2309: LD_STRING 13a_
2311: PPUSH
2312: CALL 50407 0 3
2316: ST_TO_ADDR
// if Lisa then
2317: LD_EXP 16
2321: IFFALSE 2339
// tmp := tmp ^ Lisa ;
2323: LD_ADDR_VAR 0 5
2327: PUSH
2328: LD_VAR 0 5
2332: PUSH
2333: LD_EXP 16
2337: ADD
2338: ST_TO_ADDR
// end ; if not Donaldson then
2339: LD_EXP 17
2343: NOT
2344: IFFALSE 2390
// begin Donaldson := PrepareUnit ( Donaldson , ( not debug ) , 13a_ ) ;
2346: LD_ADDR_EXP 17
2350: PUSH
2351: LD_STRING Donaldson
2353: PPUSH
2354: LD_EXP 1
2358: NOT
2359: PPUSH
2360: LD_STRING 13a_
2362: PPUSH
2363: CALL 50407 0 3
2367: ST_TO_ADDR
// if Donaldson then
2368: LD_EXP 17
2372: IFFALSE 2390
// tmp := tmp ^ Donaldson ;
2374: LD_ADDR_VAR 0 5
2378: PUSH
2379: LD_VAR 0 5
2383: PUSH
2384: LD_EXP 17
2388: ADD
2389: ST_TO_ADDR
// end ; if not Bobby then
2390: LD_EXP 18
2394: NOT
2395: IFFALSE 2441
// begin Bobby := PrepareUnit ( Bobby , ( not debug ) , 13a_ ) ;
2397: LD_ADDR_EXP 18
2401: PUSH
2402: LD_STRING Bobby
2404: PPUSH
2405: LD_EXP 1
2409: NOT
2410: PPUSH
2411: LD_STRING 13a_
2413: PPUSH
2414: CALL 50407 0 3
2418: ST_TO_ADDR
// if Bobby then
2419: LD_EXP 18
2423: IFFALSE 2441
// tmp := tmp ^ Bobby ;
2425: LD_ADDR_VAR 0 5
2429: PUSH
2430: LD_VAR 0 5
2434: PUSH
2435: LD_EXP 18
2439: ADD
2440: ST_TO_ADDR
// end ; if not Cyrus then
2441: LD_EXP 19
2445: NOT
2446: IFFALSE 2492
// begin Cyrus := PrepareUnit ( Cyrus , ( not debug ) , 13a_ ) ;
2448: LD_ADDR_EXP 19
2452: PUSH
2453: LD_STRING Cyrus
2455: PPUSH
2456: LD_EXP 1
2460: NOT
2461: PPUSH
2462: LD_STRING 13a_
2464: PPUSH
2465: CALL 50407 0 3
2469: ST_TO_ADDR
// if Cyrus then
2470: LD_EXP 19
2474: IFFALSE 2492
// tmp := tmp ^ Cyrus ;
2476: LD_ADDR_VAR 0 5
2480: PUSH
2481: LD_VAR 0 5
2485: PUSH
2486: LD_EXP 19
2490: ADD
2491: ST_TO_ADDR
// end ; if not Brown then
2492: LD_EXP 21
2496: NOT
2497: IFFALSE 2543
// begin Brown := PrepareUnit ( Brown , ( not debug ) , 13a_ ) ;
2499: LD_ADDR_EXP 21
2503: PUSH
2504: LD_STRING Brown
2506: PPUSH
2507: LD_EXP 1
2511: NOT
2512: PPUSH
2513: LD_STRING 13a_
2515: PPUSH
2516: CALL 50407 0 3
2520: ST_TO_ADDR
// if Brown then
2521: LD_EXP 21
2525: IFFALSE 2543
// tmp := tmp ^ Brown ;
2527: LD_ADDR_VAR 0 5
2531: PUSH
2532: LD_VAR 0 5
2536: PUSH
2537: LD_EXP 21
2541: ADD
2542: ST_TO_ADDR
// end ; if not Gladstone then
2543: LD_EXP 22
2547: NOT
2548: IFFALSE 2594
// begin Gladstone := PrepareUnit ( Gladstone , ( not debug ) , 13a_ ) ;
2550: LD_ADDR_EXP 22
2554: PUSH
2555: LD_STRING Gladstone
2557: PPUSH
2558: LD_EXP 1
2562: NOT
2563: PPUSH
2564: LD_STRING 13a_
2566: PPUSH
2567: CALL 50407 0 3
2571: ST_TO_ADDR
// if Gladstone then
2572: LD_EXP 22
2576: IFFALSE 2594
// tmp := tmp ^ Gladstone ;
2578: LD_ADDR_VAR 0 5
2582: PUSH
2583: LD_VAR 0 5
2587: PUSH
2588: LD_EXP 22
2592: ADD
2593: ST_TO_ADDR
// end ; if not Cornel then
2594: LD_EXP 24
2598: NOT
2599: IFFALSE 2645
// begin Cornel := PrepareUnit ( Cornel , ( not debug ) , 13a_ ) ;
2601: LD_ADDR_EXP 24
2605: PUSH
2606: LD_STRING Cornel
2608: PPUSH
2609: LD_EXP 1
2613: NOT
2614: PPUSH
2615: LD_STRING 13a_
2617: PPUSH
2618: CALL 50407 0 3
2622: ST_TO_ADDR
// if Cornel then
2623: LD_EXP 24
2627: IFFALSE 2645
// tmp := tmp ^ Cornel ;
2629: LD_ADDR_VAR 0 5
2633: PUSH
2634: LD_VAR 0 5
2638: PUSH
2639: LD_EXP 24
2643: ADD
2644: ST_TO_ADDR
// end ; if not Houten then
2645: LD_EXP 23
2649: NOT
2650: IFFALSE 2696
// begin Houten := PrepareUnit ( Houten , ( not debug ) , 13a_ ) ;
2652: LD_ADDR_EXP 23
2656: PUSH
2657: LD_STRING Houten
2659: PPUSH
2660: LD_EXP 1
2664: NOT
2665: PPUSH
2666: LD_STRING 13a_
2668: PPUSH
2669: CALL 50407 0 3
2673: ST_TO_ADDR
// if Houten then
2674: LD_EXP 23
2678: IFFALSE 2696
// tmp := tmp ^ Houten ;
2680: LD_ADDR_VAR 0 5
2684: PUSH
2685: LD_VAR 0 5
2689: PUSH
2690: LD_EXP 23
2694: ADD
2695: ST_TO_ADDR
// end ; if not Gary then
2696: LD_EXP 25
2700: NOT
2701: IFFALSE 2747
// begin Gary := PrepareUnit ( Gary , ( not debug ) , 13a_ ) ;
2703: LD_ADDR_EXP 25
2707: PUSH
2708: LD_STRING Gary
2710: PPUSH
2711: LD_EXP 1
2715: NOT
2716: PPUSH
2717: LD_STRING 13a_
2719: PPUSH
2720: CALL 50407 0 3
2724: ST_TO_ADDR
// if Gary then
2725: LD_EXP 25
2729: IFFALSE 2747
// tmp := tmp ^ Gary ;
2731: LD_ADDR_VAR 0 5
2735: PUSH
2736: LD_VAR 0 5
2740: PUSH
2741: LD_EXP 25
2745: ADD
2746: ST_TO_ADDR
// end ; if not Kikuchi then
2747: LD_EXP 27
2751: NOT
2752: IFFALSE 2798
// begin Kikuchi := PrepareUnit ( Kikuchi , ( not debug ) , 13a_ ) ;
2754: LD_ADDR_EXP 27
2758: PUSH
2759: LD_STRING Kikuchi
2761: PPUSH
2762: LD_EXP 1
2766: NOT
2767: PPUSH
2768: LD_STRING 13a_
2770: PPUSH
2771: CALL 50407 0 3
2775: ST_TO_ADDR
// if Kikuchi then
2776: LD_EXP 27
2780: IFFALSE 2798
// tmp := tmp ^ Kikuchi ;
2782: LD_ADDR_VAR 0 5
2786: PUSH
2787: LD_VAR 0 5
2791: PUSH
2792: LD_EXP 27
2796: ADD
2797: ST_TO_ADDR
// end ; tmp := tmp union CreateCharacterSet ( 13a_others ) ;
2798: LD_ADDR_VAR 0 5
2802: PUSH
2803: LD_VAR 0 5
2807: PUSH
2808: LD_STRING 13a_others
2810: PPUSH
2811: CALL_OW 31
2815: UNION
2816: ST_TO_ADDR
// tmp := tmp diff 0 ;
2817: LD_ADDR_VAR 0 5
2821: PUSH
2822: LD_VAR 0 5
2826: PUSH
2827: LD_INT 0
2829: DIFF
2830: ST_TO_ADDR
// if tmp < 15 then
2831: LD_VAR 0 5
2835: PUSH
2836: LD_INT 15
2838: LESS
2839: IFFALSE 2927
// for i = 15 downto tmp do
2841: LD_ADDR_VAR 0 2
2845: PUSH
2846: DOUBLE
2847: LD_INT 15
2849: INC
2850: ST_TO_ADDR
2851: LD_VAR 0 5
2855: PUSH
2856: FOR_DOWNTO
2857: IFFALSE 2925
// begin uc_nation := [ 1 , 3 ] [ rand ( 1 , 2 ) ] ;
2859: LD_ADDR_OWVAR 21
2863: PUSH
2864: LD_INT 1
2866: PUSH
2867: LD_INT 3
2869: PUSH
2870: EMPTY
2871: LIST
2872: LIST
2873: PUSH
2874: LD_INT 1
2876: PPUSH
2877: LD_INT 2
2879: PPUSH
2880: CALL_OW 12
2884: ARRAY
2885: ST_TO_ADDR
// PrepareHuman ( false , rand ( 1 , 4 ) , 8 ) ;
2886: LD_INT 0
2888: PPUSH
2889: LD_INT 1
2891: PPUSH
2892: LD_INT 4
2894: PPUSH
2895: CALL_OW 12
2899: PPUSH
2900: LD_INT 8
2902: PPUSH
2903: CALL_OW 380
// tmp := tmp ^ CreateHuman ;
2907: LD_ADDR_VAR 0 5
2911: PUSH
2912: LD_VAR 0 5
2916: PUSH
2917: CALL_OW 44
2921: ADD
2922: ST_TO_ADDR
// end ;
2923: GO 2856
2925: POP
2926: POP
// if not debug then
2927: LD_EXP 1
2931: NOT
2932: IFFALSE 3104
// selected = CharacterSelection (  , [ 15 , 14 , 13 ] [ Difficulty ] , [ 15 , 14 , 13 ] [ Difficulty ] , [ sel_dont_change_class , JMM , Burlak , Roth , Joan , Denis , Gossudarov , sel_not_hired , sel_changeable , sel_change_class ] ^ tmp , [ class_soldier , class_scientistic , [ class_engineer , 1 ] , class_mechanic , [ class_sniper , 0 , 3 ] , [ class_bazooker , 0 , 3 ] ] ) else
2934: LD_ADDR_VAR 0 4
2938: PUSH
2939: LD_STRING 
2941: PPUSH
2942: LD_INT 15
2944: PUSH
2945: LD_INT 14
2947: PUSH
2948: LD_INT 13
2950: PUSH
2951: EMPTY
2952: LIST
2953: LIST
2954: LIST
2955: PUSH
2956: LD_OWVAR 67
2960: ARRAY
2961: PPUSH
2962: LD_INT 15
2964: PUSH
2965: LD_INT 14
2967: PUSH
2968: LD_INT 13
2970: PUSH
2971: EMPTY
2972: LIST
2973: LIST
2974: LIST
2975: PUSH
2976: LD_OWVAR 67
2980: ARRAY
2981: PPUSH
2982: LD_INT -6
2984: PUSH
2985: LD_EXP 14
2989: PUSH
2990: LD_EXP 46
2994: PUSH
2995: LD_EXP 15
2999: PUSH
3000: LD_EXP 29
3004: PUSH
3005: LD_EXP 20
3009: PUSH
3010: LD_EXP 32
3014: PUSH
3015: LD_INT -2
3017: PUSH
3018: LD_INT -3
3020: PUSH
3021: LD_INT -5
3023: PUSH
3024: EMPTY
3025: LIST
3026: LIST
3027: LIST
3028: LIST
3029: LIST
3030: LIST
3031: LIST
3032: LIST
3033: LIST
3034: LIST
3035: PUSH
3036: LD_VAR 0 5
3040: ADD
3041: PPUSH
3042: LD_INT 1
3044: PUSH
3045: LD_INT 4
3047: PUSH
3048: LD_INT 2
3050: PUSH
3051: LD_INT 1
3053: PUSH
3054: EMPTY
3055: LIST
3056: LIST
3057: PUSH
3058: LD_INT 3
3060: PUSH
3061: LD_INT 5
3063: PUSH
3064: LD_INT 0
3066: PUSH
3067: LD_INT 3
3069: PUSH
3070: EMPTY
3071: LIST
3072: LIST
3073: LIST
3074: PUSH
3075: LD_INT 9
3077: PUSH
3078: LD_INT 0
3080: PUSH
3081: LD_INT 3
3083: PUSH
3084: EMPTY
3085: LIST
3086: LIST
3087: LIST
3088: PUSH
3089: EMPTY
3090: LIST
3091: LIST
3092: LIST
3093: LIST
3094: LIST
3095: LIST
3096: PPUSH
3097: CALL_OW 42
3101: ST_TO_ADDR
3102: GO 3183
// selected := [ Titov , Fadeev , Dolgov , Petrosyan , Scholtze , Oblukov , Kapitsova , Lipshchin , Petrovova , Kovalyuk , Kuzmov , Karamazov ] ;
3104: LD_ADDR_VAR 0 4
3108: PUSH
3109: LD_EXP 34
3113: PUSH
3114: LD_EXP 35
3118: PUSH
3119: LD_EXP 36
3123: PUSH
3124: LD_EXP 37
3128: PUSH
3129: LD_EXP 38
3133: PUSH
3134: LD_EXP 39
3138: PUSH
3139: LD_EXP 40
3143: PUSH
3144: LD_EXP 41
3148: PUSH
3149: LD_EXP 42
3153: PUSH
3154: LD_EXP 43
3158: PUSH
3159: LD_EXP 44
3163: PUSH
3164: LD_EXP 45
3168: PUSH
3169: EMPTY
3170: LIST
3171: LIST
3172: LIST
3173: LIST
3174: LIST
3175: LIST
3176: LIST
3177: LIST
3178: LIST
3179: LIST
3180: LIST
3181: LIST
3182: ST_TO_ADDR
// uc_nation := 1 ;
3183: LD_ADDR_OWVAR 21
3187: PUSH
3188: LD_INT 1
3190: ST_TO_ADDR
// PrepareVehicle ( us_morphling , engine_siberite , control_manual , us_heavy_gun , 100 ) ;
3191: LD_INT 5
3193: PPUSH
3194: LD_INT 3
3196: PPUSH
3197: LD_INT 1
3199: PPUSH
3200: LD_INT 6
3202: PPUSH
3203: LD_INT 100
3205: PPUSH
3206: CALL 57522 0 5
// veh := CreateVehicle ;
3210: LD_ADDR_VAR 0 3
3214: PUSH
3215: CALL_OW 45
3219: ST_TO_ADDR
// SetMark ( veh , - 7 ) ;
3220: LD_VAR 0 3
3224: PPUSH
3225: LD_INT 7
3227: NEG
3228: PPUSH
3229: CALL_OW 242
// SetDir ( veh , 3 ) ;
3233: LD_VAR 0 3
3237: PPUSH
3238: LD_INT 3
3240: PPUSH
3241: CALL_OW 233
// PlaceUnitArea ( veh , allianceJMMSpawnArea , false ) ;
3245: LD_VAR 0 3
3249: PPUSH
3250: LD_INT 31
3252: PPUSH
3253: LD_INT 0
3255: PPUSH
3256: CALL_OW 49
// PlaceHumanInUnit ( JMM , veh ) ;
3260: LD_EXP 14
3264: PPUSH
3265: LD_VAR 0 3
3269: PPUSH
3270: CALL_OW 52
// if Joan then
3274: LD_EXP 29
3278: IFFALSE 3350
// begin PrepareVehicle ( us_medium_tracked , engine_siberite , control_manual , us_radar , 100 ) ;
3280: LD_INT 3
3282: PPUSH
3283: LD_INT 3
3285: PPUSH
3286: LD_INT 1
3288: PPUSH
3289: LD_INT 11
3291: PPUSH
3292: LD_INT 100
3294: PPUSH
3295: CALL 57522 0 5
// veh := CreateVehicle ;
3299: LD_ADDR_VAR 0 3
3303: PUSH
3304: CALL_OW 45
3308: ST_TO_ADDR
// SetDir ( veh , 3 ) ;
3309: LD_VAR 0 3
3313: PPUSH
3314: LD_INT 3
3316: PPUSH
3317: CALL_OW 233
// PlaceUnitArea ( veh , allianceSpawnArea , false ) ;
3321: LD_VAR 0 3
3325: PPUSH
3326: LD_INT 30
3328: PPUSH
3329: LD_INT 0
3331: PPUSH
3332: CALL_OW 49
// PlaceHumanInUnit ( Joan , veh ) ;
3336: LD_EXP 29
3340: PPUSH
3341: LD_VAR 0 3
3345: PPUSH
3346: CALL_OW 52
// end ; if Roth then
3350: LD_EXP 15
3354: IFFALSE 3426
// begin PrepareVehicle ( us_medium_tracked , engine_siberite , control_manual , us_radar , 100 ) ;
3356: LD_INT 3
3358: PPUSH
3359: LD_INT 3
3361: PPUSH
3362: LD_INT 1
3364: PPUSH
3365: LD_INT 11
3367: PPUSH
3368: LD_INT 100
3370: PPUSH
3371: CALL 57522 0 5
// veh := CreateVehicle ;
3375: LD_ADDR_VAR 0 3
3379: PUSH
3380: CALL_OW 45
3384: ST_TO_ADDR
// SetDir ( veh , 3 ) ;
3385: LD_VAR 0 3
3389: PPUSH
3390: LD_INT 3
3392: PPUSH
3393: CALL_OW 233
// PlaceUnitArea ( veh , allianceSpawnArea , false ) ;
3397: LD_VAR 0 3
3401: PPUSH
3402: LD_INT 30
3404: PPUSH
3405: LD_INT 0
3407: PPUSH
3408: CALL_OW 49
// PlaceHumanInUnit ( Roth , veh ) ;
3412: LD_EXP 15
3416: PPUSH
3417: LD_VAR 0 3
3421: PPUSH
3422: CALL_OW 52
// end ; if Denis then
3426: LD_EXP 20
3430: IFFALSE 3502
// begin PrepareVehicle ( us_morphling , engine_siberite , control_manual , us_laser , 100 ) ;
3432: LD_INT 5
3434: PPUSH
3435: LD_INT 3
3437: PPUSH
3438: LD_INT 1
3440: PPUSH
3441: LD_INT 9
3443: PPUSH
3444: LD_INT 100
3446: PPUSH
3447: CALL 57522 0 5
// veh := CreateVehicle ;
3451: LD_ADDR_VAR 0 3
3455: PUSH
3456: CALL_OW 45
3460: ST_TO_ADDR
// SetDir ( veh , 3 ) ;
3461: LD_VAR 0 3
3465: PPUSH
3466: LD_INT 3
3468: PPUSH
3469: CALL_OW 233
// PlaceUnitArea ( veh , allianceSpawnArea , false ) ;
3473: LD_VAR 0 3
3477: PPUSH
3478: LD_INT 30
3480: PPUSH
3481: LD_INT 0
3483: PPUSH
3484: CALL_OW 49
// PlaceHumanInUnit ( Denis , veh ) ;
3488: LD_EXP 20
3492: PPUSH
3493: LD_VAR 0 3
3497: PPUSH
3498: CALL_OW 52
// end ; uc_nation := 3 ;
3502: LD_ADDR_OWVAR 21
3506: PUSH
3507: LD_INT 3
3509: ST_TO_ADDR
// PrepareVehicle ( ru_medium_tracked , engine_siberite , control_manual , ru_rocket_launcher , 100 ) ;
3510: LD_INT 22
3512: PPUSH
3513: LD_INT 3
3515: PPUSH
3516: LD_INT 1
3518: PPUSH
3519: LD_INT 45
3521: PPUSH
3522: LD_INT 100
3524: PPUSH
3525: CALL 57522 0 5
// veh := CreateVehicle ;
3529: LD_ADDR_VAR 0 3
3533: PUSH
3534: CALL_OW 45
3538: ST_TO_ADDR
// SetMark ( veh , - 7 ) ;
3539: LD_VAR 0 3
3543: PPUSH
3544: LD_INT 7
3546: NEG
3547: PPUSH
3548: CALL_OW 242
// SetDir ( veh , 3 ) ;
3552: LD_VAR 0 3
3556: PPUSH
3557: LD_INT 3
3559: PPUSH
3560: CALL_OW 233
// PlaceUnitArea ( veh , allianceJMMSpawnArea , false ) ;
3564: LD_VAR 0 3
3568: PPUSH
3569: LD_INT 31
3571: PPUSH
3572: LD_INT 0
3574: PPUSH
3575: CALL_OW 49
// PlaceHumanInUnit ( Burlak , veh ) ;
3579: LD_EXP 46
3583: PPUSH
3584: LD_VAR 0 3
3588: PPUSH
3589: CALL_OW 52
// if Gossudarov then
3593: LD_EXP 32
3597: IFFALSE 3684
// begin PrepareVehicle ( ru_medium_tracked , engine_siberite , control_manual , ru_cargo_bay , 100 ) ;
3599: LD_INT 22
3601: PPUSH
3602: LD_INT 3
3604: PPUSH
3605: LD_INT 1
3607: PPUSH
3608: LD_INT 51
3610: PPUSH
3611: LD_INT 100
3613: PPUSH
3614: CALL 57522 0 5
// veh := CreateVehicle ;
3618: LD_ADDR_VAR 0 3
3622: PUSH
3623: CALL_OW 45
3627: ST_TO_ADDR
// SetDir ( veh , 3 ) ;
3628: LD_VAR 0 3
3632: PPUSH
3633: LD_INT 3
3635: PPUSH
3636: CALL_OW 233
// PlaceUnitArea ( veh , allianceSpawnArea , false ) ;
3640: LD_VAR 0 3
3644: PPUSH
3645: LD_INT 30
3647: PPUSH
3648: LD_INT 0
3650: PPUSH
3651: CALL_OW 49
// PlaceHumanInUnit ( Gossudarov , veh ) ;
3655: LD_EXP 32
3659: PPUSH
3660: LD_VAR 0 3
3664: PPUSH
3665: CALL_OW 52
// SetCargo ( veh , mat_cans , 100 ) ;
3669: LD_VAR 0 3
3673: PPUSH
3674: LD_INT 1
3676: PPUSH
3677: LD_INT 100
3679: PPUSH
3680: CALL_OW 290
// end ; for i in selected do
3684: LD_ADDR_VAR 0 2
3688: PUSH
3689: LD_VAR 0 4
3693: PUSH
3694: FOR_IN
3695: IFFALSE 4253
// begin uc_nation := GetNation ( i ) ;
3697: LD_ADDR_OWVAR 21
3701: PUSH
3702: LD_VAR 0 2
3706: PPUSH
3707: CALL_OW 248
3711: ST_TO_ADDR
// if i in [ Lisa , Donaldson , Cyrus , Bobby ] then
3712: LD_VAR 0 2
3716: PUSH
3717: LD_EXP 16
3721: PUSH
3722: LD_EXP 17
3726: PUSH
3727: LD_EXP 19
3731: PUSH
3732: LD_EXP 18
3736: PUSH
3737: EMPTY
3738: LIST
3739: LIST
3740: LIST
3741: LIST
3742: IN
3743: IFFALSE 3766
// PrepareVehicle ( us_morphling , engine_siberite , control_manual , us_heavy_gun , 100 ) else
3745: LD_INT 5
3747: PPUSH
3748: LD_INT 3
3750: PPUSH
3751: LD_INT 1
3753: PPUSH
3754: LD_INT 6
3756: PPUSH
3757: LD_INT 100
3759: PPUSH
3760: CALL 57522 0 5
3764: GO 4200
// if i in [ Oblukov , Kuzmov , Petrovova , Titov ] then
3766: LD_VAR 0 2
3770: PUSH
3771: LD_EXP 39
3775: PUSH
3776: LD_EXP 44
3780: PUSH
3781: LD_EXP 42
3785: PUSH
3786: LD_EXP 34
3790: PUSH
3791: EMPTY
3792: LIST
3793: LIST
3794: LIST
3795: LIST
3796: IN
3797: IFFALSE 3828
// PrepareVehicle ( ru_heavy_tracked , engine_combustion , control_manual , ru_heavy_gun , rand ( 65 , 75 ) ) else
3799: LD_INT 24
3801: PPUSH
3802: LD_INT 1
3804: PPUSH
3805: LD_INT 1
3807: PPUSH
3808: LD_INT 46
3810: PPUSH
3811: LD_INT 65
3813: PPUSH
3814: LD_INT 75
3816: PPUSH
3817: CALL_OW 12
3821: PPUSH
3822: CALL 57522 0 5
3826: GO 4200
// if i = Karamazov then
3828: LD_VAR 0 2
3832: PUSH
3833: LD_EXP 45
3837: EQUAL
3838: IFFALSE 3861
// PrepareVehicle ( ru_medium_tracked , engine_siberite , control_manual , ru_crane , 100 ) else
3840: LD_INT 22
3842: PPUSH
3843: LD_INT 3
3845: PPUSH
3846: LD_INT 1
3848: PPUSH
3849: LD_INT 52
3851: PPUSH
3852: LD_INT 100
3854: PPUSH
3855: CALL 57522 0 5
3859: GO 4200
// if i = Brown then
3861: LD_VAR 0 2
3865: PUSH
3866: LD_EXP 21
3870: EQUAL
3871: IFFALSE 3894
// PrepareVehicle ( us_medium_tracked , engine_siberite , control_manual , us_crane , 100 ) else
3873: LD_INT 3
3875: PPUSH
3876: LD_INT 3
3878: PPUSH
3879: LD_INT 1
3881: PPUSH
3882: LD_INT 13
3884: PPUSH
3885: LD_INT 100
3887: PPUSH
3888: CALL 57522 0 5
3892: GO 4200
// if uc_nation = nation_american then
3894: LD_OWVAR 21
3898: PUSH
3899: LD_INT 1
3901: EQUAL
3902: IFFALSE 4053
// begin PrepareVehicle ( [ us_medium_tracked , us_morphling , us_morphling ] [ uc_nation mod 3 + 1 ] , [ engine_combustion , engine_siberite , engine_combustion ] [ uc_nation mod 3 + 1 ] , control_manual , [ [ us_radar , us_gatling_gun , us_double_gun ] , [ us_heavy_gun , us_rocket_launcher , us_laser ] , [ us_heavy_gun , us_laser , us_cargo_bay ] ] [ uc_nation mod 3 + 1 ] [ rand ( 1 , 3 ) ] , rand ( 65 , 75 ) ) ;
3904: LD_INT 3
3906: PUSH
3907: LD_INT 5
3909: PUSH
3910: LD_INT 5
3912: PUSH
3913: EMPTY
3914: LIST
3915: LIST
3916: LIST
3917: PUSH
3918: LD_OWVAR 21
3922: PUSH
3923: LD_INT 3
3925: MOD
3926: PUSH
3927: LD_INT 1
3929: PLUS
3930: ARRAY
3931: PPUSH
3932: LD_INT 1
3934: PUSH
3935: LD_INT 3
3937: PUSH
3938: LD_INT 1
3940: PUSH
3941: EMPTY
3942: LIST
3943: LIST
3944: LIST
3945: PUSH
3946: LD_OWVAR 21
3950: PUSH
3951: LD_INT 3
3953: MOD
3954: PUSH
3955: LD_INT 1
3957: PLUS
3958: ARRAY
3959: PPUSH
3960: LD_INT 1
3962: PPUSH
3963: LD_INT 11
3965: PUSH
3966: LD_INT 4
3968: PUSH
3969: LD_INT 5
3971: PUSH
3972: EMPTY
3973: LIST
3974: LIST
3975: LIST
3976: PUSH
3977: LD_INT 6
3979: PUSH
3980: LD_INT 7
3982: PUSH
3983: LD_INT 9
3985: PUSH
3986: EMPTY
3987: LIST
3988: LIST
3989: LIST
3990: PUSH
3991: LD_INT 6
3993: PUSH
3994: LD_INT 9
3996: PUSH
3997: LD_INT 12
3999: PUSH
4000: EMPTY
4001: LIST
4002: LIST
4003: LIST
4004: PUSH
4005: EMPTY
4006: LIST
4007: LIST
4008: LIST
4009: PUSH
4010: LD_OWVAR 21
4014: PUSH
4015: LD_INT 3
4017: MOD
4018: PUSH
4019: LD_INT 1
4021: PLUS
4022: ARRAY
4023: PUSH
4024: LD_INT 1
4026: PPUSH
4027: LD_INT 3
4029: PPUSH
4030: CALL_OW 12
4034: ARRAY
4035: PPUSH
4036: LD_INT 65
4038: PPUSH
4039: LD_INT 75
4041: PPUSH
4042: CALL_OW 12
4046: PPUSH
4047: CALL 57522 0 5
// end else
4051: GO 4200
// begin PrepareVehicle ( [ ru_medium_tracked , ru_heavy_wheeled , ru_heavy_wheeled ] [ uc_nation mod 3 + 1 ] , [ engine_combustion , engine_siberite , engine_combustion ] [ uc_nation mod 3 + 1 ] , control_manual , [ [ ru_rocket_launcher , ru_gatling_gun , ru_gun ] , [ ru_heavy_gun , ru_rocket_launcher , ru_gun ] , [ ru_heavy_gun , ru_gatling_gun , ru_rocket_launcher ] ] [ uc_nation mod 3 + 1 ] [ rand ( 1 , 3 ) ] , rand ( 65 , 75 ) ) ;
4053: LD_INT 22
4055: PUSH
4056: LD_INT 23
4058: PUSH
4059: LD_INT 23
4061: PUSH
4062: EMPTY
4063: LIST
4064: LIST
4065: LIST
4066: PUSH
4067: LD_OWVAR 21
4071: PUSH
4072: LD_INT 3
4074: MOD
4075: PUSH
4076: LD_INT 1
4078: PLUS
4079: ARRAY
4080: PPUSH
4081: LD_INT 1
4083: PUSH
4084: LD_INT 3
4086: PUSH
4087: LD_INT 1
4089: PUSH
4090: EMPTY
4091: LIST
4092: LIST
4093: LIST
4094: PUSH
4095: LD_OWVAR 21
4099: PUSH
4100: LD_INT 3
4102: MOD
4103: PUSH
4104: LD_INT 1
4106: PLUS
4107: ARRAY
4108: PPUSH
4109: LD_INT 1
4111: PPUSH
4112: LD_INT 45
4114: PUSH
4115: LD_INT 43
4117: PUSH
4118: LD_INT 44
4120: PUSH
4121: EMPTY
4122: LIST
4123: LIST
4124: LIST
4125: PUSH
4126: LD_INT 46
4128: PUSH
4129: LD_INT 45
4131: PUSH
4132: LD_INT 44
4134: PUSH
4135: EMPTY
4136: LIST
4137: LIST
4138: LIST
4139: PUSH
4140: LD_INT 46
4142: PUSH
4143: LD_INT 43
4145: PUSH
4146: LD_INT 45
4148: PUSH
4149: EMPTY
4150: LIST
4151: LIST
4152: LIST
4153: PUSH
4154: EMPTY
4155: LIST
4156: LIST
4157: LIST
4158: PUSH
4159: LD_OWVAR 21
4163: PUSH
4164: LD_INT 3
4166: MOD
4167: PUSH
4168: LD_INT 1
4170: PLUS
4171: ARRAY
4172: PUSH
4173: LD_INT 1
4175: PPUSH
4176: LD_INT 3
4178: PPUSH
4179: CALL_OW 12
4183: ARRAY
4184: PPUSH
4185: LD_INT 65
4187: PPUSH
4188: LD_INT 75
4190: PPUSH
4191: CALL_OW 12
4195: PPUSH
4196: CALL 57522 0 5
// end ; veh := CreateVehicle ;
4200: LD_ADDR_VAR 0 3
4204: PUSH
4205: CALL_OW 45
4209: ST_TO_ADDR
// SetDir ( veh , 3 ) ;
4210: LD_VAR 0 3
4214: PPUSH
4215: LD_INT 3
4217: PPUSH
4218: CALL_OW 233
// PlaceUnitArea ( veh , allianceSpawnArea , false ) ;
4222: LD_VAR 0 3
4226: PPUSH
4227: LD_INT 30
4229: PPUSH
4230: LD_INT 0
4232: PPUSH
4233: CALL_OW 49
// PlaceHumanInUnit ( i , veh ) ;
4237: LD_VAR 0 2
4241: PPUSH
4242: LD_VAR 0 3
4246: PPUSH
4247: CALL_OW 52
// end ;
4251: GO 3694
4253: POP
4254: POP
// if artifactArCaptured then
4255: LD_EXP 6
4259: IFFALSE 4345
// begin uc_nation := nation_american ;
4261: LD_ADDR_OWVAR 21
4265: PUSH
4266: LD_INT 1
4268: ST_TO_ADDR
// PrepareVehicle ( us_medium_tracked , engine_siberite , control_computer , us_cargo_bay , 100 ) ;
4269: LD_INT 3
4271: PPUSH
4272: LD_INT 3
4274: PPUSH
4275: LD_INT 3
4277: PPUSH
4278: LD_INT 12
4280: PPUSH
4281: LD_INT 100
4283: PPUSH
4284: CALL 57522 0 5
// veh := CreateVehicle ;
4288: LD_ADDR_VAR 0 3
4292: PUSH
4293: CALL_OW 45
4297: ST_TO_ADDR
// SetDir ( veh , 3 ) ;
4298: LD_VAR 0 3
4302: PPUSH
4303: LD_INT 3
4305: PPUSH
4306: CALL_OW 233
// PlaceUnitXY ( veh , 198 , 22 , false ) ;
4310: LD_VAR 0 3
4314: PPUSH
4315: LD_INT 198
4317: PPUSH
4318: LD_INT 22
4320: PPUSH
4321: LD_INT 0
4323: PPUSH
4324: CALL_OW 48
// SetCargo ( veh , mat_artifact , 50 ) ;
4328: LD_VAR 0 3
4332: PPUSH
4333: LD_INT 4
4335: PPUSH
4336: LD_INT 50
4338: PPUSH
4339: CALL_OW 290
// end else
4343: GO 4364
// begin CreateResourcesXY ( mat_artifact , 267 , 226 , 5 , false ) ;
4345: LD_INT 4
4347: PPUSH
4348: LD_INT 267
4350: PPUSH
4351: LD_INT 226
4353: PPUSH
4354: LD_INT 5
4356: PPUSH
4357: LD_INT 0
4359: PPUSH
4360: CALL_OW 58
// end ; uc_nation := nation_american ;
4364: LD_ADDR_OWVAR 21
4368: PUSH
4369: LD_INT 1
4371: ST_TO_ADDR
// PrepareVehicle ( us_medium_tracked , engine_siberite , control_computer , us_cargo_bay , 100 ) ;
4372: LD_INT 3
4374: PPUSH
4375: LD_INT 3
4377: PPUSH
4378: LD_INT 3
4380: PPUSH
4381: LD_INT 12
4383: PPUSH
4384: LD_INT 100
4386: PPUSH
4387: CALL 57522 0 5
// veh := CreateVehicle ;
4391: LD_ADDR_VAR 0 3
4395: PUSH
4396: CALL_OW 45
4400: ST_TO_ADDR
// SetDir ( veh , 3 ) ;
4401: LD_VAR 0 3
4405: PPUSH
4406: LD_INT 3
4408: PPUSH
4409: CALL_OW 233
// PlaceUnitXY ( veh , 218 , 23 , false ) ;
4413: LD_VAR 0 3
4417: PPUSH
4418: LD_INT 218
4420: PPUSH
4421: LD_INT 23
4423: PPUSH
4424: LD_INT 0
4426: PPUSH
4427: CALL_OW 48
// SetCargo ( veh , mat_artifact , 30 ) ;
4431: LD_VAR 0 3
4435: PPUSH
4436: LD_INT 4
4438: PPUSH
4439: LD_INT 30
4441: PPUSH
4442: CALL_OW 290
// uc_nation := nation_russian ;
4446: LD_ADDR_OWVAR 21
4450: PUSH
4451: LD_INT 3
4453: ST_TO_ADDR
// PrepareVehicle ( ru_medium_tracked , engine_siberite , control_computer , ru_cargo_bay , 100 ) ;
4454: LD_INT 22
4456: PPUSH
4457: LD_INT 3
4459: PPUSH
4460: LD_INT 3
4462: PPUSH
4463: LD_INT 51
4465: PPUSH
4466: LD_INT 100
4468: PPUSH
4469: CALL 57522 0 5
// veh := CreateVehicle ;
4473: LD_ADDR_VAR 0 3
4477: PUSH
4478: CALL_OW 45
4482: ST_TO_ADDR
// SetDir ( veh , 3 ) ;
4483: LD_VAR 0 3
4487: PPUSH
4488: LD_INT 3
4490: PPUSH
4491: CALL_OW 233
// PlaceUnitXY ( veh , 214 , 20 , false ) ;
4495: LD_VAR 0 3
4499: PPUSH
4500: LD_INT 214
4502: PPUSH
4503: LD_INT 20
4505: PPUSH
4506: LD_INT 0
4508: PPUSH
4509: CALL_OW 48
// SetCargo ( veh , mat_artifact , 40 ) ;
4513: LD_VAR 0 3
4517: PPUSH
4518: LD_INT 4
4520: PPUSH
4521: LD_INT 40
4523: PPUSH
4524: CALL_OW 290
// end ; end_of_file
4528: LD_VAR 0 1
4532: RET
// export Powell ; export function PrepareAmerican ; var i , b , veh , cl , tmp , depot , lab , armoury , workshop ; begin
4533: LD_INT 0
4535: PPUSH
4536: PPUSH
4537: PPUSH
4538: PPUSH
4539: PPUSH
4540: PPUSH
4541: PPUSH
4542: PPUSH
4543: PPUSH
4544: PPUSH
// InitHc ;
4545: CALL_OW 19
// uc_side := 1 ;
4549: LD_ADDR_OWVAR 20
4553: PUSH
4554: LD_INT 1
4556: ST_TO_ADDR
// uc_nation := 1 ;
4557: LD_ADDR_OWVAR 21
4561: PUSH
4562: LD_INT 1
4564: ST_TO_ADDR
// for i in FilterAllUnits ( [ [ f_side , 1 ] , [ f_type , unit_building ] ] ) do
4565: LD_ADDR_VAR 0 2
4569: PUSH
4570: LD_INT 22
4572: PUSH
4573: LD_INT 1
4575: PUSH
4576: EMPTY
4577: LIST
4578: LIST
4579: PUSH
4580: LD_INT 21
4582: PUSH
4583: LD_INT 3
4585: PUSH
4586: EMPTY
4587: LIST
4588: LIST
4589: PUSH
4590: EMPTY
4591: LIST
4592: LIST
4593: PPUSH
4594: CALL_OW 69
4598: PUSH
4599: FOR_IN
4600: IFFALSE 4616
// SetBLevel ( i , 10 ) ;
4602: LD_VAR 0 2
4606: PPUSH
4607: LD_INT 10
4609: PPUSH
4610: CALL_OW 241
4614: GO 4599
4616: POP
4617: POP
// SetResourceType ( GetBase ( am_depot ) , mat_cans , 25500 ) ;
4618: LD_INT 387
4620: PPUSH
4621: CALL_OW 274
4625: PPUSH
4626: LD_INT 1
4628: PPUSH
4629: LD_INT 25500
4631: PPUSH
4632: CALL_OW 277
// SetResourceType ( GetBase ( am_depot ) , mat_oil , 4000 ) ;
4636: LD_INT 387
4638: PPUSH
4639: CALL_OW 274
4643: PPUSH
4644: LD_INT 2
4646: PPUSH
4647: LD_INT 4000
4649: PPUSH
4650: CALL_OW 277
// SetResourceType ( GetBase ( am_depot ) , mat_siberit , 50 ) ;
4654: LD_INT 387
4656: PPUSH
4657: CALL_OW 274
4661: PPUSH
4662: LD_INT 3
4664: PPUSH
4665: LD_INT 50
4667: PPUSH
4668: CALL_OW 277
// SetResourceType ( GetBase ( am_depot2 ) , mat_cans , 7500 ) ;
4672: LD_INT 476
4674: PPUSH
4675: CALL_OW 274
4679: PPUSH
4680: LD_INT 1
4682: PPUSH
4683: LD_INT 7500
4685: PPUSH
4686: CALL_OW 277
// SetResourceType ( GetBase ( am_depot2 ) , mat_oil , 4000 ) ;
4690: LD_INT 476
4692: PPUSH
4693: CALL_OW 274
4697: PPUSH
4698: LD_INT 2
4700: PPUSH
4701: LD_INT 4000
4703: PPUSH
4704: CALL_OW 277
// SetResourceType ( GetBase ( am_depot2 ) , mat_siberit , 10 ) ;
4708: LD_INT 476
4710: PPUSH
4711: CALL_OW 274
4715: PPUSH
4716: LD_INT 3
4718: PPUSH
4719: LD_INT 10
4721: PPUSH
4722: CALL_OW 277
// Powell := NewCharacter ( Powell ) ;
4726: LD_ADDR_EXP 49
4730: PUSH
4731: LD_STRING Powell
4733: PPUSH
4734: CALL_OW 25
4738: ST_TO_ADDR
// PlaceHumanInUnit ( Powell , am_depot ) ;
4739: LD_EXP 49
4743: PPUSH
4744: LD_INT 387
4746: PPUSH
4747: CALL_OW 52
// tmp := [ ] ;
4751: LD_ADDR_VAR 0 6
4755: PUSH
4756: EMPTY
4757: ST_TO_ADDR
// Lisa := PrepareUnit ( Lisa , ( not debug ) , 12p_ ) ;
4758: LD_ADDR_EXP 16
4762: PUSH
4763: LD_STRING Lisa
4765: PPUSH
4766: LD_EXP 1
4770: NOT
4771: PPUSH
4772: LD_STRING 12p_
4774: PPUSH
4775: CALL 50407 0 3
4779: ST_TO_ADDR
// if Lisa then
4780: LD_EXP 16
4784: IFFALSE 4802
// tmp := tmp ^ Lisa ;
4786: LD_ADDR_VAR 0 6
4790: PUSH
4791: LD_VAR 0 6
4795: PUSH
4796: LD_EXP 16
4800: ADD
4801: ST_TO_ADDR
// Donaldson := PrepareUnit ( Donaldson , ( not debug ) , 12p_ ) ;
4802: LD_ADDR_EXP 17
4806: PUSH
4807: LD_STRING Donaldson
4809: PPUSH
4810: LD_EXP 1
4814: NOT
4815: PPUSH
4816: LD_STRING 12p_
4818: PPUSH
4819: CALL 50407 0 3
4823: ST_TO_ADDR
// if Donaldson then
4824: LD_EXP 17
4828: IFFALSE 4846
// tmp := tmp ^ Donaldson ;
4830: LD_ADDR_VAR 0 6
4834: PUSH
4835: LD_VAR 0 6
4839: PUSH
4840: LD_EXP 17
4844: ADD
4845: ST_TO_ADDR
// Bobby := PrepareUnit ( Bobby , ( not debug ) , 12p_ ) ;
4846: LD_ADDR_EXP 18
4850: PUSH
4851: LD_STRING Bobby
4853: PPUSH
4854: LD_EXP 1
4858: NOT
4859: PPUSH
4860: LD_STRING 12p_
4862: PPUSH
4863: CALL 50407 0 3
4867: ST_TO_ADDR
// if Bobby then
4868: LD_EXP 18
4872: IFFALSE 4890
// tmp := tmp ^ Bobby ;
4874: LD_ADDR_VAR 0 6
4878: PUSH
4879: LD_VAR 0 6
4883: PUSH
4884: LD_EXP 18
4888: ADD
4889: ST_TO_ADDR
// Cyrus := PrepareUnit ( Cyrus , ( not debug ) , 12p_ ) ;
4890: LD_ADDR_EXP 19
4894: PUSH
4895: LD_STRING Cyrus
4897: PPUSH
4898: LD_EXP 1
4902: NOT
4903: PPUSH
4904: LD_STRING 12p_
4906: PPUSH
4907: CALL 50407 0 3
4911: ST_TO_ADDR
// if Cyrus then
4912: LD_EXP 19
4916: IFFALSE 4934
// tmp := tmp ^ Cyrus ;
4918: LD_ADDR_VAR 0 6
4922: PUSH
4923: LD_VAR 0 6
4927: PUSH
4928: LD_EXP 19
4932: ADD
4933: ST_TO_ADDR
// Brown := PrepareUnit ( Brown , ( not debug ) , 12p_ ) ;
4934: LD_ADDR_EXP 21
4938: PUSH
4939: LD_STRING Brown
4941: PPUSH
4942: LD_EXP 1
4946: NOT
4947: PPUSH
4948: LD_STRING 12p_
4950: PPUSH
4951: CALL 50407 0 3
4955: ST_TO_ADDR
// if Brown then
4956: LD_EXP 21
4960: IFFALSE 4978
// tmp := tmp ^ Brown ;
4962: LD_ADDR_VAR 0 6
4966: PUSH
4967: LD_VAR 0 6
4971: PUSH
4972: LD_EXP 21
4976: ADD
4977: ST_TO_ADDR
// Gladstone := PrepareUnit ( Gladstone , ( not debug ) , 12p_ ) ;
4978: LD_ADDR_EXP 22
4982: PUSH
4983: LD_STRING Gladstone
4985: PPUSH
4986: LD_EXP 1
4990: NOT
4991: PPUSH
4992: LD_STRING 12p_
4994: PPUSH
4995: CALL 50407 0 3
4999: ST_TO_ADDR
// if Gladstone then
5000: LD_EXP 22
5004: IFFALSE 5022
// tmp := tmp ^ Gladstone ;
5006: LD_ADDR_VAR 0 6
5010: PUSH
5011: LD_VAR 0 6
5015: PUSH
5016: LD_EXP 22
5020: ADD
5021: ST_TO_ADDR
// Houten := PrepareUnit ( Houten , ( not debug ) , 12p_ ) ;
5022: LD_ADDR_EXP 23
5026: PUSH
5027: LD_STRING Houten
5029: PPUSH
5030: LD_EXP 1
5034: NOT
5035: PPUSH
5036: LD_STRING 12p_
5038: PPUSH
5039: CALL 50407 0 3
5043: ST_TO_ADDR
// if Houten then
5044: LD_EXP 23
5048: IFFALSE 5066
// tmp := tmp ^ Houten ;
5050: LD_ADDR_VAR 0 6
5054: PUSH
5055: LD_VAR 0 6
5059: PUSH
5060: LD_EXP 23
5064: ADD
5065: ST_TO_ADDR
// Cornel := PrepareUnit ( Cornel , ( not debug ) , 12p_ ) ;
5066: LD_ADDR_EXP 24
5070: PUSH
5071: LD_STRING Cornel
5073: PPUSH
5074: LD_EXP 1
5078: NOT
5079: PPUSH
5080: LD_STRING 12p_
5082: PPUSH
5083: CALL 50407 0 3
5087: ST_TO_ADDR
// if Cornel then
5088: LD_EXP 24
5092: IFFALSE 5110
// tmp := tmp ^ Cornel ;
5094: LD_ADDR_VAR 0 6
5098: PUSH
5099: LD_VAR 0 6
5103: PUSH
5104: LD_EXP 24
5108: ADD
5109: ST_TO_ADDR
// Gary := PrepareUnit ( Gary , ( not debug ) , 12p_ ) ;
5110: LD_ADDR_EXP 25
5114: PUSH
5115: LD_STRING Gary
5117: PPUSH
5118: LD_EXP 1
5122: NOT
5123: PPUSH
5124: LD_STRING 12p_
5126: PPUSH
5127: CALL 50407 0 3
5131: ST_TO_ADDR
// if Gary then
5132: LD_EXP 25
5136: IFFALSE 5154
// tmp := tmp ^ Gary ;
5138: LD_ADDR_VAR 0 6
5142: PUSH
5143: LD_VAR 0 6
5147: PUSH
5148: LD_EXP 25
5152: ADD
5153: ST_TO_ADDR
// Kikuchi := PrepareUnit ( Kikuchi , ( not debug ) , 12p_ ) ;
5154: LD_ADDR_EXP 27
5158: PUSH
5159: LD_STRING Kikuchi
5161: PPUSH
5162: LD_EXP 1
5166: NOT
5167: PPUSH
5168: LD_STRING 12p_
5170: PPUSH
5171: CALL 50407 0 3
5175: ST_TO_ADDR
// if Kikuchi then
5176: LD_EXP 27
5180: IFFALSE 5198
// tmp := tmp ^ Kikuchi ;
5182: LD_ADDR_VAR 0 6
5186: PUSH
5187: LD_VAR 0 6
5191: PUSH
5192: LD_EXP 27
5196: ADD
5197: ST_TO_ADDR
// tmp := tmp union CreateCharacterSet ( 12p_others ) ;
5198: LD_ADDR_VAR 0 6
5202: PUSH
5203: LD_VAR 0 6
5207: PUSH
5208: LD_STRING 12p_others
5210: PPUSH
5211: CALL_OW 31
5215: UNION
5216: ST_TO_ADDR
// if tmp < 36 then
5217: LD_VAR 0 6
5221: PUSH
5222: LD_INT 36
5224: LESS
5225: IFFALSE 5292
// for i = 1 to 36 - tmp do
5227: LD_ADDR_VAR 0 2
5231: PUSH
5232: DOUBLE
5233: LD_INT 1
5235: DEC
5236: ST_TO_ADDR
5237: LD_INT 36
5239: PUSH
5240: LD_VAR 0 6
5244: MINUS
5245: PUSH
5246: FOR_TO
5247: IFFALSE 5290
// begin PrepareHuman ( sex_male , i mod 4 + 1 , 10 ) ;
5249: LD_INT 1
5251: PPUSH
5252: LD_VAR 0 2
5256: PUSH
5257: LD_INT 4
5259: MOD
5260: PUSH
5261: LD_INT 1
5263: PLUS
5264: PPUSH
5265: LD_INT 10
5267: PPUSH
5268: CALL_OW 380
// tmp := tmp ^ CreateHuman ;
5272: LD_ADDR_VAR 0 6
5276: PUSH
5277: LD_VAR 0 6
5281: PUSH
5282: CALL_OW 44
5286: ADD
5287: ST_TO_ADDR
// end ;
5288: GO 5246
5290: POP
5291: POP
// for i in tmp do
5292: LD_ADDR_VAR 0 2
5296: PUSH
5297: LD_VAR 0 6
5301: PUSH
5302: FOR_IN
5303: IFFALSE 5328
// PlaceUnitXYR ( i , 62 , 93 , 9 , false ) ;
5305: LD_VAR 0 2
5309: PPUSH
5310: LD_INT 62
5312: PPUSH
5313: LD_INT 93
5315: PPUSH
5316: LD_INT 9
5318: PPUSH
5319: LD_INT 0
5321: PPUSH
5322: CALL_OW 50
5326: GO 5302
5328: POP
5329: POP
// mc_bases := Replace ( mc_bases , 4 , FilterAllUnits ( [ f_side , 1 ] ) diff Powell ) ;
5330: LD_ADDR_EXP 76
5334: PUSH
5335: LD_EXP 76
5339: PPUSH
5340: LD_INT 4
5342: PPUSH
5343: LD_INT 22
5345: PUSH
5346: LD_INT 1
5348: PUSH
5349: EMPTY
5350: LIST
5351: LIST
5352: PPUSH
5353: CALL_OW 69
5357: PUSH
5358: LD_EXP 49
5362: DIFF
5363: PPUSH
5364: CALL_OW 1
5368: ST_TO_ADDR
// uc_side := 0 ;
5369: LD_ADDR_OWVAR 20
5373: PUSH
5374: LD_INT 0
5376: ST_TO_ADDR
// uc_nation := 0 ;
5377: LD_ADDR_OWVAR 21
5381: PUSH
5382: LD_INT 0
5384: ST_TO_ADDR
// for i = 1 to 4 do
5385: LD_ADDR_VAR 0 2
5389: PUSH
5390: DOUBLE
5391: LD_INT 1
5393: DEC
5394: ST_TO_ADDR
5395: LD_INT 4
5397: PUSH
5398: FOR_TO
5399: IFFALSE 5430
// begin InitHc ;
5401: CALL_OW 19
// hc_class := class_apeman ;
5405: LD_ADDR_OWVAR 28
5409: PUSH
5410: LD_INT 12
5412: ST_TO_ADDR
// PlaceUnitArea ( CreateHuman , powellApe , false ) ;
5413: CALL_OW 44
5417: PPUSH
5418: LD_INT 11
5420: PPUSH
5421: LD_INT 0
5423: PPUSH
5424: CALL_OW 49
// end ;
5428: GO 5398
5430: POP
5431: POP
// end ;
5432: LD_VAR 0 1
5436: RET
// every 11 11$30 trigger not americanDestroyed and not MC_GetVehicles ( 4 , true ) do var i , tmp , target ;
5437: LD_EXP 4
5441: NOT
5442: PUSH
5443: LD_INT 4
5445: PPUSH
5446: LD_INT 1
5448: PPUSH
5449: CALL 45481 0 2
5453: NOT
5454: AND
5455: IFFALSE 6227
5457: GO 5459
5459: DISABLE
5460: LD_INT 0
5462: PPUSH
5463: PPUSH
5464: PPUSH
// begin enable ;
5465: ENABLE
// if not FilterAllUnits ( [ [ f_side , 1 ] , [ f_nation , 1 ] , [ f_btype , b_factory ] ] ) then
5466: LD_INT 22
5468: PUSH
5469: LD_INT 1
5471: PUSH
5472: EMPTY
5473: LIST
5474: LIST
5475: PUSH
5476: LD_INT 23
5478: PUSH
5479: LD_INT 1
5481: PUSH
5482: EMPTY
5483: LIST
5484: LIST
5485: PUSH
5486: LD_INT 30
5488: PUSH
5489: LD_INT 3
5491: PUSH
5492: EMPTY
5493: LIST
5494: LIST
5495: PUSH
5496: EMPTY
5497: LIST
5498: LIST
5499: LIST
5500: PPUSH
5501: CALL_OW 69
5505: NOT
5506: IFFALSE 5510
// exit ;
5508: GO 6227
// if Prob ( 40 ) then
5510: LD_INT 40
5512: PPUSH
5513: CALL_OW 13
5517: IFFALSE 5644
// begin MC_InsertProduceList ( 4 , [ [ us_morphling , engine_combustion , control_remote , us_rocket_launcher ] , [ us_morphling , engine_combustion , control_remote , us_rocket_launcher ] , [ us_morphling , engine_combustion , control_remote , us_rocket_launcher ] , [ us_morphling , engine_combustion , control_remote , us_heavy_gun ] , [ us_morphling , engine_combustion , control_remote , us_heavy_gun ] , [ us_morphling , engine_combustion , control_remote , us_heavy_gun ] , ] ) ;
5519: LD_INT 4
5521: PPUSH
5522: LD_INT 5
5524: PUSH
5525: LD_INT 1
5527: PUSH
5528: LD_INT 2
5530: PUSH
5531: LD_INT 7
5533: PUSH
5534: EMPTY
5535: LIST
5536: LIST
5537: LIST
5538: LIST
5539: PUSH
5540: LD_INT 5
5542: PUSH
5543: LD_INT 1
5545: PUSH
5546: LD_INT 2
5548: PUSH
5549: LD_INT 7
5551: PUSH
5552: EMPTY
5553: LIST
5554: LIST
5555: LIST
5556: LIST
5557: PUSH
5558: LD_INT 5
5560: PUSH
5561: LD_INT 1
5563: PUSH
5564: LD_INT 2
5566: PUSH
5567: LD_INT 7
5569: PUSH
5570: EMPTY
5571: LIST
5572: LIST
5573: LIST
5574: LIST
5575: PUSH
5576: LD_INT 5
5578: PUSH
5579: LD_INT 1
5581: PUSH
5582: LD_INT 2
5584: PUSH
5585: LD_INT 6
5587: PUSH
5588: EMPTY
5589: LIST
5590: LIST
5591: LIST
5592: LIST
5593: PUSH
5594: LD_INT 5
5596: PUSH
5597: LD_INT 1
5599: PUSH
5600: LD_INT 2
5602: PUSH
5603: LD_INT 6
5605: PUSH
5606: EMPTY
5607: LIST
5608: LIST
5609: LIST
5610: LIST
5611: PUSH
5612: LD_INT 5
5614: PUSH
5615: LD_INT 1
5617: PUSH
5618: LD_INT 2
5620: PUSH
5621: LD_INT 6
5623: PUSH
5624: EMPTY
5625: LIST
5626: LIST
5627: LIST
5628: LIST
5629: PUSH
5630: EMPTY
5631: LIST
5632: LIST
5633: LIST
5634: LIST
5635: LIST
5636: LIST
5637: PPUSH
5638: CALL 44063 0 2
// end else
5642: GO 5767
// begin MC_InsertProduceList ( 4 , [ [ us_morphling , engine_combustion , control_remote , us_rocket_launcher ] , [ us_morphling , engine_combustion , control_remote , us_laser ] , [ us_morphling , engine_combustion , control_remote , us_laser ] , [ us_morphling , engine_combustion , control_remote , us_heavy_gun ] , [ us_morphling , engine_combustion , control_remote , us_heavy_gun ] , [ us_morphling , engine_combustion , control_remote , us_heavy_gun ] , ] ) ;
5644: LD_INT 4
5646: PPUSH
5647: LD_INT 5
5649: PUSH
5650: LD_INT 1
5652: PUSH
5653: LD_INT 2
5655: PUSH
5656: LD_INT 7
5658: PUSH
5659: EMPTY
5660: LIST
5661: LIST
5662: LIST
5663: LIST
5664: PUSH
5665: LD_INT 5
5667: PUSH
5668: LD_INT 1
5670: PUSH
5671: LD_INT 2
5673: PUSH
5674: LD_INT 9
5676: PUSH
5677: EMPTY
5678: LIST
5679: LIST
5680: LIST
5681: LIST
5682: PUSH
5683: LD_INT 5
5685: PUSH
5686: LD_INT 1
5688: PUSH
5689: LD_INT 2
5691: PUSH
5692: LD_INT 9
5694: PUSH
5695: EMPTY
5696: LIST
5697: LIST
5698: LIST
5699: LIST
5700: PUSH
5701: LD_INT 5
5703: PUSH
5704: LD_INT 1
5706: PUSH
5707: LD_INT 2
5709: PUSH
5710: LD_INT 6
5712: PUSH
5713: EMPTY
5714: LIST
5715: LIST
5716: LIST
5717: LIST
5718: PUSH
5719: LD_INT 5
5721: PUSH
5722: LD_INT 1
5724: PUSH
5725: LD_INT 2
5727: PUSH
5728: LD_INT 6
5730: PUSH
5731: EMPTY
5732: LIST
5733: LIST
5734: LIST
5735: LIST
5736: PUSH
5737: LD_INT 5
5739: PUSH
5740: LD_INT 1
5742: PUSH
5743: LD_INT 2
5745: PUSH
5746: LD_INT 6
5748: PUSH
5749: EMPTY
5750: LIST
5751: LIST
5752: LIST
5753: LIST
5754: PUSH
5755: EMPTY
5756: LIST
5757: LIST
5758: LIST
5759: LIST
5760: LIST
5761: LIST
5762: PPUSH
5763: CALL 44063 0 2
// end ; repeat wait ( 0 0$1 ) ;
5767: LD_INT 35
5769: PPUSH
5770: CALL_OW 67
// until MC_GetVehicles ( 4 , true ) >= 6 ;
5774: LD_INT 4
5776: PPUSH
5777: LD_INT 1
5779: PPUSH
5780: CALL 45481 0 2
5784: PUSH
5785: LD_INT 6
5787: GREATEREQUAL
5788: IFFALSE 5767
// wait ( 0 0$30 ) ;
5790: LD_INT 1050
5792: PPUSH
5793: CALL_OW 67
// tmp := MC_GetVehicles ( 4 , true ) ;
5797: LD_ADDR_VAR 0 2
5801: PUSH
5802: LD_INT 4
5804: PPUSH
5805: LD_INT 1
5807: PPUSH
5808: CALL 45481 0 2
5812: ST_TO_ADDR
// mc_vehicles := Replace ( mc_vehicles , 4 , mc_vehicles [ 4 ] diff tmp ) ;
5813: LD_ADDR_EXP 95
5817: PUSH
5818: LD_EXP 95
5822: PPUSH
5823: LD_INT 4
5825: PPUSH
5826: LD_EXP 95
5830: PUSH
5831: LD_INT 4
5833: ARRAY
5834: PUSH
5835: LD_VAR 0 2
5839: DIFF
5840: PPUSH
5841: CALL_OW 1
5845: ST_TO_ADDR
// target := rand ( 0 , 2 ) ;
5846: LD_ADDR_VAR 0 3
5850: PUSH
5851: LD_INT 0
5853: PPUSH
5854: LD_INT 2
5856: PPUSH
5857: CALL_OW 12
5861: ST_TO_ADDR
// if target then
5862: LD_VAR 0 3
5866: IFFALSE 5994
// begin repeat tmp := UnitFilter ( tmp , [ f_lives , 250 ] ) ;
5868: LD_ADDR_VAR 0 2
5872: PUSH
5873: LD_VAR 0 2
5877: PPUSH
5878: LD_INT 24
5880: PUSH
5881: LD_INT 250
5883: PUSH
5884: EMPTY
5885: LIST
5886: LIST
5887: PPUSH
5888: CALL_OW 72
5892: ST_TO_ADDR
// for i in tmp do
5893: LD_ADDR_VAR 0 1
5897: PUSH
5898: LD_VAR 0 2
5902: PUSH
5903: FOR_IN
5904: IFFALSE 5944
// if GetDistUnitXY ( i , 114 , 108 ) > 9 then
5906: LD_VAR 0 1
5910: PPUSH
5911: LD_INT 114
5913: PPUSH
5914: LD_INT 108
5916: PPUSH
5917: CALL_OW 297
5921: PUSH
5922: LD_INT 9
5924: GREATER
5925: IFFALSE 5942
// ComMoveXY ( i , 114 , 108 ) ;
5927: LD_VAR 0 1
5931: PPUSH
5932: LD_INT 114
5934: PPUSH
5935: LD_INT 108
5937: PPUSH
5938: CALL_OW 111
5942: GO 5903
5944: POP
5945: POP
// wait ( 0 0$1 ) ;
5946: LD_INT 35
5948: PPUSH
5949: CALL_OW 67
// until UnitFilter ( tmp , [ f_distxy , 114 , 108 , 9 ] ) >= ( tmp - 1 ) ;
5953: LD_VAR 0 2
5957: PPUSH
5958: LD_INT 92
5960: PUSH
5961: LD_INT 114
5963: PUSH
5964: LD_INT 108
5966: PUSH
5967: LD_INT 9
5969: PUSH
5970: EMPTY
5971: LIST
5972: LIST
5973: LIST
5974: LIST
5975: PPUSH
5976: CALL_OW 72
5980: PUSH
5981: LD_VAR 0 2
5985: PUSH
5986: LD_INT 1
5988: MINUS
5989: GREATEREQUAL
5990: IFFALSE 5868
// end else
5992: GO 6118
// begin repeat tmp := UnitFilter ( tmp , [ f_lives , 250 ] ) ;
5994: LD_ADDR_VAR 0 2
5998: PUSH
5999: LD_VAR 0 2
6003: PPUSH
6004: LD_INT 24
6006: PUSH
6007: LD_INT 250
6009: PUSH
6010: EMPTY
6011: LIST
6012: LIST
6013: PPUSH
6014: CALL_OW 72
6018: ST_TO_ADDR
// for i in tmp do
6019: LD_ADDR_VAR 0 1
6023: PUSH
6024: LD_VAR 0 2
6028: PUSH
6029: FOR_IN
6030: IFFALSE 6070
// if GetDistUnitXY ( i , 129 , 139 ) > 9 then
6032: LD_VAR 0 1
6036: PPUSH
6037: LD_INT 129
6039: PPUSH
6040: LD_INT 139
6042: PPUSH
6043: CALL_OW 297
6047: PUSH
6048: LD_INT 9
6050: GREATER
6051: IFFALSE 6068
// ComMoveXY ( i , 129 , 139 ) ;
6053: LD_VAR 0 1
6057: PPUSH
6058: LD_INT 129
6060: PPUSH
6061: LD_INT 139
6063: PPUSH
6064: CALL_OW 111
6068: GO 6029
6070: POP
6071: POP
// wait ( 0 0$1 ) ;
6072: LD_INT 35
6074: PPUSH
6075: CALL_OW 67
// until UnitFilter ( tmp , [ f_distxy , 129 , 139 , 9 ] ) >= ( tmp - 1 ) ;
6079: LD_VAR 0 2
6083: PPUSH
6084: LD_INT 92
6086: PUSH
6087: LD_INT 129
6089: PUSH
6090: LD_INT 139
6092: PUSH
6093: LD_INT 9
6095: PUSH
6096: EMPTY
6097: LIST
6098: LIST
6099: LIST
6100: LIST
6101: PPUSH
6102: CALL_OW 72
6106: PUSH
6107: LD_VAR 0 2
6111: PUSH
6112: LD_INT 1
6114: MINUS
6115: GREATEREQUAL
6116: IFFALSE 5994
// end ; repeat wait ( 0 0$1 ) ;
6118: LD_INT 35
6120: PPUSH
6121: CALL_OW 67
// for i in tmp do
6125: LD_ADDR_VAR 0 1
6129: PUSH
6130: LD_VAR 0 2
6134: PUSH
6135: FOR_IN
6136: IFFALSE 6218
// begin if GetLives ( i ) > 251 then
6138: LD_VAR 0 1
6142: PPUSH
6143: CALL_OW 256
6147: PUSH
6148: LD_INT 251
6150: GREATER
6151: IFFALSE 6189
// ComAttackUnit ( i , NearestUnitToUnit ( FilterAllUnits ( [ f_enemy , 1 ] ) , i ) ) else
6153: LD_VAR 0 1
6157: PPUSH
6158: LD_INT 81
6160: PUSH
6161: LD_INT 1
6163: PUSH
6164: EMPTY
6165: LIST
6166: LIST
6167: PPUSH
6168: CALL_OW 69
6172: PPUSH
6173: LD_VAR 0 1
6177: PPUSH
6178: CALL_OW 74
6182: PPUSH
6183: CALL_OW 115
6187: GO 6216
// if IsDead ( i ) then
6189: LD_VAR 0 1
6193: PPUSH
6194: CALL_OW 301
6198: IFFALSE 6216
// tmp := tmp diff i ;
6200: LD_ADDR_VAR 0 2
6204: PUSH
6205: LD_VAR 0 2
6209: PUSH
6210: LD_VAR 0 1
6214: DIFF
6215: ST_TO_ADDR
// end ;
6216: GO 6135
6218: POP
6219: POP
// until not tmp ;
6220: LD_VAR 0 2
6224: NOT
6225: IFFALSE 6118
// end ;
6227: PPOPN 3
6229: END
// every 30 30$00 trigger not americanDestroyed do
6230: LD_EXP 4
6234: NOT
6235: IFFALSE 6300
6237: GO 6239
6239: DISABLE
// begin wait ( [ 30 30$00 , 20 20$00 , 10 10$00 ] [ Difficulty ] ) ;
6240: LD_INT 63000
6242: PUSH
6243: LD_INT 42000
6245: PUSH
6246: LD_INT 21000
6248: PUSH
6249: EMPTY
6250: LIST
6251: LIST
6252: LIST
6253: PUSH
6254: LD_OWVAR 67
6258: ARRAY
6259: PPUSH
6260: CALL_OW 67
// if americanDestroyed then
6264: LD_EXP 4
6268: IFFALSE 6272
// exit ;
6270: GO 6300
// MC_InsertProduceList ( 4 , [ [ us_morphling , engine_siberite , control_manual , us_siberium_rocket ] ] ) ;
6272: LD_INT 4
6274: PPUSH
6275: LD_INT 5
6277: PUSH
6278: LD_INT 3
6280: PUSH
6281: LD_INT 1
6283: PUSH
6284: LD_INT 8
6286: PUSH
6287: EMPTY
6288: LIST
6289: LIST
6290: LIST
6291: LIST
6292: PUSH
6293: EMPTY
6294: LIST
6295: PPUSH
6296: CALL 44063 0 2
// end ; end_of_file
6300: END
// export function PrepareArabian ; var i , un , tmp , side ; begin
6301: LD_INT 0
6303: PPUSH
6304: PPUSH
6305: PPUSH
6306: PPUSH
6307: PPUSH
// side := 2 ;
6308: LD_ADDR_VAR 0 5
6312: PUSH
6313: LD_INT 2
6315: ST_TO_ADDR
// InitHc ;
6316: CALL_OW 19
// uc_side := side ;
6320: LD_ADDR_OWVAR 20
6324: PUSH
6325: LD_VAR 0 5
6329: ST_TO_ADDR
// uc_nation := 2 ;
6330: LD_ADDR_OWVAR 21
6334: PUSH
6335: LD_INT 2
6337: ST_TO_ADDR
// for i in FilterAllUnits ( [ [ f_side , 2 ] , [ f_type , unit_building ] ] ) do
6338: LD_ADDR_VAR 0 2
6342: PUSH
6343: LD_INT 22
6345: PUSH
6346: LD_INT 2
6348: PUSH
6349: EMPTY
6350: LIST
6351: LIST
6352: PUSH
6353: LD_INT 21
6355: PUSH
6356: LD_INT 3
6358: PUSH
6359: EMPTY
6360: LIST
6361: LIST
6362: PUSH
6363: EMPTY
6364: LIST
6365: LIST
6366: PPUSH
6367: CALL_OW 69
6371: PUSH
6372: FOR_IN
6373: IFFALSE 6389
// SetBLevel ( i , 10 ) ;
6375: LD_VAR 0 2
6379: PPUSH
6380: LD_INT 10
6382: PPUSH
6383: CALL_OW 241
6387: GO 6372
6389: POP
6390: POP
// tmp := FilterAllUnits ( [ [ f_side , side ] , [ f_btype , b_bunker ] , [ f_empty ] ] ) ;
6391: LD_ADDR_VAR 0 4
6395: PUSH
6396: LD_INT 22
6398: PUSH
6399: LD_VAR 0 5
6403: PUSH
6404: EMPTY
6405: LIST
6406: LIST
6407: PUSH
6408: LD_INT 30
6410: PUSH
6411: LD_INT 32
6413: PUSH
6414: EMPTY
6415: LIST
6416: LIST
6417: PUSH
6418: LD_INT 58
6420: PUSH
6421: EMPTY
6422: LIST
6423: PUSH
6424: EMPTY
6425: LIST
6426: LIST
6427: LIST
6428: PPUSH
6429: CALL_OW 69
6433: ST_TO_ADDR
// for i = 1 to 10 do
6434: LD_ADDR_VAR 0 2
6438: PUSH
6439: DOUBLE
6440: LD_INT 1
6442: DEC
6443: ST_TO_ADDR
6444: LD_INT 10
6446: PUSH
6447: FOR_TO
6448: IFFALSE 6520
// begin uc_nation := nation_nature ;
6450: LD_ADDR_OWVAR 21
6454: PUSH
6455: LD_INT 0
6457: ST_TO_ADDR
// hc_class := class_apeman_soldier ;
6458: LD_ADDR_OWVAR 28
6462: PUSH
6463: LD_INT 15
6465: ST_TO_ADDR
// hc_gallery :=  ;
6466: LD_ADDR_OWVAR 33
6470: PUSH
6471: LD_STRING 
6473: ST_TO_ADDR
// hc_name :=  ;
6474: LD_ADDR_OWVAR 26
6478: PUSH
6479: LD_STRING 
6481: ST_TO_ADDR
// un := CreateHuman ;
6482: LD_ADDR_VAR 0 3
6486: PUSH
6487: CALL_OW 44
6491: ST_TO_ADDR
// PlaceHumanInUnit ( un , tmp [ tmp - i ] ) ;
6492: LD_VAR 0 3
6496: PPUSH
6497: LD_VAR 0 4
6501: PUSH
6502: LD_VAR 0 4
6506: PUSH
6507: LD_VAR 0 2
6511: MINUS
6512: ARRAY
6513: PPUSH
6514: CALL_OW 52
// end ;
6518: GO 6447
6520: POP
6521: POP
// PrepareBase ( ar_depot , arabianBaseArea ,  , [ 8 , 9 , 10 ] [ Difficulty ] , [ 3000 , 500 , 150 ] , [ 16 , 6 , 6 , 6 ] ) ;
6522: LD_INT 503
6524: PPUSH
6525: LD_INT 27
6527: PPUSH
6528: LD_STRING 
6530: PPUSH
6531: LD_INT 8
6533: PUSH
6534: LD_INT 9
6536: PUSH
6537: LD_INT 10
6539: PUSH
6540: EMPTY
6541: LIST
6542: LIST
6543: LIST
6544: PUSH
6545: LD_OWVAR 67
6549: ARRAY
6550: PPUSH
6551: LD_INT 3000
6553: PUSH
6554: LD_INT 500
6556: PUSH
6557: LD_INT 150
6559: PUSH
6560: EMPTY
6561: LIST
6562: LIST
6563: LIST
6564: PPUSH
6565: LD_INT 16
6567: PUSH
6568: LD_INT 6
6570: PUSH
6571: LD_INT 6
6573: PUSH
6574: LD_INT 6
6576: PUSH
6577: EMPTY
6578: LIST
6579: LIST
6580: LIST
6581: LIST
6582: PPUSH
6583: CALL 60931 0 6
// mc_bases := Replace ( mc_bases , 1 , FilterAllUnits ( [ [ f_side , side ] , [ f_nation , 2 ] , [ f_not , [ f_type , unit_vehicle ] ] ] ) ) ;
6587: LD_ADDR_EXP 76
6591: PUSH
6592: LD_EXP 76
6596: PPUSH
6597: LD_INT 1
6599: PPUSH
6600: LD_INT 22
6602: PUSH
6603: LD_VAR 0 5
6607: PUSH
6608: EMPTY
6609: LIST
6610: LIST
6611: PUSH
6612: LD_INT 23
6614: PUSH
6615: LD_INT 2
6617: PUSH
6618: EMPTY
6619: LIST
6620: LIST
6621: PUSH
6622: LD_INT 3
6624: PUSH
6625: LD_INT 21
6627: PUSH
6628: LD_INT 2
6630: PUSH
6631: EMPTY
6632: LIST
6633: LIST
6634: PUSH
6635: EMPTY
6636: LIST
6637: LIST
6638: PUSH
6639: EMPTY
6640: LIST
6641: LIST
6642: LIST
6643: PPUSH
6644: CALL_OW 69
6648: PPUSH
6649: CALL_OW 1
6653: ST_TO_ADDR
// end ;
6654: LD_VAR 0 1
6658: RET
// export Omar ; export function PrepareOmarAli ; begin
6659: LD_INT 0
6661: PPUSH
// uc_side := 5 ;
6662: LD_ADDR_OWVAR 20
6666: PUSH
6667: LD_INT 5
6669: ST_TO_ADDR
// uc_nation := 2 ;
6670: LD_ADDR_OWVAR 21
6674: PUSH
6675: LD_INT 2
6677: ST_TO_ADDR
// Omar := NewCharacter ( Omar ) ;
6678: LD_ADDR_EXP 50
6682: PUSH
6683: LD_STRING Omar
6685: PPUSH
6686: CALL_OW 25
6690: ST_TO_ADDR
// PlaceUnitXY ( Omar , 330 , 244 , false ) ;
6691: LD_EXP 50
6695: PPUSH
6696: LD_INT 330
6698: PPUSH
6699: LD_INT 244
6701: PPUSH
6702: LD_INT 0
6704: PPUSH
6705: CALL_OW 48
// ComMoveUnit ( Omar , NearestUnitToUnit ( FilterAllUnits ( [ f_side , 7 ] ) , Omar ) ) ;
6709: LD_EXP 50
6713: PPUSH
6714: LD_INT 22
6716: PUSH
6717: LD_INT 7
6719: PUSH
6720: EMPTY
6721: LIST
6722: LIST
6723: PPUSH
6724: CALL_OW 69
6728: PPUSH
6729: LD_EXP 50
6733: PPUSH
6734: CALL_OW 74
6738: PPUSH
6739: CALL_OW 112
// end ; end_of_file
6743: LD_VAR 0 1
6747: RET
// export Schulz , Kozlov ; export function PrepareLegion ; var i , side , un , tmp ; begin
6748: LD_INT 0
6750: PPUSH
6751: PPUSH
6752: PPUSH
6753: PPUSH
6754: PPUSH
// side := 8 ;
6755: LD_ADDR_VAR 0 3
6759: PUSH
6760: LD_INT 8
6762: ST_TO_ADDR
// InitHc ;
6763: CALL_OW 19
// uc_side := side ;
6767: LD_ADDR_OWVAR 20
6771: PUSH
6772: LD_VAR 0 3
6776: ST_TO_ADDR
// uc_nation := 2 ;
6777: LD_ADDR_OWVAR 21
6781: PUSH
6782: LD_INT 2
6784: ST_TO_ADDR
// for i in FilterAllUnits ( [ [ f_side , side ] , [ f_type , unit_building ] ] ) do
6785: LD_ADDR_VAR 0 2
6789: PUSH
6790: LD_INT 22
6792: PUSH
6793: LD_VAR 0 3
6797: PUSH
6798: EMPTY
6799: LIST
6800: LIST
6801: PUSH
6802: LD_INT 21
6804: PUSH
6805: LD_INT 3
6807: PUSH
6808: EMPTY
6809: LIST
6810: LIST
6811: PUSH
6812: EMPTY
6813: LIST
6814: LIST
6815: PPUSH
6816: CALL_OW 69
6820: PUSH
6821: FOR_IN
6822: IFFALSE 6838
// SetBLevel ( i , 10 ) ;
6824: LD_VAR 0 2
6828: PPUSH
6829: LD_INT 10
6831: PPUSH
6832: CALL_OW 241
6836: GO 6821
6838: POP
6839: POP
// Schulz := NewCharacter ( Schulz ) ;
6840: LD_ADDR_EXP 51
6844: PUSH
6845: LD_STRING Schulz
6847: PPUSH
6848: CALL_OW 25
6852: ST_TO_ADDR
// Kozlov := PrepareUnit ( Kozlov , false ,  ) ;
6853: LD_ADDR_EXP 52
6857: PUSH
6858: LD_STRING Kozlov
6860: PPUSH
6861: LD_INT 0
6863: PPUSH
6864: LD_STRING 
6866: PPUSH
6867: CALL 50407 0 3
6871: ST_TO_ADDR
// PlaceHumanInUnit ( Kozlov , FilterAllUnits ( [ [ f_side , 8 ] , [ f_nation , 3 ] , [ f_btype , b_lab_full ] ] ) [ 1 ] ) ;
6872: LD_EXP 52
6876: PPUSH
6877: LD_INT 22
6879: PUSH
6880: LD_INT 8
6882: PUSH
6883: EMPTY
6884: LIST
6885: LIST
6886: PUSH
6887: LD_INT 23
6889: PUSH
6890: LD_INT 3
6892: PUSH
6893: EMPTY
6894: LIST
6895: LIST
6896: PUSH
6897: LD_INT 30
6899: PUSH
6900: LD_INT 8
6902: PUSH
6903: EMPTY
6904: LIST
6905: LIST
6906: PUSH
6907: EMPTY
6908: LIST
6909: LIST
6910: LIST
6911: PPUSH
6912: CALL_OW 69
6916: PUSH
6917: LD_INT 1
6919: ARRAY
6920: PPUSH
6921: CALL_OW 52
// SetSkill ( Kozlov , class_mechanic , 10 ) ;
6925: LD_EXP 52
6929: PPUSH
6930: LD_INT 3
6932: PPUSH
6933: LD_INT 10
6935: PPUSH
6936: CALL_OW 237
// tmp := FilterAllUnits ( [ [ f_side , side ] , [ f_btype , b_bunker ] , [ f_empty ] ] ) ;
6940: LD_ADDR_VAR 0 5
6944: PUSH
6945: LD_INT 22
6947: PUSH
6948: LD_VAR 0 3
6952: PUSH
6953: EMPTY
6954: LIST
6955: LIST
6956: PUSH
6957: LD_INT 30
6959: PUSH
6960: LD_INT 32
6962: PUSH
6963: EMPTY
6964: LIST
6965: LIST
6966: PUSH
6967: LD_INT 58
6969: PUSH
6970: EMPTY
6971: LIST
6972: PUSH
6973: EMPTY
6974: LIST
6975: LIST
6976: LIST
6977: PPUSH
6978: CALL_OW 69
6982: ST_TO_ADDR
// for i = 1 to 10 do
6983: LD_ADDR_VAR 0 2
6987: PUSH
6988: DOUBLE
6989: LD_INT 1
6991: DEC
6992: ST_TO_ADDR
6993: LD_INT 10
6995: PUSH
6996: FOR_TO
6997: IFFALSE 7069
// begin uc_nation := nation_nature ;
6999: LD_ADDR_OWVAR 21
7003: PUSH
7004: LD_INT 0
7006: ST_TO_ADDR
// hc_class := class_apeman_soldier ;
7007: LD_ADDR_OWVAR 28
7011: PUSH
7012: LD_INT 15
7014: ST_TO_ADDR
// hc_gallery :=  ;
7015: LD_ADDR_OWVAR 33
7019: PUSH
7020: LD_STRING 
7022: ST_TO_ADDR
// hc_name :=  ;
7023: LD_ADDR_OWVAR 26
7027: PUSH
7028: LD_STRING 
7030: ST_TO_ADDR
// un := CreateHuman ;
7031: LD_ADDR_VAR 0 4
7035: PUSH
7036: CALL_OW 44
7040: ST_TO_ADDR
// PlaceHumanInUnit ( un , tmp [ tmp - i ] ) ;
7041: LD_VAR 0 4
7045: PPUSH
7046: LD_VAR 0 5
7050: PUSH
7051: LD_VAR 0 5
7055: PUSH
7056: LD_VAR 0 2
7060: MINUS
7061: ARRAY
7062: PPUSH
7063: CALL_OW 52
// end ;
7067: GO 6996
7069: POP
7070: POP
// PrepareBase ( ar_depot1 , legionBaseArea ,  , [ 8 , 9 , 10 ] [ Difficulty ] , [ 3000 , 500 , 150 ] , [ 16 , 6 , 6 , 8 ] ) ;
7071: LD_INT 324
7073: PPUSH
7074: LD_INT 3
7076: PPUSH
7077: LD_STRING 
7079: PPUSH
7080: LD_INT 8
7082: PUSH
7083: LD_INT 9
7085: PUSH
7086: LD_INT 10
7088: PUSH
7089: EMPTY
7090: LIST
7091: LIST
7092: LIST
7093: PUSH
7094: LD_OWVAR 67
7098: ARRAY
7099: PPUSH
7100: LD_INT 3000
7102: PUSH
7103: LD_INT 500
7105: PUSH
7106: LD_INT 150
7108: PUSH
7109: EMPTY
7110: LIST
7111: LIST
7112: LIST
7113: PPUSH
7114: LD_INT 16
7116: PUSH
7117: LD_INT 6
7119: PUSH
7120: LD_INT 6
7122: PUSH
7123: LD_INT 8
7125: PUSH
7126: EMPTY
7127: LIST
7128: LIST
7129: LIST
7130: LIST
7131: PPUSH
7132: CALL 60931 0 6
// mc_bases := Replace ( mc_bases , 3 , FilterAllUnits ( [ [ f_side , side ] , [ f_nation , 2 ] , [ f_not , [ f_type , unit_vehicle ] ] ] ) diff Schulz ) ;
7136: LD_ADDR_EXP 76
7140: PUSH
7141: LD_EXP 76
7145: PPUSH
7146: LD_INT 3
7148: PPUSH
7149: LD_INT 22
7151: PUSH
7152: LD_VAR 0 3
7156: PUSH
7157: EMPTY
7158: LIST
7159: LIST
7160: PUSH
7161: LD_INT 23
7163: PUSH
7164: LD_INT 2
7166: PUSH
7167: EMPTY
7168: LIST
7169: LIST
7170: PUSH
7171: LD_INT 3
7173: PUSH
7174: LD_INT 21
7176: PUSH
7177: LD_INT 2
7179: PUSH
7180: EMPTY
7181: LIST
7182: LIST
7183: PUSH
7184: EMPTY
7185: LIST
7186: LIST
7187: PUSH
7188: EMPTY
7189: LIST
7190: LIST
7191: LIST
7192: PPUSH
7193: CALL_OW 69
7197: PUSH
7198: LD_EXP 51
7202: DIFF
7203: PPUSH
7204: CALL_OW 1
7208: ST_TO_ADDR
// end ;
7209: LD_VAR 0 1
7213: RET
// export function BuildKozlovBomb ; begin
7214: LD_INT 0
7216: PPUSH
// if not IsOk ( kozlov_fac ) or not IsOk ( kozlov_lab ) then
7217: LD_INT 332
7219: PPUSH
7220: CALL_OW 302
7224: NOT
7225: PUSH
7226: LD_INT 336
7228: PPUSH
7229: CALL_OW 302
7233: NOT
7234: OR
7235: IFFALSE 7239
// exit ;
7237: GO 7336
// ComChangeProfession ( Kozlov , 4 ) ;
7239: LD_EXP 52
7243: PPUSH
7244: LD_INT 4
7246: PPUSH
7247: CALL_OW 123
// ComResearch ( kozlov_lab , tech_sibFiss ) ;
7251: LD_INT 336
7253: PPUSH
7254: LD_INT 25
7256: PPUSH
7257: CALL_OW 124
// repeat wait ( 0 0$1 ) ;
7261: LD_INT 35
7263: PPUSH
7264: CALL_OW 67
// until GetTech ( tech_sibFiss , 8 ) = state_researched ;
7268: LD_INT 25
7270: PPUSH
7271: LD_INT 8
7273: PPUSH
7274: CALL_OW 321
7278: PUSH
7279: LD_INT 2
7281: EQUAL
7282: IFFALSE 7261
// ComExitBuilding ( Kozlov ) ;
7284: LD_EXP 52
7288: PPUSH
7289: CALL_OW 122
// AddComEnterUnit ( Kozlov , kozlov_fac ) ;
7293: LD_EXP 52
7297: PPUSH
7298: LD_INT 332
7300: PPUSH
7301: CALL_OW 180
// AddComChangeProfession ( Kozlov , 3 ) ;
7305: LD_EXP 52
7309: PPUSH
7310: LD_INT 3
7312: PPUSH
7313: CALL_OW 183
// ComConstruct ( kozlov_fac , ru_heavy_wheeled , engine_siberite , control_manual , ru_siberium_rocket ) ;
7317: LD_INT 332
7319: PPUSH
7320: LD_INT 23
7322: PPUSH
7323: LD_INT 3
7325: PPUSH
7326: LD_INT 1
7328: PPUSH
7329: LD_INT 48
7331: PPUSH
7332: CALL_OW 125
// end ;
7336: LD_VAR 0 1
7340: RET
// every 11 11$30 trigger not legionDestroyed and not MC_GetVehicles ( 3 , true ) do var i , tmp , target ;
7341: LD_EXP 3
7345: NOT
7346: PUSH
7347: LD_INT 3
7349: PPUSH
7350: LD_INT 1
7352: PPUSH
7353: CALL 45481 0 2
7357: NOT
7358: AND
7359: IFFALSE 8199
7361: GO 7363
7363: DISABLE
7364: LD_INT 0
7366: PPUSH
7367: PPUSH
7368: PPUSH
// begin enable ;
7369: ENABLE
// if not FilterAllUnits ( [ [ f_side , 8 ] , [ f_nation , 2 ] , [ f_btype , b_factory ] ] ) then
7370: LD_INT 22
7372: PUSH
7373: LD_INT 8
7375: PUSH
7376: EMPTY
7377: LIST
7378: LIST
7379: PUSH
7380: LD_INT 23
7382: PUSH
7383: LD_INT 2
7385: PUSH
7386: EMPTY
7387: LIST
7388: LIST
7389: PUSH
7390: LD_INT 30
7392: PUSH
7393: LD_INT 3
7395: PUSH
7396: EMPTY
7397: LIST
7398: LIST
7399: PUSH
7400: EMPTY
7401: LIST
7402: LIST
7403: LIST
7404: PPUSH
7405: CALL_OW 69
7409: NOT
7410: IFFALSE 7414
// exit ;
7412: GO 8199
// if Prob ( 40 ) then
7414: LD_INT 40
7416: PPUSH
7417: CALL_OW 13
7421: IFFALSE 7548
// begin MC_InsertProduceList ( 3 , [ [ ar_half_tracked , engine_combustion , control_remote , ar_rocket_launcher ] , [ ar_half_tracked , engine_combustion , control_remote , ar_rocket_launcher ] , [ ar_half_tracked , engine_combustion , control_remote , ar_rocket_launcher ] , [ ar_half_tracked , engine_combustion , control_remote , ar_rocket_launcher ] , [ ar_half_tracked , engine_combustion , control_remote , ar_rocket_launcher ] , [ ar_half_tracked , engine_combustion , control_remote , ar_flame_thrower ] , ] ) ;
7423: LD_INT 3
7425: PPUSH
7426: LD_INT 14
7428: PUSH
7429: LD_INT 1
7431: PUSH
7432: LD_INT 2
7434: PUSH
7435: LD_INT 28
7437: PUSH
7438: EMPTY
7439: LIST
7440: LIST
7441: LIST
7442: LIST
7443: PUSH
7444: LD_INT 14
7446: PUSH
7447: LD_INT 1
7449: PUSH
7450: LD_INT 2
7452: PUSH
7453: LD_INT 28
7455: PUSH
7456: EMPTY
7457: LIST
7458: LIST
7459: LIST
7460: LIST
7461: PUSH
7462: LD_INT 14
7464: PUSH
7465: LD_INT 1
7467: PUSH
7468: LD_INT 2
7470: PUSH
7471: LD_INT 28
7473: PUSH
7474: EMPTY
7475: LIST
7476: LIST
7477: LIST
7478: LIST
7479: PUSH
7480: LD_INT 14
7482: PUSH
7483: LD_INT 1
7485: PUSH
7486: LD_INT 2
7488: PUSH
7489: LD_INT 28
7491: PUSH
7492: EMPTY
7493: LIST
7494: LIST
7495: LIST
7496: LIST
7497: PUSH
7498: LD_INT 14
7500: PUSH
7501: LD_INT 1
7503: PUSH
7504: LD_INT 2
7506: PUSH
7507: LD_INT 28
7509: PUSH
7510: EMPTY
7511: LIST
7512: LIST
7513: LIST
7514: LIST
7515: PUSH
7516: LD_INT 14
7518: PUSH
7519: LD_INT 1
7521: PUSH
7522: LD_INT 2
7524: PUSH
7525: LD_INT 26
7527: PUSH
7528: EMPTY
7529: LIST
7530: LIST
7531: LIST
7532: LIST
7533: PUSH
7534: EMPTY
7535: LIST
7536: LIST
7537: LIST
7538: LIST
7539: LIST
7540: LIST
7541: PPUSH
7542: CALL 44063 0 2
// end else
7546: GO 7739
// begin MC_InsertProduceList ( 3 , [ [ ar_half_tracked , engine_combustion , control_remote , [ ar_gun , ar_flame_thrower , ar_flame_thrower ] [ Difficulty ] ] , [ ar_half_tracked , engine_combustion , control_remote , [ ar_gun , ar_flame_thrower , ar_flame_thrower ] [ Difficulty ] ] , [ ar_half_tracked , engine_combustion , control_remote , [ ar_flame_thrower , ar_flame_thrower , ar_selfpropelled_bomb ] [ Difficulty ] ] , [ ar_medium_trike , engine_combustion , control_remote , [ ar_flame_thrower , ar_selfpropelled_bomb , ar_selfpropelled_bomb ] [ Difficulty ] ] , [ ar_medium_trike , engine_combustion , control_remote , ar_selfpropelled_bomb ] , [ ar_half_tracked , engine_combustion , control_remote , ar_flame_thrower ] , ] ) ;
7548: LD_INT 3
7550: PPUSH
7551: LD_INT 14
7553: PUSH
7554: LD_INT 1
7556: PUSH
7557: LD_INT 2
7559: PUSH
7560: LD_INT 27
7562: PUSH
7563: LD_INT 26
7565: PUSH
7566: LD_INT 26
7568: PUSH
7569: EMPTY
7570: LIST
7571: LIST
7572: LIST
7573: PUSH
7574: LD_OWVAR 67
7578: ARRAY
7579: PUSH
7580: EMPTY
7581: LIST
7582: LIST
7583: LIST
7584: LIST
7585: PUSH
7586: LD_INT 14
7588: PUSH
7589: LD_INT 1
7591: PUSH
7592: LD_INT 2
7594: PUSH
7595: LD_INT 27
7597: PUSH
7598: LD_INT 26
7600: PUSH
7601: LD_INT 26
7603: PUSH
7604: EMPTY
7605: LIST
7606: LIST
7607: LIST
7608: PUSH
7609: LD_OWVAR 67
7613: ARRAY
7614: PUSH
7615: EMPTY
7616: LIST
7617: LIST
7618: LIST
7619: LIST
7620: PUSH
7621: LD_INT 14
7623: PUSH
7624: LD_INT 1
7626: PUSH
7627: LD_INT 2
7629: PUSH
7630: LD_INT 26
7632: PUSH
7633: LD_INT 26
7635: PUSH
7636: LD_INT 29
7638: PUSH
7639: EMPTY
7640: LIST
7641: LIST
7642: LIST
7643: PUSH
7644: LD_OWVAR 67
7648: ARRAY
7649: PUSH
7650: EMPTY
7651: LIST
7652: LIST
7653: LIST
7654: LIST
7655: PUSH
7656: LD_INT 13
7658: PUSH
7659: LD_INT 1
7661: PUSH
7662: LD_INT 2
7664: PUSH
7665: LD_INT 26
7667: PUSH
7668: LD_INT 29
7670: PUSH
7671: LD_INT 29
7673: PUSH
7674: EMPTY
7675: LIST
7676: LIST
7677: LIST
7678: PUSH
7679: LD_OWVAR 67
7683: ARRAY
7684: PUSH
7685: EMPTY
7686: LIST
7687: LIST
7688: LIST
7689: LIST
7690: PUSH
7691: LD_INT 13
7693: PUSH
7694: LD_INT 1
7696: PUSH
7697: LD_INT 2
7699: PUSH
7700: LD_INT 29
7702: PUSH
7703: EMPTY
7704: LIST
7705: LIST
7706: LIST
7707: LIST
7708: PUSH
7709: LD_INT 14
7711: PUSH
7712: LD_INT 1
7714: PUSH
7715: LD_INT 2
7717: PUSH
7718: LD_INT 26
7720: PUSH
7721: EMPTY
7722: LIST
7723: LIST
7724: LIST
7725: LIST
7726: PUSH
7727: EMPTY
7728: LIST
7729: LIST
7730: LIST
7731: LIST
7732: LIST
7733: LIST
7734: PPUSH
7735: CALL 44063 0 2
// end ; repeat wait ( 0 0$1 ) ;
7739: LD_INT 35
7741: PPUSH
7742: CALL_OW 67
// until MC_GetVehicles ( 3 , true ) >= 6 ;
7746: LD_INT 3
7748: PPUSH
7749: LD_INT 1
7751: PPUSH
7752: CALL 45481 0 2
7756: PUSH
7757: LD_INT 6
7759: GREATEREQUAL
7760: IFFALSE 7739
// wait ( 0 0$30 ) ;
7762: LD_INT 1050
7764: PPUSH
7765: CALL_OW 67
// tmp := MC_GetVehicles ( 3 , true ) ;
7769: LD_ADDR_VAR 0 2
7773: PUSH
7774: LD_INT 3
7776: PPUSH
7777: LD_INT 1
7779: PPUSH
7780: CALL 45481 0 2
7784: ST_TO_ADDR
// mc_vehicles := Replace ( mc_vehicles , 3 , mc_vehicles [ 3 ] diff tmp ) ;
7785: LD_ADDR_EXP 95
7789: PUSH
7790: LD_EXP 95
7794: PPUSH
7795: LD_INT 3
7797: PPUSH
7798: LD_EXP 95
7802: PUSH
7803: LD_INT 3
7805: ARRAY
7806: PUSH
7807: LD_VAR 0 2
7811: DIFF
7812: PPUSH
7813: CALL_OW 1
7817: ST_TO_ADDR
// target := rand ( 0 , 2 ) ;
7818: LD_ADDR_VAR 0 3
7822: PUSH
7823: LD_INT 0
7825: PPUSH
7826: LD_INT 2
7828: PPUSH
7829: CALL_OW 12
7833: ST_TO_ADDR
// if target then
7834: LD_VAR 0 3
7838: IFFALSE 7966
// begin repeat tmp := UnitFilter ( tmp , [ f_lives , 250 ] ) ;
7840: LD_ADDR_VAR 0 2
7844: PUSH
7845: LD_VAR 0 2
7849: PPUSH
7850: LD_INT 24
7852: PUSH
7853: LD_INT 250
7855: PUSH
7856: EMPTY
7857: LIST
7858: LIST
7859: PPUSH
7860: CALL_OW 72
7864: ST_TO_ADDR
// for i in tmp do
7865: LD_ADDR_VAR 0 1
7869: PUSH
7870: LD_VAR 0 2
7874: PUSH
7875: FOR_IN
7876: IFFALSE 7916
// if GetDistUnitXY ( i , 89 , 71 ) > 9 then
7878: LD_VAR 0 1
7882: PPUSH
7883: LD_INT 89
7885: PPUSH
7886: LD_INT 71
7888: PPUSH
7889: CALL_OW 297
7893: PUSH
7894: LD_INT 9
7896: GREATER
7897: IFFALSE 7914
// ComMoveXY ( i , 89 , 71 ) ;
7899: LD_VAR 0 1
7903: PPUSH
7904: LD_INT 89
7906: PPUSH
7907: LD_INT 71
7909: PPUSH
7910: CALL_OW 111
7914: GO 7875
7916: POP
7917: POP
// wait ( 0 0$1 ) ;
7918: LD_INT 35
7920: PPUSH
7921: CALL_OW 67
// until UnitFilter ( tmp , [ f_distxy , 89 , 71 , 9 ] ) >= ( tmp - 1 ) ;
7925: LD_VAR 0 2
7929: PPUSH
7930: LD_INT 92
7932: PUSH
7933: LD_INT 89
7935: PUSH
7936: LD_INT 71
7938: PUSH
7939: LD_INT 9
7941: PUSH
7942: EMPTY
7943: LIST
7944: LIST
7945: LIST
7946: LIST
7947: PPUSH
7948: CALL_OW 72
7952: PUSH
7953: LD_VAR 0 2
7957: PUSH
7958: LD_INT 1
7960: MINUS
7961: GREATEREQUAL
7962: IFFALSE 7840
// end else
7964: GO 8090
// begin repeat tmp := UnitFilter ( tmp , [ f_lives , 250 ] ) ;
7966: LD_ADDR_VAR 0 2
7970: PUSH
7971: LD_VAR 0 2
7975: PPUSH
7976: LD_INT 24
7978: PUSH
7979: LD_INT 250
7981: PUSH
7982: EMPTY
7983: LIST
7984: LIST
7985: PPUSH
7986: CALL_OW 72
7990: ST_TO_ADDR
// for i in tmp do
7991: LD_ADDR_VAR 0 1
7995: PUSH
7996: LD_VAR 0 2
8000: PUSH
8001: FOR_IN
8002: IFFALSE 8042
// if GetDistUnitXY ( i , 147 , 4 ) > 9 then
8004: LD_VAR 0 1
8008: PPUSH
8009: LD_INT 147
8011: PPUSH
8012: LD_INT 4
8014: PPUSH
8015: CALL_OW 297
8019: PUSH
8020: LD_INT 9
8022: GREATER
8023: IFFALSE 8040
// ComMoveXY ( i , 147 , 4 ) ;
8025: LD_VAR 0 1
8029: PPUSH
8030: LD_INT 147
8032: PPUSH
8033: LD_INT 4
8035: PPUSH
8036: CALL_OW 111
8040: GO 8001
8042: POP
8043: POP
// wait ( 0 0$1 ) ;
8044: LD_INT 35
8046: PPUSH
8047: CALL_OW 67
// until UnitFilter ( tmp , [ f_distxy , 147 , 4 , 9 ] ) >= ( tmp - 1 ) ;
8051: LD_VAR 0 2
8055: PPUSH
8056: LD_INT 92
8058: PUSH
8059: LD_INT 147
8061: PUSH
8062: LD_INT 4
8064: PUSH
8065: LD_INT 9
8067: PUSH
8068: EMPTY
8069: LIST
8070: LIST
8071: LIST
8072: LIST
8073: PPUSH
8074: CALL_OW 72
8078: PUSH
8079: LD_VAR 0 2
8083: PUSH
8084: LD_INT 1
8086: MINUS
8087: GREATEREQUAL
8088: IFFALSE 7966
// end ; repeat wait ( 0 0$1 ) ;
8090: LD_INT 35
8092: PPUSH
8093: CALL_OW 67
// for i in tmp do
8097: LD_ADDR_VAR 0 1
8101: PUSH
8102: LD_VAR 0 2
8106: PUSH
8107: FOR_IN
8108: IFFALSE 8190
// begin if GetLives ( i ) > 251 then
8110: LD_VAR 0 1
8114: PPUSH
8115: CALL_OW 256
8119: PUSH
8120: LD_INT 251
8122: GREATER
8123: IFFALSE 8161
// ComAttackUnit ( i , NearestUnitToUnit ( FilterAllUnits ( [ f_enemy , 8 ] ) , i ) ) else
8125: LD_VAR 0 1
8129: PPUSH
8130: LD_INT 81
8132: PUSH
8133: LD_INT 8
8135: PUSH
8136: EMPTY
8137: LIST
8138: LIST
8139: PPUSH
8140: CALL_OW 69
8144: PPUSH
8145: LD_VAR 0 1
8149: PPUSH
8150: CALL_OW 74
8154: PPUSH
8155: CALL_OW 115
8159: GO 8188
// if IsDead ( i ) then
8161: LD_VAR 0 1
8165: PPUSH
8166: CALL_OW 301
8170: IFFALSE 8188
// tmp := tmp diff i ;
8172: LD_ADDR_VAR 0 2
8176: PUSH
8177: LD_VAR 0 2
8181: PUSH
8182: LD_VAR 0 1
8186: DIFF
8187: ST_TO_ADDR
// end ;
8188: GO 8107
8190: POP
8191: POP
// until not tmp ;
8192: LD_VAR 0 2
8196: NOT
8197: IFFALSE 8090
// end ;
8199: PPOPN 3
8201: END
// every 0 0$1 trigger IsOk ( Kozlov ) and not legionDestroyed do
8202: LD_EXP 52
8206: PPUSH
8207: CALL_OW 302
8211: PUSH
8212: LD_EXP 3
8216: NOT
8217: AND
8218: IFFALSE 8227
8220: GO 8222
8222: DISABLE
// BuildKozlovBomb ;
8223: CALL 7214 0 0
8227: END
// every 0 0$3 trigger FilterAllUnits ( [ [ f_side , 8 ] , [ f_weapon , ru_siberium_rocket ] ] ) do
8228: LD_INT 22
8230: PUSH
8231: LD_INT 8
8233: PUSH
8234: EMPTY
8235: LIST
8236: LIST
8237: PUSH
8238: LD_INT 34
8240: PUSH
8241: LD_INT 48
8243: PUSH
8244: EMPTY
8245: LIST
8246: LIST
8247: PUSH
8248: EMPTY
8249: LIST
8250: LIST
8251: PPUSH
8252: CALL_OW 69
8256: IFFALSE 8304
8258: GO 8260
8260: DISABLE
// begin ComAttackPlace ( FilterAllUnits ( [ [ f_side , 8 ] , [ f_weapon , ru_siberium_rocket ] ] ) [ 1 ] , 173 , 96 ) ;
8261: LD_INT 22
8263: PUSH
8264: LD_INT 8
8266: PUSH
8267: EMPTY
8268: LIST
8269: LIST
8270: PUSH
8271: LD_INT 34
8273: PUSH
8274: LD_INT 48
8276: PUSH
8277: EMPTY
8278: LIST
8279: LIST
8280: PUSH
8281: EMPTY
8282: LIST
8283: LIST
8284: PPUSH
8285: CALL_OW 69
8289: PUSH
8290: LD_INT 1
8292: ARRAY
8293: PPUSH
8294: LD_INT 173
8296: PPUSH
8297: LD_INT 96
8299: PPUSH
8300: CALL_OW 116
// end ; end_of_file
8304: END
// export Platonov , Yakotich , Gleb , Bierezov ; export behemoths , behemothBuilders ; export function PrepareRussian ; var i , j , base , tmp , side , xy , b , teleport ; begin
8305: LD_INT 0
8307: PPUSH
8308: PPUSH
8309: PPUSH
8310: PPUSH
8311: PPUSH
8312: PPUSH
8313: PPUSH
8314: PPUSH
8315: PPUSH
// side := 3 ;
8316: LD_ADDR_VAR 0 6
8320: PUSH
8321: LD_INT 3
8323: ST_TO_ADDR
// InitHc ;
8324: CALL_OW 19
// uc_side := side ;
8328: LD_ADDR_OWVAR 20
8332: PUSH
8333: LD_VAR 0 6
8337: ST_TO_ADDR
// uc_nation := 3 ;
8338: LD_ADDR_OWVAR 21
8342: PUSH
8343: LD_INT 3
8345: ST_TO_ADDR
// for i in FilterAllUnits ( [ [ f_side , side ] , [ f_type , unit_building ] ] ) do
8346: LD_ADDR_VAR 0 2
8350: PUSH
8351: LD_INT 22
8353: PUSH
8354: LD_VAR 0 6
8358: PUSH
8359: EMPTY
8360: LIST
8361: LIST
8362: PUSH
8363: LD_INT 21
8365: PUSH
8366: LD_INT 3
8368: PUSH
8369: EMPTY
8370: LIST
8371: LIST
8372: PUSH
8373: EMPTY
8374: LIST
8375: LIST
8376: PPUSH
8377: CALL_OW 69
8381: PUSH
8382: FOR_IN
8383: IFFALSE 8399
// SetBLevel ( i , 10 ) ;
8385: LD_VAR 0 2
8389: PPUSH
8390: LD_INT 10
8392: PPUSH
8393: CALL_OW 241
8397: GO 8382
8399: POP
8400: POP
// teleport := FilterAllUnits ( [ [ f_side , side ] , [ f_btype , b_teleport ] ] ) ;
8401: LD_ADDR_VAR 0 9
8405: PUSH
8406: LD_INT 22
8408: PUSH
8409: LD_VAR 0 6
8413: PUSH
8414: EMPTY
8415: LIST
8416: LIST
8417: PUSH
8418: LD_INT 30
8420: PUSH
8421: LD_INT 34
8423: PUSH
8424: EMPTY
8425: LIST
8426: LIST
8427: PUSH
8428: EMPTY
8429: LIST
8430: LIST
8431: PPUSH
8432: CALL_OW 69
8436: ST_TO_ADDR
// if teleport then
8437: LD_VAR 0 9
8441: IFFALSE 8462
// TeleportExit ( teleport [ 1 ] , 123 , 122 ) ;
8443: LD_VAR 0 9
8447: PUSH
8448: LD_INT 1
8450: ARRAY
8451: PPUSH
8452: LD_INT 123
8454: PPUSH
8455: LD_INT 122
8457: PPUSH
8458: CALL_OW 243
// hc_importance := 0 ;
8462: LD_ADDR_OWVAR 32
8466: PUSH
8467: LD_INT 0
8469: ST_TO_ADDR
// Platonov := NewCharacter ( Platonov ) ;
8470: LD_ADDR_EXP 53
8474: PUSH
8475: LD_STRING Platonov
8477: PPUSH
8478: CALL_OW 25
8482: ST_TO_ADDR
// Yakotich := NewCharacter ( Yakotich ) ;
8483: LD_ADDR_EXP 54
8487: PUSH
8488: LD_STRING Yakotich
8490: PPUSH
8491: CALL_OW 25
8495: ST_TO_ADDR
// Gleb := NewCharacter ( Gleb ) ;
8496: LD_ADDR_EXP 55
8500: PUSH
8501: LD_STRING Gleb
8503: PPUSH
8504: CALL_OW 25
8508: ST_TO_ADDR
// if TestCharacters ( 03_Cornel ) then
8509: LD_STRING 03_Cornel
8511: PPUSH
8512: CALL_OW 28
8516: IFFALSE 8564
// begin Bierezov := NewCharacter ( Mikhail ) ;
8518: LD_ADDR_EXP 56
8522: PUSH
8523: LD_STRING Mikhail
8525: PPUSH
8526: CALL_OW 25
8530: ST_TO_ADDR
// PlaceUnitXYR ( Bierezov , 197 , 111 , 9 , false ) ;
8531: LD_EXP 56
8535: PPUSH
8536: LD_INT 197
8538: PPUSH
8539: LD_INT 111
8541: PPUSH
8542: LD_INT 9
8544: PPUSH
8545: LD_INT 0
8547: PPUSH
8548: CALL_OW 50
// SetClass ( Bierezov , 3 ) ;
8552: LD_EXP 56
8556: PPUSH
8557: LD_INT 3
8559: PPUSH
8560: CALL_OW 336
// end ; PlaceHumanInUnit ( Platonov , ru_depot ) ;
8564: LD_EXP 53
8568: PPUSH
8569: LD_INT 126
8571: PPUSH
8572: CALL_OW 52
// PlaceUnitXYR ( Yakotich , 197 , 111 , 9 , false ) ;
8576: LD_EXP 54
8580: PPUSH
8581: LD_INT 197
8583: PPUSH
8584: LD_INT 111
8586: PPUSH
8587: LD_INT 9
8589: PPUSH
8590: LD_INT 0
8592: PPUSH
8593: CALL_OW 50
// PlaceUnitXYR ( Gleb , 197 , 111 , 9 , false ) ;
8597: LD_EXP 55
8601: PPUSH
8602: LD_INT 197
8604: PPUSH
8605: LD_INT 111
8607: PPUSH
8608: LD_INT 9
8610: PPUSH
8611: LD_INT 0
8613: PPUSH
8614: CALL_OW 50
// tmp := PrepareBase ( ru_depot , russianBaseArea , zhukov , [ 9 , 10 , 10 ] [ Difficulty ] , [ 90000 , 1000 , 300 ] , [ 21 , 8 , 13 , 8 ] ) ;
8618: LD_ADDR_VAR 0 5
8622: PUSH
8623: LD_INT 126
8625: PPUSH
8626: LD_INT 2
8628: PPUSH
8629: LD_STRING zhukov
8631: PPUSH
8632: LD_INT 9
8634: PUSH
8635: LD_INT 10
8637: PUSH
8638: LD_INT 10
8640: PUSH
8641: EMPTY
8642: LIST
8643: LIST
8644: LIST
8645: PUSH
8646: LD_OWVAR 67
8650: ARRAY
8651: PPUSH
8652: LD_INT 90000
8654: PUSH
8655: LD_INT 1000
8657: PUSH
8658: LD_INT 300
8660: PUSH
8661: EMPTY
8662: LIST
8663: LIST
8664: LIST
8665: PPUSH
8666: LD_INT 21
8668: PUSH
8669: LD_INT 8
8671: PUSH
8672: LD_INT 13
8674: PUSH
8675: LD_INT 8
8677: PUSH
8678: EMPTY
8679: LIST
8680: LIST
8681: LIST
8682: LIST
8683: PPUSH
8684: CALL 60931 0 6
8688: ST_TO_ADDR
// base := GetBase ( ru_depot2 ) ;
8689: LD_ADDR_VAR 0 4
8693: PUSH
8694: LD_INT 267
8696: PPUSH
8697: CALL_OW 274
8701: ST_TO_ADDR
// SetResourceType ( base , mat_cans , 5000 ) ;
8702: LD_VAR 0 4
8706: PPUSH
8707: LD_INT 1
8709: PPUSH
8710: LD_INT 5000
8712: PPUSH
8713: CALL_OW 277
// SetResourceType ( base , mat_oil , 200 ) ;
8717: LD_VAR 0 4
8721: PPUSH
8722: LD_INT 2
8724: PPUSH
8725: LD_INT 200
8727: PPUSH
8728: CALL_OW 277
// SetResourceType ( base , mat_siberit , 200 ) ;
8732: LD_VAR 0 4
8736: PPUSH
8737: LD_INT 3
8739: PPUSH
8740: LD_INT 200
8742: PPUSH
8743: CALL_OW 277
// mc_bases := Replace ( mc_bases , 2 , tmp union FilterAllUnits ( [ [ f_side , side ] , [ f_not , [ f_type , unit_vehicle ] ] ] ) diff Platonov ) ;
8747: LD_ADDR_EXP 76
8751: PUSH
8752: LD_EXP 76
8756: PPUSH
8757: LD_INT 2
8759: PPUSH
8760: LD_VAR 0 5
8764: PUSH
8765: LD_INT 22
8767: PUSH
8768: LD_VAR 0 6
8772: PUSH
8773: EMPTY
8774: LIST
8775: LIST
8776: PUSH
8777: LD_INT 3
8779: PUSH
8780: LD_INT 21
8782: PUSH
8783: LD_INT 2
8785: PUSH
8786: EMPTY
8787: LIST
8788: LIST
8789: PUSH
8790: EMPTY
8791: LIST
8792: LIST
8793: PUSH
8794: EMPTY
8795: LIST
8796: LIST
8797: PPUSH
8798: CALL_OW 69
8802: UNION
8803: PUSH
8804: LD_EXP 53
8808: DIFF
8809: PPUSH
8810: CALL_OW 1
8814: ST_TO_ADDR
// behemoths := [ ] ;
8815: LD_ADDR_EXP 57
8819: PUSH
8820: EMPTY
8821: ST_TO_ADDR
// behemothBuilders := [ ] ;
8822: LD_ADDR_EXP 58
8826: PUSH
8827: EMPTY
8828: ST_TO_ADDR
// j := 3 ;
8829: LD_ADDR_VAR 0 3
8833: PUSH
8834: LD_INT 3
8836: ST_TO_ADDR
// for i in FilterAllUnits ( [ [ f_side , 3 ] , [ f_class , 3 ] ] ) do
8837: LD_ADDR_VAR 0 2
8841: PUSH
8842: LD_INT 22
8844: PUSH
8845: LD_INT 3
8847: PUSH
8848: EMPTY
8849: LIST
8850: LIST
8851: PUSH
8852: LD_INT 25
8854: PUSH
8855: LD_INT 3
8857: PUSH
8858: EMPTY
8859: LIST
8860: LIST
8861: PUSH
8862: EMPTY
8863: LIST
8864: LIST
8865: PPUSH
8866: CALL_OW 69
8870: PUSH
8871: FOR_IN
8872: IFFALSE 8922
// begin behemothBuilders := Join ( behemothBuilders , i ) ;
8874: LD_ADDR_EXP 58
8878: PUSH
8879: LD_EXP 58
8883: PPUSH
8884: LD_VAR 0 2
8888: PPUSH
8889: CALL 93270 0 2
8893: ST_TO_ADDR
// j := j - 1 ;
8894: LD_ADDR_VAR 0 3
8898: PUSH
8899: LD_VAR 0 3
8903: PUSH
8904: LD_INT 1
8906: MINUS
8907: ST_TO_ADDR
// if j = 0 then
8908: LD_VAR 0 3
8912: PUSH
8913: LD_INT 0
8915: EQUAL
8916: IFFALSE 8920
// break ;
8918: GO 8922
// end ;
8920: GO 8871
8922: POP
8923: POP
// end ;
8924: LD_VAR 0 1
8928: RET
// export function BuildBehemoths ; var i , j , xy , tmp ; begin
8929: LD_INT 0
8931: PPUSH
8932: PPUSH
8933: PPUSH
8934: PPUSH
8935: PPUSH
// xy := [ [ 209 , 149 ] , [ 219 , 154 ] , [ 223 , 149 ] , [ 232 , 155 ] ] ;
8936: LD_ADDR_VAR 0 4
8940: PUSH
8941: LD_INT 209
8943: PUSH
8944: LD_INT 149
8946: PUSH
8947: EMPTY
8948: LIST
8949: LIST
8950: PUSH
8951: LD_INT 219
8953: PUSH
8954: LD_INT 154
8956: PUSH
8957: EMPTY
8958: LIST
8959: LIST
8960: PUSH
8961: LD_INT 223
8963: PUSH
8964: LD_INT 149
8966: PUSH
8967: EMPTY
8968: LIST
8969: LIST
8970: PUSH
8971: LD_INT 232
8973: PUSH
8974: LD_INT 155
8976: PUSH
8977: EMPTY
8978: LIST
8979: LIST
8980: PUSH
8981: EMPTY
8982: LIST
8983: LIST
8984: LIST
8985: LIST
8986: ST_TO_ADDR
// if not behemothBuilders then
8987: LD_EXP 58
8991: NOT
8992: IFFALSE 8996
// exit ;
8994: GO 9100
// j := 1 ;
8996: LD_ADDR_VAR 0 3
9000: PUSH
9001: LD_INT 1
9003: ST_TO_ADDR
// for i in behemothBuilders do
9004: LD_ADDR_VAR 0 2
9008: PUSH
9009: LD_EXP 58
9013: PUSH
9014: FOR_IN
9015: IFFALSE 9098
// begin if IsInUnit ( i ) then
9017: LD_VAR 0 2
9021: PPUSH
9022: CALL_OW 310
9026: IFFALSE 9037
// ComExitBuilding ( i ) ;
9028: LD_VAR 0 2
9032: PPUSH
9033: CALL_OW 122
// AddComBuildBehemoth ( i , b_behemoth , xy [ j ] [ 1 ] , xy [ j ] [ 2 ] , 0 ) ;
9037: LD_VAR 0 2
9041: PPUSH
9042: LD_INT 37
9044: PPUSH
9045: LD_VAR 0 4
9049: PUSH
9050: LD_VAR 0 3
9054: ARRAY
9055: PUSH
9056: LD_INT 1
9058: ARRAY
9059: PPUSH
9060: LD_VAR 0 4
9064: PUSH
9065: LD_VAR 0 3
9069: ARRAY
9070: PUSH
9071: LD_INT 2
9073: ARRAY
9074: PPUSH
9075: LD_INT 0
9077: PPUSH
9078: CALL_OW 230
// j := j + 1 ;
9082: LD_ADDR_VAR 0 3
9086: PUSH
9087: LD_VAR 0 3
9091: PUSH
9092: LD_INT 1
9094: PLUS
9095: ST_TO_ADDR
// end ;
9096: GO 9014
9098: POP
9099: POP
// end ;
9100: LD_VAR 0 1
9104: RET
// every 0 0$3 trigger GetBehemoths ( 3 ) and not FilterAllUnits ( [ [ f_side , 3 ] , [ f_btype , b_behemoth ] ] ) do var i , tmp ;
9105: LD_INT 3
9107: PPUSH
9108: CALL 93318 0 1
9112: PUSH
9113: LD_INT 22
9115: PUSH
9116: LD_INT 3
9118: PUSH
9119: EMPTY
9120: LIST
9121: LIST
9122: PUSH
9123: LD_INT 30
9125: PUSH
9126: LD_INT 37
9128: PUSH
9129: EMPTY
9130: LIST
9131: LIST
9132: PUSH
9133: EMPTY
9134: LIST
9135: LIST
9136: PPUSH
9137: CALL_OW 69
9141: NOT
9142: AND
9143: IFFALSE 9329
9145: GO 9147
9147: DISABLE
9148: LD_INT 0
9150: PPUSH
9151: PPUSH
// begin enable ;
9152: ENABLE
// tmp := GetBehemoths ( 3 ) ;
9153: LD_ADDR_VAR 0 2
9157: PUSH
9158: LD_INT 3
9160: PPUSH
9161: CALL 93318 0 1
9165: ST_TO_ADDR
// for i in tmp do
9166: LD_ADDR_VAR 0 1
9170: PUSH
9171: LD_VAR 0 2
9175: PUSH
9176: FOR_IN
9177: IFFALSE 9327
// begin if IsInArea ( i , powellBase ) and not GetTag ( i ) = 2 then
9179: LD_VAR 0 1
9183: PPUSH
9184: LD_INT 7
9186: PPUSH
9187: CALL_OW 308
9191: PUSH
9192: LD_VAR 0 1
9196: PPUSH
9197: CALL_OW 110
9201: PUSH
9202: LD_INT 2
9204: EQUAL
9205: NOT
9206: AND
9207: IFFALSE 9221
// SetTag ( i , 2 ) ;
9209: LD_VAR 0 1
9213: PPUSH
9214: LD_INT 2
9216: PPUSH
9217: CALL_OW 109
// if not FilterAllUnits ( [ [ f_enemy , 3 ] , [ f_dist , i , 12 ] ] ) and not GetTag ( i ) = 2 then
9221: LD_INT 81
9223: PUSH
9224: LD_INT 3
9226: PUSH
9227: EMPTY
9228: LIST
9229: LIST
9230: PUSH
9231: LD_INT 91
9233: PUSH
9234: LD_VAR 0 1
9238: PUSH
9239: LD_INT 12
9241: PUSH
9242: EMPTY
9243: LIST
9244: LIST
9245: LIST
9246: PUSH
9247: EMPTY
9248: LIST
9249: LIST
9250: PPUSH
9251: CALL_OW 69
9255: NOT
9256: PUSH
9257: LD_VAR 0 1
9261: PPUSH
9262: CALL_OW 110
9266: PUSH
9267: LD_INT 2
9269: EQUAL
9270: NOT
9271: AND
9272: IFFALSE 9291
// ComAgressiveMove ( i , 64 , 93 ) else
9274: LD_VAR 0 1
9278: PPUSH
9279: LD_INT 64
9281: PPUSH
9282: LD_INT 93
9284: PPUSH
9285: CALL_OW 114
9289: GO 9325
// ComAttackUnit ( i , NearestUnitToUnit ( FilterAllUnits ( [ f_enemy , 3 ] ) , i ) ) ;
9291: LD_VAR 0 1
9295: PPUSH
9296: LD_INT 81
9298: PUSH
9299: LD_INT 3
9301: PUSH
9302: EMPTY
9303: LIST
9304: LIST
9305: PPUSH
9306: CALL_OW 69
9310: PPUSH
9311: LD_VAR 0 1
9315: PPUSH
9316: CALL_OW 74
9320: PPUSH
9321: CALL_OW 115
// end ;
9325: GO 9176
9327: POP
9328: POP
// end ;
9329: PPOPN 2
9331: END
// every 11 11$30 trigger not russianDestroyed and not MC_GetVehicles ( 2 , true ) do var i , tmp , target , teleport ;
9332: LD_EXP 2
9336: NOT
9337: PUSH
9338: LD_INT 2
9340: PPUSH
9341: LD_INT 1
9343: PPUSH
9344: CALL 45481 0 2
9348: NOT
9349: AND
9350: IFFALSE 10270
9352: GO 9354
9354: DISABLE
9355: LD_INT 0
9357: PPUSH
9358: PPUSH
9359: PPUSH
9360: PPUSH
// begin enable ;
9361: ENABLE
// if not FilterAllUnits ( [ [ f_side , 3 ] , [ f_btype , b_factory ] ] ) then
9362: LD_INT 22
9364: PUSH
9365: LD_INT 3
9367: PUSH
9368: EMPTY
9369: LIST
9370: LIST
9371: PUSH
9372: LD_INT 30
9374: PUSH
9375: LD_INT 3
9377: PUSH
9378: EMPTY
9379: LIST
9380: LIST
9381: PUSH
9382: EMPTY
9383: LIST
9384: LIST
9385: PPUSH
9386: CALL_OW 69
9390: NOT
9391: IFFALSE 9395
// exit ;
9393: GO 10270
// teleport := FilterAllUnits ( [ [ f_side , 3 ] , [ f_btype , b_teleport ] ] ) ;
9395: LD_ADDR_VAR 0 4
9399: PUSH
9400: LD_INT 22
9402: PUSH
9403: LD_INT 3
9405: PUSH
9406: EMPTY
9407: LIST
9408: LIST
9409: PUSH
9410: LD_INT 30
9412: PUSH
9413: LD_INT 34
9415: PUSH
9416: EMPTY
9417: LIST
9418: LIST
9419: PUSH
9420: EMPTY
9421: LIST
9422: LIST
9423: PPUSH
9424: CALL_OW 69
9428: ST_TO_ADDR
// if Prob ( 40 ) then
9429: LD_INT 40
9431: PPUSH
9432: CALL_OW 13
9436: IFFALSE 9563
// begin MC_InsertProduceList ( 2 , [ [ ru_medium_tracked , engine_siberite , control_computer , ru_time_lapser ] , [ ru_medium_tracked , engine_siberite , control_computer , ru_time_lapser ] , [ ru_medium_tracked , engine_siberite , control_computer , ru_time_lapser ] , [ ru_heavy_tracked , engine_siberite , control_computer , ru_heavy_gun ] , [ ru_heavy_tracked , engine_siberite , control_computer , ru_heavy_gun ] , [ ru_heavy_tracked , engine_siberite , control_computer , ru_heavy_gun ] ] ) ;
9438: LD_INT 2
9440: PPUSH
9441: LD_INT 22
9443: PUSH
9444: LD_INT 3
9446: PUSH
9447: LD_INT 3
9449: PUSH
9450: LD_INT 49
9452: PUSH
9453: EMPTY
9454: LIST
9455: LIST
9456: LIST
9457: LIST
9458: PUSH
9459: LD_INT 22
9461: PUSH
9462: LD_INT 3
9464: PUSH
9465: LD_INT 3
9467: PUSH
9468: LD_INT 49
9470: PUSH
9471: EMPTY
9472: LIST
9473: LIST
9474: LIST
9475: LIST
9476: PUSH
9477: LD_INT 22
9479: PUSH
9480: LD_INT 3
9482: PUSH
9483: LD_INT 3
9485: PUSH
9486: LD_INT 49
9488: PUSH
9489: EMPTY
9490: LIST
9491: LIST
9492: LIST
9493: LIST
9494: PUSH
9495: LD_INT 24
9497: PUSH
9498: LD_INT 3
9500: PUSH
9501: LD_INT 3
9503: PUSH
9504: LD_INT 46
9506: PUSH
9507: EMPTY
9508: LIST
9509: LIST
9510: LIST
9511: LIST
9512: PUSH
9513: LD_INT 24
9515: PUSH
9516: LD_INT 3
9518: PUSH
9519: LD_INT 3
9521: PUSH
9522: LD_INT 46
9524: PUSH
9525: EMPTY
9526: LIST
9527: LIST
9528: LIST
9529: LIST
9530: PUSH
9531: LD_INT 24
9533: PUSH
9534: LD_INT 3
9536: PUSH
9537: LD_INT 3
9539: PUSH
9540: LD_INT 46
9542: PUSH
9543: EMPTY
9544: LIST
9545: LIST
9546: LIST
9547: LIST
9548: PUSH
9549: EMPTY
9550: LIST
9551: LIST
9552: LIST
9553: LIST
9554: LIST
9555: LIST
9556: PPUSH
9557: CALL 44063 0 2
// end else
9561: GO 9686
// begin MC_InsertProduceList ( 2 , [ [ ru_heavy_tracked , engine_siberite , control_computer , ru_rocket ] , [ ru_heavy_tracked , engine_siberite , control_computer , ru_rocket ] , [ ru_heavy_tracked , engine_siberite , control_computer , ru_rocket ] , [ ru_heavy_tracked , engine_siberite , control_computer , ru_heavy_gun ] , [ ru_heavy_tracked , engine_siberite , control_computer , ru_heavy_gun ] , [ ru_heavy_tracked , engine_siberite , control_computer , ru_heavy_gun ] ] ) ;
9563: LD_INT 2
9565: PPUSH
9566: LD_INT 24
9568: PUSH
9569: LD_INT 3
9571: PUSH
9572: LD_INT 3
9574: PUSH
9575: LD_INT 47
9577: PUSH
9578: EMPTY
9579: LIST
9580: LIST
9581: LIST
9582: LIST
9583: PUSH
9584: LD_INT 24
9586: PUSH
9587: LD_INT 3
9589: PUSH
9590: LD_INT 3
9592: PUSH
9593: LD_INT 47
9595: PUSH
9596: EMPTY
9597: LIST
9598: LIST
9599: LIST
9600: LIST
9601: PUSH
9602: LD_INT 24
9604: PUSH
9605: LD_INT 3
9607: PUSH
9608: LD_INT 3
9610: PUSH
9611: LD_INT 47
9613: PUSH
9614: EMPTY
9615: LIST
9616: LIST
9617: LIST
9618: LIST
9619: PUSH
9620: LD_INT 24
9622: PUSH
9623: LD_INT 3
9625: PUSH
9626: LD_INT 3
9628: PUSH
9629: LD_INT 46
9631: PUSH
9632: EMPTY
9633: LIST
9634: LIST
9635: LIST
9636: LIST
9637: PUSH
9638: LD_INT 24
9640: PUSH
9641: LD_INT 3
9643: PUSH
9644: LD_INT 3
9646: PUSH
9647: LD_INT 46
9649: PUSH
9650: EMPTY
9651: LIST
9652: LIST
9653: LIST
9654: LIST
9655: PUSH
9656: LD_INT 24
9658: PUSH
9659: LD_INT 3
9661: PUSH
9662: LD_INT 3
9664: PUSH
9665: LD_INT 46
9667: PUSH
9668: EMPTY
9669: LIST
9670: LIST
9671: LIST
9672: LIST
9673: PUSH
9674: EMPTY
9675: LIST
9676: LIST
9677: LIST
9678: LIST
9679: LIST
9680: LIST
9681: PPUSH
9682: CALL 44063 0 2
// end ; if Difficulty > 1 then
9686: LD_OWVAR 67
9690: PUSH
9691: LD_INT 1
9693: GREATER
9694: IFFALSE 9724
// MC_InsertProduceList ( 2 , [ [ ru_heavy_tracked , engine_siberite , control_computer , ru_rocket ] ] ) ;
9696: LD_INT 2
9698: PPUSH
9699: LD_INT 24
9701: PUSH
9702: LD_INT 3
9704: PUSH
9705: LD_INT 3
9707: PUSH
9708: LD_INT 47
9710: PUSH
9711: EMPTY
9712: LIST
9713: LIST
9714: LIST
9715: LIST
9716: PUSH
9717: EMPTY
9718: LIST
9719: PPUSH
9720: CALL 44063 0 2
// repeat wait ( 0 0$1 ) ;
9724: LD_INT 35
9726: PPUSH
9727: CALL_OW 67
// until MC_GetVehicles ( 2 , true ) >= [ 6 , 7 , 7 ] [ Difficulty ] ;
9731: LD_INT 2
9733: PPUSH
9734: LD_INT 1
9736: PPUSH
9737: CALL 45481 0 2
9741: PUSH
9742: LD_INT 6
9744: PUSH
9745: LD_INT 7
9747: PUSH
9748: LD_INT 7
9750: PUSH
9751: EMPTY
9752: LIST
9753: LIST
9754: LIST
9755: PUSH
9756: LD_OWVAR 67
9760: ARRAY
9761: GREATEREQUAL
9762: IFFALSE 9724
// wait ( 0 0$30 ) ;
9764: LD_INT 1050
9766: PPUSH
9767: CALL_OW 67
// tmp := MC_GetVehicles ( 2 , true ) ;
9771: LD_ADDR_VAR 0 2
9775: PUSH
9776: LD_INT 2
9778: PPUSH
9779: LD_INT 1
9781: PPUSH
9782: CALL 45481 0 2
9786: ST_TO_ADDR
// mc_vehicles := Replace ( mc_vehicles , 2 , mc_vehicles [ 2 ] diff tmp ) ;
9787: LD_ADDR_EXP 95
9791: PUSH
9792: LD_EXP 95
9796: PPUSH
9797: LD_INT 2
9799: PPUSH
9800: LD_EXP 95
9804: PUSH
9805: LD_INT 2
9807: ARRAY
9808: PUSH
9809: LD_VAR 0 2
9813: DIFF
9814: PPUSH
9815: CALL_OW 1
9819: ST_TO_ADDR
// target := rand ( 0 , 1 ) ;
9820: LD_ADDR_VAR 0 3
9824: PUSH
9825: LD_INT 0
9827: PPUSH
9828: LD_INT 1
9830: PPUSH
9831: CALL_OW 12
9835: ST_TO_ADDR
// if target then
9836: LD_VAR 0 3
9840: IFFALSE 9968
// begin repeat tmp := UnitFilter ( tmp , [ f_lives , 250 ] ) ;
9842: LD_ADDR_VAR 0 2
9846: PUSH
9847: LD_VAR 0 2
9851: PPUSH
9852: LD_INT 24
9854: PUSH
9855: LD_INT 250
9857: PUSH
9858: EMPTY
9859: LIST
9860: LIST
9861: PPUSH
9862: CALL_OW 72
9866: ST_TO_ADDR
// for i in tmp do
9867: LD_ADDR_VAR 0 1
9871: PUSH
9872: LD_VAR 0 2
9876: PUSH
9877: FOR_IN
9878: IFFALSE 9918
// if GetDistUnitXY ( i , 139 , 89 ) > 9 then
9880: LD_VAR 0 1
9884: PPUSH
9885: LD_INT 139
9887: PPUSH
9888: LD_INT 89
9890: PPUSH
9891: CALL_OW 297
9895: PUSH
9896: LD_INT 9
9898: GREATER
9899: IFFALSE 9916
// ComMoveXY ( i , 139 , 89 ) ;
9901: LD_VAR 0 1
9905: PPUSH
9906: LD_INT 139
9908: PPUSH
9909: LD_INT 89
9911: PPUSH
9912: CALL_OW 111
9916: GO 9877
9918: POP
9919: POP
// wait ( 0 0$1 ) ;
9920: LD_INT 35
9922: PPUSH
9923: CALL_OW 67
// until UnitFilter ( tmp , [ f_distxy , 139 , 89 , 9 ] ) >= ( tmp - 1 ) ;
9927: LD_VAR 0 2
9931: PPUSH
9932: LD_INT 92
9934: PUSH
9935: LD_INT 139
9937: PUSH
9938: LD_INT 89
9940: PUSH
9941: LD_INT 9
9943: PUSH
9944: EMPTY
9945: LIST
9946: LIST
9947: LIST
9948: LIST
9949: PPUSH
9950: CALL_OW 72
9954: PUSH
9955: LD_VAR 0 2
9959: PUSH
9960: LD_INT 1
9962: MINUS
9963: GREATEREQUAL
9964: IFFALSE 9842
// end else
9966: GO 10110
// begin ComEnterUnit ( tmp , teleport [ 1 ] ) ;
9968: LD_VAR 0 2
9972: PPUSH
9973: LD_VAR 0 4
9977: PUSH
9978: LD_INT 1
9980: ARRAY
9981: PPUSH
9982: CALL_OW 120
// repeat tmp := UnitFilter ( tmp , [ f_lives , 250 ] ) ;
9986: LD_ADDR_VAR 0 2
9990: PUSH
9991: LD_VAR 0 2
9995: PPUSH
9996: LD_INT 24
9998: PUSH
9999: LD_INT 250
10001: PUSH
10002: EMPTY
10003: LIST
10004: LIST
10005: PPUSH
10006: CALL_OW 72
10010: ST_TO_ADDR
// for i in tmp do
10011: LD_ADDR_VAR 0 1
10015: PUSH
10016: LD_VAR 0 2
10020: PUSH
10021: FOR_IN
10022: IFFALSE 10062
// if GetDistUnitXY ( i , 124 , 139 ) > 9 then
10024: LD_VAR 0 1
10028: PPUSH
10029: LD_INT 124
10031: PPUSH
10032: LD_INT 139
10034: PPUSH
10035: CALL_OW 297
10039: PUSH
10040: LD_INT 9
10042: GREATER
10043: IFFALSE 10060
// ComMoveXY ( i , 124 , 139 ) ;
10045: LD_VAR 0 1
10049: PPUSH
10050: LD_INT 124
10052: PPUSH
10053: LD_INT 139
10055: PPUSH
10056: CALL_OW 111
10060: GO 10021
10062: POP
10063: POP
// wait ( 0 0$1 ) ;
10064: LD_INT 35
10066: PPUSH
10067: CALL_OW 67
// until UnitFilter ( tmp , [ f_distxy , 124 , 139 , 9 ] ) >= ( tmp - 1 ) ;
10071: LD_VAR 0 2
10075: PPUSH
10076: LD_INT 92
10078: PUSH
10079: LD_INT 124
10081: PUSH
10082: LD_INT 139
10084: PUSH
10085: LD_INT 9
10087: PUSH
10088: EMPTY
10089: LIST
10090: LIST
10091: LIST
10092: LIST
10093: PPUSH
10094: CALL_OW 72
10098: PUSH
10099: LD_VAR 0 2
10103: PUSH
10104: LD_INT 1
10106: MINUS
10107: GREATEREQUAL
10108: IFFALSE 9986
// end ; repeat wait ( 0 0$1 ) ;
10110: LD_INT 35
10112: PPUSH
10113: CALL_OW 67
// for i in tmp do
10117: LD_ADDR_VAR 0 1
10121: PUSH
10122: LD_VAR 0 2
10126: PUSH
10127: FOR_IN
10128: IFFALSE 10261
// begin if GetLives ( i ) > 251 then
10130: LD_VAR 0 1
10134: PPUSH
10135: CALL_OW 256
10139: PUSH
10140: LD_INT 251
10142: GREATER
10143: IFFALSE 10232
// begin if GetWeapon ( i ) = ru_time_lapser then
10145: LD_VAR 0 1
10149: PPUSH
10150: CALL_OW 264
10154: PUSH
10155: LD_INT 49
10157: EQUAL
10158: IFFALSE 10196
// ComMoveUnit ( i , NearestUnitToUnit ( FilterAllUnits ( [ f_enemy , 3 ] ) , i ) ) else
10160: LD_VAR 0 1
10164: PPUSH
10165: LD_INT 81
10167: PUSH
10168: LD_INT 3
10170: PUSH
10171: EMPTY
10172: LIST
10173: LIST
10174: PPUSH
10175: CALL_OW 69
10179: PPUSH
10180: LD_VAR 0 1
10184: PPUSH
10185: CALL_OW 74
10189: PPUSH
10190: CALL_OW 112
10194: GO 10230
// ComAttackUnit ( i , NearestUnitToUnit ( FilterAllUnits ( [ f_enemy , 3 ] ) , i ) ) ;
10196: LD_VAR 0 1
10200: PPUSH
10201: LD_INT 81
10203: PUSH
10204: LD_INT 3
10206: PUSH
10207: EMPTY
10208: LIST
10209: LIST
10210: PPUSH
10211: CALL_OW 69
10215: PPUSH
10216: LD_VAR 0 1
10220: PPUSH
10221: CALL_OW 74
10225: PPUSH
10226: CALL_OW 115
// end else
10230: GO 10259
// if IsDead ( i ) then
10232: LD_VAR 0 1
10236: PPUSH
10237: CALL_OW 301
10241: IFFALSE 10259
// tmp := tmp diff i ;
10243: LD_ADDR_VAR 0 2
10247: PUSH
10248: LD_VAR 0 2
10252: PUSH
10253: LD_VAR 0 1
10257: DIFF
10258: ST_TO_ADDR
// end ;
10259: GO 10127
10261: POP
10262: POP
// until not tmp ;
10263: LD_VAR 0 2
10267: NOT
10268: IFFALSE 10110
// end ;
10270: PPOPN 4
10272: END
// every 30 30$00 trigger not russianDestroyed do
10273: LD_EXP 2
10277: NOT
10278: IFFALSE 10343
10280: GO 10282
10282: DISABLE
// begin wait ( [ 50 50$00 , 40 40$00 , 30 30$00 ] [ Difficulty ] ) ;
10283: LD_INT 105000
10285: PUSH
10286: LD_INT 84000
10288: PUSH
10289: LD_INT 63000
10291: PUSH
10292: EMPTY
10293: LIST
10294: LIST
10295: LIST
10296: PUSH
10297: LD_OWVAR 67
10301: ARRAY
10302: PPUSH
10303: CALL_OW 67
// if russianDestroyed then
10307: LD_EXP 2
10311: IFFALSE 10315
// exit ;
10313: GO 10343
// MC_InsertProduceList ( 2 , [ [ ru_heavy_wheeled , engine_siberite , control_manual , ru_siberium_rocket ] ] ) ;
10315: LD_INT 2
10317: PPUSH
10318: LD_INT 23
10320: PUSH
10321: LD_INT 3
10323: PUSH
10324: LD_INT 1
10326: PUSH
10327: LD_INT 48
10329: PUSH
10330: EMPTY
10331: LIST
10332: LIST
10333: LIST
10334: LIST
10335: PUSH
10336: EMPTY
10337: LIST
10338: PPUSH
10339: CALL 44063 0 2
// end ; end_of_file
10343: END
// export function CustomEvent ( event ) ; begin
10344: LD_INT 0
10346: PPUSH
// end ;
10347: LD_VAR 0 2
10351: RET
// on SibDepositContaminated ( unit , x , y ) do begin if InArea ( x , y , motherLodeArea ) then
10352: LD_VAR 0 2
10356: PPUSH
10357: LD_VAR 0 3
10361: PPUSH
10362: LD_INT 15
10364: PPUSH
10365: CALL_OW 309
10369: IFFALSE 10378
// YouLost ( MothContaminate ) ;
10371: LD_STRING MothContaminate
10373: PPUSH
10374: CALL_OW 104
// end ;
10378: PPOPN 3
10380: END
// on SiberiteRocketExploded ( unit , x , y ) do begin if InArea ( x , y , motherLodeArea ) then
10381: LD_VAR 0 2
10385: PPUSH
10386: LD_VAR 0 3
10390: PPUSH
10391: LD_INT 15
10393: PPUSH
10394: CALL_OW 309
10398: IFFALSE 10414
// begin wait ( 0 0$6 ) ;
10400: LD_INT 210
10402: PPUSH
10403: CALL_OW 67
// YouLost ( MothContaminateBomb ) ;
10407: LD_STRING MothContaminateBomb
10409: PPUSH
10410: CALL_OW 104
// end ; end ;
10414: PPOPN 3
10416: END
// on UnitDestroyed ( un ) do begin if un = JMM then
10417: LD_VAR 0 1
10421: PUSH
10422: LD_EXP 14
10426: EQUAL
10427: IFFALSE 10438
// begin YouLost ( JMM ) ;
10429: LD_STRING JMM
10431: PPUSH
10432: CALL_OW 104
// exit ;
10436: GO 10537
// end ; if un = Powell then
10438: LD_VAR 0 1
10442: PUSH
10443: LD_EXP 49
10447: EQUAL
10448: IFFALSE 10458
// americanDestroyed := true ;
10450: LD_ADDR_EXP 4
10454: PUSH
10455: LD_INT 1
10457: ST_TO_ADDR
// if un = Platonov then
10458: LD_VAR 0 1
10462: PUSH
10463: LD_EXP 53
10467: EQUAL
10468: IFFALSE 10478
// russianDestroyed := true ;
10470: LD_ADDR_EXP 2
10474: PUSH
10475: LD_INT 1
10477: ST_TO_ADDR
// if un in FilterAllUnits ( [ [ f_side , 7 ] , [ f_type , unit_vehicle ] ] ) then
10478: LD_VAR 0 1
10482: PUSH
10483: LD_INT 22
10485: PUSH
10486: LD_INT 7
10488: PUSH
10489: EMPTY
10490: LIST
10491: LIST
10492: PUSH
10493: LD_INT 21
10495: PUSH
10496: LD_INT 2
10498: PUSH
10499: EMPTY
10500: LIST
10501: LIST
10502: PUSH
10503: EMPTY
10504: LIST
10505: LIST
10506: PPUSH
10507: CALL_OW 69
10511: IN
10512: IFFALSE 10528
// vehicleLostCounter := vehicleLostCounter + 1 ;
10514: LD_ADDR_EXP 12
10518: PUSH
10519: LD_EXP 12
10523: PUSH
10524: LD_INT 1
10526: PLUS
10527: ST_TO_ADDR
// MCE_UnitDestroyed ( un ) ;
10528: LD_VAR 0 1
10532: PPUSH
10533: CALL 47455 0 1
// end ;
10537: PPOPN 1
10539: END
// on BuildingStarted ( building , builder ) do begin MCE_BuildingStarted ( building , builder ) ;
10540: LD_VAR 0 1
10544: PPUSH
10545: LD_VAR 0 2
10549: PPUSH
10550: CALL 49789 0 2
// end ;
10554: PPOPN 2
10556: END
// on UpgradeComplete ( building ) do begin MCE_UpgradeComplete ( building ) ;
10557: LD_VAR 0 1
10561: PPUSH
10562: CALL 48857 0 1
// end ;
10566: PPOPN 1
10568: END
// on BuildingComplete ( building ) do begin if building in FilterAllUnits ( [ [ f_side , 8 ] , [ f_btype , b_workshop ] , [ f_nation , 3 ] ] ) then
10569: LD_VAR 0 1
10573: PUSH
10574: LD_INT 22
10576: PUSH
10577: LD_INT 8
10579: PUSH
10580: EMPTY
10581: LIST
10582: LIST
10583: PUSH
10584: LD_INT 30
10586: PUSH
10587: LD_INT 2
10589: PUSH
10590: EMPTY
10591: LIST
10592: LIST
10593: PUSH
10594: LD_INT 23
10596: PUSH
10597: LD_INT 3
10599: PUSH
10600: EMPTY
10601: LIST
10602: LIST
10603: PUSH
10604: EMPTY
10605: LIST
10606: LIST
10607: LIST
10608: PPUSH
10609: CALL_OW 69
10613: IN
10614: IFFALSE 10641
// begin ComUpgrade ( building ) ;
10616: LD_VAR 0 1
10620: PPUSH
10621: CALL_OW 146
// ComComplete ( Kozlov , building ) ;
10625: LD_EXP 52
10629: PPUSH
10630: LD_VAR 0 1
10634: PPUSH
10635: CALL 60495 0 2
// exit ;
10639: GO 10650
// end ; MCE_BuildingComplete ( building ) ;
10641: LD_VAR 0 1
10645: PPUSH
10646: CALL 49098 0 1
// end ;
10650: PPOPN 1
10652: END
// on ResearchComplete ( tech , lab ) do begin MCE_ResearchComplete ( tech , lab ) ;
10653: LD_VAR 0 1
10657: PPUSH
10658: LD_VAR 0 2
10662: PPUSH
10663: CALL 47151 0 2
// end ;
10667: PPOPN 2
10669: END
// on CrateSpawn ( id , x , y , amount , mode ) do begin MCE_CrateSpawn ( id , x , y , amount , mode ) ;
10670: LD_VAR 0 1
10674: PPUSH
10675: LD_VAR 0 2
10679: PPUSH
10680: LD_VAR 0 3
10684: PPUSH
10685: LD_VAR 0 4
10689: PPUSH
10690: LD_VAR 0 5
10694: PPUSH
10695: CALL 46771 0 5
// end ;
10699: PPOPN 5
10701: END
// on VehicleConstructed ( vehicle , factory ) do begin MCE_VehicleConstructed ( vehicle , factory ) ;
10702: LD_VAR 0 1
10706: PPUSH
10707: LD_VAR 0 2
10711: PPUSH
10712: CALL 46367 0 2
// end ;
10716: PPOPN 2
10718: END
// on VehicleCaptured ( new , old , side , capturing_unit ) do begin MCE_VehicleCaptured ( new , old , side , capturing_unit ) ;
10719: LD_VAR 0 1
10723: PPUSH
10724: LD_VAR 0 2
10728: PPUSH
10729: LD_VAR 0 3
10733: PPUSH
10734: LD_VAR 0 4
10738: PPUSH
10739: CALL 46205 0 4
// end ;
10743: PPOPN 4
10745: END
// on BuildingCaptured ( building , side , capturning_unit ) do begin MCE_BuildingCaptured ( building , side , capturning_unit ) ;
10746: LD_VAR 0 1
10750: PPUSH
10751: LD_VAR 0 2
10755: PPUSH
10756: LD_VAR 0 3
10760: PPUSH
10761: CALL 45980 0 3
// end ;
10765: PPOPN 3
10767: END
// on EnterBuilding ( building , unit ) do begin MCE_EnterBuilding ( building , unit ) ;
10768: LD_VAR 0 1
10772: PPUSH
10773: LD_VAR 0 2
10777: PPUSH
10778: CALL 45865 0 2
// end ;
10782: PPOPN 2
10784: END
// on LeaveBuilding ( building , unit ) do begin MCE_LeaveBuilding ( building , unit ) ;
10785: LD_VAR 0 1
10789: PPUSH
10790: LD_VAR 0 2
10794: PPUSH
10795: CALL 50050 0 2
// end ;
10799: PPOPN 2
10801: END
// on EvacuateVehicle ( driver , abandoned_vehicle , unknown1 , unknown2 ) do begin MCE_EvacuateVehicle ( driver , abandoned_vehicle , unknown1 , unknown2 ) ;
10802: LD_VAR 0 1
10806: PPUSH
10807: LD_VAR 0 2
10811: PPUSH
10812: LD_VAR 0 3
10816: PPUSH
10817: LD_VAR 0 4
10821: PPUSH
10822: CALL 50266 0 4
// end ;
10826: PPOPN 4
10828: END
// on ApemanTamed ( ape , sci ) do begin MCE_ApemanTamed ( ape , sci ) ;
10829: LD_VAR 0 1
10833: PPUSH
10834: LD_VAR 0 2
10838: PPUSH
10839: CALL 45674 0 2
// end ;
10843: PPOPN 2
10845: END
// on Command ( cmd ) do begin SOS_Command ( cmd ) ;
10846: LD_VAR 0 1
10850: PPUSH
10851: CALL 93670 0 1
// end ; end_of_file
10855: PPOPN 1
10857: END
// export function Action ; begin
10858: LD_INT 0
10860: PPUSH
// InGameOn ;
10861: CALL_OW 8
// CenterNowOnXY ( 206 , 11 ) ;
10865: LD_INT 206
10867: PPUSH
10868: LD_INT 11
10870: PPUSH
10871: CALL_OW 86
// wait ( 0 0$1 ) ;
10875: LD_INT 35
10877: PPUSH
10878: CALL_OW 67
// Say ( JMM , DStart-JMM-JMM-1 ) ;
10882: LD_EXP 14
10886: PPUSH
10887: LD_STRING DStart-JMM-JMM-1
10889: PPUSH
10890: CALL_OW 88
// Say ( Burlak , DStart-JMM-Bur-1 ) ;
10894: LD_EXP 46
10898: PPUSH
10899: LD_STRING DStart-JMM-Bur-1
10901: PPUSH
10902: CALL_OW 88
// Say ( JMM , DStart-JMM-JMM-2 ) ;
10906: LD_EXP 14
10910: PPUSH
10911: LD_STRING DStart-JMM-JMM-2
10913: PPUSH
10914: CALL_OW 88
// Say ( Burlak , DStart-JMM-Bur-2 ) ;
10918: LD_EXP 46
10922: PPUSH
10923: LD_STRING DStart-JMM-Bur-2
10925: PPUSH
10926: CALL_OW 88
// InGameOff ;
10930: CALL_OW 9
// ChangeMissionObjectives ( MStart ) ;
10934: LD_STRING MStart
10936: PPUSH
10937: CALL_OW 337
// end ;
10941: LD_VAR 0 1
10945: RET
// every 0 0$2 trigger SeeXY ( 7 , 255 , 219 ) do var speaker ;
10946: LD_INT 7
10948: PPUSH
10949: LD_INT 255
10951: PPUSH
10952: LD_INT 219
10954: PPUSH
10955: CALL_OW 293
10959: IFFALSE 11568
10961: GO 10963
10963: DISABLE
10964: LD_INT 0
10966: PPUSH
// begin wait ( 0 0$3 ) ;
10967: LD_INT 105
10969: PPUSH
10970: CALL_OW 67
// alienSpotted := true ;
10974: LD_ADDR_EXP 7
10978: PUSH
10979: LD_INT 1
10981: ST_TO_ADDR
// speaker := FilterAllUnits ( [ [ f_side , 7 ] , [ f_nation , 3 ] , [ f_type , unit_human ] , [ f_sex , sex_male ] ] ) diff [ Burlak , Titov , Dolgov , Petrosyan , Kuzmov , Kovalyuk , Scholtze ] ;
10982: LD_ADDR_VAR 0 1
10986: PUSH
10987: LD_INT 22
10989: PUSH
10990: LD_INT 7
10992: PUSH
10993: EMPTY
10994: LIST
10995: LIST
10996: PUSH
10997: LD_INT 23
10999: PUSH
11000: LD_INT 3
11002: PUSH
11003: EMPTY
11004: LIST
11005: LIST
11006: PUSH
11007: LD_INT 21
11009: PUSH
11010: LD_INT 1
11012: PUSH
11013: EMPTY
11014: LIST
11015: LIST
11016: PUSH
11017: LD_INT 26
11019: PUSH
11020: LD_INT 1
11022: PUSH
11023: EMPTY
11024: LIST
11025: LIST
11026: PUSH
11027: EMPTY
11028: LIST
11029: LIST
11030: LIST
11031: LIST
11032: PPUSH
11033: CALL_OW 69
11037: PUSH
11038: LD_EXP 46
11042: PUSH
11043: LD_EXP 34
11047: PUSH
11048: LD_EXP 36
11052: PUSH
11053: LD_EXP 37
11057: PUSH
11058: LD_EXP 44
11062: PUSH
11063: LD_EXP 43
11067: PUSH
11068: LD_EXP 38
11072: PUSH
11073: EMPTY
11074: LIST
11075: LIST
11076: LIST
11077: LIST
11078: LIST
11079: LIST
11080: LIST
11081: DIFF
11082: ST_TO_ADDR
// DialogueOn ;
11083: CALL_OW 6
// PlaceSeeing ( 255 , 219 , 7 , - 20 ) ;
11087: LD_INT 255
11089: PPUSH
11090: LD_INT 219
11092: PPUSH
11093: LD_INT 7
11095: PPUSH
11096: LD_INT 20
11098: NEG
11099: PPUSH
11100: CALL_OW 330
// CenterNowOnXY ( 255 , 219 ) ;
11104: LD_INT 255
11106: PPUSH
11107: LD_INT 219
11109: PPUSH
11110: CALL_OW 86
// if speaker then
11114: LD_VAR 0 1
11118: IFFALSE 11136
// Say ( speaker [ 1 ] , DAlienBase-RSol1-1 ) ;
11120: LD_VAR 0 1
11124: PUSH
11125: LD_INT 1
11127: ARRAY
11128: PPUSH
11129: LD_STRING DAlienBase-RSol1-1
11131: PPUSH
11132: CALL_OW 88
// Say ( JMM , DAlienBase-JMM-1 ) ;
11136: LD_EXP 14
11140: PPUSH
11141: LD_STRING DAlienBase-JMM-1
11143: PPUSH
11144: CALL_OW 88
// if IsOk ( Burlak ) then
11148: LD_EXP 46
11152: PPUSH
11153: CALL_OW 302
11157: IFFALSE 11178
// begin dwait ( 0 0$1 ) ;
11159: LD_INT 35
11161: PPUSH
11162: CALL_OW 68
// Say ( Burlak , DAlienBase-Bur-1 ) ;
11166: LD_EXP 46
11170: PPUSH
11171: LD_STRING DAlienBase-Bur-1
11173: PPUSH
11174: CALL_OW 88
// end ; if IsOk ( Roth ) then
11178: LD_EXP 15
11182: PPUSH
11183: CALL_OW 302
11187: IFFALSE 11201
// Say ( Roth , DAlienBase-Roth-1 ) ;
11189: LD_EXP 15
11193: PPUSH
11194: LD_STRING DAlienBase-Roth-1
11196: PPUSH
11197: CALL_OW 88
// if IsOk ( Gossudarov ) then
11201: LD_EXP 32
11205: PPUSH
11206: CALL_OW 302
11210: IFFALSE 11226
// Say ( Gossudarov , DAlienBase-Gos-1 ) else
11212: LD_EXP 32
11216: PPUSH
11217: LD_STRING DAlienBase-Gos-1
11219: PPUSH
11220: CALL_OW 88
11224: GO 11343
// begin speaker := FilterAllUnits ( [ [ f_side , 7 ] , [ f_class , 4 ] , [ f_type , unit_human ] , [ f_sex , sex_male ] ] ) diff [ Roth , JMM , Burlak , Titov , Kuzmov , Kovalyuk ] ;
11226: LD_ADDR_VAR 0 1
11230: PUSH
11231: LD_INT 22
11233: PUSH
11234: LD_INT 7
11236: PUSH
11237: EMPTY
11238: LIST
11239: LIST
11240: PUSH
11241: LD_INT 25
11243: PUSH
11244: LD_INT 4
11246: PUSH
11247: EMPTY
11248: LIST
11249: LIST
11250: PUSH
11251: LD_INT 21
11253: PUSH
11254: LD_INT 1
11256: PUSH
11257: EMPTY
11258: LIST
11259: LIST
11260: PUSH
11261: LD_INT 26
11263: PUSH
11264: LD_INT 1
11266: PUSH
11267: EMPTY
11268: LIST
11269: LIST
11270: PUSH
11271: EMPTY
11272: LIST
11273: LIST
11274: LIST
11275: LIST
11276: PPUSH
11277: CALL_OW 69
11281: PUSH
11282: LD_EXP 15
11286: PUSH
11287: LD_EXP 14
11291: PUSH
11292: LD_EXP 46
11296: PUSH
11297: LD_EXP 34
11301: PUSH
11302: LD_EXP 44
11306: PUSH
11307: LD_EXP 43
11311: PUSH
11312: EMPTY
11313: LIST
11314: LIST
11315: LIST
11316: LIST
11317: LIST
11318: LIST
11319: DIFF
11320: ST_TO_ADDR
// if speaker then
11321: LD_VAR 0 1
11325: IFFALSE 11343
// Say ( speaker [ 1 ] , DAlienBase-Sci1-1 ) ;
11327: LD_VAR 0 1
11331: PUSH
11332: LD_INT 1
11334: ARRAY
11335: PPUSH
11336: LD_STRING DAlienBase-Sci1-1
11338: PPUSH
11339: CALL_OW 88
// end ; RemoveSeeing ( 255 , 219 , 7 ) ;
11343: LD_INT 255
11345: PPUSH
11346: LD_INT 219
11348: PPUSH
11349: LD_INT 7
11351: PPUSH
11352: CALL_OW 331
// DialogueOff ;
11356: CALL_OW 7
// repeat wait ( 0 0$1 ) ;
11360: LD_INT 35
11362: PPUSH
11363: CALL_OW 67
// until IsSelected ( alien ) ;
11367: LD_INT 1
11369: PPUSH
11370: CALL_OW 306
11374: IFFALSE 11360
// if not artifactIResearched or not artifactIIResearched then
11376: LD_EXP 9
11380: NOT
11381: PUSH
11382: LD_EXP 10
11386: NOT
11387: OR
11388: IFFALSE 11568
// begin if IsOk ( Roth ) then
11390: LD_EXP 15
11394: PPUSH
11395: CALL_OW 302
11399: IFFALSE 11415
// Say ( Roth , DAlieBaseNotReady-Roth-1 ) else
11401: LD_EXP 15
11405: PPUSH
11406: LD_STRING DAlieBaseNotReady-Roth-1
11408: PPUSH
11409: CALL_OW 88
11413: GO 11568
// if IsOk ( Gossudarov ) then
11415: LD_EXP 32
11419: PPUSH
11420: CALL_OW 302
11424: IFFALSE 11440
// Say ( Gossudarov , DAlieBaseNotReady-Gos-1 ) else
11426: LD_EXP 32
11430: PPUSH
11431: LD_STRING DAlieBaseNotReady-Gos-1
11433: PPUSH
11434: CALL_OW 88
11438: GO 11568
// begin speaker := FilterAllUnits ( [ [ f_side , 7 ] , [ f_nation , 3 ] , [ f_class , 4 ] , [ f_type , unit_human ] , [ f_sex , sex_male ] ] ) diff [ Roth , JMM , Burlak , Titov , Kuzmov , Kovalyuk ] ;
11440: LD_ADDR_VAR 0 1
11444: PUSH
11445: LD_INT 22
11447: PUSH
11448: LD_INT 7
11450: PUSH
11451: EMPTY
11452: LIST
11453: LIST
11454: PUSH
11455: LD_INT 23
11457: PUSH
11458: LD_INT 3
11460: PUSH
11461: EMPTY
11462: LIST
11463: LIST
11464: PUSH
11465: LD_INT 25
11467: PUSH
11468: LD_INT 4
11470: PUSH
11471: EMPTY
11472: LIST
11473: LIST
11474: PUSH
11475: LD_INT 21
11477: PUSH
11478: LD_INT 1
11480: PUSH
11481: EMPTY
11482: LIST
11483: LIST
11484: PUSH
11485: LD_INT 26
11487: PUSH
11488: LD_INT 1
11490: PUSH
11491: EMPTY
11492: LIST
11493: LIST
11494: PUSH
11495: EMPTY
11496: LIST
11497: LIST
11498: LIST
11499: LIST
11500: LIST
11501: PPUSH
11502: CALL_OW 69
11506: PUSH
11507: LD_EXP 15
11511: PUSH
11512: LD_EXP 14
11516: PUSH
11517: LD_EXP 46
11521: PUSH
11522: LD_EXP 34
11526: PUSH
11527: LD_EXP 44
11531: PUSH
11532: LD_EXP 43
11536: PUSH
11537: EMPTY
11538: LIST
11539: LIST
11540: LIST
11541: LIST
11542: LIST
11543: LIST
11544: DIFF
11545: ST_TO_ADDR
// if speaker then
11546: LD_VAR 0 1
11550: IFFALSE 11568
// Say ( speaker [ 1 ] , DAlieBaseNotReady-RSci1-1 ) ;
11552: LD_VAR 0 1
11556: PUSH
11557: LD_INT 1
11559: ARRAY
11560: PPUSH
11561: LD_STRING DAlieBaseNotReady-RSci1-1
11563: PPUSH
11564: CALL_OW 88
// end ; end ; end ;
11568: PPOPN 1
11570: END
// every 0 0$1 trigger GetTech ( tech_Artifact , 7 ) = state_researched do var speaker ;
11571: LD_INT 24
11573: PPUSH
11574: LD_INT 7
11576: PPUSH
11577: CALL_OW 321
11581: PUSH
11582: LD_INT 2
11584: EQUAL
11585: IFFALSE 12276
11587: GO 11589
11589: DISABLE
11590: LD_INT 0
11592: PPUSH
// begin speaker := FilterAllUnits ( [ [ f_side , 7 ] , [ f_nation , 3 ] , [ f_class , 4 ] , [ f_type , unit_human ] , [ f_sex , sex_male ] ] ) diff [ Roth , JMM , Burlak , Titov , Kuzmov , Kovalyuk ] ;
11593: LD_ADDR_VAR 0 1
11597: PUSH
11598: LD_INT 22
11600: PUSH
11601: LD_INT 7
11603: PUSH
11604: EMPTY
11605: LIST
11606: LIST
11607: PUSH
11608: LD_INT 23
11610: PUSH
11611: LD_INT 3
11613: PUSH
11614: EMPTY
11615: LIST
11616: LIST
11617: PUSH
11618: LD_INT 25
11620: PUSH
11621: LD_INT 4
11623: PUSH
11624: EMPTY
11625: LIST
11626: LIST
11627: PUSH
11628: LD_INT 21
11630: PUSH
11631: LD_INT 1
11633: PUSH
11634: EMPTY
11635: LIST
11636: LIST
11637: PUSH
11638: LD_INT 26
11640: PUSH
11641: LD_INT 1
11643: PUSH
11644: EMPTY
11645: LIST
11646: LIST
11647: PUSH
11648: EMPTY
11649: LIST
11650: LIST
11651: LIST
11652: LIST
11653: LIST
11654: PPUSH
11655: CALL_OW 69
11659: PUSH
11660: LD_EXP 15
11664: PUSH
11665: LD_EXP 14
11669: PUSH
11670: LD_EXP 46
11674: PUSH
11675: LD_EXP 34
11679: PUSH
11680: LD_EXP 44
11684: PUSH
11685: LD_EXP 43
11689: PUSH
11690: EMPTY
11691: LIST
11692: LIST
11693: LIST
11694: LIST
11695: LIST
11696: LIST
11697: DIFF
11698: ST_TO_ADDR
// if not speaker then
11699: LD_VAR 0 1
11703: NOT
11704: IFFALSE 11708
// exit ;
11706: GO 12276
// DialogueOn ;
11708: CALL_OW 6
// Say ( speaker [ 1 ] , DArtefTechnology-RSci1-1 ) ;
11712: LD_VAR 0 1
11716: PUSH
11717: LD_INT 1
11719: ARRAY
11720: PPUSH
11721: LD_STRING DArtefTechnology-RSci1-1
11723: PPUSH
11724: CALL_OW 88
// if IsOk ( Burlak ) then
11728: LD_EXP 46
11732: PPUSH
11733: CALL_OW 302
11737: IFFALSE 11751
// Say ( Burlak , DArtefTechnology-Bur-1 ) ;
11739: LD_EXP 46
11743: PPUSH
11744: LD_STRING DArtefTechnology-Bur-1
11746: PPUSH
11747: CALL_OW 88
// Say ( speaker [ 1 ] , DArtefTechnology-RSci1-2 ) ;
11751: LD_VAR 0 1
11755: PUSH
11756: LD_INT 1
11758: ARRAY
11759: PPUSH
11760: LD_STRING DArtefTechnology-RSci1-2
11762: PPUSH
11763: CALL_OW 88
// if Denis then
11767: LD_EXP 20
11771: IFFALSE 11788
// speaker := [ Denis ] else
11773: LD_ADDR_VAR 0 1
11777: PUSH
11778: LD_EXP 20
11782: PUSH
11783: EMPTY
11784: LIST
11785: ST_TO_ADDR
11786: GO 11894
// speaker := FilterAllUnits ( [ [ f_side , 7 ] , [ f_nation , 1 ] , [ f_class , 4 ] , [ f_type , unit_human ] , [ f_sex , sex_male ] ] ) diff [ Roth , JMM , Burlak , Titov , Kuzmov , Kovalyuk ] ;
11788: LD_ADDR_VAR 0 1
11792: PUSH
11793: LD_INT 22
11795: PUSH
11796: LD_INT 7
11798: PUSH
11799: EMPTY
11800: LIST
11801: LIST
11802: PUSH
11803: LD_INT 23
11805: PUSH
11806: LD_INT 1
11808: PUSH
11809: EMPTY
11810: LIST
11811: LIST
11812: PUSH
11813: LD_INT 25
11815: PUSH
11816: LD_INT 4
11818: PUSH
11819: EMPTY
11820: LIST
11821: LIST
11822: PUSH
11823: LD_INT 21
11825: PUSH
11826: LD_INT 1
11828: PUSH
11829: EMPTY
11830: LIST
11831: LIST
11832: PUSH
11833: LD_INT 26
11835: PUSH
11836: LD_INT 1
11838: PUSH
11839: EMPTY
11840: LIST
11841: LIST
11842: PUSH
11843: EMPTY
11844: LIST
11845: LIST
11846: LIST
11847: LIST
11848: LIST
11849: PPUSH
11850: CALL_OW 69
11854: PUSH
11855: LD_EXP 15
11859: PUSH
11860: LD_EXP 14
11864: PUSH
11865: LD_EXP 46
11869: PUSH
11870: LD_EXP 34
11874: PUSH
11875: LD_EXP 44
11879: PUSH
11880: LD_EXP 43
11884: PUSH
11885: EMPTY
11886: LIST
11887: LIST
11888: LIST
11889: LIST
11890: LIST
11891: LIST
11892: DIFF
11893: ST_TO_ADDR
// if speaker then
11894: LD_VAR 0 1
11898: IFFALSE 11916
// Say ( speaker [ 1 ] , DArtefTechnology-Sci1-2 ) ;
11900: LD_VAR 0 1
11904: PUSH
11905: LD_INT 1
11907: ARRAY
11908: PPUSH
11909: LD_STRING DArtefTechnology-Sci1-2
11911: PPUSH
11912: CALL_OW 88
// speaker := FilterAllUnits ( [ [ f_side , 7 ] , [ f_nation , 3 ] , [ f_class , 4 ] , [ f_type , unit_human ] , [ f_sex , sex_male ] ] ) diff [ Roth , JMM , Burlak , Titov , Kuzmov , Kovalyuk ] ;
11916: LD_ADDR_VAR 0 1
11920: PUSH
11921: LD_INT 22
11923: PUSH
11924: LD_INT 7
11926: PUSH
11927: EMPTY
11928: LIST
11929: LIST
11930: PUSH
11931: LD_INT 23
11933: PUSH
11934: LD_INT 3
11936: PUSH
11937: EMPTY
11938: LIST
11939: LIST
11940: PUSH
11941: LD_INT 25
11943: PUSH
11944: LD_INT 4
11946: PUSH
11947: EMPTY
11948: LIST
11949: LIST
11950: PUSH
11951: LD_INT 21
11953: PUSH
11954: LD_INT 1
11956: PUSH
11957: EMPTY
11958: LIST
11959: LIST
11960: PUSH
11961: LD_INT 26
11963: PUSH
11964: LD_INT 1
11966: PUSH
11967: EMPTY
11968: LIST
11969: LIST
11970: PUSH
11971: EMPTY
11972: LIST
11973: LIST
11974: LIST
11975: LIST
11976: LIST
11977: PPUSH
11978: CALL_OW 69
11982: PUSH
11983: LD_EXP 15
11987: PUSH
11988: LD_EXP 14
11992: PUSH
11993: LD_EXP 46
11997: PUSH
11998: LD_EXP 34
12002: PUSH
12003: LD_EXP 44
12007: PUSH
12008: LD_EXP 43
12012: PUSH
12013: EMPTY
12014: LIST
12015: LIST
12016: LIST
12017: LIST
12018: LIST
12019: LIST
12020: DIFF
12021: ST_TO_ADDR
// if speaker and ( artifactArCaptured or arabianDestroyed ) then
12022: LD_VAR 0 1
12026: PUSH
12027: LD_EXP 6
12031: PUSH
12032: LD_EXP 5
12036: OR
12037: AND
12038: IFFALSE 12272
// begin if arabianDestroyed and IsOk ( Burlak ) then
12040: LD_EXP 5
12044: PUSH
12045: LD_EXP 46
12049: PPUSH
12050: CALL_OW 302
12054: AND
12055: IFFALSE 12071
// Say ( Burlak , DArtefTechnology-Bur-2 ) else
12057: LD_EXP 46
12061: PPUSH
12062: LD_STRING DArtefTechnology-Bur-2
12064: PPUSH
12065: CALL_OW 88
12069: GO 12083
// Say ( JMM , DArtefTechnology-JMM-2 ) ;
12071: LD_EXP 14
12075: PPUSH
12076: LD_STRING DArtefTechnology-JMM-2
12078: PPUSH
12079: CALL_OW 88
// Say ( speaker [ 1 ] , DArtefTechnology-RSci1-3 ) ;
12083: LD_VAR 0 1
12087: PUSH
12088: LD_INT 1
12090: ARRAY
12091: PPUSH
12092: LD_STRING DArtefTechnology-RSci1-3
12094: PPUSH
12095: CALL_OW 88
// if Denis then
12099: LD_EXP 20
12103: IFFALSE 12120
// speaker := [ Denis ] else
12105: LD_ADDR_VAR 0 1
12109: PUSH
12110: LD_EXP 20
12114: PUSH
12115: EMPTY
12116: LIST
12117: ST_TO_ADDR
12118: GO 12226
// speaker := FilterAllUnits ( [ [ f_side , 7 ] , [ f_nation , 1 ] , [ f_class , 4 ] , [ f_type , unit_human ] , [ f_sex , sex_male ] ] ) diff [ Roth , JMM , Burlak , Titov , Kuzmov , Kovalyuk ] ;
12120: LD_ADDR_VAR 0 1
12124: PUSH
12125: LD_INT 22
12127: PUSH
12128: LD_INT 7
12130: PUSH
12131: EMPTY
12132: LIST
12133: LIST
12134: PUSH
12135: LD_INT 23
12137: PUSH
12138: LD_INT 1
12140: PUSH
12141: EMPTY
12142: LIST
12143: LIST
12144: PUSH
12145: LD_INT 25
12147: PUSH
12148: LD_INT 4
12150: PUSH
12151: EMPTY
12152: LIST
12153: LIST
12154: PUSH
12155: LD_INT 21
12157: PUSH
12158: LD_INT 1
12160: PUSH
12161: EMPTY
12162: LIST
12163: LIST
12164: PUSH
12165: LD_INT 26
12167: PUSH
12168: LD_INT 1
12170: PUSH
12171: EMPTY
12172: LIST
12173: LIST
12174: PUSH
12175: EMPTY
12176: LIST
12177: LIST
12178: LIST
12179: LIST
12180: LIST
12181: PPUSH
12182: CALL_OW 69
12186: PUSH
12187: LD_EXP 15
12191: PUSH
12192: LD_EXP 14
12196: PUSH
12197: LD_EXP 46
12201: PUSH
12202: LD_EXP 34
12206: PUSH
12207: LD_EXP 44
12211: PUSH
12212: LD_EXP 43
12216: PUSH
12217: EMPTY
12218: LIST
12219: LIST
12220: LIST
12221: LIST
12222: LIST
12223: LIST
12224: DIFF
12225: ST_TO_ADDR
// if speaker then
12226: LD_VAR 0 1
12230: IFFALSE 12272
// if alienSpotted then
12232: LD_EXP 7
12236: IFFALSE 12256
// Say ( speaker [ 1 ] , DArtefTechnology-Sci1-3 ) else
12238: LD_VAR 0 1
12242: PUSH
12243: LD_INT 1
12245: ARRAY
12246: PPUSH
12247: LD_STRING DArtefTechnology-Sci1-3
12249: PPUSH
12250: CALL_OW 88
12254: GO 12272
// Say ( speaker [ 1 ] , DArtefTechnology-Sci1-3a ) ;
12256: LD_VAR 0 1
12260: PUSH
12261: LD_INT 1
12263: ARRAY
12264: PPUSH
12265: LD_STRING DArtefTechnology-Sci1-3a
12267: PPUSH
12268: CALL_OW 88
// end ; DialogueOff ;
12272: CALL_OW 7
// end ;
12276: PPOPN 1
12278: END
// every 0 0$1 trigger artifactIResearched do var speaker ;
12279: LD_EXP 9
12283: IFFALSE 12478
12285: GO 12287
12287: DISABLE
12288: LD_INT 0
12290: PPUSH
// begin if Denis then
12291: LD_EXP 20
12295: IFFALSE 12312
// speaker := [ Denis ] else
12297: LD_ADDR_VAR 0 1
12301: PUSH
12302: LD_EXP 20
12306: PUSH
12307: EMPTY
12308: LIST
12309: ST_TO_ADDR
12310: GO 12418
// speaker := FilterAllUnits ( [ [ f_side , 7 ] , [ f_nation , 1 ] , [ f_class , 4 ] , [ f_type , unit_human ] , [ f_sex , sex_male ] ] ) diff [ Roth , JMM , Burlak , Titov , Kuzmov , Kovalyuk ] ;
12312: LD_ADDR_VAR 0 1
12316: PUSH
12317: LD_INT 22
12319: PUSH
12320: LD_INT 7
12322: PUSH
12323: EMPTY
12324: LIST
12325: LIST
12326: PUSH
12327: LD_INT 23
12329: PUSH
12330: LD_INT 1
12332: PUSH
12333: EMPTY
12334: LIST
12335: LIST
12336: PUSH
12337: LD_INT 25
12339: PUSH
12340: LD_INT 4
12342: PUSH
12343: EMPTY
12344: LIST
12345: LIST
12346: PUSH
12347: LD_INT 21
12349: PUSH
12350: LD_INT 1
12352: PUSH
12353: EMPTY
12354: LIST
12355: LIST
12356: PUSH
12357: LD_INT 26
12359: PUSH
12360: LD_INT 1
12362: PUSH
12363: EMPTY
12364: LIST
12365: LIST
12366: PUSH
12367: EMPTY
12368: LIST
12369: LIST
12370: LIST
12371: LIST
12372: LIST
12373: PPUSH
12374: CALL_OW 69
12378: PUSH
12379: LD_EXP 15
12383: PUSH
12384: LD_EXP 14
12388: PUSH
12389: LD_EXP 46
12393: PUSH
12394: LD_EXP 34
12398: PUSH
12399: LD_EXP 44
12403: PUSH
12404: LD_EXP 43
12408: PUSH
12409: EMPTY
12410: LIST
12411: LIST
12412: LIST
12413: LIST
12414: LIST
12415: LIST
12416: DIFF
12417: ST_TO_ADDR
// if not speaker then
12418: LD_VAR 0 1
12422: NOT
12423: IFFALSE 12427
// exit ;
12425: GO 12478
// Say ( speaker [ 1 ] , DArtefTechnologyAm-Sci1-1 ) ;
12427: LD_VAR 0 1
12431: PUSH
12432: LD_INT 1
12434: ARRAY
12435: PPUSH
12436: LD_STRING DArtefTechnologyAm-Sci1-1
12438: PPUSH
12439: CALL_OW 88
// if IsOk ( Burlak ) then
12443: LD_EXP 46
12447: PPUSH
12448: CALL_OW 302
12452: IFFALSE 12466
// Say ( Burlak , DArtefTechnologyAm-Bur-1 ) ;
12454: LD_EXP 46
12458: PPUSH
12459: LD_STRING DArtefTechnologyAm-Bur-1
12461: PPUSH
12462: CALL_OW 88
// Say ( JMM , DArtefTechnologyAm-JMM-1 ) ;
12466: LD_EXP 14
12470: PPUSH
12471: LD_STRING DArtefTechnologyAm-JMM-1
12473: PPUSH
12474: CALL_OW 88
// end ;
12478: PPOPN 1
12480: END
// every 0 0$1 trigger artifactIIResearched do var speaker ;
12481: LD_EXP 10
12485: IFFALSE 12696
12487: GO 12489
12489: DISABLE
12490: LD_INT 0
12492: PPUSH
// begin if Denis then
12493: LD_EXP 20
12497: IFFALSE 12514
// speaker := [ Denis ] else
12499: LD_ADDR_VAR 0 1
12503: PUSH
12504: LD_EXP 20
12508: PUSH
12509: EMPTY
12510: LIST
12511: ST_TO_ADDR
12512: GO 12620
// speaker := FilterAllUnits ( [ [ f_side , 7 ] , [ f_nation , 3 ] , [ f_class , 4 ] , [ f_type , unit_human ] , [ f_sex , sex_male ] ] ) diff [ Roth , JMM , Burlak , Titov , Kuzmov , Kovalyuk ] ;
12514: LD_ADDR_VAR 0 1
12518: PUSH
12519: LD_INT 22
12521: PUSH
12522: LD_INT 7
12524: PUSH
12525: EMPTY
12526: LIST
12527: LIST
12528: PUSH
12529: LD_INT 23
12531: PUSH
12532: LD_INT 3
12534: PUSH
12535: EMPTY
12536: LIST
12537: LIST
12538: PUSH
12539: LD_INT 25
12541: PUSH
12542: LD_INT 4
12544: PUSH
12545: EMPTY
12546: LIST
12547: LIST
12548: PUSH
12549: LD_INT 21
12551: PUSH
12552: LD_INT 1
12554: PUSH
12555: EMPTY
12556: LIST
12557: LIST
12558: PUSH
12559: LD_INT 26
12561: PUSH
12562: LD_INT 1
12564: PUSH
12565: EMPTY
12566: LIST
12567: LIST
12568: PUSH
12569: EMPTY
12570: LIST
12571: LIST
12572: LIST
12573: LIST
12574: LIST
12575: PPUSH
12576: CALL_OW 69
12580: PUSH
12581: LD_EXP 15
12585: PUSH
12586: LD_EXP 14
12590: PUSH
12591: LD_EXP 46
12595: PUSH
12596: LD_EXP 34
12600: PUSH
12601: LD_EXP 44
12605: PUSH
12606: LD_EXP 43
12610: PUSH
12611: EMPTY
12612: LIST
12613: LIST
12614: LIST
12615: LIST
12616: LIST
12617: LIST
12618: DIFF
12619: ST_TO_ADDR
// if not speaker then
12620: LD_VAR 0 1
12624: NOT
12625: IFFALSE 12629
// exit ;
12627: GO 12696
// Say ( speaker [ 1 ] , DArtefTechnologyRu-RSci1-1 ) ;
12629: LD_VAR 0 1
12633: PUSH
12634: LD_INT 1
12636: ARRAY
12637: PPUSH
12638: LD_STRING DArtefTechnologyRu-RSci1-1
12640: PPUSH
12641: CALL_OW 88
// if IsOk ( Burlak ) then
12645: LD_EXP 46
12649: PPUSH
12650: CALL_OW 302
12654: IFFALSE 12668
// Say ( Burlak , DArtefTechnologyRu-Bur-1 ) ;
12656: LD_EXP 46
12660: PPUSH
12661: LD_STRING DArtefTechnologyRu-Bur-1
12663: PPUSH
12664: CALL_OW 88
// Say ( speaker [ 1 ] , DArtefTechnologyRu-RSci1-2 ) ;
12668: LD_VAR 0 1
12672: PUSH
12673: LD_INT 1
12675: ARRAY
12676: PPUSH
12677: LD_STRING DArtefTechnologyRu-RSci1-2
12679: PPUSH
12680: CALL_OW 88
// Say ( JMM , DArtefTechnologyRu-JMM-1 ) ;
12684: LD_EXP 14
12688: PPUSH
12689: LD_STRING DArtefTechnologyRu-JMM-1
12691: PPUSH
12692: CALL_OW 88
// end ;
12696: PPOPN 1
12698: END
// every 0 0$1 trigger GetTech ( tech_Artifact , 7 ) = state_researched and GetSide ( alien ) = 7 do var speaker ;
12699: LD_INT 24
12701: PPUSH
12702: LD_INT 7
12704: PPUSH
12705: CALL_OW 321
12709: PUSH
12710: LD_INT 2
12712: EQUAL
12713: PUSH
12714: LD_INT 1
12716: PPUSH
12717: CALL_OW 255
12721: PUSH
12722: LD_INT 7
12724: EQUAL
12725: AND
12726: IFFALSE 12886
12728: GO 12730
12730: DISABLE
12731: LD_INT 0
12733: PPUSH
// begin if Denis then
12734: LD_EXP 20
12738: IFFALSE 12755
// speaker := [ Denis ] else
12740: LD_ADDR_VAR 0 1
12744: PUSH
12745: LD_EXP 20
12749: PUSH
12750: EMPTY
12751: LIST
12752: ST_TO_ADDR
12753: GO 12861
// speaker := FilterAllUnits ( [ [ f_side , 7 ] , [ f_nation , 1 ] , [ f_class , 4 ] , [ f_type , unit_human ] , [ f_sex , sex_male ] ] ) diff [ Roth , JMM , Burlak , Titov , Kuzmov , Kovalyuk ] ;
12755: LD_ADDR_VAR 0 1
12759: PUSH
12760: LD_INT 22
12762: PUSH
12763: LD_INT 7
12765: PUSH
12766: EMPTY
12767: LIST
12768: LIST
12769: PUSH
12770: LD_INT 23
12772: PUSH
12773: LD_INT 1
12775: PUSH
12776: EMPTY
12777: LIST
12778: LIST
12779: PUSH
12780: LD_INT 25
12782: PUSH
12783: LD_INT 4
12785: PUSH
12786: EMPTY
12787: LIST
12788: LIST
12789: PUSH
12790: LD_INT 21
12792: PUSH
12793: LD_INT 1
12795: PUSH
12796: EMPTY
12797: LIST
12798: LIST
12799: PUSH
12800: LD_INT 26
12802: PUSH
12803: LD_INT 1
12805: PUSH
12806: EMPTY
12807: LIST
12808: LIST
12809: PUSH
12810: EMPTY
12811: LIST
12812: LIST
12813: LIST
12814: LIST
12815: LIST
12816: PPUSH
12817: CALL_OW 69
12821: PUSH
12822: LD_EXP 15
12826: PUSH
12827: LD_EXP 14
12831: PUSH
12832: LD_EXP 46
12836: PUSH
12837: LD_EXP 34
12841: PUSH
12842: LD_EXP 44
12846: PUSH
12847: LD_EXP 43
12851: PUSH
12852: EMPTY
12853: LIST
12854: LIST
12855: LIST
12856: LIST
12857: LIST
12858: LIST
12859: DIFF
12860: ST_TO_ADDR
// if not speaker then
12861: LD_VAR 0 1
12865: NOT
12866: IFFALSE 12870
// exit ;
12868: GO 12886
// Say ( speaker [ 1 ] , DArtefTechnologyArStart-Sci1-1 ) ;
12870: LD_VAR 0 1
12874: PUSH
12875: LD_INT 1
12877: ARRAY
12878: PPUSH
12879: LD_STRING DArtefTechnologyArStart-Sci1-1
12881: PPUSH
12882: CALL_OW 88
// end ;
12886: PPOPN 1
12888: END
// every 0 0$1 trigger artifactIIIResearched do var speaker ;
12889: LD_EXP 11
12893: IFFALSE 13174
12895: GO 12897
12897: DISABLE
12898: LD_INT 0
12900: PPUSH
// begin speaker := FilterAllUnits ( [ [ f_side , 7 ] , [ f_nation , 3 ] , [ f_class , 4 ] , [ f_type , unit_human ] , [ f_sex , sex_male ] ] ) diff [ Roth , JMM , Burlak , Titov , Kuzmov , Kovalyuk ] ;
12901: LD_ADDR_VAR 0 1
12905: PUSH
12906: LD_INT 22
12908: PUSH
12909: LD_INT 7
12911: PUSH
12912: EMPTY
12913: LIST
12914: LIST
12915: PUSH
12916: LD_INT 23
12918: PUSH
12919: LD_INT 3
12921: PUSH
12922: EMPTY
12923: LIST
12924: LIST
12925: PUSH
12926: LD_INT 25
12928: PUSH
12929: LD_INT 4
12931: PUSH
12932: EMPTY
12933: LIST
12934: LIST
12935: PUSH
12936: LD_INT 21
12938: PUSH
12939: LD_INT 1
12941: PUSH
12942: EMPTY
12943: LIST
12944: LIST
12945: PUSH
12946: LD_INT 26
12948: PUSH
12949: LD_INT 1
12951: PUSH
12952: EMPTY
12953: LIST
12954: LIST
12955: PUSH
12956: EMPTY
12957: LIST
12958: LIST
12959: LIST
12960: LIST
12961: LIST
12962: PPUSH
12963: CALL_OW 69
12967: PUSH
12968: LD_EXP 15
12972: PUSH
12973: LD_EXP 14
12977: PUSH
12978: LD_EXP 46
12982: PUSH
12983: LD_EXP 34
12987: PUSH
12988: LD_EXP 44
12992: PUSH
12993: LD_EXP 43
12997: PUSH
12998: EMPTY
12999: LIST
13000: LIST
13001: LIST
13002: LIST
13003: LIST
13004: LIST
13005: DIFF
13006: ST_TO_ADDR
// if not speaker then
13007: LD_VAR 0 1
13011: NOT
13012: IFFALSE 13016
// exit ;
13014: GO 13174
// DialogueOn ;
13016: CALL_OW 6
// Say ( speaker [ 1 ] , DArtefTechnologyAr-RSci1-1 ) ;
13020: LD_VAR 0 1
13024: PUSH
13025: LD_INT 1
13027: ARRAY
13028: PPUSH
13029: LD_STRING DArtefTechnologyAr-RSci1-1
13031: PPUSH
13032: CALL_OW 88
// Say ( JMM , DArtefTechnologyAr-JMM-1 ) ;
13036: LD_EXP 14
13040: PPUSH
13041: LD_STRING DArtefTechnologyAr-JMM-1
13043: PPUSH
13044: CALL_OW 88
// Say ( speaker [ 1 ] , DArtefTechnologyAr-RSci1-2 ) ;
13048: LD_VAR 0 1
13052: PUSH
13053: LD_INT 1
13055: ARRAY
13056: PPUSH
13057: LD_STRING DArtefTechnologyAr-RSci1-2
13059: PPUSH
13060: CALL_OW 88
// Say ( JMM , DArtefTechnologyAr-JMM-2 ) ;
13064: LD_EXP 14
13068: PPUSH
13069: LD_STRING DArtefTechnologyAr-JMM-2
13071: PPUSH
13072: CALL_OW 88
// Say ( speaker [ 1 ] , DArtefTechnologyAr-RSci1-3 ) ;
13076: LD_VAR 0 1
13080: PUSH
13081: LD_INT 1
13083: ARRAY
13084: PPUSH
13085: LD_STRING DArtefTechnologyAr-RSci1-3
13087: PPUSH
13088: CALL_OW 88
// Say ( JMM , DArtefTechnologyAr-JMM-3 ) ;
13092: LD_EXP 14
13096: PPUSH
13097: LD_STRING DArtefTechnologyAr-JMM-3
13099: PPUSH
13100: CALL_OW 88
// Say ( speaker [ 1 ] , DArtefTechnologyAr-RSci1-4 ) ;
13104: LD_VAR 0 1
13108: PUSH
13109: LD_INT 1
13111: ARRAY
13112: PPUSH
13113: LD_STRING DArtefTechnologyAr-RSci1-4
13115: PPUSH
13116: CALL_OW 88
// if IsOk ( Burlak ) then
13120: LD_EXP 46
13124: PPUSH
13125: CALL_OW 302
13129: IFFALSE 13143
// Say ( Burlak , DArtefTechnologyAr-Bur-4 ) ;
13131: LD_EXP 46
13135: PPUSH
13136: LD_STRING DArtefTechnologyAr-Bur-4
13138: PPUSH
13139: CALL_OW 88
// Say ( JMM , DArtefTechnologyAr-JMM-4 ) ;
13143: LD_EXP 14
13147: PPUSH
13148: LD_STRING DArtefTechnologyAr-JMM-4
13150: PPUSH
13151: CALL_OW 88
// DialogueOff ;
13155: CALL_OW 7
// wait ( 0 0$45 ) ;
13159: LD_INT 1575
13161: PPUSH
13162: CALL_OW 67
// spawnOmar := true ;
13166: LD_ADDR_EXP 8
13170: PUSH
13171: LD_INT 1
13173: ST_TO_ADDR
// end ;
13174: PPOPN 1
13176: END
// every 0 0$1 trigger spawnOmar do
13177: LD_EXP 8
13181: IFFALSE 13486
13183: GO 13185
13185: DISABLE
// begin PrepareOmarAli ;
13186: CALL 6659 0 0
// if not Omar then
13190: LD_EXP 50
13194: NOT
13195: IFFALSE 13199
// exit ;
13197: GO 13486
// repeat wait ( 0 0$1 ) ;
13199: LD_INT 35
13201: PPUSH
13202: CALL_OW 67
// until See ( 7 , Omar ) ;
13206: LD_INT 7
13208: PPUSH
13209: LD_EXP 50
13213: PPUSH
13214: CALL_OW 292
13218: IFFALSE 13199
// CenterNowOnUnits ( Omar ) ;
13220: LD_EXP 50
13224: PPUSH
13225: CALL_OW 87
// DialogueOn ;
13229: CALL_OW 6
// Say ( Omar , DOmar-Omar-1 ) ;
13233: LD_EXP 50
13237: PPUSH
13238: LD_STRING DOmar-Omar-1
13240: PPUSH
13241: CALL_OW 88
// Say ( JMM , DOmar-JMM-1 ) ;
13245: LD_EXP 14
13249: PPUSH
13250: LD_STRING DOmar-JMM-1
13252: PPUSH
13253: CALL_OW 88
// Say ( Omar , DOmar-Omar-2 ) ;
13257: LD_EXP 50
13261: PPUSH
13262: LD_STRING DOmar-Omar-2
13264: PPUSH
13265: CALL_OW 88
// Say ( JMM , DOmar-JMM-2 ) ;
13269: LD_EXP 14
13273: PPUSH
13274: LD_STRING DOmar-JMM-2
13276: PPUSH
13277: CALL_OW 88
// Say ( Omar , DOmar-Omar-3 ) ;
13281: LD_EXP 50
13285: PPUSH
13286: LD_STRING DOmar-Omar-3
13288: PPUSH
13289: CALL_OW 88
// if IsOk ( Burlak ) then
13293: LD_EXP 46
13297: PPUSH
13298: CALL_OW 302
13302: IFFALSE 13318
// Say ( Burlak , DOmar-Bur-3 ) else
13304: LD_EXP 46
13308: PPUSH
13309: LD_STRING DOmar-Bur-3
13311: PPUSH
13312: CALL_OW 88
13316: GO 13330
// Say ( JMM , DOmar-JMM-3 ) ;
13318: LD_EXP 14
13322: PPUSH
13323: LD_STRING DOmar-JMM-3
13325: PPUSH
13326: CALL_OW 88
// Say ( Omar , DOmar-Omar-4 ) ;
13330: LD_EXP 50
13334: PPUSH
13335: LD_STRING DOmar-Omar-4
13337: PPUSH
13338: CALL_OW 88
// case Query ( QAccept ) of 1 :
13342: LD_STRING QAccept
13344: PPUSH
13345: CALL_OW 97
13349: PUSH
13350: LD_INT 1
13352: DOUBLE
13353: EQUAL
13354: IFTRUE 13358
13356: GO 13394
13358: POP
// begin Say ( JMM , DQrAccept#1-JMM-1 ) ;
13359: LD_EXP 14
13363: PPUSH
13364: LD_STRING DQrAccept#1-JMM-1
13366: PPUSH
13367: CALL_OW 88
// SetSide ( Omar , 7 ) ;
13371: LD_EXP 50
13375: PPUSH
13376: LD_INT 7
13378: PPUSH
13379: CALL_OW 235
// ComStop ( Omar ) ;
13383: LD_EXP 50
13387: PPUSH
13388: CALL_OW 141
// end ; 2 :
13392: GO 13443
13394: LD_INT 2
13396: DOUBLE
13397: EQUAL
13398: IFTRUE 13402
13400: GO 13442
13402: POP
// begin if IsOk ( Burlak ) then
13403: LD_EXP 46
13407: PPUSH
13408: CALL_OW 302
13412: IFFALSE 13428
// Say ( Burlak , DQrAccept#2-Bur-1 ) else
13414: LD_EXP 46
13418: PPUSH
13419: LD_STRING DQrAccept#2-Bur-1
13421: PPUSH
13422: CALL_OW 88
13426: GO 13440
// Say ( JMM , DQrAccept#2-JMM-1 ) ;
13428: LD_EXP 14
13432: PPUSH
13433: LD_STRING DQrAccept#2-JMM-1
13435: PPUSH
13436: CALL_OW 88
// end ; end ;
13440: GO 13443
13442: POP
// DialogueOff ;
13443: CALL_OW 7
// if GetSide ( Omar ) = 7 then
13447: LD_EXP 50
13451: PPUSH
13452: CALL_OW 255
13456: PUSH
13457: LD_INT 7
13459: EQUAL
13460: IFFALSE 13471
// begin SetAchievement ( ACH_OMAR ) ;
13462: LD_STRING ACH_OMAR
13464: PPUSH
13465: CALL_OW 543
// exit ;
13469: GO 13486
// end ; ComMoveXY ( Omar , 202 , 115 ) ;
13471: LD_EXP 50
13475: PPUSH
13476: LD_INT 202
13478: PPUSH
13479: LD_INT 115
13481: PPUSH
13482: CALL_OW 111
// end ;
13486: END
// every 0 0$1 trigger GetDistUnitXY ( Omar , 200 , 98 ) < 40 and russianDestroyed do
13487: LD_EXP 50
13491: PPUSH
13492: LD_INT 200
13494: PPUSH
13495: LD_INT 98
13497: PPUSH
13498: CALL_OW 297
13502: PUSH
13503: LD_INT 40
13505: LESS
13506: PUSH
13507: LD_EXP 2
13511: AND
13512: IFFALSE 13730
13514: GO 13516
13516: DISABLE
// begin SetSide ( Omar , 5 ) ;
13517: LD_EXP 50
13521: PPUSH
13522: LD_INT 5
13524: PPUSH
13525: CALL_OW 235
// if IsInUnit ( Omar ) then
13529: LD_EXP 50
13533: PPUSH
13534: CALL_OW 310
13538: IFFALSE 13549
// ComExitVehicle ( Omar ) ;
13540: LD_EXP 50
13544: PPUSH
13545: CALL_OW 121
// if IsInUnit ( Omar ) then
13549: LD_EXP 50
13553: PPUSH
13554: CALL_OW 310
13558: IFFALSE 13569
// ComExitBuilding ( Omar ) ;
13560: LD_EXP 50
13564: PPUSH
13565: CALL_OW 122
// wait ( 0 0$1 ) ;
13569: LD_INT 35
13571: PPUSH
13572: CALL_OW 67
// ComMoveXY ( Omar , 203 , 120 ) ;
13576: LD_EXP 50
13580: PPUSH
13581: LD_INT 203
13583: PPUSH
13584: LD_INT 120
13586: PPUSH
13587: CALL_OW 111
// repeat wait ( 0 0$1 ) ;
13591: LD_INT 35
13593: PPUSH
13594: CALL_OW 67
// until IsSelected ( Omar ) or GetDistUnitXY ( Omar , 203 , 120 ) < 6 ;
13598: LD_EXP 50
13602: PPUSH
13603: CALL_OW 306
13607: PUSH
13608: LD_EXP 50
13612: PPUSH
13613: LD_INT 203
13615: PPUSH
13616: LD_INT 120
13618: PPUSH
13619: CALL_OW 297
13623: PUSH
13624: LD_INT 6
13626: LESS
13627: OR
13628: IFFALSE 13591
// CenterNowOnUnits ( Omar ) ;
13630: LD_EXP 50
13634: PPUSH
13635: CALL_OW 87
// DialogueOn ;
13639: CALL_OW 6
// Say ( JMM , DOmarContam-JMM-1 ) ;
13643: LD_EXP 14
13647: PPUSH
13648: LD_STRING DOmarContam-JMM-1
13650: PPUSH
13651: CALL_OW 88
// Say ( Omar , DOmarContam-Omar-1 ) ;
13655: LD_EXP 50
13659: PPUSH
13660: LD_STRING DOmarContam-Omar-1
13662: PPUSH
13663: CALL_OW 88
// Say ( JMM , DOmarContam-JMM-2 ) ;
13667: LD_EXP 14
13671: PPUSH
13672: LD_STRING DOmarContam-JMM-2
13674: PPUSH
13675: CALL_OW 88
// DialogueOff ;
13679: CALL_OW 7
// SetAttitude ( 5 , 7 , att_enemy , true ) ;
13683: LD_INT 5
13685: PPUSH
13686: LD_INT 7
13688: PPUSH
13689: LD_INT 2
13691: PPUSH
13692: LD_INT 1
13694: PPUSH
13695: CALL_OW 80
// repeat wait ( 0 0$3 ) ;
13699: LD_INT 105
13701: PPUSH
13702: CALL_OW 67
// until IsAt ( Omar , 203 , 120 ) ;
13706: LD_EXP 50
13710: PPUSH
13711: LD_INT 203
13713: PPUSH
13714: LD_INT 120
13716: PPUSH
13717: CALL_OW 307
13721: IFFALSE 13699
// YouLost ( MothContaminate ) ;
13723: LD_STRING MothContaminate
13725: PPUSH
13726: CALL_OW 104
// end ;
13730: END
// every 0 0$2 trigger not americanDestroyed and FilterAllUnits ( [ [ f_side , 1 ] , [ f_weapon , us_siberium_rocket ] ] ) do
13731: LD_EXP 4
13735: NOT
13736: PUSH
13737: LD_INT 22
13739: PUSH
13740: LD_INT 1
13742: PUSH
13743: EMPTY
13744: LIST
13745: LIST
13746: PUSH
13747: LD_INT 34
13749: PUSH
13750: LD_INT 8
13752: PUSH
13753: EMPTY
13754: LIST
13755: LIST
13756: PUSH
13757: EMPTY
13758: LIST
13759: LIST
13760: PPUSH
13761: CALL_OW 69
13765: AND
13766: IFFALSE 13847
13768: GO 13770
13770: DISABLE
// begin if not IsOk ( Powell ) then
13771: LD_EXP 49
13775: PPUSH
13776: CALL_OW 302
13780: NOT
13781: IFFALSE 13785
// exit ;
13783: GO 13847
// DialogueOn ;
13785: CALL_OW 6
// SayRadio ( Powell , DWinAmericans-Pow-1 ) ;
13789: LD_EXP 49
13793: PPUSH
13794: LD_STRING DWinAmericans-Pow-1
13796: PPUSH
13797: CALL_OW 94
// if IsOk ( Burlak ) then
13801: LD_EXP 46
13805: PPUSH
13806: CALL_OW 302
13810: IFFALSE 13824
// Say ( Burlak , DWinAmericans-Bur-1 ) ;
13812: LD_EXP 46
13816: PPUSH
13817: LD_STRING DWinAmericans-Bur-1
13819: PPUSH
13820: CALL_OW 88
// Say ( JMM , DWinAmericans-JMM-1 ) ;
13824: LD_EXP 14
13828: PPUSH
13829: LD_STRING DWinAmericans-JMM-1
13831: PPUSH
13832: CALL_OW 88
// DialogueOff ;
13836: CALL_OW 7
// YouLost ( AmBomb ) ;
13840: LD_STRING AmBomb
13842: PPUSH
13843: CALL_OW 104
// end ;
13847: END
// every 0 0$2 trigger not russianDestroyed and FilterAllUnits ( [ [ f_side , 3 ] , [ f_weapon , ru_siberium_rocket ] ] ) do
13848: LD_EXP 2
13852: NOT
13853: PUSH
13854: LD_INT 22
13856: PUSH
13857: LD_INT 3
13859: PUSH
13860: EMPTY
13861: LIST
13862: LIST
13863: PUSH
13864: LD_INT 34
13866: PUSH
13867: LD_INT 48
13869: PUSH
13870: EMPTY
13871: LIST
13872: LIST
13873: PUSH
13874: EMPTY
13875: LIST
13876: LIST
13877: PPUSH
13878: CALL_OW 69
13882: AND
13883: IFFALSE 13964
13885: GO 13887
13887: DISABLE
// begin if not IsOk ( Platonov ) then
13888: LD_EXP 53
13892: PPUSH
13893: CALL_OW 302
13897: NOT
13898: IFFALSE 13902
// exit ;
13900: GO 13964
// DialogueOn ;
13902: CALL_OW 6
// SayRadio ( Platonov , DWinRussians-Pla-1 ) ;
13906: LD_EXP 53
13910: PPUSH
13911: LD_STRING DWinRussians-Pla-1
13913: PPUSH
13914: CALL_OW 94
// if IsOk ( Burlak ) then
13918: LD_EXP 46
13922: PPUSH
13923: CALL_OW 302
13927: IFFALSE 13941
// Say ( Burlak , DWinRussians-Bur-1 ) ;
13929: LD_EXP 46
13933: PPUSH
13934: LD_STRING DWinRussians-Bur-1
13936: PPUSH
13937: CALL_OW 88
// Say ( JMM , DWinRussians-JMM-1 ) ;
13941: LD_EXP 14
13945: PPUSH
13946: LD_STRING DWinRussians-JMM-1
13948: PPUSH
13949: CALL_OW 88
// DialogueOff ;
13953: CALL_OW 7
// YouLost ( RuBomb ) ;
13957: LD_STRING RuBomb
13959: PPUSH
13960: CALL_OW 104
// end ;
13964: END
// every 0 0$20 trigger FilterUnitsInArea ( powellBase , [ f_side , 7 ] ) and not americanDestroyed do
13965: LD_INT 7
13967: PPUSH
13968: LD_INT 22
13970: PUSH
13971: LD_INT 7
13973: PUSH
13974: EMPTY
13975: LIST
13976: LIST
13977: PPUSH
13978: CALL_OW 70
13982: PUSH
13983: LD_EXP 4
13987: NOT
13988: AND
13989: IFFALSE 14018
13991: GO 13993
13993: DISABLE
// begin SayRadio ( Powell , DSurrenderAmericans-Pow-1 ) ;
13994: LD_EXP 49
13998: PPUSH
13999: LD_STRING DSurrenderAmericans-Pow-1
14001: PPUSH
14002: CALL_OW 94
// Say ( JMM , DSurrenderAmericans-JMM-1 ) ;
14006: LD_EXP 14
14010: PPUSH
14011: LD_STRING DSurrenderAmericans-JMM-1
14013: PPUSH
14014: CALL_OW 88
// end ;
14018: END
// every 0 0$20 trigger FilterUnitsInArea ( russianBaseArea , [ f_side , 7 ] ) and not russianDestroyed and Burlak do
14019: LD_INT 2
14021: PPUSH
14022: LD_INT 22
14024: PUSH
14025: LD_INT 7
14027: PUSH
14028: EMPTY
14029: LIST
14030: LIST
14031: PPUSH
14032: CALL_OW 70
14036: PUSH
14037: LD_EXP 2
14041: NOT
14042: AND
14043: PUSH
14044: LD_EXP 46
14048: AND
14049: IFFALSE 14078
14051: GO 14053
14053: DISABLE
// begin SayRadio ( Platonov , DSurrenderRussians-Pla-1 ) ;
14054: LD_EXP 53
14058: PPUSH
14059: LD_STRING DSurrenderRussians-Pla-1
14061: PPUSH
14062: CALL_OW 94
// Say ( Burlak , DSurrenderRussians-Bur-1 ) ;
14066: LD_EXP 46
14070: PPUSH
14071: LD_STRING DSurrenderRussians-Bur-1
14073: PPUSH
14074: CALL_OW 88
// end ;
14078: END
// every 0 0$2 + 0 0$5 trigger americanDestroyed do var i , tmp , speaker ;
14079: LD_EXP 4
14083: IFFALSE 14458
14085: GO 14087
14087: DISABLE
14088: LD_INT 0
14090: PPUSH
14091: PPUSH
14092: PPUSH
// begin MC_Kill ( 4 ) ;
14093: LD_INT 4
14095: PPUSH
14096: CALL 20603 0 1
// SetAttitude ( 1 , 7 , att_friend , true ) ;
14100: LD_INT 1
14102: PPUSH
14103: LD_INT 7
14105: PPUSH
14106: LD_INT 1
14108: PPUSH
14109: LD_INT 1
14111: PPUSH
14112: CALL_OW 80
// speaker := FilterAllUnits ( [ [ f_side , 1 ] , [ f_sex , sex_male ] , [ f_nation , 1 ] ] ) diff [ Powell , Gladstone , Cyrus , Bobby , Gary , Houten ] ;
14116: LD_ADDR_VAR 0 3
14120: PUSH
14121: LD_INT 22
14123: PUSH
14124: LD_INT 1
14126: PUSH
14127: EMPTY
14128: LIST
14129: LIST
14130: PUSH
14131: LD_INT 26
14133: PUSH
14134: LD_INT 1
14136: PUSH
14137: EMPTY
14138: LIST
14139: LIST
14140: PUSH
14141: LD_INT 23
14143: PUSH
14144: LD_INT 1
14146: PUSH
14147: EMPTY
14148: LIST
14149: LIST
14150: PUSH
14151: EMPTY
14152: LIST
14153: LIST
14154: LIST
14155: PPUSH
14156: CALL_OW 69
14160: PUSH
14161: LD_EXP 49
14165: PUSH
14166: LD_EXP 22
14170: PUSH
14171: LD_EXP 19
14175: PUSH
14176: LD_EXP 18
14180: PUSH
14181: LD_EXP 25
14185: PUSH
14186: LD_EXP 23
14190: PUSH
14191: EMPTY
14192: LIST
14193: LIST
14194: LIST
14195: LIST
14196: LIST
14197: LIST
14198: DIFF
14199: ST_TO_ADDR
// if speaker then
14200: LD_VAR 0 3
14204: IFFALSE 14230
// begin DialogueOn ;
14206: CALL_OW 6
// SayRadio ( speaker [ 1 ] , DSurrenderAmericans-Sol1-1a ) ;
14210: LD_VAR 0 3
14214: PUSH
14215: LD_INT 1
14217: ARRAY
14218: PPUSH
14219: LD_STRING DSurrenderAmericans-Sol1-1a
14221: PPUSH
14222: CALL_OW 94
// DialogueOff ;
14226: CALL_OW 7
// end ; tmp := FilterAllUnits ( [ [ f_side , 1 ] , [ f_type , unit_human ] ] ) ^ FilterAllUnits ( [ [ f_side , 1 ] , [ f_type , unit_vehicle ] , [ control_manual ] ] ) ;
14230: LD_ADDR_VAR 0 2
14234: PUSH
14235: LD_INT 22
14237: PUSH
14238: LD_INT 1
14240: PUSH
14241: EMPTY
14242: LIST
14243: LIST
14244: PUSH
14245: LD_INT 21
14247: PUSH
14248: LD_INT 1
14250: PUSH
14251: EMPTY
14252: LIST
14253: LIST
14254: PUSH
14255: EMPTY
14256: LIST
14257: LIST
14258: PPUSH
14259: CALL_OW 69
14263: PUSH
14264: LD_INT 22
14266: PUSH
14267: LD_INT 1
14269: PUSH
14270: EMPTY
14271: LIST
14272: LIST
14273: PUSH
14274: LD_INT 21
14276: PUSH
14277: LD_INT 2
14279: PUSH
14280: EMPTY
14281: LIST
14282: LIST
14283: PUSH
14284: LD_INT 1
14286: PUSH
14287: EMPTY
14288: LIST
14289: PUSH
14290: EMPTY
14291: LIST
14292: LIST
14293: LIST
14294: PPUSH
14295: CALL_OW 69
14299: ADD
14300: ST_TO_ADDR
// if tmp then
14301: LD_VAR 0 2
14305: IFFALSE 14458
// repeat wait ( 0 0$1 ) ;
14307: LD_INT 35
14309: PPUSH
14310: CALL_OW 67
// for i in tmp do
14314: LD_ADDR_VAR 0 1
14318: PUSH
14319: LD_VAR 0 2
14323: PUSH
14324: FOR_IN
14325: IFFALSE 14407
// begin if IsInUnit ( i ) and GetType ( IsInUnit ( i ) ) = unit_building then
14327: LD_VAR 0 1
14331: PPUSH
14332: CALL_OW 310
14336: PUSH
14337: LD_VAR 0 1
14341: PPUSH
14342: CALL_OW 310
14346: PPUSH
14347: CALL_OW 247
14351: PUSH
14352: LD_INT 3
14354: EQUAL
14355: AND
14356: IFFALSE 14367
// ComExitBuilding ( i ) ;
14358: LD_VAR 0 1
14362: PPUSH
14363: CALL_OW 122
// AddComMoveXY ( i , 122 , 242 ) ;
14367: LD_VAR 0 1
14371: PPUSH
14372: LD_INT 122
14374: PPUSH
14375: LD_INT 242
14377: PPUSH
14378: CALL_OW 171
// if IsInArea ( i , americanEscape ) then
14382: LD_VAR 0 1
14386: PPUSH
14387: LD_INT 35
14389: PPUSH
14390: CALL_OW 308
14394: IFFALSE 14405
// RemoveUnit ( i ) ;
14396: LD_VAR 0 1
14400: PPUSH
14401: CALL_OW 64
// end ;
14405: GO 14324
14407: POP
14408: POP
// until not FilterAllUnits ( [ [ f_side , 1 ] , [ f_or , [ f_type , unit_human ] , [ f_control , control_manual ] ] ] ) ;
14409: LD_INT 22
14411: PUSH
14412: LD_INT 1
14414: PUSH
14415: EMPTY
14416: LIST
14417: LIST
14418: PUSH
14419: LD_INT 2
14421: PUSH
14422: LD_INT 21
14424: PUSH
14425: LD_INT 1
14427: PUSH
14428: EMPTY
14429: LIST
14430: LIST
14431: PUSH
14432: LD_INT 33
14434: PUSH
14435: LD_INT 1
14437: PUSH
14438: EMPTY
14439: LIST
14440: LIST
14441: PUSH
14442: EMPTY
14443: LIST
14444: LIST
14445: LIST
14446: PUSH
14447: EMPTY
14448: LIST
14449: LIST
14450: PPUSH
14451: CALL_OW 69
14455: NOT
14456: IFFALSE 14307
// end ;
14458: PPOPN 3
14460: END
// every 0 0$2 + 0 0$5 trigger russianDestroyed do var i , tmp , speaker ;
14461: LD_EXP 2
14465: IFFALSE 14858
14467: GO 14469
14469: DISABLE
14470: LD_INT 0
14472: PPUSH
14473: PPUSH
14474: PPUSH
// begin repeat wait ( 0 0$1 ) ;
14475: LD_INT 35
14477: PPUSH
14478: CALL_OW 67
// until IsDead ( Yakotich ) ;
14482: LD_EXP 54
14486: PPUSH
14487: CALL_OW 301
14491: IFFALSE 14475
// MC_Kill ( 2 ) ;
14493: LD_INT 2
14495: PPUSH
14496: CALL 20603 0 1
// SetAttitude ( 3 , 7 , att_friend , true ) ;
14500: LD_INT 3
14502: PPUSH
14503: LD_INT 7
14505: PPUSH
14506: LD_INT 1
14508: PPUSH
14509: LD_INT 1
14511: PPUSH
14512: CALL_OW 80
// speaker := FilterAllUnits ( [ [ f_side , 3 ] , [ f_sex , sex_male ] , [ f_nation , 3 ] ] ) diff [ Platonov , Yakotich ] ;
14516: LD_ADDR_VAR 0 3
14520: PUSH
14521: LD_INT 22
14523: PUSH
14524: LD_INT 3
14526: PUSH
14527: EMPTY
14528: LIST
14529: LIST
14530: PUSH
14531: LD_INT 26
14533: PUSH
14534: LD_INT 1
14536: PUSH
14537: EMPTY
14538: LIST
14539: LIST
14540: PUSH
14541: LD_INT 23
14543: PUSH
14544: LD_INT 3
14546: PUSH
14547: EMPTY
14548: LIST
14549: LIST
14550: PUSH
14551: EMPTY
14552: LIST
14553: LIST
14554: LIST
14555: PPUSH
14556: CALL_OW 69
14560: PUSH
14561: LD_EXP 53
14565: PUSH
14566: LD_EXP 54
14570: PUSH
14571: EMPTY
14572: LIST
14573: LIST
14574: DIFF
14575: ST_TO_ADDR
// if speaker then
14576: LD_VAR 0 3
14580: IFFALSE 14630
// begin DialogueOn ;
14582: CALL_OW 6
// if Burlak then
14586: LD_EXP 46
14590: IFFALSE 14610
// SayRadio ( speaker [ 1 ] , DSurrenderRussians-RSol1-1 ) else
14592: LD_VAR 0 3
14596: PUSH
14597: LD_INT 1
14599: ARRAY
14600: PPUSH
14601: LD_STRING DSurrenderRussians-RSol1-1
14603: PPUSH
14604: CALL_OW 94
14608: GO 14626
// SayRadio ( speaker [ 1 ] , DSurrenderRussians-RSol1-1a ) ;
14610: LD_VAR 0 3
14614: PUSH
14615: LD_INT 1
14617: ARRAY
14618: PPUSH
14619: LD_STRING DSurrenderRussians-RSol1-1a
14621: PPUSH
14622: CALL_OW 94
// DialogueOff ;
14626: CALL_OW 7
// end ; tmp := FilterAllUnits ( [ [ f_side , 3 ] , [ f_type , unit_human ] ] ) ^ FilterAllUnits ( [ [ f_side , 3 ] , [ f_type , unit_vehicle ] , [ control_manual ] ] ) ;
14630: LD_ADDR_VAR 0 2
14634: PUSH
14635: LD_INT 22
14637: PUSH
14638: LD_INT 3
14640: PUSH
14641: EMPTY
14642: LIST
14643: LIST
14644: PUSH
14645: LD_INT 21
14647: PUSH
14648: LD_INT 1
14650: PUSH
14651: EMPTY
14652: LIST
14653: LIST
14654: PUSH
14655: EMPTY
14656: LIST
14657: LIST
14658: PPUSH
14659: CALL_OW 69
14663: PUSH
14664: LD_INT 22
14666: PUSH
14667: LD_INT 3
14669: PUSH
14670: EMPTY
14671: LIST
14672: LIST
14673: PUSH
14674: LD_INT 21
14676: PUSH
14677: LD_INT 2
14679: PUSH
14680: EMPTY
14681: LIST
14682: LIST
14683: PUSH
14684: LD_INT 1
14686: PUSH
14687: EMPTY
14688: LIST
14689: PUSH
14690: EMPTY
14691: LIST
14692: LIST
14693: LIST
14694: PPUSH
14695: CALL_OW 69
14699: ADD
14700: ST_TO_ADDR
// if tmp then
14701: LD_VAR 0 2
14705: IFFALSE 14858
// repeat wait ( 0 0$1 ) ;
14707: LD_INT 35
14709: PPUSH
14710: CALL_OW 67
// for i in tmp do
14714: LD_ADDR_VAR 0 1
14718: PUSH
14719: LD_VAR 0 2
14723: PUSH
14724: FOR_IN
14725: IFFALSE 14807
// begin if IsInUnit ( i ) and GetType ( IsInUnit ( i ) ) = unit_building then
14727: LD_VAR 0 1
14731: PPUSH
14732: CALL_OW 310
14736: PUSH
14737: LD_VAR 0 1
14741: PPUSH
14742: CALL_OW 310
14746: PPUSH
14747: CALL_OW 247
14751: PUSH
14752: LD_INT 3
14754: EQUAL
14755: AND
14756: IFFALSE 14767
// ComExitBuilding ( i ) ;
14758: LD_VAR 0 1
14762: PPUSH
14763: CALL_OW 122
// AddComMoveXY ( i , 154 , 1 ) ;
14767: LD_VAR 0 1
14771: PPUSH
14772: LD_INT 154
14774: PPUSH
14775: LD_INT 1
14777: PPUSH
14778: CALL_OW 171
// if IsInArea ( i , russianEscape ) then
14782: LD_VAR 0 1
14786: PPUSH
14787: LD_INT 36
14789: PPUSH
14790: CALL_OW 308
14794: IFFALSE 14805
// RemoveUnit ( i ) ;
14796: LD_VAR 0 1
14800: PPUSH
14801: CALL_OW 64
// end ;
14805: GO 14724
14807: POP
14808: POP
// until not FilterAllUnits ( [ [ f_side , 3 ] , [ f_or , [ f_type , unit_human ] , [ f_control , control_manual ] ] ] ) ;
14809: LD_INT 22
14811: PUSH
14812: LD_INT 3
14814: PUSH
14815: EMPTY
14816: LIST
14817: LIST
14818: PUSH
14819: LD_INT 2
14821: PUSH
14822: LD_INT 21
14824: PUSH
14825: LD_INT 1
14827: PUSH
14828: EMPTY
14829: LIST
14830: LIST
14831: PUSH
14832: LD_INT 33
14834: PUSH
14835: LD_INT 1
14837: PUSH
14838: EMPTY
14839: LIST
14840: LIST
14841: PUSH
14842: EMPTY
14843: LIST
14844: LIST
14845: LIST
14846: PUSH
14847: EMPTY
14848: LIST
14849: LIST
14850: PPUSH
14851: CALL_OW 69
14855: NOT
14856: IFFALSE 14707
// end ;
14858: PPOPN 3
14860: END
// every 0 0$3 trigger FilterAllUnits ( [ [ f_side , 8 ] , [ f_type , unit_human ] , [ f_nation , 2 ] ] ) < 18 or IsDead ( Kozlov ) or GetSide ( ar_depot1 ) = 7 do
14861: LD_INT 22
14863: PUSH
14864: LD_INT 8
14866: PUSH
14867: EMPTY
14868: LIST
14869: LIST
14870: PUSH
14871: LD_INT 21
14873: PUSH
14874: LD_INT 1
14876: PUSH
14877: EMPTY
14878: LIST
14879: LIST
14880: PUSH
14881: LD_INT 23
14883: PUSH
14884: LD_INT 2
14886: PUSH
14887: EMPTY
14888: LIST
14889: LIST
14890: PUSH
14891: EMPTY
14892: LIST
14893: LIST
14894: LIST
14895: PPUSH
14896: CALL_OW 69
14900: PUSH
14901: LD_INT 18
14903: LESS
14904: PUSH
14905: LD_EXP 52
14909: PPUSH
14910: CALL_OW 301
14914: OR
14915: PUSH
14916: LD_INT 324
14918: PPUSH
14919: CALL_OW 255
14923: PUSH
14924: LD_INT 7
14926: EQUAL
14927: OR
14928: IFFALSE 14941
14930: GO 14932
14932: DISABLE
// legionDestroyed := true ;
14933: LD_ADDR_EXP 3
14937: PUSH
14938: LD_INT 1
14940: ST_TO_ADDR
14941: END
// every 0 0$3 trigger FilterAllUnits ( [ [ f_side , 2 ] , [ f_type , unit_human ] , [ f_nation , 2 ] ] ) < 9 do
14942: LD_INT 22
14944: PUSH
14945: LD_INT 2
14947: PUSH
14948: EMPTY
14949: LIST
14950: LIST
14951: PUSH
14952: LD_INT 21
14954: PUSH
14955: LD_INT 1
14957: PUSH
14958: EMPTY
14959: LIST
14960: LIST
14961: PUSH
14962: LD_INT 23
14964: PUSH
14965: LD_INT 2
14967: PUSH
14968: EMPTY
14969: LIST
14970: LIST
14971: PUSH
14972: EMPTY
14973: LIST
14974: LIST
14975: LIST
14976: PPUSH
14977: CALL_OW 69
14981: PUSH
14982: LD_INT 9
14984: LESS
14985: IFFALSE 14998
14987: GO 14989
14989: DISABLE
// arabianDestroyed := true ;
14990: LD_ADDR_EXP 5
14994: PUSH
14995: LD_INT 1
14997: ST_TO_ADDR
14998: END
// every 0 0$1 trigger arabianDestroyed do var i , tmp ;
14999: LD_EXP 5
15003: IFFALSE 15263
15005: GO 15007
15007: DISABLE
15008: LD_INT 0
15010: PPUSH
15011: PPUSH
// begin MC_Kill ( 1 ) ;
15012: LD_INT 1
15014: PPUSH
15015: CALL 20603 0 1
// SetAttitude ( 2 , 7 , att_friend , true ) ;
15019: LD_INT 2
15021: PPUSH
15022: LD_INT 7
15024: PPUSH
15025: LD_INT 1
15027: PPUSH
15028: LD_INT 1
15030: PPUSH
15031: CALL_OW 80
// tmp := FilterAllUnits ( [ [ f_side , 2 ] , [ f_type , unit_human ] ] ) ^ FilterAllUnits ( [ [ f_side , 8 ] , [ f_type , unit_vehicle ] , [ control_manual ] ] ) ;
15035: LD_ADDR_VAR 0 2
15039: PUSH
15040: LD_INT 22
15042: PUSH
15043: LD_INT 2
15045: PUSH
15046: EMPTY
15047: LIST
15048: LIST
15049: PUSH
15050: LD_INT 21
15052: PUSH
15053: LD_INT 1
15055: PUSH
15056: EMPTY
15057: LIST
15058: LIST
15059: PUSH
15060: EMPTY
15061: LIST
15062: LIST
15063: PPUSH
15064: CALL_OW 69
15068: PUSH
15069: LD_INT 22
15071: PUSH
15072: LD_INT 8
15074: PUSH
15075: EMPTY
15076: LIST
15077: LIST
15078: PUSH
15079: LD_INT 21
15081: PUSH
15082: LD_INT 2
15084: PUSH
15085: EMPTY
15086: LIST
15087: LIST
15088: PUSH
15089: LD_INT 1
15091: PUSH
15092: EMPTY
15093: LIST
15094: PUSH
15095: EMPTY
15096: LIST
15097: LIST
15098: LIST
15099: PPUSH
15100: CALL_OW 69
15104: ADD
15105: ST_TO_ADDR
// if tmp then
15106: LD_VAR 0 2
15110: IFFALSE 15263
// repeat wait ( 0 0$1 ) ;
15112: LD_INT 35
15114: PPUSH
15115: CALL_OW 67
// for i in tmp do
15119: LD_ADDR_VAR 0 1
15123: PUSH
15124: LD_VAR 0 2
15128: PUSH
15129: FOR_IN
15130: IFFALSE 15212
// begin if IsInUnit ( i ) and GetType ( IsInUnit ( i ) ) = unit_building then
15132: LD_VAR 0 1
15136: PPUSH
15137: CALL_OW 310
15141: PUSH
15142: LD_VAR 0 1
15146: PPUSH
15147: CALL_OW 310
15151: PPUSH
15152: CALL_OW 247
15156: PUSH
15157: LD_INT 3
15159: EQUAL
15160: AND
15161: IFFALSE 15172
// ComExitBuilding ( i ) ;
15163: LD_VAR 0 1
15167: PPUSH
15168: CALL_OW 122
// AddComMoveXY ( i , 254 , 268 ) ;
15172: LD_VAR 0 1
15176: PPUSH
15177: LD_INT 254
15179: PPUSH
15180: LD_INT 268
15182: PPUSH
15183: CALL_OW 171
// if IsInArea ( i , arabEscape ) then
15187: LD_VAR 0 1
15191: PPUSH
15192: LD_INT 34
15194: PPUSH
15195: CALL_OW 308
15199: IFFALSE 15210
// RemoveUnit ( i ) ;
15201: LD_VAR 0 1
15205: PPUSH
15206: CALL_OW 64
// end ;
15210: GO 15129
15212: POP
15213: POP
// until not FilterAllUnits ( [ [ f_side , 2 ] , [ f_or , [ f_type , unit_human ] , [ f_control , control_manual ] ] ] ) ;
15214: LD_INT 22
15216: PUSH
15217: LD_INT 2
15219: PUSH
15220: EMPTY
15221: LIST
15222: LIST
15223: PUSH
15224: LD_INT 2
15226: PUSH
15227: LD_INT 21
15229: PUSH
15230: LD_INT 1
15232: PUSH
15233: EMPTY
15234: LIST
15235: LIST
15236: PUSH
15237: LD_INT 33
15239: PUSH
15240: LD_INT 1
15242: PUSH
15243: EMPTY
15244: LIST
15245: LIST
15246: PUSH
15247: EMPTY
15248: LIST
15249: LIST
15250: LIST
15251: PUSH
15252: EMPTY
15253: LIST
15254: LIST
15255: PPUSH
15256: CALL_OW 69
15260: NOT
15261: IFFALSE 15112
// end ;
15263: PPOPN 2
15265: END
// every 0 0$1 trigger legionDestroyed do var i , tmp ;
15266: LD_EXP 3
15270: IFFALSE 15614
15272: GO 15274
15274: DISABLE
15275: LD_INT 0
15277: PPUSH
15278: PPUSH
// begin MC_Kill ( 3 ) ;
15279: LD_INT 3
15281: PPUSH
15282: CALL 20603 0 1
// SetAttitude ( 8 , 7 , att_friend , true ) ;
15286: LD_INT 8
15288: PPUSH
15289: LD_INT 7
15291: PPUSH
15292: LD_INT 1
15294: PPUSH
15295: LD_INT 1
15297: PPUSH
15298: CALL_OW 80
// DialogueOn ;
15302: CALL_OW 6
// SayRadio ( Schulz , D15-Szulc-1 ) ;
15306: LD_EXP 51
15310: PPUSH
15311: LD_STRING D15-Szulc-1
15313: PPUSH
15314: CALL_OW 94
// DialogueOff ;
15318: CALL_OW 7
// for i in FilterAllUnits ( [ [ f_side , 8 ] , [ f_type , unit_building ] , [ f_nation , 3 ] ] ) do
15322: LD_ADDR_VAR 0 1
15326: PUSH
15327: LD_INT 22
15329: PUSH
15330: LD_INT 8
15332: PUSH
15333: EMPTY
15334: LIST
15335: LIST
15336: PUSH
15337: LD_INT 21
15339: PUSH
15340: LD_INT 3
15342: PUSH
15343: EMPTY
15344: LIST
15345: LIST
15346: PUSH
15347: LD_INT 23
15349: PUSH
15350: LD_INT 3
15352: PUSH
15353: EMPTY
15354: LIST
15355: LIST
15356: PUSH
15357: EMPTY
15358: LIST
15359: LIST
15360: LIST
15361: PPUSH
15362: CALL_OW 69
15366: PUSH
15367: FOR_IN
15368: IFFALSE 15384
// SetLives ( i , 3 ) ;
15370: LD_VAR 0 1
15374: PPUSH
15375: LD_INT 3
15377: PPUSH
15378: CALL_OW 234
15382: GO 15367
15384: POP
15385: POP
// tmp := FilterAllUnits ( [ [ f_side , 8 ] , [ f_type , unit_human ] ] ) ^ FilterAllUnits ( [ [ f_side , 8 ] , [ f_type , unit_vehicle ] , [ control_manual ] ] ) ;
15386: LD_ADDR_VAR 0 2
15390: PUSH
15391: LD_INT 22
15393: PUSH
15394: LD_INT 8
15396: PUSH
15397: EMPTY
15398: LIST
15399: LIST
15400: PUSH
15401: LD_INT 21
15403: PUSH
15404: LD_INT 1
15406: PUSH
15407: EMPTY
15408: LIST
15409: LIST
15410: PUSH
15411: EMPTY
15412: LIST
15413: LIST
15414: PPUSH
15415: CALL_OW 69
15419: PUSH
15420: LD_INT 22
15422: PUSH
15423: LD_INT 8
15425: PUSH
15426: EMPTY
15427: LIST
15428: LIST
15429: PUSH
15430: LD_INT 21
15432: PUSH
15433: LD_INT 2
15435: PUSH
15436: EMPTY
15437: LIST
15438: LIST
15439: PUSH
15440: LD_INT 1
15442: PUSH
15443: EMPTY
15444: LIST
15445: PUSH
15446: EMPTY
15447: LIST
15448: LIST
15449: LIST
15450: PPUSH
15451: CALL_OW 69
15455: ADD
15456: ST_TO_ADDR
// if tmp then
15457: LD_VAR 0 2
15461: IFFALSE 15614
// repeat wait ( 0 0$1 ) ;
15463: LD_INT 35
15465: PPUSH
15466: CALL_OW 67
// for i in tmp do
15470: LD_ADDR_VAR 0 1
15474: PUSH
15475: LD_VAR 0 2
15479: PUSH
15480: FOR_IN
15481: IFFALSE 15563
// begin if IsInUnit ( i ) and GetType ( IsInUnit ( i ) ) = unit_building then
15483: LD_VAR 0 1
15487: PPUSH
15488: CALL_OW 310
15492: PUSH
15493: LD_VAR 0 1
15497: PPUSH
15498: CALL_OW 310
15502: PPUSH
15503: CALL_OW 247
15507: PUSH
15508: LD_INT 3
15510: EQUAL
15511: AND
15512: IFFALSE 15523
// ComExitBuilding ( i ) ;
15514: LD_VAR 0 1
15518: PPUSH
15519: CALL_OW 122
// AddComMoveXY ( i , 10 , 1 ) ;
15523: LD_VAR 0 1
15527: PPUSH
15528: LD_INT 10
15530: PPUSH
15531: LD_INT 1
15533: PPUSH
15534: CALL_OW 171
// if IsInArea ( i , legionEscape ) then
15538: LD_VAR 0 1
15542: PPUSH
15543: LD_INT 32
15545: PPUSH
15546: CALL_OW 308
15550: IFFALSE 15561
// RemoveUnit ( i ) ;
15552: LD_VAR 0 1
15556: PPUSH
15557: CALL_OW 64
// end ;
15561: GO 15480
15563: POP
15564: POP
// until not FilterAllUnits ( [ [ f_side , 8 ] , [ f_or , [ f_type , unit_human ] , [ f_control , control_manual ] ] ] ) ;
15565: LD_INT 22
15567: PUSH
15568: LD_INT 8
15570: PUSH
15571: EMPTY
15572: LIST
15573: LIST
15574: PUSH
15575: LD_INT 2
15577: PUSH
15578: LD_INT 21
15580: PUSH
15581: LD_INT 1
15583: PUSH
15584: EMPTY
15585: LIST
15586: LIST
15587: PUSH
15588: LD_INT 33
15590: PUSH
15591: LD_INT 1
15593: PUSH
15594: EMPTY
15595: LIST
15596: LIST
15597: PUSH
15598: EMPTY
15599: LIST
15600: LIST
15601: LIST
15602: PUSH
15603: EMPTY
15604: LIST
15605: LIST
15606: PPUSH
15607: CALL_OW 69
15611: NOT
15612: IFFALSE 15463
// end ;
15614: PPOPN 2
15616: END
// every 0 0$3 trigger americanDestroyed and russianDestroyed and legionDestroyed and arabianDestroyed do var med1 , med2 ;
15617: LD_EXP 4
15621: PUSH
15622: LD_EXP 2
15626: AND
15627: PUSH
15628: LD_EXP 3
15632: AND
15633: PUSH
15634: LD_EXP 5
15638: AND
15639: IFFALSE 17023
15641: GO 15643
15643: DISABLE
15644: LD_INT 0
15646: PPUSH
15647: PPUSH
// begin music_class := 5 ;
15648: LD_ADDR_OWVAR 72
15652: PUSH
15653: LD_INT 5
15655: ST_TO_ADDR
// music_nat := 5 ;
15656: LD_ADDR_OWVAR 71
15660: PUSH
15661: LD_INT 5
15663: ST_TO_ADDR
// if vehicleLostCounter < 3 then
15664: LD_EXP 12
15668: PUSH
15669: LD_INT 3
15671: LESS
15672: IFFALSE 15681
// SetAchievement ( ACH_ECONOMY ) ;
15674: LD_STRING ACH_ECONOMY
15676: PPUSH
15677: CALL_OW 543
// if tick < 60 60$00 then
15681: LD_OWVAR 1
15685: PUSH
15686: LD_INT 126000
15688: LESS
15689: IFFALSE 15705
// begin wait ( 3 ) ;
15691: LD_INT 3
15693: PPUSH
15694: CALL_OW 67
// SetAchievement ( ACH_ASPEED_19 ) ;
15698: LD_STRING ACH_ASPEED_19
15700: PPUSH
15701: CALL_OW 543
// end ; CenterNowOnUnits ( JMM ) ;
15705: LD_EXP 14
15709: PPUSH
15710: CALL_OW 87
// InGameOn ;
15714: CALL_OW 8
// DialogueOn ;
15718: CALL_OW 6
// Say ( JMM , DEnd-JMM-JMM-1 ) ;
15722: LD_EXP 14
15726: PPUSH
15727: LD_STRING DEnd-JMM-JMM-1
15729: PPUSH
15730: CALL_OW 88
// if Joan then
15734: LD_EXP 29
15738: IFFALSE 15754
// Say ( Joan , DEnd-JMM-Joan-1 ) else
15740: LD_EXP 29
15744: PPUSH
15745: LD_STRING DEnd-JMM-Joan-1
15747: PPUSH
15748: CALL_OW 88
15752: GO 15798
// if Lisa and GetSide ( Lisa ) = 7 and IsPlaced ( Lisa ) then
15754: LD_EXP 16
15758: PUSH
15759: LD_EXP 16
15763: PPUSH
15764: CALL_OW 255
15768: PUSH
15769: LD_INT 7
15771: EQUAL
15772: AND
15773: PUSH
15774: LD_EXP 16
15778: PPUSH
15779: CALL_OW 305
15783: AND
15784: IFFALSE 15798
// Say ( Lisa , DEnd-JMM-Lisa-1 ) ;
15786: LD_EXP 16
15790: PPUSH
15791: LD_STRING DEnd-JMM-Lisa-1
15793: PPUSH
15794: CALL_OW 88
// if Frank and IsPlaced ( Frank ) then
15798: LD_EXP 26
15802: PUSH
15803: LD_EXP 26
15807: PPUSH
15808: CALL_OW 305
15812: AND
15813: IFFALSE 15827
// Say ( Frank , DEnd-JMM-Frank-1 ) ;
15815: LD_EXP 26
15819: PPUSH
15820: LD_STRING DEnd-JMM-Frank-1
15822: PPUSH
15823: CALL_OW 88
// if Cyrus and GetSide ( Cyrus ) = 7 and IsPlaced ( Cyrus ) then
15827: LD_EXP 19
15831: PUSH
15832: LD_EXP 19
15836: PPUSH
15837: CALL_OW 255
15841: PUSH
15842: LD_INT 7
15844: EQUAL
15845: AND
15846: PUSH
15847: LD_EXP 19
15851: PPUSH
15852: CALL_OW 305
15856: AND
15857: IFFALSE 15871
// Say ( Cyrus , DEnd-JMM-Cyrus-1 ) ;
15859: LD_EXP 19
15863: PPUSH
15864: LD_STRING DEnd-JMM-Cyrus-1
15866: PPUSH
15867: CALL_OW 88
// if Burlak then
15871: LD_EXP 46
15875: IFFALSE 15889
// Say ( Burlak , DEnd-JMM-Bur-1 ) ;
15877: LD_EXP 46
15881: PPUSH
15882: LD_STRING DEnd-JMM-Bur-1
15884: PPUSH
15885: CALL_OW 88
// if Joan and Lisa and GetSide ( Lisa ) = 7 and IsPlaced ( Lisa ) then
15889: LD_EXP 29
15893: PUSH
15894: LD_EXP 16
15898: AND
15899: PUSH
15900: LD_EXP 16
15904: PPUSH
15905: CALL_OW 255
15909: PUSH
15910: LD_INT 7
15912: EQUAL
15913: AND
15914: PUSH
15915: LD_EXP 16
15919: PPUSH
15920: CALL_OW 305
15924: AND
15925: IFFALSE 15939
// Say ( Lisa , DEnd-Burlak-Lisa-1 ) ;
15927: LD_EXP 16
15931: PPUSH
15932: LD_STRING DEnd-Burlak-Lisa-1
15934: PPUSH
15935: CALL_OW 88
// if Belkov and IsPlaced ( Belkov ) then
15939: LD_EXP 47
15943: PUSH
15944: LD_EXP 47
15948: PPUSH
15949: CALL_OW 305
15953: AND
15954: IFFALSE 15968
// Say ( Belkov , DEnd-JMM-Bel-1 ) ;
15956: LD_EXP 47
15960: PPUSH
15961: LD_STRING DEnd-JMM-Bel-1
15963: PPUSH
15964: CALL_OW 88
// if Gnyevko and IsPlaced ( Gnyevko ) then
15968: LD_EXP 48
15972: PUSH
15973: LD_EXP 48
15977: PPUSH
15978: CALL_OW 305
15982: AND
15983: IFFALSE 15997
// Say ( Gnyevko , DEnd-JMM-Gny-1 ) ;
15985: LD_EXP 48
15989: PPUSH
15990: LD_STRING DEnd-JMM-Gny-1
15992: PPUSH
15993: CALL_OW 88
// if Cornel and GetSide ( Cornel ) = 7 and IsPlaced ( Cornel ) then
15997: LD_EXP 24
16001: PUSH
16002: LD_EXP 24
16006: PPUSH
16007: CALL_OW 255
16011: PUSH
16012: LD_INT 7
16014: EQUAL
16015: AND
16016: PUSH
16017: LD_EXP 24
16021: PPUSH
16022: CALL_OW 305
16026: AND
16027: IFFALSE 16041
// Say ( Cornel , DEnd-JMM-Corn-1 ) ;
16029: LD_EXP 24
16033: PPUSH
16034: LD_STRING DEnd-JMM-Corn-1
16036: PPUSH
16037: CALL_OW 88
// if Donaldson and GetSide ( Donaldson ) = 7 and IsPlaced ( Donaldson ) then
16041: LD_EXP 17
16045: PUSH
16046: LD_EXP 17
16050: PPUSH
16051: CALL_OW 255
16055: PUSH
16056: LD_INT 7
16058: EQUAL
16059: AND
16060: PUSH
16061: LD_EXP 17
16065: PPUSH
16066: CALL_OW 305
16070: AND
16071: IFFALSE 16085
// Say ( Donaldson , DEnd-JMM-Don-1 ) ;
16073: LD_EXP 17
16077: PPUSH
16078: LD_STRING DEnd-JMM-Don-1
16080: PPUSH
16081: CALL_OW 88
// if Bobby and GetSide ( Bobby ) = 7 and IsPlaced ( Bobby ) then
16085: LD_EXP 18
16089: PUSH
16090: LD_EXP 18
16094: PPUSH
16095: CALL_OW 255
16099: PUSH
16100: LD_INT 7
16102: EQUAL
16103: AND
16104: PUSH
16105: LD_EXP 18
16109: PPUSH
16110: CALL_OW 305
16114: AND
16115: IFFALSE 16129
// Say ( Bobby , DEnd-JMM-Bobby-1 ) ;
16117: LD_EXP 18
16121: PPUSH
16122: LD_STRING DEnd-JMM-Bobby-1
16124: PPUSH
16125: CALL_OW 88
// if Denis and GetSide ( Denis ) = 7 and IsPlaced ( Denis ) then
16129: LD_EXP 20
16133: PUSH
16134: LD_EXP 20
16138: PPUSH
16139: CALL_OW 255
16143: PUSH
16144: LD_INT 7
16146: EQUAL
16147: AND
16148: PUSH
16149: LD_EXP 20
16153: PPUSH
16154: CALL_OW 305
16158: AND
16159: IFFALSE 16173
// Say ( Denis , DEnd-JMM-Den-1 ) ;
16161: LD_EXP 20
16165: PPUSH
16166: LD_STRING DEnd-JMM-Den-1
16168: PPUSH
16169: CALL_OW 88
// if Gladstone and GetSide ( Gladstone ) = 7 and IsPlaced ( Gladstone ) then
16173: LD_EXP 22
16177: PUSH
16178: LD_EXP 22
16182: PPUSH
16183: CALL_OW 255
16187: PUSH
16188: LD_INT 7
16190: EQUAL
16191: AND
16192: PUSH
16193: LD_EXP 22
16197: PPUSH
16198: CALL_OW 305
16202: AND
16203: IFFALSE 16217
// Say ( Gladstone , DEnd-JMM-Glad-1 ) ;
16205: LD_EXP 22
16209: PPUSH
16210: LD_STRING DEnd-JMM-Glad-1
16212: PPUSH
16213: CALL_OW 88
// if Kikuchi and GetSide ( Kikuchi ) = 7 and IsPlaced ( Kikuchi ) then
16217: LD_EXP 27
16221: PUSH
16222: LD_EXP 27
16226: PPUSH
16227: CALL_OW 255
16231: PUSH
16232: LD_INT 7
16234: EQUAL
16235: AND
16236: PUSH
16237: LD_EXP 27
16241: PPUSH
16242: CALL_OW 305
16246: AND
16247: IFFALSE 16261
// Say ( Kikuchi , DEnd-JMM-Yam-1 ) ;
16249: LD_EXP 27
16253: PPUSH
16254: LD_STRING DEnd-JMM-Yam-1
16256: PPUSH
16257: CALL_OW 88
// if Brown and GetSide ( Brown ) = 7 and IsPlaced ( Brown ) then
16261: LD_EXP 21
16265: PUSH
16266: LD_EXP 21
16270: PPUSH
16271: CALL_OW 255
16275: PUSH
16276: LD_INT 7
16278: EQUAL
16279: AND
16280: PUSH
16281: LD_EXP 21
16285: PPUSH
16286: CALL_OW 305
16290: AND
16291: IFFALSE 16305
// Say ( Brown , DEnd-JMM-Brown-1 ) ;
16293: LD_EXP 21
16297: PPUSH
16298: LD_STRING DEnd-JMM-Brown-1
16300: PPUSH
16301: CALL_OW 88
// if Connie and GetSide ( Connie ) = 7 and IsPlaced ( Connie ) then
16305: LD_EXP 31
16309: PUSH
16310: LD_EXP 31
16314: PPUSH
16315: CALL_OW 255
16319: PUSH
16320: LD_INT 7
16322: EQUAL
16323: AND
16324: PUSH
16325: LD_EXP 31
16329: PPUSH
16330: CALL_OW 305
16334: AND
16335: IFFALSE 16349
// Say ( Connie , DEnd-JMM-Con-1 ) ;
16337: LD_EXP 31
16341: PPUSH
16342: LD_STRING DEnd-JMM-Con-1
16344: PPUSH
16345: CALL_OW 88
// if Gary and GetSide ( Gary ) = 7 and IsPlaced ( Gary ) then
16349: LD_EXP 25
16353: PUSH
16354: LD_EXP 25
16358: PPUSH
16359: CALL_OW 255
16363: PUSH
16364: LD_INT 7
16366: EQUAL
16367: AND
16368: PUSH
16369: LD_EXP 25
16373: PPUSH
16374: CALL_OW 305
16378: AND
16379: IFFALSE 16393
// Say ( Gary , DEnd-JMM-Gary-1 ) ;
16381: LD_EXP 25
16385: PPUSH
16386: LD_STRING DEnd-JMM-Gary-1
16388: PPUSH
16389: CALL_OW 88
// if Simms and Roth and IsPlaced ( Simms ) then
16393: LD_EXP 28
16397: PUSH
16398: LD_EXP 15
16402: AND
16403: PUSH
16404: LD_EXP 28
16408: PPUSH
16409: CALL_OW 305
16413: AND
16414: IFFALSE 16428
// Say ( Simms , DEnd-JMM-Sim-1 ) ;
16416: LD_EXP 28
16420: PPUSH
16421: LD_STRING DEnd-JMM-Sim-1
16423: PPUSH
16424: CALL_OW 88
// if Houten and GetSide ( Houten ) = 7 and IsPlaced ( Houten ) then
16428: LD_EXP 23
16432: PUSH
16433: LD_EXP 23
16437: PPUSH
16438: CALL_OW 255
16442: PUSH
16443: LD_INT 7
16445: EQUAL
16446: AND
16447: PUSH
16448: LD_EXP 23
16452: PPUSH
16453: CALL_OW 305
16457: AND
16458: IFFALSE 16472
// Say ( Houten , DEnd-JMM-VanH-1 ) ;
16460: LD_EXP 23
16464: PPUSH
16465: LD_STRING DEnd-JMM-VanH-1
16467: PPUSH
16468: CALL_OW 88
// if Dolgov and IsPlaced ( Dolgov ) then
16472: LD_EXP 36
16476: PUSH
16477: LD_EXP 36
16481: PPUSH
16482: CALL_OW 305
16486: AND
16487: IFFALSE 16501
// Say ( Dolgov , DEnd-JMM-Dol-1 ) ;
16489: LD_EXP 36
16493: PPUSH
16494: LD_STRING DEnd-JMM-Dol-1
16496: PPUSH
16497: CALL_OW 88
// if Kapitsova and IsPlaced ( Kapitsova ) then
16501: LD_EXP 40
16505: PUSH
16506: LD_EXP 40
16510: PPUSH
16511: CALL_OW 305
16515: AND
16516: IFFALSE 16530
// Say ( Kapitsova , DEnd-JMM-Kap-1 ) ;
16518: LD_EXP 40
16522: PPUSH
16523: LD_STRING DEnd-JMM-Kap-1
16525: PPUSH
16526: CALL_OW 88
// if Kovalyuk and IsPlaced ( Kovalyuk ) then
16530: LD_EXP 43
16534: PUSH
16535: LD_EXP 43
16539: PPUSH
16540: CALL_OW 305
16544: AND
16545: IFFALSE 16559
// Say ( Kovalyuk , DEnd-JMM-Kov-1 ) ;
16547: LD_EXP 43
16551: PPUSH
16552: LD_STRING DEnd-JMM-Kov-1
16554: PPUSH
16555: CALL_OW 88
// if Scholtze and IsPlaced ( Scholtze ) then
16559: LD_EXP 38
16563: PUSH
16564: LD_EXP 38
16568: PPUSH
16569: CALL_OW 305
16573: AND
16574: IFFALSE 16588
// Say ( Scholtze , DEnd-JMM-Sch-1 ) ;
16576: LD_EXP 38
16580: PPUSH
16581: LD_STRING DEnd-JMM-Sch-1
16583: PPUSH
16584: CALL_OW 88
// if Titov and IsPlaced ( Titov ) then
16588: LD_EXP 34
16592: PUSH
16593: LD_EXP 34
16597: PPUSH
16598: CALL_OW 305
16602: AND
16603: IFFALSE 16617
// Say ( Titov , DEnd-JMM-Tit-1 ) ;
16605: LD_EXP 34
16609: PPUSH
16610: LD_STRING DEnd-JMM-Tit-1
16612: PPUSH
16613: CALL_OW 88
// if Oblukov and IsPlaced ( Oblukov ) then
16617: LD_EXP 39
16621: PUSH
16622: LD_EXP 39
16626: PPUSH
16627: CALL_OW 305
16631: AND
16632: IFFALSE 16646
// Say ( Oblukov , DEnd-JMM-Obl-1 ) ;
16634: LD_EXP 39
16638: PPUSH
16639: LD_STRING DEnd-JMM-Obl-1
16641: PPUSH
16642: CALL_OW 88
// if Lipshchin and IsPlaced ( Lipshchin ) then
16646: LD_EXP 41
16650: PUSH
16651: LD_EXP 41
16655: PPUSH
16656: CALL_OW 305
16660: AND
16661: IFFALSE 16675
// Say ( Lipshchin , DEnd-JMM-Lip-1 ) ;
16663: LD_EXP 41
16667: PPUSH
16668: LD_STRING DEnd-JMM-Lip-1
16670: PPUSH
16671: CALL_OW 88
// if Fadeev and IsPlaced ( Fadeev ) and Burlak then
16675: LD_EXP 35
16679: PUSH
16680: LD_EXP 35
16684: PPUSH
16685: CALL_OW 305
16689: AND
16690: PUSH
16691: LD_EXP 46
16695: AND
16696: IFFALSE 16710
// Say ( Fadeev , DEnd-Burlak-Fad-1 ) ;
16698: LD_EXP 35
16702: PPUSH
16703: LD_STRING DEnd-Burlak-Fad-1
16705: PPUSH
16706: CALL_OW 88
// if Petrovova and IsPlaced ( Petrovova ) then
16710: LD_EXP 42
16714: PUSH
16715: LD_EXP 42
16719: PPUSH
16720: CALL_OW 305
16724: AND
16725: IFFALSE 16739
// Say ( Petrovova , DEnd-Burlak-Ptr-1 ) ;
16727: LD_EXP 42
16731: PPUSH
16732: LD_STRING DEnd-Burlak-Ptr-1
16734: PPUSH
16735: CALL_OW 88
// if Kuzmov and IsPlaced ( Kuzmov ) then
16739: LD_EXP 44
16743: PUSH
16744: LD_EXP 44
16748: PPUSH
16749: CALL_OW 305
16753: AND
16754: IFFALSE 16768
// Say ( Kuzmov , DEnd-Burlak-Kuz-1 ) ;
16756: LD_EXP 44
16760: PPUSH
16761: LD_STRING DEnd-Burlak-Kuz-1
16763: PPUSH
16764: CALL_OW 88
// if Kirilenkova and IsPlaced ( Kirilenkova ) and Burlak then
16768: LD_EXP 33
16772: PUSH
16773: LD_EXP 33
16777: PPUSH
16778: CALL_OW 305
16782: AND
16783: PUSH
16784: LD_EXP 46
16788: AND
16789: IFFALSE 16803
// Say ( Kirilenkova , DEnd-Burlak-Kir-1 ) ;
16791: LD_EXP 33
16795: PPUSH
16796: LD_STRING DEnd-Burlak-Kir-1
16798: PPUSH
16799: CALL_OW 88
// if Burlak then
16803: LD_EXP 46
16807: IFFALSE 16821
// Say ( JMM , DEnd-Burlak-JMM-1 ) ;
16809: LD_EXP 14
16813: PPUSH
16814: LD_STRING DEnd-Burlak-JMM-1
16816: PPUSH
16817: CALL_OW 88
// dwait ( 0 0$2 ) ;
16821: LD_INT 70
16823: PPUSH
16824: CALL_OW 68
// SayRadio ( Schulz , DEnd-Szulc ) ;
16828: LD_EXP 51
16832: PPUSH
16833: LD_STRING DEnd-Szulc
16835: PPUSH
16836: CALL_OW 94
// dwait ( 0 0$1 ) ;
16840: LD_INT 35
16842: PPUSH
16843: CALL_OW 68
// if IsLive ( Burlak ) then
16847: LD_EXP 46
16851: PPUSH
16852: CALL_OW 300
16856: IFFALSE 16868
// med1 := 1 else
16858: LD_ADDR_VAR 0 1
16862: PUSH
16863: LD_INT 1
16865: ST_TO_ADDR
16866: GO 16877
// med1 := - 1 ;
16868: LD_ADDR_VAR 0 1
16872: PUSH
16873: LD_INT 1
16875: NEG
16876: ST_TO_ADDR
// if artifactIResearched and artifactIIResearched and artifactIIIResearched then
16877: LD_EXP 9
16881: PUSH
16882: LD_EXP 10
16886: AND
16887: PUSH
16888: LD_EXP 11
16892: AND
16893: IFFALSE 16905
// med2 := 1 else
16895: LD_ADDR_VAR 0 2
16899: PUSH
16900: LD_INT 1
16902: ST_TO_ADDR
16903: GO 16914
// med2 := - 1 ;
16905: LD_ADDR_VAR 0 2
16909: PUSH
16910: LD_INT 1
16912: NEG
16913: ST_TO_ADDR
// AddMedal ( Hero , 1 ) ;
16914: LD_STRING Hero
16916: PPUSH
16917: LD_INT 1
16919: PPUSH
16920: CALL_OW 101
// AddMedal ( Artefact , med2 ) ;
16924: LD_STRING Artefact
16926: PPUSH
16927: LD_VAR 0 2
16931: PPUSH
16932: CALL_OW 101
// AddMedal ( ReconcileBurlak , med1 ) ;
16936: LD_STRING ReconcileBurlak
16938: PPUSH
16939: LD_VAR 0 1
16943: PPUSH
16944: CALL_OW 101
// if Difficulty = 3 and med1 = 1 and med2 = 1 then
16948: LD_OWVAR 67
16952: PUSH
16953: LD_INT 3
16955: EQUAL
16956: PUSH
16957: LD_VAR 0 1
16961: PUSH
16962: LD_INT 1
16964: EQUAL
16965: AND
16966: PUSH
16967: LD_VAR 0 2
16971: PUSH
16972: LD_INT 1
16974: EQUAL
16975: AND
16976: IFFALSE 16988
// SetAchievementEX ( ACH_AMER , 19 ) ;
16978: LD_STRING ACH_AMER
16980: PPUSH
16981: LD_INT 19
16983: PPUSH
16984: CALL_OW 564
// GiveMedals ( MAIN ) ;
16988: LD_STRING MAIN
16990: PPUSH
16991: CALL_OW 102
// InGameOff ;
16995: CALL_OW 9
// DialogueOff ;
16999: CALL_OW 7
// music_nat := 1 ;
17003: LD_ADDR_OWVAR 71
17007: PUSH
17008: LD_INT 1
17010: ST_TO_ADDR
// music_class := 4 ;
17011: LD_ADDR_OWVAR 72
17015: PUSH
17016: LD_INT 4
17018: ST_TO_ADDR
// YouWin ;
17019: CALL_OW 103
// end ; end_of_file
17023: PPOPN 2
17025: END
// export function InitNature ; begin
17026: LD_INT 0
17028: PPUSH
// PrepareNature ( 3 , 3 , 2 , 1 , 1 , 0 , 0 , natureArea1 , 0 ) ;
17029: LD_INT 3
17031: PPUSH
17032: LD_INT 3
17034: PPUSH
17035: LD_INT 2
17037: PPUSH
17038: LD_INT 1
17040: PPUSH
17041: LD_INT 1
17043: PPUSH
17044: LD_INT 0
17046: PPUSH
17047: LD_INT 0
17049: PPUSH
17050: LD_INT 17
17052: PPUSH
17053: LD_INT 0
17055: PPUSH
17056: CALL 85313 0 9
// PrepareNature ( 2 , 1 , 1 , 1 , 1 , 0 , 0 , natureArea2 , 0 ) ;
17060: LD_INT 2
17062: PPUSH
17063: LD_INT 1
17065: PPUSH
17066: LD_INT 1
17068: PPUSH
17069: LD_INT 1
17071: PPUSH
17072: LD_INT 1
17074: PPUSH
17075: LD_INT 0
17077: PPUSH
17078: LD_INT 0
17080: PPUSH
17081: LD_INT 18
17083: PPUSH
17084: LD_INT 0
17086: PPUSH
17087: CALL 85313 0 9
// PrepareNature ( 4 , 1 , 2 , 4 , 2 , 1 , 0 , natureArea3 , 0 ) ;
17091: LD_INT 4
17093: PPUSH
17094: LD_INT 1
17096: PPUSH
17097: LD_INT 2
17099: PPUSH
17100: LD_INT 4
17102: PPUSH
17103: LD_INT 2
17105: PPUSH
17106: LD_INT 1
17108: PPUSH
17109: LD_INT 0
17111: PPUSH
17112: LD_INT 19
17114: PPUSH
17115: LD_INT 0
17117: PPUSH
17118: CALL 85313 0 9
// PrepareNature ( 0 , 0 , 0 , 0 , 0 , 0 , 9 , 0 , natureWaterArea ) ;
17122: LD_INT 0
17124: PPUSH
17125: LD_INT 0
17127: PPUSH
17128: LD_INT 0
17130: PPUSH
17131: LD_INT 0
17133: PPUSH
17134: LD_INT 0
17136: PPUSH
17137: LD_INT 0
17139: PPUSH
17140: LD_INT 9
17142: PPUSH
17143: LD_INT 0
17145: PPUSH
17146: LD_INT 20
17148: PPUSH
17149: CALL 85313 0 9
// end ; end_of_file
17153: LD_VAR 0 1
17157: RET
// every 0 0$30 do var time ;
17158: GO 17160
17160: DISABLE
17161: LD_INT 0
17163: PPUSH
// begin time := 0 0$50 ;
17164: LD_ADDR_VAR 0 1
17168: PUSH
17169: LD_INT 1750
17171: ST_TO_ADDR
// repeat wait ( time ) ;
17172: LD_VAR 0 1
17176: PPUSH
17177: CALL_OW 67
// if Prob ( 50 ) then
17181: LD_INT 50
17183: PPUSH
17184: CALL_OW 13
17188: IFFALSE 17217
// CreateCratesXYR ( rand ( 1 , 5 ) , 106 , 89 , 45 , true ) ;
17190: LD_INT 1
17192: PPUSH
17193: LD_INT 5
17195: PPUSH
17196: CALL_OW 12
17200: PPUSH
17201: LD_INT 106
17203: PPUSH
17204: LD_INT 89
17206: PPUSH
17207: LD_INT 45
17209: PPUSH
17210: LD_INT 1
17212: PPUSH
17213: CALL_OW 56
// time := time + 0 0$3 ;
17217: LD_ADDR_VAR 0 1
17221: PUSH
17222: LD_VAR 0 1
17226: PUSH
17227: LD_INT 105
17229: PLUS
17230: ST_TO_ADDR
// if Prob ( 30 ) then
17231: LD_INT 30
17233: PPUSH
17234: CALL_OW 13
17238: IFFALSE 17284
// begin wait ( rand ( 0 0$15 , 0 0$21 ) ) ;
17240: LD_INT 525
17242: PPUSH
17243: LD_INT 735
17245: PPUSH
17246: CALL_OW 12
17250: PPUSH
17251: CALL_OW 67
// CreateCratesXYR ( rand ( 1 , 5 ) , 21 , 26 , 12 , true ) ;
17255: LD_INT 1
17257: PPUSH
17258: LD_INT 5
17260: PPUSH
17261: CALL_OW 12
17265: PPUSH
17266: LD_INT 21
17268: PPUSH
17269: LD_INT 26
17271: PPUSH
17272: LD_INT 12
17274: PPUSH
17275: LD_INT 1
17277: PPUSH
17278: CALL_OW 56
// end else
17282: GO 17320
// begin wait ( rand ( 0 0$20 , 0 0$35 ) ) ;
17284: LD_INT 700
17286: PPUSH
17287: LD_INT 1225
17289: PPUSH
17290: CALL_OW 12
17294: PPUSH
17295: CALL_OW 67
// CreateCratesArea ( rand ( 1 , 5 ) , russianCratesArea , true ) ;
17299: LD_INT 1
17301: PPUSH
17302: LD_INT 5
17304: PPUSH
17305: CALL_OW 12
17309: PPUSH
17310: LD_INT 14
17312: PPUSH
17313: LD_INT 1
17315: PPUSH
17316: CALL_OW 55
// end ; if Prob ( 50 ) then
17320: LD_INT 50
17322: PPUSH
17323: CALL_OW 13
17327: IFFALSE 17373
// begin wait ( rand ( 0 0$20 , 0 0$30 ) ) ;
17329: LD_INT 700
17331: PPUSH
17332: LD_INT 1050
17334: PPUSH
17335: CALL_OW 12
17339: PPUSH
17340: CALL_OW 67
// CreateCratesXYR ( rand ( 1 , 5 ) , 181 , 218 , 16 , true ) ;
17344: LD_INT 1
17346: PPUSH
17347: LD_INT 5
17349: PPUSH
17350: CALL_OW 12
17354: PPUSH
17355: LD_INT 181
17357: PPUSH
17358: LD_INT 218
17360: PPUSH
17361: LD_INT 16
17363: PPUSH
17364: LD_INT 1
17366: PPUSH
17367: CALL_OW 56
// end else
17371: GO 17445
// begin wait ( rand ( 0 0$10 , 0 0$15 ) ) ;
17373: LD_INT 350
17375: PPUSH
17376: LD_INT 525
17378: PPUSH
17379: CALL_OW 12
17383: PPUSH
17384: CALL_OW 67
// CreateCratesArea ( rand ( 1 , 5 ) , legionCratesArea , true ) ;
17388: LD_INT 1
17390: PPUSH
17391: LD_INT 5
17393: PPUSH
17394: CALL_OW 12
17398: PPUSH
17399: LD_INT 13
17401: PPUSH
17402: LD_INT 1
17404: PPUSH
17405: CALL_OW 55
// wait ( rand ( 0 0$10 , 0 0$20 ) ) ;
17409: LD_INT 350
17411: PPUSH
17412: LD_INT 700
17414: PPUSH
17415: CALL_OW 12
17419: PPUSH
17420: CALL_OW 67
// CreateCratesArea ( rand ( 1 , 5 ) , americanCratesArea , true ) ;
17424: LD_INT 1
17426: PPUSH
17427: LD_INT 5
17429: PPUSH
17430: CALL_OW 12
17434: PPUSH
17435: LD_INT 33
17437: PPUSH
17438: LD_INT 1
17440: PPUSH
17441: CALL_OW 55
// end ; if Prob ( [ 65 , 62 , 55 ] [ Difficulty ] ) then
17445: LD_INT 65
17447: PUSH
17448: LD_INT 62
17450: PUSH
17451: LD_INT 55
17453: PUSH
17454: EMPTY
17455: LIST
17456: LIST
17457: LIST
17458: PUSH
17459: LD_OWVAR 67
17463: ARRAY
17464: PPUSH
17465: CALL_OW 13
17469: IFFALSE 17515
// begin wait ( rand ( 0 0$15 , 0 0$25 ) ) ;
17471: LD_INT 525
17473: PPUSH
17474: LD_INT 875
17476: PPUSH
17477: CALL_OW 12
17481: PPUSH
17482: CALL_OW 67
// CreateCratesXYR ( rand ( 1 , 5 ) , 294 , 211 , 30 , true ) ;
17486: LD_INT 1
17488: PPUSH
17489: LD_INT 5
17491: PPUSH
17492: CALL_OW 12
17496: PPUSH
17497: LD_INT 294
17499: PPUSH
17500: LD_INT 211
17502: PPUSH
17503: LD_INT 30
17505: PPUSH
17506: LD_INT 1
17508: PPUSH
17509: CALL_OW 56
// end else
17513: GO 17557
// begin wait ( rand ( 0 0$12 , 0 0$22 ) ) ;
17515: LD_INT 420
17517: PPUSH
17518: LD_INT 770
17520: PPUSH
17521: CALL_OW 12
17525: PPUSH
17526: CALL_OW 67
// CreateCratesXYR ( rand ( 1 , 5 ) , 294 , 211 , 30 , true ) ;
17530: LD_INT 1
17532: PPUSH
17533: LD_INT 5
17535: PPUSH
17536: CALL_OW 12
17540: PPUSH
17541: LD_INT 294
17543: PPUSH
17544: LD_INT 211
17546: PPUSH
17547: LD_INT 30
17549: PPUSH
17550: LD_INT 1
17552: PPUSH
17553: CALL_OW 56
// end ; if time > 2 2$20 then
17557: LD_VAR 0 1
17561: PUSH
17562: LD_INT 4900
17564: GREATER
17565: IFFALSE 17575
// time := 0 0$50 ;
17567: LD_ADDR_VAR 0 1
17571: PUSH
17572: LD_INT 1750
17574: ST_TO_ADDR
// until false ;
17575: LD_INT 0
17577: IFFALSE 17172
// end ;
17579: PPOPN 1
17581: END
// every 0 0$45 trigger tick < 10 10$00 do
17582: LD_OWVAR 1
17586: PUSH
17587: LD_INT 21000
17589: LESS
17590: IFFALSE 17638
17592: GO 17594
17594: DISABLE
// begin enable ;
17595: ENABLE
// wait ( rand ( 0 0$10 , 0 0$20 ) ) ;
17596: LD_INT 350
17598: PPUSH
17599: LD_INT 700
17601: PPUSH
17602: CALL_OW 12
17606: PPUSH
17607: CALL_OW 67
// CreateCratesXYR ( rand ( 3 , 5 ) , 181 , 13 , 20 , true ) ;
17611: LD_INT 3
17613: PPUSH
17614: LD_INT 5
17616: PPUSH
17617: CALL_OW 12
17621: PPUSH
17622: LD_INT 181
17624: PPUSH
17625: LD_INT 13
17627: PPUSH
17628: LD_INT 20
17630: PPUSH
17631: LD_INT 1
17633: PPUSH
17634: CALL_OW 56
// end ; end_of_file
17638: END
// export artifactsPos , artifactsRecharge , artifactsSibCost , artifactsResearched , artifactsLabsWorking ; export artifactsResDifficulty , artifactsResProgress , artifactsLabs , artifactsButtons , artifactsReady ; export function InitArtifact ; begin
17639: LD_INT 0
17641: PPUSH
// SetArtifactRes ( 7 , true ) ;
17642: LD_INT 7
17644: PPUSH
17645: LD_INT 1
17647: PPUSH
17648: CALL_OW 467
// artifactsPos := [ [ ] , [ ] , [ ] ] ;
17652: LD_ADDR_EXP 59
17656: PUSH
17657: EMPTY
17658: PUSH
17659: EMPTY
17660: PUSH
17661: EMPTY
17662: PUSH
17663: EMPTY
17664: LIST
17665: LIST
17666: LIST
17667: ST_TO_ADDR
// artifactsRecharge := [ 0 0$30 * Difficulty , 1 1$20 * Difficulty , - 1 ] ;
17668: LD_ADDR_EXP 60
17672: PUSH
17673: LD_INT 1050
17675: PUSH
17676: LD_OWVAR 67
17680: MUL
17681: PUSH
17682: LD_INT 2800
17684: PUSH
17685: LD_OWVAR 67
17689: MUL
17690: PUSH
17691: LD_INT 1
17693: NEG
17694: PUSH
17695: EMPTY
17696: LIST
17697: LIST
17698: LIST
17699: ST_TO_ADDR
// artifactsSibCost := [ 10 , 35 , 100 ] ;
17700: LD_ADDR_EXP 61
17704: PUSH
17705: LD_INT 10
17707: PUSH
17708: LD_INT 35
17710: PUSH
17711: LD_INT 100
17713: PUSH
17714: EMPTY
17715: LIST
17716: LIST
17717: LIST
17718: ST_TO_ADDR
// artifactsResearched := [ 0 , 0 , 0 ] ;
17719: LD_ADDR_EXP 62
17723: PUSH
17724: LD_INT 0
17726: PUSH
17727: LD_INT 0
17729: PUSH
17730: LD_INT 0
17732: PUSH
17733: EMPTY
17734: LIST
17735: LIST
17736: LIST
17737: ST_TO_ADDR
// artifactsResDifficulty := [ 300 , 500 , 800 ] ;
17738: LD_ADDR_EXP 64
17742: PUSH
17743: LD_INT 300
17745: PUSH
17746: LD_INT 500
17748: PUSH
17749: LD_INT 800
17751: PUSH
17752: EMPTY
17753: LIST
17754: LIST
17755: LIST
17756: ST_TO_ADDR
// artifactsResProgress := [ 0 , 0 , 0 ] ;
17757: LD_ADDR_EXP 65
17761: PUSH
17762: LD_INT 0
17764: PUSH
17765: LD_INT 0
17767: PUSH
17768: LD_INT 0
17770: PUSH
17771: EMPTY
17772: LIST
17773: LIST
17774: LIST
17775: ST_TO_ADDR
// artifactsLabs := [ 0 , 0 , 0 ] ;
17776: LD_ADDR_EXP 66
17780: PUSH
17781: LD_INT 0
17783: PUSH
17784: LD_INT 0
17786: PUSH
17787: LD_INT 0
17789: PUSH
17790: EMPTY
17791: LIST
17792: LIST
17793: LIST
17794: ST_TO_ADDR
// artifactsLabsWorking := [ 0 , 0 , 0 ] ;
17795: LD_ADDR_EXP 63
17799: PUSH
17800: LD_INT 0
17802: PUSH
17803: LD_INT 0
17805: PUSH
17806: LD_INT 0
17808: PUSH
17809: EMPTY
17810: LIST
17811: LIST
17812: LIST
17813: ST_TO_ADDR
// artifactsButtons := [ [ art_use_eye , art_place , art_exp_left ] , [ art_use_sibexplosion , art_unit , art_exp_mid ] , [ art_use_teleport , art_place , art_exp_right ] ] ;
17814: LD_ADDR_EXP 67
17818: PUSH
17819: LD_INT 4
17821: PUSH
17822: LD_INT 3
17824: PUSH
17825: LD_INT 1
17827: PUSH
17828: EMPTY
17829: LIST
17830: LIST
17831: LIST
17832: PUSH
17833: LD_INT 5
17835: PUSH
17836: LD_INT 4
17838: PUSH
17839: LD_INT 2
17841: PUSH
17842: EMPTY
17843: LIST
17844: LIST
17845: LIST
17846: PUSH
17847: LD_INT 6
17849: PUSH
17850: LD_INT 3
17852: PUSH
17853: LD_INT 3
17855: PUSH
17856: EMPTY
17857: LIST
17858: LIST
17859: LIST
17860: PUSH
17861: EMPTY
17862: LIST
17863: LIST
17864: LIST
17865: ST_TO_ADDR
// artifactsReady := [ 0 , 0 , 0 ] ;
17866: LD_ADDR_EXP 68
17870: PUSH
17871: LD_INT 0
17873: PUSH
17874: LD_INT 0
17876: PUSH
17877: LD_INT 0
17879: PUSH
17880: EMPTY
17881: LIST
17882: LIST
17883: LIST
17884: ST_TO_ADDR
// end ;
17885: LD_VAR 0 1
17889: RET
// every 0 0$1 trigger GetTech ( tech_artifact , 7 ) = state_researched do var i , pos , j , labs , nearestLab ;
17890: LD_INT 24
17892: PPUSH
17893: LD_INT 7
17895: PPUSH
17896: CALL_OW 321
17900: PUSH
17901: LD_INT 2
17903: EQUAL
17904: IFFALSE 18830
17906: GO 17908
17908: DISABLE
17909: LD_INT 0
17911: PPUSH
17912: PPUSH
17913: PPUSH
17914: PPUSH
17915: PPUSH
// begin enable ;
17916: ENABLE
// for i = 1 to 3 do
17917: LD_ADDR_VAR 0 1
17921: PUSH
17922: DOUBLE
17923: LD_INT 1
17925: DEC
17926: ST_TO_ADDR
17927: LD_INT 3
17929: PUSH
17930: FOR_TO
17931: IFFALSE 18828
// begin pos := FindArtifact ( i + 2 ) ;
17933: LD_ADDR_VAR 0 2
17937: PUSH
17938: LD_VAR 0 1
17942: PUSH
17943: LD_INT 2
17945: PLUS
17946: PPUSH
17947: CALL_OW 469
17951: ST_TO_ADDR
// artifactsPos := Replace ( artifactsPos , i , pos ) ;
17952: LD_ADDR_EXP 59
17956: PUSH
17957: LD_EXP 59
17961: PPUSH
17962: LD_VAR 0 1
17966: PPUSH
17967: LD_VAR 0 2
17971: PPUSH
17972: CALL_OW 1
17976: ST_TO_ADDR
// if pos then
17977: LD_VAR 0 2
17981: IFFALSE 18689
// begin case i of 1 :
17983: LD_VAR 0 1
17987: PUSH
17988: LD_INT 1
17990: DOUBLE
17991: EQUAL
17992: IFTRUE 17996
17994: GO 18073
17996: POP
// labs := FilterAllUnits ( [ [ f_side , 7 ] , [ f_nation , 1 ] , [ f_or , [ f_btype , b_lab_full ] , [ f_btype , b_lab_half ] , [ f_btype , b_lab_siberium ] ] ] ) ; 2 :
17997: LD_ADDR_VAR 0 4
18001: PUSH
18002: LD_INT 22
18004: PUSH
18005: LD_INT 7
18007: PUSH
18008: EMPTY
18009: LIST
18010: LIST
18011: PUSH
18012: LD_INT 23
18014: PUSH
18015: LD_INT 1
18017: PUSH
18018: EMPTY
18019: LIST
18020: LIST
18021: PUSH
18022: LD_INT 2
18024: PUSH
18025: LD_INT 30
18027: PUSH
18028: LD_INT 8
18030: PUSH
18031: EMPTY
18032: LIST
18033: LIST
18034: PUSH
18035: LD_INT 30
18037: PUSH
18038: LD_INT 7
18040: PUSH
18041: EMPTY
18042: LIST
18043: LIST
18044: PUSH
18045: LD_INT 30
18047: PUSH
18048: LD_INT 11
18050: PUSH
18051: EMPTY
18052: LIST
18053: LIST
18054: PUSH
18055: EMPTY
18056: LIST
18057: LIST
18058: LIST
18059: LIST
18060: PUSH
18061: EMPTY
18062: LIST
18063: LIST
18064: LIST
18065: PPUSH
18066: CALL_OW 69
18070: ST_TO_ADDR
18071: GO 18181
18073: LD_INT 2
18075: DOUBLE
18076: EQUAL
18077: IFTRUE 18081
18079: GO 18158
18081: POP
// labs := FilterAllUnits ( [ [ f_side , 7 ] , [ f_nation , 3 ] , [ f_or , [ f_btype , b_lab_full ] , [ f_btype , b_lab_half ] , [ f_btype , b_lab_siberium ] ] ] ) ; 3 :
18082: LD_ADDR_VAR 0 4
18086: PUSH
18087: LD_INT 22
18089: PUSH
18090: LD_INT 7
18092: PUSH
18093: EMPTY
18094: LIST
18095: LIST
18096: PUSH
18097: LD_INT 23
18099: PUSH
18100: LD_INT 3
18102: PUSH
18103: EMPTY
18104: LIST
18105: LIST
18106: PUSH
18107: LD_INT 2
18109: PUSH
18110: LD_INT 30
18112: PUSH
18113: LD_INT 8
18115: PUSH
18116: EMPTY
18117: LIST
18118: LIST
18119: PUSH
18120: LD_INT 30
18122: PUSH
18123: LD_INT 7
18125: PUSH
18126: EMPTY
18127: LIST
18128: LIST
18129: PUSH
18130: LD_INT 30
18132: PUSH
18133: LD_INT 11
18135: PUSH
18136: EMPTY
18137: LIST
18138: LIST
18139: PUSH
18140: EMPTY
18141: LIST
18142: LIST
18143: LIST
18144: LIST
18145: PUSH
18146: EMPTY
18147: LIST
18148: LIST
18149: LIST
18150: PPUSH
18151: CALL_OW 69
18155: ST_TO_ADDR
18156: GO 18181
18158: LD_INT 3
18160: DOUBLE
18161: EQUAL
18162: IFTRUE 18166
18164: GO 18180
18166: POP
// labs := [ alien ] ; end ;
18167: LD_ADDR_VAR 0 4
18171: PUSH
18172: LD_INT 1
18174: PUSH
18175: EMPTY
18176: LIST
18177: ST_TO_ADDR
18178: GO 18181
18180: POP
// if not labs then
18181: LD_VAR 0 4
18185: NOT
18186: IFFALSE 18190
// continue ;
18188: GO 17930
// nearestLab := NearestUnitToXY ( labs , artifactsPos [ i ] [ 1 ] , artifactsPos [ i ] [ 2 ] ) ;
18190: LD_ADDR_VAR 0 5
18194: PUSH
18195: LD_VAR 0 4
18199: PPUSH
18200: LD_EXP 59
18204: PUSH
18205: LD_VAR 0 1
18209: ARRAY
18210: PUSH
18211: LD_INT 1
18213: ARRAY
18214: PPUSH
18215: LD_EXP 59
18219: PUSH
18220: LD_VAR 0 1
18224: ARRAY
18225: PUSH
18226: LD_INT 2
18228: ARRAY
18229: PPUSH
18230: CALL_OW 73
18234: ST_TO_ADDR
// if not nearestLab or nearestLab <> artifactsLabs [ i ] then
18235: LD_VAR 0 5
18239: NOT
18240: PUSH
18241: LD_VAR 0 5
18245: PUSH
18246: LD_EXP 66
18250: PUSH
18251: LD_VAR 0 1
18255: ARRAY
18256: NONEQUAL
18257: OR
18258: IFFALSE 18363
// begin SetArtifactUse ( 7 , artifactsButtons [ i ] [ 3 ] , art_no , artifactsLabs [ i ] ) ;
18260: LD_INT 7
18262: PPUSH
18263: LD_EXP 67
18267: PUSH
18268: LD_VAR 0 1
18272: ARRAY
18273: PUSH
18274: LD_INT 3
18276: ARRAY
18277: PPUSH
18278: LD_INT 0
18280: PPUSH
18281: LD_EXP 66
18285: PUSH
18286: LD_VAR 0 1
18290: ARRAY
18291: PPUSH
18292: CALL_OW 468
// SetArtifactUse ( 7 , artifactsButtons [ i ] [ 1 ] , art_no , artifactsLabs [ i ] ) ;
18296: LD_INT 7
18298: PPUSH
18299: LD_EXP 67
18303: PUSH
18304: LD_VAR 0 1
18308: ARRAY
18309: PUSH
18310: LD_INT 1
18312: ARRAY
18313: PPUSH
18314: LD_INT 0
18316: PPUSH
18317: LD_EXP 66
18321: PUSH
18322: LD_VAR 0 1
18326: ARRAY
18327: PPUSH
18328: CALL_OW 468
// if nearestLab then
18332: LD_VAR 0 5
18336: IFFALSE 18363
// artifactsLabs := Replace ( artifactsLabs , i , nearestLab ) ;
18338: LD_ADDR_EXP 66
18342: PUSH
18343: LD_EXP 66
18347: PPUSH
18348: LD_VAR 0 1
18352: PPUSH
18353: LD_VAR 0 5
18357: PPUSH
18358: CALL_OW 1
18362: ST_TO_ADDR
// end ; if not nearestLab then
18363: LD_VAR 0 5
18367: NOT
18368: IFFALSE 18372
// continue ;
18370: GO 17930
// if GetDistUnitXY ( nearestLab , artifactsPos [ i ] [ 1 ] , artifactsPos [ i ] [ 2 ] ) < 8 then
18372: LD_VAR 0 5
18376: PPUSH
18377: LD_EXP 59
18381: PUSH
18382: LD_VAR 0 1
18386: ARRAY
18387: PUSH
18388: LD_INT 1
18390: ARRAY
18391: PPUSH
18392: LD_EXP 59
18396: PUSH
18397: LD_VAR 0 1
18401: ARRAY
18402: PUSH
18403: LD_INT 2
18405: ARRAY
18406: PPUSH
18407: CALL_OW 297
18411: PUSH
18412: LD_INT 8
18414: LESS
18415: IFFALSE 18612
// begin if not artifactsResearched [ i ] then
18417: LD_EXP 62
18421: PUSH
18422: LD_VAR 0 1
18426: ARRAY
18427: NOT
18428: IFFALSE 18509
// begin if BuildingStatus ( nearestLab ) = bs_idle then
18430: LD_VAR 0 5
18434: PPUSH
18435: CALL_OW 461
18439: PUSH
18440: LD_INT 2
18442: EQUAL
18443: IFFALSE 18477
// SetArtifactUse ( 7 , artifactsButtons [ i ] [ 3 ] , art_instant , nearestLab ) else
18445: LD_INT 7
18447: PPUSH
18448: LD_EXP 67
18452: PUSH
18453: LD_VAR 0 1
18457: ARRAY
18458: PUSH
18459: LD_INT 3
18461: ARRAY
18462: PPUSH
18463: LD_INT 2
18465: PPUSH
18466: LD_VAR 0 5
18470: PPUSH
18471: CALL_OW 468
18475: GO 18507
// SetArtifactUse ( 7 , artifactsButtons [ i ] [ 3 ] , art_gray , nearestLab ) ;
18477: LD_INT 7
18479: PPUSH
18480: LD_EXP 67
18484: PUSH
18485: LD_VAR 0 1
18489: ARRAY
18490: PUSH
18491: LD_INT 3
18493: ARRAY
18494: PPUSH
18495: LD_INT 1
18497: PPUSH
18498: LD_VAR 0 5
18502: PPUSH
18503: CALL_OW 468
// end else
18507: GO 18610
// begin if BuildingStatus ( nearestLab ) = bs_idle and artifactsReady [ i ] then
18509: LD_VAR 0 5
18513: PPUSH
18514: CALL_OW 461
18518: PUSH
18519: LD_INT 2
18521: EQUAL
18522: PUSH
18523: LD_EXP 68
18527: PUSH
18528: LD_VAR 0 1
18532: ARRAY
18533: AND
18534: IFFALSE 18580
// SetArtifactUse ( 7 , artifactsButtons [ i ] [ 1 ] , artifactsButtons [ i ] [ 2 ] , nearestLab ) else
18536: LD_INT 7
18538: PPUSH
18539: LD_EXP 67
18543: PUSH
18544: LD_VAR 0 1
18548: ARRAY
18549: PUSH
18550: LD_INT 1
18552: ARRAY
18553: PPUSH
18554: LD_EXP 67
18558: PUSH
18559: LD_VAR 0 1
18563: ARRAY
18564: PUSH
18565: LD_INT 2
18567: ARRAY
18568: PPUSH
18569: LD_VAR 0 5
18573: PPUSH
18574: CALL_OW 468
18578: GO 18610
// SetArtifactUse ( 7 , artifactsButtons [ i ] [ 1 ] , art_gray , nearestLab ) end ;
18580: LD_INT 7
18582: PPUSH
18583: LD_EXP 67
18587: PUSH
18588: LD_VAR 0 1
18592: ARRAY
18593: PUSH
18594: LD_INT 1
18596: ARRAY
18597: PPUSH
18598: LD_INT 1
18600: PPUSH
18601: LD_VAR 0 5
18605: PPUSH
18606: CALL_OW 468
// end else
18610: GO 18687
// begin if not artifactsResearched [ i ] then
18612: LD_EXP 62
18616: PUSH
18617: LD_VAR 0 1
18621: ARRAY
18622: NOT
18623: IFFALSE 18657
// SetArtifactUse ( 7 , artifactsButtons [ i ] [ 3 ] , art_no , nearestLab ) else
18625: LD_INT 7
18627: PPUSH
18628: LD_EXP 67
18632: PUSH
18633: LD_VAR 0 1
18637: ARRAY
18638: PUSH
18639: LD_INT 3
18641: ARRAY
18642: PPUSH
18643: LD_INT 0
18645: PPUSH
18646: LD_VAR 0 5
18650: PPUSH
18651: CALL_OW 468
18655: GO 18687
// SetArtifactUse ( 7 , artifactsButtons [ i ] [ 1 ] , art_no , nearestLab ) ;
18657: LD_INT 7
18659: PPUSH
18660: LD_EXP 67
18664: PUSH
18665: LD_VAR 0 1
18669: ARRAY
18670: PUSH
18671: LD_INT 1
18673: ARRAY
18674: PPUSH
18675: LD_INT 0
18677: PPUSH
18678: LD_VAR 0 5
18682: PPUSH
18683: CALL_OW 468
// end ; end else
18687: GO 18826
// begin if not artifactsLabs [ i ] then
18689: LD_EXP 66
18693: PUSH
18694: LD_VAR 0 1
18698: ARRAY
18699: NOT
18700: IFFALSE 18704
// continue ;
18702: GO 17930
// SetArtifactUse ( 7 , artifactsButtons [ i ] [ 3 ] , art_no , artifactsLabs [ i ] ) ;
18704: LD_INT 7
18706: PPUSH
18707: LD_EXP 67
18711: PUSH
18712: LD_VAR 0 1
18716: ARRAY
18717: PUSH
18718: LD_INT 3
18720: ARRAY
18721: PPUSH
18722: LD_INT 0
18724: PPUSH
18725: LD_EXP 66
18729: PUSH
18730: LD_VAR 0 1
18734: ARRAY
18735: PPUSH
18736: CALL_OW 468
// SetArtifactUse ( 7 , artifactsButtons [ i ] [ 1 ] , art_no , artifactsLabs [ i ] ) ;
18740: LD_INT 7
18742: PPUSH
18743: LD_EXP 67
18747: PUSH
18748: LD_VAR 0 1
18752: ARRAY
18753: PUSH
18754: LD_INT 1
18756: ARRAY
18757: PPUSH
18758: LD_INT 0
18760: PPUSH
18761: LD_EXP 66
18765: PUSH
18766: LD_VAR 0 1
18770: ARRAY
18771: PPUSH
18772: CALL_OW 468
// if artifactsLabsWorking [ i ] then
18776: LD_EXP 63
18780: PUSH
18781: LD_VAR 0 1
18785: ARRAY
18786: IFFALSE 18826
// begin artifactsLabsWorking := Replace ( artifactsLabsWorking , i , false ) ;
18788: LD_ADDR_EXP 63
18792: PUSH
18793: LD_EXP 63
18797: PPUSH
18798: LD_VAR 0 1
18802: PPUSH
18803: LD_INT 0
18805: PPUSH
18806: CALL_OW 1
18810: ST_TO_ADDR
// ComCancel ( artifactsLabs [ i ] ) ;
18811: LD_EXP 66
18815: PUSH
18816: LD_VAR 0 1
18820: ARRAY
18821: PPUSH
18822: CALL_OW 127
// end ; end ; end ;
18826: GO 17930
18828: POP
18829: POP
// end ;
18830: PPOPN 5
18832: END
// on ArtifactUsed ( side , icon , x , y ) do var i , lab , time , list , un ;
18833: LD_INT 0
18835: PPUSH
18836: PPUSH
18837: PPUSH
18838: PPUSH
18839: PPUSH
// begin if icon = artifactsButtons [ 1 ] [ 3 ] then
18840: LD_VAR 0 2
18844: PUSH
18845: LD_EXP 67
18849: PUSH
18850: LD_INT 1
18852: ARRAY
18853: PUSH
18854: LD_INT 3
18856: ARRAY
18857: EQUAL
18858: IFFALSE 18981
// begin lab := artifactsLabs [ 1 ] ;
18860: LD_ADDR_VAR 0 6
18864: PUSH
18865: LD_EXP 66
18869: PUSH
18870: LD_INT 1
18872: ARRAY
18873: ST_TO_ADDR
// if not lab then
18874: LD_VAR 0 6
18878: NOT
18879: IFFALSE 18883
// exit ;
18881: GO 19929
// SetSpecResearch ( lab , artifactsResDifficulty [ 1 ] , true ) ;
18883: LD_VAR 0 6
18887: PPUSH
18888: LD_EXP 64
18892: PUSH
18893: LD_INT 1
18895: ARRAY
18896: PPUSH
18897: LD_INT 1
18899: PPUSH
18900: CALL_OW 486
// if artifactsResProgress [ 1 ] then
18904: LD_EXP 65
18908: PUSH
18909: LD_INT 1
18911: ARRAY
18912: IFFALSE 18932
// SetWorkingProgress ( lab , artifactsResProgress [ 1 ] ) ;
18914: LD_VAR 0 6
18918: PPUSH
18919: LD_EXP 65
18923: PUSH
18924: LD_INT 1
18926: ARRAY
18927: PPUSH
18928: CALL_OW 329
// artifactsLabsWorking := Replace ( artifactsLabsWorking , 1 , 1 ) ;
18932: LD_ADDR_EXP 63
18936: PUSH
18937: LD_EXP 63
18941: PPUSH
18942: LD_INT 1
18944: PPUSH
18945: LD_INT 1
18947: PPUSH
18948: CALL_OW 1
18952: ST_TO_ADDR
// SetArtifactUse ( 7 , artifactsButtons [ 1 ] [ 3 ] , art_no , lab ) ;
18953: LD_INT 7
18955: PPUSH
18956: LD_EXP 67
18960: PUSH
18961: LD_INT 1
18963: ARRAY
18964: PUSH
18965: LD_INT 3
18967: ARRAY
18968: PPUSH
18969: LD_INT 0
18971: PPUSH
18972: LD_VAR 0 6
18976: PPUSH
18977: CALL_OW 468
// end ; if icon = artifactsButtons [ 2 ] [ 3 ] then
18981: LD_VAR 0 2
18985: PUSH
18986: LD_EXP 67
18990: PUSH
18991: LD_INT 2
18993: ARRAY
18994: PUSH
18995: LD_INT 3
18997: ARRAY
18998: EQUAL
18999: IFFALSE 19122
// begin lab := artifactsLabs [ 2 ] ;
19001: LD_ADDR_VAR 0 6
19005: PUSH
19006: LD_EXP 66
19010: PUSH
19011: LD_INT 2
19013: ARRAY
19014: ST_TO_ADDR
// if not lab then
19015: LD_VAR 0 6
19019: NOT
19020: IFFALSE 19024
// exit ;
19022: GO 19929
// SetSpecResearch ( lab , artifactsResDifficulty [ 2 ] , true ) ;
19024: LD_VAR 0 6
19028: PPUSH
19029: LD_EXP 64
19033: PUSH
19034: LD_INT 2
19036: ARRAY
19037: PPUSH
19038: LD_INT 1
19040: PPUSH
19041: CALL_OW 486
// if artifactsResProgress [ 2 ] then
19045: LD_EXP 65
19049: PUSH
19050: LD_INT 2
19052: ARRAY
19053: IFFALSE 19073
// SetWorkingProgress ( lab , artifactsResProgress [ 2 ] ) ;
19055: LD_VAR 0 6
19059: PPUSH
19060: LD_EXP 65
19064: PUSH
19065: LD_INT 2
19067: ARRAY
19068: PPUSH
19069: CALL_OW 329
// artifactsLabsWorking := Replace ( artifactsLabsWorking , 2 , 1 ) ;
19073: LD_ADDR_EXP 63
19077: PUSH
19078: LD_EXP 63
19082: PPUSH
19083: LD_INT 2
19085: PPUSH
19086: LD_INT 1
19088: PPUSH
19089: CALL_OW 1
19093: ST_TO_ADDR
// SetArtifactUse ( 7 , artifactsButtons [ 2 ] [ 3 ] , art_no , lab ) ;
19094: LD_INT 7
19096: PPUSH
19097: LD_EXP 67
19101: PUSH
19102: LD_INT 2
19104: ARRAY
19105: PUSH
19106: LD_INT 3
19108: ARRAY
19109: PPUSH
19110: LD_INT 0
19112: PPUSH
19113: LD_VAR 0 6
19117: PPUSH
19118: CALL_OW 468
// end ; if icon = artifactsButtons [ 3 ] [ 3 ] then
19122: LD_VAR 0 2
19126: PUSH
19127: LD_EXP 67
19131: PUSH
19132: LD_INT 3
19134: ARRAY
19135: PUSH
19136: LD_INT 3
19138: ARRAY
19139: EQUAL
19140: IFFALSE 19263
// begin lab := artifactsLabs [ 3 ] ;
19142: LD_ADDR_VAR 0 6
19146: PUSH
19147: LD_EXP 66
19151: PUSH
19152: LD_INT 3
19154: ARRAY
19155: ST_TO_ADDR
// if not lab then
19156: LD_VAR 0 6
19160: NOT
19161: IFFALSE 19165
// exit ;
19163: GO 19929
// SetSpecResearch ( lab , artifactsResDifficulty [ 3 ] , true ) ;
19165: LD_VAR 0 6
19169: PPUSH
19170: LD_EXP 64
19174: PUSH
19175: LD_INT 3
19177: ARRAY
19178: PPUSH
19179: LD_INT 1
19181: PPUSH
19182: CALL_OW 486
// if artifactsResProgress [ 3 ] then
19186: LD_EXP 65
19190: PUSH
19191: LD_INT 3
19193: ARRAY
19194: IFFALSE 19214
// SetWorkingProgress ( lab , artifactsResProgress [ 3 ] ) ;
19196: LD_VAR 0 6
19200: PPUSH
19201: LD_EXP 65
19205: PUSH
19206: LD_INT 3
19208: ARRAY
19209: PPUSH
19210: CALL_OW 329
// artifactsLabsWorking := Replace ( artifactsLabsWorking , 3 , 1 ) ;
19214: LD_ADDR_EXP 63
19218: PUSH
19219: LD_EXP 63
19223: PPUSH
19224: LD_INT 3
19226: PPUSH
19227: LD_INT 1
19229: PPUSH
19230: CALL_OW 1
19234: ST_TO_ADDR
// SetArtifactUse ( 7 , artifactsButtons [ 3 ] [ 3 ] , art_no , lab ) ;
19235: LD_INT 7
19237: PPUSH
19238: LD_EXP 67
19242: PUSH
19243: LD_INT 3
19245: ARRAY
19246: PUSH
19247: LD_INT 3
19249: ARRAY
19250: PPUSH
19251: LD_INT 0
19253: PPUSH
19254: LD_VAR 0 6
19258: PPUSH
19259: CALL_OW 468
// end ; if icon = artifactsButtons [ 1 ] [ 1 ] then
19263: LD_VAR 0 2
19267: PUSH
19268: LD_EXP 67
19272: PUSH
19273: LD_INT 1
19275: ARRAY
19276: PUSH
19277: LD_INT 1
19279: ARRAY
19280: EQUAL
19281: IFFALSE 19439
// begin lab := artifactsLabs [ 1 ] ;
19283: LD_ADDR_VAR 0 6
19287: PUSH
19288: LD_EXP 66
19292: PUSH
19293: LD_INT 1
19295: ARRAY
19296: ST_TO_ADDR
// if GetBaseMaterials ( GetBase ( lab ) ) [ 3 ] < artifactsSibCost [ 1 ] then
19297: LD_VAR 0 6
19301: PPUSH
19302: CALL_OW 274
19306: PPUSH
19307: CALL 93487 0 1
19311: PUSH
19312: LD_INT 3
19314: ARRAY
19315: PUSH
19316: LD_EXP 61
19320: PUSH
19321: LD_INT 1
19323: ARRAY
19324: LESS
19325: IFFALSE 19339
// begin HintSpec ( ArtifactCost , 2 ) ;
19327: LD_STRING ArtifactCost
19329: PPUSH
19330: LD_INT 2
19332: PPUSH
19333: CALL_OW 338
// exit ;
19337: GO 19929
// end ; artifactsReady := Replace ( artifactsReady , 1 , false ) ;
19339: LD_ADDR_EXP 68
19343: PUSH
19344: LD_EXP 68
19348: PPUSH
19349: LD_INT 1
19351: PPUSH
19352: LD_INT 0
19354: PPUSH
19355: CALL_OW 1
19359: ST_TO_ADDR
// PlaceSeeing ( x , y , 7 , - 12 ) ;
19360: LD_VAR 0 3
19364: PPUSH
19365: LD_VAR 0 4
19369: PPUSH
19370: LD_INT 7
19372: PPUSH
19373: LD_INT 12
19375: NEG
19376: PPUSH
19377: CALL_OW 330
// wait ( 0 0$30 ) ;
19381: LD_INT 1050
19383: PPUSH
19384: CALL_OW 67
// RemoveSeeing ( x , y , 7 ) ;
19388: LD_VAR 0 3
19392: PPUSH
19393: LD_VAR 0 4
19397: PPUSH
19398: LD_INT 7
19400: PPUSH
19401: CALL_OW 331
// wait ( artifactsRecharge [ 1 ] ) ;
19405: LD_EXP 60
19409: PUSH
19410: LD_INT 1
19412: ARRAY
19413: PPUSH
19414: CALL_OW 67
// artifactsReady := Replace ( artifactsReady , 1 , true ) ;
19418: LD_ADDR_EXP 68
19422: PUSH
19423: LD_EXP 68
19427: PPUSH
19428: LD_INT 1
19430: PPUSH
19431: LD_INT 1
19433: PPUSH
19434: CALL_OW 1
19438: ST_TO_ADDR
// end ; if icon = artifactsButtons [ 2 ] [ 1 ] then
19439: LD_VAR 0 2
19443: PUSH
19444: LD_EXP 67
19448: PUSH
19449: LD_INT 2
19451: ARRAY
19452: PUSH
19453: LD_INT 1
19455: ARRAY
19456: EQUAL
19457: IFFALSE 19683
// begin lab := artifactsLabs [ 2 ] ;
19459: LD_ADDR_VAR 0 6
19463: PUSH
19464: LD_EXP 66
19468: PUSH
19469: LD_INT 2
19471: ARRAY
19472: ST_TO_ADDR
// if not x in FilterAllUnits ( [ [ f_enemy , 7 ] , [ f_or , [ f_engine , engine_siberite ] , [ f_btype , b_siberite_power ] , [ f_btype , b_siberite_mine ] , [ f_bweapon , ru_time_lapser ] , [ f_weapon , ru_time_lapser ] ] ] ) then
19473: LD_VAR 0 3
19477: PUSH
19478: LD_INT 81
19480: PUSH
19481: LD_INT 7
19483: PUSH
19484: EMPTY
19485: LIST
19486: LIST
19487: PUSH
19488: LD_INT 2
19490: PUSH
19491: LD_INT 32
19493: PUSH
19494: LD_INT 3
19496: PUSH
19497: EMPTY
19498: LIST
19499: LIST
19500: PUSH
19501: LD_INT 30
19503: PUSH
19504: LD_INT 28
19506: PUSH
19507: EMPTY
19508: LIST
19509: LIST
19510: PUSH
19511: LD_INT 30
19513: PUSH
19514: LD_INT 30
19516: PUSH
19517: EMPTY
19518: LIST
19519: LIST
19520: PUSH
19521: LD_INT 35
19523: PUSH
19524: LD_INT 49
19526: PUSH
19527: EMPTY
19528: LIST
19529: LIST
19530: PUSH
19531: LD_INT 34
19533: PUSH
19534: LD_INT 49
19536: PUSH
19537: EMPTY
19538: LIST
19539: LIST
19540: PUSH
19541: EMPTY
19542: LIST
19543: LIST
19544: LIST
19545: LIST
19546: LIST
19547: LIST
19548: PUSH
19549: EMPTY
19550: LIST
19551: LIST
19552: PPUSH
19553: CALL_OW 69
19557: IN
19558: NOT
19559: IFFALSE 19563
// exit ;
19561: GO 19929
// if GetBaseMaterials ( GetBase ( lab ) ) [ 3 ] < artifactsSibCost [ 2 ] then
19563: LD_VAR 0 6
19567: PPUSH
19568: CALL_OW 274
19572: PPUSH
19573: CALL 93487 0 1
19577: PUSH
19578: LD_INT 3
19580: ARRAY
19581: PUSH
19582: LD_EXP 61
19586: PUSH
19587: LD_INT 2
19589: ARRAY
19590: LESS
19591: IFFALSE 19605
// begin HintSpec ( ArtifactCost , 2 ) ;
19593: LD_STRING ArtifactCost
19595: PPUSH
19596: LD_INT 2
19598: PPUSH
19599: CALL_OW 338
// exit ;
19603: GO 19929
// end ; artifactsReady := Replace ( artifactsReady , 2 , false ) ;
19605: LD_ADDR_EXP 68
19609: PUSH
19610: LD_EXP 68
19614: PPUSH
19615: LD_INT 2
19617: PPUSH
19618: LD_INT 0
19620: PPUSH
19621: CALL_OW 1
19625: ST_TO_ADDR
// KillUnit ( x ) ;
19626: LD_VAR 0 3
19630: PPUSH
19631: CALL_OW 66
// artifactDestroyCounter := artifactDestroyCounter + 1 ;
19635: LD_ADDR_EXP 13
19639: PUSH
19640: LD_EXP 13
19644: PUSH
19645: LD_INT 1
19647: PLUS
19648: ST_TO_ADDR
// wait ( artifactsRecharge [ 2 ] ) ;
19649: LD_EXP 60
19653: PUSH
19654: LD_INT 2
19656: ARRAY
19657: PPUSH
19658: CALL_OW 67
// artifactsReady := Replace ( artifactsReady , 2 , true ) ;
19662: LD_ADDR_EXP 68
19666: PUSH
19667: LD_EXP 68
19671: PPUSH
19672: LD_INT 2
19674: PPUSH
19675: LD_INT 1
19677: PPUSH
19678: CALL_OW 1
19682: ST_TO_ADDR
// end ; if icon = artifactsButtons [ 3 ] [ 1 ] then
19683: LD_VAR 0 2
19687: PUSH
19688: LD_EXP 67
19692: PUSH
19693: LD_INT 3
19695: ARRAY
19696: PUSH
19697: LD_INT 1
19699: ARRAY
19700: EQUAL
19701: IFFALSE 19929
// begin lab := artifactsLabs [ 3 ] ;
19703: LD_ADDR_VAR 0 6
19707: PUSH
19708: LD_EXP 66
19712: PUSH
19713: LD_INT 3
19715: ARRAY
19716: ST_TO_ADDR
// if GetBaseMaterials ( GetBase ( lab ) ) [ 3 ] < artifactsSibCost [ 3 ] then
19717: LD_VAR 0 6
19721: PPUSH
19722: CALL_OW 274
19726: PPUSH
19727: CALL 93487 0 1
19731: PUSH
19732: LD_INT 3
19734: ARRAY
19735: PUSH
19736: LD_EXP 61
19740: PUSH
19741: LD_INT 3
19743: ARRAY
19744: LESS
19745: IFFALSE 19759
// begin HintSpec ( ArtifactCost , 2 ) ;
19747: LD_STRING ArtifactCost
19749: PPUSH
19750: LD_INT 2
19752: PPUSH
19753: CALL_OW 338
// exit ;
19757: GO 19929
// end ; SetAreaMapShow ( teleportArea , 1 ) ;
19759: LD_INT 37
19761: PPUSH
19762: LD_INT 1
19764: PPUSH
19765: CALL_OW 424
// time := 0 0$30 ;
19769: LD_ADDR_VAR 0 7
19773: PUSH
19774: LD_INT 1050
19776: ST_TO_ADDR
// repeat display_strings := [ Am15a-1 , time ] ;
19777: LD_ADDR_OWVAR 47
19781: PUSH
19782: LD_STRING Am15a-1
19784: PUSH
19785: LD_VAR 0 7
19789: PUSH
19790: EMPTY
19791: LIST
19792: LIST
19793: ST_TO_ADDR
// wait ( 0 0$1 ) ;
19794: LD_INT 35
19796: PPUSH
19797: CALL_OW 67
// time := time - 0 0$1 ;
19801: LD_ADDR_VAR 0 7
19805: PUSH
19806: LD_VAR 0 7
19810: PUSH
19811: LD_INT 35
19813: MINUS
19814: ST_TO_ADDR
// until time = 0 0$00 ;
19815: LD_VAR 0 7
19819: PUSH
19820: LD_INT 0
19822: EQUAL
19823: IFFALSE 19777
// display_strings :=  ;
19825: LD_ADDR_OWVAR 47
19829: PUSH
19830: LD_STRING 
19832: ST_TO_ADDR
// SetAreaMapShow ( teleportArea , 0 ) ;
19833: LD_INT 37
19835: PPUSH
19836: LD_INT 0
19838: PPUSH
19839: CALL_OW 424
// list := FilterUnitsInArea ( teleportArea , [ f_not , [ f_type , unit_building ] ] ) ;
19843: LD_ADDR_VAR 0 8
19847: PUSH
19848: LD_INT 37
19850: PPUSH
19851: LD_INT 3
19853: PUSH
19854: LD_INT 21
19856: PUSH
19857: LD_INT 3
19859: PUSH
19860: EMPTY
19861: LIST
19862: LIST
19863: PUSH
19864: EMPTY
19865: LIST
19866: LIST
19867: PPUSH
19868: CALL_OW 70
19872: ST_TO_ADDR
// CenterOnXY ( x , y ) ;
19873: LD_VAR 0 3
19877: PPUSH
19878: LD_VAR 0 4
19882: PPUSH
19883: CALL_OW 84
// for un in list do
19887: LD_ADDR_VAR 0 9
19891: PUSH
19892: LD_VAR 0 8
19896: PUSH
19897: FOR_IN
19898: IFFALSE 19927
// TeleportUnit ( un , x , y , 12 , true ) ;
19900: LD_VAR 0 9
19904: PPUSH
19905: LD_VAR 0 3
19909: PPUSH
19910: LD_VAR 0 4
19914: PPUSH
19915: LD_INT 12
19917: PPUSH
19918: LD_INT 1
19920: PPUSH
19921: CALL_OW 483
19925: GO 19897
19927: POP
19928: POP
// end ; end ;
19929: PPOPN 9
19931: END
// on SpecResearchCancel ( lab , progress ) do var i , labNum ;
19932: LD_INT 0
19934: PPUSH
19935: PPUSH
// begin labNum := 0 ;
19936: LD_ADDR_VAR 0 4
19940: PUSH
19941: LD_INT 0
19943: ST_TO_ADDR
// for i = 1 to artifactsLabs do
19944: LD_ADDR_VAR 0 3
19948: PUSH
19949: DOUBLE
19950: LD_INT 1
19952: DEC
19953: ST_TO_ADDR
19954: LD_EXP 66
19958: PUSH
19959: FOR_TO
19960: IFFALSE 19994
// if artifactsLabs [ i ] = lab then
19962: LD_EXP 66
19966: PUSH
19967: LD_VAR 0 3
19971: ARRAY
19972: PUSH
19973: LD_VAR 0 1
19977: EQUAL
19978: IFFALSE 19992
// begin labNum := i ;
19980: LD_ADDR_VAR 0 4
19984: PUSH
19985: LD_VAR 0 3
19989: ST_TO_ADDR
// break ;
19990: GO 19994
// end ;
19992: GO 19959
19994: POP
19995: POP
// if not labNum then
19996: LD_VAR 0 4
20000: NOT
20001: IFFALSE 20005
// exit ;
20003: GO 20083
// SetArtifactUse ( 7 , artifactsButtons [ labNum ] [ 3 ] , art_instant , lab ) ;
20005: LD_INT 7
20007: PPUSH
20008: LD_EXP 67
20012: PUSH
20013: LD_VAR 0 4
20017: ARRAY
20018: PUSH
20019: LD_INT 3
20021: ARRAY
20022: PPUSH
20023: LD_INT 2
20025: PPUSH
20026: LD_VAR 0 1
20030: PPUSH
20031: CALL_OW 468
// artifactsResProgress := Replace ( artifactsResProgress , labNum , progress ) ;
20035: LD_ADDR_EXP 65
20039: PUSH
20040: LD_EXP 65
20044: PPUSH
20045: LD_VAR 0 4
20049: PPUSH
20050: LD_VAR 0 2
20054: PPUSH
20055: CALL_OW 1
20059: ST_TO_ADDR
// artifactsLabsWorking := Replace ( artifactsLabsWorking , labNum , 0 ) ;
20060: LD_ADDR_EXP 63
20064: PUSH
20065: LD_EXP 63
20069: PPUSH
20070: LD_VAR 0 4
20074: PPUSH
20075: LD_INT 0
20077: PPUSH
20078: CALL_OW 1
20082: ST_TO_ADDR
// end ;
20083: PPOPN 4
20085: END
// on SpecResearchComplete ( lab ) do var i , labNum ;
20086: LD_INT 0
20088: PPUSH
20089: PPUSH
// begin labNum := 0 ;
20090: LD_ADDR_VAR 0 3
20094: PUSH
20095: LD_INT 0
20097: ST_TO_ADDR
// for i = 1 to artifactsLabs do
20098: LD_ADDR_VAR 0 2
20102: PUSH
20103: DOUBLE
20104: LD_INT 1
20106: DEC
20107: ST_TO_ADDR
20108: LD_EXP 66
20112: PUSH
20113: FOR_TO
20114: IFFALSE 20148
// if artifactsLabs [ i ] = lab then
20116: LD_EXP 66
20120: PUSH
20121: LD_VAR 0 2
20125: ARRAY
20126: PUSH
20127: LD_VAR 0 1
20131: EQUAL
20132: IFFALSE 20146
// begin labNum := i ;
20134: LD_ADDR_VAR 0 3
20138: PUSH
20139: LD_VAR 0 2
20143: ST_TO_ADDR
// break ;
20144: GO 20148
// end ;
20146: GO 20113
20148: POP
20149: POP
// if not labNum then
20150: LD_VAR 0 3
20154: NOT
20155: IFFALSE 20159
// exit ;
20157: GO 20321
// SetArtifactUse ( 7 , artifactsButtons [ labNum ] [ 3 ] , art_no , lab ) ;
20159: LD_INT 7
20161: PPUSH
20162: LD_EXP 67
20166: PUSH
20167: LD_VAR 0 3
20171: ARRAY
20172: PUSH
20173: LD_INT 3
20175: ARRAY
20176: PPUSH
20177: LD_INT 0
20179: PPUSH
20180: LD_VAR 0 1
20184: PPUSH
20185: CALL_OW 468
// artifactsResearched := Replace ( artifactsResearched , labNum , true ) ;
20189: LD_ADDR_EXP 62
20193: PUSH
20194: LD_EXP 62
20198: PPUSH
20199: LD_VAR 0 3
20203: PPUSH
20204: LD_INT 1
20206: PPUSH
20207: CALL_OW 1
20211: ST_TO_ADDR
// artifactsReady := Replace ( artifactsReady , labNum , true ) ;
20212: LD_ADDR_EXP 68
20216: PUSH
20217: LD_EXP 68
20221: PPUSH
20222: LD_VAR 0 3
20226: PPUSH
20227: LD_INT 1
20229: PPUSH
20230: CALL_OW 1
20234: ST_TO_ADDR
// artifactsLabsWorking := Replace ( artifactsLabsWorking , labNum , false ) ;
20235: LD_ADDR_EXP 63
20239: PUSH
20240: LD_EXP 63
20244: PPUSH
20245: LD_VAR 0 3
20249: PPUSH
20250: LD_INT 0
20252: PPUSH
20253: CALL_OW 1
20257: ST_TO_ADDR
// case labNum of 1 :
20258: LD_VAR 0 3
20262: PUSH
20263: LD_INT 1
20265: DOUBLE
20266: EQUAL
20267: IFTRUE 20271
20269: GO 20282
20271: POP
// artifactIResearched := true ; 2 :
20272: LD_ADDR_EXP 9
20276: PUSH
20277: LD_INT 1
20279: ST_TO_ADDR
20280: GO 20321
20282: LD_INT 2
20284: DOUBLE
20285: EQUAL
20286: IFTRUE 20290
20288: GO 20301
20290: POP
// artifactIIResearched := true ; 3 :
20291: LD_ADDR_EXP 10
20295: PUSH
20296: LD_INT 1
20298: ST_TO_ADDR
20299: GO 20321
20301: LD_INT 3
20303: DOUBLE
20304: EQUAL
20305: IFTRUE 20309
20307: GO 20320
20309: POP
// artifactIIIResearched := true ; end ;
20310: LD_ADDR_EXP 11
20314: PUSH
20315: LD_INT 1
20317: ST_TO_ADDR
20318: GO 20321
20320: POP
// end ; end_of_file
20321: PPOPN 3
20323: END
// export ru_radar , ru_big_cargo_bay , us_hack , us_artillery , ar_bio_bomb ; every 1 do
20324: GO 20326
20326: DISABLE
// begin ru_radar := 98 ;
20327: LD_ADDR_EXP 69
20331: PUSH
20332: LD_INT 98
20334: ST_TO_ADDR
// ru_big_cargo_bay := 89 ;
20335: LD_ADDR_EXP 70
20339: PUSH
20340: LD_INT 89
20342: ST_TO_ADDR
// us_hack := 99 ;
20343: LD_ADDR_EXP 71
20347: PUSH
20348: LD_INT 99
20350: ST_TO_ADDR
// us_artillery := 97 ;
20351: LD_ADDR_EXP 72
20355: PUSH
20356: LD_INT 97
20358: ST_TO_ADDR
// ar_bio_bomb := 91 ;
20359: LD_ADDR_EXP 73
20363: PUSH
20364: LD_INT 91
20366: ST_TO_ADDR
// end ; end_of_file
20367: END
// export skirmish , debug_mc ; export mc_bases , mc_building_need_repair , mc_building_repairs , mc_need_heal , mc_healers , mc_build_list , mc_builders , mc_construct_list , mc_turret_list , mc_empty_turret_list , mc_busy_turret_list , mc_defender_limit , mc_repair_vehicle , mc_mines , mc_miners , mc_minefields , mc_crates , mc_crates_collector , mc_crates_area , mc_vehicles , mc_attack , mc_produce , mc_defender , mc_scan , mc_parking , mc_scan_area , mc_sides , mc_tech , mc_can_tame , mc_ape , mc_ape_in_lab , mc_taming , mc_build_upgrade , mc_lab , mc_lab_upgrade , mc_teleport_exit , mc_teleport_exit_set , mc_deposits_xy , mc_deposits_finder , mc_allowed_tower_weapons , mc_remote_driver , mc_class , mc_class_case_use ; export function InitMacro ; var i ; begin
20368: LD_INT 0
20370: PPUSH
20371: PPUSH
// skirmish := false ;
20372: LD_ADDR_EXP 74
20376: PUSH
20377: LD_INT 0
20379: ST_TO_ADDR
// debug_mc := false ;
20380: LD_ADDR_EXP 75
20384: PUSH
20385: LD_INT 0
20387: ST_TO_ADDR
// mc_bases := [ ] ;
20388: LD_ADDR_EXP 76
20392: PUSH
20393: EMPTY
20394: ST_TO_ADDR
// mc_sides := [ ] ;
20395: LD_ADDR_EXP 102
20399: PUSH
20400: EMPTY
20401: ST_TO_ADDR
// mc_building_need_repair := [ ] ;
20402: LD_ADDR_EXP 77
20406: PUSH
20407: EMPTY
20408: ST_TO_ADDR
// mc_building_repairs := [ ] ;
20409: LD_ADDR_EXP 78
20413: PUSH
20414: EMPTY
20415: ST_TO_ADDR
// mc_need_heal := [ ] ;
20416: LD_ADDR_EXP 79
20420: PUSH
20421: EMPTY
20422: ST_TO_ADDR
// mc_healers := [ ] ;
20423: LD_ADDR_EXP 80
20427: PUSH
20428: EMPTY
20429: ST_TO_ADDR
// mc_build_list := [ ] ;
20430: LD_ADDR_EXP 81
20434: PUSH
20435: EMPTY
20436: ST_TO_ADDR
// mc_build_upgrade := [ ] ;
20437: LD_ADDR_EXP 108
20441: PUSH
20442: EMPTY
20443: ST_TO_ADDR
// mc_builders := [ ] ;
20444: LD_ADDR_EXP 82
20448: PUSH
20449: EMPTY
20450: ST_TO_ADDR
// mc_construct_list := [ ] ;
20451: LD_ADDR_EXP 83
20455: PUSH
20456: EMPTY
20457: ST_TO_ADDR
// mc_turret_list := [ ] ;
20458: LD_ADDR_EXP 84
20462: PUSH
20463: EMPTY
20464: ST_TO_ADDR
// mc_empty_turret_list := [ ] ;
20465: LD_ADDR_EXP 85
20469: PUSH
20470: EMPTY
20471: ST_TO_ADDR
// mc_miners := [ ] ;
20472: LD_ADDR_EXP 90
20476: PUSH
20477: EMPTY
20478: ST_TO_ADDR
// mc_mines := [ ] ;
20479: LD_ADDR_EXP 89
20483: PUSH
20484: EMPTY
20485: ST_TO_ADDR
// mc_minefields := [ ] ;
20486: LD_ADDR_EXP 91
20490: PUSH
20491: EMPTY
20492: ST_TO_ADDR
// mc_crates := [ ] ;
20493: LD_ADDR_EXP 92
20497: PUSH
20498: EMPTY
20499: ST_TO_ADDR
// mc_crates_collector := [ ] ;
20500: LD_ADDR_EXP 93
20504: PUSH
20505: EMPTY
20506: ST_TO_ADDR
// mc_crates_area := [ ] ;
20507: LD_ADDR_EXP 94
20511: PUSH
20512: EMPTY
20513: ST_TO_ADDR
// mc_vehicles := [ ] ;
20514: LD_ADDR_EXP 95
20518: PUSH
20519: EMPTY
20520: ST_TO_ADDR
// mc_attack := [ ] ;
20521: LD_ADDR_EXP 96
20525: PUSH
20526: EMPTY
20527: ST_TO_ADDR
// mc_produce := [ ] ;
20528: LD_ADDR_EXP 97
20532: PUSH
20533: EMPTY
20534: ST_TO_ADDR
// mc_defender := [ ] ;
20535: LD_ADDR_EXP 98
20539: PUSH
20540: EMPTY
20541: ST_TO_ADDR
// mc_parking := [ ] ;
20542: LD_ADDR_EXP 100
20546: PUSH
20547: EMPTY
20548: ST_TO_ADDR
// mc_busy_turret_list := [ ] ;
20549: LD_ADDR_EXP 86
20553: PUSH
20554: EMPTY
20555: ST_TO_ADDR
// mc_repair_vehicle := [ ] ;
20556: LD_ADDR_EXP 88
20560: PUSH
20561: EMPTY
20562: ST_TO_ADDR
// mc_scan := [ ] ;
20563: LD_ADDR_EXP 99
20567: PUSH
20568: EMPTY
20569: ST_TO_ADDR
// mc_scan_area := [ ] ;
20570: LD_ADDR_EXP 101
20574: PUSH
20575: EMPTY
20576: ST_TO_ADDR
// mc_tech := [ ] ;
20577: LD_ADDR_EXP 103
20581: PUSH
20582: EMPTY
20583: ST_TO_ADDR
// mc_class := [ ] ;
20584: LD_ADDR_EXP 117
20588: PUSH
20589: EMPTY
20590: ST_TO_ADDR
// mc_class_case_use := [ ] ;
20591: LD_ADDR_EXP 118
20595: PUSH
20596: EMPTY
20597: ST_TO_ADDR
// end ;
20598: LD_VAR 0 1
20602: RET
// export function MC_Kill ( base ) ; begin
20603: LD_INT 0
20605: PPUSH
// mc_bases := Replace ( mc_bases , base , [ ] ) ;
20606: LD_ADDR_EXP 76
20610: PUSH
20611: LD_EXP 76
20615: PPUSH
20616: LD_VAR 0 1
20620: PPUSH
20621: EMPTY
20622: PPUSH
20623: CALL_OW 1
20627: ST_TO_ADDR
// mc_building_need_repair := Replace ( mc_building_need_repair , base , [ ] ) ;
20628: LD_ADDR_EXP 77
20632: PUSH
20633: LD_EXP 77
20637: PPUSH
20638: LD_VAR 0 1
20642: PPUSH
20643: EMPTY
20644: PPUSH
20645: CALL_OW 1
20649: ST_TO_ADDR
// mc_building_repairs := Replace ( mc_building_repairs , base , [ ] ) ;
20650: LD_ADDR_EXP 78
20654: PUSH
20655: LD_EXP 78
20659: PPUSH
20660: LD_VAR 0 1
20664: PPUSH
20665: EMPTY
20666: PPUSH
20667: CALL_OW 1
20671: ST_TO_ADDR
// mc_need_heal := Replace ( mc_need_heal , base , [ ] ) ;
20672: LD_ADDR_EXP 79
20676: PUSH
20677: LD_EXP 79
20681: PPUSH
20682: LD_VAR 0 1
20686: PPUSH
20687: EMPTY
20688: PPUSH
20689: CALL_OW 1
20693: ST_TO_ADDR
// mc_healers := Replace ( mc_healers , base , [ ] ) ;
20694: LD_ADDR_EXP 80
20698: PUSH
20699: LD_EXP 80
20703: PPUSH
20704: LD_VAR 0 1
20708: PPUSH
20709: EMPTY
20710: PPUSH
20711: CALL_OW 1
20715: ST_TO_ADDR
// mc_build_list := Replace ( mc_build_list , base , [ ] ) ;
20716: LD_ADDR_EXP 81
20720: PUSH
20721: LD_EXP 81
20725: PPUSH
20726: LD_VAR 0 1
20730: PPUSH
20731: EMPTY
20732: PPUSH
20733: CALL_OW 1
20737: ST_TO_ADDR
// mc_builders := Replace ( mc_builders , base , [ ] ) ;
20738: LD_ADDR_EXP 82
20742: PUSH
20743: LD_EXP 82
20747: PPUSH
20748: LD_VAR 0 1
20752: PPUSH
20753: EMPTY
20754: PPUSH
20755: CALL_OW 1
20759: ST_TO_ADDR
// mc_construct_list := Replace ( mc_construct_list , base , [ ] ) ;
20760: LD_ADDR_EXP 83
20764: PUSH
20765: LD_EXP 83
20769: PPUSH
20770: LD_VAR 0 1
20774: PPUSH
20775: EMPTY
20776: PPUSH
20777: CALL_OW 1
20781: ST_TO_ADDR
// mc_turret_list := Replace ( mc_turret_list , base , [ ] ) ;
20782: LD_ADDR_EXP 84
20786: PUSH
20787: LD_EXP 84
20791: PPUSH
20792: LD_VAR 0 1
20796: PPUSH
20797: EMPTY
20798: PPUSH
20799: CALL_OW 1
20803: ST_TO_ADDR
// mc_empty_turret_list := Replace ( mc_empty_turret_list , base , [ ] ) ;
20804: LD_ADDR_EXP 85
20808: PUSH
20809: LD_EXP 85
20813: PPUSH
20814: LD_VAR 0 1
20818: PPUSH
20819: EMPTY
20820: PPUSH
20821: CALL_OW 1
20825: ST_TO_ADDR
// mc_busy_turret_list := Replace ( mc_busy_turret_list , base , [ ] ) ;
20826: LD_ADDR_EXP 86
20830: PUSH
20831: LD_EXP 86
20835: PPUSH
20836: LD_VAR 0 1
20840: PPUSH
20841: EMPTY
20842: PPUSH
20843: CALL_OW 1
20847: ST_TO_ADDR
// mc_defender_limit := Replace ( mc_defender_limit , base , 0 ) ;
20848: LD_ADDR_EXP 87
20852: PUSH
20853: LD_EXP 87
20857: PPUSH
20858: LD_VAR 0 1
20862: PPUSH
20863: LD_INT 0
20865: PPUSH
20866: CALL_OW 1
20870: ST_TO_ADDR
// mc_repair_vehicle := Replace ( mc_repair_vehicle , base , [ ] ) ;
20871: LD_ADDR_EXP 88
20875: PUSH
20876: LD_EXP 88
20880: PPUSH
20881: LD_VAR 0 1
20885: PPUSH
20886: EMPTY
20887: PPUSH
20888: CALL_OW 1
20892: ST_TO_ADDR
// mc_mines := Replace ( mc_mines , base , [ ] ) ;
20893: LD_ADDR_EXP 89
20897: PUSH
20898: LD_EXP 89
20902: PPUSH
20903: LD_VAR 0 1
20907: PPUSH
20908: EMPTY
20909: PPUSH
20910: CALL_OW 1
20914: ST_TO_ADDR
// mc_miners := Replace ( mc_miners , base , [ ] ) ;
20915: LD_ADDR_EXP 90
20919: PUSH
20920: LD_EXP 90
20924: PPUSH
20925: LD_VAR 0 1
20929: PPUSH
20930: EMPTY
20931: PPUSH
20932: CALL_OW 1
20936: ST_TO_ADDR
// mc_minefields := Replace ( mc_minefields , base , [ ] ) ;
20937: LD_ADDR_EXP 91
20941: PUSH
20942: LD_EXP 91
20946: PPUSH
20947: LD_VAR 0 1
20951: PPUSH
20952: EMPTY
20953: PPUSH
20954: CALL_OW 1
20958: ST_TO_ADDR
// mc_crates := Replace ( mc_crates , base , [ ] ) ;
20959: LD_ADDR_EXP 92
20963: PUSH
20964: LD_EXP 92
20968: PPUSH
20969: LD_VAR 0 1
20973: PPUSH
20974: EMPTY
20975: PPUSH
20976: CALL_OW 1
20980: ST_TO_ADDR
// mc_crates_collector := Replace ( mc_crates_collector , base , [ ] ) ;
20981: LD_ADDR_EXP 93
20985: PUSH
20986: LD_EXP 93
20990: PPUSH
20991: LD_VAR 0 1
20995: PPUSH
20996: EMPTY
20997: PPUSH
20998: CALL_OW 1
21002: ST_TO_ADDR
// mc_crates_area := Replace ( mc_crates_area , base , [ ] ) ;
21003: LD_ADDR_EXP 94
21007: PUSH
21008: LD_EXP 94
21012: PPUSH
21013: LD_VAR 0 1
21017: PPUSH
21018: EMPTY
21019: PPUSH
21020: CALL_OW 1
21024: ST_TO_ADDR
// mc_vehicles := Replace ( mc_vehicles , base , [ ] ) ;
21025: LD_ADDR_EXP 95
21029: PUSH
21030: LD_EXP 95
21034: PPUSH
21035: LD_VAR 0 1
21039: PPUSH
21040: EMPTY
21041: PPUSH
21042: CALL_OW 1
21046: ST_TO_ADDR
// mc_attack := Replace ( mc_attack , base , [ ] ) ;
21047: LD_ADDR_EXP 96
21051: PUSH
21052: LD_EXP 96
21056: PPUSH
21057: LD_VAR 0 1
21061: PPUSH
21062: EMPTY
21063: PPUSH
21064: CALL_OW 1
21068: ST_TO_ADDR
// mc_produce := Replace ( mc_produce , base , [ ] ) ;
21069: LD_ADDR_EXP 97
21073: PUSH
21074: LD_EXP 97
21078: PPUSH
21079: LD_VAR 0 1
21083: PPUSH
21084: EMPTY
21085: PPUSH
21086: CALL_OW 1
21090: ST_TO_ADDR
// mc_defender := Replace ( mc_defender , base , [ ] ) ;
21091: LD_ADDR_EXP 98
21095: PUSH
21096: LD_EXP 98
21100: PPUSH
21101: LD_VAR 0 1
21105: PPUSH
21106: EMPTY
21107: PPUSH
21108: CALL_OW 1
21112: ST_TO_ADDR
// mc_scan := Replace ( mc_scan , base , [ ] ) ;
21113: LD_ADDR_EXP 99
21117: PUSH
21118: LD_EXP 99
21122: PPUSH
21123: LD_VAR 0 1
21127: PPUSH
21128: EMPTY
21129: PPUSH
21130: CALL_OW 1
21134: ST_TO_ADDR
// mc_parking := Replace ( mc_parking , base , [ ] ) ;
21135: LD_ADDR_EXP 100
21139: PUSH
21140: LD_EXP 100
21144: PPUSH
21145: LD_VAR 0 1
21149: PPUSH
21150: EMPTY
21151: PPUSH
21152: CALL_OW 1
21156: ST_TO_ADDR
// mc_scan_area := Replace ( mc_scan_area , base , [ ] ) ;
21157: LD_ADDR_EXP 101
21161: PUSH
21162: LD_EXP 101
21166: PPUSH
21167: LD_VAR 0 1
21171: PPUSH
21172: EMPTY
21173: PPUSH
21174: CALL_OW 1
21178: ST_TO_ADDR
// mc_tech := Replace ( mc_tech , base , [ ] ) ;
21179: LD_ADDR_EXP 103
21183: PUSH
21184: LD_EXP 103
21188: PPUSH
21189: LD_VAR 0 1
21193: PPUSH
21194: EMPTY
21195: PPUSH
21196: CALL_OW 1
21200: ST_TO_ADDR
// mc_ape := Replace ( mc_ape , base , [ ] ) ;
21201: LD_ADDR_EXP 105
21205: PUSH
21206: LD_EXP 105
21210: PPUSH
21211: LD_VAR 0 1
21215: PPUSH
21216: EMPTY
21217: PPUSH
21218: CALL_OW 1
21222: ST_TO_ADDR
// mc_ape_in_lab := Replace ( mc_ape_in_lab , base , [ ] ) ;
21223: LD_ADDR_EXP 106
21227: PUSH
21228: LD_EXP 106
21232: PPUSH
21233: LD_VAR 0 1
21237: PPUSH
21238: EMPTY
21239: PPUSH
21240: CALL_OW 1
21244: ST_TO_ADDR
// mc_taming := Replace ( mc_taming , base , [ ] ) ;
21245: LD_ADDR_EXP 107
21249: PUSH
21250: LD_EXP 107
21254: PPUSH
21255: LD_VAR 0 1
21259: PPUSH
21260: EMPTY
21261: PPUSH
21262: CALL_OW 1
21266: ST_TO_ADDR
// mc_build_upgrade := Replace ( mc_build_upgrade , base , [ ] ) ;
21267: LD_ADDR_EXP 108
21271: PUSH
21272: LD_EXP 108
21276: PPUSH
21277: LD_VAR 0 1
21281: PPUSH
21282: EMPTY
21283: PPUSH
21284: CALL_OW 1
21288: ST_TO_ADDR
// mc_lab := Replace ( mc_lab , base , [ ] ) ;
21289: LD_ADDR_EXP 109
21293: PUSH
21294: LD_EXP 109
21298: PPUSH
21299: LD_VAR 0 1
21303: PPUSH
21304: EMPTY
21305: PPUSH
21306: CALL_OW 1
21310: ST_TO_ADDR
// mc_lab_upgrade := Replace ( mc_lab_upgrade , base , [ ] ) ;
21311: LD_ADDR_EXP 110
21315: PUSH
21316: LD_EXP 110
21320: PPUSH
21321: LD_VAR 0 1
21325: PPUSH
21326: EMPTY
21327: PPUSH
21328: CALL_OW 1
21332: ST_TO_ADDR
// mc_teleport_exit := Replace ( mc_teleport_exit , base , [ ] ) ;
21333: LD_ADDR_EXP 111
21337: PUSH
21338: LD_EXP 111
21342: PPUSH
21343: LD_VAR 0 1
21347: PPUSH
21348: EMPTY
21349: PPUSH
21350: CALL_OW 1
21354: ST_TO_ADDR
// mc_teleport_exit_set := Replace ( mc_teleport_exit_set , base , [ ] ) ;
21355: LD_ADDR_EXP 112
21359: PUSH
21360: LD_EXP 112
21364: PPUSH
21365: LD_VAR 0 1
21369: PPUSH
21370: EMPTY
21371: PPUSH
21372: CALL_OW 1
21376: ST_TO_ADDR
// mc_deposits_xy := Replace ( mc_deposits_xy , base , [ ] ) ;
21377: LD_ADDR_EXP 113
21381: PUSH
21382: LD_EXP 113
21386: PPUSH
21387: LD_VAR 0 1
21391: PPUSH
21392: EMPTY
21393: PPUSH
21394: CALL_OW 1
21398: ST_TO_ADDR
// mc_deposits_finder := Replace ( mc_deposits_finder , base , [ ] ) ;
21399: LD_ADDR_EXP 114
21403: PUSH
21404: LD_EXP 114
21408: PPUSH
21409: LD_VAR 0 1
21413: PPUSH
21414: EMPTY
21415: PPUSH
21416: CALL_OW 1
21420: ST_TO_ADDR
// mc_allowed_tower_weapons := Replace ( mc_allowed_tower_weapons , base , [ ] ) ;
21421: LD_ADDR_EXP 115
21425: PUSH
21426: LD_EXP 115
21430: PPUSH
21431: LD_VAR 0 1
21435: PPUSH
21436: EMPTY
21437: PPUSH
21438: CALL_OW 1
21442: ST_TO_ADDR
// mc_remote_driver := Replace ( mc_remote_driver , base , [ ] ) ;
21443: LD_ADDR_EXP 116
21447: PUSH
21448: LD_EXP 116
21452: PPUSH
21453: LD_VAR 0 1
21457: PPUSH
21458: EMPTY
21459: PPUSH
21460: CALL_OW 1
21464: ST_TO_ADDR
// mc_class := Replace ( mc_class , base , [ ] ) ;
21465: LD_ADDR_EXP 117
21469: PUSH
21470: LD_EXP 117
21474: PPUSH
21475: LD_VAR 0 1
21479: PPUSH
21480: EMPTY
21481: PPUSH
21482: CALL_OW 1
21486: ST_TO_ADDR
// mc_class_case_use := Replace ( mc_class_case_use , base , 0 ) ;
21487: LD_ADDR_EXP 118
21491: PUSH
21492: LD_EXP 118
21496: PPUSH
21497: LD_VAR 0 1
21501: PPUSH
21502: LD_INT 0
21504: PPUSH
21505: CALL_OW 1
21509: ST_TO_ADDR
// end ;
21510: LD_VAR 0 2
21514: RET
// export function MC_Add ( side , units ) ; var base ; begin
21515: LD_INT 0
21517: PPUSH
21518: PPUSH
// base := mc_bases + 1 ;
21519: LD_ADDR_VAR 0 4
21523: PUSH
21524: LD_EXP 76
21528: PUSH
21529: LD_INT 1
21531: PLUS
21532: ST_TO_ADDR
// mc_sides := Replace ( mc_sides , base , side ) ;
21533: LD_ADDR_EXP 102
21537: PUSH
21538: LD_EXP 102
21542: PPUSH
21543: LD_VAR 0 4
21547: PPUSH
21548: LD_VAR 0 1
21552: PPUSH
21553: CALL_OW 1
21557: ST_TO_ADDR
// mc_bases := Replace ( mc_bases , base , units ) ;
21558: LD_ADDR_EXP 76
21562: PUSH
21563: LD_EXP 76
21567: PPUSH
21568: LD_VAR 0 4
21572: PPUSH
21573: LD_VAR 0 2
21577: PPUSH
21578: CALL_OW 1
21582: ST_TO_ADDR
// mc_building_need_repair := Replace ( mc_building_need_repair , base , [ ] ) ;
21583: LD_ADDR_EXP 77
21587: PUSH
21588: LD_EXP 77
21592: PPUSH
21593: LD_VAR 0 4
21597: PPUSH
21598: EMPTY
21599: PPUSH
21600: CALL_OW 1
21604: ST_TO_ADDR
// mc_building_repairs := Replace ( mc_building_repairs , base , [ ] ) ;
21605: LD_ADDR_EXP 78
21609: PUSH
21610: LD_EXP 78
21614: PPUSH
21615: LD_VAR 0 4
21619: PPUSH
21620: EMPTY
21621: PPUSH
21622: CALL_OW 1
21626: ST_TO_ADDR
// mc_need_heal := Replace ( mc_need_heal , base , [ ] ) ;
21627: LD_ADDR_EXP 79
21631: PUSH
21632: LD_EXP 79
21636: PPUSH
21637: LD_VAR 0 4
21641: PPUSH
21642: EMPTY
21643: PPUSH
21644: CALL_OW 1
21648: ST_TO_ADDR
// mc_healers := Replace ( mc_healers , base , [ ] ) ;
21649: LD_ADDR_EXP 80
21653: PUSH
21654: LD_EXP 80
21658: PPUSH
21659: LD_VAR 0 4
21663: PPUSH
21664: EMPTY
21665: PPUSH
21666: CALL_OW 1
21670: ST_TO_ADDR
// mc_build_list := Replace ( mc_build_list , base , [ ] ) ;
21671: LD_ADDR_EXP 81
21675: PUSH
21676: LD_EXP 81
21680: PPUSH
21681: LD_VAR 0 4
21685: PPUSH
21686: EMPTY
21687: PPUSH
21688: CALL_OW 1
21692: ST_TO_ADDR
// mc_builders := Replace ( mc_builders , base , [ ] ) ;
21693: LD_ADDR_EXP 82
21697: PUSH
21698: LD_EXP 82
21702: PPUSH
21703: LD_VAR 0 4
21707: PPUSH
21708: EMPTY
21709: PPUSH
21710: CALL_OW 1
21714: ST_TO_ADDR
// mc_construct_list := Replace ( mc_construct_list , base , [ ] ) ;
21715: LD_ADDR_EXP 83
21719: PUSH
21720: LD_EXP 83
21724: PPUSH
21725: LD_VAR 0 4
21729: PPUSH
21730: EMPTY
21731: PPUSH
21732: CALL_OW 1
21736: ST_TO_ADDR
// mc_turret_list := Replace ( mc_turret_list , base , [ ] ) ;
21737: LD_ADDR_EXP 84
21741: PUSH
21742: LD_EXP 84
21746: PPUSH
21747: LD_VAR 0 4
21751: PPUSH
21752: EMPTY
21753: PPUSH
21754: CALL_OW 1
21758: ST_TO_ADDR
// mc_empty_turret_list := Replace ( mc_empty_turret_list , base , [ ] ) ;
21759: LD_ADDR_EXP 85
21763: PUSH
21764: LD_EXP 85
21768: PPUSH
21769: LD_VAR 0 4
21773: PPUSH
21774: EMPTY
21775: PPUSH
21776: CALL_OW 1
21780: ST_TO_ADDR
// mc_busy_turret_list := Replace ( mc_busy_turret_list , base , [ ] ) ;
21781: LD_ADDR_EXP 86
21785: PUSH
21786: LD_EXP 86
21790: PPUSH
21791: LD_VAR 0 4
21795: PPUSH
21796: EMPTY
21797: PPUSH
21798: CALL_OW 1
21802: ST_TO_ADDR
// mc_defender_limit := Replace ( mc_defender_limit , base , 0 ) ;
21803: LD_ADDR_EXP 87
21807: PUSH
21808: LD_EXP 87
21812: PPUSH
21813: LD_VAR 0 4
21817: PPUSH
21818: LD_INT 0
21820: PPUSH
21821: CALL_OW 1
21825: ST_TO_ADDR
// mc_repair_vehicle := Replace ( mc_repair_vehicle , base , [ ] ) ;
21826: LD_ADDR_EXP 88
21830: PUSH
21831: LD_EXP 88
21835: PPUSH
21836: LD_VAR 0 4
21840: PPUSH
21841: EMPTY
21842: PPUSH
21843: CALL_OW 1
21847: ST_TO_ADDR
// mc_mines := Replace ( mc_mines , base , [ ] ) ;
21848: LD_ADDR_EXP 89
21852: PUSH
21853: LD_EXP 89
21857: PPUSH
21858: LD_VAR 0 4
21862: PPUSH
21863: EMPTY
21864: PPUSH
21865: CALL_OW 1
21869: ST_TO_ADDR
// mc_miners := Replace ( mc_miners , base , [ ] ) ;
21870: LD_ADDR_EXP 90
21874: PUSH
21875: LD_EXP 90
21879: PPUSH
21880: LD_VAR 0 4
21884: PPUSH
21885: EMPTY
21886: PPUSH
21887: CALL_OW 1
21891: ST_TO_ADDR
// mc_minefields := Replace ( mc_minefields , base , [ ] ) ;
21892: LD_ADDR_EXP 91
21896: PUSH
21897: LD_EXP 91
21901: PPUSH
21902: LD_VAR 0 4
21906: PPUSH
21907: EMPTY
21908: PPUSH
21909: CALL_OW 1
21913: ST_TO_ADDR
// mc_crates := Replace ( mc_crates , base , [ ] ) ;
21914: LD_ADDR_EXP 92
21918: PUSH
21919: LD_EXP 92
21923: PPUSH
21924: LD_VAR 0 4
21928: PPUSH
21929: EMPTY
21930: PPUSH
21931: CALL_OW 1
21935: ST_TO_ADDR
// mc_crates_collector := Replace ( mc_crates_collector , base , [ ] ) ;
21936: LD_ADDR_EXP 93
21940: PUSH
21941: LD_EXP 93
21945: PPUSH
21946: LD_VAR 0 4
21950: PPUSH
21951: EMPTY
21952: PPUSH
21953: CALL_OW 1
21957: ST_TO_ADDR
// mc_crates_area := Replace ( mc_crates_area , base , [ ] ) ;
21958: LD_ADDR_EXP 94
21962: PUSH
21963: LD_EXP 94
21967: PPUSH
21968: LD_VAR 0 4
21972: PPUSH
21973: EMPTY
21974: PPUSH
21975: CALL_OW 1
21979: ST_TO_ADDR
// mc_vehicles := Replace ( mc_vehicles , base , [ ] ) ;
21980: LD_ADDR_EXP 95
21984: PUSH
21985: LD_EXP 95
21989: PPUSH
21990: LD_VAR 0 4
21994: PPUSH
21995: EMPTY
21996: PPUSH
21997: CALL_OW 1
22001: ST_TO_ADDR
// mc_attack := Replace ( mc_attack , base , [ ] ) ;
22002: LD_ADDR_EXP 96
22006: PUSH
22007: LD_EXP 96
22011: PPUSH
22012: LD_VAR 0 4
22016: PPUSH
22017: EMPTY
22018: PPUSH
22019: CALL_OW 1
22023: ST_TO_ADDR
// mc_produce := Replace ( mc_produce , base , [ ] ) ;
22024: LD_ADDR_EXP 97
22028: PUSH
22029: LD_EXP 97
22033: PPUSH
22034: LD_VAR 0 4
22038: PPUSH
22039: EMPTY
22040: PPUSH
22041: CALL_OW 1
22045: ST_TO_ADDR
// mc_defender := Replace ( mc_defender , base , [ ] ) ;
22046: LD_ADDR_EXP 98
22050: PUSH
22051: LD_EXP 98
22055: PPUSH
22056: LD_VAR 0 4
22060: PPUSH
22061: EMPTY
22062: PPUSH
22063: CALL_OW 1
22067: ST_TO_ADDR
// mc_scan := Replace ( mc_scan , base , [ ] ) ;
22068: LD_ADDR_EXP 99
22072: PUSH
22073: LD_EXP 99
22077: PPUSH
22078: LD_VAR 0 4
22082: PPUSH
22083: EMPTY
22084: PPUSH
22085: CALL_OW 1
22089: ST_TO_ADDR
// mc_parking := Replace ( mc_parking , base , [ ] ) ;
22090: LD_ADDR_EXP 100
22094: PUSH
22095: LD_EXP 100
22099: PPUSH
22100: LD_VAR 0 4
22104: PPUSH
22105: EMPTY
22106: PPUSH
22107: CALL_OW 1
22111: ST_TO_ADDR
// mc_scan_area := Replace ( mc_scan_area , base , [ ] ) ;
22112: LD_ADDR_EXP 101
22116: PUSH
22117: LD_EXP 101
22121: PPUSH
22122: LD_VAR 0 4
22126: PPUSH
22127: EMPTY
22128: PPUSH
22129: CALL_OW 1
22133: ST_TO_ADDR
// mc_tech := Replace ( mc_tech , base , [ ] ) ;
22134: LD_ADDR_EXP 103
22138: PUSH
22139: LD_EXP 103
22143: PPUSH
22144: LD_VAR 0 4
22148: PPUSH
22149: EMPTY
22150: PPUSH
22151: CALL_OW 1
22155: ST_TO_ADDR
// mc_ape := Replace ( mc_ape , base , [ ] ) ;
22156: LD_ADDR_EXP 105
22160: PUSH
22161: LD_EXP 105
22165: PPUSH
22166: LD_VAR 0 4
22170: PPUSH
22171: EMPTY
22172: PPUSH
22173: CALL_OW 1
22177: ST_TO_ADDR
// mc_ape_in_lab := Replace ( mc_ape_in_lab , base , [ ] ) ;
22178: LD_ADDR_EXP 106
22182: PUSH
22183: LD_EXP 106
22187: PPUSH
22188: LD_VAR 0 4
22192: PPUSH
22193: EMPTY
22194: PPUSH
22195: CALL_OW 1
22199: ST_TO_ADDR
// mc_taming := Replace ( mc_taming , base , [ ] ) ;
22200: LD_ADDR_EXP 107
22204: PUSH
22205: LD_EXP 107
22209: PPUSH
22210: LD_VAR 0 4
22214: PPUSH
22215: EMPTY
22216: PPUSH
22217: CALL_OW 1
22221: ST_TO_ADDR
// mc_build_upgrade := Replace ( mc_build_upgrade , base , [ ] ) ;
22222: LD_ADDR_EXP 108
22226: PUSH
22227: LD_EXP 108
22231: PPUSH
22232: LD_VAR 0 4
22236: PPUSH
22237: EMPTY
22238: PPUSH
22239: CALL_OW 1
22243: ST_TO_ADDR
// mc_lab := Replace ( mc_lab , base , [ ] ) ;
22244: LD_ADDR_EXP 109
22248: PUSH
22249: LD_EXP 109
22253: PPUSH
22254: LD_VAR 0 4
22258: PPUSH
22259: EMPTY
22260: PPUSH
22261: CALL_OW 1
22265: ST_TO_ADDR
// mc_lab_upgrade := Replace ( mc_lab_upgrade , base , [ ] ) ;
22266: LD_ADDR_EXP 110
22270: PUSH
22271: LD_EXP 110
22275: PPUSH
22276: LD_VAR 0 4
22280: PPUSH
22281: EMPTY
22282: PPUSH
22283: CALL_OW 1
22287: ST_TO_ADDR
// mc_teleport_exit := Replace ( mc_teleport_exit , base , [ ] ) ;
22288: LD_ADDR_EXP 111
22292: PUSH
22293: LD_EXP 111
22297: PPUSH
22298: LD_VAR 0 4
22302: PPUSH
22303: EMPTY
22304: PPUSH
22305: CALL_OW 1
22309: ST_TO_ADDR
// mc_teleport_exit_set := Replace ( mc_teleport_exit_set , base , [ ] ) ;
22310: LD_ADDR_EXP 112
22314: PUSH
22315: LD_EXP 112
22319: PPUSH
22320: LD_VAR 0 4
22324: PPUSH
22325: EMPTY
22326: PPUSH
22327: CALL_OW 1
22331: ST_TO_ADDR
// mc_deposits_xy := Replace ( mc_deposits_xy , base , [ ] ) ;
22332: LD_ADDR_EXP 113
22336: PUSH
22337: LD_EXP 113
22341: PPUSH
22342: LD_VAR 0 4
22346: PPUSH
22347: EMPTY
22348: PPUSH
22349: CALL_OW 1
22353: ST_TO_ADDR
// mc_deposits_finder := Replace ( mc_deposits_finder , base , [ ] ) ;
22354: LD_ADDR_EXP 114
22358: PUSH
22359: LD_EXP 114
22363: PPUSH
22364: LD_VAR 0 4
22368: PPUSH
22369: EMPTY
22370: PPUSH
22371: CALL_OW 1
22375: ST_TO_ADDR
// mc_allowed_tower_weapons := Replace ( mc_allowed_tower_weapons , base , [ ] ) ;
22376: LD_ADDR_EXP 115
22380: PUSH
22381: LD_EXP 115
22385: PPUSH
22386: LD_VAR 0 4
22390: PPUSH
22391: EMPTY
22392: PPUSH
22393: CALL_OW 1
22397: ST_TO_ADDR
// mc_remote_driver := Replace ( mc_remote_driver , base , [ ] ) ;
22398: LD_ADDR_EXP 116
22402: PUSH
22403: LD_EXP 116
22407: PPUSH
22408: LD_VAR 0 4
22412: PPUSH
22413: EMPTY
22414: PPUSH
22415: CALL_OW 1
22419: ST_TO_ADDR
// mc_class := Replace ( mc_class , base , [ ] ) ;
22420: LD_ADDR_EXP 117
22424: PUSH
22425: LD_EXP 117
22429: PPUSH
22430: LD_VAR 0 4
22434: PPUSH
22435: EMPTY
22436: PPUSH
22437: CALL_OW 1
22441: ST_TO_ADDR
// mc_class_case_use := Replace ( mc_class_case_use , base , 0 ) ;
22442: LD_ADDR_EXP 118
22446: PUSH
22447: LD_EXP 118
22451: PPUSH
22452: LD_VAR 0 4
22456: PPUSH
22457: LD_INT 0
22459: PPUSH
22460: CALL_OW 1
22464: ST_TO_ADDR
// result := base ;
22465: LD_ADDR_VAR 0 3
22469: PUSH
22470: LD_VAR 0 4
22474: ST_TO_ADDR
// end ;
22475: LD_VAR 0 3
22479: RET
// export function MC_Start ( ) ; var i ; begin
22480: LD_INT 0
22482: PPUSH
22483: PPUSH
// for i = 1 to mc_bases do
22484: LD_ADDR_VAR 0 2
22488: PUSH
22489: DOUBLE
22490: LD_INT 1
22492: DEC
22493: ST_TO_ADDR
22494: LD_EXP 76
22498: PUSH
22499: FOR_TO
22500: IFFALSE 23577
// begin mc_bases := Replace ( mc_bases , i , mc_bases [ i ] diff 0 ) ;
22502: LD_ADDR_EXP 76
22506: PUSH
22507: LD_EXP 76
22511: PPUSH
22512: LD_VAR 0 2
22516: PPUSH
22517: LD_EXP 76
22521: PUSH
22522: LD_VAR 0 2
22526: ARRAY
22527: PUSH
22528: LD_INT 0
22530: DIFF
22531: PPUSH
22532: CALL_OW 1
22536: ST_TO_ADDR
// mc_building_need_repair := Replace ( mc_building_need_repair , i , [ ] ) ;
22537: LD_ADDR_EXP 77
22541: PUSH
22542: LD_EXP 77
22546: PPUSH
22547: LD_VAR 0 2
22551: PPUSH
22552: EMPTY
22553: PPUSH
22554: CALL_OW 1
22558: ST_TO_ADDR
// mc_building_repairs := Replace ( mc_building_repairs , i , [ ] ) ;
22559: LD_ADDR_EXP 78
22563: PUSH
22564: LD_EXP 78
22568: PPUSH
22569: LD_VAR 0 2
22573: PPUSH
22574: EMPTY
22575: PPUSH
22576: CALL_OW 1
22580: ST_TO_ADDR
// mc_need_heal := Replace ( mc_need_heal , i , [ ] ) ;
22581: LD_ADDR_EXP 79
22585: PUSH
22586: LD_EXP 79
22590: PPUSH
22591: LD_VAR 0 2
22595: PPUSH
22596: EMPTY
22597: PPUSH
22598: CALL_OW 1
22602: ST_TO_ADDR
// mc_healers := Replace ( mc_healers , i , [ [ ] , [ ] ] ) ;
22603: LD_ADDR_EXP 80
22607: PUSH
22608: LD_EXP 80
22612: PPUSH
22613: LD_VAR 0 2
22617: PPUSH
22618: EMPTY
22619: PUSH
22620: EMPTY
22621: PUSH
22622: EMPTY
22623: LIST
22624: LIST
22625: PPUSH
22626: CALL_OW 1
22630: ST_TO_ADDR
// mc_build_list := Replace ( mc_build_list , i , [ ] ) ;
22631: LD_ADDR_EXP 81
22635: PUSH
22636: LD_EXP 81
22640: PPUSH
22641: LD_VAR 0 2
22645: PPUSH
22646: EMPTY
22647: PPUSH
22648: CALL_OW 1
22652: ST_TO_ADDR
// mc_build_upgrade := Replace ( mc_build_upgrade , i , [ ] ) ;
22653: LD_ADDR_EXP 108
22657: PUSH
22658: LD_EXP 108
22662: PPUSH
22663: LD_VAR 0 2
22667: PPUSH
22668: EMPTY
22669: PPUSH
22670: CALL_OW 1
22674: ST_TO_ADDR
// mc_builders := Replace ( mc_builders , i , [ ] ) ;
22675: LD_ADDR_EXP 82
22679: PUSH
22680: LD_EXP 82
22684: PPUSH
22685: LD_VAR 0 2
22689: PPUSH
22690: EMPTY
22691: PPUSH
22692: CALL_OW 1
22696: ST_TO_ADDR
// mc_construct_list := Replace ( mc_construct_list , i , [ ] ) ;
22697: LD_ADDR_EXP 83
22701: PUSH
22702: LD_EXP 83
22706: PPUSH
22707: LD_VAR 0 2
22711: PPUSH
22712: EMPTY
22713: PPUSH
22714: CALL_OW 1
22718: ST_TO_ADDR
// mc_turret_list := Replace ( mc_turret_list , i , UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_bunker ] , [ f_btype , b_turret ] ] ) ) ;
22719: LD_ADDR_EXP 84
22723: PUSH
22724: LD_EXP 84
22728: PPUSH
22729: LD_VAR 0 2
22733: PPUSH
22734: LD_EXP 76
22738: PUSH
22739: LD_VAR 0 2
22743: ARRAY
22744: PPUSH
22745: LD_INT 2
22747: PUSH
22748: LD_INT 30
22750: PUSH
22751: LD_INT 32
22753: PUSH
22754: EMPTY
22755: LIST
22756: LIST
22757: PUSH
22758: LD_INT 30
22760: PUSH
22761: LD_INT 33
22763: PUSH
22764: EMPTY
22765: LIST
22766: LIST
22767: PUSH
22768: EMPTY
22769: LIST
22770: LIST
22771: LIST
22772: PPUSH
22773: CALL_OW 72
22777: PPUSH
22778: CALL_OW 1
22782: ST_TO_ADDR
// mc_empty_turret_list := Replace ( mc_empty_turret_list , i , UnitFilter ( mc_bases [ i ] , [ [ f_or , [ f_btype , b_bunker ] , [ f_btype , b_breastwork ] ] , [ f_empty ] ] ) ) ;
22783: LD_ADDR_EXP 85
22787: PUSH
22788: LD_EXP 85
22792: PPUSH
22793: LD_VAR 0 2
22797: PPUSH
22798: LD_EXP 76
22802: PUSH
22803: LD_VAR 0 2
22807: ARRAY
22808: PPUSH
22809: LD_INT 2
22811: PUSH
22812: LD_INT 30
22814: PUSH
22815: LD_INT 32
22817: PUSH
22818: EMPTY
22819: LIST
22820: LIST
22821: PUSH
22822: LD_INT 30
22824: PUSH
22825: LD_INT 31
22827: PUSH
22828: EMPTY
22829: LIST
22830: LIST
22831: PUSH
22832: EMPTY
22833: LIST
22834: LIST
22835: LIST
22836: PUSH
22837: LD_INT 58
22839: PUSH
22840: EMPTY
22841: LIST
22842: PUSH
22843: EMPTY
22844: LIST
22845: LIST
22846: PPUSH
22847: CALL_OW 72
22851: PPUSH
22852: CALL_OW 1
22856: ST_TO_ADDR
// mc_busy_turret_list := Replace ( mc_busy_turret_list , i , [ ] ) ;
22857: LD_ADDR_EXP 86
22861: PUSH
22862: LD_EXP 86
22866: PPUSH
22867: LD_VAR 0 2
22871: PPUSH
22872: EMPTY
22873: PPUSH
22874: CALL_OW 1
22878: ST_TO_ADDR
// mc_miners := Replace ( mc_miners , i , [ ] ) ;
22879: LD_ADDR_EXP 90
22883: PUSH
22884: LD_EXP 90
22888: PPUSH
22889: LD_VAR 0 2
22893: PPUSH
22894: EMPTY
22895: PPUSH
22896: CALL_OW 1
22900: ST_TO_ADDR
// mc_mines := Replace ( mc_mines , i , [ ] ) ;
22901: LD_ADDR_EXP 89
22905: PUSH
22906: LD_EXP 89
22910: PPUSH
22911: LD_VAR 0 2
22915: PPUSH
22916: EMPTY
22917: PPUSH
22918: CALL_OW 1
22922: ST_TO_ADDR
// mc_minefields := Replace ( mc_minefields , i , [ ] ) ;
22923: LD_ADDR_EXP 91
22927: PUSH
22928: LD_EXP 91
22932: PPUSH
22933: LD_VAR 0 2
22937: PPUSH
22938: EMPTY
22939: PPUSH
22940: CALL_OW 1
22944: ST_TO_ADDR
// mc_crates := Replace ( mc_crates , i , [ ] ) ;
22945: LD_ADDR_EXP 92
22949: PUSH
22950: LD_EXP 92
22954: PPUSH
22955: LD_VAR 0 2
22959: PPUSH
22960: EMPTY
22961: PPUSH
22962: CALL_OW 1
22966: ST_TO_ADDR
// mc_crates_collector := Replace ( mc_crates_collector , i , [ ] ) ;
22967: LD_ADDR_EXP 93
22971: PUSH
22972: LD_EXP 93
22976: PPUSH
22977: LD_VAR 0 2
22981: PPUSH
22982: EMPTY
22983: PPUSH
22984: CALL_OW 1
22988: ST_TO_ADDR
// mc_crates_area := Replace ( mc_crates_area , i , [ ] ) ;
22989: LD_ADDR_EXP 94
22993: PUSH
22994: LD_EXP 94
22998: PPUSH
22999: LD_VAR 0 2
23003: PPUSH
23004: EMPTY
23005: PPUSH
23006: CALL_OW 1
23010: ST_TO_ADDR
// mc_vehicles := Replace ( mc_vehicles , i , [ ] ) ;
23011: LD_ADDR_EXP 95
23015: PUSH
23016: LD_EXP 95
23020: PPUSH
23021: LD_VAR 0 2
23025: PPUSH
23026: EMPTY
23027: PPUSH
23028: CALL_OW 1
23032: ST_TO_ADDR
// mc_attack := Replace ( mc_attack , i , [ ] ) ;
23033: LD_ADDR_EXP 96
23037: PUSH
23038: LD_EXP 96
23042: PPUSH
23043: LD_VAR 0 2
23047: PPUSH
23048: EMPTY
23049: PPUSH
23050: CALL_OW 1
23054: ST_TO_ADDR
// mc_produce := Replace ( mc_produce , i , [ ] ) ;
23055: LD_ADDR_EXP 97
23059: PUSH
23060: LD_EXP 97
23064: PPUSH
23065: LD_VAR 0 2
23069: PPUSH
23070: EMPTY
23071: PPUSH
23072: CALL_OW 1
23076: ST_TO_ADDR
// mc_defender := Replace ( mc_defender , i , [ ] ) ;
23077: LD_ADDR_EXP 98
23081: PUSH
23082: LD_EXP 98
23086: PPUSH
23087: LD_VAR 0 2
23091: PPUSH
23092: EMPTY
23093: PPUSH
23094: CALL_OW 1
23098: ST_TO_ADDR
// mc_defender_limit := Replace ( mc_defender_limit , i , 0 ) ;
23099: LD_ADDR_EXP 87
23103: PUSH
23104: LD_EXP 87
23108: PPUSH
23109: LD_VAR 0 2
23113: PPUSH
23114: LD_INT 0
23116: PPUSH
23117: CALL_OW 1
23121: ST_TO_ADDR
// mc_parking := Replace ( mc_parking , i , 0 ) ;
23122: LD_ADDR_EXP 100
23126: PUSH
23127: LD_EXP 100
23131: PPUSH
23132: LD_VAR 0 2
23136: PPUSH
23137: LD_INT 0
23139: PPUSH
23140: CALL_OW 1
23144: ST_TO_ADDR
// mc_repair_vehicle := Replace ( mc_repair_vehicle , i , [ ] ) ;
23145: LD_ADDR_EXP 88
23149: PUSH
23150: LD_EXP 88
23154: PPUSH
23155: LD_VAR 0 2
23159: PPUSH
23160: EMPTY
23161: PPUSH
23162: CALL_OW 1
23166: ST_TO_ADDR
// mc_scan := Replace ( mc_scan , i , 0 ) ;
23167: LD_ADDR_EXP 99
23171: PUSH
23172: LD_EXP 99
23176: PPUSH
23177: LD_VAR 0 2
23181: PPUSH
23182: LD_INT 0
23184: PPUSH
23185: CALL_OW 1
23189: ST_TO_ADDR
// mc_scan_area := Replace ( mc_scan_area , i , [ ] ) ;
23190: LD_ADDR_EXP 101
23194: PUSH
23195: LD_EXP 101
23199: PPUSH
23200: LD_VAR 0 2
23204: PPUSH
23205: EMPTY
23206: PPUSH
23207: CALL_OW 1
23211: ST_TO_ADDR
// mc_can_tame := Replace ( mc_can_tame , i , 0 ) ;
23212: LD_ADDR_EXP 104
23216: PUSH
23217: LD_EXP 104
23221: PPUSH
23222: LD_VAR 0 2
23226: PPUSH
23227: LD_INT 0
23229: PPUSH
23230: CALL_OW 1
23234: ST_TO_ADDR
// mc_ape := Replace ( mc_ape , i , [ ] ) ;
23235: LD_ADDR_EXP 105
23239: PUSH
23240: LD_EXP 105
23244: PPUSH
23245: LD_VAR 0 2
23249: PPUSH
23250: EMPTY
23251: PPUSH
23252: CALL_OW 1
23256: ST_TO_ADDR
// mc_ape_in_lab := Replace ( mc_ape_in_lab , i , [ ] ) ;
23257: LD_ADDR_EXP 106
23261: PUSH
23262: LD_EXP 106
23266: PPUSH
23267: LD_VAR 0 2
23271: PPUSH
23272: EMPTY
23273: PPUSH
23274: CALL_OW 1
23278: ST_TO_ADDR
// mc_taming := Replace ( mc_taming , i , [ ] ) ;
23279: LD_ADDR_EXP 107
23283: PUSH
23284: LD_EXP 107
23288: PPUSH
23289: LD_VAR 0 2
23293: PPUSH
23294: EMPTY
23295: PPUSH
23296: CALL_OW 1
23300: ST_TO_ADDR
// mc_lab := Replace ( mc_lab , i , UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_lab ] , [ f_btype , b_lab_half ] , [ f_btype , b_lab_full ] ] ) ) ;
23301: LD_ADDR_EXP 109
23305: PUSH
23306: LD_EXP 109
23310: PPUSH
23311: LD_VAR 0 2
23315: PPUSH
23316: LD_EXP 76
23320: PUSH
23321: LD_VAR 0 2
23325: ARRAY
23326: PPUSH
23327: LD_INT 2
23329: PUSH
23330: LD_INT 30
23332: PUSH
23333: LD_INT 6
23335: PUSH
23336: EMPTY
23337: LIST
23338: LIST
23339: PUSH
23340: LD_INT 30
23342: PUSH
23343: LD_INT 7
23345: PUSH
23346: EMPTY
23347: LIST
23348: LIST
23349: PUSH
23350: LD_INT 30
23352: PUSH
23353: LD_INT 8
23355: PUSH
23356: EMPTY
23357: LIST
23358: LIST
23359: PUSH
23360: EMPTY
23361: LIST
23362: LIST
23363: LIST
23364: LIST
23365: PPUSH
23366: CALL_OW 72
23370: PPUSH
23371: CALL_OW 1
23375: ST_TO_ADDR
// mc_lab_upgrade := Replace ( mc_lab_upgrade , i , [ ] ) ;
23376: LD_ADDR_EXP 110
23380: PUSH
23381: LD_EXP 110
23385: PPUSH
23386: LD_VAR 0 2
23390: PPUSH
23391: EMPTY
23392: PPUSH
23393: CALL_OW 1
23397: ST_TO_ADDR
// mc_teleport_exit := Replace ( mc_teleport_exit , i , [ ] ) ;
23398: LD_ADDR_EXP 111
23402: PUSH
23403: LD_EXP 111
23407: PPUSH
23408: LD_VAR 0 2
23412: PPUSH
23413: EMPTY
23414: PPUSH
23415: CALL_OW 1
23419: ST_TO_ADDR
// mc_teleport_exit_set := Replace ( mc_teleport_exit_set , i , [ ] ) ;
23420: LD_ADDR_EXP 112
23424: PUSH
23425: LD_EXP 112
23429: PPUSH
23430: LD_VAR 0 2
23434: PPUSH
23435: EMPTY
23436: PPUSH
23437: CALL_OW 1
23441: ST_TO_ADDR
// mc_deposits_xy := Replace ( mc_deposits_xy , i , [ ] ) ;
23442: LD_ADDR_EXP 113
23446: PUSH
23447: LD_EXP 113
23451: PPUSH
23452: LD_VAR 0 2
23456: PPUSH
23457: EMPTY
23458: PPUSH
23459: CALL_OW 1
23463: ST_TO_ADDR
// mc_deposits_finder := Replace ( mc_deposits_finder , i , [ ] ) ;
23464: LD_ADDR_EXP 114
23468: PUSH
23469: LD_EXP 114
23473: PPUSH
23474: LD_VAR 0 2
23478: PPUSH
23479: EMPTY
23480: PPUSH
23481: CALL_OW 1
23485: ST_TO_ADDR
// mc_allowed_tower_weapons := Replace ( mc_allowed_tower_weapons , i , [ ] ) ;
23486: LD_ADDR_EXP 115
23490: PUSH
23491: LD_EXP 115
23495: PPUSH
23496: LD_VAR 0 2
23500: PPUSH
23501: EMPTY
23502: PPUSH
23503: CALL_OW 1
23507: ST_TO_ADDR
// mc_remote_driver := Replace ( mc_remote_driver , i , [ ] ) ;
23508: LD_ADDR_EXP 116
23512: PUSH
23513: LD_EXP 116
23517: PPUSH
23518: LD_VAR 0 2
23522: PPUSH
23523: EMPTY
23524: PPUSH
23525: CALL_OW 1
23529: ST_TO_ADDR
// mc_class := Replace ( mc_class , i , [ ] ) ;
23530: LD_ADDR_EXP 117
23534: PUSH
23535: LD_EXP 117
23539: PPUSH
23540: LD_VAR 0 2
23544: PPUSH
23545: EMPTY
23546: PPUSH
23547: CALL_OW 1
23551: ST_TO_ADDR
// mc_class_case_use := Replace ( mc_class_case_use , i , 0 ) ;
23552: LD_ADDR_EXP 118
23556: PUSH
23557: LD_EXP 118
23561: PPUSH
23562: LD_VAR 0 2
23566: PPUSH
23567: LD_INT 0
23569: PPUSH
23570: CALL_OW 1
23574: ST_TO_ADDR
// end ;
23575: GO 22499
23577: POP
23578: POP
// MC_InitSides ( ) ;
23579: CALL 23865 0 0
// MC_InitResearch ( ) ;
23583: CALL 23604 0 0
// CustomInitMacro ( ) ;
23587: CALL 189 0 0
// skirmish := true ;
23591: LD_ADDR_EXP 74
23595: PUSH
23596: LD_INT 1
23598: ST_TO_ADDR
// end ;
23599: LD_VAR 0 1
23603: RET
// export function MC_InitResearch ( ) ; var i , j , nation , tmp , un ; begin
23604: LD_INT 0
23606: PPUSH
23607: PPUSH
23608: PPUSH
23609: PPUSH
23610: PPUSH
23611: PPUSH
// if not mc_bases then
23612: LD_EXP 76
23616: NOT
23617: IFFALSE 23621
// exit ;
23619: GO 23860
// for i = 1 to 8 do
23621: LD_ADDR_VAR 0 2
23625: PUSH
23626: DOUBLE
23627: LD_INT 1
23629: DEC
23630: ST_TO_ADDR
23631: LD_INT 8
23633: PUSH
23634: FOR_TO
23635: IFFALSE 23661
// mc_tech := Replace ( mc_tech , i , [ ] ) ;
23637: LD_ADDR_EXP 103
23641: PUSH
23642: LD_EXP 103
23646: PPUSH
23647: LD_VAR 0 2
23651: PPUSH
23652: EMPTY
23653: PPUSH
23654: CALL_OW 1
23658: ST_TO_ADDR
23659: GO 23634
23661: POP
23662: POP
// tmp := [ ] ;
23663: LD_ADDR_VAR 0 5
23667: PUSH
23668: EMPTY
23669: ST_TO_ADDR
// for i = 1 to mc_sides do
23670: LD_ADDR_VAR 0 2
23674: PUSH
23675: DOUBLE
23676: LD_INT 1
23678: DEC
23679: ST_TO_ADDR
23680: LD_EXP 102
23684: PUSH
23685: FOR_TO
23686: IFFALSE 23744
// if not mc_sides [ i ] in tmp then
23688: LD_EXP 102
23692: PUSH
23693: LD_VAR 0 2
23697: ARRAY
23698: PUSH
23699: LD_VAR 0 5
23703: IN
23704: NOT
23705: IFFALSE 23742
// tmp := Insert ( tmp , tmp + 1 , mc_sides [ i ] ) ;
23707: LD_ADDR_VAR 0 5
23711: PUSH
23712: LD_VAR 0 5
23716: PPUSH
23717: LD_VAR 0 5
23721: PUSH
23722: LD_INT 1
23724: PLUS
23725: PPUSH
23726: LD_EXP 102
23730: PUSH
23731: LD_VAR 0 2
23735: ARRAY
23736: PPUSH
23737: CALL_OW 2
23741: ST_TO_ADDR
23742: GO 23685
23744: POP
23745: POP
// if not tmp then
23746: LD_VAR 0 5
23750: NOT
23751: IFFALSE 23755
// exit ;
23753: GO 23860
// for j in tmp do
23755: LD_ADDR_VAR 0 3
23759: PUSH
23760: LD_VAR 0 5
23764: PUSH
23765: FOR_IN
23766: IFFALSE 23858
// begin un := FilterAllUnits ( [ f_side , j ] ) ;
23768: LD_ADDR_VAR 0 6
23772: PUSH
23773: LD_INT 22
23775: PUSH
23776: LD_VAR 0 3
23780: PUSH
23781: EMPTY
23782: LIST
23783: LIST
23784: PPUSH
23785: CALL_OW 69
23789: ST_TO_ADDR
// if not un then
23790: LD_VAR 0 6
23794: NOT
23795: IFFALSE 23799
// continue ;
23797: GO 23765
// nation := GetNation ( un [ 1 ] ) ;
23799: LD_ADDR_VAR 0 4
23803: PUSH
23804: LD_VAR 0 6
23808: PUSH
23809: LD_INT 1
23811: ARRAY
23812: PPUSH
23813: CALL_OW 248
23817: ST_TO_ADDR
// mc_tech := Replace ( mc_tech , j , GetTechNation ( j , nation , state_enabled ) ) ;
23818: LD_ADDR_EXP 103
23822: PUSH
23823: LD_EXP 103
23827: PPUSH
23828: LD_VAR 0 3
23832: PPUSH
23833: LD_VAR 0 3
23837: PPUSH
23838: LD_VAR 0 4
23842: PPUSH
23843: LD_INT 1
23845: PPUSH
23846: CALL 50470 0 3
23850: PPUSH
23851: CALL_OW 1
23855: ST_TO_ADDR
// end ;
23856: GO 23765
23858: POP
23859: POP
// end ;
23860: LD_VAR 0 1
23864: RET
// export function MC_InitSides ( ) ; var i ; begin
23865: LD_INT 0
23867: PPUSH
23868: PPUSH
// if not mc_bases then
23869: LD_EXP 76
23873: NOT
23874: IFFALSE 23878
// exit ;
23876: GO 23952
// for i = 1 to mc_bases do
23878: LD_ADDR_VAR 0 2
23882: PUSH
23883: DOUBLE
23884: LD_INT 1
23886: DEC
23887: ST_TO_ADDR
23888: LD_EXP 76
23892: PUSH
23893: FOR_TO
23894: IFFALSE 23950
// if mc_bases [ i ] then
23896: LD_EXP 76
23900: PUSH
23901: LD_VAR 0 2
23905: ARRAY
23906: IFFALSE 23948
// mc_sides := Replace ( mc_sides , i , GetSide ( mc_bases [ i ] [ 1 ] ) ) ;
23908: LD_ADDR_EXP 102
23912: PUSH
23913: LD_EXP 102
23917: PPUSH
23918: LD_VAR 0 2
23922: PPUSH
23923: LD_EXP 76
23927: PUSH
23928: LD_VAR 0 2
23932: ARRAY
23933: PUSH
23934: LD_INT 1
23936: ARRAY
23937: PPUSH
23938: CALL_OW 255
23942: PPUSH
23943: CALL_OW 1
23947: ST_TO_ADDR
23948: GO 23893
23950: POP
23951: POP
// end ;
23952: LD_VAR 0 1
23956: RET
// every 0 0$01 trigger skirmish do
23957: LD_EXP 74
23961: IFFALSE 24115
23963: GO 23965
23965: DISABLE
// begin enable ;
23966: ENABLE
// MC_CheckBuildings ( ) ;
23967: CALL 28613 0 0
// MC_CheckPeopleLife ( ) ;
23971: CALL 28738 0 0
// RaiseSailEvent ( 100 ) ;
23975: LD_INT 100
23977: PPUSH
23978: CALL_OW 427
// RaiseSailEvent ( 103 ) ;
23982: LD_INT 103
23984: PPUSH
23985: CALL_OW 427
// RaiseSailEvent ( 104 ) ;
23989: LD_INT 104
23991: PPUSH
23992: CALL_OW 427
// RaiseSailEvent ( 105 ) ;
23996: LD_INT 105
23998: PPUSH
23999: CALL_OW 427
// RaiseSailEvent ( 106 ) ;
24003: LD_INT 106
24005: PPUSH
24006: CALL_OW 427
// RaiseSailEvent ( 107 ) ;
24010: LD_INT 107
24012: PPUSH
24013: CALL_OW 427
// RaiseSailEvent ( 108 ) ;
24017: LD_INT 108
24019: PPUSH
24020: CALL_OW 427
// RaiseSailEvent ( 109 ) ;
24024: LD_INT 109
24026: PPUSH
24027: CALL_OW 427
// RaiseSailEvent ( 110 ) ;
24031: LD_INT 110
24033: PPUSH
24034: CALL_OW 427
// RaiseSailEvent ( 111 ) ;
24038: LD_INT 111
24040: PPUSH
24041: CALL_OW 427
// RaiseSailEvent ( 112 ) ;
24045: LD_INT 112
24047: PPUSH
24048: CALL_OW 427
// RaiseSailEvent ( 113 ) ;
24052: LD_INT 113
24054: PPUSH
24055: CALL_OW 427
// RaiseSailEvent ( 120 ) ;
24059: LD_INT 120
24061: PPUSH
24062: CALL_OW 427
// RaiseSailEvent ( 121 ) ;
24066: LD_INT 121
24068: PPUSH
24069: CALL_OW 427
// RaiseSailEvent ( 122 ) ;
24073: LD_INT 122
24075: PPUSH
24076: CALL_OW 427
// RaiseSailEvent ( 123 ) ;
24080: LD_INT 123
24082: PPUSH
24083: CALL_OW 427
// RaiseSailEvent ( 124 ) ;
24087: LD_INT 124
24089: PPUSH
24090: CALL_OW 427
// RaiseSailEvent ( 125 ) ;
24094: LD_INT 125
24096: PPUSH
24097: CALL_OW 427
// RaiseSailEvent ( 126 ) ;
24101: LD_INT 126
24103: PPUSH
24104: CALL_OW 427
// RaiseSailEvent ( 200 ) ;
24108: LD_INT 200
24110: PPUSH
24111: CALL_OW 427
// end ;
24115: END
// on SailEvent ( event ) do begin if event < 100 then
24116: LD_VAR 0 1
24120: PUSH
24121: LD_INT 100
24123: LESS
24124: IFFALSE 24135
// CustomEvent ( event ) ;
24126: LD_VAR 0 1
24130: PPUSH
24131: CALL 10344 0 1
// if event = 100 then
24135: LD_VAR 0 1
24139: PUSH
24140: LD_INT 100
24142: EQUAL
24143: IFFALSE 24149
// MC_ClassManager ( ) ;
24145: CALL 24541 0 0
// if event = 101 then
24149: LD_VAR 0 1
24153: PUSH
24154: LD_INT 101
24156: EQUAL
24157: IFFALSE 24163
// MC_RepairBuildings ( ) ;
24159: CALL 29334 0 0
// if event = 102 then
24163: LD_VAR 0 1
24167: PUSH
24168: LD_INT 102
24170: EQUAL
24171: IFFALSE 24177
// MC_Heal ( ) ;
24173: CALL 30198 0 0
// if event = 103 then
24177: LD_VAR 0 1
24181: PUSH
24182: LD_INT 103
24184: EQUAL
24185: IFFALSE 24191
// MC_Build ( ) ;
24187: CALL 30620 0 0
// if event = 104 then
24191: LD_VAR 0 1
24195: PUSH
24196: LD_INT 104
24198: EQUAL
24199: IFFALSE 24205
// MC_TurretWeapon ( ) ;
24201: CALL 32233 0 0
// if event = 105 then
24205: LD_VAR 0 1
24209: PUSH
24210: LD_INT 105
24212: EQUAL
24213: IFFALSE 24219
// MC_BuildUpgrade ( ) ;
24215: CALL 31784 0 0
// if event = 106 then
24219: LD_VAR 0 1
24223: PUSH
24224: LD_INT 106
24226: EQUAL
24227: IFFALSE 24233
// MC_PlantMines ( ) ;
24229: CALL 32663 0 0
// if event = 107 then
24233: LD_VAR 0 1
24237: PUSH
24238: LD_INT 107
24240: EQUAL
24241: IFFALSE 24247
// MC_CollectCrates ( ) ;
24243: CALL 33461 0 0
// if event = 108 then
24247: LD_VAR 0 1
24251: PUSH
24252: LD_INT 108
24254: EQUAL
24255: IFFALSE 24261
// MC_LinkRemoteControl ( ) ;
24257: CALL 35237 0 0
// if event = 109 then
24261: LD_VAR 0 1
24265: PUSH
24266: LD_INT 109
24268: EQUAL
24269: IFFALSE 24275
// MC_ProduceVehicle ( ) ;
24271: CALL 35418 0 0
// if event = 110 then
24275: LD_VAR 0 1
24279: PUSH
24280: LD_INT 110
24282: EQUAL
24283: IFFALSE 24289
// MC_SendAttack ( ) ;
24285: CALL 35884 0 0
// if event = 111 then
24289: LD_VAR 0 1
24293: PUSH
24294: LD_INT 111
24296: EQUAL
24297: IFFALSE 24303
// MC_Defend ( ) ;
24299: CALL 35992 0 0
// if event = 112 then
24303: LD_VAR 0 1
24307: PUSH
24308: LD_INT 112
24310: EQUAL
24311: IFFALSE 24317
// MC_Research ( ) ;
24313: CALL 36597 0 0
// if event = 113 then
24317: LD_VAR 0 1
24321: PUSH
24322: LD_INT 113
24324: EQUAL
24325: IFFALSE 24331
// MC_MinesTrigger ( ) ;
24327: CALL 37711 0 0
// if event = 120 then
24331: LD_VAR 0 1
24335: PUSH
24336: LD_INT 120
24338: EQUAL
24339: IFFALSE 24345
// MC_RepairVehicle ( ) ;
24341: CALL 37810 0 0
// if event = 121 then
24345: LD_VAR 0 1
24349: PUSH
24350: LD_INT 121
24352: EQUAL
24353: IFFALSE 24359
// MC_TameApe ( ) ;
24355: CALL 38540 0 0
// if event = 122 then
24359: LD_VAR 0 1
24363: PUSH
24364: LD_INT 122
24366: EQUAL
24367: IFFALSE 24373
// MC_ChangeApeClass ( ) ;
24369: CALL 39369 0 0
// if event = 123 then
24373: LD_VAR 0 1
24377: PUSH
24378: LD_INT 123
24380: EQUAL
24381: IFFALSE 24387
// MC_Bazooka ( ) ;
24383: CALL 40019 0 0
// if event = 124 then
24387: LD_VAR 0 1
24391: PUSH
24392: LD_INT 124
24394: EQUAL
24395: IFFALSE 24401
// MC_TeleportExit ( ) ;
24397: CALL 40217 0 0
// if event = 125 then
24401: LD_VAR 0 1
24405: PUSH
24406: LD_INT 125
24408: EQUAL
24409: IFFALSE 24415
// MC_Deposits ( ) ;
24411: CALL 40864 0 0
// if event = 126 then
24415: LD_VAR 0 1
24419: PUSH
24420: LD_INT 126
24422: EQUAL
24423: IFFALSE 24429
// MC_RemoteDriver ( ) ;
24425: CALL 41489 0 0
// if event = 200 then
24429: LD_VAR 0 1
24433: PUSH
24434: LD_INT 200
24436: EQUAL
24437: IFFALSE 24443
// MC_Idle ( ) ;
24439: CALL 43438 0 0
// end ;
24443: PPOPN 1
24445: END
// export function MC_Reset ( base , tag ) ; var i ; begin
24446: LD_INT 0
24448: PPUSH
24449: PPUSH
// if not mc_bases [ base ] or not tag then
24450: LD_EXP 76
24454: PUSH
24455: LD_VAR 0 1
24459: ARRAY
24460: NOT
24461: PUSH
24462: LD_VAR 0 2
24466: NOT
24467: OR
24468: IFFALSE 24472
// exit ;
24470: GO 24536
// for i in mc_bases [ base ] union mc_ape [ base ] do
24472: LD_ADDR_VAR 0 4
24476: PUSH
24477: LD_EXP 76
24481: PUSH
24482: LD_VAR 0 1
24486: ARRAY
24487: PUSH
24488: LD_EXP 105
24492: PUSH
24493: LD_VAR 0 1
24497: ARRAY
24498: UNION
24499: PUSH
24500: FOR_IN
24501: IFFALSE 24534
// if GetTag ( i ) = tag then
24503: LD_VAR 0 4
24507: PPUSH
24508: CALL_OW 110
24512: PUSH
24513: LD_VAR 0 2
24517: EQUAL
24518: IFFALSE 24532
// SetTag ( i , 0 ) ;
24520: LD_VAR 0 4
24524: PPUSH
24525: LD_INT 0
24527: PPUSH
24528: CALL_OW 109
24532: GO 24500
24534: POP
24535: POP
// end ;
24536: LD_VAR 0 3
24540: RET
// export function MC_ClassManager ( ) ; var i , j , tmp , p , b , e , k ; begin
24541: LD_INT 0
24543: PPUSH
24544: PPUSH
24545: PPUSH
24546: PPUSH
24547: PPUSH
24548: PPUSH
24549: PPUSH
24550: PPUSH
// if not mc_bases then
24551: LD_EXP 76
24555: NOT
24556: IFFALSE 24560
// exit ;
24558: GO 25018
// for i = 1 to mc_bases do
24560: LD_ADDR_VAR 0 2
24564: PUSH
24565: DOUBLE
24566: LD_INT 1
24568: DEC
24569: ST_TO_ADDR
24570: LD_EXP 76
24574: PUSH
24575: FOR_TO
24576: IFFALSE 25016
// begin tmp := MC_ClassCheckReq ( i ) ;
24578: LD_ADDR_VAR 0 4
24582: PUSH
24583: LD_VAR 0 2
24587: PPUSH
24588: CALL 25023 0 1
24592: ST_TO_ADDR
// mc_class := Replace ( mc_class , i , tmp ) ;
24593: LD_ADDR_EXP 117
24597: PUSH
24598: LD_EXP 117
24602: PPUSH
24603: LD_VAR 0 2
24607: PPUSH
24608: LD_VAR 0 4
24612: PPUSH
24613: CALL_OW 1
24617: ST_TO_ADDR
// if not tmp then
24618: LD_VAR 0 4
24622: NOT
24623: IFFALSE 24627
// continue ;
24625: GO 24575
// b := [ UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_armoury ] , [ f_btype , b_barracks ] ] ) , UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) , UnitFilter ( mc_bases [ i ] , [ f_btype , b_factory ] ) , UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_lab ] , [ f_btype , b_lab_half ] , [ f_btype , b_lab_full ] ] ) ] ;
24627: LD_ADDR_VAR 0 6
24631: PUSH
24632: LD_EXP 76
24636: PUSH
24637: LD_VAR 0 2
24641: ARRAY
24642: PPUSH
24643: LD_INT 2
24645: PUSH
24646: LD_INT 30
24648: PUSH
24649: LD_INT 4
24651: PUSH
24652: EMPTY
24653: LIST
24654: LIST
24655: PUSH
24656: LD_INT 30
24658: PUSH
24659: LD_INT 5
24661: PUSH
24662: EMPTY
24663: LIST
24664: LIST
24665: PUSH
24666: EMPTY
24667: LIST
24668: LIST
24669: LIST
24670: PPUSH
24671: CALL_OW 72
24675: PUSH
24676: LD_EXP 76
24680: PUSH
24681: LD_VAR 0 2
24685: ARRAY
24686: PPUSH
24687: LD_INT 2
24689: PUSH
24690: LD_INT 30
24692: PUSH
24693: LD_INT 0
24695: PUSH
24696: EMPTY
24697: LIST
24698: LIST
24699: PUSH
24700: LD_INT 30
24702: PUSH
24703: LD_INT 1
24705: PUSH
24706: EMPTY
24707: LIST
24708: LIST
24709: PUSH
24710: EMPTY
24711: LIST
24712: LIST
24713: LIST
24714: PPUSH
24715: CALL_OW 72
24719: PUSH
24720: LD_EXP 76
24724: PUSH
24725: LD_VAR 0 2
24729: ARRAY
24730: PPUSH
24731: LD_INT 30
24733: PUSH
24734: LD_INT 3
24736: PUSH
24737: EMPTY
24738: LIST
24739: LIST
24740: PPUSH
24741: CALL_OW 72
24745: PUSH
24746: LD_EXP 76
24750: PUSH
24751: LD_VAR 0 2
24755: ARRAY
24756: PPUSH
24757: LD_INT 2
24759: PUSH
24760: LD_INT 30
24762: PUSH
24763: LD_INT 6
24765: PUSH
24766: EMPTY
24767: LIST
24768: LIST
24769: PUSH
24770: LD_INT 30
24772: PUSH
24773: LD_INT 7
24775: PUSH
24776: EMPTY
24777: LIST
24778: LIST
24779: PUSH
24780: LD_INT 30
24782: PUSH
24783: LD_INT 8
24785: PUSH
24786: EMPTY
24787: LIST
24788: LIST
24789: PUSH
24790: EMPTY
24791: LIST
24792: LIST
24793: LIST
24794: LIST
24795: PPUSH
24796: CALL_OW 72
24800: PUSH
24801: EMPTY
24802: LIST
24803: LIST
24804: LIST
24805: LIST
24806: ST_TO_ADDR
// for j = 1 to 4 do
24807: LD_ADDR_VAR 0 3
24811: PUSH
24812: DOUBLE
24813: LD_INT 1
24815: DEC
24816: ST_TO_ADDR
24817: LD_INT 4
24819: PUSH
24820: FOR_TO
24821: IFFALSE 25012
// begin if not tmp [ j ] then
24823: LD_VAR 0 4
24827: PUSH
24828: LD_VAR 0 3
24832: ARRAY
24833: NOT
24834: IFFALSE 24838
// continue ;
24836: GO 24820
// for p in tmp [ j ] do
24838: LD_ADDR_VAR 0 5
24842: PUSH
24843: LD_VAR 0 4
24847: PUSH
24848: LD_VAR 0 3
24852: ARRAY
24853: PUSH
24854: FOR_IN
24855: IFFALSE 25008
// begin if not b [ j ] then
24857: LD_VAR 0 6
24861: PUSH
24862: LD_VAR 0 3
24866: ARRAY
24867: NOT
24868: IFFALSE 24872
// break ;
24870: GO 25008
// e := 0 ;
24872: LD_ADDR_VAR 0 7
24876: PUSH
24877: LD_INT 0
24879: ST_TO_ADDR
// for k in b [ j ] do
24880: LD_ADDR_VAR 0 8
24884: PUSH
24885: LD_VAR 0 6
24889: PUSH
24890: LD_VAR 0 3
24894: ARRAY
24895: PUSH
24896: FOR_IN
24897: IFFALSE 24924
// if IsNotFull ( k ) then
24899: LD_VAR 0 8
24903: PPUSH
24904: CALL 54910 0 1
24908: IFFALSE 24922
// begin e := k ;
24910: LD_ADDR_VAR 0 7
24914: PUSH
24915: LD_VAR 0 8
24919: ST_TO_ADDR
// break ;
24920: GO 24924
// end ;
24922: GO 24896
24924: POP
24925: POP
// if e and not UnitGoingToBuilding ( p , e ) then
24926: LD_VAR 0 7
24930: PUSH
24931: LD_VAR 0 5
24935: PPUSH
24936: LD_VAR 0 7
24940: PPUSH
24941: CALL 92032 0 2
24945: NOT
24946: AND
24947: IFFALSE 25006
// begin if IsInUnit ( p ) then
24949: LD_VAR 0 5
24953: PPUSH
24954: CALL_OW 310
24958: IFFALSE 24969
// ComExitBuilding ( p ) ;
24960: LD_VAR 0 5
24964: PPUSH
24965: CALL_OW 122
// ComEnterUnit ( p , e ) ;
24969: LD_VAR 0 5
24973: PPUSH
24974: LD_VAR 0 7
24978: PPUSH
24979: CALL_OW 120
// AddComChangeProfession ( p , j ) ;
24983: LD_VAR 0 5
24987: PPUSH
24988: LD_VAR 0 3
24992: PPUSH
24993: CALL_OW 183
// AddComExitBuilding ( p ) ;
24997: LD_VAR 0 5
25001: PPUSH
25002: CALL_OW 182
// end ; end ;
25006: GO 24854
25008: POP
25009: POP
// end ;
25010: GO 24820
25012: POP
25013: POP
// end ;
25014: GO 24575
25016: POP
25017: POP
// end ;
25018: LD_VAR 0 1
25022: RET
// export function MC_ClassCheckReq ( base ) ; var i , tmp , sol , eng , mech , sci , sort , j , p , b , bcount ; begin
25023: LD_INT 0
25025: PPUSH
25026: PPUSH
25027: PPUSH
25028: PPUSH
25029: PPUSH
25030: PPUSH
25031: PPUSH
25032: PPUSH
25033: PPUSH
25034: PPUSH
25035: PPUSH
25036: PPUSH
// if not base or not mc_bases [ base ] or not UnitFilter ( mc_bases [ base ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) then
25037: LD_VAR 0 1
25041: NOT
25042: PUSH
25043: LD_EXP 76
25047: PUSH
25048: LD_VAR 0 1
25052: ARRAY
25053: NOT
25054: OR
25055: PUSH
25056: LD_EXP 76
25060: PUSH
25061: LD_VAR 0 1
25065: ARRAY
25066: PPUSH
25067: LD_INT 2
25069: PUSH
25070: LD_INT 30
25072: PUSH
25073: LD_INT 0
25075: PUSH
25076: EMPTY
25077: LIST
25078: LIST
25079: PUSH
25080: LD_INT 30
25082: PUSH
25083: LD_INT 1
25085: PUSH
25086: EMPTY
25087: LIST
25088: LIST
25089: PUSH
25090: EMPTY
25091: LIST
25092: LIST
25093: LIST
25094: PPUSH
25095: CALL_OW 72
25099: NOT
25100: OR
25101: IFFALSE 25105
// exit ;
25103: GO 28608
// tmp := UnitFilter ( mc_bases [ base ] , [ f_or , [ f_class , 1 ] , [ f_class , 2 ] , [ f_class , 3 ] , [ f_class , 4 ] , [ f_class , 5 ] , [ f_class , 8 ] , [ f_class , 9 ] ] ) ;
25105: LD_ADDR_VAR 0 4
25109: PUSH
25110: LD_EXP 76
25114: PUSH
25115: LD_VAR 0 1
25119: ARRAY
25120: PPUSH
25121: LD_INT 2
25123: PUSH
25124: LD_INT 25
25126: PUSH
25127: LD_INT 1
25129: PUSH
25130: EMPTY
25131: LIST
25132: LIST
25133: PUSH
25134: LD_INT 25
25136: PUSH
25137: LD_INT 2
25139: PUSH
25140: EMPTY
25141: LIST
25142: LIST
25143: PUSH
25144: LD_INT 25
25146: PUSH
25147: LD_INT 3
25149: PUSH
25150: EMPTY
25151: LIST
25152: LIST
25153: PUSH
25154: LD_INT 25
25156: PUSH
25157: LD_INT 4
25159: PUSH
25160: EMPTY
25161: LIST
25162: LIST
25163: PUSH
25164: LD_INT 25
25166: PUSH
25167: LD_INT 5
25169: PUSH
25170: EMPTY
25171: LIST
25172: LIST
25173: PUSH
25174: LD_INT 25
25176: PUSH
25177: LD_INT 8
25179: PUSH
25180: EMPTY
25181: LIST
25182: LIST
25183: PUSH
25184: LD_INT 25
25186: PUSH
25187: LD_INT 9
25189: PUSH
25190: EMPTY
25191: LIST
25192: LIST
25193: PUSH
25194: EMPTY
25195: LIST
25196: LIST
25197: LIST
25198: LIST
25199: LIST
25200: LIST
25201: LIST
25202: LIST
25203: PPUSH
25204: CALL_OW 72
25208: ST_TO_ADDR
// if not tmp then
25209: LD_VAR 0 4
25213: NOT
25214: IFFALSE 25218
// exit ;
25216: GO 28608
// for i in tmp do
25218: LD_ADDR_VAR 0 3
25222: PUSH
25223: LD_VAR 0 4
25227: PUSH
25228: FOR_IN
25229: IFFALSE 25260
// if GetTag ( i ) then
25231: LD_VAR 0 3
25235: PPUSH
25236: CALL_OW 110
25240: IFFALSE 25258
// tmp := tmp diff i ;
25242: LD_ADDR_VAR 0 4
25246: PUSH
25247: LD_VAR 0 4
25251: PUSH
25252: LD_VAR 0 3
25256: DIFF
25257: ST_TO_ADDR
25258: GO 25228
25260: POP
25261: POP
// if not tmp then
25262: LD_VAR 0 4
25266: NOT
25267: IFFALSE 25271
// exit ;
25269: GO 28608
// sol := UnitFilter ( mc_bases [ base ] , [ f_or , [ f_class , 1 ] , [ f_class , 5 ] , [ f_class , 8 ] , [ f_class , 9 ] ] ) ;
25271: LD_ADDR_VAR 0 5
25275: PUSH
25276: LD_EXP 76
25280: PUSH
25281: LD_VAR 0 1
25285: ARRAY
25286: PPUSH
25287: LD_INT 2
25289: PUSH
25290: LD_INT 25
25292: PUSH
25293: LD_INT 1
25295: PUSH
25296: EMPTY
25297: LIST
25298: LIST
25299: PUSH
25300: LD_INT 25
25302: PUSH
25303: LD_INT 5
25305: PUSH
25306: EMPTY
25307: LIST
25308: LIST
25309: PUSH
25310: LD_INT 25
25312: PUSH
25313: LD_INT 8
25315: PUSH
25316: EMPTY
25317: LIST
25318: LIST
25319: PUSH
25320: LD_INT 25
25322: PUSH
25323: LD_INT 9
25325: PUSH
25326: EMPTY
25327: LIST
25328: LIST
25329: PUSH
25330: EMPTY
25331: LIST
25332: LIST
25333: LIST
25334: LIST
25335: LIST
25336: PPUSH
25337: CALL_OW 72
25341: ST_TO_ADDR
// eng := UnitFilter ( mc_bases [ base ] , [ f_class , 2 ] ) ;
25342: LD_ADDR_VAR 0 6
25346: PUSH
25347: LD_EXP 76
25351: PUSH
25352: LD_VAR 0 1
25356: ARRAY
25357: PPUSH
25358: LD_INT 25
25360: PUSH
25361: LD_INT 2
25363: PUSH
25364: EMPTY
25365: LIST
25366: LIST
25367: PPUSH
25368: CALL_OW 72
25372: ST_TO_ADDR
// mech := UnitFilter ( mc_bases [ base ] , [ f_class , 3 ] ) ;
25373: LD_ADDR_VAR 0 7
25377: PUSH
25378: LD_EXP 76
25382: PUSH
25383: LD_VAR 0 1
25387: ARRAY
25388: PPUSH
25389: LD_INT 25
25391: PUSH
25392: LD_INT 3
25394: PUSH
25395: EMPTY
25396: LIST
25397: LIST
25398: PPUSH
25399: CALL_OW 72
25403: ST_TO_ADDR
// sci := UnitFilter ( mc_bases [ base ] , [ [ f_class , 4 ] , [ f_lives , 251 ] ] ) ;
25404: LD_ADDR_VAR 0 8
25408: PUSH
25409: LD_EXP 76
25413: PUSH
25414: LD_VAR 0 1
25418: ARRAY
25419: PPUSH
25420: LD_INT 25
25422: PUSH
25423: LD_INT 4
25425: PUSH
25426: EMPTY
25427: LIST
25428: LIST
25429: PUSH
25430: LD_INT 24
25432: PUSH
25433: LD_INT 251
25435: PUSH
25436: EMPTY
25437: LIST
25438: LIST
25439: PUSH
25440: EMPTY
25441: LIST
25442: LIST
25443: PPUSH
25444: CALL_OW 72
25448: ST_TO_ADDR
// if mc_scan [ base ] then
25449: LD_EXP 99
25453: PUSH
25454: LD_VAR 0 1
25458: ARRAY
25459: IFFALSE 25920
// begin mc_class_case_use := Replace ( mc_class_case_use , base , 4 ) ;
25461: LD_ADDR_EXP 118
25465: PUSH
25466: LD_EXP 118
25470: PPUSH
25471: LD_VAR 0 1
25475: PPUSH
25476: LD_INT 4
25478: PPUSH
25479: CALL_OW 1
25483: ST_TO_ADDR
// b := UnitFilter ( mc_bases [ base ] , [ f_or , [ f_btype , b_armoury ] , [ f_btype , b_barracks ] ] ) ;
25484: LD_ADDR_VAR 0 12
25488: PUSH
25489: LD_EXP 76
25493: PUSH
25494: LD_VAR 0 1
25498: ARRAY
25499: PPUSH
25500: LD_INT 2
25502: PUSH
25503: LD_INT 30
25505: PUSH
25506: LD_INT 4
25508: PUSH
25509: EMPTY
25510: LIST
25511: LIST
25512: PUSH
25513: LD_INT 30
25515: PUSH
25516: LD_INT 5
25518: PUSH
25519: EMPTY
25520: LIST
25521: LIST
25522: PUSH
25523: EMPTY
25524: LIST
25525: LIST
25526: LIST
25527: PPUSH
25528: CALL_OW 72
25532: ST_TO_ADDR
// if not b then
25533: LD_VAR 0 12
25537: NOT
25538: IFFALSE 25542
// exit ;
25540: GO 28608
// p := [ ] ;
25542: LD_ADDR_VAR 0 11
25546: PUSH
25547: EMPTY
25548: ST_TO_ADDR
// if sci >= 2 then
25549: LD_VAR 0 8
25553: PUSH
25554: LD_INT 2
25556: GREATEREQUAL
25557: IFFALSE 25588
// sci := [ sci [ 1 ] , sci [ 2 ] ] else
25559: LD_ADDR_VAR 0 8
25563: PUSH
25564: LD_VAR 0 8
25568: PUSH
25569: LD_INT 1
25571: ARRAY
25572: PUSH
25573: LD_VAR 0 8
25577: PUSH
25578: LD_INT 2
25580: ARRAY
25581: PUSH
25582: EMPTY
25583: LIST
25584: LIST
25585: ST_TO_ADDR
25586: GO 25649
// if sci = 1 then
25588: LD_VAR 0 8
25592: PUSH
25593: LD_INT 1
25595: EQUAL
25596: IFFALSE 25617
// sci := [ sci [ 1 ] ] else
25598: LD_ADDR_VAR 0 8
25602: PUSH
25603: LD_VAR 0 8
25607: PUSH
25608: LD_INT 1
25610: ARRAY
25611: PUSH
25612: EMPTY
25613: LIST
25614: ST_TO_ADDR
25615: GO 25649
// if sci = 0 then
25617: LD_VAR 0 8
25621: PUSH
25622: LD_INT 0
25624: EQUAL
25625: IFFALSE 25649
// p := SortBySkill ( tmp , 4 ) [ 1 ] ;
25627: LD_ADDR_VAR 0 11
25631: PUSH
25632: LD_VAR 0 4
25636: PPUSH
25637: LD_INT 4
25639: PPUSH
25640: CALL 91895 0 2
25644: PUSH
25645: LD_INT 1
25647: ARRAY
25648: ST_TO_ADDR
// if eng > 4 then
25649: LD_VAR 0 6
25653: PUSH
25654: LD_INT 4
25656: GREATER
25657: IFFALSE 25703
// for i = eng downto 4 do
25659: LD_ADDR_VAR 0 3
25663: PUSH
25664: DOUBLE
25665: LD_VAR 0 6
25669: INC
25670: ST_TO_ADDR
25671: LD_INT 4
25673: PUSH
25674: FOR_DOWNTO
25675: IFFALSE 25701
// eng := eng diff eng [ i ] ;
25677: LD_ADDR_VAR 0 6
25681: PUSH
25682: LD_VAR 0 6
25686: PUSH
25687: LD_VAR 0 6
25691: PUSH
25692: LD_VAR 0 3
25696: ARRAY
25697: DIFF
25698: ST_TO_ADDR
25699: GO 25674
25701: POP
25702: POP
// tmp := tmp diff ( sol union eng union mech union sci ) ;
25703: LD_ADDR_VAR 0 4
25707: PUSH
25708: LD_VAR 0 4
25712: PUSH
25713: LD_VAR 0 5
25717: PUSH
25718: LD_VAR 0 6
25722: UNION
25723: PUSH
25724: LD_VAR 0 7
25728: UNION
25729: PUSH
25730: LD_VAR 0 8
25734: UNION
25735: DIFF
25736: ST_TO_ADDR
// bcount := UnitFilter ( mc_bases [ base ] , [ f_or , [ f_btype , b_bunker ] , [ f_btype , b_breastwork ] ] ) + UnitFilter ( mc_bases [ base ] , [ f_or , [ f_btype , b_armoury ] , [ f_btype , b_barracks ] ] ) * 6 ;
25737: LD_ADDR_VAR 0 13
25741: PUSH
25742: LD_EXP 76
25746: PUSH
25747: LD_VAR 0 1
25751: ARRAY
25752: PPUSH
25753: LD_INT 2
25755: PUSH
25756: LD_INT 30
25758: PUSH
25759: LD_INT 32
25761: PUSH
25762: EMPTY
25763: LIST
25764: LIST
25765: PUSH
25766: LD_INT 30
25768: PUSH
25769: LD_INT 31
25771: PUSH
25772: EMPTY
25773: LIST
25774: LIST
25775: PUSH
25776: EMPTY
25777: LIST
25778: LIST
25779: LIST
25780: PPUSH
25781: CALL_OW 72
25785: PUSH
25786: LD_EXP 76
25790: PUSH
25791: LD_VAR 0 1
25795: ARRAY
25796: PPUSH
25797: LD_INT 2
25799: PUSH
25800: LD_INT 30
25802: PUSH
25803: LD_INT 4
25805: PUSH
25806: EMPTY
25807: LIST
25808: LIST
25809: PUSH
25810: LD_INT 30
25812: PUSH
25813: LD_INT 5
25815: PUSH
25816: EMPTY
25817: LIST
25818: LIST
25819: PUSH
25820: EMPTY
25821: LIST
25822: LIST
25823: LIST
25824: PPUSH
25825: CALL_OW 72
25829: PUSH
25830: LD_INT 6
25832: MUL
25833: PLUS
25834: ST_TO_ADDR
// if bcount < tmp then
25835: LD_VAR 0 13
25839: PUSH
25840: LD_VAR 0 4
25844: LESS
25845: IFFALSE 25891
// for i = tmp downto bcount do
25847: LD_ADDR_VAR 0 3
25851: PUSH
25852: DOUBLE
25853: LD_VAR 0 4
25857: INC
25858: ST_TO_ADDR
25859: LD_VAR 0 13
25863: PUSH
25864: FOR_DOWNTO
25865: IFFALSE 25889
// tmp := Delete ( tmp , tmp ) ;
25867: LD_ADDR_VAR 0 4
25871: PUSH
25872: LD_VAR 0 4
25876: PPUSH
25877: LD_VAR 0 4
25881: PPUSH
25882: CALL_OW 3
25886: ST_TO_ADDR
25887: GO 25864
25889: POP
25890: POP
// result := [ tmp , 0 , 0 , p ] ;
25891: LD_ADDR_VAR 0 2
25895: PUSH
25896: LD_VAR 0 4
25900: PUSH
25901: LD_INT 0
25903: PUSH
25904: LD_INT 0
25906: PUSH
25907: LD_VAR 0 11
25911: PUSH
25912: EMPTY
25913: LIST
25914: LIST
25915: LIST
25916: LIST
25917: ST_TO_ADDR
// exit ;
25918: GO 28608
// end ; if not UnitFilter ( mc_bases [ base ] , [ f_or , [ f_btype , b_lab ] , [ f_btype , b_lab_half ] , [ f_btype , b_lab_full ] ] ) and not UnitFilter ( mc_bases [ base ] , [ f_btype , b_factory ] ) then
25920: LD_EXP 76
25924: PUSH
25925: LD_VAR 0 1
25929: ARRAY
25930: PPUSH
25931: LD_INT 2
25933: PUSH
25934: LD_INT 30
25936: PUSH
25937: LD_INT 6
25939: PUSH
25940: EMPTY
25941: LIST
25942: LIST
25943: PUSH
25944: LD_INT 30
25946: PUSH
25947: LD_INT 7
25949: PUSH
25950: EMPTY
25951: LIST
25952: LIST
25953: PUSH
25954: LD_INT 30
25956: PUSH
25957: LD_INT 8
25959: PUSH
25960: EMPTY
25961: LIST
25962: LIST
25963: PUSH
25964: EMPTY
25965: LIST
25966: LIST
25967: LIST
25968: LIST
25969: PPUSH
25970: CALL_OW 72
25974: NOT
25975: PUSH
25976: LD_EXP 76
25980: PUSH
25981: LD_VAR 0 1
25985: ARRAY
25986: PPUSH
25987: LD_INT 30
25989: PUSH
25990: LD_INT 3
25992: PUSH
25993: EMPTY
25994: LIST
25995: LIST
25996: PPUSH
25997: CALL_OW 72
26001: NOT
26002: AND
26003: IFFALSE 26075
// begin if eng = tmp then
26005: LD_VAR 0 6
26009: PUSH
26010: LD_VAR 0 4
26014: EQUAL
26015: IFFALSE 26019
// exit ;
26017: GO 28608
// mc_class_case_use := Replace ( mc_class_case_use , base , 1 ) ;
26019: LD_ADDR_EXP 118
26023: PUSH
26024: LD_EXP 118
26028: PPUSH
26029: LD_VAR 0 1
26033: PPUSH
26034: LD_INT 1
26036: PPUSH
26037: CALL_OW 1
26041: ST_TO_ADDR
// result := [ 0 , tmp diff eng , 0 , 0 ] ;
26042: LD_ADDR_VAR 0 2
26046: PUSH
26047: LD_INT 0
26049: PUSH
26050: LD_VAR 0 4
26054: PUSH
26055: LD_VAR 0 6
26059: DIFF
26060: PUSH
26061: LD_INT 0
26063: PUSH
26064: LD_INT 0
26066: PUSH
26067: EMPTY
26068: LIST
26069: LIST
26070: LIST
26071: LIST
26072: ST_TO_ADDR
// exit ;
26073: GO 28608
// end ; if mc_tech [ mc_sides [ base ] ] and UnitFilter ( mc_bases [ base ] , [ f_or , [ f_btype , b_lab ] , [ f_btype , b_lab_half ] , [ f_btype , b_lab_full ] ] ) and not UnitFilter ( mc_bases [ base ] , [ f_btype , b_factory ] ) then
26075: LD_EXP 103
26079: PUSH
26080: LD_EXP 102
26084: PUSH
26085: LD_VAR 0 1
26089: ARRAY
26090: ARRAY
26091: PUSH
26092: LD_EXP 76
26096: PUSH
26097: LD_VAR 0 1
26101: ARRAY
26102: PPUSH
26103: LD_INT 2
26105: PUSH
26106: LD_INT 30
26108: PUSH
26109: LD_INT 6
26111: PUSH
26112: EMPTY
26113: LIST
26114: LIST
26115: PUSH
26116: LD_INT 30
26118: PUSH
26119: LD_INT 7
26121: PUSH
26122: EMPTY
26123: LIST
26124: LIST
26125: PUSH
26126: LD_INT 30
26128: PUSH
26129: LD_INT 8
26131: PUSH
26132: EMPTY
26133: LIST
26134: LIST
26135: PUSH
26136: EMPTY
26137: LIST
26138: LIST
26139: LIST
26140: LIST
26141: PPUSH
26142: CALL_OW 72
26146: AND
26147: PUSH
26148: LD_EXP 76
26152: PUSH
26153: LD_VAR 0 1
26157: ARRAY
26158: PPUSH
26159: LD_INT 30
26161: PUSH
26162: LD_INT 3
26164: PUSH
26165: EMPTY
26166: LIST
26167: LIST
26168: PPUSH
26169: CALL_OW 72
26173: NOT
26174: AND
26175: IFFALSE 26389
// begin if sci >= 6 then
26177: LD_VAR 0 8
26181: PUSH
26182: LD_INT 6
26184: GREATEREQUAL
26185: IFFALSE 26189
// exit ;
26187: GO 28608
// mc_class_case_use := Replace ( mc_class_case_use , base , 2 ) ;
26189: LD_ADDR_EXP 118
26193: PUSH
26194: LD_EXP 118
26198: PPUSH
26199: LD_VAR 0 1
26203: PPUSH
26204: LD_INT 2
26206: PPUSH
26207: CALL_OW 1
26211: ST_TO_ADDR
// sort := SortBySkill ( tmp diff sci , 4 ) ;
26212: LD_ADDR_VAR 0 9
26216: PUSH
26217: LD_VAR 0 4
26221: PUSH
26222: LD_VAR 0 8
26226: DIFF
26227: PPUSH
26228: LD_INT 4
26230: PPUSH
26231: CALL 91895 0 2
26235: ST_TO_ADDR
// p := [ ] ;
26236: LD_ADDR_VAR 0 11
26240: PUSH
26241: EMPTY
26242: ST_TO_ADDR
// if sci < 6 and sort > 6 then
26243: LD_VAR 0 8
26247: PUSH
26248: LD_INT 6
26250: LESS
26251: PUSH
26252: LD_VAR 0 9
26256: PUSH
26257: LD_INT 6
26259: GREATER
26260: AND
26261: IFFALSE 26342
// begin for i = 1 to 6 - sci do
26263: LD_ADDR_VAR 0 3
26267: PUSH
26268: DOUBLE
26269: LD_INT 1
26271: DEC
26272: ST_TO_ADDR
26273: LD_INT 6
26275: PUSH
26276: LD_VAR 0 8
26280: MINUS
26281: PUSH
26282: FOR_TO
26283: IFFALSE 26338
// begin p := Insert ( p , p + 1 , sort [ 1 ] ) ;
26285: LD_ADDR_VAR 0 11
26289: PUSH
26290: LD_VAR 0 11
26294: PPUSH
26295: LD_VAR 0 11
26299: PUSH
26300: LD_INT 1
26302: PLUS
26303: PPUSH
26304: LD_VAR 0 9
26308: PUSH
26309: LD_INT 1
26311: ARRAY
26312: PPUSH
26313: CALL_OW 2
26317: ST_TO_ADDR
// sort := Delete ( sort , 1 ) ;
26318: LD_ADDR_VAR 0 9
26322: PUSH
26323: LD_VAR 0 9
26327: PPUSH
26328: LD_INT 1
26330: PPUSH
26331: CALL_OW 3
26335: ST_TO_ADDR
// end ;
26336: GO 26282
26338: POP
26339: POP
// end else
26340: GO 26362
// if sort then
26342: LD_VAR 0 9
26346: IFFALSE 26362
// p := sort [ 1 ] ;
26348: LD_ADDR_VAR 0 11
26352: PUSH
26353: LD_VAR 0 9
26357: PUSH
26358: LD_INT 1
26360: ARRAY
26361: ST_TO_ADDR
// result := [ 0 , 0 , 0 , p ] ;
26362: LD_ADDR_VAR 0 2
26366: PUSH
26367: LD_INT 0
26369: PUSH
26370: LD_INT 0
26372: PUSH
26373: LD_INT 0
26375: PUSH
26376: LD_VAR 0 11
26380: PUSH
26381: EMPTY
26382: LIST
26383: LIST
26384: LIST
26385: LIST
26386: ST_TO_ADDR
// exit ;
26387: GO 28608
// end ; if mc_tech [ mc_sides [ base ] ] and UnitFilter ( mc_bases [ base ] , [ f_or , [ f_btype , b_lab ] , [ f_btype , b_lab_half ] , [ f_btype , b_lab_full ] ] ) and UnitFilter ( mc_bases [ base ] , [ f_btype , b_factory ] ) then
26389: LD_EXP 103
26393: PUSH
26394: LD_EXP 102
26398: PUSH
26399: LD_VAR 0 1
26403: ARRAY
26404: ARRAY
26405: PUSH
26406: LD_EXP 76
26410: PUSH
26411: LD_VAR 0 1
26415: ARRAY
26416: PPUSH
26417: LD_INT 2
26419: PUSH
26420: LD_INT 30
26422: PUSH
26423: LD_INT 6
26425: PUSH
26426: EMPTY
26427: LIST
26428: LIST
26429: PUSH
26430: LD_INT 30
26432: PUSH
26433: LD_INT 7
26435: PUSH
26436: EMPTY
26437: LIST
26438: LIST
26439: PUSH
26440: LD_INT 30
26442: PUSH
26443: LD_INT 8
26445: PUSH
26446: EMPTY
26447: LIST
26448: LIST
26449: PUSH
26450: EMPTY
26451: LIST
26452: LIST
26453: LIST
26454: LIST
26455: PPUSH
26456: CALL_OW 72
26460: AND
26461: PUSH
26462: LD_EXP 76
26466: PUSH
26467: LD_VAR 0 1
26471: ARRAY
26472: PPUSH
26473: LD_INT 30
26475: PUSH
26476: LD_INT 3
26478: PUSH
26479: EMPTY
26480: LIST
26481: LIST
26482: PPUSH
26483: CALL_OW 72
26487: AND
26488: IFFALSE 27222
// begin mc_class_case_use := Replace ( mc_class_case_use , base , 3 ) ;
26490: LD_ADDR_EXP 118
26494: PUSH
26495: LD_EXP 118
26499: PPUSH
26500: LD_VAR 0 1
26504: PPUSH
26505: LD_INT 3
26507: PPUSH
26508: CALL_OW 1
26512: ST_TO_ADDR
// result := [ 0 , 0 , 0 , 0 ] ;
26513: LD_ADDR_VAR 0 2
26517: PUSH
26518: LD_INT 0
26520: PUSH
26521: LD_INT 0
26523: PUSH
26524: LD_INT 0
26526: PUSH
26527: LD_INT 0
26529: PUSH
26530: EMPTY
26531: LIST
26532: LIST
26533: LIST
26534: LIST
26535: ST_TO_ADDR
// if not eng then
26536: LD_VAR 0 6
26540: NOT
26541: IFFALSE 26604
// begin p := SortBySkill ( tmp , 2 ) [ 1 ] ;
26543: LD_ADDR_VAR 0 11
26547: PUSH
26548: LD_VAR 0 4
26552: PPUSH
26553: LD_INT 2
26555: PPUSH
26556: CALL 91895 0 2
26560: PUSH
26561: LD_INT 1
26563: ARRAY
26564: ST_TO_ADDR
// result := Replace ( result , 2 , p ) ;
26565: LD_ADDR_VAR 0 2
26569: PUSH
26570: LD_VAR 0 2
26574: PPUSH
26575: LD_INT 2
26577: PPUSH
26578: LD_VAR 0 11
26582: PPUSH
26583: CALL_OW 1
26587: ST_TO_ADDR
// tmp := tmp diff p ;
26588: LD_ADDR_VAR 0 4
26592: PUSH
26593: LD_VAR 0 4
26597: PUSH
26598: LD_VAR 0 11
26602: DIFF
26603: ST_TO_ADDR
// end ; if tmp and sci < 6 then
26604: LD_VAR 0 4
26608: PUSH
26609: LD_VAR 0 8
26613: PUSH
26614: LD_INT 6
26616: LESS
26617: AND
26618: IFFALSE 26806
// begin sort := SortBySkill ( tmp diff ( sci union mech ) , 4 ) ;
26620: LD_ADDR_VAR 0 9
26624: PUSH
26625: LD_VAR 0 4
26629: PUSH
26630: LD_VAR 0 8
26634: PUSH
26635: LD_VAR 0 7
26639: UNION
26640: DIFF
26641: PPUSH
26642: LD_INT 4
26644: PPUSH
26645: CALL 91895 0 2
26649: ST_TO_ADDR
// p := [ ] ;
26650: LD_ADDR_VAR 0 11
26654: PUSH
26655: EMPTY
26656: ST_TO_ADDR
// if sort then
26657: LD_VAR 0 9
26661: IFFALSE 26777
// for i = 1 to 6 - sci do
26663: LD_ADDR_VAR 0 3
26667: PUSH
26668: DOUBLE
26669: LD_INT 1
26671: DEC
26672: ST_TO_ADDR
26673: LD_INT 6
26675: PUSH
26676: LD_VAR 0 8
26680: MINUS
26681: PUSH
26682: FOR_TO
26683: IFFALSE 26775
// begin if i = sort then
26685: LD_VAR 0 3
26689: PUSH
26690: LD_VAR 0 9
26694: EQUAL
26695: IFFALSE 26699
// break ;
26697: GO 26775
// if GetClass ( i ) = 4 then
26699: LD_VAR 0 3
26703: PPUSH
26704: CALL_OW 257
26708: PUSH
26709: LD_INT 4
26711: EQUAL
26712: IFFALSE 26716
// continue ;
26714: GO 26682
// p := Insert ( p , p + 1 , sort [ i ] ) ;
26716: LD_ADDR_VAR 0 11
26720: PUSH
26721: LD_VAR 0 11
26725: PPUSH
26726: LD_VAR 0 11
26730: PUSH
26731: LD_INT 1
26733: PLUS
26734: PPUSH
26735: LD_VAR 0 9
26739: PUSH
26740: LD_VAR 0 3
26744: ARRAY
26745: PPUSH
26746: CALL_OW 2
26750: ST_TO_ADDR
// tmp := tmp diff sort [ i ] ;
26751: LD_ADDR_VAR 0 4
26755: PUSH
26756: LD_VAR 0 4
26760: PUSH
26761: LD_VAR 0 9
26765: PUSH
26766: LD_VAR 0 3
26770: ARRAY
26771: DIFF
26772: ST_TO_ADDR
// end ;
26773: GO 26682
26775: POP
26776: POP
// if p then
26777: LD_VAR 0 11
26781: IFFALSE 26806
// result := Replace ( result , 4 , p ) ;
26783: LD_ADDR_VAR 0 2
26787: PUSH
26788: LD_VAR 0 2
26792: PPUSH
26793: LD_INT 4
26795: PPUSH
26796: LD_VAR 0 11
26800: PPUSH
26801: CALL_OW 1
26805: ST_TO_ADDR
// end ; if tmp and mech < 6 then
26806: LD_VAR 0 4
26810: PUSH
26811: LD_VAR 0 7
26815: PUSH
26816: LD_INT 6
26818: LESS
26819: AND
26820: IFFALSE 27008
// begin sort := SortBySkill ( tmp diff ( sci union mech ) , 3 ) ;
26822: LD_ADDR_VAR 0 9
26826: PUSH
26827: LD_VAR 0 4
26831: PUSH
26832: LD_VAR 0 8
26836: PUSH
26837: LD_VAR 0 7
26841: UNION
26842: DIFF
26843: PPUSH
26844: LD_INT 3
26846: PPUSH
26847: CALL 91895 0 2
26851: ST_TO_ADDR
// p := [ ] ;
26852: LD_ADDR_VAR 0 11
26856: PUSH
26857: EMPTY
26858: ST_TO_ADDR
// if sort then
26859: LD_VAR 0 9
26863: IFFALSE 26979
// for i = 1 to 6 - mech do
26865: LD_ADDR_VAR 0 3
26869: PUSH
26870: DOUBLE
26871: LD_INT 1
26873: DEC
26874: ST_TO_ADDR
26875: LD_INT 6
26877: PUSH
26878: LD_VAR 0 7
26882: MINUS
26883: PUSH
26884: FOR_TO
26885: IFFALSE 26977
// begin if i = sort then
26887: LD_VAR 0 3
26891: PUSH
26892: LD_VAR 0 9
26896: EQUAL
26897: IFFALSE 26901
// break ;
26899: GO 26977
// if GetClass ( i ) = 3 then
26901: LD_VAR 0 3
26905: PPUSH
26906: CALL_OW 257
26910: PUSH
26911: LD_INT 3
26913: EQUAL
26914: IFFALSE 26918
// continue ;
26916: GO 26884
// p := Insert ( p , p + 1 , sort [ i ] ) ;
26918: LD_ADDR_VAR 0 11
26922: PUSH
26923: LD_VAR 0 11
26927: PPUSH
26928: LD_VAR 0 11
26932: PUSH
26933: LD_INT 1
26935: PLUS
26936: PPUSH
26937: LD_VAR 0 9
26941: PUSH
26942: LD_VAR 0 3
26946: ARRAY
26947: PPUSH
26948: CALL_OW 2
26952: ST_TO_ADDR
// tmp := tmp diff sort [ i ] ;
26953: LD_ADDR_VAR 0 4
26957: PUSH
26958: LD_VAR 0 4
26962: PUSH
26963: LD_VAR 0 9
26967: PUSH
26968: LD_VAR 0 3
26972: ARRAY
26973: DIFF
26974: ST_TO_ADDR
// end ;
26975: GO 26884
26977: POP
26978: POP
// if p then
26979: LD_VAR 0 11
26983: IFFALSE 27008
// result := Replace ( result , 3 , p ) ;
26985: LD_ADDR_VAR 0 2
26989: PUSH
26990: LD_VAR 0 2
26994: PPUSH
26995: LD_INT 3
26997: PPUSH
26998: LD_VAR 0 11
27002: PPUSH
27003: CALL_OW 1
27007: ST_TO_ADDR
// end ; if tmp > 6 and eng < 6 then
27008: LD_VAR 0 4
27012: PUSH
27013: LD_INT 6
27015: GREATER
27016: PUSH
27017: LD_VAR 0 6
27021: PUSH
27022: LD_INT 6
27024: LESS
27025: AND
27026: IFFALSE 27220
// begin sort := SortBySkill ( tmp diff ( sci union mech union eng ) , 2 ) ;
27028: LD_ADDR_VAR 0 9
27032: PUSH
27033: LD_VAR 0 4
27037: PUSH
27038: LD_VAR 0 8
27042: PUSH
27043: LD_VAR 0 7
27047: UNION
27048: PUSH
27049: LD_VAR 0 6
27053: UNION
27054: DIFF
27055: PPUSH
27056: LD_INT 2
27058: PPUSH
27059: CALL 91895 0 2
27063: ST_TO_ADDR
// p := [ ] ;
27064: LD_ADDR_VAR 0 11
27068: PUSH
27069: EMPTY
27070: ST_TO_ADDR
// if sort then
27071: LD_VAR 0 9
27075: IFFALSE 27191
// for i = 1 to 6 - eng do
27077: LD_ADDR_VAR 0 3
27081: PUSH
27082: DOUBLE
27083: LD_INT 1
27085: DEC
27086: ST_TO_ADDR
27087: LD_INT 6
27089: PUSH
27090: LD_VAR 0 6
27094: MINUS
27095: PUSH
27096: FOR_TO
27097: IFFALSE 27189
// begin if i = sort then
27099: LD_VAR 0 3
27103: PUSH
27104: LD_VAR 0 9
27108: EQUAL
27109: IFFALSE 27113
// break ;
27111: GO 27189
// if GetClass ( i ) = 2 then
27113: LD_VAR 0 3
27117: PPUSH
27118: CALL_OW 257
27122: PUSH
27123: LD_INT 2
27125: EQUAL
27126: IFFALSE 27130
// continue ;
27128: GO 27096
// p := Insert ( p , p + 1 , sort [ i ] ) ;
27130: LD_ADDR_VAR 0 11
27134: PUSH
27135: LD_VAR 0 11
27139: PPUSH
27140: LD_VAR 0 11
27144: PUSH
27145: LD_INT 1
27147: PLUS
27148: PPUSH
27149: LD_VAR 0 9
27153: PUSH
27154: LD_VAR 0 3
27158: ARRAY
27159: PPUSH
27160: CALL_OW 2
27164: ST_TO_ADDR
// tmp := tmp diff sort [ i ] ;
27165: LD_ADDR_VAR 0 4
27169: PUSH
27170: LD_VAR 0 4
27174: PUSH
27175: LD_VAR 0 9
27179: PUSH
27180: LD_VAR 0 3
27184: ARRAY
27185: DIFF
27186: ST_TO_ADDR
// end ;
27187: GO 27096
27189: POP
27190: POP
// if p then
27191: LD_VAR 0 11
27195: IFFALSE 27220
// result := Replace ( result , 2 , p ) ;
27197: LD_ADDR_VAR 0 2
27201: PUSH
27202: LD_VAR 0 2
27206: PPUSH
27207: LD_INT 2
27209: PPUSH
27210: LD_VAR 0 11
27214: PPUSH
27215: CALL_OW 1
27219: ST_TO_ADDR
// end ; exit ;
27220: GO 28608
// end ; if not mc_tech [ mc_sides [ base ] ] and UnitFilter ( mc_bases [ base ] , [ f_btype , b_factory ] ) and mc_build_list [ base ] then
27222: LD_EXP 103
27226: PUSH
27227: LD_EXP 102
27231: PUSH
27232: LD_VAR 0 1
27236: ARRAY
27237: ARRAY
27238: NOT
27239: PUSH
27240: LD_EXP 76
27244: PUSH
27245: LD_VAR 0 1
27249: ARRAY
27250: PPUSH
27251: LD_INT 30
27253: PUSH
27254: LD_INT 3
27256: PUSH
27257: EMPTY
27258: LIST
27259: LIST
27260: PPUSH
27261: CALL_OW 72
27265: AND
27266: PUSH
27267: LD_EXP 81
27271: PUSH
27272: LD_VAR 0 1
27276: ARRAY
27277: AND
27278: IFFALSE 27886
// begin mc_class_case_use := Replace ( mc_class_case_use , base , 5 ) ;
27280: LD_ADDR_EXP 118
27284: PUSH
27285: LD_EXP 118
27289: PPUSH
27290: LD_VAR 0 1
27294: PPUSH
27295: LD_INT 5
27297: PPUSH
27298: CALL_OW 1
27302: ST_TO_ADDR
// result := [ 0 , 0 , 0 , 0 ] ;
27303: LD_ADDR_VAR 0 2
27307: PUSH
27308: LD_INT 0
27310: PUSH
27311: LD_INT 0
27313: PUSH
27314: LD_INT 0
27316: PUSH
27317: LD_INT 0
27319: PUSH
27320: EMPTY
27321: LIST
27322: LIST
27323: LIST
27324: LIST
27325: ST_TO_ADDR
// if sci > 1 then
27326: LD_VAR 0 8
27330: PUSH
27331: LD_INT 1
27333: GREATER
27334: IFFALSE 27362
// tmp := tmp diff ( sci diff sci [ 1 ] ) ;
27336: LD_ADDR_VAR 0 4
27340: PUSH
27341: LD_VAR 0 4
27345: PUSH
27346: LD_VAR 0 8
27350: PUSH
27351: LD_VAR 0 8
27355: PUSH
27356: LD_INT 1
27358: ARRAY
27359: DIFF
27360: DIFF
27361: ST_TO_ADDR
// if tmp and not sci then
27362: LD_VAR 0 4
27366: PUSH
27367: LD_VAR 0 8
27371: NOT
27372: AND
27373: IFFALSE 27442
// begin sort := SortBySkill ( tmp , 4 ) ;
27375: LD_ADDR_VAR 0 9
27379: PUSH
27380: LD_VAR 0 4
27384: PPUSH
27385: LD_INT 4
27387: PPUSH
27388: CALL 91895 0 2
27392: ST_TO_ADDR
// if sort then
27393: LD_VAR 0 9
27397: IFFALSE 27413
// p := sort [ 1 ] ;
27399: LD_ADDR_VAR 0 11
27403: PUSH
27404: LD_VAR 0 9
27408: PUSH
27409: LD_INT 1
27411: ARRAY
27412: ST_TO_ADDR
// if p then
27413: LD_VAR 0 11
27417: IFFALSE 27442
// result := Replace ( result , 4 , p ) ;
27419: LD_ADDR_VAR 0 2
27423: PUSH
27424: LD_VAR 0 2
27428: PPUSH
27429: LD_INT 4
27431: PPUSH
27432: LD_VAR 0 11
27436: PPUSH
27437: CALL_OW 1
27441: ST_TO_ADDR
// end ; tmp := tmp diff mech ;
27442: LD_ADDR_VAR 0 4
27446: PUSH
27447: LD_VAR 0 4
27451: PUSH
27452: LD_VAR 0 7
27456: DIFF
27457: ST_TO_ADDR
// if tmp and mech < 6 then
27458: LD_VAR 0 4
27462: PUSH
27463: LD_VAR 0 7
27467: PUSH
27468: LD_INT 6
27470: LESS
27471: AND
27472: IFFALSE 27660
// begin sort := SortBySkill ( tmp diff ( sci union mech ) , 3 ) ;
27474: LD_ADDR_VAR 0 9
27478: PUSH
27479: LD_VAR 0 4
27483: PUSH
27484: LD_VAR 0 8
27488: PUSH
27489: LD_VAR 0 7
27493: UNION
27494: DIFF
27495: PPUSH
27496: LD_INT 3
27498: PPUSH
27499: CALL 91895 0 2
27503: ST_TO_ADDR
// p := [ ] ;
27504: LD_ADDR_VAR 0 11
27508: PUSH
27509: EMPTY
27510: ST_TO_ADDR
// if sort then
27511: LD_VAR 0 9
27515: IFFALSE 27631
// for i = 1 to 6 - mech do
27517: LD_ADDR_VAR 0 3
27521: PUSH
27522: DOUBLE
27523: LD_INT 1
27525: DEC
27526: ST_TO_ADDR
27527: LD_INT 6
27529: PUSH
27530: LD_VAR 0 7
27534: MINUS
27535: PUSH
27536: FOR_TO
27537: IFFALSE 27629
// begin if i = sort then
27539: LD_VAR 0 3
27543: PUSH
27544: LD_VAR 0 9
27548: EQUAL
27549: IFFALSE 27553
// break ;
27551: GO 27629
// if GetClass ( i ) = 3 then
27553: LD_VAR 0 3
27557: PPUSH
27558: CALL_OW 257
27562: PUSH
27563: LD_INT 3
27565: EQUAL
27566: IFFALSE 27570
// continue ;
27568: GO 27536
// p := Insert ( p , p + 1 , sort [ i ] ) ;
27570: LD_ADDR_VAR 0 11
27574: PUSH
27575: LD_VAR 0 11
27579: PPUSH
27580: LD_VAR 0 11
27584: PUSH
27585: LD_INT 1
27587: PLUS
27588: PPUSH
27589: LD_VAR 0 9
27593: PUSH
27594: LD_VAR 0 3
27598: ARRAY
27599: PPUSH
27600: CALL_OW 2
27604: ST_TO_ADDR
// tmp := tmp diff sort [ i ] ;
27605: LD_ADDR_VAR 0 4
27609: PUSH
27610: LD_VAR 0 4
27614: PUSH
27615: LD_VAR 0 9
27619: PUSH
27620: LD_VAR 0 3
27624: ARRAY
27625: DIFF
27626: ST_TO_ADDR
// end ;
27627: GO 27536
27629: POP
27630: POP
// if p then
27631: LD_VAR 0 11
27635: IFFALSE 27660
// result := Replace ( result , 3 , p ) ;
27637: LD_ADDR_VAR 0 2
27641: PUSH
27642: LD_VAR 0 2
27646: PPUSH
27647: LD_INT 3
27649: PPUSH
27650: LD_VAR 0 11
27654: PPUSH
27655: CALL_OW 1
27659: ST_TO_ADDR
// end ; tmp := tmp diff eng ;
27660: LD_ADDR_VAR 0 4
27664: PUSH
27665: LD_VAR 0 4
27669: PUSH
27670: LD_VAR 0 6
27674: DIFF
27675: ST_TO_ADDR
// if tmp and eng < 6 then
27676: LD_VAR 0 4
27680: PUSH
27681: LD_VAR 0 6
27685: PUSH
27686: LD_INT 6
27688: LESS
27689: AND
27690: IFFALSE 27884
// begin sort := SortBySkill ( tmp diff ( sci union mech union eng ) , 2 ) ;
27692: LD_ADDR_VAR 0 9
27696: PUSH
27697: LD_VAR 0 4
27701: PUSH
27702: LD_VAR 0 8
27706: PUSH
27707: LD_VAR 0 7
27711: UNION
27712: PUSH
27713: LD_VAR 0 6
27717: UNION
27718: DIFF
27719: PPUSH
27720: LD_INT 2
27722: PPUSH
27723: CALL 91895 0 2
27727: ST_TO_ADDR
// p := [ ] ;
27728: LD_ADDR_VAR 0 11
27732: PUSH
27733: EMPTY
27734: ST_TO_ADDR
// if sort then
27735: LD_VAR 0 9
27739: IFFALSE 27855
// for i = 1 to 6 - eng do
27741: LD_ADDR_VAR 0 3
27745: PUSH
27746: DOUBLE
27747: LD_INT 1
27749: DEC
27750: ST_TO_ADDR
27751: LD_INT 6
27753: PUSH
27754: LD_VAR 0 6
27758: MINUS
27759: PUSH
27760: FOR_TO
27761: IFFALSE 27853
// begin if i = sort then
27763: LD_VAR 0 3
27767: PUSH
27768: LD_VAR 0 9
27772: EQUAL
27773: IFFALSE 27777
// break ;
27775: GO 27853
// if GetClass ( i ) = 2 then
27777: LD_VAR 0 3
27781: PPUSH
27782: CALL_OW 257
27786: PUSH
27787: LD_INT 2
27789: EQUAL
27790: IFFALSE 27794
// continue ;
27792: GO 27760
// p := Insert ( p , p + 1 , sort [ i ] ) ;
27794: LD_ADDR_VAR 0 11
27798: PUSH
27799: LD_VAR 0 11
27803: PPUSH
27804: LD_VAR 0 11
27808: PUSH
27809: LD_INT 1
27811: PLUS
27812: PPUSH
27813: LD_VAR 0 9
27817: PUSH
27818: LD_VAR 0 3
27822: ARRAY
27823: PPUSH
27824: CALL_OW 2
27828: ST_TO_ADDR
// tmp := tmp diff sort [ i ] ;
27829: LD_ADDR_VAR 0 4
27833: PUSH
27834: LD_VAR 0 4
27838: PUSH
27839: LD_VAR 0 9
27843: PUSH
27844: LD_VAR 0 3
27848: ARRAY
27849: DIFF
27850: ST_TO_ADDR
// end ;
27851: GO 27760
27853: POP
27854: POP
// if p then
27855: LD_VAR 0 11
27859: IFFALSE 27884
// result := Replace ( result , 2 , p ) ;
27861: LD_ADDR_VAR 0 2
27865: PUSH
27866: LD_VAR 0 2
27870: PPUSH
27871: LD_INT 2
27873: PPUSH
27874: LD_VAR 0 11
27878: PPUSH
27879: CALL_OW 1
27883: ST_TO_ADDR
// end ; exit ;
27884: GO 28608
// end ; if not mc_tech [ mc_sides [ base ] ] and UnitFilter ( mc_bases [ base ] , [ f_btype , b_factory ] ) and not mc_build_list [ base ] then
27886: LD_EXP 103
27890: PUSH
27891: LD_EXP 102
27895: PUSH
27896: LD_VAR 0 1
27900: ARRAY
27901: ARRAY
27902: NOT
27903: PUSH
27904: LD_EXP 76
27908: PUSH
27909: LD_VAR 0 1
27913: ARRAY
27914: PPUSH
27915: LD_INT 30
27917: PUSH
27918: LD_INT 3
27920: PUSH
27921: EMPTY
27922: LIST
27923: LIST
27924: PPUSH
27925: CALL_OW 72
27929: AND
27930: PUSH
27931: LD_EXP 81
27935: PUSH
27936: LD_VAR 0 1
27940: ARRAY
27941: NOT
27942: AND
27943: IFFALSE 28608
// begin mc_class_case_use := Replace ( mc_class_case_use , base , 6 ) ;
27945: LD_ADDR_EXP 118
27949: PUSH
27950: LD_EXP 118
27954: PPUSH
27955: LD_VAR 0 1
27959: PPUSH
27960: LD_INT 6
27962: PPUSH
27963: CALL_OW 1
27967: ST_TO_ADDR
// result := [ 0 , 0 , 0 , 0 ] ;
27968: LD_ADDR_VAR 0 2
27972: PUSH
27973: LD_INT 0
27975: PUSH
27976: LD_INT 0
27978: PUSH
27979: LD_INT 0
27981: PUSH
27982: LD_INT 0
27984: PUSH
27985: EMPTY
27986: LIST
27987: LIST
27988: LIST
27989: LIST
27990: ST_TO_ADDR
// if sci >= 1 then
27991: LD_VAR 0 8
27995: PUSH
27996: LD_INT 1
27998: GREATEREQUAL
27999: IFFALSE 28021
// tmp := tmp diff sci [ 1 ] ;
28001: LD_ADDR_VAR 0 4
28005: PUSH
28006: LD_VAR 0 4
28010: PUSH
28011: LD_VAR 0 8
28015: PUSH
28016: LD_INT 1
28018: ARRAY
28019: DIFF
28020: ST_TO_ADDR
// if tmp and not sci then
28021: LD_VAR 0 4
28025: PUSH
28026: LD_VAR 0 8
28030: NOT
28031: AND
28032: IFFALSE 28101
// begin sort := SortBySkill ( tmp , 4 ) ;
28034: LD_ADDR_VAR 0 9
28038: PUSH
28039: LD_VAR 0 4
28043: PPUSH
28044: LD_INT 4
28046: PPUSH
28047: CALL 91895 0 2
28051: ST_TO_ADDR
// if sort then
28052: LD_VAR 0 9
28056: IFFALSE 28072
// p := sort [ 1 ] ;
28058: LD_ADDR_VAR 0 11
28062: PUSH
28063: LD_VAR 0 9
28067: PUSH
28068: LD_INT 1
28070: ARRAY
28071: ST_TO_ADDR
// if p then
28072: LD_VAR 0 11
28076: IFFALSE 28101
// result := Replace ( result , 4 , p ) ;
28078: LD_ADDR_VAR 0 2
28082: PUSH
28083: LD_VAR 0 2
28087: PPUSH
28088: LD_INT 4
28090: PPUSH
28091: LD_VAR 0 11
28095: PPUSH
28096: CALL_OW 1
28100: ST_TO_ADDR
// end ; tmp := tmp diff mech ;
28101: LD_ADDR_VAR 0 4
28105: PUSH
28106: LD_VAR 0 4
28110: PUSH
28111: LD_VAR 0 7
28115: DIFF
28116: ST_TO_ADDR
// if tmp and mech < 6 then
28117: LD_VAR 0 4
28121: PUSH
28122: LD_VAR 0 7
28126: PUSH
28127: LD_INT 6
28129: LESS
28130: AND
28131: IFFALSE 28313
// begin sort := SortBySkill ( tmp diff mech , 3 ) ;
28133: LD_ADDR_VAR 0 9
28137: PUSH
28138: LD_VAR 0 4
28142: PUSH
28143: LD_VAR 0 7
28147: DIFF
28148: PPUSH
28149: LD_INT 3
28151: PPUSH
28152: CALL 91895 0 2
28156: ST_TO_ADDR
// p := [ ] ;
28157: LD_ADDR_VAR 0 11
28161: PUSH
28162: EMPTY
28163: ST_TO_ADDR
// if sort then
28164: LD_VAR 0 9
28168: IFFALSE 28284
// for i = 1 to 6 - mech do
28170: LD_ADDR_VAR 0 3
28174: PUSH
28175: DOUBLE
28176: LD_INT 1
28178: DEC
28179: ST_TO_ADDR
28180: LD_INT 6
28182: PUSH
28183: LD_VAR 0 7
28187: MINUS
28188: PUSH
28189: FOR_TO
28190: IFFALSE 28282
// begin if i = sort then
28192: LD_VAR 0 3
28196: PUSH
28197: LD_VAR 0 9
28201: EQUAL
28202: IFFALSE 28206
// break ;
28204: GO 28282
// if GetClass ( i ) = 3 then
28206: LD_VAR 0 3
28210: PPUSH
28211: CALL_OW 257
28215: PUSH
28216: LD_INT 3
28218: EQUAL
28219: IFFALSE 28223
// continue ;
28221: GO 28189
// p := Insert ( p , p + 1 , sort [ i ] ) ;
28223: LD_ADDR_VAR 0 11
28227: PUSH
28228: LD_VAR 0 11
28232: PPUSH
28233: LD_VAR 0 11
28237: PUSH
28238: LD_INT 1
28240: PLUS
28241: PPUSH
28242: LD_VAR 0 9
28246: PUSH
28247: LD_VAR 0 3
28251: ARRAY
28252: PPUSH
28253: CALL_OW 2
28257: ST_TO_ADDR
// tmp := tmp diff sort [ i ] ;
28258: LD_ADDR_VAR 0 4
28262: PUSH
28263: LD_VAR 0 4
28267: PUSH
28268: LD_VAR 0 9
28272: PUSH
28273: LD_VAR 0 3
28277: ARRAY
28278: DIFF
28279: ST_TO_ADDR
// end ;
28280: GO 28189
28282: POP
28283: POP
// if p then
28284: LD_VAR 0 11
28288: IFFALSE 28313
// result := Replace ( result , 3 , p ) ;
28290: LD_ADDR_VAR 0 2
28294: PUSH
28295: LD_VAR 0 2
28299: PPUSH
28300: LD_INT 3
28302: PPUSH
28303: LD_VAR 0 11
28307: PPUSH
28308: CALL_OW 1
28312: ST_TO_ADDR
// end ; tmp := tmp diff eng ;
28313: LD_ADDR_VAR 0 4
28317: PUSH
28318: LD_VAR 0 4
28322: PUSH
28323: LD_VAR 0 6
28327: DIFF
28328: ST_TO_ADDR
// if tmp and eng < 4 then
28329: LD_VAR 0 4
28333: PUSH
28334: LD_VAR 0 6
28338: PUSH
28339: LD_INT 4
28341: LESS
28342: AND
28343: IFFALSE 28533
// begin sort := SortBySkill ( tmp diff ( mech union eng ) , 2 ) ;
28345: LD_ADDR_VAR 0 9
28349: PUSH
28350: LD_VAR 0 4
28354: PUSH
28355: LD_VAR 0 7
28359: PUSH
28360: LD_VAR 0 6
28364: UNION
28365: DIFF
28366: PPUSH
28367: LD_INT 2
28369: PPUSH
28370: CALL 91895 0 2
28374: ST_TO_ADDR
// p := [ ] ;
28375: LD_ADDR_VAR 0 11
28379: PUSH
28380: EMPTY
28381: ST_TO_ADDR
// if sort then
28382: LD_VAR 0 9
28386: IFFALSE 28502
// for i = 1 to 4 - eng do
28388: LD_ADDR_VAR 0 3
28392: PUSH
28393: DOUBLE
28394: LD_INT 1
28396: DEC
28397: ST_TO_ADDR
28398: LD_INT 4
28400: PUSH
28401: LD_VAR 0 6
28405: MINUS
28406: PUSH
28407: FOR_TO
28408: IFFALSE 28500
// begin if i = sort then
28410: LD_VAR 0 3
28414: PUSH
28415: LD_VAR 0 9
28419: EQUAL
28420: IFFALSE 28424
// break ;
28422: GO 28500
// if GetClass ( i ) = 2 then
28424: LD_VAR 0 3
28428: PPUSH
28429: CALL_OW 257
28433: PUSH
28434: LD_INT 2
28436: EQUAL
28437: IFFALSE 28441
// continue ;
28439: GO 28407
// p := Insert ( p , p + 1 , sort [ i ] ) ;
28441: LD_ADDR_VAR 0 11
28445: PUSH
28446: LD_VAR 0 11
28450: PPUSH
28451: LD_VAR 0 11
28455: PUSH
28456: LD_INT 1
28458: PLUS
28459: PPUSH
28460: LD_VAR 0 9
28464: PUSH
28465: LD_VAR 0 3
28469: ARRAY
28470: PPUSH
28471: CALL_OW 2
28475: ST_TO_ADDR
// tmp := tmp diff sort [ i ] ;
28476: LD_ADDR_VAR 0 4
28480: PUSH
28481: LD_VAR 0 4
28485: PUSH
28486: LD_VAR 0 9
28490: PUSH
28491: LD_VAR 0 3
28495: ARRAY
28496: DIFF
28497: ST_TO_ADDR
// end ;
28498: GO 28407
28500: POP
28501: POP
// if p then
28502: LD_VAR 0 11
28506: IFFALSE 28531
// result := Replace ( result , 2 , p ) ;
28508: LD_ADDR_VAR 0 2
28512: PUSH
28513: LD_VAR 0 2
28517: PPUSH
28518: LD_INT 2
28520: PPUSH
28521: LD_VAR 0 11
28525: PPUSH
28526: CALL_OW 1
28530: ST_TO_ADDR
// end else
28531: GO 28577
// for i = eng downto 5 do
28533: LD_ADDR_VAR 0 3
28537: PUSH
28538: DOUBLE
28539: LD_VAR 0 6
28543: INC
28544: ST_TO_ADDR
28545: LD_INT 5
28547: PUSH
28548: FOR_DOWNTO
28549: IFFALSE 28575
// tmp := tmp union eng [ i ] ;
28551: LD_ADDR_VAR 0 4
28555: PUSH
28556: LD_VAR 0 4
28560: PUSH
28561: LD_VAR 0 6
28565: PUSH
28566: LD_VAR 0 3
28570: ARRAY
28571: UNION
28572: ST_TO_ADDR
28573: GO 28548
28575: POP
28576: POP
// result := Replace ( result , 1 , tmp diff sol ) ;
28577: LD_ADDR_VAR 0 2
28581: PUSH
28582: LD_VAR 0 2
28586: PPUSH
28587: LD_INT 1
28589: PPUSH
28590: LD_VAR 0 4
28594: PUSH
28595: LD_VAR 0 5
28599: DIFF
28600: PPUSH
28601: CALL_OW 1
28605: ST_TO_ADDR
// exit ;
28606: GO 28608
// end ; end ;
28608: LD_VAR 0 2
28612: RET
// export function MC_CheckBuildings ( ) ; var i , tmp ; begin
28613: LD_INT 0
28615: PPUSH
28616: PPUSH
28617: PPUSH
// if not mc_bases then
28618: LD_EXP 76
28622: NOT
28623: IFFALSE 28627
// exit ;
28625: GO 28733
// for i = 1 to mc_bases do
28627: LD_ADDR_VAR 0 2
28631: PUSH
28632: DOUBLE
28633: LD_INT 1
28635: DEC
28636: ST_TO_ADDR
28637: LD_EXP 76
28641: PUSH
28642: FOR_TO
28643: IFFALSE 28724
// begin tmp := UnitFilter ( mc_bases [ i ] , [ [ f_type , unit_building ] , [ f_not , [ f_lives , 1000 ] ] ] ) ;
28645: LD_ADDR_VAR 0 3
28649: PUSH
28650: LD_EXP 76
28654: PUSH
28655: LD_VAR 0 2
28659: ARRAY
28660: PPUSH
28661: LD_INT 21
28663: PUSH
28664: LD_INT 3
28666: PUSH
28667: EMPTY
28668: LIST
28669: LIST
28670: PUSH
28671: LD_INT 3
28673: PUSH
28674: LD_INT 24
28676: PUSH
28677: LD_INT 1000
28679: PUSH
28680: EMPTY
28681: LIST
28682: LIST
28683: PUSH
28684: EMPTY
28685: LIST
28686: LIST
28687: PUSH
28688: EMPTY
28689: LIST
28690: LIST
28691: PPUSH
28692: CALL_OW 72
28696: ST_TO_ADDR
// mc_building_need_repair := Replace ( mc_building_need_repair , i , tmp ) ;
28697: LD_ADDR_EXP 77
28701: PUSH
28702: LD_EXP 77
28706: PPUSH
28707: LD_VAR 0 2
28711: PPUSH
28712: LD_VAR 0 3
28716: PPUSH
28717: CALL_OW 1
28721: ST_TO_ADDR
// end ;
28722: GO 28642
28724: POP
28725: POP
// RaiseSailEvent ( 101 ) ;
28726: LD_INT 101
28728: PPUSH
28729: CALL_OW 427
// end ;
28733: LD_VAR 0 1
28737: RET
// export function MC_CheckPeopleLife ( ) ; var i , j , k , tmp , need_heal_1 , need_heal_2 ; begin
28738: LD_INT 0
28740: PPUSH
28741: PPUSH
28742: PPUSH
28743: PPUSH
28744: PPUSH
28745: PPUSH
28746: PPUSH
// if not mc_bases then
28747: LD_EXP 76
28751: NOT
28752: IFFALSE 28756
// exit ;
28754: GO 29329
// for i = 1 to mc_bases do
28756: LD_ADDR_VAR 0 2
28760: PUSH
28761: DOUBLE
28762: LD_INT 1
28764: DEC
28765: ST_TO_ADDR
28766: LD_EXP 76
28770: PUSH
28771: FOR_TO
28772: IFFALSE 29320
// begin tmp := UnitFilter ( mc_bases [ i ] union mc_ape [ i ] , [ [ f_type , unit_human ] , [ f_and , [ f_not , [ f_inside ] ] , [ f_not , [ f_lives , 800 ] ] ] ] ) ;
28774: LD_ADDR_VAR 0 5
28778: PUSH
28779: LD_EXP 76
28783: PUSH
28784: LD_VAR 0 2
28788: ARRAY
28789: PUSH
28790: LD_EXP 105
28794: PUSH
28795: LD_VAR 0 2
28799: ARRAY
28800: UNION
28801: PPUSH
28802: LD_INT 21
28804: PUSH
28805: LD_INT 1
28807: PUSH
28808: EMPTY
28809: LIST
28810: LIST
28811: PUSH
28812: LD_INT 1
28814: PUSH
28815: LD_INT 3
28817: PUSH
28818: LD_INT 54
28820: PUSH
28821: EMPTY
28822: LIST
28823: PUSH
28824: EMPTY
28825: LIST
28826: LIST
28827: PUSH
28828: LD_INT 3
28830: PUSH
28831: LD_INT 24
28833: PUSH
28834: LD_INT 800
28836: PUSH
28837: EMPTY
28838: LIST
28839: LIST
28840: PUSH
28841: EMPTY
28842: LIST
28843: LIST
28844: PUSH
28845: EMPTY
28846: LIST
28847: LIST
28848: LIST
28849: PUSH
28850: EMPTY
28851: LIST
28852: LIST
28853: PPUSH
28854: CALL_OW 72
28858: ST_TO_ADDR
// need_heal_1 := UnitFilter ( mc_bases [ i ] , [ [ f_type , unit_human ] , [ f_and , [ f_not , [ f_inside ] ] , [ f_not , [ f_lives , 250 ] ] ] ] ) ;
28859: LD_ADDR_VAR 0 6
28863: PUSH
28864: LD_EXP 76
28868: PUSH
28869: LD_VAR 0 2
28873: ARRAY
28874: PPUSH
28875: LD_INT 21
28877: PUSH
28878: LD_INT 1
28880: PUSH
28881: EMPTY
28882: LIST
28883: LIST
28884: PUSH
28885: LD_INT 1
28887: PUSH
28888: LD_INT 3
28890: PUSH
28891: LD_INT 54
28893: PUSH
28894: EMPTY
28895: LIST
28896: PUSH
28897: EMPTY
28898: LIST
28899: LIST
28900: PUSH
28901: LD_INT 3
28903: PUSH
28904: LD_INT 24
28906: PUSH
28907: LD_INT 250
28909: PUSH
28910: EMPTY
28911: LIST
28912: LIST
28913: PUSH
28914: EMPTY
28915: LIST
28916: LIST
28917: PUSH
28918: EMPTY
28919: LIST
28920: LIST
28921: LIST
28922: PUSH
28923: EMPTY
28924: LIST
28925: LIST
28926: PPUSH
28927: CALL_OW 72
28931: ST_TO_ADDR
// need_heal_2 := tmp diff need_heal_1 ;
28932: LD_ADDR_VAR 0 7
28936: PUSH
28937: LD_VAR 0 5
28941: PUSH
28942: LD_VAR 0 6
28946: DIFF
28947: ST_TO_ADDR
// if not need_heal_1 then
28948: LD_VAR 0 6
28952: NOT
28953: IFFALSE 28986
// mc_need_heal := ReplaceIn ( mc_need_heal , [ i , 1 ] , [ ] ) else
28955: LD_ADDR_EXP 79
28959: PUSH
28960: LD_EXP 79
28964: PPUSH
28965: LD_VAR 0 2
28969: PUSH
28970: LD_INT 1
28972: PUSH
28973: EMPTY
28974: LIST
28975: LIST
28976: PPUSH
28977: EMPTY
28978: PPUSH
28979: CALL 57644 0 3
28983: ST_TO_ADDR
28984: GO 29056
// mc_need_heal := ReplaceIn ( mc_need_heal , [ i , 1 ] , UnitFilter ( mc_need_heal [ i ] [ 1 ] , [ f_not , [ f_lives , 1000 ] ] ) union need_heal_1 ) ;
28986: LD_ADDR_EXP 79
28990: PUSH
28991: LD_EXP 79
28995: PPUSH
28996: LD_VAR 0 2
29000: PUSH
29001: LD_INT 1
29003: PUSH
29004: EMPTY
29005: LIST
29006: LIST
29007: PPUSH
29008: LD_EXP 79
29012: PUSH
29013: LD_VAR 0 2
29017: ARRAY
29018: PUSH
29019: LD_INT 1
29021: ARRAY
29022: PPUSH
29023: LD_INT 3
29025: PUSH
29026: LD_INT 24
29028: PUSH
29029: LD_INT 1000
29031: PUSH
29032: EMPTY
29033: LIST
29034: LIST
29035: PUSH
29036: EMPTY
29037: LIST
29038: LIST
29039: PPUSH
29040: CALL_OW 72
29044: PUSH
29045: LD_VAR 0 6
29049: UNION
29050: PPUSH
29051: CALL 57644 0 3
29055: ST_TO_ADDR
// if not need_heal_2 then
29056: LD_VAR 0 7
29060: NOT
29061: IFFALSE 29094
// mc_need_heal := ReplaceIn ( mc_need_heal , [ i , 2 ] , [ ] ) else
29063: LD_ADDR_EXP 79
29067: PUSH
29068: LD_EXP 79
29072: PPUSH
29073: LD_VAR 0 2
29077: PUSH
29078: LD_INT 2
29080: PUSH
29081: EMPTY
29082: LIST
29083: LIST
29084: PPUSH
29085: EMPTY
29086: PPUSH
29087: CALL 57644 0 3
29091: ST_TO_ADDR
29092: GO 29126
// mc_need_heal := ReplaceIn ( mc_need_heal , [ i , 2 ] , need_heal_2 ) ;
29094: LD_ADDR_EXP 79
29098: PUSH
29099: LD_EXP 79
29103: PPUSH
29104: LD_VAR 0 2
29108: PUSH
29109: LD_INT 2
29111: PUSH
29112: EMPTY
29113: LIST
29114: LIST
29115: PPUSH
29116: LD_VAR 0 7
29120: PPUSH
29121: CALL 57644 0 3
29125: ST_TO_ADDR
// if need_heal_2 then
29126: LD_VAR 0 7
29130: IFFALSE 29302
// for j in need_heal_2 do
29132: LD_ADDR_VAR 0 3
29136: PUSH
29137: LD_VAR 0 7
29141: PUSH
29142: FOR_IN
29143: IFFALSE 29300
// begin tmp := UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_lab ] , [ f_btype , b_lab_half ] , [ f_btype , b_lab_full ] , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] , [ f_class , 4 ] ] ) ;
29145: LD_ADDR_VAR 0 5
29149: PUSH
29150: LD_EXP 76
29154: PUSH
29155: LD_VAR 0 2
29159: ARRAY
29160: PPUSH
29161: LD_INT 2
29163: PUSH
29164: LD_INT 30
29166: PUSH
29167: LD_INT 6
29169: PUSH
29170: EMPTY
29171: LIST
29172: LIST
29173: PUSH
29174: LD_INT 30
29176: PUSH
29177: LD_INT 7
29179: PUSH
29180: EMPTY
29181: LIST
29182: LIST
29183: PUSH
29184: LD_INT 30
29186: PUSH
29187: LD_INT 8
29189: PUSH
29190: EMPTY
29191: LIST
29192: LIST
29193: PUSH
29194: LD_INT 30
29196: PUSH
29197: LD_INT 0
29199: PUSH
29200: EMPTY
29201: LIST
29202: LIST
29203: PUSH
29204: LD_INT 30
29206: PUSH
29207: LD_INT 1
29209: PUSH
29210: EMPTY
29211: LIST
29212: LIST
29213: PUSH
29214: LD_INT 25
29216: PUSH
29217: LD_INT 4
29219: PUSH
29220: EMPTY
29221: LIST
29222: LIST
29223: PUSH
29224: EMPTY
29225: LIST
29226: LIST
29227: LIST
29228: LIST
29229: LIST
29230: LIST
29231: LIST
29232: PPUSH
29233: CALL_OW 72
29237: ST_TO_ADDR
// if tmp then
29238: LD_VAR 0 5
29242: IFFALSE 29298
// begin k := NearestUnitToUnit ( tmp , j ) ;
29244: LD_ADDR_VAR 0 4
29248: PUSH
29249: LD_VAR 0 5
29253: PPUSH
29254: LD_VAR 0 3
29258: PPUSH
29259: CALL_OW 74
29263: ST_TO_ADDR
// if GetDistUnits ( j , k ) > 7 then
29264: LD_VAR 0 3
29268: PPUSH
29269: LD_VAR 0 4
29273: PPUSH
29274: CALL_OW 296
29278: PUSH
29279: LD_INT 7
29281: GREATER
29282: IFFALSE 29298
// ComMoveUnit ( j , k ) ;
29284: LD_VAR 0 3
29288: PPUSH
29289: LD_VAR 0 4
29293: PPUSH
29294: CALL_OW 112
// end ; end ;
29298: GO 29142
29300: POP
29301: POP
// if not need_heal_1 and not need_heal_2 then
29302: LD_VAR 0 6
29306: NOT
29307: PUSH
29308: LD_VAR 0 7
29312: NOT
29313: AND
29314: IFFALSE 29318
// continue ;
29316: GO 28771
// end ;
29318: GO 28771
29320: POP
29321: POP
// RaiseSailEvent ( 102 ) ;
29322: LD_INT 102
29324: PPUSH
29325: CALL_OW 427
// end ;
29329: LD_VAR 0 1
29333: RET
// export function MC_RepairBuildings ( ) ; var i , j , un , tmp , cranes , to_repair_tmp , to_repair ; begin
29334: LD_INT 0
29336: PPUSH
29337: PPUSH
29338: PPUSH
29339: PPUSH
29340: PPUSH
29341: PPUSH
29342: PPUSH
29343: PPUSH
// if not mc_bases then
29344: LD_EXP 76
29348: NOT
29349: IFFALSE 29353
// exit ;
29351: GO 30193
// for i = 1 to mc_bases do
29353: LD_ADDR_VAR 0 2
29357: PUSH
29358: DOUBLE
29359: LD_INT 1
29361: DEC
29362: ST_TO_ADDR
29363: LD_EXP 76
29367: PUSH
29368: FOR_TO
29369: IFFALSE 30191
// begin if not mc_building_need_repair [ i ] then
29371: LD_EXP 77
29375: PUSH
29376: LD_VAR 0 2
29380: ARRAY
29381: NOT
29382: IFFALSE 29556
// begin cranes := UnitFilter ( mc_vehicles [ i ] , [ [ f_not , [ f_lives , 1000 ] ] , [ f_or , [ f_weapon , us_crane ] , [ f_weapon , ru_crane ] ] ] ) ;
29384: LD_ADDR_VAR 0 6
29388: PUSH
29389: LD_EXP 95
29393: PUSH
29394: LD_VAR 0 2
29398: ARRAY
29399: PPUSH
29400: LD_INT 3
29402: PUSH
29403: LD_INT 24
29405: PUSH
29406: LD_INT 1000
29408: PUSH
29409: EMPTY
29410: LIST
29411: LIST
29412: PUSH
29413: EMPTY
29414: LIST
29415: LIST
29416: PUSH
29417: LD_INT 2
29419: PUSH
29420: LD_INT 34
29422: PUSH
29423: LD_INT 13
29425: PUSH
29426: EMPTY
29427: LIST
29428: LIST
29429: PUSH
29430: LD_INT 34
29432: PUSH
29433: LD_INT 52
29435: PUSH
29436: EMPTY
29437: LIST
29438: LIST
29439: PUSH
29440: EMPTY
29441: LIST
29442: LIST
29443: LIST
29444: PUSH
29445: EMPTY
29446: LIST
29447: LIST
29448: PPUSH
29449: CALL_OW 72
29453: ST_TO_ADDR
// if cranes then
29454: LD_VAR 0 6
29458: IFFALSE 29520
// for j in cranes do
29460: LD_ADDR_VAR 0 3
29464: PUSH
29465: LD_VAR 0 6
29469: PUSH
29470: FOR_IN
29471: IFFALSE 29518
// if not IsInArea ( j , mc_parking [ i ] ) then
29473: LD_VAR 0 3
29477: PPUSH
29478: LD_EXP 100
29482: PUSH
29483: LD_VAR 0 2
29487: ARRAY
29488: PPUSH
29489: CALL_OW 308
29493: NOT
29494: IFFALSE 29516
// ComMoveToArea ( j , mc_parking [ i ] ) ;
29496: LD_VAR 0 3
29500: PPUSH
29501: LD_EXP 100
29505: PUSH
29506: LD_VAR 0 2
29510: ARRAY
29511: PPUSH
29512: CALL_OW 113
29516: GO 29470
29518: POP
29519: POP
// mc_building_repairs := Replace ( mc_building_repairs , i , [ ] ) ;
29520: LD_ADDR_EXP 78
29524: PUSH
29525: LD_EXP 78
29529: PPUSH
29530: LD_VAR 0 2
29534: PPUSH
29535: EMPTY
29536: PPUSH
29537: CALL_OW 1
29541: ST_TO_ADDR
// MC_Reset ( i , 101 ) ;
29542: LD_VAR 0 2
29546: PPUSH
29547: LD_INT 101
29549: PPUSH
29550: CALL 24446 0 2
// continue ;
29554: GO 29368
// end ; mc_builders := Replace ( mc_builders , i , [ ] ) ;
29556: LD_ADDR_EXP 82
29560: PUSH
29561: LD_EXP 82
29565: PPUSH
29566: LD_VAR 0 2
29570: PPUSH
29571: EMPTY
29572: PPUSH
29573: CALL_OW 1
29577: ST_TO_ADDR
// MC_Reset ( i , 103 ) ;
29578: LD_VAR 0 2
29582: PPUSH
29583: LD_INT 103
29585: PPUSH
29586: CALL 24446 0 2
// tmp := UnitFilter ( mc_bases [ i ] union mc_ape [ i ] , [ [ f_or , [ f_class , 2 ] , [ f_class , 16 ] ] ] ) ;
29590: LD_ADDR_VAR 0 5
29594: PUSH
29595: LD_EXP 76
29599: PUSH
29600: LD_VAR 0 2
29604: ARRAY
29605: PUSH
29606: LD_EXP 105
29610: PUSH
29611: LD_VAR 0 2
29615: ARRAY
29616: UNION
29617: PPUSH
29618: LD_INT 2
29620: PUSH
29621: LD_INT 25
29623: PUSH
29624: LD_INT 2
29626: PUSH
29627: EMPTY
29628: LIST
29629: LIST
29630: PUSH
29631: LD_INT 25
29633: PUSH
29634: LD_INT 16
29636: PUSH
29637: EMPTY
29638: LIST
29639: LIST
29640: PUSH
29641: EMPTY
29642: LIST
29643: LIST
29644: LIST
29645: PUSH
29646: EMPTY
29647: LIST
29648: PPUSH
29649: CALL_OW 72
29653: ST_TO_ADDR
// cranes := UnitFilter ( mc_vehicles [ i ] , [ f_or , [ f_weapon , us_crane ] , [ f_weapon , ru_crane ] ] ) ;
29654: LD_ADDR_VAR 0 6
29658: PUSH
29659: LD_EXP 95
29663: PUSH
29664: LD_VAR 0 2
29668: ARRAY
29669: PPUSH
29670: LD_INT 2
29672: PUSH
29673: LD_INT 34
29675: PUSH
29676: LD_INT 13
29678: PUSH
29679: EMPTY
29680: LIST
29681: LIST
29682: PUSH
29683: LD_INT 34
29685: PUSH
29686: LD_INT 52
29688: PUSH
29689: EMPTY
29690: LIST
29691: LIST
29692: PUSH
29693: EMPTY
29694: LIST
29695: LIST
29696: LIST
29697: PPUSH
29698: CALL_OW 72
29702: ST_TO_ADDR
// if cranes then
29703: LD_VAR 0 6
29707: IFFALSE 29843
// begin for j in cranes do
29709: LD_ADDR_VAR 0 3
29713: PUSH
29714: LD_VAR 0 6
29718: PUSH
29719: FOR_IN
29720: IFFALSE 29841
// if GetLives ( j ) >= 500 and not HasTask ( j ) then
29722: LD_VAR 0 3
29726: PPUSH
29727: CALL_OW 256
29731: PUSH
29732: LD_INT 500
29734: GREATEREQUAL
29735: PUSH
29736: LD_VAR 0 3
29740: PPUSH
29741: CALL_OW 314
29745: NOT
29746: AND
29747: IFFALSE 29781
// ComRepairBuilding ( j , NearestUnitToUnit ( mc_building_need_repair [ i ] , j ) ) else
29749: LD_VAR 0 3
29753: PPUSH
29754: LD_EXP 77
29758: PUSH
29759: LD_VAR 0 2
29763: ARRAY
29764: PPUSH
29765: LD_VAR 0 3
29769: PPUSH
29770: CALL_OW 74
29774: PPUSH
29775: CALL_OW 130
29779: GO 29839
// if GetLives ( j ) < 500 and not IsInArea ( j , mc_parking [ i ] ) then
29781: LD_VAR 0 3
29785: PPUSH
29786: CALL_OW 256
29790: PUSH
29791: LD_INT 500
29793: LESS
29794: PUSH
29795: LD_VAR 0 3
29799: PPUSH
29800: LD_EXP 100
29804: PUSH
29805: LD_VAR 0 2
29809: ARRAY
29810: PPUSH
29811: CALL_OW 308
29815: NOT
29816: AND
29817: IFFALSE 29839
// ComMoveToArea ( j , mc_parking [ i ] ) ;
29819: LD_VAR 0 3
29823: PPUSH
29824: LD_EXP 100
29828: PUSH
29829: LD_VAR 0 2
29833: ARRAY
29834: PPUSH
29835: CALL_OW 113
29839: GO 29719
29841: POP
29842: POP
// end ; if not tmp then
29843: LD_VAR 0 5
29847: NOT
29848: IFFALSE 29852
// continue ;
29850: GO 29368
// for j in tmp do
29852: LD_ADDR_VAR 0 3
29856: PUSH
29857: LD_VAR 0 5
29861: PUSH
29862: FOR_IN
29863: IFFALSE 30187
// begin if mc_need_heal [ i ] then
29865: LD_EXP 79
29869: PUSH
29870: LD_VAR 0 2
29874: ARRAY
29875: IFFALSE 29923
// if j in mc_need_heal [ i ] [ 1 ] or j in mc_need_heal [ i ] [ 2 ] then
29877: LD_VAR 0 3
29881: PUSH
29882: LD_EXP 79
29886: PUSH
29887: LD_VAR 0 2
29891: ARRAY
29892: PUSH
29893: LD_INT 1
29895: ARRAY
29896: IN
29897: PUSH
29898: LD_VAR 0 3
29902: PUSH
29903: LD_EXP 79
29907: PUSH
29908: LD_VAR 0 2
29912: ARRAY
29913: PUSH
29914: LD_INT 2
29916: ARRAY
29917: IN
29918: OR
29919: IFFALSE 29923
// continue ;
29921: GO 29862
// if IsInUnit ( j ) then
29923: LD_VAR 0 3
29927: PPUSH
29928: CALL_OW 310
29932: IFFALSE 29943
// ComExitBuilding ( j ) ;
29934: LD_VAR 0 3
29938: PPUSH
29939: CALL_OW 122
// if not j in mc_building_repairs [ i ] then
29943: LD_VAR 0 3
29947: PUSH
29948: LD_EXP 78
29952: PUSH
29953: LD_VAR 0 2
29957: ARRAY
29958: IN
29959: NOT
29960: IFFALSE 30018
// begin SetTag ( j , 101 ) ;
29962: LD_VAR 0 3
29966: PPUSH
29967: LD_INT 101
29969: PPUSH
29970: CALL_OW 109
// mc_building_repairs := ReplaceIn ( mc_building_repairs , [ i , mc_building_repairs [ i ] + 1 ] , j ) ;
29974: LD_ADDR_EXP 78
29978: PUSH
29979: LD_EXP 78
29983: PPUSH
29984: LD_VAR 0 2
29988: PUSH
29989: LD_EXP 78
29993: PUSH
29994: LD_VAR 0 2
29998: ARRAY
29999: PUSH
30000: LD_INT 1
30002: PLUS
30003: PUSH
30004: EMPTY
30005: LIST
30006: LIST
30007: PPUSH
30008: LD_VAR 0 3
30012: PPUSH
30013: CALL 57644 0 3
30017: ST_TO_ADDR
// end ; wait ( 1 ) ;
30018: LD_INT 1
30020: PPUSH
30021: CALL_OW 67
// to_repair_tmp := mc_building_need_repair [ i ] ;
30025: LD_ADDR_VAR 0 7
30029: PUSH
30030: LD_EXP 77
30034: PUSH
30035: LD_VAR 0 2
30039: ARRAY
30040: ST_TO_ADDR
// if mc_scan [ i ] then
30041: LD_EXP 99
30045: PUSH
30046: LD_VAR 0 2
30050: ARRAY
30051: IFFALSE 30120
// to_repair_tmp := UnitFilter ( mc_building_need_repair [ i ] , [ f_not , [ f_or , [ f_btype , b_bunker ] , [ f_btype , b_turret ] , [ f_btype , b_breastwork ] ] ] ) ;
30053: LD_ADDR_VAR 0 7
30057: PUSH
30058: LD_EXP 77
30062: PUSH
30063: LD_VAR 0 2
30067: ARRAY
30068: PPUSH
30069: LD_INT 3
30071: PUSH
30072: LD_INT 2
30074: PUSH
30075: LD_INT 30
30077: PUSH
30078: LD_INT 32
30080: PUSH
30081: EMPTY
30082: LIST
30083: LIST
30084: PUSH
30085: LD_INT 30
30087: PUSH
30088: LD_INT 33
30090: PUSH
30091: EMPTY
30092: LIST
30093: LIST
30094: PUSH
30095: LD_INT 30
30097: PUSH
30098: LD_INT 31
30100: PUSH
30101: EMPTY
30102: LIST
30103: LIST
30104: PUSH
30105: EMPTY
30106: LIST
30107: LIST
30108: LIST
30109: LIST
30110: PUSH
30111: EMPTY
30112: LIST
30113: LIST
30114: PPUSH
30115: CALL_OW 72
30119: ST_TO_ADDR
// if not to_repair_tmp then
30120: LD_VAR 0 7
30124: NOT
30125: IFFALSE 30129
// continue ;
30127: GO 29862
// to_repair := NearestUnitToUnit ( to_repair_tmp , j ) ;
30129: LD_ADDR_VAR 0 8
30133: PUSH
30134: LD_VAR 0 7
30138: PPUSH
30139: LD_VAR 0 3
30143: PPUSH
30144: CALL_OW 74
30148: ST_TO_ADDR
// if DangerAtRange ( to_repair , 14 ) [ 4 ] < 5 then
30149: LD_VAR 0 8
30153: PPUSH
30154: LD_INT 14
30156: PPUSH
30157: CALL 60237 0 2
30161: PUSH
30162: LD_INT 4
30164: ARRAY
30165: PUSH
30166: LD_INT 5
30168: LESS
30169: IFFALSE 30185
// ComRepairBuilding ( j , to_repair ) ;
30171: LD_VAR 0 3
30175: PPUSH
30176: LD_VAR 0 8
30180: PPUSH
30181: CALL_OW 130
// end ;
30185: GO 29862
30187: POP
30188: POP
// end ;
30189: GO 29368
30191: POP
30192: POP
// end ;
30193: LD_VAR 0 1
30197: RET
// export function MC_Heal ; var i , j , tmp ; begin
30198: LD_INT 0
30200: PPUSH
30201: PPUSH
30202: PPUSH
30203: PPUSH
// if not mc_bases then
30204: LD_EXP 76
30208: NOT
30209: IFFALSE 30213
// exit ;
30211: GO 30615
// for i = 1 to mc_bases do
30213: LD_ADDR_VAR 0 2
30217: PUSH
30218: DOUBLE
30219: LD_INT 1
30221: DEC
30222: ST_TO_ADDR
30223: LD_EXP 76
30227: PUSH
30228: FOR_TO
30229: IFFALSE 30613
// begin if not mc_need_heal [ i ] [ 1 ] and not mc_need_heal [ i ] [ 2 ] then
30231: LD_EXP 79
30235: PUSH
30236: LD_VAR 0 2
30240: ARRAY
30241: PUSH
30242: LD_INT 1
30244: ARRAY
30245: NOT
30246: PUSH
30247: LD_EXP 79
30251: PUSH
30252: LD_VAR 0 2
30256: ARRAY
30257: PUSH
30258: LD_INT 2
30260: ARRAY
30261: NOT
30262: AND
30263: IFFALSE 30301
// begin mc_healers := Replace ( mc_healers , i , [ ] ) ;
30265: LD_ADDR_EXP 80
30269: PUSH
30270: LD_EXP 80
30274: PPUSH
30275: LD_VAR 0 2
30279: PPUSH
30280: EMPTY
30281: PPUSH
30282: CALL_OW 1
30286: ST_TO_ADDR
// MC_Reset ( i , 102 ) ;
30287: LD_VAR 0 2
30291: PPUSH
30292: LD_INT 102
30294: PPUSH
30295: CALL 24446 0 2
// continue ;
30299: GO 30228
// end ; tmp := UnitFilter ( mc_bases [ i ] , [ f_class , 4 ] ) ;
30301: LD_ADDR_VAR 0 4
30305: PUSH
30306: LD_EXP 76
30310: PUSH
30311: LD_VAR 0 2
30315: ARRAY
30316: PPUSH
30317: LD_INT 25
30319: PUSH
30320: LD_INT 4
30322: PUSH
30323: EMPTY
30324: LIST
30325: LIST
30326: PPUSH
30327: CALL_OW 72
30331: ST_TO_ADDR
// if not tmp then
30332: LD_VAR 0 4
30336: NOT
30337: IFFALSE 30341
// continue ;
30339: GO 30228
// if mc_taming [ i ] then
30341: LD_EXP 107
30345: PUSH
30346: LD_VAR 0 2
30350: ARRAY
30351: IFFALSE 30375
// mc_taming := Replace ( mc_taming , i , [ ] ) ;
30353: LD_ADDR_EXP 107
30357: PUSH
30358: LD_EXP 107
30362: PPUSH
30363: LD_VAR 0 2
30367: PPUSH
30368: EMPTY
30369: PPUSH
30370: CALL_OW 1
30374: ST_TO_ADDR
// for j in tmp do
30375: LD_ADDR_VAR 0 3
30379: PUSH
30380: LD_VAR 0 4
30384: PUSH
30385: FOR_IN
30386: IFFALSE 30609
// begin if IsInUnit ( j ) then
30388: LD_VAR 0 3
30392: PPUSH
30393: CALL_OW 310
30397: IFFALSE 30408
// ComExitBuilding ( j ) ;
30399: LD_VAR 0 3
30403: PPUSH
30404: CALL_OW 122
// if not j in mc_healers [ i ] then
30408: LD_VAR 0 3
30412: PUSH
30413: LD_EXP 80
30417: PUSH
30418: LD_VAR 0 2
30422: ARRAY
30423: IN
30424: NOT
30425: IFFALSE 30471
// mc_healers := ReplaceIn ( mc_healers , [ i , mc_healers [ i ] + 1 ] , j ) ;
30427: LD_ADDR_EXP 80
30431: PUSH
30432: LD_EXP 80
30436: PPUSH
30437: LD_VAR 0 2
30441: PUSH
30442: LD_EXP 80
30446: PUSH
30447: LD_VAR 0 2
30451: ARRAY
30452: PUSH
30453: LD_INT 1
30455: PLUS
30456: PUSH
30457: EMPTY
30458: LIST
30459: LIST
30460: PPUSH
30461: LD_VAR 0 3
30465: PPUSH
30466: CALL 57644 0 3
30470: ST_TO_ADDR
// if GetTag ( j ) <> 102 then
30471: LD_VAR 0 3
30475: PPUSH
30476: CALL_OW 110
30480: PUSH
30481: LD_INT 102
30483: NONEQUAL
30484: IFFALSE 30498
// SetTag ( j , 102 ) ;
30486: LD_VAR 0 3
30490: PPUSH
30491: LD_INT 102
30493: PPUSH
30494: CALL_OW 109
// Wait ( 3 ) ;
30498: LD_INT 3
30500: PPUSH
30501: CALL_OW 67
// if mc_need_heal [ i ] [ 1 ] then
30505: LD_EXP 79
30509: PUSH
30510: LD_VAR 0 2
30514: ARRAY
30515: PUSH
30516: LD_INT 1
30518: ARRAY
30519: IFFALSE 30551
// ComHeal ( j , mc_need_heal [ i ] [ 1 ] [ 1 ] ) else
30521: LD_VAR 0 3
30525: PPUSH
30526: LD_EXP 79
30530: PUSH
30531: LD_VAR 0 2
30535: ARRAY
30536: PUSH
30537: LD_INT 1
30539: ARRAY
30540: PUSH
30541: LD_INT 1
30543: ARRAY
30544: PPUSH
30545: CALL_OW 128
30549: GO 30607
// if not HasTask ( j ) and mc_need_heal [ i ] [ 2 ] then
30551: LD_VAR 0 3
30555: PPUSH
30556: CALL_OW 314
30560: NOT
30561: PUSH
30562: LD_EXP 79
30566: PUSH
30567: LD_VAR 0 2
30571: ARRAY
30572: PUSH
30573: LD_INT 2
30575: ARRAY
30576: AND
30577: IFFALSE 30607
// ComHeal ( j , mc_need_heal [ i ] [ 2 ] [ 1 ] ) ;
30579: LD_VAR 0 3
30583: PPUSH
30584: LD_EXP 79
30588: PUSH
30589: LD_VAR 0 2
30593: ARRAY
30594: PUSH
30595: LD_INT 2
30597: ARRAY
30598: PUSH
30599: LD_INT 1
30601: ARRAY
30602: PPUSH
30603: CALL_OW 128
// end ;
30607: GO 30385
30609: POP
30610: POP
// end ;
30611: GO 30228
30613: POP
30614: POP
// end ;
30615: LD_VAR 0 1
30619: RET
// export function MC_Build ( ) ; var i , j , tmp , depot ; begin
30620: LD_INT 0
30622: PPUSH
30623: PPUSH
30624: PPUSH
30625: PPUSH
30626: PPUSH
// if not mc_bases then
30627: LD_EXP 76
30631: NOT
30632: IFFALSE 30636
// exit ;
30634: GO 31779
// for i = 1 to mc_bases do
30636: LD_ADDR_VAR 0 2
30640: PUSH
30641: DOUBLE
30642: LD_INT 1
30644: DEC
30645: ST_TO_ADDR
30646: LD_EXP 76
30650: PUSH
30651: FOR_TO
30652: IFFALSE 31777
// begin if mc_scan [ i ] then
30654: LD_EXP 99
30658: PUSH
30659: LD_VAR 0 2
30663: ARRAY
30664: IFFALSE 30668
// continue ;
30666: GO 30651
// if not mc_build_list [ i ] and not mc_construct_list [ i ] and mc_builders [ i ] then
30668: LD_EXP 81
30672: PUSH
30673: LD_VAR 0 2
30677: ARRAY
30678: NOT
30679: PUSH
30680: LD_EXP 83
30684: PUSH
30685: LD_VAR 0 2
30689: ARRAY
30690: NOT
30691: AND
30692: PUSH
30693: LD_EXP 82
30697: PUSH
30698: LD_VAR 0 2
30702: ARRAY
30703: AND
30704: IFFALSE 30742
// begin mc_builders := Replace ( mc_builders , i , [ ] ) ;
30706: LD_ADDR_EXP 82
30710: PUSH
30711: LD_EXP 82
30715: PPUSH
30716: LD_VAR 0 2
30720: PPUSH
30721: EMPTY
30722: PPUSH
30723: CALL_OW 1
30727: ST_TO_ADDR
// MC_Reset ( i , 103 ) ;
30728: LD_VAR 0 2
30732: PPUSH
30733: LD_INT 103
30735: PPUSH
30736: CALL 24446 0 2
// continue ;
30740: GO 30651
// end ; if mc_construct_list [ i ] then
30742: LD_EXP 83
30746: PUSH
30747: LD_VAR 0 2
30751: ARRAY
30752: IFFALSE 30972
// begin tmp := UnitFilter ( mc_bases [ i ] , [ f_class , 2 ] ) diff mc_building_repairs [ i ] ;
30754: LD_ADDR_VAR 0 4
30758: PUSH
30759: LD_EXP 76
30763: PUSH
30764: LD_VAR 0 2
30768: ARRAY
30769: PPUSH
30770: LD_INT 25
30772: PUSH
30773: LD_INT 2
30775: PUSH
30776: EMPTY
30777: LIST
30778: LIST
30779: PPUSH
30780: CALL_OW 72
30784: PUSH
30785: LD_EXP 78
30789: PUSH
30790: LD_VAR 0 2
30794: ARRAY
30795: DIFF
30796: ST_TO_ADDR
// if not tmp then
30797: LD_VAR 0 4
30801: NOT
30802: IFFALSE 30806
// continue ;
30804: GO 30651
// for j in tmp do
30806: LD_ADDR_VAR 0 3
30810: PUSH
30811: LD_VAR 0 4
30815: PUSH
30816: FOR_IN
30817: IFFALSE 30968
// begin if not mc_builders [ i ] then
30819: LD_EXP 82
30823: PUSH
30824: LD_VAR 0 2
30828: ARRAY
30829: NOT
30830: IFFALSE 30888
// begin SetTag ( j , 103 ) ;
30832: LD_VAR 0 3
30836: PPUSH
30837: LD_INT 103
30839: PPUSH
30840: CALL_OW 109
// mc_builders := ReplaceIn ( mc_builders , [ i , mc_builders [ i ] + 1 ] , j ) ;
30844: LD_ADDR_EXP 82
30848: PUSH
30849: LD_EXP 82
30853: PPUSH
30854: LD_VAR 0 2
30858: PUSH
30859: LD_EXP 82
30863: PUSH
30864: LD_VAR 0 2
30868: ARRAY
30869: PUSH
30870: LD_INT 1
30872: PLUS
30873: PUSH
30874: EMPTY
30875: LIST
30876: LIST
30877: PPUSH
30878: LD_VAR 0 3
30882: PPUSH
30883: CALL 57644 0 3
30887: ST_TO_ADDR
// end ; if IsInUnit ( j ) then
30888: LD_VAR 0 3
30892: PPUSH
30893: CALL_OW 310
30897: IFFALSE 30908
// ComExitBuilding ( j ) ;
30899: LD_VAR 0 3
30903: PPUSH
30904: CALL_OW 122
// wait ( 3 ) ;
30908: LD_INT 3
30910: PPUSH
30911: CALL_OW 67
// if not mc_construct_list [ i ] then
30915: LD_EXP 83
30919: PUSH
30920: LD_VAR 0 2
30924: ARRAY
30925: NOT
30926: IFFALSE 30930
// break ;
30928: GO 30968
// if not HasTask ( j ) then
30930: LD_VAR 0 3
30934: PPUSH
30935: CALL_OW 314
30939: NOT
30940: IFFALSE 30966
// ComComplete ( j , mc_construct_list [ i ] [ 1 ] ) ;
30942: LD_VAR 0 3
30946: PPUSH
30947: LD_EXP 83
30951: PUSH
30952: LD_VAR 0 2
30956: ARRAY
30957: PUSH
30958: LD_INT 1
30960: ARRAY
30961: PPUSH
30962: CALL 60495 0 2
// end ;
30966: GO 30816
30968: POP
30969: POP
// end else
30970: GO 31775
// if mc_build_list [ i ] then
30972: LD_EXP 81
30976: PUSH
30977: LD_VAR 0 2
30981: ARRAY
30982: IFFALSE 31775
// begin depot := UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) ;
30984: LD_ADDR_VAR 0 5
30988: PUSH
30989: LD_EXP 76
30993: PUSH
30994: LD_VAR 0 2
30998: ARRAY
30999: PPUSH
31000: LD_INT 2
31002: PUSH
31003: LD_INT 30
31005: PUSH
31006: LD_INT 0
31008: PUSH
31009: EMPTY
31010: LIST
31011: LIST
31012: PUSH
31013: LD_INT 30
31015: PUSH
31016: LD_INT 1
31018: PUSH
31019: EMPTY
31020: LIST
31021: LIST
31022: PUSH
31023: EMPTY
31024: LIST
31025: LIST
31026: LIST
31027: PPUSH
31028: CALL_OW 72
31032: ST_TO_ADDR
// if depot then
31033: LD_VAR 0 5
31037: IFFALSE 31055
// depot := depot [ 1 ] else
31039: LD_ADDR_VAR 0 5
31043: PUSH
31044: LD_VAR 0 5
31048: PUSH
31049: LD_INT 1
31051: ARRAY
31052: ST_TO_ADDR
31053: GO 31063
// depot := 0 ;
31055: LD_ADDR_VAR 0 5
31059: PUSH
31060: LD_INT 0
31062: ST_TO_ADDR
// if IsExtension ( mc_build_list [ i ] [ 1 ] [ 1 ] ) and not UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_workshop ] , [ f_btype , b_factory ] ] ) then
31063: LD_EXP 81
31067: PUSH
31068: LD_VAR 0 2
31072: ARRAY
31073: PUSH
31074: LD_INT 1
31076: ARRAY
31077: PUSH
31078: LD_INT 1
31080: ARRAY
31081: PPUSH
31082: CALL 60325 0 1
31086: PUSH
31087: LD_EXP 76
31091: PUSH
31092: LD_VAR 0 2
31096: ARRAY
31097: PPUSH
31098: LD_INT 2
31100: PUSH
31101: LD_INT 30
31103: PUSH
31104: LD_INT 2
31106: PUSH
31107: EMPTY
31108: LIST
31109: LIST
31110: PUSH
31111: LD_INT 30
31113: PUSH
31114: LD_INT 3
31116: PUSH
31117: EMPTY
31118: LIST
31119: LIST
31120: PUSH
31121: EMPTY
31122: LIST
31123: LIST
31124: LIST
31125: PPUSH
31126: CALL_OW 72
31130: NOT
31131: AND
31132: IFFALSE 31237
// begin for j = 1 to mc_build_list [ i ] do
31134: LD_ADDR_VAR 0 3
31138: PUSH
31139: DOUBLE
31140: LD_INT 1
31142: DEC
31143: ST_TO_ADDR
31144: LD_EXP 81
31148: PUSH
31149: LD_VAR 0 2
31153: ARRAY
31154: PUSH
31155: FOR_TO
31156: IFFALSE 31235
// if mc_build_list [ i ] [ j ] [ 1 ] = b_workshop then
31158: LD_EXP 81
31162: PUSH
31163: LD_VAR 0 2
31167: ARRAY
31168: PUSH
31169: LD_VAR 0 3
31173: ARRAY
31174: PUSH
31175: LD_INT 1
31177: ARRAY
31178: PUSH
31179: LD_INT 2
31181: EQUAL
31182: IFFALSE 31233
// begin mc_build_list := Replace ( mc_build_list , i , Reindex ( mc_build_list [ i ] , j , 1 , false ) ) ;
31184: LD_ADDR_EXP 81
31188: PUSH
31189: LD_EXP 81
31193: PPUSH
31194: LD_VAR 0 2
31198: PPUSH
31199: LD_EXP 81
31203: PUSH
31204: LD_VAR 0 2
31208: ARRAY
31209: PPUSH
31210: LD_VAR 0 3
31214: PPUSH
31215: LD_INT 1
31217: PPUSH
31218: LD_INT 0
31220: PPUSH
31221: CALL 57062 0 4
31225: PPUSH
31226: CALL_OW 1
31230: ST_TO_ADDR
// break ;
31231: GO 31235
// end ;
31233: GO 31155
31235: POP
31236: POP
// end ; if mc_build_list [ i ] [ 1 ] [ 1 ] = b_depot or ( depot and CanBeBuilt ( depot , mc_build_list [ i ] [ 1 ] [ 1 ] , mc_build_list [ i ] [ 1 ] [ 2 ] , mc_build_list [ i ] [ 1 ] [ 3 ] , mc_build_list [ i ] [ 1 ] [ 4 ] ) ) then
31237: LD_EXP 81
31241: PUSH
31242: LD_VAR 0 2
31246: ARRAY
31247: PUSH
31248: LD_INT 1
31250: ARRAY
31251: PUSH
31252: LD_INT 1
31254: ARRAY
31255: PUSH
31256: LD_INT 0
31258: EQUAL
31259: PUSH
31260: LD_VAR 0 5
31264: PUSH
31265: LD_VAR 0 5
31269: PPUSH
31270: LD_EXP 81
31274: PUSH
31275: LD_VAR 0 2
31279: ARRAY
31280: PUSH
31281: LD_INT 1
31283: ARRAY
31284: PUSH
31285: LD_INT 1
31287: ARRAY
31288: PPUSH
31289: LD_EXP 81
31293: PUSH
31294: LD_VAR 0 2
31298: ARRAY
31299: PUSH
31300: LD_INT 1
31302: ARRAY
31303: PUSH
31304: LD_INT 2
31306: ARRAY
31307: PPUSH
31308: LD_EXP 81
31312: PUSH
31313: LD_VAR 0 2
31317: ARRAY
31318: PUSH
31319: LD_INT 1
31321: ARRAY
31322: PUSH
31323: LD_INT 3
31325: ARRAY
31326: PPUSH
31327: LD_EXP 81
31331: PUSH
31332: LD_VAR 0 2
31336: ARRAY
31337: PUSH
31338: LD_INT 1
31340: ARRAY
31341: PUSH
31342: LD_INT 4
31344: ARRAY
31345: PPUSH
31346: CALL 65059 0 5
31350: AND
31351: OR
31352: IFFALSE 31633
// begin tmp := UnitFilter ( mc_bases [ i ] , [ f_class , 2 ] ) diff mc_building_repairs [ i ] ;
31354: LD_ADDR_VAR 0 4
31358: PUSH
31359: LD_EXP 76
31363: PUSH
31364: LD_VAR 0 2
31368: ARRAY
31369: PPUSH
31370: LD_INT 25
31372: PUSH
31373: LD_INT 2
31375: PUSH
31376: EMPTY
31377: LIST
31378: LIST
31379: PPUSH
31380: CALL_OW 72
31384: PUSH
31385: LD_EXP 78
31389: PUSH
31390: LD_VAR 0 2
31394: ARRAY
31395: DIFF
31396: ST_TO_ADDR
// if not tmp then
31397: LD_VAR 0 4
31401: NOT
31402: IFFALSE 31406
// continue ;
31404: GO 30651
// for j in tmp do
31406: LD_ADDR_VAR 0 3
31410: PUSH
31411: LD_VAR 0 4
31415: PUSH
31416: FOR_IN
31417: IFFALSE 31629
// begin if not mc_builders [ i ] then
31419: LD_EXP 82
31423: PUSH
31424: LD_VAR 0 2
31428: ARRAY
31429: NOT
31430: IFFALSE 31488
// begin SetTag ( j , 103 ) ;
31432: LD_VAR 0 3
31436: PPUSH
31437: LD_INT 103
31439: PPUSH
31440: CALL_OW 109
// mc_builders := ReplaceIn ( mc_builders , [ i , mc_builders [ i ] + 1 ] , j ) ;
31444: LD_ADDR_EXP 82
31448: PUSH
31449: LD_EXP 82
31453: PPUSH
31454: LD_VAR 0 2
31458: PUSH
31459: LD_EXP 82
31463: PUSH
31464: LD_VAR 0 2
31468: ARRAY
31469: PUSH
31470: LD_INT 1
31472: PLUS
31473: PUSH
31474: EMPTY
31475: LIST
31476: LIST
31477: PPUSH
31478: LD_VAR 0 3
31482: PPUSH
31483: CALL 57644 0 3
31487: ST_TO_ADDR
// end ; if IsInUnit ( j ) then
31488: LD_VAR 0 3
31492: PPUSH
31493: CALL_OW 310
31497: IFFALSE 31508
// ComExitBuilding ( j ) ;
31499: LD_VAR 0 3
31503: PPUSH
31504: CALL_OW 122
// wait ( 3 ) ;
31508: LD_INT 3
31510: PPUSH
31511: CALL_OW 67
// if not mc_build_list [ i ] then
31515: LD_EXP 81
31519: PUSH
31520: LD_VAR 0 2
31524: ARRAY
31525: NOT
31526: IFFALSE 31530
// break ;
31528: GO 31629
// if not HasTask ( j ) then
31530: LD_VAR 0 3
31534: PPUSH
31535: CALL_OW 314
31539: NOT
31540: IFFALSE 31627
// ComBuild ( j , mc_build_list [ i ] [ 1 ] [ 1 ] , mc_build_list [ i ] [ 1 ] [ 2 ] , mc_build_list [ i ] [ 1 ] [ 3 ] , mc_build_list [ i ] [ 1 ] [ 4 ] ) ;
31542: LD_VAR 0 3
31546: PPUSH
31547: LD_EXP 81
31551: PUSH
31552: LD_VAR 0 2
31556: ARRAY
31557: PUSH
31558: LD_INT 1
31560: ARRAY
31561: PUSH
31562: LD_INT 1
31564: ARRAY
31565: PPUSH
31566: LD_EXP 81
31570: PUSH
31571: LD_VAR 0 2
31575: ARRAY
31576: PUSH
31577: LD_INT 1
31579: ARRAY
31580: PUSH
31581: LD_INT 2
31583: ARRAY
31584: PPUSH
31585: LD_EXP 81
31589: PUSH
31590: LD_VAR 0 2
31594: ARRAY
31595: PUSH
31596: LD_INT 1
31598: ARRAY
31599: PUSH
31600: LD_INT 3
31602: ARRAY
31603: PPUSH
31604: LD_EXP 81
31608: PUSH
31609: LD_VAR 0 2
31613: ARRAY
31614: PUSH
31615: LD_INT 1
31617: ARRAY
31618: PUSH
31619: LD_INT 4
31621: ARRAY
31622: PPUSH
31623: CALL_OW 145
// end ;
31627: GO 31416
31629: POP
31630: POP
// end else
31631: GO 31775
// if not TryClearPlaceForBuilding ( mc_bases [ i ] , mc_build_list [ i ] [ 1 ] [ 1 ] , mc_build_list [ i ] [ 1 ] [ 2 ] , mc_build_list [ i ] [ 1 ] [ 3 ] , mc_build_list [ i ] [ 1 ] [ 4 ] ) then
31633: LD_EXP 76
31637: PUSH
31638: LD_VAR 0 2
31642: ARRAY
31643: PPUSH
31644: LD_EXP 81
31648: PUSH
31649: LD_VAR 0 2
31653: ARRAY
31654: PUSH
31655: LD_INT 1
31657: ARRAY
31658: PUSH
31659: LD_INT 1
31661: ARRAY
31662: PPUSH
31663: LD_EXP 81
31667: PUSH
31668: LD_VAR 0 2
31672: ARRAY
31673: PUSH
31674: LD_INT 1
31676: ARRAY
31677: PUSH
31678: LD_INT 2
31680: ARRAY
31681: PPUSH
31682: LD_EXP 81
31686: PUSH
31687: LD_VAR 0 2
31691: ARRAY
31692: PUSH
31693: LD_INT 1
31695: ARRAY
31696: PUSH
31697: LD_INT 3
31699: ARRAY
31700: PPUSH
31701: LD_EXP 81
31705: PUSH
31706: LD_VAR 0 2
31710: ARRAY
31711: PUSH
31712: LD_INT 1
31714: ARRAY
31715: PUSH
31716: LD_INT 4
31718: ARRAY
31719: PPUSH
31720: CALL 64395 0 5
31724: NOT
31725: IFFALSE 31775
// begin mc_build_list := Replace ( mc_build_list , i , Reindex ( mc_build_list [ i ] , 1 , - 1 , false ) ) ;
31727: LD_ADDR_EXP 81
31731: PUSH
31732: LD_EXP 81
31736: PPUSH
31737: LD_VAR 0 2
31741: PPUSH
31742: LD_EXP 81
31746: PUSH
31747: LD_VAR 0 2
31751: ARRAY
31752: PPUSH
31753: LD_INT 1
31755: PPUSH
31756: LD_INT 1
31758: NEG
31759: PPUSH
31760: LD_INT 0
31762: PPUSH
31763: CALL 57062 0 4
31767: PPUSH
31768: CALL_OW 1
31772: ST_TO_ADDR
// continue ;
31773: GO 30651
// end ; end ; end ;
31775: GO 30651
31777: POP
31778: POP
// end ;
31779: LD_VAR 0 1
31783: RET
// export function MC_BuildUpgrade ( ) ; var i , j , tmp , depot , lab ; begin
31784: LD_INT 0
31786: PPUSH
31787: PPUSH
31788: PPUSH
31789: PPUSH
31790: PPUSH
31791: PPUSH
// if not mc_bases then
31792: LD_EXP 76
31796: NOT
31797: IFFALSE 31801
// exit ;
31799: GO 32228
// for i = 1 to mc_bases do
31801: LD_ADDR_VAR 0 2
31805: PUSH
31806: DOUBLE
31807: LD_INT 1
31809: DEC
31810: ST_TO_ADDR
31811: LD_EXP 76
31815: PUSH
31816: FOR_TO
31817: IFFALSE 32226
// begin tmp := mc_build_upgrade [ i ] ;
31819: LD_ADDR_VAR 0 4
31823: PUSH
31824: LD_EXP 108
31828: PUSH
31829: LD_VAR 0 2
31833: ARRAY
31834: ST_TO_ADDR
// lab := UnitFilter ( mc_lab [ i ] , [ f_or , [ f_btype , b_lab ] , [ f_btype , b_lab_half ] ] ) ;
31835: LD_ADDR_VAR 0 6
31839: PUSH
31840: LD_EXP 109
31844: PUSH
31845: LD_VAR 0 2
31849: ARRAY
31850: PPUSH
31851: LD_INT 2
31853: PUSH
31854: LD_INT 30
31856: PUSH
31857: LD_INT 6
31859: PUSH
31860: EMPTY
31861: LIST
31862: LIST
31863: PUSH
31864: LD_INT 30
31866: PUSH
31867: LD_INT 7
31869: PUSH
31870: EMPTY
31871: LIST
31872: LIST
31873: PUSH
31874: EMPTY
31875: LIST
31876: LIST
31877: LIST
31878: PPUSH
31879: CALL_OW 72
31883: ST_TO_ADDR
// if not tmp and not lab then
31884: LD_VAR 0 4
31888: NOT
31889: PUSH
31890: LD_VAR 0 6
31894: NOT
31895: AND
31896: IFFALSE 31900
// continue ;
31898: GO 31816
// if tmp then
31900: LD_VAR 0 4
31904: IFFALSE 32024
// for j in tmp do
31906: LD_ADDR_VAR 0 3
31910: PUSH
31911: LD_VAR 0 4
31915: PUSH
31916: FOR_IN
31917: IFFALSE 32022
// begin if UpgradeCost ( j ) then
31919: LD_VAR 0 3
31923: PPUSH
31924: CALL 64055 0 1
31928: IFFALSE 32020
// begin ComUpgrade ( j ) ;
31930: LD_VAR 0 3
31934: PPUSH
31935: CALL_OW 146
// mc_build_upgrade := Replace ( mc_build_upgrade , i , mc_build_upgrade [ i ] diff j ) ;
31939: LD_ADDR_EXP 108
31943: PUSH
31944: LD_EXP 108
31948: PPUSH
31949: LD_VAR 0 2
31953: PPUSH
31954: LD_EXP 108
31958: PUSH
31959: LD_VAR 0 2
31963: ARRAY
31964: PUSH
31965: LD_VAR 0 3
31969: DIFF
31970: PPUSH
31971: CALL_OW 1
31975: ST_TO_ADDR
// mc_construct_list := ReplaceIn ( mc_construct_list , [ i , mc_construct_list [ i ] + 1 ] , j ) ;
31976: LD_ADDR_EXP 83
31980: PUSH
31981: LD_EXP 83
31985: PPUSH
31986: LD_VAR 0 2
31990: PUSH
31991: LD_EXP 83
31995: PUSH
31996: LD_VAR 0 2
32000: ARRAY
32001: PUSH
32002: LD_INT 1
32004: PLUS
32005: PUSH
32006: EMPTY
32007: LIST
32008: LIST
32009: PPUSH
32010: LD_VAR 0 3
32014: PPUSH
32015: CALL 57644 0 3
32019: ST_TO_ADDR
// end ; end ;
32020: GO 31916
32022: POP
32023: POP
// if not lab or not mc_lab_upgrade [ i ] then
32024: LD_VAR 0 6
32028: NOT
32029: PUSH
32030: LD_EXP 110
32034: PUSH
32035: LD_VAR 0 2
32039: ARRAY
32040: NOT
32041: OR
32042: IFFALSE 32046
// continue ;
32044: GO 31816
// for j in lab do
32046: LD_ADDR_VAR 0 3
32050: PUSH
32051: LD_VAR 0 6
32055: PUSH
32056: FOR_IN
32057: IFFALSE 32222
// begin if GetBType ( j ) in [ b_lab , b_lab_half ] and BuildingStatus ( j ) <> bs_build then
32059: LD_VAR 0 3
32063: PPUSH
32064: CALL_OW 266
32068: PUSH
32069: LD_INT 6
32071: PUSH
32072: LD_INT 7
32074: PUSH
32075: EMPTY
32076: LIST
32077: LIST
32078: IN
32079: PUSH
32080: LD_VAR 0 3
32084: PPUSH
32085: CALL_OW 461
32089: PUSH
32090: LD_INT 1
32092: NONEQUAL
32093: AND
32094: IFFALSE 32220
// begin if UpgradeLabCost ( j , mc_lab_upgrade [ i ] [ 1 ] ) then
32096: LD_VAR 0 3
32100: PPUSH
32101: LD_EXP 110
32105: PUSH
32106: LD_VAR 0 2
32110: ARRAY
32111: PUSH
32112: LD_INT 1
32114: ARRAY
32115: PPUSH
32116: CALL 64260 0 2
32120: IFFALSE 32220
// begin ComCancel ( j ) ;
32122: LD_VAR 0 3
32126: PPUSH
32127: CALL_OW 127
// AddComUpgradeLab ( j , mc_lab_upgrade [ i ] [ 1 ] ) ;
32131: LD_VAR 0 3
32135: PPUSH
32136: LD_EXP 110
32140: PUSH
32141: LD_VAR 0 2
32145: ARRAY
32146: PUSH
32147: LD_INT 1
32149: ARRAY
32150: PPUSH
32151: CALL_OW 207
// if not j in mc_construct_list [ i ] then
32155: LD_VAR 0 3
32159: PUSH
32160: LD_EXP 83
32164: PUSH
32165: LD_VAR 0 2
32169: ARRAY
32170: IN
32171: NOT
32172: IFFALSE 32218
// mc_construct_list := ReplaceIn ( mc_construct_list , [ i , mc_construct_list [ i ] + 1 ] , j ) ;
32174: LD_ADDR_EXP 83
32178: PUSH
32179: LD_EXP 83
32183: PPUSH
32184: LD_VAR 0 2
32188: PUSH
32189: LD_EXP 83
32193: PUSH
32194: LD_VAR 0 2
32198: ARRAY
32199: PUSH
32200: LD_INT 1
32202: PLUS
32203: PUSH
32204: EMPTY
32205: LIST
32206: LIST
32207: PPUSH
32208: LD_VAR 0 3
32212: PPUSH
32213: CALL 57644 0 3
32217: ST_TO_ADDR
// break ;
32218: GO 32222
// end ; end ; end ;
32220: GO 32056
32222: POP
32223: POP
// end ;
32224: GO 31816
32226: POP
32227: POP
// end ;
32228: LD_VAR 0 1
32232: RET
// export function MC_TurretWeapon ( ) ; var i , j , tmp , tmp2 , t , tw , busy , weapon ; begin
32233: LD_INT 0
32235: PPUSH
32236: PPUSH
32237: PPUSH
32238: PPUSH
32239: PPUSH
32240: PPUSH
32241: PPUSH
32242: PPUSH
32243: PPUSH
// if not mc_bases then
32244: LD_EXP 76
32248: NOT
32249: IFFALSE 32253
// exit ;
32251: GO 32658
// for i = 1 to mc_bases do
32253: LD_ADDR_VAR 0 2
32257: PUSH
32258: DOUBLE
32259: LD_INT 1
32261: DEC
32262: ST_TO_ADDR
32263: LD_EXP 76
32267: PUSH
32268: FOR_TO
32269: IFFALSE 32656
// begin if not mc_turret_list [ i ] or not UnitFilter ( mc_bases [ i ] , [ f_btype , b_factory ] ) then
32271: LD_EXP 84
32275: PUSH
32276: LD_VAR 0 2
32280: ARRAY
32281: NOT
32282: PUSH
32283: LD_EXP 76
32287: PUSH
32288: LD_VAR 0 2
32292: ARRAY
32293: PPUSH
32294: LD_INT 30
32296: PUSH
32297: LD_INT 3
32299: PUSH
32300: EMPTY
32301: LIST
32302: LIST
32303: PPUSH
32304: CALL_OW 72
32308: NOT
32309: OR
32310: IFFALSE 32314
// continue ;
32312: GO 32268
// busy := false ;
32314: LD_ADDR_VAR 0 8
32318: PUSH
32319: LD_INT 0
32321: ST_TO_ADDR
// tmp := UnitFilter ( mc_bases [ i ] , [ f_btype , b_factory ] ) ;
32322: LD_ADDR_VAR 0 4
32326: PUSH
32327: LD_EXP 76
32331: PUSH
32332: LD_VAR 0 2
32336: ARRAY
32337: PPUSH
32338: LD_INT 30
32340: PUSH
32341: LD_INT 3
32343: PUSH
32344: EMPTY
32345: LIST
32346: LIST
32347: PPUSH
32348: CALL_OW 72
32352: ST_TO_ADDR
// t := UnitFilter ( mc_turret_list [ i ] , [ f_or , [ f_btype , b_bunker ] , [ f_btype , b_turret ] ] ) ;
32353: LD_ADDR_VAR 0 6
32357: PUSH
32358: LD_EXP 84
32362: PUSH
32363: LD_VAR 0 2
32367: ARRAY
32368: PPUSH
32369: LD_INT 2
32371: PUSH
32372: LD_INT 30
32374: PUSH
32375: LD_INT 32
32377: PUSH
32378: EMPTY
32379: LIST
32380: LIST
32381: PUSH
32382: LD_INT 30
32384: PUSH
32385: LD_INT 33
32387: PUSH
32388: EMPTY
32389: LIST
32390: LIST
32391: PUSH
32392: EMPTY
32393: LIST
32394: LIST
32395: LIST
32396: PPUSH
32397: CALL_OW 72
32401: ST_TO_ADDR
// if not t then
32402: LD_VAR 0 6
32406: NOT
32407: IFFALSE 32411
// continue ;
32409: GO 32268
// for j in tmp do
32411: LD_ADDR_VAR 0 3
32415: PUSH
32416: LD_VAR 0 4
32420: PUSH
32421: FOR_IN
32422: IFFALSE 32452
// if not BuildingStatus ( j ) = bs_idle then
32424: LD_VAR 0 3
32428: PPUSH
32429: CALL_OW 461
32433: PUSH
32434: LD_INT 2
32436: EQUAL
32437: NOT
32438: IFFALSE 32450
// begin busy := true ;
32440: LD_ADDR_VAR 0 8
32444: PUSH
32445: LD_INT 1
32447: ST_TO_ADDR
// break ;
32448: GO 32452
// end ;
32450: GO 32421
32452: POP
32453: POP
// if busy then
32454: LD_VAR 0 8
32458: IFFALSE 32462
// continue ;
32460: GO 32268
// tw := UnitFilter ( t , [ f_bweapon , 0 ] ) ;
32462: LD_ADDR_VAR 0 7
32466: PUSH
32467: LD_VAR 0 6
32471: PPUSH
32472: LD_INT 35
32474: PUSH
32475: LD_INT 0
32477: PUSH
32478: EMPTY
32479: LIST
32480: LIST
32481: PPUSH
32482: CALL_OW 72
32486: ST_TO_ADDR
// if tw then
32487: LD_VAR 0 7
32491: IFFALSE 32568
// begin tw := tw [ 1 ] ;
32493: LD_ADDR_VAR 0 7
32497: PUSH
32498: LD_VAR 0 7
32502: PUSH
32503: LD_INT 1
32505: ARRAY
32506: ST_TO_ADDR
// weapon := GetTurretWeapon ( tw , mc_scan_area [ i ] ) ;
32507: LD_ADDR_VAR 0 9
32511: PUSH
32512: LD_VAR 0 7
32516: PPUSH
32517: LD_EXP 101
32521: PUSH
32522: LD_VAR 0 2
32526: ARRAY
32527: PPUSH
32528: CALL 62614 0 2
32532: ST_TO_ADDR
// if mc_allowed_tower_weapons [ i ] then
32533: LD_EXP 115
32537: PUSH
32538: LD_VAR 0 2
32542: ARRAY
32543: IFFALSE 32566
// if not weapon in mc_allowed_tower_weapons [ i ] then
32545: LD_VAR 0 9
32549: PUSH
32550: LD_EXP 115
32554: PUSH
32555: LD_VAR 0 2
32559: ARRAY
32560: IN
32561: NOT
32562: IFFALSE 32566
// continue ;
32564: GO 32268
// end else
32566: GO 32631
// begin tmp2 := UpgradeTurretsWeapon ( mc_turret_list [ i ] , tmp ) ;
32568: LD_ADDR_VAR 0 5
32572: PUSH
32573: LD_EXP 84
32577: PUSH
32578: LD_VAR 0 2
32582: ARRAY
32583: PPUSH
32584: LD_VAR 0 4
32588: PPUSH
32589: CALL 92818 0 2
32593: ST_TO_ADDR
// if not tmp2 then
32594: LD_VAR 0 5
32598: NOT
32599: IFFALSE 32603
// continue ;
32601: GO 32268
// tw := tmp2 [ 1 ] ;
32603: LD_ADDR_VAR 0 7
32607: PUSH
32608: LD_VAR 0 5
32612: PUSH
32613: LD_INT 1
32615: ARRAY
32616: ST_TO_ADDR
// weapon := tmp2 [ 2 ] ;
32617: LD_ADDR_VAR 0 9
32621: PUSH
32622: LD_VAR 0 5
32626: PUSH
32627: LD_INT 2
32629: ARRAY
32630: ST_TO_ADDR
// end ; if not weapon then
32631: LD_VAR 0 9
32635: NOT
32636: IFFALSE 32640
// continue ;
32638: GO 32268
// ComPlaceWeapon ( tw , weapon ) ;
32640: LD_VAR 0 7
32644: PPUSH
32645: LD_VAR 0 9
32649: PPUSH
32650: CALL_OW 148
// end ;
32654: GO 32268
32656: POP
32657: POP
// end ;
32658: LD_VAR 0 1
32662: RET
// export function MC_PlantMines ( ) ; var i , j , k , tmp , list ; begin
32663: LD_INT 0
32665: PPUSH
32666: PPUSH
32667: PPUSH
32668: PPUSH
32669: PPUSH
32670: PPUSH
// if not mc_bases then
32671: LD_EXP 76
32675: NOT
32676: IFFALSE 32680
// exit ;
32678: GO 33456
// for i = 1 to mc_bases do
32680: LD_ADDR_VAR 0 2
32684: PUSH
32685: DOUBLE
32686: LD_INT 1
32688: DEC
32689: ST_TO_ADDR
32690: LD_EXP 76
32694: PUSH
32695: FOR_TO
32696: IFFALSE 33454
// begin if not mc_mines [ i ] or mc_mines [ i ] = mc_miners [ i ] or mc_scan [ i ] then
32698: LD_EXP 89
32702: PUSH
32703: LD_VAR 0 2
32707: ARRAY
32708: NOT
32709: PUSH
32710: LD_EXP 89
32714: PUSH
32715: LD_VAR 0 2
32719: ARRAY
32720: PUSH
32721: LD_EXP 90
32725: PUSH
32726: LD_VAR 0 2
32730: ARRAY
32731: EQUAL
32732: OR
32733: PUSH
32734: LD_EXP 99
32738: PUSH
32739: LD_VAR 0 2
32743: ARRAY
32744: OR
32745: IFFALSE 32749
// continue ;
32747: GO 32695
// if mc_miners [ i ] then
32749: LD_EXP 90
32753: PUSH
32754: LD_VAR 0 2
32758: ARRAY
32759: IFFALSE 33141
// begin for j = mc_miners [ i ] downto 1 do
32761: LD_ADDR_VAR 0 3
32765: PUSH
32766: DOUBLE
32767: LD_EXP 90
32771: PUSH
32772: LD_VAR 0 2
32776: ARRAY
32777: INC
32778: ST_TO_ADDR
32779: LD_INT 1
32781: PUSH
32782: FOR_DOWNTO
32783: IFFALSE 33139
// begin if IsDead ( mc_miners [ i ] [ j ] ) or GetClass ( mc_miners [ i ] [ j ] ) <> 1 then
32785: LD_EXP 90
32789: PUSH
32790: LD_VAR 0 2
32794: ARRAY
32795: PUSH
32796: LD_VAR 0 3
32800: ARRAY
32801: PPUSH
32802: CALL_OW 301
32806: PUSH
32807: LD_EXP 90
32811: PUSH
32812: LD_VAR 0 2
32816: ARRAY
32817: PUSH
32818: LD_VAR 0 3
32822: ARRAY
32823: PPUSH
32824: CALL_OW 257
32828: PUSH
32829: LD_INT 1
32831: NONEQUAL
32832: OR
32833: IFFALSE 32896
// begin tmp := mc_miners [ i ] diff mc_miners [ i ] [ j ] ;
32835: LD_ADDR_VAR 0 5
32839: PUSH
32840: LD_EXP 90
32844: PUSH
32845: LD_VAR 0 2
32849: ARRAY
32850: PUSH
32851: LD_EXP 90
32855: PUSH
32856: LD_VAR 0 2
32860: ARRAY
32861: PUSH
32862: LD_VAR 0 3
32866: ARRAY
32867: DIFF
32868: ST_TO_ADDR
// mc_miners := Replace ( mc_miners , i , tmp ) ;
32869: LD_ADDR_EXP 90
32873: PUSH
32874: LD_EXP 90
32878: PPUSH
32879: LD_VAR 0 2
32883: PPUSH
32884: LD_VAR 0 5
32888: PPUSH
32889: CALL_OW 1
32893: ST_TO_ADDR
// continue ;
32894: GO 32782
// end ; if GetClass ( mc_miners [ i ] [ j ] ) = 1 and not MineOfUnit ( mc_miners [ i ] [ j ] ) and not HasTask ( mc_miners [ i ] [ j ] ) then
32896: LD_EXP 90
32900: PUSH
32901: LD_VAR 0 2
32905: ARRAY
32906: PUSH
32907: LD_VAR 0 3
32911: ARRAY
32912: PPUSH
32913: CALL_OW 257
32917: PUSH
32918: LD_INT 1
32920: EQUAL
32921: PUSH
32922: LD_EXP 90
32926: PUSH
32927: LD_VAR 0 2
32931: ARRAY
32932: PUSH
32933: LD_VAR 0 3
32937: ARRAY
32938: PPUSH
32939: CALL_OW 459
32943: NOT
32944: AND
32945: PUSH
32946: LD_EXP 90
32950: PUSH
32951: LD_VAR 0 2
32955: ARRAY
32956: PUSH
32957: LD_VAR 0 3
32961: ARRAY
32962: PPUSH
32963: CALL_OW 314
32967: NOT
32968: AND
32969: IFFALSE 33137
// begin if IsInUnit ( mc_miners [ i ] [ j ] ) then
32971: LD_EXP 90
32975: PUSH
32976: LD_VAR 0 2
32980: ARRAY
32981: PUSH
32982: LD_VAR 0 3
32986: ARRAY
32987: PPUSH
32988: CALL_OW 310
32992: IFFALSE 33015
// ComExitBuilding ( mc_miners [ i ] [ j ] ) ;
32994: LD_EXP 90
32998: PUSH
32999: LD_VAR 0 2
33003: ARRAY
33004: PUSH
33005: LD_VAR 0 3
33009: ARRAY
33010: PPUSH
33011: CALL_OW 122
// if not HasTask ( mc_miners [ i ] [ j ] ) then
33015: LD_EXP 90
33019: PUSH
33020: LD_VAR 0 2
33024: ARRAY
33025: PUSH
33026: LD_VAR 0 3
33030: ARRAY
33031: PPUSH
33032: CALL_OW 314
33036: NOT
33037: IFFALSE 33137
// AddComPlaceRemoteCharge ( mc_miners [ i ] [ j ] , mc_mines [ i ] [ j mod mc_mines [ i ] + 1 ] [ 1 ] , mc_mines [ i ] [ j mod mc_mines [ i ] + 1 ] [ 2 ] , 0 ) ;
33039: LD_EXP 90
33043: PUSH
33044: LD_VAR 0 2
33048: ARRAY
33049: PUSH
33050: LD_VAR 0 3
33054: ARRAY
33055: PPUSH
33056: LD_EXP 89
33060: PUSH
33061: LD_VAR 0 2
33065: ARRAY
33066: PUSH
33067: LD_VAR 0 3
33071: PUSH
33072: LD_EXP 89
33076: PUSH
33077: LD_VAR 0 2
33081: ARRAY
33082: MOD
33083: PUSH
33084: LD_INT 1
33086: PLUS
33087: ARRAY
33088: PUSH
33089: LD_INT 1
33091: ARRAY
33092: PPUSH
33093: LD_EXP 89
33097: PUSH
33098: LD_VAR 0 2
33102: ARRAY
33103: PUSH
33104: LD_VAR 0 3
33108: PUSH
33109: LD_EXP 89
33113: PUSH
33114: LD_VAR 0 2
33118: ARRAY
33119: MOD
33120: PUSH
33121: LD_INT 1
33123: PLUS
33124: ARRAY
33125: PUSH
33126: LD_INT 2
33128: ARRAY
33129: PPUSH
33130: LD_INT 0
33132: PPUSH
33133: CALL_OW 193
// end ; end ;
33137: GO 32782
33139: POP
33140: POP
// end ; tmp := UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_armoury ] , [ f_btype , b_barracks ] , [ f_btype , b_bunker ] ] ) ;
33141: LD_ADDR_VAR 0 5
33145: PUSH
33146: LD_EXP 76
33150: PUSH
33151: LD_VAR 0 2
33155: ARRAY
33156: PPUSH
33157: LD_INT 2
33159: PUSH
33160: LD_INT 30
33162: PUSH
33163: LD_INT 4
33165: PUSH
33166: EMPTY
33167: LIST
33168: LIST
33169: PUSH
33170: LD_INT 30
33172: PUSH
33173: LD_INT 5
33175: PUSH
33176: EMPTY
33177: LIST
33178: LIST
33179: PUSH
33180: LD_INT 30
33182: PUSH
33183: LD_INT 32
33185: PUSH
33186: EMPTY
33187: LIST
33188: LIST
33189: PUSH
33190: EMPTY
33191: LIST
33192: LIST
33193: LIST
33194: LIST
33195: PPUSH
33196: CALL_OW 72
33200: ST_TO_ADDR
// if not tmp then
33201: LD_VAR 0 5
33205: NOT
33206: IFFALSE 33210
// continue ;
33208: GO 32695
// list := [ ] ;
33210: LD_ADDR_VAR 0 6
33214: PUSH
33215: EMPTY
33216: ST_TO_ADDR
// for j in tmp do
33217: LD_ADDR_VAR 0 3
33221: PUSH
33222: LD_VAR 0 5
33226: PUSH
33227: FOR_IN
33228: IFFALSE 33297
// begin for k in UnitsInside ( j ) do
33230: LD_ADDR_VAR 0 4
33234: PUSH
33235: LD_VAR 0 3
33239: PPUSH
33240: CALL_OW 313
33244: PUSH
33245: FOR_IN
33246: IFFALSE 33293
// if GetClass ( k ) = 1 and not MineOfUnit ( k ) then
33248: LD_VAR 0 4
33252: PPUSH
33253: CALL_OW 257
33257: PUSH
33258: LD_INT 1
33260: EQUAL
33261: PUSH
33262: LD_VAR 0 4
33266: PPUSH
33267: CALL_OW 459
33271: NOT
33272: AND
33273: IFFALSE 33291
// list := list ^ k ;
33275: LD_ADDR_VAR 0 6
33279: PUSH
33280: LD_VAR 0 6
33284: PUSH
33285: LD_VAR 0 4
33289: ADD
33290: ST_TO_ADDR
33291: GO 33245
33293: POP
33294: POP
// end ;
33295: GO 33227
33297: POP
33298: POP
// list := list diff mc_miners [ i ] ;
33299: LD_ADDR_VAR 0 6
33303: PUSH
33304: LD_VAR 0 6
33308: PUSH
33309: LD_EXP 90
33313: PUSH
33314: LD_VAR 0 2
33318: ARRAY
33319: DIFF
33320: ST_TO_ADDR
// if not list then
33321: LD_VAR 0 6
33325: NOT
33326: IFFALSE 33330
// continue ;
33328: GO 32695
// k := mc_mines [ i ] - mc_miners [ i ] ;
33330: LD_ADDR_VAR 0 4
33334: PUSH
33335: LD_EXP 89
33339: PUSH
33340: LD_VAR 0 2
33344: ARRAY
33345: PUSH
33346: LD_EXP 90
33350: PUSH
33351: LD_VAR 0 2
33355: ARRAY
33356: MINUS
33357: ST_TO_ADDR
// if k > list then
33358: LD_VAR 0 4
33362: PUSH
33363: LD_VAR 0 6
33367: GREATER
33368: IFFALSE 33380
// k := list ;
33370: LD_ADDR_VAR 0 4
33374: PUSH
33375: LD_VAR 0 6
33379: ST_TO_ADDR
// for j = 1 to k do
33380: LD_ADDR_VAR 0 3
33384: PUSH
33385: DOUBLE
33386: LD_INT 1
33388: DEC
33389: ST_TO_ADDR
33390: LD_VAR 0 4
33394: PUSH
33395: FOR_TO
33396: IFFALSE 33450
// mc_miners := ReplaceIn ( mc_miners , [ i , mc_miners [ i ] + 1 ] , list [ j ] ) ;
33398: LD_ADDR_EXP 90
33402: PUSH
33403: LD_EXP 90
33407: PPUSH
33408: LD_VAR 0 2
33412: PUSH
33413: LD_EXP 90
33417: PUSH
33418: LD_VAR 0 2
33422: ARRAY
33423: PUSH
33424: LD_INT 1
33426: PLUS
33427: PUSH
33428: EMPTY
33429: LIST
33430: LIST
33431: PPUSH
33432: LD_VAR 0 6
33436: PUSH
33437: LD_VAR 0 3
33441: ARRAY
33442: PPUSH
33443: CALL 57644 0 3
33447: ST_TO_ADDR
33448: GO 33395
33450: POP
33451: POP
// end ;
33452: GO 32695
33454: POP
33455: POP
// end ;
33456: LD_VAR 0 1
33460: RET
// export function MC_CollectCrates ( ) ; var i , j , k , tmp , target , cargo , depot , fac , components ; begin
33461: LD_INT 0
33463: PPUSH
33464: PPUSH
33465: PPUSH
33466: PPUSH
33467: PPUSH
33468: PPUSH
33469: PPUSH
33470: PPUSH
33471: PPUSH
33472: PPUSH
// if not mc_bases then
33473: LD_EXP 76
33477: NOT
33478: IFFALSE 33482
// exit ;
33480: GO 35232
// for i = 1 to mc_bases do
33482: LD_ADDR_VAR 0 2
33486: PUSH
33487: DOUBLE
33488: LD_INT 1
33490: DEC
33491: ST_TO_ADDR
33492: LD_EXP 76
33496: PUSH
33497: FOR_TO
33498: IFFALSE 35230
// begin if not mc_bases [ i ] or mc_construct_list [ i ] then
33500: LD_EXP 76
33504: PUSH
33505: LD_VAR 0 2
33509: ARRAY
33510: NOT
33511: PUSH
33512: LD_EXP 83
33516: PUSH
33517: LD_VAR 0 2
33521: ARRAY
33522: OR
33523: IFFALSE 33527
// continue ;
33525: GO 33497
// if not mc_crates [ i ] and mc_crates_collector [ i ] then
33527: LD_EXP 92
33531: PUSH
33532: LD_VAR 0 2
33536: ARRAY
33537: NOT
33538: PUSH
33539: LD_EXP 93
33543: PUSH
33544: LD_VAR 0 2
33548: ARRAY
33549: AND
33550: IFFALSE 33588
// begin mc_crates_collector := Replace ( mc_crates_collector , i , [ ] ) ;
33552: LD_ADDR_EXP 93
33556: PUSH
33557: LD_EXP 93
33561: PPUSH
33562: LD_VAR 0 2
33566: PPUSH
33567: EMPTY
33568: PPUSH
33569: CALL_OW 1
33573: ST_TO_ADDR
// MC_Reset ( i , 107 ) ;
33574: LD_VAR 0 2
33578: PPUSH
33579: LD_INT 107
33581: PPUSH
33582: CALL 24446 0 2
// continue ;
33586: GO 33497
// end ; target := [ ] ;
33588: LD_ADDR_VAR 0 6
33592: PUSH
33593: EMPTY
33594: ST_TO_ADDR
// for j = mc_crates [ i ] downto 1 do
33595: LD_ADDR_VAR 0 3
33599: PUSH
33600: DOUBLE
33601: LD_EXP 92
33605: PUSH
33606: LD_VAR 0 2
33610: ARRAY
33611: INC
33612: ST_TO_ADDR
33613: LD_INT 1
33615: PUSH
33616: FOR_DOWNTO
33617: IFFALSE 33877
// begin if ValidHex ( mc_crates [ i ] [ j ] [ 2 ] , mc_crates [ i ] [ j ] [ 3 ] ) and GetResourceAmountXY ( mc_crates [ i ] [ j ] [ 2 ] , mc_crates [ i ] [ j ] [ 3 ] ) = 0 then
33619: LD_EXP 92
33623: PUSH
33624: LD_VAR 0 2
33628: ARRAY
33629: PUSH
33630: LD_VAR 0 3
33634: ARRAY
33635: PUSH
33636: LD_INT 2
33638: ARRAY
33639: PPUSH
33640: LD_EXP 92
33644: PUSH
33645: LD_VAR 0 2
33649: ARRAY
33650: PUSH
33651: LD_VAR 0 3
33655: ARRAY
33656: PUSH
33657: LD_INT 3
33659: ARRAY
33660: PPUSH
33661: CALL_OW 488
33665: PUSH
33666: LD_EXP 92
33670: PUSH
33671: LD_VAR 0 2
33675: ARRAY
33676: PUSH
33677: LD_VAR 0 3
33681: ARRAY
33682: PUSH
33683: LD_INT 2
33685: ARRAY
33686: PPUSH
33687: LD_EXP 92
33691: PUSH
33692: LD_VAR 0 2
33696: ARRAY
33697: PUSH
33698: LD_VAR 0 3
33702: ARRAY
33703: PUSH
33704: LD_INT 3
33706: ARRAY
33707: PPUSH
33708: CALL_OW 284
33712: PUSH
33713: LD_INT 0
33715: EQUAL
33716: AND
33717: IFFALSE 33772
// begin tmp := Delete ( mc_crates [ i ] , j ) ;
33719: LD_ADDR_VAR 0 5
33723: PUSH
33724: LD_EXP 92
33728: PUSH
33729: LD_VAR 0 2
33733: ARRAY
33734: PPUSH
33735: LD_VAR 0 3
33739: PPUSH
33740: CALL_OW 3
33744: ST_TO_ADDR
// mc_crates := Replace ( mc_crates , i , tmp ) ;
33745: LD_ADDR_EXP 92
33749: PUSH
33750: LD_EXP 92
33754: PPUSH
33755: LD_VAR 0 2
33759: PPUSH
33760: LD_VAR 0 5
33764: PPUSH
33765: CALL_OW 1
33769: ST_TO_ADDR
// continue ;
33770: GO 33616
// end ; if DangerAtRangeXY ( GetSide ( mc_bases [ i ] [ 1 ] ) , mc_crates [ i ] [ j ] [ 2 ] , mc_crates [ i ] [ j ] [ 3 ] , 30 ) [ 4 ] = 0 then
33772: LD_EXP 76
33776: PUSH
33777: LD_VAR 0 2
33781: ARRAY
33782: PUSH
33783: LD_INT 1
33785: ARRAY
33786: PPUSH
33787: CALL_OW 255
33791: PPUSH
33792: LD_EXP 92
33796: PUSH
33797: LD_VAR 0 2
33801: ARRAY
33802: PUSH
33803: LD_VAR 0 3
33807: ARRAY
33808: PUSH
33809: LD_INT 2
33811: ARRAY
33812: PPUSH
33813: LD_EXP 92
33817: PUSH
33818: LD_VAR 0 2
33822: ARRAY
33823: PUSH
33824: LD_VAR 0 3
33828: ARRAY
33829: PUSH
33830: LD_INT 3
33832: ARRAY
33833: PPUSH
33834: LD_INT 30
33836: PPUSH
33837: CALL 58540 0 4
33841: PUSH
33842: LD_INT 4
33844: ARRAY
33845: PUSH
33846: LD_INT 0
33848: EQUAL
33849: IFFALSE 33875
// begin target := mc_crates [ i ] [ j ] ;
33851: LD_ADDR_VAR 0 6
33855: PUSH
33856: LD_EXP 92
33860: PUSH
33861: LD_VAR 0 2
33865: ARRAY
33866: PUSH
33867: LD_VAR 0 3
33871: ARRAY
33872: ST_TO_ADDR
// break ;
33873: GO 33877
// end ; end ;
33875: GO 33616
33877: POP
33878: POP
// if not target then
33879: LD_VAR 0 6
33883: NOT
33884: IFFALSE 33888
// continue ;
33886: GO 33497
// cargo := UnitFilter ( mc_vehicles [ i ] , [ [ f_or , [ f_not , [ f_empty ] ] , [ f_linked ] , [ f_control , control_apeman ] , [ f_control , control_computer ] ] , [ f_or , [ f_weapon , ar_cargo_bay ] , [ f_weapon , ru_cargo_bay ] , [ f_weapon , us_cargo_bay ] ] ] ) ;
33888: LD_ADDR_VAR 0 7
33892: PUSH
33893: LD_EXP 95
33897: PUSH
33898: LD_VAR 0 2
33902: ARRAY
33903: PPUSH
33904: LD_INT 2
33906: PUSH
33907: LD_INT 3
33909: PUSH
33910: LD_INT 58
33912: PUSH
33913: EMPTY
33914: LIST
33915: PUSH
33916: EMPTY
33917: LIST
33918: LIST
33919: PUSH
33920: LD_INT 61
33922: PUSH
33923: EMPTY
33924: LIST
33925: PUSH
33926: LD_INT 33
33928: PUSH
33929: LD_INT 5
33931: PUSH
33932: EMPTY
33933: LIST
33934: LIST
33935: PUSH
33936: LD_INT 33
33938: PUSH
33939: LD_INT 3
33941: PUSH
33942: EMPTY
33943: LIST
33944: LIST
33945: PUSH
33946: EMPTY
33947: LIST
33948: LIST
33949: LIST
33950: LIST
33951: LIST
33952: PUSH
33953: LD_INT 2
33955: PUSH
33956: LD_INT 34
33958: PUSH
33959: LD_INT 32
33961: PUSH
33962: EMPTY
33963: LIST
33964: LIST
33965: PUSH
33966: LD_INT 34
33968: PUSH
33969: LD_INT 51
33971: PUSH
33972: EMPTY
33973: LIST
33974: LIST
33975: PUSH
33976: LD_INT 34
33978: PUSH
33979: LD_INT 12
33981: PUSH
33982: EMPTY
33983: LIST
33984: LIST
33985: PUSH
33986: EMPTY
33987: LIST
33988: LIST
33989: LIST
33990: LIST
33991: PUSH
33992: EMPTY
33993: LIST
33994: LIST
33995: PPUSH
33996: CALL_OW 72
34000: ST_TO_ADDR
// if not cargo then
34001: LD_VAR 0 7
34005: NOT
34006: IFFALSE 34649
// begin if mc_crates_collector [ i ] < 5 then
34008: LD_EXP 93
34012: PUSH
34013: LD_VAR 0 2
34017: ARRAY
34018: PUSH
34019: LD_INT 5
34021: LESS
34022: IFFALSE 34388
// begin if mc_ape [ i ] then
34024: LD_EXP 105
34028: PUSH
34029: LD_VAR 0 2
34033: ARRAY
34034: IFFALSE 34081
// tmp := UnitFilter ( mc_ape [ i ] , [ [ f_class , 16 ] , [ f_lives , 750 ] ] ) ;
34036: LD_ADDR_VAR 0 5
34040: PUSH
34041: LD_EXP 105
34045: PUSH
34046: LD_VAR 0 2
34050: ARRAY
34051: PPUSH
34052: LD_INT 25
34054: PUSH
34055: LD_INT 16
34057: PUSH
34058: EMPTY
34059: LIST
34060: LIST
34061: PUSH
34062: LD_INT 24
34064: PUSH
34065: LD_INT 750
34067: PUSH
34068: EMPTY
34069: LIST
34070: LIST
34071: PUSH
34072: EMPTY
34073: LIST
34074: LIST
34075: PPUSH
34076: CALL_OW 72
34080: ST_TO_ADDR
// if not tmp then
34081: LD_VAR 0 5
34085: NOT
34086: IFFALSE 34133
// tmp := UnitFilter ( mc_bases [ i ] , [ [ f_class , 2 ] , [ f_lives , 750 ] ] ) ;
34088: LD_ADDR_VAR 0 5
34092: PUSH
34093: LD_EXP 76
34097: PUSH
34098: LD_VAR 0 2
34102: ARRAY
34103: PPUSH
34104: LD_INT 25
34106: PUSH
34107: LD_INT 2
34109: PUSH
34110: EMPTY
34111: LIST
34112: LIST
34113: PUSH
34114: LD_INT 24
34116: PUSH
34117: LD_INT 750
34119: PUSH
34120: EMPTY
34121: LIST
34122: LIST
34123: PUSH
34124: EMPTY
34125: LIST
34126: LIST
34127: PPUSH
34128: CALL_OW 72
34132: ST_TO_ADDR
// if mc_ape [ i ] and UnitFilter ( mc_bases [ i ] , [ [ f_class , 2 ] , [ f_lives , 750 ] ] ) and tmp < 5 then
34133: LD_EXP 105
34137: PUSH
34138: LD_VAR 0 2
34142: ARRAY
34143: PUSH
34144: LD_EXP 76
34148: PUSH
34149: LD_VAR 0 2
34153: ARRAY
34154: PPUSH
34155: LD_INT 25
34157: PUSH
34158: LD_INT 2
34160: PUSH
34161: EMPTY
34162: LIST
34163: LIST
34164: PUSH
34165: LD_INT 24
34167: PUSH
34168: LD_INT 750
34170: PUSH
34171: EMPTY
34172: LIST
34173: LIST
34174: PUSH
34175: EMPTY
34176: LIST
34177: LIST
34178: PPUSH
34179: CALL_OW 72
34183: AND
34184: PUSH
34185: LD_VAR 0 5
34189: PUSH
34190: LD_INT 5
34192: LESS
34193: AND
34194: IFFALSE 34276
// begin for j in UnitFilter ( mc_bases [ i ] , [ [ f_class , 2 ] , [ f_lives , 750 ] ] ) do
34196: LD_ADDR_VAR 0 3
34200: PUSH
34201: LD_EXP 76
34205: PUSH
34206: LD_VAR 0 2
34210: ARRAY
34211: PPUSH
34212: LD_INT 25
34214: PUSH
34215: LD_INT 2
34217: PUSH
34218: EMPTY
34219: LIST
34220: LIST
34221: PUSH
34222: LD_INT 24
34224: PUSH
34225: LD_INT 750
34227: PUSH
34228: EMPTY
34229: LIST
34230: LIST
34231: PUSH
34232: EMPTY
34233: LIST
34234: LIST
34235: PPUSH
34236: CALL_OW 72
34240: PUSH
34241: FOR_IN
34242: IFFALSE 34274
// begin tmp := tmp union j ;
34244: LD_ADDR_VAR 0 5
34248: PUSH
34249: LD_VAR 0 5
34253: PUSH
34254: LD_VAR 0 3
34258: UNION
34259: ST_TO_ADDR
// if tmp >= 5 then
34260: LD_VAR 0 5
34264: PUSH
34265: LD_INT 5
34267: GREATEREQUAL
34268: IFFALSE 34272
// break ;
34270: GO 34274
// end ;
34272: GO 34241
34274: POP
34275: POP
// end ; if not tmp then
34276: LD_VAR 0 5
34280: NOT
34281: IFFALSE 34285
// continue ;
34283: GO 33497
// for j in tmp do
34285: LD_ADDR_VAR 0 3
34289: PUSH
34290: LD_VAR 0 5
34294: PUSH
34295: FOR_IN
34296: IFFALSE 34386
// if not GetTag ( j ) then
34298: LD_VAR 0 3
34302: PPUSH
34303: CALL_OW 110
34307: NOT
34308: IFFALSE 34384
// begin mc_crates_collector := ReplaceIn ( mc_crates_collector , [ i , mc_crates_collector [ i ] + 1 ] , j ) ;
34310: LD_ADDR_EXP 93
34314: PUSH
34315: LD_EXP 93
34319: PPUSH
34320: LD_VAR 0 2
34324: PUSH
34325: LD_EXP 93
34329: PUSH
34330: LD_VAR 0 2
34334: ARRAY
34335: PUSH
34336: LD_INT 1
34338: PLUS
34339: PUSH
34340: EMPTY
34341: LIST
34342: LIST
34343: PPUSH
34344: LD_VAR 0 3
34348: PPUSH
34349: CALL 57644 0 3
34353: ST_TO_ADDR
// SetTag ( j , 107 ) ;
34354: LD_VAR 0 3
34358: PPUSH
34359: LD_INT 107
34361: PPUSH
34362: CALL_OW 109
// if mc_crates_collector [ i ] >= 5 then
34366: LD_EXP 93
34370: PUSH
34371: LD_VAR 0 2
34375: ARRAY
34376: PUSH
34377: LD_INT 5
34379: GREATEREQUAL
34380: IFFALSE 34384
// break ;
34382: GO 34386
// end ;
34384: GO 34295
34386: POP
34387: POP
// end ; if mc_crates_collector [ i ] and target then
34388: LD_EXP 93
34392: PUSH
34393: LD_VAR 0 2
34397: ARRAY
34398: PUSH
34399: LD_VAR 0 6
34403: AND
34404: IFFALSE 34647
// begin if mc_crates_collector [ i ] < target [ 1 ] then
34406: LD_EXP 93
34410: PUSH
34411: LD_VAR 0 2
34415: ARRAY
34416: PUSH
34417: LD_VAR 0 6
34421: PUSH
34422: LD_INT 1
34424: ARRAY
34425: LESS
34426: IFFALSE 34446
// tmp := mc_crates_collector [ i ] else
34428: LD_ADDR_VAR 0 5
34432: PUSH
34433: LD_EXP 93
34437: PUSH
34438: LD_VAR 0 2
34442: ARRAY
34443: ST_TO_ADDR
34444: GO 34460
// tmp := target [ 1 ] ;
34446: LD_ADDR_VAR 0 5
34450: PUSH
34451: LD_VAR 0 6
34455: PUSH
34456: LD_INT 1
34458: ARRAY
34459: ST_TO_ADDR
// k := 0 ;
34460: LD_ADDR_VAR 0 4
34464: PUSH
34465: LD_INT 0
34467: ST_TO_ADDR
// for j in mc_crates_collector [ i ] do
34468: LD_ADDR_VAR 0 3
34472: PUSH
34473: LD_EXP 93
34477: PUSH
34478: LD_VAR 0 2
34482: ARRAY
34483: PUSH
34484: FOR_IN
34485: IFFALSE 34645
// begin k := k + 1 ;
34487: LD_ADDR_VAR 0 4
34491: PUSH
34492: LD_VAR 0 4
34496: PUSH
34497: LD_INT 1
34499: PLUS
34500: ST_TO_ADDR
// if k > tmp then
34501: LD_VAR 0 4
34505: PUSH
34506: LD_VAR 0 5
34510: GREATER
34511: IFFALSE 34515
// break ;
34513: GO 34645
// if not GetClass ( j ) in [ 2 , 16 ] then
34515: LD_VAR 0 3
34519: PPUSH
34520: CALL_OW 257
34524: PUSH
34525: LD_INT 2
34527: PUSH
34528: LD_INT 16
34530: PUSH
34531: EMPTY
34532: LIST
34533: LIST
34534: IN
34535: NOT
34536: IFFALSE 34589
// begin mc_crates_collector := Replace ( mc_crates_collector , i , mc_crates_collector [ i ] diff j ) ;
34538: LD_ADDR_EXP 93
34542: PUSH
34543: LD_EXP 93
34547: PPUSH
34548: LD_VAR 0 2
34552: PPUSH
34553: LD_EXP 93
34557: PUSH
34558: LD_VAR 0 2
34562: ARRAY
34563: PUSH
34564: LD_VAR 0 3
34568: DIFF
34569: PPUSH
34570: CALL_OW 1
34574: ST_TO_ADDR
// SetTag ( j , 0 ) ;
34575: LD_VAR 0 3
34579: PPUSH
34580: LD_INT 0
34582: PPUSH
34583: CALL_OW 109
// continue ;
34587: GO 34484
// end ; if IsInUnit ( j ) then
34589: LD_VAR 0 3
34593: PPUSH
34594: CALL_OW 310
34598: IFFALSE 34609
// ComExitBuilding ( j ) ;
34600: LD_VAR 0 3
34604: PPUSH
34605: CALL_OW 122
// wait ( 3 ) ;
34609: LD_INT 3
34611: PPUSH
34612: CALL_OW 67
// ComCollect ( j , target [ 2 ] , target [ 3 ] ) ;
34616: LD_VAR 0 3
34620: PPUSH
34621: LD_VAR 0 6
34625: PUSH
34626: LD_INT 2
34628: ARRAY
34629: PPUSH
34630: LD_VAR 0 6
34634: PUSH
34635: LD_INT 3
34637: ARRAY
34638: PPUSH
34639: CALL_OW 117
// end ;
34643: GO 34484
34645: POP
34646: POP
// end ; end else
34647: GO 35228
// begin for j in cargo do
34649: LD_ADDR_VAR 0 3
34653: PUSH
34654: LD_VAR 0 7
34658: PUSH
34659: FOR_IN
34660: IFFALSE 35226
// begin if GetTag ( j ) <> 0 then
34662: LD_VAR 0 3
34666: PPUSH
34667: CALL_OW 110
34671: PUSH
34672: LD_INT 0
34674: NONEQUAL
34675: IFFALSE 34679
// continue ;
34677: GO 34659
// if GetLives ( j ) < 1000 and not IsInArea ( j , mc_parking [ i ] ) then
34679: LD_VAR 0 3
34683: PPUSH
34684: CALL_OW 256
34688: PUSH
34689: LD_INT 1000
34691: LESS
34692: PUSH
34693: LD_VAR 0 3
34697: PPUSH
34698: LD_EXP 100
34702: PUSH
34703: LD_VAR 0 2
34707: ARRAY
34708: PPUSH
34709: CALL_OW 308
34713: NOT
34714: AND
34715: IFFALSE 34737
// ComMoveToArea ( j , mc_parking [ i ] ) ;
34717: LD_VAR 0 3
34721: PPUSH
34722: LD_EXP 100
34726: PUSH
34727: LD_VAR 0 2
34731: ARRAY
34732: PPUSH
34733: CALL_OW 113
// if GetLives ( j ) < 1000 and IsInArea ( j , mc_parking [ i ] ) then
34737: LD_VAR 0 3
34741: PPUSH
34742: CALL_OW 256
34746: PUSH
34747: LD_INT 1000
34749: LESS
34750: PUSH
34751: LD_VAR 0 3
34755: PPUSH
34756: LD_EXP 100
34760: PUSH
34761: LD_VAR 0 2
34765: ARRAY
34766: PPUSH
34767: CALL_OW 308
34771: AND
34772: IFFALSE 34776
// continue ;
34774: GO 34659
// if GetEngine ( j ) = engine_solar and GetFuel ( j ) < 15 then
34776: LD_VAR 0 3
34780: PPUSH
34781: CALL_OW 262
34785: PUSH
34786: LD_INT 2
34788: EQUAL
34789: PUSH
34790: LD_VAR 0 3
34794: PPUSH
34795: CALL_OW 261
34799: PUSH
34800: LD_INT 15
34802: LESS
34803: AND
34804: IFFALSE 34808
// continue ;
34806: GO 34659
// if GetEngine ( j ) = engine_combustion and GetFuel ( j ) < 10 then
34808: LD_VAR 0 3
34812: PPUSH
34813: CALL_OW 262
34817: PUSH
34818: LD_INT 1
34820: EQUAL
34821: PUSH
34822: LD_VAR 0 3
34826: PPUSH
34827: CALL_OW 261
34831: PUSH
34832: LD_INT 10
34834: LESS
34835: AND
34836: IFFALSE 35165
// begin depot := UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) ;
34838: LD_ADDR_VAR 0 8
34842: PUSH
34843: LD_EXP 76
34847: PUSH
34848: LD_VAR 0 2
34852: ARRAY
34853: PPUSH
34854: LD_INT 2
34856: PUSH
34857: LD_INT 30
34859: PUSH
34860: LD_INT 0
34862: PUSH
34863: EMPTY
34864: LIST
34865: LIST
34866: PUSH
34867: LD_INT 30
34869: PUSH
34870: LD_INT 1
34872: PUSH
34873: EMPTY
34874: LIST
34875: LIST
34876: PUSH
34877: EMPTY
34878: LIST
34879: LIST
34880: LIST
34881: PPUSH
34882: CALL_OW 72
34886: ST_TO_ADDR
// if not depot then
34887: LD_VAR 0 8
34891: NOT
34892: IFFALSE 34896
// continue ;
34894: GO 34659
// if GetDistUnits ( j , NearestUnitToUnit ( depot , j ) ) < 6 then
34896: LD_VAR 0 3
34900: PPUSH
34901: LD_VAR 0 8
34905: PPUSH
34906: LD_VAR 0 3
34910: PPUSH
34911: CALL_OW 74
34915: PPUSH
34916: CALL_OW 296
34920: PUSH
34921: LD_INT 6
34923: LESS
34924: IFFALSE 34940
// SetFuel ( j , 100 ) else
34926: LD_VAR 0 3
34930: PPUSH
34931: LD_INT 100
34933: PPUSH
34934: CALL_OW 240
34938: GO 35165
// if GetFuel ( j ) = 0 then
34940: LD_VAR 0 3
34944: PPUSH
34945: CALL_OW 261
34949: PUSH
34950: LD_INT 0
34952: EQUAL
34953: IFFALSE 35165
// begin mc_vehicles := Replace ( mc_vehicles , i , mc_vehicles [ i ] diff j ) ;
34955: LD_ADDR_EXP 95
34959: PUSH
34960: LD_EXP 95
34964: PPUSH
34965: LD_VAR 0 2
34969: PPUSH
34970: LD_EXP 95
34974: PUSH
34975: LD_VAR 0 2
34979: ARRAY
34980: PUSH
34981: LD_VAR 0 3
34985: DIFF
34986: PPUSH
34987: CALL_OW 1
34991: ST_TO_ADDR
// if GetControl ( j ) = control_manual then
34992: LD_VAR 0 3
34996: PPUSH
34997: CALL_OW 263
35001: PUSH
35002: LD_INT 1
35004: EQUAL
35005: IFFALSE 35021
// ComExitVehicle ( IsInUnit ( j ) ) ;
35007: LD_VAR 0 3
35011: PPUSH
35012: CALL_OW 310
35016: PPUSH
35017: CALL_OW 121
// if GetControl ( j ) = control_remote then
35021: LD_VAR 0 3
35025: PPUSH
35026: CALL_OW 263
35030: PUSH
35031: LD_INT 2
35033: EQUAL
35034: IFFALSE 35045
// ComUnlink ( j ) ;
35036: LD_VAR 0 3
35040: PPUSH
35041: CALL_OW 136
// fac := MC_GetBuildings ( i , b_factory ) ;
35045: LD_ADDR_VAR 0 9
35049: PUSH
35050: LD_VAR 0 2
35054: PPUSH
35055: LD_INT 3
35057: PPUSH
35058: CALL 44518 0 2
35062: ST_TO_ADDR
// if fac then
35063: LD_VAR 0 9
35067: IFFALSE 35163
// begin for k in fac do
35069: LD_ADDR_VAR 0 4
35073: PUSH
35074: LD_VAR 0 9
35078: PUSH
35079: FOR_IN
35080: IFFALSE 35161
// begin components := Produce ( fac , GetChassis ( j ) , GetEngine ( j ) , GetControl ( j ) , GetWeapon ( j ) ) ;
35082: LD_ADDR_VAR 0 10
35086: PUSH
35087: LD_VAR 0 9
35091: PPUSH
35092: LD_VAR 0 3
35096: PPUSH
35097: CALL_OW 265
35101: PPUSH
35102: LD_VAR 0 3
35106: PPUSH
35107: CALL_OW 262
35111: PPUSH
35112: LD_VAR 0 3
35116: PPUSH
35117: CALL_OW 263
35121: PPUSH
35122: LD_VAR 0 3
35126: PPUSH
35127: CALL_OW 264
35131: PPUSH
35132: CALL 55176 0 5
35136: ST_TO_ADDR
// if components then
35137: LD_VAR 0 10
35141: IFFALSE 35159
// begin MC_InsertProduceList ( i , components ) ;
35143: LD_VAR 0 2
35147: PPUSH
35148: LD_VAR 0 10
35152: PPUSH
35153: CALL 44063 0 2
// break ;
35157: GO 35161
// end ; end ;
35159: GO 35079
35161: POP
35162: POP
// end ; continue ;
35163: GO 34659
// end ; end ; if GetCargo ( j , mat_cans ) < 100 and not HasTask ( j ) then
35165: LD_VAR 0 3
35169: PPUSH
35170: LD_INT 1
35172: PPUSH
35173: CALL_OW 289
35177: PUSH
35178: LD_INT 100
35180: LESS
35181: PUSH
35182: LD_VAR 0 3
35186: PPUSH
35187: CALL_OW 314
35191: NOT
35192: AND
35193: IFFALSE 35222
// ComCollect ( j , target [ 2 ] , target [ 3 ] ) ;
35195: LD_VAR 0 3
35199: PPUSH
35200: LD_VAR 0 6
35204: PUSH
35205: LD_INT 2
35207: ARRAY
35208: PPUSH
35209: LD_VAR 0 6
35213: PUSH
35214: LD_INT 3
35216: ARRAY
35217: PPUSH
35218: CALL_OW 117
// break ;
35222: GO 35226
// end ;
35224: GO 34659
35226: POP
35227: POP
// end ; end ;
35228: GO 33497
35230: POP
35231: POP
// end ;
35232: LD_VAR 0 1
35236: RET
// export function MC_LinkRemoteControl ( ) ; var i , j , tmp ; begin
35237: LD_INT 0
35239: PPUSH
35240: PPUSH
35241: PPUSH
35242: PPUSH
// if not mc_bases then
35243: LD_EXP 76
35247: NOT
35248: IFFALSE 35252
// exit ;
35250: GO 35413
// for i = 1 to mc_bases do
35252: LD_ADDR_VAR 0 2
35256: PUSH
35257: DOUBLE
35258: LD_INT 1
35260: DEC
35261: ST_TO_ADDR
35262: LD_EXP 76
35266: PUSH
35267: FOR_TO
35268: IFFALSE 35411
// begin tmp := UnitFilter ( mc_vehicles [ i ] union mc_defender [ i ] , [ f_control , control_remote ] ) ;
35270: LD_ADDR_VAR 0 4
35274: PUSH
35275: LD_EXP 95
35279: PUSH
35280: LD_VAR 0 2
35284: ARRAY
35285: PUSH
35286: LD_EXP 98
35290: PUSH
35291: LD_VAR 0 2
35295: ARRAY
35296: UNION
35297: PPUSH
35298: LD_INT 33
35300: PUSH
35301: LD_INT 2
35303: PUSH
35304: EMPTY
35305: LIST
35306: LIST
35307: PPUSH
35308: CALL_OW 72
35312: ST_TO_ADDR
// if tmp then
35313: LD_VAR 0 4
35317: IFFALSE 35409
// for j in tmp do
35319: LD_ADDR_VAR 0 3
35323: PUSH
35324: LD_VAR 0 4
35328: PUSH
35329: FOR_IN
35330: IFFALSE 35407
// if not IsControledBy ( j ) and GetLives ( j ) >= 250 then
35332: LD_VAR 0 3
35336: PPUSH
35337: CALL_OW 312
35341: NOT
35342: PUSH
35343: LD_VAR 0 3
35347: PPUSH
35348: CALL_OW 256
35352: PUSH
35353: LD_INT 250
35355: GREATEREQUAL
35356: AND
35357: IFFALSE 35370
// Connect ( j ) else
35359: LD_VAR 0 3
35363: PPUSH
35364: CALL 60577 0 1
35368: GO 35405
// if GetLives ( j ) < 250 and IsControledBy ( j ) then
35370: LD_VAR 0 3
35374: PPUSH
35375: CALL_OW 256
35379: PUSH
35380: LD_INT 250
35382: LESS
35383: PUSH
35384: LD_VAR 0 3
35388: PPUSH
35389: CALL_OW 312
35393: AND
35394: IFFALSE 35405
// ComUnlink ( j ) ;
35396: LD_VAR 0 3
35400: PPUSH
35401: CALL_OW 136
35405: GO 35329
35407: POP
35408: POP
// end ;
35409: GO 35267
35411: POP
35412: POP
// end ;
35413: LD_VAR 0 1
35417: RET
// export function MC_ProduceVehicle ( ) ; var i , j , tmp , fac ; begin
35418: LD_INT 0
35420: PPUSH
35421: PPUSH
35422: PPUSH
35423: PPUSH
35424: PPUSH
// if not mc_bases then
35425: LD_EXP 76
35429: NOT
35430: IFFALSE 35434
// exit ;
35432: GO 35879
// for i = 1 to mc_bases do
35434: LD_ADDR_VAR 0 2
35438: PUSH
35439: DOUBLE
35440: LD_INT 1
35442: DEC
35443: ST_TO_ADDR
35444: LD_EXP 76
35448: PUSH
35449: FOR_TO
35450: IFFALSE 35877
// begin if not mc_produce [ i ] then
35452: LD_EXP 97
35456: PUSH
35457: LD_VAR 0 2
35461: ARRAY
35462: NOT
35463: IFFALSE 35467
// continue ;
35465: GO 35449
// fac := UnitFilter ( mc_bases [ i ] , [ f_btype , b_factory ] ) ;
35467: LD_ADDR_VAR 0 5
35471: PUSH
35472: LD_EXP 76
35476: PUSH
35477: LD_VAR 0 2
35481: ARRAY
35482: PPUSH
35483: LD_INT 30
35485: PUSH
35486: LD_INT 3
35488: PUSH
35489: EMPTY
35490: LIST
35491: LIST
35492: PPUSH
35493: CALL_OW 72
35497: ST_TO_ADDR
// if not fac then
35498: LD_VAR 0 5
35502: NOT
35503: IFFALSE 35507
// continue ;
35505: GO 35449
// for j in fac do
35507: LD_ADDR_VAR 0 3
35511: PUSH
35512: LD_VAR 0 5
35516: PUSH
35517: FOR_IN
35518: IFFALSE 35873
// begin if BuildingStatus ( j ) <> bs_idle or DangerAtRange ( j , 15 ) [ 4 ] then
35520: LD_VAR 0 3
35524: PPUSH
35525: CALL_OW 461
35529: PUSH
35530: LD_INT 2
35532: NONEQUAL
35533: PUSH
35534: LD_VAR 0 3
35538: PPUSH
35539: LD_INT 15
35541: PPUSH
35542: CALL 60237 0 2
35546: PUSH
35547: LD_INT 4
35549: ARRAY
35550: OR
35551: IFFALSE 35555
// continue ;
35553: GO 35517
// if CanBeConstructed ( j , mc_produce [ i ] [ 1 ] [ 1 ] , mc_produce [ i ] [ 1 ] [ 2 ] , mc_produce [ i ] [ 1 ] [ 3 ] , mc_produce [ i ] [ 1 ] [ 4 ] ) and VehicleCost ( j , [ mc_produce [ i ] [ 1 ] [ 1 ] , mc_produce [ i ] [ 1 ] [ 2 ] , mc_produce [ i ] [ 1 ] [ 3 ] , mc_produce [ i ] [ 1 ] [ 4 ] ] ) then
35555: LD_VAR 0 3
35559: PPUSH
35560: LD_EXP 97
35564: PUSH
35565: LD_VAR 0 2
35569: ARRAY
35570: PUSH
35571: LD_INT 1
35573: ARRAY
35574: PUSH
35575: LD_INT 1
35577: ARRAY
35578: PPUSH
35579: LD_EXP 97
35583: PUSH
35584: LD_VAR 0 2
35588: ARRAY
35589: PUSH
35590: LD_INT 1
35592: ARRAY
35593: PUSH
35594: LD_INT 2
35596: ARRAY
35597: PPUSH
35598: LD_EXP 97
35602: PUSH
35603: LD_VAR 0 2
35607: ARRAY
35608: PUSH
35609: LD_INT 1
35611: ARRAY
35612: PUSH
35613: LD_INT 3
35615: ARRAY
35616: PPUSH
35617: LD_EXP 97
35621: PUSH
35622: LD_VAR 0 2
35626: ARRAY
35627: PUSH
35628: LD_INT 1
35630: ARRAY
35631: PUSH
35632: LD_INT 4
35634: ARRAY
35635: PPUSH
35636: CALL_OW 448
35640: PUSH
35641: LD_VAR 0 3
35645: PPUSH
35646: LD_EXP 97
35650: PUSH
35651: LD_VAR 0 2
35655: ARRAY
35656: PUSH
35657: LD_INT 1
35659: ARRAY
35660: PUSH
35661: LD_INT 1
35663: ARRAY
35664: PUSH
35665: LD_EXP 97
35669: PUSH
35670: LD_VAR 0 2
35674: ARRAY
35675: PUSH
35676: LD_INT 1
35678: ARRAY
35679: PUSH
35680: LD_INT 2
35682: ARRAY
35683: PUSH
35684: LD_EXP 97
35688: PUSH
35689: LD_VAR 0 2
35693: ARRAY
35694: PUSH
35695: LD_INT 1
35697: ARRAY
35698: PUSH
35699: LD_INT 3
35701: ARRAY
35702: PUSH
35703: LD_EXP 97
35707: PUSH
35708: LD_VAR 0 2
35712: ARRAY
35713: PUSH
35714: LD_INT 1
35716: ARRAY
35717: PUSH
35718: LD_INT 4
35720: ARRAY
35721: PUSH
35722: EMPTY
35723: LIST
35724: LIST
35725: LIST
35726: LIST
35727: PPUSH
35728: CALL 63908 0 2
35732: AND
35733: IFFALSE 35871
// begin AddComConstruct ( j , mc_produce [ i ] [ 1 ] [ 1 ] , mc_produce [ i ] [ 1 ] [ 2 ] , mc_produce [ i ] [ 1 ] [ 3 ] , mc_produce [ i ] [ 1 ] [ 4 ] ) ;
35735: LD_VAR 0 3
35739: PPUSH
35740: LD_EXP 97
35744: PUSH
35745: LD_VAR 0 2
35749: ARRAY
35750: PUSH
35751: LD_INT 1
35753: ARRAY
35754: PUSH
35755: LD_INT 1
35757: ARRAY
35758: PPUSH
35759: LD_EXP 97
35763: PUSH
35764: LD_VAR 0 2
35768: ARRAY
35769: PUSH
35770: LD_INT 1
35772: ARRAY
35773: PUSH
35774: LD_INT 2
35776: ARRAY
35777: PPUSH
35778: LD_EXP 97
35782: PUSH
35783: LD_VAR 0 2
35787: ARRAY
35788: PUSH
35789: LD_INT 1
35791: ARRAY
35792: PUSH
35793: LD_INT 3
35795: ARRAY
35796: PPUSH
35797: LD_EXP 97
35801: PUSH
35802: LD_VAR 0 2
35806: ARRAY
35807: PUSH
35808: LD_INT 1
35810: ARRAY
35811: PUSH
35812: LD_INT 4
35814: ARRAY
35815: PPUSH
35816: CALL_OW 185
// tmp := Delete ( mc_produce [ i ] , 1 ) ;
35820: LD_ADDR_VAR 0 4
35824: PUSH
35825: LD_EXP 97
35829: PUSH
35830: LD_VAR 0 2
35834: ARRAY
35835: PPUSH
35836: LD_INT 1
35838: PPUSH
35839: CALL_OW 3
35843: ST_TO_ADDR
// mc_produce := Replace ( mc_produce , i , tmp ) ;
35844: LD_ADDR_EXP 97
35848: PUSH
35849: LD_EXP 97
35853: PPUSH
35854: LD_VAR 0 2
35858: PPUSH
35859: LD_VAR 0 4
35863: PPUSH
35864: CALL_OW 1
35868: ST_TO_ADDR
// break ;
35869: GO 35873
// end ; end ;
35871: GO 35517
35873: POP
35874: POP
// end ;
35875: GO 35449
35877: POP
35878: POP
// end ;
35879: LD_VAR 0 1
35883: RET
// export function MC_SendAttack ( ) ; var i , tmp ; begin
35884: LD_INT 0
35886: PPUSH
35887: PPUSH
35888: PPUSH
// if not mc_bases then
35889: LD_EXP 76
35893: NOT
35894: IFFALSE 35898
// exit ;
35896: GO 35987
// for i = 1 to mc_bases do
35898: LD_ADDR_VAR 0 2
35902: PUSH
35903: DOUBLE
35904: LD_INT 1
35906: DEC
35907: ST_TO_ADDR
35908: LD_EXP 76
35912: PUSH
35913: FOR_TO
35914: IFFALSE 35985
// begin if mc_attack [ i ] then
35916: LD_EXP 96
35920: PUSH
35921: LD_VAR 0 2
35925: ARRAY
35926: IFFALSE 35983
// begin tmp := mc_attack [ i ] [ 1 ] ;
35928: LD_ADDR_VAR 0 3
35932: PUSH
35933: LD_EXP 96
35937: PUSH
35938: LD_VAR 0 2
35942: ARRAY
35943: PUSH
35944: LD_INT 1
35946: ARRAY
35947: ST_TO_ADDR
// mc_attack := Replace ( mc_attack , i , [ ] ) ;
35948: LD_ADDR_EXP 96
35952: PUSH
35953: LD_EXP 96
35957: PPUSH
35958: LD_VAR 0 2
35962: PPUSH
35963: EMPTY
35964: PPUSH
35965: CALL_OW 1
35969: ST_TO_ADDR
// Attack ( tmp ) ;
35970: LD_VAR 0 3
35974: PPUSH
35975: CALL 86098 0 1
// exit ;
35979: POP
35980: POP
35981: GO 35987
// end ; end ;
35983: GO 35913
35985: POP
35986: POP
// end ;
35987: LD_VAR 0 1
35991: RET
// export function MC_Defend ( ) ; var i , j , tmp , t , x , class ; begin
35992: LD_INT 0
35994: PPUSH
35995: PPUSH
35996: PPUSH
35997: PPUSH
35998: PPUSH
35999: PPUSH
36000: PPUSH
// if not mc_bases then
36001: LD_EXP 76
36005: NOT
36006: IFFALSE 36010
// exit ;
36008: GO 36592
// for i = 1 to mc_bases do
36010: LD_ADDR_VAR 0 2
36014: PUSH
36015: DOUBLE
36016: LD_INT 1
36018: DEC
36019: ST_TO_ADDR
36020: LD_EXP 76
36024: PUSH
36025: FOR_TO
36026: IFFALSE 36590
// begin if not mc_bases [ i ] then
36028: LD_EXP 76
36032: PUSH
36033: LD_VAR 0 2
36037: ARRAY
36038: NOT
36039: IFFALSE 36043
// continue ;
36041: GO 36025
// class := AllowSpecClass ( mc_bases [ i ] [ 1 ] ) ;
36043: LD_ADDR_VAR 0 7
36047: PUSH
36048: LD_EXP 76
36052: PUSH
36053: LD_VAR 0 2
36057: ARRAY
36058: PUSH
36059: LD_INT 1
36061: ARRAY
36062: PPUSH
36063: CALL 54480 0 1
36067: ST_TO_ADDR
// mc_scan := Replace ( mc_scan , i , ScanBase ( GetSide ( mc_bases [ i ] [ 1 ] ) , mc_scan_area [ i ] ) ) ;
36068: LD_ADDR_EXP 99
36072: PUSH
36073: LD_EXP 99
36077: PPUSH
36078: LD_VAR 0 2
36082: PPUSH
36083: LD_EXP 76
36087: PUSH
36088: LD_VAR 0 2
36092: ARRAY
36093: PUSH
36094: LD_INT 1
36096: ARRAY
36097: PPUSH
36098: CALL_OW 255
36102: PPUSH
36103: LD_EXP 101
36107: PUSH
36108: LD_VAR 0 2
36112: ARRAY
36113: PPUSH
36114: CALL 52034 0 2
36118: PPUSH
36119: CALL_OW 1
36123: ST_TO_ADDR
// if not mc_scan [ i ] then
36124: LD_EXP 99
36128: PUSH
36129: LD_VAR 0 2
36133: ARRAY
36134: NOT
36135: IFFALSE 36290
// begin tmp := UnitFilter ( mc_bases [ i ] , [ f_or , [ f_class , 5 ] , [ f_class , 8 ] , [ f_class , 9 ] ] ) ;
36137: LD_ADDR_VAR 0 4
36141: PUSH
36142: LD_EXP 76
36146: PUSH
36147: LD_VAR 0 2
36151: ARRAY
36152: PPUSH
36153: LD_INT 2
36155: PUSH
36156: LD_INT 25
36158: PUSH
36159: LD_INT 5
36161: PUSH
36162: EMPTY
36163: LIST
36164: LIST
36165: PUSH
36166: LD_INT 25
36168: PUSH
36169: LD_INT 8
36171: PUSH
36172: EMPTY
36173: LIST
36174: LIST
36175: PUSH
36176: LD_INT 25
36178: PUSH
36179: LD_INT 9
36181: PUSH
36182: EMPTY
36183: LIST
36184: LIST
36185: PUSH
36186: EMPTY
36187: LIST
36188: LIST
36189: LIST
36190: LIST
36191: PPUSH
36192: CALL_OW 72
36196: ST_TO_ADDR
// if not tmp then
36197: LD_VAR 0 4
36201: NOT
36202: IFFALSE 36206
// continue ;
36204: GO 36025
// for j in tmp do
36206: LD_ADDR_VAR 0 3
36210: PUSH
36211: LD_VAR 0 4
36215: PUSH
36216: FOR_IN
36217: IFFALSE 36288
// if GetBType ( IsInUnit ( j ) ) = b_barracks and GetClass ( j ) = 1 and not MineOfUnit ( j ) and class then
36219: LD_VAR 0 3
36223: PPUSH
36224: CALL_OW 310
36228: PPUSH
36229: CALL_OW 266
36233: PUSH
36234: LD_INT 5
36236: EQUAL
36237: PUSH
36238: LD_VAR 0 3
36242: PPUSH
36243: CALL_OW 257
36247: PUSH
36248: LD_INT 1
36250: EQUAL
36251: AND
36252: PUSH
36253: LD_VAR 0 3
36257: PPUSH
36258: CALL_OW 459
36262: NOT
36263: AND
36264: PUSH
36265: LD_VAR 0 7
36269: AND
36270: IFFALSE 36286
// ComChangeProfession ( j , class ) ;
36272: LD_VAR 0 3
36276: PPUSH
36277: LD_VAR 0 7
36281: PPUSH
36282: CALL_OW 123
36286: GO 36216
36288: POP
36289: POP
// end ; if mc_scan [ i ] and not mc_defender [ i ] and not UnitFilter ( mc_bases [ i ] , [ f_btype , b_bunker ] ) and not UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_armoury ] , [ f_btype , b_barracks ] ] ) then
36290: LD_EXP 99
36294: PUSH
36295: LD_VAR 0 2
36299: ARRAY
36300: PUSH
36301: LD_EXP 98
36305: PUSH
36306: LD_VAR 0 2
36310: ARRAY
36311: NOT
36312: AND
36313: PUSH
36314: LD_EXP 76
36318: PUSH
36319: LD_VAR 0 2
36323: ARRAY
36324: PPUSH
36325: LD_INT 30
36327: PUSH
36328: LD_INT 32
36330: PUSH
36331: EMPTY
36332: LIST
36333: LIST
36334: PPUSH
36335: CALL_OW 72
36339: NOT
36340: AND
36341: PUSH
36342: LD_EXP 76
36346: PUSH
36347: LD_VAR 0 2
36351: ARRAY
36352: PPUSH
36353: LD_INT 2
36355: PUSH
36356: LD_INT 30
36358: PUSH
36359: LD_INT 4
36361: PUSH
36362: EMPTY
36363: LIST
36364: LIST
36365: PUSH
36366: LD_INT 30
36368: PUSH
36369: LD_INT 5
36371: PUSH
36372: EMPTY
36373: LIST
36374: LIST
36375: PUSH
36376: EMPTY
36377: LIST
36378: LIST
36379: LIST
36380: PPUSH
36381: CALL_OW 72
36385: NOT
36386: AND
36387: IFFALSE 36519
// begin tmp := UnitFilter ( mc_bases [ i ] , [ f_or , [ f_class , 1 ] , [ f_class , 5 ] , [ f_class , 8 ] , [ f_class , 9 ] ] ) ;
36389: LD_ADDR_VAR 0 4
36393: PUSH
36394: LD_EXP 76
36398: PUSH
36399: LD_VAR 0 2
36403: ARRAY
36404: PPUSH
36405: LD_INT 2
36407: PUSH
36408: LD_INT 25
36410: PUSH
36411: LD_INT 1
36413: PUSH
36414: EMPTY
36415: LIST
36416: LIST
36417: PUSH
36418: LD_INT 25
36420: PUSH
36421: LD_INT 5
36423: PUSH
36424: EMPTY
36425: LIST
36426: LIST
36427: PUSH
36428: LD_INT 25
36430: PUSH
36431: LD_INT 8
36433: PUSH
36434: EMPTY
36435: LIST
36436: LIST
36437: PUSH
36438: LD_INT 25
36440: PUSH
36441: LD_INT 9
36443: PUSH
36444: EMPTY
36445: LIST
36446: LIST
36447: PUSH
36448: EMPTY
36449: LIST
36450: LIST
36451: LIST
36452: LIST
36453: LIST
36454: PPUSH
36455: CALL_OW 72
36459: ST_TO_ADDR
// tmp := tmp diff FilterByTag ( tmp , 18 ) ;
36460: LD_ADDR_VAR 0 4
36464: PUSH
36465: LD_VAR 0 4
36469: PUSH
36470: LD_VAR 0 4
36474: PPUSH
36475: LD_INT 18
36477: PPUSH
36478: CALL 90907 0 2
36482: DIFF
36483: ST_TO_ADDR
// if tmp then
36484: LD_VAR 0 4
36488: IFFALSE 36519
// begin BasicDefend ( i , tmp , mc_scan_area [ i ] ) ;
36490: LD_VAR 0 2
36494: PPUSH
36495: LD_VAR 0 4
36499: PPUSH
36500: LD_EXP 101
36504: PUSH
36505: LD_VAR 0 2
36509: ARRAY
36510: PPUSH
36511: CALL 52069 0 3
// exit ;
36515: POP
36516: POP
36517: GO 36592
// end ; end ; if mc_scan [ i ] and mc_defender [ i ] then
36519: LD_EXP 99
36523: PUSH
36524: LD_VAR 0 2
36528: ARRAY
36529: PUSH
36530: LD_EXP 98
36534: PUSH
36535: LD_VAR 0 2
36539: ARRAY
36540: AND
36541: IFFALSE 36588
// begin tmp := mc_defender [ i ] ;
36543: LD_ADDR_VAR 0 4
36547: PUSH
36548: LD_EXP 98
36552: PUSH
36553: LD_VAR 0 2
36557: ARRAY
36558: ST_TO_ADDR
// Defend ( i , tmp , mc_scan [ i ] ) ;
36559: LD_VAR 0 2
36563: PPUSH
36564: LD_VAR 0 4
36568: PPUSH
36569: LD_EXP 99
36573: PUSH
36574: LD_VAR 0 2
36578: ARRAY
36579: PPUSH
36580: CALL 52630 0 3
// exit ;
36584: POP
36585: POP
36586: GO 36592
// end ; end ;
36588: GO 36025
36590: POP
36591: POP
// end ;
36592: LD_VAR 0 1
36596: RET
// export function MC_Research ( ) ; var i , j , side , t , tmp , x , sci , tmp2 , researching , idle_lab ; begin
36597: LD_INT 0
36599: PPUSH
36600: PPUSH
36601: PPUSH
36602: PPUSH
36603: PPUSH
36604: PPUSH
36605: PPUSH
36606: PPUSH
36607: PPUSH
36608: PPUSH
36609: PPUSH
// if not mc_bases then
36610: LD_EXP 76
36614: NOT
36615: IFFALSE 36619
// exit ;
36617: GO 37706
// for i = 1 to mc_bases do
36619: LD_ADDR_VAR 0 2
36623: PUSH
36624: DOUBLE
36625: LD_INT 1
36627: DEC
36628: ST_TO_ADDR
36629: LD_EXP 76
36633: PUSH
36634: FOR_TO
36635: IFFALSE 37704
// begin tmp := mc_lab [ i ] ;
36637: LD_ADDR_VAR 0 6
36641: PUSH
36642: LD_EXP 109
36646: PUSH
36647: LD_VAR 0 2
36651: ARRAY
36652: ST_TO_ADDR
// if not tmp then
36653: LD_VAR 0 6
36657: NOT
36658: IFFALSE 36662
// continue ;
36660: GO 36634
// idle_lab := 0 ;
36662: LD_ADDR_VAR 0 11
36666: PUSH
36667: LD_INT 0
36669: ST_TO_ADDR
// for j in tmp do
36670: LD_ADDR_VAR 0 3
36674: PUSH
36675: LD_VAR 0 6
36679: PUSH
36680: FOR_IN
36681: IFFALSE 37700
// begin researching := false ;
36683: LD_ADDR_VAR 0 10
36687: PUSH
36688: LD_INT 0
36690: ST_TO_ADDR
// side := GetSide ( j ) ;
36691: LD_ADDR_VAR 0 4
36695: PUSH
36696: LD_VAR 0 3
36700: PPUSH
36701: CALL_OW 255
36705: ST_TO_ADDR
// if not mc_tech [ side ] then
36706: LD_EXP 103
36710: PUSH
36711: LD_VAR 0 4
36715: ARRAY
36716: NOT
36717: IFFALSE 36721
// continue ;
36719: GO 36680
// if BuildingStatus ( j ) = bs_idle then
36721: LD_VAR 0 3
36725: PPUSH
36726: CALL_OW 461
36730: PUSH
36731: LD_INT 2
36733: EQUAL
36734: IFFALSE 36922
// begin if idle_lab and UnitsInside ( j ) < 6 then
36736: LD_VAR 0 11
36740: PUSH
36741: LD_VAR 0 3
36745: PPUSH
36746: CALL_OW 313
36750: PUSH
36751: LD_INT 6
36753: LESS
36754: AND
36755: IFFALSE 36826
// begin tmp2 := UnitsInside ( idle_lab ) ;
36757: LD_ADDR_VAR 0 9
36761: PUSH
36762: LD_VAR 0 11
36766: PPUSH
36767: CALL_OW 313
36771: ST_TO_ADDR
// if tmp2 then
36772: LD_VAR 0 9
36776: IFFALSE 36818
// for x in tmp2 do
36778: LD_ADDR_VAR 0 7
36782: PUSH
36783: LD_VAR 0 9
36787: PUSH
36788: FOR_IN
36789: IFFALSE 36816
// begin ComExitBuilding ( x ) ;
36791: LD_VAR 0 7
36795: PPUSH
36796: CALL_OW 122
// AddComEnterUnit ( x , j ) ;
36800: LD_VAR 0 7
36804: PPUSH
36805: LD_VAR 0 3
36809: PPUSH
36810: CALL_OW 180
// end ;
36814: GO 36788
36816: POP
36817: POP
// idle_lab := 0 ;
36818: LD_ADDR_VAR 0 11
36822: PUSH
36823: LD_INT 0
36825: ST_TO_ADDR
// end ; for t in mc_tech [ side ] do
36826: LD_ADDR_VAR 0 5
36830: PUSH
36831: LD_EXP 103
36835: PUSH
36836: LD_VAR 0 4
36840: ARRAY
36841: PUSH
36842: FOR_IN
36843: IFFALSE 36903
// if CanBeResearched ( j , t ) and TechCanBeResearch ( side , t ) then
36845: LD_VAR 0 3
36849: PPUSH
36850: LD_VAR 0 5
36854: PPUSH
36855: CALL_OW 430
36859: PUSH
36860: LD_VAR 0 4
36864: PPUSH
36865: LD_VAR 0 5
36869: PPUSH
36870: CALL 51139 0 2
36874: AND
36875: IFFALSE 36901
// begin researching := true ;
36877: LD_ADDR_VAR 0 10
36881: PUSH
36882: LD_INT 1
36884: ST_TO_ADDR
// ComResearch ( j , t ) ;
36885: LD_VAR 0 3
36889: PPUSH
36890: LD_VAR 0 5
36894: PPUSH
36895: CALL_OW 124
// break ;
36899: GO 36903
// end ;
36901: GO 36842
36903: POP
36904: POP
// if not researching then
36905: LD_VAR 0 10
36909: NOT
36910: IFFALSE 36922
// idle_lab := j ;
36912: LD_ADDR_VAR 0 11
36916: PUSH
36917: LD_VAR 0 3
36921: ST_TO_ADDR
// end ; if BuildingStatus ( j ) = bs_need_ape then
36922: LD_VAR 0 3
36926: PPUSH
36927: CALL_OW 461
36931: PUSH
36932: LD_INT 10
36934: EQUAL
36935: IFFALSE 37523
// begin if not mc_ape [ i ] and not mc_ape_in_lab [ i ] and mc_tech [ side ] > 1 then
36937: LD_EXP 105
36941: PUSH
36942: LD_VAR 0 2
36946: ARRAY
36947: NOT
36948: PUSH
36949: LD_EXP 106
36953: PUSH
36954: LD_VAR 0 2
36958: ARRAY
36959: NOT
36960: AND
36961: PUSH
36962: LD_EXP 103
36966: PUSH
36967: LD_VAR 0 4
36971: ARRAY
36972: PUSH
36973: LD_INT 1
36975: GREATER
36976: AND
36977: IFFALSE 37108
// begin ComCancel ( j ) ;
36979: LD_VAR 0 3
36983: PPUSH
36984: CALL_OW 127
// mc_tech := Replace ( mc_tech , side , Reindex ( mc_tech [ side ] , mc_tech [ side ] - 1 , mc_tech [ side ] , false ) ) ;
36988: LD_ADDR_EXP 103
36992: PUSH
36993: LD_EXP 103
36997: PPUSH
36998: LD_VAR 0 4
37002: PPUSH
37003: LD_EXP 103
37007: PUSH
37008: LD_VAR 0 4
37012: ARRAY
37013: PPUSH
37014: LD_EXP 103
37018: PUSH
37019: LD_VAR 0 4
37023: ARRAY
37024: PUSH
37025: LD_INT 1
37027: MINUS
37028: PPUSH
37029: LD_EXP 103
37033: PUSH
37034: LD_VAR 0 4
37038: ARRAY
37039: PPUSH
37040: LD_INT 0
37042: PPUSH
37043: CALL 57062 0 4
37047: PPUSH
37048: CALL_OW 1
37052: ST_TO_ADDR
// mc_tech := Replace ( mc_tech , side , Reindex ( mc_tech [ side ] , mc_tech [ side ] , 1 , false ) ) ;
37053: LD_ADDR_EXP 103
37057: PUSH
37058: LD_EXP 103
37062: PPUSH
37063: LD_VAR 0 4
37067: PPUSH
37068: LD_EXP 103
37072: PUSH
37073: LD_VAR 0 4
37077: ARRAY
37078: PPUSH
37079: LD_EXP 103
37083: PUSH
37084: LD_VAR 0 4
37088: ARRAY
37089: PPUSH
37090: LD_INT 1
37092: PPUSH
37093: LD_INT 0
37095: PPUSH
37096: CALL 57062 0 4
37100: PPUSH
37101: CALL_OW 1
37105: ST_TO_ADDR
// continue ;
37106: GO 36680
// end ; if mc_ape [ i ] and not mc_ape_in_lab [ i ] then
37108: LD_EXP 105
37112: PUSH
37113: LD_VAR 0 2
37117: ARRAY
37118: PUSH
37119: LD_EXP 106
37123: PUSH
37124: LD_VAR 0 2
37128: ARRAY
37129: NOT
37130: AND
37131: IFFALSE 37258
// begin mc_ape_in_lab := ReplaceIn ( mc_ape_in_lab , [ i , mc_ape_in_lab [ i ] + 1 ] , mc_ape [ i ] [ 1 ] ) ;
37133: LD_ADDR_EXP 106
37137: PUSH
37138: LD_EXP 106
37142: PPUSH
37143: LD_VAR 0 2
37147: PUSH
37148: LD_EXP 106
37152: PUSH
37153: LD_VAR 0 2
37157: ARRAY
37158: PUSH
37159: LD_INT 1
37161: PLUS
37162: PUSH
37163: EMPTY
37164: LIST
37165: LIST
37166: PPUSH
37167: LD_EXP 105
37171: PUSH
37172: LD_VAR 0 2
37176: ARRAY
37177: PUSH
37178: LD_INT 1
37180: ARRAY
37181: PPUSH
37182: CALL 57644 0 3
37186: ST_TO_ADDR
// SetTag ( mc_ape [ i ] [ 1 ] , 112 ) ;
37187: LD_EXP 105
37191: PUSH
37192: LD_VAR 0 2
37196: ARRAY
37197: PUSH
37198: LD_INT 1
37200: ARRAY
37201: PPUSH
37202: LD_INT 112
37204: PPUSH
37205: CALL_OW 109
// tmp2 := Delete ( mc_ape [ i ] , 1 ) ;
37209: LD_ADDR_VAR 0 9
37213: PUSH
37214: LD_EXP 105
37218: PUSH
37219: LD_VAR 0 2
37223: ARRAY
37224: PPUSH
37225: LD_INT 1
37227: PPUSH
37228: CALL_OW 3
37232: ST_TO_ADDR
// mc_ape := Replace ( mc_ape , i , tmp2 ) ;
37233: LD_ADDR_EXP 105
37237: PUSH
37238: LD_EXP 105
37242: PPUSH
37243: LD_VAR 0 2
37247: PPUSH
37248: LD_VAR 0 9
37252: PPUSH
37253: CALL_OW 1
37257: ST_TO_ADDR
// end ; if mc_ape [ i ] and mc_ape_in_lab [ i ] and not IsInUnit ( mc_ape_in_lab [ i ] [ 1 ] ) and UnitsInside ( j ) = 6 then
37258: LD_EXP 105
37262: PUSH
37263: LD_VAR 0 2
37267: ARRAY
37268: PUSH
37269: LD_EXP 106
37273: PUSH
37274: LD_VAR 0 2
37278: ARRAY
37279: AND
37280: PUSH
37281: LD_EXP 106
37285: PUSH
37286: LD_VAR 0 2
37290: ARRAY
37291: PUSH
37292: LD_INT 1
37294: ARRAY
37295: PPUSH
37296: CALL_OW 310
37300: NOT
37301: AND
37302: PUSH
37303: LD_VAR 0 3
37307: PPUSH
37308: CALL_OW 313
37312: PUSH
37313: LD_INT 6
37315: EQUAL
37316: AND
37317: IFFALSE 37373
// begin tmp2 := UnitsInside ( j ) ;
37319: LD_ADDR_VAR 0 9
37323: PUSH
37324: LD_VAR 0 3
37328: PPUSH
37329: CALL_OW 313
37333: ST_TO_ADDR
// if tmp2 = 6 then
37334: LD_VAR 0 9
37338: PUSH
37339: LD_INT 6
37341: EQUAL
37342: IFFALSE 37373
// begin SetTag ( tmp2 [ 1 ] , 112 ) ;
37344: LD_VAR 0 9
37348: PUSH
37349: LD_INT 1
37351: ARRAY
37352: PPUSH
37353: LD_INT 112
37355: PPUSH
37356: CALL_OW 109
// ComExitBuilding ( tmp2 [ 1 ] ) ;
37360: LD_VAR 0 9
37364: PUSH
37365: LD_INT 1
37367: ARRAY
37368: PPUSH
37369: CALL_OW 122
// end ; end ; if mc_ape_in_lab [ i ] and not HasTask ( mc_ape_in_lab [ i ] [ 1 ] ) and not IsInUnit ( mc_ape_in_lab [ i ] [ 1 ] ) then
37373: LD_EXP 106
37377: PUSH
37378: LD_VAR 0 2
37382: ARRAY
37383: PUSH
37384: LD_EXP 106
37388: PUSH
37389: LD_VAR 0 2
37393: ARRAY
37394: PUSH
37395: LD_INT 1
37397: ARRAY
37398: PPUSH
37399: CALL_OW 314
37403: NOT
37404: AND
37405: PUSH
37406: LD_EXP 106
37410: PUSH
37411: LD_VAR 0 2
37415: ARRAY
37416: PUSH
37417: LD_INT 1
37419: ARRAY
37420: PPUSH
37421: CALL_OW 310
37425: NOT
37426: AND
37427: IFFALSE 37453
// ComEnterUnit ( mc_ape_in_lab [ i ] [ 1 ] , j ) ;
37429: LD_EXP 106
37433: PUSH
37434: LD_VAR 0 2
37438: ARRAY
37439: PUSH
37440: LD_INT 1
37442: ARRAY
37443: PPUSH
37444: LD_VAR 0 3
37448: PPUSH
37449: CALL_OW 120
// if IsInUnit ( mc_ape_in_lab [ i ] [ 1 ] ) and BuildingStatus ( IsInUnit ( mc_ape_in_lab [ i ] [ 1 ] ) ) <> bs_working then
37453: LD_EXP 106
37457: PUSH
37458: LD_VAR 0 2
37462: ARRAY
37463: PUSH
37464: LD_INT 1
37466: ARRAY
37467: PPUSH
37468: CALL_OW 310
37472: PUSH
37473: LD_EXP 106
37477: PUSH
37478: LD_VAR 0 2
37482: ARRAY
37483: PUSH
37484: LD_INT 1
37486: ARRAY
37487: PPUSH
37488: CALL_OW 310
37492: PPUSH
37493: CALL_OW 461
37497: PUSH
37498: LD_INT 3
37500: NONEQUAL
37501: AND
37502: IFFALSE 37523
// ComExitBuilding ( mc_ape_in_lab [ i ] [ 1 ] ) ;
37504: LD_EXP 106
37508: PUSH
37509: LD_VAR 0 2
37513: ARRAY
37514: PUSH
37515: LD_INT 1
37517: ARRAY
37518: PPUSH
37519: CALL_OW 122
// end ; if BuildingStatus ( j ) = bs_need_people and tmp > 1 then
37523: LD_VAR 0 3
37527: PPUSH
37528: CALL_OW 461
37532: PUSH
37533: LD_INT 6
37535: EQUAL
37536: PUSH
37537: LD_VAR 0 6
37541: PUSH
37542: LD_INT 1
37544: GREATER
37545: AND
37546: IFFALSE 37698
// begin sci := [ ] ;
37548: LD_ADDR_VAR 0 8
37552: PUSH
37553: EMPTY
37554: ST_TO_ADDR
// for x in ( tmp diff j ) do
37555: LD_ADDR_VAR 0 7
37559: PUSH
37560: LD_VAR 0 6
37564: PUSH
37565: LD_VAR 0 3
37569: DIFF
37570: PUSH
37571: FOR_IN
37572: IFFALSE 37624
// begin if sci = 6 then
37574: LD_VAR 0 8
37578: PUSH
37579: LD_INT 6
37581: EQUAL
37582: IFFALSE 37586
// break ;
37584: GO 37624
// if BuildingStatus ( x ) = bs_idle then
37586: LD_VAR 0 7
37590: PPUSH
37591: CALL_OW 461
37595: PUSH
37596: LD_INT 2
37598: EQUAL
37599: IFFALSE 37622
// sci := sci ^ UnitsInside ( x ) ;
37601: LD_ADDR_VAR 0 8
37605: PUSH
37606: LD_VAR 0 8
37610: PUSH
37611: LD_VAR 0 7
37615: PPUSH
37616: CALL_OW 313
37620: ADD
37621: ST_TO_ADDR
// end ;
37622: GO 37571
37624: POP
37625: POP
// if not sci then
37626: LD_VAR 0 8
37630: NOT
37631: IFFALSE 37635
// continue ;
37633: GO 36680
// for x in sci do
37635: LD_ADDR_VAR 0 7
37639: PUSH
37640: LD_VAR 0 8
37644: PUSH
37645: FOR_IN
37646: IFFALSE 37696
// if IsInUnit ( x ) and not HasTask ( x ) then
37648: LD_VAR 0 7
37652: PPUSH
37653: CALL_OW 310
37657: PUSH
37658: LD_VAR 0 7
37662: PPUSH
37663: CALL_OW 314
37667: NOT
37668: AND
37669: IFFALSE 37694
// begin ComExitBuilding ( x ) ;
37671: LD_VAR 0 7
37675: PPUSH
37676: CALL_OW 122
// AddComEnterUnit ( x , j ) ;
37680: LD_VAR 0 7
37684: PPUSH
37685: LD_VAR 0 3
37689: PPUSH
37690: CALL_OW 180
// end ;
37694: GO 37645
37696: POP
37697: POP
// end ; end ;
37698: GO 36680
37700: POP
37701: POP
// end ;
37702: GO 36634
37704: POP
37705: POP
// end ;
37706: LD_VAR 0 1
37710: RET
// export function MC_MinesTrigger ( ) ; var i ; begin
37711: LD_INT 0
37713: PPUSH
37714: PPUSH
// if not mc_bases then
37715: LD_EXP 76
37719: NOT
37720: IFFALSE 37724
// exit ;
37722: GO 37805
// for i = 1 to mc_bases do
37724: LD_ADDR_VAR 0 2
37728: PUSH
37729: DOUBLE
37730: LD_INT 1
37732: DEC
37733: ST_TO_ADDR
37734: LD_EXP 76
37738: PUSH
37739: FOR_TO
37740: IFFALSE 37803
// if mc_mines [ i ] and mc_miners [ i ] then
37742: LD_EXP 89
37746: PUSH
37747: LD_VAR 0 2
37751: ARRAY
37752: PUSH
37753: LD_EXP 90
37757: PUSH
37758: LD_VAR 0 2
37762: ARRAY
37763: AND
37764: IFFALSE 37801
// DetonateMines ( GetSide ( mc_miners [ i ] [ 1 ] ) , mc_mines [ i ] ) ;
37766: LD_EXP 90
37770: PUSH
37771: LD_VAR 0 2
37775: ARRAY
37776: PUSH
37777: LD_INT 1
37779: ARRAY
37780: PPUSH
37781: CALL_OW 255
37785: PPUSH
37786: LD_EXP 89
37790: PUSH
37791: LD_VAR 0 2
37795: ARRAY
37796: PPUSH
37797: CALL 54633 0 2
37801: GO 37739
37803: POP
37804: POP
// end ;
37805: LD_VAR 0 1
37809: RET
// export function MC_RepairVehicle ( ) ; var i , j , k , side , fac , vehs , tmp ; begin
37810: LD_INT 0
37812: PPUSH
37813: PPUSH
37814: PPUSH
37815: PPUSH
37816: PPUSH
37817: PPUSH
37818: PPUSH
37819: PPUSH
// if not mc_bases or not mc_parking then
37820: LD_EXP 76
37824: NOT
37825: PUSH
37826: LD_EXP 100
37830: NOT
37831: OR
37832: IFFALSE 37836
// exit ;
37834: GO 38535
// for i = 1 to mc_bases do
37836: LD_ADDR_VAR 0 2
37840: PUSH
37841: DOUBLE
37842: LD_INT 1
37844: DEC
37845: ST_TO_ADDR
37846: LD_EXP 76
37850: PUSH
37851: FOR_TO
37852: IFFALSE 38533
// begin if not mc_bases [ i ] or not mc_parking [ i ] then
37854: LD_EXP 76
37858: PUSH
37859: LD_VAR 0 2
37863: ARRAY
37864: NOT
37865: PUSH
37866: LD_EXP 100
37870: PUSH
37871: LD_VAR 0 2
37875: ARRAY
37876: NOT
37877: OR
37878: IFFALSE 37882
// continue ;
37880: GO 37851
// side := GetSide ( mc_bases [ i ] [ 1 ] ) ;
37882: LD_ADDR_VAR 0 5
37886: PUSH
37887: LD_EXP 76
37891: PUSH
37892: LD_VAR 0 2
37896: ARRAY
37897: PUSH
37898: LD_INT 1
37900: ARRAY
37901: PPUSH
37902: CALL_OW 255
37906: ST_TO_ADDR
// fac := UnitFilter ( mc_bases [ i ] , [ f_btype , b_factory ] ) ;
37907: LD_ADDR_VAR 0 6
37911: PUSH
37912: LD_EXP 76
37916: PUSH
37917: LD_VAR 0 2
37921: ARRAY
37922: PPUSH
37923: LD_INT 30
37925: PUSH
37926: LD_INT 3
37928: PUSH
37929: EMPTY
37930: LIST
37931: LIST
37932: PPUSH
37933: CALL_OW 72
37937: ST_TO_ADDR
// if not fac then
37938: LD_VAR 0 6
37942: NOT
37943: IFFALSE 37994
// fac := UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) ;
37945: LD_ADDR_VAR 0 6
37949: PUSH
37950: LD_EXP 76
37954: PUSH
37955: LD_VAR 0 2
37959: ARRAY
37960: PPUSH
37961: LD_INT 2
37963: PUSH
37964: LD_INT 30
37966: PUSH
37967: LD_INT 0
37969: PUSH
37970: EMPTY
37971: LIST
37972: LIST
37973: PUSH
37974: LD_INT 30
37976: PUSH
37977: LD_INT 1
37979: PUSH
37980: EMPTY
37981: LIST
37982: LIST
37983: PUSH
37984: EMPTY
37985: LIST
37986: LIST
37987: LIST
37988: PPUSH
37989: CALL_OW 72
37993: ST_TO_ADDR
// if not fac then
37994: LD_VAR 0 6
37998: NOT
37999: IFFALSE 38003
// continue ;
38001: GO 37851
// vehs := FilterUnitsInArea ( mc_parking [ i ] , [ [ f_side , side ] , [ f_type , unit_vehicle ] , [ f_not , [ f_lives , 1000 ] ] ] ) ;
38003: LD_ADDR_VAR 0 7
38007: PUSH
38008: LD_EXP 100
38012: PUSH
38013: LD_VAR 0 2
38017: ARRAY
38018: PPUSH
38019: LD_INT 22
38021: PUSH
38022: LD_VAR 0 5
38026: PUSH
38027: EMPTY
38028: LIST
38029: LIST
38030: PUSH
38031: LD_INT 21
38033: PUSH
38034: LD_INT 2
38036: PUSH
38037: EMPTY
38038: LIST
38039: LIST
38040: PUSH
38041: LD_INT 3
38043: PUSH
38044: LD_INT 24
38046: PUSH
38047: LD_INT 1000
38049: PUSH
38050: EMPTY
38051: LIST
38052: LIST
38053: PUSH
38054: EMPTY
38055: LIST
38056: LIST
38057: PUSH
38058: EMPTY
38059: LIST
38060: LIST
38061: LIST
38062: PPUSH
38063: CALL_OW 70
38067: ST_TO_ADDR
// for j in fac do
38068: LD_ADDR_VAR 0 3
38072: PUSH
38073: LD_VAR 0 6
38077: PUSH
38078: FOR_IN
38079: IFFALSE 38160
// vehs := vehs union FilterAllUnits ( [ [ f_side , side ] , [ f_dist , j , 15 ] , [ f_type , unit_vehicle ] , [ f_not , [ f_lives , 1000 ] ] ] ) ;
38081: LD_ADDR_VAR 0 7
38085: PUSH
38086: LD_VAR 0 7
38090: PUSH
38091: LD_INT 22
38093: PUSH
38094: LD_VAR 0 5
38098: PUSH
38099: EMPTY
38100: LIST
38101: LIST
38102: PUSH
38103: LD_INT 91
38105: PUSH
38106: LD_VAR 0 3
38110: PUSH
38111: LD_INT 15
38113: PUSH
38114: EMPTY
38115: LIST
38116: LIST
38117: LIST
38118: PUSH
38119: LD_INT 21
38121: PUSH
38122: LD_INT 2
38124: PUSH
38125: EMPTY
38126: LIST
38127: LIST
38128: PUSH
38129: LD_INT 3
38131: PUSH
38132: LD_INT 24
38134: PUSH
38135: LD_INT 1000
38137: PUSH
38138: EMPTY
38139: LIST
38140: LIST
38141: PUSH
38142: EMPTY
38143: LIST
38144: LIST
38145: PUSH
38146: EMPTY
38147: LIST
38148: LIST
38149: LIST
38150: LIST
38151: PPUSH
38152: CALL_OW 69
38156: UNION
38157: ST_TO_ADDR
38158: GO 38078
38160: POP
38161: POP
// if not vehs then
38162: LD_VAR 0 7
38166: NOT
38167: IFFALSE 38193
// begin mc_repair_vehicle := Replace ( mc_repair_vehicle , i , [ ] ) ;
38169: LD_ADDR_EXP 88
38173: PUSH
38174: LD_EXP 88
38178: PPUSH
38179: LD_VAR 0 2
38183: PPUSH
38184: EMPTY
38185: PPUSH
38186: CALL_OW 1
38190: ST_TO_ADDR
// continue ;
38191: GO 37851
// end ; tmp := UnitFilter ( mc_bases [ i ] , [ f_btype , b_factory ] ) ;
38193: LD_ADDR_VAR 0 8
38197: PUSH
38198: LD_EXP 76
38202: PUSH
38203: LD_VAR 0 2
38207: ARRAY
38208: PPUSH
38209: LD_INT 30
38211: PUSH
38212: LD_INT 3
38214: PUSH
38215: EMPTY
38216: LIST
38217: LIST
38218: PPUSH
38219: CALL_OW 72
38223: ST_TO_ADDR
// if tmp then
38224: LD_VAR 0 8
38228: IFFALSE 38331
// begin for j in tmp do
38230: LD_ADDR_VAR 0 3
38234: PUSH
38235: LD_VAR 0 8
38239: PUSH
38240: FOR_IN
38241: IFFALSE 38329
// for k in UnitsInside ( j ) do
38243: LD_ADDR_VAR 0 4
38247: PUSH
38248: LD_VAR 0 3
38252: PPUSH
38253: CALL_OW 313
38257: PUSH
38258: FOR_IN
38259: IFFALSE 38325
// if k then
38261: LD_VAR 0 4
38265: IFFALSE 38323
// if not k in mc_repair_vehicle [ i ] then
38267: LD_VAR 0 4
38271: PUSH
38272: LD_EXP 88
38276: PUSH
38277: LD_VAR 0 2
38281: ARRAY
38282: IN
38283: NOT
38284: IFFALSE 38323
// mc_repair_vehicle := Replace ( mc_repair_vehicle , i , mc_repair_vehicle [ i ] union k ) ;
38286: LD_ADDR_EXP 88
38290: PUSH
38291: LD_EXP 88
38295: PPUSH
38296: LD_VAR 0 2
38300: PPUSH
38301: LD_EXP 88
38305: PUSH
38306: LD_VAR 0 2
38310: ARRAY
38311: PUSH
38312: LD_VAR 0 4
38316: UNION
38317: PPUSH
38318: CALL_OW 1
38322: ST_TO_ADDR
38323: GO 38258
38325: POP
38326: POP
38327: GO 38240
38329: POP
38330: POP
// end ; if not mc_repair_vehicle [ i ] then
38331: LD_EXP 88
38335: PUSH
38336: LD_VAR 0 2
38340: ARRAY
38341: NOT
38342: IFFALSE 38346
// continue ;
38344: GO 37851
// for j in mc_repair_vehicle [ i ] do
38346: LD_ADDR_VAR 0 3
38350: PUSH
38351: LD_EXP 88
38355: PUSH
38356: LD_VAR 0 2
38360: ARRAY
38361: PUSH
38362: FOR_IN
38363: IFFALSE 38529
// begin if GetClass ( j ) <> 3 then
38365: LD_VAR 0 3
38369: PPUSH
38370: CALL_OW 257
38374: PUSH
38375: LD_INT 3
38377: NONEQUAL
38378: IFFALSE 38419
// begin mc_repair_vehicle := Replace ( mc_repair_vehicle , i , mc_repair_vehicle [ i ] diff j ) ;
38380: LD_ADDR_EXP 88
38384: PUSH
38385: LD_EXP 88
38389: PPUSH
38390: LD_VAR 0 2
38394: PPUSH
38395: LD_EXP 88
38399: PUSH
38400: LD_VAR 0 2
38404: ARRAY
38405: PUSH
38406: LD_VAR 0 3
38410: DIFF
38411: PPUSH
38412: CALL_OW 1
38416: ST_TO_ADDR
// continue ;
38417: GO 38362
// end ; if not IsDrivenBy ( j ) and not j in mc_need_heal [ i ] [ 1 ] and not j in mc_need_heal [ i ] [ 2 ] then
38419: LD_VAR 0 3
38423: PPUSH
38424: CALL_OW 311
38428: NOT
38429: PUSH
38430: LD_VAR 0 3
38434: PUSH
38435: LD_EXP 79
38439: PUSH
38440: LD_VAR 0 2
38444: ARRAY
38445: PUSH
38446: LD_INT 1
38448: ARRAY
38449: IN
38450: NOT
38451: AND
38452: PUSH
38453: LD_VAR 0 3
38457: PUSH
38458: LD_EXP 79
38462: PUSH
38463: LD_VAR 0 2
38467: ARRAY
38468: PUSH
38469: LD_INT 2
38471: ARRAY
38472: IN
38473: NOT
38474: AND
38475: IFFALSE 38527
// begin if IsInUnit ( j ) then
38477: LD_VAR 0 3
38481: PPUSH
38482: CALL_OW 310
38486: IFFALSE 38497
// ComExitBuilding ( j ) ;
38488: LD_VAR 0 3
38492: PPUSH
38493: CALL_OW 122
// if not HasTask ( j ) then
38497: LD_VAR 0 3
38501: PPUSH
38502: CALL_OW 314
38506: NOT
38507: IFFALSE 38527
// AddComRepairVehicle ( j , vehs [ 1 ] ) ;
38509: LD_VAR 0 3
38513: PPUSH
38514: LD_VAR 0 7
38518: PUSH
38519: LD_INT 1
38521: ARRAY
38522: PPUSH
38523: CALL_OW 189
// end ; end ;
38527: GO 38362
38529: POP
38530: POP
// end ;
38531: GO 37851
38533: POP
38534: POP
// end ;
38535: LD_VAR 0 1
38539: RET
// export function MC_TameApe ( ) ; var i , j , x , y , ape , apes , tmp , dep , danger_at_area , side ; begin
38540: LD_INT 0
38542: PPUSH
38543: PPUSH
38544: PPUSH
38545: PPUSH
38546: PPUSH
38547: PPUSH
38548: PPUSH
38549: PPUSH
38550: PPUSH
38551: PPUSH
38552: PPUSH
// if not mc_bases then
38553: LD_EXP 76
38557: NOT
38558: IFFALSE 38562
// exit ;
38560: GO 39364
// for i = 1 to mc_bases do
38562: LD_ADDR_VAR 0 2
38566: PUSH
38567: DOUBLE
38568: LD_INT 1
38570: DEC
38571: ST_TO_ADDR
38572: LD_EXP 76
38576: PUSH
38577: FOR_TO
38578: IFFALSE 39362
// begin if not mc_can_tame [ i ] or mc_need_heal [ i ] [ 1 ] or mc_need_heal [ i ] [ 2 ] or not Researched ( mc_sides [ i ] , tech_apelang ) or mc_scan [ i ] then
38580: LD_EXP 104
38584: PUSH
38585: LD_VAR 0 2
38589: ARRAY
38590: NOT
38591: PUSH
38592: LD_EXP 79
38596: PUSH
38597: LD_VAR 0 2
38601: ARRAY
38602: PUSH
38603: LD_INT 1
38605: ARRAY
38606: OR
38607: PUSH
38608: LD_EXP 79
38612: PUSH
38613: LD_VAR 0 2
38617: ARRAY
38618: PUSH
38619: LD_INT 2
38621: ARRAY
38622: OR
38623: PUSH
38624: LD_EXP 102
38628: PUSH
38629: LD_VAR 0 2
38633: ARRAY
38634: PPUSH
38635: LD_INT 1
38637: PPUSH
38638: CALL_OW 325
38642: NOT
38643: OR
38644: PUSH
38645: LD_EXP 99
38649: PUSH
38650: LD_VAR 0 2
38654: ARRAY
38655: OR
38656: IFFALSE 38660
// continue ;
38658: GO 38577
// tmp := UnitFilter ( mc_bases [ i ] , [ [ f_class , 4 ] , [ f_ok ] , [ f_not , [ f_hastask ] ] ] ) diff mc_healers [ i ] ;
38660: LD_ADDR_VAR 0 8
38664: PUSH
38665: LD_EXP 76
38669: PUSH
38670: LD_VAR 0 2
38674: ARRAY
38675: PPUSH
38676: LD_INT 25
38678: PUSH
38679: LD_INT 4
38681: PUSH
38682: EMPTY
38683: LIST
38684: LIST
38685: PUSH
38686: LD_INT 50
38688: PUSH
38689: EMPTY
38690: LIST
38691: PUSH
38692: LD_INT 3
38694: PUSH
38695: LD_INT 60
38697: PUSH
38698: EMPTY
38699: LIST
38700: PUSH
38701: EMPTY
38702: LIST
38703: LIST
38704: PUSH
38705: EMPTY
38706: LIST
38707: LIST
38708: LIST
38709: PPUSH
38710: CALL_OW 72
38714: PUSH
38715: LD_EXP 80
38719: PUSH
38720: LD_VAR 0 2
38724: ARRAY
38725: DIFF
38726: ST_TO_ADDR
// dep := UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) ;
38727: LD_ADDR_VAR 0 9
38731: PUSH
38732: LD_EXP 76
38736: PUSH
38737: LD_VAR 0 2
38741: ARRAY
38742: PPUSH
38743: LD_INT 2
38745: PUSH
38746: LD_INT 30
38748: PUSH
38749: LD_INT 0
38751: PUSH
38752: EMPTY
38753: LIST
38754: LIST
38755: PUSH
38756: LD_INT 30
38758: PUSH
38759: LD_INT 1
38761: PUSH
38762: EMPTY
38763: LIST
38764: LIST
38765: PUSH
38766: EMPTY
38767: LIST
38768: LIST
38769: LIST
38770: PPUSH
38771: CALL_OW 72
38775: ST_TO_ADDR
// if not tmp or not dep then
38776: LD_VAR 0 8
38780: NOT
38781: PUSH
38782: LD_VAR 0 9
38786: NOT
38787: OR
38788: IFFALSE 38792
// continue ;
38790: GO 38577
// side := GetSide ( tmp [ 1 ] ) ;
38792: LD_ADDR_VAR 0 11
38796: PUSH
38797: LD_VAR 0 8
38801: PUSH
38802: LD_INT 1
38804: ARRAY
38805: PPUSH
38806: CALL_OW 255
38810: ST_TO_ADDR
// dep := dep [ 1 ] ;
38811: LD_ADDR_VAR 0 9
38815: PUSH
38816: LD_VAR 0 9
38820: PUSH
38821: LD_INT 1
38823: ARRAY
38824: ST_TO_ADDR
// apes := FilterUnitsInArea ( mc_can_tame [ i ] , [ [ f_side , 0 ] , [ f_class , class_apeman ] ] ) union FilterAllUnits ( [ [ f_side , 0 ] , [ f_class , class_apeman ] , [ f_dist , dep , 20 ] ] ) ;
38825: LD_ADDR_VAR 0 7
38829: PUSH
38830: LD_EXP 104
38834: PUSH
38835: LD_VAR 0 2
38839: ARRAY
38840: PPUSH
38841: LD_INT 22
38843: PUSH
38844: LD_INT 0
38846: PUSH
38847: EMPTY
38848: LIST
38849: LIST
38850: PUSH
38851: LD_INT 25
38853: PUSH
38854: LD_INT 12
38856: PUSH
38857: EMPTY
38858: LIST
38859: LIST
38860: PUSH
38861: EMPTY
38862: LIST
38863: LIST
38864: PPUSH
38865: CALL_OW 70
38869: PUSH
38870: LD_INT 22
38872: PUSH
38873: LD_INT 0
38875: PUSH
38876: EMPTY
38877: LIST
38878: LIST
38879: PUSH
38880: LD_INT 25
38882: PUSH
38883: LD_INT 12
38885: PUSH
38886: EMPTY
38887: LIST
38888: LIST
38889: PUSH
38890: LD_INT 91
38892: PUSH
38893: LD_VAR 0 9
38897: PUSH
38898: LD_INT 20
38900: PUSH
38901: EMPTY
38902: LIST
38903: LIST
38904: LIST
38905: PUSH
38906: EMPTY
38907: LIST
38908: LIST
38909: LIST
38910: PPUSH
38911: CALL_OW 69
38915: UNION
38916: ST_TO_ADDR
// danger_at_area := FilterUnitsInArea ( mc_can_tame [ i ] , [ f_enemy , side ] ) ;
38917: LD_ADDR_VAR 0 10
38921: PUSH
38922: LD_EXP 104
38926: PUSH
38927: LD_VAR 0 2
38931: ARRAY
38932: PPUSH
38933: LD_INT 81
38935: PUSH
38936: LD_VAR 0 11
38940: PUSH
38941: EMPTY
38942: LIST
38943: LIST
38944: PPUSH
38945: CALL_OW 70
38949: ST_TO_ADDR
// if not apes or danger_at_area then
38950: LD_VAR 0 7
38954: NOT
38955: PUSH
38956: LD_VAR 0 10
38960: OR
38961: IFFALSE 39011
// begin if mc_taming [ i ] then
38963: LD_EXP 107
38967: PUSH
38968: LD_VAR 0 2
38972: ARRAY
38973: IFFALSE 39009
// begin MC_Reset ( i , 121 ) ;
38975: LD_VAR 0 2
38979: PPUSH
38980: LD_INT 121
38982: PPUSH
38983: CALL 24446 0 2
// mc_taming := Replace ( mc_taming , i , [ ] ) ;
38987: LD_ADDR_EXP 107
38991: PUSH
38992: LD_EXP 107
38996: PPUSH
38997: LD_VAR 0 2
39001: PPUSH
39002: EMPTY
39003: PPUSH
39004: CALL_OW 1
39008: ST_TO_ADDR
// end ; continue ;
39009: GO 38577
// end ; for j in tmp do
39011: LD_ADDR_VAR 0 3
39015: PUSH
39016: LD_VAR 0 8
39020: PUSH
39021: FOR_IN
39022: IFFALSE 39358
// begin if not j in mc_taming [ i ] and mc_taming [ i ] < 3 then
39024: LD_VAR 0 3
39028: PUSH
39029: LD_EXP 107
39033: PUSH
39034: LD_VAR 0 2
39038: ARRAY
39039: IN
39040: NOT
39041: PUSH
39042: LD_EXP 107
39046: PUSH
39047: LD_VAR 0 2
39051: ARRAY
39052: PUSH
39053: LD_INT 3
39055: LESS
39056: AND
39057: IFFALSE 39115
// begin SetTag ( j , 121 ) ;
39059: LD_VAR 0 3
39063: PPUSH
39064: LD_INT 121
39066: PPUSH
39067: CALL_OW 109
// mc_taming := ReplaceIn ( mc_taming , [ i , mc_taming [ i ] + 1 ] , j ) ;
39071: LD_ADDR_EXP 107
39075: PUSH
39076: LD_EXP 107
39080: PPUSH
39081: LD_VAR 0 2
39085: PUSH
39086: LD_EXP 107
39090: PUSH
39091: LD_VAR 0 2
39095: ARRAY
39096: PUSH
39097: LD_INT 1
39099: PLUS
39100: PUSH
39101: EMPTY
39102: LIST
39103: LIST
39104: PPUSH
39105: LD_VAR 0 3
39109: PPUSH
39110: CALL 57644 0 3
39114: ST_TO_ADDR
// end ; if j in mc_taming [ i ] then
39115: LD_VAR 0 3
39119: PUSH
39120: LD_EXP 107
39124: PUSH
39125: LD_VAR 0 2
39129: ARRAY
39130: IN
39131: IFFALSE 39356
// begin if GetClass ( j ) <> 4 then
39133: LD_VAR 0 3
39137: PPUSH
39138: CALL_OW 257
39142: PUSH
39143: LD_INT 4
39145: NONEQUAL
39146: IFFALSE 39199
// begin mc_taming := Replace ( mc_taming , i , mc_taming [ i ] diff j ) ;
39148: LD_ADDR_EXP 107
39152: PUSH
39153: LD_EXP 107
39157: PPUSH
39158: LD_VAR 0 2
39162: PPUSH
39163: LD_EXP 107
39167: PUSH
39168: LD_VAR 0 2
39172: ARRAY
39173: PUSH
39174: LD_VAR 0 3
39178: DIFF
39179: PPUSH
39180: CALL_OW 1
39184: ST_TO_ADDR
// SetTag ( j , 0 ) ;
39185: LD_VAR 0 3
39189: PPUSH
39190: LD_INT 0
39192: PPUSH
39193: CALL_OW 109
// continue ;
39197: GO 39021
// end ; if IsInUnit ( j ) then
39199: LD_VAR 0 3
39203: PPUSH
39204: CALL_OW 310
39208: IFFALSE 39219
// ComExitBuilding ( j ) ;
39210: LD_VAR 0 3
39214: PPUSH
39215: CALL_OW 122
// ape := NearestUnitToUnit ( apes , j ) ;
39219: LD_ADDR_VAR 0 6
39223: PUSH
39224: LD_VAR 0 7
39228: PPUSH
39229: LD_VAR 0 3
39233: PPUSH
39234: CALL_OW 74
39238: ST_TO_ADDR
// if not ape then
39239: LD_VAR 0 6
39243: NOT
39244: IFFALSE 39248
// break ;
39246: GO 39358
// x := GetX ( ape ) ;
39248: LD_ADDR_VAR 0 4
39252: PUSH
39253: LD_VAR 0 6
39257: PPUSH
39258: CALL_OW 250
39262: ST_TO_ADDR
// y := GetY ( ape ) ;
39263: LD_ADDR_VAR 0 5
39267: PUSH
39268: LD_VAR 0 6
39272: PPUSH
39273: CALL_OW 251
39277: ST_TO_ADDR
// if not ValidHex ( x , y ) or DangerAtRangeXY ( side , x , y , 20 ) [ 4 ] then
39278: LD_VAR 0 4
39282: PPUSH
39283: LD_VAR 0 5
39287: PPUSH
39288: CALL_OW 488
39292: NOT
39293: PUSH
39294: LD_VAR 0 11
39298: PPUSH
39299: LD_VAR 0 4
39303: PPUSH
39304: LD_VAR 0 5
39308: PPUSH
39309: LD_INT 20
39311: PPUSH
39312: CALL 58540 0 4
39316: PUSH
39317: LD_INT 4
39319: ARRAY
39320: OR
39321: IFFALSE 39325
// break ;
39323: GO 39358
// if not HasTask ( j ) then
39325: LD_VAR 0 3
39329: PPUSH
39330: CALL_OW 314
39334: NOT
39335: IFFALSE 39356
// ComTameXY ( j , x , y ) ;
39337: LD_VAR 0 3
39341: PPUSH
39342: LD_VAR 0 4
39346: PPUSH
39347: LD_VAR 0 5
39351: PPUSH
39352: CALL_OW 131
// end ; end ;
39356: GO 39021
39358: POP
39359: POP
// end ;
39360: GO 38577
39362: POP
39363: POP
// end ;
39364: LD_VAR 0 1
39368: RET
// export function MC_ChangeApeClass ( ) ; var i , j , tmp , side , depot , selected , barracks ; begin
39369: LD_INT 0
39371: PPUSH
39372: PPUSH
39373: PPUSH
39374: PPUSH
39375: PPUSH
39376: PPUSH
39377: PPUSH
39378: PPUSH
// if not mc_bases then
39379: LD_EXP 76
39383: NOT
39384: IFFALSE 39388
// exit ;
39386: GO 40014
// for i = 1 to mc_bases do
39388: LD_ADDR_VAR 0 2
39392: PUSH
39393: DOUBLE
39394: LD_INT 1
39396: DEC
39397: ST_TO_ADDR
39398: LD_EXP 76
39402: PUSH
39403: FOR_TO
39404: IFFALSE 40012
// begin if not mc_ape [ i ] or not UnitFilter ( mc_ape [ i ] , [ f_class , 12 ] ) then
39406: LD_EXP 105
39410: PUSH
39411: LD_VAR 0 2
39415: ARRAY
39416: NOT
39417: PUSH
39418: LD_EXP 105
39422: PUSH
39423: LD_VAR 0 2
39427: ARRAY
39428: PPUSH
39429: LD_INT 25
39431: PUSH
39432: LD_INT 12
39434: PUSH
39435: EMPTY
39436: LIST
39437: LIST
39438: PPUSH
39439: CALL_OW 72
39443: NOT
39444: OR
39445: IFFALSE 39449
// continue ;
39447: GO 39403
// side := GetSide ( mc_ape [ i ] [ 1 ] ) ;
39449: LD_ADDR_VAR 0 5
39453: PUSH
39454: LD_EXP 105
39458: PUSH
39459: LD_VAR 0 2
39463: ARRAY
39464: PUSH
39465: LD_INT 1
39467: ARRAY
39468: PPUSH
39469: CALL_OW 255
39473: ST_TO_ADDR
// if Researched ( side , tech_apepsych ) then
39474: LD_VAR 0 5
39478: PPUSH
39479: LD_INT 2
39481: PPUSH
39482: CALL_OW 325
39486: IFFALSE 39739
// begin tmp := UnitFilter ( mc_ape [ i ] , [ f_class , 16 ] ) ;
39488: LD_ADDR_VAR 0 4
39492: PUSH
39493: LD_EXP 105
39497: PUSH
39498: LD_VAR 0 2
39502: ARRAY
39503: PPUSH
39504: LD_INT 25
39506: PUSH
39507: LD_INT 16
39509: PUSH
39510: EMPTY
39511: LIST
39512: LIST
39513: PPUSH
39514: CALL_OW 72
39518: ST_TO_ADDR
// if tmp < 6 then
39519: LD_VAR 0 4
39523: PUSH
39524: LD_INT 6
39526: LESS
39527: IFFALSE 39739
// begin depot := UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) ;
39529: LD_ADDR_VAR 0 6
39533: PUSH
39534: LD_EXP 76
39538: PUSH
39539: LD_VAR 0 2
39543: ARRAY
39544: PPUSH
39545: LD_INT 2
39547: PUSH
39548: LD_INT 30
39550: PUSH
39551: LD_INT 0
39553: PUSH
39554: EMPTY
39555: LIST
39556: LIST
39557: PUSH
39558: LD_INT 30
39560: PUSH
39561: LD_INT 1
39563: PUSH
39564: EMPTY
39565: LIST
39566: LIST
39567: PUSH
39568: EMPTY
39569: LIST
39570: LIST
39571: LIST
39572: PPUSH
39573: CALL_OW 72
39577: ST_TO_ADDR
// if depot then
39578: LD_VAR 0 6
39582: IFFALSE 39739
// begin selected := 0 ;
39584: LD_ADDR_VAR 0 7
39588: PUSH
39589: LD_INT 0
39591: ST_TO_ADDR
// for j in depot do
39592: LD_ADDR_VAR 0 3
39596: PUSH
39597: LD_VAR 0 6
39601: PUSH
39602: FOR_IN
39603: IFFALSE 39634
// begin if UnitsInside ( j ) < 6 then
39605: LD_VAR 0 3
39609: PPUSH
39610: CALL_OW 313
39614: PUSH
39615: LD_INT 6
39617: LESS
39618: IFFALSE 39632
// begin selected := j ;
39620: LD_ADDR_VAR 0 7
39624: PUSH
39625: LD_VAR 0 3
39629: ST_TO_ADDR
// break ;
39630: GO 39634
// end ; end ;
39632: GO 39602
39634: POP
39635: POP
// if selected then
39636: LD_VAR 0 7
39640: IFFALSE 39739
// begin for j in UnitFilter ( mc_ape [ i ] , [ f_class , 12 ] ) do
39642: LD_ADDR_VAR 0 3
39646: PUSH
39647: LD_EXP 105
39651: PUSH
39652: LD_VAR 0 2
39656: ARRAY
39657: PPUSH
39658: LD_INT 25
39660: PUSH
39661: LD_INT 12
39663: PUSH
39664: EMPTY
39665: LIST
39666: LIST
39667: PPUSH
39668: CALL_OW 72
39672: PUSH
39673: FOR_IN
39674: IFFALSE 39737
// if not HasTask ( j ) then
39676: LD_VAR 0 3
39680: PPUSH
39681: CALL_OW 314
39685: NOT
39686: IFFALSE 39735
// begin if not IsInUnit ( j ) then
39688: LD_VAR 0 3
39692: PPUSH
39693: CALL_OW 310
39697: NOT
39698: IFFALSE 39714
// ComEnterUnit ( j , selected ) ;
39700: LD_VAR 0 3
39704: PPUSH
39705: LD_VAR 0 7
39709: PPUSH
39710: CALL_OW 120
// AddComChangeProfession ( j , 16 ) ;
39714: LD_VAR 0 3
39718: PPUSH
39719: LD_INT 16
39721: PPUSH
39722: CALL_OW 183
// AddComExitBuilding ( j ) ;
39726: LD_VAR 0 3
39730: PPUSH
39731: CALL_OW 182
// end ;
39735: GO 39673
39737: POP
39738: POP
// end ; end ; end ; end ; if Researched ( side , tech_apeagres ) then
39739: LD_VAR 0 5
39743: PPUSH
39744: LD_INT 11
39746: PPUSH
39747: CALL_OW 325
39751: IFFALSE 40010
// begin tmp := UnitFilter ( mc_ape [ i ] , [ f_class , 16 ] ) ;
39753: LD_ADDR_VAR 0 4
39757: PUSH
39758: LD_EXP 105
39762: PUSH
39763: LD_VAR 0 2
39767: ARRAY
39768: PPUSH
39769: LD_INT 25
39771: PUSH
39772: LD_INT 16
39774: PUSH
39775: EMPTY
39776: LIST
39777: LIST
39778: PPUSH
39779: CALL_OW 72
39783: ST_TO_ADDR
// if tmp >= 6 or not Researched ( side , tech_apepsych ) then
39784: LD_VAR 0 4
39788: PUSH
39789: LD_INT 6
39791: GREATEREQUAL
39792: PUSH
39793: LD_VAR 0 5
39797: PPUSH
39798: LD_INT 2
39800: PPUSH
39801: CALL_OW 325
39805: NOT
39806: OR
39807: IFFALSE 40010
// begin barracks := UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_armoury ] , [ f_btype , b_barracks ] ] ) ;
39809: LD_ADDR_VAR 0 8
39813: PUSH
39814: LD_EXP 76
39818: PUSH
39819: LD_VAR 0 2
39823: ARRAY
39824: PPUSH
39825: LD_INT 2
39827: PUSH
39828: LD_INT 30
39830: PUSH
39831: LD_INT 4
39833: PUSH
39834: EMPTY
39835: LIST
39836: LIST
39837: PUSH
39838: LD_INT 30
39840: PUSH
39841: LD_INT 5
39843: PUSH
39844: EMPTY
39845: LIST
39846: LIST
39847: PUSH
39848: EMPTY
39849: LIST
39850: LIST
39851: LIST
39852: PPUSH
39853: CALL_OW 72
39857: ST_TO_ADDR
// if barracks then
39858: LD_VAR 0 8
39862: IFFALSE 40010
// begin selected := 0 ;
39864: LD_ADDR_VAR 0 7
39868: PUSH
39869: LD_INT 0
39871: ST_TO_ADDR
// for j in barracks do
39872: LD_ADDR_VAR 0 3
39876: PUSH
39877: LD_VAR 0 8
39881: PUSH
39882: FOR_IN
39883: IFFALSE 39914
// begin if UnitsInside ( j ) < 6 then
39885: LD_VAR 0 3
39889: PPUSH
39890: CALL_OW 313
39894: PUSH
39895: LD_INT 6
39897: LESS
39898: IFFALSE 39912
// begin selected := j ;
39900: LD_ADDR_VAR 0 7
39904: PUSH
39905: LD_VAR 0 3
39909: ST_TO_ADDR
// break ;
39910: GO 39914
// end ; end ;
39912: GO 39882
39914: POP
39915: POP
// if selected then
39916: LD_VAR 0 7
39920: IFFALSE 40010
// begin for j in UnitFilter ( mc_ape [ i ] , [ f_class , 12 ] ) do
39922: LD_ADDR_VAR 0 3
39926: PUSH
39927: LD_EXP 105
39931: PUSH
39932: LD_VAR 0 2
39936: ARRAY
39937: PPUSH
39938: LD_INT 25
39940: PUSH
39941: LD_INT 12
39943: PUSH
39944: EMPTY
39945: LIST
39946: LIST
39947: PPUSH
39948: CALL_OW 72
39952: PUSH
39953: FOR_IN
39954: IFFALSE 40008
// if not IsInUnit ( j ) and not HasTask ( j ) then
39956: LD_VAR 0 3
39960: PPUSH
39961: CALL_OW 310
39965: NOT
39966: PUSH
39967: LD_VAR 0 3
39971: PPUSH
39972: CALL_OW 314
39976: NOT
39977: AND
39978: IFFALSE 40006
// begin ComEnterUnit ( j , selected ) ;
39980: LD_VAR 0 3
39984: PPUSH
39985: LD_VAR 0 7
39989: PPUSH
39990: CALL_OW 120
// AddComChangeProfession ( j , 15 ) ;
39994: LD_VAR 0 3
39998: PPUSH
39999: LD_INT 15
40001: PPUSH
40002: CALL_OW 183
// end ;
40006: GO 39953
40008: POP
40009: POP
// end ; end ; end ; end ; end ;
40010: GO 39403
40012: POP
40013: POP
// end ;
40014: LD_VAR 0 1
40018: RET
// export function MC_Bazooka ( ) ; var i , j , tmp ; begin
40019: LD_INT 0
40021: PPUSH
40022: PPUSH
40023: PPUSH
40024: PPUSH
// if not mc_bases then
40025: LD_EXP 76
40029: NOT
40030: IFFALSE 40034
// exit ;
40032: GO 40212
// for i = 1 to mc_bases do
40034: LD_ADDR_VAR 0 2
40038: PUSH
40039: DOUBLE
40040: LD_INT 1
40042: DEC
40043: ST_TO_ADDR
40044: LD_EXP 76
40048: PUSH
40049: FOR_TO
40050: IFFALSE 40210
// begin tmp := UnitFilter ( mc_bases [ i ] , [ f_class , class_bazooker ] ) ;
40052: LD_ADDR_VAR 0 4
40056: PUSH
40057: LD_EXP 76
40061: PUSH
40062: LD_VAR 0 2
40066: ARRAY
40067: PPUSH
40068: LD_INT 25
40070: PUSH
40071: LD_INT 9
40073: PUSH
40074: EMPTY
40075: LIST
40076: LIST
40077: PPUSH
40078: CALL_OW 72
40082: ST_TO_ADDR
// if not tmp then
40083: LD_VAR 0 4
40087: NOT
40088: IFFALSE 40092
// continue ;
40090: GO 40049
// if not Researched ( mc_sides [ i ] , tech_spacanom ) and not Researched ( mc_sides [ i ] , tech_taurad ) then
40092: LD_EXP 102
40096: PUSH
40097: LD_VAR 0 2
40101: ARRAY
40102: PPUSH
40103: LD_INT 29
40105: PPUSH
40106: CALL_OW 325
40110: NOT
40111: PUSH
40112: LD_EXP 102
40116: PUSH
40117: LD_VAR 0 2
40121: ARRAY
40122: PPUSH
40123: LD_INT 28
40125: PPUSH
40126: CALL_OW 325
40130: NOT
40131: AND
40132: IFFALSE 40136
// continue ;
40134: GO 40049
// for j in tmp do
40136: LD_ADDR_VAR 0 3
40140: PUSH
40141: LD_VAR 0 4
40145: PUSH
40146: FOR_IN
40147: IFFALSE 40206
// if not j in mc_need_heal [ i ] [ 1 ] and not j in mc_need_heal [ i ] [ 2 ] then
40149: LD_VAR 0 3
40153: PUSH
40154: LD_EXP 79
40158: PUSH
40159: LD_VAR 0 2
40163: ARRAY
40164: PUSH
40165: LD_INT 1
40167: ARRAY
40168: IN
40169: NOT
40170: PUSH
40171: LD_VAR 0 3
40175: PUSH
40176: LD_EXP 79
40180: PUSH
40181: LD_VAR 0 2
40185: ARRAY
40186: PUSH
40187: LD_INT 2
40189: ARRAY
40190: IN
40191: NOT
40192: AND
40193: IFFALSE 40204
// ComSpaceTimeShoot ( j ) ;
40195: LD_VAR 0 3
40199: PPUSH
40200: CALL 51230 0 1
40204: GO 40146
40206: POP
40207: POP
// end ;
40208: GO 40049
40210: POP
40211: POP
// end ;
40212: LD_VAR 0 1
40216: RET
// export function MC_TeleportExit ( ) ; var i , j , x , y , save_point , tmp , teleports , sci ; begin
40217: LD_INT 0
40219: PPUSH
40220: PPUSH
40221: PPUSH
40222: PPUSH
40223: PPUSH
40224: PPUSH
40225: PPUSH
40226: PPUSH
40227: PPUSH
// if not mc_bases then
40228: LD_EXP 76
40232: NOT
40233: IFFALSE 40237
// exit ;
40235: GO 40859
// for i = 1 to mc_bases do
40237: LD_ADDR_VAR 0 2
40241: PUSH
40242: DOUBLE
40243: LD_INT 1
40245: DEC
40246: ST_TO_ADDR
40247: LD_EXP 76
40251: PUSH
40252: FOR_TO
40253: IFFALSE 40857
// begin if not mc_teleport_exit [ i ] or GetTech ( tech_targTeleport , mc_sides [ i ] ) <> state_researched then
40255: LD_EXP 111
40259: PUSH
40260: LD_VAR 0 2
40264: ARRAY
40265: NOT
40266: PUSH
40267: LD_INT 38
40269: PPUSH
40270: LD_EXP 102
40274: PUSH
40275: LD_VAR 0 2
40279: ARRAY
40280: PPUSH
40281: CALL_OW 321
40285: PUSH
40286: LD_INT 2
40288: NONEQUAL
40289: OR
40290: IFFALSE 40294
// continue ;
40292: GO 40252
// teleports := UnitFilter ( mc_bases [ i ] , [ f_btype , b_teleport ] ) ;
40294: LD_ADDR_VAR 0 8
40298: PUSH
40299: LD_EXP 76
40303: PUSH
40304: LD_VAR 0 2
40308: ARRAY
40309: PPUSH
40310: LD_INT 30
40312: PUSH
40313: LD_INT 34
40315: PUSH
40316: EMPTY
40317: LIST
40318: LIST
40319: PPUSH
40320: CALL_OW 72
40324: ST_TO_ADDR
// sci := FilterByTag ( UnitFilter ( mc_bases [ i ] , [ f_class , 4 ] ) , 0 ) ;
40325: LD_ADDR_VAR 0 9
40329: PUSH
40330: LD_EXP 76
40334: PUSH
40335: LD_VAR 0 2
40339: ARRAY
40340: PPUSH
40341: LD_INT 25
40343: PUSH
40344: LD_INT 4
40346: PUSH
40347: EMPTY
40348: LIST
40349: LIST
40350: PPUSH
40351: CALL_OW 72
40355: PPUSH
40356: LD_INT 0
40358: PPUSH
40359: CALL 90907 0 2
40363: ST_TO_ADDR
// if not sci or not teleports or FilterByTag ( mc_bases [ i ] , 124 ) then
40364: LD_VAR 0 9
40368: NOT
40369: PUSH
40370: LD_VAR 0 8
40374: NOT
40375: OR
40376: PUSH
40377: LD_EXP 76
40381: PUSH
40382: LD_VAR 0 2
40386: ARRAY
40387: PPUSH
40388: LD_INT 124
40390: PPUSH
40391: CALL 90907 0 2
40395: OR
40396: IFFALSE 40400
// continue ;
40398: GO 40252
// if mc_teleport_exit_set [ i ] < mc_teleport_exit [ i ] and mc_teleport_exit_set [ i ] < teleports then
40400: LD_EXP 112
40404: PUSH
40405: LD_VAR 0 2
40409: ARRAY
40410: PUSH
40411: LD_EXP 111
40415: PUSH
40416: LD_VAR 0 2
40420: ARRAY
40421: LESS
40422: PUSH
40423: LD_EXP 112
40427: PUSH
40428: LD_VAR 0 2
40432: ARRAY
40433: PUSH
40434: LD_VAR 0 8
40438: LESS
40439: AND
40440: IFFALSE 40855
// begin tmp := sci [ 1 ] ;
40442: LD_ADDR_VAR 0 7
40446: PUSH
40447: LD_VAR 0 9
40451: PUSH
40452: LD_INT 1
40454: ARRAY
40455: ST_TO_ADDR
// SetTag ( tmp , 124 ) ;
40456: LD_VAR 0 7
40460: PPUSH
40461: LD_INT 124
40463: PPUSH
40464: CALL_OW 109
// for j = mc_teleport_exit [ i ] downto mc_teleport_exit [ i ] do
40468: LD_ADDR_VAR 0 3
40472: PUSH
40473: DOUBLE
40474: LD_EXP 111
40478: PUSH
40479: LD_VAR 0 2
40483: ARRAY
40484: INC
40485: ST_TO_ADDR
40486: LD_EXP 111
40490: PUSH
40491: LD_VAR 0 2
40495: ARRAY
40496: PUSH
40497: FOR_DOWNTO
40498: IFFALSE 40841
// begin if IsInUnit ( tmp ) then
40500: LD_VAR 0 7
40504: PPUSH
40505: CALL_OW 310
40509: IFFALSE 40520
// ComExitBuilding ( tmp ) ;
40511: LD_VAR 0 7
40515: PPUSH
40516: CALL_OW 122
// repeat wait ( 0 0$1 ) ;
40520: LD_INT 35
40522: PPUSH
40523: CALL_OW 67
// until not IsInUnit ( tmp ) and not HasTask ( tmp ) ;
40527: LD_VAR 0 7
40531: PPUSH
40532: CALL_OW 310
40536: NOT
40537: PUSH
40538: LD_VAR 0 7
40542: PPUSH
40543: CALL_OW 314
40547: NOT
40548: AND
40549: IFFALSE 40520
// save_point := [ GetX ( tmp ) , GetY ( tmp ) ] ;
40551: LD_ADDR_VAR 0 6
40555: PUSH
40556: LD_VAR 0 7
40560: PPUSH
40561: CALL_OW 250
40565: PUSH
40566: LD_VAR 0 7
40570: PPUSH
40571: CALL_OW 251
40575: PUSH
40576: EMPTY
40577: LIST
40578: LIST
40579: ST_TO_ADDR
// repeat wait ( 0 0$1 ) ;
40580: LD_INT 35
40582: PPUSH
40583: CALL_OW 67
// x := mc_teleport_exit [ i ] [ j ] [ 1 ] ;
40587: LD_ADDR_VAR 0 4
40591: PUSH
40592: LD_EXP 111
40596: PUSH
40597: LD_VAR 0 2
40601: ARRAY
40602: PUSH
40603: LD_VAR 0 3
40607: ARRAY
40608: PUSH
40609: LD_INT 1
40611: ARRAY
40612: ST_TO_ADDR
// y := mc_teleport_exit [ i ] [ j ] [ 2 ] ;
40613: LD_ADDR_VAR 0 5
40617: PUSH
40618: LD_EXP 111
40622: PUSH
40623: LD_VAR 0 2
40627: ARRAY
40628: PUSH
40629: LD_VAR 0 3
40633: ARRAY
40634: PUSH
40635: LD_INT 2
40637: ARRAY
40638: ST_TO_ADDR
// if DangerAtRange ( tmp , 10 ) [ 4 ] then
40639: LD_VAR 0 7
40643: PPUSH
40644: LD_INT 10
40646: PPUSH
40647: CALL 60237 0 2
40651: PUSH
40652: LD_INT 4
40654: ARRAY
40655: IFFALSE 40693
// begin ComMoveXY ( tmp , save_point [ 1 ] , save_point [ 2 ] ) ;
40657: LD_VAR 0 7
40661: PPUSH
40662: LD_VAR 0 6
40666: PUSH
40667: LD_INT 1
40669: ARRAY
40670: PPUSH
40671: LD_VAR 0 6
40675: PUSH
40676: LD_INT 2
40678: ARRAY
40679: PPUSH
40680: CALL_OW 111
// wait ( 0 0$10 ) ;
40684: LD_INT 350
40686: PPUSH
40687: CALL_OW 67
// end else
40691: GO 40719
// begin ComMoveXY ( tmp , x , y ) ;
40693: LD_VAR 0 7
40697: PPUSH
40698: LD_VAR 0 4
40702: PPUSH
40703: LD_VAR 0 5
40707: PPUSH
40708: CALL_OW 111
// wait ( 0 0$3 ) ;
40712: LD_INT 105
40714: PPUSH
40715: CALL_OW 67
// end ; until IsAt ( tmp , x , y ) ;
40719: LD_VAR 0 7
40723: PPUSH
40724: LD_VAR 0 4
40728: PPUSH
40729: LD_VAR 0 5
40733: PPUSH
40734: CALL_OW 307
40738: IFFALSE 40580
// ComTeleportExit ( tmp , x , y , teleports [ j ] ) ;
40740: LD_VAR 0 7
40744: PPUSH
40745: LD_VAR 0 4
40749: PPUSH
40750: LD_VAR 0 5
40754: PPUSH
40755: LD_VAR 0 8
40759: PUSH
40760: LD_VAR 0 3
40764: ARRAY
40765: PPUSH
40766: CALL_OW 156
// repeat wait ( 0 0$1 ) ;
40770: LD_INT 35
40772: PPUSH
40773: CALL_OW 67
// until not HasTask ( tmp ) ;
40777: LD_VAR 0 7
40781: PPUSH
40782: CALL_OW 314
40786: NOT
40787: IFFALSE 40770
// mc_teleport_exit_set := ReplaceIn ( mc_teleport_exit_set , [ i , mc_teleport_exit_set [ i ] + 1 ] , teleports [ j ] ) ;
40789: LD_ADDR_EXP 112
40793: PUSH
40794: LD_EXP 112
40798: PPUSH
40799: LD_VAR 0 2
40803: PUSH
40804: LD_EXP 112
40808: PUSH
40809: LD_VAR 0 2
40813: ARRAY
40814: PUSH
40815: LD_INT 1
40817: PLUS
40818: PUSH
40819: EMPTY
40820: LIST
40821: LIST
40822: PPUSH
40823: LD_VAR 0 8
40827: PUSH
40828: LD_VAR 0 3
40832: ARRAY
40833: PPUSH
40834: CALL 57644 0 3
40838: ST_TO_ADDR
// end ;
40839: GO 40497
40841: POP
40842: POP
// MC_Reset ( i , 124 ) ;
40843: LD_VAR 0 2
40847: PPUSH
40848: LD_INT 124
40850: PPUSH
40851: CALL 24446 0 2
// end ; end ;
40855: GO 40252
40857: POP
40858: POP
// end ;
40859: LD_VAR 0 1
40863: RET
// export function MC_Deposits ( ) ; var i , tmp ; begin
40864: LD_INT 0
40866: PPUSH
40867: PPUSH
40868: PPUSH
// if not mc_bases then
40869: LD_EXP 76
40873: NOT
40874: IFFALSE 40878
// exit ;
40876: GO 41484
// for i = 1 to mc_bases do
40878: LD_ADDR_VAR 0 2
40882: PUSH
40883: DOUBLE
40884: LD_INT 1
40886: DEC
40887: ST_TO_ADDR
40888: LD_EXP 76
40892: PUSH
40893: FOR_TO
40894: IFFALSE 41482
// begin tmp := UnitFilter ( mc_bases [ i ] , [ f_class , 4 ] ) ;
40896: LD_ADDR_VAR 0 3
40900: PUSH
40901: LD_EXP 76
40905: PUSH
40906: LD_VAR 0 2
40910: ARRAY
40911: PPUSH
40912: LD_INT 25
40914: PUSH
40915: LD_INT 4
40917: PUSH
40918: EMPTY
40919: LIST
40920: LIST
40921: PPUSH
40922: CALL_OW 72
40926: ST_TO_ADDR
// if not tmp or not mc_deposits_xy [ i ] or not UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) then
40927: LD_VAR 0 3
40931: NOT
40932: PUSH
40933: LD_EXP 113
40937: PUSH
40938: LD_VAR 0 2
40942: ARRAY
40943: NOT
40944: OR
40945: PUSH
40946: LD_EXP 76
40950: PUSH
40951: LD_VAR 0 2
40955: ARRAY
40956: PPUSH
40957: LD_INT 2
40959: PUSH
40960: LD_INT 30
40962: PUSH
40963: LD_INT 0
40965: PUSH
40966: EMPTY
40967: LIST
40968: LIST
40969: PUSH
40970: LD_INT 30
40972: PUSH
40973: LD_INT 1
40975: PUSH
40976: EMPTY
40977: LIST
40978: LIST
40979: PUSH
40980: EMPTY
40981: LIST
40982: LIST
40983: LIST
40984: PPUSH
40985: CALL_OW 72
40989: NOT
40990: OR
40991: IFFALSE 41041
// begin if mc_deposits_finder [ i ] then
40993: LD_EXP 114
40997: PUSH
40998: LD_VAR 0 2
41002: ARRAY
41003: IFFALSE 41039
// begin MC_Reset ( i , 125 ) ;
41005: LD_VAR 0 2
41009: PPUSH
41010: LD_INT 125
41012: PPUSH
41013: CALL 24446 0 2
// mc_deposits_finder := Replace ( mc_deposits_finder , i , [ ] ) ;
41017: LD_ADDR_EXP 114
41021: PUSH
41022: LD_EXP 114
41026: PPUSH
41027: LD_VAR 0 2
41031: PPUSH
41032: EMPTY
41033: PPUSH
41034: CALL_OW 1
41038: ST_TO_ADDR
// end ; continue ;
41039: GO 40893
// end ; if mc_deposits_xy [ i ] [ 1 ] [ 3 ] = 1 and GetTech ( tech_sibdet , mc_sides [ i ] ) <> state_researched then
41041: LD_EXP 113
41045: PUSH
41046: LD_VAR 0 2
41050: ARRAY
41051: PUSH
41052: LD_INT 1
41054: ARRAY
41055: PUSH
41056: LD_INT 3
41058: ARRAY
41059: PUSH
41060: LD_INT 1
41062: EQUAL
41063: PUSH
41064: LD_INT 20
41066: PPUSH
41067: LD_EXP 102
41071: PUSH
41072: LD_VAR 0 2
41076: ARRAY
41077: PPUSH
41078: CALL_OW 321
41082: PUSH
41083: LD_INT 2
41085: NONEQUAL
41086: AND
41087: IFFALSE 41137
// begin if mc_deposits_finder [ i ] then
41089: LD_EXP 114
41093: PUSH
41094: LD_VAR 0 2
41098: ARRAY
41099: IFFALSE 41135
// begin MC_Reset ( i , 125 ) ;
41101: LD_VAR 0 2
41105: PPUSH
41106: LD_INT 125
41108: PPUSH
41109: CALL 24446 0 2
// mc_deposits_finder := Replace ( mc_deposits_finder , i , [ ] ) ;
41113: LD_ADDR_EXP 114
41117: PUSH
41118: LD_EXP 114
41122: PPUSH
41123: LD_VAR 0 2
41127: PPUSH
41128: EMPTY
41129: PPUSH
41130: CALL_OW 1
41134: ST_TO_ADDR
// end ; continue ;
41135: GO 40893
// end ; if GetResourceVisibility ( mc_deposits_xy [ i ] [ 1 ] [ 1 ] , mc_deposits_xy [ i ] [ 1 ] [ 2 ] , mc_sides [ i ] ) then
41137: LD_EXP 113
41141: PUSH
41142: LD_VAR 0 2
41146: ARRAY
41147: PUSH
41148: LD_INT 1
41150: ARRAY
41151: PUSH
41152: LD_INT 1
41154: ARRAY
41155: PPUSH
41156: LD_EXP 113
41160: PUSH
41161: LD_VAR 0 2
41165: ARRAY
41166: PUSH
41167: LD_INT 1
41169: ARRAY
41170: PUSH
41171: LD_INT 2
41173: ARRAY
41174: PPUSH
41175: LD_EXP 102
41179: PUSH
41180: LD_VAR 0 2
41184: ARRAY
41185: PPUSH
41186: CALL_OW 440
41190: IFFALSE 41233
// mc_deposits_xy := Replace ( mc_deposits_xy , i , Delete ( mc_deposits_xy [ i ] , 1 ) ) else
41192: LD_ADDR_EXP 113
41196: PUSH
41197: LD_EXP 113
41201: PPUSH
41202: LD_VAR 0 2
41206: PPUSH
41207: LD_EXP 113
41211: PUSH
41212: LD_VAR 0 2
41216: ARRAY
41217: PPUSH
41218: LD_INT 1
41220: PPUSH
41221: CALL_OW 3
41225: PPUSH
41226: CALL_OW 1
41230: ST_TO_ADDR
41231: GO 41480
// begin if not mc_deposits_finder [ i ] then
41233: LD_EXP 114
41237: PUSH
41238: LD_VAR 0 2
41242: ARRAY
41243: NOT
41244: IFFALSE 41296
// begin mc_deposits_finder := Replace ( mc_deposits_finder , i , [ tmp [ 1 ] ] ) ;
41246: LD_ADDR_EXP 114
41250: PUSH
41251: LD_EXP 114
41255: PPUSH
41256: LD_VAR 0 2
41260: PPUSH
41261: LD_VAR 0 3
41265: PUSH
41266: LD_INT 1
41268: ARRAY
41269: PUSH
41270: EMPTY
41271: LIST
41272: PPUSH
41273: CALL_OW 1
41277: ST_TO_ADDR
// SetTag ( tmp [ 1 ] , 125 ) ;
41278: LD_VAR 0 3
41282: PUSH
41283: LD_INT 1
41285: ARRAY
41286: PPUSH
41287: LD_INT 125
41289: PPUSH
41290: CALL_OW 109
// end else
41294: GO 41480
// begin if IsInUnit ( mc_deposits_finder [ i ] [ 1 ] ) then
41296: LD_EXP 114
41300: PUSH
41301: LD_VAR 0 2
41305: ARRAY
41306: PUSH
41307: LD_INT 1
41309: ARRAY
41310: PPUSH
41311: CALL_OW 310
41315: IFFALSE 41338
// ComExitBuilding ( mc_deposits_finder [ i ] [ 1 ] ) else
41317: LD_EXP 114
41321: PUSH
41322: LD_VAR 0 2
41326: ARRAY
41327: PUSH
41328: LD_INT 1
41330: ARRAY
41331: PPUSH
41332: CALL_OW 122
41336: GO 41480
// if not HasTask ( mc_deposits_finder [ i ] [ 1 ] ) and GetDistUnitXY ( mc_deposits_finder [ i ] [ 1 ] , mc_deposits_xy [ i ] [ 1 ] [ 1 ] , mc_deposits_xy [ i ] [ 1 ] [ 2 ] ) > 6 then
41338: LD_EXP 114
41342: PUSH
41343: LD_VAR 0 2
41347: ARRAY
41348: PUSH
41349: LD_INT 1
41351: ARRAY
41352: PPUSH
41353: CALL_OW 314
41357: NOT
41358: PUSH
41359: LD_EXP 114
41363: PUSH
41364: LD_VAR 0 2
41368: ARRAY
41369: PUSH
41370: LD_INT 1
41372: ARRAY
41373: PPUSH
41374: LD_EXP 113
41378: PUSH
41379: LD_VAR 0 2
41383: ARRAY
41384: PUSH
41385: LD_INT 1
41387: ARRAY
41388: PUSH
41389: LD_INT 1
41391: ARRAY
41392: PPUSH
41393: LD_EXP 113
41397: PUSH
41398: LD_VAR 0 2
41402: ARRAY
41403: PUSH
41404: LD_INT 1
41406: ARRAY
41407: PUSH
41408: LD_INT 2
41410: ARRAY
41411: PPUSH
41412: CALL_OW 297
41416: PUSH
41417: LD_INT 6
41419: GREATER
41420: AND
41421: IFFALSE 41480
// ComMoveXY ( mc_deposits_finder [ i ] [ 1 ] , mc_deposits_xy [ i ] [ 1 ] [ 1 ] , mc_deposits_xy [ i ] [ 1 ] [ 2 ] ) ;
41423: LD_EXP 114
41427: PUSH
41428: LD_VAR 0 2
41432: ARRAY
41433: PUSH
41434: LD_INT 1
41436: ARRAY
41437: PPUSH
41438: LD_EXP 113
41442: PUSH
41443: LD_VAR 0 2
41447: ARRAY
41448: PUSH
41449: LD_INT 1
41451: ARRAY
41452: PUSH
41453: LD_INT 1
41455: ARRAY
41456: PPUSH
41457: LD_EXP 113
41461: PUSH
41462: LD_VAR 0 2
41466: ARRAY
41467: PUSH
41468: LD_INT 1
41470: ARRAY
41471: PUSH
41472: LD_INT 2
41474: ARRAY
41475: PPUSH
41476: CALL_OW 111
// end ; end ; end ;
41480: GO 40893
41482: POP
41483: POP
// end ;
41484: LD_VAR 0 1
41488: RET
// export function MC_RemoteDriver ( ) ; var i , j , k , places , tmp , nation , ct , cts , mcts , x ; begin
41489: LD_INT 0
41491: PPUSH
41492: PPUSH
41493: PPUSH
41494: PPUSH
41495: PPUSH
41496: PPUSH
41497: PPUSH
41498: PPUSH
41499: PPUSH
41500: PPUSH
41501: PPUSH
// if not mc_bases then
41502: LD_EXP 76
41506: NOT
41507: IFFALSE 41511
// exit ;
41509: GO 42451
// for i = 1 to mc_bases do
41511: LD_ADDR_VAR 0 2
41515: PUSH
41516: DOUBLE
41517: LD_INT 1
41519: DEC
41520: ST_TO_ADDR
41521: LD_EXP 76
41525: PUSH
41526: FOR_TO
41527: IFFALSE 42449
// begin if not mc_bases [ i ] or mc_scan [ i ] then
41529: LD_EXP 76
41533: PUSH
41534: LD_VAR 0 2
41538: ARRAY
41539: NOT
41540: PUSH
41541: LD_EXP 99
41545: PUSH
41546: LD_VAR 0 2
41550: ARRAY
41551: OR
41552: IFFALSE 41556
// continue ;
41554: GO 41526
// nation := GetNation ( mc_bases [ i ] [ 1 ] ) ;
41556: LD_ADDR_VAR 0 7
41560: PUSH
41561: LD_EXP 76
41565: PUSH
41566: LD_VAR 0 2
41570: ARRAY
41571: PUSH
41572: LD_INT 1
41574: ARRAY
41575: PPUSH
41576: CALL_OW 248
41580: ST_TO_ADDR
// if nation = 3 or not UnitFilter ( mc_vehicles [ i ] union mc_defender [ i ] , [ f_control , control_remote ] ) then
41581: LD_VAR 0 7
41585: PUSH
41586: LD_INT 3
41588: EQUAL
41589: PUSH
41590: LD_EXP 95
41594: PUSH
41595: LD_VAR 0 2
41599: ARRAY
41600: PUSH
41601: LD_EXP 98
41605: PUSH
41606: LD_VAR 0 2
41610: ARRAY
41611: UNION
41612: PPUSH
41613: LD_INT 33
41615: PUSH
41616: LD_INT 2
41618: PUSH
41619: EMPTY
41620: LIST
41621: LIST
41622: PPUSH
41623: CALL_OW 72
41627: NOT
41628: OR
41629: IFFALSE 41633
// continue ;
41631: GO 41526
// cts := UnitFilter ( mc_bases [ i ] , [ f_btype , b_control_tower ] ) ;
41633: LD_ADDR_VAR 0 9
41637: PUSH
41638: LD_EXP 76
41642: PUSH
41643: LD_VAR 0 2
41647: ARRAY
41648: PPUSH
41649: LD_INT 30
41651: PUSH
41652: LD_INT 36
41654: PUSH
41655: EMPTY
41656: LIST
41657: LIST
41658: PPUSH
41659: CALL_OW 72
41663: ST_TO_ADDR
// mcts := UnitFilter ( mc_vehicles [ i ] , [ f_weapon , ar_control_tower ] ) ;
41664: LD_ADDR_VAR 0 10
41668: PUSH
41669: LD_EXP 95
41673: PUSH
41674: LD_VAR 0 2
41678: ARRAY
41679: PPUSH
41680: LD_INT 34
41682: PUSH
41683: LD_INT 31
41685: PUSH
41686: EMPTY
41687: LIST
41688: LIST
41689: PPUSH
41690: CALL_OW 72
41694: ST_TO_ADDR
// if not cts and not mcts then
41695: LD_VAR 0 9
41699: NOT
41700: PUSH
41701: LD_VAR 0 10
41705: NOT
41706: AND
41707: IFFALSE 41711
// continue ;
41709: GO 41526
// x := cts ;
41711: LD_ADDR_VAR 0 11
41715: PUSH
41716: LD_VAR 0 9
41720: ST_TO_ADDR
// if not x then
41721: LD_VAR 0 11
41725: NOT
41726: IFFALSE 41738
// x := mcts ;
41728: LD_ADDR_VAR 0 11
41732: PUSH
41733: LD_VAR 0 10
41737: ST_TO_ADDR
// if not x then
41738: LD_VAR 0 11
41742: NOT
41743: IFFALSE 41747
// continue ;
41745: GO 41526
// if mc_remote_driver [ i ] then
41747: LD_EXP 116
41751: PUSH
41752: LD_VAR 0 2
41756: ARRAY
41757: IFFALSE 42144
// for j in mc_remote_driver [ i ] do
41759: LD_ADDR_VAR 0 3
41763: PUSH
41764: LD_EXP 116
41768: PUSH
41769: LD_VAR 0 2
41773: ARRAY
41774: PUSH
41775: FOR_IN
41776: IFFALSE 42142
// begin if GetClass ( j ) <> 3 then
41778: LD_VAR 0 3
41782: PPUSH
41783: CALL_OW 257
41787: PUSH
41788: LD_INT 3
41790: NONEQUAL
41791: IFFALSE 41844
// begin mc_remote_driver := Replace ( mc_remote_driver , i , mc_remote_driver [ i ] diff j ) ;
41793: LD_ADDR_EXP 116
41797: PUSH
41798: LD_EXP 116
41802: PPUSH
41803: LD_VAR 0 2
41807: PPUSH
41808: LD_EXP 116
41812: PUSH
41813: LD_VAR 0 2
41817: ARRAY
41818: PUSH
41819: LD_VAR 0 3
41823: DIFF
41824: PPUSH
41825: CALL_OW 1
41829: ST_TO_ADDR
// SetTag ( j , 0 ) ;
41830: LD_VAR 0 3
41834: PPUSH
41835: LD_INT 0
41837: PPUSH
41838: CALL_OW 109
// continue ;
41842: GO 41775
// end ; if UnitFilter ( mc_vehicles [ i ] , [ [ f_weapon , ar_control_tower ] , [ f_empty ] ] ) and not IsDriver ( j ) then
41844: LD_EXP 95
41848: PUSH
41849: LD_VAR 0 2
41853: ARRAY
41854: PPUSH
41855: LD_INT 34
41857: PUSH
41858: LD_INT 31
41860: PUSH
41861: EMPTY
41862: LIST
41863: LIST
41864: PUSH
41865: LD_INT 58
41867: PUSH
41868: EMPTY
41869: LIST
41870: PUSH
41871: EMPTY
41872: LIST
41873: LIST
41874: PPUSH
41875: CALL_OW 72
41879: PUSH
41880: LD_VAR 0 3
41884: PPUSH
41885: CALL 90995 0 1
41889: NOT
41890: AND
41891: IFFALSE 41962
// begin if IsInUnit ( j ) then
41893: LD_VAR 0 3
41897: PPUSH
41898: CALL_OW 310
41902: IFFALSE 41913
// ComExitBuilding ( j ) ;
41904: LD_VAR 0 3
41908: PPUSH
41909: CALL_OW 122
// AddComEnterUnit ( j , UnitFilter ( mc_vehicles [ i ] , [ [ f_weapon , ar_control_tower ] , [ f_empty ] ] ) [ 1 ] ) ;
41913: LD_VAR 0 3
41917: PPUSH
41918: LD_EXP 95
41922: PUSH
41923: LD_VAR 0 2
41927: ARRAY
41928: PPUSH
41929: LD_INT 34
41931: PUSH
41932: LD_INT 31
41934: PUSH
41935: EMPTY
41936: LIST
41937: LIST
41938: PUSH
41939: LD_INT 58
41941: PUSH
41942: EMPTY
41943: LIST
41944: PUSH
41945: EMPTY
41946: LIST
41947: LIST
41948: PPUSH
41949: CALL_OW 72
41953: PUSH
41954: LD_INT 1
41956: ARRAY
41957: PPUSH
41958: CALL_OW 180
// end ; if not IsInUnit ( j ) or ( GetBType ( IsInUnit ( j ) ) <> b_control_tower and not IsDriver ( j ) ) then
41962: LD_VAR 0 3
41966: PPUSH
41967: CALL_OW 310
41971: NOT
41972: PUSH
41973: LD_VAR 0 3
41977: PPUSH
41978: CALL_OW 310
41982: PPUSH
41983: CALL_OW 266
41987: PUSH
41988: LD_INT 36
41990: NONEQUAL
41991: PUSH
41992: LD_VAR 0 3
41996: PPUSH
41997: CALL 90995 0 1
42001: NOT
42002: AND
42003: OR
42004: IFFALSE 42140
// begin if IsInUnit ( j ) then
42006: LD_VAR 0 3
42010: PPUSH
42011: CALL_OW 310
42015: IFFALSE 42026
// ComExitBuilding ( j ) ;
42017: LD_VAR 0 3
42021: PPUSH
42022: CALL_OW 122
// ct := 0 ;
42026: LD_ADDR_VAR 0 8
42030: PUSH
42031: LD_INT 0
42033: ST_TO_ADDR
// for k in x do
42034: LD_ADDR_VAR 0 4
42038: PUSH
42039: LD_VAR 0 11
42043: PUSH
42044: FOR_IN
42045: IFFALSE 42118
// if ( GetWeapon ( k ) = ar_control_tower and not IsDrivenBy ( k ) ) or ( GetBType ( k ) = b_control_tower and UnitsInside ( k ) < 3 ) then
42047: LD_VAR 0 4
42051: PPUSH
42052: CALL_OW 264
42056: PUSH
42057: LD_INT 31
42059: EQUAL
42060: PUSH
42061: LD_VAR 0 4
42065: PPUSH
42066: CALL_OW 311
42070: NOT
42071: AND
42072: PUSH
42073: LD_VAR 0 4
42077: PPUSH
42078: CALL_OW 266
42082: PUSH
42083: LD_INT 36
42085: EQUAL
42086: PUSH
42087: LD_VAR 0 4
42091: PPUSH
42092: CALL_OW 313
42096: PUSH
42097: LD_INT 3
42099: LESS
42100: AND
42101: OR
42102: IFFALSE 42116
// begin ct := k ;
42104: LD_ADDR_VAR 0 8
42108: PUSH
42109: LD_VAR 0 4
42113: ST_TO_ADDR
// break ;
42114: GO 42118
// end ;
42116: GO 42044
42118: POP
42119: POP
// if ct then
42120: LD_VAR 0 8
42124: IFFALSE 42140
// ComEnterUnit ( j , ct ) ;
42126: LD_VAR 0 3
42130: PPUSH
42131: LD_VAR 0 8
42135: PPUSH
42136: CALL_OW 120
// end ; end ;
42140: GO 41775
42142: POP
42143: POP
// places := 0 ;
42144: LD_ADDR_VAR 0 5
42148: PUSH
42149: LD_INT 0
42151: ST_TO_ADDR
// for j = 1 to x do
42152: LD_ADDR_VAR 0 3
42156: PUSH
42157: DOUBLE
42158: LD_INT 1
42160: DEC
42161: ST_TO_ADDR
42162: LD_VAR 0 11
42166: PUSH
42167: FOR_TO
42168: IFFALSE 42244
// if GetWeapon ( x [ j ] ) = ar_control_tower then
42170: LD_VAR 0 11
42174: PUSH
42175: LD_VAR 0 3
42179: ARRAY
42180: PPUSH
42181: CALL_OW 264
42185: PUSH
42186: LD_INT 31
42188: EQUAL
42189: IFFALSE 42207
// places := places + 1 else
42191: LD_ADDR_VAR 0 5
42195: PUSH
42196: LD_VAR 0 5
42200: PUSH
42201: LD_INT 1
42203: PLUS
42204: ST_TO_ADDR
42205: GO 42242
// if GetBType ( x [ j ] ) = b_control_tower then
42207: LD_VAR 0 11
42211: PUSH
42212: LD_VAR 0 3
42216: ARRAY
42217: PPUSH
42218: CALL_OW 266
42222: PUSH
42223: LD_INT 36
42225: EQUAL
42226: IFFALSE 42242
// places := places + 3 ;
42228: LD_ADDR_VAR 0 5
42232: PUSH
42233: LD_VAR 0 5
42237: PUSH
42238: LD_INT 3
42240: PLUS
42241: ST_TO_ADDR
42242: GO 42167
42244: POP
42245: POP
// if places = 0 or places <= mc_remote_driver [ i ] then
42246: LD_VAR 0 5
42250: PUSH
42251: LD_INT 0
42253: EQUAL
42254: PUSH
42255: LD_VAR 0 5
42259: PUSH
42260: LD_EXP 116
42264: PUSH
42265: LD_VAR 0 2
42269: ARRAY
42270: LESSEQUAL
42271: OR
42272: IFFALSE 42276
// continue ;
42274: GO 41526
// tmp := SortBySkill ( UnitFilter ( mc_bases [ i ] , [ f_class , 3 ] ) diff mc_remote_driver [ i ] , 3 ) ;
42276: LD_ADDR_VAR 0 6
42280: PUSH
42281: LD_EXP 76
42285: PUSH
42286: LD_VAR 0 2
42290: ARRAY
42291: PPUSH
42292: LD_INT 25
42294: PUSH
42295: LD_INT 3
42297: PUSH
42298: EMPTY
42299: LIST
42300: LIST
42301: PPUSH
42302: CALL_OW 72
42306: PUSH
42307: LD_EXP 116
42311: PUSH
42312: LD_VAR 0 2
42316: ARRAY
42317: DIFF
42318: PPUSH
42319: LD_INT 3
42321: PPUSH
42322: CALL 91895 0 2
42326: ST_TO_ADDR
// for j in tmp do
42327: LD_ADDR_VAR 0 3
42331: PUSH
42332: LD_VAR 0 6
42336: PUSH
42337: FOR_IN
42338: IFFALSE 42373
// if GetTag ( j ) > 0 then
42340: LD_VAR 0 3
42344: PPUSH
42345: CALL_OW 110
42349: PUSH
42350: LD_INT 0
42352: GREATER
42353: IFFALSE 42371
// tmp := tmp diff j ;
42355: LD_ADDR_VAR 0 6
42359: PUSH
42360: LD_VAR 0 6
42364: PUSH
42365: LD_VAR 0 3
42369: DIFF
42370: ST_TO_ADDR
42371: GO 42337
42373: POP
42374: POP
// if not tmp then
42375: LD_VAR 0 6
42379: NOT
42380: IFFALSE 42384
// continue ;
42382: GO 41526
// if places then
42384: LD_VAR 0 5
42388: IFFALSE 42447
// begin mc_remote_driver := Replace ( mc_remote_driver , i , mc_remote_driver [ i ] union tmp [ 1 ] ) ;
42390: LD_ADDR_EXP 116
42394: PUSH
42395: LD_EXP 116
42399: PPUSH
42400: LD_VAR 0 2
42404: PPUSH
42405: LD_EXP 116
42409: PUSH
42410: LD_VAR 0 2
42414: ARRAY
42415: PUSH
42416: LD_VAR 0 6
42420: PUSH
42421: LD_INT 1
42423: ARRAY
42424: UNION
42425: PPUSH
42426: CALL_OW 1
42430: ST_TO_ADDR
// SetTag ( tmp [ 1 ] , 126 ) ;
42431: LD_VAR 0 6
42435: PUSH
42436: LD_INT 1
42438: ARRAY
42439: PPUSH
42440: LD_INT 126
42442: PPUSH
42443: CALL_OW 109
// end ; end ;
42447: GO 41526
42449: POP
42450: POP
// end ;
42451: LD_VAR 0 1
42455: RET
// export function MC_Back ( base , base_unit_list , unit , class ) ; var i , j , tmp , x , depot ; begin
42456: LD_INT 0
42458: PPUSH
42459: PPUSH
42460: PPUSH
42461: PPUSH
42462: PPUSH
42463: PPUSH
// if not base or not base_unit_list or not unit or not class in [ 1 , 2 , 3 , 4 , 5 , 8 , 9 , 15 , 16 ] then
42464: LD_VAR 0 1
42468: NOT
42469: PUSH
42470: LD_VAR 0 2
42474: NOT
42475: OR
42476: PUSH
42477: LD_VAR 0 3
42481: NOT
42482: OR
42483: PUSH
42484: LD_VAR 0 4
42488: PUSH
42489: LD_INT 1
42491: PUSH
42492: LD_INT 2
42494: PUSH
42495: LD_INT 3
42497: PUSH
42498: LD_INT 4
42500: PUSH
42501: LD_INT 5
42503: PUSH
42504: LD_INT 8
42506: PUSH
42507: LD_INT 9
42509: PUSH
42510: LD_INT 15
42512: PUSH
42513: LD_INT 16
42515: PUSH
42516: EMPTY
42517: LIST
42518: LIST
42519: LIST
42520: LIST
42521: LIST
42522: LIST
42523: LIST
42524: LIST
42525: LIST
42526: IN
42527: NOT
42528: OR
42529: IFFALSE 42533
// exit ;
42531: GO 43433
// base_unit_list := UnitFilter ( base_unit_list , [ [ f_type , unit_building ] , [ f_lives , 250 ] ] ) ;
42533: LD_ADDR_VAR 0 2
42537: PUSH
42538: LD_VAR 0 2
42542: PPUSH
42543: LD_INT 21
42545: PUSH
42546: LD_INT 3
42548: PUSH
42549: EMPTY
42550: LIST
42551: LIST
42552: PUSH
42553: LD_INT 24
42555: PUSH
42556: LD_INT 250
42558: PUSH
42559: EMPTY
42560: LIST
42561: LIST
42562: PUSH
42563: EMPTY
42564: LIST
42565: LIST
42566: PPUSH
42567: CALL_OW 72
42571: ST_TO_ADDR
// case class of 1 , 15 :
42572: LD_VAR 0 4
42576: PUSH
42577: LD_INT 1
42579: DOUBLE
42580: EQUAL
42581: IFTRUE 42591
42583: LD_INT 15
42585: DOUBLE
42586: EQUAL
42587: IFTRUE 42591
42589: GO 42676
42591: POP
// tmp := UnitFilter ( base_unit_list , [ f_or , [ f_btype , b_bunker ] , [ f_btype , b_breastwork ] ] ) ^ UnitFilter ( base_unit_list , [ f_or , [ f_btype , b_armoury ] , [ f_btype , b_barracks ] ] ) ; 2 , 16 :
42592: LD_ADDR_VAR 0 8
42596: PUSH
42597: LD_VAR 0 2
42601: PPUSH
42602: LD_INT 2
42604: PUSH
42605: LD_INT 30
42607: PUSH
42608: LD_INT 32
42610: PUSH
42611: EMPTY
42612: LIST
42613: LIST
42614: PUSH
42615: LD_INT 30
42617: PUSH
42618: LD_INT 31
42620: PUSH
42621: EMPTY
42622: LIST
42623: LIST
42624: PUSH
42625: EMPTY
42626: LIST
42627: LIST
42628: LIST
42629: PPUSH
42630: CALL_OW 72
42634: PUSH
42635: LD_VAR 0 2
42639: PPUSH
42640: LD_INT 2
42642: PUSH
42643: LD_INT 30
42645: PUSH
42646: LD_INT 4
42648: PUSH
42649: EMPTY
42650: LIST
42651: LIST
42652: PUSH
42653: LD_INT 30
42655: PUSH
42656: LD_INT 5
42658: PUSH
42659: EMPTY
42660: LIST
42661: LIST
42662: PUSH
42663: EMPTY
42664: LIST
42665: LIST
42666: LIST
42667: PPUSH
42668: CALL_OW 72
42672: ADD
42673: ST_TO_ADDR
42674: GO 42922
42676: LD_INT 2
42678: DOUBLE
42679: EQUAL
42680: IFTRUE 42690
42682: LD_INT 16
42684: DOUBLE
42685: EQUAL
42686: IFTRUE 42690
42688: GO 42736
42690: POP
// tmp := UnitFilter ( base_unit_list , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) ; 3 :
42691: LD_ADDR_VAR 0 8
42695: PUSH
42696: LD_VAR 0 2
42700: PPUSH
42701: LD_INT 2
42703: PUSH
42704: LD_INT 30
42706: PUSH
42707: LD_INT 0
42709: PUSH
42710: EMPTY
42711: LIST
42712: LIST
42713: PUSH
42714: LD_INT 30
42716: PUSH
42717: LD_INT 1
42719: PUSH
42720: EMPTY
42721: LIST
42722: LIST
42723: PUSH
42724: EMPTY
42725: LIST
42726: LIST
42727: LIST
42728: PPUSH
42729: CALL_OW 72
42733: ST_TO_ADDR
42734: GO 42922
42736: LD_INT 3
42738: DOUBLE
42739: EQUAL
42740: IFTRUE 42744
42742: GO 42790
42744: POP
// tmp := UnitFilter ( base_unit_list , [ f_or , [ f_btype , b_workshop ] , [ f_btype , b_factory ] ] ) ; 4 :
42745: LD_ADDR_VAR 0 8
42749: PUSH
42750: LD_VAR 0 2
42754: PPUSH
42755: LD_INT 2
42757: PUSH
42758: LD_INT 30
42760: PUSH
42761: LD_INT 2
42763: PUSH
42764: EMPTY
42765: LIST
42766: LIST
42767: PUSH
42768: LD_INT 30
42770: PUSH
42771: LD_INT 3
42773: PUSH
42774: EMPTY
42775: LIST
42776: LIST
42777: PUSH
42778: EMPTY
42779: LIST
42780: LIST
42781: LIST
42782: PPUSH
42783: CALL_OW 72
42787: ST_TO_ADDR
42788: GO 42922
42790: LD_INT 4
42792: DOUBLE
42793: EQUAL
42794: IFTRUE 42798
42796: GO 42855
42798: POP
// tmp := UnitFilter ( base_unit_list , [ f_or , [ f_btype , b_lab ] , [ f_btype , b_lab_half ] , [ f_btype , b_lab_full ] ] ) ; 5 , 8 , 9 :
42799: LD_ADDR_VAR 0 8
42803: PUSH
42804: LD_VAR 0 2
42808: PPUSH
42809: LD_INT 2
42811: PUSH
42812: LD_INT 30
42814: PUSH
42815: LD_INT 6
42817: PUSH
42818: EMPTY
42819: LIST
42820: LIST
42821: PUSH
42822: LD_INT 30
42824: PUSH
42825: LD_INT 7
42827: PUSH
42828: EMPTY
42829: LIST
42830: LIST
42831: PUSH
42832: LD_INT 30
42834: PUSH
42835: LD_INT 8
42837: PUSH
42838: EMPTY
42839: LIST
42840: LIST
42841: PUSH
42842: EMPTY
42843: LIST
42844: LIST
42845: LIST
42846: LIST
42847: PPUSH
42848: CALL_OW 72
42852: ST_TO_ADDR
42853: GO 42922
42855: LD_INT 5
42857: DOUBLE
42858: EQUAL
42859: IFTRUE 42875
42861: LD_INT 8
42863: DOUBLE
42864: EQUAL
42865: IFTRUE 42875
42867: LD_INT 9
42869: DOUBLE
42870: EQUAL
42871: IFTRUE 42875
42873: GO 42921
42875: POP
// tmp := UnitFilter ( base_unit_list , [ f_or , [ f_btype , b_armoury ] , [ f_btype , b_barracks ] ] ) ; end ;
42876: LD_ADDR_VAR 0 8
42880: PUSH
42881: LD_VAR 0 2
42885: PPUSH
42886: LD_INT 2
42888: PUSH
42889: LD_INT 30
42891: PUSH
42892: LD_INT 4
42894: PUSH
42895: EMPTY
42896: LIST
42897: LIST
42898: PUSH
42899: LD_INT 30
42901: PUSH
42902: LD_INT 5
42904: PUSH
42905: EMPTY
42906: LIST
42907: LIST
42908: PUSH
42909: EMPTY
42910: LIST
42911: LIST
42912: LIST
42913: PPUSH
42914: CALL_OW 72
42918: ST_TO_ADDR
42919: GO 42922
42921: POP
// if not tmp then
42922: LD_VAR 0 8
42926: NOT
42927: IFFALSE 42931
// exit ;
42929: GO 43433
// if class in [ 1 , 15 ] and mc_empty_turret_list [ base ] then
42931: LD_VAR 0 4
42935: PUSH
42936: LD_INT 1
42938: PUSH
42939: LD_INT 15
42941: PUSH
42942: EMPTY
42943: LIST
42944: LIST
42945: IN
42946: PUSH
42947: LD_EXP 85
42951: PUSH
42952: LD_VAR 0 1
42956: ARRAY
42957: AND
42958: IFFALSE 43114
// begin x := mc_empty_turret_list [ base ] [ 1 ] ;
42960: LD_ADDR_VAR 0 9
42964: PUSH
42965: LD_EXP 85
42969: PUSH
42970: LD_VAR 0 1
42974: ARRAY
42975: PUSH
42976: LD_INT 1
42978: ARRAY
42979: ST_TO_ADDR
// if not x in mc_busy_turret_list [ base ] then
42980: LD_VAR 0 9
42984: PUSH
42985: LD_EXP 86
42989: PUSH
42990: LD_VAR 0 1
42994: ARRAY
42995: IN
42996: NOT
42997: IFFALSE 43112
// begin mc_busy_turret_list := ReplaceIn ( mc_busy_turret_list , [ base , mc_busy_turret_list [ base ] + 1 ] , x ) ;
42999: LD_ADDR_EXP 86
43003: PUSH
43004: LD_EXP 86
43008: PPUSH
43009: LD_VAR 0 1
43013: PUSH
43014: LD_EXP 86
43018: PUSH
43019: LD_VAR 0 1
43023: ARRAY
43024: PUSH
43025: LD_INT 1
43027: PLUS
43028: PUSH
43029: EMPTY
43030: LIST
43031: LIST
43032: PPUSH
43033: LD_VAR 0 9
43037: PPUSH
43038: CALL 57644 0 3
43042: ST_TO_ADDR
// mc_empty_turret_list := Replace ( mc_empty_turret_list , base , mc_empty_turret_list [ base ] diff x ) ;
43043: LD_ADDR_EXP 85
43047: PUSH
43048: LD_EXP 85
43052: PPUSH
43053: LD_VAR 0 1
43057: PPUSH
43058: LD_EXP 85
43062: PUSH
43063: LD_VAR 0 1
43067: ARRAY
43068: PUSH
43069: LD_VAR 0 9
43073: DIFF
43074: PPUSH
43075: CALL_OW 1
43079: ST_TO_ADDR
// ComEnterUnit ( unit , mc_busy_turret_list [ base ] [ mc_busy_turret_list [ base ] ] ) ;
43080: LD_VAR 0 3
43084: PPUSH
43085: LD_EXP 86
43089: PUSH
43090: LD_VAR 0 1
43094: ARRAY
43095: PUSH
43096: LD_EXP 86
43100: PUSH
43101: LD_VAR 0 1
43105: ARRAY
43106: ARRAY
43107: PPUSH
43108: CALL_OW 120
// end ; exit ;
43112: GO 43433
// end ; if tmp > 1 then
43114: LD_VAR 0 8
43118: PUSH
43119: LD_INT 1
43121: GREATER
43122: IFFALSE 43226
// for i = 2 to tmp do
43124: LD_ADDR_VAR 0 6
43128: PUSH
43129: DOUBLE
43130: LD_INT 2
43132: DEC
43133: ST_TO_ADDR
43134: LD_VAR 0 8
43138: PUSH
43139: FOR_TO
43140: IFFALSE 43224
// if BuildingStatus ( tmp [ i ] ) = bs_need_people then
43142: LD_VAR 0 8
43146: PUSH
43147: LD_VAR 0 6
43151: ARRAY
43152: PPUSH
43153: CALL_OW 461
43157: PUSH
43158: LD_INT 6
43160: EQUAL
43161: IFFALSE 43222
// begin x := tmp [ i ] ;
43163: LD_ADDR_VAR 0 9
43167: PUSH
43168: LD_VAR 0 8
43172: PUSH
43173: LD_VAR 0 6
43177: ARRAY
43178: ST_TO_ADDR
// tmp := Delete ( tmp , i ) ;
43179: LD_ADDR_VAR 0 8
43183: PUSH
43184: LD_VAR 0 8
43188: PPUSH
43189: LD_VAR 0 6
43193: PPUSH
43194: CALL_OW 3
43198: ST_TO_ADDR
// tmp := Insert ( tmp , 1 , x ) ;
43199: LD_ADDR_VAR 0 8
43203: PUSH
43204: LD_VAR 0 8
43208: PPUSH
43209: LD_INT 1
43211: PPUSH
43212: LD_VAR 0 9
43216: PPUSH
43217: CALL_OW 2
43221: ST_TO_ADDR
// end ;
43222: GO 43139
43224: POP
43225: POP
// for i in tmp do
43226: LD_ADDR_VAR 0 6
43230: PUSH
43231: LD_VAR 0 8
43235: PUSH
43236: FOR_IN
43237: IFFALSE 43306
// begin if ( UnitsInside ( i ) < 6 and not GetBType ( i ) in [ b_breastwork , b_bunker ] ) or UnitsInside ( i ) = 0 then
43239: LD_VAR 0 6
43243: PPUSH
43244: CALL_OW 313
43248: PUSH
43249: LD_INT 6
43251: LESS
43252: PUSH
43253: LD_VAR 0 6
43257: PPUSH
43258: CALL_OW 266
43262: PUSH
43263: LD_INT 31
43265: PUSH
43266: LD_INT 32
43268: PUSH
43269: EMPTY
43270: LIST
43271: LIST
43272: IN
43273: NOT
43274: AND
43275: PUSH
43276: LD_VAR 0 6
43280: PPUSH
43281: CALL_OW 313
43285: PUSH
43286: LD_INT 0
43288: EQUAL
43289: OR
43290: IFFALSE 43304
// begin j := i ;
43292: LD_ADDR_VAR 0 7
43296: PUSH
43297: LD_VAR 0 6
43301: ST_TO_ADDR
// break ;
43302: GO 43306
// end ; end ;
43304: GO 43236
43306: POP
43307: POP
// if j then
43308: LD_VAR 0 7
43312: IFFALSE 43330
// ComEnterUnit ( unit , j ) else
43314: LD_VAR 0 3
43318: PPUSH
43319: LD_VAR 0 7
43323: PPUSH
43324: CALL_OW 120
43328: GO 43433
// begin depot := UnitFilter ( base_unit_list , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) ;
43330: LD_ADDR_VAR 0 10
43334: PUSH
43335: LD_VAR 0 2
43339: PPUSH
43340: LD_INT 2
43342: PUSH
43343: LD_INT 30
43345: PUSH
43346: LD_INT 0
43348: PUSH
43349: EMPTY
43350: LIST
43351: LIST
43352: PUSH
43353: LD_INT 30
43355: PUSH
43356: LD_INT 1
43358: PUSH
43359: EMPTY
43360: LIST
43361: LIST
43362: PUSH
43363: EMPTY
43364: LIST
43365: LIST
43366: LIST
43367: PPUSH
43368: CALL_OW 72
43372: ST_TO_ADDR
// if depot then
43373: LD_VAR 0 10
43377: IFFALSE 43433
// begin depot := NearestUnitToUnit ( depot , unit ) ;
43379: LD_ADDR_VAR 0 10
43383: PUSH
43384: LD_VAR 0 10
43388: PPUSH
43389: LD_VAR 0 3
43393: PPUSH
43394: CALL_OW 74
43398: ST_TO_ADDR
// if GetDistUnits ( unit , depot ) > 10 then
43399: LD_VAR 0 3
43403: PPUSH
43404: LD_VAR 0 10
43408: PPUSH
43409: CALL_OW 296
43413: PUSH
43414: LD_INT 10
43416: GREATER
43417: IFFALSE 43433
// ComStandNearbyBuilding ( unit , depot ) ;
43419: LD_VAR 0 3
43423: PPUSH
43424: LD_VAR 0 10
43428: PPUSH
43429: CALL 51847 0 2
// end ; end ; end ;
43433: LD_VAR 0 5
43437: RET
// export function MC_Idle ( ) ; var i , j , tmp ; begin
43438: LD_INT 0
43440: PPUSH
43441: PPUSH
43442: PPUSH
43443: PPUSH
// if not mc_bases then
43444: LD_EXP 76
43448: NOT
43449: IFFALSE 43453
// exit ;
43451: GO 43692
// for i = 1 to mc_bases do
43453: LD_ADDR_VAR 0 2
43457: PUSH
43458: DOUBLE
43459: LD_INT 1
43461: DEC
43462: ST_TO_ADDR
43463: LD_EXP 76
43467: PUSH
43468: FOR_TO
43469: IFFALSE 43690
// begin tmp := UnitFilter ( mc_bases [ i ] , [ f_type , unit_human ] ) union mc_ape [ i ] ;
43471: LD_ADDR_VAR 0 4
43475: PUSH
43476: LD_EXP 76
43480: PUSH
43481: LD_VAR 0 2
43485: ARRAY
43486: PPUSH
43487: LD_INT 21
43489: PUSH
43490: LD_INT 1
43492: PUSH
43493: EMPTY
43494: LIST
43495: LIST
43496: PPUSH
43497: CALL_OW 72
43501: PUSH
43502: LD_EXP 105
43506: PUSH
43507: LD_VAR 0 2
43511: ARRAY
43512: UNION
43513: ST_TO_ADDR
// if not tmp then
43514: LD_VAR 0 4
43518: NOT
43519: IFFALSE 43523
// continue ;
43521: GO 43468
// for j in tmp do
43523: LD_ADDR_VAR 0 3
43527: PUSH
43528: LD_VAR 0 4
43532: PUSH
43533: FOR_IN
43534: IFFALSE 43686
// begin if not GetTag ( j ) and not HasTask ( j ) and not IsDrivenBy ( j ) and not IsInUnit ( j ) and not j in mc_need_heal [ i ] [ 1 ] and not j in mc_need_heal [ i ] [ 2 ] and not j in mc_repair_vehicle [ i ] then
43536: LD_VAR 0 3
43540: PPUSH
43541: CALL_OW 110
43545: NOT
43546: PUSH
43547: LD_VAR 0 3
43551: PPUSH
43552: CALL_OW 314
43556: NOT
43557: AND
43558: PUSH
43559: LD_VAR 0 3
43563: PPUSH
43564: CALL_OW 311
43568: NOT
43569: AND
43570: PUSH
43571: LD_VAR 0 3
43575: PPUSH
43576: CALL_OW 310
43580: NOT
43581: AND
43582: PUSH
43583: LD_VAR 0 3
43587: PUSH
43588: LD_EXP 79
43592: PUSH
43593: LD_VAR 0 2
43597: ARRAY
43598: PUSH
43599: LD_INT 1
43601: ARRAY
43602: IN
43603: NOT
43604: AND
43605: PUSH
43606: LD_VAR 0 3
43610: PUSH
43611: LD_EXP 79
43615: PUSH
43616: LD_VAR 0 2
43620: ARRAY
43621: PUSH
43622: LD_INT 2
43624: ARRAY
43625: IN
43626: NOT
43627: AND
43628: PUSH
43629: LD_VAR 0 3
43633: PUSH
43634: LD_EXP 88
43638: PUSH
43639: LD_VAR 0 2
43643: ARRAY
43644: IN
43645: NOT
43646: AND
43647: IFFALSE 43684
// MC_Back ( i , mc_bases [ i ] , j , GetClass ( j ) ) ;
43649: LD_VAR 0 2
43653: PPUSH
43654: LD_EXP 76
43658: PUSH
43659: LD_VAR 0 2
43663: ARRAY
43664: PPUSH
43665: LD_VAR 0 3
43669: PPUSH
43670: LD_VAR 0 3
43674: PPUSH
43675: CALL_OW 257
43679: PPUSH
43680: CALL 42456 0 4
// end ;
43684: GO 43533
43686: POP
43687: POP
// end ;
43688: GO 43468
43690: POP
43691: POP
// end ;
43692: LD_VAR 0 1
43696: RET
// export function MC_SetMinesField ( base , amount , area ) ; var i , tmp , list , x , j ; begin
43697: LD_INT 0
43699: PPUSH
43700: PPUSH
43701: PPUSH
43702: PPUSH
43703: PPUSH
43704: PPUSH
// if not mc_bases [ base ] then
43705: LD_EXP 76
43709: PUSH
43710: LD_VAR 0 1
43714: ARRAY
43715: NOT
43716: IFFALSE 43720
// exit ;
43718: GO 43902
// tmp := [ ] ;
43720: LD_ADDR_VAR 0 6
43724: PUSH
43725: EMPTY
43726: ST_TO_ADDR
// list := AreaToList ( area , 0 ) ;
43727: LD_ADDR_VAR 0 7
43731: PUSH
43732: LD_VAR 0 3
43736: PPUSH
43737: LD_INT 0
43739: PPUSH
43740: CALL_OW 517
43744: ST_TO_ADDR
// if not list then
43745: LD_VAR 0 7
43749: NOT
43750: IFFALSE 43754
// exit ;
43752: GO 43902
// for i = 1 to amount do
43754: LD_ADDR_VAR 0 5
43758: PUSH
43759: DOUBLE
43760: LD_INT 1
43762: DEC
43763: ST_TO_ADDR
43764: LD_VAR 0 2
43768: PUSH
43769: FOR_TO
43770: IFFALSE 43850
// begin x := rand ( 1 , list [ 1 ] ) ;
43772: LD_ADDR_VAR 0 8
43776: PUSH
43777: LD_INT 1
43779: PPUSH
43780: LD_VAR 0 7
43784: PUSH
43785: LD_INT 1
43787: ARRAY
43788: PPUSH
43789: CALL_OW 12
43793: ST_TO_ADDR
// tmp := Replace ( tmp , i , [ list [ 1 ] [ x ] , list [ 2 ] [ x ] ] ) ;
43794: LD_ADDR_VAR 0 6
43798: PUSH
43799: LD_VAR 0 6
43803: PPUSH
43804: LD_VAR 0 5
43808: PPUSH
43809: LD_VAR 0 7
43813: PUSH
43814: LD_INT 1
43816: ARRAY
43817: PUSH
43818: LD_VAR 0 8
43822: ARRAY
43823: PUSH
43824: LD_VAR 0 7
43828: PUSH
43829: LD_INT 2
43831: ARRAY
43832: PUSH
43833: LD_VAR 0 8
43837: ARRAY
43838: PUSH
43839: EMPTY
43840: LIST
43841: LIST
43842: PPUSH
43843: CALL_OW 1
43847: ST_TO_ADDR
// end ;
43848: GO 43769
43850: POP
43851: POP
// mc_mines := Replace ( mc_mines , base , tmp ) ;
43852: LD_ADDR_EXP 89
43856: PUSH
43857: LD_EXP 89
43861: PPUSH
43862: LD_VAR 0 1
43866: PPUSH
43867: LD_VAR 0 6
43871: PPUSH
43872: CALL_OW 1
43876: ST_TO_ADDR
// mc_minefields := Replace ( mc_minefields , base , area ) ;
43877: LD_ADDR_EXP 91
43881: PUSH
43882: LD_EXP 91
43886: PPUSH
43887: LD_VAR 0 1
43891: PPUSH
43892: LD_VAR 0 3
43896: PPUSH
43897: CALL_OW 1
43901: ST_TO_ADDR
// end ;
43902: LD_VAR 0 4
43906: RET
// export function MC_SetBuildingList ( base , construct_list ) ; begin
43907: LD_INT 0
43909: PPUSH
// if not mc_bases [ base ] then
43910: LD_EXP 76
43914: PUSH
43915: LD_VAR 0 1
43919: ARRAY
43920: NOT
43921: IFFALSE 43925
// exit ;
43923: GO 43950
// mc_build_list := Replace ( mc_build_list , base , construct_list ) ;
43925: LD_ADDR_EXP 81
43929: PUSH
43930: LD_EXP 81
43934: PPUSH
43935: LD_VAR 0 1
43939: PPUSH
43940: LD_VAR 0 2
43944: PPUSH
43945: CALL_OW 1
43949: ST_TO_ADDR
// end ;
43950: LD_VAR 0 3
43954: RET
// export function MC_InsertBuildingList ( base , list ) ; begin
43955: LD_INT 0
43957: PPUSH
// if not mc_bases [ base ] then
43958: LD_EXP 76
43962: PUSH
43963: LD_VAR 0 1
43967: ARRAY
43968: NOT
43969: IFFALSE 43973
// exit ;
43971: GO 44010
// mc_build_list := Replace ( mc_build_list , base , mc_build_list [ base ] union list ) ;
43973: LD_ADDR_EXP 81
43977: PUSH
43978: LD_EXP 81
43982: PPUSH
43983: LD_VAR 0 1
43987: PPUSH
43988: LD_EXP 81
43992: PUSH
43993: LD_VAR 0 1
43997: ARRAY
43998: PUSH
43999: LD_VAR 0 2
44003: UNION
44004: PPUSH
44005: CALL_OW 1
44009: ST_TO_ADDR
// end ;
44010: LD_VAR 0 3
44014: RET
// export function MC_SetProduceList ( base , produce_list ) ; begin
44015: LD_INT 0
44017: PPUSH
// if not mc_bases [ base ] then
44018: LD_EXP 76
44022: PUSH
44023: LD_VAR 0 1
44027: ARRAY
44028: NOT
44029: IFFALSE 44033
// exit ;
44031: GO 44058
// mc_produce := Replace ( mc_produce , base , produce_list ) ;
44033: LD_ADDR_EXP 97
44037: PUSH
44038: LD_EXP 97
44042: PPUSH
44043: LD_VAR 0 1
44047: PPUSH
44048: LD_VAR 0 2
44052: PPUSH
44053: CALL_OW 1
44057: ST_TO_ADDR
// end ;
44058: LD_VAR 0 3
44062: RET
// export function MC_InsertProduceList ( base , components ) ; begin
44063: LD_INT 0
44065: PPUSH
// if not mc_bases [ base ] then
44066: LD_EXP 76
44070: PUSH
44071: LD_VAR 0 1
44075: ARRAY
44076: NOT
44077: IFFALSE 44081
// exit ;
44079: GO 44118
// mc_produce := Replace ( mc_produce , base , mc_produce [ base ] ^ components ) ;
44081: LD_ADDR_EXP 97
44085: PUSH
44086: LD_EXP 97
44090: PPUSH
44091: LD_VAR 0 1
44095: PPUSH
44096: LD_EXP 97
44100: PUSH
44101: LD_VAR 0 1
44105: ARRAY
44106: PUSH
44107: LD_VAR 0 2
44111: ADD
44112: PPUSH
44113: CALL_OW 1
44117: ST_TO_ADDR
// end ;
44118: LD_VAR 0 3
44122: RET
// export function MC_SetDefenderList ( base , deflist ) ; begin
44123: LD_INT 0
44125: PPUSH
// if not mc_bases [ base ] then
44126: LD_EXP 76
44130: PUSH
44131: LD_VAR 0 1
44135: ARRAY
44136: NOT
44137: IFFALSE 44141
// exit ;
44139: GO 44195
// mc_defender := Replace ( mc_defender , base , deflist ) ;
44141: LD_ADDR_EXP 98
44145: PUSH
44146: LD_EXP 98
44150: PPUSH
44151: LD_VAR 0 1
44155: PPUSH
44156: LD_VAR 0 2
44160: PPUSH
44161: CALL_OW 1
44165: ST_TO_ADDR
// mc_defender_limit := Replace ( mc_defender_limit , base , deflist + 0 ) ;
44166: LD_ADDR_EXP 87
44170: PUSH
44171: LD_EXP 87
44175: PPUSH
44176: LD_VAR 0 1
44180: PPUSH
44181: LD_VAR 0 2
44185: PUSH
44186: LD_INT 0
44188: PLUS
44189: PPUSH
44190: CALL_OW 1
44194: ST_TO_ADDR
// end ;
44195: LD_VAR 0 3
44199: RET
// export function MC_SetDefenderLimit ( base , limit ) ; begin
44200: LD_INT 0
44202: PPUSH
// if not mc_bases [ base ] then
44203: LD_EXP 76
44207: PUSH
44208: LD_VAR 0 1
44212: ARRAY
44213: NOT
44214: IFFALSE 44218
// exit ;
44216: GO 44243
// mc_defender_limit := Replace ( mc_defender_limit , base , limit ) ;
44218: LD_ADDR_EXP 87
44222: PUSH
44223: LD_EXP 87
44227: PPUSH
44228: LD_VAR 0 1
44232: PPUSH
44233: LD_VAR 0 2
44237: PPUSH
44238: CALL_OW 1
44242: ST_TO_ADDR
// end ;
44243: LD_VAR 0 3
44247: RET
// export function MC_PrepareAttack ( base , group , path , flags ) ; var i , j , tmp ; begin
44248: LD_INT 0
44250: PPUSH
44251: PPUSH
44252: PPUSH
44253: PPUSH
// if not mc_bases [ base ] then
44254: LD_EXP 76
44258: PUSH
44259: LD_VAR 0 1
44263: ARRAY
44264: NOT
44265: IFFALSE 44269
// exit ;
44267: GO 44334
// mc_attack := ReplaceIn ( mc_attack , [ base , mc_attack [ base ] + 1 ] , [ base , group , path , flags ] ) ;
44269: LD_ADDR_EXP 96
44273: PUSH
44274: LD_EXP 96
44278: PPUSH
44279: LD_VAR 0 1
44283: PUSH
44284: LD_EXP 96
44288: PUSH
44289: LD_VAR 0 1
44293: ARRAY
44294: PUSH
44295: LD_INT 1
44297: PLUS
44298: PUSH
44299: EMPTY
44300: LIST
44301: LIST
44302: PPUSH
44303: LD_VAR 0 1
44307: PUSH
44308: LD_VAR 0 2
44312: PUSH
44313: LD_VAR 0 3
44317: PUSH
44318: LD_VAR 0 4
44322: PUSH
44323: EMPTY
44324: LIST
44325: LIST
44326: LIST
44327: LIST
44328: PPUSH
44329: CALL 57644 0 3
44333: ST_TO_ADDR
// end ;
44334: LD_VAR 0 5
44338: RET
// export function MC_SetDepositsXY ( base , deposits_list ) ; begin
44339: LD_INT 0
44341: PPUSH
// if not mc_bases [ base ] then
44342: LD_EXP 76
44346: PUSH
44347: LD_VAR 0 1
44351: ARRAY
44352: NOT
44353: IFFALSE 44357
// exit ;
44355: GO 44382
// mc_deposits_xy := Replace ( mc_deposits_xy , base , deposits_list ) ;
44357: LD_ADDR_EXP 113
44361: PUSH
44362: LD_EXP 113
44366: PPUSH
44367: LD_VAR 0 1
44371: PPUSH
44372: LD_VAR 0 2
44376: PPUSH
44377: CALL_OW 1
44381: ST_TO_ADDR
// end ;
44382: LD_VAR 0 3
44386: RET
// export function MC_GetMinesField ( base ) ; begin
44387: LD_INT 0
44389: PPUSH
// result := mc_mines [ base ] ;
44390: LD_ADDR_VAR 0 2
44394: PUSH
44395: LD_EXP 89
44399: PUSH
44400: LD_VAR 0 1
44404: ARRAY
44405: ST_TO_ADDR
// end ;
44406: LD_VAR 0 2
44410: RET
// export function MC_GetProduceList ( base ) ; begin
44411: LD_INT 0
44413: PPUSH
// result := mc_produce [ base ] ;
44414: LD_ADDR_VAR 0 2
44418: PUSH
44419: LD_EXP 97
44423: PUSH
44424: LD_VAR 0 1
44428: ARRAY
44429: ST_TO_ADDR
// end ;
44430: LD_VAR 0 2
44434: RET
// export function MC_GetBuilding ( base , btype ) ; var i ; begin
44435: LD_INT 0
44437: PPUSH
44438: PPUSH
// if not mc_bases then
44439: LD_EXP 76
44443: NOT
44444: IFFALSE 44448
// exit ;
44446: GO 44513
// if mc_bases [ base ] then
44448: LD_EXP 76
44452: PUSH
44453: LD_VAR 0 1
44457: ARRAY
44458: IFFALSE 44513
// begin result := UnitFilter ( mc_bases [ base ] , [ f_btype , btype ] ) ;
44460: LD_ADDR_VAR 0 3
44464: PUSH
44465: LD_EXP 76
44469: PUSH
44470: LD_VAR 0 1
44474: ARRAY
44475: PPUSH
44476: LD_INT 30
44478: PUSH
44479: LD_VAR 0 2
44483: PUSH
44484: EMPTY
44485: LIST
44486: LIST
44487: PPUSH
44488: CALL_OW 72
44492: ST_TO_ADDR
// if result then
44493: LD_VAR 0 3
44497: IFFALSE 44513
// result := result [ 1 ] ;
44499: LD_ADDR_VAR 0 3
44503: PUSH
44504: LD_VAR 0 3
44508: PUSH
44509: LD_INT 1
44511: ARRAY
44512: ST_TO_ADDR
// end ; end ;
44513: LD_VAR 0 3
44517: RET
// export function MC_GetBuildings ( base , btype ) ; var i ; begin
44518: LD_INT 0
44520: PPUSH
44521: PPUSH
// if not mc_bases then
44522: LD_EXP 76
44526: NOT
44527: IFFALSE 44531
// exit ;
44529: GO 44576
// if mc_bases [ base ] then
44531: LD_EXP 76
44535: PUSH
44536: LD_VAR 0 1
44540: ARRAY
44541: IFFALSE 44576
// result := UnitFilter ( mc_bases [ base ] , [ f_btype , btype ] ) ;
44543: LD_ADDR_VAR 0 3
44547: PUSH
44548: LD_EXP 76
44552: PUSH
44553: LD_VAR 0 1
44557: ARRAY
44558: PPUSH
44559: LD_INT 30
44561: PUSH
44562: LD_VAR 0 2
44566: PUSH
44567: EMPTY
44568: LIST
44569: LIST
44570: PPUSH
44571: CALL_OW 72
44575: ST_TO_ADDR
// end ;
44576: LD_VAR 0 3
44580: RET
// export function MC_SetTame ( base , area ) ; begin
44581: LD_INT 0
44583: PPUSH
// if not mc_bases or not base then
44584: LD_EXP 76
44588: NOT
44589: PUSH
44590: LD_VAR 0 1
44594: NOT
44595: OR
44596: IFFALSE 44600
// exit ;
44598: GO 44625
// mc_can_tame := Replace ( mc_can_tame , base , area ) ;
44600: LD_ADDR_EXP 104
44604: PUSH
44605: LD_EXP 104
44609: PPUSH
44610: LD_VAR 0 1
44614: PPUSH
44615: LD_VAR 0 2
44619: PPUSH
44620: CALL_OW 1
44624: ST_TO_ADDR
// end ;
44625: LD_VAR 0 3
44629: RET
// export function MC_SetUpgradeBuilding ( base , btype ) ; var tmp ; begin
44630: LD_INT 0
44632: PPUSH
44633: PPUSH
// if not mc_bases or not base then
44634: LD_EXP 76
44638: NOT
44639: PUSH
44640: LD_VAR 0 1
44644: NOT
44645: OR
44646: IFFALSE 44650
// exit ;
44648: GO 44752
// tmp := UnitFilter ( mc_bases [ base ] , [ f_btype , btype ] ) ;
44650: LD_ADDR_VAR 0 4
44654: PUSH
44655: LD_EXP 76
44659: PUSH
44660: LD_VAR 0 1
44664: ARRAY
44665: PPUSH
44666: LD_INT 30
44668: PUSH
44669: LD_VAR 0 2
44673: PUSH
44674: EMPTY
44675: LIST
44676: LIST
44677: PPUSH
44678: CALL_OW 72
44682: ST_TO_ADDR
// if not tmp then
44683: LD_VAR 0 4
44687: NOT
44688: IFFALSE 44692
// exit ;
44690: GO 44752
// mc_build_upgrade := Replace ( mc_build_upgrade , base , Insert ( mc_build_upgrade [ base ] , mc_build_upgrade [ base ] + 1 , tmp [ 1 ] ) ) ;
44692: LD_ADDR_EXP 108
44696: PUSH
44697: LD_EXP 108
44701: PPUSH
44702: LD_VAR 0 1
44706: PPUSH
44707: LD_EXP 108
44711: PUSH
44712: LD_VAR 0 1
44716: ARRAY
44717: PPUSH
44718: LD_EXP 108
44722: PUSH
44723: LD_VAR 0 1
44727: ARRAY
44728: PUSH
44729: LD_INT 1
44731: PLUS
44732: PPUSH
44733: LD_VAR 0 4
44737: PUSH
44738: LD_INT 1
44740: ARRAY
44741: PPUSH
44742: CALL_OW 2
44746: PPUSH
44747: CALL_OW 1
44751: ST_TO_ADDR
// end ;
44752: LD_VAR 0 3
44756: RET
// export function MC_SetLabKind ( base , kinds ) ; var i ; begin
44757: LD_INT 0
44759: PPUSH
44760: PPUSH
// if not mc_bases or not base or not kinds then
44761: LD_EXP 76
44765: NOT
44766: PUSH
44767: LD_VAR 0 1
44771: NOT
44772: OR
44773: PUSH
44774: LD_VAR 0 2
44778: NOT
44779: OR
44780: IFFALSE 44784
// exit ;
44782: GO 44845
// for i in kinds do
44784: LD_ADDR_VAR 0 4
44788: PUSH
44789: LD_VAR 0 2
44793: PUSH
44794: FOR_IN
44795: IFFALSE 44843
// mc_lab_upgrade := ReplaceIn ( mc_lab_upgrade , [ base , mc_lab_upgrade [ base ] + 1 ] , i ) ;
44797: LD_ADDR_EXP 110
44801: PUSH
44802: LD_EXP 110
44806: PPUSH
44807: LD_VAR 0 1
44811: PUSH
44812: LD_EXP 110
44816: PUSH
44817: LD_VAR 0 1
44821: ARRAY
44822: PUSH
44823: LD_INT 1
44825: PLUS
44826: PUSH
44827: EMPTY
44828: LIST
44829: LIST
44830: PPUSH
44831: LD_VAR 0 4
44835: PPUSH
44836: CALL 57644 0 3
44840: ST_TO_ADDR
44841: GO 44794
44843: POP
44844: POP
// end ;
44845: LD_VAR 0 3
44849: RET
// export function MC_SetCratesArea ( base , areas ) ; begin
44850: LD_INT 0
44852: PPUSH
// if not mc_bases or not base or not areas then
44853: LD_EXP 76
44857: NOT
44858: PUSH
44859: LD_VAR 0 1
44863: NOT
44864: OR
44865: PUSH
44866: LD_VAR 0 2
44870: NOT
44871: OR
44872: IFFALSE 44876
// exit ;
44874: GO 44901
// mc_crates_area := Replace ( mc_crates_area , base , areas ) ;
44876: LD_ADDR_EXP 94
44880: PUSH
44881: LD_EXP 94
44885: PPUSH
44886: LD_VAR 0 1
44890: PPUSH
44891: LD_VAR 0 2
44895: PPUSH
44896: CALL_OW 1
44900: ST_TO_ADDR
// end ;
44901: LD_VAR 0 3
44905: RET
// export function MC_SetTeleportExit ( base , teleports_exit ) ; begin
44906: LD_INT 0
44908: PPUSH
// if not mc_bases or not base or not teleports_exit then
44909: LD_EXP 76
44913: NOT
44914: PUSH
44915: LD_VAR 0 1
44919: NOT
44920: OR
44921: PUSH
44922: LD_VAR 0 2
44926: NOT
44927: OR
44928: IFFALSE 44932
// exit ;
44930: GO 44957
// mc_teleport_exit := Replace ( mc_teleport_exit , base , teleports_exit ) ;
44932: LD_ADDR_EXP 111
44936: PUSH
44937: LD_EXP 111
44941: PPUSH
44942: LD_VAR 0 1
44946: PPUSH
44947: LD_VAR 0 2
44951: PPUSH
44952: CALL_OW 1
44956: ST_TO_ADDR
// end ;
44957: LD_VAR 0 3
44961: RET
// export function MC_SetFactoryExtension ( base , x , y , d , ext_list ) ; var i , tmp ; begin
44962: LD_INT 0
44964: PPUSH
44965: PPUSH
44966: PPUSH
// if not mc_bases or not base or not ext_list then
44967: LD_EXP 76
44971: NOT
44972: PUSH
44973: LD_VAR 0 1
44977: NOT
44978: OR
44979: PUSH
44980: LD_VAR 0 5
44984: NOT
44985: OR
44986: IFFALSE 44990
// exit ;
44988: GO 45163
// tmp := GetFacExtXYD ( x , y , d ) ;
44990: LD_ADDR_VAR 0 8
44994: PUSH
44995: LD_VAR 0 2
44999: PPUSH
45000: LD_VAR 0 3
45004: PPUSH
45005: LD_VAR 0 4
45009: PPUSH
45010: CALL 91025 0 3
45014: ST_TO_ADDR
// if not tmp then
45015: LD_VAR 0 8
45019: NOT
45020: IFFALSE 45024
// exit ;
45022: GO 45163
// for i in tmp do
45024: LD_ADDR_VAR 0 7
45028: PUSH
45029: LD_VAR 0 8
45033: PUSH
45034: FOR_IN
45035: IFFALSE 45161
// begin mc_build_list := Replace ( mc_build_list , base , Insert ( mc_build_list [ base ] , mc_build_list [ base ] + 1 , [ ext_list [ 1 ] , i [ 1 ] , i [ 2 ] , i [ 3 ] ] ) ) ;
45037: LD_ADDR_EXP 81
45041: PUSH
45042: LD_EXP 81
45046: PPUSH
45047: LD_VAR 0 1
45051: PPUSH
45052: LD_EXP 81
45056: PUSH
45057: LD_VAR 0 1
45061: ARRAY
45062: PPUSH
45063: LD_EXP 81
45067: PUSH
45068: LD_VAR 0 1
45072: ARRAY
45073: PUSH
45074: LD_INT 1
45076: PLUS
45077: PPUSH
45078: LD_VAR 0 5
45082: PUSH
45083: LD_INT 1
45085: ARRAY
45086: PUSH
45087: LD_VAR 0 7
45091: PUSH
45092: LD_INT 1
45094: ARRAY
45095: PUSH
45096: LD_VAR 0 7
45100: PUSH
45101: LD_INT 2
45103: ARRAY
45104: PUSH
45105: LD_VAR 0 7
45109: PUSH
45110: LD_INT 3
45112: ARRAY
45113: PUSH
45114: EMPTY
45115: LIST
45116: LIST
45117: LIST
45118: LIST
45119: PPUSH
45120: CALL_OW 2
45124: PPUSH
45125: CALL_OW 1
45129: ST_TO_ADDR
// ext_list := Delete ( ext_list , 1 ) ;
45130: LD_ADDR_VAR 0 5
45134: PUSH
45135: LD_VAR 0 5
45139: PPUSH
45140: LD_INT 1
45142: PPUSH
45143: CALL_OW 3
45147: ST_TO_ADDR
// if not ext_list then
45148: LD_VAR 0 5
45152: NOT
45153: IFFALSE 45159
// exit ;
45155: POP
45156: POP
45157: GO 45163
// end ;
45159: GO 45034
45161: POP
45162: POP
// end ;
45163: LD_VAR 0 6
45167: RET
// export function MC_SetAllowedTurretWeapons ( base , weapon_list ) ; begin
45168: LD_INT 0
45170: PPUSH
// if not mc_bases or not base or not weapon_list then
45171: LD_EXP 76
45175: NOT
45176: PUSH
45177: LD_VAR 0 1
45181: NOT
45182: OR
45183: PUSH
45184: LD_VAR 0 2
45188: NOT
45189: OR
45190: IFFALSE 45194
// exit ;
45192: GO 45219
// mc_allowed_tower_weapons := Replace ( mc_allowed_tower_weapons , base , weapon_list ) ;
45194: LD_ADDR_EXP 115
45198: PUSH
45199: LD_EXP 115
45203: PPUSH
45204: LD_VAR 0 1
45208: PPUSH
45209: LD_VAR 0 2
45213: PPUSH
45214: CALL_OW 1
45218: ST_TO_ADDR
// end ;
45219: LD_VAR 0 3
45223: RET
// export function MC_SetTechList ( base , tech_list ) ; begin
45224: LD_INT 0
45226: PPUSH
// if not mc_bases or not base or not tech_list then
45227: LD_EXP 76
45231: NOT
45232: PUSH
45233: LD_VAR 0 1
45237: NOT
45238: OR
45239: PUSH
45240: LD_VAR 0 2
45244: NOT
45245: OR
45246: IFFALSE 45250
// exit ;
45248: GO 45275
// mc_tech := Replace ( mc_tech , base , tech_list ) ;
45250: LD_ADDR_EXP 103
45254: PUSH
45255: LD_EXP 103
45259: PPUSH
45260: LD_VAR 0 1
45264: PPUSH
45265: LD_VAR 0 2
45269: PPUSH
45270: CALL_OW 1
45274: ST_TO_ADDR
// end ;
45275: LD_VAR 0 3
45279: RET
// export function MC_SetParkingArea ( base , parking_area ) ; begin
45280: LD_INT 0
45282: PPUSH
// if not mc_bases or not parking_area or not base then
45283: LD_EXP 76
45287: NOT
45288: PUSH
45289: LD_VAR 0 2
45293: NOT
45294: OR
45295: PUSH
45296: LD_VAR 0 1
45300: NOT
45301: OR
45302: IFFALSE 45306
// exit ;
45304: GO 45331
// mc_parking := Replace ( mc_parking , base , parking_area ) ;
45306: LD_ADDR_EXP 100
45310: PUSH
45311: LD_EXP 100
45315: PPUSH
45316: LD_VAR 0 1
45320: PPUSH
45321: LD_VAR 0 2
45325: PPUSH
45326: CALL_OW 1
45330: ST_TO_ADDR
// end ;
45331: LD_VAR 0 3
45335: RET
// export function MC_SetScanArea ( base , scan_area ) ; begin
45336: LD_INT 0
45338: PPUSH
// if not mc_bases or not base or not scan_area then
45339: LD_EXP 76
45343: NOT
45344: PUSH
45345: LD_VAR 0 1
45349: NOT
45350: OR
45351: PUSH
45352: LD_VAR 0 2
45356: NOT
45357: OR
45358: IFFALSE 45362
// exit ;
45360: GO 45387
// mc_scan_area := Replace ( mc_scan_area , base , scan_area ) ;
45362: LD_ADDR_EXP 101
45366: PUSH
45367: LD_EXP 101
45371: PPUSH
45372: LD_VAR 0 1
45376: PPUSH
45377: LD_VAR 0 2
45381: PPUSH
45382: CALL_OW 1
45386: ST_TO_ADDR
// end ;
45387: LD_VAR 0 3
45391: RET
// export function MC_NotTameApeman ( base ) ; var ape_techs ; begin
45392: LD_INT 0
45394: PPUSH
45395: PPUSH
// if not mc_bases or not base then
45396: LD_EXP 76
45400: NOT
45401: PUSH
45402: LD_VAR 0 1
45406: NOT
45407: OR
45408: IFFALSE 45412
// exit ;
45410: GO 45476
// ape_techs := [ 1 , 2 , 3 , 4 , 11 ] ;
45412: LD_ADDR_VAR 0 3
45416: PUSH
45417: LD_INT 1
45419: PUSH
45420: LD_INT 2
45422: PUSH
45423: LD_INT 3
45425: PUSH
45426: LD_INT 4
45428: PUSH
45429: LD_INT 11
45431: PUSH
45432: EMPTY
45433: LIST
45434: LIST
45435: LIST
45436: LIST
45437: LIST
45438: ST_TO_ADDR
// mc_tech := Replace ( mc_tech , base , mc_tech [ base ] diff ape_techs ) ;
45439: LD_ADDR_EXP 103
45443: PUSH
45444: LD_EXP 103
45448: PPUSH
45449: LD_VAR 0 1
45453: PPUSH
45454: LD_EXP 103
45458: PUSH
45459: LD_VAR 0 1
45463: ARRAY
45464: PUSH
45465: LD_VAR 0 3
45469: DIFF
45470: PPUSH
45471: CALL_OW 1
45475: ST_TO_ADDR
// end ;
45476: LD_VAR 0 2
45480: RET
// export function MC_GetVehicles ( base , onlyCombat ) ; begin
45481: LD_INT 0
45483: PPUSH
// result := mc_vehicles [ base ] ;
45484: LD_ADDR_VAR 0 3
45488: PUSH
45489: LD_EXP 95
45493: PUSH
45494: LD_VAR 0 1
45498: ARRAY
45499: ST_TO_ADDR
// if onlyCombat then
45500: LD_VAR 0 2
45504: IFFALSE 45669
// result := result diff UnitFilter ( result , [ f_or , [ f_weapon , us_cargo_bay ] , [ f_weapon , ru_cargo_bay ] , [ f_weapon , ru_big_cargo_bay ] , [ f_weapon , ar_cargo_bay ] , [ f_weapon , us_crane ] , [ f_weapon , ru_crane ] , [ f_weapon , us_bulldozer ] , [ f_weapon , ru_bulldozer ] , [ f_weapon , ru_radar ] , [ f_weapon , ar_control_tower ] , [ f_weapon , ru_siberium_rocket ] , [ f_weapon , us_siberium_rocket ] ] ) ;
45506: LD_ADDR_VAR 0 3
45510: PUSH
45511: LD_VAR 0 3
45515: PUSH
45516: LD_VAR 0 3
45520: PPUSH
45521: LD_INT 2
45523: PUSH
45524: LD_INT 34
45526: PUSH
45527: LD_INT 12
45529: PUSH
45530: EMPTY
45531: LIST
45532: LIST
45533: PUSH
45534: LD_INT 34
45536: PUSH
45537: LD_INT 51
45539: PUSH
45540: EMPTY
45541: LIST
45542: LIST
45543: PUSH
45544: LD_INT 34
45546: PUSH
45547: LD_EXP 70
45551: PUSH
45552: EMPTY
45553: LIST
45554: LIST
45555: PUSH
45556: LD_INT 34
45558: PUSH
45559: LD_INT 32
45561: PUSH
45562: EMPTY
45563: LIST
45564: LIST
45565: PUSH
45566: LD_INT 34
45568: PUSH
45569: LD_INT 13
45571: PUSH
45572: EMPTY
45573: LIST
45574: LIST
45575: PUSH
45576: LD_INT 34
45578: PUSH
45579: LD_INT 52
45581: PUSH
45582: EMPTY
45583: LIST
45584: LIST
45585: PUSH
45586: LD_INT 34
45588: PUSH
45589: LD_INT 14
45591: PUSH
45592: EMPTY
45593: LIST
45594: LIST
45595: PUSH
45596: LD_INT 34
45598: PUSH
45599: LD_INT 53
45601: PUSH
45602: EMPTY
45603: LIST
45604: LIST
45605: PUSH
45606: LD_INT 34
45608: PUSH
45609: LD_EXP 69
45613: PUSH
45614: EMPTY
45615: LIST
45616: LIST
45617: PUSH
45618: LD_INT 34
45620: PUSH
45621: LD_INT 31
45623: PUSH
45624: EMPTY
45625: LIST
45626: LIST
45627: PUSH
45628: LD_INT 34
45630: PUSH
45631: LD_INT 48
45633: PUSH
45634: EMPTY
45635: LIST
45636: LIST
45637: PUSH
45638: LD_INT 34
45640: PUSH
45641: LD_INT 8
45643: PUSH
45644: EMPTY
45645: LIST
45646: LIST
45647: PUSH
45648: EMPTY
45649: LIST
45650: LIST
45651: LIST
45652: LIST
45653: LIST
45654: LIST
45655: LIST
45656: LIST
45657: LIST
45658: LIST
45659: LIST
45660: LIST
45661: LIST
45662: PPUSH
45663: CALL_OW 72
45667: DIFF
45668: ST_TO_ADDR
// end ; end_of_file
45669: LD_VAR 0 3
45673: RET
// export function MCE_ApemanTamed ( ape , sci ) ; var i , tmp ; begin
45674: LD_INT 0
45676: PPUSH
45677: PPUSH
45678: PPUSH
// if not mc_bases or not skirmish then
45679: LD_EXP 76
45683: NOT
45684: PUSH
45685: LD_EXP 74
45689: NOT
45690: OR
45691: IFFALSE 45695
// exit ;
45693: GO 45860
// for i = 1 to mc_bases do
45695: LD_ADDR_VAR 0 4
45699: PUSH
45700: DOUBLE
45701: LD_INT 1
45703: DEC
45704: ST_TO_ADDR
45705: LD_EXP 76
45709: PUSH
45710: FOR_TO
45711: IFFALSE 45858
// begin if sci in mc_bases [ i ] then
45713: LD_VAR 0 2
45717: PUSH
45718: LD_EXP 76
45722: PUSH
45723: LD_VAR 0 4
45727: ARRAY
45728: IN
45729: IFFALSE 45856
// begin mc_ape := ReplaceIn ( mc_ape , [ i , mc_ape [ i ] + 1 ] , ape ) ;
45731: LD_ADDR_EXP 105
45735: PUSH
45736: LD_EXP 105
45740: PPUSH
45741: LD_VAR 0 4
45745: PUSH
45746: LD_EXP 105
45750: PUSH
45751: LD_VAR 0 4
45755: ARRAY
45756: PUSH
45757: LD_INT 1
45759: PLUS
45760: PUSH
45761: EMPTY
45762: LIST
45763: LIST
45764: PPUSH
45765: LD_VAR 0 1
45769: PPUSH
45770: CALL 57644 0 3
45774: ST_TO_ADDR
// tmp := NearestUnitToUnit ( UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) , ape ) ;
45775: LD_ADDR_VAR 0 5
45779: PUSH
45780: LD_EXP 76
45784: PUSH
45785: LD_VAR 0 4
45789: ARRAY
45790: PPUSH
45791: LD_INT 2
45793: PUSH
45794: LD_INT 30
45796: PUSH
45797: LD_INT 0
45799: PUSH
45800: EMPTY
45801: LIST
45802: LIST
45803: PUSH
45804: LD_INT 30
45806: PUSH
45807: LD_INT 1
45809: PUSH
45810: EMPTY
45811: LIST
45812: LIST
45813: PUSH
45814: EMPTY
45815: LIST
45816: LIST
45817: LIST
45818: PPUSH
45819: CALL_OW 72
45823: PPUSH
45824: LD_VAR 0 1
45828: PPUSH
45829: CALL_OW 74
45833: ST_TO_ADDR
// if tmp then
45834: LD_VAR 0 5
45838: IFFALSE 45854
// ComStandNearbyBuilding ( ape , tmp ) ;
45840: LD_VAR 0 1
45844: PPUSH
45845: LD_VAR 0 5
45849: PPUSH
45850: CALL 51847 0 2
// break ;
45854: GO 45858
// end ; end ;
45856: GO 45710
45858: POP
45859: POP
// end ;
45860: LD_VAR 0 3
45864: RET
// export function MCE_EnterBuilding ( building , unit ) ; var i , tmp ; begin
45865: LD_INT 0
45867: PPUSH
45868: PPUSH
45869: PPUSH
// if not mc_bases or not skirmish then
45870: LD_EXP 76
45874: NOT
45875: PUSH
45876: LD_EXP 74
45880: NOT
45881: OR
45882: IFFALSE 45886
// exit ;
45884: GO 45975
// for i = 1 to mc_bases do
45886: LD_ADDR_VAR 0 4
45890: PUSH
45891: DOUBLE
45892: LD_INT 1
45894: DEC
45895: ST_TO_ADDR
45896: LD_EXP 76
45900: PUSH
45901: FOR_TO
45902: IFFALSE 45973
// begin if building in mc_busy_turret_list [ i ] then
45904: LD_VAR 0 1
45908: PUSH
45909: LD_EXP 86
45913: PUSH
45914: LD_VAR 0 4
45918: ARRAY
45919: IN
45920: IFFALSE 45971
// begin tmp := mc_busy_turret_list [ i ] diff building ;
45922: LD_ADDR_VAR 0 5
45926: PUSH
45927: LD_EXP 86
45931: PUSH
45932: LD_VAR 0 4
45936: ARRAY
45937: PUSH
45938: LD_VAR 0 1
45942: DIFF
45943: ST_TO_ADDR
// mc_busy_turret_list := Replace ( mc_busy_turret_list , i , tmp ) ;
45944: LD_ADDR_EXP 86
45948: PUSH
45949: LD_EXP 86
45953: PPUSH
45954: LD_VAR 0 4
45958: PPUSH
45959: LD_VAR 0 5
45963: PPUSH
45964: CALL_OW 1
45968: ST_TO_ADDR
// break ;
45969: GO 45973
// end ; end ;
45971: GO 45901
45973: POP
45974: POP
// end ;
45975: LD_VAR 0 3
45979: RET
// export function MCE_BuildingCaptured ( building , side , capturning_unit ) ; var i , tmp ; begin
45980: LD_INT 0
45982: PPUSH
45983: PPUSH
45984: PPUSH
// if not mc_bases or not skirmish then
45985: LD_EXP 76
45989: NOT
45990: PUSH
45991: LD_EXP 74
45995: NOT
45996: OR
45997: IFFALSE 46001
// exit ;
45999: GO 46200
// for i = 1 to mc_bases do
46001: LD_ADDR_VAR 0 5
46005: PUSH
46006: DOUBLE
46007: LD_INT 1
46009: DEC
46010: ST_TO_ADDR
46011: LD_EXP 76
46015: PUSH
46016: FOR_TO
46017: IFFALSE 46198
// if building in mc_bases [ i ] then
46019: LD_VAR 0 1
46023: PUSH
46024: LD_EXP 76
46028: PUSH
46029: LD_VAR 0 5
46033: ARRAY
46034: IN
46035: IFFALSE 46196
// begin tmp := mc_bases [ i ] diff building ;
46037: LD_ADDR_VAR 0 6
46041: PUSH
46042: LD_EXP 76
46046: PUSH
46047: LD_VAR 0 5
46051: ARRAY
46052: PUSH
46053: LD_VAR 0 1
46057: DIFF
46058: ST_TO_ADDR
// mc_bases := Replace ( mc_bases , i , tmp ) ;
46059: LD_ADDR_EXP 76
46063: PUSH
46064: LD_EXP 76
46068: PPUSH
46069: LD_VAR 0 5
46073: PPUSH
46074: LD_VAR 0 6
46078: PPUSH
46079: CALL_OW 1
46083: ST_TO_ADDR
// if building in mc_turret_list [ i ] then
46084: LD_VAR 0 1
46088: PUSH
46089: LD_EXP 84
46093: PUSH
46094: LD_VAR 0 5
46098: ARRAY
46099: IN
46100: IFFALSE 46139
// mc_turret_list := Replace ( mc_turret_list , i , mc_turret_list [ i ] diff building ) ;
46102: LD_ADDR_EXP 84
46106: PUSH
46107: LD_EXP 84
46111: PPUSH
46112: LD_VAR 0 5
46116: PPUSH
46117: LD_EXP 84
46121: PUSH
46122: LD_VAR 0 5
46126: ARRAY
46127: PUSH
46128: LD_VAR 0 1
46132: DIFF
46133: PPUSH
46134: CALL_OW 1
46138: ST_TO_ADDR
// if building in mc_empty_turret_list [ i ] then
46139: LD_VAR 0 1
46143: PUSH
46144: LD_EXP 85
46148: PUSH
46149: LD_VAR 0 5
46153: ARRAY
46154: IN
46155: IFFALSE 46194
// mc_empty_turret_list := Replace ( mc_empty_turret_list , i , mc_empty_turret_list [ i ] diff building ) ;
46157: LD_ADDR_EXP 85
46161: PUSH
46162: LD_EXP 85
46166: PPUSH
46167: LD_VAR 0 5
46171: PPUSH
46172: LD_EXP 85
46176: PUSH
46177: LD_VAR 0 5
46181: ARRAY
46182: PUSH
46183: LD_VAR 0 1
46187: DIFF
46188: PPUSH
46189: CALL_OW 1
46193: ST_TO_ADDR
// break ;
46194: GO 46198
// end ;
46196: GO 46016
46198: POP
46199: POP
// end ;
46200: LD_VAR 0 4
46204: RET
// export function MCE_VehicleCaptured ( new , old , side , capturing_unit ) ; var i , tmp ; begin
46205: LD_INT 0
46207: PPUSH
46208: PPUSH
46209: PPUSH
// if not mc_bases or not skirmish or not side in mc_sides then
46210: LD_EXP 76
46214: NOT
46215: PUSH
46216: LD_EXP 74
46220: NOT
46221: OR
46222: PUSH
46223: LD_VAR 0 3
46227: PUSH
46228: LD_EXP 102
46232: IN
46233: NOT
46234: OR
46235: IFFALSE 46239
// exit ;
46237: GO 46362
// for i = 1 to mc_vehicles do
46239: LD_ADDR_VAR 0 6
46243: PUSH
46244: DOUBLE
46245: LD_INT 1
46247: DEC
46248: ST_TO_ADDR
46249: LD_EXP 95
46253: PUSH
46254: FOR_TO
46255: IFFALSE 46360
// if old in mc_vehicles [ i ] or new in mc_vehicles [ i ] then
46257: LD_VAR 0 2
46261: PUSH
46262: LD_EXP 95
46266: PUSH
46267: LD_VAR 0 6
46271: ARRAY
46272: IN
46273: PUSH
46274: LD_VAR 0 1
46278: PUSH
46279: LD_EXP 95
46283: PUSH
46284: LD_VAR 0 6
46288: ARRAY
46289: IN
46290: OR
46291: IFFALSE 46358
// begin tmp := mc_vehicles [ i ] diff old ;
46293: LD_ADDR_VAR 0 7
46297: PUSH
46298: LD_EXP 95
46302: PUSH
46303: LD_VAR 0 6
46307: ARRAY
46308: PUSH
46309: LD_VAR 0 2
46313: DIFF
46314: ST_TO_ADDR
// tmp := tmp diff new ;
46315: LD_ADDR_VAR 0 7
46319: PUSH
46320: LD_VAR 0 7
46324: PUSH
46325: LD_VAR 0 1
46329: DIFF
46330: ST_TO_ADDR
// mc_vehicles := Replace ( mc_vehicles , i , tmp ) ;
46331: LD_ADDR_EXP 95
46335: PUSH
46336: LD_EXP 95
46340: PPUSH
46341: LD_VAR 0 6
46345: PPUSH
46346: LD_VAR 0 7
46350: PPUSH
46351: CALL_OW 1
46355: ST_TO_ADDR
// break ;
46356: GO 46360
// end ;
46358: GO 46254
46360: POP
46361: POP
// end ;
46362: LD_VAR 0 5
46366: RET
// export function MCE_VehicleConstructed ( vehicle , factory ) ; var i , side , tmp ; begin
46367: LD_INT 0
46369: PPUSH
46370: PPUSH
46371: PPUSH
46372: PPUSH
// if not mc_bases or not skirmish then
46373: LD_EXP 76
46377: NOT
46378: PUSH
46379: LD_EXP 74
46383: NOT
46384: OR
46385: IFFALSE 46389
// exit ;
46387: GO 46766
// side := GetSide ( vehicle ) ;
46389: LD_ADDR_VAR 0 5
46393: PUSH
46394: LD_VAR 0 1
46398: PPUSH
46399: CALL_OW 255
46403: ST_TO_ADDR
// for i = 1 to mc_bases do
46404: LD_ADDR_VAR 0 4
46408: PUSH
46409: DOUBLE
46410: LD_INT 1
46412: DEC
46413: ST_TO_ADDR
46414: LD_EXP 76
46418: PUSH
46419: FOR_TO
46420: IFFALSE 46764
// begin if factory in mc_bases [ i ] then
46422: LD_VAR 0 2
46426: PUSH
46427: LD_EXP 76
46431: PUSH
46432: LD_VAR 0 4
46436: ARRAY
46437: IN
46438: IFFALSE 46762
// begin if mc_defender [ i ] < mc_defender_limit [ i ] and not GetWeapon ( vehicle ) in [ ar_control_tower , ar_cargo_bay , ru_cargo_bay , ru_big_cargo_bay , us_cargo_bay , ar_radar , ru_radar , us_radar , ru_bulldozer , us_bulldozer , ar_bio_bomb , ar_selfpropelled_bomb , us_hack , us_crane , ru_crane , ru_siberium_rocket , us_siberium_rocket ] then
46440: LD_EXP 98
46444: PUSH
46445: LD_VAR 0 4
46449: ARRAY
46450: PUSH
46451: LD_EXP 87
46455: PUSH
46456: LD_VAR 0 4
46460: ARRAY
46461: LESS
46462: PUSH
46463: LD_VAR 0 1
46467: PPUSH
46468: CALL_OW 264
46472: PUSH
46473: LD_INT 31
46475: PUSH
46476: LD_INT 32
46478: PUSH
46479: LD_INT 51
46481: PUSH
46482: LD_EXP 70
46486: PUSH
46487: LD_INT 12
46489: PUSH
46490: LD_INT 30
46492: PUSH
46493: LD_EXP 69
46497: PUSH
46498: LD_INT 11
46500: PUSH
46501: LD_INT 53
46503: PUSH
46504: LD_INT 14
46506: PUSH
46507: LD_EXP 73
46511: PUSH
46512: LD_INT 29
46514: PUSH
46515: LD_EXP 71
46519: PUSH
46520: LD_INT 13
46522: PUSH
46523: LD_INT 52
46525: PUSH
46526: LD_INT 48
46528: PUSH
46529: LD_INT 8
46531: PUSH
46532: EMPTY
46533: LIST
46534: LIST
46535: LIST
46536: LIST
46537: LIST
46538: LIST
46539: LIST
46540: LIST
46541: LIST
46542: LIST
46543: LIST
46544: LIST
46545: LIST
46546: LIST
46547: LIST
46548: LIST
46549: LIST
46550: IN
46551: NOT
46552: AND
46553: IFFALSE 46601
// mc_defender := ReplaceIn ( mc_defender , [ i , mc_defender [ i ] + 1 ] , vehicle ) else
46555: LD_ADDR_EXP 98
46559: PUSH
46560: LD_EXP 98
46564: PPUSH
46565: LD_VAR 0 4
46569: PUSH
46570: LD_EXP 98
46574: PUSH
46575: LD_VAR 0 4
46579: ARRAY
46580: PUSH
46581: LD_INT 1
46583: PLUS
46584: PUSH
46585: EMPTY
46586: LIST
46587: LIST
46588: PPUSH
46589: LD_VAR 0 1
46593: PPUSH
46594: CALL 57644 0 3
46598: ST_TO_ADDR
46599: GO 46645
// mc_vehicles := ReplaceIn ( mc_vehicles , [ i , mc_vehicles [ i ] + 1 ] , vehicle ) ;
46601: LD_ADDR_EXP 95
46605: PUSH
46606: LD_EXP 95
46610: PPUSH
46611: LD_VAR 0 4
46615: PUSH
46616: LD_EXP 95
46620: PUSH
46621: LD_VAR 0 4
46625: ARRAY
46626: PUSH
46627: LD_INT 1
46629: PLUS
46630: PUSH
46631: EMPTY
46632: LIST
46633: LIST
46634: PPUSH
46635: LD_VAR 0 1
46639: PPUSH
46640: CALL 57644 0 3
46644: ST_TO_ADDR
// if GetControl ( vehicle ) = control_remote then
46645: LD_VAR 0 1
46649: PPUSH
46650: CALL_OW 263
46654: PUSH
46655: LD_INT 2
46657: EQUAL
46658: IFFALSE 46678
// begin repeat wait ( 0 0$1 ) ;
46660: LD_INT 35
46662: PPUSH
46663: CALL_OW 67
// until IsControledBy ( vehicle ) ;
46667: LD_VAR 0 1
46671: PPUSH
46672: CALL_OW 312
46676: IFFALSE 46660
// end ; ComMoveToArea ( vehicle , mc_parking [ i ] ) ;
46678: LD_VAR 0 1
46682: PPUSH
46683: LD_EXP 100
46687: PUSH
46688: LD_VAR 0 4
46692: ARRAY
46693: PPUSH
46694: CALL_OW 113
// if GetControl ( vehicle ) <> control_manual then
46698: LD_VAR 0 1
46702: PPUSH
46703: CALL_OW 263
46707: PUSH
46708: LD_INT 1
46710: NONEQUAL
46711: IFFALSE 46715
// break ;
46713: GO 46764
// repeat wait ( 0 0$1 ) ;
46715: LD_INT 35
46717: PPUSH
46718: CALL_OW 67
// until IsInArea ( vehicle , mc_parking [ i ] ) ;
46722: LD_VAR 0 1
46726: PPUSH
46727: LD_EXP 100
46731: PUSH
46732: LD_VAR 0 4
46736: ARRAY
46737: PPUSH
46738: CALL_OW 308
46742: IFFALSE 46715
// ComExitVehicle ( IsDrivenBy ( vehicle ) ) ;
46744: LD_VAR 0 1
46748: PPUSH
46749: CALL_OW 311
46753: PPUSH
46754: CALL_OW 121
// exit ;
46758: POP
46759: POP
46760: GO 46766
// end ; end ;
46762: GO 46419
46764: POP
46765: POP
// end ;
46766: LD_VAR 0 3
46770: RET
// export function MCE_CrateSpawn ( id , x , y , amount , mode ) ; var i , j , depot ; begin
46771: LD_INT 0
46773: PPUSH
46774: PPUSH
46775: PPUSH
46776: PPUSH
// if not mc_bases or not skirmish then
46777: LD_EXP 76
46781: NOT
46782: PUSH
46783: LD_EXP 74
46787: NOT
46788: OR
46789: IFFALSE 46793
// exit ;
46791: GO 47146
// repeat wait ( 0 0$1 ) ;
46793: LD_INT 35
46795: PPUSH
46796: CALL_OW 67
// until GetResourceAmountXY ( x , y ) ;
46800: LD_VAR 0 2
46804: PPUSH
46805: LD_VAR 0 3
46809: PPUSH
46810: CALL_OW 284
46814: IFFALSE 46793
// if GetResourceTypeXY ( x , y ) = mat_artefact then
46816: LD_VAR 0 2
46820: PPUSH
46821: LD_VAR 0 3
46825: PPUSH
46826: CALL_OW 283
46830: PUSH
46831: LD_INT 4
46833: EQUAL
46834: IFFALSE 46838
// exit ;
46836: GO 47146
// for i = 1 to mc_bases do
46838: LD_ADDR_VAR 0 7
46842: PUSH
46843: DOUBLE
46844: LD_INT 1
46846: DEC
46847: ST_TO_ADDR
46848: LD_EXP 76
46852: PUSH
46853: FOR_TO
46854: IFFALSE 47144
// begin if mc_crates_area [ i ] then
46856: LD_EXP 94
46860: PUSH
46861: LD_VAR 0 7
46865: ARRAY
46866: IFFALSE 46977
// for j in mc_crates_area [ i ] do
46868: LD_ADDR_VAR 0 8
46872: PUSH
46873: LD_EXP 94
46877: PUSH
46878: LD_VAR 0 7
46882: ARRAY
46883: PUSH
46884: FOR_IN
46885: IFFALSE 46975
// if InArea ( x , y , j ) then
46887: LD_VAR 0 2
46891: PPUSH
46892: LD_VAR 0 3
46896: PPUSH
46897: LD_VAR 0 8
46901: PPUSH
46902: CALL_OW 309
46906: IFFALSE 46973
// begin mc_crates := ReplaceIn ( mc_crates , [ i , mc_crates [ i ] + 1 ] , [ amount , x , y ] ) ;
46908: LD_ADDR_EXP 92
46912: PUSH
46913: LD_EXP 92
46917: PPUSH
46918: LD_VAR 0 7
46922: PUSH
46923: LD_EXP 92
46927: PUSH
46928: LD_VAR 0 7
46932: ARRAY
46933: PUSH
46934: LD_INT 1
46936: PLUS
46937: PUSH
46938: EMPTY
46939: LIST
46940: LIST
46941: PPUSH
46942: LD_VAR 0 4
46946: PUSH
46947: LD_VAR 0 2
46951: PUSH
46952: LD_VAR 0 3
46956: PUSH
46957: EMPTY
46958: LIST
46959: LIST
46960: LIST
46961: PPUSH
46962: CALL 57644 0 3
46966: ST_TO_ADDR
// exit ;
46967: POP
46968: POP
46969: POP
46970: POP
46971: GO 47146
// end ;
46973: GO 46884
46975: POP
46976: POP
// depot := UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) ;
46977: LD_ADDR_VAR 0 9
46981: PUSH
46982: LD_EXP 76
46986: PUSH
46987: LD_VAR 0 7
46991: ARRAY
46992: PPUSH
46993: LD_INT 2
46995: PUSH
46996: LD_INT 30
46998: PUSH
46999: LD_INT 0
47001: PUSH
47002: EMPTY
47003: LIST
47004: LIST
47005: PUSH
47006: LD_INT 30
47008: PUSH
47009: LD_INT 1
47011: PUSH
47012: EMPTY
47013: LIST
47014: LIST
47015: PUSH
47016: EMPTY
47017: LIST
47018: LIST
47019: LIST
47020: PPUSH
47021: CALL_OW 72
47025: ST_TO_ADDR
// if not depot then
47026: LD_VAR 0 9
47030: NOT
47031: IFFALSE 47035
// continue ;
47033: GO 46853
// for j in depot do
47035: LD_ADDR_VAR 0 8
47039: PUSH
47040: LD_VAR 0 9
47044: PUSH
47045: FOR_IN
47046: IFFALSE 47140
// if GetDistUnitXY ( j , x , y ) < 30 then
47048: LD_VAR 0 8
47052: PPUSH
47053: LD_VAR 0 2
47057: PPUSH
47058: LD_VAR 0 3
47062: PPUSH
47063: CALL_OW 297
47067: PUSH
47068: LD_INT 30
47070: LESS
47071: IFFALSE 47138
// begin mc_crates := ReplaceIn ( mc_crates , [ i , mc_crates [ i ] + 1 ] , [ amount , x , y ] ) ;
47073: LD_ADDR_EXP 92
47077: PUSH
47078: LD_EXP 92
47082: PPUSH
47083: LD_VAR 0 7
47087: PUSH
47088: LD_EXP 92
47092: PUSH
47093: LD_VAR 0 7
47097: ARRAY
47098: PUSH
47099: LD_INT 1
47101: PLUS
47102: PUSH
47103: EMPTY
47104: LIST
47105: LIST
47106: PPUSH
47107: LD_VAR 0 4
47111: PUSH
47112: LD_VAR 0 2
47116: PUSH
47117: LD_VAR 0 3
47121: PUSH
47122: EMPTY
47123: LIST
47124: LIST
47125: LIST
47126: PPUSH
47127: CALL 57644 0 3
47131: ST_TO_ADDR
// exit ;
47132: POP
47133: POP
47134: POP
47135: POP
47136: GO 47146
// end ;
47138: GO 47045
47140: POP
47141: POP
// end ;
47142: GO 46853
47144: POP
47145: POP
// end ;
47146: LD_VAR 0 6
47150: RET
// export function MCE_ResearchComplete ( tech , lab ) ; var side , i , tmp ; begin
47151: LD_INT 0
47153: PPUSH
47154: PPUSH
47155: PPUSH
47156: PPUSH
// if not mc_bases or not skirmish then
47157: LD_EXP 76
47161: NOT
47162: PUSH
47163: LD_EXP 74
47167: NOT
47168: OR
47169: IFFALSE 47173
// exit ;
47171: GO 47450
// side := GetSide ( lab ) ;
47173: LD_ADDR_VAR 0 4
47177: PUSH
47178: LD_VAR 0 2
47182: PPUSH
47183: CALL_OW 255
47187: ST_TO_ADDR
// if not side in mc_sides or not mc_tech or not mc_bases then
47188: LD_VAR 0 4
47192: PUSH
47193: LD_EXP 102
47197: IN
47198: NOT
47199: PUSH
47200: LD_EXP 103
47204: NOT
47205: OR
47206: PUSH
47207: LD_EXP 76
47211: NOT
47212: OR
47213: IFFALSE 47217
// exit ;
47215: GO 47450
// mc_tech := Replace ( mc_tech , side , mc_tech [ side ] diff tech ) ;
47217: LD_ADDR_EXP 103
47221: PUSH
47222: LD_EXP 103
47226: PPUSH
47227: LD_VAR 0 4
47231: PPUSH
47232: LD_EXP 103
47236: PUSH
47237: LD_VAR 0 4
47241: ARRAY
47242: PUSH
47243: LD_VAR 0 1
47247: DIFF
47248: PPUSH
47249: CALL_OW 1
47253: ST_TO_ADDR
// for i = 1 to mc_bases do
47254: LD_ADDR_VAR 0 5
47258: PUSH
47259: DOUBLE
47260: LD_INT 1
47262: DEC
47263: ST_TO_ADDR
47264: LD_EXP 76
47268: PUSH
47269: FOR_TO
47270: IFFALSE 47448
// begin if lab in mc_bases [ i ] then
47272: LD_VAR 0 2
47276: PUSH
47277: LD_EXP 76
47281: PUSH
47282: LD_VAR 0 5
47286: ARRAY
47287: IN
47288: IFFALSE 47446
// begin if tech in [ tech_apeagres , tech_apebrain , tech_apeneural , tech_apepsych ] and mc_ape_in_lab [ i ] then
47290: LD_VAR 0 1
47294: PUSH
47295: LD_INT 11
47297: PUSH
47298: LD_INT 4
47300: PUSH
47301: LD_INT 3
47303: PUSH
47304: LD_INT 2
47306: PUSH
47307: EMPTY
47308: LIST
47309: LIST
47310: LIST
47311: LIST
47312: IN
47313: PUSH
47314: LD_EXP 106
47318: PUSH
47319: LD_VAR 0 5
47323: ARRAY
47324: AND
47325: IFFALSE 47446
// begin tmp := mc_ape_in_lab [ i ] [ 1 ] ;
47327: LD_ADDR_VAR 0 6
47331: PUSH
47332: LD_EXP 106
47336: PUSH
47337: LD_VAR 0 5
47341: ARRAY
47342: PUSH
47343: LD_INT 1
47345: ARRAY
47346: ST_TO_ADDR
// mc_ape_in_lab := Replace ( mc_ape_in_lab , i , [ ] ) ;
47347: LD_ADDR_EXP 106
47351: PUSH
47352: LD_EXP 106
47356: PPUSH
47357: LD_VAR 0 5
47361: PPUSH
47362: EMPTY
47363: PPUSH
47364: CALL_OW 1
47368: ST_TO_ADDR
// SetTag ( tmp , 0 ) ;
47369: LD_VAR 0 6
47373: PPUSH
47374: LD_INT 0
47376: PPUSH
47377: CALL_OW 109
// ComExitBuilding ( tmp ) ;
47381: LD_VAR 0 6
47385: PPUSH
47386: CALL_OW 122
// mc_ape := Replace ( mc_ape , i , Insert ( mc_ape [ i ] , 1 , tmp ) ) ;
47390: LD_ADDR_EXP 105
47394: PUSH
47395: LD_EXP 105
47399: PPUSH
47400: LD_VAR 0 5
47404: PPUSH
47405: LD_EXP 105
47409: PUSH
47410: LD_VAR 0 5
47414: ARRAY
47415: PPUSH
47416: LD_INT 1
47418: PPUSH
47419: LD_VAR 0 6
47423: PPUSH
47424: CALL_OW 2
47428: PPUSH
47429: CALL_OW 1
47433: ST_TO_ADDR
// MC_Reset ( i , 112 ) ;
47434: LD_VAR 0 5
47438: PPUSH
47439: LD_INT 112
47441: PPUSH
47442: CALL 24446 0 2
// end ; end ; end ;
47446: GO 47269
47448: POP
47449: POP
// end ;
47450: LD_VAR 0 3
47454: RET
// export function MCE_UnitDestroyed ( un ) ; var i , j , btype , pos , tmp , fac , components ; begin
47455: LD_INT 0
47457: PPUSH
47458: PPUSH
47459: PPUSH
47460: PPUSH
47461: PPUSH
47462: PPUSH
47463: PPUSH
47464: PPUSH
// if not mc_bases or not skirmish then
47465: LD_EXP 76
47469: NOT
47470: PUSH
47471: LD_EXP 74
47475: NOT
47476: OR
47477: IFFALSE 47481
// exit ;
47479: GO 48852
// for i = 1 to mc_bases do
47481: LD_ADDR_VAR 0 3
47485: PUSH
47486: DOUBLE
47487: LD_INT 1
47489: DEC
47490: ST_TO_ADDR
47491: LD_EXP 76
47495: PUSH
47496: FOR_TO
47497: IFFALSE 48850
// if un in mc_bases [ i ] or un in mc_construct_list [ i ] or un in mc_defender [ i ] or un in mc_vehicles [ i ] or un in mc_ape [ i ] or un in mc_ape_in_lab [ i ] then
47499: LD_VAR 0 1
47503: PUSH
47504: LD_EXP 76
47508: PUSH
47509: LD_VAR 0 3
47513: ARRAY
47514: IN
47515: PUSH
47516: LD_VAR 0 1
47520: PUSH
47521: LD_EXP 83
47525: PUSH
47526: LD_VAR 0 3
47530: ARRAY
47531: IN
47532: OR
47533: PUSH
47534: LD_VAR 0 1
47538: PUSH
47539: LD_EXP 98
47543: PUSH
47544: LD_VAR 0 3
47548: ARRAY
47549: IN
47550: OR
47551: PUSH
47552: LD_VAR 0 1
47556: PUSH
47557: LD_EXP 95
47561: PUSH
47562: LD_VAR 0 3
47566: ARRAY
47567: IN
47568: OR
47569: PUSH
47570: LD_VAR 0 1
47574: PUSH
47575: LD_EXP 105
47579: PUSH
47580: LD_VAR 0 3
47584: ARRAY
47585: IN
47586: OR
47587: PUSH
47588: LD_VAR 0 1
47592: PUSH
47593: LD_EXP 106
47597: PUSH
47598: LD_VAR 0 3
47602: ARRAY
47603: IN
47604: OR
47605: IFFALSE 48848
// begin if un in mc_ape [ i ] then
47607: LD_VAR 0 1
47611: PUSH
47612: LD_EXP 105
47616: PUSH
47617: LD_VAR 0 3
47621: ARRAY
47622: IN
47623: IFFALSE 47662
// begin mc_ape := Replace ( mc_ape , i , mc_ape [ i ] diff un ) ;
47625: LD_ADDR_EXP 105
47629: PUSH
47630: LD_EXP 105
47634: PPUSH
47635: LD_VAR 0 3
47639: PPUSH
47640: LD_EXP 105
47644: PUSH
47645: LD_VAR 0 3
47649: ARRAY
47650: PUSH
47651: LD_VAR 0 1
47655: DIFF
47656: PPUSH
47657: CALL_OW 1
47661: ST_TO_ADDR
// end ; if un in mc_ape_in_lab [ i ] then
47662: LD_VAR 0 1
47666: PUSH
47667: LD_EXP 106
47671: PUSH
47672: LD_VAR 0 3
47676: ARRAY
47677: IN
47678: IFFALSE 47702
// begin mc_ape_in_lab := Replace ( mc_ape_in_lab , i , [ ] ) ;
47680: LD_ADDR_EXP 106
47684: PUSH
47685: LD_EXP 106
47689: PPUSH
47690: LD_VAR 0 3
47694: PPUSH
47695: EMPTY
47696: PPUSH
47697: CALL_OW 1
47701: ST_TO_ADDR
// end ; if GetType ( un ) = unit_vehicle and ( GetTag ( un ) = 20 or un in mc_defender [ i ] or GetWeapon ( un ) in [ us_cargo_bay , ru_cargo_bay , ru_big_cargo_bay , ar_cargo_bay , us_crane , ru_crane , ar_control_tower ] ) then
47702: LD_VAR 0 1
47706: PPUSH
47707: CALL_OW 247
47711: PUSH
47712: LD_INT 2
47714: EQUAL
47715: PUSH
47716: LD_VAR 0 1
47720: PPUSH
47721: CALL_OW 110
47725: PUSH
47726: LD_INT 20
47728: EQUAL
47729: PUSH
47730: LD_VAR 0 1
47734: PUSH
47735: LD_EXP 98
47739: PUSH
47740: LD_VAR 0 3
47744: ARRAY
47745: IN
47746: OR
47747: PUSH
47748: LD_VAR 0 1
47752: PPUSH
47753: CALL_OW 264
47757: PUSH
47758: LD_INT 12
47760: PUSH
47761: LD_INT 51
47763: PUSH
47764: LD_EXP 70
47768: PUSH
47769: LD_INT 32
47771: PUSH
47772: LD_INT 13
47774: PUSH
47775: LD_INT 52
47777: PUSH
47778: LD_INT 31
47780: PUSH
47781: EMPTY
47782: LIST
47783: LIST
47784: LIST
47785: LIST
47786: LIST
47787: LIST
47788: LIST
47789: IN
47790: OR
47791: AND
47792: IFFALSE 48100
// begin if un in mc_defender [ i ] then
47794: LD_VAR 0 1
47798: PUSH
47799: LD_EXP 98
47803: PUSH
47804: LD_VAR 0 3
47808: ARRAY
47809: IN
47810: IFFALSE 47849
// mc_defender := Replace ( mc_defender , i , mc_defender [ i ] diff un ) ;
47812: LD_ADDR_EXP 98
47816: PUSH
47817: LD_EXP 98
47821: PPUSH
47822: LD_VAR 0 3
47826: PPUSH
47827: LD_EXP 98
47831: PUSH
47832: LD_VAR 0 3
47836: ARRAY
47837: PUSH
47838: LD_VAR 0 1
47842: DIFF
47843: PPUSH
47844: CALL_OW 1
47848: ST_TO_ADDR
// fac := MC_GetBuildings ( i , b_factory ) ;
47849: LD_ADDR_VAR 0 8
47853: PUSH
47854: LD_VAR 0 3
47858: PPUSH
47859: LD_INT 3
47861: PPUSH
47862: CALL 44518 0 2
47866: ST_TO_ADDR
// if fac then
47867: LD_VAR 0 8
47871: IFFALSE 48100
// begin for j in fac do
47873: LD_ADDR_VAR 0 4
47877: PUSH
47878: LD_VAR 0 8
47882: PUSH
47883: FOR_IN
47884: IFFALSE 48098
// begin components := Produce ( fac , GetChassis ( un ) , GetEngine ( un ) , GetControl ( un ) , GetWeapon ( un ) ) ;
47886: LD_ADDR_VAR 0 9
47890: PUSH
47891: LD_VAR 0 8
47895: PPUSH
47896: LD_VAR 0 1
47900: PPUSH
47901: CALL_OW 265
47905: PPUSH
47906: LD_VAR 0 1
47910: PPUSH
47911: CALL_OW 262
47915: PPUSH
47916: LD_VAR 0 1
47920: PPUSH
47921: CALL_OW 263
47925: PPUSH
47926: LD_VAR 0 1
47930: PPUSH
47931: CALL_OW 264
47935: PPUSH
47936: CALL 55176 0 5
47940: ST_TO_ADDR
// if components then
47941: LD_VAR 0 9
47945: IFFALSE 48096
// begin if GetWeapon ( un ) = ar_control_tower then
47947: LD_VAR 0 1
47951: PPUSH
47952: CALL_OW 264
47956: PUSH
47957: LD_INT 31
47959: EQUAL
47960: IFFALSE 48077
// begin SetTag ( IsDrivenBy ( un ) , 0 ) ;
47962: LD_VAR 0 1
47966: PPUSH
47967: CALL_OW 311
47971: PPUSH
47972: LD_INT 0
47974: PPUSH
47975: CALL_OW 109
// mc_remote_driver := Replace ( mc_remote_driver , i , mc_remote_driver [ i ] diff IsDrivenBy ( un ) ) ;
47979: LD_ADDR_EXP 116
47983: PUSH
47984: LD_EXP 116
47988: PPUSH
47989: LD_VAR 0 3
47993: PPUSH
47994: LD_EXP 116
47998: PUSH
47999: LD_VAR 0 3
48003: ARRAY
48004: PUSH
48005: LD_VAR 0 1
48009: PPUSH
48010: CALL_OW 311
48014: DIFF
48015: PPUSH
48016: CALL_OW 1
48020: ST_TO_ADDR
// tmp := Insert ( mc_produce [ i ] , 1 , components ) ;
48021: LD_ADDR_VAR 0 7
48025: PUSH
48026: LD_EXP 97
48030: PUSH
48031: LD_VAR 0 3
48035: ARRAY
48036: PPUSH
48037: LD_INT 1
48039: PPUSH
48040: LD_VAR 0 9
48044: PPUSH
48045: CALL_OW 2
48049: ST_TO_ADDR
// mc_produce := Replace ( mc_produce , i , tmp ) ;
48050: LD_ADDR_EXP 97
48054: PUSH
48055: LD_EXP 97
48059: PPUSH
48060: LD_VAR 0 3
48064: PPUSH
48065: LD_VAR 0 7
48069: PPUSH
48070: CALL_OW 1
48074: ST_TO_ADDR
// end else
48075: GO 48094
// MC_InsertProduceList ( i , [ components ] ) ;
48077: LD_VAR 0 3
48081: PPUSH
48082: LD_VAR 0 9
48086: PUSH
48087: EMPTY
48088: LIST
48089: PPUSH
48090: CALL 44063 0 2
// break ;
48094: GO 48098
// end ; end ;
48096: GO 47883
48098: POP
48099: POP
// end ; end ; if GetType ( un ) = unit_building then
48100: LD_VAR 0 1
48104: PPUSH
48105: CALL_OW 247
48109: PUSH
48110: LD_INT 3
48112: EQUAL
48113: IFFALSE 48516
// begin btype := GetBType ( un ) ;
48115: LD_ADDR_VAR 0 5
48119: PUSH
48120: LD_VAR 0 1
48124: PPUSH
48125: CALL_OW 266
48129: ST_TO_ADDR
// if btype in [ b_oil_mine , b_siberite_mine ] then
48130: LD_VAR 0 5
48134: PUSH
48135: LD_INT 29
48137: PUSH
48138: LD_INT 30
48140: PUSH
48141: EMPTY
48142: LIST
48143: LIST
48144: IN
48145: IFFALSE 48218
// begin if not GetResourceVisibility ( GetX ( un ) , GetY ( un ) , GetSide ( un ) ) then
48147: LD_VAR 0 1
48151: PPUSH
48152: CALL_OW 250
48156: PPUSH
48157: LD_VAR 0 1
48161: PPUSH
48162: CALL_OW 251
48166: PPUSH
48167: LD_VAR 0 1
48171: PPUSH
48172: CALL_OW 255
48176: PPUSH
48177: CALL_OW 440
48181: NOT
48182: IFFALSE 48218
// SetResourceVisibility ( GetX ( un ) , GetY ( un ) , GetSide ( un ) ) ;
48184: LD_VAR 0 1
48188: PPUSH
48189: CALL_OW 250
48193: PPUSH
48194: LD_VAR 0 1
48198: PPUSH
48199: CALL_OW 251
48203: PPUSH
48204: LD_VAR 0 1
48208: PPUSH
48209: CALL_OW 255
48213: PPUSH
48214: CALL_OW 441
// end ; if btype = b_warehouse then
48218: LD_VAR 0 5
48222: PUSH
48223: LD_INT 1
48225: EQUAL
48226: IFFALSE 48244
// begin btype := b_depot ;
48228: LD_ADDR_VAR 0 5
48232: PUSH
48233: LD_INT 0
48235: ST_TO_ADDR
// pos := 1 ;
48236: LD_ADDR_VAR 0 6
48240: PUSH
48241: LD_INT 1
48243: ST_TO_ADDR
// end ; if btype = b_factory then
48244: LD_VAR 0 5
48248: PUSH
48249: LD_INT 3
48251: EQUAL
48252: IFFALSE 48270
// begin btype := b_workshop ;
48254: LD_ADDR_VAR 0 5
48258: PUSH
48259: LD_INT 2
48261: ST_TO_ADDR
// pos := 1 ;
48262: LD_ADDR_VAR 0 6
48266: PUSH
48267: LD_INT 1
48269: ST_TO_ADDR
// end ; if btype = b_barracks then
48270: LD_VAR 0 5
48274: PUSH
48275: LD_INT 5
48277: EQUAL
48278: IFFALSE 48288
// btype := b_armoury ;
48280: LD_ADDR_VAR 0 5
48284: PUSH
48285: LD_INT 4
48287: ST_TO_ADDR
// if btype in [ b_lab_half , b_lab_full ] then
48288: LD_VAR 0 5
48292: PUSH
48293: LD_INT 7
48295: PUSH
48296: LD_INT 8
48298: PUSH
48299: EMPTY
48300: LIST
48301: LIST
48302: IN
48303: IFFALSE 48313
// btype := b_lab ;
48305: LD_ADDR_VAR 0 5
48309: PUSH
48310: LD_INT 6
48312: ST_TO_ADDR
// mc_build_list := ReplaceIn ( mc_build_list , [ i , mc_build_list [ i ] + 1 ] , [ btype , GetX ( un ) , GetY ( un ) , GetDir ( un ) ] ) ;
48313: LD_ADDR_EXP 81
48317: PUSH
48318: LD_EXP 81
48322: PPUSH
48323: LD_VAR 0 3
48327: PUSH
48328: LD_EXP 81
48332: PUSH
48333: LD_VAR 0 3
48337: ARRAY
48338: PUSH
48339: LD_INT 1
48341: PLUS
48342: PUSH
48343: EMPTY
48344: LIST
48345: LIST
48346: PPUSH
48347: LD_VAR 0 5
48351: PUSH
48352: LD_VAR 0 1
48356: PPUSH
48357: CALL_OW 250
48361: PUSH
48362: LD_VAR 0 1
48366: PPUSH
48367: CALL_OW 251
48371: PUSH
48372: LD_VAR 0 1
48376: PPUSH
48377: CALL_OW 254
48381: PUSH
48382: EMPTY
48383: LIST
48384: LIST
48385: LIST
48386: LIST
48387: PPUSH
48388: CALL 57644 0 3
48392: ST_TO_ADDR
// if pos = 1 then
48393: LD_VAR 0 6
48397: PUSH
48398: LD_INT 1
48400: EQUAL
48401: IFFALSE 48516
// begin tmp := mc_build_list [ i ] ;
48403: LD_ADDR_VAR 0 7
48407: PUSH
48408: LD_EXP 81
48412: PUSH
48413: LD_VAR 0 3
48417: ARRAY
48418: ST_TO_ADDR
// if UnitFilter ( tmp , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) then
48419: LD_VAR 0 7
48423: PPUSH
48424: LD_INT 2
48426: PUSH
48427: LD_INT 30
48429: PUSH
48430: LD_INT 0
48432: PUSH
48433: EMPTY
48434: LIST
48435: LIST
48436: PUSH
48437: LD_INT 30
48439: PUSH
48440: LD_INT 1
48442: PUSH
48443: EMPTY
48444: LIST
48445: LIST
48446: PUSH
48447: EMPTY
48448: LIST
48449: LIST
48450: LIST
48451: PPUSH
48452: CALL_OW 72
48456: IFFALSE 48466
// pos := 2 ;
48458: LD_ADDR_VAR 0 6
48462: PUSH
48463: LD_INT 2
48465: ST_TO_ADDR
// tmp := ReplaceWith ( tmp , pos , tmp ) ;
48466: LD_ADDR_VAR 0 7
48470: PUSH
48471: LD_VAR 0 7
48475: PPUSH
48476: LD_VAR 0 6
48480: PPUSH
48481: LD_VAR 0 7
48485: PPUSH
48486: CALL 57970 0 3
48490: ST_TO_ADDR
// mc_build_list := Replace ( mc_build_list , i , tmp ) ;
48491: LD_ADDR_EXP 81
48495: PUSH
48496: LD_EXP 81
48500: PPUSH
48501: LD_VAR 0 3
48505: PPUSH
48506: LD_VAR 0 7
48510: PPUSH
48511: CALL_OW 1
48515: ST_TO_ADDR
// end ; end ; if un in mc_bases [ i ] then
48516: LD_VAR 0 1
48520: PUSH
48521: LD_EXP 76
48525: PUSH
48526: LD_VAR 0 3
48530: ARRAY
48531: IN
48532: IFFALSE 48571
// begin mc_bases := Replace ( mc_bases , i , mc_bases [ i ] diff un ) ;
48534: LD_ADDR_EXP 76
48538: PUSH
48539: LD_EXP 76
48543: PPUSH
48544: LD_VAR 0 3
48548: PPUSH
48549: LD_EXP 76
48553: PUSH
48554: LD_VAR 0 3
48558: ARRAY
48559: PUSH
48560: LD_VAR 0 1
48564: DIFF
48565: PPUSH
48566: CALL_OW 1
48570: ST_TO_ADDR
// end ; if un in mc_construct_list [ i ] then
48571: LD_VAR 0 1
48575: PUSH
48576: LD_EXP 83
48580: PUSH
48581: LD_VAR 0 3
48585: ARRAY
48586: IN
48587: IFFALSE 48626
// begin mc_construct_list := Replace ( mc_construct_list , i , mc_construct_list [ i ] diff un ) ;
48589: LD_ADDR_EXP 83
48593: PUSH
48594: LD_EXP 83
48598: PPUSH
48599: LD_VAR 0 3
48603: PPUSH
48604: LD_EXP 83
48608: PUSH
48609: LD_VAR 0 3
48613: ARRAY
48614: PUSH
48615: LD_VAR 0 1
48619: DIFF
48620: PPUSH
48621: CALL_OW 1
48625: ST_TO_ADDR
// end ; if un in mc_vehicles [ i ] then
48626: LD_VAR 0 1
48630: PUSH
48631: LD_EXP 95
48635: PUSH
48636: LD_VAR 0 3
48640: ARRAY
48641: IN
48642: IFFALSE 48681
// begin mc_vehicles := Replace ( mc_vehicles , i , mc_vehicles [ i ] diff un ) ;
48644: LD_ADDR_EXP 95
48648: PUSH
48649: LD_EXP 95
48653: PPUSH
48654: LD_VAR 0 3
48658: PPUSH
48659: LD_EXP 95
48663: PUSH
48664: LD_VAR 0 3
48668: ARRAY
48669: PUSH
48670: LD_VAR 0 1
48674: DIFF
48675: PPUSH
48676: CALL_OW 1
48680: ST_TO_ADDR
// end ; if un in mc_defender [ i ] then
48681: LD_VAR 0 1
48685: PUSH
48686: LD_EXP 98
48690: PUSH
48691: LD_VAR 0 3
48695: ARRAY
48696: IN
48697: IFFALSE 48736
// begin mc_defender := Replace ( mc_defender , i , mc_defender [ i ] diff un ) ;
48699: LD_ADDR_EXP 98
48703: PUSH
48704: LD_EXP 98
48708: PPUSH
48709: LD_VAR 0 3
48713: PPUSH
48714: LD_EXP 98
48718: PUSH
48719: LD_VAR 0 3
48723: ARRAY
48724: PUSH
48725: LD_VAR 0 1
48729: DIFF
48730: PPUSH
48731: CALL_OW 1
48735: ST_TO_ADDR
// end ; if un in mc_empty_turret_list [ i ] then
48736: LD_VAR 0 1
48740: PUSH
48741: LD_EXP 85
48745: PUSH
48746: LD_VAR 0 3
48750: ARRAY
48751: IN
48752: IFFALSE 48791
// begin mc_empty_turret_list := Replace ( mc_empty_turret_list , i , mc_empty_turret_list [ i ] diff un ) ;
48754: LD_ADDR_EXP 85
48758: PUSH
48759: LD_EXP 85
48763: PPUSH
48764: LD_VAR 0 3
48768: PPUSH
48769: LD_EXP 85
48773: PUSH
48774: LD_VAR 0 3
48778: ARRAY
48779: PUSH
48780: LD_VAR 0 1
48784: DIFF
48785: PPUSH
48786: CALL_OW 1
48790: ST_TO_ADDR
// end ; if un in mc_turret_list [ i ] then
48791: LD_VAR 0 1
48795: PUSH
48796: LD_EXP 84
48800: PUSH
48801: LD_VAR 0 3
48805: ARRAY
48806: IN
48807: IFFALSE 48846
// begin mc_turret_list := Replace ( mc_turret_list , i , mc_turret_list [ i ] diff un ) ;
48809: LD_ADDR_EXP 84
48813: PUSH
48814: LD_EXP 84
48818: PPUSH
48819: LD_VAR 0 3
48823: PPUSH
48824: LD_EXP 84
48828: PUSH
48829: LD_VAR 0 3
48833: ARRAY
48834: PUSH
48835: LD_VAR 0 1
48839: DIFF
48840: PPUSH
48841: CALL_OW 1
48845: ST_TO_ADDR
// end ; break ;
48846: GO 48850
// end ;
48848: GO 47496
48850: POP
48851: POP
// end ;
48852: LD_VAR 0 2
48856: RET
// export function MCE_UpgradeComplete ( building ) ; var i , j ; begin
48857: LD_INT 0
48859: PPUSH
48860: PPUSH
48861: PPUSH
// if not mc_bases or not skirmish then
48862: LD_EXP 76
48866: NOT
48867: PUSH
48868: LD_EXP 74
48872: NOT
48873: OR
48874: IFFALSE 48878
// exit ;
48876: GO 49093
// for i = 1 to mc_bases do
48878: LD_ADDR_VAR 0 3
48882: PUSH
48883: DOUBLE
48884: LD_INT 1
48886: DEC
48887: ST_TO_ADDR
48888: LD_EXP 76
48892: PUSH
48893: FOR_TO
48894: IFFALSE 49091
// begin if building in mc_construct_list [ i ] then
48896: LD_VAR 0 1
48900: PUSH
48901: LD_EXP 83
48905: PUSH
48906: LD_VAR 0 3
48910: ARRAY
48911: IN
48912: IFFALSE 49089
// begin mc_construct_list := Replace ( mc_construct_list , i , mc_construct_list [ i ] diff building ) ;
48914: LD_ADDR_EXP 83
48918: PUSH
48919: LD_EXP 83
48923: PPUSH
48924: LD_VAR 0 3
48928: PPUSH
48929: LD_EXP 83
48933: PUSH
48934: LD_VAR 0 3
48938: ARRAY
48939: PUSH
48940: LD_VAR 0 1
48944: DIFF
48945: PPUSH
48946: CALL_OW 1
48950: ST_TO_ADDR
// if building in mc_lab [ i ] then
48951: LD_VAR 0 1
48955: PUSH
48956: LD_EXP 109
48960: PUSH
48961: LD_VAR 0 3
48965: ARRAY
48966: IN
48967: IFFALSE 49022
// mc_lab_upgrade := Replace ( mc_lab_upgrade , i , Reindex ( mc_lab_upgrade [ i ] , 1 , mc_lab_upgrade [ i ] , false ) ) ;
48969: LD_ADDR_EXP 110
48973: PUSH
48974: LD_EXP 110
48978: PPUSH
48979: LD_VAR 0 3
48983: PPUSH
48984: LD_EXP 110
48988: PUSH
48989: LD_VAR 0 3
48993: ARRAY
48994: PPUSH
48995: LD_INT 1
48997: PPUSH
48998: LD_EXP 110
49002: PUSH
49003: LD_VAR 0 3
49007: ARRAY
49008: PPUSH
49009: LD_INT 0
49011: PPUSH
49012: CALL 57062 0 4
49016: PPUSH
49017: CALL_OW 1
49021: ST_TO_ADDR
// if not building in mc_bases [ i ] then
49022: LD_VAR 0 1
49026: PUSH
49027: LD_EXP 76
49031: PUSH
49032: LD_VAR 0 3
49036: ARRAY
49037: IN
49038: NOT
49039: IFFALSE 49085
// mc_bases := ReplaceIn ( mc_bases , [ i , mc_bases [ i ] + 1 ] , building ) ;
49041: LD_ADDR_EXP 76
49045: PUSH
49046: LD_EXP 76
49050: PPUSH
49051: LD_VAR 0 3
49055: PUSH
49056: LD_EXP 76
49060: PUSH
49061: LD_VAR 0 3
49065: ARRAY
49066: PUSH
49067: LD_INT 1
49069: PLUS
49070: PUSH
49071: EMPTY
49072: LIST
49073: LIST
49074: PPUSH
49075: LD_VAR 0 1
49079: PPUSH
49080: CALL 57644 0 3
49084: ST_TO_ADDR
// exit ;
49085: POP
49086: POP
49087: GO 49093
// end ; end ;
49089: GO 48893
49091: POP
49092: POP
// end ;
49093: LD_VAR 0 2
49097: RET
// export function MCE_BuildingComplete ( building ) ; var i , j , btype , tmp , units , side ; begin
49098: LD_INT 0
49100: PPUSH
49101: PPUSH
49102: PPUSH
49103: PPUSH
49104: PPUSH
49105: PPUSH
49106: PPUSH
// if not mc_bases or not skirmish then
49107: LD_EXP 76
49111: NOT
49112: PUSH
49113: LD_EXP 74
49117: NOT
49118: OR
49119: IFFALSE 49123
// exit ;
49121: GO 49784
// for i = 1 to mc_bases do
49123: LD_ADDR_VAR 0 3
49127: PUSH
49128: DOUBLE
49129: LD_INT 1
49131: DEC
49132: ST_TO_ADDR
49133: LD_EXP 76
49137: PUSH
49138: FOR_TO
49139: IFFALSE 49782
// begin if building in mc_construct_list [ i ] then
49141: LD_VAR 0 1
49145: PUSH
49146: LD_EXP 83
49150: PUSH
49151: LD_VAR 0 3
49155: ARRAY
49156: IN
49157: IFFALSE 49780
// begin mc_construct_list := Replace ( mc_construct_list , i , mc_construct_list [ i ] diff building ) ;
49159: LD_ADDR_EXP 83
49163: PUSH
49164: LD_EXP 83
49168: PPUSH
49169: LD_VAR 0 3
49173: PPUSH
49174: LD_EXP 83
49178: PUSH
49179: LD_VAR 0 3
49183: ARRAY
49184: PUSH
49185: LD_VAR 0 1
49189: DIFF
49190: PPUSH
49191: CALL_OW 1
49195: ST_TO_ADDR
// mc_bases := ReplaceIn ( mc_bases , [ i , mc_bases [ i ] + 1 ] , building ) ;
49196: LD_ADDR_EXP 76
49200: PUSH
49201: LD_EXP 76
49205: PPUSH
49206: LD_VAR 0 3
49210: PUSH
49211: LD_EXP 76
49215: PUSH
49216: LD_VAR 0 3
49220: ARRAY
49221: PUSH
49222: LD_INT 1
49224: PLUS
49225: PUSH
49226: EMPTY
49227: LIST
49228: LIST
49229: PPUSH
49230: LD_VAR 0 1
49234: PPUSH
49235: CALL 57644 0 3
49239: ST_TO_ADDR
// btype := GetBType ( building ) ;
49240: LD_ADDR_VAR 0 5
49244: PUSH
49245: LD_VAR 0 1
49249: PPUSH
49250: CALL_OW 266
49254: ST_TO_ADDR
// side := GetSide ( building ) ;
49255: LD_ADDR_VAR 0 8
49259: PUSH
49260: LD_VAR 0 1
49264: PPUSH
49265: CALL_OW 255
49269: ST_TO_ADDR
// if btype = b_lab then
49270: LD_VAR 0 5
49274: PUSH
49275: LD_INT 6
49277: EQUAL
49278: IFFALSE 49328
// begin mc_lab := ReplaceIn ( mc_lab , [ i , mc_lab [ i ] + 1 ] , building ) ;
49280: LD_ADDR_EXP 109
49284: PUSH
49285: LD_EXP 109
49289: PPUSH
49290: LD_VAR 0 3
49294: PUSH
49295: LD_EXP 109
49299: PUSH
49300: LD_VAR 0 3
49304: ARRAY
49305: PUSH
49306: LD_INT 1
49308: PLUS
49309: PUSH
49310: EMPTY
49311: LIST
49312: LIST
49313: PPUSH
49314: LD_VAR 0 1
49318: PPUSH
49319: CALL 57644 0 3
49323: ST_TO_ADDR
// exit ;
49324: POP
49325: POP
49326: GO 49784
// end ; if btype in [ b_depot , b_workshop , b_armoury ] then
49328: LD_VAR 0 5
49332: PUSH
49333: LD_INT 0
49335: PUSH
49336: LD_INT 2
49338: PUSH
49339: LD_INT 4
49341: PUSH
49342: EMPTY
49343: LIST
49344: LIST
49345: LIST
49346: IN
49347: IFFALSE 49471
// begin if btype = b_armoury then
49349: LD_VAR 0 5
49353: PUSH
49354: LD_INT 4
49356: EQUAL
49357: IFFALSE 49367
// btype := b_barracks ;
49359: LD_ADDR_VAR 0 5
49363: PUSH
49364: LD_INT 5
49366: ST_TO_ADDR
// if btype = b_depot then
49367: LD_VAR 0 5
49371: PUSH
49372: LD_INT 0
49374: EQUAL
49375: IFFALSE 49385
// btype := b_warehouse ;
49377: LD_ADDR_VAR 0 5
49381: PUSH
49382: LD_INT 1
49384: ST_TO_ADDR
// if btype = b_workshop then
49385: LD_VAR 0 5
49389: PUSH
49390: LD_INT 2
49392: EQUAL
49393: IFFALSE 49403
// btype := b_factory ;
49395: LD_ADDR_VAR 0 5
49399: PUSH
49400: LD_INT 3
49402: ST_TO_ADDR
// if GetRestrict ( btype , side ) = state_enabled then
49403: LD_VAR 0 5
49407: PPUSH
49408: LD_VAR 0 8
49412: PPUSH
49413: CALL_OW 323
49417: PUSH
49418: LD_INT 1
49420: EQUAL
49421: IFFALSE 49467
// mc_build_upgrade := ReplaceIn ( mc_build_upgrade , [ i , mc_build_upgrade [ i ] + 1 ] , building ) ;
49423: LD_ADDR_EXP 108
49427: PUSH
49428: LD_EXP 108
49432: PPUSH
49433: LD_VAR 0 3
49437: PUSH
49438: LD_EXP 108
49442: PUSH
49443: LD_VAR 0 3
49447: ARRAY
49448: PUSH
49449: LD_INT 1
49451: PLUS
49452: PUSH
49453: EMPTY
49454: LIST
49455: LIST
49456: PPUSH
49457: LD_VAR 0 1
49461: PPUSH
49462: CALL 57644 0 3
49466: ST_TO_ADDR
// exit ;
49467: POP
49468: POP
49469: GO 49784
// end ; if btype in [ b_bunker , b_turret ] then
49471: LD_VAR 0 5
49475: PUSH
49476: LD_INT 32
49478: PUSH
49479: LD_INT 33
49481: PUSH
49482: EMPTY
49483: LIST
49484: LIST
49485: IN
49486: IFFALSE 49776
// begin mc_turret_list := ReplaceIn ( mc_turret_list , [ i , mc_turret_list [ i ] + 1 ] , building ) ;
49488: LD_ADDR_EXP 84
49492: PUSH
49493: LD_EXP 84
49497: PPUSH
49498: LD_VAR 0 3
49502: PUSH
49503: LD_EXP 84
49507: PUSH
49508: LD_VAR 0 3
49512: ARRAY
49513: PUSH
49514: LD_INT 1
49516: PLUS
49517: PUSH
49518: EMPTY
49519: LIST
49520: LIST
49521: PPUSH
49522: LD_VAR 0 1
49526: PPUSH
49527: CALL 57644 0 3
49531: ST_TO_ADDR
// if btype = b_bunker then
49532: LD_VAR 0 5
49536: PUSH
49537: LD_INT 32
49539: EQUAL
49540: IFFALSE 49776
// begin mc_empty_turret_list := ReplaceIn ( mc_empty_turret_list , [ i , mc_empty_turret_list [ i ] + 1 ] , building ) ;
49542: LD_ADDR_EXP 85
49546: PUSH
49547: LD_EXP 85
49551: PPUSH
49552: LD_VAR 0 3
49556: PUSH
49557: LD_EXP 85
49561: PUSH
49562: LD_VAR 0 3
49566: ARRAY
49567: PUSH
49568: LD_INT 1
49570: PLUS
49571: PUSH
49572: EMPTY
49573: LIST
49574: LIST
49575: PPUSH
49576: LD_VAR 0 1
49580: PPUSH
49581: CALL 57644 0 3
49585: ST_TO_ADDR
// tmp := UnitFilter ( mc_bases [ i ] , [ [ f_class , 1 ] , [ f_not , [ f_inside ] ] ] ) ;
49586: LD_ADDR_VAR 0 6
49590: PUSH
49591: LD_EXP 76
49595: PUSH
49596: LD_VAR 0 3
49600: ARRAY
49601: PPUSH
49602: LD_INT 25
49604: PUSH
49605: LD_INT 1
49607: PUSH
49608: EMPTY
49609: LIST
49610: LIST
49611: PUSH
49612: LD_INT 3
49614: PUSH
49615: LD_INT 54
49617: PUSH
49618: EMPTY
49619: LIST
49620: PUSH
49621: EMPTY
49622: LIST
49623: LIST
49624: PUSH
49625: EMPTY
49626: LIST
49627: LIST
49628: PPUSH
49629: CALL_OW 72
49633: ST_TO_ADDR
// if tmp then
49634: LD_VAR 0 6
49638: IFFALSE 49644
// exit ;
49640: POP
49641: POP
49642: GO 49784
// tmp := UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_armoury ] , [ f_btype , b_barracks ] ] ) ;
49644: LD_ADDR_VAR 0 6
49648: PUSH
49649: LD_EXP 76
49653: PUSH
49654: LD_VAR 0 3
49658: ARRAY
49659: PPUSH
49660: LD_INT 2
49662: PUSH
49663: LD_INT 30
49665: PUSH
49666: LD_INT 4
49668: PUSH
49669: EMPTY
49670: LIST
49671: LIST
49672: PUSH
49673: LD_INT 30
49675: PUSH
49676: LD_INT 5
49678: PUSH
49679: EMPTY
49680: LIST
49681: LIST
49682: PUSH
49683: EMPTY
49684: LIST
49685: LIST
49686: LIST
49687: PPUSH
49688: CALL_OW 72
49692: ST_TO_ADDR
// if not tmp then
49693: LD_VAR 0 6
49697: NOT
49698: IFFALSE 49704
// exit ;
49700: POP
49701: POP
49702: GO 49784
// for j in tmp do
49704: LD_ADDR_VAR 0 4
49708: PUSH
49709: LD_VAR 0 6
49713: PUSH
49714: FOR_IN
49715: IFFALSE 49774
// begin units := UnitFilter ( UnitsInside ( j ) , [ f_class , 1 ] ) ;
49717: LD_ADDR_VAR 0 7
49721: PUSH
49722: LD_VAR 0 4
49726: PPUSH
49727: CALL_OW 313
49731: PPUSH
49732: LD_INT 25
49734: PUSH
49735: LD_INT 1
49737: PUSH
49738: EMPTY
49739: LIST
49740: LIST
49741: PPUSH
49742: CALL_OW 72
49746: ST_TO_ADDR
// if units then
49747: LD_VAR 0 7
49751: IFFALSE 49772
// begin ComExitBuilding ( units [ 1 ] ) ;
49753: LD_VAR 0 7
49757: PUSH
49758: LD_INT 1
49760: ARRAY
49761: PPUSH
49762: CALL_OW 122
// exit ;
49766: POP
49767: POP
49768: POP
49769: POP
49770: GO 49784
// end ; end ;
49772: GO 49714
49774: POP
49775: POP
// end ; end ; exit ;
49776: POP
49777: POP
49778: GO 49784
// end ; end ;
49780: GO 49138
49782: POP
49783: POP
// end ;
49784: LD_VAR 0 2
49788: RET
// export function MCE_BuildingStarted ( building , builder ) ; var i , j , btype , x , y , d ; begin
49789: LD_INT 0
49791: PPUSH
49792: PPUSH
49793: PPUSH
49794: PPUSH
49795: PPUSH
49796: PPUSH
49797: PPUSH
// if not mc_bases or not skirmish then
49798: LD_EXP 76
49802: NOT
49803: PUSH
49804: LD_EXP 74
49808: NOT
49809: OR
49810: IFFALSE 49814
// exit ;
49812: GO 50045
// btype := GetBType ( building ) ;
49814: LD_ADDR_VAR 0 6
49818: PUSH
49819: LD_VAR 0 1
49823: PPUSH
49824: CALL_OW 266
49828: ST_TO_ADDR
// x := GetX ( building ) ;
49829: LD_ADDR_VAR 0 7
49833: PUSH
49834: LD_VAR 0 1
49838: PPUSH
49839: CALL_OW 250
49843: ST_TO_ADDR
// y := GetY ( building ) ;
49844: LD_ADDR_VAR 0 8
49848: PUSH
49849: LD_VAR 0 1
49853: PPUSH
49854: CALL_OW 251
49858: ST_TO_ADDR
// d := GetDir ( building ) ;
49859: LD_ADDR_VAR 0 9
49863: PUSH
49864: LD_VAR 0 1
49868: PPUSH
49869: CALL_OW 254
49873: ST_TO_ADDR
// for i = 1 to mc_bases do
49874: LD_ADDR_VAR 0 4
49878: PUSH
49879: DOUBLE
49880: LD_INT 1
49882: DEC
49883: ST_TO_ADDR
49884: LD_EXP 76
49888: PUSH
49889: FOR_TO
49890: IFFALSE 50043
// begin if not mc_build_list [ i ] then
49892: LD_EXP 81
49896: PUSH
49897: LD_VAR 0 4
49901: ARRAY
49902: NOT
49903: IFFALSE 49907
// continue ;
49905: GO 49889
// if CompareArray ( [ btype , x , y , d ] , mc_build_list [ i ] [ 1 ] ) then
49907: LD_VAR 0 6
49911: PUSH
49912: LD_VAR 0 7
49916: PUSH
49917: LD_VAR 0 8
49921: PUSH
49922: LD_VAR 0 9
49926: PUSH
49927: EMPTY
49928: LIST
49929: LIST
49930: LIST
49931: LIST
49932: PPUSH
49933: LD_EXP 81
49937: PUSH
49938: LD_VAR 0 4
49942: ARRAY
49943: PUSH
49944: LD_INT 1
49946: ARRAY
49947: PPUSH
49948: CALL 63813 0 2
49952: IFFALSE 50041
// begin mc_build_list := Replace ( mc_build_list , i , Delete ( mc_build_list [ i ] , 1 ) ) ;
49954: LD_ADDR_EXP 81
49958: PUSH
49959: LD_EXP 81
49963: PPUSH
49964: LD_VAR 0 4
49968: PPUSH
49969: LD_EXP 81
49973: PUSH
49974: LD_VAR 0 4
49978: ARRAY
49979: PPUSH
49980: LD_INT 1
49982: PPUSH
49983: CALL_OW 3
49987: PPUSH
49988: CALL_OW 1
49992: ST_TO_ADDR
// mc_construct_list := ReplaceIn ( mc_construct_list , [ i , mc_construct_list [ i ] + 1 ] , building ) ;
49993: LD_ADDR_EXP 83
49997: PUSH
49998: LD_EXP 83
50002: PPUSH
50003: LD_VAR 0 4
50007: PUSH
50008: LD_EXP 83
50012: PUSH
50013: LD_VAR 0 4
50017: ARRAY
50018: PUSH
50019: LD_INT 1
50021: PLUS
50022: PUSH
50023: EMPTY
50024: LIST
50025: LIST
50026: PPUSH
50027: LD_VAR 0 1
50031: PPUSH
50032: CALL 57644 0 3
50036: ST_TO_ADDR
// exit ;
50037: POP
50038: POP
50039: GO 50045
// end ; end ;
50041: GO 49889
50043: POP
50044: POP
// end ;
50045: LD_VAR 0 3
50049: RET
// export function MCE_LeaveBuilding ( building , unit ) ; var i , tmp ; begin
50050: LD_INT 0
50052: PPUSH
50053: PPUSH
50054: PPUSH
// if not mc_bases or not skirmish then
50055: LD_EXP 76
50059: NOT
50060: PUSH
50061: LD_EXP 74
50065: NOT
50066: OR
50067: IFFALSE 50071
// exit ;
50069: GO 50261
// for i = 1 to mc_bases do
50071: LD_ADDR_VAR 0 4
50075: PUSH
50076: DOUBLE
50077: LD_INT 1
50079: DEC
50080: ST_TO_ADDR
50081: LD_EXP 76
50085: PUSH
50086: FOR_TO
50087: IFFALSE 50174
// begin if building in mc_turret_list [ i ] and not building in mc_empty_turret_list [ i ] then
50089: LD_VAR 0 1
50093: PUSH
50094: LD_EXP 84
50098: PUSH
50099: LD_VAR 0 4
50103: ARRAY
50104: IN
50105: PUSH
50106: LD_VAR 0 1
50110: PUSH
50111: LD_EXP 85
50115: PUSH
50116: LD_VAR 0 4
50120: ARRAY
50121: IN
50122: NOT
50123: AND
50124: IFFALSE 50172
// begin mc_empty_turret_list := ReplaceIn ( mc_empty_turret_list , [ i , mc_empty_turret_list [ i ] + 1 ] , building ) ;
50126: LD_ADDR_EXP 85
50130: PUSH
50131: LD_EXP 85
50135: PPUSH
50136: LD_VAR 0 4
50140: PUSH
50141: LD_EXP 85
50145: PUSH
50146: LD_VAR 0 4
50150: ARRAY
50151: PUSH
50152: LD_INT 1
50154: PLUS
50155: PUSH
50156: EMPTY
50157: LIST
50158: LIST
50159: PPUSH
50160: LD_VAR 0 1
50164: PPUSH
50165: CALL 57644 0 3
50169: ST_TO_ADDR
// break ;
50170: GO 50174
// end ; end ;
50172: GO 50086
50174: POP
50175: POP
// if GetClass ( building ) in mc_sides and GetBType ( building ) = b_barracks and GetTag ( unit ) <> 18 then
50176: LD_VAR 0 1
50180: PPUSH
50181: CALL_OW 257
50185: PUSH
50186: LD_EXP 102
50190: IN
50191: PUSH
50192: LD_VAR 0 1
50196: PPUSH
50197: CALL_OW 266
50201: PUSH
50202: LD_INT 5
50204: EQUAL
50205: AND
50206: PUSH
50207: LD_VAR 0 2
50211: PPUSH
50212: CALL_OW 110
50216: PUSH
50217: LD_INT 18
50219: NONEQUAL
50220: AND
50221: IFFALSE 50261
// if GetClass ( unit ) in [ 5 , 8 , 9 ] then
50223: LD_VAR 0 2
50227: PPUSH
50228: CALL_OW 257
50232: PUSH
50233: LD_INT 5
50235: PUSH
50236: LD_INT 8
50238: PUSH
50239: LD_INT 9
50241: PUSH
50242: EMPTY
50243: LIST
50244: LIST
50245: LIST
50246: IN
50247: IFFALSE 50261
// SetClass ( unit , 1 ) ;
50249: LD_VAR 0 2
50253: PPUSH
50254: LD_INT 1
50256: PPUSH
50257: CALL_OW 336
// end ;
50261: LD_VAR 0 3
50265: RET
// export function MCE_EvacuateVehicle ( driver , abandoned_vehicle , unknown1 , unknown2 ) ; var i ; begin
50266: LD_INT 0
50268: PPUSH
50269: PPUSH
// if not mc_bases or not skirmish then
50270: LD_EXP 76
50274: NOT
50275: PUSH
50276: LD_EXP 74
50280: NOT
50281: OR
50282: IFFALSE 50286
// exit ;
50284: GO 50402
// if GetLives ( abandoned_vehicle ) > 250 then
50286: LD_VAR 0 2
50290: PPUSH
50291: CALL_OW 256
50295: PUSH
50296: LD_INT 250
50298: GREATER
50299: IFFALSE 50303
// exit ;
50301: GO 50402
// for i = 1 to mc_bases do
50303: LD_ADDR_VAR 0 6
50307: PUSH
50308: DOUBLE
50309: LD_INT 1
50311: DEC
50312: ST_TO_ADDR
50313: LD_EXP 76
50317: PUSH
50318: FOR_TO
50319: IFFALSE 50400
// begin if driver in mc_bases [ i ] then
50321: LD_VAR 0 1
50325: PUSH
50326: LD_EXP 76
50330: PUSH
50331: LD_VAR 0 6
50335: ARRAY
50336: IN
50337: IFFALSE 50398
// begin ComMoveUnit ( driver , UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) [ 1 ] ) ;
50339: LD_VAR 0 1
50343: PPUSH
50344: LD_EXP 76
50348: PUSH
50349: LD_VAR 0 6
50353: ARRAY
50354: PPUSH
50355: LD_INT 2
50357: PUSH
50358: LD_INT 30
50360: PUSH
50361: LD_INT 0
50363: PUSH
50364: EMPTY
50365: LIST
50366: LIST
50367: PUSH
50368: LD_INT 30
50370: PUSH
50371: LD_INT 1
50373: PUSH
50374: EMPTY
50375: LIST
50376: LIST
50377: PUSH
50378: EMPTY
50379: LIST
50380: LIST
50381: LIST
50382: PPUSH
50383: CALL_OW 72
50387: PUSH
50388: LD_INT 1
50390: ARRAY
50391: PPUSH
50392: CALL_OW 112
// break ;
50396: GO 50400
// end ; end ;
50398: GO 50318
50400: POP
50401: POP
// end ; end_of_file
50402: LD_VAR 0 5
50406: RET
// export function PrepareUnit ( ident , exist_mode , prefix ) ; var unit ; begin
50407: LD_INT 0
50409: PPUSH
50410: PPUSH
// if exist_mode then
50411: LD_VAR 0 2
50415: IFFALSE 50440
// unit := CreateCharacter ( prefix & ident ) else
50417: LD_ADDR_VAR 0 5
50421: PUSH
50422: LD_VAR 0 3
50426: PUSH
50427: LD_VAR 0 1
50431: STR
50432: PPUSH
50433: CALL_OW 34
50437: ST_TO_ADDR
50438: GO 50455
// unit := NewCharacter ( ident ) ;
50440: LD_ADDR_VAR 0 5
50444: PUSH
50445: LD_VAR 0 1
50449: PPUSH
50450: CALL_OW 25
50454: ST_TO_ADDR
// result := unit ;
50455: LD_ADDR_VAR 0 4
50459: PUSH
50460: LD_VAR 0 5
50464: ST_TO_ADDR
// end ;
50465: LD_VAR 0 4
50469: RET
// export function GetTechNation ( side , nation , state ) ; var i ; begin
50470: LD_INT 0
50472: PPUSH
50473: PPUSH
// if not side or not nation then
50474: LD_VAR 0 1
50478: NOT
50479: PUSH
50480: LD_VAR 0 2
50484: NOT
50485: OR
50486: IFFALSE 50490
// exit ;
50488: GO 51134
// case nation of nation_american :
50490: LD_VAR 0 2
50494: PUSH
50495: LD_INT 1
50497: DOUBLE
50498: EQUAL
50499: IFTRUE 50503
50501: GO 50677
50503: POP
// result := [ 35 , 45 , 46 , 47 , 1 , 2 , 6 , 15 , 16 , 7 , 12 , 13 , 10 , 14 , 20 , 21 , 22 , 25 , 32 , 27 , 36 , 69 , 39 , 34 , 40 , 48 , 49 , 50 , 51 , 52 , 53 , 54 , 55 , 56 , 57 , 58 , 59 , 60 , 61 , 62 , 80 ] ; nation_arabian :
50504: LD_ADDR_VAR 0 4
50508: PUSH
50509: LD_INT 35
50511: PUSH
50512: LD_INT 45
50514: PUSH
50515: LD_INT 46
50517: PUSH
50518: LD_INT 47
50520: PUSH
50521: LD_INT 1
50523: PUSH
50524: LD_INT 2
50526: PUSH
50527: LD_INT 6
50529: PUSH
50530: LD_INT 15
50532: PUSH
50533: LD_INT 16
50535: PUSH
50536: LD_INT 7
50538: PUSH
50539: LD_INT 12
50541: PUSH
50542: LD_INT 13
50544: PUSH
50545: LD_INT 10
50547: PUSH
50548: LD_INT 14
50550: PUSH
50551: LD_INT 20
50553: PUSH
50554: LD_INT 21
50556: PUSH
50557: LD_INT 22
50559: PUSH
50560: LD_INT 25
50562: PUSH
50563: LD_INT 32
50565: PUSH
50566: LD_INT 27
50568: PUSH
50569: LD_INT 36
50571: PUSH
50572: LD_INT 69
50574: PUSH
50575: LD_INT 39
50577: PUSH
50578: LD_INT 34
50580: PUSH
50581: LD_INT 40
50583: PUSH
50584: LD_INT 48
50586: PUSH
50587: LD_INT 49
50589: PUSH
50590: LD_INT 50
50592: PUSH
50593: LD_INT 51
50595: PUSH
50596: LD_INT 52
50598: PUSH
50599: LD_INT 53
50601: PUSH
50602: LD_INT 54
50604: PUSH
50605: LD_INT 55
50607: PUSH
50608: LD_INT 56
50610: PUSH
50611: LD_INT 57
50613: PUSH
50614: LD_INT 58
50616: PUSH
50617: LD_INT 59
50619: PUSH
50620: LD_INT 60
50622: PUSH
50623: LD_INT 61
50625: PUSH
50626: LD_INT 62
50628: PUSH
50629: LD_INT 80
50631: PUSH
50632: EMPTY
50633: LIST
50634: LIST
50635: LIST
50636: LIST
50637: LIST
50638: LIST
50639: LIST
50640: LIST
50641: LIST
50642: LIST
50643: LIST
50644: LIST
50645: LIST
50646: LIST
50647: LIST
50648: LIST
50649: LIST
50650: LIST
50651: LIST
50652: LIST
50653: LIST
50654: LIST
50655: LIST
50656: LIST
50657: LIST
50658: LIST
50659: LIST
50660: LIST
50661: LIST
50662: LIST
50663: LIST
50664: LIST
50665: LIST
50666: LIST
50667: LIST
50668: LIST
50669: LIST
50670: LIST
50671: LIST
50672: LIST
50673: LIST
50674: ST_TO_ADDR
50675: GO 51058
50677: LD_INT 2
50679: DOUBLE
50680: EQUAL
50681: IFTRUE 50685
50683: GO 50867
50685: POP
// result := [ 35 , 45 , 46 , 47 , 70 , 1 , 11 , 3 , 4 , 5 , 6 , 15 , 18 , 7 , 17 , 8 , 20 , 21 , 22 , 72 , 26 , 69 , 39 , 40 , 41 , 42 , 43 , 48 , 49 , 50 , 51 , 52 , 53 , 54 , 55 , 56 , 60 , 61 , 62 , 66 , 67 , 68 , 81 ] ; nation_russian :
50686: LD_ADDR_VAR 0 4
50690: PUSH
50691: LD_INT 35
50693: PUSH
50694: LD_INT 45
50696: PUSH
50697: LD_INT 46
50699: PUSH
50700: LD_INT 47
50702: PUSH
50703: LD_INT 70
50705: PUSH
50706: LD_INT 1
50708: PUSH
50709: LD_INT 11
50711: PUSH
50712: LD_INT 3
50714: PUSH
50715: LD_INT 4
50717: PUSH
50718: LD_INT 5
50720: PUSH
50721: LD_INT 6
50723: PUSH
50724: LD_INT 15
50726: PUSH
50727: LD_INT 18
50729: PUSH
50730: LD_INT 7
50732: PUSH
50733: LD_INT 17
50735: PUSH
50736: LD_INT 8
50738: PUSH
50739: LD_INT 20
50741: PUSH
50742: LD_INT 21
50744: PUSH
50745: LD_INT 22
50747: PUSH
50748: LD_INT 72
50750: PUSH
50751: LD_INT 26
50753: PUSH
50754: LD_INT 69
50756: PUSH
50757: LD_INT 39
50759: PUSH
50760: LD_INT 40
50762: PUSH
50763: LD_INT 41
50765: PUSH
50766: LD_INT 42
50768: PUSH
50769: LD_INT 43
50771: PUSH
50772: LD_INT 48
50774: PUSH
50775: LD_INT 49
50777: PUSH
50778: LD_INT 50
50780: PUSH
50781: LD_INT 51
50783: PUSH
50784: LD_INT 52
50786: PUSH
50787: LD_INT 53
50789: PUSH
50790: LD_INT 54
50792: PUSH
50793: LD_INT 55
50795: PUSH
50796: LD_INT 56
50798: PUSH
50799: LD_INT 60
50801: PUSH
50802: LD_INT 61
50804: PUSH
50805: LD_INT 62
50807: PUSH
50808: LD_INT 66
50810: PUSH
50811: LD_INT 67
50813: PUSH
50814: LD_INT 68
50816: PUSH
50817: LD_INT 81
50819: PUSH
50820: EMPTY
50821: LIST
50822: LIST
50823: LIST
50824: LIST
50825: LIST
50826: LIST
50827: LIST
50828: LIST
50829: LIST
50830: LIST
50831: LIST
50832: LIST
50833: LIST
50834: LIST
50835: LIST
50836: LIST
50837: LIST
50838: LIST
50839: LIST
50840: LIST
50841: LIST
50842: LIST
50843: LIST
50844: LIST
50845: LIST
50846: LIST
50847: LIST
50848: LIST
50849: LIST
50850: LIST
50851: LIST
50852: LIST
50853: LIST
50854: LIST
50855: LIST
50856: LIST
50857: LIST
50858: LIST
50859: LIST
50860: LIST
50861: LIST
50862: LIST
50863: LIST
50864: ST_TO_ADDR
50865: GO 51058
50867: LD_INT 3
50869: DOUBLE
50870: EQUAL
50871: IFTRUE 50875
50873: GO 51057
50875: POP
// result := [ 46 , 47 , 1 , 2 , 11 , 9 , 20 , 19 , 21 , 24 , 22 , 25 , 28 , 29 , 30 , 31 , 37 , 38 , 32 , 27 , 33 , 69 , 39 , 34 , 40 , 71 , 23 , 44 , 48 , 49 , 50 , 51 , 52 , 53 , 54 , 55 , 56 , 57 , 58 , 59 , 63 , 64 , 65 ] ; end ;
50876: LD_ADDR_VAR 0 4
50880: PUSH
50881: LD_INT 46
50883: PUSH
50884: LD_INT 47
50886: PUSH
50887: LD_INT 1
50889: PUSH
50890: LD_INT 2
50892: PUSH
50893: LD_INT 11
50895: PUSH
50896: LD_INT 9
50898: PUSH
50899: LD_INT 20
50901: PUSH
50902: LD_INT 19
50904: PUSH
50905: LD_INT 21
50907: PUSH
50908: LD_INT 24
50910: PUSH
50911: LD_INT 22
50913: PUSH
50914: LD_INT 25
50916: PUSH
50917: LD_INT 28
50919: PUSH
50920: LD_INT 29
50922: PUSH
50923: LD_INT 30
50925: PUSH
50926: LD_INT 31
50928: PUSH
50929: LD_INT 37
50931: PUSH
50932: LD_INT 38
50934: PUSH
50935: LD_INT 32
50937: PUSH
50938: LD_INT 27
50940: PUSH
50941: LD_INT 33
50943: PUSH
50944: LD_INT 69
50946: PUSH
50947: LD_INT 39
50949: PUSH
50950: LD_INT 34
50952: PUSH
50953: LD_INT 40
50955: PUSH
50956: LD_INT 71
50958: PUSH
50959: LD_INT 23
50961: PUSH
50962: LD_INT 44
50964: PUSH
50965: LD_INT 48
50967: PUSH
50968: LD_INT 49
50970: PUSH
50971: LD_INT 50
50973: PUSH
50974: LD_INT 51
50976: PUSH
50977: LD_INT 52
50979: PUSH
50980: LD_INT 53
50982: PUSH
50983: LD_INT 54
50985: PUSH
50986: LD_INT 55
50988: PUSH
50989: LD_INT 56
50991: PUSH
50992: LD_INT 57
50994: PUSH
50995: LD_INT 58
50997: PUSH
50998: LD_INT 59
51000: PUSH
51001: LD_INT 63
51003: PUSH
51004: LD_INT 64
51006: PUSH
51007: LD_INT 65
51009: PUSH
51010: EMPTY
51011: LIST
51012: LIST
51013: LIST
51014: LIST
51015: LIST
51016: LIST
51017: LIST
51018: LIST
51019: LIST
51020: LIST
51021: LIST
51022: LIST
51023: LIST
51024: LIST
51025: LIST
51026: LIST
51027: LIST
51028: LIST
51029: LIST
51030: LIST
51031: LIST
51032: LIST
51033: LIST
51034: LIST
51035: LIST
51036: LIST
51037: LIST
51038: LIST
51039: LIST
51040: LIST
51041: LIST
51042: LIST
51043: LIST
51044: LIST
51045: LIST
51046: LIST
51047: LIST
51048: LIST
51049: LIST
51050: LIST
51051: LIST
51052: LIST
51053: LIST
51054: ST_TO_ADDR
51055: GO 51058
51057: POP
// if state > - 1 and state < 3 then
51058: LD_VAR 0 3
51062: PUSH
51063: LD_INT 1
51065: NEG
51066: GREATER
51067: PUSH
51068: LD_VAR 0 3
51072: PUSH
51073: LD_INT 3
51075: LESS
51076: AND
51077: IFFALSE 51134
// for i in result do
51079: LD_ADDR_VAR 0 5
51083: PUSH
51084: LD_VAR 0 4
51088: PUSH
51089: FOR_IN
51090: IFFALSE 51132
// if GetTech ( i , side ) <> state then
51092: LD_VAR 0 5
51096: PPUSH
51097: LD_VAR 0 1
51101: PPUSH
51102: CALL_OW 321
51106: PUSH
51107: LD_VAR 0 3
51111: NONEQUAL
51112: IFFALSE 51130
// result := result diff i ;
51114: LD_ADDR_VAR 0 4
51118: PUSH
51119: LD_VAR 0 4
51123: PUSH
51124: LD_VAR 0 5
51128: DIFF
51129: ST_TO_ADDR
51130: GO 51089
51132: POP
51133: POP
// end ;
51134: LD_VAR 0 4
51138: RET
// export function TechCanBeResearch ( side , tech ) ; var i , tmp ; begin
51139: LD_INT 0
51141: PPUSH
51142: PPUSH
51143: PPUSH
// result := true ;
51144: LD_ADDR_VAR 0 3
51148: PUSH
51149: LD_INT 1
51151: ST_TO_ADDR
// tmp := GetTechTechsReq ( tech ) ;
51152: LD_ADDR_VAR 0 5
51156: PUSH
51157: LD_VAR 0 2
51161: PPUSH
51162: CALL_OW 480
51166: ST_TO_ADDR
// if not tmp then
51167: LD_VAR 0 5
51171: NOT
51172: IFFALSE 51176
// exit ;
51174: GO 51225
// for i in tmp do
51176: LD_ADDR_VAR 0 4
51180: PUSH
51181: LD_VAR 0 5
51185: PUSH
51186: FOR_IN
51187: IFFALSE 51223
// if GetTech ( i , side ) <> state_researched then
51189: LD_VAR 0 4
51193: PPUSH
51194: LD_VAR 0 1
51198: PPUSH
51199: CALL_OW 321
51203: PUSH
51204: LD_INT 2
51206: NONEQUAL
51207: IFFALSE 51221
// begin result := false ;
51209: LD_ADDR_VAR 0 3
51213: PUSH
51214: LD_INT 0
51216: ST_TO_ADDR
// exit ;
51217: POP
51218: POP
51219: GO 51225
// end ;
51221: GO 51186
51223: POP
51224: POP
// end ;
51225: LD_VAR 0 3
51229: RET
// export function ComSpaceTimeShoot ( unit ) ; var i , x , y , _x , _y , tmp , side , enemy , in_unit , tech_space , tech_time , missile ; begin
51230: LD_INT 0
51232: PPUSH
51233: PPUSH
51234: PPUSH
51235: PPUSH
51236: PPUSH
51237: PPUSH
51238: PPUSH
51239: PPUSH
51240: PPUSH
51241: PPUSH
51242: PPUSH
51243: PPUSH
51244: PPUSH
// if not unit or GetClass ( unit ) <> class_bazooker then
51245: LD_VAR 0 1
51249: NOT
51250: PUSH
51251: LD_VAR 0 1
51255: PPUSH
51256: CALL_OW 257
51260: PUSH
51261: LD_INT 9
51263: NONEQUAL
51264: OR
51265: IFFALSE 51269
// exit ;
51267: GO 51842
// side := GetSide ( unit ) ;
51269: LD_ADDR_VAR 0 9
51273: PUSH
51274: LD_VAR 0 1
51278: PPUSH
51279: CALL_OW 255
51283: ST_TO_ADDR
// tech_space := tech_spacanom ;
51284: LD_ADDR_VAR 0 12
51288: PUSH
51289: LD_INT 29
51291: ST_TO_ADDR
// tech_time := tech_taurad ;
51292: LD_ADDR_VAR 0 13
51296: PUSH
51297: LD_INT 28
51299: ST_TO_ADDR
// in_unit := IsInUnit ( unit ) ;
51300: LD_ADDR_VAR 0 11
51304: PUSH
51305: LD_VAR 0 1
51309: PPUSH
51310: CALL_OW 310
51314: ST_TO_ADDR
// if GetType ( in_unit ) = unit_vehicle then
51315: LD_VAR 0 11
51319: PPUSH
51320: CALL_OW 247
51324: PUSH
51325: LD_INT 2
51327: EQUAL
51328: IFFALSE 51332
// exit ;
51330: GO 51842
// tmp := FilterAllUnits ( [ [ f_enemy , side ] , [ f_not , [ f_type , unit_building ] ] ] ) ;
51332: LD_ADDR_VAR 0 8
51336: PUSH
51337: LD_INT 81
51339: PUSH
51340: LD_VAR 0 9
51344: PUSH
51345: EMPTY
51346: LIST
51347: LIST
51348: PUSH
51349: LD_INT 3
51351: PUSH
51352: LD_INT 21
51354: PUSH
51355: LD_INT 3
51357: PUSH
51358: EMPTY
51359: LIST
51360: LIST
51361: PUSH
51362: EMPTY
51363: LIST
51364: LIST
51365: PUSH
51366: EMPTY
51367: LIST
51368: LIST
51369: PPUSH
51370: CALL_OW 69
51374: ST_TO_ADDR
// if not tmp then
51375: LD_VAR 0 8
51379: NOT
51380: IFFALSE 51384
// exit ;
51382: GO 51842
// if in_unit then
51384: LD_VAR 0 11
51388: IFFALSE 51412
// enemy := NearestUnitToUnit ( tmp , in_unit ) else
51390: LD_ADDR_VAR 0 10
51394: PUSH
51395: LD_VAR 0 8
51399: PPUSH
51400: LD_VAR 0 11
51404: PPUSH
51405: CALL_OW 74
51409: ST_TO_ADDR
51410: GO 51432
// enemy := NearestUnitToUnit ( tmp , unit ) ;
51412: LD_ADDR_VAR 0 10
51416: PUSH
51417: LD_VAR 0 8
51421: PPUSH
51422: LD_VAR 0 1
51426: PPUSH
51427: CALL_OW 74
51431: ST_TO_ADDR
// if not enemy then
51432: LD_VAR 0 10
51436: NOT
51437: IFFALSE 51441
// exit ;
51439: GO 51842
// if ( in_unit and GetDistUnits ( in_unit , enemy ) > 13 ) or GetDistUnits ( unit , enemy ) > 12 then
51441: LD_VAR 0 11
51445: PUSH
51446: LD_VAR 0 11
51450: PPUSH
51451: LD_VAR 0 10
51455: PPUSH
51456: CALL_OW 296
51460: PUSH
51461: LD_INT 13
51463: GREATER
51464: AND
51465: PUSH
51466: LD_VAR 0 1
51470: PPUSH
51471: LD_VAR 0 10
51475: PPUSH
51476: CALL_OW 296
51480: PUSH
51481: LD_INT 12
51483: GREATER
51484: OR
51485: IFFALSE 51489
// exit ;
51487: GO 51842
// missile := [ 1 ] ;
51489: LD_ADDR_VAR 0 14
51493: PUSH
51494: LD_INT 1
51496: PUSH
51497: EMPTY
51498: LIST
51499: ST_TO_ADDR
// if Researched ( side , tech_space ) then
51500: LD_VAR 0 9
51504: PPUSH
51505: LD_VAR 0 12
51509: PPUSH
51510: CALL_OW 325
51514: IFFALSE 51543
// missile := Insert ( missile , missile + 1 , 2 ) ;
51516: LD_ADDR_VAR 0 14
51520: PUSH
51521: LD_VAR 0 14
51525: PPUSH
51526: LD_VAR 0 14
51530: PUSH
51531: LD_INT 1
51533: PLUS
51534: PPUSH
51535: LD_INT 2
51537: PPUSH
51538: CALL_OW 2
51542: ST_TO_ADDR
// if Researched ( side , tech_time ) and not Researched ( GetSide ( enemy ) , tech_time ) then
51543: LD_VAR 0 9
51547: PPUSH
51548: LD_VAR 0 13
51552: PPUSH
51553: CALL_OW 325
51557: PUSH
51558: LD_VAR 0 10
51562: PPUSH
51563: CALL_OW 255
51567: PPUSH
51568: LD_VAR 0 13
51572: PPUSH
51573: CALL_OW 325
51577: NOT
51578: AND
51579: IFFALSE 51608
// missile := Insert ( missile , missile + 1 , 3 ) ;
51581: LD_ADDR_VAR 0 14
51585: PUSH
51586: LD_VAR 0 14
51590: PPUSH
51591: LD_VAR 0 14
51595: PUSH
51596: LD_INT 1
51598: PLUS
51599: PPUSH
51600: LD_INT 3
51602: PPUSH
51603: CALL_OW 2
51607: ST_TO_ADDR
// if missile < 2 then
51608: LD_VAR 0 14
51612: PUSH
51613: LD_INT 2
51615: LESS
51616: IFFALSE 51620
// exit ;
51618: GO 51842
// x := GetX ( enemy ) ;
51620: LD_ADDR_VAR 0 4
51624: PUSH
51625: LD_VAR 0 10
51629: PPUSH
51630: CALL_OW 250
51634: ST_TO_ADDR
// y := GetY ( enemy ) ;
51635: LD_ADDR_VAR 0 5
51639: PUSH
51640: LD_VAR 0 10
51644: PPUSH
51645: CALL_OW 251
51649: ST_TO_ADDR
// _x := x + rand ( - 1 , 1 ) ;
51650: LD_ADDR_VAR 0 6
51654: PUSH
51655: LD_VAR 0 4
51659: PUSH
51660: LD_INT 1
51662: NEG
51663: PPUSH
51664: LD_INT 1
51666: PPUSH
51667: CALL_OW 12
51671: PLUS
51672: ST_TO_ADDR
// _y := y + rand ( - 1 , 1 ) ;
51673: LD_ADDR_VAR 0 7
51677: PUSH
51678: LD_VAR 0 5
51682: PUSH
51683: LD_INT 1
51685: NEG
51686: PPUSH
51687: LD_INT 1
51689: PPUSH
51690: CALL_OW 12
51694: PLUS
51695: ST_TO_ADDR
// if not ValidHex ( _x , _y ) then
51696: LD_VAR 0 6
51700: PPUSH
51701: LD_VAR 0 7
51705: PPUSH
51706: CALL_OW 488
51710: NOT
51711: IFFALSE 51733
// begin _x := x ;
51713: LD_ADDR_VAR 0 6
51717: PUSH
51718: LD_VAR 0 4
51722: ST_TO_ADDR
// _y := y ;
51723: LD_ADDR_VAR 0 7
51727: PUSH
51728: LD_VAR 0 5
51732: ST_TO_ADDR
// end ; i := rand ( 1 , missile ) ;
51733: LD_ADDR_VAR 0 3
51737: PUSH
51738: LD_INT 1
51740: PPUSH
51741: LD_VAR 0 14
51745: PPUSH
51746: CALL_OW 12
51750: ST_TO_ADDR
// case i of 1 :
51751: LD_VAR 0 3
51755: PUSH
51756: LD_INT 1
51758: DOUBLE
51759: EQUAL
51760: IFTRUE 51764
51762: GO 51781
51764: POP
// ComAttackUnit ( unit , enemy ) ; 2 :
51765: LD_VAR 0 1
51769: PPUSH
51770: LD_VAR 0 10
51774: PPUSH
51775: CALL_OW 115
51779: GO 51842
51781: LD_INT 2
51783: DOUBLE
51784: EQUAL
51785: IFTRUE 51789
51787: GO 51811
51789: POP
// ComSpaceShift ( unit , _x , _y ) ; 3 :
51790: LD_VAR 0 1
51794: PPUSH
51795: LD_VAR 0 6
51799: PPUSH
51800: LD_VAR 0 7
51804: PPUSH
51805: CALL_OW 153
51809: GO 51842
51811: LD_INT 3
51813: DOUBLE
51814: EQUAL
51815: IFTRUE 51819
51817: GO 51841
51819: POP
// ComTimeShift ( unit , _x , _y ) ; end ;
51820: LD_VAR 0 1
51824: PPUSH
51825: LD_VAR 0 6
51829: PPUSH
51830: LD_VAR 0 7
51834: PPUSH
51835: CALL_OW 154
51839: GO 51842
51841: POP
// end ;
51842: LD_VAR 0 2
51846: RET
// export function ComStandNearbyBuilding ( unit , building ) ; var i , x , y , _x , _y ; begin
51847: LD_INT 0
51849: PPUSH
51850: PPUSH
51851: PPUSH
51852: PPUSH
51853: PPUSH
51854: PPUSH
// if not unit or not building then
51855: LD_VAR 0 1
51859: NOT
51860: PUSH
51861: LD_VAR 0 2
51865: NOT
51866: OR
51867: IFFALSE 51871
// exit ;
51869: GO 52029
// x := GetX ( building ) ;
51871: LD_ADDR_VAR 0 5
51875: PUSH
51876: LD_VAR 0 2
51880: PPUSH
51881: CALL_OW 250
51885: ST_TO_ADDR
// y := GetY ( building ) ;
51886: LD_ADDR_VAR 0 6
51890: PUSH
51891: LD_VAR 0 2
51895: PPUSH
51896: CALL_OW 251
51900: ST_TO_ADDR
// for i = 0 to 5 do
51901: LD_ADDR_VAR 0 4
51905: PUSH
51906: DOUBLE
51907: LD_INT 0
51909: DEC
51910: ST_TO_ADDR
51911: LD_INT 5
51913: PUSH
51914: FOR_TO
51915: IFFALSE 52027
// begin _x := ShiftX ( x , i , 3 ) ;
51917: LD_ADDR_VAR 0 7
51921: PUSH
51922: LD_VAR 0 5
51926: PPUSH
51927: LD_VAR 0 4
51931: PPUSH
51932: LD_INT 3
51934: PPUSH
51935: CALL_OW 272
51939: ST_TO_ADDR
// _y := ShiftY ( y , i , 3 ) ;
51940: LD_ADDR_VAR 0 8
51944: PUSH
51945: LD_VAR 0 6
51949: PPUSH
51950: LD_VAR 0 4
51954: PPUSH
51955: LD_INT 3
51957: PPUSH
51958: CALL_OW 273
51962: ST_TO_ADDR
// if not ValidHex ( _x , _y ) then
51963: LD_VAR 0 7
51967: PPUSH
51968: LD_VAR 0 8
51972: PPUSH
51973: CALL_OW 488
51977: NOT
51978: IFFALSE 51982
// continue ;
51980: GO 51914
// if HexInfo ( _x , _y ) = 0 then
51982: LD_VAR 0 7
51986: PPUSH
51987: LD_VAR 0 8
51991: PPUSH
51992: CALL_OW 428
51996: PUSH
51997: LD_INT 0
51999: EQUAL
52000: IFFALSE 52025
// begin ComMoveXY ( unit , _x , _y ) ;
52002: LD_VAR 0 1
52006: PPUSH
52007: LD_VAR 0 7
52011: PPUSH
52012: LD_VAR 0 8
52016: PPUSH
52017: CALL_OW 111
// exit ;
52021: POP
52022: POP
52023: GO 52029
// end ; end ;
52025: GO 51914
52027: POP
52028: POP
// end ;
52029: LD_VAR 0 3
52033: RET
// export function ScanBase ( side , base_area ) ; begin
52034: LD_INT 0
52036: PPUSH
// result := FilterUnitsInArea ( base_area , [ f_enemy , side ] ) ;
52037: LD_ADDR_VAR 0 3
52041: PUSH
52042: LD_VAR 0 2
52046: PPUSH
52047: LD_INT 81
52049: PUSH
52050: LD_VAR 0 1
52054: PUSH
52055: EMPTY
52056: LIST
52057: LIST
52058: PPUSH
52059: CALL_OW 70
52063: ST_TO_ADDR
// end ;
52064: LD_VAR 0 3
52068: RET
// export function BasicDefend ( base , solds , area ) ; var enemy , side , i , hex ; begin
52069: LD_INT 0
52071: PPUSH
52072: PPUSH
52073: PPUSH
52074: PPUSH
52075: PPUSH
// if not base or not mc_bases [ base ] or not solds or not area then
52076: LD_VAR 0 1
52080: NOT
52081: PUSH
52082: LD_EXP 76
52086: PUSH
52087: LD_VAR 0 1
52091: ARRAY
52092: NOT
52093: OR
52094: PUSH
52095: LD_VAR 0 2
52099: NOT
52100: OR
52101: PUSH
52102: LD_VAR 0 3
52106: NOT
52107: OR
52108: IFFALSE 52112
// exit ;
52110: GO 52625
// side := mc_sides [ base ] ;
52112: LD_ADDR_VAR 0 6
52116: PUSH
52117: LD_EXP 102
52121: PUSH
52122: LD_VAR 0 1
52126: ARRAY
52127: ST_TO_ADDR
// if not side then
52128: LD_VAR 0 6
52132: NOT
52133: IFFALSE 52137
// exit ;
52135: GO 52625
// for i in solds do
52137: LD_ADDR_VAR 0 7
52141: PUSH
52142: LD_VAR 0 2
52146: PUSH
52147: FOR_IN
52148: IFFALSE 52209
// if GetBType ( IsInUnit ( i ) ) in [ b_bunker , b_breastwork ] then
52150: LD_VAR 0 7
52154: PPUSH
52155: CALL_OW 310
52159: PPUSH
52160: CALL_OW 266
52164: PUSH
52165: LD_INT 32
52167: PUSH
52168: LD_INT 31
52170: PUSH
52171: EMPTY
52172: LIST
52173: LIST
52174: IN
52175: IFFALSE 52195
// solds := solds diff i else
52177: LD_ADDR_VAR 0 2
52181: PUSH
52182: LD_VAR 0 2
52186: PUSH
52187: LD_VAR 0 7
52191: DIFF
52192: ST_TO_ADDR
52193: GO 52207
// SetTag ( i , 18 ) ;
52195: LD_VAR 0 7
52199: PPUSH
52200: LD_INT 18
52202: PPUSH
52203: CALL_OW 109
52207: GO 52147
52209: POP
52210: POP
// if not solds then
52211: LD_VAR 0 2
52215: NOT
52216: IFFALSE 52220
// exit ;
52218: GO 52625
// repeat wait ( 0 0$1 ) ;
52220: LD_INT 35
52222: PPUSH
52223: CALL_OW 67
// enemy := ScanBase ( side , area ) ;
52227: LD_ADDR_VAR 0 5
52231: PUSH
52232: LD_VAR 0 6
52236: PPUSH
52237: LD_VAR 0 3
52241: PPUSH
52242: CALL 52034 0 2
52246: ST_TO_ADDR
// if not mc_bases [ base ] or mc_bases [ base ] = [ ] then
52247: LD_EXP 76
52251: PUSH
52252: LD_VAR 0 1
52256: ARRAY
52257: NOT
52258: PUSH
52259: LD_EXP 76
52263: PUSH
52264: LD_VAR 0 1
52268: ARRAY
52269: PUSH
52270: EMPTY
52271: EQUAL
52272: OR
52273: IFFALSE 52310
// begin for i in solds do
52275: LD_ADDR_VAR 0 7
52279: PUSH
52280: LD_VAR 0 2
52284: PUSH
52285: FOR_IN
52286: IFFALSE 52299
// ComStop ( i ) ;
52288: LD_VAR 0 7
52292: PPUSH
52293: CALL_OW 141
52297: GO 52285
52299: POP
52300: POP
// solds := [ ] ;
52301: LD_ADDR_VAR 0 2
52305: PUSH
52306: EMPTY
52307: ST_TO_ADDR
// exit ;
52308: GO 52625
// end ; if not enemy or enemy > 3 or mc_defender [ base ] then
52310: LD_VAR 0 5
52314: NOT
52315: PUSH
52316: LD_VAR 0 5
52320: PUSH
52321: LD_INT 3
52323: GREATER
52324: OR
52325: PUSH
52326: LD_EXP 98
52330: PUSH
52331: LD_VAR 0 1
52335: ARRAY
52336: OR
52337: IFFALSE 52378
// begin for i in solds do
52339: LD_ADDR_VAR 0 7
52343: PUSH
52344: LD_VAR 0 2
52348: PUSH
52349: FOR_IN
52350: IFFALSE 52374
// if HasTask ( i ) then
52352: LD_VAR 0 7
52356: PPUSH
52357: CALL_OW 314
52361: IFFALSE 52372
// ComStop ( i ) ;
52363: LD_VAR 0 7
52367: PPUSH
52368: CALL_OW 141
52372: GO 52349
52374: POP
52375: POP
// break ;
52376: GO 52613
// end ; for i in solds do
52378: LD_ADDR_VAR 0 7
52382: PUSH
52383: LD_VAR 0 2
52387: PUSH
52388: FOR_IN
52389: IFFALSE 52605
// begin if IsInUnit ( i ) then
52391: LD_VAR 0 7
52395: PPUSH
52396: CALL_OW 310
52400: IFFALSE 52411
// ComExitBuilding ( i ) ;
52402: LD_VAR 0 7
52406: PPUSH
52407: CALL_OW 122
// if GetLives ( i ) > 333 then
52411: LD_VAR 0 7
52415: PPUSH
52416: CALL_OW 256
52420: PUSH
52421: LD_INT 333
52423: GREATER
52424: IFFALSE 52452
// ComAttackUnit ( i , NearestUnitToUnit ( enemy , i ) ) else
52426: LD_VAR 0 7
52430: PPUSH
52431: LD_VAR 0 5
52435: PPUSH
52436: LD_VAR 0 7
52440: PPUSH
52441: CALL_OW 74
52445: PPUSH
52446: CALL_OW 115
52450: GO 52603
// begin hex := NearestUnitToUnit ( UnitFilter ( mc_bases [ base ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] , [ f_btype , b_lab ] ] ) , i ) ;
52452: LD_ADDR_VAR 0 8
52456: PUSH
52457: LD_EXP 76
52461: PUSH
52462: LD_VAR 0 1
52466: ARRAY
52467: PPUSH
52468: LD_INT 2
52470: PUSH
52471: LD_INT 30
52473: PUSH
52474: LD_INT 0
52476: PUSH
52477: EMPTY
52478: LIST
52479: LIST
52480: PUSH
52481: LD_INT 30
52483: PUSH
52484: LD_INT 1
52486: PUSH
52487: EMPTY
52488: LIST
52489: LIST
52490: PUSH
52491: LD_INT 30
52493: PUSH
52494: LD_INT 6
52496: PUSH
52497: EMPTY
52498: LIST
52499: LIST
52500: PUSH
52501: EMPTY
52502: LIST
52503: LIST
52504: LIST
52505: LIST
52506: PPUSH
52507: CALL_OW 72
52511: PPUSH
52512: LD_VAR 0 7
52516: PPUSH
52517: CALL_OW 74
52521: ST_TO_ADDR
// ComMoveXY ( i , ShiftX ( GetX ( hex ) , 3 , 5 ) , ShiftY ( GetY ( hex ) , 3 , 5 ) ) ;
52522: LD_VAR 0 7
52526: PPUSH
52527: LD_VAR 0 8
52531: PPUSH
52532: CALL_OW 250
52536: PPUSH
52537: LD_INT 3
52539: PPUSH
52540: LD_INT 5
52542: PPUSH
52543: CALL_OW 272
52547: PPUSH
52548: LD_VAR 0 8
52552: PPUSH
52553: CALL_OW 251
52557: PPUSH
52558: LD_INT 3
52560: PPUSH
52561: LD_INT 5
52563: PPUSH
52564: CALL_OW 273
52568: PPUSH
52569: CALL_OW 111
// SetTag ( i , 0 ) ;
52573: LD_VAR 0 7
52577: PPUSH
52578: LD_INT 0
52580: PPUSH
52581: CALL_OW 109
// solds := solds diff i ;
52585: LD_ADDR_VAR 0 2
52589: PUSH
52590: LD_VAR 0 2
52594: PUSH
52595: LD_VAR 0 7
52599: DIFF
52600: ST_TO_ADDR
// continue ;
52601: GO 52388
// end ; end ;
52603: GO 52388
52605: POP
52606: POP
// until solds ;
52607: LD_VAR 0 2
52611: IFFALSE 52220
// MC_Reset ( base , 18 ) ;
52613: LD_VAR 0 1
52617: PPUSH
52618: LD_INT 18
52620: PPUSH
52621: CALL 24446 0 2
// end ;
52625: LD_VAR 0 4
52629: RET
// export function Defend ( base , defenders , enemy ) ; var i , j , x , depot , solds , mech , un , tmp , mechs , e , fac , components , depot_under_attack , sold_defenders , b , can_defend ; begin
52630: LD_INT 0
52632: PPUSH
52633: PPUSH
52634: PPUSH
52635: PPUSH
52636: PPUSH
52637: PPUSH
52638: PPUSH
52639: PPUSH
52640: PPUSH
52641: PPUSH
52642: PPUSH
52643: PPUSH
52644: PPUSH
52645: PPUSH
52646: PPUSH
52647: PPUSH
52648: PPUSH
// mechs := UnitFilter ( mc_bases [ base ] , [ f_class , 3 ] ) ;
52649: LD_ADDR_VAR 0 13
52653: PUSH
52654: LD_EXP 76
52658: PUSH
52659: LD_VAR 0 1
52663: ARRAY
52664: PPUSH
52665: LD_INT 25
52667: PUSH
52668: LD_INT 3
52670: PUSH
52671: EMPTY
52672: LIST
52673: LIST
52674: PPUSH
52675: CALL_OW 72
52679: ST_TO_ADDR
// if mc_remote_driver [ base ] then
52680: LD_EXP 116
52684: PUSH
52685: LD_VAR 0 1
52689: ARRAY
52690: IFFALSE 52714
// mechs := mechs diff mc_remote_driver [ base ] ;
52692: LD_ADDR_VAR 0 13
52696: PUSH
52697: LD_VAR 0 13
52701: PUSH
52702: LD_EXP 116
52706: PUSH
52707: LD_VAR 0 1
52711: ARRAY
52712: DIFF
52713: ST_TO_ADDR
// for i in mechs do
52714: LD_ADDR_VAR 0 5
52718: PUSH
52719: LD_VAR 0 13
52723: PUSH
52724: FOR_IN
52725: IFFALSE 52760
// if GetTag ( i ) > 0 then
52727: LD_VAR 0 5
52731: PPUSH
52732: CALL_OW 110
52736: PUSH
52737: LD_INT 0
52739: GREATER
52740: IFFALSE 52758
// mechs := mechs diff i ;
52742: LD_ADDR_VAR 0 13
52746: PUSH
52747: LD_VAR 0 13
52751: PUSH
52752: LD_VAR 0 5
52756: DIFF
52757: ST_TO_ADDR
52758: GO 52724
52760: POP
52761: POP
// solds := UnitFilter ( mc_bases [ base ] , [ f_or , [ f_class , 1 ] , [ f_class , 5 ] , [ f_class , 8 ] , [ f_class , 9 ] ] ) ;
52762: LD_ADDR_VAR 0 9
52766: PUSH
52767: LD_EXP 76
52771: PUSH
52772: LD_VAR 0 1
52776: ARRAY
52777: PPUSH
52778: LD_INT 2
52780: PUSH
52781: LD_INT 25
52783: PUSH
52784: LD_INT 1
52786: PUSH
52787: EMPTY
52788: LIST
52789: LIST
52790: PUSH
52791: LD_INT 25
52793: PUSH
52794: LD_INT 5
52796: PUSH
52797: EMPTY
52798: LIST
52799: LIST
52800: PUSH
52801: LD_INT 25
52803: PUSH
52804: LD_INT 8
52806: PUSH
52807: EMPTY
52808: LIST
52809: LIST
52810: PUSH
52811: LD_INT 25
52813: PUSH
52814: LD_INT 9
52816: PUSH
52817: EMPTY
52818: LIST
52819: LIST
52820: PUSH
52821: EMPTY
52822: LIST
52823: LIST
52824: LIST
52825: LIST
52826: LIST
52827: PPUSH
52828: CALL_OW 72
52832: ST_TO_ADDR
// if not defenders and not solds then
52833: LD_VAR 0 2
52837: NOT
52838: PUSH
52839: LD_VAR 0 9
52843: NOT
52844: AND
52845: IFFALSE 52849
// exit ;
52847: GO 54475
// depot_under_attack := false ;
52849: LD_ADDR_VAR 0 17
52853: PUSH
52854: LD_INT 0
52856: ST_TO_ADDR
// sold_defenders := [ ] ;
52857: LD_ADDR_VAR 0 18
52861: PUSH
52862: EMPTY
52863: ST_TO_ADDR
// if mechs then
52864: LD_VAR 0 13
52868: IFFALSE 52997
// for i in defenders do
52870: LD_ADDR_VAR 0 5
52874: PUSH
52875: LD_VAR 0 2
52879: PUSH
52880: FOR_IN
52881: IFFALSE 52995
// begin SetTag ( i , 20 ) ;
52883: LD_VAR 0 5
52887: PPUSH
52888: LD_INT 20
52890: PPUSH
52891: CALL_OW 109
// if GetControl ( i ) = control_manual and not IsDrivenBy ( i ) and mechs then
52895: LD_VAR 0 5
52899: PPUSH
52900: CALL_OW 263
52904: PUSH
52905: LD_INT 1
52907: EQUAL
52908: PUSH
52909: LD_VAR 0 5
52913: PPUSH
52914: CALL_OW 311
52918: NOT
52919: AND
52920: PUSH
52921: LD_VAR 0 13
52925: AND
52926: IFFALSE 52993
// begin un := mechs [ 1 ] ;
52928: LD_ADDR_VAR 0 11
52932: PUSH
52933: LD_VAR 0 13
52937: PUSH
52938: LD_INT 1
52940: ARRAY
52941: ST_TO_ADDR
// ComExitBuilding ( un ) ;
52942: LD_VAR 0 11
52946: PPUSH
52947: CALL_OW 122
// AddComEnterUnit ( un , i ) ;
52951: LD_VAR 0 11
52955: PPUSH
52956: LD_VAR 0 5
52960: PPUSH
52961: CALL_OW 180
// SetTag ( un , 19 ) ;
52965: LD_VAR 0 11
52969: PPUSH
52970: LD_INT 19
52972: PPUSH
52973: CALL_OW 109
// mechs := mechs diff un ;
52977: LD_ADDR_VAR 0 13
52981: PUSH
52982: LD_VAR 0 13
52986: PUSH
52987: LD_VAR 0 11
52991: DIFF
52992: ST_TO_ADDR
// end ; end ;
52993: GO 52880
52995: POP
52996: POP
// if solds then
52997: LD_VAR 0 9
53001: IFFALSE 53060
// for i in solds do
53003: LD_ADDR_VAR 0 5
53007: PUSH
53008: LD_VAR 0 9
53012: PUSH
53013: FOR_IN
53014: IFFALSE 53058
// if not GetTag ( i ) then
53016: LD_VAR 0 5
53020: PPUSH
53021: CALL_OW 110
53025: NOT
53026: IFFALSE 53056
// begin defenders := defenders union i ;
53028: LD_ADDR_VAR 0 2
53032: PUSH
53033: LD_VAR 0 2
53037: PUSH
53038: LD_VAR 0 5
53042: UNION
53043: ST_TO_ADDR
// SetTag ( i , 18 ) ;
53044: LD_VAR 0 5
53048: PPUSH
53049: LD_INT 18
53051: PPUSH
53052: CALL_OW 109
// end ;
53056: GO 53013
53058: POP
53059: POP
// repeat wait ( 0 0$1 ) ;
53060: LD_INT 35
53062: PPUSH
53063: CALL_OW 67
// enemy := mc_scan [ base ] ;
53067: LD_ADDR_VAR 0 3
53071: PUSH
53072: LD_EXP 99
53076: PUSH
53077: LD_VAR 0 1
53081: ARRAY
53082: ST_TO_ADDR
// if not mc_bases [ base ] or mc_bases [ base ] = [ ] then
53083: LD_EXP 76
53087: PUSH
53088: LD_VAR 0 1
53092: ARRAY
53093: NOT
53094: PUSH
53095: LD_EXP 76
53099: PUSH
53100: LD_VAR 0 1
53104: ARRAY
53105: PUSH
53106: EMPTY
53107: EQUAL
53108: OR
53109: IFFALSE 53146
// begin for i in defenders do
53111: LD_ADDR_VAR 0 5
53115: PUSH
53116: LD_VAR 0 2
53120: PUSH
53121: FOR_IN
53122: IFFALSE 53135
// ComStop ( i ) ;
53124: LD_VAR 0 5
53128: PPUSH
53129: CALL_OW 141
53133: GO 53121
53135: POP
53136: POP
// defenders := [ ] ;
53137: LD_ADDR_VAR 0 2
53141: PUSH
53142: EMPTY
53143: ST_TO_ADDR
// exit ;
53144: GO 54475
// end ; for i in defenders do
53146: LD_ADDR_VAR 0 5
53150: PUSH
53151: LD_VAR 0 2
53155: PUSH
53156: FOR_IN
53157: IFFALSE 53975
// begin e := NearestUnitToUnit ( enemy , i ) ;
53159: LD_ADDR_VAR 0 14
53163: PUSH
53164: LD_VAR 0 3
53168: PPUSH
53169: LD_VAR 0 5
53173: PPUSH
53174: CALL_OW 74
53178: ST_TO_ADDR
// depot := UnitFilter ( mc_bases [ base ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) ;
53179: LD_ADDR_VAR 0 8
53183: PUSH
53184: LD_EXP 76
53188: PUSH
53189: LD_VAR 0 1
53193: ARRAY
53194: PPUSH
53195: LD_INT 2
53197: PUSH
53198: LD_INT 30
53200: PUSH
53201: LD_INT 0
53203: PUSH
53204: EMPTY
53205: LIST
53206: LIST
53207: PUSH
53208: LD_INT 30
53210: PUSH
53211: LD_INT 1
53213: PUSH
53214: EMPTY
53215: LIST
53216: LIST
53217: PUSH
53218: EMPTY
53219: LIST
53220: LIST
53221: LIST
53222: PPUSH
53223: CALL_OW 72
53227: ST_TO_ADDR
// depot_under_attack := ( not depot or UnitFilter ( depot , [ f_not , [ f_lives , 600 ] ] ) ) ;
53228: LD_ADDR_VAR 0 17
53232: PUSH
53233: LD_VAR 0 8
53237: NOT
53238: PUSH
53239: LD_VAR 0 8
53243: PPUSH
53244: LD_INT 3
53246: PUSH
53247: LD_INT 24
53249: PUSH
53250: LD_INT 600
53252: PUSH
53253: EMPTY
53254: LIST
53255: LIST
53256: PUSH
53257: EMPTY
53258: LIST
53259: LIST
53260: PPUSH
53261: CALL_OW 72
53265: OR
53266: ST_TO_ADDR
// case GetType ( i ) of unit_vehicle :
53267: LD_VAR 0 5
53271: PPUSH
53272: CALL_OW 247
53276: PUSH
53277: LD_INT 2
53279: DOUBLE
53280: EQUAL
53281: IFTRUE 53285
53283: GO 53681
53285: POP
// begin if GetLives ( i ) > 650 and ( GetDistUnits ( i , e ) < 40 or IsInArea ( e , mc_scan_area [ base ] ) ) then
53286: LD_VAR 0 5
53290: PPUSH
53291: CALL_OW 256
53295: PUSH
53296: LD_INT 650
53298: GREATER
53299: PUSH
53300: LD_VAR 0 5
53304: PPUSH
53305: LD_VAR 0 14
53309: PPUSH
53310: CALL_OW 296
53314: PUSH
53315: LD_INT 40
53317: LESS
53318: PUSH
53319: LD_VAR 0 14
53323: PPUSH
53324: LD_EXP 101
53328: PUSH
53329: LD_VAR 0 1
53333: ARRAY
53334: PPUSH
53335: CALL_OW 308
53339: OR
53340: AND
53341: IFFALSE 53463
// begin if GetEngine ( i ) = engine_combustion and GetFuel ( i ) < 30 and depot then
53343: LD_VAR 0 5
53347: PPUSH
53348: CALL_OW 262
53352: PUSH
53353: LD_INT 1
53355: EQUAL
53356: PUSH
53357: LD_VAR 0 5
53361: PPUSH
53362: CALL_OW 261
53366: PUSH
53367: LD_INT 30
53369: LESS
53370: AND
53371: PUSH
53372: LD_VAR 0 8
53376: AND
53377: IFFALSE 53447
// begin ComMoveUnit ( i , NearestUnitToUnit ( depot , i ) ) ;
53379: LD_VAR 0 5
53383: PPUSH
53384: LD_VAR 0 8
53388: PPUSH
53389: LD_VAR 0 5
53393: PPUSH
53394: CALL_OW 74
53398: PPUSH
53399: CALL_OW 112
// if GetDistUnits ( i , NearestUnitToUnit ( depot , i ) ) < 6 then
53403: LD_VAR 0 5
53407: PPUSH
53408: LD_VAR 0 8
53412: PPUSH
53413: LD_VAR 0 5
53417: PPUSH
53418: CALL_OW 74
53422: PPUSH
53423: CALL_OW 296
53427: PUSH
53428: LD_INT 6
53430: LESS
53431: IFFALSE 53445
// SetFuel ( i , 100 ) ;
53433: LD_VAR 0 5
53437: PPUSH
53438: LD_INT 100
53440: PPUSH
53441: CALL_OW 240
// end else
53445: GO 53461
// ComAttackUnit ( i , e ) ;
53447: LD_VAR 0 5
53451: PPUSH
53452: LD_VAR 0 14
53456: PPUSH
53457: CALL_OW 115
// end else
53461: GO 53564
// if ( ( not IsInArea ( e , mc_scan_area [ base ] ) and GetDistUnits ( i , e ) >= 40 ) or GetLives ( i ) <= 650 ) and not IsInArea ( i , mc_parking [ base ] ) then
53463: LD_VAR 0 14
53467: PPUSH
53468: LD_EXP 101
53472: PUSH
53473: LD_VAR 0 1
53477: ARRAY
53478: PPUSH
53479: CALL_OW 308
53483: NOT
53484: PUSH
53485: LD_VAR 0 5
53489: PPUSH
53490: LD_VAR 0 14
53494: PPUSH
53495: CALL_OW 296
53499: PUSH
53500: LD_INT 40
53502: GREATEREQUAL
53503: AND
53504: PUSH
53505: LD_VAR 0 5
53509: PPUSH
53510: CALL_OW 256
53514: PUSH
53515: LD_INT 650
53517: LESSEQUAL
53518: OR
53519: PUSH
53520: LD_VAR 0 5
53524: PPUSH
53525: LD_EXP 100
53529: PUSH
53530: LD_VAR 0 1
53534: ARRAY
53535: PPUSH
53536: CALL_OW 308
53540: NOT
53541: AND
53542: IFFALSE 53564
// ComMoveToArea ( i , mc_parking [ base ] ) ;
53544: LD_VAR 0 5
53548: PPUSH
53549: LD_EXP 100
53553: PUSH
53554: LD_VAR 0 1
53558: ARRAY
53559: PPUSH
53560: CALL_OW 113
// if GetLives ( i ) < 998 and GetControl ( i ) = control_manual and IsDrivenBy ( i ) and IsInArea ( i , mc_parking [ base ] ) then
53564: LD_VAR 0 5
53568: PPUSH
53569: CALL_OW 256
53573: PUSH
53574: LD_INT 998
53576: LESS
53577: PUSH
53578: LD_VAR 0 5
53582: PPUSH
53583: CALL_OW 263
53587: PUSH
53588: LD_INT 1
53590: EQUAL
53591: AND
53592: PUSH
53593: LD_VAR 0 5
53597: PPUSH
53598: CALL_OW 311
53602: AND
53603: PUSH
53604: LD_VAR 0 5
53608: PPUSH
53609: LD_EXP 100
53613: PUSH
53614: LD_VAR 0 1
53618: ARRAY
53619: PPUSH
53620: CALL_OW 308
53624: AND
53625: IFFALSE 53679
// begin mech := IsDrivenBy ( i ) ;
53627: LD_ADDR_VAR 0 10
53631: PUSH
53632: LD_VAR 0 5
53636: PPUSH
53637: CALL_OW 311
53641: ST_TO_ADDR
// ComExitVehicle ( mech ) ;
53642: LD_VAR 0 10
53646: PPUSH
53647: CALL_OW 121
// AddComRepairVehicle ( mech , i ) ;
53651: LD_VAR 0 10
53655: PPUSH
53656: LD_VAR 0 5
53660: PPUSH
53661: CALL_OW 189
// AddComEnterUnit ( mech , i ) ;
53665: LD_VAR 0 10
53669: PPUSH
53670: LD_VAR 0 5
53674: PPUSH
53675: CALL_OW 180
// end ; end ; unit_human :
53679: GO 53946
53681: LD_INT 1
53683: DOUBLE
53684: EQUAL
53685: IFTRUE 53689
53687: GO 53945
53689: POP
// begin b := IsInUnit ( i ) ;
53690: LD_ADDR_VAR 0 19
53694: PUSH
53695: LD_VAR 0 5
53699: PPUSH
53700: CALL_OW 310
53704: ST_TO_ADDR
// can_defend := ( not b or GetBType ( b ) in [ b_bunker , b_breastwork ] ) ;
53705: LD_ADDR_VAR 0 20
53709: PUSH
53710: LD_VAR 0 19
53714: NOT
53715: PUSH
53716: LD_VAR 0 19
53720: PPUSH
53721: CALL_OW 266
53725: PUSH
53726: LD_INT 32
53728: PUSH
53729: LD_INT 31
53731: PUSH
53732: EMPTY
53733: LIST
53734: LIST
53735: IN
53736: OR
53737: ST_TO_ADDR
// if ( depot_under_attack or UnitFilter ( defenders , [ f_type , unit_vehicle ] ) <= 1 ) and can_defend and not i in sold_defenders then
53738: LD_VAR 0 17
53742: PUSH
53743: LD_VAR 0 2
53747: PPUSH
53748: LD_INT 21
53750: PUSH
53751: LD_INT 2
53753: PUSH
53754: EMPTY
53755: LIST
53756: LIST
53757: PPUSH
53758: CALL_OW 72
53762: PUSH
53763: LD_INT 1
53765: LESSEQUAL
53766: OR
53767: PUSH
53768: LD_VAR 0 20
53772: AND
53773: PUSH
53774: LD_VAR 0 5
53778: PUSH
53779: LD_VAR 0 18
53783: IN
53784: NOT
53785: AND
53786: IFFALSE 53879
// begin if b then
53788: LD_VAR 0 19
53792: IFFALSE 53841
// if GetDistUnits ( b , NearestUnitToUnit ( enemy , b ) ) < 10 and BuildingStatus ( b ) <> bs_need_power then
53794: LD_VAR 0 19
53798: PPUSH
53799: LD_VAR 0 3
53803: PPUSH
53804: LD_VAR 0 19
53808: PPUSH
53809: CALL_OW 74
53813: PPUSH
53814: CALL_OW 296
53818: PUSH
53819: LD_INT 10
53821: LESS
53822: PUSH
53823: LD_VAR 0 19
53827: PPUSH
53828: CALL_OW 461
53832: PUSH
53833: LD_INT 7
53835: NONEQUAL
53836: AND
53837: IFFALSE 53841
// continue ;
53839: GO 53156
// sold_defenders := Replace ( sold_defenders , sold_defenders + 1 , i ) ;
53841: LD_ADDR_VAR 0 18
53845: PUSH
53846: LD_VAR 0 18
53850: PPUSH
53851: LD_VAR 0 18
53855: PUSH
53856: LD_INT 1
53858: PLUS
53859: PPUSH
53860: LD_VAR 0 5
53864: PPUSH
53865: CALL_OW 1
53869: ST_TO_ADDR
// ComExitBuilding ( i ) ;
53870: LD_VAR 0 5
53874: PPUSH
53875: CALL_OW 122
// end ; if sold_defenders then
53879: LD_VAR 0 18
53883: IFFALSE 53943
// if i in sold_defenders then
53885: LD_VAR 0 5
53889: PUSH
53890: LD_VAR 0 18
53894: IN
53895: IFFALSE 53943
// begin if not HasTask ( i ) and GetDistUnits ( i , e ) < 30 then
53897: LD_VAR 0 5
53901: PPUSH
53902: CALL_OW 314
53906: NOT
53907: PUSH
53908: LD_VAR 0 5
53912: PPUSH
53913: LD_VAR 0 14
53917: PPUSH
53918: CALL_OW 296
53922: PUSH
53923: LD_INT 30
53925: LESS
53926: AND
53927: IFFALSE 53943
// ComAttackUnit ( i , e ) ;
53929: LD_VAR 0 5
53933: PPUSH
53934: LD_VAR 0 14
53938: PPUSH
53939: CALL_OW 115
// end ; end ; end ;
53943: GO 53946
53945: POP
// if IsDead ( i ) then
53946: LD_VAR 0 5
53950: PPUSH
53951: CALL_OW 301
53955: IFFALSE 53973
// defenders := defenders diff i ;
53957: LD_ADDR_VAR 0 2
53961: PUSH
53962: LD_VAR 0 2
53966: PUSH
53967: LD_VAR 0 5
53971: DIFF
53972: ST_TO_ADDR
// end ;
53973: GO 53156
53975: POP
53976: POP
// until not enemy or not defenders or not mc_bases [ base ] ;
53977: LD_VAR 0 3
53981: NOT
53982: PUSH
53983: LD_VAR 0 2
53987: NOT
53988: OR
53989: PUSH
53990: LD_EXP 76
53994: PUSH
53995: LD_VAR 0 1
53999: ARRAY
54000: NOT
54001: OR
54002: IFFALSE 53060
// MC_Reset ( base , 18 ) ;
54004: LD_VAR 0 1
54008: PPUSH
54009: LD_INT 18
54011: PPUSH
54012: CALL 24446 0 2
// defenders := defenders diff UnitFilter ( defenders , [ f_or , [ f_class , 1 ] , [ f_class , 5 ] , [ f_class , 8 ] , [ f_class , 9 ] ] ) ;
54016: LD_ADDR_VAR 0 2
54020: PUSH
54021: LD_VAR 0 2
54025: PUSH
54026: LD_VAR 0 2
54030: PPUSH
54031: LD_INT 2
54033: PUSH
54034: LD_INT 25
54036: PUSH
54037: LD_INT 1
54039: PUSH
54040: EMPTY
54041: LIST
54042: LIST
54043: PUSH
54044: LD_INT 25
54046: PUSH
54047: LD_INT 5
54049: PUSH
54050: EMPTY
54051: LIST
54052: LIST
54053: PUSH
54054: LD_INT 25
54056: PUSH
54057: LD_INT 8
54059: PUSH
54060: EMPTY
54061: LIST
54062: LIST
54063: PUSH
54064: LD_INT 25
54066: PUSH
54067: LD_INT 9
54069: PUSH
54070: EMPTY
54071: LIST
54072: LIST
54073: PUSH
54074: EMPTY
54075: LIST
54076: LIST
54077: LIST
54078: LIST
54079: LIST
54080: PPUSH
54081: CALL_OW 72
54085: DIFF
54086: ST_TO_ADDR
// if not enemy and UnitFilter ( defenders , [ f_type , unit_vehicle ] ) then
54087: LD_VAR 0 3
54091: NOT
54092: PUSH
54093: LD_VAR 0 2
54097: PPUSH
54098: LD_INT 21
54100: PUSH
54101: LD_INT 2
54103: PUSH
54104: EMPTY
54105: LIST
54106: LIST
54107: PPUSH
54108: CALL_OW 72
54112: AND
54113: IFFALSE 54451
// begin tmp := FilterByTag ( defenders , 19 ) ;
54115: LD_ADDR_VAR 0 12
54119: PUSH
54120: LD_VAR 0 2
54124: PPUSH
54125: LD_INT 19
54127: PPUSH
54128: CALL 90907 0 2
54132: ST_TO_ADDR
// if tmp then
54133: LD_VAR 0 12
54137: IFFALSE 54207
// begin tmp := UnitFilter ( tmp , [ f_class , 3 ] ) ;
54139: LD_ADDR_VAR 0 12
54143: PUSH
54144: LD_VAR 0 12
54148: PPUSH
54149: LD_INT 25
54151: PUSH
54152: LD_INT 3
54154: PUSH
54155: EMPTY
54156: LIST
54157: LIST
54158: PPUSH
54159: CALL_OW 72
54163: ST_TO_ADDR
// if tmp then
54164: LD_VAR 0 12
54168: IFFALSE 54207
// mc_repair_vehicle := Replace ( mc_repair_vehicle , base , mc_repair_vehicle [ base ] union tmp ) ;
54170: LD_ADDR_EXP 88
54174: PUSH
54175: LD_EXP 88
54179: PPUSH
54180: LD_VAR 0 1
54184: PPUSH
54185: LD_EXP 88
54189: PUSH
54190: LD_VAR 0 1
54194: ARRAY
54195: PUSH
54196: LD_VAR 0 12
54200: UNION
54201: PPUSH
54202: CALL_OW 1
54206: ST_TO_ADDR
// end ; MC_Reset ( base , 19 ) ;
54207: LD_VAR 0 1
54211: PPUSH
54212: LD_INT 19
54214: PPUSH
54215: CALL 24446 0 2
// repeat wait ( 0 0$1 ) ;
54219: LD_INT 35
54221: PPUSH
54222: CALL_OW 67
// if not mc_bases [ base ] or mc_bases [ base ] = [ ] then
54226: LD_EXP 76
54230: PUSH
54231: LD_VAR 0 1
54235: ARRAY
54236: NOT
54237: PUSH
54238: LD_EXP 76
54242: PUSH
54243: LD_VAR 0 1
54247: ARRAY
54248: PUSH
54249: EMPTY
54250: EQUAL
54251: OR
54252: IFFALSE 54289
// begin for i in defenders do
54254: LD_ADDR_VAR 0 5
54258: PUSH
54259: LD_VAR 0 2
54263: PUSH
54264: FOR_IN
54265: IFFALSE 54278
// ComStop ( i ) ;
54267: LD_VAR 0 5
54271: PPUSH
54272: CALL_OW 141
54276: GO 54264
54278: POP
54279: POP
// defenders := [ ] ;
54280: LD_ADDR_VAR 0 2
54284: PUSH
54285: EMPTY
54286: ST_TO_ADDR
// exit ;
54287: GO 54475
// end ; for i in defenders do
54289: LD_ADDR_VAR 0 5
54293: PUSH
54294: LD_VAR 0 2
54298: PUSH
54299: FOR_IN
54300: IFFALSE 54389
// begin if not IsInArea ( i , mc_parking [ base ] ) then
54302: LD_VAR 0 5
54306: PPUSH
54307: LD_EXP 100
54311: PUSH
54312: LD_VAR 0 1
54316: ARRAY
54317: PPUSH
54318: CALL_OW 308
54322: NOT
54323: IFFALSE 54347
// ComMoveToArea ( i , mc_parking [ base ] ) else
54325: LD_VAR 0 5
54329: PPUSH
54330: LD_EXP 100
54334: PUSH
54335: LD_VAR 0 1
54339: ARRAY
54340: PPUSH
54341: CALL_OW 113
54345: GO 54387
// if GetControl ( i ) = control_manual then
54347: LD_VAR 0 5
54351: PPUSH
54352: CALL_OW 263
54356: PUSH
54357: LD_INT 1
54359: EQUAL
54360: IFFALSE 54387
// if IsDrivenBy ( i ) then
54362: LD_VAR 0 5
54366: PPUSH
54367: CALL_OW 311
54371: IFFALSE 54387
// ComExitVehicle ( IsDrivenBy ( i ) ) ;
54373: LD_VAR 0 5
54377: PPUSH
54378: CALL_OW 311
54382: PPUSH
54383: CALL_OW 121
// end ;
54387: GO 54299
54389: POP
54390: POP
// until UnitFilter ( defenders , [ f_inarea , mc_parking [ base ] ] ) = defenders or mc_scan [ base ] or not mc_bases [ base ] ;
54391: LD_VAR 0 2
54395: PPUSH
54396: LD_INT 95
54398: PUSH
54399: LD_EXP 100
54403: PUSH
54404: LD_VAR 0 1
54408: ARRAY
54409: PUSH
54410: EMPTY
54411: LIST
54412: LIST
54413: PPUSH
54414: CALL_OW 72
54418: PUSH
54419: LD_VAR 0 2
54423: EQUAL
54424: PUSH
54425: LD_EXP 99
54429: PUSH
54430: LD_VAR 0 1
54434: ARRAY
54435: OR
54436: PUSH
54437: LD_EXP 76
54441: PUSH
54442: LD_VAR 0 1
54446: ARRAY
54447: NOT
54448: OR
54449: IFFALSE 54219
// end ; MC_Reset ( base , 19 ) ;
54451: LD_VAR 0 1
54455: PPUSH
54456: LD_INT 19
54458: PPUSH
54459: CALL 24446 0 2
// MC_Reset ( base , 20 ) ;
54463: LD_VAR 0 1
54467: PPUSH
54468: LD_INT 20
54470: PPUSH
54471: CALL 24446 0 2
// end ;
54475: LD_VAR 0 4
54479: RET
// export function AllowSpecClass ( unit ) ; var side , nat , tech ; begin
54480: LD_INT 0
54482: PPUSH
54483: PPUSH
54484: PPUSH
54485: PPUSH
// result := false ;
54486: LD_ADDR_VAR 0 2
54490: PUSH
54491: LD_INT 0
54493: ST_TO_ADDR
// side := GetSide ( unit ) ;
54494: LD_ADDR_VAR 0 3
54498: PUSH
54499: LD_VAR 0 1
54503: PPUSH
54504: CALL_OW 255
54508: ST_TO_ADDR
// nat := GetNation ( unit ) ;
54509: LD_ADDR_VAR 0 4
54513: PUSH
54514: LD_VAR 0 1
54518: PPUSH
54519: CALL_OW 248
54523: ST_TO_ADDR
// case nat of 1 :
54524: LD_VAR 0 4
54528: PUSH
54529: LD_INT 1
54531: DOUBLE
54532: EQUAL
54533: IFTRUE 54537
54535: GO 54548
54537: POP
// tech := tech_lassight ; 2 :
54538: LD_ADDR_VAR 0 5
54542: PUSH
54543: LD_INT 12
54545: ST_TO_ADDR
54546: GO 54587
54548: LD_INT 2
54550: DOUBLE
54551: EQUAL
54552: IFTRUE 54556
54554: GO 54567
54556: POP
// tech := tech_mortar ; 3 :
54557: LD_ADDR_VAR 0 5
54561: PUSH
54562: LD_INT 41
54564: ST_TO_ADDR
54565: GO 54587
54567: LD_INT 3
54569: DOUBLE
54570: EQUAL
54571: IFTRUE 54575
54573: GO 54586
54575: POP
// tech := tech_bazooka ; end ;
54576: LD_ADDR_VAR 0 5
54580: PUSH
54581: LD_INT 44
54583: ST_TO_ADDR
54584: GO 54587
54586: POP
// if Researched ( side , tech ) then
54587: LD_VAR 0 3
54591: PPUSH
54592: LD_VAR 0 5
54596: PPUSH
54597: CALL_OW 325
54601: IFFALSE 54628
// result := [ class_sniper , class_mortar , class_bazooker ] [ nat ] ;
54603: LD_ADDR_VAR 0 2
54607: PUSH
54608: LD_INT 5
54610: PUSH
54611: LD_INT 8
54613: PUSH
54614: LD_INT 9
54616: PUSH
54617: EMPTY
54618: LIST
54619: LIST
54620: LIST
54621: PUSH
54622: LD_VAR 0 4
54626: ARRAY
54627: ST_TO_ADDR
// end ;
54628: LD_VAR 0 2
54632: RET
// export function DetonateMines ( side , mines ) ; var i , tmp ; begin
54633: LD_INT 0
54635: PPUSH
54636: PPUSH
54637: PPUSH
// if not mines then
54638: LD_VAR 0 2
54642: NOT
54643: IFFALSE 54647
// exit ;
54645: GO 54791
// tmp := FilterAllUnits ( [ [ f_enemy , side ] , [ f_not , [ f_type , unit_building ] ] ] ) ;
54647: LD_ADDR_VAR 0 5
54651: PUSH
54652: LD_INT 81
54654: PUSH
54655: LD_VAR 0 1
54659: PUSH
54660: EMPTY
54661: LIST
54662: LIST
54663: PUSH
54664: LD_INT 3
54666: PUSH
54667: LD_INT 21
54669: PUSH
54670: LD_INT 3
54672: PUSH
54673: EMPTY
54674: LIST
54675: LIST
54676: PUSH
54677: EMPTY
54678: LIST
54679: LIST
54680: PUSH
54681: EMPTY
54682: LIST
54683: LIST
54684: PPUSH
54685: CALL_OW 69
54689: ST_TO_ADDR
// for i in mines do
54690: LD_ADDR_VAR 0 4
54694: PUSH
54695: LD_VAR 0 2
54699: PUSH
54700: FOR_IN
54701: IFFALSE 54789
// begin if not MineAtPos ( i [ 1 ] , i [ 2 ] ) then
54703: LD_VAR 0 4
54707: PUSH
54708: LD_INT 1
54710: ARRAY
54711: PPUSH
54712: LD_VAR 0 4
54716: PUSH
54717: LD_INT 2
54719: ARRAY
54720: PPUSH
54721: CALL_OW 458
54725: NOT
54726: IFFALSE 54730
// continue ;
54728: GO 54700
// if HexInfo ( i [ 1 ] , i [ 2 ] ) in tmp then
54730: LD_VAR 0 4
54734: PUSH
54735: LD_INT 1
54737: ARRAY
54738: PPUSH
54739: LD_VAR 0 4
54743: PUSH
54744: LD_INT 2
54746: ARRAY
54747: PPUSH
54748: CALL_OW 428
54752: PUSH
54753: LD_VAR 0 5
54757: IN
54758: IFFALSE 54787
// LaunchMineAtPos ( i [ 1 ] , i [ 2 ] , side ) ;
54760: LD_VAR 0 4
54764: PUSH
54765: LD_INT 1
54767: ARRAY
54768: PPUSH
54769: LD_VAR 0 4
54773: PUSH
54774: LD_INT 2
54776: ARRAY
54777: PPUSH
54778: LD_VAR 0 1
54782: PPUSH
54783: CALL_OW 456
// end ;
54787: GO 54700
54789: POP
54790: POP
// end ;
54791: LD_VAR 0 3
54795: RET
// export function Count ( array ) ; var i ; begin
54796: LD_INT 0
54798: PPUSH
54799: PPUSH
// result := 0 ;
54800: LD_ADDR_VAR 0 2
54804: PUSH
54805: LD_INT 0
54807: ST_TO_ADDR
// for i in array do
54808: LD_ADDR_VAR 0 3
54812: PUSH
54813: LD_VAR 0 1
54817: PUSH
54818: FOR_IN
54819: IFFALSE 54843
// if i then
54821: LD_VAR 0 3
54825: IFFALSE 54841
// result := result + 1 ;
54827: LD_ADDR_VAR 0 2
54831: PUSH
54832: LD_VAR 0 2
54836: PUSH
54837: LD_INT 1
54839: PLUS
54840: ST_TO_ADDR
54841: GO 54818
54843: POP
54844: POP
// end ;
54845: LD_VAR 0 2
54849: RET
// export function IsEmpty ( building ) ; begin
54850: LD_INT 0
54852: PPUSH
// if not building then
54853: LD_VAR 0 1
54857: NOT
54858: IFFALSE 54862
// exit ;
54860: GO 54905
// result := building in FilterAllUnits ( [ [ f_side , GetSide ( building ) ] , [ f_empty ] ] ) ;
54862: LD_ADDR_VAR 0 2
54866: PUSH
54867: LD_VAR 0 1
54871: PUSH
54872: LD_INT 22
54874: PUSH
54875: LD_VAR 0 1
54879: PPUSH
54880: CALL_OW 255
54884: PUSH
54885: EMPTY
54886: LIST
54887: LIST
54888: PUSH
54889: LD_INT 58
54891: PUSH
54892: EMPTY
54893: LIST
54894: PUSH
54895: EMPTY
54896: LIST
54897: LIST
54898: PPUSH
54899: CALL_OW 69
54903: IN
54904: ST_TO_ADDR
// end ;
54905: LD_VAR 0 2
54909: RET
// export function IsNotFull ( building ) ; begin
54910: LD_INT 0
54912: PPUSH
// if not building then
54913: LD_VAR 0 1
54917: NOT
54918: IFFALSE 54922
// exit ;
54920: GO 54941
// result := UnitsInside ( building ) < 6 ;
54922: LD_ADDR_VAR 0 2
54926: PUSH
54927: LD_VAR 0 1
54931: PPUSH
54932: CALL_OW 313
54936: PUSH
54937: LD_INT 6
54939: LESS
54940: ST_TO_ADDR
// end ;
54941: LD_VAR 0 2
54945: RET
// export function GetFacExt ( factory ) ; var tmp , i , list ; begin
54946: LD_INT 0
54948: PPUSH
54949: PPUSH
54950: PPUSH
54951: PPUSH
// tmp := [ ] ;
54952: LD_ADDR_VAR 0 3
54956: PUSH
54957: EMPTY
54958: ST_TO_ADDR
// list := [ ] ;
54959: LD_ADDR_VAR 0 5
54963: PUSH
54964: EMPTY
54965: ST_TO_ADDR
// for i = 16 to 25 do
54966: LD_ADDR_VAR 0 4
54970: PUSH
54971: DOUBLE
54972: LD_INT 16
54974: DEC
54975: ST_TO_ADDR
54976: LD_INT 25
54978: PUSH
54979: FOR_TO
54980: IFFALSE 55053
// tmp := tmp ^ FilterAllUnits ( [ [ [ f_side , GetSide ( factory ) ] , [ f_dist , factory , 6 ] , [ f_btype , i ] ] ] ) ;
54982: LD_ADDR_VAR 0 3
54986: PUSH
54987: LD_VAR 0 3
54991: PUSH
54992: LD_INT 22
54994: PUSH
54995: LD_VAR 0 1
54999: PPUSH
55000: CALL_OW 255
55004: PUSH
55005: EMPTY
55006: LIST
55007: LIST
55008: PUSH
55009: LD_INT 91
55011: PUSH
55012: LD_VAR 0 1
55016: PUSH
55017: LD_INT 6
55019: PUSH
55020: EMPTY
55021: LIST
55022: LIST
55023: LIST
55024: PUSH
55025: LD_INT 30
55027: PUSH
55028: LD_VAR 0 4
55032: PUSH
55033: EMPTY
55034: LIST
55035: LIST
55036: PUSH
55037: EMPTY
55038: LIST
55039: LIST
55040: LIST
55041: PUSH
55042: EMPTY
55043: LIST
55044: PPUSH
55045: CALL_OW 69
55049: ADD
55050: ST_TO_ADDR
55051: GO 54979
55053: POP
55054: POP
// for i = 1 to tmp do
55055: LD_ADDR_VAR 0 4
55059: PUSH
55060: DOUBLE
55061: LD_INT 1
55063: DEC
55064: ST_TO_ADDR
55065: LD_VAR 0 3
55069: PUSH
55070: FOR_TO
55071: IFFALSE 55159
// list := list ^ [ [ GetBType ( tmp [ i ] ) , GetX ( tmp [ i ] ) , GetY ( tmp [ i ] ) , GetDir ( tmp [ i ] ) ] ] ;
55073: LD_ADDR_VAR 0 5
55077: PUSH
55078: LD_VAR 0 5
55082: PUSH
55083: LD_VAR 0 3
55087: PUSH
55088: LD_VAR 0 4
55092: ARRAY
55093: PPUSH
55094: CALL_OW 266
55098: PUSH
55099: LD_VAR 0 3
55103: PUSH
55104: LD_VAR 0 4
55108: ARRAY
55109: PPUSH
55110: CALL_OW 250
55114: PUSH
55115: LD_VAR 0 3
55119: PUSH
55120: LD_VAR 0 4
55124: ARRAY
55125: PPUSH
55126: CALL_OW 251
55130: PUSH
55131: LD_VAR 0 3
55135: PUSH
55136: LD_VAR 0 4
55140: ARRAY
55141: PPUSH
55142: CALL_OW 254
55146: PUSH
55147: EMPTY
55148: LIST
55149: LIST
55150: LIST
55151: LIST
55152: PUSH
55153: EMPTY
55154: LIST
55155: ADD
55156: ST_TO_ADDR
55157: GO 55070
55159: POP
55160: POP
// result := list ;
55161: LD_ADDR_VAR 0 2
55165: PUSH
55166: LD_VAR 0 5
55170: ST_TO_ADDR
// end ;
55171: LD_VAR 0 2
55175: RET
// export function Produce ( factory , chassis , engine , control , weapon ) ; var i , tmp , _chassis , _weapon , _engine , _control ; begin
55176: LD_INT 0
55178: PPUSH
55179: PPUSH
55180: PPUSH
55181: PPUSH
55182: PPUSH
55183: PPUSH
55184: PPUSH
// if not factory then
55185: LD_VAR 0 1
55189: NOT
55190: IFFALSE 55194
// exit ;
55192: GO 55787
// if control = control_apeman then
55194: LD_VAR 0 4
55198: PUSH
55199: LD_INT 5
55201: EQUAL
55202: IFFALSE 55311
// begin tmp := UnitsInside ( factory ) ;
55204: LD_ADDR_VAR 0 8
55208: PUSH
55209: LD_VAR 0 1
55213: PPUSH
55214: CALL_OW 313
55218: ST_TO_ADDR
// if not UnitFilter ( tmp , [ f_class , class_apeman ] ) then
55219: LD_VAR 0 8
55223: PPUSH
55224: LD_INT 25
55226: PUSH
55227: LD_INT 12
55229: PUSH
55230: EMPTY
55231: LIST
55232: LIST
55233: PPUSH
55234: CALL_OW 72
55238: NOT
55239: IFFALSE 55249
// control := control_manual ;
55241: LD_ADDR_VAR 0 4
55245: PUSH
55246: LD_INT 1
55248: ST_TO_ADDR
// tmp := GetFacExt ( factory ) ;
55249: LD_ADDR_VAR 0 8
55253: PUSH
55254: LD_VAR 0 1
55258: PPUSH
55259: CALL 54946 0 1
55263: ST_TO_ADDR
// if tmp then
55264: LD_VAR 0 8
55268: IFFALSE 55311
// begin for i in tmp do
55270: LD_ADDR_VAR 0 7
55274: PUSH
55275: LD_VAR 0 8
55279: PUSH
55280: FOR_IN
55281: IFFALSE 55309
// if i [ 1 ] = b_ext_radio then
55283: LD_VAR 0 7
55287: PUSH
55288: LD_INT 1
55290: ARRAY
55291: PUSH
55292: LD_INT 22
55294: EQUAL
55295: IFFALSE 55307
// begin control := control_remote ;
55297: LD_ADDR_VAR 0 4
55301: PUSH
55302: LD_INT 2
55304: ST_TO_ADDR
// break ;
55305: GO 55309
// end ;
55307: GO 55280
55309: POP
55310: POP
// end ; end ; if CanBeConstructed ( factory , chassis , engine , control , weapon ) then
55311: LD_VAR 0 1
55315: PPUSH
55316: LD_VAR 0 2
55320: PPUSH
55321: LD_VAR 0 3
55325: PPUSH
55326: LD_VAR 0 4
55330: PPUSH
55331: LD_VAR 0 5
55335: PPUSH
55336: CALL_OW 448
55340: IFFALSE 55375
// begin result := [ chassis , engine , control , weapon ] ;
55342: LD_ADDR_VAR 0 6
55346: PUSH
55347: LD_VAR 0 2
55351: PUSH
55352: LD_VAR 0 3
55356: PUSH
55357: LD_VAR 0 4
55361: PUSH
55362: LD_VAR 0 5
55366: PUSH
55367: EMPTY
55368: LIST
55369: LIST
55370: LIST
55371: LIST
55372: ST_TO_ADDR
// exit ;
55373: GO 55787
// end ; _chassis := AvailableChassisList ( factory ) ;
55375: LD_ADDR_VAR 0 9
55379: PUSH
55380: LD_VAR 0 1
55384: PPUSH
55385: CALL_OW 475
55389: ST_TO_ADDR
// _engine := AvailableEngineList ( factory ) ;
55390: LD_ADDR_VAR 0 11
55394: PUSH
55395: LD_VAR 0 1
55399: PPUSH
55400: CALL_OW 476
55404: ST_TO_ADDR
// _control := AvailableControlList ( factory ) ;
55405: LD_ADDR_VAR 0 12
55409: PUSH
55410: LD_VAR 0 1
55414: PPUSH
55415: CALL_OW 477
55419: ST_TO_ADDR
// _weapon := AvailableWeaponList ( factory ) ;
55420: LD_ADDR_VAR 0 10
55424: PUSH
55425: LD_VAR 0 1
55429: PPUSH
55430: CALL_OW 478
55434: ST_TO_ADDR
// if not _chassis or not _engine or not _control or not _weapon then
55435: LD_VAR 0 9
55439: NOT
55440: PUSH
55441: LD_VAR 0 11
55445: NOT
55446: OR
55447: PUSH
55448: LD_VAR 0 12
55452: NOT
55453: OR
55454: PUSH
55455: LD_VAR 0 10
55459: NOT
55460: OR
55461: IFFALSE 55496
// begin result := [ chassis , engine , control , weapon ] ;
55463: LD_ADDR_VAR 0 6
55467: PUSH
55468: LD_VAR 0 2
55472: PUSH
55473: LD_VAR 0 3
55477: PUSH
55478: LD_VAR 0 4
55482: PUSH
55483: LD_VAR 0 5
55487: PUSH
55488: EMPTY
55489: LIST
55490: LIST
55491: LIST
55492: LIST
55493: ST_TO_ADDR
// exit ;
55494: GO 55787
// end ; if not chassis in _chassis then
55496: LD_VAR 0 2
55500: PUSH
55501: LD_VAR 0 9
55505: IN
55506: NOT
55507: IFFALSE 55533
// chassis := _chassis [ rand ( 1 , _chassis ) ] ;
55509: LD_ADDR_VAR 0 2
55513: PUSH
55514: LD_VAR 0 9
55518: PUSH
55519: LD_INT 1
55521: PPUSH
55522: LD_VAR 0 9
55526: PPUSH
55527: CALL_OW 12
55531: ARRAY
55532: ST_TO_ADDR
// if not EngineCanBeMount ( chassis , engine ) then
55533: LD_VAR 0 2
55537: PPUSH
55538: LD_VAR 0 3
55542: PPUSH
55543: CALL 55792 0 2
55547: NOT
55548: IFFALSE 55607
// repeat engine := _engine [ 1 ] ;
55550: LD_ADDR_VAR 0 3
55554: PUSH
55555: LD_VAR 0 11
55559: PUSH
55560: LD_INT 1
55562: ARRAY
55563: ST_TO_ADDR
// _engine := Delete ( _engine , 1 ) ;
55564: LD_ADDR_VAR 0 11
55568: PUSH
55569: LD_VAR 0 11
55573: PPUSH
55574: LD_INT 1
55576: PPUSH
55577: CALL_OW 3
55581: ST_TO_ADDR
// until EngineCanBeMount ( chassis , engine ) or _engine = [ ] ;
55582: LD_VAR 0 2
55586: PPUSH
55587: LD_VAR 0 3
55591: PPUSH
55592: CALL 55792 0 2
55596: PUSH
55597: LD_VAR 0 11
55601: PUSH
55602: EMPTY
55603: EQUAL
55604: OR
55605: IFFALSE 55550
// if not control in _control then
55607: LD_VAR 0 4
55611: PUSH
55612: LD_VAR 0 12
55616: IN
55617: NOT
55618: IFFALSE 55644
// control := _control [ rand ( 1 , _control ) ] ;
55620: LD_ADDR_VAR 0 4
55624: PUSH
55625: LD_VAR 0 12
55629: PUSH
55630: LD_INT 1
55632: PPUSH
55633: LD_VAR 0 12
55637: PPUSH
55638: CALL_OW 12
55642: ARRAY
55643: ST_TO_ADDR
// if not WeaponCanBeMount ( chassis , weapon ) then
55644: LD_VAR 0 2
55648: PPUSH
55649: LD_VAR 0 5
55653: PPUSH
55654: CALL 56012 0 2
55658: NOT
55659: IFFALSE 55718
// repeat weapon := _weapon [ 1 ] ;
55661: LD_ADDR_VAR 0 5
55665: PUSH
55666: LD_VAR 0 10
55670: PUSH
55671: LD_INT 1
55673: ARRAY
55674: ST_TO_ADDR
// _weapon := Delete ( _weapon , 1 ) ;
55675: LD_ADDR_VAR 0 10
55679: PUSH
55680: LD_VAR 0 10
55684: PPUSH
55685: LD_INT 1
55687: PPUSH
55688: CALL_OW 3
55692: ST_TO_ADDR
// until WeaponCanBeMount ( chassis , weapon ) or _weapon = [ ] ;
55693: LD_VAR 0 2
55697: PPUSH
55698: LD_VAR 0 5
55702: PPUSH
55703: CALL 56012 0 2
55707: PUSH
55708: LD_VAR 0 10
55712: PUSH
55713: EMPTY
55714: EQUAL
55715: OR
55716: IFFALSE 55661
// result := [ ] ;
55718: LD_ADDR_VAR 0 6
55722: PUSH
55723: EMPTY
55724: ST_TO_ADDR
// if CanBeConstructed ( factory , chassis , engine , control , weapon ) then
55725: LD_VAR 0 1
55729: PPUSH
55730: LD_VAR 0 2
55734: PPUSH
55735: LD_VAR 0 3
55739: PPUSH
55740: LD_VAR 0 4
55744: PPUSH
55745: LD_VAR 0 5
55749: PPUSH
55750: CALL_OW 448
55754: IFFALSE 55787
// result := [ chassis , engine , control , weapon ] ;
55756: LD_ADDR_VAR 0 6
55760: PUSH
55761: LD_VAR 0 2
55765: PUSH
55766: LD_VAR 0 3
55770: PUSH
55771: LD_VAR 0 4
55775: PUSH
55776: LD_VAR 0 5
55780: PUSH
55781: EMPTY
55782: LIST
55783: LIST
55784: LIST
55785: LIST
55786: ST_TO_ADDR
// end ;
55787: LD_VAR 0 6
55791: RET
// export function EngineCanBeMount ( chassis , engine ) ; begin
55792: LD_INT 0
55794: PPUSH
// if not chassis or not engine then
55795: LD_VAR 0 1
55799: NOT
55800: PUSH
55801: LD_VAR 0 2
55805: NOT
55806: OR
55807: IFFALSE 55811
// exit ;
55809: GO 56007
// case engine of engine_solar :
55811: LD_VAR 0 2
55815: PUSH
55816: LD_INT 2
55818: DOUBLE
55819: EQUAL
55820: IFTRUE 55824
55822: GO 55862
55824: POP
// result := [ ar_hovercraft , ar_light_trike , ar_medium_trike , ar_half_tracked , us_light_wheeled , us_medium_wheeled , us_medium_tracked ] ; engine_combustion :
55825: LD_ADDR_VAR 0 3
55829: PUSH
55830: LD_INT 11
55832: PUSH
55833: LD_INT 12
55835: PUSH
55836: LD_INT 13
55838: PUSH
55839: LD_INT 14
55841: PUSH
55842: LD_INT 1
55844: PUSH
55845: LD_INT 2
55847: PUSH
55848: LD_INT 3
55850: PUSH
55851: EMPTY
55852: LIST
55853: LIST
55854: LIST
55855: LIST
55856: LIST
55857: LIST
55858: LIST
55859: ST_TO_ADDR
55860: GO 55991
55862: LD_INT 1
55864: DOUBLE
55865: EQUAL
55866: IFTRUE 55870
55868: GO 55932
55870: POP
// result := [ ar_hovercraft , ar_light_trike , ar_medium_trike , ar_half_tracked , us_light_wheeled , us_medium_wheeled , us_medium_tracked , us_heavy_tracked , us_morphling , ru_medium_wheeled , ru_heavy_wheeled , ru_medium_tracked , ru_heavy_tracked ] ; engine_siberite :
55871: LD_ADDR_VAR 0 3
55875: PUSH
55876: LD_INT 11
55878: PUSH
55879: LD_INT 12
55881: PUSH
55882: LD_INT 13
55884: PUSH
55885: LD_INT 14
55887: PUSH
55888: LD_INT 1
55890: PUSH
55891: LD_INT 2
55893: PUSH
55894: LD_INT 3
55896: PUSH
55897: LD_INT 4
55899: PUSH
55900: LD_INT 5
55902: PUSH
55903: LD_INT 21
55905: PUSH
55906: LD_INT 23
55908: PUSH
55909: LD_INT 22
55911: PUSH
55912: LD_INT 24
55914: PUSH
55915: EMPTY
55916: LIST
55917: LIST
55918: LIST
55919: LIST
55920: LIST
55921: LIST
55922: LIST
55923: LIST
55924: LIST
55925: LIST
55926: LIST
55927: LIST
55928: LIST
55929: ST_TO_ADDR
55930: GO 55991
55932: LD_INT 3
55934: DOUBLE
55935: EQUAL
55936: IFTRUE 55940
55938: GO 55990
55940: POP
// result := [ ar_medium_trike , ar_half_tracked , us_medium_wheeled , us_medium_tracked , us_heavy_tracked , us_morphling , ru_medium_wheeled , ru_medium_tracked , ru_heavy_wheeled , ru_heavy_tracked ] ; end ;
55941: LD_ADDR_VAR 0 3
55945: PUSH
55946: LD_INT 13
55948: PUSH
55949: LD_INT 14
55951: PUSH
55952: LD_INT 2
55954: PUSH
55955: LD_INT 3
55957: PUSH
55958: LD_INT 4
55960: PUSH
55961: LD_INT 5
55963: PUSH
55964: LD_INT 21
55966: PUSH
55967: LD_INT 22
55969: PUSH
55970: LD_INT 23
55972: PUSH
55973: LD_INT 24
55975: PUSH
55976: EMPTY
55977: LIST
55978: LIST
55979: LIST
55980: LIST
55981: LIST
55982: LIST
55983: LIST
55984: LIST
55985: LIST
55986: LIST
55987: ST_TO_ADDR
55988: GO 55991
55990: POP
// result := ( chassis in result ) ;
55991: LD_ADDR_VAR 0 3
55995: PUSH
55996: LD_VAR 0 1
56000: PUSH
56001: LD_VAR 0 3
56005: IN
56006: ST_TO_ADDR
// end ;
56007: LD_VAR 0 3
56011: RET
// export function WeaponCanBeMount ( chassis , weapon ) ; begin
56012: LD_INT 0
56014: PPUSH
// if not chassis or not weapon then
56015: LD_VAR 0 1
56019: NOT
56020: PUSH
56021: LD_VAR 0 2
56025: NOT
56026: OR
56027: IFFALSE 56031
// exit ;
56029: GO 57057
// case weapon of us_machine_gun :
56031: LD_VAR 0 2
56035: PUSH
56036: LD_INT 2
56038: DOUBLE
56039: EQUAL
56040: IFTRUE 56044
56042: GO 56074
56044: POP
// result := [ us_light_wheeled , us_medium_wheeled , us_medium_tracked , us_heavy_tracked , us_morphling ] ; us_light_gun :
56045: LD_ADDR_VAR 0 3
56049: PUSH
56050: LD_INT 1
56052: PUSH
56053: LD_INT 2
56055: PUSH
56056: LD_INT 3
56058: PUSH
56059: LD_INT 4
56061: PUSH
56062: LD_INT 5
56064: PUSH
56065: EMPTY
56066: LIST
56067: LIST
56068: LIST
56069: LIST
56070: LIST
56071: ST_TO_ADDR
56072: GO 57041
56074: LD_INT 3
56076: DOUBLE
56077: EQUAL
56078: IFTRUE 56082
56080: GO 56112
56082: POP
// result := [ us_light_wheeled , us_medium_wheeled , us_medium_tracked , us_heavy_tracked , us_morphling ] ; us_radar :
56083: LD_ADDR_VAR 0 3
56087: PUSH
56088: LD_INT 1
56090: PUSH
56091: LD_INT 2
56093: PUSH
56094: LD_INT 3
56096: PUSH
56097: LD_INT 4
56099: PUSH
56100: LD_INT 5
56102: PUSH
56103: EMPTY
56104: LIST
56105: LIST
56106: LIST
56107: LIST
56108: LIST
56109: ST_TO_ADDR
56110: GO 57041
56112: LD_INT 11
56114: DOUBLE
56115: EQUAL
56116: IFTRUE 56120
56118: GO 56150
56120: POP
// result := [ us_light_wheeled , us_medium_wheeled , us_medium_tracked , us_heavy_tracked , us_morphling ] ; us_gatling_gun :
56121: LD_ADDR_VAR 0 3
56125: PUSH
56126: LD_INT 1
56128: PUSH
56129: LD_INT 2
56131: PUSH
56132: LD_INT 3
56134: PUSH
56135: LD_INT 4
56137: PUSH
56138: LD_INT 5
56140: PUSH
56141: EMPTY
56142: LIST
56143: LIST
56144: LIST
56145: LIST
56146: LIST
56147: ST_TO_ADDR
56148: GO 57041
56150: LD_INT 4
56152: DOUBLE
56153: EQUAL
56154: IFTRUE 56158
56156: GO 56184
56158: POP
// result := [ us_medium_wheeled , us_medium_tracked , us_heavy_tracked , us_morphling ] ; us_double_gun :
56159: LD_ADDR_VAR 0 3
56163: PUSH
56164: LD_INT 2
56166: PUSH
56167: LD_INT 3
56169: PUSH
56170: LD_INT 4
56172: PUSH
56173: LD_INT 5
56175: PUSH
56176: EMPTY
56177: LIST
56178: LIST
56179: LIST
56180: LIST
56181: ST_TO_ADDR
56182: GO 57041
56184: LD_INT 5
56186: DOUBLE
56187: EQUAL
56188: IFTRUE 56192
56190: GO 56218
56192: POP
// result := [ us_medium_wheeled , us_medium_tracked , us_heavy_tracked , us_morphling ] ; us_laser :
56193: LD_ADDR_VAR 0 3
56197: PUSH
56198: LD_INT 2
56200: PUSH
56201: LD_INT 3
56203: PUSH
56204: LD_INT 4
56206: PUSH
56207: LD_INT 5
56209: PUSH
56210: EMPTY
56211: LIST
56212: LIST
56213: LIST
56214: LIST
56215: ST_TO_ADDR
56216: GO 57041
56218: LD_INT 9
56220: DOUBLE
56221: EQUAL
56222: IFTRUE 56226
56224: GO 56252
56226: POP
// result := [ us_medium_wheeled , us_medium_tracked , us_heavy_tracked , us_morphling ] ; us_rocket_launcher :
56227: LD_ADDR_VAR 0 3
56231: PUSH
56232: LD_INT 2
56234: PUSH
56235: LD_INT 3
56237: PUSH
56238: LD_INT 4
56240: PUSH
56241: LD_INT 5
56243: PUSH
56244: EMPTY
56245: LIST
56246: LIST
56247: LIST
56248: LIST
56249: ST_TO_ADDR
56250: GO 57041
56252: LD_INT 7
56254: DOUBLE
56255: EQUAL
56256: IFTRUE 56260
56258: GO 56286
56260: POP
// result := [ us_medium_wheeled , us_medium_tracked , us_heavy_tracked , us_morphling ] ; us_cargo_bay :
56261: LD_ADDR_VAR 0 3
56265: PUSH
56266: LD_INT 2
56268: PUSH
56269: LD_INT 3
56271: PUSH
56272: LD_INT 4
56274: PUSH
56275: LD_INT 5
56277: PUSH
56278: EMPTY
56279: LIST
56280: LIST
56281: LIST
56282: LIST
56283: ST_TO_ADDR
56284: GO 57041
56286: LD_INT 12
56288: DOUBLE
56289: EQUAL
56290: IFTRUE 56294
56292: GO 56320
56294: POP
// result := [ us_medium_wheeled , us_medium_tracked , us_heavy_tracked , us_morphling ] ; us_crane :
56295: LD_ADDR_VAR 0 3
56299: PUSH
56300: LD_INT 2
56302: PUSH
56303: LD_INT 3
56305: PUSH
56306: LD_INT 4
56308: PUSH
56309: LD_INT 5
56311: PUSH
56312: EMPTY
56313: LIST
56314: LIST
56315: LIST
56316: LIST
56317: ST_TO_ADDR
56318: GO 57041
56320: LD_INT 13
56322: DOUBLE
56323: EQUAL
56324: IFTRUE 56328
56326: GO 56354
56328: POP
// result := [ us_medium_wheeled , us_medium_tracked , us_heavy_tracked , us_morphling ] ; us_bulldozer :
56329: LD_ADDR_VAR 0 3
56333: PUSH
56334: LD_INT 2
56336: PUSH
56337: LD_INT 3
56339: PUSH
56340: LD_INT 4
56342: PUSH
56343: LD_INT 5
56345: PUSH
56346: EMPTY
56347: LIST
56348: LIST
56349: LIST
56350: LIST
56351: ST_TO_ADDR
56352: GO 57041
56354: LD_INT 14
56356: DOUBLE
56357: EQUAL
56358: IFTRUE 56362
56360: GO 56380
56362: POP
// result := [ us_heavy_tracked , us_morphling ] ; us_heavy_gun :
56363: LD_ADDR_VAR 0 3
56367: PUSH
56368: LD_INT 4
56370: PUSH
56371: LD_INT 5
56373: PUSH
56374: EMPTY
56375: LIST
56376: LIST
56377: ST_TO_ADDR
56378: GO 57041
56380: LD_INT 6
56382: DOUBLE
56383: EQUAL
56384: IFTRUE 56388
56386: GO 56406
56388: POP
// result := [ us_heavy_tracked , us_morphling ] ; us_double_laser :
56389: LD_ADDR_VAR 0 3
56393: PUSH
56394: LD_INT 4
56396: PUSH
56397: LD_INT 5
56399: PUSH
56400: EMPTY
56401: LIST
56402: LIST
56403: ST_TO_ADDR
56404: GO 57041
56406: LD_INT 10
56408: DOUBLE
56409: EQUAL
56410: IFTRUE 56414
56412: GO 56432
56414: POP
// result := [ us_heavy_tracked , us_morphling ] ; ar_multimissile_ballista :
56415: LD_ADDR_VAR 0 3
56419: PUSH
56420: LD_INT 4
56422: PUSH
56423: LD_INT 5
56425: PUSH
56426: EMPTY
56427: LIST
56428: LIST
56429: ST_TO_ADDR
56430: GO 57041
56432: LD_INT 22
56434: DOUBLE
56435: EQUAL
56436: IFTRUE 56440
56438: GO 56466
56440: POP
// result := [ ar_hovercraft , ar_light_trike , ar_medium_trike , ar_half_tracked ] ; ar_light_gun :
56441: LD_ADDR_VAR 0 3
56445: PUSH
56446: LD_INT 11
56448: PUSH
56449: LD_INT 12
56451: PUSH
56452: LD_INT 13
56454: PUSH
56455: LD_INT 14
56457: PUSH
56458: EMPTY
56459: LIST
56460: LIST
56461: LIST
56462: LIST
56463: ST_TO_ADDR
56464: GO 57041
56466: LD_INT 23
56468: DOUBLE
56469: EQUAL
56470: IFTRUE 56474
56472: GO 56500
56474: POP
// result := [ ar_hovercraft , ar_light_trike , ar_medium_trike , ar_half_tracked ] ; ar_double_machine_gun :
56475: LD_ADDR_VAR 0 3
56479: PUSH
56480: LD_INT 11
56482: PUSH
56483: LD_INT 12
56485: PUSH
56486: LD_INT 13
56488: PUSH
56489: LD_INT 14
56491: PUSH
56492: EMPTY
56493: LIST
56494: LIST
56495: LIST
56496: LIST
56497: ST_TO_ADDR
56498: GO 57041
56500: LD_INT 24
56502: DOUBLE
56503: EQUAL
56504: IFTRUE 56508
56506: GO 56534
56508: POP
// result := [ ar_hovercraft , ar_light_trike , ar_medium_trike , ar_half_tracked ] ; ar_radar :
56509: LD_ADDR_VAR 0 3
56513: PUSH
56514: LD_INT 11
56516: PUSH
56517: LD_INT 12
56519: PUSH
56520: LD_INT 13
56522: PUSH
56523: LD_INT 14
56525: PUSH
56526: EMPTY
56527: LIST
56528: LIST
56529: LIST
56530: LIST
56531: ST_TO_ADDR
56532: GO 57041
56534: LD_INT 30
56536: DOUBLE
56537: EQUAL
56538: IFTRUE 56542
56540: GO 56568
56542: POP
// result := [ ar_hovercraft , ar_light_trike , ar_medium_trike , ar_half_tracked ] ; ar_gatling_gun :
56543: LD_ADDR_VAR 0 3
56547: PUSH
56548: LD_INT 11
56550: PUSH
56551: LD_INT 12
56553: PUSH
56554: LD_INT 13
56556: PUSH
56557: LD_INT 14
56559: PUSH
56560: EMPTY
56561: LIST
56562: LIST
56563: LIST
56564: LIST
56565: ST_TO_ADDR
56566: GO 57041
56568: LD_INT 25
56570: DOUBLE
56571: EQUAL
56572: IFTRUE 56576
56574: GO 56594
56576: POP
// result := [ ar_medium_trike , ar_half_tracked ] ; ar_gun :
56577: LD_ADDR_VAR 0 3
56581: PUSH
56582: LD_INT 13
56584: PUSH
56585: LD_INT 14
56587: PUSH
56588: EMPTY
56589: LIST
56590: LIST
56591: ST_TO_ADDR
56592: GO 57041
56594: LD_INT 27
56596: DOUBLE
56597: EQUAL
56598: IFTRUE 56602
56600: GO 56620
56602: POP
// result := [ ar_medium_trike , ar_half_tracked ] ; ar_rocket_launcher :
56603: LD_ADDR_VAR 0 3
56607: PUSH
56608: LD_INT 13
56610: PUSH
56611: LD_INT 14
56613: PUSH
56614: EMPTY
56615: LIST
56616: LIST
56617: ST_TO_ADDR
56618: GO 57041
56620: LD_INT 28
56622: DOUBLE
56623: EQUAL
56624: IFTRUE 56628
56626: GO 56646
56628: POP
// result := [ ar_medium_trike , ar_half_tracked ] ; ar_selfpropelled_bomb :
56629: LD_ADDR_VAR 0 3
56633: PUSH
56634: LD_INT 13
56636: PUSH
56637: LD_INT 14
56639: PUSH
56640: EMPTY
56641: LIST
56642: LIST
56643: ST_TO_ADDR
56644: GO 57041
56646: LD_INT 29
56648: DOUBLE
56649: EQUAL
56650: IFTRUE 56654
56652: GO 56672
56654: POP
// result := [ ar_medium_trike , ar_half_tracked ] ; ar_control_tower :
56655: LD_ADDR_VAR 0 3
56659: PUSH
56660: LD_INT 13
56662: PUSH
56663: LD_INT 14
56665: PUSH
56666: EMPTY
56667: LIST
56668: LIST
56669: ST_TO_ADDR
56670: GO 57041
56672: LD_INT 31
56674: DOUBLE
56675: EQUAL
56676: IFTRUE 56680
56678: GO 56698
56680: POP
// result := [ ar_medium_trike , ar_half_tracked ] ; ar_flame_thrower :
56681: LD_ADDR_VAR 0 3
56685: PUSH
56686: LD_INT 13
56688: PUSH
56689: LD_INT 14
56691: PUSH
56692: EMPTY
56693: LIST
56694: LIST
56695: ST_TO_ADDR
56696: GO 57041
56698: LD_INT 26
56700: DOUBLE
56701: EQUAL
56702: IFTRUE 56706
56704: GO 56724
56706: POP
// result := [ ar_medium_trike , ar_half_tracked ] ; ru_heavy_machine_gun :
56707: LD_ADDR_VAR 0 3
56711: PUSH
56712: LD_INT 13
56714: PUSH
56715: LD_INT 14
56717: PUSH
56718: EMPTY
56719: LIST
56720: LIST
56721: ST_TO_ADDR
56722: GO 57041
56724: LD_INT 42
56726: DOUBLE
56727: EQUAL
56728: IFTRUE 56732
56730: GO 56758
56732: POP
// result := [ ru_medium_wheeled , ru_medium_tracked , ru_heavy_wheeled , ru_heavy_tracked ] ; ru_gatling_gun :
56733: LD_ADDR_VAR 0 3
56737: PUSH
56738: LD_INT 21
56740: PUSH
56741: LD_INT 22
56743: PUSH
56744: LD_INT 23
56746: PUSH
56747: LD_INT 24
56749: PUSH
56750: EMPTY
56751: LIST
56752: LIST
56753: LIST
56754: LIST
56755: ST_TO_ADDR
56756: GO 57041
56758: LD_INT 43
56760: DOUBLE
56761: EQUAL
56762: IFTRUE 56766
56764: GO 56792
56766: POP
// result := [ ru_medium_wheeled , ru_medium_tracked , ru_heavy_wheeled , ru_heavy_tracked ] ; ru_gun :
56767: LD_ADDR_VAR 0 3
56771: PUSH
56772: LD_INT 21
56774: PUSH
56775: LD_INT 22
56777: PUSH
56778: LD_INT 23
56780: PUSH
56781: LD_INT 24
56783: PUSH
56784: EMPTY
56785: LIST
56786: LIST
56787: LIST
56788: LIST
56789: ST_TO_ADDR
56790: GO 57041
56792: LD_INT 44
56794: DOUBLE
56795: EQUAL
56796: IFTRUE 56800
56798: GO 56826
56800: POP
// result := [ ru_medium_wheeled , ru_medium_tracked , ru_heavy_wheeled , ru_heavy_tracked ] ; ru_rocket_launcher :
56801: LD_ADDR_VAR 0 3
56805: PUSH
56806: LD_INT 21
56808: PUSH
56809: LD_INT 22
56811: PUSH
56812: LD_INT 23
56814: PUSH
56815: LD_INT 24
56817: PUSH
56818: EMPTY
56819: LIST
56820: LIST
56821: LIST
56822: LIST
56823: ST_TO_ADDR
56824: GO 57041
56826: LD_INT 45
56828: DOUBLE
56829: EQUAL
56830: IFTRUE 56834
56832: GO 56860
56834: POP
// result := [ ru_medium_wheeled , ru_medium_tracked , ru_heavy_wheeled , ru_heavy_tracked ] ; ru_time_lapser :
56835: LD_ADDR_VAR 0 3
56839: PUSH
56840: LD_INT 21
56842: PUSH
56843: LD_INT 22
56845: PUSH
56846: LD_INT 23
56848: PUSH
56849: LD_INT 24
56851: PUSH
56852: EMPTY
56853: LIST
56854: LIST
56855: LIST
56856: LIST
56857: ST_TO_ADDR
56858: GO 57041
56860: LD_INT 49
56862: DOUBLE
56863: EQUAL
56864: IFTRUE 56868
56866: GO 56894
56868: POP
// result := [ ru_medium_wheeled , ru_medium_tracked , ru_heavy_wheeled , ru_heavy_tracked ] ; ru_cargo_bay :
56869: LD_ADDR_VAR 0 3
56873: PUSH
56874: LD_INT 21
56876: PUSH
56877: LD_INT 22
56879: PUSH
56880: LD_INT 23
56882: PUSH
56883: LD_INT 24
56885: PUSH
56886: EMPTY
56887: LIST
56888: LIST
56889: LIST
56890: LIST
56891: ST_TO_ADDR
56892: GO 57041
56894: LD_INT 51
56896: DOUBLE
56897: EQUAL
56898: IFTRUE 56902
56900: GO 56928
56902: POP
// result := [ ru_medium_wheeled , ru_medium_tracked , ru_heavy_wheeled , ru_heavy_tracked ] ; ru_crane :
56903: LD_ADDR_VAR 0 3
56907: PUSH
56908: LD_INT 21
56910: PUSH
56911: LD_INT 22
56913: PUSH
56914: LD_INT 23
56916: PUSH
56917: LD_INT 24
56919: PUSH
56920: EMPTY
56921: LIST
56922: LIST
56923: LIST
56924: LIST
56925: ST_TO_ADDR
56926: GO 57041
56928: LD_INT 52
56930: DOUBLE
56931: EQUAL
56932: IFTRUE 56936
56934: GO 56962
56936: POP
// result := [ ru_medium_wheeled , ru_medium_tracked , ru_heavy_wheeled , ru_heavy_tracked ] ; ru_bulldozer :
56937: LD_ADDR_VAR 0 3
56941: PUSH
56942: LD_INT 21
56944: PUSH
56945: LD_INT 22
56947: PUSH
56948: LD_INT 23
56950: PUSH
56951: LD_INT 24
56953: PUSH
56954: EMPTY
56955: LIST
56956: LIST
56957: LIST
56958: LIST
56959: ST_TO_ADDR
56960: GO 57041
56962: LD_INT 53
56964: DOUBLE
56965: EQUAL
56966: IFTRUE 56970
56968: GO 56988
56970: POP
// result := [ ru_heavy_wheeled , ru_heavy_tracked ] ; ru_heavy_gun :
56971: LD_ADDR_VAR 0 3
56975: PUSH
56976: LD_INT 23
56978: PUSH
56979: LD_INT 24
56981: PUSH
56982: EMPTY
56983: LIST
56984: LIST
56985: ST_TO_ADDR
56986: GO 57041
56988: LD_INT 46
56990: DOUBLE
56991: EQUAL
56992: IFTRUE 56996
56994: GO 57014
56996: POP
// result := [ ru_heavy_wheeled , ru_heavy_tracked ] ; ru_rocket :
56997: LD_ADDR_VAR 0 3
57001: PUSH
57002: LD_INT 23
57004: PUSH
57005: LD_INT 24
57007: PUSH
57008: EMPTY
57009: LIST
57010: LIST
57011: ST_TO_ADDR
57012: GO 57041
57014: LD_INT 47
57016: DOUBLE
57017: EQUAL
57018: IFTRUE 57022
57020: GO 57040
57022: POP
// result := [ ru_heavy_wheeled , ru_heavy_tracked ] ; end ;
57023: LD_ADDR_VAR 0 3
57027: PUSH
57028: LD_INT 23
57030: PUSH
57031: LD_INT 24
57033: PUSH
57034: EMPTY
57035: LIST
57036: LIST
57037: ST_TO_ADDR
57038: GO 57041
57040: POP
// result := ( chassis in result ) ;
57041: LD_ADDR_VAR 0 3
57045: PUSH
57046: LD_VAR 0 1
57050: PUSH
57051: LD_VAR 0 3
57055: IN
57056: ST_TO_ADDR
// end ;
57057: LD_VAR 0 3
57061: RET
// export function Reindex ( array , i_from , i_to , direction ) ; var i , j , k , d , tmp , length ; begin
57062: LD_INT 0
57064: PPUSH
57065: PPUSH
57066: PPUSH
57067: PPUSH
57068: PPUSH
57069: PPUSH
57070: PPUSH
// result := array ;
57071: LD_ADDR_VAR 0 5
57075: PUSH
57076: LD_VAR 0 1
57080: ST_TO_ADDR
// if not array or not i_from or not i_to or i_from > array or i_to > array then
57081: LD_VAR 0 1
57085: NOT
57086: PUSH
57087: LD_VAR 0 2
57091: NOT
57092: OR
57093: PUSH
57094: LD_VAR 0 3
57098: NOT
57099: OR
57100: PUSH
57101: LD_VAR 0 2
57105: PUSH
57106: LD_VAR 0 1
57110: GREATER
57111: OR
57112: PUSH
57113: LD_VAR 0 3
57117: PUSH
57118: LD_VAR 0 1
57122: GREATER
57123: OR
57124: IFFALSE 57128
// exit ;
57126: GO 57424
// if direction then
57128: LD_VAR 0 4
57132: IFFALSE 57196
// begin d := 1 ;
57134: LD_ADDR_VAR 0 9
57138: PUSH
57139: LD_INT 1
57141: ST_TO_ADDR
// if i_from > i_to then
57142: LD_VAR 0 2
57146: PUSH
57147: LD_VAR 0 3
57151: GREATER
57152: IFFALSE 57178
// length := ( array - i_from ) + i_to else
57154: LD_ADDR_VAR 0 11
57158: PUSH
57159: LD_VAR 0 1
57163: PUSH
57164: LD_VAR 0 2
57168: MINUS
57169: PUSH
57170: LD_VAR 0 3
57174: PLUS
57175: ST_TO_ADDR
57176: GO 57194
// length := i_to - i_from ;
57178: LD_ADDR_VAR 0 11
57182: PUSH
57183: LD_VAR 0 3
57187: PUSH
57188: LD_VAR 0 2
57192: MINUS
57193: ST_TO_ADDR
// end else
57194: GO 57257
// begin d := - 1 ;
57196: LD_ADDR_VAR 0 9
57200: PUSH
57201: LD_INT 1
57203: NEG
57204: ST_TO_ADDR
// if i_from > i_to then
57205: LD_VAR 0 2
57209: PUSH
57210: LD_VAR 0 3
57214: GREATER
57215: IFFALSE 57235
// length := i_from - i_to else
57217: LD_ADDR_VAR 0 11
57221: PUSH
57222: LD_VAR 0 2
57226: PUSH
57227: LD_VAR 0 3
57231: MINUS
57232: ST_TO_ADDR
57233: GO 57257
// length := ( array - i_to ) + i_from ;
57235: LD_ADDR_VAR 0 11
57239: PUSH
57240: LD_VAR 0 1
57244: PUSH
57245: LD_VAR 0 3
57249: MINUS
57250: PUSH
57251: LD_VAR 0 2
57255: PLUS
57256: ST_TO_ADDR
// end ; if not length then
57257: LD_VAR 0 11
57261: NOT
57262: IFFALSE 57266
// exit ;
57264: GO 57424
// tmp := array ;
57266: LD_ADDR_VAR 0 10
57270: PUSH
57271: LD_VAR 0 1
57275: ST_TO_ADDR
// for i = 1 to length do
57276: LD_ADDR_VAR 0 6
57280: PUSH
57281: DOUBLE
57282: LD_INT 1
57284: DEC
57285: ST_TO_ADDR
57286: LD_VAR 0 11
57290: PUSH
57291: FOR_TO
57292: IFFALSE 57412
// begin for j = 1 to array do
57294: LD_ADDR_VAR 0 7
57298: PUSH
57299: DOUBLE
57300: LD_INT 1
57302: DEC
57303: ST_TO_ADDR
57304: LD_VAR 0 1
57308: PUSH
57309: FOR_TO
57310: IFFALSE 57398
// begin k := j + d ;
57312: LD_ADDR_VAR 0 8
57316: PUSH
57317: LD_VAR 0 7
57321: PUSH
57322: LD_VAR 0 9
57326: PLUS
57327: ST_TO_ADDR
// if k > array then
57328: LD_VAR 0 8
57332: PUSH
57333: LD_VAR 0 1
57337: GREATER
57338: IFFALSE 57348
// k := 1 ;
57340: LD_ADDR_VAR 0 8
57344: PUSH
57345: LD_INT 1
57347: ST_TO_ADDR
// if not k then
57348: LD_VAR 0 8
57352: NOT
57353: IFFALSE 57365
// k := array ;
57355: LD_ADDR_VAR 0 8
57359: PUSH
57360: LD_VAR 0 1
57364: ST_TO_ADDR
// tmp := Replace ( tmp , k , array [ j ] ) ;
57365: LD_ADDR_VAR 0 10
57369: PUSH
57370: LD_VAR 0 10
57374: PPUSH
57375: LD_VAR 0 8
57379: PPUSH
57380: LD_VAR 0 1
57384: PUSH
57385: LD_VAR 0 7
57389: ARRAY
57390: PPUSH
57391: CALL_OW 1
57395: ST_TO_ADDR
// end ;
57396: GO 57309
57398: POP
57399: POP
// array := tmp ;
57400: LD_ADDR_VAR 0 1
57404: PUSH
57405: LD_VAR 0 10
57409: ST_TO_ADDR
// end ;
57410: GO 57291
57412: POP
57413: POP
// result := array ;
57414: LD_ADDR_VAR 0 5
57418: PUSH
57419: LD_VAR 0 1
57423: ST_TO_ADDR
// end ;
57424: LD_VAR 0 5
57428: RET
// export function GetElementIndex ( array , value ) ; var i ; begin
57429: LD_INT 0
57431: PPUSH
57432: PPUSH
// result := 0 ;
57433: LD_ADDR_VAR 0 3
57437: PUSH
57438: LD_INT 0
57440: ST_TO_ADDR
// if not array or not value in array then
57441: LD_VAR 0 1
57445: NOT
57446: PUSH
57447: LD_VAR 0 2
57451: PUSH
57452: LD_VAR 0 1
57456: IN
57457: NOT
57458: OR
57459: IFFALSE 57463
// exit ;
57461: GO 57517
// for i = 1 to array do
57463: LD_ADDR_VAR 0 4
57467: PUSH
57468: DOUBLE
57469: LD_INT 1
57471: DEC
57472: ST_TO_ADDR
57473: LD_VAR 0 1
57477: PUSH
57478: FOR_TO
57479: IFFALSE 57515
// if value = array [ i ] then
57481: LD_VAR 0 2
57485: PUSH
57486: LD_VAR 0 1
57490: PUSH
57491: LD_VAR 0 4
57495: ARRAY
57496: EQUAL
57497: IFFALSE 57513
// begin result := i ;
57499: LD_ADDR_VAR 0 3
57503: PUSH
57504: LD_VAR 0 4
57508: ST_TO_ADDR
// exit ;
57509: POP
57510: POP
57511: GO 57517
// end ;
57513: GO 57478
57515: POP
57516: POP
// end ;
57517: LD_VAR 0 3
57521: RET
// export function PrepareVehicle ( chassis , engine , control , weapon , fuel ) ; begin
57522: LD_INT 0
57524: PPUSH
// vc_chassis := chassis ;
57525: LD_ADDR_OWVAR 37
57529: PUSH
57530: LD_VAR 0 1
57534: ST_TO_ADDR
// vc_engine := engine ;
57535: LD_ADDR_OWVAR 39
57539: PUSH
57540: LD_VAR 0 2
57544: ST_TO_ADDR
// vc_control := control ;
57545: LD_ADDR_OWVAR 38
57549: PUSH
57550: LD_VAR 0 3
57554: ST_TO_ADDR
// vc_weapon := weapon ;
57555: LD_ADDR_OWVAR 40
57559: PUSH
57560: LD_VAR 0 4
57564: ST_TO_ADDR
// vc_fuel_battery := fuel ;
57565: LD_ADDR_OWVAR 41
57569: PUSH
57570: LD_VAR 0 5
57574: ST_TO_ADDR
// end ;
57575: LD_VAR 0 6
57579: RET
// export function WantPlant ( unit ) ; var task ; begin
57580: LD_INT 0
57582: PPUSH
57583: PPUSH
// result := false ;
57584: LD_ADDR_VAR 0 2
57588: PUSH
57589: LD_INT 0
57591: ST_TO_ADDR
// task := GetTaskList ( unit ) ;
57592: LD_ADDR_VAR 0 3
57596: PUSH
57597: LD_VAR 0 1
57601: PPUSH
57602: CALL_OW 437
57606: ST_TO_ADDR
// if task then
57607: LD_VAR 0 3
57611: IFFALSE 57639
// if task [ 1 ] [ 1 ] = p then
57613: LD_VAR 0 3
57617: PUSH
57618: LD_INT 1
57620: ARRAY
57621: PUSH
57622: LD_INT 1
57624: ARRAY
57625: PUSH
57626: LD_STRING p
57628: EQUAL
57629: IFFALSE 57639
// result := true ;
57631: LD_ADDR_VAR 0 2
57635: PUSH
57636: LD_INT 1
57638: ST_TO_ADDR
// end ;
57639: LD_VAR 0 2
57643: RET
// export function ReplaceIn ( arr , pos , value ) ; var i , tmp , s_arr ; begin
57644: LD_INT 0
57646: PPUSH
57647: PPUSH
57648: PPUSH
57649: PPUSH
// if pos < 1 then
57650: LD_VAR 0 2
57654: PUSH
57655: LD_INT 1
57657: LESS
57658: IFFALSE 57662
// exit ;
57660: GO 57965
// if pos = 1 then
57662: LD_VAR 0 2
57666: PUSH
57667: LD_INT 1
57669: EQUAL
57670: IFFALSE 57703
// result := Replace ( arr , pos [ 1 ] , value ) else
57672: LD_ADDR_VAR 0 4
57676: PUSH
57677: LD_VAR 0 1
57681: PPUSH
57682: LD_VAR 0 2
57686: PUSH
57687: LD_INT 1
57689: ARRAY
57690: PPUSH
57691: LD_VAR 0 3
57695: PPUSH
57696: CALL_OW 1
57700: ST_TO_ADDR
57701: GO 57965
// begin tmp := arr ;
57703: LD_ADDR_VAR 0 6
57707: PUSH
57708: LD_VAR 0 1
57712: ST_TO_ADDR
// s_arr := [ tmp ] ;
57713: LD_ADDR_VAR 0 7
57717: PUSH
57718: LD_VAR 0 6
57722: PUSH
57723: EMPTY
57724: LIST
57725: ST_TO_ADDR
// for i = 1 to pos - 1 do
57726: LD_ADDR_VAR 0 5
57730: PUSH
57731: DOUBLE
57732: LD_INT 1
57734: DEC
57735: ST_TO_ADDR
57736: LD_VAR 0 2
57740: PUSH
57741: LD_INT 1
57743: MINUS
57744: PUSH
57745: FOR_TO
57746: IFFALSE 57791
// begin tmp := tmp [ pos [ i ] ] ;
57748: LD_ADDR_VAR 0 6
57752: PUSH
57753: LD_VAR 0 6
57757: PUSH
57758: LD_VAR 0 2
57762: PUSH
57763: LD_VAR 0 5
57767: ARRAY
57768: ARRAY
57769: ST_TO_ADDR
// s_arr := s_arr ^ [ tmp ] ;
57770: LD_ADDR_VAR 0 7
57774: PUSH
57775: LD_VAR 0 7
57779: PUSH
57780: LD_VAR 0 6
57784: PUSH
57785: EMPTY
57786: LIST
57787: ADD
57788: ST_TO_ADDR
// end ;
57789: GO 57745
57791: POP
57792: POP
// tmp := Replace ( tmp , pos [ pos ] , value ) ;
57793: LD_ADDR_VAR 0 6
57797: PUSH
57798: LD_VAR 0 6
57802: PPUSH
57803: LD_VAR 0 2
57807: PUSH
57808: LD_VAR 0 2
57812: ARRAY
57813: PPUSH
57814: LD_VAR 0 3
57818: PPUSH
57819: CALL_OW 1
57823: ST_TO_ADDR
// s_arr := Replace ( s_arr , s_arr , tmp ) ;
57824: LD_ADDR_VAR 0 7
57828: PUSH
57829: LD_VAR 0 7
57833: PPUSH
57834: LD_VAR 0 7
57838: PPUSH
57839: LD_VAR 0 6
57843: PPUSH
57844: CALL_OW 1
57848: ST_TO_ADDR
// for i = s_arr downto 2 do
57849: LD_ADDR_VAR 0 5
57853: PUSH
57854: DOUBLE
57855: LD_VAR 0 7
57859: INC
57860: ST_TO_ADDR
57861: LD_INT 2
57863: PUSH
57864: FOR_DOWNTO
57865: IFFALSE 57949
// begin tmp := Replace ( s_arr [ i - 1 ] , pos [ i - 1 ] , s_arr [ i ] ) ;
57867: LD_ADDR_VAR 0 6
57871: PUSH
57872: LD_VAR 0 7
57876: PUSH
57877: LD_VAR 0 5
57881: PUSH
57882: LD_INT 1
57884: MINUS
57885: ARRAY
57886: PPUSH
57887: LD_VAR 0 2
57891: PUSH
57892: LD_VAR 0 5
57896: PUSH
57897: LD_INT 1
57899: MINUS
57900: ARRAY
57901: PPUSH
57902: LD_VAR 0 7
57906: PUSH
57907: LD_VAR 0 5
57911: ARRAY
57912: PPUSH
57913: CALL_OW 1
57917: ST_TO_ADDR
// s_arr := Replace ( s_arr , i - 1 , tmp ) ;
57918: LD_ADDR_VAR 0 7
57922: PUSH
57923: LD_VAR 0 7
57927: PPUSH
57928: LD_VAR 0 5
57932: PUSH
57933: LD_INT 1
57935: MINUS
57936: PPUSH
57937: LD_VAR 0 6
57941: PPUSH
57942: CALL_OW 1
57946: ST_TO_ADDR
// end ;
57947: GO 57864
57949: POP
57950: POP
// result := s_arr [ 1 ] ;
57951: LD_ADDR_VAR 0 4
57955: PUSH
57956: LD_VAR 0 7
57960: PUSH
57961: LD_INT 1
57963: ARRAY
57964: ST_TO_ADDR
// end ; end ;
57965: LD_VAR 0 4
57969: RET
// export function ReplaceWith ( list , pos1 , pos2 ) ; var i ; begin
57970: LD_INT 0
57972: PPUSH
57973: PPUSH
// if not list then
57974: LD_VAR 0 1
57978: NOT
57979: IFFALSE 57983
// exit ;
57981: GO 58074
// i := list [ pos1 ] ;
57983: LD_ADDR_VAR 0 5
57987: PUSH
57988: LD_VAR 0 1
57992: PUSH
57993: LD_VAR 0 2
57997: ARRAY
57998: ST_TO_ADDR
// if not i then
57999: LD_VAR 0 5
58003: NOT
58004: IFFALSE 58008
// exit ;
58006: GO 58074
// list := Replace ( list , pos1 , list [ pos2 ] ) ;
58008: LD_ADDR_VAR 0 1
58012: PUSH
58013: LD_VAR 0 1
58017: PPUSH
58018: LD_VAR 0 2
58022: PPUSH
58023: LD_VAR 0 1
58027: PUSH
58028: LD_VAR 0 3
58032: ARRAY
58033: PPUSH
58034: CALL_OW 1
58038: ST_TO_ADDR
// list := Replace ( list , pos2 , i ) ;
58039: LD_ADDR_VAR 0 1
58043: PUSH
58044: LD_VAR 0 1
58048: PPUSH
58049: LD_VAR 0 3
58053: PPUSH
58054: LD_VAR 0 5
58058: PPUSH
58059: CALL_OW 1
58063: ST_TO_ADDR
// result := list ;
58064: LD_ADDR_VAR 0 4
58068: PUSH
58069: LD_VAR 0 1
58073: ST_TO_ADDR
// end ;
58074: LD_VAR 0 4
58078: RET
// export function SortByDistanceUnit ( unit , list , asc , mode ) ; begin
58079: LD_INT 0
58081: PPUSH
// result := SortByDistanceXY ( GetX ( unit ) , GetY ( unit ) , list , asc , mode ) ;
58082: LD_ADDR_VAR 0 5
58086: PUSH
58087: LD_VAR 0 1
58091: PPUSH
58092: CALL_OW 250
58096: PPUSH
58097: LD_VAR 0 1
58101: PPUSH
58102: CALL_OW 251
58106: PPUSH
58107: LD_VAR 0 2
58111: PPUSH
58112: LD_VAR 0 3
58116: PPUSH
58117: LD_VAR 0 4
58121: PPUSH
58122: CALL 58132 0 5
58126: ST_TO_ADDR
// end ;
58127: LD_VAR 0 5
58131: RET
// export function SortByDistanceXY ( x , y , list , asc , mode ) ; var i , j , tmp ; begin
58132: LD_INT 0
58134: PPUSH
58135: PPUSH
58136: PPUSH
58137: PPUSH
// if not list then
58138: LD_VAR 0 3
58142: NOT
58143: IFFALSE 58147
// exit ;
58145: GO 58535
// result := [ ] ;
58147: LD_ADDR_VAR 0 6
58151: PUSH
58152: EMPTY
58153: ST_TO_ADDR
// for i in list do
58154: LD_ADDR_VAR 0 7
58158: PUSH
58159: LD_VAR 0 3
58163: PUSH
58164: FOR_IN
58165: IFFALSE 58367
// begin tmp := GetDistUnitXY ( i , x , y ) ;
58167: LD_ADDR_VAR 0 9
58171: PUSH
58172: LD_VAR 0 7
58176: PPUSH
58177: LD_VAR 0 1
58181: PPUSH
58182: LD_VAR 0 2
58186: PPUSH
58187: CALL_OW 297
58191: ST_TO_ADDR
// if not result then
58192: LD_VAR 0 6
58196: NOT
58197: IFFALSE 58223
// result := [ [ i , tmp ] ] else
58199: LD_ADDR_VAR 0 6
58203: PUSH
58204: LD_VAR 0 7
58208: PUSH
58209: LD_VAR 0 9
58213: PUSH
58214: EMPTY
58215: LIST
58216: LIST
58217: PUSH
58218: EMPTY
58219: LIST
58220: ST_TO_ADDR
58221: GO 58365
// begin if result [ result ] [ 2 ] < tmp then
58223: LD_VAR 0 6
58227: PUSH
58228: LD_VAR 0 6
58232: ARRAY
58233: PUSH
58234: LD_INT 2
58236: ARRAY
58237: PUSH
58238: LD_VAR 0 9
58242: LESS
58243: IFFALSE 58285
// result := Insert ( result , result + 1 , [ i , tmp ] ) else
58245: LD_ADDR_VAR 0 6
58249: PUSH
58250: LD_VAR 0 6
58254: PPUSH
58255: LD_VAR 0 6
58259: PUSH
58260: LD_INT 1
58262: PLUS
58263: PPUSH
58264: LD_VAR 0 7
58268: PUSH
58269: LD_VAR 0 9
58273: PUSH
58274: EMPTY
58275: LIST
58276: LIST
58277: PPUSH
58278: CALL_OW 2
58282: ST_TO_ADDR
58283: GO 58365
// for j = 1 to result do
58285: LD_ADDR_VAR 0 8
58289: PUSH
58290: DOUBLE
58291: LD_INT 1
58293: DEC
58294: ST_TO_ADDR
58295: LD_VAR 0 6
58299: PUSH
58300: FOR_TO
58301: IFFALSE 58363
// begin if tmp < result [ j ] [ 2 ] then
58303: LD_VAR 0 9
58307: PUSH
58308: LD_VAR 0 6
58312: PUSH
58313: LD_VAR 0 8
58317: ARRAY
58318: PUSH
58319: LD_INT 2
58321: ARRAY
58322: LESS
58323: IFFALSE 58361
// begin result := Insert ( result , j , [ i , tmp ] ) ;
58325: LD_ADDR_VAR 0 6
58329: PUSH
58330: LD_VAR 0 6
58334: PPUSH
58335: LD_VAR 0 8
58339: PPUSH
58340: LD_VAR 0 7
58344: PUSH
58345: LD_VAR 0 9
58349: PUSH
58350: EMPTY
58351: LIST
58352: LIST
58353: PPUSH
58354: CALL_OW 2
58358: ST_TO_ADDR
// break ;
58359: GO 58363
// end ; end ;
58361: GO 58300
58363: POP
58364: POP
// end ; end ;
58365: GO 58164
58367: POP
58368: POP
// if result and not asc then
58369: LD_VAR 0 6
58373: PUSH
58374: LD_VAR 0 4
58378: NOT
58379: AND
58380: IFFALSE 58455
// begin tmp := result ;
58382: LD_ADDR_VAR 0 9
58386: PUSH
58387: LD_VAR 0 6
58391: ST_TO_ADDR
// for i = tmp downto 1 do
58392: LD_ADDR_VAR 0 7
58396: PUSH
58397: DOUBLE
58398: LD_VAR 0 9
58402: INC
58403: ST_TO_ADDR
58404: LD_INT 1
58406: PUSH
58407: FOR_DOWNTO
58408: IFFALSE 58453
// result := Replace ( result , tmp - i + 1 , tmp [ i ] ) ;
58410: LD_ADDR_VAR 0 6
58414: PUSH
58415: LD_VAR 0 6
58419: PPUSH
58420: LD_VAR 0 9
58424: PUSH
58425: LD_VAR 0 7
58429: MINUS
58430: PUSH
58431: LD_INT 1
58433: PLUS
58434: PPUSH
58435: LD_VAR 0 9
58439: PUSH
58440: LD_VAR 0 7
58444: ARRAY
58445: PPUSH
58446: CALL_OW 1
58450: ST_TO_ADDR
58451: GO 58407
58453: POP
58454: POP
// end ; tmp := [ ] ;
58455: LD_ADDR_VAR 0 9
58459: PUSH
58460: EMPTY
58461: ST_TO_ADDR
// if mode then
58462: LD_VAR 0 5
58466: IFFALSE 58535
// begin for i = 1 to result do
58468: LD_ADDR_VAR 0 7
58472: PUSH
58473: DOUBLE
58474: LD_INT 1
58476: DEC
58477: ST_TO_ADDR
58478: LD_VAR 0 6
58482: PUSH
58483: FOR_TO
58484: IFFALSE 58523
// tmp := Replace ( tmp , i , result [ i ] [ 1 ] ) ;
58486: LD_ADDR_VAR 0 9
58490: PUSH
58491: LD_VAR 0 9
58495: PPUSH
58496: LD_VAR 0 7
58500: PPUSH
58501: LD_VAR 0 6
58505: PUSH
58506: LD_VAR 0 7
58510: ARRAY
58511: PUSH
58512: LD_INT 1
58514: ARRAY
58515: PPUSH
58516: CALL_OW 1
58520: ST_TO_ADDR
58521: GO 58483
58523: POP
58524: POP
// result := tmp ;
58525: LD_ADDR_VAR 0 6
58529: PUSH
58530: LD_VAR 0 9
58534: ST_TO_ADDR
// end ; end ;
58535: LD_VAR 0 6
58539: RET
// export function DangerAtRangeXY ( side , x , y , range ) ; var i , j , tmp , points , bpoints ; begin
58540: LD_INT 0
58542: PPUSH
58543: PPUSH
58544: PPUSH
58545: PPUSH
58546: PPUSH
58547: PPUSH
// result := [ 0 , 0 , 0 , [ ] ] ;
58548: LD_ADDR_VAR 0 5
58552: PUSH
58553: LD_INT 0
58555: PUSH
58556: LD_INT 0
58558: PUSH
58559: LD_INT 0
58561: PUSH
58562: EMPTY
58563: PUSH
58564: EMPTY
58565: LIST
58566: LIST
58567: LIST
58568: LIST
58569: ST_TO_ADDR
// if not x or not y then
58570: LD_VAR 0 2
58574: NOT
58575: PUSH
58576: LD_VAR 0 3
58580: NOT
58581: OR
58582: IFFALSE 58586
// exit ;
58584: GO 60232
// if not range then
58586: LD_VAR 0 4
58590: NOT
58591: IFFALSE 58601
// range := 10 ;
58593: LD_ADDR_VAR 0 4
58597: PUSH
58598: LD_INT 10
58600: ST_TO_ADDR
// tmp := FilterAllUnits ( [ [ f_enemy , side ] , [ f_distxy , x , y , range ] , [ f_not , [ f_type , unit_building ] ] ] ) ;
58601: LD_ADDR_VAR 0 8
58605: PUSH
58606: LD_INT 81
58608: PUSH
58609: LD_VAR 0 1
58613: PUSH
58614: EMPTY
58615: LIST
58616: LIST
58617: PUSH
58618: LD_INT 92
58620: PUSH
58621: LD_VAR 0 2
58625: PUSH
58626: LD_VAR 0 3
58630: PUSH
58631: LD_VAR 0 4
58635: PUSH
58636: EMPTY
58637: LIST
58638: LIST
58639: LIST
58640: LIST
58641: PUSH
58642: LD_INT 3
58644: PUSH
58645: LD_INT 21
58647: PUSH
58648: LD_INT 3
58650: PUSH
58651: EMPTY
58652: LIST
58653: LIST
58654: PUSH
58655: EMPTY
58656: LIST
58657: LIST
58658: PUSH
58659: EMPTY
58660: LIST
58661: LIST
58662: LIST
58663: PPUSH
58664: CALL_OW 69
58668: ST_TO_ADDR
// if not tmp then
58669: LD_VAR 0 8
58673: NOT
58674: IFFALSE 58678
// exit ;
58676: GO 60232
// for i in tmp do
58678: LD_ADDR_VAR 0 6
58682: PUSH
58683: LD_VAR 0 8
58687: PUSH
58688: FOR_IN
58689: IFFALSE 60207
// begin points := [ 0 , 0 , 0 ] ;
58691: LD_ADDR_VAR 0 9
58695: PUSH
58696: LD_INT 0
58698: PUSH
58699: LD_INT 0
58701: PUSH
58702: LD_INT 0
58704: PUSH
58705: EMPTY
58706: LIST
58707: LIST
58708: LIST
58709: ST_TO_ADDR
// bpoints := 1 ;
58710: LD_ADDR_VAR 0 10
58714: PUSH
58715: LD_INT 1
58717: ST_TO_ADDR
// case GetType ( i ) of unit_human :
58718: LD_VAR 0 6
58722: PPUSH
58723: CALL_OW 247
58727: PUSH
58728: LD_INT 1
58730: DOUBLE
58731: EQUAL
58732: IFTRUE 58736
58734: GO 59314
58736: POP
// begin if GetClass ( i ) = 1 then
58737: LD_VAR 0 6
58741: PPUSH
58742: CALL_OW 257
58746: PUSH
58747: LD_INT 1
58749: EQUAL
58750: IFFALSE 58771
// points := [ 10 , 5 , 3 ] ;
58752: LD_ADDR_VAR 0 9
58756: PUSH
58757: LD_INT 10
58759: PUSH
58760: LD_INT 5
58762: PUSH
58763: LD_INT 3
58765: PUSH
58766: EMPTY
58767: LIST
58768: LIST
58769: LIST
58770: ST_TO_ADDR
// if GetClass ( i ) in [ 2 , 3 , 4 ] then
58771: LD_VAR 0 6
58775: PPUSH
58776: CALL_OW 257
58780: PUSH
58781: LD_INT 2
58783: PUSH
58784: LD_INT 3
58786: PUSH
58787: LD_INT 4
58789: PUSH
58790: EMPTY
58791: LIST
58792: LIST
58793: LIST
58794: IN
58795: IFFALSE 58816
// points := [ 3 , 2 , 1 ] ;
58797: LD_ADDR_VAR 0 9
58801: PUSH
58802: LD_INT 3
58804: PUSH
58805: LD_INT 2
58807: PUSH
58808: LD_INT 1
58810: PUSH
58811: EMPTY
58812: LIST
58813: LIST
58814: LIST
58815: ST_TO_ADDR
// if GetClass ( i ) = 5 then
58816: LD_VAR 0 6
58820: PPUSH
58821: CALL_OW 257
58825: PUSH
58826: LD_INT 5
58828: EQUAL
58829: IFFALSE 58850
// points := [ 130 , 5 , 2 ] ;
58831: LD_ADDR_VAR 0 9
58835: PUSH
58836: LD_INT 130
58838: PUSH
58839: LD_INT 5
58841: PUSH
58842: LD_INT 2
58844: PUSH
58845: EMPTY
58846: LIST
58847: LIST
58848: LIST
58849: ST_TO_ADDR
// if GetClass ( i ) = 8 then
58850: LD_VAR 0 6
58854: PPUSH
58855: CALL_OW 257
58859: PUSH
58860: LD_INT 8
58862: EQUAL
58863: IFFALSE 58884
// points := [ 35 , 35 , 30 ] ;
58865: LD_ADDR_VAR 0 9
58869: PUSH
58870: LD_INT 35
58872: PUSH
58873: LD_INT 35
58875: PUSH
58876: LD_INT 30
58878: PUSH
58879: EMPTY
58880: LIST
58881: LIST
58882: LIST
58883: ST_TO_ADDR
// if GetClass ( i ) = 9 then
58884: LD_VAR 0 6
58888: PPUSH
58889: CALL_OW 257
58893: PUSH
58894: LD_INT 9
58896: EQUAL
58897: IFFALSE 58918
// points := [ 20 , 55 , 40 ] ;
58899: LD_ADDR_VAR 0 9
58903: PUSH
58904: LD_INT 20
58906: PUSH
58907: LD_INT 55
58909: PUSH
58910: LD_INT 40
58912: PUSH
58913: EMPTY
58914: LIST
58915: LIST
58916: LIST
58917: ST_TO_ADDR
// if GetClass ( i ) in [ 12 , 16 ] then
58918: LD_VAR 0 6
58922: PPUSH
58923: CALL_OW 257
58927: PUSH
58928: LD_INT 12
58930: PUSH
58931: LD_INT 16
58933: PUSH
58934: EMPTY
58935: LIST
58936: LIST
58937: IN
58938: IFFALSE 58959
// points := [ 5 , 3 , 2 ] ;
58940: LD_ADDR_VAR 0 9
58944: PUSH
58945: LD_INT 5
58947: PUSH
58948: LD_INT 3
58950: PUSH
58951: LD_INT 2
58953: PUSH
58954: EMPTY
58955: LIST
58956: LIST
58957: LIST
58958: ST_TO_ADDR
// if GetClass ( i ) = 17 then
58959: LD_VAR 0 6
58963: PPUSH
58964: CALL_OW 257
58968: PUSH
58969: LD_INT 17
58971: EQUAL
58972: IFFALSE 58993
// points := [ 100 , 50 , 75 ] ;
58974: LD_ADDR_VAR 0 9
58978: PUSH
58979: LD_INT 100
58981: PUSH
58982: LD_INT 50
58984: PUSH
58985: LD_INT 75
58987: PUSH
58988: EMPTY
58989: LIST
58990: LIST
58991: LIST
58992: ST_TO_ADDR
// if GetClass ( i ) = 15 then
58993: LD_VAR 0 6
58997: PPUSH
58998: CALL_OW 257
59002: PUSH
59003: LD_INT 15
59005: EQUAL
59006: IFFALSE 59027
// points := [ 10 , 5 , 3 ] ;
59008: LD_ADDR_VAR 0 9
59012: PUSH
59013: LD_INT 10
59015: PUSH
59016: LD_INT 5
59018: PUSH
59019: LD_INT 3
59021: PUSH
59022: EMPTY
59023: LIST
59024: LIST
59025: LIST
59026: ST_TO_ADDR
// if GetClass ( i ) = 14 then
59027: LD_VAR 0 6
59031: PPUSH
59032: CALL_OW 257
59036: PUSH
59037: LD_INT 14
59039: EQUAL
59040: IFFALSE 59061
// points := [ 10 , 0 , 0 ] ;
59042: LD_ADDR_VAR 0 9
59046: PUSH
59047: LD_INT 10
59049: PUSH
59050: LD_INT 0
59052: PUSH
59053: LD_INT 0
59055: PUSH
59056: EMPTY
59057: LIST
59058: LIST
59059: LIST
59060: ST_TO_ADDR
// if GetClass ( i ) = 11 then
59061: LD_VAR 0 6
59065: PPUSH
59066: CALL_OW 257
59070: PUSH
59071: LD_INT 11
59073: EQUAL
59074: IFFALSE 59095
// points := [ 30 , 10 , 5 ] ;
59076: LD_ADDR_VAR 0 9
59080: PUSH
59081: LD_INT 30
59083: PUSH
59084: LD_INT 10
59086: PUSH
59087: LD_INT 5
59089: PUSH
59090: EMPTY
59091: LIST
59092: LIST
59093: LIST
59094: ST_TO_ADDR
// if GetTech ( side , tech_stimdrugs ) = state_researched then
59095: LD_VAR 0 1
59099: PPUSH
59100: LD_INT 5
59102: PPUSH
59103: CALL_OW 321
59107: PUSH
59108: LD_INT 2
59110: EQUAL
59111: IFFALSE 59128
// bpoints := bpoints * 1.8 ;
59113: LD_ADDR_VAR 0 10
59117: PUSH
59118: LD_VAR 0 10
59122: PUSH
59123: LD_REAL  1.80000000000000E+0000
59126: MUL
59127: ST_TO_ADDR
// if GetClass ( i ) in [ 1 , 2 , 3 , 4 ] and GetTech ( side , tech_weap1 ) = state_researched then
59128: LD_VAR 0 6
59132: PPUSH
59133: CALL_OW 257
59137: PUSH
59138: LD_INT 1
59140: PUSH
59141: LD_INT 2
59143: PUSH
59144: LD_INT 3
59146: PUSH
59147: LD_INT 4
59149: PUSH
59150: EMPTY
59151: LIST
59152: LIST
59153: LIST
59154: LIST
59155: IN
59156: PUSH
59157: LD_VAR 0 1
59161: PPUSH
59162: LD_INT 51
59164: PPUSH
59165: CALL_OW 321
59169: PUSH
59170: LD_INT 2
59172: EQUAL
59173: AND
59174: IFFALSE 59191
// bpoints := bpoints * 1.2 ;
59176: LD_ADDR_VAR 0 10
59180: PUSH
59181: LD_VAR 0 10
59185: PUSH
59186: LD_REAL  1.20000000000000E+0000
59189: MUL
59190: ST_TO_ADDR
// if GetClass ( i ) in [ 5 , 7 , 9 ] and GetTech ( side , tech_weap2 ) = state_researched then
59191: LD_VAR 0 6
59195: PPUSH
59196: CALL_OW 257
59200: PUSH
59201: LD_INT 5
59203: PUSH
59204: LD_INT 7
59206: PUSH
59207: LD_INT 9
59209: PUSH
59210: EMPTY
59211: LIST
59212: LIST
59213: LIST
59214: IN
59215: PUSH
59216: LD_VAR 0 1
59220: PPUSH
59221: LD_INT 52
59223: PPUSH
59224: CALL_OW 321
59228: PUSH
59229: LD_INT 2
59231: EQUAL
59232: AND
59233: IFFALSE 59250
// bpoints := bpoints * 1.5 ;
59235: LD_ADDR_VAR 0 10
59239: PUSH
59240: LD_VAR 0 10
59244: PUSH
59245: LD_REAL  1.50000000000000E+0000
59248: MUL
59249: ST_TO_ADDR
// if GetTech ( side , tech_bio1 ) = state_researched then
59250: LD_VAR 0 1
59254: PPUSH
59255: LD_INT 66
59257: PPUSH
59258: CALL_OW 321
59262: PUSH
59263: LD_INT 2
59265: EQUAL
59266: IFFALSE 59283
// bpoints := bpoints * 1.1 ;
59268: LD_ADDR_VAR 0 10
59272: PUSH
59273: LD_VAR 0 10
59277: PUSH
59278: LD_REAL  1.10000000000000E+0000
59281: MUL
59282: ST_TO_ADDR
// bpoints := bpoints * ( GetSkill ( i , 1 ) * 1.15 ) ;
59283: LD_ADDR_VAR 0 10
59287: PUSH
59288: LD_VAR 0 10
59292: PUSH
59293: LD_VAR 0 6
59297: PPUSH
59298: LD_INT 1
59300: PPUSH
59301: CALL_OW 259
59305: PUSH
59306: LD_REAL  1.15000000000000E+0000
59309: MUL
59310: MUL
59311: ST_TO_ADDR
// end ; unit_vehicle :
59312: GO 60136
59314: LD_INT 2
59316: DOUBLE
59317: EQUAL
59318: IFTRUE 59322
59320: GO 60124
59322: POP
// begin if GetWeapon ( i ) in [ us_machine_gun , ru_heavy_machine_gun , ar_double_machine_gun ] then
59323: LD_VAR 0 6
59327: PPUSH
59328: CALL_OW 264
59332: PUSH
59333: LD_INT 2
59335: PUSH
59336: LD_INT 42
59338: PUSH
59339: LD_INT 24
59341: PUSH
59342: EMPTY
59343: LIST
59344: LIST
59345: LIST
59346: IN
59347: IFFALSE 59368
// points := [ 25 , 5 , 3 ] ;
59349: LD_ADDR_VAR 0 9
59353: PUSH
59354: LD_INT 25
59356: PUSH
59357: LD_INT 5
59359: PUSH
59360: LD_INT 3
59362: PUSH
59363: EMPTY
59364: LIST
59365: LIST
59366: LIST
59367: ST_TO_ADDR
// if GetWeapon ( i ) in [ us_gatling_gun , ru_gatling_gun , ar_gatling_gun ] then
59368: LD_VAR 0 6
59372: PPUSH
59373: CALL_OW 264
59377: PUSH
59378: LD_INT 4
59380: PUSH
59381: LD_INT 43
59383: PUSH
59384: LD_INT 25
59386: PUSH
59387: EMPTY
59388: LIST
59389: LIST
59390: LIST
59391: IN
59392: IFFALSE 59413
// points := [ 40 , 15 , 5 ] ;
59394: LD_ADDR_VAR 0 9
59398: PUSH
59399: LD_INT 40
59401: PUSH
59402: LD_INT 15
59404: PUSH
59405: LD_INT 5
59407: PUSH
59408: EMPTY
59409: LIST
59410: LIST
59411: LIST
59412: ST_TO_ADDR
// if GetWeapon ( i ) in [ us_light_gun , ar_light_gun ] then
59413: LD_VAR 0 6
59417: PPUSH
59418: CALL_OW 264
59422: PUSH
59423: LD_INT 3
59425: PUSH
59426: LD_INT 23
59428: PUSH
59429: EMPTY
59430: LIST
59431: LIST
59432: IN
59433: IFFALSE 59454
// points := [ 7 , 25 , 8 ] ;
59435: LD_ADDR_VAR 0 9
59439: PUSH
59440: LD_INT 7
59442: PUSH
59443: LD_INT 25
59445: PUSH
59446: LD_INT 8
59448: PUSH
59449: EMPTY
59450: LIST
59451: LIST
59452: LIST
59453: ST_TO_ADDR
// if GetWeapon ( i ) in [ us_double_gun , ar_gun , ru_gun ] then
59454: LD_VAR 0 6
59458: PPUSH
59459: CALL_OW 264
59463: PUSH
59464: LD_INT 5
59466: PUSH
59467: LD_INT 27
59469: PUSH
59470: LD_INT 44
59472: PUSH
59473: EMPTY
59474: LIST
59475: LIST
59476: LIST
59477: IN
59478: IFFALSE 59499
// points := [ 14 , 50 , 16 ] ;
59480: LD_ADDR_VAR 0 9
59484: PUSH
59485: LD_INT 14
59487: PUSH
59488: LD_INT 50
59490: PUSH
59491: LD_INT 16
59493: PUSH
59494: EMPTY
59495: LIST
59496: LIST
59497: LIST
59498: ST_TO_ADDR
// if GetWeapon ( i ) in [ us_heavy_gun , ru_heavy_gun ] then
59499: LD_VAR 0 6
59503: PPUSH
59504: CALL_OW 264
59508: PUSH
59509: LD_INT 6
59511: PUSH
59512: LD_INT 46
59514: PUSH
59515: EMPTY
59516: LIST
59517: LIST
59518: IN
59519: IFFALSE 59540
// points := [ 32 , 120 , 70 ] ;
59521: LD_ADDR_VAR 0 9
59525: PUSH
59526: LD_INT 32
59528: PUSH
59529: LD_INT 120
59531: PUSH
59532: LD_INT 70
59534: PUSH
59535: EMPTY
59536: LIST
59537: LIST
59538: LIST
59539: ST_TO_ADDR
// if GetWeapon ( i ) in [ us_rocket_launcher , ar_rocket_launcher , ru_rocket_launcher ] then
59540: LD_VAR 0 6
59544: PPUSH
59545: CALL_OW 264
59549: PUSH
59550: LD_INT 7
59552: PUSH
59553: LD_INT 28
59555: PUSH
59556: LD_INT 45
59558: PUSH
59559: EMPTY
59560: LIST
59561: LIST
59562: LIST
59563: IN
59564: IFFALSE 59585
// points := [ 35 , 20 , 45 ] ;
59566: LD_ADDR_VAR 0 9
59570: PUSH
59571: LD_INT 35
59573: PUSH
59574: LD_INT 20
59576: PUSH
59577: LD_INT 45
59579: PUSH
59580: EMPTY
59581: LIST
59582: LIST
59583: LIST
59584: ST_TO_ADDR
// if GetWeapon ( i ) in [ ru_rocket ] then
59585: LD_VAR 0 6
59589: PPUSH
59590: CALL_OW 264
59594: PUSH
59595: LD_INT 47
59597: PUSH
59598: EMPTY
59599: LIST
59600: IN
59601: IFFALSE 59622
// points := [ 67 , 45 , 75 ] ;
59603: LD_ADDR_VAR 0 9
59607: PUSH
59608: LD_INT 67
59610: PUSH
59611: LD_INT 45
59613: PUSH
59614: LD_INT 75
59616: PUSH
59617: EMPTY
59618: LIST
59619: LIST
59620: LIST
59621: ST_TO_ADDR
// if GetWeapon ( i ) in [ ar_flame_thrower ] then
59622: LD_VAR 0 6
59626: PPUSH
59627: CALL_OW 264
59631: PUSH
59632: LD_INT 26
59634: PUSH
59635: EMPTY
59636: LIST
59637: IN
59638: IFFALSE 59659
// points := [ 120 , 30 , 80 ] ;
59640: LD_ADDR_VAR 0 9
59644: PUSH
59645: LD_INT 120
59647: PUSH
59648: LD_INT 30
59650: PUSH
59651: LD_INT 80
59653: PUSH
59654: EMPTY
59655: LIST
59656: LIST
59657: LIST
59658: ST_TO_ADDR
// if GetWeapon ( i ) in [ ar_multimissile_ballista ] then
59659: LD_VAR 0 6
59663: PPUSH
59664: CALL_OW 264
59668: PUSH
59669: LD_INT 22
59671: PUSH
59672: EMPTY
59673: LIST
59674: IN
59675: IFFALSE 59696
// points := [ 40 , 1 , 1 ] ;
59677: LD_ADDR_VAR 0 9
59681: PUSH
59682: LD_INT 40
59684: PUSH
59685: LD_INT 1
59687: PUSH
59688: LD_INT 1
59690: PUSH
59691: EMPTY
59692: LIST
59693: LIST
59694: LIST
59695: ST_TO_ADDR
// if GetWeapon ( i ) in [ ar_selfpropelled_bomb ] then
59696: LD_VAR 0 6
59700: PPUSH
59701: CALL_OW 264
59705: PUSH
59706: LD_INT 29
59708: PUSH
59709: EMPTY
59710: LIST
59711: IN
59712: IFFALSE 59733
// points := [ 70 , 200 , 400 ] ;
59714: LD_ADDR_VAR 0 9
59718: PUSH
59719: LD_INT 70
59721: PUSH
59722: LD_INT 200
59724: PUSH
59725: LD_INT 400
59727: PUSH
59728: EMPTY
59729: LIST
59730: LIST
59731: LIST
59732: ST_TO_ADDR
// if GetWeapon ( i ) in [ us_bulldozer , ru_bulldozer ] then
59733: LD_VAR 0 6
59737: PPUSH
59738: CALL_OW 264
59742: PUSH
59743: LD_INT 14
59745: PUSH
59746: LD_INT 53
59748: PUSH
59749: EMPTY
59750: LIST
59751: LIST
59752: IN
59753: IFFALSE 59774
// points := [ 40 , 10 , 20 ] ;
59755: LD_ADDR_VAR 0 9
59759: PUSH
59760: LD_INT 40
59762: PUSH
59763: LD_INT 10
59765: PUSH
59766: LD_INT 20
59768: PUSH
59769: EMPTY
59770: LIST
59771: LIST
59772: LIST
59773: ST_TO_ADDR
// if GetWeapon ( i ) in [ us_laser ] then
59774: LD_VAR 0 6
59778: PPUSH
59779: CALL_OW 264
59783: PUSH
59784: LD_INT 9
59786: PUSH
59787: EMPTY
59788: LIST
59789: IN
59790: IFFALSE 59811
// points := [ 5 , 70 , 20 ] ;
59792: LD_ADDR_VAR 0 9
59796: PUSH
59797: LD_INT 5
59799: PUSH
59800: LD_INT 70
59802: PUSH
59803: LD_INT 20
59805: PUSH
59806: EMPTY
59807: LIST
59808: LIST
59809: LIST
59810: ST_TO_ADDR
// if GetWeapon ( i ) in [ us_double_laser ] then
59811: LD_VAR 0 6
59815: PPUSH
59816: CALL_OW 264
59820: PUSH
59821: LD_INT 10
59823: PUSH
59824: EMPTY
59825: LIST
59826: IN
59827: IFFALSE 59848
// points := [ 35 , 110 , 70 ] ;
59829: LD_ADDR_VAR 0 9
59833: PUSH
59834: LD_INT 35
59836: PUSH
59837: LD_INT 110
59839: PUSH
59840: LD_INT 70
59842: PUSH
59843: EMPTY
59844: LIST
59845: LIST
59846: LIST
59847: ST_TO_ADDR
// if GetChassis ( i ) = 25 then
59848: LD_VAR 0 6
59852: PPUSH
59853: CALL_OW 265
59857: PUSH
59858: LD_INT 25
59860: EQUAL
59861: IFFALSE 59882
// points := [ 80 , 65 , 100 ] ;
59863: LD_ADDR_VAR 0 9
59867: PUSH
59868: LD_INT 80
59870: PUSH
59871: LD_INT 65
59873: PUSH
59874: LD_INT 100
59876: PUSH
59877: EMPTY
59878: LIST
59879: LIST
59880: LIST
59881: ST_TO_ADDR
// if GetControl ( i ) = control_manual then
59882: LD_VAR 0 6
59886: PPUSH
59887: CALL_OW 263
59891: PUSH
59892: LD_INT 1
59894: EQUAL
59895: IFFALSE 59930
// bpoints := bpoints * ( GetSkill ( IsDrivenBy ( i ) , 3 ) * 4 ) ;
59897: LD_ADDR_VAR 0 10
59901: PUSH
59902: LD_VAR 0 10
59906: PUSH
59907: LD_VAR 0 6
59911: PPUSH
59912: CALL_OW 311
59916: PPUSH
59917: LD_INT 3
59919: PPUSH
59920: CALL_OW 259
59924: PUSH
59925: LD_INT 4
59927: MUL
59928: MUL
59929: ST_TO_ADDR
// if GetControl ( i ) = control_remote then
59930: LD_VAR 0 6
59934: PPUSH
59935: CALL_OW 263
59939: PUSH
59940: LD_INT 2
59942: EQUAL
59943: IFFALSE 59994
// begin j := IsControledBy ( i ) ;
59945: LD_ADDR_VAR 0 7
59949: PUSH
59950: LD_VAR 0 6
59954: PPUSH
59955: CALL_OW 312
59959: ST_TO_ADDR
// if j then
59960: LD_VAR 0 7
59964: IFFALSE 59994
// bpoints := bpoints * ( GetSkill ( j , 3 ) * 3 ) ;
59966: LD_ADDR_VAR 0 10
59970: PUSH
59971: LD_VAR 0 10
59975: PUSH
59976: LD_VAR 0 7
59980: PPUSH
59981: LD_INT 3
59983: PPUSH
59984: CALL_OW 259
59988: PUSH
59989: LD_INT 3
59991: MUL
59992: MUL
59993: ST_TO_ADDR
// end ; if GetWeapon ( i ) in [ us_double_gun , us_heavy_gun , ru_heavy_gun , ru_gun , ru_rocket , ru_rocket_launcher , ar_rocket_launcher , us_rocket_launcher , ar_gun , ar_selfpropelled_bomb ] and GetTech ( side , tech_weap2 ) = state_researched then
59994: LD_VAR 0 6
59998: PPUSH
59999: CALL_OW 264
60003: PUSH
60004: LD_INT 5
60006: PUSH
60007: LD_INT 6
60009: PUSH
60010: LD_INT 46
60012: PUSH
60013: LD_INT 44
60015: PUSH
60016: LD_INT 47
60018: PUSH
60019: LD_INT 45
60021: PUSH
60022: LD_INT 28
60024: PUSH
60025: LD_INT 7
60027: PUSH
60028: LD_INT 27
60030: PUSH
60031: LD_INT 29
60033: PUSH
60034: EMPTY
60035: LIST
60036: LIST
60037: LIST
60038: LIST
60039: LIST
60040: LIST
60041: LIST
60042: LIST
60043: LIST
60044: LIST
60045: IN
60046: PUSH
60047: LD_VAR 0 1
60051: PPUSH
60052: LD_INT 52
60054: PPUSH
60055: CALL_OW 321
60059: PUSH
60060: LD_INT 2
60062: EQUAL
60063: AND
60064: IFFALSE 60081
// bpoints := bpoints * 1.2 ;
60066: LD_ADDR_VAR 0 10
60070: PUSH
60071: LD_VAR 0 10
60075: PUSH
60076: LD_REAL  1.20000000000000E+0000
60079: MUL
60080: ST_TO_ADDR
// if GetWeapon ( i ) in [ us_heavy_gun , ru_heavy_gun , ru_rocket ] then
60081: LD_VAR 0 6
60085: PPUSH
60086: CALL_OW 264
60090: PUSH
60091: LD_INT 6
60093: PUSH
60094: LD_INT 46
60096: PUSH
60097: LD_INT 47
60099: PUSH
60100: EMPTY
60101: LIST
60102: LIST
60103: LIST
60104: IN
60105: IFFALSE 60122
// bpoints := bpoints * 1.2 ;
60107: LD_ADDR_VAR 0 10
60111: PUSH
60112: LD_VAR 0 10
60116: PUSH
60117: LD_REAL  1.20000000000000E+0000
60120: MUL
60121: ST_TO_ADDR
// end ; unit_building :
60122: GO 60136
60124: LD_INT 3
60126: DOUBLE
60127: EQUAL
60128: IFTRUE 60132
60130: GO 60135
60132: POP
// ; end ;
60133: GO 60136
60135: POP
// for j = 1 to 3 do
60136: LD_ADDR_VAR 0 7
60140: PUSH
60141: DOUBLE
60142: LD_INT 1
60144: DEC
60145: ST_TO_ADDR
60146: LD_INT 3
60148: PUSH
60149: FOR_TO
60150: IFFALSE 60203
// result := Replace ( result , j , result [ j ] + ( points [ j ] * bpoints ) ) ;
60152: LD_ADDR_VAR 0 5
60156: PUSH
60157: LD_VAR 0 5
60161: PPUSH
60162: LD_VAR 0 7
60166: PPUSH
60167: LD_VAR 0 5
60171: PUSH
60172: LD_VAR 0 7
60176: ARRAY
60177: PUSH
60178: LD_VAR 0 9
60182: PUSH
60183: LD_VAR 0 7
60187: ARRAY
60188: PUSH
60189: LD_VAR 0 10
60193: MUL
60194: PLUS
60195: PPUSH
60196: CALL_OW 1
60200: ST_TO_ADDR
60201: GO 60149
60203: POP
60204: POP
// end ;
60205: GO 58688
60207: POP
60208: POP
// result := Replace ( result , 4 , tmp ) ;
60209: LD_ADDR_VAR 0 5
60213: PUSH
60214: LD_VAR 0 5
60218: PPUSH
60219: LD_INT 4
60221: PPUSH
60222: LD_VAR 0 8
60226: PPUSH
60227: CALL_OW 1
60231: ST_TO_ADDR
// end ;
60232: LD_VAR 0 5
60236: RET
// export function DangerAtRange ( unit , range ) ; begin
60237: LD_INT 0
60239: PPUSH
// result := DangerAtRangeXY ( GetSide ( unit ) , GetX ( unit ) , GetY ( unit ) , range ) ;
60240: LD_ADDR_VAR 0 3
60244: PUSH
60245: LD_VAR 0 1
60249: PPUSH
60250: CALL_OW 255
60254: PPUSH
60255: LD_VAR 0 1
60259: PPUSH
60260: CALL_OW 250
60264: PPUSH
60265: LD_VAR 0 1
60269: PPUSH
60270: CALL_OW 251
60274: PPUSH
60275: LD_VAR 0 2
60279: PPUSH
60280: CALL 58540 0 4
60284: ST_TO_ADDR
// end ;
60285: LD_VAR 0 3
60289: RET
// export function DangerInArea ( side , area ) ; begin
60290: LD_INT 0
60292: PPUSH
// result := FilterUnitsInArea ( area , [ f_enemy , side ] ) ;
60293: LD_ADDR_VAR 0 3
60297: PUSH
60298: LD_VAR 0 2
60302: PPUSH
60303: LD_INT 81
60305: PUSH
60306: LD_VAR 0 1
60310: PUSH
60311: EMPTY
60312: LIST
60313: LIST
60314: PPUSH
60315: CALL_OW 70
60319: ST_TO_ADDR
// end ;
60320: LD_VAR 0 3
60324: RET
// export function IsExtension ( b ) ; begin
60325: LD_INT 0
60327: PPUSH
// result := b in [ b_ext_stitch , b_ext_radar , b_ext_radio , b_ext_gun , b_ext_computer , b_ext_siberium , b_ext_noncombat , b_ext_track , b_ext_laser , b_ext_rocket ] ;
60328: LD_ADDR_VAR 0 2
60332: PUSH
60333: LD_VAR 0 1
60337: PUSH
60338: LD_INT 23
60340: PUSH
60341: LD_INT 20
60343: PUSH
60344: LD_INT 22
60346: PUSH
60347: LD_INT 17
60349: PUSH
60350: LD_INT 24
60352: PUSH
60353: LD_INT 21
60355: PUSH
60356: LD_INT 19
60358: PUSH
60359: LD_INT 16
60361: PUSH
60362: LD_INT 25
60364: PUSH
60365: LD_INT 18
60367: PUSH
60368: EMPTY
60369: LIST
60370: LIST
60371: LIST
60372: LIST
60373: LIST
60374: LIST
60375: LIST
60376: LIST
60377: LIST
60378: LIST
60379: IN
60380: ST_TO_ADDR
// end ;
60381: LD_VAR 0 2
60385: RET
// export function GetBaseBuildings ( base , area ) ; var tmp , i ; begin
60386: LD_INT 0
60388: PPUSH
60389: PPUSH
60390: PPUSH
// result := [ ] ;
60391: LD_ADDR_VAR 0 3
60395: PUSH
60396: EMPTY
60397: ST_TO_ADDR
// tmp := FilterUnitsInArea ( area , [ f_type , unit_building ] ) ;
60398: LD_ADDR_VAR 0 4
60402: PUSH
60403: LD_VAR 0 2
60407: PPUSH
60408: LD_INT 21
60410: PUSH
60411: LD_INT 3
60413: PUSH
60414: EMPTY
60415: LIST
60416: LIST
60417: PPUSH
60418: CALL_OW 70
60422: ST_TO_ADDR
// if not tmp then
60423: LD_VAR 0 4
60427: NOT
60428: IFFALSE 60432
// exit ;
60430: GO 60490
// for i in tmp do
60432: LD_ADDR_VAR 0 5
60436: PUSH
60437: LD_VAR 0 4
60441: PUSH
60442: FOR_IN
60443: IFFALSE 60478
// if GetBase ( i ) <> base then
60445: LD_VAR 0 5
60449: PPUSH
60450: CALL_OW 274
60454: PUSH
60455: LD_VAR 0 1
60459: NONEQUAL
60460: IFFALSE 60476
// ComLinkToBase ( base , i ) ;
60462: LD_VAR 0 1
60466: PPUSH
60467: LD_VAR 0 5
60471: PPUSH
60472: CALL_OW 169
60476: GO 60442
60478: POP
60479: POP
// result := tmp ;
60480: LD_ADDR_VAR 0 3
60484: PUSH
60485: LD_VAR 0 4
60489: ST_TO_ADDR
// end ;
60490: LD_VAR 0 3
60494: RET
// export function ComComplete ( unit , b ) ; var i ; begin
60495: LD_INT 0
60497: PPUSH
60498: PPUSH
// if BuildingStatus ( b ) = bs_build then
60499: LD_VAR 0 2
60503: PPUSH
60504: CALL_OW 461
60508: PUSH
60509: LD_INT 1
60511: EQUAL
60512: IFFALSE 60572
// SetTaskList ( unit , [ [ h , GetX ( b ) , GetY ( b ) , b , 0 , 0 , 0 ] ] ) ;
60514: LD_VAR 0 1
60518: PPUSH
60519: LD_STRING h
60521: PUSH
60522: LD_VAR 0 2
60526: PPUSH
60527: CALL_OW 250
60531: PUSH
60532: LD_VAR 0 2
60536: PPUSH
60537: CALL_OW 251
60541: PUSH
60542: LD_VAR 0 2
60546: PUSH
60547: LD_INT 0
60549: PUSH
60550: LD_INT 0
60552: PUSH
60553: LD_INT 0
60555: PUSH
60556: EMPTY
60557: LIST
60558: LIST
60559: LIST
60560: LIST
60561: LIST
60562: LIST
60563: LIST
60564: PUSH
60565: EMPTY
60566: LIST
60567: PPUSH
60568: CALL_OW 446
// end ;
60572: LD_VAR 0 3
60576: RET
// export function Connect ( vehicle ) ; var i , t , mech , tmp , j ; begin
60577: LD_INT 0
60579: PPUSH
60580: PPUSH
60581: PPUSH
60582: PPUSH
60583: PPUSH
60584: PPUSH
// if not vehicle or not GetControl ( vehicle ) = control_remote then
60585: LD_VAR 0 1
60589: NOT
60590: PUSH
60591: LD_VAR 0 1
60595: PPUSH
60596: CALL_OW 263
60600: PUSH
60601: LD_INT 2
60603: EQUAL
60604: NOT
60605: OR
60606: IFFALSE 60610
// exit ;
60608: GO 60926
// tmp := FilterAllUnits ( [ [ f_side , GetSide ( vehicle ) ] , [ f_or , [ f_btype , b_control_tower ] , [ f_weapon , ar_control_tower ] ] ] ) ;
60610: LD_ADDR_VAR 0 6
60614: PUSH
60615: LD_INT 22
60617: PUSH
60618: LD_VAR 0 1
60622: PPUSH
60623: CALL_OW 255
60627: PUSH
60628: EMPTY
60629: LIST
60630: LIST
60631: PUSH
60632: LD_INT 2
60634: PUSH
60635: LD_INT 30
60637: PUSH
60638: LD_INT 36
60640: PUSH
60641: EMPTY
60642: LIST
60643: LIST
60644: PUSH
60645: LD_INT 34
60647: PUSH
60648: LD_INT 31
60650: PUSH
60651: EMPTY
60652: LIST
60653: LIST
60654: PUSH
60655: EMPTY
60656: LIST
60657: LIST
60658: LIST
60659: PUSH
60660: EMPTY
60661: LIST
60662: LIST
60663: PPUSH
60664: CALL_OW 69
60668: ST_TO_ADDR
// if not tmp then
60669: LD_VAR 0 6
60673: NOT
60674: IFFALSE 60678
// exit ;
60676: GO 60926
// result := [ ] ;
60678: LD_ADDR_VAR 0 2
60682: PUSH
60683: EMPTY
60684: ST_TO_ADDR
// for i in tmp do
60685: LD_ADDR_VAR 0 3
60689: PUSH
60690: LD_VAR 0 6
60694: PUSH
60695: FOR_IN
60696: IFFALSE 60767
// begin t := UnitsInside ( i ) ;
60698: LD_ADDR_VAR 0 4
60702: PUSH
60703: LD_VAR 0 3
60707: PPUSH
60708: CALL_OW 313
60712: ST_TO_ADDR
// if t then
60713: LD_VAR 0 4
60717: IFFALSE 60765
// for j in t do
60719: LD_ADDR_VAR 0 7
60723: PUSH
60724: LD_VAR 0 4
60728: PUSH
60729: FOR_IN
60730: IFFALSE 60763
// result := Insert ( result , result + 1 , j ) ;
60732: LD_ADDR_VAR 0 2
60736: PUSH
60737: LD_VAR 0 2
60741: PPUSH
60742: LD_VAR 0 2
60746: PUSH
60747: LD_INT 1
60749: PLUS
60750: PPUSH
60751: LD_VAR 0 7
60755: PPUSH
60756: CALL_OW 2
60760: ST_TO_ADDR
60761: GO 60729
60763: POP
60764: POP
// end ;
60765: GO 60695
60767: POP
60768: POP
// if not result then
60769: LD_VAR 0 2
60773: NOT
60774: IFFALSE 60778
// exit ;
60776: GO 60926
// mech := result [ 1 ] ;
60778: LD_ADDR_VAR 0 5
60782: PUSH
60783: LD_VAR 0 2
60787: PUSH
60788: LD_INT 1
60790: ARRAY
60791: ST_TO_ADDR
// if result > 1 then
60792: LD_VAR 0 2
60796: PUSH
60797: LD_INT 1
60799: GREATER
60800: IFFALSE 60912
// for i = 2 to result do
60802: LD_ADDR_VAR 0 3
60806: PUSH
60807: DOUBLE
60808: LD_INT 2
60810: DEC
60811: ST_TO_ADDR
60812: LD_VAR 0 2
60816: PUSH
60817: FOR_TO
60818: IFFALSE 60910
// begin t := GetSkill ( result [ i ] , 3 ) - UnitsLinked ( result [ i ] ) ;
60820: LD_ADDR_VAR 0 4
60824: PUSH
60825: LD_VAR 0 2
60829: PUSH
60830: LD_VAR 0 3
60834: ARRAY
60835: PPUSH
60836: LD_INT 3
60838: PPUSH
60839: CALL_OW 259
60843: PUSH
60844: LD_VAR 0 2
60848: PUSH
60849: LD_VAR 0 3
60853: ARRAY
60854: PPUSH
60855: CALL_OW 432
60859: MINUS
60860: ST_TO_ADDR
// if t >= ( GetSkill ( mech , 3 ) - UnitsLinked ( mech ) ) then
60861: LD_VAR 0 4
60865: PUSH
60866: LD_VAR 0 5
60870: PPUSH
60871: LD_INT 3
60873: PPUSH
60874: CALL_OW 259
60878: PUSH
60879: LD_VAR 0 5
60883: PPUSH
60884: CALL_OW 432
60888: MINUS
60889: GREATEREQUAL
60890: IFFALSE 60908
// mech := result [ i ] ;
60892: LD_ADDR_VAR 0 5
60896: PUSH
60897: LD_VAR 0 2
60901: PUSH
60902: LD_VAR 0 3
60906: ARRAY
60907: ST_TO_ADDR
// end ;
60908: GO 60817
60910: POP
60911: POP
// ComLinkTo ( vehicle , mech ) ;
60912: LD_VAR 0 1
60916: PPUSH
60917: LD_VAR 0 5
60921: PPUSH
60922: CALL_OW 135
// end ;
60926: LD_VAR 0 2
60930: RET
// export function PrepareBase ( base_dep , area , name , skill , sources , personel ) ; var i , j , d , b , f , x , un , base , side , nation , buildings , tmp ; begin
60931: LD_INT 0
60933: PPUSH
60934: PPUSH
60935: PPUSH
60936: PPUSH
60937: PPUSH
60938: PPUSH
60939: PPUSH
60940: PPUSH
60941: PPUSH
60942: PPUSH
60943: PPUSH
60944: PPUSH
60945: PPUSH
// result := [ ] ;
60946: LD_ADDR_VAR 0 7
60950: PUSH
60951: EMPTY
60952: ST_TO_ADDR
// if not GetBType ( base_dep ) in [ b_depot , b_warehouse ] then
60953: LD_VAR 0 1
60957: PPUSH
60958: CALL_OW 266
60962: PUSH
60963: LD_INT 0
60965: PUSH
60966: LD_INT 1
60968: PUSH
60969: EMPTY
60970: LIST
60971: LIST
60972: IN
60973: NOT
60974: IFFALSE 60978
// exit ;
60976: GO 62609
// if name then
60978: LD_VAR 0 3
60982: IFFALSE 60998
// SetBName ( base_dep , name ) ;
60984: LD_VAR 0 1
60988: PPUSH
60989: LD_VAR 0 3
60993: PPUSH
60994: CALL_OW 500
// base := GetBase ( base_dep ) ;
60998: LD_ADDR_VAR 0 15
61002: PUSH
61003: LD_VAR 0 1
61007: PPUSH
61008: CALL_OW 274
61012: ST_TO_ADDR
// side := GetSide ( base_dep ) ;
61013: LD_ADDR_VAR 0 16
61017: PUSH
61018: LD_VAR 0 1
61022: PPUSH
61023: CALL_OW 255
61027: ST_TO_ADDR
// nation := GetNation ( base_dep ) ;
61028: LD_ADDR_VAR 0 17
61032: PUSH
61033: LD_VAR 0 1
61037: PPUSH
61038: CALL_OW 248
61042: ST_TO_ADDR
// if sources then
61043: LD_VAR 0 5
61047: IFFALSE 61094
// for i = 1 to 3 do
61049: LD_ADDR_VAR 0 8
61053: PUSH
61054: DOUBLE
61055: LD_INT 1
61057: DEC
61058: ST_TO_ADDR
61059: LD_INT 3
61061: PUSH
61062: FOR_TO
61063: IFFALSE 61092
// AddResourceType ( base , i , sources [ i ] ) ;
61065: LD_VAR 0 15
61069: PPUSH
61070: LD_VAR 0 8
61074: PPUSH
61075: LD_VAR 0 5
61079: PUSH
61080: LD_VAR 0 8
61084: ARRAY
61085: PPUSH
61086: CALL_OW 276
61090: GO 61062
61092: POP
61093: POP
// buildings := GetBaseBuildings ( base , area ) ;
61094: LD_ADDR_VAR 0 18
61098: PUSH
61099: LD_VAR 0 15
61103: PPUSH
61104: LD_VAR 0 2
61108: PPUSH
61109: CALL 60386 0 2
61113: ST_TO_ADDR
// InitHc ;
61114: CALL_OW 19
// InitUc ;
61118: CALL_OW 18
// uc_side := side ;
61122: LD_ADDR_OWVAR 20
61126: PUSH
61127: LD_VAR 0 16
61131: ST_TO_ADDR
// uc_nation := nation ;
61132: LD_ADDR_OWVAR 21
61136: PUSH
61137: LD_VAR 0 17
61141: ST_TO_ADDR
// if buildings then
61142: LD_VAR 0 18
61146: IFFALSE 62468
// begin tmp := UnitFilter ( buildings , [ f_or , [ f_btype , b_oil_mine ] , [ f_btype , b_siberite_mine ] ] ) ;
61148: LD_ADDR_VAR 0 19
61152: PUSH
61153: LD_VAR 0 18
61157: PPUSH
61158: LD_INT 2
61160: PUSH
61161: LD_INT 30
61163: PUSH
61164: LD_INT 29
61166: PUSH
61167: EMPTY
61168: LIST
61169: LIST
61170: PUSH
61171: LD_INT 30
61173: PUSH
61174: LD_INT 30
61176: PUSH
61177: EMPTY
61178: LIST
61179: LIST
61180: PUSH
61181: EMPTY
61182: LIST
61183: LIST
61184: LIST
61185: PPUSH
61186: CALL_OW 72
61190: ST_TO_ADDR
// if tmp then
61191: LD_VAR 0 19
61195: IFFALSE 61243
// for i in tmp do
61197: LD_ADDR_VAR 0 8
61201: PUSH
61202: LD_VAR 0 19
61206: PUSH
61207: FOR_IN
61208: IFFALSE 61241
// SetResourceVisibility ( GetX ( i ) , GetY ( i ) , side ) ;
61210: LD_VAR 0 8
61214: PPUSH
61215: CALL_OW 250
61219: PPUSH
61220: LD_VAR 0 8
61224: PPUSH
61225: CALL_OW 251
61229: PPUSH
61230: LD_VAR 0 16
61234: PPUSH
61235: CALL_OW 441
61239: GO 61207
61241: POP
61242: POP
// if UnitFilter ( buildings , [ f_or , [ f_btype , b_bunker ] , [ f_btype , b_turret ] ] ) then
61243: LD_VAR 0 18
61247: PPUSH
61248: LD_INT 2
61250: PUSH
61251: LD_INT 30
61253: PUSH
61254: LD_INT 32
61256: PUSH
61257: EMPTY
61258: LIST
61259: LIST
61260: PUSH
61261: LD_INT 30
61263: PUSH
61264: LD_INT 33
61266: PUSH
61267: EMPTY
61268: LIST
61269: LIST
61270: PUSH
61271: EMPTY
61272: LIST
61273: LIST
61274: LIST
61275: PPUSH
61276: CALL_OW 72
61280: IFFALSE 61368
// begin for i in UnitFilter ( buildings , [ f_or , [ f_btype , b_bunker ] , [ f_btype , b_turret ] ] ) do
61282: LD_ADDR_VAR 0 8
61286: PUSH
61287: LD_VAR 0 18
61291: PPUSH
61292: LD_INT 2
61294: PUSH
61295: LD_INT 30
61297: PUSH
61298: LD_INT 32
61300: PUSH
61301: EMPTY
61302: LIST
61303: LIST
61304: PUSH
61305: LD_INT 30
61307: PUSH
61308: LD_INT 33
61310: PUSH
61311: EMPTY
61312: LIST
61313: LIST
61314: PUSH
61315: EMPTY
61316: LIST
61317: LIST
61318: LIST
61319: PPUSH
61320: CALL_OW 72
61324: PUSH
61325: FOR_IN
61326: IFFALSE 61366
// begin if not GetBWeapon ( i ) then
61328: LD_VAR 0 8
61332: PPUSH
61333: CALL_OW 269
61337: NOT
61338: IFFALSE 61364
// PlaceWeaponTurret ( i , GetTurretWeapon ( i , area ) ) ;
61340: LD_VAR 0 8
61344: PPUSH
61345: LD_VAR 0 8
61349: PPUSH
61350: LD_VAR 0 2
61354: PPUSH
61355: CALL 62614 0 2
61359: PPUSH
61360: CALL_OW 431
// end ;
61364: GO 61325
61366: POP
61367: POP
// end ; for i = 1 to personel do
61368: LD_ADDR_VAR 0 8
61372: PUSH
61373: DOUBLE
61374: LD_INT 1
61376: DEC
61377: ST_TO_ADDR
61378: LD_VAR 0 6
61382: PUSH
61383: FOR_TO
61384: IFFALSE 62448
// begin if i > 4 then
61386: LD_VAR 0 8
61390: PUSH
61391: LD_INT 4
61393: GREATER
61394: IFFALSE 61398
// break ;
61396: GO 62448
// case i of 1 :
61398: LD_VAR 0 8
61402: PUSH
61403: LD_INT 1
61405: DOUBLE
61406: EQUAL
61407: IFTRUE 61411
61409: GO 61491
61411: POP
// f := UnitFilter ( buildings , [ [ f_side , side ] , [ f_empty ] , [ f_or , [ f_btype , b_bunker ] , [ f_btype , b_armoury ] , [ f_btype , b_barracks ] ] ] ) ; 2 :
61412: LD_ADDR_VAR 0 12
61416: PUSH
61417: LD_VAR 0 18
61421: PPUSH
61422: LD_INT 22
61424: PUSH
61425: LD_VAR 0 16
61429: PUSH
61430: EMPTY
61431: LIST
61432: LIST
61433: PUSH
61434: LD_INT 58
61436: PUSH
61437: EMPTY
61438: LIST
61439: PUSH
61440: LD_INT 2
61442: PUSH
61443: LD_INT 30
61445: PUSH
61446: LD_INT 32
61448: PUSH
61449: EMPTY
61450: LIST
61451: LIST
61452: PUSH
61453: LD_INT 30
61455: PUSH
61456: LD_INT 4
61458: PUSH
61459: EMPTY
61460: LIST
61461: LIST
61462: PUSH
61463: LD_INT 30
61465: PUSH
61466: LD_INT 5
61468: PUSH
61469: EMPTY
61470: LIST
61471: LIST
61472: PUSH
61473: EMPTY
61474: LIST
61475: LIST
61476: LIST
61477: LIST
61478: PUSH
61479: EMPTY
61480: LIST
61481: LIST
61482: LIST
61483: PPUSH
61484: CALL_OW 72
61488: ST_TO_ADDR
61489: GO 61713
61491: LD_INT 2
61493: DOUBLE
61494: EQUAL
61495: IFTRUE 61499
61497: GO 61561
61499: POP
// f := UnitFilter ( buildings , [ [ f_side , side ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ] ) ; 3 :
61500: LD_ADDR_VAR 0 12
61504: PUSH
61505: LD_VAR 0 18
61509: PPUSH
61510: LD_INT 22
61512: PUSH
61513: LD_VAR 0 16
61517: PUSH
61518: EMPTY
61519: LIST
61520: LIST
61521: PUSH
61522: LD_INT 2
61524: PUSH
61525: LD_INT 30
61527: PUSH
61528: LD_INT 0
61530: PUSH
61531: EMPTY
61532: LIST
61533: LIST
61534: PUSH
61535: LD_INT 30
61537: PUSH
61538: LD_INT 1
61540: PUSH
61541: EMPTY
61542: LIST
61543: LIST
61544: PUSH
61545: EMPTY
61546: LIST
61547: LIST
61548: LIST
61549: PUSH
61550: EMPTY
61551: LIST
61552: LIST
61553: PPUSH
61554: CALL_OW 72
61558: ST_TO_ADDR
61559: GO 61713
61561: LD_INT 3
61563: DOUBLE
61564: EQUAL
61565: IFTRUE 61569
61567: GO 61631
61569: POP
// f := UnitFilter ( buildings , [ [ f_side , side ] , [ f_or , [ f_btype , b_workshop ] , [ f_btype , b_factory ] ] ] ) ; 4 :
61570: LD_ADDR_VAR 0 12
61574: PUSH
61575: LD_VAR 0 18
61579: PPUSH
61580: LD_INT 22
61582: PUSH
61583: LD_VAR 0 16
61587: PUSH
61588: EMPTY
61589: LIST
61590: LIST
61591: PUSH
61592: LD_INT 2
61594: PUSH
61595: LD_INT 30
61597: PUSH
61598: LD_INT 2
61600: PUSH
61601: EMPTY
61602: LIST
61603: LIST
61604: PUSH
61605: LD_INT 30
61607: PUSH
61608: LD_INT 3
61610: PUSH
61611: EMPTY
61612: LIST
61613: LIST
61614: PUSH
61615: EMPTY
61616: LIST
61617: LIST
61618: LIST
61619: PUSH
61620: EMPTY
61621: LIST
61622: LIST
61623: PPUSH
61624: CALL_OW 72
61628: ST_TO_ADDR
61629: GO 61713
61631: LD_INT 4
61633: DOUBLE
61634: EQUAL
61635: IFTRUE 61639
61637: GO 61712
61639: POP
// f := UnitFilter ( buildings , [ [ f_side , side ] , [ f_or , [ f_btype , b_lab ] , [ f_btype , b_lab_half ] , [ f_btype , b_lab_full ] ] ] ) ; end ;
61640: LD_ADDR_VAR 0 12
61644: PUSH
61645: LD_VAR 0 18
61649: PPUSH
61650: LD_INT 22
61652: PUSH
61653: LD_VAR 0 16
61657: PUSH
61658: EMPTY
61659: LIST
61660: LIST
61661: PUSH
61662: LD_INT 2
61664: PUSH
61665: LD_INT 30
61667: PUSH
61668: LD_INT 6
61670: PUSH
61671: EMPTY
61672: LIST
61673: LIST
61674: PUSH
61675: LD_INT 30
61677: PUSH
61678: LD_INT 7
61680: PUSH
61681: EMPTY
61682: LIST
61683: LIST
61684: PUSH
61685: LD_INT 30
61687: PUSH
61688: LD_INT 8
61690: PUSH
61691: EMPTY
61692: LIST
61693: LIST
61694: PUSH
61695: EMPTY
61696: LIST
61697: LIST
61698: LIST
61699: LIST
61700: PUSH
61701: EMPTY
61702: LIST
61703: LIST
61704: PPUSH
61705: CALL_OW 72
61709: ST_TO_ADDR
61710: GO 61713
61712: POP
// if i = 1 then
61713: LD_VAR 0 8
61717: PUSH
61718: LD_INT 1
61720: EQUAL
61721: IFFALSE 61832
// begin tmp := [ ] ;
61723: LD_ADDR_VAR 0 19
61727: PUSH
61728: EMPTY
61729: ST_TO_ADDR
// for j in f do
61730: LD_ADDR_VAR 0 9
61734: PUSH
61735: LD_VAR 0 12
61739: PUSH
61740: FOR_IN
61741: IFFALSE 61814
// if GetBType ( j ) = b_bunker then
61743: LD_VAR 0 9
61747: PPUSH
61748: CALL_OW 266
61752: PUSH
61753: LD_INT 32
61755: EQUAL
61756: IFFALSE 61783
// tmp := Insert ( tmp , 1 , j ) else
61758: LD_ADDR_VAR 0 19
61762: PUSH
61763: LD_VAR 0 19
61767: PPUSH
61768: LD_INT 1
61770: PPUSH
61771: LD_VAR 0 9
61775: PPUSH
61776: CALL_OW 2
61780: ST_TO_ADDR
61781: GO 61812
// tmp := Insert ( tmp , tmp + 1 , j ) ;
61783: LD_ADDR_VAR 0 19
61787: PUSH
61788: LD_VAR 0 19
61792: PPUSH
61793: LD_VAR 0 19
61797: PUSH
61798: LD_INT 1
61800: PLUS
61801: PPUSH
61802: LD_VAR 0 9
61806: PPUSH
61807: CALL_OW 2
61811: ST_TO_ADDR
61812: GO 61740
61814: POP
61815: POP
// if tmp then
61816: LD_VAR 0 19
61820: IFFALSE 61832
// f := tmp ;
61822: LD_ADDR_VAR 0 12
61826: PUSH
61827: LD_VAR 0 19
61831: ST_TO_ADDR
// end ; x := personel [ i ] ;
61832: LD_ADDR_VAR 0 13
61836: PUSH
61837: LD_VAR 0 6
61841: PUSH
61842: LD_VAR 0 8
61846: ARRAY
61847: ST_TO_ADDR
// if x = - 1 then
61848: LD_VAR 0 13
61852: PUSH
61853: LD_INT 1
61855: NEG
61856: EQUAL
61857: IFFALSE 62066
// begin for j in f do
61859: LD_ADDR_VAR 0 9
61863: PUSH
61864: LD_VAR 0 12
61868: PUSH
61869: FOR_IN
61870: IFFALSE 62062
// repeat InitHc ;
61872: CALL_OW 19
// if GetBType ( j ) = b_barracks then
61876: LD_VAR 0 9
61880: PPUSH
61881: CALL_OW 266
61885: PUSH
61886: LD_INT 5
61888: EQUAL
61889: IFFALSE 61959
// begin if UnitsInside ( j ) < 3 then
61891: LD_VAR 0 9
61895: PPUSH
61896: CALL_OW 313
61900: PUSH
61901: LD_INT 3
61903: LESS
61904: IFFALSE 61940
// PrepareHuman ( false , [ class_sniper , class_mortar , class_bazooker ] [ nation ] , skill ) else
61906: LD_INT 0
61908: PPUSH
61909: LD_INT 5
61911: PUSH
61912: LD_INT 8
61914: PUSH
61915: LD_INT 9
61917: PUSH
61918: EMPTY
61919: LIST
61920: LIST
61921: LIST
61922: PUSH
61923: LD_VAR 0 17
61927: ARRAY
61928: PPUSH
61929: LD_VAR 0 4
61933: PPUSH
61934: CALL_OW 380
61938: GO 61957
// PrepareHuman ( false , i , skill ) ;
61940: LD_INT 0
61942: PPUSH
61943: LD_VAR 0 8
61947: PPUSH
61948: LD_VAR 0 4
61952: PPUSH
61953: CALL_OW 380
// end else
61957: GO 61976
// PrepareHuman ( false , i , skill ) ;
61959: LD_INT 0
61961: PPUSH
61962: LD_VAR 0 8
61966: PPUSH
61967: LD_VAR 0 4
61971: PPUSH
61972: CALL_OW 380
// un := CreateHuman ;
61976: LD_ADDR_VAR 0 14
61980: PUSH
61981: CALL_OW 44
61985: ST_TO_ADDR
// result := Insert ( result , 1 , un ) ;
61986: LD_ADDR_VAR 0 7
61990: PUSH
61991: LD_VAR 0 7
61995: PPUSH
61996: LD_INT 1
61998: PPUSH
61999: LD_VAR 0 14
62003: PPUSH
62004: CALL_OW 2
62008: ST_TO_ADDR
// PlaceHumanInUnit ( un , j ) ;
62009: LD_VAR 0 14
62013: PPUSH
62014: LD_VAR 0 9
62018: PPUSH
62019: CALL_OW 52
// until UnitsInside ( j ) = 6 or GetBType ( j ) in [ b_bunker , b_breastwork ] ;
62023: LD_VAR 0 9
62027: PPUSH
62028: CALL_OW 313
62032: PUSH
62033: LD_INT 6
62035: EQUAL
62036: PUSH
62037: LD_VAR 0 9
62041: PPUSH
62042: CALL_OW 266
62046: PUSH
62047: LD_INT 32
62049: PUSH
62050: LD_INT 31
62052: PUSH
62053: EMPTY
62054: LIST
62055: LIST
62056: IN
62057: OR
62058: IFFALSE 61872
62060: GO 61869
62062: POP
62063: POP
// end else
62064: GO 62446
// for j = 1 to x do
62066: LD_ADDR_VAR 0 9
62070: PUSH
62071: DOUBLE
62072: LD_INT 1
62074: DEC
62075: ST_TO_ADDR
62076: LD_VAR 0 13
62080: PUSH
62081: FOR_TO
62082: IFFALSE 62444
// begin InitHc ;
62084: CALL_OW 19
// if not f then
62088: LD_VAR 0 12
62092: NOT
62093: IFFALSE 62182
// begin PrepareHuman ( false , i , skill ) ;
62095: LD_INT 0
62097: PPUSH
62098: LD_VAR 0 8
62102: PPUSH
62103: LD_VAR 0 4
62107: PPUSH
62108: CALL_OW 380
// un := CreateHuman ;
62112: LD_ADDR_VAR 0 14
62116: PUSH
62117: CALL_OW 44
62121: ST_TO_ADDR
// result := Insert ( result , 1 , un ) ;
62122: LD_ADDR_VAR 0 7
62126: PUSH
62127: LD_VAR 0 7
62131: PPUSH
62132: LD_INT 1
62134: PPUSH
62135: LD_VAR 0 14
62139: PPUSH
62140: CALL_OW 2
62144: ST_TO_ADDR
// PlaceUnitXYR ( un , GetX ( base_dep ) , GetY ( base_dep ) , 10 , false ) ;
62145: LD_VAR 0 14
62149: PPUSH
62150: LD_VAR 0 1
62154: PPUSH
62155: CALL_OW 250
62159: PPUSH
62160: LD_VAR 0 1
62164: PPUSH
62165: CALL_OW 251
62169: PPUSH
62170: LD_INT 10
62172: PPUSH
62173: LD_INT 0
62175: PPUSH
62176: CALL_OW 50
// continue ;
62180: GO 62081
// end ; if ( UnitsInside ( f [ 1 ] ) and GetBType ( f [ 1 ] ) in [ b_bunker , b_breastwork ] ) or ( UnitsInside ( f [ 1 ] ) = 6 ) then
62182: LD_VAR 0 12
62186: PUSH
62187: LD_INT 1
62189: ARRAY
62190: PPUSH
62191: CALL_OW 313
62195: PUSH
62196: LD_VAR 0 12
62200: PUSH
62201: LD_INT 1
62203: ARRAY
62204: PPUSH
62205: CALL_OW 266
62209: PUSH
62210: LD_INT 32
62212: PUSH
62213: LD_INT 31
62215: PUSH
62216: EMPTY
62217: LIST
62218: LIST
62219: IN
62220: AND
62221: PUSH
62222: LD_VAR 0 12
62226: PUSH
62227: LD_INT 1
62229: ARRAY
62230: PPUSH
62231: CALL_OW 313
62235: PUSH
62236: LD_INT 6
62238: EQUAL
62239: OR
62240: IFFALSE 62260
// f := Delete ( f , 1 ) ;
62242: LD_ADDR_VAR 0 12
62246: PUSH
62247: LD_VAR 0 12
62251: PPUSH
62252: LD_INT 1
62254: PPUSH
62255: CALL_OW 3
62259: ST_TO_ADDR
// if not f then
62260: LD_VAR 0 12
62264: NOT
62265: IFFALSE 62283
// begin x := x + 2 ;
62267: LD_ADDR_VAR 0 13
62271: PUSH
62272: LD_VAR 0 13
62276: PUSH
62277: LD_INT 2
62279: PLUS
62280: ST_TO_ADDR
// continue ;
62281: GO 62081
// end ; if GetBType ( f [ 1 ] ) = b_barracks then
62283: LD_VAR 0 12
62287: PUSH
62288: LD_INT 1
62290: ARRAY
62291: PPUSH
62292: CALL_OW 266
62296: PUSH
62297: LD_INT 5
62299: EQUAL
62300: IFFALSE 62374
// begin if UnitsInside ( f [ 1 ] ) < 3 then
62302: LD_VAR 0 12
62306: PUSH
62307: LD_INT 1
62309: ARRAY
62310: PPUSH
62311: CALL_OW 313
62315: PUSH
62316: LD_INT 3
62318: LESS
62319: IFFALSE 62355
// PrepareHuman ( false , [ class_sniper , class_mortar , class_bazooker ] [ nation ] , skill ) else
62321: LD_INT 0
62323: PPUSH
62324: LD_INT 5
62326: PUSH
62327: LD_INT 8
62329: PUSH
62330: LD_INT 9
62332: PUSH
62333: EMPTY
62334: LIST
62335: LIST
62336: LIST
62337: PUSH
62338: LD_VAR 0 17
62342: ARRAY
62343: PPUSH
62344: LD_VAR 0 4
62348: PPUSH
62349: CALL_OW 380
62353: GO 62372
// PrepareHuman ( false , i , skill ) ;
62355: LD_INT 0
62357: PPUSH
62358: LD_VAR 0 8
62362: PPUSH
62363: LD_VAR 0 4
62367: PPUSH
62368: CALL_OW 380
// end else
62372: GO 62391
// PrepareHuman ( false , i , skill ) ;
62374: LD_INT 0
62376: PPUSH
62377: LD_VAR 0 8
62381: PPUSH
62382: LD_VAR 0 4
62386: PPUSH
62387: CALL_OW 380
// un := CreateHuman ;
62391: LD_ADDR_VAR 0 14
62395: PUSH
62396: CALL_OW 44
62400: ST_TO_ADDR
// result := Insert ( result , 1 , un ) ;
62401: LD_ADDR_VAR 0 7
62405: PUSH
62406: LD_VAR 0 7
62410: PPUSH
62411: LD_INT 1
62413: PPUSH
62414: LD_VAR 0 14
62418: PPUSH
62419: CALL_OW 2
62423: ST_TO_ADDR
// PlaceHumanInUnit ( un , f [ 1 ] ) ;
62424: LD_VAR 0 14
62428: PPUSH
62429: LD_VAR 0 12
62433: PUSH
62434: LD_INT 1
62436: ARRAY
62437: PPUSH
62438: CALL_OW 52
// end ;
62442: GO 62081
62444: POP
62445: POP
// end ;
62446: GO 61383
62448: POP
62449: POP
// result := result ^ buildings ;
62450: LD_ADDR_VAR 0 7
62454: PUSH
62455: LD_VAR 0 7
62459: PUSH
62460: LD_VAR 0 18
62464: ADD
62465: ST_TO_ADDR
// end else
62466: GO 62609
// begin for i = 1 to personel do
62468: LD_ADDR_VAR 0 8
62472: PUSH
62473: DOUBLE
62474: LD_INT 1
62476: DEC
62477: ST_TO_ADDR
62478: LD_VAR 0 6
62482: PUSH
62483: FOR_TO
62484: IFFALSE 62607
// begin if i > 4 then
62486: LD_VAR 0 8
62490: PUSH
62491: LD_INT 4
62493: GREATER
62494: IFFALSE 62498
// break ;
62496: GO 62607
// x := personel [ i ] ;
62498: LD_ADDR_VAR 0 13
62502: PUSH
62503: LD_VAR 0 6
62507: PUSH
62508: LD_VAR 0 8
62512: ARRAY
62513: ST_TO_ADDR
// if x = - 1 then
62514: LD_VAR 0 13
62518: PUSH
62519: LD_INT 1
62521: NEG
62522: EQUAL
62523: IFFALSE 62527
// continue ;
62525: GO 62483
// PrepareHuman ( false , i , skill ) ;
62527: LD_INT 0
62529: PPUSH
62530: LD_VAR 0 8
62534: PPUSH
62535: LD_VAR 0 4
62539: PPUSH
62540: CALL_OW 380
// un := CreateHuman ;
62544: LD_ADDR_VAR 0 14
62548: PUSH
62549: CALL_OW 44
62553: ST_TO_ADDR
// PlaceUnitXYR ( un , GetX ( base_dep ) , GetY ( base_dep ) , 10 , false ) ;
62554: LD_VAR 0 14
62558: PPUSH
62559: LD_VAR 0 1
62563: PPUSH
62564: CALL_OW 250
62568: PPUSH
62569: LD_VAR 0 1
62573: PPUSH
62574: CALL_OW 251
62578: PPUSH
62579: LD_INT 10
62581: PPUSH
62582: LD_INT 0
62584: PPUSH
62585: CALL_OW 50
// result := result ^ un ;
62589: LD_ADDR_VAR 0 7
62593: PUSH
62594: LD_VAR 0 7
62598: PUSH
62599: LD_VAR 0 14
62603: ADD
62604: ST_TO_ADDR
// end ;
62605: GO 62483
62607: POP
62608: POP
// end ; end ;
62609: LD_VAR 0 7
62613: RET
// export function GetTurretWeapon ( tower , area ) ; var hex , list , factories , base , i , j , x , y , nat , h , tmp , height , side , fac_list , weapon ; begin
62614: LD_INT 0
62616: PPUSH
62617: PPUSH
62618: PPUSH
62619: PPUSH
62620: PPUSH
62621: PPUSH
62622: PPUSH
62623: PPUSH
62624: PPUSH
62625: PPUSH
62626: PPUSH
62627: PPUSH
62628: PPUSH
62629: PPUSH
62630: PPUSH
62631: PPUSH
// result := false ;
62632: LD_ADDR_VAR 0 3
62636: PUSH
62637: LD_INT 0
62639: ST_TO_ADDR
// if not tower or not GetBType ( tower ) in [ b_bunker , b_turret ] then
62640: LD_VAR 0 1
62644: NOT
62645: PUSH
62646: LD_VAR 0 1
62650: PPUSH
62651: CALL_OW 266
62655: PUSH
62656: LD_INT 32
62658: PUSH
62659: LD_INT 33
62661: PUSH
62662: EMPTY
62663: LIST
62664: LIST
62665: IN
62666: NOT
62667: OR
62668: IFFALSE 62672
// exit ;
62670: GO 63808
// nat := GetNation ( tower ) ;
62672: LD_ADDR_VAR 0 12
62676: PUSH
62677: LD_VAR 0 1
62681: PPUSH
62682: CALL_OW 248
62686: ST_TO_ADDR
// side := GetSide ( tower ) ;
62687: LD_ADDR_VAR 0 16
62691: PUSH
62692: LD_VAR 0 1
62696: PPUSH
62697: CALL_OW 255
62701: ST_TO_ADDR
// x := GetX ( tower ) ;
62702: LD_ADDR_VAR 0 10
62706: PUSH
62707: LD_VAR 0 1
62711: PPUSH
62712: CALL_OW 250
62716: ST_TO_ADDR
// y := GetY ( tower ) ;
62717: LD_ADDR_VAR 0 11
62721: PUSH
62722: LD_VAR 0 1
62726: PPUSH
62727: CALL_OW 251
62731: ST_TO_ADDR
// if not x or not y then
62732: LD_VAR 0 10
62736: NOT
62737: PUSH
62738: LD_VAR 0 11
62742: NOT
62743: OR
62744: IFFALSE 62748
// exit ;
62746: GO 63808
// weapon := 0 ;
62748: LD_ADDR_VAR 0 18
62752: PUSH
62753: LD_INT 0
62755: ST_TO_ADDR
// fac_list := [ ] ;
62756: LD_ADDR_VAR 0 17
62760: PUSH
62761: EMPTY
62762: ST_TO_ADDR
// factories := UnitFilter ( GetBaseBuildings ( GetBase ( tower ) , area ) , [ f_btype , b_factory ] ) ;
62763: LD_ADDR_VAR 0 6
62767: PUSH
62768: LD_VAR 0 1
62772: PPUSH
62773: CALL_OW 274
62777: PPUSH
62778: LD_VAR 0 2
62782: PPUSH
62783: CALL 60386 0 2
62787: PPUSH
62788: LD_INT 30
62790: PUSH
62791: LD_INT 3
62793: PUSH
62794: EMPTY
62795: LIST
62796: LIST
62797: PPUSH
62798: CALL_OW 72
62802: ST_TO_ADDR
// if not factories then
62803: LD_VAR 0 6
62807: NOT
62808: IFFALSE 62812
// exit ;
62810: GO 63808
// for i in factories do
62812: LD_ADDR_VAR 0 8
62816: PUSH
62817: LD_VAR 0 6
62821: PUSH
62822: FOR_IN
62823: IFFALSE 62848
// fac_list := fac_list union AvailableWeaponList ( i ) ;
62825: LD_ADDR_VAR 0 17
62829: PUSH
62830: LD_VAR 0 17
62834: PUSH
62835: LD_VAR 0 8
62839: PPUSH
62840: CALL_OW 478
62844: UNION
62845: ST_TO_ADDR
62846: GO 62822
62848: POP
62849: POP
// if not fac_list then
62850: LD_VAR 0 17
62854: NOT
62855: IFFALSE 62859
// exit ;
62857: GO 63808
// list := [ [ us_gatling_gun , us_double_gun , us_laser , us_double_laser , us_heavy_gun , us_rocket_launcher , us_radar ] , [ ar_gun , ar_rocket_launcher , ar_flame_thrower , ar_radar ] , [ ru_gatling_gun , ru_gun , ru_heavy_gun , ru_rocket_launcher , ru_rocket , ru_time_lapser ] ] [ nat ] ;
62859: LD_ADDR_VAR 0 5
62863: PUSH
62864: LD_INT 4
62866: PUSH
62867: LD_INT 5
62869: PUSH
62870: LD_INT 9
62872: PUSH
62873: LD_INT 10
62875: PUSH
62876: LD_INT 6
62878: PUSH
62879: LD_INT 7
62881: PUSH
62882: LD_INT 11
62884: PUSH
62885: EMPTY
62886: LIST
62887: LIST
62888: LIST
62889: LIST
62890: LIST
62891: LIST
62892: LIST
62893: PUSH
62894: LD_INT 27
62896: PUSH
62897: LD_INT 28
62899: PUSH
62900: LD_INT 26
62902: PUSH
62903: LD_INT 30
62905: PUSH
62906: EMPTY
62907: LIST
62908: LIST
62909: LIST
62910: LIST
62911: PUSH
62912: LD_INT 43
62914: PUSH
62915: LD_INT 44
62917: PUSH
62918: LD_INT 46
62920: PUSH
62921: LD_INT 45
62923: PUSH
62924: LD_INT 47
62926: PUSH
62927: LD_INT 49
62929: PUSH
62930: EMPTY
62931: LIST
62932: LIST
62933: LIST
62934: LIST
62935: LIST
62936: LIST
62937: PUSH
62938: EMPTY
62939: LIST
62940: LIST
62941: LIST
62942: PUSH
62943: LD_VAR 0 12
62947: ARRAY
62948: ST_TO_ADDR
// for i in list do
62949: LD_ADDR_VAR 0 8
62953: PUSH
62954: LD_VAR 0 5
62958: PUSH
62959: FOR_IN
62960: IFFALSE 62993
// if not i in fac_list then
62962: LD_VAR 0 8
62966: PUSH
62967: LD_VAR 0 17
62971: IN
62972: NOT
62973: IFFALSE 62991
// list := list diff i ;
62975: LD_ADDR_VAR 0 5
62979: PUSH
62980: LD_VAR 0 5
62984: PUSH
62985: LD_VAR 0 8
62989: DIFF
62990: ST_TO_ADDR
62991: GO 62959
62993: POP
62994: POP
// if not list then
62995: LD_VAR 0 5
62999: NOT
63000: IFFALSE 63004
// exit ;
63002: GO 63808
// if nat = nation_russian and ru_time_lapser in list and GetTech ( tech_lapser , side ) = state_researched then
63004: LD_VAR 0 12
63008: PUSH
63009: LD_INT 3
63011: EQUAL
63012: PUSH
63013: LD_INT 49
63015: PUSH
63016: LD_VAR 0 5
63020: IN
63021: AND
63022: PUSH
63023: LD_INT 31
63025: PPUSH
63026: LD_VAR 0 16
63030: PPUSH
63031: CALL_OW 321
63035: PUSH
63036: LD_INT 2
63038: EQUAL
63039: AND
63040: IFFALSE 63100
// begin if not FilterAllUnits ( [ [ f_side , side ] , [ f_bweapon , ru_time_lapser ] , [ f_dist , tower , 10 ] ] ) then
63042: LD_INT 22
63044: PUSH
63045: LD_VAR 0 16
63049: PUSH
63050: EMPTY
63051: LIST
63052: LIST
63053: PUSH
63054: LD_INT 35
63056: PUSH
63057: LD_INT 49
63059: PUSH
63060: EMPTY
63061: LIST
63062: LIST
63063: PUSH
63064: LD_INT 91
63066: PUSH
63067: LD_VAR 0 1
63071: PUSH
63072: LD_INT 10
63074: PUSH
63075: EMPTY
63076: LIST
63077: LIST
63078: LIST
63079: PUSH
63080: EMPTY
63081: LIST
63082: LIST
63083: LIST
63084: PPUSH
63085: CALL_OW 69
63089: NOT
63090: IFFALSE 63100
// weapon := ru_time_lapser ;
63092: LD_ADDR_VAR 0 18
63096: PUSH
63097: LD_INT 49
63099: ST_TO_ADDR
// end ; if nat in [ 1 , 2 ] and ( us_radar in list or ar_radar in list ) and GetTech ( tech_radar , side ) = state_researched then
63100: LD_VAR 0 12
63104: PUSH
63105: LD_INT 1
63107: PUSH
63108: LD_INT 2
63110: PUSH
63111: EMPTY
63112: LIST
63113: LIST
63114: IN
63115: PUSH
63116: LD_INT 11
63118: PUSH
63119: LD_VAR 0 5
63123: IN
63124: PUSH
63125: LD_INT 30
63127: PUSH
63128: LD_VAR 0 5
63132: IN
63133: OR
63134: AND
63135: PUSH
63136: LD_INT 6
63138: PPUSH
63139: LD_VAR 0 16
63143: PPUSH
63144: CALL_OW 321
63148: PUSH
63149: LD_INT 2
63151: EQUAL
63152: AND
63153: IFFALSE 63318
// begin if not FilterAllUnits ( [ [ f_side , side ] , [ f_or , [ f_bweapon , us_radar ] , [ f_bweapon , ar_radar ] ] , [ f_dist , tower , 18 ] ] ) and FilterAllUnits ( [ [ [ f_side , side ] , [ f_or , [ f_btype , b_bunker ] , [ f_btype , b_turret ] ] , [ f_dist , tower , 12 ] ] ] ) > 2 then
63155: LD_INT 22
63157: PUSH
63158: LD_VAR 0 16
63162: PUSH
63163: EMPTY
63164: LIST
63165: LIST
63166: PUSH
63167: LD_INT 2
63169: PUSH
63170: LD_INT 35
63172: PUSH
63173: LD_INT 11
63175: PUSH
63176: EMPTY
63177: LIST
63178: LIST
63179: PUSH
63180: LD_INT 35
63182: PUSH
63183: LD_INT 30
63185: PUSH
63186: EMPTY
63187: LIST
63188: LIST
63189: PUSH
63190: EMPTY
63191: LIST
63192: LIST
63193: LIST
63194: PUSH
63195: LD_INT 91
63197: PUSH
63198: LD_VAR 0 1
63202: PUSH
63203: LD_INT 18
63205: PUSH
63206: EMPTY
63207: LIST
63208: LIST
63209: LIST
63210: PUSH
63211: EMPTY
63212: LIST
63213: LIST
63214: LIST
63215: PPUSH
63216: CALL_OW 69
63220: NOT
63221: PUSH
63222: LD_INT 22
63224: PUSH
63225: LD_VAR 0 16
63229: PUSH
63230: EMPTY
63231: LIST
63232: LIST
63233: PUSH
63234: LD_INT 2
63236: PUSH
63237: LD_INT 30
63239: PUSH
63240: LD_INT 32
63242: PUSH
63243: EMPTY
63244: LIST
63245: LIST
63246: PUSH
63247: LD_INT 30
63249: PUSH
63250: LD_INT 33
63252: PUSH
63253: EMPTY
63254: LIST
63255: LIST
63256: PUSH
63257: EMPTY
63258: LIST
63259: LIST
63260: LIST
63261: PUSH
63262: LD_INT 91
63264: PUSH
63265: LD_VAR 0 1
63269: PUSH
63270: LD_INT 12
63272: PUSH
63273: EMPTY
63274: LIST
63275: LIST
63276: LIST
63277: PUSH
63278: EMPTY
63279: LIST
63280: LIST
63281: LIST
63282: PUSH
63283: EMPTY
63284: LIST
63285: PPUSH
63286: CALL_OW 69
63290: PUSH
63291: LD_INT 2
63293: GREATER
63294: AND
63295: IFFALSE 63318
// weapon := [ us_radar , ar_radar ] [ nat ] ;
63297: LD_ADDR_VAR 0 18
63301: PUSH
63302: LD_INT 11
63304: PUSH
63305: LD_INT 30
63307: PUSH
63308: EMPTY
63309: LIST
63310: LIST
63311: PUSH
63312: LD_VAR 0 12
63316: ARRAY
63317: ST_TO_ADDR
// end ; if not weapon and GetTech ( tech_rocket , side ) = state_researched and ( us_rocket_launcher in list or ar_rocket_launcher in list or ru_rocket_launcher in list ) then
63318: LD_VAR 0 18
63322: NOT
63323: PUSH
63324: LD_INT 40
63326: PPUSH
63327: LD_VAR 0 16
63331: PPUSH
63332: CALL_OW 321
63336: PUSH
63337: LD_INT 2
63339: EQUAL
63340: AND
63341: PUSH
63342: LD_INT 7
63344: PUSH
63345: LD_VAR 0 5
63349: IN
63350: PUSH
63351: LD_INT 28
63353: PUSH
63354: LD_VAR 0 5
63358: IN
63359: OR
63360: PUSH
63361: LD_INT 45
63363: PUSH
63364: LD_VAR 0 5
63368: IN
63369: OR
63370: AND
63371: IFFALSE 63625
// begin hex := GetHexInfo ( x , y ) ;
63373: LD_ADDR_VAR 0 4
63377: PUSH
63378: LD_VAR 0 10
63382: PPUSH
63383: LD_VAR 0 11
63387: PPUSH
63388: CALL_OW 546
63392: ST_TO_ADDR
// if hex [ 1 ] then
63393: LD_VAR 0 4
63397: PUSH
63398: LD_INT 1
63400: ARRAY
63401: IFFALSE 63405
// exit ;
63403: GO 63808
// height := hex [ 2 ] ;
63405: LD_ADDR_VAR 0 15
63409: PUSH
63410: LD_VAR 0 4
63414: PUSH
63415: LD_INT 2
63417: ARRAY
63418: ST_TO_ADDR
// tmp := [ 0 , 2 , 3 , 5 ] ;
63419: LD_ADDR_VAR 0 14
63423: PUSH
63424: LD_INT 0
63426: PUSH
63427: LD_INT 2
63429: PUSH
63430: LD_INT 3
63432: PUSH
63433: LD_INT 5
63435: PUSH
63436: EMPTY
63437: LIST
63438: LIST
63439: LIST
63440: LIST
63441: ST_TO_ADDR
// for i in tmp do
63442: LD_ADDR_VAR 0 8
63446: PUSH
63447: LD_VAR 0 14
63451: PUSH
63452: FOR_IN
63453: IFFALSE 63623
// begin j := [ ShiftX ( x , i , 5 ) , ShiftY ( y , i , 5 ) ] ;
63455: LD_ADDR_VAR 0 9
63459: PUSH
63460: LD_VAR 0 10
63464: PPUSH
63465: LD_VAR 0 8
63469: PPUSH
63470: LD_INT 5
63472: PPUSH
63473: CALL_OW 272
63477: PUSH
63478: LD_VAR 0 11
63482: PPUSH
63483: LD_VAR 0 8
63487: PPUSH
63488: LD_INT 5
63490: PPUSH
63491: CALL_OW 273
63495: PUSH
63496: EMPTY
63497: LIST
63498: LIST
63499: ST_TO_ADDR
// if ValidHex ( j [ 1 ] , j [ 2 ] ) then
63500: LD_VAR 0 9
63504: PUSH
63505: LD_INT 1
63507: ARRAY
63508: PPUSH
63509: LD_VAR 0 9
63513: PUSH
63514: LD_INT 2
63516: ARRAY
63517: PPUSH
63518: CALL_OW 488
63522: IFFALSE 63621
// begin hex := GetHexInfo ( j [ 1 ] , j [ 2 ] ) ;
63524: LD_ADDR_VAR 0 4
63528: PUSH
63529: LD_VAR 0 9
63533: PUSH
63534: LD_INT 1
63536: ARRAY
63537: PPUSH
63538: LD_VAR 0 9
63542: PUSH
63543: LD_INT 2
63545: ARRAY
63546: PPUSH
63547: CALL_OW 546
63551: ST_TO_ADDR
// if hex [ 1 ] then
63552: LD_VAR 0 4
63556: PUSH
63557: LD_INT 1
63559: ARRAY
63560: IFFALSE 63564
// continue ;
63562: GO 63452
// h := hex [ 2 ] ;
63564: LD_ADDR_VAR 0 13
63568: PUSH
63569: LD_VAR 0 4
63573: PUSH
63574: LD_INT 2
63576: ARRAY
63577: ST_TO_ADDR
// if h + 7 < height then
63578: LD_VAR 0 13
63582: PUSH
63583: LD_INT 7
63585: PLUS
63586: PUSH
63587: LD_VAR 0 15
63591: LESS
63592: IFFALSE 63621
// begin weapon := [ us_rocket_launcher , ar_rocket_launcher , ru_rocket_launcher ] [ nat ] ;
63594: LD_ADDR_VAR 0 18
63598: PUSH
63599: LD_INT 7
63601: PUSH
63602: LD_INT 28
63604: PUSH
63605: LD_INT 45
63607: PUSH
63608: EMPTY
63609: LIST
63610: LIST
63611: LIST
63612: PUSH
63613: LD_VAR 0 12
63617: ARRAY
63618: ST_TO_ADDR
// break ;
63619: GO 63623
// end ; end ; end ;
63621: GO 63452
63623: POP
63624: POP
// end ; if not weapon then
63625: LD_VAR 0 18
63629: NOT
63630: IFFALSE 63690
// begin list := list diff [ us_radar , ar_radar , ru_time_lapser ] ;
63632: LD_ADDR_VAR 0 5
63636: PUSH
63637: LD_VAR 0 5
63641: PUSH
63642: LD_INT 11
63644: PUSH
63645: LD_INT 30
63647: PUSH
63648: LD_INT 49
63650: PUSH
63651: EMPTY
63652: LIST
63653: LIST
63654: LIST
63655: DIFF
63656: ST_TO_ADDR
// if not list then
63657: LD_VAR 0 5
63661: NOT
63662: IFFALSE 63666
// exit ;
63664: GO 63808
// weapon := list [ rand ( 1 , list ) ] ;
63666: LD_ADDR_VAR 0 18
63670: PUSH
63671: LD_VAR 0 5
63675: PUSH
63676: LD_INT 1
63678: PPUSH
63679: LD_VAR 0 5
63683: PPUSH
63684: CALL_OW 12
63688: ARRAY
63689: ST_TO_ADDR
// end ; if weapon then
63690: LD_VAR 0 18
63694: IFFALSE 63808
// begin tmp := CostOfWeapon ( weapon ) ;
63696: LD_ADDR_VAR 0 14
63700: PUSH
63701: LD_VAR 0 18
63705: PPUSH
63706: CALL_OW 451
63710: ST_TO_ADDR
// j := GetBase ( tower ) ;
63711: LD_ADDR_VAR 0 9
63715: PUSH
63716: LD_VAR 0 1
63720: PPUSH
63721: CALL_OW 274
63725: ST_TO_ADDR
// if GetResourceType ( j , mat_cans ) >= tmp [ 1 ] and GetResourceType ( j , mat_oil ) >= tmp [ 2 ] and GetResourceType ( j , mat_siberit ) >= tmp [ 3 ] then
63726: LD_VAR 0 9
63730: PPUSH
63731: LD_INT 1
63733: PPUSH
63734: CALL_OW 275
63738: PUSH
63739: LD_VAR 0 14
63743: PUSH
63744: LD_INT 1
63746: ARRAY
63747: GREATEREQUAL
63748: PUSH
63749: LD_VAR 0 9
63753: PPUSH
63754: LD_INT 2
63756: PPUSH
63757: CALL_OW 275
63761: PUSH
63762: LD_VAR 0 14
63766: PUSH
63767: LD_INT 2
63769: ARRAY
63770: GREATEREQUAL
63771: AND
63772: PUSH
63773: LD_VAR 0 9
63777: PPUSH
63778: LD_INT 3
63780: PPUSH
63781: CALL_OW 275
63785: PUSH
63786: LD_VAR 0 14
63790: PUSH
63791: LD_INT 3
63793: ARRAY
63794: GREATEREQUAL
63795: AND
63796: IFFALSE 63808
// result := weapon ;
63798: LD_ADDR_VAR 0 3
63802: PUSH
63803: LD_VAR 0 18
63807: ST_TO_ADDR
// end ; end ;
63808: LD_VAR 0 3
63812: RET
// export function CompareArray ( array1 , array2 ) ; var i ; begin
63813: LD_INT 0
63815: PPUSH
63816: PPUSH
// result := true ;
63817: LD_ADDR_VAR 0 3
63821: PUSH
63822: LD_INT 1
63824: ST_TO_ADDR
// if array1 = array2 then
63825: LD_VAR 0 1
63829: PUSH
63830: LD_VAR 0 2
63834: EQUAL
63835: IFFALSE 63895
// begin for i = 1 to array1 do
63837: LD_ADDR_VAR 0 4
63841: PUSH
63842: DOUBLE
63843: LD_INT 1
63845: DEC
63846: ST_TO_ADDR
63847: LD_VAR 0 1
63851: PUSH
63852: FOR_TO
63853: IFFALSE 63891
// if array1 [ i ] <> array2 [ i ] then
63855: LD_VAR 0 1
63859: PUSH
63860: LD_VAR 0 4
63864: ARRAY
63865: PUSH
63866: LD_VAR 0 2
63870: PUSH
63871: LD_VAR 0 4
63875: ARRAY
63876: NONEQUAL
63877: IFFALSE 63889
// begin result := false ;
63879: LD_ADDR_VAR 0 3
63883: PUSH
63884: LD_INT 0
63886: ST_TO_ADDR
// break ;
63887: GO 63891
// end ;
63889: GO 63852
63891: POP
63892: POP
// end else
63893: GO 63903
// result := false ;
63895: LD_ADDR_VAR 0 3
63899: PUSH
63900: LD_INT 0
63902: ST_TO_ADDR
// end ;
63903: LD_VAR 0 3
63907: RET
// export function VehicleCost ( fac , list ) ; var cost , pom ; begin
63908: LD_INT 0
63910: PPUSH
63911: PPUSH
63912: PPUSH
// pom := GetBase ( fac ) ;
63913: LD_ADDR_VAR 0 5
63917: PUSH
63918: LD_VAR 0 1
63922: PPUSH
63923: CALL_OW 274
63927: ST_TO_ADDR
// cost := CostOfVehicle ( list [ 1 ] , list [ 2 ] , list [ 3 ] , list [ 4 ] ) ;
63928: LD_ADDR_VAR 0 4
63932: PUSH
63933: LD_VAR 0 2
63937: PUSH
63938: LD_INT 1
63940: ARRAY
63941: PPUSH
63942: LD_VAR 0 2
63946: PUSH
63947: LD_INT 2
63949: ARRAY
63950: PPUSH
63951: LD_VAR 0 2
63955: PUSH
63956: LD_INT 3
63958: ARRAY
63959: PPUSH
63960: LD_VAR 0 2
63964: PUSH
63965: LD_INT 4
63967: ARRAY
63968: PPUSH
63969: CALL_OW 449
63973: ST_TO_ADDR
// result := GetResourceType ( pom , mat_cans ) >= cost [ 1 ] and GetResourceType ( pom , mat_oil ) >= cost [ 2 ] and GetResourceType ( pom , mat_siberit ) >= cost [ 3 ] ;
63974: LD_ADDR_VAR 0 3
63978: PUSH
63979: LD_VAR 0 5
63983: PPUSH
63984: LD_INT 1
63986: PPUSH
63987: CALL_OW 275
63991: PUSH
63992: LD_VAR 0 4
63996: PUSH
63997: LD_INT 1
63999: ARRAY
64000: GREATEREQUAL
64001: PUSH
64002: LD_VAR 0 5
64006: PPUSH
64007: LD_INT 2
64009: PPUSH
64010: CALL_OW 275
64014: PUSH
64015: LD_VAR 0 4
64019: PUSH
64020: LD_INT 2
64022: ARRAY
64023: GREATEREQUAL
64024: AND
64025: PUSH
64026: LD_VAR 0 5
64030: PPUSH
64031: LD_INT 3
64033: PPUSH
64034: CALL_OW 275
64038: PUSH
64039: LD_VAR 0 4
64043: PUSH
64044: LD_INT 3
64046: ARRAY
64047: GREATEREQUAL
64048: AND
64049: ST_TO_ADDR
// end ;
64050: LD_VAR 0 3
64054: RET
// export function UpgradeCost ( building ) ; var pom , cost , btype ; begin
64055: LD_INT 0
64057: PPUSH
64058: PPUSH
64059: PPUSH
64060: PPUSH
// pom := GetBase ( building ) ;
64061: LD_ADDR_VAR 0 3
64065: PUSH
64066: LD_VAR 0 1
64070: PPUSH
64071: CALL_OW 274
64075: ST_TO_ADDR
// if not pom then
64076: LD_VAR 0 3
64080: NOT
64081: IFFALSE 64085
// exit ;
64083: GO 64255
// btype := GetBType ( building ) ;
64085: LD_ADDR_VAR 0 5
64089: PUSH
64090: LD_VAR 0 1
64094: PPUSH
64095: CALL_OW 266
64099: ST_TO_ADDR
// if btype = b_armoury then
64100: LD_VAR 0 5
64104: PUSH
64105: LD_INT 4
64107: EQUAL
64108: IFFALSE 64118
// btype := b_barracks ;
64110: LD_ADDR_VAR 0 5
64114: PUSH
64115: LD_INT 5
64117: ST_TO_ADDR
// if btype = b_depot then
64118: LD_VAR 0 5
64122: PUSH
64123: LD_INT 0
64125: EQUAL
64126: IFFALSE 64136
// btype := b_warehouse ;
64128: LD_ADDR_VAR 0 5
64132: PUSH
64133: LD_INT 1
64135: ST_TO_ADDR
// if btype = b_workshop then
64136: LD_VAR 0 5
64140: PUSH
64141: LD_INT 2
64143: EQUAL
64144: IFFALSE 64154
// btype := b_factory ;
64146: LD_ADDR_VAR 0 5
64150: PUSH
64151: LD_INT 3
64153: ST_TO_ADDR
// cost := CostOfBuilding ( btype , GetNation ( building ) ) ;
64154: LD_ADDR_VAR 0 4
64158: PUSH
64159: LD_VAR 0 5
64163: PPUSH
64164: LD_VAR 0 1
64168: PPUSH
64169: CALL_OW 248
64173: PPUSH
64174: CALL_OW 450
64178: ST_TO_ADDR
// result := GetResourceType ( pom , mat_cans ) >= cost [ 1 ] and GetResourceType ( pom , mat_oil ) >= cost [ 2 ] and GetResourceType ( pom , mat_siberit ) >= cost [ 3 ] ;
64179: LD_ADDR_VAR 0 2
64183: PUSH
64184: LD_VAR 0 3
64188: PPUSH
64189: LD_INT 1
64191: PPUSH
64192: CALL_OW 275
64196: PUSH
64197: LD_VAR 0 4
64201: PUSH
64202: LD_INT 1
64204: ARRAY
64205: GREATEREQUAL
64206: PUSH
64207: LD_VAR 0 3
64211: PPUSH
64212: LD_INT 2
64214: PPUSH
64215: CALL_OW 275
64219: PUSH
64220: LD_VAR 0 4
64224: PUSH
64225: LD_INT 2
64227: ARRAY
64228: GREATEREQUAL
64229: AND
64230: PUSH
64231: LD_VAR 0 3
64235: PPUSH
64236: LD_INT 3
64238: PPUSH
64239: CALL_OW 275
64243: PUSH
64244: LD_VAR 0 4
64248: PUSH
64249: LD_INT 3
64251: ARRAY
64252: GREATEREQUAL
64253: AND
64254: ST_TO_ADDR
// end ;
64255: LD_VAR 0 2
64259: RET
// export function UpgradeLabCost ( building , btype ) ; var pom , cost ; begin
64260: LD_INT 0
64262: PPUSH
64263: PPUSH
64264: PPUSH
// pom := GetBase ( building ) ;
64265: LD_ADDR_VAR 0 4
64269: PUSH
64270: LD_VAR 0 1
64274: PPUSH
64275: CALL_OW 274
64279: ST_TO_ADDR
// if not pom then
64280: LD_VAR 0 4
64284: NOT
64285: IFFALSE 64289
// exit ;
64287: GO 64390
// cost := CostOfBuilding ( btype , GetNation ( building ) ) ;
64289: LD_ADDR_VAR 0 5
64293: PUSH
64294: LD_VAR 0 2
64298: PPUSH
64299: LD_VAR 0 1
64303: PPUSH
64304: CALL_OW 248
64308: PPUSH
64309: CALL_OW 450
64313: ST_TO_ADDR
// result := GetResourceType ( pom , mat_cans ) >= cost [ 1 ] and GetResourceType ( pom , mat_oil ) >= cost [ 2 ] and GetResourceType ( pom , mat_siberit ) >= cost [ 3 ] ;
64314: LD_ADDR_VAR 0 3
64318: PUSH
64319: LD_VAR 0 4
64323: PPUSH
64324: LD_INT 1
64326: PPUSH
64327: CALL_OW 275
64331: PUSH
64332: LD_VAR 0 5
64336: PUSH
64337: LD_INT 1
64339: ARRAY
64340: GREATEREQUAL
64341: PUSH
64342: LD_VAR 0 4
64346: PPUSH
64347: LD_INT 2
64349: PPUSH
64350: CALL_OW 275
64354: PUSH
64355: LD_VAR 0 5
64359: PUSH
64360: LD_INT 2
64362: ARRAY
64363: GREATEREQUAL
64364: AND
64365: PUSH
64366: LD_VAR 0 4
64370: PPUSH
64371: LD_INT 3
64373: PPUSH
64374: CALL_OW 275
64378: PUSH
64379: LD_VAR 0 5
64383: PUSH
64384: LD_INT 3
64386: ARRAY
64387: GREATEREQUAL
64388: AND
64389: ST_TO_ADDR
// end ;
64390: LD_VAR 0 3
64394: RET
// export function TryClearPlaceForBuilding ( base , btype , x , y , d ) ; var i , j , _x , _y , tmp , hexes , r , xy , dep ; begin
64395: LD_INT 0
64397: PPUSH
64398: PPUSH
64399: PPUSH
64400: PPUSH
64401: PPUSH
64402: PPUSH
64403: PPUSH
64404: PPUSH
64405: PPUSH
64406: PPUSH
// result := false ;
64407: LD_ADDR_VAR 0 6
64411: PUSH
64412: LD_INT 0
64414: ST_TO_ADDR
// if not base or not btype or not x or not y then
64415: LD_VAR 0 1
64419: NOT
64420: PUSH
64421: LD_VAR 0 2
64425: NOT
64426: OR
64427: PUSH
64428: LD_VAR 0 3
64432: NOT
64433: OR
64434: PUSH
64435: LD_VAR 0 4
64439: NOT
64440: OR
64441: IFFALSE 64445
// exit ;
64443: GO 65054
// hexes := GetBuildingHexes ( btype , x , y , d , GetNation ( base [ 1 ] ) , 0 ) ;
64445: LD_ADDR_VAR 0 12
64449: PUSH
64450: LD_VAR 0 2
64454: PPUSH
64455: LD_VAR 0 3
64459: PPUSH
64460: LD_VAR 0 4
64464: PPUSH
64465: LD_VAR 0 5
64469: PPUSH
64470: LD_VAR 0 1
64474: PUSH
64475: LD_INT 1
64477: ARRAY
64478: PPUSH
64479: CALL_OW 248
64483: PPUSH
64484: LD_INT 0
64486: PPUSH
64487: CALL 65891 0 6
64491: ST_TO_ADDR
// if not hexes then
64492: LD_VAR 0 12
64496: NOT
64497: IFFALSE 64501
// exit ;
64499: GO 65054
// for i = 1 to hexes do
64501: LD_ADDR_VAR 0 7
64505: PUSH
64506: DOUBLE
64507: LD_INT 1
64509: DEC
64510: ST_TO_ADDR
64511: LD_VAR 0 12
64515: PUSH
64516: FOR_TO
64517: IFFALSE 65052
// begin tmp := HexInfo ( hexes [ i ] [ 1 ] , hexes [ i ] [ 2 ] ) ;
64519: LD_ADDR_VAR 0 11
64523: PUSH
64524: LD_VAR 0 12
64528: PUSH
64529: LD_VAR 0 7
64533: ARRAY
64534: PUSH
64535: LD_INT 1
64537: ARRAY
64538: PPUSH
64539: LD_VAR 0 12
64543: PUSH
64544: LD_VAR 0 7
64548: ARRAY
64549: PUSH
64550: LD_INT 2
64552: ARRAY
64553: PPUSH
64554: CALL_OW 428
64558: ST_TO_ADDR
// if IsEnvironment ( hexes [ i ] [ 1 ] , hexes [ i ] [ 2 ] ) or not ValidHex ( hexes [ i ] [ 1 ] , hexes [ i ] [ 2 ] ) or GetType ( tmp ) = unit_building then
64559: LD_VAR 0 12
64563: PUSH
64564: LD_VAR 0 7
64568: ARRAY
64569: PUSH
64570: LD_INT 1
64572: ARRAY
64573: PPUSH
64574: LD_VAR 0 12
64578: PUSH
64579: LD_VAR 0 7
64583: ARRAY
64584: PUSH
64585: LD_INT 2
64587: ARRAY
64588: PPUSH
64589: CALL_OW 351
64593: PUSH
64594: LD_VAR 0 12
64598: PUSH
64599: LD_VAR 0 7
64603: ARRAY
64604: PUSH
64605: LD_INT 1
64607: ARRAY
64608: PPUSH
64609: LD_VAR 0 12
64613: PUSH
64614: LD_VAR 0 7
64618: ARRAY
64619: PUSH
64620: LD_INT 2
64622: ARRAY
64623: PPUSH
64624: CALL_OW 488
64628: NOT
64629: OR
64630: PUSH
64631: LD_VAR 0 11
64635: PPUSH
64636: CALL_OW 247
64640: PUSH
64641: LD_INT 3
64643: EQUAL
64644: OR
64645: IFFALSE 64651
// exit ;
64647: POP
64648: POP
64649: GO 65054
// if not tmp or not tmp in base then
64651: LD_VAR 0 11
64655: NOT
64656: PUSH
64657: LD_VAR 0 11
64661: PUSH
64662: LD_VAR 0 1
64666: IN
64667: NOT
64668: OR
64669: IFFALSE 64673
// continue ;
64671: GO 64516
// result := true ;
64673: LD_ADDR_VAR 0 6
64677: PUSH
64678: LD_INT 1
64680: ST_TO_ADDR
// dep := UnitFilter ( base , [ [ f_side , GetSide ( tmp ) ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ] ) ;
64681: LD_ADDR_VAR 0 15
64685: PUSH
64686: LD_VAR 0 1
64690: PPUSH
64691: LD_INT 22
64693: PUSH
64694: LD_VAR 0 11
64698: PPUSH
64699: CALL_OW 255
64703: PUSH
64704: EMPTY
64705: LIST
64706: LIST
64707: PUSH
64708: LD_INT 2
64710: PUSH
64711: LD_INT 30
64713: PUSH
64714: LD_INT 0
64716: PUSH
64717: EMPTY
64718: LIST
64719: LIST
64720: PUSH
64721: LD_INT 30
64723: PUSH
64724: LD_INT 1
64726: PUSH
64727: EMPTY
64728: LIST
64729: LIST
64730: PUSH
64731: EMPTY
64732: LIST
64733: LIST
64734: LIST
64735: PUSH
64736: EMPTY
64737: LIST
64738: LIST
64739: PPUSH
64740: CALL_OW 72
64744: ST_TO_ADDR
// if dep then
64745: LD_VAR 0 15
64749: IFFALSE 64885
// begin xy := [ ShiftX ( GetX ( dep [ 1 ] ) , GetDir ( dep [ 1 ] ) , 5 ) , ShiftY ( GetY ( dep [ 1 ] ) , GetDir ( dep [ 1 ] ) , 5 ) ] ;
64751: LD_ADDR_VAR 0 14
64755: PUSH
64756: LD_VAR 0 15
64760: PUSH
64761: LD_INT 1
64763: ARRAY
64764: PPUSH
64765: CALL_OW 250
64769: PPUSH
64770: LD_VAR 0 15
64774: PUSH
64775: LD_INT 1
64777: ARRAY
64778: PPUSH
64779: CALL_OW 254
64783: PPUSH
64784: LD_INT 5
64786: PPUSH
64787: CALL_OW 272
64791: PUSH
64792: LD_VAR 0 15
64796: PUSH
64797: LD_INT 1
64799: ARRAY
64800: PPUSH
64801: CALL_OW 251
64805: PPUSH
64806: LD_VAR 0 15
64810: PUSH
64811: LD_INT 1
64813: ARRAY
64814: PPUSH
64815: CALL_OW 254
64819: PPUSH
64820: LD_INT 5
64822: PPUSH
64823: CALL_OW 273
64827: PUSH
64828: EMPTY
64829: LIST
64830: LIST
64831: ST_TO_ADDR
// if ValidHex ( xy [ 1 ] , xy [ 2 ] ) then
64832: LD_VAR 0 14
64836: PUSH
64837: LD_INT 1
64839: ARRAY
64840: PPUSH
64841: LD_VAR 0 14
64845: PUSH
64846: LD_INT 2
64848: ARRAY
64849: PPUSH
64850: CALL_OW 488
64854: IFFALSE 64885
// begin ComMoveXY ( tmp , xy [ 1 ] , xy [ 2 ] ) ;
64856: LD_VAR 0 11
64860: PPUSH
64861: LD_VAR 0 14
64865: PUSH
64866: LD_INT 1
64868: ARRAY
64869: PPUSH
64870: LD_VAR 0 14
64874: PUSH
64875: LD_INT 2
64877: ARRAY
64878: PPUSH
64879: CALL_OW 111
// continue ;
64883: GO 64516
// end ; end ; r := GetDir ( tmp ) ;
64885: LD_ADDR_VAR 0 13
64889: PUSH
64890: LD_VAR 0 11
64894: PPUSH
64895: CALL_OW 254
64899: ST_TO_ADDR
// if r = 5 then
64900: LD_VAR 0 13
64904: PUSH
64905: LD_INT 5
64907: EQUAL
64908: IFFALSE 64918
// r := 0 ;
64910: LD_ADDR_VAR 0 13
64914: PUSH
64915: LD_INT 0
64917: ST_TO_ADDR
// for j = r to 5 do
64918: LD_ADDR_VAR 0 8
64922: PUSH
64923: DOUBLE
64924: LD_VAR 0 13
64928: DEC
64929: ST_TO_ADDR
64930: LD_INT 5
64932: PUSH
64933: FOR_TO
64934: IFFALSE 65048
// begin _x := ShiftX ( GetX ( tmp ) , j , 2 ) ;
64936: LD_ADDR_VAR 0 9
64940: PUSH
64941: LD_VAR 0 11
64945: PPUSH
64946: CALL_OW 250
64950: PPUSH
64951: LD_VAR 0 8
64955: PPUSH
64956: LD_INT 2
64958: PPUSH
64959: CALL_OW 272
64963: ST_TO_ADDR
// _y := ShiftY ( GetY ( tmp ) , j , 2 ) ;
64964: LD_ADDR_VAR 0 10
64968: PUSH
64969: LD_VAR 0 11
64973: PPUSH
64974: CALL_OW 251
64978: PPUSH
64979: LD_VAR 0 8
64983: PPUSH
64984: LD_INT 2
64986: PPUSH
64987: CALL_OW 273
64991: ST_TO_ADDR
// if ValidHex ( _x , _y ) and not HexInfo ( _x , _y ) then
64992: LD_VAR 0 9
64996: PPUSH
64997: LD_VAR 0 10
65001: PPUSH
65002: CALL_OW 488
65006: PUSH
65007: LD_VAR 0 9
65011: PPUSH
65012: LD_VAR 0 10
65016: PPUSH
65017: CALL_OW 428
65021: NOT
65022: AND
65023: IFFALSE 65046
// begin ComMoveXY ( tmp , _x , _y ) ;
65025: LD_VAR 0 11
65029: PPUSH
65030: LD_VAR 0 9
65034: PPUSH
65035: LD_VAR 0 10
65039: PPUSH
65040: CALL_OW 111
// break ;
65044: GO 65048
// end ; end ;
65046: GO 64933
65048: POP
65049: POP
// end ;
65050: GO 64516
65052: POP
65053: POP
// end ;
65054: LD_VAR 0 6
65058: RET
// export function CanBeBuilt ( depot , btype , x , y , d ) ; var i , j , side , pom , cost , hexes , height , dist , hex ; begin
65059: LD_INT 0
65061: PPUSH
65062: PPUSH
65063: PPUSH
65064: PPUSH
65065: PPUSH
65066: PPUSH
65067: PPUSH
65068: PPUSH
65069: PPUSH
65070: PPUSH
// result := false ;
65071: LD_ADDR_VAR 0 6
65075: PUSH
65076: LD_INT 0
65078: ST_TO_ADDR
// if not depot or not GetBType ( depot ) in [ b_depot , b_warehouse ] or not btype or not d in [ 0 , 1 , 2 , 3 , 4 , 5 ] or not ValidHex ( x , y ) then
65079: LD_VAR 0 1
65083: NOT
65084: PUSH
65085: LD_VAR 0 1
65089: PPUSH
65090: CALL_OW 266
65094: PUSH
65095: LD_INT 0
65097: PUSH
65098: LD_INT 1
65100: PUSH
65101: EMPTY
65102: LIST
65103: LIST
65104: IN
65105: NOT
65106: OR
65107: PUSH
65108: LD_VAR 0 2
65112: NOT
65113: OR
65114: PUSH
65115: LD_VAR 0 5
65119: PUSH
65120: LD_INT 0
65122: PUSH
65123: LD_INT 1
65125: PUSH
65126: LD_INT 2
65128: PUSH
65129: LD_INT 3
65131: PUSH
65132: LD_INT 4
65134: PUSH
65135: LD_INT 5
65137: PUSH
65138: EMPTY
65139: LIST
65140: LIST
65141: LIST
65142: LIST
65143: LIST
65144: LIST
65145: IN
65146: NOT
65147: OR
65148: PUSH
65149: LD_VAR 0 3
65153: PPUSH
65154: LD_VAR 0 4
65158: PPUSH
65159: CALL_OW 488
65163: NOT
65164: OR
65165: IFFALSE 65169
// exit ;
65167: GO 65886
// pom := GetBase ( depot ) ;
65169: LD_ADDR_VAR 0 10
65173: PUSH
65174: LD_VAR 0 1
65178: PPUSH
65179: CALL_OW 274
65183: ST_TO_ADDR
// cost := CostOfBuilding ( btype , GetNation ( depot ) ) ;
65184: LD_ADDR_VAR 0 11
65188: PUSH
65189: LD_VAR 0 2
65193: PPUSH
65194: LD_VAR 0 1
65198: PPUSH
65199: CALL_OW 248
65203: PPUSH
65204: CALL_OW 450
65208: ST_TO_ADDR
// if not ( GetResourceType ( pom , mat_cans ) >= cost [ 1 ] and GetResourceType ( pom , mat_oil ) >= cost [ 2 ] and GetResourceType ( pom , mat_siberit ) >= cost [ 3 ] ) then
65209: LD_VAR 0 10
65213: PPUSH
65214: LD_INT 1
65216: PPUSH
65217: CALL_OW 275
65221: PUSH
65222: LD_VAR 0 11
65226: PUSH
65227: LD_INT 1
65229: ARRAY
65230: GREATEREQUAL
65231: PUSH
65232: LD_VAR 0 10
65236: PPUSH
65237: LD_INT 2
65239: PPUSH
65240: CALL_OW 275
65244: PUSH
65245: LD_VAR 0 11
65249: PUSH
65250: LD_INT 2
65252: ARRAY
65253: GREATEREQUAL
65254: AND
65255: PUSH
65256: LD_VAR 0 10
65260: PPUSH
65261: LD_INT 3
65263: PPUSH
65264: CALL_OW 275
65268: PUSH
65269: LD_VAR 0 11
65273: PUSH
65274: LD_INT 3
65276: ARRAY
65277: GREATEREQUAL
65278: AND
65279: NOT
65280: IFFALSE 65284
// exit ;
65282: GO 65886
// if GetBType ( depot ) = b_depot then
65284: LD_VAR 0 1
65288: PPUSH
65289: CALL_OW 266
65293: PUSH
65294: LD_INT 0
65296: EQUAL
65297: IFFALSE 65309
// dist := 28 else
65299: LD_ADDR_VAR 0 14
65303: PUSH
65304: LD_INT 28
65306: ST_TO_ADDR
65307: GO 65317
// dist := 36 ;
65309: LD_ADDR_VAR 0 14
65313: PUSH
65314: LD_INT 36
65316: ST_TO_ADDR
// if GetDistUnitXY ( depot , x , y ) > dist then
65317: LD_VAR 0 1
65321: PPUSH
65322: LD_VAR 0 3
65326: PPUSH
65327: LD_VAR 0 4
65331: PPUSH
65332: CALL_OW 297
65336: PUSH
65337: LD_VAR 0 14
65341: GREATER
65342: IFFALSE 65346
// exit ;
65344: GO 65886
// hexes := GetBuildingHexes ( btype , x , y , d , GetNation ( depot ) , 0 ) ;
65346: LD_ADDR_VAR 0 12
65350: PUSH
65351: LD_VAR 0 2
65355: PPUSH
65356: LD_VAR 0 3
65360: PPUSH
65361: LD_VAR 0 4
65365: PPUSH
65366: LD_VAR 0 5
65370: PPUSH
65371: LD_VAR 0 1
65375: PPUSH
65376: CALL_OW 248
65380: PPUSH
65381: LD_INT 0
65383: PPUSH
65384: CALL 65891 0 6
65388: ST_TO_ADDR
// if not hexes then
65389: LD_VAR 0 12
65393: NOT
65394: IFFALSE 65398
// exit ;
65396: GO 65886
// hex := GetHexInfo ( x , y ) ;
65398: LD_ADDR_VAR 0 15
65402: PUSH
65403: LD_VAR 0 3
65407: PPUSH
65408: LD_VAR 0 4
65412: PPUSH
65413: CALL_OW 546
65417: ST_TO_ADDR
// if hex [ 1 ] then
65418: LD_VAR 0 15
65422: PUSH
65423: LD_INT 1
65425: ARRAY
65426: IFFALSE 65430
// exit ;
65428: GO 65886
// height := hex [ 2 ] ;
65430: LD_ADDR_VAR 0 13
65434: PUSH
65435: LD_VAR 0 15
65439: PUSH
65440: LD_INT 2
65442: ARRAY
65443: ST_TO_ADDR
// for i = 1 to hexes do
65444: LD_ADDR_VAR 0 7
65448: PUSH
65449: DOUBLE
65450: LD_INT 1
65452: DEC
65453: ST_TO_ADDR
65454: LD_VAR 0 12
65458: PUSH
65459: FOR_TO
65460: IFFALSE 65790
// begin if not ValidHex ( hexes [ i ] [ 1 ] , hexes [ i ] [ 2 ] ) or HexInfo ( hexes [ i ] [ 1 ] , hexes [ i ] [ 2 ] ) > 0 or IsEnvironment ( hexes [ i ] [ 1 ] , hexes [ i ] [ 2 ] ) then
65462: LD_VAR 0 12
65466: PUSH
65467: LD_VAR 0 7
65471: ARRAY
65472: PUSH
65473: LD_INT 1
65475: ARRAY
65476: PPUSH
65477: LD_VAR 0 12
65481: PUSH
65482: LD_VAR 0 7
65486: ARRAY
65487: PUSH
65488: LD_INT 2
65490: ARRAY
65491: PPUSH
65492: CALL_OW 488
65496: NOT
65497: PUSH
65498: LD_VAR 0 12
65502: PUSH
65503: LD_VAR 0 7
65507: ARRAY
65508: PUSH
65509: LD_INT 1
65511: ARRAY
65512: PPUSH
65513: LD_VAR 0 12
65517: PUSH
65518: LD_VAR 0 7
65522: ARRAY
65523: PUSH
65524: LD_INT 2
65526: ARRAY
65527: PPUSH
65528: CALL_OW 428
65532: PUSH
65533: LD_INT 0
65535: GREATER
65536: OR
65537: PUSH
65538: LD_VAR 0 12
65542: PUSH
65543: LD_VAR 0 7
65547: ARRAY
65548: PUSH
65549: LD_INT 1
65551: ARRAY
65552: PPUSH
65553: LD_VAR 0 12
65557: PUSH
65558: LD_VAR 0 7
65562: ARRAY
65563: PUSH
65564: LD_INT 2
65566: ARRAY
65567: PPUSH
65568: CALL_OW 351
65572: OR
65573: IFFALSE 65579
// exit ;
65575: POP
65576: POP
65577: GO 65886
// j := GetHexInfo ( hexes [ i ] [ 1 ] , hexes [ i ] [ 2 ] ) ;
65579: LD_ADDR_VAR 0 8
65583: PUSH
65584: LD_VAR 0 12
65588: PUSH
65589: LD_VAR 0 7
65593: ARRAY
65594: PUSH
65595: LD_INT 1
65597: ARRAY
65598: PPUSH
65599: LD_VAR 0 12
65603: PUSH
65604: LD_VAR 0 7
65608: ARRAY
65609: PUSH
65610: LD_INT 2
65612: ARRAY
65613: PPUSH
65614: CALL_OW 546
65618: ST_TO_ADDR
// if j [ 1 ] or j [ 2 ] > height + 2 or j [ 2 ] < height - 2 or not j [ 3 ] in [ 0 , 8 , 9 , 10 , 11 , 12 , 13 , 16 , 17 , 18 , 19 , 20 , 21 ] or not j [ 5 ] or not j [ 6 ] in [ 1 , 2 , 7 , 9 , 10 , 11 ] then
65619: LD_VAR 0 8
65623: PUSH
65624: LD_INT 1
65626: ARRAY
65627: PUSH
65628: LD_VAR 0 8
65632: PUSH
65633: LD_INT 2
65635: ARRAY
65636: PUSH
65637: LD_VAR 0 13
65641: PUSH
65642: LD_INT 2
65644: PLUS
65645: GREATER
65646: OR
65647: PUSH
65648: LD_VAR 0 8
65652: PUSH
65653: LD_INT 2
65655: ARRAY
65656: PUSH
65657: LD_VAR 0 13
65661: PUSH
65662: LD_INT 2
65664: MINUS
65665: LESS
65666: OR
65667: PUSH
65668: LD_VAR 0 8
65672: PUSH
65673: LD_INT 3
65675: ARRAY
65676: PUSH
65677: LD_INT 0
65679: PUSH
65680: LD_INT 8
65682: PUSH
65683: LD_INT 9
65685: PUSH
65686: LD_INT 10
65688: PUSH
65689: LD_INT 11
65691: PUSH
65692: LD_INT 12
65694: PUSH
65695: LD_INT 13
65697: PUSH
65698: LD_INT 16
65700: PUSH
65701: LD_INT 17
65703: PUSH
65704: LD_INT 18
65706: PUSH
65707: LD_INT 19
65709: PUSH
65710: LD_INT 20
65712: PUSH
65713: LD_INT 21
65715: PUSH
65716: EMPTY
65717: LIST
65718: LIST
65719: LIST
65720: LIST
65721: LIST
65722: LIST
65723: LIST
65724: LIST
65725: LIST
65726: LIST
65727: LIST
65728: LIST
65729: LIST
65730: IN
65731: NOT
65732: OR
65733: PUSH
65734: LD_VAR 0 8
65738: PUSH
65739: LD_INT 5
65741: ARRAY
65742: NOT
65743: OR
65744: PUSH
65745: LD_VAR 0 8
65749: PUSH
65750: LD_INT 6
65752: ARRAY
65753: PUSH
65754: LD_INT 1
65756: PUSH
65757: LD_INT 2
65759: PUSH
65760: LD_INT 7
65762: PUSH
65763: LD_INT 9
65765: PUSH
65766: LD_INT 10
65768: PUSH
65769: LD_INT 11
65771: PUSH
65772: EMPTY
65773: LIST
65774: LIST
65775: LIST
65776: LIST
65777: LIST
65778: LIST
65779: IN
65780: NOT
65781: OR
65782: IFFALSE 65788
// exit ;
65784: POP
65785: POP
65786: GO 65886
// end ;
65788: GO 65459
65790: POP
65791: POP
// side := GetSide ( depot ) ;
65792: LD_ADDR_VAR 0 9
65796: PUSH
65797: LD_VAR 0 1
65801: PPUSH
65802: CALL_OW 255
65806: ST_TO_ADDR
// if DangerAtRangeXY ( side , x , y , 20 ) [ 4 ] then
65807: LD_VAR 0 9
65811: PPUSH
65812: LD_VAR 0 3
65816: PPUSH
65817: LD_VAR 0 4
65821: PPUSH
65822: LD_INT 20
65824: PPUSH
65825: CALL 58540 0 4
65829: PUSH
65830: LD_INT 4
65832: ARRAY
65833: IFFALSE 65837
// exit ;
65835: GO 65886
// if btype in [ b_oil_mine , b_siberite_mine ] and not GetResourceVisibility ( x , y , side ) then
65837: LD_VAR 0 2
65841: PUSH
65842: LD_INT 29
65844: PUSH
65845: LD_INT 30
65847: PUSH
65848: EMPTY
65849: LIST
65850: LIST
65851: IN
65852: PUSH
65853: LD_VAR 0 3
65857: PPUSH
65858: LD_VAR 0 4
65862: PPUSH
65863: LD_VAR 0 9
65867: PPUSH
65868: CALL_OW 440
65872: NOT
65873: AND
65874: IFFALSE 65878
// exit ;
65876: GO 65886
// result := true ;
65878: LD_ADDR_VAR 0 6
65882: PUSH
65883: LD_INT 1
65885: ST_TO_ADDR
// end ;
65886: LD_VAR 0 6
65890: RET
// export function GetBuildingHexes ( btype , x , y , dir , nation , mode ) ; var i , temp_list , temp_list2 ; var DepotAm0 , DepotAm1 , DepotAm2 , DepotAm3 , DepotAm4 , DepotAm5 , DepotAr0 , DepotAr1 , DepotAr2 , DepotAr3 , DepotAr4 , DepotAr5 , DepotRu0 , DepotRu1 , DepotRu2 , DepotRu3 , DepotRu4 , DepotRu5 ; var Factory0 , Factory1 , Factory2 , Factory3 , Factory4 , Factory5 , Ext0 , Ext1 , Ext2 , Ext3 , Ext4 , Ext5 ; var Lab0 , Lab1 , Lab2 , Lab3 , Lab4 , Lab5 , ControlTower0 , ControlTower1 , ControlTower2 , ControlTower3 , ControlTower4 , ControlTower5 ; var Barracks0 , Barracks1 , Barracks2 , Barracks3 , Barracks4 , Barracks5 , Bunker0 , Bunker1 , Bunker2 , Bunker3 , Bunker4 , Bunker5 ; begin
65891: LD_INT 0
65893: PPUSH
65894: PPUSH
65895: PPUSH
65896: PPUSH
65897: PPUSH
65898: PPUSH
65899: PPUSH
65900: PPUSH
65901: PPUSH
65902: PPUSH
65903: PPUSH
65904: PPUSH
65905: PPUSH
65906: PPUSH
65907: PPUSH
65908: PPUSH
65909: PPUSH
65910: PPUSH
65911: PPUSH
65912: PPUSH
65913: PPUSH
65914: PPUSH
65915: PPUSH
65916: PPUSH
65917: PPUSH
65918: PPUSH
65919: PPUSH
65920: PPUSH
65921: PPUSH
65922: PPUSH
65923: PPUSH
65924: PPUSH
65925: PPUSH
65926: PPUSH
65927: PPUSH
65928: PPUSH
65929: PPUSH
65930: PPUSH
65931: PPUSH
65932: PPUSH
65933: PPUSH
65934: PPUSH
65935: PPUSH
65936: PPUSH
65937: PPUSH
65938: PPUSH
65939: PPUSH
65940: PPUSH
65941: PPUSH
65942: PPUSH
65943: PPUSH
65944: PPUSH
65945: PPUSH
65946: PPUSH
65947: PPUSH
65948: PPUSH
65949: PPUSH
65950: PPUSH
// result = [ ] ;
65951: LD_ADDR_VAR 0 7
65955: PUSH
65956: EMPTY
65957: ST_TO_ADDR
// temp_list = [ ] ;
65958: LD_ADDR_VAR 0 9
65962: PUSH
65963: EMPTY
65964: ST_TO_ADDR
// if not dir in [ 0 , 1 , 2 , 3 , 4 , 5 ] or ( btype in [ b_depot , b_warehouse ] and not nation in [ nation_american , nation_arabian , nation_russian ] ) then
65965: LD_VAR 0 4
65969: PUSH
65970: LD_INT 0
65972: PUSH
65973: LD_INT 1
65975: PUSH
65976: LD_INT 2
65978: PUSH
65979: LD_INT 3
65981: PUSH
65982: LD_INT 4
65984: PUSH
65985: LD_INT 5
65987: PUSH
65988: EMPTY
65989: LIST
65990: LIST
65991: LIST
65992: LIST
65993: LIST
65994: LIST
65995: IN
65996: NOT
65997: PUSH
65998: LD_VAR 0 1
66002: PUSH
66003: LD_INT 0
66005: PUSH
66006: LD_INT 1
66008: PUSH
66009: EMPTY
66010: LIST
66011: LIST
66012: IN
66013: PUSH
66014: LD_VAR 0 5
66018: PUSH
66019: LD_INT 1
66021: PUSH
66022: LD_INT 2
66024: PUSH
66025: LD_INT 3
66027: PUSH
66028: EMPTY
66029: LIST
66030: LIST
66031: LIST
66032: IN
66033: NOT
66034: AND
66035: OR
66036: IFFALSE 66040
// exit ;
66038: GO 84431
// if btype in [ b_lab , b_lab_half , b_lab_full , b_lab_biological , b_lab_computer , b_lab_opto , b_lab_siberium , b_lab_spacetime , b_lab_weapon ] then
66040: LD_VAR 0 1
66044: PUSH
66045: LD_INT 6
66047: PUSH
66048: LD_INT 7
66050: PUSH
66051: LD_INT 8
66053: PUSH
66054: LD_INT 13
66056: PUSH
66057: LD_INT 12
66059: PUSH
66060: LD_INT 15
66062: PUSH
66063: LD_INT 11
66065: PUSH
66066: LD_INT 14
66068: PUSH
66069: LD_INT 10
66071: PUSH
66072: EMPTY
66073: LIST
66074: LIST
66075: LIST
66076: LIST
66077: LIST
66078: LIST
66079: LIST
66080: LIST
66081: LIST
66082: IN
66083: IFFALSE 66093
// btype = b_lab ;
66085: LD_ADDR_VAR 0 1
66089: PUSH
66090: LD_INT 6
66092: ST_TO_ADDR
// if not mode in [ 0 , 1 , 2 ] or ( not btype in [ b_depot , b_warehouse , b_workshop , b_factory , b_lab , b_control_tower , b_armoury , b_barracks , b_breastwork , b_bunker , b_turret ] and mode = 1 ) or ( not btype in [ b_workshop , b_factory ] and mode = 2 ) then
66093: LD_VAR 0 6
66097: PUSH
66098: LD_INT 0
66100: PUSH
66101: LD_INT 1
66103: PUSH
66104: LD_INT 2
66106: PUSH
66107: EMPTY
66108: LIST
66109: LIST
66110: LIST
66111: IN
66112: NOT
66113: PUSH
66114: LD_VAR 0 1
66118: PUSH
66119: LD_INT 0
66121: PUSH
66122: LD_INT 1
66124: PUSH
66125: LD_INT 2
66127: PUSH
66128: LD_INT 3
66130: PUSH
66131: LD_INT 6
66133: PUSH
66134: LD_INT 36
66136: PUSH
66137: LD_INT 4
66139: PUSH
66140: LD_INT 5
66142: PUSH
66143: LD_INT 31
66145: PUSH
66146: LD_INT 32
66148: PUSH
66149: LD_INT 33
66151: PUSH
66152: EMPTY
66153: LIST
66154: LIST
66155: LIST
66156: LIST
66157: LIST
66158: LIST
66159: LIST
66160: LIST
66161: LIST
66162: LIST
66163: LIST
66164: IN
66165: NOT
66166: PUSH
66167: LD_VAR 0 6
66171: PUSH
66172: LD_INT 1
66174: EQUAL
66175: AND
66176: OR
66177: PUSH
66178: LD_VAR 0 1
66182: PUSH
66183: LD_INT 2
66185: PUSH
66186: LD_INT 3
66188: PUSH
66189: EMPTY
66190: LIST
66191: LIST
66192: IN
66193: NOT
66194: PUSH
66195: LD_VAR 0 6
66199: PUSH
66200: LD_INT 2
66202: EQUAL
66203: AND
66204: OR
66205: IFFALSE 66215
// mode = 0 ;
66207: LD_ADDR_VAR 0 6
66211: PUSH
66212: LD_INT 0
66214: ST_TO_ADDR
// case mode of 0 :
66215: LD_VAR 0 6
66219: PUSH
66220: LD_INT 0
66222: DOUBLE
66223: EQUAL
66224: IFTRUE 66228
66226: GO 77681
66228: POP
// begin DepotAm0 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ 1 , 3 ] , [ 0 , 3 ] , [ - 1 , 2 ] ] ;
66229: LD_ADDR_VAR 0 11
66233: PUSH
66234: LD_INT 0
66236: PUSH
66237: LD_INT 0
66239: PUSH
66240: EMPTY
66241: LIST
66242: LIST
66243: PUSH
66244: LD_INT 0
66246: PUSH
66247: LD_INT 1
66249: NEG
66250: PUSH
66251: EMPTY
66252: LIST
66253: LIST
66254: PUSH
66255: LD_INT 1
66257: PUSH
66258: LD_INT 0
66260: PUSH
66261: EMPTY
66262: LIST
66263: LIST
66264: PUSH
66265: LD_INT 1
66267: PUSH
66268: LD_INT 1
66270: PUSH
66271: EMPTY
66272: LIST
66273: LIST
66274: PUSH
66275: LD_INT 0
66277: PUSH
66278: LD_INT 1
66280: PUSH
66281: EMPTY
66282: LIST
66283: LIST
66284: PUSH
66285: LD_INT 1
66287: NEG
66288: PUSH
66289: LD_INT 0
66291: PUSH
66292: EMPTY
66293: LIST
66294: LIST
66295: PUSH
66296: LD_INT 1
66298: NEG
66299: PUSH
66300: LD_INT 1
66302: NEG
66303: PUSH
66304: EMPTY
66305: LIST
66306: LIST
66307: PUSH
66308: LD_INT 1
66310: NEG
66311: PUSH
66312: LD_INT 2
66314: NEG
66315: PUSH
66316: EMPTY
66317: LIST
66318: LIST
66319: PUSH
66320: LD_INT 0
66322: PUSH
66323: LD_INT 2
66325: NEG
66326: PUSH
66327: EMPTY
66328: LIST
66329: LIST
66330: PUSH
66331: LD_INT 1
66333: PUSH
66334: LD_INT 1
66336: NEG
66337: PUSH
66338: EMPTY
66339: LIST
66340: LIST
66341: PUSH
66342: LD_INT 1
66344: PUSH
66345: LD_INT 2
66347: PUSH
66348: EMPTY
66349: LIST
66350: LIST
66351: PUSH
66352: LD_INT 0
66354: PUSH
66355: LD_INT 2
66357: PUSH
66358: EMPTY
66359: LIST
66360: LIST
66361: PUSH
66362: LD_INT 1
66364: NEG
66365: PUSH
66366: LD_INT 1
66368: PUSH
66369: EMPTY
66370: LIST
66371: LIST
66372: PUSH
66373: LD_INT 1
66375: PUSH
66376: LD_INT 3
66378: PUSH
66379: EMPTY
66380: LIST
66381: LIST
66382: PUSH
66383: LD_INT 0
66385: PUSH
66386: LD_INT 3
66388: PUSH
66389: EMPTY
66390: LIST
66391: LIST
66392: PUSH
66393: LD_INT 1
66395: NEG
66396: PUSH
66397: LD_INT 2
66399: PUSH
66400: EMPTY
66401: LIST
66402: LIST
66403: PUSH
66404: EMPTY
66405: LIST
66406: LIST
66407: LIST
66408: LIST
66409: LIST
66410: LIST
66411: LIST
66412: LIST
66413: LIST
66414: LIST
66415: LIST
66416: LIST
66417: LIST
66418: LIST
66419: LIST
66420: LIST
66421: ST_TO_ADDR
// DepotAm1 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , 1 ] , [ - 3 , 0 ] , [ - 3 , - 1 ] ] ;
66422: LD_ADDR_VAR 0 12
66426: PUSH
66427: LD_INT 0
66429: PUSH
66430: LD_INT 0
66432: PUSH
66433: EMPTY
66434: LIST
66435: LIST
66436: PUSH
66437: LD_INT 0
66439: PUSH
66440: LD_INT 1
66442: NEG
66443: PUSH
66444: EMPTY
66445: LIST
66446: LIST
66447: PUSH
66448: LD_INT 1
66450: PUSH
66451: LD_INT 0
66453: PUSH
66454: EMPTY
66455: LIST
66456: LIST
66457: PUSH
66458: LD_INT 1
66460: PUSH
66461: LD_INT 1
66463: PUSH
66464: EMPTY
66465: LIST
66466: LIST
66467: PUSH
66468: LD_INT 0
66470: PUSH
66471: LD_INT 1
66473: PUSH
66474: EMPTY
66475: LIST
66476: LIST
66477: PUSH
66478: LD_INT 1
66480: NEG
66481: PUSH
66482: LD_INT 0
66484: PUSH
66485: EMPTY
66486: LIST
66487: LIST
66488: PUSH
66489: LD_INT 1
66491: NEG
66492: PUSH
66493: LD_INT 1
66495: NEG
66496: PUSH
66497: EMPTY
66498: LIST
66499: LIST
66500: PUSH
66501: LD_INT 1
66503: PUSH
66504: LD_INT 1
66506: NEG
66507: PUSH
66508: EMPTY
66509: LIST
66510: LIST
66511: PUSH
66512: LD_INT 2
66514: PUSH
66515: LD_INT 0
66517: PUSH
66518: EMPTY
66519: LIST
66520: LIST
66521: PUSH
66522: LD_INT 2
66524: PUSH
66525: LD_INT 1
66527: PUSH
66528: EMPTY
66529: LIST
66530: LIST
66531: PUSH
66532: LD_INT 1
66534: NEG
66535: PUSH
66536: LD_INT 1
66538: PUSH
66539: EMPTY
66540: LIST
66541: LIST
66542: PUSH
66543: LD_INT 2
66545: NEG
66546: PUSH
66547: LD_INT 0
66549: PUSH
66550: EMPTY
66551: LIST
66552: LIST
66553: PUSH
66554: LD_INT 2
66556: NEG
66557: PUSH
66558: LD_INT 1
66560: NEG
66561: PUSH
66562: EMPTY
66563: LIST
66564: LIST
66565: PUSH
66566: LD_INT 2
66568: NEG
66569: PUSH
66570: LD_INT 1
66572: PUSH
66573: EMPTY
66574: LIST
66575: LIST
66576: PUSH
66577: LD_INT 3
66579: NEG
66580: PUSH
66581: LD_INT 0
66583: PUSH
66584: EMPTY
66585: LIST
66586: LIST
66587: PUSH
66588: LD_INT 3
66590: NEG
66591: PUSH
66592: LD_INT 1
66594: NEG
66595: PUSH
66596: EMPTY
66597: LIST
66598: LIST
66599: PUSH
66600: EMPTY
66601: LIST
66602: LIST
66603: LIST
66604: LIST
66605: LIST
66606: LIST
66607: LIST
66608: LIST
66609: LIST
66610: LIST
66611: LIST
66612: LIST
66613: LIST
66614: LIST
66615: LIST
66616: LIST
66617: ST_TO_ADDR
// DepotAm2 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ - 2 , - 3 ] , [ - 3 , - 2 ] , [ - 3 , - 3 ] ] ;
66618: LD_ADDR_VAR 0 13
66622: PUSH
66623: LD_INT 0
66625: PUSH
66626: LD_INT 0
66628: PUSH
66629: EMPTY
66630: LIST
66631: LIST
66632: PUSH
66633: LD_INT 0
66635: PUSH
66636: LD_INT 1
66638: NEG
66639: PUSH
66640: EMPTY
66641: LIST
66642: LIST
66643: PUSH
66644: LD_INT 1
66646: PUSH
66647: LD_INT 0
66649: PUSH
66650: EMPTY
66651: LIST
66652: LIST
66653: PUSH
66654: LD_INT 1
66656: PUSH
66657: LD_INT 1
66659: PUSH
66660: EMPTY
66661: LIST
66662: LIST
66663: PUSH
66664: LD_INT 0
66666: PUSH
66667: LD_INT 1
66669: PUSH
66670: EMPTY
66671: LIST
66672: LIST
66673: PUSH
66674: LD_INT 1
66676: NEG
66677: PUSH
66678: LD_INT 0
66680: PUSH
66681: EMPTY
66682: LIST
66683: LIST
66684: PUSH
66685: LD_INT 1
66687: NEG
66688: PUSH
66689: LD_INT 1
66691: NEG
66692: PUSH
66693: EMPTY
66694: LIST
66695: LIST
66696: PUSH
66697: LD_INT 1
66699: NEG
66700: PUSH
66701: LD_INT 2
66703: NEG
66704: PUSH
66705: EMPTY
66706: LIST
66707: LIST
66708: PUSH
66709: LD_INT 2
66711: PUSH
66712: LD_INT 1
66714: PUSH
66715: EMPTY
66716: LIST
66717: LIST
66718: PUSH
66719: LD_INT 2
66721: PUSH
66722: LD_INT 2
66724: PUSH
66725: EMPTY
66726: LIST
66727: LIST
66728: PUSH
66729: LD_INT 1
66731: PUSH
66732: LD_INT 2
66734: PUSH
66735: EMPTY
66736: LIST
66737: LIST
66738: PUSH
66739: LD_INT 2
66741: NEG
66742: PUSH
66743: LD_INT 1
66745: NEG
66746: PUSH
66747: EMPTY
66748: LIST
66749: LIST
66750: PUSH
66751: LD_INT 2
66753: NEG
66754: PUSH
66755: LD_INT 2
66757: NEG
66758: PUSH
66759: EMPTY
66760: LIST
66761: LIST
66762: PUSH
66763: LD_INT 2
66765: NEG
66766: PUSH
66767: LD_INT 3
66769: NEG
66770: PUSH
66771: EMPTY
66772: LIST
66773: LIST
66774: PUSH
66775: LD_INT 3
66777: NEG
66778: PUSH
66779: LD_INT 2
66781: NEG
66782: PUSH
66783: EMPTY
66784: LIST
66785: LIST
66786: PUSH
66787: LD_INT 3
66789: NEG
66790: PUSH
66791: LD_INT 3
66793: NEG
66794: PUSH
66795: EMPTY
66796: LIST
66797: LIST
66798: PUSH
66799: EMPTY
66800: LIST
66801: LIST
66802: LIST
66803: LIST
66804: LIST
66805: LIST
66806: LIST
66807: LIST
66808: LIST
66809: LIST
66810: LIST
66811: LIST
66812: LIST
66813: LIST
66814: LIST
66815: LIST
66816: ST_TO_ADDR
// DepotAm3 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 1 , - 3 ] , [ 0 , - 3 ] , [ 1 , - 2 ] ] ;
66817: LD_ADDR_VAR 0 14
66821: PUSH
66822: LD_INT 0
66824: PUSH
66825: LD_INT 0
66827: PUSH
66828: EMPTY
66829: LIST
66830: LIST
66831: PUSH
66832: LD_INT 0
66834: PUSH
66835: LD_INT 1
66837: NEG
66838: PUSH
66839: EMPTY
66840: LIST
66841: LIST
66842: PUSH
66843: LD_INT 1
66845: PUSH
66846: LD_INT 0
66848: PUSH
66849: EMPTY
66850: LIST
66851: LIST
66852: PUSH
66853: LD_INT 1
66855: PUSH
66856: LD_INT 1
66858: PUSH
66859: EMPTY
66860: LIST
66861: LIST
66862: PUSH
66863: LD_INT 0
66865: PUSH
66866: LD_INT 1
66868: PUSH
66869: EMPTY
66870: LIST
66871: LIST
66872: PUSH
66873: LD_INT 1
66875: NEG
66876: PUSH
66877: LD_INT 0
66879: PUSH
66880: EMPTY
66881: LIST
66882: LIST
66883: PUSH
66884: LD_INT 1
66886: NEG
66887: PUSH
66888: LD_INT 1
66890: NEG
66891: PUSH
66892: EMPTY
66893: LIST
66894: LIST
66895: PUSH
66896: LD_INT 1
66898: NEG
66899: PUSH
66900: LD_INT 2
66902: NEG
66903: PUSH
66904: EMPTY
66905: LIST
66906: LIST
66907: PUSH
66908: LD_INT 0
66910: PUSH
66911: LD_INT 2
66913: NEG
66914: PUSH
66915: EMPTY
66916: LIST
66917: LIST
66918: PUSH
66919: LD_INT 1
66921: PUSH
66922: LD_INT 1
66924: NEG
66925: PUSH
66926: EMPTY
66927: LIST
66928: LIST
66929: PUSH
66930: LD_INT 1
66932: PUSH
66933: LD_INT 2
66935: PUSH
66936: EMPTY
66937: LIST
66938: LIST
66939: PUSH
66940: LD_INT 0
66942: PUSH
66943: LD_INT 2
66945: PUSH
66946: EMPTY
66947: LIST
66948: LIST
66949: PUSH
66950: LD_INT 1
66952: NEG
66953: PUSH
66954: LD_INT 1
66956: PUSH
66957: EMPTY
66958: LIST
66959: LIST
66960: PUSH
66961: LD_INT 1
66963: NEG
66964: PUSH
66965: LD_INT 3
66967: NEG
66968: PUSH
66969: EMPTY
66970: LIST
66971: LIST
66972: PUSH
66973: LD_INT 0
66975: PUSH
66976: LD_INT 3
66978: NEG
66979: PUSH
66980: EMPTY
66981: LIST
66982: LIST
66983: PUSH
66984: LD_INT 1
66986: PUSH
66987: LD_INT 2
66989: NEG
66990: PUSH
66991: EMPTY
66992: LIST
66993: LIST
66994: PUSH
66995: EMPTY
66996: LIST
66997: LIST
66998: LIST
66999: LIST
67000: LIST
67001: LIST
67002: LIST
67003: LIST
67004: LIST
67005: LIST
67006: LIST
67007: LIST
67008: LIST
67009: LIST
67010: LIST
67011: LIST
67012: ST_TO_ADDR
// DepotAm4 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ 2 , - 1 ] , [ 3 , 0 ] , [ 3 , 1 ] ] ;
67013: LD_ADDR_VAR 0 15
67017: PUSH
67018: LD_INT 0
67020: PUSH
67021: LD_INT 0
67023: PUSH
67024: EMPTY
67025: LIST
67026: LIST
67027: PUSH
67028: LD_INT 0
67030: PUSH
67031: LD_INT 1
67033: NEG
67034: PUSH
67035: EMPTY
67036: LIST
67037: LIST
67038: PUSH
67039: LD_INT 1
67041: PUSH
67042: LD_INT 0
67044: PUSH
67045: EMPTY
67046: LIST
67047: LIST
67048: PUSH
67049: LD_INT 1
67051: PUSH
67052: LD_INT 1
67054: PUSH
67055: EMPTY
67056: LIST
67057: LIST
67058: PUSH
67059: LD_INT 0
67061: PUSH
67062: LD_INT 1
67064: PUSH
67065: EMPTY
67066: LIST
67067: LIST
67068: PUSH
67069: LD_INT 1
67071: NEG
67072: PUSH
67073: LD_INT 0
67075: PUSH
67076: EMPTY
67077: LIST
67078: LIST
67079: PUSH
67080: LD_INT 1
67082: NEG
67083: PUSH
67084: LD_INT 1
67086: NEG
67087: PUSH
67088: EMPTY
67089: LIST
67090: LIST
67091: PUSH
67092: LD_INT 1
67094: PUSH
67095: LD_INT 1
67097: NEG
67098: PUSH
67099: EMPTY
67100: LIST
67101: LIST
67102: PUSH
67103: LD_INT 2
67105: PUSH
67106: LD_INT 0
67108: PUSH
67109: EMPTY
67110: LIST
67111: LIST
67112: PUSH
67113: LD_INT 2
67115: PUSH
67116: LD_INT 1
67118: PUSH
67119: EMPTY
67120: LIST
67121: LIST
67122: PUSH
67123: LD_INT 1
67125: NEG
67126: PUSH
67127: LD_INT 1
67129: PUSH
67130: EMPTY
67131: LIST
67132: LIST
67133: PUSH
67134: LD_INT 2
67136: NEG
67137: PUSH
67138: LD_INT 0
67140: PUSH
67141: EMPTY
67142: LIST
67143: LIST
67144: PUSH
67145: LD_INT 2
67147: NEG
67148: PUSH
67149: LD_INT 1
67151: NEG
67152: PUSH
67153: EMPTY
67154: LIST
67155: LIST
67156: PUSH
67157: LD_INT 2
67159: PUSH
67160: LD_INT 1
67162: NEG
67163: PUSH
67164: EMPTY
67165: LIST
67166: LIST
67167: PUSH
67168: LD_INT 3
67170: PUSH
67171: LD_INT 0
67173: PUSH
67174: EMPTY
67175: LIST
67176: LIST
67177: PUSH
67178: LD_INT 3
67180: PUSH
67181: LD_INT 1
67183: PUSH
67184: EMPTY
67185: LIST
67186: LIST
67187: PUSH
67188: EMPTY
67189: LIST
67190: LIST
67191: LIST
67192: LIST
67193: LIST
67194: LIST
67195: LIST
67196: LIST
67197: LIST
67198: LIST
67199: LIST
67200: LIST
67201: LIST
67202: LIST
67203: LIST
67204: LIST
67205: ST_TO_ADDR
// DepotAm5 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ 3 , 2 ] , [ 3 , 3 ] , [ 2 , 3 ] ] ;
67206: LD_ADDR_VAR 0 16
67210: PUSH
67211: LD_INT 0
67213: PUSH
67214: LD_INT 0
67216: PUSH
67217: EMPTY
67218: LIST
67219: LIST
67220: PUSH
67221: LD_INT 0
67223: PUSH
67224: LD_INT 1
67226: NEG
67227: PUSH
67228: EMPTY
67229: LIST
67230: LIST
67231: PUSH
67232: LD_INT 1
67234: PUSH
67235: LD_INT 0
67237: PUSH
67238: EMPTY
67239: LIST
67240: LIST
67241: PUSH
67242: LD_INT 1
67244: PUSH
67245: LD_INT 1
67247: PUSH
67248: EMPTY
67249: LIST
67250: LIST
67251: PUSH
67252: LD_INT 0
67254: PUSH
67255: LD_INT 1
67257: PUSH
67258: EMPTY
67259: LIST
67260: LIST
67261: PUSH
67262: LD_INT 1
67264: NEG
67265: PUSH
67266: LD_INT 0
67268: PUSH
67269: EMPTY
67270: LIST
67271: LIST
67272: PUSH
67273: LD_INT 1
67275: NEG
67276: PUSH
67277: LD_INT 1
67279: NEG
67280: PUSH
67281: EMPTY
67282: LIST
67283: LIST
67284: PUSH
67285: LD_INT 1
67287: NEG
67288: PUSH
67289: LD_INT 2
67291: NEG
67292: PUSH
67293: EMPTY
67294: LIST
67295: LIST
67296: PUSH
67297: LD_INT 2
67299: PUSH
67300: LD_INT 1
67302: PUSH
67303: EMPTY
67304: LIST
67305: LIST
67306: PUSH
67307: LD_INT 2
67309: PUSH
67310: LD_INT 2
67312: PUSH
67313: EMPTY
67314: LIST
67315: LIST
67316: PUSH
67317: LD_INT 1
67319: PUSH
67320: LD_INT 2
67322: PUSH
67323: EMPTY
67324: LIST
67325: LIST
67326: PUSH
67327: LD_INT 2
67329: NEG
67330: PUSH
67331: LD_INT 1
67333: NEG
67334: PUSH
67335: EMPTY
67336: LIST
67337: LIST
67338: PUSH
67339: LD_INT 2
67341: NEG
67342: PUSH
67343: LD_INT 2
67345: NEG
67346: PUSH
67347: EMPTY
67348: LIST
67349: LIST
67350: PUSH
67351: LD_INT 3
67353: PUSH
67354: LD_INT 2
67356: PUSH
67357: EMPTY
67358: LIST
67359: LIST
67360: PUSH
67361: LD_INT 3
67363: PUSH
67364: LD_INT 3
67366: PUSH
67367: EMPTY
67368: LIST
67369: LIST
67370: PUSH
67371: LD_INT 2
67373: PUSH
67374: LD_INT 3
67376: PUSH
67377: EMPTY
67378: LIST
67379: LIST
67380: PUSH
67381: EMPTY
67382: LIST
67383: LIST
67384: LIST
67385: LIST
67386: LIST
67387: LIST
67388: LIST
67389: LIST
67390: LIST
67391: LIST
67392: LIST
67393: LIST
67394: LIST
67395: LIST
67396: LIST
67397: LIST
67398: ST_TO_ADDR
// DepotAr0 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
67399: LD_ADDR_VAR 0 17
67403: PUSH
67404: LD_INT 0
67406: PUSH
67407: LD_INT 0
67409: PUSH
67410: EMPTY
67411: LIST
67412: LIST
67413: PUSH
67414: LD_INT 0
67416: PUSH
67417: LD_INT 1
67419: NEG
67420: PUSH
67421: EMPTY
67422: LIST
67423: LIST
67424: PUSH
67425: LD_INT 1
67427: PUSH
67428: LD_INT 0
67430: PUSH
67431: EMPTY
67432: LIST
67433: LIST
67434: PUSH
67435: LD_INT 1
67437: PUSH
67438: LD_INT 1
67440: PUSH
67441: EMPTY
67442: LIST
67443: LIST
67444: PUSH
67445: LD_INT 0
67447: PUSH
67448: LD_INT 1
67450: PUSH
67451: EMPTY
67452: LIST
67453: LIST
67454: PUSH
67455: LD_INT 1
67457: NEG
67458: PUSH
67459: LD_INT 0
67461: PUSH
67462: EMPTY
67463: LIST
67464: LIST
67465: PUSH
67466: LD_INT 1
67468: NEG
67469: PUSH
67470: LD_INT 1
67472: NEG
67473: PUSH
67474: EMPTY
67475: LIST
67476: LIST
67477: PUSH
67478: LD_INT 1
67480: NEG
67481: PUSH
67482: LD_INT 2
67484: NEG
67485: PUSH
67486: EMPTY
67487: LIST
67488: LIST
67489: PUSH
67490: LD_INT 0
67492: PUSH
67493: LD_INT 2
67495: NEG
67496: PUSH
67497: EMPTY
67498: LIST
67499: LIST
67500: PUSH
67501: LD_INT 1
67503: PUSH
67504: LD_INT 1
67506: NEG
67507: PUSH
67508: EMPTY
67509: LIST
67510: LIST
67511: PUSH
67512: LD_INT 2
67514: PUSH
67515: LD_INT 0
67517: PUSH
67518: EMPTY
67519: LIST
67520: LIST
67521: PUSH
67522: LD_INT 2
67524: PUSH
67525: LD_INT 1
67527: PUSH
67528: EMPTY
67529: LIST
67530: LIST
67531: PUSH
67532: LD_INT 2
67534: PUSH
67535: LD_INT 2
67537: PUSH
67538: EMPTY
67539: LIST
67540: LIST
67541: PUSH
67542: LD_INT 1
67544: PUSH
67545: LD_INT 2
67547: PUSH
67548: EMPTY
67549: LIST
67550: LIST
67551: PUSH
67552: LD_INT 0
67554: PUSH
67555: LD_INT 2
67557: PUSH
67558: EMPTY
67559: LIST
67560: LIST
67561: PUSH
67562: LD_INT 1
67564: NEG
67565: PUSH
67566: LD_INT 1
67568: PUSH
67569: EMPTY
67570: LIST
67571: LIST
67572: PUSH
67573: LD_INT 2
67575: NEG
67576: PUSH
67577: LD_INT 0
67579: PUSH
67580: EMPTY
67581: LIST
67582: LIST
67583: PUSH
67584: LD_INT 2
67586: NEG
67587: PUSH
67588: LD_INT 1
67590: NEG
67591: PUSH
67592: EMPTY
67593: LIST
67594: LIST
67595: PUSH
67596: LD_INT 2
67598: NEG
67599: PUSH
67600: LD_INT 2
67602: NEG
67603: PUSH
67604: EMPTY
67605: LIST
67606: LIST
67607: PUSH
67608: EMPTY
67609: LIST
67610: LIST
67611: LIST
67612: LIST
67613: LIST
67614: LIST
67615: LIST
67616: LIST
67617: LIST
67618: LIST
67619: LIST
67620: LIST
67621: LIST
67622: LIST
67623: LIST
67624: LIST
67625: LIST
67626: LIST
67627: LIST
67628: ST_TO_ADDR
// DepotAr1 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
67629: LD_ADDR_VAR 0 18
67633: PUSH
67634: LD_INT 0
67636: PUSH
67637: LD_INT 0
67639: PUSH
67640: EMPTY
67641: LIST
67642: LIST
67643: PUSH
67644: LD_INT 0
67646: PUSH
67647: LD_INT 1
67649: NEG
67650: PUSH
67651: EMPTY
67652: LIST
67653: LIST
67654: PUSH
67655: LD_INT 1
67657: PUSH
67658: LD_INT 0
67660: PUSH
67661: EMPTY
67662: LIST
67663: LIST
67664: PUSH
67665: LD_INT 1
67667: PUSH
67668: LD_INT 1
67670: PUSH
67671: EMPTY
67672: LIST
67673: LIST
67674: PUSH
67675: LD_INT 0
67677: PUSH
67678: LD_INT 1
67680: PUSH
67681: EMPTY
67682: LIST
67683: LIST
67684: PUSH
67685: LD_INT 1
67687: NEG
67688: PUSH
67689: LD_INT 0
67691: PUSH
67692: EMPTY
67693: LIST
67694: LIST
67695: PUSH
67696: LD_INT 1
67698: NEG
67699: PUSH
67700: LD_INT 1
67702: NEG
67703: PUSH
67704: EMPTY
67705: LIST
67706: LIST
67707: PUSH
67708: LD_INT 1
67710: NEG
67711: PUSH
67712: LD_INT 2
67714: NEG
67715: PUSH
67716: EMPTY
67717: LIST
67718: LIST
67719: PUSH
67720: LD_INT 0
67722: PUSH
67723: LD_INT 2
67725: NEG
67726: PUSH
67727: EMPTY
67728: LIST
67729: LIST
67730: PUSH
67731: LD_INT 1
67733: PUSH
67734: LD_INT 1
67736: NEG
67737: PUSH
67738: EMPTY
67739: LIST
67740: LIST
67741: PUSH
67742: LD_INT 2
67744: PUSH
67745: LD_INT 0
67747: PUSH
67748: EMPTY
67749: LIST
67750: LIST
67751: PUSH
67752: LD_INT 2
67754: PUSH
67755: LD_INT 1
67757: PUSH
67758: EMPTY
67759: LIST
67760: LIST
67761: PUSH
67762: LD_INT 2
67764: PUSH
67765: LD_INT 2
67767: PUSH
67768: EMPTY
67769: LIST
67770: LIST
67771: PUSH
67772: LD_INT 1
67774: PUSH
67775: LD_INT 2
67777: PUSH
67778: EMPTY
67779: LIST
67780: LIST
67781: PUSH
67782: LD_INT 0
67784: PUSH
67785: LD_INT 2
67787: PUSH
67788: EMPTY
67789: LIST
67790: LIST
67791: PUSH
67792: LD_INT 1
67794: NEG
67795: PUSH
67796: LD_INT 1
67798: PUSH
67799: EMPTY
67800: LIST
67801: LIST
67802: PUSH
67803: LD_INT 2
67805: NEG
67806: PUSH
67807: LD_INT 0
67809: PUSH
67810: EMPTY
67811: LIST
67812: LIST
67813: PUSH
67814: LD_INT 2
67816: NEG
67817: PUSH
67818: LD_INT 1
67820: NEG
67821: PUSH
67822: EMPTY
67823: LIST
67824: LIST
67825: PUSH
67826: LD_INT 2
67828: NEG
67829: PUSH
67830: LD_INT 2
67832: NEG
67833: PUSH
67834: EMPTY
67835: LIST
67836: LIST
67837: PUSH
67838: EMPTY
67839: LIST
67840: LIST
67841: LIST
67842: LIST
67843: LIST
67844: LIST
67845: LIST
67846: LIST
67847: LIST
67848: LIST
67849: LIST
67850: LIST
67851: LIST
67852: LIST
67853: LIST
67854: LIST
67855: LIST
67856: LIST
67857: LIST
67858: ST_TO_ADDR
// DepotAr2 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
67859: LD_ADDR_VAR 0 19
67863: PUSH
67864: LD_INT 0
67866: PUSH
67867: LD_INT 0
67869: PUSH
67870: EMPTY
67871: LIST
67872: LIST
67873: PUSH
67874: LD_INT 0
67876: PUSH
67877: LD_INT 1
67879: NEG
67880: PUSH
67881: EMPTY
67882: LIST
67883: LIST
67884: PUSH
67885: LD_INT 1
67887: PUSH
67888: LD_INT 0
67890: PUSH
67891: EMPTY
67892: LIST
67893: LIST
67894: PUSH
67895: LD_INT 1
67897: PUSH
67898: LD_INT 1
67900: PUSH
67901: EMPTY
67902: LIST
67903: LIST
67904: PUSH
67905: LD_INT 0
67907: PUSH
67908: LD_INT 1
67910: PUSH
67911: EMPTY
67912: LIST
67913: LIST
67914: PUSH
67915: LD_INT 1
67917: NEG
67918: PUSH
67919: LD_INT 0
67921: PUSH
67922: EMPTY
67923: LIST
67924: LIST
67925: PUSH
67926: LD_INT 1
67928: NEG
67929: PUSH
67930: LD_INT 1
67932: NEG
67933: PUSH
67934: EMPTY
67935: LIST
67936: LIST
67937: PUSH
67938: LD_INT 1
67940: NEG
67941: PUSH
67942: LD_INT 2
67944: NEG
67945: PUSH
67946: EMPTY
67947: LIST
67948: LIST
67949: PUSH
67950: LD_INT 0
67952: PUSH
67953: LD_INT 2
67955: NEG
67956: PUSH
67957: EMPTY
67958: LIST
67959: LIST
67960: PUSH
67961: LD_INT 1
67963: PUSH
67964: LD_INT 1
67966: NEG
67967: PUSH
67968: EMPTY
67969: LIST
67970: LIST
67971: PUSH
67972: LD_INT 2
67974: PUSH
67975: LD_INT 0
67977: PUSH
67978: EMPTY
67979: LIST
67980: LIST
67981: PUSH
67982: LD_INT 2
67984: PUSH
67985: LD_INT 1
67987: PUSH
67988: EMPTY
67989: LIST
67990: LIST
67991: PUSH
67992: LD_INT 2
67994: PUSH
67995: LD_INT 2
67997: PUSH
67998: EMPTY
67999: LIST
68000: LIST
68001: PUSH
68002: LD_INT 1
68004: PUSH
68005: LD_INT 2
68007: PUSH
68008: EMPTY
68009: LIST
68010: LIST
68011: PUSH
68012: LD_INT 0
68014: PUSH
68015: LD_INT 2
68017: PUSH
68018: EMPTY
68019: LIST
68020: LIST
68021: PUSH
68022: LD_INT 1
68024: NEG
68025: PUSH
68026: LD_INT 1
68028: PUSH
68029: EMPTY
68030: LIST
68031: LIST
68032: PUSH
68033: LD_INT 2
68035: NEG
68036: PUSH
68037: LD_INT 0
68039: PUSH
68040: EMPTY
68041: LIST
68042: LIST
68043: PUSH
68044: LD_INT 2
68046: NEG
68047: PUSH
68048: LD_INT 1
68050: NEG
68051: PUSH
68052: EMPTY
68053: LIST
68054: LIST
68055: PUSH
68056: LD_INT 2
68058: NEG
68059: PUSH
68060: LD_INT 2
68062: NEG
68063: PUSH
68064: EMPTY
68065: LIST
68066: LIST
68067: PUSH
68068: EMPTY
68069: LIST
68070: LIST
68071: LIST
68072: LIST
68073: LIST
68074: LIST
68075: LIST
68076: LIST
68077: LIST
68078: LIST
68079: LIST
68080: LIST
68081: LIST
68082: LIST
68083: LIST
68084: LIST
68085: LIST
68086: LIST
68087: LIST
68088: ST_TO_ADDR
// DepotAr3 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
68089: LD_ADDR_VAR 0 20
68093: PUSH
68094: LD_INT 0
68096: PUSH
68097: LD_INT 0
68099: PUSH
68100: EMPTY
68101: LIST
68102: LIST
68103: PUSH
68104: LD_INT 0
68106: PUSH
68107: LD_INT 1
68109: NEG
68110: PUSH
68111: EMPTY
68112: LIST
68113: LIST
68114: PUSH
68115: LD_INT 1
68117: PUSH
68118: LD_INT 0
68120: PUSH
68121: EMPTY
68122: LIST
68123: LIST
68124: PUSH
68125: LD_INT 1
68127: PUSH
68128: LD_INT 1
68130: PUSH
68131: EMPTY
68132: LIST
68133: LIST
68134: PUSH
68135: LD_INT 0
68137: PUSH
68138: LD_INT 1
68140: PUSH
68141: EMPTY
68142: LIST
68143: LIST
68144: PUSH
68145: LD_INT 1
68147: NEG
68148: PUSH
68149: LD_INT 0
68151: PUSH
68152: EMPTY
68153: LIST
68154: LIST
68155: PUSH
68156: LD_INT 1
68158: NEG
68159: PUSH
68160: LD_INT 1
68162: NEG
68163: PUSH
68164: EMPTY
68165: LIST
68166: LIST
68167: PUSH
68168: LD_INT 1
68170: NEG
68171: PUSH
68172: LD_INT 2
68174: NEG
68175: PUSH
68176: EMPTY
68177: LIST
68178: LIST
68179: PUSH
68180: LD_INT 0
68182: PUSH
68183: LD_INT 2
68185: NEG
68186: PUSH
68187: EMPTY
68188: LIST
68189: LIST
68190: PUSH
68191: LD_INT 1
68193: PUSH
68194: LD_INT 1
68196: NEG
68197: PUSH
68198: EMPTY
68199: LIST
68200: LIST
68201: PUSH
68202: LD_INT 2
68204: PUSH
68205: LD_INT 0
68207: PUSH
68208: EMPTY
68209: LIST
68210: LIST
68211: PUSH
68212: LD_INT 2
68214: PUSH
68215: LD_INT 1
68217: PUSH
68218: EMPTY
68219: LIST
68220: LIST
68221: PUSH
68222: LD_INT 2
68224: PUSH
68225: LD_INT 2
68227: PUSH
68228: EMPTY
68229: LIST
68230: LIST
68231: PUSH
68232: LD_INT 1
68234: PUSH
68235: LD_INT 2
68237: PUSH
68238: EMPTY
68239: LIST
68240: LIST
68241: PUSH
68242: LD_INT 0
68244: PUSH
68245: LD_INT 2
68247: PUSH
68248: EMPTY
68249: LIST
68250: LIST
68251: PUSH
68252: LD_INT 1
68254: NEG
68255: PUSH
68256: LD_INT 1
68258: PUSH
68259: EMPTY
68260: LIST
68261: LIST
68262: PUSH
68263: LD_INT 2
68265: NEG
68266: PUSH
68267: LD_INT 0
68269: PUSH
68270: EMPTY
68271: LIST
68272: LIST
68273: PUSH
68274: LD_INT 2
68276: NEG
68277: PUSH
68278: LD_INT 1
68280: NEG
68281: PUSH
68282: EMPTY
68283: LIST
68284: LIST
68285: PUSH
68286: LD_INT 2
68288: NEG
68289: PUSH
68290: LD_INT 2
68292: NEG
68293: PUSH
68294: EMPTY
68295: LIST
68296: LIST
68297: PUSH
68298: EMPTY
68299: LIST
68300: LIST
68301: LIST
68302: LIST
68303: LIST
68304: LIST
68305: LIST
68306: LIST
68307: LIST
68308: LIST
68309: LIST
68310: LIST
68311: LIST
68312: LIST
68313: LIST
68314: LIST
68315: LIST
68316: LIST
68317: LIST
68318: ST_TO_ADDR
// DepotAr4 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
68319: LD_ADDR_VAR 0 21
68323: PUSH
68324: LD_INT 0
68326: PUSH
68327: LD_INT 0
68329: PUSH
68330: EMPTY
68331: LIST
68332: LIST
68333: PUSH
68334: LD_INT 0
68336: PUSH
68337: LD_INT 1
68339: NEG
68340: PUSH
68341: EMPTY
68342: LIST
68343: LIST
68344: PUSH
68345: LD_INT 1
68347: PUSH
68348: LD_INT 0
68350: PUSH
68351: EMPTY
68352: LIST
68353: LIST
68354: PUSH
68355: LD_INT 1
68357: PUSH
68358: LD_INT 1
68360: PUSH
68361: EMPTY
68362: LIST
68363: LIST
68364: PUSH
68365: LD_INT 0
68367: PUSH
68368: LD_INT 1
68370: PUSH
68371: EMPTY
68372: LIST
68373: LIST
68374: PUSH
68375: LD_INT 1
68377: NEG
68378: PUSH
68379: LD_INT 0
68381: PUSH
68382: EMPTY
68383: LIST
68384: LIST
68385: PUSH
68386: LD_INT 1
68388: NEG
68389: PUSH
68390: LD_INT 1
68392: NEG
68393: PUSH
68394: EMPTY
68395: LIST
68396: LIST
68397: PUSH
68398: LD_INT 1
68400: NEG
68401: PUSH
68402: LD_INT 2
68404: NEG
68405: PUSH
68406: EMPTY
68407: LIST
68408: LIST
68409: PUSH
68410: LD_INT 0
68412: PUSH
68413: LD_INT 2
68415: NEG
68416: PUSH
68417: EMPTY
68418: LIST
68419: LIST
68420: PUSH
68421: LD_INT 1
68423: PUSH
68424: LD_INT 1
68426: NEG
68427: PUSH
68428: EMPTY
68429: LIST
68430: LIST
68431: PUSH
68432: LD_INT 2
68434: PUSH
68435: LD_INT 0
68437: PUSH
68438: EMPTY
68439: LIST
68440: LIST
68441: PUSH
68442: LD_INT 2
68444: PUSH
68445: LD_INT 1
68447: PUSH
68448: EMPTY
68449: LIST
68450: LIST
68451: PUSH
68452: LD_INT 2
68454: PUSH
68455: LD_INT 2
68457: PUSH
68458: EMPTY
68459: LIST
68460: LIST
68461: PUSH
68462: LD_INT 1
68464: PUSH
68465: LD_INT 2
68467: PUSH
68468: EMPTY
68469: LIST
68470: LIST
68471: PUSH
68472: LD_INT 0
68474: PUSH
68475: LD_INT 2
68477: PUSH
68478: EMPTY
68479: LIST
68480: LIST
68481: PUSH
68482: LD_INT 1
68484: NEG
68485: PUSH
68486: LD_INT 1
68488: PUSH
68489: EMPTY
68490: LIST
68491: LIST
68492: PUSH
68493: LD_INT 2
68495: NEG
68496: PUSH
68497: LD_INT 0
68499: PUSH
68500: EMPTY
68501: LIST
68502: LIST
68503: PUSH
68504: LD_INT 2
68506: NEG
68507: PUSH
68508: LD_INT 1
68510: NEG
68511: PUSH
68512: EMPTY
68513: LIST
68514: LIST
68515: PUSH
68516: LD_INT 2
68518: NEG
68519: PUSH
68520: LD_INT 2
68522: NEG
68523: PUSH
68524: EMPTY
68525: LIST
68526: LIST
68527: PUSH
68528: EMPTY
68529: LIST
68530: LIST
68531: LIST
68532: LIST
68533: LIST
68534: LIST
68535: LIST
68536: LIST
68537: LIST
68538: LIST
68539: LIST
68540: LIST
68541: LIST
68542: LIST
68543: LIST
68544: LIST
68545: LIST
68546: LIST
68547: LIST
68548: ST_TO_ADDR
// DepotAr5 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
68549: LD_ADDR_VAR 0 22
68553: PUSH
68554: LD_INT 0
68556: PUSH
68557: LD_INT 0
68559: PUSH
68560: EMPTY
68561: LIST
68562: LIST
68563: PUSH
68564: LD_INT 0
68566: PUSH
68567: LD_INT 1
68569: NEG
68570: PUSH
68571: EMPTY
68572: LIST
68573: LIST
68574: PUSH
68575: LD_INT 1
68577: PUSH
68578: LD_INT 0
68580: PUSH
68581: EMPTY
68582: LIST
68583: LIST
68584: PUSH
68585: LD_INT 1
68587: PUSH
68588: LD_INT 1
68590: PUSH
68591: EMPTY
68592: LIST
68593: LIST
68594: PUSH
68595: LD_INT 0
68597: PUSH
68598: LD_INT 1
68600: PUSH
68601: EMPTY
68602: LIST
68603: LIST
68604: PUSH
68605: LD_INT 1
68607: NEG
68608: PUSH
68609: LD_INT 0
68611: PUSH
68612: EMPTY
68613: LIST
68614: LIST
68615: PUSH
68616: LD_INT 1
68618: NEG
68619: PUSH
68620: LD_INT 1
68622: NEG
68623: PUSH
68624: EMPTY
68625: LIST
68626: LIST
68627: PUSH
68628: LD_INT 1
68630: NEG
68631: PUSH
68632: LD_INT 2
68634: NEG
68635: PUSH
68636: EMPTY
68637: LIST
68638: LIST
68639: PUSH
68640: LD_INT 0
68642: PUSH
68643: LD_INT 2
68645: NEG
68646: PUSH
68647: EMPTY
68648: LIST
68649: LIST
68650: PUSH
68651: LD_INT 1
68653: PUSH
68654: LD_INT 1
68656: NEG
68657: PUSH
68658: EMPTY
68659: LIST
68660: LIST
68661: PUSH
68662: LD_INT 2
68664: PUSH
68665: LD_INT 0
68667: PUSH
68668: EMPTY
68669: LIST
68670: LIST
68671: PUSH
68672: LD_INT 2
68674: PUSH
68675: LD_INT 1
68677: PUSH
68678: EMPTY
68679: LIST
68680: LIST
68681: PUSH
68682: LD_INT 2
68684: PUSH
68685: LD_INT 2
68687: PUSH
68688: EMPTY
68689: LIST
68690: LIST
68691: PUSH
68692: LD_INT 1
68694: PUSH
68695: LD_INT 2
68697: PUSH
68698: EMPTY
68699: LIST
68700: LIST
68701: PUSH
68702: LD_INT 0
68704: PUSH
68705: LD_INT 2
68707: PUSH
68708: EMPTY
68709: LIST
68710: LIST
68711: PUSH
68712: LD_INT 1
68714: NEG
68715: PUSH
68716: LD_INT 1
68718: PUSH
68719: EMPTY
68720: LIST
68721: LIST
68722: PUSH
68723: LD_INT 2
68725: NEG
68726: PUSH
68727: LD_INT 0
68729: PUSH
68730: EMPTY
68731: LIST
68732: LIST
68733: PUSH
68734: LD_INT 2
68736: NEG
68737: PUSH
68738: LD_INT 1
68740: NEG
68741: PUSH
68742: EMPTY
68743: LIST
68744: LIST
68745: PUSH
68746: LD_INT 2
68748: NEG
68749: PUSH
68750: LD_INT 2
68752: NEG
68753: PUSH
68754: EMPTY
68755: LIST
68756: LIST
68757: PUSH
68758: EMPTY
68759: LIST
68760: LIST
68761: LIST
68762: LIST
68763: LIST
68764: LIST
68765: LIST
68766: LIST
68767: LIST
68768: LIST
68769: LIST
68770: LIST
68771: LIST
68772: LIST
68773: LIST
68774: LIST
68775: LIST
68776: LIST
68777: LIST
68778: ST_TO_ADDR
// DepotRu0 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ - 2 , - 3 ] , [ - 1 , - 3 ] , [ 1 , - 2 ] , [ 2 , - 1 ] ] ;
68779: LD_ADDR_VAR 0 23
68783: PUSH
68784: LD_INT 0
68786: PUSH
68787: LD_INT 0
68789: PUSH
68790: EMPTY
68791: LIST
68792: LIST
68793: PUSH
68794: LD_INT 0
68796: PUSH
68797: LD_INT 1
68799: NEG
68800: PUSH
68801: EMPTY
68802: LIST
68803: LIST
68804: PUSH
68805: LD_INT 1
68807: PUSH
68808: LD_INT 0
68810: PUSH
68811: EMPTY
68812: LIST
68813: LIST
68814: PUSH
68815: LD_INT 1
68817: PUSH
68818: LD_INT 1
68820: PUSH
68821: EMPTY
68822: LIST
68823: LIST
68824: PUSH
68825: LD_INT 0
68827: PUSH
68828: LD_INT 1
68830: PUSH
68831: EMPTY
68832: LIST
68833: LIST
68834: PUSH
68835: LD_INT 1
68837: NEG
68838: PUSH
68839: LD_INT 0
68841: PUSH
68842: EMPTY
68843: LIST
68844: LIST
68845: PUSH
68846: LD_INT 1
68848: NEG
68849: PUSH
68850: LD_INT 1
68852: NEG
68853: PUSH
68854: EMPTY
68855: LIST
68856: LIST
68857: PUSH
68858: LD_INT 1
68860: NEG
68861: PUSH
68862: LD_INT 2
68864: NEG
68865: PUSH
68866: EMPTY
68867: LIST
68868: LIST
68869: PUSH
68870: LD_INT 0
68872: PUSH
68873: LD_INT 2
68875: NEG
68876: PUSH
68877: EMPTY
68878: LIST
68879: LIST
68880: PUSH
68881: LD_INT 1
68883: PUSH
68884: LD_INT 1
68886: NEG
68887: PUSH
68888: EMPTY
68889: LIST
68890: LIST
68891: PUSH
68892: LD_INT 2
68894: PUSH
68895: LD_INT 0
68897: PUSH
68898: EMPTY
68899: LIST
68900: LIST
68901: PUSH
68902: LD_INT 2
68904: PUSH
68905: LD_INT 1
68907: PUSH
68908: EMPTY
68909: LIST
68910: LIST
68911: PUSH
68912: LD_INT 2
68914: PUSH
68915: LD_INT 2
68917: PUSH
68918: EMPTY
68919: LIST
68920: LIST
68921: PUSH
68922: LD_INT 1
68924: PUSH
68925: LD_INT 2
68927: PUSH
68928: EMPTY
68929: LIST
68930: LIST
68931: PUSH
68932: LD_INT 0
68934: PUSH
68935: LD_INT 2
68937: PUSH
68938: EMPTY
68939: LIST
68940: LIST
68941: PUSH
68942: LD_INT 1
68944: NEG
68945: PUSH
68946: LD_INT 1
68948: PUSH
68949: EMPTY
68950: LIST
68951: LIST
68952: PUSH
68953: LD_INT 2
68955: NEG
68956: PUSH
68957: LD_INT 0
68959: PUSH
68960: EMPTY
68961: LIST
68962: LIST
68963: PUSH
68964: LD_INT 2
68966: NEG
68967: PUSH
68968: LD_INT 1
68970: NEG
68971: PUSH
68972: EMPTY
68973: LIST
68974: LIST
68975: PUSH
68976: LD_INT 2
68978: NEG
68979: PUSH
68980: LD_INT 2
68982: NEG
68983: PUSH
68984: EMPTY
68985: LIST
68986: LIST
68987: PUSH
68988: LD_INT 2
68990: NEG
68991: PUSH
68992: LD_INT 3
68994: NEG
68995: PUSH
68996: EMPTY
68997: LIST
68998: LIST
68999: PUSH
69000: LD_INT 1
69002: NEG
69003: PUSH
69004: LD_INT 3
69006: NEG
69007: PUSH
69008: EMPTY
69009: LIST
69010: LIST
69011: PUSH
69012: LD_INT 1
69014: PUSH
69015: LD_INT 2
69017: NEG
69018: PUSH
69019: EMPTY
69020: LIST
69021: LIST
69022: PUSH
69023: LD_INT 2
69025: PUSH
69026: LD_INT 1
69028: NEG
69029: PUSH
69030: EMPTY
69031: LIST
69032: LIST
69033: PUSH
69034: EMPTY
69035: LIST
69036: LIST
69037: LIST
69038: LIST
69039: LIST
69040: LIST
69041: LIST
69042: LIST
69043: LIST
69044: LIST
69045: LIST
69046: LIST
69047: LIST
69048: LIST
69049: LIST
69050: LIST
69051: LIST
69052: LIST
69053: LIST
69054: LIST
69055: LIST
69056: LIST
69057: LIST
69058: ST_TO_ADDR
// DepotRu1 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ 1 , - 2 ] , [ 2 , - 1 ] , [ 3 , 1 ] , [ 3 , 2 ] ] ;
69059: LD_ADDR_VAR 0 24
69063: PUSH
69064: LD_INT 0
69066: PUSH
69067: LD_INT 0
69069: PUSH
69070: EMPTY
69071: LIST
69072: LIST
69073: PUSH
69074: LD_INT 0
69076: PUSH
69077: LD_INT 1
69079: NEG
69080: PUSH
69081: EMPTY
69082: LIST
69083: LIST
69084: PUSH
69085: LD_INT 1
69087: PUSH
69088: LD_INT 0
69090: PUSH
69091: EMPTY
69092: LIST
69093: LIST
69094: PUSH
69095: LD_INT 1
69097: PUSH
69098: LD_INT 1
69100: PUSH
69101: EMPTY
69102: LIST
69103: LIST
69104: PUSH
69105: LD_INT 0
69107: PUSH
69108: LD_INT 1
69110: PUSH
69111: EMPTY
69112: LIST
69113: LIST
69114: PUSH
69115: LD_INT 1
69117: NEG
69118: PUSH
69119: LD_INT 0
69121: PUSH
69122: EMPTY
69123: LIST
69124: LIST
69125: PUSH
69126: LD_INT 1
69128: NEG
69129: PUSH
69130: LD_INT 1
69132: NEG
69133: PUSH
69134: EMPTY
69135: LIST
69136: LIST
69137: PUSH
69138: LD_INT 1
69140: NEG
69141: PUSH
69142: LD_INT 2
69144: NEG
69145: PUSH
69146: EMPTY
69147: LIST
69148: LIST
69149: PUSH
69150: LD_INT 0
69152: PUSH
69153: LD_INT 2
69155: NEG
69156: PUSH
69157: EMPTY
69158: LIST
69159: LIST
69160: PUSH
69161: LD_INT 1
69163: PUSH
69164: LD_INT 1
69166: NEG
69167: PUSH
69168: EMPTY
69169: LIST
69170: LIST
69171: PUSH
69172: LD_INT 2
69174: PUSH
69175: LD_INT 0
69177: PUSH
69178: EMPTY
69179: LIST
69180: LIST
69181: PUSH
69182: LD_INT 2
69184: PUSH
69185: LD_INT 1
69187: PUSH
69188: EMPTY
69189: LIST
69190: LIST
69191: PUSH
69192: LD_INT 2
69194: PUSH
69195: LD_INT 2
69197: PUSH
69198: EMPTY
69199: LIST
69200: LIST
69201: PUSH
69202: LD_INT 1
69204: PUSH
69205: LD_INT 2
69207: PUSH
69208: EMPTY
69209: LIST
69210: LIST
69211: PUSH
69212: LD_INT 0
69214: PUSH
69215: LD_INT 2
69217: PUSH
69218: EMPTY
69219: LIST
69220: LIST
69221: PUSH
69222: LD_INT 1
69224: NEG
69225: PUSH
69226: LD_INT 1
69228: PUSH
69229: EMPTY
69230: LIST
69231: LIST
69232: PUSH
69233: LD_INT 2
69235: NEG
69236: PUSH
69237: LD_INT 0
69239: PUSH
69240: EMPTY
69241: LIST
69242: LIST
69243: PUSH
69244: LD_INT 2
69246: NEG
69247: PUSH
69248: LD_INT 1
69250: NEG
69251: PUSH
69252: EMPTY
69253: LIST
69254: LIST
69255: PUSH
69256: LD_INT 2
69258: NEG
69259: PUSH
69260: LD_INT 2
69262: NEG
69263: PUSH
69264: EMPTY
69265: LIST
69266: LIST
69267: PUSH
69268: LD_INT 1
69270: PUSH
69271: LD_INT 2
69273: NEG
69274: PUSH
69275: EMPTY
69276: LIST
69277: LIST
69278: PUSH
69279: LD_INT 2
69281: PUSH
69282: LD_INT 1
69284: NEG
69285: PUSH
69286: EMPTY
69287: LIST
69288: LIST
69289: PUSH
69290: LD_INT 3
69292: PUSH
69293: LD_INT 1
69295: PUSH
69296: EMPTY
69297: LIST
69298: LIST
69299: PUSH
69300: LD_INT 3
69302: PUSH
69303: LD_INT 2
69305: PUSH
69306: EMPTY
69307: LIST
69308: LIST
69309: PUSH
69310: EMPTY
69311: LIST
69312: LIST
69313: LIST
69314: LIST
69315: LIST
69316: LIST
69317: LIST
69318: LIST
69319: LIST
69320: LIST
69321: LIST
69322: LIST
69323: LIST
69324: LIST
69325: LIST
69326: LIST
69327: LIST
69328: LIST
69329: LIST
69330: LIST
69331: LIST
69332: LIST
69333: LIST
69334: ST_TO_ADDR
// DepotRu2 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ 3 , 1 ] , [ 3 , 2 ] , [ 2 , 3 ] , [ 1 , 3 ] ] ;
69335: LD_ADDR_VAR 0 25
69339: PUSH
69340: LD_INT 0
69342: PUSH
69343: LD_INT 0
69345: PUSH
69346: EMPTY
69347: LIST
69348: LIST
69349: PUSH
69350: LD_INT 0
69352: PUSH
69353: LD_INT 1
69355: NEG
69356: PUSH
69357: EMPTY
69358: LIST
69359: LIST
69360: PUSH
69361: LD_INT 1
69363: PUSH
69364: LD_INT 0
69366: PUSH
69367: EMPTY
69368: LIST
69369: LIST
69370: PUSH
69371: LD_INT 1
69373: PUSH
69374: LD_INT 1
69376: PUSH
69377: EMPTY
69378: LIST
69379: LIST
69380: PUSH
69381: LD_INT 0
69383: PUSH
69384: LD_INT 1
69386: PUSH
69387: EMPTY
69388: LIST
69389: LIST
69390: PUSH
69391: LD_INT 1
69393: NEG
69394: PUSH
69395: LD_INT 0
69397: PUSH
69398: EMPTY
69399: LIST
69400: LIST
69401: PUSH
69402: LD_INT 1
69404: NEG
69405: PUSH
69406: LD_INT 1
69408: NEG
69409: PUSH
69410: EMPTY
69411: LIST
69412: LIST
69413: PUSH
69414: LD_INT 1
69416: NEG
69417: PUSH
69418: LD_INT 2
69420: NEG
69421: PUSH
69422: EMPTY
69423: LIST
69424: LIST
69425: PUSH
69426: LD_INT 0
69428: PUSH
69429: LD_INT 2
69431: NEG
69432: PUSH
69433: EMPTY
69434: LIST
69435: LIST
69436: PUSH
69437: LD_INT 1
69439: PUSH
69440: LD_INT 1
69442: NEG
69443: PUSH
69444: EMPTY
69445: LIST
69446: LIST
69447: PUSH
69448: LD_INT 2
69450: PUSH
69451: LD_INT 0
69453: PUSH
69454: EMPTY
69455: LIST
69456: LIST
69457: PUSH
69458: LD_INT 2
69460: PUSH
69461: LD_INT 1
69463: PUSH
69464: EMPTY
69465: LIST
69466: LIST
69467: PUSH
69468: LD_INT 2
69470: PUSH
69471: LD_INT 2
69473: PUSH
69474: EMPTY
69475: LIST
69476: LIST
69477: PUSH
69478: LD_INT 1
69480: PUSH
69481: LD_INT 2
69483: PUSH
69484: EMPTY
69485: LIST
69486: LIST
69487: PUSH
69488: LD_INT 0
69490: PUSH
69491: LD_INT 2
69493: PUSH
69494: EMPTY
69495: LIST
69496: LIST
69497: PUSH
69498: LD_INT 1
69500: NEG
69501: PUSH
69502: LD_INT 1
69504: PUSH
69505: EMPTY
69506: LIST
69507: LIST
69508: PUSH
69509: LD_INT 2
69511: NEG
69512: PUSH
69513: LD_INT 0
69515: PUSH
69516: EMPTY
69517: LIST
69518: LIST
69519: PUSH
69520: LD_INT 2
69522: NEG
69523: PUSH
69524: LD_INT 1
69526: NEG
69527: PUSH
69528: EMPTY
69529: LIST
69530: LIST
69531: PUSH
69532: LD_INT 2
69534: NEG
69535: PUSH
69536: LD_INT 2
69538: NEG
69539: PUSH
69540: EMPTY
69541: LIST
69542: LIST
69543: PUSH
69544: LD_INT 3
69546: PUSH
69547: LD_INT 1
69549: PUSH
69550: EMPTY
69551: LIST
69552: LIST
69553: PUSH
69554: LD_INT 3
69556: PUSH
69557: LD_INT 2
69559: PUSH
69560: EMPTY
69561: LIST
69562: LIST
69563: PUSH
69564: LD_INT 2
69566: PUSH
69567: LD_INT 3
69569: PUSH
69570: EMPTY
69571: LIST
69572: LIST
69573: PUSH
69574: LD_INT 1
69576: PUSH
69577: LD_INT 3
69579: PUSH
69580: EMPTY
69581: LIST
69582: LIST
69583: PUSH
69584: EMPTY
69585: LIST
69586: LIST
69587: LIST
69588: LIST
69589: LIST
69590: LIST
69591: LIST
69592: LIST
69593: LIST
69594: LIST
69595: LIST
69596: LIST
69597: LIST
69598: LIST
69599: LIST
69600: LIST
69601: LIST
69602: LIST
69603: LIST
69604: LIST
69605: LIST
69606: LIST
69607: LIST
69608: ST_TO_ADDR
// DepotRu3 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ 2 , 3 ] , [ 1 , 3 ] , [ - 1 , 2 ] , [ - 2 , 1 ] ] ;
69609: LD_ADDR_VAR 0 26
69613: PUSH
69614: LD_INT 0
69616: PUSH
69617: LD_INT 0
69619: PUSH
69620: EMPTY
69621: LIST
69622: LIST
69623: PUSH
69624: LD_INT 0
69626: PUSH
69627: LD_INT 1
69629: NEG
69630: PUSH
69631: EMPTY
69632: LIST
69633: LIST
69634: PUSH
69635: LD_INT 1
69637: PUSH
69638: LD_INT 0
69640: PUSH
69641: EMPTY
69642: LIST
69643: LIST
69644: PUSH
69645: LD_INT 1
69647: PUSH
69648: LD_INT 1
69650: PUSH
69651: EMPTY
69652: LIST
69653: LIST
69654: PUSH
69655: LD_INT 0
69657: PUSH
69658: LD_INT 1
69660: PUSH
69661: EMPTY
69662: LIST
69663: LIST
69664: PUSH
69665: LD_INT 1
69667: NEG
69668: PUSH
69669: LD_INT 0
69671: PUSH
69672: EMPTY
69673: LIST
69674: LIST
69675: PUSH
69676: LD_INT 1
69678: NEG
69679: PUSH
69680: LD_INT 1
69682: NEG
69683: PUSH
69684: EMPTY
69685: LIST
69686: LIST
69687: PUSH
69688: LD_INT 1
69690: NEG
69691: PUSH
69692: LD_INT 2
69694: NEG
69695: PUSH
69696: EMPTY
69697: LIST
69698: LIST
69699: PUSH
69700: LD_INT 0
69702: PUSH
69703: LD_INT 2
69705: NEG
69706: PUSH
69707: EMPTY
69708: LIST
69709: LIST
69710: PUSH
69711: LD_INT 1
69713: PUSH
69714: LD_INT 1
69716: NEG
69717: PUSH
69718: EMPTY
69719: LIST
69720: LIST
69721: PUSH
69722: LD_INT 2
69724: PUSH
69725: LD_INT 0
69727: PUSH
69728: EMPTY
69729: LIST
69730: LIST
69731: PUSH
69732: LD_INT 2
69734: PUSH
69735: LD_INT 1
69737: PUSH
69738: EMPTY
69739: LIST
69740: LIST
69741: PUSH
69742: LD_INT 2
69744: PUSH
69745: LD_INT 2
69747: PUSH
69748: EMPTY
69749: LIST
69750: LIST
69751: PUSH
69752: LD_INT 1
69754: PUSH
69755: LD_INT 2
69757: PUSH
69758: EMPTY
69759: LIST
69760: LIST
69761: PUSH
69762: LD_INT 0
69764: PUSH
69765: LD_INT 2
69767: PUSH
69768: EMPTY
69769: LIST
69770: LIST
69771: PUSH
69772: LD_INT 1
69774: NEG
69775: PUSH
69776: LD_INT 1
69778: PUSH
69779: EMPTY
69780: LIST
69781: LIST
69782: PUSH
69783: LD_INT 2
69785: NEG
69786: PUSH
69787: LD_INT 0
69789: PUSH
69790: EMPTY
69791: LIST
69792: LIST
69793: PUSH
69794: LD_INT 2
69796: NEG
69797: PUSH
69798: LD_INT 1
69800: NEG
69801: PUSH
69802: EMPTY
69803: LIST
69804: LIST
69805: PUSH
69806: LD_INT 2
69808: NEG
69809: PUSH
69810: LD_INT 2
69812: NEG
69813: PUSH
69814: EMPTY
69815: LIST
69816: LIST
69817: PUSH
69818: LD_INT 2
69820: PUSH
69821: LD_INT 3
69823: PUSH
69824: EMPTY
69825: LIST
69826: LIST
69827: PUSH
69828: LD_INT 1
69830: PUSH
69831: LD_INT 3
69833: PUSH
69834: EMPTY
69835: LIST
69836: LIST
69837: PUSH
69838: LD_INT 1
69840: NEG
69841: PUSH
69842: LD_INT 2
69844: PUSH
69845: EMPTY
69846: LIST
69847: LIST
69848: PUSH
69849: LD_INT 2
69851: NEG
69852: PUSH
69853: LD_INT 1
69855: PUSH
69856: EMPTY
69857: LIST
69858: LIST
69859: PUSH
69860: EMPTY
69861: LIST
69862: LIST
69863: LIST
69864: LIST
69865: LIST
69866: LIST
69867: LIST
69868: LIST
69869: LIST
69870: LIST
69871: LIST
69872: LIST
69873: LIST
69874: LIST
69875: LIST
69876: LIST
69877: LIST
69878: LIST
69879: LIST
69880: LIST
69881: LIST
69882: LIST
69883: LIST
69884: ST_TO_ADDR
// DepotRu4 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ - 1 , 2 ] , [ - 2 , 1 ] , [ - 3 , - 1 ] , [ - 3 , - 2 ] ] ;
69885: LD_ADDR_VAR 0 27
69889: PUSH
69890: LD_INT 0
69892: PUSH
69893: LD_INT 0
69895: PUSH
69896: EMPTY
69897: LIST
69898: LIST
69899: PUSH
69900: LD_INT 0
69902: PUSH
69903: LD_INT 1
69905: NEG
69906: PUSH
69907: EMPTY
69908: LIST
69909: LIST
69910: PUSH
69911: LD_INT 1
69913: PUSH
69914: LD_INT 0
69916: PUSH
69917: EMPTY
69918: LIST
69919: LIST
69920: PUSH
69921: LD_INT 1
69923: PUSH
69924: LD_INT 1
69926: PUSH
69927: EMPTY
69928: LIST
69929: LIST
69930: PUSH
69931: LD_INT 0
69933: PUSH
69934: LD_INT 1
69936: PUSH
69937: EMPTY
69938: LIST
69939: LIST
69940: PUSH
69941: LD_INT 1
69943: NEG
69944: PUSH
69945: LD_INT 0
69947: PUSH
69948: EMPTY
69949: LIST
69950: LIST
69951: PUSH
69952: LD_INT 1
69954: NEG
69955: PUSH
69956: LD_INT 1
69958: NEG
69959: PUSH
69960: EMPTY
69961: LIST
69962: LIST
69963: PUSH
69964: LD_INT 1
69966: NEG
69967: PUSH
69968: LD_INT 2
69970: NEG
69971: PUSH
69972: EMPTY
69973: LIST
69974: LIST
69975: PUSH
69976: LD_INT 0
69978: PUSH
69979: LD_INT 2
69981: NEG
69982: PUSH
69983: EMPTY
69984: LIST
69985: LIST
69986: PUSH
69987: LD_INT 1
69989: PUSH
69990: LD_INT 1
69992: NEG
69993: PUSH
69994: EMPTY
69995: LIST
69996: LIST
69997: PUSH
69998: LD_INT 2
70000: PUSH
70001: LD_INT 0
70003: PUSH
70004: EMPTY
70005: LIST
70006: LIST
70007: PUSH
70008: LD_INT 2
70010: PUSH
70011: LD_INT 1
70013: PUSH
70014: EMPTY
70015: LIST
70016: LIST
70017: PUSH
70018: LD_INT 2
70020: PUSH
70021: LD_INT 2
70023: PUSH
70024: EMPTY
70025: LIST
70026: LIST
70027: PUSH
70028: LD_INT 1
70030: PUSH
70031: LD_INT 2
70033: PUSH
70034: EMPTY
70035: LIST
70036: LIST
70037: PUSH
70038: LD_INT 0
70040: PUSH
70041: LD_INT 2
70043: PUSH
70044: EMPTY
70045: LIST
70046: LIST
70047: PUSH
70048: LD_INT 1
70050: NEG
70051: PUSH
70052: LD_INT 1
70054: PUSH
70055: EMPTY
70056: LIST
70057: LIST
70058: PUSH
70059: LD_INT 2
70061: NEG
70062: PUSH
70063: LD_INT 0
70065: PUSH
70066: EMPTY
70067: LIST
70068: LIST
70069: PUSH
70070: LD_INT 2
70072: NEG
70073: PUSH
70074: LD_INT 1
70076: NEG
70077: PUSH
70078: EMPTY
70079: LIST
70080: LIST
70081: PUSH
70082: LD_INT 2
70084: NEG
70085: PUSH
70086: LD_INT 2
70088: NEG
70089: PUSH
70090: EMPTY
70091: LIST
70092: LIST
70093: PUSH
70094: LD_INT 1
70096: NEG
70097: PUSH
70098: LD_INT 2
70100: PUSH
70101: EMPTY
70102: LIST
70103: LIST
70104: PUSH
70105: LD_INT 2
70107: NEG
70108: PUSH
70109: LD_INT 1
70111: PUSH
70112: EMPTY
70113: LIST
70114: LIST
70115: PUSH
70116: LD_INT 3
70118: NEG
70119: PUSH
70120: LD_INT 1
70122: NEG
70123: PUSH
70124: EMPTY
70125: LIST
70126: LIST
70127: PUSH
70128: LD_INT 3
70130: NEG
70131: PUSH
70132: LD_INT 2
70134: NEG
70135: PUSH
70136: EMPTY
70137: LIST
70138: LIST
70139: PUSH
70140: EMPTY
70141: LIST
70142: LIST
70143: LIST
70144: LIST
70145: LIST
70146: LIST
70147: LIST
70148: LIST
70149: LIST
70150: LIST
70151: LIST
70152: LIST
70153: LIST
70154: LIST
70155: LIST
70156: LIST
70157: LIST
70158: LIST
70159: LIST
70160: LIST
70161: LIST
70162: LIST
70163: LIST
70164: ST_TO_ADDR
// DepotRu5 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ - 2 , - 3 ] , [ - 1 , - 3 ] , [ - 3 , - 1 ] , [ - 3 , - 2 ] ] ;
70165: LD_ADDR_VAR 0 28
70169: PUSH
70170: LD_INT 0
70172: PUSH
70173: LD_INT 0
70175: PUSH
70176: EMPTY
70177: LIST
70178: LIST
70179: PUSH
70180: LD_INT 0
70182: PUSH
70183: LD_INT 1
70185: NEG
70186: PUSH
70187: EMPTY
70188: LIST
70189: LIST
70190: PUSH
70191: LD_INT 1
70193: PUSH
70194: LD_INT 0
70196: PUSH
70197: EMPTY
70198: LIST
70199: LIST
70200: PUSH
70201: LD_INT 1
70203: PUSH
70204: LD_INT 1
70206: PUSH
70207: EMPTY
70208: LIST
70209: LIST
70210: PUSH
70211: LD_INT 0
70213: PUSH
70214: LD_INT 1
70216: PUSH
70217: EMPTY
70218: LIST
70219: LIST
70220: PUSH
70221: LD_INT 1
70223: NEG
70224: PUSH
70225: LD_INT 0
70227: PUSH
70228: EMPTY
70229: LIST
70230: LIST
70231: PUSH
70232: LD_INT 1
70234: NEG
70235: PUSH
70236: LD_INT 1
70238: NEG
70239: PUSH
70240: EMPTY
70241: LIST
70242: LIST
70243: PUSH
70244: LD_INT 1
70246: NEG
70247: PUSH
70248: LD_INT 2
70250: NEG
70251: PUSH
70252: EMPTY
70253: LIST
70254: LIST
70255: PUSH
70256: LD_INT 0
70258: PUSH
70259: LD_INT 2
70261: NEG
70262: PUSH
70263: EMPTY
70264: LIST
70265: LIST
70266: PUSH
70267: LD_INT 1
70269: PUSH
70270: LD_INT 1
70272: NEG
70273: PUSH
70274: EMPTY
70275: LIST
70276: LIST
70277: PUSH
70278: LD_INT 2
70280: PUSH
70281: LD_INT 0
70283: PUSH
70284: EMPTY
70285: LIST
70286: LIST
70287: PUSH
70288: LD_INT 2
70290: PUSH
70291: LD_INT 1
70293: PUSH
70294: EMPTY
70295: LIST
70296: LIST
70297: PUSH
70298: LD_INT 2
70300: PUSH
70301: LD_INT 2
70303: PUSH
70304: EMPTY
70305: LIST
70306: LIST
70307: PUSH
70308: LD_INT 1
70310: PUSH
70311: LD_INT 2
70313: PUSH
70314: EMPTY
70315: LIST
70316: LIST
70317: PUSH
70318: LD_INT 0
70320: PUSH
70321: LD_INT 2
70323: PUSH
70324: EMPTY
70325: LIST
70326: LIST
70327: PUSH
70328: LD_INT 1
70330: NEG
70331: PUSH
70332: LD_INT 1
70334: PUSH
70335: EMPTY
70336: LIST
70337: LIST
70338: PUSH
70339: LD_INT 2
70341: NEG
70342: PUSH
70343: LD_INT 0
70345: PUSH
70346: EMPTY
70347: LIST
70348: LIST
70349: PUSH
70350: LD_INT 2
70352: NEG
70353: PUSH
70354: LD_INT 1
70356: NEG
70357: PUSH
70358: EMPTY
70359: LIST
70360: LIST
70361: PUSH
70362: LD_INT 2
70364: NEG
70365: PUSH
70366: LD_INT 2
70368: NEG
70369: PUSH
70370: EMPTY
70371: LIST
70372: LIST
70373: PUSH
70374: LD_INT 2
70376: NEG
70377: PUSH
70378: LD_INT 3
70380: NEG
70381: PUSH
70382: EMPTY
70383: LIST
70384: LIST
70385: PUSH
70386: LD_INT 1
70388: NEG
70389: PUSH
70390: LD_INT 3
70392: NEG
70393: PUSH
70394: EMPTY
70395: LIST
70396: LIST
70397: PUSH
70398: LD_INT 3
70400: NEG
70401: PUSH
70402: LD_INT 1
70404: NEG
70405: PUSH
70406: EMPTY
70407: LIST
70408: LIST
70409: PUSH
70410: LD_INT 3
70412: NEG
70413: PUSH
70414: LD_INT 2
70416: NEG
70417: PUSH
70418: EMPTY
70419: LIST
70420: LIST
70421: PUSH
70422: EMPTY
70423: LIST
70424: LIST
70425: LIST
70426: LIST
70427: LIST
70428: LIST
70429: LIST
70430: LIST
70431: LIST
70432: LIST
70433: LIST
70434: LIST
70435: LIST
70436: LIST
70437: LIST
70438: LIST
70439: LIST
70440: LIST
70441: LIST
70442: LIST
70443: LIST
70444: LIST
70445: LIST
70446: ST_TO_ADDR
// Factory0 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ - 2 , - 3 ] , [ 2 , - 1 ] , [ 3 , 1 ] , [ 1 , 3 ] , [ - 1 , 2 ] , [ - 3 , - 2 ] ] ;
70447: LD_ADDR_VAR 0 29
70451: PUSH
70452: LD_INT 0
70454: PUSH
70455: LD_INT 0
70457: PUSH
70458: EMPTY
70459: LIST
70460: LIST
70461: PUSH
70462: LD_INT 0
70464: PUSH
70465: LD_INT 1
70467: NEG
70468: PUSH
70469: EMPTY
70470: LIST
70471: LIST
70472: PUSH
70473: LD_INT 1
70475: PUSH
70476: LD_INT 0
70478: PUSH
70479: EMPTY
70480: LIST
70481: LIST
70482: PUSH
70483: LD_INT 1
70485: PUSH
70486: LD_INT 1
70488: PUSH
70489: EMPTY
70490: LIST
70491: LIST
70492: PUSH
70493: LD_INT 0
70495: PUSH
70496: LD_INT 1
70498: PUSH
70499: EMPTY
70500: LIST
70501: LIST
70502: PUSH
70503: LD_INT 1
70505: NEG
70506: PUSH
70507: LD_INT 0
70509: PUSH
70510: EMPTY
70511: LIST
70512: LIST
70513: PUSH
70514: LD_INT 1
70516: NEG
70517: PUSH
70518: LD_INT 1
70520: NEG
70521: PUSH
70522: EMPTY
70523: LIST
70524: LIST
70525: PUSH
70526: LD_INT 1
70528: NEG
70529: PUSH
70530: LD_INT 2
70532: NEG
70533: PUSH
70534: EMPTY
70535: LIST
70536: LIST
70537: PUSH
70538: LD_INT 0
70540: PUSH
70541: LD_INT 2
70543: NEG
70544: PUSH
70545: EMPTY
70546: LIST
70547: LIST
70548: PUSH
70549: LD_INT 1
70551: PUSH
70552: LD_INT 1
70554: NEG
70555: PUSH
70556: EMPTY
70557: LIST
70558: LIST
70559: PUSH
70560: LD_INT 2
70562: PUSH
70563: LD_INT 0
70565: PUSH
70566: EMPTY
70567: LIST
70568: LIST
70569: PUSH
70570: LD_INT 2
70572: PUSH
70573: LD_INT 1
70575: PUSH
70576: EMPTY
70577: LIST
70578: LIST
70579: PUSH
70580: LD_INT 1
70582: PUSH
70583: LD_INT 2
70585: PUSH
70586: EMPTY
70587: LIST
70588: LIST
70589: PUSH
70590: LD_INT 0
70592: PUSH
70593: LD_INT 2
70595: PUSH
70596: EMPTY
70597: LIST
70598: LIST
70599: PUSH
70600: LD_INT 1
70602: NEG
70603: PUSH
70604: LD_INT 1
70606: PUSH
70607: EMPTY
70608: LIST
70609: LIST
70610: PUSH
70611: LD_INT 2
70613: NEG
70614: PUSH
70615: LD_INT 1
70617: NEG
70618: PUSH
70619: EMPTY
70620: LIST
70621: LIST
70622: PUSH
70623: LD_INT 2
70625: NEG
70626: PUSH
70627: LD_INT 2
70629: NEG
70630: PUSH
70631: EMPTY
70632: LIST
70633: LIST
70634: PUSH
70635: LD_INT 2
70637: NEG
70638: PUSH
70639: LD_INT 3
70641: NEG
70642: PUSH
70643: EMPTY
70644: LIST
70645: LIST
70646: PUSH
70647: LD_INT 2
70649: PUSH
70650: LD_INT 1
70652: NEG
70653: PUSH
70654: EMPTY
70655: LIST
70656: LIST
70657: PUSH
70658: LD_INT 3
70660: PUSH
70661: LD_INT 1
70663: PUSH
70664: EMPTY
70665: LIST
70666: LIST
70667: PUSH
70668: LD_INT 1
70670: PUSH
70671: LD_INT 3
70673: PUSH
70674: EMPTY
70675: LIST
70676: LIST
70677: PUSH
70678: LD_INT 1
70680: NEG
70681: PUSH
70682: LD_INT 2
70684: PUSH
70685: EMPTY
70686: LIST
70687: LIST
70688: PUSH
70689: LD_INT 3
70691: NEG
70692: PUSH
70693: LD_INT 2
70695: NEG
70696: PUSH
70697: EMPTY
70698: LIST
70699: LIST
70700: PUSH
70701: EMPTY
70702: LIST
70703: LIST
70704: LIST
70705: LIST
70706: LIST
70707: LIST
70708: LIST
70709: LIST
70710: LIST
70711: LIST
70712: LIST
70713: LIST
70714: LIST
70715: LIST
70716: LIST
70717: LIST
70718: LIST
70719: LIST
70720: LIST
70721: LIST
70722: LIST
70723: LIST
70724: LIST
70725: ST_TO_ADDR
// Factory1 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 1 , - 3 ] , [ 1 , - 2 ] , [ 3 , 2 ] , [ 2 , 3 ] , [ - 2 , 1 ] , [ - 3 , - 1 ] ] ;
70726: LD_ADDR_VAR 0 30
70730: PUSH
70731: LD_INT 0
70733: PUSH
70734: LD_INT 0
70736: PUSH
70737: EMPTY
70738: LIST
70739: LIST
70740: PUSH
70741: LD_INT 0
70743: PUSH
70744: LD_INT 1
70746: NEG
70747: PUSH
70748: EMPTY
70749: LIST
70750: LIST
70751: PUSH
70752: LD_INT 1
70754: PUSH
70755: LD_INT 0
70757: PUSH
70758: EMPTY
70759: LIST
70760: LIST
70761: PUSH
70762: LD_INT 1
70764: PUSH
70765: LD_INT 1
70767: PUSH
70768: EMPTY
70769: LIST
70770: LIST
70771: PUSH
70772: LD_INT 0
70774: PUSH
70775: LD_INT 1
70777: PUSH
70778: EMPTY
70779: LIST
70780: LIST
70781: PUSH
70782: LD_INT 1
70784: NEG
70785: PUSH
70786: LD_INT 0
70788: PUSH
70789: EMPTY
70790: LIST
70791: LIST
70792: PUSH
70793: LD_INT 1
70795: NEG
70796: PUSH
70797: LD_INT 1
70799: NEG
70800: PUSH
70801: EMPTY
70802: LIST
70803: LIST
70804: PUSH
70805: LD_INT 1
70807: NEG
70808: PUSH
70809: LD_INT 2
70811: NEG
70812: PUSH
70813: EMPTY
70814: LIST
70815: LIST
70816: PUSH
70817: LD_INT 0
70819: PUSH
70820: LD_INT 2
70822: NEG
70823: PUSH
70824: EMPTY
70825: LIST
70826: LIST
70827: PUSH
70828: LD_INT 1
70830: PUSH
70831: LD_INT 1
70833: NEG
70834: PUSH
70835: EMPTY
70836: LIST
70837: LIST
70838: PUSH
70839: LD_INT 2
70841: PUSH
70842: LD_INT 0
70844: PUSH
70845: EMPTY
70846: LIST
70847: LIST
70848: PUSH
70849: LD_INT 2
70851: PUSH
70852: LD_INT 1
70854: PUSH
70855: EMPTY
70856: LIST
70857: LIST
70858: PUSH
70859: LD_INT 2
70861: PUSH
70862: LD_INT 2
70864: PUSH
70865: EMPTY
70866: LIST
70867: LIST
70868: PUSH
70869: LD_INT 1
70871: PUSH
70872: LD_INT 2
70874: PUSH
70875: EMPTY
70876: LIST
70877: LIST
70878: PUSH
70879: LD_INT 1
70881: NEG
70882: PUSH
70883: LD_INT 1
70885: PUSH
70886: EMPTY
70887: LIST
70888: LIST
70889: PUSH
70890: LD_INT 2
70892: NEG
70893: PUSH
70894: LD_INT 0
70896: PUSH
70897: EMPTY
70898: LIST
70899: LIST
70900: PUSH
70901: LD_INT 2
70903: NEG
70904: PUSH
70905: LD_INT 1
70907: NEG
70908: PUSH
70909: EMPTY
70910: LIST
70911: LIST
70912: PUSH
70913: LD_INT 1
70915: NEG
70916: PUSH
70917: LD_INT 3
70919: NEG
70920: PUSH
70921: EMPTY
70922: LIST
70923: LIST
70924: PUSH
70925: LD_INT 1
70927: PUSH
70928: LD_INT 2
70930: NEG
70931: PUSH
70932: EMPTY
70933: LIST
70934: LIST
70935: PUSH
70936: LD_INT 3
70938: PUSH
70939: LD_INT 2
70941: PUSH
70942: EMPTY
70943: LIST
70944: LIST
70945: PUSH
70946: LD_INT 2
70948: PUSH
70949: LD_INT 3
70951: PUSH
70952: EMPTY
70953: LIST
70954: LIST
70955: PUSH
70956: LD_INT 2
70958: NEG
70959: PUSH
70960: LD_INT 1
70962: PUSH
70963: EMPTY
70964: LIST
70965: LIST
70966: PUSH
70967: LD_INT 3
70969: NEG
70970: PUSH
70971: LD_INT 1
70973: NEG
70974: PUSH
70975: EMPTY
70976: LIST
70977: LIST
70978: PUSH
70979: EMPTY
70980: LIST
70981: LIST
70982: LIST
70983: LIST
70984: LIST
70985: LIST
70986: LIST
70987: LIST
70988: LIST
70989: LIST
70990: LIST
70991: LIST
70992: LIST
70993: LIST
70994: LIST
70995: LIST
70996: LIST
70997: LIST
70998: LIST
70999: LIST
71000: LIST
71001: LIST
71002: LIST
71003: ST_TO_ADDR
// Factory2 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ - 2 , - 3 ] , [ 2 , - 1 ] , [ 3 , 1 ] , [ 1 , 3 ] , [ - 1 , 2 ] , [ - 3 , - 2 ] ] ;
71004: LD_ADDR_VAR 0 31
71008: PUSH
71009: LD_INT 0
71011: PUSH
71012: LD_INT 0
71014: PUSH
71015: EMPTY
71016: LIST
71017: LIST
71018: PUSH
71019: LD_INT 0
71021: PUSH
71022: LD_INT 1
71024: NEG
71025: PUSH
71026: EMPTY
71027: LIST
71028: LIST
71029: PUSH
71030: LD_INT 1
71032: PUSH
71033: LD_INT 0
71035: PUSH
71036: EMPTY
71037: LIST
71038: LIST
71039: PUSH
71040: LD_INT 1
71042: PUSH
71043: LD_INT 1
71045: PUSH
71046: EMPTY
71047: LIST
71048: LIST
71049: PUSH
71050: LD_INT 0
71052: PUSH
71053: LD_INT 1
71055: PUSH
71056: EMPTY
71057: LIST
71058: LIST
71059: PUSH
71060: LD_INT 1
71062: NEG
71063: PUSH
71064: LD_INT 0
71066: PUSH
71067: EMPTY
71068: LIST
71069: LIST
71070: PUSH
71071: LD_INT 1
71073: NEG
71074: PUSH
71075: LD_INT 1
71077: NEG
71078: PUSH
71079: EMPTY
71080: LIST
71081: LIST
71082: PUSH
71083: LD_INT 1
71085: NEG
71086: PUSH
71087: LD_INT 2
71089: NEG
71090: PUSH
71091: EMPTY
71092: LIST
71093: LIST
71094: PUSH
71095: LD_INT 1
71097: PUSH
71098: LD_INT 1
71100: NEG
71101: PUSH
71102: EMPTY
71103: LIST
71104: LIST
71105: PUSH
71106: LD_INT 2
71108: PUSH
71109: LD_INT 0
71111: PUSH
71112: EMPTY
71113: LIST
71114: LIST
71115: PUSH
71116: LD_INT 2
71118: PUSH
71119: LD_INT 1
71121: PUSH
71122: EMPTY
71123: LIST
71124: LIST
71125: PUSH
71126: LD_INT 2
71128: PUSH
71129: LD_INT 2
71131: PUSH
71132: EMPTY
71133: LIST
71134: LIST
71135: PUSH
71136: LD_INT 1
71138: PUSH
71139: LD_INT 2
71141: PUSH
71142: EMPTY
71143: LIST
71144: LIST
71145: PUSH
71146: LD_INT 0
71148: PUSH
71149: LD_INT 2
71151: PUSH
71152: EMPTY
71153: LIST
71154: LIST
71155: PUSH
71156: LD_INT 1
71158: NEG
71159: PUSH
71160: LD_INT 1
71162: PUSH
71163: EMPTY
71164: LIST
71165: LIST
71166: PUSH
71167: LD_INT 2
71169: NEG
71170: PUSH
71171: LD_INT 1
71173: NEG
71174: PUSH
71175: EMPTY
71176: LIST
71177: LIST
71178: PUSH
71179: LD_INT 2
71181: NEG
71182: PUSH
71183: LD_INT 2
71185: NEG
71186: PUSH
71187: EMPTY
71188: LIST
71189: LIST
71190: PUSH
71191: LD_INT 2
71193: NEG
71194: PUSH
71195: LD_INT 3
71197: NEG
71198: PUSH
71199: EMPTY
71200: LIST
71201: LIST
71202: PUSH
71203: LD_INT 2
71205: PUSH
71206: LD_INT 1
71208: NEG
71209: PUSH
71210: EMPTY
71211: LIST
71212: LIST
71213: PUSH
71214: LD_INT 3
71216: PUSH
71217: LD_INT 1
71219: PUSH
71220: EMPTY
71221: LIST
71222: LIST
71223: PUSH
71224: LD_INT 1
71226: PUSH
71227: LD_INT 3
71229: PUSH
71230: EMPTY
71231: LIST
71232: LIST
71233: PUSH
71234: LD_INT 1
71236: NEG
71237: PUSH
71238: LD_INT 2
71240: PUSH
71241: EMPTY
71242: LIST
71243: LIST
71244: PUSH
71245: LD_INT 3
71247: NEG
71248: PUSH
71249: LD_INT 2
71251: NEG
71252: PUSH
71253: EMPTY
71254: LIST
71255: LIST
71256: PUSH
71257: EMPTY
71258: LIST
71259: LIST
71260: LIST
71261: LIST
71262: LIST
71263: LIST
71264: LIST
71265: LIST
71266: LIST
71267: LIST
71268: LIST
71269: LIST
71270: LIST
71271: LIST
71272: LIST
71273: LIST
71274: LIST
71275: LIST
71276: LIST
71277: LIST
71278: LIST
71279: LIST
71280: LIST
71281: ST_TO_ADDR
// Factory3 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 1 , - 3 ] , [ 1 , - 2 ] , [ 3 , 2 ] , [ 2 , 3 ] , [ - 2 , 1 ] , [ - 3 , - 1 ] ] ;
71282: LD_ADDR_VAR 0 32
71286: PUSH
71287: LD_INT 0
71289: PUSH
71290: LD_INT 0
71292: PUSH
71293: EMPTY
71294: LIST
71295: LIST
71296: PUSH
71297: LD_INT 0
71299: PUSH
71300: LD_INT 1
71302: NEG
71303: PUSH
71304: EMPTY
71305: LIST
71306: LIST
71307: PUSH
71308: LD_INT 1
71310: PUSH
71311: LD_INT 0
71313: PUSH
71314: EMPTY
71315: LIST
71316: LIST
71317: PUSH
71318: LD_INT 1
71320: PUSH
71321: LD_INT 1
71323: PUSH
71324: EMPTY
71325: LIST
71326: LIST
71327: PUSH
71328: LD_INT 0
71330: PUSH
71331: LD_INT 1
71333: PUSH
71334: EMPTY
71335: LIST
71336: LIST
71337: PUSH
71338: LD_INT 1
71340: NEG
71341: PUSH
71342: LD_INT 0
71344: PUSH
71345: EMPTY
71346: LIST
71347: LIST
71348: PUSH
71349: LD_INT 1
71351: NEG
71352: PUSH
71353: LD_INT 1
71355: NEG
71356: PUSH
71357: EMPTY
71358: LIST
71359: LIST
71360: PUSH
71361: LD_INT 1
71363: NEG
71364: PUSH
71365: LD_INT 2
71367: NEG
71368: PUSH
71369: EMPTY
71370: LIST
71371: LIST
71372: PUSH
71373: LD_INT 0
71375: PUSH
71376: LD_INT 2
71378: NEG
71379: PUSH
71380: EMPTY
71381: LIST
71382: LIST
71383: PUSH
71384: LD_INT 1
71386: PUSH
71387: LD_INT 1
71389: NEG
71390: PUSH
71391: EMPTY
71392: LIST
71393: LIST
71394: PUSH
71395: LD_INT 2
71397: PUSH
71398: LD_INT 1
71400: PUSH
71401: EMPTY
71402: LIST
71403: LIST
71404: PUSH
71405: LD_INT 2
71407: PUSH
71408: LD_INT 2
71410: PUSH
71411: EMPTY
71412: LIST
71413: LIST
71414: PUSH
71415: LD_INT 1
71417: PUSH
71418: LD_INT 2
71420: PUSH
71421: EMPTY
71422: LIST
71423: LIST
71424: PUSH
71425: LD_INT 0
71427: PUSH
71428: LD_INT 2
71430: PUSH
71431: EMPTY
71432: LIST
71433: LIST
71434: PUSH
71435: LD_INT 1
71437: NEG
71438: PUSH
71439: LD_INT 1
71441: PUSH
71442: EMPTY
71443: LIST
71444: LIST
71445: PUSH
71446: LD_INT 2
71448: NEG
71449: PUSH
71450: LD_INT 0
71452: PUSH
71453: EMPTY
71454: LIST
71455: LIST
71456: PUSH
71457: LD_INT 2
71459: NEG
71460: PUSH
71461: LD_INT 1
71463: NEG
71464: PUSH
71465: EMPTY
71466: LIST
71467: LIST
71468: PUSH
71469: LD_INT 1
71471: NEG
71472: PUSH
71473: LD_INT 3
71475: NEG
71476: PUSH
71477: EMPTY
71478: LIST
71479: LIST
71480: PUSH
71481: LD_INT 1
71483: PUSH
71484: LD_INT 2
71486: NEG
71487: PUSH
71488: EMPTY
71489: LIST
71490: LIST
71491: PUSH
71492: LD_INT 3
71494: PUSH
71495: LD_INT 2
71497: PUSH
71498: EMPTY
71499: LIST
71500: LIST
71501: PUSH
71502: LD_INT 2
71504: PUSH
71505: LD_INT 3
71507: PUSH
71508: EMPTY
71509: LIST
71510: LIST
71511: PUSH
71512: LD_INT 2
71514: NEG
71515: PUSH
71516: LD_INT 1
71518: PUSH
71519: EMPTY
71520: LIST
71521: LIST
71522: PUSH
71523: LD_INT 3
71525: NEG
71526: PUSH
71527: LD_INT 1
71529: NEG
71530: PUSH
71531: EMPTY
71532: LIST
71533: LIST
71534: PUSH
71535: EMPTY
71536: LIST
71537: LIST
71538: LIST
71539: LIST
71540: LIST
71541: LIST
71542: LIST
71543: LIST
71544: LIST
71545: LIST
71546: LIST
71547: LIST
71548: LIST
71549: LIST
71550: LIST
71551: LIST
71552: LIST
71553: LIST
71554: LIST
71555: LIST
71556: LIST
71557: LIST
71558: LIST
71559: ST_TO_ADDR
// Factory4 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ - 2 , - 3 ] , [ 2 , - 1 ] , [ 3 , 1 ] , [ 1 , 3 ] , [ - 1 , 2 ] , [ - 3 , - 2 ] ] ;
71560: LD_ADDR_VAR 0 33
71564: PUSH
71565: LD_INT 0
71567: PUSH
71568: LD_INT 0
71570: PUSH
71571: EMPTY
71572: LIST
71573: LIST
71574: PUSH
71575: LD_INT 0
71577: PUSH
71578: LD_INT 1
71580: NEG
71581: PUSH
71582: EMPTY
71583: LIST
71584: LIST
71585: PUSH
71586: LD_INT 1
71588: PUSH
71589: LD_INT 0
71591: PUSH
71592: EMPTY
71593: LIST
71594: LIST
71595: PUSH
71596: LD_INT 1
71598: PUSH
71599: LD_INT 1
71601: PUSH
71602: EMPTY
71603: LIST
71604: LIST
71605: PUSH
71606: LD_INT 0
71608: PUSH
71609: LD_INT 1
71611: PUSH
71612: EMPTY
71613: LIST
71614: LIST
71615: PUSH
71616: LD_INT 1
71618: NEG
71619: PUSH
71620: LD_INT 0
71622: PUSH
71623: EMPTY
71624: LIST
71625: LIST
71626: PUSH
71627: LD_INT 1
71629: NEG
71630: PUSH
71631: LD_INT 1
71633: NEG
71634: PUSH
71635: EMPTY
71636: LIST
71637: LIST
71638: PUSH
71639: LD_INT 1
71641: NEG
71642: PUSH
71643: LD_INT 2
71645: NEG
71646: PUSH
71647: EMPTY
71648: LIST
71649: LIST
71650: PUSH
71651: LD_INT 1
71653: PUSH
71654: LD_INT 1
71656: NEG
71657: PUSH
71658: EMPTY
71659: LIST
71660: LIST
71661: PUSH
71662: LD_INT 2
71664: PUSH
71665: LD_INT 0
71667: PUSH
71668: EMPTY
71669: LIST
71670: LIST
71671: PUSH
71672: LD_INT 2
71674: PUSH
71675: LD_INT 1
71677: PUSH
71678: EMPTY
71679: LIST
71680: LIST
71681: PUSH
71682: LD_INT 1
71684: PUSH
71685: LD_INT 2
71687: PUSH
71688: EMPTY
71689: LIST
71690: LIST
71691: PUSH
71692: LD_INT 0
71694: PUSH
71695: LD_INT 2
71697: PUSH
71698: EMPTY
71699: LIST
71700: LIST
71701: PUSH
71702: LD_INT 1
71704: NEG
71705: PUSH
71706: LD_INT 1
71708: PUSH
71709: EMPTY
71710: LIST
71711: LIST
71712: PUSH
71713: LD_INT 2
71715: NEG
71716: PUSH
71717: LD_INT 0
71719: PUSH
71720: EMPTY
71721: LIST
71722: LIST
71723: PUSH
71724: LD_INT 2
71726: NEG
71727: PUSH
71728: LD_INT 1
71730: NEG
71731: PUSH
71732: EMPTY
71733: LIST
71734: LIST
71735: PUSH
71736: LD_INT 2
71738: NEG
71739: PUSH
71740: LD_INT 2
71742: NEG
71743: PUSH
71744: EMPTY
71745: LIST
71746: LIST
71747: PUSH
71748: LD_INT 2
71750: NEG
71751: PUSH
71752: LD_INT 3
71754: NEG
71755: PUSH
71756: EMPTY
71757: LIST
71758: LIST
71759: PUSH
71760: LD_INT 2
71762: PUSH
71763: LD_INT 1
71765: NEG
71766: PUSH
71767: EMPTY
71768: LIST
71769: LIST
71770: PUSH
71771: LD_INT 3
71773: PUSH
71774: LD_INT 1
71776: PUSH
71777: EMPTY
71778: LIST
71779: LIST
71780: PUSH
71781: LD_INT 1
71783: PUSH
71784: LD_INT 3
71786: PUSH
71787: EMPTY
71788: LIST
71789: LIST
71790: PUSH
71791: LD_INT 1
71793: NEG
71794: PUSH
71795: LD_INT 2
71797: PUSH
71798: EMPTY
71799: LIST
71800: LIST
71801: PUSH
71802: LD_INT 3
71804: NEG
71805: PUSH
71806: LD_INT 2
71808: NEG
71809: PUSH
71810: EMPTY
71811: LIST
71812: LIST
71813: PUSH
71814: EMPTY
71815: LIST
71816: LIST
71817: LIST
71818: LIST
71819: LIST
71820: LIST
71821: LIST
71822: LIST
71823: LIST
71824: LIST
71825: LIST
71826: LIST
71827: LIST
71828: LIST
71829: LIST
71830: LIST
71831: LIST
71832: LIST
71833: LIST
71834: LIST
71835: LIST
71836: LIST
71837: LIST
71838: ST_TO_ADDR
// Factory5 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ - 1 , - 3 ] , [ 1 , - 2 ] , [ 3 , 2 ] , [ 2 , 3 ] , [ - 2 , 1 ] , [ - 3 , - 1 ] ] ;
71839: LD_ADDR_VAR 0 34
71843: PUSH
71844: LD_INT 0
71846: PUSH
71847: LD_INT 0
71849: PUSH
71850: EMPTY
71851: LIST
71852: LIST
71853: PUSH
71854: LD_INT 0
71856: PUSH
71857: LD_INT 1
71859: NEG
71860: PUSH
71861: EMPTY
71862: LIST
71863: LIST
71864: PUSH
71865: LD_INT 1
71867: PUSH
71868: LD_INT 0
71870: PUSH
71871: EMPTY
71872: LIST
71873: LIST
71874: PUSH
71875: LD_INT 1
71877: PUSH
71878: LD_INT 1
71880: PUSH
71881: EMPTY
71882: LIST
71883: LIST
71884: PUSH
71885: LD_INT 0
71887: PUSH
71888: LD_INT 1
71890: PUSH
71891: EMPTY
71892: LIST
71893: LIST
71894: PUSH
71895: LD_INT 1
71897: NEG
71898: PUSH
71899: LD_INT 0
71901: PUSH
71902: EMPTY
71903: LIST
71904: LIST
71905: PUSH
71906: LD_INT 1
71908: NEG
71909: PUSH
71910: LD_INT 1
71912: NEG
71913: PUSH
71914: EMPTY
71915: LIST
71916: LIST
71917: PUSH
71918: LD_INT 1
71920: NEG
71921: PUSH
71922: LD_INT 2
71924: NEG
71925: PUSH
71926: EMPTY
71927: LIST
71928: LIST
71929: PUSH
71930: LD_INT 0
71932: PUSH
71933: LD_INT 2
71935: NEG
71936: PUSH
71937: EMPTY
71938: LIST
71939: LIST
71940: PUSH
71941: LD_INT 1
71943: PUSH
71944: LD_INT 1
71946: NEG
71947: PUSH
71948: EMPTY
71949: LIST
71950: LIST
71951: PUSH
71952: LD_INT 2
71954: PUSH
71955: LD_INT 1
71957: PUSH
71958: EMPTY
71959: LIST
71960: LIST
71961: PUSH
71962: LD_INT 2
71964: PUSH
71965: LD_INT 2
71967: PUSH
71968: EMPTY
71969: LIST
71970: LIST
71971: PUSH
71972: LD_INT 1
71974: PUSH
71975: LD_INT 2
71977: PUSH
71978: EMPTY
71979: LIST
71980: LIST
71981: PUSH
71982: LD_INT 1
71984: NEG
71985: PUSH
71986: LD_INT 1
71988: PUSH
71989: EMPTY
71990: LIST
71991: LIST
71992: PUSH
71993: LD_INT 2
71995: NEG
71996: PUSH
71997: LD_INT 0
71999: PUSH
72000: EMPTY
72001: LIST
72002: LIST
72003: PUSH
72004: LD_INT 2
72006: NEG
72007: PUSH
72008: LD_INT 1
72010: NEG
72011: PUSH
72012: EMPTY
72013: LIST
72014: LIST
72015: PUSH
72016: LD_INT 2
72018: NEG
72019: PUSH
72020: LD_INT 2
72022: NEG
72023: PUSH
72024: EMPTY
72025: LIST
72026: LIST
72027: PUSH
72028: LD_INT 1
72030: NEG
72031: PUSH
72032: LD_INT 3
72034: NEG
72035: PUSH
72036: EMPTY
72037: LIST
72038: LIST
72039: PUSH
72040: LD_INT 1
72042: PUSH
72043: LD_INT 2
72045: NEG
72046: PUSH
72047: EMPTY
72048: LIST
72049: LIST
72050: PUSH
72051: LD_INT 3
72053: PUSH
72054: LD_INT 2
72056: PUSH
72057: EMPTY
72058: LIST
72059: LIST
72060: PUSH
72061: LD_INT 2
72063: PUSH
72064: LD_INT 3
72066: PUSH
72067: EMPTY
72068: LIST
72069: LIST
72070: PUSH
72071: LD_INT 2
72073: NEG
72074: PUSH
72075: LD_INT 1
72077: PUSH
72078: EMPTY
72079: LIST
72080: LIST
72081: PUSH
72082: LD_INT 3
72084: NEG
72085: PUSH
72086: LD_INT 1
72088: NEG
72089: PUSH
72090: EMPTY
72091: LIST
72092: LIST
72093: PUSH
72094: EMPTY
72095: LIST
72096: LIST
72097: LIST
72098: LIST
72099: LIST
72100: LIST
72101: LIST
72102: LIST
72103: LIST
72104: LIST
72105: LIST
72106: LIST
72107: LIST
72108: LIST
72109: LIST
72110: LIST
72111: LIST
72112: LIST
72113: LIST
72114: LIST
72115: LIST
72116: LIST
72117: LIST
72118: ST_TO_ADDR
// Ext0 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ 2 , 1 ] , [ - 2 , - 1 ] ] ;
72119: LD_ADDR_VAR 0 35
72123: PUSH
72124: LD_INT 0
72126: PUSH
72127: LD_INT 0
72129: PUSH
72130: EMPTY
72131: LIST
72132: LIST
72133: PUSH
72134: LD_INT 0
72136: PUSH
72137: LD_INT 1
72139: NEG
72140: PUSH
72141: EMPTY
72142: LIST
72143: LIST
72144: PUSH
72145: LD_INT 1
72147: PUSH
72148: LD_INT 0
72150: PUSH
72151: EMPTY
72152: LIST
72153: LIST
72154: PUSH
72155: LD_INT 1
72157: PUSH
72158: LD_INT 1
72160: PUSH
72161: EMPTY
72162: LIST
72163: LIST
72164: PUSH
72165: LD_INT 0
72167: PUSH
72168: LD_INT 1
72170: PUSH
72171: EMPTY
72172: LIST
72173: LIST
72174: PUSH
72175: LD_INT 1
72177: NEG
72178: PUSH
72179: LD_INT 0
72181: PUSH
72182: EMPTY
72183: LIST
72184: LIST
72185: PUSH
72186: LD_INT 1
72188: NEG
72189: PUSH
72190: LD_INT 1
72192: NEG
72193: PUSH
72194: EMPTY
72195: LIST
72196: LIST
72197: PUSH
72198: LD_INT 2
72200: PUSH
72201: LD_INT 1
72203: PUSH
72204: EMPTY
72205: LIST
72206: LIST
72207: PUSH
72208: LD_INT 2
72210: NEG
72211: PUSH
72212: LD_INT 1
72214: NEG
72215: PUSH
72216: EMPTY
72217: LIST
72218: LIST
72219: PUSH
72220: EMPTY
72221: LIST
72222: LIST
72223: LIST
72224: LIST
72225: LIST
72226: LIST
72227: LIST
72228: LIST
72229: LIST
72230: ST_TO_ADDR
// Ext1 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 1 , 2 ] ] ;
72231: LD_ADDR_VAR 0 36
72235: PUSH
72236: LD_INT 0
72238: PUSH
72239: LD_INT 0
72241: PUSH
72242: EMPTY
72243: LIST
72244: LIST
72245: PUSH
72246: LD_INT 0
72248: PUSH
72249: LD_INT 1
72251: NEG
72252: PUSH
72253: EMPTY
72254: LIST
72255: LIST
72256: PUSH
72257: LD_INT 1
72259: PUSH
72260: LD_INT 0
72262: PUSH
72263: EMPTY
72264: LIST
72265: LIST
72266: PUSH
72267: LD_INT 1
72269: PUSH
72270: LD_INT 1
72272: PUSH
72273: EMPTY
72274: LIST
72275: LIST
72276: PUSH
72277: LD_INT 0
72279: PUSH
72280: LD_INT 1
72282: PUSH
72283: EMPTY
72284: LIST
72285: LIST
72286: PUSH
72287: LD_INT 1
72289: NEG
72290: PUSH
72291: LD_INT 0
72293: PUSH
72294: EMPTY
72295: LIST
72296: LIST
72297: PUSH
72298: LD_INT 1
72300: NEG
72301: PUSH
72302: LD_INT 1
72304: NEG
72305: PUSH
72306: EMPTY
72307: LIST
72308: LIST
72309: PUSH
72310: LD_INT 1
72312: NEG
72313: PUSH
72314: LD_INT 2
72316: NEG
72317: PUSH
72318: EMPTY
72319: LIST
72320: LIST
72321: PUSH
72322: LD_INT 1
72324: PUSH
72325: LD_INT 2
72327: PUSH
72328: EMPTY
72329: LIST
72330: LIST
72331: PUSH
72332: EMPTY
72333: LIST
72334: LIST
72335: LIST
72336: LIST
72337: LIST
72338: LIST
72339: LIST
72340: LIST
72341: LIST
72342: ST_TO_ADDR
// Ext2 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ 1 , - 1 ] , [ - 1 , 1 ] ] ;
72343: LD_ADDR_VAR 0 37
72347: PUSH
72348: LD_INT 0
72350: PUSH
72351: LD_INT 0
72353: PUSH
72354: EMPTY
72355: LIST
72356: LIST
72357: PUSH
72358: LD_INT 0
72360: PUSH
72361: LD_INT 1
72363: NEG
72364: PUSH
72365: EMPTY
72366: LIST
72367: LIST
72368: PUSH
72369: LD_INT 1
72371: PUSH
72372: LD_INT 0
72374: PUSH
72375: EMPTY
72376: LIST
72377: LIST
72378: PUSH
72379: LD_INT 1
72381: PUSH
72382: LD_INT 1
72384: PUSH
72385: EMPTY
72386: LIST
72387: LIST
72388: PUSH
72389: LD_INT 0
72391: PUSH
72392: LD_INT 1
72394: PUSH
72395: EMPTY
72396: LIST
72397: LIST
72398: PUSH
72399: LD_INT 1
72401: NEG
72402: PUSH
72403: LD_INT 0
72405: PUSH
72406: EMPTY
72407: LIST
72408: LIST
72409: PUSH
72410: LD_INT 1
72412: NEG
72413: PUSH
72414: LD_INT 1
72416: NEG
72417: PUSH
72418: EMPTY
72419: LIST
72420: LIST
72421: PUSH
72422: LD_INT 1
72424: PUSH
72425: LD_INT 1
72427: NEG
72428: PUSH
72429: EMPTY
72430: LIST
72431: LIST
72432: PUSH
72433: LD_INT 1
72435: NEG
72436: PUSH
72437: LD_INT 1
72439: PUSH
72440: EMPTY
72441: LIST
72442: LIST
72443: PUSH
72444: EMPTY
72445: LIST
72446: LIST
72447: LIST
72448: LIST
72449: LIST
72450: LIST
72451: LIST
72452: LIST
72453: LIST
72454: ST_TO_ADDR
// Ext3 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ 2 , 1 ] , [ - 2 , - 1 ] ] ;
72455: LD_ADDR_VAR 0 38
72459: PUSH
72460: LD_INT 0
72462: PUSH
72463: LD_INT 0
72465: PUSH
72466: EMPTY
72467: LIST
72468: LIST
72469: PUSH
72470: LD_INT 0
72472: PUSH
72473: LD_INT 1
72475: NEG
72476: PUSH
72477: EMPTY
72478: LIST
72479: LIST
72480: PUSH
72481: LD_INT 1
72483: PUSH
72484: LD_INT 0
72486: PUSH
72487: EMPTY
72488: LIST
72489: LIST
72490: PUSH
72491: LD_INT 1
72493: PUSH
72494: LD_INT 1
72496: PUSH
72497: EMPTY
72498: LIST
72499: LIST
72500: PUSH
72501: LD_INT 0
72503: PUSH
72504: LD_INT 1
72506: PUSH
72507: EMPTY
72508: LIST
72509: LIST
72510: PUSH
72511: LD_INT 1
72513: NEG
72514: PUSH
72515: LD_INT 0
72517: PUSH
72518: EMPTY
72519: LIST
72520: LIST
72521: PUSH
72522: LD_INT 1
72524: NEG
72525: PUSH
72526: LD_INT 1
72528: NEG
72529: PUSH
72530: EMPTY
72531: LIST
72532: LIST
72533: PUSH
72534: LD_INT 2
72536: PUSH
72537: LD_INT 1
72539: PUSH
72540: EMPTY
72541: LIST
72542: LIST
72543: PUSH
72544: LD_INT 2
72546: NEG
72547: PUSH
72548: LD_INT 1
72550: NEG
72551: PUSH
72552: EMPTY
72553: LIST
72554: LIST
72555: PUSH
72556: EMPTY
72557: LIST
72558: LIST
72559: LIST
72560: LIST
72561: LIST
72562: LIST
72563: LIST
72564: LIST
72565: LIST
72566: ST_TO_ADDR
// Ext4 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 1 , 2 ] ] ;
72567: LD_ADDR_VAR 0 39
72571: PUSH
72572: LD_INT 0
72574: PUSH
72575: LD_INT 0
72577: PUSH
72578: EMPTY
72579: LIST
72580: LIST
72581: PUSH
72582: LD_INT 0
72584: PUSH
72585: LD_INT 1
72587: NEG
72588: PUSH
72589: EMPTY
72590: LIST
72591: LIST
72592: PUSH
72593: LD_INT 1
72595: PUSH
72596: LD_INT 0
72598: PUSH
72599: EMPTY
72600: LIST
72601: LIST
72602: PUSH
72603: LD_INT 1
72605: PUSH
72606: LD_INT 1
72608: PUSH
72609: EMPTY
72610: LIST
72611: LIST
72612: PUSH
72613: LD_INT 0
72615: PUSH
72616: LD_INT 1
72618: PUSH
72619: EMPTY
72620: LIST
72621: LIST
72622: PUSH
72623: LD_INT 1
72625: NEG
72626: PUSH
72627: LD_INT 0
72629: PUSH
72630: EMPTY
72631: LIST
72632: LIST
72633: PUSH
72634: LD_INT 1
72636: NEG
72637: PUSH
72638: LD_INT 1
72640: NEG
72641: PUSH
72642: EMPTY
72643: LIST
72644: LIST
72645: PUSH
72646: LD_INT 1
72648: NEG
72649: PUSH
72650: LD_INT 2
72652: NEG
72653: PUSH
72654: EMPTY
72655: LIST
72656: LIST
72657: PUSH
72658: LD_INT 1
72660: PUSH
72661: LD_INT 2
72663: PUSH
72664: EMPTY
72665: LIST
72666: LIST
72667: PUSH
72668: EMPTY
72669: LIST
72670: LIST
72671: LIST
72672: LIST
72673: LIST
72674: LIST
72675: LIST
72676: LIST
72677: LIST
72678: ST_TO_ADDR
// Ext5 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ 1 , - 1 ] , [ - 1 , 1 ] ] ;
72679: LD_ADDR_VAR 0 40
72683: PUSH
72684: LD_INT 0
72686: PUSH
72687: LD_INT 0
72689: PUSH
72690: EMPTY
72691: LIST
72692: LIST
72693: PUSH
72694: LD_INT 0
72696: PUSH
72697: LD_INT 1
72699: NEG
72700: PUSH
72701: EMPTY
72702: LIST
72703: LIST
72704: PUSH
72705: LD_INT 1
72707: PUSH
72708: LD_INT 0
72710: PUSH
72711: EMPTY
72712: LIST
72713: LIST
72714: PUSH
72715: LD_INT 1
72717: PUSH
72718: LD_INT 1
72720: PUSH
72721: EMPTY
72722: LIST
72723: LIST
72724: PUSH
72725: LD_INT 0
72727: PUSH
72728: LD_INT 1
72730: PUSH
72731: EMPTY
72732: LIST
72733: LIST
72734: PUSH
72735: LD_INT 1
72737: NEG
72738: PUSH
72739: LD_INT 0
72741: PUSH
72742: EMPTY
72743: LIST
72744: LIST
72745: PUSH
72746: LD_INT 1
72748: NEG
72749: PUSH
72750: LD_INT 1
72752: NEG
72753: PUSH
72754: EMPTY
72755: LIST
72756: LIST
72757: PUSH
72758: LD_INT 1
72760: PUSH
72761: LD_INT 1
72763: NEG
72764: PUSH
72765: EMPTY
72766: LIST
72767: LIST
72768: PUSH
72769: LD_INT 1
72771: NEG
72772: PUSH
72773: LD_INT 1
72775: PUSH
72776: EMPTY
72777: LIST
72778: LIST
72779: PUSH
72780: EMPTY
72781: LIST
72782: LIST
72783: LIST
72784: LIST
72785: LIST
72786: LIST
72787: LIST
72788: LIST
72789: LIST
72790: ST_TO_ADDR
// Lab0 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ - 2 , - 3 ] , [ 2 , - 1 ] , [ 3 , 0 ] , [ 3 , 1 ] , [ 3 , 2 ] , [ 3 , 3 ] , [ 2 , 3 ] , [ - 2 , 1 ] , [ - 3 , 0 ] , [ - 3 , - 1 ] , [ - 3 , - 2 ] , [ - 3 , - 3 ] ] ;
72791: LD_ADDR_VAR 0 41
72795: PUSH
72796: LD_INT 0
72798: PUSH
72799: LD_INT 0
72801: PUSH
72802: EMPTY
72803: LIST
72804: LIST
72805: PUSH
72806: LD_INT 0
72808: PUSH
72809: LD_INT 1
72811: NEG
72812: PUSH
72813: EMPTY
72814: LIST
72815: LIST
72816: PUSH
72817: LD_INT 1
72819: PUSH
72820: LD_INT 0
72822: PUSH
72823: EMPTY
72824: LIST
72825: LIST
72826: PUSH
72827: LD_INT 1
72829: PUSH
72830: LD_INT 1
72832: PUSH
72833: EMPTY
72834: LIST
72835: LIST
72836: PUSH
72837: LD_INT 0
72839: PUSH
72840: LD_INT 1
72842: PUSH
72843: EMPTY
72844: LIST
72845: LIST
72846: PUSH
72847: LD_INT 1
72849: NEG
72850: PUSH
72851: LD_INT 0
72853: PUSH
72854: EMPTY
72855: LIST
72856: LIST
72857: PUSH
72858: LD_INT 1
72860: NEG
72861: PUSH
72862: LD_INT 1
72864: NEG
72865: PUSH
72866: EMPTY
72867: LIST
72868: LIST
72869: PUSH
72870: LD_INT 1
72872: NEG
72873: PUSH
72874: LD_INT 2
72876: NEG
72877: PUSH
72878: EMPTY
72879: LIST
72880: LIST
72881: PUSH
72882: LD_INT 1
72884: PUSH
72885: LD_INT 1
72887: NEG
72888: PUSH
72889: EMPTY
72890: LIST
72891: LIST
72892: PUSH
72893: LD_INT 2
72895: PUSH
72896: LD_INT 0
72898: PUSH
72899: EMPTY
72900: LIST
72901: LIST
72902: PUSH
72903: LD_INT 2
72905: PUSH
72906: LD_INT 1
72908: PUSH
72909: EMPTY
72910: LIST
72911: LIST
72912: PUSH
72913: LD_INT 2
72915: PUSH
72916: LD_INT 2
72918: PUSH
72919: EMPTY
72920: LIST
72921: LIST
72922: PUSH
72923: LD_INT 1
72925: PUSH
72926: LD_INT 2
72928: PUSH
72929: EMPTY
72930: LIST
72931: LIST
72932: PUSH
72933: LD_INT 1
72935: NEG
72936: PUSH
72937: LD_INT 1
72939: PUSH
72940: EMPTY
72941: LIST
72942: LIST
72943: PUSH
72944: LD_INT 2
72946: NEG
72947: PUSH
72948: LD_INT 0
72950: PUSH
72951: EMPTY
72952: LIST
72953: LIST
72954: PUSH
72955: LD_INT 2
72957: NEG
72958: PUSH
72959: LD_INT 1
72961: NEG
72962: PUSH
72963: EMPTY
72964: LIST
72965: LIST
72966: PUSH
72967: LD_INT 2
72969: NEG
72970: PUSH
72971: LD_INT 2
72973: NEG
72974: PUSH
72975: EMPTY
72976: LIST
72977: LIST
72978: PUSH
72979: LD_INT 2
72981: NEG
72982: PUSH
72983: LD_INT 3
72985: NEG
72986: PUSH
72987: EMPTY
72988: LIST
72989: LIST
72990: PUSH
72991: LD_INT 2
72993: PUSH
72994: LD_INT 1
72996: NEG
72997: PUSH
72998: EMPTY
72999: LIST
73000: LIST
73001: PUSH
73002: LD_INT 3
73004: PUSH
73005: LD_INT 0
73007: PUSH
73008: EMPTY
73009: LIST
73010: LIST
73011: PUSH
73012: LD_INT 3
73014: PUSH
73015: LD_INT 1
73017: PUSH
73018: EMPTY
73019: LIST
73020: LIST
73021: PUSH
73022: LD_INT 3
73024: PUSH
73025: LD_INT 2
73027: PUSH
73028: EMPTY
73029: LIST
73030: LIST
73031: PUSH
73032: LD_INT 3
73034: PUSH
73035: LD_INT 3
73037: PUSH
73038: EMPTY
73039: LIST
73040: LIST
73041: PUSH
73042: LD_INT 2
73044: PUSH
73045: LD_INT 3
73047: PUSH
73048: EMPTY
73049: LIST
73050: LIST
73051: PUSH
73052: LD_INT 2
73054: NEG
73055: PUSH
73056: LD_INT 1
73058: PUSH
73059: EMPTY
73060: LIST
73061: LIST
73062: PUSH
73063: LD_INT 3
73065: NEG
73066: PUSH
73067: LD_INT 0
73069: PUSH
73070: EMPTY
73071: LIST
73072: LIST
73073: PUSH
73074: LD_INT 3
73076: NEG
73077: PUSH
73078: LD_INT 1
73080: NEG
73081: PUSH
73082: EMPTY
73083: LIST
73084: LIST
73085: PUSH
73086: LD_INT 3
73088: NEG
73089: PUSH
73090: LD_INT 2
73092: NEG
73093: PUSH
73094: EMPTY
73095: LIST
73096: LIST
73097: PUSH
73098: LD_INT 3
73100: NEG
73101: PUSH
73102: LD_INT 3
73104: NEG
73105: PUSH
73106: EMPTY
73107: LIST
73108: LIST
73109: PUSH
73110: EMPTY
73111: LIST
73112: LIST
73113: LIST
73114: LIST
73115: LIST
73116: LIST
73117: LIST
73118: LIST
73119: LIST
73120: LIST
73121: LIST
73122: LIST
73123: LIST
73124: LIST
73125: LIST
73126: LIST
73127: LIST
73128: LIST
73129: LIST
73130: LIST
73131: LIST
73132: LIST
73133: LIST
73134: LIST
73135: LIST
73136: LIST
73137: LIST
73138: LIST
73139: LIST
73140: ST_TO_ADDR
// Lab1 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ - 2 , - 3 ] , [ - 1 , - 3 ] , [ 0 , - 3 ] , [ 1 , - 2 ] , [ 3 , 2 ] , [ 3 , 3 ] , [ 2 , 3 ] , [ 1 , 3 ] , [ 0 , 3 ] , [ - 1 , 2 ] , [ - 3 , - 2 ] , [ - 3 , - 3 ] ] ;
73141: LD_ADDR_VAR 0 42
73145: PUSH
73146: LD_INT 0
73148: PUSH
73149: LD_INT 0
73151: PUSH
73152: EMPTY
73153: LIST
73154: LIST
73155: PUSH
73156: LD_INT 0
73158: PUSH
73159: LD_INT 1
73161: NEG
73162: PUSH
73163: EMPTY
73164: LIST
73165: LIST
73166: PUSH
73167: LD_INT 1
73169: PUSH
73170: LD_INT 0
73172: PUSH
73173: EMPTY
73174: LIST
73175: LIST
73176: PUSH
73177: LD_INT 1
73179: PUSH
73180: LD_INT 1
73182: PUSH
73183: EMPTY
73184: LIST
73185: LIST
73186: PUSH
73187: LD_INT 0
73189: PUSH
73190: LD_INT 1
73192: PUSH
73193: EMPTY
73194: LIST
73195: LIST
73196: PUSH
73197: LD_INT 1
73199: NEG
73200: PUSH
73201: LD_INT 0
73203: PUSH
73204: EMPTY
73205: LIST
73206: LIST
73207: PUSH
73208: LD_INT 1
73210: NEG
73211: PUSH
73212: LD_INT 1
73214: NEG
73215: PUSH
73216: EMPTY
73217: LIST
73218: LIST
73219: PUSH
73220: LD_INT 1
73222: NEG
73223: PUSH
73224: LD_INT 2
73226: NEG
73227: PUSH
73228: EMPTY
73229: LIST
73230: LIST
73231: PUSH
73232: LD_INT 0
73234: PUSH
73235: LD_INT 2
73237: NEG
73238: PUSH
73239: EMPTY
73240: LIST
73241: LIST
73242: PUSH
73243: LD_INT 1
73245: PUSH
73246: LD_INT 1
73248: NEG
73249: PUSH
73250: EMPTY
73251: LIST
73252: LIST
73253: PUSH
73254: LD_INT 2
73256: PUSH
73257: LD_INT 1
73259: PUSH
73260: EMPTY
73261: LIST
73262: LIST
73263: PUSH
73264: LD_INT 2
73266: PUSH
73267: LD_INT 2
73269: PUSH
73270: EMPTY
73271: LIST
73272: LIST
73273: PUSH
73274: LD_INT 1
73276: PUSH
73277: LD_INT 2
73279: PUSH
73280: EMPTY
73281: LIST
73282: LIST
73283: PUSH
73284: LD_INT 0
73286: PUSH
73287: LD_INT 2
73289: PUSH
73290: EMPTY
73291: LIST
73292: LIST
73293: PUSH
73294: LD_INT 1
73296: NEG
73297: PUSH
73298: LD_INT 1
73300: PUSH
73301: EMPTY
73302: LIST
73303: LIST
73304: PUSH
73305: LD_INT 2
73307: NEG
73308: PUSH
73309: LD_INT 1
73311: NEG
73312: PUSH
73313: EMPTY
73314: LIST
73315: LIST
73316: PUSH
73317: LD_INT 2
73319: NEG
73320: PUSH
73321: LD_INT 2
73323: NEG
73324: PUSH
73325: EMPTY
73326: LIST
73327: LIST
73328: PUSH
73329: LD_INT 2
73331: NEG
73332: PUSH
73333: LD_INT 3
73335: NEG
73336: PUSH
73337: EMPTY
73338: LIST
73339: LIST
73340: PUSH
73341: LD_INT 1
73343: NEG
73344: PUSH
73345: LD_INT 3
73347: NEG
73348: PUSH
73349: EMPTY
73350: LIST
73351: LIST
73352: PUSH
73353: LD_INT 0
73355: PUSH
73356: LD_INT 3
73358: NEG
73359: PUSH
73360: EMPTY
73361: LIST
73362: LIST
73363: PUSH
73364: LD_INT 1
73366: PUSH
73367: LD_INT 2
73369: NEG
73370: PUSH
73371: EMPTY
73372: LIST
73373: LIST
73374: PUSH
73375: LD_INT 3
73377: PUSH
73378: LD_INT 2
73380: PUSH
73381: EMPTY
73382: LIST
73383: LIST
73384: PUSH
73385: LD_INT 3
73387: PUSH
73388: LD_INT 3
73390: PUSH
73391: EMPTY
73392: LIST
73393: LIST
73394: PUSH
73395: LD_INT 2
73397: PUSH
73398: LD_INT 3
73400: PUSH
73401: EMPTY
73402: LIST
73403: LIST
73404: PUSH
73405: LD_INT 1
73407: PUSH
73408: LD_INT 3
73410: PUSH
73411: EMPTY
73412: LIST
73413: LIST
73414: PUSH
73415: LD_INT 0
73417: PUSH
73418: LD_INT 3
73420: PUSH
73421: EMPTY
73422: LIST
73423: LIST
73424: PUSH
73425: LD_INT 1
73427: NEG
73428: PUSH
73429: LD_INT 2
73431: PUSH
73432: EMPTY
73433: LIST
73434: LIST
73435: PUSH
73436: LD_INT 3
73438: NEG
73439: PUSH
73440: LD_INT 2
73442: NEG
73443: PUSH
73444: EMPTY
73445: LIST
73446: LIST
73447: PUSH
73448: LD_INT 3
73450: NEG
73451: PUSH
73452: LD_INT 3
73454: NEG
73455: PUSH
73456: EMPTY
73457: LIST
73458: LIST
73459: PUSH
73460: EMPTY
73461: LIST
73462: LIST
73463: LIST
73464: LIST
73465: LIST
73466: LIST
73467: LIST
73468: LIST
73469: LIST
73470: LIST
73471: LIST
73472: LIST
73473: LIST
73474: LIST
73475: LIST
73476: LIST
73477: LIST
73478: LIST
73479: LIST
73480: LIST
73481: LIST
73482: LIST
73483: LIST
73484: LIST
73485: LIST
73486: LIST
73487: LIST
73488: LIST
73489: LIST
73490: ST_TO_ADDR
// Lab2 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 1 , - 3 ] , [ 0 , - 3 ] , [ 1 , - 2 ] , [ 2 , - 1 ] , [ 3 , 0 ] , [ 3 , 1 ] , [ 1 , 3 ] , [ 0 , 3 ] , [ - 1 , 2 ] , [ - 2 , 1 ] , [ - 3 , 0 ] , [ - 3 , - 1 ] ] ;
73491: LD_ADDR_VAR 0 43
73495: PUSH
73496: LD_INT 0
73498: PUSH
73499: LD_INT 0
73501: PUSH
73502: EMPTY
73503: LIST
73504: LIST
73505: PUSH
73506: LD_INT 0
73508: PUSH
73509: LD_INT 1
73511: NEG
73512: PUSH
73513: EMPTY
73514: LIST
73515: LIST
73516: PUSH
73517: LD_INT 1
73519: PUSH
73520: LD_INT 0
73522: PUSH
73523: EMPTY
73524: LIST
73525: LIST
73526: PUSH
73527: LD_INT 1
73529: PUSH
73530: LD_INT 1
73532: PUSH
73533: EMPTY
73534: LIST
73535: LIST
73536: PUSH
73537: LD_INT 0
73539: PUSH
73540: LD_INT 1
73542: PUSH
73543: EMPTY
73544: LIST
73545: LIST
73546: PUSH
73547: LD_INT 1
73549: NEG
73550: PUSH
73551: LD_INT 0
73553: PUSH
73554: EMPTY
73555: LIST
73556: LIST
73557: PUSH
73558: LD_INT 1
73560: NEG
73561: PUSH
73562: LD_INT 1
73564: NEG
73565: PUSH
73566: EMPTY
73567: LIST
73568: LIST
73569: PUSH
73570: LD_INT 1
73572: NEG
73573: PUSH
73574: LD_INT 2
73576: NEG
73577: PUSH
73578: EMPTY
73579: LIST
73580: LIST
73581: PUSH
73582: LD_INT 0
73584: PUSH
73585: LD_INT 2
73587: NEG
73588: PUSH
73589: EMPTY
73590: LIST
73591: LIST
73592: PUSH
73593: LD_INT 1
73595: PUSH
73596: LD_INT 1
73598: NEG
73599: PUSH
73600: EMPTY
73601: LIST
73602: LIST
73603: PUSH
73604: LD_INT 2
73606: PUSH
73607: LD_INT 0
73609: PUSH
73610: EMPTY
73611: LIST
73612: LIST
73613: PUSH
73614: LD_INT 2
73616: PUSH
73617: LD_INT 1
73619: PUSH
73620: EMPTY
73621: LIST
73622: LIST
73623: PUSH
73624: LD_INT 1
73626: PUSH
73627: LD_INT 2
73629: PUSH
73630: EMPTY
73631: LIST
73632: LIST
73633: PUSH
73634: LD_INT 0
73636: PUSH
73637: LD_INT 2
73639: PUSH
73640: EMPTY
73641: LIST
73642: LIST
73643: PUSH
73644: LD_INT 1
73646: NEG
73647: PUSH
73648: LD_INT 1
73650: PUSH
73651: EMPTY
73652: LIST
73653: LIST
73654: PUSH
73655: LD_INT 2
73657: NEG
73658: PUSH
73659: LD_INT 0
73661: PUSH
73662: EMPTY
73663: LIST
73664: LIST
73665: PUSH
73666: LD_INT 2
73668: NEG
73669: PUSH
73670: LD_INT 1
73672: NEG
73673: PUSH
73674: EMPTY
73675: LIST
73676: LIST
73677: PUSH
73678: LD_INT 1
73680: NEG
73681: PUSH
73682: LD_INT 3
73684: NEG
73685: PUSH
73686: EMPTY
73687: LIST
73688: LIST
73689: PUSH
73690: LD_INT 0
73692: PUSH
73693: LD_INT 3
73695: NEG
73696: PUSH
73697: EMPTY
73698: LIST
73699: LIST
73700: PUSH
73701: LD_INT 1
73703: PUSH
73704: LD_INT 2
73706: NEG
73707: PUSH
73708: EMPTY
73709: LIST
73710: LIST
73711: PUSH
73712: LD_INT 2
73714: PUSH
73715: LD_INT 1
73717: NEG
73718: PUSH
73719: EMPTY
73720: LIST
73721: LIST
73722: PUSH
73723: LD_INT 3
73725: PUSH
73726: LD_INT 0
73728: PUSH
73729: EMPTY
73730: LIST
73731: LIST
73732: PUSH
73733: LD_INT 3
73735: PUSH
73736: LD_INT 1
73738: PUSH
73739: EMPTY
73740: LIST
73741: LIST
73742: PUSH
73743: LD_INT 1
73745: PUSH
73746: LD_INT 3
73748: PUSH
73749: EMPTY
73750: LIST
73751: LIST
73752: PUSH
73753: LD_INT 0
73755: PUSH
73756: LD_INT 3
73758: PUSH
73759: EMPTY
73760: LIST
73761: LIST
73762: PUSH
73763: LD_INT 1
73765: NEG
73766: PUSH
73767: LD_INT 2
73769: PUSH
73770: EMPTY
73771: LIST
73772: LIST
73773: PUSH
73774: LD_INT 2
73776: NEG
73777: PUSH
73778: LD_INT 1
73780: PUSH
73781: EMPTY
73782: LIST
73783: LIST
73784: PUSH
73785: LD_INT 3
73787: NEG
73788: PUSH
73789: LD_INT 0
73791: PUSH
73792: EMPTY
73793: LIST
73794: LIST
73795: PUSH
73796: LD_INT 3
73798: NEG
73799: PUSH
73800: LD_INT 1
73802: NEG
73803: PUSH
73804: EMPTY
73805: LIST
73806: LIST
73807: PUSH
73808: EMPTY
73809: LIST
73810: LIST
73811: LIST
73812: LIST
73813: LIST
73814: LIST
73815: LIST
73816: LIST
73817: LIST
73818: LIST
73819: LIST
73820: LIST
73821: LIST
73822: LIST
73823: LIST
73824: LIST
73825: LIST
73826: LIST
73827: LIST
73828: LIST
73829: LIST
73830: LIST
73831: LIST
73832: LIST
73833: LIST
73834: LIST
73835: LIST
73836: LIST
73837: LIST
73838: ST_TO_ADDR
// Lab3 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ - 2 , - 3 ] , [ 2 , - 1 ] , [ 3 , 0 ] , [ 3 , 1 ] , [ 3 , 2 ] , [ 3 , 3 ] , [ 2 , 3 ] , [ - 2 , 1 ] , [ - 3 , 0 ] , [ - 3 , - 1 ] , [ - 3 , - 2 ] , [ - 3 , - 3 ] ] ;
73839: LD_ADDR_VAR 0 44
73843: PUSH
73844: LD_INT 0
73846: PUSH
73847: LD_INT 0
73849: PUSH
73850: EMPTY
73851: LIST
73852: LIST
73853: PUSH
73854: LD_INT 0
73856: PUSH
73857: LD_INT 1
73859: NEG
73860: PUSH
73861: EMPTY
73862: LIST
73863: LIST
73864: PUSH
73865: LD_INT 1
73867: PUSH
73868: LD_INT 0
73870: PUSH
73871: EMPTY
73872: LIST
73873: LIST
73874: PUSH
73875: LD_INT 1
73877: PUSH
73878: LD_INT 1
73880: PUSH
73881: EMPTY
73882: LIST
73883: LIST
73884: PUSH
73885: LD_INT 0
73887: PUSH
73888: LD_INT 1
73890: PUSH
73891: EMPTY
73892: LIST
73893: LIST
73894: PUSH
73895: LD_INT 1
73897: NEG
73898: PUSH
73899: LD_INT 0
73901: PUSH
73902: EMPTY
73903: LIST
73904: LIST
73905: PUSH
73906: LD_INT 1
73908: NEG
73909: PUSH
73910: LD_INT 1
73912: NEG
73913: PUSH
73914: EMPTY
73915: LIST
73916: LIST
73917: PUSH
73918: LD_INT 1
73920: NEG
73921: PUSH
73922: LD_INT 2
73924: NEG
73925: PUSH
73926: EMPTY
73927: LIST
73928: LIST
73929: PUSH
73930: LD_INT 1
73932: PUSH
73933: LD_INT 1
73935: NEG
73936: PUSH
73937: EMPTY
73938: LIST
73939: LIST
73940: PUSH
73941: LD_INT 2
73943: PUSH
73944: LD_INT 0
73946: PUSH
73947: EMPTY
73948: LIST
73949: LIST
73950: PUSH
73951: LD_INT 2
73953: PUSH
73954: LD_INT 1
73956: PUSH
73957: EMPTY
73958: LIST
73959: LIST
73960: PUSH
73961: LD_INT 2
73963: PUSH
73964: LD_INT 2
73966: PUSH
73967: EMPTY
73968: LIST
73969: LIST
73970: PUSH
73971: LD_INT 1
73973: PUSH
73974: LD_INT 2
73976: PUSH
73977: EMPTY
73978: LIST
73979: LIST
73980: PUSH
73981: LD_INT 1
73983: NEG
73984: PUSH
73985: LD_INT 1
73987: PUSH
73988: EMPTY
73989: LIST
73990: LIST
73991: PUSH
73992: LD_INT 2
73994: NEG
73995: PUSH
73996: LD_INT 0
73998: PUSH
73999: EMPTY
74000: LIST
74001: LIST
74002: PUSH
74003: LD_INT 2
74005: NEG
74006: PUSH
74007: LD_INT 1
74009: NEG
74010: PUSH
74011: EMPTY
74012: LIST
74013: LIST
74014: PUSH
74015: LD_INT 2
74017: NEG
74018: PUSH
74019: LD_INT 2
74021: NEG
74022: PUSH
74023: EMPTY
74024: LIST
74025: LIST
74026: PUSH
74027: LD_INT 2
74029: NEG
74030: PUSH
74031: LD_INT 3
74033: NEG
74034: PUSH
74035: EMPTY
74036: LIST
74037: LIST
74038: PUSH
74039: LD_INT 2
74041: PUSH
74042: LD_INT 1
74044: NEG
74045: PUSH
74046: EMPTY
74047: LIST
74048: LIST
74049: PUSH
74050: LD_INT 3
74052: PUSH
74053: LD_INT 0
74055: PUSH
74056: EMPTY
74057: LIST
74058: LIST
74059: PUSH
74060: LD_INT 3
74062: PUSH
74063: LD_INT 1
74065: PUSH
74066: EMPTY
74067: LIST
74068: LIST
74069: PUSH
74070: LD_INT 3
74072: PUSH
74073: LD_INT 2
74075: PUSH
74076: EMPTY
74077: LIST
74078: LIST
74079: PUSH
74080: LD_INT 3
74082: PUSH
74083: LD_INT 3
74085: PUSH
74086: EMPTY
74087: LIST
74088: LIST
74089: PUSH
74090: LD_INT 2
74092: PUSH
74093: LD_INT 3
74095: PUSH
74096: EMPTY
74097: LIST
74098: LIST
74099: PUSH
74100: LD_INT 2
74102: NEG
74103: PUSH
74104: LD_INT 1
74106: PUSH
74107: EMPTY
74108: LIST
74109: LIST
74110: PUSH
74111: LD_INT 3
74113: NEG
74114: PUSH
74115: LD_INT 0
74117: PUSH
74118: EMPTY
74119: LIST
74120: LIST
74121: PUSH
74122: LD_INT 3
74124: NEG
74125: PUSH
74126: LD_INT 1
74128: NEG
74129: PUSH
74130: EMPTY
74131: LIST
74132: LIST
74133: PUSH
74134: LD_INT 3
74136: NEG
74137: PUSH
74138: LD_INT 2
74140: NEG
74141: PUSH
74142: EMPTY
74143: LIST
74144: LIST
74145: PUSH
74146: LD_INT 3
74148: NEG
74149: PUSH
74150: LD_INT 3
74152: NEG
74153: PUSH
74154: EMPTY
74155: LIST
74156: LIST
74157: PUSH
74158: EMPTY
74159: LIST
74160: LIST
74161: LIST
74162: LIST
74163: LIST
74164: LIST
74165: LIST
74166: LIST
74167: LIST
74168: LIST
74169: LIST
74170: LIST
74171: LIST
74172: LIST
74173: LIST
74174: LIST
74175: LIST
74176: LIST
74177: LIST
74178: LIST
74179: LIST
74180: LIST
74181: LIST
74182: LIST
74183: LIST
74184: LIST
74185: LIST
74186: LIST
74187: LIST
74188: ST_TO_ADDR
// Lab4 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ - 2 , - 3 ] , [ - 1 , - 3 ] , [ 0 , - 3 ] , [ 1 , - 2 ] , [ 3 , 2 ] , [ 3 , 3 ] , [ 2 , 3 ] , [ 1 , 3 ] , [ 0 , 3 ] , [ - 1 , 2 ] , [ - 3 , - 2 ] , [ - 3 , - 3 ] ] ;
74189: LD_ADDR_VAR 0 45
74193: PUSH
74194: LD_INT 0
74196: PUSH
74197: LD_INT 0
74199: PUSH
74200: EMPTY
74201: LIST
74202: LIST
74203: PUSH
74204: LD_INT 0
74206: PUSH
74207: LD_INT 1
74209: NEG
74210: PUSH
74211: EMPTY
74212: LIST
74213: LIST
74214: PUSH
74215: LD_INT 1
74217: PUSH
74218: LD_INT 0
74220: PUSH
74221: EMPTY
74222: LIST
74223: LIST
74224: PUSH
74225: LD_INT 1
74227: PUSH
74228: LD_INT 1
74230: PUSH
74231: EMPTY
74232: LIST
74233: LIST
74234: PUSH
74235: LD_INT 0
74237: PUSH
74238: LD_INT 1
74240: PUSH
74241: EMPTY
74242: LIST
74243: LIST
74244: PUSH
74245: LD_INT 1
74247: NEG
74248: PUSH
74249: LD_INT 0
74251: PUSH
74252: EMPTY
74253: LIST
74254: LIST
74255: PUSH
74256: LD_INT 1
74258: NEG
74259: PUSH
74260: LD_INT 1
74262: NEG
74263: PUSH
74264: EMPTY
74265: LIST
74266: LIST
74267: PUSH
74268: LD_INT 1
74270: NEG
74271: PUSH
74272: LD_INT 2
74274: NEG
74275: PUSH
74276: EMPTY
74277: LIST
74278: LIST
74279: PUSH
74280: LD_INT 0
74282: PUSH
74283: LD_INT 2
74285: NEG
74286: PUSH
74287: EMPTY
74288: LIST
74289: LIST
74290: PUSH
74291: LD_INT 1
74293: PUSH
74294: LD_INT 1
74296: NEG
74297: PUSH
74298: EMPTY
74299: LIST
74300: LIST
74301: PUSH
74302: LD_INT 2
74304: PUSH
74305: LD_INT 1
74307: PUSH
74308: EMPTY
74309: LIST
74310: LIST
74311: PUSH
74312: LD_INT 2
74314: PUSH
74315: LD_INT 2
74317: PUSH
74318: EMPTY
74319: LIST
74320: LIST
74321: PUSH
74322: LD_INT 1
74324: PUSH
74325: LD_INT 2
74327: PUSH
74328: EMPTY
74329: LIST
74330: LIST
74331: PUSH
74332: LD_INT 0
74334: PUSH
74335: LD_INT 2
74337: PUSH
74338: EMPTY
74339: LIST
74340: LIST
74341: PUSH
74342: LD_INT 1
74344: NEG
74345: PUSH
74346: LD_INT 1
74348: PUSH
74349: EMPTY
74350: LIST
74351: LIST
74352: PUSH
74353: LD_INT 2
74355: NEG
74356: PUSH
74357: LD_INT 1
74359: NEG
74360: PUSH
74361: EMPTY
74362: LIST
74363: LIST
74364: PUSH
74365: LD_INT 2
74367: NEG
74368: PUSH
74369: LD_INT 2
74371: NEG
74372: PUSH
74373: EMPTY
74374: LIST
74375: LIST
74376: PUSH
74377: LD_INT 2
74379: NEG
74380: PUSH
74381: LD_INT 3
74383: NEG
74384: PUSH
74385: EMPTY
74386: LIST
74387: LIST
74388: PUSH
74389: LD_INT 1
74391: NEG
74392: PUSH
74393: LD_INT 3
74395: NEG
74396: PUSH
74397: EMPTY
74398: LIST
74399: LIST
74400: PUSH
74401: LD_INT 0
74403: PUSH
74404: LD_INT 3
74406: NEG
74407: PUSH
74408: EMPTY
74409: LIST
74410: LIST
74411: PUSH
74412: LD_INT 1
74414: PUSH
74415: LD_INT 2
74417: NEG
74418: PUSH
74419: EMPTY
74420: LIST
74421: LIST
74422: PUSH
74423: LD_INT 3
74425: PUSH
74426: LD_INT 2
74428: PUSH
74429: EMPTY
74430: LIST
74431: LIST
74432: PUSH
74433: LD_INT 3
74435: PUSH
74436: LD_INT 3
74438: PUSH
74439: EMPTY
74440: LIST
74441: LIST
74442: PUSH
74443: LD_INT 2
74445: PUSH
74446: LD_INT 3
74448: PUSH
74449: EMPTY
74450: LIST
74451: LIST
74452: PUSH
74453: LD_INT 1
74455: PUSH
74456: LD_INT 3
74458: PUSH
74459: EMPTY
74460: LIST
74461: LIST
74462: PUSH
74463: LD_INT 0
74465: PUSH
74466: LD_INT 3
74468: PUSH
74469: EMPTY
74470: LIST
74471: LIST
74472: PUSH
74473: LD_INT 1
74475: NEG
74476: PUSH
74477: LD_INT 2
74479: PUSH
74480: EMPTY
74481: LIST
74482: LIST
74483: PUSH
74484: LD_INT 3
74486: NEG
74487: PUSH
74488: LD_INT 2
74490: NEG
74491: PUSH
74492: EMPTY
74493: LIST
74494: LIST
74495: PUSH
74496: LD_INT 3
74498: NEG
74499: PUSH
74500: LD_INT 3
74502: NEG
74503: PUSH
74504: EMPTY
74505: LIST
74506: LIST
74507: PUSH
74508: EMPTY
74509: LIST
74510: LIST
74511: LIST
74512: LIST
74513: LIST
74514: LIST
74515: LIST
74516: LIST
74517: LIST
74518: LIST
74519: LIST
74520: LIST
74521: LIST
74522: LIST
74523: LIST
74524: LIST
74525: LIST
74526: LIST
74527: LIST
74528: LIST
74529: LIST
74530: LIST
74531: LIST
74532: LIST
74533: LIST
74534: LIST
74535: LIST
74536: LIST
74537: LIST
74538: ST_TO_ADDR
// Lab5 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 1 , - 3 ] , [ 0 , - 3 ] , [ 1 , - 2 ] , [ 2 , - 1 ] , [ 3 , 0 ] , [ 3 , 1 ] , [ 1 , 3 ] , [ 0 , 3 ] , [ - 1 , 2 ] , [ - 2 , 1 ] , [ - 3 , 0 ] , [ - 3 , - 1 ] ] ;
74539: LD_ADDR_VAR 0 46
74543: PUSH
74544: LD_INT 0
74546: PUSH
74547: LD_INT 0
74549: PUSH
74550: EMPTY
74551: LIST
74552: LIST
74553: PUSH
74554: LD_INT 0
74556: PUSH
74557: LD_INT 1
74559: NEG
74560: PUSH
74561: EMPTY
74562: LIST
74563: LIST
74564: PUSH
74565: LD_INT 1
74567: PUSH
74568: LD_INT 0
74570: PUSH
74571: EMPTY
74572: LIST
74573: LIST
74574: PUSH
74575: LD_INT 1
74577: PUSH
74578: LD_INT 1
74580: PUSH
74581: EMPTY
74582: LIST
74583: LIST
74584: PUSH
74585: LD_INT 0
74587: PUSH
74588: LD_INT 1
74590: PUSH
74591: EMPTY
74592: LIST
74593: LIST
74594: PUSH
74595: LD_INT 1
74597: NEG
74598: PUSH
74599: LD_INT 0
74601: PUSH
74602: EMPTY
74603: LIST
74604: LIST
74605: PUSH
74606: LD_INT 1
74608: NEG
74609: PUSH
74610: LD_INT 1
74612: NEG
74613: PUSH
74614: EMPTY
74615: LIST
74616: LIST
74617: PUSH
74618: LD_INT 1
74620: NEG
74621: PUSH
74622: LD_INT 2
74624: NEG
74625: PUSH
74626: EMPTY
74627: LIST
74628: LIST
74629: PUSH
74630: LD_INT 0
74632: PUSH
74633: LD_INT 2
74635: NEG
74636: PUSH
74637: EMPTY
74638: LIST
74639: LIST
74640: PUSH
74641: LD_INT 1
74643: PUSH
74644: LD_INT 1
74646: NEG
74647: PUSH
74648: EMPTY
74649: LIST
74650: LIST
74651: PUSH
74652: LD_INT 2
74654: PUSH
74655: LD_INT 0
74657: PUSH
74658: EMPTY
74659: LIST
74660: LIST
74661: PUSH
74662: LD_INT 2
74664: PUSH
74665: LD_INT 1
74667: PUSH
74668: EMPTY
74669: LIST
74670: LIST
74671: PUSH
74672: LD_INT 1
74674: PUSH
74675: LD_INT 2
74677: PUSH
74678: EMPTY
74679: LIST
74680: LIST
74681: PUSH
74682: LD_INT 0
74684: PUSH
74685: LD_INT 2
74687: PUSH
74688: EMPTY
74689: LIST
74690: LIST
74691: PUSH
74692: LD_INT 1
74694: NEG
74695: PUSH
74696: LD_INT 1
74698: PUSH
74699: EMPTY
74700: LIST
74701: LIST
74702: PUSH
74703: LD_INT 2
74705: NEG
74706: PUSH
74707: LD_INT 0
74709: PUSH
74710: EMPTY
74711: LIST
74712: LIST
74713: PUSH
74714: LD_INT 2
74716: NEG
74717: PUSH
74718: LD_INT 1
74720: NEG
74721: PUSH
74722: EMPTY
74723: LIST
74724: LIST
74725: PUSH
74726: LD_INT 1
74728: NEG
74729: PUSH
74730: LD_INT 3
74732: NEG
74733: PUSH
74734: EMPTY
74735: LIST
74736: LIST
74737: PUSH
74738: LD_INT 0
74740: PUSH
74741: LD_INT 3
74743: NEG
74744: PUSH
74745: EMPTY
74746: LIST
74747: LIST
74748: PUSH
74749: LD_INT 1
74751: PUSH
74752: LD_INT 2
74754: NEG
74755: PUSH
74756: EMPTY
74757: LIST
74758: LIST
74759: PUSH
74760: LD_INT 2
74762: PUSH
74763: LD_INT 1
74765: NEG
74766: PUSH
74767: EMPTY
74768: LIST
74769: LIST
74770: PUSH
74771: LD_INT 3
74773: PUSH
74774: LD_INT 0
74776: PUSH
74777: EMPTY
74778: LIST
74779: LIST
74780: PUSH
74781: LD_INT 3
74783: PUSH
74784: LD_INT 1
74786: PUSH
74787: EMPTY
74788: LIST
74789: LIST
74790: PUSH
74791: LD_INT 1
74793: PUSH
74794: LD_INT 3
74796: PUSH
74797: EMPTY
74798: LIST
74799: LIST
74800: PUSH
74801: LD_INT 0
74803: PUSH
74804: LD_INT 3
74806: PUSH
74807: EMPTY
74808: LIST
74809: LIST
74810: PUSH
74811: LD_INT 1
74813: NEG
74814: PUSH
74815: LD_INT 2
74817: PUSH
74818: EMPTY
74819: LIST
74820: LIST
74821: PUSH
74822: LD_INT 2
74824: NEG
74825: PUSH
74826: LD_INT 1
74828: PUSH
74829: EMPTY
74830: LIST
74831: LIST
74832: PUSH
74833: LD_INT 3
74835: NEG
74836: PUSH
74837: LD_INT 0
74839: PUSH
74840: EMPTY
74841: LIST
74842: LIST
74843: PUSH
74844: LD_INT 3
74846: NEG
74847: PUSH
74848: LD_INT 1
74850: NEG
74851: PUSH
74852: EMPTY
74853: LIST
74854: LIST
74855: PUSH
74856: EMPTY
74857: LIST
74858: LIST
74859: LIST
74860: LIST
74861: LIST
74862: LIST
74863: LIST
74864: LIST
74865: LIST
74866: LIST
74867: LIST
74868: LIST
74869: LIST
74870: LIST
74871: LIST
74872: LIST
74873: LIST
74874: LIST
74875: LIST
74876: LIST
74877: LIST
74878: LIST
74879: LIST
74880: LIST
74881: LIST
74882: LIST
74883: LIST
74884: LIST
74885: LIST
74886: ST_TO_ADDR
// ControlTower0 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
74887: LD_ADDR_VAR 0 47
74891: PUSH
74892: LD_INT 0
74894: PUSH
74895: LD_INT 0
74897: PUSH
74898: EMPTY
74899: LIST
74900: LIST
74901: PUSH
74902: LD_INT 0
74904: PUSH
74905: LD_INT 1
74907: NEG
74908: PUSH
74909: EMPTY
74910: LIST
74911: LIST
74912: PUSH
74913: LD_INT 1
74915: PUSH
74916: LD_INT 0
74918: PUSH
74919: EMPTY
74920: LIST
74921: LIST
74922: PUSH
74923: LD_INT 1
74925: PUSH
74926: LD_INT 1
74928: PUSH
74929: EMPTY
74930: LIST
74931: LIST
74932: PUSH
74933: LD_INT 0
74935: PUSH
74936: LD_INT 1
74938: PUSH
74939: EMPTY
74940: LIST
74941: LIST
74942: PUSH
74943: LD_INT 1
74945: NEG
74946: PUSH
74947: LD_INT 0
74949: PUSH
74950: EMPTY
74951: LIST
74952: LIST
74953: PUSH
74954: LD_INT 1
74956: NEG
74957: PUSH
74958: LD_INT 1
74960: NEG
74961: PUSH
74962: EMPTY
74963: LIST
74964: LIST
74965: PUSH
74966: LD_INT 1
74968: NEG
74969: PUSH
74970: LD_INT 2
74972: NEG
74973: PUSH
74974: EMPTY
74975: LIST
74976: LIST
74977: PUSH
74978: LD_INT 0
74980: PUSH
74981: LD_INT 2
74983: NEG
74984: PUSH
74985: EMPTY
74986: LIST
74987: LIST
74988: PUSH
74989: LD_INT 1
74991: PUSH
74992: LD_INT 1
74994: NEG
74995: PUSH
74996: EMPTY
74997: LIST
74998: LIST
74999: PUSH
75000: LD_INT 2
75002: NEG
75003: PUSH
75004: LD_INT 1
75006: NEG
75007: PUSH
75008: EMPTY
75009: LIST
75010: LIST
75011: PUSH
75012: LD_INT 2
75014: NEG
75015: PUSH
75016: LD_INT 2
75018: NEG
75019: PUSH
75020: EMPTY
75021: LIST
75022: LIST
75023: PUSH
75024: EMPTY
75025: LIST
75026: LIST
75027: LIST
75028: LIST
75029: LIST
75030: LIST
75031: LIST
75032: LIST
75033: LIST
75034: LIST
75035: LIST
75036: LIST
75037: ST_TO_ADDR
// ControlTower1 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] ] ;
75038: LD_ADDR_VAR 0 48
75042: PUSH
75043: LD_INT 0
75045: PUSH
75046: LD_INT 0
75048: PUSH
75049: EMPTY
75050: LIST
75051: LIST
75052: PUSH
75053: LD_INT 0
75055: PUSH
75056: LD_INT 1
75058: NEG
75059: PUSH
75060: EMPTY
75061: LIST
75062: LIST
75063: PUSH
75064: LD_INT 1
75066: PUSH
75067: LD_INT 0
75069: PUSH
75070: EMPTY
75071: LIST
75072: LIST
75073: PUSH
75074: LD_INT 1
75076: PUSH
75077: LD_INT 1
75079: PUSH
75080: EMPTY
75081: LIST
75082: LIST
75083: PUSH
75084: LD_INT 0
75086: PUSH
75087: LD_INT 1
75089: PUSH
75090: EMPTY
75091: LIST
75092: LIST
75093: PUSH
75094: LD_INT 1
75096: NEG
75097: PUSH
75098: LD_INT 0
75100: PUSH
75101: EMPTY
75102: LIST
75103: LIST
75104: PUSH
75105: LD_INT 1
75107: NEG
75108: PUSH
75109: LD_INT 1
75111: NEG
75112: PUSH
75113: EMPTY
75114: LIST
75115: LIST
75116: PUSH
75117: LD_INT 1
75119: NEG
75120: PUSH
75121: LD_INT 2
75123: NEG
75124: PUSH
75125: EMPTY
75126: LIST
75127: LIST
75128: PUSH
75129: LD_INT 0
75131: PUSH
75132: LD_INT 2
75134: NEG
75135: PUSH
75136: EMPTY
75137: LIST
75138: LIST
75139: PUSH
75140: LD_INT 1
75142: PUSH
75143: LD_INT 1
75145: NEG
75146: PUSH
75147: EMPTY
75148: LIST
75149: LIST
75150: PUSH
75151: LD_INT 2
75153: PUSH
75154: LD_INT 0
75156: PUSH
75157: EMPTY
75158: LIST
75159: LIST
75160: PUSH
75161: LD_INT 2
75163: PUSH
75164: LD_INT 1
75166: PUSH
75167: EMPTY
75168: LIST
75169: LIST
75170: PUSH
75171: EMPTY
75172: LIST
75173: LIST
75174: LIST
75175: LIST
75176: LIST
75177: LIST
75178: LIST
75179: LIST
75180: LIST
75181: LIST
75182: LIST
75183: LIST
75184: ST_TO_ADDR
// ControlTower2 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] ] ;
75185: LD_ADDR_VAR 0 49
75189: PUSH
75190: LD_INT 0
75192: PUSH
75193: LD_INT 0
75195: PUSH
75196: EMPTY
75197: LIST
75198: LIST
75199: PUSH
75200: LD_INT 0
75202: PUSH
75203: LD_INT 1
75205: NEG
75206: PUSH
75207: EMPTY
75208: LIST
75209: LIST
75210: PUSH
75211: LD_INT 1
75213: PUSH
75214: LD_INT 0
75216: PUSH
75217: EMPTY
75218: LIST
75219: LIST
75220: PUSH
75221: LD_INT 1
75223: PUSH
75224: LD_INT 1
75226: PUSH
75227: EMPTY
75228: LIST
75229: LIST
75230: PUSH
75231: LD_INT 0
75233: PUSH
75234: LD_INT 1
75236: PUSH
75237: EMPTY
75238: LIST
75239: LIST
75240: PUSH
75241: LD_INT 1
75243: NEG
75244: PUSH
75245: LD_INT 0
75247: PUSH
75248: EMPTY
75249: LIST
75250: LIST
75251: PUSH
75252: LD_INT 1
75254: NEG
75255: PUSH
75256: LD_INT 1
75258: NEG
75259: PUSH
75260: EMPTY
75261: LIST
75262: LIST
75263: PUSH
75264: LD_INT 1
75266: PUSH
75267: LD_INT 1
75269: NEG
75270: PUSH
75271: EMPTY
75272: LIST
75273: LIST
75274: PUSH
75275: LD_INT 2
75277: PUSH
75278: LD_INT 0
75280: PUSH
75281: EMPTY
75282: LIST
75283: LIST
75284: PUSH
75285: LD_INT 2
75287: PUSH
75288: LD_INT 1
75290: PUSH
75291: EMPTY
75292: LIST
75293: LIST
75294: PUSH
75295: LD_INT 2
75297: PUSH
75298: LD_INT 2
75300: PUSH
75301: EMPTY
75302: LIST
75303: LIST
75304: PUSH
75305: LD_INT 1
75307: PUSH
75308: LD_INT 2
75310: PUSH
75311: EMPTY
75312: LIST
75313: LIST
75314: PUSH
75315: EMPTY
75316: LIST
75317: LIST
75318: LIST
75319: LIST
75320: LIST
75321: LIST
75322: LIST
75323: LIST
75324: LIST
75325: LIST
75326: LIST
75327: LIST
75328: ST_TO_ADDR
// ControlTower3 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] ] ;
75329: LD_ADDR_VAR 0 50
75333: PUSH
75334: LD_INT 0
75336: PUSH
75337: LD_INT 0
75339: PUSH
75340: EMPTY
75341: LIST
75342: LIST
75343: PUSH
75344: LD_INT 0
75346: PUSH
75347: LD_INT 1
75349: NEG
75350: PUSH
75351: EMPTY
75352: LIST
75353: LIST
75354: PUSH
75355: LD_INT 1
75357: PUSH
75358: LD_INT 0
75360: PUSH
75361: EMPTY
75362: LIST
75363: LIST
75364: PUSH
75365: LD_INT 1
75367: PUSH
75368: LD_INT 1
75370: PUSH
75371: EMPTY
75372: LIST
75373: LIST
75374: PUSH
75375: LD_INT 0
75377: PUSH
75378: LD_INT 1
75380: PUSH
75381: EMPTY
75382: LIST
75383: LIST
75384: PUSH
75385: LD_INT 1
75387: NEG
75388: PUSH
75389: LD_INT 0
75391: PUSH
75392: EMPTY
75393: LIST
75394: LIST
75395: PUSH
75396: LD_INT 1
75398: NEG
75399: PUSH
75400: LD_INT 1
75402: NEG
75403: PUSH
75404: EMPTY
75405: LIST
75406: LIST
75407: PUSH
75408: LD_INT 2
75410: PUSH
75411: LD_INT 1
75413: PUSH
75414: EMPTY
75415: LIST
75416: LIST
75417: PUSH
75418: LD_INT 2
75420: PUSH
75421: LD_INT 2
75423: PUSH
75424: EMPTY
75425: LIST
75426: LIST
75427: PUSH
75428: LD_INT 1
75430: PUSH
75431: LD_INT 2
75433: PUSH
75434: EMPTY
75435: LIST
75436: LIST
75437: PUSH
75438: LD_INT 0
75440: PUSH
75441: LD_INT 2
75443: PUSH
75444: EMPTY
75445: LIST
75446: LIST
75447: PUSH
75448: LD_INT 1
75450: NEG
75451: PUSH
75452: LD_INT 1
75454: PUSH
75455: EMPTY
75456: LIST
75457: LIST
75458: PUSH
75459: EMPTY
75460: LIST
75461: LIST
75462: LIST
75463: LIST
75464: LIST
75465: LIST
75466: LIST
75467: LIST
75468: LIST
75469: LIST
75470: LIST
75471: LIST
75472: ST_TO_ADDR
// ControlTower4 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] ] ;
75473: LD_ADDR_VAR 0 51
75477: PUSH
75478: LD_INT 0
75480: PUSH
75481: LD_INT 0
75483: PUSH
75484: EMPTY
75485: LIST
75486: LIST
75487: PUSH
75488: LD_INT 0
75490: PUSH
75491: LD_INT 1
75493: NEG
75494: PUSH
75495: EMPTY
75496: LIST
75497: LIST
75498: PUSH
75499: LD_INT 1
75501: PUSH
75502: LD_INT 0
75504: PUSH
75505: EMPTY
75506: LIST
75507: LIST
75508: PUSH
75509: LD_INT 1
75511: PUSH
75512: LD_INT 1
75514: PUSH
75515: EMPTY
75516: LIST
75517: LIST
75518: PUSH
75519: LD_INT 0
75521: PUSH
75522: LD_INT 1
75524: PUSH
75525: EMPTY
75526: LIST
75527: LIST
75528: PUSH
75529: LD_INT 1
75531: NEG
75532: PUSH
75533: LD_INT 0
75535: PUSH
75536: EMPTY
75537: LIST
75538: LIST
75539: PUSH
75540: LD_INT 1
75542: NEG
75543: PUSH
75544: LD_INT 1
75546: NEG
75547: PUSH
75548: EMPTY
75549: LIST
75550: LIST
75551: PUSH
75552: LD_INT 1
75554: PUSH
75555: LD_INT 2
75557: PUSH
75558: EMPTY
75559: LIST
75560: LIST
75561: PUSH
75562: LD_INT 0
75564: PUSH
75565: LD_INT 2
75567: PUSH
75568: EMPTY
75569: LIST
75570: LIST
75571: PUSH
75572: LD_INT 1
75574: NEG
75575: PUSH
75576: LD_INT 1
75578: PUSH
75579: EMPTY
75580: LIST
75581: LIST
75582: PUSH
75583: LD_INT 2
75585: NEG
75586: PUSH
75587: LD_INT 0
75589: PUSH
75590: EMPTY
75591: LIST
75592: LIST
75593: PUSH
75594: LD_INT 2
75596: NEG
75597: PUSH
75598: LD_INT 1
75600: NEG
75601: PUSH
75602: EMPTY
75603: LIST
75604: LIST
75605: PUSH
75606: EMPTY
75607: LIST
75608: LIST
75609: LIST
75610: LIST
75611: LIST
75612: LIST
75613: LIST
75614: LIST
75615: LIST
75616: LIST
75617: LIST
75618: LIST
75619: ST_TO_ADDR
// ControlTower5 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
75620: LD_ADDR_VAR 0 52
75624: PUSH
75625: LD_INT 0
75627: PUSH
75628: LD_INT 0
75630: PUSH
75631: EMPTY
75632: LIST
75633: LIST
75634: PUSH
75635: LD_INT 0
75637: PUSH
75638: LD_INT 1
75640: NEG
75641: PUSH
75642: EMPTY
75643: LIST
75644: LIST
75645: PUSH
75646: LD_INT 1
75648: PUSH
75649: LD_INT 0
75651: PUSH
75652: EMPTY
75653: LIST
75654: LIST
75655: PUSH
75656: LD_INT 1
75658: PUSH
75659: LD_INT 1
75661: PUSH
75662: EMPTY
75663: LIST
75664: LIST
75665: PUSH
75666: LD_INT 0
75668: PUSH
75669: LD_INT 1
75671: PUSH
75672: EMPTY
75673: LIST
75674: LIST
75675: PUSH
75676: LD_INT 1
75678: NEG
75679: PUSH
75680: LD_INT 0
75682: PUSH
75683: EMPTY
75684: LIST
75685: LIST
75686: PUSH
75687: LD_INT 1
75689: NEG
75690: PUSH
75691: LD_INT 1
75693: NEG
75694: PUSH
75695: EMPTY
75696: LIST
75697: LIST
75698: PUSH
75699: LD_INT 1
75701: NEG
75702: PUSH
75703: LD_INT 2
75705: NEG
75706: PUSH
75707: EMPTY
75708: LIST
75709: LIST
75710: PUSH
75711: LD_INT 1
75713: NEG
75714: PUSH
75715: LD_INT 1
75717: PUSH
75718: EMPTY
75719: LIST
75720: LIST
75721: PUSH
75722: LD_INT 2
75724: NEG
75725: PUSH
75726: LD_INT 0
75728: PUSH
75729: EMPTY
75730: LIST
75731: LIST
75732: PUSH
75733: LD_INT 2
75735: NEG
75736: PUSH
75737: LD_INT 1
75739: NEG
75740: PUSH
75741: EMPTY
75742: LIST
75743: LIST
75744: PUSH
75745: LD_INT 2
75747: NEG
75748: PUSH
75749: LD_INT 2
75751: NEG
75752: PUSH
75753: EMPTY
75754: LIST
75755: LIST
75756: PUSH
75757: EMPTY
75758: LIST
75759: LIST
75760: LIST
75761: LIST
75762: LIST
75763: LIST
75764: LIST
75765: LIST
75766: LIST
75767: LIST
75768: LIST
75769: LIST
75770: ST_TO_ADDR
// Barracks0 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
75771: LD_ADDR_VAR 0 53
75775: PUSH
75776: LD_INT 0
75778: PUSH
75779: LD_INT 0
75781: PUSH
75782: EMPTY
75783: LIST
75784: LIST
75785: PUSH
75786: LD_INT 0
75788: PUSH
75789: LD_INT 1
75791: NEG
75792: PUSH
75793: EMPTY
75794: LIST
75795: LIST
75796: PUSH
75797: LD_INT 1
75799: PUSH
75800: LD_INT 0
75802: PUSH
75803: EMPTY
75804: LIST
75805: LIST
75806: PUSH
75807: LD_INT 1
75809: PUSH
75810: LD_INT 1
75812: PUSH
75813: EMPTY
75814: LIST
75815: LIST
75816: PUSH
75817: LD_INT 0
75819: PUSH
75820: LD_INT 1
75822: PUSH
75823: EMPTY
75824: LIST
75825: LIST
75826: PUSH
75827: LD_INT 1
75829: NEG
75830: PUSH
75831: LD_INT 0
75833: PUSH
75834: EMPTY
75835: LIST
75836: LIST
75837: PUSH
75838: LD_INT 1
75840: NEG
75841: PUSH
75842: LD_INT 1
75844: NEG
75845: PUSH
75846: EMPTY
75847: LIST
75848: LIST
75849: PUSH
75850: LD_INT 1
75852: NEG
75853: PUSH
75854: LD_INT 2
75856: NEG
75857: PUSH
75858: EMPTY
75859: LIST
75860: LIST
75861: PUSH
75862: LD_INT 0
75864: PUSH
75865: LD_INT 2
75867: NEG
75868: PUSH
75869: EMPTY
75870: LIST
75871: LIST
75872: PUSH
75873: LD_INT 1
75875: PUSH
75876: LD_INT 1
75878: NEG
75879: PUSH
75880: EMPTY
75881: LIST
75882: LIST
75883: PUSH
75884: LD_INT 2
75886: PUSH
75887: LD_INT 0
75889: PUSH
75890: EMPTY
75891: LIST
75892: LIST
75893: PUSH
75894: LD_INT 2
75896: PUSH
75897: LD_INT 1
75899: PUSH
75900: EMPTY
75901: LIST
75902: LIST
75903: PUSH
75904: LD_INT 2
75906: PUSH
75907: LD_INT 2
75909: PUSH
75910: EMPTY
75911: LIST
75912: LIST
75913: PUSH
75914: LD_INT 1
75916: PUSH
75917: LD_INT 2
75919: PUSH
75920: EMPTY
75921: LIST
75922: LIST
75923: PUSH
75924: LD_INT 0
75926: PUSH
75927: LD_INT 2
75929: PUSH
75930: EMPTY
75931: LIST
75932: LIST
75933: PUSH
75934: LD_INT 1
75936: NEG
75937: PUSH
75938: LD_INT 1
75940: PUSH
75941: EMPTY
75942: LIST
75943: LIST
75944: PUSH
75945: LD_INT 2
75947: NEG
75948: PUSH
75949: LD_INT 0
75951: PUSH
75952: EMPTY
75953: LIST
75954: LIST
75955: PUSH
75956: LD_INT 2
75958: NEG
75959: PUSH
75960: LD_INT 1
75962: NEG
75963: PUSH
75964: EMPTY
75965: LIST
75966: LIST
75967: PUSH
75968: LD_INT 2
75970: NEG
75971: PUSH
75972: LD_INT 2
75974: NEG
75975: PUSH
75976: EMPTY
75977: LIST
75978: LIST
75979: PUSH
75980: EMPTY
75981: LIST
75982: LIST
75983: LIST
75984: LIST
75985: LIST
75986: LIST
75987: LIST
75988: LIST
75989: LIST
75990: LIST
75991: LIST
75992: LIST
75993: LIST
75994: LIST
75995: LIST
75996: LIST
75997: LIST
75998: LIST
75999: LIST
76000: ST_TO_ADDR
// Barracks1 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
76001: LD_ADDR_VAR 0 54
76005: PUSH
76006: LD_INT 0
76008: PUSH
76009: LD_INT 0
76011: PUSH
76012: EMPTY
76013: LIST
76014: LIST
76015: PUSH
76016: LD_INT 0
76018: PUSH
76019: LD_INT 1
76021: NEG
76022: PUSH
76023: EMPTY
76024: LIST
76025: LIST
76026: PUSH
76027: LD_INT 1
76029: PUSH
76030: LD_INT 0
76032: PUSH
76033: EMPTY
76034: LIST
76035: LIST
76036: PUSH
76037: LD_INT 1
76039: PUSH
76040: LD_INT 1
76042: PUSH
76043: EMPTY
76044: LIST
76045: LIST
76046: PUSH
76047: LD_INT 0
76049: PUSH
76050: LD_INT 1
76052: PUSH
76053: EMPTY
76054: LIST
76055: LIST
76056: PUSH
76057: LD_INT 1
76059: NEG
76060: PUSH
76061: LD_INT 0
76063: PUSH
76064: EMPTY
76065: LIST
76066: LIST
76067: PUSH
76068: LD_INT 1
76070: NEG
76071: PUSH
76072: LD_INT 1
76074: NEG
76075: PUSH
76076: EMPTY
76077: LIST
76078: LIST
76079: PUSH
76080: LD_INT 1
76082: NEG
76083: PUSH
76084: LD_INT 2
76086: NEG
76087: PUSH
76088: EMPTY
76089: LIST
76090: LIST
76091: PUSH
76092: LD_INT 0
76094: PUSH
76095: LD_INT 2
76097: NEG
76098: PUSH
76099: EMPTY
76100: LIST
76101: LIST
76102: PUSH
76103: LD_INT 1
76105: PUSH
76106: LD_INT 1
76108: NEG
76109: PUSH
76110: EMPTY
76111: LIST
76112: LIST
76113: PUSH
76114: LD_INT 2
76116: PUSH
76117: LD_INT 0
76119: PUSH
76120: EMPTY
76121: LIST
76122: LIST
76123: PUSH
76124: LD_INT 2
76126: PUSH
76127: LD_INT 1
76129: PUSH
76130: EMPTY
76131: LIST
76132: LIST
76133: PUSH
76134: LD_INT 2
76136: PUSH
76137: LD_INT 2
76139: PUSH
76140: EMPTY
76141: LIST
76142: LIST
76143: PUSH
76144: LD_INT 1
76146: PUSH
76147: LD_INT 2
76149: PUSH
76150: EMPTY
76151: LIST
76152: LIST
76153: PUSH
76154: LD_INT 0
76156: PUSH
76157: LD_INT 2
76159: PUSH
76160: EMPTY
76161: LIST
76162: LIST
76163: PUSH
76164: LD_INT 1
76166: NEG
76167: PUSH
76168: LD_INT 1
76170: PUSH
76171: EMPTY
76172: LIST
76173: LIST
76174: PUSH
76175: LD_INT 2
76177: NEG
76178: PUSH
76179: LD_INT 0
76181: PUSH
76182: EMPTY
76183: LIST
76184: LIST
76185: PUSH
76186: LD_INT 2
76188: NEG
76189: PUSH
76190: LD_INT 1
76192: NEG
76193: PUSH
76194: EMPTY
76195: LIST
76196: LIST
76197: PUSH
76198: LD_INT 2
76200: NEG
76201: PUSH
76202: LD_INT 2
76204: NEG
76205: PUSH
76206: EMPTY
76207: LIST
76208: LIST
76209: PUSH
76210: EMPTY
76211: LIST
76212: LIST
76213: LIST
76214: LIST
76215: LIST
76216: LIST
76217: LIST
76218: LIST
76219: LIST
76220: LIST
76221: LIST
76222: LIST
76223: LIST
76224: LIST
76225: LIST
76226: LIST
76227: LIST
76228: LIST
76229: LIST
76230: ST_TO_ADDR
// Barracks2 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
76231: LD_ADDR_VAR 0 55
76235: PUSH
76236: LD_INT 0
76238: PUSH
76239: LD_INT 0
76241: PUSH
76242: EMPTY
76243: LIST
76244: LIST
76245: PUSH
76246: LD_INT 0
76248: PUSH
76249: LD_INT 1
76251: NEG
76252: PUSH
76253: EMPTY
76254: LIST
76255: LIST
76256: PUSH
76257: LD_INT 1
76259: PUSH
76260: LD_INT 0
76262: PUSH
76263: EMPTY
76264: LIST
76265: LIST
76266: PUSH
76267: LD_INT 1
76269: PUSH
76270: LD_INT 1
76272: PUSH
76273: EMPTY
76274: LIST
76275: LIST
76276: PUSH
76277: LD_INT 0
76279: PUSH
76280: LD_INT 1
76282: PUSH
76283: EMPTY
76284: LIST
76285: LIST
76286: PUSH
76287: LD_INT 1
76289: NEG
76290: PUSH
76291: LD_INT 0
76293: PUSH
76294: EMPTY
76295: LIST
76296: LIST
76297: PUSH
76298: LD_INT 1
76300: NEG
76301: PUSH
76302: LD_INT 1
76304: NEG
76305: PUSH
76306: EMPTY
76307: LIST
76308: LIST
76309: PUSH
76310: LD_INT 1
76312: NEG
76313: PUSH
76314: LD_INT 2
76316: NEG
76317: PUSH
76318: EMPTY
76319: LIST
76320: LIST
76321: PUSH
76322: LD_INT 0
76324: PUSH
76325: LD_INT 2
76327: NEG
76328: PUSH
76329: EMPTY
76330: LIST
76331: LIST
76332: PUSH
76333: LD_INT 1
76335: PUSH
76336: LD_INT 1
76338: NEG
76339: PUSH
76340: EMPTY
76341: LIST
76342: LIST
76343: PUSH
76344: LD_INT 2
76346: PUSH
76347: LD_INT 0
76349: PUSH
76350: EMPTY
76351: LIST
76352: LIST
76353: PUSH
76354: LD_INT 2
76356: PUSH
76357: LD_INT 1
76359: PUSH
76360: EMPTY
76361: LIST
76362: LIST
76363: PUSH
76364: LD_INT 2
76366: PUSH
76367: LD_INT 2
76369: PUSH
76370: EMPTY
76371: LIST
76372: LIST
76373: PUSH
76374: LD_INT 1
76376: PUSH
76377: LD_INT 2
76379: PUSH
76380: EMPTY
76381: LIST
76382: LIST
76383: PUSH
76384: LD_INT 0
76386: PUSH
76387: LD_INT 2
76389: PUSH
76390: EMPTY
76391: LIST
76392: LIST
76393: PUSH
76394: LD_INT 1
76396: NEG
76397: PUSH
76398: LD_INT 1
76400: PUSH
76401: EMPTY
76402: LIST
76403: LIST
76404: PUSH
76405: LD_INT 2
76407: NEG
76408: PUSH
76409: LD_INT 0
76411: PUSH
76412: EMPTY
76413: LIST
76414: LIST
76415: PUSH
76416: LD_INT 2
76418: NEG
76419: PUSH
76420: LD_INT 1
76422: NEG
76423: PUSH
76424: EMPTY
76425: LIST
76426: LIST
76427: PUSH
76428: LD_INT 2
76430: NEG
76431: PUSH
76432: LD_INT 2
76434: NEG
76435: PUSH
76436: EMPTY
76437: LIST
76438: LIST
76439: PUSH
76440: EMPTY
76441: LIST
76442: LIST
76443: LIST
76444: LIST
76445: LIST
76446: LIST
76447: LIST
76448: LIST
76449: LIST
76450: LIST
76451: LIST
76452: LIST
76453: LIST
76454: LIST
76455: LIST
76456: LIST
76457: LIST
76458: LIST
76459: LIST
76460: ST_TO_ADDR
// Barracks3 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
76461: LD_ADDR_VAR 0 56
76465: PUSH
76466: LD_INT 0
76468: PUSH
76469: LD_INT 0
76471: PUSH
76472: EMPTY
76473: LIST
76474: LIST
76475: PUSH
76476: LD_INT 0
76478: PUSH
76479: LD_INT 1
76481: NEG
76482: PUSH
76483: EMPTY
76484: LIST
76485: LIST
76486: PUSH
76487: LD_INT 1
76489: PUSH
76490: LD_INT 0
76492: PUSH
76493: EMPTY
76494: LIST
76495: LIST
76496: PUSH
76497: LD_INT 1
76499: PUSH
76500: LD_INT 1
76502: PUSH
76503: EMPTY
76504: LIST
76505: LIST
76506: PUSH
76507: LD_INT 0
76509: PUSH
76510: LD_INT 1
76512: PUSH
76513: EMPTY
76514: LIST
76515: LIST
76516: PUSH
76517: LD_INT 1
76519: NEG
76520: PUSH
76521: LD_INT 0
76523: PUSH
76524: EMPTY
76525: LIST
76526: LIST
76527: PUSH
76528: LD_INT 1
76530: NEG
76531: PUSH
76532: LD_INT 1
76534: NEG
76535: PUSH
76536: EMPTY
76537: LIST
76538: LIST
76539: PUSH
76540: LD_INT 1
76542: NEG
76543: PUSH
76544: LD_INT 2
76546: NEG
76547: PUSH
76548: EMPTY
76549: LIST
76550: LIST
76551: PUSH
76552: LD_INT 0
76554: PUSH
76555: LD_INT 2
76557: NEG
76558: PUSH
76559: EMPTY
76560: LIST
76561: LIST
76562: PUSH
76563: LD_INT 1
76565: PUSH
76566: LD_INT 1
76568: NEG
76569: PUSH
76570: EMPTY
76571: LIST
76572: LIST
76573: PUSH
76574: LD_INT 2
76576: PUSH
76577: LD_INT 0
76579: PUSH
76580: EMPTY
76581: LIST
76582: LIST
76583: PUSH
76584: LD_INT 2
76586: PUSH
76587: LD_INT 1
76589: PUSH
76590: EMPTY
76591: LIST
76592: LIST
76593: PUSH
76594: LD_INT 2
76596: PUSH
76597: LD_INT 2
76599: PUSH
76600: EMPTY
76601: LIST
76602: LIST
76603: PUSH
76604: LD_INT 1
76606: PUSH
76607: LD_INT 2
76609: PUSH
76610: EMPTY
76611: LIST
76612: LIST
76613: PUSH
76614: LD_INT 0
76616: PUSH
76617: LD_INT 2
76619: PUSH
76620: EMPTY
76621: LIST
76622: LIST
76623: PUSH
76624: LD_INT 1
76626: NEG
76627: PUSH
76628: LD_INT 1
76630: PUSH
76631: EMPTY
76632: LIST
76633: LIST
76634: PUSH
76635: LD_INT 2
76637: NEG
76638: PUSH
76639: LD_INT 0
76641: PUSH
76642: EMPTY
76643: LIST
76644: LIST
76645: PUSH
76646: LD_INT 2
76648: NEG
76649: PUSH
76650: LD_INT 1
76652: NEG
76653: PUSH
76654: EMPTY
76655: LIST
76656: LIST
76657: PUSH
76658: LD_INT 2
76660: NEG
76661: PUSH
76662: LD_INT 2
76664: NEG
76665: PUSH
76666: EMPTY
76667: LIST
76668: LIST
76669: PUSH
76670: EMPTY
76671: LIST
76672: LIST
76673: LIST
76674: LIST
76675: LIST
76676: LIST
76677: LIST
76678: LIST
76679: LIST
76680: LIST
76681: LIST
76682: LIST
76683: LIST
76684: LIST
76685: LIST
76686: LIST
76687: LIST
76688: LIST
76689: LIST
76690: ST_TO_ADDR
// Barracks4 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
76691: LD_ADDR_VAR 0 57
76695: PUSH
76696: LD_INT 0
76698: PUSH
76699: LD_INT 0
76701: PUSH
76702: EMPTY
76703: LIST
76704: LIST
76705: PUSH
76706: LD_INT 0
76708: PUSH
76709: LD_INT 1
76711: NEG
76712: PUSH
76713: EMPTY
76714: LIST
76715: LIST
76716: PUSH
76717: LD_INT 1
76719: PUSH
76720: LD_INT 0
76722: PUSH
76723: EMPTY
76724: LIST
76725: LIST
76726: PUSH
76727: LD_INT 1
76729: PUSH
76730: LD_INT 1
76732: PUSH
76733: EMPTY
76734: LIST
76735: LIST
76736: PUSH
76737: LD_INT 0
76739: PUSH
76740: LD_INT 1
76742: PUSH
76743: EMPTY
76744: LIST
76745: LIST
76746: PUSH
76747: LD_INT 1
76749: NEG
76750: PUSH
76751: LD_INT 0
76753: PUSH
76754: EMPTY
76755: LIST
76756: LIST
76757: PUSH
76758: LD_INT 1
76760: NEG
76761: PUSH
76762: LD_INT 1
76764: NEG
76765: PUSH
76766: EMPTY
76767: LIST
76768: LIST
76769: PUSH
76770: LD_INT 1
76772: NEG
76773: PUSH
76774: LD_INT 2
76776: NEG
76777: PUSH
76778: EMPTY
76779: LIST
76780: LIST
76781: PUSH
76782: LD_INT 0
76784: PUSH
76785: LD_INT 2
76787: NEG
76788: PUSH
76789: EMPTY
76790: LIST
76791: LIST
76792: PUSH
76793: LD_INT 1
76795: PUSH
76796: LD_INT 1
76798: NEG
76799: PUSH
76800: EMPTY
76801: LIST
76802: LIST
76803: PUSH
76804: LD_INT 2
76806: PUSH
76807: LD_INT 0
76809: PUSH
76810: EMPTY
76811: LIST
76812: LIST
76813: PUSH
76814: LD_INT 2
76816: PUSH
76817: LD_INT 1
76819: PUSH
76820: EMPTY
76821: LIST
76822: LIST
76823: PUSH
76824: LD_INT 2
76826: PUSH
76827: LD_INT 2
76829: PUSH
76830: EMPTY
76831: LIST
76832: LIST
76833: PUSH
76834: LD_INT 1
76836: PUSH
76837: LD_INT 2
76839: PUSH
76840: EMPTY
76841: LIST
76842: LIST
76843: PUSH
76844: LD_INT 0
76846: PUSH
76847: LD_INT 2
76849: PUSH
76850: EMPTY
76851: LIST
76852: LIST
76853: PUSH
76854: LD_INT 1
76856: NEG
76857: PUSH
76858: LD_INT 1
76860: PUSH
76861: EMPTY
76862: LIST
76863: LIST
76864: PUSH
76865: LD_INT 2
76867: NEG
76868: PUSH
76869: LD_INT 0
76871: PUSH
76872: EMPTY
76873: LIST
76874: LIST
76875: PUSH
76876: LD_INT 2
76878: NEG
76879: PUSH
76880: LD_INT 1
76882: NEG
76883: PUSH
76884: EMPTY
76885: LIST
76886: LIST
76887: PUSH
76888: LD_INT 2
76890: NEG
76891: PUSH
76892: LD_INT 2
76894: NEG
76895: PUSH
76896: EMPTY
76897: LIST
76898: LIST
76899: PUSH
76900: EMPTY
76901: LIST
76902: LIST
76903: LIST
76904: LIST
76905: LIST
76906: LIST
76907: LIST
76908: LIST
76909: LIST
76910: LIST
76911: LIST
76912: LIST
76913: LIST
76914: LIST
76915: LIST
76916: LIST
76917: LIST
76918: LIST
76919: LIST
76920: ST_TO_ADDR
// Barracks5 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
76921: LD_ADDR_VAR 0 58
76925: PUSH
76926: LD_INT 0
76928: PUSH
76929: LD_INT 0
76931: PUSH
76932: EMPTY
76933: LIST
76934: LIST
76935: PUSH
76936: LD_INT 0
76938: PUSH
76939: LD_INT 1
76941: NEG
76942: PUSH
76943: EMPTY
76944: LIST
76945: LIST
76946: PUSH
76947: LD_INT 1
76949: PUSH
76950: LD_INT 0
76952: PUSH
76953: EMPTY
76954: LIST
76955: LIST
76956: PUSH
76957: LD_INT 1
76959: PUSH
76960: LD_INT 1
76962: PUSH
76963: EMPTY
76964: LIST
76965: LIST
76966: PUSH
76967: LD_INT 0
76969: PUSH
76970: LD_INT 1
76972: PUSH
76973: EMPTY
76974: LIST
76975: LIST
76976: PUSH
76977: LD_INT 1
76979: NEG
76980: PUSH
76981: LD_INT 0
76983: PUSH
76984: EMPTY
76985: LIST
76986: LIST
76987: PUSH
76988: LD_INT 1
76990: NEG
76991: PUSH
76992: LD_INT 1
76994: NEG
76995: PUSH
76996: EMPTY
76997: LIST
76998: LIST
76999: PUSH
77000: LD_INT 1
77002: NEG
77003: PUSH
77004: LD_INT 2
77006: NEG
77007: PUSH
77008: EMPTY
77009: LIST
77010: LIST
77011: PUSH
77012: LD_INT 0
77014: PUSH
77015: LD_INT 2
77017: NEG
77018: PUSH
77019: EMPTY
77020: LIST
77021: LIST
77022: PUSH
77023: LD_INT 1
77025: PUSH
77026: LD_INT 1
77028: NEG
77029: PUSH
77030: EMPTY
77031: LIST
77032: LIST
77033: PUSH
77034: LD_INT 2
77036: PUSH
77037: LD_INT 0
77039: PUSH
77040: EMPTY
77041: LIST
77042: LIST
77043: PUSH
77044: LD_INT 2
77046: PUSH
77047: LD_INT 1
77049: PUSH
77050: EMPTY
77051: LIST
77052: LIST
77053: PUSH
77054: LD_INT 2
77056: PUSH
77057: LD_INT 2
77059: PUSH
77060: EMPTY
77061: LIST
77062: LIST
77063: PUSH
77064: LD_INT 1
77066: PUSH
77067: LD_INT 2
77069: PUSH
77070: EMPTY
77071: LIST
77072: LIST
77073: PUSH
77074: LD_INT 0
77076: PUSH
77077: LD_INT 2
77079: PUSH
77080: EMPTY
77081: LIST
77082: LIST
77083: PUSH
77084: LD_INT 1
77086: NEG
77087: PUSH
77088: LD_INT 1
77090: PUSH
77091: EMPTY
77092: LIST
77093: LIST
77094: PUSH
77095: LD_INT 2
77097: NEG
77098: PUSH
77099: LD_INT 0
77101: PUSH
77102: EMPTY
77103: LIST
77104: LIST
77105: PUSH
77106: LD_INT 2
77108: NEG
77109: PUSH
77110: LD_INT 1
77112: NEG
77113: PUSH
77114: EMPTY
77115: LIST
77116: LIST
77117: PUSH
77118: LD_INT 2
77120: NEG
77121: PUSH
77122: LD_INT 2
77124: NEG
77125: PUSH
77126: EMPTY
77127: LIST
77128: LIST
77129: PUSH
77130: EMPTY
77131: LIST
77132: LIST
77133: LIST
77134: LIST
77135: LIST
77136: LIST
77137: LIST
77138: LIST
77139: LIST
77140: LIST
77141: LIST
77142: LIST
77143: LIST
77144: LIST
77145: LIST
77146: LIST
77147: LIST
77148: LIST
77149: LIST
77150: ST_TO_ADDR
// Bunker0 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] ] ;
77151: LD_ADDR_VAR 0 59
77155: PUSH
77156: LD_INT 0
77158: PUSH
77159: LD_INT 0
77161: PUSH
77162: EMPTY
77163: LIST
77164: LIST
77165: PUSH
77166: LD_INT 0
77168: PUSH
77169: LD_INT 1
77171: NEG
77172: PUSH
77173: EMPTY
77174: LIST
77175: LIST
77176: PUSH
77177: LD_INT 1
77179: PUSH
77180: LD_INT 0
77182: PUSH
77183: EMPTY
77184: LIST
77185: LIST
77186: PUSH
77187: LD_INT 1
77189: PUSH
77190: LD_INT 1
77192: PUSH
77193: EMPTY
77194: LIST
77195: LIST
77196: PUSH
77197: LD_INT 0
77199: PUSH
77200: LD_INT 1
77202: PUSH
77203: EMPTY
77204: LIST
77205: LIST
77206: PUSH
77207: LD_INT 1
77209: NEG
77210: PUSH
77211: LD_INT 0
77213: PUSH
77214: EMPTY
77215: LIST
77216: LIST
77217: PUSH
77218: LD_INT 1
77220: NEG
77221: PUSH
77222: LD_INT 1
77224: NEG
77225: PUSH
77226: EMPTY
77227: LIST
77228: LIST
77229: PUSH
77230: EMPTY
77231: LIST
77232: LIST
77233: LIST
77234: LIST
77235: LIST
77236: LIST
77237: LIST
77238: ST_TO_ADDR
// Bunker1 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] ] ;
77239: LD_ADDR_VAR 0 60
77243: PUSH
77244: LD_INT 0
77246: PUSH
77247: LD_INT 0
77249: PUSH
77250: EMPTY
77251: LIST
77252: LIST
77253: PUSH
77254: LD_INT 0
77256: PUSH
77257: LD_INT 1
77259: NEG
77260: PUSH
77261: EMPTY
77262: LIST
77263: LIST
77264: PUSH
77265: LD_INT 1
77267: PUSH
77268: LD_INT 0
77270: PUSH
77271: EMPTY
77272: LIST
77273: LIST
77274: PUSH
77275: LD_INT 1
77277: PUSH
77278: LD_INT 1
77280: PUSH
77281: EMPTY
77282: LIST
77283: LIST
77284: PUSH
77285: LD_INT 0
77287: PUSH
77288: LD_INT 1
77290: PUSH
77291: EMPTY
77292: LIST
77293: LIST
77294: PUSH
77295: LD_INT 1
77297: NEG
77298: PUSH
77299: LD_INT 0
77301: PUSH
77302: EMPTY
77303: LIST
77304: LIST
77305: PUSH
77306: LD_INT 1
77308: NEG
77309: PUSH
77310: LD_INT 1
77312: NEG
77313: PUSH
77314: EMPTY
77315: LIST
77316: LIST
77317: PUSH
77318: EMPTY
77319: LIST
77320: LIST
77321: LIST
77322: LIST
77323: LIST
77324: LIST
77325: LIST
77326: ST_TO_ADDR
// Bunker2 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] ] ;
77327: LD_ADDR_VAR 0 61
77331: PUSH
77332: LD_INT 0
77334: PUSH
77335: LD_INT 0
77337: PUSH
77338: EMPTY
77339: LIST
77340: LIST
77341: PUSH
77342: LD_INT 0
77344: PUSH
77345: LD_INT 1
77347: NEG
77348: PUSH
77349: EMPTY
77350: LIST
77351: LIST
77352: PUSH
77353: LD_INT 1
77355: PUSH
77356: LD_INT 0
77358: PUSH
77359: EMPTY
77360: LIST
77361: LIST
77362: PUSH
77363: LD_INT 1
77365: PUSH
77366: LD_INT 1
77368: PUSH
77369: EMPTY
77370: LIST
77371: LIST
77372: PUSH
77373: LD_INT 0
77375: PUSH
77376: LD_INT 1
77378: PUSH
77379: EMPTY
77380: LIST
77381: LIST
77382: PUSH
77383: LD_INT 1
77385: NEG
77386: PUSH
77387: LD_INT 0
77389: PUSH
77390: EMPTY
77391: LIST
77392: LIST
77393: PUSH
77394: LD_INT 1
77396: NEG
77397: PUSH
77398: LD_INT 1
77400: NEG
77401: PUSH
77402: EMPTY
77403: LIST
77404: LIST
77405: PUSH
77406: EMPTY
77407: LIST
77408: LIST
77409: LIST
77410: LIST
77411: LIST
77412: LIST
77413: LIST
77414: ST_TO_ADDR
// Bunker3 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] ] ;
77415: LD_ADDR_VAR 0 62
77419: PUSH
77420: LD_INT 0
77422: PUSH
77423: LD_INT 0
77425: PUSH
77426: EMPTY
77427: LIST
77428: LIST
77429: PUSH
77430: LD_INT 0
77432: PUSH
77433: LD_INT 1
77435: NEG
77436: PUSH
77437: EMPTY
77438: LIST
77439: LIST
77440: PUSH
77441: LD_INT 1
77443: PUSH
77444: LD_INT 0
77446: PUSH
77447: EMPTY
77448: LIST
77449: LIST
77450: PUSH
77451: LD_INT 1
77453: PUSH
77454: LD_INT 1
77456: PUSH
77457: EMPTY
77458: LIST
77459: LIST
77460: PUSH
77461: LD_INT 0
77463: PUSH
77464: LD_INT 1
77466: PUSH
77467: EMPTY
77468: LIST
77469: LIST
77470: PUSH
77471: LD_INT 1
77473: NEG
77474: PUSH
77475: LD_INT 0
77477: PUSH
77478: EMPTY
77479: LIST
77480: LIST
77481: PUSH
77482: LD_INT 1
77484: NEG
77485: PUSH
77486: LD_INT 1
77488: NEG
77489: PUSH
77490: EMPTY
77491: LIST
77492: LIST
77493: PUSH
77494: EMPTY
77495: LIST
77496: LIST
77497: LIST
77498: LIST
77499: LIST
77500: LIST
77501: LIST
77502: ST_TO_ADDR
// Bunker4 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] ] ;
77503: LD_ADDR_VAR 0 63
77507: PUSH
77508: LD_INT 0
77510: PUSH
77511: LD_INT 0
77513: PUSH
77514: EMPTY
77515: LIST
77516: LIST
77517: PUSH
77518: LD_INT 0
77520: PUSH
77521: LD_INT 1
77523: NEG
77524: PUSH
77525: EMPTY
77526: LIST
77527: LIST
77528: PUSH
77529: LD_INT 1
77531: PUSH
77532: LD_INT 0
77534: PUSH
77535: EMPTY
77536: LIST
77537: LIST
77538: PUSH
77539: LD_INT 1
77541: PUSH
77542: LD_INT 1
77544: PUSH
77545: EMPTY
77546: LIST
77547: LIST
77548: PUSH
77549: LD_INT 0
77551: PUSH
77552: LD_INT 1
77554: PUSH
77555: EMPTY
77556: LIST
77557: LIST
77558: PUSH
77559: LD_INT 1
77561: NEG
77562: PUSH
77563: LD_INT 0
77565: PUSH
77566: EMPTY
77567: LIST
77568: LIST
77569: PUSH
77570: LD_INT 1
77572: NEG
77573: PUSH
77574: LD_INT 1
77576: NEG
77577: PUSH
77578: EMPTY
77579: LIST
77580: LIST
77581: PUSH
77582: EMPTY
77583: LIST
77584: LIST
77585: LIST
77586: LIST
77587: LIST
77588: LIST
77589: LIST
77590: ST_TO_ADDR
// Bunker5 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] ] ;
77591: LD_ADDR_VAR 0 64
77595: PUSH
77596: LD_INT 0
77598: PUSH
77599: LD_INT 0
77601: PUSH
77602: EMPTY
77603: LIST
77604: LIST
77605: PUSH
77606: LD_INT 0
77608: PUSH
77609: LD_INT 1
77611: NEG
77612: PUSH
77613: EMPTY
77614: LIST
77615: LIST
77616: PUSH
77617: LD_INT 1
77619: PUSH
77620: LD_INT 0
77622: PUSH
77623: EMPTY
77624: LIST
77625: LIST
77626: PUSH
77627: LD_INT 1
77629: PUSH
77630: LD_INT 1
77632: PUSH
77633: EMPTY
77634: LIST
77635: LIST
77636: PUSH
77637: LD_INT 0
77639: PUSH
77640: LD_INT 1
77642: PUSH
77643: EMPTY
77644: LIST
77645: LIST
77646: PUSH
77647: LD_INT 1
77649: NEG
77650: PUSH
77651: LD_INT 0
77653: PUSH
77654: EMPTY
77655: LIST
77656: LIST
77657: PUSH
77658: LD_INT 1
77660: NEG
77661: PUSH
77662: LD_INT 1
77664: NEG
77665: PUSH
77666: EMPTY
77667: LIST
77668: LIST
77669: PUSH
77670: EMPTY
77671: LIST
77672: LIST
77673: LIST
77674: LIST
77675: LIST
77676: LIST
77677: LIST
77678: ST_TO_ADDR
// end ; 1 :
77679: GO 83576
77681: LD_INT 1
77683: DOUBLE
77684: EQUAL
77685: IFTRUE 77689
77687: GO 80312
77689: POP
// begin DepotAm0 = [ [ - 1 , - 3 ] , [ 0 , - 3 ] , [ 1 , - 2 ] ] ;
77690: LD_ADDR_VAR 0 11
77694: PUSH
77695: LD_INT 1
77697: NEG
77698: PUSH
77699: LD_INT 3
77701: NEG
77702: PUSH
77703: EMPTY
77704: LIST
77705: LIST
77706: PUSH
77707: LD_INT 0
77709: PUSH
77710: LD_INT 3
77712: NEG
77713: PUSH
77714: EMPTY
77715: LIST
77716: LIST
77717: PUSH
77718: LD_INT 1
77720: PUSH
77721: LD_INT 2
77723: NEG
77724: PUSH
77725: EMPTY
77726: LIST
77727: LIST
77728: PUSH
77729: EMPTY
77730: LIST
77731: LIST
77732: LIST
77733: ST_TO_ADDR
// DepotAm1 = [ [ 2 , - 1 ] , [ 3 , 0 ] , [ 3 , 1 ] ] ;
77734: LD_ADDR_VAR 0 12
77738: PUSH
77739: LD_INT 2
77741: PUSH
77742: LD_INT 1
77744: NEG
77745: PUSH
77746: EMPTY
77747: LIST
77748: LIST
77749: PUSH
77750: LD_INT 3
77752: PUSH
77753: LD_INT 0
77755: PUSH
77756: EMPTY
77757: LIST
77758: LIST
77759: PUSH
77760: LD_INT 3
77762: PUSH
77763: LD_INT 1
77765: PUSH
77766: EMPTY
77767: LIST
77768: LIST
77769: PUSH
77770: EMPTY
77771: LIST
77772: LIST
77773: LIST
77774: ST_TO_ADDR
// DepotAm2 = [ [ 3 , 2 ] , [ 3 , 3 ] , [ 2 , 3 ] ] ;
77775: LD_ADDR_VAR 0 13
77779: PUSH
77780: LD_INT 3
77782: PUSH
77783: LD_INT 2
77785: PUSH
77786: EMPTY
77787: LIST
77788: LIST
77789: PUSH
77790: LD_INT 3
77792: PUSH
77793: LD_INT 3
77795: PUSH
77796: EMPTY
77797: LIST
77798: LIST
77799: PUSH
77800: LD_INT 2
77802: PUSH
77803: LD_INT 3
77805: PUSH
77806: EMPTY
77807: LIST
77808: LIST
77809: PUSH
77810: EMPTY
77811: LIST
77812: LIST
77813: LIST
77814: ST_TO_ADDR
// DepotAm3 = [ [ 1 , 3 ] , [ 0 , 3 ] , [ - 1 , 2 ] ] ;
77815: LD_ADDR_VAR 0 14
77819: PUSH
77820: LD_INT 1
77822: PUSH
77823: LD_INT 3
77825: PUSH
77826: EMPTY
77827: LIST
77828: LIST
77829: PUSH
77830: LD_INT 0
77832: PUSH
77833: LD_INT 3
77835: PUSH
77836: EMPTY
77837: LIST
77838: LIST
77839: PUSH
77840: LD_INT 1
77842: NEG
77843: PUSH
77844: LD_INT 2
77846: PUSH
77847: EMPTY
77848: LIST
77849: LIST
77850: PUSH
77851: EMPTY
77852: LIST
77853: LIST
77854: LIST
77855: ST_TO_ADDR
// DepotAm4 = [ [ - 2 , 1 ] , [ - 3 , 0 ] , [ - 3 , - 1 ] ] ;
77856: LD_ADDR_VAR 0 15
77860: PUSH
77861: LD_INT 2
77863: NEG
77864: PUSH
77865: LD_INT 1
77867: PUSH
77868: EMPTY
77869: LIST
77870: LIST
77871: PUSH
77872: LD_INT 3
77874: NEG
77875: PUSH
77876: LD_INT 0
77878: PUSH
77879: EMPTY
77880: LIST
77881: LIST
77882: PUSH
77883: LD_INT 3
77885: NEG
77886: PUSH
77887: LD_INT 1
77889: NEG
77890: PUSH
77891: EMPTY
77892: LIST
77893: LIST
77894: PUSH
77895: EMPTY
77896: LIST
77897: LIST
77898: LIST
77899: ST_TO_ADDR
// DepotAm5 = [ [ - 2 , - 3 ] , [ - 3 , - 2 ] , [ - 3 , - 3 ] ] ;
77900: LD_ADDR_VAR 0 16
77904: PUSH
77905: LD_INT 2
77907: NEG
77908: PUSH
77909: LD_INT 3
77911: NEG
77912: PUSH
77913: EMPTY
77914: LIST
77915: LIST
77916: PUSH
77917: LD_INT 3
77919: NEG
77920: PUSH
77921: LD_INT 2
77923: NEG
77924: PUSH
77925: EMPTY
77926: LIST
77927: LIST
77928: PUSH
77929: LD_INT 3
77931: NEG
77932: PUSH
77933: LD_INT 3
77935: NEG
77936: PUSH
77937: EMPTY
77938: LIST
77939: LIST
77940: PUSH
77941: EMPTY
77942: LIST
77943: LIST
77944: LIST
77945: ST_TO_ADDR
// DepotAr0 = [ [ - 1 , - 3 ] , [ 0 , - 3 ] , [ 1 , - 2 ] ] ;
77946: LD_ADDR_VAR 0 17
77950: PUSH
77951: LD_INT 1
77953: NEG
77954: PUSH
77955: LD_INT 3
77957: NEG
77958: PUSH
77959: EMPTY
77960: LIST
77961: LIST
77962: PUSH
77963: LD_INT 0
77965: PUSH
77966: LD_INT 3
77968: NEG
77969: PUSH
77970: EMPTY
77971: LIST
77972: LIST
77973: PUSH
77974: LD_INT 1
77976: PUSH
77977: LD_INT 2
77979: NEG
77980: PUSH
77981: EMPTY
77982: LIST
77983: LIST
77984: PUSH
77985: EMPTY
77986: LIST
77987: LIST
77988: LIST
77989: ST_TO_ADDR
// DepotAr1 = [ [ 2 , - 1 ] , [ 3 , 0 ] , [ 3 , 1 ] ] ;
77990: LD_ADDR_VAR 0 18
77994: PUSH
77995: LD_INT 2
77997: PUSH
77998: LD_INT 1
78000: NEG
78001: PUSH
78002: EMPTY
78003: LIST
78004: LIST
78005: PUSH
78006: LD_INT 3
78008: PUSH
78009: LD_INT 0
78011: PUSH
78012: EMPTY
78013: LIST
78014: LIST
78015: PUSH
78016: LD_INT 3
78018: PUSH
78019: LD_INT 1
78021: PUSH
78022: EMPTY
78023: LIST
78024: LIST
78025: PUSH
78026: EMPTY
78027: LIST
78028: LIST
78029: LIST
78030: ST_TO_ADDR
// DepotAr2 = [ [ 3 , 2 ] , [ 3 , 3 ] , [ 2 , 3 ] ] ;
78031: LD_ADDR_VAR 0 19
78035: PUSH
78036: LD_INT 3
78038: PUSH
78039: LD_INT 2
78041: PUSH
78042: EMPTY
78043: LIST
78044: LIST
78045: PUSH
78046: LD_INT 3
78048: PUSH
78049: LD_INT 3
78051: PUSH
78052: EMPTY
78053: LIST
78054: LIST
78055: PUSH
78056: LD_INT 2
78058: PUSH
78059: LD_INT 3
78061: PUSH
78062: EMPTY
78063: LIST
78064: LIST
78065: PUSH
78066: EMPTY
78067: LIST
78068: LIST
78069: LIST
78070: ST_TO_ADDR
// DepotAr3 = [ [ 1 , 3 ] , [ 0 , 3 ] , [ - 1 , 2 ] ] ;
78071: LD_ADDR_VAR 0 20
78075: PUSH
78076: LD_INT 1
78078: PUSH
78079: LD_INT 3
78081: PUSH
78082: EMPTY
78083: LIST
78084: LIST
78085: PUSH
78086: LD_INT 0
78088: PUSH
78089: LD_INT 3
78091: PUSH
78092: EMPTY
78093: LIST
78094: LIST
78095: PUSH
78096: LD_INT 1
78098: NEG
78099: PUSH
78100: LD_INT 2
78102: PUSH
78103: EMPTY
78104: LIST
78105: LIST
78106: PUSH
78107: EMPTY
78108: LIST
78109: LIST
78110: LIST
78111: ST_TO_ADDR
// DepotAr4 = [ [ - 2 , 1 ] , [ - 3 , 0 ] , [ - 3 , - 1 ] ] ;
78112: LD_ADDR_VAR 0 21
78116: PUSH
78117: LD_INT 2
78119: NEG
78120: PUSH
78121: LD_INT 1
78123: PUSH
78124: EMPTY
78125: LIST
78126: LIST
78127: PUSH
78128: LD_INT 3
78130: NEG
78131: PUSH
78132: LD_INT 0
78134: PUSH
78135: EMPTY
78136: LIST
78137: LIST
78138: PUSH
78139: LD_INT 3
78141: NEG
78142: PUSH
78143: LD_INT 1
78145: NEG
78146: PUSH
78147: EMPTY
78148: LIST
78149: LIST
78150: PUSH
78151: EMPTY
78152: LIST
78153: LIST
78154: LIST
78155: ST_TO_ADDR
// DepotAr5 = [ [ - 2 , - 3 ] , [ - 3 , - 2 ] , [ - 3 , - 3 ] ] ;
78156: LD_ADDR_VAR 0 22
78160: PUSH
78161: LD_INT 2
78163: NEG
78164: PUSH
78165: LD_INT 3
78167: NEG
78168: PUSH
78169: EMPTY
78170: LIST
78171: LIST
78172: PUSH
78173: LD_INT 3
78175: NEG
78176: PUSH
78177: LD_INT 2
78179: NEG
78180: PUSH
78181: EMPTY
78182: LIST
78183: LIST
78184: PUSH
78185: LD_INT 3
78187: NEG
78188: PUSH
78189: LD_INT 3
78191: NEG
78192: PUSH
78193: EMPTY
78194: LIST
78195: LIST
78196: PUSH
78197: EMPTY
78198: LIST
78199: LIST
78200: LIST
78201: ST_TO_ADDR
// DepotRu0 = [ [ 0 , - 3 ] , [ - 1 , - 4 ] , [ 1 , - 3 ] ] ;
78202: LD_ADDR_VAR 0 23
78206: PUSH
78207: LD_INT 0
78209: PUSH
78210: LD_INT 3
78212: NEG
78213: PUSH
78214: EMPTY
78215: LIST
78216: LIST
78217: PUSH
78218: LD_INT 1
78220: NEG
78221: PUSH
78222: LD_INT 4
78224: NEG
78225: PUSH
78226: EMPTY
78227: LIST
78228: LIST
78229: PUSH
78230: LD_INT 1
78232: PUSH
78233: LD_INT 3
78235: NEG
78236: PUSH
78237: EMPTY
78238: LIST
78239: LIST
78240: PUSH
78241: EMPTY
78242: LIST
78243: LIST
78244: LIST
78245: ST_TO_ADDR
// DepotRu1 = [ [ 3 , 0 ] , [ 3 , - 1 ] , [ 4 , 1 ] ] ;
78246: LD_ADDR_VAR 0 24
78250: PUSH
78251: LD_INT 3
78253: PUSH
78254: LD_INT 0
78256: PUSH
78257: EMPTY
78258: LIST
78259: LIST
78260: PUSH
78261: LD_INT 3
78263: PUSH
78264: LD_INT 1
78266: NEG
78267: PUSH
78268: EMPTY
78269: LIST
78270: LIST
78271: PUSH
78272: LD_INT 4
78274: PUSH
78275: LD_INT 1
78277: PUSH
78278: EMPTY
78279: LIST
78280: LIST
78281: PUSH
78282: EMPTY
78283: LIST
78284: LIST
78285: LIST
78286: ST_TO_ADDR
// DepotRu2 = [ [ 3 , 3 ] , [ 4 , 3 ] , [ 3 , 4 ] ] ;
78287: LD_ADDR_VAR 0 25
78291: PUSH
78292: LD_INT 3
78294: PUSH
78295: LD_INT 3
78297: PUSH
78298: EMPTY
78299: LIST
78300: LIST
78301: PUSH
78302: LD_INT 4
78304: PUSH
78305: LD_INT 3
78307: PUSH
78308: EMPTY
78309: LIST
78310: LIST
78311: PUSH
78312: LD_INT 3
78314: PUSH
78315: LD_INT 4
78317: PUSH
78318: EMPTY
78319: LIST
78320: LIST
78321: PUSH
78322: EMPTY
78323: LIST
78324: LIST
78325: LIST
78326: ST_TO_ADDR
// DepotRu3 = [ [ 0 , 3 ] , [ 1 , 4 ] , [ - 1 , 3 ] ] ;
78327: LD_ADDR_VAR 0 26
78331: PUSH
78332: LD_INT 0
78334: PUSH
78335: LD_INT 3
78337: PUSH
78338: EMPTY
78339: LIST
78340: LIST
78341: PUSH
78342: LD_INT 1
78344: PUSH
78345: LD_INT 4
78347: PUSH
78348: EMPTY
78349: LIST
78350: LIST
78351: PUSH
78352: LD_INT 1
78354: NEG
78355: PUSH
78356: LD_INT 3
78358: PUSH
78359: EMPTY
78360: LIST
78361: LIST
78362: PUSH
78363: EMPTY
78364: LIST
78365: LIST
78366: LIST
78367: ST_TO_ADDR
// DepotRu4 = [ [ - 3 , 0 ] , [ - 3 , 1 ] , [ - 4 , - 1 ] ] ;
78368: LD_ADDR_VAR 0 27
78372: PUSH
78373: LD_INT 3
78375: NEG
78376: PUSH
78377: LD_INT 0
78379: PUSH
78380: EMPTY
78381: LIST
78382: LIST
78383: PUSH
78384: LD_INT 3
78386: NEG
78387: PUSH
78388: LD_INT 1
78390: PUSH
78391: EMPTY
78392: LIST
78393: LIST
78394: PUSH
78395: LD_INT 4
78397: NEG
78398: PUSH
78399: LD_INT 1
78401: NEG
78402: PUSH
78403: EMPTY
78404: LIST
78405: LIST
78406: PUSH
78407: EMPTY
78408: LIST
78409: LIST
78410: LIST
78411: ST_TO_ADDR
// DepotRu5 = [ [ - 3 , - 3 ] , [ - 3 , - 4 ] , [ - 4 , - 3 ] ] ;
78412: LD_ADDR_VAR 0 28
78416: PUSH
78417: LD_INT 3
78419: NEG
78420: PUSH
78421: LD_INT 3
78423: NEG
78424: PUSH
78425: EMPTY
78426: LIST
78427: LIST
78428: PUSH
78429: LD_INT 3
78431: NEG
78432: PUSH
78433: LD_INT 4
78435: NEG
78436: PUSH
78437: EMPTY
78438: LIST
78439: LIST
78440: PUSH
78441: LD_INT 4
78443: NEG
78444: PUSH
78445: LD_INT 3
78447: NEG
78448: PUSH
78449: EMPTY
78450: LIST
78451: LIST
78452: PUSH
78453: EMPTY
78454: LIST
78455: LIST
78456: LIST
78457: ST_TO_ADDR
// Factory0 = [ [ - 1 , - 3 ] , [ 0 , - 3 ] , [ 1 , - 2 ] , [ - 1 , - 4 ] , [ 0 , - 4 ] , [ 1 , - 3 ] , [ - 1 , - 5 ] , [ 0 , - 5 ] , [ 1 , - 4 ] , [ - 1 , - 6 ] , [ 0 , - 6 ] , [ 1 , - 5 ] ] ;
78458: LD_ADDR_VAR 0 29
78462: PUSH
78463: LD_INT 1
78465: NEG
78466: PUSH
78467: LD_INT 3
78469: NEG
78470: PUSH
78471: EMPTY
78472: LIST
78473: LIST
78474: PUSH
78475: LD_INT 0
78477: PUSH
78478: LD_INT 3
78480: NEG
78481: PUSH
78482: EMPTY
78483: LIST
78484: LIST
78485: PUSH
78486: LD_INT 1
78488: PUSH
78489: LD_INT 2
78491: NEG
78492: PUSH
78493: EMPTY
78494: LIST
78495: LIST
78496: PUSH
78497: LD_INT 1
78499: NEG
78500: PUSH
78501: LD_INT 4
78503: NEG
78504: PUSH
78505: EMPTY
78506: LIST
78507: LIST
78508: PUSH
78509: LD_INT 0
78511: PUSH
78512: LD_INT 4
78514: NEG
78515: PUSH
78516: EMPTY
78517: LIST
78518: LIST
78519: PUSH
78520: LD_INT 1
78522: PUSH
78523: LD_INT 3
78525: NEG
78526: PUSH
78527: EMPTY
78528: LIST
78529: LIST
78530: PUSH
78531: LD_INT 1
78533: NEG
78534: PUSH
78535: LD_INT 5
78537: NEG
78538: PUSH
78539: EMPTY
78540: LIST
78541: LIST
78542: PUSH
78543: LD_INT 0
78545: PUSH
78546: LD_INT 5
78548: NEG
78549: PUSH
78550: EMPTY
78551: LIST
78552: LIST
78553: PUSH
78554: LD_INT 1
78556: PUSH
78557: LD_INT 4
78559: NEG
78560: PUSH
78561: EMPTY
78562: LIST
78563: LIST
78564: PUSH
78565: LD_INT 1
78567: NEG
78568: PUSH
78569: LD_INT 6
78571: NEG
78572: PUSH
78573: EMPTY
78574: LIST
78575: LIST
78576: PUSH
78577: LD_INT 0
78579: PUSH
78580: LD_INT 6
78582: NEG
78583: PUSH
78584: EMPTY
78585: LIST
78586: LIST
78587: PUSH
78588: LD_INT 1
78590: PUSH
78591: LD_INT 5
78593: NEG
78594: PUSH
78595: EMPTY
78596: LIST
78597: LIST
78598: PUSH
78599: EMPTY
78600: LIST
78601: LIST
78602: LIST
78603: LIST
78604: LIST
78605: LIST
78606: LIST
78607: LIST
78608: LIST
78609: LIST
78610: LIST
78611: LIST
78612: ST_TO_ADDR
// Factory1 = [ [ 2 , - 1 ] , [ 3 , 0 ] , [ 3 , 1 ] , [ 3 , - 1 ] , [ 4 , 0 ] , [ 4 , 1 ] , [ 4 , - 1 ] , [ 5 , 0 ] , [ 5 , 1 ] , [ 5 , - 1 ] , [ 6 , 0 ] , [ 6 , 1 ] ] ;
78613: LD_ADDR_VAR 0 30
78617: PUSH
78618: LD_INT 2
78620: PUSH
78621: LD_INT 1
78623: NEG
78624: PUSH
78625: EMPTY
78626: LIST
78627: LIST
78628: PUSH
78629: LD_INT 3
78631: PUSH
78632: LD_INT 0
78634: PUSH
78635: EMPTY
78636: LIST
78637: LIST
78638: PUSH
78639: LD_INT 3
78641: PUSH
78642: LD_INT 1
78644: PUSH
78645: EMPTY
78646: LIST
78647: LIST
78648: PUSH
78649: LD_INT 3
78651: PUSH
78652: LD_INT 1
78654: NEG
78655: PUSH
78656: EMPTY
78657: LIST
78658: LIST
78659: PUSH
78660: LD_INT 4
78662: PUSH
78663: LD_INT 0
78665: PUSH
78666: EMPTY
78667: LIST
78668: LIST
78669: PUSH
78670: LD_INT 4
78672: PUSH
78673: LD_INT 1
78675: PUSH
78676: EMPTY
78677: LIST
78678: LIST
78679: PUSH
78680: LD_INT 4
78682: PUSH
78683: LD_INT 1
78685: NEG
78686: PUSH
78687: EMPTY
78688: LIST
78689: LIST
78690: PUSH
78691: LD_INT 5
78693: PUSH
78694: LD_INT 0
78696: PUSH
78697: EMPTY
78698: LIST
78699: LIST
78700: PUSH
78701: LD_INT 5
78703: PUSH
78704: LD_INT 1
78706: PUSH
78707: EMPTY
78708: LIST
78709: LIST
78710: PUSH
78711: LD_INT 5
78713: PUSH
78714: LD_INT 1
78716: NEG
78717: PUSH
78718: EMPTY
78719: LIST
78720: LIST
78721: PUSH
78722: LD_INT 6
78724: PUSH
78725: LD_INT 0
78727: PUSH
78728: EMPTY
78729: LIST
78730: LIST
78731: PUSH
78732: LD_INT 6
78734: PUSH
78735: LD_INT 1
78737: PUSH
78738: EMPTY
78739: LIST
78740: LIST
78741: PUSH
78742: EMPTY
78743: LIST
78744: LIST
78745: LIST
78746: LIST
78747: LIST
78748: LIST
78749: LIST
78750: LIST
78751: LIST
78752: LIST
78753: LIST
78754: LIST
78755: ST_TO_ADDR
// Factory2 = [ [ 3 , 2 ] , [ 3 , 3 ] , [ 2 , 3 ] , [ 4 , 3 ] , [ 4 , 4 ] , [ 3 , 4 ] , [ 5 , 4 ] , [ 5 , 5 ] , [ 4 , 5 ] , [ 6 , 5 ] , [ 6 , 6 ] , [ 5 , 6 ] ] ;
78756: LD_ADDR_VAR 0 31
78760: PUSH
78761: LD_INT 3
78763: PUSH
78764: LD_INT 2
78766: PUSH
78767: EMPTY
78768: LIST
78769: LIST
78770: PUSH
78771: LD_INT 3
78773: PUSH
78774: LD_INT 3
78776: PUSH
78777: EMPTY
78778: LIST
78779: LIST
78780: PUSH
78781: LD_INT 2
78783: PUSH
78784: LD_INT 3
78786: PUSH
78787: EMPTY
78788: LIST
78789: LIST
78790: PUSH
78791: LD_INT 4
78793: PUSH
78794: LD_INT 3
78796: PUSH
78797: EMPTY
78798: LIST
78799: LIST
78800: PUSH
78801: LD_INT 4
78803: PUSH
78804: LD_INT 4
78806: PUSH
78807: EMPTY
78808: LIST
78809: LIST
78810: PUSH
78811: LD_INT 3
78813: PUSH
78814: LD_INT 4
78816: PUSH
78817: EMPTY
78818: LIST
78819: LIST
78820: PUSH
78821: LD_INT 5
78823: PUSH
78824: LD_INT 4
78826: PUSH
78827: EMPTY
78828: LIST
78829: LIST
78830: PUSH
78831: LD_INT 5
78833: PUSH
78834: LD_INT 5
78836: PUSH
78837: EMPTY
78838: LIST
78839: LIST
78840: PUSH
78841: LD_INT 4
78843: PUSH
78844: LD_INT 5
78846: PUSH
78847: EMPTY
78848: LIST
78849: LIST
78850: PUSH
78851: LD_INT 6
78853: PUSH
78854: LD_INT 5
78856: PUSH
78857: EMPTY
78858: LIST
78859: LIST
78860: PUSH
78861: LD_INT 6
78863: PUSH
78864: LD_INT 6
78866: PUSH
78867: EMPTY
78868: LIST
78869: LIST
78870: PUSH
78871: LD_INT 5
78873: PUSH
78874: LD_INT 6
78876: PUSH
78877: EMPTY
78878: LIST
78879: LIST
78880: PUSH
78881: EMPTY
78882: LIST
78883: LIST
78884: LIST
78885: LIST
78886: LIST
78887: LIST
78888: LIST
78889: LIST
78890: LIST
78891: LIST
78892: LIST
78893: LIST
78894: ST_TO_ADDR
// Factory3 = [ [ 1 , 3 ] , [ 0 , 3 ] , [ - 1 , 2 ] , [ 1 , 4 ] , [ 0 , 4 ] , [ - 1 , 3 ] , [ 1 , 5 ] , [ 0 , 5 ] , [ - 1 , 4 ] , [ 1 , 6 ] , [ 0 , 6 ] , [ - 1 , 5 ] ] ;
78895: LD_ADDR_VAR 0 32
78899: PUSH
78900: LD_INT 1
78902: PUSH
78903: LD_INT 3
78905: PUSH
78906: EMPTY
78907: LIST
78908: LIST
78909: PUSH
78910: LD_INT 0
78912: PUSH
78913: LD_INT 3
78915: PUSH
78916: EMPTY
78917: LIST
78918: LIST
78919: PUSH
78920: LD_INT 1
78922: NEG
78923: PUSH
78924: LD_INT 2
78926: PUSH
78927: EMPTY
78928: LIST
78929: LIST
78930: PUSH
78931: LD_INT 1
78933: PUSH
78934: LD_INT 4
78936: PUSH
78937: EMPTY
78938: LIST
78939: LIST
78940: PUSH
78941: LD_INT 0
78943: PUSH
78944: LD_INT 4
78946: PUSH
78947: EMPTY
78948: LIST
78949: LIST
78950: PUSH
78951: LD_INT 1
78953: NEG
78954: PUSH
78955: LD_INT 3
78957: PUSH
78958: EMPTY
78959: LIST
78960: LIST
78961: PUSH
78962: LD_INT 1
78964: PUSH
78965: LD_INT 5
78967: PUSH
78968: EMPTY
78969: LIST
78970: LIST
78971: PUSH
78972: LD_INT 0
78974: PUSH
78975: LD_INT 5
78977: PUSH
78978: EMPTY
78979: LIST
78980: LIST
78981: PUSH
78982: LD_INT 1
78984: NEG
78985: PUSH
78986: LD_INT 4
78988: PUSH
78989: EMPTY
78990: LIST
78991: LIST
78992: PUSH
78993: LD_INT 1
78995: PUSH
78996: LD_INT 6
78998: PUSH
78999: EMPTY
79000: LIST
79001: LIST
79002: PUSH
79003: LD_INT 0
79005: PUSH
79006: LD_INT 6
79008: PUSH
79009: EMPTY
79010: LIST
79011: LIST
79012: PUSH
79013: LD_INT 1
79015: NEG
79016: PUSH
79017: LD_INT 5
79019: PUSH
79020: EMPTY
79021: LIST
79022: LIST
79023: PUSH
79024: EMPTY
79025: LIST
79026: LIST
79027: LIST
79028: LIST
79029: LIST
79030: LIST
79031: LIST
79032: LIST
79033: LIST
79034: LIST
79035: LIST
79036: LIST
79037: ST_TO_ADDR
// Factory4 = [ [ - 2 , 1 ] , [ - 3 , 0 ] , [ - 3 , - 1 ] , [ - 3 , 1 ] , [ - 4 , 0 ] , [ - 4 , - 1 ] , [ - 4 , 1 ] , [ - 5 , 0 ] , [ - 5 , - 1 ] , [ - 5 , 1 ] , [ - 6 , 0 ] , [ - 6 , - 1 ] ] ;
79038: LD_ADDR_VAR 0 33
79042: PUSH
79043: LD_INT 2
79045: NEG
79046: PUSH
79047: LD_INT 1
79049: PUSH
79050: EMPTY
79051: LIST
79052: LIST
79053: PUSH
79054: LD_INT 3
79056: NEG
79057: PUSH
79058: LD_INT 0
79060: PUSH
79061: EMPTY
79062: LIST
79063: LIST
79064: PUSH
79065: LD_INT 3
79067: NEG
79068: PUSH
79069: LD_INT 1
79071: NEG
79072: PUSH
79073: EMPTY
79074: LIST
79075: LIST
79076: PUSH
79077: LD_INT 3
79079: NEG
79080: PUSH
79081: LD_INT 1
79083: PUSH
79084: EMPTY
79085: LIST
79086: LIST
79087: PUSH
79088: LD_INT 4
79090: NEG
79091: PUSH
79092: LD_INT 0
79094: PUSH
79095: EMPTY
79096: LIST
79097: LIST
79098: PUSH
79099: LD_INT 4
79101: NEG
79102: PUSH
79103: LD_INT 1
79105: NEG
79106: PUSH
79107: EMPTY
79108: LIST
79109: LIST
79110: PUSH
79111: LD_INT 4
79113: NEG
79114: PUSH
79115: LD_INT 1
79117: PUSH
79118: EMPTY
79119: LIST
79120: LIST
79121: PUSH
79122: LD_INT 5
79124: NEG
79125: PUSH
79126: LD_INT 0
79128: PUSH
79129: EMPTY
79130: LIST
79131: LIST
79132: PUSH
79133: LD_INT 5
79135: NEG
79136: PUSH
79137: LD_INT 1
79139: NEG
79140: PUSH
79141: EMPTY
79142: LIST
79143: LIST
79144: PUSH
79145: LD_INT 5
79147: NEG
79148: PUSH
79149: LD_INT 1
79151: PUSH
79152: EMPTY
79153: LIST
79154: LIST
79155: PUSH
79156: LD_INT 6
79158: NEG
79159: PUSH
79160: LD_INT 0
79162: PUSH
79163: EMPTY
79164: LIST
79165: LIST
79166: PUSH
79167: LD_INT 6
79169: NEG
79170: PUSH
79171: LD_INT 1
79173: NEG
79174: PUSH
79175: EMPTY
79176: LIST
79177: LIST
79178: PUSH
79179: EMPTY
79180: LIST
79181: LIST
79182: LIST
79183: LIST
79184: LIST
79185: LIST
79186: LIST
79187: LIST
79188: LIST
79189: LIST
79190: LIST
79191: LIST
79192: ST_TO_ADDR
// Factory5 = [ [ - 2 , - 3 ] , [ - 3 , - 2 ] , [ - 3 , - 3 ] , [ - 3 , - 4 ] , [ - 4 , - 3 ] , [ - 4 , - 4 ] , [ - 4 , - 5 ] , [ - 5 , - 4 ] , [ - 5 , - 5 ] , [ - 5 , - 6 ] , [ - 6 , - 5 ] , [ - 6 , - 6 ] ] ;
79193: LD_ADDR_VAR 0 34
79197: PUSH
79198: LD_INT 2
79200: NEG
79201: PUSH
79202: LD_INT 3
79204: NEG
79205: PUSH
79206: EMPTY
79207: LIST
79208: LIST
79209: PUSH
79210: LD_INT 3
79212: NEG
79213: PUSH
79214: LD_INT 2
79216: NEG
79217: PUSH
79218: EMPTY
79219: LIST
79220: LIST
79221: PUSH
79222: LD_INT 3
79224: NEG
79225: PUSH
79226: LD_INT 3
79228: NEG
79229: PUSH
79230: EMPTY
79231: LIST
79232: LIST
79233: PUSH
79234: LD_INT 3
79236: NEG
79237: PUSH
79238: LD_INT 4
79240: NEG
79241: PUSH
79242: EMPTY
79243: LIST
79244: LIST
79245: PUSH
79246: LD_INT 4
79248: NEG
79249: PUSH
79250: LD_INT 3
79252: NEG
79253: PUSH
79254: EMPTY
79255: LIST
79256: LIST
79257: PUSH
79258: LD_INT 4
79260: NEG
79261: PUSH
79262: LD_INT 4
79264: NEG
79265: PUSH
79266: EMPTY
79267: LIST
79268: LIST
79269: PUSH
79270: LD_INT 4
79272: NEG
79273: PUSH
79274: LD_INT 5
79276: NEG
79277: PUSH
79278: EMPTY
79279: LIST
79280: LIST
79281: PUSH
79282: LD_INT 5
79284: NEG
79285: PUSH
79286: LD_INT 4
79288: NEG
79289: PUSH
79290: EMPTY
79291: LIST
79292: LIST
79293: PUSH
79294: LD_INT 5
79296: NEG
79297: PUSH
79298: LD_INT 5
79300: NEG
79301: PUSH
79302: EMPTY
79303: LIST
79304: LIST
79305: PUSH
79306: LD_INT 5
79308: NEG
79309: PUSH
79310: LD_INT 6
79312: NEG
79313: PUSH
79314: EMPTY
79315: LIST
79316: LIST
79317: PUSH
79318: LD_INT 6
79320: NEG
79321: PUSH
79322: LD_INT 5
79324: NEG
79325: PUSH
79326: EMPTY
79327: LIST
79328: LIST
79329: PUSH
79330: LD_INT 6
79332: NEG
79333: PUSH
79334: LD_INT 6
79336: NEG
79337: PUSH
79338: EMPTY
79339: LIST
79340: LIST
79341: PUSH
79342: EMPTY
79343: LIST
79344: LIST
79345: LIST
79346: LIST
79347: LIST
79348: LIST
79349: LIST
79350: LIST
79351: LIST
79352: LIST
79353: LIST
79354: LIST
79355: ST_TO_ADDR
// Lab0 = [ [ 0 , - 2 ] , [ - 1 , - 3 ] , [ 1 , - 2 ] ] ;
79356: LD_ADDR_VAR 0 41
79360: PUSH
79361: LD_INT 0
79363: PUSH
79364: LD_INT 2
79366: NEG
79367: PUSH
79368: EMPTY
79369: LIST
79370: LIST
79371: PUSH
79372: LD_INT 1
79374: NEG
79375: PUSH
79376: LD_INT 3
79378: NEG
79379: PUSH
79380: EMPTY
79381: LIST
79382: LIST
79383: PUSH
79384: LD_INT 1
79386: PUSH
79387: LD_INT 2
79389: NEG
79390: PUSH
79391: EMPTY
79392: LIST
79393: LIST
79394: PUSH
79395: EMPTY
79396: LIST
79397: LIST
79398: LIST
79399: ST_TO_ADDR
// Lab1 = [ [ 2 , 0 ] , [ 2 , - 1 ] , [ 3 , 1 ] ] ;
79400: LD_ADDR_VAR 0 42
79404: PUSH
79405: LD_INT 2
79407: PUSH
79408: LD_INT 0
79410: PUSH
79411: EMPTY
79412: LIST
79413: LIST
79414: PUSH
79415: LD_INT 2
79417: PUSH
79418: LD_INT 1
79420: NEG
79421: PUSH
79422: EMPTY
79423: LIST
79424: LIST
79425: PUSH
79426: LD_INT 3
79428: PUSH
79429: LD_INT 1
79431: PUSH
79432: EMPTY
79433: LIST
79434: LIST
79435: PUSH
79436: EMPTY
79437: LIST
79438: LIST
79439: LIST
79440: ST_TO_ADDR
// Lab2 = [ [ 2 , 2 ] , [ 3 , 2 ] , [ 2 , 3 ] ] ;
79441: LD_ADDR_VAR 0 43
79445: PUSH
79446: LD_INT 2
79448: PUSH
79449: LD_INT 2
79451: PUSH
79452: EMPTY
79453: LIST
79454: LIST
79455: PUSH
79456: LD_INT 3
79458: PUSH
79459: LD_INT 2
79461: PUSH
79462: EMPTY
79463: LIST
79464: LIST
79465: PUSH
79466: LD_INT 2
79468: PUSH
79469: LD_INT 3
79471: PUSH
79472: EMPTY
79473: LIST
79474: LIST
79475: PUSH
79476: EMPTY
79477: LIST
79478: LIST
79479: LIST
79480: ST_TO_ADDR
// Lab3 = [ [ 0 , 2 ] , [ 1 , 3 ] , [ - 1 , 2 ] ] ;
79481: LD_ADDR_VAR 0 44
79485: PUSH
79486: LD_INT 0
79488: PUSH
79489: LD_INT 2
79491: PUSH
79492: EMPTY
79493: LIST
79494: LIST
79495: PUSH
79496: LD_INT 1
79498: PUSH
79499: LD_INT 3
79501: PUSH
79502: EMPTY
79503: LIST
79504: LIST
79505: PUSH
79506: LD_INT 1
79508: NEG
79509: PUSH
79510: LD_INT 2
79512: PUSH
79513: EMPTY
79514: LIST
79515: LIST
79516: PUSH
79517: EMPTY
79518: LIST
79519: LIST
79520: LIST
79521: ST_TO_ADDR
// Lab4 = [ [ - 2 , 0 ] , [ - 2 , 1 ] , [ - 3 , - 1 ] ] ;
79522: LD_ADDR_VAR 0 45
79526: PUSH
79527: LD_INT 2
79529: NEG
79530: PUSH
79531: LD_INT 0
79533: PUSH
79534: EMPTY
79535: LIST
79536: LIST
79537: PUSH
79538: LD_INT 2
79540: NEG
79541: PUSH
79542: LD_INT 1
79544: PUSH
79545: EMPTY
79546: LIST
79547: LIST
79548: PUSH
79549: LD_INT 3
79551: NEG
79552: PUSH
79553: LD_INT 1
79555: NEG
79556: PUSH
79557: EMPTY
79558: LIST
79559: LIST
79560: PUSH
79561: EMPTY
79562: LIST
79563: LIST
79564: LIST
79565: ST_TO_ADDR
// Lab5 = [ [ - 2 , - 2 ] , [ - 2 , - 3 ] , [ - 3 , - 2 ] ] ;
79566: LD_ADDR_VAR 0 46
79570: PUSH
79571: LD_INT 2
79573: NEG
79574: PUSH
79575: LD_INT 2
79577: NEG
79578: PUSH
79579: EMPTY
79580: LIST
79581: LIST
79582: PUSH
79583: LD_INT 2
79585: NEG
79586: PUSH
79587: LD_INT 3
79589: NEG
79590: PUSH
79591: EMPTY
79592: LIST
79593: LIST
79594: PUSH
79595: LD_INT 3
79597: NEG
79598: PUSH
79599: LD_INT 2
79601: NEG
79602: PUSH
79603: EMPTY
79604: LIST
79605: LIST
79606: PUSH
79607: EMPTY
79608: LIST
79609: LIST
79610: LIST
79611: ST_TO_ADDR
// ControlTower0 = [ [ - 2 , - 3 ] , [ - 1 , - 3 ] ] ;
79612: LD_ADDR_VAR 0 47
79616: PUSH
79617: LD_INT 2
79619: NEG
79620: PUSH
79621: LD_INT 3
79623: NEG
79624: PUSH
79625: EMPTY
79626: LIST
79627: LIST
79628: PUSH
79629: LD_INT 1
79631: NEG
79632: PUSH
79633: LD_INT 3
79635: NEG
79636: PUSH
79637: EMPTY
79638: LIST
79639: LIST
79640: PUSH
79641: EMPTY
79642: LIST
79643: LIST
79644: ST_TO_ADDR
// ControlTower1 = [ [ 1 , - 2 ] , [ 2 , - 1 ] ] ;
79645: LD_ADDR_VAR 0 48
79649: PUSH
79650: LD_INT 1
79652: PUSH
79653: LD_INT 2
79655: NEG
79656: PUSH
79657: EMPTY
79658: LIST
79659: LIST
79660: PUSH
79661: LD_INT 2
79663: PUSH
79664: LD_INT 1
79666: NEG
79667: PUSH
79668: EMPTY
79669: LIST
79670: LIST
79671: PUSH
79672: EMPTY
79673: LIST
79674: LIST
79675: ST_TO_ADDR
// ControlTower2 = [ [ 3 , 1 ] , [ 3 , 2 ] ] ;
79676: LD_ADDR_VAR 0 49
79680: PUSH
79681: LD_INT 3
79683: PUSH
79684: LD_INT 1
79686: PUSH
79687: EMPTY
79688: LIST
79689: LIST
79690: PUSH
79691: LD_INT 3
79693: PUSH
79694: LD_INT 2
79696: PUSH
79697: EMPTY
79698: LIST
79699: LIST
79700: PUSH
79701: EMPTY
79702: LIST
79703: LIST
79704: ST_TO_ADDR
// ControlTower3 = [ [ 2 , 3 ] , [ 1 , 3 ] ] ;
79705: LD_ADDR_VAR 0 50
79709: PUSH
79710: LD_INT 2
79712: PUSH
79713: LD_INT 3
79715: PUSH
79716: EMPTY
79717: LIST
79718: LIST
79719: PUSH
79720: LD_INT 1
79722: PUSH
79723: LD_INT 3
79725: PUSH
79726: EMPTY
79727: LIST
79728: LIST
79729: PUSH
79730: EMPTY
79731: LIST
79732: LIST
79733: ST_TO_ADDR
// ControlTower4 = [ [ - 1 , 2 ] , [ - 2 , 1 ] ] ;
79734: LD_ADDR_VAR 0 51
79738: PUSH
79739: LD_INT 1
79741: NEG
79742: PUSH
79743: LD_INT 2
79745: PUSH
79746: EMPTY
79747: LIST
79748: LIST
79749: PUSH
79750: LD_INT 2
79752: NEG
79753: PUSH
79754: LD_INT 1
79756: PUSH
79757: EMPTY
79758: LIST
79759: LIST
79760: PUSH
79761: EMPTY
79762: LIST
79763: LIST
79764: ST_TO_ADDR
// ControlTower5 = [ [ - 3 , - 1 ] , [ - 3 , - 2 ] ] ;
79765: LD_ADDR_VAR 0 52
79769: PUSH
79770: LD_INT 3
79772: NEG
79773: PUSH
79774: LD_INT 1
79776: NEG
79777: PUSH
79778: EMPTY
79779: LIST
79780: LIST
79781: PUSH
79782: LD_INT 3
79784: NEG
79785: PUSH
79786: LD_INT 2
79788: NEG
79789: PUSH
79790: EMPTY
79791: LIST
79792: LIST
79793: PUSH
79794: EMPTY
79795: LIST
79796: LIST
79797: ST_TO_ADDR
// Barracks0 = [ [ - 1 , - 3 ] , [ 0 , - 3 ] , [ 1 , - 2 ] ] ;
79798: LD_ADDR_VAR 0 53
79802: PUSH
79803: LD_INT 1
79805: NEG
79806: PUSH
79807: LD_INT 3
79809: NEG
79810: PUSH
79811: EMPTY
79812: LIST
79813: LIST
79814: PUSH
79815: LD_INT 0
79817: PUSH
79818: LD_INT 3
79820: NEG
79821: PUSH
79822: EMPTY
79823: LIST
79824: LIST
79825: PUSH
79826: LD_INT 1
79828: PUSH
79829: LD_INT 2
79831: NEG
79832: PUSH
79833: EMPTY
79834: LIST
79835: LIST
79836: PUSH
79837: EMPTY
79838: LIST
79839: LIST
79840: LIST
79841: ST_TO_ADDR
// Barracks1 = [ [ 2 , - 1 ] , [ 3 , 0 ] , [ 3 , 1 ] ] ;
79842: LD_ADDR_VAR 0 54
79846: PUSH
79847: LD_INT 2
79849: PUSH
79850: LD_INT 1
79852: NEG
79853: PUSH
79854: EMPTY
79855: LIST
79856: LIST
79857: PUSH
79858: LD_INT 3
79860: PUSH
79861: LD_INT 0
79863: PUSH
79864: EMPTY
79865: LIST
79866: LIST
79867: PUSH
79868: LD_INT 3
79870: PUSH
79871: LD_INT 1
79873: PUSH
79874: EMPTY
79875: LIST
79876: LIST
79877: PUSH
79878: EMPTY
79879: LIST
79880: LIST
79881: LIST
79882: ST_TO_ADDR
// Barracks2 = [ [ 3 , 2 ] , [ 3 , 3 ] , [ 2 , 3 ] ] ;
79883: LD_ADDR_VAR 0 55
79887: PUSH
79888: LD_INT 3
79890: PUSH
79891: LD_INT 2
79893: PUSH
79894: EMPTY
79895: LIST
79896: LIST
79897: PUSH
79898: LD_INT 3
79900: PUSH
79901: LD_INT 3
79903: PUSH
79904: EMPTY
79905: LIST
79906: LIST
79907: PUSH
79908: LD_INT 2
79910: PUSH
79911: LD_INT 3
79913: PUSH
79914: EMPTY
79915: LIST
79916: LIST
79917: PUSH
79918: EMPTY
79919: LIST
79920: LIST
79921: LIST
79922: ST_TO_ADDR
// Barracks3 = [ [ 1 , 3 ] , [ 0 , 3 ] , [ - 1 , 2 ] ] ;
79923: LD_ADDR_VAR 0 56
79927: PUSH
79928: LD_INT 1
79930: PUSH
79931: LD_INT 3
79933: PUSH
79934: EMPTY
79935: LIST
79936: LIST
79937: PUSH
79938: LD_INT 0
79940: PUSH
79941: LD_INT 3
79943: PUSH
79944: EMPTY
79945: LIST
79946: LIST
79947: PUSH
79948: LD_INT 1
79950: NEG
79951: PUSH
79952: LD_INT 2
79954: PUSH
79955: EMPTY
79956: LIST
79957: LIST
79958: PUSH
79959: EMPTY
79960: LIST
79961: LIST
79962: LIST
79963: ST_TO_ADDR
// Barracks4 = [ [ - 2 , 1 ] , [ - 3 , 0 ] , [ - 3 , - 1 ] ] ;
79964: LD_ADDR_VAR 0 57
79968: PUSH
79969: LD_INT 2
79971: NEG
79972: PUSH
79973: LD_INT 1
79975: PUSH
79976: EMPTY
79977: LIST
79978: LIST
79979: PUSH
79980: LD_INT 3
79982: NEG
79983: PUSH
79984: LD_INT 0
79986: PUSH
79987: EMPTY
79988: LIST
79989: LIST
79990: PUSH
79991: LD_INT 3
79993: NEG
79994: PUSH
79995: LD_INT 1
79997: NEG
79998: PUSH
79999: EMPTY
80000: LIST
80001: LIST
80002: PUSH
80003: EMPTY
80004: LIST
80005: LIST
80006: LIST
80007: ST_TO_ADDR
// Barracks5 = [ [ - 2 , - 3 ] , [ - 3 , - 2 ] , [ - 3 , - 3 ] ] ;
80008: LD_ADDR_VAR 0 58
80012: PUSH
80013: LD_INT 2
80015: NEG
80016: PUSH
80017: LD_INT 3
80019: NEG
80020: PUSH
80021: EMPTY
80022: LIST
80023: LIST
80024: PUSH
80025: LD_INT 3
80027: NEG
80028: PUSH
80029: LD_INT 2
80031: NEG
80032: PUSH
80033: EMPTY
80034: LIST
80035: LIST
80036: PUSH
80037: LD_INT 3
80039: NEG
80040: PUSH
80041: LD_INT 3
80043: NEG
80044: PUSH
80045: EMPTY
80046: LIST
80047: LIST
80048: PUSH
80049: EMPTY
80050: LIST
80051: LIST
80052: LIST
80053: ST_TO_ADDR
// Bunker0 = [ [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] ] ;
80054: LD_ADDR_VAR 0 59
80058: PUSH
80059: LD_INT 1
80061: NEG
80062: PUSH
80063: LD_INT 2
80065: NEG
80066: PUSH
80067: EMPTY
80068: LIST
80069: LIST
80070: PUSH
80071: LD_INT 0
80073: PUSH
80074: LD_INT 2
80076: NEG
80077: PUSH
80078: EMPTY
80079: LIST
80080: LIST
80081: PUSH
80082: LD_INT 1
80084: PUSH
80085: LD_INT 1
80087: NEG
80088: PUSH
80089: EMPTY
80090: LIST
80091: LIST
80092: PUSH
80093: EMPTY
80094: LIST
80095: LIST
80096: LIST
80097: ST_TO_ADDR
// Bunker1 = [ [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] ] ;
80098: LD_ADDR_VAR 0 60
80102: PUSH
80103: LD_INT 1
80105: PUSH
80106: LD_INT 1
80108: NEG
80109: PUSH
80110: EMPTY
80111: LIST
80112: LIST
80113: PUSH
80114: LD_INT 2
80116: PUSH
80117: LD_INT 0
80119: PUSH
80120: EMPTY
80121: LIST
80122: LIST
80123: PUSH
80124: LD_INT 2
80126: PUSH
80127: LD_INT 1
80129: PUSH
80130: EMPTY
80131: LIST
80132: LIST
80133: PUSH
80134: EMPTY
80135: LIST
80136: LIST
80137: LIST
80138: ST_TO_ADDR
// Bunker2 = [ [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] ] ;
80139: LD_ADDR_VAR 0 61
80143: PUSH
80144: LD_INT 2
80146: PUSH
80147: LD_INT 1
80149: PUSH
80150: EMPTY
80151: LIST
80152: LIST
80153: PUSH
80154: LD_INT 2
80156: PUSH
80157: LD_INT 2
80159: PUSH
80160: EMPTY
80161: LIST
80162: LIST
80163: PUSH
80164: LD_INT 1
80166: PUSH
80167: LD_INT 2
80169: PUSH
80170: EMPTY
80171: LIST
80172: LIST
80173: PUSH
80174: EMPTY
80175: LIST
80176: LIST
80177: LIST
80178: ST_TO_ADDR
// Bunker3 = [ [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] ] ;
80179: LD_ADDR_VAR 0 62
80183: PUSH
80184: LD_INT 1
80186: PUSH
80187: LD_INT 2
80189: PUSH
80190: EMPTY
80191: LIST
80192: LIST
80193: PUSH
80194: LD_INT 0
80196: PUSH
80197: LD_INT 2
80199: PUSH
80200: EMPTY
80201: LIST
80202: LIST
80203: PUSH
80204: LD_INT 1
80206: NEG
80207: PUSH
80208: LD_INT 1
80210: PUSH
80211: EMPTY
80212: LIST
80213: LIST
80214: PUSH
80215: EMPTY
80216: LIST
80217: LIST
80218: LIST
80219: ST_TO_ADDR
// Bunker4 = [ [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] ] ;
80220: LD_ADDR_VAR 0 63
80224: PUSH
80225: LD_INT 1
80227: NEG
80228: PUSH
80229: LD_INT 1
80231: PUSH
80232: EMPTY
80233: LIST
80234: LIST
80235: PUSH
80236: LD_INT 2
80238: NEG
80239: PUSH
80240: LD_INT 0
80242: PUSH
80243: EMPTY
80244: LIST
80245: LIST
80246: PUSH
80247: LD_INT 2
80249: NEG
80250: PUSH
80251: LD_INT 1
80253: NEG
80254: PUSH
80255: EMPTY
80256: LIST
80257: LIST
80258: PUSH
80259: EMPTY
80260: LIST
80261: LIST
80262: LIST
80263: ST_TO_ADDR
// Bunker5 = [ [ - 1 , - 2 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
80264: LD_ADDR_VAR 0 64
80268: PUSH
80269: LD_INT 1
80271: NEG
80272: PUSH
80273: LD_INT 2
80275: NEG
80276: PUSH
80277: EMPTY
80278: LIST
80279: LIST
80280: PUSH
80281: LD_INT 2
80283: NEG
80284: PUSH
80285: LD_INT 1
80287: NEG
80288: PUSH
80289: EMPTY
80290: LIST
80291: LIST
80292: PUSH
80293: LD_INT 2
80295: NEG
80296: PUSH
80297: LD_INT 2
80299: NEG
80300: PUSH
80301: EMPTY
80302: LIST
80303: LIST
80304: PUSH
80305: EMPTY
80306: LIST
80307: LIST
80308: LIST
80309: ST_TO_ADDR
// end ; 2 :
80310: GO 83576
80312: LD_INT 2
80314: DOUBLE
80315: EQUAL
80316: IFTRUE 80320
80318: GO 83575
80320: POP
// begin Factory0 = [ [ 4 , 0 ] , [ 4 , - 1 ] , [ 5 , 0 ] , [ 5 , 1 ] , [ 4 , 1 ] , [ 3 , 0 ] , [ 3 , - 1 ] , [ 3 , - 2 ] , [ 5 , 2 ] , [ 3 , 3 ] , [ 3 , 2 ] , [ 4 , 3 ] , [ 4 , 4 ] , [ 3 , 4 ] , [ 2 , 3 ] , [ 2 , 2 ] , [ 4 , 2 ] , [ 2 , 4 ] , [ 0 , 4 ] , [ 0 , 3 ] , [ 1 , 4 ] , [ 1 , 5 ] , [ 0 , 5 ] , [ - 1 , 4 ] , [ - 1 , 3 ] , [ 2 , 5 ] , [ - 2 , 3 ] , [ - 3 , 0 ] , [ - 3 , - 1 ] , [ - 2 , 0 ] , [ - 2 , 1 ] , [ - 3 , 1 ] , [ - 4 , 0 ] , [ - 4 , - 1 ] , [ - 4 , - 2 ] , [ - 2 , 2 ] , [ - 4 , - 4 ] , [ - 4 , - 5 ] , [ - 3 , - 4 ] , [ - 3 , - 3 ] , [ - 4 , - 3 ] , [ - 5 , - 4 ] , [ - 5 , - 5 ] , [ - 3 , - 5 ] , [ - 5 , - 3 ] ] ;
80321: LD_ADDR_VAR 0 29
80325: PUSH
80326: LD_INT 4
80328: PUSH
80329: LD_INT 0
80331: PUSH
80332: EMPTY
80333: LIST
80334: LIST
80335: PUSH
80336: LD_INT 4
80338: PUSH
80339: LD_INT 1
80341: NEG
80342: PUSH
80343: EMPTY
80344: LIST
80345: LIST
80346: PUSH
80347: LD_INT 5
80349: PUSH
80350: LD_INT 0
80352: PUSH
80353: EMPTY
80354: LIST
80355: LIST
80356: PUSH
80357: LD_INT 5
80359: PUSH
80360: LD_INT 1
80362: PUSH
80363: EMPTY
80364: LIST
80365: LIST
80366: PUSH
80367: LD_INT 4
80369: PUSH
80370: LD_INT 1
80372: PUSH
80373: EMPTY
80374: LIST
80375: LIST
80376: PUSH
80377: LD_INT 3
80379: PUSH
80380: LD_INT 0
80382: PUSH
80383: EMPTY
80384: LIST
80385: LIST
80386: PUSH
80387: LD_INT 3
80389: PUSH
80390: LD_INT 1
80392: NEG
80393: PUSH
80394: EMPTY
80395: LIST
80396: LIST
80397: PUSH
80398: LD_INT 3
80400: PUSH
80401: LD_INT 2
80403: NEG
80404: PUSH
80405: EMPTY
80406: LIST
80407: LIST
80408: PUSH
80409: LD_INT 5
80411: PUSH
80412: LD_INT 2
80414: PUSH
80415: EMPTY
80416: LIST
80417: LIST
80418: PUSH
80419: LD_INT 3
80421: PUSH
80422: LD_INT 3
80424: PUSH
80425: EMPTY
80426: LIST
80427: LIST
80428: PUSH
80429: LD_INT 3
80431: PUSH
80432: LD_INT 2
80434: PUSH
80435: EMPTY
80436: LIST
80437: LIST
80438: PUSH
80439: LD_INT 4
80441: PUSH
80442: LD_INT 3
80444: PUSH
80445: EMPTY
80446: LIST
80447: LIST
80448: PUSH
80449: LD_INT 4
80451: PUSH
80452: LD_INT 4
80454: PUSH
80455: EMPTY
80456: LIST
80457: LIST
80458: PUSH
80459: LD_INT 3
80461: PUSH
80462: LD_INT 4
80464: PUSH
80465: EMPTY
80466: LIST
80467: LIST
80468: PUSH
80469: LD_INT 2
80471: PUSH
80472: LD_INT 3
80474: PUSH
80475: EMPTY
80476: LIST
80477: LIST
80478: PUSH
80479: LD_INT 2
80481: PUSH
80482: LD_INT 2
80484: PUSH
80485: EMPTY
80486: LIST
80487: LIST
80488: PUSH
80489: LD_INT 4
80491: PUSH
80492: LD_INT 2
80494: PUSH
80495: EMPTY
80496: LIST
80497: LIST
80498: PUSH
80499: LD_INT 2
80501: PUSH
80502: LD_INT 4
80504: PUSH
80505: EMPTY
80506: LIST
80507: LIST
80508: PUSH
80509: LD_INT 0
80511: PUSH
80512: LD_INT 4
80514: PUSH
80515: EMPTY
80516: LIST
80517: LIST
80518: PUSH
80519: LD_INT 0
80521: PUSH
80522: LD_INT 3
80524: PUSH
80525: EMPTY
80526: LIST
80527: LIST
80528: PUSH
80529: LD_INT 1
80531: PUSH
80532: LD_INT 4
80534: PUSH
80535: EMPTY
80536: LIST
80537: LIST
80538: PUSH
80539: LD_INT 1
80541: PUSH
80542: LD_INT 5
80544: PUSH
80545: EMPTY
80546: LIST
80547: LIST
80548: PUSH
80549: LD_INT 0
80551: PUSH
80552: LD_INT 5
80554: PUSH
80555: EMPTY
80556: LIST
80557: LIST
80558: PUSH
80559: LD_INT 1
80561: NEG
80562: PUSH
80563: LD_INT 4
80565: PUSH
80566: EMPTY
80567: LIST
80568: LIST
80569: PUSH
80570: LD_INT 1
80572: NEG
80573: PUSH
80574: LD_INT 3
80576: PUSH
80577: EMPTY
80578: LIST
80579: LIST
80580: PUSH
80581: LD_INT 2
80583: PUSH
80584: LD_INT 5
80586: PUSH
80587: EMPTY
80588: LIST
80589: LIST
80590: PUSH
80591: LD_INT 2
80593: NEG
80594: PUSH
80595: LD_INT 3
80597: PUSH
80598: EMPTY
80599: LIST
80600: LIST
80601: PUSH
80602: LD_INT 3
80604: NEG
80605: PUSH
80606: LD_INT 0
80608: PUSH
80609: EMPTY
80610: LIST
80611: LIST
80612: PUSH
80613: LD_INT 3
80615: NEG
80616: PUSH
80617: LD_INT 1
80619: NEG
80620: PUSH
80621: EMPTY
80622: LIST
80623: LIST
80624: PUSH
80625: LD_INT 2
80627: NEG
80628: PUSH
80629: LD_INT 0
80631: PUSH
80632: EMPTY
80633: LIST
80634: LIST
80635: PUSH
80636: LD_INT 2
80638: NEG
80639: PUSH
80640: LD_INT 1
80642: PUSH
80643: EMPTY
80644: LIST
80645: LIST
80646: PUSH
80647: LD_INT 3
80649: NEG
80650: PUSH
80651: LD_INT 1
80653: PUSH
80654: EMPTY
80655: LIST
80656: LIST
80657: PUSH
80658: LD_INT 4
80660: NEG
80661: PUSH
80662: LD_INT 0
80664: PUSH
80665: EMPTY
80666: LIST
80667: LIST
80668: PUSH
80669: LD_INT 4
80671: NEG
80672: PUSH
80673: LD_INT 1
80675: NEG
80676: PUSH
80677: EMPTY
80678: LIST
80679: LIST
80680: PUSH
80681: LD_INT 4
80683: NEG
80684: PUSH
80685: LD_INT 2
80687: NEG
80688: PUSH
80689: EMPTY
80690: LIST
80691: LIST
80692: PUSH
80693: LD_INT 2
80695: NEG
80696: PUSH
80697: LD_INT 2
80699: PUSH
80700: EMPTY
80701: LIST
80702: LIST
80703: PUSH
80704: LD_INT 4
80706: NEG
80707: PUSH
80708: LD_INT 4
80710: NEG
80711: PUSH
80712: EMPTY
80713: LIST
80714: LIST
80715: PUSH
80716: LD_INT 4
80718: NEG
80719: PUSH
80720: LD_INT 5
80722: NEG
80723: PUSH
80724: EMPTY
80725: LIST
80726: LIST
80727: PUSH
80728: LD_INT 3
80730: NEG
80731: PUSH
80732: LD_INT 4
80734: NEG
80735: PUSH
80736: EMPTY
80737: LIST
80738: LIST
80739: PUSH
80740: LD_INT 3
80742: NEG
80743: PUSH
80744: LD_INT 3
80746: NEG
80747: PUSH
80748: EMPTY
80749: LIST
80750: LIST
80751: PUSH
80752: LD_INT 4
80754: NEG
80755: PUSH
80756: LD_INT 3
80758: NEG
80759: PUSH
80760: EMPTY
80761: LIST
80762: LIST
80763: PUSH
80764: LD_INT 5
80766: NEG
80767: PUSH
80768: LD_INT 4
80770: NEG
80771: PUSH
80772: EMPTY
80773: LIST
80774: LIST
80775: PUSH
80776: LD_INT 5
80778: NEG
80779: PUSH
80780: LD_INT 5
80782: NEG
80783: PUSH
80784: EMPTY
80785: LIST
80786: LIST
80787: PUSH
80788: LD_INT 3
80790: NEG
80791: PUSH
80792: LD_INT 5
80794: NEG
80795: PUSH
80796: EMPTY
80797: LIST
80798: LIST
80799: PUSH
80800: LD_INT 5
80802: NEG
80803: PUSH
80804: LD_INT 3
80806: NEG
80807: PUSH
80808: EMPTY
80809: LIST
80810: LIST
80811: PUSH
80812: EMPTY
80813: LIST
80814: LIST
80815: LIST
80816: LIST
80817: LIST
80818: LIST
80819: LIST
80820: LIST
80821: LIST
80822: LIST
80823: LIST
80824: LIST
80825: LIST
80826: LIST
80827: LIST
80828: LIST
80829: LIST
80830: LIST
80831: LIST
80832: LIST
80833: LIST
80834: LIST
80835: LIST
80836: LIST
80837: LIST
80838: LIST
80839: LIST
80840: LIST
80841: LIST
80842: LIST
80843: LIST
80844: LIST
80845: LIST
80846: LIST
80847: LIST
80848: LIST
80849: LIST
80850: LIST
80851: LIST
80852: LIST
80853: LIST
80854: LIST
80855: LIST
80856: LIST
80857: LIST
80858: ST_TO_ADDR
// Factory1 = [ [ 4 , 4 ] , [ 4 , 3 ] , [ 5 , 4 ] , [ 5 , 5 ] , [ 4 , 5 ] , [ 3 , 4 ] , [ 3 , 3 ] , [ 5 , 3 ] , [ 3 , 5 ] , [ 0 , 3 ] , [ 0 , 2 ] , [ 1 , 3 ] , [ 1 , 4 ] , [ 0 , 4 ] , [ - 1 , 3 ] , [ - 1 , 2 ] , [ 2 , 4 ] , [ - 2 , 2 ] , [ - 4 , 0 ] , [ - 4 , - 1 ] , [ - 3 , 0 ] , [ - 3 , 1 ] , [ - 4 , 1 ] , [ - 5 , 0 ] , [ - 5 , - 1 ] , [ - 5 , - 2 ] , [ - 3 , 2 ] , [ - 3 , - 3 ] , [ - 3 , - 4 ] , [ - 2 , - 3 ] , [ - 2 , - 2 ] , [ - 3 , - 2 ] , [ - 4 , - 3 ] , [ - 4 , - 4 ] , [ - 2 , - 4 ] , [ - 4 , - 2 ] , [ 0 , - 4 ] , [ 0 , - 5 ] , [ 1 , - 4 ] , [ 1 , - 3 ] , [ 0 , - 3 ] , [ - 1 , - 4 ] , [ - 1 , - 5 ] , [ 2 , - 3 ] , [ - 2 , - 5 ] ] ;
80859: LD_ADDR_VAR 0 30
80863: PUSH
80864: LD_INT 4
80866: PUSH
80867: LD_INT 4
80869: PUSH
80870: EMPTY
80871: LIST
80872: LIST
80873: PUSH
80874: LD_INT 4
80876: PUSH
80877: LD_INT 3
80879: PUSH
80880: EMPTY
80881: LIST
80882: LIST
80883: PUSH
80884: LD_INT 5
80886: PUSH
80887: LD_INT 4
80889: PUSH
80890: EMPTY
80891: LIST
80892: LIST
80893: PUSH
80894: LD_INT 5
80896: PUSH
80897: LD_INT 5
80899: PUSH
80900: EMPTY
80901: LIST
80902: LIST
80903: PUSH
80904: LD_INT 4
80906: PUSH
80907: LD_INT 5
80909: PUSH
80910: EMPTY
80911: LIST
80912: LIST
80913: PUSH
80914: LD_INT 3
80916: PUSH
80917: LD_INT 4
80919: PUSH
80920: EMPTY
80921: LIST
80922: LIST
80923: PUSH
80924: LD_INT 3
80926: PUSH
80927: LD_INT 3
80929: PUSH
80930: EMPTY
80931: LIST
80932: LIST
80933: PUSH
80934: LD_INT 5
80936: PUSH
80937: LD_INT 3
80939: PUSH
80940: EMPTY
80941: LIST
80942: LIST
80943: PUSH
80944: LD_INT 3
80946: PUSH
80947: LD_INT 5
80949: PUSH
80950: EMPTY
80951: LIST
80952: LIST
80953: PUSH
80954: LD_INT 0
80956: PUSH
80957: LD_INT 3
80959: PUSH
80960: EMPTY
80961: LIST
80962: LIST
80963: PUSH
80964: LD_INT 0
80966: PUSH
80967: LD_INT 2
80969: PUSH
80970: EMPTY
80971: LIST
80972: LIST
80973: PUSH
80974: LD_INT 1
80976: PUSH
80977: LD_INT 3
80979: PUSH
80980: EMPTY
80981: LIST
80982: LIST
80983: PUSH
80984: LD_INT 1
80986: PUSH
80987: LD_INT 4
80989: PUSH
80990: EMPTY
80991: LIST
80992: LIST
80993: PUSH
80994: LD_INT 0
80996: PUSH
80997: LD_INT 4
80999: PUSH
81000: EMPTY
81001: LIST
81002: LIST
81003: PUSH
81004: LD_INT 1
81006: NEG
81007: PUSH
81008: LD_INT 3
81010: PUSH
81011: EMPTY
81012: LIST
81013: LIST
81014: PUSH
81015: LD_INT 1
81017: NEG
81018: PUSH
81019: LD_INT 2
81021: PUSH
81022: EMPTY
81023: LIST
81024: LIST
81025: PUSH
81026: LD_INT 2
81028: PUSH
81029: LD_INT 4
81031: PUSH
81032: EMPTY
81033: LIST
81034: LIST
81035: PUSH
81036: LD_INT 2
81038: NEG
81039: PUSH
81040: LD_INT 2
81042: PUSH
81043: EMPTY
81044: LIST
81045: LIST
81046: PUSH
81047: LD_INT 4
81049: NEG
81050: PUSH
81051: LD_INT 0
81053: PUSH
81054: EMPTY
81055: LIST
81056: LIST
81057: PUSH
81058: LD_INT 4
81060: NEG
81061: PUSH
81062: LD_INT 1
81064: NEG
81065: PUSH
81066: EMPTY
81067: LIST
81068: LIST
81069: PUSH
81070: LD_INT 3
81072: NEG
81073: PUSH
81074: LD_INT 0
81076: PUSH
81077: EMPTY
81078: LIST
81079: LIST
81080: PUSH
81081: LD_INT 3
81083: NEG
81084: PUSH
81085: LD_INT 1
81087: PUSH
81088: EMPTY
81089: LIST
81090: LIST
81091: PUSH
81092: LD_INT 4
81094: NEG
81095: PUSH
81096: LD_INT 1
81098: PUSH
81099: EMPTY
81100: LIST
81101: LIST
81102: PUSH
81103: LD_INT 5
81105: NEG
81106: PUSH
81107: LD_INT 0
81109: PUSH
81110: EMPTY
81111: LIST
81112: LIST
81113: PUSH
81114: LD_INT 5
81116: NEG
81117: PUSH
81118: LD_INT 1
81120: NEG
81121: PUSH
81122: EMPTY
81123: LIST
81124: LIST
81125: PUSH
81126: LD_INT 5
81128: NEG
81129: PUSH
81130: LD_INT 2
81132: NEG
81133: PUSH
81134: EMPTY
81135: LIST
81136: LIST
81137: PUSH
81138: LD_INT 3
81140: NEG
81141: PUSH
81142: LD_INT 2
81144: PUSH
81145: EMPTY
81146: LIST
81147: LIST
81148: PUSH
81149: LD_INT 3
81151: NEG
81152: PUSH
81153: LD_INT 3
81155: NEG
81156: PUSH
81157: EMPTY
81158: LIST
81159: LIST
81160: PUSH
81161: LD_INT 3
81163: NEG
81164: PUSH
81165: LD_INT 4
81167: NEG
81168: PUSH
81169: EMPTY
81170: LIST
81171: LIST
81172: PUSH
81173: LD_INT 2
81175: NEG
81176: PUSH
81177: LD_INT 3
81179: NEG
81180: PUSH
81181: EMPTY
81182: LIST
81183: LIST
81184: PUSH
81185: LD_INT 2
81187: NEG
81188: PUSH
81189: LD_INT 2
81191: NEG
81192: PUSH
81193: EMPTY
81194: LIST
81195: LIST
81196: PUSH
81197: LD_INT 3
81199: NEG
81200: PUSH
81201: LD_INT 2
81203: NEG
81204: PUSH
81205: EMPTY
81206: LIST
81207: LIST
81208: PUSH
81209: LD_INT 4
81211: NEG
81212: PUSH
81213: LD_INT 3
81215: NEG
81216: PUSH
81217: EMPTY
81218: LIST
81219: LIST
81220: PUSH
81221: LD_INT 4
81223: NEG
81224: PUSH
81225: LD_INT 4
81227: NEG
81228: PUSH
81229: EMPTY
81230: LIST
81231: LIST
81232: PUSH
81233: LD_INT 2
81235: NEG
81236: PUSH
81237: LD_INT 4
81239: NEG
81240: PUSH
81241: EMPTY
81242: LIST
81243: LIST
81244: PUSH
81245: LD_INT 4
81247: NEG
81248: PUSH
81249: LD_INT 2
81251: NEG
81252: PUSH
81253: EMPTY
81254: LIST
81255: LIST
81256: PUSH
81257: LD_INT 0
81259: PUSH
81260: LD_INT 4
81262: NEG
81263: PUSH
81264: EMPTY
81265: LIST
81266: LIST
81267: PUSH
81268: LD_INT 0
81270: PUSH
81271: LD_INT 5
81273: NEG
81274: PUSH
81275: EMPTY
81276: LIST
81277: LIST
81278: PUSH
81279: LD_INT 1
81281: PUSH
81282: LD_INT 4
81284: NEG
81285: PUSH
81286: EMPTY
81287: LIST
81288: LIST
81289: PUSH
81290: LD_INT 1
81292: PUSH
81293: LD_INT 3
81295: NEG
81296: PUSH
81297: EMPTY
81298: LIST
81299: LIST
81300: PUSH
81301: LD_INT 0
81303: PUSH
81304: LD_INT 3
81306: NEG
81307: PUSH
81308: EMPTY
81309: LIST
81310: LIST
81311: PUSH
81312: LD_INT 1
81314: NEG
81315: PUSH
81316: LD_INT 4
81318: NEG
81319: PUSH
81320: EMPTY
81321: LIST
81322: LIST
81323: PUSH
81324: LD_INT 1
81326: NEG
81327: PUSH
81328: LD_INT 5
81330: NEG
81331: PUSH
81332: EMPTY
81333: LIST
81334: LIST
81335: PUSH
81336: LD_INT 2
81338: PUSH
81339: LD_INT 3
81341: NEG
81342: PUSH
81343: EMPTY
81344: LIST
81345: LIST
81346: PUSH
81347: LD_INT 2
81349: NEG
81350: PUSH
81351: LD_INT 5
81353: NEG
81354: PUSH
81355: EMPTY
81356: LIST
81357: LIST
81358: PUSH
81359: EMPTY
81360: LIST
81361: LIST
81362: LIST
81363: LIST
81364: LIST
81365: LIST
81366: LIST
81367: LIST
81368: LIST
81369: LIST
81370: LIST
81371: LIST
81372: LIST
81373: LIST
81374: LIST
81375: LIST
81376: LIST
81377: LIST
81378: LIST
81379: LIST
81380: LIST
81381: LIST
81382: LIST
81383: LIST
81384: LIST
81385: LIST
81386: LIST
81387: LIST
81388: LIST
81389: LIST
81390: LIST
81391: LIST
81392: LIST
81393: LIST
81394: LIST
81395: LIST
81396: LIST
81397: LIST
81398: LIST
81399: LIST
81400: LIST
81401: LIST
81402: LIST
81403: LIST
81404: LIST
81405: ST_TO_ADDR
// Factory2 = [ [ 0 , 4 ] , [ 0 , 3 ] , [ 1 , 4 ] , [ 1 , 5 ] , [ 0 , 5 ] , [ - 1 , 4 ] , [ - 1 , 3 ] , [ 2 , 5 ] , [ - 2 , 3 ] , [ - 3 , 0 ] , [ - 3 , - 1 ] , [ - 2 , 0 ] , [ - 2 , 1 ] , [ - 3 , 1 ] , [ - 4 , 0 ] , [ - 4 , - 1 ] , [ - 4 , - 2 ] , [ - 2 , 2 ] , [ - 4 , - 4 ] , [ - 4 , - 5 ] , [ - 3 , - 4 ] , [ - 3 , - 3 ] , [ - 4 , - 3 ] , [ - 5 , - 4 ] , [ - 5 , - 5 ] , [ - 3 , - 5 ] , [ - 5 , - 3 ] , [ 0 , - 3 ] , [ 0 , - 4 ] , [ 1 , - 3 ] , [ 1 , - 2 ] , [ 0 , - 2 ] , [ - 1 , - 3 ] , [ - 1 , - 4 ] , [ 2 , - 2 ] , [ - 2 , - 4 ] , [ 4 , 0 ] , [ 4 , - 1 ] , [ 5 , 0 ] , [ 5 , 1 ] , [ 4 , 1 ] , [ 3 , 0 ] , [ 3 , - 1 ] , [ 3 , - 2 ] , [ 5 , 2 ] ] ;
81406: LD_ADDR_VAR 0 31
81410: PUSH
81411: LD_INT 0
81413: PUSH
81414: LD_INT 4
81416: PUSH
81417: EMPTY
81418: LIST
81419: LIST
81420: PUSH
81421: LD_INT 0
81423: PUSH
81424: LD_INT 3
81426: PUSH
81427: EMPTY
81428: LIST
81429: LIST
81430: PUSH
81431: LD_INT 1
81433: PUSH
81434: LD_INT 4
81436: PUSH
81437: EMPTY
81438: LIST
81439: LIST
81440: PUSH
81441: LD_INT 1
81443: PUSH
81444: LD_INT 5
81446: PUSH
81447: EMPTY
81448: LIST
81449: LIST
81450: PUSH
81451: LD_INT 0
81453: PUSH
81454: LD_INT 5
81456: PUSH
81457: EMPTY
81458: LIST
81459: LIST
81460: PUSH
81461: LD_INT 1
81463: NEG
81464: PUSH
81465: LD_INT 4
81467: PUSH
81468: EMPTY
81469: LIST
81470: LIST
81471: PUSH
81472: LD_INT 1
81474: NEG
81475: PUSH
81476: LD_INT 3
81478: PUSH
81479: EMPTY
81480: LIST
81481: LIST
81482: PUSH
81483: LD_INT 2
81485: PUSH
81486: LD_INT 5
81488: PUSH
81489: EMPTY
81490: LIST
81491: LIST
81492: PUSH
81493: LD_INT 2
81495: NEG
81496: PUSH
81497: LD_INT 3
81499: PUSH
81500: EMPTY
81501: LIST
81502: LIST
81503: PUSH
81504: LD_INT 3
81506: NEG
81507: PUSH
81508: LD_INT 0
81510: PUSH
81511: EMPTY
81512: LIST
81513: LIST
81514: PUSH
81515: LD_INT 3
81517: NEG
81518: PUSH
81519: LD_INT 1
81521: NEG
81522: PUSH
81523: EMPTY
81524: LIST
81525: LIST
81526: PUSH
81527: LD_INT 2
81529: NEG
81530: PUSH
81531: LD_INT 0
81533: PUSH
81534: EMPTY
81535: LIST
81536: LIST
81537: PUSH
81538: LD_INT 2
81540: NEG
81541: PUSH
81542: LD_INT 1
81544: PUSH
81545: EMPTY
81546: LIST
81547: LIST
81548: PUSH
81549: LD_INT 3
81551: NEG
81552: PUSH
81553: LD_INT 1
81555: PUSH
81556: EMPTY
81557: LIST
81558: LIST
81559: PUSH
81560: LD_INT 4
81562: NEG
81563: PUSH
81564: LD_INT 0
81566: PUSH
81567: EMPTY
81568: LIST
81569: LIST
81570: PUSH
81571: LD_INT 4
81573: NEG
81574: PUSH
81575: LD_INT 1
81577: NEG
81578: PUSH
81579: EMPTY
81580: LIST
81581: LIST
81582: PUSH
81583: LD_INT 4
81585: NEG
81586: PUSH
81587: LD_INT 2
81589: NEG
81590: PUSH
81591: EMPTY
81592: LIST
81593: LIST
81594: PUSH
81595: LD_INT 2
81597: NEG
81598: PUSH
81599: LD_INT 2
81601: PUSH
81602: EMPTY
81603: LIST
81604: LIST
81605: PUSH
81606: LD_INT 4
81608: NEG
81609: PUSH
81610: LD_INT 4
81612: NEG
81613: PUSH
81614: EMPTY
81615: LIST
81616: LIST
81617: PUSH
81618: LD_INT 4
81620: NEG
81621: PUSH
81622: LD_INT 5
81624: NEG
81625: PUSH
81626: EMPTY
81627: LIST
81628: LIST
81629: PUSH
81630: LD_INT 3
81632: NEG
81633: PUSH
81634: LD_INT 4
81636: NEG
81637: PUSH
81638: EMPTY
81639: LIST
81640: LIST
81641: PUSH
81642: LD_INT 3
81644: NEG
81645: PUSH
81646: LD_INT 3
81648: NEG
81649: PUSH
81650: EMPTY
81651: LIST
81652: LIST
81653: PUSH
81654: LD_INT 4
81656: NEG
81657: PUSH
81658: LD_INT 3
81660: NEG
81661: PUSH
81662: EMPTY
81663: LIST
81664: LIST
81665: PUSH
81666: LD_INT 5
81668: NEG
81669: PUSH
81670: LD_INT 4
81672: NEG
81673: PUSH
81674: EMPTY
81675: LIST
81676: LIST
81677: PUSH
81678: LD_INT 5
81680: NEG
81681: PUSH
81682: LD_INT 5
81684: NEG
81685: PUSH
81686: EMPTY
81687: LIST
81688: LIST
81689: PUSH
81690: LD_INT 3
81692: NEG
81693: PUSH
81694: LD_INT 5
81696: NEG
81697: PUSH
81698: EMPTY
81699: LIST
81700: LIST
81701: PUSH
81702: LD_INT 5
81704: NEG
81705: PUSH
81706: LD_INT 3
81708: NEG
81709: PUSH
81710: EMPTY
81711: LIST
81712: LIST
81713: PUSH
81714: LD_INT 0
81716: PUSH
81717: LD_INT 3
81719: NEG
81720: PUSH
81721: EMPTY
81722: LIST
81723: LIST
81724: PUSH
81725: LD_INT 0
81727: PUSH
81728: LD_INT 4
81730: NEG
81731: PUSH
81732: EMPTY
81733: LIST
81734: LIST
81735: PUSH
81736: LD_INT 1
81738: PUSH
81739: LD_INT 3
81741: NEG
81742: PUSH
81743: EMPTY
81744: LIST
81745: LIST
81746: PUSH
81747: LD_INT 1
81749: PUSH
81750: LD_INT 2
81752: NEG
81753: PUSH
81754: EMPTY
81755: LIST
81756: LIST
81757: PUSH
81758: LD_INT 0
81760: PUSH
81761: LD_INT 2
81763: NEG
81764: PUSH
81765: EMPTY
81766: LIST
81767: LIST
81768: PUSH
81769: LD_INT 1
81771: NEG
81772: PUSH
81773: LD_INT 3
81775: NEG
81776: PUSH
81777: EMPTY
81778: LIST
81779: LIST
81780: PUSH
81781: LD_INT 1
81783: NEG
81784: PUSH
81785: LD_INT 4
81787: NEG
81788: PUSH
81789: EMPTY
81790: LIST
81791: LIST
81792: PUSH
81793: LD_INT 2
81795: PUSH
81796: LD_INT 2
81798: NEG
81799: PUSH
81800: EMPTY
81801: LIST
81802: LIST
81803: PUSH
81804: LD_INT 2
81806: NEG
81807: PUSH
81808: LD_INT 4
81810: NEG
81811: PUSH
81812: EMPTY
81813: LIST
81814: LIST
81815: PUSH
81816: LD_INT 4
81818: PUSH
81819: LD_INT 0
81821: PUSH
81822: EMPTY
81823: LIST
81824: LIST
81825: PUSH
81826: LD_INT 4
81828: PUSH
81829: LD_INT 1
81831: NEG
81832: PUSH
81833: EMPTY
81834: LIST
81835: LIST
81836: PUSH
81837: LD_INT 5
81839: PUSH
81840: LD_INT 0
81842: PUSH
81843: EMPTY
81844: LIST
81845: LIST
81846: PUSH
81847: LD_INT 5
81849: PUSH
81850: LD_INT 1
81852: PUSH
81853: EMPTY
81854: LIST
81855: LIST
81856: PUSH
81857: LD_INT 4
81859: PUSH
81860: LD_INT 1
81862: PUSH
81863: EMPTY
81864: LIST
81865: LIST
81866: PUSH
81867: LD_INT 3
81869: PUSH
81870: LD_INT 0
81872: PUSH
81873: EMPTY
81874: LIST
81875: LIST
81876: PUSH
81877: LD_INT 3
81879: PUSH
81880: LD_INT 1
81882: NEG
81883: PUSH
81884: EMPTY
81885: LIST
81886: LIST
81887: PUSH
81888: LD_INT 3
81890: PUSH
81891: LD_INT 2
81893: NEG
81894: PUSH
81895: EMPTY
81896: LIST
81897: LIST
81898: PUSH
81899: LD_INT 5
81901: PUSH
81902: LD_INT 2
81904: PUSH
81905: EMPTY
81906: LIST
81907: LIST
81908: PUSH
81909: EMPTY
81910: LIST
81911: LIST
81912: LIST
81913: LIST
81914: LIST
81915: LIST
81916: LIST
81917: LIST
81918: LIST
81919: LIST
81920: LIST
81921: LIST
81922: LIST
81923: LIST
81924: LIST
81925: LIST
81926: LIST
81927: LIST
81928: LIST
81929: LIST
81930: LIST
81931: LIST
81932: LIST
81933: LIST
81934: LIST
81935: LIST
81936: LIST
81937: LIST
81938: LIST
81939: LIST
81940: LIST
81941: LIST
81942: LIST
81943: LIST
81944: LIST
81945: LIST
81946: LIST
81947: LIST
81948: LIST
81949: LIST
81950: LIST
81951: LIST
81952: LIST
81953: LIST
81954: LIST
81955: ST_TO_ADDR
// Factory3 = [ [ - 4 , 0 ] , [ - 4 , - 1 ] , [ - 3 , 0 ] , [ - 3 , 1 ] , [ - 4 , 1 ] , [ - 5 , 0 ] , [ - 5 , - 1 ] , [ - 5 , - 2 ] , [ - 3 , 2 ] , [ - 3 , - 3 ] , [ - 3 , - 4 ] , [ - 2 , - 3 ] , [ - 2 , - 2 ] , [ - 3 , - 2 ] , [ - 4 , - 3 ] , [ - 4 , - 4 ] , [ - 2 , - 4 ] , [ - 4 , - 2 ] , [ 0 , - 4 ] , [ 0 , - 5 ] , [ 1 , - 4 ] , [ 1 , - 3 ] , [ 0 , - 3 ] , [ - 1 , - 4 ] , [ - 1 , - 5 ] , [ 2 , - 3 ] , [ - 2 , - 5 ] , [ 3 , 0 ] , [ 3 , - 1 ] , [ 4 , 0 ] , [ 4 , 1 ] , [ 3 , 1 ] , [ 2 , 0 ] , [ 2 , - 1 ] , [ 2 , - 2 ] , [ 4 , 2 ] , [ 4 , 4 ] , [ 4 , 3 ] , [ 5 , 4 ] , [ 5 , 5 ] , [ 4 , 5 ] , [ 3 , 4 ] , [ 3 , 3 ] , [ 5 , 3 ] , [ 3 , 5 ] ] ;
81956: LD_ADDR_VAR 0 32
81960: PUSH
81961: LD_INT 4
81963: NEG
81964: PUSH
81965: LD_INT 0
81967: PUSH
81968: EMPTY
81969: LIST
81970: LIST
81971: PUSH
81972: LD_INT 4
81974: NEG
81975: PUSH
81976: LD_INT 1
81978: NEG
81979: PUSH
81980: EMPTY
81981: LIST
81982: LIST
81983: PUSH
81984: LD_INT 3
81986: NEG
81987: PUSH
81988: LD_INT 0
81990: PUSH
81991: EMPTY
81992: LIST
81993: LIST
81994: PUSH
81995: LD_INT 3
81997: NEG
81998: PUSH
81999: LD_INT 1
82001: PUSH
82002: EMPTY
82003: LIST
82004: LIST
82005: PUSH
82006: LD_INT 4
82008: NEG
82009: PUSH
82010: LD_INT 1
82012: PUSH
82013: EMPTY
82014: LIST
82015: LIST
82016: PUSH
82017: LD_INT 5
82019: NEG
82020: PUSH
82021: LD_INT 0
82023: PUSH
82024: EMPTY
82025: LIST
82026: LIST
82027: PUSH
82028: LD_INT 5
82030: NEG
82031: PUSH
82032: LD_INT 1
82034: NEG
82035: PUSH
82036: EMPTY
82037: LIST
82038: LIST
82039: PUSH
82040: LD_INT 5
82042: NEG
82043: PUSH
82044: LD_INT 2
82046: NEG
82047: PUSH
82048: EMPTY
82049: LIST
82050: LIST
82051: PUSH
82052: LD_INT 3
82054: NEG
82055: PUSH
82056: LD_INT 2
82058: PUSH
82059: EMPTY
82060: LIST
82061: LIST
82062: PUSH
82063: LD_INT 3
82065: NEG
82066: PUSH
82067: LD_INT 3
82069: NEG
82070: PUSH
82071: EMPTY
82072: LIST
82073: LIST
82074: PUSH
82075: LD_INT 3
82077: NEG
82078: PUSH
82079: LD_INT 4
82081: NEG
82082: PUSH
82083: EMPTY
82084: LIST
82085: LIST
82086: PUSH
82087: LD_INT 2
82089: NEG
82090: PUSH
82091: LD_INT 3
82093: NEG
82094: PUSH
82095: EMPTY
82096: LIST
82097: LIST
82098: PUSH
82099: LD_INT 2
82101: NEG
82102: PUSH
82103: LD_INT 2
82105: NEG
82106: PUSH
82107: EMPTY
82108: LIST
82109: LIST
82110: PUSH
82111: LD_INT 3
82113: NEG
82114: PUSH
82115: LD_INT 2
82117: NEG
82118: PUSH
82119: EMPTY
82120: LIST
82121: LIST
82122: PUSH
82123: LD_INT 4
82125: NEG
82126: PUSH
82127: LD_INT 3
82129: NEG
82130: PUSH
82131: EMPTY
82132: LIST
82133: LIST
82134: PUSH
82135: LD_INT 4
82137: NEG
82138: PUSH
82139: LD_INT 4
82141: NEG
82142: PUSH
82143: EMPTY
82144: LIST
82145: LIST
82146: PUSH
82147: LD_INT 2
82149: NEG
82150: PUSH
82151: LD_INT 4
82153: NEG
82154: PUSH
82155: EMPTY
82156: LIST
82157: LIST
82158: PUSH
82159: LD_INT 4
82161: NEG
82162: PUSH
82163: LD_INT 2
82165: NEG
82166: PUSH
82167: EMPTY
82168: LIST
82169: LIST
82170: PUSH
82171: LD_INT 0
82173: PUSH
82174: LD_INT 4
82176: NEG
82177: PUSH
82178: EMPTY
82179: LIST
82180: LIST
82181: PUSH
82182: LD_INT 0
82184: PUSH
82185: LD_INT 5
82187: NEG
82188: PUSH
82189: EMPTY
82190: LIST
82191: LIST
82192: PUSH
82193: LD_INT 1
82195: PUSH
82196: LD_INT 4
82198: NEG
82199: PUSH
82200: EMPTY
82201: LIST
82202: LIST
82203: PUSH
82204: LD_INT 1
82206: PUSH
82207: LD_INT 3
82209: NEG
82210: PUSH
82211: EMPTY
82212: LIST
82213: LIST
82214: PUSH
82215: LD_INT 0
82217: PUSH
82218: LD_INT 3
82220: NEG
82221: PUSH
82222: EMPTY
82223: LIST
82224: LIST
82225: PUSH
82226: LD_INT 1
82228: NEG
82229: PUSH
82230: LD_INT 4
82232: NEG
82233: PUSH
82234: EMPTY
82235: LIST
82236: LIST
82237: PUSH
82238: LD_INT 1
82240: NEG
82241: PUSH
82242: LD_INT 5
82244: NEG
82245: PUSH
82246: EMPTY
82247: LIST
82248: LIST
82249: PUSH
82250: LD_INT 2
82252: PUSH
82253: LD_INT 3
82255: NEG
82256: PUSH
82257: EMPTY
82258: LIST
82259: LIST
82260: PUSH
82261: LD_INT 2
82263: NEG
82264: PUSH
82265: LD_INT 5
82267: NEG
82268: PUSH
82269: EMPTY
82270: LIST
82271: LIST
82272: PUSH
82273: LD_INT 3
82275: PUSH
82276: LD_INT 0
82278: PUSH
82279: EMPTY
82280: LIST
82281: LIST
82282: PUSH
82283: LD_INT 3
82285: PUSH
82286: LD_INT 1
82288: NEG
82289: PUSH
82290: EMPTY
82291: LIST
82292: LIST
82293: PUSH
82294: LD_INT 4
82296: PUSH
82297: LD_INT 0
82299: PUSH
82300: EMPTY
82301: LIST
82302: LIST
82303: PUSH
82304: LD_INT 4
82306: PUSH
82307: LD_INT 1
82309: PUSH
82310: EMPTY
82311: LIST
82312: LIST
82313: PUSH
82314: LD_INT 3
82316: PUSH
82317: LD_INT 1
82319: PUSH
82320: EMPTY
82321: LIST
82322: LIST
82323: PUSH
82324: LD_INT 2
82326: PUSH
82327: LD_INT 0
82329: PUSH
82330: EMPTY
82331: LIST
82332: LIST
82333: PUSH
82334: LD_INT 2
82336: PUSH
82337: LD_INT 1
82339: NEG
82340: PUSH
82341: EMPTY
82342: LIST
82343: LIST
82344: PUSH
82345: LD_INT 2
82347: PUSH
82348: LD_INT 2
82350: NEG
82351: PUSH
82352: EMPTY
82353: LIST
82354: LIST
82355: PUSH
82356: LD_INT 4
82358: PUSH
82359: LD_INT 2
82361: PUSH
82362: EMPTY
82363: LIST
82364: LIST
82365: PUSH
82366: LD_INT 4
82368: PUSH
82369: LD_INT 4
82371: PUSH
82372: EMPTY
82373: LIST
82374: LIST
82375: PUSH
82376: LD_INT 4
82378: PUSH
82379: LD_INT 3
82381: PUSH
82382: EMPTY
82383: LIST
82384: LIST
82385: PUSH
82386: LD_INT 5
82388: PUSH
82389: LD_INT 4
82391: PUSH
82392: EMPTY
82393: LIST
82394: LIST
82395: PUSH
82396: LD_INT 5
82398: PUSH
82399: LD_INT 5
82401: PUSH
82402: EMPTY
82403: LIST
82404: LIST
82405: PUSH
82406: LD_INT 4
82408: PUSH
82409: LD_INT 5
82411: PUSH
82412: EMPTY
82413: LIST
82414: LIST
82415: PUSH
82416: LD_INT 3
82418: PUSH
82419: LD_INT 4
82421: PUSH
82422: EMPTY
82423: LIST
82424: LIST
82425: PUSH
82426: LD_INT 3
82428: PUSH
82429: LD_INT 3
82431: PUSH
82432: EMPTY
82433: LIST
82434: LIST
82435: PUSH
82436: LD_INT 5
82438: PUSH
82439: LD_INT 3
82441: PUSH
82442: EMPTY
82443: LIST
82444: LIST
82445: PUSH
82446: LD_INT 3
82448: PUSH
82449: LD_INT 5
82451: PUSH
82452: EMPTY
82453: LIST
82454: LIST
82455: PUSH
82456: EMPTY
82457: LIST
82458: LIST
82459: LIST
82460: LIST
82461: LIST
82462: LIST
82463: LIST
82464: LIST
82465: LIST
82466: LIST
82467: LIST
82468: LIST
82469: LIST
82470: LIST
82471: LIST
82472: LIST
82473: LIST
82474: LIST
82475: LIST
82476: LIST
82477: LIST
82478: LIST
82479: LIST
82480: LIST
82481: LIST
82482: LIST
82483: LIST
82484: LIST
82485: LIST
82486: LIST
82487: LIST
82488: LIST
82489: LIST
82490: LIST
82491: LIST
82492: LIST
82493: LIST
82494: LIST
82495: LIST
82496: LIST
82497: LIST
82498: LIST
82499: LIST
82500: LIST
82501: LIST
82502: ST_TO_ADDR
// Factory4 = [ [ - 4 , - 4 ] , [ - 4 , - 5 ] , [ - 3 , - 4 ] , [ - 3 , - 3 ] , [ - 4 , - 3 ] , [ - 5 , - 4 ] , [ - 5 , - 5 ] , [ - 3 , - 5 ] , [ - 5 , - 3 ] , [ 0 , - 3 ] , [ 0 , - 4 ] , [ 1 , - 3 ] , [ 1 , - 2 ] , [ 0 , - 2 ] , [ - 1 , - 3 ] , [ - 1 , - 4 ] , [ 2 , - 2 ] , [ - 2 , - 4 ] , [ 4 , 0 ] , [ 4 , - 1 ] , [ 5 , 0 ] , [ 5 , 1 ] , [ 4 , 1 ] , [ 3 , 0 ] , [ 3 , - 1 ] , [ 3 , - 2 ] , [ 5 , 2 ] , [ 3 , 3 ] , [ 3 , 2 ] , [ 4 , 3 ] , [ 4 , 4 ] , [ 3 , 4 ] , [ 2 , 3 ] , [ 2 , 2 ] , [ 4 , 2 ] , [ 2 , 4 ] , [ 0 , 4 ] , [ 0 , 3 ] , [ 1 , 4 ] , [ 1 , 5 ] , [ 0 , 5 ] , [ - 1 , 4 ] , [ - 1 , 3 ] , [ 2 , 5 ] , [ - 2 , 3 ] ] ;
82503: LD_ADDR_VAR 0 33
82507: PUSH
82508: LD_INT 4
82510: NEG
82511: PUSH
82512: LD_INT 4
82514: NEG
82515: PUSH
82516: EMPTY
82517: LIST
82518: LIST
82519: PUSH
82520: LD_INT 4
82522: NEG
82523: PUSH
82524: LD_INT 5
82526: NEG
82527: PUSH
82528: EMPTY
82529: LIST
82530: LIST
82531: PUSH
82532: LD_INT 3
82534: NEG
82535: PUSH
82536: LD_INT 4
82538: NEG
82539: PUSH
82540: EMPTY
82541: LIST
82542: LIST
82543: PUSH
82544: LD_INT 3
82546: NEG
82547: PUSH
82548: LD_INT 3
82550: NEG
82551: PUSH
82552: EMPTY
82553: LIST
82554: LIST
82555: PUSH
82556: LD_INT 4
82558: NEG
82559: PUSH
82560: LD_INT 3
82562: NEG
82563: PUSH
82564: EMPTY
82565: LIST
82566: LIST
82567: PUSH
82568: LD_INT 5
82570: NEG
82571: PUSH
82572: LD_INT 4
82574: NEG
82575: PUSH
82576: EMPTY
82577: LIST
82578: LIST
82579: PUSH
82580: LD_INT 5
82582: NEG
82583: PUSH
82584: LD_INT 5
82586: NEG
82587: PUSH
82588: EMPTY
82589: LIST
82590: LIST
82591: PUSH
82592: LD_INT 3
82594: NEG
82595: PUSH
82596: LD_INT 5
82598: NEG
82599: PUSH
82600: EMPTY
82601: LIST
82602: LIST
82603: PUSH
82604: LD_INT 5
82606: NEG
82607: PUSH
82608: LD_INT 3
82610: NEG
82611: PUSH
82612: EMPTY
82613: LIST
82614: LIST
82615: PUSH
82616: LD_INT 0
82618: PUSH
82619: LD_INT 3
82621: NEG
82622: PUSH
82623: EMPTY
82624: LIST
82625: LIST
82626: PUSH
82627: LD_INT 0
82629: PUSH
82630: LD_INT 4
82632: NEG
82633: PUSH
82634: EMPTY
82635: LIST
82636: LIST
82637: PUSH
82638: LD_INT 1
82640: PUSH
82641: LD_INT 3
82643: NEG
82644: PUSH
82645: EMPTY
82646: LIST
82647: LIST
82648: PUSH
82649: LD_INT 1
82651: PUSH
82652: LD_INT 2
82654: NEG
82655: PUSH
82656: EMPTY
82657: LIST
82658: LIST
82659: PUSH
82660: LD_INT 0
82662: PUSH
82663: LD_INT 2
82665: NEG
82666: PUSH
82667: EMPTY
82668: LIST
82669: LIST
82670: PUSH
82671: LD_INT 1
82673: NEG
82674: PUSH
82675: LD_INT 3
82677: NEG
82678: PUSH
82679: EMPTY
82680: LIST
82681: LIST
82682: PUSH
82683: LD_INT 1
82685: NEG
82686: PUSH
82687: LD_INT 4
82689: NEG
82690: PUSH
82691: EMPTY
82692: LIST
82693: LIST
82694: PUSH
82695: LD_INT 2
82697: PUSH
82698: LD_INT 2
82700: NEG
82701: PUSH
82702: EMPTY
82703: LIST
82704: LIST
82705: PUSH
82706: LD_INT 2
82708: NEG
82709: PUSH
82710: LD_INT 4
82712: NEG
82713: PUSH
82714: EMPTY
82715: LIST
82716: LIST
82717: PUSH
82718: LD_INT 4
82720: PUSH
82721: LD_INT 0
82723: PUSH
82724: EMPTY
82725: LIST
82726: LIST
82727: PUSH
82728: LD_INT 4
82730: PUSH
82731: LD_INT 1
82733: NEG
82734: PUSH
82735: EMPTY
82736: LIST
82737: LIST
82738: PUSH
82739: LD_INT 5
82741: PUSH
82742: LD_INT 0
82744: PUSH
82745: EMPTY
82746: LIST
82747: LIST
82748: PUSH
82749: LD_INT 5
82751: PUSH
82752: LD_INT 1
82754: PUSH
82755: EMPTY
82756: LIST
82757: LIST
82758: PUSH
82759: LD_INT 4
82761: PUSH
82762: LD_INT 1
82764: PUSH
82765: EMPTY
82766: LIST
82767: LIST
82768: PUSH
82769: LD_INT 3
82771: PUSH
82772: LD_INT 0
82774: PUSH
82775: EMPTY
82776: LIST
82777: LIST
82778: PUSH
82779: LD_INT 3
82781: PUSH
82782: LD_INT 1
82784: NEG
82785: PUSH
82786: EMPTY
82787: LIST
82788: LIST
82789: PUSH
82790: LD_INT 3
82792: PUSH
82793: LD_INT 2
82795: NEG
82796: PUSH
82797: EMPTY
82798: LIST
82799: LIST
82800: PUSH
82801: LD_INT 5
82803: PUSH
82804: LD_INT 2
82806: PUSH
82807: EMPTY
82808: LIST
82809: LIST
82810: PUSH
82811: LD_INT 3
82813: PUSH
82814: LD_INT 3
82816: PUSH
82817: EMPTY
82818: LIST
82819: LIST
82820: PUSH
82821: LD_INT 3
82823: PUSH
82824: LD_INT 2
82826: PUSH
82827: EMPTY
82828: LIST
82829: LIST
82830: PUSH
82831: LD_INT 4
82833: PUSH
82834: LD_INT 3
82836: PUSH
82837: EMPTY
82838: LIST
82839: LIST
82840: PUSH
82841: LD_INT 4
82843: PUSH
82844: LD_INT 4
82846: PUSH
82847: EMPTY
82848: LIST
82849: LIST
82850: PUSH
82851: LD_INT 3
82853: PUSH
82854: LD_INT 4
82856: PUSH
82857: EMPTY
82858: LIST
82859: LIST
82860: PUSH
82861: LD_INT 2
82863: PUSH
82864: LD_INT 3
82866: PUSH
82867: EMPTY
82868: LIST
82869: LIST
82870: PUSH
82871: LD_INT 2
82873: PUSH
82874: LD_INT 2
82876: PUSH
82877: EMPTY
82878: LIST
82879: LIST
82880: PUSH
82881: LD_INT 4
82883: PUSH
82884: LD_INT 2
82886: PUSH
82887: EMPTY
82888: LIST
82889: LIST
82890: PUSH
82891: LD_INT 2
82893: PUSH
82894: LD_INT 4
82896: PUSH
82897: EMPTY
82898: LIST
82899: LIST
82900: PUSH
82901: LD_INT 0
82903: PUSH
82904: LD_INT 4
82906: PUSH
82907: EMPTY
82908: LIST
82909: LIST
82910: PUSH
82911: LD_INT 0
82913: PUSH
82914: LD_INT 3
82916: PUSH
82917: EMPTY
82918: LIST
82919: LIST
82920: PUSH
82921: LD_INT 1
82923: PUSH
82924: LD_INT 4
82926: PUSH
82927: EMPTY
82928: LIST
82929: LIST
82930: PUSH
82931: LD_INT 1
82933: PUSH
82934: LD_INT 5
82936: PUSH
82937: EMPTY
82938: LIST
82939: LIST
82940: PUSH
82941: LD_INT 0
82943: PUSH
82944: LD_INT 5
82946: PUSH
82947: EMPTY
82948: LIST
82949: LIST
82950: PUSH
82951: LD_INT 1
82953: NEG
82954: PUSH
82955: LD_INT 4
82957: PUSH
82958: EMPTY
82959: LIST
82960: LIST
82961: PUSH
82962: LD_INT 1
82964: NEG
82965: PUSH
82966: LD_INT 3
82968: PUSH
82969: EMPTY
82970: LIST
82971: LIST
82972: PUSH
82973: LD_INT 2
82975: PUSH
82976: LD_INT 5
82978: PUSH
82979: EMPTY
82980: LIST
82981: LIST
82982: PUSH
82983: LD_INT 2
82985: NEG
82986: PUSH
82987: LD_INT 3
82989: PUSH
82990: EMPTY
82991: LIST
82992: LIST
82993: PUSH
82994: EMPTY
82995: LIST
82996: LIST
82997: LIST
82998: LIST
82999: LIST
83000: LIST
83001: LIST
83002: LIST
83003: LIST
83004: LIST
83005: LIST
83006: LIST
83007: LIST
83008: LIST
83009: LIST
83010: LIST
83011: LIST
83012: LIST
83013: LIST
83014: LIST
83015: LIST
83016: LIST
83017: LIST
83018: LIST
83019: LIST
83020: LIST
83021: LIST
83022: LIST
83023: LIST
83024: LIST
83025: LIST
83026: LIST
83027: LIST
83028: LIST
83029: LIST
83030: LIST
83031: LIST
83032: LIST
83033: LIST
83034: LIST
83035: LIST
83036: LIST
83037: LIST
83038: LIST
83039: LIST
83040: ST_TO_ADDR
// Factory5 = [ [ 0 , - 4 ] , [ 0 , - 5 ] , [ 1 , - 4 ] , [ 1 , - 3 ] , [ 0 , - 3 ] , [ - 1 , - 4 ] , [ - 1 , - 5 ] , [ 2 , - 3 ] , [ - 2 , - 5 ] , [ 3 , 0 ] , [ 3 , - 1 ] , [ 4 , 0 ] , [ 4 , 1 ] , [ 3 , 1 ] , [ 2 , 0 ] , [ 2 , - 1 ] , [ 2 , - 2 ] , [ 4 , 2 ] , [ 4 , 4 ] , [ 4 , 3 ] , [ 5 , 4 ] , [ 5 , 5 ] , [ 4 , 5 ] , [ 3 , 4 ] , [ 3 , 3 ] , [ 5 , 3 ] , [ 3 , 5 ] , [ 0 , 3 ] , [ 0 , 2 ] , [ 1 , 3 ] , [ 1 , 4 ] , [ 0 , 4 ] , [ - 1 , 3 ] , [ - 1 , 2 ] , [ 2 , 4 ] , [ - 2 , 2 ] , [ - 4 , 0 ] , [ - 4 , - 1 ] , [ - 3 , 0 ] , [ - 3 , 1 ] , [ - 4 , 1 ] , [ - 5 , 0 ] , [ - 5 , - 1 ] , [ - 5 , - 2 ] , [ - 3 , 2 ] ] ;
83041: LD_ADDR_VAR 0 34
83045: PUSH
83046: LD_INT 0
83048: PUSH
83049: LD_INT 4
83051: NEG
83052: PUSH
83053: EMPTY
83054: LIST
83055: LIST
83056: PUSH
83057: LD_INT 0
83059: PUSH
83060: LD_INT 5
83062: NEG
83063: PUSH
83064: EMPTY
83065: LIST
83066: LIST
83067: PUSH
83068: LD_INT 1
83070: PUSH
83071: LD_INT 4
83073: NEG
83074: PUSH
83075: EMPTY
83076: LIST
83077: LIST
83078: PUSH
83079: LD_INT 1
83081: PUSH
83082: LD_INT 3
83084: NEG
83085: PUSH
83086: EMPTY
83087: LIST
83088: LIST
83089: PUSH
83090: LD_INT 0
83092: PUSH
83093: LD_INT 3
83095: NEG
83096: PUSH
83097: EMPTY
83098: LIST
83099: LIST
83100: PUSH
83101: LD_INT 1
83103: NEG
83104: PUSH
83105: LD_INT 4
83107: NEG
83108: PUSH
83109: EMPTY
83110: LIST
83111: LIST
83112: PUSH
83113: LD_INT 1
83115: NEG
83116: PUSH
83117: LD_INT 5
83119: NEG
83120: PUSH
83121: EMPTY
83122: LIST
83123: LIST
83124: PUSH
83125: LD_INT 2
83127: PUSH
83128: LD_INT 3
83130: NEG
83131: PUSH
83132: EMPTY
83133: LIST
83134: LIST
83135: PUSH
83136: LD_INT 2
83138: NEG
83139: PUSH
83140: LD_INT 5
83142: NEG
83143: PUSH
83144: EMPTY
83145: LIST
83146: LIST
83147: PUSH
83148: LD_INT 3
83150: PUSH
83151: LD_INT 0
83153: PUSH
83154: EMPTY
83155: LIST
83156: LIST
83157: PUSH
83158: LD_INT 3
83160: PUSH
83161: LD_INT 1
83163: NEG
83164: PUSH
83165: EMPTY
83166: LIST
83167: LIST
83168: PUSH
83169: LD_INT 4
83171: PUSH
83172: LD_INT 0
83174: PUSH
83175: EMPTY
83176: LIST
83177: LIST
83178: PUSH
83179: LD_INT 4
83181: PUSH
83182: LD_INT 1
83184: PUSH
83185: EMPTY
83186: LIST
83187: LIST
83188: PUSH
83189: LD_INT 3
83191: PUSH
83192: LD_INT 1
83194: PUSH
83195: EMPTY
83196: LIST
83197: LIST
83198: PUSH
83199: LD_INT 2
83201: PUSH
83202: LD_INT 0
83204: PUSH
83205: EMPTY
83206: LIST
83207: LIST
83208: PUSH
83209: LD_INT 2
83211: PUSH
83212: LD_INT 1
83214: NEG
83215: PUSH
83216: EMPTY
83217: LIST
83218: LIST
83219: PUSH
83220: LD_INT 2
83222: PUSH
83223: LD_INT 2
83225: NEG
83226: PUSH
83227: EMPTY
83228: LIST
83229: LIST
83230: PUSH
83231: LD_INT 4
83233: PUSH
83234: LD_INT 2
83236: PUSH
83237: EMPTY
83238: LIST
83239: LIST
83240: PUSH
83241: LD_INT 4
83243: PUSH
83244: LD_INT 4
83246: PUSH
83247: EMPTY
83248: LIST
83249: LIST
83250: PUSH
83251: LD_INT 4
83253: PUSH
83254: LD_INT 3
83256: PUSH
83257: EMPTY
83258: LIST
83259: LIST
83260: PUSH
83261: LD_INT 5
83263: PUSH
83264: LD_INT 4
83266: PUSH
83267: EMPTY
83268: LIST
83269: LIST
83270: PUSH
83271: LD_INT 5
83273: PUSH
83274: LD_INT 5
83276: PUSH
83277: EMPTY
83278: LIST
83279: LIST
83280: PUSH
83281: LD_INT 4
83283: PUSH
83284: LD_INT 5
83286: PUSH
83287: EMPTY
83288: LIST
83289: LIST
83290: PUSH
83291: LD_INT 3
83293: PUSH
83294: LD_INT 4
83296: PUSH
83297: EMPTY
83298: LIST
83299: LIST
83300: PUSH
83301: LD_INT 3
83303: PUSH
83304: LD_INT 3
83306: PUSH
83307: EMPTY
83308: LIST
83309: LIST
83310: PUSH
83311: LD_INT 5
83313: PUSH
83314: LD_INT 3
83316: PUSH
83317: EMPTY
83318: LIST
83319: LIST
83320: PUSH
83321: LD_INT 3
83323: PUSH
83324: LD_INT 5
83326: PUSH
83327: EMPTY
83328: LIST
83329: LIST
83330: PUSH
83331: LD_INT 0
83333: PUSH
83334: LD_INT 3
83336: PUSH
83337: EMPTY
83338: LIST
83339: LIST
83340: PUSH
83341: LD_INT 0
83343: PUSH
83344: LD_INT 2
83346: PUSH
83347: EMPTY
83348: LIST
83349: LIST
83350: PUSH
83351: LD_INT 1
83353: PUSH
83354: LD_INT 3
83356: PUSH
83357: EMPTY
83358: LIST
83359: LIST
83360: PUSH
83361: LD_INT 1
83363: PUSH
83364: LD_INT 4
83366: PUSH
83367: EMPTY
83368: LIST
83369: LIST
83370: PUSH
83371: LD_INT 0
83373: PUSH
83374: LD_INT 4
83376: PUSH
83377: EMPTY
83378: LIST
83379: LIST
83380: PUSH
83381: LD_INT 1
83383: NEG
83384: PUSH
83385: LD_INT 3
83387: PUSH
83388: EMPTY
83389: LIST
83390: LIST
83391: PUSH
83392: LD_INT 1
83394: NEG
83395: PUSH
83396: LD_INT 2
83398: PUSH
83399: EMPTY
83400: LIST
83401: LIST
83402: PUSH
83403: LD_INT 2
83405: PUSH
83406: LD_INT 4
83408: PUSH
83409: EMPTY
83410: LIST
83411: LIST
83412: PUSH
83413: LD_INT 2
83415: NEG
83416: PUSH
83417: LD_INT 2
83419: PUSH
83420: EMPTY
83421: LIST
83422: LIST
83423: PUSH
83424: LD_INT 4
83426: NEG
83427: PUSH
83428: LD_INT 0
83430: PUSH
83431: EMPTY
83432: LIST
83433: LIST
83434: PUSH
83435: LD_INT 4
83437: NEG
83438: PUSH
83439: LD_INT 1
83441: NEG
83442: PUSH
83443: EMPTY
83444: LIST
83445: LIST
83446: PUSH
83447: LD_INT 3
83449: NEG
83450: PUSH
83451: LD_INT 0
83453: PUSH
83454: EMPTY
83455: LIST
83456: LIST
83457: PUSH
83458: LD_INT 3
83460: NEG
83461: PUSH
83462: LD_INT 1
83464: PUSH
83465: EMPTY
83466: LIST
83467: LIST
83468: PUSH
83469: LD_INT 4
83471: NEG
83472: PUSH
83473: LD_INT 1
83475: PUSH
83476: EMPTY
83477: LIST
83478: LIST
83479: PUSH
83480: LD_INT 5
83482: NEG
83483: PUSH
83484: LD_INT 0
83486: PUSH
83487: EMPTY
83488: LIST
83489: LIST
83490: PUSH
83491: LD_INT 5
83493: NEG
83494: PUSH
83495: LD_INT 1
83497: NEG
83498: PUSH
83499: EMPTY
83500: LIST
83501: LIST
83502: PUSH
83503: LD_INT 5
83505: NEG
83506: PUSH
83507: LD_INT 2
83509: NEG
83510: PUSH
83511: EMPTY
83512: LIST
83513: LIST
83514: PUSH
83515: LD_INT 3
83517: NEG
83518: PUSH
83519: LD_INT 2
83521: PUSH
83522: EMPTY
83523: LIST
83524: LIST
83525: PUSH
83526: EMPTY
83527: LIST
83528: LIST
83529: LIST
83530: LIST
83531: LIST
83532: LIST
83533: LIST
83534: LIST
83535: LIST
83536: LIST
83537: LIST
83538: LIST
83539: LIST
83540: LIST
83541: LIST
83542: LIST
83543: LIST
83544: LIST
83545: LIST
83546: LIST
83547: LIST
83548: LIST
83549: LIST
83550: LIST
83551: LIST
83552: LIST
83553: LIST
83554: LIST
83555: LIST
83556: LIST
83557: LIST
83558: LIST
83559: LIST
83560: LIST
83561: LIST
83562: LIST
83563: LIST
83564: LIST
83565: LIST
83566: LIST
83567: LIST
83568: LIST
83569: LIST
83570: LIST
83571: LIST
83572: ST_TO_ADDR
// end ; end ;
83573: GO 83576
83575: POP
// case btype of b_depot , b_warehouse :
83576: LD_VAR 0 1
83580: PUSH
83581: LD_INT 0
83583: DOUBLE
83584: EQUAL
83585: IFTRUE 83595
83587: LD_INT 1
83589: DOUBLE
83590: EQUAL
83591: IFTRUE 83595
83593: GO 83796
83595: POP
// case nation of nation_american :
83596: LD_VAR 0 5
83600: PUSH
83601: LD_INT 1
83603: DOUBLE
83604: EQUAL
83605: IFTRUE 83609
83607: GO 83665
83609: POP
// temp_list = [ DepotAm0 , DepotAm1 , DepotAm2 , DepotAm3 , DepotAm4 , DepotAm5 ] [ dir + 1 ] ; nation_arabian :
83610: LD_ADDR_VAR 0 9
83614: PUSH
83615: LD_VAR 0 11
83619: PUSH
83620: LD_VAR 0 12
83624: PUSH
83625: LD_VAR 0 13
83629: PUSH
83630: LD_VAR 0 14
83634: PUSH
83635: LD_VAR 0 15
83639: PUSH
83640: LD_VAR 0 16
83644: PUSH
83645: EMPTY
83646: LIST
83647: LIST
83648: LIST
83649: LIST
83650: LIST
83651: LIST
83652: PUSH
83653: LD_VAR 0 4
83657: PUSH
83658: LD_INT 1
83660: PLUS
83661: ARRAY
83662: ST_TO_ADDR
83663: GO 83794
83665: LD_INT 2
83667: DOUBLE
83668: EQUAL
83669: IFTRUE 83673
83671: GO 83729
83673: POP
// temp_list = [ DepotAr0 , DepotAr1 , DepotAr2 , DepotAr3 , DepotAr4 , DepotAr5 ] [ dir + 1 ] ; nation_russian :
83674: LD_ADDR_VAR 0 9
83678: PUSH
83679: LD_VAR 0 17
83683: PUSH
83684: LD_VAR 0 18
83688: PUSH
83689: LD_VAR 0 19
83693: PUSH
83694: LD_VAR 0 20
83698: PUSH
83699: LD_VAR 0 21
83703: PUSH
83704: LD_VAR 0 22
83708: PUSH
83709: EMPTY
83710: LIST
83711: LIST
83712: LIST
83713: LIST
83714: LIST
83715: LIST
83716: PUSH
83717: LD_VAR 0 4
83721: PUSH
83722: LD_INT 1
83724: PLUS
83725: ARRAY
83726: ST_TO_ADDR
83727: GO 83794
83729: LD_INT 3
83731: DOUBLE
83732: EQUAL
83733: IFTRUE 83737
83735: GO 83793
83737: POP
// temp_list = [ DepotRu0 , DepotRu1 , DepotRu2 , DepotRu3 , DepotRu4 , DepotRu5 ] [ dir + 1 ] ; end ; b_workshop , b_factory :
83738: LD_ADDR_VAR 0 9
83742: PUSH
83743: LD_VAR 0 23
83747: PUSH
83748: LD_VAR 0 24
83752: PUSH
83753: LD_VAR 0 25
83757: PUSH
83758: LD_VAR 0 26
83762: PUSH
83763: LD_VAR 0 27
83767: PUSH
83768: LD_VAR 0 28
83772: PUSH
83773: EMPTY
83774: LIST
83775: LIST
83776: LIST
83777: LIST
83778: LIST
83779: LIST
83780: PUSH
83781: LD_VAR 0 4
83785: PUSH
83786: LD_INT 1
83788: PLUS
83789: ARRAY
83790: ST_TO_ADDR
83791: GO 83794
83793: POP
83794: GO 84349
83796: LD_INT 2
83798: DOUBLE
83799: EQUAL
83800: IFTRUE 83810
83802: LD_INT 3
83804: DOUBLE
83805: EQUAL
83806: IFTRUE 83810
83808: GO 83866
83810: POP
// temp_list = [ Factory0 , Factory1 , Factory2 , Factory3 , Factory4 , Factory5 ] [ dir + 1 ] ; b_ext_track , b_ext_gun , b_ext_rocket , b_ext_noncombat , b_ext_radio , b_ext_radar , b_ext_siberium , b_ext_stitch , b_ext_computer , b_ext_laser :
83811: LD_ADDR_VAR 0 9
83815: PUSH
83816: LD_VAR 0 29
83820: PUSH
83821: LD_VAR 0 30
83825: PUSH
83826: LD_VAR 0 31
83830: PUSH
83831: LD_VAR 0 32
83835: PUSH
83836: LD_VAR 0 33
83840: PUSH
83841: LD_VAR 0 34
83845: PUSH
83846: EMPTY
83847: LIST
83848: LIST
83849: LIST
83850: LIST
83851: LIST
83852: LIST
83853: PUSH
83854: LD_VAR 0 4
83858: PUSH
83859: LD_INT 1
83861: PLUS
83862: ARRAY
83863: ST_TO_ADDR
83864: GO 84349
83866: LD_INT 16
83868: DOUBLE
83869: EQUAL
83870: IFTRUE 83928
83872: LD_INT 17
83874: DOUBLE
83875: EQUAL
83876: IFTRUE 83928
83878: LD_INT 18
83880: DOUBLE
83881: EQUAL
83882: IFTRUE 83928
83884: LD_INT 19
83886: DOUBLE
83887: EQUAL
83888: IFTRUE 83928
83890: LD_INT 22
83892: DOUBLE
83893: EQUAL
83894: IFTRUE 83928
83896: LD_INT 20
83898: DOUBLE
83899: EQUAL
83900: IFTRUE 83928
83902: LD_INT 21
83904: DOUBLE
83905: EQUAL
83906: IFTRUE 83928
83908: LD_INT 23
83910: DOUBLE
83911: EQUAL
83912: IFTRUE 83928
83914: LD_INT 24
83916: DOUBLE
83917: EQUAL
83918: IFTRUE 83928
83920: LD_INT 25
83922: DOUBLE
83923: EQUAL
83924: IFTRUE 83928
83926: GO 83984
83928: POP
// temp_list = [ Ext0 , Ext1 , Ext2 , Ext3 , Ext4 , Ext5 ] [ dir + 1 ] ; b_lab , b_lab_half , b_lab_full , b_lab_biological , b_lab_computer , b_lab_opto , b_lab_siberium , b_lab_spacetime , b_lab_weapon :
83929: LD_ADDR_VAR 0 9
83933: PUSH
83934: LD_VAR 0 35
83938: PUSH
83939: LD_VAR 0 36
83943: PUSH
83944: LD_VAR 0 37
83948: PUSH
83949: LD_VAR 0 38
83953: PUSH
83954: LD_VAR 0 39
83958: PUSH
83959: LD_VAR 0 40
83963: PUSH
83964: EMPTY
83965: LIST
83966: LIST
83967: LIST
83968: LIST
83969: LIST
83970: LIST
83971: PUSH
83972: LD_VAR 0 4
83976: PUSH
83977: LD_INT 1
83979: PLUS
83980: ARRAY
83981: ST_TO_ADDR
83982: GO 84349
83984: LD_INT 6
83986: DOUBLE
83987: EQUAL
83988: IFTRUE 84040
83990: LD_INT 7
83992: DOUBLE
83993: EQUAL
83994: IFTRUE 84040
83996: LD_INT 8
83998: DOUBLE
83999: EQUAL
84000: IFTRUE 84040
84002: LD_INT 13
84004: DOUBLE
84005: EQUAL
84006: IFTRUE 84040
84008: LD_INT 12
84010: DOUBLE
84011: EQUAL
84012: IFTRUE 84040
84014: LD_INT 15
84016: DOUBLE
84017: EQUAL
84018: IFTRUE 84040
84020: LD_INT 11
84022: DOUBLE
84023: EQUAL
84024: IFTRUE 84040
84026: LD_INT 14
84028: DOUBLE
84029: EQUAL
84030: IFTRUE 84040
84032: LD_INT 10
84034: DOUBLE
84035: EQUAL
84036: IFTRUE 84040
84038: GO 84096
84040: POP
// temp_list = [ Lab0 , Lab1 , Lab2 , Lab3 , Lab4 , Lab5 ] [ dir + 1 ] ; b_control_tower :
84041: LD_ADDR_VAR 0 9
84045: PUSH
84046: LD_VAR 0 41
84050: PUSH
84051: LD_VAR 0 42
84055: PUSH
84056: LD_VAR 0 43
84060: PUSH
84061: LD_VAR 0 44
84065: PUSH
84066: LD_VAR 0 45
84070: PUSH
84071: LD_VAR 0 46
84075: PUSH
84076: EMPTY
84077: LIST
84078: LIST
84079: LIST
84080: LIST
84081: LIST
84082: LIST
84083: PUSH
84084: LD_VAR 0 4
84088: PUSH
84089: LD_INT 1
84091: PLUS
84092: ARRAY
84093: ST_TO_ADDR
84094: GO 84349
84096: LD_INT 36
84098: DOUBLE
84099: EQUAL
84100: IFTRUE 84104
84102: GO 84160
84104: POP
// temp_list = [ ControlTower0 , ControlTower1 , ControlTower2 , ControlTower3 , ControlTower4 , ControlTower5 ] [ dir + 1 ] ; b_armoury , b_barracks , b_teleport , b_behemoth :
84105: LD_ADDR_VAR 0 9
84109: PUSH
84110: LD_VAR 0 47
84114: PUSH
84115: LD_VAR 0 48
84119: PUSH
84120: LD_VAR 0 49
84124: PUSH
84125: LD_VAR 0 50
84129: PUSH
84130: LD_VAR 0 51
84134: PUSH
84135: LD_VAR 0 52
84139: PUSH
84140: EMPTY
84141: LIST
84142: LIST
84143: LIST
84144: LIST
84145: LIST
84146: LIST
84147: PUSH
84148: LD_VAR 0 4
84152: PUSH
84153: LD_INT 1
84155: PLUS
84156: ARRAY
84157: ST_TO_ADDR
84158: GO 84349
84160: LD_INT 4
84162: DOUBLE
84163: EQUAL
84164: IFTRUE 84186
84166: LD_INT 5
84168: DOUBLE
84169: EQUAL
84170: IFTRUE 84186
84172: LD_INT 34
84174: DOUBLE
84175: EQUAL
84176: IFTRUE 84186
84178: LD_INT 37
84180: DOUBLE
84181: EQUAL
84182: IFTRUE 84186
84184: GO 84242
84186: POP
// temp_list = [ Barracks0 , Barracks1 , Barracks2 , Barracks3 , Barracks4 , Barracks5 ] [ dir + 1 ] ; b_breastwork , b_bunker , b_turret , b_solar_power , b_oil_power , b_siberite_power , b_oil_mine , b_siberite_mine :
84187: LD_ADDR_VAR 0 9
84191: PUSH
84192: LD_VAR 0 53
84196: PUSH
84197: LD_VAR 0 54
84201: PUSH
84202: LD_VAR 0 55
84206: PUSH
84207: LD_VAR 0 56
84211: PUSH
84212: LD_VAR 0 57
84216: PUSH
84217: LD_VAR 0 58
84221: PUSH
84222: EMPTY
84223: LIST
84224: LIST
84225: LIST
84226: LIST
84227: LIST
84228: LIST
84229: PUSH
84230: LD_VAR 0 4
84234: PUSH
84235: LD_INT 1
84237: PLUS
84238: ARRAY
84239: ST_TO_ADDR
84240: GO 84349
84242: LD_INT 31
84244: DOUBLE
84245: EQUAL
84246: IFTRUE 84292
84248: LD_INT 32
84250: DOUBLE
84251: EQUAL
84252: IFTRUE 84292
84254: LD_INT 33
84256: DOUBLE
84257: EQUAL
84258: IFTRUE 84292
84260: LD_INT 27
84262: DOUBLE
84263: EQUAL
84264: IFTRUE 84292
84266: LD_INT 26
84268: DOUBLE
84269: EQUAL
84270: IFTRUE 84292
84272: LD_INT 28
84274: DOUBLE
84275: EQUAL
84276: IFTRUE 84292
84278: LD_INT 29
84280: DOUBLE
84281: EQUAL
84282: IFTRUE 84292
84284: LD_INT 30
84286: DOUBLE
84287: EQUAL
84288: IFTRUE 84292
84290: GO 84348
84292: POP
// temp_list = [ Bunker0 , Bunker1 , Bunker2 , Bunker3 , Bunker4 , Bunker5 ] [ dir + 1 ] ; end ;
84293: LD_ADDR_VAR 0 9
84297: PUSH
84298: LD_VAR 0 59
84302: PUSH
84303: LD_VAR 0 60
84307: PUSH
84308: LD_VAR 0 61
84312: PUSH
84313: LD_VAR 0 62
84317: PUSH
84318: LD_VAR 0 63
84322: PUSH
84323: LD_VAR 0 64
84327: PUSH
84328: EMPTY
84329: LIST
84330: LIST
84331: LIST
84332: LIST
84333: LIST
84334: LIST
84335: PUSH
84336: LD_VAR 0 4
84340: PUSH
84341: LD_INT 1
84343: PLUS
84344: ARRAY
84345: ST_TO_ADDR
84346: GO 84349
84348: POP
// temp_list2 = [ ] ;
84349: LD_ADDR_VAR 0 10
84353: PUSH
84354: EMPTY
84355: ST_TO_ADDR
// for i in temp_list do
84356: LD_ADDR_VAR 0 8
84360: PUSH
84361: LD_VAR 0 9
84365: PUSH
84366: FOR_IN
84367: IFFALSE 84419
// temp_list2 = temp_list2 ^ [ [ i [ 1 ] + x , i [ 2 ] + y ] ] ;
84369: LD_ADDR_VAR 0 10
84373: PUSH
84374: LD_VAR 0 10
84378: PUSH
84379: LD_VAR 0 8
84383: PUSH
84384: LD_INT 1
84386: ARRAY
84387: PUSH
84388: LD_VAR 0 2
84392: PLUS
84393: PUSH
84394: LD_VAR 0 8
84398: PUSH
84399: LD_INT 2
84401: ARRAY
84402: PUSH
84403: LD_VAR 0 3
84407: PLUS
84408: PUSH
84409: EMPTY
84410: LIST
84411: LIST
84412: PUSH
84413: EMPTY
84414: LIST
84415: ADD
84416: ST_TO_ADDR
84417: GO 84366
84419: POP
84420: POP
// result = temp_list2 ;
84421: LD_ADDR_VAR 0 7
84425: PUSH
84426: LD_VAR 0 10
84430: ST_TO_ADDR
// end ;
84431: LD_VAR 0 7
84435: RET
// export function EnemyInRange ( unit , dist ) ; begin
84436: LD_INT 0
84438: PPUSH
// result := DangerAtRangeXY ( GetSide ( unit ) , GetX ( unit ) , GetY ( unit ) , dist ) [ 4 ] ;
84439: LD_ADDR_VAR 0 3
84443: PUSH
84444: LD_VAR 0 1
84448: PPUSH
84449: CALL_OW 255
84453: PPUSH
84454: LD_VAR 0 1
84458: PPUSH
84459: CALL_OW 250
84463: PPUSH
84464: LD_VAR 0 1
84468: PPUSH
84469: CALL_OW 251
84473: PPUSH
84474: LD_VAR 0 2
84478: PPUSH
84479: CALL 58540 0 4
84483: PUSH
84484: LD_INT 4
84486: ARRAY
84487: ST_TO_ADDR
// end ;
84488: LD_VAR 0 3
84492: RET
// export function PlayerSeeMe ( unit ) ; begin
84493: LD_INT 0
84495: PPUSH
// result := See ( your_side , unit ) ;
84496: LD_ADDR_VAR 0 2
84500: PUSH
84501: LD_OWVAR 2
84505: PPUSH
84506: LD_VAR 0 1
84510: PPUSH
84511: CALL_OW 292
84515: ST_TO_ADDR
// end ;
84516: LD_VAR 0 2
84520: RET
// export function ReverseDir ( unit ) ; begin
84521: LD_INT 0
84523: PPUSH
// if not unit then
84524: LD_VAR 0 1
84528: NOT
84529: IFFALSE 84533
// exit ;
84531: GO 84556
// result := ( GetDir ( unit ) + 3 ) mod 6 ;
84533: LD_ADDR_VAR 0 2
84537: PUSH
84538: LD_VAR 0 1
84542: PPUSH
84543: CALL_OW 254
84547: PUSH
84548: LD_INT 3
84550: PLUS
84551: PUSH
84552: LD_INT 6
84554: MOD
84555: ST_TO_ADDR
// end ;
84556: LD_VAR 0 2
84560: RET
// export function GetClosestHex ( unit , hexes ) ; var i , dist , tmp , hex ; begin
84561: LD_INT 0
84563: PPUSH
84564: PPUSH
84565: PPUSH
84566: PPUSH
84567: PPUSH
// if not hexes then
84568: LD_VAR 0 2
84572: NOT
84573: IFFALSE 84577
// exit ;
84575: GO 84725
// dist := 9999 ;
84577: LD_ADDR_VAR 0 5
84581: PUSH
84582: LD_INT 9999
84584: ST_TO_ADDR
// for i = 1 to hexes do
84585: LD_ADDR_VAR 0 4
84589: PUSH
84590: DOUBLE
84591: LD_INT 1
84593: DEC
84594: ST_TO_ADDR
84595: LD_VAR 0 2
84599: PUSH
84600: FOR_TO
84601: IFFALSE 84713
// begin if GetDistUnitXY ( unit , hexes [ i ] [ 1 ] , hexes [ i ] [ 2 ] ) < dist then
84603: LD_VAR 0 1
84607: PPUSH
84608: LD_VAR 0 2
84612: PUSH
84613: LD_VAR 0 4
84617: ARRAY
84618: PUSH
84619: LD_INT 1
84621: ARRAY
84622: PPUSH
84623: LD_VAR 0 2
84627: PUSH
84628: LD_VAR 0 4
84632: ARRAY
84633: PUSH
84634: LD_INT 2
84636: ARRAY
84637: PPUSH
84638: CALL_OW 297
84642: PUSH
84643: LD_VAR 0 5
84647: LESS
84648: IFFALSE 84711
// begin hex := hexes [ i ] ;
84650: LD_ADDR_VAR 0 7
84654: PUSH
84655: LD_VAR 0 2
84659: PUSH
84660: LD_VAR 0 4
84664: ARRAY
84665: ST_TO_ADDR
// dist := GetDistUnitXY ( unit , hexes [ i ] [ 1 ] , hexes [ i ] [ 2 ] ) ;
84666: LD_ADDR_VAR 0 5
84670: PUSH
84671: LD_VAR 0 1
84675: PPUSH
84676: LD_VAR 0 2
84680: PUSH
84681: LD_VAR 0 4
84685: ARRAY
84686: PUSH
84687: LD_INT 1
84689: ARRAY
84690: PPUSH
84691: LD_VAR 0 2
84695: PUSH
84696: LD_VAR 0 4
84700: ARRAY
84701: PUSH
84702: LD_INT 2
84704: ARRAY
84705: PPUSH
84706: CALL_OW 297
84710: ST_TO_ADDR
// end ; end ;
84711: GO 84600
84713: POP
84714: POP
// result := hex ;
84715: LD_ADDR_VAR 0 3
84719: PUSH
84720: LD_VAR 0 7
84724: ST_TO_ADDR
// end ;
84725: LD_VAR 0 3
84729: RET
// export function ComAutodestruct ( unit ) ; var i ; begin
84730: LD_INT 0
84732: PPUSH
84733: PPUSH
// if not unit or not unit in FilterAllUnits ( [ [ f_type , unit_vehicle ] , [ f_nation , 2 ] ] ) then
84734: LD_VAR 0 1
84738: NOT
84739: PUSH
84740: LD_VAR 0 1
84744: PUSH
84745: LD_INT 21
84747: PUSH
84748: LD_INT 2
84750: PUSH
84751: EMPTY
84752: LIST
84753: LIST
84754: PUSH
84755: LD_INT 23
84757: PUSH
84758: LD_INT 2
84760: PUSH
84761: EMPTY
84762: LIST
84763: LIST
84764: PUSH
84765: EMPTY
84766: LIST
84767: LIST
84768: PPUSH
84769: CALL_OW 69
84773: IN
84774: NOT
84775: OR
84776: IFFALSE 84780
// exit ;
84778: GO 84827
// for i = 1 to 3 do
84780: LD_ADDR_VAR 0 3
84784: PUSH
84785: DOUBLE
84786: LD_INT 1
84788: DEC
84789: ST_TO_ADDR
84790: LD_INT 3
84792: PUSH
84793: FOR_TO
84794: IFFALSE 84825
// MineExplosion ( GetX ( unit ) , GetY ( unit ) , 1 ) ;
84796: LD_VAR 0 1
84800: PPUSH
84801: CALL_OW 250
84805: PPUSH
84806: LD_VAR 0 1
84810: PPUSH
84811: CALL_OW 251
84815: PPUSH
84816: LD_INT 1
84818: PPUSH
84819: CALL_OW 453
84823: GO 84793
84825: POP
84826: POP
// end ;
84827: LD_VAR 0 2
84831: RET
// export function AttackHovercraft ( unit , enemy_unit ) ; var i , j , tmp , x , y ; begin
84832: LD_INT 0
84834: PPUSH
84835: PPUSH
84836: PPUSH
84837: PPUSH
84838: PPUSH
84839: PPUSH
// if not unit or not enemy_unit or HasTask ( unit ) then
84840: LD_VAR 0 1
84844: NOT
84845: PUSH
84846: LD_VAR 0 2
84850: NOT
84851: OR
84852: PUSH
84853: LD_VAR 0 1
84857: PPUSH
84858: CALL_OW 314
84862: OR
84863: IFFALSE 84867
// exit ;
84865: GO 85308
// x := GetX ( enemy_unit ) ;
84867: LD_ADDR_VAR 0 7
84871: PUSH
84872: LD_VAR 0 2
84876: PPUSH
84877: CALL_OW 250
84881: ST_TO_ADDR
// y := GetY ( enemy_unit ) ;
84882: LD_ADDR_VAR 0 8
84886: PUSH
84887: LD_VAR 0 2
84891: PPUSH
84892: CALL_OW 251
84896: ST_TO_ADDR
// if not x or not y then
84897: LD_VAR 0 7
84901: NOT
84902: PUSH
84903: LD_VAR 0 8
84907: NOT
84908: OR
84909: IFFALSE 84913
// exit ;
84911: GO 85308
// tmp := [ [ ShiftX ( x , 0 , 4 ) , ShiftY ( y , 0 , 4 ) ] , [ ShiftX ( x , 1 , 4 ) , ShiftY ( y , 1 , 4 ) ] , [ ShiftX ( x , 2 , 4 ) , ShiftY ( y , 2 , 4 ) ] , [ ShiftX ( x , 3 , 4 ) , ShiftY ( y , 3 , 4 ) ] , [ ShiftX ( x , 4 , 4 ) , ShiftY ( y , 4 , 4 ) ] , [ ShiftX ( x , 5 , 4 ) , ShiftY ( y , 5 , 4 ) ] ] ;
84913: LD_ADDR_VAR 0 6
84917: PUSH
84918: LD_VAR 0 7
84922: PPUSH
84923: LD_INT 0
84925: PPUSH
84926: LD_INT 4
84928: PPUSH
84929: CALL_OW 272
84933: PUSH
84934: LD_VAR 0 8
84938: PPUSH
84939: LD_INT 0
84941: PPUSH
84942: LD_INT 4
84944: PPUSH
84945: CALL_OW 273
84949: PUSH
84950: EMPTY
84951: LIST
84952: LIST
84953: PUSH
84954: LD_VAR 0 7
84958: PPUSH
84959: LD_INT 1
84961: PPUSH
84962: LD_INT 4
84964: PPUSH
84965: CALL_OW 272
84969: PUSH
84970: LD_VAR 0 8
84974: PPUSH
84975: LD_INT 1
84977: PPUSH
84978: LD_INT 4
84980: PPUSH
84981: CALL_OW 273
84985: PUSH
84986: EMPTY
84987: LIST
84988: LIST
84989: PUSH
84990: LD_VAR 0 7
84994: PPUSH
84995: LD_INT 2
84997: PPUSH
84998: LD_INT 4
85000: PPUSH
85001: CALL_OW 272
85005: PUSH
85006: LD_VAR 0 8
85010: PPUSH
85011: LD_INT 2
85013: PPUSH
85014: LD_INT 4
85016: PPUSH
85017: CALL_OW 273
85021: PUSH
85022: EMPTY
85023: LIST
85024: LIST
85025: PUSH
85026: LD_VAR 0 7
85030: PPUSH
85031: LD_INT 3
85033: PPUSH
85034: LD_INT 4
85036: PPUSH
85037: CALL_OW 272
85041: PUSH
85042: LD_VAR 0 8
85046: PPUSH
85047: LD_INT 3
85049: PPUSH
85050: LD_INT 4
85052: PPUSH
85053: CALL_OW 273
85057: PUSH
85058: EMPTY
85059: LIST
85060: LIST
85061: PUSH
85062: LD_VAR 0 7
85066: PPUSH
85067: LD_INT 4
85069: PPUSH
85070: LD_INT 4
85072: PPUSH
85073: CALL_OW 272
85077: PUSH
85078: LD_VAR 0 8
85082: PPUSH
85083: LD_INT 4
85085: PPUSH
85086: LD_INT 4
85088: PPUSH
85089: CALL_OW 273
85093: PUSH
85094: EMPTY
85095: LIST
85096: LIST
85097: PUSH
85098: LD_VAR 0 7
85102: PPUSH
85103: LD_INT 5
85105: PPUSH
85106: LD_INT 4
85108: PPUSH
85109: CALL_OW 272
85113: PUSH
85114: LD_VAR 0 8
85118: PPUSH
85119: LD_INT 5
85121: PPUSH
85122: LD_INT 4
85124: PPUSH
85125: CALL_OW 273
85129: PUSH
85130: EMPTY
85131: LIST
85132: LIST
85133: PUSH
85134: EMPTY
85135: LIST
85136: LIST
85137: LIST
85138: LIST
85139: LIST
85140: LIST
85141: ST_TO_ADDR
// for i = tmp downto 1 do
85142: LD_ADDR_VAR 0 4
85146: PUSH
85147: DOUBLE
85148: LD_VAR 0 6
85152: INC
85153: ST_TO_ADDR
85154: LD_INT 1
85156: PUSH
85157: FOR_DOWNTO
85158: IFFALSE 85259
// if not ValidHex ( tmp [ i ] [ 1 ] , tmp [ i ] [ 2 ] ) or HexInfo ( tmp [ i ] [ 1 ] , tmp [ i ] [ 2 ] ) <> 0 then
85160: LD_VAR 0 6
85164: PUSH
85165: LD_VAR 0 4
85169: ARRAY
85170: PUSH
85171: LD_INT 1
85173: ARRAY
85174: PPUSH
85175: LD_VAR 0 6
85179: PUSH
85180: LD_VAR 0 4
85184: ARRAY
85185: PUSH
85186: LD_INT 2
85188: ARRAY
85189: PPUSH
85190: CALL_OW 488
85194: NOT
85195: PUSH
85196: LD_VAR 0 6
85200: PUSH
85201: LD_VAR 0 4
85205: ARRAY
85206: PUSH
85207: LD_INT 1
85209: ARRAY
85210: PPUSH
85211: LD_VAR 0 6
85215: PUSH
85216: LD_VAR 0 4
85220: ARRAY
85221: PUSH
85222: LD_INT 2
85224: ARRAY
85225: PPUSH
85226: CALL_OW 428
85230: PUSH
85231: LD_INT 0
85233: NONEQUAL
85234: OR
85235: IFFALSE 85257
// tmp := Delete ( tmp , i ) ;
85237: LD_ADDR_VAR 0 6
85241: PUSH
85242: LD_VAR 0 6
85246: PPUSH
85247: LD_VAR 0 4
85251: PPUSH
85252: CALL_OW 3
85256: ST_TO_ADDR
85257: GO 85157
85259: POP
85260: POP
// j := GetClosestHex ( unit , tmp ) ;
85261: LD_ADDR_VAR 0 5
85265: PUSH
85266: LD_VAR 0 1
85270: PPUSH
85271: LD_VAR 0 6
85275: PPUSH
85276: CALL 84561 0 2
85280: ST_TO_ADDR
// ComMoveXY ( unit , j [ 1 ] , j [ 2 ] ) ;
85281: LD_VAR 0 1
85285: PPUSH
85286: LD_VAR 0 5
85290: PUSH
85291: LD_INT 1
85293: ARRAY
85294: PPUSH
85295: LD_VAR 0 5
85299: PUSH
85300: LD_INT 2
85302: ARRAY
85303: PPUSH
85304: CALL_OW 111
// end ;
85308: LD_VAR 0 3
85312: RET
// export function PrepareNature ( birds , tigers , apemans , enchidnas , horses , mastodonts , fishes , nat_area , wat_area ) ; var i , animal ; begin
85313: LD_INT 0
85315: PPUSH
85316: PPUSH
85317: PPUSH
// uc_side = 0 ;
85318: LD_ADDR_OWVAR 20
85322: PUSH
85323: LD_INT 0
85325: ST_TO_ADDR
// uc_nation = 0 ;
85326: LD_ADDR_OWVAR 21
85330: PUSH
85331: LD_INT 0
85333: ST_TO_ADDR
// InitHc ;
85334: CALL_OW 19
// InitVc ;
85338: CALL_OW 20
// if mastodonts then
85342: LD_VAR 0 6
85346: IFFALSE 85413
// for i = 1 to mastodonts do
85348: LD_ADDR_VAR 0 11
85352: PUSH
85353: DOUBLE
85354: LD_INT 1
85356: DEC
85357: ST_TO_ADDR
85358: LD_VAR 0 6
85362: PUSH
85363: FOR_TO
85364: IFFALSE 85411
// begin vc_chassis := 31 ;
85366: LD_ADDR_OWVAR 37
85370: PUSH
85371: LD_INT 31
85373: ST_TO_ADDR
// vc_control := control_rider ;
85374: LD_ADDR_OWVAR 38
85378: PUSH
85379: LD_INT 4
85381: ST_TO_ADDR
// animal := CreateVehicle ;
85382: LD_ADDR_VAR 0 12
85386: PUSH
85387: CALL_OW 45
85391: ST_TO_ADDR
// PlaceUnitInArea ( animal , nat_area , false ) ;
85392: LD_VAR 0 12
85396: PPUSH
85397: LD_VAR 0 8
85401: PPUSH
85402: LD_INT 0
85404: PPUSH
85405: CALL 92184 0 3
// end ;
85409: GO 85363
85411: POP
85412: POP
// if horses then
85413: LD_VAR 0 5
85417: IFFALSE 85484
// for i = 1 to horses do
85419: LD_ADDR_VAR 0 11
85423: PUSH
85424: DOUBLE
85425: LD_INT 1
85427: DEC
85428: ST_TO_ADDR
85429: LD_VAR 0 5
85433: PUSH
85434: FOR_TO
85435: IFFALSE 85482
// begin hc_class := 21 ;
85437: LD_ADDR_OWVAR 28
85441: PUSH
85442: LD_INT 21
85444: ST_TO_ADDR
// hc_gallery :=  ;
85445: LD_ADDR_OWVAR 33
85449: PUSH
85450: LD_STRING 
85452: ST_TO_ADDR
// animal := CreateHuman ;
85453: LD_ADDR_VAR 0 12
85457: PUSH
85458: CALL_OW 44
85462: ST_TO_ADDR
// PlaceUnitInArea ( animal , nat_area , false ) ;
85463: LD_VAR 0 12
85467: PPUSH
85468: LD_VAR 0 8
85472: PPUSH
85473: LD_INT 0
85475: PPUSH
85476: CALL 92184 0 3
// end ;
85480: GO 85434
85482: POP
85483: POP
// if birds then
85484: LD_VAR 0 1
85488: IFFALSE 85555
// for i = 1 to birds do
85490: LD_ADDR_VAR 0 11
85494: PUSH
85495: DOUBLE
85496: LD_INT 1
85498: DEC
85499: ST_TO_ADDR
85500: LD_VAR 0 1
85504: PUSH
85505: FOR_TO
85506: IFFALSE 85553
// begin hc_class = 18 ;
85508: LD_ADDR_OWVAR 28
85512: PUSH
85513: LD_INT 18
85515: ST_TO_ADDR
// hc_gallery =  ;
85516: LD_ADDR_OWVAR 33
85520: PUSH
85521: LD_STRING 
85523: ST_TO_ADDR
// animal := CreateHuman ;
85524: LD_ADDR_VAR 0 12
85528: PUSH
85529: CALL_OW 44
85533: ST_TO_ADDR
// PlaceUnitInArea ( animal , nat_area , false ) ;
85534: LD_VAR 0 12
85538: PPUSH
85539: LD_VAR 0 8
85543: PPUSH
85544: LD_INT 0
85546: PPUSH
85547: CALL 92184 0 3
// end ;
85551: GO 85505
85553: POP
85554: POP
// if tigers then
85555: LD_VAR 0 2
85559: IFFALSE 85643
// for i = 1 to tigers do
85561: LD_ADDR_VAR 0 11
85565: PUSH
85566: DOUBLE
85567: LD_INT 1
85569: DEC
85570: ST_TO_ADDR
85571: LD_VAR 0 2
85575: PUSH
85576: FOR_TO
85577: IFFALSE 85641
// begin hc_class = class_tiger ;
85579: LD_ADDR_OWVAR 28
85583: PUSH
85584: LD_INT 14
85586: ST_TO_ADDR
// hc_gallery =  ;
85587: LD_ADDR_OWVAR 33
85591: PUSH
85592: LD_STRING 
85594: ST_TO_ADDR
// hc_agressivity = Rand ( - 7 , 7 ) ;
85595: LD_ADDR_OWVAR 35
85599: PUSH
85600: LD_INT 7
85602: NEG
85603: PPUSH
85604: LD_INT 7
85606: PPUSH
85607: CALL_OW 12
85611: ST_TO_ADDR
// animal := CreateHuman ;
85612: LD_ADDR_VAR 0 12
85616: PUSH
85617: CALL_OW 44
85621: ST_TO_ADDR
// PlaceUnitInArea ( animal , nat_area , false ) ;
85622: LD_VAR 0 12
85626: PPUSH
85627: LD_VAR 0 8
85631: PPUSH
85632: LD_INT 0
85634: PPUSH
85635: CALL 92184 0 3
// end ;
85639: GO 85576
85641: POP
85642: POP
// if apemans then
85643: LD_VAR 0 3
85647: IFFALSE 85770
// for i = 1 to apemans do
85649: LD_ADDR_VAR 0 11
85653: PUSH
85654: DOUBLE
85655: LD_INT 1
85657: DEC
85658: ST_TO_ADDR
85659: LD_VAR 0 3
85663: PUSH
85664: FOR_TO
85665: IFFALSE 85768
// begin hc_class = class_apeman ;
85667: LD_ADDR_OWVAR 28
85671: PUSH
85672: LD_INT 12
85674: ST_TO_ADDR
// hc_gallery =  ;
85675: LD_ADDR_OWVAR 33
85679: PUSH
85680: LD_STRING 
85682: ST_TO_ADDR
// hc_agressivity = rand ( - 5 , 5 ) ;
85683: LD_ADDR_OWVAR 35
85687: PUSH
85688: LD_INT 5
85690: NEG
85691: PPUSH
85692: LD_INT 5
85694: PPUSH
85695: CALL_OW 12
85699: ST_TO_ADDR
// hc_skills := [ rand ( 1 , 3 ) , rand ( 1 , 3 ) , 0 , 0 ] ;
85700: LD_ADDR_OWVAR 31
85704: PUSH
85705: LD_INT 1
85707: PPUSH
85708: LD_INT 3
85710: PPUSH
85711: CALL_OW 12
85715: PUSH
85716: LD_INT 1
85718: PPUSH
85719: LD_INT 3
85721: PPUSH
85722: CALL_OW 12
85726: PUSH
85727: LD_INT 0
85729: PUSH
85730: LD_INT 0
85732: PUSH
85733: EMPTY
85734: LIST
85735: LIST
85736: LIST
85737: LIST
85738: ST_TO_ADDR
// animal := CreateHuman ;
85739: LD_ADDR_VAR 0 12
85743: PUSH
85744: CALL_OW 44
85748: ST_TO_ADDR
// PlaceUnitInArea ( animal , nat_area , false ) ;
85749: LD_VAR 0 12
85753: PPUSH
85754: LD_VAR 0 8
85758: PPUSH
85759: LD_INT 0
85761: PPUSH
85762: CALL 92184 0 3
// end ;
85766: GO 85664
85768: POP
85769: POP
// if enchidnas then
85770: LD_VAR 0 4
85774: IFFALSE 85841
// for i = 1 to enchidnas do
85776: LD_ADDR_VAR 0 11
85780: PUSH
85781: DOUBLE
85782: LD_INT 1
85784: DEC
85785: ST_TO_ADDR
85786: LD_VAR 0 4
85790: PUSH
85791: FOR_TO
85792: IFFALSE 85839
// begin hc_class = 13 ;
85794: LD_ADDR_OWVAR 28
85798: PUSH
85799: LD_INT 13
85801: ST_TO_ADDR
// hc_gallery =  ;
85802: LD_ADDR_OWVAR 33
85806: PUSH
85807: LD_STRING 
85809: ST_TO_ADDR
// animal := CreateHuman ;
85810: LD_ADDR_VAR 0 12
85814: PUSH
85815: CALL_OW 44
85819: ST_TO_ADDR
// PlaceUnitInArea ( animal , nat_area , false ) ;
85820: LD_VAR 0 12
85824: PPUSH
85825: LD_VAR 0 8
85829: PPUSH
85830: LD_INT 0
85832: PPUSH
85833: CALL 92184 0 3
// end ;
85837: GO 85791
85839: POP
85840: POP
// if fishes then
85841: LD_VAR 0 7
85845: IFFALSE 85912
// for i = 1 to fishes do
85847: LD_ADDR_VAR 0 11
85851: PUSH
85852: DOUBLE
85853: LD_INT 1
85855: DEC
85856: ST_TO_ADDR
85857: LD_VAR 0 7
85861: PUSH
85862: FOR_TO
85863: IFFALSE 85910
// begin hc_class = 20 ;
85865: LD_ADDR_OWVAR 28
85869: PUSH
85870: LD_INT 20
85872: ST_TO_ADDR
// hc_gallery =  ;
85873: LD_ADDR_OWVAR 33
85877: PUSH
85878: LD_STRING 
85880: ST_TO_ADDR
// animal := CreateHuman ;
85881: LD_ADDR_VAR 0 12
85885: PUSH
85886: CALL_OW 44
85890: ST_TO_ADDR
// PlaceUnitInArea ( animal , wat_area , false ) ;
85891: LD_VAR 0 12
85895: PPUSH
85896: LD_VAR 0 9
85900: PPUSH
85901: LD_INT 0
85903: PPUSH
85904: CALL 92184 0 3
// end ;
85908: GO 85862
85910: POP
85911: POP
// end ;
85912: LD_VAR 0 10
85916: RET
// export function WantHeal ( sci , unit ) ; begin
85917: LD_INT 0
85919: PPUSH
// if GetTaskList ( sci ) > 0 then
85920: LD_VAR 0 1
85924: PPUSH
85925: CALL_OW 437
85929: PUSH
85930: LD_INT 0
85932: GREATER
85933: IFFALSE 86003
// begin if GetTaskList ( sci ) [ 1 ] [ 1 ] = l and GetTaskList ( sci ) [ 1 ] [ 4 ] = unit then
85935: LD_VAR 0 1
85939: PPUSH
85940: CALL_OW 437
85944: PUSH
85945: LD_INT 1
85947: ARRAY
85948: PUSH
85949: LD_INT 1
85951: ARRAY
85952: PUSH
85953: LD_STRING l
85955: EQUAL
85956: PUSH
85957: LD_VAR 0 1
85961: PPUSH
85962: CALL_OW 437
85966: PUSH
85967: LD_INT 1
85969: ARRAY
85970: PUSH
85971: LD_INT 4
85973: ARRAY
85974: PUSH
85975: LD_VAR 0 2
85979: EQUAL
85980: AND
85981: IFFALSE 85993
// result := true else
85983: LD_ADDR_VAR 0 3
85987: PUSH
85988: LD_INT 1
85990: ST_TO_ADDR
85991: GO 86001
// result := false ;
85993: LD_ADDR_VAR 0 3
85997: PUSH
85998: LD_INT 0
86000: ST_TO_ADDR
// end else
86001: GO 86011
// result := false ;
86003: LD_ADDR_VAR 0 3
86007: PUSH
86008: LD_INT 0
86010: ST_TO_ADDR
// end ;
86011: LD_VAR 0 3
86015: RET
// export function HealTarget ( sci ) ; begin
86016: LD_INT 0
86018: PPUSH
// if not sci then
86019: LD_VAR 0 1
86023: NOT
86024: IFFALSE 86028
// exit ;
86026: GO 86093
// result := 0 ;
86028: LD_ADDR_VAR 0 2
86032: PUSH
86033: LD_INT 0
86035: ST_TO_ADDR
// if GetTaskList ( sci ) then
86036: LD_VAR 0 1
86040: PPUSH
86041: CALL_OW 437
86045: IFFALSE 86093
// if GetTaskList ( sci ) [ 1 ] [ 1 ] = l then
86047: LD_VAR 0 1
86051: PPUSH
86052: CALL_OW 437
86056: PUSH
86057: LD_INT 1
86059: ARRAY
86060: PUSH
86061: LD_INT 1
86063: ARRAY
86064: PUSH
86065: LD_STRING l
86067: EQUAL
86068: IFFALSE 86093
// result := GetTaskList ( sci ) [ 1 ] [ 4 ] ;
86070: LD_ADDR_VAR 0 2
86074: PUSH
86075: LD_VAR 0 1
86079: PPUSH
86080: CALL_OW 437
86084: PUSH
86085: LD_INT 1
86087: ARRAY
86088: PUSH
86089: LD_INT 4
86091: ARRAY
86092: ST_TO_ADDR
// end ;
86093: LD_VAR 0 2
86097: RET
// export function Attack ( list ) ; var base , group , path , flags , i , j , k , x , y , d , z , tmp , tmp2 , units_path , f_ignore_area , f_capture , f_ignore_civ , f_murder , f_mines , f_repair , f_heal , f_spacetime , f_attack_depot , f_crawl , mined , bombed , attacking , to_heal , healers , to_repair , repairs , empty_vehs , side ; begin
86098: LD_INT 0
86100: PPUSH
86101: PPUSH
86102: PPUSH
86103: PPUSH
86104: PPUSH
86105: PPUSH
86106: PPUSH
86107: PPUSH
86108: PPUSH
86109: PPUSH
86110: PPUSH
86111: PPUSH
86112: PPUSH
86113: PPUSH
86114: PPUSH
86115: PPUSH
86116: PPUSH
86117: PPUSH
86118: PPUSH
86119: PPUSH
86120: PPUSH
86121: PPUSH
86122: PPUSH
86123: PPUSH
86124: PPUSH
86125: PPUSH
86126: PPUSH
86127: PPUSH
86128: PPUSH
86129: PPUSH
86130: PPUSH
86131: PPUSH
86132: PPUSH
86133: PPUSH
// if not list then
86134: LD_VAR 0 1
86138: NOT
86139: IFFALSE 86143
// exit ;
86141: GO 90795
// base := list [ 1 ] ;
86143: LD_ADDR_VAR 0 3
86147: PUSH
86148: LD_VAR 0 1
86152: PUSH
86153: LD_INT 1
86155: ARRAY
86156: ST_TO_ADDR
// group := list [ 2 ] ;
86157: LD_ADDR_VAR 0 4
86161: PUSH
86162: LD_VAR 0 1
86166: PUSH
86167: LD_INT 2
86169: ARRAY
86170: ST_TO_ADDR
// path := list [ 3 ] ;
86171: LD_ADDR_VAR 0 5
86175: PUSH
86176: LD_VAR 0 1
86180: PUSH
86181: LD_INT 3
86183: ARRAY
86184: ST_TO_ADDR
// flags := list [ 4 ] ;
86185: LD_ADDR_VAR 0 6
86189: PUSH
86190: LD_VAR 0 1
86194: PUSH
86195: LD_INT 4
86197: ARRAY
86198: ST_TO_ADDR
// mined := [ ] ;
86199: LD_ADDR_VAR 0 27
86203: PUSH
86204: EMPTY
86205: ST_TO_ADDR
// bombed := [ ] ;
86206: LD_ADDR_VAR 0 28
86210: PUSH
86211: EMPTY
86212: ST_TO_ADDR
// healers := [ ] ;
86213: LD_ADDR_VAR 0 31
86217: PUSH
86218: EMPTY
86219: ST_TO_ADDR
// to_heal := [ ] ;
86220: LD_ADDR_VAR 0 30
86224: PUSH
86225: EMPTY
86226: ST_TO_ADDR
// repairs := [ ] ;
86227: LD_ADDR_VAR 0 33
86231: PUSH
86232: EMPTY
86233: ST_TO_ADDR
// to_repair := [ ] ;
86234: LD_ADDR_VAR 0 32
86238: PUSH
86239: EMPTY
86240: ST_TO_ADDR
// if not group or not path then
86241: LD_VAR 0 4
86245: NOT
86246: PUSH
86247: LD_VAR 0 5
86251: NOT
86252: OR
86253: IFFALSE 86257
// exit ;
86255: GO 90795
// side := GetSide ( group [ 1 ] ) ;
86257: LD_ADDR_VAR 0 35
86261: PUSH
86262: LD_VAR 0 4
86266: PUSH
86267: LD_INT 1
86269: ARRAY
86270: PPUSH
86271: CALL_OW 255
86275: ST_TO_ADDR
// if flags then
86276: LD_VAR 0 6
86280: IFFALSE 86424
// begin f_ignore_area := flags [ 1 ] ;
86282: LD_ADDR_VAR 0 17
86286: PUSH
86287: LD_VAR 0 6
86291: PUSH
86292: LD_INT 1
86294: ARRAY
86295: ST_TO_ADDR
// f_capture := flags [ 2 ] ;
86296: LD_ADDR_VAR 0 18
86300: PUSH
86301: LD_VAR 0 6
86305: PUSH
86306: LD_INT 2
86308: ARRAY
86309: ST_TO_ADDR
// f_ignore_civ := flags [ 3 ] ;
86310: LD_ADDR_VAR 0 19
86314: PUSH
86315: LD_VAR 0 6
86319: PUSH
86320: LD_INT 3
86322: ARRAY
86323: ST_TO_ADDR
// f_murder := flags [ 4 ] ;
86324: LD_ADDR_VAR 0 20
86328: PUSH
86329: LD_VAR 0 6
86333: PUSH
86334: LD_INT 4
86336: ARRAY
86337: ST_TO_ADDR
// f_mines := flags [ 5 ] ;
86338: LD_ADDR_VAR 0 21
86342: PUSH
86343: LD_VAR 0 6
86347: PUSH
86348: LD_INT 5
86350: ARRAY
86351: ST_TO_ADDR
// f_repair := flags [ 6 ] ;
86352: LD_ADDR_VAR 0 22
86356: PUSH
86357: LD_VAR 0 6
86361: PUSH
86362: LD_INT 6
86364: ARRAY
86365: ST_TO_ADDR
// f_heal := flags [ 7 ] ;
86366: LD_ADDR_VAR 0 23
86370: PUSH
86371: LD_VAR 0 6
86375: PUSH
86376: LD_INT 7
86378: ARRAY
86379: ST_TO_ADDR
// f_spacetime := flags [ 8 ] ;
86380: LD_ADDR_VAR 0 24
86384: PUSH
86385: LD_VAR 0 6
86389: PUSH
86390: LD_INT 8
86392: ARRAY
86393: ST_TO_ADDR
// f_attack_depot := flags [ 9 ] ;
86394: LD_ADDR_VAR 0 25
86398: PUSH
86399: LD_VAR 0 6
86403: PUSH
86404: LD_INT 9
86406: ARRAY
86407: ST_TO_ADDR
// f_crawl := flags [ 10 ] ;
86408: LD_ADDR_VAR 0 26
86412: PUSH
86413: LD_VAR 0 6
86417: PUSH
86418: LD_INT 10
86420: ARRAY
86421: ST_TO_ADDR
// end else
86422: GO 86504
// begin f_ignore_area := false ;
86424: LD_ADDR_VAR 0 17
86428: PUSH
86429: LD_INT 0
86431: ST_TO_ADDR
// f_capture := false ;
86432: LD_ADDR_VAR 0 18
86436: PUSH
86437: LD_INT 0
86439: ST_TO_ADDR
// f_ignore_civ := false ;
86440: LD_ADDR_VAR 0 19
86444: PUSH
86445: LD_INT 0
86447: ST_TO_ADDR
// f_murder := false ;
86448: LD_ADDR_VAR 0 20
86452: PUSH
86453: LD_INT 0
86455: ST_TO_ADDR
// f_mines := false ;
86456: LD_ADDR_VAR 0 21
86460: PUSH
86461: LD_INT 0
86463: ST_TO_ADDR
// f_repair := false ;
86464: LD_ADDR_VAR 0 22
86468: PUSH
86469: LD_INT 0
86471: ST_TO_ADDR
// f_heal := false ;
86472: LD_ADDR_VAR 0 23
86476: PUSH
86477: LD_INT 0
86479: ST_TO_ADDR
// f_spacetime := false ;
86480: LD_ADDR_VAR 0 24
86484: PUSH
86485: LD_INT 0
86487: ST_TO_ADDR
// f_attack_depot := false ;
86488: LD_ADDR_VAR 0 25
86492: PUSH
86493: LD_INT 0
86495: ST_TO_ADDR
// f_crawl := false ;
86496: LD_ADDR_VAR 0 26
86500: PUSH
86501: LD_INT 0
86503: ST_TO_ADDR
// end ; if f_heal then
86504: LD_VAR 0 23
86508: IFFALSE 86535
// healers := UnitFilter ( group , [ f_class , 4 ] ) ;
86510: LD_ADDR_VAR 0 31
86514: PUSH
86515: LD_VAR 0 4
86519: PPUSH
86520: LD_INT 25
86522: PUSH
86523: LD_INT 4
86525: PUSH
86526: EMPTY
86527: LIST
86528: LIST
86529: PPUSH
86530: CALL_OW 72
86534: ST_TO_ADDR
// if f_repair then
86535: LD_VAR 0 22
86539: IFFALSE 86566
// repairs := UnitFilter ( group , [ f_class , 3 ] ) ;
86541: LD_ADDR_VAR 0 33
86545: PUSH
86546: LD_VAR 0 4
86550: PPUSH
86551: LD_INT 25
86553: PUSH
86554: LD_INT 3
86556: PUSH
86557: EMPTY
86558: LIST
86559: LIST
86560: PPUSH
86561: CALL_OW 72
86565: ST_TO_ADDR
// units_path := [ ] ;
86566: LD_ADDR_VAR 0 16
86570: PUSH
86571: EMPTY
86572: ST_TO_ADDR
// for i = 1 to group do
86573: LD_ADDR_VAR 0 7
86577: PUSH
86578: DOUBLE
86579: LD_INT 1
86581: DEC
86582: ST_TO_ADDR
86583: LD_VAR 0 4
86587: PUSH
86588: FOR_TO
86589: IFFALSE 86618
// units_path := Replace ( units_path , i , path ) ;
86591: LD_ADDR_VAR 0 16
86595: PUSH
86596: LD_VAR 0 16
86600: PPUSH
86601: LD_VAR 0 7
86605: PPUSH
86606: LD_VAR 0 5
86610: PPUSH
86611: CALL_OW 1
86615: ST_TO_ADDR
86616: GO 86588
86618: POP
86619: POP
// repeat for i = group downto 1 do
86620: LD_ADDR_VAR 0 7
86624: PUSH
86625: DOUBLE
86626: LD_VAR 0 4
86630: INC
86631: ST_TO_ADDR
86632: LD_INT 1
86634: PUSH
86635: FOR_DOWNTO
86636: IFFALSE 90758
// begin wait ( 5 ) ;
86638: LD_INT 5
86640: PPUSH
86641: CALL_OW 67
// tmp := [ ] ;
86645: LD_ADDR_VAR 0 14
86649: PUSH
86650: EMPTY
86651: ST_TO_ADDR
// attacking := false ;
86652: LD_ADDR_VAR 0 29
86656: PUSH
86657: LD_INT 0
86659: ST_TO_ADDR
// if IsDead ( group [ i ] ) or not group [ i ] then
86660: LD_VAR 0 4
86664: PUSH
86665: LD_VAR 0 7
86669: ARRAY
86670: PPUSH
86671: CALL_OW 301
86675: PUSH
86676: LD_VAR 0 4
86680: PUSH
86681: LD_VAR 0 7
86685: ARRAY
86686: NOT
86687: OR
86688: IFFALSE 86797
// begin if GetType ( group [ i ] ) = unit_human then
86690: LD_VAR 0 4
86694: PUSH
86695: LD_VAR 0 7
86699: ARRAY
86700: PPUSH
86701: CALL_OW 247
86705: PUSH
86706: LD_INT 1
86708: EQUAL
86709: IFFALSE 86755
// begin to_heal := to_heal diff group [ i ] ;
86711: LD_ADDR_VAR 0 30
86715: PUSH
86716: LD_VAR 0 30
86720: PUSH
86721: LD_VAR 0 4
86725: PUSH
86726: LD_VAR 0 7
86730: ARRAY
86731: DIFF
86732: ST_TO_ADDR
// healers := healers diff group [ i ] ;
86733: LD_ADDR_VAR 0 31
86737: PUSH
86738: LD_VAR 0 31
86742: PUSH
86743: LD_VAR 0 4
86747: PUSH
86748: LD_VAR 0 7
86752: ARRAY
86753: DIFF
86754: ST_TO_ADDR
// end ; group := Delete ( group , i ) ;
86755: LD_ADDR_VAR 0 4
86759: PUSH
86760: LD_VAR 0 4
86764: PPUSH
86765: LD_VAR 0 7
86769: PPUSH
86770: CALL_OW 3
86774: ST_TO_ADDR
// units_path := Delete ( units_path , i ) ;
86775: LD_ADDR_VAR 0 16
86779: PUSH
86780: LD_VAR 0 16
86784: PPUSH
86785: LD_VAR 0 7
86789: PPUSH
86790: CALL_OW 3
86794: ST_TO_ADDR
// continue ;
86795: GO 86635
// end ; if f_repair then
86797: LD_VAR 0 22
86801: IFFALSE 87290
// begin if GetType ( group [ i ] ) = unit_vehicle then
86803: LD_VAR 0 4
86807: PUSH
86808: LD_VAR 0 7
86812: ARRAY
86813: PPUSH
86814: CALL_OW 247
86818: PUSH
86819: LD_INT 2
86821: EQUAL
86822: IFFALSE 87012
// begin if GetLives ( group [ i ] ) < 700 and not group [ i ] in to_repair then
86824: LD_VAR 0 4
86828: PUSH
86829: LD_VAR 0 7
86833: ARRAY
86834: PPUSH
86835: CALL_OW 256
86839: PUSH
86840: LD_INT 700
86842: LESS
86843: PUSH
86844: LD_VAR 0 4
86848: PUSH
86849: LD_VAR 0 7
86853: ARRAY
86854: PUSH
86855: LD_VAR 0 32
86859: IN
86860: NOT
86861: AND
86862: IFFALSE 86886
// to_repair := to_repair union group [ i ] ;
86864: LD_ADDR_VAR 0 32
86868: PUSH
86869: LD_VAR 0 32
86873: PUSH
86874: LD_VAR 0 4
86878: PUSH
86879: LD_VAR 0 7
86883: ARRAY
86884: UNION
86885: ST_TO_ADDR
// if GetLives ( group [ i ] ) = 1000 and group [ i ] in to_repair then
86886: LD_VAR 0 4
86890: PUSH
86891: LD_VAR 0 7
86895: ARRAY
86896: PPUSH
86897: CALL_OW 256
86901: PUSH
86902: LD_INT 1000
86904: EQUAL
86905: PUSH
86906: LD_VAR 0 4
86910: PUSH
86911: LD_VAR 0 7
86915: ARRAY
86916: PUSH
86917: LD_VAR 0 32
86921: IN
86922: AND
86923: IFFALSE 86947
// to_repair := to_repair diff group [ i ] ;
86925: LD_ADDR_VAR 0 32
86929: PUSH
86930: LD_VAR 0 32
86934: PUSH
86935: LD_VAR 0 4
86939: PUSH
86940: LD_VAR 0 7
86944: ARRAY
86945: DIFF
86946: ST_TO_ADDR
// if group [ i ] in to_repair then
86947: LD_VAR 0 4
86951: PUSH
86952: LD_VAR 0 7
86956: ARRAY
86957: PUSH
86958: LD_VAR 0 32
86962: IN
86963: IFFALSE 87010
// begin if not IsInArea ( group [ i ] , f_repair ) then
86965: LD_VAR 0 4
86969: PUSH
86970: LD_VAR 0 7
86974: ARRAY
86975: PPUSH
86976: LD_VAR 0 22
86980: PPUSH
86981: CALL_OW 308
86985: NOT
86986: IFFALSE 87008
// ComMoveToArea ( group [ i ] , f_repair ) ;
86988: LD_VAR 0 4
86992: PUSH
86993: LD_VAR 0 7
86997: ARRAY
86998: PPUSH
86999: LD_VAR 0 22
87003: PPUSH
87004: CALL_OW 113
// continue ;
87008: GO 86635
// end ; end else
87010: GO 87290
// if group [ i ] in repairs then
87012: LD_VAR 0 4
87016: PUSH
87017: LD_VAR 0 7
87021: ARRAY
87022: PUSH
87023: LD_VAR 0 33
87027: IN
87028: IFFALSE 87290
// begin if IsInUnit ( group [ i ] ) then
87030: LD_VAR 0 4
87034: PUSH
87035: LD_VAR 0 7
87039: ARRAY
87040: PPUSH
87041: CALL_OW 310
87045: IFFALSE 87113
// begin z := IsInUnit ( group [ i ] ) ;
87047: LD_ADDR_VAR 0 13
87051: PUSH
87052: LD_VAR 0 4
87056: PUSH
87057: LD_VAR 0 7
87061: ARRAY
87062: PPUSH
87063: CALL_OW 310
87067: ST_TO_ADDR
// if z in to_repair and IsInArea ( z , f_repair ) then
87068: LD_VAR 0 13
87072: PUSH
87073: LD_VAR 0 32
87077: IN
87078: PUSH
87079: LD_VAR 0 13
87083: PPUSH
87084: LD_VAR 0 22
87088: PPUSH
87089: CALL_OW 308
87093: AND
87094: IFFALSE 87111
// ComExitVehicle ( group [ i ] ) ;
87096: LD_VAR 0 4
87100: PUSH
87101: LD_VAR 0 7
87105: ARRAY
87106: PPUSH
87107: CALL_OW 121
// end else
87111: GO 87290
// begin z := UnitFilter ( group , [ [ f_inarea , f_repair ] , [ f_empty ] ] ) ;
87113: LD_ADDR_VAR 0 13
87117: PUSH
87118: LD_VAR 0 4
87122: PPUSH
87123: LD_INT 95
87125: PUSH
87126: LD_VAR 0 22
87130: PUSH
87131: EMPTY
87132: LIST
87133: LIST
87134: PUSH
87135: LD_INT 58
87137: PUSH
87138: EMPTY
87139: LIST
87140: PUSH
87141: EMPTY
87142: LIST
87143: LIST
87144: PPUSH
87145: CALL_OW 72
87149: ST_TO_ADDR
// if not HasTask ( group [ i ] ) then
87150: LD_VAR 0 4
87154: PUSH
87155: LD_VAR 0 7
87159: ARRAY
87160: PPUSH
87161: CALL_OW 314
87165: NOT
87166: IFFALSE 87288
// begin x := NearestUnitToUnit ( z , group [ i ] ) ;
87168: LD_ADDR_VAR 0 10
87172: PUSH
87173: LD_VAR 0 13
87177: PPUSH
87178: LD_VAR 0 4
87182: PUSH
87183: LD_VAR 0 7
87187: ARRAY
87188: PPUSH
87189: CALL_OW 74
87193: ST_TO_ADDR
// if not x then
87194: LD_VAR 0 10
87198: NOT
87199: IFFALSE 87203
// continue ;
87201: GO 86635
// if GetLives ( x ) < 1000 then
87203: LD_VAR 0 10
87207: PPUSH
87208: CALL_OW 256
87212: PUSH
87213: LD_INT 1000
87215: LESS
87216: IFFALSE 87240
// ComRepairVehicle ( group [ i ] , x ) else
87218: LD_VAR 0 4
87222: PUSH
87223: LD_VAR 0 7
87227: ARRAY
87228: PPUSH
87229: LD_VAR 0 10
87233: PPUSH
87234: CALL_OW 129
87238: GO 87288
// if not ( f_heal and GetLives ( group [ i ] ) < 1000 ) then
87240: LD_VAR 0 23
87244: PUSH
87245: LD_VAR 0 4
87249: PUSH
87250: LD_VAR 0 7
87254: ARRAY
87255: PPUSH
87256: CALL_OW 256
87260: PUSH
87261: LD_INT 1000
87263: LESS
87264: AND
87265: NOT
87266: IFFALSE 87288
// ComEnterUnit ( group [ i ] , x ) ;
87268: LD_VAR 0 4
87272: PUSH
87273: LD_VAR 0 7
87277: ARRAY
87278: PPUSH
87279: LD_VAR 0 10
87283: PPUSH
87284: CALL_OW 120
// end ; continue ;
87288: GO 86635
// end ; end ; end ; if f_heal and GetType ( group [ i ] ) = unit_human then
87290: LD_VAR 0 23
87294: PUSH
87295: LD_VAR 0 4
87299: PUSH
87300: LD_VAR 0 7
87304: ARRAY
87305: PPUSH
87306: CALL_OW 247
87310: PUSH
87311: LD_INT 1
87313: EQUAL
87314: AND
87315: IFFALSE 87793
// begin if group [ i ] in healers then
87317: LD_VAR 0 4
87321: PUSH
87322: LD_VAR 0 7
87326: ARRAY
87327: PUSH
87328: LD_VAR 0 31
87332: IN
87333: IFFALSE 87606
// begin if not IsInArea ( group [ i ] , f_heal ) and not HasTask ( group [ i ] ) then
87335: LD_VAR 0 4
87339: PUSH
87340: LD_VAR 0 7
87344: ARRAY
87345: PPUSH
87346: LD_VAR 0 23
87350: PPUSH
87351: CALL_OW 308
87355: NOT
87356: PUSH
87357: LD_VAR 0 4
87361: PUSH
87362: LD_VAR 0 7
87366: ARRAY
87367: PPUSH
87368: CALL_OW 314
87372: NOT
87373: AND
87374: IFFALSE 87398
// ComMoveToArea ( group [ i ] , f_heal ) else
87376: LD_VAR 0 4
87380: PUSH
87381: LD_VAR 0 7
87385: ARRAY
87386: PPUSH
87387: LD_VAR 0 23
87391: PPUSH
87392: CALL_OW 113
87396: GO 87604
// if GetLives ( HealTarget ( group [ i ] ) ) = 1000 then
87398: LD_VAR 0 4
87402: PUSH
87403: LD_VAR 0 7
87407: ARRAY
87408: PPUSH
87409: CALL 86016 0 1
87413: PPUSH
87414: CALL_OW 256
87418: PUSH
87419: LD_INT 1000
87421: EQUAL
87422: IFFALSE 87441
// ComStop ( group [ i ] ) else
87424: LD_VAR 0 4
87428: PUSH
87429: LD_VAR 0 7
87433: ARRAY
87434: PPUSH
87435: CALL_OW 141
87439: GO 87604
// if not HasTask ( group [ i ] ) and to_heal then
87441: LD_VAR 0 4
87445: PUSH
87446: LD_VAR 0 7
87450: ARRAY
87451: PPUSH
87452: CALL_OW 314
87456: NOT
87457: PUSH
87458: LD_VAR 0 30
87462: AND
87463: IFFALSE 87604
// begin z := NearestUnitToUnit ( UnitFilter ( to_heal , [ f_not , [ f_inside ] ] ) , group [ i ] ) ;
87465: LD_ADDR_VAR 0 13
87469: PUSH
87470: LD_VAR 0 30
87474: PPUSH
87475: LD_INT 3
87477: PUSH
87478: LD_INT 54
87480: PUSH
87481: EMPTY
87482: LIST
87483: PUSH
87484: EMPTY
87485: LIST
87486: LIST
87487: PPUSH
87488: CALL_OW 72
87492: PPUSH
87493: LD_VAR 0 4
87497: PUSH
87498: LD_VAR 0 7
87502: ARRAY
87503: PPUSH
87504: CALL_OW 74
87508: ST_TO_ADDR
// if z then
87509: LD_VAR 0 13
87513: IFFALSE 87604
// if FilterAllUnits ( [ [ f_dist , z , 10 ] , [ f_enemy , GetSide ( z ) ] ] ) = 0 then
87515: LD_INT 91
87517: PUSH
87518: LD_VAR 0 13
87522: PUSH
87523: LD_INT 10
87525: PUSH
87526: EMPTY
87527: LIST
87528: LIST
87529: LIST
87530: PUSH
87531: LD_INT 81
87533: PUSH
87534: LD_VAR 0 13
87538: PPUSH
87539: CALL_OW 255
87543: PUSH
87544: EMPTY
87545: LIST
87546: LIST
87547: PUSH
87548: EMPTY
87549: LIST
87550: LIST
87551: PPUSH
87552: CALL_OW 69
87556: PUSH
87557: LD_INT 0
87559: EQUAL
87560: IFFALSE 87584
// ComHeal ( group [ i ] , z ) else
87562: LD_VAR 0 4
87566: PUSH
87567: LD_VAR 0 7
87571: ARRAY
87572: PPUSH
87573: LD_VAR 0 13
87577: PPUSH
87578: CALL_OW 128
87582: GO 87604
// ComMoveToArea ( group [ i ] , f_heal ) ;
87584: LD_VAR 0 4
87588: PUSH
87589: LD_VAR 0 7
87593: ARRAY
87594: PPUSH
87595: LD_VAR 0 23
87599: PPUSH
87600: CALL_OW 113
// end ; continue ;
87604: GO 86635
// end ; if GetLives ( group [ i ] ) < 700 and not group [ i ] in to_heal then
87606: LD_VAR 0 4
87610: PUSH
87611: LD_VAR 0 7
87615: ARRAY
87616: PPUSH
87617: CALL_OW 256
87621: PUSH
87622: LD_INT 700
87624: LESS
87625: PUSH
87626: LD_VAR 0 4
87630: PUSH
87631: LD_VAR 0 7
87635: ARRAY
87636: PUSH
87637: LD_VAR 0 30
87641: IN
87642: NOT
87643: AND
87644: IFFALSE 87668
// to_heal := to_heal union group [ i ] ;
87646: LD_ADDR_VAR 0 30
87650: PUSH
87651: LD_VAR 0 30
87655: PUSH
87656: LD_VAR 0 4
87660: PUSH
87661: LD_VAR 0 7
87665: ARRAY
87666: UNION
87667: ST_TO_ADDR
// if group [ i ] in to_heal then
87668: LD_VAR 0 4
87672: PUSH
87673: LD_VAR 0 7
87677: ARRAY
87678: PUSH
87679: LD_VAR 0 30
87683: IN
87684: IFFALSE 87793
// begin if GetLives ( group [ i ] ) = 1000 then
87686: LD_VAR 0 4
87690: PUSH
87691: LD_VAR 0 7
87695: ARRAY
87696: PPUSH
87697: CALL_OW 256
87701: PUSH
87702: LD_INT 1000
87704: EQUAL
87705: IFFALSE 87731
// to_heal := to_heal diff group [ i ] else
87707: LD_ADDR_VAR 0 30
87711: PUSH
87712: LD_VAR 0 30
87716: PUSH
87717: LD_VAR 0 4
87721: PUSH
87722: LD_VAR 0 7
87726: ARRAY
87727: DIFF
87728: ST_TO_ADDR
87729: GO 87793
// begin if not IsInArea ( group [ i ] , to_heal ) then
87731: LD_VAR 0 4
87735: PUSH
87736: LD_VAR 0 7
87740: ARRAY
87741: PPUSH
87742: LD_VAR 0 30
87746: PPUSH
87747: CALL_OW 308
87751: NOT
87752: IFFALSE 87776
// ComMoveToArea ( group [ i ] , f_heal ) else
87754: LD_VAR 0 4
87758: PUSH
87759: LD_VAR 0 7
87763: ARRAY
87764: PPUSH
87765: LD_VAR 0 23
87769: PPUSH
87770: CALL_OW 113
87774: GO 87791
// ComHold ( group [ i ] ) ;
87776: LD_VAR 0 4
87780: PUSH
87781: LD_VAR 0 7
87785: ARRAY
87786: PPUSH
87787: CALL_OW 140
// continue ;
87791: GO 86635
// end ; end ; end ; if not EnemyInRange ( group [ i ] , 10 ) and not units_path [ i ] = [ ] then
87793: LD_VAR 0 4
87797: PUSH
87798: LD_VAR 0 7
87802: ARRAY
87803: PPUSH
87804: LD_INT 10
87806: PPUSH
87807: CALL 84436 0 2
87811: NOT
87812: PUSH
87813: LD_VAR 0 16
87817: PUSH
87818: LD_VAR 0 7
87822: ARRAY
87823: PUSH
87824: EMPTY
87825: EQUAL
87826: NOT
87827: AND
87828: IFFALSE 88094
// begin if GetEngine ( group [ i ] ) in [ engine_combustion , engine_solar ] then
87830: LD_VAR 0 4
87834: PUSH
87835: LD_VAR 0 7
87839: ARRAY
87840: PPUSH
87841: CALL_OW 262
87845: PUSH
87846: LD_INT 1
87848: PUSH
87849: LD_INT 2
87851: PUSH
87852: EMPTY
87853: LIST
87854: LIST
87855: IN
87856: IFFALSE 87897
// if GetFuel ( group [ i ] ) < 10 then
87858: LD_VAR 0 4
87862: PUSH
87863: LD_VAR 0 7
87867: ARRAY
87868: PPUSH
87869: CALL_OW 261
87873: PUSH
87874: LD_INT 10
87876: LESS
87877: IFFALSE 87897
// SetFuel ( group [ i ] , 12 ) ;
87879: LD_VAR 0 4
87883: PUSH
87884: LD_VAR 0 7
87888: ARRAY
87889: PPUSH
87890: LD_INT 12
87892: PPUSH
87893: CALL_OW 240
// if units_path [ i ] then
87897: LD_VAR 0 16
87901: PUSH
87902: LD_VAR 0 7
87906: ARRAY
87907: IFFALSE 88092
// begin if GetDistUnitXY ( group [ i ] , units_path [ i ] [ 1 ] [ 1 ] , units_path [ i ] [ 1 ] [ 2 ] ) > 6 then
87909: LD_VAR 0 4
87913: PUSH
87914: LD_VAR 0 7
87918: ARRAY
87919: PPUSH
87920: LD_VAR 0 16
87924: PUSH
87925: LD_VAR 0 7
87929: ARRAY
87930: PUSH
87931: LD_INT 1
87933: ARRAY
87934: PUSH
87935: LD_INT 1
87937: ARRAY
87938: PPUSH
87939: LD_VAR 0 16
87943: PUSH
87944: LD_VAR 0 7
87948: ARRAY
87949: PUSH
87950: LD_INT 1
87952: ARRAY
87953: PUSH
87954: LD_INT 2
87956: ARRAY
87957: PPUSH
87958: CALL_OW 297
87962: PUSH
87963: LD_INT 6
87965: GREATER
87966: IFFALSE 88041
// begin if not HasTask ( group [ i ] ) then
87968: LD_VAR 0 4
87972: PUSH
87973: LD_VAR 0 7
87977: ARRAY
87978: PPUSH
87979: CALL_OW 314
87983: NOT
87984: IFFALSE 88039
// ComAgressiveMove ( group [ i ] , units_path [ i ] [ 1 ] [ 1 ] , units_path [ i ] [ 1 ] [ 2 ] ) ;
87986: LD_VAR 0 4
87990: PUSH
87991: LD_VAR 0 7
87995: ARRAY
87996: PPUSH
87997: LD_VAR 0 16
88001: PUSH
88002: LD_VAR 0 7
88006: ARRAY
88007: PUSH
88008: LD_INT 1
88010: ARRAY
88011: PUSH
88012: LD_INT 1
88014: ARRAY
88015: PPUSH
88016: LD_VAR 0 16
88020: PUSH
88021: LD_VAR 0 7
88025: ARRAY
88026: PUSH
88027: LD_INT 1
88029: ARRAY
88030: PUSH
88031: LD_INT 2
88033: ARRAY
88034: PPUSH
88035: CALL_OW 114
// end else
88039: GO 88092
// begin tmp2 := Delete ( units_path [ i ] , 1 ) ;
88041: LD_ADDR_VAR 0 15
88045: PUSH
88046: LD_VAR 0 16
88050: PUSH
88051: LD_VAR 0 7
88055: ARRAY
88056: PPUSH
88057: LD_INT 1
88059: PPUSH
88060: CALL_OW 3
88064: ST_TO_ADDR
// units_path := Replace ( units_path , i , tmp2 ) ;
88065: LD_ADDR_VAR 0 16
88069: PUSH
88070: LD_VAR 0 16
88074: PPUSH
88075: LD_VAR 0 7
88079: PPUSH
88080: LD_VAR 0 15
88084: PPUSH
88085: CALL_OW 1
88089: ST_TO_ADDR
// continue ;
88090: GO 86635
// end ; end ; end else
88092: GO 90756
// begin tmp := FilterAllUnits ( [ f_enemy , GetSide ( group [ i ] ) ] ) ;
88094: LD_ADDR_VAR 0 14
88098: PUSH
88099: LD_INT 81
88101: PUSH
88102: LD_VAR 0 4
88106: PUSH
88107: LD_VAR 0 7
88111: ARRAY
88112: PPUSH
88113: CALL_OW 255
88117: PUSH
88118: EMPTY
88119: LIST
88120: LIST
88121: PPUSH
88122: CALL_OW 69
88126: ST_TO_ADDR
// if not tmp then
88127: LD_VAR 0 14
88131: NOT
88132: IFFALSE 88136
// continue ;
88134: GO 86635
// if f_ignore_area then
88136: LD_VAR 0 17
88140: IFFALSE 88228
// begin tmp2 := UnitFilter ( tmp , [ f_not , [ f_distxy , f_ignore_area [ 1 ] , f_ignore_area [ 2 ] , f_ignore_area [ 3 ] ] ] ) ;
88142: LD_ADDR_VAR 0 15
88146: PUSH
88147: LD_VAR 0 14
88151: PPUSH
88152: LD_INT 3
88154: PUSH
88155: LD_INT 92
88157: PUSH
88158: LD_VAR 0 17
88162: PUSH
88163: LD_INT 1
88165: ARRAY
88166: PUSH
88167: LD_VAR 0 17
88171: PUSH
88172: LD_INT 2
88174: ARRAY
88175: PUSH
88176: LD_VAR 0 17
88180: PUSH
88181: LD_INT 3
88183: ARRAY
88184: PUSH
88185: EMPTY
88186: LIST
88187: LIST
88188: LIST
88189: LIST
88190: PUSH
88191: EMPTY
88192: LIST
88193: LIST
88194: PPUSH
88195: CALL_OW 72
88199: ST_TO_ADDR
// if ( tmp diff tmp2 ) then
88200: LD_VAR 0 14
88204: PUSH
88205: LD_VAR 0 15
88209: DIFF
88210: IFFALSE 88228
// tmp := tmp diff tmp2 ;
88212: LD_ADDR_VAR 0 14
88216: PUSH
88217: LD_VAR 0 14
88221: PUSH
88222: LD_VAR 0 15
88226: DIFF
88227: ST_TO_ADDR
// end ; if not f_murder then
88228: LD_VAR 0 20
88232: NOT
88233: IFFALSE 88291
// begin tmp2 := UnitFilter ( tmp , [ f_not , [ f_ok ] ] ) ;
88235: LD_ADDR_VAR 0 15
88239: PUSH
88240: LD_VAR 0 14
88244: PPUSH
88245: LD_INT 3
88247: PUSH
88248: LD_INT 50
88250: PUSH
88251: EMPTY
88252: LIST
88253: PUSH
88254: EMPTY
88255: LIST
88256: LIST
88257: PPUSH
88258: CALL_OW 72
88262: ST_TO_ADDR
// if ( tmp diff tmp2 ) then
88263: LD_VAR 0 14
88267: PUSH
88268: LD_VAR 0 15
88272: DIFF
88273: IFFALSE 88291
// tmp := tmp diff tmp2 ;
88275: LD_ADDR_VAR 0 14
88279: PUSH
88280: LD_VAR 0 14
88284: PUSH
88285: LD_VAR 0 15
88289: DIFF
88290: ST_TO_ADDR
// end ; tmp := SortByDistanceUnit ( group [ i ] , tmp , true , true ) ;
88291: LD_ADDR_VAR 0 14
88295: PUSH
88296: LD_VAR 0 4
88300: PUSH
88301: LD_VAR 0 7
88305: ARRAY
88306: PPUSH
88307: LD_VAR 0 14
88311: PPUSH
88312: LD_INT 1
88314: PPUSH
88315: LD_INT 1
88317: PPUSH
88318: CALL 58079 0 4
88322: ST_TO_ADDR
// if GetClass ( group [ i ] ) = 1 then
88323: LD_VAR 0 4
88327: PUSH
88328: LD_VAR 0 7
88332: ARRAY
88333: PPUSH
88334: CALL_OW 257
88338: PUSH
88339: LD_INT 1
88341: EQUAL
88342: IFFALSE 88790
// begin if WantPlant ( group [ i ] ) then
88344: LD_VAR 0 4
88348: PUSH
88349: LD_VAR 0 7
88353: ARRAY
88354: PPUSH
88355: CALL 57580 0 1
88359: IFFALSE 88363
// continue ;
88361: GO 86635
// if f_capture and not IsInUnit ( group [ i ] ) and tmp [ 1 ] in UnitFilter ( tmp , [ [ f_type , unit_vehicle ] , [ f_empty ] ] ) then
88363: LD_VAR 0 18
88367: PUSH
88368: LD_VAR 0 4
88372: PUSH
88373: LD_VAR 0 7
88377: ARRAY
88378: PPUSH
88379: CALL_OW 310
88383: NOT
88384: AND
88385: PUSH
88386: LD_VAR 0 14
88390: PUSH
88391: LD_INT 1
88393: ARRAY
88394: PUSH
88395: LD_VAR 0 14
88399: PPUSH
88400: LD_INT 21
88402: PUSH
88403: LD_INT 2
88405: PUSH
88406: EMPTY
88407: LIST
88408: LIST
88409: PUSH
88410: LD_INT 58
88412: PUSH
88413: EMPTY
88414: LIST
88415: PUSH
88416: EMPTY
88417: LIST
88418: LIST
88419: PPUSH
88420: CALL_OW 72
88424: IN
88425: AND
88426: IFFALSE 88462
// begin ComEnterUnit ( group [ i ] , tmp [ 1 ] ) ;
88428: LD_VAR 0 4
88432: PUSH
88433: LD_VAR 0 7
88437: ARRAY
88438: PPUSH
88439: LD_VAR 0 14
88443: PUSH
88444: LD_INT 1
88446: ARRAY
88447: PPUSH
88448: CALL_OW 120
// attacking := true ;
88452: LD_ADDR_VAR 0 29
88456: PUSH
88457: LD_INT 1
88459: ST_TO_ADDR
// continue ;
88460: GO 86635
// end ; if f_crawl and GetClass ( group [ i ] ) = 1 and GetLives ( group [ i ] ) < 800 and not Crawls ( group [ i ] ) then
88462: LD_VAR 0 26
88466: PUSH
88467: LD_VAR 0 4
88471: PUSH
88472: LD_VAR 0 7
88476: ARRAY
88477: PPUSH
88478: CALL_OW 257
88482: PUSH
88483: LD_INT 1
88485: EQUAL
88486: AND
88487: PUSH
88488: LD_VAR 0 4
88492: PUSH
88493: LD_VAR 0 7
88497: ARRAY
88498: PPUSH
88499: CALL_OW 256
88503: PUSH
88504: LD_INT 800
88506: LESS
88507: AND
88508: PUSH
88509: LD_VAR 0 4
88513: PUSH
88514: LD_VAR 0 7
88518: ARRAY
88519: PPUSH
88520: CALL_OW 318
88524: NOT
88525: AND
88526: IFFALSE 88543
// ComCrawl ( group [ i ] ) ;
88528: LD_VAR 0 4
88532: PUSH
88533: LD_VAR 0 7
88537: ARRAY
88538: PPUSH
88539: CALL_OW 137
// if f_mines then
88543: LD_VAR 0 21
88547: IFFALSE 88790
// begin if GetType ( tmp [ 1 ] ) = unit_building and not tmp [ 1 ] in mined then
88549: LD_VAR 0 14
88553: PUSH
88554: LD_INT 1
88556: ARRAY
88557: PPUSH
88558: CALL_OW 247
88562: PUSH
88563: LD_INT 3
88565: EQUAL
88566: PUSH
88567: LD_VAR 0 14
88571: PUSH
88572: LD_INT 1
88574: ARRAY
88575: PUSH
88576: LD_VAR 0 27
88580: IN
88581: NOT
88582: AND
88583: IFFALSE 88790
// begin x := GetX ( tmp [ 1 ] ) ;
88585: LD_ADDR_VAR 0 10
88589: PUSH
88590: LD_VAR 0 14
88594: PUSH
88595: LD_INT 1
88597: ARRAY
88598: PPUSH
88599: CALL_OW 250
88603: ST_TO_ADDR
// y := GetY ( tmp [ 1 ] ) ;
88604: LD_ADDR_VAR 0 11
88608: PUSH
88609: LD_VAR 0 14
88613: PUSH
88614: LD_INT 1
88616: ARRAY
88617: PPUSH
88618: CALL_OW 251
88622: ST_TO_ADDR
// d := ReverseDir ( group [ i ] ) ;
88623: LD_ADDR_VAR 0 12
88627: PUSH
88628: LD_VAR 0 4
88632: PUSH
88633: LD_VAR 0 7
88637: ARRAY
88638: PPUSH
88639: CALL 84521 0 1
88643: ST_TO_ADDR
// ComPlaceDelayedCharge ( group [ i ] , x , y , tmp [ 1 ] ) ;
88644: LD_VAR 0 4
88648: PUSH
88649: LD_VAR 0 7
88653: ARRAY
88654: PPUSH
88655: LD_VAR 0 10
88659: PPUSH
88660: LD_VAR 0 11
88664: PPUSH
88665: LD_VAR 0 14
88669: PUSH
88670: LD_INT 1
88672: ARRAY
88673: PPUSH
88674: CALL_OW 132
// AddComMoveXY ( group [ i ] , ShiftX ( x , d , 7 ) , ShiftY ( y , d , 7 ) ) ;
88678: LD_VAR 0 4
88682: PUSH
88683: LD_VAR 0 7
88687: ARRAY
88688: PPUSH
88689: LD_VAR 0 10
88693: PPUSH
88694: LD_VAR 0 12
88698: PPUSH
88699: LD_INT 7
88701: PPUSH
88702: CALL_OW 272
88706: PPUSH
88707: LD_VAR 0 11
88711: PPUSH
88712: LD_VAR 0 12
88716: PPUSH
88717: LD_INT 7
88719: PPUSH
88720: CALL_OW 273
88724: PPUSH
88725: CALL_OW 171
// SetTag ( group [ i ] , 71 ) ;
88729: LD_VAR 0 4
88733: PUSH
88734: LD_VAR 0 7
88738: ARRAY
88739: PPUSH
88740: LD_INT 71
88742: PPUSH
88743: CALL_OW 109
// mined := Replace ( mined , mined + 1 , tmp [ 1 ] ) ;
88747: LD_ADDR_VAR 0 27
88751: PUSH
88752: LD_VAR 0 27
88756: PPUSH
88757: LD_VAR 0 27
88761: PUSH
88762: LD_INT 1
88764: PLUS
88765: PPUSH
88766: LD_VAR 0 14
88770: PUSH
88771: LD_INT 1
88773: ARRAY
88774: PPUSH
88775: CALL_OW 1
88779: ST_TO_ADDR
// attacking := true ;
88780: LD_ADDR_VAR 0 29
88784: PUSH
88785: LD_INT 1
88787: ST_TO_ADDR
// continue ;
88788: GO 86635
// end ; end ; end ; if GetClass ( group [ i ] ) = 17 and not GetTag ( group [ i ] ) = 71 then
88790: LD_VAR 0 4
88794: PUSH
88795: LD_VAR 0 7
88799: ARRAY
88800: PPUSH
88801: CALL_OW 257
88805: PUSH
88806: LD_INT 17
88808: EQUAL
88809: PUSH
88810: LD_VAR 0 4
88814: PUSH
88815: LD_VAR 0 7
88819: ARRAY
88820: PPUSH
88821: CALL_OW 110
88825: PUSH
88826: LD_INT 71
88828: EQUAL
88829: NOT
88830: AND
88831: IFFALSE 88977
// begin attacking := false ;
88833: LD_ADDR_VAR 0 29
88837: PUSH
88838: LD_INT 0
88840: ST_TO_ADDR
// k := 5 ;
88841: LD_ADDR_VAR 0 9
88845: PUSH
88846: LD_INT 5
88848: ST_TO_ADDR
// if tmp < k then
88849: LD_VAR 0 14
88853: PUSH
88854: LD_VAR 0 9
88858: LESS
88859: IFFALSE 88871
// k := tmp ;
88861: LD_ADDR_VAR 0 9
88865: PUSH
88866: LD_VAR 0 14
88870: ST_TO_ADDR
// for j = 1 to k do
88871: LD_ADDR_VAR 0 8
88875: PUSH
88876: DOUBLE
88877: LD_INT 1
88879: DEC
88880: ST_TO_ADDR
88881: LD_VAR 0 9
88885: PUSH
88886: FOR_TO
88887: IFFALSE 88975
// begin if not tmp [ j ] in UnitFilter ( tmp , [ f_empty ] ) then
88889: LD_VAR 0 14
88893: PUSH
88894: LD_VAR 0 8
88898: ARRAY
88899: PUSH
88900: LD_VAR 0 14
88904: PPUSH
88905: LD_INT 58
88907: PUSH
88908: EMPTY
88909: LIST
88910: PPUSH
88911: CALL_OW 72
88915: IN
88916: NOT
88917: IFFALSE 88973
// begin ComAttackUnit ( group [ i ] , tmp [ j ] ) ;
88919: LD_VAR 0 4
88923: PUSH
88924: LD_VAR 0 7
88928: ARRAY
88929: PPUSH
88930: LD_VAR 0 14
88934: PUSH
88935: LD_VAR 0 8
88939: ARRAY
88940: PPUSH
88941: CALL_OW 115
// attacking := true ;
88945: LD_ADDR_VAR 0 29
88949: PUSH
88950: LD_INT 1
88952: ST_TO_ADDR
// SetTag ( group [ i ] , 71 ) ;
88953: LD_VAR 0 4
88957: PUSH
88958: LD_VAR 0 7
88962: ARRAY
88963: PPUSH
88964: LD_INT 71
88966: PPUSH
88967: CALL_OW 109
// continue ;
88971: GO 88886
// end ; end ;
88973: GO 88886
88975: POP
88976: POP
// end ; if GetClass ( group [ i ] ) = 8 or GetWeapon ( group [ i ] ) in [ ar_rocket_launcher , ru_rocket_launcher , us_rocket_launcher , ru_rocket ] then
88977: LD_VAR 0 4
88981: PUSH
88982: LD_VAR 0 7
88986: ARRAY
88987: PPUSH
88988: CALL_OW 257
88992: PUSH
88993: LD_INT 8
88995: EQUAL
88996: PUSH
88997: LD_VAR 0 4
89001: PUSH
89002: LD_VAR 0 7
89006: ARRAY
89007: PPUSH
89008: CALL_OW 264
89012: PUSH
89013: LD_INT 28
89015: PUSH
89016: LD_INT 45
89018: PUSH
89019: LD_INT 7
89021: PUSH
89022: LD_INT 47
89024: PUSH
89025: EMPTY
89026: LIST
89027: LIST
89028: LIST
89029: LIST
89030: IN
89031: OR
89032: IFFALSE 89288
// begin attacking := false ;
89034: LD_ADDR_VAR 0 29
89038: PUSH
89039: LD_INT 0
89041: ST_TO_ADDR
// if GetBType ( tmp [ 1 ] ) in [ b_bunker , b_breastwork , b_turret , b_armoury , b_barracks ] then
89042: LD_VAR 0 14
89046: PUSH
89047: LD_INT 1
89049: ARRAY
89050: PPUSH
89051: CALL_OW 266
89055: PUSH
89056: LD_INT 32
89058: PUSH
89059: LD_INT 31
89061: PUSH
89062: LD_INT 33
89064: PUSH
89065: LD_INT 4
89067: PUSH
89068: LD_INT 5
89070: PUSH
89071: EMPTY
89072: LIST
89073: LIST
89074: LIST
89075: LIST
89076: LIST
89077: IN
89078: IFFALSE 89264
// begin k := GetBuildingHexes ( GetBType ( tmp [ 1 ] ) , GetX ( tmp [ 1 ] ) , GetY ( tmp [ 1 ] ) , GetDir ( tmp [ 1 ] ) , GetNation ( tmp [ 1 ] ) , 0 ) ;
89080: LD_ADDR_VAR 0 9
89084: PUSH
89085: LD_VAR 0 14
89089: PUSH
89090: LD_INT 1
89092: ARRAY
89093: PPUSH
89094: CALL_OW 266
89098: PPUSH
89099: LD_VAR 0 14
89103: PUSH
89104: LD_INT 1
89106: ARRAY
89107: PPUSH
89108: CALL_OW 250
89112: PPUSH
89113: LD_VAR 0 14
89117: PUSH
89118: LD_INT 1
89120: ARRAY
89121: PPUSH
89122: CALL_OW 251
89126: PPUSH
89127: LD_VAR 0 14
89131: PUSH
89132: LD_INT 1
89134: ARRAY
89135: PPUSH
89136: CALL_OW 254
89140: PPUSH
89141: LD_VAR 0 14
89145: PUSH
89146: LD_INT 1
89148: ARRAY
89149: PPUSH
89150: CALL_OW 248
89154: PPUSH
89155: LD_INT 0
89157: PPUSH
89158: CALL 65891 0 6
89162: ST_TO_ADDR
// j := GetClosestHex ( group [ i ] , k ) ;
89163: LD_ADDR_VAR 0 8
89167: PUSH
89168: LD_VAR 0 4
89172: PUSH
89173: LD_VAR 0 7
89177: ARRAY
89178: PPUSH
89179: LD_VAR 0 9
89183: PPUSH
89184: CALL 84561 0 2
89188: ST_TO_ADDR
// if j then
89189: LD_VAR 0 8
89193: IFFALSE 89262
// if ValidHex ( j [ 1 ] , j [ 2 ] ) then
89195: LD_VAR 0 8
89199: PUSH
89200: LD_INT 1
89202: ARRAY
89203: PPUSH
89204: LD_VAR 0 8
89208: PUSH
89209: LD_INT 2
89211: ARRAY
89212: PPUSH
89213: CALL_OW 488
89217: IFFALSE 89262
// begin ComAttackPlace ( group [ i ] , j [ 1 ] , j [ 2 ] ) ;
89219: LD_VAR 0 4
89223: PUSH
89224: LD_VAR 0 7
89228: ARRAY
89229: PPUSH
89230: LD_VAR 0 8
89234: PUSH
89235: LD_INT 1
89237: ARRAY
89238: PPUSH
89239: LD_VAR 0 8
89243: PUSH
89244: LD_INT 2
89246: ARRAY
89247: PPUSH
89248: CALL_OW 116
// attacking := true ;
89252: LD_ADDR_VAR 0 29
89256: PUSH
89257: LD_INT 1
89259: ST_TO_ADDR
// continue ;
89260: GO 86635
// end ; end else
89262: GO 89288
// ComAttackUnit ( group [ i ] , tmp [ 1 ] ) ;
89264: LD_VAR 0 4
89268: PUSH
89269: LD_VAR 0 7
89273: ARRAY
89274: PPUSH
89275: LD_VAR 0 14
89279: PUSH
89280: LD_INT 1
89282: ARRAY
89283: PPUSH
89284: CALL_OW 115
// end ; if GetChassis ( group [ i ] ) = ar_hovercraft then
89288: LD_VAR 0 4
89292: PUSH
89293: LD_VAR 0 7
89297: ARRAY
89298: PPUSH
89299: CALL_OW 265
89303: PUSH
89304: LD_INT 11
89306: EQUAL
89307: IFFALSE 89585
// begin k := 10 ;
89309: LD_ADDR_VAR 0 9
89313: PUSH
89314: LD_INT 10
89316: ST_TO_ADDR
// x := 0 ;
89317: LD_ADDR_VAR 0 10
89321: PUSH
89322: LD_INT 0
89324: ST_TO_ADDR
// if tmp < k then
89325: LD_VAR 0 14
89329: PUSH
89330: LD_VAR 0 9
89334: LESS
89335: IFFALSE 89347
// k := tmp ;
89337: LD_ADDR_VAR 0 9
89341: PUSH
89342: LD_VAR 0 14
89346: ST_TO_ADDR
// for j = k downto 1 do
89347: LD_ADDR_VAR 0 8
89351: PUSH
89352: DOUBLE
89353: LD_VAR 0 9
89357: INC
89358: ST_TO_ADDR
89359: LD_INT 1
89361: PUSH
89362: FOR_DOWNTO
89363: IFFALSE 89438
// begin if GetType ( tmp [ j ] ) = unit_human then
89365: LD_VAR 0 14
89369: PUSH
89370: LD_VAR 0 8
89374: ARRAY
89375: PPUSH
89376: CALL_OW 247
89380: PUSH
89381: LD_INT 1
89383: EQUAL
89384: IFFALSE 89436
// begin AttackHovercraft ( group [ i ] , tmp [ j ] ) ;
89386: LD_VAR 0 4
89390: PUSH
89391: LD_VAR 0 7
89395: ARRAY
89396: PPUSH
89397: LD_VAR 0 14
89401: PUSH
89402: LD_VAR 0 8
89406: ARRAY
89407: PPUSH
89408: CALL 84832 0 2
// x := tmp [ j ] ;
89412: LD_ADDR_VAR 0 10
89416: PUSH
89417: LD_VAR 0 14
89421: PUSH
89422: LD_VAR 0 8
89426: ARRAY
89427: ST_TO_ADDR
// attacking := true ;
89428: LD_ADDR_VAR 0 29
89432: PUSH
89433: LD_INT 1
89435: ST_TO_ADDR
// end ; end ;
89436: GO 89362
89438: POP
89439: POP
// if not x then
89440: LD_VAR 0 10
89444: NOT
89445: IFFALSE 89585
// begin attacking := true ;
89447: LD_ADDR_VAR 0 29
89451: PUSH
89452: LD_INT 1
89454: ST_TO_ADDR
// if GetHexInfo ( GetX ( group [ i ] ) , GetY ( group [ i ] ) ) [ 2 ] = GetHexInfo ( GetX ( tmp [ 1 ] ) , GetY ( tmp [ 1 ] ) ) [ 2 ] then
89455: LD_VAR 0 4
89459: PUSH
89460: LD_VAR 0 7
89464: ARRAY
89465: PPUSH
89466: CALL_OW 250
89470: PPUSH
89471: LD_VAR 0 4
89475: PUSH
89476: LD_VAR 0 7
89480: ARRAY
89481: PPUSH
89482: CALL_OW 251
89486: PPUSH
89487: CALL_OW 546
89491: PUSH
89492: LD_INT 2
89494: ARRAY
89495: PUSH
89496: LD_VAR 0 14
89500: PUSH
89501: LD_INT 1
89503: ARRAY
89504: PPUSH
89505: CALL_OW 250
89509: PPUSH
89510: LD_VAR 0 14
89514: PUSH
89515: LD_INT 1
89517: ARRAY
89518: PPUSH
89519: CALL_OW 251
89523: PPUSH
89524: CALL_OW 546
89528: PUSH
89529: LD_INT 2
89531: ARRAY
89532: EQUAL
89533: IFFALSE 89561
// AttackHovercraft ( group [ i ] , tmp [ 1 ] ) else
89535: LD_VAR 0 4
89539: PUSH
89540: LD_VAR 0 7
89544: ARRAY
89545: PPUSH
89546: LD_VAR 0 14
89550: PUSH
89551: LD_INT 1
89553: ARRAY
89554: PPUSH
89555: CALL 84832 0 2
89559: GO 89585
// ComAttackUnit ( group [ i ] , tmp [ 1 ] ) ;
89561: LD_VAR 0 4
89565: PUSH
89566: LD_VAR 0 7
89570: ARRAY
89571: PPUSH
89572: LD_VAR 0 14
89576: PUSH
89577: LD_INT 1
89579: ARRAY
89580: PPUSH
89581: CALL_OW 115
// end ; end ; if GetWeapon ( group [ i ] ) = ar_selfpropelled_bomb then
89585: LD_VAR 0 4
89589: PUSH
89590: LD_VAR 0 7
89594: ARRAY
89595: PPUSH
89596: CALL_OW 264
89600: PUSH
89601: LD_INT 29
89603: EQUAL
89604: IFFALSE 89970
// begin if WantsToAttack ( group [ i ] ) in bombed then
89606: LD_VAR 0 4
89610: PUSH
89611: LD_VAR 0 7
89615: ARRAY
89616: PPUSH
89617: CALL_OW 319
89621: PUSH
89622: LD_VAR 0 28
89626: IN
89627: IFFALSE 89631
// continue ;
89629: GO 86635
// k := 8 ;
89631: LD_ADDR_VAR 0 9
89635: PUSH
89636: LD_INT 8
89638: ST_TO_ADDR
// x := 0 ;
89639: LD_ADDR_VAR 0 10
89643: PUSH
89644: LD_INT 0
89646: ST_TO_ADDR
// if tmp < k then
89647: LD_VAR 0 14
89651: PUSH
89652: LD_VAR 0 9
89656: LESS
89657: IFFALSE 89669
// k := tmp ;
89659: LD_ADDR_VAR 0 9
89663: PUSH
89664: LD_VAR 0 14
89668: ST_TO_ADDR
// for j = 1 to k do
89669: LD_ADDR_VAR 0 8
89673: PUSH
89674: DOUBLE
89675: LD_INT 1
89677: DEC
89678: ST_TO_ADDR
89679: LD_VAR 0 9
89683: PUSH
89684: FOR_TO
89685: IFFALSE 89817
// begin if GetType ( tmp [ j ] ) = unit_building then
89687: LD_VAR 0 14
89691: PUSH
89692: LD_VAR 0 8
89696: ARRAY
89697: PPUSH
89698: CALL_OW 247
89702: PUSH
89703: LD_INT 3
89705: EQUAL
89706: IFFALSE 89815
// if not tmp [ j ] in bombed and UnitsInside ( tmp [ j ] ) then
89708: LD_VAR 0 14
89712: PUSH
89713: LD_VAR 0 8
89717: ARRAY
89718: PUSH
89719: LD_VAR 0 28
89723: IN
89724: NOT
89725: PUSH
89726: LD_VAR 0 14
89730: PUSH
89731: LD_VAR 0 8
89735: ARRAY
89736: PPUSH
89737: CALL_OW 313
89741: AND
89742: IFFALSE 89815
// begin ComAttackUnit ( group [ i ] , tmp [ j ] ) ;
89744: LD_VAR 0 4
89748: PUSH
89749: LD_VAR 0 7
89753: ARRAY
89754: PPUSH
89755: LD_VAR 0 14
89759: PUSH
89760: LD_VAR 0 8
89764: ARRAY
89765: PPUSH
89766: CALL_OW 115
// bombed := Replace ( bombed , bombed + 1 , tmp [ j ] ) ;
89770: LD_ADDR_VAR 0 28
89774: PUSH
89775: LD_VAR 0 28
89779: PPUSH
89780: LD_VAR 0 28
89784: PUSH
89785: LD_INT 1
89787: PLUS
89788: PPUSH
89789: LD_VAR 0 14
89793: PUSH
89794: LD_VAR 0 8
89798: ARRAY
89799: PPUSH
89800: CALL_OW 1
89804: ST_TO_ADDR
// attacking := true ;
89805: LD_ADDR_VAR 0 29
89809: PUSH
89810: LD_INT 1
89812: ST_TO_ADDR
// break ;
89813: GO 89817
// end ; end ;
89815: GO 89684
89817: POP
89818: POP
// if not attacking and f_attack_depot then
89819: LD_VAR 0 29
89823: NOT
89824: PUSH
89825: LD_VAR 0 25
89829: AND
89830: IFFALSE 89925
// begin z := UnitFilter ( tmp , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) ;
89832: LD_ADDR_VAR 0 13
89836: PUSH
89837: LD_VAR 0 14
89841: PPUSH
89842: LD_INT 2
89844: PUSH
89845: LD_INT 30
89847: PUSH
89848: LD_INT 0
89850: PUSH
89851: EMPTY
89852: LIST
89853: LIST
89854: PUSH
89855: LD_INT 30
89857: PUSH
89858: LD_INT 1
89860: PUSH
89861: EMPTY
89862: LIST
89863: LIST
89864: PUSH
89865: EMPTY
89866: LIST
89867: LIST
89868: LIST
89869: PPUSH
89870: CALL_OW 72
89874: ST_TO_ADDR
// if z then
89875: LD_VAR 0 13
89879: IFFALSE 89925
// begin ComAttackUnit ( group [ i ] , NearestUnitToUnit ( z , group [ i ] ) ) ;
89881: LD_VAR 0 4
89885: PUSH
89886: LD_VAR 0 7
89890: ARRAY
89891: PPUSH
89892: LD_VAR 0 13
89896: PPUSH
89897: LD_VAR 0 4
89901: PUSH
89902: LD_VAR 0 7
89906: ARRAY
89907: PPUSH
89908: CALL_OW 74
89912: PPUSH
89913: CALL_OW 115
// attacking := true ;
89917: LD_ADDR_VAR 0 29
89921: PUSH
89922: LD_INT 1
89924: ST_TO_ADDR
// end ; end ; if GetLives ( group [ i ] ) < 500 then
89925: LD_VAR 0 4
89929: PUSH
89930: LD_VAR 0 7
89934: ARRAY
89935: PPUSH
89936: CALL_OW 256
89940: PUSH
89941: LD_INT 500
89943: LESS
89944: IFFALSE 89970
// ComAttackUnit ( group [ i ] , tmp [ 1 ] ) ;
89946: LD_VAR 0 4
89950: PUSH
89951: LD_VAR 0 7
89955: ARRAY
89956: PPUSH
89957: LD_VAR 0 14
89961: PUSH
89962: LD_INT 1
89964: ARRAY
89965: PPUSH
89966: CALL_OW 115
// end ; if GetWeapon ( group [ i ] ) = ru_time_lapser then
89970: LD_VAR 0 4
89974: PUSH
89975: LD_VAR 0 7
89979: ARRAY
89980: PPUSH
89981: CALL_OW 264
89985: PUSH
89986: LD_INT 49
89988: EQUAL
89989: IFFALSE 90110
// begin if not HasTask ( group [ i ] ) then
89991: LD_VAR 0 4
89995: PUSH
89996: LD_VAR 0 7
90000: ARRAY
90001: PPUSH
90002: CALL_OW 314
90006: NOT
90007: IFFALSE 90110
// begin k := NearestUnitToUnit ( FilterAllUnits ( [ f_enemy , GetSide ( group [ i ] ) ] ) , group [ i ] ) ;
90009: LD_ADDR_VAR 0 9
90013: PUSH
90014: LD_INT 81
90016: PUSH
90017: LD_VAR 0 4
90021: PUSH
90022: LD_VAR 0 7
90026: ARRAY
90027: PPUSH
90028: CALL_OW 255
90032: PUSH
90033: EMPTY
90034: LIST
90035: LIST
90036: PPUSH
90037: CALL_OW 69
90041: PPUSH
90042: LD_VAR 0 4
90046: PUSH
90047: LD_VAR 0 7
90051: ARRAY
90052: PPUSH
90053: CALL_OW 74
90057: ST_TO_ADDR
// if k then
90058: LD_VAR 0 9
90062: IFFALSE 90110
// if GetDistUnits ( group [ i ] , k ) > 10 then
90064: LD_VAR 0 4
90068: PUSH
90069: LD_VAR 0 7
90073: ARRAY
90074: PPUSH
90075: LD_VAR 0 9
90079: PPUSH
90080: CALL_OW 296
90084: PUSH
90085: LD_INT 10
90087: GREATER
90088: IFFALSE 90110
// ComMoveUnit ( group [ i ] , k ) ;
90090: LD_VAR 0 4
90094: PUSH
90095: LD_VAR 0 7
90099: ARRAY
90100: PPUSH
90101: LD_VAR 0 9
90105: PPUSH
90106: CALL_OW 112
// end ; end ; if GetLives ( group [ i ] ) < 250 and group [ i ] in FilterAllUnits ( [ [ f_type , unit_vehicle ] , [ f_nation , 2 ] ] ) then
90110: LD_VAR 0 4
90114: PUSH
90115: LD_VAR 0 7
90119: ARRAY
90120: PPUSH
90121: CALL_OW 256
90125: PUSH
90126: LD_INT 250
90128: LESS
90129: PUSH
90130: LD_VAR 0 4
90134: PUSH
90135: LD_VAR 0 7
90139: ARRAY
90140: PUSH
90141: LD_INT 21
90143: PUSH
90144: LD_INT 2
90146: PUSH
90147: EMPTY
90148: LIST
90149: LIST
90150: PUSH
90151: LD_INT 23
90153: PUSH
90154: LD_INT 2
90156: PUSH
90157: EMPTY
90158: LIST
90159: LIST
90160: PUSH
90161: EMPTY
90162: LIST
90163: LIST
90164: PPUSH
90165: CALL_OW 69
90169: IN
90170: AND
90171: IFFALSE 90296
// begin k := NearestUnitToUnit ( all_units diff group [ i ] , group [ i ] ) ;
90173: LD_ADDR_VAR 0 9
90177: PUSH
90178: LD_OWVAR 3
90182: PUSH
90183: LD_VAR 0 4
90187: PUSH
90188: LD_VAR 0 7
90192: ARRAY
90193: DIFF
90194: PPUSH
90195: LD_VAR 0 4
90199: PUSH
90200: LD_VAR 0 7
90204: ARRAY
90205: PPUSH
90206: CALL_OW 74
90210: ST_TO_ADDR
// if not k then
90211: LD_VAR 0 9
90215: NOT
90216: IFFALSE 90220
// continue ;
90218: GO 86635
// if k in FilterAllUnits ( [ f_enemy , GetSide ( group [ i ] ) ] ) and GetDistUnits ( k , group [ i ] ) < 5 then
90220: LD_VAR 0 9
90224: PUSH
90225: LD_INT 81
90227: PUSH
90228: LD_VAR 0 4
90232: PUSH
90233: LD_VAR 0 7
90237: ARRAY
90238: PPUSH
90239: CALL_OW 255
90243: PUSH
90244: EMPTY
90245: LIST
90246: LIST
90247: PPUSH
90248: CALL_OW 69
90252: IN
90253: PUSH
90254: LD_VAR 0 9
90258: PPUSH
90259: LD_VAR 0 4
90263: PUSH
90264: LD_VAR 0 7
90268: ARRAY
90269: PPUSH
90270: CALL_OW 296
90274: PUSH
90275: LD_INT 5
90277: LESS
90278: AND
90279: IFFALSE 90296
// ComAutodestruct ( group [ i ] ) ;
90281: LD_VAR 0 4
90285: PUSH
90286: LD_VAR 0 7
90290: ARRAY
90291: PPUSH
90292: CALL 84730 0 1
// end ; if f_attack_depot then
90296: LD_VAR 0 25
90300: IFFALSE 90412
// begin k := 6 ;
90302: LD_ADDR_VAR 0 9
90306: PUSH
90307: LD_INT 6
90309: ST_TO_ADDR
// if tmp < k then
90310: LD_VAR 0 14
90314: PUSH
90315: LD_VAR 0 9
90319: LESS
90320: IFFALSE 90332
// k := tmp ;
90322: LD_ADDR_VAR 0 9
90326: PUSH
90327: LD_VAR 0 14
90331: ST_TO_ADDR
// for j = 1 to k do
90332: LD_ADDR_VAR 0 8
90336: PUSH
90337: DOUBLE
90338: LD_INT 1
90340: DEC
90341: ST_TO_ADDR
90342: LD_VAR 0 9
90346: PUSH
90347: FOR_TO
90348: IFFALSE 90410
// if GetBType ( j ) in [ b_depot , b_warehouse ] then
90350: LD_VAR 0 8
90354: PPUSH
90355: CALL_OW 266
90359: PUSH
90360: LD_INT 0
90362: PUSH
90363: LD_INT 1
90365: PUSH
90366: EMPTY
90367: LIST
90368: LIST
90369: IN
90370: IFFALSE 90408
// begin ComAttackUnit ( group [ i ] , tmp [ j ] ) ;
90372: LD_VAR 0 4
90376: PUSH
90377: LD_VAR 0 7
90381: ARRAY
90382: PPUSH
90383: LD_VAR 0 14
90387: PUSH
90388: LD_VAR 0 8
90392: ARRAY
90393: PPUSH
90394: CALL_OW 115
// attacking := true ;
90398: LD_ADDR_VAR 0 29
90402: PUSH
90403: LD_INT 1
90405: ST_TO_ADDR
// break ;
90406: GO 90410
// end ;
90408: GO 90347
90410: POP
90411: POP
// end ; if IsOk ( group [ i ] ) and not attacking then
90412: LD_VAR 0 4
90416: PUSH
90417: LD_VAR 0 7
90421: ARRAY
90422: PPUSH
90423: CALL_OW 302
90427: PUSH
90428: LD_VAR 0 29
90432: NOT
90433: AND
90434: IFFALSE 90756
// begin if GetTag ( group [ i ] ) = 71 then
90436: LD_VAR 0 4
90440: PUSH
90441: LD_VAR 0 7
90445: ARRAY
90446: PPUSH
90447: CALL_OW 110
90451: PUSH
90452: LD_INT 71
90454: EQUAL
90455: IFFALSE 90496
// begin if HasTask ( group [ i ] ) then
90457: LD_VAR 0 4
90461: PUSH
90462: LD_VAR 0 7
90466: ARRAY
90467: PPUSH
90468: CALL_OW 314
90472: IFFALSE 90478
// continue else
90474: GO 86635
90476: GO 90496
// SetTag ( group [ i ] , 0 ) ;
90478: LD_VAR 0 4
90482: PUSH
90483: LD_VAR 0 7
90487: ARRAY
90488: PPUSH
90489: LD_INT 0
90491: PPUSH
90492: CALL_OW 109
// end ; k := 8 ;
90496: LD_ADDR_VAR 0 9
90500: PUSH
90501: LD_INT 8
90503: ST_TO_ADDR
// x := 0 ;
90504: LD_ADDR_VAR 0 10
90508: PUSH
90509: LD_INT 0
90511: ST_TO_ADDR
// if tmp < k then
90512: LD_VAR 0 14
90516: PUSH
90517: LD_VAR 0 9
90521: LESS
90522: IFFALSE 90534
// k := tmp ;
90524: LD_ADDR_VAR 0 9
90528: PUSH
90529: LD_VAR 0 14
90533: ST_TO_ADDR
// for j = 1 to k do
90534: LD_ADDR_VAR 0 8
90538: PUSH
90539: DOUBLE
90540: LD_INT 1
90542: DEC
90543: ST_TO_ADDR
90544: LD_VAR 0 9
90548: PUSH
90549: FOR_TO
90550: IFFALSE 90648
// if GetType ( tmp [ j ] ) = unit_human and ( ( GetLives ( tmp [ j ] ) < 250 and f_murder ) or ( not f_murder and GetLives ( tmp [ j ] ) >= 250 ) ) then
90552: LD_VAR 0 14
90556: PUSH
90557: LD_VAR 0 8
90561: ARRAY
90562: PPUSH
90563: CALL_OW 247
90567: PUSH
90568: LD_INT 1
90570: EQUAL
90571: PUSH
90572: LD_VAR 0 14
90576: PUSH
90577: LD_VAR 0 8
90581: ARRAY
90582: PPUSH
90583: CALL_OW 256
90587: PUSH
90588: LD_INT 250
90590: LESS
90591: PUSH
90592: LD_VAR 0 20
90596: AND
90597: PUSH
90598: LD_VAR 0 20
90602: NOT
90603: PUSH
90604: LD_VAR 0 14
90608: PUSH
90609: LD_VAR 0 8
90613: ARRAY
90614: PPUSH
90615: CALL_OW 256
90619: PUSH
90620: LD_INT 250
90622: GREATEREQUAL
90623: AND
90624: OR
90625: AND
90626: IFFALSE 90646
// begin x := tmp [ j ] ;
90628: LD_ADDR_VAR 0 10
90632: PUSH
90633: LD_VAR 0 14
90637: PUSH
90638: LD_VAR 0 8
90642: ARRAY
90643: ST_TO_ADDR
// break ;
90644: GO 90648
// end ;
90646: GO 90549
90648: POP
90649: POP
// if x then
90650: LD_VAR 0 10
90654: IFFALSE 90678
// ComAttackUnit ( group [ i ] , x ) else
90656: LD_VAR 0 4
90660: PUSH
90661: LD_VAR 0 7
90665: ARRAY
90666: PPUSH
90667: LD_VAR 0 10
90671: PPUSH
90672: CALL_OW 115
90676: GO 90702
// ComAttackUnit ( group [ i ] , tmp [ 1 ] ) ;
90678: LD_VAR 0 4
90682: PUSH
90683: LD_VAR 0 7
90687: ARRAY
90688: PPUSH
90689: LD_VAR 0 14
90693: PUSH
90694: LD_INT 1
90696: ARRAY
90697: PPUSH
90698: CALL_OW 115
// if not HasTask ( group [ i ] ) then
90702: LD_VAR 0 4
90706: PUSH
90707: LD_VAR 0 7
90711: ARRAY
90712: PPUSH
90713: CALL_OW 314
90717: NOT
90718: IFFALSE 90756
// ComAttackUnit ( group [ i ] , NearestUnitToUnit ( tmp , group [ i ] ) ) ;
90720: LD_VAR 0 4
90724: PUSH
90725: LD_VAR 0 7
90729: ARRAY
90730: PPUSH
90731: LD_VAR 0 14
90735: PPUSH
90736: LD_VAR 0 4
90740: PUSH
90741: LD_VAR 0 7
90745: ARRAY
90746: PPUSH
90747: CALL_OW 74
90751: PPUSH
90752: CALL_OW 115
// end ; end ; end ;
90756: GO 86635
90758: POP
90759: POP
// wait ( 0 0$1 ) ;
90760: LD_INT 35
90762: PPUSH
90763: CALL_OW 67
// until group = [ ] or not FilterAllUnits ( [ f_enemy , side ] ) ;
90767: LD_VAR 0 4
90771: PUSH
90772: EMPTY
90773: EQUAL
90774: PUSH
90775: LD_INT 81
90777: PUSH
90778: LD_VAR 0 35
90782: PUSH
90783: EMPTY
90784: LIST
90785: LIST
90786: PPUSH
90787: CALL_OW 69
90791: NOT
90792: OR
90793: IFFALSE 86620
// end ;
90795: LD_VAR 0 2
90799: RET
// export function _ScanBase ( base_units ) ; var i , t , tmp ; begin
90800: LD_INT 0
90802: PPUSH
90803: PPUSH
90804: PPUSH
90805: PPUSH
// if not base_units then
90806: LD_VAR 0 1
90810: NOT
90811: IFFALSE 90815
// exit ;
90813: GO 90902
// result := false ;
90815: LD_ADDR_VAR 0 2
90819: PUSH
90820: LD_INT 0
90822: ST_TO_ADDR
// tmp := UnitFilter ( base_units , [ f_type , unit_building ] ) ;
90823: LD_ADDR_VAR 0 5
90827: PUSH
90828: LD_VAR 0 1
90832: PPUSH
90833: LD_INT 21
90835: PUSH
90836: LD_INT 3
90838: PUSH
90839: EMPTY
90840: LIST
90841: LIST
90842: PPUSH
90843: CALL_OW 72
90847: ST_TO_ADDR
// if not tmp then
90848: LD_VAR 0 5
90852: NOT
90853: IFFALSE 90857
// exit ;
90855: GO 90902
// for i in tmp do
90857: LD_ADDR_VAR 0 3
90861: PUSH
90862: LD_VAR 0 5
90866: PUSH
90867: FOR_IN
90868: IFFALSE 90900
// begin result := EnemyInRange ( i , 22 ) ;
90870: LD_ADDR_VAR 0 2
90874: PUSH
90875: LD_VAR 0 3
90879: PPUSH
90880: LD_INT 22
90882: PPUSH
90883: CALL 84436 0 2
90887: ST_TO_ADDR
// if result then
90888: LD_VAR 0 2
90892: IFFALSE 90898
// exit ;
90894: POP
90895: POP
90896: GO 90902
// end ;
90898: GO 90867
90900: POP
90901: POP
// end ;
90902: LD_VAR 0 2
90906: RET
// export function FilterByTag ( units , tag ) ; var i ; begin
90907: LD_INT 0
90909: PPUSH
90910: PPUSH
// if not units then
90911: LD_VAR 0 1
90915: NOT
90916: IFFALSE 90920
// exit ;
90918: GO 90990
// result := [ ] ;
90920: LD_ADDR_VAR 0 3
90924: PUSH
90925: EMPTY
90926: ST_TO_ADDR
// for i in units do
90927: LD_ADDR_VAR 0 4
90931: PUSH
90932: LD_VAR 0 1
90936: PUSH
90937: FOR_IN
90938: IFFALSE 90988
// if GetTag ( i ) = tag then
90940: LD_VAR 0 4
90944: PPUSH
90945: CALL_OW 110
90949: PUSH
90950: LD_VAR 0 2
90954: EQUAL
90955: IFFALSE 90986
// result := Insert ( result , result + 1 , i ) ;
90957: LD_ADDR_VAR 0 3
90961: PUSH
90962: LD_VAR 0 3
90966: PPUSH
90967: LD_VAR 0 3
90971: PUSH
90972: LD_INT 1
90974: PLUS
90975: PPUSH
90976: LD_VAR 0 4
90980: PPUSH
90981: CALL_OW 2
90985: ST_TO_ADDR
90986: GO 90937
90988: POP
90989: POP
// end ;
90990: LD_VAR 0 3
90994: RET
// export function IsDriver ( un ) ; begin
90995: LD_INT 0
90997: PPUSH
// result := un in FilterAllUnits ( [ f_driving ] ) ;
90998: LD_ADDR_VAR 0 2
91002: PUSH
91003: LD_VAR 0 1
91007: PUSH
91008: LD_INT 55
91010: PUSH
91011: EMPTY
91012: LIST
91013: PPUSH
91014: CALL_OW 69
91018: IN
91019: ST_TO_ADDR
// end ;
91020: LD_VAR 0 2
91024: RET
// export function GetFacExtXYD ( x , y , d ) ; var list ; begin
91025: LD_INT 0
91027: PPUSH
91028: PPUSH
// list := [ ] ;
91029: LD_ADDR_VAR 0 5
91033: PUSH
91034: EMPTY
91035: ST_TO_ADDR
// case d of 0 :
91036: LD_VAR 0 3
91040: PUSH
91041: LD_INT 0
91043: DOUBLE
91044: EQUAL
91045: IFTRUE 91049
91047: GO 91182
91049: POP
// begin list := [ [ x - 4 , y - 4 , 2 ] , [ x - 3 , y , 1 ] , [ x + 4 , y , 4 ] , [ x + 3 , y + 3 , 5 ] , [ x , y + 4 , 0 ] ] ;
91050: LD_ADDR_VAR 0 5
91054: PUSH
91055: LD_VAR 0 1
91059: PUSH
91060: LD_INT 4
91062: MINUS
91063: PUSH
91064: LD_VAR 0 2
91068: PUSH
91069: LD_INT 4
91071: MINUS
91072: PUSH
91073: LD_INT 2
91075: PUSH
91076: EMPTY
91077: LIST
91078: LIST
91079: LIST
91080: PUSH
91081: LD_VAR 0 1
91085: PUSH
91086: LD_INT 3
91088: MINUS
91089: PUSH
91090: LD_VAR 0 2
91094: PUSH
91095: LD_INT 1
91097: PUSH
91098: EMPTY
91099: LIST
91100: LIST
91101: LIST
91102: PUSH
91103: LD_VAR 0 1
91107: PUSH
91108: LD_INT 4
91110: PLUS
91111: PUSH
91112: LD_VAR 0 2
91116: PUSH
91117: LD_INT 4
91119: PUSH
91120: EMPTY
91121: LIST
91122: LIST
91123: LIST
91124: PUSH
91125: LD_VAR 0 1
91129: PUSH
91130: LD_INT 3
91132: PLUS
91133: PUSH
91134: LD_VAR 0 2
91138: PUSH
91139: LD_INT 3
91141: PLUS
91142: PUSH
91143: LD_INT 5
91145: PUSH
91146: EMPTY
91147: LIST
91148: LIST
91149: LIST
91150: PUSH
91151: LD_VAR 0 1
91155: PUSH
91156: LD_VAR 0 2
91160: PUSH
91161: LD_INT 4
91163: PLUS
91164: PUSH
91165: LD_INT 0
91167: PUSH
91168: EMPTY
91169: LIST
91170: LIST
91171: LIST
91172: PUSH
91173: EMPTY
91174: LIST
91175: LIST
91176: LIST
91177: LIST
91178: LIST
91179: ST_TO_ADDR
// end ; 1 :
91180: GO 91880
91182: LD_INT 1
91184: DOUBLE
91185: EQUAL
91186: IFTRUE 91190
91188: GO 91323
91190: POP
// begin list := [ [ x , y - 4 , 3 ] , [ x - 3 , y - 3 , 2 ] , [ x - 4 , y , 1 ] , [ x , y + 3 , 0 ] , [ x + 4 , y + 4 , 5 ] ] ;
91191: LD_ADDR_VAR 0 5
91195: PUSH
91196: LD_VAR 0 1
91200: PUSH
91201: LD_VAR 0 2
91205: PUSH
91206: LD_INT 4
91208: MINUS
91209: PUSH
91210: LD_INT 3
91212: PUSH
91213: EMPTY
91214: LIST
91215: LIST
91216: LIST
91217: PUSH
91218: LD_VAR 0 1
91222: PUSH
91223: LD_INT 3
91225: MINUS
91226: PUSH
91227: LD_VAR 0 2
91231: PUSH
91232: LD_INT 3
91234: MINUS
91235: PUSH
91236: LD_INT 2
91238: PUSH
91239: EMPTY
91240: LIST
91241: LIST
91242: LIST
91243: PUSH
91244: LD_VAR 0 1
91248: PUSH
91249: LD_INT 4
91251: MINUS
91252: PUSH
91253: LD_VAR 0 2
91257: PUSH
91258: LD_INT 1
91260: PUSH
91261: EMPTY
91262: LIST
91263: LIST
91264: LIST
91265: PUSH
91266: LD_VAR 0 1
91270: PUSH
91271: LD_VAR 0 2
91275: PUSH
91276: LD_INT 3
91278: PLUS
91279: PUSH
91280: LD_INT 0
91282: PUSH
91283: EMPTY
91284: LIST
91285: LIST
91286: LIST
91287: PUSH
91288: LD_VAR 0 1
91292: PUSH
91293: LD_INT 4
91295: PLUS
91296: PUSH
91297: LD_VAR 0 2
91301: PUSH
91302: LD_INT 4
91304: PLUS
91305: PUSH
91306: LD_INT 5
91308: PUSH
91309: EMPTY
91310: LIST
91311: LIST
91312: LIST
91313: PUSH
91314: EMPTY
91315: LIST
91316: LIST
91317: LIST
91318: LIST
91319: LIST
91320: ST_TO_ADDR
// end ; 2 :
91321: GO 91880
91323: LD_INT 2
91325: DOUBLE
91326: EQUAL
91327: IFTRUE 91331
91329: GO 91460
91331: POP
// begin list := [ [ x , y - 3 , 3 ] , [ x + 4 , y , 4 ] , [ x , y + 4 , 0 ] , [ x - 3 , y , 1 ] , [ x - 4 , y - 4 , 2 ] ] ;
91332: LD_ADDR_VAR 0 5
91336: PUSH
91337: LD_VAR 0 1
91341: PUSH
91342: LD_VAR 0 2
91346: PUSH
91347: LD_INT 3
91349: MINUS
91350: PUSH
91351: LD_INT 3
91353: PUSH
91354: EMPTY
91355: LIST
91356: LIST
91357: LIST
91358: PUSH
91359: LD_VAR 0 1
91363: PUSH
91364: LD_INT 4
91366: PLUS
91367: PUSH
91368: LD_VAR 0 2
91372: PUSH
91373: LD_INT 4
91375: PUSH
91376: EMPTY
91377: LIST
91378: LIST
91379: LIST
91380: PUSH
91381: LD_VAR 0 1
91385: PUSH
91386: LD_VAR 0 2
91390: PUSH
91391: LD_INT 4
91393: PLUS
91394: PUSH
91395: LD_INT 0
91397: PUSH
91398: EMPTY
91399: LIST
91400: LIST
91401: LIST
91402: PUSH
91403: LD_VAR 0 1
91407: PUSH
91408: LD_INT 3
91410: MINUS
91411: PUSH
91412: LD_VAR 0 2
91416: PUSH
91417: LD_INT 1
91419: PUSH
91420: EMPTY
91421: LIST
91422: LIST
91423: LIST
91424: PUSH
91425: LD_VAR 0 1
91429: PUSH
91430: LD_INT 4
91432: MINUS
91433: PUSH
91434: LD_VAR 0 2
91438: PUSH
91439: LD_INT 4
91441: MINUS
91442: PUSH
91443: LD_INT 2
91445: PUSH
91446: EMPTY
91447: LIST
91448: LIST
91449: LIST
91450: PUSH
91451: EMPTY
91452: LIST
91453: LIST
91454: LIST
91455: LIST
91456: LIST
91457: ST_TO_ADDR
// end ; 3 :
91458: GO 91880
91460: LD_INT 3
91462: DOUBLE
91463: EQUAL
91464: IFTRUE 91468
91466: GO 91601
91468: POP
// begin list := [ [ x + 3 , y , 4 ] , [ x + 4 , y + 4 , 5 ] , [ x - 4 , y , 1 ] , [ x , y - 4 , 3 ] , [ x - 3 , y - 3 , 2 ] ] ;
91469: LD_ADDR_VAR 0 5
91473: PUSH
91474: LD_VAR 0 1
91478: PUSH
91479: LD_INT 3
91481: PLUS
91482: PUSH
91483: LD_VAR 0 2
91487: PUSH
91488: LD_INT 4
91490: PUSH
91491: EMPTY
91492: LIST
91493: LIST
91494: LIST
91495: PUSH
91496: LD_VAR 0 1
91500: PUSH
91501: LD_INT 4
91503: PLUS
91504: PUSH
91505: LD_VAR 0 2
91509: PUSH
91510: LD_INT 4
91512: PLUS
91513: PUSH
91514: LD_INT 5
91516: PUSH
91517: EMPTY
91518: LIST
91519: LIST
91520: LIST
91521: PUSH
91522: LD_VAR 0 1
91526: PUSH
91527: LD_INT 4
91529: MINUS
91530: PUSH
91531: LD_VAR 0 2
91535: PUSH
91536: LD_INT 1
91538: PUSH
91539: EMPTY
91540: LIST
91541: LIST
91542: LIST
91543: PUSH
91544: LD_VAR 0 1
91548: PUSH
91549: LD_VAR 0 2
91553: PUSH
91554: LD_INT 4
91556: MINUS
91557: PUSH
91558: LD_INT 3
91560: PUSH
91561: EMPTY
91562: LIST
91563: LIST
91564: LIST
91565: PUSH
91566: LD_VAR 0 1
91570: PUSH
91571: LD_INT 3
91573: MINUS
91574: PUSH
91575: LD_VAR 0 2
91579: PUSH
91580: LD_INT 3
91582: MINUS
91583: PUSH
91584: LD_INT 2
91586: PUSH
91587: EMPTY
91588: LIST
91589: LIST
91590: LIST
91591: PUSH
91592: EMPTY
91593: LIST
91594: LIST
91595: LIST
91596: LIST
91597: LIST
91598: ST_TO_ADDR
// end ; 4 :
91599: GO 91880
91601: LD_INT 4
91603: DOUBLE
91604: EQUAL
91605: IFTRUE 91609
91607: GO 91742
91609: POP
// begin list := [ [ x , y + 4 , 0 ] , [ x + 3 , y + 3 , 5 ] , [ x + 4 , y , 4 ] , [ x , y - 3 , 3 ] , [ x - 4 , y - 4 , 2 ] ] ;
91610: LD_ADDR_VAR 0 5
91614: PUSH
91615: LD_VAR 0 1
91619: PUSH
91620: LD_VAR 0 2
91624: PUSH
91625: LD_INT 4
91627: PLUS
91628: PUSH
91629: LD_INT 0
91631: PUSH
91632: EMPTY
91633: LIST
91634: LIST
91635: LIST
91636: PUSH
91637: LD_VAR 0 1
91641: PUSH
91642: LD_INT 3
91644: PLUS
91645: PUSH
91646: LD_VAR 0 2
91650: PUSH
91651: LD_INT 3
91653: PLUS
91654: PUSH
91655: LD_INT 5
91657: PUSH
91658: EMPTY
91659: LIST
91660: LIST
91661: LIST
91662: PUSH
91663: LD_VAR 0 1
91667: PUSH
91668: LD_INT 4
91670: PLUS
91671: PUSH
91672: LD_VAR 0 2
91676: PUSH
91677: LD_INT 4
91679: PUSH
91680: EMPTY
91681: LIST
91682: LIST
91683: LIST
91684: PUSH
91685: LD_VAR 0 1
91689: PUSH
91690: LD_VAR 0 2
91694: PUSH
91695: LD_INT 3
91697: MINUS
91698: PUSH
91699: LD_INT 3
91701: PUSH
91702: EMPTY
91703: LIST
91704: LIST
91705: LIST
91706: PUSH
91707: LD_VAR 0 1
91711: PUSH
91712: LD_INT 4
91714: MINUS
91715: PUSH
91716: LD_VAR 0 2
91720: PUSH
91721: LD_INT 4
91723: MINUS
91724: PUSH
91725: LD_INT 2
91727: PUSH
91728: EMPTY
91729: LIST
91730: LIST
91731: LIST
91732: PUSH
91733: EMPTY
91734: LIST
91735: LIST
91736: LIST
91737: LIST
91738: LIST
91739: ST_TO_ADDR
// end ; 5 :
91740: GO 91880
91742: LD_INT 5
91744: DOUBLE
91745: EQUAL
91746: IFTRUE 91750
91748: GO 91879
91750: POP
// begin list := [ [ x - 4 , y , 1 ] , [ x , y - 4 , 3 ] , [ x + 4 , y + 4 , 5 ] , [ x + 3 , y , 4 ] , [ x , y + 3 , 0 ] ] ;
91751: LD_ADDR_VAR 0 5
91755: PUSH
91756: LD_VAR 0 1
91760: PUSH
91761: LD_INT 4
91763: MINUS
91764: PUSH
91765: LD_VAR 0 2
91769: PUSH
91770: LD_INT 1
91772: PUSH
91773: EMPTY
91774: LIST
91775: LIST
91776: LIST
91777: PUSH
91778: LD_VAR 0 1
91782: PUSH
91783: LD_VAR 0 2
91787: PUSH
91788: LD_INT 4
91790: MINUS
91791: PUSH
91792: LD_INT 3
91794: PUSH
91795: EMPTY
91796: LIST
91797: LIST
91798: LIST
91799: PUSH
91800: LD_VAR 0 1
91804: PUSH
91805: LD_INT 4
91807: PLUS
91808: PUSH
91809: LD_VAR 0 2
91813: PUSH
91814: LD_INT 4
91816: PLUS
91817: PUSH
91818: LD_INT 5
91820: PUSH
91821: EMPTY
91822: LIST
91823: LIST
91824: LIST
91825: PUSH
91826: LD_VAR 0 1
91830: PUSH
91831: LD_INT 3
91833: PLUS
91834: PUSH
91835: LD_VAR 0 2
91839: PUSH
91840: LD_INT 4
91842: PUSH
91843: EMPTY
91844: LIST
91845: LIST
91846: LIST
91847: PUSH
91848: LD_VAR 0 1
91852: PUSH
91853: LD_VAR 0 2
91857: PUSH
91858: LD_INT 3
91860: PLUS
91861: PUSH
91862: LD_INT 0
91864: PUSH
91865: EMPTY
91866: LIST
91867: LIST
91868: LIST
91869: PUSH
91870: EMPTY
91871: LIST
91872: LIST
91873: LIST
91874: LIST
91875: LIST
91876: ST_TO_ADDR
// end ; end ;
91877: GO 91880
91879: POP
// result := list ;
91880: LD_ADDR_VAR 0 4
91884: PUSH
91885: LD_VAR 0 5
91889: ST_TO_ADDR
// end ;
91890: LD_VAR 0 4
91894: RET
// export function SortBySkill ( units , class ) ; var i , tmp ; begin
91895: LD_INT 0
91897: PPUSH
91898: PPUSH
91899: PPUSH
// if not units or not class in [ 1 , 2 , 3 , 4 ] then
91900: LD_VAR 0 1
91904: NOT
91905: PUSH
91906: LD_VAR 0 2
91910: PUSH
91911: LD_INT 1
91913: PUSH
91914: LD_INT 2
91916: PUSH
91917: LD_INT 3
91919: PUSH
91920: LD_INT 4
91922: PUSH
91923: EMPTY
91924: LIST
91925: LIST
91926: LIST
91927: LIST
91928: IN
91929: NOT
91930: OR
91931: IFFALSE 91935
// exit ;
91933: GO 92027
// tmp := [ ] ;
91935: LD_ADDR_VAR 0 5
91939: PUSH
91940: EMPTY
91941: ST_TO_ADDR
// for i in units do
91942: LD_ADDR_VAR 0 4
91946: PUSH
91947: LD_VAR 0 1
91951: PUSH
91952: FOR_IN
91953: IFFALSE 91996
// tmp := Insert ( tmp , tmp + 1 , GetSkill ( i , class ) ) ;
91955: LD_ADDR_VAR 0 5
91959: PUSH
91960: LD_VAR 0 5
91964: PPUSH
91965: LD_VAR 0 5
91969: PUSH
91970: LD_INT 1
91972: PLUS
91973: PPUSH
91974: LD_VAR 0 4
91978: PPUSH
91979: LD_VAR 0 2
91983: PPUSH
91984: CALL_OW 259
91988: PPUSH
91989: CALL_OW 2
91993: ST_TO_ADDR
91994: GO 91952
91996: POP
91997: POP
// if not tmp then
91998: LD_VAR 0 5
92002: NOT
92003: IFFALSE 92007
// exit ;
92005: GO 92027
// result := SortListByListDesc ( units , tmp ) ;
92007: LD_ADDR_VAR 0 3
92011: PUSH
92012: LD_VAR 0 1
92016: PPUSH
92017: LD_VAR 0 5
92021: PPUSH
92022: CALL_OW 77
92026: ST_TO_ADDR
// end ;
92027: LD_VAR 0 3
92031: RET
// export function UnitGoingToBuilding ( unit , building ) ; var x , y ; begin
92032: LD_INT 0
92034: PPUSH
92035: PPUSH
92036: PPUSH
// x := GetX ( building ) ;
92037: LD_ADDR_VAR 0 4
92041: PUSH
92042: LD_VAR 0 2
92046: PPUSH
92047: CALL_OW 250
92051: ST_TO_ADDR
// y := GetY ( building ) ;
92052: LD_ADDR_VAR 0 5
92056: PUSH
92057: LD_VAR 0 2
92061: PPUSH
92062: CALL_OW 251
92066: ST_TO_ADDR
// if GetTaskList ( unit ) then
92067: LD_VAR 0 1
92071: PPUSH
92072: CALL_OW 437
92076: IFFALSE 92171
// begin if e = GetTaskList ( unit ) [ 1 ] [ 1 ] and x = GetTaskList ( unit ) [ 1 ] [ 2 ] and y = GetTaskList ( unit ) [ 1 ] [ 3 ] then
92078: LD_STRING e
92080: PUSH
92081: LD_VAR 0 1
92085: PPUSH
92086: CALL_OW 437
92090: PUSH
92091: LD_INT 1
92093: ARRAY
92094: PUSH
92095: LD_INT 1
92097: ARRAY
92098: EQUAL
92099: PUSH
92100: LD_VAR 0 4
92104: PUSH
92105: LD_VAR 0 1
92109: PPUSH
92110: CALL_OW 437
92114: PUSH
92115: LD_INT 1
92117: ARRAY
92118: PUSH
92119: LD_INT 2
92121: ARRAY
92122: EQUAL
92123: AND
92124: PUSH
92125: LD_VAR 0 5
92129: PUSH
92130: LD_VAR 0 1
92134: PPUSH
92135: CALL_OW 437
92139: PUSH
92140: LD_INT 1
92142: ARRAY
92143: PUSH
92144: LD_INT 3
92146: ARRAY
92147: EQUAL
92148: AND
92149: IFFALSE 92161
// result := true else
92151: LD_ADDR_VAR 0 3
92155: PUSH
92156: LD_INT 1
92158: ST_TO_ADDR
92159: GO 92169
// result := false ;
92161: LD_ADDR_VAR 0 3
92165: PUSH
92166: LD_INT 0
92168: ST_TO_ADDR
// end else
92169: GO 92179
// result := false ;
92171: LD_ADDR_VAR 0 3
92175: PUSH
92176: LD_INT 0
92178: ST_TO_ADDR
// end ;
92179: LD_VAR 0 3
92183: RET
// export function PlaceUnitInArea ( unit , area , mode ) ; var i , tmp , hex ; begin
92184: LD_INT 0
92186: PPUSH
92187: PPUSH
92188: PPUSH
92189: PPUSH
// if not unit or not area then
92190: LD_VAR 0 1
92194: NOT
92195: PUSH
92196: LD_VAR 0 2
92200: NOT
92201: OR
92202: IFFALSE 92206
// exit ;
92204: GO 92370
// tmp := AreaToList ( area , i ) ;
92206: LD_ADDR_VAR 0 6
92210: PUSH
92211: LD_VAR 0 2
92215: PPUSH
92216: LD_VAR 0 5
92220: PPUSH
92221: CALL_OW 517
92225: ST_TO_ADDR
// for i = 1 to tmp [ 1 ] do
92226: LD_ADDR_VAR 0 5
92230: PUSH
92231: DOUBLE
92232: LD_INT 1
92234: DEC
92235: ST_TO_ADDR
92236: LD_VAR 0 6
92240: PUSH
92241: LD_INT 1
92243: ARRAY
92244: PUSH
92245: FOR_TO
92246: IFFALSE 92368
// begin hex := [ tmp [ 1 ] [ i ] , tmp [ 2 ] [ i ] ] ;
92248: LD_ADDR_VAR 0 7
92252: PUSH
92253: LD_VAR 0 6
92257: PUSH
92258: LD_INT 1
92260: ARRAY
92261: PUSH
92262: LD_VAR 0 5
92266: ARRAY
92267: PUSH
92268: LD_VAR 0 6
92272: PUSH
92273: LD_INT 2
92275: ARRAY
92276: PUSH
92277: LD_VAR 0 5
92281: ARRAY
92282: PUSH
92283: EMPTY
92284: LIST
92285: LIST
92286: ST_TO_ADDR
// if HexInfo ( hex [ 1 ] , hex [ 2 ] ) = 0 then
92287: LD_VAR 0 7
92291: PUSH
92292: LD_INT 1
92294: ARRAY
92295: PPUSH
92296: LD_VAR 0 7
92300: PUSH
92301: LD_INT 2
92303: ARRAY
92304: PPUSH
92305: CALL_OW 428
92309: PUSH
92310: LD_INT 0
92312: EQUAL
92313: IFFALSE 92366
// begin PlaceUnitXY ( unit , hex [ 1 ] , hex [ 2 ] , mode ) ;
92315: LD_VAR 0 1
92319: PPUSH
92320: LD_VAR 0 7
92324: PUSH
92325: LD_INT 1
92327: ARRAY
92328: PPUSH
92329: LD_VAR 0 7
92333: PUSH
92334: LD_INT 2
92336: ARRAY
92337: PPUSH
92338: LD_VAR 0 3
92342: PPUSH
92343: CALL_OW 48
// result := IsPlaced ( unit ) ;
92347: LD_ADDR_VAR 0 4
92351: PUSH
92352: LD_VAR 0 1
92356: PPUSH
92357: CALL_OW 305
92361: ST_TO_ADDR
// exit ;
92362: POP
92363: POP
92364: GO 92370
// end ; end ;
92366: GO 92245
92368: POP
92369: POP
// end ;
92370: LD_VAR 0 4
92374: RET
// export function BuildingsListDump ( side ) ; var i , tmp ; begin
92375: LD_INT 0
92377: PPUSH
92378: PPUSH
92379: PPUSH
// if not side or side > 8 then
92380: LD_VAR 0 1
92384: NOT
92385: PUSH
92386: LD_VAR 0 1
92390: PUSH
92391: LD_INT 8
92393: GREATER
92394: OR
92395: IFFALSE 92399
// exit ;
92397: GO 92586
// tmp := FilterAllUnits ( [ [ f_side , side ] , [ f_type , unit_building ] ] ) ;
92399: LD_ADDR_VAR 0 4
92403: PUSH
92404: LD_INT 22
92406: PUSH
92407: LD_VAR 0 1
92411: PUSH
92412: EMPTY
92413: LIST
92414: LIST
92415: PUSH
92416: LD_INT 21
92418: PUSH
92419: LD_INT 3
92421: PUSH
92422: EMPTY
92423: LIST
92424: LIST
92425: PUSH
92426: EMPTY
92427: LIST
92428: LIST
92429: PPUSH
92430: CALL_OW 69
92434: ST_TO_ADDR
// if not tmp then
92435: LD_VAR 0 4
92439: NOT
92440: IFFALSE 92444
// exit ;
92442: GO 92586
// enable_addtolog := true ;
92444: LD_ADDR_OWVAR 81
92448: PUSH
92449: LD_INT 1
92451: ST_TO_ADDR
// AddToLog ( [ ) ;
92452: LD_STRING [
92454: PPUSH
92455: CALL_OW 561
// for i in tmp do
92459: LD_ADDR_VAR 0 3
92463: PUSH
92464: LD_VAR 0 4
92468: PUSH
92469: FOR_IN
92470: IFFALSE 92577
// begin AddToLog ( [ & GetBType ( i ) & ,  & GetX ( i ) & ,  & GetY ( i ) & ,  & GetDir ( i ) & ,  & GetLabKind ( i , 1 ) & ,  & GetLabKind ( i , 2 ) & ], ) ;
92472: LD_STRING [
92474: PUSH
92475: LD_VAR 0 3
92479: PPUSH
92480: CALL_OW 266
92484: STR
92485: PUSH
92486: LD_STRING , 
92488: STR
92489: PUSH
92490: LD_VAR 0 3
92494: PPUSH
92495: CALL_OW 250
92499: STR
92500: PUSH
92501: LD_STRING , 
92503: STR
92504: PUSH
92505: LD_VAR 0 3
92509: PPUSH
92510: CALL_OW 251
92514: STR
92515: PUSH
92516: LD_STRING , 
92518: STR
92519: PUSH
92520: LD_VAR 0 3
92524: PPUSH
92525: CALL_OW 254
92529: STR
92530: PUSH
92531: LD_STRING , 
92533: STR
92534: PUSH
92535: LD_VAR 0 3
92539: PPUSH
92540: LD_INT 1
92542: PPUSH
92543: CALL_OW 268
92547: STR
92548: PUSH
92549: LD_STRING , 
92551: STR
92552: PUSH
92553: LD_VAR 0 3
92557: PPUSH
92558: LD_INT 2
92560: PPUSH
92561: CALL_OW 268
92565: STR
92566: PUSH
92567: LD_STRING ],
92569: STR
92570: PPUSH
92571: CALL_OW 561
// end ;
92575: GO 92469
92577: POP
92578: POP
// AddToLog ( ]; ) ;
92579: LD_STRING ];
92581: PPUSH
92582: CALL_OW 561
// end ;
92586: LD_VAR 0 2
92590: RET
// export function Crates ( area , rate , min , max ) ; var i , r , time , amount ; begin
92591: LD_INT 0
92593: PPUSH
92594: PPUSH
92595: PPUSH
92596: PPUSH
92597: PPUSH
// if not area or not rate or not max then
92598: LD_VAR 0 1
92602: NOT
92603: PUSH
92604: LD_VAR 0 2
92608: NOT
92609: OR
92610: PUSH
92611: LD_VAR 0 4
92615: NOT
92616: OR
92617: IFFALSE 92621
// exit ;
92619: GO 92813
// while 1 do
92621: LD_INT 1
92623: IFFALSE 92813
// begin amount := GetResourceArea ( area , mat_cans ) * 10 ;
92625: LD_ADDR_VAR 0 9
92629: PUSH
92630: LD_VAR 0 1
92634: PPUSH
92635: LD_INT 1
92637: PPUSH
92638: CALL_OW 287
92642: PUSH
92643: LD_INT 10
92645: MUL
92646: ST_TO_ADDR
// r := rate / 10 ;
92647: LD_ADDR_VAR 0 7
92651: PUSH
92652: LD_VAR 0 2
92656: PUSH
92657: LD_INT 10
92659: DIVREAL
92660: ST_TO_ADDR
// time := 1 1$00 ;
92661: LD_ADDR_VAR 0 8
92665: PUSH
92666: LD_INT 2100
92668: ST_TO_ADDR
// if amount < min then
92669: LD_VAR 0 9
92673: PUSH
92674: LD_VAR 0 3
92678: LESS
92679: IFFALSE 92697
// r := r * 2 else
92681: LD_ADDR_VAR 0 7
92685: PUSH
92686: LD_VAR 0 7
92690: PUSH
92691: LD_INT 2
92693: MUL
92694: ST_TO_ADDR
92695: GO 92723
// if amount > max then
92697: LD_VAR 0 9
92701: PUSH
92702: LD_VAR 0 4
92706: GREATER
92707: IFFALSE 92723
// r := r / 2 ;
92709: LD_ADDR_VAR 0 7
92713: PUSH
92714: LD_VAR 0 7
92718: PUSH
92719: LD_INT 2
92721: DIVREAL
92722: ST_TO_ADDR
// time := time / r ;
92723: LD_ADDR_VAR 0 8
92727: PUSH
92728: LD_VAR 0 8
92732: PUSH
92733: LD_VAR 0 7
92737: DIVREAL
92738: ST_TO_ADDR
// if time < 0 then
92739: LD_VAR 0 8
92743: PUSH
92744: LD_INT 0
92746: LESS
92747: IFFALSE 92764
// time := time * - 1 ;
92749: LD_ADDR_VAR 0 8
92753: PUSH
92754: LD_VAR 0 8
92758: PUSH
92759: LD_INT 1
92761: NEG
92762: MUL
92763: ST_TO_ADDR
// wait ( time ) ;
92764: LD_VAR 0 8
92768: PPUSH
92769: CALL_OW 67
// wait ( rand ( 0 0$01 , 0 0$25 ) ) ;
92773: LD_INT 35
92775: PPUSH
92776: LD_INT 875
92778: PPUSH
92779: CALL_OW 12
92783: PPUSH
92784: CALL_OW 67
// CreateCratesArea ( rand ( 1 , 5 ) , area , true ) ;
92788: LD_INT 1
92790: PPUSH
92791: LD_INT 5
92793: PPUSH
92794: CALL_OW 12
92798: PPUSH
92799: LD_VAR 0 1
92803: PPUSH
92804: LD_INT 1
92806: PPUSH
92807: CALL_OW 55
// end ;
92811: GO 92621
// end ;
92813: LD_VAR 0 5
92817: RET
// export function UpgradeTurretsWeapon ( turrets , factories ) ; var i , j , k , nat , weapon , weapons , list ; begin
92818: LD_INT 0
92820: PPUSH
92821: PPUSH
92822: PPUSH
92823: PPUSH
92824: PPUSH
92825: PPUSH
92826: PPUSH
92827: PPUSH
// if not turrets or not factories then
92828: LD_VAR 0 1
92832: NOT
92833: PUSH
92834: LD_VAR 0 2
92838: NOT
92839: OR
92840: IFFALSE 92844
// exit ;
92842: GO 93151
// list := [ [ [ us_double_gun , us_heavy_gun ] , [ us_machine_gun , us_gatling_gun ] , [ us_light_gun , us_double_gun ] ] , [ [ ar_double_machine_gun , ar_gatling_gun ] , [ ar_light_gun , ar_gun ] ] , [ [ ru_heavy_machine_gun , ru_gatling_gun ] , [ ru_gun , ru_heavy_gun ] , [ ru_rocket_launcher , ru_rocket ] ] , ] ;
92844: LD_ADDR_VAR 0 10
92848: PUSH
92849: LD_INT 5
92851: PUSH
92852: LD_INT 6
92854: PUSH
92855: EMPTY
92856: LIST
92857: LIST
92858: PUSH
92859: LD_INT 2
92861: PUSH
92862: LD_INT 4
92864: PUSH
92865: EMPTY
92866: LIST
92867: LIST
92868: PUSH
92869: LD_INT 3
92871: PUSH
92872: LD_INT 5
92874: PUSH
92875: EMPTY
92876: LIST
92877: LIST
92878: PUSH
92879: EMPTY
92880: LIST
92881: LIST
92882: LIST
92883: PUSH
92884: LD_INT 24
92886: PUSH
92887: LD_INT 25
92889: PUSH
92890: EMPTY
92891: LIST
92892: LIST
92893: PUSH
92894: LD_INT 23
92896: PUSH
92897: LD_INT 27
92899: PUSH
92900: EMPTY
92901: LIST
92902: LIST
92903: PUSH
92904: EMPTY
92905: LIST
92906: LIST
92907: PUSH
92908: LD_INT 42
92910: PUSH
92911: LD_INT 43
92913: PUSH
92914: EMPTY
92915: LIST
92916: LIST
92917: PUSH
92918: LD_INT 44
92920: PUSH
92921: LD_INT 46
92923: PUSH
92924: EMPTY
92925: LIST
92926: LIST
92927: PUSH
92928: LD_INT 45
92930: PUSH
92931: LD_INT 47
92933: PUSH
92934: EMPTY
92935: LIST
92936: LIST
92937: PUSH
92938: EMPTY
92939: LIST
92940: LIST
92941: LIST
92942: PUSH
92943: EMPTY
92944: LIST
92945: LIST
92946: LIST
92947: ST_TO_ADDR
// result := [ ] ;
92948: LD_ADDR_VAR 0 3
92952: PUSH
92953: EMPTY
92954: ST_TO_ADDR
// for i in turrets do
92955: LD_ADDR_VAR 0 4
92959: PUSH
92960: LD_VAR 0 1
92964: PUSH
92965: FOR_IN
92966: IFFALSE 93149
// begin nat := GetNation ( i ) ;
92968: LD_ADDR_VAR 0 7
92972: PUSH
92973: LD_VAR 0 4
92977: PPUSH
92978: CALL_OW 248
92982: ST_TO_ADDR
// weapon := 0 ;
92983: LD_ADDR_VAR 0 8
92987: PUSH
92988: LD_INT 0
92990: ST_TO_ADDR
// if not nat then
92991: LD_VAR 0 7
92995: NOT
92996: IFFALSE 93000
// continue ;
92998: GO 92965
// for j in list [ nat ] do
93000: LD_ADDR_VAR 0 5
93004: PUSH
93005: LD_VAR 0 10
93009: PUSH
93010: LD_VAR 0 7
93014: ARRAY
93015: PUSH
93016: FOR_IN
93017: IFFALSE 93058
// if GetBWeapon ( i ) = j [ 1 ] then
93019: LD_VAR 0 4
93023: PPUSH
93024: CALL_OW 269
93028: PUSH
93029: LD_VAR 0 5
93033: PUSH
93034: LD_INT 1
93036: ARRAY
93037: EQUAL
93038: IFFALSE 93056
// begin weapon := j [ 2 ] ;
93040: LD_ADDR_VAR 0 8
93044: PUSH
93045: LD_VAR 0 5
93049: PUSH
93050: LD_INT 2
93052: ARRAY
93053: ST_TO_ADDR
// break ;
93054: GO 93058
// end ;
93056: GO 93016
93058: POP
93059: POP
// if not weapon then
93060: LD_VAR 0 8
93064: NOT
93065: IFFALSE 93069
// continue ;
93067: GO 92965
// for k in factories do
93069: LD_ADDR_VAR 0 6
93073: PUSH
93074: LD_VAR 0 2
93078: PUSH
93079: FOR_IN
93080: IFFALSE 93145
// begin weapons := AvailableWeaponList ( k ) ;
93082: LD_ADDR_VAR 0 9
93086: PUSH
93087: LD_VAR 0 6
93091: PPUSH
93092: CALL_OW 478
93096: ST_TO_ADDR
// if not weapons then
93097: LD_VAR 0 9
93101: NOT
93102: IFFALSE 93106
// continue ;
93104: GO 93079
// if weapon in weapons then
93106: LD_VAR 0 8
93110: PUSH
93111: LD_VAR 0 9
93115: IN
93116: IFFALSE 93143
// begin result := [ i , weapon ] ;
93118: LD_ADDR_VAR 0 3
93122: PUSH
93123: LD_VAR 0 4
93127: PUSH
93128: LD_VAR 0 8
93132: PUSH
93133: EMPTY
93134: LIST
93135: LIST
93136: ST_TO_ADDR
// exit ;
93137: POP
93138: POP
93139: POP
93140: POP
93141: GO 93151
// end ; end ;
93143: GO 93079
93145: POP
93146: POP
// end ;
93147: GO 92965
93149: POP
93150: POP
// end ;
93151: LD_VAR 0 3
93155: RET
// export function RevealMapOnXY ( x , y , side , range ) ; begin
93156: LD_INT 0
93158: PPUSH
// if not side or side > 8 then
93159: LD_VAR 0 3
93163: NOT
93164: PUSH
93165: LD_VAR 0 3
93169: PUSH
93170: LD_INT 8
93172: GREATER
93173: OR
93174: IFFALSE 93178
// exit ;
93176: GO 93237
// if not range then
93178: LD_VAR 0 4
93182: NOT
93183: IFFALSE 93194
// range := - 12 ;
93185: LD_ADDR_VAR 0 4
93189: PUSH
93190: LD_INT 12
93192: NEG
93193: ST_TO_ADDR
// PlaceSeeing ( x , y , side , range ) ;
93194: LD_VAR 0 1
93198: PPUSH
93199: LD_VAR 0 2
93203: PPUSH
93204: LD_VAR 0 3
93208: PPUSH
93209: LD_VAR 0 4
93213: PPUSH
93214: CALL_OW 330
// RemoveSeeing ( x , y , side ) ;
93218: LD_VAR 0 1
93222: PPUSH
93223: LD_VAR 0 2
93227: PPUSH
93228: LD_VAR 0 3
93232: PPUSH
93233: CALL_OW 331
// end ;
93237: LD_VAR 0 5
93241: RET
// export function Video ( mode ) ; begin
93242: LD_INT 0
93244: PPUSH
// ingame_video = mode ;
93245: LD_ADDR_OWVAR 52
93249: PUSH
93250: LD_VAR 0 1
93254: ST_TO_ADDR
// interface_hidden = mode ;
93255: LD_ADDR_OWVAR 54
93259: PUSH
93260: LD_VAR 0 1
93264: ST_TO_ADDR
// end ;
93265: LD_VAR 0 2
93269: RET
// export function Join ( array , element ) ; begin
93270: LD_INT 0
93272: PPUSH
// result := array ^ element ;
93273: LD_ADDR_VAR 0 3
93277: PUSH
93278: LD_VAR 0 1
93282: PUSH
93283: LD_VAR 0 2
93287: ADD
93288: ST_TO_ADDR
// end ;
93289: LD_VAR 0 3
93293: RET
// export function JoinUnion ( array , element ) ; begin
93294: LD_INT 0
93296: PPUSH
// result := array union element ;
93297: LD_ADDR_VAR 0 3
93301: PUSH
93302: LD_VAR 0 1
93306: PUSH
93307: LD_VAR 0 2
93311: UNION
93312: ST_TO_ADDR
// end ;
93313: LD_VAR 0 3
93317: RET
// export function GetBehemoths ( side ) ; begin
93318: LD_INT 0
93320: PPUSH
// result := FilterAllUnits ( [ [ f_side , side ] , [ f_chassis , 25 ] ] ) ;
93321: LD_ADDR_VAR 0 2
93325: PUSH
93326: LD_INT 22
93328: PUSH
93329: LD_VAR 0 1
93333: PUSH
93334: EMPTY
93335: LIST
93336: LIST
93337: PUSH
93338: LD_INT 31
93340: PUSH
93341: LD_INT 25
93343: PUSH
93344: EMPTY
93345: LIST
93346: LIST
93347: PUSH
93348: EMPTY
93349: LIST
93350: LIST
93351: PPUSH
93352: CALL_OW 69
93356: ST_TO_ADDR
// end ;
93357: LD_VAR 0 2
93361: RET
// export function Shuffle ( array ) ; var i , index ; begin
93362: LD_INT 0
93364: PPUSH
93365: PPUSH
93366: PPUSH
// result := [ ] ;
93367: LD_ADDR_VAR 0 2
93371: PUSH
93372: EMPTY
93373: ST_TO_ADDR
// if not array then
93374: LD_VAR 0 1
93378: NOT
93379: IFFALSE 93383
// exit ;
93381: GO 93482
// Randomize ;
93383: CALL_OW 10
// for i = array downto 1 do
93387: LD_ADDR_VAR 0 3
93391: PUSH
93392: DOUBLE
93393: LD_VAR 0 1
93397: INC
93398: ST_TO_ADDR
93399: LD_INT 1
93401: PUSH
93402: FOR_DOWNTO
93403: IFFALSE 93480
// begin index := rand ( 1 , array ) ;
93405: LD_ADDR_VAR 0 4
93409: PUSH
93410: LD_INT 1
93412: PPUSH
93413: LD_VAR 0 1
93417: PPUSH
93418: CALL_OW 12
93422: ST_TO_ADDR
// result := Insert ( result , result + 1 , array [ index ] ) ;
93423: LD_ADDR_VAR 0 2
93427: PUSH
93428: LD_VAR 0 2
93432: PPUSH
93433: LD_VAR 0 2
93437: PUSH
93438: LD_INT 1
93440: PLUS
93441: PPUSH
93442: LD_VAR 0 1
93446: PUSH
93447: LD_VAR 0 4
93451: ARRAY
93452: PPUSH
93453: CALL_OW 2
93457: ST_TO_ADDR
// array := Delete ( array , index ) ;
93458: LD_ADDR_VAR 0 1
93462: PUSH
93463: LD_VAR 0 1
93467: PPUSH
93468: LD_VAR 0 4
93472: PPUSH
93473: CALL_OW 3
93477: ST_TO_ADDR
// end ;
93478: GO 93402
93480: POP
93481: POP
// end ;
93482: LD_VAR 0 2
93486: RET
// export function GetBaseMaterials ( base ) ; begin
93487: LD_INT 0
93489: PPUSH
// result := [ 0 , 0 , 0 ] ;
93490: LD_ADDR_VAR 0 2
93494: PUSH
93495: LD_INT 0
93497: PUSH
93498: LD_INT 0
93500: PUSH
93501: LD_INT 0
93503: PUSH
93504: EMPTY
93505: LIST
93506: LIST
93507: LIST
93508: ST_TO_ADDR
// if not base then
93509: LD_VAR 0 1
93513: NOT
93514: IFFALSE 93518
// exit ;
93516: GO 93567
// result := [ GetResourceType ( base , mat_cans ) , GetResourceType ( base , mat_oil ) , GetResourceType ( base , mat_siberit ) ] ;
93518: LD_ADDR_VAR 0 2
93522: PUSH
93523: LD_VAR 0 1
93527: PPUSH
93528: LD_INT 1
93530: PPUSH
93531: CALL_OW 275
93535: PUSH
93536: LD_VAR 0 1
93540: PPUSH
93541: LD_INT 2
93543: PPUSH
93544: CALL_OW 275
93548: PUSH
93549: LD_VAR 0 1
93553: PPUSH
93554: LD_INT 3
93556: PPUSH
93557: CALL_OW 275
93561: PUSH
93562: EMPTY
93563: LIST
93564: LIST
93565: LIST
93566: ST_TO_ADDR
// end ; end_of_file end_of_file end_of_file
93567: LD_VAR 0 2
93571: RET
// export function SOS_UnitExtraDestroyed ( un , killerSide , killerUnit ) ; var i , eff , side ; begin
93572: LD_INT 0
93574: PPUSH
93575: PPUSH
93576: PPUSH
93577: PPUSH
// if GetWeapon ( un ) = ar_bio_bomb then
93578: LD_VAR 0 1
93582: PPUSH
93583: CALL_OW 264
93587: PUSH
93588: LD_EXP 73
93592: EQUAL
93593: IFFALSE 93665
// begin if GetTech ( tech_bio3 , GetSide ( un ) ) = state_researched then
93595: LD_INT 68
93597: PPUSH
93598: LD_VAR 0 1
93602: PPUSH
93603: CALL_OW 255
93607: PPUSH
93608: CALL_OW 321
93612: PUSH
93613: LD_INT 2
93615: EQUAL
93616: IFFALSE 93628
// eff := 70 else
93618: LD_ADDR_VAR 0 6
93622: PUSH
93623: LD_INT 70
93625: ST_TO_ADDR
93626: GO 93636
// eff := 30 ;
93628: LD_ADDR_VAR 0 6
93632: PUSH
93633: LD_INT 30
93635: ST_TO_ADDR
// ArtContamination ( GetX ( un ) , GetY ( un ) , eff ) ;
93636: LD_VAR 0 1
93640: PPUSH
93641: CALL_OW 250
93645: PPUSH
93646: LD_VAR 0 1
93650: PPUSH
93651: CALL_OW 251
93655: PPUSH
93656: LD_VAR 0 6
93660: PPUSH
93661: CALL_OW 495
// end ; end ;
93665: LD_VAR 0 4
93669: RET
// export function SOS_Command ( cmd ) ; var i , j , tmp , taskList , _taskList ; begin
93670: LD_INT 0
93672: PPUSH
93673: PPUSH
93674: PPUSH
93675: PPUSH
93676: PPUSH
93677: PPUSH
// if cmd = 124 then
93678: LD_VAR 0 1
93682: PUSH
93683: LD_INT 124
93685: EQUAL
93686: IFFALSE 93892
// begin tmp := FilterAllUnits ( [ f_or , [ f_weapon , ru_bulldozer ] , [ f_weapon , us_bulldozer ] ] ) ;
93688: LD_ADDR_VAR 0 5
93692: PUSH
93693: LD_INT 2
93695: PUSH
93696: LD_INT 34
93698: PUSH
93699: LD_INT 53
93701: PUSH
93702: EMPTY
93703: LIST
93704: LIST
93705: PUSH
93706: LD_INT 34
93708: PUSH
93709: LD_INT 14
93711: PUSH
93712: EMPTY
93713: LIST
93714: LIST
93715: PUSH
93716: EMPTY
93717: LIST
93718: LIST
93719: LIST
93720: PPUSH
93721: CALL_OW 69
93725: ST_TO_ADDR
// if not tmp then
93726: LD_VAR 0 5
93730: NOT
93731: IFFALSE 93735
// exit ;
93733: GO 93892
// for i in tmp do
93735: LD_ADDR_VAR 0 3
93739: PUSH
93740: LD_VAR 0 5
93744: PUSH
93745: FOR_IN
93746: IFFALSE 93890
// begin taskList := GetTaskList ( i ) ;
93748: LD_ADDR_VAR 0 6
93752: PUSH
93753: LD_VAR 0 3
93757: PPUSH
93758: CALL_OW 437
93762: ST_TO_ADDR
// if not taskList then
93763: LD_VAR 0 6
93767: NOT
93768: IFFALSE 93772
// continue ;
93770: GO 93745
// for j = 1 to taskList do
93772: LD_ADDR_VAR 0 4
93776: PUSH
93777: DOUBLE
93778: LD_INT 1
93780: DEC
93781: ST_TO_ADDR
93782: LD_VAR 0 6
93786: PUSH
93787: FOR_TO
93788: IFFALSE 93886
// if taskList [ j ] [ 1 ] = | then
93790: LD_VAR 0 6
93794: PUSH
93795: LD_VAR 0 4
93799: ARRAY
93800: PUSH
93801: LD_INT 1
93803: ARRAY
93804: PUSH
93805: LD_STRING |
93807: EQUAL
93808: IFFALSE 93884
// begin _taskList := Delete ( taskList , 1 ) ;
93810: LD_ADDR_VAR 0 7
93814: PUSH
93815: LD_VAR 0 6
93819: PPUSH
93820: LD_INT 1
93822: PPUSH
93823: CALL_OW 3
93827: ST_TO_ADDR
// SetTaskList ( i , _taskList ) ;
93828: LD_VAR 0 3
93832: PPUSH
93833: LD_VAR 0 7
93837: PPUSH
93838: CALL_OW 446
// CutTreeXYR ( i , taskList [ j ] [ 2 ] , taskList [ j ] [ 3 ] , 8 ) ;
93842: LD_VAR 0 3
93846: PPUSH
93847: LD_VAR 0 6
93851: PUSH
93852: LD_VAR 0 4
93856: ARRAY
93857: PUSH
93858: LD_INT 2
93860: ARRAY
93861: PPUSH
93862: LD_VAR 0 6
93866: PUSH
93867: LD_VAR 0 4
93871: ARRAY
93872: PUSH
93873: LD_INT 3
93875: ARRAY
93876: PPUSH
93877: LD_INT 8
93879: PPUSH
93880: CALL 93897 0 4
// end ;
93884: GO 93787
93886: POP
93887: POP
// end ;
93888: GO 93745
93890: POP
93891: POP
// end ; end ;
93892: LD_VAR 0 2
93896: RET
// function CutTreeXYR ( bulldozer , x , y , r ) ; var i , min_x , min_y , max_x , max_y , _x , _y , list ; begin
93897: LD_INT 0
93899: PPUSH
93900: PPUSH
93901: PPUSH
93902: PPUSH
93903: PPUSH
93904: PPUSH
93905: PPUSH
93906: PPUSH
93907: PPUSH
// if not bulldozer or not ValidHex ( x , y ) or not r then
93908: LD_VAR 0 1
93912: NOT
93913: PUSH
93914: LD_VAR 0 2
93918: PPUSH
93919: LD_VAR 0 3
93923: PPUSH
93924: CALL_OW 488
93928: NOT
93929: OR
93930: PUSH
93931: LD_VAR 0 4
93935: NOT
93936: OR
93937: IFFALSE 93941
// exit ;
93939: GO 94281
// list := [ ] ;
93941: LD_ADDR_VAR 0 13
93945: PUSH
93946: EMPTY
93947: ST_TO_ADDR
// if x - r < 0 then
93948: LD_VAR 0 2
93952: PUSH
93953: LD_VAR 0 4
93957: MINUS
93958: PUSH
93959: LD_INT 0
93961: LESS
93962: IFFALSE 93974
// min_x := 0 else
93964: LD_ADDR_VAR 0 7
93968: PUSH
93969: LD_INT 0
93971: ST_TO_ADDR
93972: GO 93990
// min_x := x - r ;
93974: LD_ADDR_VAR 0 7
93978: PUSH
93979: LD_VAR 0 2
93983: PUSH
93984: LD_VAR 0 4
93988: MINUS
93989: ST_TO_ADDR
// if y - r < 0 then
93990: LD_VAR 0 3
93994: PUSH
93995: LD_VAR 0 4
93999: MINUS
94000: PUSH
94001: LD_INT 0
94003: LESS
94004: IFFALSE 94016
// min_y := 0 else
94006: LD_ADDR_VAR 0 8
94010: PUSH
94011: LD_INT 0
94013: ST_TO_ADDR
94014: GO 94032
// min_y := y - r ;
94016: LD_ADDR_VAR 0 8
94020: PUSH
94021: LD_VAR 0 3
94025: PUSH
94026: LD_VAR 0 4
94030: MINUS
94031: ST_TO_ADDR
// max_x := x + r ;
94032: LD_ADDR_VAR 0 9
94036: PUSH
94037: LD_VAR 0 2
94041: PUSH
94042: LD_VAR 0 4
94046: PLUS
94047: ST_TO_ADDR
// max_y := y + r ;
94048: LD_ADDR_VAR 0 10
94052: PUSH
94053: LD_VAR 0 3
94057: PUSH
94058: LD_VAR 0 4
94062: PLUS
94063: ST_TO_ADDR
// for _x = min_x to max_x do
94064: LD_ADDR_VAR 0 11
94068: PUSH
94069: DOUBLE
94070: LD_VAR 0 7
94074: DEC
94075: ST_TO_ADDR
94076: LD_VAR 0 9
94080: PUSH
94081: FOR_TO
94082: IFFALSE 94199
// for _y = min_y to max_y do
94084: LD_ADDR_VAR 0 12
94088: PUSH
94089: DOUBLE
94090: LD_VAR 0 8
94094: DEC
94095: ST_TO_ADDR
94096: LD_VAR 0 10
94100: PUSH
94101: FOR_TO
94102: IFFALSE 94195
// begin if not ValidHex ( _x , _y ) then
94104: LD_VAR 0 11
94108: PPUSH
94109: LD_VAR 0 12
94113: PPUSH
94114: CALL_OW 488
94118: NOT
94119: IFFALSE 94123
// continue ;
94121: GO 94101
// if IsEnvironment ( _x , _y ) and IsEnvironmentDestroyable ( _x , _y ) then
94123: LD_VAR 0 11
94127: PPUSH
94128: LD_VAR 0 12
94132: PPUSH
94133: CALL_OW 351
94137: PUSH
94138: LD_VAR 0 11
94142: PPUSH
94143: LD_VAR 0 12
94147: PPUSH
94148: CALL_OW 554
94152: AND
94153: IFFALSE 94193
// list := Insert ( list , list + 1 , [ _x , _y ] ) ;
94155: LD_ADDR_VAR 0 13
94159: PUSH
94160: LD_VAR 0 13
94164: PPUSH
94165: LD_VAR 0 13
94169: PUSH
94170: LD_INT 1
94172: PLUS
94173: PPUSH
94174: LD_VAR 0 11
94178: PUSH
94179: LD_VAR 0 12
94183: PUSH
94184: EMPTY
94185: LIST
94186: LIST
94187: PPUSH
94188: CALL_OW 2
94192: ST_TO_ADDR
// end ;
94193: GO 94101
94195: POP
94196: POP
94197: GO 94081
94199: POP
94200: POP
// if not list then
94201: LD_VAR 0 13
94205: NOT
94206: IFFALSE 94210
// exit ;
94208: GO 94281
// for i in list do
94210: LD_ADDR_VAR 0 6
94214: PUSH
94215: LD_VAR 0 13
94219: PUSH
94220: FOR_IN
94221: IFFALSE 94279
// AddTaskList ( bulldozer , [ [ M , i [ 1 ] , i [ 2 ] , 0 , 0 , 0 , 0 ] ] ) ;
94223: LD_VAR 0 1
94227: PPUSH
94228: LD_STRING M
94230: PUSH
94231: LD_VAR 0 6
94235: PUSH
94236: LD_INT 1
94238: ARRAY
94239: PUSH
94240: LD_VAR 0 6
94244: PUSH
94245: LD_INT 2
94247: ARRAY
94248: PUSH
94249: LD_INT 0
94251: PUSH
94252: LD_INT 0
94254: PUSH
94255: LD_INT 0
94257: PUSH
94258: LD_INT 0
94260: PUSH
94261: EMPTY
94262: LIST
94263: LIST
94264: LIST
94265: LIST
94266: LIST
94267: LIST
94268: LIST
94269: PUSH
94270: EMPTY
94271: LIST
94272: PPUSH
94273: CALL_OW 447
94277: GO 94220
94279: POP
94280: POP
// end ;
94281: LD_VAR 0 5
94285: RET
