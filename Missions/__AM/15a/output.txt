// starting begin ResetFog ;
   0: CALL_OW 335
// AnimateTrees ( true ) ;
   4: LD_INT 1
   6: PPUSH
   7: CALL_OW 573
// InitVariables ;
  11: CALL 65 0 0
// InitMacro ;
  15: CALL 10542 0 0
// InitNature ;
  19: CALL 10366 0 0
// if debug then
  23: LD_EXP 1
  27: IFFALSE 36
// FogOff ( 1 ) ;
  29: LD_INT 1
  31: PPUSH
  32: CALL_OW 344
// PrepareAmerican ;
  36: CALL 3999 0 0
// PrepareAlliance ;
  40: CALL 1149 0 0
// PrepareArabian ;
  44: CALL 5654 0 0
// PrepareRussian ;
  48: CALL 7514 0 0
// PrepareLegion ;
  52: CALL 5955 0 0
// Action ;
  56: CALL 9919 0 0
// MC_Start ( ) ;
  60: CALL 12654 0 0
// end ;
  64: END
// export debug ; export russianDestroyed , legionDestroyed , americanDestroyed , arabianDestroyed ; export function InitVariables ; begin
  65: LD_INT 0
  67: PPUSH
// debug := 1 ;
  68: LD_ADDR_EXP 1
  72: PUSH
  73: LD_INT 1
  75: ST_TO_ADDR
// russianDestroyed := false ;
  76: LD_ADDR_EXP 2
  80: PUSH
  81: LD_INT 0
  83: ST_TO_ADDR
// legionDestroyed := false ;
  84: LD_ADDR_EXP 3
  88: PUSH
  89: LD_INT 0
  91: ST_TO_ADDR
// americanDestroyed := false ;
  92: LD_ADDR_EXP 4
  96: PUSH
  97: LD_INT 0
  99: ST_TO_ADDR
// arabianDestroyed := false ;
 100: LD_ADDR_EXP 5
 104: PUSH
 105: LD_INT 0
 107: ST_TO_ADDR
// end ;
 108: LD_VAR 0 1
 112: RET
// export function CustomInitMacro ( ) ; begin
 113: LD_INT 0
 115: PPUSH
// mc_parking := [ arabianParkingArea , russianParkingArea , legionParkingArea , powellParking ] ;
 116: LD_ADDR_EXP 80
 120: PUSH
 121: LD_INT 26
 123: PUSH
 124: LD_INT 1
 126: PUSH
 127: LD_INT 4
 129: PUSH
 130: LD_INT 8
 132: PUSH
 133: EMPTY
 134: LIST
 135: LIST
 136: LIST
 137: LIST
 138: ST_TO_ADDR
// mc_scan_area := [ arabianBaseArea , russianBaseArea , legionBaseArea , powellBase ] ;
 139: LD_ADDR_EXP 81
 143: PUSH
 144: LD_INT 27
 146: PUSH
 147: LD_INT 2
 149: PUSH
 150: LD_INT 3
 152: PUSH
 153: LD_INT 7
 155: PUSH
 156: EMPTY
 157: LIST
 158: LIST
 159: LIST
 160: LIST
 161: ST_TO_ADDR
// MC_SetMinesField ( 1 , [ 6 , 7 , 9 ] [ Difficulty ] , arabianMinefield ) ;
 162: LD_INT 1
 164: PPUSH
 165: LD_INT 6
 167: PUSH
 168: LD_INT 7
 170: PUSH
 171: LD_INT 9
 173: PUSH
 174: EMPTY
 175: LIST
 176: LIST
 177: LIST
 178: PUSH
 179: LD_OWVAR 67
 183: ARRAY
 184: PPUSH
 185: LD_INT 28
 187: PPUSH
 188: CALL 33759 0 3
// MC_SetLabKind ( 1 , [ b_lab_weapon , b_lab_siberium , b_lab_biological , b_lab_opto ] ) ;
 192: LD_INT 1
 194: PPUSH
 195: LD_INT 10
 197: PUSH
 198: LD_INT 11
 200: PUSH
 201: LD_INT 13
 203: PUSH
 204: LD_INT 15
 206: PUSH
 207: EMPTY
 208: LIST
 209: LIST
 210: LIST
 211: LIST
 212: PPUSH
 213: CALL 34819 0 2
// MC_SetCratesArea ( 1 , [ arabianCratesArea ] ) ;
 217: LD_INT 1
 219: PPUSH
 220: LD_INT 29
 222: PUSH
 223: EMPTY
 224: LIST
 225: PPUSH
 226: CALL 34912 0 2
// mc_ape := Replace ( mc_ape , 1 , FilterAllUnits ( [ [ f_side , 2 ] , [ f_class , class_apeman_soldier ] ] ) ) ;
 230: LD_ADDR_EXP 85
 234: PUSH
 235: LD_EXP 85
 239: PPUSH
 240: LD_INT 1
 242: PPUSH
 243: LD_INT 22
 245: PUSH
 246: LD_INT 2
 248: PUSH
 249: EMPTY
 250: LIST
 251: LIST
 252: PUSH
 253: LD_INT 25
 255: PUSH
 256: LD_INT 15
 258: PUSH
 259: EMPTY
 260: LIST
 261: LIST
 262: PUSH
 263: EMPTY
 264: LIST
 265: LIST
 266: PPUSH
 267: CALL_OW 69
 271: PPUSH
 272: CALL_OW 1
 276: ST_TO_ADDR
// MC_SetProduceList ( 1 , [ [ ar_medium_trike , engine_solar , control_manual , ar_control_tower ] , [ ar_medium_trike , engine_solar , control_manual , ar_control_tower ] , [ ar_medium_trike , engine_combustion , control_manual , ar_rocket_launcher ] , [ ar_medium_trike , engine_combustion , control_manual , ar_rocket_launcher ] , [ ar_medium_trike , engine_combustion , control_manual , ar_rocket_launcher ] , [ ar_medium_trike , engine_combustion , control_manual , ar_rocket_launcher ] ] ) ;
 277: LD_INT 1
 279: PPUSH
 280: LD_INT 13
 282: PUSH
 283: LD_INT 2
 285: PUSH
 286: LD_INT 1
 288: PUSH
 289: LD_INT 31
 291: PUSH
 292: EMPTY
 293: LIST
 294: LIST
 295: LIST
 296: LIST
 297: PUSH
 298: LD_INT 13
 300: PUSH
 301: LD_INT 2
 303: PUSH
 304: LD_INT 1
 306: PUSH
 307: LD_INT 31
 309: PUSH
 310: EMPTY
 311: LIST
 312: LIST
 313: LIST
 314: LIST
 315: PUSH
 316: LD_INT 13
 318: PUSH
 319: LD_INT 1
 321: PUSH
 322: LD_INT 1
 324: PUSH
 325: LD_INT 28
 327: PUSH
 328: EMPTY
 329: LIST
 330: LIST
 331: LIST
 332: LIST
 333: PUSH
 334: LD_INT 13
 336: PUSH
 337: LD_INT 1
 339: PUSH
 340: LD_INT 1
 342: PUSH
 343: LD_INT 28
 345: PUSH
 346: EMPTY
 347: LIST
 348: LIST
 349: LIST
 350: LIST
 351: PUSH
 352: LD_INT 13
 354: PUSH
 355: LD_INT 1
 357: PUSH
 358: LD_INT 1
 360: PUSH
 361: LD_INT 28
 363: PUSH
 364: EMPTY
 365: LIST
 366: LIST
 367: LIST
 368: LIST
 369: PUSH
 370: LD_INT 13
 372: PUSH
 373: LD_INT 1
 375: PUSH
 376: LD_INT 1
 378: PUSH
 379: LD_INT 28
 381: PUSH
 382: EMPTY
 383: LIST
 384: LIST
 385: LIST
 386: LIST
 387: PUSH
 388: EMPTY
 389: LIST
 390: LIST
 391: LIST
 392: LIST
 393: LIST
 394: LIST
 395: PPUSH
 396: CALL 34077 0 2
// MC_SetDefenderLimit ( 1 , 4 ) ;
 400: LD_INT 1
 402: PPUSH
 403: LD_INT 4
 405: PPUSH
 406: CALL 34262 0 2
// MC_SetLabKind ( 2 , [ b_lab_weapon , b_lab_siberium , b_lab_computer , b_lab_spacetime ] ) ;
 410: LD_INT 2
 412: PPUSH
 413: LD_INT 10
 415: PUSH
 416: LD_INT 11
 418: PUSH
 419: LD_INT 12
 421: PUSH
 422: LD_INT 14
 424: PUSH
 425: EMPTY
 426: LIST
 427: LIST
 428: LIST
 429: LIST
 430: PPUSH
 431: CALL 34819 0 2
// MC_SetCratesArea ( 2 , [ russianCratesArea ] ) ;
 435: LD_INT 2
 437: PPUSH
 438: LD_INT 14
 440: PUSH
 441: EMPTY
 442: LIST
 443: PPUSH
 444: CALL 34912 0 2
// MC_SetProduceList ( 2 , [ [ ru_medium_wheeled , engine_siberite , control_computer , ru_cargo_bay ] , [ ru_medium_tracked , engine_siberite , control_computer , ru_crane ] , [ ru_medium_tracked , engine_siberite , control_computer , ru_crane ] , [ ru_heavy_tracked , engine_siberite , control_computer , ru_rocket ] , [ ru_heavy_tracked , engine_siberite , control_computer , ru_rocket ] , [ ru_heavy_tracked , engine_siberite , control_computer , ru_rocket ] , [ ru_heavy_tracked , engine_siberite , control_computer , ru_rocket ] , [ ru_heavy_tracked , engine_siberite , control_computer , ru_rocket ] ] ) ;
 448: LD_INT 2
 450: PPUSH
 451: LD_INT 21
 453: PUSH
 454: LD_INT 3
 456: PUSH
 457: LD_INT 3
 459: PUSH
 460: LD_INT 51
 462: PUSH
 463: EMPTY
 464: LIST
 465: LIST
 466: LIST
 467: LIST
 468: PUSH
 469: LD_INT 22
 471: PUSH
 472: LD_INT 3
 474: PUSH
 475: LD_INT 3
 477: PUSH
 478: LD_INT 52
 480: PUSH
 481: EMPTY
 482: LIST
 483: LIST
 484: LIST
 485: LIST
 486: PUSH
 487: LD_INT 22
 489: PUSH
 490: LD_INT 3
 492: PUSH
 493: LD_INT 3
 495: PUSH
 496: LD_INT 52
 498: PUSH
 499: EMPTY
 500: LIST
 501: LIST
 502: LIST
 503: LIST
 504: PUSH
 505: LD_INT 24
 507: PUSH
 508: LD_INT 3
 510: PUSH
 511: LD_INT 3
 513: PUSH
 514: LD_INT 47
 516: PUSH
 517: EMPTY
 518: LIST
 519: LIST
 520: LIST
 521: LIST
 522: PUSH
 523: LD_INT 24
 525: PUSH
 526: LD_INT 3
 528: PUSH
 529: LD_INT 3
 531: PUSH
 532: LD_INT 47
 534: PUSH
 535: EMPTY
 536: LIST
 537: LIST
 538: LIST
 539: LIST
 540: PUSH
 541: LD_INT 24
 543: PUSH
 544: LD_INT 3
 546: PUSH
 547: LD_INT 3
 549: PUSH
 550: LD_INT 47
 552: PUSH
 553: EMPTY
 554: LIST
 555: LIST
 556: LIST
 557: LIST
 558: PUSH
 559: LD_INT 24
 561: PUSH
 562: LD_INT 3
 564: PUSH
 565: LD_INT 3
 567: PUSH
 568: LD_INT 47
 570: PUSH
 571: EMPTY
 572: LIST
 573: LIST
 574: LIST
 575: LIST
 576: PUSH
 577: LD_INT 24
 579: PUSH
 580: LD_INT 3
 582: PUSH
 583: LD_INT 3
 585: PUSH
 586: LD_INT 47
 588: PUSH
 589: EMPTY
 590: LIST
 591: LIST
 592: LIST
 593: LIST
 594: PUSH
 595: EMPTY
 596: LIST
 597: LIST
 598: LIST
 599: LIST
 600: LIST
 601: LIST
 602: LIST
 603: LIST
 604: PPUSH
 605: CALL 34077 0 2
// MC_SetDefenderLimit ( 2 , 5 ) ;
 609: LD_INT 2
 611: PPUSH
 612: LD_INT 5
 614: PPUSH
 615: CALL 34262 0 2
// MC_SetUpgradeBuilding ( 2 , b_depot ) ;
 619: LD_INT 2
 621: PPUSH
 622: LD_INT 0
 624: PPUSH
 625: CALL 34692 0 2
// MC_SetMinesField ( 3 , [ 10 , 12 , 15 ] [ Difficulty ] , legionMinefield ) ;
 629: LD_INT 3
 631: PPUSH
 632: LD_INT 10
 634: PUSH
 635: LD_INT 12
 637: PUSH
 638: LD_INT 15
 640: PUSH
 641: EMPTY
 642: LIST
 643: LIST
 644: LIST
 645: PUSH
 646: LD_OWVAR 67
 650: ARRAY
 651: PPUSH
 652: LD_INT 24
 654: PPUSH
 655: CALL 33759 0 3
// MC_SetLabKind ( 3 , [ b_lab_weapon , b_lab_siberium , b_lab_biological , b_lab_opto ] ) ;
 659: LD_INT 3
 661: PPUSH
 662: LD_INT 10
 664: PUSH
 665: LD_INT 11
 667: PUSH
 668: LD_INT 13
 670: PUSH
 671: LD_INT 15
 673: PUSH
 674: EMPTY
 675: LIST
 676: LIST
 677: LIST
 678: LIST
 679: PPUSH
 680: CALL 34819 0 2
// MC_SetCratesArea ( 3 , [ legionCratesArea ] ) ;
 684: LD_INT 3
 686: PPUSH
 687: LD_INT 13
 689: PUSH
 690: EMPTY
 691: LIST
 692: PPUSH
 693: CALL 34912 0 2
// mc_ape := Replace ( mc_ape , 3 , FilterAllUnits ( [ [ f_side , 8 ] , [ f_class , class_apeman_soldier ] ] ) ) ;
 697: LD_ADDR_EXP 85
 701: PUSH
 702: LD_EXP 85
 706: PPUSH
 707: LD_INT 3
 709: PPUSH
 710: LD_INT 22
 712: PUSH
 713: LD_INT 8
 715: PUSH
 716: EMPTY
 717: LIST
 718: LIST
 719: PUSH
 720: LD_INT 25
 722: PUSH
 723: LD_INT 15
 725: PUSH
 726: EMPTY
 727: LIST
 728: LIST
 729: PUSH
 730: EMPTY
 731: LIST
 732: LIST
 733: PPUSH
 734: CALL_OW 69
 738: PPUSH
 739: CALL_OW 1
 743: ST_TO_ADDR
// MC_SetProduceList ( 3 , [ [ ar_medium_trike , engine_solar , control_manual , ar_control_tower ] , [ ar_medium_trike , engine_solar , control_manual , ar_control_tower ] , [ ar_medium_trike , engine_siberite , control_remote , ar_cargo_bay ] , [ ar_half_tracked , engine_combustion , control_manual , ar_rocket_launcher ] , [ ar_half_tracked , engine_combustion , control_manual , ar_rocket_launcher ] , [ ar_half_tracked , engine_combustion , control_manual , ar_rocket_launcher ] , [ ar_half_tracked , engine_combustion , control_manual , ar_rocket_launcher ] ] ) ;
 744: LD_INT 3
 746: PPUSH
 747: LD_INT 13
 749: PUSH
 750: LD_INT 2
 752: PUSH
 753: LD_INT 1
 755: PUSH
 756: LD_INT 31
 758: PUSH
 759: EMPTY
 760: LIST
 761: LIST
 762: LIST
 763: LIST
 764: PUSH
 765: LD_INT 13
 767: PUSH
 768: LD_INT 2
 770: PUSH
 771: LD_INT 1
 773: PUSH
 774: LD_INT 31
 776: PUSH
 777: EMPTY
 778: LIST
 779: LIST
 780: LIST
 781: LIST
 782: PUSH
 783: LD_INT 13
 785: PUSH
 786: LD_INT 3
 788: PUSH
 789: LD_INT 2
 791: PUSH
 792: LD_INT 32
 794: PUSH
 795: EMPTY
 796: LIST
 797: LIST
 798: LIST
 799: LIST
 800: PUSH
 801: LD_INT 14
 803: PUSH
 804: LD_INT 1
 806: PUSH
 807: LD_INT 1
 809: PUSH
 810: LD_INT 28
 812: PUSH
 813: EMPTY
 814: LIST
 815: LIST
 816: LIST
 817: LIST
 818: PUSH
 819: LD_INT 14
 821: PUSH
 822: LD_INT 1
 824: PUSH
 825: LD_INT 1
 827: PUSH
 828: LD_INT 28
 830: PUSH
 831: EMPTY
 832: LIST
 833: LIST
 834: LIST
 835: LIST
 836: PUSH
 837: LD_INT 14
 839: PUSH
 840: LD_INT 1
 842: PUSH
 843: LD_INT 1
 845: PUSH
 846: LD_INT 28
 848: PUSH
 849: EMPTY
 850: LIST
 851: LIST
 852: LIST
 853: LIST
 854: PUSH
 855: LD_INT 14
 857: PUSH
 858: LD_INT 1
 860: PUSH
 861: LD_INT 1
 863: PUSH
 864: LD_INT 28
 866: PUSH
 867: EMPTY
 868: LIST
 869: LIST
 870: LIST
 871: LIST
 872: PUSH
 873: EMPTY
 874: LIST
 875: LIST
 876: LIST
 877: LIST
 878: LIST
 879: LIST
 880: LIST
 881: PPUSH
 882: CALL 34077 0 2
// MC_SetDefenderLimit ( 3 , 4 ) ;
 886: LD_INT 3
 888: PPUSH
 889: LD_INT 4
 891: PPUSH
 892: CALL 34262 0 2
// MC_SetLabKind ( 4 , [ b_lab_weapon , b_lab_computer , b_lab_siberium , b_lab_opto ] ) ;
 896: LD_INT 4
 898: PPUSH
 899: LD_INT 10
 901: PUSH
 902: LD_INT 12
 904: PUSH
 905: LD_INT 11
 907: PUSH
 908: LD_INT 15
 910: PUSH
 911: EMPTY
 912: LIST
 913: LIST
 914: LIST
 915: LIST
 916: PPUSH
 917: CALL 34819 0 2
// MC_SetCratesArea ( 4 , [ powellBase ] ) ;
 921: LD_INT 4
 923: PPUSH
 924: LD_INT 7
 926: PUSH
 927: EMPTY
 928: LIST
 929: PPUSH
 930: CALL 34912 0 2
// MC_SetAllowedTurretWeapons ( 4 , [ us_double_gun , us_heavy_gun , us_rocket_launcher , us_laser , us_double_laser ] ) ;
 934: LD_INT 4
 936: PPUSH
 937: LD_INT 5
 939: PUSH
 940: LD_INT 6
 942: PUSH
 943: LD_INT 7
 945: PUSH
 946: LD_INT 9
 948: PUSH
 949: LD_INT 10
 951: PUSH
 952: EMPTY
 953: LIST
 954: LIST
 955: LIST
 956: LIST
 957: LIST
 958: PPUSH
 959: CALL 35230 0 2
// MC_SetFactoryExtension ( 4 , 54 , 85 , 2 , [ b_ext_laser , b_ext_track , b_ext_gun , b_ext_rocket , b_ext_radio ] ) ;
 963: LD_INT 4
 965: PPUSH
 966: LD_INT 54
 968: PPUSH
 969: LD_INT 85
 971: PPUSH
 972: LD_INT 2
 974: PPUSH
 975: LD_INT 25
 977: PUSH
 978: LD_INT 16
 980: PUSH
 981: LD_INT 17
 983: PUSH
 984: LD_INT 18
 986: PUSH
 987: LD_INT 22
 989: PUSH
 990: EMPTY
 991: LIST
 992: LIST
 993: LIST
 994: LIST
 995: LIST
 996: PPUSH
 997: CALL 35024 0 5
// MC_SetProduceList ( 4 , [ [ us_morphling , engine_combustion , control_manual , us_rocket_launcher ] , [ us_morphling , engine_combustion , control_manual , us_heavy_gun ] , [ us_morphling , engine_combustion , control_manual , us_rocket_launcher ] , [ us_morphling , engine_combustion , control_manual , us_heavy_gun ] , [ us_morphling , engine_combustion , control_computer , us_cargo_bay ] , [ us_medium_tracked , engine_combustion , control_computer , us_crane ] ] ) ;
1001: LD_INT 4
1003: PPUSH
1004: LD_INT 5
1006: PUSH
1007: LD_INT 1
1009: PUSH
1010: LD_INT 1
1012: PUSH
1013: LD_INT 7
1015: PUSH
1016: EMPTY
1017: LIST
1018: LIST
1019: LIST
1020: LIST
1021: PUSH
1022: LD_INT 5
1024: PUSH
1025: LD_INT 1
1027: PUSH
1028: LD_INT 1
1030: PUSH
1031: LD_INT 6
1033: PUSH
1034: EMPTY
1035: LIST
1036: LIST
1037: LIST
1038: LIST
1039: PUSH
1040: LD_INT 5
1042: PUSH
1043: LD_INT 1
1045: PUSH
1046: LD_INT 1
1048: PUSH
1049: LD_INT 7
1051: PUSH
1052: EMPTY
1053: LIST
1054: LIST
1055: LIST
1056: LIST
1057: PUSH
1058: LD_INT 5
1060: PUSH
1061: LD_INT 1
1063: PUSH
1064: LD_INT 1
1066: PUSH
1067: LD_INT 6
1069: PUSH
1070: EMPTY
1071: LIST
1072: LIST
1073: LIST
1074: LIST
1075: PUSH
1076: LD_INT 5
1078: PUSH
1079: LD_INT 1
1081: PUSH
1082: LD_INT 3
1084: PUSH
1085: LD_INT 12
1087: PUSH
1088: EMPTY
1089: LIST
1090: LIST
1091: LIST
1092: LIST
1093: PUSH
1094: LD_INT 3
1096: PUSH
1097: LD_INT 1
1099: PUSH
1100: LD_INT 3
1102: PUSH
1103: LD_INT 13
1105: PUSH
1106: EMPTY
1107: LIST
1108: LIST
1109: LIST
1110: LIST
1111: PUSH
1112: EMPTY
1113: LIST
1114: LIST
1115: LIST
1116: LIST
1117: LIST
1118: LIST
1119: PPUSH
1120: CALL 34077 0 2
// MC_SetDefenderLimit ( 4 , 4 ) ;
1124: LD_INT 4
1126: PPUSH
1127: LD_INT 4
1129: PPUSH
1130: CALL 34262 0 2
// MC_SetTame ( 4 , powellApe ) ;
1134: LD_INT 4
1136: PPUSH
1137: LD_INT 11
1139: PPUSH
1140: CALL 34643 0 2
// end ; end_of_file
1144: LD_VAR 0 1
1148: RET
// export JMM , Roth , Lisa , Donaldson , Bobby , Cyrus , Denis , Brown , Gladstone , Houten , Cornel , Gary , Frank , Kikuchi , Simms , Joan , DeltaDoctor ; export Gossudarov , Kirilenkova , Titov , Fadeev , Dolgov , Petrosyan , Scholtze , Oblukov , Kapitsova , Lipshchin , Petrovova , Kovalyuk , Kuzmov , Karamazov ; export Burlak , Belkov , Gnyevko ; export function PrepareAlliance ; var i , veh , selected , tmp ; begin
1149: LD_INT 0
1151: PPUSH
1152: PPUSH
1153: PPUSH
1154: PPUSH
1155: PPUSH
// uc_side := 7 ;
1156: LD_ADDR_OWVAR 20
1160: PUSH
1161: LD_INT 7
1163: ST_TO_ADDR
// tmp := [ ] ;
1164: LD_ADDR_VAR 0 5
1168: PUSH
1169: EMPTY
1170: ST_TO_ADDR
// JMM := PrepareUnit ( JMM , ( not debug ) , 14a_ ) ;
1171: LD_ADDR_EXP 6
1175: PUSH
1176: LD_STRING JMM
1178: PPUSH
1179: LD_EXP 1
1183: NOT
1184: PPUSH
1185: LD_STRING 14a_
1187: PPUSH
1188: CALL 40247 0 3
1192: ST_TO_ADDR
// Burlak := PrepareUnit ( Burlak , ( not debug ) , 14a_ ) ;
1193: LD_ADDR_EXP 37
1197: PUSH
1198: LD_STRING Burlak
1200: PPUSH
1201: LD_EXP 1
1205: NOT
1206: PPUSH
1207: LD_STRING 14a_
1209: PPUSH
1210: CALL 40247 0 3
1214: ST_TO_ADDR
// Joan := PrepareUnit ( Joan , ( not debug ) , 13a_ ) ;
1215: LD_ADDR_EXP 21
1219: PUSH
1220: LD_STRING Joan
1222: PPUSH
1223: LD_EXP 1
1227: NOT
1228: PPUSH
1229: LD_STRING 13a_
1231: PPUSH
1232: CALL 40247 0 3
1236: ST_TO_ADDR
// Roth := PrepareUnit ( Roth , ( not debug ) , 13a_ ) ;
1237: LD_ADDR_EXP 7
1241: PUSH
1242: LD_STRING Roth
1244: PPUSH
1245: LD_EXP 1
1249: NOT
1250: PPUSH
1251: LD_STRING 13a_
1253: PPUSH
1254: CALL 40247 0 3
1258: ST_TO_ADDR
// Gossudarov := PrepareUnit ( Gossudarov , ( not debug ) , 13a_ ) ;
1259: LD_ADDR_EXP 23
1263: PUSH
1264: LD_STRING Gossudarov
1266: PPUSH
1267: LD_EXP 1
1271: NOT
1272: PPUSH
1273: LD_STRING 13a_
1275: PPUSH
1276: CALL 40247 0 3
1280: ST_TO_ADDR
// DeltaDoctor := PrepareUnit ( DeltaDoctor , ( not debug ) , 13a_ ) ;
1281: LD_ADDR_EXP 22
1285: PUSH
1286: LD_STRING DeltaDoctor
1288: PPUSH
1289: LD_EXP 1
1293: NOT
1294: PPUSH
1295: LD_STRING 13a_
1297: PPUSH
1298: CALL 40247 0 3
1302: ST_TO_ADDR
// if DeltaDoctor then
1303: LD_EXP 22
1307: IFFALSE 1325
// tmp := tmp ^ DeltaDoctor ;
1309: LD_ADDR_VAR 0 5
1313: PUSH
1314: LD_VAR 0 5
1318: PUSH
1319: LD_EXP 22
1323: ADD
1324: ST_TO_ADDR
// Simms := PrepareUnit ( Simms , ( not debug ) , 13a_ ) ;
1325: LD_ADDR_EXP 20
1329: PUSH
1330: LD_STRING Simms
1332: PPUSH
1333: LD_EXP 1
1337: NOT
1338: PPUSH
1339: LD_STRING 13a_
1341: PPUSH
1342: CALL 40247 0 3
1346: ST_TO_ADDR
// if Simms then
1347: LD_EXP 20
1351: IFFALSE 1369
// tmp := tmp ^ Simms ;
1353: LD_ADDR_VAR 0 5
1357: PUSH
1358: LD_VAR 0 5
1362: PUSH
1363: LD_EXP 20
1367: ADD
1368: ST_TO_ADDR
// Frank := PrepareUnit ( Frank , ( not debug ) , 13a_ ) ;
1369: LD_ADDR_EXP 18
1373: PUSH
1374: LD_STRING Frank
1376: PPUSH
1377: LD_EXP 1
1381: NOT
1382: PPUSH
1383: LD_STRING 13a_
1385: PPUSH
1386: CALL 40247 0 3
1390: ST_TO_ADDR
// if Frank then
1391: LD_EXP 18
1395: IFFALSE 1413
// tmp := tmp ^ Frank ;
1397: LD_ADDR_VAR 0 5
1401: PUSH
1402: LD_VAR 0 5
1406: PUSH
1407: LD_EXP 18
1411: ADD
1412: ST_TO_ADDR
// Kirilenkova := PrepareUnit ( Kirilenkova , ( not debug ) , 13a_ ) ;
1413: LD_ADDR_EXP 24
1417: PUSH
1418: LD_STRING Kirilenkova
1420: PPUSH
1421: LD_EXP 1
1425: NOT
1426: PPUSH
1427: LD_STRING 13a_
1429: PPUSH
1430: CALL 40247 0 3
1434: ST_TO_ADDR
// if Kirilenkova then
1435: LD_EXP 24
1439: IFFALSE 1457
// tmp := tmp ^ Kirilenkova ;
1441: LD_ADDR_VAR 0 5
1445: PUSH
1446: LD_VAR 0 5
1450: PUSH
1451: LD_EXP 24
1455: ADD
1456: ST_TO_ADDR
// Titov := PrepareUnit ( Titov , ( not debug ) , 13a_ ) ;
1457: LD_ADDR_EXP 25
1461: PUSH
1462: LD_STRING Titov
1464: PPUSH
1465: LD_EXP 1
1469: NOT
1470: PPUSH
1471: LD_STRING 13a_
1473: PPUSH
1474: CALL 40247 0 3
1478: ST_TO_ADDR
// if Titov then
1479: LD_EXP 25
1483: IFFALSE 1501
// tmp := tmp ^ Titov ;
1485: LD_ADDR_VAR 0 5
1489: PUSH
1490: LD_VAR 0 5
1494: PUSH
1495: LD_EXP 25
1499: ADD
1500: ST_TO_ADDR
// Fadeev := PrepareUnit ( Fadeev , ( not debug ) , 13a_ ) ;
1501: LD_ADDR_EXP 26
1505: PUSH
1506: LD_STRING Fadeev
1508: PPUSH
1509: LD_EXP 1
1513: NOT
1514: PPUSH
1515: LD_STRING 13a_
1517: PPUSH
1518: CALL 40247 0 3
1522: ST_TO_ADDR
// if Fadeev then
1523: LD_EXP 26
1527: IFFALSE 1545
// tmp := tmp ^ Fadeev ;
1529: LD_ADDR_VAR 0 5
1533: PUSH
1534: LD_VAR 0 5
1538: PUSH
1539: LD_EXP 26
1543: ADD
1544: ST_TO_ADDR
// Dolgov := PrepareUnit ( Dolgov , ( not debug ) , 13a_ ) ;
1545: LD_ADDR_EXP 27
1549: PUSH
1550: LD_STRING Dolgov
1552: PPUSH
1553: LD_EXP 1
1557: NOT
1558: PPUSH
1559: LD_STRING 13a_
1561: PPUSH
1562: CALL 40247 0 3
1566: ST_TO_ADDR
// if Dolgov then
1567: LD_EXP 27
1571: IFFALSE 1589
// tmp := tmp ^ Dolgov ;
1573: LD_ADDR_VAR 0 5
1577: PUSH
1578: LD_VAR 0 5
1582: PUSH
1583: LD_EXP 27
1587: ADD
1588: ST_TO_ADDR
// Petrosyan := PrepareUnit ( Petrosyan , ( not debug ) , 13a_ ) ;
1589: LD_ADDR_EXP 28
1593: PUSH
1594: LD_STRING Petrosyan
1596: PPUSH
1597: LD_EXP 1
1601: NOT
1602: PPUSH
1603: LD_STRING 13a_
1605: PPUSH
1606: CALL 40247 0 3
1610: ST_TO_ADDR
// if Petrosyan then
1611: LD_EXP 28
1615: IFFALSE 1633
// tmp := tmp ^ Petrosyan ;
1617: LD_ADDR_VAR 0 5
1621: PUSH
1622: LD_VAR 0 5
1626: PUSH
1627: LD_EXP 28
1631: ADD
1632: ST_TO_ADDR
// Scholtze := PrepareUnit ( Scholtze , ( not debug ) , 13a_ ) ;
1633: LD_ADDR_EXP 29
1637: PUSH
1638: LD_STRING Scholtze
1640: PPUSH
1641: LD_EXP 1
1645: NOT
1646: PPUSH
1647: LD_STRING 13a_
1649: PPUSH
1650: CALL 40247 0 3
1654: ST_TO_ADDR
// if Scholtze then
1655: LD_EXP 29
1659: IFFALSE 1677
// tmp := tmp ^ Scholtze ;
1661: LD_ADDR_VAR 0 5
1665: PUSH
1666: LD_VAR 0 5
1670: PUSH
1671: LD_EXP 29
1675: ADD
1676: ST_TO_ADDR
// Oblukov := PrepareUnit ( Oblukov , ( not debug ) , 13a_ ) ;
1677: LD_ADDR_EXP 30
1681: PUSH
1682: LD_STRING Oblukov
1684: PPUSH
1685: LD_EXP 1
1689: NOT
1690: PPUSH
1691: LD_STRING 13a_
1693: PPUSH
1694: CALL 40247 0 3
1698: ST_TO_ADDR
// if Oblukov then
1699: LD_EXP 30
1703: IFFALSE 1721
// tmp := tmp ^ Oblukov ;
1705: LD_ADDR_VAR 0 5
1709: PUSH
1710: LD_VAR 0 5
1714: PUSH
1715: LD_EXP 30
1719: ADD
1720: ST_TO_ADDR
// Kapitsova := PrepareUnit ( Kapitsova , ( not debug ) , 13a_ ) ;
1721: LD_ADDR_EXP 31
1725: PUSH
1726: LD_STRING Kapitsova
1728: PPUSH
1729: LD_EXP 1
1733: NOT
1734: PPUSH
1735: LD_STRING 13a_
1737: PPUSH
1738: CALL 40247 0 3
1742: ST_TO_ADDR
// if Kapitsova then
1743: LD_EXP 31
1747: IFFALSE 1765
// tmp := tmp ^ Kapitsova ;
1749: LD_ADDR_VAR 0 5
1753: PUSH
1754: LD_VAR 0 5
1758: PUSH
1759: LD_EXP 31
1763: ADD
1764: ST_TO_ADDR
// Lipshchin := PrepareUnit ( Lipshchin , ( not debug ) , 13a_ ) ;
1765: LD_ADDR_EXP 32
1769: PUSH
1770: LD_STRING Lipshchin
1772: PPUSH
1773: LD_EXP 1
1777: NOT
1778: PPUSH
1779: LD_STRING 13a_
1781: PPUSH
1782: CALL 40247 0 3
1786: ST_TO_ADDR
// if Lipshchin then
1787: LD_EXP 32
1791: IFFALSE 1809
// tmp := tmp ^ Lipshchin ;
1793: LD_ADDR_VAR 0 5
1797: PUSH
1798: LD_VAR 0 5
1802: PUSH
1803: LD_EXP 32
1807: ADD
1808: ST_TO_ADDR
// Petrovova := PrepareUnit ( Petrovova , ( not debug ) , 13a_ ) ;
1809: LD_ADDR_EXP 33
1813: PUSH
1814: LD_STRING Petrovova
1816: PPUSH
1817: LD_EXP 1
1821: NOT
1822: PPUSH
1823: LD_STRING 13a_
1825: PPUSH
1826: CALL 40247 0 3
1830: ST_TO_ADDR
// if Petrovova then
1831: LD_EXP 33
1835: IFFALSE 1853
// tmp := tmp ^ Petrovova ;
1837: LD_ADDR_VAR 0 5
1841: PUSH
1842: LD_VAR 0 5
1846: PUSH
1847: LD_EXP 33
1851: ADD
1852: ST_TO_ADDR
// Kovalyuk := PrepareUnit ( Kovalyuk , ( not debug ) , 13a_ ) ;
1853: LD_ADDR_EXP 34
1857: PUSH
1858: LD_STRING Kovalyuk
1860: PPUSH
1861: LD_EXP 1
1865: NOT
1866: PPUSH
1867: LD_STRING 13a_
1869: PPUSH
1870: CALL 40247 0 3
1874: ST_TO_ADDR
// if Kovalyuk then
1875: LD_EXP 34
1879: IFFALSE 1897
// tmp := tmp ^ Kovalyuk ;
1881: LD_ADDR_VAR 0 5
1885: PUSH
1886: LD_VAR 0 5
1890: PUSH
1891: LD_EXP 34
1895: ADD
1896: ST_TO_ADDR
// Kuzmov := PrepareUnit ( Kuzmov , ( not debug ) , 13a_ ) ;
1897: LD_ADDR_EXP 35
1901: PUSH
1902: LD_STRING Kuzmov
1904: PPUSH
1905: LD_EXP 1
1909: NOT
1910: PPUSH
1911: LD_STRING 13a_
1913: PPUSH
1914: CALL 40247 0 3
1918: ST_TO_ADDR
// if Kuzmov then
1919: LD_EXP 35
1923: IFFALSE 1941
// tmp := tmp ^ Kuzmov ;
1925: LD_ADDR_VAR 0 5
1929: PUSH
1930: LD_VAR 0 5
1934: PUSH
1935: LD_EXP 35
1939: ADD
1940: ST_TO_ADDR
// Karamazov := PrepareUnit ( Karamazov , ( not debug ) , 13a_ ) ;
1941: LD_ADDR_EXP 36
1945: PUSH
1946: LD_STRING Karamazov
1948: PPUSH
1949: LD_EXP 1
1953: NOT
1954: PPUSH
1955: LD_STRING 13a_
1957: PPUSH
1958: CALL 40247 0 3
1962: ST_TO_ADDR
// if Karamazov then
1963: LD_EXP 36
1967: IFFALSE 1985
// tmp := tmp ^ Karamazov ;
1969: LD_ADDR_VAR 0 5
1973: PUSH
1974: LD_VAR 0 5
1978: PUSH
1979: LD_EXP 36
1983: ADD
1984: ST_TO_ADDR
// Belkov := PrepareUnit ( Belkov , ( not debug ) , 13a_ ) ;
1985: LD_ADDR_EXP 38
1989: PUSH
1990: LD_STRING Belkov
1992: PPUSH
1993: LD_EXP 1
1997: NOT
1998: PPUSH
1999: LD_STRING 13a_
2001: PPUSH
2002: CALL 40247 0 3
2006: ST_TO_ADDR
// if Belkov then
2007: LD_EXP 38
2011: IFFALSE 2029
// tmp := tmp ^ Belkov ;
2013: LD_ADDR_VAR 0 5
2017: PUSH
2018: LD_VAR 0 5
2022: PUSH
2023: LD_EXP 38
2027: ADD
2028: ST_TO_ADDR
// Gnyevko := PrepareUnit ( Gnyevko , ( not debug ) , 13a_ ) ;
2029: LD_ADDR_EXP 39
2033: PUSH
2034: LD_STRING Gnyevko
2036: PPUSH
2037: LD_EXP 1
2041: NOT
2042: PPUSH
2043: LD_STRING 13a_
2045: PPUSH
2046: CALL 40247 0 3
2050: ST_TO_ADDR
// if Gnyevko then
2051: LD_EXP 39
2055: IFFALSE 2073
// tmp := tmp ^ Gnyevko ;
2057: LD_ADDR_VAR 0 5
2061: PUSH
2062: LD_VAR 0 5
2066: PUSH
2067: LD_EXP 39
2071: ADD
2072: ST_TO_ADDR
// if not Lisa then
2073: LD_EXP 8
2077: NOT
2078: IFFALSE 2124
// begin Lisa := PrepareUnit ( Lisa , ( not debug ) , 13a_ ) ;
2080: LD_ADDR_EXP 8
2084: PUSH
2085: LD_STRING Lisa
2087: PPUSH
2088: LD_EXP 1
2092: NOT
2093: PPUSH
2094: LD_STRING 13a_
2096: PPUSH
2097: CALL 40247 0 3
2101: ST_TO_ADDR
// if Lisa then
2102: LD_EXP 8
2106: IFFALSE 2124
// tmp := tmp ^ Lisa ;
2108: LD_ADDR_VAR 0 5
2112: PUSH
2113: LD_VAR 0 5
2117: PUSH
2118: LD_EXP 8
2122: ADD
2123: ST_TO_ADDR
// end ; if not Donaldson then
2124: LD_EXP 9
2128: NOT
2129: IFFALSE 2175
// begin Donaldson := PrepareUnit ( Donaldson , ( not debug ) , 13a_ ) ;
2131: LD_ADDR_EXP 9
2135: PUSH
2136: LD_STRING Donaldson
2138: PPUSH
2139: LD_EXP 1
2143: NOT
2144: PPUSH
2145: LD_STRING 13a_
2147: PPUSH
2148: CALL 40247 0 3
2152: ST_TO_ADDR
// if Donaldson then
2153: LD_EXP 9
2157: IFFALSE 2175
// tmp := tmp ^ Donaldson ;
2159: LD_ADDR_VAR 0 5
2163: PUSH
2164: LD_VAR 0 5
2168: PUSH
2169: LD_EXP 9
2173: ADD
2174: ST_TO_ADDR
// end ; if not Bobby then
2175: LD_EXP 10
2179: NOT
2180: IFFALSE 2226
// begin Bobby := PrepareUnit ( Bobby , ( not debug ) , 13a_ ) ;
2182: LD_ADDR_EXP 10
2186: PUSH
2187: LD_STRING Bobby
2189: PPUSH
2190: LD_EXP 1
2194: NOT
2195: PPUSH
2196: LD_STRING 13a_
2198: PPUSH
2199: CALL 40247 0 3
2203: ST_TO_ADDR
// if Bobby then
2204: LD_EXP 10
2208: IFFALSE 2226
// tmp := tmp ^ Bobby ;
2210: LD_ADDR_VAR 0 5
2214: PUSH
2215: LD_VAR 0 5
2219: PUSH
2220: LD_EXP 10
2224: ADD
2225: ST_TO_ADDR
// end ; if not Cyrus then
2226: LD_EXP 11
2230: NOT
2231: IFFALSE 2277
// begin Cyrus := PrepareUnit ( Cyrus , ( not debug ) , 13a_ ) ;
2233: LD_ADDR_EXP 11
2237: PUSH
2238: LD_STRING Cyrus
2240: PPUSH
2241: LD_EXP 1
2245: NOT
2246: PPUSH
2247: LD_STRING 13a_
2249: PPUSH
2250: CALL 40247 0 3
2254: ST_TO_ADDR
// if Cyrus then
2255: LD_EXP 11
2259: IFFALSE 2277
// tmp := tmp ^ Cyrus ;
2261: LD_ADDR_VAR 0 5
2265: PUSH
2266: LD_VAR 0 5
2270: PUSH
2271: LD_EXP 11
2275: ADD
2276: ST_TO_ADDR
// end ; if not Brown then
2277: LD_EXP 13
2281: NOT
2282: IFFALSE 2328
// begin Brown := PrepareUnit ( Brown , ( not debug ) , 13a_ ) ;
2284: LD_ADDR_EXP 13
2288: PUSH
2289: LD_STRING Brown
2291: PPUSH
2292: LD_EXP 1
2296: NOT
2297: PPUSH
2298: LD_STRING 13a_
2300: PPUSH
2301: CALL 40247 0 3
2305: ST_TO_ADDR
// if Brown then
2306: LD_EXP 13
2310: IFFALSE 2328
// tmp := tmp ^ Brown ;
2312: LD_ADDR_VAR 0 5
2316: PUSH
2317: LD_VAR 0 5
2321: PUSH
2322: LD_EXP 13
2326: ADD
2327: ST_TO_ADDR
// end ; if not Gladstone then
2328: LD_EXP 14
2332: NOT
2333: IFFALSE 2379
// begin Gladstone := PrepareUnit ( Gladstone , ( not debug ) , 13a_ ) ;
2335: LD_ADDR_EXP 14
2339: PUSH
2340: LD_STRING Gladstone
2342: PPUSH
2343: LD_EXP 1
2347: NOT
2348: PPUSH
2349: LD_STRING 13a_
2351: PPUSH
2352: CALL 40247 0 3
2356: ST_TO_ADDR
// if Gladstone then
2357: LD_EXP 14
2361: IFFALSE 2379
// tmp := tmp ^ Gladstone ;
2363: LD_ADDR_VAR 0 5
2367: PUSH
2368: LD_VAR 0 5
2372: PUSH
2373: LD_EXP 14
2377: ADD
2378: ST_TO_ADDR
// end ; if not Cornel then
2379: LD_EXP 16
2383: NOT
2384: IFFALSE 2430
// begin Cornel := PrepareUnit ( Cornel , ( not debug ) , 13a_ ) ;
2386: LD_ADDR_EXP 16
2390: PUSH
2391: LD_STRING Cornel
2393: PPUSH
2394: LD_EXP 1
2398: NOT
2399: PPUSH
2400: LD_STRING 13a_
2402: PPUSH
2403: CALL 40247 0 3
2407: ST_TO_ADDR
// if Cornel then
2408: LD_EXP 16
2412: IFFALSE 2430
// tmp := tmp ^ Cornel ;
2414: LD_ADDR_VAR 0 5
2418: PUSH
2419: LD_VAR 0 5
2423: PUSH
2424: LD_EXP 16
2428: ADD
2429: ST_TO_ADDR
// end ; if not Houten then
2430: LD_EXP 15
2434: NOT
2435: IFFALSE 2481
// begin Houten := PrepareUnit ( Houten , ( not debug ) , 13a_ ) ;
2437: LD_ADDR_EXP 15
2441: PUSH
2442: LD_STRING Houten
2444: PPUSH
2445: LD_EXP 1
2449: NOT
2450: PPUSH
2451: LD_STRING 13a_
2453: PPUSH
2454: CALL 40247 0 3
2458: ST_TO_ADDR
// if Houten then
2459: LD_EXP 15
2463: IFFALSE 2481
// tmp := tmp ^ Houten ;
2465: LD_ADDR_VAR 0 5
2469: PUSH
2470: LD_VAR 0 5
2474: PUSH
2475: LD_EXP 15
2479: ADD
2480: ST_TO_ADDR
// end ; if not Gary then
2481: LD_EXP 17
2485: NOT
2486: IFFALSE 2532
// begin Gary := PrepareUnit ( Gary , ( not debug ) , 13a_ ) ;
2488: LD_ADDR_EXP 17
2492: PUSH
2493: LD_STRING Gary
2495: PPUSH
2496: LD_EXP 1
2500: NOT
2501: PPUSH
2502: LD_STRING 13a_
2504: PPUSH
2505: CALL 40247 0 3
2509: ST_TO_ADDR
// if Gary then
2510: LD_EXP 17
2514: IFFALSE 2532
// tmp := tmp ^ Gary ;
2516: LD_ADDR_VAR 0 5
2520: PUSH
2521: LD_VAR 0 5
2525: PUSH
2526: LD_EXP 17
2530: ADD
2531: ST_TO_ADDR
// end ; if not Kikuchi then
2532: LD_EXP 19
2536: NOT
2537: IFFALSE 2583
// begin Kikuchi := PrepareUnit ( Kikuchi , ( not debug ) , 13a_ ) ;
2539: LD_ADDR_EXP 19
2543: PUSH
2544: LD_STRING Kikuchi
2546: PPUSH
2547: LD_EXP 1
2551: NOT
2552: PPUSH
2553: LD_STRING 13a_
2555: PPUSH
2556: CALL 40247 0 3
2560: ST_TO_ADDR
// if Kikuchi then
2561: LD_EXP 19
2565: IFFALSE 2583
// tmp := tmp ^ Kikuchi ;
2567: LD_ADDR_VAR 0 5
2571: PUSH
2572: LD_VAR 0 5
2576: PUSH
2577: LD_EXP 19
2581: ADD
2582: ST_TO_ADDR
// end ; tmp := tmp union CreateCharacterSet ( 13a_others ) ;
2583: LD_ADDR_VAR 0 5
2587: PUSH
2588: LD_VAR 0 5
2592: PUSH
2593: LD_STRING 13a_others
2595: PPUSH
2596: CALL_OW 31
2600: UNION
2601: ST_TO_ADDR
// tmp := tmp diff 0 ;
2602: LD_ADDR_VAR 0 5
2606: PUSH
2607: LD_VAR 0 5
2611: PUSH
2612: LD_INT 0
2614: DIFF
2615: ST_TO_ADDR
// if tmp < 15 then
2616: LD_VAR 0 5
2620: PUSH
2621: LD_INT 15
2623: LESS
2624: IFFALSE 2712
// for i = 15 downto tmp do
2626: LD_ADDR_VAR 0 2
2630: PUSH
2631: DOUBLE
2632: LD_INT 15
2634: INC
2635: ST_TO_ADDR
2636: LD_VAR 0 5
2640: PUSH
2641: FOR_DOWNTO
2642: IFFALSE 2710
// begin uc_nation := [ 1 , 3 ] [ rand ( 1 , 2 ) ] ;
2644: LD_ADDR_OWVAR 21
2648: PUSH
2649: LD_INT 1
2651: PUSH
2652: LD_INT 3
2654: PUSH
2655: EMPTY
2656: LIST
2657: LIST
2658: PUSH
2659: LD_INT 1
2661: PPUSH
2662: LD_INT 2
2664: PPUSH
2665: CALL_OW 12
2669: ARRAY
2670: ST_TO_ADDR
// PrepareHuman ( false , rand ( 1 , 4 ) , 8 ) ;
2671: LD_INT 0
2673: PPUSH
2674: LD_INT 1
2676: PPUSH
2677: LD_INT 4
2679: PPUSH
2680: CALL_OW 12
2684: PPUSH
2685: LD_INT 8
2687: PPUSH
2688: CALL_OW 380
// tmp := tmp ^ CreateHuman ;
2692: LD_ADDR_VAR 0 5
2696: PUSH
2697: LD_VAR 0 5
2701: PUSH
2702: CALL_OW 44
2706: ADD
2707: ST_TO_ADDR
// end ;
2708: GO 2641
2710: POP
2711: POP
// if not debug then
2712: LD_EXP 1
2716: NOT
2717: IFFALSE 2883
// selected = CharacterSelection (  , [ 12 , 11 , 10 ] [ Difficulty ] , [ 12 , 11 , 10 ] [ Difficulty ] , [ sel_dont_change_class , JMM , Burlak , Roth , Joan , Gossudarov , sel_not_hired , sel_changeable , sel_change_class ] ^ tmp , [ class_soldier , class_scientistic , [ class_engineer , 1 ] , class_mechanic , [ class_sniper , 0 , 3 ] , [ class_bazooker , 0 , 3 ] ] ) else
2719: LD_ADDR_VAR 0 4
2723: PUSH
2724: LD_STRING 
2726: PPUSH
2727: LD_INT 12
2729: PUSH
2730: LD_INT 11
2732: PUSH
2733: LD_INT 10
2735: PUSH
2736: EMPTY
2737: LIST
2738: LIST
2739: LIST
2740: PUSH
2741: LD_OWVAR 67
2745: ARRAY
2746: PPUSH
2747: LD_INT 12
2749: PUSH
2750: LD_INT 11
2752: PUSH
2753: LD_INT 10
2755: PUSH
2756: EMPTY
2757: LIST
2758: LIST
2759: LIST
2760: PUSH
2761: LD_OWVAR 67
2765: ARRAY
2766: PPUSH
2767: LD_INT -6
2769: PUSH
2770: LD_EXP 6
2774: PUSH
2775: LD_EXP 37
2779: PUSH
2780: LD_EXP 7
2784: PUSH
2785: LD_EXP 21
2789: PUSH
2790: LD_EXP 23
2794: PUSH
2795: LD_INT -2
2797: PUSH
2798: LD_INT -3
2800: PUSH
2801: LD_INT -5
2803: PUSH
2804: EMPTY
2805: LIST
2806: LIST
2807: LIST
2808: LIST
2809: LIST
2810: LIST
2811: LIST
2812: LIST
2813: LIST
2814: PUSH
2815: LD_VAR 0 5
2819: ADD
2820: PPUSH
2821: LD_INT 1
2823: PUSH
2824: LD_INT 4
2826: PUSH
2827: LD_INT 2
2829: PUSH
2830: LD_INT 1
2832: PUSH
2833: EMPTY
2834: LIST
2835: LIST
2836: PUSH
2837: LD_INT 3
2839: PUSH
2840: LD_INT 5
2842: PUSH
2843: LD_INT 0
2845: PUSH
2846: LD_INT 3
2848: PUSH
2849: EMPTY
2850: LIST
2851: LIST
2852: LIST
2853: PUSH
2854: LD_INT 9
2856: PUSH
2857: LD_INT 0
2859: PUSH
2860: LD_INT 3
2862: PUSH
2863: EMPTY
2864: LIST
2865: LIST
2866: LIST
2867: PUSH
2868: EMPTY
2869: LIST
2870: LIST
2871: LIST
2872: LIST
2873: LIST
2874: LIST
2875: PPUSH
2876: CALL_OW 42
2880: ST_TO_ADDR
2881: GO 2962
// selected := [ Titov , Fadeev , Dolgov , Petrosyan , Scholtze , Oblukov , Kapitsova , Lipshchin , Petrovova , Kovalyuk , Kuzmov , Karamazov ] ;
2883: LD_ADDR_VAR 0 4
2887: PUSH
2888: LD_EXP 25
2892: PUSH
2893: LD_EXP 26
2897: PUSH
2898: LD_EXP 27
2902: PUSH
2903: LD_EXP 28
2907: PUSH
2908: LD_EXP 29
2912: PUSH
2913: LD_EXP 30
2917: PUSH
2918: LD_EXP 31
2922: PUSH
2923: LD_EXP 32
2927: PUSH
2928: LD_EXP 33
2932: PUSH
2933: LD_EXP 34
2937: PUSH
2938: LD_EXP 35
2942: PUSH
2943: LD_EXP 36
2947: PUSH
2948: EMPTY
2949: LIST
2950: LIST
2951: LIST
2952: LIST
2953: LIST
2954: LIST
2955: LIST
2956: LIST
2957: LIST
2958: LIST
2959: LIST
2960: LIST
2961: ST_TO_ADDR
// uc_nation := 1 ;
2962: LD_ADDR_OWVAR 21
2966: PUSH
2967: LD_INT 1
2969: ST_TO_ADDR
// PrepareVehicle ( us_morphling , engine_siberite , control_manual , us_heavy_gun , 100 ) ;
2970: LD_INT 5
2972: PPUSH
2973: LD_INT 3
2975: PPUSH
2976: LD_INT 1
2978: PPUSH
2979: LD_INT 6
2981: PPUSH
2982: LD_INT 100
2984: PPUSH
2985: CALL 46998 0 5
// veh := CreateVehicle ;
2989: LD_ADDR_VAR 0 3
2993: PUSH
2994: CALL_OW 45
2998: ST_TO_ADDR
// SetMark ( veh , - 7 ) ;
2999: LD_VAR 0 3
3003: PPUSH
3004: LD_INT 7
3006: NEG
3007: PPUSH
3008: CALL_OW 242
// SetDir ( veh , 3 ) ;
3012: LD_VAR 0 3
3016: PPUSH
3017: LD_INT 3
3019: PPUSH
3020: CALL_OW 233
// PlaceUnitArea ( veh , allianceJMMSpawnArea , false ) ;
3024: LD_VAR 0 3
3028: PPUSH
3029: LD_INT 31
3031: PPUSH
3032: LD_INT 0
3034: PPUSH
3035: CALL_OW 49
// PlaceHumanInUnit ( JMM , veh ) ;
3039: LD_EXP 6
3043: PPUSH
3044: LD_VAR 0 3
3048: PPUSH
3049: CALL_OW 52
// uc_nation := 3 ;
3053: LD_ADDR_OWVAR 21
3057: PUSH
3058: LD_INT 3
3060: ST_TO_ADDR
// PrepareVehicle ( ru_medium_tracked , engine_siberite , control_manual , ru_rocket_launcher , 100 ) ;
3061: LD_INT 22
3063: PPUSH
3064: LD_INT 3
3066: PPUSH
3067: LD_INT 1
3069: PPUSH
3070: LD_INT 45
3072: PPUSH
3073: LD_INT 100
3075: PPUSH
3076: CALL 46998 0 5
// veh := CreateVehicle ;
3080: LD_ADDR_VAR 0 3
3084: PUSH
3085: CALL_OW 45
3089: ST_TO_ADDR
// SetMark ( veh , - 7 ) ;
3090: LD_VAR 0 3
3094: PPUSH
3095: LD_INT 7
3097: NEG
3098: PPUSH
3099: CALL_OW 242
// SetDir ( veh , 3 ) ;
3103: LD_VAR 0 3
3107: PPUSH
3108: LD_INT 3
3110: PPUSH
3111: CALL_OW 233
// PlaceUnitArea ( veh , allianceJMMSpawnArea , false ) ;
3115: LD_VAR 0 3
3119: PPUSH
3120: LD_INT 31
3122: PPUSH
3123: LD_INT 0
3125: PPUSH
3126: CALL_OW 49
// PlaceHumanInUnit ( Burlak , veh ) ;
3130: LD_EXP 37
3134: PPUSH
3135: LD_VAR 0 3
3139: PPUSH
3140: CALL_OW 52
// for i in selected do
3144: LD_ADDR_VAR 0 2
3148: PUSH
3149: LD_VAR 0 4
3153: PUSH
3154: FOR_IN
3155: IFFALSE 3713
// begin uc_nation := GetNation ( i ) ;
3157: LD_ADDR_OWVAR 21
3161: PUSH
3162: LD_VAR 0 2
3166: PPUSH
3167: CALL_OW 248
3171: ST_TO_ADDR
// if i in [ Lisa , Donaldson , Cyrus , Bobby ] then
3172: LD_VAR 0 2
3176: PUSH
3177: LD_EXP 8
3181: PUSH
3182: LD_EXP 9
3186: PUSH
3187: LD_EXP 11
3191: PUSH
3192: LD_EXP 10
3196: PUSH
3197: EMPTY
3198: LIST
3199: LIST
3200: LIST
3201: LIST
3202: IN
3203: IFFALSE 3226
// PrepareVehicle ( us_morphling , engine_siberite , control_manual , us_heavy_gun , 100 ) else
3205: LD_INT 5
3207: PPUSH
3208: LD_INT 3
3210: PPUSH
3211: LD_INT 1
3213: PPUSH
3214: LD_INT 6
3216: PPUSH
3217: LD_INT 100
3219: PPUSH
3220: CALL 46998 0 5
3224: GO 3660
// if i in [ Oblukov , Kuzmov , Petrovova , Titov ] then
3226: LD_VAR 0 2
3230: PUSH
3231: LD_EXP 30
3235: PUSH
3236: LD_EXP 35
3240: PUSH
3241: LD_EXP 33
3245: PUSH
3246: LD_EXP 25
3250: PUSH
3251: EMPTY
3252: LIST
3253: LIST
3254: LIST
3255: LIST
3256: IN
3257: IFFALSE 3288
// PrepareVehicle ( ru_heavy_tracked , engine_combustion , control_manual , ru_heavy_gun , rand ( 65 , 75 ) ) else
3259: LD_INT 24
3261: PPUSH
3262: LD_INT 1
3264: PPUSH
3265: LD_INT 1
3267: PPUSH
3268: LD_INT 46
3270: PPUSH
3271: LD_INT 65
3273: PPUSH
3274: LD_INT 75
3276: PPUSH
3277: CALL_OW 12
3281: PPUSH
3282: CALL 46998 0 5
3286: GO 3660
// if i = Karamazov then
3288: LD_VAR 0 2
3292: PUSH
3293: LD_EXP 36
3297: EQUAL
3298: IFFALSE 3321
// PrepareVehicle ( ru_medium_tracked , engine_siberite , control_manual , ru_crane , 100 ) else
3300: LD_INT 22
3302: PPUSH
3303: LD_INT 3
3305: PPUSH
3306: LD_INT 1
3308: PPUSH
3309: LD_INT 52
3311: PPUSH
3312: LD_INT 100
3314: PPUSH
3315: CALL 46998 0 5
3319: GO 3660
// if i = Brown then
3321: LD_VAR 0 2
3325: PUSH
3326: LD_EXP 13
3330: EQUAL
3331: IFFALSE 3354
// PrepareVehicle ( us_medium_tracked , engine_siberite , control_manual , us_crane , 100 ) else
3333: LD_INT 3
3335: PPUSH
3336: LD_INT 3
3338: PPUSH
3339: LD_INT 1
3341: PPUSH
3342: LD_INT 13
3344: PPUSH
3345: LD_INT 100
3347: PPUSH
3348: CALL 46998 0 5
3352: GO 3660
// if uc_nation = nation_american then
3354: LD_OWVAR 21
3358: PUSH
3359: LD_INT 1
3361: EQUAL
3362: IFFALSE 3513
// begin PrepareVehicle ( [ us_medium_tracked , us_morphling , us_morphling ] [ uc_nation mod 3 + 1 ] , [ engine_combustion , engine_siberite , engine_combustion ] [ uc_nation mod 3 + 1 ] , control_manual , [ [ us_radar , us_gatling_gun , us_double_gun ] , [ us_heavy_gun , us_rocket_launcher , us_laser ] , [ us_heavy_gun , us_laser , us_cargo_bay ] ] [ uc_nation mod 3 + 1 ] [ rand ( 1 , 3 ) ] , rand ( 65 , 75 ) ) ;
3364: LD_INT 3
3366: PUSH
3367: LD_INT 5
3369: PUSH
3370: LD_INT 5
3372: PUSH
3373: EMPTY
3374: LIST
3375: LIST
3376: LIST
3377: PUSH
3378: LD_OWVAR 21
3382: PUSH
3383: LD_INT 3
3385: MOD
3386: PUSH
3387: LD_INT 1
3389: PLUS
3390: ARRAY
3391: PPUSH
3392: LD_INT 1
3394: PUSH
3395: LD_INT 3
3397: PUSH
3398: LD_INT 1
3400: PUSH
3401: EMPTY
3402: LIST
3403: LIST
3404: LIST
3405: PUSH
3406: LD_OWVAR 21
3410: PUSH
3411: LD_INT 3
3413: MOD
3414: PUSH
3415: LD_INT 1
3417: PLUS
3418: ARRAY
3419: PPUSH
3420: LD_INT 1
3422: PPUSH
3423: LD_INT 11
3425: PUSH
3426: LD_INT 4
3428: PUSH
3429: LD_INT 5
3431: PUSH
3432: EMPTY
3433: LIST
3434: LIST
3435: LIST
3436: PUSH
3437: LD_INT 6
3439: PUSH
3440: LD_INT 7
3442: PUSH
3443: LD_INT 9
3445: PUSH
3446: EMPTY
3447: LIST
3448: LIST
3449: LIST
3450: PUSH
3451: LD_INT 6
3453: PUSH
3454: LD_INT 9
3456: PUSH
3457: LD_INT 12
3459: PUSH
3460: EMPTY
3461: LIST
3462: LIST
3463: LIST
3464: PUSH
3465: EMPTY
3466: LIST
3467: LIST
3468: LIST
3469: PUSH
3470: LD_OWVAR 21
3474: PUSH
3475: LD_INT 3
3477: MOD
3478: PUSH
3479: LD_INT 1
3481: PLUS
3482: ARRAY
3483: PUSH
3484: LD_INT 1
3486: PPUSH
3487: LD_INT 3
3489: PPUSH
3490: CALL_OW 12
3494: ARRAY
3495: PPUSH
3496: LD_INT 65
3498: PPUSH
3499: LD_INT 75
3501: PPUSH
3502: CALL_OW 12
3506: PPUSH
3507: CALL 46998 0 5
// end else
3511: GO 3660
// begin PrepareVehicle ( [ ru_medium_tracked , ru_heavy_wheeled , ru_heavy_wheeled ] [ uc_nation mod 3 + 1 ] , [ engine_combustion , engine_siberite , engine_combustion ] [ uc_nation mod 3 + 1 ] , control_manual , [ [ ru_rocket_launcher , ru_gatling_gun , ru_gun ] , [ ru_heavy_gun , ru_rocket_launcher , ru_gun ] , [ ru_heavy_gun , ru_gatling_gun , ru_rocket_launcher ] ] [ uc_nation mod 3 + 1 ] [ rand ( 1 , 3 ) ] , rand ( 65 , 75 ) ) ;
3513: LD_INT 22
3515: PUSH
3516: LD_INT 23
3518: PUSH
3519: LD_INT 23
3521: PUSH
3522: EMPTY
3523: LIST
3524: LIST
3525: LIST
3526: PUSH
3527: LD_OWVAR 21
3531: PUSH
3532: LD_INT 3
3534: MOD
3535: PUSH
3536: LD_INT 1
3538: PLUS
3539: ARRAY
3540: PPUSH
3541: LD_INT 1
3543: PUSH
3544: LD_INT 3
3546: PUSH
3547: LD_INT 1
3549: PUSH
3550: EMPTY
3551: LIST
3552: LIST
3553: LIST
3554: PUSH
3555: LD_OWVAR 21
3559: PUSH
3560: LD_INT 3
3562: MOD
3563: PUSH
3564: LD_INT 1
3566: PLUS
3567: ARRAY
3568: PPUSH
3569: LD_INT 1
3571: PPUSH
3572: LD_INT 45
3574: PUSH
3575: LD_INT 43
3577: PUSH
3578: LD_INT 44
3580: PUSH
3581: EMPTY
3582: LIST
3583: LIST
3584: LIST
3585: PUSH
3586: LD_INT 46
3588: PUSH
3589: LD_INT 45
3591: PUSH
3592: LD_INT 44
3594: PUSH
3595: EMPTY
3596: LIST
3597: LIST
3598: LIST
3599: PUSH
3600: LD_INT 46
3602: PUSH
3603: LD_INT 43
3605: PUSH
3606: LD_INT 45
3608: PUSH
3609: EMPTY
3610: LIST
3611: LIST
3612: LIST
3613: PUSH
3614: EMPTY
3615: LIST
3616: LIST
3617: LIST
3618: PUSH
3619: LD_OWVAR 21
3623: PUSH
3624: LD_INT 3
3626: MOD
3627: PUSH
3628: LD_INT 1
3630: PLUS
3631: ARRAY
3632: PUSH
3633: LD_INT 1
3635: PPUSH
3636: LD_INT 3
3638: PPUSH
3639: CALL_OW 12
3643: ARRAY
3644: PPUSH
3645: LD_INT 65
3647: PPUSH
3648: LD_INT 75
3650: PPUSH
3651: CALL_OW 12
3655: PPUSH
3656: CALL 46998 0 5
// end ; veh := CreateVehicle ;
3660: LD_ADDR_VAR 0 3
3664: PUSH
3665: CALL_OW 45
3669: ST_TO_ADDR
// SetDir ( veh , 3 ) ;
3670: LD_VAR 0 3
3674: PPUSH
3675: LD_INT 3
3677: PPUSH
3678: CALL_OW 233
// PlaceUnitArea ( veh , allianceSpawnArea , false ) ;
3682: LD_VAR 0 3
3686: PPUSH
3687: LD_INT 30
3689: PPUSH
3690: LD_INT 0
3692: PPUSH
3693: CALL_OW 49
// PlaceHumanInUnit ( i , veh ) ;
3697: LD_VAR 0 2
3701: PPUSH
3702: LD_VAR 0 3
3706: PPUSH
3707: CALL_OW 52
// end ;
3711: GO 3154
3713: POP
3714: POP
// if LoadVariable ( 11_artifact_captured , 0 ) then
3715: LD_STRING 11_artifact_captured
3717: PPUSH
3718: LD_INT 0
3720: PPUSH
3721: CALL_OW 30
3725: IFFALSE 3811
// begin uc_nation := nation_american ;
3727: LD_ADDR_OWVAR 21
3731: PUSH
3732: LD_INT 1
3734: ST_TO_ADDR
// PrepareVehicle ( us_medium_tracked , engine_siberite , control_computer , us_cargo_bay , 100 ) ;
3735: LD_INT 3
3737: PPUSH
3738: LD_INT 3
3740: PPUSH
3741: LD_INT 3
3743: PPUSH
3744: LD_INT 12
3746: PPUSH
3747: LD_INT 100
3749: PPUSH
3750: CALL 46998 0 5
// veh := CreateVehicle ;
3754: LD_ADDR_VAR 0 3
3758: PUSH
3759: CALL_OW 45
3763: ST_TO_ADDR
// SetDir ( veh , 3 ) ;
3764: LD_VAR 0 3
3768: PPUSH
3769: LD_INT 3
3771: PPUSH
3772: CALL_OW 233
// PlaceUnitXY ( veh , 198 , 22 , false ) ;
3776: LD_VAR 0 3
3780: PPUSH
3781: LD_INT 198
3783: PPUSH
3784: LD_INT 22
3786: PPUSH
3787: LD_INT 0
3789: PPUSH
3790: CALL_OW 48
// SetCargo ( veh , mat_artifact , 50 ) ;
3794: LD_VAR 0 3
3798: PPUSH
3799: LD_INT 4
3801: PPUSH
3802: LD_INT 50
3804: PPUSH
3805: CALL_OW 290
// end else
3809: GO 3830
// begin CreateResourcesXY ( mat_artifact , 267 , 226 , 5 , false ) ;
3811: LD_INT 4
3813: PPUSH
3814: LD_INT 267
3816: PPUSH
3817: LD_INT 226
3819: PPUSH
3820: LD_INT 5
3822: PPUSH
3823: LD_INT 0
3825: PPUSH
3826: CALL_OW 58
// end ; uc_nation := nation_american ;
3830: LD_ADDR_OWVAR 21
3834: PUSH
3835: LD_INT 1
3837: ST_TO_ADDR
// PrepareVehicle ( us_medium_tracked , engine_siberite , control_computer , us_cargo_bay , 100 ) ;
3838: LD_INT 3
3840: PPUSH
3841: LD_INT 3
3843: PPUSH
3844: LD_INT 3
3846: PPUSH
3847: LD_INT 12
3849: PPUSH
3850: LD_INT 100
3852: PPUSH
3853: CALL 46998 0 5
// veh := CreateVehicle ;
3857: LD_ADDR_VAR 0 3
3861: PUSH
3862: CALL_OW 45
3866: ST_TO_ADDR
// SetDir ( veh , 3 ) ;
3867: LD_VAR 0 3
3871: PPUSH
3872: LD_INT 3
3874: PPUSH
3875: CALL_OW 233
// PlaceUnitXY ( veh , 218 , 23 , false ) ;
3879: LD_VAR 0 3
3883: PPUSH
3884: LD_INT 218
3886: PPUSH
3887: LD_INT 23
3889: PPUSH
3890: LD_INT 0
3892: PPUSH
3893: CALL_OW 48
// SetCargo ( veh , mat_artifact , 30 ) ;
3897: LD_VAR 0 3
3901: PPUSH
3902: LD_INT 4
3904: PPUSH
3905: LD_INT 30
3907: PPUSH
3908: CALL_OW 290
// uc_nation := nation_russian ;
3912: LD_ADDR_OWVAR 21
3916: PUSH
3917: LD_INT 3
3919: ST_TO_ADDR
// PrepareVehicle ( ru_medium_tracked , engine_siberite , control_computer , ru_cargo_bay , 100 ) ;
3920: LD_INT 22
3922: PPUSH
3923: LD_INT 3
3925: PPUSH
3926: LD_INT 3
3928: PPUSH
3929: LD_INT 51
3931: PPUSH
3932: LD_INT 100
3934: PPUSH
3935: CALL 46998 0 5
// veh := CreateVehicle ;
3939: LD_ADDR_VAR 0 3
3943: PUSH
3944: CALL_OW 45
3948: ST_TO_ADDR
// SetDir ( veh , 3 ) ;
3949: LD_VAR 0 3
3953: PPUSH
3954: LD_INT 3
3956: PPUSH
3957: CALL_OW 233
// PlaceUnitXY ( veh , 214 , 20 , false ) ;
3961: LD_VAR 0 3
3965: PPUSH
3966: LD_INT 214
3968: PPUSH
3969: LD_INT 20
3971: PPUSH
3972: LD_INT 0
3974: PPUSH
3975: CALL_OW 48
// SetCargo ( veh , mat_artifact , 40 ) ;
3979: LD_VAR 0 3
3983: PPUSH
3984: LD_INT 4
3986: PPUSH
3987: LD_INT 40
3989: PPUSH
3990: CALL_OW 290
// end ; end_of_file
3994: LD_VAR 0 1
3998: RET
// export Powell ; export function PrepareAmerican ; var i , b , veh , cl , tmp , depot , lab , armoury , workshop ; begin
3999: LD_INT 0
4001: PPUSH
4002: PPUSH
4003: PPUSH
4004: PPUSH
4005: PPUSH
4006: PPUSH
4007: PPUSH
4008: PPUSH
4009: PPUSH
4010: PPUSH
// uc_side := 1 ;
4011: LD_ADDR_OWVAR 20
4015: PUSH
4016: LD_INT 1
4018: ST_TO_ADDR
// uc_nation := 1 ;
4019: LD_ADDR_OWVAR 21
4023: PUSH
4024: LD_INT 1
4026: ST_TO_ADDR
// SetResourceType ( GetBase ( am_depot ) , mat_cans , 25500 ) ;
4027: LD_INT 387
4029: PPUSH
4030: CALL_OW 274
4034: PPUSH
4035: LD_INT 1
4037: PPUSH
4038: LD_INT 25500
4040: PPUSH
4041: CALL_OW 277
// SetResourceType ( GetBase ( am_depot ) , mat_oil , 4000 ) ;
4045: LD_INT 387
4047: PPUSH
4048: CALL_OW 274
4052: PPUSH
4053: LD_INT 2
4055: PPUSH
4056: LD_INT 4000
4058: PPUSH
4059: CALL_OW 277
// SetResourceType ( GetBase ( am_depot ) , mat_siberit , 50 ) ;
4063: LD_INT 387
4065: PPUSH
4066: CALL_OW 274
4070: PPUSH
4071: LD_INT 3
4073: PPUSH
4074: LD_INT 50
4076: PPUSH
4077: CALL_OW 277
// SetResourceType ( GetBase ( am_depot2 ) , mat_cans , 7500 ) ;
4081: LD_INT 476
4083: PPUSH
4084: CALL_OW 274
4088: PPUSH
4089: LD_INT 1
4091: PPUSH
4092: LD_INT 7500
4094: PPUSH
4095: CALL_OW 277
// SetResourceType ( GetBase ( am_depot2 ) , mat_oil , 4000 ) ;
4099: LD_INT 476
4101: PPUSH
4102: CALL_OW 274
4106: PPUSH
4107: LD_INT 2
4109: PPUSH
4110: LD_INT 4000
4112: PPUSH
4113: CALL_OW 277
// SetResourceType ( GetBase ( am_depot2 ) , mat_siberit , 10 ) ;
4117: LD_INT 476
4119: PPUSH
4120: CALL_OW 274
4124: PPUSH
4125: LD_INT 3
4127: PPUSH
4128: LD_INT 10
4130: PPUSH
4131: CALL_OW 277
// Powell := NewCharacter ( Powell ) ;
4135: LD_ADDR_EXP 40
4139: PUSH
4140: LD_STRING Powell
4142: PPUSH
4143: CALL_OW 25
4147: ST_TO_ADDR
// PlaceUnitXY ( Powell , 57 , 94 , false ) ;
4148: LD_EXP 40
4152: PPUSH
4153: LD_INT 57
4155: PPUSH
4156: LD_INT 94
4158: PPUSH
4159: LD_INT 0
4161: PPUSH
4162: CALL_OW 48
// ComTurnXY ( Powell , 58 , 94 ) ;
4166: LD_EXP 40
4170: PPUSH
4171: LD_INT 58
4173: PPUSH
4174: LD_INT 94
4176: PPUSH
4177: CALL_OW 118
// tmp := [ ] ;
4181: LD_ADDR_VAR 0 6
4185: PUSH
4186: EMPTY
4187: ST_TO_ADDR
// Lisa := PrepareUnit ( Lisa , ( not debug ) , 12p_ ) ;
4188: LD_ADDR_EXP 8
4192: PUSH
4193: LD_STRING Lisa
4195: PPUSH
4196: LD_EXP 1
4200: NOT
4201: PPUSH
4202: LD_STRING 12p_
4204: PPUSH
4205: CALL 40247 0 3
4209: ST_TO_ADDR
// if Lisa then
4210: LD_EXP 8
4214: IFFALSE 4232
// tmp := tmp ^ Lisa ;
4216: LD_ADDR_VAR 0 6
4220: PUSH
4221: LD_VAR 0 6
4225: PUSH
4226: LD_EXP 8
4230: ADD
4231: ST_TO_ADDR
// Donaldson := PrepareUnit ( Donaldson , ( not debug ) , 12p_ ) ;
4232: LD_ADDR_EXP 9
4236: PUSH
4237: LD_STRING Donaldson
4239: PPUSH
4240: LD_EXP 1
4244: NOT
4245: PPUSH
4246: LD_STRING 12p_
4248: PPUSH
4249: CALL 40247 0 3
4253: ST_TO_ADDR
// if Donaldson then
4254: LD_EXP 9
4258: IFFALSE 4276
// tmp := tmp ^ Donaldson ;
4260: LD_ADDR_VAR 0 6
4264: PUSH
4265: LD_VAR 0 6
4269: PUSH
4270: LD_EXP 9
4274: ADD
4275: ST_TO_ADDR
// Bobby := PrepareUnit ( Bobby , ( not debug ) , 12p_ ) ;
4276: LD_ADDR_EXP 10
4280: PUSH
4281: LD_STRING Bobby
4283: PPUSH
4284: LD_EXP 1
4288: NOT
4289: PPUSH
4290: LD_STRING 12p_
4292: PPUSH
4293: CALL 40247 0 3
4297: ST_TO_ADDR
// if Bobby then
4298: LD_EXP 10
4302: IFFALSE 4320
// tmp := tmp ^ Bobby ;
4304: LD_ADDR_VAR 0 6
4308: PUSH
4309: LD_VAR 0 6
4313: PUSH
4314: LD_EXP 10
4318: ADD
4319: ST_TO_ADDR
// Cyrus := PrepareUnit ( Cyrus , ( not debug ) , 12p_ ) ;
4320: LD_ADDR_EXP 11
4324: PUSH
4325: LD_STRING Cyrus
4327: PPUSH
4328: LD_EXP 1
4332: NOT
4333: PPUSH
4334: LD_STRING 12p_
4336: PPUSH
4337: CALL 40247 0 3
4341: ST_TO_ADDR
// if Cyrus then
4342: LD_EXP 11
4346: IFFALSE 4364
// tmp := tmp ^ Cyrus ;
4348: LD_ADDR_VAR 0 6
4352: PUSH
4353: LD_VAR 0 6
4357: PUSH
4358: LD_EXP 11
4362: ADD
4363: ST_TO_ADDR
// Brown := PrepareUnit ( Brown , ( not debug ) , 12p_ ) ;
4364: LD_ADDR_EXP 13
4368: PUSH
4369: LD_STRING Brown
4371: PPUSH
4372: LD_EXP 1
4376: NOT
4377: PPUSH
4378: LD_STRING 12p_
4380: PPUSH
4381: CALL 40247 0 3
4385: ST_TO_ADDR
// if Brown then
4386: LD_EXP 13
4390: IFFALSE 4408
// tmp := tmp ^ Brown ;
4392: LD_ADDR_VAR 0 6
4396: PUSH
4397: LD_VAR 0 6
4401: PUSH
4402: LD_EXP 13
4406: ADD
4407: ST_TO_ADDR
// Gladstone := PrepareUnit ( Gladstone , ( not debug ) , 12p_ ) ;
4408: LD_ADDR_EXP 14
4412: PUSH
4413: LD_STRING Gladstone
4415: PPUSH
4416: LD_EXP 1
4420: NOT
4421: PPUSH
4422: LD_STRING 12p_
4424: PPUSH
4425: CALL 40247 0 3
4429: ST_TO_ADDR
// if Gladstone then
4430: LD_EXP 14
4434: IFFALSE 4452
// tmp := tmp ^ Gladstone ;
4436: LD_ADDR_VAR 0 6
4440: PUSH
4441: LD_VAR 0 6
4445: PUSH
4446: LD_EXP 14
4450: ADD
4451: ST_TO_ADDR
// Houten := PrepareUnit ( Houten , ( not debug ) , 12p_ ) ;
4452: LD_ADDR_EXP 15
4456: PUSH
4457: LD_STRING Houten
4459: PPUSH
4460: LD_EXP 1
4464: NOT
4465: PPUSH
4466: LD_STRING 12p_
4468: PPUSH
4469: CALL 40247 0 3
4473: ST_TO_ADDR
// if Houten then
4474: LD_EXP 15
4478: IFFALSE 4496
// tmp := tmp ^ Houten ;
4480: LD_ADDR_VAR 0 6
4484: PUSH
4485: LD_VAR 0 6
4489: PUSH
4490: LD_EXP 15
4494: ADD
4495: ST_TO_ADDR
// Cornel := PrepareUnit ( Cornel , ( not debug ) , 12p_ ) ;
4496: LD_ADDR_EXP 16
4500: PUSH
4501: LD_STRING Cornel
4503: PPUSH
4504: LD_EXP 1
4508: NOT
4509: PPUSH
4510: LD_STRING 12p_
4512: PPUSH
4513: CALL 40247 0 3
4517: ST_TO_ADDR
// if Cornel then
4518: LD_EXP 16
4522: IFFALSE 4540
// tmp := tmp ^ Cornel ;
4524: LD_ADDR_VAR 0 6
4528: PUSH
4529: LD_VAR 0 6
4533: PUSH
4534: LD_EXP 16
4538: ADD
4539: ST_TO_ADDR
// Gary := PrepareUnit ( Gary , ( not debug ) , 12p_ ) ;
4540: LD_ADDR_EXP 17
4544: PUSH
4545: LD_STRING Gary
4547: PPUSH
4548: LD_EXP 1
4552: NOT
4553: PPUSH
4554: LD_STRING 12p_
4556: PPUSH
4557: CALL 40247 0 3
4561: ST_TO_ADDR
// if Gary then
4562: LD_EXP 17
4566: IFFALSE 4584
// tmp := tmp ^ Gary ;
4568: LD_ADDR_VAR 0 6
4572: PUSH
4573: LD_VAR 0 6
4577: PUSH
4578: LD_EXP 17
4582: ADD
4583: ST_TO_ADDR
// Kikuchi := PrepareUnit ( Kikuchi , ( not debug ) , 12p_ ) ;
4584: LD_ADDR_EXP 19
4588: PUSH
4589: LD_STRING Kikuchi
4591: PPUSH
4592: LD_EXP 1
4596: NOT
4597: PPUSH
4598: LD_STRING 12p_
4600: PPUSH
4601: CALL 40247 0 3
4605: ST_TO_ADDR
// if Kikuchi then
4606: LD_EXP 19
4610: IFFALSE 4628
// tmp := tmp ^ Kikuchi ;
4612: LD_ADDR_VAR 0 6
4616: PUSH
4617: LD_VAR 0 6
4621: PUSH
4622: LD_EXP 19
4626: ADD
4627: ST_TO_ADDR
// tmp := tmp union CreateCharacterSet ( 12p_others ) ;
4628: LD_ADDR_VAR 0 6
4632: PUSH
4633: LD_VAR 0 6
4637: PUSH
4638: LD_STRING 12p_others
4640: PPUSH
4641: CALL_OW 31
4645: UNION
4646: ST_TO_ADDR
// if tmp < 36 then
4647: LD_VAR 0 6
4651: PUSH
4652: LD_INT 36
4654: LESS
4655: IFFALSE 4722
// for i = 1 to 36 - tmp do
4657: LD_ADDR_VAR 0 2
4661: PUSH
4662: DOUBLE
4663: LD_INT 1
4665: DEC
4666: ST_TO_ADDR
4667: LD_INT 36
4669: PUSH
4670: LD_VAR 0 6
4674: MINUS
4675: PUSH
4676: FOR_TO
4677: IFFALSE 4720
// begin PrepareHuman ( sex_male , i mod 4 + 1 , 10 ) ;
4679: LD_INT 1
4681: PPUSH
4682: LD_VAR 0 2
4686: PUSH
4687: LD_INT 4
4689: MOD
4690: PUSH
4691: LD_INT 1
4693: PLUS
4694: PPUSH
4695: LD_INT 10
4697: PPUSH
4698: CALL_OW 380
// tmp := tmp ^ CreateHuman ;
4702: LD_ADDR_VAR 0 6
4706: PUSH
4707: LD_VAR 0 6
4711: PUSH
4712: CALL_OW 44
4716: ADD
4717: ST_TO_ADDR
// end ;
4718: GO 4676
4720: POP
4721: POP
// for i in tmp do
4722: LD_ADDR_VAR 0 2
4726: PUSH
4727: LD_VAR 0 6
4731: PUSH
4732: FOR_IN
4733: IFFALSE 4758
// PlaceUnitXYR ( i , 62 , 93 , 9 , false ) ;
4735: LD_VAR 0 2
4739: PPUSH
4740: LD_INT 62
4742: PPUSH
4743: LD_INT 93
4745: PPUSH
4746: LD_INT 9
4748: PPUSH
4749: LD_INT 0
4751: PPUSH
4752: CALL_OW 50
4756: GO 4732
4758: POP
4759: POP
// mc_bases := Replace ( mc_bases , 4 , FilterAllUnits ( [ f_side , 1 ] ) ) ;
4760: LD_ADDR_EXP 56
4764: PUSH
4765: LD_EXP 56
4769: PPUSH
4770: LD_INT 4
4772: PPUSH
4773: LD_INT 22
4775: PUSH
4776: LD_INT 1
4778: PUSH
4779: EMPTY
4780: LIST
4781: LIST
4782: PPUSH
4783: CALL_OW 69
4787: PPUSH
4788: CALL_OW 1
4792: ST_TO_ADDR
// uc_side := 0 ;
4793: LD_ADDR_OWVAR 20
4797: PUSH
4798: LD_INT 0
4800: ST_TO_ADDR
// uc_nation := 0 ;
4801: LD_ADDR_OWVAR 21
4805: PUSH
4806: LD_INT 0
4808: ST_TO_ADDR
// for i = 1 to 4 do
4809: LD_ADDR_VAR 0 2
4813: PUSH
4814: DOUBLE
4815: LD_INT 1
4817: DEC
4818: ST_TO_ADDR
4819: LD_INT 4
4821: PUSH
4822: FOR_TO
4823: IFFALSE 4854
// begin InitHc ;
4825: CALL_OW 19
// hc_class := class_apeman ;
4829: LD_ADDR_OWVAR 28
4833: PUSH
4834: LD_INT 12
4836: ST_TO_ADDR
// PlaceUnitArea ( CreateHuman , powellApe , false ) ;
4837: CALL_OW 44
4841: PPUSH
4842: LD_INT 11
4844: PPUSH
4845: LD_INT 0
4847: PPUSH
4848: CALL_OW 49
// end ;
4852: GO 4822
4854: POP
4855: POP
// end ;
4856: LD_VAR 0 1
4860: RET
// every 11 11$30 trigger not americanDestroyed and not MC_GetVehicles ( 4 , true ) do var i , tmp , target ;
4861: LD_EXP 4
4865: NOT
4866: PUSH
4867: LD_INT 4
4869: PPUSH
4870: LD_INT 1
4872: PPUSH
4873: CALL 35543 0 2
4877: NOT
4878: AND
4879: IFFALSE 5651
4881: GO 4883
4883: DISABLE
4884: LD_INT 0
4886: PPUSH
4887: PPUSH
4888: PPUSH
// begin enable ;
4889: ENABLE
// if not FilterAllUnits ( [ [ f_side , 1 ] , [ f_nation , 1 ] , [ f_btype , b_factory ] ] ) then
4890: LD_INT 22
4892: PUSH
4893: LD_INT 1
4895: PUSH
4896: EMPTY
4897: LIST
4898: LIST
4899: PUSH
4900: LD_INT 23
4902: PUSH
4903: LD_INT 1
4905: PUSH
4906: EMPTY
4907: LIST
4908: LIST
4909: PUSH
4910: LD_INT 30
4912: PUSH
4913: LD_INT 3
4915: PUSH
4916: EMPTY
4917: LIST
4918: LIST
4919: PUSH
4920: EMPTY
4921: LIST
4922: LIST
4923: LIST
4924: PPUSH
4925: CALL_OW 69
4929: NOT
4930: IFFALSE 4934
// exit ;
4932: GO 5651
// if Prob ( 40 ) then
4934: LD_INT 40
4936: PPUSH
4937: CALL_OW 13
4941: IFFALSE 5068
// begin MC_InsertProduceList ( 4 , [ [ us_morphling , engine_combustion , control_remote , us_rocket_launcher ] , [ us_morphling , engine_combustion , control_remote , us_rocket_launcher ] , [ us_morphling , engine_combustion , control_remote , us_rocket_launcher ] , [ us_morphling , engine_combustion , control_remote , us_heavy_gun ] , [ us_morphling , engine_combustion , control_remote , us_heavy_gun ] , [ us_morphling , engine_combustion , control_remote , us_heavy_gun ] , ] ) ;
4943: LD_INT 4
4945: PPUSH
4946: LD_INT 5
4948: PUSH
4949: LD_INT 1
4951: PUSH
4952: LD_INT 2
4954: PUSH
4955: LD_INT 7
4957: PUSH
4958: EMPTY
4959: LIST
4960: LIST
4961: LIST
4962: LIST
4963: PUSH
4964: LD_INT 5
4966: PUSH
4967: LD_INT 1
4969: PUSH
4970: LD_INT 2
4972: PUSH
4973: LD_INT 7
4975: PUSH
4976: EMPTY
4977: LIST
4978: LIST
4979: LIST
4980: LIST
4981: PUSH
4982: LD_INT 5
4984: PUSH
4985: LD_INT 1
4987: PUSH
4988: LD_INT 2
4990: PUSH
4991: LD_INT 7
4993: PUSH
4994: EMPTY
4995: LIST
4996: LIST
4997: LIST
4998: LIST
4999: PUSH
5000: LD_INT 5
5002: PUSH
5003: LD_INT 1
5005: PUSH
5006: LD_INT 2
5008: PUSH
5009: LD_INT 6
5011: PUSH
5012: EMPTY
5013: LIST
5014: LIST
5015: LIST
5016: LIST
5017: PUSH
5018: LD_INT 5
5020: PUSH
5021: LD_INT 1
5023: PUSH
5024: LD_INT 2
5026: PUSH
5027: LD_INT 6
5029: PUSH
5030: EMPTY
5031: LIST
5032: LIST
5033: LIST
5034: LIST
5035: PUSH
5036: LD_INT 5
5038: PUSH
5039: LD_INT 1
5041: PUSH
5042: LD_INT 2
5044: PUSH
5045: LD_INT 6
5047: PUSH
5048: EMPTY
5049: LIST
5050: LIST
5051: LIST
5052: LIST
5053: PUSH
5054: EMPTY
5055: LIST
5056: LIST
5057: LIST
5058: LIST
5059: LIST
5060: LIST
5061: PPUSH
5062: CALL 34125 0 2
// end else
5066: GO 5191
// begin MC_InsertProduceList ( 4 , [ [ us_morphling , engine_combustion , control_remote , us_rocket_launcher ] , [ us_morphling , engine_combustion , control_remote , us_laser ] , [ us_morphling , engine_combustion , control_remote , us_laser ] , [ us_morphling , engine_combustion , control_remote , us_heavy_gun ] , [ us_morphling , engine_combustion , control_remote , us_heavy_gun ] , [ us_morphling , engine_combustion , control_remote , us_heavy_gun ] , ] ) ;
5068: LD_INT 4
5070: PPUSH
5071: LD_INT 5
5073: PUSH
5074: LD_INT 1
5076: PUSH
5077: LD_INT 2
5079: PUSH
5080: LD_INT 7
5082: PUSH
5083: EMPTY
5084: LIST
5085: LIST
5086: LIST
5087: LIST
5088: PUSH
5089: LD_INT 5
5091: PUSH
5092: LD_INT 1
5094: PUSH
5095: LD_INT 2
5097: PUSH
5098: LD_INT 9
5100: PUSH
5101: EMPTY
5102: LIST
5103: LIST
5104: LIST
5105: LIST
5106: PUSH
5107: LD_INT 5
5109: PUSH
5110: LD_INT 1
5112: PUSH
5113: LD_INT 2
5115: PUSH
5116: LD_INT 9
5118: PUSH
5119: EMPTY
5120: LIST
5121: LIST
5122: LIST
5123: LIST
5124: PUSH
5125: LD_INT 5
5127: PUSH
5128: LD_INT 1
5130: PUSH
5131: LD_INT 2
5133: PUSH
5134: LD_INT 6
5136: PUSH
5137: EMPTY
5138: LIST
5139: LIST
5140: LIST
5141: LIST
5142: PUSH
5143: LD_INT 5
5145: PUSH
5146: LD_INT 1
5148: PUSH
5149: LD_INT 2
5151: PUSH
5152: LD_INT 6
5154: PUSH
5155: EMPTY
5156: LIST
5157: LIST
5158: LIST
5159: LIST
5160: PUSH
5161: LD_INT 5
5163: PUSH
5164: LD_INT 1
5166: PUSH
5167: LD_INT 2
5169: PUSH
5170: LD_INT 6
5172: PUSH
5173: EMPTY
5174: LIST
5175: LIST
5176: LIST
5177: LIST
5178: PUSH
5179: EMPTY
5180: LIST
5181: LIST
5182: LIST
5183: LIST
5184: LIST
5185: LIST
5186: PPUSH
5187: CALL 34125 0 2
// end ; repeat wait ( 0 0$1 ) ;
5191: LD_INT 35
5193: PPUSH
5194: CALL_OW 67
// until MC_GetVehicles ( 4 , true ) >= 6 ;
5198: LD_INT 4
5200: PPUSH
5201: LD_INT 1
5203: PPUSH
5204: CALL 35543 0 2
5208: PUSH
5209: LD_INT 6
5211: GREATEREQUAL
5212: IFFALSE 5191
// wait ( 0 0$30 ) ;
5214: LD_INT 1050
5216: PPUSH
5217: CALL_OW 67
// tmp := MC_GetVehicles ( 4 , true ) ;
5221: LD_ADDR_VAR 0 2
5225: PUSH
5226: LD_INT 4
5228: PPUSH
5229: LD_INT 1
5231: PPUSH
5232: CALL 35543 0 2
5236: ST_TO_ADDR
// mc_vehicles := Replace ( mc_vehicles , 4 , mc_vehicles [ 4 ] diff tmp ) ;
5237: LD_ADDR_EXP 75
5241: PUSH
5242: LD_EXP 75
5246: PPUSH
5247: LD_INT 4
5249: PPUSH
5250: LD_EXP 75
5254: PUSH
5255: LD_INT 4
5257: ARRAY
5258: PUSH
5259: LD_VAR 0 2
5263: DIFF
5264: PPUSH
5265: CALL_OW 1
5269: ST_TO_ADDR
// target := rand ( 0 , 2 ) ;
5270: LD_ADDR_VAR 0 3
5274: PUSH
5275: LD_INT 0
5277: PPUSH
5278: LD_INT 2
5280: PPUSH
5281: CALL_OW 12
5285: ST_TO_ADDR
// if target then
5286: LD_VAR 0 3
5290: IFFALSE 5418
// begin repeat tmp := UnitFilter ( tmp , [ f_lives , 250 ] ) ;
5292: LD_ADDR_VAR 0 2
5296: PUSH
5297: LD_VAR 0 2
5301: PPUSH
5302: LD_INT 24
5304: PUSH
5305: LD_INT 250
5307: PUSH
5308: EMPTY
5309: LIST
5310: LIST
5311: PPUSH
5312: CALL_OW 72
5316: ST_TO_ADDR
// for i in tmp do
5317: LD_ADDR_VAR 0 1
5321: PUSH
5322: LD_VAR 0 2
5326: PUSH
5327: FOR_IN
5328: IFFALSE 5368
// if GetDistUnitXY ( i , 114 , 108 ) > 9 then
5330: LD_VAR 0 1
5334: PPUSH
5335: LD_INT 114
5337: PPUSH
5338: LD_INT 108
5340: PPUSH
5341: CALL_OW 297
5345: PUSH
5346: LD_INT 9
5348: GREATER
5349: IFFALSE 5366
// ComMoveXY ( i , 114 , 108 ) ;
5351: LD_VAR 0 1
5355: PPUSH
5356: LD_INT 114
5358: PPUSH
5359: LD_INT 108
5361: PPUSH
5362: CALL_OW 111
5366: GO 5327
5368: POP
5369: POP
// wait ( 0 0$1 ) ;
5370: LD_INT 35
5372: PPUSH
5373: CALL_OW 67
// until UnitFilter ( tmp , [ f_distxy , 114 , 108 , 9 ] ) >= ( tmp - 1 ) ;
5377: LD_VAR 0 2
5381: PPUSH
5382: LD_INT 92
5384: PUSH
5385: LD_INT 114
5387: PUSH
5388: LD_INT 108
5390: PUSH
5391: LD_INT 9
5393: PUSH
5394: EMPTY
5395: LIST
5396: LIST
5397: LIST
5398: LIST
5399: PPUSH
5400: CALL_OW 72
5404: PUSH
5405: LD_VAR 0 2
5409: PUSH
5410: LD_INT 1
5412: MINUS
5413: GREATEREQUAL
5414: IFFALSE 5292
// end else
5416: GO 5542
// begin repeat tmp := UnitFilter ( tmp , [ f_lives , 250 ] ) ;
5418: LD_ADDR_VAR 0 2
5422: PUSH
5423: LD_VAR 0 2
5427: PPUSH
5428: LD_INT 24
5430: PUSH
5431: LD_INT 250
5433: PUSH
5434: EMPTY
5435: LIST
5436: LIST
5437: PPUSH
5438: CALL_OW 72
5442: ST_TO_ADDR
// for i in tmp do
5443: LD_ADDR_VAR 0 1
5447: PUSH
5448: LD_VAR 0 2
5452: PUSH
5453: FOR_IN
5454: IFFALSE 5494
// if GetDistUnitXY ( i , 129 , 139 ) > 9 then
5456: LD_VAR 0 1
5460: PPUSH
5461: LD_INT 129
5463: PPUSH
5464: LD_INT 139
5466: PPUSH
5467: CALL_OW 297
5471: PUSH
5472: LD_INT 9
5474: GREATER
5475: IFFALSE 5492
// ComMoveXY ( i , 129 , 139 ) ;
5477: LD_VAR 0 1
5481: PPUSH
5482: LD_INT 129
5484: PPUSH
5485: LD_INT 139
5487: PPUSH
5488: CALL_OW 111
5492: GO 5453
5494: POP
5495: POP
// wait ( 0 0$1 ) ;
5496: LD_INT 35
5498: PPUSH
5499: CALL_OW 67
// until UnitFilter ( tmp , [ f_distxy , 129 , 139 , 9 ] ) >= ( tmp - 1 ) ;
5503: LD_VAR 0 2
5507: PPUSH
5508: LD_INT 92
5510: PUSH
5511: LD_INT 129
5513: PUSH
5514: LD_INT 139
5516: PUSH
5517: LD_INT 9
5519: PUSH
5520: EMPTY
5521: LIST
5522: LIST
5523: LIST
5524: LIST
5525: PPUSH
5526: CALL_OW 72
5530: PUSH
5531: LD_VAR 0 2
5535: PUSH
5536: LD_INT 1
5538: MINUS
5539: GREATEREQUAL
5540: IFFALSE 5418
// end ; repeat wait ( 0 0$1 ) ;
5542: LD_INT 35
5544: PPUSH
5545: CALL_OW 67
// for i in tmp do
5549: LD_ADDR_VAR 0 1
5553: PUSH
5554: LD_VAR 0 2
5558: PUSH
5559: FOR_IN
5560: IFFALSE 5642
// begin if GetLives ( i ) > 251 then
5562: LD_VAR 0 1
5566: PPUSH
5567: CALL_OW 256
5571: PUSH
5572: LD_INT 251
5574: GREATER
5575: IFFALSE 5613
// ComAttackUnit ( i , NearestUnitToUnit ( FilterAllUnits ( [ f_enemy , 1 ] ) , i ) ) else
5577: LD_VAR 0 1
5581: PPUSH
5582: LD_INT 81
5584: PUSH
5585: LD_INT 1
5587: PUSH
5588: EMPTY
5589: LIST
5590: LIST
5591: PPUSH
5592: CALL_OW 69
5596: PPUSH
5597: LD_VAR 0 1
5601: PPUSH
5602: CALL_OW 74
5606: PPUSH
5607: CALL_OW 115
5611: GO 5640
// if IsDead ( i ) then
5613: LD_VAR 0 1
5617: PPUSH
5618: CALL_OW 301
5622: IFFALSE 5640
// tmp := tmp diff i ;
5624: LD_ADDR_VAR 0 2
5628: PUSH
5629: LD_VAR 0 2
5633: PUSH
5634: LD_VAR 0 1
5638: DIFF
5639: ST_TO_ADDR
// end ;
5640: GO 5559
5642: POP
5643: POP
// until not tmp ;
5644: LD_VAR 0 2
5648: NOT
5649: IFFALSE 5542
// end ; end_of_file
5651: PPOPN 3
5653: END
// export function PrepareArabian ; var i , un , tmp , side ; begin
5654: LD_INT 0
5656: PPUSH
5657: PPUSH
5658: PPUSH
5659: PPUSH
5660: PPUSH
// side := 2 ;
5661: LD_ADDR_VAR 0 5
5665: PUSH
5666: LD_INT 2
5668: ST_TO_ADDR
// uc_side := side ;
5669: LD_ADDR_OWVAR 20
5673: PUSH
5674: LD_VAR 0 5
5678: ST_TO_ADDR
// uc_nation := 2 ;
5679: LD_ADDR_OWVAR 21
5683: PUSH
5684: LD_INT 2
5686: ST_TO_ADDR
// tmp := FilterAllUnits ( [ [ f_side , side ] , [ f_btype , b_bunker ] , [ f_empty ] ] ) ;
5687: LD_ADDR_VAR 0 4
5691: PUSH
5692: LD_INT 22
5694: PUSH
5695: LD_VAR 0 5
5699: PUSH
5700: EMPTY
5701: LIST
5702: LIST
5703: PUSH
5704: LD_INT 30
5706: PUSH
5707: LD_INT 32
5709: PUSH
5710: EMPTY
5711: LIST
5712: LIST
5713: PUSH
5714: LD_INT 58
5716: PUSH
5717: EMPTY
5718: LIST
5719: PUSH
5720: EMPTY
5721: LIST
5722: LIST
5723: LIST
5724: PPUSH
5725: CALL_OW 69
5729: ST_TO_ADDR
// for i = 1 to 10 do
5730: LD_ADDR_VAR 0 2
5734: PUSH
5735: DOUBLE
5736: LD_INT 1
5738: DEC
5739: ST_TO_ADDR
5740: LD_INT 10
5742: PUSH
5743: FOR_TO
5744: IFFALSE 5816
// begin uc_nation := nation_nature ;
5746: LD_ADDR_OWVAR 21
5750: PUSH
5751: LD_INT 0
5753: ST_TO_ADDR
// hc_class := class_apeman_soldier ;
5754: LD_ADDR_OWVAR 28
5758: PUSH
5759: LD_INT 15
5761: ST_TO_ADDR
// hc_gallery :=  ;
5762: LD_ADDR_OWVAR 33
5766: PUSH
5767: LD_STRING 
5769: ST_TO_ADDR
// hc_name :=  ;
5770: LD_ADDR_OWVAR 26
5774: PUSH
5775: LD_STRING 
5777: ST_TO_ADDR
// un := CreateHuman ;
5778: LD_ADDR_VAR 0 3
5782: PUSH
5783: CALL_OW 44
5787: ST_TO_ADDR
// PlaceHumanInUnit ( un , tmp [ tmp - i ] ) ;
5788: LD_VAR 0 3
5792: PPUSH
5793: LD_VAR 0 4
5797: PUSH
5798: LD_VAR 0 4
5802: PUSH
5803: LD_VAR 0 2
5807: MINUS
5808: ARRAY
5809: PPUSH
5810: CALL_OW 52
// end ;
5814: GO 5743
5816: POP
5817: POP
// PrepareBase ( ar_depot , arabianBaseArea ,  , [ 8 , 9 , 10 ] [ Difficulty ] , [ 3000 , 500 , 150 ] , [ 16 , 6 , 6 , 6 ] ) ;
5818: LD_INT 503
5820: PPUSH
5821: LD_INT 27
5823: PPUSH
5824: LD_STRING 
5826: PPUSH
5827: LD_INT 8
5829: PUSH
5830: LD_INT 9
5832: PUSH
5833: LD_INT 10
5835: PUSH
5836: EMPTY
5837: LIST
5838: LIST
5839: LIST
5840: PUSH
5841: LD_OWVAR 67
5845: ARRAY
5846: PPUSH
5847: LD_INT 3000
5849: PUSH
5850: LD_INT 500
5852: PUSH
5853: LD_INT 150
5855: PUSH
5856: EMPTY
5857: LIST
5858: LIST
5859: LIST
5860: PPUSH
5861: LD_INT 16
5863: PUSH
5864: LD_INT 6
5866: PUSH
5867: LD_INT 6
5869: PUSH
5870: LD_INT 6
5872: PUSH
5873: EMPTY
5874: LIST
5875: LIST
5876: LIST
5877: LIST
5878: PPUSH
5879: CALL 50407 0 6
// mc_bases := Replace ( mc_bases , 1 , FilterAllUnits ( [ [ f_side , side ] , [ f_nation , 2 ] , [ f_not , [ f_type , unit_vehicle ] ] ] ) ) ;
5883: LD_ADDR_EXP 56
5887: PUSH
5888: LD_EXP 56
5892: PPUSH
5893: LD_INT 1
5895: PPUSH
5896: LD_INT 22
5898: PUSH
5899: LD_VAR 0 5
5903: PUSH
5904: EMPTY
5905: LIST
5906: LIST
5907: PUSH
5908: LD_INT 23
5910: PUSH
5911: LD_INT 2
5913: PUSH
5914: EMPTY
5915: LIST
5916: LIST
5917: PUSH
5918: LD_INT 3
5920: PUSH
5921: LD_INT 21
5923: PUSH
5924: LD_INT 2
5926: PUSH
5927: EMPTY
5928: LIST
5929: LIST
5930: PUSH
5931: EMPTY
5932: LIST
5933: LIST
5934: PUSH
5935: EMPTY
5936: LIST
5937: LIST
5938: LIST
5939: PPUSH
5940: CALL_OW 69
5944: PPUSH
5945: CALL_OW 1
5949: ST_TO_ADDR
// end ; end_of_file
5950: LD_VAR 0 1
5954: RET
// export Schulz , Kozlov ; export function PrepareLegion ; var i , side , un , tmp ; begin
5955: LD_INT 0
5957: PPUSH
5958: PPUSH
5959: PPUSH
5960: PPUSH
5961: PPUSH
// side := 8 ;
5962: LD_ADDR_VAR 0 3
5966: PUSH
5967: LD_INT 8
5969: ST_TO_ADDR
// uc_side := side ;
5970: LD_ADDR_OWVAR 20
5974: PUSH
5975: LD_VAR 0 3
5979: ST_TO_ADDR
// uc_nation := 2 ;
5980: LD_ADDR_OWVAR 21
5984: PUSH
5985: LD_INT 2
5987: ST_TO_ADDR
// for i in FilterAllUnits ( [ [ f_side , side ] , [ f_type , unit_building ] ] ) do
5988: LD_ADDR_VAR 0 2
5992: PUSH
5993: LD_INT 22
5995: PUSH
5996: LD_VAR 0 3
6000: PUSH
6001: EMPTY
6002: LIST
6003: LIST
6004: PUSH
6005: LD_INT 21
6007: PUSH
6008: LD_INT 3
6010: PUSH
6011: EMPTY
6012: LIST
6013: LIST
6014: PUSH
6015: EMPTY
6016: LIST
6017: LIST
6018: PPUSH
6019: CALL_OW 69
6023: PUSH
6024: FOR_IN
6025: IFFALSE 6041
// SetBLevel ( i , 10 ) ;
6027: LD_VAR 0 2
6031: PPUSH
6032: LD_INT 10
6034: PPUSH
6035: CALL_OW 241
6039: GO 6024
6041: POP
6042: POP
// Schulz := PrepareUnit ( Schulz , false ,  ) ;
6043: LD_ADDR_EXP 41
6047: PUSH
6048: LD_STRING Schulz
6050: PPUSH
6051: LD_INT 0
6053: PPUSH
6054: LD_STRING 
6056: PPUSH
6057: CALL 40247 0 3
6061: ST_TO_ADDR
// Kozlov := PrepareUnit ( Kozlov , false ,  ) ;
6062: LD_ADDR_EXP 42
6066: PUSH
6067: LD_STRING Kozlov
6069: PPUSH
6070: LD_INT 0
6072: PPUSH
6073: LD_STRING 
6075: PPUSH
6076: CALL 40247 0 3
6080: ST_TO_ADDR
// PlaceHumanInUnit ( Kozlov , FilterAllUnits ( [ [ f_side , 8 ] , [ f_nation , 3 ] , [ f_btype , b_lab_full ] ] ) [ 1 ] ) ;
6081: LD_EXP 42
6085: PPUSH
6086: LD_INT 22
6088: PUSH
6089: LD_INT 8
6091: PUSH
6092: EMPTY
6093: LIST
6094: LIST
6095: PUSH
6096: LD_INT 23
6098: PUSH
6099: LD_INT 3
6101: PUSH
6102: EMPTY
6103: LIST
6104: LIST
6105: PUSH
6106: LD_INT 30
6108: PUSH
6109: LD_INT 8
6111: PUSH
6112: EMPTY
6113: LIST
6114: LIST
6115: PUSH
6116: EMPTY
6117: LIST
6118: LIST
6119: LIST
6120: PPUSH
6121: CALL_OW 69
6125: PUSH
6126: LD_INT 1
6128: ARRAY
6129: PPUSH
6130: CALL_OW 52
// SetSkill ( Kozlov , class_mechanic , 10 ) ;
6134: LD_EXP 42
6138: PPUSH
6139: LD_INT 3
6141: PPUSH
6142: LD_INT 10
6144: PPUSH
6145: CALL_OW 237
// tmp := FilterAllUnits ( [ [ f_side , side ] , [ f_btype , b_bunker ] , [ f_empty ] ] ) ;
6149: LD_ADDR_VAR 0 5
6153: PUSH
6154: LD_INT 22
6156: PUSH
6157: LD_VAR 0 3
6161: PUSH
6162: EMPTY
6163: LIST
6164: LIST
6165: PUSH
6166: LD_INT 30
6168: PUSH
6169: LD_INT 32
6171: PUSH
6172: EMPTY
6173: LIST
6174: LIST
6175: PUSH
6176: LD_INT 58
6178: PUSH
6179: EMPTY
6180: LIST
6181: PUSH
6182: EMPTY
6183: LIST
6184: LIST
6185: LIST
6186: PPUSH
6187: CALL_OW 69
6191: ST_TO_ADDR
// for i = 1 to 10 do
6192: LD_ADDR_VAR 0 2
6196: PUSH
6197: DOUBLE
6198: LD_INT 1
6200: DEC
6201: ST_TO_ADDR
6202: LD_INT 10
6204: PUSH
6205: FOR_TO
6206: IFFALSE 6278
// begin uc_nation := nation_nature ;
6208: LD_ADDR_OWVAR 21
6212: PUSH
6213: LD_INT 0
6215: ST_TO_ADDR
// hc_class := class_apeman_soldier ;
6216: LD_ADDR_OWVAR 28
6220: PUSH
6221: LD_INT 15
6223: ST_TO_ADDR
// hc_gallery :=  ;
6224: LD_ADDR_OWVAR 33
6228: PUSH
6229: LD_STRING 
6231: ST_TO_ADDR
// hc_name :=  ;
6232: LD_ADDR_OWVAR 26
6236: PUSH
6237: LD_STRING 
6239: ST_TO_ADDR
// un := CreateHuman ;
6240: LD_ADDR_VAR 0 4
6244: PUSH
6245: CALL_OW 44
6249: ST_TO_ADDR
// PlaceHumanInUnit ( un , tmp [ tmp - i ] ) ;
6250: LD_VAR 0 4
6254: PPUSH
6255: LD_VAR 0 5
6259: PUSH
6260: LD_VAR 0 5
6264: PUSH
6265: LD_VAR 0 2
6269: MINUS
6270: ARRAY
6271: PPUSH
6272: CALL_OW 52
// end ;
6276: GO 6205
6278: POP
6279: POP
// PrepareBase ( ar_depot1 , legionBaseArea ,  , [ 8 , 9 , 10 ] [ Difficulty ] , [ 3000 , 500 , 150 ] , [ 16 , 6 , 6 , 8 ] ) ;
6280: LD_INT 324
6282: PPUSH
6283: LD_INT 3
6285: PPUSH
6286: LD_STRING 
6288: PPUSH
6289: LD_INT 8
6291: PUSH
6292: LD_INT 9
6294: PUSH
6295: LD_INT 10
6297: PUSH
6298: EMPTY
6299: LIST
6300: LIST
6301: LIST
6302: PUSH
6303: LD_OWVAR 67
6307: ARRAY
6308: PPUSH
6309: LD_INT 3000
6311: PUSH
6312: LD_INT 500
6314: PUSH
6315: LD_INT 150
6317: PUSH
6318: EMPTY
6319: LIST
6320: LIST
6321: LIST
6322: PPUSH
6323: LD_INT 16
6325: PUSH
6326: LD_INT 6
6328: PUSH
6329: LD_INT 6
6331: PUSH
6332: LD_INT 8
6334: PUSH
6335: EMPTY
6336: LIST
6337: LIST
6338: LIST
6339: LIST
6340: PPUSH
6341: CALL 50407 0 6
// mc_bases := Replace ( mc_bases , 3 , FilterAllUnits ( [ [ f_side , side ] , [ f_nation , 2 ] , [ f_not , [ f_type , unit_vehicle ] ] ] ) diff Schulz ) ;
6345: LD_ADDR_EXP 56
6349: PUSH
6350: LD_EXP 56
6354: PPUSH
6355: LD_INT 3
6357: PPUSH
6358: LD_INT 22
6360: PUSH
6361: LD_VAR 0 3
6365: PUSH
6366: EMPTY
6367: LIST
6368: LIST
6369: PUSH
6370: LD_INT 23
6372: PUSH
6373: LD_INT 2
6375: PUSH
6376: EMPTY
6377: LIST
6378: LIST
6379: PUSH
6380: LD_INT 3
6382: PUSH
6383: LD_INT 21
6385: PUSH
6386: LD_INT 2
6388: PUSH
6389: EMPTY
6390: LIST
6391: LIST
6392: PUSH
6393: EMPTY
6394: LIST
6395: LIST
6396: PUSH
6397: EMPTY
6398: LIST
6399: LIST
6400: LIST
6401: PPUSH
6402: CALL_OW 69
6406: PUSH
6407: LD_EXP 41
6411: DIFF
6412: PPUSH
6413: CALL_OW 1
6417: ST_TO_ADDR
// end ;
6418: LD_VAR 0 1
6422: RET
// export function BuildKozlovBomb ; begin
6423: LD_INT 0
6425: PPUSH
// if not IsOk ( kozlov_fac ) or not IsOk ( kozlov_lab ) then
6426: LD_INT 332
6428: PPUSH
6429: CALL_OW 302
6433: NOT
6434: PUSH
6435: LD_INT 336
6437: PPUSH
6438: CALL_OW 302
6442: NOT
6443: OR
6444: IFFALSE 6448
// exit ;
6446: GO 6545
// ComChangeProfession ( Kozlov , 4 ) ;
6448: LD_EXP 42
6452: PPUSH
6453: LD_INT 4
6455: PPUSH
6456: CALL_OW 123
// ComResearch ( kozlov_lab , tech_sibFiss ) ;
6460: LD_INT 336
6462: PPUSH
6463: LD_INT 25
6465: PPUSH
6466: CALL_OW 124
// repeat wait ( 0 0$1 ) ;
6470: LD_INT 35
6472: PPUSH
6473: CALL_OW 67
// until GetTech ( tech_sibFiss , 8 ) = state_researched ;
6477: LD_INT 25
6479: PPUSH
6480: LD_INT 8
6482: PPUSH
6483: CALL_OW 321
6487: PUSH
6488: LD_INT 2
6490: EQUAL
6491: IFFALSE 6470
// ComExitBuilding ( Kozlov ) ;
6493: LD_EXP 42
6497: PPUSH
6498: CALL_OW 122
// AddComEnterUnit ( Kozlov , kozlov_fac ) ;
6502: LD_EXP 42
6506: PPUSH
6507: LD_INT 332
6509: PPUSH
6510: CALL_OW 180
// AddComChangeProfession ( Kozlov , 3 ) ;
6514: LD_EXP 42
6518: PPUSH
6519: LD_INT 3
6521: PPUSH
6522: CALL_OW 183
// ComConstruct ( kozlov_fac , ru_heavy_wheeled , engine_siberite , control_manual , ru_siberium_rocket ) ;
6526: LD_INT 332
6528: PPUSH
6529: LD_INT 23
6531: PPUSH
6532: LD_INT 3
6534: PPUSH
6535: LD_INT 1
6537: PPUSH
6538: LD_INT 48
6540: PPUSH
6541: CALL_OW 125
// end ;
6545: LD_VAR 0 1
6549: RET
// every 11 11$30 trigger not legionDestroyed and not MC_GetVehicles ( 3 , true ) do var i , tmp , target ;
6550: LD_EXP 3
6554: NOT
6555: PUSH
6556: LD_INT 3
6558: PPUSH
6559: LD_INT 1
6561: PPUSH
6562: CALL 35543 0 2
6566: NOT
6567: AND
6568: IFFALSE 7408
6570: GO 6572
6572: DISABLE
6573: LD_INT 0
6575: PPUSH
6576: PPUSH
6577: PPUSH
// begin enable ;
6578: ENABLE
// if not FilterAllUnits ( [ [ f_side , 8 ] , [ f_nation , 2 ] , [ f_btype , b_factory ] ] ) then
6579: LD_INT 22
6581: PUSH
6582: LD_INT 8
6584: PUSH
6585: EMPTY
6586: LIST
6587: LIST
6588: PUSH
6589: LD_INT 23
6591: PUSH
6592: LD_INT 2
6594: PUSH
6595: EMPTY
6596: LIST
6597: LIST
6598: PUSH
6599: LD_INT 30
6601: PUSH
6602: LD_INT 3
6604: PUSH
6605: EMPTY
6606: LIST
6607: LIST
6608: PUSH
6609: EMPTY
6610: LIST
6611: LIST
6612: LIST
6613: PPUSH
6614: CALL_OW 69
6618: NOT
6619: IFFALSE 6623
// exit ;
6621: GO 7408
// if Prob ( 40 ) then
6623: LD_INT 40
6625: PPUSH
6626: CALL_OW 13
6630: IFFALSE 6757
// begin MC_InsertProduceList ( 3 , [ [ ar_half_tracked , engine_combustion , control_remote , ar_rocket_launcher ] , [ ar_half_tracked , engine_combustion , control_remote , ar_rocket_launcher ] , [ ar_half_tracked , engine_combustion , control_remote , ar_rocket_launcher ] , [ ar_half_tracked , engine_combustion , control_remote , ar_rocket_launcher ] , [ ar_half_tracked , engine_combustion , control_remote , ar_rocket_launcher ] , [ ar_half_tracked , engine_combustion , control_remote , ar_flame_thrower ] , ] ) ;
6632: LD_INT 3
6634: PPUSH
6635: LD_INT 14
6637: PUSH
6638: LD_INT 1
6640: PUSH
6641: LD_INT 2
6643: PUSH
6644: LD_INT 28
6646: PUSH
6647: EMPTY
6648: LIST
6649: LIST
6650: LIST
6651: LIST
6652: PUSH
6653: LD_INT 14
6655: PUSH
6656: LD_INT 1
6658: PUSH
6659: LD_INT 2
6661: PUSH
6662: LD_INT 28
6664: PUSH
6665: EMPTY
6666: LIST
6667: LIST
6668: LIST
6669: LIST
6670: PUSH
6671: LD_INT 14
6673: PUSH
6674: LD_INT 1
6676: PUSH
6677: LD_INT 2
6679: PUSH
6680: LD_INT 28
6682: PUSH
6683: EMPTY
6684: LIST
6685: LIST
6686: LIST
6687: LIST
6688: PUSH
6689: LD_INT 14
6691: PUSH
6692: LD_INT 1
6694: PUSH
6695: LD_INT 2
6697: PUSH
6698: LD_INT 28
6700: PUSH
6701: EMPTY
6702: LIST
6703: LIST
6704: LIST
6705: LIST
6706: PUSH
6707: LD_INT 14
6709: PUSH
6710: LD_INT 1
6712: PUSH
6713: LD_INT 2
6715: PUSH
6716: LD_INT 28
6718: PUSH
6719: EMPTY
6720: LIST
6721: LIST
6722: LIST
6723: LIST
6724: PUSH
6725: LD_INT 14
6727: PUSH
6728: LD_INT 1
6730: PUSH
6731: LD_INT 2
6733: PUSH
6734: LD_INT 26
6736: PUSH
6737: EMPTY
6738: LIST
6739: LIST
6740: LIST
6741: LIST
6742: PUSH
6743: EMPTY
6744: LIST
6745: LIST
6746: LIST
6747: LIST
6748: LIST
6749: LIST
6750: PPUSH
6751: CALL 34125 0 2
// end else
6755: GO 6948
// begin MC_InsertProduceList ( 3 , [ [ ar_half_tracked , engine_combustion , control_remote , [ ar_gun , ar_flame_thrower , ar_flame_thrower ] [ Difficulty ] ] , [ ar_half_tracked , engine_combustion , control_remote , [ ar_gun , ar_flame_thrower , ar_flame_thrower ] [ Difficulty ] ] , [ ar_half_tracked , engine_combustion , control_remote , [ ar_flame_thrower , ar_flame_thrower , ar_selfpropelled_bomb ] [ Difficulty ] ] , [ ar_medium_trike , engine_combustion , control_remote , [ ar_flame_thrower , ar_selfpropelled_bomb , ar_selfpropelled_bomb ] [ Difficulty ] ] , [ ar_medium_trike , engine_combustion , control_remote , ar_selfpropelled_bomb ] , [ ar_half_tracked , engine_combustion , control_remote , ar_flame_thrower ] , ] ) ;
6757: LD_INT 3
6759: PPUSH
6760: LD_INT 14
6762: PUSH
6763: LD_INT 1
6765: PUSH
6766: LD_INT 2
6768: PUSH
6769: LD_INT 27
6771: PUSH
6772: LD_INT 26
6774: PUSH
6775: LD_INT 26
6777: PUSH
6778: EMPTY
6779: LIST
6780: LIST
6781: LIST
6782: PUSH
6783: LD_OWVAR 67
6787: ARRAY
6788: PUSH
6789: EMPTY
6790: LIST
6791: LIST
6792: LIST
6793: LIST
6794: PUSH
6795: LD_INT 14
6797: PUSH
6798: LD_INT 1
6800: PUSH
6801: LD_INT 2
6803: PUSH
6804: LD_INT 27
6806: PUSH
6807: LD_INT 26
6809: PUSH
6810: LD_INT 26
6812: PUSH
6813: EMPTY
6814: LIST
6815: LIST
6816: LIST
6817: PUSH
6818: LD_OWVAR 67
6822: ARRAY
6823: PUSH
6824: EMPTY
6825: LIST
6826: LIST
6827: LIST
6828: LIST
6829: PUSH
6830: LD_INT 14
6832: PUSH
6833: LD_INT 1
6835: PUSH
6836: LD_INT 2
6838: PUSH
6839: LD_INT 26
6841: PUSH
6842: LD_INT 26
6844: PUSH
6845: LD_INT 29
6847: PUSH
6848: EMPTY
6849: LIST
6850: LIST
6851: LIST
6852: PUSH
6853: LD_OWVAR 67
6857: ARRAY
6858: PUSH
6859: EMPTY
6860: LIST
6861: LIST
6862: LIST
6863: LIST
6864: PUSH
6865: LD_INT 13
6867: PUSH
6868: LD_INT 1
6870: PUSH
6871: LD_INT 2
6873: PUSH
6874: LD_INT 26
6876: PUSH
6877: LD_INT 29
6879: PUSH
6880: LD_INT 29
6882: PUSH
6883: EMPTY
6884: LIST
6885: LIST
6886: LIST
6887: PUSH
6888: LD_OWVAR 67
6892: ARRAY
6893: PUSH
6894: EMPTY
6895: LIST
6896: LIST
6897: LIST
6898: LIST
6899: PUSH
6900: LD_INT 13
6902: PUSH
6903: LD_INT 1
6905: PUSH
6906: LD_INT 2
6908: PUSH
6909: LD_INT 29
6911: PUSH
6912: EMPTY
6913: LIST
6914: LIST
6915: LIST
6916: LIST
6917: PUSH
6918: LD_INT 14
6920: PUSH
6921: LD_INT 1
6923: PUSH
6924: LD_INT 2
6926: PUSH
6927: LD_INT 26
6929: PUSH
6930: EMPTY
6931: LIST
6932: LIST
6933: LIST
6934: LIST
6935: PUSH
6936: EMPTY
6937: LIST
6938: LIST
6939: LIST
6940: LIST
6941: LIST
6942: LIST
6943: PPUSH
6944: CALL 34125 0 2
// end ; repeat wait ( 0 0$1 ) ;
6948: LD_INT 35
6950: PPUSH
6951: CALL_OW 67
// until MC_GetVehicles ( 3 , true ) >= 6 ;
6955: LD_INT 3
6957: PPUSH
6958: LD_INT 1
6960: PPUSH
6961: CALL 35543 0 2
6965: PUSH
6966: LD_INT 6
6968: GREATEREQUAL
6969: IFFALSE 6948
// wait ( 0 0$30 ) ;
6971: LD_INT 1050
6973: PPUSH
6974: CALL_OW 67
// tmp := MC_GetVehicles ( 3 , true ) ;
6978: LD_ADDR_VAR 0 2
6982: PUSH
6983: LD_INT 3
6985: PPUSH
6986: LD_INT 1
6988: PPUSH
6989: CALL 35543 0 2
6993: ST_TO_ADDR
// mc_vehicles := Replace ( mc_vehicles , 3 , mc_vehicles [ 3 ] diff tmp ) ;
6994: LD_ADDR_EXP 75
6998: PUSH
6999: LD_EXP 75
7003: PPUSH
7004: LD_INT 3
7006: PPUSH
7007: LD_EXP 75
7011: PUSH
7012: LD_INT 3
7014: ARRAY
7015: PUSH
7016: LD_VAR 0 2
7020: DIFF
7021: PPUSH
7022: CALL_OW 1
7026: ST_TO_ADDR
// target := rand ( 0 , 2 ) ;
7027: LD_ADDR_VAR 0 3
7031: PUSH
7032: LD_INT 0
7034: PPUSH
7035: LD_INT 2
7037: PPUSH
7038: CALL_OW 12
7042: ST_TO_ADDR
// if target then
7043: LD_VAR 0 3
7047: IFFALSE 7175
// begin repeat tmp := UnitFilter ( tmp , [ f_lives , 250 ] ) ;
7049: LD_ADDR_VAR 0 2
7053: PUSH
7054: LD_VAR 0 2
7058: PPUSH
7059: LD_INT 24
7061: PUSH
7062: LD_INT 250
7064: PUSH
7065: EMPTY
7066: LIST
7067: LIST
7068: PPUSH
7069: CALL_OW 72
7073: ST_TO_ADDR
// for i in tmp do
7074: LD_ADDR_VAR 0 1
7078: PUSH
7079: LD_VAR 0 2
7083: PUSH
7084: FOR_IN
7085: IFFALSE 7125
// if GetDistUnitXY ( i , 89 , 71 ) > 9 then
7087: LD_VAR 0 1
7091: PPUSH
7092: LD_INT 89
7094: PPUSH
7095: LD_INT 71
7097: PPUSH
7098: CALL_OW 297
7102: PUSH
7103: LD_INT 9
7105: GREATER
7106: IFFALSE 7123
// ComMoveXY ( i , 89 , 71 ) ;
7108: LD_VAR 0 1
7112: PPUSH
7113: LD_INT 89
7115: PPUSH
7116: LD_INT 71
7118: PPUSH
7119: CALL_OW 111
7123: GO 7084
7125: POP
7126: POP
// wait ( 0 0$1 ) ;
7127: LD_INT 35
7129: PPUSH
7130: CALL_OW 67
// until UnitFilter ( tmp , [ f_distxy , 89 , 71 , 9 ] ) >= ( tmp - 1 ) ;
7134: LD_VAR 0 2
7138: PPUSH
7139: LD_INT 92
7141: PUSH
7142: LD_INT 89
7144: PUSH
7145: LD_INT 71
7147: PUSH
7148: LD_INT 9
7150: PUSH
7151: EMPTY
7152: LIST
7153: LIST
7154: LIST
7155: LIST
7156: PPUSH
7157: CALL_OW 72
7161: PUSH
7162: LD_VAR 0 2
7166: PUSH
7167: LD_INT 1
7169: MINUS
7170: GREATEREQUAL
7171: IFFALSE 7049
// end else
7173: GO 7299
// begin repeat tmp := UnitFilter ( tmp , [ f_lives , 250 ] ) ;
7175: LD_ADDR_VAR 0 2
7179: PUSH
7180: LD_VAR 0 2
7184: PPUSH
7185: LD_INT 24
7187: PUSH
7188: LD_INT 250
7190: PUSH
7191: EMPTY
7192: LIST
7193: LIST
7194: PPUSH
7195: CALL_OW 72
7199: ST_TO_ADDR
// for i in tmp do
7200: LD_ADDR_VAR 0 1
7204: PUSH
7205: LD_VAR 0 2
7209: PUSH
7210: FOR_IN
7211: IFFALSE 7251
// if GetDistUnitXY ( i , 147 , 4 ) > 9 then
7213: LD_VAR 0 1
7217: PPUSH
7218: LD_INT 147
7220: PPUSH
7221: LD_INT 4
7223: PPUSH
7224: CALL_OW 297
7228: PUSH
7229: LD_INT 9
7231: GREATER
7232: IFFALSE 7249
// ComMoveXY ( i , 147 , 4 ) ;
7234: LD_VAR 0 1
7238: PPUSH
7239: LD_INT 147
7241: PPUSH
7242: LD_INT 4
7244: PPUSH
7245: CALL_OW 111
7249: GO 7210
7251: POP
7252: POP
// wait ( 0 0$1 ) ;
7253: LD_INT 35
7255: PPUSH
7256: CALL_OW 67
// until UnitFilter ( tmp , [ f_distxy , 147 , 4 , 9 ] ) >= ( tmp - 1 ) ;
7260: LD_VAR 0 2
7264: PPUSH
7265: LD_INT 92
7267: PUSH
7268: LD_INT 147
7270: PUSH
7271: LD_INT 4
7273: PUSH
7274: LD_INT 9
7276: PUSH
7277: EMPTY
7278: LIST
7279: LIST
7280: LIST
7281: LIST
7282: PPUSH
7283: CALL_OW 72
7287: PUSH
7288: LD_VAR 0 2
7292: PUSH
7293: LD_INT 1
7295: MINUS
7296: GREATEREQUAL
7297: IFFALSE 7175
// end ; repeat wait ( 0 0$1 ) ;
7299: LD_INT 35
7301: PPUSH
7302: CALL_OW 67
// for i in tmp do
7306: LD_ADDR_VAR 0 1
7310: PUSH
7311: LD_VAR 0 2
7315: PUSH
7316: FOR_IN
7317: IFFALSE 7399
// begin if GetLives ( i ) > 251 then
7319: LD_VAR 0 1
7323: PPUSH
7324: CALL_OW 256
7328: PUSH
7329: LD_INT 251
7331: GREATER
7332: IFFALSE 7370
// ComAttackUnit ( i , NearestUnitToUnit ( FilterAllUnits ( [ f_enemy , 8 ] ) , i ) ) else
7334: LD_VAR 0 1
7338: PPUSH
7339: LD_INT 81
7341: PUSH
7342: LD_INT 8
7344: PUSH
7345: EMPTY
7346: LIST
7347: LIST
7348: PPUSH
7349: CALL_OW 69
7353: PPUSH
7354: LD_VAR 0 1
7358: PPUSH
7359: CALL_OW 74
7363: PPUSH
7364: CALL_OW 115
7368: GO 7397
// if IsDead ( i ) then
7370: LD_VAR 0 1
7374: PPUSH
7375: CALL_OW 301
7379: IFFALSE 7397
// tmp := tmp diff i ;
7381: LD_ADDR_VAR 0 2
7385: PUSH
7386: LD_VAR 0 2
7390: PUSH
7391: LD_VAR 0 1
7395: DIFF
7396: ST_TO_ADDR
// end ;
7397: GO 7316
7399: POP
7400: POP
// until not tmp ;
7401: LD_VAR 0 2
7405: NOT
7406: IFFALSE 7299
// end ;
7408: PPOPN 3
7410: END
// every 0 0$1 trigger IsOk ( Kozlov ) and not legionDestroyed do
7411: LD_EXP 42
7415: PPUSH
7416: CALL_OW 302
7420: PUSH
7421: LD_EXP 3
7425: NOT
7426: AND
7427: IFFALSE 7436
7429: GO 7431
7431: DISABLE
// BuildKozlovBomb ;
7432: CALL 6423 0 0
7436: END
// every 0 0$3 trigger FilterAllUnits ( [ [ f_side , 8 ] , [ f_weapon , ru_siberium_rocket ] ] ) do
7437: LD_INT 22
7439: PUSH
7440: LD_INT 8
7442: PUSH
7443: EMPTY
7444: LIST
7445: LIST
7446: PUSH
7447: LD_INT 34
7449: PUSH
7450: LD_INT 48
7452: PUSH
7453: EMPTY
7454: LIST
7455: LIST
7456: PUSH
7457: EMPTY
7458: LIST
7459: LIST
7460: PPUSH
7461: CALL_OW 69
7465: IFFALSE 7513
7467: GO 7469
7469: DISABLE
// begin ComAttackPlace ( FilterAllUnits ( [ [ f_side , 8 ] , [ f_weapon , ru_siberium_rocket ] ] ) [ 1 ] , 173 , 96 ) ;
7470: LD_INT 22
7472: PUSH
7473: LD_INT 8
7475: PUSH
7476: EMPTY
7477: LIST
7478: LIST
7479: PUSH
7480: LD_INT 34
7482: PUSH
7483: LD_INT 48
7485: PUSH
7486: EMPTY
7487: LIST
7488: LIST
7489: PUSH
7490: EMPTY
7491: LIST
7492: LIST
7493: PPUSH
7494: CALL_OW 69
7498: PUSH
7499: LD_INT 1
7501: ARRAY
7502: PPUSH
7503: LD_INT 173
7505: PPUSH
7506: LD_INT 96
7508: PPUSH
7509: CALL_OW 116
// end ; end_of_file
7513: END
// export Platonov , Yakotich , Gleb , Bierezov ; export behemoths , behemothBuilders ; export function PrepareRussian ; var i , j , base , tmp , side , xy , b , teleport ; begin
7514: LD_INT 0
7516: PPUSH
7517: PPUSH
7518: PPUSH
7519: PPUSH
7520: PPUSH
7521: PPUSH
7522: PPUSH
7523: PPUSH
7524: PPUSH
// side := 3 ;
7525: LD_ADDR_VAR 0 6
7529: PUSH
7530: LD_INT 3
7532: ST_TO_ADDR
// uc_side := side ;
7533: LD_ADDR_OWVAR 20
7537: PUSH
7538: LD_VAR 0 6
7542: ST_TO_ADDR
// uc_nation := 3 ;
7543: LD_ADDR_OWVAR 21
7547: PUSH
7548: LD_INT 3
7550: ST_TO_ADDR
// for i in FilterAllUnits ( [ [ f_side , side ] , [ f_type , unit_building ] ] ) do
7551: LD_ADDR_VAR 0 2
7555: PUSH
7556: LD_INT 22
7558: PUSH
7559: LD_VAR 0 6
7563: PUSH
7564: EMPTY
7565: LIST
7566: LIST
7567: PUSH
7568: LD_INT 21
7570: PUSH
7571: LD_INT 3
7573: PUSH
7574: EMPTY
7575: LIST
7576: LIST
7577: PUSH
7578: EMPTY
7579: LIST
7580: LIST
7581: PPUSH
7582: CALL_OW 69
7586: PUSH
7587: FOR_IN
7588: IFFALSE 7604
// SetBLevel ( i , 10 ) ;
7590: LD_VAR 0 2
7594: PPUSH
7595: LD_INT 10
7597: PPUSH
7598: CALL_OW 241
7602: GO 7587
7604: POP
7605: POP
// teleport := FilterAllUnits ( [ [ f_side , side ] , [ f_btype , b_teleport ] ] ) ;
7606: LD_ADDR_VAR 0 9
7610: PUSH
7611: LD_INT 22
7613: PUSH
7614: LD_VAR 0 6
7618: PUSH
7619: EMPTY
7620: LIST
7621: LIST
7622: PUSH
7623: LD_INT 30
7625: PUSH
7626: LD_INT 34
7628: PUSH
7629: EMPTY
7630: LIST
7631: LIST
7632: PUSH
7633: EMPTY
7634: LIST
7635: LIST
7636: PPUSH
7637: CALL_OW 69
7641: ST_TO_ADDR
// if teleport then
7642: LD_VAR 0 9
7646: IFFALSE 7667
// TeleportExit ( teleport [ 1 ] , 123 , 122 ) ;
7648: LD_VAR 0 9
7652: PUSH
7653: LD_INT 1
7655: ARRAY
7656: PPUSH
7657: LD_INT 123
7659: PPUSH
7660: LD_INT 122
7662: PPUSH
7663: CALL_OW 243
// Platonov := NewCharacter ( Platonov ) ;
7667: LD_ADDR_EXP 43
7671: PUSH
7672: LD_STRING Platonov
7674: PPUSH
7675: CALL_OW 25
7679: ST_TO_ADDR
// Kovalyuk := NewCharacter ( Kovalyuk ) ;
7680: LD_ADDR_EXP 34
7684: PUSH
7685: LD_STRING Kovalyuk
7687: PPUSH
7688: CALL_OW 25
7692: ST_TO_ADDR
// Yakotich := NewCharacter ( Yakotich ) ;
7693: LD_ADDR_EXP 44
7697: PUSH
7698: LD_STRING Yakotich
7700: PPUSH
7701: CALL_OW 25
7705: ST_TO_ADDR
// Gleb := NewCharacter ( Gleb ) ;
7706: LD_ADDR_EXP 45
7710: PUSH
7711: LD_STRING Gleb
7713: PPUSH
7714: CALL_OW 25
7718: ST_TO_ADDR
// if TestCharacters ( 03_Cornel ) then
7719: LD_STRING 03_Cornel
7721: PPUSH
7722: CALL_OW 28
7726: IFFALSE 7774
// begin Bierezov := NewCharacter ( Mikhail ) ;
7728: LD_ADDR_EXP 46
7732: PUSH
7733: LD_STRING Mikhail
7735: PPUSH
7736: CALL_OW 25
7740: ST_TO_ADDR
// PlaceUnitXYR ( Bierezov , 197 , 111 , 9 , false ) ;
7741: LD_EXP 46
7745: PPUSH
7746: LD_INT 197
7748: PPUSH
7749: LD_INT 111
7751: PPUSH
7752: LD_INT 9
7754: PPUSH
7755: LD_INT 0
7757: PPUSH
7758: CALL_OW 50
// SetClass ( Bierezov , 3 ) ;
7762: LD_EXP 46
7766: PPUSH
7767: LD_INT 3
7769: PPUSH
7770: CALL_OW 336
// end ; PlaceHumanInUnit ( Platonov , ru_depot ) ;
7774: LD_EXP 43
7778: PPUSH
7779: LD_INT 126
7781: PPUSH
7782: CALL_OW 52
// PlaceHumanInUnit ( Kovalyuk , ru_fac1 ) ;
7786: LD_EXP 34
7790: PPUSH
7791: LD_INT 134
7793: PPUSH
7794: CALL_OW 52
// PlaceUnitXYR ( Yakotich , 197 , 111 , 9 , false ) ;
7798: LD_EXP 44
7802: PPUSH
7803: LD_INT 197
7805: PPUSH
7806: LD_INT 111
7808: PPUSH
7809: LD_INT 9
7811: PPUSH
7812: LD_INT 0
7814: PPUSH
7815: CALL_OW 50
// PlaceUnitXYR ( Gleb , 197 , 111 , 9 , false ) ;
7819: LD_EXP 45
7823: PPUSH
7824: LD_INT 197
7826: PPUSH
7827: LD_INT 111
7829: PPUSH
7830: LD_INT 9
7832: PPUSH
7833: LD_INT 0
7835: PPUSH
7836: CALL_OW 50
// tmp := PrepareBase ( ru_depot , russianBaseArea , zhukov , [ 9 , 10 , 10 ] [ Difficulty ] , [ 99999 , 1000 , 300 ] , [ 12 , 8 , 13 , 8 ] ) ;
7840: LD_ADDR_VAR 0 5
7844: PUSH
7845: LD_INT 126
7847: PPUSH
7848: LD_INT 2
7850: PPUSH
7851: LD_STRING zhukov
7853: PPUSH
7854: LD_INT 9
7856: PUSH
7857: LD_INT 10
7859: PUSH
7860: LD_INT 10
7862: PUSH
7863: EMPTY
7864: LIST
7865: LIST
7866: LIST
7867: PUSH
7868: LD_OWVAR 67
7872: ARRAY
7873: PPUSH
7874: LD_INT 99999
7876: PUSH
7877: LD_INT 1000
7879: PUSH
7880: LD_INT 300
7882: PUSH
7883: EMPTY
7884: LIST
7885: LIST
7886: LIST
7887: PPUSH
7888: LD_INT 12
7890: PUSH
7891: LD_INT 8
7893: PUSH
7894: LD_INT 13
7896: PUSH
7897: LD_INT 8
7899: PUSH
7900: EMPTY
7901: LIST
7902: LIST
7903: LIST
7904: LIST
7905: PPUSH
7906: CALL 50407 0 6
7910: ST_TO_ADDR
// base := GetBase ( ru_depot2 ) ;
7911: LD_ADDR_VAR 0 4
7915: PUSH
7916: LD_INT 267
7918: PPUSH
7919: CALL_OW 274
7923: ST_TO_ADDR
// SetResourceType ( base , mat_cans , 5000 ) ;
7924: LD_VAR 0 4
7928: PPUSH
7929: LD_INT 1
7931: PPUSH
7932: LD_INT 5000
7934: PPUSH
7935: CALL_OW 277
// SetResourceType ( base , mat_oil , 200 ) ;
7939: LD_VAR 0 4
7943: PPUSH
7944: LD_INT 2
7946: PPUSH
7947: LD_INT 200
7949: PPUSH
7950: CALL_OW 277
// SetResourceType ( base , mat_siberit , 200 ) ;
7954: LD_VAR 0 4
7958: PPUSH
7959: LD_INT 3
7961: PPUSH
7962: LD_INT 200
7964: PPUSH
7965: CALL_OW 277
// mc_bases := Replace ( mc_bases , 2 , tmp union FilterAllUnits ( [ [ f_side , side ] , [ f_not , [ f_type , unit_vehicle ] ] ] ) diff Platonov ) ;
7969: LD_ADDR_EXP 56
7973: PUSH
7974: LD_EXP 56
7978: PPUSH
7979: LD_INT 2
7981: PPUSH
7982: LD_VAR 0 5
7986: PUSH
7987: LD_INT 22
7989: PUSH
7990: LD_VAR 0 6
7994: PUSH
7995: EMPTY
7996: LIST
7997: LIST
7998: PUSH
7999: LD_INT 3
8001: PUSH
8002: LD_INT 21
8004: PUSH
8005: LD_INT 2
8007: PUSH
8008: EMPTY
8009: LIST
8010: LIST
8011: PUSH
8012: EMPTY
8013: LIST
8014: LIST
8015: PUSH
8016: EMPTY
8017: LIST
8018: LIST
8019: PPUSH
8020: CALL_OW 69
8024: UNION
8025: PUSH
8026: LD_EXP 43
8030: DIFF
8031: PPUSH
8032: CALL_OW 1
8036: ST_TO_ADDR
// behemoths := [ ] ;
8037: LD_ADDR_EXP 47
8041: PUSH
8042: EMPTY
8043: ST_TO_ADDR
// behemothBuilders := [ ] ;
8044: LD_ADDR_EXP 48
8048: PUSH
8049: EMPTY
8050: ST_TO_ADDR
// j := 3 ;
8051: LD_ADDR_VAR 0 3
8055: PUSH
8056: LD_INT 3
8058: ST_TO_ADDR
// for i in FilterAllUnits ( [ [ f_side , 3 ] , [ f_class , 3 ] ] ) do
8059: LD_ADDR_VAR 0 2
8063: PUSH
8064: LD_INT 22
8066: PUSH
8067: LD_INT 3
8069: PUSH
8070: EMPTY
8071: LIST
8072: LIST
8073: PUSH
8074: LD_INT 25
8076: PUSH
8077: LD_INT 3
8079: PUSH
8080: EMPTY
8081: LIST
8082: LIST
8083: PUSH
8084: EMPTY
8085: LIST
8086: LIST
8087: PPUSH
8088: CALL_OW 69
8092: PUSH
8093: FOR_IN
8094: IFFALSE 8144
// begin behemothBuilders := Join ( behemothBuilders , i ) ;
8096: LD_ADDR_EXP 48
8100: PUSH
8101: LD_EXP 48
8105: PPUSH
8106: LD_VAR 0 2
8110: PPUSH
8111: CALL 82743 0 2
8115: ST_TO_ADDR
// j := j - 1 ;
8116: LD_ADDR_VAR 0 3
8120: PUSH
8121: LD_VAR 0 3
8125: PUSH
8126: LD_INT 1
8128: MINUS
8129: ST_TO_ADDR
// if j = 0 then
8130: LD_VAR 0 3
8134: PUSH
8135: LD_INT 0
8137: EQUAL
8138: IFFALSE 8142
// break ;
8140: GO 8144
// end ;
8142: GO 8093
8144: POP
8145: POP
// end ;
8146: LD_VAR 0 1
8150: RET
// export function BuildBehemoths ; var i , j , xy , tmp ; begin
8151: LD_INT 0
8153: PPUSH
8154: PPUSH
8155: PPUSH
8156: PPUSH
8157: PPUSH
// xy := [ [ 209 , 149 ] , [ 219 , 154 ] , [ 223 , 149 ] , [ 232 , 155 ] ] ;
8158: LD_ADDR_VAR 0 4
8162: PUSH
8163: LD_INT 209
8165: PUSH
8166: LD_INT 149
8168: PUSH
8169: EMPTY
8170: LIST
8171: LIST
8172: PUSH
8173: LD_INT 219
8175: PUSH
8176: LD_INT 154
8178: PUSH
8179: EMPTY
8180: LIST
8181: LIST
8182: PUSH
8183: LD_INT 223
8185: PUSH
8186: LD_INT 149
8188: PUSH
8189: EMPTY
8190: LIST
8191: LIST
8192: PUSH
8193: LD_INT 232
8195: PUSH
8196: LD_INT 155
8198: PUSH
8199: EMPTY
8200: LIST
8201: LIST
8202: PUSH
8203: EMPTY
8204: LIST
8205: LIST
8206: LIST
8207: LIST
8208: ST_TO_ADDR
// if not behemothBuilders then
8209: LD_EXP 48
8213: NOT
8214: IFFALSE 8218
// exit ;
8216: GO 8322
// j := 1 ;
8218: LD_ADDR_VAR 0 3
8222: PUSH
8223: LD_INT 1
8225: ST_TO_ADDR
// for i in behemothBuilders do
8226: LD_ADDR_VAR 0 2
8230: PUSH
8231: LD_EXP 48
8235: PUSH
8236: FOR_IN
8237: IFFALSE 8320
// begin if IsInUnit ( i ) then
8239: LD_VAR 0 2
8243: PPUSH
8244: CALL_OW 310
8248: IFFALSE 8259
// ComExitBuilding ( i ) ;
8250: LD_VAR 0 2
8254: PPUSH
8255: CALL_OW 122
// AddComBuildBehemoth ( i , b_behemoth , xy [ j ] [ 1 ] , xy [ j ] [ 2 ] , 0 ) ;
8259: LD_VAR 0 2
8263: PPUSH
8264: LD_INT 37
8266: PPUSH
8267: LD_VAR 0 4
8271: PUSH
8272: LD_VAR 0 3
8276: ARRAY
8277: PUSH
8278: LD_INT 1
8280: ARRAY
8281: PPUSH
8282: LD_VAR 0 4
8286: PUSH
8287: LD_VAR 0 3
8291: ARRAY
8292: PUSH
8293: LD_INT 2
8295: ARRAY
8296: PPUSH
8297: LD_INT 0
8299: PPUSH
8300: CALL_OW 230
// j := j + 1 ;
8304: LD_ADDR_VAR 0 3
8308: PUSH
8309: LD_VAR 0 3
8313: PUSH
8314: LD_INT 1
8316: PLUS
8317: ST_TO_ADDR
// end ;
8318: GO 8236
8320: POP
8321: POP
// end ;
8322: LD_VAR 0 1
8326: RET
// every 0 0$3 trigger GetBehemoths ( 3 ) and not FilterAllUnits ( [ [ f_side , 3 ] , [ f_btype , b_behemoth ] ] ) do var i , tmp ;
8327: LD_INT 3
8329: PPUSH
8330: CALL 82791 0 1
8334: PUSH
8335: LD_INT 22
8337: PUSH
8338: LD_INT 3
8340: PUSH
8341: EMPTY
8342: LIST
8343: LIST
8344: PUSH
8345: LD_INT 30
8347: PUSH
8348: LD_INT 37
8350: PUSH
8351: EMPTY
8352: LIST
8353: LIST
8354: PUSH
8355: EMPTY
8356: LIST
8357: LIST
8358: PPUSH
8359: CALL_OW 69
8363: NOT
8364: AND
8365: IFFALSE 8551
8367: GO 8369
8369: DISABLE
8370: LD_INT 0
8372: PPUSH
8373: PPUSH
// begin enable ;
8374: ENABLE
// tmp := GetBehemoths ( 3 ) ;
8375: LD_ADDR_VAR 0 2
8379: PUSH
8380: LD_INT 3
8382: PPUSH
8383: CALL 82791 0 1
8387: ST_TO_ADDR
// for i in tmp do
8388: LD_ADDR_VAR 0 1
8392: PUSH
8393: LD_VAR 0 2
8397: PUSH
8398: FOR_IN
8399: IFFALSE 8549
// begin if IsInArea ( i , powellBase ) and not GetTag ( i ) = 2 then
8401: LD_VAR 0 1
8405: PPUSH
8406: LD_INT 7
8408: PPUSH
8409: CALL_OW 308
8413: PUSH
8414: LD_VAR 0 1
8418: PPUSH
8419: CALL_OW 110
8423: PUSH
8424: LD_INT 2
8426: EQUAL
8427: NOT
8428: AND
8429: IFFALSE 8443
// SetTag ( i , 2 ) ;
8431: LD_VAR 0 1
8435: PPUSH
8436: LD_INT 2
8438: PPUSH
8439: CALL_OW 109
// if not FilterAllUnits ( [ [ f_enemy , 3 ] , [ f_dist , i , 12 ] ] ) and not GetTag ( i ) = 2 then
8443: LD_INT 81
8445: PUSH
8446: LD_INT 3
8448: PUSH
8449: EMPTY
8450: LIST
8451: LIST
8452: PUSH
8453: LD_INT 91
8455: PUSH
8456: LD_VAR 0 1
8460: PUSH
8461: LD_INT 12
8463: PUSH
8464: EMPTY
8465: LIST
8466: LIST
8467: LIST
8468: PUSH
8469: EMPTY
8470: LIST
8471: LIST
8472: PPUSH
8473: CALL_OW 69
8477: NOT
8478: PUSH
8479: LD_VAR 0 1
8483: PPUSH
8484: CALL_OW 110
8488: PUSH
8489: LD_INT 2
8491: EQUAL
8492: NOT
8493: AND
8494: IFFALSE 8513
// ComAgressiveMove ( i , 64 , 93 ) else
8496: LD_VAR 0 1
8500: PPUSH
8501: LD_INT 64
8503: PPUSH
8504: LD_INT 93
8506: PPUSH
8507: CALL_OW 114
8511: GO 8547
// ComAttackUnit ( i , NearestUnitToUnit ( FilterAllUnits ( [ f_enemy , 3 ] ) , i ) ) ;
8513: LD_VAR 0 1
8517: PPUSH
8518: LD_INT 81
8520: PUSH
8521: LD_INT 3
8523: PUSH
8524: EMPTY
8525: LIST
8526: LIST
8527: PPUSH
8528: CALL_OW 69
8532: PPUSH
8533: LD_VAR 0 1
8537: PPUSH
8538: CALL_OW 74
8542: PPUSH
8543: CALL_OW 115
// end ;
8547: GO 8398
8549: POP
8550: POP
// end ;
8551: PPOPN 2
8553: END
// every 11 11$30 trigger not russianDestroyed and not MC_GetVehicles ( 2 , true ) do var i , tmp , target , teleport ;
8554: LD_EXP 2
8558: NOT
8559: PUSH
8560: LD_INT 2
8562: PPUSH
8563: LD_INT 1
8565: PPUSH
8566: CALL 35543 0 2
8570: NOT
8571: AND
8572: IFFALSE 9492
8574: GO 8576
8576: DISABLE
8577: LD_INT 0
8579: PPUSH
8580: PPUSH
8581: PPUSH
8582: PPUSH
// begin enable ;
8583: ENABLE
// if not FilterAllUnits ( [ [ f_side , 3 ] , [ f_btype , b_factory ] ] ) then
8584: LD_INT 22
8586: PUSH
8587: LD_INT 3
8589: PUSH
8590: EMPTY
8591: LIST
8592: LIST
8593: PUSH
8594: LD_INT 30
8596: PUSH
8597: LD_INT 3
8599: PUSH
8600: EMPTY
8601: LIST
8602: LIST
8603: PUSH
8604: EMPTY
8605: LIST
8606: LIST
8607: PPUSH
8608: CALL_OW 69
8612: NOT
8613: IFFALSE 8617
// exit ;
8615: GO 9492
// teleport := FilterAllUnits ( [ [ f_side , 3 ] , [ f_btype , b_teleport ] ] ) ;
8617: LD_ADDR_VAR 0 4
8621: PUSH
8622: LD_INT 22
8624: PUSH
8625: LD_INT 3
8627: PUSH
8628: EMPTY
8629: LIST
8630: LIST
8631: PUSH
8632: LD_INT 30
8634: PUSH
8635: LD_INT 34
8637: PUSH
8638: EMPTY
8639: LIST
8640: LIST
8641: PUSH
8642: EMPTY
8643: LIST
8644: LIST
8645: PPUSH
8646: CALL_OW 69
8650: ST_TO_ADDR
// if Prob ( 40 ) then
8651: LD_INT 40
8653: PPUSH
8654: CALL_OW 13
8658: IFFALSE 8785
// begin MC_InsertProduceList ( 2 , [ [ ru_medium_tracked , engine_siberite , control_computer , ru_time_lapser ] , [ ru_medium_tracked , engine_siberite , control_computer , ru_time_lapser ] , [ ru_medium_tracked , engine_siberite , control_computer , ru_time_lapser ] , [ ru_heavy_tracked , engine_siberite , control_computer , ru_heavy_gun ] , [ ru_heavy_tracked , engine_siberite , control_computer , ru_heavy_gun ] , [ ru_heavy_tracked , engine_siberite , control_computer , ru_heavy_gun ] ] ) ;
8660: LD_INT 2
8662: PPUSH
8663: LD_INT 22
8665: PUSH
8666: LD_INT 3
8668: PUSH
8669: LD_INT 3
8671: PUSH
8672: LD_INT 49
8674: PUSH
8675: EMPTY
8676: LIST
8677: LIST
8678: LIST
8679: LIST
8680: PUSH
8681: LD_INT 22
8683: PUSH
8684: LD_INT 3
8686: PUSH
8687: LD_INT 3
8689: PUSH
8690: LD_INT 49
8692: PUSH
8693: EMPTY
8694: LIST
8695: LIST
8696: LIST
8697: LIST
8698: PUSH
8699: LD_INT 22
8701: PUSH
8702: LD_INT 3
8704: PUSH
8705: LD_INT 3
8707: PUSH
8708: LD_INT 49
8710: PUSH
8711: EMPTY
8712: LIST
8713: LIST
8714: LIST
8715: LIST
8716: PUSH
8717: LD_INT 24
8719: PUSH
8720: LD_INT 3
8722: PUSH
8723: LD_INT 3
8725: PUSH
8726: LD_INT 46
8728: PUSH
8729: EMPTY
8730: LIST
8731: LIST
8732: LIST
8733: LIST
8734: PUSH
8735: LD_INT 24
8737: PUSH
8738: LD_INT 3
8740: PUSH
8741: LD_INT 3
8743: PUSH
8744: LD_INT 46
8746: PUSH
8747: EMPTY
8748: LIST
8749: LIST
8750: LIST
8751: LIST
8752: PUSH
8753: LD_INT 24
8755: PUSH
8756: LD_INT 3
8758: PUSH
8759: LD_INT 3
8761: PUSH
8762: LD_INT 46
8764: PUSH
8765: EMPTY
8766: LIST
8767: LIST
8768: LIST
8769: LIST
8770: PUSH
8771: EMPTY
8772: LIST
8773: LIST
8774: LIST
8775: LIST
8776: LIST
8777: LIST
8778: PPUSH
8779: CALL 34125 0 2
// end else
8783: GO 8908
// begin MC_InsertProduceList ( 2 , [ [ ru_heavy_tracked , engine_siberite , control_computer , ru_rocket ] , [ ru_heavy_tracked , engine_siberite , control_computer , ru_rocket ] , [ ru_heavy_tracked , engine_siberite , control_computer , ru_rocket ] , [ ru_heavy_tracked , engine_siberite , control_computer , ru_heavy_gun ] , [ ru_heavy_tracked , engine_siberite , control_computer , ru_heavy_gun ] , [ ru_heavy_tracked , engine_siberite , control_computer , ru_heavy_gun ] ] ) ;
8785: LD_INT 2
8787: PPUSH
8788: LD_INT 24
8790: PUSH
8791: LD_INT 3
8793: PUSH
8794: LD_INT 3
8796: PUSH
8797: LD_INT 47
8799: PUSH
8800: EMPTY
8801: LIST
8802: LIST
8803: LIST
8804: LIST
8805: PUSH
8806: LD_INT 24
8808: PUSH
8809: LD_INT 3
8811: PUSH
8812: LD_INT 3
8814: PUSH
8815: LD_INT 47
8817: PUSH
8818: EMPTY
8819: LIST
8820: LIST
8821: LIST
8822: LIST
8823: PUSH
8824: LD_INT 24
8826: PUSH
8827: LD_INT 3
8829: PUSH
8830: LD_INT 3
8832: PUSH
8833: LD_INT 47
8835: PUSH
8836: EMPTY
8837: LIST
8838: LIST
8839: LIST
8840: LIST
8841: PUSH
8842: LD_INT 24
8844: PUSH
8845: LD_INT 3
8847: PUSH
8848: LD_INT 3
8850: PUSH
8851: LD_INT 46
8853: PUSH
8854: EMPTY
8855: LIST
8856: LIST
8857: LIST
8858: LIST
8859: PUSH
8860: LD_INT 24
8862: PUSH
8863: LD_INT 3
8865: PUSH
8866: LD_INT 3
8868: PUSH
8869: LD_INT 46
8871: PUSH
8872: EMPTY
8873: LIST
8874: LIST
8875: LIST
8876: LIST
8877: PUSH
8878: LD_INT 24
8880: PUSH
8881: LD_INT 3
8883: PUSH
8884: LD_INT 3
8886: PUSH
8887: LD_INT 46
8889: PUSH
8890: EMPTY
8891: LIST
8892: LIST
8893: LIST
8894: LIST
8895: PUSH
8896: EMPTY
8897: LIST
8898: LIST
8899: LIST
8900: LIST
8901: LIST
8902: LIST
8903: PPUSH
8904: CALL 34125 0 2
// end ; if Difficulty > 1 then
8908: LD_OWVAR 67
8912: PUSH
8913: LD_INT 1
8915: GREATER
8916: IFFALSE 8946
// MC_InsertProduceList ( 2 , [ [ ru_heavy_tracked , engine_siberite , control_computer , ru_rocket ] ] ) ;
8918: LD_INT 2
8920: PPUSH
8921: LD_INT 24
8923: PUSH
8924: LD_INT 3
8926: PUSH
8927: LD_INT 3
8929: PUSH
8930: LD_INT 47
8932: PUSH
8933: EMPTY
8934: LIST
8935: LIST
8936: LIST
8937: LIST
8938: PUSH
8939: EMPTY
8940: LIST
8941: PPUSH
8942: CALL 34125 0 2
// repeat wait ( 0 0$1 ) ;
8946: LD_INT 35
8948: PPUSH
8949: CALL_OW 67
// until MC_GetVehicles ( 2 , true ) >= [ 6 , 7 , 7 ] [ Difficulty ] ;
8953: LD_INT 2
8955: PPUSH
8956: LD_INT 1
8958: PPUSH
8959: CALL 35543 0 2
8963: PUSH
8964: LD_INT 6
8966: PUSH
8967: LD_INT 7
8969: PUSH
8970: LD_INT 7
8972: PUSH
8973: EMPTY
8974: LIST
8975: LIST
8976: LIST
8977: PUSH
8978: LD_OWVAR 67
8982: ARRAY
8983: GREATEREQUAL
8984: IFFALSE 8946
// wait ( 0 0$30 ) ;
8986: LD_INT 1050
8988: PPUSH
8989: CALL_OW 67
// tmp := MC_GetVehicles ( 2 , true ) ;
8993: LD_ADDR_VAR 0 2
8997: PUSH
8998: LD_INT 2
9000: PPUSH
9001: LD_INT 1
9003: PPUSH
9004: CALL 35543 0 2
9008: ST_TO_ADDR
// mc_vehicles := Replace ( mc_vehicles , 2 , mc_vehicles [ 2 ] diff tmp ) ;
9009: LD_ADDR_EXP 75
9013: PUSH
9014: LD_EXP 75
9018: PPUSH
9019: LD_INT 2
9021: PPUSH
9022: LD_EXP 75
9026: PUSH
9027: LD_INT 2
9029: ARRAY
9030: PUSH
9031: LD_VAR 0 2
9035: DIFF
9036: PPUSH
9037: CALL_OW 1
9041: ST_TO_ADDR
// target := rand ( 0 , 1 ) ;
9042: LD_ADDR_VAR 0 3
9046: PUSH
9047: LD_INT 0
9049: PPUSH
9050: LD_INT 1
9052: PPUSH
9053: CALL_OW 12
9057: ST_TO_ADDR
// if target then
9058: LD_VAR 0 3
9062: IFFALSE 9190
// begin repeat tmp := UnitFilter ( tmp , [ f_lives , 250 ] ) ;
9064: LD_ADDR_VAR 0 2
9068: PUSH
9069: LD_VAR 0 2
9073: PPUSH
9074: LD_INT 24
9076: PUSH
9077: LD_INT 250
9079: PUSH
9080: EMPTY
9081: LIST
9082: LIST
9083: PPUSH
9084: CALL_OW 72
9088: ST_TO_ADDR
// for i in tmp do
9089: LD_ADDR_VAR 0 1
9093: PUSH
9094: LD_VAR 0 2
9098: PUSH
9099: FOR_IN
9100: IFFALSE 9140
// if GetDistUnitXY ( i , 139 , 89 ) > 9 then
9102: LD_VAR 0 1
9106: PPUSH
9107: LD_INT 139
9109: PPUSH
9110: LD_INT 89
9112: PPUSH
9113: CALL_OW 297
9117: PUSH
9118: LD_INT 9
9120: GREATER
9121: IFFALSE 9138
// ComMoveXY ( i , 139 , 89 ) ;
9123: LD_VAR 0 1
9127: PPUSH
9128: LD_INT 139
9130: PPUSH
9131: LD_INT 89
9133: PPUSH
9134: CALL_OW 111
9138: GO 9099
9140: POP
9141: POP
// wait ( 0 0$1 ) ;
9142: LD_INT 35
9144: PPUSH
9145: CALL_OW 67
// until UnitFilter ( tmp , [ f_distxy , 139 , 89 , 9 ] ) >= ( tmp - 1 ) ;
9149: LD_VAR 0 2
9153: PPUSH
9154: LD_INT 92
9156: PUSH
9157: LD_INT 139
9159: PUSH
9160: LD_INT 89
9162: PUSH
9163: LD_INT 9
9165: PUSH
9166: EMPTY
9167: LIST
9168: LIST
9169: LIST
9170: LIST
9171: PPUSH
9172: CALL_OW 72
9176: PUSH
9177: LD_VAR 0 2
9181: PUSH
9182: LD_INT 1
9184: MINUS
9185: GREATEREQUAL
9186: IFFALSE 9064
// end else
9188: GO 9332
// begin ComEnterUnit ( tmp , teleport [ 1 ] ) ;
9190: LD_VAR 0 2
9194: PPUSH
9195: LD_VAR 0 4
9199: PUSH
9200: LD_INT 1
9202: ARRAY
9203: PPUSH
9204: CALL_OW 120
// repeat tmp := UnitFilter ( tmp , [ f_lives , 250 ] ) ;
9208: LD_ADDR_VAR 0 2
9212: PUSH
9213: LD_VAR 0 2
9217: PPUSH
9218: LD_INT 24
9220: PUSH
9221: LD_INT 250
9223: PUSH
9224: EMPTY
9225: LIST
9226: LIST
9227: PPUSH
9228: CALL_OW 72
9232: ST_TO_ADDR
// for i in tmp do
9233: LD_ADDR_VAR 0 1
9237: PUSH
9238: LD_VAR 0 2
9242: PUSH
9243: FOR_IN
9244: IFFALSE 9284
// if GetDistUnitXY ( i , 124 , 139 ) > 9 then
9246: LD_VAR 0 1
9250: PPUSH
9251: LD_INT 124
9253: PPUSH
9254: LD_INT 139
9256: PPUSH
9257: CALL_OW 297
9261: PUSH
9262: LD_INT 9
9264: GREATER
9265: IFFALSE 9282
// ComMoveXY ( i , 124 , 139 ) ;
9267: LD_VAR 0 1
9271: PPUSH
9272: LD_INT 124
9274: PPUSH
9275: LD_INT 139
9277: PPUSH
9278: CALL_OW 111
9282: GO 9243
9284: POP
9285: POP
// wait ( 0 0$1 ) ;
9286: LD_INT 35
9288: PPUSH
9289: CALL_OW 67
// until UnitFilter ( tmp , [ f_distxy , 124 , 139 , 9 ] ) >= ( tmp - 1 ) ;
9293: LD_VAR 0 2
9297: PPUSH
9298: LD_INT 92
9300: PUSH
9301: LD_INT 124
9303: PUSH
9304: LD_INT 139
9306: PUSH
9307: LD_INT 9
9309: PUSH
9310: EMPTY
9311: LIST
9312: LIST
9313: LIST
9314: LIST
9315: PPUSH
9316: CALL_OW 72
9320: PUSH
9321: LD_VAR 0 2
9325: PUSH
9326: LD_INT 1
9328: MINUS
9329: GREATEREQUAL
9330: IFFALSE 9208
// end ; repeat wait ( 0 0$1 ) ;
9332: LD_INT 35
9334: PPUSH
9335: CALL_OW 67
// for i in tmp do
9339: LD_ADDR_VAR 0 1
9343: PUSH
9344: LD_VAR 0 2
9348: PUSH
9349: FOR_IN
9350: IFFALSE 9483
// begin if GetLives ( i ) > 251 then
9352: LD_VAR 0 1
9356: PPUSH
9357: CALL_OW 256
9361: PUSH
9362: LD_INT 251
9364: GREATER
9365: IFFALSE 9454
// begin if GetWeapon ( i ) = ru_time_lapser then
9367: LD_VAR 0 1
9371: PPUSH
9372: CALL_OW 264
9376: PUSH
9377: LD_INT 49
9379: EQUAL
9380: IFFALSE 9418
// ComMoveUnit ( i , NearestUnitToUnit ( FilterAllUnits ( [ f_enemy , 3 ] ) , i ) ) else
9382: LD_VAR 0 1
9386: PPUSH
9387: LD_INT 81
9389: PUSH
9390: LD_INT 3
9392: PUSH
9393: EMPTY
9394: LIST
9395: LIST
9396: PPUSH
9397: CALL_OW 69
9401: PPUSH
9402: LD_VAR 0 1
9406: PPUSH
9407: CALL_OW 74
9411: PPUSH
9412: CALL_OW 112
9416: GO 9452
// ComAttackUnit ( i , NearestUnitToUnit ( FilterAllUnits ( [ f_enemy , 3 ] ) , i ) ) ;
9418: LD_VAR 0 1
9422: PPUSH
9423: LD_INT 81
9425: PUSH
9426: LD_INT 3
9428: PUSH
9429: EMPTY
9430: LIST
9431: LIST
9432: PPUSH
9433: CALL_OW 69
9437: PPUSH
9438: LD_VAR 0 1
9442: PPUSH
9443: CALL_OW 74
9447: PPUSH
9448: CALL_OW 115
// end else
9452: GO 9481
// if IsDead ( i ) then
9454: LD_VAR 0 1
9458: PPUSH
9459: CALL_OW 301
9463: IFFALSE 9481
// tmp := tmp diff i ;
9465: LD_ADDR_VAR 0 2
9469: PUSH
9470: LD_VAR 0 2
9474: PUSH
9475: LD_VAR 0 1
9479: DIFF
9480: ST_TO_ADDR
// end ;
9481: GO 9349
9483: POP
9484: POP
// until not tmp ;
9485: LD_VAR 0 2
9489: NOT
9490: IFFALSE 9332
// end ; end_of_file
9492: PPOPN 4
9494: END
// export function CustomEvent ( event ) ; begin
9495: LD_INT 0
9497: PPUSH
// end ;
9498: LD_VAR 0 2
9502: RET
// on SibDepositContaminated ( unit , x , y ) do begin if InArea ( x , y , motherLodeArea ) then
9503: LD_VAR 0 2
9507: PPUSH
9508: LD_VAR 0 3
9512: PPUSH
9513: LD_INT 15
9515: PPUSH
9516: CALL_OW 309
9520: IFFALSE 9529
// YouLost ( MothContaminate ) ;
9522: LD_STRING MothContaminate
9524: PPUSH
9525: CALL_OW 104
// end ;
9529: PPOPN 3
9531: END
// on SiberiteRocketExploded ( unit , x , y ) do begin if InArea ( x , y , motherLodeArea ) then
9532: LD_VAR 0 2
9536: PPUSH
9537: LD_VAR 0 3
9541: PPUSH
9542: LD_INT 15
9544: PPUSH
9545: CALL_OW 309
9549: IFFALSE 9565
// begin wait ( 0 0$6 ) ;
9551: LD_INT 210
9553: PPUSH
9554: CALL_OW 67
// YouLost ( MothContaminateBomb ) ;
9558: LD_STRING MothContaminateBomb
9560: PPUSH
9561: CALL_OW 104
// end ; end ;
9565: PPOPN 3
9567: END
// on UnitDestroyed ( un ) do begin if un = JMM then
9568: LD_VAR 0 1
9572: PUSH
9573: LD_EXP 6
9577: EQUAL
9578: IFFALSE 9589
// begin YouLost ( JMM ) ;
9580: LD_STRING JMM
9582: PPUSH
9583: CALL_OW 104
// exit ;
9587: GO 9598
// end ; MCE_UnitDestroyed ( un ) ;
9589: LD_VAR 0 1
9593: PPUSH
9594: CALL 37517 0 1
// end ;
9598: PPOPN 1
9600: END
// on BuildingStarted ( building , builder ) do begin MCE_BuildingStarted ( building , builder ) ;
9601: LD_VAR 0 1
9605: PPUSH
9606: LD_VAR 0 2
9610: PPUSH
9611: CALL 39629 0 2
// end ;
9615: PPOPN 2
9617: END
// on UpgradeComplete ( building ) do begin MCE_UpgradeComplete ( building ) ;
9618: LD_VAR 0 1
9622: PPUSH
9623: CALL 38697 0 1
// end ;
9627: PPOPN 1
9629: END
// on BuildingComplete ( building ) do begin if building in FilterAllUnits ( [ [ f_side , 8 ] , [ f_btype , b_workshop ] , [ f_nation , 3 ] ] ) then
9630: LD_VAR 0 1
9634: PUSH
9635: LD_INT 22
9637: PUSH
9638: LD_INT 8
9640: PUSH
9641: EMPTY
9642: LIST
9643: LIST
9644: PUSH
9645: LD_INT 30
9647: PUSH
9648: LD_INT 2
9650: PUSH
9651: EMPTY
9652: LIST
9653: LIST
9654: PUSH
9655: LD_INT 23
9657: PUSH
9658: LD_INT 3
9660: PUSH
9661: EMPTY
9662: LIST
9663: LIST
9664: PUSH
9665: EMPTY
9666: LIST
9667: LIST
9668: LIST
9669: PPUSH
9670: CALL_OW 69
9674: IN
9675: IFFALSE 9702
// begin ComUpgrade ( building ) ;
9677: LD_VAR 0 1
9681: PPUSH
9682: CALL_OW 146
// ComComplete ( Kozlov , building ) ;
9686: LD_EXP 42
9690: PPUSH
9691: LD_VAR 0 1
9695: PPUSH
9696: CALL 49971 0 2
// exit ;
9700: GO 9711
// end ; MCE_BuildingComplete ( building ) ;
9702: LD_VAR 0 1
9706: PPUSH
9707: CALL 38938 0 1
// end ;
9711: PPOPN 1
9713: END
// on ResearchComplete ( tech , lab ) do begin MCE_ResearchComplete ( tech , lab ) ;
9714: LD_VAR 0 1
9718: PPUSH
9719: LD_VAR 0 2
9723: PPUSH
9724: CALL 37213 0 2
// end ;
9728: PPOPN 2
9730: END
// on CrateSpawn ( id , x , y , amount , mode ) do begin MCE_CrateSpawn ( id , x , y , amount , mode ) ;
9731: LD_VAR 0 1
9735: PPUSH
9736: LD_VAR 0 2
9740: PPUSH
9741: LD_VAR 0 3
9745: PPUSH
9746: LD_VAR 0 4
9750: PPUSH
9751: LD_VAR 0 5
9755: PPUSH
9756: CALL 36833 0 5
// end ;
9760: PPOPN 5
9762: END
// on VehicleConstructed ( vehicle , factory ) do begin MCE_VehicleConstructed ( vehicle , factory ) ;
9763: LD_VAR 0 1
9767: PPUSH
9768: LD_VAR 0 2
9772: PPUSH
9773: CALL 36429 0 2
// end ;
9777: PPOPN 2
9779: END
// on VehicleCaptured ( new , old , side , capturing_unit ) do begin MCE_VehicleCaptured ( new , old , side , capturing_unit ) ;
9780: LD_VAR 0 1
9784: PPUSH
9785: LD_VAR 0 2
9789: PPUSH
9790: LD_VAR 0 3
9794: PPUSH
9795: LD_VAR 0 4
9799: PPUSH
9800: CALL 36267 0 4
// end ;
9804: PPOPN 4
9806: END
// on BuildingCaptured ( building , side , capturning_unit ) do begin MCE_BuildingCaptured ( building , side , capturning_unit ) ;
9807: LD_VAR 0 1
9811: PPUSH
9812: LD_VAR 0 2
9816: PPUSH
9817: LD_VAR 0 3
9821: PPUSH
9822: CALL 36042 0 3
// end ;
9826: PPOPN 3
9828: END
// on EnterBuilding ( building , unit ) do begin MCE_EnterBuilding ( building , unit ) ;
9829: LD_VAR 0 1
9833: PPUSH
9834: LD_VAR 0 2
9838: PPUSH
9839: CALL 35927 0 2
// end ;
9843: PPOPN 2
9845: END
// on LeaveBuilding ( building , unit ) do begin MCE_LeaveBuilding ( building , unit ) ;
9846: LD_VAR 0 1
9850: PPUSH
9851: LD_VAR 0 2
9855: PPUSH
9856: CALL 39890 0 2
// end ;
9860: PPOPN 2
9862: END
// on EvacuateVehicle ( driver , abandoned_vehicle , unknown1 , unknown2 ) do begin MCE_EvacuateVehicle ( driver , abandoned_vehicle , unknown1 , unknown2 ) ;
9863: LD_VAR 0 1
9867: PPUSH
9868: LD_VAR 0 2
9872: PPUSH
9873: LD_VAR 0 3
9877: PPUSH
9878: LD_VAR 0 4
9882: PPUSH
9883: CALL 40106 0 4
// end ;
9887: PPOPN 4
9889: END
// on ApemanTamed ( ape , sci ) do begin MCE_ApemanTamed ( ape , sci ) ;
9890: LD_VAR 0 1
9894: PPUSH
9895: LD_VAR 0 2
9899: PPUSH
9900: CALL 35736 0 2
// end ;
9904: PPOPN 2
9906: END
// on Command ( cmd ) do begin SOS_Command ( cmd ) ;
9907: LD_VAR 0 1
9911: PPUSH
9912: CALL 83058 0 1
// end ; end_of_file
9916: PPOPN 1
9918: END
// export function Action ; begin
9919: LD_INT 0
9921: PPUSH
// InGameOn ;
9922: CALL_OW 8
// CenterNowOnXY ( 206 , 11 ) ;
9926: LD_INT 206
9928: PPUSH
9929: LD_INT 11
9931: PPUSH
9932: CALL_OW 86
// wait ( 0 0$1 ) ;
9936: LD_INT 35
9938: PPUSH
9939: CALL_OW 67
// Say ( JMM , DStart-JMM-JMM-1 ) ;
9943: LD_EXP 6
9947: PPUSH
9948: LD_STRING DStart-JMM-JMM-1
9950: PPUSH
9951: CALL_OW 88
// Say ( Burlak , DStart-JMM-Bur-1 ) ;
9955: LD_EXP 37
9959: PPUSH
9960: LD_STRING DStart-JMM-Bur-1
9962: PPUSH
9963: CALL_OW 88
// Say ( JMM , DStart-JMM-JMM-2 ) ;
9967: LD_EXP 6
9971: PPUSH
9972: LD_STRING DStart-JMM-JMM-2
9974: PPUSH
9975: CALL_OW 88
// Say ( Burlak , DStart-JMM-Bur-2 ) ;
9979: LD_EXP 37
9983: PPUSH
9984: LD_STRING DStart-JMM-Bur-2
9986: PPUSH
9987: CALL_OW 88
// InGameOff ;
9991: CALL_OW 9
// ChangeMissionObjectives ( MStart ) ;
9995: LD_STRING MStart
9997: PPUSH
9998: CALL_OW 337
// end ;
10002: LD_VAR 0 1
10006: RET
// every 0 0$1 trigger legionDestroyed do var i , tmp ;
10007: LD_EXP 3
10011: IFFALSE 10363
10013: GO 10015
10015: DISABLE
10016: LD_INT 0
10018: PPUSH
10019: PPUSH
// begin MC_Kill ( 3 ) ;
10020: LD_INT 3
10022: PPUSH
10023: CALL 10777 0 1
// if IsOk ( Schulz ) then
10027: LD_EXP 41
10031: PPUSH
10032: CALL_OW 302
10036: IFFALSE 10058
// begin DialogueOn ;
10038: CALL_OW 6
// SayRadio ( Schulz , D15-Szulc-1 ) ;
10042: LD_EXP 41
10046: PPUSH
10047: LD_STRING D15-Szulc-1
10049: PPUSH
10050: CALL_OW 94
// DialogueOff ;
10054: CALL_OW 7
// end ; SetAttitude ( 8 , 7 , att_friend , true ) ;
10058: LD_INT 8
10060: PPUSH
10061: LD_INT 7
10063: PPUSH
10064: LD_INT 1
10066: PPUSH
10067: LD_INT 1
10069: PPUSH
10070: CALL_OW 80
// for i in FilterAllUnits ( [ [ f_side , 8 ] , [ f_type , unit_building ] , [ f_nation , 3 ] ] ) do
10074: LD_ADDR_VAR 0 1
10078: PUSH
10079: LD_INT 22
10081: PUSH
10082: LD_INT 8
10084: PUSH
10085: EMPTY
10086: LIST
10087: LIST
10088: PUSH
10089: LD_INT 21
10091: PUSH
10092: LD_INT 3
10094: PUSH
10095: EMPTY
10096: LIST
10097: LIST
10098: PUSH
10099: LD_INT 23
10101: PUSH
10102: LD_INT 3
10104: PUSH
10105: EMPTY
10106: LIST
10107: LIST
10108: PUSH
10109: EMPTY
10110: LIST
10111: LIST
10112: LIST
10113: PPUSH
10114: CALL_OW 69
10118: PUSH
10119: FOR_IN
10120: IFFALSE 10133
// DestroyUnit ( i ) ;
10122: LD_VAR 0 1
10126: PPUSH
10127: CALL_OW 65
10131: GO 10119
10133: POP
10134: POP
// tmp := FilterAllUnits ( [ [ f_side , 8 ] , [ f_type , unit_human ] ] ) ^ FilterAllUnits ( [ [ f_side , 8 ] , [ f_type , unit_vehicle ] , [ control_manual ] ] ) ;
10135: LD_ADDR_VAR 0 2
10139: PUSH
10140: LD_INT 22
10142: PUSH
10143: LD_INT 8
10145: PUSH
10146: EMPTY
10147: LIST
10148: LIST
10149: PUSH
10150: LD_INT 21
10152: PUSH
10153: LD_INT 1
10155: PUSH
10156: EMPTY
10157: LIST
10158: LIST
10159: PUSH
10160: EMPTY
10161: LIST
10162: LIST
10163: PPUSH
10164: CALL_OW 69
10168: PUSH
10169: LD_INT 22
10171: PUSH
10172: LD_INT 8
10174: PUSH
10175: EMPTY
10176: LIST
10177: LIST
10178: PUSH
10179: LD_INT 21
10181: PUSH
10182: LD_INT 2
10184: PUSH
10185: EMPTY
10186: LIST
10187: LIST
10188: PUSH
10189: LD_INT 1
10191: PUSH
10192: EMPTY
10193: LIST
10194: PUSH
10195: EMPTY
10196: LIST
10197: LIST
10198: LIST
10199: PPUSH
10200: CALL_OW 69
10204: ADD
10205: ST_TO_ADDR
// if tmp then
10206: LD_VAR 0 2
10210: IFFALSE 10363
// repeat wait ( 0 0$1 ) ;
10212: LD_INT 35
10214: PPUSH
10215: CALL_OW 67
// for i in tmp do
10219: LD_ADDR_VAR 0 1
10223: PUSH
10224: LD_VAR 0 2
10228: PUSH
10229: FOR_IN
10230: IFFALSE 10312
// begin if IsInUnit ( i ) and GetType ( IsInUnit ( i ) ) = unit_building then
10232: LD_VAR 0 1
10236: PPUSH
10237: CALL_OW 310
10241: PUSH
10242: LD_VAR 0 1
10246: PPUSH
10247: CALL_OW 310
10251: PPUSH
10252: CALL_OW 247
10256: PUSH
10257: LD_INT 3
10259: EQUAL
10260: AND
10261: IFFALSE 10272
// ComExitBuilding ( i ) ;
10263: LD_VAR 0 1
10267: PPUSH
10268: CALL_OW 122
// AddComMoveXY ( i , 10 , 1 ) ;
10272: LD_VAR 0 1
10276: PPUSH
10277: LD_INT 10
10279: PPUSH
10280: LD_INT 1
10282: PPUSH
10283: CALL_OW 171
// if IsInArea ( i , legionEscape ) then
10287: LD_VAR 0 1
10291: PPUSH
10292: LD_INT 32
10294: PPUSH
10295: CALL_OW 308
10299: IFFALSE 10310
// RemoveUnit ( i ) ;
10301: LD_VAR 0 1
10305: PPUSH
10306: CALL_OW 64
// end ;
10310: GO 10229
10312: POP
10313: POP
// until not FilterAllUnits ( [ [ f_side , 8 ] , [ f_or , [ f_type , unit_human ] , [ f_control , control_manual ] ] ] ) ;
10314: LD_INT 22
10316: PUSH
10317: LD_INT 8
10319: PUSH
10320: EMPTY
10321: LIST
10322: LIST
10323: PUSH
10324: LD_INT 2
10326: PUSH
10327: LD_INT 21
10329: PUSH
10330: LD_INT 1
10332: PUSH
10333: EMPTY
10334: LIST
10335: LIST
10336: PUSH
10337: LD_INT 33
10339: PUSH
10340: LD_INT 1
10342: PUSH
10343: EMPTY
10344: LIST
10345: LIST
10346: PUSH
10347: EMPTY
10348: LIST
10349: LIST
10350: LIST
10351: PUSH
10352: EMPTY
10353: LIST
10354: LIST
10355: PPUSH
10356: CALL_OW 69
10360: NOT
10361: IFFALSE 10212
// end ; end_of_file
10363: PPOPN 2
10365: END
// export function InitNature ; begin
10366: LD_INT 0
10368: PPUSH
// PrepareNature ( 3 , 3 , 2 , 1 , 1 , 0 , 0 , natureArea1 , 0 ) ;
10369: LD_INT 3
10371: PPUSH
10372: LD_INT 3
10374: PPUSH
10375: LD_INT 2
10377: PPUSH
10378: LD_INT 1
10380: PPUSH
10381: LD_INT 1
10383: PPUSH
10384: LD_INT 0
10386: PPUSH
10387: LD_INT 0
10389: PPUSH
10390: LD_INT 17
10392: PPUSH
10393: LD_INT 0
10395: PPUSH
10396: CALL 74812 0 9
// PrepareNature ( 2 , 1 , 1 , 1 , 1 , 0 , 0 , natureArea2 , 0 ) ;
10400: LD_INT 2
10402: PPUSH
10403: LD_INT 1
10405: PPUSH
10406: LD_INT 1
10408: PPUSH
10409: LD_INT 1
10411: PPUSH
10412: LD_INT 1
10414: PPUSH
10415: LD_INT 0
10417: PPUSH
10418: LD_INT 0
10420: PPUSH
10421: LD_INT 18
10423: PPUSH
10424: LD_INT 0
10426: PPUSH
10427: CALL 74812 0 9
// PrepareNature ( 4 , 1 , 2 , 4 , 2 , 1 , 0 , natureArea3 , 0 ) ;
10431: LD_INT 4
10433: PPUSH
10434: LD_INT 1
10436: PPUSH
10437: LD_INT 2
10439: PPUSH
10440: LD_INT 4
10442: PPUSH
10443: LD_INT 2
10445: PPUSH
10446: LD_INT 1
10448: PPUSH
10449: LD_INT 0
10451: PPUSH
10452: LD_INT 19
10454: PPUSH
10455: LD_INT 0
10457: PPUSH
10458: CALL 74812 0 9
// PrepareNature ( 0 , 0 , 0 , 0 , 0 , 0 , 9 , 0 , natureWaterArea ) ;
10462: LD_INT 0
10464: PPUSH
10465: LD_INT 0
10467: PPUSH
10468: LD_INT 0
10470: PPUSH
10471: LD_INT 0
10473: PPUSH
10474: LD_INT 0
10476: PPUSH
10477: LD_INT 0
10479: PPUSH
10480: LD_INT 9
10482: PPUSH
10483: LD_INT 0
10485: PPUSH
10486: LD_INT 20
10488: PPUSH
10489: CALL 74812 0 9
// end ; end_of_file
10493: LD_VAR 0 1
10497: RET
// export ru_radar , ru_big_cargo_bay , us_hack , us_artillery , ar_bio_bomb ; every 1 do
10498: GO 10500
10500: DISABLE
// begin ru_radar := 98 ;
10501: LD_ADDR_EXP 49
10505: PUSH
10506: LD_INT 98
10508: ST_TO_ADDR
// ru_big_cargo_bay := 89 ;
10509: LD_ADDR_EXP 50
10513: PUSH
10514: LD_INT 89
10516: ST_TO_ADDR
// us_hack := 99 ;
10517: LD_ADDR_EXP 51
10521: PUSH
10522: LD_INT 99
10524: ST_TO_ADDR
// us_artillery := 97 ;
10525: LD_ADDR_EXP 52
10529: PUSH
10530: LD_INT 97
10532: ST_TO_ADDR
// ar_bio_bomb := 91 ;
10533: LD_ADDR_EXP 53
10537: PUSH
10538: LD_INT 91
10540: ST_TO_ADDR
// end ; end_of_file
10541: END
// export skirmish , debug_mc ; export mc_bases , mc_building_need_repair , mc_building_repairs , mc_need_heal , mc_healers , mc_build_list , mc_builders , mc_construct_list , mc_turret_list , mc_empty_turret_list , mc_busy_turret_list , mc_defender_limit , mc_repair_vehicle , mc_mines , mc_miners , mc_minefields , mc_crates , mc_crates_collector , mc_crates_area , mc_vehicles , mc_attack , mc_produce , mc_defender , mc_scan , mc_parking , mc_scan_area , mc_sides , mc_tech , mc_can_tame , mc_ape , mc_ape_in_lab , mc_taming , mc_build_upgrade , mc_lab , mc_lab_upgrade , mc_teleport_exit , mc_teleport_exit_set , mc_deposits_xy , mc_deposits_finder , mc_allowed_tower_weapons , mc_remote_driver , mc_class , mc_class_case_use ; export function InitMacro ; var i ; begin
10542: LD_INT 0
10544: PPUSH
10545: PPUSH
// skirmish := false ;
10546: LD_ADDR_EXP 54
10550: PUSH
10551: LD_INT 0
10553: ST_TO_ADDR
// debug_mc := false ;
10554: LD_ADDR_EXP 55
10558: PUSH
10559: LD_INT 0
10561: ST_TO_ADDR
// mc_bases := [ ] ;
10562: LD_ADDR_EXP 56
10566: PUSH
10567: EMPTY
10568: ST_TO_ADDR
// mc_sides := [ ] ;
10569: LD_ADDR_EXP 82
10573: PUSH
10574: EMPTY
10575: ST_TO_ADDR
// mc_building_need_repair := [ ] ;
10576: LD_ADDR_EXP 57
10580: PUSH
10581: EMPTY
10582: ST_TO_ADDR
// mc_building_repairs := [ ] ;
10583: LD_ADDR_EXP 58
10587: PUSH
10588: EMPTY
10589: ST_TO_ADDR
// mc_need_heal := [ ] ;
10590: LD_ADDR_EXP 59
10594: PUSH
10595: EMPTY
10596: ST_TO_ADDR
// mc_healers := [ ] ;
10597: LD_ADDR_EXP 60
10601: PUSH
10602: EMPTY
10603: ST_TO_ADDR
// mc_build_list := [ ] ;
10604: LD_ADDR_EXP 61
10608: PUSH
10609: EMPTY
10610: ST_TO_ADDR
// mc_build_upgrade := [ ] ;
10611: LD_ADDR_EXP 88
10615: PUSH
10616: EMPTY
10617: ST_TO_ADDR
// mc_builders := [ ] ;
10618: LD_ADDR_EXP 62
10622: PUSH
10623: EMPTY
10624: ST_TO_ADDR
// mc_construct_list := [ ] ;
10625: LD_ADDR_EXP 63
10629: PUSH
10630: EMPTY
10631: ST_TO_ADDR
// mc_turret_list := [ ] ;
10632: LD_ADDR_EXP 64
10636: PUSH
10637: EMPTY
10638: ST_TO_ADDR
// mc_empty_turret_list := [ ] ;
10639: LD_ADDR_EXP 65
10643: PUSH
10644: EMPTY
10645: ST_TO_ADDR
// mc_miners := [ ] ;
10646: LD_ADDR_EXP 70
10650: PUSH
10651: EMPTY
10652: ST_TO_ADDR
// mc_mines := [ ] ;
10653: LD_ADDR_EXP 69
10657: PUSH
10658: EMPTY
10659: ST_TO_ADDR
// mc_minefields := [ ] ;
10660: LD_ADDR_EXP 71
10664: PUSH
10665: EMPTY
10666: ST_TO_ADDR
// mc_crates := [ ] ;
10667: LD_ADDR_EXP 72
10671: PUSH
10672: EMPTY
10673: ST_TO_ADDR
// mc_crates_collector := [ ] ;
10674: LD_ADDR_EXP 73
10678: PUSH
10679: EMPTY
10680: ST_TO_ADDR
// mc_crates_area := [ ] ;
10681: LD_ADDR_EXP 74
10685: PUSH
10686: EMPTY
10687: ST_TO_ADDR
// mc_vehicles := [ ] ;
10688: LD_ADDR_EXP 75
10692: PUSH
10693: EMPTY
10694: ST_TO_ADDR
// mc_attack := [ ] ;
10695: LD_ADDR_EXP 76
10699: PUSH
10700: EMPTY
10701: ST_TO_ADDR
// mc_produce := [ ] ;
10702: LD_ADDR_EXP 77
10706: PUSH
10707: EMPTY
10708: ST_TO_ADDR
// mc_defender := [ ] ;
10709: LD_ADDR_EXP 78
10713: PUSH
10714: EMPTY
10715: ST_TO_ADDR
// mc_parking := [ ] ;
10716: LD_ADDR_EXP 80
10720: PUSH
10721: EMPTY
10722: ST_TO_ADDR
// mc_busy_turret_list := [ ] ;
10723: LD_ADDR_EXP 66
10727: PUSH
10728: EMPTY
10729: ST_TO_ADDR
// mc_repair_vehicle := [ ] ;
10730: LD_ADDR_EXP 68
10734: PUSH
10735: EMPTY
10736: ST_TO_ADDR
// mc_scan := [ ] ;
10737: LD_ADDR_EXP 79
10741: PUSH
10742: EMPTY
10743: ST_TO_ADDR
// mc_scan_area := [ ] ;
10744: LD_ADDR_EXP 81
10748: PUSH
10749: EMPTY
10750: ST_TO_ADDR
// mc_tech := [ ] ;
10751: LD_ADDR_EXP 83
10755: PUSH
10756: EMPTY
10757: ST_TO_ADDR
// mc_class := [ ] ;
10758: LD_ADDR_EXP 97
10762: PUSH
10763: EMPTY
10764: ST_TO_ADDR
// mc_class_case_use := [ ] ;
10765: LD_ADDR_EXP 98
10769: PUSH
10770: EMPTY
10771: ST_TO_ADDR
// end ;
10772: LD_VAR 0 1
10776: RET
// export function MC_Kill ( base ) ; begin
10777: LD_INT 0
10779: PPUSH
// mc_bases := Replace ( mc_bases , base , [ ] ) ;
10780: LD_ADDR_EXP 56
10784: PUSH
10785: LD_EXP 56
10789: PPUSH
10790: LD_VAR 0 1
10794: PPUSH
10795: EMPTY
10796: PPUSH
10797: CALL_OW 1
10801: ST_TO_ADDR
// mc_building_need_repair := Replace ( mc_building_need_repair , base , [ ] ) ;
10802: LD_ADDR_EXP 57
10806: PUSH
10807: LD_EXP 57
10811: PPUSH
10812: LD_VAR 0 1
10816: PPUSH
10817: EMPTY
10818: PPUSH
10819: CALL_OW 1
10823: ST_TO_ADDR
// mc_building_repairs := Replace ( mc_building_repairs , base , [ ] ) ;
10824: LD_ADDR_EXP 58
10828: PUSH
10829: LD_EXP 58
10833: PPUSH
10834: LD_VAR 0 1
10838: PPUSH
10839: EMPTY
10840: PPUSH
10841: CALL_OW 1
10845: ST_TO_ADDR
// mc_need_heal := Replace ( mc_need_heal , base , [ ] ) ;
10846: LD_ADDR_EXP 59
10850: PUSH
10851: LD_EXP 59
10855: PPUSH
10856: LD_VAR 0 1
10860: PPUSH
10861: EMPTY
10862: PPUSH
10863: CALL_OW 1
10867: ST_TO_ADDR
// mc_healers := Replace ( mc_healers , base , [ ] ) ;
10868: LD_ADDR_EXP 60
10872: PUSH
10873: LD_EXP 60
10877: PPUSH
10878: LD_VAR 0 1
10882: PPUSH
10883: EMPTY
10884: PPUSH
10885: CALL_OW 1
10889: ST_TO_ADDR
// mc_build_list := Replace ( mc_build_list , base , [ ] ) ;
10890: LD_ADDR_EXP 61
10894: PUSH
10895: LD_EXP 61
10899: PPUSH
10900: LD_VAR 0 1
10904: PPUSH
10905: EMPTY
10906: PPUSH
10907: CALL_OW 1
10911: ST_TO_ADDR
// mc_builders := Replace ( mc_builders , base , [ ] ) ;
10912: LD_ADDR_EXP 62
10916: PUSH
10917: LD_EXP 62
10921: PPUSH
10922: LD_VAR 0 1
10926: PPUSH
10927: EMPTY
10928: PPUSH
10929: CALL_OW 1
10933: ST_TO_ADDR
// mc_construct_list := Replace ( mc_construct_list , base , [ ] ) ;
10934: LD_ADDR_EXP 63
10938: PUSH
10939: LD_EXP 63
10943: PPUSH
10944: LD_VAR 0 1
10948: PPUSH
10949: EMPTY
10950: PPUSH
10951: CALL_OW 1
10955: ST_TO_ADDR
// mc_turret_list := Replace ( mc_turret_list , base , [ ] ) ;
10956: LD_ADDR_EXP 64
10960: PUSH
10961: LD_EXP 64
10965: PPUSH
10966: LD_VAR 0 1
10970: PPUSH
10971: EMPTY
10972: PPUSH
10973: CALL_OW 1
10977: ST_TO_ADDR
// mc_empty_turret_list := Replace ( mc_empty_turret_list , base , [ ] ) ;
10978: LD_ADDR_EXP 65
10982: PUSH
10983: LD_EXP 65
10987: PPUSH
10988: LD_VAR 0 1
10992: PPUSH
10993: EMPTY
10994: PPUSH
10995: CALL_OW 1
10999: ST_TO_ADDR
// mc_busy_turret_list := Replace ( mc_busy_turret_list , base , [ ] ) ;
11000: LD_ADDR_EXP 66
11004: PUSH
11005: LD_EXP 66
11009: PPUSH
11010: LD_VAR 0 1
11014: PPUSH
11015: EMPTY
11016: PPUSH
11017: CALL_OW 1
11021: ST_TO_ADDR
// mc_defender_limit := Replace ( mc_defender_limit , base , 0 ) ;
11022: LD_ADDR_EXP 67
11026: PUSH
11027: LD_EXP 67
11031: PPUSH
11032: LD_VAR 0 1
11036: PPUSH
11037: LD_INT 0
11039: PPUSH
11040: CALL_OW 1
11044: ST_TO_ADDR
// mc_repair_vehicle := Replace ( mc_repair_vehicle , base , [ ] ) ;
11045: LD_ADDR_EXP 68
11049: PUSH
11050: LD_EXP 68
11054: PPUSH
11055: LD_VAR 0 1
11059: PPUSH
11060: EMPTY
11061: PPUSH
11062: CALL_OW 1
11066: ST_TO_ADDR
// mc_mines := Replace ( mc_mines , base , [ ] ) ;
11067: LD_ADDR_EXP 69
11071: PUSH
11072: LD_EXP 69
11076: PPUSH
11077: LD_VAR 0 1
11081: PPUSH
11082: EMPTY
11083: PPUSH
11084: CALL_OW 1
11088: ST_TO_ADDR
// mc_miners := Replace ( mc_miners , base , [ ] ) ;
11089: LD_ADDR_EXP 70
11093: PUSH
11094: LD_EXP 70
11098: PPUSH
11099: LD_VAR 0 1
11103: PPUSH
11104: EMPTY
11105: PPUSH
11106: CALL_OW 1
11110: ST_TO_ADDR
// mc_minefields := Replace ( mc_minefields , base , [ ] ) ;
11111: LD_ADDR_EXP 71
11115: PUSH
11116: LD_EXP 71
11120: PPUSH
11121: LD_VAR 0 1
11125: PPUSH
11126: EMPTY
11127: PPUSH
11128: CALL_OW 1
11132: ST_TO_ADDR
// mc_crates := Replace ( mc_crates , base , [ ] ) ;
11133: LD_ADDR_EXP 72
11137: PUSH
11138: LD_EXP 72
11142: PPUSH
11143: LD_VAR 0 1
11147: PPUSH
11148: EMPTY
11149: PPUSH
11150: CALL_OW 1
11154: ST_TO_ADDR
// mc_crates_collector := Replace ( mc_crates_collector , base , [ ] ) ;
11155: LD_ADDR_EXP 73
11159: PUSH
11160: LD_EXP 73
11164: PPUSH
11165: LD_VAR 0 1
11169: PPUSH
11170: EMPTY
11171: PPUSH
11172: CALL_OW 1
11176: ST_TO_ADDR
// mc_crates_area := Replace ( mc_crates_area , base , [ ] ) ;
11177: LD_ADDR_EXP 74
11181: PUSH
11182: LD_EXP 74
11186: PPUSH
11187: LD_VAR 0 1
11191: PPUSH
11192: EMPTY
11193: PPUSH
11194: CALL_OW 1
11198: ST_TO_ADDR
// mc_vehicles := Replace ( mc_vehicles , base , [ ] ) ;
11199: LD_ADDR_EXP 75
11203: PUSH
11204: LD_EXP 75
11208: PPUSH
11209: LD_VAR 0 1
11213: PPUSH
11214: EMPTY
11215: PPUSH
11216: CALL_OW 1
11220: ST_TO_ADDR
// mc_attack := Replace ( mc_attack , base , [ ] ) ;
11221: LD_ADDR_EXP 76
11225: PUSH
11226: LD_EXP 76
11230: PPUSH
11231: LD_VAR 0 1
11235: PPUSH
11236: EMPTY
11237: PPUSH
11238: CALL_OW 1
11242: ST_TO_ADDR
// mc_produce := Replace ( mc_produce , base , [ ] ) ;
11243: LD_ADDR_EXP 77
11247: PUSH
11248: LD_EXP 77
11252: PPUSH
11253: LD_VAR 0 1
11257: PPUSH
11258: EMPTY
11259: PPUSH
11260: CALL_OW 1
11264: ST_TO_ADDR
// mc_defender := Replace ( mc_defender , base , [ ] ) ;
11265: LD_ADDR_EXP 78
11269: PUSH
11270: LD_EXP 78
11274: PPUSH
11275: LD_VAR 0 1
11279: PPUSH
11280: EMPTY
11281: PPUSH
11282: CALL_OW 1
11286: ST_TO_ADDR
// mc_scan := Replace ( mc_scan , base , [ ] ) ;
11287: LD_ADDR_EXP 79
11291: PUSH
11292: LD_EXP 79
11296: PPUSH
11297: LD_VAR 0 1
11301: PPUSH
11302: EMPTY
11303: PPUSH
11304: CALL_OW 1
11308: ST_TO_ADDR
// mc_parking := Replace ( mc_parking , base , [ ] ) ;
11309: LD_ADDR_EXP 80
11313: PUSH
11314: LD_EXP 80
11318: PPUSH
11319: LD_VAR 0 1
11323: PPUSH
11324: EMPTY
11325: PPUSH
11326: CALL_OW 1
11330: ST_TO_ADDR
// mc_scan_area := Replace ( mc_scan_area , base , [ ] ) ;
11331: LD_ADDR_EXP 81
11335: PUSH
11336: LD_EXP 81
11340: PPUSH
11341: LD_VAR 0 1
11345: PPUSH
11346: EMPTY
11347: PPUSH
11348: CALL_OW 1
11352: ST_TO_ADDR
// mc_tech := Replace ( mc_tech , base , [ ] ) ;
11353: LD_ADDR_EXP 83
11357: PUSH
11358: LD_EXP 83
11362: PPUSH
11363: LD_VAR 0 1
11367: PPUSH
11368: EMPTY
11369: PPUSH
11370: CALL_OW 1
11374: ST_TO_ADDR
// mc_ape := Replace ( mc_ape , base , [ ] ) ;
11375: LD_ADDR_EXP 85
11379: PUSH
11380: LD_EXP 85
11384: PPUSH
11385: LD_VAR 0 1
11389: PPUSH
11390: EMPTY
11391: PPUSH
11392: CALL_OW 1
11396: ST_TO_ADDR
// mc_ape_in_lab := Replace ( mc_ape_in_lab , base , [ ] ) ;
11397: LD_ADDR_EXP 86
11401: PUSH
11402: LD_EXP 86
11406: PPUSH
11407: LD_VAR 0 1
11411: PPUSH
11412: EMPTY
11413: PPUSH
11414: CALL_OW 1
11418: ST_TO_ADDR
// mc_taming := Replace ( mc_taming , base , [ ] ) ;
11419: LD_ADDR_EXP 87
11423: PUSH
11424: LD_EXP 87
11428: PPUSH
11429: LD_VAR 0 1
11433: PPUSH
11434: EMPTY
11435: PPUSH
11436: CALL_OW 1
11440: ST_TO_ADDR
// mc_build_upgrade := Replace ( mc_build_upgrade , base , [ ] ) ;
11441: LD_ADDR_EXP 88
11445: PUSH
11446: LD_EXP 88
11450: PPUSH
11451: LD_VAR 0 1
11455: PPUSH
11456: EMPTY
11457: PPUSH
11458: CALL_OW 1
11462: ST_TO_ADDR
// mc_lab := Replace ( mc_lab , base , [ ] ) ;
11463: LD_ADDR_EXP 89
11467: PUSH
11468: LD_EXP 89
11472: PPUSH
11473: LD_VAR 0 1
11477: PPUSH
11478: EMPTY
11479: PPUSH
11480: CALL_OW 1
11484: ST_TO_ADDR
// mc_lab_upgrade := Replace ( mc_lab_upgrade , base , [ ] ) ;
11485: LD_ADDR_EXP 90
11489: PUSH
11490: LD_EXP 90
11494: PPUSH
11495: LD_VAR 0 1
11499: PPUSH
11500: EMPTY
11501: PPUSH
11502: CALL_OW 1
11506: ST_TO_ADDR
// mc_teleport_exit := Replace ( mc_teleport_exit , base , [ ] ) ;
11507: LD_ADDR_EXP 91
11511: PUSH
11512: LD_EXP 91
11516: PPUSH
11517: LD_VAR 0 1
11521: PPUSH
11522: EMPTY
11523: PPUSH
11524: CALL_OW 1
11528: ST_TO_ADDR
// mc_teleport_exit_set := Replace ( mc_teleport_exit_set , base , [ ] ) ;
11529: LD_ADDR_EXP 92
11533: PUSH
11534: LD_EXP 92
11538: PPUSH
11539: LD_VAR 0 1
11543: PPUSH
11544: EMPTY
11545: PPUSH
11546: CALL_OW 1
11550: ST_TO_ADDR
// mc_deposits_xy := Replace ( mc_deposits_xy , base , [ ] ) ;
11551: LD_ADDR_EXP 93
11555: PUSH
11556: LD_EXP 93
11560: PPUSH
11561: LD_VAR 0 1
11565: PPUSH
11566: EMPTY
11567: PPUSH
11568: CALL_OW 1
11572: ST_TO_ADDR
// mc_deposits_finder := Replace ( mc_deposits_finder , base , [ ] ) ;
11573: LD_ADDR_EXP 94
11577: PUSH
11578: LD_EXP 94
11582: PPUSH
11583: LD_VAR 0 1
11587: PPUSH
11588: EMPTY
11589: PPUSH
11590: CALL_OW 1
11594: ST_TO_ADDR
// mc_allowed_tower_weapons := Replace ( mc_allowed_tower_weapons , base , [ ] ) ;
11595: LD_ADDR_EXP 95
11599: PUSH
11600: LD_EXP 95
11604: PPUSH
11605: LD_VAR 0 1
11609: PPUSH
11610: EMPTY
11611: PPUSH
11612: CALL_OW 1
11616: ST_TO_ADDR
// mc_remote_driver := Replace ( mc_remote_driver , base , [ ] ) ;
11617: LD_ADDR_EXP 96
11621: PUSH
11622: LD_EXP 96
11626: PPUSH
11627: LD_VAR 0 1
11631: PPUSH
11632: EMPTY
11633: PPUSH
11634: CALL_OW 1
11638: ST_TO_ADDR
// mc_class := Replace ( mc_class , base , [ ] ) ;
11639: LD_ADDR_EXP 97
11643: PUSH
11644: LD_EXP 97
11648: PPUSH
11649: LD_VAR 0 1
11653: PPUSH
11654: EMPTY
11655: PPUSH
11656: CALL_OW 1
11660: ST_TO_ADDR
// mc_class_case_use := Replace ( mc_class_case_use , base , 0 ) ;
11661: LD_ADDR_EXP 98
11665: PUSH
11666: LD_EXP 98
11670: PPUSH
11671: LD_VAR 0 1
11675: PPUSH
11676: LD_INT 0
11678: PPUSH
11679: CALL_OW 1
11683: ST_TO_ADDR
// end ;
11684: LD_VAR 0 2
11688: RET
// export function MC_Add ( side , units ) ; var base ; begin
11689: LD_INT 0
11691: PPUSH
11692: PPUSH
// base := mc_bases + 1 ;
11693: LD_ADDR_VAR 0 4
11697: PUSH
11698: LD_EXP 56
11702: PUSH
11703: LD_INT 1
11705: PLUS
11706: ST_TO_ADDR
// mc_sides := Replace ( mc_sides , base , side ) ;
11707: LD_ADDR_EXP 82
11711: PUSH
11712: LD_EXP 82
11716: PPUSH
11717: LD_VAR 0 4
11721: PPUSH
11722: LD_VAR 0 1
11726: PPUSH
11727: CALL_OW 1
11731: ST_TO_ADDR
// mc_bases := Replace ( mc_bases , base , units ) ;
11732: LD_ADDR_EXP 56
11736: PUSH
11737: LD_EXP 56
11741: PPUSH
11742: LD_VAR 0 4
11746: PPUSH
11747: LD_VAR 0 2
11751: PPUSH
11752: CALL_OW 1
11756: ST_TO_ADDR
// mc_building_need_repair := Replace ( mc_building_need_repair , base , [ ] ) ;
11757: LD_ADDR_EXP 57
11761: PUSH
11762: LD_EXP 57
11766: PPUSH
11767: LD_VAR 0 4
11771: PPUSH
11772: EMPTY
11773: PPUSH
11774: CALL_OW 1
11778: ST_TO_ADDR
// mc_building_repairs := Replace ( mc_building_repairs , base , [ ] ) ;
11779: LD_ADDR_EXP 58
11783: PUSH
11784: LD_EXP 58
11788: PPUSH
11789: LD_VAR 0 4
11793: PPUSH
11794: EMPTY
11795: PPUSH
11796: CALL_OW 1
11800: ST_TO_ADDR
// mc_need_heal := Replace ( mc_need_heal , base , [ ] ) ;
11801: LD_ADDR_EXP 59
11805: PUSH
11806: LD_EXP 59
11810: PPUSH
11811: LD_VAR 0 4
11815: PPUSH
11816: EMPTY
11817: PPUSH
11818: CALL_OW 1
11822: ST_TO_ADDR
// mc_healers := Replace ( mc_healers , base , [ ] ) ;
11823: LD_ADDR_EXP 60
11827: PUSH
11828: LD_EXP 60
11832: PPUSH
11833: LD_VAR 0 4
11837: PPUSH
11838: EMPTY
11839: PPUSH
11840: CALL_OW 1
11844: ST_TO_ADDR
// mc_build_list := Replace ( mc_build_list , base , [ ] ) ;
11845: LD_ADDR_EXP 61
11849: PUSH
11850: LD_EXP 61
11854: PPUSH
11855: LD_VAR 0 4
11859: PPUSH
11860: EMPTY
11861: PPUSH
11862: CALL_OW 1
11866: ST_TO_ADDR
// mc_builders := Replace ( mc_builders , base , [ ] ) ;
11867: LD_ADDR_EXP 62
11871: PUSH
11872: LD_EXP 62
11876: PPUSH
11877: LD_VAR 0 4
11881: PPUSH
11882: EMPTY
11883: PPUSH
11884: CALL_OW 1
11888: ST_TO_ADDR
// mc_construct_list := Replace ( mc_construct_list , base , [ ] ) ;
11889: LD_ADDR_EXP 63
11893: PUSH
11894: LD_EXP 63
11898: PPUSH
11899: LD_VAR 0 4
11903: PPUSH
11904: EMPTY
11905: PPUSH
11906: CALL_OW 1
11910: ST_TO_ADDR
// mc_turret_list := Replace ( mc_turret_list , base , [ ] ) ;
11911: LD_ADDR_EXP 64
11915: PUSH
11916: LD_EXP 64
11920: PPUSH
11921: LD_VAR 0 4
11925: PPUSH
11926: EMPTY
11927: PPUSH
11928: CALL_OW 1
11932: ST_TO_ADDR
// mc_empty_turret_list := Replace ( mc_empty_turret_list , base , [ ] ) ;
11933: LD_ADDR_EXP 65
11937: PUSH
11938: LD_EXP 65
11942: PPUSH
11943: LD_VAR 0 4
11947: PPUSH
11948: EMPTY
11949: PPUSH
11950: CALL_OW 1
11954: ST_TO_ADDR
// mc_busy_turret_list := Replace ( mc_busy_turret_list , base , [ ] ) ;
11955: LD_ADDR_EXP 66
11959: PUSH
11960: LD_EXP 66
11964: PPUSH
11965: LD_VAR 0 4
11969: PPUSH
11970: EMPTY
11971: PPUSH
11972: CALL_OW 1
11976: ST_TO_ADDR
// mc_defender_limit := Replace ( mc_defender_limit , base , 0 ) ;
11977: LD_ADDR_EXP 67
11981: PUSH
11982: LD_EXP 67
11986: PPUSH
11987: LD_VAR 0 4
11991: PPUSH
11992: LD_INT 0
11994: PPUSH
11995: CALL_OW 1
11999: ST_TO_ADDR
// mc_repair_vehicle := Replace ( mc_repair_vehicle , base , [ ] ) ;
12000: LD_ADDR_EXP 68
12004: PUSH
12005: LD_EXP 68
12009: PPUSH
12010: LD_VAR 0 4
12014: PPUSH
12015: EMPTY
12016: PPUSH
12017: CALL_OW 1
12021: ST_TO_ADDR
// mc_mines := Replace ( mc_mines , base , [ ] ) ;
12022: LD_ADDR_EXP 69
12026: PUSH
12027: LD_EXP 69
12031: PPUSH
12032: LD_VAR 0 4
12036: PPUSH
12037: EMPTY
12038: PPUSH
12039: CALL_OW 1
12043: ST_TO_ADDR
// mc_miners := Replace ( mc_miners , base , [ ] ) ;
12044: LD_ADDR_EXP 70
12048: PUSH
12049: LD_EXP 70
12053: PPUSH
12054: LD_VAR 0 4
12058: PPUSH
12059: EMPTY
12060: PPUSH
12061: CALL_OW 1
12065: ST_TO_ADDR
// mc_minefields := Replace ( mc_minefields , base , [ ] ) ;
12066: LD_ADDR_EXP 71
12070: PUSH
12071: LD_EXP 71
12075: PPUSH
12076: LD_VAR 0 4
12080: PPUSH
12081: EMPTY
12082: PPUSH
12083: CALL_OW 1
12087: ST_TO_ADDR
// mc_crates := Replace ( mc_crates , base , [ ] ) ;
12088: LD_ADDR_EXP 72
12092: PUSH
12093: LD_EXP 72
12097: PPUSH
12098: LD_VAR 0 4
12102: PPUSH
12103: EMPTY
12104: PPUSH
12105: CALL_OW 1
12109: ST_TO_ADDR
// mc_crates_collector := Replace ( mc_crates_collector , base , [ ] ) ;
12110: LD_ADDR_EXP 73
12114: PUSH
12115: LD_EXP 73
12119: PPUSH
12120: LD_VAR 0 4
12124: PPUSH
12125: EMPTY
12126: PPUSH
12127: CALL_OW 1
12131: ST_TO_ADDR
// mc_crates_area := Replace ( mc_crates_area , base , [ ] ) ;
12132: LD_ADDR_EXP 74
12136: PUSH
12137: LD_EXP 74
12141: PPUSH
12142: LD_VAR 0 4
12146: PPUSH
12147: EMPTY
12148: PPUSH
12149: CALL_OW 1
12153: ST_TO_ADDR
// mc_vehicles := Replace ( mc_vehicles , base , [ ] ) ;
12154: LD_ADDR_EXP 75
12158: PUSH
12159: LD_EXP 75
12163: PPUSH
12164: LD_VAR 0 4
12168: PPUSH
12169: EMPTY
12170: PPUSH
12171: CALL_OW 1
12175: ST_TO_ADDR
// mc_attack := Replace ( mc_attack , base , [ ] ) ;
12176: LD_ADDR_EXP 76
12180: PUSH
12181: LD_EXP 76
12185: PPUSH
12186: LD_VAR 0 4
12190: PPUSH
12191: EMPTY
12192: PPUSH
12193: CALL_OW 1
12197: ST_TO_ADDR
// mc_produce := Replace ( mc_produce , base , [ ] ) ;
12198: LD_ADDR_EXP 77
12202: PUSH
12203: LD_EXP 77
12207: PPUSH
12208: LD_VAR 0 4
12212: PPUSH
12213: EMPTY
12214: PPUSH
12215: CALL_OW 1
12219: ST_TO_ADDR
// mc_defender := Replace ( mc_defender , base , [ ] ) ;
12220: LD_ADDR_EXP 78
12224: PUSH
12225: LD_EXP 78
12229: PPUSH
12230: LD_VAR 0 4
12234: PPUSH
12235: EMPTY
12236: PPUSH
12237: CALL_OW 1
12241: ST_TO_ADDR
// mc_scan := Replace ( mc_scan , base , [ ] ) ;
12242: LD_ADDR_EXP 79
12246: PUSH
12247: LD_EXP 79
12251: PPUSH
12252: LD_VAR 0 4
12256: PPUSH
12257: EMPTY
12258: PPUSH
12259: CALL_OW 1
12263: ST_TO_ADDR
// mc_parking := Replace ( mc_parking , base , [ ] ) ;
12264: LD_ADDR_EXP 80
12268: PUSH
12269: LD_EXP 80
12273: PPUSH
12274: LD_VAR 0 4
12278: PPUSH
12279: EMPTY
12280: PPUSH
12281: CALL_OW 1
12285: ST_TO_ADDR
// mc_scan_area := Replace ( mc_scan_area , base , [ ] ) ;
12286: LD_ADDR_EXP 81
12290: PUSH
12291: LD_EXP 81
12295: PPUSH
12296: LD_VAR 0 4
12300: PPUSH
12301: EMPTY
12302: PPUSH
12303: CALL_OW 1
12307: ST_TO_ADDR
// mc_tech := Replace ( mc_tech , base , [ ] ) ;
12308: LD_ADDR_EXP 83
12312: PUSH
12313: LD_EXP 83
12317: PPUSH
12318: LD_VAR 0 4
12322: PPUSH
12323: EMPTY
12324: PPUSH
12325: CALL_OW 1
12329: ST_TO_ADDR
// mc_ape := Replace ( mc_ape , base , [ ] ) ;
12330: LD_ADDR_EXP 85
12334: PUSH
12335: LD_EXP 85
12339: PPUSH
12340: LD_VAR 0 4
12344: PPUSH
12345: EMPTY
12346: PPUSH
12347: CALL_OW 1
12351: ST_TO_ADDR
// mc_ape_in_lab := Replace ( mc_ape_in_lab , base , [ ] ) ;
12352: LD_ADDR_EXP 86
12356: PUSH
12357: LD_EXP 86
12361: PPUSH
12362: LD_VAR 0 4
12366: PPUSH
12367: EMPTY
12368: PPUSH
12369: CALL_OW 1
12373: ST_TO_ADDR
// mc_taming := Replace ( mc_taming , base , [ ] ) ;
12374: LD_ADDR_EXP 87
12378: PUSH
12379: LD_EXP 87
12383: PPUSH
12384: LD_VAR 0 4
12388: PPUSH
12389: EMPTY
12390: PPUSH
12391: CALL_OW 1
12395: ST_TO_ADDR
// mc_build_upgrade := Replace ( mc_build_upgrade , base , [ ] ) ;
12396: LD_ADDR_EXP 88
12400: PUSH
12401: LD_EXP 88
12405: PPUSH
12406: LD_VAR 0 4
12410: PPUSH
12411: EMPTY
12412: PPUSH
12413: CALL_OW 1
12417: ST_TO_ADDR
// mc_lab := Replace ( mc_lab , base , [ ] ) ;
12418: LD_ADDR_EXP 89
12422: PUSH
12423: LD_EXP 89
12427: PPUSH
12428: LD_VAR 0 4
12432: PPUSH
12433: EMPTY
12434: PPUSH
12435: CALL_OW 1
12439: ST_TO_ADDR
// mc_lab_upgrade := Replace ( mc_lab_upgrade , base , [ ] ) ;
12440: LD_ADDR_EXP 90
12444: PUSH
12445: LD_EXP 90
12449: PPUSH
12450: LD_VAR 0 4
12454: PPUSH
12455: EMPTY
12456: PPUSH
12457: CALL_OW 1
12461: ST_TO_ADDR
// mc_teleport_exit := Replace ( mc_teleport_exit , base , [ ] ) ;
12462: LD_ADDR_EXP 91
12466: PUSH
12467: LD_EXP 91
12471: PPUSH
12472: LD_VAR 0 4
12476: PPUSH
12477: EMPTY
12478: PPUSH
12479: CALL_OW 1
12483: ST_TO_ADDR
// mc_teleport_exit_set := Replace ( mc_teleport_exit_set , base , [ ] ) ;
12484: LD_ADDR_EXP 92
12488: PUSH
12489: LD_EXP 92
12493: PPUSH
12494: LD_VAR 0 4
12498: PPUSH
12499: EMPTY
12500: PPUSH
12501: CALL_OW 1
12505: ST_TO_ADDR
// mc_deposits_xy := Replace ( mc_deposits_xy , base , [ ] ) ;
12506: LD_ADDR_EXP 93
12510: PUSH
12511: LD_EXP 93
12515: PPUSH
12516: LD_VAR 0 4
12520: PPUSH
12521: EMPTY
12522: PPUSH
12523: CALL_OW 1
12527: ST_TO_ADDR
// mc_deposits_finder := Replace ( mc_deposits_finder , base , [ ] ) ;
12528: LD_ADDR_EXP 94
12532: PUSH
12533: LD_EXP 94
12537: PPUSH
12538: LD_VAR 0 4
12542: PPUSH
12543: EMPTY
12544: PPUSH
12545: CALL_OW 1
12549: ST_TO_ADDR
// mc_allowed_tower_weapons := Replace ( mc_allowed_tower_weapons , base , [ ] ) ;
12550: LD_ADDR_EXP 95
12554: PUSH
12555: LD_EXP 95
12559: PPUSH
12560: LD_VAR 0 4
12564: PPUSH
12565: EMPTY
12566: PPUSH
12567: CALL_OW 1
12571: ST_TO_ADDR
// mc_remote_driver := Replace ( mc_remote_driver , base , [ ] ) ;
12572: LD_ADDR_EXP 96
12576: PUSH
12577: LD_EXP 96
12581: PPUSH
12582: LD_VAR 0 4
12586: PPUSH
12587: EMPTY
12588: PPUSH
12589: CALL_OW 1
12593: ST_TO_ADDR
// mc_class := Replace ( mc_class , base , [ ] ) ;
12594: LD_ADDR_EXP 97
12598: PUSH
12599: LD_EXP 97
12603: PPUSH
12604: LD_VAR 0 4
12608: PPUSH
12609: EMPTY
12610: PPUSH
12611: CALL_OW 1
12615: ST_TO_ADDR
// mc_class_case_use := Replace ( mc_class_case_use , base , 0 ) ;
12616: LD_ADDR_EXP 98
12620: PUSH
12621: LD_EXP 98
12625: PPUSH
12626: LD_VAR 0 4
12630: PPUSH
12631: LD_INT 0
12633: PPUSH
12634: CALL_OW 1
12638: ST_TO_ADDR
// result := base ;
12639: LD_ADDR_VAR 0 3
12643: PUSH
12644: LD_VAR 0 4
12648: ST_TO_ADDR
// end ;
12649: LD_VAR 0 3
12653: RET
// export function MC_Start ( ) ; var i ; begin
12654: LD_INT 0
12656: PPUSH
12657: PPUSH
// for i = 1 to mc_bases do
12658: LD_ADDR_VAR 0 2
12662: PUSH
12663: DOUBLE
12664: LD_INT 1
12666: DEC
12667: ST_TO_ADDR
12668: LD_EXP 56
12672: PUSH
12673: FOR_TO
12674: IFFALSE 13751
// begin mc_bases := Replace ( mc_bases , i , mc_bases [ i ] diff 0 ) ;
12676: LD_ADDR_EXP 56
12680: PUSH
12681: LD_EXP 56
12685: PPUSH
12686: LD_VAR 0 2
12690: PPUSH
12691: LD_EXP 56
12695: PUSH
12696: LD_VAR 0 2
12700: ARRAY
12701: PUSH
12702: LD_INT 0
12704: DIFF
12705: PPUSH
12706: CALL_OW 1
12710: ST_TO_ADDR
// mc_building_need_repair := Replace ( mc_building_need_repair , i , [ ] ) ;
12711: LD_ADDR_EXP 57
12715: PUSH
12716: LD_EXP 57
12720: PPUSH
12721: LD_VAR 0 2
12725: PPUSH
12726: EMPTY
12727: PPUSH
12728: CALL_OW 1
12732: ST_TO_ADDR
// mc_building_repairs := Replace ( mc_building_repairs , i , [ ] ) ;
12733: LD_ADDR_EXP 58
12737: PUSH
12738: LD_EXP 58
12742: PPUSH
12743: LD_VAR 0 2
12747: PPUSH
12748: EMPTY
12749: PPUSH
12750: CALL_OW 1
12754: ST_TO_ADDR
// mc_need_heal := Replace ( mc_need_heal , i , [ ] ) ;
12755: LD_ADDR_EXP 59
12759: PUSH
12760: LD_EXP 59
12764: PPUSH
12765: LD_VAR 0 2
12769: PPUSH
12770: EMPTY
12771: PPUSH
12772: CALL_OW 1
12776: ST_TO_ADDR
// mc_healers := Replace ( mc_healers , i , [ [ ] , [ ] ] ) ;
12777: LD_ADDR_EXP 60
12781: PUSH
12782: LD_EXP 60
12786: PPUSH
12787: LD_VAR 0 2
12791: PPUSH
12792: EMPTY
12793: PUSH
12794: EMPTY
12795: PUSH
12796: EMPTY
12797: LIST
12798: LIST
12799: PPUSH
12800: CALL_OW 1
12804: ST_TO_ADDR
// mc_build_list := Replace ( mc_build_list , i , [ ] ) ;
12805: LD_ADDR_EXP 61
12809: PUSH
12810: LD_EXP 61
12814: PPUSH
12815: LD_VAR 0 2
12819: PPUSH
12820: EMPTY
12821: PPUSH
12822: CALL_OW 1
12826: ST_TO_ADDR
// mc_build_upgrade := Replace ( mc_build_upgrade , i , [ ] ) ;
12827: LD_ADDR_EXP 88
12831: PUSH
12832: LD_EXP 88
12836: PPUSH
12837: LD_VAR 0 2
12841: PPUSH
12842: EMPTY
12843: PPUSH
12844: CALL_OW 1
12848: ST_TO_ADDR
// mc_builders := Replace ( mc_builders , i , [ ] ) ;
12849: LD_ADDR_EXP 62
12853: PUSH
12854: LD_EXP 62
12858: PPUSH
12859: LD_VAR 0 2
12863: PPUSH
12864: EMPTY
12865: PPUSH
12866: CALL_OW 1
12870: ST_TO_ADDR
// mc_construct_list := Replace ( mc_construct_list , i , [ ] ) ;
12871: LD_ADDR_EXP 63
12875: PUSH
12876: LD_EXP 63
12880: PPUSH
12881: LD_VAR 0 2
12885: PPUSH
12886: EMPTY
12887: PPUSH
12888: CALL_OW 1
12892: ST_TO_ADDR
// mc_turret_list := Replace ( mc_turret_list , i , UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_bunker ] , [ f_btype , b_turret ] ] ) ) ;
12893: LD_ADDR_EXP 64
12897: PUSH
12898: LD_EXP 64
12902: PPUSH
12903: LD_VAR 0 2
12907: PPUSH
12908: LD_EXP 56
12912: PUSH
12913: LD_VAR 0 2
12917: ARRAY
12918: PPUSH
12919: LD_INT 2
12921: PUSH
12922: LD_INT 30
12924: PUSH
12925: LD_INT 32
12927: PUSH
12928: EMPTY
12929: LIST
12930: LIST
12931: PUSH
12932: LD_INT 30
12934: PUSH
12935: LD_INT 33
12937: PUSH
12938: EMPTY
12939: LIST
12940: LIST
12941: PUSH
12942: EMPTY
12943: LIST
12944: LIST
12945: LIST
12946: PPUSH
12947: CALL_OW 72
12951: PPUSH
12952: CALL_OW 1
12956: ST_TO_ADDR
// mc_empty_turret_list := Replace ( mc_empty_turret_list , i , UnitFilter ( mc_bases [ i ] , [ [ f_or , [ f_btype , b_bunker ] , [ f_btype , b_breastwork ] ] , [ f_empty ] ] ) ) ;
12957: LD_ADDR_EXP 65
12961: PUSH
12962: LD_EXP 65
12966: PPUSH
12967: LD_VAR 0 2
12971: PPUSH
12972: LD_EXP 56
12976: PUSH
12977: LD_VAR 0 2
12981: ARRAY
12982: PPUSH
12983: LD_INT 2
12985: PUSH
12986: LD_INT 30
12988: PUSH
12989: LD_INT 32
12991: PUSH
12992: EMPTY
12993: LIST
12994: LIST
12995: PUSH
12996: LD_INT 30
12998: PUSH
12999: LD_INT 31
13001: PUSH
13002: EMPTY
13003: LIST
13004: LIST
13005: PUSH
13006: EMPTY
13007: LIST
13008: LIST
13009: LIST
13010: PUSH
13011: LD_INT 58
13013: PUSH
13014: EMPTY
13015: LIST
13016: PUSH
13017: EMPTY
13018: LIST
13019: LIST
13020: PPUSH
13021: CALL_OW 72
13025: PPUSH
13026: CALL_OW 1
13030: ST_TO_ADDR
// mc_busy_turret_list := Replace ( mc_busy_turret_list , i , [ ] ) ;
13031: LD_ADDR_EXP 66
13035: PUSH
13036: LD_EXP 66
13040: PPUSH
13041: LD_VAR 0 2
13045: PPUSH
13046: EMPTY
13047: PPUSH
13048: CALL_OW 1
13052: ST_TO_ADDR
// mc_miners := Replace ( mc_miners , i , [ ] ) ;
13053: LD_ADDR_EXP 70
13057: PUSH
13058: LD_EXP 70
13062: PPUSH
13063: LD_VAR 0 2
13067: PPUSH
13068: EMPTY
13069: PPUSH
13070: CALL_OW 1
13074: ST_TO_ADDR
// mc_mines := Replace ( mc_mines , i , [ ] ) ;
13075: LD_ADDR_EXP 69
13079: PUSH
13080: LD_EXP 69
13084: PPUSH
13085: LD_VAR 0 2
13089: PPUSH
13090: EMPTY
13091: PPUSH
13092: CALL_OW 1
13096: ST_TO_ADDR
// mc_minefields := Replace ( mc_minefields , i , [ ] ) ;
13097: LD_ADDR_EXP 71
13101: PUSH
13102: LD_EXP 71
13106: PPUSH
13107: LD_VAR 0 2
13111: PPUSH
13112: EMPTY
13113: PPUSH
13114: CALL_OW 1
13118: ST_TO_ADDR
// mc_crates := Replace ( mc_crates , i , [ ] ) ;
13119: LD_ADDR_EXP 72
13123: PUSH
13124: LD_EXP 72
13128: PPUSH
13129: LD_VAR 0 2
13133: PPUSH
13134: EMPTY
13135: PPUSH
13136: CALL_OW 1
13140: ST_TO_ADDR
// mc_crates_collector := Replace ( mc_crates_collector , i , [ ] ) ;
13141: LD_ADDR_EXP 73
13145: PUSH
13146: LD_EXP 73
13150: PPUSH
13151: LD_VAR 0 2
13155: PPUSH
13156: EMPTY
13157: PPUSH
13158: CALL_OW 1
13162: ST_TO_ADDR
// mc_crates_area := Replace ( mc_crates_area , i , [ ] ) ;
13163: LD_ADDR_EXP 74
13167: PUSH
13168: LD_EXP 74
13172: PPUSH
13173: LD_VAR 0 2
13177: PPUSH
13178: EMPTY
13179: PPUSH
13180: CALL_OW 1
13184: ST_TO_ADDR
// mc_vehicles := Replace ( mc_vehicles , i , [ ] ) ;
13185: LD_ADDR_EXP 75
13189: PUSH
13190: LD_EXP 75
13194: PPUSH
13195: LD_VAR 0 2
13199: PPUSH
13200: EMPTY
13201: PPUSH
13202: CALL_OW 1
13206: ST_TO_ADDR
// mc_attack := Replace ( mc_attack , i , [ ] ) ;
13207: LD_ADDR_EXP 76
13211: PUSH
13212: LD_EXP 76
13216: PPUSH
13217: LD_VAR 0 2
13221: PPUSH
13222: EMPTY
13223: PPUSH
13224: CALL_OW 1
13228: ST_TO_ADDR
// mc_produce := Replace ( mc_produce , i , [ ] ) ;
13229: LD_ADDR_EXP 77
13233: PUSH
13234: LD_EXP 77
13238: PPUSH
13239: LD_VAR 0 2
13243: PPUSH
13244: EMPTY
13245: PPUSH
13246: CALL_OW 1
13250: ST_TO_ADDR
// mc_defender := Replace ( mc_defender , i , [ ] ) ;
13251: LD_ADDR_EXP 78
13255: PUSH
13256: LD_EXP 78
13260: PPUSH
13261: LD_VAR 0 2
13265: PPUSH
13266: EMPTY
13267: PPUSH
13268: CALL_OW 1
13272: ST_TO_ADDR
// mc_defender_limit := Replace ( mc_defender_limit , i , 0 ) ;
13273: LD_ADDR_EXP 67
13277: PUSH
13278: LD_EXP 67
13282: PPUSH
13283: LD_VAR 0 2
13287: PPUSH
13288: LD_INT 0
13290: PPUSH
13291: CALL_OW 1
13295: ST_TO_ADDR
// mc_parking := Replace ( mc_parking , i , 0 ) ;
13296: LD_ADDR_EXP 80
13300: PUSH
13301: LD_EXP 80
13305: PPUSH
13306: LD_VAR 0 2
13310: PPUSH
13311: LD_INT 0
13313: PPUSH
13314: CALL_OW 1
13318: ST_TO_ADDR
// mc_repair_vehicle := Replace ( mc_repair_vehicle , i , [ ] ) ;
13319: LD_ADDR_EXP 68
13323: PUSH
13324: LD_EXP 68
13328: PPUSH
13329: LD_VAR 0 2
13333: PPUSH
13334: EMPTY
13335: PPUSH
13336: CALL_OW 1
13340: ST_TO_ADDR
// mc_scan := Replace ( mc_scan , i , 0 ) ;
13341: LD_ADDR_EXP 79
13345: PUSH
13346: LD_EXP 79
13350: PPUSH
13351: LD_VAR 0 2
13355: PPUSH
13356: LD_INT 0
13358: PPUSH
13359: CALL_OW 1
13363: ST_TO_ADDR
// mc_scan_area := Replace ( mc_scan_area , i , [ ] ) ;
13364: LD_ADDR_EXP 81
13368: PUSH
13369: LD_EXP 81
13373: PPUSH
13374: LD_VAR 0 2
13378: PPUSH
13379: EMPTY
13380: PPUSH
13381: CALL_OW 1
13385: ST_TO_ADDR
// mc_can_tame := Replace ( mc_can_tame , i , 0 ) ;
13386: LD_ADDR_EXP 84
13390: PUSH
13391: LD_EXP 84
13395: PPUSH
13396: LD_VAR 0 2
13400: PPUSH
13401: LD_INT 0
13403: PPUSH
13404: CALL_OW 1
13408: ST_TO_ADDR
// mc_ape := Replace ( mc_ape , i , [ ] ) ;
13409: LD_ADDR_EXP 85
13413: PUSH
13414: LD_EXP 85
13418: PPUSH
13419: LD_VAR 0 2
13423: PPUSH
13424: EMPTY
13425: PPUSH
13426: CALL_OW 1
13430: ST_TO_ADDR
// mc_ape_in_lab := Replace ( mc_ape_in_lab , i , [ ] ) ;
13431: LD_ADDR_EXP 86
13435: PUSH
13436: LD_EXP 86
13440: PPUSH
13441: LD_VAR 0 2
13445: PPUSH
13446: EMPTY
13447: PPUSH
13448: CALL_OW 1
13452: ST_TO_ADDR
// mc_taming := Replace ( mc_taming , i , [ ] ) ;
13453: LD_ADDR_EXP 87
13457: PUSH
13458: LD_EXP 87
13462: PPUSH
13463: LD_VAR 0 2
13467: PPUSH
13468: EMPTY
13469: PPUSH
13470: CALL_OW 1
13474: ST_TO_ADDR
// mc_lab := Replace ( mc_lab , i , UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_lab ] , [ f_btype , b_lab_half ] , [ f_btype , b_lab_full ] ] ) ) ;
13475: LD_ADDR_EXP 89
13479: PUSH
13480: LD_EXP 89
13484: PPUSH
13485: LD_VAR 0 2
13489: PPUSH
13490: LD_EXP 56
13494: PUSH
13495: LD_VAR 0 2
13499: ARRAY
13500: PPUSH
13501: LD_INT 2
13503: PUSH
13504: LD_INT 30
13506: PUSH
13507: LD_INT 6
13509: PUSH
13510: EMPTY
13511: LIST
13512: LIST
13513: PUSH
13514: LD_INT 30
13516: PUSH
13517: LD_INT 7
13519: PUSH
13520: EMPTY
13521: LIST
13522: LIST
13523: PUSH
13524: LD_INT 30
13526: PUSH
13527: LD_INT 8
13529: PUSH
13530: EMPTY
13531: LIST
13532: LIST
13533: PUSH
13534: EMPTY
13535: LIST
13536: LIST
13537: LIST
13538: LIST
13539: PPUSH
13540: CALL_OW 72
13544: PPUSH
13545: CALL_OW 1
13549: ST_TO_ADDR
// mc_lab_upgrade := Replace ( mc_lab_upgrade , i , [ ] ) ;
13550: LD_ADDR_EXP 90
13554: PUSH
13555: LD_EXP 90
13559: PPUSH
13560: LD_VAR 0 2
13564: PPUSH
13565: EMPTY
13566: PPUSH
13567: CALL_OW 1
13571: ST_TO_ADDR
// mc_teleport_exit := Replace ( mc_teleport_exit , i , [ ] ) ;
13572: LD_ADDR_EXP 91
13576: PUSH
13577: LD_EXP 91
13581: PPUSH
13582: LD_VAR 0 2
13586: PPUSH
13587: EMPTY
13588: PPUSH
13589: CALL_OW 1
13593: ST_TO_ADDR
// mc_teleport_exit_set := Replace ( mc_teleport_exit_set , i , [ ] ) ;
13594: LD_ADDR_EXP 92
13598: PUSH
13599: LD_EXP 92
13603: PPUSH
13604: LD_VAR 0 2
13608: PPUSH
13609: EMPTY
13610: PPUSH
13611: CALL_OW 1
13615: ST_TO_ADDR
// mc_deposits_xy := Replace ( mc_deposits_xy , i , [ ] ) ;
13616: LD_ADDR_EXP 93
13620: PUSH
13621: LD_EXP 93
13625: PPUSH
13626: LD_VAR 0 2
13630: PPUSH
13631: EMPTY
13632: PPUSH
13633: CALL_OW 1
13637: ST_TO_ADDR
// mc_deposits_finder := Replace ( mc_deposits_finder , i , [ ] ) ;
13638: LD_ADDR_EXP 94
13642: PUSH
13643: LD_EXP 94
13647: PPUSH
13648: LD_VAR 0 2
13652: PPUSH
13653: EMPTY
13654: PPUSH
13655: CALL_OW 1
13659: ST_TO_ADDR
// mc_allowed_tower_weapons := Replace ( mc_allowed_tower_weapons , i , [ ] ) ;
13660: LD_ADDR_EXP 95
13664: PUSH
13665: LD_EXP 95
13669: PPUSH
13670: LD_VAR 0 2
13674: PPUSH
13675: EMPTY
13676: PPUSH
13677: CALL_OW 1
13681: ST_TO_ADDR
// mc_remote_driver := Replace ( mc_remote_driver , i , [ ] ) ;
13682: LD_ADDR_EXP 96
13686: PUSH
13687: LD_EXP 96
13691: PPUSH
13692: LD_VAR 0 2
13696: PPUSH
13697: EMPTY
13698: PPUSH
13699: CALL_OW 1
13703: ST_TO_ADDR
// mc_class := Replace ( mc_class , i , [ ] ) ;
13704: LD_ADDR_EXP 97
13708: PUSH
13709: LD_EXP 97
13713: PPUSH
13714: LD_VAR 0 2
13718: PPUSH
13719: EMPTY
13720: PPUSH
13721: CALL_OW 1
13725: ST_TO_ADDR
// mc_class_case_use := Replace ( mc_class_case_use , i , 0 ) ;
13726: LD_ADDR_EXP 98
13730: PUSH
13731: LD_EXP 98
13735: PPUSH
13736: LD_VAR 0 2
13740: PPUSH
13741: LD_INT 0
13743: PPUSH
13744: CALL_OW 1
13748: ST_TO_ADDR
// end ;
13749: GO 12673
13751: POP
13752: POP
// MC_InitSides ( ) ;
13753: CALL 14039 0 0
// MC_InitResearch ( ) ;
13757: CALL 13778 0 0
// CustomInitMacro ( ) ;
13761: CALL 113 0 0
// skirmish := true ;
13765: LD_ADDR_EXP 54
13769: PUSH
13770: LD_INT 1
13772: ST_TO_ADDR
// end ;
13773: LD_VAR 0 1
13777: RET
// export function MC_InitResearch ( ) ; var i , j , nation , tmp , un ; begin
13778: LD_INT 0
13780: PPUSH
13781: PPUSH
13782: PPUSH
13783: PPUSH
13784: PPUSH
13785: PPUSH
// if not mc_bases then
13786: LD_EXP 56
13790: NOT
13791: IFFALSE 13795
// exit ;
13793: GO 14034
// for i = 1 to 8 do
13795: LD_ADDR_VAR 0 2
13799: PUSH
13800: DOUBLE
13801: LD_INT 1
13803: DEC
13804: ST_TO_ADDR
13805: LD_INT 8
13807: PUSH
13808: FOR_TO
13809: IFFALSE 13835
// mc_tech := Replace ( mc_tech , i , [ ] ) ;
13811: LD_ADDR_EXP 83
13815: PUSH
13816: LD_EXP 83
13820: PPUSH
13821: LD_VAR 0 2
13825: PPUSH
13826: EMPTY
13827: PPUSH
13828: CALL_OW 1
13832: ST_TO_ADDR
13833: GO 13808
13835: POP
13836: POP
// tmp := [ ] ;
13837: LD_ADDR_VAR 0 5
13841: PUSH
13842: EMPTY
13843: ST_TO_ADDR
// for i = 1 to mc_sides do
13844: LD_ADDR_VAR 0 2
13848: PUSH
13849: DOUBLE
13850: LD_INT 1
13852: DEC
13853: ST_TO_ADDR
13854: LD_EXP 82
13858: PUSH
13859: FOR_TO
13860: IFFALSE 13918
// if not mc_sides [ i ] in tmp then
13862: LD_EXP 82
13866: PUSH
13867: LD_VAR 0 2
13871: ARRAY
13872: PUSH
13873: LD_VAR 0 5
13877: IN
13878: NOT
13879: IFFALSE 13916
// tmp := Insert ( tmp , tmp + 1 , mc_sides [ i ] ) ;
13881: LD_ADDR_VAR 0 5
13885: PUSH
13886: LD_VAR 0 5
13890: PPUSH
13891: LD_VAR 0 5
13895: PUSH
13896: LD_INT 1
13898: PLUS
13899: PPUSH
13900: LD_EXP 82
13904: PUSH
13905: LD_VAR 0 2
13909: ARRAY
13910: PPUSH
13911: CALL_OW 2
13915: ST_TO_ADDR
13916: GO 13859
13918: POP
13919: POP
// if not tmp then
13920: LD_VAR 0 5
13924: NOT
13925: IFFALSE 13929
// exit ;
13927: GO 14034
// for j in tmp do
13929: LD_ADDR_VAR 0 3
13933: PUSH
13934: LD_VAR 0 5
13938: PUSH
13939: FOR_IN
13940: IFFALSE 14032
// begin un := FilterAllUnits ( [ f_side , j ] ) ;
13942: LD_ADDR_VAR 0 6
13946: PUSH
13947: LD_INT 22
13949: PUSH
13950: LD_VAR 0 3
13954: PUSH
13955: EMPTY
13956: LIST
13957: LIST
13958: PPUSH
13959: CALL_OW 69
13963: ST_TO_ADDR
// if not un then
13964: LD_VAR 0 6
13968: NOT
13969: IFFALSE 13973
// continue ;
13971: GO 13939
// nation := GetNation ( un [ 1 ] ) ;
13973: LD_ADDR_VAR 0 4
13977: PUSH
13978: LD_VAR 0 6
13982: PUSH
13983: LD_INT 1
13985: ARRAY
13986: PPUSH
13987: CALL_OW 248
13991: ST_TO_ADDR
// mc_tech := Replace ( mc_tech , j , GetTechNation ( j , nation , state_enabled ) ) ;
13992: LD_ADDR_EXP 83
13996: PUSH
13997: LD_EXP 83
14001: PPUSH
14002: LD_VAR 0 3
14006: PPUSH
14007: LD_VAR 0 3
14011: PPUSH
14012: LD_VAR 0 4
14016: PPUSH
14017: LD_INT 1
14019: PPUSH
14020: CALL 40310 0 3
14024: PPUSH
14025: CALL_OW 1
14029: ST_TO_ADDR
// end ;
14030: GO 13939
14032: POP
14033: POP
// end ;
14034: LD_VAR 0 1
14038: RET
// export function MC_InitSides ( ) ; var i ; begin
14039: LD_INT 0
14041: PPUSH
14042: PPUSH
// if not mc_bases then
14043: LD_EXP 56
14047: NOT
14048: IFFALSE 14052
// exit ;
14050: GO 14126
// for i = 1 to mc_bases do
14052: LD_ADDR_VAR 0 2
14056: PUSH
14057: DOUBLE
14058: LD_INT 1
14060: DEC
14061: ST_TO_ADDR
14062: LD_EXP 56
14066: PUSH
14067: FOR_TO
14068: IFFALSE 14124
// if mc_bases [ i ] then
14070: LD_EXP 56
14074: PUSH
14075: LD_VAR 0 2
14079: ARRAY
14080: IFFALSE 14122
// mc_sides := Replace ( mc_sides , i , GetSide ( mc_bases [ i ] [ 1 ] ) ) ;
14082: LD_ADDR_EXP 82
14086: PUSH
14087: LD_EXP 82
14091: PPUSH
14092: LD_VAR 0 2
14096: PPUSH
14097: LD_EXP 56
14101: PUSH
14102: LD_VAR 0 2
14106: ARRAY
14107: PUSH
14108: LD_INT 1
14110: ARRAY
14111: PPUSH
14112: CALL_OW 255
14116: PPUSH
14117: CALL_OW 1
14121: ST_TO_ADDR
14122: GO 14067
14124: POP
14125: POP
// end ;
14126: LD_VAR 0 1
14130: RET
// every 0 0$01 trigger skirmish do
14131: LD_EXP 54
14135: IFFALSE 14289
14137: GO 14139
14139: DISABLE
// begin enable ;
14140: ENABLE
// MC_CheckBuildings ( ) ;
14141: CALL 18787 0 0
// MC_CheckPeopleLife ( ) ;
14145: CALL 18912 0 0
// RaiseSailEvent ( 100 ) ;
14149: LD_INT 100
14151: PPUSH
14152: CALL_OW 427
// RaiseSailEvent ( 103 ) ;
14156: LD_INT 103
14158: PPUSH
14159: CALL_OW 427
// RaiseSailEvent ( 104 ) ;
14163: LD_INT 104
14165: PPUSH
14166: CALL_OW 427
// RaiseSailEvent ( 105 ) ;
14170: LD_INT 105
14172: PPUSH
14173: CALL_OW 427
// RaiseSailEvent ( 106 ) ;
14177: LD_INT 106
14179: PPUSH
14180: CALL_OW 427
// RaiseSailEvent ( 107 ) ;
14184: LD_INT 107
14186: PPUSH
14187: CALL_OW 427
// RaiseSailEvent ( 108 ) ;
14191: LD_INT 108
14193: PPUSH
14194: CALL_OW 427
// RaiseSailEvent ( 109 ) ;
14198: LD_INT 109
14200: PPUSH
14201: CALL_OW 427
// RaiseSailEvent ( 110 ) ;
14205: LD_INT 110
14207: PPUSH
14208: CALL_OW 427
// RaiseSailEvent ( 111 ) ;
14212: LD_INT 111
14214: PPUSH
14215: CALL_OW 427
// RaiseSailEvent ( 112 ) ;
14219: LD_INT 112
14221: PPUSH
14222: CALL_OW 427
// RaiseSailEvent ( 113 ) ;
14226: LD_INT 113
14228: PPUSH
14229: CALL_OW 427
// RaiseSailEvent ( 120 ) ;
14233: LD_INT 120
14235: PPUSH
14236: CALL_OW 427
// RaiseSailEvent ( 121 ) ;
14240: LD_INT 121
14242: PPUSH
14243: CALL_OW 427
// RaiseSailEvent ( 122 ) ;
14247: LD_INT 122
14249: PPUSH
14250: CALL_OW 427
// RaiseSailEvent ( 123 ) ;
14254: LD_INT 123
14256: PPUSH
14257: CALL_OW 427
// RaiseSailEvent ( 124 ) ;
14261: LD_INT 124
14263: PPUSH
14264: CALL_OW 427
// RaiseSailEvent ( 125 ) ;
14268: LD_INT 125
14270: PPUSH
14271: CALL_OW 427
// RaiseSailEvent ( 126 ) ;
14275: LD_INT 126
14277: PPUSH
14278: CALL_OW 427
// RaiseSailEvent ( 200 ) ;
14282: LD_INT 200
14284: PPUSH
14285: CALL_OW 427
// end ;
14289: END
// on SailEvent ( event ) do begin if event < 100 then
14290: LD_VAR 0 1
14294: PUSH
14295: LD_INT 100
14297: LESS
14298: IFFALSE 14309
// CustomEvent ( event ) ;
14300: LD_VAR 0 1
14304: PPUSH
14305: CALL 9495 0 1
// if event = 100 then
14309: LD_VAR 0 1
14313: PUSH
14314: LD_INT 100
14316: EQUAL
14317: IFFALSE 14323
// MC_ClassManager ( ) ;
14319: CALL 14715 0 0
// if event = 101 then
14323: LD_VAR 0 1
14327: PUSH
14328: LD_INT 101
14330: EQUAL
14331: IFFALSE 14337
// MC_RepairBuildings ( ) ;
14333: CALL 19508 0 0
// if event = 102 then
14337: LD_VAR 0 1
14341: PUSH
14342: LD_INT 102
14344: EQUAL
14345: IFFALSE 14351
// MC_Heal ( ) ;
14347: CALL 20240 0 0
// if event = 103 then
14351: LD_VAR 0 1
14355: PUSH
14356: LD_INT 103
14358: EQUAL
14359: IFFALSE 14365
// MC_Build ( ) ;
14361: CALL 20662 0 0
// if event = 104 then
14365: LD_VAR 0 1
14369: PUSH
14370: LD_INT 104
14372: EQUAL
14373: IFFALSE 14379
// MC_TurretWeapon ( ) ;
14375: CALL 22275 0 0
// if event = 105 then
14379: LD_VAR 0 1
14383: PUSH
14384: LD_INT 105
14386: EQUAL
14387: IFFALSE 14393
// MC_BuildUpgrade ( ) ;
14389: CALL 21826 0 0
// if event = 106 then
14393: LD_VAR 0 1
14397: PUSH
14398: LD_INT 106
14400: EQUAL
14401: IFFALSE 14407
// MC_PlantMines ( ) ;
14403: CALL 22705 0 0
// if event = 107 then
14407: LD_VAR 0 1
14411: PUSH
14412: LD_INT 107
14414: EQUAL
14415: IFFALSE 14421
// MC_CollectCrates ( ) ;
14417: CALL 23739 0 0
// if event = 108 then
14421: LD_VAR 0 1
14425: PUSH
14426: LD_INT 108
14428: EQUAL
14429: IFFALSE 14435
// MC_LinkRemoteControl ( ) ;
14431: CALL 25515 0 0
// if event = 109 then
14435: LD_VAR 0 1
14439: PUSH
14440: LD_INT 109
14442: EQUAL
14443: IFFALSE 14449
// MC_ProduceVehicle ( ) ;
14445: CALL 25696 0 0
// if event = 110 then
14449: LD_VAR 0 1
14453: PUSH
14454: LD_INT 110
14456: EQUAL
14457: IFFALSE 14463
// MC_SendAttack ( ) ;
14459: CALL 26162 0 0
// if event = 111 then
14463: LD_VAR 0 1
14467: PUSH
14468: LD_INT 111
14470: EQUAL
14471: IFFALSE 14477
// MC_Defend ( ) ;
14473: CALL 26270 0 0
// if event = 112 then
14477: LD_VAR 0 1
14481: PUSH
14482: LD_INT 112
14484: EQUAL
14485: IFFALSE 14491
// MC_Research ( ) ;
14487: CALL 26875 0 0
// if event = 113 then
14491: LD_VAR 0 1
14495: PUSH
14496: LD_INT 113
14498: EQUAL
14499: IFFALSE 14505
// MC_MinesTrigger ( ) ;
14501: CALL 27989 0 0
// if event = 120 then
14505: LD_VAR 0 1
14509: PUSH
14510: LD_INT 120
14512: EQUAL
14513: IFFALSE 14519
// MC_RepairVehicle ( ) ;
14515: CALL 28088 0 0
// if event = 121 then
14519: LD_VAR 0 1
14523: PUSH
14524: LD_INT 121
14526: EQUAL
14527: IFFALSE 14533
// MC_TameApe ( ) ;
14529: CALL 28818 0 0
// if event = 122 then
14533: LD_VAR 0 1
14537: PUSH
14538: LD_INT 122
14540: EQUAL
14541: IFFALSE 14547
// MC_ChangeApeClass ( ) ;
14543: CALL 29647 0 0
// if event = 123 then
14547: LD_VAR 0 1
14551: PUSH
14552: LD_INT 123
14554: EQUAL
14555: IFFALSE 14561
// MC_Bazooka ( ) ;
14557: CALL 30297 0 0
// if event = 124 then
14561: LD_VAR 0 1
14565: PUSH
14566: LD_INT 124
14568: EQUAL
14569: IFFALSE 14575
// MC_TeleportExit ( ) ;
14571: CALL 30495 0 0
// if event = 125 then
14575: LD_VAR 0 1
14579: PUSH
14580: LD_INT 125
14582: EQUAL
14583: IFFALSE 14589
// MC_Deposits ( ) ;
14585: CALL 31142 0 0
// if event = 126 then
14589: LD_VAR 0 1
14593: PUSH
14594: LD_INT 126
14596: EQUAL
14597: IFFALSE 14603
// MC_RemoteDriver ( ) ;
14599: CALL 31767 0 0
// if event = 200 then
14603: LD_VAR 0 1
14607: PUSH
14608: LD_INT 200
14610: EQUAL
14611: IFFALSE 14617
// MC_Idle ( ) ;
14613: CALL 33500 0 0
// end ;
14617: PPOPN 1
14619: END
// export function MC_Reset ( base , tag ) ; var i ; begin
14620: LD_INT 0
14622: PPUSH
14623: PPUSH
// if not mc_bases [ base ] or not tag then
14624: LD_EXP 56
14628: PUSH
14629: LD_VAR 0 1
14633: ARRAY
14634: NOT
14635: PUSH
14636: LD_VAR 0 2
14640: NOT
14641: OR
14642: IFFALSE 14646
// exit ;
14644: GO 14710
// for i in mc_bases [ base ] union mc_ape [ base ] do
14646: LD_ADDR_VAR 0 4
14650: PUSH
14651: LD_EXP 56
14655: PUSH
14656: LD_VAR 0 1
14660: ARRAY
14661: PUSH
14662: LD_EXP 85
14666: PUSH
14667: LD_VAR 0 1
14671: ARRAY
14672: UNION
14673: PUSH
14674: FOR_IN
14675: IFFALSE 14708
// if GetTag ( i ) = tag then
14677: LD_VAR 0 4
14681: PPUSH
14682: CALL_OW 110
14686: PUSH
14687: LD_VAR 0 2
14691: EQUAL
14692: IFFALSE 14706
// SetTag ( i , 0 ) ;
14694: LD_VAR 0 4
14698: PPUSH
14699: LD_INT 0
14701: PPUSH
14702: CALL_OW 109
14706: GO 14674
14708: POP
14709: POP
// end ;
14710: LD_VAR 0 3
14714: RET
// export function MC_ClassManager ( ) ; var i , j , tmp , p , b , e , k ; begin
14715: LD_INT 0
14717: PPUSH
14718: PPUSH
14719: PPUSH
14720: PPUSH
14721: PPUSH
14722: PPUSH
14723: PPUSH
14724: PPUSH
// if not mc_bases then
14725: LD_EXP 56
14729: NOT
14730: IFFALSE 14734
// exit ;
14732: GO 15192
// for i = 1 to mc_bases do
14734: LD_ADDR_VAR 0 2
14738: PUSH
14739: DOUBLE
14740: LD_INT 1
14742: DEC
14743: ST_TO_ADDR
14744: LD_EXP 56
14748: PUSH
14749: FOR_TO
14750: IFFALSE 15190
// begin tmp := MC_ClassCheckReq ( i ) ;
14752: LD_ADDR_VAR 0 4
14756: PUSH
14757: LD_VAR 0 2
14761: PPUSH
14762: CALL 15197 0 1
14766: ST_TO_ADDR
// mc_class := Replace ( mc_class , i , tmp ) ;
14767: LD_ADDR_EXP 97
14771: PUSH
14772: LD_EXP 97
14776: PPUSH
14777: LD_VAR 0 2
14781: PPUSH
14782: LD_VAR 0 4
14786: PPUSH
14787: CALL_OW 1
14791: ST_TO_ADDR
// if not tmp then
14792: LD_VAR 0 4
14796: NOT
14797: IFFALSE 14801
// continue ;
14799: GO 14749
// b := [ UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_armoury ] , [ f_btype , b_barracks ] ] ) , UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) , UnitFilter ( mc_bases [ i ] , [ f_btype , b_factory ] ) , UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_lab ] , [ f_btype , b_lab_half ] , [ f_btype , b_lab_full ] ] ) ] ;
14801: LD_ADDR_VAR 0 6
14805: PUSH
14806: LD_EXP 56
14810: PUSH
14811: LD_VAR 0 2
14815: ARRAY
14816: PPUSH
14817: LD_INT 2
14819: PUSH
14820: LD_INT 30
14822: PUSH
14823: LD_INT 4
14825: PUSH
14826: EMPTY
14827: LIST
14828: LIST
14829: PUSH
14830: LD_INT 30
14832: PUSH
14833: LD_INT 5
14835: PUSH
14836: EMPTY
14837: LIST
14838: LIST
14839: PUSH
14840: EMPTY
14841: LIST
14842: LIST
14843: LIST
14844: PPUSH
14845: CALL_OW 72
14849: PUSH
14850: LD_EXP 56
14854: PUSH
14855: LD_VAR 0 2
14859: ARRAY
14860: PPUSH
14861: LD_INT 2
14863: PUSH
14864: LD_INT 30
14866: PUSH
14867: LD_INT 0
14869: PUSH
14870: EMPTY
14871: LIST
14872: LIST
14873: PUSH
14874: LD_INT 30
14876: PUSH
14877: LD_INT 1
14879: PUSH
14880: EMPTY
14881: LIST
14882: LIST
14883: PUSH
14884: EMPTY
14885: LIST
14886: LIST
14887: LIST
14888: PPUSH
14889: CALL_OW 72
14893: PUSH
14894: LD_EXP 56
14898: PUSH
14899: LD_VAR 0 2
14903: ARRAY
14904: PPUSH
14905: LD_INT 30
14907: PUSH
14908: LD_INT 3
14910: PUSH
14911: EMPTY
14912: LIST
14913: LIST
14914: PPUSH
14915: CALL_OW 72
14919: PUSH
14920: LD_EXP 56
14924: PUSH
14925: LD_VAR 0 2
14929: ARRAY
14930: PPUSH
14931: LD_INT 2
14933: PUSH
14934: LD_INT 30
14936: PUSH
14937: LD_INT 6
14939: PUSH
14940: EMPTY
14941: LIST
14942: LIST
14943: PUSH
14944: LD_INT 30
14946: PUSH
14947: LD_INT 7
14949: PUSH
14950: EMPTY
14951: LIST
14952: LIST
14953: PUSH
14954: LD_INT 30
14956: PUSH
14957: LD_INT 8
14959: PUSH
14960: EMPTY
14961: LIST
14962: LIST
14963: PUSH
14964: EMPTY
14965: LIST
14966: LIST
14967: LIST
14968: LIST
14969: PPUSH
14970: CALL_OW 72
14974: PUSH
14975: EMPTY
14976: LIST
14977: LIST
14978: LIST
14979: LIST
14980: ST_TO_ADDR
// for j = 1 to 4 do
14981: LD_ADDR_VAR 0 3
14985: PUSH
14986: DOUBLE
14987: LD_INT 1
14989: DEC
14990: ST_TO_ADDR
14991: LD_INT 4
14993: PUSH
14994: FOR_TO
14995: IFFALSE 15186
// begin if not tmp [ j ] then
14997: LD_VAR 0 4
15001: PUSH
15002: LD_VAR 0 3
15006: ARRAY
15007: NOT
15008: IFFALSE 15012
// continue ;
15010: GO 14994
// for p in tmp [ j ] do
15012: LD_ADDR_VAR 0 5
15016: PUSH
15017: LD_VAR 0 4
15021: PUSH
15022: LD_VAR 0 3
15026: ARRAY
15027: PUSH
15028: FOR_IN
15029: IFFALSE 15182
// begin if not b [ j ] then
15031: LD_VAR 0 6
15035: PUSH
15036: LD_VAR 0 3
15040: ARRAY
15041: NOT
15042: IFFALSE 15046
// break ;
15044: GO 15182
// e := 0 ;
15046: LD_ADDR_VAR 0 7
15050: PUSH
15051: LD_INT 0
15053: ST_TO_ADDR
// for k in b [ j ] do
15054: LD_ADDR_VAR 0 8
15058: PUSH
15059: LD_VAR 0 6
15063: PUSH
15064: LD_VAR 0 3
15068: ARRAY
15069: PUSH
15070: FOR_IN
15071: IFFALSE 15098
// if IsNotFull ( k ) then
15073: LD_VAR 0 8
15077: PPUSH
15078: CALL 44386 0 1
15082: IFFALSE 15096
// begin e := k ;
15084: LD_ADDR_VAR 0 7
15088: PUSH
15089: LD_VAR 0 8
15093: ST_TO_ADDR
// break ;
15094: GO 15098
// end ;
15096: GO 15070
15098: POP
15099: POP
// if e and not UnitGoingToBuilding ( p , e ) then
15100: LD_VAR 0 7
15104: PUSH
15105: LD_VAR 0 5
15109: PPUSH
15110: LD_VAR 0 7
15114: PPUSH
15115: CALL 81505 0 2
15119: NOT
15120: AND
15121: IFFALSE 15180
// begin if IsInUnit ( p ) then
15123: LD_VAR 0 5
15127: PPUSH
15128: CALL_OW 310
15132: IFFALSE 15143
// ComExitBuilding ( p ) ;
15134: LD_VAR 0 5
15138: PPUSH
15139: CALL_OW 122
// ComEnterUnit ( p , e ) ;
15143: LD_VAR 0 5
15147: PPUSH
15148: LD_VAR 0 7
15152: PPUSH
15153: CALL_OW 120
// AddComChangeProfession ( p , j ) ;
15157: LD_VAR 0 5
15161: PPUSH
15162: LD_VAR 0 3
15166: PPUSH
15167: CALL_OW 183
// AddComExitBuilding ( p ) ;
15171: LD_VAR 0 5
15175: PPUSH
15176: CALL_OW 182
// end ; end ;
15180: GO 15028
15182: POP
15183: POP
// end ;
15184: GO 14994
15186: POP
15187: POP
// end ;
15188: GO 14749
15190: POP
15191: POP
// end ;
15192: LD_VAR 0 1
15196: RET
// export function MC_ClassCheckReq ( base ) ; var i , tmp , sol , eng , mech , sci , sort , j , p , b , bcount ; begin
15197: LD_INT 0
15199: PPUSH
15200: PPUSH
15201: PPUSH
15202: PPUSH
15203: PPUSH
15204: PPUSH
15205: PPUSH
15206: PPUSH
15207: PPUSH
15208: PPUSH
15209: PPUSH
15210: PPUSH
// if not base or not mc_bases [ base ] or not UnitFilter ( mc_bases [ base ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) then
15211: LD_VAR 0 1
15215: NOT
15216: PUSH
15217: LD_EXP 56
15221: PUSH
15222: LD_VAR 0 1
15226: ARRAY
15227: NOT
15228: OR
15229: PUSH
15230: LD_EXP 56
15234: PUSH
15235: LD_VAR 0 1
15239: ARRAY
15240: PPUSH
15241: LD_INT 2
15243: PUSH
15244: LD_INT 30
15246: PUSH
15247: LD_INT 0
15249: PUSH
15250: EMPTY
15251: LIST
15252: LIST
15253: PUSH
15254: LD_INT 30
15256: PUSH
15257: LD_INT 1
15259: PUSH
15260: EMPTY
15261: LIST
15262: LIST
15263: PUSH
15264: EMPTY
15265: LIST
15266: LIST
15267: LIST
15268: PPUSH
15269: CALL_OW 72
15273: NOT
15274: OR
15275: IFFALSE 15279
// exit ;
15277: GO 18782
// tmp := UnitFilter ( mc_bases [ base ] , [ f_or , [ f_class , 1 ] , [ f_class , 2 ] , [ f_class , 3 ] , [ f_class , 4 ] , [ f_class , 5 ] , [ f_class , 8 ] , [ f_class , 9 ] ] ) ;
15279: LD_ADDR_VAR 0 4
15283: PUSH
15284: LD_EXP 56
15288: PUSH
15289: LD_VAR 0 1
15293: ARRAY
15294: PPUSH
15295: LD_INT 2
15297: PUSH
15298: LD_INT 25
15300: PUSH
15301: LD_INT 1
15303: PUSH
15304: EMPTY
15305: LIST
15306: LIST
15307: PUSH
15308: LD_INT 25
15310: PUSH
15311: LD_INT 2
15313: PUSH
15314: EMPTY
15315: LIST
15316: LIST
15317: PUSH
15318: LD_INT 25
15320: PUSH
15321: LD_INT 3
15323: PUSH
15324: EMPTY
15325: LIST
15326: LIST
15327: PUSH
15328: LD_INT 25
15330: PUSH
15331: LD_INT 4
15333: PUSH
15334: EMPTY
15335: LIST
15336: LIST
15337: PUSH
15338: LD_INT 25
15340: PUSH
15341: LD_INT 5
15343: PUSH
15344: EMPTY
15345: LIST
15346: LIST
15347: PUSH
15348: LD_INT 25
15350: PUSH
15351: LD_INT 8
15353: PUSH
15354: EMPTY
15355: LIST
15356: LIST
15357: PUSH
15358: LD_INT 25
15360: PUSH
15361: LD_INT 9
15363: PUSH
15364: EMPTY
15365: LIST
15366: LIST
15367: PUSH
15368: EMPTY
15369: LIST
15370: LIST
15371: LIST
15372: LIST
15373: LIST
15374: LIST
15375: LIST
15376: LIST
15377: PPUSH
15378: CALL_OW 72
15382: ST_TO_ADDR
// if not tmp then
15383: LD_VAR 0 4
15387: NOT
15388: IFFALSE 15392
// exit ;
15390: GO 18782
// for i in tmp do
15392: LD_ADDR_VAR 0 3
15396: PUSH
15397: LD_VAR 0 4
15401: PUSH
15402: FOR_IN
15403: IFFALSE 15434
// if GetTag ( i ) then
15405: LD_VAR 0 3
15409: PPUSH
15410: CALL_OW 110
15414: IFFALSE 15432
// tmp := tmp diff i ;
15416: LD_ADDR_VAR 0 4
15420: PUSH
15421: LD_VAR 0 4
15425: PUSH
15426: LD_VAR 0 3
15430: DIFF
15431: ST_TO_ADDR
15432: GO 15402
15434: POP
15435: POP
// if not tmp then
15436: LD_VAR 0 4
15440: NOT
15441: IFFALSE 15445
// exit ;
15443: GO 18782
// sol := UnitFilter ( mc_bases [ base ] , [ f_or , [ f_class , 1 ] , [ f_class , 5 ] , [ f_class , 8 ] , [ f_class , 9 ] ] ) ;
15445: LD_ADDR_VAR 0 5
15449: PUSH
15450: LD_EXP 56
15454: PUSH
15455: LD_VAR 0 1
15459: ARRAY
15460: PPUSH
15461: LD_INT 2
15463: PUSH
15464: LD_INT 25
15466: PUSH
15467: LD_INT 1
15469: PUSH
15470: EMPTY
15471: LIST
15472: LIST
15473: PUSH
15474: LD_INT 25
15476: PUSH
15477: LD_INT 5
15479: PUSH
15480: EMPTY
15481: LIST
15482: LIST
15483: PUSH
15484: LD_INT 25
15486: PUSH
15487: LD_INT 8
15489: PUSH
15490: EMPTY
15491: LIST
15492: LIST
15493: PUSH
15494: LD_INT 25
15496: PUSH
15497: LD_INT 9
15499: PUSH
15500: EMPTY
15501: LIST
15502: LIST
15503: PUSH
15504: EMPTY
15505: LIST
15506: LIST
15507: LIST
15508: LIST
15509: LIST
15510: PPUSH
15511: CALL_OW 72
15515: ST_TO_ADDR
// eng := UnitFilter ( mc_bases [ base ] , [ f_class , 2 ] ) ;
15516: LD_ADDR_VAR 0 6
15520: PUSH
15521: LD_EXP 56
15525: PUSH
15526: LD_VAR 0 1
15530: ARRAY
15531: PPUSH
15532: LD_INT 25
15534: PUSH
15535: LD_INT 2
15537: PUSH
15538: EMPTY
15539: LIST
15540: LIST
15541: PPUSH
15542: CALL_OW 72
15546: ST_TO_ADDR
// mech := UnitFilter ( mc_bases [ base ] , [ f_class , 3 ] ) ;
15547: LD_ADDR_VAR 0 7
15551: PUSH
15552: LD_EXP 56
15556: PUSH
15557: LD_VAR 0 1
15561: ARRAY
15562: PPUSH
15563: LD_INT 25
15565: PUSH
15566: LD_INT 3
15568: PUSH
15569: EMPTY
15570: LIST
15571: LIST
15572: PPUSH
15573: CALL_OW 72
15577: ST_TO_ADDR
// sci := UnitFilter ( mc_bases [ base ] , [ [ f_class , 4 ] , [ f_lives , 251 ] ] ) ;
15578: LD_ADDR_VAR 0 8
15582: PUSH
15583: LD_EXP 56
15587: PUSH
15588: LD_VAR 0 1
15592: ARRAY
15593: PPUSH
15594: LD_INT 25
15596: PUSH
15597: LD_INT 4
15599: PUSH
15600: EMPTY
15601: LIST
15602: LIST
15603: PUSH
15604: LD_INT 24
15606: PUSH
15607: LD_INT 251
15609: PUSH
15610: EMPTY
15611: LIST
15612: LIST
15613: PUSH
15614: EMPTY
15615: LIST
15616: LIST
15617: PPUSH
15618: CALL_OW 72
15622: ST_TO_ADDR
// if mc_scan [ base ] then
15623: LD_EXP 79
15627: PUSH
15628: LD_VAR 0 1
15632: ARRAY
15633: IFFALSE 16094
// begin mc_class_case_use := Replace ( mc_class_case_use , base , 4 ) ;
15635: LD_ADDR_EXP 98
15639: PUSH
15640: LD_EXP 98
15644: PPUSH
15645: LD_VAR 0 1
15649: PPUSH
15650: LD_INT 4
15652: PPUSH
15653: CALL_OW 1
15657: ST_TO_ADDR
// b := UnitFilter ( mc_bases [ base ] , [ f_or , [ f_btype , b_armoury ] , [ f_btype , b_barracks ] ] ) ;
15658: LD_ADDR_VAR 0 12
15662: PUSH
15663: LD_EXP 56
15667: PUSH
15668: LD_VAR 0 1
15672: ARRAY
15673: PPUSH
15674: LD_INT 2
15676: PUSH
15677: LD_INT 30
15679: PUSH
15680: LD_INT 4
15682: PUSH
15683: EMPTY
15684: LIST
15685: LIST
15686: PUSH
15687: LD_INT 30
15689: PUSH
15690: LD_INT 5
15692: PUSH
15693: EMPTY
15694: LIST
15695: LIST
15696: PUSH
15697: EMPTY
15698: LIST
15699: LIST
15700: LIST
15701: PPUSH
15702: CALL_OW 72
15706: ST_TO_ADDR
// if not b then
15707: LD_VAR 0 12
15711: NOT
15712: IFFALSE 15716
// exit ;
15714: GO 18782
// p := [ ] ;
15716: LD_ADDR_VAR 0 11
15720: PUSH
15721: EMPTY
15722: ST_TO_ADDR
// if sci >= 2 then
15723: LD_VAR 0 8
15727: PUSH
15728: LD_INT 2
15730: GREATEREQUAL
15731: IFFALSE 15762
// sci := [ sci [ 1 ] , sci [ 2 ] ] else
15733: LD_ADDR_VAR 0 8
15737: PUSH
15738: LD_VAR 0 8
15742: PUSH
15743: LD_INT 1
15745: ARRAY
15746: PUSH
15747: LD_VAR 0 8
15751: PUSH
15752: LD_INT 2
15754: ARRAY
15755: PUSH
15756: EMPTY
15757: LIST
15758: LIST
15759: ST_TO_ADDR
15760: GO 15823
// if sci = 1 then
15762: LD_VAR 0 8
15766: PUSH
15767: LD_INT 1
15769: EQUAL
15770: IFFALSE 15791
// sci := [ sci [ 1 ] ] else
15772: LD_ADDR_VAR 0 8
15776: PUSH
15777: LD_VAR 0 8
15781: PUSH
15782: LD_INT 1
15784: ARRAY
15785: PUSH
15786: EMPTY
15787: LIST
15788: ST_TO_ADDR
15789: GO 15823
// if sci = 0 then
15791: LD_VAR 0 8
15795: PUSH
15796: LD_INT 0
15798: EQUAL
15799: IFFALSE 15823
// p := SortBySkill ( tmp , 4 ) [ 1 ] ;
15801: LD_ADDR_VAR 0 11
15805: PUSH
15806: LD_VAR 0 4
15810: PPUSH
15811: LD_INT 4
15813: PPUSH
15814: CALL 81368 0 2
15818: PUSH
15819: LD_INT 1
15821: ARRAY
15822: ST_TO_ADDR
// if eng > 4 then
15823: LD_VAR 0 6
15827: PUSH
15828: LD_INT 4
15830: GREATER
15831: IFFALSE 15877
// for i = eng downto 4 do
15833: LD_ADDR_VAR 0 3
15837: PUSH
15838: DOUBLE
15839: LD_VAR 0 6
15843: INC
15844: ST_TO_ADDR
15845: LD_INT 4
15847: PUSH
15848: FOR_DOWNTO
15849: IFFALSE 15875
// eng := eng diff eng [ i ] ;
15851: LD_ADDR_VAR 0 6
15855: PUSH
15856: LD_VAR 0 6
15860: PUSH
15861: LD_VAR 0 6
15865: PUSH
15866: LD_VAR 0 3
15870: ARRAY
15871: DIFF
15872: ST_TO_ADDR
15873: GO 15848
15875: POP
15876: POP
// tmp := tmp diff ( sol union eng union mech union sci ) ;
15877: LD_ADDR_VAR 0 4
15881: PUSH
15882: LD_VAR 0 4
15886: PUSH
15887: LD_VAR 0 5
15891: PUSH
15892: LD_VAR 0 6
15896: UNION
15897: PUSH
15898: LD_VAR 0 7
15902: UNION
15903: PUSH
15904: LD_VAR 0 8
15908: UNION
15909: DIFF
15910: ST_TO_ADDR
// bcount := UnitFilter ( mc_bases [ base ] , [ f_or , [ f_btype , b_bunker ] , [ f_btype , b_breastwork ] ] ) + UnitFilter ( mc_bases [ base ] , [ f_or , [ f_btype , b_armoury ] , [ f_btype , b_barracks ] ] ) * 6 ;
15911: LD_ADDR_VAR 0 13
15915: PUSH
15916: LD_EXP 56
15920: PUSH
15921: LD_VAR 0 1
15925: ARRAY
15926: PPUSH
15927: LD_INT 2
15929: PUSH
15930: LD_INT 30
15932: PUSH
15933: LD_INT 32
15935: PUSH
15936: EMPTY
15937: LIST
15938: LIST
15939: PUSH
15940: LD_INT 30
15942: PUSH
15943: LD_INT 31
15945: PUSH
15946: EMPTY
15947: LIST
15948: LIST
15949: PUSH
15950: EMPTY
15951: LIST
15952: LIST
15953: LIST
15954: PPUSH
15955: CALL_OW 72
15959: PUSH
15960: LD_EXP 56
15964: PUSH
15965: LD_VAR 0 1
15969: ARRAY
15970: PPUSH
15971: LD_INT 2
15973: PUSH
15974: LD_INT 30
15976: PUSH
15977: LD_INT 4
15979: PUSH
15980: EMPTY
15981: LIST
15982: LIST
15983: PUSH
15984: LD_INT 30
15986: PUSH
15987: LD_INT 5
15989: PUSH
15990: EMPTY
15991: LIST
15992: LIST
15993: PUSH
15994: EMPTY
15995: LIST
15996: LIST
15997: LIST
15998: PPUSH
15999: CALL_OW 72
16003: PUSH
16004: LD_INT 6
16006: MUL
16007: PLUS
16008: ST_TO_ADDR
// if bcount < tmp then
16009: LD_VAR 0 13
16013: PUSH
16014: LD_VAR 0 4
16018: LESS
16019: IFFALSE 16065
// for i = tmp downto bcount do
16021: LD_ADDR_VAR 0 3
16025: PUSH
16026: DOUBLE
16027: LD_VAR 0 4
16031: INC
16032: ST_TO_ADDR
16033: LD_VAR 0 13
16037: PUSH
16038: FOR_DOWNTO
16039: IFFALSE 16063
// tmp := Delete ( tmp , tmp ) ;
16041: LD_ADDR_VAR 0 4
16045: PUSH
16046: LD_VAR 0 4
16050: PPUSH
16051: LD_VAR 0 4
16055: PPUSH
16056: CALL_OW 3
16060: ST_TO_ADDR
16061: GO 16038
16063: POP
16064: POP
// result := [ tmp , 0 , 0 , p ] ;
16065: LD_ADDR_VAR 0 2
16069: PUSH
16070: LD_VAR 0 4
16074: PUSH
16075: LD_INT 0
16077: PUSH
16078: LD_INT 0
16080: PUSH
16081: LD_VAR 0 11
16085: PUSH
16086: EMPTY
16087: LIST
16088: LIST
16089: LIST
16090: LIST
16091: ST_TO_ADDR
// exit ;
16092: GO 18782
// end ; if not UnitFilter ( mc_bases [ base ] , [ f_or , [ f_btype , b_lab ] , [ f_btype , b_lab_half ] , [ f_btype , b_lab_full ] ] ) and not UnitFilter ( mc_bases [ base ] , [ f_btype , b_factory ] ) then
16094: LD_EXP 56
16098: PUSH
16099: LD_VAR 0 1
16103: ARRAY
16104: PPUSH
16105: LD_INT 2
16107: PUSH
16108: LD_INT 30
16110: PUSH
16111: LD_INT 6
16113: PUSH
16114: EMPTY
16115: LIST
16116: LIST
16117: PUSH
16118: LD_INT 30
16120: PUSH
16121: LD_INT 7
16123: PUSH
16124: EMPTY
16125: LIST
16126: LIST
16127: PUSH
16128: LD_INT 30
16130: PUSH
16131: LD_INT 8
16133: PUSH
16134: EMPTY
16135: LIST
16136: LIST
16137: PUSH
16138: EMPTY
16139: LIST
16140: LIST
16141: LIST
16142: LIST
16143: PPUSH
16144: CALL_OW 72
16148: NOT
16149: PUSH
16150: LD_EXP 56
16154: PUSH
16155: LD_VAR 0 1
16159: ARRAY
16160: PPUSH
16161: LD_INT 30
16163: PUSH
16164: LD_INT 3
16166: PUSH
16167: EMPTY
16168: LIST
16169: LIST
16170: PPUSH
16171: CALL_OW 72
16175: NOT
16176: AND
16177: IFFALSE 16249
// begin if eng = tmp then
16179: LD_VAR 0 6
16183: PUSH
16184: LD_VAR 0 4
16188: EQUAL
16189: IFFALSE 16193
// exit ;
16191: GO 18782
// mc_class_case_use := Replace ( mc_class_case_use , base , 1 ) ;
16193: LD_ADDR_EXP 98
16197: PUSH
16198: LD_EXP 98
16202: PPUSH
16203: LD_VAR 0 1
16207: PPUSH
16208: LD_INT 1
16210: PPUSH
16211: CALL_OW 1
16215: ST_TO_ADDR
// result := [ 0 , tmp diff eng , 0 , 0 ] ;
16216: LD_ADDR_VAR 0 2
16220: PUSH
16221: LD_INT 0
16223: PUSH
16224: LD_VAR 0 4
16228: PUSH
16229: LD_VAR 0 6
16233: DIFF
16234: PUSH
16235: LD_INT 0
16237: PUSH
16238: LD_INT 0
16240: PUSH
16241: EMPTY
16242: LIST
16243: LIST
16244: LIST
16245: LIST
16246: ST_TO_ADDR
// exit ;
16247: GO 18782
// end ; if mc_tech [ mc_sides [ base ] ] and UnitFilter ( mc_bases [ base ] , [ f_or , [ f_btype , b_lab ] , [ f_btype , b_lab_half ] , [ f_btype , b_lab_full ] ] ) and not UnitFilter ( mc_bases [ base ] , [ f_btype , b_factory ] ) then
16249: LD_EXP 83
16253: PUSH
16254: LD_EXP 82
16258: PUSH
16259: LD_VAR 0 1
16263: ARRAY
16264: ARRAY
16265: PUSH
16266: LD_EXP 56
16270: PUSH
16271: LD_VAR 0 1
16275: ARRAY
16276: PPUSH
16277: LD_INT 2
16279: PUSH
16280: LD_INT 30
16282: PUSH
16283: LD_INT 6
16285: PUSH
16286: EMPTY
16287: LIST
16288: LIST
16289: PUSH
16290: LD_INT 30
16292: PUSH
16293: LD_INT 7
16295: PUSH
16296: EMPTY
16297: LIST
16298: LIST
16299: PUSH
16300: LD_INT 30
16302: PUSH
16303: LD_INT 8
16305: PUSH
16306: EMPTY
16307: LIST
16308: LIST
16309: PUSH
16310: EMPTY
16311: LIST
16312: LIST
16313: LIST
16314: LIST
16315: PPUSH
16316: CALL_OW 72
16320: AND
16321: PUSH
16322: LD_EXP 56
16326: PUSH
16327: LD_VAR 0 1
16331: ARRAY
16332: PPUSH
16333: LD_INT 30
16335: PUSH
16336: LD_INT 3
16338: PUSH
16339: EMPTY
16340: LIST
16341: LIST
16342: PPUSH
16343: CALL_OW 72
16347: NOT
16348: AND
16349: IFFALSE 16563
// begin if sci >= 6 then
16351: LD_VAR 0 8
16355: PUSH
16356: LD_INT 6
16358: GREATEREQUAL
16359: IFFALSE 16363
// exit ;
16361: GO 18782
// mc_class_case_use := Replace ( mc_class_case_use , base , 2 ) ;
16363: LD_ADDR_EXP 98
16367: PUSH
16368: LD_EXP 98
16372: PPUSH
16373: LD_VAR 0 1
16377: PPUSH
16378: LD_INT 2
16380: PPUSH
16381: CALL_OW 1
16385: ST_TO_ADDR
// sort := SortBySkill ( tmp diff sci , 4 ) ;
16386: LD_ADDR_VAR 0 9
16390: PUSH
16391: LD_VAR 0 4
16395: PUSH
16396: LD_VAR 0 8
16400: DIFF
16401: PPUSH
16402: LD_INT 4
16404: PPUSH
16405: CALL 81368 0 2
16409: ST_TO_ADDR
// p := [ ] ;
16410: LD_ADDR_VAR 0 11
16414: PUSH
16415: EMPTY
16416: ST_TO_ADDR
// if sci < 6 and sort > 6 then
16417: LD_VAR 0 8
16421: PUSH
16422: LD_INT 6
16424: LESS
16425: PUSH
16426: LD_VAR 0 9
16430: PUSH
16431: LD_INT 6
16433: GREATER
16434: AND
16435: IFFALSE 16516
// begin for i = 1 to 6 - sci do
16437: LD_ADDR_VAR 0 3
16441: PUSH
16442: DOUBLE
16443: LD_INT 1
16445: DEC
16446: ST_TO_ADDR
16447: LD_INT 6
16449: PUSH
16450: LD_VAR 0 8
16454: MINUS
16455: PUSH
16456: FOR_TO
16457: IFFALSE 16512
// begin p := Insert ( p , p + 1 , sort [ 1 ] ) ;
16459: LD_ADDR_VAR 0 11
16463: PUSH
16464: LD_VAR 0 11
16468: PPUSH
16469: LD_VAR 0 11
16473: PUSH
16474: LD_INT 1
16476: PLUS
16477: PPUSH
16478: LD_VAR 0 9
16482: PUSH
16483: LD_INT 1
16485: ARRAY
16486: PPUSH
16487: CALL_OW 2
16491: ST_TO_ADDR
// sort := Delete ( sort , 1 ) ;
16492: LD_ADDR_VAR 0 9
16496: PUSH
16497: LD_VAR 0 9
16501: PPUSH
16502: LD_INT 1
16504: PPUSH
16505: CALL_OW 3
16509: ST_TO_ADDR
// end ;
16510: GO 16456
16512: POP
16513: POP
// end else
16514: GO 16536
// if sort then
16516: LD_VAR 0 9
16520: IFFALSE 16536
// p := sort [ 1 ] ;
16522: LD_ADDR_VAR 0 11
16526: PUSH
16527: LD_VAR 0 9
16531: PUSH
16532: LD_INT 1
16534: ARRAY
16535: ST_TO_ADDR
// result := [ 0 , 0 , 0 , p ] ;
16536: LD_ADDR_VAR 0 2
16540: PUSH
16541: LD_INT 0
16543: PUSH
16544: LD_INT 0
16546: PUSH
16547: LD_INT 0
16549: PUSH
16550: LD_VAR 0 11
16554: PUSH
16555: EMPTY
16556: LIST
16557: LIST
16558: LIST
16559: LIST
16560: ST_TO_ADDR
// exit ;
16561: GO 18782
// end ; if mc_tech [ mc_sides [ base ] ] and UnitFilter ( mc_bases [ base ] , [ f_or , [ f_btype , b_lab ] , [ f_btype , b_lab_half ] , [ f_btype , b_lab_full ] ] ) and UnitFilter ( mc_bases [ base ] , [ f_btype , b_factory ] ) then
16563: LD_EXP 83
16567: PUSH
16568: LD_EXP 82
16572: PUSH
16573: LD_VAR 0 1
16577: ARRAY
16578: ARRAY
16579: PUSH
16580: LD_EXP 56
16584: PUSH
16585: LD_VAR 0 1
16589: ARRAY
16590: PPUSH
16591: LD_INT 2
16593: PUSH
16594: LD_INT 30
16596: PUSH
16597: LD_INT 6
16599: PUSH
16600: EMPTY
16601: LIST
16602: LIST
16603: PUSH
16604: LD_INT 30
16606: PUSH
16607: LD_INT 7
16609: PUSH
16610: EMPTY
16611: LIST
16612: LIST
16613: PUSH
16614: LD_INT 30
16616: PUSH
16617: LD_INT 8
16619: PUSH
16620: EMPTY
16621: LIST
16622: LIST
16623: PUSH
16624: EMPTY
16625: LIST
16626: LIST
16627: LIST
16628: LIST
16629: PPUSH
16630: CALL_OW 72
16634: AND
16635: PUSH
16636: LD_EXP 56
16640: PUSH
16641: LD_VAR 0 1
16645: ARRAY
16646: PPUSH
16647: LD_INT 30
16649: PUSH
16650: LD_INT 3
16652: PUSH
16653: EMPTY
16654: LIST
16655: LIST
16656: PPUSH
16657: CALL_OW 72
16661: AND
16662: IFFALSE 17396
// begin mc_class_case_use := Replace ( mc_class_case_use , base , 3 ) ;
16664: LD_ADDR_EXP 98
16668: PUSH
16669: LD_EXP 98
16673: PPUSH
16674: LD_VAR 0 1
16678: PPUSH
16679: LD_INT 3
16681: PPUSH
16682: CALL_OW 1
16686: ST_TO_ADDR
// result := [ 0 , 0 , 0 , 0 ] ;
16687: LD_ADDR_VAR 0 2
16691: PUSH
16692: LD_INT 0
16694: PUSH
16695: LD_INT 0
16697: PUSH
16698: LD_INT 0
16700: PUSH
16701: LD_INT 0
16703: PUSH
16704: EMPTY
16705: LIST
16706: LIST
16707: LIST
16708: LIST
16709: ST_TO_ADDR
// if not eng then
16710: LD_VAR 0 6
16714: NOT
16715: IFFALSE 16778
// begin p := SortBySkill ( tmp , 2 ) [ 1 ] ;
16717: LD_ADDR_VAR 0 11
16721: PUSH
16722: LD_VAR 0 4
16726: PPUSH
16727: LD_INT 2
16729: PPUSH
16730: CALL 81368 0 2
16734: PUSH
16735: LD_INT 1
16737: ARRAY
16738: ST_TO_ADDR
// result := Replace ( result , 2 , p ) ;
16739: LD_ADDR_VAR 0 2
16743: PUSH
16744: LD_VAR 0 2
16748: PPUSH
16749: LD_INT 2
16751: PPUSH
16752: LD_VAR 0 11
16756: PPUSH
16757: CALL_OW 1
16761: ST_TO_ADDR
// tmp := tmp diff p ;
16762: LD_ADDR_VAR 0 4
16766: PUSH
16767: LD_VAR 0 4
16771: PUSH
16772: LD_VAR 0 11
16776: DIFF
16777: ST_TO_ADDR
// end ; if tmp and sci < 6 then
16778: LD_VAR 0 4
16782: PUSH
16783: LD_VAR 0 8
16787: PUSH
16788: LD_INT 6
16790: LESS
16791: AND
16792: IFFALSE 16980
// begin sort := SortBySkill ( tmp diff ( sci union mech ) , 4 ) ;
16794: LD_ADDR_VAR 0 9
16798: PUSH
16799: LD_VAR 0 4
16803: PUSH
16804: LD_VAR 0 8
16808: PUSH
16809: LD_VAR 0 7
16813: UNION
16814: DIFF
16815: PPUSH
16816: LD_INT 4
16818: PPUSH
16819: CALL 81368 0 2
16823: ST_TO_ADDR
// p := [ ] ;
16824: LD_ADDR_VAR 0 11
16828: PUSH
16829: EMPTY
16830: ST_TO_ADDR
// if sort then
16831: LD_VAR 0 9
16835: IFFALSE 16951
// for i = 1 to 6 - sci do
16837: LD_ADDR_VAR 0 3
16841: PUSH
16842: DOUBLE
16843: LD_INT 1
16845: DEC
16846: ST_TO_ADDR
16847: LD_INT 6
16849: PUSH
16850: LD_VAR 0 8
16854: MINUS
16855: PUSH
16856: FOR_TO
16857: IFFALSE 16949
// begin if i = sort then
16859: LD_VAR 0 3
16863: PUSH
16864: LD_VAR 0 9
16868: EQUAL
16869: IFFALSE 16873
// break ;
16871: GO 16949
// if GetClass ( i ) = 4 then
16873: LD_VAR 0 3
16877: PPUSH
16878: CALL_OW 257
16882: PUSH
16883: LD_INT 4
16885: EQUAL
16886: IFFALSE 16890
// continue ;
16888: GO 16856
// p := Insert ( p , p + 1 , sort [ i ] ) ;
16890: LD_ADDR_VAR 0 11
16894: PUSH
16895: LD_VAR 0 11
16899: PPUSH
16900: LD_VAR 0 11
16904: PUSH
16905: LD_INT 1
16907: PLUS
16908: PPUSH
16909: LD_VAR 0 9
16913: PUSH
16914: LD_VAR 0 3
16918: ARRAY
16919: PPUSH
16920: CALL_OW 2
16924: ST_TO_ADDR
// tmp := tmp diff sort [ i ] ;
16925: LD_ADDR_VAR 0 4
16929: PUSH
16930: LD_VAR 0 4
16934: PUSH
16935: LD_VAR 0 9
16939: PUSH
16940: LD_VAR 0 3
16944: ARRAY
16945: DIFF
16946: ST_TO_ADDR
// end ;
16947: GO 16856
16949: POP
16950: POP
// if p then
16951: LD_VAR 0 11
16955: IFFALSE 16980
// result := Replace ( result , 4 , p ) ;
16957: LD_ADDR_VAR 0 2
16961: PUSH
16962: LD_VAR 0 2
16966: PPUSH
16967: LD_INT 4
16969: PPUSH
16970: LD_VAR 0 11
16974: PPUSH
16975: CALL_OW 1
16979: ST_TO_ADDR
// end ; if tmp and mech < 6 then
16980: LD_VAR 0 4
16984: PUSH
16985: LD_VAR 0 7
16989: PUSH
16990: LD_INT 6
16992: LESS
16993: AND
16994: IFFALSE 17182
// begin sort := SortBySkill ( tmp diff ( sci union mech ) , 3 ) ;
16996: LD_ADDR_VAR 0 9
17000: PUSH
17001: LD_VAR 0 4
17005: PUSH
17006: LD_VAR 0 8
17010: PUSH
17011: LD_VAR 0 7
17015: UNION
17016: DIFF
17017: PPUSH
17018: LD_INT 3
17020: PPUSH
17021: CALL 81368 0 2
17025: ST_TO_ADDR
// p := [ ] ;
17026: LD_ADDR_VAR 0 11
17030: PUSH
17031: EMPTY
17032: ST_TO_ADDR
// if sort then
17033: LD_VAR 0 9
17037: IFFALSE 17153
// for i = 1 to 6 - mech do
17039: LD_ADDR_VAR 0 3
17043: PUSH
17044: DOUBLE
17045: LD_INT 1
17047: DEC
17048: ST_TO_ADDR
17049: LD_INT 6
17051: PUSH
17052: LD_VAR 0 7
17056: MINUS
17057: PUSH
17058: FOR_TO
17059: IFFALSE 17151
// begin if i = sort then
17061: LD_VAR 0 3
17065: PUSH
17066: LD_VAR 0 9
17070: EQUAL
17071: IFFALSE 17075
// break ;
17073: GO 17151
// if GetClass ( i ) = 3 then
17075: LD_VAR 0 3
17079: PPUSH
17080: CALL_OW 257
17084: PUSH
17085: LD_INT 3
17087: EQUAL
17088: IFFALSE 17092
// continue ;
17090: GO 17058
// p := Insert ( p , p + 1 , sort [ i ] ) ;
17092: LD_ADDR_VAR 0 11
17096: PUSH
17097: LD_VAR 0 11
17101: PPUSH
17102: LD_VAR 0 11
17106: PUSH
17107: LD_INT 1
17109: PLUS
17110: PPUSH
17111: LD_VAR 0 9
17115: PUSH
17116: LD_VAR 0 3
17120: ARRAY
17121: PPUSH
17122: CALL_OW 2
17126: ST_TO_ADDR
// tmp := tmp diff sort [ i ] ;
17127: LD_ADDR_VAR 0 4
17131: PUSH
17132: LD_VAR 0 4
17136: PUSH
17137: LD_VAR 0 9
17141: PUSH
17142: LD_VAR 0 3
17146: ARRAY
17147: DIFF
17148: ST_TO_ADDR
// end ;
17149: GO 17058
17151: POP
17152: POP
// if p then
17153: LD_VAR 0 11
17157: IFFALSE 17182
// result := Replace ( result , 3 , p ) ;
17159: LD_ADDR_VAR 0 2
17163: PUSH
17164: LD_VAR 0 2
17168: PPUSH
17169: LD_INT 3
17171: PPUSH
17172: LD_VAR 0 11
17176: PPUSH
17177: CALL_OW 1
17181: ST_TO_ADDR
// end ; if tmp > 6 and eng < 6 then
17182: LD_VAR 0 4
17186: PUSH
17187: LD_INT 6
17189: GREATER
17190: PUSH
17191: LD_VAR 0 6
17195: PUSH
17196: LD_INT 6
17198: LESS
17199: AND
17200: IFFALSE 17394
// begin sort := SortBySkill ( tmp diff ( sci union mech union eng ) , 2 ) ;
17202: LD_ADDR_VAR 0 9
17206: PUSH
17207: LD_VAR 0 4
17211: PUSH
17212: LD_VAR 0 8
17216: PUSH
17217: LD_VAR 0 7
17221: UNION
17222: PUSH
17223: LD_VAR 0 6
17227: UNION
17228: DIFF
17229: PPUSH
17230: LD_INT 2
17232: PPUSH
17233: CALL 81368 0 2
17237: ST_TO_ADDR
// p := [ ] ;
17238: LD_ADDR_VAR 0 11
17242: PUSH
17243: EMPTY
17244: ST_TO_ADDR
// if sort then
17245: LD_VAR 0 9
17249: IFFALSE 17365
// for i = 1 to 6 - eng do
17251: LD_ADDR_VAR 0 3
17255: PUSH
17256: DOUBLE
17257: LD_INT 1
17259: DEC
17260: ST_TO_ADDR
17261: LD_INT 6
17263: PUSH
17264: LD_VAR 0 6
17268: MINUS
17269: PUSH
17270: FOR_TO
17271: IFFALSE 17363
// begin if i = sort then
17273: LD_VAR 0 3
17277: PUSH
17278: LD_VAR 0 9
17282: EQUAL
17283: IFFALSE 17287
// break ;
17285: GO 17363
// if GetClass ( i ) = 2 then
17287: LD_VAR 0 3
17291: PPUSH
17292: CALL_OW 257
17296: PUSH
17297: LD_INT 2
17299: EQUAL
17300: IFFALSE 17304
// continue ;
17302: GO 17270
// p := Insert ( p , p + 1 , sort [ i ] ) ;
17304: LD_ADDR_VAR 0 11
17308: PUSH
17309: LD_VAR 0 11
17313: PPUSH
17314: LD_VAR 0 11
17318: PUSH
17319: LD_INT 1
17321: PLUS
17322: PPUSH
17323: LD_VAR 0 9
17327: PUSH
17328: LD_VAR 0 3
17332: ARRAY
17333: PPUSH
17334: CALL_OW 2
17338: ST_TO_ADDR
// tmp := tmp diff sort [ i ] ;
17339: LD_ADDR_VAR 0 4
17343: PUSH
17344: LD_VAR 0 4
17348: PUSH
17349: LD_VAR 0 9
17353: PUSH
17354: LD_VAR 0 3
17358: ARRAY
17359: DIFF
17360: ST_TO_ADDR
// end ;
17361: GO 17270
17363: POP
17364: POP
// if p then
17365: LD_VAR 0 11
17369: IFFALSE 17394
// result := Replace ( result , 2 , p ) ;
17371: LD_ADDR_VAR 0 2
17375: PUSH
17376: LD_VAR 0 2
17380: PPUSH
17381: LD_INT 2
17383: PPUSH
17384: LD_VAR 0 11
17388: PPUSH
17389: CALL_OW 1
17393: ST_TO_ADDR
// end ; exit ;
17394: GO 18782
// end ; if not mc_tech [ mc_sides [ base ] ] and UnitFilter ( mc_bases [ base ] , [ f_btype , b_factory ] ) and mc_build_list [ base ] then
17396: LD_EXP 83
17400: PUSH
17401: LD_EXP 82
17405: PUSH
17406: LD_VAR 0 1
17410: ARRAY
17411: ARRAY
17412: NOT
17413: PUSH
17414: LD_EXP 56
17418: PUSH
17419: LD_VAR 0 1
17423: ARRAY
17424: PPUSH
17425: LD_INT 30
17427: PUSH
17428: LD_INT 3
17430: PUSH
17431: EMPTY
17432: LIST
17433: LIST
17434: PPUSH
17435: CALL_OW 72
17439: AND
17440: PUSH
17441: LD_EXP 61
17445: PUSH
17446: LD_VAR 0 1
17450: ARRAY
17451: AND
17452: IFFALSE 18060
// begin mc_class_case_use := Replace ( mc_class_case_use , base , 5 ) ;
17454: LD_ADDR_EXP 98
17458: PUSH
17459: LD_EXP 98
17463: PPUSH
17464: LD_VAR 0 1
17468: PPUSH
17469: LD_INT 5
17471: PPUSH
17472: CALL_OW 1
17476: ST_TO_ADDR
// result := [ 0 , 0 , 0 , 0 ] ;
17477: LD_ADDR_VAR 0 2
17481: PUSH
17482: LD_INT 0
17484: PUSH
17485: LD_INT 0
17487: PUSH
17488: LD_INT 0
17490: PUSH
17491: LD_INT 0
17493: PUSH
17494: EMPTY
17495: LIST
17496: LIST
17497: LIST
17498: LIST
17499: ST_TO_ADDR
// if sci > 1 then
17500: LD_VAR 0 8
17504: PUSH
17505: LD_INT 1
17507: GREATER
17508: IFFALSE 17536
// tmp := tmp diff ( sci diff sci [ 1 ] ) ;
17510: LD_ADDR_VAR 0 4
17514: PUSH
17515: LD_VAR 0 4
17519: PUSH
17520: LD_VAR 0 8
17524: PUSH
17525: LD_VAR 0 8
17529: PUSH
17530: LD_INT 1
17532: ARRAY
17533: DIFF
17534: DIFF
17535: ST_TO_ADDR
// if tmp and not sci then
17536: LD_VAR 0 4
17540: PUSH
17541: LD_VAR 0 8
17545: NOT
17546: AND
17547: IFFALSE 17616
// begin sort := SortBySkill ( tmp , 4 ) ;
17549: LD_ADDR_VAR 0 9
17553: PUSH
17554: LD_VAR 0 4
17558: PPUSH
17559: LD_INT 4
17561: PPUSH
17562: CALL 81368 0 2
17566: ST_TO_ADDR
// if sort then
17567: LD_VAR 0 9
17571: IFFALSE 17587
// p := sort [ 1 ] ;
17573: LD_ADDR_VAR 0 11
17577: PUSH
17578: LD_VAR 0 9
17582: PUSH
17583: LD_INT 1
17585: ARRAY
17586: ST_TO_ADDR
// if p then
17587: LD_VAR 0 11
17591: IFFALSE 17616
// result := Replace ( result , 4 , p ) ;
17593: LD_ADDR_VAR 0 2
17597: PUSH
17598: LD_VAR 0 2
17602: PPUSH
17603: LD_INT 4
17605: PPUSH
17606: LD_VAR 0 11
17610: PPUSH
17611: CALL_OW 1
17615: ST_TO_ADDR
// end ; tmp := tmp diff mech ;
17616: LD_ADDR_VAR 0 4
17620: PUSH
17621: LD_VAR 0 4
17625: PUSH
17626: LD_VAR 0 7
17630: DIFF
17631: ST_TO_ADDR
// if tmp and mech < 6 then
17632: LD_VAR 0 4
17636: PUSH
17637: LD_VAR 0 7
17641: PUSH
17642: LD_INT 6
17644: LESS
17645: AND
17646: IFFALSE 17834
// begin sort := SortBySkill ( tmp diff ( sci union mech ) , 3 ) ;
17648: LD_ADDR_VAR 0 9
17652: PUSH
17653: LD_VAR 0 4
17657: PUSH
17658: LD_VAR 0 8
17662: PUSH
17663: LD_VAR 0 7
17667: UNION
17668: DIFF
17669: PPUSH
17670: LD_INT 3
17672: PPUSH
17673: CALL 81368 0 2
17677: ST_TO_ADDR
// p := [ ] ;
17678: LD_ADDR_VAR 0 11
17682: PUSH
17683: EMPTY
17684: ST_TO_ADDR
// if sort then
17685: LD_VAR 0 9
17689: IFFALSE 17805
// for i = 1 to 6 - mech do
17691: LD_ADDR_VAR 0 3
17695: PUSH
17696: DOUBLE
17697: LD_INT 1
17699: DEC
17700: ST_TO_ADDR
17701: LD_INT 6
17703: PUSH
17704: LD_VAR 0 7
17708: MINUS
17709: PUSH
17710: FOR_TO
17711: IFFALSE 17803
// begin if i = sort then
17713: LD_VAR 0 3
17717: PUSH
17718: LD_VAR 0 9
17722: EQUAL
17723: IFFALSE 17727
// break ;
17725: GO 17803
// if GetClass ( i ) = 3 then
17727: LD_VAR 0 3
17731: PPUSH
17732: CALL_OW 257
17736: PUSH
17737: LD_INT 3
17739: EQUAL
17740: IFFALSE 17744
// continue ;
17742: GO 17710
// p := Insert ( p , p + 1 , sort [ i ] ) ;
17744: LD_ADDR_VAR 0 11
17748: PUSH
17749: LD_VAR 0 11
17753: PPUSH
17754: LD_VAR 0 11
17758: PUSH
17759: LD_INT 1
17761: PLUS
17762: PPUSH
17763: LD_VAR 0 9
17767: PUSH
17768: LD_VAR 0 3
17772: ARRAY
17773: PPUSH
17774: CALL_OW 2
17778: ST_TO_ADDR
// tmp := tmp diff sort [ i ] ;
17779: LD_ADDR_VAR 0 4
17783: PUSH
17784: LD_VAR 0 4
17788: PUSH
17789: LD_VAR 0 9
17793: PUSH
17794: LD_VAR 0 3
17798: ARRAY
17799: DIFF
17800: ST_TO_ADDR
// end ;
17801: GO 17710
17803: POP
17804: POP
// if p then
17805: LD_VAR 0 11
17809: IFFALSE 17834
// result := Replace ( result , 3 , p ) ;
17811: LD_ADDR_VAR 0 2
17815: PUSH
17816: LD_VAR 0 2
17820: PPUSH
17821: LD_INT 3
17823: PPUSH
17824: LD_VAR 0 11
17828: PPUSH
17829: CALL_OW 1
17833: ST_TO_ADDR
// end ; tmp := tmp diff eng ;
17834: LD_ADDR_VAR 0 4
17838: PUSH
17839: LD_VAR 0 4
17843: PUSH
17844: LD_VAR 0 6
17848: DIFF
17849: ST_TO_ADDR
// if tmp and eng < 6 then
17850: LD_VAR 0 4
17854: PUSH
17855: LD_VAR 0 6
17859: PUSH
17860: LD_INT 6
17862: LESS
17863: AND
17864: IFFALSE 18058
// begin sort := SortBySkill ( tmp diff ( sci union mech union eng ) , 2 ) ;
17866: LD_ADDR_VAR 0 9
17870: PUSH
17871: LD_VAR 0 4
17875: PUSH
17876: LD_VAR 0 8
17880: PUSH
17881: LD_VAR 0 7
17885: UNION
17886: PUSH
17887: LD_VAR 0 6
17891: UNION
17892: DIFF
17893: PPUSH
17894: LD_INT 2
17896: PPUSH
17897: CALL 81368 0 2
17901: ST_TO_ADDR
// p := [ ] ;
17902: LD_ADDR_VAR 0 11
17906: PUSH
17907: EMPTY
17908: ST_TO_ADDR
// if sort then
17909: LD_VAR 0 9
17913: IFFALSE 18029
// for i = 1 to 6 - eng do
17915: LD_ADDR_VAR 0 3
17919: PUSH
17920: DOUBLE
17921: LD_INT 1
17923: DEC
17924: ST_TO_ADDR
17925: LD_INT 6
17927: PUSH
17928: LD_VAR 0 6
17932: MINUS
17933: PUSH
17934: FOR_TO
17935: IFFALSE 18027
// begin if i = sort then
17937: LD_VAR 0 3
17941: PUSH
17942: LD_VAR 0 9
17946: EQUAL
17947: IFFALSE 17951
// break ;
17949: GO 18027
// if GetClass ( i ) = 2 then
17951: LD_VAR 0 3
17955: PPUSH
17956: CALL_OW 257
17960: PUSH
17961: LD_INT 2
17963: EQUAL
17964: IFFALSE 17968
// continue ;
17966: GO 17934
// p := Insert ( p , p + 1 , sort [ i ] ) ;
17968: LD_ADDR_VAR 0 11
17972: PUSH
17973: LD_VAR 0 11
17977: PPUSH
17978: LD_VAR 0 11
17982: PUSH
17983: LD_INT 1
17985: PLUS
17986: PPUSH
17987: LD_VAR 0 9
17991: PUSH
17992: LD_VAR 0 3
17996: ARRAY
17997: PPUSH
17998: CALL_OW 2
18002: ST_TO_ADDR
// tmp := tmp diff sort [ i ] ;
18003: LD_ADDR_VAR 0 4
18007: PUSH
18008: LD_VAR 0 4
18012: PUSH
18013: LD_VAR 0 9
18017: PUSH
18018: LD_VAR 0 3
18022: ARRAY
18023: DIFF
18024: ST_TO_ADDR
// end ;
18025: GO 17934
18027: POP
18028: POP
// if p then
18029: LD_VAR 0 11
18033: IFFALSE 18058
// result := Replace ( result , 2 , p ) ;
18035: LD_ADDR_VAR 0 2
18039: PUSH
18040: LD_VAR 0 2
18044: PPUSH
18045: LD_INT 2
18047: PPUSH
18048: LD_VAR 0 11
18052: PPUSH
18053: CALL_OW 1
18057: ST_TO_ADDR
// end ; exit ;
18058: GO 18782
// end ; if not mc_tech [ mc_sides [ base ] ] and UnitFilter ( mc_bases [ base ] , [ f_btype , b_factory ] ) and not mc_build_list [ base ] then
18060: LD_EXP 83
18064: PUSH
18065: LD_EXP 82
18069: PUSH
18070: LD_VAR 0 1
18074: ARRAY
18075: ARRAY
18076: NOT
18077: PUSH
18078: LD_EXP 56
18082: PUSH
18083: LD_VAR 0 1
18087: ARRAY
18088: PPUSH
18089: LD_INT 30
18091: PUSH
18092: LD_INT 3
18094: PUSH
18095: EMPTY
18096: LIST
18097: LIST
18098: PPUSH
18099: CALL_OW 72
18103: AND
18104: PUSH
18105: LD_EXP 61
18109: PUSH
18110: LD_VAR 0 1
18114: ARRAY
18115: NOT
18116: AND
18117: IFFALSE 18782
// begin mc_class_case_use := Replace ( mc_class_case_use , base , 6 ) ;
18119: LD_ADDR_EXP 98
18123: PUSH
18124: LD_EXP 98
18128: PPUSH
18129: LD_VAR 0 1
18133: PPUSH
18134: LD_INT 6
18136: PPUSH
18137: CALL_OW 1
18141: ST_TO_ADDR
// result := [ 0 , 0 , 0 , 0 ] ;
18142: LD_ADDR_VAR 0 2
18146: PUSH
18147: LD_INT 0
18149: PUSH
18150: LD_INT 0
18152: PUSH
18153: LD_INT 0
18155: PUSH
18156: LD_INT 0
18158: PUSH
18159: EMPTY
18160: LIST
18161: LIST
18162: LIST
18163: LIST
18164: ST_TO_ADDR
// if sci >= 1 then
18165: LD_VAR 0 8
18169: PUSH
18170: LD_INT 1
18172: GREATEREQUAL
18173: IFFALSE 18195
// tmp := tmp diff sci [ 1 ] ;
18175: LD_ADDR_VAR 0 4
18179: PUSH
18180: LD_VAR 0 4
18184: PUSH
18185: LD_VAR 0 8
18189: PUSH
18190: LD_INT 1
18192: ARRAY
18193: DIFF
18194: ST_TO_ADDR
// if tmp and not sci then
18195: LD_VAR 0 4
18199: PUSH
18200: LD_VAR 0 8
18204: NOT
18205: AND
18206: IFFALSE 18275
// begin sort := SortBySkill ( tmp , 4 ) ;
18208: LD_ADDR_VAR 0 9
18212: PUSH
18213: LD_VAR 0 4
18217: PPUSH
18218: LD_INT 4
18220: PPUSH
18221: CALL 81368 0 2
18225: ST_TO_ADDR
// if sort then
18226: LD_VAR 0 9
18230: IFFALSE 18246
// p := sort [ 1 ] ;
18232: LD_ADDR_VAR 0 11
18236: PUSH
18237: LD_VAR 0 9
18241: PUSH
18242: LD_INT 1
18244: ARRAY
18245: ST_TO_ADDR
// if p then
18246: LD_VAR 0 11
18250: IFFALSE 18275
// result := Replace ( result , 4 , p ) ;
18252: LD_ADDR_VAR 0 2
18256: PUSH
18257: LD_VAR 0 2
18261: PPUSH
18262: LD_INT 4
18264: PPUSH
18265: LD_VAR 0 11
18269: PPUSH
18270: CALL_OW 1
18274: ST_TO_ADDR
// end ; tmp := tmp diff mech ;
18275: LD_ADDR_VAR 0 4
18279: PUSH
18280: LD_VAR 0 4
18284: PUSH
18285: LD_VAR 0 7
18289: DIFF
18290: ST_TO_ADDR
// if tmp and mech < 6 then
18291: LD_VAR 0 4
18295: PUSH
18296: LD_VAR 0 7
18300: PUSH
18301: LD_INT 6
18303: LESS
18304: AND
18305: IFFALSE 18487
// begin sort := SortBySkill ( tmp diff mech , 3 ) ;
18307: LD_ADDR_VAR 0 9
18311: PUSH
18312: LD_VAR 0 4
18316: PUSH
18317: LD_VAR 0 7
18321: DIFF
18322: PPUSH
18323: LD_INT 3
18325: PPUSH
18326: CALL 81368 0 2
18330: ST_TO_ADDR
// p := [ ] ;
18331: LD_ADDR_VAR 0 11
18335: PUSH
18336: EMPTY
18337: ST_TO_ADDR
// if sort then
18338: LD_VAR 0 9
18342: IFFALSE 18458
// for i = 1 to 6 - mech do
18344: LD_ADDR_VAR 0 3
18348: PUSH
18349: DOUBLE
18350: LD_INT 1
18352: DEC
18353: ST_TO_ADDR
18354: LD_INT 6
18356: PUSH
18357: LD_VAR 0 7
18361: MINUS
18362: PUSH
18363: FOR_TO
18364: IFFALSE 18456
// begin if i = sort then
18366: LD_VAR 0 3
18370: PUSH
18371: LD_VAR 0 9
18375: EQUAL
18376: IFFALSE 18380
// break ;
18378: GO 18456
// if GetClass ( i ) = 3 then
18380: LD_VAR 0 3
18384: PPUSH
18385: CALL_OW 257
18389: PUSH
18390: LD_INT 3
18392: EQUAL
18393: IFFALSE 18397
// continue ;
18395: GO 18363
// p := Insert ( p , p + 1 , sort [ i ] ) ;
18397: LD_ADDR_VAR 0 11
18401: PUSH
18402: LD_VAR 0 11
18406: PPUSH
18407: LD_VAR 0 11
18411: PUSH
18412: LD_INT 1
18414: PLUS
18415: PPUSH
18416: LD_VAR 0 9
18420: PUSH
18421: LD_VAR 0 3
18425: ARRAY
18426: PPUSH
18427: CALL_OW 2
18431: ST_TO_ADDR
// tmp := tmp diff sort [ i ] ;
18432: LD_ADDR_VAR 0 4
18436: PUSH
18437: LD_VAR 0 4
18441: PUSH
18442: LD_VAR 0 9
18446: PUSH
18447: LD_VAR 0 3
18451: ARRAY
18452: DIFF
18453: ST_TO_ADDR
// end ;
18454: GO 18363
18456: POP
18457: POP
// if p then
18458: LD_VAR 0 11
18462: IFFALSE 18487
// result := Replace ( result , 3 , p ) ;
18464: LD_ADDR_VAR 0 2
18468: PUSH
18469: LD_VAR 0 2
18473: PPUSH
18474: LD_INT 3
18476: PPUSH
18477: LD_VAR 0 11
18481: PPUSH
18482: CALL_OW 1
18486: ST_TO_ADDR
// end ; tmp := tmp diff eng ;
18487: LD_ADDR_VAR 0 4
18491: PUSH
18492: LD_VAR 0 4
18496: PUSH
18497: LD_VAR 0 6
18501: DIFF
18502: ST_TO_ADDR
// if tmp and eng < 4 then
18503: LD_VAR 0 4
18507: PUSH
18508: LD_VAR 0 6
18512: PUSH
18513: LD_INT 4
18515: LESS
18516: AND
18517: IFFALSE 18707
// begin sort := SortBySkill ( tmp diff ( mech union eng ) , 2 ) ;
18519: LD_ADDR_VAR 0 9
18523: PUSH
18524: LD_VAR 0 4
18528: PUSH
18529: LD_VAR 0 7
18533: PUSH
18534: LD_VAR 0 6
18538: UNION
18539: DIFF
18540: PPUSH
18541: LD_INT 2
18543: PPUSH
18544: CALL 81368 0 2
18548: ST_TO_ADDR
// p := [ ] ;
18549: LD_ADDR_VAR 0 11
18553: PUSH
18554: EMPTY
18555: ST_TO_ADDR
// if sort then
18556: LD_VAR 0 9
18560: IFFALSE 18676
// for i = 1 to 4 - eng do
18562: LD_ADDR_VAR 0 3
18566: PUSH
18567: DOUBLE
18568: LD_INT 1
18570: DEC
18571: ST_TO_ADDR
18572: LD_INT 4
18574: PUSH
18575: LD_VAR 0 6
18579: MINUS
18580: PUSH
18581: FOR_TO
18582: IFFALSE 18674
// begin if i = sort then
18584: LD_VAR 0 3
18588: PUSH
18589: LD_VAR 0 9
18593: EQUAL
18594: IFFALSE 18598
// break ;
18596: GO 18674
// if GetClass ( i ) = 2 then
18598: LD_VAR 0 3
18602: PPUSH
18603: CALL_OW 257
18607: PUSH
18608: LD_INT 2
18610: EQUAL
18611: IFFALSE 18615
// continue ;
18613: GO 18581
// p := Insert ( p , p + 1 , sort [ i ] ) ;
18615: LD_ADDR_VAR 0 11
18619: PUSH
18620: LD_VAR 0 11
18624: PPUSH
18625: LD_VAR 0 11
18629: PUSH
18630: LD_INT 1
18632: PLUS
18633: PPUSH
18634: LD_VAR 0 9
18638: PUSH
18639: LD_VAR 0 3
18643: ARRAY
18644: PPUSH
18645: CALL_OW 2
18649: ST_TO_ADDR
// tmp := tmp diff sort [ i ] ;
18650: LD_ADDR_VAR 0 4
18654: PUSH
18655: LD_VAR 0 4
18659: PUSH
18660: LD_VAR 0 9
18664: PUSH
18665: LD_VAR 0 3
18669: ARRAY
18670: DIFF
18671: ST_TO_ADDR
// end ;
18672: GO 18581
18674: POP
18675: POP
// if p then
18676: LD_VAR 0 11
18680: IFFALSE 18705
// result := Replace ( result , 2 , p ) ;
18682: LD_ADDR_VAR 0 2
18686: PUSH
18687: LD_VAR 0 2
18691: PPUSH
18692: LD_INT 2
18694: PPUSH
18695: LD_VAR 0 11
18699: PPUSH
18700: CALL_OW 1
18704: ST_TO_ADDR
// end else
18705: GO 18751
// for i = eng downto 5 do
18707: LD_ADDR_VAR 0 3
18711: PUSH
18712: DOUBLE
18713: LD_VAR 0 6
18717: INC
18718: ST_TO_ADDR
18719: LD_INT 5
18721: PUSH
18722: FOR_DOWNTO
18723: IFFALSE 18749
// tmp := tmp union eng [ i ] ;
18725: LD_ADDR_VAR 0 4
18729: PUSH
18730: LD_VAR 0 4
18734: PUSH
18735: LD_VAR 0 6
18739: PUSH
18740: LD_VAR 0 3
18744: ARRAY
18745: UNION
18746: ST_TO_ADDR
18747: GO 18722
18749: POP
18750: POP
// result := Replace ( result , 1 , tmp diff sol ) ;
18751: LD_ADDR_VAR 0 2
18755: PUSH
18756: LD_VAR 0 2
18760: PPUSH
18761: LD_INT 1
18763: PPUSH
18764: LD_VAR 0 4
18768: PUSH
18769: LD_VAR 0 5
18773: DIFF
18774: PPUSH
18775: CALL_OW 1
18779: ST_TO_ADDR
// exit ;
18780: GO 18782
// end ; end ;
18782: LD_VAR 0 2
18786: RET
// export function MC_CheckBuildings ( ) ; var i , tmp ; begin
18787: LD_INT 0
18789: PPUSH
18790: PPUSH
18791: PPUSH
// if not mc_bases then
18792: LD_EXP 56
18796: NOT
18797: IFFALSE 18801
// exit ;
18799: GO 18907
// for i = 1 to mc_bases do
18801: LD_ADDR_VAR 0 2
18805: PUSH
18806: DOUBLE
18807: LD_INT 1
18809: DEC
18810: ST_TO_ADDR
18811: LD_EXP 56
18815: PUSH
18816: FOR_TO
18817: IFFALSE 18898
// begin tmp := UnitFilter ( mc_bases [ i ] , [ [ f_type , unit_building ] , [ f_not , [ f_lives , 1000 ] ] ] ) ;
18819: LD_ADDR_VAR 0 3
18823: PUSH
18824: LD_EXP 56
18828: PUSH
18829: LD_VAR 0 2
18833: ARRAY
18834: PPUSH
18835: LD_INT 21
18837: PUSH
18838: LD_INT 3
18840: PUSH
18841: EMPTY
18842: LIST
18843: LIST
18844: PUSH
18845: LD_INT 3
18847: PUSH
18848: LD_INT 24
18850: PUSH
18851: LD_INT 1000
18853: PUSH
18854: EMPTY
18855: LIST
18856: LIST
18857: PUSH
18858: EMPTY
18859: LIST
18860: LIST
18861: PUSH
18862: EMPTY
18863: LIST
18864: LIST
18865: PPUSH
18866: CALL_OW 72
18870: ST_TO_ADDR
// mc_building_need_repair := Replace ( mc_building_need_repair , i , tmp ) ;
18871: LD_ADDR_EXP 57
18875: PUSH
18876: LD_EXP 57
18880: PPUSH
18881: LD_VAR 0 2
18885: PPUSH
18886: LD_VAR 0 3
18890: PPUSH
18891: CALL_OW 1
18895: ST_TO_ADDR
// end ;
18896: GO 18816
18898: POP
18899: POP
// RaiseSailEvent ( 101 ) ;
18900: LD_INT 101
18902: PPUSH
18903: CALL_OW 427
// end ;
18907: LD_VAR 0 1
18911: RET
// export function MC_CheckPeopleLife ( ) ; var i , j , k , tmp , need_heal_1 , need_heal_2 ; begin
18912: LD_INT 0
18914: PPUSH
18915: PPUSH
18916: PPUSH
18917: PPUSH
18918: PPUSH
18919: PPUSH
18920: PPUSH
// if not mc_bases then
18921: LD_EXP 56
18925: NOT
18926: IFFALSE 18930
// exit ;
18928: GO 19503
// for i = 1 to mc_bases do
18930: LD_ADDR_VAR 0 2
18934: PUSH
18935: DOUBLE
18936: LD_INT 1
18938: DEC
18939: ST_TO_ADDR
18940: LD_EXP 56
18944: PUSH
18945: FOR_TO
18946: IFFALSE 19494
// begin tmp := UnitFilter ( mc_bases [ i ] union mc_ape [ i ] , [ [ f_type , unit_human ] , [ f_and , [ f_not , [ f_inside ] ] , [ f_not , [ f_lives , 800 ] ] ] ] ) ;
18948: LD_ADDR_VAR 0 5
18952: PUSH
18953: LD_EXP 56
18957: PUSH
18958: LD_VAR 0 2
18962: ARRAY
18963: PUSH
18964: LD_EXP 85
18968: PUSH
18969: LD_VAR 0 2
18973: ARRAY
18974: UNION
18975: PPUSH
18976: LD_INT 21
18978: PUSH
18979: LD_INT 1
18981: PUSH
18982: EMPTY
18983: LIST
18984: LIST
18985: PUSH
18986: LD_INT 1
18988: PUSH
18989: LD_INT 3
18991: PUSH
18992: LD_INT 54
18994: PUSH
18995: EMPTY
18996: LIST
18997: PUSH
18998: EMPTY
18999: LIST
19000: LIST
19001: PUSH
19002: LD_INT 3
19004: PUSH
19005: LD_INT 24
19007: PUSH
19008: LD_INT 800
19010: PUSH
19011: EMPTY
19012: LIST
19013: LIST
19014: PUSH
19015: EMPTY
19016: LIST
19017: LIST
19018: PUSH
19019: EMPTY
19020: LIST
19021: LIST
19022: LIST
19023: PUSH
19024: EMPTY
19025: LIST
19026: LIST
19027: PPUSH
19028: CALL_OW 72
19032: ST_TO_ADDR
// need_heal_1 := UnitFilter ( mc_bases [ i ] , [ [ f_type , unit_human ] , [ f_and , [ f_not , [ f_inside ] ] , [ f_not , [ f_lives , 250 ] ] ] ] ) ;
19033: LD_ADDR_VAR 0 6
19037: PUSH
19038: LD_EXP 56
19042: PUSH
19043: LD_VAR 0 2
19047: ARRAY
19048: PPUSH
19049: LD_INT 21
19051: PUSH
19052: LD_INT 1
19054: PUSH
19055: EMPTY
19056: LIST
19057: LIST
19058: PUSH
19059: LD_INT 1
19061: PUSH
19062: LD_INT 3
19064: PUSH
19065: LD_INT 54
19067: PUSH
19068: EMPTY
19069: LIST
19070: PUSH
19071: EMPTY
19072: LIST
19073: LIST
19074: PUSH
19075: LD_INT 3
19077: PUSH
19078: LD_INT 24
19080: PUSH
19081: LD_INT 250
19083: PUSH
19084: EMPTY
19085: LIST
19086: LIST
19087: PUSH
19088: EMPTY
19089: LIST
19090: LIST
19091: PUSH
19092: EMPTY
19093: LIST
19094: LIST
19095: LIST
19096: PUSH
19097: EMPTY
19098: LIST
19099: LIST
19100: PPUSH
19101: CALL_OW 72
19105: ST_TO_ADDR
// need_heal_2 := tmp diff need_heal_1 ;
19106: LD_ADDR_VAR 0 7
19110: PUSH
19111: LD_VAR 0 5
19115: PUSH
19116: LD_VAR 0 6
19120: DIFF
19121: ST_TO_ADDR
// if not need_heal_1 then
19122: LD_VAR 0 6
19126: NOT
19127: IFFALSE 19160
// mc_need_heal := ReplaceIn ( mc_need_heal , [ i , 1 ] , [ ] ) else
19129: LD_ADDR_EXP 59
19133: PUSH
19134: LD_EXP 59
19138: PPUSH
19139: LD_VAR 0 2
19143: PUSH
19144: LD_INT 1
19146: PUSH
19147: EMPTY
19148: LIST
19149: LIST
19150: PPUSH
19151: EMPTY
19152: PPUSH
19153: CALL 47120 0 3
19157: ST_TO_ADDR
19158: GO 19230
// mc_need_heal := ReplaceIn ( mc_need_heal , [ i , 1 ] , UnitFilter ( mc_need_heal [ i ] [ 1 ] , [ f_not , [ f_lives , 1000 ] ] ) union need_heal_1 ) ;
19160: LD_ADDR_EXP 59
19164: PUSH
19165: LD_EXP 59
19169: PPUSH
19170: LD_VAR 0 2
19174: PUSH
19175: LD_INT 1
19177: PUSH
19178: EMPTY
19179: LIST
19180: LIST
19181: PPUSH
19182: LD_EXP 59
19186: PUSH
19187: LD_VAR 0 2
19191: ARRAY
19192: PUSH
19193: LD_INT 1
19195: ARRAY
19196: PPUSH
19197: LD_INT 3
19199: PUSH
19200: LD_INT 24
19202: PUSH
19203: LD_INT 1000
19205: PUSH
19206: EMPTY
19207: LIST
19208: LIST
19209: PUSH
19210: EMPTY
19211: LIST
19212: LIST
19213: PPUSH
19214: CALL_OW 72
19218: PUSH
19219: LD_VAR 0 6
19223: UNION
19224: PPUSH
19225: CALL 47120 0 3
19229: ST_TO_ADDR
// if not need_heal_2 then
19230: LD_VAR 0 7
19234: NOT
19235: IFFALSE 19268
// mc_need_heal := ReplaceIn ( mc_need_heal , [ i , 2 ] , [ ] ) else
19237: LD_ADDR_EXP 59
19241: PUSH
19242: LD_EXP 59
19246: PPUSH
19247: LD_VAR 0 2
19251: PUSH
19252: LD_INT 2
19254: PUSH
19255: EMPTY
19256: LIST
19257: LIST
19258: PPUSH
19259: EMPTY
19260: PPUSH
19261: CALL 47120 0 3
19265: ST_TO_ADDR
19266: GO 19300
// mc_need_heal := ReplaceIn ( mc_need_heal , [ i , 2 ] , need_heal_2 ) ;
19268: LD_ADDR_EXP 59
19272: PUSH
19273: LD_EXP 59
19277: PPUSH
19278: LD_VAR 0 2
19282: PUSH
19283: LD_INT 2
19285: PUSH
19286: EMPTY
19287: LIST
19288: LIST
19289: PPUSH
19290: LD_VAR 0 7
19294: PPUSH
19295: CALL 47120 0 3
19299: ST_TO_ADDR
// if need_heal_2 then
19300: LD_VAR 0 7
19304: IFFALSE 19476
// for j in need_heal_2 do
19306: LD_ADDR_VAR 0 3
19310: PUSH
19311: LD_VAR 0 7
19315: PUSH
19316: FOR_IN
19317: IFFALSE 19474
// begin tmp := UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_lab ] , [ f_btype , b_lab_half ] , [ f_btype , b_lab_full ] , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] , [ f_class , 4 ] ] ) ;
19319: LD_ADDR_VAR 0 5
19323: PUSH
19324: LD_EXP 56
19328: PUSH
19329: LD_VAR 0 2
19333: ARRAY
19334: PPUSH
19335: LD_INT 2
19337: PUSH
19338: LD_INT 30
19340: PUSH
19341: LD_INT 6
19343: PUSH
19344: EMPTY
19345: LIST
19346: LIST
19347: PUSH
19348: LD_INT 30
19350: PUSH
19351: LD_INT 7
19353: PUSH
19354: EMPTY
19355: LIST
19356: LIST
19357: PUSH
19358: LD_INT 30
19360: PUSH
19361: LD_INT 8
19363: PUSH
19364: EMPTY
19365: LIST
19366: LIST
19367: PUSH
19368: LD_INT 30
19370: PUSH
19371: LD_INT 0
19373: PUSH
19374: EMPTY
19375: LIST
19376: LIST
19377: PUSH
19378: LD_INT 30
19380: PUSH
19381: LD_INT 1
19383: PUSH
19384: EMPTY
19385: LIST
19386: LIST
19387: PUSH
19388: LD_INT 25
19390: PUSH
19391: LD_INT 4
19393: PUSH
19394: EMPTY
19395: LIST
19396: LIST
19397: PUSH
19398: EMPTY
19399: LIST
19400: LIST
19401: LIST
19402: LIST
19403: LIST
19404: LIST
19405: LIST
19406: PPUSH
19407: CALL_OW 72
19411: ST_TO_ADDR
// if tmp then
19412: LD_VAR 0 5
19416: IFFALSE 19472
// begin k := NearestUnitToUnit ( tmp , j ) ;
19418: LD_ADDR_VAR 0 4
19422: PUSH
19423: LD_VAR 0 5
19427: PPUSH
19428: LD_VAR 0 3
19432: PPUSH
19433: CALL_OW 74
19437: ST_TO_ADDR
// if GetDistUnits ( j , k ) > 7 then
19438: LD_VAR 0 3
19442: PPUSH
19443: LD_VAR 0 4
19447: PPUSH
19448: CALL_OW 296
19452: PUSH
19453: LD_INT 7
19455: GREATER
19456: IFFALSE 19472
// ComMoveUnit ( j , k ) ;
19458: LD_VAR 0 3
19462: PPUSH
19463: LD_VAR 0 4
19467: PPUSH
19468: CALL_OW 112
// end ; end ;
19472: GO 19316
19474: POP
19475: POP
// if not need_heal_1 and not need_heal_2 then
19476: LD_VAR 0 6
19480: NOT
19481: PUSH
19482: LD_VAR 0 7
19486: NOT
19487: AND
19488: IFFALSE 19492
// continue ;
19490: GO 18945
// end ;
19492: GO 18945
19494: POP
19495: POP
// RaiseSailEvent ( 102 ) ;
19496: LD_INT 102
19498: PPUSH
19499: CALL_OW 427
// end ;
19503: LD_VAR 0 1
19507: RET
// export function MC_RepairBuildings ( ) ; var i , j , un , tmp , cranes ; begin
19508: LD_INT 0
19510: PPUSH
19511: PPUSH
19512: PPUSH
19513: PPUSH
19514: PPUSH
19515: PPUSH
// if not mc_bases then
19516: LD_EXP 56
19520: NOT
19521: IFFALSE 19525
// exit ;
19523: GO 20235
// for i = 1 to mc_bases do
19525: LD_ADDR_VAR 0 2
19529: PUSH
19530: DOUBLE
19531: LD_INT 1
19533: DEC
19534: ST_TO_ADDR
19535: LD_EXP 56
19539: PUSH
19540: FOR_TO
19541: IFFALSE 20233
// begin if not mc_building_need_repair [ i ] then
19543: LD_EXP 57
19547: PUSH
19548: LD_VAR 0 2
19552: ARRAY
19553: NOT
19554: IFFALSE 19728
// begin cranes := UnitFilter ( mc_vehicles [ i ] , [ [ f_not , [ f_lives , 1000 ] ] , [ f_or , [ f_weapon , us_crane ] , [ f_weapon , ru_crane ] ] ] ) ;
19556: LD_ADDR_VAR 0 6
19560: PUSH
19561: LD_EXP 75
19565: PUSH
19566: LD_VAR 0 2
19570: ARRAY
19571: PPUSH
19572: LD_INT 3
19574: PUSH
19575: LD_INT 24
19577: PUSH
19578: LD_INT 1000
19580: PUSH
19581: EMPTY
19582: LIST
19583: LIST
19584: PUSH
19585: EMPTY
19586: LIST
19587: LIST
19588: PUSH
19589: LD_INT 2
19591: PUSH
19592: LD_INT 34
19594: PUSH
19595: LD_INT 13
19597: PUSH
19598: EMPTY
19599: LIST
19600: LIST
19601: PUSH
19602: LD_INT 34
19604: PUSH
19605: LD_INT 52
19607: PUSH
19608: EMPTY
19609: LIST
19610: LIST
19611: PUSH
19612: EMPTY
19613: LIST
19614: LIST
19615: LIST
19616: PUSH
19617: EMPTY
19618: LIST
19619: LIST
19620: PPUSH
19621: CALL_OW 72
19625: ST_TO_ADDR
// if cranes then
19626: LD_VAR 0 6
19630: IFFALSE 19692
// for j in cranes do
19632: LD_ADDR_VAR 0 3
19636: PUSH
19637: LD_VAR 0 6
19641: PUSH
19642: FOR_IN
19643: IFFALSE 19690
// if not IsInArea ( j , mc_parking [ i ] ) then
19645: LD_VAR 0 3
19649: PPUSH
19650: LD_EXP 80
19654: PUSH
19655: LD_VAR 0 2
19659: ARRAY
19660: PPUSH
19661: CALL_OW 308
19665: NOT
19666: IFFALSE 19688
// ComMoveToArea ( j , mc_parking [ i ] ) ;
19668: LD_VAR 0 3
19672: PPUSH
19673: LD_EXP 80
19677: PUSH
19678: LD_VAR 0 2
19682: ARRAY
19683: PPUSH
19684: CALL_OW 113
19688: GO 19642
19690: POP
19691: POP
// mc_building_repairs := Replace ( mc_building_repairs , i , [ ] ) ;
19692: LD_ADDR_EXP 58
19696: PUSH
19697: LD_EXP 58
19701: PPUSH
19702: LD_VAR 0 2
19706: PPUSH
19707: EMPTY
19708: PPUSH
19709: CALL_OW 1
19713: ST_TO_ADDR
// MC_Reset ( i , 101 ) ;
19714: LD_VAR 0 2
19718: PPUSH
19719: LD_INT 101
19721: PPUSH
19722: CALL 14620 0 2
// continue ;
19726: GO 19540
// end ; mc_builders := Replace ( mc_builders , i , [ ] ) ;
19728: LD_ADDR_EXP 62
19732: PUSH
19733: LD_EXP 62
19737: PPUSH
19738: LD_VAR 0 2
19742: PPUSH
19743: EMPTY
19744: PPUSH
19745: CALL_OW 1
19749: ST_TO_ADDR
// MC_Reset ( i , 103 ) ;
19750: LD_VAR 0 2
19754: PPUSH
19755: LD_INT 103
19757: PPUSH
19758: CALL 14620 0 2
// tmp := UnitFilter ( mc_bases [ i ] union mc_ape [ i ] , [ [ f_or , [ f_class , 2 ] , [ f_class , 16 ] ] ] ) ;
19762: LD_ADDR_VAR 0 5
19766: PUSH
19767: LD_EXP 56
19771: PUSH
19772: LD_VAR 0 2
19776: ARRAY
19777: PUSH
19778: LD_EXP 85
19782: PUSH
19783: LD_VAR 0 2
19787: ARRAY
19788: UNION
19789: PPUSH
19790: LD_INT 2
19792: PUSH
19793: LD_INT 25
19795: PUSH
19796: LD_INT 2
19798: PUSH
19799: EMPTY
19800: LIST
19801: LIST
19802: PUSH
19803: LD_INT 25
19805: PUSH
19806: LD_INT 16
19808: PUSH
19809: EMPTY
19810: LIST
19811: LIST
19812: PUSH
19813: EMPTY
19814: LIST
19815: LIST
19816: LIST
19817: PUSH
19818: EMPTY
19819: LIST
19820: PPUSH
19821: CALL_OW 72
19825: ST_TO_ADDR
// cranes := UnitFilter ( mc_vehicles [ i ] , [ f_or , [ f_weapon , us_crane ] , [ f_weapon , ru_crane ] ] ) ;
19826: LD_ADDR_VAR 0 6
19830: PUSH
19831: LD_EXP 75
19835: PUSH
19836: LD_VAR 0 2
19840: ARRAY
19841: PPUSH
19842: LD_INT 2
19844: PUSH
19845: LD_INT 34
19847: PUSH
19848: LD_INT 13
19850: PUSH
19851: EMPTY
19852: LIST
19853: LIST
19854: PUSH
19855: LD_INT 34
19857: PUSH
19858: LD_INT 52
19860: PUSH
19861: EMPTY
19862: LIST
19863: LIST
19864: PUSH
19865: EMPTY
19866: LIST
19867: LIST
19868: LIST
19869: PPUSH
19870: CALL_OW 72
19874: ST_TO_ADDR
// if cranes then
19875: LD_VAR 0 6
19879: IFFALSE 20015
// begin for j in cranes do
19881: LD_ADDR_VAR 0 3
19885: PUSH
19886: LD_VAR 0 6
19890: PUSH
19891: FOR_IN
19892: IFFALSE 20013
// if GetLives ( j ) >= 500 and not HasTask ( j ) then
19894: LD_VAR 0 3
19898: PPUSH
19899: CALL_OW 256
19903: PUSH
19904: LD_INT 500
19906: GREATEREQUAL
19907: PUSH
19908: LD_VAR 0 3
19912: PPUSH
19913: CALL_OW 314
19917: NOT
19918: AND
19919: IFFALSE 19953
// ComRepairBuilding ( j , NearestUnitToUnit ( mc_building_need_repair [ i ] , j ) ) else
19921: LD_VAR 0 3
19925: PPUSH
19926: LD_EXP 57
19930: PUSH
19931: LD_VAR 0 2
19935: ARRAY
19936: PPUSH
19937: LD_VAR 0 3
19941: PPUSH
19942: CALL_OW 74
19946: PPUSH
19947: CALL_OW 130
19951: GO 20011
// if GetLives ( j ) < 500 and not IsInArea ( j , mc_parking [ i ] ) then
19953: LD_VAR 0 3
19957: PPUSH
19958: CALL_OW 256
19962: PUSH
19963: LD_INT 500
19965: LESS
19966: PUSH
19967: LD_VAR 0 3
19971: PPUSH
19972: LD_EXP 80
19976: PUSH
19977: LD_VAR 0 2
19981: ARRAY
19982: PPUSH
19983: CALL_OW 308
19987: NOT
19988: AND
19989: IFFALSE 20011
// ComMoveToArea ( j , mc_parking [ i ] ) ;
19991: LD_VAR 0 3
19995: PPUSH
19996: LD_EXP 80
20000: PUSH
20001: LD_VAR 0 2
20005: ARRAY
20006: PPUSH
20007: CALL_OW 113
20011: GO 19891
20013: POP
20014: POP
// end ; if not tmp then
20015: LD_VAR 0 5
20019: NOT
20020: IFFALSE 20024
// continue ;
20022: GO 19540
// for j in tmp do
20024: LD_ADDR_VAR 0 3
20028: PUSH
20029: LD_VAR 0 5
20033: PUSH
20034: FOR_IN
20035: IFFALSE 20229
// begin if mc_need_heal [ i ] then
20037: LD_EXP 59
20041: PUSH
20042: LD_VAR 0 2
20046: ARRAY
20047: IFFALSE 20095
// if j in mc_need_heal [ i ] [ 1 ] or j in mc_need_heal [ i ] [ 2 ] then
20049: LD_VAR 0 3
20053: PUSH
20054: LD_EXP 59
20058: PUSH
20059: LD_VAR 0 2
20063: ARRAY
20064: PUSH
20065: LD_INT 1
20067: ARRAY
20068: IN
20069: PUSH
20070: LD_VAR 0 3
20074: PUSH
20075: LD_EXP 59
20079: PUSH
20080: LD_VAR 0 2
20084: ARRAY
20085: PUSH
20086: LD_INT 2
20088: ARRAY
20089: IN
20090: OR
20091: IFFALSE 20095
// continue ;
20093: GO 20034
// if IsInUnit ( j ) then
20095: LD_VAR 0 3
20099: PPUSH
20100: CALL_OW 310
20104: IFFALSE 20115
// ComExitBuilding ( j ) ;
20106: LD_VAR 0 3
20110: PPUSH
20111: CALL_OW 122
// if not j in mc_building_repairs [ i ] then
20115: LD_VAR 0 3
20119: PUSH
20120: LD_EXP 58
20124: PUSH
20125: LD_VAR 0 2
20129: ARRAY
20130: IN
20131: NOT
20132: IFFALSE 20190
// begin SetTag ( j , 101 ) ;
20134: LD_VAR 0 3
20138: PPUSH
20139: LD_INT 101
20141: PPUSH
20142: CALL_OW 109
// mc_building_repairs := ReplaceIn ( mc_building_repairs , [ i , mc_building_repairs [ i ] + 1 ] , j ) ;
20146: LD_ADDR_EXP 58
20150: PUSH
20151: LD_EXP 58
20155: PPUSH
20156: LD_VAR 0 2
20160: PUSH
20161: LD_EXP 58
20165: PUSH
20166: LD_VAR 0 2
20170: ARRAY
20171: PUSH
20172: LD_INT 1
20174: PLUS
20175: PUSH
20176: EMPTY
20177: LIST
20178: LIST
20179: PPUSH
20180: LD_VAR 0 3
20184: PPUSH
20185: CALL 47120 0 3
20189: ST_TO_ADDR
// end ; wait ( 1 ) ;
20190: LD_INT 1
20192: PPUSH
20193: CALL_OW 67
// ComRepairBuilding ( j , NearestUnitToUnit ( mc_building_need_repair [ i ] , j ) ) ;
20197: LD_VAR 0 3
20201: PPUSH
20202: LD_EXP 57
20206: PUSH
20207: LD_VAR 0 2
20211: ARRAY
20212: PPUSH
20213: LD_VAR 0 3
20217: PPUSH
20218: CALL_OW 74
20222: PPUSH
20223: CALL_OW 130
// end ;
20227: GO 20034
20229: POP
20230: POP
// end ;
20231: GO 19540
20233: POP
20234: POP
// end ;
20235: LD_VAR 0 1
20239: RET
// export function MC_Heal ; var i , j , tmp ; begin
20240: LD_INT 0
20242: PPUSH
20243: PPUSH
20244: PPUSH
20245: PPUSH
// if not mc_bases then
20246: LD_EXP 56
20250: NOT
20251: IFFALSE 20255
// exit ;
20253: GO 20657
// for i = 1 to mc_bases do
20255: LD_ADDR_VAR 0 2
20259: PUSH
20260: DOUBLE
20261: LD_INT 1
20263: DEC
20264: ST_TO_ADDR
20265: LD_EXP 56
20269: PUSH
20270: FOR_TO
20271: IFFALSE 20655
// begin if not mc_need_heal [ i ] [ 1 ] and not mc_need_heal [ i ] [ 2 ] then
20273: LD_EXP 59
20277: PUSH
20278: LD_VAR 0 2
20282: ARRAY
20283: PUSH
20284: LD_INT 1
20286: ARRAY
20287: NOT
20288: PUSH
20289: LD_EXP 59
20293: PUSH
20294: LD_VAR 0 2
20298: ARRAY
20299: PUSH
20300: LD_INT 2
20302: ARRAY
20303: NOT
20304: AND
20305: IFFALSE 20343
// begin mc_healers := Replace ( mc_healers , i , [ ] ) ;
20307: LD_ADDR_EXP 60
20311: PUSH
20312: LD_EXP 60
20316: PPUSH
20317: LD_VAR 0 2
20321: PPUSH
20322: EMPTY
20323: PPUSH
20324: CALL_OW 1
20328: ST_TO_ADDR
// MC_Reset ( i , 102 ) ;
20329: LD_VAR 0 2
20333: PPUSH
20334: LD_INT 102
20336: PPUSH
20337: CALL 14620 0 2
// continue ;
20341: GO 20270
// end ; tmp := UnitFilter ( mc_bases [ i ] , [ f_class , 4 ] ) ;
20343: LD_ADDR_VAR 0 4
20347: PUSH
20348: LD_EXP 56
20352: PUSH
20353: LD_VAR 0 2
20357: ARRAY
20358: PPUSH
20359: LD_INT 25
20361: PUSH
20362: LD_INT 4
20364: PUSH
20365: EMPTY
20366: LIST
20367: LIST
20368: PPUSH
20369: CALL_OW 72
20373: ST_TO_ADDR
// if not tmp then
20374: LD_VAR 0 4
20378: NOT
20379: IFFALSE 20383
// continue ;
20381: GO 20270
// if mc_taming [ i ] then
20383: LD_EXP 87
20387: PUSH
20388: LD_VAR 0 2
20392: ARRAY
20393: IFFALSE 20417
// mc_taming := Replace ( mc_taming , i , [ ] ) ;
20395: LD_ADDR_EXP 87
20399: PUSH
20400: LD_EXP 87
20404: PPUSH
20405: LD_VAR 0 2
20409: PPUSH
20410: EMPTY
20411: PPUSH
20412: CALL_OW 1
20416: ST_TO_ADDR
// for j in tmp do
20417: LD_ADDR_VAR 0 3
20421: PUSH
20422: LD_VAR 0 4
20426: PUSH
20427: FOR_IN
20428: IFFALSE 20651
// begin if IsInUnit ( j ) then
20430: LD_VAR 0 3
20434: PPUSH
20435: CALL_OW 310
20439: IFFALSE 20450
// ComExitBuilding ( j ) ;
20441: LD_VAR 0 3
20445: PPUSH
20446: CALL_OW 122
// if not j in mc_healers [ i ] then
20450: LD_VAR 0 3
20454: PUSH
20455: LD_EXP 60
20459: PUSH
20460: LD_VAR 0 2
20464: ARRAY
20465: IN
20466: NOT
20467: IFFALSE 20513
// mc_healers := ReplaceIn ( mc_healers , [ i , mc_healers [ i ] + 1 ] , j ) ;
20469: LD_ADDR_EXP 60
20473: PUSH
20474: LD_EXP 60
20478: PPUSH
20479: LD_VAR 0 2
20483: PUSH
20484: LD_EXP 60
20488: PUSH
20489: LD_VAR 0 2
20493: ARRAY
20494: PUSH
20495: LD_INT 1
20497: PLUS
20498: PUSH
20499: EMPTY
20500: LIST
20501: LIST
20502: PPUSH
20503: LD_VAR 0 3
20507: PPUSH
20508: CALL 47120 0 3
20512: ST_TO_ADDR
// if GetTag ( j ) <> 102 then
20513: LD_VAR 0 3
20517: PPUSH
20518: CALL_OW 110
20522: PUSH
20523: LD_INT 102
20525: NONEQUAL
20526: IFFALSE 20540
// SetTag ( j , 102 ) ;
20528: LD_VAR 0 3
20532: PPUSH
20533: LD_INT 102
20535: PPUSH
20536: CALL_OW 109
// Wait ( 3 ) ;
20540: LD_INT 3
20542: PPUSH
20543: CALL_OW 67
// if mc_need_heal [ i ] [ 1 ] then
20547: LD_EXP 59
20551: PUSH
20552: LD_VAR 0 2
20556: ARRAY
20557: PUSH
20558: LD_INT 1
20560: ARRAY
20561: IFFALSE 20593
// ComHeal ( j , mc_need_heal [ i ] [ 1 ] [ 1 ] ) else
20563: LD_VAR 0 3
20567: PPUSH
20568: LD_EXP 59
20572: PUSH
20573: LD_VAR 0 2
20577: ARRAY
20578: PUSH
20579: LD_INT 1
20581: ARRAY
20582: PUSH
20583: LD_INT 1
20585: ARRAY
20586: PPUSH
20587: CALL_OW 128
20591: GO 20649
// if not HasTask ( j ) and mc_need_heal [ i ] [ 2 ] then
20593: LD_VAR 0 3
20597: PPUSH
20598: CALL_OW 314
20602: NOT
20603: PUSH
20604: LD_EXP 59
20608: PUSH
20609: LD_VAR 0 2
20613: ARRAY
20614: PUSH
20615: LD_INT 2
20617: ARRAY
20618: AND
20619: IFFALSE 20649
// ComHeal ( j , mc_need_heal [ i ] [ 2 ] [ 1 ] ) ;
20621: LD_VAR 0 3
20625: PPUSH
20626: LD_EXP 59
20630: PUSH
20631: LD_VAR 0 2
20635: ARRAY
20636: PUSH
20637: LD_INT 2
20639: ARRAY
20640: PUSH
20641: LD_INT 1
20643: ARRAY
20644: PPUSH
20645: CALL_OW 128
// end ;
20649: GO 20427
20651: POP
20652: POP
// end ;
20653: GO 20270
20655: POP
20656: POP
// end ;
20657: LD_VAR 0 1
20661: RET
// export function MC_Build ( ) ; var i , j , tmp , depot ; begin
20662: LD_INT 0
20664: PPUSH
20665: PPUSH
20666: PPUSH
20667: PPUSH
20668: PPUSH
// if not mc_bases then
20669: LD_EXP 56
20673: NOT
20674: IFFALSE 20678
// exit ;
20676: GO 21821
// for i = 1 to mc_bases do
20678: LD_ADDR_VAR 0 2
20682: PUSH
20683: DOUBLE
20684: LD_INT 1
20686: DEC
20687: ST_TO_ADDR
20688: LD_EXP 56
20692: PUSH
20693: FOR_TO
20694: IFFALSE 21819
// begin if mc_scan [ i ] then
20696: LD_EXP 79
20700: PUSH
20701: LD_VAR 0 2
20705: ARRAY
20706: IFFALSE 20710
// continue ;
20708: GO 20693
// if not mc_build_list [ i ] and not mc_construct_list [ i ] and mc_builders [ i ] then
20710: LD_EXP 61
20714: PUSH
20715: LD_VAR 0 2
20719: ARRAY
20720: NOT
20721: PUSH
20722: LD_EXP 63
20726: PUSH
20727: LD_VAR 0 2
20731: ARRAY
20732: NOT
20733: AND
20734: PUSH
20735: LD_EXP 62
20739: PUSH
20740: LD_VAR 0 2
20744: ARRAY
20745: AND
20746: IFFALSE 20784
// begin mc_builders := Replace ( mc_builders , i , [ ] ) ;
20748: LD_ADDR_EXP 62
20752: PUSH
20753: LD_EXP 62
20757: PPUSH
20758: LD_VAR 0 2
20762: PPUSH
20763: EMPTY
20764: PPUSH
20765: CALL_OW 1
20769: ST_TO_ADDR
// MC_Reset ( i , 103 ) ;
20770: LD_VAR 0 2
20774: PPUSH
20775: LD_INT 103
20777: PPUSH
20778: CALL 14620 0 2
// continue ;
20782: GO 20693
// end ; if mc_construct_list [ i ] then
20784: LD_EXP 63
20788: PUSH
20789: LD_VAR 0 2
20793: ARRAY
20794: IFFALSE 21014
// begin tmp := UnitFilter ( mc_bases [ i ] , [ f_class , 2 ] ) diff mc_building_repairs [ i ] ;
20796: LD_ADDR_VAR 0 4
20800: PUSH
20801: LD_EXP 56
20805: PUSH
20806: LD_VAR 0 2
20810: ARRAY
20811: PPUSH
20812: LD_INT 25
20814: PUSH
20815: LD_INT 2
20817: PUSH
20818: EMPTY
20819: LIST
20820: LIST
20821: PPUSH
20822: CALL_OW 72
20826: PUSH
20827: LD_EXP 58
20831: PUSH
20832: LD_VAR 0 2
20836: ARRAY
20837: DIFF
20838: ST_TO_ADDR
// if not tmp then
20839: LD_VAR 0 4
20843: NOT
20844: IFFALSE 20848
// continue ;
20846: GO 20693
// for j in tmp do
20848: LD_ADDR_VAR 0 3
20852: PUSH
20853: LD_VAR 0 4
20857: PUSH
20858: FOR_IN
20859: IFFALSE 21010
// begin if not mc_builders [ i ] then
20861: LD_EXP 62
20865: PUSH
20866: LD_VAR 0 2
20870: ARRAY
20871: NOT
20872: IFFALSE 20930
// begin SetTag ( j , 103 ) ;
20874: LD_VAR 0 3
20878: PPUSH
20879: LD_INT 103
20881: PPUSH
20882: CALL_OW 109
// mc_builders := ReplaceIn ( mc_builders , [ i , mc_builders [ i ] + 1 ] , j ) ;
20886: LD_ADDR_EXP 62
20890: PUSH
20891: LD_EXP 62
20895: PPUSH
20896: LD_VAR 0 2
20900: PUSH
20901: LD_EXP 62
20905: PUSH
20906: LD_VAR 0 2
20910: ARRAY
20911: PUSH
20912: LD_INT 1
20914: PLUS
20915: PUSH
20916: EMPTY
20917: LIST
20918: LIST
20919: PPUSH
20920: LD_VAR 0 3
20924: PPUSH
20925: CALL 47120 0 3
20929: ST_TO_ADDR
// end ; if IsInUnit ( j ) then
20930: LD_VAR 0 3
20934: PPUSH
20935: CALL_OW 310
20939: IFFALSE 20950
// ComExitBuilding ( j ) ;
20941: LD_VAR 0 3
20945: PPUSH
20946: CALL_OW 122
// wait ( 3 ) ;
20950: LD_INT 3
20952: PPUSH
20953: CALL_OW 67
// if not mc_construct_list [ i ] then
20957: LD_EXP 63
20961: PUSH
20962: LD_VAR 0 2
20966: ARRAY
20967: NOT
20968: IFFALSE 20972
// break ;
20970: GO 21010
// if not HasTask ( j ) then
20972: LD_VAR 0 3
20976: PPUSH
20977: CALL_OW 314
20981: NOT
20982: IFFALSE 21008
// ComComplete ( j , mc_construct_list [ i ] [ 1 ] ) ;
20984: LD_VAR 0 3
20988: PPUSH
20989: LD_EXP 63
20993: PUSH
20994: LD_VAR 0 2
20998: ARRAY
20999: PUSH
21000: LD_INT 1
21002: ARRAY
21003: PPUSH
21004: CALL 49971 0 2
// end ;
21008: GO 20858
21010: POP
21011: POP
// end else
21012: GO 21817
// if mc_build_list [ i ] then
21014: LD_EXP 61
21018: PUSH
21019: LD_VAR 0 2
21023: ARRAY
21024: IFFALSE 21817
// begin depot := UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) ;
21026: LD_ADDR_VAR 0 5
21030: PUSH
21031: LD_EXP 56
21035: PUSH
21036: LD_VAR 0 2
21040: ARRAY
21041: PPUSH
21042: LD_INT 2
21044: PUSH
21045: LD_INT 30
21047: PUSH
21048: LD_INT 0
21050: PUSH
21051: EMPTY
21052: LIST
21053: LIST
21054: PUSH
21055: LD_INT 30
21057: PUSH
21058: LD_INT 1
21060: PUSH
21061: EMPTY
21062: LIST
21063: LIST
21064: PUSH
21065: EMPTY
21066: LIST
21067: LIST
21068: LIST
21069: PPUSH
21070: CALL_OW 72
21074: ST_TO_ADDR
// if depot then
21075: LD_VAR 0 5
21079: IFFALSE 21097
// depot := depot [ 1 ] else
21081: LD_ADDR_VAR 0 5
21085: PUSH
21086: LD_VAR 0 5
21090: PUSH
21091: LD_INT 1
21093: ARRAY
21094: ST_TO_ADDR
21095: GO 21105
// depot := 0 ;
21097: LD_ADDR_VAR 0 5
21101: PUSH
21102: LD_INT 0
21104: ST_TO_ADDR
// if IsExtension ( mc_build_list [ i ] [ 1 ] [ 1 ] ) and not UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_workshop ] , [ f_btype , b_factory ] ] ) then
21105: LD_EXP 61
21109: PUSH
21110: LD_VAR 0 2
21114: ARRAY
21115: PUSH
21116: LD_INT 1
21118: ARRAY
21119: PUSH
21120: LD_INT 1
21122: ARRAY
21123: PPUSH
21124: CALL 49801 0 1
21128: PUSH
21129: LD_EXP 56
21133: PUSH
21134: LD_VAR 0 2
21138: ARRAY
21139: PPUSH
21140: LD_INT 2
21142: PUSH
21143: LD_INT 30
21145: PUSH
21146: LD_INT 2
21148: PUSH
21149: EMPTY
21150: LIST
21151: LIST
21152: PUSH
21153: LD_INT 30
21155: PUSH
21156: LD_INT 3
21158: PUSH
21159: EMPTY
21160: LIST
21161: LIST
21162: PUSH
21163: EMPTY
21164: LIST
21165: LIST
21166: LIST
21167: PPUSH
21168: CALL_OW 72
21172: NOT
21173: AND
21174: IFFALSE 21279
// begin for j = 1 to mc_build_list [ i ] do
21176: LD_ADDR_VAR 0 3
21180: PUSH
21181: DOUBLE
21182: LD_INT 1
21184: DEC
21185: ST_TO_ADDR
21186: LD_EXP 61
21190: PUSH
21191: LD_VAR 0 2
21195: ARRAY
21196: PUSH
21197: FOR_TO
21198: IFFALSE 21277
// if mc_build_list [ i ] [ j ] [ 1 ] = b_workshop then
21200: LD_EXP 61
21204: PUSH
21205: LD_VAR 0 2
21209: ARRAY
21210: PUSH
21211: LD_VAR 0 3
21215: ARRAY
21216: PUSH
21217: LD_INT 1
21219: ARRAY
21220: PUSH
21221: LD_INT 2
21223: EQUAL
21224: IFFALSE 21275
// begin mc_build_list := Replace ( mc_build_list , i , Reindex ( mc_build_list [ i ] , j , 1 , false ) ) ;
21226: LD_ADDR_EXP 61
21230: PUSH
21231: LD_EXP 61
21235: PPUSH
21236: LD_VAR 0 2
21240: PPUSH
21241: LD_EXP 61
21245: PUSH
21246: LD_VAR 0 2
21250: ARRAY
21251: PPUSH
21252: LD_VAR 0 3
21256: PPUSH
21257: LD_INT 1
21259: PPUSH
21260: LD_INT 0
21262: PPUSH
21263: CALL 46538 0 4
21267: PPUSH
21268: CALL_OW 1
21272: ST_TO_ADDR
// break ;
21273: GO 21277
// end ;
21275: GO 21197
21277: POP
21278: POP
// end ; if mc_build_list [ i ] [ 1 ] [ 1 ] = b_depot or ( depot and CanBeBuilt ( depot , mc_build_list [ i ] [ 1 ] [ 1 ] , mc_build_list [ i ] [ 1 ] [ 2 ] , mc_build_list [ i ] [ 1 ] [ 3 ] , mc_build_list [ i ] [ 1 ] [ 4 ] ) ) then
21279: LD_EXP 61
21283: PUSH
21284: LD_VAR 0 2
21288: ARRAY
21289: PUSH
21290: LD_INT 1
21292: ARRAY
21293: PUSH
21294: LD_INT 1
21296: ARRAY
21297: PUSH
21298: LD_INT 0
21300: EQUAL
21301: PUSH
21302: LD_VAR 0 5
21306: PUSH
21307: LD_VAR 0 5
21311: PPUSH
21312: LD_EXP 61
21316: PUSH
21317: LD_VAR 0 2
21321: ARRAY
21322: PUSH
21323: LD_INT 1
21325: ARRAY
21326: PUSH
21327: LD_INT 1
21329: ARRAY
21330: PPUSH
21331: LD_EXP 61
21335: PUSH
21336: LD_VAR 0 2
21340: ARRAY
21341: PUSH
21342: LD_INT 1
21344: ARRAY
21345: PUSH
21346: LD_INT 2
21348: ARRAY
21349: PPUSH
21350: LD_EXP 61
21354: PUSH
21355: LD_VAR 0 2
21359: ARRAY
21360: PUSH
21361: LD_INT 1
21363: ARRAY
21364: PUSH
21365: LD_INT 3
21367: ARRAY
21368: PPUSH
21369: LD_EXP 61
21373: PUSH
21374: LD_VAR 0 2
21378: ARRAY
21379: PUSH
21380: LD_INT 1
21382: ARRAY
21383: PUSH
21384: LD_INT 4
21386: ARRAY
21387: PPUSH
21388: CALL 54535 0 5
21392: AND
21393: OR
21394: IFFALSE 21675
// begin tmp := UnitFilter ( mc_bases [ i ] , [ f_class , 2 ] ) diff mc_building_repairs [ i ] ;
21396: LD_ADDR_VAR 0 4
21400: PUSH
21401: LD_EXP 56
21405: PUSH
21406: LD_VAR 0 2
21410: ARRAY
21411: PPUSH
21412: LD_INT 25
21414: PUSH
21415: LD_INT 2
21417: PUSH
21418: EMPTY
21419: LIST
21420: LIST
21421: PPUSH
21422: CALL_OW 72
21426: PUSH
21427: LD_EXP 58
21431: PUSH
21432: LD_VAR 0 2
21436: ARRAY
21437: DIFF
21438: ST_TO_ADDR
// if not tmp then
21439: LD_VAR 0 4
21443: NOT
21444: IFFALSE 21448
// continue ;
21446: GO 20693
// for j in tmp do
21448: LD_ADDR_VAR 0 3
21452: PUSH
21453: LD_VAR 0 4
21457: PUSH
21458: FOR_IN
21459: IFFALSE 21671
// begin if not mc_builders [ i ] then
21461: LD_EXP 62
21465: PUSH
21466: LD_VAR 0 2
21470: ARRAY
21471: NOT
21472: IFFALSE 21530
// begin SetTag ( j , 103 ) ;
21474: LD_VAR 0 3
21478: PPUSH
21479: LD_INT 103
21481: PPUSH
21482: CALL_OW 109
// mc_builders := ReplaceIn ( mc_builders , [ i , mc_builders [ i ] + 1 ] , j ) ;
21486: LD_ADDR_EXP 62
21490: PUSH
21491: LD_EXP 62
21495: PPUSH
21496: LD_VAR 0 2
21500: PUSH
21501: LD_EXP 62
21505: PUSH
21506: LD_VAR 0 2
21510: ARRAY
21511: PUSH
21512: LD_INT 1
21514: PLUS
21515: PUSH
21516: EMPTY
21517: LIST
21518: LIST
21519: PPUSH
21520: LD_VAR 0 3
21524: PPUSH
21525: CALL 47120 0 3
21529: ST_TO_ADDR
// end ; if IsInUnit ( j ) then
21530: LD_VAR 0 3
21534: PPUSH
21535: CALL_OW 310
21539: IFFALSE 21550
// ComExitBuilding ( j ) ;
21541: LD_VAR 0 3
21545: PPUSH
21546: CALL_OW 122
// wait ( 3 ) ;
21550: LD_INT 3
21552: PPUSH
21553: CALL_OW 67
// if not mc_build_list [ i ] then
21557: LD_EXP 61
21561: PUSH
21562: LD_VAR 0 2
21566: ARRAY
21567: NOT
21568: IFFALSE 21572
// break ;
21570: GO 21671
// if not HasTask ( j ) then
21572: LD_VAR 0 3
21576: PPUSH
21577: CALL_OW 314
21581: NOT
21582: IFFALSE 21669
// ComBuild ( j , mc_build_list [ i ] [ 1 ] [ 1 ] , mc_build_list [ i ] [ 1 ] [ 2 ] , mc_build_list [ i ] [ 1 ] [ 3 ] , mc_build_list [ i ] [ 1 ] [ 4 ] ) ;
21584: LD_VAR 0 3
21588: PPUSH
21589: LD_EXP 61
21593: PUSH
21594: LD_VAR 0 2
21598: ARRAY
21599: PUSH
21600: LD_INT 1
21602: ARRAY
21603: PUSH
21604: LD_INT 1
21606: ARRAY
21607: PPUSH
21608: LD_EXP 61
21612: PUSH
21613: LD_VAR 0 2
21617: ARRAY
21618: PUSH
21619: LD_INT 1
21621: ARRAY
21622: PUSH
21623: LD_INT 2
21625: ARRAY
21626: PPUSH
21627: LD_EXP 61
21631: PUSH
21632: LD_VAR 0 2
21636: ARRAY
21637: PUSH
21638: LD_INT 1
21640: ARRAY
21641: PUSH
21642: LD_INT 3
21644: ARRAY
21645: PPUSH
21646: LD_EXP 61
21650: PUSH
21651: LD_VAR 0 2
21655: ARRAY
21656: PUSH
21657: LD_INT 1
21659: ARRAY
21660: PUSH
21661: LD_INT 4
21663: ARRAY
21664: PPUSH
21665: CALL_OW 145
// end ;
21669: GO 21458
21671: POP
21672: POP
// end else
21673: GO 21817
// if not TryClearPlaceForBuilding ( mc_bases [ i ] , mc_build_list [ i ] [ 1 ] [ 1 ] , mc_build_list [ i ] [ 1 ] [ 2 ] , mc_build_list [ i ] [ 1 ] [ 3 ] , mc_build_list [ i ] [ 1 ] [ 4 ] ) then
21675: LD_EXP 56
21679: PUSH
21680: LD_VAR 0 2
21684: ARRAY
21685: PPUSH
21686: LD_EXP 61
21690: PUSH
21691: LD_VAR 0 2
21695: ARRAY
21696: PUSH
21697: LD_INT 1
21699: ARRAY
21700: PUSH
21701: LD_INT 1
21703: ARRAY
21704: PPUSH
21705: LD_EXP 61
21709: PUSH
21710: LD_VAR 0 2
21714: ARRAY
21715: PUSH
21716: LD_INT 1
21718: ARRAY
21719: PUSH
21720: LD_INT 2
21722: ARRAY
21723: PPUSH
21724: LD_EXP 61
21728: PUSH
21729: LD_VAR 0 2
21733: ARRAY
21734: PUSH
21735: LD_INT 1
21737: ARRAY
21738: PUSH
21739: LD_INT 3
21741: ARRAY
21742: PPUSH
21743: LD_EXP 61
21747: PUSH
21748: LD_VAR 0 2
21752: ARRAY
21753: PUSH
21754: LD_INT 1
21756: ARRAY
21757: PUSH
21758: LD_INT 4
21760: ARRAY
21761: PPUSH
21762: CALL 53871 0 5
21766: NOT
21767: IFFALSE 21817
// begin mc_build_list := Replace ( mc_build_list , i , Reindex ( mc_build_list [ i ] , 1 , - 1 , false ) ) ;
21769: LD_ADDR_EXP 61
21773: PUSH
21774: LD_EXP 61
21778: PPUSH
21779: LD_VAR 0 2
21783: PPUSH
21784: LD_EXP 61
21788: PUSH
21789: LD_VAR 0 2
21793: ARRAY
21794: PPUSH
21795: LD_INT 1
21797: PPUSH
21798: LD_INT 1
21800: NEG
21801: PPUSH
21802: LD_INT 0
21804: PPUSH
21805: CALL 46538 0 4
21809: PPUSH
21810: CALL_OW 1
21814: ST_TO_ADDR
// continue ;
21815: GO 20693
// end ; end ; end ;
21817: GO 20693
21819: POP
21820: POP
// end ;
21821: LD_VAR 0 1
21825: RET
// export function MC_BuildUpgrade ( ) ; var i , j , tmp , depot , lab ; begin
21826: LD_INT 0
21828: PPUSH
21829: PPUSH
21830: PPUSH
21831: PPUSH
21832: PPUSH
21833: PPUSH
// if not mc_bases then
21834: LD_EXP 56
21838: NOT
21839: IFFALSE 21843
// exit ;
21841: GO 22270
// for i = 1 to mc_bases do
21843: LD_ADDR_VAR 0 2
21847: PUSH
21848: DOUBLE
21849: LD_INT 1
21851: DEC
21852: ST_TO_ADDR
21853: LD_EXP 56
21857: PUSH
21858: FOR_TO
21859: IFFALSE 22268
// begin tmp := mc_build_upgrade [ i ] ;
21861: LD_ADDR_VAR 0 4
21865: PUSH
21866: LD_EXP 88
21870: PUSH
21871: LD_VAR 0 2
21875: ARRAY
21876: ST_TO_ADDR
// lab := UnitFilter ( mc_lab [ i ] , [ f_or , [ f_btype , b_lab ] , [ f_btype , b_lab_half ] ] ) ;
21877: LD_ADDR_VAR 0 6
21881: PUSH
21882: LD_EXP 89
21886: PUSH
21887: LD_VAR 0 2
21891: ARRAY
21892: PPUSH
21893: LD_INT 2
21895: PUSH
21896: LD_INT 30
21898: PUSH
21899: LD_INT 6
21901: PUSH
21902: EMPTY
21903: LIST
21904: LIST
21905: PUSH
21906: LD_INT 30
21908: PUSH
21909: LD_INT 7
21911: PUSH
21912: EMPTY
21913: LIST
21914: LIST
21915: PUSH
21916: EMPTY
21917: LIST
21918: LIST
21919: LIST
21920: PPUSH
21921: CALL_OW 72
21925: ST_TO_ADDR
// if not tmp and not lab then
21926: LD_VAR 0 4
21930: NOT
21931: PUSH
21932: LD_VAR 0 6
21936: NOT
21937: AND
21938: IFFALSE 21942
// continue ;
21940: GO 21858
// if tmp then
21942: LD_VAR 0 4
21946: IFFALSE 22066
// for j in tmp do
21948: LD_ADDR_VAR 0 3
21952: PUSH
21953: LD_VAR 0 4
21957: PUSH
21958: FOR_IN
21959: IFFALSE 22064
// begin if UpgradeCost ( j ) then
21961: LD_VAR 0 3
21965: PPUSH
21966: CALL 53531 0 1
21970: IFFALSE 22062
// begin ComUpgrade ( j ) ;
21972: LD_VAR 0 3
21976: PPUSH
21977: CALL_OW 146
// mc_build_upgrade := Replace ( mc_build_upgrade , i , mc_build_upgrade [ i ] diff j ) ;
21981: LD_ADDR_EXP 88
21985: PUSH
21986: LD_EXP 88
21990: PPUSH
21991: LD_VAR 0 2
21995: PPUSH
21996: LD_EXP 88
22000: PUSH
22001: LD_VAR 0 2
22005: ARRAY
22006: PUSH
22007: LD_VAR 0 3
22011: DIFF
22012: PPUSH
22013: CALL_OW 1
22017: ST_TO_ADDR
// mc_construct_list := ReplaceIn ( mc_construct_list , [ i , mc_construct_list [ i ] + 1 ] , j ) ;
22018: LD_ADDR_EXP 63
22022: PUSH
22023: LD_EXP 63
22027: PPUSH
22028: LD_VAR 0 2
22032: PUSH
22033: LD_EXP 63
22037: PUSH
22038: LD_VAR 0 2
22042: ARRAY
22043: PUSH
22044: LD_INT 1
22046: PLUS
22047: PUSH
22048: EMPTY
22049: LIST
22050: LIST
22051: PPUSH
22052: LD_VAR 0 3
22056: PPUSH
22057: CALL 47120 0 3
22061: ST_TO_ADDR
// end ; end ;
22062: GO 21958
22064: POP
22065: POP
// if not lab or not mc_lab_upgrade [ i ] then
22066: LD_VAR 0 6
22070: NOT
22071: PUSH
22072: LD_EXP 90
22076: PUSH
22077: LD_VAR 0 2
22081: ARRAY
22082: NOT
22083: OR
22084: IFFALSE 22088
// continue ;
22086: GO 21858
// for j in lab do
22088: LD_ADDR_VAR 0 3
22092: PUSH
22093: LD_VAR 0 6
22097: PUSH
22098: FOR_IN
22099: IFFALSE 22264
// begin if GetBType ( j ) in [ b_lab , b_lab_half ] and BuildingStatus ( j ) <> bs_build then
22101: LD_VAR 0 3
22105: PPUSH
22106: CALL_OW 266
22110: PUSH
22111: LD_INT 6
22113: PUSH
22114: LD_INT 7
22116: PUSH
22117: EMPTY
22118: LIST
22119: LIST
22120: IN
22121: PUSH
22122: LD_VAR 0 3
22126: PPUSH
22127: CALL_OW 461
22131: PUSH
22132: LD_INT 1
22134: NONEQUAL
22135: AND
22136: IFFALSE 22262
// begin if UpgradeLabCost ( j , mc_lab_upgrade [ i ] [ 1 ] ) then
22138: LD_VAR 0 3
22142: PPUSH
22143: LD_EXP 90
22147: PUSH
22148: LD_VAR 0 2
22152: ARRAY
22153: PUSH
22154: LD_INT 1
22156: ARRAY
22157: PPUSH
22158: CALL 53736 0 2
22162: IFFALSE 22262
// begin ComCancel ( j ) ;
22164: LD_VAR 0 3
22168: PPUSH
22169: CALL_OW 127
// AddComUpgradeLab ( j , mc_lab_upgrade [ i ] [ 1 ] ) ;
22173: LD_VAR 0 3
22177: PPUSH
22178: LD_EXP 90
22182: PUSH
22183: LD_VAR 0 2
22187: ARRAY
22188: PUSH
22189: LD_INT 1
22191: ARRAY
22192: PPUSH
22193: CALL_OW 207
// if not j in mc_construct_list [ i ] then
22197: LD_VAR 0 3
22201: PUSH
22202: LD_EXP 63
22206: PUSH
22207: LD_VAR 0 2
22211: ARRAY
22212: IN
22213: NOT
22214: IFFALSE 22260
// mc_construct_list := ReplaceIn ( mc_construct_list , [ i , mc_construct_list [ i ] + 1 ] , j ) ;
22216: LD_ADDR_EXP 63
22220: PUSH
22221: LD_EXP 63
22225: PPUSH
22226: LD_VAR 0 2
22230: PUSH
22231: LD_EXP 63
22235: PUSH
22236: LD_VAR 0 2
22240: ARRAY
22241: PUSH
22242: LD_INT 1
22244: PLUS
22245: PUSH
22246: EMPTY
22247: LIST
22248: LIST
22249: PPUSH
22250: LD_VAR 0 3
22254: PPUSH
22255: CALL 47120 0 3
22259: ST_TO_ADDR
// break ;
22260: GO 22264
// end ; end ; end ;
22262: GO 22098
22264: POP
22265: POP
// end ;
22266: GO 21858
22268: POP
22269: POP
// end ;
22270: LD_VAR 0 1
22274: RET
// export function MC_TurretWeapon ( ) ; var i , j , tmp , tmp2 , t , tw , busy , weapon ; begin
22275: LD_INT 0
22277: PPUSH
22278: PPUSH
22279: PPUSH
22280: PPUSH
22281: PPUSH
22282: PPUSH
22283: PPUSH
22284: PPUSH
22285: PPUSH
// if not mc_bases then
22286: LD_EXP 56
22290: NOT
22291: IFFALSE 22295
// exit ;
22293: GO 22700
// for i = 1 to mc_bases do
22295: LD_ADDR_VAR 0 2
22299: PUSH
22300: DOUBLE
22301: LD_INT 1
22303: DEC
22304: ST_TO_ADDR
22305: LD_EXP 56
22309: PUSH
22310: FOR_TO
22311: IFFALSE 22698
// begin if not mc_turret_list [ i ] or not UnitFilter ( mc_bases [ i ] , [ f_btype , b_factory ] ) then
22313: LD_EXP 64
22317: PUSH
22318: LD_VAR 0 2
22322: ARRAY
22323: NOT
22324: PUSH
22325: LD_EXP 56
22329: PUSH
22330: LD_VAR 0 2
22334: ARRAY
22335: PPUSH
22336: LD_INT 30
22338: PUSH
22339: LD_INT 3
22341: PUSH
22342: EMPTY
22343: LIST
22344: LIST
22345: PPUSH
22346: CALL_OW 72
22350: NOT
22351: OR
22352: IFFALSE 22356
// continue ;
22354: GO 22310
// busy := false ;
22356: LD_ADDR_VAR 0 8
22360: PUSH
22361: LD_INT 0
22363: ST_TO_ADDR
// tmp := UnitFilter ( mc_bases [ i ] , [ f_btype , b_factory ] ) ;
22364: LD_ADDR_VAR 0 4
22368: PUSH
22369: LD_EXP 56
22373: PUSH
22374: LD_VAR 0 2
22378: ARRAY
22379: PPUSH
22380: LD_INT 30
22382: PUSH
22383: LD_INT 3
22385: PUSH
22386: EMPTY
22387: LIST
22388: LIST
22389: PPUSH
22390: CALL_OW 72
22394: ST_TO_ADDR
// t := UnitFilter ( mc_turret_list [ i ] , [ f_or , [ f_btype , b_bunker ] , [ f_btype , b_turret ] ] ) ;
22395: LD_ADDR_VAR 0 6
22399: PUSH
22400: LD_EXP 64
22404: PUSH
22405: LD_VAR 0 2
22409: ARRAY
22410: PPUSH
22411: LD_INT 2
22413: PUSH
22414: LD_INT 30
22416: PUSH
22417: LD_INT 32
22419: PUSH
22420: EMPTY
22421: LIST
22422: LIST
22423: PUSH
22424: LD_INT 30
22426: PUSH
22427: LD_INT 33
22429: PUSH
22430: EMPTY
22431: LIST
22432: LIST
22433: PUSH
22434: EMPTY
22435: LIST
22436: LIST
22437: LIST
22438: PPUSH
22439: CALL_OW 72
22443: ST_TO_ADDR
// if not t then
22444: LD_VAR 0 6
22448: NOT
22449: IFFALSE 22453
// continue ;
22451: GO 22310
// for j in tmp do
22453: LD_ADDR_VAR 0 3
22457: PUSH
22458: LD_VAR 0 4
22462: PUSH
22463: FOR_IN
22464: IFFALSE 22494
// if not BuildingStatus ( j ) = bs_idle then
22466: LD_VAR 0 3
22470: PPUSH
22471: CALL_OW 461
22475: PUSH
22476: LD_INT 2
22478: EQUAL
22479: NOT
22480: IFFALSE 22492
// begin busy := true ;
22482: LD_ADDR_VAR 0 8
22486: PUSH
22487: LD_INT 1
22489: ST_TO_ADDR
// break ;
22490: GO 22494
// end ;
22492: GO 22463
22494: POP
22495: POP
// if busy then
22496: LD_VAR 0 8
22500: IFFALSE 22504
// continue ;
22502: GO 22310
// tw := UnitFilter ( t , [ f_bweapon , 0 ] ) ;
22504: LD_ADDR_VAR 0 7
22508: PUSH
22509: LD_VAR 0 6
22513: PPUSH
22514: LD_INT 35
22516: PUSH
22517: LD_INT 0
22519: PUSH
22520: EMPTY
22521: LIST
22522: LIST
22523: PPUSH
22524: CALL_OW 72
22528: ST_TO_ADDR
// if tw then
22529: LD_VAR 0 7
22533: IFFALSE 22610
// begin tw := tw [ 1 ] ;
22535: LD_ADDR_VAR 0 7
22539: PUSH
22540: LD_VAR 0 7
22544: PUSH
22545: LD_INT 1
22547: ARRAY
22548: ST_TO_ADDR
// weapon := GetTurretWeapon ( tw , mc_scan_area [ i ] ) ;
22549: LD_ADDR_VAR 0 9
22553: PUSH
22554: LD_VAR 0 7
22558: PPUSH
22559: LD_EXP 81
22563: PUSH
22564: LD_VAR 0 2
22568: ARRAY
22569: PPUSH
22570: CALL 52090 0 2
22574: ST_TO_ADDR
// if mc_allowed_tower_weapons [ i ] then
22575: LD_EXP 95
22579: PUSH
22580: LD_VAR 0 2
22584: ARRAY
22585: IFFALSE 22608
// if not weapon in mc_allowed_tower_weapons [ i ] then
22587: LD_VAR 0 9
22591: PUSH
22592: LD_EXP 95
22596: PUSH
22597: LD_VAR 0 2
22601: ARRAY
22602: IN
22603: NOT
22604: IFFALSE 22608
// continue ;
22606: GO 22310
// end else
22608: GO 22673
// begin tmp2 := UpgradeTurretsWeapon ( mc_turret_list [ i ] , tmp ) ;
22610: LD_ADDR_VAR 0 5
22614: PUSH
22615: LD_EXP 64
22619: PUSH
22620: LD_VAR 0 2
22624: ARRAY
22625: PPUSH
22626: LD_VAR 0 4
22630: PPUSH
22631: CALL 82291 0 2
22635: ST_TO_ADDR
// if not tmp2 then
22636: LD_VAR 0 5
22640: NOT
22641: IFFALSE 22645
// continue ;
22643: GO 22310
// tw := tmp2 [ 1 ] ;
22645: LD_ADDR_VAR 0 7
22649: PUSH
22650: LD_VAR 0 5
22654: PUSH
22655: LD_INT 1
22657: ARRAY
22658: ST_TO_ADDR
// weapon := tmp2 [ 2 ] ;
22659: LD_ADDR_VAR 0 9
22663: PUSH
22664: LD_VAR 0 5
22668: PUSH
22669: LD_INT 2
22671: ARRAY
22672: ST_TO_ADDR
// end ; if not weapon then
22673: LD_VAR 0 9
22677: NOT
22678: IFFALSE 22682
// continue ;
22680: GO 22310
// ComPlaceWeapon ( tw , weapon ) ;
22682: LD_VAR 0 7
22686: PPUSH
22687: LD_VAR 0 9
22691: PPUSH
22692: CALL_OW 148
// end ;
22696: GO 22310
22698: POP
22699: POP
// end ;
22700: LD_VAR 0 1
22704: RET
// export function MC_PlantMines ( ) ; var i , j , k , tmp , list ; begin
22705: LD_INT 0
22707: PPUSH
22708: PPUSH
22709: PPUSH
22710: PPUSH
22711: PPUSH
22712: PPUSH
// if not mc_bases then
22713: LD_EXP 56
22717: NOT
22718: IFFALSE 22722
// exit ;
22720: GO 23734
// for i = 1 to mc_bases do
22722: LD_ADDR_VAR 0 2
22726: PUSH
22727: DOUBLE
22728: LD_INT 1
22730: DEC
22731: ST_TO_ADDR
22732: LD_EXP 56
22736: PUSH
22737: FOR_TO
22738: IFFALSE 23732
// begin if not mc_mines [ i ] or mc_mines [ i ] = mc_miners [ i ] then
22740: LD_EXP 69
22744: PUSH
22745: LD_VAR 0 2
22749: ARRAY
22750: NOT
22751: PUSH
22752: LD_EXP 69
22756: PUSH
22757: LD_VAR 0 2
22761: ARRAY
22762: PUSH
22763: LD_EXP 70
22767: PUSH
22768: LD_VAR 0 2
22772: ARRAY
22773: EQUAL
22774: OR
22775: IFFALSE 22779
// continue ;
22777: GO 22737
// if mc_miners [ i ] then
22779: LD_EXP 70
22783: PUSH
22784: LD_VAR 0 2
22788: ARRAY
22789: IFFALSE 23419
// begin k := 1 ;
22791: LD_ADDR_VAR 0 4
22795: PUSH
22796: LD_INT 1
22798: ST_TO_ADDR
// for j = mc_miners [ i ] downto 1 do
22799: LD_ADDR_VAR 0 3
22803: PUSH
22804: DOUBLE
22805: LD_EXP 70
22809: PUSH
22810: LD_VAR 0 2
22814: ARRAY
22815: INC
22816: ST_TO_ADDR
22817: LD_INT 1
22819: PUSH
22820: FOR_DOWNTO
22821: IFFALSE 23417
// begin if IsDead ( mc_miners [ i ] [ j ] ) or GetClass ( mc_miners [ i ] [ j ] ) <> 1 then
22823: LD_EXP 70
22827: PUSH
22828: LD_VAR 0 2
22832: ARRAY
22833: PUSH
22834: LD_VAR 0 3
22838: ARRAY
22839: PPUSH
22840: CALL_OW 301
22844: PUSH
22845: LD_EXP 70
22849: PUSH
22850: LD_VAR 0 2
22854: ARRAY
22855: PUSH
22856: LD_VAR 0 3
22860: ARRAY
22861: PPUSH
22862: CALL_OW 257
22866: PUSH
22867: LD_INT 1
22869: NONEQUAL
22870: OR
22871: IFFALSE 22934
// begin tmp := mc_miners [ i ] diff mc_miners [ i ] [ j ] ;
22873: LD_ADDR_VAR 0 5
22877: PUSH
22878: LD_EXP 70
22882: PUSH
22883: LD_VAR 0 2
22887: ARRAY
22888: PUSH
22889: LD_EXP 70
22893: PUSH
22894: LD_VAR 0 2
22898: ARRAY
22899: PUSH
22900: LD_VAR 0 3
22904: ARRAY
22905: DIFF
22906: ST_TO_ADDR
// mc_miners := Replace ( mc_miners , i , tmp ) ;
22907: LD_ADDR_EXP 70
22911: PUSH
22912: LD_EXP 70
22916: PPUSH
22917: LD_VAR 0 2
22921: PPUSH
22922: LD_VAR 0 5
22926: PPUSH
22927: CALL_OW 1
22931: ST_TO_ADDR
// continue ;
22932: GO 22820
// end ; if WantPlant ( mc_miners [ i ] [ j ] ) and ( DangerAtRangeXY ( GetSide ( mc_miners [ i ] [ j ] ) , mc_mines [ i ] [ k ] [ 1 ] , mc_mines [ i ] [ k ] [ 2 ] , 15 ) [ 4 ] or DangerAtRange ( mc_miners [ i ] [ j ] , 10 ) [ 4 ] ) then
22934: LD_EXP 70
22938: PUSH
22939: LD_VAR 0 2
22943: ARRAY
22944: PUSH
22945: LD_VAR 0 3
22949: ARRAY
22950: PPUSH
22951: CALL 47056 0 1
22955: PUSH
22956: LD_EXP 70
22960: PUSH
22961: LD_VAR 0 2
22965: ARRAY
22966: PUSH
22967: LD_VAR 0 3
22971: ARRAY
22972: PPUSH
22973: CALL_OW 255
22977: PPUSH
22978: LD_EXP 69
22982: PUSH
22983: LD_VAR 0 2
22987: ARRAY
22988: PUSH
22989: LD_VAR 0 4
22993: ARRAY
22994: PUSH
22995: LD_INT 1
22997: ARRAY
22998: PPUSH
22999: LD_EXP 69
23003: PUSH
23004: LD_VAR 0 2
23008: ARRAY
23009: PUSH
23010: LD_VAR 0 4
23014: ARRAY
23015: PUSH
23016: LD_INT 2
23018: ARRAY
23019: PPUSH
23020: LD_INT 15
23022: PPUSH
23023: CALL 48016 0 4
23027: PUSH
23028: LD_INT 4
23030: ARRAY
23031: PUSH
23032: LD_EXP 70
23036: PUSH
23037: LD_VAR 0 2
23041: ARRAY
23042: PUSH
23043: LD_VAR 0 3
23047: ARRAY
23048: PPUSH
23049: LD_INT 10
23051: PPUSH
23052: CALL 49713 0 2
23056: PUSH
23057: LD_INT 4
23059: ARRAY
23060: OR
23061: AND
23062: IFFALSE 23085
// ComStop ( mc_miners [ i ] [ j ] ) ;
23064: LD_EXP 70
23068: PUSH
23069: LD_VAR 0 2
23073: ARRAY
23074: PUSH
23075: LD_VAR 0 3
23079: ARRAY
23080: PPUSH
23081: CALL_OW 141
// if GetClass ( mc_miners [ i ] [ j ] ) = 1 and not MineOfUnit ( mc_miners [ i ] [ j ] ) and DangerAtRangeXY ( GetSide ( mc_miners [ i ] [ j ] ) , mc_mines [ i ] [ k ] [ 1 ] , mc_mines [ i ] [ k ] [ 2 ] , 15 ) [ 4 ] = 0 and not HasTask ( mc_miners [ i ] [ j ] ) then
23085: LD_EXP 70
23089: PUSH
23090: LD_VAR 0 2
23094: ARRAY
23095: PUSH
23096: LD_VAR 0 3
23100: ARRAY
23101: PPUSH
23102: CALL_OW 257
23106: PUSH
23107: LD_INT 1
23109: EQUAL
23110: PUSH
23111: LD_EXP 70
23115: PUSH
23116: LD_VAR 0 2
23120: ARRAY
23121: PUSH
23122: LD_VAR 0 3
23126: ARRAY
23127: PPUSH
23128: CALL_OW 459
23132: NOT
23133: AND
23134: PUSH
23135: LD_EXP 70
23139: PUSH
23140: LD_VAR 0 2
23144: ARRAY
23145: PUSH
23146: LD_VAR 0 3
23150: ARRAY
23151: PPUSH
23152: CALL_OW 255
23156: PPUSH
23157: LD_EXP 69
23161: PUSH
23162: LD_VAR 0 2
23166: ARRAY
23167: PUSH
23168: LD_VAR 0 4
23172: ARRAY
23173: PUSH
23174: LD_INT 1
23176: ARRAY
23177: PPUSH
23178: LD_EXP 69
23182: PUSH
23183: LD_VAR 0 2
23187: ARRAY
23188: PUSH
23189: LD_VAR 0 4
23193: ARRAY
23194: PUSH
23195: LD_INT 2
23197: ARRAY
23198: PPUSH
23199: LD_INT 15
23201: PPUSH
23202: CALL 48016 0 4
23206: PUSH
23207: LD_INT 4
23209: ARRAY
23210: PUSH
23211: LD_INT 0
23213: EQUAL
23214: AND
23215: PUSH
23216: LD_EXP 70
23220: PUSH
23221: LD_VAR 0 2
23225: ARRAY
23226: PUSH
23227: LD_VAR 0 3
23231: ARRAY
23232: PPUSH
23233: CALL_OW 314
23237: NOT
23238: AND
23239: IFFALSE 23415
// begin if IsInUnit ( mc_miners [ i ] [ j ] ) then
23241: LD_EXP 70
23245: PUSH
23246: LD_VAR 0 2
23250: ARRAY
23251: PUSH
23252: LD_VAR 0 3
23256: ARRAY
23257: PPUSH
23258: CALL_OW 310
23262: IFFALSE 23285
// ComExitBuilding ( mc_miners [ i ] [ j ] ) ;
23264: LD_EXP 70
23268: PUSH
23269: LD_VAR 0 2
23273: ARRAY
23274: PUSH
23275: LD_VAR 0 3
23279: ARRAY
23280: PPUSH
23281: CALL_OW 122
// if not HasTask ( mc_miners [ i ] [ j ] ) then
23285: LD_EXP 70
23289: PUSH
23290: LD_VAR 0 2
23294: ARRAY
23295: PUSH
23296: LD_VAR 0 3
23300: ARRAY
23301: PPUSH
23302: CALL_OW 314
23306: NOT
23307: IFFALSE 23375
// AddComPlaceRemoteCharge ( mc_miners [ i ] [ j ] , mc_mines [ i ] [ k ] [ 1 ] , mc_mines [ i ] [ k ] [ 2 ] , 0 ) ;
23309: LD_EXP 70
23313: PUSH
23314: LD_VAR 0 2
23318: ARRAY
23319: PUSH
23320: LD_VAR 0 3
23324: ARRAY
23325: PPUSH
23326: LD_EXP 69
23330: PUSH
23331: LD_VAR 0 2
23335: ARRAY
23336: PUSH
23337: LD_VAR 0 4
23341: ARRAY
23342: PUSH
23343: LD_INT 1
23345: ARRAY
23346: PPUSH
23347: LD_EXP 69
23351: PUSH
23352: LD_VAR 0 2
23356: ARRAY
23357: PUSH
23358: LD_VAR 0 4
23362: ARRAY
23363: PUSH
23364: LD_INT 2
23366: ARRAY
23367: PPUSH
23368: LD_INT 0
23370: PPUSH
23371: CALL_OW 193
// k := k + 1 ;
23375: LD_ADDR_VAR 0 4
23379: PUSH
23380: LD_VAR 0 4
23384: PUSH
23385: LD_INT 1
23387: PLUS
23388: ST_TO_ADDR
// if k > mc_mines [ i ] then
23389: LD_VAR 0 4
23393: PUSH
23394: LD_EXP 69
23398: PUSH
23399: LD_VAR 0 2
23403: ARRAY
23404: GREATER
23405: IFFALSE 23415
// k := 1 ;
23407: LD_ADDR_VAR 0 4
23411: PUSH
23412: LD_INT 1
23414: ST_TO_ADDR
// end ; end ;
23415: GO 22820
23417: POP
23418: POP
// end ; tmp := UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_armoury ] , [ f_btype , b_barracks ] , [ f_btype , b_bunker ] ] ) ;
23419: LD_ADDR_VAR 0 5
23423: PUSH
23424: LD_EXP 56
23428: PUSH
23429: LD_VAR 0 2
23433: ARRAY
23434: PPUSH
23435: LD_INT 2
23437: PUSH
23438: LD_INT 30
23440: PUSH
23441: LD_INT 4
23443: PUSH
23444: EMPTY
23445: LIST
23446: LIST
23447: PUSH
23448: LD_INT 30
23450: PUSH
23451: LD_INT 5
23453: PUSH
23454: EMPTY
23455: LIST
23456: LIST
23457: PUSH
23458: LD_INT 30
23460: PUSH
23461: LD_INT 32
23463: PUSH
23464: EMPTY
23465: LIST
23466: LIST
23467: PUSH
23468: EMPTY
23469: LIST
23470: LIST
23471: LIST
23472: LIST
23473: PPUSH
23474: CALL_OW 72
23478: ST_TO_ADDR
// if not tmp then
23479: LD_VAR 0 5
23483: NOT
23484: IFFALSE 23488
// continue ;
23486: GO 22737
// list := [ ] ;
23488: LD_ADDR_VAR 0 6
23492: PUSH
23493: EMPTY
23494: ST_TO_ADDR
// for j in tmp do
23495: LD_ADDR_VAR 0 3
23499: PUSH
23500: LD_VAR 0 5
23504: PUSH
23505: FOR_IN
23506: IFFALSE 23575
// begin for k in UnitsInside ( j ) do
23508: LD_ADDR_VAR 0 4
23512: PUSH
23513: LD_VAR 0 3
23517: PPUSH
23518: CALL_OW 313
23522: PUSH
23523: FOR_IN
23524: IFFALSE 23571
// if GetClass ( k ) = 1 and not MineOfUnit ( k ) then
23526: LD_VAR 0 4
23530: PPUSH
23531: CALL_OW 257
23535: PUSH
23536: LD_INT 1
23538: EQUAL
23539: PUSH
23540: LD_VAR 0 4
23544: PPUSH
23545: CALL_OW 459
23549: NOT
23550: AND
23551: IFFALSE 23569
// list := list ^ k ;
23553: LD_ADDR_VAR 0 6
23557: PUSH
23558: LD_VAR 0 6
23562: PUSH
23563: LD_VAR 0 4
23567: ADD
23568: ST_TO_ADDR
23569: GO 23523
23571: POP
23572: POP
// end ;
23573: GO 23505
23575: POP
23576: POP
// list := list diff mc_miners [ i ] ;
23577: LD_ADDR_VAR 0 6
23581: PUSH
23582: LD_VAR 0 6
23586: PUSH
23587: LD_EXP 70
23591: PUSH
23592: LD_VAR 0 2
23596: ARRAY
23597: DIFF
23598: ST_TO_ADDR
// if not list then
23599: LD_VAR 0 6
23603: NOT
23604: IFFALSE 23608
// continue ;
23606: GO 22737
// k := mc_mines [ i ] - mc_miners [ i ] ;
23608: LD_ADDR_VAR 0 4
23612: PUSH
23613: LD_EXP 69
23617: PUSH
23618: LD_VAR 0 2
23622: ARRAY
23623: PUSH
23624: LD_EXP 70
23628: PUSH
23629: LD_VAR 0 2
23633: ARRAY
23634: MINUS
23635: ST_TO_ADDR
// if k > list then
23636: LD_VAR 0 4
23640: PUSH
23641: LD_VAR 0 6
23645: GREATER
23646: IFFALSE 23658
// k := list ;
23648: LD_ADDR_VAR 0 4
23652: PUSH
23653: LD_VAR 0 6
23657: ST_TO_ADDR
// for j = 1 to k do
23658: LD_ADDR_VAR 0 3
23662: PUSH
23663: DOUBLE
23664: LD_INT 1
23666: DEC
23667: ST_TO_ADDR
23668: LD_VAR 0 4
23672: PUSH
23673: FOR_TO
23674: IFFALSE 23728
// mc_miners := ReplaceIn ( mc_miners , [ i , mc_miners [ i ] + 1 ] , list [ j ] ) ;
23676: LD_ADDR_EXP 70
23680: PUSH
23681: LD_EXP 70
23685: PPUSH
23686: LD_VAR 0 2
23690: PUSH
23691: LD_EXP 70
23695: PUSH
23696: LD_VAR 0 2
23700: ARRAY
23701: PUSH
23702: LD_INT 1
23704: PLUS
23705: PUSH
23706: EMPTY
23707: LIST
23708: LIST
23709: PPUSH
23710: LD_VAR 0 6
23714: PUSH
23715: LD_VAR 0 3
23719: ARRAY
23720: PPUSH
23721: CALL 47120 0 3
23725: ST_TO_ADDR
23726: GO 23673
23728: POP
23729: POP
// end ;
23730: GO 22737
23732: POP
23733: POP
// end ;
23734: LD_VAR 0 1
23738: RET
// export function MC_CollectCrates ( ) ; var i , j , k , tmp , target , cargo , depot , fac , components ; begin
23739: LD_INT 0
23741: PPUSH
23742: PPUSH
23743: PPUSH
23744: PPUSH
23745: PPUSH
23746: PPUSH
23747: PPUSH
23748: PPUSH
23749: PPUSH
23750: PPUSH
// if not mc_bases then
23751: LD_EXP 56
23755: NOT
23756: IFFALSE 23760
// exit ;
23758: GO 25510
// for i = 1 to mc_bases do
23760: LD_ADDR_VAR 0 2
23764: PUSH
23765: DOUBLE
23766: LD_INT 1
23768: DEC
23769: ST_TO_ADDR
23770: LD_EXP 56
23774: PUSH
23775: FOR_TO
23776: IFFALSE 25508
// begin if not mc_bases [ i ] or mc_construct_list [ i ] then
23778: LD_EXP 56
23782: PUSH
23783: LD_VAR 0 2
23787: ARRAY
23788: NOT
23789: PUSH
23790: LD_EXP 63
23794: PUSH
23795: LD_VAR 0 2
23799: ARRAY
23800: OR
23801: IFFALSE 23805
// continue ;
23803: GO 23775
// if not mc_crates [ i ] and mc_crates_collector [ i ] then
23805: LD_EXP 72
23809: PUSH
23810: LD_VAR 0 2
23814: ARRAY
23815: NOT
23816: PUSH
23817: LD_EXP 73
23821: PUSH
23822: LD_VAR 0 2
23826: ARRAY
23827: AND
23828: IFFALSE 23866
// begin mc_crates_collector := Replace ( mc_crates_collector , i , [ ] ) ;
23830: LD_ADDR_EXP 73
23834: PUSH
23835: LD_EXP 73
23839: PPUSH
23840: LD_VAR 0 2
23844: PPUSH
23845: EMPTY
23846: PPUSH
23847: CALL_OW 1
23851: ST_TO_ADDR
// MC_Reset ( i , 107 ) ;
23852: LD_VAR 0 2
23856: PPUSH
23857: LD_INT 107
23859: PPUSH
23860: CALL 14620 0 2
// continue ;
23864: GO 23775
// end ; target := [ ] ;
23866: LD_ADDR_VAR 0 6
23870: PUSH
23871: EMPTY
23872: ST_TO_ADDR
// for j = mc_crates [ i ] downto 1 do
23873: LD_ADDR_VAR 0 3
23877: PUSH
23878: DOUBLE
23879: LD_EXP 72
23883: PUSH
23884: LD_VAR 0 2
23888: ARRAY
23889: INC
23890: ST_TO_ADDR
23891: LD_INT 1
23893: PUSH
23894: FOR_DOWNTO
23895: IFFALSE 24155
// begin if ValidHex ( mc_crates [ i ] [ j ] [ 2 ] , mc_crates [ i ] [ j ] [ 3 ] ) and GetResourceAmountXY ( mc_crates [ i ] [ j ] [ 2 ] , mc_crates [ i ] [ j ] [ 3 ] ) = 0 then
23897: LD_EXP 72
23901: PUSH
23902: LD_VAR 0 2
23906: ARRAY
23907: PUSH
23908: LD_VAR 0 3
23912: ARRAY
23913: PUSH
23914: LD_INT 2
23916: ARRAY
23917: PPUSH
23918: LD_EXP 72
23922: PUSH
23923: LD_VAR 0 2
23927: ARRAY
23928: PUSH
23929: LD_VAR 0 3
23933: ARRAY
23934: PUSH
23935: LD_INT 3
23937: ARRAY
23938: PPUSH
23939: CALL_OW 488
23943: PUSH
23944: LD_EXP 72
23948: PUSH
23949: LD_VAR 0 2
23953: ARRAY
23954: PUSH
23955: LD_VAR 0 3
23959: ARRAY
23960: PUSH
23961: LD_INT 2
23963: ARRAY
23964: PPUSH
23965: LD_EXP 72
23969: PUSH
23970: LD_VAR 0 2
23974: ARRAY
23975: PUSH
23976: LD_VAR 0 3
23980: ARRAY
23981: PUSH
23982: LD_INT 3
23984: ARRAY
23985: PPUSH
23986: CALL_OW 284
23990: PUSH
23991: LD_INT 0
23993: EQUAL
23994: AND
23995: IFFALSE 24050
// begin tmp := Delete ( mc_crates [ i ] , j ) ;
23997: LD_ADDR_VAR 0 5
24001: PUSH
24002: LD_EXP 72
24006: PUSH
24007: LD_VAR 0 2
24011: ARRAY
24012: PPUSH
24013: LD_VAR 0 3
24017: PPUSH
24018: CALL_OW 3
24022: ST_TO_ADDR
// mc_crates := Replace ( mc_crates , i , tmp ) ;
24023: LD_ADDR_EXP 72
24027: PUSH
24028: LD_EXP 72
24032: PPUSH
24033: LD_VAR 0 2
24037: PPUSH
24038: LD_VAR 0 5
24042: PPUSH
24043: CALL_OW 1
24047: ST_TO_ADDR
// continue ;
24048: GO 23894
// end ; if DangerAtRangeXY ( GetSide ( mc_bases [ i ] [ 1 ] ) , mc_crates [ i ] [ j ] [ 2 ] , mc_crates [ i ] [ j ] [ 3 ] , 30 ) [ 4 ] = 0 then
24050: LD_EXP 56
24054: PUSH
24055: LD_VAR 0 2
24059: ARRAY
24060: PUSH
24061: LD_INT 1
24063: ARRAY
24064: PPUSH
24065: CALL_OW 255
24069: PPUSH
24070: LD_EXP 72
24074: PUSH
24075: LD_VAR 0 2
24079: ARRAY
24080: PUSH
24081: LD_VAR 0 3
24085: ARRAY
24086: PUSH
24087: LD_INT 2
24089: ARRAY
24090: PPUSH
24091: LD_EXP 72
24095: PUSH
24096: LD_VAR 0 2
24100: ARRAY
24101: PUSH
24102: LD_VAR 0 3
24106: ARRAY
24107: PUSH
24108: LD_INT 3
24110: ARRAY
24111: PPUSH
24112: LD_INT 30
24114: PPUSH
24115: CALL 48016 0 4
24119: PUSH
24120: LD_INT 4
24122: ARRAY
24123: PUSH
24124: LD_INT 0
24126: EQUAL
24127: IFFALSE 24153
// begin target := mc_crates [ i ] [ j ] ;
24129: LD_ADDR_VAR 0 6
24133: PUSH
24134: LD_EXP 72
24138: PUSH
24139: LD_VAR 0 2
24143: ARRAY
24144: PUSH
24145: LD_VAR 0 3
24149: ARRAY
24150: ST_TO_ADDR
// break ;
24151: GO 24155
// end ; end ;
24153: GO 23894
24155: POP
24156: POP
// if not target then
24157: LD_VAR 0 6
24161: NOT
24162: IFFALSE 24166
// continue ;
24164: GO 23775
// cargo := UnitFilter ( mc_vehicles [ i ] , [ [ f_or , [ f_not , [ f_empty ] ] , [ f_linked ] , [ f_control , control_apeman ] , [ f_control , control_computer ] ] , [ f_or , [ f_weapon , ar_cargo_bay ] , [ f_weapon , ru_cargo_bay ] , [ f_weapon , us_cargo_bay ] ] ] ) ;
24166: LD_ADDR_VAR 0 7
24170: PUSH
24171: LD_EXP 75
24175: PUSH
24176: LD_VAR 0 2
24180: ARRAY
24181: PPUSH
24182: LD_INT 2
24184: PUSH
24185: LD_INT 3
24187: PUSH
24188: LD_INT 58
24190: PUSH
24191: EMPTY
24192: LIST
24193: PUSH
24194: EMPTY
24195: LIST
24196: LIST
24197: PUSH
24198: LD_INT 61
24200: PUSH
24201: EMPTY
24202: LIST
24203: PUSH
24204: LD_INT 33
24206: PUSH
24207: LD_INT 5
24209: PUSH
24210: EMPTY
24211: LIST
24212: LIST
24213: PUSH
24214: LD_INT 33
24216: PUSH
24217: LD_INT 3
24219: PUSH
24220: EMPTY
24221: LIST
24222: LIST
24223: PUSH
24224: EMPTY
24225: LIST
24226: LIST
24227: LIST
24228: LIST
24229: LIST
24230: PUSH
24231: LD_INT 2
24233: PUSH
24234: LD_INT 34
24236: PUSH
24237: LD_INT 32
24239: PUSH
24240: EMPTY
24241: LIST
24242: LIST
24243: PUSH
24244: LD_INT 34
24246: PUSH
24247: LD_INT 51
24249: PUSH
24250: EMPTY
24251: LIST
24252: LIST
24253: PUSH
24254: LD_INT 34
24256: PUSH
24257: LD_INT 12
24259: PUSH
24260: EMPTY
24261: LIST
24262: LIST
24263: PUSH
24264: EMPTY
24265: LIST
24266: LIST
24267: LIST
24268: LIST
24269: PUSH
24270: EMPTY
24271: LIST
24272: LIST
24273: PPUSH
24274: CALL_OW 72
24278: ST_TO_ADDR
// if not cargo then
24279: LD_VAR 0 7
24283: NOT
24284: IFFALSE 24927
// begin if mc_crates_collector [ i ] < 5 then
24286: LD_EXP 73
24290: PUSH
24291: LD_VAR 0 2
24295: ARRAY
24296: PUSH
24297: LD_INT 5
24299: LESS
24300: IFFALSE 24666
// begin if mc_ape [ i ] then
24302: LD_EXP 85
24306: PUSH
24307: LD_VAR 0 2
24311: ARRAY
24312: IFFALSE 24359
// tmp := UnitFilter ( mc_ape [ i ] , [ [ f_class , 16 ] , [ f_lives , 750 ] ] ) ;
24314: LD_ADDR_VAR 0 5
24318: PUSH
24319: LD_EXP 85
24323: PUSH
24324: LD_VAR 0 2
24328: ARRAY
24329: PPUSH
24330: LD_INT 25
24332: PUSH
24333: LD_INT 16
24335: PUSH
24336: EMPTY
24337: LIST
24338: LIST
24339: PUSH
24340: LD_INT 24
24342: PUSH
24343: LD_INT 750
24345: PUSH
24346: EMPTY
24347: LIST
24348: LIST
24349: PUSH
24350: EMPTY
24351: LIST
24352: LIST
24353: PPUSH
24354: CALL_OW 72
24358: ST_TO_ADDR
// if not tmp then
24359: LD_VAR 0 5
24363: NOT
24364: IFFALSE 24411
// tmp := UnitFilter ( mc_bases [ i ] , [ [ f_class , 2 ] , [ f_lives , 750 ] ] ) ;
24366: LD_ADDR_VAR 0 5
24370: PUSH
24371: LD_EXP 56
24375: PUSH
24376: LD_VAR 0 2
24380: ARRAY
24381: PPUSH
24382: LD_INT 25
24384: PUSH
24385: LD_INT 2
24387: PUSH
24388: EMPTY
24389: LIST
24390: LIST
24391: PUSH
24392: LD_INT 24
24394: PUSH
24395: LD_INT 750
24397: PUSH
24398: EMPTY
24399: LIST
24400: LIST
24401: PUSH
24402: EMPTY
24403: LIST
24404: LIST
24405: PPUSH
24406: CALL_OW 72
24410: ST_TO_ADDR
// if mc_ape [ i ] and UnitFilter ( mc_bases [ i ] , [ [ f_class , 2 ] , [ f_lives , 750 ] ] ) and tmp < 5 then
24411: LD_EXP 85
24415: PUSH
24416: LD_VAR 0 2
24420: ARRAY
24421: PUSH
24422: LD_EXP 56
24426: PUSH
24427: LD_VAR 0 2
24431: ARRAY
24432: PPUSH
24433: LD_INT 25
24435: PUSH
24436: LD_INT 2
24438: PUSH
24439: EMPTY
24440: LIST
24441: LIST
24442: PUSH
24443: LD_INT 24
24445: PUSH
24446: LD_INT 750
24448: PUSH
24449: EMPTY
24450: LIST
24451: LIST
24452: PUSH
24453: EMPTY
24454: LIST
24455: LIST
24456: PPUSH
24457: CALL_OW 72
24461: AND
24462: PUSH
24463: LD_VAR 0 5
24467: PUSH
24468: LD_INT 5
24470: LESS
24471: AND
24472: IFFALSE 24554
// begin for j in UnitFilter ( mc_bases [ i ] , [ [ f_class , 2 ] , [ f_lives , 750 ] ] ) do
24474: LD_ADDR_VAR 0 3
24478: PUSH
24479: LD_EXP 56
24483: PUSH
24484: LD_VAR 0 2
24488: ARRAY
24489: PPUSH
24490: LD_INT 25
24492: PUSH
24493: LD_INT 2
24495: PUSH
24496: EMPTY
24497: LIST
24498: LIST
24499: PUSH
24500: LD_INT 24
24502: PUSH
24503: LD_INT 750
24505: PUSH
24506: EMPTY
24507: LIST
24508: LIST
24509: PUSH
24510: EMPTY
24511: LIST
24512: LIST
24513: PPUSH
24514: CALL_OW 72
24518: PUSH
24519: FOR_IN
24520: IFFALSE 24552
// begin tmp := tmp union j ;
24522: LD_ADDR_VAR 0 5
24526: PUSH
24527: LD_VAR 0 5
24531: PUSH
24532: LD_VAR 0 3
24536: UNION
24537: ST_TO_ADDR
// if tmp >= 5 then
24538: LD_VAR 0 5
24542: PUSH
24543: LD_INT 5
24545: GREATEREQUAL
24546: IFFALSE 24550
// break ;
24548: GO 24552
// end ;
24550: GO 24519
24552: POP
24553: POP
// end ; if not tmp then
24554: LD_VAR 0 5
24558: NOT
24559: IFFALSE 24563
// continue ;
24561: GO 23775
// for j in tmp do
24563: LD_ADDR_VAR 0 3
24567: PUSH
24568: LD_VAR 0 5
24572: PUSH
24573: FOR_IN
24574: IFFALSE 24664
// if not GetTag ( j ) then
24576: LD_VAR 0 3
24580: PPUSH
24581: CALL_OW 110
24585: NOT
24586: IFFALSE 24662
// begin mc_crates_collector := ReplaceIn ( mc_crates_collector , [ i , mc_crates_collector [ i ] + 1 ] , j ) ;
24588: LD_ADDR_EXP 73
24592: PUSH
24593: LD_EXP 73
24597: PPUSH
24598: LD_VAR 0 2
24602: PUSH
24603: LD_EXP 73
24607: PUSH
24608: LD_VAR 0 2
24612: ARRAY
24613: PUSH
24614: LD_INT 1
24616: PLUS
24617: PUSH
24618: EMPTY
24619: LIST
24620: LIST
24621: PPUSH
24622: LD_VAR 0 3
24626: PPUSH
24627: CALL 47120 0 3
24631: ST_TO_ADDR
// SetTag ( j , 107 ) ;
24632: LD_VAR 0 3
24636: PPUSH
24637: LD_INT 107
24639: PPUSH
24640: CALL_OW 109
// if mc_crates_collector [ i ] >= 5 then
24644: LD_EXP 73
24648: PUSH
24649: LD_VAR 0 2
24653: ARRAY
24654: PUSH
24655: LD_INT 5
24657: GREATEREQUAL
24658: IFFALSE 24662
// break ;
24660: GO 24664
// end ;
24662: GO 24573
24664: POP
24665: POP
// end ; if mc_crates_collector [ i ] and target then
24666: LD_EXP 73
24670: PUSH
24671: LD_VAR 0 2
24675: ARRAY
24676: PUSH
24677: LD_VAR 0 6
24681: AND
24682: IFFALSE 24925
// begin if mc_crates_collector [ i ] < target [ 1 ] then
24684: LD_EXP 73
24688: PUSH
24689: LD_VAR 0 2
24693: ARRAY
24694: PUSH
24695: LD_VAR 0 6
24699: PUSH
24700: LD_INT 1
24702: ARRAY
24703: LESS
24704: IFFALSE 24724
// tmp := mc_crates_collector [ i ] else
24706: LD_ADDR_VAR 0 5
24710: PUSH
24711: LD_EXP 73
24715: PUSH
24716: LD_VAR 0 2
24720: ARRAY
24721: ST_TO_ADDR
24722: GO 24738
// tmp := target [ 1 ] ;
24724: LD_ADDR_VAR 0 5
24728: PUSH
24729: LD_VAR 0 6
24733: PUSH
24734: LD_INT 1
24736: ARRAY
24737: ST_TO_ADDR
// k := 0 ;
24738: LD_ADDR_VAR 0 4
24742: PUSH
24743: LD_INT 0
24745: ST_TO_ADDR
// for j in mc_crates_collector [ i ] do
24746: LD_ADDR_VAR 0 3
24750: PUSH
24751: LD_EXP 73
24755: PUSH
24756: LD_VAR 0 2
24760: ARRAY
24761: PUSH
24762: FOR_IN
24763: IFFALSE 24923
// begin k := k + 1 ;
24765: LD_ADDR_VAR 0 4
24769: PUSH
24770: LD_VAR 0 4
24774: PUSH
24775: LD_INT 1
24777: PLUS
24778: ST_TO_ADDR
// if k > tmp then
24779: LD_VAR 0 4
24783: PUSH
24784: LD_VAR 0 5
24788: GREATER
24789: IFFALSE 24793
// break ;
24791: GO 24923
// if not GetClass ( j ) in [ 2 , 16 ] then
24793: LD_VAR 0 3
24797: PPUSH
24798: CALL_OW 257
24802: PUSH
24803: LD_INT 2
24805: PUSH
24806: LD_INT 16
24808: PUSH
24809: EMPTY
24810: LIST
24811: LIST
24812: IN
24813: NOT
24814: IFFALSE 24867
// begin mc_crates_collector := Replace ( mc_crates_collector , i , mc_crates_collector [ i ] diff j ) ;
24816: LD_ADDR_EXP 73
24820: PUSH
24821: LD_EXP 73
24825: PPUSH
24826: LD_VAR 0 2
24830: PPUSH
24831: LD_EXP 73
24835: PUSH
24836: LD_VAR 0 2
24840: ARRAY
24841: PUSH
24842: LD_VAR 0 3
24846: DIFF
24847: PPUSH
24848: CALL_OW 1
24852: ST_TO_ADDR
// SetTag ( j , 0 ) ;
24853: LD_VAR 0 3
24857: PPUSH
24858: LD_INT 0
24860: PPUSH
24861: CALL_OW 109
// continue ;
24865: GO 24762
// end ; if IsInUnit ( j ) then
24867: LD_VAR 0 3
24871: PPUSH
24872: CALL_OW 310
24876: IFFALSE 24887
// ComExitBuilding ( j ) ;
24878: LD_VAR 0 3
24882: PPUSH
24883: CALL_OW 122
// wait ( 3 ) ;
24887: LD_INT 3
24889: PPUSH
24890: CALL_OW 67
// ComCollect ( j , target [ 2 ] , target [ 3 ] ) ;
24894: LD_VAR 0 3
24898: PPUSH
24899: LD_VAR 0 6
24903: PUSH
24904: LD_INT 2
24906: ARRAY
24907: PPUSH
24908: LD_VAR 0 6
24912: PUSH
24913: LD_INT 3
24915: ARRAY
24916: PPUSH
24917: CALL_OW 117
// end ;
24921: GO 24762
24923: POP
24924: POP
// end ; end else
24925: GO 25506
// begin for j in cargo do
24927: LD_ADDR_VAR 0 3
24931: PUSH
24932: LD_VAR 0 7
24936: PUSH
24937: FOR_IN
24938: IFFALSE 25504
// begin if GetTag ( j ) <> 0 then
24940: LD_VAR 0 3
24944: PPUSH
24945: CALL_OW 110
24949: PUSH
24950: LD_INT 0
24952: NONEQUAL
24953: IFFALSE 24957
// continue ;
24955: GO 24937
// if GetLives ( j ) < 1000 and not IsInArea ( j , mc_parking [ i ] ) then
24957: LD_VAR 0 3
24961: PPUSH
24962: CALL_OW 256
24966: PUSH
24967: LD_INT 1000
24969: LESS
24970: PUSH
24971: LD_VAR 0 3
24975: PPUSH
24976: LD_EXP 80
24980: PUSH
24981: LD_VAR 0 2
24985: ARRAY
24986: PPUSH
24987: CALL_OW 308
24991: NOT
24992: AND
24993: IFFALSE 25015
// ComMoveToArea ( j , mc_parking [ i ] ) ;
24995: LD_VAR 0 3
24999: PPUSH
25000: LD_EXP 80
25004: PUSH
25005: LD_VAR 0 2
25009: ARRAY
25010: PPUSH
25011: CALL_OW 113
// if GetLives ( j ) < 1000 and IsInArea ( j , mc_parking [ i ] ) then
25015: LD_VAR 0 3
25019: PPUSH
25020: CALL_OW 256
25024: PUSH
25025: LD_INT 1000
25027: LESS
25028: PUSH
25029: LD_VAR 0 3
25033: PPUSH
25034: LD_EXP 80
25038: PUSH
25039: LD_VAR 0 2
25043: ARRAY
25044: PPUSH
25045: CALL_OW 308
25049: AND
25050: IFFALSE 25054
// continue ;
25052: GO 24937
// if GetEngine ( j ) = engine_solar and GetFuel ( j ) < 15 then
25054: LD_VAR 0 3
25058: PPUSH
25059: CALL_OW 262
25063: PUSH
25064: LD_INT 2
25066: EQUAL
25067: PUSH
25068: LD_VAR 0 3
25072: PPUSH
25073: CALL_OW 261
25077: PUSH
25078: LD_INT 15
25080: LESS
25081: AND
25082: IFFALSE 25086
// continue ;
25084: GO 24937
// if GetEngine ( j ) = engine_combustion and GetFuel ( j ) < 10 then
25086: LD_VAR 0 3
25090: PPUSH
25091: CALL_OW 262
25095: PUSH
25096: LD_INT 1
25098: EQUAL
25099: PUSH
25100: LD_VAR 0 3
25104: PPUSH
25105: CALL_OW 261
25109: PUSH
25110: LD_INT 10
25112: LESS
25113: AND
25114: IFFALSE 25443
// begin depot := UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) ;
25116: LD_ADDR_VAR 0 8
25120: PUSH
25121: LD_EXP 56
25125: PUSH
25126: LD_VAR 0 2
25130: ARRAY
25131: PPUSH
25132: LD_INT 2
25134: PUSH
25135: LD_INT 30
25137: PUSH
25138: LD_INT 0
25140: PUSH
25141: EMPTY
25142: LIST
25143: LIST
25144: PUSH
25145: LD_INT 30
25147: PUSH
25148: LD_INT 1
25150: PUSH
25151: EMPTY
25152: LIST
25153: LIST
25154: PUSH
25155: EMPTY
25156: LIST
25157: LIST
25158: LIST
25159: PPUSH
25160: CALL_OW 72
25164: ST_TO_ADDR
// if not depot then
25165: LD_VAR 0 8
25169: NOT
25170: IFFALSE 25174
// continue ;
25172: GO 24937
// if GetDistUnits ( j , NearestUnitToUnit ( depot , j ) ) < 6 then
25174: LD_VAR 0 3
25178: PPUSH
25179: LD_VAR 0 8
25183: PPUSH
25184: LD_VAR 0 3
25188: PPUSH
25189: CALL_OW 74
25193: PPUSH
25194: CALL_OW 296
25198: PUSH
25199: LD_INT 6
25201: LESS
25202: IFFALSE 25218
// SetFuel ( j , 100 ) else
25204: LD_VAR 0 3
25208: PPUSH
25209: LD_INT 100
25211: PPUSH
25212: CALL_OW 240
25216: GO 25443
// if GetFuel ( j ) = 0 then
25218: LD_VAR 0 3
25222: PPUSH
25223: CALL_OW 261
25227: PUSH
25228: LD_INT 0
25230: EQUAL
25231: IFFALSE 25443
// begin mc_vehicles := Replace ( mc_vehicles , i , mc_vehicles [ i ] diff j ) ;
25233: LD_ADDR_EXP 75
25237: PUSH
25238: LD_EXP 75
25242: PPUSH
25243: LD_VAR 0 2
25247: PPUSH
25248: LD_EXP 75
25252: PUSH
25253: LD_VAR 0 2
25257: ARRAY
25258: PUSH
25259: LD_VAR 0 3
25263: DIFF
25264: PPUSH
25265: CALL_OW 1
25269: ST_TO_ADDR
// if GetControl ( j ) = control_manual then
25270: LD_VAR 0 3
25274: PPUSH
25275: CALL_OW 263
25279: PUSH
25280: LD_INT 1
25282: EQUAL
25283: IFFALSE 25299
// ComExitVehicle ( IsInUnit ( j ) ) ;
25285: LD_VAR 0 3
25289: PPUSH
25290: CALL_OW 310
25294: PPUSH
25295: CALL_OW 121
// if GetControl ( j ) = control_remote then
25299: LD_VAR 0 3
25303: PPUSH
25304: CALL_OW 263
25308: PUSH
25309: LD_INT 2
25311: EQUAL
25312: IFFALSE 25323
// ComUnlink ( j ) ;
25314: LD_VAR 0 3
25318: PPUSH
25319: CALL_OW 136
// fac := MC_GetBuildings ( i , b_factory ) ;
25323: LD_ADDR_VAR 0 9
25327: PUSH
25328: LD_VAR 0 2
25332: PPUSH
25333: LD_INT 3
25335: PPUSH
25336: CALL 34580 0 2
25340: ST_TO_ADDR
// if fac then
25341: LD_VAR 0 9
25345: IFFALSE 25441
// begin for k in fac do
25347: LD_ADDR_VAR 0 4
25351: PUSH
25352: LD_VAR 0 9
25356: PUSH
25357: FOR_IN
25358: IFFALSE 25439
// begin components := Produce ( fac , GetChassis ( j ) , GetEngine ( j ) , GetControl ( j ) , GetWeapon ( j ) ) ;
25360: LD_ADDR_VAR 0 10
25364: PUSH
25365: LD_VAR 0 9
25369: PPUSH
25370: LD_VAR 0 3
25374: PPUSH
25375: CALL_OW 265
25379: PPUSH
25380: LD_VAR 0 3
25384: PPUSH
25385: CALL_OW 262
25389: PPUSH
25390: LD_VAR 0 3
25394: PPUSH
25395: CALL_OW 263
25399: PPUSH
25400: LD_VAR 0 3
25404: PPUSH
25405: CALL_OW 264
25409: PPUSH
25410: CALL 44652 0 5
25414: ST_TO_ADDR
// if components then
25415: LD_VAR 0 10
25419: IFFALSE 25437
// begin MC_InsertProduceList ( i , components ) ;
25421: LD_VAR 0 2
25425: PPUSH
25426: LD_VAR 0 10
25430: PPUSH
25431: CALL 34125 0 2
// break ;
25435: GO 25439
// end ; end ;
25437: GO 25357
25439: POP
25440: POP
// end ; continue ;
25441: GO 24937
// end ; end ; if GetCargo ( j , mat_cans ) < 100 and not HasTask ( j ) then
25443: LD_VAR 0 3
25447: PPUSH
25448: LD_INT 1
25450: PPUSH
25451: CALL_OW 289
25455: PUSH
25456: LD_INT 100
25458: LESS
25459: PUSH
25460: LD_VAR 0 3
25464: PPUSH
25465: CALL_OW 314
25469: NOT
25470: AND
25471: IFFALSE 25500
// ComCollect ( j , target [ 2 ] , target [ 3 ] ) ;
25473: LD_VAR 0 3
25477: PPUSH
25478: LD_VAR 0 6
25482: PUSH
25483: LD_INT 2
25485: ARRAY
25486: PPUSH
25487: LD_VAR 0 6
25491: PUSH
25492: LD_INT 3
25494: ARRAY
25495: PPUSH
25496: CALL_OW 117
// break ;
25500: GO 25504
// end ;
25502: GO 24937
25504: POP
25505: POP
// end ; end ;
25506: GO 23775
25508: POP
25509: POP
// end ;
25510: LD_VAR 0 1
25514: RET
// export function MC_LinkRemoteControl ( ) ; var i , j , tmp ; begin
25515: LD_INT 0
25517: PPUSH
25518: PPUSH
25519: PPUSH
25520: PPUSH
// if not mc_bases then
25521: LD_EXP 56
25525: NOT
25526: IFFALSE 25530
// exit ;
25528: GO 25691
// for i = 1 to mc_bases do
25530: LD_ADDR_VAR 0 2
25534: PUSH
25535: DOUBLE
25536: LD_INT 1
25538: DEC
25539: ST_TO_ADDR
25540: LD_EXP 56
25544: PUSH
25545: FOR_TO
25546: IFFALSE 25689
// begin tmp := UnitFilter ( mc_vehicles [ i ] union mc_defender [ i ] , [ f_control , control_remote ] ) ;
25548: LD_ADDR_VAR 0 4
25552: PUSH
25553: LD_EXP 75
25557: PUSH
25558: LD_VAR 0 2
25562: ARRAY
25563: PUSH
25564: LD_EXP 78
25568: PUSH
25569: LD_VAR 0 2
25573: ARRAY
25574: UNION
25575: PPUSH
25576: LD_INT 33
25578: PUSH
25579: LD_INT 2
25581: PUSH
25582: EMPTY
25583: LIST
25584: LIST
25585: PPUSH
25586: CALL_OW 72
25590: ST_TO_ADDR
// if tmp then
25591: LD_VAR 0 4
25595: IFFALSE 25687
// for j in tmp do
25597: LD_ADDR_VAR 0 3
25601: PUSH
25602: LD_VAR 0 4
25606: PUSH
25607: FOR_IN
25608: IFFALSE 25685
// if not IsControledBy ( j ) and GetLives ( j ) >= 250 then
25610: LD_VAR 0 3
25614: PPUSH
25615: CALL_OW 312
25619: NOT
25620: PUSH
25621: LD_VAR 0 3
25625: PPUSH
25626: CALL_OW 256
25630: PUSH
25631: LD_INT 250
25633: GREATEREQUAL
25634: AND
25635: IFFALSE 25648
// Connect ( j ) else
25637: LD_VAR 0 3
25641: PPUSH
25642: CALL 50053 0 1
25646: GO 25683
// if GetLives ( j ) < 250 and IsControledBy ( j ) then
25648: LD_VAR 0 3
25652: PPUSH
25653: CALL_OW 256
25657: PUSH
25658: LD_INT 250
25660: LESS
25661: PUSH
25662: LD_VAR 0 3
25666: PPUSH
25667: CALL_OW 312
25671: AND
25672: IFFALSE 25683
// ComUnlink ( j ) ;
25674: LD_VAR 0 3
25678: PPUSH
25679: CALL_OW 136
25683: GO 25607
25685: POP
25686: POP
// end ;
25687: GO 25545
25689: POP
25690: POP
// end ;
25691: LD_VAR 0 1
25695: RET
// export function MC_ProduceVehicle ( ) ; var i , j , tmp , fac ; begin
25696: LD_INT 0
25698: PPUSH
25699: PPUSH
25700: PPUSH
25701: PPUSH
25702: PPUSH
// if not mc_bases then
25703: LD_EXP 56
25707: NOT
25708: IFFALSE 25712
// exit ;
25710: GO 26157
// for i = 1 to mc_bases do
25712: LD_ADDR_VAR 0 2
25716: PUSH
25717: DOUBLE
25718: LD_INT 1
25720: DEC
25721: ST_TO_ADDR
25722: LD_EXP 56
25726: PUSH
25727: FOR_TO
25728: IFFALSE 26155
// begin if not mc_produce [ i ] then
25730: LD_EXP 77
25734: PUSH
25735: LD_VAR 0 2
25739: ARRAY
25740: NOT
25741: IFFALSE 25745
// continue ;
25743: GO 25727
// fac := UnitFilter ( mc_bases [ i ] , [ f_btype , b_factory ] ) ;
25745: LD_ADDR_VAR 0 5
25749: PUSH
25750: LD_EXP 56
25754: PUSH
25755: LD_VAR 0 2
25759: ARRAY
25760: PPUSH
25761: LD_INT 30
25763: PUSH
25764: LD_INT 3
25766: PUSH
25767: EMPTY
25768: LIST
25769: LIST
25770: PPUSH
25771: CALL_OW 72
25775: ST_TO_ADDR
// if not fac then
25776: LD_VAR 0 5
25780: NOT
25781: IFFALSE 25785
// continue ;
25783: GO 25727
// for j in fac do
25785: LD_ADDR_VAR 0 3
25789: PUSH
25790: LD_VAR 0 5
25794: PUSH
25795: FOR_IN
25796: IFFALSE 26151
// begin if BuildingStatus ( j ) <> bs_idle or DangerAtRange ( j , 15 ) [ 4 ] then
25798: LD_VAR 0 3
25802: PPUSH
25803: CALL_OW 461
25807: PUSH
25808: LD_INT 2
25810: NONEQUAL
25811: PUSH
25812: LD_VAR 0 3
25816: PPUSH
25817: LD_INT 15
25819: PPUSH
25820: CALL 49713 0 2
25824: PUSH
25825: LD_INT 4
25827: ARRAY
25828: OR
25829: IFFALSE 25833
// continue ;
25831: GO 25795
// if CanBeConstructed ( j , mc_produce [ i ] [ 1 ] [ 1 ] , mc_produce [ i ] [ 1 ] [ 2 ] , mc_produce [ i ] [ 1 ] [ 3 ] , mc_produce [ i ] [ 1 ] [ 4 ] ) and VehicleCost ( j , [ mc_produce [ i ] [ 1 ] [ 1 ] , mc_produce [ i ] [ 1 ] [ 2 ] , mc_produce [ i ] [ 1 ] [ 3 ] , mc_produce [ i ] [ 1 ] [ 4 ] ] ) then
25833: LD_VAR 0 3
25837: PPUSH
25838: LD_EXP 77
25842: PUSH
25843: LD_VAR 0 2
25847: ARRAY
25848: PUSH
25849: LD_INT 1
25851: ARRAY
25852: PUSH
25853: LD_INT 1
25855: ARRAY
25856: PPUSH
25857: LD_EXP 77
25861: PUSH
25862: LD_VAR 0 2
25866: ARRAY
25867: PUSH
25868: LD_INT 1
25870: ARRAY
25871: PUSH
25872: LD_INT 2
25874: ARRAY
25875: PPUSH
25876: LD_EXP 77
25880: PUSH
25881: LD_VAR 0 2
25885: ARRAY
25886: PUSH
25887: LD_INT 1
25889: ARRAY
25890: PUSH
25891: LD_INT 3
25893: ARRAY
25894: PPUSH
25895: LD_EXP 77
25899: PUSH
25900: LD_VAR 0 2
25904: ARRAY
25905: PUSH
25906: LD_INT 1
25908: ARRAY
25909: PUSH
25910: LD_INT 4
25912: ARRAY
25913: PPUSH
25914: CALL_OW 448
25918: PUSH
25919: LD_VAR 0 3
25923: PPUSH
25924: LD_EXP 77
25928: PUSH
25929: LD_VAR 0 2
25933: ARRAY
25934: PUSH
25935: LD_INT 1
25937: ARRAY
25938: PUSH
25939: LD_INT 1
25941: ARRAY
25942: PUSH
25943: LD_EXP 77
25947: PUSH
25948: LD_VAR 0 2
25952: ARRAY
25953: PUSH
25954: LD_INT 1
25956: ARRAY
25957: PUSH
25958: LD_INT 2
25960: ARRAY
25961: PUSH
25962: LD_EXP 77
25966: PUSH
25967: LD_VAR 0 2
25971: ARRAY
25972: PUSH
25973: LD_INT 1
25975: ARRAY
25976: PUSH
25977: LD_INT 3
25979: ARRAY
25980: PUSH
25981: LD_EXP 77
25985: PUSH
25986: LD_VAR 0 2
25990: ARRAY
25991: PUSH
25992: LD_INT 1
25994: ARRAY
25995: PUSH
25996: LD_INT 4
25998: ARRAY
25999: PUSH
26000: EMPTY
26001: LIST
26002: LIST
26003: LIST
26004: LIST
26005: PPUSH
26006: CALL 53384 0 2
26010: AND
26011: IFFALSE 26149
// begin AddComConstruct ( j , mc_produce [ i ] [ 1 ] [ 1 ] , mc_produce [ i ] [ 1 ] [ 2 ] , mc_produce [ i ] [ 1 ] [ 3 ] , mc_produce [ i ] [ 1 ] [ 4 ] ) ;
26013: LD_VAR 0 3
26017: PPUSH
26018: LD_EXP 77
26022: PUSH
26023: LD_VAR 0 2
26027: ARRAY
26028: PUSH
26029: LD_INT 1
26031: ARRAY
26032: PUSH
26033: LD_INT 1
26035: ARRAY
26036: PPUSH
26037: LD_EXP 77
26041: PUSH
26042: LD_VAR 0 2
26046: ARRAY
26047: PUSH
26048: LD_INT 1
26050: ARRAY
26051: PUSH
26052: LD_INT 2
26054: ARRAY
26055: PPUSH
26056: LD_EXP 77
26060: PUSH
26061: LD_VAR 0 2
26065: ARRAY
26066: PUSH
26067: LD_INT 1
26069: ARRAY
26070: PUSH
26071: LD_INT 3
26073: ARRAY
26074: PPUSH
26075: LD_EXP 77
26079: PUSH
26080: LD_VAR 0 2
26084: ARRAY
26085: PUSH
26086: LD_INT 1
26088: ARRAY
26089: PUSH
26090: LD_INT 4
26092: ARRAY
26093: PPUSH
26094: CALL_OW 185
// tmp := Delete ( mc_produce [ i ] , 1 ) ;
26098: LD_ADDR_VAR 0 4
26102: PUSH
26103: LD_EXP 77
26107: PUSH
26108: LD_VAR 0 2
26112: ARRAY
26113: PPUSH
26114: LD_INT 1
26116: PPUSH
26117: CALL_OW 3
26121: ST_TO_ADDR
// mc_produce := Replace ( mc_produce , i , tmp ) ;
26122: LD_ADDR_EXP 77
26126: PUSH
26127: LD_EXP 77
26131: PPUSH
26132: LD_VAR 0 2
26136: PPUSH
26137: LD_VAR 0 4
26141: PPUSH
26142: CALL_OW 1
26146: ST_TO_ADDR
// break ;
26147: GO 26151
// end ; end ;
26149: GO 25795
26151: POP
26152: POP
// end ;
26153: GO 25727
26155: POP
26156: POP
// end ;
26157: LD_VAR 0 1
26161: RET
// export function MC_SendAttack ( ) ; var i , tmp ; begin
26162: LD_INT 0
26164: PPUSH
26165: PPUSH
26166: PPUSH
// if not mc_bases then
26167: LD_EXP 56
26171: NOT
26172: IFFALSE 26176
// exit ;
26174: GO 26265
// for i = 1 to mc_bases do
26176: LD_ADDR_VAR 0 2
26180: PUSH
26181: DOUBLE
26182: LD_INT 1
26184: DEC
26185: ST_TO_ADDR
26186: LD_EXP 56
26190: PUSH
26191: FOR_TO
26192: IFFALSE 26263
// begin if mc_attack [ i ] then
26194: LD_EXP 76
26198: PUSH
26199: LD_VAR 0 2
26203: ARRAY
26204: IFFALSE 26261
// begin tmp := mc_attack [ i ] [ 1 ] ;
26206: LD_ADDR_VAR 0 3
26210: PUSH
26211: LD_EXP 76
26215: PUSH
26216: LD_VAR 0 2
26220: ARRAY
26221: PUSH
26222: LD_INT 1
26224: ARRAY
26225: ST_TO_ADDR
// mc_attack := Replace ( mc_attack , i , [ ] ) ;
26226: LD_ADDR_EXP 76
26230: PUSH
26231: LD_EXP 76
26235: PPUSH
26236: LD_VAR 0 2
26240: PPUSH
26241: EMPTY
26242: PPUSH
26243: CALL_OW 1
26247: ST_TO_ADDR
// Attack ( tmp ) ;
26248: LD_VAR 0 3
26252: PPUSH
26253: CALL 75597 0 1
// exit ;
26257: POP
26258: POP
26259: GO 26265
// end ; end ;
26261: GO 26191
26263: POP
26264: POP
// end ;
26265: LD_VAR 0 1
26269: RET
// export function MC_Defend ( ) ; var i , j , tmp , t , x , class ; begin
26270: LD_INT 0
26272: PPUSH
26273: PPUSH
26274: PPUSH
26275: PPUSH
26276: PPUSH
26277: PPUSH
26278: PPUSH
// if not mc_bases then
26279: LD_EXP 56
26283: NOT
26284: IFFALSE 26288
// exit ;
26286: GO 26870
// for i = 1 to mc_bases do
26288: LD_ADDR_VAR 0 2
26292: PUSH
26293: DOUBLE
26294: LD_INT 1
26296: DEC
26297: ST_TO_ADDR
26298: LD_EXP 56
26302: PUSH
26303: FOR_TO
26304: IFFALSE 26868
// begin if not mc_bases [ i ] then
26306: LD_EXP 56
26310: PUSH
26311: LD_VAR 0 2
26315: ARRAY
26316: NOT
26317: IFFALSE 26321
// continue ;
26319: GO 26303
// class := AllowSpecClass ( mc_bases [ i ] [ 1 ] ) ;
26321: LD_ADDR_VAR 0 7
26325: PUSH
26326: LD_EXP 56
26330: PUSH
26331: LD_VAR 0 2
26335: ARRAY
26336: PUSH
26337: LD_INT 1
26339: ARRAY
26340: PPUSH
26341: CALL 43956 0 1
26345: ST_TO_ADDR
// mc_scan := Replace ( mc_scan , i , ScanBase ( GetSide ( mc_bases [ i ] [ 1 ] ) , mc_scan_area [ i ] ) ) ;
26346: LD_ADDR_EXP 79
26350: PUSH
26351: LD_EXP 79
26355: PPUSH
26356: LD_VAR 0 2
26360: PPUSH
26361: LD_EXP 56
26365: PUSH
26366: LD_VAR 0 2
26370: ARRAY
26371: PUSH
26372: LD_INT 1
26374: ARRAY
26375: PPUSH
26376: CALL_OW 255
26380: PPUSH
26381: LD_EXP 81
26385: PUSH
26386: LD_VAR 0 2
26390: ARRAY
26391: PPUSH
26392: CALL 41874 0 2
26396: PPUSH
26397: CALL_OW 1
26401: ST_TO_ADDR
// if not mc_scan [ i ] then
26402: LD_EXP 79
26406: PUSH
26407: LD_VAR 0 2
26411: ARRAY
26412: NOT
26413: IFFALSE 26568
// begin tmp := UnitFilter ( mc_bases [ i ] , [ f_or , [ f_class , 5 ] , [ f_class , 8 ] , [ f_class , 9 ] ] ) ;
26415: LD_ADDR_VAR 0 4
26419: PUSH
26420: LD_EXP 56
26424: PUSH
26425: LD_VAR 0 2
26429: ARRAY
26430: PPUSH
26431: LD_INT 2
26433: PUSH
26434: LD_INT 25
26436: PUSH
26437: LD_INT 5
26439: PUSH
26440: EMPTY
26441: LIST
26442: LIST
26443: PUSH
26444: LD_INT 25
26446: PUSH
26447: LD_INT 8
26449: PUSH
26450: EMPTY
26451: LIST
26452: LIST
26453: PUSH
26454: LD_INT 25
26456: PUSH
26457: LD_INT 9
26459: PUSH
26460: EMPTY
26461: LIST
26462: LIST
26463: PUSH
26464: EMPTY
26465: LIST
26466: LIST
26467: LIST
26468: LIST
26469: PPUSH
26470: CALL_OW 72
26474: ST_TO_ADDR
// if not tmp then
26475: LD_VAR 0 4
26479: NOT
26480: IFFALSE 26484
// continue ;
26482: GO 26303
// for j in tmp do
26484: LD_ADDR_VAR 0 3
26488: PUSH
26489: LD_VAR 0 4
26493: PUSH
26494: FOR_IN
26495: IFFALSE 26566
// if GetBType ( IsInUnit ( j ) ) = b_barracks and GetClass ( j ) = 1 and not MineOfUnit ( j ) and class then
26497: LD_VAR 0 3
26501: PPUSH
26502: CALL_OW 310
26506: PPUSH
26507: CALL_OW 266
26511: PUSH
26512: LD_INT 5
26514: EQUAL
26515: PUSH
26516: LD_VAR 0 3
26520: PPUSH
26521: CALL_OW 257
26525: PUSH
26526: LD_INT 1
26528: EQUAL
26529: AND
26530: PUSH
26531: LD_VAR 0 3
26535: PPUSH
26536: CALL_OW 459
26540: NOT
26541: AND
26542: PUSH
26543: LD_VAR 0 7
26547: AND
26548: IFFALSE 26564
// ComChangeProfession ( j , class ) ;
26550: LD_VAR 0 3
26554: PPUSH
26555: LD_VAR 0 7
26559: PPUSH
26560: CALL_OW 123
26564: GO 26494
26566: POP
26567: POP
// end ; if mc_scan [ i ] and not mc_defender [ i ] and not UnitFilter ( mc_bases [ i ] , [ f_btype , b_bunker ] ) and not UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_armoury ] , [ f_btype , b_barracks ] ] ) then
26568: LD_EXP 79
26572: PUSH
26573: LD_VAR 0 2
26577: ARRAY
26578: PUSH
26579: LD_EXP 78
26583: PUSH
26584: LD_VAR 0 2
26588: ARRAY
26589: NOT
26590: AND
26591: PUSH
26592: LD_EXP 56
26596: PUSH
26597: LD_VAR 0 2
26601: ARRAY
26602: PPUSH
26603: LD_INT 30
26605: PUSH
26606: LD_INT 32
26608: PUSH
26609: EMPTY
26610: LIST
26611: LIST
26612: PPUSH
26613: CALL_OW 72
26617: NOT
26618: AND
26619: PUSH
26620: LD_EXP 56
26624: PUSH
26625: LD_VAR 0 2
26629: ARRAY
26630: PPUSH
26631: LD_INT 2
26633: PUSH
26634: LD_INT 30
26636: PUSH
26637: LD_INT 4
26639: PUSH
26640: EMPTY
26641: LIST
26642: LIST
26643: PUSH
26644: LD_INT 30
26646: PUSH
26647: LD_INT 5
26649: PUSH
26650: EMPTY
26651: LIST
26652: LIST
26653: PUSH
26654: EMPTY
26655: LIST
26656: LIST
26657: LIST
26658: PPUSH
26659: CALL_OW 72
26663: NOT
26664: AND
26665: IFFALSE 26797
// begin tmp := UnitFilter ( mc_bases [ i ] , [ f_or , [ f_class , 1 ] , [ f_class , 5 ] , [ f_class , 8 ] , [ f_class , 9 ] ] ) ;
26667: LD_ADDR_VAR 0 4
26671: PUSH
26672: LD_EXP 56
26676: PUSH
26677: LD_VAR 0 2
26681: ARRAY
26682: PPUSH
26683: LD_INT 2
26685: PUSH
26686: LD_INT 25
26688: PUSH
26689: LD_INT 1
26691: PUSH
26692: EMPTY
26693: LIST
26694: LIST
26695: PUSH
26696: LD_INT 25
26698: PUSH
26699: LD_INT 5
26701: PUSH
26702: EMPTY
26703: LIST
26704: LIST
26705: PUSH
26706: LD_INT 25
26708: PUSH
26709: LD_INT 8
26711: PUSH
26712: EMPTY
26713: LIST
26714: LIST
26715: PUSH
26716: LD_INT 25
26718: PUSH
26719: LD_INT 9
26721: PUSH
26722: EMPTY
26723: LIST
26724: LIST
26725: PUSH
26726: EMPTY
26727: LIST
26728: LIST
26729: LIST
26730: LIST
26731: LIST
26732: PPUSH
26733: CALL_OW 72
26737: ST_TO_ADDR
// tmp := tmp diff FilterByTag ( tmp , 18 ) ;
26738: LD_ADDR_VAR 0 4
26742: PUSH
26743: LD_VAR 0 4
26747: PUSH
26748: LD_VAR 0 4
26752: PPUSH
26753: LD_INT 18
26755: PPUSH
26756: CALL 80380 0 2
26760: DIFF
26761: ST_TO_ADDR
// if tmp then
26762: LD_VAR 0 4
26766: IFFALSE 26797
// begin BasicDefend ( i , tmp , mc_scan_area [ i ] ) ;
26768: LD_VAR 0 2
26772: PPUSH
26773: LD_VAR 0 4
26777: PPUSH
26778: LD_EXP 81
26782: PUSH
26783: LD_VAR 0 2
26787: ARRAY
26788: PPUSH
26789: CALL 41909 0 3
// exit ;
26793: POP
26794: POP
26795: GO 26870
// end ; end ; if mc_scan [ i ] and mc_defender [ i ] then
26797: LD_EXP 79
26801: PUSH
26802: LD_VAR 0 2
26806: ARRAY
26807: PUSH
26808: LD_EXP 78
26812: PUSH
26813: LD_VAR 0 2
26817: ARRAY
26818: AND
26819: IFFALSE 26866
// begin tmp := mc_defender [ i ] ;
26821: LD_ADDR_VAR 0 4
26825: PUSH
26826: LD_EXP 78
26830: PUSH
26831: LD_VAR 0 2
26835: ARRAY
26836: ST_TO_ADDR
// Defend ( i , tmp , mc_scan [ i ] ) ;
26837: LD_VAR 0 2
26841: PPUSH
26842: LD_VAR 0 4
26846: PPUSH
26847: LD_EXP 79
26851: PUSH
26852: LD_VAR 0 2
26856: ARRAY
26857: PPUSH
26858: CALL 42407 0 3
// exit ;
26862: POP
26863: POP
26864: GO 26870
// end ; end ;
26866: GO 26303
26868: POP
26869: POP
// end ;
26870: LD_VAR 0 1
26874: RET
// export function MC_Research ( ) ; var i , j , side , t , tmp , x , sci , tmp2 , researching , idle_lab ; begin
26875: LD_INT 0
26877: PPUSH
26878: PPUSH
26879: PPUSH
26880: PPUSH
26881: PPUSH
26882: PPUSH
26883: PPUSH
26884: PPUSH
26885: PPUSH
26886: PPUSH
26887: PPUSH
// if not mc_bases then
26888: LD_EXP 56
26892: NOT
26893: IFFALSE 26897
// exit ;
26895: GO 27984
// for i = 1 to mc_bases do
26897: LD_ADDR_VAR 0 2
26901: PUSH
26902: DOUBLE
26903: LD_INT 1
26905: DEC
26906: ST_TO_ADDR
26907: LD_EXP 56
26911: PUSH
26912: FOR_TO
26913: IFFALSE 27982
// begin tmp := mc_lab [ i ] ;
26915: LD_ADDR_VAR 0 6
26919: PUSH
26920: LD_EXP 89
26924: PUSH
26925: LD_VAR 0 2
26929: ARRAY
26930: ST_TO_ADDR
// if not tmp then
26931: LD_VAR 0 6
26935: NOT
26936: IFFALSE 26940
// continue ;
26938: GO 26912
// idle_lab := 0 ;
26940: LD_ADDR_VAR 0 11
26944: PUSH
26945: LD_INT 0
26947: ST_TO_ADDR
// for j in tmp do
26948: LD_ADDR_VAR 0 3
26952: PUSH
26953: LD_VAR 0 6
26957: PUSH
26958: FOR_IN
26959: IFFALSE 27978
// begin researching := false ;
26961: LD_ADDR_VAR 0 10
26965: PUSH
26966: LD_INT 0
26968: ST_TO_ADDR
// side := GetSide ( j ) ;
26969: LD_ADDR_VAR 0 4
26973: PUSH
26974: LD_VAR 0 3
26978: PPUSH
26979: CALL_OW 255
26983: ST_TO_ADDR
// if not mc_tech [ side ] then
26984: LD_EXP 83
26988: PUSH
26989: LD_VAR 0 4
26993: ARRAY
26994: NOT
26995: IFFALSE 26999
// continue ;
26997: GO 26958
// if BuildingStatus ( j ) = bs_idle then
26999: LD_VAR 0 3
27003: PPUSH
27004: CALL_OW 461
27008: PUSH
27009: LD_INT 2
27011: EQUAL
27012: IFFALSE 27200
// begin if idle_lab and UnitsInside ( j ) < 6 then
27014: LD_VAR 0 11
27018: PUSH
27019: LD_VAR 0 3
27023: PPUSH
27024: CALL_OW 313
27028: PUSH
27029: LD_INT 6
27031: LESS
27032: AND
27033: IFFALSE 27104
// begin tmp2 := UnitsInside ( idle_lab ) ;
27035: LD_ADDR_VAR 0 9
27039: PUSH
27040: LD_VAR 0 11
27044: PPUSH
27045: CALL_OW 313
27049: ST_TO_ADDR
// if tmp2 then
27050: LD_VAR 0 9
27054: IFFALSE 27096
// for x in tmp2 do
27056: LD_ADDR_VAR 0 7
27060: PUSH
27061: LD_VAR 0 9
27065: PUSH
27066: FOR_IN
27067: IFFALSE 27094
// begin ComExitBuilding ( x ) ;
27069: LD_VAR 0 7
27073: PPUSH
27074: CALL_OW 122
// AddComEnterUnit ( x , j ) ;
27078: LD_VAR 0 7
27082: PPUSH
27083: LD_VAR 0 3
27087: PPUSH
27088: CALL_OW 180
// end ;
27092: GO 27066
27094: POP
27095: POP
// idle_lab := 0 ;
27096: LD_ADDR_VAR 0 11
27100: PUSH
27101: LD_INT 0
27103: ST_TO_ADDR
// end ; for t in mc_tech [ side ] do
27104: LD_ADDR_VAR 0 5
27108: PUSH
27109: LD_EXP 83
27113: PUSH
27114: LD_VAR 0 4
27118: ARRAY
27119: PUSH
27120: FOR_IN
27121: IFFALSE 27181
// if CanBeResearched ( j , t ) and TechCanBeResearch ( side , t ) then
27123: LD_VAR 0 3
27127: PPUSH
27128: LD_VAR 0 5
27132: PPUSH
27133: CALL_OW 430
27137: PUSH
27138: LD_VAR 0 4
27142: PPUSH
27143: LD_VAR 0 5
27147: PPUSH
27148: CALL 40979 0 2
27152: AND
27153: IFFALSE 27179
// begin researching := true ;
27155: LD_ADDR_VAR 0 10
27159: PUSH
27160: LD_INT 1
27162: ST_TO_ADDR
// ComResearch ( j , t ) ;
27163: LD_VAR 0 3
27167: PPUSH
27168: LD_VAR 0 5
27172: PPUSH
27173: CALL_OW 124
// break ;
27177: GO 27181
// end ;
27179: GO 27120
27181: POP
27182: POP
// if not researching then
27183: LD_VAR 0 10
27187: NOT
27188: IFFALSE 27200
// idle_lab := j ;
27190: LD_ADDR_VAR 0 11
27194: PUSH
27195: LD_VAR 0 3
27199: ST_TO_ADDR
// end ; if BuildingStatus ( j ) = bs_need_ape then
27200: LD_VAR 0 3
27204: PPUSH
27205: CALL_OW 461
27209: PUSH
27210: LD_INT 10
27212: EQUAL
27213: IFFALSE 27801
// begin if not mc_ape [ i ] and not mc_ape_in_lab [ i ] and mc_tech [ side ] > 1 then
27215: LD_EXP 85
27219: PUSH
27220: LD_VAR 0 2
27224: ARRAY
27225: NOT
27226: PUSH
27227: LD_EXP 86
27231: PUSH
27232: LD_VAR 0 2
27236: ARRAY
27237: NOT
27238: AND
27239: PUSH
27240: LD_EXP 83
27244: PUSH
27245: LD_VAR 0 4
27249: ARRAY
27250: PUSH
27251: LD_INT 1
27253: GREATER
27254: AND
27255: IFFALSE 27386
// begin ComCancel ( j ) ;
27257: LD_VAR 0 3
27261: PPUSH
27262: CALL_OW 127
// mc_tech := Replace ( mc_tech , side , Reindex ( mc_tech [ side ] , mc_tech [ side ] - 1 , mc_tech [ side ] , false ) ) ;
27266: LD_ADDR_EXP 83
27270: PUSH
27271: LD_EXP 83
27275: PPUSH
27276: LD_VAR 0 4
27280: PPUSH
27281: LD_EXP 83
27285: PUSH
27286: LD_VAR 0 4
27290: ARRAY
27291: PPUSH
27292: LD_EXP 83
27296: PUSH
27297: LD_VAR 0 4
27301: ARRAY
27302: PUSH
27303: LD_INT 1
27305: MINUS
27306: PPUSH
27307: LD_EXP 83
27311: PUSH
27312: LD_VAR 0 4
27316: ARRAY
27317: PPUSH
27318: LD_INT 0
27320: PPUSH
27321: CALL 46538 0 4
27325: PPUSH
27326: CALL_OW 1
27330: ST_TO_ADDR
// mc_tech := Replace ( mc_tech , side , Reindex ( mc_tech [ side ] , mc_tech [ side ] , 1 , false ) ) ;
27331: LD_ADDR_EXP 83
27335: PUSH
27336: LD_EXP 83
27340: PPUSH
27341: LD_VAR 0 4
27345: PPUSH
27346: LD_EXP 83
27350: PUSH
27351: LD_VAR 0 4
27355: ARRAY
27356: PPUSH
27357: LD_EXP 83
27361: PUSH
27362: LD_VAR 0 4
27366: ARRAY
27367: PPUSH
27368: LD_INT 1
27370: PPUSH
27371: LD_INT 0
27373: PPUSH
27374: CALL 46538 0 4
27378: PPUSH
27379: CALL_OW 1
27383: ST_TO_ADDR
// continue ;
27384: GO 26958
// end ; if mc_ape [ i ] and not mc_ape_in_lab [ i ] then
27386: LD_EXP 85
27390: PUSH
27391: LD_VAR 0 2
27395: ARRAY
27396: PUSH
27397: LD_EXP 86
27401: PUSH
27402: LD_VAR 0 2
27406: ARRAY
27407: NOT
27408: AND
27409: IFFALSE 27536
// begin mc_ape_in_lab := ReplaceIn ( mc_ape_in_lab , [ i , mc_ape_in_lab [ i ] + 1 ] , mc_ape [ i ] [ 1 ] ) ;
27411: LD_ADDR_EXP 86
27415: PUSH
27416: LD_EXP 86
27420: PPUSH
27421: LD_VAR 0 2
27425: PUSH
27426: LD_EXP 86
27430: PUSH
27431: LD_VAR 0 2
27435: ARRAY
27436: PUSH
27437: LD_INT 1
27439: PLUS
27440: PUSH
27441: EMPTY
27442: LIST
27443: LIST
27444: PPUSH
27445: LD_EXP 85
27449: PUSH
27450: LD_VAR 0 2
27454: ARRAY
27455: PUSH
27456: LD_INT 1
27458: ARRAY
27459: PPUSH
27460: CALL 47120 0 3
27464: ST_TO_ADDR
// SetTag ( mc_ape [ i ] [ 1 ] , 112 ) ;
27465: LD_EXP 85
27469: PUSH
27470: LD_VAR 0 2
27474: ARRAY
27475: PUSH
27476: LD_INT 1
27478: ARRAY
27479: PPUSH
27480: LD_INT 112
27482: PPUSH
27483: CALL_OW 109
// tmp2 := Delete ( mc_ape [ i ] , 1 ) ;
27487: LD_ADDR_VAR 0 9
27491: PUSH
27492: LD_EXP 85
27496: PUSH
27497: LD_VAR 0 2
27501: ARRAY
27502: PPUSH
27503: LD_INT 1
27505: PPUSH
27506: CALL_OW 3
27510: ST_TO_ADDR
// mc_ape := Replace ( mc_ape , i , tmp2 ) ;
27511: LD_ADDR_EXP 85
27515: PUSH
27516: LD_EXP 85
27520: PPUSH
27521: LD_VAR 0 2
27525: PPUSH
27526: LD_VAR 0 9
27530: PPUSH
27531: CALL_OW 1
27535: ST_TO_ADDR
// end ; if mc_ape [ i ] and mc_ape_in_lab [ i ] and not IsInUnit ( mc_ape_in_lab [ i ] [ 1 ] ) and UnitsInside ( j ) = 6 then
27536: LD_EXP 85
27540: PUSH
27541: LD_VAR 0 2
27545: ARRAY
27546: PUSH
27547: LD_EXP 86
27551: PUSH
27552: LD_VAR 0 2
27556: ARRAY
27557: AND
27558: PUSH
27559: LD_EXP 86
27563: PUSH
27564: LD_VAR 0 2
27568: ARRAY
27569: PUSH
27570: LD_INT 1
27572: ARRAY
27573: PPUSH
27574: CALL_OW 310
27578: NOT
27579: AND
27580: PUSH
27581: LD_VAR 0 3
27585: PPUSH
27586: CALL_OW 313
27590: PUSH
27591: LD_INT 6
27593: EQUAL
27594: AND
27595: IFFALSE 27651
// begin tmp2 := UnitsInside ( j ) ;
27597: LD_ADDR_VAR 0 9
27601: PUSH
27602: LD_VAR 0 3
27606: PPUSH
27607: CALL_OW 313
27611: ST_TO_ADDR
// if tmp2 = 6 then
27612: LD_VAR 0 9
27616: PUSH
27617: LD_INT 6
27619: EQUAL
27620: IFFALSE 27651
// begin SetTag ( tmp2 [ 1 ] , 112 ) ;
27622: LD_VAR 0 9
27626: PUSH
27627: LD_INT 1
27629: ARRAY
27630: PPUSH
27631: LD_INT 112
27633: PPUSH
27634: CALL_OW 109
// ComExitBuilding ( tmp2 [ 1 ] ) ;
27638: LD_VAR 0 9
27642: PUSH
27643: LD_INT 1
27645: ARRAY
27646: PPUSH
27647: CALL_OW 122
// end ; end ; if mc_ape_in_lab [ i ] and not HasTask ( mc_ape_in_lab [ i ] [ 1 ] ) and not IsInUnit ( mc_ape_in_lab [ i ] [ 1 ] ) then
27651: LD_EXP 86
27655: PUSH
27656: LD_VAR 0 2
27660: ARRAY
27661: PUSH
27662: LD_EXP 86
27666: PUSH
27667: LD_VAR 0 2
27671: ARRAY
27672: PUSH
27673: LD_INT 1
27675: ARRAY
27676: PPUSH
27677: CALL_OW 314
27681: NOT
27682: AND
27683: PUSH
27684: LD_EXP 86
27688: PUSH
27689: LD_VAR 0 2
27693: ARRAY
27694: PUSH
27695: LD_INT 1
27697: ARRAY
27698: PPUSH
27699: CALL_OW 310
27703: NOT
27704: AND
27705: IFFALSE 27731
// ComEnterUnit ( mc_ape_in_lab [ i ] [ 1 ] , j ) ;
27707: LD_EXP 86
27711: PUSH
27712: LD_VAR 0 2
27716: ARRAY
27717: PUSH
27718: LD_INT 1
27720: ARRAY
27721: PPUSH
27722: LD_VAR 0 3
27726: PPUSH
27727: CALL_OW 120
// if IsInUnit ( mc_ape_in_lab [ i ] [ 1 ] ) and BuildingStatus ( IsInUnit ( mc_ape_in_lab [ i ] [ 1 ] ) ) <> bs_working then
27731: LD_EXP 86
27735: PUSH
27736: LD_VAR 0 2
27740: ARRAY
27741: PUSH
27742: LD_INT 1
27744: ARRAY
27745: PPUSH
27746: CALL_OW 310
27750: PUSH
27751: LD_EXP 86
27755: PUSH
27756: LD_VAR 0 2
27760: ARRAY
27761: PUSH
27762: LD_INT 1
27764: ARRAY
27765: PPUSH
27766: CALL_OW 310
27770: PPUSH
27771: CALL_OW 461
27775: PUSH
27776: LD_INT 3
27778: NONEQUAL
27779: AND
27780: IFFALSE 27801
// ComExitBuilding ( mc_ape_in_lab [ i ] [ 1 ] ) ;
27782: LD_EXP 86
27786: PUSH
27787: LD_VAR 0 2
27791: ARRAY
27792: PUSH
27793: LD_INT 1
27795: ARRAY
27796: PPUSH
27797: CALL_OW 122
// end ; if BuildingStatus ( j ) = bs_need_people and tmp > 1 then
27801: LD_VAR 0 3
27805: PPUSH
27806: CALL_OW 461
27810: PUSH
27811: LD_INT 6
27813: EQUAL
27814: PUSH
27815: LD_VAR 0 6
27819: PUSH
27820: LD_INT 1
27822: GREATER
27823: AND
27824: IFFALSE 27976
// begin sci := [ ] ;
27826: LD_ADDR_VAR 0 8
27830: PUSH
27831: EMPTY
27832: ST_TO_ADDR
// for x in ( tmp diff j ) do
27833: LD_ADDR_VAR 0 7
27837: PUSH
27838: LD_VAR 0 6
27842: PUSH
27843: LD_VAR 0 3
27847: DIFF
27848: PUSH
27849: FOR_IN
27850: IFFALSE 27902
// begin if sci = 6 then
27852: LD_VAR 0 8
27856: PUSH
27857: LD_INT 6
27859: EQUAL
27860: IFFALSE 27864
// break ;
27862: GO 27902
// if BuildingStatus ( x ) = bs_idle then
27864: LD_VAR 0 7
27868: PPUSH
27869: CALL_OW 461
27873: PUSH
27874: LD_INT 2
27876: EQUAL
27877: IFFALSE 27900
// sci := sci ^ UnitsInside ( x ) ;
27879: LD_ADDR_VAR 0 8
27883: PUSH
27884: LD_VAR 0 8
27888: PUSH
27889: LD_VAR 0 7
27893: PPUSH
27894: CALL_OW 313
27898: ADD
27899: ST_TO_ADDR
// end ;
27900: GO 27849
27902: POP
27903: POP
// if not sci then
27904: LD_VAR 0 8
27908: NOT
27909: IFFALSE 27913
// continue ;
27911: GO 26958
// for x in sci do
27913: LD_ADDR_VAR 0 7
27917: PUSH
27918: LD_VAR 0 8
27922: PUSH
27923: FOR_IN
27924: IFFALSE 27974
// if IsInUnit ( x ) and not HasTask ( x ) then
27926: LD_VAR 0 7
27930: PPUSH
27931: CALL_OW 310
27935: PUSH
27936: LD_VAR 0 7
27940: PPUSH
27941: CALL_OW 314
27945: NOT
27946: AND
27947: IFFALSE 27972
// begin ComExitBuilding ( x ) ;
27949: LD_VAR 0 7
27953: PPUSH
27954: CALL_OW 122
// AddComEnterUnit ( x , j ) ;
27958: LD_VAR 0 7
27962: PPUSH
27963: LD_VAR 0 3
27967: PPUSH
27968: CALL_OW 180
// end ;
27972: GO 27923
27974: POP
27975: POP
// end ; end ;
27976: GO 26958
27978: POP
27979: POP
// end ;
27980: GO 26912
27982: POP
27983: POP
// end ;
27984: LD_VAR 0 1
27988: RET
// export function MC_MinesTrigger ( ) ; var i ; begin
27989: LD_INT 0
27991: PPUSH
27992: PPUSH
// if not mc_bases then
27993: LD_EXP 56
27997: NOT
27998: IFFALSE 28002
// exit ;
28000: GO 28083
// for i = 1 to mc_bases do
28002: LD_ADDR_VAR 0 2
28006: PUSH
28007: DOUBLE
28008: LD_INT 1
28010: DEC
28011: ST_TO_ADDR
28012: LD_EXP 56
28016: PUSH
28017: FOR_TO
28018: IFFALSE 28081
// if mc_mines [ i ] and mc_miners [ i ] then
28020: LD_EXP 69
28024: PUSH
28025: LD_VAR 0 2
28029: ARRAY
28030: PUSH
28031: LD_EXP 70
28035: PUSH
28036: LD_VAR 0 2
28040: ARRAY
28041: AND
28042: IFFALSE 28079
// DetonateMines ( GetSide ( mc_miners [ i ] [ 1 ] ) , mc_mines [ i ] ) ;
28044: LD_EXP 70
28048: PUSH
28049: LD_VAR 0 2
28053: ARRAY
28054: PUSH
28055: LD_INT 1
28057: ARRAY
28058: PPUSH
28059: CALL_OW 255
28063: PPUSH
28064: LD_EXP 69
28068: PUSH
28069: LD_VAR 0 2
28073: ARRAY
28074: PPUSH
28075: CALL 44109 0 2
28079: GO 28017
28081: POP
28082: POP
// end ;
28083: LD_VAR 0 1
28087: RET
// export function MC_RepairVehicle ( ) ; var i , j , k , side , fac , vehs , tmp ; begin
28088: LD_INT 0
28090: PPUSH
28091: PPUSH
28092: PPUSH
28093: PPUSH
28094: PPUSH
28095: PPUSH
28096: PPUSH
28097: PPUSH
// if not mc_bases or not mc_parking then
28098: LD_EXP 56
28102: NOT
28103: PUSH
28104: LD_EXP 80
28108: NOT
28109: OR
28110: IFFALSE 28114
// exit ;
28112: GO 28813
// for i = 1 to mc_bases do
28114: LD_ADDR_VAR 0 2
28118: PUSH
28119: DOUBLE
28120: LD_INT 1
28122: DEC
28123: ST_TO_ADDR
28124: LD_EXP 56
28128: PUSH
28129: FOR_TO
28130: IFFALSE 28811
// begin if not mc_bases [ i ] or not mc_parking [ i ] then
28132: LD_EXP 56
28136: PUSH
28137: LD_VAR 0 2
28141: ARRAY
28142: NOT
28143: PUSH
28144: LD_EXP 80
28148: PUSH
28149: LD_VAR 0 2
28153: ARRAY
28154: NOT
28155: OR
28156: IFFALSE 28160
// continue ;
28158: GO 28129
// side := GetSide ( mc_bases [ i ] [ 1 ] ) ;
28160: LD_ADDR_VAR 0 5
28164: PUSH
28165: LD_EXP 56
28169: PUSH
28170: LD_VAR 0 2
28174: ARRAY
28175: PUSH
28176: LD_INT 1
28178: ARRAY
28179: PPUSH
28180: CALL_OW 255
28184: ST_TO_ADDR
// fac := UnitFilter ( mc_bases [ i ] , [ f_btype , b_factory ] ) ;
28185: LD_ADDR_VAR 0 6
28189: PUSH
28190: LD_EXP 56
28194: PUSH
28195: LD_VAR 0 2
28199: ARRAY
28200: PPUSH
28201: LD_INT 30
28203: PUSH
28204: LD_INT 3
28206: PUSH
28207: EMPTY
28208: LIST
28209: LIST
28210: PPUSH
28211: CALL_OW 72
28215: ST_TO_ADDR
// if not fac then
28216: LD_VAR 0 6
28220: NOT
28221: IFFALSE 28272
// fac := UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) ;
28223: LD_ADDR_VAR 0 6
28227: PUSH
28228: LD_EXP 56
28232: PUSH
28233: LD_VAR 0 2
28237: ARRAY
28238: PPUSH
28239: LD_INT 2
28241: PUSH
28242: LD_INT 30
28244: PUSH
28245: LD_INT 0
28247: PUSH
28248: EMPTY
28249: LIST
28250: LIST
28251: PUSH
28252: LD_INT 30
28254: PUSH
28255: LD_INT 1
28257: PUSH
28258: EMPTY
28259: LIST
28260: LIST
28261: PUSH
28262: EMPTY
28263: LIST
28264: LIST
28265: LIST
28266: PPUSH
28267: CALL_OW 72
28271: ST_TO_ADDR
// if not fac then
28272: LD_VAR 0 6
28276: NOT
28277: IFFALSE 28281
// continue ;
28279: GO 28129
// vehs := FilterUnitsInArea ( mc_parking [ i ] , [ [ f_side , side ] , [ f_type , unit_vehicle ] , [ f_not , [ f_lives , 1000 ] ] ] ) ;
28281: LD_ADDR_VAR 0 7
28285: PUSH
28286: LD_EXP 80
28290: PUSH
28291: LD_VAR 0 2
28295: ARRAY
28296: PPUSH
28297: LD_INT 22
28299: PUSH
28300: LD_VAR 0 5
28304: PUSH
28305: EMPTY
28306: LIST
28307: LIST
28308: PUSH
28309: LD_INT 21
28311: PUSH
28312: LD_INT 2
28314: PUSH
28315: EMPTY
28316: LIST
28317: LIST
28318: PUSH
28319: LD_INT 3
28321: PUSH
28322: LD_INT 24
28324: PUSH
28325: LD_INT 1000
28327: PUSH
28328: EMPTY
28329: LIST
28330: LIST
28331: PUSH
28332: EMPTY
28333: LIST
28334: LIST
28335: PUSH
28336: EMPTY
28337: LIST
28338: LIST
28339: LIST
28340: PPUSH
28341: CALL_OW 70
28345: ST_TO_ADDR
// for j in fac do
28346: LD_ADDR_VAR 0 3
28350: PUSH
28351: LD_VAR 0 6
28355: PUSH
28356: FOR_IN
28357: IFFALSE 28438
// vehs := vehs union FilterAllUnits ( [ [ f_side , side ] , [ f_dist , j , 15 ] , [ f_type , unit_vehicle ] , [ f_not , [ f_lives , 1000 ] ] ] ) ;
28359: LD_ADDR_VAR 0 7
28363: PUSH
28364: LD_VAR 0 7
28368: PUSH
28369: LD_INT 22
28371: PUSH
28372: LD_VAR 0 5
28376: PUSH
28377: EMPTY
28378: LIST
28379: LIST
28380: PUSH
28381: LD_INT 91
28383: PUSH
28384: LD_VAR 0 3
28388: PUSH
28389: LD_INT 15
28391: PUSH
28392: EMPTY
28393: LIST
28394: LIST
28395: LIST
28396: PUSH
28397: LD_INT 21
28399: PUSH
28400: LD_INT 2
28402: PUSH
28403: EMPTY
28404: LIST
28405: LIST
28406: PUSH
28407: LD_INT 3
28409: PUSH
28410: LD_INT 24
28412: PUSH
28413: LD_INT 1000
28415: PUSH
28416: EMPTY
28417: LIST
28418: LIST
28419: PUSH
28420: EMPTY
28421: LIST
28422: LIST
28423: PUSH
28424: EMPTY
28425: LIST
28426: LIST
28427: LIST
28428: LIST
28429: PPUSH
28430: CALL_OW 69
28434: UNION
28435: ST_TO_ADDR
28436: GO 28356
28438: POP
28439: POP
// if not vehs then
28440: LD_VAR 0 7
28444: NOT
28445: IFFALSE 28471
// begin mc_repair_vehicle := Replace ( mc_repair_vehicle , i , [ ] ) ;
28447: LD_ADDR_EXP 68
28451: PUSH
28452: LD_EXP 68
28456: PPUSH
28457: LD_VAR 0 2
28461: PPUSH
28462: EMPTY
28463: PPUSH
28464: CALL_OW 1
28468: ST_TO_ADDR
// continue ;
28469: GO 28129
// end ; tmp := UnitFilter ( mc_bases [ i ] , [ f_btype , b_factory ] ) ;
28471: LD_ADDR_VAR 0 8
28475: PUSH
28476: LD_EXP 56
28480: PUSH
28481: LD_VAR 0 2
28485: ARRAY
28486: PPUSH
28487: LD_INT 30
28489: PUSH
28490: LD_INT 3
28492: PUSH
28493: EMPTY
28494: LIST
28495: LIST
28496: PPUSH
28497: CALL_OW 72
28501: ST_TO_ADDR
// if tmp then
28502: LD_VAR 0 8
28506: IFFALSE 28609
// begin for j in tmp do
28508: LD_ADDR_VAR 0 3
28512: PUSH
28513: LD_VAR 0 8
28517: PUSH
28518: FOR_IN
28519: IFFALSE 28607
// for k in UnitsInside ( j ) do
28521: LD_ADDR_VAR 0 4
28525: PUSH
28526: LD_VAR 0 3
28530: PPUSH
28531: CALL_OW 313
28535: PUSH
28536: FOR_IN
28537: IFFALSE 28603
// if k then
28539: LD_VAR 0 4
28543: IFFALSE 28601
// if not k in mc_repair_vehicle [ i ] then
28545: LD_VAR 0 4
28549: PUSH
28550: LD_EXP 68
28554: PUSH
28555: LD_VAR 0 2
28559: ARRAY
28560: IN
28561: NOT
28562: IFFALSE 28601
// mc_repair_vehicle := Replace ( mc_repair_vehicle , i , mc_repair_vehicle [ i ] union k ) ;
28564: LD_ADDR_EXP 68
28568: PUSH
28569: LD_EXP 68
28573: PPUSH
28574: LD_VAR 0 2
28578: PPUSH
28579: LD_EXP 68
28583: PUSH
28584: LD_VAR 0 2
28588: ARRAY
28589: PUSH
28590: LD_VAR 0 4
28594: UNION
28595: PPUSH
28596: CALL_OW 1
28600: ST_TO_ADDR
28601: GO 28536
28603: POP
28604: POP
28605: GO 28518
28607: POP
28608: POP
// end ; if not mc_repair_vehicle [ i ] then
28609: LD_EXP 68
28613: PUSH
28614: LD_VAR 0 2
28618: ARRAY
28619: NOT
28620: IFFALSE 28624
// continue ;
28622: GO 28129
// for j in mc_repair_vehicle [ i ] do
28624: LD_ADDR_VAR 0 3
28628: PUSH
28629: LD_EXP 68
28633: PUSH
28634: LD_VAR 0 2
28638: ARRAY
28639: PUSH
28640: FOR_IN
28641: IFFALSE 28807
// begin if GetClass ( j ) <> 3 then
28643: LD_VAR 0 3
28647: PPUSH
28648: CALL_OW 257
28652: PUSH
28653: LD_INT 3
28655: NONEQUAL
28656: IFFALSE 28697
// begin mc_repair_vehicle := Replace ( mc_repair_vehicle , i , mc_repair_vehicle [ i ] diff j ) ;
28658: LD_ADDR_EXP 68
28662: PUSH
28663: LD_EXP 68
28667: PPUSH
28668: LD_VAR 0 2
28672: PPUSH
28673: LD_EXP 68
28677: PUSH
28678: LD_VAR 0 2
28682: ARRAY
28683: PUSH
28684: LD_VAR 0 3
28688: DIFF
28689: PPUSH
28690: CALL_OW 1
28694: ST_TO_ADDR
// continue ;
28695: GO 28640
// end ; if not IsDrivenBy ( j ) and not j in mc_need_heal [ i ] [ 1 ] and not j in mc_need_heal [ i ] [ 2 ] then
28697: LD_VAR 0 3
28701: PPUSH
28702: CALL_OW 311
28706: NOT
28707: PUSH
28708: LD_VAR 0 3
28712: PUSH
28713: LD_EXP 59
28717: PUSH
28718: LD_VAR 0 2
28722: ARRAY
28723: PUSH
28724: LD_INT 1
28726: ARRAY
28727: IN
28728: NOT
28729: AND
28730: PUSH
28731: LD_VAR 0 3
28735: PUSH
28736: LD_EXP 59
28740: PUSH
28741: LD_VAR 0 2
28745: ARRAY
28746: PUSH
28747: LD_INT 2
28749: ARRAY
28750: IN
28751: NOT
28752: AND
28753: IFFALSE 28805
// begin if IsInUnit ( j ) then
28755: LD_VAR 0 3
28759: PPUSH
28760: CALL_OW 310
28764: IFFALSE 28775
// ComExitBuilding ( j ) ;
28766: LD_VAR 0 3
28770: PPUSH
28771: CALL_OW 122
// if not HasTask ( j ) then
28775: LD_VAR 0 3
28779: PPUSH
28780: CALL_OW 314
28784: NOT
28785: IFFALSE 28805
// AddComRepairVehicle ( j , vehs [ 1 ] ) ;
28787: LD_VAR 0 3
28791: PPUSH
28792: LD_VAR 0 7
28796: PUSH
28797: LD_INT 1
28799: ARRAY
28800: PPUSH
28801: CALL_OW 189
// end ; end ;
28805: GO 28640
28807: POP
28808: POP
// end ;
28809: GO 28129
28811: POP
28812: POP
// end ;
28813: LD_VAR 0 1
28817: RET
// export function MC_TameApe ( ) ; var i , j , x , y , ape , apes , tmp , dep , danger_at_area , side ; begin
28818: LD_INT 0
28820: PPUSH
28821: PPUSH
28822: PPUSH
28823: PPUSH
28824: PPUSH
28825: PPUSH
28826: PPUSH
28827: PPUSH
28828: PPUSH
28829: PPUSH
28830: PPUSH
// if not mc_bases then
28831: LD_EXP 56
28835: NOT
28836: IFFALSE 28840
// exit ;
28838: GO 29642
// for i = 1 to mc_bases do
28840: LD_ADDR_VAR 0 2
28844: PUSH
28845: DOUBLE
28846: LD_INT 1
28848: DEC
28849: ST_TO_ADDR
28850: LD_EXP 56
28854: PUSH
28855: FOR_TO
28856: IFFALSE 29640
// begin if not mc_can_tame [ i ] or mc_need_heal [ i ] [ 1 ] or mc_need_heal [ i ] [ 2 ] or not Researched ( mc_sides [ i ] , tech_apelang ) or mc_scan [ i ] then
28858: LD_EXP 84
28862: PUSH
28863: LD_VAR 0 2
28867: ARRAY
28868: NOT
28869: PUSH
28870: LD_EXP 59
28874: PUSH
28875: LD_VAR 0 2
28879: ARRAY
28880: PUSH
28881: LD_INT 1
28883: ARRAY
28884: OR
28885: PUSH
28886: LD_EXP 59
28890: PUSH
28891: LD_VAR 0 2
28895: ARRAY
28896: PUSH
28897: LD_INT 2
28899: ARRAY
28900: OR
28901: PUSH
28902: LD_EXP 82
28906: PUSH
28907: LD_VAR 0 2
28911: ARRAY
28912: PPUSH
28913: LD_INT 1
28915: PPUSH
28916: CALL_OW 325
28920: NOT
28921: OR
28922: PUSH
28923: LD_EXP 79
28927: PUSH
28928: LD_VAR 0 2
28932: ARRAY
28933: OR
28934: IFFALSE 28938
// continue ;
28936: GO 28855
// tmp := UnitFilter ( mc_bases [ i ] , [ [ f_class , 4 ] , [ f_ok ] , [ f_not , [ f_hastask ] ] ] ) diff mc_healers [ i ] ;
28938: LD_ADDR_VAR 0 8
28942: PUSH
28943: LD_EXP 56
28947: PUSH
28948: LD_VAR 0 2
28952: ARRAY
28953: PPUSH
28954: LD_INT 25
28956: PUSH
28957: LD_INT 4
28959: PUSH
28960: EMPTY
28961: LIST
28962: LIST
28963: PUSH
28964: LD_INT 50
28966: PUSH
28967: EMPTY
28968: LIST
28969: PUSH
28970: LD_INT 3
28972: PUSH
28973: LD_INT 60
28975: PUSH
28976: EMPTY
28977: LIST
28978: PUSH
28979: EMPTY
28980: LIST
28981: LIST
28982: PUSH
28983: EMPTY
28984: LIST
28985: LIST
28986: LIST
28987: PPUSH
28988: CALL_OW 72
28992: PUSH
28993: LD_EXP 60
28997: PUSH
28998: LD_VAR 0 2
29002: ARRAY
29003: DIFF
29004: ST_TO_ADDR
// dep := UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) ;
29005: LD_ADDR_VAR 0 9
29009: PUSH
29010: LD_EXP 56
29014: PUSH
29015: LD_VAR 0 2
29019: ARRAY
29020: PPUSH
29021: LD_INT 2
29023: PUSH
29024: LD_INT 30
29026: PUSH
29027: LD_INT 0
29029: PUSH
29030: EMPTY
29031: LIST
29032: LIST
29033: PUSH
29034: LD_INT 30
29036: PUSH
29037: LD_INT 1
29039: PUSH
29040: EMPTY
29041: LIST
29042: LIST
29043: PUSH
29044: EMPTY
29045: LIST
29046: LIST
29047: LIST
29048: PPUSH
29049: CALL_OW 72
29053: ST_TO_ADDR
// if not tmp or not dep then
29054: LD_VAR 0 8
29058: NOT
29059: PUSH
29060: LD_VAR 0 9
29064: NOT
29065: OR
29066: IFFALSE 29070
// continue ;
29068: GO 28855
// side := GetSide ( tmp [ 1 ] ) ;
29070: LD_ADDR_VAR 0 11
29074: PUSH
29075: LD_VAR 0 8
29079: PUSH
29080: LD_INT 1
29082: ARRAY
29083: PPUSH
29084: CALL_OW 255
29088: ST_TO_ADDR
// dep := dep [ 1 ] ;
29089: LD_ADDR_VAR 0 9
29093: PUSH
29094: LD_VAR 0 9
29098: PUSH
29099: LD_INT 1
29101: ARRAY
29102: ST_TO_ADDR
// apes := FilterUnitsInArea ( mc_can_tame [ i ] , [ [ f_side , 0 ] , [ f_class , class_apeman ] ] ) union FilterAllUnits ( [ [ f_side , 0 ] , [ f_class , class_apeman ] , [ f_dist , dep , 20 ] ] ) ;
29103: LD_ADDR_VAR 0 7
29107: PUSH
29108: LD_EXP 84
29112: PUSH
29113: LD_VAR 0 2
29117: ARRAY
29118: PPUSH
29119: LD_INT 22
29121: PUSH
29122: LD_INT 0
29124: PUSH
29125: EMPTY
29126: LIST
29127: LIST
29128: PUSH
29129: LD_INT 25
29131: PUSH
29132: LD_INT 12
29134: PUSH
29135: EMPTY
29136: LIST
29137: LIST
29138: PUSH
29139: EMPTY
29140: LIST
29141: LIST
29142: PPUSH
29143: CALL_OW 70
29147: PUSH
29148: LD_INT 22
29150: PUSH
29151: LD_INT 0
29153: PUSH
29154: EMPTY
29155: LIST
29156: LIST
29157: PUSH
29158: LD_INT 25
29160: PUSH
29161: LD_INT 12
29163: PUSH
29164: EMPTY
29165: LIST
29166: LIST
29167: PUSH
29168: LD_INT 91
29170: PUSH
29171: LD_VAR 0 9
29175: PUSH
29176: LD_INT 20
29178: PUSH
29179: EMPTY
29180: LIST
29181: LIST
29182: LIST
29183: PUSH
29184: EMPTY
29185: LIST
29186: LIST
29187: LIST
29188: PPUSH
29189: CALL_OW 69
29193: UNION
29194: ST_TO_ADDR
// danger_at_area := FilterUnitsInArea ( mc_can_tame [ i ] , [ f_enemy , side ] ) ;
29195: LD_ADDR_VAR 0 10
29199: PUSH
29200: LD_EXP 84
29204: PUSH
29205: LD_VAR 0 2
29209: ARRAY
29210: PPUSH
29211: LD_INT 81
29213: PUSH
29214: LD_VAR 0 11
29218: PUSH
29219: EMPTY
29220: LIST
29221: LIST
29222: PPUSH
29223: CALL_OW 70
29227: ST_TO_ADDR
// if not apes or danger_at_area then
29228: LD_VAR 0 7
29232: NOT
29233: PUSH
29234: LD_VAR 0 10
29238: OR
29239: IFFALSE 29289
// begin if mc_taming [ i ] then
29241: LD_EXP 87
29245: PUSH
29246: LD_VAR 0 2
29250: ARRAY
29251: IFFALSE 29287
// begin MC_Reset ( i , 121 ) ;
29253: LD_VAR 0 2
29257: PPUSH
29258: LD_INT 121
29260: PPUSH
29261: CALL 14620 0 2
// mc_taming := Replace ( mc_taming , i , [ ] ) ;
29265: LD_ADDR_EXP 87
29269: PUSH
29270: LD_EXP 87
29274: PPUSH
29275: LD_VAR 0 2
29279: PPUSH
29280: EMPTY
29281: PPUSH
29282: CALL_OW 1
29286: ST_TO_ADDR
// end ; continue ;
29287: GO 28855
// end ; for j in tmp do
29289: LD_ADDR_VAR 0 3
29293: PUSH
29294: LD_VAR 0 8
29298: PUSH
29299: FOR_IN
29300: IFFALSE 29636
// begin if not j in mc_taming [ i ] and mc_taming [ i ] < 3 then
29302: LD_VAR 0 3
29306: PUSH
29307: LD_EXP 87
29311: PUSH
29312: LD_VAR 0 2
29316: ARRAY
29317: IN
29318: NOT
29319: PUSH
29320: LD_EXP 87
29324: PUSH
29325: LD_VAR 0 2
29329: ARRAY
29330: PUSH
29331: LD_INT 3
29333: LESS
29334: AND
29335: IFFALSE 29393
// begin SetTag ( j , 121 ) ;
29337: LD_VAR 0 3
29341: PPUSH
29342: LD_INT 121
29344: PPUSH
29345: CALL_OW 109
// mc_taming := ReplaceIn ( mc_taming , [ i , mc_taming [ i ] + 1 ] , j ) ;
29349: LD_ADDR_EXP 87
29353: PUSH
29354: LD_EXP 87
29358: PPUSH
29359: LD_VAR 0 2
29363: PUSH
29364: LD_EXP 87
29368: PUSH
29369: LD_VAR 0 2
29373: ARRAY
29374: PUSH
29375: LD_INT 1
29377: PLUS
29378: PUSH
29379: EMPTY
29380: LIST
29381: LIST
29382: PPUSH
29383: LD_VAR 0 3
29387: PPUSH
29388: CALL 47120 0 3
29392: ST_TO_ADDR
// end ; if j in mc_taming [ i ] then
29393: LD_VAR 0 3
29397: PUSH
29398: LD_EXP 87
29402: PUSH
29403: LD_VAR 0 2
29407: ARRAY
29408: IN
29409: IFFALSE 29634
// begin if GetClass ( j ) <> 4 then
29411: LD_VAR 0 3
29415: PPUSH
29416: CALL_OW 257
29420: PUSH
29421: LD_INT 4
29423: NONEQUAL
29424: IFFALSE 29477
// begin mc_taming := Replace ( mc_taming , i , mc_taming [ i ] diff j ) ;
29426: LD_ADDR_EXP 87
29430: PUSH
29431: LD_EXP 87
29435: PPUSH
29436: LD_VAR 0 2
29440: PPUSH
29441: LD_EXP 87
29445: PUSH
29446: LD_VAR 0 2
29450: ARRAY
29451: PUSH
29452: LD_VAR 0 3
29456: DIFF
29457: PPUSH
29458: CALL_OW 1
29462: ST_TO_ADDR
// SetTag ( j , 0 ) ;
29463: LD_VAR 0 3
29467: PPUSH
29468: LD_INT 0
29470: PPUSH
29471: CALL_OW 109
// continue ;
29475: GO 29299
// end ; if IsInUnit ( j ) then
29477: LD_VAR 0 3
29481: PPUSH
29482: CALL_OW 310
29486: IFFALSE 29497
// ComExitBuilding ( j ) ;
29488: LD_VAR 0 3
29492: PPUSH
29493: CALL_OW 122
// ape := NearestUnitToUnit ( apes , j ) ;
29497: LD_ADDR_VAR 0 6
29501: PUSH
29502: LD_VAR 0 7
29506: PPUSH
29507: LD_VAR 0 3
29511: PPUSH
29512: CALL_OW 74
29516: ST_TO_ADDR
// if not ape then
29517: LD_VAR 0 6
29521: NOT
29522: IFFALSE 29526
// break ;
29524: GO 29636
// x := GetX ( ape ) ;
29526: LD_ADDR_VAR 0 4
29530: PUSH
29531: LD_VAR 0 6
29535: PPUSH
29536: CALL_OW 250
29540: ST_TO_ADDR
// y := GetY ( ape ) ;
29541: LD_ADDR_VAR 0 5
29545: PUSH
29546: LD_VAR 0 6
29550: PPUSH
29551: CALL_OW 251
29555: ST_TO_ADDR
// if not ValidHex ( x , y ) or DangerAtRangeXY ( side , x , y , 20 ) [ 4 ] then
29556: LD_VAR 0 4
29560: PPUSH
29561: LD_VAR 0 5
29565: PPUSH
29566: CALL_OW 488
29570: NOT
29571: PUSH
29572: LD_VAR 0 11
29576: PPUSH
29577: LD_VAR 0 4
29581: PPUSH
29582: LD_VAR 0 5
29586: PPUSH
29587: LD_INT 20
29589: PPUSH
29590: CALL 48016 0 4
29594: PUSH
29595: LD_INT 4
29597: ARRAY
29598: OR
29599: IFFALSE 29603
// break ;
29601: GO 29636
// if not HasTask ( j ) then
29603: LD_VAR 0 3
29607: PPUSH
29608: CALL_OW 314
29612: NOT
29613: IFFALSE 29634
// ComTameXY ( j , x , y ) ;
29615: LD_VAR 0 3
29619: PPUSH
29620: LD_VAR 0 4
29624: PPUSH
29625: LD_VAR 0 5
29629: PPUSH
29630: CALL_OW 131
// end ; end ;
29634: GO 29299
29636: POP
29637: POP
// end ;
29638: GO 28855
29640: POP
29641: POP
// end ;
29642: LD_VAR 0 1
29646: RET
// export function MC_ChangeApeClass ( ) ; var i , j , tmp , side , depot , selected , barracks ; begin
29647: LD_INT 0
29649: PPUSH
29650: PPUSH
29651: PPUSH
29652: PPUSH
29653: PPUSH
29654: PPUSH
29655: PPUSH
29656: PPUSH
// if not mc_bases then
29657: LD_EXP 56
29661: NOT
29662: IFFALSE 29666
// exit ;
29664: GO 30292
// for i = 1 to mc_bases do
29666: LD_ADDR_VAR 0 2
29670: PUSH
29671: DOUBLE
29672: LD_INT 1
29674: DEC
29675: ST_TO_ADDR
29676: LD_EXP 56
29680: PUSH
29681: FOR_TO
29682: IFFALSE 30290
// begin if not mc_ape [ i ] or not UnitFilter ( mc_ape [ i ] , [ f_class , 12 ] ) then
29684: LD_EXP 85
29688: PUSH
29689: LD_VAR 0 2
29693: ARRAY
29694: NOT
29695: PUSH
29696: LD_EXP 85
29700: PUSH
29701: LD_VAR 0 2
29705: ARRAY
29706: PPUSH
29707: LD_INT 25
29709: PUSH
29710: LD_INT 12
29712: PUSH
29713: EMPTY
29714: LIST
29715: LIST
29716: PPUSH
29717: CALL_OW 72
29721: NOT
29722: OR
29723: IFFALSE 29727
// continue ;
29725: GO 29681
// side := GetSide ( mc_ape [ i ] [ 1 ] ) ;
29727: LD_ADDR_VAR 0 5
29731: PUSH
29732: LD_EXP 85
29736: PUSH
29737: LD_VAR 0 2
29741: ARRAY
29742: PUSH
29743: LD_INT 1
29745: ARRAY
29746: PPUSH
29747: CALL_OW 255
29751: ST_TO_ADDR
// if Researched ( side , tech_apepsych ) then
29752: LD_VAR 0 5
29756: PPUSH
29757: LD_INT 2
29759: PPUSH
29760: CALL_OW 325
29764: IFFALSE 30017
// begin tmp := UnitFilter ( mc_ape [ i ] , [ f_class , 16 ] ) ;
29766: LD_ADDR_VAR 0 4
29770: PUSH
29771: LD_EXP 85
29775: PUSH
29776: LD_VAR 0 2
29780: ARRAY
29781: PPUSH
29782: LD_INT 25
29784: PUSH
29785: LD_INT 16
29787: PUSH
29788: EMPTY
29789: LIST
29790: LIST
29791: PPUSH
29792: CALL_OW 72
29796: ST_TO_ADDR
// if tmp < 6 then
29797: LD_VAR 0 4
29801: PUSH
29802: LD_INT 6
29804: LESS
29805: IFFALSE 30017
// begin depot := UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) ;
29807: LD_ADDR_VAR 0 6
29811: PUSH
29812: LD_EXP 56
29816: PUSH
29817: LD_VAR 0 2
29821: ARRAY
29822: PPUSH
29823: LD_INT 2
29825: PUSH
29826: LD_INT 30
29828: PUSH
29829: LD_INT 0
29831: PUSH
29832: EMPTY
29833: LIST
29834: LIST
29835: PUSH
29836: LD_INT 30
29838: PUSH
29839: LD_INT 1
29841: PUSH
29842: EMPTY
29843: LIST
29844: LIST
29845: PUSH
29846: EMPTY
29847: LIST
29848: LIST
29849: LIST
29850: PPUSH
29851: CALL_OW 72
29855: ST_TO_ADDR
// if depot then
29856: LD_VAR 0 6
29860: IFFALSE 30017
// begin selected := 0 ;
29862: LD_ADDR_VAR 0 7
29866: PUSH
29867: LD_INT 0
29869: ST_TO_ADDR
// for j in depot do
29870: LD_ADDR_VAR 0 3
29874: PUSH
29875: LD_VAR 0 6
29879: PUSH
29880: FOR_IN
29881: IFFALSE 29912
// begin if UnitsInside ( j ) < 6 then
29883: LD_VAR 0 3
29887: PPUSH
29888: CALL_OW 313
29892: PUSH
29893: LD_INT 6
29895: LESS
29896: IFFALSE 29910
// begin selected := j ;
29898: LD_ADDR_VAR 0 7
29902: PUSH
29903: LD_VAR 0 3
29907: ST_TO_ADDR
// break ;
29908: GO 29912
// end ; end ;
29910: GO 29880
29912: POP
29913: POP
// if selected then
29914: LD_VAR 0 7
29918: IFFALSE 30017
// begin for j in UnitFilter ( mc_ape [ i ] , [ f_class , 12 ] ) do
29920: LD_ADDR_VAR 0 3
29924: PUSH
29925: LD_EXP 85
29929: PUSH
29930: LD_VAR 0 2
29934: ARRAY
29935: PPUSH
29936: LD_INT 25
29938: PUSH
29939: LD_INT 12
29941: PUSH
29942: EMPTY
29943: LIST
29944: LIST
29945: PPUSH
29946: CALL_OW 72
29950: PUSH
29951: FOR_IN
29952: IFFALSE 30015
// if not HasTask ( j ) then
29954: LD_VAR 0 3
29958: PPUSH
29959: CALL_OW 314
29963: NOT
29964: IFFALSE 30013
// begin if not IsInUnit ( j ) then
29966: LD_VAR 0 3
29970: PPUSH
29971: CALL_OW 310
29975: NOT
29976: IFFALSE 29992
// ComEnterUnit ( j , selected ) ;
29978: LD_VAR 0 3
29982: PPUSH
29983: LD_VAR 0 7
29987: PPUSH
29988: CALL_OW 120
// AddComChangeProfession ( j , 16 ) ;
29992: LD_VAR 0 3
29996: PPUSH
29997: LD_INT 16
29999: PPUSH
30000: CALL_OW 183
// AddComExitBuilding ( j ) ;
30004: LD_VAR 0 3
30008: PPUSH
30009: CALL_OW 182
// end ;
30013: GO 29951
30015: POP
30016: POP
// end ; end ; end ; end ; if Researched ( side , tech_apeagres ) then
30017: LD_VAR 0 5
30021: PPUSH
30022: LD_INT 11
30024: PPUSH
30025: CALL_OW 325
30029: IFFALSE 30288
// begin tmp := UnitFilter ( mc_ape [ i ] , [ f_class , 16 ] ) ;
30031: LD_ADDR_VAR 0 4
30035: PUSH
30036: LD_EXP 85
30040: PUSH
30041: LD_VAR 0 2
30045: ARRAY
30046: PPUSH
30047: LD_INT 25
30049: PUSH
30050: LD_INT 16
30052: PUSH
30053: EMPTY
30054: LIST
30055: LIST
30056: PPUSH
30057: CALL_OW 72
30061: ST_TO_ADDR
// if tmp >= 6 or not Researched ( side , tech_apepsych ) then
30062: LD_VAR 0 4
30066: PUSH
30067: LD_INT 6
30069: GREATEREQUAL
30070: PUSH
30071: LD_VAR 0 5
30075: PPUSH
30076: LD_INT 2
30078: PPUSH
30079: CALL_OW 325
30083: NOT
30084: OR
30085: IFFALSE 30288
// begin barracks := UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_armoury ] , [ f_btype , b_barracks ] ] ) ;
30087: LD_ADDR_VAR 0 8
30091: PUSH
30092: LD_EXP 56
30096: PUSH
30097: LD_VAR 0 2
30101: ARRAY
30102: PPUSH
30103: LD_INT 2
30105: PUSH
30106: LD_INT 30
30108: PUSH
30109: LD_INT 4
30111: PUSH
30112: EMPTY
30113: LIST
30114: LIST
30115: PUSH
30116: LD_INT 30
30118: PUSH
30119: LD_INT 5
30121: PUSH
30122: EMPTY
30123: LIST
30124: LIST
30125: PUSH
30126: EMPTY
30127: LIST
30128: LIST
30129: LIST
30130: PPUSH
30131: CALL_OW 72
30135: ST_TO_ADDR
// if barracks then
30136: LD_VAR 0 8
30140: IFFALSE 30288
// begin selected := 0 ;
30142: LD_ADDR_VAR 0 7
30146: PUSH
30147: LD_INT 0
30149: ST_TO_ADDR
// for j in barracks do
30150: LD_ADDR_VAR 0 3
30154: PUSH
30155: LD_VAR 0 8
30159: PUSH
30160: FOR_IN
30161: IFFALSE 30192
// begin if UnitsInside ( j ) < 6 then
30163: LD_VAR 0 3
30167: PPUSH
30168: CALL_OW 313
30172: PUSH
30173: LD_INT 6
30175: LESS
30176: IFFALSE 30190
// begin selected := j ;
30178: LD_ADDR_VAR 0 7
30182: PUSH
30183: LD_VAR 0 3
30187: ST_TO_ADDR
// break ;
30188: GO 30192
// end ; end ;
30190: GO 30160
30192: POP
30193: POP
// if selected then
30194: LD_VAR 0 7
30198: IFFALSE 30288
// begin for j in UnitFilter ( mc_ape [ i ] , [ f_class , 12 ] ) do
30200: LD_ADDR_VAR 0 3
30204: PUSH
30205: LD_EXP 85
30209: PUSH
30210: LD_VAR 0 2
30214: ARRAY
30215: PPUSH
30216: LD_INT 25
30218: PUSH
30219: LD_INT 12
30221: PUSH
30222: EMPTY
30223: LIST
30224: LIST
30225: PPUSH
30226: CALL_OW 72
30230: PUSH
30231: FOR_IN
30232: IFFALSE 30286
// if not IsInUnit ( j ) and not HasTask ( j ) then
30234: LD_VAR 0 3
30238: PPUSH
30239: CALL_OW 310
30243: NOT
30244: PUSH
30245: LD_VAR 0 3
30249: PPUSH
30250: CALL_OW 314
30254: NOT
30255: AND
30256: IFFALSE 30284
// begin ComEnterUnit ( j , selected ) ;
30258: LD_VAR 0 3
30262: PPUSH
30263: LD_VAR 0 7
30267: PPUSH
30268: CALL_OW 120
// AddComChangeProfession ( j , 15 ) ;
30272: LD_VAR 0 3
30276: PPUSH
30277: LD_INT 15
30279: PPUSH
30280: CALL_OW 183
// end ;
30284: GO 30231
30286: POP
30287: POP
// end ; end ; end ; end ; end ;
30288: GO 29681
30290: POP
30291: POP
// end ;
30292: LD_VAR 0 1
30296: RET
// export function MC_Bazooka ( ) ; var i , j , tmp ; begin
30297: LD_INT 0
30299: PPUSH
30300: PPUSH
30301: PPUSH
30302: PPUSH
// if not mc_bases then
30303: LD_EXP 56
30307: NOT
30308: IFFALSE 30312
// exit ;
30310: GO 30490
// for i = 1 to mc_bases do
30312: LD_ADDR_VAR 0 2
30316: PUSH
30317: DOUBLE
30318: LD_INT 1
30320: DEC
30321: ST_TO_ADDR
30322: LD_EXP 56
30326: PUSH
30327: FOR_TO
30328: IFFALSE 30488
// begin tmp := UnitFilter ( mc_bases [ i ] , [ f_class , class_bazooker ] ) ;
30330: LD_ADDR_VAR 0 4
30334: PUSH
30335: LD_EXP 56
30339: PUSH
30340: LD_VAR 0 2
30344: ARRAY
30345: PPUSH
30346: LD_INT 25
30348: PUSH
30349: LD_INT 9
30351: PUSH
30352: EMPTY
30353: LIST
30354: LIST
30355: PPUSH
30356: CALL_OW 72
30360: ST_TO_ADDR
// if not tmp then
30361: LD_VAR 0 4
30365: NOT
30366: IFFALSE 30370
// continue ;
30368: GO 30327
// if not Researched ( mc_sides [ i ] , tech_spacanom ) and not Researched ( mc_sides [ i ] , tech_taurad ) then
30370: LD_EXP 82
30374: PUSH
30375: LD_VAR 0 2
30379: ARRAY
30380: PPUSH
30381: LD_INT 29
30383: PPUSH
30384: CALL_OW 325
30388: NOT
30389: PUSH
30390: LD_EXP 82
30394: PUSH
30395: LD_VAR 0 2
30399: ARRAY
30400: PPUSH
30401: LD_INT 28
30403: PPUSH
30404: CALL_OW 325
30408: NOT
30409: AND
30410: IFFALSE 30414
// continue ;
30412: GO 30327
// for j in tmp do
30414: LD_ADDR_VAR 0 3
30418: PUSH
30419: LD_VAR 0 4
30423: PUSH
30424: FOR_IN
30425: IFFALSE 30484
// if not j in mc_need_heal [ i ] [ 1 ] and not j in mc_need_heal [ i ] [ 2 ] then
30427: LD_VAR 0 3
30431: PUSH
30432: LD_EXP 59
30436: PUSH
30437: LD_VAR 0 2
30441: ARRAY
30442: PUSH
30443: LD_INT 1
30445: ARRAY
30446: IN
30447: NOT
30448: PUSH
30449: LD_VAR 0 3
30453: PUSH
30454: LD_EXP 59
30458: PUSH
30459: LD_VAR 0 2
30463: ARRAY
30464: PUSH
30465: LD_INT 2
30467: ARRAY
30468: IN
30469: NOT
30470: AND
30471: IFFALSE 30482
// ComSpaceTimeShoot ( j ) ;
30473: LD_VAR 0 3
30477: PPUSH
30478: CALL 41070 0 1
30482: GO 30424
30484: POP
30485: POP
// end ;
30486: GO 30327
30488: POP
30489: POP
// end ;
30490: LD_VAR 0 1
30494: RET
// export function MC_TeleportExit ( ) ; var i , j , x , y , save_point , tmp , teleports , sci ; begin
30495: LD_INT 0
30497: PPUSH
30498: PPUSH
30499: PPUSH
30500: PPUSH
30501: PPUSH
30502: PPUSH
30503: PPUSH
30504: PPUSH
30505: PPUSH
// if not mc_bases then
30506: LD_EXP 56
30510: NOT
30511: IFFALSE 30515
// exit ;
30513: GO 31137
// for i = 1 to mc_bases do
30515: LD_ADDR_VAR 0 2
30519: PUSH
30520: DOUBLE
30521: LD_INT 1
30523: DEC
30524: ST_TO_ADDR
30525: LD_EXP 56
30529: PUSH
30530: FOR_TO
30531: IFFALSE 31135
// begin if not mc_teleport_exit [ i ] or GetTech ( tech_targTeleport , mc_sides [ i ] ) <> state_researched then
30533: LD_EXP 91
30537: PUSH
30538: LD_VAR 0 2
30542: ARRAY
30543: NOT
30544: PUSH
30545: LD_INT 38
30547: PPUSH
30548: LD_EXP 82
30552: PUSH
30553: LD_VAR 0 2
30557: ARRAY
30558: PPUSH
30559: CALL_OW 321
30563: PUSH
30564: LD_INT 2
30566: NONEQUAL
30567: OR
30568: IFFALSE 30572
// continue ;
30570: GO 30530
// teleports := UnitFilter ( mc_bases [ i ] , [ f_btype , b_teleport ] ) ;
30572: LD_ADDR_VAR 0 8
30576: PUSH
30577: LD_EXP 56
30581: PUSH
30582: LD_VAR 0 2
30586: ARRAY
30587: PPUSH
30588: LD_INT 30
30590: PUSH
30591: LD_INT 34
30593: PUSH
30594: EMPTY
30595: LIST
30596: LIST
30597: PPUSH
30598: CALL_OW 72
30602: ST_TO_ADDR
// sci := FilterByTag ( UnitFilter ( mc_bases [ i ] , [ f_class , 4 ] ) , 0 ) ;
30603: LD_ADDR_VAR 0 9
30607: PUSH
30608: LD_EXP 56
30612: PUSH
30613: LD_VAR 0 2
30617: ARRAY
30618: PPUSH
30619: LD_INT 25
30621: PUSH
30622: LD_INT 4
30624: PUSH
30625: EMPTY
30626: LIST
30627: LIST
30628: PPUSH
30629: CALL_OW 72
30633: PPUSH
30634: LD_INT 0
30636: PPUSH
30637: CALL 80380 0 2
30641: ST_TO_ADDR
// if not sci or not teleports or FilterByTag ( mc_bases [ i ] , 124 ) then
30642: LD_VAR 0 9
30646: NOT
30647: PUSH
30648: LD_VAR 0 8
30652: NOT
30653: OR
30654: PUSH
30655: LD_EXP 56
30659: PUSH
30660: LD_VAR 0 2
30664: ARRAY
30665: PPUSH
30666: LD_INT 124
30668: PPUSH
30669: CALL 80380 0 2
30673: OR
30674: IFFALSE 30678
// continue ;
30676: GO 30530
// if mc_teleport_exit_set [ i ] < mc_teleport_exit [ i ] and mc_teleport_exit_set [ i ] < teleports then
30678: LD_EXP 92
30682: PUSH
30683: LD_VAR 0 2
30687: ARRAY
30688: PUSH
30689: LD_EXP 91
30693: PUSH
30694: LD_VAR 0 2
30698: ARRAY
30699: LESS
30700: PUSH
30701: LD_EXP 92
30705: PUSH
30706: LD_VAR 0 2
30710: ARRAY
30711: PUSH
30712: LD_VAR 0 8
30716: LESS
30717: AND
30718: IFFALSE 31133
// begin tmp := sci [ 1 ] ;
30720: LD_ADDR_VAR 0 7
30724: PUSH
30725: LD_VAR 0 9
30729: PUSH
30730: LD_INT 1
30732: ARRAY
30733: ST_TO_ADDR
// SetTag ( tmp , 124 ) ;
30734: LD_VAR 0 7
30738: PPUSH
30739: LD_INT 124
30741: PPUSH
30742: CALL_OW 109
// for j = mc_teleport_exit [ i ] downto mc_teleport_exit [ i ] do
30746: LD_ADDR_VAR 0 3
30750: PUSH
30751: DOUBLE
30752: LD_EXP 91
30756: PUSH
30757: LD_VAR 0 2
30761: ARRAY
30762: INC
30763: ST_TO_ADDR
30764: LD_EXP 91
30768: PUSH
30769: LD_VAR 0 2
30773: ARRAY
30774: PUSH
30775: FOR_DOWNTO
30776: IFFALSE 31119
// begin if IsInUnit ( tmp ) then
30778: LD_VAR 0 7
30782: PPUSH
30783: CALL_OW 310
30787: IFFALSE 30798
// ComExitBuilding ( tmp ) ;
30789: LD_VAR 0 7
30793: PPUSH
30794: CALL_OW 122
// repeat wait ( 0 0$1 ) ;
30798: LD_INT 35
30800: PPUSH
30801: CALL_OW 67
// until not IsInUnit ( tmp ) and not HasTask ( tmp ) ;
30805: LD_VAR 0 7
30809: PPUSH
30810: CALL_OW 310
30814: NOT
30815: PUSH
30816: LD_VAR 0 7
30820: PPUSH
30821: CALL_OW 314
30825: NOT
30826: AND
30827: IFFALSE 30798
// save_point := [ GetX ( tmp ) , GetY ( tmp ) ] ;
30829: LD_ADDR_VAR 0 6
30833: PUSH
30834: LD_VAR 0 7
30838: PPUSH
30839: CALL_OW 250
30843: PUSH
30844: LD_VAR 0 7
30848: PPUSH
30849: CALL_OW 251
30853: PUSH
30854: EMPTY
30855: LIST
30856: LIST
30857: ST_TO_ADDR
// repeat wait ( 0 0$1 ) ;
30858: LD_INT 35
30860: PPUSH
30861: CALL_OW 67
// x := mc_teleport_exit [ i ] [ j ] [ 1 ] ;
30865: LD_ADDR_VAR 0 4
30869: PUSH
30870: LD_EXP 91
30874: PUSH
30875: LD_VAR 0 2
30879: ARRAY
30880: PUSH
30881: LD_VAR 0 3
30885: ARRAY
30886: PUSH
30887: LD_INT 1
30889: ARRAY
30890: ST_TO_ADDR
// y := mc_teleport_exit [ i ] [ j ] [ 2 ] ;
30891: LD_ADDR_VAR 0 5
30895: PUSH
30896: LD_EXP 91
30900: PUSH
30901: LD_VAR 0 2
30905: ARRAY
30906: PUSH
30907: LD_VAR 0 3
30911: ARRAY
30912: PUSH
30913: LD_INT 2
30915: ARRAY
30916: ST_TO_ADDR
// if DangerAtRange ( tmp , 10 ) [ 4 ] then
30917: LD_VAR 0 7
30921: PPUSH
30922: LD_INT 10
30924: PPUSH
30925: CALL 49713 0 2
30929: PUSH
30930: LD_INT 4
30932: ARRAY
30933: IFFALSE 30971
// begin ComMoveXY ( tmp , save_point [ 1 ] , save_point [ 2 ] ) ;
30935: LD_VAR 0 7
30939: PPUSH
30940: LD_VAR 0 6
30944: PUSH
30945: LD_INT 1
30947: ARRAY
30948: PPUSH
30949: LD_VAR 0 6
30953: PUSH
30954: LD_INT 2
30956: ARRAY
30957: PPUSH
30958: CALL_OW 111
// wait ( 0 0$10 ) ;
30962: LD_INT 350
30964: PPUSH
30965: CALL_OW 67
// end else
30969: GO 30997
// begin ComMoveXY ( tmp , x , y ) ;
30971: LD_VAR 0 7
30975: PPUSH
30976: LD_VAR 0 4
30980: PPUSH
30981: LD_VAR 0 5
30985: PPUSH
30986: CALL_OW 111
// wait ( 0 0$3 ) ;
30990: LD_INT 105
30992: PPUSH
30993: CALL_OW 67
// end ; until IsAt ( tmp , x , y ) ;
30997: LD_VAR 0 7
31001: PPUSH
31002: LD_VAR 0 4
31006: PPUSH
31007: LD_VAR 0 5
31011: PPUSH
31012: CALL_OW 307
31016: IFFALSE 30858
// ComTeleportExit ( tmp , x , y , teleports [ j ] ) ;
31018: LD_VAR 0 7
31022: PPUSH
31023: LD_VAR 0 4
31027: PPUSH
31028: LD_VAR 0 5
31032: PPUSH
31033: LD_VAR 0 8
31037: PUSH
31038: LD_VAR 0 3
31042: ARRAY
31043: PPUSH
31044: CALL_OW 156
// repeat wait ( 0 0$1 ) ;
31048: LD_INT 35
31050: PPUSH
31051: CALL_OW 67
// until not HasTask ( tmp ) ;
31055: LD_VAR 0 7
31059: PPUSH
31060: CALL_OW 314
31064: NOT
31065: IFFALSE 31048
// mc_teleport_exit_set := ReplaceIn ( mc_teleport_exit_set , [ i , mc_teleport_exit_set [ i ] + 1 ] , teleports [ j ] ) ;
31067: LD_ADDR_EXP 92
31071: PUSH
31072: LD_EXP 92
31076: PPUSH
31077: LD_VAR 0 2
31081: PUSH
31082: LD_EXP 92
31086: PUSH
31087: LD_VAR 0 2
31091: ARRAY
31092: PUSH
31093: LD_INT 1
31095: PLUS
31096: PUSH
31097: EMPTY
31098: LIST
31099: LIST
31100: PPUSH
31101: LD_VAR 0 8
31105: PUSH
31106: LD_VAR 0 3
31110: ARRAY
31111: PPUSH
31112: CALL 47120 0 3
31116: ST_TO_ADDR
// end ;
31117: GO 30775
31119: POP
31120: POP
// MC_Reset ( i , 124 ) ;
31121: LD_VAR 0 2
31125: PPUSH
31126: LD_INT 124
31128: PPUSH
31129: CALL 14620 0 2
// end ; end ;
31133: GO 30530
31135: POP
31136: POP
// end ;
31137: LD_VAR 0 1
31141: RET
// export function MC_Deposits ( ) ; var i , tmp ; begin
31142: LD_INT 0
31144: PPUSH
31145: PPUSH
31146: PPUSH
// if not mc_bases then
31147: LD_EXP 56
31151: NOT
31152: IFFALSE 31156
// exit ;
31154: GO 31762
// for i = 1 to mc_bases do
31156: LD_ADDR_VAR 0 2
31160: PUSH
31161: DOUBLE
31162: LD_INT 1
31164: DEC
31165: ST_TO_ADDR
31166: LD_EXP 56
31170: PUSH
31171: FOR_TO
31172: IFFALSE 31760
// begin tmp := UnitFilter ( mc_bases [ i ] , [ f_class , 4 ] ) ;
31174: LD_ADDR_VAR 0 3
31178: PUSH
31179: LD_EXP 56
31183: PUSH
31184: LD_VAR 0 2
31188: ARRAY
31189: PPUSH
31190: LD_INT 25
31192: PUSH
31193: LD_INT 4
31195: PUSH
31196: EMPTY
31197: LIST
31198: LIST
31199: PPUSH
31200: CALL_OW 72
31204: ST_TO_ADDR
// if not tmp or not mc_deposits_xy [ i ] or not UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) then
31205: LD_VAR 0 3
31209: NOT
31210: PUSH
31211: LD_EXP 93
31215: PUSH
31216: LD_VAR 0 2
31220: ARRAY
31221: NOT
31222: OR
31223: PUSH
31224: LD_EXP 56
31228: PUSH
31229: LD_VAR 0 2
31233: ARRAY
31234: PPUSH
31235: LD_INT 2
31237: PUSH
31238: LD_INT 30
31240: PUSH
31241: LD_INT 0
31243: PUSH
31244: EMPTY
31245: LIST
31246: LIST
31247: PUSH
31248: LD_INT 30
31250: PUSH
31251: LD_INT 1
31253: PUSH
31254: EMPTY
31255: LIST
31256: LIST
31257: PUSH
31258: EMPTY
31259: LIST
31260: LIST
31261: LIST
31262: PPUSH
31263: CALL_OW 72
31267: NOT
31268: OR
31269: IFFALSE 31319
// begin if mc_deposits_finder [ i ] then
31271: LD_EXP 94
31275: PUSH
31276: LD_VAR 0 2
31280: ARRAY
31281: IFFALSE 31317
// begin MC_Reset ( i , 125 ) ;
31283: LD_VAR 0 2
31287: PPUSH
31288: LD_INT 125
31290: PPUSH
31291: CALL 14620 0 2
// mc_deposits_finder := Replace ( mc_deposits_finder , i , [ ] ) ;
31295: LD_ADDR_EXP 94
31299: PUSH
31300: LD_EXP 94
31304: PPUSH
31305: LD_VAR 0 2
31309: PPUSH
31310: EMPTY
31311: PPUSH
31312: CALL_OW 1
31316: ST_TO_ADDR
// end ; continue ;
31317: GO 31171
// end ; if mc_deposits_xy [ i ] [ 1 ] [ 3 ] = 1 and GetTech ( tech_sibdet , mc_sides [ i ] ) <> state_researched then
31319: LD_EXP 93
31323: PUSH
31324: LD_VAR 0 2
31328: ARRAY
31329: PUSH
31330: LD_INT 1
31332: ARRAY
31333: PUSH
31334: LD_INT 3
31336: ARRAY
31337: PUSH
31338: LD_INT 1
31340: EQUAL
31341: PUSH
31342: LD_INT 20
31344: PPUSH
31345: LD_EXP 82
31349: PUSH
31350: LD_VAR 0 2
31354: ARRAY
31355: PPUSH
31356: CALL_OW 321
31360: PUSH
31361: LD_INT 2
31363: NONEQUAL
31364: AND
31365: IFFALSE 31415
// begin if mc_deposits_finder [ i ] then
31367: LD_EXP 94
31371: PUSH
31372: LD_VAR 0 2
31376: ARRAY
31377: IFFALSE 31413
// begin MC_Reset ( i , 125 ) ;
31379: LD_VAR 0 2
31383: PPUSH
31384: LD_INT 125
31386: PPUSH
31387: CALL 14620 0 2
// mc_deposits_finder := Replace ( mc_deposits_finder , i , [ ] ) ;
31391: LD_ADDR_EXP 94
31395: PUSH
31396: LD_EXP 94
31400: PPUSH
31401: LD_VAR 0 2
31405: PPUSH
31406: EMPTY
31407: PPUSH
31408: CALL_OW 1
31412: ST_TO_ADDR
// end ; continue ;
31413: GO 31171
// end ; if GetResourceVisibility ( mc_deposits_xy [ i ] [ 1 ] [ 1 ] , mc_deposits_xy [ i ] [ 1 ] [ 2 ] , mc_sides [ i ] ) then
31415: LD_EXP 93
31419: PUSH
31420: LD_VAR 0 2
31424: ARRAY
31425: PUSH
31426: LD_INT 1
31428: ARRAY
31429: PUSH
31430: LD_INT 1
31432: ARRAY
31433: PPUSH
31434: LD_EXP 93
31438: PUSH
31439: LD_VAR 0 2
31443: ARRAY
31444: PUSH
31445: LD_INT 1
31447: ARRAY
31448: PUSH
31449: LD_INT 2
31451: ARRAY
31452: PPUSH
31453: LD_EXP 82
31457: PUSH
31458: LD_VAR 0 2
31462: ARRAY
31463: PPUSH
31464: CALL_OW 440
31468: IFFALSE 31511
// mc_deposits_xy := Replace ( mc_deposits_xy , i , Delete ( mc_deposits_xy [ i ] , 1 ) ) else
31470: LD_ADDR_EXP 93
31474: PUSH
31475: LD_EXP 93
31479: PPUSH
31480: LD_VAR 0 2
31484: PPUSH
31485: LD_EXP 93
31489: PUSH
31490: LD_VAR 0 2
31494: ARRAY
31495: PPUSH
31496: LD_INT 1
31498: PPUSH
31499: CALL_OW 3
31503: PPUSH
31504: CALL_OW 1
31508: ST_TO_ADDR
31509: GO 31758
// begin if not mc_deposits_finder [ i ] then
31511: LD_EXP 94
31515: PUSH
31516: LD_VAR 0 2
31520: ARRAY
31521: NOT
31522: IFFALSE 31574
// begin mc_deposits_finder := Replace ( mc_deposits_finder , i , [ tmp [ 1 ] ] ) ;
31524: LD_ADDR_EXP 94
31528: PUSH
31529: LD_EXP 94
31533: PPUSH
31534: LD_VAR 0 2
31538: PPUSH
31539: LD_VAR 0 3
31543: PUSH
31544: LD_INT 1
31546: ARRAY
31547: PUSH
31548: EMPTY
31549: LIST
31550: PPUSH
31551: CALL_OW 1
31555: ST_TO_ADDR
// SetTag ( tmp [ 1 ] , 125 ) ;
31556: LD_VAR 0 3
31560: PUSH
31561: LD_INT 1
31563: ARRAY
31564: PPUSH
31565: LD_INT 125
31567: PPUSH
31568: CALL_OW 109
// end else
31572: GO 31758
// begin if IsInUnit ( mc_deposits_finder [ i ] [ 1 ] ) then
31574: LD_EXP 94
31578: PUSH
31579: LD_VAR 0 2
31583: ARRAY
31584: PUSH
31585: LD_INT 1
31587: ARRAY
31588: PPUSH
31589: CALL_OW 310
31593: IFFALSE 31616
// ComExitBuilding ( mc_deposits_finder [ i ] [ 1 ] ) else
31595: LD_EXP 94
31599: PUSH
31600: LD_VAR 0 2
31604: ARRAY
31605: PUSH
31606: LD_INT 1
31608: ARRAY
31609: PPUSH
31610: CALL_OW 122
31614: GO 31758
// if not HasTask ( mc_deposits_finder [ i ] [ 1 ] ) and GetDistUnitXY ( mc_deposits_finder [ i ] [ 1 ] , mc_deposits_xy [ i ] [ 1 ] [ 1 ] , mc_deposits_xy [ i ] [ 1 ] [ 2 ] ) > 6 then
31616: LD_EXP 94
31620: PUSH
31621: LD_VAR 0 2
31625: ARRAY
31626: PUSH
31627: LD_INT 1
31629: ARRAY
31630: PPUSH
31631: CALL_OW 314
31635: NOT
31636: PUSH
31637: LD_EXP 94
31641: PUSH
31642: LD_VAR 0 2
31646: ARRAY
31647: PUSH
31648: LD_INT 1
31650: ARRAY
31651: PPUSH
31652: LD_EXP 93
31656: PUSH
31657: LD_VAR 0 2
31661: ARRAY
31662: PUSH
31663: LD_INT 1
31665: ARRAY
31666: PUSH
31667: LD_INT 1
31669: ARRAY
31670: PPUSH
31671: LD_EXP 93
31675: PUSH
31676: LD_VAR 0 2
31680: ARRAY
31681: PUSH
31682: LD_INT 1
31684: ARRAY
31685: PUSH
31686: LD_INT 2
31688: ARRAY
31689: PPUSH
31690: CALL_OW 297
31694: PUSH
31695: LD_INT 6
31697: GREATER
31698: AND
31699: IFFALSE 31758
// ComMoveXY ( mc_deposits_finder [ i ] [ 1 ] , mc_deposits_xy [ i ] [ 1 ] [ 1 ] , mc_deposits_xy [ i ] [ 1 ] [ 2 ] ) ;
31701: LD_EXP 94
31705: PUSH
31706: LD_VAR 0 2
31710: ARRAY
31711: PUSH
31712: LD_INT 1
31714: ARRAY
31715: PPUSH
31716: LD_EXP 93
31720: PUSH
31721: LD_VAR 0 2
31725: ARRAY
31726: PUSH
31727: LD_INT 1
31729: ARRAY
31730: PUSH
31731: LD_INT 1
31733: ARRAY
31734: PPUSH
31735: LD_EXP 93
31739: PUSH
31740: LD_VAR 0 2
31744: ARRAY
31745: PUSH
31746: LD_INT 1
31748: ARRAY
31749: PUSH
31750: LD_INT 2
31752: ARRAY
31753: PPUSH
31754: CALL_OW 111
// end ; end ; end ;
31758: GO 31171
31760: POP
31761: POP
// end ;
31762: LD_VAR 0 1
31766: RET
// export function MC_RemoteDriver ( ) ; var i , j , k , places , tmp , nation , ct , cts , mcts , x ; begin
31767: LD_INT 0
31769: PPUSH
31770: PPUSH
31771: PPUSH
31772: PPUSH
31773: PPUSH
31774: PPUSH
31775: PPUSH
31776: PPUSH
31777: PPUSH
31778: PPUSH
31779: PPUSH
// if not mc_bases then
31780: LD_EXP 56
31784: NOT
31785: IFFALSE 31789
// exit ;
31787: GO 32513
// for i = 1 to mc_bases do
31789: LD_ADDR_VAR 0 2
31793: PUSH
31794: DOUBLE
31795: LD_INT 1
31797: DEC
31798: ST_TO_ADDR
31799: LD_EXP 56
31803: PUSH
31804: FOR_TO
31805: IFFALSE 32511
// begin if not mc_bases [ i ] then
31807: LD_EXP 56
31811: PUSH
31812: LD_VAR 0 2
31816: ARRAY
31817: NOT
31818: IFFALSE 31822
// continue ;
31820: GO 31804
// nation := GetNation ( mc_bases [ i ] [ 1 ] ) ;
31822: LD_ADDR_VAR 0 7
31826: PUSH
31827: LD_EXP 56
31831: PUSH
31832: LD_VAR 0 2
31836: ARRAY
31837: PUSH
31838: LD_INT 1
31840: ARRAY
31841: PPUSH
31842: CALL_OW 248
31846: ST_TO_ADDR
// if nation = 3 or not UnitFilter ( mc_vehicles [ i ] union mc_defender [ i ] , [ f_control , control_remote ] ) then
31847: LD_VAR 0 7
31851: PUSH
31852: LD_INT 3
31854: EQUAL
31855: PUSH
31856: LD_EXP 75
31860: PUSH
31861: LD_VAR 0 2
31865: ARRAY
31866: PUSH
31867: LD_EXP 78
31871: PUSH
31872: LD_VAR 0 2
31876: ARRAY
31877: UNION
31878: PPUSH
31879: LD_INT 33
31881: PUSH
31882: LD_INT 2
31884: PUSH
31885: EMPTY
31886: LIST
31887: LIST
31888: PPUSH
31889: CALL_OW 72
31893: NOT
31894: OR
31895: IFFALSE 31899
// continue ;
31897: GO 31804
// cts := UnitFilter ( mc_bases [ i ] , [ f_btype , b_control_tower ] ) ;
31899: LD_ADDR_VAR 0 9
31903: PUSH
31904: LD_EXP 56
31908: PUSH
31909: LD_VAR 0 2
31913: ARRAY
31914: PPUSH
31915: LD_INT 30
31917: PUSH
31918: LD_INT 36
31920: PUSH
31921: EMPTY
31922: LIST
31923: LIST
31924: PPUSH
31925: CALL_OW 72
31929: ST_TO_ADDR
// mcts := UnitFilter ( mc_vehicles [ i ] , [ f_weapon , ar_control_tower ] ) ;
31930: LD_ADDR_VAR 0 10
31934: PUSH
31935: LD_EXP 75
31939: PUSH
31940: LD_VAR 0 2
31944: ARRAY
31945: PPUSH
31946: LD_INT 34
31948: PUSH
31949: LD_INT 31
31951: PUSH
31952: EMPTY
31953: LIST
31954: LIST
31955: PPUSH
31956: CALL_OW 72
31960: ST_TO_ADDR
// if not cts and not mcts then
31961: LD_VAR 0 9
31965: NOT
31966: PUSH
31967: LD_VAR 0 10
31971: NOT
31972: AND
31973: IFFALSE 31977
// continue ;
31975: GO 31804
// x := cts ;
31977: LD_ADDR_VAR 0 11
31981: PUSH
31982: LD_VAR 0 9
31986: ST_TO_ADDR
// if not x then
31987: LD_VAR 0 11
31991: NOT
31992: IFFALSE 32004
// x := mcts ;
31994: LD_ADDR_VAR 0 11
31998: PUSH
31999: LD_VAR 0 10
32003: ST_TO_ADDR
// if mc_remote_driver [ i ] then
32004: LD_EXP 96
32008: PUSH
32009: LD_VAR 0 2
32013: ARRAY
32014: IFFALSE 32283
// for j in mc_remote_driver [ i ] do
32016: LD_ADDR_VAR 0 3
32020: PUSH
32021: LD_EXP 96
32025: PUSH
32026: LD_VAR 0 2
32030: ARRAY
32031: PUSH
32032: FOR_IN
32033: IFFALSE 32281
// begin if GetClass ( j ) <> 3 then
32035: LD_VAR 0 3
32039: PPUSH
32040: CALL_OW 257
32044: PUSH
32045: LD_INT 3
32047: NONEQUAL
32048: IFFALSE 32101
// begin mc_remote_driver := Replace ( mc_remote_driver , i , mc_remote_driver [ i ] diff j ) ;
32050: LD_ADDR_EXP 96
32054: PUSH
32055: LD_EXP 96
32059: PPUSH
32060: LD_VAR 0 2
32064: PPUSH
32065: LD_EXP 96
32069: PUSH
32070: LD_VAR 0 2
32074: ARRAY
32075: PUSH
32076: LD_VAR 0 3
32080: DIFF
32081: PPUSH
32082: CALL_OW 1
32086: ST_TO_ADDR
// SetTag ( j , 0 ) ;
32087: LD_VAR 0 3
32091: PPUSH
32092: LD_INT 0
32094: PPUSH
32095: CALL_OW 109
// continue ;
32099: GO 32032
// end ; if not IsInUnit ( j ) or ( GetBType ( IsInUnit ( j ) ) <> b_control_tower and not IsDriver ( j ) ) then
32101: LD_VAR 0 3
32105: PPUSH
32106: CALL_OW 310
32110: NOT
32111: PUSH
32112: LD_VAR 0 3
32116: PPUSH
32117: CALL_OW 310
32121: PPUSH
32122: CALL_OW 266
32126: PUSH
32127: LD_INT 36
32129: NONEQUAL
32130: PUSH
32131: LD_VAR 0 3
32135: PPUSH
32136: CALL 80468 0 1
32140: NOT
32141: AND
32142: OR
32143: IFFALSE 32279
// begin if IsInUnit ( j ) then
32145: LD_VAR 0 3
32149: PPUSH
32150: CALL_OW 310
32154: IFFALSE 32165
// ComExitBuilding ( j ) ;
32156: LD_VAR 0 3
32160: PPUSH
32161: CALL_OW 122
// ct := 0 ;
32165: LD_ADDR_VAR 0 8
32169: PUSH
32170: LD_INT 0
32172: ST_TO_ADDR
// for k in x do
32173: LD_ADDR_VAR 0 4
32177: PUSH
32178: LD_VAR 0 11
32182: PUSH
32183: FOR_IN
32184: IFFALSE 32257
// if ( GetWeapon ( k ) = ar_control_tower and not IsDrivenBy ( k ) ) or ( GetBType ( k ) = b_control_tower and UnitsInside ( k ) < 3 ) then
32186: LD_VAR 0 4
32190: PPUSH
32191: CALL_OW 264
32195: PUSH
32196: LD_INT 31
32198: EQUAL
32199: PUSH
32200: LD_VAR 0 4
32204: PPUSH
32205: CALL_OW 311
32209: NOT
32210: AND
32211: PUSH
32212: LD_VAR 0 4
32216: PPUSH
32217: CALL_OW 266
32221: PUSH
32222: LD_INT 36
32224: EQUAL
32225: PUSH
32226: LD_VAR 0 4
32230: PPUSH
32231: CALL_OW 313
32235: PUSH
32236: LD_INT 3
32238: LESS
32239: AND
32240: OR
32241: IFFALSE 32255
// begin ct := k ;
32243: LD_ADDR_VAR 0 8
32247: PUSH
32248: LD_VAR 0 4
32252: ST_TO_ADDR
// break ;
32253: GO 32257
// end ;
32255: GO 32183
32257: POP
32258: POP
// if ct then
32259: LD_VAR 0 8
32263: IFFALSE 32279
// ComEnterUnit ( j , ct ) ;
32265: LD_VAR 0 3
32269: PPUSH
32270: LD_VAR 0 8
32274: PPUSH
32275: CALL_OW 120
// end ; end ;
32279: GO 32032
32281: POP
32282: POP
// places := 0 ;
32283: LD_ADDR_VAR 0 5
32287: PUSH
32288: LD_INT 0
32290: ST_TO_ADDR
// for j = 1 to x do
32291: LD_ADDR_VAR 0 3
32295: PUSH
32296: DOUBLE
32297: LD_INT 1
32299: DEC
32300: ST_TO_ADDR
32301: LD_VAR 0 11
32305: PUSH
32306: FOR_TO
32307: IFFALSE 32362
// if GetWeapon ( x [ j ] ) = ar_control_tower then
32309: LD_VAR 0 11
32313: PUSH
32314: LD_VAR 0 3
32318: ARRAY
32319: PPUSH
32320: CALL_OW 264
32324: PUSH
32325: LD_INT 31
32327: EQUAL
32328: IFFALSE 32346
// places := places + 1 else
32330: LD_ADDR_VAR 0 5
32334: PUSH
32335: LD_VAR 0 5
32339: PUSH
32340: LD_INT 1
32342: PLUS
32343: ST_TO_ADDR
32344: GO 32360
// places := places + 3 ;
32346: LD_ADDR_VAR 0 5
32350: PUSH
32351: LD_VAR 0 5
32355: PUSH
32356: LD_INT 3
32358: PLUS
32359: ST_TO_ADDR
32360: GO 32306
32362: POP
32363: POP
// tmp := SortBySkill ( UnitFilter ( mc_bases [ i ] , [ f_class , 3 ] ) diff mc_remote_driver [ i ] , 3 ) ;
32364: LD_ADDR_VAR 0 6
32368: PUSH
32369: LD_EXP 56
32373: PUSH
32374: LD_VAR 0 2
32378: ARRAY
32379: PPUSH
32380: LD_INT 25
32382: PUSH
32383: LD_INT 3
32385: PUSH
32386: EMPTY
32387: LIST
32388: LIST
32389: PPUSH
32390: CALL_OW 72
32394: PUSH
32395: LD_EXP 96
32399: PUSH
32400: LD_VAR 0 2
32404: ARRAY
32405: DIFF
32406: PPUSH
32407: LD_INT 3
32409: PPUSH
32410: CALL 81368 0 2
32414: ST_TO_ADDR
// if not tmp then
32415: LD_VAR 0 6
32419: NOT
32420: IFFALSE 32424
// continue ;
32422: GO 31804
// places := places - mc_remote_driver [ i ] ;
32424: LD_ADDR_VAR 0 5
32428: PUSH
32429: LD_VAR 0 5
32433: PUSH
32434: LD_EXP 96
32438: PUSH
32439: LD_VAR 0 2
32443: ARRAY
32444: MINUS
32445: ST_TO_ADDR
// if places then
32446: LD_VAR 0 5
32450: IFFALSE 32509
// begin mc_remote_driver := Replace ( mc_remote_driver , i , mc_remote_driver [ i ] union tmp [ 1 ] ) ;
32452: LD_ADDR_EXP 96
32456: PUSH
32457: LD_EXP 96
32461: PPUSH
32462: LD_VAR 0 2
32466: PPUSH
32467: LD_EXP 96
32471: PUSH
32472: LD_VAR 0 2
32476: ARRAY
32477: PUSH
32478: LD_VAR 0 6
32482: PUSH
32483: LD_INT 1
32485: ARRAY
32486: UNION
32487: PPUSH
32488: CALL_OW 1
32492: ST_TO_ADDR
// SetTag ( tmp [ 1 ] , 126 ) ;
32493: LD_VAR 0 6
32497: PUSH
32498: LD_INT 1
32500: ARRAY
32501: PPUSH
32502: LD_INT 126
32504: PPUSH
32505: CALL_OW 109
// end ; end ;
32509: GO 31804
32511: POP
32512: POP
// end ;
32513: LD_VAR 0 1
32517: RET
// export function MC_Back ( base , base_unit_list , unit , class ) ; var i , j , tmp , x , depot ; begin
32518: LD_INT 0
32520: PPUSH
32521: PPUSH
32522: PPUSH
32523: PPUSH
32524: PPUSH
32525: PPUSH
// if not base or not base_unit_list or not unit or not class in [ 1 , 2 , 3 , 4 , 5 , 8 , 9 , 15 , 16 ] then
32526: LD_VAR 0 1
32530: NOT
32531: PUSH
32532: LD_VAR 0 2
32536: NOT
32537: OR
32538: PUSH
32539: LD_VAR 0 3
32543: NOT
32544: OR
32545: PUSH
32546: LD_VAR 0 4
32550: PUSH
32551: LD_INT 1
32553: PUSH
32554: LD_INT 2
32556: PUSH
32557: LD_INT 3
32559: PUSH
32560: LD_INT 4
32562: PUSH
32563: LD_INT 5
32565: PUSH
32566: LD_INT 8
32568: PUSH
32569: LD_INT 9
32571: PUSH
32572: LD_INT 15
32574: PUSH
32575: LD_INT 16
32577: PUSH
32578: EMPTY
32579: LIST
32580: LIST
32581: LIST
32582: LIST
32583: LIST
32584: LIST
32585: LIST
32586: LIST
32587: LIST
32588: IN
32589: NOT
32590: OR
32591: IFFALSE 32595
// exit ;
32593: GO 33495
// base_unit_list := UnitFilter ( base_unit_list , [ [ f_type , unit_building ] , [ f_lives , 250 ] ] ) ;
32595: LD_ADDR_VAR 0 2
32599: PUSH
32600: LD_VAR 0 2
32604: PPUSH
32605: LD_INT 21
32607: PUSH
32608: LD_INT 3
32610: PUSH
32611: EMPTY
32612: LIST
32613: LIST
32614: PUSH
32615: LD_INT 24
32617: PUSH
32618: LD_INT 250
32620: PUSH
32621: EMPTY
32622: LIST
32623: LIST
32624: PUSH
32625: EMPTY
32626: LIST
32627: LIST
32628: PPUSH
32629: CALL_OW 72
32633: ST_TO_ADDR
// case class of 1 , 15 :
32634: LD_VAR 0 4
32638: PUSH
32639: LD_INT 1
32641: DOUBLE
32642: EQUAL
32643: IFTRUE 32653
32645: LD_INT 15
32647: DOUBLE
32648: EQUAL
32649: IFTRUE 32653
32651: GO 32738
32653: POP
// tmp := UnitFilter ( base_unit_list , [ f_or , [ f_btype , b_bunker ] , [ f_btype , b_breastwork ] ] ) ^ UnitFilter ( base_unit_list , [ f_or , [ f_btype , b_armoury ] , [ f_btype , b_barracks ] ] ) ; 2 , 16 :
32654: LD_ADDR_VAR 0 8
32658: PUSH
32659: LD_VAR 0 2
32663: PPUSH
32664: LD_INT 2
32666: PUSH
32667: LD_INT 30
32669: PUSH
32670: LD_INT 32
32672: PUSH
32673: EMPTY
32674: LIST
32675: LIST
32676: PUSH
32677: LD_INT 30
32679: PUSH
32680: LD_INT 31
32682: PUSH
32683: EMPTY
32684: LIST
32685: LIST
32686: PUSH
32687: EMPTY
32688: LIST
32689: LIST
32690: LIST
32691: PPUSH
32692: CALL_OW 72
32696: PUSH
32697: LD_VAR 0 2
32701: PPUSH
32702: LD_INT 2
32704: PUSH
32705: LD_INT 30
32707: PUSH
32708: LD_INT 4
32710: PUSH
32711: EMPTY
32712: LIST
32713: LIST
32714: PUSH
32715: LD_INT 30
32717: PUSH
32718: LD_INT 5
32720: PUSH
32721: EMPTY
32722: LIST
32723: LIST
32724: PUSH
32725: EMPTY
32726: LIST
32727: LIST
32728: LIST
32729: PPUSH
32730: CALL_OW 72
32734: ADD
32735: ST_TO_ADDR
32736: GO 32984
32738: LD_INT 2
32740: DOUBLE
32741: EQUAL
32742: IFTRUE 32752
32744: LD_INT 16
32746: DOUBLE
32747: EQUAL
32748: IFTRUE 32752
32750: GO 32798
32752: POP
// tmp := UnitFilter ( base_unit_list , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) ; 3 :
32753: LD_ADDR_VAR 0 8
32757: PUSH
32758: LD_VAR 0 2
32762: PPUSH
32763: LD_INT 2
32765: PUSH
32766: LD_INT 30
32768: PUSH
32769: LD_INT 0
32771: PUSH
32772: EMPTY
32773: LIST
32774: LIST
32775: PUSH
32776: LD_INT 30
32778: PUSH
32779: LD_INT 1
32781: PUSH
32782: EMPTY
32783: LIST
32784: LIST
32785: PUSH
32786: EMPTY
32787: LIST
32788: LIST
32789: LIST
32790: PPUSH
32791: CALL_OW 72
32795: ST_TO_ADDR
32796: GO 32984
32798: LD_INT 3
32800: DOUBLE
32801: EQUAL
32802: IFTRUE 32806
32804: GO 32852
32806: POP
// tmp := UnitFilter ( base_unit_list , [ f_or , [ f_btype , b_workshop ] , [ f_btype , b_factory ] ] ) ; 4 :
32807: LD_ADDR_VAR 0 8
32811: PUSH
32812: LD_VAR 0 2
32816: PPUSH
32817: LD_INT 2
32819: PUSH
32820: LD_INT 30
32822: PUSH
32823: LD_INT 2
32825: PUSH
32826: EMPTY
32827: LIST
32828: LIST
32829: PUSH
32830: LD_INT 30
32832: PUSH
32833: LD_INT 3
32835: PUSH
32836: EMPTY
32837: LIST
32838: LIST
32839: PUSH
32840: EMPTY
32841: LIST
32842: LIST
32843: LIST
32844: PPUSH
32845: CALL_OW 72
32849: ST_TO_ADDR
32850: GO 32984
32852: LD_INT 4
32854: DOUBLE
32855: EQUAL
32856: IFTRUE 32860
32858: GO 32917
32860: POP
// tmp := UnitFilter ( base_unit_list , [ f_or , [ f_btype , b_lab ] , [ f_btype , b_lab_half ] , [ f_btype , b_lab_full ] ] ) ; 5 , 8 , 9 :
32861: LD_ADDR_VAR 0 8
32865: PUSH
32866: LD_VAR 0 2
32870: PPUSH
32871: LD_INT 2
32873: PUSH
32874: LD_INT 30
32876: PUSH
32877: LD_INT 6
32879: PUSH
32880: EMPTY
32881: LIST
32882: LIST
32883: PUSH
32884: LD_INT 30
32886: PUSH
32887: LD_INT 7
32889: PUSH
32890: EMPTY
32891: LIST
32892: LIST
32893: PUSH
32894: LD_INT 30
32896: PUSH
32897: LD_INT 8
32899: PUSH
32900: EMPTY
32901: LIST
32902: LIST
32903: PUSH
32904: EMPTY
32905: LIST
32906: LIST
32907: LIST
32908: LIST
32909: PPUSH
32910: CALL_OW 72
32914: ST_TO_ADDR
32915: GO 32984
32917: LD_INT 5
32919: DOUBLE
32920: EQUAL
32921: IFTRUE 32937
32923: LD_INT 8
32925: DOUBLE
32926: EQUAL
32927: IFTRUE 32937
32929: LD_INT 9
32931: DOUBLE
32932: EQUAL
32933: IFTRUE 32937
32935: GO 32983
32937: POP
// tmp := UnitFilter ( base_unit_list , [ f_or , [ f_btype , b_armoury ] , [ f_btype , b_barracks ] ] ) ; end ;
32938: LD_ADDR_VAR 0 8
32942: PUSH
32943: LD_VAR 0 2
32947: PPUSH
32948: LD_INT 2
32950: PUSH
32951: LD_INT 30
32953: PUSH
32954: LD_INT 4
32956: PUSH
32957: EMPTY
32958: LIST
32959: LIST
32960: PUSH
32961: LD_INT 30
32963: PUSH
32964: LD_INT 5
32966: PUSH
32967: EMPTY
32968: LIST
32969: LIST
32970: PUSH
32971: EMPTY
32972: LIST
32973: LIST
32974: LIST
32975: PPUSH
32976: CALL_OW 72
32980: ST_TO_ADDR
32981: GO 32984
32983: POP
// if not tmp then
32984: LD_VAR 0 8
32988: NOT
32989: IFFALSE 32993
// exit ;
32991: GO 33495
// if class in [ 1 , 15 ] and mc_empty_turret_list [ base ] then
32993: LD_VAR 0 4
32997: PUSH
32998: LD_INT 1
33000: PUSH
33001: LD_INT 15
33003: PUSH
33004: EMPTY
33005: LIST
33006: LIST
33007: IN
33008: PUSH
33009: LD_EXP 65
33013: PUSH
33014: LD_VAR 0 1
33018: ARRAY
33019: AND
33020: IFFALSE 33176
// begin x := mc_empty_turret_list [ base ] [ 1 ] ;
33022: LD_ADDR_VAR 0 9
33026: PUSH
33027: LD_EXP 65
33031: PUSH
33032: LD_VAR 0 1
33036: ARRAY
33037: PUSH
33038: LD_INT 1
33040: ARRAY
33041: ST_TO_ADDR
// if not x in mc_busy_turret_list [ base ] then
33042: LD_VAR 0 9
33046: PUSH
33047: LD_EXP 66
33051: PUSH
33052: LD_VAR 0 1
33056: ARRAY
33057: IN
33058: NOT
33059: IFFALSE 33174
// begin mc_busy_turret_list := ReplaceIn ( mc_busy_turret_list , [ base , mc_busy_turret_list [ base ] + 1 ] , x ) ;
33061: LD_ADDR_EXP 66
33065: PUSH
33066: LD_EXP 66
33070: PPUSH
33071: LD_VAR 0 1
33075: PUSH
33076: LD_EXP 66
33080: PUSH
33081: LD_VAR 0 1
33085: ARRAY
33086: PUSH
33087: LD_INT 1
33089: PLUS
33090: PUSH
33091: EMPTY
33092: LIST
33093: LIST
33094: PPUSH
33095: LD_VAR 0 9
33099: PPUSH
33100: CALL 47120 0 3
33104: ST_TO_ADDR
// mc_empty_turret_list := Replace ( mc_empty_turret_list , base , mc_empty_turret_list [ base ] diff x ) ;
33105: LD_ADDR_EXP 65
33109: PUSH
33110: LD_EXP 65
33114: PPUSH
33115: LD_VAR 0 1
33119: PPUSH
33120: LD_EXP 65
33124: PUSH
33125: LD_VAR 0 1
33129: ARRAY
33130: PUSH
33131: LD_VAR 0 9
33135: DIFF
33136: PPUSH
33137: CALL_OW 1
33141: ST_TO_ADDR
// ComEnterUnit ( unit , mc_busy_turret_list [ base ] [ mc_busy_turret_list [ base ] ] ) ;
33142: LD_VAR 0 3
33146: PPUSH
33147: LD_EXP 66
33151: PUSH
33152: LD_VAR 0 1
33156: ARRAY
33157: PUSH
33158: LD_EXP 66
33162: PUSH
33163: LD_VAR 0 1
33167: ARRAY
33168: ARRAY
33169: PPUSH
33170: CALL_OW 120
// end ; exit ;
33174: GO 33495
// end ; if tmp > 1 then
33176: LD_VAR 0 8
33180: PUSH
33181: LD_INT 1
33183: GREATER
33184: IFFALSE 33288
// for i = 2 to tmp do
33186: LD_ADDR_VAR 0 6
33190: PUSH
33191: DOUBLE
33192: LD_INT 2
33194: DEC
33195: ST_TO_ADDR
33196: LD_VAR 0 8
33200: PUSH
33201: FOR_TO
33202: IFFALSE 33286
// if BuildingStatus ( tmp [ i ] ) = bs_need_people then
33204: LD_VAR 0 8
33208: PUSH
33209: LD_VAR 0 6
33213: ARRAY
33214: PPUSH
33215: CALL_OW 461
33219: PUSH
33220: LD_INT 6
33222: EQUAL
33223: IFFALSE 33284
// begin x := tmp [ i ] ;
33225: LD_ADDR_VAR 0 9
33229: PUSH
33230: LD_VAR 0 8
33234: PUSH
33235: LD_VAR 0 6
33239: ARRAY
33240: ST_TO_ADDR
// tmp := Delete ( tmp , i ) ;
33241: LD_ADDR_VAR 0 8
33245: PUSH
33246: LD_VAR 0 8
33250: PPUSH
33251: LD_VAR 0 6
33255: PPUSH
33256: CALL_OW 3
33260: ST_TO_ADDR
// tmp := Insert ( tmp , 1 , x ) ;
33261: LD_ADDR_VAR 0 8
33265: PUSH
33266: LD_VAR 0 8
33270: PPUSH
33271: LD_INT 1
33273: PPUSH
33274: LD_VAR 0 9
33278: PPUSH
33279: CALL_OW 2
33283: ST_TO_ADDR
// end ;
33284: GO 33201
33286: POP
33287: POP
// for i in tmp do
33288: LD_ADDR_VAR 0 6
33292: PUSH
33293: LD_VAR 0 8
33297: PUSH
33298: FOR_IN
33299: IFFALSE 33368
// begin if ( UnitsInside ( i ) < 6 and not GetBType ( i ) in [ b_breastwork , b_bunker ] ) or UnitsInside ( i ) = 0 then
33301: LD_VAR 0 6
33305: PPUSH
33306: CALL_OW 313
33310: PUSH
33311: LD_INT 6
33313: LESS
33314: PUSH
33315: LD_VAR 0 6
33319: PPUSH
33320: CALL_OW 266
33324: PUSH
33325: LD_INT 31
33327: PUSH
33328: LD_INT 32
33330: PUSH
33331: EMPTY
33332: LIST
33333: LIST
33334: IN
33335: NOT
33336: AND
33337: PUSH
33338: LD_VAR 0 6
33342: PPUSH
33343: CALL_OW 313
33347: PUSH
33348: LD_INT 0
33350: EQUAL
33351: OR
33352: IFFALSE 33366
// begin j := i ;
33354: LD_ADDR_VAR 0 7
33358: PUSH
33359: LD_VAR 0 6
33363: ST_TO_ADDR
// break ;
33364: GO 33368
// end ; end ;
33366: GO 33298
33368: POP
33369: POP
// if j then
33370: LD_VAR 0 7
33374: IFFALSE 33392
// ComEnterUnit ( unit , j ) else
33376: LD_VAR 0 3
33380: PPUSH
33381: LD_VAR 0 7
33385: PPUSH
33386: CALL_OW 120
33390: GO 33495
// begin depot := UnitFilter ( base_unit_list , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) ;
33392: LD_ADDR_VAR 0 10
33396: PUSH
33397: LD_VAR 0 2
33401: PPUSH
33402: LD_INT 2
33404: PUSH
33405: LD_INT 30
33407: PUSH
33408: LD_INT 0
33410: PUSH
33411: EMPTY
33412: LIST
33413: LIST
33414: PUSH
33415: LD_INT 30
33417: PUSH
33418: LD_INT 1
33420: PUSH
33421: EMPTY
33422: LIST
33423: LIST
33424: PUSH
33425: EMPTY
33426: LIST
33427: LIST
33428: LIST
33429: PPUSH
33430: CALL_OW 72
33434: ST_TO_ADDR
// if depot then
33435: LD_VAR 0 10
33439: IFFALSE 33495
// begin depot := NearestUnitToUnit ( depot , unit ) ;
33441: LD_ADDR_VAR 0 10
33445: PUSH
33446: LD_VAR 0 10
33450: PPUSH
33451: LD_VAR 0 3
33455: PPUSH
33456: CALL_OW 74
33460: ST_TO_ADDR
// if GetDistUnits ( unit , depot ) > 10 then
33461: LD_VAR 0 3
33465: PPUSH
33466: LD_VAR 0 10
33470: PPUSH
33471: CALL_OW 296
33475: PUSH
33476: LD_INT 10
33478: GREATER
33479: IFFALSE 33495
// ComStandNearbyBuilding ( unit , depot ) ;
33481: LD_VAR 0 3
33485: PPUSH
33486: LD_VAR 0 10
33490: PPUSH
33491: CALL 41687 0 2
// end ; end ; end ;
33495: LD_VAR 0 5
33499: RET
// export function MC_Idle ( ) ; var i , j , tmp ; begin
33500: LD_INT 0
33502: PPUSH
33503: PPUSH
33504: PPUSH
33505: PPUSH
// if not mc_bases then
33506: LD_EXP 56
33510: NOT
33511: IFFALSE 33515
// exit ;
33513: GO 33754
// for i = 1 to mc_bases do
33515: LD_ADDR_VAR 0 2
33519: PUSH
33520: DOUBLE
33521: LD_INT 1
33523: DEC
33524: ST_TO_ADDR
33525: LD_EXP 56
33529: PUSH
33530: FOR_TO
33531: IFFALSE 33752
// begin tmp := UnitFilter ( mc_bases [ i ] , [ f_type , unit_human ] ) union mc_ape [ i ] ;
33533: LD_ADDR_VAR 0 4
33537: PUSH
33538: LD_EXP 56
33542: PUSH
33543: LD_VAR 0 2
33547: ARRAY
33548: PPUSH
33549: LD_INT 21
33551: PUSH
33552: LD_INT 1
33554: PUSH
33555: EMPTY
33556: LIST
33557: LIST
33558: PPUSH
33559: CALL_OW 72
33563: PUSH
33564: LD_EXP 85
33568: PUSH
33569: LD_VAR 0 2
33573: ARRAY
33574: UNION
33575: ST_TO_ADDR
// if not tmp then
33576: LD_VAR 0 4
33580: NOT
33581: IFFALSE 33585
// continue ;
33583: GO 33530
// for j in tmp do
33585: LD_ADDR_VAR 0 3
33589: PUSH
33590: LD_VAR 0 4
33594: PUSH
33595: FOR_IN
33596: IFFALSE 33748
// begin if not GetTag ( j ) and not HasTask ( j ) and not IsDrivenBy ( j ) and not IsInUnit ( j ) and not j in mc_need_heal [ i ] [ 1 ] and not j in mc_need_heal [ i ] [ 2 ] and not j in mc_repair_vehicle [ i ] then
33598: LD_VAR 0 3
33602: PPUSH
33603: CALL_OW 110
33607: NOT
33608: PUSH
33609: LD_VAR 0 3
33613: PPUSH
33614: CALL_OW 314
33618: NOT
33619: AND
33620: PUSH
33621: LD_VAR 0 3
33625: PPUSH
33626: CALL_OW 311
33630: NOT
33631: AND
33632: PUSH
33633: LD_VAR 0 3
33637: PPUSH
33638: CALL_OW 310
33642: NOT
33643: AND
33644: PUSH
33645: LD_VAR 0 3
33649: PUSH
33650: LD_EXP 59
33654: PUSH
33655: LD_VAR 0 2
33659: ARRAY
33660: PUSH
33661: LD_INT 1
33663: ARRAY
33664: IN
33665: NOT
33666: AND
33667: PUSH
33668: LD_VAR 0 3
33672: PUSH
33673: LD_EXP 59
33677: PUSH
33678: LD_VAR 0 2
33682: ARRAY
33683: PUSH
33684: LD_INT 2
33686: ARRAY
33687: IN
33688: NOT
33689: AND
33690: PUSH
33691: LD_VAR 0 3
33695: PUSH
33696: LD_EXP 68
33700: PUSH
33701: LD_VAR 0 2
33705: ARRAY
33706: IN
33707: NOT
33708: AND
33709: IFFALSE 33746
// MC_Back ( i , mc_bases [ i ] , j , GetClass ( j ) ) ;
33711: LD_VAR 0 2
33715: PPUSH
33716: LD_EXP 56
33720: PUSH
33721: LD_VAR 0 2
33725: ARRAY
33726: PPUSH
33727: LD_VAR 0 3
33731: PPUSH
33732: LD_VAR 0 3
33736: PPUSH
33737: CALL_OW 257
33741: PPUSH
33742: CALL 32518 0 4
// end ;
33746: GO 33595
33748: POP
33749: POP
// end ;
33750: GO 33530
33752: POP
33753: POP
// end ;
33754: LD_VAR 0 1
33758: RET
// export function MC_SetMinesField ( base , amount , area ) ; var i , tmp , list , x , j ; begin
33759: LD_INT 0
33761: PPUSH
33762: PPUSH
33763: PPUSH
33764: PPUSH
33765: PPUSH
33766: PPUSH
// if not mc_bases [ base ] then
33767: LD_EXP 56
33771: PUSH
33772: LD_VAR 0 1
33776: ARRAY
33777: NOT
33778: IFFALSE 33782
// exit ;
33780: GO 33964
// tmp := [ ] ;
33782: LD_ADDR_VAR 0 6
33786: PUSH
33787: EMPTY
33788: ST_TO_ADDR
// list := AreaToList ( area , 0 ) ;
33789: LD_ADDR_VAR 0 7
33793: PUSH
33794: LD_VAR 0 3
33798: PPUSH
33799: LD_INT 0
33801: PPUSH
33802: CALL_OW 517
33806: ST_TO_ADDR
// if not list then
33807: LD_VAR 0 7
33811: NOT
33812: IFFALSE 33816
// exit ;
33814: GO 33964
// for i = 1 to amount do
33816: LD_ADDR_VAR 0 5
33820: PUSH
33821: DOUBLE
33822: LD_INT 1
33824: DEC
33825: ST_TO_ADDR
33826: LD_VAR 0 2
33830: PUSH
33831: FOR_TO
33832: IFFALSE 33912
// begin x := rand ( 1 , list [ 1 ] ) ;
33834: LD_ADDR_VAR 0 8
33838: PUSH
33839: LD_INT 1
33841: PPUSH
33842: LD_VAR 0 7
33846: PUSH
33847: LD_INT 1
33849: ARRAY
33850: PPUSH
33851: CALL_OW 12
33855: ST_TO_ADDR
// tmp := Replace ( tmp , i , [ list [ 1 ] [ x ] , list [ 2 ] [ x ] ] ) ;
33856: LD_ADDR_VAR 0 6
33860: PUSH
33861: LD_VAR 0 6
33865: PPUSH
33866: LD_VAR 0 5
33870: PPUSH
33871: LD_VAR 0 7
33875: PUSH
33876: LD_INT 1
33878: ARRAY
33879: PUSH
33880: LD_VAR 0 8
33884: ARRAY
33885: PUSH
33886: LD_VAR 0 7
33890: PUSH
33891: LD_INT 2
33893: ARRAY
33894: PUSH
33895: LD_VAR 0 8
33899: ARRAY
33900: PUSH
33901: EMPTY
33902: LIST
33903: LIST
33904: PPUSH
33905: CALL_OW 1
33909: ST_TO_ADDR
// end ;
33910: GO 33831
33912: POP
33913: POP
// mc_mines := Replace ( mc_mines , base , tmp ) ;
33914: LD_ADDR_EXP 69
33918: PUSH
33919: LD_EXP 69
33923: PPUSH
33924: LD_VAR 0 1
33928: PPUSH
33929: LD_VAR 0 6
33933: PPUSH
33934: CALL_OW 1
33938: ST_TO_ADDR
// mc_minefields := Replace ( mc_minefields , base , area ) ;
33939: LD_ADDR_EXP 71
33943: PUSH
33944: LD_EXP 71
33948: PPUSH
33949: LD_VAR 0 1
33953: PPUSH
33954: LD_VAR 0 3
33958: PPUSH
33959: CALL_OW 1
33963: ST_TO_ADDR
// end ;
33964: LD_VAR 0 4
33968: RET
// export function MC_SetBuildingList ( base , construct_list ) ; begin
33969: LD_INT 0
33971: PPUSH
// if not mc_bases [ base ] then
33972: LD_EXP 56
33976: PUSH
33977: LD_VAR 0 1
33981: ARRAY
33982: NOT
33983: IFFALSE 33987
// exit ;
33985: GO 34012
// mc_build_list := Replace ( mc_build_list , base , construct_list ) ;
33987: LD_ADDR_EXP 61
33991: PUSH
33992: LD_EXP 61
33996: PPUSH
33997: LD_VAR 0 1
34001: PPUSH
34002: LD_VAR 0 2
34006: PPUSH
34007: CALL_OW 1
34011: ST_TO_ADDR
// end ;
34012: LD_VAR 0 3
34016: RET
// export function MC_InsertBuildingList ( base , list ) ; begin
34017: LD_INT 0
34019: PPUSH
// if not mc_bases [ base ] then
34020: LD_EXP 56
34024: PUSH
34025: LD_VAR 0 1
34029: ARRAY
34030: NOT
34031: IFFALSE 34035
// exit ;
34033: GO 34072
// mc_build_list := Replace ( mc_build_list , base , mc_build_list [ base ] union list ) ;
34035: LD_ADDR_EXP 61
34039: PUSH
34040: LD_EXP 61
34044: PPUSH
34045: LD_VAR 0 1
34049: PPUSH
34050: LD_EXP 61
34054: PUSH
34055: LD_VAR 0 1
34059: ARRAY
34060: PUSH
34061: LD_VAR 0 2
34065: UNION
34066: PPUSH
34067: CALL_OW 1
34071: ST_TO_ADDR
// end ;
34072: LD_VAR 0 3
34076: RET
// export function MC_SetProduceList ( base , produce_list ) ; begin
34077: LD_INT 0
34079: PPUSH
// if not mc_bases [ base ] then
34080: LD_EXP 56
34084: PUSH
34085: LD_VAR 0 1
34089: ARRAY
34090: NOT
34091: IFFALSE 34095
// exit ;
34093: GO 34120
// mc_produce := Replace ( mc_produce , base , produce_list ) ;
34095: LD_ADDR_EXP 77
34099: PUSH
34100: LD_EXP 77
34104: PPUSH
34105: LD_VAR 0 1
34109: PPUSH
34110: LD_VAR 0 2
34114: PPUSH
34115: CALL_OW 1
34119: ST_TO_ADDR
// end ;
34120: LD_VAR 0 3
34124: RET
// export function MC_InsertProduceList ( base , components ) ; begin
34125: LD_INT 0
34127: PPUSH
// if not mc_bases [ base ] then
34128: LD_EXP 56
34132: PUSH
34133: LD_VAR 0 1
34137: ARRAY
34138: NOT
34139: IFFALSE 34143
// exit ;
34141: GO 34180
// mc_produce := Replace ( mc_produce , base , mc_produce [ base ] ^ components ) ;
34143: LD_ADDR_EXP 77
34147: PUSH
34148: LD_EXP 77
34152: PPUSH
34153: LD_VAR 0 1
34157: PPUSH
34158: LD_EXP 77
34162: PUSH
34163: LD_VAR 0 1
34167: ARRAY
34168: PUSH
34169: LD_VAR 0 2
34173: ADD
34174: PPUSH
34175: CALL_OW 1
34179: ST_TO_ADDR
// end ;
34180: LD_VAR 0 3
34184: RET
// export function MC_SetDefenderList ( base , deflist ) ; begin
34185: LD_INT 0
34187: PPUSH
// if not mc_bases [ base ] then
34188: LD_EXP 56
34192: PUSH
34193: LD_VAR 0 1
34197: ARRAY
34198: NOT
34199: IFFALSE 34203
// exit ;
34201: GO 34257
// mc_defender := Replace ( mc_defender , base , deflist ) ;
34203: LD_ADDR_EXP 78
34207: PUSH
34208: LD_EXP 78
34212: PPUSH
34213: LD_VAR 0 1
34217: PPUSH
34218: LD_VAR 0 2
34222: PPUSH
34223: CALL_OW 1
34227: ST_TO_ADDR
// mc_defender_limit := Replace ( mc_defender_limit , base , deflist + 0 ) ;
34228: LD_ADDR_EXP 67
34232: PUSH
34233: LD_EXP 67
34237: PPUSH
34238: LD_VAR 0 1
34242: PPUSH
34243: LD_VAR 0 2
34247: PUSH
34248: LD_INT 0
34250: PLUS
34251: PPUSH
34252: CALL_OW 1
34256: ST_TO_ADDR
// end ;
34257: LD_VAR 0 3
34261: RET
// export function MC_SetDefenderLimit ( base , limit ) ; begin
34262: LD_INT 0
34264: PPUSH
// if not mc_bases [ base ] then
34265: LD_EXP 56
34269: PUSH
34270: LD_VAR 0 1
34274: ARRAY
34275: NOT
34276: IFFALSE 34280
// exit ;
34278: GO 34305
// mc_defender_limit := Replace ( mc_defender_limit , base , limit ) ;
34280: LD_ADDR_EXP 67
34284: PUSH
34285: LD_EXP 67
34289: PPUSH
34290: LD_VAR 0 1
34294: PPUSH
34295: LD_VAR 0 2
34299: PPUSH
34300: CALL_OW 1
34304: ST_TO_ADDR
// end ;
34305: LD_VAR 0 3
34309: RET
// export function MC_PrepareAttack ( base , group , path , flags ) ; var i , j , tmp ; begin
34310: LD_INT 0
34312: PPUSH
34313: PPUSH
34314: PPUSH
34315: PPUSH
// if not mc_bases [ base ] then
34316: LD_EXP 56
34320: PUSH
34321: LD_VAR 0 1
34325: ARRAY
34326: NOT
34327: IFFALSE 34331
// exit ;
34329: GO 34396
// mc_attack := ReplaceIn ( mc_attack , [ base , mc_attack [ base ] + 1 ] , [ base , group , path , flags ] ) ;
34331: LD_ADDR_EXP 76
34335: PUSH
34336: LD_EXP 76
34340: PPUSH
34341: LD_VAR 0 1
34345: PUSH
34346: LD_EXP 76
34350: PUSH
34351: LD_VAR 0 1
34355: ARRAY
34356: PUSH
34357: LD_INT 1
34359: PLUS
34360: PUSH
34361: EMPTY
34362: LIST
34363: LIST
34364: PPUSH
34365: LD_VAR 0 1
34369: PUSH
34370: LD_VAR 0 2
34374: PUSH
34375: LD_VAR 0 3
34379: PUSH
34380: LD_VAR 0 4
34384: PUSH
34385: EMPTY
34386: LIST
34387: LIST
34388: LIST
34389: LIST
34390: PPUSH
34391: CALL 47120 0 3
34395: ST_TO_ADDR
// end ;
34396: LD_VAR 0 5
34400: RET
// export function MC_SetDepositsXY ( base , deposits_list ) ; begin
34401: LD_INT 0
34403: PPUSH
// if not mc_bases [ base ] then
34404: LD_EXP 56
34408: PUSH
34409: LD_VAR 0 1
34413: ARRAY
34414: NOT
34415: IFFALSE 34419
// exit ;
34417: GO 34444
// mc_deposits_xy := Replace ( mc_deposits_xy , base , deposits_list ) ;
34419: LD_ADDR_EXP 93
34423: PUSH
34424: LD_EXP 93
34428: PPUSH
34429: LD_VAR 0 1
34433: PPUSH
34434: LD_VAR 0 2
34438: PPUSH
34439: CALL_OW 1
34443: ST_TO_ADDR
// end ;
34444: LD_VAR 0 3
34448: RET
// export function MC_GetMinesField ( base ) ; begin
34449: LD_INT 0
34451: PPUSH
// result := mc_mines [ base ] ;
34452: LD_ADDR_VAR 0 2
34456: PUSH
34457: LD_EXP 69
34461: PUSH
34462: LD_VAR 0 1
34466: ARRAY
34467: ST_TO_ADDR
// end ;
34468: LD_VAR 0 2
34472: RET
// export function MC_GetProduceList ( base ) ; begin
34473: LD_INT 0
34475: PPUSH
// result := mc_produce [ base ] ;
34476: LD_ADDR_VAR 0 2
34480: PUSH
34481: LD_EXP 77
34485: PUSH
34486: LD_VAR 0 1
34490: ARRAY
34491: ST_TO_ADDR
// end ;
34492: LD_VAR 0 2
34496: RET
// export function MC_GetBuilding ( base , btype ) ; var i ; begin
34497: LD_INT 0
34499: PPUSH
34500: PPUSH
// if not mc_bases then
34501: LD_EXP 56
34505: NOT
34506: IFFALSE 34510
// exit ;
34508: GO 34575
// if mc_bases [ base ] then
34510: LD_EXP 56
34514: PUSH
34515: LD_VAR 0 1
34519: ARRAY
34520: IFFALSE 34575
// begin result := UnitFilter ( mc_bases [ base ] , [ f_btype , btype ] ) ;
34522: LD_ADDR_VAR 0 3
34526: PUSH
34527: LD_EXP 56
34531: PUSH
34532: LD_VAR 0 1
34536: ARRAY
34537: PPUSH
34538: LD_INT 30
34540: PUSH
34541: LD_VAR 0 2
34545: PUSH
34546: EMPTY
34547: LIST
34548: LIST
34549: PPUSH
34550: CALL_OW 72
34554: ST_TO_ADDR
// if result then
34555: LD_VAR 0 3
34559: IFFALSE 34575
// result := result [ 1 ] ;
34561: LD_ADDR_VAR 0 3
34565: PUSH
34566: LD_VAR 0 3
34570: PUSH
34571: LD_INT 1
34573: ARRAY
34574: ST_TO_ADDR
// end ; end ;
34575: LD_VAR 0 3
34579: RET
// export function MC_GetBuildings ( base , btype ) ; var i ; begin
34580: LD_INT 0
34582: PPUSH
34583: PPUSH
// if not mc_bases then
34584: LD_EXP 56
34588: NOT
34589: IFFALSE 34593
// exit ;
34591: GO 34638
// if mc_bases [ base ] then
34593: LD_EXP 56
34597: PUSH
34598: LD_VAR 0 1
34602: ARRAY
34603: IFFALSE 34638
// result := UnitFilter ( mc_bases [ base ] , [ f_btype , btype ] ) ;
34605: LD_ADDR_VAR 0 3
34609: PUSH
34610: LD_EXP 56
34614: PUSH
34615: LD_VAR 0 1
34619: ARRAY
34620: PPUSH
34621: LD_INT 30
34623: PUSH
34624: LD_VAR 0 2
34628: PUSH
34629: EMPTY
34630: LIST
34631: LIST
34632: PPUSH
34633: CALL_OW 72
34637: ST_TO_ADDR
// end ;
34638: LD_VAR 0 3
34642: RET
// export function MC_SetTame ( base , area ) ; begin
34643: LD_INT 0
34645: PPUSH
// if not mc_bases or not base then
34646: LD_EXP 56
34650: NOT
34651: PUSH
34652: LD_VAR 0 1
34656: NOT
34657: OR
34658: IFFALSE 34662
// exit ;
34660: GO 34687
// mc_can_tame := Replace ( mc_can_tame , base , area ) ;
34662: LD_ADDR_EXP 84
34666: PUSH
34667: LD_EXP 84
34671: PPUSH
34672: LD_VAR 0 1
34676: PPUSH
34677: LD_VAR 0 2
34681: PPUSH
34682: CALL_OW 1
34686: ST_TO_ADDR
// end ;
34687: LD_VAR 0 3
34691: RET
// export function MC_SetUpgradeBuilding ( base , btype ) ; var tmp ; begin
34692: LD_INT 0
34694: PPUSH
34695: PPUSH
// if not mc_bases or not base then
34696: LD_EXP 56
34700: NOT
34701: PUSH
34702: LD_VAR 0 1
34706: NOT
34707: OR
34708: IFFALSE 34712
// exit ;
34710: GO 34814
// tmp := UnitFilter ( mc_bases [ base ] , [ f_btype , btype ] ) ;
34712: LD_ADDR_VAR 0 4
34716: PUSH
34717: LD_EXP 56
34721: PUSH
34722: LD_VAR 0 1
34726: ARRAY
34727: PPUSH
34728: LD_INT 30
34730: PUSH
34731: LD_VAR 0 2
34735: PUSH
34736: EMPTY
34737: LIST
34738: LIST
34739: PPUSH
34740: CALL_OW 72
34744: ST_TO_ADDR
// if not tmp then
34745: LD_VAR 0 4
34749: NOT
34750: IFFALSE 34754
// exit ;
34752: GO 34814
// mc_build_upgrade := Replace ( mc_build_upgrade , base , Insert ( mc_build_upgrade [ base ] , mc_build_upgrade [ base ] + 1 , tmp [ 1 ] ) ) ;
34754: LD_ADDR_EXP 88
34758: PUSH
34759: LD_EXP 88
34763: PPUSH
34764: LD_VAR 0 1
34768: PPUSH
34769: LD_EXP 88
34773: PUSH
34774: LD_VAR 0 1
34778: ARRAY
34779: PPUSH
34780: LD_EXP 88
34784: PUSH
34785: LD_VAR 0 1
34789: ARRAY
34790: PUSH
34791: LD_INT 1
34793: PLUS
34794: PPUSH
34795: LD_VAR 0 4
34799: PUSH
34800: LD_INT 1
34802: ARRAY
34803: PPUSH
34804: CALL_OW 2
34808: PPUSH
34809: CALL_OW 1
34813: ST_TO_ADDR
// end ;
34814: LD_VAR 0 3
34818: RET
// export function MC_SetLabKind ( base , kinds ) ; var i ; begin
34819: LD_INT 0
34821: PPUSH
34822: PPUSH
// if not mc_bases or not base or not kinds then
34823: LD_EXP 56
34827: NOT
34828: PUSH
34829: LD_VAR 0 1
34833: NOT
34834: OR
34835: PUSH
34836: LD_VAR 0 2
34840: NOT
34841: OR
34842: IFFALSE 34846
// exit ;
34844: GO 34907
// for i in kinds do
34846: LD_ADDR_VAR 0 4
34850: PUSH
34851: LD_VAR 0 2
34855: PUSH
34856: FOR_IN
34857: IFFALSE 34905
// mc_lab_upgrade := ReplaceIn ( mc_lab_upgrade , [ base , mc_lab_upgrade [ base ] + 1 ] , i ) ;
34859: LD_ADDR_EXP 90
34863: PUSH
34864: LD_EXP 90
34868: PPUSH
34869: LD_VAR 0 1
34873: PUSH
34874: LD_EXP 90
34878: PUSH
34879: LD_VAR 0 1
34883: ARRAY
34884: PUSH
34885: LD_INT 1
34887: PLUS
34888: PUSH
34889: EMPTY
34890: LIST
34891: LIST
34892: PPUSH
34893: LD_VAR 0 4
34897: PPUSH
34898: CALL 47120 0 3
34902: ST_TO_ADDR
34903: GO 34856
34905: POP
34906: POP
// end ;
34907: LD_VAR 0 3
34911: RET
// export function MC_SetCratesArea ( base , areas ) ; begin
34912: LD_INT 0
34914: PPUSH
// if not mc_bases or not base or not areas then
34915: LD_EXP 56
34919: NOT
34920: PUSH
34921: LD_VAR 0 1
34925: NOT
34926: OR
34927: PUSH
34928: LD_VAR 0 2
34932: NOT
34933: OR
34934: IFFALSE 34938
// exit ;
34936: GO 34963
// mc_crates_area := Replace ( mc_crates_area , base , areas ) ;
34938: LD_ADDR_EXP 74
34942: PUSH
34943: LD_EXP 74
34947: PPUSH
34948: LD_VAR 0 1
34952: PPUSH
34953: LD_VAR 0 2
34957: PPUSH
34958: CALL_OW 1
34962: ST_TO_ADDR
// end ;
34963: LD_VAR 0 3
34967: RET
// export function MC_SetTeleportExit ( base , teleports_exit ) ; begin
34968: LD_INT 0
34970: PPUSH
// if not mc_bases or not base or not teleports_exit then
34971: LD_EXP 56
34975: NOT
34976: PUSH
34977: LD_VAR 0 1
34981: NOT
34982: OR
34983: PUSH
34984: LD_VAR 0 2
34988: NOT
34989: OR
34990: IFFALSE 34994
// exit ;
34992: GO 35019
// mc_teleport_exit := Replace ( mc_teleport_exit , base , teleports_exit ) ;
34994: LD_ADDR_EXP 91
34998: PUSH
34999: LD_EXP 91
35003: PPUSH
35004: LD_VAR 0 1
35008: PPUSH
35009: LD_VAR 0 2
35013: PPUSH
35014: CALL_OW 1
35018: ST_TO_ADDR
// end ;
35019: LD_VAR 0 3
35023: RET
// export function MC_SetFactoryExtension ( base , x , y , d , ext_list ) ; var i , tmp ; begin
35024: LD_INT 0
35026: PPUSH
35027: PPUSH
35028: PPUSH
// if not mc_bases or not base or not ext_list then
35029: LD_EXP 56
35033: NOT
35034: PUSH
35035: LD_VAR 0 1
35039: NOT
35040: OR
35041: PUSH
35042: LD_VAR 0 5
35046: NOT
35047: OR
35048: IFFALSE 35052
// exit ;
35050: GO 35225
// tmp := GetFacExtXYD ( x , y , d ) ;
35052: LD_ADDR_VAR 0 8
35056: PUSH
35057: LD_VAR 0 2
35061: PPUSH
35062: LD_VAR 0 3
35066: PPUSH
35067: LD_VAR 0 4
35071: PPUSH
35072: CALL 80498 0 3
35076: ST_TO_ADDR
// if not tmp then
35077: LD_VAR 0 8
35081: NOT
35082: IFFALSE 35086
// exit ;
35084: GO 35225
// for i in tmp do
35086: LD_ADDR_VAR 0 7
35090: PUSH
35091: LD_VAR 0 8
35095: PUSH
35096: FOR_IN
35097: IFFALSE 35223
// begin mc_build_list := Replace ( mc_build_list , base , Insert ( mc_build_list [ base ] , mc_build_list [ base ] + 1 , [ ext_list [ 1 ] , i [ 1 ] , i [ 2 ] , i [ 3 ] ] ) ) ;
35099: LD_ADDR_EXP 61
35103: PUSH
35104: LD_EXP 61
35108: PPUSH
35109: LD_VAR 0 1
35113: PPUSH
35114: LD_EXP 61
35118: PUSH
35119: LD_VAR 0 1
35123: ARRAY
35124: PPUSH
35125: LD_EXP 61
35129: PUSH
35130: LD_VAR 0 1
35134: ARRAY
35135: PUSH
35136: LD_INT 1
35138: PLUS
35139: PPUSH
35140: LD_VAR 0 5
35144: PUSH
35145: LD_INT 1
35147: ARRAY
35148: PUSH
35149: LD_VAR 0 7
35153: PUSH
35154: LD_INT 1
35156: ARRAY
35157: PUSH
35158: LD_VAR 0 7
35162: PUSH
35163: LD_INT 2
35165: ARRAY
35166: PUSH
35167: LD_VAR 0 7
35171: PUSH
35172: LD_INT 3
35174: ARRAY
35175: PUSH
35176: EMPTY
35177: LIST
35178: LIST
35179: LIST
35180: LIST
35181: PPUSH
35182: CALL_OW 2
35186: PPUSH
35187: CALL_OW 1
35191: ST_TO_ADDR
// ext_list := Delete ( ext_list , 1 ) ;
35192: LD_ADDR_VAR 0 5
35196: PUSH
35197: LD_VAR 0 5
35201: PPUSH
35202: LD_INT 1
35204: PPUSH
35205: CALL_OW 3
35209: ST_TO_ADDR
// if not ext_list then
35210: LD_VAR 0 5
35214: NOT
35215: IFFALSE 35221
// exit ;
35217: POP
35218: POP
35219: GO 35225
// end ;
35221: GO 35096
35223: POP
35224: POP
// end ;
35225: LD_VAR 0 6
35229: RET
// export function MC_SetAllowedTurretWeapons ( base , weapon_list ) ; begin
35230: LD_INT 0
35232: PPUSH
// if not mc_bases or not base or not weapon_list then
35233: LD_EXP 56
35237: NOT
35238: PUSH
35239: LD_VAR 0 1
35243: NOT
35244: OR
35245: PUSH
35246: LD_VAR 0 2
35250: NOT
35251: OR
35252: IFFALSE 35256
// exit ;
35254: GO 35281
// mc_allowed_tower_weapons := Replace ( mc_allowed_tower_weapons , base , weapon_list ) ;
35256: LD_ADDR_EXP 95
35260: PUSH
35261: LD_EXP 95
35265: PPUSH
35266: LD_VAR 0 1
35270: PPUSH
35271: LD_VAR 0 2
35275: PPUSH
35276: CALL_OW 1
35280: ST_TO_ADDR
// end ;
35281: LD_VAR 0 3
35285: RET
// export function MC_SetTechList ( base , tech_list ) ; begin
35286: LD_INT 0
35288: PPUSH
// if not mc_bases or not base or not tech_list then
35289: LD_EXP 56
35293: NOT
35294: PUSH
35295: LD_VAR 0 1
35299: NOT
35300: OR
35301: PUSH
35302: LD_VAR 0 2
35306: NOT
35307: OR
35308: IFFALSE 35312
// exit ;
35310: GO 35337
// mc_tech := Replace ( mc_tech , base , tech_list ) ;
35312: LD_ADDR_EXP 83
35316: PUSH
35317: LD_EXP 83
35321: PPUSH
35322: LD_VAR 0 1
35326: PPUSH
35327: LD_VAR 0 2
35331: PPUSH
35332: CALL_OW 1
35336: ST_TO_ADDR
// end ;
35337: LD_VAR 0 3
35341: RET
// export function MC_SetParkingArea ( base , parking_area ) ; begin
35342: LD_INT 0
35344: PPUSH
// if not mc_bases or not parking_area or not base then
35345: LD_EXP 56
35349: NOT
35350: PUSH
35351: LD_VAR 0 2
35355: NOT
35356: OR
35357: PUSH
35358: LD_VAR 0 1
35362: NOT
35363: OR
35364: IFFALSE 35368
// exit ;
35366: GO 35393
// mc_parking := Replace ( mc_parking , base , parking_area ) ;
35368: LD_ADDR_EXP 80
35372: PUSH
35373: LD_EXP 80
35377: PPUSH
35378: LD_VAR 0 1
35382: PPUSH
35383: LD_VAR 0 2
35387: PPUSH
35388: CALL_OW 1
35392: ST_TO_ADDR
// end ;
35393: LD_VAR 0 3
35397: RET
// export function MC_SetScanArea ( base , scan_area ) ; begin
35398: LD_INT 0
35400: PPUSH
// if not mc_bases or not base or not scan_area then
35401: LD_EXP 56
35405: NOT
35406: PUSH
35407: LD_VAR 0 1
35411: NOT
35412: OR
35413: PUSH
35414: LD_VAR 0 2
35418: NOT
35419: OR
35420: IFFALSE 35424
// exit ;
35422: GO 35449
// mc_scan_area := Replace ( mc_scan_area , base , scan_area ) ;
35424: LD_ADDR_EXP 81
35428: PUSH
35429: LD_EXP 81
35433: PPUSH
35434: LD_VAR 0 1
35438: PPUSH
35439: LD_VAR 0 2
35443: PPUSH
35444: CALL_OW 1
35448: ST_TO_ADDR
// end ;
35449: LD_VAR 0 3
35453: RET
// export function MC_NotTameApeman ( base ) ; var ape_techs ; begin
35454: LD_INT 0
35456: PPUSH
35457: PPUSH
// if not mc_bases or not base then
35458: LD_EXP 56
35462: NOT
35463: PUSH
35464: LD_VAR 0 1
35468: NOT
35469: OR
35470: IFFALSE 35474
// exit ;
35472: GO 35538
// ape_techs := [ 1 , 2 , 3 , 4 , 11 ] ;
35474: LD_ADDR_VAR 0 3
35478: PUSH
35479: LD_INT 1
35481: PUSH
35482: LD_INT 2
35484: PUSH
35485: LD_INT 3
35487: PUSH
35488: LD_INT 4
35490: PUSH
35491: LD_INT 11
35493: PUSH
35494: EMPTY
35495: LIST
35496: LIST
35497: LIST
35498: LIST
35499: LIST
35500: ST_TO_ADDR
// mc_tech := Replace ( mc_tech , base , mc_tech [ base ] diff ape_techs ) ;
35501: LD_ADDR_EXP 83
35505: PUSH
35506: LD_EXP 83
35510: PPUSH
35511: LD_VAR 0 1
35515: PPUSH
35516: LD_EXP 83
35520: PUSH
35521: LD_VAR 0 1
35525: ARRAY
35526: PUSH
35527: LD_VAR 0 3
35531: DIFF
35532: PPUSH
35533: CALL_OW 1
35537: ST_TO_ADDR
// end ;
35538: LD_VAR 0 2
35542: RET
// export function MC_GetVehicles ( base , onlyCombat ) ; begin
35543: LD_INT 0
35545: PPUSH
// result := mc_vehicles [ base ] ;
35546: LD_ADDR_VAR 0 3
35550: PUSH
35551: LD_EXP 75
35555: PUSH
35556: LD_VAR 0 1
35560: ARRAY
35561: ST_TO_ADDR
// if onlyCombat then
35562: LD_VAR 0 2
35566: IFFALSE 35731
// result := result diff UnitFilter ( result , [ f_or , [ f_weapon , us_cargo_bay ] , [ f_weapon , ru_cargo_bay ] , [ f_weapon , ru_big_cargo_bay ] , [ f_weapon , ar_cargo_bay ] , [ f_weapon , us_crane ] , [ f_weapon , ru_crane ] , [ f_weapon , us_bulldozer ] , [ f_weapon , ru_bulldozer ] , [ f_weapon , ru_radar ] , [ f_weapon , ar_control_tower ] , [ f_weapon , ru_siberium_rocket ] , [ f_weapon , us_siberium_rocket ] ] ) ;
35568: LD_ADDR_VAR 0 3
35572: PUSH
35573: LD_VAR 0 3
35577: PUSH
35578: LD_VAR 0 3
35582: PPUSH
35583: LD_INT 2
35585: PUSH
35586: LD_INT 34
35588: PUSH
35589: LD_INT 12
35591: PUSH
35592: EMPTY
35593: LIST
35594: LIST
35595: PUSH
35596: LD_INT 34
35598: PUSH
35599: LD_INT 51
35601: PUSH
35602: EMPTY
35603: LIST
35604: LIST
35605: PUSH
35606: LD_INT 34
35608: PUSH
35609: LD_EXP 50
35613: PUSH
35614: EMPTY
35615: LIST
35616: LIST
35617: PUSH
35618: LD_INT 34
35620: PUSH
35621: LD_INT 32
35623: PUSH
35624: EMPTY
35625: LIST
35626: LIST
35627: PUSH
35628: LD_INT 34
35630: PUSH
35631: LD_INT 13
35633: PUSH
35634: EMPTY
35635: LIST
35636: LIST
35637: PUSH
35638: LD_INT 34
35640: PUSH
35641: LD_INT 52
35643: PUSH
35644: EMPTY
35645: LIST
35646: LIST
35647: PUSH
35648: LD_INT 34
35650: PUSH
35651: LD_INT 14
35653: PUSH
35654: EMPTY
35655: LIST
35656: LIST
35657: PUSH
35658: LD_INT 34
35660: PUSH
35661: LD_INT 53
35663: PUSH
35664: EMPTY
35665: LIST
35666: LIST
35667: PUSH
35668: LD_INT 34
35670: PUSH
35671: LD_EXP 49
35675: PUSH
35676: EMPTY
35677: LIST
35678: LIST
35679: PUSH
35680: LD_INT 34
35682: PUSH
35683: LD_INT 31
35685: PUSH
35686: EMPTY
35687: LIST
35688: LIST
35689: PUSH
35690: LD_INT 34
35692: PUSH
35693: LD_INT 48
35695: PUSH
35696: EMPTY
35697: LIST
35698: LIST
35699: PUSH
35700: LD_INT 34
35702: PUSH
35703: LD_INT 8
35705: PUSH
35706: EMPTY
35707: LIST
35708: LIST
35709: PUSH
35710: EMPTY
35711: LIST
35712: LIST
35713: LIST
35714: LIST
35715: LIST
35716: LIST
35717: LIST
35718: LIST
35719: LIST
35720: LIST
35721: LIST
35722: LIST
35723: LIST
35724: PPUSH
35725: CALL_OW 72
35729: DIFF
35730: ST_TO_ADDR
// end ; end_of_file
35731: LD_VAR 0 3
35735: RET
// export function MCE_ApemanTamed ( ape , sci ) ; var i , tmp ; begin
35736: LD_INT 0
35738: PPUSH
35739: PPUSH
35740: PPUSH
// if not mc_bases or not skirmish then
35741: LD_EXP 56
35745: NOT
35746: PUSH
35747: LD_EXP 54
35751: NOT
35752: OR
35753: IFFALSE 35757
// exit ;
35755: GO 35922
// for i = 1 to mc_bases do
35757: LD_ADDR_VAR 0 4
35761: PUSH
35762: DOUBLE
35763: LD_INT 1
35765: DEC
35766: ST_TO_ADDR
35767: LD_EXP 56
35771: PUSH
35772: FOR_TO
35773: IFFALSE 35920
// begin if sci in mc_bases [ i ] then
35775: LD_VAR 0 2
35779: PUSH
35780: LD_EXP 56
35784: PUSH
35785: LD_VAR 0 4
35789: ARRAY
35790: IN
35791: IFFALSE 35918
// begin mc_ape := ReplaceIn ( mc_ape , [ i , mc_ape [ i ] + 1 ] , ape ) ;
35793: LD_ADDR_EXP 85
35797: PUSH
35798: LD_EXP 85
35802: PPUSH
35803: LD_VAR 0 4
35807: PUSH
35808: LD_EXP 85
35812: PUSH
35813: LD_VAR 0 4
35817: ARRAY
35818: PUSH
35819: LD_INT 1
35821: PLUS
35822: PUSH
35823: EMPTY
35824: LIST
35825: LIST
35826: PPUSH
35827: LD_VAR 0 1
35831: PPUSH
35832: CALL 47120 0 3
35836: ST_TO_ADDR
// tmp := NearestUnitToUnit ( UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) , ape ) ;
35837: LD_ADDR_VAR 0 5
35841: PUSH
35842: LD_EXP 56
35846: PUSH
35847: LD_VAR 0 4
35851: ARRAY
35852: PPUSH
35853: LD_INT 2
35855: PUSH
35856: LD_INT 30
35858: PUSH
35859: LD_INT 0
35861: PUSH
35862: EMPTY
35863: LIST
35864: LIST
35865: PUSH
35866: LD_INT 30
35868: PUSH
35869: LD_INT 1
35871: PUSH
35872: EMPTY
35873: LIST
35874: LIST
35875: PUSH
35876: EMPTY
35877: LIST
35878: LIST
35879: LIST
35880: PPUSH
35881: CALL_OW 72
35885: PPUSH
35886: LD_VAR 0 1
35890: PPUSH
35891: CALL_OW 74
35895: ST_TO_ADDR
// if tmp then
35896: LD_VAR 0 5
35900: IFFALSE 35916
// ComStandNearbyBuilding ( ape , tmp ) ;
35902: LD_VAR 0 1
35906: PPUSH
35907: LD_VAR 0 5
35911: PPUSH
35912: CALL 41687 0 2
// break ;
35916: GO 35920
// end ; end ;
35918: GO 35772
35920: POP
35921: POP
// end ;
35922: LD_VAR 0 3
35926: RET
// export function MCE_EnterBuilding ( building , unit ) ; var i , tmp ; begin
35927: LD_INT 0
35929: PPUSH
35930: PPUSH
35931: PPUSH
// if not mc_bases or not skirmish then
35932: LD_EXP 56
35936: NOT
35937: PUSH
35938: LD_EXP 54
35942: NOT
35943: OR
35944: IFFALSE 35948
// exit ;
35946: GO 36037
// for i = 1 to mc_bases do
35948: LD_ADDR_VAR 0 4
35952: PUSH
35953: DOUBLE
35954: LD_INT 1
35956: DEC
35957: ST_TO_ADDR
35958: LD_EXP 56
35962: PUSH
35963: FOR_TO
35964: IFFALSE 36035
// begin if building in mc_busy_turret_list [ i ] then
35966: LD_VAR 0 1
35970: PUSH
35971: LD_EXP 66
35975: PUSH
35976: LD_VAR 0 4
35980: ARRAY
35981: IN
35982: IFFALSE 36033
// begin tmp := mc_busy_turret_list [ i ] diff building ;
35984: LD_ADDR_VAR 0 5
35988: PUSH
35989: LD_EXP 66
35993: PUSH
35994: LD_VAR 0 4
35998: ARRAY
35999: PUSH
36000: LD_VAR 0 1
36004: DIFF
36005: ST_TO_ADDR
// mc_busy_turret_list := Replace ( mc_busy_turret_list , i , tmp ) ;
36006: LD_ADDR_EXP 66
36010: PUSH
36011: LD_EXP 66
36015: PPUSH
36016: LD_VAR 0 4
36020: PPUSH
36021: LD_VAR 0 5
36025: PPUSH
36026: CALL_OW 1
36030: ST_TO_ADDR
// break ;
36031: GO 36035
// end ; end ;
36033: GO 35963
36035: POP
36036: POP
// end ;
36037: LD_VAR 0 3
36041: RET
// export function MCE_BuildingCaptured ( building , side , capturning_unit ) ; var i , tmp ; begin
36042: LD_INT 0
36044: PPUSH
36045: PPUSH
36046: PPUSH
// if not mc_bases or not skirmish then
36047: LD_EXP 56
36051: NOT
36052: PUSH
36053: LD_EXP 54
36057: NOT
36058: OR
36059: IFFALSE 36063
// exit ;
36061: GO 36262
// for i = 1 to mc_bases do
36063: LD_ADDR_VAR 0 5
36067: PUSH
36068: DOUBLE
36069: LD_INT 1
36071: DEC
36072: ST_TO_ADDR
36073: LD_EXP 56
36077: PUSH
36078: FOR_TO
36079: IFFALSE 36260
// if building in mc_bases [ i ] then
36081: LD_VAR 0 1
36085: PUSH
36086: LD_EXP 56
36090: PUSH
36091: LD_VAR 0 5
36095: ARRAY
36096: IN
36097: IFFALSE 36258
// begin tmp := mc_bases [ i ] diff building ;
36099: LD_ADDR_VAR 0 6
36103: PUSH
36104: LD_EXP 56
36108: PUSH
36109: LD_VAR 0 5
36113: ARRAY
36114: PUSH
36115: LD_VAR 0 1
36119: DIFF
36120: ST_TO_ADDR
// mc_bases := Replace ( mc_bases , i , tmp ) ;
36121: LD_ADDR_EXP 56
36125: PUSH
36126: LD_EXP 56
36130: PPUSH
36131: LD_VAR 0 5
36135: PPUSH
36136: LD_VAR 0 6
36140: PPUSH
36141: CALL_OW 1
36145: ST_TO_ADDR
// if building in mc_turret_list [ i ] then
36146: LD_VAR 0 1
36150: PUSH
36151: LD_EXP 64
36155: PUSH
36156: LD_VAR 0 5
36160: ARRAY
36161: IN
36162: IFFALSE 36201
// mc_turret_list := Replace ( mc_turret_list , i , mc_turret_list [ i ] diff building ) ;
36164: LD_ADDR_EXP 64
36168: PUSH
36169: LD_EXP 64
36173: PPUSH
36174: LD_VAR 0 5
36178: PPUSH
36179: LD_EXP 64
36183: PUSH
36184: LD_VAR 0 5
36188: ARRAY
36189: PUSH
36190: LD_VAR 0 1
36194: DIFF
36195: PPUSH
36196: CALL_OW 1
36200: ST_TO_ADDR
// if building in mc_empty_turret_list [ i ] then
36201: LD_VAR 0 1
36205: PUSH
36206: LD_EXP 65
36210: PUSH
36211: LD_VAR 0 5
36215: ARRAY
36216: IN
36217: IFFALSE 36256
// mc_empty_turret_list := Replace ( mc_empty_turret_list , i , mc_empty_turret_list [ i ] diff building ) ;
36219: LD_ADDR_EXP 65
36223: PUSH
36224: LD_EXP 65
36228: PPUSH
36229: LD_VAR 0 5
36233: PPUSH
36234: LD_EXP 65
36238: PUSH
36239: LD_VAR 0 5
36243: ARRAY
36244: PUSH
36245: LD_VAR 0 1
36249: DIFF
36250: PPUSH
36251: CALL_OW 1
36255: ST_TO_ADDR
// break ;
36256: GO 36260
// end ;
36258: GO 36078
36260: POP
36261: POP
// end ;
36262: LD_VAR 0 4
36266: RET
// export function MCE_VehicleCaptured ( new , old , side , capturing_unit ) ; var i , tmp ; begin
36267: LD_INT 0
36269: PPUSH
36270: PPUSH
36271: PPUSH
// if not mc_bases or not skirmish or not side in mc_sides then
36272: LD_EXP 56
36276: NOT
36277: PUSH
36278: LD_EXP 54
36282: NOT
36283: OR
36284: PUSH
36285: LD_VAR 0 3
36289: PUSH
36290: LD_EXP 82
36294: IN
36295: NOT
36296: OR
36297: IFFALSE 36301
// exit ;
36299: GO 36424
// for i = 1 to mc_vehicles do
36301: LD_ADDR_VAR 0 6
36305: PUSH
36306: DOUBLE
36307: LD_INT 1
36309: DEC
36310: ST_TO_ADDR
36311: LD_EXP 75
36315: PUSH
36316: FOR_TO
36317: IFFALSE 36422
// if old in mc_vehicles [ i ] or new in mc_vehicles [ i ] then
36319: LD_VAR 0 2
36323: PUSH
36324: LD_EXP 75
36328: PUSH
36329: LD_VAR 0 6
36333: ARRAY
36334: IN
36335: PUSH
36336: LD_VAR 0 1
36340: PUSH
36341: LD_EXP 75
36345: PUSH
36346: LD_VAR 0 6
36350: ARRAY
36351: IN
36352: OR
36353: IFFALSE 36420
// begin tmp := mc_vehicles [ i ] diff old ;
36355: LD_ADDR_VAR 0 7
36359: PUSH
36360: LD_EXP 75
36364: PUSH
36365: LD_VAR 0 6
36369: ARRAY
36370: PUSH
36371: LD_VAR 0 2
36375: DIFF
36376: ST_TO_ADDR
// tmp := tmp diff new ;
36377: LD_ADDR_VAR 0 7
36381: PUSH
36382: LD_VAR 0 7
36386: PUSH
36387: LD_VAR 0 1
36391: DIFF
36392: ST_TO_ADDR
// mc_vehicles := Replace ( mc_vehicles , i , tmp ) ;
36393: LD_ADDR_EXP 75
36397: PUSH
36398: LD_EXP 75
36402: PPUSH
36403: LD_VAR 0 6
36407: PPUSH
36408: LD_VAR 0 7
36412: PPUSH
36413: CALL_OW 1
36417: ST_TO_ADDR
// break ;
36418: GO 36422
// end ;
36420: GO 36316
36422: POP
36423: POP
// end ;
36424: LD_VAR 0 5
36428: RET
// export function MCE_VehicleConstructed ( vehicle , factory ) ; var i , side , tmp ; begin
36429: LD_INT 0
36431: PPUSH
36432: PPUSH
36433: PPUSH
36434: PPUSH
// if not mc_bases or not skirmish then
36435: LD_EXP 56
36439: NOT
36440: PUSH
36441: LD_EXP 54
36445: NOT
36446: OR
36447: IFFALSE 36451
// exit ;
36449: GO 36828
// side := GetSide ( vehicle ) ;
36451: LD_ADDR_VAR 0 5
36455: PUSH
36456: LD_VAR 0 1
36460: PPUSH
36461: CALL_OW 255
36465: ST_TO_ADDR
// for i = 1 to mc_bases do
36466: LD_ADDR_VAR 0 4
36470: PUSH
36471: DOUBLE
36472: LD_INT 1
36474: DEC
36475: ST_TO_ADDR
36476: LD_EXP 56
36480: PUSH
36481: FOR_TO
36482: IFFALSE 36826
// begin if factory in mc_bases [ i ] then
36484: LD_VAR 0 2
36488: PUSH
36489: LD_EXP 56
36493: PUSH
36494: LD_VAR 0 4
36498: ARRAY
36499: IN
36500: IFFALSE 36824
// begin if mc_defender [ i ] < mc_defender_limit [ i ] and not GetWeapon ( vehicle ) in [ ar_control_tower , ar_cargo_bay , ru_cargo_bay , ru_big_cargo_bay , us_cargo_bay , ar_radar , ru_radar , us_radar , ru_bulldozer , us_bulldozer , ar_bio_bomb , ar_selfpropelled_bomb , us_hack , us_crane , ru_crane , ru_siberium_rocket , us_siberium_rocket ] then
36502: LD_EXP 78
36506: PUSH
36507: LD_VAR 0 4
36511: ARRAY
36512: PUSH
36513: LD_EXP 67
36517: PUSH
36518: LD_VAR 0 4
36522: ARRAY
36523: LESS
36524: PUSH
36525: LD_VAR 0 1
36529: PPUSH
36530: CALL_OW 264
36534: PUSH
36535: LD_INT 31
36537: PUSH
36538: LD_INT 32
36540: PUSH
36541: LD_INT 51
36543: PUSH
36544: LD_EXP 50
36548: PUSH
36549: LD_INT 12
36551: PUSH
36552: LD_INT 30
36554: PUSH
36555: LD_EXP 49
36559: PUSH
36560: LD_INT 11
36562: PUSH
36563: LD_INT 53
36565: PUSH
36566: LD_INT 14
36568: PUSH
36569: LD_EXP 53
36573: PUSH
36574: LD_INT 29
36576: PUSH
36577: LD_EXP 51
36581: PUSH
36582: LD_INT 13
36584: PUSH
36585: LD_INT 52
36587: PUSH
36588: LD_INT 48
36590: PUSH
36591: LD_INT 8
36593: PUSH
36594: EMPTY
36595: LIST
36596: LIST
36597: LIST
36598: LIST
36599: LIST
36600: LIST
36601: LIST
36602: LIST
36603: LIST
36604: LIST
36605: LIST
36606: LIST
36607: LIST
36608: LIST
36609: LIST
36610: LIST
36611: LIST
36612: IN
36613: NOT
36614: AND
36615: IFFALSE 36663
// mc_defender := ReplaceIn ( mc_defender , [ i , mc_defender [ i ] + 1 ] , vehicle ) else
36617: LD_ADDR_EXP 78
36621: PUSH
36622: LD_EXP 78
36626: PPUSH
36627: LD_VAR 0 4
36631: PUSH
36632: LD_EXP 78
36636: PUSH
36637: LD_VAR 0 4
36641: ARRAY
36642: PUSH
36643: LD_INT 1
36645: PLUS
36646: PUSH
36647: EMPTY
36648: LIST
36649: LIST
36650: PPUSH
36651: LD_VAR 0 1
36655: PPUSH
36656: CALL 47120 0 3
36660: ST_TO_ADDR
36661: GO 36707
// mc_vehicles := ReplaceIn ( mc_vehicles , [ i , mc_vehicles [ i ] + 1 ] , vehicle ) ;
36663: LD_ADDR_EXP 75
36667: PUSH
36668: LD_EXP 75
36672: PPUSH
36673: LD_VAR 0 4
36677: PUSH
36678: LD_EXP 75
36682: PUSH
36683: LD_VAR 0 4
36687: ARRAY
36688: PUSH
36689: LD_INT 1
36691: PLUS
36692: PUSH
36693: EMPTY
36694: LIST
36695: LIST
36696: PPUSH
36697: LD_VAR 0 1
36701: PPUSH
36702: CALL 47120 0 3
36706: ST_TO_ADDR
// if GetControl ( vehicle ) = control_remote then
36707: LD_VAR 0 1
36711: PPUSH
36712: CALL_OW 263
36716: PUSH
36717: LD_INT 2
36719: EQUAL
36720: IFFALSE 36740
// begin repeat wait ( 0 0$1 ) ;
36722: LD_INT 35
36724: PPUSH
36725: CALL_OW 67
// until IsControledBy ( vehicle ) ;
36729: LD_VAR 0 1
36733: PPUSH
36734: CALL_OW 312
36738: IFFALSE 36722
// end ; ComMoveToArea ( vehicle , mc_parking [ i ] ) ;
36740: LD_VAR 0 1
36744: PPUSH
36745: LD_EXP 80
36749: PUSH
36750: LD_VAR 0 4
36754: ARRAY
36755: PPUSH
36756: CALL_OW 113
// if GetControl ( vehicle ) <> control_manual then
36760: LD_VAR 0 1
36764: PPUSH
36765: CALL_OW 263
36769: PUSH
36770: LD_INT 1
36772: NONEQUAL
36773: IFFALSE 36777
// break ;
36775: GO 36826
// repeat wait ( 0 0$1 ) ;
36777: LD_INT 35
36779: PPUSH
36780: CALL_OW 67
// until IsInArea ( vehicle , mc_parking [ i ] ) ;
36784: LD_VAR 0 1
36788: PPUSH
36789: LD_EXP 80
36793: PUSH
36794: LD_VAR 0 4
36798: ARRAY
36799: PPUSH
36800: CALL_OW 308
36804: IFFALSE 36777
// ComExitVehicle ( IsDrivenBy ( vehicle ) ) ;
36806: LD_VAR 0 1
36810: PPUSH
36811: CALL_OW 311
36815: PPUSH
36816: CALL_OW 121
// exit ;
36820: POP
36821: POP
36822: GO 36828
// end ; end ;
36824: GO 36481
36826: POP
36827: POP
// end ;
36828: LD_VAR 0 3
36832: RET
// export function MCE_CrateSpawn ( id , x , y , amount , mode ) ; var i , j , depot ; begin
36833: LD_INT 0
36835: PPUSH
36836: PPUSH
36837: PPUSH
36838: PPUSH
// if not mc_bases or not skirmish then
36839: LD_EXP 56
36843: NOT
36844: PUSH
36845: LD_EXP 54
36849: NOT
36850: OR
36851: IFFALSE 36855
// exit ;
36853: GO 37208
// repeat wait ( 0 0$1 ) ;
36855: LD_INT 35
36857: PPUSH
36858: CALL_OW 67
// until GetResourceAmountXY ( x , y ) ;
36862: LD_VAR 0 2
36866: PPUSH
36867: LD_VAR 0 3
36871: PPUSH
36872: CALL_OW 284
36876: IFFALSE 36855
// if GetResourceTypeXY ( x , y ) = mat_artefact then
36878: LD_VAR 0 2
36882: PPUSH
36883: LD_VAR 0 3
36887: PPUSH
36888: CALL_OW 283
36892: PUSH
36893: LD_INT 4
36895: EQUAL
36896: IFFALSE 36900
// exit ;
36898: GO 37208
// for i = 1 to mc_bases do
36900: LD_ADDR_VAR 0 7
36904: PUSH
36905: DOUBLE
36906: LD_INT 1
36908: DEC
36909: ST_TO_ADDR
36910: LD_EXP 56
36914: PUSH
36915: FOR_TO
36916: IFFALSE 37206
// begin if mc_crates_area [ i ] then
36918: LD_EXP 74
36922: PUSH
36923: LD_VAR 0 7
36927: ARRAY
36928: IFFALSE 37039
// for j in mc_crates_area [ i ] do
36930: LD_ADDR_VAR 0 8
36934: PUSH
36935: LD_EXP 74
36939: PUSH
36940: LD_VAR 0 7
36944: ARRAY
36945: PUSH
36946: FOR_IN
36947: IFFALSE 37037
// if InArea ( x , y , j ) then
36949: LD_VAR 0 2
36953: PPUSH
36954: LD_VAR 0 3
36958: PPUSH
36959: LD_VAR 0 8
36963: PPUSH
36964: CALL_OW 309
36968: IFFALSE 37035
// begin mc_crates := ReplaceIn ( mc_crates , [ i , mc_crates [ i ] + 1 ] , [ amount , x , y ] ) ;
36970: LD_ADDR_EXP 72
36974: PUSH
36975: LD_EXP 72
36979: PPUSH
36980: LD_VAR 0 7
36984: PUSH
36985: LD_EXP 72
36989: PUSH
36990: LD_VAR 0 7
36994: ARRAY
36995: PUSH
36996: LD_INT 1
36998: PLUS
36999: PUSH
37000: EMPTY
37001: LIST
37002: LIST
37003: PPUSH
37004: LD_VAR 0 4
37008: PUSH
37009: LD_VAR 0 2
37013: PUSH
37014: LD_VAR 0 3
37018: PUSH
37019: EMPTY
37020: LIST
37021: LIST
37022: LIST
37023: PPUSH
37024: CALL 47120 0 3
37028: ST_TO_ADDR
// exit ;
37029: POP
37030: POP
37031: POP
37032: POP
37033: GO 37208
// end ;
37035: GO 36946
37037: POP
37038: POP
// depot := UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) ;
37039: LD_ADDR_VAR 0 9
37043: PUSH
37044: LD_EXP 56
37048: PUSH
37049: LD_VAR 0 7
37053: ARRAY
37054: PPUSH
37055: LD_INT 2
37057: PUSH
37058: LD_INT 30
37060: PUSH
37061: LD_INT 0
37063: PUSH
37064: EMPTY
37065: LIST
37066: LIST
37067: PUSH
37068: LD_INT 30
37070: PUSH
37071: LD_INT 1
37073: PUSH
37074: EMPTY
37075: LIST
37076: LIST
37077: PUSH
37078: EMPTY
37079: LIST
37080: LIST
37081: LIST
37082: PPUSH
37083: CALL_OW 72
37087: ST_TO_ADDR
// if not depot then
37088: LD_VAR 0 9
37092: NOT
37093: IFFALSE 37097
// continue ;
37095: GO 36915
// for j in depot do
37097: LD_ADDR_VAR 0 8
37101: PUSH
37102: LD_VAR 0 9
37106: PUSH
37107: FOR_IN
37108: IFFALSE 37202
// if GetDistUnitXY ( j , x , y ) < 30 then
37110: LD_VAR 0 8
37114: PPUSH
37115: LD_VAR 0 2
37119: PPUSH
37120: LD_VAR 0 3
37124: PPUSH
37125: CALL_OW 297
37129: PUSH
37130: LD_INT 30
37132: LESS
37133: IFFALSE 37200
// begin mc_crates := ReplaceIn ( mc_crates , [ i , mc_crates [ i ] + 1 ] , [ amount , x , y ] ) ;
37135: LD_ADDR_EXP 72
37139: PUSH
37140: LD_EXP 72
37144: PPUSH
37145: LD_VAR 0 7
37149: PUSH
37150: LD_EXP 72
37154: PUSH
37155: LD_VAR 0 7
37159: ARRAY
37160: PUSH
37161: LD_INT 1
37163: PLUS
37164: PUSH
37165: EMPTY
37166: LIST
37167: LIST
37168: PPUSH
37169: LD_VAR 0 4
37173: PUSH
37174: LD_VAR 0 2
37178: PUSH
37179: LD_VAR 0 3
37183: PUSH
37184: EMPTY
37185: LIST
37186: LIST
37187: LIST
37188: PPUSH
37189: CALL 47120 0 3
37193: ST_TO_ADDR
// exit ;
37194: POP
37195: POP
37196: POP
37197: POP
37198: GO 37208
// end ;
37200: GO 37107
37202: POP
37203: POP
// end ;
37204: GO 36915
37206: POP
37207: POP
// end ;
37208: LD_VAR 0 6
37212: RET
// export function MCE_ResearchComplete ( tech , lab ) ; var side , i , tmp ; begin
37213: LD_INT 0
37215: PPUSH
37216: PPUSH
37217: PPUSH
37218: PPUSH
// if not mc_bases or not skirmish then
37219: LD_EXP 56
37223: NOT
37224: PUSH
37225: LD_EXP 54
37229: NOT
37230: OR
37231: IFFALSE 37235
// exit ;
37233: GO 37512
// side := GetSide ( lab ) ;
37235: LD_ADDR_VAR 0 4
37239: PUSH
37240: LD_VAR 0 2
37244: PPUSH
37245: CALL_OW 255
37249: ST_TO_ADDR
// if not side in mc_sides or not mc_tech or not mc_bases then
37250: LD_VAR 0 4
37254: PUSH
37255: LD_EXP 82
37259: IN
37260: NOT
37261: PUSH
37262: LD_EXP 83
37266: NOT
37267: OR
37268: PUSH
37269: LD_EXP 56
37273: NOT
37274: OR
37275: IFFALSE 37279
// exit ;
37277: GO 37512
// mc_tech := Replace ( mc_tech , side , mc_tech [ side ] diff tech ) ;
37279: LD_ADDR_EXP 83
37283: PUSH
37284: LD_EXP 83
37288: PPUSH
37289: LD_VAR 0 4
37293: PPUSH
37294: LD_EXP 83
37298: PUSH
37299: LD_VAR 0 4
37303: ARRAY
37304: PUSH
37305: LD_VAR 0 1
37309: DIFF
37310: PPUSH
37311: CALL_OW 1
37315: ST_TO_ADDR
// for i = 1 to mc_bases do
37316: LD_ADDR_VAR 0 5
37320: PUSH
37321: DOUBLE
37322: LD_INT 1
37324: DEC
37325: ST_TO_ADDR
37326: LD_EXP 56
37330: PUSH
37331: FOR_TO
37332: IFFALSE 37510
// begin if lab in mc_bases [ i ] then
37334: LD_VAR 0 2
37338: PUSH
37339: LD_EXP 56
37343: PUSH
37344: LD_VAR 0 5
37348: ARRAY
37349: IN
37350: IFFALSE 37508
// begin if tech in [ tech_apeagres , tech_apebrain , tech_apeneural , tech_apepsych ] and mc_ape_in_lab [ i ] then
37352: LD_VAR 0 1
37356: PUSH
37357: LD_INT 11
37359: PUSH
37360: LD_INT 4
37362: PUSH
37363: LD_INT 3
37365: PUSH
37366: LD_INT 2
37368: PUSH
37369: EMPTY
37370: LIST
37371: LIST
37372: LIST
37373: LIST
37374: IN
37375: PUSH
37376: LD_EXP 86
37380: PUSH
37381: LD_VAR 0 5
37385: ARRAY
37386: AND
37387: IFFALSE 37508
// begin tmp := mc_ape_in_lab [ i ] [ 1 ] ;
37389: LD_ADDR_VAR 0 6
37393: PUSH
37394: LD_EXP 86
37398: PUSH
37399: LD_VAR 0 5
37403: ARRAY
37404: PUSH
37405: LD_INT 1
37407: ARRAY
37408: ST_TO_ADDR
// mc_ape_in_lab := Replace ( mc_ape_in_lab , i , [ ] ) ;
37409: LD_ADDR_EXP 86
37413: PUSH
37414: LD_EXP 86
37418: PPUSH
37419: LD_VAR 0 5
37423: PPUSH
37424: EMPTY
37425: PPUSH
37426: CALL_OW 1
37430: ST_TO_ADDR
// SetTag ( tmp , 0 ) ;
37431: LD_VAR 0 6
37435: PPUSH
37436: LD_INT 0
37438: PPUSH
37439: CALL_OW 109
// ComExitBuilding ( tmp ) ;
37443: LD_VAR 0 6
37447: PPUSH
37448: CALL_OW 122
// mc_ape := Replace ( mc_ape , i , Insert ( mc_ape [ i ] , 1 , tmp ) ) ;
37452: LD_ADDR_EXP 85
37456: PUSH
37457: LD_EXP 85
37461: PPUSH
37462: LD_VAR 0 5
37466: PPUSH
37467: LD_EXP 85
37471: PUSH
37472: LD_VAR 0 5
37476: ARRAY
37477: PPUSH
37478: LD_INT 1
37480: PPUSH
37481: LD_VAR 0 6
37485: PPUSH
37486: CALL_OW 2
37490: PPUSH
37491: CALL_OW 1
37495: ST_TO_ADDR
// MC_Reset ( i , 112 ) ;
37496: LD_VAR 0 5
37500: PPUSH
37501: LD_INT 112
37503: PPUSH
37504: CALL 14620 0 2
// end ; end ; end ;
37508: GO 37331
37510: POP
37511: POP
// end ;
37512: LD_VAR 0 3
37516: RET
// export function MCE_UnitDestroyed ( un ) ; var i , j , btype , pos , tmp , fac , components ; begin
37517: LD_INT 0
37519: PPUSH
37520: PPUSH
37521: PPUSH
37522: PPUSH
37523: PPUSH
37524: PPUSH
37525: PPUSH
37526: PPUSH
// if not mc_bases or not skirmish then
37527: LD_EXP 56
37531: NOT
37532: PUSH
37533: LD_EXP 54
37537: NOT
37538: OR
37539: IFFALSE 37543
// exit ;
37541: GO 38692
// for i = 1 to mc_bases do
37543: LD_ADDR_VAR 0 3
37547: PUSH
37548: DOUBLE
37549: LD_INT 1
37551: DEC
37552: ST_TO_ADDR
37553: LD_EXP 56
37557: PUSH
37558: FOR_TO
37559: IFFALSE 38690
// if un in mc_bases [ i ] or un in mc_construct_list [ i ] or un in mc_defender [ i ] or un in mc_vehicles [ i ] or un in mc_ape [ i ] or un in mc_ape_in_lab [ i ] then
37561: LD_VAR 0 1
37565: PUSH
37566: LD_EXP 56
37570: PUSH
37571: LD_VAR 0 3
37575: ARRAY
37576: IN
37577: PUSH
37578: LD_VAR 0 1
37582: PUSH
37583: LD_EXP 63
37587: PUSH
37588: LD_VAR 0 3
37592: ARRAY
37593: IN
37594: OR
37595: PUSH
37596: LD_VAR 0 1
37600: PUSH
37601: LD_EXP 78
37605: PUSH
37606: LD_VAR 0 3
37610: ARRAY
37611: IN
37612: OR
37613: PUSH
37614: LD_VAR 0 1
37618: PUSH
37619: LD_EXP 75
37623: PUSH
37624: LD_VAR 0 3
37628: ARRAY
37629: IN
37630: OR
37631: PUSH
37632: LD_VAR 0 1
37636: PUSH
37637: LD_EXP 85
37641: PUSH
37642: LD_VAR 0 3
37646: ARRAY
37647: IN
37648: OR
37649: PUSH
37650: LD_VAR 0 1
37654: PUSH
37655: LD_EXP 86
37659: PUSH
37660: LD_VAR 0 3
37664: ARRAY
37665: IN
37666: OR
37667: IFFALSE 38688
// begin if un in mc_ape [ i ] then
37669: LD_VAR 0 1
37673: PUSH
37674: LD_EXP 85
37678: PUSH
37679: LD_VAR 0 3
37683: ARRAY
37684: IN
37685: IFFALSE 37724
// begin mc_ape := Replace ( mc_ape , i , mc_ape [ i ] diff un ) ;
37687: LD_ADDR_EXP 85
37691: PUSH
37692: LD_EXP 85
37696: PPUSH
37697: LD_VAR 0 3
37701: PPUSH
37702: LD_EXP 85
37706: PUSH
37707: LD_VAR 0 3
37711: ARRAY
37712: PUSH
37713: LD_VAR 0 1
37717: DIFF
37718: PPUSH
37719: CALL_OW 1
37723: ST_TO_ADDR
// end ; if un in mc_ape_in_lab [ i ] then
37724: LD_VAR 0 1
37728: PUSH
37729: LD_EXP 86
37733: PUSH
37734: LD_VAR 0 3
37738: ARRAY
37739: IN
37740: IFFALSE 37764
// begin mc_ape_in_lab := Replace ( mc_ape_in_lab , i , [ ] ) ;
37742: LD_ADDR_EXP 86
37746: PUSH
37747: LD_EXP 86
37751: PPUSH
37752: LD_VAR 0 3
37756: PPUSH
37757: EMPTY
37758: PPUSH
37759: CALL_OW 1
37763: ST_TO_ADDR
// end ; if GetType ( un ) = unit_vehicle and ( GetTag ( un ) = 20 or un in mc_defender [ i ] or GetWeapon ( un ) in [ us_cargo_bay , ru_cargo_bay , ru_big_cargo_bay , ar_cargo_bay , us_crane , ru_crane ] ) then
37764: LD_VAR 0 1
37768: PPUSH
37769: CALL_OW 247
37773: PUSH
37774: LD_INT 2
37776: EQUAL
37777: PUSH
37778: LD_VAR 0 1
37782: PPUSH
37783: CALL_OW 110
37787: PUSH
37788: LD_INT 20
37790: EQUAL
37791: PUSH
37792: LD_VAR 0 1
37796: PUSH
37797: LD_EXP 78
37801: PUSH
37802: LD_VAR 0 3
37806: ARRAY
37807: IN
37808: OR
37809: PUSH
37810: LD_VAR 0 1
37814: PPUSH
37815: CALL_OW 264
37819: PUSH
37820: LD_INT 12
37822: PUSH
37823: LD_INT 51
37825: PUSH
37826: LD_EXP 50
37830: PUSH
37831: LD_INT 32
37833: PUSH
37834: LD_INT 13
37836: PUSH
37837: LD_INT 52
37839: PUSH
37840: EMPTY
37841: LIST
37842: LIST
37843: LIST
37844: LIST
37845: LIST
37846: LIST
37847: IN
37848: OR
37849: AND
37850: IFFALSE 38028
// begin if un in mc_defender [ i ] then
37852: LD_VAR 0 1
37856: PUSH
37857: LD_EXP 78
37861: PUSH
37862: LD_VAR 0 3
37866: ARRAY
37867: IN
37868: IFFALSE 37907
// mc_defender := Replace ( mc_defender , i , mc_defender [ i ] diff un ) ;
37870: LD_ADDR_EXP 78
37874: PUSH
37875: LD_EXP 78
37879: PPUSH
37880: LD_VAR 0 3
37884: PPUSH
37885: LD_EXP 78
37889: PUSH
37890: LD_VAR 0 3
37894: ARRAY
37895: PUSH
37896: LD_VAR 0 1
37900: DIFF
37901: PPUSH
37902: CALL_OW 1
37906: ST_TO_ADDR
// fac := MC_GetBuildings ( i , b_factory ) ;
37907: LD_ADDR_VAR 0 8
37911: PUSH
37912: LD_VAR 0 3
37916: PPUSH
37917: LD_INT 3
37919: PPUSH
37920: CALL 34580 0 2
37924: ST_TO_ADDR
// if fac then
37925: LD_VAR 0 8
37929: IFFALSE 38028
// begin for j in fac do
37931: LD_ADDR_VAR 0 4
37935: PUSH
37936: LD_VAR 0 8
37940: PUSH
37941: FOR_IN
37942: IFFALSE 38026
// begin components := Produce ( fac , GetChassis ( un ) , GetEngine ( un ) , GetControl ( un ) , GetWeapon ( un ) ) ;
37944: LD_ADDR_VAR 0 9
37948: PUSH
37949: LD_VAR 0 8
37953: PPUSH
37954: LD_VAR 0 1
37958: PPUSH
37959: CALL_OW 265
37963: PPUSH
37964: LD_VAR 0 1
37968: PPUSH
37969: CALL_OW 262
37973: PPUSH
37974: LD_VAR 0 1
37978: PPUSH
37979: CALL_OW 263
37983: PPUSH
37984: LD_VAR 0 1
37988: PPUSH
37989: CALL_OW 264
37993: PPUSH
37994: CALL 44652 0 5
37998: ST_TO_ADDR
// if components then
37999: LD_VAR 0 9
38003: IFFALSE 38024
// begin MC_InsertProduceList ( i , [ components ] ) ;
38005: LD_VAR 0 3
38009: PPUSH
38010: LD_VAR 0 9
38014: PUSH
38015: EMPTY
38016: LIST
38017: PPUSH
38018: CALL 34125 0 2
// break ;
38022: GO 38026
// end ; end ;
38024: GO 37941
38026: POP
38027: POP
// end ; end ; if GetType ( un ) = unit_building then
38028: LD_VAR 0 1
38032: PPUSH
38033: CALL_OW 247
38037: PUSH
38038: LD_INT 3
38040: EQUAL
38041: IFFALSE 38356
// begin btype := GetBType ( un ) ;
38043: LD_ADDR_VAR 0 5
38047: PUSH
38048: LD_VAR 0 1
38052: PPUSH
38053: CALL_OW 266
38057: ST_TO_ADDR
// if btype = b_warehouse then
38058: LD_VAR 0 5
38062: PUSH
38063: LD_INT 1
38065: EQUAL
38066: IFFALSE 38084
// begin btype := b_depot ;
38068: LD_ADDR_VAR 0 5
38072: PUSH
38073: LD_INT 0
38075: ST_TO_ADDR
// pos := 1 ;
38076: LD_ADDR_VAR 0 6
38080: PUSH
38081: LD_INT 1
38083: ST_TO_ADDR
// end ; if btype = b_factory then
38084: LD_VAR 0 5
38088: PUSH
38089: LD_INT 3
38091: EQUAL
38092: IFFALSE 38110
// begin btype := b_workshop ;
38094: LD_ADDR_VAR 0 5
38098: PUSH
38099: LD_INT 2
38101: ST_TO_ADDR
// pos := 1 ;
38102: LD_ADDR_VAR 0 6
38106: PUSH
38107: LD_INT 1
38109: ST_TO_ADDR
// end ; if btype = b_barracks then
38110: LD_VAR 0 5
38114: PUSH
38115: LD_INT 5
38117: EQUAL
38118: IFFALSE 38128
// btype := b_armoury ;
38120: LD_ADDR_VAR 0 5
38124: PUSH
38125: LD_INT 4
38127: ST_TO_ADDR
// if btype in [ b_lab_half , b_lab_full ] then
38128: LD_VAR 0 5
38132: PUSH
38133: LD_INT 7
38135: PUSH
38136: LD_INT 8
38138: PUSH
38139: EMPTY
38140: LIST
38141: LIST
38142: IN
38143: IFFALSE 38153
// btype := b_lab ;
38145: LD_ADDR_VAR 0 5
38149: PUSH
38150: LD_INT 6
38152: ST_TO_ADDR
// mc_build_list := ReplaceIn ( mc_build_list , [ i , mc_build_list [ i ] + 1 ] , [ btype , GetX ( un ) , GetY ( un ) , GetDir ( un ) ] ) ;
38153: LD_ADDR_EXP 61
38157: PUSH
38158: LD_EXP 61
38162: PPUSH
38163: LD_VAR 0 3
38167: PUSH
38168: LD_EXP 61
38172: PUSH
38173: LD_VAR 0 3
38177: ARRAY
38178: PUSH
38179: LD_INT 1
38181: PLUS
38182: PUSH
38183: EMPTY
38184: LIST
38185: LIST
38186: PPUSH
38187: LD_VAR 0 5
38191: PUSH
38192: LD_VAR 0 1
38196: PPUSH
38197: CALL_OW 250
38201: PUSH
38202: LD_VAR 0 1
38206: PPUSH
38207: CALL_OW 251
38211: PUSH
38212: LD_VAR 0 1
38216: PPUSH
38217: CALL_OW 254
38221: PUSH
38222: EMPTY
38223: LIST
38224: LIST
38225: LIST
38226: LIST
38227: PPUSH
38228: CALL 47120 0 3
38232: ST_TO_ADDR
// if pos = 1 then
38233: LD_VAR 0 6
38237: PUSH
38238: LD_INT 1
38240: EQUAL
38241: IFFALSE 38356
// begin tmp := mc_build_list [ i ] ;
38243: LD_ADDR_VAR 0 7
38247: PUSH
38248: LD_EXP 61
38252: PUSH
38253: LD_VAR 0 3
38257: ARRAY
38258: ST_TO_ADDR
// if UnitFilter ( tmp , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) then
38259: LD_VAR 0 7
38263: PPUSH
38264: LD_INT 2
38266: PUSH
38267: LD_INT 30
38269: PUSH
38270: LD_INT 0
38272: PUSH
38273: EMPTY
38274: LIST
38275: LIST
38276: PUSH
38277: LD_INT 30
38279: PUSH
38280: LD_INT 1
38282: PUSH
38283: EMPTY
38284: LIST
38285: LIST
38286: PUSH
38287: EMPTY
38288: LIST
38289: LIST
38290: LIST
38291: PPUSH
38292: CALL_OW 72
38296: IFFALSE 38306
// pos := 2 ;
38298: LD_ADDR_VAR 0 6
38302: PUSH
38303: LD_INT 2
38305: ST_TO_ADDR
// tmp := ReplaceWith ( tmp , pos , tmp ) ;
38306: LD_ADDR_VAR 0 7
38310: PUSH
38311: LD_VAR 0 7
38315: PPUSH
38316: LD_VAR 0 6
38320: PPUSH
38321: LD_VAR 0 7
38325: PPUSH
38326: CALL 47446 0 3
38330: ST_TO_ADDR
// mc_build_list := Replace ( mc_build_list , i , tmp ) ;
38331: LD_ADDR_EXP 61
38335: PUSH
38336: LD_EXP 61
38340: PPUSH
38341: LD_VAR 0 3
38345: PPUSH
38346: LD_VAR 0 7
38350: PPUSH
38351: CALL_OW 1
38355: ST_TO_ADDR
// end ; end ; if un in mc_bases [ i ] then
38356: LD_VAR 0 1
38360: PUSH
38361: LD_EXP 56
38365: PUSH
38366: LD_VAR 0 3
38370: ARRAY
38371: IN
38372: IFFALSE 38411
// begin mc_bases := Replace ( mc_bases , i , mc_bases [ i ] diff un ) ;
38374: LD_ADDR_EXP 56
38378: PUSH
38379: LD_EXP 56
38383: PPUSH
38384: LD_VAR 0 3
38388: PPUSH
38389: LD_EXP 56
38393: PUSH
38394: LD_VAR 0 3
38398: ARRAY
38399: PUSH
38400: LD_VAR 0 1
38404: DIFF
38405: PPUSH
38406: CALL_OW 1
38410: ST_TO_ADDR
// end ; if un in mc_construct_list [ i ] then
38411: LD_VAR 0 1
38415: PUSH
38416: LD_EXP 63
38420: PUSH
38421: LD_VAR 0 3
38425: ARRAY
38426: IN
38427: IFFALSE 38466
// begin mc_construct_list := Replace ( mc_construct_list , i , mc_construct_list [ i ] diff un ) ;
38429: LD_ADDR_EXP 63
38433: PUSH
38434: LD_EXP 63
38438: PPUSH
38439: LD_VAR 0 3
38443: PPUSH
38444: LD_EXP 63
38448: PUSH
38449: LD_VAR 0 3
38453: ARRAY
38454: PUSH
38455: LD_VAR 0 1
38459: DIFF
38460: PPUSH
38461: CALL_OW 1
38465: ST_TO_ADDR
// end ; if un in mc_vehicles [ i ] then
38466: LD_VAR 0 1
38470: PUSH
38471: LD_EXP 75
38475: PUSH
38476: LD_VAR 0 3
38480: ARRAY
38481: IN
38482: IFFALSE 38521
// begin mc_vehicles := Replace ( mc_vehicles , i , mc_vehicles [ i ] diff un ) ;
38484: LD_ADDR_EXP 75
38488: PUSH
38489: LD_EXP 75
38493: PPUSH
38494: LD_VAR 0 3
38498: PPUSH
38499: LD_EXP 75
38503: PUSH
38504: LD_VAR 0 3
38508: ARRAY
38509: PUSH
38510: LD_VAR 0 1
38514: DIFF
38515: PPUSH
38516: CALL_OW 1
38520: ST_TO_ADDR
// end ; if un in mc_defender [ i ] then
38521: LD_VAR 0 1
38525: PUSH
38526: LD_EXP 78
38530: PUSH
38531: LD_VAR 0 3
38535: ARRAY
38536: IN
38537: IFFALSE 38576
// begin mc_defender := Replace ( mc_defender , i , mc_defender [ i ] diff un ) ;
38539: LD_ADDR_EXP 78
38543: PUSH
38544: LD_EXP 78
38548: PPUSH
38549: LD_VAR 0 3
38553: PPUSH
38554: LD_EXP 78
38558: PUSH
38559: LD_VAR 0 3
38563: ARRAY
38564: PUSH
38565: LD_VAR 0 1
38569: DIFF
38570: PPUSH
38571: CALL_OW 1
38575: ST_TO_ADDR
// end ; if un in mc_empty_turret_list [ i ] then
38576: LD_VAR 0 1
38580: PUSH
38581: LD_EXP 65
38585: PUSH
38586: LD_VAR 0 3
38590: ARRAY
38591: IN
38592: IFFALSE 38631
// begin mc_empty_turret_list := Replace ( mc_empty_turret_list , i , mc_empty_turret_list [ i ] diff un ) ;
38594: LD_ADDR_EXP 65
38598: PUSH
38599: LD_EXP 65
38603: PPUSH
38604: LD_VAR 0 3
38608: PPUSH
38609: LD_EXP 65
38613: PUSH
38614: LD_VAR 0 3
38618: ARRAY
38619: PUSH
38620: LD_VAR 0 1
38624: DIFF
38625: PPUSH
38626: CALL_OW 1
38630: ST_TO_ADDR
// end ; if un in mc_turret_list [ i ] then
38631: LD_VAR 0 1
38635: PUSH
38636: LD_EXP 64
38640: PUSH
38641: LD_VAR 0 3
38645: ARRAY
38646: IN
38647: IFFALSE 38686
// begin mc_turret_list := Replace ( mc_turret_list , i , mc_turret_list [ i ] diff un ) ;
38649: LD_ADDR_EXP 64
38653: PUSH
38654: LD_EXP 64
38658: PPUSH
38659: LD_VAR 0 3
38663: PPUSH
38664: LD_EXP 64
38668: PUSH
38669: LD_VAR 0 3
38673: ARRAY
38674: PUSH
38675: LD_VAR 0 1
38679: DIFF
38680: PPUSH
38681: CALL_OW 1
38685: ST_TO_ADDR
// end ; break ;
38686: GO 38690
// end ;
38688: GO 37558
38690: POP
38691: POP
// end ;
38692: LD_VAR 0 2
38696: RET
// export function MCE_UpgradeComplete ( building ) ; var i , j ; begin
38697: LD_INT 0
38699: PPUSH
38700: PPUSH
38701: PPUSH
// if not mc_bases or not skirmish then
38702: LD_EXP 56
38706: NOT
38707: PUSH
38708: LD_EXP 54
38712: NOT
38713: OR
38714: IFFALSE 38718
// exit ;
38716: GO 38933
// for i = 1 to mc_bases do
38718: LD_ADDR_VAR 0 3
38722: PUSH
38723: DOUBLE
38724: LD_INT 1
38726: DEC
38727: ST_TO_ADDR
38728: LD_EXP 56
38732: PUSH
38733: FOR_TO
38734: IFFALSE 38931
// begin if building in mc_construct_list [ i ] then
38736: LD_VAR 0 1
38740: PUSH
38741: LD_EXP 63
38745: PUSH
38746: LD_VAR 0 3
38750: ARRAY
38751: IN
38752: IFFALSE 38929
// begin mc_construct_list := Replace ( mc_construct_list , i , mc_construct_list [ i ] diff building ) ;
38754: LD_ADDR_EXP 63
38758: PUSH
38759: LD_EXP 63
38763: PPUSH
38764: LD_VAR 0 3
38768: PPUSH
38769: LD_EXP 63
38773: PUSH
38774: LD_VAR 0 3
38778: ARRAY
38779: PUSH
38780: LD_VAR 0 1
38784: DIFF
38785: PPUSH
38786: CALL_OW 1
38790: ST_TO_ADDR
// if building in mc_lab [ i ] then
38791: LD_VAR 0 1
38795: PUSH
38796: LD_EXP 89
38800: PUSH
38801: LD_VAR 0 3
38805: ARRAY
38806: IN
38807: IFFALSE 38862
// mc_lab_upgrade := Replace ( mc_lab_upgrade , i , Reindex ( mc_lab_upgrade [ i ] , 1 , mc_lab_upgrade [ i ] , false ) ) ;
38809: LD_ADDR_EXP 90
38813: PUSH
38814: LD_EXP 90
38818: PPUSH
38819: LD_VAR 0 3
38823: PPUSH
38824: LD_EXP 90
38828: PUSH
38829: LD_VAR 0 3
38833: ARRAY
38834: PPUSH
38835: LD_INT 1
38837: PPUSH
38838: LD_EXP 90
38842: PUSH
38843: LD_VAR 0 3
38847: ARRAY
38848: PPUSH
38849: LD_INT 0
38851: PPUSH
38852: CALL 46538 0 4
38856: PPUSH
38857: CALL_OW 1
38861: ST_TO_ADDR
// if not building in mc_bases [ i ] then
38862: LD_VAR 0 1
38866: PUSH
38867: LD_EXP 56
38871: PUSH
38872: LD_VAR 0 3
38876: ARRAY
38877: IN
38878: NOT
38879: IFFALSE 38925
// mc_bases := ReplaceIn ( mc_bases , [ i , mc_bases [ i ] + 1 ] , building ) ;
38881: LD_ADDR_EXP 56
38885: PUSH
38886: LD_EXP 56
38890: PPUSH
38891: LD_VAR 0 3
38895: PUSH
38896: LD_EXP 56
38900: PUSH
38901: LD_VAR 0 3
38905: ARRAY
38906: PUSH
38907: LD_INT 1
38909: PLUS
38910: PUSH
38911: EMPTY
38912: LIST
38913: LIST
38914: PPUSH
38915: LD_VAR 0 1
38919: PPUSH
38920: CALL 47120 0 3
38924: ST_TO_ADDR
// exit ;
38925: POP
38926: POP
38927: GO 38933
// end ; end ;
38929: GO 38733
38931: POP
38932: POP
// end ;
38933: LD_VAR 0 2
38937: RET
// export function MCE_BuildingComplete ( building ) ; var i , j , btype , tmp , units , side ; begin
38938: LD_INT 0
38940: PPUSH
38941: PPUSH
38942: PPUSH
38943: PPUSH
38944: PPUSH
38945: PPUSH
38946: PPUSH
// if not mc_bases or not skirmish then
38947: LD_EXP 56
38951: NOT
38952: PUSH
38953: LD_EXP 54
38957: NOT
38958: OR
38959: IFFALSE 38963
// exit ;
38961: GO 39624
// for i = 1 to mc_bases do
38963: LD_ADDR_VAR 0 3
38967: PUSH
38968: DOUBLE
38969: LD_INT 1
38971: DEC
38972: ST_TO_ADDR
38973: LD_EXP 56
38977: PUSH
38978: FOR_TO
38979: IFFALSE 39622
// begin if building in mc_construct_list [ i ] then
38981: LD_VAR 0 1
38985: PUSH
38986: LD_EXP 63
38990: PUSH
38991: LD_VAR 0 3
38995: ARRAY
38996: IN
38997: IFFALSE 39620
// begin mc_construct_list := Replace ( mc_construct_list , i , mc_construct_list [ i ] diff building ) ;
38999: LD_ADDR_EXP 63
39003: PUSH
39004: LD_EXP 63
39008: PPUSH
39009: LD_VAR 0 3
39013: PPUSH
39014: LD_EXP 63
39018: PUSH
39019: LD_VAR 0 3
39023: ARRAY
39024: PUSH
39025: LD_VAR 0 1
39029: DIFF
39030: PPUSH
39031: CALL_OW 1
39035: ST_TO_ADDR
// mc_bases := ReplaceIn ( mc_bases , [ i , mc_bases [ i ] + 1 ] , building ) ;
39036: LD_ADDR_EXP 56
39040: PUSH
39041: LD_EXP 56
39045: PPUSH
39046: LD_VAR 0 3
39050: PUSH
39051: LD_EXP 56
39055: PUSH
39056: LD_VAR 0 3
39060: ARRAY
39061: PUSH
39062: LD_INT 1
39064: PLUS
39065: PUSH
39066: EMPTY
39067: LIST
39068: LIST
39069: PPUSH
39070: LD_VAR 0 1
39074: PPUSH
39075: CALL 47120 0 3
39079: ST_TO_ADDR
// btype := GetBType ( building ) ;
39080: LD_ADDR_VAR 0 5
39084: PUSH
39085: LD_VAR 0 1
39089: PPUSH
39090: CALL_OW 266
39094: ST_TO_ADDR
// side := GetSide ( building ) ;
39095: LD_ADDR_VAR 0 8
39099: PUSH
39100: LD_VAR 0 1
39104: PPUSH
39105: CALL_OW 255
39109: ST_TO_ADDR
// if btype = b_lab then
39110: LD_VAR 0 5
39114: PUSH
39115: LD_INT 6
39117: EQUAL
39118: IFFALSE 39168
// begin mc_lab := ReplaceIn ( mc_lab , [ i , mc_lab [ i ] + 1 ] , building ) ;
39120: LD_ADDR_EXP 89
39124: PUSH
39125: LD_EXP 89
39129: PPUSH
39130: LD_VAR 0 3
39134: PUSH
39135: LD_EXP 89
39139: PUSH
39140: LD_VAR 0 3
39144: ARRAY
39145: PUSH
39146: LD_INT 1
39148: PLUS
39149: PUSH
39150: EMPTY
39151: LIST
39152: LIST
39153: PPUSH
39154: LD_VAR 0 1
39158: PPUSH
39159: CALL 47120 0 3
39163: ST_TO_ADDR
// exit ;
39164: POP
39165: POP
39166: GO 39624
// end ; if btype in [ b_depot , b_workshop , b_armoury ] then
39168: LD_VAR 0 5
39172: PUSH
39173: LD_INT 0
39175: PUSH
39176: LD_INT 2
39178: PUSH
39179: LD_INT 4
39181: PUSH
39182: EMPTY
39183: LIST
39184: LIST
39185: LIST
39186: IN
39187: IFFALSE 39311
// begin if btype = b_armoury then
39189: LD_VAR 0 5
39193: PUSH
39194: LD_INT 4
39196: EQUAL
39197: IFFALSE 39207
// btype := b_barracks ;
39199: LD_ADDR_VAR 0 5
39203: PUSH
39204: LD_INT 5
39206: ST_TO_ADDR
// if btype = b_depot then
39207: LD_VAR 0 5
39211: PUSH
39212: LD_INT 0
39214: EQUAL
39215: IFFALSE 39225
// btype := b_warehouse ;
39217: LD_ADDR_VAR 0 5
39221: PUSH
39222: LD_INT 1
39224: ST_TO_ADDR
// if btype = b_workshop then
39225: LD_VAR 0 5
39229: PUSH
39230: LD_INT 2
39232: EQUAL
39233: IFFALSE 39243
// btype := b_factory ;
39235: LD_ADDR_VAR 0 5
39239: PUSH
39240: LD_INT 3
39242: ST_TO_ADDR
// if GetRestrict ( btype , side ) = state_enabled then
39243: LD_VAR 0 5
39247: PPUSH
39248: LD_VAR 0 8
39252: PPUSH
39253: CALL_OW 323
39257: PUSH
39258: LD_INT 1
39260: EQUAL
39261: IFFALSE 39307
// mc_build_upgrade := ReplaceIn ( mc_build_upgrade , [ i , mc_build_upgrade [ i ] + 1 ] , building ) ;
39263: LD_ADDR_EXP 88
39267: PUSH
39268: LD_EXP 88
39272: PPUSH
39273: LD_VAR 0 3
39277: PUSH
39278: LD_EXP 88
39282: PUSH
39283: LD_VAR 0 3
39287: ARRAY
39288: PUSH
39289: LD_INT 1
39291: PLUS
39292: PUSH
39293: EMPTY
39294: LIST
39295: LIST
39296: PPUSH
39297: LD_VAR 0 1
39301: PPUSH
39302: CALL 47120 0 3
39306: ST_TO_ADDR
// exit ;
39307: POP
39308: POP
39309: GO 39624
// end ; if btype in [ b_bunker , b_turret ] then
39311: LD_VAR 0 5
39315: PUSH
39316: LD_INT 32
39318: PUSH
39319: LD_INT 33
39321: PUSH
39322: EMPTY
39323: LIST
39324: LIST
39325: IN
39326: IFFALSE 39616
// begin mc_turret_list := ReplaceIn ( mc_turret_list , [ i , mc_turret_list [ i ] + 1 ] , building ) ;
39328: LD_ADDR_EXP 64
39332: PUSH
39333: LD_EXP 64
39337: PPUSH
39338: LD_VAR 0 3
39342: PUSH
39343: LD_EXP 64
39347: PUSH
39348: LD_VAR 0 3
39352: ARRAY
39353: PUSH
39354: LD_INT 1
39356: PLUS
39357: PUSH
39358: EMPTY
39359: LIST
39360: LIST
39361: PPUSH
39362: LD_VAR 0 1
39366: PPUSH
39367: CALL 47120 0 3
39371: ST_TO_ADDR
// if btype = b_bunker then
39372: LD_VAR 0 5
39376: PUSH
39377: LD_INT 32
39379: EQUAL
39380: IFFALSE 39616
// begin mc_empty_turret_list := ReplaceIn ( mc_empty_turret_list , [ i , mc_empty_turret_list [ i ] + 1 ] , building ) ;
39382: LD_ADDR_EXP 65
39386: PUSH
39387: LD_EXP 65
39391: PPUSH
39392: LD_VAR 0 3
39396: PUSH
39397: LD_EXP 65
39401: PUSH
39402: LD_VAR 0 3
39406: ARRAY
39407: PUSH
39408: LD_INT 1
39410: PLUS
39411: PUSH
39412: EMPTY
39413: LIST
39414: LIST
39415: PPUSH
39416: LD_VAR 0 1
39420: PPUSH
39421: CALL 47120 0 3
39425: ST_TO_ADDR
// tmp := UnitFilter ( mc_bases [ i ] , [ [ f_class , 1 ] , [ f_not , [ f_inside ] ] ] ) ;
39426: LD_ADDR_VAR 0 6
39430: PUSH
39431: LD_EXP 56
39435: PUSH
39436: LD_VAR 0 3
39440: ARRAY
39441: PPUSH
39442: LD_INT 25
39444: PUSH
39445: LD_INT 1
39447: PUSH
39448: EMPTY
39449: LIST
39450: LIST
39451: PUSH
39452: LD_INT 3
39454: PUSH
39455: LD_INT 54
39457: PUSH
39458: EMPTY
39459: LIST
39460: PUSH
39461: EMPTY
39462: LIST
39463: LIST
39464: PUSH
39465: EMPTY
39466: LIST
39467: LIST
39468: PPUSH
39469: CALL_OW 72
39473: ST_TO_ADDR
// if tmp then
39474: LD_VAR 0 6
39478: IFFALSE 39484
// exit ;
39480: POP
39481: POP
39482: GO 39624
// tmp := UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_armoury ] , [ f_btype , b_barracks ] ] ) ;
39484: LD_ADDR_VAR 0 6
39488: PUSH
39489: LD_EXP 56
39493: PUSH
39494: LD_VAR 0 3
39498: ARRAY
39499: PPUSH
39500: LD_INT 2
39502: PUSH
39503: LD_INT 30
39505: PUSH
39506: LD_INT 4
39508: PUSH
39509: EMPTY
39510: LIST
39511: LIST
39512: PUSH
39513: LD_INT 30
39515: PUSH
39516: LD_INT 5
39518: PUSH
39519: EMPTY
39520: LIST
39521: LIST
39522: PUSH
39523: EMPTY
39524: LIST
39525: LIST
39526: LIST
39527: PPUSH
39528: CALL_OW 72
39532: ST_TO_ADDR
// if not tmp then
39533: LD_VAR 0 6
39537: NOT
39538: IFFALSE 39544
// exit ;
39540: POP
39541: POP
39542: GO 39624
// for j in tmp do
39544: LD_ADDR_VAR 0 4
39548: PUSH
39549: LD_VAR 0 6
39553: PUSH
39554: FOR_IN
39555: IFFALSE 39614
// begin units := UnitFilter ( UnitsInside ( j ) , [ f_class , 1 ] ) ;
39557: LD_ADDR_VAR 0 7
39561: PUSH
39562: LD_VAR 0 4
39566: PPUSH
39567: CALL_OW 313
39571: PPUSH
39572: LD_INT 25
39574: PUSH
39575: LD_INT 1
39577: PUSH
39578: EMPTY
39579: LIST
39580: LIST
39581: PPUSH
39582: CALL_OW 72
39586: ST_TO_ADDR
// if units then
39587: LD_VAR 0 7
39591: IFFALSE 39612
// begin ComExitBuilding ( units [ 1 ] ) ;
39593: LD_VAR 0 7
39597: PUSH
39598: LD_INT 1
39600: ARRAY
39601: PPUSH
39602: CALL_OW 122
// exit ;
39606: POP
39607: POP
39608: POP
39609: POP
39610: GO 39624
// end ; end ;
39612: GO 39554
39614: POP
39615: POP
// end ; end ; exit ;
39616: POP
39617: POP
39618: GO 39624
// end ; end ;
39620: GO 38978
39622: POP
39623: POP
// end ;
39624: LD_VAR 0 2
39628: RET
// export function MCE_BuildingStarted ( building , builder ) ; var i , j , btype , x , y , d ; begin
39629: LD_INT 0
39631: PPUSH
39632: PPUSH
39633: PPUSH
39634: PPUSH
39635: PPUSH
39636: PPUSH
39637: PPUSH
// if not mc_bases or not skirmish then
39638: LD_EXP 56
39642: NOT
39643: PUSH
39644: LD_EXP 54
39648: NOT
39649: OR
39650: IFFALSE 39654
// exit ;
39652: GO 39885
// btype := GetBType ( building ) ;
39654: LD_ADDR_VAR 0 6
39658: PUSH
39659: LD_VAR 0 1
39663: PPUSH
39664: CALL_OW 266
39668: ST_TO_ADDR
// x := GetX ( building ) ;
39669: LD_ADDR_VAR 0 7
39673: PUSH
39674: LD_VAR 0 1
39678: PPUSH
39679: CALL_OW 250
39683: ST_TO_ADDR
// y := GetY ( building ) ;
39684: LD_ADDR_VAR 0 8
39688: PUSH
39689: LD_VAR 0 1
39693: PPUSH
39694: CALL_OW 251
39698: ST_TO_ADDR
// d := GetDir ( building ) ;
39699: LD_ADDR_VAR 0 9
39703: PUSH
39704: LD_VAR 0 1
39708: PPUSH
39709: CALL_OW 254
39713: ST_TO_ADDR
// for i = 1 to mc_bases do
39714: LD_ADDR_VAR 0 4
39718: PUSH
39719: DOUBLE
39720: LD_INT 1
39722: DEC
39723: ST_TO_ADDR
39724: LD_EXP 56
39728: PUSH
39729: FOR_TO
39730: IFFALSE 39883
// begin if not mc_build_list [ i ] then
39732: LD_EXP 61
39736: PUSH
39737: LD_VAR 0 4
39741: ARRAY
39742: NOT
39743: IFFALSE 39747
// continue ;
39745: GO 39729
// if CompareArray ( [ btype , x , y , d ] , mc_build_list [ i ] [ 1 ] ) then
39747: LD_VAR 0 6
39751: PUSH
39752: LD_VAR 0 7
39756: PUSH
39757: LD_VAR 0 8
39761: PUSH
39762: LD_VAR 0 9
39766: PUSH
39767: EMPTY
39768: LIST
39769: LIST
39770: LIST
39771: LIST
39772: PPUSH
39773: LD_EXP 61
39777: PUSH
39778: LD_VAR 0 4
39782: ARRAY
39783: PUSH
39784: LD_INT 1
39786: ARRAY
39787: PPUSH
39788: CALL 53289 0 2
39792: IFFALSE 39881
// begin mc_build_list := Replace ( mc_build_list , i , Delete ( mc_build_list [ i ] , 1 ) ) ;
39794: LD_ADDR_EXP 61
39798: PUSH
39799: LD_EXP 61
39803: PPUSH
39804: LD_VAR 0 4
39808: PPUSH
39809: LD_EXP 61
39813: PUSH
39814: LD_VAR 0 4
39818: ARRAY
39819: PPUSH
39820: LD_INT 1
39822: PPUSH
39823: CALL_OW 3
39827: PPUSH
39828: CALL_OW 1
39832: ST_TO_ADDR
// mc_construct_list := ReplaceIn ( mc_construct_list , [ i , mc_construct_list [ i ] + 1 ] , building ) ;
39833: LD_ADDR_EXP 63
39837: PUSH
39838: LD_EXP 63
39842: PPUSH
39843: LD_VAR 0 4
39847: PUSH
39848: LD_EXP 63
39852: PUSH
39853: LD_VAR 0 4
39857: ARRAY
39858: PUSH
39859: LD_INT 1
39861: PLUS
39862: PUSH
39863: EMPTY
39864: LIST
39865: LIST
39866: PPUSH
39867: LD_VAR 0 1
39871: PPUSH
39872: CALL 47120 0 3
39876: ST_TO_ADDR
// exit ;
39877: POP
39878: POP
39879: GO 39885
// end ; end ;
39881: GO 39729
39883: POP
39884: POP
// end ;
39885: LD_VAR 0 3
39889: RET
// export function MCE_LeaveBuilding ( building , unit ) ; var i , tmp ; begin
39890: LD_INT 0
39892: PPUSH
39893: PPUSH
39894: PPUSH
// if not mc_bases or not skirmish then
39895: LD_EXP 56
39899: NOT
39900: PUSH
39901: LD_EXP 54
39905: NOT
39906: OR
39907: IFFALSE 39911
// exit ;
39909: GO 40101
// for i = 1 to mc_bases do
39911: LD_ADDR_VAR 0 4
39915: PUSH
39916: DOUBLE
39917: LD_INT 1
39919: DEC
39920: ST_TO_ADDR
39921: LD_EXP 56
39925: PUSH
39926: FOR_TO
39927: IFFALSE 40014
// begin if building in mc_turret_list [ i ] and not building in mc_empty_turret_list [ i ] then
39929: LD_VAR 0 1
39933: PUSH
39934: LD_EXP 64
39938: PUSH
39939: LD_VAR 0 4
39943: ARRAY
39944: IN
39945: PUSH
39946: LD_VAR 0 1
39950: PUSH
39951: LD_EXP 65
39955: PUSH
39956: LD_VAR 0 4
39960: ARRAY
39961: IN
39962: NOT
39963: AND
39964: IFFALSE 40012
// begin mc_empty_turret_list := ReplaceIn ( mc_empty_turret_list , [ i , mc_empty_turret_list [ i ] + 1 ] , building ) ;
39966: LD_ADDR_EXP 65
39970: PUSH
39971: LD_EXP 65
39975: PPUSH
39976: LD_VAR 0 4
39980: PUSH
39981: LD_EXP 65
39985: PUSH
39986: LD_VAR 0 4
39990: ARRAY
39991: PUSH
39992: LD_INT 1
39994: PLUS
39995: PUSH
39996: EMPTY
39997: LIST
39998: LIST
39999: PPUSH
40000: LD_VAR 0 1
40004: PPUSH
40005: CALL 47120 0 3
40009: ST_TO_ADDR
// break ;
40010: GO 40014
// end ; end ;
40012: GO 39926
40014: POP
40015: POP
// if GetClass ( building ) in mc_sides and GetBType ( building ) = b_barracks and GetTag ( unit ) <> 18 then
40016: LD_VAR 0 1
40020: PPUSH
40021: CALL_OW 257
40025: PUSH
40026: LD_EXP 82
40030: IN
40031: PUSH
40032: LD_VAR 0 1
40036: PPUSH
40037: CALL_OW 266
40041: PUSH
40042: LD_INT 5
40044: EQUAL
40045: AND
40046: PUSH
40047: LD_VAR 0 2
40051: PPUSH
40052: CALL_OW 110
40056: PUSH
40057: LD_INT 18
40059: NONEQUAL
40060: AND
40061: IFFALSE 40101
// if GetClass ( unit ) in [ 5 , 8 , 9 ] then
40063: LD_VAR 0 2
40067: PPUSH
40068: CALL_OW 257
40072: PUSH
40073: LD_INT 5
40075: PUSH
40076: LD_INT 8
40078: PUSH
40079: LD_INT 9
40081: PUSH
40082: EMPTY
40083: LIST
40084: LIST
40085: LIST
40086: IN
40087: IFFALSE 40101
// SetClass ( unit , 1 ) ;
40089: LD_VAR 0 2
40093: PPUSH
40094: LD_INT 1
40096: PPUSH
40097: CALL_OW 336
// end ;
40101: LD_VAR 0 3
40105: RET
// export function MCE_EvacuateVehicle ( driver , abandoned_vehicle , unknown1 , unknown2 ) ; var i ; begin
40106: LD_INT 0
40108: PPUSH
40109: PPUSH
// if not mc_bases or not skirmish then
40110: LD_EXP 56
40114: NOT
40115: PUSH
40116: LD_EXP 54
40120: NOT
40121: OR
40122: IFFALSE 40126
// exit ;
40124: GO 40242
// if GetLives ( abandoned_vehicle ) > 250 then
40126: LD_VAR 0 2
40130: PPUSH
40131: CALL_OW 256
40135: PUSH
40136: LD_INT 250
40138: GREATER
40139: IFFALSE 40143
// exit ;
40141: GO 40242
// for i = 1 to mc_bases do
40143: LD_ADDR_VAR 0 6
40147: PUSH
40148: DOUBLE
40149: LD_INT 1
40151: DEC
40152: ST_TO_ADDR
40153: LD_EXP 56
40157: PUSH
40158: FOR_TO
40159: IFFALSE 40240
// begin if driver in mc_bases [ i ] then
40161: LD_VAR 0 1
40165: PUSH
40166: LD_EXP 56
40170: PUSH
40171: LD_VAR 0 6
40175: ARRAY
40176: IN
40177: IFFALSE 40238
// begin ComMoveUnit ( driver , UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) [ 1 ] ) ;
40179: LD_VAR 0 1
40183: PPUSH
40184: LD_EXP 56
40188: PUSH
40189: LD_VAR 0 6
40193: ARRAY
40194: PPUSH
40195: LD_INT 2
40197: PUSH
40198: LD_INT 30
40200: PUSH
40201: LD_INT 0
40203: PUSH
40204: EMPTY
40205: LIST
40206: LIST
40207: PUSH
40208: LD_INT 30
40210: PUSH
40211: LD_INT 1
40213: PUSH
40214: EMPTY
40215: LIST
40216: LIST
40217: PUSH
40218: EMPTY
40219: LIST
40220: LIST
40221: LIST
40222: PPUSH
40223: CALL_OW 72
40227: PUSH
40228: LD_INT 1
40230: ARRAY
40231: PPUSH
40232: CALL_OW 112
// break ;
40236: GO 40240
// end ; end ;
40238: GO 40158
40240: POP
40241: POP
// end ; end_of_file
40242: LD_VAR 0 5
40246: RET
// export function PrepareUnit ( ident , exist_mode , prefix ) ; var unit ; begin
40247: LD_INT 0
40249: PPUSH
40250: PPUSH
// if exist_mode then
40251: LD_VAR 0 2
40255: IFFALSE 40280
// unit := CreateCharacter ( prefix & ident ) else
40257: LD_ADDR_VAR 0 5
40261: PUSH
40262: LD_VAR 0 3
40266: PUSH
40267: LD_VAR 0 1
40271: STR
40272: PPUSH
40273: CALL_OW 34
40277: ST_TO_ADDR
40278: GO 40295
// unit := NewCharacter ( ident ) ;
40280: LD_ADDR_VAR 0 5
40284: PUSH
40285: LD_VAR 0 1
40289: PPUSH
40290: CALL_OW 25
40294: ST_TO_ADDR
// result := unit ;
40295: LD_ADDR_VAR 0 4
40299: PUSH
40300: LD_VAR 0 5
40304: ST_TO_ADDR
// end ;
40305: LD_VAR 0 4
40309: RET
// export function GetTechNation ( side , nation , state ) ; var i ; begin
40310: LD_INT 0
40312: PPUSH
40313: PPUSH
// if not side or not nation then
40314: LD_VAR 0 1
40318: NOT
40319: PUSH
40320: LD_VAR 0 2
40324: NOT
40325: OR
40326: IFFALSE 40330
// exit ;
40328: GO 40974
// case nation of nation_american :
40330: LD_VAR 0 2
40334: PUSH
40335: LD_INT 1
40337: DOUBLE
40338: EQUAL
40339: IFTRUE 40343
40341: GO 40517
40343: POP
// result := [ 35 , 45 , 46 , 47 , 1 , 2 , 6 , 15 , 16 , 7 , 12 , 13 , 10 , 14 , 20 , 21 , 22 , 25 , 32 , 27 , 36 , 69 , 39 , 34 , 40 , 48 , 49 , 50 , 51 , 52 , 53 , 54 , 55 , 56 , 57 , 58 , 59 , 60 , 61 , 62 , 80 ] ; nation_arabian :
40344: LD_ADDR_VAR 0 4
40348: PUSH
40349: LD_INT 35
40351: PUSH
40352: LD_INT 45
40354: PUSH
40355: LD_INT 46
40357: PUSH
40358: LD_INT 47
40360: PUSH
40361: LD_INT 1
40363: PUSH
40364: LD_INT 2
40366: PUSH
40367: LD_INT 6
40369: PUSH
40370: LD_INT 15
40372: PUSH
40373: LD_INT 16
40375: PUSH
40376: LD_INT 7
40378: PUSH
40379: LD_INT 12
40381: PUSH
40382: LD_INT 13
40384: PUSH
40385: LD_INT 10
40387: PUSH
40388: LD_INT 14
40390: PUSH
40391: LD_INT 20
40393: PUSH
40394: LD_INT 21
40396: PUSH
40397: LD_INT 22
40399: PUSH
40400: LD_INT 25
40402: PUSH
40403: LD_INT 32
40405: PUSH
40406: LD_INT 27
40408: PUSH
40409: LD_INT 36
40411: PUSH
40412: LD_INT 69
40414: PUSH
40415: LD_INT 39
40417: PUSH
40418: LD_INT 34
40420: PUSH
40421: LD_INT 40
40423: PUSH
40424: LD_INT 48
40426: PUSH
40427: LD_INT 49
40429: PUSH
40430: LD_INT 50
40432: PUSH
40433: LD_INT 51
40435: PUSH
40436: LD_INT 52
40438: PUSH
40439: LD_INT 53
40441: PUSH
40442: LD_INT 54
40444: PUSH
40445: LD_INT 55
40447: PUSH
40448: LD_INT 56
40450: PUSH
40451: LD_INT 57
40453: PUSH
40454: LD_INT 58
40456: PUSH
40457: LD_INT 59
40459: PUSH
40460: LD_INT 60
40462: PUSH
40463: LD_INT 61
40465: PUSH
40466: LD_INT 62
40468: PUSH
40469: LD_INT 80
40471: PUSH
40472: EMPTY
40473: LIST
40474: LIST
40475: LIST
40476: LIST
40477: LIST
40478: LIST
40479: LIST
40480: LIST
40481: LIST
40482: LIST
40483: LIST
40484: LIST
40485: LIST
40486: LIST
40487: LIST
40488: LIST
40489: LIST
40490: LIST
40491: LIST
40492: LIST
40493: LIST
40494: LIST
40495: LIST
40496: LIST
40497: LIST
40498: LIST
40499: LIST
40500: LIST
40501: LIST
40502: LIST
40503: LIST
40504: LIST
40505: LIST
40506: LIST
40507: LIST
40508: LIST
40509: LIST
40510: LIST
40511: LIST
40512: LIST
40513: LIST
40514: ST_TO_ADDR
40515: GO 40898
40517: LD_INT 2
40519: DOUBLE
40520: EQUAL
40521: IFTRUE 40525
40523: GO 40707
40525: POP
// result := [ 35 , 45 , 46 , 47 , 70 , 1 , 11 , 3 , 4 , 5 , 6 , 15 , 18 , 7 , 17 , 8 , 20 , 21 , 22 , 72 , 26 , 69 , 39 , 40 , 41 , 42 , 43 , 48 , 49 , 50 , 51 , 52 , 53 , 54 , 55 , 56 , 60 , 61 , 62 , 66 , 67 , 68 , 81 ] ; nation_russian :
40526: LD_ADDR_VAR 0 4
40530: PUSH
40531: LD_INT 35
40533: PUSH
40534: LD_INT 45
40536: PUSH
40537: LD_INT 46
40539: PUSH
40540: LD_INT 47
40542: PUSH
40543: LD_INT 70
40545: PUSH
40546: LD_INT 1
40548: PUSH
40549: LD_INT 11
40551: PUSH
40552: LD_INT 3
40554: PUSH
40555: LD_INT 4
40557: PUSH
40558: LD_INT 5
40560: PUSH
40561: LD_INT 6
40563: PUSH
40564: LD_INT 15
40566: PUSH
40567: LD_INT 18
40569: PUSH
40570: LD_INT 7
40572: PUSH
40573: LD_INT 17
40575: PUSH
40576: LD_INT 8
40578: PUSH
40579: LD_INT 20
40581: PUSH
40582: LD_INT 21
40584: PUSH
40585: LD_INT 22
40587: PUSH
40588: LD_INT 72
40590: PUSH
40591: LD_INT 26
40593: PUSH
40594: LD_INT 69
40596: PUSH
40597: LD_INT 39
40599: PUSH
40600: LD_INT 40
40602: PUSH
40603: LD_INT 41
40605: PUSH
40606: LD_INT 42
40608: PUSH
40609: LD_INT 43
40611: PUSH
40612: LD_INT 48
40614: PUSH
40615: LD_INT 49
40617: PUSH
40618: LD_INT 50
40620: PUSH
40621: LD_INT 51
40623: PUSH
40624: LD_INT 52
40626: PUSH
40627: LD_INT 53
40629: PUSH
40630: LD_INT 54
40632: PUSH
40633: LD_INT 55
40635: PUSH
40636: LD_INT 56
40638: PUSH
40639: LD_INT 60
40641: PUSH
40642: LD_INT 61
40644: PUSH
40645: LD_INT 62
40647: PUSH
40648: LD_INT 66
40650: PUSH
40651: LD_INT 67
40653: PUSH
40654: LD_INT 68
40656: PUSH
40657: LD_INT 81
40659: PUSH
40660: EMPTY
40661: LIST
40662: LIST
40663: LIST
40664: LIST
40665: LIST
40666: LIST
40667: LIST
40668: LIST
40669: LIST
40670: LIST
40671: LIST
40672: LIST
40673: LIST
40674: LIST
40675: LIST
40676: LIST
40677: LIST
40678: LIST
40679: LIST
40680: LIST
40681: LIST
40682: LIST
40683: LIST
40684: LIST
40685: LIST
40686: LIST
40687: LIST
40688: LIST
40689: LIST
40690: LIST
40691: LIST
40692: LIST
40693: LIST
40694: LIST
40695: LIST
40696: LIST
40697: LIST
40698: LIST
40699: LIST
40700: LIST
40701: LIST
40702: LIST
40703: LIST
40704: ST_TO_ADDR
40705: GO 40898
40707: LD_INT 3
40709: DOUBLE
40710: EQUAL
40711: IFTRUE 40715
40713: GO 40897
40715: POP
// result := [ 46 , 47 , 1 , 2 , 11 , 9 , 20 , 19 , 21 , 24 , 22 , 25 , 28 , 29 , 30 , 31 , 37 , 38 , 32 , 27 , 33 , 69 , 39 , 34 , 40 , 71 , 23 , 44 , 48 , 49 , 50 , 51 , 52 , 53 , 54 , 55 , 56 , 57 , 58 , 59 , 63 , 64 , 65 ] ; end ;
40716: LD_ADDR_VAR 0 4
40720: PUSH
40721: LD_INT 46
40723: PUSH
40724: LD_INT 47
40726: PUSH
40727: LD_INT 1
40729: PUSH
40730: LD_INT 2
40732: PUSH
40733: LD_INT 11
40735: PUSH
40736: LD_INT 9
40738: PUSH
40739: LD_INT 20
40741: PUSH
40742: LD_INT 19
40744: PUSH
40745: LD_INT 21
40747: PUSH
40748: LD_INT 24
40750: PUSH
40751: LD_INT 22
40753: PUSH
40754: LD_INT 25
40756: PUSH
40757: LD_INT 28
40759: PUSH
40760: LD_INT 29
40762: PUSH
40763: LD_INT 30
40765: PUSH
40766: LD_INT 31
40768: PUSH
40769: LD_INT 37
40771: PUSH
40772: LD_INT 38
40774: PUSH
40775: LD_INT 32
40777: PUSH
40778: LD_INT 27
40780: PUSH
40781: LD_INT 33
40783: PUSH
40784: LD_INT 69
40786: PUSH
40787: LD_INT 39
40789: PUSH
40790: LD_INT 34
40792: PUSH
40793: LD_INT 40
40795: PUSH
40796: LD_INT 71
40798: PUSH
40799: LD_INT 23
40801: PUSH
40802: LD_INT 44
40804: PUSH
40805: LD_INT 48
40807: PUSH
40808: LD_INT 49
40810: PUSH
40811: LD_INT 50
40813: PUSH
40814: LD_INT 51
40816: PUSH
40817: LD_INT 52
40819: PUSH
40820: LD_INT 53
40822: PUSH
40823: LD_INT 54
40825: PUSH
40826: LD_INT 55
40828: PUSH
40829: LD_INT 56
40831: PUSH
40832: LD_INT 57
40834: PUSH
40835: LD_INT 58
40837: PUSH
40838: LD_INT 59
40840: PUSH
40841: LD_INT 63
40843: PUSH
40844: LD_INT 64
40846: PUSH
40847: LD_INT 65
40849: PUSH
40850: EMPTY
40851: LIST
40852: LIST
40853: LIST
40854: LIST
40855: LIST
40856: LIST
40857: LIST
40858: LIST
40859: LIST
40860: LIST
40861: LIST
40862: LIST
40863: LIST
40864: LIST
40865: LIST
40866: LIST
40867: LIST
40868: LIST
40869: LIST
40870: LIST
40871: LIST
40872: LIST
40873: LIST
40874: LIST
40875: LIST
40876: LIST
40877: LIST
40878: LIST
40879: LIST
40880: LIST
40881: LIST
40882: LIST
40883: LIST
40884: LIST
40885: LIST
40886: LIST
40887: LIST
40888: LIST
40889: LIST
40890: LIST
40891: LIST
40892: LIST
40893: LIST
40894: ST_TO_ADDR
40895: GO 40898
40897: POP
// if state > - 1 and state < 3 then
40898: LD_VAR 0 3
40902: PUSH
40903: LD_INT 1
40905: NEG
40906: GREATER
40907: PUSH
40908: LD_VAR 0 3
40912: PUSH
40913: LD_INT 3
40915: LESS
40916: AND
40917: IFFALSE 40974
// for i in result do
40919: LD_ADDR_VAR 0 5
40923: PUSH
40924: LD_VAR 0 4
40928: PUSH
40929: FOR_IN
40930: IFFALSE 40972
// if GetTech ( i , side ) <> state then
40932: LD_VAR 0 5
40936: PPUSH
40937: LD_VAR 0 1
40941: PPUSH
40942: CALL_OW 321
40946: PUSH
40947: LD_VAR 0 3
40951: NONEQUAL
40952: IFFALSE 40970
// result := result diff i ;
40954: LD_ADDR_VAR 0 4
40958: PUSH
40959: LD_VAR 0 4
40963: PUSH
40964: LD_VAR 0 5
40968: DIFF
40969: ST_TO_ADDR
40970: GO 40929
40972: POP
40973: POP
// end ;
40974: LD_VAR 0 4
40978: RET
// export function TechCanBeResearch ( side , tech ) ; var i , tmp ; begin
40979: LD_INT 0
40981: PPUSH
40982: PPUSH
40983: PPUSH
// result := true ;
40984: LD_ADDR_VAR 0 3
40988: PUSH
40989: LD_INT 1
40991: ST_TO_ADDR
// tmp := GetTechTechsReq ( tech ) ;
40992: LD_ADDR_VAR 0 5
40996: PUSH
40997: LD_VAR 0 2
41001: PPUSH
41002: CALL_OW 480
41006: ST_TO_ADDR
// if not tmp then
41007: LD_VAR 0 5
41011: NOT
41012: IFFALSE 41016
// exit ;
41014: GO 41065
// for i in tmp do
41016: LD_ADDR_VAR 0 4
41020: PUSH
41021: LD_VAR 0 5
41025: PUSH
41026: FOR_IN
41027: IFFALSE 41063
// if GetTech ( i , side ) <> state_researched then
41029: LD_VAR 0 4
41033: PPUSH
41034: LD_VAR 0 1
41038: PPUSH
41039: CALL_OW 321
41043: PUSH
41044: LD_INT 2
41046: NONEQUAL
41047: IFFALSE 41061
// begin result := false ;
41049: LD_ADDR_VAR 0 3
41053: PUSH
41054: LD_INT 0
41056: ST_TO_ADDR
// exit ;
41057: POP
41058: POP
41059: GO 41065
// end ;
41061: GO 41026
41063: POP
41064: POP
// end ;
41065: LD_VAR 0 3
41069: RET
// export function ComSpaceTimeShoot ( unit ) ; var i , x , y , _x , _y , tmp , side , enemy , in_unit , tech_space , tech_time , missile ; begin
41070: LD_INT 0
41072: PPUSH
41073: PPUSH
41074: PPUSH
41075: PPUSH
41076: PPUSH
41077: PPUSH
41078: PPUSH
41079: PPUSH
41080: PPUSH
41081: PPUSH
41082: PPUSH
41083: PPUSH
41084: PPUSH
// if not unit or GetClass ( unit ) <> class_bazooker then
41085: LD_VAR 0 1
41089: NOT
41090: PUSH
41091: LD_VAR 0 1
41095: PPUSH
41096: CALL_OW 257
41100: PUSH
41101: LD_INT 9
41103: NONEQUAL
41104: OR
41105: IFFALSE 41109
// exit ;
41107: GO 41682
// side := GetSide ( unit ) ;
41109: LD_ADDR_VAR 0 9
41113: PUSH
41114: LD_VAR 0 1
41118: PPUSH
41119: CALL_OW 255
41123: ST_TO_ADDR
// tech_space := tech_spacanom ;
41124: LD_ADDR_VAR 0 12
41128: PUSH
41129: LD_INT 29
41131: ST_TO_ADDR
// tech_time := tech_taurad ;
41132: LD_ADDR_VAR 0 13
41136: PUSH
41137: LD_INT 28
41139: ST_TO_ADDR
// in_unit := IsInUnit ( unit ) ;
41140: LD_ADDR_VAR 0 11
41144: PUSH
41145: LD_VAR 0 1
41149: PPUSH
41150: CALL_OW 310
41154: ST_TO_ADDR
// if GetType ( in_unit ) = unit_vehicle then
41155: LD_VAR 0 11
41159: PPUSH
41160: CALL_OW 247
41164: PUSH
41165: LD_INT 2
41167: EQUAL
41168: IFFALSE 41172
// exit ;
41170: GO 41682
// tmp := FilterAllUnits ( [ [ f_enemy , side ] , [ f_not , [ f_type , unit_building ] ] ] ) ;
41172: LD_ADDR_VAR 0 8
41176: PUSH
41177: LD_INT 81
41179: PUSH
41180: LD_VAR 0 9
41184: PUSH
41185: EMPTY
41186: LIST
41187: LIST
41188: PUSH
41189: LD_INT 3
41191: PUSH
41192: LD_INT 21
41194: PUSH
41195: LD_INT 3
41197: PUSH
41198: EMPTY
41199: LIST
41200: LIST
41201: PUSH
41202: EMPTY
41203: LIST
41204: LIST
41205: PUSH
41206: EMPTY
41207: LIST
41208: LIST
41209: PPUSH
41210: CALL_OW 69
41214: ST_TO_ADDR
// if not tmp then
41215: LD_VAR 0 8
41219: NOT
41220: IFFALSE 41224
// exit ;
41222: GO 41682
// if in_unit then
41224: LD_VAR 0 11
41228: IFFALSE 41252
// enemy := NearestUnitToUnit ( tmp , in_unit ) else
41230: LD_ADDR_VAR 0 10
41234: PUSH
41235: LD_VAR 0 8
41239: PPUSH
41240: LD_VAR 0 11
41244: PPUSH
41245: CALL_OW 74
41249: ST_TO_ADDR
41250: GO 41272
// enemy := NearestUnitToUnit ( tmp , unit ) ;
41252: LD_ADDR_VAR 0 10
41256: PUSH
41257: LD_VAR 0 8
41261: PPUSH
41262: LD_VAR 0 1
41266: PPUSH
41267: CALL_OW 74
41271: ST_TO_ADDR
// if not enemy then
41272: LD_VAR 0 10
41276: NOT
41277: IFFALSE 41281
// exit ;
41279: GO 41682
// if ( in_unit and GetDistUnits ( in_unit , enemy ) > 13 ) or GetDistUnits ( unit , enemy ) > 12 then
41281: LD_VAR 0 11
41285: PUSH
41286: LD_VAR 0 11
41290: PPUSH
41291: LD_VAR 0 10
41295: PPUSH
41296: CALL_OW 296
41300: PUSH
41301: LD_INT 13
41303: GREATER
41304: AND
41305: PUSH
41306: LD_VAR 0 1
41310: PPUSH
41311: LD_VAR 0 10
41315: PPUSH
41316: CALL_OW 296
41320: PUSH
41321: LD_INT 12
41323: GREATER
41324: OR
41325: IFFALSE 41329
// exit ;
41327: GO 41682
// missile := [ 1 ] ;
41329: LD_ADDR_VAR 0 14
41333: PUSH
41334: LD_INT 1
41336: PUSH
41337: EMPTY
41338: LIST
41339: ST_TO_ADDR
// if Researched ( side , tech_space ) then
41340: LD_VAR 0 9
41344: PPUSH
41345: LD_VAR 0 12
41349: PPUSH
41350: CALL_OW 325
41354: IFFALSE 41383
// missile := Insert ( missile , missile + 1 , 2 ) ;
41356: LD_ADDR_VAR 0 14
41360: PUSH
41361: LD_VAR 0 14
41365: PPUSH
41366: LD_VAR 0 14
41370: PUSH
41371: LD_INT 1
41373: PLUS
41374: PPUSH
41375: LD_INT 2
41377: PPUSH
41378: CALL_OW 2
41382: ST_TO_ADDR
// if Researched ( side , tech_time ) and not Researched ( GetSide ( enemy ) , tech_time ) then
41383: LD_VAR 0 9
41387: PPUSH
41388: LD_VAR 0 13
41392: PPUSH
41393: CALL_OW 325
41397: PUSH
41398: LD_VAR 0 10
41402: PPUSH
41403: CALL_OW 255
41407: PPUSH
41408: LD_VAR 0 13
41412: PPUSH
41413: CALL_OW 325
41417: NOT
41418: AND
41419: IFFALSE 41448
// missile := Insert ( missile , missile + 1 , 3 ) ;
41421: LD_ADDR_VAR 0 14
41425: PUSH
41426: LD_VAR 0 14
41430: PPUSH
41431: LD_VAR 0 14
41435: PUSH
41436: LD_INT 1
41438: PLUS
41439: PPUSH
41440: LD_INT 3
41442: PPUSH
41443: CALL_OW 2
41447: ST_TO_ADDR
// if missile < 2 then
41448: LD_VAR 0 14
41452: PUSH
41453: LD_INT 2
41455: LESS
41456: IFFALSE 41460
// exit ;
41458: GO 41682
// x := GetX ( enemy ) ;
41460: LD_ADDR_VAR 0 4
41464: PUSH
41465: LD_VAR 0 10
41469: PPUSH
41470: CALL_OW 250
41474: ST_TO_ADDR
// y := GetY ( enemy ) ;
41475: LD_ADDR_VAR 0 5
41479: PUSH
41480: LD_VAR 0 10
41484: PPUSH
41485: CALL_OW 251
41489: ST_TO_ADDR
// _x := x + rand ( - 1 , 1 ) ;
41490: LD_ADDR_VAR 0 6
41494: PUSH
41495: LD_VAR 0 4
41499: PUSH
41500: LD_INT 1
41502: NEG
41503: PPUSH
41504: LD_INT 1
41506: PPUSH
41507: CALL_OW 12
41511: PLUS
41512: ST_TO_ADDR
// _y := y + rand ( - 1 , 1 ) ;
41513: LD_ADDR_VAR 0 7
41517: PUSH
41518: LD_VAR 0 5
41522: PUSH
41523: LD_INT 1
41525: NEG
41526: PPUSH
41527: LD_INT 1
41529: PPUSH
41530: CALL_OW 12
41534: PLUS
41535: ST_TO_ADDR
// if not ValidHex ( _x , _y ) then
41536: LD_VAR 0 6
41540: PPUSH
41541: LD_VAR 0 7
41545: PPUSH
41546: CALL_OW 488
41550: NOT
41551: IFFALSE 41573
// begin _x := x ;
41553: LD_ADDR_VAR 0 6
41557: PUSH
41558: LD_VAR 0 4
41562: ST_TO_ADDR
// _y := y ;
41563: LD_ADDR_VAR 0 7
41567: PUSH
41568: LD_VAR 0 5
41572: ST_TO_ADDR
// end ; i := rand ( 1 , missile ) ;
41573: LD_ADDR_VAR 0 3
41577: PUSH
41578: LD_INT 1
41580: PPUSH
41581: LD_VAR 0 14
41585: PPUSH
41586: CALL_OW 12
41590: ST_TO_ADDR
// case i of 1 :
41591: LD_VAR 0 3
41595: PUSH
41596: LD_INT 1
41598: DOUBLE
41599: EQUAL
41600: IFTRUE 41604
41602: GO 41621
41604: POP
// ComAttackUnit ( unit , enemy ) ; 2 :
41605: LD_VAR 0 1
41609: PPUSH
41610: LD_VAR 0 10
41614: PPUSH
41615: CALL_OW 115
41619: GO 41682
41621: LD_INT 2
41623: DOUBLE
41624: EQUAL
41625: IFTRUE 41629
41627: GO 41651
41629: POP
// ComSpaceShift ( unit , _x , _y ) ; 3 :
41630: LD_VAR 0 1
41634: PPUSH
41635: LD_VAR 0 6
41639: PPUSH
41640: LD_VAR 0 7
41644: PPUSH
41645: CALL_OW 153
41649: GO 41682
41651: LD_INT 3
41653: DOUBLE
41654: EQUAL
41655: IFTRUE 41659
41657: GO 41681
41659: POP
// ComTimeShift ( unit , _x , _y ) ; end ;
41660: LD_VAR 0 1
41664: PPUSH
41665: LD_VAR 0 6
41669: PPUSH
41670: LD_VAR 0 7
41674: PPUSH
41675: CALL_OW 154
41679: GO 41682
41681: POP
// end ;
41682: LD_VAR 0 2
41686: RET
// export function ComStandNearbyBuilding ( unit , building ) ; var i , x , y , _x , _y ; begin
41687: LD_INT 0
41689: PPUSH
41690: PPUSH
41691: PPUSH
41692: PPUSH
41693: PPUSH
41694: PPUSH
// if not unit or not building then
41695: LD_VAR 0 1
41699: NOT
41700: PUSH
41701: LD_VAR 0 2
41705: NOT
41706: OR
41707: IFFALSE 41711
// exit ;
41709: GO 41869
// x := GetX ( building ) ;
41711: LD_ADDR_VAR 0 5
41715: PUSH
41716: LD_VAR 0 2
41720: PPUSH
41721: CALL_OW 250
41725: ST_TO_ADDR
// y := GetY ( building ) ;
41726: LD_ADDR_VAR 0 6
41730: PUSH
41731: LD_VAR 0 2
41735: PPUSH
41736: CALL_OW 251
41740: ST_TO_ADDR
// for i = 0 to 5 do
41741: LD_ADDR_VAR 0 4
41745: PUSH
41746: DOUBLE
41747: LD_INT 0
41749: DEC
41750: ST_TO_ADDR
41751: LD_INT 5
41753: PUSH
41754: FOR_TO
41755: IFFALSE 41867
// begin _x := ShiftX ( x , i , 3 ) ;
41757: LD_ADDR_VAR 0 7
41761: PUSH
41762: LD_VAR 0 5
41766: PPUSH
41767: LD_VAR 0 4
41771: PPUSH
41772: LD_INT 3
41774: PPUSH
41775: CALL_OW 272
41779: ST_TO_ADDR
// _y := ShiftY ( y , i , 3 ) ;
41780: LD_ADDR_VAR 0 8
41784: PUSH
41785: LD_VAR 0 6
41789: PPUSH
41790: LD_VAR 0 4
41794: PPUSH
41795: LD_INT 3
41797: PPUSH
41798: CALL_OW 273
41802: ST_TO_ADDR
// if not ValidHex ( _x , _y ) then
41803: LD_VAR 0 7
41807: PPUSH
41808: LD_VAR 0 8
41812: PPUSH
41813: CALL_OW 488
41817: NOT
41818: IFFALSE 41822
// continue ;
41820: GO 41754
// if HexInfo ( _x , _y ) = 0 then
41822: LD_VAR 0 7
41826: PPUSH
41827: LD_VAR 0 8
41831: PPUSH
41832: CALL_OW 428
41836: PUSH
41837: LD_INT 0
41839: EQUAL
41840: IFFALSE 41865
// begin ComMoveXY ( unit , _x , _y ) ;
41842: LD_VAR 0 1
41846: PPUSH
41847: LD_VAR 0 7
41851: PPUSH
41852: LD_VAR 0 8
41856: PPUSH
41857: CALL_OW 111
// exit ;
41861: POP
41862: POP
41863: GO 41869
// end ; end ;
41865: GO 41754
41867: POP
41868: POP
// end ;
41869: LD_VAR 0 3
41873: RET
// export function ScanBase ( side , base_area ) ; begin
41874: LD_INT 0
41876: PPUSH
// result := FilterUnitsInArea ( base_area , [ f_enemy , side ] ) ;
41877: LD_ADDR_VAR 0 3
41881: PUSH
41882: LD_VAR 0 2
41886: PPUSH
41887: LD_INT 81
41889: PUSH
41890: LD_VAR 0 1
41894: PUSH
41895: EMPTY
41896: LIST
41897: LIST
41898: PPUSH
41899: CALL_OW 70
41903: ST_TO_ADDR
// end ;
41904: LD_VAR 0 3
41908: RET
// export function BasicDefend ( base , solds , area ) ; var enemy , side , i , hex ; begin
41909: LD_INT 0
41911: PPUSH
41912: PPUSH
41913: PPUSH
41914: PPUSH
41915: PPUSH
// if not base or not mc_bases [ base ] or not solds or not area then
41916: LD_VAR 0 1
41920: NOT
41921: PUSH
41922: LD_EXP 56
41926: PUSH
41927: LD_VAR 0 1
41931: ARRAY
41932: NOT
41933: OR
41934: PUSH
41935: LD_VAR 0 2
41939: NOT
41940: OR
41941: PUSH
41942: LD_VAR 0 3
41946: NOT
41947: OR
41948: IFFALSE 41952
// exit ;
41950: GO 42402
// side := mc_sides [ base ] ;
41952: LD_ADDR_VAR 0 6
41956: PUSH
41957: LD_EXP 82
41961: PUSH
41962: LD_VAR 0 1
41966: ARRAY
41967: ST_TO_ADDR
// if not side then
41968: LD_VAR 0 6
41972: NOT
41973: IFFALSE 41977
// exit ;
41975: GO 42402
// for i in solds do
41977: LD_ADDR_VAR 0 7
41981: PUSH
41982: LD_VAR 0 2
41986: PUSH
41987: FOR_IN
41988: IFFALSE 42049
// if GetBType ( IsInUnit ( i ) ) in [ b_bunker , b_breastwork ] then
41990: LD_VAR 0 7
41994: PPUSH
41995: CALL_OW 310
41999: PPUSH
42000: CALL_OW 266
42004: PUSH
42005: LD_INT 32
42007: PUSH
42008: LD_INT 31
42010: PUSH
42011: EMPTY
42012: LIST
42013: LIST
42014: IN
42015: IFFALSE 42035
// solds := solds diff i else
42017: LD_ADDR_VAR 0 2
42021: PUSH
42022: LD_VAR 0 2
42026: PUSH
42027: LD_VAR 0 7
42031: DIFF
42032: ST_TO_ADDR
42033: GO 42047
// SetTag ( i , 18 ) ;
42035: LD_VAR 0 7
42039: PPUSH
42040: LD_INT 18
42042: PPUSH
42043: CALL_OW 109
42047: GO 41987
42049: POP
42050: POP
// if not solds then
42051: LD_VAR 0 2
42055: NOT
42056: IFFALSE 42060
// exit ;
42058: GO 42402
// repeat wait ( 0 0$1 ) ;
42060: LD_INT 35
42062: PPUSH
42063: CALL_OW 67
// enemy := ScanBase ( side , area ) ;
42067: LD_ADDR_VAR 0 5
42071: PUSH
42072: LD_VAR 0 6
42076: PPUSH
42077: LD_VAR 0 3
42081: PPUSH
42082: CALL 41874 0 2
42086: ST_TO_ADDR
// if not enemy or enemy > 3 or mc_defender [ base ] then
42087: LD_VAR 0 5
42091: NOT
42092: PUSH
42093: LD_VAR 0 5
42097: PUSH
42098: LD_INT 3
42100: GREATER
42101: OR
42102: PUSH
42103: LD_EXP 78
42107: PUSH
42108: LD_VAR 0 1
42112: ARRAY
42113: OR
42114: IFFALSE 42155
// begin for i in solds do
42116: LD_ADDR_VAR 0 7
42120: PUSH
42121: LD_VAR 0 2
42125: PUSH
42126: FOR_IN
42127: IFFALSE 42151
// if HasTask ( i ) then
42129: LD_VAR 0 7
42133: PPUSH
42134: CALL_OW 314
42138: IFFALSE 42149
// ComStop ( i ) ;
42140: LD_VAR 0 7
42144: PPUSH
42145: CALL_OW 141
42149: GO 42126
42151: POP
42152: POP
// break ;
42153: GO 42390
// end ; for i in solds do
42155: LD_ADDR_VAR 0 7
42159: PUSH
42160: LD_VAR 0 2
42164: PUSH
42165: FOR_IN
42166: IFFALSE 42382
// begin if IsInUnit ( i ) then
42168: LD_VAR 0 7
42172: PPUSH
42173: CALL_OW 310
42177: IFFALSE 42188
// ComExitBuilding ( i ) ;
42179: LD_VAR 0 7
42183: PPUSH
42184: CALL_OW 122
// if GetLives ( i ) > 333 then
42188: LD_VAR 0 7
42192: PPUSH
42193: CALL_OW 256
42197: PUSH
42198: LD_INT 333
42200: GREATER
42201: IFFALSE 42229
// ComAttackUnit ( i , NearestUnitToUnit ( enemy , i ) ) else
42203: LD_VAR 0 7
42207: PPUSH
42208: LD_VAR 0 5
42212: PPUSH
42213: LD_VAR 0 7
42217: PPUSH
42218: CALL_OW 74
42222: PPUSH
42223: CALL_OW 115
42227: GO 42380
// begin hex := NearestUnitToUnit ( UnitFilter ( mc_bases [ base ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] , [ f_btype , b_lab ] ] ) , i ) ;
42229: LD_ADDR_VAR 0 8
42233: PUSH
42234: LD_EXP 56
42238: PUSH
42239: LD_VAR 0 1
42243: ARRAY
42244: PPUSH
42245: LD_INT 2
42247: PUSH
42248: LD_INT 30
42250: PUSH
42251: LD_INT 0
42253: PUSH
42254: EMPTY
42255: LIST
42256: LIST
42257: PUSH
42258: LD_INT 30
42260: PUSH
42261: LD_INT 1
42263: PUSH
42264: EMPTY
42265: LIST
42266: LIST
42267: PUSH
42268: LD_INT 30
42270: PUSH
42271: LD_INT 6
42273: PUSH
42274: EMPTY
42275: LIST
42276: LIST
42277: PUSH
42278: EMPTY
42279: LIST
42280: LIST
42281: LIST
42282: LIST
42283: PPUSH
42284: CALL_OW 72
42288: PPUSH
42289: LD_VAR 0 7
42293: PPUSH
42294: CALL_OW 74
42298: ST_TO_ADDR
// ComMoveXY ( i , ShiftX ( GetX ( hex ) , 3 , 5 ) , ShiftY ( GetY ( hex ) , 3 , 5 ) ) ;
42299: LD_VAR 0 7
42303: PPUSH
42304: LD_VAR 0 8
42308: PPUSH
42309: CALL_OW 250
42313: PPUSH
42314: LD_INT 3
42316: PPUSH
42317: LD_INT 5
42319: PPUSH
42320: CALL_OW 272
42324: PPUSH
42325: LD_VAR 0 8
42329: PPUSH
42330: CALL_OW 251
42334: PPUSH
42335: LD_INT 3
42337: PPUSH
42338: LD_INT 5
42340: PPUSH
42341: CALL_OW 273
42345: PPUSH
42346: CALL_OW 111
// SetTag ( i , 0 ) ;
42350: LD_VAR 0 7
42354: PPUSH
42355: LD_INT 0
42357: PPUSH
42358: CALL_OW 109
// solds := solds diff i ;
42362: LD_ADDR_VAR 0 2
42366: PUSH
42367: LD_VAR 0 2
42371: PUSH
42372: LD_VAR 0 7
42376: DIFF
42377: ST_TO_ADDR
// continue ;
42378: GO 42165
// end ; end ;
42380: GO 42165
42382: POP
42383: POP
// until solds ;
42384: LD_VAR 0 2
42388: IFFALSE 42060
// MC_Reset ( base , 18 ) ;
42390: LD_VAR 0 1
42394: PPUSH
42395: LD_INT 18
42397: PPUSH
42398: CALL 14620 0 2
// end ;
42402: LD_VAR 0 4
42406: RET
// export function Defend ( base , defenders , enemy ) ; var i , j , x , solds , mech , un , tmp , mechs , e , fac , components , depot_under_attack , sold_defenders , b , can_defend ; begin
42407: LD_INT 0
42409: PPUSH
42410: PPUSH
42411: PPUSH
42412: PPUSH
42413: PPUSH
42414: PPUSH
42415: PPUSH
42416: PPUSH
42417: PPUSH
42418: PPUSH
42419: PPUSH
42420: PPUSH
42421: PPUSH
42422: PPUSH
42423: PPUSH
42424: PPUSH
// mechs := UnitFilter ( mc_bases [ base ] , [ f_class , 3 ] ) ;
42425: LD_ADDR_VAR 0 12
42429: PUSH
42430: LD_EXP 56
42434: PUSH
42435: LD_VAR 0 1
42439: ARRAY
42440: PPUSH
42441: LD_INT 25
42443: PUSH
42444: LD_INT 3
42446: PUSH
42447: EMPTY
42448: LIST
42449: LIST
42450: PPUSH
42451: CALL_OW 72
42455: ST_TO_ADDR
// if mc_remote_driver [ base ] then
42456: LD_EXP 96
42460: PUSH
42461: LD_VAR 0 1
42465: ARRAY
42466: IFFALSE 42490
// mechs := mechs diff mc_remote_driver [ base ] ;
42468: LD_ADDR_VAR 0 12
42472: PUSH
42473: LD_VAR 0 12
42477: PUSH
42478: LD_EXP 96
42482: PUSH
42483: LD_VAR 0 1
42487: ARRAY
42488: DIFF
42489: ST_TO_ADDR
// solds := UnitFilter ( mc_bases [ base ] , [ f_or , [ f_class , 1 ] , [ f_class , 5 ] , [ f_class , 8 ] , [ f_class , 9 ] ] ) ;
42490: LD_ADDR_VAR 0 8
42494: PUSH
42495: LD_EXP 56
42499: PUSH
42500: LD_VAR 0 1
42504: ARRAY
42505: PPUSH
42506: LD_INT 2
42508: PUSH
42509: LD_INT 25
42511: PUSH
42512: LD_INT 1
42514: PUSH
42515: EMPTY
42516: LIST
42517: LIST
42518: PUSH
42519: LD_INT 25
42521: PUSH
42522: LD_INT 5
42524: PUSH
42525: EMPTY
42526: LIST
42527: LIST
42528: PUSH
42529: LD_INT 25
42531: PUSH
42532: LD_INT 8
42534: PUSH
42535: EMPTY
42536: LIST
42537: LIST
42538: PUSH
42539: LD_INT 25
42541: PUSH
42542: LD_INT 9
42544: PUSH
42545: EMPTY
42546: LIST
42547: LIST
42548: PUSH
42549: EMPTY
42550: LIST
42551: LIST
42552: LIST
42553: LIST
42554: LIST
42555: PPUSH
42556: CALL_OW 72
42560: ST_TO_ADDR
// if not defenders and not solds then
42561: LD_VAR 0 2
42565: NOT
42566: PUSH
42567: LD_VAR 0 8
42571: NOT
42572: AND
42573: IFFALSE 42577
// exit ;
42575: GO 43951
// depot_under_attack := false ;
42577: LD_ADDR_VAR 0 16
42581: PUSH
42582: LD_INT 0
42584: ST_TO_ADDR
// sold_defenders := [ ] ;
42585: LD_ADDR_VAR 0 17
42589: PUSH
42590: EMPTY
42591: ST_TO_ADDR
// if mechs then
42592: LD_VAR 0 12
42596: IFFALSE 42725
// for i in defenders do
42598: LD_ADDR_VAR 0 5
42602: PUSH
42603: LD_VAR 0 2
42607: PUSH
42608: FOR_IN
42609: IFFALSE 42723
// begin SetTag ( i , 20 ) ;
42611: LD_VAR 0 5
42615: PPUSH
42616: LD_INT 20
42618: PPUSH
42619: CALL_OW 109
// if GetControl ( i ) = control_manual and not IsDrivenBy ( i ) and mechs then
42623: LD_VAR 0 5
42627: PPUSH
42628: CALL_OW 263
42632: PUSH
42633: LD_INT 1
42635: EQUAL
42636: PUSH
42637: LD_VAR 0 5
42641: PPUSH
42642: CALL_OW 311
42646: NOT
42647: AND
42648: PUSH
42649: LD_VAR 0 12
42653: AND
42654: IFFALSE 42721
// begin un := mechs [ 1 ] ;
42656: LD_ADDR_VAR 0 10
42660: PUSH
42661: LD_VAR 0 12
42665: PUSH
42666: LD_INT 1
42668: ARRAY
42669: ST_TO_ADDR
// ComExitBuilding ( un ) ;
42670: LD_VAR 0 10
42674: PPUSH
42675: CALL_OW 122
// AddComEnterUnit ( un , i ) ;
42679: LD_VAR 0 10
42683: PPUSH
42684: LD_VAR 0 5
42688: PPUSH
42689: CALL_OW 180
// SetTag ( un , 19 ) ;
42693: LD_VAR 0 10
42697: PPUSH
42698: LD_INT 19
42700: PPUSH
42701: CALL_OW 109
// mechs := mechs diff un ;
42705: LD_ADDR_VAR 0 12
42709: PUSH
42710: LD_VAR 0 12
42714: PUSH
42715: LD_VAR 0 10
42719: DIFF
42720: ST_TO_ADDR
// end ; end ;
42721: GO 42608
42723: POP
42724: POP
// if solds then
42725: LD_VAR 0 8
42729: IFFALSE 42788
// for i in solds do
42731: LD_ADDR_VAR 0 5
42735: PUSH
42736: LD_VAR 0 8
42740: PUSH
42741: FOR_IN
42742: IFFALSE 42786
// if not GetTag ( i ) then
42744: LD_VAR 0 5
42748: PPUSH
42749: CALL_OW 110
42753: NOT
42754: IFFALSE 42784
// begin defenders := defenders union i ;
42756: LD_ADDR_VAR 0 2
42760: PUSH
42761: LD_VAR 0 2
42765: PUSH
42766: LD_VAR 0 5
42770: UNION
42771: ST_TO_ADDR
// SetTag ( i , 18 ) ;
42772: LD_VAR 0 5
42776: PPUSH
42777: LD_INT 18
42779: PPUSH
42780: CALL_OW 109
// end ;
42784: GO 42741
42786: POP
42787: POP
// repeat wait ( 0 0$1 ) ;
42788: LD_INT 35
42790: PPUSH
42791: CALL_OW 67
// enemy := mc_scan [ base ] ;
42795: LD_ADDR_VAR 0 3
42799: PUSH
42800: LD_EXP 79
42804: PUSH
42805: LD_VAR 0 1
42809: ARRAY
42810: ST_TO_ADDR
// for i in defenders do
42811: LD_ADDR_VAR 0 5
42815: PUSH
42816: LD_VAR 0 2
42820: PUSH
42821: FOR_IN
42822: IFFALSE 43552
// begin e := NearestUnitToUnit ( enemy , i ) ;
42824: LD_ADDR_VAR 0 13
42828: PUSH
42829: LD_VAR 0 3
42833: PPUSH
42834: LD_VAR 0 5
42838: PPUSH
42839: CALL_OW 74
42843: ST_TO_ADDR
// depot_under_attack := ( not UnitFilter ( mc_bases [ base ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) or GetLives ( UnitFilter ( mc_bases [ base ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) ) < 600 ) ;
42844: LD_ADDR_VAR 0 16
42848: PUSH
42849: LD_EXP 56
42853: PUSH
42854: LD_VAR 0 1
42858: ARRAY
42859: PPUSH
42860: LD_INT 2
42862: PUSH
42863: LD_INT 30
42865: PUSH
42866: LD_INT 0
42868: PUSH
42869: EMPTY
42870: LIST
42871: LIST
42872: PUSH
42873: LD_INT 30
42875: PUSH
42876: LD_INT 1
42878: PUSH
42879: EMPTY
42880: LIST
42881: LIST
42882: PUSH
42883: EMPTY
42884: LIST
42885: LIST
42886: LIST
42887: PPUSH
42888: CALL_OW 72
42892: NOT
42893: PUSH
42894: LD_EXP 56
42898: PUSH
42899: LD_VAR 0 1
42903: ARRAY
42904: PPUSH
42905: LD_INT 2
42907: PUSH
42908: LD_INT 30
42910: PUSH
42911: LD_INT 0
42913: PUSH
42914: EMPTY
42915: LIST
42916: LIST
42917: PUSH
42918: LD_INT 30
42920: PUSH
42921: LD_INT 1
42923: PUSH
42924: EMPTY
42925: LIST
42926: LIST
42927: PUSH
42928: EMPTY
42929: LIST
42930: LIST
42931: LIST
42932: PPUSH
42933: CALL_OW 72
42937: PPUSH
42938: CALL_OW 256
42942: PUSH
42943: LD_INT 600
42945: LESS
42946: OR
42947: ST_TO_ADDR
// case GetType ( i ) of unit_vehicle :
42948: LD_VAR 0 5
42952: PPUSH
42953: CALL_OW 247
42957: PUSH
42958: LD_INT 2
42960: DOUBLE
42961: EQUAL
42962: IFTRUE 42966
42964: GO 43258
42966: POP
// begin if GetLives ( i ) > 650 and ( GetDistUnits ( i , e ) < 40 or IsInArea ( e , mc_scan_area [ base ] ) ) then
42967: LD_VAR 0 5
42971: PPUSH
42972: CALL_OW 256
42976: PUSH
42977: LD_INT 650
42979: GREATER
42980: PUSH
42981: LD_VAR 0 5
42985: PPUSH
42986: LD_VAR 0 13
42990: PPUSH
42991: CALL_OW 296
42995: PUSH
42996: LD_INT 40
42998: LESS
42999: PUSH
43000: LD_VAR 0 13
43004: PPUSH
43005: LD_EXP 81
43009: PUSH
43010: LD_VAR 0 1
43014: ARRAY
43015: PPUSH
43016: CALL_OW 308
43020: OR
43021: AND
43022: IFFALSE 43040
// ComAttackUnit ( i , e ) else
43024: LD_VAR 0 5
43028: PPUSH
43029: LD_VAR 0 13
43033: PPUSH
43034: CALL_OW 115
43038: GO 43141
// if ( ( not IsInArea ( e , mc_scan_area [ base ] ) and GetDistUnits ( i , e ) >= 40 ) or GetLives ( i ) <= 650 ) and not IsInArea ( i , mc_parking [ base ] ) then
43040: LD_VAR 0 13
43044: PPUSH
43045: LD_EXP 81
43049: PUSH
43050: LD_VAR 0 1
43054: ARRAY
43055: PPUSH
43056: CALL_OW 308
43060: NOT
43061: PUSH
43062: LD_VAR 0 5
43066: PPUSH
43067: LD_VAR 0 13
43071: PPUSH
43072: CALL_OW 296
43076: PUSH
43077: LD_INT 40
43079: GREATEREQUAL
43080: AND
43081: PUSH
43082: LD_VAR 0 5
43086: PPUSH
43087: CALL_OW 256
43091: PUSH
43092: LD_INT 650
43094: LESSEQUAL
43095: OR
43096: PUSH
43097: LD_VAR 0 5
43101: PPUSH
43102: LD_EXP 80
43106: PUSH
43107: LD_VAR 0 1
43111: ARRAY
43112: PPUSH
43113: CALL_OW 308
43117: NOT
43118: AND
43119: IFFALSE 43141
// ComMoveToArea ( i , mc_parking [ base ] ) ;
43121: LD_VAR 0 5
43125: PPUSH
43126: LD_EXP 80
43130: PUSH
43131: LD_VAR 0 1
43135: ARRAY
43136: PPUSH
43137: CALL_OW 113
// if GetLives ( i ) < 998 and GetControl ( i ) = control_manual and IsDrivenBy ( i ) and IsInArea ( i , mc_parking [ base ] ) then
43141: LD_VAR 0 5
43145: PPUSH
43146: CALL_OW 256
43150: PUSH
43151: LD_INT 998
43153: LESS
43154: PUSH
43155: LD_VAR 0 5
43159: PPUSH
43160: CALL_OW 263
43164: PUSH
43165: LD_INT 1
43167: EQUAL
43168: AND
43169: PUSH
43170: LD_VAR 0 5
43174: PPUSH
43175: CALL_OW 311
43179: AND
43180: PUSH
43181: LD_VAR 0 5
43185: PPUSH
43186: LD_EXP 80
43190: PUSH
43191: LD_VAR 0 1
43195: ARRAY
43196: PPUSH
43197: CALL_OW 308
43201: AND
43202: IFFALSE 43256
// begin mech := IsDrivenBy ( i ) ;
43204: LD_ADDR_VAR 0 9
43208: PUSH
43209: LD_VAR 0 5
43213: PPUSH
43214: CALL_OW 311
43218: ST_TO_ADDR
// ComExitVehicle ( mech ) ;
43219: LD_VAR 0 9
43223: PPUSH
43224: CALL_OW 121
// AddComRepairVehicle ( mech , i ) ;
43228: LD_VAR 0 9
43232: PPUSH
43233: LD_VAR 0 5
43237: PPUSH
43238: CALL_OW 189
// AddComEnterUnit ( mech , i ) ;
43242: LD_VAR 0 9
43246: PPUSH
43247: LD_VAR 0 5
43251: PPUSH
43252: CALL_OW 180
// end ; end ; unit_human :
43256: GO 43523
43258: LD_INT 1
43260: DOUBLE
43261: EQUAL
43262: IFTRUE 43266
43264: GO 43522
43266: POP
// begin b := IsInUnit ( i ) ;
43267: LD_ADDR_VAR 0 18
43271: PUSH
43272: LD_VAR 0 5
43276: PPUSH
43277: CALL_OW 310
43281: ST_TO_ADDR
// can_defend := ( not b or GetBType ( b ) in [ b_bunker , b_breastwork ] ) ;
43282: LD_ADDR_VAR 0 19
43286: PUSH
43287: LD_VAR 0 18
43291: NOT
43292: PUSH
43293: LD_VAR 0 18
43297: PPUSH
43298: CALL_OW 266
43302: PUSH
43303: LD_INT 32
43305: PUSH
43306: LD_INT 31
43308: PUSH
43309: EMPTY
43310: LIST
43311: LIST
43312: IN
43313: OR
43314: ST_TO_ADDR
// if ( depot_under_attack or UnitFilter ( defenders , [ f_type , unit_vehicle ] ) <= 1 ) and can_defend and not i in sold_defenders then
43315: LD_VAR 0 16
43319: PUSH
43320: LD_VAR 0 2
43324: PPUSH
43325: LD_INT 21
43327: PUSH
43328: LD_INT 2
43330: PUSH
43331: EMPTY
43332: LIST
43333: LIST
43334: PPUSH
43335: CALL_OW 72
43339: PUSH
43340: LD_INT 1
43342: LESSEQUAL
43343: OR
43344: PUSH
43345: LD_VAR 0 19
43349: AND
43350: PUSH
43351: LD_VAR 0 5
43355: PUSH
43356: LD_VAR 0 17
43360: IN
43361: NOT
43362: AND
43363: IFFALSE 43456
// begin if b then
43365: LD_VAR 0 18
43369: IFFALSE 43418
// if GetDistUnits ( b , NearestUnitToUnit ( enemy , b ) ) < 10 and BuildingStatus ( b ) <> bs_need_power then
43371: LD_VAR 0 18
43375: PPUSH
43376: LD_VAR 0 3
43380: PPUSH
43381: LD_VAR 0 18
43385: PPUSH
43386: CALL_OW 74
43390: PPUSH
43391: CALL_OW 296
43395: PUSH
43396: LD_INT 10
43398: LESS
43399: PUSH
43400: LD_VAR 0 18
43404: PPUSH
43405: CALL_OW 461
43409: PUSH
43410: LD_INT 7
43412: NONEQUAL
43413: AND
43414: IFFALSE 43418
// continue ;
43416: GO 42821
// sold_defenders := Replace ( sold_defenders , sold_defenders + 1 , i ) ;
43418: LD_ADDR_VAR 0 17
43422: PUSH
43423: LD_VAR 0 17
43427: PPUSH
43428: LD_VAR 0 17
43432: PUSH
43433: LD_INT 1
43435: PLUS
43436: PPUSH
43437: LD_VAR 0 5
43441: PPUSH
43442: CALL_OW 1
43446: ST_TO_ADDR
// ComExitBuilding ( i ) ;
43447: LD_VAR 0 5
43451: PPUSH
43452: CALL_OW 122
// end ; if sold_defenders then
43456: LD_VAR 0 17
43460: IFFALSE 43520
// if i in sold_defenders then
43462: LD_VAR 0 5
43466: PUSH
43467: LD_VAR 0 17
43471: IN
43472: IFFALSE 43520
// begin if not HasTask ( i ) and GetDistUnits ( i , e ) < 30 then
43474: LD_VAR 0 5
43478: PPUSH
43479: CALL_OW 314
43483: NOT
43484: PUSH
43485: LD_VAR 0 5
43489: PPUSH
43490: LD_VAR 0 13
43494: PPUSH
43495: CALL_OW 296
43499: PUSH
43500: LD_INT 30
43502: LESS
43503: AND
43504: IFFALSE 43520
// ComAttackUnit ( i , e ) ;
43506: LD_VAR 0 5
43510: PPUSH
43511: LD_VAR 0 13
43515: PPUSH
43516: CALL_OW 115
// end ; end ; end ;
43520: GO 43523
43522: POP
// if IsDead ( i ) then
43523: LD_VAR 0 5
43527: PPUSH
43528: CALL_OW 301
43532: IFFALSE 43550
// defenders := defenders diff i ;
43534: LD_ADDR_VAR 0 2
43538: PUSH
43539: LD_VAR 0 2
43543: PUSH
43544: LD_VAR 0 5
43548: DIFF
43549: ST_TO_ADDR
// end ;
43550: GO 42821
43552: POP
43553: POP
// until not enemy or not defenders ;
43554: LD_VAR 0 3
43558: NOT
43559: PUSH
43560: LD_VAR 0 2
43564: NOT
43565: OR
43566: IFFALSE 42788
// MC_Reset ( base , 18 ) ;
43568: LD_VAR 0 1
43572: PPUSH
43573: LD_INT 18
43575: PPUSH
43576: CALL 14620 0 2
// defenders := defenders diff UnitFilter ( defenders , [ f_or , [ f_class , 1 ] , [ f_class , 5 ] , [ f_class , 8 ] , [ f_class , 9 ] ] ) ;
43580: LD_ADDR_VAR 0 2
43584: PUSH
43585: LD_VAR 0 2
43589: PUSH
43590: LD_VAR 0 2
43594: PPUSH
43595: LD_INT 2
43597: PUSH
43598: LD_INT 25
43600: PUSH
43601: LD_INT 1
43603: PUSH
43604: EMPTY
43605: LIST
43606: LIST
43607: PUSH
43608: LD_INT 25
43610: PUSH
43611: LD_INT 5
43613: PUSH
43614: EMPTY
43615: LIST
43616: LIST
43617: PUSH
43618: LD_INT 25
43620: PUSH
43621: LD_INT 8
43623: PUSH
43624: EMPTY
43625: LIST
43626: LIST
43627: PUSH
43628: LD_INT 25
43630: PUSH
43631: LD_INT 9
43633: PUSH
43634: EMPTY
43635: LIST
43636: LIST
43637: PUSH
43638: EMPTY
43639: LIST
43640: LIST
43641: LIST
43642: LIST
43643: LIST
43644: PPUSH
43645: CALL_OW 72
43649: DIFF
43650: ST_TO_ADDR
// if not enemy and UnitFilter ( defenders , [ f_type , unit_vehicle ] ) then
43651: LD_VAR 0 3
43655: NOT
43656: PUSH
43657: LD_VAR 0 2
43661: PPUSH
43662: LD_INT 21
43664: PUSH
43665: LD_INT 2
43667: PUSH
43668: EMPTY
43669: LIST
43670: LIST
43671: PPUSH
43672: CALL_OW 72
43676: AND
43677: IFFALSE 43939
// begin tmp := FilterByTag ( defenders , 19 ) ;
43679: LD_ADDR_VAR 0 11
43683: PUSH
43684: LD_VAR 0 2
43688: PPUSH
43689: LD_INT 19
43691: PPUSH
43692: CALL 80380 0 2
43696: ST_TO_ADDR
// if tmp then
43697: LD_VAR 0 11
43701: IFFALSE 43771
// begin tmp := UnitFilter ( tmp , [ f_class , 3 ] ) ;
43703: LD_ADDR_VAR 0 11
43707: PUSH
43708: LD_VAR 0 11
43712: PPUSH
43713: LD_INT 25
43715: PUSH
43716: LD_INT 3
43718: PUSH
43719: EMPTY
43720: LIST
43721: LIST
43722: PPUSH
43723: CALL_OW 72
43727: ST_TO_ADDR
// if tmp then
43728: LD_VAR 0 11
43732: IFFALSE 43771
// mc_repair_vehicle := Replace ( mc_repair_vehicle , base , mc_repair_vehicle [ base ] union tmp ) ;
43734: LD_ADDR_EXP 68
43738: PUSH
43739: LD_EXP 68
43743: PPUSH
43744: LD_VAR 0 1
43748: PPUSH
43749: LD_EXP 68
43753: PUSH
43754: LD_VAR 0 1
43758: ARRAY
43759: PUSH
43760: LD_VAR 0 11
43764: UNION
43765: PPUSH
43766: CALL_OW 1
43770: ST_TO_ADDR
// end ; MC_Reset ( base , 19 ) ;
43771: LD_VAR 0 1
43775: PPUSH
43776: LD_INT 19
43778: PPUSH
43779: CALL 14620 0 2
// repeat wait ( 0 0$1 ) ;
43783: LD_INT 35
43785: PPUSH
43786: CALL_OW 67
// for i in defenders do
43790: LD_ADDR_VAR 0 5
43794: PUSH
43795: LD_VAR 0 2
43799: PUSH
43800: FOR_IN
43801: IFFALSE 43890
// begin if not IsInArea ( i , mc_parking [ base ] ) then
43803: LD_VAR 0 5
43807: PPUSH
43808: LD_EXP 80
43812: PUSH
43813: LD_VAR 0 1
43817: ARRAY
43818: PPUSH
43819: CALL_OW 308
43823: NOT
43824: IFFALSE 43848
// ComMoveToArea ( i , mc_parking [ base ] ) else
43826: LD_VAR 0 5
43830: PPUSH
43831: LD_EXP 80
43835: PUSH
43836: LD_VAR 0 1
43840: ARRAY
43841: PPUSH
43842: CALL_OW 113
43846: GO 43888
// if GetControl ( i ) = control_manual then
43848: LD_VAR 0 5
43852: PPUSH
43853: CALL_OW 263
43857: PUSH
43858: LD_INT 1
43860: EQUAL
43861: IFFALSE 43888
// if IsDrivenBy ( i ) then
43863: LD_VAR 0 5
43867: PPUSH
43868: CALL_OW 311
43872: IFFALSE 43888
// ComExitVehicle ( IsDrivenBy ( i ) ) ;
43874: LD_VAR 0 5
43878: PPUSH
43879: CALL_OW 311
43883: PPUSH
43884: CALL_OW 121
// end ;
43888: GO 43800
43890: POP
43891: POP
// until UnitFilter ( defenders , [ f_inarea , mc_parking [ base ] ] ) = defenders or mc_scan [ base ] ;
43892: LD_VAR 0 2
43896: PPUSH
43897: LD_INT 95
43899: PUSH
43900: LD_EXP 80
43904: PUSH
43905: LD_VAR 0 1
43909: ARRAY
43910: PUSH
43911: EMPTY
43912: LIST
43913: LIST
43914: PPUSH
43915: CALL_OW 72
43919: PUSH
43920: LD_VAR 0 2
43924: EQUAL
43925: PUSH
43926: LD_EXP 79
43930: PUSH
43931: LD_VAR 0 1
43935: ARRAY
43936: OR
43937: IFFALSE 43783
// end ; MC_Reset ( base , 20 ) ;
43939: LD_VAR 0 1
43943: PPUSH
43944: LD_INT 20
43946: PPUSH
43947: CALL 14620 0 2
// end ;
43951: LD_VAR 0 4
43955: RET
// export function AllowSpecClass ( unit ) ; var side , nat , tech ; begin
43956: LD_INT 0
43958: PPUSH
43959: PPUSH
43960: PPUSH
43961: PPUSH
// result := false ;
43962: LD_ADDR_VAR 0 2
43966: PUSH
43967: LD_INT 0
43969: ST_TO_ADDR
// side := GetSide ( unit ) ;
43970: LD_ADDR_VAR 0 3
43974: PUSH
43975: LD_VAR 0 1
43979: PPUSH
43980: CALL_OW 255
43984: ST_TO_ADDR
// nat := GetNation ( unit ) ;
43985: LD_ADDR_VAR 0 4
43989: PUSH
43990: LD_VAR 0 1
43994: PPUSH
43995: CALL_OW 248
43999: ST_TO_ADDR
// case nat of 1 :
44000: LD_VAR 0 4
44004: PUSH
44005: LD_INT 1
44007: DOUBLE
44008: EQUAL
44009: IFTRUE 44013
44011: GO 44024
44013: POP
// tech := tech_lassight ; 2 :
44014: LD_ADDR_VAR 0 5
44018: PUSH
44019: LD_INT 12
44021: ST_TO_ADDR
44022: GO 44063
44024: LD_INT 2
44026: DOUBLE
44027: EQUAL
44028: IFTRUE 44032
44030: GO 44043
44032: POP
// tech := tech_mortar ; 3 :
44033: LD_ADDR_VAR 0 5
44037: PUSH
44038: LD_INT 41
44040: ST_TO_ADDR
44041: GO 44063
44043: LD_INT 3
44045: DOUBLE
44046: EQUAL
44047: IFTRUE 44051
44049: GO 44062
44051: POP
// tech := tech_bazooka ; end ;
44052: LD_ADDR_VAR 0 5
44056: PUSH
44057: LD_INT 44
44059: ST_TO_ADDR
44060: GO 44063
44062: POP
// if Researched ( side , tech ) then
44063: LD_VAR 0 3
44067: PPUSH
44068: LD_VAR 0 5
44072: PPUSH
44073: CALL_OW 325
44077: IFFALSE 44104
// result := [ class_sniper , class_mortar , class_bazooker ] [ nat ] ;
44079: LD_ADDR_VAR 0 2
44083: PUSH
44084: LD_INT 5
44086: PUSH
44087: LD_INT 8
44089: PUSH
44090: LD_INT 9
44092: PUSH
44093: EMPTY
44094: LIST
44095: LIST
44096: LIST
44097: PUSH
44098: LD_VAR 0 4
44102: ARRAY
44103: ST_TO_ADDR
// end ;
44104: LD_VAR 0 2
44108: RET
// export function DetonateMines ( side , mines ) ; var i , tmp ; begin
44109: LD_INT 0
44111: PPUSH
44112: PPUSH
44113: PPUSH
// if not mines then
44114: LD_VAR 0 2
44118: NOT
44119: IFFALSE 44123
// exit ;
44121: GO 44267
// tmp := FilterAllUnits ( [ [ f_enemy , side ] , [ f_not , [ f_type , unit_building ] ] ] ) ;
44123: LD_ADDR_VAR 0 5
44127: PUSH
44128: LD_INT 81
44130: PUSH
44131: LD_VAR 0 1
44135: PUSH
44136: EMPTY
44137: LIST
44138: LIST
44139: PUSH
44140: LD_INT 3
44142: PUSH
44143: LD_INT 21
44145: PUSH
44146: LD_INT 3
44148: PUSH
44149: EMPTY
44150: LIST
44151: LIST
44152: PUSH
44153: EMPTY
44154: LIST
44155: LIST
44156: PUSH
44157: EMPTY
44158: LIST
44159: LIST
44160: PPUSH
44161: CALL_OW 69
44165: ST_TO_ADDR
// for i in mines do
44166: LD_ADDR_VAR 0 4
44170: PUSH
44171: LD_VAR 0 2
44175: PUSH
44176: FOR_IN
44177: IFFALSE 44265
// begin if not MineAtPos ( i [ 1 ] , i [ 2 ] ) then
44179: LD_VAR 0 4
44183: PUSH
44184: LD_INT 1
44186: ARRAY
44187: PPUSH
44188: LD_VAR 0 4
44192: PUSH
44193: LD_INT 2
44195: ARRAY
44196: PPUSH
44197: CALL_OW 458
44201: NOT
44202: IFFALSE 44206
// continue ;
44204: GO 44176
// if HexInfo ( i [ 1 ] , i [ 2 ] ) in tmp then
44206: LD_VAR 0 4
44210: PUSH
44211: LD_INT 1
44213: ARRAY
44214: PPUSH
44215: LD_VAR 0 4
44219: PUSH
44220: LD_INT 2
44222: ARRAY
44223: PPUSH
44224: CALL_OW 428
44228: PUSH
44229: LD_VAR 0 5
44233: IN
44234: IFFALSE 44263
// LaunchMineAtPos ( i [ 1 ] , i [ 2 ] , side ) ;
44236: LD_VAR 0 4
44240: PUSH
44241: LD_INT 1
44243: ARRAY
44244: PPUSH
44245: LD_VAR 0 4
44249: PUSH
44250: LD_INT 2
44252: ARRAY
44253: PPUSH
44254: LD_VAR 0 1
44258: PPUSH
44259: CALL_OW 456
// end ;
44263: GO 44176
44265: POP
44266: POP
// end ;
44267: LD_VAR 0 3
44271: RET
// export function Count ( array ) ; var i ; begin
44272: LD_INT 0
44274: PPUSH
44275: PPUSH
// result := 0 ;
44276: LD_ADDR_VAR 0 2
44280: PUSH
44281: LD_INT 0
44283: ST_TO_ADDR
// for i in array do
44284: LD_ADDR_VAR 0 3
44288: PUSH
44289: LD_VAR 0 1
44293: PUSH
44294: FOR_IN
44295: IFFALSE 44319
// if i then
44297: LD_VAR 0 3
44301: IFFALSE 44317
// result := result + 1 ;
44303: LD_ADDR_VAR 0 2
44307: PUSH
44308: LD_VAR 0 2
44312: PUSH
44313: LD_INT 1
44315: PLUS
44316: ST_TO_ADDR
44317: GO 44294
44319: POP
44320: POP
// end ;
44321: LD_VAR 0 2
44325: RET
// export function IsEmpty ( building ) ; begin
44326: LD_INT 0
44328: PPUSH
// if not building then
44329: LD_VAR 0 1
44333: NOT
44334: IFFALSE 44338
// exit ;
44336: GO 44381
// result := building in FilterAllUnits ( [ [ f_side , GetSide ( building ) ] , [ f_empty ] ] ) ;
44338: LD_ADDR_VAR 0 2
44342: PUSH
44343: LD_VAR 0 1
44347: PUSH
44348: LD_INT 22
44350: PUSH
44351: LD_VAR 0 1
44355: PPUSH
44356: CALL_OW 255
44360: PUSH
44361: EMPTY
44362: LIST
44363: LIST
44364: PUSH
44365: LD_INT 58
44367: PUSH
44368: EMPTY
44369: LIST
44370: PUSH
44371: EMPTY
44372: LIST
44373: LIST
44374: PPUSH
44375: CALL_OW 69
44379: IN
44380: ST_TO_ADDR
// end ;
44381: LD_VAR 0 2
44385: RET
// export function IsNotFull ( building ) ; begin
44386: LD_INT 0
44388: PPUSH
// if not building then
44389: LD_VAR 0 1
44393: NOT
44394: IFFALSE 44398
// exit ;
44396: GO 44417
// result := UnitsInside ( building ) < 6 ;
44398: LD_ADDR_VAR 0 2
44402: PUSH
44403: LD_VAR 0 1
44407: PPUSH
44408: CALL_OW 313
44412: PUSH
44413: LD_INT 6
44415: LESS
44416: ST_TO_ADDR
// end ;
44417: LD_VAR 0 2
44421: RET
// export function GetFacExt ( factory ) ; var tmp , i , list ; begin
44422: LD_INT 0
44424: PPUSH
44425: PPUSH
44426: PPUSH
44427: PPUSH
// tmp := [ ] ;
44428: LD_ADDR_VAR 0 3
44432: PUSH
44433: EMPTY
44434: ST_TO_ADDR
// list := [ ] ;
44435: LD_ADDR_VAR 0 5
44439: PUSH
44440: EMPTY
44441: ST_TO_ADDR
// for i = 16 to 25 do
44442: LD_ADDR_VAR 0 4
44446: PUSH
44447: DOUBLE
44448: LD_INT 16
44450: DEC
44451: ST_TO_ADDR
44452: LD_INT 25
44454: PUSH
44455: FOR_TO
44456: IFFALSE 44529
// tmp := tmp ^ FilterAllUnits ( [ [ [ f_side , GetSide ( factory ) ] , [ f_dist , factory , 6 ] , [ f_btype , i ] ] ] ) ;
44458: LD_ADDR_VAR 0 3
44462: PUSH
44463: LD_VAR 0 3
44467: PUSH
44468: LD_INT 22
44470: PUSH
44471: LD_VAR 0 1
44475: PPUSH
44476: CALL_OW 255
44480: PUSH
44481: EMPTY
44482: LIST
44483: LIST
44484: PUSH
44485: LD_INT 91
44487: PUSH
44488: LD_VAR 0 1
44492: PUSH
44493: LD_INT 6
44495: PUSH
44496: EMPTY
44497: LIST
44498: LIST
44499: LIST
44500: PUSH
44501: LD_INT 30
44503: PUSH
44504: LD_VAR 0 4
44508: PUSH
44509: EMPTY
44510: LIST
44511: LIST
44512: PUSH
44513: EMPTY
44514: LIST
44515: LIST
44516: LIST
44517: PUSH
44518: EMPTY
44519: LIST
44520: PPUSH
44521: CALL_OW 69
44525: ADD
44526: ST_TO_ADDR
44527: GO 44455
44529: POP
44530: POP
// for i = 1 to tmp do
44531: LD_ADDR_VAR 0 4
44535: PUSH
44536: DOUBLE
44537: LD_INT 1
44539: DEC
44540: ST_TO_ADDR
44541: LD_VAR 0 3
44545: PUSH
44546: FOR_TO
44547: IFFALSE 44635
// list := list ^ [ [ GetBType ( tmp [ i ] ) , GetX ( tmp [ i ] ) , GetY ( tmp [ i ] ) , GetDir ( tmp [ i ] ) ] ] ;
44549: LD_ADDR_VAR 0 5
44553: PUSH
44554: LD_VAR 0 5
44558: PUSH
44559: LD_VAR 0 3
44563: PUSH
44564: LD_VAR 0 4
44568: ARRAY
44569: PPUSH
44570: CALL_OW 266
44574: PUSH
44575: LD_VAR 0 3
44579: PUSH
44580: LD_VAR 0 4
44584: ARRAY
44585: PPUSH
44586: CALL_OW 250
44590: PUSH
44591: LD_VAR 0 3
44595: PUSH
44596: LD_VAR 0 4
44600: ARRAY
44601: PPUSH
44602: CALL_OW 251
44606: PUSH
44607: LD_VAR 0 3
44611: PUSH
44612: LD_VAR 0 4
44616: ARRAY
44617: PPUSH
44618: CALL_OW 254
44622: PUSH
44623: EMPTY
44624: LIST
44625: LIST
44626: LIST
44627: LIST
44628: PUSH
44629: EMPTY
44630: LIST
44631: ADD
44632: ST_TO_ADDR
44633: GO 44546
44635: POP
44636: POP
// result := list ;
44637: LD_ADDR_VAR 0 2
44641: PUSH
44642: LD_VAR 0 5
44646: ST_TO_ADDR
// end ;
44647: LD_VAR 0 2
44651: RET
// export function Produce ( factory , chassis , engine , control , weapon ) ; var i , tmp , _chassis , _weapon , _engine , _control ; begin
44652: LD_INT 0
44654: PPUSH
44655: PPUSH
44656: PPUSH
44657: PPUSH
44658: PPUSH
44659: PPUSH
44660: PPUSH
// if not factory then
44661: LD_VAR 0 1
44665: NOT
44666: IFFALSE 44670
// exit ;
44668: GO 45263
// if control = control_apeman then
44670: LD_VAR 0 4
44674: PUSH
44675: LD_INT 5
44677: EQUAL
44678: IFFALSE 44787
// begin tmp := UnitsInside ( factory ) ;
44680: LD_ADDR_VAR 0 8
44684: PUSH
44685: LD_VAR 0 1
44689: PPUSH
44690: CALL_OW 313
44694: ST_TO_ADDR
// if not UnitFilter ( tmp , [ f_class , class_apeman ] ) then
44695: LD_VAR 0 8
44699: PPUSH
44700: LD_INT 25
44702: PUSH
44703: LD_INT 12
44705: PUSH
44706: EMPTY
44707: LIST
44708: LIST
44709: PPUSH
44710: CALL_OW 72
44714: NOT
44715: IFFALSE 44725
// control := control_manual ;
44717: LD_ADDR_VAR 0 4
44721: PUSH
44722: LD_INT 1
44724: ST_TO_ADDR
// tmp := GetFacExt ( factory ) ;
44725: LD_ADDR_VAR 0 8
44729: PUSH
44730: LD_VAR 0 1
44734: PPUSH
44735: CALL 44422 0 1
44739: ST_TO_ADDR
// if tmp then
44740: LD_VAR 0 8
44744: IFFALSE 44787
// begin for i in tmp do
44746: LD_ADDR_VAR 0 7
44750: PUSH
44751: LD_VAR 0 8
44755: PUSH
44756: FOR_IN
44757: IFFALSE 44785
// if i [ 1 ] = b_ext_radio then
44759: LD_VAR 0 7
44763: PUSH
44764: LD_INT 1
44766: ARRAY
44767: PUSH
44768: LD_INT 22
44770: EQUAL
44771: IFFALSE 44783
// begin control := control_remote ;
44773: LD_ADDR_VAR 0 4
44777: PUSH
44778: LD_INT 2
44780: ST_TO_ADDR
// break ;
44781: GO 44785
// end ;
44783: GO 44756
44785: POP
44786: POP
// end ; end ; if CanBeConstructed ( factory , chassis , engine , control , weapon ) then
44787: LD_VAR 0 1
44791: PPUSH
44792: LD_VAR 0 2
44796: PPUSH
44797: LD_VAR 0 3
44801: PPUSH
44802: LD_VAR 0 4
44806: PPUSH
44807: LD_VAR 0 5
44811: PPUSH
44812: CALL_OW 448
44816: IFFALSE 44851
// begin result := [ chassis , engine , control , weapon ] ;
44818: LD_ADDR_VAR 0 6
44822: PUSH
44823: LD_VAR 0 2
44827: PUSH
44828: LD_VAR 0 3
44832: PUSH
44833: LD_VAR 0 4
44837: PUSH
44838: LD_VAR 0 5
44842: PUSH
44843: EMPTY
44844: LIST
44845: LIST
44846: LIST
44847: LIST
44848: ST_TO_ADDR
// exit ;
44849: GO 45263
// end ; _chassis := AvailableChassisList ( factory ) ;
44851: LD_ADDR_VAR 0 9
44855: PUSH
44856: LD_VAR 0 1
44860: PPUSH
44861: CALL_OW 475
44865: ST_TO_ADDR
// _engine := AvailableEngineList ( factory ) ;
44866: LD_ADDR_VAR 0 11
44870: PUSH
44871: LD_VAR 0 1
44875: PPUSH
44876: CALL_OW 476
44880: ST_TO_ADDR
// _control := AvailableControlList ( factory ) ;
44881: LD_ADDR_VAR 0 12
44885: PUSH
44886: LD_VAR 0 1
44890: PPUSH
44891: CALL_OW 477
44895: ST_TO_ADDR
// _weapon := AvailableWeaponList ( factory ) ;
44896: LD_ADDR_VAR 0 10
44900: PUSH
44901: LD_VAR 0 1
44905: PPUSH
44906: CALL_OW 478
44910: ST_TO_ADDR
// if not _chassis or not _engine or not _control or not _weapon then
44911: LD_VAR 0 9
44915: NOT
44916: PUSH
44917: LD_VAR 0 11
44921: NOT
44922: OR
44923: PUSH
44924: LD_VAR 0 12
44928: NOT
44929: OR
44930: PUSH
44931: LD_VAR 0 10
44935: NOT
44936: OR
44937: IFFALSE 44972
// begin result := [ chassis , engine , control , weapon ] ;
44939: LD_ADDR_VAR 0 6
44943: PUSH
44944: LD_VAR 0 2
44948: PUSH
44949: LD_VAR 0 3
44953: PUSH
44954: LD_VAR 0 4
44958: PUSH
44959: LD_VAR 0 5
44963: PUSH
44964: EMPTY
44965: LIST
44966: LIST
44967: LIST
44968: LIST
44969: ST_TO_ADDR
// exit ;
44970: GO 45263
// end ; if not chassis in _chassis then
44972: LD_VAR 0 2
44976: PUSH
44977: LD_VAR 0 9
44981: IN
44982: NOT
44983: IFFALSE 45009
// chassis := _chassis [ rand ( 1 , _chassis ) ] ;
44985: LD_ADDR_VAR 0 2
44989: PUSH
44990: LD_VAR 0 9
44994: PUSH
44995: LD_INT 1
44997: PPUSH
44998: LD_VAR 0 9
45002: PPUSH
45003: CALL_OW 12
45007: ARRAY
45008: ST_TO_ADDR
// if not EngineCanBeMount ( chassis , engine ) then
45009: LD_VAR 0 2
45013: PPUSH
45014: LD_VAR 0 3
45018: PPUSH
45019: CALL 45268 0 2
45023: NOT
45024: IFFALSE 45083
// repeat engine := _engine [ 1 ] ;
45026: LD_ADDR_VAR 0 3
45030: PUSH
45031: LD_VAR 0 11
45035: PUSH
45036: LD_INT 1
45038: ARRAY
45039: ST_TO_ADDR
// _engine := Delete ( _engine , 1 ) ;
45040: LD_ADDR_VAR 0 11
45044: PUSH
45045: LD_VAR 0 11
45049: PPUSH
45050: LD_INT 1
45052: PPUSH
45053: CALL_OW 3
45057: ST_TO_ADDR
// until EngineCanBeMount ( chassis , engine ) or _engine = [ ] ;
45058: LD_VAR 0 2
45062: PPUSH
45063: LD_VAR 0 3
45067: PPUSH
45068: CALL 45268 0 2
45072: PUSH
45073: LD_VAR 0 11
45077: PUSH
45078: EMPTY
45079: EQUAL
45080: OR
45081: IFFALSE 45026
// if not control in _control then
45083: LD_VAR 0 4
45087: PUSH
45088: LD_VAR 0 12
45092: IN
45093: NOT
45094: IFFALSE 45120
// control := _control [ rand ( 1 , _control ) ] ;
45096: LD_ADDR_VAR 0 4
45100: PUSH
45101: LD_VAR 0 12
45105: PUSH
45106: LD_INT 1
45108: PPUSH
45109: LD_VAR 0 12
45113: PPUSH
45114: CALL_OW 12
45118: ARRAY
45119: ST_TO_ADDR
// if not WeaponCanBeMount ( chassis , weapon ) then
45120: LD_VAR 0 2
45124: PPUSH
45125: LD_VAR 0 5
45129: PPUSH
45130: CALL 45488 0 2
45134: NOT
45135: IFFALSE 45194
// repeat weapon := _weapon [ 1 ] ;
45137: LD_ADDR_VAR 0 5
45141: PUSH
45142: LD_VAR 0 10
45146: PUSH
45147: LD_INT 1
45149: ARRAY
45150: ST_TO_ADDR
// _weapon := Delete ( _weapon , 1 ) ;
45151: LD_ADDR_VAR 0 10
45155: PUSH
45156: LD_VAR 0 10
45160: PPUSH
45161: LD_INT 1
45163: PPUSH
45164: CALL_OW 3
45168: ST_TO_ADDR
// until WeaponCanBeMount ( chassis , weapon ) or _weapon = [ ] ;
45169: LD_VAR 0 2
45173: PPUSH
45174: LD_VAR 0 5
45178: PPUSH
45179: CALL 45488 0 2
45183: PUSH
45184: LD_VAR 0 10
45188: PUSH
45189: EMPTY
45190: EQUAL
45191: OR
45192: IFFALSE 45137
// result := [ ] ;
45194: LD_ADDR_VAR 0 6
45198: PUSH
45199: EMPTY
45200: ST_TO_ADDR
// if CanBeConstructed ( factory , chassis , engine , control , weapon ) then
45201: LD_VAR 0 1
45205: PPUSH
45206: LD_VAR 0 2
45210: PPUSH
45211: LD_VAR 0 3
45215: PPUSH
45216: LD_VAR 0 4
45220: PPUSH
45221: LD_VAR 0 5
45225: PPUSH
45226: CALL_OW 448
45230: IFFALSE 45263
// result := [ chassis , engine , control , weapon ] ;
45232: LD_ADDR_VAR 0 6
45236: PUSH
45237: LD_VAR 0 2
45241: PUSH
45242: LD_VAR 0 3
45246: PUSH
45247: LD_VAR 0 4
45251: PUSH
45252: LD_VAR 0 5
45256: PUSH
45257: EMPTY
45258: LIST
45259: LIST
45260: LIST
45261: LIST
45262: ST_TO_ADDR
// end ;
45263: LD_VAR 0 6
45267: RET
// export function EngineCanBeMount ( chassis , engine ) ; begin
45268: LD_INT 0
45270: PPUSH
// if not chassis or not engine then
45271: LD_VAR 0 1
45275: NOT
45276: PUSH
45277: LD_VAR 0 2
45281: NOT
45282: OR
45283: IFFALSE 45287
// exit ;
45285: GO 45483
// case engine of engine_solar :
45287: LD_VAR 0 2
45291: PUSH
45292: LD_INT 2
45294: DOUBLE
45295: EQUAL
45296: IFTRUE 45300
45298: GO 45338
45300: POP
// result := [ ar_hovercraft , ar_light_trike , ar_medium_trike , ar_half_tracked , us_light_wheeled , us_medium_wheeled , us_medium_tracked ] ; engine_combustion :
45301: LD_ADDR_VAR 0 3
45305: PUSH
45306: LD_INT 11
45308: PUSH
45309: LD_INT 12
45311: PUSH
45312: LD_INT 13
45314: PUSH
45315: LD_INT 14
45317: PUSH
45318: LD_INT 1
45320: PUSH
45321: LD_INT 2
45323: PUSH
45324: LD_INT 3
45326: PUSH
45327: EMPTY
45328: LIST
45329: LIST
45330: LIST
45331: LIST
45332: LIST
45333: LIST
45334: LIST
45335: ST_TO_ADDR
45336: GO 45467
45338: LD_INT 1
45340: DOUBLE
45341: EQUAL
45342: IFTRUE 45346
45344: GO 45408
45346: POP
// result := [ ar_hovercraft , ar_light_trike , ar_medium_trike , ar_half_tracked , us_light_wheeled , us_medium_wheeled , us_medium_tracked , us_heavy_tracked , us_morphling , ru_medium_wheeled , ru_heavy_wheeled , ru_medium_tracked , ru_heavy_tracked ] ; engine_siberite :
45347: LD_ADDR_VAR 0 3
45351: PUSH
45352: LD_INT 11
45354: PUSH
45355: LD_INT 12
45357: PUSH
45358: LD_INT 13
45360: PUSH
45361: LD_INT 14
45363: PUSH
45364: LD_INT 1
45366: PUSH
45367: LD_INT 2
45369: PUSH
45370: LD_INT 3
45372: PUSH
45373: LD_INT 4
45375: PUSH
45376: LD_INT 5
45378: PUSH
45379: LD_INT 21
45381: PUSH
45382: LD_INT 23
45384: PUSH
45385: LD_INT 22
45387: PUSH
45388: LD_INT 24
45390: PUSH
45391: EMPTY
45392: LIST
45393: LIST
45394: LIST
45395: LIST
45396: LIST
45397: LIST
45398: LIST
45399: LIST
45400: LIST
45401: LIST
45402: LIST
45403: LIST
45404: LIST
45405: ST_TO_ADDR
45406: GO 45467
45408: LD_INT 3
45410: DOUBLE
45411: EQUAL
45412: IFTRUE 45416
45414: GO 45466
45416: POP
// result := [ ar_medium_trike , ar_half_tracked , us_medium_wheeled , us_medium_tracked , us_heavy_tracked , us_morphling , ru_medium_wheeled , ru_medium_tracked , ru_heavy_wheeled , ru_heavy_tracked ] ; end ;
45417: LD_ADDR_VAR 0 3
45421: PUSH
45422: LD_INT 13
45424: PUSH
45425: LD_INT 14
45427: PUSH
45428: LD_INT 2
45430: PUSH
45431: LD_INT 3
45433: PUSH
45434: LD_INT 4
45436: PUSH
45437: LD_INT 5
45439: PUSH
45440: LD_INT 21
45442: PUSH
45443: LD_INT 22
45445: PUSH
45446: LD_INT 23
45448: PUSH
45449: LD_INT 24
45451: PUSH
45452: EMPTY
45453: LIST
45454: LIST
45455: LIST
45456: LIST
45457: LIST
45458: LIST
45459: LIST
45460: LIST
45461: LIST
45462: LIST
45463: ST_TO_ADDR
45464: GO 45467
45466: POP
// result := ( chassis in result ) ;
45467: LD_ADDR_VAR 0 3
45471: PUSH
45472: LD_VAR 0 1
45476: PUSH
45477: LD_VAR 0 3
45481: IN
45482: ST_TO_ADDR
// end ;
45483: LD_VAR 0 3
45487: RET
// export function WeaponCanBeMount ( chassis , weapon ) ; begin
45488: LD_INT 0
45490: PPUSH
// if not chassis or not weapon then
45491: LD_VAR 0 1
45495: NOT
45496: PUSH
45497: LD_VAR 0 2
45501: NOT
45502: OR
45503: IFFALSE 45507
// exit ;
45505: GO 46533
// case weapon of us_machine_gun :
45507: LD_VAR 0 2
45511: PUSH
45512: LD_INT 2
45514: DOUBLE
45515: EQUAL
45516: IFTRUE 45520
45518: GO 45550
45520: POP
// result := [ us_light_wheeled , us_medium_wheeled , us_medium_tracked , us_heavy_tracked , us_morphling ] ; us_light_gun :
45521: LD_ADDR_VAR 0 3
45525: PUSH
45526: LD_INT 1
45528: PUSH
45529: LD_INT 2
45531: PUSH
45532: LD_INT 3
45534: PUSH
45535: LD_INT 4
45537: PUSH
45538: LD_INT 5
45540: PUSH
45541: EMPTY
45542: LIST
45543: LIST
45544: LIST
45545: LIST
45546: LIST
45547: ST_TO_ADDR
45548: GO 46517
45550: LD_INT 3
45552: DOUBLE
45553: EQUAL
45554: IFTRUE 45558
45556: GO 45588
45558: POP
// result := [ us_light_wheeled , us_medium_wheeled , us_medium_tracked , us_heavy_tracked , us_morphling ] ; us_radar :
45559: LD_ADDR_VAR 0 3
45563: PUSH
45564: LD_INT 1
45566: PUSH
45567: LD_INT 2
45569: PUSH
45570: LD_INT 3
45572: PUSH
45573: LD_INT 4
45575: PUSH
45576: LD_INT 5
45578: PUSH
45579: EMPTY
45580: LIST
45581: LIST
45582: LIST
45583: LIST
45584: LIST
45585: ST_TO_ADDR
45586: GO 46517
45588: LD_INT 11
45590: DOUBLE
45591: EQUAL
45592: IFTRUE 45596
45594: GO 45626
45596: POP
// result := [ us_light_wheeled , us_medium_wheeled , us_medium_tracked , us_heavy_tracked , us_morphling ] ; us_gatling_gun :
45597: LD_ADDR_VAR 0 3
45601: PUSH
45602: LD_INT 1
45604: PUSH
45605: LD_INT 2
45607: PUSH
45608: LD_INT 3
45610: PUSH
45611: LD_INT 4
45613: PUSH
45614: LD_INT 5
45616: PUSH
45617: EMPTY
45618: LIST
45619: LIST
45620: LIST
45621: LIST
45622: LIST
45623: ST_TO_ADDR
45624: GO 46517
45626: LD_INT 4
45628: DOUBLE
45629: EQUAL
45630: IFTRUE 45634
45632: GO 45660
45634: POP
// result := [ us_medium_wheeled , us_medium_tracked , us_heavy_tracked , us_morphling ] ; us_double_gun :
45635: LD_ADDR_VAR 0 3
45639: PUSH
45640: LD_INT 2
45642: PUSH
45643: LD_INT 3
45645: PUSH
45646: LD_INT 4
45648: PUSH
45649: LD_INT 5
45651: PUSH
45652: EMPTY
45653: LIST
45654: LIST
45655: LIST
45656: LIST
45657: ST_TO_ADDR
45658: GO 46517
45660: LD_INT 5
45662: DOUBLE
45663: EQUAL
45664: IFTRUE 45668
45666: GO 45694
45668: POP
// result := [ us_medium_wheeled , us_medium_tracked , us_heavy_tracked , us_morphling ] ; us_laser :
45669: LD_ADDR_VAR 0 3
45673: PUSH
45674: LD_INT 2
45676: PUSH
45677: LD_INT 3
45679: PUSH
45680: LD_INT 4
45682: PUSH
45683: LD_INT 5
45685: PUSH
45686: EMPTY
45687: LIST
45688: LIST
45689: LIST
45690: LIST
45691: ST_TO_ADDR
45692: GO 46517
45694: LD_INT 9
45696: DOUBLE
45697: EQUAL
45698: IFTRUE 45702
45700: GO 45728
45702: POP
// result := [ us_medium_wheeled , us_medium_tracked , us_heavy_tracked , us_morphling ] ; us_rocket_launcher :
45703: LD_ADDR_VAR 0 3
45707: PUSH
45708: LD_INT 2
45710: PUSH
45711: LD_INT 3
45713: PUSH
45714: LD_INT 4
45716: PUSH
45717: LD_INT 5
45719: PUSH
45720: EMPTY
45721: LIST
45722: LIST
45723: LIST
45724: LIST
45725: ST_TO_ADDR
45726: GO 46517
45728: LD_INT 7
45730: DOUBLE
45731: EQUAL
45732: IFTRUE 45736
45734: GO 45762
45736: POP
// result := [ us_medium_wheeled , us_medium_tracked , us_heavy_tracked , us_morphling ] ; us_cargo_bay :
45737: LD_ADDR_VAR 0 3
45741: PUSH
45742: LD_INT 2
45744: PUSH
45745: LD_INT 3
45747: PUSH
45748: LD_INT 4
45750: PUSH
45751: LD_INT 5
45753: PUSH
45754: EMPTY
45755: LIST
45756: LIST
45757: LIST
45758: LIST
45759: ST_TO_ADDR
45760: GO 46517
45762: LD_INT 12
45764: DOUBLE
45765: EQUAL
45766: IFTRUE 45770
45768: GO 45796
45770: POP
// result := [ us_medium_wheeled , us_medium_tracked , us_heavy_tracked , us_morphling ] ; us_crane :
45771: LD_ADDR_VAR 0 3
45775: PUSH
45776: LD_INT 2
45778: PUSH
45779: LD_INT 3
45781: PUSH
45782: LD_INT 4
45784: PUSH
45785: LD_INT 5
45787: PUSH
45788: EMPTY
45789: LIST
45790: LIST
45791: LIST
45792: LIST
45793: ST_TO_ADDR
45794: GO 46517
45796: LD_INT 13
45798: DOUBLE
45799: EQUAL
45800: IFTRUE 45804
45802: GO 45830
45804: POP
// result := [ us_medium_wheeled , us_medium_tracked , us_heavy_tracked , us_morphling ] ; us_bulldozer :
45805: LD_ADDR_VAR 0 3
45809: PUSH
45810: LD_INT 2
45812: PUSH
45813: LD_INT 3
45815: PUSH
45816: LD_INT 4
45818: PUSH
45819: LD_INT 5
45821: PUSH
45822: EMPTY
45823: LIST
45824: LIST
45825: LIST
45826: LIST
45827: ST_TO_ADDR
45828: GO 46517
45830: LD_INT 14
45832: DOUBLE
45833: EQUAL
45834: IFTRUE 45838
45836: GO 45856
45838: POP
// result := [ us_heavy_tracked , us_morphling ] ; us_heavy_gun :
45839: LD_ADDR_VAR 0 3
45843: PUSH
45844: LD_INT 4
45846: PUSH
45847: LD_INT 5
45849: PUSH
45850: EMPTY
45851: LIST
45852: LIST
45853: ST_TO_ADDR
45854: GO 46517
45856: LD_INT 6
45858: DOUBLE
45859: EQUAL
45860: IFTRUE 45864
45862: GO 45882
45864: POP
// result := [ us_heavy_tracked , us_morphling ] ; us_double_laser :
45865: LD_ADDR_VAR 0 3
45869: PUSH
45870: LD_INT 4
45872: PUSH
45873: LD_INT 5
45875: PUSH
45876: EMPTY
45877: LIST
45878: LIST
45879: ST_TO_ADDR
45880: GO 46517
45882: LD_INT 10
45884: DOUBLE
45885: EQUAL
45886: IFTRUE 45890
45888: GO 45908
45890: POP
// result := [ us_heavy_tracked , us_morphling ] ; ar_multimissile_ballista :
45891: LD_ADDR_VAR 0 3
45895: PUSH
45896: LD_INT 4
45898: PUSH
45899: LD_INT 5
45901: PUSH
45902: EMPTY
45903: LIST
45904: LIST
45905: ST_TO_ADDR
45906: GO 46517
45908: LD_INT 22
45910: DOUBLE
45911: EQUAL
45912: IFTRUE 45916
45914: GO 45942
45916: POP
// result := [ ar_hovercraft , ar_light_trike , ar_medium_trike , ar_half_tracked ] ; ar_light_gun :
45917: LD_ADDR_VAR 0 3
45921: PUSH
45922: LD_INT 11
45924: PUSH
45925: LD_INT 12
45927: PUSH
45928: LD_INT 13
45930: PUSH
45931: LD_INT 14
45933: PUSH
45934: EMPTY
45935: LIST
45936: LIST
45937: LIST
45938: LIST
45939: ST_TO_ADDR
45940: GO 46517
45942: LD_INT 23
45944: DOUBLE
45945: EQUAL
45946: IFTRUE 45950
45948: GO 45976
45950: POP
// result := [ ar_hovercraft , ar_light_trike , ar_medium_trike , ar_half_tracked ] ; ar_double_machine_gun :
45951: LD_ADDR_VAR 0 3
45955: PUSH
45956: LD_INT 11
45958: PUSH
45959: LD_INT 12
45961: PUSH
45962: LD_INT 13
45964: PUSH
45965: LD_INT 14
45967: PUSH
45968: EMPTY
45969: LIST
45970: LIST
45971: LIST
45972: LIST
45973: ST_TO_ADDR
45974: GO 46517
45976: LD_INT 24
45978: DOUBLE
45979: EQUAL
45980: IFTRUE 45984
45982: GO 46010
45984: POP
// result := [ ar_hovercraft , ar_light_trike , ar_medium_trike , ar_half_tracked ] ; ar_radar :
45985: LD_ADDR_VAR 0 3
45989: PUSH
45990: LD_INT 11
45992: PUSH
45993: LD_INT 12
45995: PUSH
45996: LD_INT 13
45998: PUSH
45999: LD_INT 14
46001: PUSH
46002: EMPTY
46003: LIST
46004: LIST
46005: LIST
46006: LIST
46007: ST_TO_ADDR
46008: GO 46517
46010: LD_INT 30
46012: DOUBLE
46013: EQUAL
46014: IFTRUE 46018
46016: GO 46044
46018: POP
// result := [ ar_hovercraft , ar_light_trike , ar_medium_trike , ar_half_tracked ] ; ar_gatling_gun :
46019: LD_ADDR_VAR 0 3
46023: PUSH
46024: LD_INT 11
46026: PUSH
46027: LD_INT 12
46029: PUSH
46030: LD_INT 13
46032: PUSH
46033: LD_INT 14
46035: PUSH
46036: EMPTY
46037: LIST
46038: LIST
46039: LIST
46040: LIST
46041: ST_TO_ADDR
46042: GO 46517
46044: LD_INT 25
46046: DOUBLE
46047: EQUAL
46048: IFTRUE 46052
46050: GO 46070
46052: POP
// result := [ ar_medium_trike , ar_half_tracked ] ; ar_gun :
46053: LD_ADDR_VAR 0 3
46057: PUSH
46058: LD_INT 13
46060: PUSH
46061: LD_INT 14
46063: PUSH
46064: EMPTY
46065: LIST
46066: LIST
46067: ST_TO_ADDR
46068: GO 46517
46070: LD_INT 27
46072: DOUBLE
46073: EQUAL
46074: IFTRUE 46078
46076: GO 46096
46078: POP
// result := [ ar_medium_trike , ar_half_tracked ] ; ar_rocket_launcher :
46079: LD_ADDR_VAR 0 3
46083: PUSH
46084: LD_INT 13
46086: PUSH
46087: LD_INT 14
46089: PUSH
46090: EMPTY
46091: LIST
46092: LIST
46093: ST_TO_ADDR
46094: GO 46517
46096: LD_INT 28
46098: DOUBLE
46099: EQUAL
46100: IFTRUE 46104
46102: GO 46122
46104: POP
// result := [ ar_medium_trike , ar_half_tracked ] ; ar_selfpropelled_bomb :
46105: LD_ADDR_VAR 0 3
46109: PUSH
46110: LD_INT 13
46112: PUSH
46113: LD_INT 14
46115: PUSH
46116: EMPTY
46117: LIST
46118: LIST
46119: ST_TO_ADDR
46120: GO 46517
46122: LD_INT 29
46124: DOUBLE
46125: EQUAL
46126: IFTRUE 46130
46128: GO 46148
46130: POP
// result := [ ar_medium_trike , ar_half_tracked ] ; ar_control_tower :
46131: LD_ADDR_VAR 0 3
46135: PUSH
46136: LD_INT 13
46138: PUSH
46139: LD_INT 14
46141: PUSH
46142: EMPTY
46143: LIST
46144: LIST
46145: ST_TO_ADDR
46146: GO 46517
46148: LD_INT 31
46150: DOUBLE
46151: EQUAL
46152: IFTRUE 46156
46154: GO 46174
46156: POP
// result := [ ar_medium_trike , ar_half_tracked ] ; ar_flame_thrower :
46157: LD_ADDR_VAR 0 3
46161: PUSH
46162: LD_INT 13
46164: PUSH
46165: LD_INT 14
46167: PUSH
46168: EMPTY
46169: LIST
46170: LIST
46171: ST_TO_ADDR
46172: GO 46517
46174: LD_INT 26
46176: DOUBLE
46177: EQUAL
46178: IFTRUE 46182
46180: GO 46200
46182: POP
// result := [ ar_medium_trike , ar_half_tracked ] ; ru_heavy_machine_gun :
46183: LD_ADDR_VAR 0 3
46187: PUSH
46188: LD_INT 13
46190: PUSH
46191: LD_INT 14
46193: PUSH
46194: EMPTY
46195: LIST
46196: LIST
46197: ST_TO_ADDR
46198: GO 46517
46200: LD_INT 42
46202: DOUBLE
46203: EQUAL
46204: IFTRUE 46208
46206: GO 46234
46208: POP
// result := [ ru_medium_wheeled , ru_medium_tracked , ru_heavy_wheeled , ru_heavy_tracked ] ; ru_gatling_gun :
46209: LD_ADDR_VAR 0 3
46213: PUSH
46214: LD_INT 21
46216: PUSH
46217: LD_INT 22
46219: PUSH
46220: LD_INT 23
46222: PUSH
46223: LD_INT 24
46225: PUSH
46226: EMPTY
46227: LIST
46228: LIST
46229: LIST
46230: LIST
46231: ST_TO_ADDR
46232: GO 46517
46234: LD_INT 43
46236: DOUBLE
46237: EQUAL
46238: IFTRUE 46242
46240: GO 46268
46242: POP
// result := [ ru_medium_wheeled , ru_medium_tracked , ru_heavy_wheeled , ru_heavy_tracked ] ; ru_gun :
46243: LD_ADDR_VAR 0 3
46247: PUSH
46248: LD_INT 21
46250: PUSH
46251: LD_INT 22
46253: PUSH
46254: LD_INT 23
46256: PUSH
46257: LD_INT 24
46259: PUSH
46260: EMPTY
46261: LIST
46262: LIST
46263: LIST
46264: LIST
46265: ST_TO_ADDR
46266: GO 46517
46268: LD_INT 44
46270: DOUBLE
46271: EQUAL
46272: IFTRUE 46276
46274: GO 46302
46276: POP
// result := [ ru_medium_wheeled , ru_medium_tracked , ru_heavy_wheeled , ru_heavy_tracked ] ; ru_rocket_launcher :
46277: LD_ADDR_VAR 0 3
46281: PUSH
46282: LD_INT 21
46284: PUSH
46285: LD_INT 22
46287: PUSH
46288: LD_INT 23
46290: PUSH
46291: LD_INT 24
46293: PUSH
46294: EMPTY
46295: LIST
46296: LIST
46297: LIST
46298: LIST
46299: ST_TO_ADDR
46300: GO 46517
46302: LD_INT 45
46304: DOUBLE
46305: EQUAL
46306: IFTRUE 46310
46308: GO 46336
46310: POP
// result := [ ru_medium_wheeled , ru_medium_tracked , ru_heavy_wheeled , ru_heavy_tracked ] ; ru_time_lapser :
46311: LD_ADDR_VAR 0 3
46315: PUSH
46316: LD_INT 21
46318: PUSH
46319: LD_INT 22
46321: PUSH
46322: LD_INT 23
46324: PUSH
46325: LD_INT 24
46327: PUSH
46328: EMPTY
46329: LIST
46330: LIST
46331: LIST
46332: LIST
46333: ST_TO_ADDR
46334: GO 46517
46336: LD_INT 49
46338: DOUBLE
46339: EQUAL
46340: IFTRUE 46344
46342: GO 46370
46344: POP
// result := [ ru_medium_wheeled , ru_medium_tracked , ru_heavy_wheeled , ru_heavy_tracked ] ; ru_cargo_bay :
46345: LD_ADDR_VAR 0 3
46349: PUSH
46350: LD_INT 21
46352: PUSH
46353: LD_INT 22
46355: PUSH
46356: LD_INT 23
46358: PUSH
46359: LD_INT 24
46361: PUSH
46362: EMPTY
46363: LIST
46364: LIST
46365: LIST
46366: LIST
46367: ST_TO_ADDR
46368: GO 46517
46370: LD_INT 51
46372: DOUBLE
46373: EQUAL
46374: IFTRUE 46378
46376: GO 46404
46378: POP
// result := [ ru_medium_wheeled , ru_medium_tracked , ru_heavy_wheeled , ru_heavy_tracked ] ; ru_crane :
46379: LD_ADDR_VAR 0 3
46383: PUSH
46384: LD_INT 21
46386: PUSH
46387: LD_INT 22
46389: PUSH
46390: LD_INT 23
46392: PUSH
46393: LD_INT 24
46395: PUSH
46396: EMPTY
46397: LIST
46398: LIST
46399: LIST
46400: LIST
46401: ST_TO_ADDR
46402: GO 46517
46404: LD_INT 52
46406: DOUBLE
46407: EQUAL
46408: IFTRUE 46412
46410: GO 46438
46412: POP
// result := [ ru_medium_wheeled , ru_medium_tracked , ru_heavy_wheeled , ru_heavy_tracked ] ; ru_bulldozer :
46413: LD_ADDR_VAR 0 3
46417: PUSH
46418: LD_INT 21
46420: PUSH
46421: LD_INT 22
46423: PUSH
46424: LD_INT 23
46426: PUSH
46427: LD_INT 24
46429: PUSH
46430: EMPTY
46431: LIST
46432: LIST
46433: LIST
46434: LIST
46435: ST_TO_ADDR
46436: GO 46517
46438: LD_INT 53
46440: DOUBLE
46441: EQUAL
46442: IFTRUE 46446
46444: GO 46464
46446: POP
// result := [ ru_heavy_wheeled , ru_heavy_tracked ] ; ru_heavy_gun :
46447: LD_ADDR_VAR 0 3
46451: PUSH
46452: LD_INT 23
46454: PUSH
46455: LD_INT 24
46457: PUSH
46458: EMPTY
46459: LIST
46460: LIST
46461: ST_TO_ADDR
46462: GO 46517
46464: LD_INT 46
46466: DOUBLE
46467: EQUAL
46468: IFTRUE 46472
46470: GO 46490
46472: POP
// result := [ ru_heavy_wheeled , ru_heavy_tracked ] ; ru_rocket :
46473: LD_ADDR_VAR 0 3
46477: PUSH
46478: LD_INT 23
46480: PUSH
46481: LD_INT 24
46483: PUSH
46484: EMPTY
46485: LIST
46486: LIST
46487: ST_TO_ADDR
46488: GO 46517
46490: LD_INT 47
46492: DOUBLE
46493: EQUAL
46494: IFTRUE 46498
46496: GO 46516
46498: POP
// result := [ ru_heavy_wheeled , ru_heavy_tracked ] ; end ;
46499: LD_ADDR_VAR 0 3
46503: PUSH
46504: LD_INT 23
46506: PUSH
46507: LD_INT 24
46509: PUSH
46510: EMPTY
46511: LIST
46512: LIST
46513: ST_TO_ADDR
46514: GO 46517
46516: POP
// result := ( chassis in result ) ;
46517: LD_ADDR_VAR 0 3
46521: PUSH
46522: LD_VAR 0 1
46526: PUSH
46527: LD_VAR 0 3
46531: IN
46532: ST_TO_ADDR
// end ;
46533: LD_VAR 0 3
46537: RET
// export function Reindex ( array , i_from , i_to , direction ) ; var i , j , k , d , tmp , length ; begin
46538: LD_INT 0
46540: PPUSH
46541: PPUSH
46542: PPUSH
46543: PPUSH
46544: PPUSH
46545: PPUSH
46546: PPUSH
// result := array ;
46547: LD_ADDR_VAR 0 5
46551: PUSH
46552: LD_VAR 0 1
46556: ST_TO_ADDR
// if not array or not i_from or not i_to or i_from > array or i_to > array then
46557: LD_VAR 0 1
46561: NOT
46562: PUSH
46563: LD_VAR 0 2
46567: NOT
46568: OR
46569: PUSH
46570: LD_VAR 0 3
46574: NOT
46575: OR
46576: PUSH
46577: LD_VAR 0 2
46581: PUSH
46582: LD_VAR 0 1
46586: GREATER
46587: OR
46588: PUSH
46589: LD_VAR 0 3
46593: PUSH
46594: LD_VAR 0 1
46598: GREATER
46599: OR
46600: IFFALSE 46604
// exit ;
46602: GO 46900
// if direction then
46604: LD_VAR 0 4
46608: IFFALSE 46672
// begin d := 1 ;
46610: LD_ADDR_VAR 0 9
46614: PUSH
46615: LD_INT 1
46617: ST_TO_ADDR
// if i_from > i_to then
46618: LD_VAR 0 2
46622: PUSH
46623: LD_VAR 0 3
46627: GREATER
46628: IFFALSE 46654
// length := ( array - i_from ) + i_to else
46630: LD_ADDR_VAR 0 11
46634: PUSH
46635: LD_VAR 0 1
46639: PUSH
46640: LD_VAR 0 2
46644: MINUS
46645: PUSH
46646: LD_VAR 0 3
46650: PLUS
46651: ST_TO_ADDR
46652: GO 46670
// length := i_to - i_from ;
46654: LD_ADDR_VAR 0 11
46658: PUSH
46659: LD_VAR 0 3
46663: PUSH
46664: LD_VAR 0 2
46668: MINUS
46669: ST_TO_ADDR
// end else
46670: GO 46733
// begin d := - 1 ;
46672: LD_ADDR_VAR 0 9
46676: PUSH
46677: LD_INT 1
46679: NEG
46680: ST_TO_ADDR
// if i_from > i_to then
46681: LD_VAR 0 2
46685: PUSH
46686: LD_VAR 0 3
46690: GREATER
46691: IFFALSE 46711
// length := i_from - i_to else
46693: LD_ADDR_VAR 0 11
46697: PUSH
46698: LD_VAR 0 2
46702: PUSH
46703: LD_VAR 0 3
46707: MINUS
46708: ST_TO_ADDR
46709: GO 46733
// length := ( array - i_to ) + i_from ;
46711: LD_ADDR_VAR 0 11
46715: PUSH
46716: LD_VAR 0 1
46720: PUSH
46721: LD_VAR 0 3
46725: MINUS
46726: PUSH
46727: LD_VAR 0 2
46731: PLUS
46732: ST_TO_ADDR
// end ; if not length then
46733: LD_VAR 0 11
46737: NOT
46738: IFFALSE 46742
// exit ;
46740: GO 46900
// tmp := array ;
46742: LD_ADDR_VAR 0 10
46746: PUSH
46747: LD_VAR 0 1
46751: ST_TO_ADDR
// for i = 1 to length do
46752: LD_ADDR_VAR 0 6
46756: PUSH
46757: DOUBLE
46758: LD_INT 1
46760: DEC
46761: ST_TO_ADDR
46762: LD_VAR 0 11
46766: PUSH
46767: FOR_TO
46768: IFFALSE 46888
// begin for j = 1 to array do
46770: LD_ADDR_VAR 0 7
46774: PUSH
46775: DOUBLE
46776: LD_INT 1
46778: DEC
46779: ST_TO_ADDR
46780: LD_VAR 0 1
46784: PUSH
46785: FOR_TO
46786: IFFALSE 46874
// begin k := j + d ;
46788: LD_ADDR_VAR 0 8
46792: PUSH
46793: LD_VAR 0 7
46797: PUSH
46798: LD_VAR 0 9
46802: PLUS
46803: ST_TO_ADDR
// if k > array then
46804: LD_VAR 0 8
46808: PUSH
46809: LD_VAR 0 1
46813: GREATER
46814: IFFALSE 46824
// k := 1 ;
46816: LD_ADDR_VAR 0 8
46820: PUSH
46821: LD_INT 1
46823: ST_TO_ADDR
// if not k then
46824: LD_VAR 0 8
46828: NOT
46829: IFFALSE 46841
// k := array ;
46831: LD_ADDR_VAR 0 8
46835: PUSH
46836: LD_VAR 0 1
46840: ST_TO_ADDR
// tmp := Replace ( tmp , k , array [ j ] ) ;
46841: LD_ADDR_VAR 0 10
46845: PUSH
46846: LD_VAR 0 10
46850: PPUSH
46851: LD_VAR 0 8
46855: PPUSH
46856: LD_VAR 0 1
46860: PUSH
46861: LD_VAR 0 7
46865: ARRAY
46866: PPUSH
46867: CALL_OW 1
46871: ST_TO_ADDR
// end ;
46872: GO 46785
46874: POP
46875: POP
// array := tmp ;
46876: LD_ADDR_VAR 0 1
46880: PUSH
46881: LD_VAR 0 10
46885: ST_TO_ADDR
// end ;
46886: GO 46767
46888: POP
46889: POP
// result := array ;
46890: LD_ADDR_VAR 0 5
46894: PUSH
46895: LD_VAR 0 1
46899: ST_TO_ADDR
// end ;
46900: LD_VAR 0 5
46904: RET
// export function GetElementIndex ( array , value ) ; var i ; begin
46905: LD_INT 0
46907: PPUSH
46908: PPUSH
// result := 0 ;
46909: LD_ADDR_VAR 0 3
46913: PUSH
46914: LD_INT 0
46916: ST_TO_ADDR
// if not array or not value in array then
46917: LD_VAR 0 1
46921: NOT
46922: PUSH
46923: LD_VAR 0 2
46927: PUSH
46928: LD_VAR 0 1
46932: IN
46933: NOT
46934: OR
46935: IFFALSE 46939
// exit ;
46937: GO 46993
// for i = 1 to array do
46939: LD_ADDR_VAR 0 4
46943: PUSH
46944: DOUBLE
46945: LD_INT 1
46947: DEC
46948: ST_TO_ADDR
46949: LD_VAR 0 1
46953: PUSH
46954: FOR_TO
46955: IFFALSE 46991
// if value = array [ i ] then
46957: LD_VAR 0 2
46961: PUSH
46962: LD_VAR 0 1
46966: PUSH
46967: LD_VAR 0 4
46971: ARRAY
46972: EQUAL
46973: IFFALSE 46989
// begin result := i ;
46975: LD_ADDR_VAR 0 3
46979: PUSH
46980: LD_VAR 0 4
46984: ST_TO_ADDR
// exit ;
46985: POP
46986: POP
46987: GO 46993
// end ;
46989: GO 46954
46991: POP
46992: POP
// end ;
46993: LD_VAR 0 3
46997: RET
// export function PrepareVehicle ( chassis , engine , control , weapon , fuel ) ; begin
46998: LD_INT 0
47000: PPUSH
// vc_chassis := chassis ;
47001: LD_ADDR_OWVAR 37
47005: PUSH
47006: LD_VAR 0 1
47010: ST_TO_ADDR
// vc_engine := engine ;
47011: LD_ADDR_OWVAR 39
47015: PUSH
47016: LD_VAR 0 2
47020: ST_TO_ADDR
// vc_control := control ;
47021: LD_ADDR_OWVAR 38
47025: PUSH
47026: LD_VAR 0 3
47030: ST_TO_ADDR
// vc_weapon := weapon ;
47031: LD_ADDR_OWVAR 40
47035: PUSH
47036: LD_VAR 0 4
47040: ST_TO_ADDR
// vc_fuel_battery := fuel ;
47041: LD_ADDR_OWVAR 41
47045: PUSH
47046: LD_VAR 0 5
47050: ST_TO_ADDR
// end ;
47051: LD_VAR 0 6
47055: RET
// export function WantPlant ( unit ) ; var task ; begin
47056: LD_INT 0
47058: PPUSH
47059: PPUSH
// result := false ;
47060: LD_ADDR_VAR 0 2
47064: PUSH
47065: LD_INT 0
47067: ST_TO_ADDR
// task := GetTaskList ( unit ) ;
47068: LD_ADDR_VAR 0 3
47072: PUSH
47073: LD_VAR 0 1
47077: PPUSH
47078: CALL_OW 437
47082: ST_TO_ADDR
// if task then
47083: LD_VAR 0 3
47087: IFFALSE 47115
// if task [ 1 ] [ 1 ] = p then
47089: LD_VAR 0 3
47093: PUSH
47094: LD_INT 1
47096: ARRAY
47097: PUSH
47098: LD_INT 1
47100: ARRAY
47101: PUSH
47102: LD_STRING p
47104: EQUAL
47105: IFFALSE 47115
// result := true ;
47107: LD_ADDR_VAR 0 2
47111: PUSH
47112: LD_INT 1
47114: ST_TO_ADDR
// end ;
47115: LD_VAR 0 2
47119: RET
// export function ReplaceIn ( arr , pos , value ) ; var i , tmp , s_arr ; begin
47120: LD_INT 0
47122: PPUSH
47123: PPUSH
47124: PPUSH
47125: PPUSH
// if pos < 1 then
47126: LD_VAR 0 2
47130: PUSH
47131: LD_INT 1
47133: LESS
47134: IFFALSE 47138
// exit ;
47136: GO 47441
// if pos = 1 then
47138: LD_VAR 0 2
47142: PUSH
47143: LD_INT 1
47145: EQUAL
47146: IFFALSE 47179
// result := Replace ( arr , pos [ 1 ] , value ) else
47148: LD_ADDR_VAR 0 4
47152: PUSH
47153: LD_VAR 0 1
47157: PPUSH
47158: LD_VAR 0 2
47162: PUSH
47163: LD_INT 1
47165: ARRAY
47166: PPUSH
47167: LD_VAR 0 3
47171: PPUSH
47172: CALL_OW 1
47176: ST_TO_ADDR
47177: GO 47441
// begin tmp := arr ;
47179: LD_ADDR_VAR 0 6
47183: PUSH
47184: LD_VAR 0 1
47188: ST_TO_ADDR
// s_arr := [ tmp ] ;
47189: LD_ADDR_VAR 0 7
47193: PUSH
47194: LD_VAR 0 6
47198: PUSH
47199: EMPTY
47200: LIST
47201: ST_TO_ADDR
// for i = 1 to pos - 1 do
47202: LD_ADDR_VAR 0 5
47206: PUSH
47207: DOUBLE
47208: LD_INT 1
47210: DEC
47211: ST_TO_ADDR
47212: LD_VAR 0 2
47216: PUSH
47217: LD_INT 1
47219: MINUS
47220: PUSH
47221: FOR_TO
47222: IFFALSE 47267
// begin tmp := tmp [ pos [ i ] ] ;
47224: LD_ADDR_VAR 0 6
47228: PUSH
47229: LD_VAR 0 6
47233: PUSH
47234: LD_VAR 0 2
47238: PUSH
47239: LD_VAR 0 5
47243: ARRAY
47244: ARRAY
47245: ST_TO_ADDR
// s_arr := s_arr ^ [ tmp ] ;
47246: LD_ADDR_VAR 0 7
47250: PUSH
47251: LD_VAR 0 7
47255: PUSH
47256: LD_VAR 0 6
47260: PUSH
47261: EMPTY
47262: LIST
47263: ADD
47264: ST_TO_ADDR
// end ;
47265: GO 47221
47267: POP
47268: POP
// tmp := Replace ( tmp , pos [ pos ] , value ) ;
47269: LD_ADDR_VAR 0 6
47273: PUSH
47274: LD_VAR 0 6
47278: PPUSH
47279: LD_VAR 0 2
47283: PUSH
47284: LD_VAR 0 2
47288: ARRAY
47289: PPUSH
47290: LD_VAR 0 3
47294: PPUSH
47295: CALL_OW 1
47299: ST_TO_ADDR
// s_arr := Replace ( s_arr , s_arr , tmp ) ;
47300: LD_ADDR_VAR 0 7
47304: PUSH
47305: LD_VAR 0 7
47309: PPUSH
47310: LD_VAR 0 7
47314: PPUSH
47315: LD_VAR 0 6
47319: PPUSH
47320: CALL_OW 1
47324: ST_TO_ADDR
// for i = s_arr downto 2 do
47325: LD_ADDR_VAR 0 5
47329: PUSH
47330: DOUBLE
47331: LD_VAR 0 7
47335: INC
47336: ST_TO_ADDR
47337: LD_INT 2
47339: PUSH
47340: FOR_DOWNTO
47341: IFFALSE 47425
// begin tmp := Replace ( s_arr [ i - 1 ] , pos [ i - 1 ] , s_arr [ i ] ) ;
47343: LD_ADDR_VAR 0 6
47347: PUSH
47348: LD_VAR 0 7
47352: PUSH
47353: LD_VAR 0 5
47357: PUSH
47358: LD_INT 1
47360: MINUS
47361: ARRAY
47362: PPUSH
47363: LD_VAR 0 2
47367: PUSH
47368: LD_VAR 0 5
47372: PUSH
47373: LD_INT 1
47375: MINUS
47376: ARRAY
47377: PPUSH
47378: LD_VAR 0 7
47382: PUSH
47383: LD_VAR 0 5
47387: ARRAY
47388: PPUSH
47389: CALL_OW 1
47393: ST_TO_ADDR
// s_arr := Replace ( s_arr , i - 1 , tmp ) ;
47394: LD_ADDR_VAR 0 7
47398: PUSH
47399: LD_VAR 0 7
47403: PPUSH
47404: LD_VAR 0 5
47408: PUSH
47409: LD_INT 1
47411: MINUS
47412: PPUSH
47413: LD_VAR 0 6
47417: PPUSH
47418: CALL_OW 1
47422: ST_TO_ADDR
// end ;
47423: GO 47340
47425: POP
47426: POP
// result := s_arr [ 1 ] ;
47427: LD_ADDR_VAR 0 4
47431: PUSH
47432: LD_VAR 0 7
47436: PUSH
47437: LD_INT 1
47439: ARRAY
47440: ST_TO_ADDR
// end ; end ;
47441: LD_VAR 0 4
47445: RET
// export function ReplaceWith ( list , pos1 , pos2 ) ; var i ; begin
47446: LD_INT 0
47448: PPUSH
47449: PPUSH
// if not list then
47450: LD_VAR 0 1
47454: NOT
47455: IFFALSE 47459
// exit ;
47457: GO 47550
// i := list [ pos1 ] ;
47459: LD_ADDR_VAR 0 5
47463: PUSH
47464: LD_VAR 0 1
47468: PUSH
47469: LD_VAR 0 2
47473: ARRAY
47474: ST_TO_ADDR
// if not i then
47475: LD_VAR 0 5
47479: NOT
47480: IFFALSE 47484
// exit ;
47482: GO 47550
// list := Replace ( list , pos1 , list [ pos2 ] ) ;
47484: LD_ADDR_VAR 0 1
47488: PUSH
47489: LD_VAR 0 1
47493: PPUSH
47494: LD_VAR 0 2
47498: PPUSH
47499: LD_VAR 0 1
47503: PUSH
47504: LD_VAR 0 3
47508: ARRAY
47509: PPUSH
47510: CALL_OW 1
47514: ST_TO_ADDR
// list := Replace ( list , pos2 , i ) ;
47515: LD_ADDR_VAR 0 1
47519: PUSH
47520: LD_VAR 0 1
47524: PPUSH
47525: LD_VAR 0 3
47529: PPUSH
47530: LD_VAR 0 5
47534: PPUSH
47535: CALL_OW 1
47539: ST_TO_ADDR
// result := list ;
47540: LD_ADDR_VAR 0 4
47544: PUSH
47545: LD_VAR 0 1
47549: ST_TO_ADDR
// end ;
47550: LD_VAR 0 4
47554: RET
// export function SortByDistanceUnit ( unit , list , asc , mode ) ; begin
47555: LD_INT 0
47557: PPUSH
// result := SortByDistanceXY ( GetX ( unit ) , GetY ( unit ) , list , asc , mode ) ;
47558: LD_ADDR_VAR 0 5
47562: PUSH
47563: LD_VAR 0 1
47567: PPUSH
47568: CALL_OW 250
47572: PPUSH
47573: LD_VAR 0 1
47577: PPUSH
47578: CALL_OW 251
47582: PPUSH
47583: LD_VAR 0 2
47587: PPUSH
47588: LD_VAR 0 3
47592: PPUSH
47593: LD_VAR 0 4
47597: PPUSH
47598: CALL 47608 0 5
47602: ST_TO_ADDR
// end ;
47603: LD_VAR 0 5
47607: RET
// export function SortByDistanceXY ( x , y , list , asc , mode ) ; var i , j , tmp ; begin
47608: LD_INT 0
47610: PPUSH
47611: PPUSH
47612: PPUSH
47613: PPUSH
// if not list then
47614: LD_VAR 0 3
47618: NOT
47619: IFFALSE 47623
// exit ;
47621: GO 48011
// result := [ ] ;
47623: LD_ADDR_VAR 0 6
47627: PUSH
47628: EMPTY
47629: ST_TO_ADDR
// for i in list do
47630: LD_ADDR_VAR 0 7
47634: PUSH
47635: LD_VAR 0 3
47639: PUSH
47640: FOR_IN
47641: IFFALSE 47843
// begin tmp := GetDistUnitXY ( i , x , y ) ;
47643: LD_ADDR_VAR 0 9
47647: PUSH
47648: LD_VAR 0 7
47652: PPUSH
47653: LD_VAR 0 1
47657: PPUSH
47658: LD_VAR 0 2
47662: PPUSH
47663: CALL_OW 297
47667: ST_TO_ADDR
// if not result then
47668: LD_VAR 0 6
47672: NOT
47673: IFFALSE 47699
// result := [ [ i , tmp ] ] else
47675: LD_ADDR_VAR 0 6
47679: PUSH
47680: LD_VAR 0 7
47684: PUSH
47685: LD_VAR 0 9
47689: PUSH
47690: EMPTY
47691: LIST
47692: LIST
47693: PUSH
47694: EMPTY
47695: LIST
47696: ST_TO_ADDR
47697: GO 47841
// begin if result [ result ] [ 2 ] < tmp then
47699: LD_VAR 0 6
47703: PUSH
47704: LD_VAR 0 6
47708: ARRAY
47709: PUSH
47710: LD_INT 2
47712: ARRAY
47713: PUSH
47714: LD_VAR 0 9
47718: LESS
47719: IFFALSE 47761
// result := Insert ( result , result + 1 , [ i , tmp ] ) else
47721: LD_ADDR_VAR 0 6
47725: PUSH
47726: LD_VAR 0 6
47730: PPUSH
47731: LD_VAR 0 6
47735: PUSH
47736: LD_INT 1
47738: PLUS
47739: PPUSH
47740: LD_VAR 0 7
47744: PUSH
47745: LD_VAR 0 9
47749: PUSH
47750: EMPTY
47751: LIST
47752: LIST
47753: PPUSH
47754: CALL_OW 2
47758: ST_TO_ADDR
47759: GO 47841
// for j = 1 to result do
47761: LD_ADDR_VAR 0 8
47765: PUSH
47766: DOUBLE
47767: LD_INT 1
47769: DEC
47770: ST_TO_ADDR
47771: LD_VAR 0 6
47775: PUSH
47776: FOR_TO
47777: IFFALSE 47839
// begin if tmp < result [ j ] [ 2 ] then
47779: LD_VAR 0 9
47783: PUSH
47784: LD_VAR 0 6
47788: PUSH
47789: LD_VAR 0 8
47793: ARRAY
47794: PUSH
47795: LD_INT 2
47797: ARRAY
47798: LESS
47799: IFFALSE 47837
// begin result := Insert ( result , j , [ i , tmp ] ) ;
47801: LD_ADDR_VAR 0 6
47805: PUSH
47806: LD_VAR 0 6
47810: PPUSH
47811: LD_VAR 0 8
47815: PPUSH
47816: LD_VAR 0 7
47820: PUSH
47821: LD_VAR 0 9
47825: PUSH
47826: EMPTY
47827: LIST
47828: LIST
47829: PPUSH
47830: CALL_OW 2
47834: ST_TO_ADDR
// break ;
47835: GO 47839
// end ; end ;
47837: GO 47776
47839: POP
47840: POP
// end ; end ;
47841: GO 47640
47843: POP
47844: POP
// if result and not asc then
47845: LD_VAR 0 6
47849: PUSH
47850: LD_VAR 0 4
47854: NOT
47855: AND
47856: IFFALSE 47931
// begin tmp := result ;
47858: LD_ADDR_VAR 0 9
47862: PUSH
47863: LD_VAR 0 6
47867: ST_TO_ADDR
// for i = tmp downto 1 do
47868: LD_ADDR_VAR 0 7
47872: PUSH
47873: DOUBLE
47874: LD_VAR 0 9
47878: INC
47879: ST_TO_ADDR
47880: LD_INT 1
47882: PUSH
47883: FOR_DOWNTO
47884: IFFALSE 47929
// result := Replace ( result , tmp - i + 1 , tmp [ i ] ) ;
47886: LD_ADDR_VAR 0 6
47890: PUSH
47891: LD_VAR 0 6
47895: PPUSH
47896: LD_VAR 0 9
47900: PUSH
47901: LD_VAR 0 7
47905: MINUS
47906: PUSH
47907: LD_INT 1
47909: PLUS
47910: PPUSH
47911: LD_VAR 0 9
47915: PUSH
47916: LD_VAR 0 7
47920: ARRAY
47921: PPUSH
47922: CALL_OW 1
47926: ST_TO_ADDR
47927: GO 47883
47929: POP
47930: POP
// end ; tmp := [ ] ;
47931: LD_ADDR_VAR 0 9
47935: PUSH
47936: EMPTY
47937: ST_TO_ADDR
// if mode then
47938: LD_VAR 0 5
47942: IFFALSE 48011
// begin for i = 1 to result do
47944: LD_ADDR_VAR 0 7
47948: PUSH
47949: DOUBLE
47950: LD_INT 1
47952: DEC
47953: ST_TO_ADDR
47954: LD_VAR 0 6
47958: PUSH
47959: FOR_TO
47960: IFFALSE 47999
// tmp := Replace ( tmp , i , result [ i ] [ 1 ] ) ;
47962: LD_ADDR_VAR 0 9
47966: PUSH
47967: LD_VAR 0 9
47971: PPUSH
47972: LD_VAR 0 7
47976: PPUSH
47977: LD_VAR 0 6
47981: PUSH
47982: LD_VAR 0 7
47986: ARRAY
47987: PUSH
47988: LD_INT 1
47990: ARRAY
47991: PPUSH
47992: CALL_OW 1
47996: ST_TO_ADDR
47997: GO 47959
47999: POP
48000: POP
// result := tmp ;
48001: LD_ADDR_VAR 0 6
48005: PUSH
48006: LD_VAR 0 9
48010: ST_TO_ADDR
// end ; end ;
48011: LD_VAR 0 6
48015: RET
// export function DangerAtRangeXY ( side , x , y , range ) ; var i , j , tmp , points , bpoints ; begin
48016: LD_INT 0
48018: PPUSH
48019: PPUSH
48020: PPUSH
48021: PPUSH
48022: PPUSH
48023: PPUSH
// result := [ 0 , 0 , 0 , [ ] ] ;
48024: LD_ADDR_VAR 0 5
48028: PUSH
48029: LD_INT 0
48031: PUSH
48032: LD_INT 0
48034: PUSH
48035: LD_INT 0
48037: PUSH
48038: EMPTY
48039: PUSH
48040: EMPTY
48041: LIST
48042: LIST
48043: LIST
48044: LIST
48045: ST_TO_ADDR
// if not x or not y then
48046: LD_VAR 0 2
48050: NOT
48051: PUSH
48052: LD_VAR 0 3
48056: NOT
48057: OR
48058: IFFALSE 48062
// exit ;
48060: GO 49708
// if not range then
48062: LD_VAR 0 4
48066: NOT
48067: IFFALSE 48077
// range := 10 ;
48069: LD_ADDR_VAR 0 4
48073: PUSH
48074: LD_INT 10
48076: ST_TO_ADDR
// tmp := FilterAllUnits ( [ [ f_enemy , side ] , [ f_distxy , x , y , range ] , [ f_not , [ f_type , unit_building ] ] ] ) ;
48077: LD_ADDR_VAR 0 8
48081: PUSH
48082: LD_INT 81
48084: PUSH
48085: LD_VAR 0 1
48089: PUSH
48090: EMPTY
48091: LIST
48092: LIST
48093: PUSH
48094: LD_INT 92
48096: PUSH
48097: LD_VAR 0 2
48101: PUSH
48102: LD_VAR 0 3
48106: PUSH
48107: LD_VAR 0 4
48111: PUSH
48112: EMPTY
48113: LIST
48114: LIST
48115: LIST
48116: LIST
48117: PUSH
48118: LD_INT 3
48120: PUSH
48121: LD_INT 21
48123: PUSH
48124: LD_INT 3
48126: PUSH
48127: EMPTY
48128: LIST
48129: LIST
48130: PUSH
48131: EMPTY
48132: LIST
48133: LIST
48134: PUSH
48135: EMPTY
48136: LIST
48137: LIST
48138: LIST
48139: PPUSH
48140: CALL_OW 69
48144: ST_TO_ADDR
// if not tmp then
48145: LD_VAR 0 8
48149: NOT
48150: IFFALSE 48154
// exit ;
48152: GO 49708
// for i in tmp do
48154: LD_ADDR_VAR 0 6
48158: PUSH
48159: LD_VAR 0 8
48163: PUSH
48164: FOR_IN
48165: IFFALSE 49683
// begin points := [ 0 , 0 , 0 ] ;
48167: LD_ADDR_VAR 0 9
48171: PUSH
48172: LD_INT 0
48174: PUSH
48175: LD_INT 0
48177: PUSH
48178: LD_INT 0
48180: PUSH
48181: EMPTY
48182: LIST
48183: LIST
48184: LIST
48185: ST_TO_ADDR
// bpoints := 1 ;
48186: LD_ADDR_VAR 0 10
48190: PUSH
48191: LD_INT 1
48193: ST_TO_ADDR
// case GetType ( i ) of unit_human :
48194: LD_VAR 0 6
48198: PPUSH
48199: CALL_OW 247
48203: PUSH
48204: LD_INT 1
48206: DOUBLE
48207: EQUAL
48208: IFTRUE 48212
48210: GO 48790
48212: POP
// begin if GetClass ( i ) = 1 then
48213: LD_VAR 0 6
48217: PPUSH
48218: CALL_OW 257
48222: PUSH
48223: LD_INT 1
48225: EQUAL
48226: IFFALSE 48247
// points := [ 10 , 5 , 3 ] ;
48228: LD_ADDR_VAR 0 9
48232: PUSH
48233: LD_INT 10
48235: PUSH
48236: LD_INT 5
48238: PUSH
48239: LD_INT 3
48241: PUSH
48242: EMPTY
48243: LIST
48244: LIST
48245: LIST
48246: ST_TO_ADDR
// if GetClass ( i ) in [ 2 , 3 , 4 ] then
48247: LD_VAR 0 6
48251: PPUSH
48252: CALL_OW 257
48256: PUSH
48257: LD_INT 2
48259: PUSH
48260: LD_INT 3
48262: PUSH
48263: LD_INT 4
48265: PUSH
48266: EMPTY
48267: LIST
48268: LIST
48269: LIST
48270: IN
48271: IFFALSE 48292
// points := [ 3 , 2 , 1 ] ;
48273: LD_ADDR_VAR 0 9
48277: PUSH
48278: LD_INT 3
48280: PUSH
48281: LD_INT 2
48283: PUSH
48284: LD_INT 1
48286: PUSH
48287: EMPTY
48288: LIST
48289: LIST
48290: LIST
48291: ST_TO_ADDR
// if GetClass ( i ) = 5 then
48292: LD_VAR 0 6
48296: PPUSH
48297: CALL_OW 257
48301: PUSH
48302: LD_INT 5
48304: EQUAL
48305: IFFALSE 48326
// points := [ 130 , 5 , 2 ] ;
48307: LD_ADDR_VAR 0 9
48311: PUSH
48312: LD_INT 130
48314: PUSH
48315: LD_INT 5
48317: PUSH
48318: LD_INT 2
48320: PUSH
48321: EMPTY
48322: LIST
48323: LIST
48324: LIST
48325: ST_TO_ADDR
// if GetClass ( i ) = 8 then
48326: LD_VAR 0 6
48330: PPUSH
48331: CALL_OW 257
48335: PUSH
48336: LD_INT 8
48338: EQUAL
48339: IFFALSE 48360
// points := [ 35 , 35 , 30 ] ;
48341: LD_ADDR_VAR 0 9
48345: PUSH
48346: LD_INT 35
48348: PUSH
48349: LD_INT 35
48351: PUSH
48352: LD_INT 30
48354: PUSH
48355: EMPTY
48356: LIST
48357: LIST
48358: LIST
48359: ST_TO_ADDR
// if GetClass ( i ) = 9 then
48360: LD_VAR 0 6
48364: PPUSH
48365: CALL_OW 257
48369: PUSH
48370: LD_INT 9
48372: EQUAL
48373: IFFALSE 48394
// points := [ 20 , 55 , 40 ] ;
48375: LD_ADDR_VAR 0 9
48379: PUSH
48380: LD_INT 20
48382: PUSH
48383: LD_INT 55
48385: PUSH
48386: LD_INT 40
48388: PUSH
48389: EMPTY
48390: LIST
48391: LIST
48392: LIST
48393: ST_TO_ADDR
// if GetClass ( i ) in [ 12 , 16 ] then
48394: LD_VAR 0 6
48398: PPUSH
48399: CALL_OW 257
48403: PUSH
48404: LD_INT 12
48406: PUSH
48407: LD_INT 16
48409: PUSH
48410: EMPTY
48411: LIST
48412: LIST
48413: IN
48414: IFFALSE 48435
// points := [ 5 , 3 , 2 ] ;
48416: LD_ADDR_VAR 0 9
48420: PUSH
48421: LD_INT 5
48423: PUSH
48424: LD_INT 3
48426: PUSH
48427: LD_INT 2
48429: PUSH
48430: EMPTY
48431: LIST
48432: LIST
48433: LIST
48434: ST_TO_ADDR
// if GetClass ( i ) = 17 then
48435: LD_VAR 0 6
48439: PPUSH
48440: CALL_OW 257
48444: PUSH
48445: LD_INT 17
48447: EQUAL
48448: IFFALSE 48469
// points := [ 100 , 50 , 75 ] ;
48450: LD_ADDR_VAR 0 9
48454: PUSH
48455: LD_INT 100
48457: PUSH
48458: LD_INT 50
48460: PUSH
48461: LD_INT 75
48463: PUSH
48464: EMPTY
48465: LIST
48466: LIST
48467: LIST
48468: ST_TO_ADDR
// if GetClass ( i ) = 15 then
48469: LD_VAR 0 6
48473: PPUSH
48474: CALL_OW 257
48478: PUSH
48479: LD_INT 15
48481: EQUAL
48482: IFFALSE 48503
// points := [ 10 , 5 , 3 ] ;
48484: LD_ADDR_VAR 0 9
48488: PUSH
48489: LD_INT 10
48491: PUSH
48492: LD_INT 5
48494: PUSH
48495: LD_INT 3
48497: PUSH
48498: EMPTY
48499: LIST
48500: LIST
48501: LIST
48502: ST_TO_ADDR
// if GetClass ( i ) = 14 then
48503: LD_VAR 0 6
48507: PPUSH
48508: CALL_OW 257
48512: PUSH
48513: LD_INT 14
48515: EQUAL
48516: IFFALSE 48537
// points := [ 10 , 0 , 0 ] ;
48518: LD_ADDR_VAR 0 9
48522: PUSH
48523: LD_INT 10
48525: PUSH
48526: LD_INT 0
48528: PUSH
48529: LD_INT 0
48531: PUSH
48532: EMPTY
48533: LIST
48534: LIST
48535: LIST
48536: ST_TO_ADDR
// if GetClass ( i ) = 11 then
48537: LD_VAR 0 6
48541: PPUSH
48542: CALL_OW 257
48546: PUSH
48547: LD_INT 11
48549: EQUAL
48550: IFFALSE 48571
// points := [ 30 , 10 , 5 ] ;
48552: LD_ADDR_VAR 0 9
48556: PUSH
48557: LD_INT 30
48559: PUSH
48560: LD_INT 10
48562: PUSH
48563: LD_INT 5
48565: PUSH
48566: EMPTY
48567: LIST
48568: LIST
48569: LIST
48570: ST_TO_ADDR
// if GetTech ( side , tech_stimdrugs ) = state_researched then
48571: LD_VAR 0 1
48575: PPUSH
48576: LD_INT 5
48578: PPUSH
48579: CALL_OW 321
48583: PUSH
48584: LD_INT 2
48586: EQUAL
48587: IFFALSE 48604
// bpoints := bpoints * 1.8 ;
48589: LD_ADDR_VAR 0 10
48593: PUSH
48594: LD_VAR 0 10
48598: PUSH
48599: LD_REAL  1.80000000000000E+0000
48602: MUL
48603: ST_TO_ADDR
// if GetClass ( i ) in [ 1 , 2 , 3 , 4 ] and GetTech ( side , tech_weap1 ) = state_researched then
48604: LD_VAR 0 6
48608: PPUSH
48609: CALL_OW 257
48613: PUSH
48614: LD_INT 1
48616: PUSH
48617: LD_INT 2
48619: PUSH
48620: LD_INT 3
48622: PUSH
48623: LD_INT 4
48625: PUSH
48626: EMPTY
48627: LIST
48628: LIST
48629: LIST
48630: LIST
48631: IN
48632: PUSH
48633: LD_VAR 0 1
48637: PPUSH
48638: LD_INT 51
48640: PPUSH
48641: CALL_OW 321
48645: PUSH
48646: LD_INT 2
48648: EQUAL
48649: AND
48650: IFFALSE 48667
// bpoints := bpoints * 1.2 ;
48652: LD_ADDR_VAR 0 10
48656: PUSH
48657: LD_VAR 0 10
48661: PUSH
48662: LD_REAL  1.20000000000000E+0000
48665: MUL
48666: ST_TO_ADDR
// if GetClass ( i ) in [ 5 , 7 , 9 ] and GetTech ( side , tech_weap2 ) = state_researched then
48667: LD_VAR 0 6
48671: PPUSH
48672: CALL_OW 257
48676: PUSH
48677: LD_INT 5
48679: PUSH
48680: LD_INT 7
48682: PUSH
48683: LD_INT 9
48685: PUSH
48686: EMPTY
48687: LIST
48688: LIST
48689: LIST
48690: IN
48691: PUSH
48692: LD_VAR 0 1
48696: PPUSH
48697: LD_INT 52
48699: PPUSH
48700: CALL_OW 321
48704: PUSH
48705: LD_INT 2
48707: EQUAL
48708: AND
48709: IFFALSE 48726
// bpoints := bpoints * 1.5 ;
48711: LD_ADDR_VAR 0 10
48715: PUSH
48716: LD_VAR 0 10
48720: PUSH
48721: LD_REAL  1.50000000000000E+0000
48724: MUL
48725: ST_TO_ADDR
// if GetTech ( side , tech_bio1 ) = state_researched then
48726: LD_VAR 0 1
48730: PPUSH
48731: LD_INT 66
48733: PPUSH
48734: CALL_OW 321
48738: PUSH
48739: LD_INT 2
48741: EQUAL
48742: IFFALSE 48759
// bpoints := bpoints * 1.1 ;
48744: LD_ADDR_VAR 0 10
48748: PUSH
48749: LD_VAR 0 10
48753: PUSH
48754: LD_REAL  1.10000000000000E+0000
48757: MUL
48758: ST_TO_ADDR
// bpoints := bpoints * ( GetSkill ( i , 1 ) * 1.15 ) ;
48759: LD_ADDR_VAR 0 10
48763: PUSH
48764: LD_VAR 0 10
48768: PUSH
48769: LD_VAR 0 6
48773: PPUSH
48774: LD_INT 1
48776: PPUSH
48777: CALL_OW 259
48781: PUSH
48782: LD_REAL  1.15000000000000E+0000
48785: MUL
48786: MUL
48787: ST_TO_ADDR
// end ; unit_vehicle :
48788: GO 49612
48790: LD_INT 2
48792: DOUBLE
48793: EQUAL
48794: IFTRUE 48798
48796: GO 49600
48798: POP
// begin if GetWeapon ( i ) in [ us_machine_gun , ru_heavy_machine_gun , ar_double_machine_gun ] then
48799: LD_VAR 0 6
48803: PPUSH
48804: CALL_OW 264
48808: PUSH
48809: LD_INT 2
48811: PUSH
48812: LD_INT 42
48814: PUSH
48815: LD_INT 24
48817: PUSH
48818: EMPTY
48819: LIST
48820: LIST
48821: LIST
48822: IN
48823: IFFALSE 48844
// points := [ 25 , 5 , 3 ] ;
48825: LD_ADDR_VAR 0 9
48829: PUSH
48830: LD_INT 25
48832: PUSH
48833: LD_INT 5
48835: PUSH
48836: LD_INT 3
48838: PUSH
48839: EMPTY
48840: LIST
48841: LIST
48842: LIST
48843: ST_TO_ADDR
// if GetWeapon ( i ) in [ us_gatling_gun , ru_gatling_gun , ar_gatling_gun ] then
48844: LD_VAR 0 6
48848: PPUSH
48849: CALL_OW 264
48853: PUSH
48854: LD_INT 4
48856: PUSH
48857: LD_INT 43
48859: PUSH
48860: LD_INT 25
48862: PUSH
48863: EMPTY
48864: LIST
48865: LIST
48866: LIST
48867: IN
48868: IFFALSE 48889
// points := [ 40 , 15 , 5 ] ;
48870: LD_ADDR_VAR 0 9
48874: PUSH
48875: LD_INT 40
48877: PUSH
48878: LD_INT 15
48880: PUSH
48881: LD_INT 5
48883: PUSH
48884: EMPTY
48885: LIST
48886: LIST
48887: LIST
48888: ST_TO_ADDR
// if GetWeapon ( i ) in [ us_light_gun , ar_light_gun ] then
48889: LD_VAR 0 6
48893: PPUSH
48894: CALL_OW 264
48898: PUSH
48899: LD_INT 3
48901: PUSH
48902: LD_INT 23
48904: PUSH
48905: EMPTY
48906: LIST
48907: LIST
48908: IN
48909: IFFALSE 48930
// points := [ 7 , 25 , 8 ] ;
48911: LD_ADDR_VAR 0 9
48915: PUSH
48916: LD_INT 7
48918: PUSH
48919: LD_INT 25
48921: PUSH
48922: LD_INT 8
48924: PUSH
48925: EMPTY
48926: LIST
48927: LIST
48928: LIST
48929: ST_TO_ADDR
// if GetWeapon ( i ) in [ us_double_gun , ar_gun , ru_gun ] then
48930: LD_VAR 0 6
48934: PPUSH
48935: CALL_OW 264
48939: PUSH
48940: LD_INT 5
48942: PUSH
48943: LD_INT 27
48945: PUSH
48946: LD_INT 44
48948: PUSH
48949: EMPTY
48950: LIST
48951: LIST
48952: LIST
48953: IN
48954: IFFALSE 48975
// points := [ 14 , 50 , 16 ] ;
48956: LD_ADDR_VAR 0 9
48960: PUSH
48961: LD_INT 14
48963: PUSH
48964: LD_INT 50
48966: PUSH
48967: LD_INT 16
48969: PUSH
48970: EMPTY
48971: LIST
48972: LIST
48973: LIST
48974: ST_TO_ADDR
// if GetWeapon ( i ) in [ us_heavy_gun , ru_heavy_gun ] then
48975: LD_VAR 0 6
48979: PPUSH
48980: CALL_OW 264
48984: PUSH
48985: LD_INT 6
48987: PUSH
48988: LD_INT 46
48990: PUSH
48991: EMPTY
48992: LIST
48993: LIST
48994: IN
48995: IFFALSE 49016
// points := [ 32 , 120 , 70 ] ;
48997: LD_ADDR_VAR 0 9
49001: PUSH
49002: LD_INT 32
49004: PUSH
49005: LD_INT 120
49007: PUSH
49008: LD_INT 70
49010: PUSH
49011: EMPTY
49012: LIST
49013: LIST
49014: LIST
49015: ST_TO_ADDR
// if GetWeapon ( i ) in [ us_rocket_launcher , ar_rocket_launcher , ru_rocket_launcher ] then
49016: LD_VAR 0 6
49020: PPUSH
49021: CALL_OW 264
49025: PUSH
49026: LD_INT 7
49028: PUSH
49029: LD_INT 28
49031: PUSH
49032: LD_INT 45
49034: PUSH
49035: EMPTY
49036: LIST
49037: LIST
49038: LIST
49039: IN
49040: IFFALSE 49061
// points := [ 35 , 20 , 45 ] ;
49042: LD_ADDR_VAR 0 9
49046: PUSH
49047: LD_INT 35
49049: PUSH
49050: LD_INT 20
49052: PUSH
49053: LD_INT 45
49055: PUSH
49056: EMPTY
49057: LIST
49058: LIST
49059: LIST
49060: ST_TO_ADDR
// if GetWeapon ( i ) in [ ru_rocket ] then
49061: LD_VAR 0 6
49065: PPUSH
49066: CALL_OW 264
49070: PUSH
49071: LD_INT 47
49073: PUSH
49074: EMPTY
49075: LIST
49076: IN
49077: IFFALSE 49098
// points := [ 67 , 45 , 75 ] ;
49079: LD_ADDR_VAR 0 9
49083: PUSH
49084: LD_INT 67
49086: PUSH
49087: LD_INT 45
49089: PUSH
49090: LD_INT 75
49092: PUSH
49093: EMPTY
49094: LIST
49095: LIST
49096: LIST
49097: ST_TO_ADDR
// if GetWeapon ( i ) in [ ar_flame_thrower ] then
49098: LD_VAR 0 6
49102: PPUSH
49103: CALL_OW 264
49107: PUSH
49108: LD_INT 26
49110: PUSH
49111: EMPTY
49112: LIST
49113: IN
49114: IFFALSE 49135
// points := [ 120 , 30 , 80 ] ;
49116: LD_ADDR_VAR 0 9
49120: PUSH
49121: LD_INT 120
49123: PUSH
49124: LD_INT 30
49126: PUSH
49127: LD_INT 80
49129: PUSH
49130: EMPTY
49131: LIST
49132: LIST
49133: LIST
49134: ST_TO_ADDR
// if GetWeapon ( i ) in [ ar_multimissile_ballista ] then
49135: LD_VAR 0 6
49139: PPUSH
49140: CALL_OW 264
49144: PUSH
49145: LD_INT 22
49147: PUSH
49148: EMPTY
49149: LIST
49150: IN
49151: IFFALSE 49172
// points := [ 40 , 1 , 1 ] ;
49153: LD_ADDR_VAR 0 9
49157: PUSH
49158: LD_INT 40
49160: PUSH
49161: LD_INT 1
49163: PUSH
49164: LD_INT 1
49166: PUSH
49167: EMPTY
49168: LIST
49169: LIST
49170: LIST
49171: ST_TO_ADDR
// if GetWeapon ( i ) in [ ar_selfpropelled_bomb ] then
49172: LD_VAR 0 6
49176: PPUSH
49177: CALL_OW 264
49181: PUSH
49182: LD_INT 29
49184: PUSH
49185: EMPTY
49186: LIST
49187: IN
49188: IFFALSE 49209
// points := [ 70 , 200 , 400 ] ;
49190: LD_ADDR_VAR 0 9
49194: PUSH
49195: LD_INT 70
49197: PUSH
49198: LD_INT 200
49200: PUSH
49201: LD_INT 400
49203: PUSH
49204: EMPTY
49205: LIST
49206: LIST
49207: LIST
49208: ST_TO_ADDR
// if GetWeapon ( i ) in [ us_bulldozer , ru_bulldozer ] then
49209: LD_VAR 0 6
49213: PPUSH
49214: CALL_OW 264
49218: PUSH
49219: LD_INT 14
49221: PUSH
49222: LD_INT 53
49224: PUSH
49225: EMPTY
49226: LIST
49227: LIST
49228: IN
49229: IFFALSE 49250
// points := [ 40 , 10 , 20 ] ;
49231: LD_ADDR_VAR 0 9
49235: PUSH
49236: LD_INT 40
49238: PUSH
49239: LD_INT 10
49241: PUSH
49242: LD_INT 20
49244: PUSH
49245: EMPTY
49246: LIST
49247: LIST
49248: LIST
49249: ST_TO_ADDR
// if GetWeapon ( i ) in [ us_laser ] then
49250: LD_VAR 0 6
49254: PPUSH
49255: CALL_OW 264
49259: PUSH
49260: LD_INT 9
49262: PUSH
49263: EMPTY
49264: LIST
49265: IN
49266: IFFALSE 49287
// points := [ 5 , 70 , 20 ] ;
49268: LD_ADDR_VAR 0 9
49272: PUSH
49273: LD_INT 5
49275: PUSH
49276: LD_INT 70
49278: PUSH
49279: LD_INT 20
49281: PUSH
49282: EMPTY
49283: LIST
49284: LIST
49285: LIST
49286: ST_TO_ADDR
// if GetWeapon ( i ) in [ us_double_laser ] then
49287: LD_VAR 0 6
49291: PPUSH
49292: CALL_OW 264
49296: PUSH
49297: LD_INT 10
49299: PUSH
49300: EMPTY
49301: LIST
49302: IN
49303: IFFALSE 49324
// points := [ 35 , 110 , 70 ] ;
49305: LD_ADDR_VAR 0 9
49309: PUSH
49310: LD_INT 35
49312: PUSH
49313: LD_INT 110
49315: PUSH
49316: LD_INT 70
49318: PUSH
49319: EMPTY
49320: LIST
49321: LIST
49322: LIST
49323: ST_TO_ADDR
// if GetChassis ( i ) = 25 then
49324: LD_VAR 0 6
49328: PPUSH
49329: CALL_OW 265
49333: PUSH
49334: LD_INT 25
49336: EQUAL
49337: IFFALSE 49358
// points := [ 80 , 65 , 100 ] ;
49339: LD_ADDR_VAR 0 9
49343: PUSH
49344: LD_INT 80
49346: PUSH
49347: LD_INT 65
49349: PUSH
49350: LD_INT 100
49352: PUSH
49353: EMPTY
49354: LIST
49355: LIST
49356: LIST
49357: ST_TO_ADDR
// if GetControl ( i ) = control_manual then
49358: LD_VAR 0 6
49362: PPUSH
49363: CALL_OW 263
49367: PUSH
49368: LD_INT 1
49370: EQUAL
49371: IFFALSE 49406
// bpoints := bpoints * ( GetSkill ( IsDrivenBy ( i ) , 3 ) * 4 ) ;
49373: LD_ADDR_VAR 0 10
49377: PUSH
49378: LD_VAR 0 10
49382: PUSH
49383: LD_VAR 0 6
49387: PPUSH
49388: CALL_OW 311
49392: PPUSH
49393: LD_INT 3
49395: PPUSH
49396: CALL_OW 259
49400: PUSH
49401: LD_INT 4
49403: MUL
49404: MUL
49405: ST_TO_ADDR
// if GetControl ( i ) = control_remote then
49406: LD_VAR 0 6
49410: PPUSH
49411: CALL_OW 263
49415: PUSH
49416: LD_INT 2
49418: EQUAL
49419: IFFALSE 49470
// begin j := IsControledBy ( i ) ;
49421: LD_ADDR_VAR 0 7
49425: PUSH
49426: LD_VAR 0 6
49430: PPUSH
49431: CALL_OW 312
49435: ST_TO_ADDR
// if j then
49436: LD_VAR 0 7
49440: IFFALSE 49470
// bpoints := bpoints * ( GetSkill ( j , 3 ) * 3 ) ;
49442: LD_ADDR_VAR 0 10
49446: PUSH
49447: LD_VAR 0 10
49451: PUSH
49452: LD_VAR 0 7
49456: PPUSH
49457: LD_INT 3
49459: PPUSH
49460: CALL_OW 259
49464: PUSH
49465: LD_INT 3
49467: MUL
49468: MUL
49469: ST_TO_ADDR
// end ; if GetWeapon ( i ) in [ us_double_gun , us_heavy_gun , ru_heavy_gun , ru_gun , ru_rocket , ru_rocket_launcher , ar_rocket_launcher , us_rocket_launcher , ar_gun , ar_selfpropelled_bomb ] and GetTech ( side , tech_weap2 ) = state_researched then
49470: LD_VAR 0 6
49474: PPUSH
49475: CALL_OW 264
49479: PUSH
49480: LD_INT 5
49482: PUSH
49483: LD_INT 6
49485: PUSH
49486: LD_INT 46
49488: PUSH
49489: LD_INT 44
49491: PUSH
49492: LD_INT 47
49494: PUSH
49495: LD_INT 45
49497: PUSH
49498: LD_INT 28
49500: PUSH
49501: LD_INT 7
49503: PUSH
49504: LD_INT 27
49506: PUSH
49507: LD_INT 29
49509: PUSH
49510: EMPTY
49511: LIST
49512: LIST
49513: LIST
49514: LIST
49515: LIST
49516: LIST
49517: LIST
49518: LIST
49519: LIST
49520: LIST
49521: IN
49522: PUSH
49523: LD_VAR 0 1
49527: PPUSH
49528: LD_INT 52
49530: PPUSH
49531: CALL_OW 321
49535: PUSH
49536: LD_INT 2
49538: EQUAL
49539: AND
49540: IFFALSE 49557
// bpoints := bpoints * 1.2 ;
49542: LD_ADDR_VAR 0 10
49546: PUSH
49547: LD_VAR 0 10
49551: PUSH
49552: LD_REAL  1.20000000000000E+0000
49555: MUL
49556: ST_TO_ADDR
// if GetWeapon ( i ) in [ us_heavy_gun , ru_heavy_gun , ru_rocket ] then
49557: LD_VAR 0 6
49561: PPUSH
49562: CALL_OW 264
49566: PUSH
49567: LD_INT 6
49569: PUSH
49570: LD_INT 46
49572: PUSH
49573: LD_INT 47
49575: PUSH
49576: EMPTY
49577: LIST
49578: LIST
49579: LIST
49580: IN
49581: IFFALSE 49598
// bpoints := bpoints * 1.2 ;
49583: LD_ADDR_VAR 0 10
49587: PUSH
49588: LD_VAR 0 10
49592: PUSH
49593: LD_REAL  1.20000000000000E+0000
49596: MUL
49597: ST_TO_ADDR
// end ; unit_building :
49598: GO 49612
49600: LD_INT 3
49602: DOUBLE
49603: EQUAL
49604: IFTRUE 49608
49606: GO 49611
49608: POP
// ; end ;
49609: GO 49612
49611: POP
// for j = 1 to 3 do
49612: LD_ADDR_VAR 0 7
49616: PUSH
49617: DOUBLE
49618: LD_INT 1
49620: DEC
49621: ST_TO_ADDR
49622: LD_INT 3
49624: PUSH
49625: FOR_TO
49626: IFFALSE 49679
// result := Replace ( result , j , result [ j ] + ( points [ j ] * bpoints ) ) ;
49628: LD_ADDR_VAR 0 5
49632: PUSH
49633: LD_VAR 0 5
49637: PPUSH
49638: LD_VAR 0 7
49642: PPUSH
49643: LD_VAR 0 5
49647: PUSH
49648: LD_VAR 0 7
49652: ARRAY
49653: PUSH
49654: LD_VAR 0 9
49658: PUSH
49659: LD_VAR 0 7
49663: ARRAY
49664: PUSH
49665: LD_VAR 0 10
49669: MUL
49670: PLUS
49671: PPUSH
49672: CALL_OW 1
49676: ST_TO_ADDR
49677: GO 49625
49679: POP
49680: POP
// end ;
49681: GO 48164
49683: POP
49684: POP
// result := Replace ( result , 4 , tmp ) ;
49685: LD_ADDR_VAR 0 5
49689: PUSH
49690: LD_VAR 0 5
49694: PPUSH
49695: LD_INT 4
49697: PPUSH
49698: LD_VAR 0 8
49702: PPUSH
49703: CALL_OW 1
49707: ST_TO_ADDR
// end ;
49708: LD_VAR 0 5
49712: RET
// export function DangerAtRange ( unit , range ) ; begin
49713: LD_INT 0
49715: PPUSH
// result := DangerAtRangeXY ( GetSide ( unit ) , GetX ( unit ) , GetY ( unit ) , range ) ;
49716: LD_ADDR_VAR 0 3
49720: PUSH
49721: LD_VAR 0 1
49725: PPUSH
49726: CALL_OW 255
49730: PPUSH
49731: LD_VAR 0 1
49735: PPUSH
49736: CALL_OW 250
49740: PPUSH
49741: LD_VAR 0 1
49745: PPUSH
49746: CALL_OW 251
49750: PPUSH
49751: LD_VAR 0 2
49755: PPUSH
49756: CALL 48016 0 4
49760: ST_TO_ADDR
// end ;
49761: LD_VAR 0 3
49765: RET
// export function DangerInArea ( side , area ) ; begin
49766: LD_INT 0
49768: PPUSH
// result := FilterUnitsInArea ( area , [ f_enemy , side ] ) ;
49769: LD_ADDR_VAR 0 3
49773: PUSH
49774: LD_VAR 0 2
49778: PPUSH
49779: LD_INT 81
49781: PUSH
49782: LD_VAR 0 1
49786: PUSH
49787: EMPTY
49788: LIST
49789: LIST
49790: PPUSH
49791: CALL_OW 70
49795: ST_TO_ADDR
// end ;
49796: LD_VAR 0 3
49800: RET
// export function IsExtension ( b ) ; begin
49801: LD_INT 0
49803: PPUSH
// result := b in [ b_ext_stitch , b_ext_radar , b_ext_radio , b_ext_gun , b_ext_computer , b_ext_siberium , b_ext_noncombat , b_ext_track , b_ext_laser , b_ext_rocket ] ;
49804: LD_ADDR_VAR 0 2
49808: PUSH
49809: LD_VAR 0 1
49813: PUSH
49814: LD_INT 23
49816: PUSH
49817: LD_INT 20
49819: PUSH
49820: LD_INT 22
49822: PUSH
49823: LD_INT 17
49825: PUSH
49826: LD_INT 24
49828: PUSH
49829: LD_INT 21
49831: PUSH
49832: LD_INT 19
49834: PUSH
49835: LD_INT 16
49837: PUSH
49838: LD_INT 25
49840: PUSH
49841: LD_INT 18
49843: PUSH
49844: EMPTY
49845: LIST
49846: LIST
49847: LIST
49848: LIST
49849: LIST
49850: LIST
49851: LIST
49852: LIST
49853: LIST
49854: LIST
49855: IN
49856: ST_TO_ADDR
// end ;
49857: LD_VAR 0 2
49861: RET
// export function GetBaseBuildings ( base , area ) ; var tmp , i ; begin
49862: LD_INT 0
49864: PPUSH
49865: PPUSH
49866: PPUSH
// result := [ ] ;
49867: LD_ADDR_VAR 0 3
49871: PUSH
49872: EMPTY
49873: ST_TO_ADDR
// tmp := FilterUnitsInArea ( area , [ f_type , unit_building ] ) ;
49874: LD_ADDR_VAR 0 4
49878: PUSH
49879: LD_VAR 0 2
49883: PPUSH
49884: LD_INT 21
49886: PUSH
49887: LD_INT 3
49889: PUSH
49890: EMPTY
49891: LIST
49892: LIST
49893: PPUSH
49894: CALL_OW 70
49898: ST_TO_ADDR
// if not tmp then
49899: LD_VAR 0 4
49903: NOT
49904: IFFALSE 49908
// exit ;
49906: GO 49966
// for i in tmp do
49908: LD_ADDR_VAR 0 5
49912: PUSH
49913: LD_VAR 0 4
49917: PUSH
49918: FOR_IN
49919: IFFALSE 49954
// if GetBase ( i ) <> base then
49921: LD_VAR 0 5
49925: PPUSH
49926: CALL_OW 274
49930: PUSH
49931: LD_VAR 0 1
49935: NONEQUAL
49936: IFFALSE 49952
// ComLinkToBase ( base , i ) ;
49938: LD_VAR 0 1
49942: PPUSH
49943: LD_VAR 0 5
49947: PPUSH
49948: CALL_OW 169
49952: GO 49918
49954: POP
49955: POP
// result := tmp ;
49956: LD_ADDR_VAR 0 3
49960: PUSH
49961: LD_VAR 0 4
49965: ST_TO_ADDR
// end ;
49966: LD_VAR 0 3
49970: RET
// export function ComComplete ( unit , b ) ; var i ; begin
49971: LD_INT 0
49973: PPUSH
49974: PPUSH
// if BuildingStatus ( b ) = bs_build then
49975: LD_VAR 0 2
49979: PPUSH
49980: CALL_OW 461
49984: PUSH
49985: LD_INT 1
49987: EQUAL
49988: IFFALSE 50048
// SetTaskList ( unit , [ [ h , GetX ( b ) , GetY ( b ) , b , 0 , 0 , 0 ] ] ) ;
49990: LD_VAR 0 1
49994: PPUSH
49995: LD_STRING h
49997: PUSH
49998: LD_VAR 0 2
50002: PPUSH
50003: CALL_OW 250
50007: PUSH
50008: LD_VAR 0 2
50012: PPUSH
50013: CALL_OW 251
50017: PUSH
50018: LD_VAR 0 2
50022: PUSH
50023: LD_INT 0
50025: PUSH
50026: LD_INT 0
50028: PUSH
50029: LD_INT 0
50031: PUSH
50032: EMPTY
50033: LIST
50034: LIST
50035: LIST
50036: LIST
50037: LIST
50038: LIST
50039: LIST
50040: PUSH
50041: EMPTY
50042: LIST
50043: PPUSH
50044: CALL_OW 446
// end ;
50048: LD_VAR 0 3
50052: RET
// export function Connect ( vehicle ) ; var i , t , mech , tmp , j ; begin
50053: LD_INT 0
50055: PPUSH
50056: PPUSH
50057: PPUSH
50058: PPUSH
50059: PPUSH
50060: PPUSH
// if not vehicle or not GetControl ( vehicle ) = control_remote then
50061: LD_VAR 0 1
50065: NOT
50066: PUSH
50067: LD_VAR 0 1
50071: PPUSH
50072: CALL_OW 263
50076: PUSH
50077: LD_INT 2
50079: EQUAL
50080: NOT
50081: OR
50082: IFFALSE 50086
// exit ;
50084: GO 50402
// tmp := FilterAllUnits ( [ [ f_side , GetSide ( vehicle ) ] , [ f_or , [ f_btype , b_control_tower ] , [ f_weapon , ar_control_tower ] ] ] ) ;
50086: LD_ADDR_VAR 0 6
50090: PUSH
50091: LD_INT 22
50093: PUSH
50094: LD_VAR 0 1
50098: PPUSH
50099: CALL_OW 255
50103: PUSH
50104: EMPTY
50105: LIST
50106: LIST
50107: PUSH
50108: LD_INT 2
50110: PUSH
50111: LD_INT 30
50113: PUSH
50114: LD_INT 36
50116: PUSH
50117: EMPTY
50118: LIST
50119: LIST
50120: PUSH
50121: LD_INT 34
50123: PUSH
50124: LD_INT 31
50126: PUSH
50127: EMPTY
50128: LIST
50129: LIST
50130: PUSH
50131: EMPTY
50132: LIST
50133: LIST
50134: LIST
50135: PUSH
50136: EMPTY
50137: LIST
50138: LIST
50139: PPUSH
50140: CALL_OW 69
50144: ST_TO_ADDR
// if not tmp then
50145: LD_VAR 0 6
50149: NOT
50150: IFFALSE 50154
// exit ;
50152: GO 50402
// result := [ ] ;
50154: LD_ADDR_VAR 0 2
50158: PUSH
50159: EMPTY
50160: ST_TO_ADDR
// for i in tmp do
50161: LD_ADDR_VAR 0 3
50165: PUSH
50166: LD_VAR 0 6
50170: PUSH
50171: FOR_IN
50172: IFFALSE 50243
// begin t := UnitsInside ( i ) ;
50174: LD_ADDR_VAR 0 4
50178: PUSH
50179: LD_VAR 0 3
50183: PPUSH
50184: CALL_OW 313
50188: ST_TO_ADDR
// if t then
50189: LD_VAR 0 4
50193: IFFALSE 50241
// for j in t do
50195: LD_ADDR_VAR 0 7
50199: PUSH
50200: LD_VAR 0 4
50204: PUSH
50205: FOR_IN
50206: IFFALSE 50239
// result := Insert ( result , result + 1 , j ) ;
50208: LD_ADDR_VAR 0 2
50212: PUSH
50213: LD_VAR 0 2
50217: PPUSH
50218: LD_VAR 0 2
50222: PUSH
50223: LD_INT 1
50225: PLUS
50226: PPUSH
50227: LD_VAR 0 7
50231: PPUSH
50232: CALL_OW 2
50236: ST_TO_ADDR
50237: GO 50205
50239: POP
50240: POP
// end ;
50241: GO 50171
50243: POP
50244: POP
// if not result then
50245: LD_VAR 0 2
50249: NOT
50250: IFFALSE 50254
// exit ;
50252: GO 50402
// mech := result [ 1 ] ;
50254: LD_ADDR_VAR 0 5
50258: PUSH
50259: LD_VAR 0 2
50263: PUSH
50264: LD_INT 1
50266: ARRAY
50267: ST_TO_ADDR
// if result > 1 then
50268: LD_VAR 0 2
50272: PUSH
50273: LD_INT 1
50275: GREATER
50276: IFFALSE 50388
// for i = 2 to result do
50278: LD_ADDR_VAR 0 3
50282: PUSH
50283: DOUBLE
50284: LD_INT 2
50286: DEC
50287: ST_TO_ADDR
50288: LD_VAR 0 2
50292: PUSH
50293: FOR_TO
50294: IFFALSE 50386
// begin t := GetSkill ( result [ i ] , 3 ) - UnitsLinked ( result [ i ] ) ;
50296: LD_ADDR_VAR 0 4
50300: PUSH
50301: LD_VAR 0 2
50305: PUSH
50306: LD_VAR 0 3
50310: ARRAY
50311: PPUSH
50312: LD_INT 3
50314: PPUSH
50315: CALL_OW 259
50319: PUSH
50320: LD_VAR 0 2
50324: PUSH
50325: LD_VAR 0 3
50329: ARRAY
50330: PPUSH
50331: CALL_OW 432
50335: MINUS
50336: ST_TO_ADDR
// if t >= ( GetSkill ( mech , 3 ) - UnitsLinked ( mech ) ) then
50337: LD_VAR 0 4
50341: PUSH
50342: LD_VAR 0 5
50346: PPUSH
50347: LD_INT 3
50349: PPUSH
50350: CALL_OW 259
50354: PUSH
50355: LD_VAR 0 5
50359: PPUSH
50360: CALL_OW 432
50364: MINUS
50365: GREATEREQUAL
50366: IFFALSE 50384
// mech := result [ i ] ;
50368: LD_ADDR_VAR 0 5
50372: PUSH
50373: LD_VAR 0 2
50377: PUSH
50378: LD_VAR 0 3
50382: ARRAY
50383: ST_TO_ADDR
// end ;
50384: GO 50293
50386: POP
50387: POP
// ComLinkTo ( vehicle , mech ) ;
50388: LD_VAR 0 1
50392: PPUSH
50393: LD_VAR 0 5
50397: PPUSH
50398: CALL_OW 135
// end ;
50402: LD_VAR 0 2
50406: RET
// export function PrepareBase ( base_dep , area , name , skill , sources , personel ) ; var i , j , d , b , f , x , un , base , side , nation , buildings , tmp ; begin
50407: LD_INT 0
50409: PPUSH
50410: PPUSH
50411: PPUSH
50412: PPUSH
50413: PPUSH
50414: PPUSH
50415: PPUSH
50416: PPUSH
50417: PPUSH
50418: PPUSH
50419: PPUSH
50420: PPUSH
50421: PPUSH
// result := [ ] ;
50422: LD_ADDR_VAR 0 7
50426: PUSH
50427: EMPTY
50428: ST_TO_ADDR
// if not GetBType ( base_dep ) in [ b_depot , b_warehouse ] then
50429: LD_VAR 0 1
50433: PPUSH
50434: CALL_OW 266
50438: PUSH
50439: LD_INT 0
50441: PUSH
50442: LD_INT 1
50444: PUSH
50445: EMPTY
50446: LIST
50447: LIST
50448: IN
50449: NOT
50450: IFFALSE 50454
// exit ;
50452: GO 52085
// if name then
50454: LD_VAR 0 3
50458: IFFALSE 50474
// SetBName ( base_dep , name ) ;
50460: LD_VAR 0 1
50464: PPUSH
50465: LD_VAR 0 3
50469: PPUSH
50470: CALL_OW 500
// base := GetBase ( base_dep ) ;
50474: LD_ADDR_VAR 0 15
50478: PUSH
50479: LD_VAR 0 1
50483: PPUSH
50484: CALL_OW 274
50488: ST_TO_ADDR
// side := GetSide ( base_dep ) ;
50489: LD_ADDR_VAR 0 16
50493: PUSH
50494: LD_VAR 0 1
50498: PPUSH
50499: CALL_OW 255
50503: ST_TO_ADDR
// nation := GetNation ( base_dep ) ;
50504: LD_ADDR_VAR 0 17
50508: PUSH
50509: LD_VAR 0 1
50513: PPUSH
50514: CALL_OW 248
50518: ST_TO_ADDR
// if sources then
50519: LD_VAR 0 5
50523: IFFALSE 50570
// for i = 1 to 3 do
50525: LD_ADDR_VAR 0 8
50529: PUSH
50530: DOUBLE
50531: LD_INT 1
50533: DEC
50534: ST_TO_ADDR
50535: LD_INT 3
50537: PUSH
50538: FOR_TO
50539: IFFALSE 50568
// AddResourceType ( base , i , sources [ i ] ) ;
50541: LD_VAR 0 15
50545: PPUSH
50546: LD_VAR 0 8
50550: PPUSH
50551: LD_VAR 0 5
50555: PUSH
50556: LD_VAR 0 8
50560: ARRAY
50561: PPUSH
50562: CALL_OW 276
50566: GO 50538
50568: POP
50569: POP
// buildings := GetBaseBuildings ( base , area ) ;
50570: LD_ADDR_VAR 0 18
50574: PUSH
50575: LD_VAR 0 15
50579: PPUSH
50580: LD_VAR 0 2
50584: PPUSH
50585: CALL 49862 0 2
50589: ST_TO_ADDR
// InitHc ;
50590: CALL_OW 19
// InitUc ;
50594: CALL_OW 18
// uc_side := side ;
50598: LD_ADDR_OWVAR 20
50602: PUSH
50603: LD_VAR 0 16
50607: ST_TO_ADDR
// uc_nation := nation ;
50608: LD_ADDR_OWVAR 21
50612: PUSH
50613: LD_VAR 0 17
50617: ST_TO_ADDR
// if buildings then
50618: LD_VAR 0 18
50622: IFFALSE 51944
// begin tmp := UnitFilter ( buildings , [ f_or , [ f_btype , b_oil_mine ] , [ f_btype , b_siberite_mine ] ] ) ;
50624: LD_ADDR_VAR 0 19
50628: PUSH
50629: LD_VAR 0 18
50633: PPUSH
50634: LD_INT 2
50636: PUSH
50637: LD_INT 30
50639: PUSH
50640: LD_INT 29
50642: PUSH
50643: EMPTY
50644: LIST
50645: LIST
50646: PUSH
50647: LD_INT 30
50649: PUSH
50650: LD_INT 30
50652: PUSH
50653: EMPTY
50654: LIST
50655: LIST
50656: PUSH
50657: EMPTY
50658: LIST
50659: LIST
50660: LIST
50661: PPUSH
50662: CALL_OW 72
50666: ST_TO_ADDR
// if tmp then
50667: LD_VAR 0 19
50671: IFFALSE 50719
// for i in tmp do
50673: LD_ADDR_VAR 0 8
50677: PUSH
50678: LD_VAR 0 19
50682: PUSH
50683: FOR_IN
50684: IFFALSE 50717
// SetResourceVisibility ( GetX ( i ) , GetY ( i ) , side ) ;
50686: LD_VAR 0 8
50690: PPUSH
50691: CALL_OW 250
50695: PPUSH
50696: LD_VAR 0 8
50700: PPUSH
50701: CALL_OW 251
50705: PPUSH
50706: LD_VAR 0 16
50710: PPUSH
50711: CALL_OW 441
50715: GO 50683
50717: POP
50718: POP
// if UnitFilter ( buildings , [ f_or , [ f_btype , b_bunker ] , [ f_btype , b_turret ] ] ) then
50719: LD_VAR 0 18
50723: PPUSH
50724: LD_INT 2
50726: PUSH
50727: LD_INT 30
50729: PUSH
50730: LD_INT 32
50732: PUSH
50733: EMPTY
50734: LIST
50735: LIST
50736: PUSH
50737: LD_INT 30
50739: PUSH
50740: LD_INT 33
50742: PUSH
50743: EMPTY
50744: LIST
50745: LIST
50746: PUSH
50747: EMPTY
50748: LIST
50749: LIST
50750: LIST
50751: PPUSH
50752: CALL_OW 72
50756: IFFALSE 50844
// begin for i in UnitFilter ( buildings , [ f_or , [ f_btype , b_bunker ] , [ f_btype , b_turret ] ] ) do
50758: LD_ADDR_VAR 0 8
50762: PUSH
50763: LD_VAR 0 18
50767: PPUSH
50768: LD_INT 2
50770: PUSH
50771: LD_INT 30
50773: PUSH
50774: LD_INT 32
50776: PUSH
50777: EMPTY
50778: LIST
50779: LIST
50780: PUSH
50781: LD_INT 30
50783: PUSH
50784: LD_INT 33
50786: PUSH
50787: EMPTY
50788: LIST
50789: LIST
50790: PUSH
50791: EMPTY
50792: LIST
50793: LIST
50794: LIST
50795: PPUSH
50796: CALL_OW 72
50800: PUSH
50801: FOR_IN
50802: IFFALSE 50842
// begin if not GetBWeapon ( i ) then
50804: LD_VAR 0 8
50808: PPUSH
50809: CALL_OW 269
50813: NOT
50814: IFFALSE 50840
// PlaceWeaponTurret ( i , GetTurretWeapon ( i , area ) ) ;
50816: LD_VAR 0 8
50820: PPUSH
50821: LD_VAR 0 8
50825: PPUSH
50826: LD_VAR 0 2
50830: PPUSH
50831: CALL 52090 0 2
50835: PPUSH
50836: CALL_OW 431
// end ;
50840: GO 50801
50842: POP
50843: POP
// end ; for i = 1 to personel do
50844: LD_ADDR_VAR 0 8
50848: PUSH
50849: DOUBLE
50850: LD_INT 1
50852: DEC
50853: ST_TO_ADDR
50854: LD_VAR 0 6
50858: PUSH
50859: FOR_TO
50860: IFFALSE 51924
// begin if i > 4 then
50862: LD_VAR 0 8
50866: PUSH
50867: LD_INT 4
50869: GREATER
50870: IFFALSE 50874
// break ;
50872: GO 51924
// case i of 1 :
50874: LD_VAR 0 8
50878: PUSH
50879: LD_INT 1
50881: DOUBLE
50882: EQUAL
50883: IFTRUE 50887
50885: GO 50967
50887: POP
// f := UnitFilter ( buildings , [ [ f_side , side ] , [ f_empty ] , [ f_or , [ f_btype , b_bunker ] , [ f_btype , b_armoury ] , [ f_btype , b_barracks ] ] ] ) ; 2 :
50888: LD_ADDR_VAR 0 12
50892: PUSH
50893: LD_VAR 0 18
50897: PPUSH
50898: LD_INT 22
50900: PUSH
50901: LD_VAR 0 16
50905: PUSH
50906: EMPTY
50907: LIST
50908: LIST
50909: PUSH
50910: LD_INT 58
50912: PUSH
50913: EMPTY
50914: LIST
50915: PUSH
50916: LD_INT 2
50918: PUSH
50919: LD_INT 30
50921: PUSH
50922: LD_INT 32
50924: PUSH
50925: EMPTY
50926: LIST
50927: LIST
50928: PUSH
50929: LD_INT 30
50931: PUSH
50932: LD_INT 4
50934: PUSH
50935: EMPTY
50936: LIST
50937: LIST
50938: PUSH
50939: LD_INT 30
50941: PUSH
50942: LD_INT 5
50944: PUSH
50945: EMPTY
50946: LIST
50947: LIST
50948: PUSH
50949: EMPTY
50950: LIST
50951: LIST
50952: LIST
50953: LIST
50954: PUSH
50955: EMPTY
50956: LIST
50957: LIST
50958: LIST
50959: PPUSH
50960: CALL_OW 72
50964: ST_TO_ADDR
50965: GO 51189
50967: LD_INT 2
50969: DOUBLE
50970: EQUAL
50971: IFTRUE 50975
50973: GO 51037
50975: POP
// f := UnitFilter ( buildings , [ [ f_side , side ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ] ) ; 3 :
50976: LD_ADDR_VAR 0 12
50980: PUSH
50981: LD_VAR 0 18
50985: PPUSH
50986: LD_INT 22
50988: PUSH
50989: LD_VAR 0 16
50993: PUSH
50994: EMPTY
50995: LIST
50996: LIST
50997: PUSH
50998: LD_INT 2
51000: PUSH
51001: LD_INT 30
51003: PUSH
51004: LD_INT 0
51006: PUSH
51007: EMPTY
51008: LIST
51009: LIST
51010: PUSH
51011: LD_INT 30
51013: PUSH
51014: LD_INT 1
51016: PUSH
51017: EMPTY
51018: LIST
51019: LIST
51020: PUSH
51021: EMPTY
51022: LIST
51023: LIST
51024: LIST
51025: PUSH
51026: EMPTY
51027: LIST
51028: LIST
51029: PPUSH
51030: CALL_OW 72
51034: ST_TO_ADDR
51035: GO 51189
51037: LD_INT 3
51039: DOUBLE
51040: EQUAL
51041: IFTRUE 51045
51043: GO 51107
51045: POP
// f := UnitFilter ( buildings , [ [ f_side , side ] , [ f_or , [ f_btype , b_workshop ] , [ f_btype , b_factory ] ] ] ) ; 4 :
51046: LD_ADDR_VAR 0 12
51050: PUSH
51051: LD_VAR 0 18
51055: PPUSH
51056: LD_INT 22
51058: PUSH
51059: LD_VAR 0 16
51063: PUSH
51064: EMPTY
51065: LIST
51066: LIST
51067: PUSH
51068: LD_INT 2
51070: PUSH
51071: LD_INT 30
51073: PUSH
51074: LD_INT 2
51076: PUSH
51077: EMPTY
51078: LIST
51079: LIST
51080: PUSH
51081: LD_INT 30
51083: PUSH
51084: LD_INT 3
51086: PUSH
51087: EMPTY
51088: LIST
51089: LIST
51090: PUSH
51091: EMPTY
51092: LIST
51093: LIST
51094: LIST
51095: PUSH
51096: EMPTY
51097: LIST
51098: LIST
51099: PPUSH
51100: CALL_OW 72
51104: ST_TO_ADDR
51105: GO 51189
51107: LD_INT 4
51109: DOUBLE
51110: EQUAL
51111: IFTRUE 51115
51113: GO 51188
51115: POP
// f := UnitFilter ( buildings , [ [ f_side , side ] , [ f_or , [ f_btype , b_lab ] , [ f_btype , b_lab_half ] , [ f_btype , b_lab_full ] ] ] ) ; end ;
51116: LD_ADDR_VAR 0 12
51120: PUSH
51121: LD_VAR 0 18
51125: PPUSH
51126: LD_INT 22
51128: PUSH
51129: LD_VAR 0 16
51133: PUSH
51134: EMPTY
51135: LIST
51136: LIST
51137: PUSH
51138: LD_INT 2
51140: PUSH
51141: LD_INT 30
51143: PUSH
51144: LD_INT 6
51146: PUSH
51147: EMPTY
51148: LIST
51149: LIST
51150: PUSH
51151: LD_INT 30
51153: PUSH
51154: LD_INT 7
51156: PUSH
51157: EMPTY
51158: LIST
51159: LIST
51160: PUSH
51161: LD_INT 30
51163: PUSH
51164: LD_INT 8
51166: PUSH
51167: EMPTY
51168: LIST
51169: LIST
51170: PUSH
51171: EMPTY
51172: LIST
51173: LIST
51174: LIST
51175: LIST
51176: PUSH
51177: EMPTY
51178: LIST
51179: LIST
51180: PPUSH
51181: CALL_OW 72
51185: ST_TO_ADDR
51186: GO 51189
51188: POP
// if i = 1 then
51189: LD_VAR 0 8
51193: PUSH
51194: LD_INT 1
51196: EQUAL
51197: IFFALSE 51308
// begin tmp := [ ] ;
51199: LD_ADDR_VAR 0 19
51203: PUSH
51204: EMPTY
51205: ST_TO_ADDR
// for j in f do
51206: LD_ADDR_VAR 0 9
51210: PUSH
51211: LD_VAR 0 12
51215: PUSH
51216: FOR_IN
51217: IFFALSE 51290
// if GetBType ( j ) = b_bunker then
51219: LD_VAR 0 9
51223: PPUSH
51224: CALL_OW 266
51228: PUSH
51229: LD_INT 32
51231: EQUAL
51232: IFFALSE 51259
// tmp := Insert ( tmp , 1 , j ) else
51234: LD_ADDR_VAR 0 19
51238: PUSH
51239: LD_VAR 0 19
51243: PPUSH
51244: LD_INT 1
51246: PPUSH
51247: LD_VAR 0 9
51251: PPUSH
51252: CALL_OW 2
51256: ST_TO_ADDR
51257: GO 51288
// tmp := Insert ( tmp , tmp + 1 , j ) ;
51259: LD_ADDR_VAR 0 19
51263: PUSH
51264: LD_VAR 0 19
51268: PPUSH
51269: LD_VAR 0 19
51273: PUSH
51274: LD_INT 1
51276: PLUS
51277: PPUSH
51278: LD_VAR 0 9
51282: PPUSH
51283: CALL_OW 2
51287: ST_TO_ADDR
51288: GO 51216
51290: POP
51291: POP
// if tmp then
51292: LD_VAR 0 19
51296: IFFALSE 51308
// f := tmp ;
51298: LD_ADDR_VAR 0 12
51302: PUSH
51303: LD_VAR 0 19
51307: ST_TO_ADDR
// end ; x := personel [ i ] ;
51308: LD_ADDR_VAR 0 13
51312: PUSH
51313: LD_VAR 0 6
51317: PUSH
51318: LD_VAR 0 8
51322: ARRAY
51323: ST_TO_ADDR
// if x = - 1 then
51324: LD_VAR 0 13
51328: PUSH
51329: LD_INT 1
51331: NEG
51332: EQUAL
51333: IFFALSE 51542
// begin for j in f do
51335: LD_ADDR_VAR 0 9
51339: PUSH
51340: LD_VAR 0 12
51344: PUSH
51345: FOR_IN
51346: IFFALSE 51538
// repeat InitHc ;
51348: CALL_OW 19
// if GetBType ( j ) = b_barracks then
51352: LD_VAR 0 9
51356: PPUSH
51357: CALL_OW 266
51361: PUSH
51362: LD_INT 5
51364: EQUAL
51365: IFFALSE 51435
// begin if UnitsInside ( j ) < 3 then
51367: LD_VAR 0 9
51371: PPUSH
51372: CALL_OW 313
51376: PUSH
51377: LD_INT 3
51379: LESS
51380: IFFALSE 51416
// PrepareHuman ( false , [ class_sniper , class_mortar , class_bazooker ] [ nation ] , skill ) else
51382: LD_INT 0
51384: PPUSH
51385: LD_INT 5
51387: PUSH
51388: LD_INT 8
51390: PUSH
51391: LD_INT 9
51393: PUSH
51394: EMPTY
51395: LIST
51396: LIST
51397: LIST
51398: PUSH
51399: LD_VAR 0 17
51403: ARRAY
51404: PPUSH
51405: LD_VAR 0 4
51409: PPUSH
51410: CALL_OW 380
51414: GO 51433
// PrepareHuman ( false , i , skill ) ;
51416: LD_INT 0
51418: PPUSH
51419: LD_VAR 0 8
51423: PPUSH
51424: LD_VAR 0 4
51428: PPUSH
51429: CALL_OW 380
// end else
51433: GO 51452
// PrepareHuman ( false , i , skill ) ;
51435: LD_INT 0
51437: PPUSH
51438: LD_VAR 0 8
51442: PPUSH
51443: LD_VAR 0 4
51447: PPUSH
51448: CALL_OW 380
// un := CreateHuman ;
51452: LD_ADDR_VAR 0 14
51456: PUSH
51457: CALL_OW 44
51461: ST_TO_ADDR
// result := Insert ( result , 1 , un ) ;
51462: LD_ADDR_VAR 0 7
51466: PUSH
51467: LD_VAR 0 7
51471: PPUSH
51472: LD_INT 1
51474: PPUSH
51475: LD_VAR 0 14
51479: PPUSH
51480: CALL_OW 2
51484: ST_TO_ADDR
// PlaceHumanInUnit ( un , j ) ;
51485: LD_VAR 0 14
51489: PPUSH
51490: LD_VAR 0 9
51494: PPUSH
51495: CALL_OW 52
// until UnitsInside ( j ) = 6 or GetBType ( j ) in [ b_bunker , b_breastwork ] ;
51499: LD_VAR 0 9
51503: PPUSH
51504: CALL_OW 313
51508: PUSH
51509: LD_INT 6
51511: EQUAL
51512: PUSH
51513: LD_VAR 0 9
51517: PPUSH
51518: CALL_OW 266
51522: PUSH
51523: LD_INT 32
51525: PUSH
51526: LD_INT 31
51528: PUSH
51529: EMPTY
51530: LIST
51531: LIST
51532: IN
51533: OR
51534: IFFALSE 51348
51536: GO 51345
51538: POP
51539: POP
// end else
51540: GO 51922
// for j = 1 to x do
51542: LD_ADDR_VAR 0 9
51546: PUSH
51547: DOUBLE
51548: LD_INT 1
51550: DEC
51551: ST_TO_ADDR
51552: LD_VAR 0 13
51556: PUSH
51557: FOR_TO
51558: IFFALSE 51920
// begin InitHc ;
51560: CALL_OW 19
// if not f then
51564: LD_VAR 0 12
51568: NOT
51569: IFFALSE 51658
// begin PrepareHuman ( false , i , skill ) ;
51571: LD_INT 0
51573: PPUSH
51574: LD_VAR 0 8
51578: PPUSH
51579: LD_VAR 0 4
51583: PPUSH
51584: CALL_OW 380
// un := CreateHuman ;
51588: LD_ADDR_VAR 0 14
51592: PUSH
51593: CALL_OW 44
51597: ST_TO_ADDR
// result := Insert ( result , 1 , un ) ;
51598: LD_ADDR_VAR 0 7
51602: PUSH
51603: LD_VAR 0 7
51607: PPUSH
51608: LD_INT 1
51610: PPUSH
51611: LD_VAR 0 14
51615: PPUSH
51616: CALL_OW 2
51620: ST_TO_ADDR
// PlaceUnitXYR ( un , GetX ( base_dep ) , GetY ( base_dep ) , 10 , false ) ;
51621: LD_VAR 0 14
51625: PPUSH
51626: LD_VAR 0 1
51630: PPUSH
51631: CALL_OW 250
51635: PPUSH
51636: LD_VAR 0 1
51640: PPUSH
51641: CALL_OW 251
51645: PPUSH
51646: LD_INT 10
51648: PPUSH
51649: LD_INT 0
51651: PPUSH
51652: CALL_OW 50
// continue ;
51656: GO 51557
// end ; if ( UnitsInside ( f [ 1 ] ) and GetBType ( f [ 1 ] ) in [ b_bunker , b_breastwork ] ) or ( UnitsInside ( f [ 1 ] ) = 6 ) then
51658: LD_VAR 0 12
51662: PUSH
51663: LD_INT 1
51665: ARRAY
51666: PPUSH
51667: CALL_OW 313
51671: PUSH
51672: LD_VAR 0 12
51676: PUSH
51677: LD_INT 1
51679: ARRAY
51680: PPUSH
51681: CALL_OW 266
51685: PUSH
51686: LD_INT 32
51688: PUSH
51689: LD_INT 31
51691: PUSH
51692: EMPTY
51693: LIST
51694: LIST
51695: IN
51696: AND
51697: PUSH
51698: LD_VAR 0 12
51702: PUSH
51703: LD_INT 1
51705: ARRAY
51706: PPUSH
51707: CALL_OW 313
51711: PUSH
51712: LD_INT 6
51714: EQUAL
51715: OR
51716: IFFALSE 51736
// f := Delete ( f , 1 ) ;
51718: LD_ADDR_VAR 0 12
51722: PUSH
51723: LD_VAR 0 12
51727: PPUSH
51728: LD_INT 1
51730: PPUSH
51731: CALL_OW 3
51735: ST_TO_ADDR
// if not f then
51736: LD_VAR 0 12
51740: NOT
51741: IFFALSE 51759
// begin x := x + 2 ;
51743: LD_ADDR_VAR 0 13
51747: PUSH
51748: LD_VAR 0 13
51752: PUSH
51753: LD_INT 2
51755: PLUS
51756: ST_TO_ADDR
// continue ;
51757: GO 51557
// end ; if GetBType ( f [ 1 ] ) = b_barracks then
51759: LD_VAR 0 12
51763: PUSH
51764: LD_INT 1
51766: ARRAY
51767: PPUSH
51768: CALL_OW 266
51772: PUSH
51773: LD_INT 5
51775: EQUAL
51776: IFFALSE 51850
// begin if UnitsInside ( f [ 1 ] ) < 3 then
51778: LD_VAR 0 12
51782: PUSH
51783: LD_INT 1
51785: ARRAY
51786: PPUSH
51787: CALL_OW 313
51791: PUSH
51792: LD_INT 3
51794: LESS
51795: IFFALSE 51831
// PrepareHuman ( false , [ class_sniper , class_mortar , class_bazooker ] [ nation ] , skill ) else
51797: LD_INT 0
51799: PPUSH
51800: LD_INT 5
51802: PUSH
51803: LD_INT 8
51805: PUSH
51806: LD_INT 9
51808: PUSH
51809: EMPTY
51810: LIST
51811: LIST
51812: LIST
51813: PUSH
51814: LD_VAR 0 17
51818: ARRAY
51819: PPUSH
51820: LD_VAR 0 4
51824: PPUSH
51825: CALL_OW 380
51829: GO 51848
// PrepareHuman ( false , i , skill ) ;
51831: LD_INT 0
51833: PPUSH
51834: LD_VAR 0 8
51838: PPUSH
51839: LD_VAR 0 4
51843: PPUSH
51844: CALL_OW 380
// end else
51848: GO 51867
// PrepareHuman ( false , i , skill ) ;
51850: LD_INT 0
51852: PPUSH
51853: LD_VAR 0 8
51857: PPUSH
51858: LD_VAR 0 4
51862: PPUSH
51863: CALL_OW 380
// un := CreateHuman ;
51867: LD_ADDR_VAR 0 14
51871: PUSH
51872: CALL_OW 44
51876: ST_TO_ADDR
// result := Insert ( result , 1 , un ) ;
51877: LD_ADDR_VAR 0 7
51881: PUSH
51882: LD_VAR 0 7
51886: PPUSH
51887: LD_INT 1
51889: PPUSH
51890: LD_VAR 0 14
51894: PPUSH
51895: CALL_OW 2
51899: ST_TO_ADDR
// PlaceHumanInUnit ( un , f [ 1 ] ) ;
51900: LD_VAR 0 14
51904: PPUSH
51905: LD_VAR 0 12
51909: PUSH
51910: LD_INT 1
51912: ARRAY
51913: PPUSH
51914: CALL_OW 52
// end ;
51918: GO 51557
51920: POP
51921: POP
// end ;
51922: GO 50859
51924: POP
51925: POP
// result := result ^ buildings ;
51926: LD_ADDR_VAR 0 7
51930: PUSH
51931: LD_VAR 0 7
51935: PUSH
51936: LD_VAR 0 18
51940: ADD
51941: ST_TO_ADDR
// end else
51942: GO 52085
// begin for i = 1 to personel do
51944: LD_ADDR_VAR 0 8
51948: PUSH
51949: DOUBLE
51950: LD_INT 1
51952: DEC
51953: ST_TO_ADDR
51954: LD_VAR 0 6
51958: PUSH
51959: FOR_TO
51960: IFFALSE 52083
// begin if i > 4 then
51962: LD_VAR 0 8
51966: PUSH
51967: LD_INT 4
51969: GREATER
51970: IFFALSE 51974
// break ;
51972: GO 52083
// x := personel [ i ] ;
51974: LD_ADDR_VAR 0 13
51978: PUSH
51979: LD_VAR 0 6
51983: PUSH
51984: LD_VAR 0 8
51988: ARRAY
51989: ST_TO_ADDR
// if x = - 1 then
51990: LD_VAR 0 13
51994: PUSH
51995: LD_INT 1
51997: NEG
51998: EQUAL
51999: IFFALSE 52003
// continue ;
52001: GO 51959
// PrepareHuman ( false , i , skill ) ;
52003: LD_INT 0
52005: PPUSH
52006: LD_VAR 0 8
52010: PPUSH
52011: LD_VAR 0 4
52015: PPUSH
52016: CALL_OW 380
// un := CreateHuman ;
52020: LD_ADDR_VAR 0 14
52024: PUSH
52025: CALL_OW 44
52029: ST_TO_ADDR
// PlaceUnitXYR ( un , GetX ( base_dep ) , GetY ( base_dep ) , 10 , false ) ;
52030: LD_VAR 0 14
52034: PPUSH
52035: LD_VAR 0 1
52039: PPUSH
52040: CALL_OW 250
52044: PPUSH
52045: LD_VAR 0 1
52049: PPUSH
52050: CALL_OW 251
52054: PPUSH
52055: LD_INT 10
52057: PPUSH
52058: LD_INT 0
52060: PPUSH
52061: CALL_OW 50
// result := result ^ un ;
52065: LD_ADDR_VAR 0 7
52069: PUSH
52070: LD_VAR 0 7
52074: PUSH
52075: LD_VAR 0 14
52079: ADD
52080: ST_TO_ADDR
// end ;
52081: GO 51959
52083: POP
52084: POP
// end ; end ;
52085: LD_VAR 0 7
52089: RET
// export function GetTurretWeapon ( tower , area ) ; var hex , list , factories , base , i , j , x , y , nat , h , tmp , height , side , fac_list , weapon ; begin
52090: LD_INT 0
52092: PPUSH
52093: PPUSH
52094: PPUSH
52095: PPUSH
52096: PPUSH
52097: PPUSH
52098: PPUSH
52099: PPUSH
52100: PPUSH
52101: PPUSH
52102: PPUSH
52103: PPUSH
52104: PPUSH
52105: PPUSH
52106: PPUSH
52107: PPUSH
// result := false ;
52108: LD_ADDR_VAR 0 3
52112: PUSH
52113: LD_INT 0
52115: ST_TO_ADDR
// if not tower or not GetBType ( tower ) in [ b_bunker , b_turret ] then
52116: LD_VAR 0 1
52120: NOT
52121: PUSH
52122: LD_VAR 0 1
52126: PPUSH
52127: CALL_OW 266
52131: PUSH
52132: LD_INT 32
52134: PUSH
52135: LD_INT 33
52137: PUSH
52138: EMPTY
52139: LIST
52140: LIST
52141: IN
52142: NOT
52143: OR
52144: IFFALSE 52148
// exit ;
52146: GO 53284
// nat := GetNation ( tower ) ;
52148: LD_ADDR_VAR 0 12
52152: PUSH
52153: LD_VAR 0 1
52157: PPUSH
52158: CALL_OW 248
52162: ST_TO_ADDR
// side := GetSide ( tower ) ;
52163: LD_ADDR_VAR 0 16
52167: PUSH
52168: LD_VAR 0 1
52172: PPUSH
52173: CALL_OW 255
52177: ST_TO_ADDR
// x := GetX ( tower ) ;
52178: LD_ADDR_VAR 0 10
52182: PUSH
52183: LD_VAR 0 1
52187: PPUSH
52188: CALL_OW 250
52192: ST_TO_ADDR
// y := GetY ( tower ) ;
52193: LD_ADDR_VAR 0 11
52197: PUSH
52198: LD_VAR 0 1
52202: PPUSH
52203: CALL_OW 251
52207: ST_TO_ADDR
// if not x or not y then
52208: LD_VAR 0 10
52212: NOT
52213: PUSH
52214: LD_VAR 0 11
52218: NOT
52219: OR
52220: IFFALSE 52224
// exit ;
52222: GO 53284
// weapon := 0 ;
52224: LD_ADDR_VAR 0 18
52228: PUSH
52229: LD_INT 0
52231: ST_TO_ADDR
// fac_list := [ ] ;
52232: LD_ADDR_VAR 0 17
52236: PUSH
52237: EMPTY
52238: ST_TO_ADDR
// factories := UnitFilter ( GetBaseBuildings ( GetBase ( tower ) , area ) , [ f_btype , b_factory ] ) ;
52239: LD_ADDR_VAR 0 6
52243: PUSH
52244: LD_VAR 0 1
52248: PPUSH
52249: CALL_OW 274
52253: PPUSH
52254: LD_VAR 0 2
52258: PPUSH
52259: CALL 49862 0 2
52263: PPUSH
52264: LD_INT 30
52266: PUSH
52267: LD_INT 3
52269: PUSH
52270: EMPTY
52271: LIST
52272: LIST
52273: PPUSH
52274: CALL_OW 72
52278: ST_TO_ADDR
// if not factories then
52279: LD_VAR 0 6
52283: NOT
52284: IFFALSE 52288
// exit ;
52286: GO 53284
// for i in factories do
52288: LD_ADDR_VAR 0 8
52292: PUSH
52293: LD_VAR 0 6
52297: PUSH
52298: FOR_IN
52299: IFFALSE 52324
// fac_list := fac_list union AvailableWeaponList ( i ) ;
52301: LD_ADDR_VAR 0 17
52305: PUSH
52306: LD_VAR 0 17
52310: PUSH
52311: LD_VAR 0 8
52315: PPUSH
52316: CALL_OW 478
52320: UNION
52321: ST_TO_ADDR
52322: GO 52298
52324: POP
52325: POP
// if not fac_list then
52326: LD_VAR 0 17
52330: NOT
52331: IFFALSE 52335
// exit ;
52333: GO 53284
// list := [ [ us_gatling_gun , us_double_gun , us_laser , us_double_laser , us_heavy_gun , us_rocket_launcher , us_radar ] , [ ar_gun , ar_rocket_launcher , ar_flame_thrower , ar_radar ] , [ ru_gatling_gun , ru_gun , ru_heavy_gun , ru_rocket_launcher , ru_rocket , ru_time_lapser ] ] [ nat ] ;
52335: LD_ADDR_VAR 0 5
52339: PUSH
52340: LD_INT 4
52342: PUSH
52343: LD_INT 5
52345: PUSH
52346: LD_INT 9
52348: PUSH
52349: LD_INT 10
52351: PUSH
52352: LD_INT 6
52354: PUSH
52355: LD_INT 7
52357: PUSH
52358: LD_INT 11
52360: PUSH
52361: EMPTY
52362: LIST
52363: LIST
52364: LIST
52365: LIST
52366: LIST
52367: LIST
52368: LIST
52369: PUSH
52370: LD_INT 27
52372: PUSH
52373: LD_INT 28
52375: PUSH
52376: LD_INT 26
52378: PUSH
52379: LD_INT 30
52381: PUSH
52382: EMPTY
52383: LIST
52384: LIST
52385: LIST
52386: LIST
52387: PUSH
52388: LD_INT 43
52390: PUSH
52391: LD_INT 44
52393: PUSH
52394: LD_INT 46
52396: PUSH
52397: LD_INT 45
52399: PUSH
52400: LD_INT 47
52402: PUSH
52403: LD_INT 49
52405: PUSH
52406: EMPTY
52407: LIST
52408: LIST
52409: LIST
52410: LIST
52411: LIST
52412: LIST
52413: PUSH
52414: EMPTY
52415: LIST
52416: LIST
52417: LIST
52418: PUSH
52419: LD_VAR 0 12
52423: ARRAY
52424: ST_TO_ADDR
// for i in list do
52425: LD_ADDR_VAR 0 8
52429: PUSH
52430: LD_VAR 0 5
52434: PUSH
52435: FOR_IN
52436: IFFALSE 52469
// if not i in fac_list then
52438: LD_VAR 0 8
52442: PUSH
52443: LD_VAR 0 17
52447: IN
52448: NOT
52449: IFFALSE 52467
// list := list diff i ;
52451: LD_ADDR_VAR 0 5
52455: PUSH
52456: LD_VAR 0 5
52460: PUSH
52461: LD_VAR 0 8
52465: DIFF
52466: ST_TO_ADDR
52467: GO 52435
52469: POP
52470: POP
// if not list then
52471: LD_VAR 0 5
52475: NOT
52476: IFFALSE 52480
// exit ;
52478: GO 53284
// if nat = nation_russian and ru_time_lapser in list and GetTech ( tech_lapser , side ) = state_researched then
52480: LD_VAR 0 12
52484: PUSH
52485: LD_INT 3
52487: EQUAL
52488: PUSH
52489: LD_INT 49
52491: PUSH
52492: LD_VAR 0 5
52496: IN
52497: AND
52498: PUSH
52499: LD_INT 31
52501: PPUSH
52502: LD_VAR 0 16
52506: PPUSH
52507: CALL_OW 321
52511: PUSH
52512: LD_INT 2
52514: EQUAL
52515: AND
52516: IFFALSE 52576
// begin if not FilterAllUnits ( [ [ f_side , side ] , [ f_bweapon , ru_time_lapser ] , [ f_dist , tower , 10 ] ] ) then
52518: LD_INT 22
52520: PUSH
52521: LD_VAR 0 16
52525: PUSH
52526: EMPTY
52527: LIST
52528: LIST
52529: PUSH
52530: LD_INT 35
52532: PUSH
52533: LD_INT 49
52535: PUSH
52536: EMPTY
52537: LIST
52538: LIST
52539: PUSH
52540: LD_INT 91
52542: PUSH
52543: LD_VAR 0 1
52547: PUSH
52548: LD_INT 10
52550: PUSH
52551: EMPTY
52552: LIST
52553: LIST
52554: LIST
52555: PUSH
52556: EMPTY
52557: LIST
52558: LIST
52559: LIST
52560: PPUSH
52561: CALL_OW 69
52565: NOT
52566: IFFALSE 52576
// weapon := ru_time_lapser ;
52568: LD_ADDR_VAR 0 18
52572: PUSH
52573: LD_INT 49
52575: ST_TO_ADDR
// end ; if nat in [ 1 , 2 ] and ( us_radar in list or ar_radar in list ) and GetTech ( tech_radar , side ) = state_researched then
52576: LD_VAR 0 12
52580: PUSH
52581: LD_INT 1
52583: PUSH
52584: LD_INT 2
52586: PUSH
52587: EMPTY
52588: LIST
52589: LIST
52590: IN
52591: PUSH
52592: LD_INT 11
52594: PUSH
52595: LD_VAR 0 5
52599: IN
52600: PUSH
52601: LD_INT 30
52603: PUSH
52604: LD_VAR 0 5
52608: IN
52609: OR
52610: AND
52611: PUSH
52612: LD_INT 6
52614: PPUSH
52615: LD_VAR 0 16
52619: PPUSH
52620: CALL_OW 321
52624: PUSH
52625: LD_INT 2
52627: EQUAL
52628: AND
52629: IFFALSE 52794
// begin if not FilterAllUnits ( [ [ f_side , side ] , [ f_or , [ f_bweapon , us_radar ] , [ f_bweapon , ar_radar ] ] , [ f_dist , tower , 18 ] ] ) and FilterAllUnits ( [ [ [ f_side , side ] , [ f_or , [ f_btype , b_bunker ] , [ f_btype , b_turret ] ] , [ f_dist , tower , 12 ] ] ] ) > 2 then
52631: LD_INT 22
52633: PUSH
52634: LD_VAR 0 16
52638: PUSH
52639: EMPTY
52640: LIST
52641: LIST
52642: PUSH
52643: LD_INT 2
52645: PUSH
52646: LD_INT 35
52648: PUSH
52649: LD_INT 11
52651: PUSH
52652: EMPTY
52653: LIST
52654: LIST
52655: PUSH
52656: LD_INT 35
52658: PUSH
52659: LD_INT 30
52661: PUSH
52662: EMPTY
52663: LIST
52664: LIST
52665: PUSH
52666: EMPTY
52667: LIST
52668: LIST
52669: LIST
52670: PUSH
52671: LD_INT 91
52673: PUSH
52674: LD_VAR 0 1
52678: PUSH
52679: LD_INT 18
52681: PUSH
52682: EMPTY
52683: LIST
52684: LIST
52685: LIST
52686: PUSH
52687: EMPTY
52688: LIST
52689: LIST
52690: LIST
52691: PPUSH
52692: CALL_OW 69
52696: NOT
52697: PUSH
52698: LD_INT 22
52700: PUSH
52701: LD_VAR 0 16
52705: PUSH
52706: EMPTY
52707: LIST
52708: LIST
52709: PUSH
52710: LD_INT 2
52712: PUSH
52713: LD_INT 30
52715: PUSH
52716: LD_INT 32
52718: PUSH
52719: EMPTY
52720: LIST
52721: LIST
52722: PUSH
52723: LD_INT 30
52725: PUSH
52726: LD_INT 33
52728: PUSH
52729: EMPTY
52730: LIST
52731: LIST
52732: PUSH
52733: EMPTY
52734: LIST
52735: LIST
52736: LIST
52737: PUSH
52738: LD_INT 91
52740: PUSH
52741: LD_VAR 0 1
52745: PUSH
52746: LD_INT 12
52748: PUSH
52749: EMPTY
52750: LIST
52751: LIST
52752: LIST
52753: PUSH
52754: EMPTY
52755: LIST
52756: LIST
52757: LIST
52758: PUSH
52759: EMPTY
52760: LIST
52761: PPUSH
52762: CALL_OW 69
52766: PUSH
52767: LD_INT 2
52769: GREATER
52770: AND
52771: IFFALSE 52794
// weapon := [ us_radar , ar_radar ] [ nat ] ;
52773: LD_ADDR_VAR 0 18
52777: PUSH
52778: LD_INT 11
52780: PUSH
52781: LD_INT 30
52783: PUSH
52784: EMPTY
52785: LIST
52786: LIST
52787: PUSH
52788: LD_VAR 0 12
52792: ARRAY
52793: ST_TO_ADDR
// end ; if not weapon and GetTech ( tech_rocket , side ) = state_researched and ( us_rocket_launcher in list or ar_rocket_launcher in list or ru_rocket_launcher in list ) then
52794: LD_VAR 0 18
52798: NOT
52799: PUSH
52800: LD_INT 40
52802: PPUSH
52803: LD_VAR 0 16
52807: PPUSH
52808: CALL_OW 321
52812: PUSH
52813: LD_INT 2
52815: EQUAL
52816: AND
52817: PUSH
52818: LD_INT 7
52820: PUSH
52821: LD_VAR 0 5
52825: IN
52826: PUSH
52827: LD_INT 28
52829: PUSH
52830: LD_VAR 0 5
52834: IN
52835: OR
52836: PUSH
52837: LD_INT 45
52839: PUSH
52840: LD_VAR 0 5
52844: IN
52845: OR
52846: AND
52847: IFFALSE 53101
// begin hex := GetHexInfo ( x , y ) ;
52849: LD_ADDR_VAR 0 4
52853: PUSH
52854: LD_VAR 0 10
52858: PPUSH
52859: LD_VAR 0 11
52863: PPUSH
52864: CALL_OW 546
52868: ST_TO_ADDR
// if hex [ 1 ] then
52869: LD_VAR 0 4
52873: PUSH
52874: LD_INT 1
52876: ARRAY
52877: IFFALSE 52881
// exit ;
52879: GO 53284
// height := hex [ 2 ] ;
52881: LD_ADDR_VAR 0 15
52885: PUSH
52886: LD_VAR 0 4
52890: PUSH
52891: LD_INT 2
52893: ARRAY
52894: ST_TO_ADDR
// tmp := [ 0 , 2 , 3 , 5 ] ;
52895: LD_ADDR_VAR 0 14
52899: PUSH
52900: LD_INT 0
52902: PUSH
52903: LD_INT 2
52905: PUSH
52906: LD_INT 3
52908: PUSH
52909: LD_INT 5
52911: PUSH
52912: EMPTY
52913: LIST
52914: LIST
52915: LIST
52916: LIST
52917: ST_TO_ADDR
// for i in tmp do
52918: LD_ADDR_VAR 0 8
52922: PUSH
52923: LD_VAR 0 14
52927: PUSH
52928: FOR_IN
52929: IFFALSE 53099
// begin j := [ ShiftX ( x , i , 5 ) , ShiftY ( y , i , 5 ) ] ;
52931: LD_ADDR_VAR 0 9
52935: PUSH
52936: LD_VAR 0 10
52940: PPUSH
52941: LD_VAR 0 8
52945: PPUSH
52946: LD_INT 5
52948: PPUSH
52949: CALL_OW 272
52953: PUSH
52954: LD_VAR 0 11
52958: PPUSH
52959: LD_VAR 0 8
52963: PPUSH
52964: LD_INT 5
52966: PPUSH
52967: CALL_OW 273
52971: PUSH
52972: EMPTY
52973: LIST
52974: LIST
52975: ST_TO_ADDR
// if ValidHex ( j [ 1 ] , j [ 2 ] ) then
52976: LD_VAR 0 9
52980: PUSH
52981: LD_INT 1
52983: ARRAY
52984: PPUSH
52985: LD_VAR 0 9
52989: PUSH
52990: LD_INT 2
52992: ARRAY
52993: PPUSH
52994: CALL_OW 488
52998: IFFALSE 53097
// begin hex := GetHexInfo ( j [ 1 ] , j [ 2 ] ) ;
53000: LD_ADDR_VAR 0 4
53004: PUSH
53005: LD_VAR 0 9
53009: PUSH
53010: LD_INT 1
53012: ARRAY
53013: PPUSH
53014: LD_VAR 0 9
53018: PUSH
53019: LD_INT 2
53021: ARRAY
53022: PPUSH
53023: CALL_OW 546
53027: ST_TO_ADDR
// if hex [ 1 ] then
53028: LD_VAR 0 4
53032: PUSH
53033: LD_INT 1
53035: ARRAY
53036: IFFALSE 53040
// continue ;
53038: GO 52928
// h := hex [ 2 ] ;
53040: LD_ADDR_VAR 0 13
53044: PUSH
53045: LD_VAR 0 4
53049: PUSH
53050: LD_INT 2
53052: ARRAY
53053: ST_TO_ADDR
// if h + 7 < height then
53054: LD_VAR 0 13
53058: PUSH
53059: LD_INT 7
53061: PLUS
53062: PUSH
53063: LD_VAR 0 15
53067: LESS
53068: IFFALSE 53097
// begin weapon := [ us_rocket_launcher , ar_rocket_launcher , ru_rocket_launcher ] [ nat ] ;
53070: LD_ADDR_VAR 0 18
53074: PUSH
53075: LD_INT 7
53077: PUSH
53078: LD_INT 28
53080: PUSH
53081: LD_INT 45
53083: PUSH
53084: EMPTY
53085: LIST
53086: LIST
53087: LIST
53088: PUSH
53089: LD_VAR 0 12
53093: ARRAY
53094: ST_TO_ADDR
// break ;
53095: GO 53099
// end ; end ; end ;
53097: GO 52928
53099: POP
53100: POP
// end ; if not weapon then
53101: LD_VAR 0 18
53105: NOT
53106: IFFALSE 53166
// begin list := list diff [ us_radar , ar_radar , ru_time_lapser ] ;
53108: LD_ADDR_VAR 0 5
53112: PUSH
53113: LD_VAR 0 5
53117: PUSH
53118: LD_INT 11
53120: PUSH
53121: LD_INT 30
53123: PUSH
53124: LD_INT 49
53126: PUSH
53127: EMPTY
53128: LIST
53129: LIST
53130: LIST
53131: DIFF
53132: ST_TO_ADDR
// if not list then
53133: LD_VAR 0 5
53137: NOT
53138: IFFALSE 53142
// exit ;
53140: GO 53284
// weapon := list [ rand ( 1 , list ) ] ;
53142: LD_ADDR_VAR 0 18
53146: PUSH
53147: LD_VAR 0 5
53151: PUSH
53152: LD_INT 1
53154: PPUSH
53155: LD_VAR 0 5
53159: PPUSH
53160: CALL_OW 12
53164: ARRAY
53165: ST_TO_ADDR
// end ; if weapon then
53166: LD_VAR 0 18
53170: IFFALSE 53284
// begin tmp := CostOfWeapon ( weapon ) ;
53172: LD_ADDR_VAR 0 14
53176: PUSH
53177: LD_VAR 0 18
53181: PPUSH
53182: CALL_OW 451
53186: ST_TO_ADDR
// j := GetBase ( tower ) ;
53187: LD_ADDR_VAR 0 9
53191: PUSH
53192: LD_VAR 0 1
53196: PPUSH
53197: CALL_OW 274
53201: ST_TO_ADDR
// if GetResourceType ( j , mat_cans ) >= tmp [ 1 ] and GetResourceType ( j , mat_oil ) >= tmp [ 2 ] and GetResourceType ( j , mat_siberit ) >= tmp [ 3 ] then
53202: LD_VAR 0 9
53206: PPUSH
53207: LD_INT 1
53209: PPUSH
53210: CALL_OW 275
53214: PUSH
53215: LD_VAR 0 14
53219: PUSH
53220: LD_INT 1
53222: ARRAY
53223: GREATEREQUAL
53224: PUSH
53225: LD_VAR 0 9
53229: PPUSH
53230: LD_INT 2
53232: PPUSH
53233: CALL_OW 275
53237: PUSH
53238: LD_VAR 0 14
53242: PUSH
53243: LD_INT 2
53245: ARRAY
53246: GREATEREQUAL
53247: AND
53248: PUSH
53249: LD_VAR 0 9
53253: PPUSH
53254: LD_INT 3
53256: PPUSH
53257: CALL_OW 275
53261: PUSH
53262: LD_VAR 0 14
53266: PUSH
53267: LD_INT 3
53269: ARRAY
53270: GREATEREQUAL
53271: AND
53272: IFFALSE 53284
// result := weapon ;
53274: LD_ADDR_VAR 0 3
53278: PUSH
53279: LD_VAR 0 18
53283: ST_TO_ADDR
// end ; end ;
53284: LD_VAR 0 3
53288: RET
// export function CompareArray ( array1 , array2 ) ; var i ; begin
53289: LD_INT 0
53291: PPUSH
53292: PPUSH
// result := true ;
53293: LD_ADDR_VAR 0 3
53297: PUSH
53298: LD_INT 1
53300: ST_TO_ADDR
// if array1 = array2 then
53301: LD_VAR 0 1
53305: PUSH
53306: LD_VAR 0 2
53310: EQUAL
53311: IFFALSE 53371
// begin for i = 1 to array1 do
53313: LD_ADDR_VAR 0 4
53317: PUSH
53318: DOUBLE
53319: LD_INT 1
53321: DEC
53322: ST_TO_ADDR
53323: LD_VAR 0 1
53327: PUSH
53328: FOR_TO
53329: IFFALSE 53367
// if array1 [ i ] <> array2 [ i ] then
53331: LD_VAR 0 1
53335: PUSH
53336: LD_VAR 0 4
53340: ARRAY
53341: PUSH
53342: LD_VAR 0 2
53346: PUSH
53347: LD_VAR 0 4
53351: ARRAY
53352: NONEQUAL
53353: IFFALSE 53365
// begin result := false ;
53355: LD_ADDR_VAR 0 3
53359: PUSH
53360: LD_INT 0
53362: ST_TO_ADDR
// break ;
53363: GO 53367
// end ;
53365: GO 53328
53367: POP
53368: POP
// end else
53369: GO 53379
// result := false ;
53371: LD_ADDR_VAR 0 3
53375: PUSH
53376: LD_INT 0
53378: ST_TO_ADDR
// end ;
53379: LD_VAR 0 3
53383: RET
// export function VehicleCost ( fac , list ) ; var cost , pom ; begin
53384: LD_INT 0
53386: PPUSH
53387: PPUSH
53388: PPUSH
// pom := GetBase ( fac ) ;
53389: LD_ADDR_VAR 0 5
53393: PUSH
53394: LD_VAR 0 1
53398: PPUSH
53399: CALL_OW 274
53403: ST_TO_ADDR
// cost := CostOfVehicle ( list [ 1 ] , list [ 2 ] , list [ 3 ] , list [ 4 ] ) ;
53404: LD_ADDR_VAR 0 4
53408: PUSH
53409: LD_VAR 0 2
53413: PUSH
53414: LD_INT 1
53416: ARRAY
53417: PPUSH
53418: LD_VAR 0 2
53422: PUSH
53423: LD_INT 2
53425: ARRAY
53426: PPUSH
53427: LD_VAR 0 2
53431: PUSH
53432: LD_INT 3
53434: ARRAY
53435: PPUSH
53436: LD_VAR 0 2
53440: PUSH
53441: LD_INT 4
53443: ARRAY
53444: PPUSH
53445: CALL_OW 449
53449: ST_TO_ADDR
// result := GetResourceType ( pom , mat_cans ) >= cost [ 1 ] and GetResourceType ( pom , mat_oil ) >= cost [ 2 ] and GetResourceType ( pom , mat_siberit ) >= cost [ 3 ] ;
53450: LD_ADDR_VAR 0 3
53454: PUSH
53455: LD_VAR 0 5
53459: PPUSH
53460: LD_INT 1
53462: PPUSH
53463: CALL_OW 275
53467: PUSH
53468: LD_VAR 0 4
53472: PUSH
53473: LD_INT 1
53475: ARRAY
53476: GREATEREQUAL
53477: PUSH
53478: LD_VAR 0 5
53482: PPUSH
53483: LD_INT 2
53485: PPUSH
53486: CALL_OW 275
53490: PUSH
53491: LD_VAR 0 4
53495: PUSH
53496: LD_INT 2
53498: ARRAY
53499: GREATEREQUAL
53500: AND
53501: PUSH
53502: LD_VAR 0 5
53506: PPUSH
53507: LD_INT 3
53509: PPUSH
53510: CALL_OW 275
53514: PUSH
53515: LD_VAR 0 4
53519: PUSH
53520: LD_INT 3
53522: ARRAY
53523: GREATEREQUAL
53524: AND
53525: ST_TO_ADDR
// end ;
53526: LD_VAR 0 3
53530: RET
// export function UpgradeCost ( building ) ; var pom , cost , btype ; begin
53531: LD_INT 0
53533: PPUSH
53534: PPUSH
53535: PPUSH
53536: PPUSH
// pom := GetBase ( building ) ;
53537: LD_ADDR_VAR 0 3
53541: PUSH
53542: LD_VAR 0 1
53546: PPUSH
53547: CALL_OW 274
53551: ST_TO_ADDR
// if not pom then
53552: LD_VAR 0 3
53556: NOT
53557: IFFALSE 53561
// exit ;
53559: GO 53731
// btype := GetBType ( building ) ;
53561: LD_ADDR_VAR 0 5
53565: PUSH
53566: LD_VAR 0 1
53570: PPUSH
53571: CALL_OW 266
53575: ST_TO_ADDR
// if btype = b_armoury then
53576: LD_VAR 0 5
53580: PUSH
53581: LD_INT 4
53583: EQUAL
53584: IFFALSE 53594
// btype := b_barracks ;
53586: LD_ADDR_VAR 0 5
53590: PUSH
53591: LD_INT 5
53593: ST_TO_ADDR
// if btype = b_depot then
53594: LD_VAR 0 5
53598: PUSH
53599: LD_INT 0
53601: EQUAL
53602: IFFALSE 53612
// btype := b_warehouse ;
53604: LD_ADDR_VAR 0 5
53608: PUSH
53609: LD_INT 1
53611: ST_TO_ADDR
// if btype = b_workshop then
53612: LD_VAR 0 5
53616: PUSH
53617: LD_INT 2
53619: EQUAL
53620: IFFALSE 53630
// btype := b_factory ;
53622: LD_ADDR_VAR 0 5
53626: PUSH
53627: LD_INT 3
53629: ST_TO_ADDR
// cost := CostOfBuilding ( btype , GetNation ( building ) ) ;
53630: LD_ADDR_VAR 0 4
53634: PUSH
53635: LD_VAR 0 5
53639: PPUSH
53640: LD_VAR 0 1
53644: PPUSH
53645: CALL_OW 248
53649: PPUSH
53650: CALL_OW 450
53654: ST_TO_ADDR
// result := GetResourceType ( pom , mat_cans ) >= cost [ 1 ] and GetResourceType ( pom , mat_oil ) >= cost [ 2 ] and GetResourceType ( pom , mat_siberit ) >= cost [ 3 ] ;
53655: LD_ADDR_VAR 0 2
53659: PUSH
53660: LD_VAR 0 3
53664: PPUSH
53665: LD_INT 1
53667: PPUSH
53668: CALL_OW 275
53672: PUSH
53673: LD_VAR 0 4
53677: PUSH
53678: LD_INT 1
53680: ARRAY
53681: GREATEREQUAL
53682: PUSH
53683: LD_VAR 0 3
53687: PPUSH
53688: LD_INT 2
53690: PPUSH
53691: CALL_OW 275
53695: PUSH
53696: LD_VAR 0 4
53700: PUSH
53701: LD_INT 2
53703: ARRAY
53704: GREATEREQUAL
53705: AND
53706: PUSH
53707: LD_VAR 0 3
53711: PPUSH
53712: LD_INT 3
53714: PPUSH
53715: CALL_OW 275
53719: PUSH
53720: LD_VAR 0 4
53724: PUSH
53725: LD_INT 3
53727: ARRAY
53728: GREATEREQUAL
53729: AND
53730: ST_TO_ADDR
// end ;
53731: LD_VAR 0 2
53735: RET
// export function UpgradeLabCost ( building , btype ) ; var pom , cost ; begin
53736: LD_INT 0
53738: PPUSH
53739: PPUSH
53740: PPUSH
// pom := GetBase ( building ) ;
53741: LD_ADDR_VAR 0 4
53745: PUSH
53746: LD_VAR 0 1
53750: PPUSH
53751: CALL_OW 274
53755: ST_TO_ADDR
// if not pom then
53756: LD_VAR 0 4
53760: NOT
53761: IFFALSE 53765
// exit ;
53763: GO 53866
// cost := CostOfBuilding ( btype , GetNation ( building ) ) ;
53765: LD_ADDR_VAR 0 5
53769: PUSH
53770: LD_VAR 0 2
53774: PPUSH
53775: LD_VAR 0 1
53779: PPUSH
53780: CALL_OW 248
53784: PPUSH
53785: CALL_OW 450
53789: ST_TO_ADDR
// result := GetResourceType ( pom , mat_cans ) >= cost [ 1 ] and GetResourceType ( pom , mat_oil ) >= cost [ 2 ] and GetResourceType ( pom , mat_siberit ) >= cost [ 3 ] ;
53790: LD_ADDR_VAR 0 3
53794: PUSH
53795: LD_VAR 0 4
53799: PPUSH
53800: LD_INT 1
53802: PPUSH
53803: CALL_OW 275
53807: PUSH
53808: LD_VAR 0 5
53812: PUSH
53813: LD_INT 1
53815: ARRAY
53816: GREATEREQUAL
53817: PUSH
53818: LD_VAR 0 4
53822: PPUSH
53823: LD_INT 2
53825: PPUSH
53826: CALL_OW 275
53830: PUSH
53831: LD_VAR 0 5
53835: PUSH
53836: LD_INT 2
53838: ARRAY
53839: GREATEREQUAL
53840: AND
53841: PUSH
53842: LD_VAR 0 4
53846: PPUSH
53847: LD_INT 3
53849: PPUSH
53850: CALL_OW 275
53854: PUSH
53855: LD_VAR 0 5
53859: PUSH
53860: LD_INT 3
53862: ARRAY
53863: GREATEREQUAL
53864: AND
53865: ST_TO_ADDR
// end ;
53866: LD_VAR 0 3
53870: RET
// export function TryClearPlaceForBuilding ( base , btype , x , y , d ) ; var i , j , _x , _y , tmp , hexes , r , xy , dep ; begin
53871: LD_INT 0
53873: PPUSH
53874: PPUSH
53875: PPUSH
53876: PPUSH
53877: PPUSH
53878: PPUSH
53879: PPUSH
53880: PPUSH
53881: PPUSH
53882: PPUSH
// result := false ;
53883: LD_ADDR_VAR 0 6
53887: PUSH
53888: LD_INT 0
53890: ST_TO_ADDR
// if not base or not btype or not x or not y then
53891: LD_VAR 0 1
53895: NOT
53896: PUSH
53897: LD_VAR 0 2
53901: NOT
53902: OR
53903: PUSH
53904: LD_VAR 0 3
53908: NOT
53909: OR
53910: PUSH
53911: LD_VAR 0 4
53915: NOT
53916: OR
53917: IFFALSE 53921
// exit ;
53919: GO 54530
// hexes := GetBuildingHexes ( btype , x , y , d , GetNation ( base [ 1 ] ) , 0 ) ;
53921: LD_ADDR_VAR 0 12
53925: PUSH
53926: LD_VAR 0 2
53930: PPUSH
53931: LD_VAR 0 3
53935: PPUSH
53936: LD_VAR 0 4
53940: PPUSH
53941: LD_VAR 0 5
53945: PPUSH
53946: LD_VAR 0 1
53950: PUSH
53951: LD_INT 1
53953: ARRAY
53954: PPUSH
53955: CALL_OW 248
53959: PPUSH
53960: LD_INT 0
53962: PPUSH
53963: CALL 55367 0 6
53967: ST_TO_ADDR
// if not hexes then
53968: LD_VAR 0 12
53972: NOT
53973: IFFALSE 53977
// exit ;
53975: GO 54530
// for i = 1 to hexes do
53977: LD_ADDR_VAR 0 7
53981: PUSH
53982: DOUBLE
53983: LD_INT 1
53985: DEC
53986: ST_TO_ADDR
53987: LD_VAR 0 12
53991: PUSH
53992: FOR_TO
53993: IFFALSE 54528
// begin tmp := HexInfo ( hexes [ i ] [ 1 ] , hexes [ i ] [ 2 ] ) ;
53995: LD_ADDR_VAR 0 11
53999: PUSH
54000: LD_VAR 0 12
54004: PUSH
54005: LD_VAR 0 7
54009: ARRAY
54010: PUSH
54011: LD_INT 1
54013: ARRAY
54014: PPUSH
54015: LD_VAR 0 12
54019: PUSH
54020: LD_VAR 0 7
54024: ARRAY
54025: PUSH
54026: LD_INT 2
54028: ARRAY
54029: PPUSH
54030: CALL_OW 428
54034: ST_TO_ADDR
// if IsEnvironment ( hexes [ i ] [ 1 ] , hexes [ i ] [ 2 ] ) or not ValidHex ( hexes [ i ] [ 1 ] , hexes [ i ] [ 2 ] ) or GetType ( tmp ) = unit_building then
54035: LD_VAR 0 12
54039: PUSH
54040: LD_VAR 0 7
54044: ARRAY
54045: PUSH
54046: LD_INT 1
54048: ARRAY
54049: PPUSH
54050: LD_VAR 0 12
54054: PUSH
54055: LD_VAR 0 7
54059: ARRAY
54060: PUSH
54061: LD_INT 2
54063: ARRAY
54064: PPUSH
54065: CALL_OW 351
54069: PUSH
54070: LD_VAR 0 12
54074: PUSH
54075: LD_VAR 0 7
54079: ARRAY
54080: PUSH
54081: LD_INT 1
54083: ARRAY
54084: PPUSH
54085: LD_VAR 0 12
54089: PUSH
54090: LD_VAR 0 7
54094: ARRAY
54095: PUSH
54096: LD_INT 2
54098: ARRAY
54099: PPUSH
54100: CALL_OW 488
54104: NOT
54105: OR
54106: PUSH
54107: LD_VAR 0 11
54111: PPUSH
54112: CALL_OW 247
54116: PUSH
54117: LD_INT 3
54119: EQUAL
54120: OR
54121: IFFALSE 54127
// exit ;
54123: POP
54124: POP
54125: GO 54530
// if not tmp or not tmp in base then
54127: LD_VAR 0 11
54131: NOT
54132: PUSH
54133: LD_VAR 0 11
54137: PUSH
54138: LD_VAR 0 1
54142: IN
54143: NOT
54144: OR
54145: IFFALSE 54149
// continue ;
54147: GO 53992
// result := true ;
54149: LD_ADDR_VAR 0 6
54153: PUSH
54154: LD_INT 1
54156: ST_TO_ADDR
// dep := UnitFilter ( base , [ [ f_side , GetSide ( tmp ) ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ] ) ;
54157: LD_ADDR_VAR 0 15
54161: PUSH
54162: LD_VAR 0 1
54166: PPUSH
54167: LD_INT 22
54169: PUSH
54170: LD_VAR 0 11
54174: PPUSH
54175: CALL_OW 255
54179: PUSH
54180: EMPTY
54181: LIST
54182: LIST
54183: PUSH
54184: LD_INT 2
54186: PUSH
54187: LD_INT 30
54189: PUSH
54190: LD_INT 0
54192: PUSH
54193: EMPTY
54194: LIST
54195: LIST
54196: PUSH
54197: LD_INT 30
54199: PUSH
54200: LD_INT 1
54202: PUSH
54203: EMPTY
54204: LIST
54205: LIST
54206: PUSH
54207: EMPTY
54208: LIST
54209: LIST
54210: LIST
54211: PUSH
54212: EMPTY
54213: LIST
54214: LIST
54215: PPUSH
54216: CALL_OW 72
54220: ST_TO_ADDR
// if dep then
54221: LD_VAR 0 15
54225: IFFALSE 54361
// begin xy := [ ShiftX ( GetX ( dep [ 1 ] ) , GetDir ( dep [ 1 ] ) , 5 ) , ShiftY ( GetY ( dep [ 1 ] ) , GetDir ( dep [ 1 ] ) , 5 ) ] ;
54227: LD_ADDR_VAR 0 14
54231: PUSH
54232: LD_VAR 0 15
54236: PUSH
54237: LD_INT 1
54239: ARRAY
54240: PPUSH
54241: CALL_OW 250
54245: PPUSH
54246: LD_VAR 0 15
54250: PUSH
54251: LD_INT 1
54253: ARRAY
54254: PPUSH
54255: CALL_OW 254
54259: PPUSH
54260: LD_INT 5
54262: PPUSH
54263: CALL_OW 272
54267: PUSH
54268: LD_VAR 0 15
54272: PUSH
54273: LD_INT 1
54275: ARRAY
54276: PPUSH
54277: CALL_OW 251
54281: PPUSH
54282: LD_VAR 0 15
54286: PUSH
54287: LD_INT 1
54289: ARRAY
54290: PPUSH
54291: CALL_OW 254
54295: PPUSH
54296: LD_INT 5
54298: PPUSH
54299: CALL_OW 273
54303: PUSH
54304: EMPTY
54305: LIST
54306: LIST
54307: ST_TO_ADDR
// if ValidHex ( xy [ 1 ] , xy [ 2 ] ) then
54308: LD_VAR 0 14
54312: PUSH
54313: LD_INT 1
54315: ARRAY
54316: PPUSH
54317: LD_VAR 0 14
54321: PUSH
54322: LD_INT 2
54324: ARRAY
54325: PPUSH
54326: CALL_OW 488
54330: IFFALSE 54361
// begin ComMoveXY ( tmp , xy [ 1 ] , xy [ 2 ] ) ;
54332: LD_VAR 0 11
54336: PPUSH
54337: LD_VAR 0 14
54341: PUSH
54342: LD_INT 1
54344: ARRAY
54345: PPUSH
54346: LD_VAR 0 14
54350: PUSH
54351: LD_INT 2
54353: ARRAY
54354: PPUSH
54355: CALL_OW 111
// continue ;
54359: GO 53992
// end ; end ; r := GetDir ( tmp ) ;
54361: LD_ADDR_VAR 0 13
54365: PUSH
54366: LD_VAR 0 11
54370: PPUSH
54371: CALL_OW 254
54375: ST_TO_ADDR
// if r = 5 then
54376: LD_VAR 0 13
54380: PUSH
54381: LD_INT 5
54383: EQUAL
54384: IFFALSE 54394
// r := 0 ;
54386: LD_ADDR_VAR 0 13
54390: PUSH
54391: LD_INT 0
54393: ST_TO_ADDR
// for j = r to 5 do
54394: LD_ADDR_VAR 0 8
54398: PUSH
54399: DOUBLE
54400: LD_VAR 0 13
54404: DEC
54405: ST_TO_ADDR
54406: LD_INT 5
54408: PUSH
54409: FOR_TO
54410: IFFALSE 54524
// begin _x := ShiftX ( GetX ( tmp ) , j , 2 ) ;
54412: LD_ADDR_VAR 0 9
54416: PUSH
54417: LD_VAR 0 11
54421: PPUSH
54422: CALL_OW 250
54426: PPUSH
54427: LD_VAR 0 8
54431: PPUSH
54432: LD_INT 2
54434: PPUSH
54435: CALL_OW 272
54439: ST_TO_ADDR
// _y := ShiftY ( GetY ( tmp ) , j , 2 ) ;
54440: LD_ADDR_VAR 0 10
54444: PUSH
54445: LD_VAR 0 11
54449: PPUSH
54450: CALL_OW 251
54454: PPUSH
54455: LD_VAR 0 8
54459: PPUSH
54460: LD_INT 2
54462: PPUSH
54463: CALL_OW 273
54467: ST_TO_ADDR
// if ValidHex ( _x , _y ) and not HexInfo ( _x , _y ) then
54468: LD_VAR 0 9
54472: PPUSH
54473: LD_VAR 0 10
54477: PPUSH
54478: CALL_OW 488
54482: PUSH
54483: LD_VAR 0 9
54487: PPUSH
54488: LD_VAR 0 10
54492: PPUSH
54493: CALL_OW 428
54497: NOT
54498: AND
54499: IFFALSE 54522
// begin ComMoveXY ( tmp , _x , _y ) ;
54501: LD_VAR 0 11
54505: PPUSH
54506: LD_VAR 0 9
54510: PPUSH
54511: LD_VAR 0 10
54515: PPUSH
54516: CALL_OW 111
// break ;
54520: GO 54524
// end ; end ;
54522: GO 54409
54524: POP
54525: POP
// end ;
54526: GO 53992
54528: POP
54529: POP
// end ;
54530: LD_VAR 0 6
54534: RET
// export function CanBeBuilt ( depot , btype , x , y , d ) ; var i , j , side , pom , cost , hexes , height , dist , hex ; begin
54535: LD_INT 0
54537: PPUSH
54538: PPUSH
54539: PPUSH
54540: PPUSH
54541: PPUSH
54542: PPUSH
54543: PPUSH
54544: PPUSH
54545: PPUSH
54546: PPUSH
// result := false ;
54547: LD_ADDR_VAR 0 6
54551: PUSH
54552: LD_INT 0
54554: ST_TO_ADDR
// if not depot or not GetBType ( depot ) in [ b_depot , b_warehouse ] or not btype or not d in [ 0 , 1 , 2 , 3 , 4 , 5 ] or not ValidHex ( x , y ) then
54555: LD_VAR 0 1
54559: NOT
54560: PUSH
54561: LD_VAR 0 1
54565: PPUSH
54566: CALL_OW 266
54570: PUSH
54571: LD_INT 0
54573: PUSH
54574: LD_INT 1
54576: PUSH
54577: EMPTY
54578: LIST
54579: LIST
54580: IN
54581: NOT
54582: OR
54583: PUSH
54584: LD_VAR 0 2
54588: NOT
54589: OR
54590: PUSH
54591: LD_VAR 0 5
54595: PUSH
54596: LD_INT 0
54598: PUSH
54599: LD_INT 1
54601: PUSH
54602: LD_INT 2
54604: PUSH
54605: LD_INT 3
54607: PUSH
54608: LD_INT 4
54610: PUSH
54611: LD_INT 5
54613: PUSH
54614: EMPTY
54615: LIST
54616: LIST
54617: LIST
54618: LIST
54619: LIST
54620: LIST
54621: IN
54622: NOT
54623: OR
54624: PUSH
54625: LD_VAR 0 3
54629: PPUSH
54630: LD_VAR 0 4
54634: PPUSH
54635: CALL_OW 488
54639: NOT
54640: OR
54641: IFFALSE 54645
// exit ;
54643: GO 55362
// pom := GetBase ( depot ) ;
54645: LD_ADDR_VAR 0 10
54649: PUSH
54650: LD_VAR 0 1
54654: PPUSH
54655: CALL_OW 274
54659: ST_TO_ADDR
// cost := CostOfBuilding ( btype , GetNation ( depot ) ) ;
54660: LD_ADDR_VAR 0 11
54664: PUSH
54665: LD_VAR 0 2
54669: PPUSH
54670: LD_VAR 0 1
54674: PPUSH
54675: CALL_OW 248
54679: PPUSH
54680: CALL_OW 450
54684: ST_TO_ADDR
// if not ( GetResourceType ( pom , mat_cans ) >= cost [ 1 ] and GetResourceType ( pom , mat_oil ) >= cost [ 2 ] and GetResourceType ( pom , mat_siberit ) >= cost [ 3 ] ) then
54685: LD_VAR 0 10
54689: PPUSH
54690: LD_INT 1
54692: PPUSH
54693: CALL_OW 275
54697: PUSH
54698: LD_VAR 0 11
54702: PUSH
54703: LD_INT 1
54705: ARRAY
54706: GREATEREQUAL
54707: PUSH
54708: LD_VAR 0 10
54712: PPUSH
54713: LD_INT 2
54715: PPUSH
54716: CALL_OW 275
54720: PUSH
54721: LD_VAR 0 11
54725: PUSH
54726: LD_INT 2
54728: ARRAY
54729: GREATEREQUAL
54730: AND
54731: PUSH
54732: LD_VAR 0 10
54736: PPUSH
54737: LD_INT 3
54739: PPUSH
54740: CALL_OW 275
54744: PUSH
54745: LD_VAR 0 11
54749: PUSH
54750: LD_INT 3
54752: ARRAY
54753: GREATEREQUAL
54754: AND
54755: NOT
54756: IFFALSE 54760
// exit ;
54758: GO 55362
// if GetBType ( depot ) = b_depot then
54760: LD_VAR 0 1
54764: PPUSH
54765: CALL_OW 266
54769: PUSH
54770: LD_INT 0
54772: EQUAL
54773: IFFALSE 54785
// dist := 28 else
54775: LD_ADDR_VAR 0 14
54779: PUSH
54780: LD_INT 28
54782: ST_TO_ADDR
54783: GO 54793
// dist := 36 ;
54785: LD_ADDR_VAR 0 14
54789: PUSH
54790: LD_INT 36
54792: ST_TO_ADDR
// if GetDistUnitXY ( depot , x , y ) > dist then
54793: LD_VAR 0 1
54797: PPUSH
54798: LD_VAR 0 3
54802: PPUSH
54803: LD_VAR 0 4
54807: PPUSH
54808: CALL_OW 297
54812: PUSH
54813: LD_VAR 0 14
54817: GREATER
54818: IFFALSE 54822
// exit ;
54820: GO 55362
// hexes := GetBuildingHexes ( btype , x , y , d , GetNation ( depot ) , 0 ) ;
54822: LD_ADDR_VAR 0 12
54826: PUSH
54827: LD_VAR 0 2
54831: PPUSH
54832: LD_VAR 0 3
54836: PPUSH
54837: LD_VAR 0 4
54841: PPUSH
54842: LD_VAR 0 5
54846: PPUSH
54847: LD_VAR 0 1
54851: PPUSH
54852: CALL_OW 248
54856: PPUSH
54857: LD_INT 0
54859: PPUSH
54860: CALL 55367 0 6
54864: ST_TO_ADDR
// if not hexes then
54865: LD_VAR 0 12
54869: NOT
54870: IFFALSE 54874
// exit ;
54872: GO 55362
// hex := GetHexInfo ( x , y ) ;
54874: LD_ADDR_VAR 0 15
54878: PUSH
54879: LD_VAR 0 3
54883: PPUSH
54884: LD_VAR 0 4
54888: PPUSH
54889: CALL_OW 546
54893: ST_TO_ADDR
// if hex [ 1 ] then
54894: LD_VAR 0 15
54898: PUSH
54899: LD_INT 1
54901: ARRAY
54902: IFFALSE 54906
// exit ;
54904: GO 55362
// height := hex [ 2 ] ;
54906: LD_ADDR_VAR 0 13
54910: PUSH
54911: LD_VAR 0 15
54915: PUSH
54916: LD_INT 2
54918: ARRAY
54919: ST_TO_ADDR
// for i = 1 to hexes do
54920: LD_ADDR_VAR 0 7
54924: PUSH
54925: DOUBLE
54926: LD_INT 1
54928: DEC
54929: ST_TO_ADDR
54930: LD_VAR 0 12
54934: PUSH
54935: FOR_TO
54936: IFFALSE 55266
// begin if not ValidHex ( hexes [ i ] [ 1 ] , hexes [ i ] [ 2 ] ) or HexInfo ( hexes [ i ] [ 1 ] , hexes [ i ] [ 2 ] ) > 0 or IsEnvironment ( hexes [ i ] [ 1 ] , hexes [ i ] [ 2 ] ) then
54938: LD_VAR 0 12
54942: PUSH
54943: LD_VAR 0 7
54947: ARRAY
54948: PUSH
54949: LD_INT 1
54951: ARRAY
54952: PPUSH
54953: LD_VAR 0 12
54957: PUSH
54958: LD_VAR 0 7
54962: ARRAY
54963: PUSH
54964: LD_INT 2
54966: ARRAY
54967: PPUSH
54968: CALL_OW 488
54972: NOT
54973: PUSH
54974: LD_VAR 0 12
54978: PUSH
54979: LD_VAR 0 7
54983: ARRAY
54984: PUSH
54985: LD_INT 1
54987: ARRAY
54988: PPUSH
54989: LD_VAR 0 12
54993: PUSH
54994: LD_VAR 0 7
54998: ARRAY
54999: PUSH
55000: LD_INT 2
55002: ARRAY
55003: PPUSH
55004: CALL_OW 428
55008: PUSH
55009: LD_INT 0
55011: GREATER
55012: OR
55013: PUSH
55014: LD_VAR 0 12
55018: PUSH
55019: LD_VAR 0 7
55023: ARRAY
55024: PUSH
55025: LD_INT 1
55027: ARRAY
55028: PPUSH
55029: LD_VAR 0 12
55033: PUSH
55034: LD_VAR 0 7
55038: ARRAY
55039: PUSH
55040: LD_INT 2
55042: ARRAY
55043: PPUSH
55044: CALL_OW 351
55048: OR
55049: IFFALSE 55055
// exit ;
55051: POP
55052: POP
55053: GO 55362
// j := GetHexInfo ( hexes [ i ] [ 1 ] , hexes [ i ] [ 2 ] ) ;
55055: LD_ADDR_VAR 0 8
55059: PUSH
55060: LD_VAR 0 12
55064: PUSH
55065: LD_VAR 0 7
55069: ARRAY
55070: PUSH
55071: LD_INT 1
55073: ARRAY
55074: PPUSH
55075: LD_VAR 0 12
55079: PUSH
55080: LD_VAR 0 7
55084: ARRAY
55085: PUSH
55086: LD_INT 2
55088: ARRAY
55089: PPUSH
55090: CALL_OW 546
55094: ST_TO_ADDR
// if j [ 1 ] or j [ 2 ] > height + 2 or j [ 2 ] < height - 2 or not j [ 3 ] in [ 0 , 8 , 9 , 10 , 11 , 12 , 13 , 16 , 17 , 18 , 19 , 20 , 21 ] or not j [ 5 ] or not j [ 6 ] in [ 1 , 2 , 7 , 9 , 10 , 11 ] then
55095: LD_VAR 0 8
55099: PUSH
55100: LD_INT 1
55102: ARRAY
55103: PUSH
55104: LD_VAR 0 8
55108: PUSH
55109: LD_INT 2
55111: ARRAY
55112: PUSH
55113: LD_VAR 0 13
55117: PUSH
55118: LD_INT 2
55120: PLUS
55121: GREATER
55122: OR
55123: PUSH
55124: LD_VAR 0 8
55128: PUSH
55129: LD_INT 2
55131: ARRAY
55132: PUSH
55133: LD_VAR 0 13
55137: PUSH
55138: LD_INT 2
55140: MINUS
55141: LESS
55142: OR
55143: PUSH
55144: LD_VAR 0 8
55148: PUSH
55149: LD_INT 3
55151: ARRAY
55152: PUSH
55153: LD_INT 0
55155: PUSH
55156: LD_INT 8
55158: PUSH
55159: LD_INT 9
55161: PUSH
55162: LD_INT 10
55164: PUSH
55165: LD_INT 11
55167: PUSH
55168: LD_INT 12
55170: PUSH
55171: LD_INT 13
55173: PUSH
55174: LD_INT 16
55176: PUSH
55177: LD_INT 17
55179: PUSH
55180: LD_INT 18
55182: PUSH
55183: LD_INT 19
55185: PUSH
55186: LD_INT 20
55188: PUSH
55189: LD_INT 21
55191: PUSH
55192: EMPTY
55193: LIST
55194: LIST
55195: LIST
55196: LIST
55197: LIST
55198: LIST
55199: LIST
55200: LIST
55201: LIST
55202: LIST
55203: LIST
55204: LIST
55205: LIST
55206: IN
55207: NOT
55208: OR
55209: PUSH
55210: LD_VAR 0 8
55214: PUSH
55215: LD_INT 5
55217: ARRAY
55218: NOT
55219: OR
55220: PUSH
55221: LD_VAR 0 8
55225: PUSH
55226: LD_INT 6
55228: ARRAY
55229: PUSH
55230: LD_INT 1
55232: PUSH
55233: LD_INT 2
55235: PUSH
55236: LD_INT 7
55238: PUSH
55239: LD_INT 9
55241: PUSH
55242: LD_INT 10
55244: PUSH
55245: LD_INT 11
55247: PUSH
55248: EMPTY
55249: LIST
55250: LIST
55251: LIST
55252: LIST
55253: LIST
55254: LIST
55255: IN
55256: NOT
55257: OR
55258: IFFALSE 55264
// exit ;
55260: POP
55261: POP
55262: GO 55362
// end ;
55264: GO 54935
55266: POP
55267: POP
// side := GetSide ( depot ) ;
55268: LD_ADDR_VAR 0 9
55272: PUSH
55273: LD_VAR 0 1
55277: PPUSH
55278: CALL_OW 255
55282: ST_TO_ADDR
// if DangerAtRangeXY ( side , x , y , 20 ) [ 4 ] then
55283: LD_VAR 0 9
55287: PPUSH
55288: LD_VAR 0 3
55292: PPUSH
55293: LD_VAR 0 4
55297: PPUSH
55298: LD_INT 20
55300: PPUSH
55301: CALL 48016 0 4
55305: PUSH
55306: LD_INT 4
55308: ARRAY
55309: IFFALSE 55313
// exit ;
55311: GO 55362
// if btype in [ b_oil_mine , b_siberite_mine ] and not GetResourceVisibility ( x , y , side ) then
55313: LD_VAR 0 2
55317: PUSH
55318: LD_INT 29
55320: PUSH
55321: LD_INT 30
55323: PUSH
55324: EMPTY
55325: LIST
55326: LIST
55327: IN
55328: PUSH
55329: LD_VAR 0 3
55333: PPUSH
55334: LD_VAR 0 4
55338: PPUSH
55339: LD_VAR 0 9
55343: PPUSH
55344: CALL_OW 440
55348: NOT
55349: AND
55350: IFFALSE 55354
// exit ;
55352: GO 55362
// result := true ;
55354: LD_ADDR_VAR 0 6
55358: PUSH
55359: LD_INT 1
55361: ST_TO_ADDR
// end ;
55362: LD_VAR 0 6
55366: RET
// export function GetBuildingHexes ( btype , x , y , dir , nation , mode ) ; var i , temp_list , temp_list2 ; var DepotAm0 , DepotAm1 , DepotAm2 , DepotAm3 , DepotAm4 , DepotAm5 , DepotAr0 , DepotAr1 , DepotAr2 , DepotAr3 , DepotAr4 , DepotAr5 , DepotRu0 , DepotRu1 , DepotRu2 , DepotRu3 , DepotRu4 , DepotRu5 ; var Factory0 , Factory1 , Factory2 , Factory3 , Factory4 , Factory5 , Ext0 , Ext1 , Ext2 , Ext3 , Ext4 , Ext5 ; var Lab0 , Lab1 , Lab2 , Lab3 , Lab4 , Lab5 , ControlTower0 , ControlTower1 , ControlTower2 , ControlTower3 , ControlTower4 , ControlTower5 ; var Barracks0 , Barracks1 , Barracks2 , Barracks3 , Barracks4 , Barracks5 , Bunker0 , Bunker1 , Bunker2 , Bunker3 , Bunker4 , Bunker5 ; begin
55367: LD_INT 0
55369: PPUSH
55370: PPUSH
55371: PPUSH
55372: PPUSH
55373: PPUSH
55374: PPUSH
55375: PPUSH
55376: PPUSH
55377: PPUSH
55378: PPUSH
55379: PPUSH
55380: PPUSH
55381: PPUSH
55382: PPUSH
55383: PPUSH
55384: PPUSH
55385: PPUSH
55386: PPUSH
55387: PPUSH
55388: PPUSH
55389: PPUSH
55390: PPUSH
55391: PPUSH
55392: PPUSH
55393: PPUSH
55394: PPUSH
55395: PPUSH
55396: PPUSH
55397: PPUSH
55398: PPUSH
55399: PPUSH
55400: PPUSH
55401: PPUSH
55402: PPUSH
55403: PPUSH
55404: PPUSH
55405: PPUSH
55406: PPUSH
55407: PPUSH
55408: PPUSH
55409: PPUSH
55410: PPUSH
55411: PPUSH
55412: PPUSH
55413: PPUSH
55414: PPUSH
55415: PPUSH
55416: PPUSH
55417: PPUSH
55418: PPUSH
55419: PPUSH
55420: PPUSH
55421: PPUSH
55422: PPUSH
55423: PPUSH
55424: PPUSH
55425: PPUSH
55426: PPUSH
// result = [ ] ;
55427: LD_ADDR_VAR 0 7
55431: PUSH
55432: EMPTY
55433: ST_TO_ADDR
// temp_list = [ ] ;
55434: LD_ADDR_VAR 0 9
55438: PUSH
55439: EMPTY
55440: ST_TO_ADDR
// if not dir in [ 0 , 1 , 2 , 3 , 4 , 5 ] or ( btype in [ b_depot , b_warehouse ] and not nation in [ nation_american , nation_arabian , nation_russian ] ) then
55441: LD_VAR 0 4
55445: PUSH
55446: LD_INT 0
55448: PUSH
55449: LD_INT 1
55451: PUSH
55452: LD_INT 2
55454: PUSH
55455: LD_INT 3
55457: PUSH
55458: LD_INT 4
55460: PUSH
55461: LD_INT 5
55463: PUSH
55464: EMPTY
55465: LIST
55466: LIST
55467: LIST
55468: LIST
55469: LIST
55470: LIST
55471: IN
55472: NOT
55473: PUSH
55474: LD_VAR 0 1
55478: PUSH
55479: LD_INT 0
55481: PUSH
55482: LD_INT 1
55484: PUSH
55485: EMPTY
55486: LIST
55487: LIST
55488: IN
55489: PUSH
55490: LD_VAR 0 5
55494: PUSH
55495: LD_INT 1
55497: PUSH
55498: LD_INT 2
55500: PUSH
55501: LD_INT 3
55503: PUSH
55504: EMPTY
55505: LIST
55506: LIST
55507: LIST
55508: IN
55509: NOT
55510: AND
55511: OR
55512: IFFALSE 55516
// exit ;
55514: GO 73907
// if btype in [ b_lab , b_lab_half , b_lab_full , b_lab_biological , b_lab_computer , b_lab_opto , b_lab_siberium , b_lab_spacetime , b_lab_weapon ] then
55516: LD_VAR 0 1
55520: PUSH
55521: LD_INT 6
55523: PUSH
55524: LD_INT 7
55526: PUSH
55527: LD_INT 8
55529: PUSH
55530: LD_INT 13
55532: PUSH
55533: LD_INT 12
55535: PUSH
55536: LD_INT 15
55538: PUSH
55539: LD_INT 11
55541: PUSH
55542: LD_INT 14
55544: PUSH
55545: LD_INT 10
55547: PUSH
55548: EMPTY
55549: LIST
55550: LIST
55551: LIST
55552: LIST
55553: LIST
55554: LIST
55555: LIST
55556: LIST
55557: LIST
55558: IN
55559: IFFALSE 55569
// btype = b_lab ;
55561: LD_ADDR_VAR 0 1
55565: PUSH
55566: LD_INT 6
55568: ST_TO_ADDR
// if not mode in [ 0 , 1 , 2 ] or ( not btype in [ b_depot , b_warehouse , b_workshop , b_factory , b_lab , b_control_tower , b_armoury , b_barracks , b_breastwork , b_bunker , b_turret ] and mode = 1 ) or ( not btype in [ b_workshop , b_factory ] and mode = 2 ) then
55569: LD_VAR 0 6
55573: PUSH
55574: LD_INT 0
55576: PUSH
55577: LD_INT 1
55579: PUSH
55580: LD_INT 2
55582: PUSH
55583: EMPTY
55584: LIST
55585: LIST
55586: LIST
55587: IN
55588: NOT
55589: PUSH
55590: LD_VAR 0 1
55594: PUSH
55595: LD_INT 0
55597: PUSH
55598: LD_INT 1
55600: PUSH
55601: LD_INT 2
55603: PUSH
55604: LD_INT 3
55606: PUSH
55607: LD_INT 6
55609: PUSH
55610: LD_INT 36
55612: PUSH
55613: LD_INT 4
55615: PUSH
55616: LD_INT 5
55618: PUSH
55619: LD_INT 31
55621: PUSH
55622: LD_INT 32
55624: PUSH
55625: LD_INT 33
55627: PUSH
55628: EMPTY
55629: LIST
55630: LIST
55631: LIST
55632: LIST
55633: LIST
55634: LIST
55635: LIST
55636: LIST
55637: LIST
55638: LIST
55639: LIST
55640: IN
55641: NOT
55642: PUSH
55643: LD_VAR 0 6
55647: PUSH
55648: LD_INT 1
55650: EQUAL
55651: AND
55652: OR
55653: PUSH
55654: LD_VAR 0 1
55658: PUSH
55659: LD_INT 2
55661: PUSH
55662: LD_INT 3
55664: PUSH
55665: EMPTY
55666: LIST
55667: LIST
55668: IN
55669: NOT
55670: PUSH
55671: LD_VAR 0 6
55675: PUSH
55676: LD_INT 2
55678: EQUAL
55679: AND
55680: OR
55681: IFFALSE 55691
// mode = 0 ;
55683: LD_ADDR_VAR 0 6
55687: PUSH
55688: LD_INT 0
55690: ST_TO_ADDR
// case mode of 0 :
55691: LD_VAR 0 6
55695: PUSH
55696: LD_INT 0
55698: DOUBLE
55699: EQUAL
55700: IFTRUE 55704
55702: GO 67157
55704: POP
// begin DepotAm0 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ 1 , 3 ] , [ 0 , 3 ] , [ - 1 , 2 ] ] ;
55705: LD_ADDR_VAR 0 11
55709: PUSH
55710: LD_INT 0
55712: PUSH
55713: LD_INT 0
55715: PUSH
55716: EMPTY
55717: LIST
55718: LIST
55719: PUSH
55720: LD_INT 0
55722: PUSH
55723: LD_INT 1
55725: NEG
55726: PUSH
55727: EMPTY
55728: LIST
55729: LIST
55730: PUSH
55731: LD_INT 1
55733: PUSH
55734: LD_INT 0
55736: PUSH
55737: EMPTY
55738: LIST
55739: LIST
55740: PUSH
55741: LD_INT 1
55743: PUSH
55744: LD_INT 1
55746: PUSH
55747: EMPTY
55748: LIST
55749: LIST
55750: PUSH
55751: LD_INT 0
55753: PUSH
55754: LD_INT 1
55756: PUSH
55757: EMPTY
55758: LIST
55759: LIST
55760: PUSH
55761: LD_INT 1
55763: NEG
55764: PUSH
55765: LD_INT 0
55767: PUSH
55768: EMPTY
55769: LIST
55770: LIST
55771: PUSH
55772: LD_INT 1
55774: NEG
55775: PUSH
55776: LD_INT 1
55778: NEG
55779: PUSH
55780: EMPTY
55781: LIST
55782: LIST
55783: PUSH
55784: LD_INT 1
55786: NEG
55787: PUSH
55788: LD_INT 2
55790: NEG
55791: PUSH
55792: EMPTY
55793: LIST
55794: LIST
55795: PUSH
55796: LD_INT 0
55798: PUSH
55799: LD_INT 2
55801: NEG
55802: PUSH
55803: EMPTY
55804: LIST
55805: LIST
55806: PUSH
55807: LD_INT 1
55809: PUSH
55810: LD_INT 1
55812: NEG
55813: PUSH
55814: EMPTY
55815: LIST
55816: LIST
55817: PUSH
55818: LD_INT 1
55820: PUSH
55821: LD_INT 2
55823: PUSH
55824: EMPTY
55825: LIST
55826: LIST
55827: PUSH
55828: LD_INT 0
55830: PUSH
55831: LD_INT 2
55833: PUSH
55834: EMPTY
55835: LIST
55836: LIST
55837: PUSH
55838: LD_INT 1
55840: NEG
55841: PUSH
55842: LD_INT 1
55844: PUSH
55845: EMPTY
55846: LIST
55847: LIST
55848: PUSH
55849: LD_INT 1
55851: PUSH
55852: LD_INT 3
55854: PUSH
55855: EMPTY
55856: LIST
55857: LIST
55858: PUSH
55859: LD_INT 0
55861: PUSH
55862: LD_INT 3
55864: PUSH
55865: EMPTY
55866: LIST
55867: LIST
55868: PUSH
55869: LD_INT 1
55871: NEG
55872: PUSH
55873: LD_INT 2
55875: PUSH
55876: EMPTY
55877: LIST
55878: LIST
55879: PUSH
55880: EMPTY
55881: LIST
55882: LIST
55883: LIST
55884: LIST
55885: LIST
55886: LIST
55887: LIST
55888: LIST
55889: LIST
55890: LIST
55891: LIST
55892: LIST
55893: LIST
55894: LIST
55895: LIST
55896: LIST
55897: ST_TO_ADDR
// DepotAm1 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , 1 ] , [ - 3 , 0 ] , [ - 3 , - 1 ] ] ;
55898: LD_ADDR_VAR 0 12
55902: PUSH
55903: LD_INT 0
55905: PUSH
55906: LD_INT 0
55908: PUSH
55909: EMPTY
55910: LIST
55911: LIST
55912: PUSH
55913: LD_INT 0
55915: PUSH
55916: LD_INT 1
55918: NEG
55919: PUSH
55920: EMPTY
55921: LIST
55922: LIST
55923: PUSH
55924: LD_INT 1
55926: PUSH
55927: LD_INT 0
55929: PUSH
55930: EMPTY
55931: LIST
55932: LIST
55933: PUSH
55934: LD_INT 1
55936: PUSH
55937: LD_INT 1
55939: PUSH
55940: EMPTY
55941: LIST
55942: LIST
55943: PUSH
55944: LD_INT 0
55946: PUSH
55947: LD_INT 1
55949: PUSH
55950: EMPTY
55951: LIST
55952: LIST
55953: PUSH
55954: LD_INT 1
55956: NEG
55957: PUSH
55958: LD_INT 0
55960: PUSH
55961: EMPTY
55962: LIST
55963: LIST
55964: PUSH
55965: LD_INT 1
55967: NEG
55968: PUSH
55969: LD_INT 1
55971: NEG
55972: PUSH
55973: EMPTY
55974: LIST
55975: LIST
55976: PUSH
55977: LD_INT 1
55979: PUSH
55980: LD_INT 1
55982: NEG
55983: PUSH
55984: EMPTY
55985: LIST
55986: LIST
55987: PUSH
55988: LD_INT 2
55990: PUSH
55991: LD_INT 0
55993: PUSH
55994: EMPTY
55995: LIST
55996: LIST
55997: PUSH
55998: LD_INT 2
56000: PUSH
56001: LD_INT 1
56003: PUSH
56004: EMPTY
56005: LIST
56006: LIST
56007: PUSH
56008: LD_INT 1
56010: NEG
56011: PUSH
56012: LD_INT 1
56014: PUSH
56015: EMPTY
56016: LIST
56017: LIST
56018: PUSH
56019: LD_INT 2
56021: NEG
56022: PUSH
56023: LD_INT 0
56025: PUSH
56026: EMPTY
56027: LIST
56028: LIST
56029: PUSH
56030: LD_INT 2
56032: NEG
56033: PUSH
56034: LD_INT 1
56036: NEG
56037: PUSH
56038: EMPTY
56039: LIST
56040: LIST
56041: PUSH
56042: LD_INT 2
56044: NEG
56045: PUSH
56046: LD_INT 1
56048: PUSH
56049: EMPTY
56050: LIST
56051: LIST
56052: PUSH
56053: LD_INT 3
56055: NEG
56056: PUSH
56057: LD_INT 0
56059: PUSH
56060: EMPTY
56061: LIST
56062: LIST
56063: PUSH
56064: LD_INT 3
56066: NEG
56067: PUSH
56068: LD_INT 1
56070: NEG
56071: PUSH
56072: EMPTY
56073: LIST
56074: LIST
56075: PUSH
56076: EMPTY
56077: LIST
56078: LIST
56079: LIST
56080: LIST
56081: LIST
56082: LIST
56083: LIST
56084: LIST
56085: LIST
56086: LIST
56087: LIST
56088: LIST
56089: LIST
56090: LIST
56091: LIST
56092: LIST
56093: ST_TO_ADDR
// DepotAm2 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ - 2 , - 3 ] , [ - 3 , - 2 ] , [ - 3 , - 3 ] ] ;
56094: LD_ADDR_VAR 0 13
56098: PUSH
56099: LD_INT 0
56101: PUSH
56102: LD_INT 0
56104: PUSH
56105: EMPTY
56106: LIST
56107: LIST
56108: PUSH
56109: LD_INT 0
56111: PUSH
56112: LD_INT 1
56114: NEG
56115: PUSH
56116: EMPTY
56117: LIST
56118: LIST
56119: PUSH
56120: LD_INT 1
56122: PUSH
56123: LD_INT 0
56125: PUSH
56126: EMPTY
56127: LIST
56128: LIST
56129: PUSH
56130: LD_INT 1
56132: PUSH
56133: LD_INT 1
56135: PUSH
56136: EMPTY
56137: LIST
56138: LIST
56139: PUSH
56140: LD_INT 0
56142: PUSH
56143: LD_INT 1
56145: PUSH
56146: EMPTY
56147: LIST
56148: LIST
56149: PUSH
56150: LD_INT 1
56152: NEG
56153: PUSH
56154: LD_INT 0
56156: PUSH
56157: EMPTY
56158: LIST
56159: LIST
56160: PUSH
56161: LD_INT 1
56163: NEG
56164: PUSH
56165: LD_INT 1
56167: NEG
56168: PUSH
56169: EMPTY
56170: LIST
56171: LIST
56172: PUSH
56173: LD_INT 1
56175: NEG
56176: PUSH
56177: LD_INT 2
56179: NEG
56180: PUSH
56181: EMPTY
56182: LIST
56183: LIST
56184: PUSH
56185: LD_INT 2
56187: PUSH
56188: LD_INT 1
56190: PUSH
56191: EMPTY
56192: LIST
56193: LIST
56194: PUSH
56195: LD_INT 2
56197: PUSH
56198: LD_INT 2
56200: PUSH
56201: EMPTY
56202: LIST
56203: LIST
56204: PUSH
56205: LD_INT 1
56207: PUSH
56208: LD_INT 2
56210: PUSH
56211: EMPTY
56212: LIST
56213: LIST
56214: PUSH
56215: LD_INT 2
56217: NEG
56218: PUSH
56219: LD_INT 1
56221: NEG
56222: PUSH
56223: EMPTY
56224: LIST
56225: LIST
56226: PUSH
56227: LD_INT 2
56229: NEG
56230: PUSH
56231: LD_INT 2
56233: NEG
56234: PUSH
56235: EMPTY
56236: LIST
56237: LIST
56238: PUSH
56239: LD_INT 2
56241: NEG
56242: PUSH
56243: LD_INT 3
56245: NEG
56246: PUSH
56247: EMPTY
56248: LIST
56249: LIST
56250: PUSH
56251: LD_INT 3
56253: NEG
56254: PUSH
56255: LD_INT 2
56257: NEG
56258: PUSH
56259: EMPTY
56260: LIST
56261: LIST
56262: PUSH
56263: LD_INT 3
56265: NEG
56266: PUSH
56267: LD_INT 3
56269: NEG
56270: PUSH
56271: EMPTY
56272: LIST
56273: LIST
56274: PUSH
56275: EMPTY
56276: LIST
56277: LIST
56278: LIST
56279: LIST
56280: LIST
56281: LIST
56282: LIST
56283: LIST
56284: LIST
56285: LIST
56286: LIST
56287: LIST
56288: LIST
56289: LIST
56290: LIST
56291: LIST
56292: ST_TO_ADDR
// DepotAm3 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 1 , - 3 ] , [ 0 , - 3 ] , [ 1 , - 2 ] ] ;
56293: LD_ADDR_VAR 0 14
56297: PUSH
56298: LD_INT 0
56300: PUSH
56301: LD_INT 0
56303: PUSH
56304: EMPTY
56305: LIST
56306: LIST
56307: PUSH
56308: LD_INT 0
56310: PUSH
56311: LD_INT 1
56313: NEG
56314: PUSH
56315: EMPTY
56316: LIST
56317: LIST
56318: PUSH
56319: LD_INT 1
56321: PUSH
56322: LD_INT 0
56324: PUSH
56325: EMPTY
56326: LIST
56327: LIST
56328: PUSH
56329: LD_INT 1
56331: PUSH
56332: LD_INT 1
56334: PUSH
56335: EMPTY
56336: LIST
56337: LIST
56338: PUSH
56339: LD_INT 0
56341: PUSH
56342: LD_INT 1
56344: PUSH
56345: EMPTY
56346: LIST
56347: LIST
56348: PUSH
56349: LD_INT 1
56351: NEG
56352: PUSH
56353: LD_INT 0
56355: PUSH
56356: EMPTY
56357: LIST
56358: LIST
56359: PUSH
56360: LD_INT 1
56362: NEG
56363: PUSH
56364: LD_INT 1
56366: NEG
56367: PUSH
56368: EMPTY
56369: LIST
56370: LIST
56371: PUSH
56372: LD_INT 1
56374: NEG
56375: PUSH
56376: LD_INT 2
56378: NEG
56379: PUSH
56380: EMPTY
56381: LIST
56382: LIST
56383: PUSH
56384: LD_INT 0
56386: PUSH
56387: LD_INT 2
56389: NEG
56390: PUSH
56391: EMPTY
56392: LIST
56393: LIST
56394: PUSH
56395: LD_INT 1
56397: PUSH
56398: LD_INT 1
56400: NEG
56401: PUSH
56402: EMPTY
56403: LIST
56404: LIST
56405: PUSH
56406: LD_INT 1
56408: PUSH
56409: LD_INT 2
56411: PUSH
56412: EMPTY
56413: LIST
56414: LIST
56415: PUSH
56416: LD_INT 0
56418: PUSH
56419: LD_INT 2
56421: PUSH
56422: EMPTY
56423: LIST
56424: LIST
56425: PUSH
56426: LD_INT 1
56428: NEG
56429: PUSH
56430: LD_INT 1
56432: PUSH
56433: EMPTY
56434: LIST
56435: LIST
56436: PUSH
56437: LD_INT 1
56439: NEG
56440: PUSH
56441: LD_INT 3
56443: NEG
56444: PUSH
56445: EMPTY
56446: LIST
56447: LIST
56448: PUSH
56449: LD_INT 0
56451: PUSH
56452: LD_INT 3
56454: NEG
56455: PUSH
56456: EMPTY
56457: LIST
56458: LIST
56459: PUSH
56460: LD_INT 1
56462: PUSH
56463: LD_INT 2
56465: NEG
56466: PUSH
56467: EMPTY
56468: LIST
56469: LIST
56470: PUSH
56471: EMPTY
56472: LIST
56473: LIST
56474: LIST
56475: LIST
56476: LIST
56477: LIST
56478: LIST
56479: LIST
56480: LIST
56481: LIST
56482: LIST
56483: LIST
56484: LIST
56485: LIST
56486: LIST
56487: LIST
56488: ST_TO_ADDR
// DepotAm4 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ 2 , - 1 ] , [ 3 , 0 ] , [ 3 , 1 ] ] ;
56489: LD_ADDR_VAR 0 15
56493: PUSH
56494: LD_INT 0
56496: PUSH
56497: LD_INT 0
56499: PUSH
56500: EMPTY
56501: LIST
56502: LIST
56503: PUSH
56504: LD_INT 0
56506: PUSH
56507: LD_INT 1
56509: NEG
56510: PUSH
56511: EMPTY
56512: LIST
56513: LIST
56514: PUSH
56515: LD_INT 1
56517: PUSH
56518: LD_INT 0
56520: PUSH
56521: EMPTY
56522: LIST
56523: LIST
56524: PUSH
56525: LD_INT 1
56527: PUSH
56528: LD_INT 1
56530: PUSH
56531: EMPTY
56532: LIST
56533: LIST
56534: PUSH
56535: LD_INT 0
56537: PUSH
56538: LD_INT 1
56540: PUSH
56541: EMPTY
56542: LIST
56543: LIST
56544: PUSH
56545: LD_INT 1
56547: NEG
56548: PUSH
56549: LD_INT 0
56551: PUSH
56552: EMPTY
56553: LIST
56554: LIST
56555: PUSH
56556: LD_INT 1
56558: NEG
56559: PUSH
56560: LD_INT 1
56562: NEG
56563: PUSH
56564: EMPTY
56565: LIST
56566: LIST
56567: PUSH
56568: LD_INT 1
56570: PUSH
56571: LD_INT 1
56573: NEG
56574: PUSH
56575: EMPTY
56576: LIST
56577: LIST
56578: PUSH
56579: LD_INT 2
56581: PUSH
56582: LD_INT 0
56584: PUSH
56585: EMPTY
56586: LIST
56587: LIST
56588: PUSH
56589: LD_INT 2
56591: PUSH
56592: LD_INT 1
56594: PUSH
56595: EMPTY
56596: LIST
56597: LIST
56598: PUSH
56599: LD_INT 1
56601: NEG
56602: PUSH
56603: LD_INT 1
56605: PUSH
56606: EMPTY
56607: LIST
56608: LIST
56609: PUSH
56610: LD_INT 2
56612: NEG
56613: PUSH
56614: LD_INT 0
56616: PUSH
56617: EMPTY
56618: LIST
56619: LIST
56620: PUSH
56621: LD_INT 2
56623: NEG
56624: PUSH
56625: LD_INT 1
56627: NEG
56628: PUSH
56629: EMPTY
56630: LIST
56631: LIST
56632: PUSH
56633: LD_INT 2
56635: PUSH
56636: LD_INT 1
56638: NEG
56639: PUSH
56640: EMPTY
56641: LIST
56642: LIST
56643: PUSH
56644: LD_INT 3
56646: PUSH
56647: LD_INT 0
56649: PUSH
56650: EMPTY
56651: LIST
56652: LIST
56653: PUSH
56654: LD_INT 3
56656: PUSH
56657: LD_INT 1
56659: PUSH
56660: EMPTY
56661: LIST
56662: LIST
56663: PUSH
56664: EMPTY
56665: LIST
56666: LIST
56667: LIST
56668: LIST
56669: LIST
56670: LIST
56671: LIST
56672: LIST
56673: LIST
56674: LIST
56675: LIST
56676: LIST
56677: LIST
56678: LIST
56679: LIST
56680: LIST
56681: ST_TO_ADDR
// DepotAm5 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ 3 , 2 ] , [ 3 , 3 ] , [ 2 , 3 ] ] ;
56682: LD_ADDR_VAR 0 16
56686: PUSH
56687: LD_INT 0
56689: PUSH
56690: LD_INT 0
56692: PUSH
56693: EMPTY
56694: LIST
56695: LIST
56696: PUSH
56697: LD_INT 0
56699: PUSH
56700: LD_INT 1
56702: NEG
56703: PUSH
56704: EMPTY
56705: LIST
56706: LIST
56707: PUSH
56708: LD_INT 1
56710: PUSH
56711: LD_INT 0
56713: PUSH
56714: EMPTY
56715: LIST
56716: LIST
56717: PUSH
56718: LD_INT 1
56720: PUSH
56721: LD_INT 1
56723: PUSH
56724: EMPTY
56725: LIST
56726: LIST
56727: PUSH
56728: LD_INT 0
56730: PUSH
56731: LD_INT 1
56733: PUSH
56734: EMPTY
56735: LIST
56736: LIST
56737: PUSH
56738: LD_INT 1
56740: NEG
56741: PUSH
56742: LD_INT 0
56744: PUSH
56745: EMPTY
56746: LIST
56747: LIST
56748: PUSH
56749: LD_INT 1
56751: NEG
56752: PUSH
56753: LD_INT 1
56755: NEG
56756: PUSH
56757: EMPTY
56758: LIST
56759: LIST
56760: PUSH
56761: LD_INT 1
56763: NEG
56764: PUSH
56765: LD_INT 2
56767: NEG
56768: PUSH
56769: EMPTY
56770: LIST
56771: LIST
56772: PUSH
56773: LD_INT 2
56775: PUSH
56776: LD_INT 1
56778: PUSH
56779: EMPTY
56780: LIST
56781: LIST
56782: PUSH
56783: LD_INT 2
56785: PUSH
56786: LD_INT 2
56788: PUSH
56789: EMPTY
56790: LIST
56791: LIST
56792: PUSH
56793: LD_INT 1
56795: PUSH
56796: LD_INT 2
56798: PUSH
56799: EMPTY
56800: LIST
56801: LIST
56802: PUSH
56803: LD_INT 2
56805: NEG
56806: PUSH
56807: LD_INT 1
56809: NEG
56810: PUSH
56811: EMPTY
56812: LIST
56813: LIST
56814: PUSH
56815: LD_INT 2
56817: NEG
56818: PUSH
56819: LD_INT 2
56821: NEG
56822: PUSH
56823: EMPTY
56824: LIST
56825: LIST
56826: PUSH
56827: LD_INT 3
56829: PUSH
56830: LD_INT 2
56832: PUSH
56833: EMPTY
56834: LIST
56835: LIST
56836: PUSH
56837: LD_INT 3
56839: PUSH
56840: LD_INT 3
56842: PUSH
56843: EMPTY
56844: LIST
56845: LIST
56846: PUSH
56847: LD_INT 2
56849: PUSH
56850: LD_INT 3
56852: PUSH
56853: EMPTY
56854: LIST
56855: LIST
56856: PUSH
56857: EMPTY
56858: LIST
56859: LIST
56860: LIST
56861: LIST
56862: LIST
56863: LIST
56864: LIST
56865: LIST
56866: LIST
56867: LIST
56868: LIST
56869: LIST
56870: LIST
56871: LIST
56872: LIST
56873: LIST
56874: ST_TO_ADDR
// DepotAr0 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
56875: LD_ADDR_VAR 0 17
56879: PUSH
56880: LD_INT 0
56882: PUSH
56883: LD_INT 0
56885: PUSH
56886: EMPTY
56887: LIST
56888: LIST
56889: PUSH
56890: LD_INT 0
56892: PUSH
56893: LD_INT 1
56895: NEG
56896: PUSH
56897: EMPTY
56898: LIST
56899: LIST
56900: PUSH
56901: LD_INT 1
56903: PUSH
56904: LD_INT 0
56906: PUSH
56907: EMPTY
56908: LIST
56909: LIST
56910: PUSH
56911: LD_INT 1
56913: PUSH
56914: LD_INT 1
56916: PUSH
56917: EMPTY
56918: LIST
56919: LIST
56920: PUSH
56921: LD_INT 0
56923: PUSH
56924: LD_INT 1
56926: PUSH
56927: EMPTY
56928: LIST
56929: LIST
56930: PUSH
56931: LD_INT 1
56933: NEG
56934: PUSH
56935: LD_INT 0
56937: PUSH
56938: EMPTY
56939: LIST
56940: LIST
56941: PUSH
56942: LD_INT 1
56944: NEG
56945: PUSH
56946: LD_INT 1
56948: NEG
56949: PUSH
56950: EMPTY
56951: LIST
56952: LIST
56953: PUSH
56954: LD_INT 1
56956: NEG
56957: PUSH
56958: LD_INT 2
56960: NEG
56961: PUSH
56962: EMPTY
56963: LIST
56964: LIST
56965: PUSH
56966: LD_INT 0
56968: PUSH
56969: LD_INT 2
56971: NEG
56972: PUSH
56973: EMPTY
56974: LIST
56975: LIST
56976: PUSH
56977: LD_INT 1
56979: PUSH
56980: LD_INT 1
56982: NEG
56983: PUSH
56984: EMPTY
56985: LIST
56986: LIST
56987: PUSH
56988: LD_INT 2
56990: PUSH
56991: LD_INT 0
56993: PUSH
56994: EMPTY
56995: LIST
56996: LIST
56997: PUSH
56998: LD_INT 2
57000: PUSH
57001: LD_INT 1
57003: PUSH
57004: EMPTY
57005: LIST
57006: LIST
57007: PUSH
57008: LD_INT 2
57010: PUSH
57011: LD_INT 2
57013: PUSH
57014: EMPTY
57015: LIST
57016: LIST
57017: PUSH
57018: LD_INT 1
57020: PUSH
57021: LD_INT 2
57023: PUSH
57024: EMPTY
57025: LIST
57026: LIST
57027: PUSH
57028: LD_INT 0
57030: PUSH
57031: LD_INT 2
57033: PUSH
57034: EMPTY
57035: LIST
57036: LIST
57037: PUSH
57038: LD_INT 1
57040: NEG
57041: PUSH
57042: LD_INT 1
57044: PUSH
57045: EMPTY
57046: LIST
57047: LIST
57048: PUSH
57049: LD_INT 2
57051: NEG
57052: PUSH
57053: LD_INT 0
57055: PUSH
57056: EMPTY
57057: LIST
57058: LIST
57059: PUSH
57060: LD_INT 2
57062: NEG
57063: PUSH
57064: LD_INT 1
57066: NEG
57067: PUSH
57068: EMPTY
57069: LIST
57070: LIST
57071: PUSH
57072: LD_INT 2
57074: NEG
57075: PUSH
57076: LD_INT 2
57078: NEG
57079: PUSH
57080: EMPTY
57081: LIST
57082: LIST
57083: PUSH
57084: EMPTY
57085: LIST
57086: LIST
57087: LIST
57088: LIST
57089: LIST
57090: LIST
57091: LIST
57092: LIST
57093: LIST
57094: LIST
57095: LIST
57096: LIST
57097: LIST
57098: LIST
57099: LIST
57100: LIST
57101: LIST
57102: LIST
57103: LIST
57104: ST_TO_ADDR
// DepotAr1 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
57105: LD_ADDR_VAR 0 18
57109: PUSH
57110: LD_INT 0
57112: PUSH
57113: LD_INT 0
57115: PUSH
57116: EMPTY
57117: LIST
57118: LIST
57119: PUSH
57120: LD_INT 0
57122: PUSH
57123: LD_INT 1
57125: NEG
57126: PUSH
57127: EMPTY
57128: LIST
57129: LIST
57130: PUSH
57131: LD_INT 1
57133: PUSH
57134: LD_INT 0
57136: PUSH
57137: EMPTY
57138: LIST
57139: LIST
57140: PUSH
57141: LD_INT 1
57143: PUSH
57144: LD_INT 1
57146: PUSH
57147: EMPTY
57148: LIST
57149: LIST
57150: PUSH
57151: LD_INT 0
57153: PUSH
57154: LD_INT 1
57156: PUSH
57157: EMPTY
57158: LIST
57159: LIST
57160: PUSH
57161: LD_INT 1
57163: NEG
57164: PUSH
57165: LD_INT 0
57167: PUSH
57168: EMPTY
57169: LIST
57170: LIST
57171: PUSH
57172: LD_INT 1
57174: NEG
57175: PUSH
57176: LD_INT 1
57178: NEG
57179: PUSH
57180: EMPTY
57181: LIST
57182: LIST
57183: PUSH
57184: LD_INT 1
57186: NEG
57187: PUSH
57188: LD_INT 2
57190: NEG
57191: PUSH
57192: EMPTY
57193: LIST
57194: LIST
57195: PUSH
57196: LD_INT 0
57198: PUSH
57199: LD_INT 2
57201: NEG
57202: PUSH
57203: EMPTY
57204: LIST
57205: LIST
57206: PUSH
57207: LD_INT 1
57209: PUSH
57210: LD_INT 1
57212: NEG
57213: PUSH
57214: EMPTY
57215: LIST
57216: LIST
57217: PUSH
57218: LD_INT 2
57220: PUSH
57221: LD_INT 0
57223: PUSH
57224: EMPTY
57225: LIST
57226: LIST
57227: PUSH
57228: LD_INT 2
57230: PUSH
57231: LD_INT 1
57233: PUSH
57234: EMPTY
57235: LIST
57236: LIST
57237: PUSH
57238: LD_INT 2
57240: PUSH
57241: LD_INT 2
57243: PUSH
57244: EMPTY
57245: LIST
57246: LIST
57247: PUSH
57248: LD_INT 1
57250: PUSH
57251: LD_INT 2
57253: PUSH
57254: EMPTY
57255: LIST
57256: LIST
57257: PUSH
57258: LD_INT 0
57260: PUSH
57261: LD_INT 2
57263: PUSH
57264: EMPTY
57265: LIST
57266: LIST
57267: PUSH
57268: LD_INT 1
57270: NEG
57271: PUSH
57272: LD_INT 1
57274: PUSH
57275: EMPTY
57276: LIST
57277: LIST
57278: PUSH
57279: LD_INT 2
57281: NEG
57282: PUSH
57283: LD_INT 0
57285: PUSH
57286: EMPTY
57287: LIST
57288: LIST
57289: PUSH
57290: LD_INT 2
57292: NEG
57293: PUSH
57294: LD_INT 1
57296: NEG
57297: PUSH
57298: EMPTY
57299: LIST
57300: LIST
57301: PUSH
57302: LD_INT 2
57304: NEG
57305: PUSH
57306: LD_INT 2
57308: NEG
57309: PUSH
57310: EMPTY
57311: LIST
57312: LIST
57313: PUSH
57314: EMPTY
57315: LIST
57316: LIST
57317: LIST
57318: LIST
57319: LIST
57320: LIST
57321: LIST
57322: LIST
57323: LIST
57324: LIST
57325: LIST
57326: LIST
57327: LIST
57328: LIST
57329: LIST
57330: LIST
57331: LIST
57332: LIST
57333: LIST
57334: ST_TO_ADDR
// DepotAr2 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
57335: LD_ADDR_VAR 0 19
57339: PUSH
57340: LD_INT 0
57342: PUSH
57343: LD_INT 0
57345: PUSH
57346: EMPTY
57347: LIST
57348: LIST
57349: PUSH
57350: LD_INT 0
57352: PUSH
57353: LD_INT 1
57355: NEG
57356: PUSH
57357: EMPTY
57358: LIST
57359: LIST
57360: PUSH
57361: LD_INT 1
57363: PUSH
57364: LD_INT 0
57366: PUSH
57367: EMPTY
57368: LIST
57369: LIST
57370: PUSH
57371: LD_INT 1
57373: PUSH
57374: LD_INT 1
57376: PUSH
57377: EMPTY
57378: LIST
57379: LIST
57380: PUSH
57381: LD_INT 0
57383: PUSH
57384: LD_INT 1
57386: PUSH
57387: EMPTY
57388: LIST
57389: LIST
57390: PUSH
57391: LD_INT 1
57393: NEG
57394: PUSH
57395: LD_INT 0
57397: PUSH
57398: EMPTY
57399: LIST
57400: LIST
57401: PUSH
57402: LD_INT 1
57404: NEG
57405: PUSH
57406: LD_INT 1
57408: NEG
57409: PUSH
57410: EMPTY
57411: LIST
57412: LIST
57413: PUSH
57414: LD_INT 1
57416: NEG
57417: PUSH
57418: LD_INT 2
57420: NEG
57421: PUSH
57422: EMPTY
57423: LIST
57424: LIST
57425: PUSH
57426: LD_INT 0
57428: PUSH
57429: LD_INT 2
57431: NEG
57432: PUSH
57433: EMPTY
57434: LIST
57435: LIST
57436: PUSH
57437: LD_INT 1
57439: PUSH
57440: LD_INT 1
57442: NEG
57443: PUSH
57444: EMPTY
57445: LIST
57446: LIST
57447: PUSH
57448: LD_INT 2
57450: PUSH
57451: LD_INT 0
57453: PUSH
57454: EMPTY
57455: LIST
57456: LIST
57457: PUSH
57458: LD_INT 2
57460: PUSH
57461: LD_INT 1
57463: PUSH
57464: EMPTY
57465: LIST
57466: LIST
57467: PUSH
57468: LD_INT 2
57470: PUSH
57471: LD_INT 2
57473: PUSH
57474: EMPTY
57475: LIST
57476: LIST
57477: PUSH
57478: LD_INT 1
57480: PUSH
57481: LD_INT 2
57483: PUSH
57484: EMPTY
57485: LIST
57486: LIST
57487: PUSH
57488: LD_INT 0
57490: PUSH
57491: LD_INT 2
57493: PUSH
57494: EMPTY
57495: LIST
57496: LIST
57497: PUSH
57498: LD_INT 1
57500: NEG
57501: PUSH
57502: LD_INT 1
57504: PUSH
57505: EMPTY
57506: LIST
57507: LIST
57508: PUSH
57509: LD_INT 2
57511: NEG
57512: PUSH
57513: LD_INT 0
57515: PUSH
57516: EMPTY
57517: LIST
57518: LIST
57519: PUSH
57520: LD_INT 2
57522: NEG
57523: PUSH
57524: LD_INT 1
57526: NEG
57527: PUSH
57528: EMPTY
57529: LIST
57530: LIST
57531: PUSH
57532: LD_INT 2
57534: NEG
57535: PUSH
57536: LD_INT 2
57538: NEG
57539: PUSH
57540: EMPTY
57541: LIST
57542: LIST
57543: PUSH
57544: EMPTY
57545: LIST
57546: LIST
57547: LIST
57548: LIST
57549: LIST
57550: LIST
57551: LIST
57552: LIST
57553: LIST
57554: LIST
57555: LIST
57556: LIST
57557: LIST
57558: LIST
57559: LIST
57560: LIST
57561: LIST
57562: LIST
57563: LIST
57564: ST_TO_ADDR
// DepotAr3 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
57565: LD_ADDR_VAR 0 20
57569: PUSH
57570: LD_INT 0
57572: PUSH
57573: LD_INT 0
57575: PUSH
57576: EMPTY
57577: LIST
57578: LIST
57579: PUSH
57580: LD_INT 0
57582: PUSH
57583: LD_INT 1
57585: NEG
57586: PUSH
57587: EMPTY
57588: LIST
57589: LIST
57590: PUSH
57591: LD_INT 1
57593: PUSH
57594: LD_INT 0
57596: PUSH
57597: EMPTY
57598: LIST
57599: LIST
57600: PUSH
57601: LD_INT 1
57603: PUSH
57604: LD_INT 1
57606: PUSH
57607: EMPTY
57608: LIST
57609: LIST
57610: PUSH
57611: LD_INT 0
57613: PUSH
57614: LD_INT 1
57616: PUSH
57617: EMPTY
57618: LIST
57619: LIST
57620: PUSH
57621: LD_INT 1
57623: NEG
57624: PUSH
57625: LD_INT 0
57627: PUSH
57628: EMPTY
57629: LIST
57630: LIST
57631: PUSH
57632: LD_INT 1
57634: NEG
57635: PUSH
57636: LD_INT 1
57638: NEG
57639: PUSH
57640: EMPTY
57641: LIST
57642: LIST
57643: PUSH
57644: LD_INT 1
57646: NEG
57647: PUSH
57648: LD_INT 2
57650: NEG
57651: PUSH
57652: EMPTY
57653: LIST
57654: LIST
57655: PUSH
57656: LD_INT 0
57658: PUSH
57659: LD_INT 2
57661: NEG
57662: PUSH
57663: EMPTY
57664: LIST
57665: LIST
57666: PUSH
57667: LD_INT 1
57669: PUSH
57670: LD_INT 1
57672: NEG
57673: PUSH
57674: EMPTY
57675: LIST
57676: LIST
57677: PUSH
57678: LD_INT 2
57680: PUSH
57681: LD_INT 0
57683: PUSH
57684: EMPTY
57685: LIST
57686: LIST
57687: PUSH
57688: LD_INT 2
57690: PUSH
57691: LD_INT 1
57693: PUSH
57694: EMPTY
57695: LIST
57696: LIST
57697: PUSH
57698: LD_INT 2
57700: PUSH
57701: LD_INT 2
57703: PUSH
57704: EMPTY
57705: LIST
57706: LIST
57707: PUSH
57708: LD_INT 1
57710: PUSH
57711: LD_INT 2
57713: PUSH
57714: EMPTY
57715: LIST
57716: LIST
57717: PUSH
57718: LD_INT 0
57720: PUSH
57721: LD_INT 2
57723: PUSH
57724: EMPTY
57725: LIST
57726: LIST
57727: PUSH
57728: LD_INT 1
57730: NEG
57731: PUSH
57732: LD_INT 1
57734: PUSH
57735: EMPTY
57736: LIST
57737: LIST
57738: PUSH
57739: LD_INT 2
57741: NEG
57742: PUSH
57743: LD_INT 0
57745: PUSH
57746: EMPTY
57747: LIST
57748: LIST
57749: PUSH
57750: LD_INT 2
57752: NEG
57753: PUSH
57754: LD_INT 1
57756: NEG
57757: PUSH
57758: EMPTY
57759: LIST
57760: LIST
57761: PUSH
57762: LD_INT 2
57764: NEG
57765: PUSH
57766: LD_INT 2
57768: NEG
57769: PUSH
57770: EMPTY
57771: LIST
57772: LIST
57773: PUSH
57774: EMPTY
57775: LIST
57776: LIST
57777: LIST
57778: LIST
57779: LIST
57780: LIST
57781: LIST
57782: LIST
57783: LIST
57784: LIST
57785: LIST
57786: LIST
57787: LIST
57788: LIST
57789: LIST
57790: LIST
57791: LIST
57792: LIST
57793: LIST
57794: ST_TO_ADDR
// DepotAr4 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
57795: LD_ADDR_VAR 0 21
57799: PUSH
57800: LD_INT 0
57802: PUSH
57803: LD_INT 0
57805: PUSH
57806: EMPTY
57807: LIST
57808: LIST
57809: PUSH
57810: LD_INT 0
57812: PUSH
57813: LD_INT 1
57815: NEG
57816: PUSH
57817: EMPTY
57818: LIST
57819: LIST
57820: PUSH
57821: LD_INT 1
57823: PUSH
57824: LD_INT 0
57826: PUSH
57827: EMPTY
57828: LIST
57829: LIST
57830: PUSH
57831: LD_INT 1
57833: PUSH
57834: LD_INT 1
57836: PUSH
57837: EMPTY
57838: LIST
57839: LIST
57840: PUSH
57841: LD_INT 0
57843: PUSH
57844: LD_INT 1
57846: PUSH
57847: EMPTY
57848: LIST
57849: LIST
57850: PUSH
57851: LD_INT 1
57853: NEG
57854: PUSH
57855: LD_INT 0
57857: PUSH
57858: EMPTY
57859: LIST
57860: LIST
57861: PUSH
57862: LD_INT 1
57864: NEG
57865: PUSH
57866: LD_INT 1
57868: NEG
57869: PUSH
57870: EMPTY
57871: LIST
57872: LIST
57873: PUSH
57874: LD_INT 1
57876: NEG
57877: PUSH
57878: LD_INT 2
57880: NEG
57881: PUSH
57882: EMPTY
57883: LIST
57884: LIST
57885: PUSH
57886: LD_INT 0
57888: PUSH
57889: LD_INT 2
57891: NEG
57892: PUSH
57893: EMPTY
57894: LIST
57895: LIST
57896: PUSH
57897: LD_INT 1
57899: PUSH
57900: LD_INT 1
57902: NEG
57903: PUSH
57904: EMPTY
57905: LIST
57906: LIST
57907: PUSH
57908: LD_INT 2
57910: PUSH
57911: LD_INT 0
57913: PUSH
57914: EMPTY
57915: LIST
57916: LIST
57917: PUSH
57918: LD_INT 2
57920: PUSH
57921: LD_INT 1
57923: PUSH
57924: EMPTY
57925: LIST
57926: LIST
57927: PUSH
57928: LD_INT 2
57930: PUSH
57931: LD_INT 2
57933: PUSH
57934: EMPTY
57935: LIST
57936: LIST
57937: PUSH
57938: LD_INT 1
57940: PUSH
57941: LD_INT 2
57943: PUSH
57944: EMPTY
57945: LIST
57946: LIST
57947: PUSH
57948: LD_INT 0
57950: PUSH
57951: LD_INT 2
57953: PUSH
57954: EMPTY
57955: LIST
57956: LIST
57957: PUSH
57958: LD_INT 1
57960: NEG
57961: PUSH
57962: LD_INT 1
57964: PUSH
57965: EMPTY
57966: LIST
57967: LIST
57968: PUSH
57969: LD_INT 2
57971: NEG
57972: PUSH
57973: LD_INT 0
57975: PUSH
57976: EMPTY
57977: LIST
57978: LIST
57979: PUSH
57980: LD_INT 2
57982: NEG
57983: PUSH
57984: LD_INT 1
57986: NEG
57987: PUSH
57988: EMPTY
57989: LIST
57990: LIST
57991: PUSH
57992: LD_INT 2
57994: NEG
57995: PUSH
57996: LD_INT 2
57998: NEG
57999: PUSH
58000: EMPTY
58001: LIST
58002: LIST
58003: PUSH
58004: EMPTY
58005: LIST
58006: LIST
58007: LIST
58008: LIST
58009: LIST
58010: LIST
58011: LIST
58012: LIST
58013: LIST
58014: LIST
58015: LIST
58016: LIST
58017: LIST
58018: LIST
58019: LIST
58020: LIST
58021: LIST
58022: LIST
58023: LIST
58024: ST_TO_ADDR
// DepotAr5 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
58025: LD_ADDR_VAR 0 22
58029: PUSH
58030: LD_INT 0
58032: PUSH
58033: LD_INT 0
58035: PUSH
58036: EMPTY
58037: LIST
58038: LIST
58039: PUSH
58040: LD_INT 0
58042: PUSH
58043: LD_INT 1
58045: NEG
58046: PUSH
58047: EMPTY
58048: LIST
58049: LIST
58050: PUSH
58051: LD_INT 1
58053: PUSH
58054: LD_INT 0
58056: PUSH
58057: EMPTY
58058: LIST
58059: LIST
58060: PUSH
58061: LD_INT 1
58063: PUSH
58064: LD_INT 1
58066: PUSH
58067: EMPTY
58068: LIST
58069: LIST
58070: PUSH
58071: LD_INT 0
58073: PUSH
58074: LD_INT 1
58076: PUSH
58077: EMPTY
58078: LIST
58079: LIST
58080: PUSH
58081: LD_INT 1
58083: NEG
58084: PUSH
58085: LD_INT 0
58087: PUSH
58088: EMPTY
58089: LIST
58090: LIST
58091: PUSH
58092: LD_INT 1
58094: NEG
58095: PUSH
58096: LD_INT 1
58098: NEG
58099: PUSH
58100: EMPTY
58101: LIST
58102: LIST
58103: PUSH
58104: LD_INT 1
58106: NEG
58107: PUSH
58108: LD_INT 2
58110: NEG
58111: PUSH
58112: EMPTY
58113: LIST
58114: LIST
58115: PUSH
58116: LD_INT 0
58118: PUSH
58119: LD_INT 2
58121: NEG
58122: PUSH
58123: EMPTY
58124: LIST
58125: LIST
58126: PUSH
58127: LD_INT 1
58129: PUSH
58130: LD_INT 1
58132: NEG
58133: PUSH
58134: EMPTY
58135: LIST
58136: LIST
58137: PUSH
58138: LD_INT 2
58140: PUSH
58141: LD_INT 0
58143: PUSH
58144: EMPTY
58145: LIST
58146: LIST
58147: PUSH
58148: LD_INT 2
58150: PUSH
58151: LD_INT 1
58153: PUSH
58154: EMPTY
58155: LIST
58156: LIST
58157: PUSH
58158: LD_INT 2
58160: PUSH
58161: LD_INT 2
58163: PUSH
58164: EMPTY
58165: LIST
58166: LIST
58167: PUSH
58168: LD_INT 1
58170: PUSH
58171: LD_INT 2
58173: PUSH
58174: EMPTY
58175: LIST
58176: LIST
58177: PUSH
58178: LD_INT 0
58180: PUSH
58181: LD_INT 2
58183: PUSH
58184: EMPTY
58185: LIST
58186: LIST
58187: PUSH
58188: LD_INT 1
58190: NEG
58191: PUSH
58192: LD_INT 1
58194: PUSH
58195: EMPTY
58196: LIST
58197: LIST
58198: PUSH
58199: LD_INT 2
58201: NEG
58202: PUSH
58203: LD_INT 0
58205: PUSH
58206: EMPTY
58207: LIST
58208: LIST
58209: PUSH
58210: LD_INT 2
58212: NEG
58213: PUSH
58214: LD_INT 1
58216: NEG
58217: PUSH
58218: EMPTY
58219: LIST
58220: LIST
58221: PUSH
58222: LD_INT 2
58224: NEG
58225: PUSH
58226: LD_INT 2
58228: NEG
58229: PUSH
58230: EMPTY
58231: LIST
58232: LIST
58233: PUSH
58234: EMPTY
58235: LIST
58236: LIST
58237: LIST
58238: LIST
58239: LIST
58240: LIST
58241: LIST
58242: LIST
58243: LIST
58244: LIST
58245: LIST
58246: LIST
58247: LIST
58248: LIST
58249: LIST
58250: LIST
58251: LIST
58252: LIST
58253: LIST
58254: ST_TO_ADDR
// DepotRu0 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ - 2 , - 3 ] , [ - 1 , - 3 ] , [ 1 , - 2 ] , [ 2 , - 1 ] ] ;
58255: LD_ADDR_VAR 0 23
58259: PUSH
58260: LD_INT 0
58262: PUSH
58263: LD_INT 0
58265: PUSH
58266: EMPTY
58267: LIST
58268: LIST
58269: PUSH
58270: LD_INT 0
58272: PUSH
58273: LD_INT 1
58275: NEG
58276: PUSH
58277: EMPTY
58278: LIST
58279: LIST
58280: PUSH
58281: LD_INT 1
58283: PUSH
58284: LD_INT 0
58286: PUSH
58287: EMPTY
58288: LIST
58289: LIST
58290: PUSH
58291: LD_INT 1
58293: PUSH
58294: LD_INT 1
58296: PUSH
58297: EMPTY
58298: LIST
58299: LIST
58300: PUSH
58301: LD_INT 0
58303: PUSH
58304: LD_INT 1
58306: PUSH
58307: EMPTY
58308: LIST
58309: LIST
58310: PUSH
58311: LD_INT 1
58313: NEG
58314: PUSH
58315: LD_INT 0
58317: PUSH
58318: EMPTY
58319: LIST
58320: LIST
58321: PUSH
58322: LD_INT 1
58324: NEG
58325: PUSH
58326: LD_INT 1
58328: NEG
58329: PUSH
58330: EMPTY
58331: LIST
58332: LIST
58333: PUSH
58334: LD_INT 1
58336: NEG
58337: PUSH
58338: LD_INT 2
58340: NEG
58341: PUSH
58342: EMPTY
58343: LIST
58344: LIST
58345: PUSH
58346: LD_INT 0
58348: PUSH
58349: LD_INT 2
58351: NEG
58352: PUSH
58353: EMPTY
58354: LIST
58355: LIST
58356: PUSH
58357: LD_INT 1
58359: PUSH
58360: LD_INT 1
58362: NEG
58363: PUSH
58364: EMPTY
58365: LIST
58366: LIST
58367: PUSH
58368: LD_INT 2
58370: PUSH
58371: LD_INT 0
58373: PUSH
58374: EMPTY
58375: LIST
58376: LIST
58377: PUSH
58378: LD_INT 2
58380: PUSH
58381: LD_INT 1
58383: PUSH
58384: EMPTY
58385: LIST
58386: LIST
58387: PUSH
58388: LD_INT 2
58390: PUSH
58391: LD_INT 2
58393: PUSH
58394: EMPTY
58395: LIST
58396: LIST
58397: PUSH
58398: LD_INT 1
58400: PUSH
58401: LD_INT 2
58403: PUSH
58404: EMPTY
58405: LIST
58406: LIST
58407: PUSH
58408: LD_INT 0
58410: PUSH
58411: LD_INT 2
58413: PUSH
58414: EMPTY
58415: LIST
58416: LIST
58417: PUSH
58418: LD_INT 1
58420: NEG
58421: PUSH
58422: LD_INT 1
58424: PUSH
58425: EMPTY
58426: LIST
58427: LIST
58428: PUSH
58429: LD_INT 2
58431: NEG
58432: PUSH
58433: LD_INT 0
58435: PUSH
58436: EMPTY
58437: LIST
58438: LIST
58439: PUSH
58440: LD_INT 2
58442: NEG
58443: PUSH
58444: LD_INT 1
58446: NEG
58447: PUSH
58448: EMPTY
58449: LIST
58450: LIST
58451: PUSH
58452: LD_INT 2
58454: NEG
58455: PUSH
58456: LD_INT 2
58458: NEG
58459: PUSH
58460: EMPTY
58461: LIST
58462: LIST
58463: PUSH
58464: LD_INT 2
58466: NEG
58467: PUSH
58468: LD_INT 3
58470: NEG
58471: PUSH
58472: EMPTY
58473: LIST
58474: LIST
58475: PUSH
58476: LD_INT 1
58478: NEG
58479: PUSH
58480: LD_INT 3
58482: NEG
58483: PUSH
58484: EMPTY
58485: LIST
58486: LIST
58487: PUSH
58488: LD_INT 1
58490: PUSH
58491: LD_INT 2
58493: NEG
58494: PUSH
58495: EMPTY
58496: LIST
58497: LIST
58498: PUSH
58499: LD_INT 2
58501: PUSH
58502: LD_INT 1
58504: NEG
58505: PUSH
58506: EMPTY
58507: LIST
58508: LIST
58509: PUSH
58510: EMPTY
58511: LIST
58512: LIST
58513: LIST
58514: LIST
58515: LIST
58516: LIST
58517: LIST
58518: LIST
58519: LIST
58520: LIST
58521: LIST
58522: LIST
58523: LIST
58524: LIST
58525: LIST
58526: LIST
58527: LIST
58528: LIST
58529: LIST
58530: LIST
58531: LIST
58532: LIST
58533: LIST
58534: ST_TO_ADDR
// DepotRu1 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ 1 , - 2 ] , [ 2 , - 1 ] , [ 3 , 1 ] , [ 3 , 2 ] ] ;
58535: LD_ADDR_VAR 0 24
58539: PUSH
58540: LD_INT 0
58542: PUSH
58543: LD_INT 0
58545: PUSH
58546: EMPTY
58547: LIST
58548: LIST
58549: PUSH
58550: LD_INT 0
58552: PUSH
58553: LD_INT 1
58555: NEG
58556: PUSH
58557: EMPTY
58558: LIST
58559: LIST
58560: PUSH
58561: LD_INT 1
58563: PUSH
58564: LD_INT 0
58566: PUSH
58567: EMPTY
58568: LIST
58569: LIST
58570: PUSH
58571: LD_INT 1
58573: PUSH
58574: LD_INT 1
58576: PUSH
58577: EMPTY
58578: LIST
58579: LIST
58580: PUSH
58581: LD_INT 0
58583: PUSH
58584: LD_INT 1
58586: PUSH
58587: EMPTY
58588: LIST
58589: LIST
58590: PUSH
58591: LD_INT 1
58593: NEG
58594: PUSH
58595: LD_INT 0
58597: PUSH
58598: EMPTY
58599: LIST
58600: LIST
58601: PUSH
58602: LD_INT 1
58604: NEG
58605: PUSH
58606: LD_INT 1
58608: NEG
58609: PUSH
58610: EMPTY
58611: LIST
58612: LIST
58613: PUSH
58614: LD_INT 1
58616: NEG
58617: PUSH
58618: LD_INT 2
58620: NEG
58621: PUSH
58622: EMPTY
58623: LIST
58624: LIST
58625: PUSH
58626: LD_INT 0
58628: PUSH
58629: LD_INT 2
58631: NEG
58632: PUSH
58633: EMPTY
58634: LIST
58635: LIST
58636: PUSH
58637: LD_INT 1
58639: PUSH
58640: LD_INT 1
58642: NEG
58643: PUSH
58644: EMPTY
58645: LIST
58646: LIST
58647: PUSH
58648: LD_INT 2
58650: PUSH
58651: LD_INT 0
58653: PUSH
58654: EMPTY
58655: LIST
58656: LIST
58657: PUSH
58658: LD_INT 2
58660: PUSH
58661: LD_INT 1
58663: PUSH
58664: EMPTY
58665: LIST
58666: LIST
58667: PUSH
58668: LD_INT 2
58670: PUSH
58671: LD_INT 2
58673: PUSH
58674: EMPTY
58675: LIST
58676: LIST
58677: PUSH
58678: LD_INT 1
58680: PUSH
58681: LD_INT 2
58683: PUSH
58684: EMPTY
58685: LIST
58686: LIST
58687: PUSH
58688: LD_INT 0
58690: PUSH
58691: LD_INT 2
58693: PUSH
58694: EMPTY
58695: LIST
58696: LIST
58697: PUSH
58698: LD_INT 1
58700: NEG
58701: PUSH
58702: LD_INT 1
58704: PUSH
58705: EMPTY
58706: LIST
58707: LIST
58708: PUSH
58709: LD_INT 2
58711: NEG
58712: PUSH
58713: LD_INT 0
58715: PUSH
58716: EMPTY
58717: LIST
58718: LIST
58719: PUSH
58720: LD_INT 2
58722: NEG
58723: PUSH
58724: LD_INT 1
58726: NEG
58727: PUSH
58728: EMPTY
58729: LIST
58730: LIST
58731: PUSH
58732: LD_INT 2
58734: NEG
58735: PUSH
58736: LD_INT 2
58738: NEG
58739: PUSH
58740: EMPTY
58741: LIST
58742: LIST
58743: PUSH
58744: LD_INT 1
58746: PUSH
58747: LD_INT 2
58749: NEG
58750: PUSH
58751: EMPTY
58752: LIST
58753: LIST
58754: PUSH
58755: LD_INT 2
58757: PUSH
58758: LD_INT 1
58760: NEG
58761: PUSH
58762: EMPTY
58763: LIST
58764: LIST
58765: PUSH
58766: LD_INT 3
58768: PUSH
58769: LD_INT 1
58771: PUSH
58772: EMPTY
58773: LIST
58774: LIST
58775: PUSH
58776: LD_INT 3
58778: PUSH
58779: LD_INT 2
58781: PUSH
58782: EMPTY
58783: LIST
58784: LIST
58785: PUSH
58786: EMPTY
58787: LIST
58788: LIST
58789: LIST
58790: LIST
58791: LIST
58792: LIST
58793: LIST
58794: LIST
58795: LIST
58796: LIST
58797: LIST
58798: LIST
58799: LIST
58800: LIST
58801: LIST
58802: LIST
58803: LIST
58804: LIST
58805: LIST
58806: LIST
58807: LIST
58808: LIST
58809: LIST
58810: ST_TO_ADDR
// DepotRu2 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ 3 , 1 ] , [ 3 , 2 ] , [ 2 , 3 ] , [ 1 , 3 ] ] ;
58811: LD_ADDR_VAR 0 25
58815: PUSH
58816: LD_INT 0
58818: PUSH
58819: LD_INT 0
58821: PUSH
58822: EMPTY
58823: LIST
58824: LIST
58825: PUSH
58826: LD_INT 0
58828: PUSH
58829: LD_INT 1
58831: NEG
58832: PUSH
58833: EMPTY
58834: LIST
58835: LIST
58836: PUSH
58837: LD_INT 1
58839: PUSH
58840: LD_INT 0
58842: PUSH
58843: EMPTY
58844: LIST
58845: LIST
58846: PUSH
58847: LD_INT 1
58849: PUSH
58850: LD_INT 1
58852: PUSH
58853: EMPTY
58854: LIST
58855: LIST
58856: PUSH
58857: LD_INT 0
58859: PUSH
58860: LD_INT 1
58862: PUSH
58863: EMPTY
58864: LIST
58865: LIST
58866: PUSH
58867: LD_INT 1
58869: NEG
58870: PUSH
58871: LD_INT 0
58873: PUSH
58874: EMPTY
58875: LIST
58876: LIST
58877: PUSH
58878: LD_INT 1
58880: NEG
58881: PUSH
58882: LD_INT 1
58884: NEG
58885: PUSH
58886: EMPTY
58887: LIST
58888: LIST
58889: PUSH
58890: LD_INT 1
58892: NEG
58893: PUSH
58894: LD_INT 2
58896: NEG
58897: PUSH
58898: EMPTY
58899: LIST
58900: LIST
58901: PUSH
58902: LD_INT 0
58904: PUSH
58905: LD_INT 2
58907: NEG
58908: PUSH
58909: EMPTY
58910: LIST
58911: LIST
58912: PUSH
58913: LD_INT 1
58915: PUSH
58916: LD_INT 1
58918: NEG
58919: PUSH
58920: EMPTY
58921: LIST
58922: LIST
58923: PUSH
58924: LD_INT 2
58926: PUSH
58927: LD_INT 0
58929: PUSH
58930: EMPTY
58931: LIST
58932: LIST
58933: PUSH
58934: LD_INT 2
58936: PUSH
58937: LD_INT 1
58939: PUSH
58940: EMPTY
58941: LIST
58942: LIST
58943: PUSH
58944: LD_INT 2
58946: PUSH
58947: LD_INT 2
58949: PUSH
58950: EMPTY
58951: LIST
58952: LIST
58953: PUSH
58954: LD_INT 1
58956: PUSH
58957: LD_INT 2
58959: PUSH
58960: EMPTY
58961: LIST
58962: LIST
58963: PUSH
58964: LD_INT 0
58966: PUSH
58967: LD_INT 2
58969: PUSH
58970: EMPTY
58971: LIST
58972: LIST
58973: PUSH
58974: LD_INT 1
58976: NEG
58977: PUSH
58978: LD_INT 1
58980: PUSH
58981: EMPTY
58982: LIST
58983: LIST
58984: PUSH
58985: LD_INT 2
58987: NEG
58988: PUSH
58989: LD_INT 0
58991: PUSH
58992: EMPTY
58993: LIST
58994: LIST
58995: PUSH
58996: LD_INT 2
58998: NEG
58999: PUSH
59000: LD_INT 1
59002: NEG
59003: PUSH
59004: EMPTY
59005: LIST
59006: LIST
59007: PUSH
59008: LD_INT 2
59010: NEG
59011: PUSH
59012: LD_INT 2
59014: NEG
59015: PUSH
59016: EMPTY
59017: LIST
59018: LIST
59019: PUSH
59020: LD_INT 3
59022: PUSH
59023: LD_INT 1
59025: PUSH
59026: EMPTY
59027: LIST
59028: LIST
59029: PUSH
59030: LD_INT 3
59032: PUSH
59033: LD_INT 2
59035: PUSH
59036: EMPTY
59037: LIST
59038: LIST
59039: PUSH
59040: LD_INT 2
59042: PUSH
59043: LD_INT 3
59045: PUSH
59046: EMPTY
59047: LIST
59048: LIST
59049: PUSH
59050: LD_INT 1
59052: PUSH
59053: LD_INT 3
59055: PUSH
59056: EMPTY
59057: LIST
59058: LIST
59059: PUSH
59060: EMPTY
59061: LIST
59062: LIST
59063: LIST
59064: LIST
59065: LIST
59066: LIST
59067: LIST
59068: LIST
59069: LIST
59070: LIST
59071: LIST
59072: LIST
59073: LIST
59074: LIST
59075: LIST
59076: LIST
59077: LIST
59078: LIST
59079: LIST
59080: LIST
59081: LIST
59082: LIST
59083: LIST
59084: ST_TO_ADDR
// DepotRu3 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ 2 , 3 ] , [ 1 , 3 ] , [ - 1 , 2 ] , [ - 2 , 1 ] ] ;
59085: LD_ADDR_VAR 0 26
59089: PUSH
59090: LD_INT 0
59092: PUSH
59093: LD_INT 0
59095: PUSH
59096: EMPTY
59097: LIST
59098: LIST
59099: PUSH
59100: LD_INT 0
59102: PUSH
59103: LD_INT 1
59105: NEG
59106: PUSH
59107: EMPTY
59108: LIST
59109: LIST
59110: PUSH
59111: LD_INT 1
59113: PUSH
59114: LD_INT 0
59116: PUSH
59117: EMPTY
59118: LIST
59119: LIST
59120: PUSH
59121: LD_INT 1
59123: PUSH
59124: LD_INT 1
59126: PUSH
59127: EMPTY
59128: LIST
59129: LIST
59130: PUSH
59131: LD_INT 0
59133: PUSH
59134: LD_INT 1
59136: PUSH
59137: EMPTY
59138: LIST
59139: LIST
59140: PUSH
59141: LD_INT 1
59143: NEG
59144: PUSH
59145: LD_INT 0
59147: PUSH
59148: EMPTY
59149: LIST
59150: LIST
59151: PUSH
59152: LD_INT 1
59154: NEG
59155: PUSH
59156: LD_INT 1
59158: NEG
59159: PUSH
59160: EMPTY
59161: LIST
59162: LIST
59163: PUSH
59164: LD_INT 1
59166: NEG
59167: PUSH
59168: LD_INT 2
59170: NEG
59171: PUSH
59172: EMPTY
59173: LIST
59174: LIST
59175: PUSH
59176: LD_INT 0
59178: PUSH
59179: LD_INT 2
59181: NEG
59182: PUSH
59183: EMPTY
59184: LIST
59185: LIST
59186: PUSH
59187: LD_INT 1
59189: PUSH
59190: LD_INT 1
59192: NEG
59193: PUSH
59194: EMPTY
59195: LIST
59196: LIST
59197: PUSH
59198: LD_INT 2
59200: PUSH
59201: LD_INT 0
59203: PUSH
59204: EMPTY
59205: LIST
59206: LIST
59207: PUSH
59208: LD_INT 2
59210: PUSH
59211: LD_INT 1
59213: PUSH
59214: EMPTY
59215: LIST
59216: LIST
59217: PUSH
59218: LD_INT 2
59220: PUSH
59221: LD_INT 2
59223: PUSH
59224: EMPTY
59225: LIST
59226: LIST
59227: PUSH
59228: LD_INT 1
59230: PUSH
59231: LD_INT 2
59233: PUSH
59234: EMPTY
59235: LIST
59236: LIST
59237: PUSH
59238: LD_INT 0
59240: PUSH
59241: LD_INT 2
59243: PUSH
59244: EMPTY
59245: LIST
59246: LIST
59247: PUSH
59248: LD_INT 1
59250: NEG
59251: PUSH
59252: LD_INT 1
59254: PUSH
59255: EMPTY
59256: LIST
59257: LIST
59258: PUSH
59259: LD_INT 2
59261: NEG
59262: PUSH
59263: LD_INT 0
59265: PUSH
59266: EMPTY
59267: LIST
59268: LIST
59269: PUSH
59270: LD_INT 2
59272: NEG
59273: PUSH
59274: LD_INT 1
59276: NEG
59277: PUSH
59278: EMPTY
59279: LIST
59280: LIST
59281: PUSH
59282: LD_INT 2
59284: NEG
59285: PUSH
59286: LD_INT 2
59288: NEG
59289: PUSH
59290: EMPTY
59291: LIST
59292: LIST
59293: PUSH
59294: LD_INT 2
59296: PUSH
59297: LD_INT 3
59299: PUSH
59300: EMPTY
59301: LIST
59302: LIST
59303: PUSH
59304: LD_INT 1
59306: PUSH
59307: LD_INT 3
59309: PUSH
59310: EMPTY
59311: LIST
59312: LIST
59313: PUSH
59314: LD_INT 1
59316: NEG
59317: PUSH
59318: LD_INT 2
59320: PUSH
59321: EMPTY
59322: LIST
59323: LIST
59324: PUSH
59325: LD_INT 2
59327: NEG
59328: PUSH
59329: LD_INT 1
59331: PUSH
59332: EMPTY
59333: LIST
59334: LIST
59335: PUSH
59336: EMPTY
59337: LIST
59338: LIST
59339: LIST
59340: LIST
59341: LIST
59342: LIST
59343: LIST
59344: LIST
59345: LIST
59346: LIST
59347: LIST
59348: LIST
59349: LIST
59350: LIST
59351: LIST
59352: LIST
59353: LIST
59354: LIST
59355: LIST
59356: LIST
59357: LIST
59358: LIST
59359: LIST
59360: ST_TO_ADDR
// DepotRu4 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ - 1 , 2 ] , [ - 2 , 1 ] , [ - 3 , - 1 ] , [ - 3 , - 2 ] ] ;
59361: LD_ADDR_VAR 0 27
59365: PUSH
59366: LD_INT 0
59368: PUSH
59369: LD_INT 0
59371: PUSH
59372: EMPTY
59373: LIST
59374: LIST
59375: PUSH
59376: LD_INT 0
59378: PUSH
59379: LD_INT 1
59381: NEG
59382: PUSH
59383: EMPTY
59384: LIST
59385: LIST
59386: PUSH
59387: LD_INT 1
59389: PUSH
59390: LD_INT 0
59392: PUSH
59393: EMPTY
59394: LIST
59395: LIST
59396: PUSH
59397: LD_INT 1
59399: PUSH
59400: LD_INT 1
59402: PUSH
59403: EMPTY
59404: LIST
59405: LIST
59406: PUSH
59407: LD_INT 0
59409: PUSH
59410: LD_INT 1
59412: PUSH
59413: EMPTY
59414: LIST
59415: LIST
59416: PUSH
59417: LD_INT 1
59419: NEG
59420: PUSH
59421: LD_INT 0
59423: PUSH
59424: EMPTY
59425: LIST
59426: LIST
59427: PUSH
59428: LD_INT 1
59430: NEG
59431: PUSH
59432: LD_INT 1
59434: NEG
59435: PUSH
59436: EMPTY
59437: LIST
59438: LIST
59439: PUSH
59440: LD_INT 1
59442: NEG
59443: PUSH
59444: LD_INT 2
59446: NEG
59447: PUSH
59448: EMPTY
59449: LIST
59450: LIST
59451: PUSH
59452: LD_INT 0
59454: PUSH
59455: LD_INT 2
59457: NEG
59458: PUSH
59459: EMPTY
59460: LIST
59461: LIST
59462: PUSH
59463: LD_INT 1
59465: PUSH
59466: LD_INT 1
59468: NEG
59469: PUSH
59470: EMPTY
59471: LIST
59472: LIST
59473: PUSH
59474: LD_INT 2
59476: PUSH
59477: LD_INT 0
59479: PUSH
59480: EMPTY
59481: LIST
59482: LIST
59483: PUSH
59484: LD_INT 2
59486: PUSH
59487: LD_INT 1
59489: PUSH
59490: EMPTY
59491: LIST
59492: LIST
59493: PUSH
59494: LD_INT 2
59496: PUSH
59497: LD_INT 2
59499: PUSH
59500: EMPTY
59501: LIST
59502: LIST
59503: PUSH
59504: LD_INT 1
59506: PUSH
59507: LD_INT 2
59509: PUSH
59510: EMPTY
59511: LIST
59512: LIST
59513: PUSH
59514: LD_INT 0
59516: PUSH
59517: LD_INT 2
59519: PUSH
59520: EMPTY
59521: LIST
59522: LIST
59523: PUSH
59524: LD_INT 1
59526: NEG
59527: PUSH
59528: LD_INT 1
59530: PUSH
59531: EMPTY
59532: LIST
59533: LIST
59534: PUSH
59535: LD_INT 2
59537: NEG
59538: PUSH
59539: LD_INT 0
59541: PUSH
59542: EMPTY
59543: LIST
59544: LIST
59545: PUSH
59546: LD_INT 2
59548: NEG
59549: PUSH
59550: LD_INT 1
59552: NEG
59553: PUSH
59554: EMPTY
59555: LIST
59556: LIST
59557: PUSH
59558: LD_INT 2
59560: NEG
59561: PUSH
59562: LD_INT 2
59564: NEG
59565: PUSH
59566: EMPTY
59567: LIST
59568: LIST
59569: PUSH
59570: LD_INT 1
59572: NEG
59573: PUSH
59574: LD_INT 2
59576: PUSH
59577: EMPTY
59578: LIST
59579: LIST
59580: PUSH
59581: LD_INT 2
59583: NEG
59584: PUSH
59585: LD_INT 1
59587: PUSH
59588: EMPTY
59589: LIST
59590: LIST
59591: PUSH
59592: LD_INT 3
59594: NEG
59595: PUSH
59596: LD_INT 1
59598: NEG
59599: PUSH
59600: EMPTY
59601: LIST
59602: LIST
59603: PUSH
59604: LD_INT 3
59606: NEG
59607: PUSH
59608: LD_INT 2
59610: NEG
59611: PUSH
59612: EMPTY
59613: LIST
59614: LIST
59615: PUSH
59616: EMPTY
59617: LIST
59618: LIST
59619: LIST
59620: LIST
59621: LIST
59622: LIST
59623: LIST
59624: LIST
59625: LIST
59626: LIST
59627: LIST
59628: LIST
59629: LIST
59630: LIST
59631: LIST
59632: LIST
59633: LIST
59634: LIST
59635: LIST
59636: LIST
59637: LIST
59638: LIST
59639: LIST
59640: ST_TO_ADDR
// DepotRu5 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ - 2 , - 3 ] , [ - 1 , - 3 ] , [ - 3 , - 1 ] , [ - 3 , - 2 ] ] ;
59641: LD_ADDR_VAR 0 28
59645: PUSH
59646: LD_INT 0
59648: PUSH
59649: LD_INT 0
59651: PUSH
59652: EMPTY
59653: LIST
59654: LIST
59655: PUSH
59656: LD_INT 0
59658: PUSH
59659: LD_INT 1
59661: NEG
59662: PUSH
59663: EMPTY
59664: LIST
59665: LIST
59666: PUSH
59667: LD_INT 1
59669: PUSH
59670: LD_INT 0
59672: PUSH
59673: EMPTY
59674: LIST
59675: LIST
59676: PUSH
59677: LD_INT 1
59679: PUSH
59680: LD_INT 1
59682: PUSH
59683: EMPTY
59684: LIST
59685: LIST
59686: PUSH
59687: LD_INT 0
59689: PUSH
59690: LD_INT 1
59692: PUSH
59693: EMPTY
59694: LIST
59695: LIST
59696: PUSH
59697: LD_INT 1
59699: NEG
59700: PUSH
59701: LD_INT 0
59703: PUSH
59704: EMPTY
59705: LIST
59706: LIST
59707: PUSH
59708: LD_INT 1
59710: NEG
59711: PUSH
59712: LD_INT 1
59714: NEG
59715: PUSH
59716: EMPTY
59717: LIST
59718: LIST
59719: PUSH
59720: LD_INT 1
59722: NEG
59723: PUSH
59724: LD_INT 2
59726: NEG
59727: PUSH
59728: EMPTY
59729: LIST
59730: LIST
59731: PUSH
59732: LD_INT 0
59734: PUSH
59735: LD_INT 2
59737: NEG
59738: PUSH
59739: EMPTY
59740: LIST
59741: LIST
59742: PUSH
59743: LD_INT 1
59745: PUSH
59746: LD_INT 1
59748: NEG
59749: PUSH
59750: EMPTY
59751: LIST
59752: LIST
59753: PUSH
59754: LD_INT 2
59756: PUSH
59757: LD_INT 0
59759: PUSH
59760: EMPTY
59761: LIST
59762: LIST
59763: PUSH
59764: LD_INT 2
59766: PUSH
59767: LD_INT 1
59769: PUSH
59770: EMPTY
59771: LIST
59772: LIST
59773: PUSH
59774: LD_INT 2
59776: PUSH
59777: LD_INT 2
59779: PUSH
59780: EMPTY
59781: LIST
59782: LIST
59783: PUSH
59784: LD_INT 1
59786: PUSH
59787: LD_INT 2
59789: PUSH
59790: EMPTY
59791: LIST
59792: LIST
59793: PUSH
59794: LD_INT 0
59796: PUSH
59797: LD_INT 2
59799: PUSH
59800: EMPTY
59801: LIST
59802: LIST
59803: PUSH
59804: LD_INT 1
59806: NEG
59807: PUSH
59808: LD_INT 1
59810: PUSH
59811: EMPTY
59812: LIST
59813: LIST
59814: PUSH
59815: LD_INT 2
59817: NEG
59818: PUSH
59819: LD_INT 0
59821: PUSH
59822: EMPTY
59823: LIST
59824: LIST
59825: PUSH
59826: LD_INT 2
59828: NEG
59829: PUSH
59830: LD_INT 1
59832: NEG
59833: PUSH
59834: EMPTY
59835: LIST
59836: LIST
59837: PUSH
59838: LD_INT 2
59840: NEG
59841: PUSH
59842: LD_INT 2
59844: NEG
59845: PUSH
59846: EMPTY
59847: LIST
59848: LIST
59849: PUSH
59850: LD_INT 2
59852: NEG
59853: PUSH
59854: LD_INT 3
59856: NEG
59857: PUSH
59858: EMPTY
59859: LIST
59860: LIST
59861: PUSH
59862: LD_INT 1
59864: NEG
59865: PUSH
59866: LD_INT 3
59868: NEG
59869: PUSH
59870: EMPTY
59871: LIST
59872: LIST
59873: PUSH
59874: LD_INT 3
59876: NEG
59877: PUSH
59878: LD_INT 1
59880: NEG
59881: PUSH
59882: EMPTY
59883: LIST
59884: LIST
59885: PUSH
59886: LD_INT 3
59888: NEG
59889: PUSH
59890: LD_INT 2
59892: NEG
59893: PUSH
59894: EMPTY
59895: LIST
59896: LIST
59897: PUSH
59898: EMPTY
59899: LIST
59900: LIST
59901: LIST
59902: LIST
59903: LIST
59904: LIST
59905: LIST
59906: LIST
59907: LIST
59908: LIST
59909: LIST
59910: LIST
59911: LIST
59912: LIST
59913: LIST
59914: LIST
59915: LIST
59916: LIST
59917: LIST
59918: LIST
59919: LIST
59920: LIST
59921: LIST
59922: ST_TO_ADDR
// Factory0 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ - 2 , - 3 ] , [ 2 , - 1 ] , [ 3 , 1 ] , [ 1 , 3 ] , [ - 1 , 2 ] , [ - 3 , - 2 ] ] ;
59923: LD_ADDR_VAR 0 29
59927: PUSH
59928: LD_INT 0
59930: PUSH
59931: LD_INT 0
59933: PUSH
59934: EMPTY
59935: LIST
59936: LIST
59937: PUSH
59938: LD_INT 0
59940: PUSH
59941: LD_INT 1
59943: NEG
59944: PUSH
59945: EMPTY
59946: LIST
59947: LIST
59948: PUSH
59949: LD_INT 1
59951: PUSH
59952: LD_INT 0
59954: PUSH
59955: EMPTY
59956: LIST
59957: LIST
59958: PUSH
59959: LD_INT 1
59961: PUSH
59962: LD_INT 1
59964: PUSH
59965: EMPTY
59966: LIST
59967: LIST
59968: PUSH
59969: LD_INT 0
59971: PUSH
59972: LD_INT 1
59974: PUSH
59975: EMPTY
59976: LIST
59977: LIST
59978: PUSH
59979: LD_INT 1
59981: NEG
59982: PUSH
59983: LD_INT 0
59985: PUSH
59986: EMPTY
59987: LIST
59988: LIST
59989: PUSH
59990: LD_INT 1
59992: NEG
59993: PUSH
59994: LD_INT 1
59996: NEG
59997: PUSH
59998: EMPTY
59999: LIST
60000: LIST
60001: PUSH
60002: LD_INT 1
60004: NEG
60005: PUSH
60006: LD_INT 2
60008: NEG
60009: PUSH
60010: EMPTY
60011: LIST
60012: LIST
60013: PUSH
60014: LD_INT 0
60016: PUSH
60017: LD_INT 2
60019: NEG
60020: PUSH
60021: EMPTY
60022: LIST
60023: LIST
60024: PUSH
60025: LD_INT 1
60027: PUSH
60028: LD_INT 1
60030: NEG
60031: PUSH
60032: EMPTY
60033: LIST
60034: LIST
60035: PUSH
60036: LD_INT 2
60038: PUSH
60039: LD_INT 0
60041: PUSH
60042: EMPTY
60043: LIST
60044: LIST
60045: PUSH
60046: LD_INT 2
60048: PUSH
60049: LD_INT 1
60051: PUSH
60052: EMPTY
60053: LIST
60054: LIST
60055: PUSH
60056: LD_INT 1
60058: PUSH
60059: LD_INT 2
60061: PUSH
60062: EMPTY
60063: LIST
60064: LIST
60065: PUSH
60066: LD_INT 0
60068: PUSH
60069: LD_INT 2
60071: PUSH
60072: EMPTY
60073: LIST
60074: LIST
60075: PUSH
60076: LD_INT 1
60078: NEG
60079: PUSH
60080: LD_INT 1
60082: PUSH
60083: EMPTY
60084: LIST
60085: LIST
60086: PUSH
60087: LD_INT 2
60089: NEG
60090: PUSH
60091: LD_INT 1
60093: NEG
60094: PUSH
60095: EMPTY
60096: LIST
60097: LIST
60098: PUSH
60099: LD_INT 2
60101: NEG
60102: PUSH
60103: LD_INT 2
60105: NEG
60106: PUSH
60107: EMPTY
60108: LIST
60109: LIST
60110: PUSH
60111: LD_INT 2
60113: NEG
60114: PUSH
60115: LD_INT 3
60117: NEG
60118: PUSH
60119: EMPTY
60120: LIST
60121: LIST
60122: PUSH
60123: LD_INT 2
60125: PUSH
60126: LD_INT 1
60128: NEG
60129: PUSH
60130: EMPTY
60131: LIST
60132: LIST
60133: PUSH
60134: LD_INT 3
60136: PUSH
60137: LD_INT 1
60139: PUSH
60140: EMPTY
60141: LIST
60142: LIST
60143: PUSH
60144: LD_INT 1
60146: PUSH
60147: LD_INT 3
60149: PUSH
60150: EMPTY
60151: LIST
60152: LIST
60153: PUSH
60154: LD_INT 1
60156: NEG
60157: PUSH
60158: LD_INT 2
60160: PUSH
60161: EMPTY
60162: LIST
60163: LIST
60164: PUSH
60165: LD_INT 3
60167: NEG
60168: PUSH
60169: LD_INT 2
60171: NEG
60172: PUSH
60173: EMPTY
60174: LIST
60175: LIST
60176: PUSH
60177: EMPTY
60178: LIST
60179: LIST
60180: LIST
60181: LIST
60182: LIST
60183: LIST
60184: LIST
60185: LIST
60186: LIST
60187: LIST
60188: LIST
60189: LIST
60190: LIST
60191: LIST
60192: LIST
60193: LIST
60194: LIST
60195: LIST
60196: LIST
60197: LIST
60198: LIST
60199: LIST
60200: LIST
60201: ST_TO_ADDR
// Factory1 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 1 , - 3 ] , [ 1 , - 2 ] , [ 3 , 2 ] , [ 2 , 3 ] , [ - 2 , 1 ] , [ - 3 , - 1 ] ] ;
60202: LD_ADDR_VAR 0 30
60206: PUSH
60207: LD_INT 0
60209: PUSH
60210: LD_INT 0
60212: PUSH
60213: EMPTY
60214: LIST
60215: LIST
60216: PUSH
60217: LD_INT 0
60219: PUSH
60220: LD_INT 1
60222: NEG
60223: PUSH
60224: EMPTY
60225: LIST
60226: LIST
60227: PUSH
60228: LD_INT 1
60230: PUSH
60231: LD_INT 0
60233: PUSH
60234: EMPTY
60235: LIST
60236: LIST
60237: PUSH
60238: LD_INT 1
60240: PUSH
60241: LD_INT 1
60243: PUSH
60244: EMPTY
60245: LIST
60246: LIST
60247: PUSH
60248: LD_INT 0
60250: PUSH
60251: LD_INT 1
60253: PUSH
60254: EMPTY
60255: LIST
60256: LIST
60257: PUSH
60258: LD_INT 1
60260: NEG
60261: PUSH
60262: LD_INT 0
60264: PUSH
60265: EMPTY
60266: LIST
60267: LIST
60268: PUSH
60269: LD_INT 1
60271: NEG
60272: PUSH
60273: LD_INT 1
60275: NEG
60276: PUSH
60277: EMPTY
60278: LIST
60279: LIST
60280: PUSH
60281: LD_INT 1
60283: NEG
60284: PUSH
60285: LD_INT 2
60287: NEG
60288: PUSH
60289: EMPTY
60290: LIST
60291: LIST
60292: PUSH
60293: LD_INT 0
60295: PUSH
60296: LD_INT 2
60298: NEG
60299: PUSH
60300: EMPTY
60301: LIST
60302: LIST
60303: PUSH
60304: LD_INT 1
60306: PUSH
60307: LD_INT 1
60309: NEG
60310: PUSH
60311: EMPTY
60312: LIST
60313: LIST
60314: PUSH
60315: LD_INT 2
60317: PUSH
60318: LD_INT 0
60320: PUSH
60321: EMPTY
60322: LIST
60323: LIST
60324: PUSH
60325: LD_INT 2
60327: PUSH
60328: LD_INT 1
60330: PUSH
60331: EMPTY
60332: LIST
60333: LIST
60334: PUSH
60335: LD_INT 2
60337: PUSH
60338: LD_INT 2
60340: PUSH
60341: EMPTY
60342: LIST
60343: LIST
60344: PUSH
60345: LD_INT 1
60347: PUSH
60348: LD_INT 2
60350: PUSH
60351: EMPTY
60352: LIST
60353: LIST
60354: PUSH
60355: LD_INT 1
60357: NEG
60358: PUSH
60359: LD_INT 1
60361: PUSH
60362: EMPTY
60363: LIST
60364: LIST
60365: PUSH
60366: LD_INT 2
60368: NEG
60369: PUSH
60370: LD_INT 0
60372: PUSH
60373: EMPTY
60374: LIST
60375: LIST
60376: PUSH
60377: LD_INT 2
60379: NEG
60380: PUSH
60381: LD_INT 1
60383: NEG
60384: PUSH
60385: EMPTY
60386: LIST
60387: LIST
60388: PUSH
60389: LD_INT 1
60391: NEG
60392: PUSH
60393: LD_INT 3
60395: NEG
60396: PUSH
60397: EMPTY
60398: LIST
60399: LIST
60400: PUSH
60401: LD_INT 1
60403: PUSH
60404: LD_INT 2
60406: NEG
60407: PUSH
60408: EMPTY
60409: LIST
60410: LIST
60411: PUSH
60412: LD_INT 3
60414: PUSH
60415: LD_INT 2
60417: PUSH
60418: EMPTY
60419: LIST
60420: LIST
60421: PUSH
60422: LD_INT 2
60424: PUSH
60425: LD_INT 3
60427: PUSH
60428: EMPTY
60429: LIST
60430: LIST
60431: PUSH
60432: LD_INT 2
60434: NEG
60435: PUSH
60436: LD_INT 1
60438: PUSH
60439: EMPTY
60440: LIST
60441: LIST
60442: PUSH
60443: LD_INT 3
60445: NEG
60446: PUSH
60447: LD_INT 1
60449: NEG
60450: PUSH
60451: EMPTY
60452: LIST
60453: LIST
60454: PUSH
60455: EMPTY
60456: LIST
60457: LIST
60458: LIST
60459: LIST
60460: LIST
60461: LIST
60462: LIST
60463: LIST
60464: LIST
60465: LIST
60466: LIST
60467: LIST
60468: LIST
60469: LIST
60470: LIST
60471: LIST
60472: LIST
60473: LIST
60474: LIST
60475: LIST
60476: LIST
60477: LIST
60478: LIST
60479: ST_TO_ADDR
// Factory2 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ - 2 , - 3 ] , [ 2 , - 1 ] , [ 3 , 1 ] , [ 1 , 3 ] , [ - 1 , 2 ] , [ - 3 , - 2 ] ] ;
60480: LD_ADDR_VAR 0 31
60484: PUSH
60485: LD_INT 0
60487: PUSH
60488: LD_INT 0
60490: PUSH
60491: EMPTY
60492: LIST
60493: LIST
60494: PUSH
60495: LD_INT 0
60497: PUSH
60498: LD_INT 1
60500: NEG
60501: PUSH
60502: EMPTY
60503: LIST
60504: LIST
60505: PUSH
60506: LD_INT 1
60508: PUSH
60509: LD_INT 0
60511: PUSH
60512: EMPTY
60513: LIST
60514: LIST
60515: PUSH
60516: LD_INT 1
60518: PUSH
60519: LD_INT 1
60521: PUSH
60522: EMPTY
60523: LIST
60524: LIST
60525: PUSH
60526: LD_INT 0
60528: PUSH
60529: LD_INT 1
60531: PUSH
60532: EMPTY
60533: LIST
60534: LIST
60535: PUSH
60536: LD_INT 1
60538: NEG
60539: PUSH
60540: LD_INT 0
60542: PUSH
60543: EMPTY
60544: LIST
60545: LIST
60546: PUSH
60547: LD_INT 1
60549: NEG
60550: PUSH
60551: LD_INT 1
60553: NEG
60554: PUSH
60555: EMPTY
60556: LIST
60557: LIST
60558: PUSH
60559: LD_INT 1
60561: NEG
60562: PUSH
60563: LD_INT 2
60565: NEG
60566: PUSH
60567: EMPTY
60568: LIST
60569: LIST
60570: PUSH
60571: LD_INT 1
60573: PUSH
60574: LD_INT 1
60576: NEG
60577: PUSH
60578: EMPTY
60579: LIST
60580: LIST
60581: PUSH
60582: LD_INT 2
60584: PUSH
60585: LD_INT 0
60587: PUSH
60588: EMPTY
60589: LIST
60590: LIST
60591: PUSH
60592: LD_INT 2
60594: PUSH
60595: LD_INT 1
60597: PUSH
60598: EMPTY
60599: LIST
60600: LIST
60601: PUSH
60602: LD_INT 2
60604: PUSH
60605: LD_INT 2
60607: PUSH
60608: EMPTY
60609: LIST
60610: LIST
60611: PUSH
60612: LD_INT 1
60614: PUSH
60615: LD_INT 2
60617: PUSH
60618: EMPTY
60619: LIST
60620: LIST
60621: PUSH
60622: LD_INT 0
60624: PUSH
60625: LD_INT 2
60627: PUSH
60628: EMPTY
60629: LIST
60630: LIST
60631: PUSH
60632: LD_INT 1
60634: NEG
60635: PUSH
60636: LD_INT 1
60638: PUSH
60639: EMPTY
60640: LIST
60641: LIST
60642: PUSH
60643: LD_INT 2
60645: NEG
60646: PUSH
60647: LD_INT 1
60649: NEG
60650: PUSH
60651: EMPTY
60652: LIST
60653: LIST
60654: PUSH
60655: LD_INT 2
60657: NEG
60658: PUSH
60659: LD_INT 2
60661: NEG
60662: PUSH
60663: EMPTY
60664: LIST
60665: LIST
60666: PUSH
60667: LD_INT 2
60669: NEG
60670: PUSH
60671: LD_INT 3
60673: NEG
60674: PUSH
60675: EMPTY
60676: LIST
60677: LIST
60678: PUSH
60679: LD_INT 2
60681: PUSH
60682: LD_INT 1
60684: NEG
60685: PUSH
60686: EMPTY
60687: LIST
60688: LIST
60689: PUSH
60690: LD_INT 3
60692: PUSH
60693: LD_INT 1
60695: PUSH
60696: EMPTY
60697: LIST
60698: LIST
60699: PUSH
60700: LD_INT 1
60702: PUSH
60703: LD_INT 3
60705: PUSH
60706: EMPTY
60707: LIST
60708: LIST
60709: PUSH
60710: LD_INT 1
60712: NEG
60713: PUSH
60714: LD_INT 2
60716: PUSH
60717: EMPTY
60718: LIST
60719: LIST
60720: PUSH
60721: LD_INT 3
60723: NEG
60724: PUSH
60725: LD_INT 2
60727: NEG
60728: PUSH
60729: EMPTY
60730: LIST
60731: LIST
60732: PUSH
60733: EMPTY
60734: LIST
60735: LIST
60736: LIST
60737: LIST
60738: LIST
60739: LIST
60740: LIST
60741: LIST
60742: LIST
60743: LIST
60744: LIST
60745: LIST
60746: LIST
60747: LIST
60748: LIST
60749: LIST
60750: LIST
60751: LIST
60752: LIST
60753: LIST
60754: LIST
60755: LIST
60756: LIST
60757: ST_TO_ADDR
// Factory3 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 1 , - 3 ] , [ 1 , - 2 ] , [ 3 , 2 ] , [ 2 , 3 ] , [ - 2 , 1 ] , [ - 3 , - 1 ] ] ;
60758: LD_ADDR_VAR 0 32
60762: PUSH
60763: LD_INT 0
60765: PUSH
60766: LD_INT 0
60768: PUSH
60769: EMPTY
60770: LIST
60771: LIST
60772: PUSH
60773: LD_INT 0
60775: PUSH
60776: LD_INT 1
60778: NEG
60779: PUSH
60780: EMPTY
60781: LIST
60782: LIST
60783: PUSH
60784: LD_INT 1
60786: PUSH
60787: LD_INT 0
60789: PUSH
60790: EMPTY
60791: LIST
60792: LIST
60793: PUSH
60794: LD_INT 1
60796: PUSH
60797: LD_INT 1
60799: PUSH
60800: EMPTY
60801: LIST
60802: LIST
60803: PUSH
60804: LD_INT 0
60806: PUSH
60807: LD_INT 1
60809: PUSH
60810: EMPTY
60811: LIST
60812: LIST
60813: PUSH
60814: LD_INT 1
60816: NEG
60817: PUSH
60818: LD_INT 0
60820: PUSH
60821: EMPTY
60822: LIST
60823: LIST
60824: PUSH
60825: LD_INT 1
60827: NEG
60828: PUSH
60829: LD_INT 1
60831: NEG
60832: PUSH
60833: EMPTY
60834: LIST
60835: LIST
60836: PUSH
60837: LD_INT 1
60839: NEG
60840: PUSH
60841: LD_INT 2
60843: NEG
60844: PUSH
60845: EMPTY
60846: LIST
60847: LIST
60848: PUSH
60849: LD_INT 0
60851: PUSH
60852: LD_INT 2
60854: NEG
60855: PUSH
60856: EMPTY
60857: LIST
60858: LIST
60859: PUSH
60860: LD_INT 1
60862: PUSH
60863: LD_INT 1
60865: NEG
60866: PUSH
60867: EMPTY
60868: LIST
60869: LIST
60870: PUSH
60871: LD_INT 2
60873: PUSH
60874: LD_INT 1
60876: PUSH
60877: EMPTY
60878: LIST
60879: LIST
60880: PUSH
60881: LD_INT 2
60883: PUSH
60884: LD_INT 2
60886: PUSH
60887: EMPTY
60888: LIST
60889: LIST
60890: PUSH
60891: LD_INT 1
60893: PUSH
60894: LD_INT 2
60896: PUSH
60897: EMPTY
60898: LIST
60899: LIST
60900: PUSH
60901: LD_INT 0
60903: PUSH
60904: LD_INT 2
60906: PUSH
60907: EMPTY
60908: LIST
60909: LIST
60910: PUSH
60911: LD_INT 1
60913: NEG
60914: PUSH
60915: LD_INT 1
60917: PUSH
60918: EMPTY
60919: LIST
60920: LIST
60921: PUSH
60922: LD_INT 2
60924: NEG
60925: PUSH
60926: LD_INT 0
60928: PUSH
60929: EMPTY
60930: LIST
60931: LIST
60932: PUSH
60933: LD_INT 2
60935: NEG
60936: PUSH
60937: LD_INT 1
60939: NEG
60940: PUSH
60941: EMPTY
60942: LIST
60943: LIST
60944: PUSH
60945: LD_INT 1
60947: NEG
60948: PUSH
60949: LD_INT 3
60951: NEG
60952: PUSH
60953: EMPTY
60954: LIST
60955: LIST
60956: PUSH
60957: LD_INT 1
60959: PUSH
60960: LD_INT 2
60962: NEG
60963: PUSH
60964: EMPTY
60965: LIST
60966: LIST
60967: PUSH
60968: LD_INT 3
60970: PUSH
60971: LD_INT 2
60973: PUSH
60974: EMPTY
60975: LIST
60976: LIST
60977: PUSH
60978: LD_INT 2
60980: PUSH
60981: LD_INT 3
60983: PUSH
60984: EMPTY
60985: LIST
60986: LIST
60987: PUSH
60988: LD_INT 2
60990: NEG
60991: PUSH
60992: LD_INT 1
60994: PUSH
60995: EMPTY
60996: LIST
60997: LIST
60998: PUSH
60999: LD_INT 3
61001: NEG
61002: PUSH
61003: LD_INT 1
61005: NEG
61006: PUSH
61007: EMPTY
61008: LIST
61009: LIST
61010: PUSH
61011: EMPTY
61012: LIST
61013: LIST
61014: LIST
61015: LIST
61016: LIST
61017: LIST
61018: LIST
61019: LIST
61020: LIST
61021: LIST
61022: LIST
61023: LIST
61024: LIST
61025: LIST
61026: LIST
61027: LIST
61028: LIST
61029: LIST
61030: LIST
61031: LIST
61032: LIST
61033: LIST
61034: LIST
61035: ST_TO_ADDR
// Factory4 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ - 2 , - 3 ] , [ 2 , - 1 ] , [ 3 , 1 ] , [ 1 , 3 ] , [ - 1 , 2 ] , [ - 3 , - 2 ] ] ;
61036: LD_ADDR_VAR 0 33
61040: PUSH
61041: LD_INT 0
61043: PUSH
61044: LD_INT 0
61046: PUSH
61047: EMPTY
61048: LIST
61049: LIST
61050: PUSH
61051: LD_INT 0
61053: PUSH
61054: LD_INT 1
61056: NEG
61057: PUSH
61058: EMPTY
61059: LIST
61060: LIST
61061: PUSH
61062: LD_INT 1
61064: PUSH
61065: LD_INT 0
61067: PUSH
61068: EMPTY
61069: LIST
61070: LIST
61071: PUSH
61072: LD_INT 1
61074: PUSH
61075: LD_INT 1
61077: PUSH
61078: EMPTY
61079: LIST
61080: LIST
61081: PUSH
61082: LD_INT 0
61084: PUSH
61085: LD_INT 1
61087: PUSH
61088: EMPTY
61089: LIST
61090: LIST
61091: PUSH
61092: LD_INT 1
61094: NEG
61095: PUSH
61096: LD_INT 0
61098: PUSH
61099: EMPTY
61100: LIST
61101: LIST
61102: PUSH
61103: LD_INT 1
61105: NEG
61106: PUSH
61107: LD_INT 1
61109: NEG
61110: PUSH
61111: EMPTY
61112: LIST
61113: LIST
61114: PUSH
61115: LD_INT 1
61117: NEG
61118: PUSH
61119: LD_INT 2
61121: NEG
61122: PUSH
61123: EMPTY
61124: LIST
61125: LIST
61126: PUSH
61127: LD_INT 1
61129: PUSH
61130: LD_INT 1
61132: NEG
61133: PUSH
61134: EMPTY
61135: LIST
61136: LIST
61137: PUSH
61138: LD_INT 2
61140: PUSH
61141: LD_INT 0
61143: PUSH
61144: EMPTY
61145: LIST
61146: LIST
61147: PUSH
61148: LD_INT 2
61150: PUSH
61151: LD_INT 1
61153: PUSH
61154: EMPTY
61155: LIST
61156: LIST
61157: PUSH
61158: LD_INT 1
61160: PUSH
61161: LD_INT 2
61163: PUSH
61164: EMPTY
61165: LIST
61166: LIST
61167: PUSH
61168: LD_INT 0
61170: PUSH
61171: LD_INT 2
61173: PUSH
61174: EMPTY
61175: LIST
61176: LIST
61177: PUSH
61178: LD_INT 1
61180: NEG
61181: PUSH
61182: LD_INT 1
61184: PUSH
61185: EMPTY
61186: LIST
61187: LIST
61188: PUSH
61189: LD_INT 2
61191: NEG
61192: PUSH
61193: LD_INT 0
61195: PUSH
61196: EMPTY
61197: LIST
61198: LIST
61199: PUSH
61200: LD_INT 2
61202: NEG
61203: PUSH
61204: LD_INT 1
61206: NEG
61207: PUSH
61208: EMPTY
61209: LIST
61210: LIST
61211: PUSH
61212: LD_INT 2
61214: NEG
61215: PUSH
61216: LD_INT 2
61218: NEG
61219: PUSH
61220: EMPTY
61221: LIST
61222: LIST
61223: PUSH
61224: LD_INT 2
61226: NEG
61227: PUSH
61228: LD_INT 3
61230: NEG
61231: PUSH
61232: EMPTY
61233: LIST
61234: LIST
61235: PUSH
61236: LD_INT 2
61238: PUSH
61239: LD_INT 1
61241: NEG
61242: PUSH
61243: EMPTY
61244: LIST
61245: LIST
61246: PUSH
61247: LD_INT 3
61249: PUSH
61250: LD_INT 1
61252: PUSH
61253: EMPTY
61254: LIST
61255: LIST
61256: PUSH
61257: LD_INT 1
61259: PUSH
61260: LD_INT 3
61262: PUSH
61263: EMPTY
61264: LIST
61265: LIST
61266: PUSH
61267: LD_INT 1
61269: NEG
61270: PUSH
61271: LD_INT 2
61273: PUSH
61274: EMPTY
61275: LIST
61276: LIST
61277: PUSH
61278: LD_INT 3
61280: NEG
61281: PUSH
61282: LD_INT 2
61284: NEG
61285: PUSH
61286: EMPTY
61287: LIST
61288: LIST
61289: PUSH
61290: EMPTY
61291: LIST
61292: LIST
61293: LIST
61294: LIST
61295: LIST
61296: LIST
61297: LIST
61298: LIST
61299: LIST
61300: LIST
61301: LIST
61302: LIST
61303: LIST
61304: LIST
61305: LIST
61306: LIST
61307: LIST
61308: LIST
61309: LIST
61310: LIST
61311: LIST
61312: LIST
61313: LIST
61314: ST_TO_ADDR
// Factory5 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ - 1 , - 3 ] , [ 1 , - 2 ] , [ 3 , 2 ] , [ 2 , 3 ] , [ - 2 , 1 ] , [ - 3 , - 1 ] ] ;
61315: LD_ADDR_VAR 0 34
61319: PUSH
61320: LD_INT 0
61322: PUSH
61323: LD_INT 0
61325: PUSH
61326: EMPTY
61327: LIST
61328: LIST
61329: PUSH
61330: LD_INT 0
61332: PUSH
61333: LD_INT 1
61335: NEG
61336: PUSH
61337: EMPTY
61338: LIST
61339: LIST
61340: PUSH
61341: LD_INT 1
61343: PUSH
61344: LD_INT 0
61346: PUSH
61347: EMPTY
61348: LIST
61349: LIST
61350: PUSH
61351: LD_INT 1
61353: PUSH
61354: LD_INT 1
61356: PUSH
61357: EMPTY
61358: LIST
61359: LIST
61360: PUSH
61361: LD_INT 0
61363: PUSH
61364: LD_INT 1
61366: PUSH
61367: EMPTY
61368: LIST
61369: LIST
61370: PUSH
61371: LD_INT 1
61373: NEG
61374: PUSH
61375: LD_INT 0
61377: PUSH
61378: EMPTY
61379: LIST
61380: LIST
61381: PUSH
61382: LD_INT 1
61384: NEG
61385: PUSH
61386: LD_INT 1
61388: NEG
61389: PUSH
61390: EMPTY
61391: LIST
61392: LIST
61393: PUSH
61394: LD_INT 1
61396: NEG
61397: PUSH
61398: LD_INT 2
61400: NEG
61401: PUSH
61402: EMPTY
61403: LIST
61404: LIST
61405: PUSH
61406: LD_INT 0
61408: PUSH
61409: LD_INT 2
61411: NEG
61412: PUSH
61413: EMPTY
61414: LIST
61415: LIST
61416: PUSH
61417: LD_INT 1
61419: PUSH
61420: LD_INT 1
61422: NEG
61423: PUSH
61424: EMPTY
61425: LIST
61426: LIST
61427: PUSH
61428: LD_INT 2
61430: PUSH
61431: LD_INT 1
61433: PUSH
61434: EMPTY
61435: LIST
61436: LIST
61437: PUSH
61438: LD_INT 2
61440: PUSH
61441: LD_INT 2
61443: PUSH
61444: EMPTY
61445: LIST
61446: LIST
61447: PUSH
61448: LD_INT 1
61450: PUSH
61451: LD_INT 2
61453: PUSH
61454: EMPTY
61455: LIST
61456: LIST
61457: PUSH
61458: LD_INT 1
61460: NEG
61461: PUSH
61462: LD_INT 1
61464: PUSH
61465: EMPTY
61466: LIST
61467: LIST
61468: PUSH
61469: LD_INT 2
61471: NEG
61472: PUSH
61473: LD_INT 0
61475: PUSH
61476: EMPTY
61477: LIST
61478: LIST
61479: PUSH
61480: LD_INT 2
61482: NEG
61483: PUSH
61484: LD_INT 1
61486: NEG
61487: PUSH
61488: EMPTY
61489: LIST
61490: LIST
61491: PUSH
61492: LD_INT 2
61494: NEG
61495: PUSH
61496: LD_INT 2
61498: NEG
61499: PUSH
61500: EMPTY
61501: LIST
61502: LIST
61503: PUSH
61504: LD_INT 1
61506: NEG
61507: PUSH
61508: LD_INT 3
61510: NEG
61511: PUSH
61512: EMPTY
61513: LIST
61514: LIST
61515: PUSH
61516: LD_INT 1
61518: PUSH
61519: LD_INT 2
61521: NEG
61522: PUSH
61523: EMPTY
61524: LIST
61525: LIST
61526: PUSH
61527: LD_INT 3
61529: PUSH
61530: LD_INT 2
61532: PUSH
61533: EMPTY
61534: LIST
61535: LIST
61536: PUSH
61537: LD_INT 2
61539: PUSH
61540: LD_INT 3
61542: PUSH
61543: EMPTY
61544: LIST
61545: LIST
61546: PUSH
61547: LD_INT 2
61549: NEG
61550: PUSH
61551: LD_INT 1
61553: PUSH
61554: EMPTY
61555: LIST
61556: LIST
61557: PUSH
61558: LD_INT 3
61560: NEG
61561: PUSH
61562: LD_INT 1
61564: NEG
61565: PUSH
61566: EMPTY
61567: LIST
61568: LIST
61569: PUSH
61570: EMPTY
61571: LIST
61572: LIST
61573: LIST
61574: LIST
61575: LIST
61576: LIST
61577: LIST
61578: LIST
61579: LIST
61580: LIST
61581: LIST
61582: LIST
61583: LIST
61584: LIST
61585: LIST
61586: LIST
61587: LIST
61588: LIST
61589: LIST
61590: LIST
61591: LIST
61592: LIST
61593: LIST
61594: ST_TO_ADDR
// Ext0 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ 2 , 1 ] , [ - 2 , - 1 ] ] ;
61595: LD_ADDR_VAR 0 35
61599: PUSH
61600: LD_INT 0
61602: PUSH
61603: LD_INT 0
61605: PUSH
61606: EMPTY
61607: LIST
61608: LIST
61609: PUSH
61610: LD_INT 0
61612: PUSH
61613: LD_INT 1
61615: NEG
61616: PUSH
61617: EMPTY
61618: LIST
61619: LIST
61620: PUSH
61621: LD_INT 1
61623: PUSH
61624: LD_INT 0
61626: PUSH
61627: EMPTY
61628: LIST
61629: LIST
61630: PUSH
61631: LD_INT 1
61633: PUSH
61634: LD_INT 1
61636: PUSH
61637: EMPTY
61638: LIST
61639: LIST
61640: PUSH
61641: LD_INT 0
61643: PUSH
61644: LD_INT 1
61646: PUSH
61647: EMPTY
61648: LIST
61649: LIST
61650: PUSH
61651: LD_INT 1
61653: NEG
61654: PUSH
61655: LD_INT 0
61657: PUSH
61658: EMPTY
61659: LIST
61660: LIST
61661: PUSH
61662: LD_INT 1
61664: NEG
61665: PUSH
61666: LD_INT 1
61668: NEG
61669: PUSH
61670: EMPTY
61671: LIST
61672: LIST
61673: PUSH
61674: LD_INT 2
61676: PUSH
61677: LD_INT 1
61679: PUSH
61680: EMPTY
61681: LIST
61682: LIST
61683: PUSH
61684: LD_INT 2
61686: NEG
61687: PUSH
61688: LD_INT 1
61690: NEG
61691: PUSH
61692: EMPTY
61693: LIST
61694: LIST
61695: PUSH
61696: EMPTY
61697: LIST
61698: LIST
61699: LIST
61700: LIST
61701: LIST
61702: LIST
61703: LIST
61704: LIST
61705: LIST
61706: ST_TO_ADDR
// Ext1 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 1 , 2 ] ] ;
61707: LD_ADDR_VAR 0 36
61711: PUSH
61712: LD_INT 0
61714: PUSH
61715: LD_INT 0
61717: PUSH
61718: EMPTY
61719: LIST
61720: LIST
61721: PUSH
61722: LD_INT 0
61724: PUSH
61725: LD_INT 1
61727: NEG
61728: PUSH
61729: EMPTY
61730: LIST
61731: LIST
61732: PUSH
61733: LD_INT 1
61735: PUSH
61736: LD_INT 0
61738: PUSH
61739: EMPTY
61740: LIST
61741: LIST
61742: PUSH
61743: LD_INT 1
61745: PUSH
61746: LD_INT 1
61748: PUSH
61749: EMPTY
61750: LIST
61751: LIST
61752: PUSH
61753: LD_INT 0
61755: PUSH
61756: LD_INT 1
61758: PUSH
61759: EMPTY
61760: LIST
61761: LIST
61762: PUSH
61763: LD_INT 1
61765: NEG
61766: PUSH
61767: LD_INT 0
61769: PUSH
61770: EMPTY
61771: LIST
61772: LIST
61773: PUSH
61774: LD_INT 1
61776: NEG
61777: PUSH
61778: LD_INT 1
61780: NEG
61781: PUSH
61782: EMPTY
61783: LIST
61784: LIST
61785: PUSH
61786: LD_INT 1
61788: NEG
61789: PUSH
61790: LD_INT 2
61792: NEG
61793: PUSH
61794: EMPTY
61795: LIST
61796: LIST
61797: PUSH
61798: LD_INT 1
61800: PUSH
61801: LD_INT 2
61803: PUSH
61804: EMPTY
61805: LIST
61806: LIST
61807: PUSH
61808: EMPTY
61809: LIST
61810: LIST
61811: LIST
61812: LIST
61813: LIST
61814: LIST
61815: LIST
61816: LIST
61817: LIST
61818: ST_TO_ADDR
// Ext2 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ 1 , - 1 ] , [ - 1 , 1 ] ] ;
61819: LD_ADDR_VAR 0 37
61823: PUSH
61824: LD_INT 0
61826: PUSH
61827: LD_INT 0
61829: PUSH
61830: EMPTY
61831: LIST
61832: LIST
61833: PUSH
61834: LD_INT 0
61836: PUSH
61837: LD_INT 1
61839: NEG
61840: PUSH
61841: EMPTY
61842: LIST
61843: LIST
61844: PUSH
61845: LD_INT 1
61847: PUSH
61848: LD_INT 0
61850: PUSH
61851: EMPTY
61852: LIST
61853: LIST
61854: PUSH
61855: LD_INT 1
61857: PUSH
61858: LD_INT 1
61860: PUSH
61861: EMPTY
61862: LIST
61863: LIST
61864: PUSH
61865: LD_INT 0
61867: PUSH
61868: LD_INT 1
61870: PUSH
61871: EMPTY
61872: LIST
61873: LIST
61874: PUSH
61875: LD_INT 1
61877: NEG
61878: PUSH
61879: LD_INT 0
61881: PUSH
61882: EMPTY
61883: LIST
61884: LIST
61885: PUSH
61886: LD_INT 1
61888: NEG
61889: PUSH
61890: LD_INT 1
61892: NEG
61893: PUSH
61894: EMPTY
61895: LIST
61896: LIST
61897: PUSH
61898: LD_INT 1
61900: PUSH
61901: LD_INT 1
61903: NEG
61904: PUSH
61905: EMPTY
61906: LIST
61907: LIST
61908: PUSH
61909: LD_INT 1
61911: NEG
61912: PUSH
61913: LD_INT 1
61915: PUSH
61916: EMPTY
61917: LIST
61918: LIST
61919: PUSH
61920: EMPTY
61921: LIST
61922: LIST
61923: LIST
61924: LIST
61925: LIST
61926: LIST
61927: LIST
61928: LIST
61929: LIST
61930: ST_TO_ADDR
// Ext3 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ 2 , 1 ] , [ - 2 , - 1 ] ] ;
61931: LD_ADDR_VAR 0 38
61935: PUSH
61936: LD_INT 0
61938: PUSH
61939: LD_INT 0
61941: PUSH
61942: EMPTY
61943: LIST
61944: LIST
61945: PUSH
61946: LD_INT 0
61948: PUSH
61949: LD_INT 1
61951: NEG
61952: PUSH
61953: EMPTY
61954: LIST
61955: LIST
61956: PUSH
61957: LD_INT 1
61959: PUSH
61960: LD_INT 0
61962: PUSH
61963: EMPTY
61964: LIST
61965: LIST
61966: PUSH
61967: LD_INT 1
61969: PUSH
61970: LD_INT 1
61972: PUSH
61973: EMPTY
61974: LIST
61975: LIST
61976: PUSH
61977: LD_INT 0
61979: PUSH
61980: LD_INT 1
61982: PUSH
61983: EMPTY
61984: LIST
61985: LIST
61986: PUSH
61987: LD_INT 1
61989: NEG
61990: PUSH
61991: LD_INT 0
61993: PUSH
61994: EMPTY
61995: LIST
61996: LIST
61997: PUSH
61998: LD_INT 1
62000: NEG
62001: PUSH
62002: LD_INT 1
62004: NEG
62005: PUSH
62006: EMPTY
62007: LIST
62008: LIST
62009: PUSH
62010: LD_INT 2
62012: PUSH
62013: LD_INT 1
62015: PUSH
62016: EMPTY
62017: LIST
62018: LIST
62019: PUSH
62020: LD_INT 2
62022: NEG
62023: PUSH
62024: LD_INT 1
62026: NEG
62027: PUSH
62028: EMPTY
62029: LIST
62030: LIST
62031: PUSH
62032: EMPTY
62033: LIST
62034: LIST
62035: LIST
62036: LIST
62037: LIST
62038: LIST
62039: LIST
62040: LIST
62041: LIST
62042: ST_TO_ADDR
// Ext4 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 1 , 2 ] ] ;
62043: LD_ADDR_VAR 0 39
62047: PUSH
62048: LD_INT 0
62050: PUSH
62051: LD_INT 0
62053: PUSH
62054: EMPTY
62055: LIST
62056: LIST
62057: PUSH
62058: LD_INT 0
62060: PUSH
62061: LD_INT 1
62063: NEG
62064: PUSH
62065: EMPTY
62066: LIST
62067: LIST
62068: PUSH
62069: LD_INT 1
62071: PUSH
62072: LD_INT 0
62074: PUSH
62075: EMPTY
62076: LIST
62077: LIST
62078: PUSH
62079: LD_INT 1
62081: PUSH
62082: LD_INT 1
62084: PUSH
62085: EMPTY
62086: LIST
62087: LIST
62088: PUSH
62089: LD_INT 0
62091: PUSH
62092: LD_INT 1
62094: PUSH
62095: EMPTY
62096: LIST
62097: LIST
62098: PUSH
62099: LD_INT 1
62101: NEG
62102: PUSH
62103: LD_INT 0
62105: PUSH
62106: EMPTY
62107: LIST
62108: LIST
62109: PUSH
62110: LD_INT 1
62112: NEG
62113: PUSH
62114: LD_INT 1
62116: NEG
62117: PUSH
62118: EMPTY
62119: LIST
62120: LIST
62121: PUSH
62122: LD_INT 1
62124: NEG
62125: PUSH
62126: LD_INT 2
62128: NEG
62129: PUSH
62130: EMPTY
62131: LIST
62132: LIST
62133: PUSH
62134: LD_INT 1
62136: PUSH
62137: LD_INT 2
62139: PUSH
62140: EMPTY
62141: LIST
62142: LIST
62143: PUSH
62144: EMPTY
62145: LIST
62146: LIST
62147: LIST
62148: LIST
62149: LIST
62150: LIST
62151: LIST
62152: LIST
62153: LIST
62154: ST_TO_ADDR
// Ext5 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ 1 , - 1 ] , [ - 1 , 1 ] ] ;
62155: LD_ADDR_VAR 0 40
62159: PUSH
62160: LD_INT 0
62162: PUSH
62163: LD_INT 0
62165: PUSH
62166: EMPTY
62167: LIST
62168: LIST
62169: PUSH
62170: LD_INT 0
62172: PUSH
62173: LD_INT 1
62175: NEG
62176: PUSH
62177: EMPTY
62178: LIST
62179: LIST
62180: PUSH
62181: LD_INT 1
62183: PUSH
62184: LD_INT 0
62186: PUSH
62187: EMPTY
62188: LIST
62189: LIST
62190: PUSH
62191: LD_INT 1
62193: PUSH
62194: LD_INT 1
62196: PUSH
62197: EMPTY
62198: LIST
62199: LIST
62200: PUSH
62201: LD_INT 0
62203: PUSH
62204: LD_INT 1
62206: PUSH
62207: EMPTY
62208: LIST
62209: LIST
62210: PUSH
62211: LD_INT 1
62213: NEG
62214: PUSH
62215: LD_INT 0
62217: PUSH
62218: EMPTY
62219: LIST
62220: LIST
62221: PUSH
62222: LD_INT 1
62224: NEG
62225: PUSH
62226: LD_INT 1
62228: NEG
62229: PUSH
62230: EMPTY
62231: LIST
62232: LIST
62233: PUSH
62234: LD_INT 1
62236: PUSH
62237: LD_INT 1
62239: NEG
62240: PUSH
62241: EMPTY
62242: LIST
62243: LIST
62244: PUSH
62245: LD_INT 1
62247: NEG
62248: PUSH
62249: LD_INT 1
62251: PUSH
62252: EMPTY
62253: LIST
62254: LIST
62255: PUSH
62256: EMPTY
62257: LIST
62258: LIST
62259: LIST
62260: LIST
62261: LIST
62262: LIST
62263: LIST
62264: LIST
62265: LIST
62266: ST_TO_ADDR
// Lab0 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ - 2 , - 3 ] , [ 2 , - 1 ] , [ 3 , 0 ] , [ 3 , 1 ] , [ 3 , 2 ] , [ 3 , 3 ] , [ 2 , 3 ] , [ - 2 , 1 ] , [ - 3 , 0 ] , [ - 3 , - 1 ] , [ - 3 , - 2 ] , [ - 3 , - 3 ] ] ;
62267: LD_ADDR_VAR 0 41
62271: PUSH
62272: LD_INT 0
62274: PUSH
62275: LD_INT 0
62277: PUSH
62278: EMPTY
62279: LIST
62280: LIST
62281: PUSH
62282: LD_INT 0
62284: PUSH
62285: LD_INT 1
62287: NEG
62288: PUSH
62289: EMPTY
62290: LIST
62291: LIST
62292: PUSH
62293: LD_INT 1
62295: PUSH
62296: LD_INT 0
62298: PUSH
62299: EMPTY
62300: LIST
62301: LIST
62302: PUSH
62303: LD_INT 1
62305: PUSH
62306: LD_INT 1
62308: PUSH
62309: EMPTY
62310: LIST
62311: LIST
62312: PUSH
62313: LD_INT 0
62315: PUSH
62316: LD_INT 1
62318: PUSH
62319: EMPTY
62320: LIST
62321: LIST
62322: PUSH
62323: LD_INT 1
62325: NEG
62326: PUSH
62327: LD_INT 0
62329: PUSH
62330: EMPTY
62331: LIST
62332: LIST
62333: PUSH
62334: LD_INT 1
62336: NEG
62337: PUSH
62338: LD_INT 1
62340: NEG
62341: PUSH
62342: EMPTY
62343: LIST
62344: LIST
62345: PUSH
62346: LD_INT 1
62348: NEG
62349: PUSH
62350: LD_INT 2
62352: NEG
62353: PUSH
62354: EMPTY
62355: LIST
62356: LIST
62357: PUSH
62358: LD_INT 1
62360: PUSH
62361: LD_INT 1
62363: NEG
62364: PUSH
62365: EMPTY
62366: LIST
62367: LIST
62368: PUSH
62369: LD_INT 2
62371: PUSH
62372: LD_INT 0
62374: PUSH
62375: EMPTY
62376: LIST
62377: LIST
62378: PUSH
62379: LD_INT 2
62381: PUSH
62382: LD_INT 1
62384: PUSH
62385: EMPTY
62386: LIST
62387: LIST
62388: PUSH
62389: LD_INT 2
62391: PUSH
62392: LD_INT 2
62394: PUSH
62395: EMPTY
62396: LIST
62397: LIST
62398: PUSH
62399: LD_INT 1
62401: PUSH
62402: LD_INT 2
62404: PUSH
62405: EMPTY
62406: LIST
62407: LIST
62408: PUSH
62409: LD_INT 1
62411: NEG
62412: PUSH
62413: LD_INT 1
62415: PUSH
62416: EMPTY
62417: LIST
62418: LIST
62419: PUSH
62420: LD_INT 2
62422: NEG
62423: PUSH
62424: LD_INT 0
62426: PUSH
62427: EMPTY
62428: LIST
62429: LIST
62430: PUSH
62431: LD_INT 2
62433: NEG
62434: PUSH
62435: LD_INT 1
62437: NEG
62438: PUSH
62439: EMPTY
62440: LIST
62441: LIST
62442: PUSH
62443: LD_INT 2
62445: NEG
62446: PUSH
62447: LD_INT 2
62449: NEG
62450: PUSH
62451: EMPTY
62452: LIST
62453: LIST
62454: PUSH
62455: LD_INT 2
62457: NEG
62458: PUSH
62459: LD_INT 3
62461: NEG
62462: PUSH
62463: EMPTY
62464: LIST
62465: LIST
62466: PUSH
62467: LD_INT 2
62469: PUSH
62470: LD_INT 1
62472: NEG
62473: PUSH
62474: EMPTY
62475: LIST
62476: LIST
62477: PUSH
62478: LD_INT 3
62480: PUSH
62481: LD_INT 0
62483: PUSH
62484: EMPTY
62485: LIST
62486: LIST
62487: PUSH
62488: LD_INT 3
62490: PUSH
62491: LD_INT 1
62493: PUSH
62494: EMPTY
62495: LIST
62496: LIST
62497: PUSH
62498: LD_INT 3
62500: PUSH
62501: LD_INT 2
62503: PUSH
62504: EMPTY
62505: LIST
62506: LIST
62507: PUSH
62508: LD_INT 3
62510: PUSH
62511: LD_INT 3
62513: PUSH
62514: EMPTY
62515: LIST
62516: LIST
62517: PUSH
62518: LD_INT 2
62520: PUSH
62521: LD_INT 3
62523: PUSH
62524: EMPTY
62525: LIST
62526: LIST
62527: PUSH
62528: LD_INT 2
62530: NEG
62531: PUSH
62532: LD_INT 1
62534: PUSH
62535: EMPTY
62536: LIST
62537: LIST
62538: PUSH
62539: LD_INT 3
62541: NEG
62542: PUSH
62543: LD_INT 0
62545: PUSH
62546: EMPTY
62547: LIST
62548: LIST
62549: PUSH
62550: LD_INT 3
62552: NEG
62553: PUSH
62554: LD_INT 1
62556: NEG
62557: PUSH
62558: EMPTY
62559: LIST
62560: LIST
62561: PUSH
62562: LD_INT 3
62564: NEG
62565: PUSH
62566: LD_INT 2
62568: NEG
62569: PUSH
62570: EMPTY
62571: LIST
62572: LIST
62573: PUSH
62574: LD_INT 3
62576: NEG
62577: PUSH
62578: LD_INT 3
62580: NEG
62581: PUSH
62582: EMPTY
62583: LIST
62584: LIST
62585: PUSH
62586: EMPTY
62587: LIST
62588: LIST
62589: LIST
62590: LIST
62591: LIST
62592: LIST
62593: LIST
62594: LIST
62595: LIST
62596: LIST
62597: LIST
62598: LIST
62599: LIST
62600: LIST
62601: LIST
62602: LIST
62603: LIST
62604: LIST
62605: LIST
62606: LIST
62607: LIST
62608: LIST
62609: LIST
62610: LIST
62611: LIST
62612: LIST
62613: LIST
62614: LIST
62615: LIST
62616: ST_TO_ADDR
// Lab1 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ - 2 , - 3 ] , [ - 1 , - 3 ] , [ 0 , - 3 ] , [ 1 , - 2 ] , [ 3 , 2 ] , [ 3 , 3 ] , [ 2 , 3 ] , [ 1 , 3 ] , [ 0 , 3 ] , [ - 1 , 2 ] , [ - 3 , - 2 ] , [ - 3 , - 3 ] ] ;
62617: LD_ADDR_VAR 0 42
62621: PUSH
62622: LD_INT 0
62624: PUSH
62625: LD_INT 0
62627: PUSH
62628: EMPTY
62629: LIST
62630: LIST
62631: PUSH
62632: LD_INT 0
62634: PUSH
62635: LD_INT 1
62637: NEG
62638: PUSH
62639: EMPTY
62640: LIST
62641: LIST
62642: PUSH
62643: LD_INT 1
62645: PUSH
62646: LD_INT 0
62648: PUSH
62649: EMPTY
62650: LIST
62651: LIST
62652: PUSH
62653: LD_INT 1
62655: PUSH
62656: LD_INT 1
62658: PUSH
62659: EMPTY
62660: LIST
62661: LIST
62662: PUSH
62663: LD_INT 0
62665: PUSH
62666: LD_INT 1
62668: PUSH
62669: EMPTY
62670: LIST
62671: LIST
62672: PUSH
62673: LD_INT 1
62675: NEG
62676: PUSH
62677: LD_INT 0
62679: PUSH
62680: EMPTY
62681: LIST
62682: LIST
62683: PUSH
62684: LD_INT 1
62686: NEG
62687: PUSH
62688: LD_INT 1
62690: NEG
62691: PUSH
62692: EMPTY
62693: LIST
62694: LIST
62695: PUSH
62696: LD_INT 1
62698: NEG
62699: PUSH
62700: LD_INT 2
62702: NEG
62703: PUSH
62704: EMPTY
62705: LIST
62706: LIST
62707: PUSH
62708: LD_INT 0
62710: PUSH
62711: LD_INT 2
62713: NEG
62714: PUSH
62715: EMPTY
62716: LIST
62717: LIST
62718: PUSH
62719: LD_INT 1
62721: PUSH
62722: LD_INT 1
62724: NEG
62725: PUSH
62726: EMPTY
62727: LIST
62728: LIST
62729: PUSH
62730: LD_INT 2
62732: PUSH
62733: LD_INT 1
62735: PUSH
62736: EMPTY
62737: LIST
62738: LIST
62739: PUSH
62740: LD_INT 2
62742: PUSH
62743: LD_INT 2
62745: PUSH
62746: EMPTY
62747: LIST
62748: LIST
62749: PUSH
62750: LD_INT 1
62752: PUSH
62753: LD_INT 2
62755: PUSH
62756: EMPTY
62757: LIST
62758: LIST
62759: PUSH
62760: LD_INT 0
62762: PUSH
62763: LD_INT 2
62765: PUSH
62766: EMPTY
62767: LIST
62768: LIST
62769: PUSH
62770: LD_INT 1
62772: NEG
62773: PUSH
62774: LD_INT 1
62776: PUSH
62777: EMPTY
62778: LIST
62779: LIST
62780: PUSH
62781: LD_INT 2
62783: NEG
62784: PUSH
62785: LD_INT 1
62787: NEG
62788: PUSH
62789: EMPTY
62790: LIST
62791: LIST
62792: PUSH
62793: LD_INT 2
62795: NEG
62796: PUSH
62797: LD_INT 2
62799: NEG
62800: PUSH
62801: EMPTY
62802: LIST
62803: LIST
62804: PUSH
62805: LD_INT 2
62807: NEG
62808: PUSH
62809: LD_INT 3
62811: NEG
62812: PUSH
62813: EMPTY
62814: LIST
62815: LIST
62816: PUSH
62817: LD_INT 1
62819: NEG
62820: PUSH
62821: LD_INT 3
62823: NEG
62824: PUSH
62825: EMPTY
62826: LIST
62827: LIST
62828: PUSH
62829: LD_INT 0
62831: PUSH
62832: LD_INT 3
62834: NEG
62835: PUSH
62836: EMPTY
62837: LIST
62838: LIST
62839: PUSH
62840: LD_INT 1
62842: PUSH
62843: LD_INT 2
62845: NEG
62846: PUSH
62847: EMPTY
62848: LIST
62849: LIST
62850: PUSH
62851: LD_INT 3
62853: PUSH
62854: LD_INT 2
62856: PUSH
62857: EMPTY
62858: LIST
62859: LIST
62860: PUSH
62861: LD_INT 3
62863: PUSH
62864: LD_INT 3
62866: PUSH
62867: EMPTY
62868: LIST
62869: LIST
62870: PUSH
62871: LD_INT 2
62873: PUSH
62874: LD_INT 3
62876: PUSH
62877: EMPTY
62878: LIST
62879: LIST
62880: PUSH
62881: LD_INT 1
62883: PUSH
62884: LD_INT 3
62886: PUSH
62887: EMPTY
62888: LIST
62889: LIST
62890: PUSH
62891: LD_INT 0
62893: PUSH
62894: LD_INT 3
62896: PUSH
62897: EMPTY
62898: LIST
62899: LIST
62900: PUSH
62901: LD_INT 1
62903: NEG
62904: PUSH
62905: LD_INT 2
62907: PUSH
62908: EMPTY
62909: LIST
62910: LIST
62911: PUSH
62912: LD_INT 3
62914: NEG
62915: PUSH
62916: LD_INT 2
62918: NEG
62919: PUSH
62920: EMPTY
62921: LIST
62922: LIST
62923: PUSH
62924: LD_INT 3
62926: NEG
62927: PUSH
62928: LD_INT 3
62930: NEG
62931: PUSH
62932: EMPTY
62933: LIST
62934: LIST
62935: PUSH
62936: EMPTY
62937: LIST
62938: LIST
62939: LIST
62940: LIST
62941: LIST
62942: LIST
62943: LIST
62944: LIST
62945: LIST
62946: LIST
62947: LIST
62948: LIST
62949: LIST
62950: LIST
62951: LIST
62952: LIST
62953: LIST
62954: LIST
62955: LIST
62956: LIST
62957: LIST
62958: LIST
62959: LIST
62960: LIST
62961: LIST
62962: LIST
62963: LIST
62964: LIST
62965: LIST
62966: ST_TO_ADDR
// Lab2 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 1 , - 3 ] , [ 0 , - 3 ] , [ 1 , - 2 ] , [ 2 , - 1 ] , [ 3 , 0 ] , [ 3 , 1 ] , [ 1 , 3 ] , [ 0 , 3 ] , [ - 1 , 2 ] , [ - 2 , 1 ] , [ - 3 , 0 ] , [ - 3 , - 1 ] ] ;
62967: LD_ADDR_VAR 0 43
62971: PUSH
62972: LD_INT 0
62974: PUSH
62975: LD_INT 0
62977: PUSH
62978: EMPTY
62979: LIST
62980: LIST
62981: PUSH
62982: LD_INT 0
62984: PUSH
62985: LD_INT 1
62987: NEG
62988: PUSH
62989: EMPTY
62990: LIST
62991: LIST
62992: PUSH
62993: LD_INT 1
62995: PUSH
62996: LD_INT 0
62998: PUSH
62999: EMPTY
63000: LIST
63001: LIST
63002: PUSH
63003: LD_INT 1
63005: PUSH
63006: LD_INT 1
63008: PUSH
63009: EMPTY
63010: LIST
63011: LIST
63012: PUSH
63013: LD_INT 0
63015: PUSH
63016: LD_INT 1
63018: PUSH
63019: EMPTY
63020: LIST
63021: LIST
63022: PUSH
63023: LD_INT 1
63025: NEG
63026: PUSH
63027: LD_INT 0
63029: PUSH
63030: EMPTY
63031: LIST
63032: LIST
63033: PUSH
63034: LD_INT 1
63036: NEG
63037: PUSH
63038: LD_INT 1
63040: NEG
63041: PUSH
63042: EMPTY
63043: LIST
63044: LIST
63045: PUSH
63046: LD_INT 1
63048: NEG
63049: PUSH
63050: LD_INT 2
63052: NEG
63053: PUSH
63054: EMPTY
63055: LIST
63056: LIST
63057: PUSH
63058: LD_INT 0
63060: PUSH
63061: LD_INT 2
63063: NEG
63064: PUSH
63065: EMPTY
63066: LIST
63067: LIST
63068: PUSH
63069: LD_INT 1
63071: PUSH
63072: LD_INT 1
63074: NEG
63075: PUSH
63076: EMPTY
63077: LIST
63078: LIST
63079: PUSH
63080: LD_INT 2
63082: PUSH
63083: LD_INT 0
63085: PUSH
63086: EMPTY
63087: LIST
63088: LIST
63089: PUSH
63090: LD_INT 2
63092: PUSH
63093: LD_INT 1
63095: PUSH
63096: EMPTY
63097: LIST
63098: LIST
63099: PUSH
63100: LD_INT 1
63102: PUSH
63103: LD_INT 2
63105: PUSH
63106: EMPTY
63107: LIST
63108: LIST
63109: PUSH
63110: LD_INT 0
63112: PUSH
63113: LD_INT 2
63115: PUSH
63116: EMPTY
63117: LIST
63118: LIST
63119: PUSH
63120: LD_INT 1
63122: NEG
63123: PUSH
63124: LD_INT 1
63126: PUSH
63127: EMPTY
63128: LIST
63129: LIST
63130: PUSH
63131: LD_INT 2
63133: NEG
63134: PUSH
63135: LD_INT 0
63137: PUSH
63138: EMPTY
63139: LIST
63140: LIST
63141: PUSH
63142: LD_INT 2
63144: NEG
63145: PUSH
63146: LD_INT 1
63148: NEG
63149: PUSH
63150: EMPTY
63151: LIST
63152: LIST
63153: PUSH
63154: LD_INT 1
63156: NEG
63157: PUSH
63158: LD_INT 3
63160: NEG
63161: PUSH
63162: EMPTY
63163: LIST
63164: LIST
63165: PUSH
63166: LD_INT 0
63168: PUSH
63169: LD_INT 3
63171: NEG
63172: PUSH
63173: EMPTY
63174: LIST
63175: LIST
63176: PUSH
63177: LD_INT 1
63179: PUSH
63180: LD_INT 2
63182: NEG
63183: PUSH
63184: EMPTY
63185: LIST
63186: LIST
63187: PUSH
63188: LD_INT 2
63190: PUSH
63191: LD_INT 1
63193: NEG
63194: PUSH
63195: EMPTY
63196: LIST
63197: LIST
63198: PUSH
63199: LD_INT 3
63201: PUSH
63202: LD_INT 0
63204: PUSH
63205: EMPTY
63206: LIST
63207: LIST
63208: PUSH
63209: LD_INT 3
63211: PUSH
63212: LD_INT 1
63214: PUSH
63215: EMPTY
63216: LIST
63217: LIST
63218: PUSH
63219: LD_INT 1
63221: PUSH
63222: LD_INT 3
63224: PUSH
63225: EMPTY
63226: LIST
63227: LIST
63228: PUSH
63229: LD_INT 0
63231: PUSH
63232: LD_INT 3
63234: PUSH
63235: EMPTY
63236: LIST
63237: LIST
63238: PUSH
63239: LD_INT 1
63241: NEG
63242: PUSH
63243: LD_INT 2
63245: PUSH
63246: EMPTY
63247: LIST
63248: LIST
63249: PUSH
63250: LD_INT 2
63252: NEG
63253: PUSH
63254: LD_INT 1
63256: PUSH
63257: EMPTY
63258: LIST
63259: LIST
63260: PUSH
63261: LD_INT 3
63263: NEG
63264: PUSH
63265: LD_INT 0
63267: PUSH
63268: EMPTY
63269: LIST
63270: LIST
63271: PUSH
63272: LD_INT 3
63274: NEG
63275: PUSH
63276: LD_INT 1
63278: NEG
63279: PUSH
63280: EMPTY
63281: LIST
63282: LIST
63283: PUSH
63284: EMPTY
63285: LIST
63286: LIST
63287: LIST
63288: LIST
63289: LIST
63290: LIST
63291: LIST
63292: LIST
63293: LIST
63294: LIST
63295: LIST
63296: LIST
63297: LIST
63298: LIST
63299: LIST
63300: LIST
63301: LIST
63302: LIST
63303: LIST
63304: LIST
63305: LIST
63306: LIST
63307: LIST
63308: LIST
63309: LIST
63310: LIST
63311: LIST
63312: LIST
63313: LIST
63314: ST_TO_ADDR
// Lab3 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ - 2 , - 3 ] , [ 2 , - 1 ] , [ 3 , 0 ] , [ 3 , 1 ] , [ 3 , 2 ] , [ 3 , 3 ] , [ 2 , 3 ] , [ - 2 , 1 ] , [ - 3 , 0 ] , [ - 3 , - 1 ] , [ - 3 , - 2 ] , [ - 3 , - 3 ] ] ;
63315: LD_ADDR_VAR 0 44
63319: PUSH
63320: LD_INT 0
63322: PUSH
63323: LD_INT 0
63325: PUSH
63326: EMPTY
63327: LIST
63328: LIST
63329: PUSH
63330: LD_INT 0
63332: PUSH
63333: LD_INT 1
63335: NEG
63336: PUSH
63337: EMPTY
63338: LIST
63339: LIST
63340: PUSH
63341: LD_INT 1
63343: PUSH
63344: LD_INT 0
63346: PUSH
63347: EMPTY
63348: LIST
63349: LIST
63350: PUSH
63351: LD_INT 1
63353: PUSH
63354: LD_INT 1
63356: PUSH
63357: EMPTY
63358: LIST
63359: LIST
63360: PUSH
63361: LD_INT 0
63363: PUSH
63364: LD_INT 1
63366: PUSH
63367: EMPTY
63368: LIST
63369: LIST
63370: PUSH
63371: LD_INT 1
63373: NEG
63374: PUSH
63375: LD_INT 0
63377: PUSH
63378: EMPTY
63379: LIST
63380: LIST
63381: PUSH
63382: LD_INT 1
63384: NEG
63385: PUSH
63386: LD_INT 1
63388: NEG
63389: PUSH
63390: EMPTY
63391: LIST
63392: LIST
63393: PUSH
63394: LD_INT 1
63396: NEG
63397: PUSH
63398: LD_INT 2
63400: NEG
63401: PUSH
63402: EMPTY
63403: LIST
63404: LIST
63405: PUSH
63406: LD_INT 1
63408: PUSH
63409: LD_INT 1
63411: NEG
63412: PUSH
63413: EMPTY
63414: LIST
63415: LIST
63416: PUSH
63417: LD_INT 2
63419: PUSH
63420: LD_INT 0
63422: PUSH
63423: EMPTY
63424: LIST
63425: LIST
63426: PUSH
63427: LD_INT 2
63429: PUSH
63430: LD_INT 1
63432: PUSH
63433: EMPTY
63434: LIST
63435: LIST
63436: PUSH
63437: LD_INT 2
63439: PUSH
63440: LD_INT 2
63442: PUSH
63443: EMPTY
63444: LIST
63445: LIST
63446: PUSH
63447: LD_INT 1
63449: PUSH
63450: LD_INT 2
63452: PUSH
63453: EMPTY
63454: LIST
63455: LIST
63456: PUSH
63457: LD_INT 1
63459: NEG
63460: PUSH
63461: LD_INT 1
63463: PUSH
63464: EMPTY
63465: LIST
63466: LIST
63467: PUSH
63468: LD_INT 2
63470: NEG
63471: PUSH
63472: LD_INT 0
63474: PUSH
63475: EMPTY
63476: LIST
63477: LIST
63478: PUSH
63479: LD_INT 2
63481: NEG
63482: PUSH
63483: LD_INT 1
63485: NEG
63486: PUSH
63487: EMPTY
63488: LIST
63489: LIST
63490: PUSH
63491: LD_INT 2
63493: NEG
63494: PUSH
63495: LD_INT 2
63497: NEG
63498: PUSH
63499: EMPTY
63500: LIST
63501: LIST
63502: PUSH
63503: LD_INT 2
63505: NEG
63506: PUSH
63507: LD_INT 3
63509: NEG
63510: PUSH
63511: EMPTY
63512: LIST
63513: LIST
63514: PUSH
63515: LD_INT 2
63517: PUSH
63518: LD_INT 1
63520: NEG
63521: PUSH
63522: EMPTY
63523: LIST
63524: LIST
63525: PUSH
63526: LD_INT 3
63528: PUSH
63529: LD_INT 0
63531: PUSH
63532: EMPTY
63533: LIST
63534: LIST
63535: PUSH
63536: LD_INT 3
63538: PUSH
63539: LD_INT 1
63541: PUSH
63542: EMPTY
63543: LIST
63544: LIST
63545: PUSH
63546: LD_INT 3
63548: PUSH
63549: LD_INT 2
63551: PUSH
63552: EMPTY
63553: LIST
63554: LIST
63555: PUSH
63556: LD_INT 3
63558: PUSH
63559: LD_INT 3
63561: PUSH
63562: EMPTY
63563: LIST
63564: LIST
63565: PUSH
63566: LD_INT 2
63568: PUSH
63569: LD_INT 3
63571: PUSH
63572: EMPTY
63573: LIST
63574: LIST
63575: PUSH
63576: LD_INT 2
63578: NEG
63579: PUSH
63580: LD_INT 1
63582: PUSH
63583: EMPTY
63584: LIST
63585: LIST
63586: PUSH
63587: LD_INT 3
63589: NEG
63590: PUSH
63591: LD_INT 0
63593: PUSH
63594: EMPTY
63595: LIST
63596: LIST
63597: PUSH
63598: LD_INT 3
63600: NEG
63601: PUSH
63602: LD_INT 1
63604: NEG
63605: PUSH
63606: EMPTY
63607: LIST
63608: LIST
63609: PUSH
63610: LD_INT 3
63612: NEG
63613: PUSH
63614: LD_INT 2
63616: NEG
63617: PUSH
63618: EMPTY
63619: LIST
63620: LIST
63621: PUSH
63622: LD_INT 3
63624: NEG
63625: PUSH
63626: LD_INT 3
63628: NEG
63629: PUSH
63630: EMPTY
63631: LIST
63632: LIST
63633: PUSH
63634: EMPTY
63635: LIST
63636: LIST
63637: LIST
63638: LIST
63639: LIST
63640: LIST
63641: LIST
63642: LIST
63643: LIST
63644: LIST
63645: LIST
63646: LIST
63647: LIST
63648: LIST
63649: LIST
63650: LIST
63651: LIST
63652: LIST
63653: LIST
63654: LIST
63655: LIST
63656: LIST
63657: LIST
63658: LIST
63659: LIST
63660: LIST
63661: LIST
63662: LIST
63663: LIST
63664: ST_TO_ADDR
// Lab4 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ - 2 , - 3 ] , [ - 1 , - 3 ] , [ 0 , - 3 ] , [ 1 , - 2 ] , [ 3 , 2 ] , [ 3 , 3 ] , [ 2 , 3 ] , [ 1 , 3 ] , [ 0 , 3 ] , [ - 1 , 2 ] , [ - 3 , - 2 ] , [ - 3 , - 3 ] ] ;
63665: LD_ADDR_VAR 0 45
63669: PUSH
63670: LD_INT 0
63672: PUSH
63673: LD_INT 0
63675: PUSH
63676: EMPTY
63677: LIST
63678: LIST
63679: PUSH
63680: LD_INT 0
63682: PUSH
63683: LD_INT 1
63685: NEG
63686: PUSH
63687: EMPTY
63688: LIST
63689: LIST
63690: PUSH
63691: LD_INT 1
63693: PUSH
63694: LD_INT 0
63696: PUSH
63697: EMPTY
63698: LIST
63699: LIST
63700: PUSH
63701: LD_INT 1
63703: PUSH
63704: LD_INT 1
63706: PUSH
63707: EMPTY
63708: LIST
63709: LIST
63710: PUSH
63711: LD_INT 0
63713: PUSH
63714: LD_INT 1
63716: PUSH
63717: EMPTY
63718: LIST
63719: LIST
63720: PUSH
63721: LD_INT 1
63723: NEG
63724: PUSH
63725: LD_INT 0
63727: PUSH
63728: EMPTY
63729: LIST
63730: LIST
63731: PUSH
63732: LD_INT 1
63734: NEG
63735: PUSH
63736: LD_INT 1
63738: NEG
63739: PUSH
63740: EMPTY
63741: LIST
63742: LIST
63743: PUSH
63744: LD_INT 1
63746: NEG
63747: PUSH
63748: LD_INT 2
63750: NEG
63751: PUSH
63752: EMPTY
63753: LIST
63754: LIST
63755: PUSH
63756: LD_INT 0
63758: PUSH
63759: LD_INT 2
63761: NEG
63762: PUSH
63763: EMPTY
63764: LIST
63765: LIST
63766: PUSH
63767: LD_INT 1
63769: PUSH
63770: LD_INT 1
63772: NEG
63773: PUSH
63774: EMPTY
63775: LIST
63776: LIST
63777: PUSH
63778: LD_INT 2
63780: PUSH
63781: LD_INT 1
63783: PUSH
63784: EMPTY
63785: LIST
63786: LIST
63787: PUSH
63788: LD_INT 2
63790: PUSH
63791: LD_INT 2
63793: PUSH
63794: EMPTY
63795: LIST
63796: LIST
63797: PUSH
63798: LD_INT 1
63800: PUSH
63801: LD_INT 2
63803: PUSH
63804: EMPTY
63805: LIST
63806: LIST
63807: PUSH
63808: LD_INT 0
63810: PUSH
63811: LD_INT 2
63813: PUSH
63814: EMPTY
63815: LIST
63816: LIST
63817: PUSH
63818: LD_INT 1
63820: NEG
63821: PUSH
63822: LD_INT 1
63824: PUSH
63825: EMPTY
63826: LIST
63827: LIST
63828: PUSH
63829: LD_INT 2
63831: NEG
63832: PUSH
63833: LD_INT 1
63835: NEG
63836: PUSH
63837: EMPTY
63838: LIST
63839: LIST
63840: PUSH
63841: LD_INT 2
63843: NEG
63844: PUSH
63845: LD_INT 2
63847: NEG
63848: PUSH
63849: EMPTY
63850: LIST
63851: LIST
63852: PUSH
63853: LD_INT 2
63855: NEG
63856: PUSH
63857: LD_INT 3
63859: NEG
63860: PUSH
63861: EMPTY
63862: LIST
63863: LIST
63864: PUSH
63865: LD_INT 1
63867: NEG
63868: PUSH
63869: LD_INT 3
63871: NEG
63872: PUSH
63873: EMPTY
63874: LIST
63875: LIST
63876: PUSH
63877: LD_INT 0
63879: PUSH
63880: LD_INT 3
63882: NEG
63883: PUSH
63884: EMPTY
63885: LIST
63886: LIST
63887: PUSH
63888: LD_INT 1
63890: PUSH
63891: LD_INT 2
63893: NEG
63894: PUSH
63895: EMPTY
63896: LIST
63897: LIST
63898: PUSH
63899: LD_INT 3
63901: PUSH
63902: LD_INT 2
63904: PUSH
63905: EMPTY
63906: LIST
63907: LIST
63908: PUSH
63909: LD_INT 3
63911: PUSH
63912: LD_INT 3
63914: PUSH
63915: EMPTY
63916: LIST
63917: LIST
63918: PUSH
63919: LD_INT 2
63921: PUSH
63922: LD_INT 3
63924: PUSH
63925: EMPTY
63926: LIST
63927: LIST
63928: PUSH
63929: LD_INT 1
63931: PUSH
63932: LD_INT 3
63934: PUSH
63935: EMPTY
63936: LIST
63937: LIST
63938: PUSH
63939: LD_INT 0
63941: PUSH
63942: LD_INT 3
63944: PUSH
63945: EMPTY
63946: LIST
63947: LIST
63948: PUSH
63949: LD_INT 1
63951: NEG
63952: PUSH
63953: LD_INT 2
63955: PUSH
63956: EMPTY
63957: LIST
63958: LIST
63959: PUSH
63960: LD_INT 3
63962: NEG
63963: PUSH
63964: LD_INT 2
63966: NEG
63967: PUSH
63968: EMPTY
63969: LIST
63970: LIST
63971: PUSH
63972: LD_INT 3
63974: NEG
63975: PUSH
63976: LD_INT 3
63978: NEG
63979: PUSH
63980: EMPTY
63981: LIST
63982: LIST
63983: PUSH
63984: EMPTY
63985: LIST
63986: LIST
63987: LIST
63988: LIST
63989: LIST
63990: LIST
63991: LIST
63992: LIST
63993: LIST
63994: LIST
63995: LIST
63996: LIST
63997: LIST
63998: LIST
63999: LIST
64000: LIST
64001: LIST
64002: LIST
64003: LIST
64004: LIST
64005: LIST
64006: LIST
64007: LIST
64008: LIST
64009: LIST
64010: LIST
64011: LIST
64012: LIST
64013: LIST
64014: ST_TO_ADDR
// Lab5 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 1 , - 3 ] , [ 0 , - 3 ] , [ 1 , - 2 ] , [ 2 , - 1 ] , [ 3 , 0 ] , [ 3 , 1 ] , [ 1 , 3 ] , [ 0 , 3 ] , [ - 1 , 2 ] , [ - 2 , 1 ] , [ - 3 , 0 ] , [ - 3 , - 1 ] ] ;
64015: LD_ADDR_VAR 0 46
64019: PUSH
64020: LD_INT 0
64022: PUSH
64023: LD_INT 0
64025: PUSH
64026: EMPTY
64027: LIST
64028: LIST
64029: PUSH
64030: LD_INT 0
64032: PUSH
64033: LD_INT 1
64035: NEG
64036: PUSH
64037: EMPTY
64038: LIST
64039: LIST
64040: PUSH
64041: LD_INT 1
64043: PUSH
64044: LD_INT 0
64046: PUSH
64047: EMPTY
64048: LIST
64049: LIST
64050: PUSH
64051: LD_INT 1
64053: PUSH
64054: LD_INT 1
64056: PUSH
64057: EMPTY
64058: LIST
64059: LIST
64060: PUSH
64061: LD_INT 0
64063: PUSH
64064: LD_INT 1
64066: PUSH
64067: EMPTY
64068: LIST
64069: LIST
64070: PUSH
64071: LD_INT 1
64073: NEG
64074: PUSH
64075: LD_INT 0
64077: PUSH
64078: EMPTY
64079: LIST
64080: LIST
64081: PUSH
64082: LD_INT 1
64084: NEG
64085: PUSH
64086: LD_INT 1
64088: NEG
64089: PUSH
64090: EMPTY
64091: LIST
64092: LIST
64093: PUSH
64094: LD_INT 1
64096: NEG
64097: PUSH
64098: LD_INT 2
64100: NEG
64101: PUSH
64102: EMPTY
64103: LIST
64104: LIST
64105: PUSH
64106: LD_INT 0
64108: PUSH
64109: LD_INT 2
64111: NEG
64112: PUSH
64113: EMPTY
64114: LIST
64115: LIST
64116: PUSH
64117: LD_INT 1
64119: PUSH
64120: LD_INT 1
64122: NEG
64123: PUSH
64124: EMPTY
64125: LIST
64126: LIST
64127: PUSH
64128: LD_INT 2
64130: PUSH
64131: LD_INT 0
64133: PUSH
64134: EMPTY
64135: LIST
64136: LIST
64137: PUSH
64138: LD_INT 2
64140: PUSH
64141: LD_INT 1
64143: PUSH
64144: EMPTY
64145: LIST
64146: LIST
64147: PUSH
64148: LD_INT 1
64150: PUSH
64151: LD_INT 2
64153: PUSH
64154: EMPTY
64155: LIST
64156: LIST
64157: PUSH
64158: LD_INT 0
64160: PUSH
64161: LD_INT 2
64163: PUSH
64164: EMPTY
64165: LIST
64166: LIST
64167: PUSH
64168: LD_INT 1
64170: NEG
64171: PUSH
64172: LD_INT 1
64174: PUSH
64175: EMPTY
64176: LIST
64177: LIST
64178: PUSH
64179: LD_INT 2
64181: NEG
64182: PUSH
64183: LD_INT 0
64185: PUSH
64186: EMPTY
64187: LIST
64188: LIST
64189: PUSH
64190: LD_INT 2
64192: NEG
64193: PUSH
64194: LD_INT 1
64196: NEG
64197: PUSH
64198: EMPTY
64199: LIST
64200: LIST
64201: PUSH
64202: LD_INT 1
64204: NEG
64205: PUSH
64206: LD_INT 3
64208: NEG
64209: PUSH
64210: EMPTY
64211: LIST
64212: LIST
64213: PUSH
64214: LD_INT 0
64216: PUSH
64217: LD_INT 3
64219: NEG
64220: PUSH
64221: EMPTY
64222: LIST
64223: LIST
64224: PUSH
64225: LD_INT 1
64227: PUSH
64228: LD_INT 2
64230: NEG
64231: PUSH
64232: EMPTY
64233: LIST
64234: LIST
64235: PUSH
64236: LD_INT 2
64238: PUSH
64239: LD_INT 1
64241: NEG
64242: PUSH
64243: EMPTY
64244: LIST
64245: LIST
64246: PUSH
64247: LD_INT 3
64249: PUSH
64250: LD_INT 0
64252: PUSH
64253: EMPTY
64254: LIST
64255: LIST
64256: PUSH
64257: LD_INT 3
64259: PUSH
64260: LD_INT 1
64262: PUSH
64263: EMPTY
64264: LIST
64265: LIST
64266: PUSH
64267: LD_INT 1
64269: PUSH
64270: LD_INT 3
64272: PUSH
64273: EMPTY
64274: LIST
64275: LIST
64276: PUSH
64277: LD_INT 0
64279: PUSH
64280: LD_INT 3
64282: PUSH
64283: EMPTY
64284: LIST
64285: LIST
64286: PUSH
64287: LD_INT 1
64289: NEG
64290: PUSH
64291: LD_INT 2
64293: PUSH
64294: EMPTY
64295: LIST
64296: LIST
64297: PUSH
64298: LD_INT 2
64300: NEG
64301: PUSH
64302: LD_INT 1
64304: PUSH
64305: EMPTY
64306: LIST
64307: LIST
64308: PUSH
64309: LD_INT 3
64311: NEG
64312: PUSH
64313: LD_INT 0
64315: PUSH
64316: EMPTY
64317: LIST
64318: LIST
64319: PUSH
64320: LD_INT 3
64322: NEG
64323: PUSH
64324: LD_INT 1
64326: NEG
64327: PUSH
64328: EMPTY
64329: LIST
64330: LIST
64331: PUSH
64332: EMPTY
64333: LIST
64334: LIST
64335: LIST
64336: LIST
64337: LIST
64338: LIST
64339: LIST
64340: LIST
64341: LIST
64342: LIST
64343: LIST
64344: LIST
64345: LIST
64346: LIST
64347: LIST
64348: LIST
64349: LIST
64350: LIST
64351: LIST
64352: LIST
64353: LIST
64354: LIST
64355: LIST
64356: LIST
64357: LIST
64358: LIST
64359: LIST
64360: LIST
64361: LIST
64362: ST_TO_ADDR
// ControlTower0 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
64363: LD_ADDR_VAR 0 47
64367: PUSH
64368: LD_INT 0
64370: PUSH
64371: LD_INT 0
64373: PUSH
64374: EMPTY
64375: LIST
64376: LIST
64377: PUSH
64378: LD_INT 0
64380: PUSH
64381: LD_INT 1
64383: NEG
64384: PUSH
64385: EMPTY
64386: LIST
64387: LIST
64388: PUSH
64389: LD_INT 1
64391: PUSH
64392: LD_INT 0
64394: PUSH
64395: EMPTY
64396: LIST
64397: LIST
64398: PUSH
64399: LD_INT 1
64401: PUSH
64402: LD_INT 1
64404: PUSH
64405: EMPTY
64406: LIST
64407: LIST
64408: PUSH
64409: LD_INT 0
64411: PUSH
64412: LD_INT 1
64414: PUSH
64415: EMPTY
64416: LIST
64417: LIST
64418: PUSH
64419: LD_INT 1
64421: NEG
64422: PUSH
64423: LD_INT 0
64425: PUSH
64426: EMPTY
64427: LIST
64428: LIST
64429: PUSH
64430: LD_INT 1
64432: NEG
64433: PUSH
64434: LD_INT 1
64436: NEG
64437: PUSH
64438: EMPTY
64439: LIST
64440: LIST
64441: PUSH
64442: LD_INT 1
64444: NEG
64445: PUSH
64446: LD_INT 2
64448: NEG
64449: PUSH
64450: EMPTY
64451: LIST
64452: LIST
64453: PUSH
64454: LD_INT 0
64456: PUSH
64457: LD_INT 2
64459: NEG
64460: PUSH
64461: EMPTY
64462: LIST
64463: LIST
64464: PUSH
64465: LD_INT 1
64467: PUSH
64468: LD_INT 1
64470: NEG
64471: PUSH
64472: EMPTY
64473: LIST
64474: LIST
64475: PUSH
64476: LD_INT 2
64478: NEG
64479: PUSH
64480: LD_INT 1
64482: NEG
64483: PUSH
64484: EMPTY
64485: LIST
64486: LIST
64487: PUSH
64488: LD_INT 2
64490: NEG
64491: PUSH
64492: LD_INT 2
64494: NEG
64495: PUSH
64496: EMPTY
64497: LIST
64498: LIST
64499: PUSH
64500: EMPTY
64501: LIST
64502: LIST
64503: LIST
64504: LIST
64505: LIST
64506: LIST
64507: LIST
64508: LIST
64509: LIST
64510: LIST
64511: LIST
64512: LIST
64513: ST_TO_ADDR
// ControlTower1 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] ] ;
64514: LD_ADDR_VAR 0 48
64518: PUSH
64519: LD_INT 0
64521: PUSH
64522: LD_INT 0
64524: PUSH
64525: EMPTY
64526: LIST
64527: LIST
64528: PUSH
64529: LD_INT 0
64531: PUSH
64532: LD_INT 1
64534: NEG
64535: PUSH
64536: EMPTY
64537: LIST
64538: LIST
64539: PUSH
64540: LD_INT 1
64542: PUSH
64543: LD_INT 0
64545: PUSH
64546: EMPTY
64547: LIST
64548: LIST
64549: PUSH
64550: LD_INT 1
64552: PUSH
64553: LD_INT 1
64555: PUSH
64556: EMPTY
64557: LIST
64558: LIST
64559: PUSH
64560: LD_INT 0
64562: PUSH
64563: LD_INT 1
64565: PUSH
64566: EMPTY
64567: LIST
64568: LIST
64569: PUSH
64570: LD_INT 1
64572: NEG
64573: PUSH
64574: LD_INT 0
64576: PUSH
64577: EMPTY
64578: LIST
64579: LIST
64580: PUSH
64581: LD_INT 1
64583: NEG
64584: PUSH
64585: LD_INT 1
64587: NEG
64588: PUSH
64589: EMPTY
64590: LIST
64591: LIST
64592: PUSH
64593: LD_INT 1
64595: NEG
64596: PUSH
64597: LD_INT 2
64599: NEG
64600: PUSH
64601: EMPTY
64602: LIST
64603: LIST
64604: PUSH
64605: LD_INT 0
64607: PUSH
64608: LD_INT 2
64610: NEG
64611: PUSH
64612: EMPTY
64613: LIST
64614: LIST
64615: PUSH
64616: LD_INT 1
64618: PUSH
64619: LD_INT 1
64621: NEG
64622: PUSH
64623: EMPTY
64624: LIST
64625: LIST
64626: PUSH
64627: LD_INT 2
64629: PUSH
64630: LD_INT 0
64632: PUSH
64633: EMPTY
64634: LIST
64635: LIST
64636: PUSH
64637: LD_INT 2
64639: PUSH
64640: LD_INT 1
64642: PUSH
64643: EMPTY
64644: LIST
64645: LIST
64646: PUSH
64647: EMPTY
64648: LIST
64649: LIST
64650: LIST
64651: LIST
64652: LIST
64653: LIST
64654: LIST
64655: LIST
64656: LIST
64657: LIST
64658: LIST
64659: LIST
64660: ST_TO_ADDR
// ControlTower2 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] ] ;
64661: LD_ADDR_VAR 0 49
64665: PUSH
64666: LD_INT 0
64668: PUSH
64669: LD_INT 0
64671: PUSH
64672: EMPTY
64673: LIST
64674: LIST
64675: PUSH
64676: LD_INT 0
64678: PUSH
64679: LD_INT 1
64681: NEG
64682: PUSH
64683: EMPTY
64684: LIST
64685: LIST
64686: PUSH
64687: LD_INT 1
64689: PUSH
64690: LD_INT 0
64692: PUSH
64693: EMPTY
64694: LIST
64695: LIST
64696: PUSH
64697: LD_INT 1
64699: PUSH
64700: LD_INT 1
64702: PUSH
64703: EMPTY
64704: LIST
64705: LIST
64706: PUSH
64707: LD_INT 0
64709: PUSH
64710: LD_INT 1
64712: PUSH
64713: EMPTY
64714: LIST
64715: LIST
64716: PUSH
64717: LD_INT 1
64719: NEG
64720: PUSH
64721: LD_INT 0
64723: PUSH
64724: EMPTY
64725: LIST
64726: LIST
64727: PUSH
64728: LD_INT 1
64730: NEG
64731: PUSH
64732: LD_INT 1
64734: NEG
64735: PUSH
64736: EMPTY
64737: LIST
64738: LIST
64739: PUSH
64740: LD_INT 1
64742: PUSH
64743: LD_INT 1
64745: NEG
64746: PUSH
64747: EMPTY
64748: LIST
64749: LIST
64750: PUSH
64751: LD_INT 2
64753: PUSH
64754: LD_INT 0
64756: PUSH
64757: EMPTY
64758: LIST
64759: LIST
64760: PUSH
64761: LD_INT 2
64763: PUSH
64764: LD_INT 1
64766: PUSH
64767: EMPTY
64768: LIST
64769: LIST
64770: PUSH
64771: LD_INT 2
64773: PUSH
64774: LD_INT 2
64776: PUSH
64777: EMPTY
64778: LIST
64779: LIST
64780: PUSH
64781: LD_INT 1
64783: PUSH
64784: LD_INT 2
64786: PUSH
64787: EMPTY
64788: LIST
64789: LIST
64790: PUSH
64791: EMPTY
64792: LIST
64793: LIST
64794: LIST
64795: LIST
64796: LIST
64797: LIST
64798: LIST
64799: LIST
64800: LIST
64801: LIST
64802: LIST
64803: LIST
64804: ST_TO_ADDR
// ControlTower3 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] ] ;
64805: LD_ADDR_VAR 0 50
64809: PUSH
64810: LD_INT 0
64812: PUSH
64813: LD_INT 0
64815: PUSH
64816: EMPTY
64817: LIST
64818: LIST
64819: PUSH
64820: LD_INT 0
64822: PUSH
64823: LD_INT 1
64825: NEG
64826: PUSH
64827: EMPTY
64828: LIST
64829: LIST
64830: PUSH
64831: LD_INT 1
64833: PUSH
64834: LD_INT 0
64836: PUSH
64837: EMPTY
64838: LIST
64839: LIST
64840: PUSH
64841: LD_INT 1
64843: PUSH
64844: LD_INT 1
64846: PUSH
64847: EMPTY
64848: LIST
64849: LIST
64850: PUSH
64851: LD_INT 0
64853: PUSH
64854: LD_INT 1
64856: PUSH
64857: EMPTY
64858: LIST
64859: LIST
64860: PUSH
64861: LD_INT 1
64863: NEG
64864: PUSH
64865: LD_INT 0
64867: PUSH
64868: EMPTY
64869: LIST
64870: LIST
64871: PUSH
64872: LD_INT 1
64874: NEG
64875: PUSH
64876: LD_INT 1
64878: NEG
64879: PUSH
64880: EMPTY
64881: LIST
64882: LIST
64883: PUSH
64884: LD_INT 2
64886: PUSH
64887: LD_INT 1
64889: PUSH
64890: EMPTY
64891: LIST
64892: LIST
64893: PUSH
64894: LD_INT 2
64896: PUSH
64897: LD_INT 2
64899: PUSH
64900: EMPTY
64901: LIST
64902: LIST
64903: PUSH
64904: LD_INT 1
64906: PUSH
64907: LD_INT 2
64909: PUSH
64910: EMPTY
64911: LIST
64912: LIST
64913: PUSH
64914: LD_INT 0
64916: PUSH
64917: LD_INT 2
64919: PUSH
64920: EMPTY
64921: LIST
64922: LIST
64923: PUSH
64924: LD_INT 1
64926: NEG
64927: PUSH
64928: LD_INT 1
64930: PUSH
64931: EMPTY
64932: LIST
64933: LIST
64934: PUSH
64935: EMPTY
64936: LIST
64937: LIST
64938: LIST
64939: LIST
64940: LIST
64941: LIST
64942: LIST
64943: LIST
64944: LIST
64945: LIST
64946: LIST
64947: LIST
64948: ST_TO_ADDR
// ControlTower4 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] ] ;
64949: LD_ADDR_VAR 0 51
64953: PUSH
64954: LD_INT 0
64956: PUSH
64957: LD_INT 0
64959: PUSH
64960: EMPTY
64961: LIST
64962: LIST
64963: PUSH
64964: LD_INT 0
64966: PUSH
64967: LD_INT 1
64969: NEG
64970: PUSH
64971: EMPTY
64972: LIST
64973: LIST
64974: PUSH
64975: LD_INT 1
64977: PUSH
64978: LD_INT 0
64980: PUSH
64981: EMPTY
64982: LIST
64983: LIST
64984: PUSH
64985: LD_INT 1
64987: PUSH
64988: LD_INT 1
64990: PUSH
64991: EMPTY
64992: LIST
64993: LIST
64994: PUSH
64995: LD_INT 0
64997: PUSH
64998: LD_INT 1
65000: PUSH
65001: EMPTY
65002: LIST
65003: LIST
65004: PUSH
65005: LD_INT 1
65007: NEG
65008: PUSH
65009: LD_INT 0
65011: PUSH
65012: EMPTY
65013: LIST
65014: LIST
65015: PUSH
65016: LD_INT 1
65018: NEG
65019: PUSH
65020: LD_INT 1
65022: NEG
65023: PUSH
65024: EMPTY
65025: LIST
65026: LIST
65027: PUSH
65028: LD_INT 1
65030: PUSH
65031: LD_INT 2
65033: PUSH
65034: EMPTY
65035: LIST
65036: LIST
65037: PUSH
65038: LD_INT 0
65040: PUSH
65041: LD_INT 2
65043: PUSH
65044: EMPTY
65045: LIST
65046: LIST
65047: PUSH
65048: LD_INT 1
65050: NEG
65051: PUSH
65052: LD_INT 1
65054: PUSH
65055: EMPTY
65056: LIST
65057: LIST
65058: PUSH
65059: LD_INT 2
65061: NEG
65062: PUSH
65063: LD_INT 0
65065: PUSH
65066: EMPTY
65067: LIST
65068: LIST
65069: PUSH
65070: LD_INT 2
65072: NEG
65073: PUSH
65074: LD_INT 1
65076: NEG
65077: PUSH
65078: EMPTY
65079: LIST
65080: LIST
65081: PUSH
65082: EMPTY
65083: LIST
65084: LIST
65085: LIST
65086: LIST
65087: LIST
65088: LIST
65089: LIST
65090: LIST
65091: LIST
65092: LIST
65093: LIST
65094: LIST
65095: ST_TO_ADDR
// ControlTower5 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
65096: LD_ADDR_VAR 0 52
65100: PUSH
65101: LD_INT 0
65103: PUSH
65104: LD_INT 0
65106: PUSH
65107: EMPTY
65108: LIST
65109: LIST
65110: PUSH
65111: LD_INT 0
65113: PUSH
65114: LD_INT 1
65116: NEG
65117: PUSH
65118: EMPTY
65119: LIST
65120: LIST
65121: PUSH
65122: LD_INT 1
65124: PUSH
65125: LD_INT 0
65127: PUSH
65128: EMPTY
65129: LIST
65130: LIST
65131: PUSH
65132: LD_INT 1
65134: PUSH
65135: LD_INT 1
65137: PUSH
65138: EMPTY
65139: LIST
65140: LIST
65141: PUSH
65142: LD_INT 0
65144: PUSH
65145: LD_INT 1
65147: PUSH
65148: EMPTY
65149: LIST
65150: LIST
65151: PUSH
65152: LD_INT 1
65154: NEG
65155: PUSH
65156: LD_INT 0
65158: PUSH
65159: EMPTY
65160: LIST
65161: LIST
65162: PUSH
65163: LD_INT 1
65165: NEG
65166: PUSH
65167: LD_INT 1
65169: NEG
65170: PUSH
65171: EMPTY
65172: LIST
65173: LIST
65174: PUSH
65175: LD_INT 1
65177: NEG
65178: PUSH
65179: LD_INT 2
65181: NEG
65182: PUSH
65183: EMPTY
65184: LIST
65185: LIST
65186: PUSH
65187: LD_INT 1
65189: NEG
65190: PUSH
65191: LD_INT 1
65193: PUSH
65194: EMPTY
65195: LIST
65196: LIST
65197: PUSH
65198: LD_INT 2
65200: NEG
65201: PUSH
65202: LD_INT 0
65204: PUSH
65205: EMPTY
65206: LIST
65207: LIST
65208: PUSH
65209: LD_INT 2
65211: NEG
65212: PUSH
65213: LD_INT 1
65215: NEG
65216: PUSH
65217: EMPTY
65218: LIST
65219: LIST
65220: PUSH
65221: LD_INT 2
65223: NEG
65224: PUSH
65225: LD_INT 2
65227: NEG
65228: PUSH
65229: EMPTY
65230: LIST
65231: LIST
65232: PUSH
65233: EMPTY
65234: LIST
65235: LIST
65236: LIST
65237: LIST
65238: LIST
65239: LIST
65240: LIST
65241: LIST
65242: LIST
65243: LIST
65244: LIST
65245: LIST
65246: ST_TO_ADDR
// Barracks0 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
65247: LD_ADDR_VAR 0 53
65251: PUSH
65252: LD_INT 0
65254: PUSH
65255: LD_INT 0
65257: PUSH
65258: EMPTY
65259: LIST
65260: LIST
65261: PUSH
65262: LD_INT 0
65264: PUSH
65265: LD_INT 1
65267: NEG
65268: PUSH
65269: EMPTY
65270: LIST
65271: LIST
65272: PUSH
65273: LD_INT 1
65275: PUSH
65276: LD_INT 0
65278: PUSH
65279: EMPTY
65280: LIST
65281: LIST
65282: PUSH
65283: LD_INT 1
65285: PUSH
65286: LD_INT 1
65288: PUSH
65289: EMPTY
65290: LIST
65291: LIST
65292: PUSH
65293: LD_INT 0
65295: PUSH
65296: LD_INT 1
65298: PUSH
65299: EMPTY
65300: LIST
65301: LIST
65302: PUSH
65303: LD_INT 1
65305: NEG
65306: PUSH
65307: LD_INT 0
65309: PUSH
65310: EMPTY
65311: LIST
65312: LIST
65313: PUSH
65314: LD_INT 1
65316: NEG
65317: PUSH
65318: LD_INT 1
65320: NEG
65321: PUSH
65322: EMPTY
65323: LIST
65324: LIST
65325: PUSH
65326: LD_INT 1
65328: NEG
65329: PUSH
65330: LD_INT 2
65332: NEG
65333: PUSH
65334: EMPTY
65335: LIST
65336: LIST
65337: PUSH
65338: LD_INT 0
65340: PUSH
65341: LD_INT 2
65343: NEG
65344: PUSH
65345: EMPTY
65346: LIST
65347: LIST
65348: PUSH
65349: LD_INT 1
65351: PUSH
65352: LD_INT 1
65354: NEG
65355: PUSH
65356: EMPTY
65357: LIST
65358: LIST
65359: PUSH
65360: LD_INT 2
65362: PUSH
65363: LD_INT 0
65365: PUSH
65366: EMPTY
65367: LIST
65368: LIST
65369: PUSH
65370: LD_INT 2
65372: PUSH
65373: LD_INT 1
65375: PUSH
65376: EMPTY
65377: LIST
65378: LIST
65379: PUSH
65380: LD_INT 2
65382: PUSH
65383: LD_INT 2
65385: PUSH
65386: EMPTY
65387: LIST
65388: LIST
65389: PUSH
65390: LD_INT 1
65392: PUSH
65393: LD_INT 2
65395: PUSH
65396: EMPTY
65397: LIST
65398: LIST
65399: PUSH
65400: LD_INT 0
65402: PUSH
65403: LD_INT 2
65405: PUSH
65406: EMPTY
65407: LIST
65408: LIST
65409: PUSH
65410: LD_INT 1
65412: NEG
65413: PUSH
65414: LD_INT 1
65416: PUSH
65417: EMPTY
65418: LIST
65419: LIST
65420: PUSH
65421: LD_INT 2
65423: NEG
65424: PUSH
65425: LD_INT 0
65427: PUSH
65428: EMPTY
65429: LIST
65430: LIST
65431: PUSH
65432: LD_INT 2
65434: NEG
65435: PUSH
65436: LD_INT 1
65438: NEG
65439: PUSH
65440: EMPTY
65441: LIST
65442: LIST
65443: PUSH
65444: LD_INT 2
65446: NEG
65447: PUSH
65448: LD_INT 2
65450: NEG
65451: PUSH
65452: EMPTY
65453: LIST
65454: LIST
65455: PUSH
65456: EMPTY
65457: LIST
65458: LIST
65459: LIST
65460: LIST
65461: LIST
65462: LIST
65463: LIST
65464: LIST
65465: LIST
65466: LIST
65467: LIST
65468: LIST
65469: LIST
65470: LIST
65471: LIST
65472: LIST
65473: LIST
65474: LIST
65475: LIST
65476: ST_TO_ADDR
// Barracks1 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
65477: LD_ADDR_VAR 0 54
65481: PUSH
65482: LD_INT 0
65484: PUSH
65485: LD_INT 0
65487: PUSH
65488: EMPTY
65489: LIST
65490: LIST
65491: PUSH
65492: LD_INT 0
65494: PUSH
65495: LD_INT 1
65497: NEG
65498: PUSH
65499: EMPTY
65500: LIST
65501: LIST
65502: PUSH
65503: LD_INT 1
65505: PUSH
65506: LD_INT 0
65508: PUSH
65509: EMPTY
65510: LIST
65511: LIST
65512: PUSH
65513: LD_INT 1
65515: PUSH
65516: LD_INT 1
65518: PUSH
65519: EMPTY
65520: LIST
65521: LIST
65522: PUSH
65523: LD_INT 0
65525: PUSH
65526: LD_INT 1
65528: PUSH
65529: EMPTY
65530: LIST
65531: LIST
65532: PUSH
65533: LD_INT 1
65535: NEG
65536: PUSH
65537: LD_INT 0
65539: PUSH
65540: EMPTY
65541: LIST
65542: LIST
65543: PUSH
65544: LD_INT 1
65546: NEG
65547: PUSH
65548: LD_INT 1
65550: NEG
65551: PUSH
65552: EMPTY
65553: LIST
65554: LIST
65555: PUSH
65556: LD_INT 1
65558: NEG
65559: PUSH
65560: LD_INT 2
65562: NEG
65563: PUSH
65564: EMPTY
65565: LIST
65566: LIST
65567: PUSH
65568: LD_INT 0
65570: PUSH
65571: LD_INT 2
65573: NEG
65574: PUSH
65575: EMPTY
65576: LIST
65577: LIST
65578: PUSH
65579: LD_INT 1
65581: PUSH
65582: LD_INT 1
65584: NEG
65585: PUSH
65586: EMPTY
65587: LIST
65588: LIST
65589: PUSH
65590: LD_INT 2
65592: PUSH
65593: LD_INT 0
65595: PUSH
65596: EMPTY
65597: LIST
65598: LIST
65599: PUSH
65600: LD_INT 2
65602: PUSH
65603: LD_INT 1
65605: PUSH
65606: EMPTY
65607: LIST
65608: LIST
65609: PUSH
65610: LD_INT 2
65612: PUSH
65613: LD_INT 2
65615: PUSH
65616: EMPTY
65617: LIST
65618: LIST
65619: PUSH
65620: LD_INT 1
65622: PUSH
65623: LD_INT 2
65625: PUSH
65626: EMPTY
65627: LIST
65628: LIST
65629: PUSH
65630: LD_INT 0
65632: PUSH
65633: LD_INT 2
65635: PUSH
65636: EMPTY
65637: LIST
65638: LIST
65639: PUSH
65640: LD_INT 1
65642: NEG
65643: PUSH
65644: LD_INT 1
65646: PUSH
65647: EMPTY
65648: LIST
65649: LIST
65650: PUSH
65651: LD_INT 2
65653: NEG
65654: PUSH
65655: LD_INT 0
65657: PUSH
65658: EMPTY
65659: LIST
65660: LIST
65661: PUSH
65662: LD_INT 2
65664: NEG
65665: PUSH
65666: LD_INT 1
65668: NEG
65669: PUSH
65670: EMPTY
65671: LIST
65672: LIST
65673: PUSH
65674: LD_INT 2
65676: NEG
65677: PUSH
65678: LD_INT 2
65680: NEG
65681: PUSH
65682: EMPTY
65683: LIST
65684: LIST
65685: PUSH
65686: EMPTY
65687: LIST
65688: LIST
65689: LIST
65690: LIST
65691: LIST
65692: LIST
65693: LIST
65694: LIST
65695: LIST
65696: LIST
65697: LIST
65698: LIST
65699: LIST
65700: LIST
65701: LIST
65702: LIST
65703: LIST
65704: LIST
65705: LIST
65706: ST_TO_ADDR
// Barracks2 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
65707: LD_ADDR_VAR 0 55
65711: PUSH
65712: LD_INT 0
65714: PUSH
65715: LD_INT 0
65717: PUSH
65718: EMPTY
65719: LIST
65720: LIST
65721: PUSH
65722: LD_INT 0
65724: PUSH
65725: LD_INT 1
65727: NEG
65728: PUSH
65729: EMPTY
65730: LIST
65731: LIST
65732: PUSH
65733: LD_INT 1
65735: PUSH
65736: LD_INT 0
65738: PUSH
65739: EMPTY
65740: LIST
65741: LIST
65742: PUSH
65743: LD_INT 1
65745: PUSH
65746: LD_INT 1
65748: PUSH
65749: EMPTY
65750: LIST
65751: LIST
65752: PUSH
65753: LD_INT 0
65755: PUSH
65756: LD_INT 1
65758: PUSH
65759: EMPTY
65760: LIST
65761: LIST
65762: PUSH
65763: LD_INT 1
65765: NEG
65766: PUSH
65767: LD_INT 0
65769: PUSH
65770: EMPTY
65771: LIST
65772: LIST
65773: PUSH
65774: LD_INT 1
65776: NEG
65777: PUSH
65778: LD_INT 1
65780: NEG
65781: PUSH
65782: EMPTY
65783: LIST
65784: LIST
65785: PUSH
65786: LD_INT 1
65788: NEG
65789: PUSH
65790: LD_INT 2
65792: NEG
65793: PUSH
65794: EMPTY
65795: LIST
65796: LIST
65797: PUSH
65798: LD_INT 0
65800: PUSH
65801: LD_INT 2
65803: NEG
65804: PUSH
65805: EMPTY
65806: LIST
65807: LIST
65808: PUSH
65809: LD_INT 1
65811: PUSH
65812: LD_INT 1
65814: NEG
65815: PUSH
65816: EMPTY
65817: LIST
65818: LIST
65819: PUSH
65820: LD_INT 2
65822: PUSH
65823: LD_INT 0
65825: PUSH
65826: EMPTY
65827: LIST
65828: LIST
65829: PUSH
65830: LD_INT 2
65832: PUSH
65833: LD_INT 1
65835: PUSH
65836: EMPTY
65837: LIST
65838: LIST
65839: PUSH
65840: LD_INT 2
65842: PUSH
65843: LD_INT 2
65845: PUSH
65846: EMPTY
65847: LIST
65848: LIST
65849: PUSH
65850: LD_INT 1
65852: PUSH
65853: LD_INT 2
65855: PUSH
65856: EMPTY
65857: LIST
65858: LIST
65859: PUSH
65860: LD_INT 0
65862: PUSH
65863: LD_INT 2
65865: PUSH
65866: EMPTY
65867: LIST
65868: LIST
65869: PUSH
65870: LD_INT 1
65872: NEG
65873: PUSH
65874: LD_INT 1
65876: PUSH
65877: EMPTY
65878: LIST
65879: LIST
65880: PUSH
65881: LD_INT 2
65883: NEG
65884: PUSH
65885: LD_INT 0
65887: PUSH
65888: EMPTY
65889: LIST
65890: LIST
65891: PUSH
65892: LD_INT 2
65894: NEG
65895: PUSH
65896: LD_INT 1
65898: NEG
65899: PUSH
65900: EMPTY
65901: LIST
65902: LIST
65903: PUSH
65904: LD_INT 2
65906: NEG
65907: PUSH
65908: LD_INT 2
65910: NEG
65911: PUSH
65912: EMPTY
65913: LIST
65914: LIST
65915: PUSH
65916: EMPTY
65917: LIST
65918: LIST
65919: LIST
65920: LIST
65921: LIST
65922: LIST
65923: LIST
65924: LIST
65925: LIST
65926: LIST
65927: LIST
65928: LIST
65929: LIST
65930: LIST
65931: LIST
65932: LIST
65933: LIST
65934: LIST
65935: LIST
65936: ST_TO_ADDR
// Barracks3 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
65937: LD_ADDR_VAR 0 56
65941: PUSH
65942: LD_INT 0
65944: PUSH
65945: LD_INT 0
65947: PUSH
65948: EMPTY
65949: LIST
65950: LIST
65951: PUSH
65952: LD_INT 0
65954: PUSH
65955: LD_INT 1
65957: NEG
65958: PUSH
65959: EMPTY
65960: LIST
65961: LIST
65962: PUSH
65963: LD_INT 1
65965: PUSH
65966: LD_INT 0
65968: PUSH
65969: EMPTY
65970: LIST
65971: LIST
65972: PUSH
65973: LD_INT 1
65975: PUSH
65976: LD_INT 1
65978: PUSH
65979: EMPTY
65980: LIST
65981: LIST
65982: PUSH
65983: LD_INT 0
65985: PUSH
65986: LD_INT 1
65988: PUSH
65989: EMPTY
65990: LIST
65991: LIST
65992: PUSH
65993: LD_INT 1
65995: NEG
65996: PUSH
65997: LD_INT 0
65999: PUSH
66000: EMPTY
66001: LIST
66002: LIST
66003: PUSH
66004: LD_INT 1
66006: NEG
66007: PUSH
66008: LD_INT 1
66010: NEG
66011: PUSH
66012: EMPTY
66013: LIST
66014: LIST
66015: PUSH
66016: LD_INT 1
66018: NEG
66019: PUSH
66020: LD_INT 2
66022: NEG
66023: PUSH
66024: EMPTY
66025: LIST
66026: LIST
66027: PUSH
66028: LD_INT 0
66030: PUSH
66031: LD_INT 2
66033: NEG
66034: PUSH
66035: EMPTY
66036: LIST
66037: LIST
66038: PUSH
66039: LD_INT 1
66041: PUSH
66042: LD_INT 1
66044: NEG
66045: PUSH
66046: EMPTY
66047: LIST
66048: LIST
66049: PUSH
66050: LD_INT 2
66052: PUSH
66053: LD_INT 0
66055: PUSH
66056: EMPTY
66057: LIST
66058: LIST
66059: PUSH
66060: LD_INT 2
66062: PUSH
66063: LD_INT 1
66065: PUSH
66066: EMPTY
66067: LIST
66068: LIST
66069: PUSH
66070: LD_INT 2
66072: PUSH
66073: LD_INT 2
66075: PUSH
66076: EMPTY
66077: LIST
66078: LIST
66079: PUSH
66080: LD_INT 1
66082: PUSH
66083: LD_INT 2
66085: PUSH
66086: EMPTY
66087: LIST
66088: LIST
66089: PUSH
66090: LD_INT 0
66092: PUSH
66093: LD_INT 2
66095: PUSH
66096: EMPTY
66097: LIST
66098: LIST
66099: PUSH
66100: LD_INT 1
66102: NEG
66103: PUSH
66104: LD_INT 1
66106: PUSH
66107: EMPTY
66108: LIST
66109: LIST
66110: PUSH
66111: LD_INT 2
66113: NEG
66114: PUSH
66115: LD_INT 0
66117: PUSH
66118: EMPTY
66119: LIST
66120: LIST
66121: PUSH
66122: LD_INT 2
66124: NEG
66125: PUSH
66126: LD_INT 1
66128: NEG
66129: PUSH
66130: EMPTY
66131: LIST
66132: LIST
66133: PUSH
66134: LD_INT 2
66136: NEG
66137: PUSH
66138: LD_INT 2
66140: NEG
66141: PUSH
66142: EMPTY
66143: LIST
66144: LIST
66145: PUSH
66146: EMPTY
66147: LIST
66148: LIST
66149: LIST
66150: LIST
66151: LIST
66152: LIST
66153: LIST
66154: LIST
66155: LIST
66156: LIST
66157: LIST
66158: LIST
66159: LIST
66160: LIST
66161: LIST
66162: LIST
66163: LIST
66164: LIST
66165: LIST
66166: ST_TO_ADDR
// Barracks4 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
66167: LD_ADDR_VAR 0 57
66171: PUSH
66172: LD_INT 0
66174: PUSH
66175: LD_INT 0
66177: PUSH
66178: EMPTY
66179: LIST
66180: LIST
66181: PUSH
66182: LD_INT 0
66184: PUSH
66185: LD_INT 1
66187: NEG
66188: PUSH
66189: EMPTY
66190: LIST
66191: LIST
66192: PUSH
66193: LD_INT 1
66195: PUSH
66196: LD_INT 0
66198: PUSH
66199: EMPTY
66200: LIST
66201: LIST
66202: PUSH
66203: LD_INT 1
66205: PUSH
66206: LD_INT 1
66208: PUSH
66209: EMPTY
66210: LIST
66211: LIST
66212: PUSH
66213: LD_INT 0
66215: PUSH
66216: LD_INT 1
66218: PUSH
66219: EMPTY
66220: LIST
66221: LIST
66222: PUSH
66223: LD_INT 1
66225: NEG
66226: PUSH
66227: LD_INT 0
66229: PUSH
66230: EMPTY
66231: LIST
66232: LIST
66233: PUSH
66234: LD_INT 1
66236: NEG
66237: PUSH
66238: LD_INT 1
66240: NEG
66241: PUSH
66242: EMPTY
66243: LIST
66244: LIST
66245: PUSH
66246: LD_INT 1
66248: NEG
66249: PUSH
66250: LD_INT 2
66252: NEG
66253: PUSH
66254: EMPTY
66255: LIST
66256: LIST
66257: PUSH
66258: LD_INT 0
66260: PUSH
66261: LD_INT 2
66263: NEG
66264: PUSH
66265: EMPTY
66266: LIST
66267: LIST
66268: PUSH
66269: LD_INT 1
66271: PUSH
66272: LD_INT 1
66274: NEG
66275: PUSH
66276: EMPTY
66277: LIST
66278: LIST
66279: PUSH
66280: LD_INT 2
66282: PUSH
66283: LD_INT 0
66285: PUSH
66286: EMPTY
66287: LIST
66288: LIST
66289: PUSH
66290: LD_INT 2
66292: PUSH
66293: LD_INT 1
66295: PUSH
66296: EMPTY
66297: LIST
66298: LIST
66299: PUSH
66300: LD_INT 2
66302: PUSH
66303: LD_INT 2
66305: PUSH
66306: EMPTY
66307: LIST
66308: LIST
66309: PUSH
66310: LD_INT 1
66312: PUSH
66313: LD_INT 2
66315: PUSH
66316: EMPTY
66317: LIST
66318: LIST
66319: PUSH
66320: LD_INT 0
66322: PUSH
66323: LD_INT 2
66325: PUSH
66326: EMPTY
66327: LIST
66328: LIST
66329: PUSH
66330: LD_INT 1
66332: NEG
66333: PUSH
66334: LD_INT 1
66336: PUSH
66337: EMPTY
66338: LIST
66339: LIST
66340: PUSH
66341: LD_INT 2
66343: NEG
66344: PUSH
66345: LD_INT 0
66347: PUSH
66348: EMPTY
66349: LIST
66350: LIST
66351: PUSH
66352: LD_INT 2
66354: NEG
66355: PUSH
66356: LD_INT 1
66358: NEG
66359: PUSH
66360: EMPTY
66361: LIST
66362: LIST
66363: PUSH
66364: LD_INT 2
66366: NEG
66367: PUSH
66368: LD_INT 2
66370: NEG
66371: PUSH
66372: EMPTY
66373: LIST
66374: LIST
66375: PUSH
66376: EMPTY
66377: LIST
66378: LIST
66379: LIST
66380: LIST
66381: LIST
66382: LIST
66383: LIST
66384: LIST
66385: LIST
66386: LIST
66387: LIST
66388: LIST
66389: LIST
66390: LIST
66391: LIST
66392: LIST
66393: LIST
66394: LIST
66395: LIST
66396: ST_TO_ADDR
// Barracks5 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
66397: LD_ADDR_VAR 0 58
66401: PUSH
66402: LD_INT 0
66404: PUSH
66405: LD_INT 0
66407: PUSH
66408: EMPTY
66409: LIST
66410: LIST
66411: PUSH
66412: LD_INT 0
66414: PUSH
66415: LD_INT 1
66417: NEG
66418: PUSH
66419: EMPTY
66420: LIST
66421: LIST
66422: PUSH
66423: LD_INT 1
66425: PUSH
66426: LD_INT 0
66428: PUSH
66429: EMPTY
66430: LIST
66431: LIST
66432: PUSH
66433: LD_INT 1
66435: PUSH
66436: LD_INT 1
66438: PUSH
66439: EMPTY
66440: LIST
66441: LIST
66442: PUSH
66443: LD_INT 0
66445: PUSH
66446: LD_INT 1
66448: PUSH
66449: EMPTY
66450: LIST
66451: LIST
66452: PUSH
66453: LD_INT 1
66455: NEG
66456: PUSH
66457: LD_INT 0
66459: PUSH
66460: EMPTY
66461: LIST
66462: LIST
66463: PUSH
66464: LD_INT 1
66466: NEG
66467: PUSH
66468: LD_INT 1
66470: NEG
66471: PUSH
66472: EMPTY
66473: LIST
66474: LIST
66475: PUSH
66476: LD_INT 1
66478: NEG
66479: PUSH
66480: LD_INT 2
66482: NEG
66483: PUSH
66484: EMPTY
66485: LIST
66486: LIST
66487: PUSH
66488: LD_INT 0
66490: PUSH
66491: LD_INT 2
66493: NEG
66494: PUSH
66495: EMPTY
66496: LIST
66497: LIST
66498: PUSH
66499: LD_INT 1
66501: PUSH
66502: LD_INT 1
66504: NEG
66505: PUSH
66506: EMPTY
66507: LIST
66508: LIST
66509: PUSH
66510: LD_INT 2
66512: PUSH
66513: LD_INT 0
66515: PUSH
66516: EMPTY
66517: LIST
66518: LIST
66519: PUSH
66520: LD_INT 2
66522: PUSH
66523: LD_INT 1
66525: PUSH
66526: EMPTY
66527: LIST
66528: LIST
66529: PUSH
66530: LD_INT 2
66532: PUSH
66533: LD_INT 2
66535: PUSH
66536: EMPTY
66537: LIST
66538: LIST
66539: PUSH
66540: LD_INT 1
66542: PUSH
66543: LD_INT 2
66545: PUSH
66546: EMPTY
66547: LIST
66548: LIST
66549: PUSH
66550: LD_INT 0
66552: PUSH
66553: LD_INT 2
66555: PUSH
66556: EMPTY
66557: LIST
66558: LIST
66559: PUSH
66560: LD_INT 1
66562: NEG
66563: PUSH
66564: LD_INT 1
66566: PUSH
66567: EMPTY
66568: LIST
66569: LIST
66570: PUSH
66571: LD_INT 2
66573: NEG
66574: PUSH
66575: LD_INT 0
66577: PUSH
66578: EMPTY
66579: LIST
66580: LIST
66581: PUSH
66582: LD_INT 2
66584: NEG
66585: PUSH
66586: LD_INT 1
66588: NEG
66589: PUSH
66590: EMPTY
66591: LIST
66592: LIST
66593: PUSH
66594: LD_INT 2
66596: NEG
66597: PUSH
66598: LD_INT 2
66600: NEG
66601: PUSH
66602: EMPTY
66603: LIST
66604: LIST
66605: PUSH
66606: EMPTY
66607: LIST
66608: LIST
66609: LIST
66610: LIST
66611: LIST
66612: LIST
66613: LIST
66614: LIST
66615: LIST
66616: LIST
66617: LIST
66618: LIST
66619: LIST
66620: LIST
66621: LIST
66622: LIST
66623: LIST
66624: LIST
66625: LIST
66626: ST_TO_ADDR
// Bunker0 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] ] ;
66627: LD_ADDR_VAR 0 59
66631: PUSH
66632: LD_INT 0
66634: PUSH
66635: LD_INT 0
66637: PUSH
66638: EMPTY
66639: LIST
66640: LIST
66641: PUSH
66642: LD_INT 0
66644: PUSH
66645: LD_INT 1
66647: NEG
66648: PUSH
66649: EMPTY
66650: LIST
66651: LIST
66652: PUSH
66653: LD_INT 1
66655: PUSH
66656: LD_INT 0
66658: PUSH
66659: EMPTY
66660: LIST
66661: LIST
66662: PUSH
66663: LD_INT 1
66665: PUSH
66666: LD_INT 1
66668: PUSH
66669: EMPTY
66670: LIST
66671: LIST
66672: PUSH
66673: LD_INT 0
66675: PUSH
66676: LD_INT 1
66678: PUSH
66679: EMPTY
66680: LIST
66681: LIST
66682: PUSH
66683: LD_INT 1
66685: NEG
66686: PUSH
66687: LD_INT 0
66689: PUSH
66690: EMPTY
66691: LIST
66692: LIST
66693: PUSH
66694: LD_INT 1
66696: NEG
66697: PUSH
66698: LD_INT 1
66700: NEG
66701: PUSH
66702: EMPTY
66703: LIST
66704: LIST
66705: PUSH
66706: EMPTY
66707: LIST
66708: LIST
66709: LIST
66710: LIST
66711: LIST
66712: LIST
66713: LIST
66714: ST_TO_ADDR
// Bunker1 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] ] ;
66715: LD_ADDR_VAR 0 60
66719: PUSH
66720: LD_INT 0
66722: PUSH
66723: LD_INT 0
66725: PUSH
66726: EMPTY
66727: LIST
66728: LIST
66729: PUSH
66730: LD_INT 0
66732: PUSH
66733: LD_INT 1
66735: NEG
66736: PUSH
66737: EMPTY
66738: LIST
66739: LIST
66740: PUSH
66741: LD_INT 1
66743: PUSH
66744: LD_INT 0
66746: PUSH
66747: EMPTY
66748: LIST
66749: LIST
66750: PUSH
66751: LD_INT 1
66753: PUSH
66754: LD_INT 1
66756: PUSH
66757: EMPTY
66758: LIST
66759: LIST
66760: PUSH
66761: LD_INT 0
66763: PUSH
66764: LD_INT 1
66766: PUSH
66767: EMPTY
66768: LIST
66769: LIST
66770: PUSH
66771: LD_INT 1
66773: NEG
66774: PUSH
66775: LD_INT 0
66777: PUSH
66778: EMPTY
66779: LIST
66780: LIST
66781: PUSH
66782: LD_INT 1
66784: NEG
66785: PUSH
66786: LD_INT 1
66788: NEG
66789: PUSH
66790: EMPTY
66791: LIST
66792: LIST
66793: PUSH
66794: EMPTY
66795: LIST
66796: LIST
66797: LIST
66798: LIST
66799: LIST
66800: LIST
66801: LIST
66802: ST_TO_ADDR
// Bunker2 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] ] ;
66803: LD_ADDR_VAR 0 61
66807: PUSH
66808: LD_INT 0
66810: PUSH
66811: LD_INT 0
66813: PUSH
66814: EMPTY
66815: LIST
66816: LIST
66817: PUSH
66818: LD_INT 0
66820: PUSH
66821: LD_INT 1
66823: NEG
66824: PUSH
66825: EMPTY
66826: LIST
66827: LIST
66828: PUSH
66829: LD_INT 1
66831: PUSH
66832: LD_INT 0
66834: PUSH
66835: EMPTY
66836: LIST
66837: LIST
66838: PUSH
66839: LD_INT 1
66841: PUSH
66842: LD_INT 1
66844: PUSH
66845: EMPTY
66846: LIST
66847: LIST
66848: PUSH
66849: LD_INT 0
66851: PUSH
66852: LD_INT 1
66854: PUSH
66855: EMPTY
66856: LIST
66857: LIST
66858: PUSH
66859: LD_INT 1
66861: NEG
66862: PUSH
66863: LD_INT 0
66865: PUSH
66866: EMPTY
66867: LIST
66868: LIST
66869: PUSH
66870: LD_INT 1
66872: NEG
66873: PUSH
66874: LD_INT 1
66876: NEG
66877: PUSH
66878: EMPTY
66879: LIST
66880: LIST
66881: PUSH
66882: EMPTY
66883: LIST
66884: LIST
66885: LIST
66886: LIST
66887: LIST
66888: LIST
66889: LIST
66890: ST_TO_ADDR
// Bunker3 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] ] ;
66891: LD_ADDR_VAR 0 62
66895: PUSH
66896: LD_INT 0
66898: PUSH
66899: LD_INT 0
66901: PUSH
66902: EMPTY
66903: LIST
66904: LIST
66905: PUSH
66906: LD_INT 0
66908: PUSH
66909: LD_INT 1
66911: NEG
66912: PUSH
66913: EMPTY
66914: LIST
66915: LIST
66916: PUSH
66917: LD_INT 1
66919: PUSH
66920: LD_INT 0
66922: PUSH
66923: EMPTY
66924: LIST
66925: LIST
66926: PUSH
66927: LD_INT 1
66929: PUSH
66930: LD_INT 1
66932: PUSH
66933: EMPTY
66934: LIST
66935: LIST
66936: PUSH
66937: LD_INT 0
66939: PUSH
66940: LD_INT 1
66942: PUSH
66943: EMPTY
66944: LIST
66945: LIST
66946: PUSH
66947: LD_INT 1
66949: NEG
66950: PUSH
66951: LD_INT 0
66953: PUSH
66954: EMPTY
66955: LIST
66956: LIST
66957: PUSH
66958: LD_INT 1
66960: NEG
66961: PUSH
66962: LD_INT 1
66964: NEG
66965: PUSH
66966: EMPTY
66967: LIST
66968: LIST
66969: PUSH
66970: EMPTY
66971: LIST
66972: LIST
66973: LIST
66974: LIST
66975: LIST
66976: LIST
66977: LIST
66978: ST_TO_ADDR
// Bunker4 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] ] ;
66979: LD_ADDR_VAR 0 63
66983: PUSH
66984: LD_INT 0
66986: PUSH
66987: LD_INT 0
66989: PUSH
66990: EMPTY
66991: LIST
66992: LIST
66993: PUSH
66994: LD_INT 0
66996: PUSH
66997: LD_INT 1
66999: NEG
67000: PUSH
67001: EMPTY
67002: LIST
67003: LIST
67004: PUSH
67005: LD_INT 1
67007: PUSH
67008: LD_INT 0
67010: PUSH
67011: EMPTY
67012: LIST
67013: LIST
67014: PUSH
67015: LD_INT 1
67017: PUSH
67018: LD_INT 1
67020: PUSH
67021: EMPTY
67022: LIST
67023: LIST
67024: PUSH
67025: LD_INT 0
67027: PUSH
67028: LD_INT 1
67030: PUSH
67031: EMPTY
67032: LIST
67033: LIST
67034: PUSH
67035: LD_INT 1
67037: NEG
67038: PUSH
67039: LD_INT 0
67041: PUSH
67042: EMPTY
67043: LIST
67044: LIST
67045: PUSH
67046: LD_INT 1
67048: NEG
67049: PUSH
67050: LD_INT 1
67052: NEG
67053: PUSH
67054: EMPTY
67055: LIST
67056: LIST
67057: PUSH
67058: EMPTY
67059: LIST
67060: LIST
67061: LIST
67062: LIST
67063: LIST
67064: LIST
67065: LIST
67066: ST_TO_ADDR
// Bunker5 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] ] ;
67067: LD_ADDR_VAR 0 64
67071: PUSH
67072: LD_INT 0
67074: PUSH
67075: LD_INT 0
67077: PUSH
67078: EMPTY
67079: LIST
67080: LIST
67081: PUSH
67082: LD_INT 0
67084: PUSH
67085: LD_INT 1
67087: NEG
67088: PUSH
67089: EMPTY
67090: LIST
67091: LIST
67092: PUSH
67093: LD_INT 1
67095: PUSH
67096: LD_INT 0
67098: PUSH
67099: EMPTY
67100: LIST
67101: LIST
67102: PUSH
67103: LD_INT 1
67105: PUSH
67106: LD_INT 1
67108: PUSH
67109: EMPTY
67110: LIST
67111: LIST
67112: PUSH
67113: LD_INT 0
67115: PUSH
67116: LD_INT 1
67118: PUSH
67119: EMPTY
67120: LIST
67121: LIST
67122: PUSH
67123: LD_INT 1
67125: NEG
67126: PUSH
67127: LD_INT 0
67129: PUSH
67130: EMPTY
67131: LIST
67132: LIST
67133: PUSH
67134: LD_INT 1
67136: NEG
67137: PUSH
67138: LD_INT 1
67140: NEG
67141: PUSH
67142: EMPTY
67143: LIST
67144: LIST
67145: PUSH
67146: EMPTY
67147: LIST
67148: LIST
67149: LIST
67150: LIST
67151: LIST
67152: LIST
67153: LIST
67154: ST_TO_ADDR
// end ; 1 :
67155: GO 73052
67157: LD_INT 1
67159: DOUBLE
67160: EQUAL
67161: IFTRUE 67165
67163: GO 69788
67165: POP
// begin DepotAm0 = [ [ - 1 , - 3 ] , [ 0 , - 3 ] , [ 1 , - 2 ] ] ;
67166: LD_ADDR_VAR 0 11
67170: PUSH
67171: LD_INT 1
67173: NEG
67174: PUSH
67175: LD_INT 3
67177: NEG
67178: PUSH
67179: EMPTY
67180: LIST
67181: LIST
67182: PUSH
67183: LD_INT 0
67185: PUSH
67186: LD_INT 3
67188: NEG
67189: PUSH
67190: EMPTY
67191: LIST
67192: LIST
67193: PUSH
67194: LD_INT 1
67196: PUSH
67197: LD_INT 2
67199: NEG
67200: PUSH
67201: EMPTY
67202: LIST
67203: LIST
67204: PUSH
67205: EMPTY
67206: LIST
67207: LIST
67208: LIST
67209: ST_TO_ADDR
// DepotAm1 = [ [ 2 , - 1 ] , [ 3 , 0 ] , [ 3 , 1 ] ] ;
67210: LD_ADDR_VAR 0 12
67214: PUSH
67215: LD_INT 2
67217: PUSH
67218: LD_INT 1
67220: NEG
67221: PUSH
67222: EMPTY
67223: LIST
67224: LIST
67225: PUSH
67226: LD_INT 3
67228: PUSH
67229: LD_INT 0
67231: PUSH
67232: EMPTY
67233: LIST
67234: LIST
67235: PUSH
67236: LD_INT 3
67238: PUSH
67239: LD_INT 1
67241: PUSH
67242: EMPTY
67243: LIST
67244: LIST
67245: PUSH
67246: EMPTY
67247: LIST
67248: LIST
67249: LIST
67250: ST_TO_ADDR
// DepotAm2 = [ [ 3 , 2 ] , [ 3 , 3 ] , [ 2 , 3 ] ] ;
67251: LD_ADDR_VAR 0 13
67255: PUSH
67256: LD_INT 3
67258: PUSH
67259: LD_INT 2
67261: PUSH
67262: EMPTY
67263: LIST
67264: LIST
67265: PUSH
67266: LD_INT 3
67268: PUSH
67269: LD_INT 3
67271: PUSH
67272: EMPTY
67273: LIST
67274: LIST
67275: PUSH
67276: LD_INT 2
67278: PUSH
67279: LD_INT 3
67281: PUSH
67282: EMPTY
67283: LIST
67284: LIST
67285: PUSH
67286: EMPTY
67287: LIST
67288: LIST
67289: LIST
67290: ST_TO_ADDR
// DepotAm3 = [ [ 1 , 3 ] , [ 0 , 3 ] , [ - 1 , 2 ] ] ;
67291: LD_ADDR_VAR 0 14
67295: PUSH
67296: LD_INT 1
67298: PUSH
67299: LD_INT 3
67301: PUSH
67302: EMPTY
67303: LIST
67304: LIST
67305: PUSH
67306: LD_INT 0
67308: PUSH
67309: LD_INT 3
67311: PUSH
67312: EMPTY
67313: LIST
67314: LIST
67315: PUSH
67316: LD_INT 1
67318: NEG
67319: PUSH
67320: LD_INT 2
67322: PUSH
67323: EMPTY
67324: LIST
67325: LIST
67326: PUSH
67327: EMPTY
67328: LIST
67329: LIST
67330: LIST
67331: ST_TO_ADDR
// DepotAm4 = [ [ - 2 , 1 ] , [ - 3 , 0 ] , [ - 3 , - 1 ] ] ;
67332: LD_ADDR_VAR 0 15
67336: PUSH
67337: LD_INT 2
67339: NEG
67340: PUSH
67341: LD_INT 1
67343: PUSH
67344: EMPTY
67345: LIST
67346: LIST
67347: PUSH
67348: LD_INT 3
67350: NEG
67351: PUSH
67352: LD_INT 0
67354: PUSH
67355: EMPTY
67356: LIST
67357: LIST
67358: PUSH
67359: LD_INT 3
67361: NEG
67362: PUSH
67363: LD_INT 1
67365: NEG
67366: PUSH
67367: EMPTY
67368: LIST
67369: LIST
67370: PUSH
67371: EMPTY
67372: LIST
67373: LIST
67374: LIST
67375: ST_TO_ADDR
// DepotAm5 = [ [ - 2 , - 3 ] , [ - 3 , - 2 ] , [ - 3 , - 3 ] ] ;
67376: LD_ADDR_VAR 0 16
67380: PUSH
67381: LD_INT 2
67383: NEG
67384: PUSH
67385: LD_INT 3
67387: NEG
67388: PUSH
67389: EMPTY
67390: LIST
67391: LIST
67392: PUSH
67393: LD_INT 3
67395: NEG
67396: PUSH
67397: LD_INT 2
67399: NEG
67400: PUSH
67401: EMPTY
67402: LIST
67403: LIST
67404: PUSH
67405: LD_INT 3
67407: NEG
67408: PUSH
67409: LD_INT 3
67411: NEG
67412: PUSH
67413: EMPTY
67414: LIST
67415: LIST
67416: PUSH
67417: EMPTY
67418: LIST
67419: LIST
67420: LIST
67421: ST_TO_ADDR
// DepotAr0 = [ [ - 1 , - 3 ] , [ 0 , - 3 ] , [ 1 , - 2 ] ] ;
67422: LD_ADDR_VAR 0 17
67426: PUSH
67427: LD_INT 1
67429: NEG
67430: PUSH
67431: LD_INT 3
67433: NEG
67434: PUSH
67435: EMPTY
67436: LIST
67437: LIST
67438: PUSH
67439: LD_INT 0
67441: PUSH
67442: LD_INT 3
67444: NEG
67445: PUSH
67446: EMPTY
67447: LIST
67448: LIST
67449: PUSH
67450: LD_INT 1
67452: PUSH
67453: LD_INT 2
67455: NEG
67456: PUSH
67457: EMPTY
67458: LIST
67459: LIST
67460: PUSH
67461: EMPTY
67462: LIST
67463: LIST
67464: LIST
67465: ST_TO_ADDR
// DepotAr1 = [ [ 2 , - 1 ] , [ 3 , 0 ] , [ 3 , 1 ] ] ;
67466: LD_ADDR_VAR 0 18
67470: PUSH
67471: LD_INT 2
67473: PUSH
67474: LD_INT 1
67476: NEG
67477: PUSH
67478: EMPTY
67479: LIST
67480: LIST
67481: PUSH
67482: LD_INT 3
67484: PUSH
67485: LD_INT 0
67487: PUSH
67488: EMPTY
67489: LIST
67490: LIST
67491: PUSH
67492: LD_INT 3
67494: PUSH
67495: LD_INT 1
67497: PUSH
67498: EMPTY
67499: LIST
67500: LIST
67501: PUSH
67502: EMPTY
67503: LIST
67504: LIST
67505: LIST
67506: ST_TO_ADDR
// DepotAr2 = [ [ 3 , 2 ] , [ 3 , 3 ] , [ 2 , 3 ] ] ;
67507: LD_ADDR_VAR 0 19
67511: PUSH
67512: LD_INT 3
67514: PUSH
67515: LD_INT 2
67517: PUSH
67518: EMPTY
67519: LIST
67520: LIST
67521: PUSH
67522: LD_INT 3
67524: PUSH
67525: LD_INT 3
67527: PUSH
67528: EMPTY
67529: LIST
67530: LIST
67531: PUSH
67532: LD_INT 2
67534: PUSH
67535: LD_INT 3
67537: PUSH
67538: EMPTY
67539: LIST
67540: LIST
67541: PUSH
67542: EMPTY
67543: LIST
67544: LIST
67545: LIST
67546: ST_TO_ADDR
// DepotAr3 = [ [ 1 , 3 ] , [ 0 , 3 ] , [ - 1 , 2 ] ] ;
67547: LD_ADDR_VAR 0 20
67551: PUSH
67552: LD_INT 1
67554: PUSH
67555: LD_INT 3
67557: PUSH
67558: EMPTY
67559: LIST
67560: LIST
67561: PUSH
67562: LD_INT 0
67564: PUSH
67565: LD_INT 3
67567: PUSH
67568: EMPTY
67569: LIST
67570: LIST
67571: PUSH
67572: LD_INT 1
67574: NEG
67575: PUSH
67576: LD_INT 2
67578: PUSH
67579: EMPTY
67580: LIST
67581: LIST
67582: PUSH
67583: EMPTY
67584: LIST
67585: LIST
67586: LIST
67587: ST_TO_ADDR
// DepotAr4 = [ [ - 2 , 1 ] , [ - 3 , 0 ] , [ - 3 , - 1 ] ] ;
67588: LD_ADDR_VAR 0 21
67592: PUSH
67593: LD_INT 2
67595: NEG
67596: PUSH
67597: LD_INT 1
67599: PUSH
67600: EMPTY
67601: LIST
67602: LIST
67603: PUSH
67604: LD_INT 3
67606: NEG
67607: PUSH
67608: LD_INT 0
67610: PUSH
67611: EMPTY
67612: LIST
67613: LIST
67614: PUSH
67615: LD_INT 3
67617: NEG
67618: PUSH
67619: LD_INT 1
67621: NEG
67622: PUSH
67623: EMPTY
67624: LIST
67625: LIST
67626: PUSH
67627: EMPTY
67628: LIST
67629: LIST
67630: LIST
67631: ST_TO_ADDR
// DepotAr5 = [ [ - 2 , - 3 ] , [ - 3 , - 2 ] , [ - 3 , - 3 ] ] ;
67632: LD_ADDR_VAR 0 22
67636: PUSH
67637: LD_INT 2
67639: NEG
67640: PUSH
67641: LD_INT 3
67643: NEG
67644: PUSH
67645: EMPTY
67646: LIST
67647: LIST
67648: PUSH
67649: LD_INT 3
67651: NEG
67652: PUSH
67653: LD_INT 2
67655: NEG
67656: PUSH
67657: EMPTY
67658: LIST
67659: LIST
67660: PUSH
67661: LD_INT 3
67663: NEG
67664: PUSH
67665: LD_INT 3
67667: NEG
67668: PUSH
67669: EMPTY
67670: LIST
67671: LIST
67672: PUSH
67673: EMPTY
67674: LIST
67675: LIST
67676: LIST
67677: ST_TO_ADDR
// DepotRu0 = [ [ 0 , - 3 ] , [ - 1 , - 4 ] , [ 1 , - 3 ] ] ;
67678: LD_ADDR_VAR 0 23
67682: PUSH
67683: LD_INT 0
67685: PUSH
67686: LD_INT 3
67688: NEG
67689: PUSH
67690: EMPTY
67691: LIST
67692: LIST
67693: PUSH
67694: LD_INT 1
67696: NEG
67697: PUSH
67698: LD_INT 4
67700: NEG
67701: PUSH
67702: EMPTY
67703: LIST
67704: LIST
67705: PUSH
67706: LD_INT 1
67708: PUSH
67709: LD_INT 3
67711: NEG
67712: PUSH
67713: EMPTY
67714: LIST
67715: LIST
67716: PUSH
67717: EMPTY
67718: LIST
67719: LIST
67720: LIST
67721: ST_TO_ADDR
// DepotRu1 = [ [ 3 , 0 ] , [ 3 , - 1 ] , [ 4 , 1 ] ] ;
67722: LD_ADDR_VAR 0 24
67726: PUSH
67727: LD_INT 3
67729: PUSH
67730: LD_INT 0
67732: PUSH
67733: EMPTY
67734: LIST
67735: LIST
67736: PUSH
67737: LD_INT 3
67739: PUSH
67740: LD_INT 1
67742: NEG
67743: PUSH
67744: EMPTY
67745: LIST
67746: LIST
67747: PUSH
67748: LD_INT 4
67750: PUSH
67751: LD_INT 1
67753: PUSH
67754: EMPTY
67755: LIST
67756: LIST
67757: PUSH
67758: EMPTY
67759: LIST
67760: LIST
67761: LIST
67762: ST_TO_ADDR
// DepotRu2 = [ [ 3 , 3 ] , [ 4 , 3 ] , [ 3 , 4 ] ] ;
67763: LD_ADDR_VAR 0 25
67767: PUSH
67768: LD_INT 3
67770: PUSH
67771: LD_INT 3
67773: PUSH
67774: EMPTY
67775: LIST
67776: LIST
67777: PUSH
67778: LD_INT 4
67780: PUSH
67781: LD_INT 3
67783: PUSH
67784: EMPTY
67785: LIST
67786: LIST
67787: PUSH
67788: LD_INT 3
67790: PUSH
67791: LD_INT 4
67793: PUSH
67794: EMPTY
67795: LIST
67796: LIST
67797: PUSH
67798: EMPTY
67799: LIST
67800: LIST
67801: LIST
67802: ST_TO_ADDR
// DepotRu3 = [ [ 0 , 3 ] , [ 1 , 4 ] , [ - 1 , 3 ] ] ;
67803: LD_ADDR_VAR 0 26
67807: PUSH
67808: LD_INT 0
67810: PUSH
67811: LD_INT 3
67813: PUSH
67814: EMPTY
67815: LIST
67816: LIST
67817: PUSH
67818: LD_INT 1
67820: PUSH
67821: LD_INT 4
67823: PUSH
67824: EMPTY
67825: LIST
67826: LIST
67827: PUSH
67828: LD_INT 1
67830: NEG
67831: PUSH
67832: LD_INT 3
67834: PUSH
67835: EMPTY
67836: LIST
67837: LIST
67838: PUSH
67839: EMPTY
67840: LIST
67841: LIST
67842: LIST
67843: ST_TO_ADDR
// DepotRu4 = [ [ - 3 , 0 ] , [ - 3 , 1 ] , [ - 4 , - 1 ] ] ;
67844: LD_ADDR_VAR 0 27
67848: PUSH
67849: LD_INT 3
67851: NEG
67852: PUSH
67853: LD_INT 0
67855: PUSH
67856: EMPTY
67857: LIST
67858: LIST
67859: PUSH
67860: LD_INT 3
67862: NEG
67863: PUSH
67864: LD_INT 1
67866: PUSH
67867: EMPTY
67868: LIST
67869: LIST
67870: PUSH
67871: LD_INT 4
67873: NEG
67874: PUSH
67875: LD_INT 1
67877: NEG
67878: PUSH
67879: EMPTY
67880: LIST
67881: LIST
67882: PUSH
67883: EMPTY
67884: LIST
67885: LIST
67886: LIST
67887: ST_TO_ADDR
// DepotRu5 = [ [ - 3 , - 3 ] , [ - 3 , - 4 ] , [ - 4 , - 3 ] ] ;
67888: LD_ADDR_VAR 0 28
67892: PUSH
67893: LD_INT 3
67895: NEG
67896: PUSH
67897: LD_INT 3
67899: NEG
67900: PUSH
67901: EMPTY
67902: LIST
67903: LIST
67904: PUSH
67905: LD_INT 3
67907: NEG
67908: PUSH
67909: LD_INT 4
67911: NEG
67912: PUSH
67913: EMPTY
67914: LIST
67915: LIST
67916: PUSH
67917: LD_INT 4
67919: NEG
67920: PUSH
67921: LD_INT 3
67923: NEG
67924: PUSH
67925: EMPTY
67926: LIST
67927: LIST
67928: PUSH
67929: EMPTY
67930: LIST
67931: LIST
67932: LIST
67933: ST_TO_ADDR
// Factory0 = [ [ - 1 , - 3 ] , [ 0 , - 3 ] , [ 1 , - 2 ] , [ - 1 , - 4 ] , [ 0 , - 4 ] , [ 1 , - 3 ] , [ - 1 , - 5 ] , [ 0 , - 5 ] , [ 1 , - 4 ] , [ - 1 , - 6 ] , [ 0 , - 6 ] , [ 1 , - 5 ] ] ;
67934: LD_ADDR_VAR 0 29
67938: PUSH
67939: LD_INT 1
67941: NEG
67942: PUSH
67943: LD_INT 3
67945: NEG
67946: PUSH
67947: EMPTY
67948: LIST
67949: LIST
67950: PUSH
67951: LD_INT 0
67953: PUSH
67954: LD_INT 3
67956: NEG
67957: PUSH
67958: EMPTY
67959: LIST
67960: LIST
67961: PUSH
67962: LD_INT 1
67964: PUSH
67965: LD_INT 2
67967: NEG
67968: PUSH
67969: EMPTY
67970: LIST
67971: LIST
67972: PUSH
67973: LD_INT 1
67975: NEG
67976: PUSH
67977: LD_INT 4
67979: NEG
67980: PUSH
67981: EMPTY
67982: LIST
67983: LIST
67984: PUSH
67985: LD_INT 0
67987: PUSH
67988: LD_INT 4
67990: NEG
67991: PUSH
67992: EMPTY
67993: LIST
67994: LIST
67995: PUSH
67996: LD_INT 1
67998: PUSH
67999: LD_INT 3
68001: NEG
68002: PUSH
68003: EMPTY
68004: LIST
68005: LIST
68006: PUSH
68007: LD_INT 1
68009: NEG
68010: PUSH
68011: LD_INT 5
68013: NEG
68014: PUSH
68015: EMPTY
68016: LIST
68017: LIST
68018: PUSH
68019: LD_INT 0
68021: PUSH
68022: LD_INT 5
68024: NEG
68025: PUSH
68026: EMPTY
68027: LIST
68028: LIST
68029: PUSH
68030: LD_INT 1
68032: PUSH
68033: LD_INT 4
68035: NEG
68036: PUSH
68037: EMPTY
68038: LIST
68039: LIST
68040: PUSH
68041: LD_INT 1
68043: NEG
68044: PUSH
68045: LD_INT 6
68047: NEG
68048: PUSH
68049: EMPTY
68050: LIST
68051: LIST
68052: PUSH
68053: LD_INT 0
68055: PUSH
68056: LD_INT 6
68058: NEG
68059: PUSH
68060: EMPTY
68061: LIST
68062: LIST
68063: PUSH
68064: LD_INT 1
68066: PUSH
68067: LD_INT 5
68069: NEG
68070: PUSH
68071: EMPTY
68072: LIST
68073: LIST
68074: PUSH
68075: EMPTY
68076: LIST
68077: LIST
68078: LIST
68079: LIST
68080: LIST
68081: LIST
68082: LIST
68083: LIST
68084: LIST
68085: LIST
68086: LIST
68087: LIST
68088: ST_TO_ADDR
// Factory1 = [ [ 2 , - 1 ] , [ 3 , 0 ] , [ 3 , 1 ] , [ 3 , - 1 ] , [ 4 , 0 ] , [ 4 , 1 ] , [ 4 , - 1 ] , [ 5 , 0 ] , [ 5 , 1 ] , [ 5 , - 1 ] , [ 6 , 0 ] , [ 6 , 1 ] ] ;
68089: LD_ADDR_VAR 0 30
68093: PUSH
68094: LD_INT 2
68096: PUSH
68097: LD_INT 1
68099: NEG
68100: PUSH
68101: EMPTY
68102: LIST
68103: LIST
68104: PUSH
68105: LD_INT 3
68107: PUSH
68108: LD_INT 0
68110: PUSH
68111: EMPTY
68112: LIST
68113: LIST
68114: PUSH
68115: LD_INT 3
68117: PUSH
68118: LD_INT 1
68120: PUSH
68121: EMPTY
68122: LIST
68123: LIST
68124: PUSH
68125: LD_INT 3
68127: PUSH
68128: LD_INT 1
68130: NEG
68131: PUSH
68132: EMPTY
68133: LIST
68134: LIST
68135: PUSH
68136: LD_INT 4
68138: PUSH
68139: LD_INT 0
68141: PUSH
68142: EMPTY
68143: LIST
68144: LIST
68145: PUSH
68146: LD_INT 4
68148: PUSH
68149: LD_INT 1
68151: PUSH
68152: EMPTY
68153: LIST
68154: LIST
68155: PUSH
68156: LD_INT 4
68158: PUSH
68159: LD_INT 1
68161: NEG
68162: PUSH
68163: EMPTY
68164: LIST
68165: LIST
68166: PUSH
68167: LD_INT 5
68169: PUSH
68170: LD_INT 0
68172: PUSH
68173: EMPTY
68174: LIST
68175: LIST
68176: PUSH
68177: LD_INT 5
68179: PUSH
68180: LD_INT 1
68182: PUSH
68183: EMPTY
68184: LIST
68185: LIST
68186: PUSH
68187: LD_INT 5
68189: PUSH
68190: LD_INT 1
68192: NEG
68193: PUSH
68194: EMPTY
68195: LIST
68196: LIST
68197: PUSH
68198: LD_INT 6
68200: PUSH
68201: LD_INT 0
68203: PUSH
68204: EMPTY
68205: LIST
68206: LIST
68207: PUSH
68208: LD_INT 6
68210: PUSH
68211: LD_INT 1
68213: PUSH
68214: EMPTY
68215: LIST
68216: LIST
68217: PUSH
68218: EMPTY
68219: LIST
68220: LIST
68221: LIST
68222: LIST
68223: LIST
68224: LIST
68225: LIST
68226: LIST
68227: LIST
68228: LIST
68229: LIST
68230: LIST
68231: ST_TO_ADDR
// Factory2 = [ [ 3 , 2 ] , [ 3 , 3 ] , [ 2 , 3 ] , [ 4 , 3 ] , [ 4 , 4 ] , [ 3 , 4 ] , [ 5 , 4 ] , [ 5 , 5 ] , [ 4 , 5 ] , [ 6 , 5 ] , [ 6 , 6 ] , [ 5 , 6 ] ] ;
68232: LD_ADDR_VAR 0 31
68236: PUSH
68237: LD_INT 3
68239: PUSH
68240: LD_INT 2
68242: PUSH
68243: EMPTY
68244: LIST
68245: LIST
68246: PUSH
68247: LD_INT 3
68249: PUSH
68250: LD_INT 3
68252: PUSH
68253: EMPTY
68254: LIST
68255: LIST
68256: PUSH
68257: LD_INT 2
68259: PUSH
68260: LD_INT 3
68262: PUSH
68263: EMPTY
68264: LIST
68265: LIST
68266: PUSH
68267: LD_INT 4
68269: PUSH
68270: LD_INT 3
68272: PUSH
68273: EMPTY
68274: LIST
68275: LIST
68276: PUSH
68277: LD_INT 4
68279: PUSH
68280: LD_INT 4
68282: PUSH
68283: EMPTY
68284: LIST
68285: LIST
68286: PUSH
68287: LD_INT 3
68289: PUSH
68290: LD_INT 4
68292: PUSH
68293: EMPTY
68294: LIST
68295: LIST
68296: PUSH
68297: LD_INT 5
68299: PUSH
68300: LD_INT 4
68302: PUSH
68303: EMPTY
68304: LIST
68305: LIST
68306: PUSH
68307: LD_INT 5
68309: PUSH
68310: LD_INT 5
68312: PUSH
68313: EMPTY
68314: LIST
68315: LIST
68316: PUSH
68317: LD_INT 4
68319: PUSH
68320: LD_INT 5
68322: PUSH
68323: EMPTY
68324: LIST
68325: LIST
68326: PUSH
68327: LD_INT 6
68329: PUSH
68330: LD_INT 5
68332: PUSH
68333: EMPTY
68334: LIST
68335: LIST
68336: PUSH
68337: LD_INT 6
68339: PUSH
68340: LD_INT 6
68342: PUSH
68343: EMPTY
68344: LIST
68345: LIST
68346: PUSH
68347: LD_INT 5
68349: PUSH
68350: LD_INT 6
68352: PUSH
68353: EMPTY
68354: LIST
68355: LIST
68356: PUSH
68357: EMPTY
68358: LIST
68359: LIST
68360: LIST
68361: LIST
68362: LIST
68363: LIST
68364: LIST
68365: LIST
68366: LIST
68367: LIST
68368: LIST
68369: LIST
68370: ST_TO_ADDR
// Factory3 = [ [ 1 , 3 ] , [ 0 , 3 ] , [ - 1 , 2 ] , [ 1 , 4 ] , [ 0 , 4 ] , [ - 1 , 3 ] , [ 1 , 5 ] , [ 0 , 5 ] , [ - 1 , 4 ] , [ 1 , 6 ] , [ 0 , 6 ] , [ - 1 , 5 ] ] ;
68371: LD_ADDR_VAR 0 32
68375: PUSH
68376: LD_INT 1
68378: PUSH
68379: LD_INT 3
68381: PUSH
68382: EMPTY
68383: LIST
68384: LIST
68385: PUSH
68386: LD_INT 0
68388: PUSH
68389: LD_INT 3
68391: PUSH
68392: EMPTY
68393: LIST
68394: LIST
68395: PUSH
68396: LD_INT 1
68398: NEG
68399: PUSH
68400: LD_INT 2
68402: PUSH
68403: EMPTY
68404: LIST
68405: LIST
68406: PUSH
68407: LD_INT 1
68409: PUSH
68410: LD_INT 4
68412: PUSH
68413: EMPTY
68414: LIST
68415: LIST
68416: PUSH
68417: LD_INT 0
68419: PUSH
68420: LD_INT 4
68422: PUSH
68423: EMPTY
68424: LIST
68425: LIST
68426: PUSH
68427: LD_INT 1
68429: NEG
68430: PUSH
68431: LD_INT 3
68433: PUSH
68434: EMPTY
68435: LIST
68436: LIST
68437: PUSH
68438: LD_INT 1
68440: PUSH
68441: LD_INT 5
68443: PUSH
68444: EMPTY
68445: LIST
68446: LIST
68447: PUSH
68448: LD_INT 0
68450: PUSH
68451: LD_INT 5
68453: PUSH
68454: EMPTY
68455: LIST
68456: LIST
68457: PUSH
68458: LD_INT 1
68460: NEG
68461: PUSH
68462: LD_INT 4
68464: PUSH
68465: EMPTY
68466: LIST
68467: LIST
68468: PUSH
68469: LD_INT 1
68471: PUSH
68472: LD_INT 6
68474: PUSH
68475: EMPTY
68476: LIST
68477: LIST
68478: PUSH
68479: LD_INT 0
68481: PUSH
68482: LD_INT 6
68484: PUSH
68485: EMPTY
68486: LIST
68487: LIST
68488: PUSH
68489: LD_INT 1
68491: NEG
68492: PUSH
68493: LD_INT 5
68495: PUSH
68496: EMPTY
68497: LIST
68498: LIST
68499: PUSH
68500: EMPTY
68501: LIST
68502: LIST
68503: LIST
68504: LIST
68505: LIST
68506: LIST
68507: LIST
68508: LIST
68509: LIST
68510: LIST
68511: LIST
68512: LIST
68513: ST_TO_ADDR
// Factory4 = [ [ - 2 , 1 ] , [ - 3 , 0 ] , [ - 3 , - 1 ] , [ - 3 , 1 ] , [ - 4 , 0 ] , [ - 4 , - 1 ] , [ - 4 , 1 ] , [ - 5 , 0 ] , [ - 5 , - 1 ] , [ - 5 , 1 ] , [ - 6 , 0 ] , [ - 6 , - 1 ] ] ;
68514: LD_ADDR_VAR 0 33
68518: PUSH
68519: LD_INT 2
68521: NEG
68522: PUSH
68523: LD_INT 1
68525: PUSH
68526: EMPTY
68527: LIST
68528: LIST
68529: PUSH
68530: LD_INT 3
68532: NEG
68533: PUSH
68534: LD_INT 0
68536: PUSH
68537: EMPTY
68538: LIST
68539: LIST
68540: PUSH
68541: LD_INT 3
68543: NEG
68544: PUSH
68545: LD_INT 1
68547: NEG
68548: PUSH
68549: EMPTY
68550: LIST
68551: LIST
68552: PUSH
68553: LD_INT 3
68555: NEG
68556: PUSH
68557: LD_INT 1
68559: PUSH
68560: EMPTY
68561: LIST
68562: LIST
68563: PUSH
68564: LD_INT 4
68566: NEG
68567: PUSH
68568: LD_INT 0
68570: PUSH
68571: EMPTY
68572: LIST
68573: LIST
68574: PUSH
68575: LD_INT 4
68577: NEG
68578: PUSH
68579: LD_INT 1
68581: NEG
68582: PUSH
68583: EMPTY
68584: LIST
68585: LIST
68586: PUSH
68587: LD_INT 4
68589: NEG
68590: PUSH
68591: LD_INT 1
68593: PUSH
68594: EMPTY
68595: LIST
68596: LIST
68597: PUSH
68598: LD_INT 5
68600: NEG
68601: PUSH
68602: LD_INT 0
68604: PUSH
68605: EMPTY
68606: LIST
68607: LIST
68608: PUSH
68609: LD_INT 5
68611: NEG
68612: PUSH
68613: LD_INT 1
68615: NEG
68616: PUSH
68617: EMPTY
68618: LIST
68619: LIST
68620: PUSH
68621: LD_INT 5
68623: NEG
68624: PUSH
68625: LD_INT 1
68627: PUSH
68628: EMPTY
68629: LIST
68630: LIST
68631: PUSH
68632: LD_INT 6
68634: NEG
68635: PUSH
68636: LD_INT 0
68638: PUSH
68639: EMPTY
68640: LIST
68641: LIST
68642: PUSH
68643: LD_INT 6
68645: NEG
68646: PUSH
68647: LD_INT 1
68649: NEG
68650: PUSH
68651: EMPTY
68652: LIST
68653: LIST
68654: PUSH
68655: EMPTY
68656: LIST
68657: LIST
68658: LIST
68659: LIST
68660: LIST
68661: LIST
68662: LIST
68663: LIST
68664: LIST
68665: LIST
68666: LIST
68667: LIST
68668: ST_TO_ADDR
// Factory5 = [ [ - 2 , - 3 ] , [ - 3 , - 2 ] , [ - 3 , - 3 ] , [ - 3 , - 4 ] , [ - 4 , - 3 ] , [ - 4 , - 4 ] , [ - 4 , - 5 ] , [ - 5 , - 4 ] , [ - 5 , - 5 ] , [ - 5 , - 6 ] , [ - 6 , - 5 ] , [ - 6 , - 6 ] ] ;
68669: LD_ADDR_VAR 0 34
68673: PUSH
68674: LD_INT 2
68676: NEG
68677: PUSH
68678: LD_INT 3
68680: NEG
68681: PUSH
68682: EMPTY
68683: LIST
68684: LIST
68685: PUSH
68686: LD_INT 3
68688: NEG
68689: PUSH
68690: LD_INT 2
68692: NEG
68693: PUSH
68694: EMPTY
68695: LIST
68696: LIST
68697: PUSH
68698: LD_INT 3
68700: NEG
68701: PUSH
68702: LD_INT 3
68704: NEG
68705: PUSH
68706: EMPTY
68707: LIST
68708: LIST
68709: PUSH
68710: LD_INT 3
68712: NEG
68713: PUSH
68714: LD_INT 4
68716: NEG
68717: PUSH
68718: EMPTY
68719: LIST
68720: LIST
68721: PUSH
68722: LD_INT 4
68724: NEG
68725: PUSH
68726: LD_INT 3
68728: NEG
68729: PUSH
68730: EMPTY
68731: LIST
68732: LIST
68733: PUSH
68734: LD_INT 4
68736: NEG
68737: PUSH
68738: LD_INT 4
68740: NEG
68741: PUSH
68742: EMPTY
68743: LIST
68744: LIST
68745: PUSH
68746: LD_INT 4
68748: NEG
68749: PUSH
68750: LD_INT 5
68752: NEG
68753: PUSH
68754: EMPTY
68755: LIST
68756: LIST
68757: PUSH
68758: LD_INT 5
68760: NEG
68761: PUSH
68762: LD_INT 4
68764: NEG
68765: PUSH
68766: EMPTY
68767: LIST
68768: LIST
68769: PUSH
68770: LD_INT 5
68772: NEG
68773: PUSH
68774: LD_INT 5
68776: NEG
68777: PUSH
68778: EMPTY
68779: LIST
68780: LIST
68781: PUSH
68782: LD_INT 5
68784: NEG
68785: PUSH
68786: LD_INT 6
68788: NEG
68789: PUSH
68790: EMPTY
68791: LIST
68792: LIST
68793: PUSH
68794: LD_INT 6
68796: NEG
68797: PUSH
68798: LD_INT 5
68800: NEG
68801: PUSH
68802: EMPTY
68803: LIST
68804: LIST
68805: PUSH
68806: LD_INT 6
68808: NEG
68809: PUSH
68810: LD_INT 6
68812: NEG
68813: PUSH
68814: EMPTY
68815: LIST
68816: LIST
68817: PUSH
68818: EMPTY
68819: LIST
68820: LIST
68821: LIST
68822: LIST
68823: LIST
68824: LIST
68825: LIST
68826: LIST
68827: LIST
68828: LIST
68829: LIST
68830: LIST
68831: ST_TO_ADDR
// Lab0 = [ [ 0 , - 2 ] , [ - 1 , - 3 ] , [ 1 , - 2 ] ] ;
68832: LD_ADDR_VAR 0 41
68836: PUSH
68837: LD_INT 0
68839: PUSH
68840: LD_INT 2
68842: NEG
68843: PUSH
68844: EMPTY
68845: LIST
68846: LIST
68847: PUSH
68848: LD_INT 1
68850: NEG
68851: PUSH
68852: LD_INT 3
68854: NEG
68855: PUSH
68856: EMPTY
68857: LIST
68858: LIST
68859: PUSH
68860: LD_INT 1
68862: PUSH
68863: LD_INT 2
68865: NEG
68866: PUSH
68867: EMPTY
68868: LIST
68869: LIST
68870: PUSH
68871: EMPTY
68872: LIST
68873: LIST
68874: LIST
68875: ST_TO_ADDR
// Lab1 = [ [ 2 , 0 ] , [ 2 , - 1 ] , [ 3 , 1 ] ] ;
68876: LD_ADDR_VAR 0 42
68880: PUSH
68881: LD_INT 2
68883: PUSH
68884: LD_INT 0
68886: PUSH
68887: EMPTY
68888: LIST
68889: LIST
68890: PUSH
68891: LD_INT 2
68893: PUSH
68894: LD_INT 1
68896: NEG
68897: PUSH
68898: EMPTY
68899: LIST
68900: LIST
68901: PUSH
68902: LD_INT 3
68904: PUSH
68905: LD_INT 1
68907: PUSH
68908: EMPTY
68909: LIST
68910: LIST
68911: PUSH
68912: EMPTY
68913: LIST
68914: LIST
68915: LIST
68916: ST_TO_ADDR
// Lab2 = [ [ 2 , 2 ] , [ 3 , 2 ] , [ 2 , 3 ] ] ;
68917: LD_ADDR_VAR 0 43
68921: PUSH
68922: LD_INT 2
68924: PUSH
68925: LD_INT 2
68927: PUSH
68928: EMPTY
68929: LIST
68930: LIST
68931: PUSH
68932: LD_INT 3
68934: PUSH
68935: LD_INT 2
68937: PUSH
68938: EMPTY
68939: LIST
68940: LIST
68941: PUSH
68942: LD_INT 2
68944: PUSH
68945: LD_INT 3
68947: PUSH
68948: EMPTY
68949: LIST
68950: LIST
68951: PUSH
68952: EMPTY
68953: LIST
68954: LIST
68955: LIST
68956: ST_TO_ADDR
// Lab3 = [ [ 0 , 2 ] , [ 1 , 3 ] , [ - 1 , 2 ] ] ;
68957: LD_ADDR_VAR 0 44
68961: PUSH
68962: LD_INT 0
68964: PUSH
68965: LD_INT 2
68967: PUSH
68968: EMPTY
68969: LIST
68970: LIST
68971: PUSH
68972: LD_INT 1
68974: PUSH
68975: LD_INT 3
68977: PUSH
68978: EMPTY
68979: LIST
68980: LIST
68981: PUSH
68982: LD_INT 1
68984: NEG
68985: PUSH
68986: LD_INT 2
68988: PUSH
68989: EMPTY
68990: LIST
68991: LIST
68992: PUSH
68993: EMPTY
68994: LIST
68995: LIST
68996: LIST
68997: ST_TO_ADDR
// Lab4 = [ [ - 2 , 0 ] , [ - 2 , 1 ] , [ - 3 , - 1 ] ] ;
68998: LD_ADDR_VAR 0 45
69002: PUSH
69003: LD_INT 2
69005: NEG
69006: PUSH
69007: LD_INT 0
69009: PUSH
69010: EMPTY
69011: LIST
69012: LIST
69013: PUSH
69014: LD_INT 2
69016: NEG
69017: PUSH
69018: LD_INT 1
69020: PUSH
69021: EMPTY
69022: LIST
69023: LIST
69024: PUSH
69025: LD_INT 3
69027: NEG
69028: PUSH
69029: LD_INT 1
69031: NEG
69032: PUSH
69033: EMPTY
69034: LIST
69035: LIST
69036: PUSH
69037: EMPTY
69038: LIST
69039: LIST
69040: LIST
69041: ST_TO_ADDR
// Lab5 = [ [ - 2 , - 2 ] , [ - 2 , - 3 ] , [ - 3 , - 2 ] ] ;
69042: LD_ADDR_VAR 0 46
69046: PUSH
69047: LD_INT 2
69049: NEG
69050: PUSH
69051: LD_INT 2
69053: NEG
69054: PUSH
69055: EMPTY
69056: LIST
69057: LIST
69058: PUSH
69059: LD_INT 2
69061: NEG
69062: PUSH
69063: LD_INT 3
69065: NEG
69066: PUSH
69067: EMPTY
69068: LIST
69069: LIST
69070: PUSH
69071: LD_INT 3
69073: NEG
69074: PUSH
69075: LD_INT 2
69077: NEG
69078: PUSH
69079: EMPTY
69080: LIST
69081: LIST
69082: PUSH
69083: EMPTY
69084: LIST
69085: LIST
69086: LIST
69087: ST_TO_ADDR
// ControlTower0 = [ [ - 2 , - 3 ] , [ - 1 , - 3 ] ] ;
69088: LD_ADDR_VAR 0 47
69092: PUSH
69093: LD_INT 2
69095: NEG
69096: PUSH
69097: LD_INT 3
69099: NEG
69100: PUSH
69101: EMPTY
69102: LIST
69103: LIST
69104: PUSH
69105: LD_INT 1
69107: NEG
69108: PUSH
69109: LD_INT 3
69111: NEG
69112: PUSH
69113: EMPTY
69114: LIST
69115: LIST
69116: PUSH
69117: EMPTY
69118: LIST
69119: LIST
69120: ST_TO_ADDR
// ControlTower1 = [ [ 1 , - 2 ] , [ 2 , - 1 ] ] ;
69121: LD_ADDR_VAR 0 48
69125: PUSH
69126: LD_INT 1
69128: PUSH
69129: LD_INT 2
69131: NEG
69132: PUSH
69133: EMPTY
69134: LIST
69135: LIST
69136: PUSH
69137: LD_INT 2
69139: PUSH
69140: LD_INT 1
69142: NEG
69143: PUSH
69144: EMPTY
69145: LIST
69146: LIST
69147: PUSH
69148: EMPTY
69149: LIST
69150: LIST
69151: ST_TO_ADDR
// ControlTower2 = [ [ 3 , 1 ] , [ 3 , 2 ] ] ;
69152: LD_ADDR_VAR 0 49
69156: PUSH
69157: LD_INT 3
69159: PUSH
69160: LD_INT 1
69162: PUSH
69163: EMPTY
69164: LIST
69165: LIST
69166: PUSH
69167: LD_INT 3
69169: PUSH
69170: LD_INT 2
69172: PUSH
69173: EMPTY
69174: LIST
69175: LIST
69176: PUSH
69177: EMPTY
69178: LIST
69179: LIST
69180: ST_TO_ADDR
// ControlTower3 = [ [ 2 , 3 ] , [ 1 , 3 ] ] ;
69181: LD_ADDR_VAR 0 50
69185: PUSH
69186: LD_INT 2
69188: PUSH
69189: LD_INT 3
69191: PUSH
69192: EMPTY
69193: LIST
69194: LIST
69195: PUSH
69196: LD_INT 1
69198: PUSH
69199: LD_INT 3
69201: PUSH
69202: EMPTY
69203: LIST
69204: LIST
69205: PUSH
69206: EMPTY
69207: LIST
69208: LIST
69209: ST_TO_ADDR
// ControlTower4 = [ [ - 1 , 2 ] , [ - 2 , 1 ] ] ;
69210: LD_ADDR_VAR 0 51
69214: PUSH
69215: LD_INT 1
69217: NEG
69218: PUSH
69219: LD_INT 2
69221: PUSH
69222: EMPTY
69223: LIST
69224: LIST
69225: PUSH
69226: LD_INT 2
69228: NEG
69229: PUSH
69230: LD_INT 1
69232: PUSH
69233: EMPTY
69234: LIST
69235: LIST
69236: PUSH
69237: EMPTY
69238: LIST
69239: LIST
69240: ST_TO_ADDR
// ControlTower5 = [ [ - 3 , - 1 ] , [ - 3 , - 2 ] ] ;
69241: LD_ADDR_VAR 0 52
69245: PUSH
69246: LD_INT 3
69248: NEG
69249: PUSH
69250: LD_INT 1
69252: NEG
69253: PUSH
69254: EMPTY
69255: LIST
69256: LIST
69257: PUSH
69258: LD_INT 3
69260: NEG
69261: PUSH
69262: LD_INT 2
69264: NEG
69265: PUSH
69266: EMPTY
69267: LIST
69268: LIST
69269: PUSH
69270: EMPTY
69271: LIST
69272: LIST
69273: ST_TO_ADDR
// Barracks0 = [ [ - 1 , - 3 ] , [ 0 , - 3 ] , [ 1 , - 2 ] ] ;
69274: LD_ADDR_VAR 0 53
69278: PUSH
69279: LD_INT 1
69281: NEG
69282: PUSH
69283: LD_INT 3
69285: NEG
69286: PUSH
69287: EMPTY
69288: LIST
69289: LIST
69290: PUSH
69291: LD_INT 0
69293: PUSH
69294: LD_INT 3
69296: NEG
69297: PUSH
69298: EMPTY
69299: LIST
69300: LIST
69301: PUSH
69302: LD_INT 1
69304: PUSH
69305: LD_INT 2
69307: NEG
69308: PUSH
69309: EMPTY
69310: LIST
69311: LIST
69312: PUSH
69313: EMPTY
69314: LIST
69315: LIST
69316: LIST
69317: ST_TO_ADDR
// Barracks1 = [ [ 2 , - 1 ] , [ 3 , 0 ] , [ 3 , 1 ] ] ;
69318: LD_ADDR_VAR 0 54
69322: PUSH
69323: LD_INT 2
69325: PUSH
69326: LD_INT 1
69328: NEG
69329: PUSH
69330: EMPTY
69331: LIST
69332: LIST
69333: PUSH
69334: LD_INT 3
69336: PUSH
69337: LD_INT 0
69339: PUSH
69340: EMPTY
69341: LIST
69342: LIST
69343: PUSH
69344: LD_INT 3
69346: PUSH
69347: LD_INT 1
69349: PUSH
69350: EMPTY
69351: LIST
69352: LIST
69353: PUSH
69354: EMPTY
69355: LIST
69356: LIST
69357: LIST
69358: ST_TO_ADDR
// Barracks2 = [ [ 3 , 2 ] , [ 3 , 3 ] , [ 2 , 3 ] ] ;
69359: LD_ADDR_VAR 0 55
69363: PUSH
69364: LD_INT 3
69366: PUSH
69367: LD_INT 2
69369: PUSH
69370: EMPTY
69371: LIST
69372: LIST
69373: PUSH
69374: LD_INT 3
69376: PUSH
69377: LD_INT 3
69379: PUSH
69380: EMPTY
69381: LIST
69382: LIST
69383: PUSH
69384: LD_INT 2
69386: PUSH
69387: LD_INT 3
69389: PUSH
69390: EMPTY
69391: LIST
69392: LIST
69393: PUSH
69394: EMPTY
69395: LIST
69396: LIST
69397: LIST
69398: ST_TO_ADDR
// Barracks3 = [ [ 1 , 3 ] , [ 0 , 3 ] , [ - 1 , 2 ] ] ;
69399: LD_ADDR_VAR 0 56
69403: PUSH
69404: LD_INT 1
69406: PUSH
69407: LD_INT 3
69409: PUSH
69410: EMPTY
69411: LIST
69412: LIST
69413: PUSH
69414: LD_INT 0
69416: PUSH
69417: LD_INT 3
69419: PUSH
69420: EMPTY
69421: LIST
69422: LIST
69423: PUSH
69424: LD_INT 1
69426: NEG
69427: PUSH
69428: LD_INT 2
69430: PUSH
69431: EMPTY
69432: LIST
69433: LIST
69434: PUSH
69435: EMPTY
69436: LIST
69437: LIST
69438: LIST
69439: ST_TO_ADDR
// Barracks4 = [ [ - 2 , 1 ] , [ - 3 , 0 ] , [ - 3 , - 1 ] ] ;
69440: LD_ADDR_VAR 0 57
69444: PUSH
69445: LD_INT 2
69447: NEG
69448: PUSH
69449: LD_INT 1
69451: PUSH
69452: EMPTY
69453: LIST
69454: LIST
69455: PUSH
69456: LD_INT 3
69458: NEG
69459: PUSH
69460: LD_INT 0
69462: PUSH
69463: EMPTY
69464: LIST
69465: LIST
69466: PUSH
69467: LD_INT 3
69469: NEG
69470: PUSH
69471: LD_INT 1
69473: NEG
69474: PUSH
69475: EMPTY
69476: LIST
69477: LIST
69478: PUSH
69479: EMPTY
69480: LIST
69481: LIST
69482: LIST
69483: ST_TO_ADDR
// Barracks5 = [ [ - 2 , - 3 ] , [ - 3 , - 2 ] , [ - 3 , - 3 ] ] ;
69484: LD_ADDR_VAR 0 58
69488: PUSH
69489: LD_INT 2
69491: NEG
69492: PUSH
69493: LD_INT 3
69495: NEG
69496: PUSH
69497: EMPTY
69498: LIST
69499: LIST
69500: PUSH
69501: LD_INT 3
69503: NEG
69504: PUSH
69505: LD_INT 2
69507: NEG
69508: PUSH
69509: EMPTY
69510: LIST
69511: LIST
69512: PUSH
69513: LD_INT 3
69515: NEG
69516: PUSH
69517: LD_INT 3
69519: NEG
69520: PUSH
69521: EMPTY
69522: LIST
69523: LIST
69524: PUSH
69525: EMPTY
69526: LIST
69527: LIST
69528: LIST
69529: ST_TO_ADDR
// Bunker0 = [ [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] ] ;
69530: LD_ADDR_VAR 0 59
69534: PUSH
69535: LD_INT 1
69537: NEG
69538: PUSH
69539: LD_INT 2
69541: NEG
69542: PUSH
69543: EMPTY
69544: LIST
69545: LIST
69546: PUSH
69547: LD_INT 0
69549: PUSH
69550: LD_INT 2
69552: NEG
69553: PUSH
69554: EMPTY
69555: LIST
69556: LIST
69557: PUSH
69558: LD_INT 1
69560: PUSH
69561: LD_INT 1
69563: NEG
69564: PUSH
69565: EMPTY
69566: LIST
69567: LIST
69568: PUSH
69569: EMPTY
69570: LIST
69571: LIST
69572: LIST
69573: ST_TO_ADDR
// Bunker1 = [ [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] ] ;
69574: LD_ADDR_VAR 0 60
69578: PUSH
69579: LD_INT 1
69581: PUSH
69582: LD_INT 1
69584: NEG
69585: PUSH
69586: EMPTY
69587: LIST
69588: LIST
69589: PUSH
69590: LD_INT 2
69592: PUSH
69593: LD_INT 0
69595: PUSH
69596: EMPTY
69597: LIST
69598: LIST
69599: PUSH
69600: LD_INT 2
69602: PUSH
69603: LD_INT 1
69605: PUSH
69606: EMPTY
69607: LIST
69608: LIST
69609: PUSH
69610: EMPTY
69611: LIST
69612: LIST
69613: LIST
69614: ST_TO_ADDR
// Bunker2 = [ [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] ] ;
69615: LD_ADDR_VAR 0 61
69619: PUSH
69620: LD_INT 2
69622: PUSH
69623: LD_INT 1
69625: PUSH
69626: EMPTY
69627: LIST
69628: LIST
69629: PUSH
69630: LD_INT 2
69632: PUSH
69633: LD_INT 2
69635: PUSH
69636: EMPTY
69637: LIST
69638: LIST
69639: PUSH
69640: LD_INT 1
69642: PUSH
69643: LD_INT 2
69645: PUSH
69646: EMPTY
69647: LIST
69648: LIST
69649: PUSH
69650: EMPTY
69651: LIST
69652: LIST
69653: LIST
69654: ST_TO_ADDR
// Bunker3 = [ [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] ] ;
69655: LD_ADDR_VAR 0 62
69659: PUSH
69660: LD_INT 1
69662: PUSH
69663: LD_INT 2
69665: PUSH
69666: EMPTY
69667: LIST
69668: LIST
69669: PUSH
69670: LD_INT 0
69672: PUSH
69673: LD_INT 2
69675: PUSH
69676: EMPTY
69677: LIST
69678: LIST
69679: PUSH
69680: LD_INT 1
69682: NEG
69683: PUSH
69684: LD_INT 1
69686: PUSH
69687: EMPTY
69688: LIST
69689: LIST
69690: PUSH
69691: EMPTY
69692: LIST
69693: LIST
69694: LIST
69695: ST_TO_ADDR
// Bunker4 = [ [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] ] ;
69696: LD_ADDR_VAR 0 63
69700: PUSH
69701: LD_INT 1
69703: NEG
69704: PUSH
69705: LD_INT 1
69707: PUSH
69708: EMPTY
69709: LIST
69710: LIST
69711: PUSH
69712: LD_INT 2
69714: NEG
69715: PUSH
69716: LD_INT 0
69718: PUSH
69719: EMPTY
69720: LIST
69721: LIST
69722: PUSH
69723: LD_INT 2
69725: NEG
69726: PUSH
69727: LD_INT 1
69729: NEG
69730: PUSH
69731: EMPTY
69732: LIST
69733: LIST
69734: PUSH
69735: EMPTY
69736: LIST
69737: LIST
69738: LIST
69739: ST_TO_ADDR
// Bunker5 = [ [ - 1 , - 2 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
69740: LD_ADDR_VAR 0 64
69744: PUSH
69745: LD_INT 1
69747: NEG
69748: PUSH
69749: LD_INT 2
69751: NEG
69752: PUSH
69753: EMPTY
69754: LIST
69755: LIST
69756: PUSH
69757: LD_INT 2
69759: NEG
69760: PUSH
69761: LD_INT 1
69763: NEG
69764: PUSH
69765: EMPTY
69766: LIST
69767: LIST
69768: PUSH
69769: LD_INT 2
69771: NEG
69772: PUSH
69773: LD_INT 2
69775: NEG
69776: PUSH
69777: EMPTY
69778: LIST
69779: LIST
69780: PUSH
69781: EMPTY
69782: LIST
69783: LIST
69784: LIST
69785: ST_TO_ADDR
// end ; 2 :
69786: GO 73052
69788: LD_INT 2
69790: DOUBLE
69791: EQUAL
69792: IFTRUE 69796
69794: GO 73051
69796: POP
// begin Factory0 = [ [ 4 , 0 ] , [ 4 , - 1 ] , [ 5 , 0 ] , [ 5 , 1 ] , [ 4 , 1 ] , [ 3 , 0 ] , [ 3 , - 1 ] , [ 3 , - 2 ] , [ 5 , 2 ] , [ 3 , 3 ] , [ 3 , 2 ] , [ 4 , 3 ] , [ 4 , 4 ] , [ 3 , 4 ] , [ 2 , 3 ] , [ 2 , 2 ] , [ 4 , 2 ] , [ 2 , 4 ] , [ 0 , 4 ] , [ 0 , 3 ] , [ 1 , 4 ] , [ 1 , 5 ] , [ 0 , 5 ] , [ - 1 , 4 ] , [ - 1 , 3 ] , [ 2 , 5 ] , [ - 2 , 3 ] , [ - 3 , 0 ] , [ - 3 , - 1 ] , [ - 2 , 0 ] , [ - 2 , 1 ] , [ - 3 , 1 ] , [ - 4 , 0 ] , [ - 4 , - 1 ] , [ - 4 , - 2 ] , [ - 2 , 2 ] , [ - 4 , - 4 ] , [ - 4 , - 5 ] , [ - 3 , - 4 ] , [ - 3 , - 3 ] , [ - 4 , - 3 ] , [ - 5 , - 4 ] , [ - 5 , - 5 ] , [ - 3 , - 5 ] , [ - 5 , - 3 ] ] ;
69797: LD_ADDR_VAR 0 29
69801: PUSH
69802: LD_INT 4
69804: PUSH
69805: LD_INT 0
69807: PUSH
69808: EMPTY
69809: LIST
69810: LIST
69811: PUSH
69812: LD_INT 4
69814: PUSH
69815: LD_INT 1
69817: NEG
69818: PUSH
69819: EMPTY
69820: LIST
69821: LIST
69822: PUSH
69823: LD_INT 5
69825: PUSH
69826: LD_INT 0
69828: PUSH
69829: EMPTY
69830: LIST
69831: LIST
69832: PUSH
69833: LD_INT 5
69835: PUSH
69836: LD_INT 1
69838: PUSH
69839: EMPTY
69840: LIST
69841: LIST
69842: PUSH
69843: LD_INT 4
69845: PUSH
69846: LD_INT 1
69848: PUSH
69849: EMPTY
69850: LIST
69851: LIST
69852: PUSH
69853: LD_INT 3
69855: PUSH
69856: LD_INT 0
69858: PUSH
69859: EMPTY
69860: LIST
69861: LIST
69862: PUSH
69863: LD_INT 3
69865: PUSH
69866: LD_INT 1
69868: NEG
69869: PUSH
69870: EMPTY
69871: LIST
69872: LIST
69873: PUSH
69874: LD_INT 3
69876: PUSH
69877: LD_INT 2
69879: NEG
69880: PUSH
69881: EMPTY
69882: LIST
69883: LIST
69884: PUSH
69885: LD_INT 5
69887: PUSH
69888: LD_INT 2
69890: PUSH
69891: EMPTY
69892: LIST
69893: LIST
69894: PUSH
69895: LD_INT 3
69897: PUSH
69898: LD_INT 3
69900: PUSH
69901: EMPTY
69902: LIST
69903: LIST
69904: PUSH
69905: LD_INT 3
69907: PUSH
69908: LD_INT 2
69910: PUSH
69911: EMPTY
69912: LIST
69913: LIST
69914: PUSH
69915: LD_INT 4
69917: PUSH
69918: LD_INT 3
69920: PUSH
69921: EMPTY
69922: LIST
69923: LIST
69924: PUSH
69925: LD_INT 4
69927: PUSH
69928: LD_INT 4
69930: PUSH
69931: EMPTY
69932: LIST
69933: LIST
69934: PUSH
69935: LD_INT 3
69937: PUSH
69938: LD_INT 4
69940: PUSH
69941: EMPTY
69942: LIST
69943: LIST
69944: PUSH
69945: LD_INT 2
69947: PUSH
69948: LD_INT 3
69950: PUSH
69951: EMPTY
69952: LIST
69953: LIST
69954: PUSH
69955: LD_INT 2
69957: PUSH
69958: LD_INT 2
69960: PUSH
69961: EMPTY
69962: LIST
69963: LIST
69964: PUSH
69965: LD_INT 4
69967: PUSH
69968: LD_INT 2
69970: PUSH
69971: EMPTY
69972: LIST
69973: LIST
69974: PUSH
69975: LD_INT 2
69977: PUSH
69978: LD_INT 4
69980: PUSH
69981: EMPTY
69982: LIST
69983: LIST
69984: PUSH
69985: LD_INT 0
69987: PUSH
69988: LD_INT 4
69990: PUSH
69991: EMPTY
69992: LIST
69993: LIST
69994: PUSH
69995: LD_INT 0
69997: PUSH
69998: LD_INT 3
70000: PUSH
70001: EMPTY
70002: LIST
70003: LIST
70004: PUSH
70005: LD_INT 1
70007: PUSH
70008: LD_INT 4
70010: PUSH
70011: EMPTY
70012: LIST
70013: LIST
70014: PUSH
70015: LD_INT 1
70017: PUSH
70018: LD_INT 5
70020: PUSH
70021: EMPTY
70022: LIST
70023: LIST
70024: PUSH
70025: LD_INT 0
70027: PUSH
70028: LD_INT 5
70030: PUSH
70031: EMPTY
70032: LIST
70033: LIST
70034: PUSH
70035: LD_INT 1
70037: NEG
70038: PUSH
70039: LD_INT 4
70041: PUSH
70042: EMPTY
70043: LIST
70044: LIST
70045: PUSH
70046: LD_INT 1
70048: NEG
70049: PUSH
70050: LD_INT 3
70052: PUSH
70053: EMPTY
70054: LIST
70055: LIST
70056: PUSH
70057: LD_INT 2
70059: PUSH
70060: LD_INT 5
70062: PUSH
70063: EMPTY
70064: LIST
70065: LIST
70066: PUSH
70067: LD_INT 2
70069: NEG
70070: PUSH
70071: LD_INT 3
70073: PUSH
70074: EMPTY
70075: LIST
70076: LIST
70077: PUSH
70078: LD_INT 3
70080: NEG
70081: PUSH
70082: LD_INT 0
70084: PUSH
70085: EMPTY
70086: LIST
70087: LIST
70088: PUSH
70089: LD_INT 3
70091: NEG
70092: PUSH
70093: LD_INT 1
70095: NEG
70096: PUSH
70097: EMPTY
70098: LIST
70099: LIST
70100: PUSH
70101: LD_INT 2
70103: NEG
70104: PUSH
70105: LD_INT 0
70107: PUSH
70108: EMPTY
70109: LIST
70110: LIST
70111: PUSH
70112: LD_INT 2
70114: NEG
70115: PUSH
70116: LD_INT 1
70118: PUSH
70119: EMPTY
70120: LIST
70121: LIST
70122: PUSH
70123: LD_INT 3
70125: NEG
70126: PUSH
70127: LD_INT 1
70129: PUSH
70130: EMPTY
70131: LIST
70132: LIST
70133: PUSH
70134: LD_INT 4
70136: NEG
70137: PUSH
70138: LD_INT 0
70140: PUSH
70141: EMPTY
70142: LIST
70143: LIST
70144: PUSH
70145: LD_INT 4
70147: NEG
70148: PUSH
70149: LD_INT 1
70151: NEG
70152: PUSH
70153: EMPTY
70154: LIST
70155: LIST
70156: PUSH
70157: LD_INT 4
70159: NEG
70160: PUSH
70161: LD_INT 2
70163: NEG
70164: PUSH
70165: EMPTY
70166: LIST
70167: LIST
70168: PUSH
70169: LD_INT 2
70171: NEG
70172: PUSH
70173: LD_INT 2
70175: PUSH
70176: EMPTY
70177: LIST
70178: LIST
70179: PUSH
70180: LD_INT 4
70182: NEG
70183: PUSH
70184: LD_INT 4
70186: NEG
70187: PUSH
70188: EMPTY
70189: LIST
70190: LIST
70191: PUSH
70192: LD_INT 4
70194: NEG
70195: PUSH
70196: LD_INT 5
70198: NEG
70199: PUSH
70200: EMPTY
70201: LIST
70202: LIST
70203: PUSH
70204: LD_INT 3
70206: NEG
70207: PUSH
70208: LD_INT 4
70210: NEG
70211: PUSH
70212: EMPTY
70213: LIST
70214: LIST
70215: PUSH
70216: LD_INT 3
70218: NEG
70219: PUSH
70220: LD_INT 3
70222: NEG
70223: PUSH
70224: EMPTY
70225: LIST
70226: LIST
70227: PUSH
70228: LD_INT 4
70230: NEG
70231: PUSH
70232: LD_INT 3
70234: NEG
70235: PUSH
70236: EMPTY
70237: LIST
70238: LIST
70239: PUSH
70240: LD_INT 5
70242: NEG
70243: PUSH
70244: LD_INT 4
70246: NEG
70247: PUSH
70248: EMPTY
70249: LIST
70250: LIST
70251: PUSH
70252: LD_INT 5
70254: NEG
70255: PUSH
70256: LD_INT 5
70258: NEG
70259: PUSH
70260: EMPTY
70261: LIST
70262: LIST
70263: PUSH
70264: LD_INT 3
70266: NEG
70267: PUSH
70268: LD_INT 5
70270: NEG
70271: PUSH
70272: EMPTY
70273: LIST
70274: LIST
70275: PUSH
70276: LD_INT 5
70278: NEG
70279: PUSH
70280: LD_INT 3
70282: NEG
70283: PUSH
70284: EMPTY
70285: LIST
70286: LIST
70287: PUSH
70288: EMPTY
70289: LIST
70290: LIST
70291: LIST
70292: LIST
70293: LIST
70294: LIST
70295: LIST
70296: LIST
70297: LIST
70298: LIST
70299: LIST
70300: LIST
70301: LIST
70302: LIST
70303: LIST
70304: LIST
70305: LIST
70306: LIST
70307: LIST
70308: LIST
70309: LIST
70310: LIST
70311: LIST
70312: LIST
70313: LIST
70314: LIST
70315: LIST
70316: LIST
70317: LIST
70318: LIST
70319: LIST
70320: LIST
70321: LIST
70322: LIST
70323: LIST
70324: LIST
70325: LIST
70326: LIST
70327: LIST
70328: LIST
70329: LIST
70330: LIST
70331: LIST
70332: LIST
70333: LIST
70334: ST_TO_ADDR
// Factory1 = [ [ 4 , 4 ] , [ 4 , 3 ] , [ 5 , 4 ] , [ 5 , 5 ] , [ 4 , 5 ] , [ 3 , 4 ] , [ 3 , 3 ] , [ 5 , 3 ] , [ 3 , 5 ] , [ 0 , 3 ] , [ 0 , 2 ] , [ 1 , 3 ] , [ 1 , 4 ] , [ 0 , 4 ] , [ - 1 , 3 ] , [ - 1 , 2 ] , [ 2 , 4 ] , [ - 2 , 2 ] , [ - 4 , 0 ] , [ - 4 , - 1 ] , [ - 3 , 0 ] , [ - 3 , 1 ] , [ - 4 , 1 ] , [ - 5 , 0 ] , [ - 5 , - 1 ] , [ - 5 , - 2 ] , [ - 3 , 2 ] , [ - 3 , - 3 ] , [ - 3 , - 4 ] , [ - 2 , - 3 ] , [ - 2 , - 2 ] , [ - 3 , - 2 ] , [ - 4 , - 3 ] , [ - 4 , - 4 ] , [ - 2 , - 4 ] , [ - 4 , - 2 ] , [ 0 , - 4 ] , [ 0 , - 5 ] , [ 1 , - 4 ] , [ 1 , - 3 ] , [ 0 , - 3 ] , [ - 1 , - 4 ] , [ - 1 , - 5 ] , [ 2 , - 3 ] , [ - 2 , - 5 ] ] ;
70335: LD_ADDR_VAR 0 30
70339: PUSH
70340: LD_INT 4
70342: PUSH
70343: LD_INT 4
70345: PUSH
70346: EMPTY
70347: LIST
70348: LIST
70349: PUSH
70350: LD_INT 4
70352: PUSH
70353: LD_INT 3
70355: PUSH
70356: EMPTY
70357: LIST
70358: LIST
70359: PUSH
70360: LD_INT 5
70362: PUSH
70363: LD_INT 4
70365: PUSH
70366: EMPTY
70367: LIST
70368: LIST
70369: PUSH
70370: LD_INT 5
70372: PUSH
70373: LD_INT 5
70375: PUSH
70376: EMPTY
70377: LIST
70378: LIST
70379: PUSH
70380: LD_INT 4
70382: PUSH
70383: LD_INT 5
70385: PUSH
70386: EMPTY
70387: LIST
70388: LIST
70389: PUSH
70390: LD_INT 3
70392: PUSH
70393: LD_INT 4
70395: PUSH
70396: EMPTY
70397: LIST
70398: LIST
70399: PUSH
70400: LD_INT 3
70402: PUSH
70403: LD_INT 3
70405: PUSH
70406: EMPTY
70407: LIST
70408: LIST
70409: PUSH
70410: LD_INT 5
70412: PUSH
70413: LD_INT 3
70415: PUSH
70416: EMPTY
70417: LIST
70418: LIST
70419: PUSH
70420: LD_INT 3
70422: PUSH
70423: LD_INT 5
70425: PUSH
70426: EMPTY
70427: LIST
70428: LIST
70429: PUSH
70430: LD_INT 0
70432: PUSH
70433: LD_INT 3
70435: PUSH
70436: EMPTY
70437: LIST
70438: LIST
70439: PUSH
70440: LD_INT 0
70442: PUSH
70443: LD_INT 2
70445: PUSH
70446: EMPTY
70447: LIST
70448: LIST
70449: PUSH
70450: LD_INT 1
70452: PUSH
70453: LD_INT 3
70455: PUSH
70456: EMPTY
70457: LIST
70458: LIST
70459: PUSH
70460: LD_INT 1
70462: PUSH
70463: LD_INT 4
70465: PUSH
70466: EMPTY
70467: LIST
70468: LIST
70469: PUSH
70470: LD_INT 0
70472: PUSH
70473: LD_INT 4
70475: PUSH
70476: EMPTY
70477: LIST
70478: LIST
70479: PUSH
70480: LD_INT 1
70482: NEG
70483: PUSH
70484: LD_INT 3
70486: PUSH
70487: EMPTY
70488: LIST
70489: LIST
70490: PUSH
70491: LD_INT 1
70493: NEG
70494: PUSH
70495: LD_INT 2
70497: PUSH
70498: EMPTY
70499: LIST
70500: LIST
70501: PUSH
70502: LD_INT 2
70504: PUSH
70505: LD_INT 4
70507: PUSH
70508: EMPTY
70509: LIST
70510: LIST
70511: PUSH
70512: LD_INT 2
70514: NEG
70515: PUSH
70516: LD_INT 2
70518: PUSH
70519: EMPTY
70520: LIST
70521: LIST
70522: PUSH
70523: LD_INT 4
70525: NEG
70526: PUSH
70527: LD_INT 0
70529: PUSH
70530: EMPTY
70531: LIST
70532: LIST
70533: PUSH
70534: LD_INT 4
70536: NEG
70537: PUSH
70538: LD_INT 1
70540: NEG
70541: PUSH
70542: EMPTY
70543: LIST
70544: LIST
70545: PUSH
70546: LD_INT 3
70548: NEG
70549: PUSH
70550: LD_INT 0
70552: PUSH
70553: EMPTY
70554: LIST
70555: LIST
70556: PUSH
70557: LD_INT 3
70559: NEG
70560: PUSH
70561: LD_INT 1
70563: PUSH
70564: EMPTY
70565: LIST
70566: LIST
70567: PUSH
70568: LD_INT 4
70570: NEG
70571: PUSH
70572: LD_INT 1
70574: PUSH
70575: EMPTY
70576: LIST
70577: LIST
70578: PUSH
70579: LD_INT 5
70581: NEG
70582: PUSH
70583: LD_INT 0
70585: PUSH
70586: EMPTY
70587: LIST
70588: LIST
70589: PUSH
70590: LD_INT 5
70592: NEG
70593: PUSH
70594: LD_INT 1
70596: NEG
70597: PUSH
70598: EMPTY
70599: LIST
70600: LIST
70601: PUSH
70602: LD_INT 5
70604: NEG
70605: PUSH
70606: LD_INT 2
70608: NEG
70609: PUSH
70610: EMPTY
70611: LIST
70612: LIST
70613: PUSH
70614: LD_INT 3
70616: NEG
70617: PUSH
70618: LD_INT 2
70620: PUSH
70621: EMPTY
70622: LIST
70623: LIST
70624: PUSH
70625: LD_INT 3
70627: NEG
70628: PUSH
70629: LD_INT 3
70631: NEG
70632: PUSH
70633: EMPTY
70634: LIST
70635: LIST
70636: PUSH
70637: LD_INT 3
70639: NEG
70640: PUSH
70641: LD_INT 4
70643: NEG
70644: PUSH
70645: EMPTY
70646: LIST
70647: LIST
70648: PUSH
70649: LD_INT 2
70651: NEG
70652: PUSH
70653: LD_INT 3
70655: NEG
70656: PUSH
70657: EMPTY
70658: LIST
70659: LIST
70660: PUSH
70661: LD_INT 2
70663: NEG
70664: PUSH
70665: LD_INT 2
70667: NEG
70668: PUSH
70669: EMPTY
70670: LIST
70671: LIST
70672: PUSH
70673: LD_INT 3
70675: NEG
70676: PUSH
70677: LD_INT 2
70679: NEG
70680: PUSH
70681: EMPTY
70682: LIST
70683: LIST
70684: PUSH
70685: LD_INT 4
70687: NEG
70688: PUSH
70689: LD_INT 3
70691: NEG
70692: PUSH
70693: EMPTY
70694: LIST
70695: LIST
70696: PUSH
70697: LD_INT 4
70699: NEG
70700: PUSH
70701: LD_INT 4
70703: NEG
70704: PUSH
70705: EMPTY
70706: LIST
70707: LIST
70708: PUSH
70709: LD_INT 2
70711: NEG
70712: PUSH
70713: LD_INT 4
70715: NEG
70716: PUSH
70717: EMPTY
70718: LIST
70719: LIST
70720: PUSH
70721: LD_INT 4
70723: NEG
70724: PUSH
70725: LD_INT 2
70727: NEG
70728: PUSH
70729: EMPTY
70730: LIST
70731: LIST
70732: PUSH
70733: LD_INT 0
70735: PUSH
70736: LD_INT 4
70738: NEG
70739: PUSH
70740: EMPTY
70741: LIST
70742: LIST
70743: PUSH
70744: LD_INT 0
70746: PUSH
70747: LD_INT 5
70749: NEG
70750: PUSH
70751: EMPTY
70752: LIST
70753: LIST
70754: PUSH
70755: LD_INT 1
70757: PUSH
70758: LD_INT 4
70760: NEG
70761: PUSH
70762: EMPTY
70763: LIST
70764: LIST
70765: PUSH
70766: LD_INT 1
70768: PUSH
70769: LD_INT 3
70771: NEG
70772: PUSH
70773: EMPTY
70774: LIST
70775: LIST
70776: PUSH
70777: LD_INT 0
70779: PUSH
70780: LD_INT 3
70782: NEG
70783: PUSH
70784: EMPTY
70785: LIST
70786: LIST
70787: PUSH
70788: LD_INT 1
70790: NEG
70791: PUSH
70792: LD_INT 4
70794: NEG
70795: PUSH
70796: EMPTY
70797: LIST
70798: LIST
70799: PUSH
70800: LD_INT 1
70802: NEG
70803: PUSH
70804: LD_INT 5
70806: NEG
70807: PUSH
70808: EMPTY
70809: LIST
70810: LIST
70811: PUSH
70812: LD_INT 2
70814: PUSH
70815: LD_INT 3
70817: NEG
70818: PUSH
70819: EMPTY
70820: LIST
70821: LIST
70822: PUSH
70823: LD_INT 2
70825: NEG
70826: PUSH
70827: LD_INT 5
70829: NEG
70830: PUSH
70831: EMPTY
70832: LIST
70833: LIST
70834: PUSH
70835: EMPTY
70836: LIST
70837: LIST
70838: LIST
70839: LIST
70840: LIST
70841: LIST
70842: LIST
70843: LIST
70844: LIST
70845: LIST
70846: LIST
70847: LIST
70848: LIST
70849: LIST
70850: LIST
70851: LIST
70852: LIST
70853: LIST
70854: LIST
70855: LIST
70856: LIST
70857: LIST
70858: LIST
70859: LIST
70860: LIST
70861: LIST
70862: LIST
70863: LIST
70864: LIST
70865: LIST
70866: LIST
70867: LIST
70868: LIST
70869: LIST
70870: LIST
70871: LIST
70872: LIST
70873: LIST
70874: LIST
70875: LIST
70876: LIST
70877: LIST
70878: LIST
70879: LIST
70880: LIST
70881: ST_TO_ADDR
// Factory2 = [ [ 0 , 4 ] , [ 0 , 3 ] , [ 1 , 4 ] , [ 1 , 5 ] , [ 0 , 5 ] , [ - 1 , 4 ] , [ - 1 , 3 ] , [ 2 , 5 ] , [ - 2 , 3 ] , [ - 3 , 0 ] , [ - 3 , - 1 ] , [ - 2 , 0 ] , [ - 2 , 1 ] , [ - 3 , 1 ] , [ - 4 , 0 ] , [ - 4 , - 1 ] , [ - 4 , - 2 ] , [ - 2 , 2 ] , [ - 4 , - 4 ] , [ - 4 , - 5 ] , [ - 3 , - 4 ] , [ - 3 , - 3 ] , [ - 4 , - 3 ] , [ - 5 , - 4 ] , [ - 5 , - 5 ] , [ - 3 , - 5 ] , [ - 5 , - 3 ] , [ 0 , - 3 ] , [ 0 , - 4 ] , [ 1 , - 3 ] , [ 1 , - 2 ] , [ 0 , - 2 ] , [ - 1 , - 3 ] , [ - 1 , - 4 ] , [ 2 , - 2 ] , [ - 2 , - 4 ] , [ 4 , 0 ] , [ 4 , - 1 ] , [ 5 , 0 ] , [ 5 , 1 ] , [ 4 , 1 ] , [ 3 , 0 ] , [ 3 , - 1 ] , [ 3 , - 2 ] , [ 5 , 2 ] ] ;
70882: LD_ADDR_VAR 0 31
70886: PUSH
70887: LD_INT 0
70889: PUSH
70890: LD_INT 4
70892: PUSH
70893: EMPTY
70894: LIST
70895: LIST
70896: PUSH
70897: LD_INT 0
70899: PUSH
70900: LD_INT 3
70902: PUSH
70903: EMPTY
70904: LIST
70905: LIST
70906: PUSH
70907: LD_INT 1
70909: PUSH
70910: LD_INT 4
70912: PUSH
70913: EMPTY
70914: LIST
70915: LIST
70916: PUSH
70917: LD_INT 1
70919: PUSH
70920: LD_INT 5
70922: PUSH
70923: EMPTY
70924: LIST
70925: LIST
70926: PUSH
70927: LD_INT 0
70929: PUSH
70930: LD_INT 5
70932: PUSH
70933: EMPTY
70934: LIST
70935: LIST
70936: PUSH
70937: LD_INT 1
70939: NEG
70940: PUSH
70941: LD_INT 4
70943: PUSH
70944: EMPTY
70945: LIST
70946: LIST
70947: PUSH
70948: LD_INT 1
70950: NEG
70951: PUSH
70952: LD_INT 3
70954: PUSH
70955: EMPTY
70956: LIST
70957: LIST
70958: PUSH
70959: LD_INT 2
70961: PUSH
70962: LD_INT 5
70964: PUSH
70965: EMPTY
70966: LIST
70967: LIST
70968: PUSH
70969: LD_INT 2
70971: NEG
70972: PUSH
70973: LD_INT 3
70975: PUSH
70976: EMPTY
70977: LIST
70978: LIST
70979: PUSH
70980: LD_INT 3
70982: NEG
70983: PUSH
70984: LD_INT 0
70986: PUSH
70987: EMPTY
70988: LIST
70989: LIST
70990: PUSH
70991: LD_INT 3
70993: NEG
70994: PUSH
70995: LD_INT 1
70997: NEG
70998: PUSH
70999: EMPTY
71000: LIST
71001: LIST
71002: PUSH
71003: LD_INT 2
71005: NEG
71006: PUSH
71007: LD_INT 0
71009: PUSH
71010: EMPTY
71011: LIST
71012: LIST
71013: PUSH
71014: LD_INT 2
71016: NEG
71017: PUSH
71018: LD_INT 1
71020: PUSH
71021: EMPTY
71022: LIST
71023: LIST
71024: PUSH
71025: LD_INT 3
71027: NEG
71028: PUSH
71029: LD_INT 1
71031: PUSH
71032: EMPTY
71033: LIST
71034: LIST
71035: PUSH
71036: LD_INT 4
71038: NEG
71039: PUSH
71040: LD_INT 0
71042: PUSH
71043: EMPTY
71044: LIST
71045: LIST
71046: PUSH
71047: LD_INT 4
71049: NEG
71050: PUSH
71051: LD_INT 1
71053: NEG
71054: PUSH
71055: EMPTY
71056: LIST
71057: LIST
71058: PUSH
71059: LD_INT 4
71061: NEG
71062: PUSH
71063: LD_INT 2
71065: NEG
71066: PUSH
71067: EMPTY
71068: LIST
71069: LIST
71070: PUSH
71071: LD_INT 2
71073: NEG
71074: PUSH
71075: LD_INT 2
71077: PUSH
71078: EMPTY
71079: LIST
71080: LIST
71081: PUSH
71082: LD_INT 4
71084: NEG
71085: PUSH
71086: LD_INT 4
71088: NEG
71089: PUSH
71090: EMPTY
71091: LIST
71092: LIST
71093: PUSH
71094: LD_INT 4
71096: NEG
71097: PUSH
71098: LD_INT 5
71100: NEG
71101: PUSH
71102: EMPTY
71103: LIST
71104: LIST
71105: PUSH
71106: LD_INT 3
71108: NEG
71109: PUSH
71110: LD_INT 4
71112: NEG
71113: PUSH
71114: EMPTY
71115: LIST
71116: LIST
71117: PUSH
71118: LD_INT 3
71120: NEG
71121: PUSH
71122: LD_INT 3
71124: NEG
71125: PUSH
71126: EMPTY
71127: LIST
71128: LIST
71129: PUSH
71130: LD_INT 4
71132: NEG
71133: PUSH
71134: LD_INT 3
71136: NEG
71137: PUSH
71138: EMPTY
71139: LIST
71140: LIST
71141: PUSH
71142: LD_INT 5
71144: NEG
71145: PUSH
71146: LD_INT 4
71148: NEG
71149: PUSH
71150: EMPTY
71151: LIST
71152: LIST
71153: PUSH
71154: LD_INT 5
71156: NEG
71157: PUSH
71158: LD_INT 5
71160: NEG
71161: PUSH
71162: EMPTY
71163: LIST
71164: LIST
71165: PUSH
71166: LD_INT 3
71168: NEG
71169: PUSH
71170: LD_INT 5
71172: NEG
71173: PUSH
71174: EMPTY
71175: LIST
71176: LIST
71177: PUSH
71178: LD_INT 5
71180: NEG
71181: PUSH
71182: LD_INT 3
71184: NEG
71185: PUSH
71186: EMPTY
71187: LIST
71188: LIST
71189: PUSH
71190: LD_INT 0
71192: PUSH
71193: LD_INT 3
71195: NEG
71196: PUSH
71197: EMPTY
71198: LIST
71199: LIST
71200: PUSH
71201: LD_INT 0
71203: PUSH
71204: LD_INT 4
71206: NEG
71207: PUSH
71208: EMPTY
71209: LIST
71210: LIST
71211: PUSH
71212: LD_INT 1
71214: PUSH
71215: LD_INT 3
71217: NEG
71218: PUSH
71219: EMPTY
71220: LIST
71221: LIST
71222: PUSH
71223: LD_INT 1
71225: PUSH
71226: LD_INT 2
71228: NEG
71229: PUSH
71230: EMPTY
71231: LIST
71232: LIST
71233: PUSH
71234: LD_INT 0
71236: PUSH
71237: LD_INT 2
71239: NEG
71240: PUSH
71241: EMPTY
71242: LIST
71243: LIST
71244: PUSH
71245: LD_INT 1
71247: NEG
71248: PUSH
71249: LD_INT 3
71251: NEG
71252: PUSH
71253: EMPTY
71254: LIST
71255: LIST
71256: PUSH
71257: LD_INT 1
71259: NEG
71260: PUSH
71261: LD_INT 4
71263: NEG
71264: PUSH
71265: EMPTY
71266: LIST
71267: LIST
71268: PUSH
71269: LD_INT 2
71271: PUSH
71272: LD_INT 2
71274: NEG
71275: PUSH
71276: EMPTY
71277: LIST
71278: LIST
71279: PUSH
71280: LD_INT 2
71282: NEG
71283: PUSH
71284: LD_INT 4
71286: NEG
71287: PUSH
71288: EMPTY
71289: LIST
71290: LIST
71291: PUSH
71292: LD_INT 4
71294: PUSH
71295: LD_INT 0
71297: PUSH
71298: EMPTY
71299: LIST
71300: LIST
71301: PUSH
71302: LD_INT 4
71304: PUSH
71305: LD_INT 1
71307: NEG
71308: PUSH
71309: EMPTY
71310: LIST
71311: LIST
71312: PUSH
71313: LD_INT 5
71315: PUSH
71316: LD_INT 0
71318: PUSH
71319: EMPTY
71320: LIST
71321: LIST
71322: PUSH
71323: LD_INT 5
71325: PUSH
71326: LD_INT 1
71328: PUSH
71329: EMPTY
71330: LIST
71331: LIST
71332: PUSH
71333: LD_INT 4
71335: PUSH
71336: LD_INT 1
71338: PUSH
71339: EMPTY
71340: LIST
71341: LIST
71342: PUSH
71343: LD_INT 3
71345: PUSH
71346: LD_INT 0
71348: PUSH
71349: EMPTY
71350: LIST
71351: LIST
71352: PUSH
71353: LD_INT 3
71355: PUSH
71356: LD_INT 1
71358: NEG
71359: PUSH
71360: EMPTY
71361: LIST
71362: LIST
71363: PUSH
71364: LD_INT 3
71366: PUSH
71367: LD_INT 2
71369: NEG
71370: PUSH
71371: EMPTY
71372: LIST
71373: LIST
71374: PUSH
71375: LD_INT 5
71377: PUSH
71378: LD_INT 2
71380: PUSH
71381: EMPTY
71382: LIST
71383: LIST
71384: PUSH
71385: EMPTY
71386: LIST
71387: LIST
71388: LIST
71389: LIST
71390: LIST
71391: LIST
71392: LIST
71393: LIST
71394: LIST
71395: LIST
71396: LIST
71397: LIST
71398: LIST
71399: LIST
71400: LIST
71401: LIST
71402: LIST
71403: LIST
71404: LIST
71405: LIST
71406: LIST
71407: LIST
71408: LIST
71409: LIST
71410: LIST
71411: LIST
71412: LIST
71413: LIST
71414: LIST
71415: LIST
71416: LIST
71417: LIST
71418: LIST
71419: LIST
71420: LIST
71421: LIST
71422: LIST
71423: LIST
71424: LIST
71425: LIST
71426: LIST
71427: LIST
71428: LIST
71429: LIST
71430: LIST
71431: ST_TO_ADDR
// Factory3 = [ [ - 4 , 0 ] , [ - 4 , - 1 ] , [ - 3 , 0 ] , [ - 3 , 1 ] , [ - 4 , 1 ] , [ - 5 , 0 ] , [ - 5 , - 1 ] , [ - 5 , - 2 ] , [ - 3 , 2 ] , [ - 3 , - 3 ] , [ - 3 , - 4 ] , [ - 2 , - 3 ] , [ - 2 , - 2 ] , [ - 3 , - 2 ] , [ - 4 , - 3 ] , [ - 4 , - 4 ] , [ - 2 , - 4 ] , [ - 4 , - 2 ] , [ 0 , - 4 ] , [ 0 , - 5 ] , [ 1 , - 4 ] , [ 1 , - 3 ] , [ 0 , - 3 ] , [ - 1 , - 4 ] , [ - 1 , - 5 ] , [ 2 , - 3 ] , [ - 2 , - 5 ] , [ 3 , 0 ] , [ 3 , - 1 ] , [ 4 , 0 ] , [ 4 , 1 ] , [ 3 , 1 ] , [ 2 , 0 ] , [ 2 , - 1 ] , [ 2 , - 2 ] , [ 4 , 2 ] , [ 4 , 4 ] , [ 4 , 3 ] , [ 5 , 4 ] , [ 5 , 5 ] , [ 4 , 5 ] , [ 3 , 4 ] , [ 3 , 3 ] , [ 5 , 3 ] , [ 3 , 5 ] ] ;
71432: LD_ADDR_VAR 0 32
71436: PUSH
71437: LD_INT 4
71439: NEG
71440: PUSH
71441: LD_INT 0
71443: PUSH
71444: EMPTY
71445: LIST
71446: LIST
71447: PUSH
71448: LD_INT 4
71450: NEG
71451: PUSH
71452: LD_INT 1
71454: NEG
71455: PUSH
71456: EMPTY
71457: LIST
71458: LIST
71459: PUSH
71460: LD_INT 3
71462: NEG
71463: PUSH
71464: LD_INT 0
71466: PUSH
71467: EMPTY
71468: LIST
71469: LIST
71470: PUSH
71471: LD_INT 3
71473: NEG
71474: PUSH
71475: LD_INT 1
71477: PUSH
71478: EMPTY
71479: LIST
71480: LIST
71481: PUSH
71482: LD_INT 4
71484: NEG
71485: PUSH
71486: LD_INT 1
71488: PUSH
71489: EMPTY
71490: LIST
71491: LIST
71492: PUSH
71493: LD_INT 5
71495: NEG
71496: PUSH
71497: LD_INT 0
71499: PUSH
71500: EMPTY
71501: LIST
71502: LIST
71503: PUSH
71504: LD_INT 5
71506: NEG
71507: PUSH
71508: LD_INT 1
71510: NEG
71511: PUSH
71512: EMPTY
71513: LIST
71514: LIST
71515: PUSH
71516: LD_INT 5
71518: NEG
71519: PUSH
71520: LD_INT 2
71522: NEG
71523: PUSH
71524: EMPTY
71525: LIST
71526: LIST
71527: PUSH
71528: LD_INT 3
71530: NEG
71531: PUSH
71532: LD_INT 2
71534: PUSH
71535: EMPTY
71536: LIST
71537: LIST
71538: PUSH
71539: LD_INT 3
71541: NEG
71542: PUSH
71543: LD_INT 3
71545: NEG
71546: PUSH
71547: EMPTY
71548: LIST
71549: LIST
71550: PUSH
71551: LD_INT 3
71553: NEG
71554: PUSH
71555: LD_INT 4
71557: NEG
71558: PUSH
71559: EMPTY
71560: LIST
71561: LIST
71562: PUSH
71563: LD_INT 2
71565: NEG
71566: PUSH
71567: LD_INT 3
71569: NEG
71570: PUSH
71571: EMPTY
71572: LIST
71573: LIST
71574: PUSH
71575: LD_INT 2
71577: NEG
71578: PUSH
71579: LD_INT 2
71581: NEG
71582: PUSH
71583: EMPTY
71584: LIST
71585: LIST
71586: PUSH
71587: LD_INT 3
71589: NEG
71590: PUSH
71591: LD_INT 2
71593: NEG
71594: PUSH
71595: EMPTY
71596: LIST
71597: LIST
71598: PUSH
71599: LD_INT 4
71601: NEG
71602: PUSH
71603: LD_INT 3
71605: NEG
71606: PUSH
71607: EMPTY
71608: LIST
71609: LIST
71610: PUSH
71611: LD_INT 4
71613: NEG
71614: PUSH
71615: LD_INT 4
71617: NEG
71618: PUSH
71619: EMPTY
71620: LIST
71621: LIST
71622: PUSH
71623: LD_INT 2
71625: NEG
71626: PUSH
71627: LD_INT 4
71629: NEG
71630: PUSH
71631: EMPTY
71632: LIST
71633: LIST
71634: PUSH
71635: LD_INT 4
71637: NEG
71638: PUSH
71639: LD_INT 2
71641: NEG
71642: PUSH
71643: EMPTY
71644: LIST
71645: LIST
71646: PUSH
71647: LD_INT 0
71649: PUSH
71650: LD_INT 4
71652: NEG
71653: PUSH
71654: EMPTY
71655: LIST
71656: LIST
71657: PUSH
71658: LD_INT 0
71660: PUSH
71661: LD_INT 5
71663: NEG
71664: PUSH
71665: EMPTY
71666: LIST
71667: LIST
71668: PUSH
71669: LD_INT 1
71671: PUSH
71672: LD_INT 4
71674: NEG
71675: PUSH
71676: EMPTY
71677: LIST
71678: LIST
71679: PUSH
71680: LD_INT 1
71682: PUSH
71683: LD_INT 3
71685: NEG
71686: PUSH
71687: EMPTY
71688: LIST
71689: LIST
71690: PUSH
71691: LD_INT 0
71693: PUSH
71694: LD_INT 3
71696: NEG
71697: PUSH
71698: EMPTY
71699: LIST
71700: LIST
71701: PUSH
71702: LD_INT 1
71704: NEG
71705: PUSH
71706: LD_INT 4
71708: NEG
71709: PUSH
71710: EMPTY
71711: LIST
71712: LIST
71713: PUSH
71714: LD_INT 1
71716: NEG
71717: PUSH
71718: LD_INT 5
71720: NEG
71721: PUSH
71722: EMPTY
71723: LIST
71724: LIST
71725: PUSH
71726: LD_INT 2
71728: PUSH
71729: LD_INT 3
71731: NEG
71732: PUSH
71733: EMPTY
71734: LIST
71735: LIST
71736: PUSH
71737: LD_INT 2
71739: NEG
71740: PUSH
71741: LD_INT 5
71743: NEG
71744: PUSH
71745: EMPTY
71746: LIST
71747: LIST
71748: PUSH
71749: LD_INT 3
71751: PUSH
71752: LD_INT 0
71754: PUSH
71755: EMPTY
71756: LIST
71757: LIST
71758: PUSH
71759: LD_INT 3
71761: PUSH
71762: LD_INT 1
71764: NEG
71765: PUSH
71766: EMPTY
71767: LIST
71768: LIST
71769: PUSH
71770: LD_INT 4
71772: PUSH
71773: LD_INT 0
71775: PUSH
71776: EMPTY
71777: LIST
71778: LIST
71779: PUSH
71780: LD_INT 4
71782: PUSH
71783: LD_INT 1
71785: PUSH
71786: EMPTY
71787: LIST
71788: LIST
71789: PUSH
71790: LD_INT 3
71792: PUSH
71793: LD_INT 1
71795: PUSH
71796: EMPTY
71797: LIST
71798: LIST
71799: PUSH
71800: LD_INT 2
71802: PUSH
71803: LD_INT 0
71805: PUSH
71806: EMPTY
71807: LIST
71808: LIST
71809: PUSH
71810: LD_INT 2
71812: PUSH
71813: LD_INT 1
71815: NEG
71816: PUSH
71817: EMPTY
71818: LIST
71819: LIST
71820: PUSH
71821: LD_INT 2
71823: PUSH
71824: LD_INT 2
71826: NEG
71827: PUSH
71828: EMPTY
71829: LIST
71830: LIST
71831: PUSH
71832: LD_INT 4
71834: PUSH
71835: LD_INT 2
71837: PUSH
71838: EMPTY
71839: LIST
71840: LIST
71841: PUSH
71842: LD_INT 4
71844: PUSH
71845: LD_INT 4
71847: PUSH
71848: EMPTY
71849: LIST
71850: LIST
71851: PUSH
71852: LD_INT 4
71854: PUSH
71855: LD_INT 3
71857: PUSH
71858: EMPTY
71859: LIST
71860: LIST
71861: PUSH
71862: LD_INT 5
71864: PUSH
71865: LD_INT 4
71867: PUSH
71868: EMPTY
71869: LIST
71870: LIST
71871: PUSH
71872: LD_INT 5
71874: PUSH
71875: LD_INT 5
71877: PUSH
71878: EMPTY
71879: LIST
71880: LIST
71881: PUSH
71882: LD_INT 4
71884: PUSH
71885: LD_INT 5
71887: PUSH
71888: EMPTY
71889: LIST
71890: LIST
71891: PUSH
71892: LD_INT 3
71894: PUSH
71895: LD_INT 4
71897: PUSH
71898: EMPTY
71899: LIST
71900: LIST
71901: PUSH
71902: LD_INT 3
71904: PUSH
71905: LD_INT 3
71907: PUSH
71908: EMPTY
71909: LIST
71910: LIST
71911: PUSH
71912: LD_INT 5
71914: PUSH
71915: LD_INT 3
71917: PUSH
71918: EMPTY
71919: LIST
71920: LIST
71921: PUSH
71922: LD_INT 3
71924: PUSH
71925: LD_INT 5
71927: PUSH
71928: EMPTY
71929: LIST
71930: LIST
71931: PUSH
71932: EMPTY
71933: LIST
71934: LIST
71935: LIST
71936: LIST
71937: LIST
71938: LIST
71939: LIST
71940: LIST
71941: LIST
71942: LIST
71943: LIST
71944: LIST
71945: LIST
71946: LIST
71947: LIST
71948: LIST
71949: LIST
71950: LIST
71951: LIST
71952: LIST
71953: LIST
71954: LIST
71955: LIST
71956: LIST
71957: LIST
71958: LIST
71959: LIST
71960: LIST
71961: LIST
71962: LIST
71963: LIST
71964: LIST
71965: LIST
71966: LIST
71967: LIST
71968: LIST
71969: LIST
71970: LIST
71971: LIST
71972: LIST
71973: LIST
71974: LIST
71975: LIST
71976: LIST
71977: LIST
71978: ST_TO_ADDR
// Factory4 = [ [ - 4 , - 4 ] , [ - 4 , - 5 ] , [ - 3 , - 4 ] , [ - 3 , - 3 ] , [ - 4 , - 3 ] , [ - 5 , - 4 ] , [ - 5 , - 5 ] , [ - 3 , - 5 ] , [ - 5 , - 3 ] , [ 0 , - 3 ] , [ 0 , - 4 ] , [ 1 , - 3 ] , [ 1 , - 2 ] , [ 0 , - 2 ] , [ - 1 , - 3 ] , [ - 1 , - 4 ] , [ 2 , - 2 ] , [ - 2 , - 4 ] , [ 4 , 0 ] , [ 4 , - 1 ] , [ 5 , 0 ] , [ 5 , 1 ] , [ 4 , 1 ] , [ 3 , 0 ] , [ 3 , - 1 ] , [ 3 , - 2 ] , [ 5 , 2 ] , [ 3 , 3 ] , [ 3 , 2 ] , [ 4 , 3 ] , [ 4 , 4 ] , [ 3 , 4 ] , [ 2 , 3 ] , [ 2 , 2 ] , [ 4 , 2 ] , [ 2 , 4 ] , [ 0 , 4 ] , [ 0 , 3 ] , [ 1 , 4 ] , [ 1 , 5 ] , [ 0 , 5 ] , [ - 1 , 4 ] , [ - 1 , 3 ] , [ 2 , 5 ] , [ - 2 , 3 ] ] ;
71979: LD_ADDR_VAR 0 33
71983: PUSH
71984: LD_INT 4
71986: NEG
71987: PUSH
71988: LD_INT 4
71990: NEG
71991: PUSH
71992: EMPTY
71993: LIST
71994: LIST
71995: PUSH
71996: LD_INT 4
71998: NEG
71999: PUSH
72000: LD_INT 5
72002: NEG
72003: PUSH
72004: EMPTY
72005: LIST
72006: LIST
72007: PUSH
72008: LD_INT 3
72010: NEG
72011: PUSH
72012: LD_INT 4
72014: NEG
72015: PUSH
72016: EMPTY
72017: LIST
72018: LIST
72019: PUSH
72020: LD_INT 3
72022: NEG
72023: PUSH
72024: LD_INT 3
72026: NEG
72027: PUSH
72028: EMPTY
72029: LIST
72030: LIST
72031: PUSH
72032: LD_INT 4
72034: NEG
72035: PUSH
72036: LD_INT 3
72038: NEG
72039: PUSH
72040: EMPTY
72041: LIST
72042: LIST
72043: PUSH
72044: LD_INT 5
72046: NEG
72047: PUSH
72048: LD_INT 4
72050: NEG
72051: PUSH
72052: EMPTY
72053: LIST
72054: LIST
72055: PUSH
72056: LD_INT 5
72058: NEG
72059: PUSH
72060: LD_INT 5
72062: NEG
72063: PUSH
72064: EMPTY
72065: LIST
72066: LIST
72067: PUSH
72068: LD_INT 3
72070: NEG
72071: PUSH
72072: LD_INT 5
72074: NEG
72075: PUSH
72076: EMPTY
72077: LIST
72078: LIST
72079: PUSH
72080: LD_INT 5
72082: NEG
72083: PUSH
72084: LD_INT 3
72086: NEG
72087: PUSH
72088: EMPTY
72089: LIST
72090: LIST
72091: PUSH
72092: LD_INT 0
72094: PUSH
72095: LD_INT 3
72097: NEG
72098: PUSH
72099: EMPTY
72100: LIST
72101: LIST
72102: PUSH
72103: LD_INT 0
72105: PUSH
72106: LD_INT 4
72108: NEG
72109: PUSH
72110: EMPTY
72111: LIST
72112: LIST
72113: PUSH
72114: LD_INT 1
72116: PUSH
72117: LD_INT 3
72119: NEG
72120: PUSH
72121: EMPTY
72122: LIST
72123: LIST
72124: PUSH
72125: LD_INT 1
72127: PUSH
72128: LD_INT 2
72130: NEG
72131: PUSH
72132: EMPTY
72133: LIST
72134: LIST
72135: PUSH
72136: LD_INT 0
72138: PUSH
72139: LD_INT 2
72141: NEG
72142: PUSH
72143: EMPTY
72144: LIST
72145: LIST
72146: PUSH
72147: LD_INT 1
72149: NEG
72150: PUSH
72151: LD_INT 3
72153: NEG
72154: PUSH
72155: EMPTY
72156: LIST
72157: LIST
72158: PUSH
72159: LD_INT 1
72161: NEG
72162: PUSH
72163: LD_INT 4
72165: NEG
72166: PUSH
72167: EMPTY
72168: LIST
72169: LIST
72170: PUSH
72171: LD_INT 2
72173: PUSH
72174: LD_INT 2
72176: NEG
72177: PUSH
72178: EMPTY
72179: LIST
72180: LIST
72181: PUSH
72182: LD_INT 2
72184: NEG
72185: PUSH
72186: LD_INT 4
72188: NEG
72189: PUSH
72190: EMPTY
72191: LIST
72192: LIST
72193: PUSH
72194: LD_INT 4
72196: PUSH
72197: LD_INT 0
72199: PUSH
72200: EMPTY
72201: LIST
72202: LIST
72203: PUSH
72204: LD_INT 4
72206: PUSH
72207: LD_INT 1
72209: NEG
72210: PUSH
72211: EMPTY
72212: LIST
72213: LIST
72214: PUSH
72215: LD_INT 5
72217: PUSH
72218: LD_INT 0
72220: PUSH
72221: EMPTY
72222: LIST
72223: LIST
72224: PUSH
72225: LD_INT 5
72227: PUSH
72228: LD_INT 1
72230: PUSH
72231: EMPTY
72232: LIST
72233: LIST
72234: PUSH
72235: LD_INT 4
72237: PUSH
72238: LD_INT 1
72240: PUSH
72241: EMPTY
72242: LIST
72243: LIST
72244: PUSH
72245: LD_INT 3
72247: PUSH
72248: LD_INT 0
72250: PUSH
72251: EMPTY
72252: LIST
72253: LIST
72254: PUSH
72255: LD_INT 3
72257: PUSH
72258: LD_INT 1
72260: NEG
72261: PUSH
72262: EMPTY
72263: LIST
72264: LIST
72265: PUSH
72266: LD_INT 3
72268: PUSH
72269: LD_INT 2
72271: NEG
72272: PUSH
72273: EMPTY
72274: LIST
72275: LIST
72276: PUSH
72277: LD_INT 5
72279: PUSH
72280: LD_INT 2
72282: PUSH
72283: EMPTY
72284: LIST
72285: LIST
72286: PUSH
72287: LD_INT 3
72289: PUSH
72290: LD_INT 3
72292: PUSH
72293: EMPTY
72294: LIST
72295: LIST
72296: PUSH
72297: LD_INT 3
72299: PUSH
72300: LD_INT 2
72302: PUSH
72303: EMPTY
72304: LIST
72305: LIST
72306: PUSH
72307: LD_INT 4
72309: PUSH
72310: LD_INT 3
72312: PUSH
72313: EMPTY
72314: LIST
72315: LIST
72316: PUSH
72317: LD_INT 4
72319: PUSH
72320: LD_INT 4
72322: PUSH
72323: EMPTY
72324: LIST
72325: LIST
72326: PUSH
72327: LD_INT 3
72329: PUSH
72330: LD_INT 4
72332: PUSH
72333: EMPTY
72334: LIST
72335: LIST
72336: PUSH
72337: LD_INT 2
72339: PUSH
72340: LD_INT 3
72342: PUSH
72343: EMPTY
72344: LIST
72345: LIST
72346: PUSH
72347: LD_INT 2
72349: PUSH
72350: LD_INT 2
72352: PUSH
72353: EMPTY
72354: LIST
72355: LIST
72356: PUSH
72357: LD_INT 4
72359: PUSH
72360: LD_INT 2
72362: PUSH
72363: EMPTY
72364: LIST
72365: LIST
72366: PUSH
72367: LD_INT 2
72369: PUSH
72370: LD_INT 4
72372: PUSH
72373: EMPTY
72374: LIST
72375: LIST
72376: PUSH
72377: LD_INT 0
72379: PUSH
72380: LD_INT 4
72382: PUSH
72383: EMPTY
72384: LIST
72385: LIST
72386: PUSH
72387: LD_INT 0
72389: PUSH
72390: LD_INT 3
72392: PUSH
72393: EMPTY
72394: LIST
72395: LIST
72396: PUSH
72397: LD_INT 1
72399: PUSH
72400: LD_INT 4
72402: PUSH
72403: EMPTY
72404: LIST
72405: LIST
72406: PUSH
72407: LD_INT 1
72409: PUSH
72410: LD_INT 5
72412: PUSH
72413: EMPTY
72414: LIST
72415: LIST
72416: PUSH
72417: LD_INT 0
72419: PUSH
72420: LD_INT 5
72422: PUSH
72423: EMPTY
72424: LIST
72425: LIST
72426: PUSH
72427: LD_INT 1
72429: NEG
72430: PUSH
72431: LD_INT 4
72433: PUSH
72434: EMPTY
72435: LIST
72436: LIST
72437: PUSH
72438: LD_INT 1
72440: NEG
72441: PUSH
72442: LD_INT 3
72444: PUSH
72445: EMPTY
72446: LIST
72447: LIST
72448: PUSH
72449: LD_INT 2
72451: PUSH
72452: LD_INT 5
72454: PUSH
72455: EMPTY
72456: LIST
72457: LIST
72458: PUSH
72459: LD_INT 2
72461: NEG
72462: PUSH
72463: LD_INT 3
72465: PUSH
72466: EMPTY
72467: LIST
72468: LIST
72469: PUSH
72470: EMPTY
72471: LIST
72472: LIST
72473: LIST
72474: LIST
72475: LIST
72476: LIST
72477: LIST
72478: LIST
72479: LIST
72480: LIST
72481: LIST
72482: LIST
72483: LIST
72484: LIST
72485: LIST
72486: LIST
72487: LIST
72488: LIST
72489: LIST
72490: LIST
72491: LIST
72492: LIST
72493: LIST
72494: LIST
72495: LIST
72496: LIST
72497: LIST
72498: LIST
72499: LIST
72500: LIST
72501: LIST
72502: LIST
72503: LIST
72504: LIST
72505: LIST
72506: LIST
72507: LIST
72508: LIST
72509: LIST
72510: LIST
72511: LIST
72512: LIST
72513: LIST
72514: LIST
72515: LIST
72516: ST_TO_ADDR
// Factory5 = [ [ 0 , - 4 ] , [ 0 , - 5 ] , [ 1 , - 4 ] , [ 1 , - 3 ] , [ 0 , - 3 ] , [ - 1 , - 4 ] , [ - 1 , - 5 ] , [ 2 , - 3 ] , [ - 2 , - 5 ] , [ 3 , 0 ] , [ 3 , - 1 ] , [ 4 , 0 ] , [ 4 , 1 ] , [ 3 , 1 ] , [ 2 , 0 ] , [ 2 , - 1 ] , [ 2 , - 2 ] , [ 4 , 2 ] , [ 4 , 4 ] , [ 4 , 3 ] , [ 5 , 4 ] , [ 5 , 5 ] , [ 4 , 5 ] , [ 3 , 4 ] , [ 3 , 3 ] , [ 5 , 3 ] , [ 3 , 5 ] , [ 0 , 3 ] , [ 0 , 2 ] , [ 1 , 3 ] , [ 1 , 4 ] , [ 0 , 4 ] , [ - 1 , 3 ] , [ - 1 , 2 ] , [ 2 , 4 ] , [ - 2 , 2 ] , [ - 4 , 0 ] , [ - 4 , - 1 ] , [ - 3 , 0 ] , [ - 3 , 1 ] , [ - 4 , 1 ] , [ - 5 , 0 ] , [ - 5 , - 1 ] , [ - 5 , - 2 ] , [ - 3 , 2 ] ] ;
72517: LD_ADDR_VAR 0 34
72521: PUSH
72522: LD_INT 0
72524: PUSH
72525: LD_INT 4
72527: NEG
72528: PUSH
72529: EMPTY
72530: LIST
72531: LIST
72532: PUSH
72533: LD_INT 0
72535: PUSH
72536: LD_INT 5
72538: NEG
72539: PUSH
72540: EMPTY
72541: LIST
72542: LIST
72543: PUSH
72544: LD_INT 1
72546: PUSH
72547: LD_INT 4
72549: NEG
72550: PUSH
72551: EMPTY
72552: LIST
72553: LIST
72554: PUSH
72555: LD_INT 1
72557: PUSH
72558: LD_INT 3
72560: NEG
72561: PUSH
72562: EMPTY
72563: LIST
72564: LIST
72565: PUSH
72566: LD_INT 0
72568: PUSH
72569: LD_INT 3
72571: NEG
72572: PUSH
72573: EMPTY
72574: LIST
72575: LIST
72576: PUSH
72577: LD_INT 1
72579: NEG
72580: PUSH
72581: LD_INT 4
72583: NEG
72584: PUSH
72585: EMPTY
72586: LIST
72587: LIST
72588: PUSH
72589: LD_INT 1
72591: NEG
72592: PUSH
72593: LD_INT 5
72595: NEG
72596: PUSH
72597: EMPTY
72598: LIST
72599: LIST
72600: PUSH
72601: LD_INT 2
72603: PUSH
72604: LD_INT 3
72606: NEG
72607: PUSH
72608: EMPTY
72609: LIST
72610: LIST
72611: PUSH
72612: LD_INT 2
72614: NEG
72615: PUSH
72616: LD_INT 5
72618: NEG
72619: PUSH
72620: EMPTY
72621: LIST
72622: LIST
72623: PUSH
72624: LD_INT 3
72626: PUSH
72627: LD_INT 0
72629: PUSH
72630: EMPTY
72631: LIST
72632: LIST
72633: PUSH
72634: LD_INT 3
72636: PUSH
72637: LD_INT 1
72639: NEG
72640: PUSH
72641: EMPTY
72642: LIST
72643: LIST
72644: PUSH
72645: LD_INT 4
72647: PUSH
72648: LD_INT 0
72650: PUSH
72651: EMPTY
72652: LIST
72653: LIST
72654: PUSH
72655: LD_INT 4
72657: PUSH
72658: LD_INT 1
72660: PUSH
72661: EMPTY
72662: LIST
72663: LIST
72664: PUSH
72665: LD_INT 3
72667: PUSH
72668: LD_INT 1
72670: PUSH
72671: EMPTY
72672: LIST
72673: LIST
72674: PUSH
72675: LD_INT 2
72677: PUSH
72678: LD_INT 0
72680: PUSH
72681: EMPTY
72682: LIST
72683: LIST
72684: PUSH
72685: LD_INT 2
72687: PUSH
72688: LD_INT 1
72690: NEG
72691: PUSH
72692: EMPTY
72693: LIST
72694: LIST
72695: PUSH
72696: LD_INT 2
72698: PUSH
72699: LD_INT 2
72701: NEG
72702: PUSH
72703: EMPTY
72704: LIST
72705: LIST
72706: PUSH
72707: LD_INT 4
72709: PUSH
72710: LD_INT 2
72712: PUSH
72713: EMPTY
72714: LIST
72715: LIST
72716: PUSH
72717: LD_INT 4
72719: PUSH
72720: LD_INT 4
72722: PUSH
72723: EMPTY
72724: LIST
72725: LIST
72726: PUSH
72727: LD_INT 4
72729: PUSH
72730: LD_INT 3
72732: PUSH
72733: EMPTY
72734: LIST
72735: LIST
72736: PUSH
72737: LD_INT 5
72739: PUSH
72740: LD_INT 4
72742: PUSH
72743: EMPTY
72744: LIST
72745: LIST
72746: PUSH
72747: LD_INT 5
72749: PUSH
72750: LD_INT 5
72752: PUSH
72753: EMPTY
72754: LIST
72755: LIST
72756: PUSH
72757: LD_INT 4
72759: PUSH
72760: LD_INT 5
72762: PUSH
72763: EMPTY
72764: LIST
72765: LIST
72766: PUSH
72767: LD_INT 3
72769: PUSH
72770: LD_INT 4
72772: PUSH
72773: EMPTY
72774: LIST
72775: LIST
72776: PUSH
72777: LD_INT 3
72779: PUSH
72780: LD_INT 3
72782: PUSH
72783: EMPTY
72784: LIST
72785: LIST
72786: PUSH
72787: LD_INT 5
72789: PUSH
72790: LD_INT 3
72792: PUSH
72793: EMPTY
72794: LIST
72795: LIST
72796: PUSH
72797: LD_INT 3
72799: PUSH
72800: LD_INT 5
72802: PUSH
72803: EMPTY
72804: LIST
72805: LIST
72806: PUSH
72807: LD_INT 0
72809: PUSH
72810: LD_INT 3
72812: PUSH
72813: EMPTY
72814: LIST
72815: LIST
72816: PUSH
72817: LD_INT 0
72819: PUSH
72820: LD_INT 2
72822: PUSH
72823: EMPTY
72824: LIST
72825: LIST
72826: PUSH
72827: LD_INT 1
72829: PUSH
72830: LD_INT 3
72832: PUSH
72833: EMPTY
72834: LIST
72835: LIST
72836: PUSH
72837: LD_INT 1
72839: PUSH
72840: LD_INT 4
72842: PUSH
72843: EMPTY
72844: LIST
72845: LIST
72846: PUSH
72847: LD_INT 0
72849: PUSH
72850: LD_INT 4
72852: PUSH
72853: EMPTY
72854: LIST
72855: LIST
72856: PUSH
72857: LD_INT 1
72859: NEG
72860: PUSH
72861: LD_INT 3
72863: PUSH
72864: EMPTY
72865: LIST
72866: LIST
72867: PUSH
72868: LD_INT 1
72870: NEG
72871: PUSH
72872: LD_INT 2
72874: PUSH
72875: EMPTY
72876: LIST
72877: LIST
72878: PUSH
72879: LD_INT 2
72881: PUSH
72882: LD_INT 4
72884: PUSH
72885: EMPTY
72886: LIST
72887: LIST
72888: PUSH
72889: LD_INT 2
72891: NEG
72892: PUSH
72893: LD_INT 2
72895: PUSH
72896: EMPTY
72897: LIST
72898: LIST
72899: PUSH
72900: LD_INT 4
72902: NEG
72903: PUSH
72904: LD_INT 0
72906: PUSH
72907: EMPTY
72908: LIST
72909: LIST
72910: PUSH
72911: LD_INT 4
72913: NEG
72914: PUSH
72915: LD_INT 1
72917: NEG
72918: PUSH
72919: EMPTY
72920: LIST
72921: LIST
72922: PUSH
72923: LD_INT 3
72925: NEG
72926: PUSH
72927: LD_INT 0
72929: PUSH
72930: EMPTY
72931: LIST
72932: LIST
72933: PUSH
72934: LD_INT 3
72936: NEG
72937: PUSH
72938: LD_INT 1
72940: PUSH
72941: EMPTY
72942: LIST
72943: LIST
72944: PUSH
72945: LD_INT 4
72947: NEG
72948: PUSH
72949: LD_INT 1
72951: PUSH
72952: EMPTY
72953: LIST
72954: LIST
72955: PUSH
72956: LD_INT 5
72958: NEG
72959: PUSH
72960: LD_INT 0
72962: PUSH
72963: EMPTY
72964: LIST
72965: LIST
72966: PUSH
72967: LD_INT 5
72969: NEG
72970: PUSH
72971: LD_INT 1
72973: NEG
72974: PUSH
72975: EMPTY
72976: LIST
72977: LIST
72978: PUSH
72979: LD_INT 5
72981: NEG
72982: PUSH
72983: LD_INT 2
72985: NEG
72986: PUSH
72987: EMPTY
72988: LIST
72989: LIST
72990: PUSH
72991: LD_INT 3
72993: NEG
72994: PUSH
72995: LD_INT 2
72997: PUSH
72998: EMPTY
72999: LIST
73000: LIST
73001: PUSH
73002: EMPTY
73003: LIST
73004: LIST
73005: LIST
73006: LIST
73007: LIST
73008: LIST
73009: LIST
73010: LIST
73011: LIST
73012: LIST
73013: LIST
73014: LIST
73015: LIST
73016: LIST
73017: LIST
73018: LIST
73019: LIST
73020: LIST
73021: LIST
73022: LIST
73023: LIST
73024: LIST
73025: LIST
73026: LIST
73027: LIST
73028: LIST
73029: LIST
73030: LIST
73031: LIST
73032: LIST
73033: LIST
73034: LIST
73035: LIST
73036: LIST
73037: LIST
73038: LIST
73039: LIST
73040: LIST
73041: LIST
73042: LIST
73043: LIST
73044: LIST
73045: LIST
73046: LIST
73047: LIST
73048: ST_TO_ADDR
// end ; end ;
73049: GO 73052
73051: POP
// case btype of b_depot , b_warehouse :
73052: LD_VAR 0 1
73056: PUSH
73057: LD_INT 0
73059: DOUBLE
73060: EQUAL
73061: IFTRUE 73071
73063: LD_INT 1
73065: DOUBLE
73066: EQUAL
73067: IFTRUE 73071
73069: GO 73272
73071: POP
// case nation of nation_american :
73072: LD_VAR 0 5
73076: PUSH
73077: LD_INT 1
73079: DOUBLE
73080: EQUAL
73081: IFTRUE 73085
73083: GO 73141
73085: POP
// temp_list = [ DepotAm0 , DepotAm1 , DepotAm2 , DepotAm3 , DepotAm4 , DepotAm5 ] [ dir + 1 ] ; nation_arabian :
73086: LD_ADDR_VAR 0 9
73090: PUSH
73091: LD_VAR 0 11
73095: PUSH
73096: LD_VAR 0 12
73100: PUSH
73101: LD_VAR 0 13
73105: PUSH
73106: LD_VAR 0 14
73110: PUSH
73111: LD_VAR 0 15
73115: PUSH
73116: LD_VAR 0 16
73120: PUSH
73121: EMPTY
73122: LIST
73123: LIST
73124: LIST
73125: LIST
73126: LIST
73127: LIST
73128: PUSH
73129: LD_VAR 0 4
73133: PUSH
73134: LD_INT 1
73136: PLUS
73137: ARRAY
73138: ST_TO_ADDR
73139: GO 73270
73141: LD_INT 2
73143: DOUBLE
73144: EQUAL
73145: IFTRUE 73149
73147: GO 73205
73149: POP
// temp_list = [ DepotAr0 , DepotAr1 , DepotAr2 , DepotAr3 , DepotAr4 , DepotAr5 ] [ dir + 1 ] ; nation_russian :
73150: LD_ADDR_VAR 0 9
73154: PUSH
73155: LD_VAR 0 17
73159: PUSH
73160: LD_VAR 0 18
73164: PUSH
73165: LD_VAR 0 19
73169: PUSH
73170: LD_VAR 0 20
73174: PUSH
73175: LD_VAR 0 21
73179: PUSH
73180: LD_VAR 0 22
73184: PUSH
73185: EMPTY
73186: LIST
73187: LIST
73188: LIST
73189: LIST
73190: LIST
73191: LIST
73192: PUSH
73193: LD_VAR 0 4
73197: PUSH
73198: LD_INT 1
73200: PLUS
73201: ARRAY
73202: ST_TO_ADDR
73203: GO 73270
73205: LD_INT 3
73207: DOUBLE
73208: EQUAL
73209: IFTRUE 73213
73211: GO 73269
73213: POP
// temp_list = [ DepotRu0 , DepotRu1 , DepotRu2 , DepotRu3 , DepotRu4 , DepotRu5 ] [ dir + 1 ] ; end ; b_workshop , b_factory :
73214: LD_ADDR_VAR 0 9
73218: PUSH
73219: LD_VAR 0 23
73223: PUSH
73224: LD_VAR 0 24
73228: PUSH
73229: LD_VAR 0 25
73233: PUSH
73234: LD_VAR 0 26
73238: PUSH
73239: LD_VAR 0 27
73243: PUSH
73244: LD_VAR 0 28
73248: PUSH
73249: EMPTY
73250: LIST
73251: LIST
73252: LIST
73253: LIST
73254: LIST
73255: LIST
73256: PUSH
73257: LD_VAR 0 4
73261: PUSH
73262: LD_INT 1
73264: PLUS
73265: ARRAY
73266: ST_TO_ADDR
73267: GO 73270
73269: POP
73270: GO 73825
73272: LD_INT 2
73274: DOUBLE
73275: EQUAL
73276: IFTRUE 73286
73278: LD_INT 3
73280: DOUBLE
73281: EQUAL
73282: IFTRUE 73286
73284: GO 73342
73286: POP
// temp_list = [ Factory0 , Factory1 , Factory2 , Factory3 , Factory4 , Factory5 ] [ dir + 1 ] ; b_ext_track , b_ext_gun , b_ext_rocket , b_ext_noncombat , b_ext_radio , b_ext_radar , b_ext_siberium , b_ext_stitch , b_ext_computer , b_ext_laser :
73287: LD_ADDR_VAR 0 9
73291: PUSH
73292: LD_VAR 0 29
73296: PUSH
73297: LD_VAR 0 30
73301: PUSH
73302: LD_VAR 0 31
73306: PUSH
73307: LD_VAR 0 32
73311: PUSH
73312: LD_VAR 0 33
73316: PUSH
73317: LD_VAR 0 34
73321: PUSH
73322: EMPTY
73323: LIST
73324: LIST
73325: LIST
73326: LIST
73327: LIST
73328: LIST
73329: PUSH
73330: LD_VAR 0 4
73334: PUSH
73335: LD_INT 1
73337: PLUS
73338: ARRAY
73339: ST_TO_ADDR
73340: GO 73825
73342: LD_INT 16
73344: DOUBLE
73345: EQUAL
73346: IFTRUE 73404
73348: LD_INT 17
73350: DOUBLE
73351: EQUAL
73352: IFTRUE 73404
73354: LD_INT 18
73356: DOUBLE
73357: EQUAL
73358: IFTRUE 73404
73360: LD_INT 19
73362: DOUBLE
73363: EQUAL
73364: IFTRUE 73404
73366: LD_INT 22
73368: DOUBLE
73369: EQUAL
73370: IFTRUE 73404
73372: LD_INT 20
73374: DOUBLE
73375: EQUAL
73376: IFTRUE 73404
73378: LD_INT 21
73380: DOUBLE
73381: EQUAL
73382: IFTRUE 73404
73384: LD_INT 23
73386: DOUBLE
73387: EQUAL
73388: IFTRUE 73404
73390: LD_INT 24
73392: DOUBLE
73393: EQUAL
73394: IFTRUE 73404
73396: LD_INT 25
73398: DOUBLE
73399: EQUAL
73400: IFTRUE 73404
73402: GO 73460
73404: POP
// temp_list = [ Ext0 , Ext1 , Ext2 , Ext3 , Ext4 , Ext5 ] [ dir + 1 ] ; b_lab , b_lab_half , b_lab_full , b_lab_biological , b_lab_computer , b_lab_opto , b_lab_siberium , b_lab_spacetime , b_lab_weapon :
73405: LD_ADDR_VAR 0 9
73409: PUSH
73410: LD_VAR 0 35
73414: PUSH
73415: LD_VAR 0 36
73419: PUSH
73420: LD_VAR 0 37
73424: PUSH
73425: LD_VAR 0 38
73429: PUSH
73430: LD_VAR 0 39
73434: PUSH
73435: LD_VAR 0 40
73439: PUSH
73440: EMPTY
73441: LIST
73442: LIST
73443: LIST
73444: LIST
73445: LIST
73446: LIST
73447: PUSH
73448: LD_VAR 0 4
73452: PUSH
73453: LD_INT 1
73455: PLUS
73456: ARRAY
73457: ST_TO_ADDR
73458: GO 73825
73460: LD_INT 6
73462: DOUBLE
73463: EQUAL
73464: IFTRUE 73516
73466: LD_INT 7
73468: DOUBLE
73469: EQUAL
73470: IFTRUE 73516
73472: LD_INT 8
73474: DOUBLE
73475: EQUAL
73476: IFTRUE 73516
73478: LD_INT 13
73480: DOUBLE
73481: EQUAL
73482: IFTRUE 73516
73484: LD_INT 12
73486: DOUBLE
73487: EQUAL
73488: IFTRUE 73516
73490: LD_INT 15
73492: DOUBLE
73493: EQUAL
73494: IFTRUE 73516
73496: LD_INT 11
73498: DOUBLE
73499: EQUAL
73500: IFTRUE 73516
73502: LD_INT 14
73504: DOUBLE
73505: EQUAL
73506: IFTRUE 73516
73508: LD_INT 10
73510: DOUBLE
73511: EQUAL
73512: IFTRUE 73516
73514: GO 73572
73516: POP
// temp_list = [ Lab0 , Lab1 , Lab2 , Lab3 , Lab4 , Lab5 ] [ dir + 1 ] ; b_control_tower :
73517: LD_ADDR_VAR 0 9
73521: PUSH
73522: LD_VAR 0 41
73526: PUSH
73527: LD_VAR 0 42
73531: PUSH
73532: LD_VAR 0 43
73536: PUSH
73537: LD_VAR 0 44
73541: PUSH
73542: LD_VAR 0 45
73546: PUSH
73547: LD_VAR 0 46
73551: PUSH
73552: EMPTY
73553: LIST
73554: LIST
73555: LIST
73556: LIST
73557: LIST
73558: LIST
73559: PUSH
73560: LD_VAR 0 4
73564: PUSH
73565: LD_INT 1
73567: PLUS
73568: ARRAY
73569: ST_TO_ADDR
73570: GO 73825
73572: LD_INT 36
73574: DOUBLE
73575: EQUAL
73576: IFTRUE 73580
73578: GO 73636
73580: POP
// temp_list = [ ControlTower0 , ControlTower1 , ControlTower2 , ControlTower3 , ControlTower4 , ControlTower5 ] [ dir + 1 ] ; b_armoury , b_barracks , b_teleport , b_behemoth :
73581: LD_ADDR_VAR 0 9
73585: PUSH
73586: LD_VAR 0 47
73590: PUSH
73591: LD_VAR 0 48
73595: PUSH
73596: LD_VAR 0 49
73600: PUSH
73601: LD_VAR 0 50
73605: PUSH
73606: LD_VAR 0 51
73610: PUSH
73611: LD_VAR 0 52
73615: PUSH
73616: EMPTY
73617: LIST
73618: LIST
73619: LIST
73620: LIST
73621: LIST
73622: LIST
73623: PUSH
73624: LD_VAR 0 4
73628: PUSH
73629: LD_INT 1
73631: PLUS
73632: ARRAY
73633: ST_TO_ADDR
73634: GO 73825
73636: LD_INT 4
73638: DOUBLE
73639: EQUAL
73640: IFTRUE 73662
73642: LD_INT 5
73644: DOUBLE
73645: EQUAL
73646: IFTRUE 73662
73648: LD_INT 34
73650: DOUBLE
73651: EQUAL
73652: IFTRUE 73662
73654: LD_INT 37
73656: DOUBLE
73657: EQUAL
73658: IFTRUE 73662
73660: GO 73718
73662: POP
// temp_list = [ Barracks0 , Barracks1 , Barracks2 , Barracks3 , Barracks4 , Barracks5 ] [ dir + 1 ] ; b_breastwork , b_bunker , b_turret , b_solar_power , b_oil_power , b_siberite_power , b_oil_mine , b_siberite_mine :
73663: LD_ADDR_VAR 0 9
73667: PUSH
73668: LD_VAR 0 53
73672: PUSH
73673: LD_VAR 0 54
73677: PUSH
73678: LD_VAR 0 55
73682: PUSH
73683: LD_VAR 0 56
73687: PUSH
73688: LD_VAR 0 57
73692: PUSH
73693: LD_VAR 0 58
73697: PUSH
73698: EMPTY
73699: LIST
73700: LIST
73701: LIST
73702: LIST
73703: LIST
73704: LIST
73705: PUSH
73706: LD_VAR 0 4
73710: PUSH
73711: LD_INT 1
73713: PLUS
73714: ARRAY
73715: ST_TO_ADDR
73716: GO 73825
73718: LD_INT 31
73720: DOUBLE
73721: EQUAL
73722: IFTRUE 73768
73724: LD_INT 32
73726: DOUBLE
73727: EQUAL
73728: IFTRUE 73768
73730: LD_INT 33
73732: DOUBLE
73733: EQUAL
73734: IFTRUE 73768
73736: LD_INT 27
73738: DOUBLE
73739: EQUAL
73740: IFTRUE 73768
73742: LD_INT 26
73744: DOUBLE
73745: EQUAL
73746: IFTRUE 73768
73748: LD_INT 28
73750: DOUBLE
73751: EQUAL
73752: IFTRUE 73768
73754: LD_INT 29
73756: DOUBLE
73757: EQUAL
73758: IFTRUE 73768
73760: LD_INT 30
73762: DOUBLE
73763: EQUAL
73764: IFTRUE 73768
73766: GO 73824
73768: POP
// temp_list = [ Bunker0 , Bunker1 , Bunker2 , Bunker3 , Bunker4 , Bunker5 ] [ dir + 1 ] ; end ;
73769: LD_ADDR_VAR 0 9
73773: PUSH
73774: LD_VAR 0 59
73778: PUSH
73779: LD_VAR 0 60
73783: PUSH
73784: LD_VAR 0 61
73788: PUSH
73789: LD_VAR 0 62
73793: PUSH
73794: LD_VAR 0 63
73798: PUSH
73799: LD_VAR 0 64
73803: PUSH
73804: EMPTY
73805: LIST
73806: LIST
73807: LIST
73808: LIST
73809: LIST
73810: LIST
73811: PUSH
73812: LD_VAR 0 4
73816: PUSH
73817: LD_INT 1
73819: PLUS
73820: ARRAY
73821: ST_TO_ADDR
73822: GO 73825
73824: POP
// temp_list2 = [ ] ;
73825: LD_ADDR_VAR 0 10
73829: PUSH
73830: EMPTY
73831: ST_TO_ADDR
// for i in temp_list do
73832: LD_ADDR_VAR 0 8
73836: PUSH
73837: LD_VAR 0 9
73841: PUSH
73842: FOR_IN
73843: IFFALSE 73895
// temp_list2 = temp_list2 ^ [ [ i [ 1 ] + x , i [ 2 ] + y ] ] ;
73845: LD_ADDR_VAR 0 10
73849: PUSH
73850: LD_VAR 0 10
73854: PUSH
73855: LD_VAR 0 8
73859: PUSH
73860: LD_INT 1
73862: ARRAY
73863: PUSH
73864: LD_VAR 0 2
73868: PLUS
73869: PUSH
73870: LD_VAR 0 8
73874: PUSH
73875: LD_INT 2
73877: ARRAY
73878: PUSH
73879: LD_VAR 0 3
73883: PLUS
73884: PUSH
73885: EMPTY
73886: LIST
73887: LIST
73888: PUSH
73889: EMPTY
73890: LIST
73891: ADD
73892: ST_TO_ADDR
73893: GO 73842
73895: POP
73896: POP
// result = temp_list2 ;
73897: LD_ADDR_VAR 0 7
73901: PUSH
73902: LD_VAR 0 10
73906: ST_TO_ADDR
// end ;
73907: LD_VAR 0 7
73911: RET
// export function EnemyInRange ( unit , dist ) ; begin
73912: LD_INT 0
73914: PPUSH
// result := DangerAtRangeXY ( GetSide ( unit ) , GetX ( unit ) , GetY ( unit ) , dist ) [ 4 ] ;
73915: LD_ADDR_VAR 0 3
73919: PUSH
73920: LD_VAR 0 1
73924: PPUSH
73925: CALL_OW 255
73929: PPUSH
73930: LD_VAR 0 1
73934: PPUSH
73935: CALL_OW 250
73939: PPUSH
73940: LD_VAR 0 1
73944: PPUSH
73945: CALL_OW 251
73949: PPUSH
73950: LD_VAR 0 2
73954: PPUSH
73955: CALL 48016 0 4
73959: PUSH
73960: LD_INT 4
73962: ARRAY
73963: ST_TO_ADDR
// end ;
73964: LD_VAR 0 3
73968: RET
// export function PlayerSeeMe ( unit ) ; begin
73969: LD_INT 0
73971: PPUSH
// result := See ( your_side , unit ) ;
73972: LD_ADDR_VAR 0 2
73976: PUSH
73977: LD_OWVAR 2
73981: PPUSH
73982: LD_VAR 0 1
73986: PPUSH
73987: CALL_OW 292
73991: ST_TO_ADDR
// end ;
73992: LD_VAR 0 2
73996: RET
// export function ReverseDir ( unit ) ; begin
73997: LD_INT 0
73999: PPUSH
// if not unit then
74000: LD_VAR 0 1
74004: NOT
74005: IFFALSE 74009
// exit ;
74007: GO 74055
// result := [ 3 , 4 , 5 , 0 , 1 , 2 ] [ GetDir ( unit ) + 1 ] ;
74009: LD_ADDR_VAR 0 2
74013: PUSH
74014: LD_INT 3
74016: PUSH
74017: LD_INT 4
74019: PUSH
74020: LD_INT 5
74022: PUSH
74023: LD_INT 0
74025: PUSH
74026: LD_INT 1
74028: PUSH
74029: LD_INT 2
74031: PUSH
74032: EMPTY
74033: LIST
74034: LIST
74035: LIST
74036: LIST
74037: LIST
74038: LIST
74039: PUSH
74040: LD_VAR 0 1
74044: PPUSH
74045: CALL_OW 254
74049: PUSH
74050: LD_INT 1
74052: PLUS
74053: ARRAY
74054: ST_TO_ADDR
// end ;
74055: LD_VAR 0 2
74059: RET
// export function GetClosestHex ( unit , hexes ) ; var i , dist , tmp , hex ; begin
74060: LD_INT 0
74062: PPUSH
74063: PPUSH
74064: PPUSH
74065: PPUSH
74066: PPUSH
// if not hexes then
74067: LD_VAR 0 2
74071: NOT
74072: IFFALSE 74076
// exit ;
74074: GO 74224
// dist := 9999 ;
74076: LD_ADDR_VAR 0 5
74080: PUSH
74081: LD_INT 9999
74083: ST_TO_ADDR
// for i = 1 to hexes do
74084: LD_ADDR_VAR 0 4
74088: PUSH
74089: DOUBLE
74090: LD_INT 1
74092: DEC
74093: ST_TO_ADDR
74094: LD_VAR 0 2
74098: PUSH
74099: FOR_TO
74100: IFFALSE 74212
// begin if GetDistUnitXY ( unit , hexes [ i ] [ 1 ] , hexes [ i ] [ 2 ] ) < dist then
74102: LD_VAR 0 1
74106: PPUSH
74107: LD_VAR 0 2
74111: PUSH
74112: LD_VAR 0 4
74116: ARRAY
74117: PUSH
74118: LD_INT 1
74120: ARRAY
74121: PPUSH
74122: LD_VAR 0 2
74126: PUSH
74127: LD_VAR 0 4
74131: ARRAY
74132: PUSH
74133: LD_INT 2
74135: ARRAY
74136: PPUSH
74137: CALL_OW 297
74141: PUSH
74142: LD_VAR 0 5
74146: LESS
74147: IFFALSE 74210
// begin hex := hexes [ i ] ;
74149: LD_ADDR_VAR 0 7
74153: PUSH
74154: LD_VAR 0 2
74158: PUSH
74159: LD_VAR 0 4
74163: ARRAY
74164: ST_TO_ADDR
// dist := GetDistUnitXY ( unit , hexes [ i ] [ 1 ] , hexes [ i ] [ 2 ] ) ;
74165: LD_ADDR_VAR 0 5
74169: PUSH
74170: LD_VAR 0 1
74174: PPUSH
74175: LD_VAR 0 2
74179: PUSH
74180: LD_VAR 0 4
74184: ARRAY
74185: PUSH
74186: LD_INT 1
74188: ARRAY
74189: PPUSH
74190: LD_VAR 0 2
74194: PUSH
74195: LD_VAR 0 4
74199: ARRAY
74200: PUSH
74201: LD_INT 2
74203: ARRAY
74204: PPUSH
74205: CALL_OW 297
74209: ST_TO_ADDR
// end ; end ;
74210: GO 74099
74212: POP
74213: POP
// result := hex ;
74214: LD_ADDR_VAR 0 3
74218: PUSH
74219: LD_VAR 0 7
74223: ST_TO_ADDR
// end ;
74224: LD_VAR 0 3
74228: RET
// export function ComAutodestruct ( unit ) ; var i ; begin
74229: LD_INT 0
74231: PPUSH
74232: PPUSH
// if not unit or not unit in FilterAllUnits ( [ [ f_type , unit_vehicle ] , [ f_nation , 2 ] ] ) then
74233: LD_VAR 0 1
74237: NOT
74238: PUSH
74239: LD_VAR 0 1
74243: PUSH
74244: LD_INT 21
74246: PUSH
74247: LD_INT 2
74249: PUSH
74250: EMPTY
74251: LIST
74252: LIST
74253: PUSH
74254: LD_INT 23
74256: PUSH
74257: LD_INT 2
74259: PUSH
74260: EMPTY
74261: LIST
74262: LIST
74263: PUSH
74264: EMPTY
74265: LIST
74266: LIST
74267: PPUSH
74268: CALL_OW 69
74272: IN
74273: NOT
74274: OR
74275: IFFALSE 74279
// exit ;
74277: GO 74326
// for i = 1 to 3 do
74279: LD_ADDR_VAR 0 3
74283: PUSH
74284: DOUBLE
74285: LD_INT 1
74287: DEC
74288: ST_TO_ADDR
74289: LD_INT 3
74291: PUSH
74292: FOR_TO
74293: IFFALSE 74324
// MineExplosion ( GetX ( unit ) , GetY ( unit ) , 1 ) ;
74295: LD_VAR 0 1
74299: PPUSH
74300: CALL_OW 250
74304: PPUSH
74305: LD_VAR 0 1
74309: PPUSH
74310: CALL_OW 251
74314: PPUSH
74315: LD_INT 1
74317: PPUSH
74318: CALL_OW 453
74322: GO 74292
74324: POP
74325: POP
// end ;
74326: LD_VAR 0 2
74330: RET
// export function AttackHovercraft ( unit , enemy_unit ) ; var i , j , tmp , x , y ; begin
74331: LD_INT 0
74333: PPUSH
74334: PPUSH
74335: PPUSH
74336: PPUSH
74337: PPUSH
74338: PPUSH
// if not unit or not enemy_unit or HasTask ( unit ) then
74339: LD_VAR 0 1
74343: NOT
74344: PUSH
74345: LD_VAR 0 2
74349: NOT
74350: OR
74351: PUSH
74352: LD_VAR 0 1
74356: PPUSH
74357: CALL_OW 314
74361: OR
74362: IFFALSE 74366
// exit ;
74364: GO 74807
// x := GetX ( enemy_unit ) ;
74366: LD_ADDR_VAR 0 7
74370: PUSH
74371: LD_VAR 0 2
74375: PPUSH
74376: CALL_OW 250
74380: ST_TO_ADDR
// y := GetY ( enemy_unit ) ;
74381: LD_ADDR_VAR 0 8
74385: PUSH
74386: LD_VAR 0 2
74390: PPUSH
74391: CALL_OW 251
74395: ST_TO_ADDR
// if not x or not y then
74396: LD_VAR 0 7
74400: NOT
74401: PUSH
74402: LD_VAR 0 8
74406: NOT
74407: OR
74408: IFFALSE 74412
// exit ;
74410: GO 74807
// tmp := [ [ ShiftX ( x , 0 , 4 ) , ShiftY ( y , 0 , 4 ) ] , [ ShiftX ( x , 1 , 4 ) , ShiftY ( y , 1 , 4 ) ] , [ ShiftX ( x , 2 , 4 ) , ShiftY ( y , 2 , 4 ) ] , [ ShiftX ( x , 3 , 4 ) , ShiftY ( y , 3 , 4 ) ] , [ ShiftX ( x , 4 , 4 ) , ShiftY ( y , 4 , 4 ) ] , [ ShiftX ( x , 5 , 4 ) , ShiftY ( y , 5 , 4 ) ] ] ;
74412: LD_ADDR_VAR 0 6
74416: PUSH
74417: LD_VAR 0 7
74421: PPUSH
74422: LD_INT 0
74424: PPUSH
74425: LD_INT 4
74427: PPUSH
74428: CALL_OW 272
74432: PUSH
74433: LD_VAR 0 8
74437: PPUSH
74438: LD_INT 0
74440: PPUSH
74441: LD_INT 4
74443: PPUSH
74444: CALL_OW 273
74448: PUSH
74449: EMPTY
74450: LIST
74451: LIST
74452: PUSH
74453: LD_VAR 0 7
74457: PPUSH
74458: LD_INT 1
74460: PPUSH
74461: LD_INT 4
74463: PPUSH
74464: CALL_OW 272
74468: PUSH
74469: LD_VAR 0 8
74473: PPUSH
74474: LD_INT 1
74476: PPUSH
74477: LD_INT 4
74479: PPUSH
74480: CALL_OW 273
74484: PUSH
74485: EMPTY
74486: LIST
74487: LIST
74488: PUSH
74489: LD_VAR 0 7
74493: PPUSH
74494: LD_INT 2
74496: PPUSH
74497: LD_INT 4
74499: PPUSH
74500: CALL_OW 272
74504: PUSH
74505: LD_VAR 0 8
74509: PPUSH
74510: LD_INT 2
74512: PPUSH
74513: LD_INT 4
74515: PPUSH
74516: CALL_OW 273
74520: PUSH
74521: EMPTY
74522: LIST
74523: LIST
74524: PUSH
74525: LD_VAR 0 7
74529: PPUSH
74530: LD_INT 3
74532: PPUSH
74533: LD_INT 4
74535: PPUSH
74536: CALL_OW 272
74540: PUSH
74541: LD_VAR 0 8
74545: PPUSH
74546: LD_INT 3
74548: PPUSH
74549: LD_INT 4
74551: PPUSH
74552: CALL_OW 273
74556: PUSH
74557: EMPTY
74558: LIST
74559: LIST
74560: PUSH
74561: LD_VAR 0 7
74565: PPUSH
74566: LD_INT 4
74568: PPUSH
74569: LD_INT 4
74571: PPUSH
74572: CALL_OW 272
74576: PUSH
74577: LD_VAR 0 8
74581: PPUSH
74582: LD_INT 4
74584: PPUSH
74585: LD_INT 4
74587: PPUSH
74588: CALL_OW 273
74592: PUSH
74593: EMPTY
74594: LIST
74595: LIST
74596: PUSH
74597: LD_VAR 0 7
74601: PPUSH
74602: LD_INT 5
74604: PPUSH
74605: LD_INT 4
74607: PPUSH
74608: CALL_OW 272
74612: PUSH
74613: LD_VAR 0 8
74617: PPUSH
74618: LD_INT 5
74620: PPUSH
74621: LD_INT 4
74623: PPUSH
74624: CALL_OW 273
74628: PUSH
74629: EMPTY
74630: LIST
74631: LIST
74632: PUSH
74633: EMPTY
74634: LIST
74635: LIST
74636: LIST
74637: LIST
74638: LIST
74639: LIST
74640: ST_TO_ADDR
// for i = tmp downto 1 do
74641: LD_ADDR_VAR 0 4
74645: PUSH
74646: DOUBLE
74647: LD_VAR 0 6
74651: INC
74652: ST_TO_ADDR
74653: LD_INT 1
74655: PUSH
74656: FOR_DOWNTO
74657: IFFALSE 74758
// if not ValidHex ( tmp [ i ] [ 1 ] , tmp [ i ] [ 2 ] ) or HexInfo ( tmp [ i ] [ 1 ] , tmp [ i ] [ 2 ] ) <> 0 then
74659: LD_VAR 0 6
74663: PUSH
74664: LD_VAR 0 4
74668: ARRAY
74669: PUSH
74670: LD_INT 1
74672: ARRAY
74673: PPUSH
74674: LD_VAR 0 6
74678: PUSH
74679: LD_VAR 0 4
74683: ARRAY
74684: PUSH
74685: LD_INT 2
74687: ARRAY
74688: PPUSH
74689: CALL_OW 488
74693: NOT
74694: PUSH
74695: LD_VAR 0 6
74699: PUSH
74700: LD_VAR 0 4
74704: ARRAY
74705: PUSH
74706: LD_INT 1
74708: ARRAY
74709: PPUSH
74710: LD_VAR 0 6
74714: PUSH
74715: LD_VAR 0 4
74719: ARRAY
74720: PUSH
74721: LD_INT 2
74723: ARRAY
74724: PPUSH
74725: CALL_OW 428
74729: PUSH
74730: LD_INT 0
74732: NONEQUAL
74733: OR
74734: IFFALSE 74756
// tmp := Delete ( tmp , i ) ;
74736: LD_ADDR_VAR 0 6
74740: PUSH
74741: LD_VAR 0 6
74745: PPUSH
74746: LD_VAR 0 4
74750: PPUSH
74751: CALL_OW 3
74755: ST_TO_ADDR
74756: GO 74656
74758: POP
74759: POP
// j := GetClosestHex ( unit , tmp ) ;
74760: LD_ADDR_VAR 0 5
74764: PUSH
74765: LD_VAR 0 1
74769: PPUSH
74770: LD_VAR 0 6
74774: PPUSH
74775: CALL 74060 0 2
74779: ST_TO_ADDR
// ComMoveXY ( unit , j [ 1 ] , j [ 2 ] ) ;
74780: LD_VAR 0 1
74784: PPUSH
74785: LD_VAR 0 5
74789: PUSH
74790: LD_INT 1
74792: ARRAY
74793: PPUSH
74794: LD_VAR 0 5
74798: PUSH
74799: LD_INT 2
74801: ARRAY
74802: PPUSH
74803: CALL_OW 111
// end ;
74807: LD_VAR 0 3
74811: RET
// export function PrepareNature ( birds , tigers , apemans , enchidnas , horses , mastodonts , fishes , nat_area , wat_area ) ; var i , animal ; begin
74812: LD_INT 0
74814: PPUSH
74815: PPUSH
74816: PPUSH
// uc_side = 0 ;
74817: LD_ADDR_OWVAR 20
74821: PUSH
74822: LD_INT 0
74824: ST_TO_ADDR
// uc_nation = 0 ;
74825: LD_ADDR_OWVAR 21
74829: PUSH
74830: LD_INT 0
74832: ST_TO_ADDR
// InitHc ;
74833: CALL_OW 19
// InitVc ;
74837: CALL_OW 20
// if mastodonts then
74841: LD_VAR 0 6
74845: IFFALSE 74912
// for i = 1 to mastodonts do
74847: LD_ADDR_VAR 0 11
74851: PUSH
74852: DOUBLE
74853: LD_INT 1
74855: DEC
74856: ST_TO_ADDR
74857: LD_VAR 0 6
74861: PUSH
74862: FOR_TO
74863: IFFALSE 74910
// begin vc_chassis := 31 ;
74865: LD_ADDR_OWVAR 37
74869: PUSH
74870: LD_INT 31
74872: ST_TO_ADDR
// vc_control := control_rider ;
74873: LD_ADDR_OWVAR 38
74877: PUSH
74878: LD_INT 4
74880: ST_TO_ADDR
// animal := CreateVehicle ;
74881: LD_ADDR_VAR 0 12
74885: PUSH
74886: CALL_OW 45
74890: ST_TO_ADDR
// PlaceUnitInArea ( animal , nat_area , false ) ;
74891: LD_VAR 0 12
74895: PPUSH
74896: LD_VAR 0 8
74900: PPUSH
74901: LD_INT 0
74903: PPUSH
74904: CALL 81657 0 3
// end ;
74908: GO 74862
74910: POP
74911: POP
// if horses then
74912: LD_VAR 0 5
74916: IFFALSE 74983
// for i = 1 to horses do
74918: LD_ADDR_VAR 0 11
74922: PUSH
74923: DOUBLE
74924: LD_INT 1
74926: DEC
74927: ST_TO_ADDR
74928: LD_VAR 0 5
74932: PUSH
74933: FOR_TO
74934: IFFALSE 74981
// begin hc_class := 21 ;
74936: LD_ADDR_OWVAR 28
74940: PUSH
74941: LD_INT 21
74943: ST_TO_ADDR
// hc_gallery :=  ;
74944: LD_ADDR_OWVAR 33
74948: PUSH
74949: LD_STRING 
74951: ST_TO_ADDR
// animal := CreateHuman ;
74952: LD_ADDR_VAR 0 12
74956: PUSH
74957: CALL_OW 44
74961: ST_TO_ADDR
// PlaceUnitInArea ( animal , nat_area , false ) ;
74962: LD_VAR 0 12
74966: PPUSH
74967: LD_VAR 0 8
74971: PPUSH
74972: LD_INT 0
74974: PPUSH
74975: CALL 81657 0 3
// end ;
74979: GO 74933
74981: POP
74982: POP
// if birds then
74983: LD_VAR 0 1
74987: IFFALSE 75054
// for i = 1 to birds do
74989: LD_ADDR_VAR 0 11
74993: PUSH
74994: DOUBLE
74995: LD_INT 1
74997: DEC
74998: ST_TO_ADDR
74999: LD_VAR 0 1
75003: PUSH
75004: FOR_TO
75005: IFFALSE 75052
// begin hc_class = 18 ;
75007: LD_ADDR_OWVAR 28
75011: PUSH
75012: LD_INT 18
75014: ST_TO_ADDR
// hc_gallery =  ;
75015: LD_ADDR_OWVAR 33
75019: PUSH
75020: LD_STRING 
75022: ST_TO_ADDR
// animal := CreateHuman ;
75023: LD_ADDR_VAR 0 12
75027: PUSH
75028: CALL_OW 44
75032: ST_TO_ADDR
// PlaceUnitInArea ( animal , nat_area , false ) ;
75033: LD_VAR 0 12
75037: PPUSH
75038: LD_VAR 0 8
75042: PPUSH
75043: LD_INT 0
75045: PPUSH
75046: CALL 81657 0 3
// end ;
75050: GO 75004
75052: POP
75053: POP
// if tigers then
75054: LD_VAR 0 2
75058: IFFALSE 75142
// for i = 1 to tigers do
75060: LD_ADDR_VAR 0 11
75064: PUSH
75065: DOUBLE
75066: LD_INT 1
75068: DEC
75069: ST_TO_ADDR
75070: LD_VAR 0 2
75074: PUSH
75075: FOR_TO
75076: IFFALSE 75140
// begin hc_class = class_tiger ;
75078: LD_ADDR_OWVAR 28
75082: PUSH
75083: LD_INT 14
75085: ST_TO_ADDR
// hc_gallery =  ;
75086: LD_ADDR_OWVAR 33
75090: PUSH
75091: LD_STRING 
75093: ST_TO_ADDR
// hc_agressivity = Rand ( - 7 , 7 ) ;
75094: LD_ADDR_OWVAR 35
75098: PUSH
75099: LD_INT 7
75101: NEG
75102: PPUSH
75103: LD_INT 7
75105: PPUSH
75106: CALL_OW 12
75110: ST_TO_ADDR
// animal := CreateHuman ;
75111: LD_ADDR_VAR 0 12
75115: PUSH
75116: CALL_OW 44
75120: ST_TO_ADDR
// PlaceUnitInArea ( animal , nat_area , false ) ;
75121: LD_VAR 0 12
75125: PPUSH
75126: LD_VAR 0 8
75130: PPUSH
75131: LD_INT 0
75133: PPUSH
75134: CALL 81657 0 3
// end ;
75138: GO 75075
75140: POP
75141: POP
// if apemans then
75142: LD_VAR 0 3
75146: IFFALSE 75269
// for i = 1 to apemans do
75148: LD_ADDR_VAR 0 11
75152: PUSH
75153: DOUBLE
75154: LD_INT 1
75156: DEC
75157: ST_TO_ADDR
75158: LD_VAR 0 3
75162: PUSH
75163: FOR_TO
75164: IFFALSE 75267
// begin hc_class = class_apeman ;
75166: LD_ADDR_OWVAR 28
75170: PUSH
75171: LD_INT 12
75173: ST_TO_ADDR
// hc_gallery =  ;
75174: LD_ADDR_OWVAR 33
75178: PUSH
75179: LD_STRING 
75181: ST_TO_ADDR
// hc_agressivity = rand ( - 5 , 5 ) ;
75182: LD_ADDR_OWVAR 35
75186: PUSH
75187: LD_INT 5
75189: NEG
75190: PPUSH
75191: LD_INT 5
75193: PPUSH
75194: CALL_OW 12
75198: ST_TO_ADDR
// hc_skills := [ rand ( 1 , 3 ) , rand ( 1 , 3 ) , 0 , 0 ] ;
75199: LD_ADDR_OWVAR 31
75203: PUSH
75204: LD_INT 1
75206: PPUSH
75207: LD_INT 3
75209: PPUSH
75210: CALL_OW 12
75214: PUSH
75215: LD_INT 1
75217: PPUSH
75218: LD_INT 3
75220: PPUSH
75221: CALL_OW 12
75225: PUSH
75226: LD_INT 0
75228: PUSH
75229: LD_INT 0
75231: PUSH
75232: EMPTY
75233: LIST
75234: LIST
75235: LIST
75236: LIST
75237: ST_TO_ADDR
// animal := CreateHuman ;
75238: LD_ADDR_VAR 0 12
75242: PUSH
75243: CALL_OW 44
75247: ST_TO_ADDR
// PlaceUnitInArea ( animal , nat_area , false ) ;
75248: LD_VAR 0 12
75252: PPUSH
75253: LD_VAR 0 8
75257: PPUSH
75258: LD_INT 0
75260: PPUSH
75261: CALL 81657 0 3
// end ;
75265: GO 75163
75267: POP
75268: POP
// if enchidnas then
75269: LD_VAR 0 4
75273: IFFALSE 75340
// for i = 1 to enchidnas do
75275: LD_ADDR_VAR 0 11
75279: PUSH
75280: DOUBLE
75281: LD_INT 1
75283: DEC
75284: ST_TO_ADDR
75285: LD_VAR 0 4
75289: PUSH
75290: FOR_TO
75291: IFFALSE 75338
// begin hc_class = 13 ;
75293: LD_ADDR_OWVAR 28
75297: PUSH
75298: LD_INT 13
75300: ST_TO_ADDR
// hc_gallery =  ;
75301: LD_ADDR_OWVAR 33
75305: PUSH
75306: LD_STRING 
75308: ST_TO_ADDR
// animal := CreateHuman ;
75309: LD_ADDR_VAR 0 12
75313: PUSH
75314: CALL_OW 44
75318: ST_TO_ADDR
// PlaceUnitInArea ( animal , nat_area , false ) ;
75319: LD_VAR 0 12
75323: PPUSH
75324: LD_VAR 0 8
75328: PPUSH
75329: LD_INT 0
75331: PPUSH
75332: CALL 81657 0 3
// end ;
75336: GO 75290
75338: POP
75339: POP
// if fishes then
75340: LD_VAR 0 7
75344: IFFALSE 75411
// for i = 1 to fishes do
75346: LD_ADDR_VAR 0 11
75350: PUSH
75351: DOUBLE
75352: LD_INT 1
75354: DEC
75355: ST_TO_ADDR
75356: LD_VAR 0 7
75360: PUSH
75361: FOR_TO
75362: IFFALSE 75409
// begin hc_class = 20 ;
75364: LD_ADDR_OWVAR 28
75368: PUSH
75369: LD_INT 20
75371: ST_TO_ADDR
// hc_gallery =  ;
75372: LD_ADDR_OWVAR 33
75376: PUSH
75377: LD_STRING 
75379: ST_TO_ADDR
// animal := CreateHuman ;
75380: LD_ADDR_VAR 0 12
75384: PUSH
75385: CALL_OW 44
75389: ST_TO_ADDR
// PlaceUnitInArea ( animal , wat_area , false ) ;
75390: LD_VAR 0 12
75394: PPUSH
75395: LD_VAR 0 9
75399: PPUSH
75400: LD_INT 0
75402: PPUSH
75403: CALL 81657 0 3
// end ;
75407: GO 75361
75409: POP
75410: POP
// end ;
75411: LD_VAR 0 10
75415: RET
// export function WantHeal ( sci , unit ) ; begin
75416: LD_INT 0
75418: PPUSH
// if GetTaskList ( sci ) > 0 then
75419: LD_VAR 0 1
75423: PPUSH
75424: CALL_OW 437
75428: PUSH
75429: LD_INT 0
75431: GREATER
75432: IFFALSE 75502
// begin if GetTaskList ( sci ) [ 1 ] [ 1 ] = l and GetTaskList ( sci ) [ 1 ] [ 4 ] = unit then
75434: LD_VAR 0 1
75438: PPUSH
75439: CALL_OW 437
75443: PUSH
75444: LD_INT 1
75446: ARRAY
75447: PUSH
75448: LD_INT 1
75450: ARRAY
75451: PUSH
75452: LD_STRING l
75454: EQUAL
75455: PUSH
75456: LD_VAR 0 1
75460: PPUSH
75461: CALL_OW 437
75465: PUSH
75466: LD_INT 1
75468: ARRAY
75469: PUSH
75470: LD_INT 4
75472: ARRAY
75473: PUSH
75474: LD_VAR 0 2
75478: EQUAL
75479: AND
75480: IFFALSE 75492
// result := true else
75482: LD_ADDR_VAR 0 3
75486: PUSH
75487: LD_INT 1
75489: ST_TO_ADDR
75490: GO 75500
// result := false ;
75492: LD_ADDR_VAR 0 3
75496: PUSH
75497: LD_INT 0
75499: ST_TO_ADDR
// end else
75500: GO 75510
// result := false ;
75502: LD_ADDR_VAR 0 3
75506: PUSH
75507: LD_INT 0
75509: ST_TO_ADDR
// end ;
75510: LD_VAR 0 3
75514: RET
// export function HealTarget ( sci ) ; begin
75515: LD_INT 0
75517: PPUSH
// if not sci then
75518: LD_VAR 0 1
75522: NOT
75523: IFFALSE 75527
// exit ;
75525: GO 75592
// result := 0 ;
75527: LD_ADDR_VAR 0 2
75531: PUSH
75532: LD_INT 0
75534: ST_TO_ADDR
// if GetTaskList ( sci ) then
75535: LD_VAR 0 1
75539: PPUSH
75540: CALL_OW 437
75544: IFFALSE 75592
// if GetTaskList ( sci ) [ 1 ] [ 1 ] = l then
75546: LD_VAR 0 1
75550: PPUSH
75551: CALL_OW 437
75555: PUSH
75556: LD_INT 1
75558: ARRAY
75559: PUSH
75560: LD_INT 1
75562: ARRAY
75563: PUSH
75564: LD_STRING l
75566: EQUAL
75567: IFFALSE 75592
// result := GetTaskList ( sci ) [ 1 ] [ 4 ] ;
75569: LD_ADDR_VAR 0 2
75573: PUSH
75574: LD_VAR 0 1
75578: PPUSH
75579: CALL_OW 437
75583: PUSH
75584: LD_INT 1
75586: ARRAY
75587: PUSH
75588: LD_INT 4
75590: ARRAY
75591: ST_TO_ADDR
// end ;
75592: LD_VAR 0 2
75596: RET
// export function Attack ( list ) ; var base , group , path , flags , i , j , k , x , y , d , z , tmp , tmp2 , units_path , f_ignore_area , f_capture , f_ignore_civ , f_murder , f_mines , f_repair , f_heal , f_spacetime , f_attack_depot , f_crawl , mined , bombed , attacking , to_heal , healers , to_repair , repairs , empty_vehs , side ; begin
75597: LD_INT 0
75599: PPUSH
75600: PPUSH
75601: PPUSH
75602: PPUSH
75603: PPUSH
75604: PPUSH
75605: PPUSH
75606: PPUSH
75607: PPUSH
75608: PPUSH
75609: PPUSH
75610: PPUSH
75611: PPUSH
75612: PPUSH
75613: PPUSH
75614: PPUSH
75615: PPUSH
75616: PPUSH
75617: PPUSH
75618: PPUSH
75619: PPUSH
75620: PPUSH
75621: PPUSH
75622: PPUSH
75623: PPUSH
75624: PPUSH
75625: PPUSH
75626: PPUSH
75627: PPUSH
75628: PPUSH
75629: PPUSH
75630: PPUSH
75631: PPUSH
75632: PPUSH
// if not list then
75633: LD_VAR 0 1
75637: NOT
75638: IFFALSE 75642
// exit ;
75640: GO 80268
// base := list [ 1 ] ;
75642: LD_ADDR_VAR 0 3
75646: PUSH
75647: LD_VAR 0 1
75651: PUSH
75652: LD_INT 1
75654: ARRAY
75655: ST_TO_ADDR
// group := list [ 2 ] ;
75656: LD_ADDR_VAR 0 4
75660: PUSH
75661: LD_VAR 0 1
75665: PUSH
75666: LD_INT 2
75668: ARRAY
75669: ST_TO_ADDR
// path := list [ 3 ] ;
75670: LD_ADDR_VAR 0 5
75674: PUSH
75675: LD_VAR 0 1
75679: PUSH
75680: LD_INT 3
75682: ARRAY
75683: ST_TO_ADDR
// flags := list [ 4 ] ;
75684: LD_ADDR_VAR 0 6
75688: PUSH
75689: LD_VAR 0 1
75693: PUSH
75694: LD_INT 4
75696: ARRAY
75697: ST_TO_ADDR
// mined := [ ] ;
75698: LD_ADDR_VAR 0 27
75702: PUSH
75703: EMPTY
75704: ST_TO_ADDR
// bombed := [ ] ;
75705: LD_ADDR_VAR 0 28
75709: PUSH
75710: EMPTY
75711: ST_TO_ADDR
// healers := [ ] ;
75712: LD_ADDR_VAR 0 31
75716: PUSH
75717: EMPTY
75718: ST_TO_ADDR
// to_heal := [ ] ;
75719: LD_ADDR_VAR 0 30
75723: PUSH
75724: EMPTY
75725: ST_TO_ADDR
// repairs := [ ] ;
75726: LD_ADDR_VAR 0 33
75730: PUSH
75731: EMPTY
75732: ST_TO_ADDR
// to_repair := [ ] ;
75733: LD_ADDR_VAR 0 32
75737: PUSH
75738: EMPTY
75739: ST_TO_ADDR
// if not group or not path then
75740: LD_VAR 0 4
75744: NOT
75745: PUSH
75746: LD_VAR 0 5
75750: NOT
75751: OR
75752: IFFALSE 75756
// exit ;
75754: GO 80268
// side := GetSide ( group [ 1 ] ) ;
75756: LD_ADDR_VAR 0 35
75760: PUSH
75761: LD_VAR 0 4
75765: PUSH
75766: LD_INT 1
75768: ARRAY
75769: PPUSH
75770: CALL_OW 255
75774: ST_TO_ADDR
// if flags then
75775: LD_VAR 0 6
75779: IFFALSE 75923
// begin f_ignore_area := flags [ 1 ] ;
75781: LD_ADDR_VAR 0 17
75785: PUSH
75786: LD_VAR 0 6
75790: PUSH
75791: LD_INT 1
75793: ARRAY
75794: ST_TO_ADDR
// f_capture := flags [ 2 ] ;
75795: LD_ADDR_VAR 0 18
75799: PUSH
75800: LD_VAR 0 6
75804: PUSH
75805: LD_INT 2
75807: ARRAY
75808: ST_TO_ADDR
// f_ignore_civ := flags [ 3 ] ;
75809: LD_ADDR_VAR 0 19
75813: PUSH
75814: LD_VAR 0 6
75818: PUSH
75819: LD_INT 3
75821: ARRAY
75822: ST_TO_ADDR
// f_murder := flags [ 4 ] ;
75823: LD_ADDR_VAR 0 20
75827: PUSH
75828: LD_VAR 0 6
75832: PUSH
75833: LD_INT 4
75835: ARRAY
75836: ST_TO_ADDR
// f_mines := flags [ 5 ] ;
75837: LD_ADDR_VAR 0 21
75841: PUSH
75842: LD_VAR 0 6
75846: PUSH
75847: LD_INT 5
75849: ARRAY
75850: ST_TO_ADDR
// f_repair := flags [ 6 ] ;
75851: LD_ADDR_VAR 0 22
75855: PUSH
75856: LD_VAR 0 6
75860: PUSH
75861: LD_INT 6
75863: ARRAY
75864: ST_TO_ADDR
// f_heal := flags [ 7 ] ;
75865: LD_ADDR_VAR 0 23
75869: PUSH
75870: LD_VAR 0 6
75874: PUSH
75875: LD_INT 7
75877: ARRAY
75878: ST_TO_ADDR
// f_spacetime := flags [ 8 ] ;
75879: LD_ADDR_VAR 0 24
75883: PUSH
75884: LD_VAR 0 6
75888: PUSH
75889: LD_INT 8
75891: ARRAY
75892: ST_TO_ADDR
// f_attack_depot := flags [ 9 ] ;
75893: LD_ADDR_VAR 0 25
75897: PUSH
75898: LD_VAR 0 6
75902: PUSH
75903: LD_INT 9
75905: ARRAY
75906: ST_TO_ADDR
// f_crawl := flags [ 10 ] ;
75907: LD_ADDR_VAR 0 26
75911: PUSH
75912: LD_VAR 0 6
75916: PUSH
75917: LD_INT 10
75919: ARRAY
75920: ST_TO_ADDR
// end else
75921: GO 76003
// begin f_ignore_area := false ;
75923: LD_ADDR_VAR 0 17
75927: PUSH
75928: LD_INT 0
75930: ST_TO_ADDR
// f_capture := false ;
75931: LD_ADDR_VAR 0 18
75935: PUSH
75936: LD_INT 0
75938: ST_TO_ADDR
// f_ignore_civ := false ;
75939: LD_ADDR_VAR 0 19
75943: PUSH
75944: LD_INT 0
75946: ST_TO_ADDR
// f_murder := false ;
75947: LD_ADDR_VAR 0 20
75951: PUSH
75952: LD_INT 0
75954: ST_TO_ADDR
// f_mines := false ;
75955: LD_ADDR_VAR 0 21
75959: PUSH
75960: LD_INT 0
75962: ST_TO_ADDR
// f_repair := false ;
75963: LD_ADDR_VAR 0 22
75967: PUSH
75968: LD_INT 0
75970: ST_TO_ADDR
// f_heal := false ;
75971: LD_ADDR_VAR 0 23
75975: PUSH
75976: LD_INT 0
75978: ST_TO_ADDR
// f_spacetime := false ;
75979: LD_ADDR_VAR 0 24
75983: PUSH
75984: LD_INT 0
75986: ST_TO_ADDR
// f_attack_depot := false ;
75987: LD_ADDR_VAR 0 25
75991: PUSH
75992: LD_INT 0
75994: ST_TO_ADDR
// f_crawl := false ;
75995: LD_ADDR_VAR 0 26
75999: PUSH
76000: LD_INT 0
76002: ST_TO_ADDR
// end ; if f_heal then
76003: LD_VAR 0 23
76007: IFFALSE 76034
// healers := UnitFilter ( group , [ f_class , 4 ] ) ;
76009: LD_ADDR_VAR 0 31
76013: PUSH
76014: LD_VAR 0 4
76018: PPUSH
76019: LD_INT 25
76021: PUSH
76022: LD_INT 4
76024: PUSH
76025: EMPTY
76026: LIST
76027: LIST
76028: PPUSH
76029: CALL_OW 72
76033: ST_TO_ADDR
// if f_repair then
76034: LD_VAR 0 22
76038: IFFALSE 76065
// repairs := UnitFilter ( group , [ f_class , 3 ] ) ;
76040: LD_ADDR_VAR 0 33
76044: PUSH
76045: LD_VAR 0 4
76049: PPUSH
76050: LD_INT 25
76052: PUSH
76053: LD_INT 3
76055: PUSH
76056: EMPTY
76057: LIST
76058: LIST
76059: PPUSH
76060: CALL_OW 72
76064: ST_TO_ADDR
// units_path := [ ] ;
76065: LD_ADDR_VAR 0 16
76069: PUSH
76070: EMPTY
76071: ST_TO_ADDR
// for i = 1 to group do
76072: LD_ADDR_VAR 0 7
76076: PUSH
76077: DOUBLE
76078: LD_INT 1
76080: DEC
76081: ST_TO_ADDR
76082: LD_VAR 0 4
76086: PUSH
76087: FOR_TO
76088: IFFALSE 76117
// units_path := Replace ( units_path , i , path ) ;
76090: LD_ADDR_VAR 0 16
76094: PUSH
76095: LD_VAR 0 16
76099: PPUSH
76100: LD_VAR 0 7
76104: PPUSH
76105: LD_VAR 0 5
76109: PPUSH
76110: CALL_OW 1
76114: ST_TO_ADDR
76115: GO 76087
76117: POP
76118: POP
// repeat for i = group downto 1 do
76119: LD_ADDR_VAR 0 7
76123: PUSH
76124: DOUBLE
76125: LD_VAR 0 4
76129: INC
76130: ST_TO_ADDR
76131: LD_INT 1
76133: PUSH
76134: FOR_DOWNTO
76135: IFFALSE 80231
// begin wait ( 5 ) ;
76137: LD_INT 5
76139: PPUSH
76140: CALL_OW 67
// tmp := [ ] ;
76144: LD_ADDR_VAR 0 14
76148: PUSH
76149: EMPTY
76150: ST_TO_ADDR
// attacking := false ;
76151: LD_ADDR_VAR 0 29
76155: PUSH
76156: LD_INT 0
76158: ST_TO_ADDR
// if IsDead ( group [ i ] ) or not group [ i ] then
76159: LD_VAR 0 4
76163: PUSH
76164: LD_VAR 0 7
76168: ARRAY
76169: PPUSH
76170: CALL_OW 301
76174: PUSH
76175: LD_VAR 0 4
76179: PUSH
76180: LD_VAR 0 7
76184: ARRAY
76185: NOT
76186: OR
76187: IFFALSE 76296
// begin if GetType ( group [ i ] ) = unit_human then
76189: LD_VAR 0 4
76193: PUSH
76194: LD_VAR 0 7
76198: ARRAY
76199: PPUSH
76200: CALL_OW 247
76204: PUSH
76205: LD_INT 1
76207: EQUAL
76208: IFFALSE 76254
// begin to_heal := to_heal diff group [ i ] ;
76210: LD_ADDR_VAR 0 30
76214: PUSH
76215: LD_VAR 0 30
76219: PUSH
76220: LD_VAR 0 4
76224: PUSH
76225: LD_VAR 0 7
76229: ARRAY
76230: DIFF
76231: ST_TO_ADDR
// healers := healers diff group [ i ] ;
76232: LD_ADDR_VAR 0 31
76236: PUSH
76237: LD_VAR 0 31
76241: PUSH
76242: LD_VAR 0 4
76246: PUSH
76247: LD_VAR 0 7
76251: ARRAY
76252: DIFF
76253: ST_TO_ADDR
// end ; group := Delete ( group , i ) ;
76254: LD_ADDR_VAR 0 4
76258: PUSH
76259: LD_VAR 0 4
76263: PPUSH
76264: LD_VAR 0 7
76268: PPUSH
76269: CALL_OW 3
76273: ST_TO_ADDR
// units_path := Delete ( units_path , i ) ;
76274: LD_ADDR_VAR 0 16
76278: PUSH
76279: LD_VAR 0 16
76283: PPUSH
76284: LD_VAR 0 7
76288: PPUSH
76289: CALL_OW 3
76293: ST_TO_ADDR
// continue ;
76294: GO 76134
// end ; if f_repair then
76296: LD_VAR 0 22
76300: IFFALSE 76789
// begin if GetType ( group [ i ] ) = unit_vehicle then
76302: LD_VAR 0 4
76306: PUSH
76307: LD_VAR 0 7
76311: ARRAY
76312: PPUSH
76313: CALL_OW 247
76317: PUSH
76318: LD_INT 2
76320: EQUAL
76321: IFFALSE 76511
// begin if GetLives ( group [ i ] ) < 700 and not group [ i ] in to_repair then
76323: LD_VAR 0 4
76327: PUSH
76328: LD_VAR 0 7
76332: ARRAY
76333: PPUSH
76334: CALL_OW 256
76338: PUSH
76339: LD_INT 700
76341: LESS
76342: PUSH
76343: LD_VAR 0 4
76347: PUSH
76348: LD_VAR 0 7
76352: ARRAY
76353: PUSH
76354: LD_VAR 0 32
76358: IN
76359: NOT
76360: AND
76361: IFFALSE 76385
// to_repair := to_repair union group [ i ] ;
76363: LD_ADDR_VAR 0 32
76367: PUSH
76368: LD_VAR 0 32
76372: PUSH
76373: LD_VAR 0 4
76377: PUSH
76378: LD_VAR 0 7
76382: ARRAY
76383: UNION
76384: ST_TO_ADDR
// if GetLives ( group [ i ] ) = 1000 and group [ i ] in to_repair then
76385: LD_VAR 0 4
76389: PUSH
76390: LD_VAR 0 7
76394: ARRAY
76395: PPUSH
76396: CALL_OW 256
76400: PUSH
76401: LD_INT 1000
76403: EQUAL
76404: PUSH
76405: LD_VAR 0 4
76409: PUSH
76410: LD_VAR 0 7
76414: ARRAY
76415: PUSH
76416: LD_VAR 0 32
76420: IN
76421: AND
76422: IFFALSE 76446
// to_repair := to_repair diff group [ i ] ;
76424: LD_ADDR_VAR 0 32
76428: PUSH
76429: LD_VAR 0 32
76433: PUSH
76434: LD_VAR 0 4
76438: PUSH
76439: LD_VAR 0 7
76443: ARRAY
76444: DIFF
76445: ST_TO_ADDR
// if group [ i ] in to_repair then
76446: LD_VAR 0 4
76450: PUSH
76451: LD_VAR 0 7
76455: ARRAY
76456: PUSH
76457: LD_VAR 0 32
76461: IN
76462: IFFALSE 76509
// begin if not IsInArea ( group [ i ] , f_repair ) then
76464: LD_VAR 0 4
76468: PUSH
76469: LD_VAR 0 7
76473: ARRAY
76474: PPUSH
76475: LD_VAR 0 22
76479: PPUSH
76480: CALL_OW 308
76484: NOT
76485: IFFALSE 76507
// ComMoveToArea ( group [ i ] , f_repair ) ;
76487: LD_VAR 0 4
76491: PUSH
76492: LD_VAR 0 7
76496: ARRAY
76497: PPUSH
76498: LD_VAR 0 22
76502: PPUSH
76503: CALL_OW 113
// continue ;
76507: GO 76134
// end ; end else
76509: GO 76789
// if group [ i ] in repairs then
76511: LD_VAR 0 4
76515: PUSH
76516: LD_VAR 0 7
76520: ARRAY
76521: PUSH
76522: LD_VAR 0 33
76526: IN
76527: IFFALSE 76789
// begin if IsInUnit ( group [ i ] ) then
76529: LD_VAR 0 4
76533: PUSH
76534: LD_VAR 0 7
76538: ARRAY
76539: PPUSH
76540: CALL_OW 310
76544: IFFALSE 76612
// begin z := IsInUnit ( group [ i ] ) ;
76546: LD_ADDR_VAR 0 13
76550: PUSH
76551: LD_VAR 0 4
76555: PUSH
76556: LD_VAR 0 7
76560: ARRAY
76561: PPUSH
76562: CALL_OW 310
76566: ST_TO_ADDR
// if z in to_repair and IsInArea ( z , f_repair ) then
76567: LD_VAR 0 13
76571: PUSH
76572: LD_VAR 0 32
76576: IN
76577: PUSH
76578: LD_VAR 0 13
76582: PPUSH
76583: LD_VAR 0 22
76587: PPUSH
76588: CALL_OW 308
76592: AND
76593: IFFALSE 76610
// ComExitVehicle ( group [ i ] ) ;
76595: LD_VAR 0 4
76599: PUSH
76600: LD_VAR 0 7
76604: ARRAY
76605: PPUSH
76606: CALL_OW 121
// end else
76610: GO 76789
// begin z := UnitFilter ( group , [ [ f_inarea , f_repair ] , [ f_empty ] ] ) ;
76612: LD_ADDR_VAR 0 13
76616: PUSH
76617: LD_VAR 0 4
76621: PPUSH
76622: LD_INT 95
76624: PUSH
76625: LD_VAR 0 22
76629: PUSH
76630: EMPTY
76631: LIST
76632: LIST
76633: PUSH
76634: LD_INT 58
76636: PUSH
76637: EMPTY
76638: LIST
76639: PUSH
76640: EMPTY
76641: LIST
76642: LIST
76643: PPUSH
76644: CALL_OW 72
76648: ST_TO_ADDR
// if not HasTask ( group [ i ] ) then
76649: LD_VAR 0 4
76653: PUSH
76654: LD_VAR 0 7
76658: ARRAY
76659: PPUSH
76660: CALL_OW 314
76664: NOT
76665: IFFALSE 76787
// begin x := NearestUnitToUnit ( z , group [ i ] ) ;
76667: LD_ADDR_VAR 0 10
76671: PUSH
76672: LD_VAR 0 13
76676: PPUSH
76677: LD_VAR 0 4
76681: PUSH
76682: LD_VAR 0 7
76686: ARRAY
76687: PPUSH
76688: CALL_OW 74
76692: ST_TO_ADDR
// if not x then
76693: LD_VAR 0 10
76697: NOT
76698: IFFALSE 76702
// continue ;
76700: GO 76134
// if GetLives ( x ) < 1000 then
76702: LD_VAR 0 10
76706: PPUSH
76707: CALL_OW 256
76711: PUSH
76712: LD_INT 1000
76714: LESS
76715: IFFALSE 76739
// ComRepairVehicle ( group [ i ] , x ) else
76717: LD_VAR 0 4
76721: PUSH
76722: LD_VAR 0 7
76726: ARRAY
76727: PPUSH
76728: LD_VAR 0 10
76732: PPUSH
76733: CALL_OW 129
76737: GO 76787
// if not ( f_heal and GetLives ( group [ i ] ) < 1000 ) then
76739: LD_VAR 0 23
76743: PUSH
76744: LD_VAR 0 4
76748: PUSH
76749: LD_VAR 0 7
76753: ARRAY
76754: PPUSH
76755: CALL_OW 256
76759: PUSH
76760: LD_INT 1000
76762: LESS
76763: AND
76764: NOT
76765: IFFALSE 76787
// ComEnterUnit ( group [ i ] , x ) ;
76767: LD_VAR 0 4
76771: PUSH
76772: LD_VAR 0 7
76776: ARRAY
76777: PPUSH
76778: LD_VAR 0 10
76782: PPUSH
76783: CALL_OW 120
// end ; continue ;
76787: GO 76134
// end ; end ; end ; if f_heal and GetType ( group [ i ] ) = unit_human then
76789: LD_VAR 0 23
76793: PUSH
76794: LD_VAR 0 4
76798: PUSH
76799: LD_VAR 0 7
76803: ARRAY
76804: PPUSH
76805: CALL_OW 247
76809: PUSH
76810: LD_INT 1
76812: EQUAL
76813: AND
76814: IFFALSE 77292
// begin if group [ i ] in healers then
76816: LD_VAR 0 4
76820: PUSH
76821: LD_VAR 0 7
76825: ARRAY
76826: PUSH
76827: LD_VAR 0 31
76831: IN
76832: IFFALSE 77105
// begin if not IsInArea ( group [ i ] , f_heal ) and not HasTask ( group [ i ] ) then
76834: LD_VAR 0 4
76838: PUSH
76839: LD_VAR 0 7
76843: ARRAY
76844: PPUSH
76845: LD_VAR 0 23
76849: PPUSH
76850: CALL_OW 308
76854: NOT
76855: PUSH
76856: LD_VAR 0 4
76860: PUSH
76861: LD_VAR 0 7
76865: ARRAY
76866: PPUSH
76867: CALL_OW 314
76871: NOT
76872: AND
76873: IFFALSE 76897
// ComMoveToArea ( group [ i ] , f_heal ) else
76875: LD_VAR 0 4
76879: PUSH
76880: LD_VAR 0 7
76884: ARRAY
76885: PPUSH
76886: LD_VAR 0 23
76890: PPUSH
76891: CALL_OW 113
76895: GO 77103
// if GetLives ( HealTarget ( group [ i ] ) ) = 1000 then
76897: LD_VAR 0 4
76901: PUSH
76902: LD_VAR 0 7
76906: ARRAY
76907: PPUSH
76908: CALL 75515 0 1
76912: PPUSH
76913: CALL_OW 256
76917: PUSH
76918: LD_INT 1000
76920: EQUAL
76921: IFFALSE 76940
// ComStop ( group [ i ] ) else
76923: LD_VAR 0 4
76927: PUSH
76928: LD_VAR 0 7
76932: ARRAY
76933: PPUSH
76934: CALL_OW 141
76938: GO 77103
// if not HasTask ( group [ i ] ) and to_heal then
76940: LD_VAR 0 4
76944: PUSH
76945: LD_VAR 0 7
76949: ARRAY
76950: PPUSH
76951: CALL_OW 314
76955: NOT
76956: PUSH
76957: LD_VAR 0 30
76961: AND
76962: IFFALSE 77103
// begin z := NearestUnitToUnit ( UnitFilter ( to_heal , [ f_not , [ f_inside ] ] ) , group [ i ] ) ;
76964: LD_ADDR_VAR 0 13
76968: PUSH
76969: LD_VAR 0 30
76973: PPUSH
76974: LD_INT 3
76976: PUSH
76977: LD_INT 54
76979: PUSH
76980: EMPTY
76981: LIST
76982: PUSH
76983: EMPTY
76984: LIST
76985: LIST
76986: PPUSH
76987: CALL_OW 72
76991: PPUSH
76992: LD_VAR 0 4
76996: PUSH
76997: LD_VAR 0 7
77001: ARRAY
77002: PPUSH
77003: CALL_OW 74
77007: ST_TO_ADDR
// if z then
77008: LD_VAR 0 13
77012: IFFALSE 77103
// if FilterAllUnits ( [ [ f_dist , z , 10 ] , [ f_enemy , GetSide ( z ) ] ] ) = 0 then
77014: LD_INT 91
77016: PUSH
77017: LD_VAR 0 13
77021: PUSH
77022: LD_INT 10
77024: PUSH
77025: EMPTY
77026: LIST
77027: LIST
77028: LIST
77029: PUSH
77030: LD_INT 81
77032: PUSH
77033: LD_VAR 0 13
77037: PPUSH
77038: CALL_OW 255
77042: PUSH
77043: EMPTY
77044: LIST
77045: LIST
77046: PUSH
77047: EMPTY
77048: LIST
77049: LIST
77050: PPUSH
77051: CALL_OW 69
77055: PUSH
77056: LD_INT 0
77058: EQUAL
77059: IFFALSE 77083
// ComHeal ( group [ i ] , z ) else
77061: LD_VAR 0 4
77065: PUSH
77066: LD_VAR 0 7
77070: ARRAY
77071: PPUSH
77072: LD_VAR 0 13
77076: PPUSH
77077: CALL_OW 128
77081: GO 77103
// ComMoveToArea ( group [ i ] , f_heal ) ;
77083: LD_VAR 0 4
77087: PUSH
77088: LD_VAR 0 7
77092: ARRAY
77093: PPUSH
77094: LD_VAR 0 23
77098: PPUSH
77099: CALL_OW 113
// end ; continue ;
77103: GO 76134
// end ; if GetLives ( group [ i ] ) < 700 and not group [ i ] in to_heal then
77105: LD_VAR 0 4
77109: PUSH
77110: LD_VAR 0 7
77114: ARRAY
77115: PPUSH
77116: CALL_OW 256
77120: PUSH
77121: LD_INT 700
77123: LESS
77124: PUSH
77125: LD_VAR 0 4
77129: PUSH
77130: LD_VAR 0 7
77134: ARRAY
77135: PUSH
77136: LD_VAR 0 30
77140: IN
77141: NOT
77142: AND
77143: IFFALSE 77167
// to_heal := to_heal union group [ i ] ;
77145: LD_ADDR_VAR 0 30
77149: PUSH
77150: LD_VAR 0 30
77154: PUSH
77155: LD_VAR 0 4
77159: PUSH
77160: LD_VAR 0 7
77164: ARRAY
77165: UNION
77166: ST_TO_ADDR
// if group [ i ] in to_heal then
77167: LD_VAR 0 4
77171: PUSH
77172: LD_VAR 0 7
77176: ARRAY
77177: PUSH
77178: LD_VAR 0 30
77182: IN
77183: IFFALSE 77292
// begin if GetLives ( group [ i ] ) = 1000 then
77185: LD_VAR 0 4
77189: PUSH
77190: LD_VAR 0 7
77194: ARRAY
77195: PPUSH
77196: CALL_OW 256
77200: PUSH
77201: LD_INT 1000
77203: EQUAL
77204: IFFALSE 77230
// to_heal := to_heal diff group [ i ] else
77206: LD_ADDR_VAR 0 30
77210: PUSH
77211: LD_VAR 0 30
77215: PUSH
77216: LD_VAR 0 4
77220: PUSH
77221: LD_VAR 0 7
77225: ARRAY
77226: DIFF
77227: ST_TO_ADDR
77228: GO 77292
// begin if not IsInArea ( group [ i ] , to_heal ) then
77230: LD_VAR 0 4
77234: PUSH
77235: LD_VAR 0 7
77239: ARRAY
77240: PPUSH
77241: LD_VAR 0 30
77245: PPUSH
77246: CALL_OW 308
77250: NOT
77251: IFFALSE 77275
// ComMoveToArea ( group [ i ] , f_heal ) else
77253: LD_VAR 0 4
77257: PUSH
77258: LD_VAR 0 7
77262: ARRAY
77263: PPUSH
77264: LD_VAR 0 23
77268: PPUSH
77269: CALL_OW 113
77273: GO 77290
// ComHold ( group [ i ] ) ;
77275: LD_VAR 0 4
77279: PUSH
77280: LD_VAR 0 7
77284: ARRAY
77285: PPUSH
77286: CALL_OW 140
// continue ;
77290: GO 76134
// end ; end ; end ; if not EnemyInRange ( group [ i ] , 10 ) and not units_path [ i ] = [ ] then
77292: LD_VAR 0 4
77296: PUSH
77297: LD_VAR 0 7
77301: ARRAY
77302: PPUSH
77303: LD_INT 10
77305: PPUSH
77306: CALL 73912 0 2
77310: NOT
77311: PUSH
77312: LD_VAR 0 16
77316: PUSH
77317: LD_VAR 0 7
77321: ARRAY
77322: PUSH
77323: EMPTY
77324: EQUAL
77325: NOT
77326: AND
77327: IFFALSE 77593
// begin if GetEngine ( group [ i ] ) in [ engine_combustion , engine_solar ] then
77329: LD_VAR 0 4
77333: PUSH
77334: LD_VAR 0 7
77338: ARRAY
77339: PPUSH
77340: CALL_OW 262
77344: PUSH
77345: LD_INT 1
77347: PUSH
77348: LD_INT 2
77350: PUSH
77351: EMPTY
77352: LIST
77353: LIST
77354: IN
77355: IFFALSE 77396
// if GetFuel ( group [ i ] ) < 10 then
77357: LD_VAR 0 4
77361: PUSH
77362: LD_VAR 0 7
77366: ARRAY
77367: PPUSH
77368: CALL_OW 261
77372: PUSH
77373: LD_INT 10
77375: LESS
77376: IFFALSE 77396
// SetFuel ( group [ i ] , 12 ) ;
77378: LD_VAR 0 4
77382: PUSH
77383: LD_VAR 0 7
77387: ARRAY
77388: PPUSH
77389: LD_INT 12
77391: PPUSH
77392: CALL_OW 240
// if units_path [ i ] then
77396: LD_VAR 0 16
77400: PUSH
77401: LD_VAR 0 7
77405: ARRAY
77406: IFFALSE 77591
// begin if GetDistUnitXY ( group [ i ] , units_path [ i ] [ 1 ] [ 1 ] , units_path [ i ] [ 1 ] [ 2 ] ) > 6 then
77408: LD_VAR 0 4
77412: PUSH
77413: LD_VAR 0 7
77417: ARRAY
77418: PPUSH
77419: LD_VAR 0 16
77423: PUSH
77424: LD_VAR 0 7
77428: ARRAY
77429: PUSH
77430: LD_INT 1
77432: ARRAY
77433: PUSH
77434: LD_INT 1
77436: ARRAY
77437: PPUSH
77438: LD_VAR 0 16
77442: PUSH
77443: LD_VAR 0 7
77447: ARRAY
77448: PUSH
77449: LD_INT 1
77451: ARRAY
77452: PUSH
77453: LD_INT 2
77455: ARRAY
77456: PPUSH
77457: CALL_OW 297
77461: PUSH
77462: LD_INT 6
77464: GREATER
77465: IFFALSE 77540
// begin if not HasTask ( group [ i ] ) then
77467: LD_VAR 0 4
77471: PUSH
77472: LD_VAR 0 7
77476: ARRAY
77477: PPUSH
77478: CALL_OW 314
77482: NOT
77483: IFFALSE 77538
// ComAgressiveMove ( group [ i ] , units_path [ i ] [ 1 ] [ 1 ] , units_path [ i ] [ 1 ] [ 2 ] ) ;
77485: LD_VAR 0 4
77489: PUSH
77490: LD_VAR 0 7
77494: ARRAY
77495: PPUSH
77496: LD_VAR 0 16
77500: PUSH
77501: LD_VAR 0 7
77505: ARRAY
77506: PUSH
77507: LD_INT 1
77509: ARRAY
77510: PUSH
77511: LD_INT 1
77513: ARRAY
77514: PPUSH
77515: LD_VAR 0 16
77519: PUSH
77520: LD_VAR 0 7
77524: ARRAY
77525: PUSH
77526: LD_INT 1
77528: ARRAY
77529: PUSH
77530: LD_INT 2
77532: ARRAY
77533: PPUSH
77534: CALL_OW 114
// end else
77538: GO 77591
// begin tmp2 := Delete ( units_path [ i ] , 1 ) ;
77540: LD_ADDR_VAR 0 15
77544: PUSH
77545: LD_VAR 0 16
77549: PUSH
77550: LD_VAR 0 7
77554: ARRAY
77555: PPUSH
77556: LD_INT 1
77558: PPUSH
77559: CALL_OW 3
77563: ST_TO_ADDR
// units_path := Replace ( units_path , i , tmp2 ) ;
77564: LD_ADDR_VAR 0 16
77568: PUSH
77569: LD_VAR 0 16
77573: PPUSH
77574: LD_VAR 0 7
77578: PPUSH
77579: LD_VAR 0 15
77583: PPUSH
77584: CALL_OW 1
77588: ST_TO_ADDR
// continue ;
77589: GO 76134
// end ; end ; end else
77591: GO 80229
// begin tmp := FilterAllUnits ( [ f_enemy , GetSide ( group [ i ] ) ] ) ;
77593: LD_ADDR_VAR 0 14
77597: PUSH
77598: LD_INT 81
77600: PUSH
77601: LD_VAR 0 4
77605: PUSH
77606: LD_VAR 0 7
77610: ARRAY
77611: PPUSH
77612: CALL_OW 255
77616: PUSH
77617: EMPTY
77618: LIST
77619: LIST
77620: PPUSH
77621: CALL_OW 69
77625: ST_TO_ADDR
// if not tmp then
77626: LD_VAR 0 14
77630: NOT
77631: IFFALSE 77635
// continue ;
77633: GO 76134
// if f_ignore_area then
77635: LD_VAR 0 17
77639: IFFALSE 77727
// begin tmp2 := UnitFilter ( tmp , [ f_not , [ f_distxy , f_ignore_area [ 1 ] , f_ignore_area [ 2 ] , f_ignore_area [ 3 ] ] ] ) ;
77641: LD_ADDR_VAR 0 15
77645: PUSH
77646: LD_VAR 0 14
77650: PPUSH
77651: LD_INT 3
77653: PUSH
77654: LD_INT 92
77656: PUSH
77657: LD_VAR 0 17
77661: PUSH
77662: LD_INT 1
77664: ARRAY
77665: PUSH
77666: LD_VAR 0 17
77670: PUSH
77671: LD_INT 2
77673: ARRAY
77674: PUSH
77675: LD_VAR 0 17
77679: PUSH
77680: LD_INT 3
77682: ARRAY
77683: PUSH
77684: EMPTY
77685: LIST
77686: LIST
77687: LIST
77688: LIST
77689: PUSH
77690: EMPTY
77691: LIST
77692: LIST
77693: PPUSH
77694: CALL_OW 72
77698: ST_TO_ADDR
// if ( tmp diff tmp2 ) then
77699: LD_VAR 0 14
77703: PUSH
77704: LD_VAR 0 15
77708: DIFF
77709: IFFALSE 77727
// tmp := tmp diff tmp2 ;
77711: LD_ADDR_VAR 0 14
77715: PUSH
77716: LD_VAR 0 14
77720: PUSH
77721: LD_VAR 0 15
77725: DIFF
77726: ST_TO_ADDR
// end ; if not f_murder then
77727: LD_VAR 0 20
77731: NOT
77732: IFFALSE 77790
// begin tmp2 := UnitFilter ( tmp , [ f_not , [ f_ok ] ] ) ;
77734: LD_ADDR_VAR 0 15
77738: PUSH
77739: LD_VAR 0 14
77743: PPUSH
77744: LD_INT 3
77746: PUSH
77747: LD_INT 50
77749: PUSH
77750: EMPTY
77751: LIST
77752: PUSH
77753: EMPTY
77754: LIST
77755: LIST
77756: PPUSH
77757: CALL_OW 72
77761: ST_TO_ADDR
// if ( tmp diff tmp2 ) then
77762: LD_VAR 0 14
77766: PUSH
77767: LD_VAR 0 15
77771: DIFF
77772: IFFALSE 77790
// tmp := tmp diff tmp2 ;
77774: LD_ADDR_VAR 0 14
77778: PUSH
77779: LD_VAR 0 14
77783: PUSH
77784: LD_VAR 0 15
77788: DIFF
77789: ST_TO_ADDR
// end ; tmp := SortByDistanceUnit ( group [ i ] , tmp , true , true ) ;
77790: LD_ADDR_VAR 0 14
77794: PUSH
77795: LD_VAR 0 4
77799: PUSH
77800: LD_VAR 0 7
77804: ARRAY
77805: PPUSH
77806: LD_VAR 0 14
77810: PPUSH
77811: LD_INT 1
77813: PPUSH
77814: LD_INT 1
77816: PPUSH
77817: CALL 47555 0 4
77821: ST_TO_ADDR
// if GetClass ( group [ i ] ) = 1 then
77822: LD_VAR 0 4
77826: PUSH
77827: LD_VAR 0 7
77831: ARRAY
77832: PPUSH
77833: CALL_OW 257
77837: PUSH
77838: LD_INT 1
77840: EQUAL
77841: IFFALSE 78289
// begin if WantPlant ( group [ i ] ) then
77843: LD_VAR 0 4
77847: PUSH
77848: LD_VAR 0 7
77852: ARRAY
77853: PPUSH
77854: CALL 47056 0 1
77858: IFFALSE 77862
// continue ;
77860: GO 76134
// if f_capture and not IsInUnit ( group [ i ] ) and tmp [ 1 ] in UnitFilter ( tmp , [ [ f_type , unit_vehicle ] , [ f_empty ] ] ) then
77862: LD_VAR 0 18
77866: PUSH
77867: LD_VAR 0 4
77871: PUSH
77872: LD_VAR 0 7
77876: ARRAY
77877: PPUSH
77878: CALL_OW 310
77882: NOT
77883: AND
77884: PUSH
77885: LD_VAR 0 14
77889: PUSH
77890: LD_INT 1
77892: ARRAY
77893: PUSH
77894: LD_VAR 0 14
77898: PPUSH
77899: LD_INT 21
77901: PUSH
77902: LD_INT 2
77904: PUSH
77905: EMPTY
77906: LIST
77907: LIST
77908: PUSH
77909: LD_INT 58
77911: PUSH
77912: EMPTY
77913: LIST
77914: PUSH
77915: EMPTY
77916: LIST
77917: LIST
77918: PPUSH
77919: CALL_OW 72
77923: IN
77924: AND
77925: IFFALSE 77961
// begin ComEnterUnit ( group [ i ] , tmp [ 1 ] ) ;
77927: LD_VAR 0 4
77931: PUSH
77932: LD_VAR 0 7
77936: ARRAY
77937: PPUSH
77938: LD_VAR 0 14
77942: PUSH
77943: LD_INT 1
77945: ARRAY
77946: PPUSH
77947: CALL_OW 120
// attacking := true ;
77951: LD_ADDR_VAR 0 29
77955: PUSH
77956: LD_INT 1
77958: ST_TO_ADDR
// continue ;
77959: GO 76134
// end ; if f_crawl and GetClass ( group [ i ] ) = 1 and GetLives ( group [ i ] ) < 800 and not Crawls ( group [ i ] ) then
77961: LD_VAR 0 26
77965: PUSH
77966: LD_VAR 0 4
77970: PUSH
77971: LD_VAR 0 7
77975: ARRAY
77976: PPUSH
77977: CALL_OW 257
77981: PUSH
77982: LD_INT 1
77984: EQUAL
77985: AND
77986: PUSH
77987: LD_VAR 0 4
77991: PUSH
77992: LD_VAR 0 7
77996: ARRAY
77997: PPUSH
77998: CALL_OW 256
78002: PUSH
78003: LD_INT 800
78005: LESS
78006: AND
78007: PUSH
78008: LD_VAR 0 4
78012: PUSH
78013: LD_VAR 0 7
78017: ARRAY
78018: PPUSH
78019: CALL_OW 318
78023: NOT
78024: AND
78025: IFFALSE 78042
// ComCrawl ( group [ i ] ) ;
78027: LD_VAR 0 4
78031: PUSH
78032: LD_VAR 0 7
78036: ARRAY
78037: PPUSH
78038: CALL_OW 137
// if f_mines then
78042: LD_VAR 0 21
78046: IFFALSE 78289
// begin if GetType ( tmp [ 1 ] ) = unit_building and not tmp [ 1 ] in mined then
78048: LD_VAR 0 14
78052: PUSH
78053: LD_INT 1
78055: ARRAY
78056: PPUSH
78057: CALL_OW 247
78061: PUSH
78062: LD_INT 3
78064: EQUAL
78065: PUSH
78066: LD_VAR 0 14
78070: PUSH
78071: LD_INT 1
78073: ARRAY
78074: PUSH
78075: LD_VAR 0 27
78079: IN
78080: NOT
78081: AND
78082: IFFALSE 78289
// begin x := GetX ( tmp [ 1 ] ) ;
78084: LD_ADDR_VAR 0 10
78088: PUSH
78089: LD_VAR 0 14
78093: PUSH
78094: LD_INT 1
78096: ARRAY
78097: PPUSH
78098: CALL_OW 250
78102: ST_TO_ADDR
// y := GetY ( tmp [ 1 ] ) ;
78103: LD_ADDR_VAR 0 11
78107: PUSH
78108: LD_VAR 0 14
78112: PUSH
78113: LD_INT 1
78115: ARRAY
78116: PPUSH
78117: CALL_OW 251
78121: ST_TO_ADDR
// d := ReverseDir ( group [ i ] ) ;
78122: LD_ADDR_VAR 0 12
78126: PUSH
78127: LD_VAR 0 4
78131: PUSH
78132: LD_VAR 0 7
78136: ARRAY
78137: PPUSH
78138: CALL 73997 0 1
78142: ST_TO_ADDR
// ComPlaceDelayedCharge ( group [ i ] , x , y , tmp [ 1 ] ) ;
78143: LD_VAR 0 4
78147: PUSH
78148: LD_VAR 0 7
78152: ARRAY
78153: PPUSH
78154: LD_VAR 0 10
78158: PPUSH
78159: LD_VAR 0 11
78163: PPUSH
78164: LD_VAR 0 14
78168: PUSH
78169: LD_INT 1
78171: ARRAY
78172: PPUSH
78173: CALL_OW 132
// AddComMoveXY ( group [ i ] , ShiftX ( x , d , 7 ) , ShiftY ( y , d , 7 ) ) ;
78177: LD_VAR 0 4
78181: PUSH
78182: LD_VAR 0 7
78186: ARRAY
78187: PPUSH
78188: LD_VAR 0 10
78192: PPUSH
78193: LD_VAR 0 12
78197: PPUSH
78198: LD_INT 7
78200: PPUSH
78201: CALL_OW 272
78205: PPUSH
78206: LD_VAR 0 11
78210: PPUSH
78211: LD_VAR 0 12
78215: PPUSH
78216: LD_INT 7
78218: PPUSH
78219: CALL_OW 273
78223: PPUSH
78224: CALL_OW 171
// SetTag ( group [ i ] , 71 ) ;
78228: LD_VAR 0 4
78232: PUSH
78233: LD_VAR 0 7
78237: ARRAY
78238: PPUSH
78239: LD_INT 71
78241: PPUSH
78242: CALL_OW 109
// mined := Replace ( mined , mined + 1 , tmp [ 1 ] ) ;
78246: LD_ADDR_VAR 0 27
78250: PUSH
78251: LD_VAR 0 27
78255: PPUSH
78256: LD_VAR 0 27
78260: PUSH
78261: LD_INT 1
78263: PLUS
78264: PPUSH
78265: LD_VAR 0 14
78269: PUSH
78270: LD_INT 1
78272: ARRAY
78273: PPUSH
78274: CALL_OW 1
78278: ST_TO_ADDR
// attacking := true ;
78279: LD_ADDR_VAR 0 29
78283: PUSH
78284: LD_INT 1
78286: ST_TO_ADDR
// continue ;
78287: GO 76134
// end ; end ; end ; if GetClass ( group [ i ] ) = 17 and not GetTag ( group [ i ] ) = 71 then
78289: LD_VAR 0 4
78293: PUSH
78294: LD_VAR 0 7
78298: ARRAY
78299: PPUSH
78300: CALL_OW 257
78304: PUSH
78305: LD_INT 17
78307: EQUAL
78308: PUSH
78309: LD_VAR 0 4
78313: PUSH
78314: LD_VAR 0 7
78318: ARRAY
78319: PPUSH
78320: CALL_OW 110
78324: PUSH
78325: LD_INT 71
78327: EQUAL
78328: NOT
78329: AND
78330: IFFALSE 78476
// begin attacking := false ;
78332: LD_ADDR_VAR 0 29
78336: PUSH
78337: LD_INT 0
78339: ST_TO_ADDR
// k := 5 ;
78340: LD_ADDR_VAR 0 9
78344: PUSH
78345: LD_INT 5
78347: ST_TO_ADDR
// if tmp < k then
78348: LD_VAR 0 14
78352: PUSH
78353: LD_VAR 0 9
78357: LESS
78358: IFFALSE 78370
// k := tmp ;
78360: LD_ADDR_VAR 0 9
78364: PUSH
78365: LD_VAR 0 14
78369: ST_TO_ADDR
// for j = 1 to k do
78370: LD_ADDR_VAR 0 8
78374: PUSH
78375: DOUBLE
78376: LD_INT 1
78378: DEC
78379: ST_TO_ADDR
78380: LD_VAR 0 9
78384: PUSH
78385: FOR_TO
78386: IFFALSE 78474
// begin if not tmp [ j ] in UnitFilter ( tmp , [ f_empty ] ) then
78388: LD_VAR 0 14
78392: PUSH
78393: LD_VAR 0 8
78397: ARRAY
78398: PUSH
78399: LD_VAR 0 14
78403: PPUSH
78404: LD_INT 58
78406: PUSH
78407: EMPTY
78408: LIST
78409: PPUSH
78410: CALL_OW 72
78414: IN
78415: NOT
78416: IFFALSE 78472
// begin ComAttackUnit ( group [ i ] , tmp [ j ] ) ;
78418: LD_VAR 0 4
78422: PUSH
78423: LD_VAR 0 7
78427: ARRAY
78428: PPUSH
78429: LD_VAR 0 14
78433: PUSH
78434: LD_VAR 0 8
78438: ARRAY
78439: PPUSH
78440: CALL_OW 115
// attacking := true ;
78444: LD_ADDR_VAR 0 29
78448: PUSH
78449: LD_INT 1
78451: ST_TO_ADDR
// SetTag ( group [ i ] , 71 ) ;
78452: LD_VAR 0 4
78456: PUSH
78457: LD_VAR 0 7
78461: ARRAY
78462: PPUSH
78463: LD_INT 71
78465: PPUSH
78466: CALL_OW 109
// continue ;
78470: GO 78385
// end ; end ;
78472: GO 78385
78474: POP
78475: POP
// end ; if GetClass ( group [ i ] ) = 8 or GetWeapon ( group [ i ] ) in [ ar_rocket_launcher , ru_rocket_launcher , us_rocket_launcher , ru_rocket ] then
78476: LD_VAR 0 4
78480: PUSH
78481: LD_VAR 0 7
78485: ARRAY
78486: PPUSH
78487: CALL_OW 257
78491: PUSH
78492: LD_INT 8
78494: EQUAL
78495: PUSH
78496: LD_VAR 0 4
78500: PUSH
78501: LD_VAR 0 7
78505: ARRAY
78506: PPUSH
78507: CALL_OW 264
78511: PUSH
78512: LD_INT 28
78514: PUSH
78515: LD_INT 45
78517: PUSH
78518: LD_INT 7
78520: PUSH
78521: LD_INT 47
78523: PUSH
78524: EMPTY
78525: LIST
78526: LIST
78527: LIST
78528: LIST
78529: IN
78530: OR
78531: IFFALSE 78761
// begin attacking := false ;
78533: LD_ADDR_VAR 0 29
78537: PUSH
78538: LD_INT 0
78540: ST_TO_ADDR
// if GetBType ( tmp [ 1 ] ) in [ b_bunker , b_breastwork , b_turret , b_armoury , b_barracks ] then
78541: LD_VAR 0 14
78545: PUSH
78546: LD_INT 1
78548: ARRAY
78549: PPUSH
78550: CALL_OW 266
78554: PUSH
78555: LD_INT 32
78557: PUSH
78558: LD_INT 31
78560: PUSH
78561: LD_INT 33
78563: PUSH
78564: LD_INT 4
78566: PUSH
78567: LD_INT 5
78569: PUSH
78570: EMPTY
78571: LIST
78572: LIST
78573: LIST
78574: LIST
78575: LIST
78576: IN
78577: IFFALSE 78761
// begin k := GetBuildingHexes ( GetBType ( tmp [ 1 ] ) , GetX ( tmp [ 1 ] ) , GetY ( tmp [ 1 ] ) , GetDir ( tmp [ 1 ] ) , GetNation ( tmp [ 1 ] ) , 0 ) ;
78579: LD_ADDR_VAR 0 9
78583: PUSH
78584: LD_VAR 0 14
78588: PUSH
78589: LD_INT 1
78591: ARRAY
78592: PPUSH
78593: CALL_OW 266
78597: PPUSH
78598: LD_VAR 0 14
78602: PUSH
78603: LD_INT 1
78605: ARRAY
78606: PPUSH
78607: CALL_OW 250
78611: PPUSH
78612: LD_VAR 0 14
78616: PUSH
78617: LD_INT 1
78619: ARRAY
78620: PPUSH
78621: CALL_OW 251
78625: PPUSH
78626: LD_VAR 0 14
78630: PUSH
78631: LD_INT 1
78633: ARRAY
78634: PPUSH
78635: CALL_OW 254
78639: PPUSH
78640: LD_VAR 0 14
78644: PUSH
78645: LD_INT 1
78647: ARRAY
78648: PPUSH
78649: CALL_OW 248
78653: PPUSH
78654: LD_INT 0
78656: PPUSH
78657: CALL 55367 0 6
78661: ST_TO_ADDR
// j := GetClosestHex ( group [ i ] , k ) ;
78662: LD_ADDR_VAR 0 8
78666: PUSH
78667: LD_VAR 0 4
78671: PUSH
78672: LD_VAR 0 7
78676: ARRAY
78677: PPUSH
78678: LD_VAR 0 9
78682: PPUSH
78683: CALL 74060 0 2
78687: ST_TO_ADDR
// if j then
78688: LD_VAR 0 8
78692: IFFALSE 78761
// if ValidHex ( j [ 1 ] , j [ 2 ] ) then
78694: LD_VAR 0 8
78698: PUSH
78699: LD_INT 1
78701: ARRAY
78702: PPUSH
78703: LD_VAR 0 8
78707: PUSH
78708: LD_INT 2
78710: ARRAY
78711: PPUSH
78712: CALL_OW 488
78716: IFFALSE 78761
// begin ComAttackPlace ( group [ i ] , j [ 1 ] , j [ 2 ] ) ;
78718: LD_VAR 0 4
78722: PUSH
78723: LD_VAR 0 7
78727: ARRAY
78728: PPUSH
78729: LD_VAR 0 8
78733: PUSH
78734: LD_INT 1
78736: ARRAY
78737: PPUSH
78738: LD_VAR 0 8
78742: PUSH
78743: LD_INT 2
78745: ARRAY
78746: PPUSH
78747: CALL_OW 116
// attacking := true ;
78751: LD_ADDR_VAR 0 29
78755: PUSH
78756: LD_INT 1
78758: ST_TO_ADDR
// continue ;
78759: GO 76134
// end ; end ; end ; if GetChassis ( group [ i ] ) = ar_hovercraft then
78761: LD_VAR 0 4
78765: PUSH
78766: LD_VAR 0 7
78770: ARRAY
78771: PPUSH
78772: CALL_OW 265
78776: PUSH
78777: LD_INT 11
78779: EQUAL
78780: IFFALSE 79058
// begin k := 10 ;
78782: LD_ADDR_VAR 0 9
78786: PUSH
78787: LD_INT 10
78789: ST_TO_ADDR
// x := 0 ;
78790: LD_ADDR_VAR 0 10
78794: PUSH
78795: LD_INT 0
78797: ST_TO_ADDR
// if tmp < k then
78798: LD_VAR 0 14
78802: PUSH
78803: LD_VAR 0 9
78807: LESS
78808: IFFALSE 78820
// k := tmp ;
78810: LD_ADDR_VAR 0 9
78814: PUSH
78815: LD_VAR 0 14
78819: ST_TO_ADDR
// for j = k downto 1 do
78820: LD_ADDR_VAR 0 8
78824: PUSH
78825: DOUBLE
78826: LD_VAR 0 9
78830: INC
78831: ST_TO_ADDR
78832: LD_INT 1
78834: PUSH
78835: FOR_DOWNTO
78836: IFFALSE 78911
// begin if GetType ( tmp [ j ] ) = unit_human then
78838: LD_VAR 0 14
78842: PUSH
78843: LD_VAR 0 8
78847: ARRAY
78848: PPUSH
78849: CALL_OW 247
78853: PUSH
78854: LD_INT 1
78856: EQUAL
78857: IFFALSE 78909
// begin AttackHovercraft ( group [ i ] , tmp [ j ] ) ;
78859: LD_VAR 0 4
78863: PUSH
78864: LD_VAR 0 7
78868: ARRAY
78869: PPUSH
78870: LD_VAR 0 14
78874: PUSH
78875: LD_VAR 0 8
78879: ARRAY
78880: PPUSH
78881: CALL 74331 0 2
// x := tmp [ j ] ;
78885: LD_ADDR_VAR 0 10
78889: PUSH
78890: LD_VAR 0 14
78894: PUSH
78895: LD_VAR 0 8
78899: ARRAY
78900: ST_TO_ADDR
// attacking := true ;
78901: LD_ADDR_VAR 0 29
78905: PUSH
78906: LD_INT 1
78908: ST_TO_ADDR
// end ; end ;
78909: GO 78835
78911: POP
78912: POP
// if not x then
78913: LD_VAR 0 10
78917: NOT
78918: IFFALSE 79058
// begin attacking := true ;
78920: LD_ADDR_VAR 0 29
78924: PUSH
78925: LD_INT 1
78927: ST_TO_ADDR
// if GetHexInfo ( GetX ( group [ i ] ) , GetY ( group [ i ] ) ) [ 2 ] = GetHexInfo ( GetX ( tmp [ 1 ] ) , GetY ( tmp [ 1 ] ) ) [ 2 ] then
78928: LD_VAR 0 4
78932: PUSH
78933: LD_VAR 0 7
78937: ARRAY
78938: PPUSH
78939: CALL_OW 250
78943: PPUSH
78944: LD_VAR 0 4
78948: PUSH
78949: LD_VAR 0 7
78953: ARRAY
78954: PPUSH
78955: CALL_OW 251
78959: PPUSH
78960: CALL_OW 546
78964: PUSH
78965: LD_INT 2
78967: ARRAY
78968: PUSH
78969: LD_VAR 0 14
78973: PUSH
78974: LD_INT 1
78976: ARRAY
78977: PPUSH
78978: CALL_OW 250
78982: PPUSH
78983: LD_VAR 0 14
78987: PUSH
78988: LD_INT 1
78990: ARRAY
78991: PPUSH
78992: CALL_OW 251
78996: PPUSH
78997: CALL_OW 546
79001: PUSH
79002: LD_INT 2
79004: ARRAY
79005: EQUAL
79006: IFFALSE 79034
// AttackHovercraft ( group [ i ] , tmp [ 1 ] ) else
79008: LD_VAR 0 4
79012: PUSH
79013: LD_VAR 0 7
79017: ARRAY
79018: PPUSH
79019: LD_VAR 0 14
79023: PUSH
79024: LD_INT 1
79026: ARRAY
79027: PPUSH
79028: CALL 74331 0 2
79032: GO 79058
// ComAttackUnit ( group [ i ] , tmp [ 1 ] ) ;
79034: LD_VAR 0 4
79038: PUSH
79039: LD_VAR 0 7
79043: ARRAY
79044: PPUSH
79045: LD_VAR 0 14
79049: PUSH
79050: LD_INT 1
79052: ARRAY
79053: PPUSH
79054: CALL_OW 115
// end ; end ; if GetWeapon ( group [ i ] ) = ar_selfpropelled_bomb then
79058: LD_VAR 0 4
79062: PUSH
79063: LD_VAR 0 7
79067: ARRAY
79068: PPUSH
79069: CALL_OW 264
79073: PUSH
79074: LD_INT 29
79076: EQUAL
79077: IFFALSE 79443
// begin if WantsToAttack ( group [ i ] ) in bombed then
79079: LD_VAR 0 4
79083: PUSH
79084: LD_VAR 0 7
79088: ARRAY
79089: PPUSH
79090: CALL_OW 319
79094: PUSH
79095: LD_VAR 0 28
79099: IN
79100: IFFALSE 79104
// continue ;
79102: GO 76134
// k := 8 ;
79104: LD_ADDR_VAR 0 9
79108: PUSH
79109: LD_INT 8
79111: ST_TO_ADDR
// x := 0 ;
79112: LD_ADDR_VAR 0 10
79116: PUSH
79117: LD_INT 0
79119: ST_TO_ADDR
// if tmp < k then
79120: LD_VAR 0 14
79124: PUSH
79125: LD_VAR 0 9
79129: LESS
79130: IFFALSE 79142
// k := tmp ;
79132: LD_ADDR_VAR 0 9
79136: PUSH
79137: LD_VAR 0 14
79141: ST_TO_ADDR
// for j = 1 to k do
79142: LD_ADDR_VAR 0 8
79146: PUSH
79147: DOUBLE
79148: LD_INT 1
79150: DEC
79151: ST_TO_ADDR
79152: LD_VAR 0 9
79156: PUSH
79157: FOR_TO
79158: IFFALSE 79290
// begin if GetType ( tmp [ j ] ) = unit_building then
79160: LD_VAR 0 14
79164: PUSH
79165: LD_VAR 0 8
79169: ARRAY
79170: PPUSH
79171: CALL_OW 247
79175: PUSH
79176: LD_INT 3
79178: EQUAL
79179: IFFALSE 79288
// if not tmp [ j ] in bombed and UnitsInside ( tmp [ j ] ) then
79181: LD_VAR 0 14
79185: PUSH
79186: LD_VAR 0 8
79190: ARRAY
79191: PUSH
79192: LD_VAR 0 28
79196: IN
79197: NOT
79198: PUSH
79199: LD_VAR 0 14
79203: PUSH
79204: LD_VAR 0 8
79208: ARRAY
79209: PPUSH
79210: CALL_OW 313
79214: AND
79215: IFFALSE 79288
// begin ComAttackUnit ( group [ i ] , tmp [ j ] ) ;
79217: LD_VAR 0 4
79221: PUSH
79222: LD_VAR 0 7
79226: ARRAY
79227: PPUSH
79228: LD_VAR 0 14
79232: PUSH
79233: LD_VAR 0 8
79237: ARRAY
79238: PPUSH
79239: CALL_OW 115
// bombed := Replace ( bombed , bombed + 1 , tmp [ j ] ) ;
79243: LD_ADDR_VAR 0 28
79247: PUSH
79248: LD_VAR 0 28
79252: PPUSH
79253: LD_VAR 0 28
79257: PUSH
79258: LD_INT 1
79260: PLUS
79261: PPUSH
79262: LD_VAR 0 14
79266: PUSH
79267: LD_VAR 0 8
79271: ARRAY
79272: PPUSH
79273: CALL_OW 1
79277: ST_TO_ADDR
// attacking := true ;
79278: LD_ADDR_VAR 0 29
79282: PUSH
79283: LD_INT 1
79285: ST_TO_ADDR
// break ;
79286: GO 79290
// end ; end ;
79288: GO 79157
79290: POP
79291: POP
// if not attacking and f_attack_depot then
79292: LD_VAR 0 29
79296: NOT
79297: PUSH
79298: LD_VAR 0 25
79302: AND
79303: IFFALSE 79398
// begin z := UnitFilter ( tmp , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) ;
79305: LD_ADDR_VAR 0 13
79309: PUSH
79310: LD_VAR 0 14
79314: PPUSH
79315: LD_INT 2
79317: PUSH
79318: LD_INT 30
79320: PUSH
79321: LD_INT 0
79323: PUSH
79324: EMPTY
79325: LIST
79326: LIST
79327: PUSH
79328: LD_INT 30
79330: PUSH
79331: LD_INT 1
79333: PUSH
79334: EMPTY
79335: LIST
79336: LIST
79337: PUSH
79338: EMPTY
79339: LIST
79340: LIST
79341: LIST
79342: PPUSH
79343: CALL_OW 72
79347: ST_TO_ADDR
// if z then
79348: LD_VAR 0 13
79352: IFFALSE 79398
// begin ComAttackUnit ( group [ i ] , NearestUnitToUnit ( z , group [ i ] ) ) ;
79354: LD_VAR 0 4
79358: PUSH
79359: LD_VAR 0 7
79363: ARRAY
79364: PPUSH
79365: LD_VAR 0 13
79369: PPUSH
79370: LD_VAR 0 4
79374: PUSH
79375: LD_VAR 0 7
79379: ARRAY
79380: PPUSH
79381: CALL_OW 74
79385: PPUSH
79386: CALL_OW 115
// attacking := true ;
79390: LD_ADDR_VAR 0 29
79394: PUSH
79395: LD_INT 1
79397: ST_TO_ADDR
// end ; end ; if GetLives ( group [ i ] ) < 500 then
79398: LD_VAR 0 4
79402: PUSH
79403: LD_VAR 0 7
79407: ARRAY
79408: PPUSH
79409: CALL_OW 256
79413: PUSH
79414: LD_INT 500
79416: LESS
79417: IFFALSE 79443
// ComAttackUnit ( group [ i ] , tmp [ 1 ] ) ;
79419: LD_VAR 0 4
79423: PUSH
79424: LD_VAR 0 7
79428: ARRAY
79429: PPUSH
79430: LD_VAR 0 14
79434: PUSH
79435: LD_INT 1
79437: ARRAY
79438: PPUSH
79439: CALL_OW 115
// end ; if GetWeapon ( group [ i ] ) = ru_time_lapser then
79443: LD_VAR 0 4
79447: PUSH
79448: LD_VAR 0 7
79452: ARRAY
79453: PPUSH
79454: CALL_OW 264
79458: PUSH
79459: LD_INT 49
79461: EQUAL
79462: IFFALSE 79583
// begin if not HasTask ( group [ i ] ) then
79464: LD_VAR 0 4
79468: PUSH
79469: LD_VAR 0 7
79473: ARRAY
79474: PPUSH
79475: CALL_OW 314
79479: NOT
79480: IFFALSE 79583
// begin k := NearestUnitToUnit ( FilterAllUnits ( [ f_enemy , GetSide ( group [ i ] ) ] ) , group [ i ] ) ;
79482: LD_ADDR_VAR 0 9
79486: PUSH
79487: LD_INT 81
79489: PUSH
79490: LD_VAR 0 4
79494: PUSH
79495: LD_VAR 0 7
79499: ARRAY
79500: PPUSH
79501: CALL_OW 255
79505: PUSH
79506: EMPTY
79507: LIST
79508: LIST
79509: PPUSH
79510: CALL_OW 69
79514: PPUSH
79515: LD_VAR 0 4
79519: PUSH
79520: LD_VAR 0 7
79524: ARRAY
79525: PPUSH
79526: CALL_OW 74
79530: ST_TO_ADDR
// if k then
79531: LD_VAR 0 9
79535: IFFALSE 79583
// if GetDistUnits ( group [ i ] , k ) > 10 then
79537: LD_VAR 0 4
79541: PUSH
79542: LD_VAR 0 7
79546: ARRAY
79547: PPUSH
79548: LD_VAR 0 9
79552: PPUSH
79553: CALL_OW 296
79557: PUSH
79558: LD_INT 10
79560: GREATER
79561: IFFALSE 79583
// ComMoveUnit ( group [ i ] , k ) ;
79563: LD_VAR 0 4
79567: PUSH
79568: LD_VAR 0 7
79572: ARRAY
79573: PPUSH
79574: LD_VAR 0 9
79578: PPUSH
79579: CALL_OW 112
// end ; end ; if GetLives ( group [ i ] ) < 250 and group [ i ] in FilterAllUnits ( [ [ f_type , unit_vehicle ] , [ f_nation , 2 ] ] ) then
79583: LD_VAR 0 4
79587: PUSH
79588: LD_VAR 0 7
79592: ARRAY
79593: PPUSH
79594: CALL_OW 256
79598: PUSH
79599: LD_INT 250
79601: LESS
79602: PUSH
79603: LD_VAR 0 4
79607: PUSH
79608: LD_VAR 0 7
79612: ARRAY
79613: PUSH
79614: LD_INT 21
79616: PUSH
79617: LD_INT 2
79619: PUSH
79620: EMPTY
79621: LIST
79622: LIST
79623: PUSH
79624: LD_INT 23
79626: PUSH
79627: LD_INT 2
79629: PUSH
79630: EMPTY
79631: LIST
79632: LIST
79633: PUSH
79634: EMPTY
79635: LIST
79636: LIST
79637: PPUSH
79638: CALL_OW 69
79642: IN
79643: AND
79644: IFFALSE 79769
// begin k := NearestUnitToUnit ( all_units diff group [ i ] , group [ i ] ) ;
79646: LD_ADDR_VAR 0 9
79650: PUSH
79651: LD_OWVAR 3
79655: PUSH
79656: LD_VAR 0 4
79660: PUSH
79661: LD_VAR 0 7
79665: ARRAY
79666: DIFF
79667: PPUSH
79668: LD_VAR 0 4
79672: PUSH
79673: LD_VAR 0 7
79677: ARRAY
79678: PPUSH
79679: CALL_OW 74
79683: ST_TO_ADDR
// if not k then
79684: LD_VAR 0 9
79688: NOT
79689: IFFALSE 79693
// continue ;
79691: GO 76134
// if k in FilterAllUnits ( [ f_enemy , GetSide ( group [ i ] ) ] ) and GetDistUnits ( k , group [ i ] ) < 5 then
79693: LD_VAR 0 9
79697: PUSH
79698: LD_INT 81
79700: PUSH
79701: LD_VAR 0 4
79705: PUSH
79706: LD_VAR 0 7
79710: ARRAY
79711: PPUSH
79712: CALL_OW 255
79716: PUSH
79717: EMPTY
79718: LIST
79719: LIST
79720: PPUSH
79721: CALL_OW 69
79725: IN
79726: PUSH
79727: LD_VAR 0 9
79731: PPUSH
79732: LD_VAR 0 4
79736: PUSH
79737: LD_VAR 0 7
79741: ARRAY
79742: PPUSH
79743: CALL_OW 296
79747: PUSH
79748: LD_INT 5
79750: LESS
79751: AND
79752: IFFALSE 79769
// ComAutodestruct ( group [ i ] ) ;
79754: LD_VAR 0 4
79758: PUSH
79759: LD_VAR 0 7
79763: ARRAY
79764: PPUSH
79765: CALL 74229 0 1
// end ; if f_attack_depot then
79769: LD_VAR 0 25
79773: IFFALSE 79885
// begin k := 6 ;
79775: LD_ADDR_VAR 0 9
79779: PUSH
79780: LD_INT 6
79782: ST_TO_ADDR
// if tmp < k then
79783: LD_VAR 0 14
79787: PUSH
79788: LD_VAR 0 9
79792: LESS
79793: IFFALSE 79805
// k := tmp ;
79795: LD_ADDR_VAR 0 9
79799: PUSH
79800: LD_VAR 0 14
79804: ST_TO_ADDR
// for j = 1 to k do
79805: LD_ADDR_VAR 0 8
79809: PUSH
79810: DOUBLE
79811: LD_INT 1
79813: DEC
79814: ST_TO_ADDR
79815: LD_VAR 0 9
79819: PUSH
79820: FOR_TO
79821: IFFALSE 79883
// if GetBType ( j ) in [ b_depot , b_warehouse ] then
79823: LD_VAR 0 8
79827: PPUSH
79828: CALL_OW 266
79832: PUSH
79833: LD_INT 0
79835: PUSH
79836: LD_INT 1
79838: PUSH
79839: EMPTY
79840: LIST
79841: LIST
79842: IN
79843: IFFALSE 79881
// begin ComAttackUnit ( group [ i ] , tmp [ j ] ) ;
79845: LD_VAR 0 4
79849: PUSH
79850: LD_VAR 0 7
79854: ARRAY
79855: PPUSH
79856: LD_VAR 0 14
79860: PUSH
79861: LD_VAR 0 8
79865: ARRAY
79866: PPUSH
79867: CALL_OW 115
// attacking := true ;
79871: LD_ADDR_VAR 0 29
79875: PUSH
79876: LD_INT 1
79878: ST_TO_ADDR
// break ;
79879: GO 79883
// end ;
79881: GO 79820
79883: POP
79884: POP
// end ; if IsOk ( group [ i ] ) and not attacking then
79885: LD_VAR 0 4
79889: PUSH
79890: LD_VAR 0 7
79894: ARRAY
79895: PPUSH
79896: CALL_OW 302
79900: PUSH
79901: LD_VAR 0 29
79905: NOT
79906: AND
79907: IFFALSE 80229
// begin if GetTag ( group [ i ] ) = 71 then
79909: LD_VAR 0 4
79913: PUSH
79914: LD_VAR 0 7
79918: ARRAY
79919: PPUSH
79920: CALL_OW 110
79924: PUSH
79925: LD_INT 71
79927: EQUAL
79928: IFFALSE 79969
// begin if HasTask ( group [ i ] ) then
79930: LD_VAR 0 4
79934: PUSH
79935: LD_VAR 0 7
79939: ARRAY
79940: PPUSH
79941: CALL_OW 314
79945: IFFALSE 79951
// continue else
79947: GO 76134
79949: GO 79969
// SetTag ( group [ i ] , 0 ) ;
79951: LD_VAR 0 4
79955: PUSH
79956: LD_VAR 0 7
79960: ARRAY
79961: PPUSH
79962: LD_INT 0
79964: PPUSH
79965: CALL_OW 109
// end ; k := 8 ;
79969: LD_ADDR_VAR 0 9
79973: PUSH
79974: LD_INT 8
79976: ST_TO_ADDR
// x := 0 ;
79977: LD_ADDR_VAR 0 10
79981: PUSH
79982: LD_INT 0
79984: ST_TO_ADDR
// if tmp < k then
79985: LD_VAR 0 14
79989: PUSH
79990: LD_VAR 0 9
79994: LESS
79995: IFFALSE 80007
// k := tmp ;
79997: LD_ADDR_VAR 0 9
80001: PUSH
80002: LD_VAR 0 14
80006: ST_TO_ADDR
// for j = 1 to k do
80007: LD_ADDR_VAR 0 8
80011: PUSH
80012: DOUBLE
80013: LD_INT 1
80015: DEC
80016: ST_TO_ADDR
80017: LD_VAR 0 9
80021: PUSH
80022: FOR_TO
80023: IFFALSE 80121
// if GetType ( tmp [ j ] ) = unit_human and ( ( GetLives ( tmp [ j ] ) < 250 and f_murder ) or ( not f_murder and GetLives ( tmp [ j ] ) >= 250 ) ) then
80025: LD_VAR 0 14
80029: PUSH
80030: LD_VAR 0 8
80034: ARRAY
80035: PPUSH
80036: CALL_OW 247
80040: PUSH
80041: LD_INT 1
80043: EQUAL
80044: PUSH
80045: LD_VAR 0 14
80049: PUSH
80050: LD_VAR 0 8
80054: ARRAY
80055: PPUSH
80056: CALL_OW 256
80060: PUSH
80061: LD_INT 250
80063: LESS
80064: PUSH
80065: LD_VAR 0 20
80069: AND
80070: PUSH
80071: LD_VAR 0 20
80075: NOT
80076: PUSH
80077: LD_VAR 0 14
80081: PUSH
80082: LD_VAR 0 8
80086: ARRAY
80087: PPUSH
80088: CALL_OW 256
80092: PUSH
80093: LD_INT 250
80095: GREATEREQUAL
80096: AND
80097: OR
80098: AND
80099: IFFALSE 80119
// begin x := tmp [ j ] ;
80101: LD_ADDR_VAR 0 10
80105: PUSH
80106: LD_VAR 0 14
80110: PUSH
80111: LD_VAR 0 8
80115: ARRAY
80116: ST_TO_ADDR
// break ;
80117: GO 80121
// end ;
80119: GO 80022
80121: POP
80122: POP
// if x then
80123: LD_VAR 0 10
80127: IFFALSE 80151
// ComAttackUnit ( group [ i ] , x ) else
80129: LD_VAR 0 4
80133: PUSH
80134: LD_VAR 0 7
80138: ARRAY
80139: PPUSH
80140: LD_VAR 0 10
80144: PPUSH
80145: CALL_OW 115
80149: GO 80175
// ComAttackUnit ( group [ i ] , tmp [ 1 ] ) ;
80151: LD_VAR 0 4
80155: PUSH
80156: LD_VAR 0 7
80160: ARRAY
80161: PPUSH
80162: LD_VAR 0 14
80166: PUSH
80167: LD_INT 1
80169: ARRAY
80170: PPUSH
80171: CALL_OW 115
// if not HasTask ( group [ i ] ) then
80175: LD_VAR 0 4
80179: PUSH
80180: LD_VAR 0 7
80184: ARRAY
80185: PPUSH
80186: CALL_OW 314
80190: NOT
80191: IFFALSE 80229
// ComAttackUnit ( group [ i ] , NearestUnitToUnit ( tmp , group [ i ] ) ) ;
80193: LD_VAR 0 4
80197: PUSH
80198: LD_VAR 0 7
80202: ARRAY
80203: PPUSH
80204: LD_VAR 0 14
80208: PPUSH
80209: LD_VAR 0 4
80213: PUSH
80214: LD_VAR 0 7
80218: ARRAY
80219: PPUSH
80220: CALL_OW 74
80224: PPUSH
80225: CALL_OW 115
// end ; end ; end ;
80229: GO 76134
80231: POP
80232: POP
// wait ( 0 0$1 ) ;
80233: LD_INT 35
80235: PPUSH
80236: CALL_OW 67
// until group = [ ] or not FilterAllUnits ( [ f_enemy , side ] ) ;
80240: LD_VAR 0 4
80244: PUSH
80245: EMPTY
80246: EQUAL
80247: PUSH
80248: LD_INT 81
80250: PUSH
80251: LD_VAR 0 35
80255: PUSH
80256: EMPTY
80257: LIST
80258: LIST
80259: PPUSH
80260: CALL_OW 69
80264: NOT
80265: OR
80266: IFFALSE 76119
// end ;
80268: LD_VAR 0 2
80272: RET
// export function _ScanBase ( base_units ) ; var i , t , tmp ; begin
80273: LD_INT 0
80275: PPUSH
80276: PPUSH
80277: PPUSH
80278: PPUSH
// if not base_units then
80279: LD_VAR 0 1
80283: NOT
80284: IFFALSE 80288
// exit ;
80286: GO 80375
// result := false ;
80288: LD_ADDR_VAR 0 2
80292: PUSH
80293: LD_INT 0
80295: ST_TO_ADDR
// tmp := UnitFilter ( base_units , [ f_type , unit_building ] ) ;
80296: LD_ADDR_VAR 0 5
80300: PUSH
80301: LD_VAR 0 1
80305: PPUSH
80306: LD_INT 21
80308: PUSH
80309: LD_INT 3
80311: PUSH
80312: EMPTY
80313: LIST
80314: LIST
80315: PPUSH
80316: CALL_OW 72
80320: ST_TO_ADDR
// if not tmp then
80321: LD_VAR 0 5
80325: NOT
80326: IFFALSE 80330
// exit ;
80328: GO 80375
// for i in tmp do
80330: LD_ADDR_VAR 0 3
80334: PUSH
80335: LD_VAR 0 5
80339: PUSH
80340: FOR_IN
80341: IFFALSE 80373
// begin result := EnemyInRange ( i , 22 ) ;
80343: LD_ADDR_VAR 0 2
80347: PUSH
80348: LD_VAR 0 3
80352: PPUSH
80353: LD_INT 22
80355: PPUSH
80356: CALL 73912 0 2
80360: ST_TO_ADDR
// if result then
80361: LD_VAR 0 2
80365: IFFALSE 80371
// exit ;
80367: POP
80368: POP
80369: GO 80375
// end ;
80371: GO 80340
80373: POP
80374: POP
// end ;
80375: LD_VAR 0 2
80379: RET
// export function FilterByTag ( units , tag ) ; var i ; begin
80380: LD_INT 0
80382: PPUSH
80383: PPUSH
// if not units then
80384: LD_VAR 0 1
80388: NOT
80389: IFFALSE 80393
// exit ;
80391: GO 80463
// result := [ ] ;
80393: LD_ADDR_VAR 0 3
80397: PUSH
80398: EMPTY
80399: ST_TO_ADDR
// for i in units do
80400: LD_ADDR_VAR 0 4
80404: PUSH
80405: LD_VAR 0 1
80409: PUSH
80410: FOR_IN
80411: IFFALSE 80461
// if GetTag ( i ) = tag then
80413: LD_VAR 0 4
80417: PPUSH
80418: CALL_OW 110
80422: PUSH
80423: LD_VAR 0 2
80427: EQUAL
80428: IFFALSE 80459
// result := Insert ( result , result + 1 , i ) ;
80430: LD_ADDR_VAR 0 3
80434: PUSH
80435: LD_VAR 0 3
80439: PPUSH
80440: LD_VAR 0 3
80444: PUSH
80445: LD_INT 1
80447: PLUS
80448: PPUSH
80449: LD_VAR 0 4
80453: PPUSH
80454: CALL_OW 2
80458: ST_TO_ADDR
80459: GO 80410
80461: POP
80462: POP
// end ;
80463: LD_VAR 0 3
80467: RET
// export function IsDriver ( un ) ; begin
80468: LD_INT 0
80470: PPUSH
// result := un in FilterAllUnits ( [ f_driving ] ) ;
80471: LD_ADDR_VAR 0 2
80475: PUSH
80476: LD_VAR 0 1
80480: PUSH
80481: LD_INT 55
80483: PUSH
80484: EMPTY
80485: LIST
80486: PPUSH
80487: CALL_OW 69
80491: IN
80492: ST_TO_ADDR
// end ;
80493: LD_VAR 0 2
80497: RET
// export function GetFacExtXYD ( x , y , d ) ; var list ; begin
80498: LD_INT 0
80500: PPUSH
80501: PPUSH
// list := [ ] ;
80502: LD_ADDR_VAR 0 5
80506: PUSH
80507: EMPTY
80508: ST_TO_ADDR
// case d of 0 :
80509: LD_VAR 0 3
80513: PUSH
80514: LD_INT 0
80516: DOUBLE
80517: EQUAL
80518: IFTRUE 80522
80520: GO 80655
80522: POP
// begin list := [ [ x - 4 , y - 4 , 2 ] , [ x - 3 , y , 1 ] , [ x + 4 , y , 4 ] , [ x + 3 , y + 3 , 5 ] , [ x , y + 4 , 0 ] ] ;
80523: LD_ADDR_VAR 0 5
80527: PUSH
80528: LD_VAR 0 1
80532: PUSH
80533: LD_INT 4
80535: MINUS
80536: PUSH
80537: LD_VAR 0 2
80541: PUSH
80542: LD_INT 4
80544: MINUS
80545: PUSH
80546: LD_INT 2
80548: PUSH
80549: EMPTY
80550: LIST
80551: LIST
80552: LIST
80553: PUSH
80554: LD_VAR 0 1
80558: PUSH
80559: LD_INT 3
80561: MINUS
80562: PUSH
80563: LD_VAR 0 2
80567: PUSH
80568: LD_INT 1
80570: PUSH
80571: EMPTY
80572: LIST
80573: LIST
80574: LIST
80575: PUSH
80576: LD_VAR 0 1
80580: PUSH
80581: LD_INT 4
80583: PLUS
80584: PUSH
80585: LD_VAR 0 2
80589: PUSH
80590: LD_INT 4
80592: PUSH
80593: EMPTY
80594: LIST
80595: LIST
80596: LIST
80597: PUSH
80598: LD_VAR 0 1
80602: PUSH
80603: LD_INT 3
80605: PLUS
80606: PUSH
80607: LD_VAR 0 2
80611: PUSH
80612: LD_INT 3
80614: PLUS
80615: PUSH
80616: LD_INT 5
80618: PUSH
80619: EMPTY
80620: LIST
80621: LIST
80622: LIST
80623: PUSH
80624: LD_VAR 0 1
80628: PUSH
80629: LD_VAR 0 2
80633: PUSH
80634: LD_INT 4
80636: PLUS
80637: PUSH
80638: LD_INT 0
80640: PUSH
80641: EMPTY
80642: LIST
80643: LIST
80644: LIST
80645: PUSH
80646: EMPTY
80647: LIST
80648: LIST
80649: LIST
80650: LIST
80651: LIST
80652: ST_TO_ADDR
// end ; 1 :
80653: GO 81353
80655: LD_INT 1
80657: DOUBLE
80658: EQUAL
80659: IFTRUE 80663
80661: GO 80796
80663: POP
// begin list := [ [ x , y - 4 , 3 ] , [ x - 3 , y - 3 , 2 ] , [ x - 4 , y , 1 ] , [ x , y + 3 , 0 ] , [ x + 4 , y + 4 , 5 ] ] ;
80664: LD_ADDR_VAR 0 5
80668: PUSH
80669: LD_VAR 0 1
80673: PUSH
80674: LD_VAR 0 2
80678: PUSH
80679: LD_INT 4
80681: MINUS
80682: PUSH
80683: LD_INT 3
80685: PUSH
80686: EMPTY
80687: LIST
80688: LIST
80689: LIST
80690: PUSH
80691: LD_VAR 0 1
80695: PUSH
80696: LD_INT 3
80698: MINUS
80699: PUSH
80700: LD_VAR 0 2
80704: PUSH
80705: LD_INT 3
80707: MINUS
80708: PUSH
80709: LD_INT 2
80711: PUSH
80712: EMPTY
80713: LIST
80714: LIST
80715: LIST
80716: PUSH
80717: LD_VAR 0 1
80721: PUSH
80722: LD_INT 4
80724: MINUS
80725: PUSH
80726: LD_VAR 0 2
80730: PUSH
80731: LD_INT 1
80733: PUSH
80734: EMPTY
80735: LIST
80736: LIST
80737: LIST
80738: PUSH
80739: LD_VAR 0 1
80743: PUSH
80744: LD_VAR 0 2
80748: PUSH
80749: LD_INT 3
80751: PLUS
80752: PUSH
80753: LD_INT 0
80755: PUSH
80756: EMPTY
80757: LIST
80758: LIST
80759: LIST
80760: PUSH
80761: LD_VAR 0 1
80765: PUSH
80766: LD_INT 4
80768: PLUS
80769: PUSH
80770: LD_VAR 0 2
80774: PUSH
80775: LD_INT 4
80777: PLUS
80778: PUSH
80779: LD_INT 5
80781: PUSH
80782: EMPTY
80783: LIST
80784: LIST
80785: LIST
80786: PUSH
80787: EMPTY
80788: LIST
80789: LIST
80790: LIST
80791: LIST
80792: LIST
80793: ST_TO_ADDR
// end ; 2 :
80794: GO 81353
80796: LD_INT 2
80798: DOUBLE
80799: EQUAL
80800: IFTRUE 80804
80802: GO 80933
80804: POP
// begin list := [ [ x , y - 3 , 3 ] , [ x + 4 , y , 4 ] , [ x , y + 4 , 0 ] , [ x - 3 , y , 1 ] , [ x - 4 , y - 4 , 2 ] ] ;
80805: LD_ADDR_VAR 0 5
80809: PUSH
80810: LD_VAR 0 1
80814: PUSH
80815: LD_VAR 0 2
80819: PUSH
80820: LD_INT 3
80822: MINUS
80823: PUSH
80824: LD_INT 3
80826: PUSH
80827: EMPTY
80828: LIST
80829: LIST
80830: LIST
80831: PUSH
80832: LD_VAR 0 1
80836: PUSH
80837: LD_INT 4
80839: PLUS
80840: PUSH
80841: LD_VAR 0 2
80845: PUSH
80846: LD_INT 4
80848: PUSH
80849: EMPTY
80850: LIST
80851: LIST
80852: LIST
80853: PUSH
80854: LD_VAR 0 1
80858: PUSH
80859: LD_VAR 0 2
80863: PUSH
80864: LD_INT 4
80866: PLUS
80867: PUSH
80868: LD_INT 0
80870: PUSH
80871: EMPTY
80872: LIST
80873: LIST
80874: LIST
80875: PUSH
80876: LD_VAR 0 1
80880: PUSH
80881: LD_INT 3
80883: MINUS
80884: PUSH
80885: LD_VAR 0 2
80889: PUSH
80890: LD_INT 1
80892: PUSH
80893: EMPTY
80894: LIST
80895: LIST
80896: LIST
80897: PUSH
80898: LD_VAR 0 1
80902: PUSH
80903: LD_INT 4
80905: MINUS
80906: PUSH
80907: LD_VAR 0 2
80911: PUSH
80912: LD_INT 4
80914: MINUS
80915: PUSH
80916: LD_INT 2
80918: PUSH
80919: EMPTY
80920: LIST
80921: LIST
80922: LIST
80923: PUSH
80924: EMPTY
80925: LIST
80926: LIST
80927: LIST
80928: LIST
80929: LIST
80930: ST_TO_ADDR
// end ; 3 :
80931: GO 81353
80933: LD_INT 3
80935: DOUBLE
80936: EQUAL
80937: IFTRUE 80941
80939: GO 81074
80941: POP
// begin list := [ [ x + 3 , y , 4 ] , [ x + 4 , y + 4 , 5 ] , [ x - 4 , y , 1 ] , [ x , y - 4 , 3 ] , [ x - 3 , y - 3 , 2 ] ] ;
80942: LD_ADDR_VAR 0 5
80946: PUSH
80947: LD_VAR 0 1
80951: PUSH
80952: LD_INT 3
80954: PLUS
80955: PUSH
80956: LD_VAR 0 2
80960: PUSH
80961: LD_INT 4
80963: PUSH
80964: EMPTY
80965: LIST
80966: LIST
80967: LIST
80968: PUSH
80969: LD_VAR 0 1
80973: PUSH
80974: LD_INT 4
80976: PLUS
80977: PUSH
80978: LD_VAR 0 2
80982: PUSH
80983: LD_INT 4
80985: PLUS
80986: PUSH
80987: LD_INT 5
80989: PUSH
80990: EMPTY
80991: LIST
80992: LIST
80993: LIST
80994: PUSH
80995: LD_VAR 0 1
80999: PUSH
81000: LD_INT 4
81002: MINUS
81003: PUSH
81004: LD_VAR 0 2
81008: PUSH
81009: LD_INT 1
81011: PUSH
81012: EMPTY
81013: LIST
81014: LIST
81015: LIST
81016: PUSH
81017: LD_VAR 0 1
81021: PUSH
81022: LD_VAR 0 2
81026: PUSH
81027: LD_INT 4
81029: MINUS
81030: PUSH
81031: LD_INT 3
81033: PUSH
81034: EMPTY
81035: LIST
81036: LIST
81037: LIST
81038: PUSH
81039: LD_VAR 0 1
81043: PUSH
81044: LD_INT 3
81046: MINUS
81047: PUSH
81048: LD_VAR 0 2
81052: PUSH
81053: LD_INT 3
81055: MINUS
81056: PUSH
81057: LD_INT 2
81059: PUSH
81060: EMPTY
81061: LIST
81062: LIST
81063: LIST
81064: PUSH
81065: EMPTY
81066: LIST
81067: LIST
81068: LIST
81069: LIST
81070: LIST
81071: ST_TO_ADDR
// end ; 4 :
81072: GO 81353
81074: LD_INT 4
81076: DOUBLE
81077: EQUAL
81078: IFTRUE 81082
81080: GO 81215
81082: POP
// begin list := [ [ x , y + 4 , 0 ] , [ x + 3 , y + 3 , 5 ] , [ x + 4 , y , 4 ] , [ x , y - 3 , 3 ] , [ x - 4 , y - 4 , 2 ] ] ;
81083: LD_ADDR_VAR 0 5
81087: PUSH
81088: LD_VAR 0 1
81092: PUSH
81093: LD_VAR 0 2
81097: PUSH
81098: LD_INT 4
81100: PLUS
81101: PUSH
81102: LD_INT 0
81104: PUSH
81105: EMPTY
81106: LIST
81107: LIST
81108: LIST
81109: PUSH
81110: LD_VAR 0 1
81114: PUSH
81115: LD_INT 3
81117: PLUS
81118: PUSH
81119: LD_VAR 0 2
81123: PUSH
81124: LD_INT 3
81126: PLUS
81127: PUSH
81128: LD_INT 5
81130: PUSH
81131: EMPTY
81132: LIST
81133: LIST
81134: LIST
81135: PUSH
81136: LD_VAR 0 1
81140: PUSH
81141: LD_INT 4
81143: PLUS
81144: PUSH
81145: LD_VAR 0 2
81149: PUSH
81150: LD_INT 4
81152: PUSH
81153: EMPTY
81154: LIST
81155: LIST
81156: LIST
81157: PUSH
81158: LD_VAR 0 1
81162: PUSH
81163: LD_VAR 0 2
81167: PUSH
81168: LD_INT 3
81170: MINUS
81171: PUSH
81172: LD_INT 3
81174: PUSH
81175: EMPTY
81176: LIST
81177: LIST
81178: LIST
81179: PUSH
81180: LD_VAR 0 1
81184: PUSH
81185: LD_INT 4
81187: MINUS
81188: PUSH
81189: LD_VAR 0 2
81193: PUSH
81194: LD_INT 4
81196: MINUS
81197: PUSH
81198: LD_INT 2
81200: PUSH
81201: EMPTY
81202: LIST
81203: LIST
81204: LIST
81205: PUSH
81206: EMPTY
81207: LIST
81208: LIST
81209: LIST
81210: LIST
81211: LIST
81212: ST_TO_ADDR
// end ; 5 :
81213: GO 81353
81215: LD_INT 5
81217: DOUBLE
81218: EQUAL
81219: IFTRUE 81223
81221: GO 81352
81223: POP
// begin list := [ [ x - 4 , y , 1 ] , [ x , y - 4 , 3 ] , [ x + 4 , y + 4 , 5 ] , [ x + 3 , y , 4 ] , [ x , y + 3 , 0 ] ] ;
81224: LD_ADDR_VAR 0 5
81228: PUSH
81229: LD_VAR 0 1
81233: PUSH
81234: LD_INT 4
81236: MINUS
81237: PUSH
81238: LD_VAR 0 2
81242: PUSH
81243: LD_INT 1
81245: PUSH
81246: EMPTY
81247: LIST
81248: LIST
81249: LIST
81250: PUSH
81251: LD_VAR 0 1
81255: PUSH
81256: LD_VAR 0 2
81260: PUSH
81261: LD_INT 4
81263: MINUS
81264: PUSH
81265: LD_INT 3
81267: PUSH
81268: EMPTY
81269: LIST
81270: LIST
81271: LIST
81272: PUSH
81273: LD_VAR 0 1
81277: PUSH
81278: LD_INT 4
81280: PLUS
81281: PUSH
81282: LD_VAR 0 2
81286: PUSH
81287: LD_INT 4
81289: PLUS
81290: PUSH
81291: LD_INT 5
81293: PUSH
81294: EMPTY
81295: LIST
81296: LIST
81297: LIST
81298: PUSH
81299: LD_VAR 0 1
81303: PUSH
81304: LD_INT 3
81306: PLUS
81307: PUSH
81308: LD_VAR 0 2
81312: PUSH
81313: LD_INT 4
81315: PUSH
81316: EMPTY
81317: LIST
81318: LIST
81319: LIST
81320: PUSH
81321: LD_VAR 0 1
81325: PUSH
81326: LD_VAR 0 2
81330: PUSH
81331: LD_INT 3
81333: PLUS
81334: PUSH
81335: LD_INT 0
81337: PUSH
81338: EMPTY
81339: LIST
81340: LIST
81341: LIST
81342: PUSH
81343: EMPTY
81344: LIST
81345: LIST
81346: LIST
81347: LIST
81348: LIST
81349: ST_TO_ADDR
// end ; end ;
81350: GO 81353
81352: POP
// result := list ;
81353: LD_ADDR_VAR 0 4
81357: PUSH
81358: LD_VAR 0 5
81362: ST_TO_ADDR
// end ;
81363: LD_VAR 0 4
81367: RET
// export function SortBySkill ( units , class ) ; var i , tmp ; begin
81368: LD_INT 0
81370: PPUSH
81371: PPUSH
81372: PPUSH
// if not units or not class in [ 1 , 2 , 3 , 4 ] then
81373: LD_VAR 0 1
81377: NOT
81378: PUSH
81379: LD_VAR 0 2
81383: PUSH
81384: LD_INT 1
81386: PUSH
81387: LD_INT 2
81389: PUSH
81390: LD_INT 3
81392: PUSH
81393: LD_INT 4
81395: PUSH
81396: EMPTY
81397: LIST
81398: LIST
81399: LIST
81400: LIST
81401: IN
81402: NOT
81403: OR
81404: IFFALSE 81408
// exit ;
81406: GO 81500
// tmp := [ ] ;
81408: LD_ADDR_VAR 0 5
81412: PUSH
81413: EMPTY
81414: ST_TO_ADDR
// for i in units do
81415: LD_ADDR_VAR 0 4
81419: PUSH
81420: LD_VAR 0 1
81424: PUSH
81425: FOR_IN
81426: IFFALSE 81469
// tmp := Insert ( tmp , tmp + 1 , GetSkill ( i , class ) ) ;
81428: LD_ADDR_VAR 0 5
81432: PUSH
81433: LD_VAR 0 5
81437: PPUSH
81438: LD_VAR 0 5
81442: PUSH
81443: LD_INT 1
81445: PLUS
81446: PPUSH
81447: LD_VAR 0 4
81451: PPUSH
81452: LD_VAR 0 2
81456: PPUSH
81457: CALL_OW 259
81461: PPUSH
81462: CALL_OW 2
81466: ST_TO_ADDR
81467: GO 81425
81469: POP
81470: POP
// if not tmp then
81471: LD_VAR 0 5
81475: NOT
81476: IFFALSE 81480
// exit ;
81478: GO 81500
// result := SortListByListDesc ( units , tmp ) ;
81480: LD_ADDR_VAR 0 3
81484: PUSH
81485: LD_VAR 0 1
81489: PPUSH
81490: LD_VAR 0 5
81494: PPUSH
81495: CALL_OW 77
81499: ST_TO_ADDR
// end ;
81500: LD_VAR 0 3
81504: RET
// export function UnitGoingToBuilding ( unit , building ) ; var x , y ; begin
81505: LD_INT 0
81507: PPUSH
81508: PPUSH
81509: PPUSH
// x := GetX ( building ) ;
81510: LD_ADDR_VAR 0 4
81514: PUSH
81515: LD_VAR 0 2
81519: PPUSH
81520: CALL_OW 250
81524: ST_TO_ADDR
// y := GetY ( building ) ;
81525: LD_ADDR_VAR 0 5
81529: PUSH
81530: LD_VAR 0 2
81534: PPUSH
81535: CALL_OW 251
81539: ST_TO_ADDR
// if GetTaskList ( unit ) then
81540: LD_VAR 0 1
81544: PPUSH
81545: CALL_OW 437
81549: IFFALSE 81644
// begin if e = GetTaskList ( unit ) [ 1 ] [ 1 ] and x = GetTaskList ( unit ) [ 1 ] [ 2 ] and y = GetTaskList ( unit ) [ 1 ] [ 3 ] then
81551: LD_STRING e
81553: PUSH
81554: LD_VAR 0 1
81558: PPUSH
81559: CALL_OW 437
81563: PUSH
81564: LD_INT 1
81566: ARRAY
81567: PUSH
81568: LD_INT 1
81570: ARRAY
81571: EQUAL
81572: PUSH
81573: LD_VAR 0 4
81577: PUSH
81578: LD_VAR 0 1
81582: PPUSH
81583: CALL_OW 437
81587: PUSH
81588: LD_INT 1
81590: ARRAY
81591: PUSH
81592: LD_INT 2
81594: ARRAY
81595: EQUAL
81596: AND
81597: PUSH
81598: LD_VAR 0 5
81602: PUSH
81603: LD_VAR 0 1
81607: PPUSH
81608: CALL_OW 437
81612: PUSH
81613: LD_INT 1
81615: ARRAY
81616: PUSH
81617: LD_INT 3
81619: ARRAY
81620: EQUAL
81621: AND
81622: IFFALSE 81634
// result := true else
81624: LD_ADDR_VAR 0 3
81628: PUSH
81629: LD_INT 1
81631: ST_TO_ADDR
81632: GO 81642
// result := false ;
81634: LD_ADDR_VAR 0 3
81638: PUSH
81639: LD_INT 0
81641: ST_TO_ADDR
// end else
81642: GO 81652
// result := false ;
81644: LD_ADDR_VAR 0 3
81648: PUSH
81649: LD_INT 0
81651: ST_TO_ADDR
// end ;
81652: LD_VAR 0 3
81656: RET
// export function PlaceUnitInArea ( unit , area , mode ) ; var i , tmp , hex ; begin
81657: LD_INT 0
81659: PPUSH
81660: PPUSH
81661: PPUSH
81662: PPUSH
// if not unit or not area then
81663: LD_VAR 0 1
81667: NOT
81668: PUSH
81669: LD_VAR 0 2
81673: NOT
81674: OR
81675: IFFALSE 81679
// exit ;
81677: GO 81843
// tmp := AreaToList ( area , i ) ;
81679: LD_ADDR_VAR 0 6
81683: PUSH
81684: LD_VAR 0 2
81688: PPUSH
81689: LD_VAR 0 5
81693: PPUSH
81694: CALL_OW 517
81698: ST_TO_ADDR
// for i = 1 to tmp [ 1 ] do
81699: LD_ADDR_VAR 0 5
81703: PUSH
81704: DOUBLE
81705: LD_INT 1
81707: DEC
81708: ST_TO_ADDR
81709: LD_VAR 0 6
81713: PUSH
81714: LD_INT 1
81716: ARRAY
81717: PUSH
81718: FOR_TO
81719: IFFALSE 81841
// begin hex := [ tmp [ 1 ] [ i ] , tmp [ 2 ] [ i ] ] ;
81721: LD_ADDR_VAR 0 7
81725: PUSH
81726: LD_VAR 0 6
81730: PUSH
81731: LD_INT 1
81733: ARRAY
81734: PUSH
81735: LD_VAR 0 5
81739: ARRAY
81740: PUSH
81741: LD_VAR 0 6
81745: PUSH
81746: LD_INT 2
81748: ARRAY
81749: PUSH
81750: LD_VAR 0 5
81754: ARRAY
81755: PUSH
81756: EMPTY
81757: LIST
81758: LIST
81759: ST_TO_ADDR
// if HexInfo ( hex [ 1 ] , hex [ 2 ] ) = 0 then
81760: LD_VAR 0 7
81764: PUSH
81765: LD_INT 1
81767: ARRAY
81768: PPUSH
81769: LD_VAR 0 7
81773: PUSH
81774: LD_INT 2
81776: ARRAY
81777: PPUSH
81778: CALL_OW 428
81782: PUSH
81783: LD_INT 0
81785: EQUAL
81786: IFFALSE 81839
// begin PlaceUnitXY ( unit , hex [ 1 ] , hex [ 2 ] , mode ) ;
81788: LD_VAR 0 1
81792: PPUSH
81793: LD_VAR 0 7
81797: PUSH
81798: LD_INT 1
81800: ARRAY
81801: PPUSH
81802: LD_VAR 0 7
81806: PUSH
81807: LD_INT 2
81809: ARRAY
81810: PPUSH
81811: LD_VAR 0 3
81815: PPUSH
81816: CALL_OW 48
// result := IsPlaced ( unit ) ;
81820: LD_ADDR_VAR 0 4
81824: PUSH
81825: LD_VAR 0 1
81829: PPUSH
81830: CALL_OW 305
81834: ST_TO_ADDR
// exit ;
81835: POP
81836: POP
81837: GO 81843
// end ; end ;
81839: GO 81718
81841: POP
81842: POP
// end ;
81843: LD_VAR 0 4
81847: RET
// export function BuildingsListDump ( side ) ; var i , tmp ; begin
81848: LD_INT 0
81850: PPUSH
81851: PPUSH
81852: PPUSH
// if not side or side > 8 then
81853: LD_VAR 0 1
81857: NOT
81858: PUSH
81859: LD_VAR 0 1
81863: PUSH
81864: LD_INT 8
81866: GREATER
81867: OR
81868: IFFALSE 81872
// exit ;
81870: GO 82059
// tmp := FilterAllUnits ( [ [ f_side , side ] , [ f_type , unit_building ] ] ) ;
81872: LD_ADDR_VAR 0 4
81876: PUSH
81877: LD_INT 22
81879: PUSH
81880: LD_VAR 0 1
81884: PUSH
81885: EMPTY
81886: LIST
81887: LIST
81888: PUSH
81889: LD_INT 21
81891: PUSH
81892: LD_INT 3
81894: PUSH
81895: EMPTY
81896: LIST
81897: LIST
81898: PUSH
81899: EMPTY
81900: LIST
81901: LIST
81902: PPUSH
81903: CALL_OW 69
81907: ST_TO_ADDR
// if not tmp then
81908: LD_VAR 0 4
81912: NOT
81913: IFFALSE 81917
// exit ;
81915: GO 82059
// enable_addtolog := true ;
81917: LD_ADDR_OWVAR 81
81921: PUSH
81922: LD_INT 1
81924: ST_TO_ADDR
// AddToLog ( [ ) ;
81925: LD_STRING [
81927: PPUSH
81928: CALL_OW 561
// for i in tmp do
81932: LD_ADDR_VAR 0 3
81936: PUSH
81937: LD_VAR 0 4
81941: PUSH
81942: FOR_IN
81943: IFFALSE 82050
// begin AddToLog ( [ & GetBType ( i ) & ,  & GetX ( i ) & ,  & GetY ( i ) & ,  & GetDir ( i ) & ,  & GetLabKind ( i , 1 ) & ,  & GetLabKind ( i , 2 ) & ], ) ;
81945: LD_STRING [
81947: PUSH
81948: LD_VAR 0 3
81952: PPUSH
81953: CALL_OW 266
81957: STR
81958: PUSH
81959: LD_STRING , 
81961: STR
81962: PUSH
81963: LD_VAR 0 3
81967: PPUSH
81968: CALL_OW 250
81972: STR
81973: PUSH
81974: LD_STRING , 
81976: STR
81977: PUSH
81978: LD_VAR 0 3
81982: PPUSH
81983: CALL_OW 251
81987: STR
81988: PUSH
81989: LD_STRING , 
81991: STR
81992: PUSH
81993: LD_VAR 0 3
81997: PPUSH
81998: CALL_OW 254
82002: STR
82003: PUSH
82004: LD_STRING , 
82006: STR
82007: PUSH
82008: LD_VAR 0 3
82012: PPUSH
82013: LD_INT 1
82015: PPUSH
82016: CALL_OW 268
82020: STR
82021: PUSH
82022: LD_STRING , 
82024: STR
82025: PUSH
82026: LD_VAR 0 3
82030: PPUSH
82031: LD_INT 2
82033: PPUSH
82034: CALL_OW 268
82038: STR
82039: PUSH
82040: LD_STRING ],
82042: STR
82043: PPUSH
82044: CALL_OW 561
// end ;
82048: GO 81942
82050: POP
82051: POP
// AddToLog ( ]; ) ;
82052: LD_STRING ];
82054: PPUSH
82055: CALL_OW 561
// end ;
82059: LD_VAR 0 2
82063: RET
// export function Crates ( area , rate , min , max ) ; var i , r , time , amount ; begin
82064: LD_INT 0
82066: PPUSH
82067: PPUSH
82068: PPUSH
82069: PPUSH
82070: PPUSH
// if not area or not rate or not max then
82071: LD_VAR 0 1
82075: NOT
82076: PUSH
82077: LD_VAR 0 2
82081: NOT
82082: OR
82083: PUSH
82084: LD_VAR 0 4
82088: NOT
82089: OR
82090: IFFALSE 82094
// exit ;
82092: GO 82286
// while 1 do
82094: LD_INT 1
82096: IFFALSE 82286
// begin amount := GetResourceArea ( area , mat_cans ) * 10 ;
82098: LD_ADDR_VAR 0 9
82102: PUSH
82103: LD_VAR 0 1
82107: PPUSH
82108: LD_INT 1
82110: PPUSH
82111: CALL_OW 287
82115: PUSH
82116: LD_INT 10
82118: MUL
82119: ST_TO_ADDR
// r := rate / 10 ;
82120: LD_ADDR_VAR 0 7
82124: PUSH
82125: LD_VAR 0 2
82129: PUSH
82130: LD_INT 10
82132: DIVREAL
82133: ST_TO_ADDR
// time := 1 1$00 ;
82134: LD_ADDR_VAR 0 8
82138: PUSH
82139: LD_INT 2100
82141: ST_TO_ADDR
// if amount < min then
82142: LD_VAR 0 9
82146: PUSH
82147: LD_VAR 0 3
82151: LESS
82152: IFFALSE 82170
// r := r * 2 else
82154: LD_ADDR_VAR 0 7
82158: PUSH
82159: LD_VAR 0 7
82163: PUSH
82164: LD_INT 2
82166: MUL
82167: ST_TO_ADDR
82168: GO 82196
// if amount > max then
82170: LD_VAR 0 9
82174: PUSH
82175: LD_VAR 0 4
82179: GREATER
82180: IFFALSE 82196
// r := r / 2 ;
82182: LD_ADDR_VAR 0 7
82186: PUSH
82187: LD_VAR 0 7
82191: PUSH
82192: LD_INT 2
82194: DIVREAL
82195: ST_TO_ADDR
// time := time / r ;
82196: LD_ADDR_VAR 0 8
82200: PUSH
82201: LD_VAR 0 8
82205: PUSH
82206: LD_VAR 0 7
82210: DIVREAL
82211: ST_TO_ADDR
// if time < 0 then
82212: LD_VAR 0 8
82216: PUSH
82217: LD_INT 0
82219: LESS
82220: IFFALSE 82237
// time := time * - 1 ;
82222: LD_ADDR_VAR 0 8
82226: PUSH
82227: LD_VAR 0 8
82231: PUSH
82232: LD_INT 1
82234: NEG
82235: MUL
82236: ST_TO_ADDR
// wait ( time ) ;
82237: LD_VAR 0 8
82241: PPUSH
82242: CALL_OW 67
// wait ( rand ( 0 0$01 , 0 0$25 ) ) ;
82246: LD_INT 35
82248: PPUSH
82249: LD_INT 875
82251: PPUSH
82252: CALL_OW 12
82256: PPUSH
82257: CALL_OW 67
// CreateCratesArea ( rand ( 1 , 5 ) , area , true ) ;
82261: LD_INT 1
82263: PPUSH
82264: LD_INT 5
82266: PPUSH
82267: CALL_OW 12
82271: PPUSH
82272: LD_VAR 0 1
82276: PPUSH
82277: LD_INT 1
82279: PPUSH
82280: CALL_OW 55
// end ;
82284: GO 82094
// end ;
82286: LD_VAR 0 5
82290: RET
// export function UpgradeTurretsWeapon ( turrets , factories ) ; var i , j , k , nat , weapon , weapons , list ; begin
82291: LD_INT 0
82293: PPUSH
82294: PPUSH
82295: PPUSH
82296: PPUSH
82297: PPUSH
82298: PPUSH
82299: PPUSH
82300: PPUSH
// if not turrets or not factories then
82301: LD_VAR 0 1
82305: NOT
82306: PUSH
82307: LD_VAR 0 2
82311: NOT
82312: OR
82313: IFFALSE 82317
// exit ;
82315: GO 82624
// list := [ [ [ us_double_gun , us_heavy_gun ] , [ us_machine_gun , us_gatling_gun ] , [ us_light_gun , us_double_gun ] ] , [ [ ar_double_machine_gun , ar_gatling_gun ] , [ ar_light_gun , ar_gun ] ] , [ [ ru_heavy_machine_gun , ru_gatling_gun ] , [ ru_gun , ru_heavy_gun ] , [ ru_rocket_launcher , ru_rocket ] ] , ] ;
82317: LD_ADDR_VAR 0 10
82321: PUSH
82322: LD_INT 5
82324: PUSH
82325: LD_INT 6
82327: PUSH
82328: EMPTY
82329: LIST
82330: LIST
82331: PUSH
82332: LD_INT 2
82334: PUSH
82335: LD_INT 4
82337: PUSH
82338: EMPTY
82339: LIST
82340: LIST
82341: PUSH
82342: LD_INT 3
82344: PUSH
82345: LD_INT 5
82347: PUSH
82348: EMPTY
82349: LIST
82350: LIST
82351: PUSH
82352: EMPTY
82353: LIST
82354: LIST
82355: LIST
82356: PUSH
82357: LD_INT 24
82359: PUSH
82360: LD_INT 25
82362: PUSH
82363: EMPTY
82364: LIST
82365: LIST
82366: PUSH
82367: LD_INT 23
82369: PUSH
82370: LD_INT 27
82372: PUSH
82373: EMPTY
82374: LIST
82375: LIST
82376: PUSH
82377: EMPTY
82378: LIST
82379: LIST
82380: PUSH
82381: LD_INT 42
82383: PUSH
82384: LD_INT 43
82386: PUSH
82387: EMPTY
82388: LIST
82389: LIST
82390: PUSH
82391: LD_INT 44
82393: PUSH
82394: LD_INT 46
82396: PUSH
82397: EMPTY
82398: LIST
82399: LIST
82400: PUSH
82401: LD_INT 45
82403: PUSH
82404: LD_INT 47
82406: PUSH
82407: EMPTY
82408: LIST
82409: LIST
82410: PUSH
82411: EMPTY
82412: LIST
82413: LIST
82414: LIST
82415: PUSH
82416: EMPTY
82417: LIST
82418: LIST
82419: LIST
82420: ST_TO_ADDR
// result := [ ] ;
82421: LD_ADDR_VAR 0 3
82425: PUSH
82426: EMPTY
82427: ST_TO_ADDR
// for i in turrets do
82428: LD_ADDR_VAR 0 4
82432: PUSH
82433: LD_VAR 0 1
82437: PUSH
82438: FOR_IN
82439: IFFALSE 82622
// begin nat := GetNation ( i ) ;
82441: LD_ADDR_VAR 0 7
82445: PUSH
82446: LD_VAR 0 4
82450: PPUSH
82451: CALL_OW 248
82455: ST_TO_ADDR
// weapon := 0 ;
82456: LD_ADDR_VAR 0 8
82460: PUSH
82461: LD_INT 0
82463: ST_TO_ADDR
// if not nat then
82464: LD_VAR 0 7
82468: NOT
82469: IFFALSE 82473
// continue ;
82471: GO 82438
// for j in list [ nat ] do
82473: LD_ADDR_VAR 0 5
82477: PUSH
82478: LD_VAR 0 10
82482: PUSH
82483: LD_VAR 0 7
82487: ARRAY
82488: PUSH
82489: FOR_IN
82490: IFFALSE 82531
// if GetBWeapon ( i ) = j [ 1 ] then
82492: LD_VAR 0 4
82496: PPUSH
82497: CALL_OW 269
82501: PUSH
82502: LD_VAR 0 5
82506: PUSH
82507: LD_INT 1
82509: ARRAY
82510: EQUAL
82511: IFFALSE 82529
// begin weapon := j [ 2 ] ;
82513: LD_ADDR_VAR 0 8
82517: PUSH
82518: LD_VAR 0 5
82522: PUSH
82523: LD_INT 2
82525: ARRAY
82526: ST_TO_ADDR
// break ;
82527: GO 82531
// end ;
82529: GO 82489
82531: POP
82532: POP
// if not weapon then
82533: LD_VAR 0 8
82537: NOT
82538: IFFALSE 82542
// continue ;
82540: GO 82438
// for k in factories do
82542: LD_ADDR_VAR 0 6
82546: PUSH
82547: LD_VAR 0 2
82551: PUSH
82552: FOR_IN
82553: IFFALSE 82618
// begin weapons := AvailableWeaponList ( k ) ;
82555: LD_ADDR_VAR 0 9
82559: PUSH
82560: LD_VAR 0 6
82564: PPUSH
82565: CALL_OW 478
82569: ST_TO_ADDR
// if not weapons then
82570: LD_VAR 0 9
82574: NOT
82575: IFFALSE 82579
// continue ;
82577: GO 82552
// if weapon in weapons then
82579: LD_VAR 0 8
82583: PUSH
82584: LD_VAR 0 9
82588: IN
82589: IFFALSE 82616
// begin result := [ i , weapon ] ;
82591: LD_ADDR_VAR 0 3
82595: PUSH
82596: LD_VAR 0 4
82600: PUSH
82601: LD_VAR 0 8
82605: PUSH
82606: EMPTY
82607: LIST
82608: LIST
82609: ST_TO_ADDR
// exit ;
82610: POP
82611: POP
82612: POP
82613: POP
82614: GO 82624
// end ; end ;
82616: GO 82552
82618: POP
82619: POP
// end ;
82620: GO 82438
82622: POP
82623: POP
// end ;
82624: LD_VAR 0 3
82628: RET
// export function RevealMapOnXY ( x , y , side , range ) ; begin
82629: LD_INT 0
82631: PPUSH
// if not side or side > 8 then
82632: LD_VAR 0 3
82636: NOT
82637: PUSH
82638: LD_VAR 0 3
82642: PUSH
82643: LD_INT 8
82645: GREATER
82646: OR
82647: IFFALSE 82651
// exit ;
82649: GO 82710
// if not range then
82651: LD_VAR 0 4
82655: NOT
82656: IFFALSE 82667
// range := - 12 ;
82658: LD_ADDR_VAR 0 4
82662: PUSH
82663: LD_INT 12
82665: NEG
82666: ST_TO_ADDR
// PlaceSeeing ( x , y , side , range ) ;
82667: LD_VAR 0 1
82671: PPUSH
82672: LD_VAR 0 2
82676: PPUSH
82677: LD_VAR 0 3
82681: PPUSH
82682: LD_VAR 0 4
82686: PPUSH
82687: CALL_OW 330
// RemoveSeeing ( x , y , side ) ;
82691: LD_VAR 0 1
82695: PPUSH
82696: LD_VAR 0 2
82700: PPUSH
82701: LD_VAR 0 3
82705: PPUSH
82706: CALL_OW 331
// end ;
82710: LD_VAR 0 5
82714: RET
// export function Video ( mode ) ; begin
82715: LD_INT 0
82717: PPUSH
// ingame_video = mode ;
82718: LD_ADDR_OWVAR 52
82722: PUSH
82723: LD_VAR 0 1
82727: ST_TO_ADDR
// interface_hidden = mode ;
82728: LD_ADDR_OWVAR 54
82732: PUSH
82733: LD_VAR 0 1
82737: ST_TO_ADDR
// end ;
82738: LD_VAR 0 2
82742: RET
// export function Join ( array , element ) ; begin
82743: LD_INT 0
82745: PPUSH
// result := array ^ element ;
82746: LD_ADDR_VAR 0 3
82750: PUSH
82751: LD_VAR 0 1
82755: PUSH
82756: LD_VAR 0 2
82760: ADD
82761: ST_TO_ADDR
// end ;
82762: LD_VAR 0 3
82766: RET
// export function JoinUnion ( array , element ) ; begin
82767: LD_INT 0
82769: PPUSH
// result := array union element ;
82770: LD_ADDR_VAR 0 3
82774: PUSH
82775: LD_VAR 0 1
82779: PUSH
82780: LD_VAR 0 2
82784: UNION
82785: ST_TO_ADDR
// end ;
82786: LD_VAR 0 3
82790: RET
// export function GetBehemoths ( side ) ; begin
82791: LD_INT 0
82793: PPUSH
// result := FilterAllUnits ( [ [ f_side , side ] , [ f_chassis , 25 ] ] ) ;
82794: LD_ADDR_VAR 0 2
82798: PUSH
82799: LD_INT 22
82801: PUSH
82802: LD_VAR 0 1
82806: PUSH
82807: EMPTY
82808: LIST
82809: LIST
82810: PUSH
82811: LD_INT 31
82813: PUSH
82814: LD_INT 25
82816: PUSH
82817: EMPTY
82818: LIST
82819: LIST
82820: PUSH
82821: EMPTY
82822: LIST
82823: LIST
82824: PPUSH
82825: CALL_OW 69
82829: ST_TO_ADDR
// end ;
82830: LD_VAR 0 2
82834: RET
// export function Shuffle ( array ) ; var i , index ; begin
82835: LD_INT 0
82837: PPUSH
82838: PPUSH
82839: PPUSH
// result := [ ] ;
82840: LD_ADDR_VAR 0 2
82844: PUSH
82845: EMPTY
82846: ST_TO_ADDR
// if not array then
82847: LD_VAR 0 1
82851: NOT
82852: IFFALSE 82856
// exit ;
82854: GO 82955
// Randomize ;
82856: CALL_OW 10
// for i = array downto 1 do
82860: LD_ADDR_VAR 0 3
82864: PUSH
82865: DOUBLE
82866: LD_VAR 0 1
82870: INC
82871: ST_TO_ADDR
82872: LD_INT 1
82874: PUSH
82875: FOR_DOWNTO
82876: IFFALSE 82953
// begin index := rand ( 1 , array ) ;
82878: LD_ADDR_VAR 0 4
82882: PUSH
82883: LD_INT 1
82885: PPUSH
82886: LD_VAR 0 1
82890: PPUSH
82891: CALL_OW 12
82895: ST_TO_ADDR
// result := Insert ( result , result + 1 , array [ index ] ) ;
82896: LD_ADDR_VAR 0 2
82900: PUSH
82901: LD_VAR 0 2
82905: PPUSH
82906: LD_VAR 0 2
82910: PUSH
82911: LD_INT 1
82913: PLUS
82914: PPUSH
82915: LD_VAR 0 1
82919: PUSH
82920: LD_VAR 0 4
82924: ARRAY
82925: PPUSH
82926: CALL_OW 2
82930: ST_TO_ADDR
// array := Delete ( array , index ) ;
82931: LD_ADDR_VAR 0 1
82935: PUSH
82936: LD_VAR 0 1
82940: PPUSH
82941: LD_VAR 0 4
82945: PPUSH
82946: CALL_OW 3
82950: ST_TO_ADDR
// end ;
82951: GO 82875
82953: POP
82954: POP
// end ; end_of_file end_of_file end_of_file
82955: LD_VAR 0 2
82959: RET
// export function SOS_UnitExtraDestroyed ( un , killerSide , killerUnit ) ; var i , eff , side ; begin
82960: LD_INT 0
82962: PPUSH
82963: PPUSH
82964: PPUSH
82965: PPUSH
// if GetWeapon ( un ) = ar_bio_bomb then
82966: LD_VAR 0 1
82970: PPUSH
82971: CALL_OW 264
82975: PUSH
82976: LD_EXP 53
82980: EQUAL
82981: IFFALSE 83053
// begin if GetTech ( tech_bio3 , GetSide ( un ) ) = state_researched then
82983: LD_INT 68
82985: PPUSH
82986: LD_VAR 0 1
82990: PPUSH
82991: CALL_OW 255
82995: PPUSH
82996: CALL_OW 321
83000: PUSH
83001: LD_INT 2
83003: EQUAL
83004: IFFALSE 83016
// eff := 70 else
83006: LD_ADDR_VAR 0 6
83010: PUSH
83011: LD_INT 70
83013: ST_TO_ADDR
83014: GO 83024
// eff := 30 ;
83016: LD_ADDR_VAR 0 6
83020: PUSH
83021: LD_INT 30
83023: ST_TO_ADDR
// ArtContamination ( GetX ( un ) , GetY ( un ) , eff ) ;
83024: LD_VAR 0 1
83028: PPUSH
83029: CALL_OW 250
83033: PPUSH
83034: LD_VAR 0 1
83038: PPUSH
83039: CALL_OW 251
83043: PPUSH
83044: LD_VAR 0 6
83048: PPUSH
83049: CALL_OW 495
// end ; end ;
83053: LD_VAR 0 4
83057: RET
// export function SOS_Command ( cmd ) ; var i , j , tmp , taskList , _taskList ; begin
83058: LD_INT 0
83060: PPUSH
83061: PPUSH
83062: PPUSH
83063: PPUSH
83064: PPUSH
83065: PPUSH
// if cmd = 124 then
83066: LD_VAR 0 1
83070: PUSH
83071: LD_INT 124
83073: EQUAL
83074: IFFALSE 83280
// begin tmp := FilterAllUnits ( [ f_or , [ f_weapon , ru_bulldozer ] , [ f_weapon , us_bulldozer ] ] ) ;
83076: LD_ADDR_VAR 0 5
83080: PUSH
83081: LD_INT 2
83083: PUSH
83084: LD_INT 34
83086: PUSH
83087: LD_INT 53
83089: PUSH
83090: EMPTY
83091: LIST
83092: LIST
83093: PUSH
83094: LD_INT 34
83096: PUSH
83097: LD_INT 14
83099: PUSH
83100: EMPTY
83101: LIST
83102: LIST
83103: PUSH
83104: EMPTY
83105: LIST
83106: LIST
83107: LIST
83108: PPUSH
83109: CALL_OW 69
83113: ST_TO_ADDR
// if not tmp then
83114: LD_VAR 0 5
83118: NOT
83119: IFFALSE 83123
// exit ;
83121: GO 83280
// for i in tmp do
83123: LD_ADDR_VAR 0 3
83127: PUSH
83128: LD_VAR 0 5
83132: PUSH
83133: FOR_IN
83134: IFFALSE 83278
// begin taskList := GetTaskList ( i ) ;
83136: LD_ADDR_VAR 0 6
83140: PUSH
83141: LD_VAR 0 3
83145: PPUSH
83146: CALL_OW 437
83150: ST_TO_ADDR
// if not taskList then
83151: LD_VAR 0 6
83155: NOT
83156: IFFALSE 83160
// continue ;
83158: GO 83133
// for j = 1 to taskList do
83160: LD_ADDR_VAR 0 4
83164: PUSH
83165: DOUBLE
83166: LD_INT 1
83168: DEC
83169: ST_TO_ADDR
83170: LD_VAR 0 6
83174: PUSH
83175: FOR_TO
83176: IFFALSE 83274
// if taskList [ j ] [ 1 ] = | then
83178: LD_VAR 0 6
83182: PUSH
83183: LD_VAR 0 4
83187: ARRAY
83188: PUSH
83189: LD_INT 1
83191: ARRAY
83192: PUSH
83193: LD_STRING |
83195: EQUAL
83196: IFFALSE 83272
// begin _taskList := Delete ( taskList , 1 ) ;
83198: LD_ADDR_VAR 0 7
83202: PUSH
83203: LD_VAR 0 6
83207: PPUSH
83208: LD_INT 1
83210: PPUSH
83211: CALL_OW 3
83215: ST_TO_ADDR
// SetTaskList ( i , _taskList ) ;
83216: LD_VAR 0 3
83220: PPUSH
83221: LD_VAR 0 7
83225: PPUSH
83226: CALL_OW 446
// CutTreeXYR ( i , taskList [ j ] [ 2 ] , taskList [ j ] [ 3 ] , 8 ) ;
83230: LD_VAR 0 3
83234: PPUSH
83235: LD_VAR 0 6
83239: PUSH
83240: LD_VAR 0 4
83244: ARRAY
83245: PUSH
83246: LD_INT 2
83248: ARRAY
83249: PPUSH
83250: LD_VAR 0 6
83254: PUSH
83255: LD_VAR 0 4
83259: ARRAY
83260: PUSH
83261: LD_INT 3
83263: ARRAY
83264: PPUSH
83265: LD_INT 8
83267: PPUSH
83268: CALL 83285 0 4
// end ;
83272: GO 83175
83274: POP
83275: POP
// end ;
83276: GO 83133
83278: POP
83279: POP
// end ; end ;
83280: LD_VAR 0 2
83284: RET
// function CutTreeXYR ( bulldozer , x , y , r ) ; var i , min_x , min_y , max_x , max_y , _x , _y , list ; begin
83285: LD_INT 0
83287: PPUSH
83288: PPUSH
83289: PPUSH
83290: PPUSH
83291: PPUSH
83292: PPUSH
83293: PPUSH
83294: PPUSH
83295: PPUSH
// if not bulldozer or not ValidHex ( x , y ) or not r then
83296: LD_VAR 0 1
83300: NOT
83301: PUSH
83302: LD_VAR 0 2
83306: PPUSH
83307: LD_VAR 0 3
83311: PPUSH
83312: CALL_OW 488
83316: NOT
83317: OR
83318: PUSH
83319: LD_VAR 0 4
83323: NOT
83324: OR
83325: IFFALSE 83329
// exit ;
83327: GO 83669
// list := [ ] ;
83329: LD_ADDR_VAR 0 13
83333: PUSH
83334: EMPTY
83335: ST_TO_ADDR
// if x - r < 0 then
83336: LD_VAR 0 2
83340: PUSH
83341: LD_VAR 0 4
83345: MINUS
83346: PUSH
83347: LD_INT 0
83349: LESS
83350: IFFALSE 83362
// min_x := 0 else
83352: LD_ADDR_VAR 0 7
83356: PUSH
83357: LD_INT 0
83359: ST_TO_ADDR
83360: GO 83378
// min_x := x - r ;
83362: LD_ADDR_VAR 0 7
83366: PUSH
83367: LD_VAR 0 2
83371: PUSH
83372: LD_VAR 0 4
83376: MINUS
83377: ST_TO_ADDR
// if y - r < 0 then
83378: LD_VAR 0 3
83382: PUSH
83383: LD_VAR 0 4
83387: MINUS
83388: PUSH
83389: LD_INT 0
83391: LESS
83392: IFFALSE 83404
// min_y := 0 else
83394: LD_ADDR_VAR 0 8
83398: PUSH
83399: LD_INT 0
83401: ST_TO_ADDR
83402: GO 83420
// min_y := y - r ;
83404: LD_ADDR_VAR 0 8
83408: PUSH
83409: LD_VAR 0 3
83413: PUSH
83414: LD_VAR 0 4
83418: MINUS
83419: ST_TO_ADDR
// max_x := x + r ;
83420: LD_ADDR_VAR 0 9
83424: PUSH
83425: LD_VAR 0 2
83429: PUSH
83430: LD_VAR 0 4
83434: PLUS
83435: ST_TO_ADDR
// max_y := y + r ;
83436: LD_ADDR_VAR 0 10
83440: PUSH
83441: LD_VAR 0 3
83445: PUSH
83446: LD_VAR 0 4
83450: PLUS
83451: ST_TO_ADDR
// for _x = min_x to max_x do
83452: LD_ADDR_VAR 0 11
83456: PUSH
83457: DOUBLE
83458: LD_VAR 0 7
83462: DEC
83463: ST_TO_ADDR
83464: LD_VAR 0 9
83468: PUSH
83469: FOR_TO
83470: IFFALSE 83587
// for _y = min_y to max_y do
83472: LD_ADDR_VAR 0 12
83476: PUSH
83477: DOUBLE
83478: LD_VAR 0 8
83482: DEC
83483: ST_TO_ADDR
83484: LD_VAR 0 10
83488: PUSH
83489: FOR_TO
83490: IFFALSE 83583
// begin if not ValidHex ( _x , _y ) then
83492: LD_VAR 0 11
83496: PPUSH
83497: LD_VAR 0 12
83501: PPUSH
83502: CALL_OW 488
83506: NOT
83507: IFFALSE 83511
// continue ;
83509: GO 83489
// if IsEnvironment ( _x , _y ) and IsEnvironmentDestroyable ( _x , _y ) then
83511: LD_VAR 0 11
83515: PPUSH
83516: LD_VAR 0 12
83520: PPUSH
83521: CALL_OW 351
83525: PUSH
83526: LD_VAR 0 11
83530: PPUSH
83531: LD_VAR 0 12
83535: PPUSH
83536: CALL_OW 554
83540: AND
83541: IFFALSE 83581
// list := Insert ( list , list + 1 , [ _x , _y ] ) ;
83543: LD_ADDR_VAR 0 13
83547: PUSH
83548: LD_VAR 0 13
83552: PPUSH
83553: LD_VAR 0 13
83557: PUSH
83558: LD_INT 1
83560: PLUS
83561: PPUSH
83562: LD_VAR 0 11
83566: PUSH
83567: LD_VAR 0 12
83571: PUSH
83572: EMPTY
83573: LIST
83574: LIST
83575: PPUSH
83576: CALL_OW 2
83580: ST_TO_ADDR
// end ;
83581: GO 83489
83583: POP
83584: POP
83585: GO 83469
83587: POP
83588: POP
// if not list then
83589: LD_VAR 0 13
83593: NOT
83594: IFFALSE 83598
// exit ;
83596: GO 83669
// for i in list do
83598: LD_ADDR_VAR 0 6
83602: PUSH
83603: LD_VAR 0 13
83607: PUSH
83608: FOR_IN
83609: IFFALSE 83667
// AddTaskList ( bulldozer , [ [ M , i [ 1 ] , i [ 2 ] , 0 , 0 , 0 , 0 ] ] ) ;
83611: LD_VAR 0 1
83615: PPUSH
83616: LD_STRING M
83618: PUSH
83619: LD_VAR 0 6
83623: PUSH
83624: LD_INT 1
83626: ARRAY
83627: PUSH
83628: LD_VAR 0 6
83632: PUSH
83633: LD_INT 2
83635: ARRAY
83636: PUSH
83637: LD_INT 0
83639: PUSH
83640: LD_INT 0
83642: PUSH
83643: LD_INT 0
83645: PUSH
83646: LD_INT 0
83648: PUSH
83649: EMPTY
83650: LIST
83651: LIST
83652: LIST
83653: LIST
83654: LIST
83655: LIST
83656: LIST
83657: PUSH
83658: EMPTY
83659: LIST
83660: PPUSH
83661: CALL_OW 447
83665: GO 83608
83667: POP
83668: POP
// end ;
83669: LD_VAR 0 5
83673: RET
