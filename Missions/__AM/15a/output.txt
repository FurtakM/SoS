// starting begin ResetFog ;
   0: CALL_OW 335
// AnimateTrees ( true ) ;
   4: LD_INT 1
   6: PPUSH
   7: CALL_OW 573
// InitVariables ;
  11: CALL 69 0 0
// InitMacro ;
  15: CALL 20072 0 0
// InitNature ;
  19: CALL 16744 0 0
// InitArtifact ;
  23: CALL 17357 0 0
// if debug then
  27: LD_EXP 1
  31: IFFALSE 40
// FogOff ( 1 ) ;
  33: LD_INT 1
  35: PPUSH
  36: CALL_OW 344
// PrepareAmerican ;
  40: CALL 4496 0 0
// PrepareAlliance ;
  44: CALL 1314 0 0
// PrepareArabian ;
  48: CALL 6226 0 0
// PrepareRussian ;
  52: CALL 8177 0 0
// PrepareLegion ;
  56: CALL 6620 0 0
// Action ;
  60: CALL 10680 0 0
// MC_Start ( ) ;
  64: CALL 22184 0 0
// end ;
  68: END
// export debug ; export russianDestroyed , legionDestroyed , americanDestroyed , arabianDestroyed ; export artifactArCaptured , alienSpotted , spawnOmar ; export artifactIResearched , artifactIIResearched , artifactIIIResearched ; export function InitVariables ; begin
  69: LD_INT 0
  71: PPUSH
// debug := false ;
  72: LD_ADDR_EXP 1
  76: PUSH
  77: LD_INT 0
  79: ST_TO_ADDR
// artifactArCaptured := LoadVariable ( 11_artifact_captured , 0 ) ;
  80: LD_ADDR_EXP 6
  84: PUSH
  85: LD_STRING 11_artifact_captured
  87: PPUSH
  88: LD_INT 0
  90: PPUSH
  91: CALL_OW 30
  95: ST_TO_ADDR
// russianDestroyed := false ;
  96: LD_ADDR_EXP 2
 100: PUSH
 101: LD_INT 0
 103: ST_TO_ADDR
// legionDestroyed := false ;
 104: LD_ADDR_EXP 3
 108: PUSH
 109: LD_INT 0
 111: ST_TO_ADDR
// americanDestroyed := false ;
 112: LD_ADDR_EXP 4
 116: PUSH
 117: LD_INT 0
 119: ST_TO_ADDR
// arabianDestroyed := false ;
 120: LD_ADDR_EXP 5
 124: PUSH
 125: LD_INT 0
 127: ST_TO_ADDR
// artifactIResearched := false ;
 128: LD_ADDR_EXP 9
 132: PUSH
 133: LD_INT 0
 135: ST_TO_ADDR
// artifactIIResearched := false ;
 136: LD_ADDR_EXP 10
 140: PUSH
 141: LD_INT 0
 143: ST_TO_ADDR
// artifactIIIResearched := false ;
 144: LD_ADDR_EXP 11
 148: PUSH
 149: LD_INT 0
 151: ST_TO_ADDR
// alienSpotted := false ;
 152: LD_ADDR_EXP 7
 156: PUSH
 157: LD_INT 0
 159: ST_TO_ADDR
// spawnOmar := false ;
 160: LD_ADDR_EXP 8
 164: PUSH
 165: LD_INT 0
 167: ST_TO_ADDR
// end ;
 168: LD_VAR 0 1
 172: RET
// export function CustomInitMacro ( ) ; begin
 173: LD_INT 0
 175: PPUSH
// mc_parking := [ arabianParkingArea , russianParkingArea , legionParkingArea , powellParking ] ;
 176: LD_ADDR_EXP 98
 180: PUSH
 181: LD_INT 26
 183: PUSH
 184: LD_INT 1
 186: PUSH
 187: LD_INT 4
 189: PUSH
 190: LD_INT 8
 192: PUSH
 193: EMPTY
 194: LIST
 195: LIST
 196: LIST
 197: LIST
 198: ST_TO_ADDR
// mc_scan_area := [ arabianBaseArea , russianBaseArea , legionBaseArea , powellBase ] ;
 199: LD_ADDR_EXP 99
 203: PUSH
 204: LD_INT 27
 206: PUSH
 207: LD_INT 2
 209: PUSH
 210: LD_INT 3
 212: PUSH
 213: LD_INT 7
 215: PUSH
 216: EMPTY
 217: LIST
 218: LIST
 219: LIST
 220: LIST
 221: ST_TO_ADDR
// MC_SetMinesField ( 1 , [ 6 , 7 , 9 ] [ Difficulty ] , arabianMinefield ) ;
 222: LD_INT 1
 224: PPUSH
 225: LD_INT 6
 227: PUSH
 228: LD_INT 7
 230: PUSH
 231: LD_INT 9
 233: PUSH
 234: EMPTY
 235: LIST
 236: LIST
 237: LIST
 238: PUSH
 239: LD_OWVAR 67
 243: ARRAY
 244: PPUSH
 245: LD_INT 28
 247: PPUSH
 248: CALL 43289 0 3
// MC_SetLabKind ( 1 , [ b_lab_weapon , b_lab_siberium , b_lab_biological , b_lab_opto ] ) ;
 252: LD_INT 1
 254: PPUSH
 255: LD_INT 10
 257: PUSH
 258: LD_INT 11
 260: PUSH
 261: LD_INT 13
 263: PUSH
 264: LD_INT 15
 266: PUSH
 267: EMPTY
 268: LIST
 269: LIST
 270: LIST
 271: LIST
 272: PPUSH
 273: CALL 44349 0 2
// MC_SetCratesArea ( 1 , [ arabianCratesArea ] ) ;
 277: LD_INT 1
 279: PPUSH
 280: LD_INT 29
 282: PUSH
 283: EMPTY
 284: LIST
 285: PPUSH
 286: CALL 44442 0 2
// mc_ape := Replace ( mc_ape , 1 , FilterAllUnits ( [ [ f_side , 2 ] , [ f_class , class_apeman_soldier ] ] ) ) ;
 290: LD_ADDR_EXP 103
 294: PUSH
 295: LD_EXP 103
 299: PPUSH
 300: LD_INT 1
 302: PPUSH
 303: LD_INT 22
 305: PUSH
 306: LD_INT 2
 308: PUSH
 309: EMPTY
 310: LIST
 311: LIST
 312: PUSH
 313: LD_INT 25
 315: PUSH
 316: LD_INT 15
 318: PUSH
 319: EMPTY
 320: LIST
 321: LIST
 322: PUSH
 323: EMPTY
 324: LIST
 325: LIST
 326: PPUSH
 327: CALL_OW 69
 331: PPUSH
 332: CALL_OW 1
 336: ST_TO_ADDR
// MC_SetProduceList ( 1 , [ [ ar_medium_trike , engine_solar , control_manual , ar_control_tower ] , [ ar_medium_trike , engine_solar , control_manual , ar_control_tower ] , [ ar_medium_trike , engine_combustion , control_manual , ar_rocket_launcher ] , [ ar_medium_trike , engine_combustion , control_manual , ar_rocket_launcher ] , [ ar_medium_trike , engine_combustion , control_manual , ar_rocket_launcher ] , [ ar_medium_trike , engine_combustion , control_manual , ar_rocket_launcher ] ] ) ;
 337: LD_INT 1
 339: PPUSH
 340: LD_INT 13
 342: PUSH
 343: LD_INT 2
 345: PUSH
 346: LD_INT 1
 348: PUSH
 349: LD_INT 31
 351: PUSH
 352: EMPTY
 353: LIST
 354: LIST
 355: LIST
 356: LIST
 357: PUSH
 358: LD_INT 13
 360: PUSH
 361: LD_INT 2
 363: PUSH
 364: LD_INT 1
 366: PUSH
 367: LD_INT 31
 369: PUSH
 370: EMPTY
 371: LIST
 372: LIST
 373: LIST
 374: LIST
 375: PUSH
 376: LD_INT 13
 378: PUSH
 379: LD_INT 1
 381: PUSH
 382: LD_INT 1
 384: PUSH
 385: LD_INT 28
 387: PUSH
 388: EMPTY
 389: LIST
 390: LIST
 391: LIST
 392: LIST
 393: PUSH
 394: LD_INT 13
 396: PUSH
 397: LD_INT 1
 399: PUSH
 400: LD_INT 1
 402: PUSH
 403: LD_INT 28
 405: PUSH
 406: EMPTY
 407: LIST
 408: LIST
 409: LIST
 410: LIST
 411: PUSH
 412: LD_INT 13
 414: PUSH
 415: LD_INT 1
 417: PUSH
 418: LD_INT 1
 420: PUSH
 421: LD_INT 28
 423: PUSH
 424: EMPTY
 425: LIST
 426: LIST
 427: LIST
 428: LIST
 429: PUSH
 430: LD_INT 13
 432: PUSH
 433: LD_INT 1
 435: PUSH
 436: LD_INT 1
 438: PUSH
 439: LD_INT 28
 441: PUSH
 442: EMPTY
 443: LIST
 444: LIST
 445: LIST
 446: LIST
 447: PUSH
 448: EMPTY
 449: LIST
 450: LIST
 451: LIST
 452: LIST
 453: LIST
 454: LIST
 455: PPUSH
 456: CALL 43607 0 2
// MC_SetDefenderLimit ( 1 , 4 ) ;
 460: LD_INT 1
 462: PPUSH
 463: LD_INT 4
 465: PPUSH
 466: CALL 43792 0 2
// MC_SetLabKind ( 2 , [ b_lab_weapon , b_lab_siberium , b_lab_computer , b_lab_spacetime ] ) ;
 470: LD_INT 2
 472: PPUSH
 473: LD_INT 10
 475: PUSH
 476: LD_INT 11
 478: PUSH
 479: LD_INT 12
 481: PUSH
 482: LD_INT 14
 484: PUSH
 485: EMPTY
 486: LIST
 487: LIST
 488: LIST
 489: LIST
 490: PPUSH
 491: CALL 44349 0 2
// MC_SetCratesArea ( 2 , [ russianCratesArea ] ) ;
 495: LD_INT 2
 497: PPUSH
 498: LD_INT 14
 500: PUSH
 501: EMPTY
 502: LIST
 503: PPUSH
 504: CALL 44442 0 2
// MC_SetProduceList ( 2 , [ [ ru_medium_wheeled , engine_siberite , control_computer , ru_cargo_bay ] , [ ru_medium_tracked , engine_siberite , control_computer , ru_crane ] , [ ru_medium_tracked , engine_siberite , control_computer , ru_crane ] , [ ru_heavy_tracked , engine_siberite , control_computer , ru_rocket ] , [ ru_heavy_tracked , engine_siberite , control_computer , ru_rocket ] , [ ru_heavy_tracked , engine_siberite , control_computer , ru_rocket ] , [ ru_heavy_tracked , engine_siberite , control_computer , ru_rocket ] , [ ru_heavy_tracked , engine_siberite , control_computer , ru_rocket ] ] ) ;
 508: LD_INT 2
 510: PPUSH
 511: LD_INT 21
 513: PUSH
 514: LD_INT 3
 516: PUSH
 517: LD_INT 3
 519: PUSH
 520: LD_INT 51
 522: PUSH
 523: EMPTY
 524: LIST
 525: LIST
 526: LIST
 527: LIST
 528: PUSH
 529: LD_INT 22
 531: PUSH
 532: LD_INT 3
 534: PUSH
 535: LD_INT 3
 537: PUSH
 538: LD_INT 52
 540: PUSH
 541: EMPTY
 542: LIST
 543: LIST
 544: LIST
 545: LIST
 546: PUSH
 547: LD_INT 22
 549: PUSH
 550: LD_INT 3
 552: PUSH
 553: LD_INT 3
 555: PUSH
 556: LD_INT 52
 558: PUSH
 559: EMPTY
 560: LIST
 561: LIST
 562: LIST
 563: LIST
 564: PUSH
 565: LD_INT 24
 567: PUSH
 568: LD_INT 3
 570: PUSH
 571: LD_INT 3
 573: PUSH
 574: LD_INT 47
 576: PUSH
 577: EMPTY
 578: LIST
 579: LIST
 580: LIST
 581: LIST
 582: PUSH
 583: LD_INT 24
 585: PUSH
 586: LD_INT 3
 588: PUSH
 589: LD_INT 3
 591: PUSH
 592: LD_INT 47
 594: PUSH
 595: EMPTY
 596: LIST
 597: LIST
 598: LIST
 599: LIST
 600: PUSH
 601: LD_INT 24
 603: PUSH
 604: LD_INT 3
 606: PUSH
 607: LD_INT 3
 609: PUSH
 610: LD_INT 47
 612: PUSH
 613: EMPTY
 614: LIST
 615: LIST
 616: LIST
 617: LIST
 618: PUSH
 619: LD_INT 24
 621: PUSH
 622: LD_INT 3
 624: PUSH
 625: LD_INT 3
 627: PUSH
 628: LD_INT 47
 630: PUSH
 631: EMPTY
 632: LIST
 633: LIST
 634: LIST
 635: LIST
 636: PUSH
 637: LD_INT 24
 639: PUSH
 640: LD_INT 3
 642: PUSH
 643: LD_INT 3
 645: PUSH
 646: LD_INT 47
 648: PUSH
 649: EMPTY
 650: LIST
 651: LIST
 652: LIST
 653: LIST
 654: PUSH
 655: EMPTY
 656: LIST
 657: LIST
 658: LIST
 659: LIST
 660: LIST
 661: LIST
 662: LIST
 663: LIST
 664: PPUSH
 665: CALL 43607 0 2
// MC_SetDefenderLimit ( 2 , 5 ) ;
 669: LD_INT 2
 671: PPUSH
 672: LD_INT 5
 674: PPUSH
 675: CALL 43792 0 2
// MC_SetUpgradeBuilding ( 2 , b_depot ) ;
 679: LD_INT 2
 681: PPUSH
 682: LD_INT 0
 684: PPUSH
 685: CALL 44222 0 2
// MC_SetMinesField ( 3 , [ 10 , 12 , 15 ] [ Difficulty ] , legionMinefield ) ;
 689: LD_INT 3
 691: PPUSH
 692: LD_INT 10
 694: PUSH
 695: LD_INT 12
 697: PUSH
 698: LD_INT 15
 700: PUSH
 701: EMPTY
 702: LIST
 703: LIST
 704: LIST
 705: PUSH
 706: LD_OWVAR 67
 710: ARRAY
 711: PPUSH
 712: LD_INT 24
 714: PPUSH
 715: CALL 43289 0 3
// MC_SetLabKind ( 3 , [ b_lab_weapon , b_lab_siberium , b_lab_biological , b_lab_opto ] ) ;
 719: LD_INT 3
 721: PPUSH
 722: LD_INT 10
 724: PUSH
 725: LD_INT 11
 727: PUSH
 728: LD_INT 13
 730: PUSH
 731: LD_INT 15
 733: PUSH
 734: EMPTY
 735: LIST
 736: LIST
 737: LIST
 738: LIST
 739: PPUSH
 740: CALL 44349 0 2
// MC_SetCratesArea ( 3 , [ legionCratesArea ] ) ;
 744: LD_INT 3
 746: PPUSH
 747: LD_INT 13
 749: PUSH
 750: EMPTY
 751: LIST
 752: PPUSH
 753: CALL 44442 0 2
// mc_ape := Replace ( mc_ape , 3 , FilterAllUnits ( [ [ f_side , 8 ] , [ f_class , class_apeman_soldier ] ] ) ) ;
 757: LD_ADDR_EXP 103
 761: PUSH
 762: LD_EXP 103
 766: PPUSH
 767: LD_INT 3
 769: PPUSH
 770: LD_INT 22
 772: PUSH
 773: LD_INT 8
 775: PUSH
 776: EMPTY
 777: LIST
 778: LIST
 779: PUSH
 780: LD_INT 25
 782: PUSH
 783: LD_INT 15
 785: PUSH
 786: EMPTY
 787: LIST
 788: LIST
 789: PUSH
 790: EMPTY
 791: LIST
 792: LIST
 793: PPUSH
 794: CALL_OW 69
 798: PPUSH
 799: CALL_OW 1
 803: ST_TO_ADDR
// MC_SetProduceList ( 3 , [ [ ar_medium_trike , engine_solar , control_manual , ar_control_tower ] , [ ar_medium_trike , engine_solar , control_manual , ar_control_tower ] , [ ar_medium_trike , engine_siberite , control_remote , ar_cargo_bay ] , [ ar_half_tracked , engine_combustion , control_manual , ar_rocket_launcher ] , [ ar_half_tracked , engine_combustion , control_manual , ar_rocket_launcher ] , [ ar_half_tracked , engine_combustion , control_manual , ar_rocket_launcher ] , [ ar_half_tracked , engine_combustion , control_manual , ar_rocket_launcher ] ] ) ;
 804: LD_INT 3
 806: PPUSH
 807: LD_INT 13
 809: PUSH
 810: LD_INT 2
 812: PUSH
 813: LD_INT 1
 815: PUSH
 816: LD_INT 31
 818: PUSH
 819: EMPTY
 820: LIST
 821: LIST
 822: LIST
 823: LIST
 824: PUSH
 825: LD_INT 13
 827: PUSH
 828: LD_INT 2
 830: PUSH
 831: LD_INT 1
 833: PUSH
 834: LD_INT 31
 836: PUSH
 837: EMPTY
 838: LIST
 839: LIST
 840: LIST
 841: LIST
 842: PUSH
 843: LD_INT 13
 845: PUSH
 846: LD_INT 3
 848: PUSH
 849: LD_INT 2
 851: PUSH
 852: LD_INT 32
 854: PUSH
 855: EMPTY
 856: LIST
 857: LIST
 858: LIST
 859: LIST
 860: PUSH
 861: LD_INT 14
 863: PUSH
 864: LD_INT 1
 866: PUSH
 867: LD_INT 1
 869: PUSH
 870: LD_INT 28
 872: PUSH
 873: EMPTY
 874: LIST
 875: LIST
 876: LIST
 877: LIST
 878: PUSH
 879: LD_INT 14
 881: PUSH
 882: LD_INT 1
 884: PUSH
 885: LD_INT 1
 887: PUSH
 888: LD_INT 28
 890: PUSH
 891: EMPTY
 892: LIST
 893: LIST
 894: LIST
 895: LIST
 896: PUSH
 897: LD_INT 14
 899: PUSH
 900: LD_INT 1
 902: PUSH
 903: LD_INT 1
 905: PUSH
 906: LD_INT 28
 908: PUSH
 909: EMPTY
 910: LIST
 911: LIST
 912: LIST
 913: LIST
 914: PUSH
 915: LD_INT 14
 917: PUSH
 918: LD_INT 1
 920: PUSH
 921: LD_INT 1
 923: PUSH
 924: LD_INT 28
 926: PUSH
 927: EMPTY
 928: LIST
 929: LIST
 930: LIST
 931: LIST
 932: PUSH
 933: EMPTY
 934: LIST
 935: LIST
 936: LIST
 937: LIST
 938: LIST
 939: LIST
 940: LIST
 941: PPUSH
 942: CALL 43607 0 2
// MC_SetDefenderLimit ( 3 , 4 ) ;
 946: LD_INT 3
 948: PPUSH
 949: LD_INT 4
 951: PPUSH
 952: CALL 43792 0 2
// MC_SetLabKind ( 4 , [ b_lab_weapon , b_lab_computer , b_lab_siberium , b_lab_opto ] ) ;
 956: LD_INT 4
 958: PPUSH
 959: LD_INT 10
 961: PUSH
 962: LD_INT 12
 964: PUSH
 965: LD_INT 11
 967: PUSH
 968: LD_INT 15
 970: PUSH
 971: EMPTY
 972: LIST
 973: LIST
 974: LIST
 975: LIST
 976: PPUSH
 977: CALL 44349 0 2
// MC_SetCratesArea ( 4 , [ americanCratesArea ] ) ;
 981: LD_INT 4
 983: PPUSH
 984: LD_INT 33
 986: PUSH
 987: EMPTY
 988: LIST
 989: PPUSH
 990: CALL 44442 0 2
// MC_SetAllowedTurretWeapons ( 4 , [ us_double_gun , us_heavy_gun , us_rocket_launcher , us_laser , us_double_laser ] ) ;
 994: LD_INT 4
 996: PPUSH
 997: LD_INT 5
 999: PUSH
1000: LD_INT 6
1002: PUSH
1003: LD_INT 7
1005: PUSH
1006: LD_INT 9
1008: PUSH
1009: LD_INT 10
1011: PUSH
1012: EMPTY
1013: LIST
1014: LIST
1015: LIST
1016: LIST
1017: LIST
1018: PPUSH
1019: CALL 44760 0 2
// MC_SetFactoryExtension ( 4 , 54 , 85 , 2 , [ b_ext_laser , b_ext_track , b_ext_gun , b_ext_rocket , b_ext_radio ] ) ;
1023: LD_INT 4
1025: PPUSH
1026: LD_INT 54
1028: PPUSH
1029: LD_INT 85
1031: PPUSH
1032: LD_INT 2
1034: PPUSH
1035: LD_INT 25
1037: PUSH
1038: LD_INT 16
1040: PUSH
1041: LD_INT 17
1043: PUSH
1044: LD_INT 18
1046: PUSH
1047: LD_INT 22
1049: PUSH
1050: EMPTY
1051: LIST
1052: LIST
1053: LIST
1054: LIST
1055: LIST
1056: PPUSH
1057: CALL 44554 0 5
// MC_SetProduceList ( 4 , [ [ us_morphling , engine_combustion , control_manual , us_rocket_launcher ] , [ us_morphling , engine_combustion , control_manual , us_heavy_gun ] , [ us_morphling , engine_combustion , control_manual , us_rocket_launcher ] , [ us_morphling , engine_combustion , control_manual , us_heavy_gun ] , [ us_morphling , engine_combustion , control_computer , us_cargo_bay ] , [ us_medium_tracked , engine_combustion , control_computer , us_crane ] ] ) ;
1061: LD_INT 4
1063: PPUSH
1064: LD_INT 5
1066: PUSH
1067: LD_INT 1
1069: PUSH
1070: LD_INT 1
1072: PUSH
1073: LD_INT 7
1075: PUSH
1076: EMPTY
1077: LIST
1078: LIST
1079: LIST
1080: LIST
1081: PUSH
1082: LD_INT 5
1084: PUSH
1085: LD_INT 1
1087: PUSH
1088: LD_INT 1
1090: PUSH
1091: LD_INT 6
1093: PUSH
1094: EMPTY
1095: LIST
1096: LIST
1097: LIST
1098: LIST
1099: PUSH
1100: LD_INT 5
1102: PUSH
1103: LD_INT 1
1105: PUSH
1106: LD_INT 1
1108: PUSH
1109: LD_INT 7
1111: PUSH
1112: EMPTY
1113: LIST
1114: LIST
1115: LIST
1116: LIST
1117: PUSH
1118: LD_INT 5
1120: PUSH
1121: LD_INT 1
1123: PUSH
1124: LD_INT 1
1126: PUSH
1127: LD_INT 6
1129: PUSH
1130: EMPTY
1131: LIST
1132: LIST
1133: LIST
1134: LIST
1135: PUSH
1136: LD_INT 5
1138: PUSH
1139: LD_INT 1
1141: PUSH
1142: LD_INT 3
1144: PUSH
1145: LD_INT 12
1147: PUSH
1148: EMPTY
1149: LIST
1150: LIST
1151: LIST
1152: LIST
1153: PUSH
1154: LD_INT 3
1156: PUSH
1157: LD_INT 1
1159: PUSH
1160: LD_INT 3
1162: PUSH
1163: LD_INT 13
1165: PUSH
1166: EMPTY
1167: LIST
1168: LIST
1169: LIST
1170: LIST
1171: PUSH
1172: EMPTY
1173: LIST
1174: LIST
1175: LIST
1176: LIST
1177: LIST
1178: LIST
1179: PPUSH
1180: CALL 43607 0 2
// MC_SetDefenderLimit ( 4 , 4 ) ;
1184: LD_INT 4
1186: PPUSH
1187: LD_INT 4
1189: PPUSH
1190: CALL 43792 0 2
// MC_SetTame ( 4 , powellApe ) ;
1194: LD_INT 4
1196: PPUSH
1197: LD_INT 11
1199: PPUSH
1200: CALL 44173 0 2
// end ;
1204: LD_VAR 0 1
1208: RET
// every 0 0$1 trigger debug do var i ;
1209: LD_EXP 1
1213: IFFALSE 1311
1215: GO 1217
1217: DISABLE
1218: LD_INT 0
1220: PPUSH
// begin enable ;
1221: ENABLE
// for i in FilterAllUnits ( [ [ f_side , 7 ] , [ f_or , [ f_type , unit_human ] , [ f_type , unit_vehicle ] ] , [ f_not , [ f_lives , 1000 ] ] ] ) do
1222: LD_ADDR_VAR 0 1
1226: PUSH
1227: LD_INT 22
1229: PUSH
1230: LD_INT 7
1232: PUSH
1233: EMPTY
1234: LIST
1235: LIST
1236: PUSH
1237: LD_INT 2
1239: PUSH
1240: LD_INT 21
1242: PUSH
1243: LD_INT 1
1245: PUSH
1246: EMPTY
1247: LIST
1248: LIST
1249: PUSH
1250: LD_INT 21
1252: PUSH
1253: LD_INT 2
1255: PUSH
1256: EMPTY
1257: LIST
1258: LIST
1259: PUSH
1260: EMPTY
1261: LIST
1262: LIST
1263: LIST
1264: PUSH
1265: LD_INT 3
1267: PUSH
1268: LD_INT 24
1270: PUSH
1271: LD_INT 1000
1273: PUSH
1274: EMPTY
1275: LIST
1276: LIST
1277: PUSH
1278: EMPTY
1279: LIST
1280: LIST
1281: PUSH
1282: EMPTY
1283: LIST
1284: LIST
1285: LIST
1286: PPUSH
1287: CALL_OW 69
1291: PUSH
1292: FOR_IN
1293: IFFALSE 1309
// SetLives ( i , 1000 ) ;
1295: LD_VAR 0 1
1299: PPUSH
1300: LD_INT 1000
1302: PPUSH
1303: CALL_OW 234
1307: GO 1292
1309: POP
1310: POP
// end ; end_of_file
1311: PPOPN 1
1313: END
// export JMM , Roth , Lisa , Donaldson , Bobby , Cyrus , Denis , Brown , Gladstone , Houten , Cornel , Gary , Frank , Kikuchi , Simms , Joan , DeltaDoctor , Connie ; export Gossudarov , Kirilenkova , Titov , Fadeev , Dolgov , Petrosyan , Scholtze , Oblukov , Kapitsova , Lipshchin , Petrovova , Kovalyuk , Kuzmov , Karamazov ; export Burlak , Belkov , Gnyevko ; export function PrepareAlliance ; var i , veh , selected , tmp ; begin
1314: LD_INT 0
1316: PPUSH
1317: PPUSH
1318: PPUSH
1319: PPUSH
1320: PPUSH
// uc_side := 7 ;
1321: LD_ADDR_OWVAR 20
1325: PUSH
1326: LD_INT 7
1328: ST_TO_ADDR
// tmp := [ ] ;
1329: LD_ADDR_VAR 0 5
1333: PUSH
1334: EMPTY
1335: ST_TO_ADDR
// JMM := PrepareUnit ( JMM , ( not debug ) , 14a_ ) ;
1336: LD_ADDR_EXP 12
1340: PUSH
1341: LD_STRING JMM
1343: PPUSH
1344: LD_EXP 1
1348: NOT
1349: PPUSH
1350: LD_STRING 14a_
1352: PPUSH
1353: CALL 49865 0 3
1357: ST_TO_ADDR
// Burlak := PrepareUnit ( Burlak , ( not debug ) , 14a_ ) ;
1358: LD_ADDR_EXP 44
1362: PUSH
1363: LD_STRING Burlak
1365: PPUSH
1366: LD_EXP 1
1370: NOT
1371: PPUSH
1372: LD_STRING 14a_
1374: PPUSH
1375: CALL 49865 0 3
1379: ST_TO_ADDR
// Joan := PrepareUnit ( Joan , ( not debug ) , 13a_ ) ;
1380: LD_ADDR_EXP 27
1384: PUSH
1385: LD_STRING Joan
1387: PPUSH
1388: LD_EXP 1
1392: NOT
1393: PPUSH
1394: LD_STRING 13a_
1396: PPUSH
1397: CALL 49865 0 3
1401: ST_TO_ADDR
// Roth := PrepareUnit ( Roth , ( not debug ) , 13a_ ) ;
1402: LD_ADDR_EXP 13
1406: PUSH
1407: LD_STRING Roth
1409: PPUSH
1410: LD_EXP 1
1414: NOT
1415: PPUSH
1416: LD_STRING 13a_
1418: PPUSH
1419: CALL 49865 0 3
1423: ST_TO_ADDR
// Gossudarov := PrepareUnit ( Gossudarov , ( not debug ) , 13a_ ) ;
1424: LD_ADDR_EXP 30
1428: PUSH
1429: LD_STRING Gossudarov
1431: PPUSH
1432: LD_EXP 1
1436: NOT
1437: PPUSH
1438: LD_STRING 13a_
1440: PPUSH
1441: CALL 49865 0 3
1445: ST_TO_ADDR
// DeltaDoctor := PrepareUnit ( DeltaDoctor , ( not debug ) , 13a_ ) ;
1446: LD_ADDR_EXP 28
1450: PUSH
1451: LD_STRING DeltaDoctor
1453: PPUSH
1454: LD_EXP 1
1458: NOT
1459: PPUSH
1460: LD_STRING 13a_
1462: PPUSH
1463: CALL 49865 0 3
1467: ST_TO_ADDR
// if DeltaDoctor then
1468: LD_EXP 28
1472: IFFALSE 1490
// tmp := tmp ^ DeltaDoctor ;
1474: LD_ADDR_VAR 0 5
1478: PUSH
1479: LD_VAR 0 5
1483: PUSH
1484: LD_EXP 28
1488: ADD
1489: ST_TO_ADDR
// Simms := PrepareUnit ( Simms , ( not debug ) , 13a_ ) ;
1490: LD_ADDR_EXP 26
1494: PUSH
1495: LD_STRING Simms
1497: PPUSH
1498: LD_EXP 1
1502: NOT
1503: PPUSH
1504: LD_STRING 13a_
1506: PPUSH
1507: CALL 49865 0 3
1511: ST_TO_ADDR
// if Simms then
1512: LD_EXP 26
1516: IFFALSE 1534
// tmp := tmp ^ Simms ;
1518: LD_ADDR_VAR 0 5
1522: PUSH
1523: LD_VAR 0 5
1527: PUSH
1528: LD_EXP 26
1532: ADD
1533: ST_TO_ADDR
// Frank := PrepareUnit ( Frank , ( not debug ) , 13a_ ) ;
1534: LD_ADDR_EXP 24
1538: PUSH
1539: LD_STRING Frank
1541: PPUSH
1542: LD_EXP 1
1546: NOT
1547: PPUSH
1548: LD_STRING 13a_
1550: PPUSH
1551: CALL 49865 0 3
1555: ST_TO_ADDR
// if Frank then
1556: LD_EXP 24
1560: IFFALSE 1578
// tmp := tmp ^ Frank ;
1562: LD_ADDR_VAR 0 5
1566: PUSH
1567: LD_VAR 0 5
1571: PUSH
1572: LD_EXP 24
1576: ADD
1577: ST_TO_ADDR
// Kirilenkova := PrepareUnit ( Kirilenkova , ( not debug ) , 13a_ ) ;
1578: LD_ADDR_EXP 31
1582: PUSH
1583: LD_STRING Kirilenkova
1585: PPUSH
1586: LD_EXP 1
1590: NOT
1591: PPUSH
1592: LD_STRING 13a_
1594: PPUSH
1595: CALL 49865 0 3
1599: ST_TO_ADDR
// if Kirilenkova then
1600: LD_EXP 31
1604: IFFALSE 1622
// tmp := tmp ^ Kirilenkova ;
1606: LD_ADDR_VAR 0 5
1610: PUSH
1611: LD_VAR 0 5
1615: PUSH
1616: LD_EXP 31
1620: ADD
1621: ST_TO_ADDR
// Titov := PrepareUnit ( Titov , ( not debug ) , 13a_ ) ;
1622: LD_ADDR_EXP 32
1626: PUSH
1627: LD_STRING Titov
1629: PPUSH
1630: LD_EXP 1
1634: NOT
1635: PPUSH
1636: LD_STRING 13a_
1638: PPUSH
1639: CALL 49865 0 3
1643: ST_TO_ADDR
// if Titov then
1644: LD_EXP 32
1648: IFFALSE 1666
// tmp := tmp ^ Titov ;
1650: LD_ADDR_VAR 0 5
1654: PUSH
1655: LD_VAR 0 5
1659: PUSH
1660: LD_EXP 32
1664: ADD
1665: ST_TO_ADDR
// Fadeev := PrepareUnit ( Fadeev , ( not debug ) , 13a_ ) ;
1666: LD_ADDR_EXP 33
1670: PUSH
1671: LD_STRING Fadeev
1673: PPUSH
1674: LD_EXP 1
1678: NOT
1679: PPUSH
1680: LD_STRING 13a_
1682: PPUSH
1683: CALL 49865 0 3
1687: ST_TO_ADDR
// if Fadeev then
1688: LD_EXP 33
1692: IFFALSE 1710
// tmp := tmp ^ Fadeev ;
1694: LD_ADDR_VAR 0 5
1698: PUSH
1699: LD_VAR 0 5
1703: PUSH
1704: LD_EXP 33
1708: ADD
1709: ST_TO_ADDR
// Dolgov := PrepareUnit ( Dolgov , ( not debug ) , 13a_ ) ;
1710: LD_ADDR_EXP 34
1714: PUSH
1715: LD_STRING Dolgov
1717: PPUSH
1718: LD_EXP 1
1722: NOT
1723: PPUSH
1724: LD_STRING 13a_
1726: PPUSH
1727: CALL 49865 0 3
1731: ST_TO_ADDR
// if Dolgov then
1732: LD_EXP 34
1736: IFFALSE 1754
// tmp := tmp ^ Dolgov ;
1738: LD_ADDR_VAR 0 5
1742: PUSH
1743: LD_VAR 0 5
1747: PUSH
1748: LD_EXP 34
1752: ADD
1753: ST_TO_ADDR
// Petrosyan := PrepareUnit ( Petrosyan , ( not debug ) , 13a_ ) ;
1754: LD_ADDR_EXP 35
1758: PUSH
1759: LD_STRING Petrosyan
1761: PPUSH
1762: LD_EXP 1
1766: NOT
1767: PPUSH
1768: LD_STRING 13a_
1770: PPUSH
1771: CALL 49865 0 3
1775: ST_TO_ADDR
// if Petrosyan then
1776: LD_EXP 35
1780: IFFALSE 1798
// tmp := tmp ^ Petrosyan ;
1782: LD_ADDR_VAR 0 5
1786: PUSH
1787: LD_VAR 0 5
1791: PUSH
1792: LD_EXP 35
1796: ADD
1797: ST_TO_ADDR
// Scholtze := PrepareUnit ( Scholtze , ( not debug ) , 13a_ ) ;
1798: LD_ADDR_EXP 36
1802: PUSH
1803: LD_STRING Scholtze
1805: PPUSH
1806: LD_EXP 1
1810: NOT
1811: PPUSH
1812: LD_STRING 13a_
1814: PPUSH
1815: CALL 49865 0 3
1819: ST_TO_ADDR
// if Scholtze then
1820: LD_EXP 36
1824: IFFALSE 1842
// tmp := tmp ^ Scholtze ;
1826: LD_ADDR_VAR 0 5
1830: PUSH
1831: LD_VAR 0 5
1835: PUSH
1836: LD_EXP 36
1840: ADD
1841: ST_TO_ADDR
// Oblukov := PrepareUnit ( Oblukov , ( not debug ) , 13a_ ) ;
1842: LD_ADDR_EXP 37
1846: PUSH
1847: LD_STRING Oblukov
1849: PPUSH
1850: LD_EXP 1
1854: NOT
1855: PPUSH
1856: LD_STRING 13a_
1858: PPUSH
1859: CALL 49865 0 3
1863: ST_TO_ADDR
// if Oblukov then
1864: LD_EXP 37
1868: IFFALSE 1886
// tmp := tmp ^ Oblukov ;
1870: LD_ADDR_VAR 0 5
1874: PUSH
1875: LD_VAR 0 5
1879: PUSH
1880: LD_EXP 37
1884: ADD
1885: ST_TO_ADDR
// Kapitsova := PrepareUnit ( Kapitsova , ( not debug ) , 13a_ ) ;
1886: LD_ADDR_EXP 38
1890: PUSH
1891: LD_STRING Kapitsova
1893: PPUSH
1894: LD_EXP 1
1898: NOT
1899: PPUSH
1900: LD_STRING 13a_
1902: PPUSH
1903: CALL 49865 0 3
1907: ST_TO_ADDR
// if Kapitsova then
1908: LD_EXP 38
1912: IFFALSE 1930
// tmp := tmp ^ Kapitsova ;
1914: LD_ADDR_VAR 0 5
1918: PUSH
1919: LD_VAR 0 5
1923: PUSH
1924: LD_EXP 38
1928: ADD
1929: ST_TO_ADDR
// Lipshchin := PrepareUnit ( Lipshchin , ( not debug ) , 13a_ ) ;
1930: LD_ADDR_EXP 39
1934: PUSH
1935: LD_STRING Lipshchin
1937: PPUSH
1938: LD_EXP 1
1942: NOT
1943: PPUSH
1944: LD_STRING 13a_
1946: PPUSH
1947: CALL 49865 0 3
1951: ST_TO_ADDR
// if Lipshchin then
1952: LD_EXP 39
1956: IFFALSE 1974
// tmp := tmp ^ Lipshchin ;
1958: LD_ADDR_VAR 0 5
1962: PUSH
1963: LD_VAR 0 5
1967: PUSH
1968: LD_EXP 39
1972: ADD
1973: ST_TO_ADDR
// Petrovova := PrepareUnit ( Petrovova , ( not debug ) , 13a_ ) ;
1974: LD_ADDR_EXP 40
1978: PUSH
1979: LD_STRING Petrovova
1981: PPUSH
1982: LD_EXP 1
1986: NOT
1987: PPUSH
1988: LD_STRING 13a_
1990: PPUSH
1991: CALL 49865 0 3
1995: ST_TO_ADDR
// if Petrovova then
1996: LD_EXP 40
2000: IFFALSE 2018
// tmp := tmp ^ Petrovova ;
2002: LD_ADDR_VAR 0 5
2006: PUSH
2007: LD_VAR 0 5
2011: PUSH
2012: LD_EXP 40
2016: ADD
2017: ST_TO_ADDR
// Kovalyuk := PrepareUnit ( Kovalyuk , ( not debug ) , 13a_ ) ;
2018: LD_ADDR_EXP 41
2022: PUSH
2023: LD_STRING Kovalyuk
2025: PPUSH
2026: LD_EXP 1
2030: NOT
2031: PPUSH
2032: LD_STRING 13a_
2034: PPUSH
2035: CALL 49865 0 3
2039: ST_TO_ADDR
// if Kovalyuk then
2040: LD_EXP 41
2044: IFFALSE 2062
// tmp := tmp ^ Kovalyuk ;
2046: LD_ADDR_VAR 0 5
2050: PUSH
2051: LD_VAR 0 5
2055: PUSH
2056: LD_EXP 41
2060: ADD
2061: ST_TO_ADDR
// Kuzmov := PrepareUnit ( Kuzmov , ( not debug ) , 13a_ ) ;
2062: LD_ADDR_EXP 42
2066: PUSH
2067: LD_STRING Kuzmov
2069: PPUSH
2070: LD_EXP 1
2074: NOT
2075: PPUSH
2076: LD_STRING 13a_
2078: PPUSH
2079: CALL 49865 0 3
2083: ST_TO_ADDR
// if Kuzmov then
2084: LD_EXP 42
2088: IFFALSE 2106
// tmp := tmp ^ Kuzmov ;
2090: LD_ADDR_VAR 0 5
2094: PUSH
2095: LD_VAR 0 5
2099: PUSH
2100: LD_EXP 42
2104: ADD
2105: ST_TO_ADDR
// Karamazov := PrepareUnit ( Karamazov , ( not debug ) , 13a_ ) ;
2106: LD_ADDR_EXP 43
2110: PUSH
2111: LD_STRING Karamazov
2113: PPUSH
2114: LD_EXP 1
2118: NOT
2119: PPUSH
2120: LD_STRING 13a_
2122: PPUSH
2123: CALL 49865 0 3
2127: ST_TO_ADDR
// if Karamazov then
2128: LD_EXP 43
2132: IFFALSE 2150
// tmp := tmp ^ Karamazov ;
2134: LD_ADDR_VAR 0 5
2138: PUSH
2139: LD_VAR 0 5
2143: PUSH
2144: LD_EXP 43
2148: ADD
2149: ST_TO_ADDR
// Belkov := PrepareUnit ( Belkov , ( not debug ) , 13a_ ) ;
2150: LD_ADDR_EXP 45
2154: PUSH
2155: LD_STRING Belkov
2157: PPUSH
2158: LD_EXP 1
2162: NOT
2163: PPUSH
2164: LD_STRING 13a_
2166: PPUSH
2167: CALL 49865 0 3
2171: ST_TO_ADDR
// if Belkov then
2172: LD_EXP 45
2176: IFFALSE 2194
// tmp := tmp ^ Belkov ;
2178: LD_ADDR_VAR 0 5
2182: PUSH
2183: LD_VAR 0 5
2187: PUSH
2188: LD_EXP 45
2192: ADD
2193: ST_TO_ADDR
// Gnyevko := PrepareUnit ( Gnyevko , ( not debug ) , 13a_ ) ;
2194: LD_ADDR_EXP 46
2198: PUSH
2199: LD_STRING Gnyevko
2201: PPUSH
2202: LD_EXP 1
2206: NOT
2207: PPUSH
2208: LD_STRING 13a_
2210: PPUSH
2211: CALL 49865 0 3
2215: ST_TO_ADDR
// if Gnyevko then
2216: LD_EXP 46
2220: IFFALSE 2238
// tmp := tmp ^ Gnyevko ;
2222: LD_ADDR_VAR 0 5
2226: PUSH
2227: LD_VAR 0 5
2231: PUSH
2232: LD_EXP 46
2236: ADD
2237: ST_TO_ADDR
// Connie = NewCharacter ( Coonie ) ;
2238: LD_ADDR_EXP 29
2242: PUSH
2243: LD_STRING Coonie
2245: PPUSH
2246: CALL_OW 25
2250: ST_TO_ADDR
// if not Lisa then
2251: LD_EXP 14
2255: NOT
2256: IFFALSE 2302
// begin Lisa := PrepareUnit ( Lisa , ( not debug ) , 13a_ ) ;
2258: LD_ADDR_EXP 14
2262: PUSH
2263: LD_STRING Lisa
2265: PPUSH
2266: LD_EXP 1
2270: NOT
2271: PPUSH
2272: LD_STRING 13a_
2274: PPUSH
2275: CALL 49865 0 3
2279: ST_TO_ADDR
// if Lisa then
2280: LD_EXP 14
2284: IFFALSE 2302
// tmp := tmp ^ Lisa ;
2286: LD_ADDR_VAR 0 5
2290: PUSH
2291: LD_VAR 0 5
2295: PUSH
2296: LD_EXP 14
2300: ADD
2301: ST_TO_ADDR
// end ; if not Donaldson then
2302: LD_EXP 15
2306: NOT
2307: IFFALSE 2353
// begin Donaldson := PrepareUnit ( Donaldson , ( not debug ) , 13a_ ) ;
2309: LD_ADDR_EXP 15
2313: PUSH
2314: LD_STRING Donaldson
2316: PPUSH
2317: LD_EXP 1
2321: NOT
2322: PPUSH
2323: LD_STRING 13a_
2325: PPUSH
2326: CALL 49865 0 3
2330: ST_TO_ADDR
// if Donaldson then
2331: LD_EXP 15
2335: IFFALSE 2353
// tmp := tmp ^ Donaldson ;
2337: LD_ADDR_VAR 0 5
2341: PUSH
2342: LD_VAR 0 5
2346: PUSH
2347: LD_EXP 15
2351: ADD
2352: ST_TO_ADDR
// end ; if not Bobby then
2353: LD_EXP 16
2357: NOT
2358: IFFALSE 2404
// begin Bobby := PrepareUnit ( Bobby , ( not debug ) , 13a_ ) ;
2360: LD_ADDR_EXP 16
2364: PUSH
2365: LD_STRING Bobby
2367: PPUSH
2368: LD_EXP 1
2372: NOT
2373: PPUSH
2374: LD_STRING 13a_
2376: PPUSH
2377: CALL 49865 0 3
2381: ST_TO_ADDR
// if Bobby then
2382: LD_EXP 16
2386: IFFALSE 2404
// tmp := tmp ^ Bobby ;
2388: LD_ADDR_VAR 0 5
2392: PUSH
2393: LD_VAR 0 5
2397: PUSH
2398: LD_EXP 16
2402: ADD
2403: ST_TO_ADDR
// end ; if not Cyrus then
2404: LD_EXP 17
2408: NOT
2409: IFFALSE 2455
// begin Cyrus := PrepareUnit ( Cyrus , ( not debug ) , 13a_ ) ;
2411: LD_ADDR_EXP 17
2415: PUSH
2416: LD_STRING Cyrus
2418: PPUSH
2419: LD_EXP 1
2423: NOT
2424: PPUSH
2425: LD_STRING 13a_
2427: PPUSH
2428: CALL 49865 0 3
2432: ST_TO_ADDR
// if Cyrus then
2433: LD_EXP 17
2437: IFFALSE 2455
// tmp := tmp ^ Cyrus ;
2439: LD_ADDR_VAR 0 5
2443: PUSH
2444: LD_VAR 0 5
2448: PUSH
2449: LD_EXP 17
2453: ADD
2454: ST_TO_ADDR
// end ; if not Brown then
2455: LD_EXP 19
2459: NOT
2460: IFFALSE 2506
// begin Brown := PrepareUnit ( Brown , ( not debug ) , 13a_ ) ;
2462: LD_ADDR_EXP 19
2466: PUSH
2467: LD_STRING Brown
2469: PPUSH
2470: LD_EXP 1
2474: NOT
2475: PPUSH
2476: LD_STRING 13a_
2478: PPUSH
2479: CALL 49865 0 3
2483: ST_TO_ADDR
// if Brown then
2484: LD_EXP 19
2488: IFFALSE 2506
// tmp := tmp ^ Brown ;
2490: LD_ADDR_VAR 0 5
2494: PUSH
2495: LD_VAR 0 5
2499: PUSH
2500: LD_EXP 19
2504: ADD
2505: ST_TO_ADDR
// end ; if not Gladstone then
2506: LD_EXP 20
2510: NOT
2511: IFFALSE 2557
// begin Gladstone := PrepareUnit ( Gladstone , ( not debug ) , 13a_ ) ;
2513: LD_ADDR_EXP 20
2517: PUSH
2518: LD_STRING Gladstone
2520: PPUSH
2521: LD_EXP 1
2525: NOT
2526: PPUSH
2527: LD_STRING 13a_
2529: PPUSH
2530: CALL 49865 0 3
2534: ST_TO_ADDR
// if Gladstone then
2535: LD_EXP 20
2539: IFFALSE 2557
// tmp := tmp ^ Gladstone ;
2541: LD_ADDR_VAR 0 5
2545: PUSH
2546: LD_VAR 0 5
2550: PUSH
2551: LD_EXP 20
2555: ADD
2556: ST_TO_ADDR
// end ; if not Cornel then
2557: LD_EXP 22
2561: NOT
2562: IFFALSE 2608
// begin Cornel := PrepareUnit ( Cornel , ( not debug ) , 13a_ ) ;
2564: LD_ADDR_EXP 22
2568: PUSH
2569: LD_STRING Cornel
2571: PPUSH
2572: LD_EXP 1
2576: NOT
2577: PPUSH
2578: LD_STRING 13a_
2580: PPUSH
2581: CALL 49865 0 3
2585: ST_TO_ADDR
// if Cornel then
2586: LD_EXP 22
2590: IFFALSE 2608
// tmp := tmp ^ Cornel ;
2592: LD_ADDR_VAR 0 5
2596: PUSH
2597: LD_VAR 0 5
2601: PUSH
2602: LD_EXP 22
2606: ADD
2607: ST_TO_ADDR
// end ; if not Houten then
2608: LD_EXP 21
2612: NOT
2613: IFFALSE 2659
// begin Houten := PrepareUnit ( Houten , ( not debug ) , 13a_ ) ;
2615: LD_ADDR_EXP 21
2619: PUSH
2620: LD_STRING Houten
2622: PPUSH
2623: LD_EXP 1
2627: NOT
2628: PPUSH
2629: LD_STRING 13a_
2631: PPUSH
2632: CALL 49865 0 3
2636: ST_TO_ADDR
// if Houten then
2637: LD_EXP 21
2641: IFFALSE 2659
// tmp := tmp ^ Houten ;
2643: LD_ADDR_VAR 0 5
2647: PUSH
2648: LD_VAR 0 5
2652: PUSH
2653: LD_EXP 21
2657: ADD
2658: ST_TO_ADDR
// end ; if not Gary then
2659: LD_EXP 23
2663: NOT
2664: IFFALSE 2710
// begin Gary := PrepareUnit ( Gary , ( not debug ) , 13a_ ) ;
2666: LD_ADDR_EXP 23
2670: PUSH
2671: LD_STRING Gary
2673: PPUSH
2674: LD_EXP 1
2678: NOT
2679: PPUSH
2680: LD_STRING 13a_
2682: PPUSH
2683: CALL 49865 0 3
2687: ST_TO_ADDR
// if Gary then
2688: LD_EXP 23
2692: IFFALSE 2710
// tmp := tmp ^ Gary ;
2694: LD_ADDR_VAR 0 5
2698: PUSH
2699: LD_VAR 0 5
2703: PUSH
2704: LD_EXP 23
2708: ADD
2709: ST_TO_ADDR
// end ; if not Kikuchi then
2710: LD_EXP 25
2714: NOT
2715: IFFALSE 2761
// begin Kikuchi := PrepareUnit ( Kikuchi , ( not debug ) , 13a_ ) ;
2717: LD_ADDR_EXP 25
2721: PUSH
2722: LD_STRING Kikuchi
2724: PPUSH
2725: LD_EXP 1
2729: NOT
2730: PPUSH
2731: LD_STRING 13a_
2733: PPUSH
2734: CALL 49865 0 3
2738: ST_TO_ADDR
// if Kikuchi then
2739: LD_EXP 25
2743: IFFALSE 2761
// tmp := tmp ^ Kikuchi ;
2745: LD_ADDR_VAR 0 5
2749: PUSH
2750: LD_VAR 0 5
2754: PUSH
2755: LD_EXP 25
2759: ADD
2760: ST_TO_ADDR
// end ; tmp := tmp union CreateCharacterSet ( 13a_others ) ;
2761: LD_ADDR_VAR 0 5
2765: PUSH
2766: LD_VAR 0 5
2770: PUSH
2771: LD_STRING 13a_others
2773: PPUSH
2774: CALL_OW 31
2778: UNION
2779: ST_TO_ADDR
// tmp := tmp diff 0 ;
2780: LD_ADDR_VAR 0 5
2784: PUSH
2785: LD_VAR 0 5
2789: PUSH
2790: LD_INT 0
2792: DIFF
2793: ST_TO_ADDR
// if tmp < 15 then
2794: LD_VAR 0 5
2798: PUSH
2799: LD_INT 15
2801: LESS
2802: IFFALSE 2890
// for i = 15 downto tmp do
2804: LD_ADDR_VAR 0 2
2808: PUSH
2809: DOUBLE
2810: LD_INT 15
2812: INC
2813: ST_TO_ADDR
2814: LD_VAR 0 5
2818: PUSH
2819: FOR_DOWNTO
2820: IFFALSE 2888
// begin uc_nation := [ 1 , 3 ] [ rand ( 1 , 2 ) ] ;
2822: LD_ADDR_OWVAR 21
2826: PUSH
2827: LD_INT 1
2829: PUSH
2830: LD_INT 3
2832: PUSH
2833: EMPTY
2834: LIST
2835: LIST
2836: PUSH
2837: LD_INT 1
2839: PPUSH
2840: LD_INT 2
2842: PPUSH
2843: CALL_OW 12
2847: ARRAY
2848: ST_TO_ADDR
// PrepareHuman ( false , rand ( 1 , 4 ) , 8 ) ;
2849: LD_INT 0
2851: PPUSH
2852: LD_INT 1
2854: PPUSH
2855: LD_INT 4
2857: PPUSH
2858: CALL_OW 12
2862: PPUSH
2863: LD_INT 8
2865: PPUSH
2866: CALL_OW 380
// tmp := tmp ^ CreateHuman ;
2870: LD_ADDR_VAR 0 5
2874: PUSH
2875: LD_VAR 0 5
2879: PUSH
2880: CALL_OW 44
2884: ADD
2885: ST_TO_ADDR
// end ;
2886: GO 2819
2888: POP
2889: POP
// if not debug then
2890: LD_EXP 1
2894: NOT
2895: IFFALSE 3067
// selected = CharacterSelection (  , [ 15 , 14 , 13 ] [ Difficulty ] , [ 15 , 14 , 13 ] [ Difficulty ] , [ sel_dont_change_class , JMM , Burlak , Roth , Joan , Denis , Gossudarov , sel_not_hired , sel_changeable , sel_change_class ] ^ tmp , [ class_soldier , class_scientistic , [ class_engineer , 1 ] , class_mechanic , [ class_sniper , 0 , 3 ] , [ class_bazooker , 0 , 3 ] ] ) else
2897: LD_ADDR_VAR 0 4
2901: PUSH
2902: LD_STRING 
2904: PPUSH
2905: LD_INT 15
2907: PUSH
2908: LD_INT 14
2910: PUSH
2911: LD_INT 13
2913: PUSH
2914: EMPTY
2915: LIST
2916: LIST
2917: LIST
2918: PUSH
2919: LD_OWVAR 67
2923: ARRAY
2924: PPUSH
2925: LD_INT 15
2927: PUSH
2928: LD_INT 14
2930: PUSH
2931: LD_INT 13
2933: PUSH
2934: EMPTY
2935: LIST
2936: LIST
2937: LIST
2938: PUSH
2939: LD_OWVAR 67
2943: ARRAY
2944: PPUSH
2945: LD_INT -6
2947: PUSH
2948: LD_EXP 12
2952: PUSH
2953: LD_EXP 44
2957: PUSH
2958: LD_EXP 13
2962: PUSH
2963: LD_EXP 27
2967: PUSH
2968: LD_EXP 18
2972: PUSH
2973: LD_EXP 30
2977: PUSH
2978: LD_INT -2
2980: PUSH
2981: LD_INT -3
2983: PUSH
2984: LD_INT -5
2986: PUSH
2987: EMPTY
2988: LIST
2989: LIST
2990: LIST
2991: LIST
2992: LIST
2993: LIST
2994: LIST
2995: LIST
2996: LIST
2997: LIST
2998: PUSH
2999: LD_VAR 0 5
3003: ADD
3004: PPUSH
3005: LD_INT 1
3007: PUSH
3008: LD_INT 4
3010: PUSH
3011: LD_INT 2
3013: PUSH
3014: LD_INT 1
3016: PUSH
3017: EMPTY
3018: LIST
3019: LIST
3020: PUSH
3021: LD_INT 3
3023: PUSH
3024: LD_INT 5
3026: PUSH
3027: LD_INT 0
3029: PUSH
3030: LD_INT 3
3032: PUSH
3033: EMPTY
3034: LIST
3035: LIST
3036: LIST
3037: PUSH
3038: LD_INT 9
3040: PUSH
3041: LD_INT 0
3043: PUSH
3044: LD_INT 3
3046: PUSH
3047: EMPTY
3048: LIST
3049: LIST
3050: LIST
3051: PUSH
3052: EMPTY
3053: LIST
3054: LIST
3055: LIST
3056: LIST
3057: LIST
3058: LIST
3059: PPUSH
3060: CALL_OW 42
3064: ST_TO_ADDR
3065: GO 3146
// selected := [ Titov , Fadeev , Dolgov , Petrosyan , Scholtze , Oblukov , Kapitsova , Lipshchin , Petrovova , Kovalyuk , Kuzmov , Karamazov ] ;
3067: LD_ADDR_VAR 0 4
3071: PUSH
3072: LD_EXP 32
3076: PUSH
3077: LD_EXP 33
3081: PUSH
3082: LD_EXP 34
3086: PUSH
3087: LD_EXP 35
3091: PUSH
3092: LD_EXP 36
3096: PUSH
3097: LD_EXP 37
3101: PUSH
3102: LD_EXP 38
3106: PUSH
3107: LD_EXP 39
3111: PUSH
3112: LD_EXP 40
3116: PUSH
3117: LD_EXP 41
3121: PUSH
3122: LD_EXP 42
3126: PUSH
3127: LD_EXP 43
3131: PUSH
3132: EMPTY
3133: LIST
3134: LIST
3135: LIST
3136: LIST
3137: LIST
3138: LIST
3139: LIST
3140: LIST
3141: LIST
3142: LIST
3143: LIST
3144: LIST
3145: ST_TO_ADDR
// uc_nation := 1 ;
3146: LD_ADDR_OWVAR 21
3150: PUSH
3151: LD_INT 1
3153: ST_TO_ADDR
// PrepareVehicle ( us_morphling , engine_siberite , control_manual , us_heavy_gun , 100 ) ;
3154: LD_INT 5
3156: PPUSH
3157: LD_INT 3
3159: PPUSH
3160: LD_INT 1
3162: PPUSH
3163: LD_INT 6
3165: PPUSH
3166: LD_INT 100
3168: PPUSH
3169: CALL 56831 0 5
// veh := CreateVehicle ;
3173: LD_ADDR_VAR 0 3
3177: PUSH
3178: CALL_OW 45
3182: ST_TO_ADDR
// SetMark ( veh , - 7 ) ;
3183: LD_VAR 0 3
3187: PPUSH
3188: LD_INT 7
3190: NEG
3191: PPUSH
3192: CALL_OW 242
// SetDir ( veh , 3 ) ;
3196: LD_VAR 0 3
3200: PPUSH
3201: LD_INT 3
3203: PPUSH
3204: CALL_OW 233
// PlaceUnitArea ( veh , allianceJMMSpawnArea , false ) ;
3208: LD_VAR 0 3
3212: PPUSH
3213: LD_INT 31
3215: PPUSH
3216: LD_INT 0
3218: PPUSH
3219: CALL_OW 49
// PlaceHumanInUnit ( JMM , veh ) ;
3223: LD_EXP 12
3227: PPUSH
3228: LD_VAR 0 3
3232: PPUSH
3233: CALL_OW 52
// if Joan then
3237: LD_EXP 27
3241: IFFALSE 3313
// begin PrepareVehicle ( us_medium_tracked , engine_siberite , control_manual , us_radar , 100 ) ;
3243: LD_INT 3
3245: PPUSH
3246: LD_INT 3
3248: PPUSH
3249: LD_INT 1
3251: PPUSH
3252: LD_INT 11
3254: PPUSH
3255: LD_INT 100
3257: PPUSH
3258: CALL 56831 0 5
// veh := CreateVehicle ;
3262: LD_ADDR_VAR 0 3
3266: PUSH
3267: CALL_OW 45
3271: ST_TO_ADDR
// SetDir ( veh , 3 ) ;
3272: LD_VAR 0 3
3276: PPUSH
3277: LD_INT 3
3279: PPUSH
3280: CALL_OW 233
// PlaceUnitArea ( veh , allianceSpawnArea , false ) ;
3284: LD_VAR 0 3
3288: PPUSH
3289: LD_INT 30
3291: PPUSH
3292: LD_INT 0
3294: PPUSH
3295: CALL_OW 49
// PlaceHumanInUnit ( Joan , veh ) ;
3299: LD_EXP 27
3303: PPUSH
3304: LD_VAR 0 3
3308: PPUSH
3309: CALL_OW 52
// end ; if Roth then
3313: LD_EXP 13
3317: IFFALSE 3389
// begin PrepareVehicle ( us_medium_tracked , engine_siberite , control_manual , us_radar , 100 ) ;
3319: LD_INT 3
3321: PPUSH
3322: LD_INT 3
3324: PPUSH
3325: LD_INT 1
3327: PPUSH
3328: LD_INT 11
3330: PPUSH
3331: LD_INT 100
3333: PPUSH
3334: CALL 56831 0 5
// veh := CreateVehicle ;
3338: LD_ADDR_VAR 0 3
3342: PUSH
3343: CALL_OW 45
3347: ST_TO_ADDR
// SetDir ( veh , 3 ) ;
3348: LD_VAR 0 3
3352: PPUSH
3353: LD_INT 3
3355: PPUSH
3356: CALL_OW 233
// PlaceUnitArea ( veh , allianceSpawnArea , false ) ;
3360: LD_VAR 0 3
3364: PPUSH
3365: LD_INT 30
3367: PPUSH
3368: LD_INT 0
3370: PPUSH
3371: CALL_OW 49
// PlaceHumanInUnit ( Roth , veh ) ;
3375: LD_EXP 13
3379: PPUSH
3380: LD_VAR 0 3
3384: PPUSH
3385: CALL_OW 52
// end ; if Denis then
3389: LD_EXP 18
3393: IFFALSE 3465
// begin PrepareVehicle ( us_morphling , engine_siberite , control_manual , us_laser , 100 ) ;
3395: LD_INT 5
3397: PPUSH
3398: LD_INT 3
3400: PPUSH
3401: LD_INT 1
3403: PPUSH
3404: LD_INT 9
3406: PPUSH
3407: LD_INT 100
3409: PPUSH
3410: CALL 56831 0 5
// veh := CreateVehicle ;
3414: LD_ADDR_VAR 0 3
3418: PUSH
3419: CALL_OW 45
3423: ST_TO_ADDR
// SetDir ( veh , 3 ) ;
3424: LD_VAR 0 3
3428: PPUSH
3429: LD_INT 3
3431: PPUSH
3432: CALL_OW 233
// PlaceUnitArea ( veh , allianceSpawnArea , false ) ;
3436: LD_VAR 0 3
3440: PPUSH
3441: LD_INT 30
3443: PPUSH
3444: LD_INT 0
3446: PPUSH
3447: CALL_OW 49
// PlaceHumanInUnit ( Denis , veh ) ;
3451: LD_EXP 18
3455: PPUSH
3456: LD_VAR 0 3
3460: PPUSH
3461: CALL_OW 52
// end ; uc_nation := 3 ;
3465: LD_ADDR_OWVAR 21
3469: PUSH
3470: LD_INT 3
3472: ST_TO_ADDR
// PrepareVehicle ( ru_medium_tracked , engine_siberite , control_manual , ru_rocket_launcher , 100 ) ;
3473: LD_INT 22
3475: PPUSH
3476: LD_INT 3
3478: PPUSH
3479: LD_INT 1
3481: PPUSH
3482: LD_INT 45
3484: PPUSH
3485: LD_INT 100
3487: PPUSH
3488: CALL 56831 0 5
// veh := CreateVehicle ;
3492: LD_ADDR_VAR 0 3
3496: PUSH
3497: CALL_OW 45
3501: ST_TO_ADDR
// SetMark ( veh , - 7 ) ;
3502: LD_VAR 0 3
3506: PPUSH
3507: LD_INT 7
3509: NEG
3510: PPUSH
3511: CALL_OW 242
// SetDir ( veh , 3 ) ;
3515: LD_VAR 0 3
3519: PPUSH
3520: LD_INT 3
3522: PPUSH
3523: CALL_OW 233
// PlaceUnitArea ( veh , allianceJMMSpawnArea , false ) ;
3527: LD_VAR 0 3
3531: PPUSH
3532: LD_INT 31
3534: PPUSH
3535: LD_INT 0
3537: PPUSH
3538: CALL_OW 49
// PlaceHumanInUnit ( Burlak , veh ) ;
3542: LD_EXP 44
3546: PPUSH
3547: LD_VAR 0 3
3551: PPUSH
3552: CALL_OW 52
// if Gossudarov then
3556: LD_EXP 30
3560: IFFALSE 3647
// begin PrepareVehicle ( ru_medium_tracked , engine_siberite , control_manual , ru_cargo_bay , 100 ) ;
3562: LD_INT 22
3564: PPUSH
3565: LD_INT 3
3567: PPUSH
3568: LD_INT 1
3570: PPUSH
3571: LD_INT 51
3573: PPUSH
3574: LD_INT 100
3576: PPUSH
3577: CALL 56831 0 5
// veh := CreateVehicle ;
3581: LD_ADDR_VAR 0 3
3585: PUSH
3586: CALL_OW 45
3590: ST_TO_ADDR
// SetDir ( veh , 3 ) ;
3591: LD_VAR 0 3
3595: PPUSH
3596: LD_INT 3
3598: PPUSH
3599: CALL_OW 233
// PlaceUnitArea ( veh , allianceSpawnArea , false ) ;
3603: LD_VAR 0 3
3607: PPUSH
3608: LD_INT 30
3610: PPUSH
3611: LD_INT 0
3613: PPUSH
3614: CALL_OW 49
// PlaceHumanInUnit ( Gossudarov , veh ) ;
3618: LD_EXP 30
3622: PPUSH
3623: LD_VAR 0 3
3627: PPUSH
3628: CALL_OW 52
// SetCargo ( veh , mat_cans , 100 ) ;
3632: LD_VAR 0 3
3636: PPUSH
3637: LD_INT 1
3639: PPUSH
3640: LD_INT 100
3642: PPUSH
3643: CALL_OW 290
// end ; for i in selected do
3647: LD_ADDR_VAR 0 2
3651: PUSH
3652: LD_VAR 0 4
3656: PUSH
3657: FOR_IN
3658: IFFALSE 4216
// begin uc_nation := GetNation ( i ) ;
3660: LD_ADDR_OWVAR 21
3664: PUSH
3665: LD_VAR 0 2
3669: PPUSH
3670: CALL_OW 248
3674: ST_TO_ADDR
// if i in [ Lisa , Donaldson , Cyrus , Bobby ] then
3675: LD_VAR 0 2
3679: PUSH
3680: LD_EXP 14
3684: PUSH
3685: LD_EXP 15
3689: PUSH
3690: LD_EXP 17
3694: PUSH
3695: LD_EXP 16
3699: PUSH
3700: EMPTY
3701: LIST
3702: LIST
3703: LIST
3704: LIST
3705: IN
3706: IFFALSE 3729
// PrepareVehicle ( us_morphling , engine_siberite , control_manual , us_heavy_gun , 100 ) else
3708: LD_INT 5
3710: PPUSH
3711: LD_INT 3
3713: PPUSH
3714: LD_INT 1
3716: PPUSH
3717: LD_INT 6
3719: PPUSH
3720: LD_INT 100
3722: PPUSH
3723: CALL 56831 0 5
3727: GO 4163
// if i in [ Oblukov , Kuzmov , Petrovova , Titov ] then
3729: LD_VAR 0 2
3733: PUSH
3734: LD_EXP 37
3738: PUSH
3739: LD_EXP 42
3743: PUSH
3744: LD_EXP 40
3748: PUSH
3749: LD_EXP 32
3753: PUSH
3754: EMPTY
3755: LIST
3756: LIST
3757: LIST
3758: LIST
3759: IN
3760: IFFALSE 3791
// PrepareVehicle ( ru_heavy_tracked , engine_combustion , control_manual , ru_heavy_gun , rand ( 65 , 75 ) ) else
3762: LD_INT 24
3764: PPUSH
3765: LD_INT 1
3767: PPUSH
3768: LD_INT 1
3770: PPUSH
3771: LD_INT 46
3773: PPUSH
3774: LD_INT 65
3776: PPUSH
3777: LD_INT 75
3779: PPUSH
3780: CALL_OW 12
3784: PPUSH
3785: CALL 56831 0 5
3789: GO 4163
// if i = Karamazov then
3791: LD_VAR 0 2
3795: PUSH
3796: LD_EXP 43
3800: EQUAL
3801: IFFALSE 3824
// PrepareVehicle ( ru_medium_tracked , engine_siberite , control_manual , ru_crane , 100 ) else
3803: LD_INT 22
3805: PPUSH
3806: LD_INT 3
3808: PPUSH
3809: LD_INT 1
3811: PPUSH
3812: LD_INT 52
3814: PPUSH
3815: LD_INT 100
3817: PPUSH
3818: CALL 56831 0 5
3822: GO 4163
// if i = Brown then
3824: LD_VAR 0 2
3828: PUSH
3829: LD_EXP 19
3833: EQUAL
3834: IFFALSE 3857
// PrepareVehicle ( us_medium_tracked , engine_siberite , control_manual , us_crane , 100 ) else
3836: LD_INT 3
3838: PPUSH
3839: LD_INT 3
3841: PPUSH
3842: LD_INT 1
3844: PPUSH
3845: LD_INT 13
3847: PPUSH
3848: LD_INT 100
3850: PPUSH
3851: CALL 56831 0 5
3855: GO 4163
// if uc_nation = nation_american then
3857: LD_OWVAR 21
3861: PUSH
3862: LD_INT 1
3864: EQUAL
3865: IFFALSE 4016
// begin PrepareVehicle ( [ us_medium_tracked , us_morphling , us_morphling ] [ uc_nation mod 3 + 1 ] , [ engine_combustion , engine_siberite , engine_combustion ] [ uc_nation mod 3 + 1 ] , control_manual , [ [ us_radar , us_gatling_gun , us_double_gun ] , [ us_heavy_gun , us_rocket_launcher , us_laser ] , [ us_heavy_gun , us_laser , us_cargo_bay ] ] [ uc_nation mod 3 + 1 ] [ rand ( 1 , 3 ) ] , rand ( 65 , 75 ) ) ;
3867: LD_INT 3
3869: PUSH
3870: LD_INT 5
3872: PUSH
3873: LD_INT 5
3875: PUSH
3876: EMPTY
3877: LIST
3878: LIST
3879: LIST
3880: PUSH
3881: LD_OWVAR 21
3885: PUSH
3886: LD_INT 3
3888: MOD
3889: PUSH
3890: LD_INT 1
3892: PLUS
3893: ARRAY
3894: PPUSH
3895: LD_INT 1
3897: PUSH
3898: LD_INT 3
3900: PUSH
3901: LD_INT 1
3903: PUSH
3904: EMPTY
3905: LIST
3906: LIST
3907: LIST
3908: PUSH
3909: LD_OWVAR 21
3913: PUSH
3914: LD_INT 3
3916: MOD
3917: PUSH
3918: LD_INT 1
3920: PLUS
3921: ARRAY
3922: PPUSH
3923: LD_INT 1
3925: PPUSH
3926: LD_INT 11
3928: PUSH
3929: LD_INT 4
3931: PUSH
3932: LD_INT 5
3934: PUSH
3935: EMPTY
3936: LIST
3937: LIST
3938: LIST
3939: PUSH
3940: LD_INT 6
3942: PUSH
3943: LD_INT 7
3945: PUSH
3946: LD_INT 9
3948: PUSH
3949: EMPTY
3950: LIST
3951: LIST
3952: LIST
3953: PUSH
3954: LD_INT 6
3956: PUSH
3957: LD_INT 9
3959: PUSH
3960: LD_INT 12
3962: PUSH
3963: EMPTY
3964: LIST
3965: LIST
3966: LIST
3967: PUSH
3968: EMPTY
3969: LIST
3970: LIST
3971: LIST
3972: PUSH
3973: LD_OWVAR 21
3977: PUSH
3978: LD_INT 3
3980: MOD
3981: PUSH
3982: LD_INT 1
3984: PLUS
3985: ARRAY
3986: PUSH
3987: LD_INT 1
3989: PPUSH
3990: LD_INT 3
3992: PPUSH
3993: CALL_OW 12
3997: ARRAY
3998: PPUSH
3999: LD_INT 65
4001: PPUSH
4002: LD_INT 75
4004: PPUSH
4005: CALL_OW 12
4009: PPUSH
4010: CALL 56831 0 5
// end else
4014: GO 4163
// begin PrepareVehicle ( [ ru_medium_tracked , ru_heavy_wheeled , ru_heavy_wheeled ] [ uc_nation mod 3 + 1 ] , [ engine_combustion , engine_siberite , engine_combustion ] [ uc_nation mod 3 + 1 ] , control_manual , [ [ ru_rocket_launcher , ru_gatling_gun , ru_gun ] , [ ru_heavy_gun , ru_rocket_launcher , ru_gun ] , [ ru_heavy_gun , ru_gatling_gun , ru_rocket_launcher ] ] [ uc_nation mod 3 + 1 ] [ rand ( 1 , 3 ) ] , rand ( 65 , 75 ) ) ;
4016: LD_INT 22
4018: PUSH
4019: LD_INT 23
4021: PUSH
4022: LD_INT 23
4024: PUSH
4025: EMPTY
4026: LIST
4027: LIST
4028: LIST
4029: PUSH
4030: LD_OWVAR 21
4034: PUSH
4035: LD_INT 3
4037: MOD
4038: PUSH
4039: LD_INT 1
4041: PLUS
4042: ARRAY
4043: PPUSH
4044: LD_INT 1
4046: PUSH
4047: LD_INT 3
4049: PUSH
4050: LD_INT 1
4052: PUSH
4053: EMPTY
4054: LIST
4055: LIST
4056: LIST
4057: PUSH
4058: LD_OWVAR 21
4062: PUSH
4063: LD_INT 3
4065: MOD
4066: PUSH
4067: LD_INT 1
4069: PLUS
4070: ARRAY
4071: PPUSH
4072: LD_INT 1
4074: PPUSH
4075: LD_INT 45
4077: PUSH
4078: LD_INT 43
4080: PUSH
4081: LD_INT 44
4083: PUSH
4084: EMPTY
4085: LIST
4086: LIST
4087: LIST
4088: PUSH
4089: LD_INT 46
4091: PUSH
4092: LD_INT 45
4094: PUSH
4095: LD_INT 44
4097: PUSH
4098: EMPTY
4099: LIST
4100: LIST
4101: LIST
4102: PUSH
4103: LD_INT 46
4105: PUSH
4106: LD_INT 43
4108: PUSH
4109: LD_INT 45
4111: PUSH
4112: EMPTY
4113: LIST
4114: LIST
4115: LIST
4116: PUSH
4117: EMPTY
4118: LIST
4119: LIST
4120: LIST
4121: PUSH
4122: LD_OWVAR 21
4126: PUSH
4127: LD_INT 3
4129: MOD
4130: PUSH
4131: LD_INT 1
4133: PLUS
4134: ARRAY
4135: PUSH
4136: LD_INT 1
4138: PPUSH
4139: LD_INT 3
4141: PPUSH
4142: CALL_OW 12
4146: ARRAY
4147: PPUSH
4148: LD_INT 65
4150: PPUSH
4151: LD_INT 75
4153: PPUSH
4154: CALL_OW 12
4158: PPUSH
4159: CALL 56831 0 5
// end ; veh := CreateVehicle ;
4163: LD_ADDR_VAR 0 3
4167: PUSH
4168: CALL_OW 45
4172: ST_TO_ADDR
// SetDir ( veh , 3 ) ;
4173: LD_VAR 0 3
4177: PPUSH
4178: LD_INT 3
4180: PPUSH
4181: CALL_OW 233
// PlaceUnitArea ( veh , allianceSpawnArea , false ) ;
4185: LD_VAR 0 3
4189: PPUSH
4190: LD_INT 30
4192: PPUSH
4193: LD_INT 0
4195: PPUSH
4196: CALL_OW 49
// PlaceHumanInUnit ( i , veh ) ;
4200: LD_VAR 0 2
4204: PPUSH
4205: LD_VAR 0 3
4209: PPUSH
4210: CALL_OW 52
// end ;
4214: GO 3657
4216: POP
4217: POP
// if artifactArCaptured then
4218: LD_EXP 6
4222: IFFALSE 4308
// begin uc_nation := nation_american ;
4224: LD_ADDR_OWVAR 21
4228: PUSH
4229: LD_INT 1
4231: ST_TO_ADDR
// PrepareVehicle ( us_medium_tracked , engine_siberite , control_computer , us_cargo_bay , 100 ) ;
4232: LD_INT 3
4234: PPUSH
4235: LD_INT 3
4237: PPUSH
4238: LD_INT 3
4240: PPUSH
4241: LD_INT 12
4243: PPUSH
4244: LD_INT 100
4246: PPUSH
4247: CALL 56831 0 5
// veh := CreateVehicle ;
4251: LD_ADDR_VAR 0 3
4255: PUSH
4256: CALL_OW 45
4260: ST_TO_ADDR
// SetDir ( veh , 3 ) ;
4261: LD_VAR 0 3
4265: PPUSH
4266: LD_INT 3
4268: PPUSH
4269: CALL_OW 233
// PlaceUnitXY ( veh , 198 , 22 , false ) ;
4273: LD_VAR 0 3
4277: PPUSH
4278: LD_INT 198
4280: PPUSH
4281: LD_INT 22
4283: PPUSH
4284: LD_INT 0
4286: PPUSH
4287: CALL_OW 48
// SetCargo ( veh , mat_artifact , 50 ) ;
4291: LD_VAR 0 3
4295: PPUSH
4296: LD_INT 4
4298: PPUSH
4299: LD_INT 50
4301: PPUSH
4302: CALL_OW 290
// end else
4306: GO 4327
// begin CreateResourcesXY ( mat_artifact , 267 , 226 , 5 , false ) ;
4308: LD_INT 4
4310: PPUSH
4311: LD_INT 267
4313: PPUSH
4314: LD_INT 226
4316: PPUSH
4317: LD_INT 5
4319: PPUSH
4320: LD_INT 0
4322: PPUSH
4323: CALL_OW 58
// end ; uc_nation := nation_american ;
4327: LD_ADDR_OWVAR 21
4331: PUSH
4332: LD_INT 1
4334: ST_TO_ADDR
// PrepareVehicle ( us_medium_tracked , engine_siberite , control_computer , us_cargo_bay , 100 ) ;
4335: LD_INT 3
4337: PPUSH
4338: LD_INT 3
4340: PPUSH
4341: LD_INT 3
4343: PPUSH
4344: LD_INT 12
4346: PPUSH
4347: LD_INT 100
4349: PPUSH
4350: CALL 56831 0 5
// veh := CreateVehicle ;
4354: LD_ADDR_VAR 0 3
4358: PUSH
4359: CALL_OW 45
4363: ST_TO_ADDR
// SetDir ( veh , 3 ) ;
4364: LD_VAR 0 3
4368: PPUSH
4369: LD_INT 3
4371: PPUSH
4372: CALL_OW 233
// PlaceUnitXY ( veh , 218 , 23 , false ) ;
4376: LD_VAR 0 3
4380: PPUSH
4381: LD_INT 218
4383: PPUSH
4384: LD_INT 23
4386: PPUSH
4387: LD_INT 0
4389: PPUSH
4390: CALL_OW 48
// SetCargo ( veh , mat_artifact , 30 ) ;
4394: LD_VAR 0 3
4398: PPUSH
4399: LD_INT 4
4401: PPUSH
4402: LD_INT 30
4404: PPUSH
4405: CALL_OW 290
// uc_nation := nation_russian ;
4409: LD_ADDR_OWVAR 21
4413: PUSH
4414: LD_INT 3
4416: ST_TO_ADDR
// PrepareVehicle ( ru_medium_tracked , engine_siberite , control_computer , ru_cargo_bay , 100 ) ;
4417: LD_INT 22
4419: PPUSH
4420: LD_INT 3
4422: PPUSH
4423: LD_INT 3
4425: PPUSH
4426: LD_INT 51
4428: PPUSH
4429: LD_INT 100
4431: PPUSH
4432: CALL 56831 0 5
// veh := CreateVehicle ;
4436: LD_ADDR_VAR 0 3
4440: PUSH
4441: CALL_OW 45
4445: ST_TO_ADDR
// SetDir ( veh , 3 ) ;
4446: LD_VAR 0 3
4450: PPUSH
4451: LD_INT 3
4453: PPUSH
4454: CALL_OW 233
// PlaceUnitXY ( veh , 214 , 20 , false ) ;
4458: LD_VAR 0 3
4462: PPUSH
4463: LD_INT 214
4465: PPUSH
4466: LD_INT 20
4468: PPUSH
4469: LD_INT 0
4471: PPUSH
4472: CALL_OW 48
// SetCargo ( veh , mat_artifact , 40 ) ;
4476: LD_VAR 0 3
4480: PPUSH
4481: LD_INT 4
4483: PPUSH
4484: LD_INT 40
4486: PPUSH
4487: CALL_OW 290
// end ; end_of_file
4491: LD_VAR 0 1
4495: RET
// export Powell ; export function PrepareAmerican ; var i , b , veh , cl , tmp , depot , lab , armoury , workshop ; begin
4496: LD_INT 0
4498: PPUSH
4499: PPUSH
4500: PPUSH
4501: PPUSH
4502: PPUSH
4503: PPUSH
4504: PPUSH
4505: PPUSH
4506: PPUSH
4507: PPUSH
// InitHc ;
4508: CALL_OW 19
// uc_side := 1 ;
4512: LD_ADDR_OWVAR 20
4516: PUSH
4517: LD_INT 1
4519: ST_TO_ADDR
// uc_nation := 1 ;
4520: LD_ADDR_OWVAR 21
4524: PUSH
4525: LD_INT 1
4527: ST_TO_ADDR
// SetResourceType ( GetBase ( am_depot ) , mat_cans , 25500 ) ;
4528: LD_INT 387
4530: PPUSH
4531: CALL_OW 274
4535: PPUSH
4536: LD_INT 1
4538: PPUSH
4539: LD_INT 25500
4541: PPUSH
4542: CALL_OW 277
// SetResourceType ( GetBase ( am_depot ) , mat_oil , 4000 ) ;
4546: LD_INT 387
4548: PPUSH
4549: CALL_OW 274
4553: PPUSH
4554: LD_INT 2
4556: PPUSH
4557: LD_INT 4000
4559: PPUSH
4560: CALL_OW 277
// SetResourceType ( GetBase ( am_depot ) , mat_siberit , 50 ) ;
4564: LD_INT 387
4566: PPUSH
4567: CALL_OW 274
4571: PPUSH
4572: LD_INT 3
4574: PPUSH
4575: LD_INT 50
4577: PPUSH
4578: CALL_OW 277
// SetResourceType ( GetBase ( am_depot2 ) , mat_cans , 7500 ) ;
4582: LD_INT 476
4584: PPUSH
4585: CALL_OW 274
4589: PPUSH
4590: LD_INT 1
4592: PPUSH
4593: LD_INT 7500
4595: PPUSH
4596: CALL_OW 277
// SetResourceType ( GetBase ( am_depot2 ) , mat_oil , 4000 ) ;
4600: LD_INT 476
4602: PPUSH
4603: CALL_OW 274
4607: PPUSH
4608: LD_INT 2
4610: PPUSH
4611: LD_INT 4000
4613: PPUSH
4614: CALL_OW 277
// SetResourceType ( GetBase ( am_depot2 ) , mat_siberit , 10 ) ;
4618: LD_INT 476
4620: PPUSH
4621: CALL_OW 274
4625: PPUSH
4626: LD_INT 3
4628: PPUSH
4629: LD_INT 10
4631: PPUSH
4632: CALL_OW 277
// Powell := NewCharacter ( Powell ) ;
4636: LD_ADDR_EXP 47
4640: PUSH
4641: LD_STRING Powell
4643: PPUSH
4644: CALL_OW 25
4648: ST_TO_ADDR
// PlaceUnitXY ( Powell , 57 , 94 , false ) ;
4649: LD_EXP 47
4653: PPUSH
4654: LD_INT 57
4656: PPUSH
4657: LD_INT 94
4659: PPUSH
4660: LD_INT 0
4662: PPUSH
4663: CALL_OW 48
// ComTurnXY ( Powell , 58 , 94 ) ;
4667: LD_EXP 47
4671: PPUSH
4672: LD_INT 58
4674: PPUSH
4675: LD_INT 94
4677: PPUSH
4678: CALL_OW 118
// tmp := [ ] ;
4682: LD_ADDR_VAR 0 6
4686: PUSH
4687: EMPTY
4688: ST_TO_ADDR
// Lisa := PrepareUnit ( Lisa , ( not debug ) , 12p_ ) ;
4689: LD_ADDR_EXP 14
4693: PUSH
4694: LD_STRING Lisa
4696: PPUSH
4697: LD_EXP 1
4701: NOT
4702: PPUSH
4703: LD_STRING 12p_
4705: PPUSH
4706: CALL 49865 0 3
4710: ST_TO_ADDR
// if Lisa then
4711: LD_EXP 14
4715: IFFALSE 4733
// tmp := tmp ^ Lisa ;
4717: LD_ADDR_VAR 0 6
4721: PUSH
4722: LD_VAR 0 6
4726: PUSH
4727: LD_EXP 14
4731: ADD
4732: ST_TO_ADDR
// Donaldson := PrepareUnit ( Donaldson , ( not debug ) , 12p_ ) ;
4733: LD_ADDR_EXP 15
4737: PUSH
4738: LD_STRING Donaldson
4740: PPUSH
4741: LD_EXP 1
4745: NOT
4746: PPUSH
4747: LD_STRING 12p_
4749: PPUSH
4750: CALL 49865 0 3
4754: ST_TO_ADDR
// if Donaldson then
4755: LD_EXP 15
4759: IFFALSE 4777
// tmp := tmp ^ Donaldson ;
4761: LD_ADDR_VAR 0 6
4765: PUSH
4766: LD_VAR 0 6
4770: PUSH
4771: LD_EXP 15
4775: ADD
4776: ST_TO_ADDR
// Bobby := PrepareUnit ( Bobby , ( not debug ) , 12p_ ) ;
4777: LD_ADDR_EXP 16
4781: PUSH
4782: LD_STRING Bobby
4784: PPUSH
4785: LD_EXP 1
4789: NOT
4790: PPUSH
4791: LD_STRING 12p_
4793: PPUSH
4794: CALL 49865 0 3
4798: ST_TO_ADDR
// if Bobby then
4799: LD_EXP 16
4803: IFFALSE 4821
// tmp := tmp ^ Bobby ;
4805: LD_ADDR_VAR 0 6
4809: PUSH
4810: LD_VAR 0 6
4814: PUSH
4815: LD_EXP 16
4819: ADD
4820: ST_TO_ADDR
// Cyrus := PrepareUnit ( Cyrus , ( not debug ) , 12p_ ) ;
4821: LD_ADDR_EXP 17
4825: PUSH
4826: LD_STRING Cyrus
4828: PPUSH
4829: LD_EXP 1
4833: NOT
4834: PPUSH
4835: LD_STRING 12p_
4837: PPUSH
4838: CALL 49865 0 3
4842: ST_TO_ADDR
// if Cyrus then
4843: LD_EXP 17
4847: IFFALSE 4865
// tmp := tmp ^ Cyrus ;
4849: LD_ADDR_VAR 0 6
4853: PUSH
4854: LD_VAR 0 6
4858: PUSH
4859: LD_EXP 17
4863: ADD
4864: ST_TO_ADDR
// Brown := PrepareUnit ( Brown , ( not debug ) , 12p_ ) ;
4865: LD_ADDR_EXP 19
4869: PUSH
4870: LD_STRING Brown
4872: PPUSH
4873: LD_EXP 1
4877: NOT
4878: PPUSH
4879: LD_STRING 12p_
4881: PPUSH
4882: CALL 49865 0 3
4886: ST_TO_ADDR
// if Brown then
4887: LD_EXP 19
4891: IFFALSE 4909
// tmp := tmp ^ Brown ;
4893: LD_ADDR_VAR 0 6
4897: PUSH
4898: LD_VAR 0 6
4902: PUSH
4903: LD_EXP 19
4907: ADD
4908: ST_TO_ADDR
// Gladstone := PrepareUnit ( Gladstone , ( not debug ) , 12p_ ) ;
4909: LD_ADDR_EXP 20
4913: PUSH
4914: LD_STRING Gladstone
4916: PPUSH
4917: LD_EXP 1
4921: NOT
4922: PPUSH
4923: LD_STRING 12p_
4925: PPUSH
4926: CALL 49865 0 3
4930: ST_TO_ADDR
// if Gladstone then
4931: LD_EXP 20
4935: IFFALSE 4953
// tmp := tmp ^ Gladstone ;
4937: LD_ADDR_VAR 0 6
4941: PUSH
4942: LD_VAR 0 6
4946: PUSH
4947: LD_EXP 20
4951: ADD
4952: ST_TO_ADDR
// Houten := PrepareUnit ( Houten , ( not debug ) , 12p_ ) ;
4953: LD_ADDR_EXP 21
4957: PUSH
4958: LD_STRING Houten
4960: PPUSH
4961: LD_EXP 1
4965: NOT
4966: PPUSH
4967: LD_STRING 12p_
4969: PPUSH
4970: CALL 49865 0 3
4974: ST_TO_ADDR
// if Houten then
4975: LD_EXP 21
4979: IFFALSE 4997
// tmp := tmp ^ Houten ;
4981: LD_ADDR_VAR 0 6
4985: PUSH
4986: LD_VAR 0 6
4990: PUSH
4991: LD_EXP 21
4995: ADD
4996: ST_TO_ADDR
// Cornel := PrepareUnit ( Cornel , ( not debug ) , 12p_ ) ;
4997: LD_ADDR_EXP 22
5001: PUSH
5002: LD_STRING Cornel
5004: PPUSH
5005: LD_EXP 1
5009: NOT
5010: PPUSH
5011: LD_STRING 12p_
5013: PPUSH
5014: CALL 49865 0 3
5018: ST_TO_ADDR
// if Cornel then
5019: LD_EXP 22
5023: IFFALSE 5041
// tmp := tmp ^ Cornel ;
5025: LD_ADDR_VAR 0 6
5029: PUSH
5030: LD_VAR 0 6
5034: PUSH
5035: LD_EXP 22
5039: ADD
5040: ST_TO_ADDR
// Gary := PrepareUnit ( Gary , ( not debug ) , 12p_ ) ;
5041: LD_ADDR_EXP 23
5045: PUSH
5046: LD_STRING Gary
5048: PPUSH
5049: LD_EXP 1
5053: NOT
5054: PPUSH
5055: LD_STRING 12p_
5057: PPUSH
5058: CALL 49865 0 3
5062: ST_TO_ADDR
// if Gary then
5063: LD_EXP 23
5067: IFFALSE 5085
// tmp := tmp ^ Gary ;
5069: LD_ADDR_VAR 0 6
5073: PUSH
5074: LD_VAR 0 6
5078: PUSH
5079: LD_EXP 23
5083: ADD
5084: ST_TO_ADDR
// Kikuchi := PrepareUnit ( Kikuchi , ( not debug ) , 12p_ ) ;
5085: LD_ADDR_EXP 25
5089: PUSH
5090: LD_STRING Kikuchi
5092: PPUSH
5093: LD_EXP 1
5097: NOT
5098: PPUSH
5099: LD_STRING 12p_
5101: PPUSH
5102: CALL 49865 0 3
5106: ST_TO_ADDR
// if Kikuchi then
5107: LD_EXP 25
5111: IFFALSE 5129
// tmp := tmp ^ Kikuchi ;
5113: LD_ADDR_VAR 0 6
5117: PUSH
5118: LD_VAR 0 6
5122: PUSH
5123: LD_EXP 25
5127: ADD
5128: ST_TO_ADDR
// tmp := tmp union CreateCharacterSet ( 12p_others ) ;
5129: LD_ADDR_VAR 0 6
5133: PUSH
5134: LD_VAR 0 6
5138: PUSH
5139: LD_STRING 12p_others
5141: PPUSH
5142: CALL_OW 31
5146: UNION
5147: ST_TO_ADDR
// if tmp < 36 then
5148: LD_VAR 0 6
5152: PUSH
5153: LD_INT 36
5155: LESS
5156: IFFALSE 5223
// for i = 1 to 36 - tmp do
5158: LD_ADDR_VAR 0 2
5162: PUSH
5163: DOUBLE
5164: LD_INT 1
5166: DEC
5167: ST_TO_ADDR
5168: LD_INT 36
5170: PUSH
5171: LD_VAR 0 6
5175: MINUS
5176: PUSH
5177: FOR_TO
5178: IFFALSE 5221
// begin PrepareHuman ( sex_male , i mod 4 + 1 , 10 ) ;
5180: LD_INT 1
5182: PPUSH
5183: LD_VAR 0 2
5187: PUSH
5188: LD_INT 4
5190: MOD
5191: PUSH
5192: LD_INT 1
5194: PLUS
5195: PPUSH
5196: LD_INT 10
5198: PPUSH
5199: CALL_OW 380
// tmp := tmp ^ CreateHuman ;
5203: LD_ADDR_VAR 0 6
5207: PUSH
5208: LD_VAR 0 6
5212: PUSH
5213: CALL_OW 44
5217: ADD
5218: ST_TO_ADDR
// end ;
5219: GO 5177
5221: POP
5222: POP
// for i in tmp do
5223: LD_ADDR_VAR 0 2
5227: PUSH
5228: LD_VAR 0 6
5232: PUSH
5233: FOR_IN
5234: IFFALSE 5259
// PlaceUnitXYR ( i , 62 , 93 , 9 , false ) ;
5236: LD_VAR 0 2
5240: PPUSH
5241: LD_INT 62
5243: PPUSH
5244: LD_INT 93
5246: PPUSH
5247: LD_INT 9
5249: PPUSH
5250: LD_INT 0
5252: PPUSH
5253: CALL_OW 50
5257: GO 5233
5259: POP
5260: POP
// mc_bases := Replace ( mc_bases , 4 , FilterAllUnits ( [ f_side , 1 ] ) ) ;
5261: LD_ADDR_EXP 74
5265: PUSH
5266: LD_EXP 74
5270: PPUSH
5271: LD_INT 4
5273: PPUSH
5274: LD_INT 22
5276: PUSH
5277: LD_INT 1
5279: PUSH
5280: EMPTY
5281: LIST
5282: LIST
5283: PPUSH
5284: CALL_OW 69
5288: PPUSH
5289: CALL_OW 1
5293: ST_TO_ADDR
// uc_side := 0 ;
5294: LD_ADDR_OWVAR 20
5298: PUSH
5299: LD_INT 0
5301: ST_TO_ADDR
// uc_nation := 0 ;
5302: LD_ADDR_OWVAR 21
5306: PUSH
5307: LD_INT 0
5309: ST_TO_ADDR
// for i = 1 to 4 do
5310: LD_ADDR_VAR 0 2
5314: PUSH
5315: DOUBLE
5316: LD_INT 1
5318: DEC
5319: ST_TO_ADDR
5320: LD_INT 4
5322: PUSH
5323: FOR_TO
5324: IFFALSE 5355
// begin InitHc ;
5326: CALL_OW 19
// hc_class := class_apeman ;
5330: LD_ADDR_OWVAR 28
5334: PUSH
5335: LD_INT 12
5337: ST_TO_ADDR
// PlaceUnitArea ( CreateHuman , powellApe , false ) ;
5338: CALL_OW 44
5342: PPUSH
5343: LD_INT 11
5345: PPUSH
5346: LD_INT 0
5348: PPUSH
5349: CALL_OW 49
// end ;
5353: GO 5323
5355: POP
5356: POP
// end ;
5357: LD_VAR 0 1
5361: RET
// every 11 11$30 trigger not americanDestroyed and not MC_GetVehicles ( 4 , true ) do var i , tmp , target ;
5362: LD_EXP 4
5366: NOT
5367: PUSH
5368: LD_INT 4
5370: PPUSH
5371: LD_INT 1
5373: PPUSH
5374: CALL 45073 0 2
5378: NOT
5379: AND
5380: IFFALSE 6152
5382: GO 5384
5384: DISABLE
5385: LD_INT 0
5387: PPUSH
5388: PPUSH
5389: PPUSH
// begin enable ;
5390: ENABLE
// if not FilterAllUnits ( [ [ f_side , 1 ] , [ f_nation , 1 ] , [ f_btype , b_factory ] ] ) then
5391: LD_INT 22
5393: PUSH
5394: LD_INT 1
5396: PUSH
5397: EMPTY
5398: LIST
5399: LIST
5400: PUSH
5401: LD_INT 23
5403: PUSH
5404: LD_INT 1
5406: PUSH
5407: EMPTY
5408: LIST
5409: LIST
5410: PUSH
5411: LD_INT 30
5413: PUSH
5414: LD_INT 3
5416: PUSH
5417: EMPTY
5418: LIST
5419: LIST
5420: PUSH
5421: EMPTY
5422: LIST
5423: LIST
5424: LIST
5425: PPUSH
5426: CALL_OW 69
5430: NOT
5431: IFFALSE 5435
// exit ;
5433: GO 6152
// if Prob ( 40 ) then
5435: LD_INT 40
5437: PPUSH
5438: CALL_OW 13
5442: IFFALSE 5569
// begin MC_InsertProduceList ( 4 , [ [ us_morphling , engine_combustion , control_remote , us_rocket_launcher ] , [ us_morphling , engine_combustion , control_remote , us_rocket_launcher ] , [ us_morphling , engine_combustion , control_remote , us_rocket_launcher ] , [ us_morphling , engine_combustion , control_remote , us_heavy_gun ] , [ us_morphling , engine_combustion , control_remote , us_heavy_gun ] , [ us_morphling , engine_combustion , control_remote , us_heavy_gun ] , ] ) ;
5444: LD_INT 4
5446: PPUSH
5447: LD_INT 5
5449: PUSH
5450: LD_INT 1
5452: PUSH
5453: LD_INT 2
5455: PUSH
5456: LD_INT 7
5458: PUSH
5459: EMPTY
5460: LIST
5461: LIST
5462: LIST
5463: LIST
5464: PUSH
5465: LD_INT 5
5467: PUSH
5468: LD_INT 1
5470: PUSH
5471: LD_INT 2
5473: PUSH
5474: LD_INT 7
5476: PUSH
5477: EMPTY
5478: LIST
5479: LIST
5480: LIST
5481: LIST
5482: PUSH
5483: LD_INT 5
5485: PUSH
5486: LD_INT 1
5488: PUSH
5489: LD_INT 2
5491: PUSH
5492: LD_INT 7
5494: PUSH
5495: EMPTY
5496: LIST
5497: LIST
5498: LIST
5499: LIST
5500: PUSH
5501: LD_INT 5
5503: PUSH
5504: LD_INT 1
5506: PUSH
5507: LD_INT 2
5509: PUSH
5510: LD_INT 6
5512: PUSH
5513: EMPTY
5514: LIST
5515: LIST
5516: LIST
5517: LIST
5518: PUSH
5519: LD_INT 5
5521: PUSH
5522: LD_INT 1
5524: PUSH
5525: LD_INT 2
5527: PUSH
5528: LD_INT 6
5530: PUSH
5531: EMPTY
5532: LIST
5533: LIST
5534: LIST
5535: LIST
5536: PUSH
5537: LD_INT 5
5539: PUSH
5540: LD_INT 1
5542: PUSH
5543: LD_INT 2
5545: PUSH
5546: LD_INT 6
5548: PUSH
5549: EMPTY
5550: LIST
5551: LIST
5552: LIST
5553: LIST
5554: PUSH
5555: EMPTY
5556: LIST
5557: LIST
5558: LIST
5559: LIST
5560: LIST
5561: LIST
5562: PPUSH
5563: CALL 43655 0 2
// end else
5567: GO 5692
// begin MC_InsertProduceList ( 4 , [ [ us_morphling , engine_combustion , control_remote , us_rocket_launcher ] , [ us_morphling , engine_combustion , control_remote , us_laser ] , [ us_morphling , engine_combustion , control_remote , us_laser ] , [ us_morphling , engine_combustion , control_remote , us_heavy_gun ] , [ us_morphling , engine_combustion , control_remote , us_heavy_gun ] , [ us_morphling , engine_combustion , control_remote , us_heavy_gun ] , ] ) ;
5569: LD_INT 4
5571: PPUSH
5572: LD_INT 5
5574: PUSH
5575: LD_INT 1
5577: PUSH
5578: LD_INT 2
5580: PUSH
5581: LD_INT 7
5583: PUSH
5584: EMPTY
5585: LIST
5586: LIST
5587: LIST
5588: LIST
5589: PUSH
5590: LD_INT 5
5592: PUSH
5593: LD_INT 1
5595: PUSH
5596: LD_INT 2
5598: PUSH
5599: LD_INT 9
5601: PUSH
5602: EMPTY
5603: LIST
5604: LIST
5605: LIST
5606: LIST
5607: PUSH
5608: LD_INT 5
5610: PUSH
5611: LD_INT 1
5613: PUSH
5614: LD_INT 2
5616: PUSH
5617: LD_INT 9
5619: PUSH
5620: EMPTY
5621: LIST
5622: LIST
5623: LIST
5624: LIST
5625: PUSH
5626: LD_INT 5
5628: PUSH
5629: LD_INT 1
5631: PUSH
5632: LD_INT 2
5634: PUSH
5635: LD_INT 6
5637: PUSH
5638: EMPTY
5639: LIST
5640: LIST
5641: LIST
5642: LIST
5643: PUSH
5644: LD_INT 5
5646: PUSH
5647: LD_INT 1
5649: PUSH
5650: LD_INT 2
5652: PUSH
5653: LD_INT 6
5655: PUSH
5656: EMPTY
5657: LIST
5658: LIST
5659: LIST
5660: LIST
5661: PUSH
5662: LD_INT 5
5664: PUSH
5665: LD_INT 1
5667: PUSH
5668: LD_INT 2
5670: PUSH
5671: LD_INT 6
5673: PUSH
5674: EMPTY
5675: LIST
5676: LIST
5677: LIST
5678: LIST
5679: PUSH
5680: EMPTY
5681: LIST
5682: LIST
5683: LIST
5684: LIST
5685: LIST
5686: LIST
5687: PPUSH
5688: CALL 43655 0 2
// end ; repeat wait ( 0 0$1 ) ;
5692: LD_INT 35
5694: PPUSH
5695: CALL_OW 67
// until MC_GetVehicles ( 4 , true ) >= 6 ;
5699: LD_INT 4
5701: PPUSH
5702: LD_INT 1
5704: PPUSH
5705: CALL 45073 0 2
5709: PUSH
5710: LD_INT 6
5712: GREATEREQUAL
5713: IFFALSE 5692
// wait ( 0 0$30 ) ;
5715: LD_INT 1050
5717: PPUSH
5718: CALL_OW 67
// tmp := MC_GetVehicles ( 4 , true ) ;
5722: LD_ADDR_VAR 0 2
5726: PUSH
5727: LD_INT 4
5729: PPUSH
5730: LD_INT 1
5732: PPUSH
5733: CALL 45073 0 2
5737: ST_TO_ADDR
// mc_vehicles := Replace ( mc_vehicles , 4 , mc_vehicles [ 4 ] diff tmp ) ;
5738: LD_ADDR_EXP 93
5742: PUSH
5743: LD_EXP 93
5747: PPUSH
5748: LD_INT 4
5750: PPUSH
5751: LD_EXP 93
5755: PUSH
5756: LD_INT 4
5758: ARRAY
5759: PUSH
5760: LD_VAR 0 2
5764: DIFF
5765: PPUSH
5766: CALL_OW 1
5770: ST_TO_ADDR
// target := rand ( 0 , 2 ) ;
5771: LD_ADDR_VAR 0 3
5775: PUSH
5776: LD_INT 0
5778: PPUSH
5779: LD_INT 2
5781: PPUSH
5782: CALL_OW 12
5786: ST_TO_ADDR
// if target then
5787: LD_VAR 0 3
5791: IFFALSE 5919
// begin repeat tmp := UnitFilter ( tmp , [ f_lives , 250 ] ) ;
5793: LD_ADDR_VAR 0 2
5797: PUSH
5798: LD_VAR 0 2
5802: PPUSH
5803: LD_INT 24
5805: PUSH
5806: LD_INT 250
5808: PUSH
5809: EMPTY
5810: LIST
5811: LIST
5812: PPUSH
5813: CALL_OW 72
5817: ST_TO_ADDR
// for i in tmp do
5818: LD_ADDR_VAR 0 1
5822: PUSH
5823: LD_VAR 0 2
5827: PUSH
5828: FOR_IN
5829: IFFALSE 5869
// if GetDistUnitXY ( i , 114 , 108 ) > 9 then
5831: LD_VAR 0 1
5835: PPUSH
5836: LD_INT 114
5838: PPUSH
5839: LD_INT 108
5841: PPUSH
5842: CALL_OW 297
5846: PUSH
5847: LD_INT 9
5849: GREATER
5850: IFFALSE 5867
// ComMoveXY ( i , 114 , 108 ) ;
5852: LD_VAR 0 1
5856: PPUSH
5857: LD_INT 114
5859: PPUSH
5860: LD_INT 108
5862: PPUSH
5863: CALL_OW 111
5867: GO 5828
5869: POP
5870: POP
// wait ( 0 0$1 ) ;
5871: LD_INT 35
5873: PPUSH
5874: CALL_OW 67
// until UnitFilter ( tmp , [ f_distxy , 114 , 108 , 9 ] ) >= ( tmp - 1 ) ;
5878: LD_VAR 0 2
5882: PPUSH
5883: LD_INT 92
5885: PUSH
5886: LD_INT 114
5888: PUSH
5889: LD_INT 108
5891: PUSH
5892: LD_INT 9
5894: PUSH
5895: EMPTY
5896: LIST
5897: LIST
5898: LIST
5899: LIST
5900: PPUSH
5901: CALL_OW 72
5905: PUSH
5906: LD_VAR 0 2
5910: PUSH
5911: LD_INT 1
5913: MINUS
5914: GREATEREQUAL
5915: IFFALSE 5793
// end else
5917: GO 6043
// begin repeat tmp := UnitFilter ( tmp , [ f_lives , 250 ] ) ;
5919: LD_ADDR_VAR 0 2
5923: PUSH
5924: LD_VAR 0 2
5928: PPUSH
5929: LD_INT 24
5931: PUSH
5932: LD_INT 250
5934: PUSH
5935: EMPTY
5936: LIST
5937: LIST
5938: PPUSH
5939: CALL_OW 72
5943: ST_TO_ADDR
// for i in tmp do
5944: LD_ADDR_VAR 0 1
5948: PUSH
5949: LD_VAR 0 2
5953: PUSH
5954: FOR_IN
5955: IFFALSE 5995
// if GetDistUnitXY ( i , 129 , 139 ) > 9 then
5957: LD_VAR 0 1
5961: PPUSH
5962: LD_INT 129
5964: PPUSH
5965: LD_INT 139
5967: PPUSH
5968: CALL_OW 297
5972: PUSH
5973: LD_INT 9
5975: GREATER
5976: IFFALSE 5993
// ComMoveXY ( i , 129 , 139 ) ;
5978: LD_VAR 0 1
5982: PPUSH
5983: LD_INT 129
5985: PPUSH
5986: LD_INT 139
5988: PPUSH
5989: CALL_OW 111
5993: GO 5954
5995: POP
5996: POP
// wait ( 0 0$1 ) ;
5997: LD_INT 35
5999: PPUSH
6000: CALL_OW 67
// until UnitFilter ( tmp , [ f_distxy , 129 , 139 , 9 ] ) >= ( tmp - 1 ) ;
6004: LD_VAR 0 2
6008: PPUSH
6009: LD_INT 92
6011: PUSH
6012: LD_INT 129
6014: PUSH
6015: LD_INT 139
6017: PUSH
6018: LD_INT 9
6020: PUSH
6021: EMPTY
6022: LIST
6023: LIST
6024: LIST
6025: LIST
6026: PPUSH
6027: CALL_OW 72
6031: PUSH
6032: LD_VAR 0 2
6036: PUSH
6037: LD_INT 1
6039: MINUS
6040: GREATEREQUAL
6041: IFFALSE 5919
// end ; repeat wait ( 0 0$1 ) ;
6043: LD_INT 35
6045: PPUSH
6046: CALL_OW 67
// for i in tmp do
6050: LD_ADDR_VAR 0 1
6054: PUSH
6055: LD_VAR 0 2
6059: PUSH
6060: FOR_IN
6061: IFFALSE 6143
// begin if GetLives ( i ) > 251 then
6063: LD_VAR 0 1
6067: PPUSH
6068: CALL_OW 256
6072: PUSH
6073: LD_INT 251
6075: GREATER
6076: IFFALSE 6114
// ComAttackUnit ( i , NearestUnitToUnit ( FilterAllUnits ( [ f_enemy , 1 ] ) , i ) ) else
6078: LD_VAR 0 1
6082: PPUSH
6083: LD_INT 81
6085: PUSH
6086: LD_INT 1
6088: PUSH
6089: EMPTY
6090: LIST
6091: LIST
6092: PPUSH
6093: CALL_OW 69
6097: PPUSH
6098: LD_VAR 0 1
6102: PPUSH
6103: CALL_OW 74
6107: PPUSH
6108: CALL_OW 115
6112: GO 6141
// if IsDead ( i ) then
6114: LD_VAR 0 1
6118: PPUSH
6119: CALL_OW 301
6123: IFFALSE 6141
// tmp := tmp diff i ;
6125: LD_ADDR_VAR 0 2
6129: PUSH
6130: LD_VAR 0 2
6134: PUSH
6135: LD_VAR 0 1
6139: DIFF
6140: ST_TO_ADDR
// end ;
6141: GO 6060
6143: POP
6144: POP
// until not tmp ;
6145: LD_VAR 0 2
6149: NOT
6150: IFFALSE 6043
// end ;
6152: PPOPN 3
6154: END
// every 30 30$00 trigger not americanDestroyed do
6155: LD_EXP 4
6159: NOT
6160: IFFALSE 6225
6162: GO 6164
6164: DISABLE
// begin wait ( [ 30 30$00 , 20 20$00 , 10 10$00 ] [ Difficulty ] ) ;
6165: LD_INT 63000
6167: PUSH
6168: LD_INT 42000
6170: PUSH
6171: LD_INT 21000
6173: PUSH
6174: EMPTY
6175: LIST
6176: LIST
6177: LIST
6178: PUSH
6179: LD_OWVAR 67
6183: ARRAY
6184: PPUSH
6185: CALL_OW 67
// if americanDestroyed then
6189: LD_EXP 4
6193: IFFALSE 6197
// exit ;
6195: GO 6225
// MC_InsertProduceList ( 4 , [ [ us_morphling , engine_siberite , control_manual , us_siberium_rocket ] ] ) ;
6197: LD_INT 4
6199: PPUSH
6200: LD_INT 5
6202: PUSH
6203: LD_INT 3
6205: PUSH
6206: LD_INT 1
6208: PUSH
6209: LD_INT 8
6211: PUSH
6212: EMPTY
6213: LIST
6214: LIST
6215: LIST
6216: LIST
6217: PUSH
6218: EMPTY
6219: LIST
6220: PPUSH
6221: CALL 43655 0 2
// end ; end_of_file
6225: END
// export function PrepareArabian ; var i , un , tmp , side ; begin
6226: LD_INT 0
6228: PPUSH
6229: PPUSH
6230: PPUSH
6231: PPUSH
6232: PPUSH
// side := 2 ;
6233: LD_ADDR_VAR 0 5
6237: PUSH
6238: LD_INT 2
6240: ST_TO_ADDR
// InitHc ;
6241: CALL_OW 19
// uc_side := side ;
6245: LD_ADDR_OWVAR 20
6249: PUSH
6250: LD_VAR 0 5
6254: ST_TO_ADDR
// uc_nation := 2 ;
6255: LD_ADDR_OWVAR 21
6259: PUSH
6260: LD_INT 2
6262: ST_TO_ADDR
// tmp := FilterAllUnits ( [ [ f_side , side ] , [ f_btype , b_bunker ] , [ f_empty ] ] ) ;
6263: LD_ADDR_VAR 0 4
6267: PUSH
6268: LD_INT 22
6270: PUSH
6271: LD_VAR 0 5
6275: PUSH
6276: EMPTY
6277: LIST
6278: LIST
6279: PUSH
6280: LD_INT 30
6282: PUSH
6283: LD_INT 32
6285: PUSH
6286: EMPTY
6287: LIST
6288: LIST
6289: PUSH
6290: LD_INT 58
6292: PUSH
6293: EMPTY
6294: LIST
6295: PUSH
6296: EMPTY
6297: LIST
6298: LIST
6299: LIST
6300: PPUSH
6301: CALL_OW 69
6305: ST_TO_ADDR
// for i = 1 to 10 do
6306: LD_ADDR_VAR 0 2
6310: PUSH
6311: DOUBLE
6312: LD_INT 1
6314: DEC
6315: ST_TO_ADDR
6316: LD_INT 10
6318: PUSH
6319: FOR_TO
6320: IFFALSE 6392
// begin uc_nation := nation_nature ;
6322: LD_ADDR_OWVAR 21
6326: PUSH
6327: LD_INT 0
6329: ST_TO_ADDR
// hc_class := class_apeman_soldier ;
6330: LD_ADDR_OWVAR 28
6334: PUSH
6335: LD_INT 15
6337: ST_TO_ADDR
// hc_gallery :=  ;
6338: LD_ADDR_OWVAR 33
6342: PUSH
6343: LD_STRING 
6345: ST_TO_ADDR
// hc_name :=  ;
6346: LD_ADDR_OWVAR 26
6350: PUSH
6351: LD_STRING 
6353: ST_TO_ADDR
// un := CreateHuman ;
6354: LD_ADDR_VAR 0 3
6358: PUSH
6359: CALL_OW 44
6363: ST_TO_ADDR
// PlaceHumanInUnit ( un , tmp [ tmp - i ] ) ;
6364: LD_VAR 0 3
6368: PPUSH
6369: LD_VAR 0 4
6373: PUSH
6374: LD_VAR 0 4
6378: PUSH
6379: LD_VAR 0 2
6383: MINUS
6384: ARRAY
6385: PPUSH
6386: CALL_OW 52
// end ;
6390: GO 6319
6392: POP
6393: POP
// PrepareBase ( ar_depot , arabianBaseArea ,  , [ 8 , 9 , 10 ] [ Difficulty ] , [ 3000 , 500 , 150 ] , [ 16 , 6 , 6 , 6 ] ) ;
6394: LD_INT 503
6396: PPUSH
6397: LD_INT 27
6399: PPUSH
6400: LD_STRING 
6402: PPUSH
6403: LD_INT 8
6405: PUSH
6406: LD_INT 9
6408: PUSH
6409: LD_INT 10
6411: PUSH
6412: EMPTY
6413: LIST
6414: LIST
6415: LIST
6416: PUSH
6417: LD_OWVAR 67
6421: ARRAY
6422: PPUSH
6423: LD_INT 3000
6425: PUSH
6426: LD_INT 500
6428: PUSH
6429: LD_INT 150
6431: PUSH
6432: EMPTY
6433: LIST
6434: LIST
6435: LIST
6436: PPUSH
6437: LD_INT 16
6439: PUSH
6440: LD_INT 6
6442: PUSH
6443: LD_INT 6
6445: PUSH
6446: LD_INT 6
6448: PUSH
6449: EMPTY
6450: LIST
6451: LIST
6452: LIST
6453: LIST
6454: PPUSH
6455: CALL 60240 0 6
// mc_bases := Replace ( mc_bases , 1 , FilterAllUnits ( [ [ f_side , side ] , [ f_nation , 2 ] , [ f_not , [ f_type , unit_vehicle ] ] ] ) ) ;
6459: LD_ADDR_EXP 74
6463: PUSH
6464: LD_EXP 74
6468: PPUSH
6469: LD_INT 1
6471: PPUSH
6472: LD_INT 22
6474: PUSH
6475: LD_VAR 0 5
6479: PUSH
6480: EMPTY
6481: LIST
6482: LIST
6483: PUSH
6484: LD_INT 23
6486: PUSH
6487: LD_INT 2
6489: PUSH
6490: EMPTY
6491: LIST
6492: LIST
6493: PUSH
6494: LD_INT 3
6496: PUSH
6497: LD_INT 21
6499: PUSH
6500: LD_INT 2
6502: PUSH
6503: EMPTY
6504: LIST
6505: LIST
6506: PUSH
6507: EMPTY
6508: LIST
6509: LIST
6510: PUSH
6511: EMPTY
6512: LIST
6513: LIST
6514: LIST
6515: PPUSH
6516: CALL_OW 69
6520: PPUSH
6521: CALL_OW 1
6525: ST_TO_ADDR
// end ;
6526: LD_VAR 0 1
6530: RET
// export Omar ; export function PrepareOmarAli ; begin
6531: LD_INT 0
6533: PPUSH
// uc_side := 5 ;
6534: LD_ADDR_OWVAR 20
6538: PUSH
6539: LD_INT 5
6541: ST_TO_ADDR
// uc_nation := 2 ;
6542: LD_ADDR_OWVAR 21
6546: PUSH
6547: LD_INT 2
6549: ST_TO_ADDR
// Omar := NewCharacter ( Omar ) ;
6550: LD_ADDR_EXP 48
6554: PUSH
6555: LD_STRING Omar
6557: PPUSH
6558: CALL_OW 25
6562: ST_TO_ADDR
// PlaceUnitXY ( Omar , 330 , 244 , false ) ;
6563: LD_EXP 48
6567: PPUSH
6568: LD_INT 330
6570: PPUSH
6571: LD_INT 244
6573: PPUSH
6574: LD_INT 0
6576: PPUSH
6577: CALL_OW 48
// ComMoveUnit ( Omar , NearestUnitToUnit ( FilterAllUnits ( [ f_side , 7 ] ) , Omar ) ) ;
6581: LD_EXP 48
6585: PPUSH
6586: LD_INT 22
6588: PUSH
6589: LD_INT 7
6591: PUSH
6592: EMPTY
6593: LIST
6594: LIST
6595: PPUSH
6596: CALL_OW 69
6600: PPUSH
6601: LD_EXP 48
6605: PPUSH
6606: CALL_OW 74
6610: PPUSH
6611: CALL_OW 112
// end ; end_of_file
6615: LD_VAR 0 1
6619: RET
// export Schulz , Kozlov ; export function PrepareLegion ; var i , side , un , tmp ; begin
6620: LD_INT 0
6622: PPUSH
6623: PPUSH
6624: PPUSH
6625: PPUSH
6626: PPUSH
// side := 8 ;
6627: LD_ADDR_VAR 0 3
6631: PUSH
6632: LD_INT 8
6634: ST_TO_ADDR
// InitHc ;
6635: CALL_OW 19
// uc_side := side ;
6639: LD_ADDR_OWVAR 20
6643: PUSH
6644: LD_VAR 0 3
6648: ST_TO_ADDR
// uc_nation := 2 ;
6649: LD_ADDR_OWVAR 21
6653: PUSH
6654: LD_INT 2
6656: ST_TO_ADDR
// for i in FilterAllUnits ( [ [ f_side , side ] , [ f_type , unit_building ] ] ) do
6657: LD_ADDR_VAR 0 2
6661: PUSH
6662: LD_INT 22
6664: PUSH
6665: LD_VAR 0 3
6669: PUSH
6670: EMPTY
6671: LIST
6672: LIST
6673: PUSH
6674: LD_INT 21
6676: PUSH
6677: LD_INT 3
6679: PUSH
6680: EMPTY
6681: LIST
6682: LIST
6683: PUSH
6684: EMPTY
6685: LIST
6686: LIST
6687: PPUSH
6688: CALL_OW 69
6692: PUSH
6693: FOR_IN
6694: IFFALSE 6710
// SetBLevel ( i , 10 ) ;
6696: LD_VAR 0 2
6700: PPUSH
6701: LD_INT 10
6703: PPUSH
6704: CALL_OW 241
6708: GO 6693
6710: POP
6711: POP
// Schulz := NewCharacter ( Schulz ) ;
6712: LD_ADDR_EXP 49
6716: PUSH
6717: LD_STRING Schulz
6719: PPUSH
6720: CALL_OW 25
6724: ST_TO_ADDR
// Kozlov := PrepareUnit ( Kozlov , false ,  ) ;
6725: LD_ADDR_EXP 50
6729: PUSH
6730: LD_STRING Kozlov
6732: PPUSH
6733: LD_INT 0
6735: PPUSH
6736: LD_STRING 
6738: PPUSH
6739: CALL 49865 0 3
6743: ST_TO_ADDR
// PlaceHumanInUnit ( Kozlov , FilterAllUnits ( [ [ f_side , 8 ] , [ f_nation , 3 ] , [ f_btype , b_lab_full ] ] ) [ 1 ] ) ;
6744: LD_EXP 50
6748: PPUSH
6749: LD_INT 22
6751: PUSH
6752: LD_INT 8
6754: PUSH
6755: EMPTY
6756: LIST
6757: LIST
6758: PUSH
6759: LD_INT 23
6761: PUSH
6762: LD_INT 3
6764: PUSH
6765: EMPTY
6766: LIST
6767: LIST
6768: PUSH
6769: LD_INT 30
6771: PUSH
6772: LD_INT 8
6774: PUSH
6775: EMPTY
6776: LIST
6777: LIST
6778: PUSH
6779: EMPTY
6780: LIST
6781: LIST
6782: LIST
6783: PPUSH
6784: CALL_OW 69
6788: PUSH
6789: LD_INT 1
6791: ARRAY
6792: PPUSH
6793: CALL_OW 52
// SetSkill ( Kozlov , class_mechanic , 10 ) ;
6797: LD_EXP 50
6801: PPUSH
6802: LD_INT 3
6804: PPUSH
6805: LD_INT 10
6807: PPUSH
6808: CALL_OW 237
// tmp := FilterAllUnits ( [ [ f_side , side ] , [ f_btype , b_bunker ] , [ f_empty ] ] ) ;
6812: LD_ADDR_VAR 0 5
6816: PUSH
6817: LD_INT 22
6819: PUSH
6820: LD_VAR 0 3
6824: PUSH
6825: EMPTY
6826: LIST
6827: LIST
6828: PUSH
6829: LD_INT 30
6831: PUSH
6832: LD_INT 32
6834: PUSH
6835: EMPTY
6836: LIST
6837: LIST
6838: PUSH
6839: LD_INT 58
6841: PUSH
6842: EMPTY
6843: LIST
6844: PUSH
6845: EMPTY
6846: LIST
6847: LIST
6848: LIST
6849: PPUSH
6850: CALL_OW 69
6854: ST_TO_ADDR
// for i = 1 to 10 do
6855: LD_ADDR_VAR 0 2
6859: PUSH
6860: DOUBLE
6861: LD_INT 1
6863: DEC
6864: ST_TO_ADDR
6865: LD_INT 10
6867: PUSH
6868: FOR_TO
6869: IFFALSE 6941
// begin uc_nation := nation_nature ;
6871: LD_ADDR_OWVAR 21
6875: PUSH
6876: LD_INT 0
6878: ST_TO_ADDR
// hc_class := class_apeman_soldier ;
6879: LD_ADDR_OWVAR 28
6883: PUSH
6884: LD_INT 15
6886: ST_TO_ADDR
// hc_gallery :=  ;
6887: LD_ADDR_OWVAR 33
6891: PUSH
6892: LD_STRING 
6894: ST_TO_ADDR
// hc_name :=  ;
6895: LD_ADDR_OWVAR 26
6899: PUSH
6900: LD_STRING 
6902: ST_TO_ADDR
// un := CreateHuman ;
6903: LD_ADDR_VAR 0 4
6907: PUSH
6908: CALL_OW 44
6912: ST_TO_ADDR
// PlaceHumanInUnit ( un , tmp [ tmp - i ] ) ;
6913: LD_VAR 0 4
6917: PPUSH
6918: LD_VAR 0 5
6922: PUSH
6923: LD_VAR 0 5
6927: PUSH
6928: LD_VAR 0 2
6932: MINUS
6933: ARRAY
6934: PPUSH
6935: CALL_OW 52
// end ;
6939: GO 6868
6941: POP
6942: POP
// PrepareBase ( ar_depot1 , legionBaseArea ,  , [ 8 , 9 , 10 ] [ Difficulty ] , [ 3000 , 500 , 150 ] , [ 16 , 6 , 6 , 8 ] ) ;
6943: LD_INT 324
6945: PPUSH
6946: LD_INT 3
6948: PPUSH
6949: LD_STRING 
6951: PPUSH
6952: LD_INT 8
6954: PUSH
6955: LD_INT 9
6957: PUSH
6958: LD_INT 10
6960: PUSH
6961: EMPTY
6962: LIST
6963: LIST
6964: LIST
6965: PUSH
6966: LD_OWVAR 67
6970: ARRAY
6971: PPUSH
6972: LD_INT 3000
6974: PUSH
6975: LD_INT 500
6977: PUSH
6978: LD_INT 150
6980: PUSH
6981: EMPTY
6982: LIST
6983: LIST
6984: LIST
6985: PPUSH
6986: LD_INT 16
6988: PUSH
6989: LD_INT 6
6991: PUSH
6992: LD_INT 6
6994: PUSH
6995: LD_INT 8
6997: PUSH
6998: EMPTY
6999: LIST
7000: LIST
7001: LIST
7002: LIST
7003: PPUSH
7004: CALL 60240 0 6
// mc_bases := Replace ( mc_bases , 3 , FilterAllUnits ( [ [ f_side , side ] , [ f_nation , 2 ] , [ f_not , [ f_type , unit_vehicle ] ] ] ) diff Schulz ) ;
7008: LD_ADDR_EXP 74
7012: PUSH
7013: LD_EXP 74
7017: PPUSH
7018: LD_INT 3
7020: PPUSH
7021: LD_INT 22
7023: PUSH
7024: LD_VAR 0 3
7028: PUSH
7029: EMPTY
7030: LIST
7031: LIST
7032: PUSH
7033: LD_INT 23
7035: PUSH
7036: LD_INT 2
7038: PUSH
7039: EMPTY
7040: LIST
7041: LIST
7042: PUSH
7043: LD_INT 3
7045: PUSH
7046: LD_INT 21
7048: PUSH
7049: LD_INT 2
7051: PUSH
7052: EMPTY
7053: LIST
7054: LIST
7055: PUSH
7056: EMPTY
7057: LIST
7058: LIST
7059: PUSH
7060: EMPTY
7061: LIST
7062: LIST
7063: LIST
7064: PPUSH
7065: CALL_OW 69
7069: PUSH
7070: LD_EXP 49
7074: DIFF
7075: PPUSH
7076: CALL_OW 1
7080: ST_TO_ADDR
// end ;
7081: LD_VAR 0 1
7085: RET
// export function BuildKozlovBomb ; begin
7086: LD_INT 0
7088: PPUSH
// if not IsOk ( kozlov_fac ) or not IsOk ( kozlov_lab ) then
7089: LD_INT 332
7091: PPUSH
7092: CALL_OW 302
7096: NOT
7097: PUSH
7098: LD_INT 336
7100: PPUSH
7101: CALL_OW 302
7105: NOT
7106: OR
7107: IFFALSE 7111
// exit ;
7109: GO 7208
// ComChangeProfession ( Kozlov , 4 ) ;
7111: LD_EXP 50
7115: PPUSH
7116: LD_INT 4
7118: PPUSH
7119: CALL_OW 123
// ComResearch ( kozlov_lab , tech_sibFiss ) ;
7123: LD_INT 336
7125: PPUSH
7126: LD_INT 25
7128: PPUSH
7129: CALL_OW 124
// repeat wait ( 0 0$1 ) ;
7133: LD_INT 35
7135: PPUSH
7136: CALL_OW 67
// until GetTech ( tech_sibFiss , 8 ) = state_researched ;
7140: LD_INT 25
7142: PPUSH
7143: LD_INT 8
7145: PPUSH
7146: CALL_OW 321
7150: PUSH
7151: LD_INT 2
7153: EQUAL
7154: IFFALSE 7133
// ComExitBuilding ( Kozlov ) ;
7156: LD_EXP 50
7160: PPUSH
7161: CALL_OW 122
// AddComEnterUnit ( Kozlov , kozlov_fac ) ;
7165: LD_EXP 50
7169: PPUSH
7170: LD_INT 332
7172: PPUSH
7173: CALL_OW 180
// AddComChangeProfession ( Kozlov , 3 ) ;
7177: LD_EXP 50
7181: PPUSH
7182: LD_INT 3
7184: PPUSH
7185: CALL_OW 183
// ComConstruct ( kozlov_fac , ru_heavy_wheeled , engine_siberite , control_manual , ru_siberium_rocket ) ;
7189: LD_INT 332
7191: PPUSH
7192: LD_INT 23
7194: PPUSH
7195: LD_INT 3
7197: PPUSH
7198: LD_INT 1
7200: PPUSH
7201: LD_INT 48
7203: PPUSH
7204: CALL_OW 125
// end ;
7208: LD_VAR 0 1
7212: RET
// every 11 11$30 trigger not legionDestroyed and not MC_GetVehicles ( 3 , true ) do var i , tmp , target ;
7213: LD_EXP 3
7217: NOT
7218: PUSH
7219: LD_INT 3
7221: PPUSH
7222: LD_INT 1
7224: PPUSH
7225: CALL 45073 0 2
7229: NOT
7230: AND
7231: IFFALSE 8071
7233: GO 7235
7235: DISABLE
7236: LD_INT 0
7238: PPUSH
7239: PPUSH
7240: PPUSH
// begin enable ;
7241: ENABLE
// if not FilterAllUnits ( [ [ f_side , 8 ] , [ f_nation , 2 ] , [ f_btype , b_factory ] ] ) then
7242: LD_INT 22
7244: PUSH
7245: LD_INT 8
7247: PUSH
7248: EMPTY
7249: LIST
7250: LIST
7251: PUSH
7252: LD_INT 23
7254: PUSH
7255: LD_INT 2
7257: PUSH
7258: EMPTY
7259: LIST
7260: LIST
7261: PUSH
7262: LD_INT 30
7264: PUSH
7265: LD_INT 3
7267: PUSH
7268: EMPTY
7269: LIST
7270: LIST
7271: PUSH
7272: EMPTY
7273: LIST
7274: LIST
7275: LIST
7276: PPUSH
7277: CALL_OW 69
7281: NOT
7282: IFFALSE 7286
// exit ;
7284: GO 8071
// if Prob ( 40 ) then
7286: LD_INT 40
7288: PPUSH
7289: CALL_OW 13
7293: IFFALSE 7420
// begin MC_InsertProduceList ( 3 , [ [ ar_half_tracked , engine_combustion , control_remote , ar_rocket_launcher ] , [ ar_half_tracked , engine_combustion , control_remote , ar_rocket_launcher ] , [ ar_half_tracked , engine_combustion , control_remote , ar_rocket_launcher ] , [ ar_half_tracked , engine_combustion , control_remote , ar_rocket_launcher ] , [ ar_half_tracked , engine_combustion , control_remote , ar_rocket_launcher ] , [ ar_half_tracked , engine_combustion , control_remote , ar_flame_thrower ] , ] ) ;
7295: LD_INT 3
7297: PPUSH
7298: LD_INT 14
7300: PUSH
7301: LD_INT 1
7303: PUSH
7304: LD_INT 2
7306: PUSH
7307: LD_INT 28
7309: PUSH
7310: EMPTY
7311: LIST
7312: LIST
7313: LIST
7314: LIST
7315: PUSH
7316: LD_INT 14
7318: PUSH
7319: LD_INT 1
7321: PUSH
7322: LD_INT 2
7324: PUSH
7325: LD_INT 28
7327: PUSH
7328: EMPTY
7329: LIST
7330: LIST
7331: LIST
7332: LIST
7333: PUSH
7334: LD_INT 14
7336: PUSH
7337: LD_INT 1
7339: PUSH
7340: LD_INT 2
7342: PUSH
7343: LD_INT 28
7345: PUSH
7346: EMPTY
7347: LIST
7348: LIST
7349: LIST
7350: LIST
7351: PUSH
7352: LD_INT 14
7354: PUSH
7355: LD_INT 1
7357: PUSH
7358: LD_INT 2
7360: PUSH
7361: LD_INT 28
7363: PUSH
7364: EMPTY
7365: LIST
7366: LIST
7367: LIST
7368: LIST
7369: PUSH
7370: LD_INT 14
7372: PUSH
7373: LD_INT 1
7375: PUSH
7376: LD_INT 2
7378: PUSH
7379: LD_INT 28
7381: PUSH
7382: EMPTY
7383: LIST
7384: LIST
7385: LIST
7386: LIST
7387: PUSH
7388: LD_INT 14
7390: PUSH
7391: LD_INT 1
7393: PUSH
7394: LD_INT 2
7396: PUSH
7397: LD_INT 26
7399: PUSH
7400: EMPTY
7401: LIST
7402: LIST
7403: LIST
7404: LIST
7405: PUSH
7406: EMPTY
7407: LIST
7408: LIST
7409: LIST
7410: LIST
7411: LIST
7412: LIST
7413: PPUSH
7414: CALL 43655 0 2
// end else
7418: GO 7611
// begin MC_InsertProduceList ( 3 , [ [ ar_half_tracked , engine_combustion , control_remote , [ ar_gun , ar_flame_thrower , ar_flame_thrower ] [ Difficulty ] ] , [ ar_half_tracked , engine_combustion , control_remote , [ ar_gun , ar_flame_thrower , ar_flame_thrower ] [ Difficulty ] ] , [ ar_half_tracked , engine_combustion , control_remote , [ ar_flame_thrower , ar_flame_thrower , ar_selfpropelled_bomb ] [ Difficulty ] ] , [ ar_medium_trike , engine_combustion , control_remote , [ ar_flame_thrower , ar_selfpropelled_bomb , ar_selfpropelled_bomb ] [ Difficulty ] ] , [ ar_medium_trike , engine_combustion , control_remote , ar_selfpropelled_bomb ] , [ ar_half_tracked , engine_combustion , control_remote , ar_flame_thrower ] , ] ) ;
7420: LD_INT 3
7422: PPUSH
7423: LD_INT 14
7425: PUSH
7426: LD_INT 1
7428: PUSH
7429: LD_INT 2
7431: PUSH
7432: LD_INT 27
7434: PUSH
7435: LD_INT 26
7437: PUSH
7438: LD_INT 26
7440: PUSH
7441: EMPTY
7442: LIST
7443: LIST
7444: LIST
7445: PUSH
7446: LD_OWVAR 67
7450: ARRAY
7451: PUSH
7452: EMPTY
7453: LIST
7454: LIST
7455: LIST
7456: LIST
7457: PUSH
7458: LD_INT 14
7460: PUSH
7461: LD_INT 1
7463: PUSH
7464: LD_INT 2
7466: PUSH
7467: LD_INT 27
7469: PUSH
7470: LD_INT 26
7472: PUSH
7473: LD_INT 26
7475: PUSH
7476: EMPTY
7477: LIST
7478: LIST
7479: LIST
7480: PUSH
7481: LD_OWVAR 67
7485: ARRAY
7486: PUSH
7487: EMPTY
7488: LIST
7489: LIST
7490: LIST
7491: LIST
7492: PUSH
7493: LD_INT 14
7495: PUSH
7496: LD_INT 1
7498: PUSH
7499: LD_INT 2
7501: PUSH
7502: LD_INT 26
7504: PUSH
7505: LD_INT 26
7507: PUSH
7508: LD_INT 29
7510: PUSH
7511: EMPTY
7512: LIST
7513: LIST
7514: LIST
7515: PUSH
7516: LD_OWVAR 67
7520: ARRAY
7521: PUSH
7522: EMPTY
7523: LIST
7524: LIST
7525: LIST
7526: LIST
7527: PUSH
7528: LD_INT 13
7530: PUSH
7531: LD_INT 1
7533: PUSH
7534: LD_INT 2
7536: PUSH
7537: LD_INT 26
7539: PUSH
7540: LD_INT 29
7542: PUSH
7543: LD_INT 29
7545: PUSH
7546: EMPTY
7547: LIST
7548: LIST
7549: LIST
7550: PUSH
7551: LD_OWVAR 67
7555: ARRAY
7556: PUSH
7557: EMPTY
7558: LIST
7559: LIST
7560: LIST
7561: LIST
7562: PUSH
7563: LD_INT 13
7565: PUSH
7566: LD_INT 1
7568: PUSH
7569: LD_INT 2
7571: PUSH
7572: LD_INT 29
7574: PUSH
7575: EMPTY
7576: LIST
7577: LIST
7578: LIST
7579: LIST
7580: PUSH
7581: LD_INT 14
7583: PUSH
7584: LD_INT 1
7586: PUSH
7587: LD_INT 2
7589: PUSH
7590: LD_INT 26
7592: PUSH
7593: EMPTY
7594: LIST
7595: LIST
7596: LIST
7597: LIST
7598: PUSH
7599: EMPTY
7600: LIST
7601: LIST
7602: LIST
7603: LIST
7604: LIST
7605: LIST
7606: PPUSH
7607: CALL 43655 0 2
// end ; repeat wait ( 0 0$1 ) ;
7611: LD_INT 35
7613: PPUSH
7614: CALL_OW 67
// until MC_GetVehicles ( 3 , true ) >= 6 ;
7618: LD_INT 3
7620: PPUSH
7621: LD_INT 1
7623: PPUSH
7624: CALL 45073 0 2
7628: PUSH
7629: LD_INT 6
7631: GREATEREQUAL
7632: IFFALSE 7611
// wait ( 0 0$30 ) ;
7634: LD_INT 1050
7636: PPUSH
7637: CALL_OW 67
// tmp := MC_GetVehicles ( 3 , true ) ;
7641: LD_ADDR_VAR 0 2
7645: PUSH
7646: LD_INT 3
7648: PPUSH
7649: LD_INT 1
7651: PPUSH
7652: CALL 45073 0 2
7656: ST_TO_ADDR
// mc_vehicles := Replace ( mc_vehicles , 3 , mc_vehicles [ 3 ] diff tmp ) ;
7657: LD_ADDR_EXP 93
7661: PUSH
7662: LD_EXP 93
7666: PPUSH
7667: LD_INT 3
7669: PPUSH
7670: LD_EXP 93
7674: PUSH
7675: LD_INT 3
7677: ARRAY
7678: PUSH
7679: LD_VAR 0 2
7683: DIFF
7684: PPUSH
7685: CALL_OW 1
7689: ST_TO_ADDR
// target := rand ( 0 , 2 ) ;
7690: LD_ADDR_VAR 0 3
7694: PUSH
7695: LD_INT 0
7697: PPUSH
7698: LD_INT 2
7700: PPUSH
7701: CALL_OW 12
7705: ST_TO_ADDR
// if target then
7706: LD_VAR 0 3
7710: IFFALSE 7838
// begin repeat tmp := UnitFilter ( tmp , [ f_lives , 250 ] ) ;
7712: LD_ADDR_VAR 0 2
7716: PUSH
7717: LD_VAR 0 2
7721: PPUSH
7722: LD_INT 24
7724: PUSH
7725: LD_INT 250
7727: PUSH
7728: EMPTY
7729: LIST
7730: LIST
7731: PPUSH
7732: CALL_OW 72
7736: ST_TO_ADDR
// for i in tmp do
7737: LD_ADDR_VAR 0 1
7741: PUSH
7742: LD_VAR 0 2
7746: PUSH
7747: FOR_IN
7748: IFFALSE 7788
// if GetDistUnitXY ( i , 89 , 71 ) > 9 then
7750: LD_VAR 0 1
7754: PPUSH
7755: LD_INT 89
7757: PPUSH
7758: LD_INT 71
7760: PPUSH
7761: CALL_OW 297
7765: PUSH
7766: LD_INT 9
7768: GREATER
7769: IFFALSE 7786
// ComMoveXY ( i , 89 , 71 ) ;
7771: LD_VAR 0 1
7775: PPUSH
7776: LD_INT 89
7778: PPUSH
7779: LD_INT 71
7781: PPUSH
7782: CALL_OW 111
7786: GO 7747
7788: POP
7789: POP
// wait ( 0 0$1 ) ;
7790: LD_INT 35
7792: PPUSH
7793: CALL_OW 67
// until UnitFilter ( tmp , [ f_distxy , 89 , 71 , 9 ] ) >= ( tmp - 1 ) ;
7797: LD_VAR 0 2
7801: PPUSH
7802: LD_INT 92
7804: PUSH
7805: LD_INT 89
7807: PUSH
7808: LD_INT 71
7810: PUSH
7811: LD_INT 9
7813: PUSH
7814: EMPTY
7815: LIST
7816: LIST
7817: LIST
7818: LIST
7819: PPUSH
7820: CALL_OW 72
7824: PUSH
7825: LD_VAR 0 2
7829: PUSH
7830: LD_INT 1
7832: MINUS
7833: GREATEREQUAL
7834: IFFALSE 7712
// end else
7836: GO 7962
// begin repeat tmp := UnitFilter ( tmp , [ f_lives , 250 ] ) ;
7838: LD_ADDR_VAR 0 2
7842: PUSH
7843: LD_VAR 0 2
7847: PPUSH
7848: LD_INT 24
7850: PUSH
7851: LD_INT 250
7853: PUSH
7854: EMPTY
7855: LIST
7856: LIST
7857: PPUSH
7858: CALL_OW 72
7862: ST_TO_ADDR
// for i in tmp do
7863: LD_ADDR_VAR 0 1
7867: PUSH
7868: LD_VAR 0 2
7872: PUSH
7873: FOR_IN
7874: IFFALSE 7914
// if GetDistUnitXY ( i , 147 , 4 ) > 9 then
7876: LD_VAR 0 1
7880: PPUSH
7881: LD_INT 147
7883: PPUSH
7884: LD_INT 4
7886: PPUSH
7887: CALL_OW 297
7891: PUSH
7892: LD_INT 9
7894: GREATER
7895: IFFALSE 7912
// ComMoveXY ( i , 147 , 4 ) ;
7897: LD_VAR 0 1
7901: PPUSH
7902: LD_INT 147
7904: PPUSH
7905: LD_INT 4
7907: PPUSH
7908: CALL_OW 111
7912: GO 7873
7914: POP
7915: POP
// wait ( 0 0$1 ) ;
7916: LD_INT 35
7918: PPUSH
7919: CALL_OW 67
// until UnitFilter ( tmp , [ f_distxy , 147 , 4 , 9 ] ) >= ( tmp - 1 ) ;
7923: LD_VAR 0 2
7927: PPUSH
7928: LD_INT 92
7930: PUSH
7931: LD_INT 147
7933: PUSH
7934: LD_INT 4
7936: PUSH
7937: LD_INT 9
7939: PUSH
7940: EMPTY
7941: LIST
7942: LIST
7943: LIST
7944: LIST
7945: PPUSH
7946: CALL_OW 72
7950: PUSH
7951: LD_VAR 0 2
7955: PUSH
7956: LD_INT 1
7958: MINUS
7959: GREATEREQUAL
7960: IFFALSE 7838
// end ; repeat wait ( 0 0$1 ) ;
7962: LD_INT 35
7964: PPUSH
7965: CALL_OW 67
// for i in tmp do
7969: LD_ADDR_VAR 0 1
7973: PUSH
7974: LD_VAR 0 2
7978: PUSH
7979: FOR_IN
7980: IFFALSE 8062
// begin if GetLives ( i ) > 251 then
7982: LD_VAR 0 1
7986: PPUSH
7987: CALL_OW 256
7991: PUSH
7992: LD_INT 251
7994: GREATER
7995: IFFALSE 8033
// ComAttackUnit ( i , NearestUnitToUnit ( FilterAllUnits ( [ f_enemy , 8 ] ) , i ) ) else
7997: LD_VAR 0 1
8001: PPUSH
8002: LD_INT 81
8004: PUSH
8005: LD_INT 8
8007: PUSH
8008: EMPTY
8009: LIST
8010: LIST
8011: PPUSH
8012: CALL_OW 69
8016: PPUSH
8017: LD_VAR 0 1
8021: PPUSH
8022: CALL_OW 74
8026: PPUSH
8027: CALL_OW 115
8031: GO 8060
// if IsDead ( i ) then
8033: LD_VAR 0 1
8037: PPUSH
8038: CALL_OW 301
8042: IFFALSE 8060
// tmp := tmp diff i ;
8044: LD_ADDR_VAR 0 2
8048: PUSH
8049: LD_VAR 0 2
8053: PUSH
8054: LD_VAR 0 1
8058: DIFF
8059: ST_TO_ADDR
// end ;
8060: GO 7979
8062: POP
8063: POP
// until not tmp ;
8064: LD_VAR 0 2
8068: NOT
8069: IFFALSE 7962
// end ;
8071: PPOPN 3
8073: END
// every 0 0$1 trigger IsOk ( Kozlov ) and not legionDestroyed do
8074: LD_EXP 50
8078: PPUSH
8079: CALL_OW 302
8083: PUSH
8084: LD_EXP 3
8088: NOT
8089: AND
8090: IFFALSE 8099
8092: GO 8094
8094: DISABLE
// BuildKozlovBomb ;
8095: CALL 7086 0 0
8099: END
// every 0 0$3 trigger FilterAllUnits ( [ [ f_side , 8 ] , [ f_weapon , ru_siberium_rocket ] ] ) do
8100: LD_INT 22
8102: PUSH
8103: LD_INT 8
8105: PUSH
8106: EMPTY
8107: LIST
8108: LIST
8109: PUSH
8110: LD_INT 34
8112: PUSH
8113: LD_INT 48
8115: PUSH
8116: EMPTY
8117: LIST
8118: LIST
8119: PUSH
8120: EMPTY
8121: LIST
8122: LIST
8123: PPUSH
8124: CALL_OW 69
8128: IFFALSE 8176
8130: GO 8132
8132: DISABLE
// begin ComAttackPlace ( FilterAllUnits ( [ [ f_side , 8 ] , [ f_weapon , ru_siberium_rocket ] ] ) [ 1 ] , 173 , 96 ) ;
8133: LD_INT 22
8135: PUSH
8136: LD_INT 8
8138: PUSH
8139: EMPTY
8140: LIST
8141: LIST
8142: PUSH
8143: LD_INT 34
8145: PUSH
8146: LD_INT 48
8148: PUSH
8149: EMPTY
8150: LIST
8151: LIST
8152: PUSH
8153: EMPTY
8154: LIST
8155: LIST
8156: PPUSH
8157: CALL_OW 69
8161: PUSH
8162: LD_INT 1
8164: ARRAY
8165: PPUSH
8166: LD_INT 173
8168: PPUSH
8169: LD_INT 96
8171: PPUSH
8172: CALL_OW 116
// end ; end_of_file
8176: END
// export Platonov , Yakotich , Gleb , Bierezov ; export behemoths , behemothBuilders ; export function PrepareRussian ; var i , j , base , tmp , side , xy , b , teleport ; begin
8177: LD_INT 0
8179: PPUSH
8180: PPUSH
8181: PPUSH
8182: PPUSH
8183: PPUSH
8184: PPUSH
8185: PPUSH
8186: PPUSH
8187: PPUSH
// side := 3 ;
8188: LD_ADDR_VAR 0 6
8192: PUSH
8193: LD_INT 3
8195: ST_TO_ADDR
// InitHc ;
8196: CALL_OW 19
// uc_side := side ;
8200: LD_ADDR_OWVAR 20
8204: PUSH
8205: LD_VAR 0 6
8209: ST_TO_ADDR
// uc_nation := 3 ;
8210: LD_ADDR_OWVAR 21
8214: PUSH
8215: LD_INT 3
8217: ST_TO_ADDR
// for i in FilterAllUnits ( [ [ f_side , side ] , [ f_type , unit_building ] ] ) do
8218: LD_ADDR_VAR 0 2
8222: PUSH
8223: LD_INT 22
8225: PUSH
8226: LD_VAR 0 6
8230: PUSH
8231: EMPTY
8232: LIST
8233: LIST
8234: PUSH
8235: LD_INT 21
8237: PUSH
8238: LD_INT 3
8240: PUSH
8241: EMPTY
8242: LIST
8243: LIST
8244: PUSH
8245: EMPTY
8246: LIST
8247: LIST
8248: PPUSH
8249: CALL_OW 69
8253: PUSH
8254: FOR_IN
8255: IFFALSE 8271
// SetBLevel ( i , 10 ) ;
8257: LD_VAR 0 2
8261: PPUSH
8262: LD_INT 10
8264: PPUSH
8265: CALL_OW 241
8269: GO 8254
8271: POP
8272: POP
// teleport := FilterAllUnits ( [ [ f_side , side ] , [ f_btype , b_teleport ] ] ) ;
8273: LD_ADDR_VAR 0 9
8277: PUSH
8278: LD_INT 22
8280: PUSH
8281: LD_VAR 0 6
8285: PUSH
8286: EMPTY
8287: LIST
8288: LIST
8289: PUSH
8290: LD_INT 30
8292: PUSH
8293: LD_INT 34
8295: PUSH
8296: EMPTY
8297: LIST
8298: LIST
8299: PUSH
8300: EMPTY
8301: LIST
8302: LIST
8303: PPUSH
8304: CALL_OW 69
8308: ST_TO_ADDR
// if teleport then
8309: LD_VAR 0 9
8313: IFFALSE 8334
// TeleportExit ( teleport [ 1 ] , 123 , 122 ) ;
8315: LD_VAR 0 9
8319: PUSH
8320: LD_INT 1
8322: ARRAY
8323: PPUSH
8324: LD_INT 123
8326: PPUSH
8327: LD_INT 122
8329: PPUSH
8330: CALL_OW 243
// hc_importance := 0 ;
8334: LD_ADDR_OWVAR 32
8338: PUSH
8339: LD_INT 0
8341: ST_TO_ADDR
// Platonov := NewCharacter ( Platonov ) ;
8342: LD_ADDR_EXP 51
8346: PUSH
8347: LD_STRING Platonov
8349: PPUSH
8350: CALL_OW 25
8354: ST_TO_ADDR
// Yakotich := NewCharacter ( Yakotich ) ;
8355: LD_ADDR_EXP 52
8359: PUSH
8360: LD_STRING Yakotich
8362: PPUSH
8363: CALL_OW 25
8367: ST_TO_ADDR
// Gleb := NewCharacter ( Gleb ) ;
8368: LD_ADDR_EXP 53
8372: PUSH
8373: LD_STRING Gleb
8375: PPUSH
8376: CALL_OW 25
8380: ST_TO_ADDR
// if TestCharacters ( 03_Cornel ) then
8381: LD_STRING 03_Cornel
8383: PPUSH
8384: CALL_OW 28
8388: IFFALSE 8436
// begin Bierezov := NewCharacter ( Mikhail ) ;
8390: LD_ADDR_EXP 54
8394: PUSH
8395: LD_STRING Mikhail
8397: PPUSH
8398: CALL_OW 25
8402: ST_TO_ADDR
// PlaceUnitXYR ( Bierezov , 197 , 111 , 9 , false ) ;
8403: LD_EXP 54
8407: PPUSH
8408: LD_INT 197
8410: PPUSH
8411: LD_INT 111
8413: PPUSH
8414: LD_INT 9
8416: PPUSH
8417: LD_INT 0
8419: PPUSH
8420: CALL_OW 50
// SetClass ( Bierezov , 3 ) ;
8424: LD_EXP 54
8428: PPUSH
8429: LD_INT 3
8431: PPUSH
8432: CALL_OW 336
// end ; PlaceHumanInUnit ( Platonov , ru_depot ) ;
8436: LD_EXP 51
8440: PPUSH
8441: LD_INT 126
8443: PPUSH
8444: CALL_OW 52
// PlaceUnitXYR ( Yakotich , 197 , 111 , 9 , false ) ;
8448: LD_EXP 52
8452: PPUSH
8453: LD_INT 197
8455: PPUSH
8456: LD_INT 111
8458: PPUSH
8459: LD_INT 9
8461: PPUSH
8462: LD_INT 0
8464: PPUSH
8465: CALL_OW 50
// PlaceUnitXYR ( Gleb , 197 , 111 , 9 , false ) ;
8469: LD_EXP 53
8473: PPUSH
8474: LD_INT 197
8476: PPUSH
8477: LD_INT 111
8479: PPUSH
8480: LD_INT 9
8482: PPUSH
8483: LD_INT 0
8485: PPUSH
8486: CALL_OW 50
// tmp := PrepareBase ( ru_depot , russianBaseArea , zhukov , [ 9 , 10 , 10 ] [ Difficulty ] , [ 90000 , 1000 , 300 ] , [ 21 , 8 , 13 , 8 ] ) ;
8490: LD_ADDR_VAR 0 5
8494: PUSH
8495: LD_INT 126
8497: PPUSH
8498: LD_INT 2
8500: PPUSH
8501: LD_STRING zhukov
8503: PPUSH
8504: LD_INT 9
8506: PUSH
8507: LD_INT 10
8509: PUSH
8510: LD_INT 10
8512: PUSH
8513: EMPTY
8514: LIST
8515: LIST
8516: LIST
8517: PUSH
8518: LD_OWVAR 67
8522: ARRAY
8523: PPUSH
8524: LD_INT 90000
8526: PUSH
8527: LD_INT 1000
8529: PUSH
8530: LD_INT 300
8532: PUSH
8533: EMPTY
8534: LIST
8535: LIST
8536: LIST
8537: PPUSH
8538: LD_INT 21
8540: PUSH
8541: LD_INT 8
8543: PUSH
8544: LD_INT 13
8546: PUSH
8547: LD_INT 8
8549: PUSH
8550: EMPTY
8551: LIST
8552: LIST
8553: LIST
8554: LIST
8555: PPUSH
8556: CALL 60240 0 6
8560: ST_TO_ADDR
// base := GetBase ( ru_depot2 ) ;
8561: LD_ADDR_VAR 0 4
8565: PUSH
8566: LD_INT 267
8568: PPUSH
8569: CALL_OW 274
8573: ST_TO_ADDR
// SetResourceType ( base , mat_cans , 5000 ) ;
8574: LD_VAR 0 4
8578: PPUSH
8579: LD_INT 1
8581: PPUSH
8582: LD_INT 5000
8584: PPUSH
8585: CALL_OW 277
// SetResourceType ( base , mat_oil , 200 ) ;
8589: LD_VAR 0 4
8593: PPUSH
8594: LD_INT 2
8596: PPUSH
8597: LD_INT 200
8599: PPUSH
8600: CALL_OW 277
// SetResourceType ( base , mat_siberit , 200 ) ;
8604: LD_VAR 0 4
8608: PPUSH
8609: LD_INT 3
8611: PPUSH
8612: LD_INT 200
8614: PPUSH
8615: CALL_OW 277
// mc_bases := Replace ( mc_bases , 2 , tmp union FilterAllUnits ( [ [ f_side , side ] , [ f_not , [ f_type , unit_vehicle ] ] ] ) diff Platonov ) ;
8619: LD_ADDR_EXP 74
8623: PUSH
8624: LD_EXP 74
8628: PPUSH
8629: LD_INT 2
8631: PPUSH
8632: LD_VAR 0 5
8636: PUSH
8637: LD_INT 22
8639: PUSH
8640: LD_VAR 0 6
8644: PUSH
8645: EMPTY
8646: LIST
8647: LIST
8648: PUSH
8649: LD_INT 3
8651: PUSH
8652: LD_INT 21
8654: PUSH
8655: LD_INT 2
8657: PUSH
8658: EMPTY
8659: LIST
8660: LIST
8661: PUSH
8662: EMPTY
8663: LIST
8664: LIST
8665: PUSH
8666: EMPTY
8667: LIST
8668: LIST
8669: PPUSH
8670: CALL_OW 69
8674: UNION
8675: PUSH
8676: LD_EXP 51
8680: DIFF
8681: PPUSH
8682: CALL_OW 1
8686: ST_TO_ADDR
// behemoths := [ ] ;
8687: LD_ADDR_EXP 55
8691: PUSH
8692: EMPTY
8693: ST_TO_ADDR
// behemothBuilders := [ ] ;
8694: LD_ADDR_EXP 56
8698: PUSH
8699: EMPTY
8700: ST_TO_ADDR
// j := 3 ;
8701: LD_ADDR_VAR 0 3
8705: PUSH
8706: LD_INT 3
8708: ST_TO_ADDR
// for i in FilterAllUnits ( [ [ f_side , 3 ] , [ f_class , 3 ] ] ) do
8709: LD_ADDR_VAR 0 2
8713: PUSH
8714: LD_INT 22
8716: PUSH
8717: LD_INT 3
8719: PUSH
8720: EMPTY
8721: LIST
8722: LIST
8723: PUSH
8724: LD_INT 25
8726: PUSH
8727: LD_INT 3
8729: PUSH
8730: EMPTY
8731: LIST
8732: LIST
8733: PUSH
8734: EMPTY
8735: LIST
8736: LIST
8737: PPUSH
8738: CALL_OW 69
8742: PUSH
8743: FOR_IN
8744: IFFALSE 8794
// begin behemothBuilders := Join ( behemothBuilders , i ) ;
8746: LD_ADDR_EXP 56
8750: PUSH
8751: LD_EXP 56
8755: PPUSH
8756: LD_VAR 0 2
8760: PPUSH
8761: CALL 92576 0 2
8765: ST_TO_ADDR
// j := j - 1 ;
8766: LD_ADDR_VAR 0 3
8770: PUSH
8771: LD_VAR 0 3
8775: PUSH
8776: LD_INT 1
8778: MINUS
8779: ST_TO_ADDR
// if j = 0 then
8780: LD_VAR 0 3
8784: PUSH
8785: LD_INT 0
8787: EQUAL
8788: IFFALSE 8792
// break ;
8790: GO 8794
// end ;
8792: GO 8743
8794: POP
8795: POP
// end ;
8796: LD_VAR 0 1
8800: RET
// export function BuildBehemoths ; var i , j , xy , tmp ; begin
8801: LD_INT 0
8803: PPUSH
8804: PPUSH
8805: PPUSH
8806: PPUSH
8807: PPUSH
// xy := [ [ 209 , 149 ] , [ 219 , 154 ] , [ 223 , 149 ] , [ 232 , 155 ] ] ;
8808: LD_ADDR_VAR 0 4
8812: PUSH
8813: LD_INT 209
8815: PUSH
8816: LD_INT 149
8818: PUSH
8819: EMPTY
8820: LIST
8821: LIST
8822: PUSH
8823: LD_INT 219
8825: PUSH
8826: LD_INT 154
8828: PUSH
8829: EMPTY
8830: LIST
8831: LIST
8832: PUSH
8833: LD_INT 223
8835: PUSH
8836: LD_INT 149
8838: PUSH
8839: EMPTY
8840: LIST
8841: LIST
8842: PUSH
8843: LD_INT 232
8845: PUSH
8846: LD_INT 155
8848: PUSH
8849: EMPTY
8850: LIST
8851: LIST
8852: PUSH
8853: EMPTY
8854: LIST
8855: LIST
8856: LIST
8857: LIST
8858: ST_TO_ADDR
// if not behemothBuilders then
8859: LD_EXP 56
8863: NOT
8864: IFFALSE 8868
// exit ;
8866: GO 8972
// j := 1 ;
8868: LD_ADDR_VAR 0 3
8872: PUSH
8873: LD_INT 1
8875: ST_TO_ADDR
// for i in behemothBuilders do
8876: LD_ADDR_VAR 0 2
8880: PUSH
8881: LD_EXP 56
8885: PUSH
8886: FOR_IN
8887: IFFALSE 8970
// begin if IsInUnit ( i ) then
8889: LD_VAR 0 2
8893: PPUSH
8894: CALL_OW 310
8898: IFFALSE 8909
// ComExitBuilding ( i ) ;
8900: LD_VAR 0 2
8904: PPUSH
8905: CALL_OW 122
// AddComBuildBehemoth ( i , b_behemoth , xy [ j ] [ 1 ] , xy [ j ] [ 2 ] , 0 ) ;
8909: LD_VAR 0 2
8913: PPUSH
8914: LD_INT 37
8916: PPUSH
8917: LD_VAR 0 4
8921: PUSH
8922: LD_VAR 0 3
8926: ARRAY
8927: PUSH
8928: LD_INT 1
8930: ARRAY
8931: PPUSH
8932: LD_VAR 0 4
8936: PUSH
8937: LD_VAR 0 3
8941: ARRAY
8942: PUSH
8943: LD_INT 2
8945: ARRAY
8946: PPUSH
8947: LD_INT 0
8949: PPUSH
8950: CALL_OW 230
// j := j + 1 ;
8954: LD_ADDR_VAR 0 3
8958: PUSH
8959: LD_VAR 0 3
8963: PUSH
8964: LD_INT 1
8966: PLUS
8967: ST_TO_ADDR
// end ;
8968: GO 8886
8970: POP
8971: POP
// end ;
8972: LD_VAR 0 1
8976: RET
// every 0 0$3 trigger GetBehemoths ( 3 ) and not FilterAllUnits ( [ [ f_side , 3 ] , [ f_btype , b_behemoth ] ] ) do var i , tmp ;
8977: LD_INT 3
8979: PPUSH
8980: CALL 92624 0 1
8984: PUSH
8985: LD_INT 22
8987: PUSH
8988: LD_INT 3
8990: PUSH
8991: EMPTY
8992: LIST
8993: LIST
8994: PUSH
8995: LD_INT 30
8997: PUSH
8998: LD_INT 37
9000: PUSH
9001: EMPTY
9002: LIST
9003: LIST
9004: PUSH
9005: EMPTY
9006: LIST
9007: LIST
9008: PPUSH
9009: CALL_OW 69
9013: NOT
9014: AND
9015: IFFALSE 9201
9017: GO 9019
9019: DISABLE
9020: LD_INT 0
9022: PPUSH
9023: PPUSH
// begin enable ;
9024: ENABLE
// tmp := GetBehemoths ( 3 ) ;
9025: LD_ADDR_VAR 0 2
9029: PUSH
9030: LD_INT 3
9032: PPUSH
9033: CALL 92624 0 1
9037: ST_TO_ADDR
// for i in tmp do
9038: LD_ADDR_VAR 0 1
9042: PUSH
9043: LD_VAR 0 2
9047: PUSH
9048: FOR_IN
9049: IFFALSE 9199
// begin if IsInArea ( i , powellBase ) and not GetTag ( i ) = 2 then
9051: LD_VAR 0 1
9055: PPUSH
9056: LD_INT 7
9058: PPUSH
9059: CALL_OW 308
9063: PUSH
9064: LD_VAR 0 1
9068: PPUSH
9069: CALL_OW 110
9073: PUSH
9074: LD_INT 2
9076: EQUAL
9077: NOT
9078: AND
9079: IFFALSE 9093
// SetTag ( i , 2 ) ;
9081: LD_VAR 0 1
9085: PPUSH
9086: LD_INT 2
9088: PPUSH
9089: CALL_OW 109
// if not FilterAllUnits ( [ [ f_enemy , 3 ] , [ f_dist , i , 12 ] ] ) and not GetTag ( i ) = 2 then
9093: LD_INT 81
9095: PUSH
9096: LD_INT 3
9098: PUSH
9099: EMPTY
9100: LIST
9101: LIST
9102: PUSH
9103: LD_INT 91
9105: PUSH
9106: LD_VAR 0 1
9110: PUSH
9111: LD_INT 12
9113: PUSH
9114: EMPTY
9115: LIST
9116: LIST
9117: LIST
9118: PUSH
9119: EMPTY
9120: LIST
9121: LIST
9122: PPUSH
9123: CALL_OW 69
9127: NOT
9128: PUSH
9129: LD_VAR 0 1
9133: PPUSH
9134: CALL_OW 110
9138: PUSH
9139: LD_INT 2
9141: EQUAL
9142: NOT
9143: AND
9144: IFFALSE 9163
// ComAgressiveMove ( i , 64 , 93 ) else
9146: LD_VAR 0 1
9150: PPUSH
9151: LD_INT 64
9153: PPUSH
9154: LD_INT 93
9156: PPUSH
9157: CALL_OW 114
9161: GO 9197
// ComAttackUnit ( i , NearestUnitToUnit ( FilterAllUnits ( [ f_enemy , 3 ] ) , i ) ) ;
9163: LD_VAR 0 1
9167: PPUSH
9168: LD_INT 81
9170: PUSH
9171: LD_INT 3
9173: PUSH
9174: EMPTY
9175: LIST
9176: LIST
9177: PPUSH
9178: CALL_OW 69
9182: PPUSH
9183: LD_VAR 0 1
9187: PPUSH
9188: CALL_OW 74
9192: PPUSH
9193: CALL_OW 115
// end ;
9197: GO 9048
9199: POP
9200: POP
// end ;
9201: PPOPN 2
9203: END
// every 11 11$30 trigger not russianDestroyed and not MC_GetVehicles ( 2 , true ) do var i , tmp , target , teleport ;
9204: LD_EXP 2
9208: NOT
9209: PUSH
9210: LD_INT 2
9212: PPUSH
9213: LD_INT 1
9215: PPUSH
9216: CALL 45073 0 2
9220: NOT
9221: AND
9222: IFFALSE 10142
9224: GO 9226
9226: DISABLE
9227: LD_INT 0
9229: PPUSH
9230: PPUSH
9231: PPUSH
9232: PPUSH
// begin enable ;
9233: ENABLE
// if not FilterAllUnits ( [ [ f_side , 3 ] , [ f_btype , b_factory ] ] ) then
9234: LD_INT 22
9236: PUSH
9237: LD_INT 3
9239: PUSH
9240: EMPTY
9241: LIST
9242: LIST
9243: PUSH
9244: LD_INT 30
9246: PUSH
9247: LD_INT 3
9249: PUSH
9250: EMPTY
9251: LIST
9252: LIST
9253: PUSH
9254: EMPTY
9255: LIST
9256: LIST
9257: PPUSH
9258: CALL_OW 69
9262: NOT
9263: IFFALSE 9267
// exit ;
9265: GO 10142
// teleport := FilterAllUnits ( [ [ f_side , 3 ] , [ f_btype , b_teleport ] ] ) ;
9267: LD_ADDR_VAR 0 4
9271: PUSH
9272: LD_INT 22
9274: PUSH
9275: LD_INT 3
9277: PUSH
9278: EMPTY
9279: LIST
9280: LIST
9281: PUSH
9282: LD_INT 30
9284: PUSH
9285: LD_INT 34
9287: PUSH
9288: EMPTY
9289: LIST
9290: LIST
9291: PUSH
9292: EMPTY
9293: LIST
9294: LIST
9295: PPUSH
9296: CALL_OW 69
9300: ST_TO_ADDR
// if Prob ( 40 ) then
9301: LD_INT 40
9303: PPUSH
9304: CALL_OW 13
9308: IFFALSE 9435
// begin MC_InsertProduceList ( 2 , [ [ ru_medium_tracked , engine_siberite , control_computer , ru_time_lapser ] , [ ru_medium_tracked , engine_siberite , control_computer , ru_time_lapser ] , [ ru_medium_tracked , engine_siberite , control_computer , ru_time_lapser ] , [ ru_heavy_tracked , engine_siberite , control_computer , ru_heavy_gun ] , [ ru_heavy_tracked , engine_siberite , control_computer , ru_heavy_gun ] , [ ru_heavy_tracked , engine_siberite , control_computer , ru_heavy_gun ] ] ) ;
9310: LD_INT 2
9312: PPUSH
9313: LD_INT 22
9315: PUSH
9316: LD_INT 3
9318: PUSH
9319: LD_INT 3
9321: PUSH
9322: LD_INT 49
9324: PUSH
9325: EMPTY
9326: LIST
9327: LIST
9328: LIST
9329: LIST
9330: PUSH
9331: LD_INT 22
9333: PUSH
9334: LD_INT 3
9336: PUSH
9337: LD_INT 3
9339: PUSH
9340: LD_INT 49
9342: PUSH
9343: EMPTY
9344: LIST
9345: LIST
9346: LIST
9347: LIST
9348: PUSH
9349: LD_INT 22
9351: PUSH
9352: LD_INT 3
9354: PUSH
9355: LD_INT 3
9357: PUSH
9358: LD_INT 49
9360: PUSH
9361: EMPTY
9362: LIST
9363: LIST
9364: LIST
9365: LIST
9366: PUSH
9367: LD_INT 24
9369: PUSH
9370: LD_INT 3
9372: PUSH
9373: LD_INT 3
9375: PUSH
9376: LD_INT 46
9378: PUSH
9379: EMPTY
9380: LIST
9381: LIST
9382: LIST
9383: LIST
9384: PUSH
9385: LD_INT 24
9387: PUSH
9388: LD_INT 3
9390: PUSH
9391: LD_INT 3
9393: PUSH
9394: LD_INT 46
9396: PUSH
9397: EMPTY
9398: LIST
9399: LIST
9400: LIST
9401: LIST
9402: PUSH
9403: LD_INT 24
9405: PUSH
9406: LD_INT 3
9408: PUSH
9409: LD_INT 3
9411: PUSH
9412: LD_INT 46
9414: PUSH
9415: EMPTY
9416: LIST
9417: LIST
9418: LIST
9419: LIST
9420: PUSH
9421: EMPTY
9422: LIST
9423: LIST
9424: LIST
9425: LIST
9426: LIST
9427: LIST
9428: PPUSH
9429: CALL 43655 0 2
// end else
9433: GO 9558
// begin MC_InsertProduceList ( 2 , [ [ ru_heavy_tracked , engine_siberite , control_computer , ru_rocket ] , [ ru_heavy_tracked , engine_siberite , control_computer , ru_rocket ] , [ ru_heavy_tracked , engine_siberite , control_computer , ru_rocket ] , [ ru_heavy_tracked , engine_siberite , control_computer , ru_heavy_gun ] , [ ru_heavy_tracked , engine_siberite , control_computer , ru_heavy_gun ] , [ ru_heavy_tracked , engine_siberite , control_computer , ru_heavy_gun ] ] ) ;
9435: LD_INT 2
9437: PPUSH
9438: LD_INT 24
9440: PUSH
9441: LD_INT 3
9443: PUSH
9444: LD_INT 3
9446: PUSH
9447: LD_INT 47
9449: PUSH
9450: EMPTY
9451: LIST
9452: LIST
9453: LIST
9454: LIST
9455: PUSH
9456: LD_INT 24
9458: PUSH
9459: LD_INT 3
9461: PUSH
9462: LD_INT 3
9464: PUSH
9465: LD_INT 47
9467: PUSH
9468: EMPTY
9469: LIST
9470: LIST
9471: LIST
9472: LIST
9473: PUSH
9474: LD_INT 24
9476: PUSH
9477: LD_INT 3
9479: PUSH
9480: LD_INT 3
9482: PUSH
9483: LD_INT 47
9485: PUSH
9486: EMPTY
9487: LIST
9488: LIST
9489: LIST
9490: LIST
9491: PUSH
9492: LD_INT 24
9494: PUSH
9495: LD_INT 3
9497: PUSH
9498: LD_INT 3
9500: PUSH
9501: LD_INT 46
9503: PUSH
9504: EMPTY
9505: LIST
9506: LIST
9507: LIST
9508: LIST
9509: PUSH
9510: LD_INT 24
9512: PUSH
9513: LD_INT 3
9515: PUSH
9516: LD_INT 3
9518: PUSH
9519: LD_INT 46
9521: PUSH
9522: EMPTY
9523: LIST
9524: LIST
9525: LIST
9526: LIST
9527: PUSH
9528: LD_INT 24
9530: PUSH
9531: LD_INT 3
9533: PUSH
9534: LD_INT 3
9536: PUSH
9537: LD_INT 46
9539: PUSH
9540: EMPTY
9541: LIST
9542: LIST
9543: LIST
9544: LIST
9545: PUSH
9546: EMPTY
9547: LIST
9548: LIST
9549: LIST
9550: LIST
9551: LIST
9552: LIST
9553: PPUSH
9554: CALL 43655 0 2
// end ; if Difficulty > 1 then
9558: LD_OWVAR 67
9562: PUSH
9563: LD_INT 1
9565: GREATER
9566: IFFALSE 9596
// MC_InsertProduceList ( 2 , [ [ ru_heavy_tracked , engine_siberite , control_computer , ru_rocket ] ] ) ;
9568: LD_INT 2
9570: PPUSH
9571: LD_INT 24
9573: PUSH
9574: LD_INT 3
9576: PUSH
9577: LD_INT 3
9579: PUSH
9580: LD_INT 47
9582: PUSH
9583: EMPTY
9584: LIST
9585: LIST
9586: LIST
9587: LIST
9588: PUSH
9589: EMPTY
9590: LIST
9591: PPUSH
9592: CALL 43655 0 2
// repeat wait ( 0 0$1 ) ;
9596: LD_INT 35
9598: PPUSH
9599: CALL_OW 67
// until MC_GetVehicles ( 2 , true ) >= [ 6 , 7 , 7 ] [ Difficulty ] ;
9603: LD_INT 2
9605: PPUSH
9606: LD_INT 1
9608: PPUSH
9609: CALL 45073 0 2
9613: PUSH
9614: LD_INT 6
9616: PUSH
9617: LD_INT 7
9619: PUSH
9620: LD_INT 7
9622: PUSH
9623: EMPTY
9624: LIST
9625: LIST
9626: LIST
9627: PUSH
9628: LD_OWVAR 67
9632: ARRAY
9633: GREATEREQUAL
9634: IFFALSE 9596
// wait ( 0 0$30 ) ;
9636: LD_INT 1050
9638: PPUSH
9639: CALL_OW 67
// tmp := MC_GetVehicles ( 2 , true ) ;
9643: LD_ADDR_VAR 0 2
9647: PUSH
9648: LD_INT 2
9650: PPUSH
9651: LD_INT 1
9653: PPUSH
9654: CALL 45073 0 2
9658: ST_TO_ADDR
// mc_vehicles := Replace ( mc_vehicles , 2 , mc_vehicles [ 2 ] diff tmp ) ;
9659: LD_ADDR_EXP 93
9663: PUSH
9664: LD_EXP 93
9668: PPUSH
9669: LD_INT 2
9671: PPUSH
9672: LD_EXP 93
9676: PUSH
9677: LD_INT 2
9679: ARRAY
9680: PUSH
9681: LD_VAR 0 2
9685: DIFF
9686: PPUSH
9687: CALL_OW 1
9691: ST_TO_ADDR
// target := rand ( 0 , 1 ) ;
9692: LD_ADDR_VAR 0 3
9696: PUSH
9697: LD_INT 0
9699: PPUSH
9700: LD_INT 1
9702: PPUSH
9703: CALL_OW 12
9707: ST_TO_ADDR
// if target then
9708: LD_VAR 0 3
9712: IFFALSE 9840
// begin repeat tmp := UnitFilter ( tmp , [ f_lives , 250 ] ) ;
9714: LD_ADDR_VAR 0 2
9718: PUSH
9719: LD_VAR 0 2
9723: PPUSH
9724: LD_INT 24
9726: PUSH
9727: LD_INT 250
9729: PUSH
9730: EMPTY
9731: LIST
9732: LIST
9733: PPUSH
9734: CALL_OW 72
9738: ST_TO_ADDR
// for i in tmp do
9739: LD_ADDR_VAR 0 1
9743: PUSH
9744: LD_VAR 0 2
9748: PUSH
9749: FOR_IN
9750: IFFALSE 9790
// if GetDistUnitXY ( i , 139 , 89 ) > 9 then
9752: LD_VAR 0 1
9756: PPUSH
9757: LD_INT 139
9759: PPUSH
9760: LD_INT 89
9762: PPUSH
9763: CALL_OW 297
9767: PUSH
9768: LD_INT 9
9770: GREATER
9771: IFFALSE 9788
// ComMoveXY ( i , 139 , 89 ) ;
9773: LD_VAR 0 1
9777: PPUSH
9778: LD_INT 139
9780: PPUSH
9781: LD_INT 89
9783: PPUSH
9784: CALL_OW 111
9788: GO 9749
9790: POP
9791: POP
// wait ( 0 0$1 ) ;
9792: LD_INT 35
9794: PPUSH
9795: CALL_OW 67
// until UnitFilter ( tmp , [ f_distxy , 139 , 89 , 9 ] ) >= ( tmp - 1 ) ;
9799: LD_VAR 0 2
9803: PPUSH
9804: LD_INT 92
9806: PUSH
9807: LD_INT 139
9809: PUSH
9810: LD_INT 89
9812: PUSH
9813: LD_INT 9
9815: PUSH
9816: EMPTY
9817: LIST
9818: LIST
9819: LIST
9820: LIST
9821: PPUSH
9822: CALL_OW 72
9826: PUSH
9827: LD_VAR 0 2
9831: PUSH
9832: LD_INT 1
9834: MINUS
9835: GREATEREQUAL
9836: IFFALSE 9714
// end else
9838: GO 9982
// begin ComEnterUnit ( tmp , teleport [ 1 ] ) ;
9840: LD_VAR 0 2
9844: PPUSH
9845: LD_VAR 0 4
9849: PUSH
9850: LD_INT 1
9852: ARRAY
9853: PPUSH
9854: CALL_OW 120
// repeat tmp := UnitFilter ( tmp , [ f_lives , 250 ] ) ;
9858: LD_ADDR_VAR 0 2
9862: PUSH
9863: LD_VAR 0 2
9867: PPUSH
9868: LD_INT 24
9870: PUSH
9871: LD_INT 250
9873: PUSH
9874: EMPTY
9875: LIST
9876: LIST
9877: PPUSH
9878: CALL_OW 72
9882: ST_TO_ADDR
// for i in tmp do
9883: LD_ADDR_VAR 0 1
9887: PUSH
9888: LD_VAR 0 2
9892: PUSH
9893: FOR_IN
9894: IFFALSE 9934
// if GetDistUnitXY ( i , 124 , 139 ) > 9 then
9896: LD_VAR 0 1
9900: PPUSH
9901: LD_INT 124
9903: PPUSH
9904: LD_INT 139
9906: PPUSH
9907: CALL_OW 297
9911: PUSH
9912: LD_INT 9
9914: GREATER
9915: IFFALSE 9932
// ComMoveXY ( i , 124 , 139 ) ;
9917: LD_VAR 0 1
9921: PPUSH
9922: LD_INT 124
9924: PPUSH
9925: LD_INT 139
9927: PPUSH
9928: CALL_OW 111
9932: GO 9893
9934: POP
9935: POP
// wait ( 0 0$1 ) ;
9936: LD_INT 35
9938: PPUSH
9939: CALL_OW 67
// until UnitFilter ( tmp , [ f_distxy , 124 , 139 , 9 ] ) >= ( tmp - 1 ) ;
9943: LD_VAR 0 2
9947: PPUSH
9948: LD_INT 92
9950: PUSH
9951: LD_INT 124
9953: PUSH
9954: LD_INT 139
9956: PUSH
9957: LD_INT 9
9959: PUSH
9960: EMPTY
9961: LIST
9962: LIST
9963: LIST
9964: LIST
9965: PPUSH
9966: CALL_OW 72
9970: PUSH
9971: LD_VAR 0 2
9975: PUSH
9976: LD_INT 1
9978: MINUS
9979: GREATEREQUAL
9980: IFFALSE 9858
// end ; repeat wait ( 0 0$1 ) ;
9982: LD_INT 35
9984: PPUSH
9985: CALL_OW 67
// for i in tmp do
9989: LD_ADDR_VAR 0 1
9993: PUSH
9994: LD_VAR 0 2
9998: PUSH
9999: FOR_IN
10000: IFFALSE 10133
// begin if GetLives ( i ) > 251 then
10002: LD_VAR 0 1
10006: PPUSH
10007: CALL_OW 256
10011: PUSH
10012: LD_INT 251
10014: GREATER
10015: IFFALSE 10104
// begin if GetWeapon ( i ) = ru_time_lapser then
10017: LD_VAR 0 1
10021: PPUSH
10022: CALL_OW 264
10026: PUSH
10027: LD_INT 49
10029: EQUAL
10030: IFFALSE 10068
// ComMoveUnit ( i , NearestUnitToUnit ( FilterAllUnits ( [ f_enemy , 3 ] ) , i ) ) else
10032: LD_VAR 0 1
10036: PPUSH
10037: LD_INT 81
10039: PUSH
10040: LD_INT 3
10042: PUSH
10043: EMPTY
10044: LIST
10045: LIST
10046: PPUSH
10047: CALL_OW 69
10051: PPUSH
10052: LD_VAR 0 1
10056: PPUSH
10057: CALL_OW 74
10061: PPUSH
10062: CALL_OW 112
10066: GO 10102
// ComAttackUnit ( i , NearestUnitToUnit ( FilterAllUnits ( [ f_enemy , 3 ] ) , i ) ) ;
10068: LD_VAR 0 1
10072: PPUSH
10073: LD_INT 81
10075: PUSH
10076: LD_INT 3
10078: PUSH
10079: EMPTY
10080: LIST
10081: LIST
10082: PPUSH
10083: CALL_OW 69
10087: PPUSH
10088: LD_VAR 0 1
10092: PPUSH
10093: CALL_OW 74
10097: PPUSH
10098: CALL_OW 115
// end else
10102: GO 10131
// if IsDead ( i ) then
10104: LD_VAR 0 1
10108: PPUSH
10109: CALL_OW 301
10113: IFFALSE 10131
// tmp := tmp diff i ;
10115: LD_ADDR_VAR 0 2
10119: PUSH
10120: LD_VAR 0 2
10124: PUSH
10125: LD_VAR 0 1
10129: DIFF
10130: ST_TO_ADDR
// end ;
10131: GO 9999
10133: POP
10134: POP
// until not tmp ;
10135: LD_VAR 0 2
10139: NOT
10140: IFFALSE 9982
// end ;
10142: PPOPN 4
10144: END
// every 30 30$00 trigger not russianDestroyed do
10145: LD_EXP 2
10149: NOT
10150: IFFALSE 10215
10152: GO 10154
10154: DISABLE
// begin wait ( [ 50 50$00 , 40 40$00 , 30 30$00 ] [ Difficulty ] ) ;
10155: LD_INT 105000
10157: PUSH
10158: LD_INT 84000
10160: PUSH
10161: LD_INT 63000
10163: PUSH
10164: EMPTY
10165: LIST
10166: LIST
10167: LIST
10168: PUSH
10169: LD_OWVAR 67
10173: ARRAY
10174: PPUSH
10175: CALL_OW 67
// if russianDestroyed then
10179: LD_EXP 2
10183: IFFALSE 10187
// exit ;
10185: GO 10215
// MC_InsertProduceList ( 2 , [ [ ru_heavy_wheeled , engine_siberite , control_manual , ru_siberium_rocket ] ] ) ;
10187: LD_INT 2
10189: PPUSH
10190: LD_INT 23
10192: PUSH
10193: LD_INT 3
10195: PUSH
10196: LD_INT 1
10198: PUSH
10199: LD_INT 48
10201: PUSH
10202: EMPTY
10203: LIST
10204: LIST
10205: LIST
10206: LIST
10207: PUSH
10208: EMPTY
10209: LIST
10210: PPUSH
10211: CALL 43655 0 2
// end ; end_of_file
10215: END
// export function CustomEvent ( event ) ; begin
10216: LD_INT 0
10218: PPUSH
// end ;
10219: LD_VAR 0 2
10223: RET
// on SibDepositContaminated ( unit , x , y ) do begin if InArea ( x , y , motherLodeArea ) then
10224: LD_VAR 0 2
10228: PPUSH
10229: LD_VAR 0 3
10233: PPUSH
10234: LD_INT 15
10236: PPUSH
10237: CALL_OW 309
10241: IFFALSE 10250
// YouLost ( MothContaminate ) ;
10243: LD_STRING MothContaminate
10245: PPUSH
10246: CALL_OW 104
// end ;
10250: PPOPN 3
10252: END
// on SiberiteRocketExploded ( unit , x , y ) do begin if InArea ( x , y , motherLodeArea ) then
10253: LD_VAR 0 2
10257: PPUSH
10258: LD_VAR 0 3
10262: PPUSH
10263: LD_INT 15
10265: PPUSH
10266: CALL_OW 309
10270: IFFALSE 10286
// begin wait ( 0 0$6 ) ;
10272: LD_INT 210
10274: PPUSH
10275: CALL_OW 67
// YouLost ( MothContaminateBomb ) ;
10279: LD_STRING MothContaminateBomb
10281: PPUSH
10282: CALL_OW 104
// end ; end ;
10286: PPOPN 3
10288: END
// on UnitDestroyed ( un ) do begin if un = JMM then
10289: LD_VAR 0 1
10293: PUSH
10294: LD_EXP 12
10298: EQUAL
10299: IFFALSE 10310
// begin YouLost ( JMM ) ;
10301: LD_STRING JMM
10303: PPUSH
10304: CALL_OW 104
// exit ;
10308: GO 10359
// end ; if un = Powell then
10310: LD_VAR 0 1
10314: PUSH
10315: LD_EXP 47
10319: EQUAL
10320: IFFALSE 10330
// americanDestroyed := true ;
10322: LD_ADDR_EXP 4
10326: PUSH
10327: LD_INT 1
10329: ST_TO_ADDR
// if un = Platonov then
10330: LD_VAR 0 1
10334: PUSH
10335: LD_EXP 51
10339: EQUAL
10340: IFFALSE 10350
// russianDestroyed := true ;
10342: LD_ADDR_EXP 2
10346: PUSH
10347: LD_INT 1
10349: ST_TO_ADDR
// MCE_UnitDestroyed ( un ) ;
10350: LD_VAR 0 1
10354: PPUSH
10355: CALL 47047 0 1
// end ;
10359: PPOPN 1
10361: END
// on BuildingStarted ( building , builder ) do begin MCE_BuildingStarted ( building , builder ) ;
10362: LD_VAR 0 1
10366: PPUSH
10367: LD_VAR 0 2
10371: PPUSH
10372: CALL 49247 0 2
// end ;
10376: PPOPN 2
10378: END
// on UpgradeComplete ( building ) do begin MCE_UpgradeComplete ( building ) ;
10379: LD_VAR 0 1
10383: PPUSH
10384: CALL 48315 0 1
// end ;
10388: PPOPN 1
10390: END
// on BuildingComplete ( building ) do begin if building in FilterAllUnits ( [ [ f_side , 8 ] , [ f_btype , b_workshop ] , [ f_nation , 3 ] ] ) then
10391: LD_VAR 0 1
10395: PUSH
10396: LD_INT 22
10398: PUSH
10399: LD_INT 8
10401: PUSH
10402: EMPTY
10403: LIST
10404: LIST
10405: PUSH
10406: LD_INT 30
10408: PUSH
10409: LD_INT 2
10411: PUSH
10412: EMPTY
10413: LIST
10414: LIST
10415: PUSH
10416: LD_INT 23
10418: PUSH
10419: LD_INT 3
10421: PUSH
10422: EMPTY
10423: LIST
10424: LIST
10425: PUSH
10426: EMPTY
10427: LIST
10428: LIST
10429: LIST
10430: PPUSH
10431: CALL_OW 69
10435: IN
10436: IFFALSE 10463
// begin ComUpgrade ( building ) ;
10438: LD_VAR 0 1
10442: PPUSH
10443: CALL_OW 146
// ComComplete ( Kozlov , building ) ;
10447: LD_EXP 50
10451: PPUSH
10452: LD_VAR 0 1
10456: PPUSH
10457: CALL 59804 0 2
// exit ;
10461: GO 10472
// end ; MCE_BuildingComplete ( building ) ;
10463: LD_VAR 0 1
10467: PPUSH
10468: CALL 48556 0 1
// end ;
10472: PPOPN 1
10474: END
// on ResearchComplete ( tech , lab ) do begin MCE_ResearchComplete ( tech , lab ) ;
10475: LD_VAR 0 1
10479: PPUSH
10480: LD_VAR 0 2
10484: PPUSH
10485: CALL 46743 0 2
// end ;
10489: PPOPN 2
10491: END
// on CrateSpawn ( id , x , y , amount , mode ) do begin MCE_CrateSpawn ( id , x , y , amount , mode ) ;
10492: LD_VAR 0 1
10496: PPUSH
10497: LD_VAR 0 2
10501: PPUSH
10502: LD_VAR 0 3
10506: PPUSH
10507: LD_VAR 0 4
10511: PPUSH
10512: LD_VAR 0 5
10516: PPUSH
10517: CALL 46363 0 5
// end ;
10521: PPOPN 5
10523: END
// on VehicleConstructed ( vehicle , factory ) do begin MCE_VehicleConstructed ( vehicle , factory ) ;
10524: LD_VAR 0 1
10528: PPUSH
10529: LD_VAR 0 2
10533: PPUSH
10534: CALL 45959 0 2
// end ;
10538: PPOPN 2
10540: END
// on VehicleCaptured ( new , old , side , capturing_unit ) do begin MCE_VehicleCaptured ( new , old , side , capturing_unit ) ;
10541: LD_VAR 0 1
10545: PPUSH
10546: LD_VAR 0 2
10550: PPUSH
10551: LD_VAR 0 3
10555: PPUSH
10556: LD_VAR 0 4
10560: PPUSH
10561: CALL 45797 0 4
// end ;
10565: PPOPN 4
10567: END
// on BuildingCaptured ( building , side , capturning_unit ) do begin MCE_BuildingCaptured ( building , side , capturning_unit ) ;
10568: LD_VAR 0 1
10572: PPUSH
10573: LD_VAR 0 2
10577: PPUSH
10578: LD_VAR 0 3
10582: PPUSH
10583: CALL 45572 0 3
// end ;
10587: PPOPN 3
10589: END
// on EnterBuilding ( building , unit ) do begin MCE_EnterBuilding ( building , unit ) ;
10590: LD_VAR 0 1
10594: PPUSH
10595: LD_VAR 0 2
10599: PPUSH
10600: CALL 45457 0 2
// end ;
10604: PPOPN 2
10606: END
// on LeaveBuilding ( building , unit ) do begin MCE_LeaveBuilding ( building , unit ) ;
10607: LD_VAR 0 1
10611: PPUSH
10612: LD_VAR 0 2
10616: PPUSH
10617: CALL 49508 0 2
// end ;
10621: PPOPN 2
10623: END
// on EvacuateVehicle ( driver , abandoned_vehicle , unknown1 , unknown2 ) do begin MCE_EvacuateVehicle ( driver , abandoned_vehicle , unknown1 , unknown2 ) ;
10624: LD_VAR 0 1
10628: PPUSH
10629: LD_VAR 0 2
10633: PPUSH
10634: LD_VAR 0 3
10638: PPUSH
10639: LD_VAR 0 4
10643: PPUSH
10644: CALL 49724 0 4
// end ;
10648: PPOPN 4
10650: END
// on ApemanTamed ( ape , sci ) do begin MCE_ApemanTamed ( ape , sci ) ;
10651: LD_VAR 0 1
10655: PPUSH
10656: LD_VAR 0 2
10660: PPUSH
10661: CALL 45266 0 2
// end ;
10665: PPOPN 2
10667: END
// on Command ( cmd ) do begin SOS_Command ( cmd ) ;
10668: LD_VAR 0 1
10672: PPUSH
10673: CALL 92976 0 1
// end ; end_of_file
10677: PPOPN 1
10679: END
// export function Action ; begin
10680: LD_INT 0
10682: PPUSH
// InGameOn ;
10683: CALL_OW 8
// CenterNowOnXY ( 206 , 11 ) ;
10687: LD_INT 206
10689: PPUSH
10690: LD_INT 11
10692: PPUSH
10693: CALL_OW 86
// wait ( 0 0$1 ) ;
10697: LD_INT 35
10699: PPUSH
10700: CALL_OW 67
// Say ( JMM , DStart-JMM-JMM-1 ) ;
10704: LD_EXP 12
10708: PPUSH
10709: LD_STRING DStart-JMM-JMM-1
10711: PPUSH
10712: CALL_OW 88
// Say ( Burlak , DStart-JMM-Bur-1 ) ;
10716: LD_EXP 44
10720: PPUSH
10721: LD_STRING DStart-JMM-Bur-1
10723: PPUSH
10724: CALL_OW 88
// Say ( JMM , DStart-JMM-JMM-2 ) ;
10728: LD_EXP 12
10732: PPUSH
10733: LD_STRING DStart-JMM-JMM-2
10735: PPUSH
10736: CALL_OW 88
// Say ( Burlak , DStart-JMM-Bur-2 ) ;
10740: LD_EXP 44
10744: PPUSH
10745: LD_STRING DStart-JMM-Bur-2
10747: PPUSH
10748: CALL_OW 88
// InGameOff ;
10752: CALL_OW 9
// ChangeMissionObjectives ( MStart ) ;
10756: LD_STRING MStart
10758: PPUSH
10759: CALL_OW 337
// end ;
10763: LD_VAR 0 1
10767: RET
// every 0 0$2 trigger SeeXY ( 7 , 255 , 219 ) do var speaker ;
10768: LD_INT 7
10770: PPUSH
10771: LD_INT 255
10773: PPUSH
10774: LD_INT 219
10776: PPUSH
10777: CALL_OW 293
10781: IFFALSE 11390
10783: GO 10785
10785: DISABLE
10786: LD_INT 0
10788: PPUSH
// begin wait ( 0 0$3 ) ;
10789: LD_INT 105
10791: PPUSH
10792: CALL_OW 67
// alienSpotted := true ;
10796: LD_ADDR_EXP 7
10800: PUSH
10801: LD_INT 1
10803: ST_TO_ADDR
// speaker := FilterAllUnits ( [ [ f_side , 7 ] , [ f_nation , 3 ] , [ f_type , unit_human ] , [ f_sex , sex_male ] ] ) diff [ Burlak , Titov , Dolgov , Petrosyan , Kuzmov , Kovalyuk , Scholtze ] ;
10804: LD_ADDR_VAR 0 1
10808: PUSH
10809: LD_INT 22
10811: PUSH
10812: LD_INT 7
10814: PUSH
10815: EMPTY
10816: LIST
10817: LIST
10818: PUSH
10819: LD_INT 23
10821: PUSH
10822: LD_INT 3
10824: PUSH
10825: EMPTY
10826: LIST
10827: LIST
10828: PUSH
10829: LD_INT 21
10831: PUSH
10832: LD_INT 1
10834: PUSH
10835: EMPTY
10836: LIST
10837: LIST
10838: PUSH
10839: LD_INT 26
10841: PUSH
10842: LD_INT 1
10844: PUSH
10845: EMPTY
10846: LIST
10847: LIST
10848: PUSH
10849: EMPTY
10850: LIST
10851: LIST
10852: LIST
10853: LIST
10854: PPUSH
10855: CALL_OW 69
10859: PUSH
10860: LD_EXP 44
10864: PUSH
10865: LD_EXP 32
10869: PUSH
10870: LD_EXP 34
10874: PUSH
10875: LD_EXP 35
10879: PUSH
10880: LD_EXP 42
10884: PUSH
10885: LD_EXP 41
10889: PUSH
10890: LD_EXP 36
10894: PUSH
10895: EMPTY
10896: LIST
10897: LIST
10898: LIST
10899: LIST
10900: LIST
10901: LIST
10902: LIST
10903: DIFF
10904: ST_TO_ADDR
// DialogueOn ;
10905: CALL_OW 6
// PlaceSeeing ( 255 , 219 , 7 , - 20 ) ;
10909: LD_INT 255
10911: PPUSH
10912: LD_INT 219
10914: PPUSH
10915: LD_INT 7
10917: PPUSH
10918: LD_INT 20
10920: NEG
10921: PPUSH
10922: CALL_OW 330
// CenterNowOnXY ( 255 , 219 ) ;
10926: LD_INT 255
10928: PPUSH
10929: LD_INT 219
10931: PPUSH
10932: CALL_OW 86
// if speaker then
10936: LD_VAR 0 1
10940: IFFALSE 10958
// Say ( speaker [ 1 ] , DAlienBase-RSol1-1 ) ;
10942: LD_VAR 0 1
10946: PUSH
10947: LD_INT 1
10949: ARRAY
10950: PPUSH
10951: LD_STRING DAlienBase-RSol1-1
10953: PPUSH
10954: CALL_OW 88
// Say ( JMM , DAlienBase-JMM-1 ) ;
10958: LD_EXP 12
10962: PPUSH
10963: LD_STRING DAlienBase-JMM-1
10965: PPUSH
10966: CALL_OW 88
// if IsOk ( Burlak ) then
10970: LD_EXP 44
10974: PPUSH
10975: CALL_OW 302
10979: IFFALSE 11000
// begin dwait ( 0 0$1 ) ;
10981: LD_INT 35
10983: PPUSH
10984: CALL_OW 68
// Say ( Burlak , DAlienBase-Bur-1 ) ;
10988: LD_EXP 44
10992: PPUSH
10993: LD_STRING DAlienBase-Bur-1
10995: PPUSH
10996: CALL_OW 88
// end ; if IsOk ( Roth ) then
11000: LD_EXP 13
11004: PPUSH
11005: CALL_OW 302
11009: IFFALSE 11023
// Say ( Roth , DAlienBase-Roth-1 ) ;
11011: LD_EXP 13
11015: PPUSH
11016: LD_STRING DAlienBase-Roth-1
11018: PPUSH
11019: CALL_OW 88
// if IsOk ( Gossudarov ) then
11023: LD_EXP 30
11027: PPUSH
11028: CALL_OW 302
11032: IFFALSE 11048
// Say ( Gossudarov , DAlienBase-Gos-1 ) else
11034: LD_EXP 30
11038: PPUSH
11039: LD_STRING DAlienBase-Gos-1
11041: PPUSH
11042: CALL_OW 88
11046: GO 11165
// begin speaker := FilterAllUnits ( [ [ f_side , 7 ] , [ f_class , 4 ] , [ f_type , unit_human ] , [ f_sex , sex_male ] ] ) diff [ Roth , JMM , Burlak , Titov , Kuzmov , Kovalyuk ] ;
11048: LD_ADDR_VAR 0 1
11052: PUSH
11053: LD_INT 22
11055: PUSH
11056: LD_INT 7
11058: PUSH
11059: EMPTY
11060: LIST
11061: LIST
11062: PUSH
11063: LD_INT 25
11065: PUSH
11066: LD_INT 4
11068: PUSH
11069: EMPTY
11070: LIST
11071: LIST
11072: PUSH
11073: LD_INT 21
11075: PUSH
11076: LD_INT 1
11078: PUSH
11079: EMPTY
11080: LIST
11081: LIST
11082: PUSH
11083: LD_INT 26
11085: PUSH
11086: LD_INT 1
11088: PUSH
11089: EMPTY
11090: LIST
11091: LIST
11092: PUSH
11093: EMPTY
11094: LIST
11095: LIST
11096: LIST
11097: LIST
11098: PPUSH
11099: CALL_OW 69
11103: PUSH
11104: LD_EXP 13
11108: PUSH
11109: LD_EXP 12
11113: PUSH
11114: LD_EXP 44
11118: PUSH
11119: LD_EXP 32
11123: PUSH
11124: LD_EXP 42
11128: PUSH
11129: LD_EXP 41
11133: PUSH
11134: EMPTY
11135: LIST
11136: LIST
11137: LIST
11138: LIST
11139: LIST
11140: LIST
11141: DIFF
11142: ST_TO_ADDR
// if speaker then
11143: LD_VAR 0 1
11147: IFFALSE 11165
// Say ( speaker [ 1 ] , DAlienBase-Sci1-1 ) ;
11149: LD_VAR 0 1
11153: PUSH
11154: LD_INT 1
11156: ARRAY
11157: PPUSH
11158: LD_STRING DAlienBase-Sci1-1
11160: PPUSH
11161: CALL_OW 88
// end ; RemoveSeeing ( 255 , 219 , 7 ) ;
11165: LD_INT 255
11167: PPUSH
11168: LD_INT 219
11170: PPUSH
11171: LD_INT 7
11173: PPUSH
11174: CALL_OW 331
// DialogueOff ;
11178: CALL_OW 7
// repeat wait ( 0 0$1 ) ;
11182: LD_INT 35
11184: PPUSH
11185: CALL_OW 67
// until IsSelected ( alien ) ;
11189: LD_INT 1
11191: PPUSH
11192: CALL_OW 306
11196: IFFALSE 11182
// if not artifactIResearched or not artifactIIResearched then
11198: LD_EXP 9
11202: NOT
11203: PUSH
11204: LD_EXP 10
11208: NOT
11209: OR
11210: IFFALSE 11390
// begin if IsOk ( Roth ) then
11212: LD_EXP 13
11216: PPUSH
11217: CALL_OW 302
11221: IFFALSE 11237
// Say ( Roth , DAlieBaseNotReady-Roth-1 ) else
11223: LD_EXP 13
11227: PPUSH
11228: LD_STRING DAlieBaseNotReady-Roth-1
11230: PPUSH
11231: CALL_OW 88
11235: GO 11390
// if IsOk ( Gossudarov ) then
11237: LD_EXP 30
11241: PPUSH
11242: CALL_OW 302
11246: IFFALSE 11262
// Say ( Gossudarov , DAlieBaseNotReady-Gos-1 ) else
11248: LD_EXP 30
11252: PPUSH
11253: LD_STRING DAlieBaseNotReady-Gos-1
11255: PPUSH
11256: CALL_OW 88
11260: GO 11390
// begin speaker := FilterAllUnits ( [ [ f_side , 7 ] , [ f_nation , 3 ] , [ f_class , 4 ] , [ f_type , unit_human ] , [ f_sex , sex_male ] ] ) diff [ Roth , JMM , Burlak , Titov , Kuzmov , Kovalyuk ] ;
11262: LD_ADDR_VAR 0 1
11266: PUSH
11267: LD_INT 22
11269: PUSH
11270: LD_INT 7
11272: PUSH
11273: EMPTY
11274: LIST
11275: LIST
11276: PUSH
11277: LD_INT 23
11279: PUSH
11280: LD_INT 3
11282: PUSH
11283: EMPTY
11284: LIST
11285: LIST
11286: PUSH
11287: LD_INT 25
11289: PUSH
11290: LD_INT 4
11292: PUSH
11293: EMPTY
11294: LIST
11295: LIST
11296: PUSH
11297: LD_INT 21
11299: PUSH
11300: LD_INT 1
11302: PUSH
11303: EMPTY
11304: LIST
11305: LIST
11306: PUSH
11307: LD_INT 26
11309: PUSH
11310: LD_INT 1
11312: PUSH
11313: EMPTY
11314: LIST
11315: LIST
11316: PUSH
11317: EMPTY
11318: LIST
11319: LIST
11320: LIST
11321: LIST
11322: LIST
11323: PPUSH
11324: CALL_OW 69
11328: PUSH
11329: LD_EXP 13
11333: PUSH
11334: LD_EXP 12
11338: PUSH
11339: LD_EXP 44
11343: PUSH
11344: LD_EXP 32
11348: PUSH
11349: LD_EXP 42
11353: PUSH
11354: LD_EXP 41
11358: PUSH
11359: EMPTY
11360: LIST
11361: LIST
11362: LIST
11363: LIST
11364: LIST
11365: LIST
11366: DIFF
11367: ST_TO_ADDR
// if speaker then
11368: LD_VAR 0 1
11372: IFFALSE 11390
// Say ( speaker [ 1 ] , DAlieBaseNotReady-RSci1-1 ) ;
11374: LD_VAR 0 1
11378: PUSH
11379: LD_INT 1
11381: ARRAY
11382: PPUSH
11383: LD_STRING DAlieBaseNotReady-RSci1-1
11385: PPUSH
11386: CALL_OW 88
// end ; end ; end ;
11390: PPOPN 1
11392: END
// every 0 0$1 trigger GetTech ( tech_Artifact , 7 ) = state_researched do var speaker ;
11393: LD_INT 24
11395: PPUSH
11396: LD_INT 7
11398: PPUSH
11399: CALL_OW 321
11403: PUSH
11404: LD_INT 2
11406: EQUAL
11407: IFFALSE 12098
11409: GO 11411
11411: DISABLE
11412: LD_INT 0
11414: PPUSH
// begin speaker := FilterAllUnits ( [ [ f_side , 7 ] , [ f_nation , 3 ] , [ f_class , 4 ] , [ f_type , unit_human ] , [ f_sex , sex_male ] ] ) diff [ Roth , JMM , Burlak , Titov , Kuzmov , Kovalyuk ] ;
11415: LD_ADDR_VAR 0 1
11419: PUSH
11420: LD_INT 22
11422: PUSH
11423: LD_INT 7
11425: PUSH
11426: EMPTY
11427: LIST
11428: LIST
11429: PUSH
11430: LD_INT 23
11432: PUSH
11433: LD_INT 3
11435: PUSH
11436: EMPTY
11437: LIST
11438: LIST
11439: PUSH
11440: LD_INT 25
11442: PUSH
11443: LD_INT 4
11445: PUSH
11446: EMPTY
11447: LIST
11448: LIST
11449: PUSH
11450: LD_INT 21
11452: PUSH
11453: LD_INT 1
11455: PUSH
11456: EMPTY
11457: LIST
11458: LIST
11459: PUSH
11460: LD_INT 26
11462: PUSH
11463: LD_INT 1
11465: PUSH
11466: EMPTY
11467: LIST
11468: LIST
11469: PUSH
11470: EMPTY
11471: LIST
11472: LIST
11473: LIST
11474: LIST
11475: LIST
11476: PPUSH
11477: CALL_OW 69
11481: PUSH
11482: LD_EXP 13
11486: PUSH
11487: LD_EXP 12
11491: PUSH
11492: LD_EXP 44
11496: PUSH
11497: LD_EXP 32
11501: PUSH
11502: LD_EXP 42
11506: PUSH
11507: LD_EXP 41
11511: PUSH
11512: EMPTY
11513: LIST
11514: LIST
11515: LIST
11516: LIST
11517: LIST
11518: LIST
11519: DIFF
11520: ST_TO_ADDR
// if not speaker then
11521: LD_VAR 0 1
11525: NOT
11526: IFFALSE 11530
// exit ;
11528: GO 12098
// DialogueOn ;
11530: CALL_OW 6
// Say ( speaker [ 1 ] , DArtefTechnology-RSci1-1 ) ;
11534: LD_VAR 0 1
11538: PUSH
11539: LD_INT 1
11541: ARRAY
11542: PPUSH
11543: LD_STRING DArtefTechnology-RSci1-1
11545: PPUSH
11546: CALL_OW 88
// if IsOk ( Burlak ) then
11550: LD_EXP 44
11554: PPUSH
11555: CALL_OW 302
11559: IFFALSE 11573
// Say ( Burlak , DArtefTechnology-Bur-1 ) ;
11561: LD_EXP 44
11565: PPUSH
11566: LD_STRING DArtefTechnology-Bur-1
11568: PPUSH
11569: CALL_OW 88
// Say ( speaker [ 1 ] , DArtefTechnology-RSci1-2 ) ;
11573: LD_VAR 0 1
11577: PUSH
11578: LD_INT 1
11580: ARRAY
11581: PPUSH
11582: LD_STRING DArtefTechnology-RSci1-2
11584: PPUSH
11585: CALL_OW 88
// if Denis then
11589: LD_EXP 18
11593: IFFALSE 11610
// speaker := [ Denis ] else
11595: LD_ADDR_VAR 0 1
11599: PUSH
11600: LD_EXP 18
11604: PUSH
11605: EMPTY
11606: LIST
11607: ST_TO_ADDR
11608: GO 11716
// speaker := FilterAllUnits ( [ [ f_side , 7 ] , [ f_nation , 1 ] , [ f_class , 4 ] , [ f_type , unit_human ] , [ f_sex , sex_male ] ] ) diff [ Roth , JMM , Burlak , Titov , Kuzmov , Kovalyuk ] ;
11610: LD_ADDR_VAR 0 1
11614: PUSH
11615: LD_INT 22
11617: PUSH
11618: LD_INT 7
11620: PUSH
11621: EMPTY
11622: LIST
11623: LIST
11624: PUSH
11625: LD_INT 23
11627: PUSH
11628: LD_INT 1
11630: PUSH
11631: EMPTY
11632: LIST
11633: LIST
11634: PUSH
11635: LD_INT 25
11637: PUSH
11638: LD_INT 4
11640: PUSH
11641: EMPTY
11642: LIST
11643: LIST
11644: PUSH
11645: LD_INT 21
11647: PUSH
11648: LD_INT 1
11650: PUSH
11651: EMPTY
11652: LIST
11653: LIST
11654: PUSH
11655: LD_INT 26
11657: PUSH
11658: LD_INT 1
11660: PUSH
11661: EMPTY
11662: LIST
11663: LIST
11664: PUSH
11665: EMPTY
11666: LIST
11667: LIST
11668: LIST
11669: LIST
11670: LIST
11671: PPUSH
11672: CALL_OW 69
11676: PUSH
11677: LD_EXP 13
11681: PUSH
11682: LD_EXP 12
11686: PUSH
11687: LD_EXP 44
11691: PUSH
11692: LD_EXP 32
11696: PUSH
11697: LD_EXP 42
11701: PUSH
11702: LD_EXP 41
11706: PUSH
11707: EMPTY
11708: LIST
11709: LIST
11710: LIST
11711: LIST
11712: LIST
11713: LIST
11714: DIFF
11715: ST_TO_ADDR
// if speaker then
11716: LD_VAR 0 1
11720: IFFALSE 11738
// Say ( speaker [ 1 ] , DArtefTechnology-Sci1-2 ) ;
11722: LD_VAR 0 1
11726: PUSH
11727: LD_INT 1
11729: ARRAY
11730: PPUSH
11731: LD_STRING DArtefTechnology-Sci1-2
11733: PPUSH
11734: CALL_OW 88
// speaker := FilterAllUnits ( [ [ f_side , 7 ] , [ f_nation , 3 ] , [ f_class , 4 ] , [ f_type , unit_human ] , [ f_sex , sex_male ] ] ) diff [ Roth , JMM , Burlak , Titov , Kuzmov , Kovalyuk ] ;
11738: LD_ADDR_VAR 0 1
11742: PUSH
11743: LD_INT 22
11745: PUSH
11746: LD_INT 7
11748: PUSH
11749: EMPTY
11750: LIST
11751: LIST
11752: PUSH
11753: LD_INT 23
11755: PUSH
11756: LD_INT 3
11758: PUSH
11759: EMPTY
11760: LIST
11761: LIST
11762: PUSH
11763: LD_INT 25
11765: PUSH
11766: LD_INT 4
11768: PUSH
11769: EMPTY
11770: LIST
11771: LIST
11772: PUSH
11773: LD_INT 21
11775: PUSH
11776: LD_INT 1
11778: PUSH
11779: EMPTY
11780: LIST
11781: LIST
11782: PUSH
11783: LD_INT 26
11785: PUSH
11786: LD_INT 1
11788: PUSH
11789: EMPTY
11790: LIST
11791: LIST
11792: PUSH
11793: EMPTY
11794: LIST
11795: LIST
11796: LIST
11797: LIST
11798: LIST
11799: PPUSH
11800: CALL_OW 69
11804: PUSH
11805: LD_EXP 13
11809: PUSH
11810: LD_EXP 12
11814: PUSH
11815: LD_EXP 44
11819: PUSH
11820: LD_EXP 32
11824: PUSH
11825: LD_EXP 42
11829: PUSH
11830: LD_EXP 41
11834: PUSH
11835: EMPTY
11836: LIST
11837: LIST
11838: LIST
11839: LIST
11840: LIST
11841: LIST
11842: DIFF
11843: ST_TO_ADDR
// if speaker and ( artifactArCaptured or arabianDestroyed ) then
11844: LD_VAR 0 1
11848: PUSH
11849: LD_EXP 6
11853: PUSH
11854: LD_EXP 5
11858: OR
11859: AND
11860: IFFALSE 12094
// begin if arabianDestroyed and IsOk ( Burlak ) then
11862: LD_EXP 5
11866: PUSH
11867: LD_EXP 44
11871: PPUSH
11872: CALL_OW 302
11876: AND
11877: IFFALSE 11893
// Say ( Burlak , DArtefTechnology-Bur-2 ) else
11879: LD_EXP 44
11883: PPUSH
11884: LD_STRING DArtefTechnology-Bur-2
11886: PPUSH
11887: CALL_OW 88
11891: GO 11905
// Say ( JMM , DArtefTechnology-JMM-2 ) ;
11893: LD_EXP 12
11897: PPUSH
11898: LD_STRING DArtefTechnology-JMM-2
11900: PPUSH
11901: CALL_OW 88
// Say ( speaker [ 1 ] , DArtefTechnology-RSci1-3 ) ;
11905: LD_VAR 0 1
11909: PUSH
11910: LD_INT 1
11912: ARRAY
11913: PPUSH
11914: LD_STRING DArtefTechnology-RSci1-3
11916: PPUSH
11917: CALL_OW 88
// if Denis then
11921: LD_EXP 18
11925: IFFALSE 11942
// speaker := [ Denis ] else
11927: LD_ADDR_VAR 0 1
11931: PUSH
11932: LD_EXP 18
11936: PUSH
11937: EMPTY
11938: LIST
11939: ST_TO_ADDR
11940: GO 12048
// speaker := FilterAllUnits ( [ [ f_side , 7 ] , [ f_nation , 1 ] , [ f_class , 4 ] , [ f_type , unit_human ] , [ f_sex , sex_male ] ] ) diff [ Roth , JMM , Burlak , Titov , Kuzmov , Kovalyuk ] ;
11942: LD_ADDR_VAR 0 1
11946: PUSH
11947: LD_INT 22
11949: PUSH
11950: LD_INT 7
11952: PUSH
11953: EMPTY
11954: LIST
11955: LIST
11956: PUSH
11957: LD_INT 23
11959: PUSH
11960: LD_INT 1
11962: PUSH
11963: EMPTY
11964: LIST
11965: LIST
11966: PUSH
11967: LD_INT 25
11969: PUSH
11970: LD_INT 4
11972: PUSH
11973: EMPTY
11974: LIST
11975: LIST
11976: PUSH
11977: LD_INT 21
11979: PUSH
11980: LD_INT 1
11982: PUSH
11983: EMPTY
11984: LIST
11985: LIST
11986: PUSH
11987: LD_INT 26
11989: PUSH
11990: LD_INT 1
11992: PUSH
11993: EMPTY
11994: LIST
11995: LIST
11996: PUSH
11997: EMPTY
11998: LIST
11999: LIST
12000: LIST
12001: LIST
12002: LIST
12003: PPUSH
12004: CALL_OW 69
12008: PUSH
12009: LD_EXP 13
12013: PUSH
12014: LD_EXP 12
12018: PUSH
12019: LD_EXP 44
12023: PUSH
12024: LD_EXP 32
12028: PUSH
12029: LD_EXP 42
12033: PUSH
12034: LD_EXP 41
12038: PUSH
12039: EMPTY
12040: LIST
12041: LIST
12042: LIST
12043: LIST
12044: LIST
12045: LIST
12046: DIFF
12047: ST_TO_ADDR
// if speaker then
12048: LD_VAR 0 1
12052: IFFALSE 12094
// if alienSpotted then
12054: LD_EXP 7
12058: IFFALSE 12078
// Say ( speaker [ 1 ] , DArtefTechnology-Sci1-3 ) else
12060: LD_VAR 0 1
12064: PUSH
12065: LD_INT 1
12067: ARRAY
12068: PPUSH
12069: LD_STRING DArtefTechnology-Sci1-3
12071: PPUSH
12072: CALL_OW 88
12076: GO 12094
// Say ( speaker [ 1 ] , DArtefTechnology-Sci1-3a ) ;
12078: LD_VAR 0 1
12082: PUSH
12083: LD_INT 1
12085: ARRAY
12086: PPUSH
12087: LD_STRING DArtefTechnology-Sci1-3a
12089: PPUSH
12090: CALL_OW 88
// end ; DialogueOff ;
12094: CALL_OW 7
// end ;
12098: PPOPN 1
12100: END
// every 0 0$1 trigger artifactIResearched do var speaker ;
12101: LD_EXP 9
12105: IFFALSE 12300
12107: GO 12109
12109: DISABLE
12110: LD_INT 0
12112: PPUSH
// begin if Denis then
12113: LD_EXP 18
12117: IFFALSE 12134
// speaker := [ Denis ] else
12119: LD_ADDR_VAR 0 1
12123: PUSH
12124: LD_EXP 18
12128: PUSH
12129: EMPTY
12130: LIST
12131: ST_TO_ADDR
12132: GO 12240
// speaker := FilterAllUnits ( [ [ f_side , 7 ] , [ f_nation , 1 ] , [ f_class , 4 ] , [ f_type , unit_human ] , [ f_sex , sex_male ] ] ) diff [ Roth , JMM , Burlak , Titov , Kuzmov , Kovalyuk ] ;
12134: LD_ADDR_VAR 0 1
12138: PUSH
12139: LD_INT 22
12141: PUSH
12142: LD_INT 7
12144: PUSH
12145: EMPTY
12146: LIST
12147: LIST
12148: PUSH
12149: LD_INT 23
12151: PUSH
12152: LD_INT 1
12154: PUSH
12155: EMPTY
12156: LIST
12157: LIST
12158: PUSH
12159: LD_INT 25
12161: PUSH
12162: LD_INT 4
12164: PUSH
12165: EMPTY
12166: LIST
12167: LIST
12168: PUSH
12169: LD_INT 21
12171: PUSH
12172: LD_INT 1
12174: PUSH
12175: EMPTY
12176: LIST
12177: LIST
12178: PUSH
12179: LD_INT 26
12181: PUSH
12182: LD_INT 1
12184: PUSH
12185: EMPTY
12186: LIST
12187: LIST
12188: PUSH
12189: EMPTY
12190: LIST
12191: LIST
12192: LIST
12193: LIST
12194: LIST
12195: PPUSH
12196: CALL_OW 69
12200: PUSH
12201: LD_EXP 13
12205: PUSH
12206: LD_EXP 12
12210: PUSH
12211: LD_EXP 44
12215: PUSH
12216: LD_EXP 32
12220: PUSH
12221: LD_EXP 42
12225: PUSH
12226: LD_EXP 41
12230: PUSH
12231: EMPTY
12232: LIST
12233: LIST
12234: LIST
12235: LIST
12236: LIST
12237: LIST
12238: DIFF
12239: ST_TO_ADDR
// if not speaker then
12240: LD_VAR 0 1
12244: NOT
12245: IFFALSE 12249
// exit ;
12247: GO 12300
// Say ( speaker [ 1 ] , DArtefTechnologyAm-Sci1-1 ) ;
12249: LD_VAR 0 1
12253: PUSH
12254: LD_INT 1
12256: ARRAY
12257: PPUSH
12258: LD_STRING DArtefTechnologyAm-Sci1-1
12260: PPUSH
12261: CALL_OW 88
// if IsOk ( Burlak ) then
12265: LD_EXP 44
12269: PPUSH
12270: CALL_OW 302
12274: IFFALSE 12288
// Say ( Burlak , DArtefTechnologyAm-Bur-1 ) ;
12276: LD_EXP 44
12280: PPUSH
12281: LD_STRING DArtefTechnologyAm-Bur-1
12283: PPUSH
12284: CALL_OW 88
// Say ( JMM , DArtefTechnologyAm-JMM-1 ) ;
12288: LD_EXP 12
12292: PPUSH
12293: LD_STRING DArtefTechnologyAm-JMM-1
12295: PPUSH
12296: CALL_OW 88
// end ;
12300: PPOPN 1
12302: END
// every 0 0$1 trigger artifactIIResearched do var speaker ;
12303: LD_EXP 10
12307: IFFALSE 12518
12309: GO 12311
12311: DISABLE
12312: LD_INT 0
12314: PPUSH
// begin if Denis then
12315: LD_EXP 18
12319: IFFALSE 12336
// speaker := [ Denis ] else
12321: LD_ADDR_VAR 0 1
12325: PUSH
12326: LD_EXP 18
12330: PUSH
12331: EMPTY
12332: LIST
12333: ST_TO_ADDR
12334: GO 12442
// speaker := FilterAllUnits ( [ [ f_side , 7 ] , [ f_nation , 3 ] , [ f_class , 4 ] , [ f_type , unit_human ] , [ f_sex , sex_male ] ] ) diff [ Roth , JMM , Burlak , Titov , Kuzmov , Kovalyuk ] ;
12336: LD_ADDR_VAR 0 1
12340: PUSH
12341: LD_INT 22
12343: PUSH
12344: LD_INT 7
12346: PUSH
12347: EMPTY
12348: LIST
12349: LIST
12350: PUSH
12351: LD_INT 23
12353: PUSH
12354: LD_INT 3
12356: PUSH
12357: EMPTY
12358: LIST
12359: LIST
12360: PUSH
12361: LD_INT 25
12363: PUSH
12364: LD_INT 4
12366: PUSH
12367: EMPTY
12368: LIST
12369: LIST
12370: PUSH
12371: LD_INT 21
12373: PUSH
12374: LD_INT 1
12376: PUSH
12377: EMPTY
12378: LIST
12379: LIST
12380: PUSH
12381: LD_INT 26
12383: PUSH
12384: LD_INT 1
12386: PUSH
12387: EMPTY
12388: LIST
12389: LIST
12390: PUSH
12391: EMPTY
12392: LIST
12393: LIST
12394: LIST
12395: LIST
12396: LIST
12397: PPUSH
12398: CALL_OW 69
12402: PUSH
12403: LD_EXP 13
12407: PUSH
12408: LD_EXP 12
12412: PUSH
12413: LD_EXP 44
12417: PUSH
12418: LD_EXP 32
12422: PUSH
12423: LD_EXP 42
12427: PUSH
12428: LD_EXP 41
12432: PUSH
12433: EMPTY
12434: LIST
12435: LIST
12436: LIST
12437: LIST
12438: LIST
12439: LIST
12440: DIFF
12441: ST_TO_ADDR
// if not speaker then
12442: LD_VAR 0 1
12446: NOT
12447: IFFALSE 12451
// exit ;
12449: GO 12518
// Say ( speaker [ 1 ] , DArtefTechnologyRu-RSci1-1 ) ;
12451: LD_VAR 0 1
12455: PUSH
12456: LD_INT 1
12458: ARRAY
12459: PPUSH
12460: LD_STRING DArtefTechnologyRu-RSci1-1
12462: PPUSH
12463: CALL_OW 88
// if IsOk ( Burlak ) then
12467: LD_EXP 44
12471: PPUSH
12472: CALL_OW 302
12476: IFFALSE 12490
// Say ( Burlak , DArtefTechnologyRu-Bur-1 ) ;
12478: LD_EXP 44
12482: PPUSH
12483: LD_STRING DArtefTechnologyRu-Bur-1
12485: PPUSH
12486: CALL_OW 88
// Say ( speaker [ 1 ] , DArtefTechnologyRu-RSci1-2 ) ;
12490: LD_VAR 0 1
12494: PUSH
12495: LD_INT 1
12497: ARRAY
12498: PPUSH
12499: LD_STRING DArtefTechnologyRu-RSci1-2
12501: PPUSH
12502: CALL_OW 88
// Say ( JMM , DArtefTechnologyRu-JMM-1 ) ;
12506: LD_EXP 12
12510: PPUSH
12511: LD_STRING DArtefTechnologyRu-JMM-1
12513: PPUSH
12514: CALL_OW 88
// end ;
12518: PPOPN 1
12520: END
// every 0 0$1 trigger GetTech ( tech_Artifact , 7 ) = state_researched and GetSide ( alien ) = 7 do var speaker ;
12521: LD_INT 24
12523: PPUSH
12524: LD_INT 7
12526: PPUSH
12527: CALL_OW 321
12531: PUSH
12532: LD_INT 2
12534: EQUAL
12535: PUSH
12536: LD_INT 1
12538: PPUSH
12539: CALL_OW 255
12543: PUSH
12544: LD_INT 7
12546: EQUAL
12547: AND
12548: IFFALSE 12708
12550: GO 12552
12552: DISABLE
12553: LD_INT 0
12555: PPUSH
// begin if Denis then
12556: LD_EXP 18
12560: IFFALSE 12577
// speaker := [ Denis ] else
12562: LD_ADDR_VAR 0 1
12566: PUSH
12567: LD_EXP 18
12571: PUSH
12572: EMPTY
12573: LIST
12574: ST_TO_ADDR
12575: GO 12683
// speaker := FilterAllUnits ( [ [ f_side , 7 ] , [ f_nation , 1 ] , [ f_class , 4 ] , [ f_type , unit_human ] , [ f_sex , sex_male ] ] ) diff [ Roth , JMM , Burlak , Titov , Kuzmov , Kovalyuk ] ;
12577: LD_ADDR_VAR 0 1
12581: PUSH
12582: LD_INT 22
12584: PUSH
12585: LD_INT 7
12587: PUSH
12588: EMPTY
12589: LIST
12590: LIST
12591: PUSH
12592: LD_INT 23
12594: PUSH
12595: LD_INT 1
12597: PUSH
12598: EMPTY
12599: LIST
12600: LIST
12601: PUSH
12602: LD_INT 25
12604: PUSH
12605: LD_INT 4
12607: PUSH
12608: EMPTY
12609: LIST
12610: LIST
12611: PUSH
12612: LD_INT 21
12614: PUSH
12615: LD_INT 1
12617: PUSH
12618: EMPTY
12619: LIST
12620: LIST
12621: PUSH
12622: LD_INT 26
12624: PUSH
12625: LD_INT 1
12627: PUSH
12628: EMPTY
12629: LIST
12630: LIST
12631: PUSH
12632: EMPTY
12633: LIST
12634: LIST
12635: LIST
12636: LIST
12637: LIST
12638: PPUSH
12639: CALL_OW 69
12643: PUSH
12644: LD_EXP 13
12648: PUSH
12649: LD_EXP 12
12653: PUSH
12654: LD_EXP 44
12658: PUSH
12659: LD_EXP 32
12663: PUSH
12664: LD_EXP 42
12668: PUSH
12669: LD_EXP 41
12673: PUSH
12674: EMPTY
12675: LIST
12676: LIST
12677: LIST
12678: LIST
12679: LIST
12680: LIST
12681: DIFF
12682: ST_TO_ADDR
// if not speaker then
12683: LD_VAR 0 1
12687: NOT
12688: IFFALSE 12692
// exit ;
12690: GO 12708
// Say ( speaker [ 1 ] , DArtefTechnologyArStart-Sci1-1 ) ;
12692: LD_VAR 0 1
12696: PUSH
12697: LD_INT 1
12699: ARRAY
12700: PPUSH
12701: LD_STRING DArtefTechnologyArStart-Sci1-1
12703: PPUSH
12704: CALL_OW 88
// end ;
12708: PPOPN 1
12710: END
// every 0 0$1 trigger artifactIIIResearched do var speaker ;
12711: LD_EXP 11
12715: IFFALSE 12996
12717: GO 12719
12719: DISABLE
12720: LD_INT 0
12722: PPUSH
// begin speaker := FilterAllUnits ( [ [ f_side , 7 ] , [ f_nation , 3 ] , [ f_class , 4 ] , [ f_type , unit_human ] , [ f_sex , sex_male ] ] ) diff [ Roth , JMM , Burlak , Titov , Kuzmov , Kovalyuk ] ;
12723: LD_ADDR_VAR 0 1
12727: PUSH
12728: LD_INT 22
12730: PUSH
12731: LD_INT 7
12733: PUSH
12734: EMPTY
12735: LIST
12736: LIST
12737: PUSH
12738: LD_INT 23
12740: PUSH
12741: LD_INT 3
12743: PUSH
12744: EMPTY
12745: LIST
12746: LIST
12747: PUSH
12748: LD_INT 25
12750: PUSH
12751: LD_INT 4
12753: PUSH
12754: EMPTY
12755: LIST
12756: LIST
12757: PUSH
12758: LD_INT 21
12760: PUSH
12761: LD_INT 1
12763: PUSH
12764: EMPTY
12765: LIST
12766: LIST
12767: PUSH
12768: LD_INT 26
12770: PUSH
12771: LD_INT 1
12773: PUSH
12774: EMPTY
12775: LIST
12776: LIST
12777: PUSH
12778: EMPTY
12779: LIST
12780: LIST
12781: LIST
12782: LIST
12783: LIST
12784: PPUSH
12785: CALL_OW 69
12789: PUSH
12790: LD_EXP 13
12794: PUSH
12795: LD_EXP 12
12799: PUSH
12800: LD_EXP 44
12804: PUSH
12805: LD_EXP 32
12809: PUSH
12810: LD_EXP 42
12814: PUSH
12815: LD_EXP 41
12819: PUSH
12820: EMPTY
12821: LIST
12822: LIST
12823: LIST
12824: LIST
12825: LIST
12826: LIST
12827: DIFF
12828: ST_TO_ADDR
// if not speaker then
12829: LD_VAR 0 1
12833: NOT
12834: IFFALSE 12838
// exit ;
12836: GO 12996
// DialogueOn ;
12838: CALL_OW 6
// Say ( speaker [ 1 ] , DArtefTechnologyAr-RSci1-1 ) ;
12842: LD_VAR 0 1
12846: PUSH
12847: LD_INT 1
12849: ARRAY
12850: PPUSH
12851: LD_STRING DArtefTechnologyAr-RSci1-1
12853: PPUSH
12854: CALL_OW 88
// Say ( JMM , DArtefTechnologyAr-JMM-1 ) ;
12858: LD_EXP 12
12862: PPUSH
12863: LD_STRING DArtefTechnologyAr-JMM-1
12865: PPUSH
12866: CALL_OW 88
// Say ( speaker [ 1 ] , DArtefTechnologyAr-RSci1-2 ) ;
12870: LD_VAR 0 1
12874: PUSH
12875: LD_INT 1
12877: ARRAY
12878: PPUSH
12879: LD_STRING DArtefTechnologyAr-RSci1-2
12881: PPUSH
12882: CALL_OW 88
// Say ( JMM , DArtefTechnologyAr-JMM-2 ) ;
12886: LD_EXP 12
12890: PPUSH
12891: LD_STRING DArtefTechnologyAr-JMM-2
12893: PPUSH
12894: CALL_OW 88
// Say ( speaker [ 1 ] , DArtefTechnologyAr-RSci1-3 ) ;
12898: LD_VAR 0 1
12902: PUSH
12903: LD_INT 1
12905: ARRAY
12906: PPUSH
12907: LD_STRING DArtefTechnologyAr-RSci1-3
12909: PPUSH
12910: CALL_OW 88
// Say ( JMM , DArtefTechnologyAr-JMM-3 ) ;
12914: LD_EXP 12
12918: PPUSH
12919: LD_STRING DArtefTechnologyAr-JMM-3
12921: PPUSH
12922: CALL_OW 88
// Say ( speaker [ 1 ] , DArtefTechnologyAr-RSci1-4 ) ;
12926: LD_VAR 0 1
12930: PUSH
12931: LD_INT 1
12933: ARRAY
12934: PPUSH
12935: LD_STRING DArtefTechnologyAr-RSci1-4
12937: PPUSH
12938: CALL_OW 88
// if IsOk ( Burlak ) then
12942: LD_EXP 44
12946: PPUSH
12947: CALL_OW 302
12951: IFFALSE 12965
// Say ( Burlak , DArtefTechnologyAr-Bur-4 ) ;
12953: LD_EXP 44
12957: PPUSH
12958: LD_STRING DArtefTechnologyAr-Bur-4
12960: PPUSH
12961: CALL_OW 88
// Say ( JMM , DArtefTechnologyAr-JMM-4 ) ;
12965: LD_EXP 12
12969: PPUSH
12970: LD_STRING DArtefTechnologyAr-JMM-4
12972: PPUSH
12973: CALL_OW 88
// DialogueOff ;
12977: CALL_OW 7
// wait ( 0 0$45 ) ;
12981: LD_INT 1575
12983: PPUSH
12984: CALL_OW 67
// spawnOmar := true ;
12988: LD_ADDR_EXP 8
12992: PUSH
12993: LD_INT 1
12995: ST_TO_ADDR
// end ;
12996: PPOPN 1
12998: END
// every 0 0$1 trigger spawnOmar do
12999: LD_EXP 8
13003: IFFALSE 13301
13005: GO 13007
13007: DISABLE
// begin PrepareOmarAli ;
13008: CALL 6531 0 0
// if not Omar then
13012: LD_EXP 48
13016: NOT
13017: IFFALSE 13021
// exit ;
13019: GO 13301
// repeat wait ( 0 0$1 ) ;
13021: LD_INT 35
13023: PPUSH
13024: CALL_OW 67
// until See ( 7 , Omar ) ;
13028: LD_INT 7
13030: PPUSH
13031: LD_EXP 48
13035: PPUSH
13036: CALL_OW 292
13040: IFFALSE 13021
// CenterNowOnUnits ( Omar ) ;
13042: LD_EXP 48
13046: PPUSH
13047: CALL_OW 87
// DialogueOn ;
13051: CALL_OW 6
// Say ( Omar , DOmar-Omar-1 ) ;
13055: LD_EXP 48
13059: PPUSH
13060: LD_STRING DOmar-Omar-1
13062: PPUSH
13063: CALL_OW 88
// Say ( JMM , DOmar-JMM-1 ) ;
13067: LD_EXP 12
13071: PPUSH
13072: LD_STRING DOmar-JMM-1
13074: PPUSH
13075: CALL_OW 88
// Say ( Omar , DOmar-Omar-2 ) ;
13079: LD_EXP 48
13083: PPUSH
13084: LD_STRING DOmar-Omar-2
13086: PPUSH
13087: CALL_OW 88
// Say ( JMM , DOmar-JMM-2 ) ;
13091: LD_EXP 12
13095: PPUSH
13096: LD_STRING DOmar-JMM-2
13098: PPUSH
13099: CALL_OW 88
// Say ( Omar , DOmar-Omar-3 ) ;
13103: LD_EXP 48
13107: PPUSH
13108: LD_STRING DOmar-Omar-3
13110: PPUSH
13111: CALL_OW 88
// if IsOk ( Burlak ) then
13115: LD_EXP 44
13119: PPUSH
13120: CALL_OW 302
13124: IFFALSE 13140
// Say ( Burlak , DOmar-Bur-3 ) else
13126: LD_EXP 44
13130: PPUSH
13131: LD_STRING DOmar-Bur-3
13133: PPUSH
13134: CALL_OW 88
13138: GO 13152
// Say ( JMM , DOmar-JMM-3 ) ;
13140: LD_EXP 12
13144: PPUSH
13145: LD_STRING DOmar-JMM-3
13147: PPUSH
13148: CALL_OW 88
// Say ( Omar , DOmar-Omar-4 ) ;
13152: LD_EXP 48
13156: PPUSH
13157: LD_STRING DOmar-Omar-4
13159: PPUSH
13160: CALL_OW 88
// case Query ( QAccept ) of 1 :
13164: LD_STRING QAccept
13166: PPUSH
13167: CALL_OW 97
13171: PUSH
13172: LD_INT 1
13174: DOUBLE
13175: EQUAL
13176: IFTRUE 13180
13178: GO 13216
13180: POP
// begin Say ( JMM , DQrAccept#1-JMM-1 ) ;
13181: LD_EXP 12
13185: PPUSH
13186: LD_STRING DQrAccept#1-JMM-1
13188: PPUSH
13189: CALL_OW 88
// SetSide ( Omar , 7 ) ;
13193: LD_EXP 48
13197: PPUSH
13198: LD_INT 7
13200: PPUSH
13201: CALL_OW 235
// ComStop ( Omar ) ;
13205: LD_EXP 48
13209: PPUSH
13210: CALL_OW 141
// end ; 2 :
13214: GO 13265
13216: LD_INT 2
13218: DOUBLE
13219: EQUAL
13220: IFTRUE 13224
13222: GO 13264
13224: POP
// begin if IsOk ( Burlak ) then
13225: LD_EXP 44
13229: PPUSH
13230: CALL_OW 302
13234: IFFALSE 13250
// Say ( Burlak , DQrAccept#2-Bur-1 ) else
13236: LD_EXP 44
13240: PPUSH
13241: LD_STRING DQrAccept#2-Bur-1
13243: PPUSH
13244: CALL_OW 88
13248: GO 13262
// Say ( JMM , DQrAccept#2-JMM-1 ) ;
13250: LD_EXP 12
13254: PPUSH
13255: LD_STRING DQrAccept#2-JMM-1
13257: PPUSH
13258: CALL_OW 88
// end ; end ;
13262: GO 13265
13264: POP
// DialogueOff ;
13265: CALL_OW 7
// if GetSide ( Omar ) = 7 then
13269: LD_EXP 48
13273: PPUSH
13274: CALL_OW 255
13278: PUSH
13279: LD_INT 7
13281: EQUAL
13282: IFFALSE 13286
// exit ;
13284: GO 13301
// ComMoveXY ( Omar , 202 , 115 ) ;
13286: LD_EXP 48
13290: PPUSH
13291: LD_INT 202
13293: PPUSH
13294: LD_INT 115
13296: PPUSH
13297: CALL_OW 111
// end ;
13301: END
// every 0 0$1 trigger GetDistUnitXY ( Omar , 200 , 98 ) < 40 and russianDestroyed do
13302: LD_EXP 48
13306: PPUSH
13307: LD_INT 200
13309: PPUSH
13310: LD_INT 98
13312: PPUSH
13313: CALL_OW 297
13317: PUSH
13318: LD_INT 40
13320: LESS
13321: PUSH
13322: LD_EXP 2
13326: AND
13327: IFFALSE 13545
13329: GO 13331
13331: DISABLE
// begin SetSide ( Omar , 5 ) ;
13332: LD_EXP 48
13336: PPUSH
13337: LD_INT 5
13339: PPUSH
13340: CALL_OW 235
// if IsInUnit ( Omar ) then
13344: LD_EXP 48
13348: PPUSH
13349: CALL_OW 310
13353: IFFALSE 13364
// ComExitVehicle ( Omar ) ;
13355: LD_EXP 48
13359: PPUSH
13360: CALL_OW 121
// if IsInUnit ( Omar ) then
13364: LD_EXP 48
13368: PPUSH
13369: CALL_OW 310
13373: IFFALSE 13384
// ComExitBuilding ( Omar ) ;
13375: LD_EXP 48
13379: PPUSH
13380: CALL_OW 122
// wait ( 0 0$1 ) ;
13384: LD_INT 35
13386: PPUSH
13387: CALL_OW 67
// ComMoveXY ( Omar , 203 , 120 ) ;
13391: LD_EXP 48
13395: PPUSH
13396: LD_INT 203
13398: PPUSH
13399: LD_INT 120
13401: PPUSH
13402: CALL_OW 111
// repeat wait ( 0 0$1 ) ;
13406: LD_INT 35
13408: PPUSH
13409: CALL_OW 67
// until IsSelected ( Omar ) or GetDistUnitXY ( Omar , 203 , 120 ) < 6 ;
13413: LD_EXP 48
13417: PPUSH
13418: CALL_OW 306
13422: PUSH
13423: LD_EXP 48
13427: PPUSH
13428: LD_INT 203
13430: PPUSH
13431: LD_INT 120
13433: PPUSH
13434: CALL_OW 297
13438: PUSH
13439: LD_INT 6
13441: LESS
13442: OR
13443: IFFALSE 13406
// CenterNowOnUnits ( Omar ) ;
13445: LD_EXP 48
13449: PPUSH
13450: CALL_OW 87
// DialogueOn ;
13454: CALL_OW 6
// Say ( JMM , DOmarContam-JMM-1 ) ;
13458: LD_EXP 12
13462: PPUSH
13463: LD_STRING DOmarContam-JMM-1
13465: PPUSH
13466: CALL_OW 88
// Say ( Omar , DOmarContam-Omar-1 ) ;
13470: LD_EXP 48
13474: PPUSH
13475: LD_STRING DOmarContam-Omar-1
13477: PPUSH
13478: CALL_OW 88
// Say ( JMM , DOmarContam-JMM-2 ) ;
13482: LD_EXP 12
13486: PPUSH
13487: LD_STRING DOmarContam-JMM-2
13489: PPUSH
13490: CALL_OW 88
// DialogueOff ;
13494: CALL_OW 7
// SetAttitude ( 5 , 7 , att_enemy , true ) ;
13498: LD_INT 5
13500: PPUSH
13501: LD_INT 7
13503: PPUSH
13504: LD_INT 2
13506: PPUSH
13507: LD_INT 1
13509: PPUSH
13510: CALL_OW 80
// repeat wait ( 0 0$3 ) ;
13514: LD_INT 105
13516: PPUSH
13517: CALL_OW 67
// until IsAt ( Omar , 203 , 120 ) ;
13521: LD_EXP 48
13525: PPUSH
13526: LD_INT 203
13528: PPUSH
13529: LD_INT 120
13531: PPUSH
13532: CALL_OW 307
13536: IFFALSE 13514
// YouLost ( MothContaminate ) ;
13538: LD_STRING MothContaminate
13540: PPUSH
13541: CALL_OW 104
// end ;
13545: END
// every 0 0$2 trigger not americanDestroyed and FilterAllUnits ( [ [ f_side , 1 ] , [ f_weapon , us_siberium_rocket ] ] ) do
13546: LD_EXP 4
13550: NOT
13551: PUSH
13552: LD_INT 22
13554: PUSH
13555: LD_INT 1
13557: PUSH
13558: EMPTY
13559: LIST
13560: LIST
13561: PUSH
13562: LD_INT 34
13564: PUSH
13565: LD_INT 8
13567: PUSH
13568: EMPTY
13569: LIST
13570: LIST
13571: PUSH
13572: EMPTY
13573: LIST
13574: LIST
13575: PPUSH
13576: CALL_OW 69
13580: AND
13581: IFFALSE 13662
13583: GO 13585
13585: DISABLE
// begin if not IsOk ( Powell ) then
13586: LD_EXP 47
13590: PPUSH
13591: CALL_OW 302
13595: NOT
13596: IFFALSE 13600
// exit ;
13598: GO 13662
// DialogueOn ;
13600: CALL_OW 6
// SayRadio ( Powell , DWinAmericans-Pow-1 ) ;
13604: LD_EXP 47
13608: PPUSH
13609: LD_STRING DWinAmericans-Pow-1
13611: PPUSH
13612: CALL_OW 94
// if IsOk ( Burlak ) then
13616: LD_EXP 44
13620: PPUSH
13621: CALL_OW 302
13625: IFFALSE 13639
// Say ( Burlak , DWinAmericans-Bur-1 ) ;
13627: LD_EXP 44
13631: PPUSH
13632: LD_STRING DWinAmericans-Bur-1
13634: PPUSH
13635: CALL_OW 88
// Say ( JMM , DWinAmericans-JMM-1 ) ;
13639: LD_EXP 12
13643: PPUSH
13644: LD_STRING DWinAmericans-JMM-1
13646: PPUSH
13647: CALL_OW 88
// DialogueOff ;
13651: CALL_OW 7
// YouLost ( AmBomb ) ;
13655: LD_STRING AmBomb
13657: PPUSH
13658: CALL_OW 104
// end ;
13662: END
// every 0 0$2 trigger not russianDestroyed and FilterAllUnits ( [ [ f_side , 3 ] , [ f_weapon , ru_siberium_rocket ] ] ) do
13663: LD_EXP 2
13667: NOT
13668: PUSH
13669: LD_INT 22
13671: PUSH
13672: LD_INT 3
13674: PUSH
13675: EMPTY
13676: LIST
13677: LIST
13678: PUSH
13679: LD_INT 34
13681: PUSH
13682: LD_INT 48
13684: PUSH
13685: EMPTY
13686: LIST
13687: LIST
13688: PUSH
13689: EMPTY
13690: LIST
13691: LIST
13692: PPUSH
13693: CALL_OW 69
13697: AND
13698: IFFALSE 13779
13700: GO 13702
13702: DISABLE
// begin if not IsOk ( Platonov ) then
13703: LD_EXP 51
13707: PPUSH
13708: CALL_OW 302
13712: NOT
13713: IFFALSE 13717
// exit ;
13715: GO 13779
// DialogueOn ;
13717: CALL_OW 6
// SayRadio ( Platonov , DWinRussians-Pla-1 ) ;
13721: LD_EXP 51
13725: PPUSH
13726: LD_STRING DWinRussians-Pla-1
13728: PPUSH
13729: CALL_OW 94
// if IsOk ( Burlak ) then
13733: LD_EXP 44
13737: PPUSH
13738: CALL_OW 302
13742: IFFALSE 13756
// Say ( Burlak , DWinRussians-Bur-1 ) ;
13744: LD_EXP 44
13748: PPUSH
13749: LD_STRING DWinRussians-Bur-1
13751: PPUSH
13752: CALL_OW 88
// Say ( JMM , DWinRussians-JMM-1 ) ;
13756: LD_EXP 12
13760: PPUSH
13761: LD_STRING DWinRussians-JMM-1
13763: PPUSH
13764: CALL_OW 88
// DialogueOff ;
13768: CALL_OW 7
// YouLost ( RuBomb ) ;
13772: LD_STRING RuBomb
13774: PPUSH
13775: CALL_OW 104
// end ;
13779: END
// every 0 0$20 trigger FilterUnitsInArea ( powellBase , [ f_side , 7 ] ) and not americanDestroyed do
13780: LD_INT 7
13782: PPUSH
13783: LD_INT 22
13785: PUSH
13786: LD_INT 7
13788: PUSH
13789: EMPTY
13790: LIST
13791: LIST
13792: PPUSH
13793: CALL_OW 70
13797: PUSH
13798: LD_EXP 4
13802: NOT
13803: AND
13804: IFFALSE 13833
13806: GO 13808
13808: DISABLE
// begin SayRadio ( Powell , DSurrenderAmericans-Pow-1 ) ;
13809: LD_EXP 47
13813: PPUSH
13814: LD_STRING DSurrenderAmericans-Pow-1
13816: PPUSH
13817: CALL_OW 94
// Say ( JMM , DSurrenderAmericans-JMM-1 ) ;
13821: LD_EXP 12
13825: PPUSH
13826: LD_STRING DSurrenderAmericans-JMM-1
13828: PPUSH
13829: CALL_OW 88
// end ;
13833: END
// every 0 0$20 trigger FilterUnitsInArea ( russianBaseArea , [ f_side , 7 ] ) and not russianDestroyed and Burlak do
13834: LD_INT 2
13836: PPUSH
13837: LD_INT 22
13839: PUSH
13840: LD_INT 7
13842: PUSH
13843: EMPTY
13844: LIST
13845: LIST
13846: PPUSH
13847: CALL_OW 70
13851: PUSH
13852: LD_EXP 2
13856: NOT
13857: AND
13858: PUSH
13859: LD_EXP 44
13863: AND
13864: IFFALSE 13893
13866: GO 13868
13868: DISABLE
// begin SayRadio ( Platonov , DSurrenderRussians-Pla-1 ) ;
13869: LD_EXP 51
13873: PPUSH
13874: LD_STRING DSurrenderRussians-Pla-1
13876: PPUSH
13877: CALL_OW 94
// Say ( Burlak , DSurrenderRussians-Bur-1 ) ;
13881: LD_EXP 44
13885: PPUSH
13886: LD_STRING DSurrenderRussians-Bur-1
13888: PPUSH
13889: CALL_OW 88
// end ;
13893: END
// every 0 0$2 + 0 0$5 trigger americanDestroyed do var i , tmp , speaker ;
13894: LD_EXP 4
13898: IFFALSE 14273
13900: GO 13902
13902: DISABLE
13903: LD_INT 0
13905: PPUSH
13906: PPUSH
13907: PPUSH
// begin MC_Kill ( 4 ) ;
13908: LD_INT 4
13910: PPUSH
13911: CALL 20307 0 1
// SetAttitude ( 1 , 7 , att_friend , true ) ;
13915: LD_INT 1
13917: PPUSH
13918: LD_INT 7
13920: PPUSH
13921: LD_INT 1
13923: PPUSH
13924: LD_INT 1
13926: PPUSH
13927: CALL_OW 80
// speaker := FilterAllUnits ( [ [ f_side , 1 ] , [ f_sex , sex_male ] , [ f_nation , 1 ] ] ) diff [ Powell , Gladstone , Cyrus , Bobby , Gary , Houten ] ;
13931: LD_ADDR_VAR 0 3
13935: PUSH
13936: LD_INT 22
13938: PUSH
13939: LD_INT 1
13941: PUSH
13942: EMPTY
13943: LIST
13944: LIST
13945: PUSH
13946: LD_INT 26
13948: PUSH
13949: LD_INT 1
13951: PUSH
13952: EMPTY
13953: LIST
13954: LIST
13955: PUSH
13956: LD_INT 23
13958: PUSH
13959: LD_INT 1
13961: PUSH
13962: EMPTY
13963: LIST
13964: LIST
13965: PUSH
13966: EMPTY
13967: LIST
13968: LIST
13969: LIST
13970: PPUSH
13971: CALL_OW 69
13975: PUSH
13976: LD_EXP 47
13980: PUSH
13981: LD_EXP 20
13985: PUSH
13986: LD_EXP 17
13990: PUSH
13991: LD_EXP 16
13995: PUSH
13996: LD_EXP 23
14000: PUSH
14001: LD_EXP 21
14005: PUSH
14006: EMPTY
14007: LIST
14008: LIST
14009: LIST
14010: LIST
14011: LIST
14012: LIST
14013: DIFF
14014: ST_TO_ADDR
// if speaker then
14015: LD_VAR 0 3
14019: IFFALSE 14045
// begin DialogueOn ;
14021: CALL_OW 6
// SayRadio ( speaker [ 1 ] , DSurrenderAmericans-Sol1-1a ) ;
14025: LD_VAR 0 3
14029: PUSH
14030: LD_INT 1
14032: ARRAY
14033: PPUSH
14034: LD_STRING DSurrenderAmericans-Sol1-1a
14036: PPUSH
14037: CALL_OW 94
// DialogueOff ;
14041: CALL_OW 7
// end ; tmp := FilterAllUnits ( [ [ f_side , 1 ] , [ f_type , unit_human ] ] ) ^ FilterAllUnits ( [ [ f_side , 1 ] , [ f_type , unit_vehicle ] , [ control_manual ] ] ) ;
14045: LD_ADDR_VAR 0 2
14049: PUSH
14050: LD_INT 22
14052: PUSH
14053: LD_INT 1
14055: PUSH
14056: EMPTY
14057: LIST
14058: LIST
14059: PUSH
14060: LD_INT 21
14062: PUSH
14063: LD_INT 1
14065: PUSH
14066: EMPTY
14067: LIST
14068: LIST
14069: PUSH
14070: EMPTY
14071: LIST
14072: LIST
14073: PPUSH
14074: CALL_OW 69
14078: PUSH
14079: LD_INT 22
14081: PUSH
14082: LD_INT 1
14084: PUSH
14085: EMPTY
14086: LIST
14087: LIST
14088: PUSH
14089: LD_INT 21
14091: PUSH
14092: LD_INT 2
14094: PUSH
14095: EMPTY
14096: LIST
14097: LIST
14098: PUSH
14099: LD_INT 1
14101: PUSH
14102: EMPTY
14103: LIST
14104: PUSH
14105: EMPTY
14106: LIST
14107: LIST
14108: LIST
14109: PPUSH
14110: CALL_OW 69
14114: ADD
14115: ST_TO_ADDR
// if tmp then
14116: LD_VAR 0 2
14120: IFFALSE 14273
// repeat wait ( 0 0$1 ) ;
14122: LD_INT 35
14124: PPUSH
14125: CALL_OW 67
// for i in tmp do
14129: LD_ADDR_VAR 0 1
14133: PUSH
14134: LD_VAR 0 2
14138: PUSH
14139: FOR_IN
14140: IFFALSE 14222
// begin if IsInUnit ( i ) and GetType ( IsInUnit ( i ) ) = unit_building then
14142: LD_VAR 0 1
14146: PPUSH
14147: CALL_OW 310
14151: PUSH
14152: LD_VAR 0 1
14156: PPUSH
14157: CALL_OW 310
14161: PPUSH
14162: CALL_OW 247
14166: PUSH
14167: LD_INT 3
14169: EQUAL
14170: AND
14171: IFFALSE 14182
// ComExitBuilding ( i ) ;
14173: LD_VAR 0 1
14177: PPUSH
14178: CALL_OW 122
// AddComMoveXY ( i , 122 , 242 ) ;
14182: LD_VAR 0 1
14186: PPUSH
14187: LD_INT 122
14189: PPUSH
14190: LD_INT 242
14192: PPUSH
14193: CALL_OW 171
// if IsInArea ( i , americanEscape ) then
14197: LD_VAR 0 1
14201: PPUSH
14202: LD_INT 35
14204: PPUSH
14205: CALL_OW 308
14209: IFFALSE 14220
// RemoveUnit ( i ) ;
14211: LD_VAR 0 1
14215: PPUSH
14216: CALL_OW 64
// end ;
14220: GO 14139
14222: POP
14223: POP
// until not FilterAllUnits ( [ [ f_side , 1 ] , [ f_or , [ f_type , unit_human ] , [ f_control , control_manual ] ] ] ) ;
14224: LD_INT 22
14226: PUSH
14227: LD_INT 1
14229: PUSH
14230: EMPTY
14231: LIST
14232: LIST
14233: PUSH
14234: LD_INT 2
14236: PUSH
14237: LD_INT 21
14239: PUSH
14240: LD_INT 1
14242: PUSH
14243: EMPTY
14244: LIST
14245: LIST
14246: PUSH
14247: LD_INT 33
14249: PUSH
14250: LD_INT 1
14252: PUSH
14253: EMPTY
14254: LIST
14255: LIST
14256: PUSH
14257: EMPTY
14258: LIST
14259: LIST
14260: LIST
14261: PUSH
14262: EMPTY
14263: LIST
14264: LIST
14265: PPUSH
14266: CALL_OW 69
14270: NOT
14271: IFFALSE 14122
// end ;
14273: PPOPN 3
14275: END
// every 0 0$2 + 0 0$5 trigger russianDestroyed do var i , tmp , speaker ;
14276: LD_EXP 2
14280: IFFALSE 14673
14282: GO 14284
14284: DISABLE
14285: LD_INT 0
14287: PPUSH
14288: PPUSH
14289: PPUSH
// begin repeat wait ( 0 0$1 ) ;
14290: LD_INT 35
14292: PPUSH
14293: CALL_OW 67
// until IsDead ( Yakotich ) ;
14297: LD_EXP 52
14301: PPUSH
14302: CALL_OW 301
14306: IFFALSE 14290
// MC_Kill ( 2 ) ;
14308: LD_INT 2
14310: PPUSH
14311: CALL 20307 0 1
// SetAttitude ( 3 , 7 , att_friend , true ) ;
14315: LD_INT 3
14317: PPUSH
14318: LD_INT 7
14320: PPUSH
14321: LD_INT 1
14323: PPUSH
14324: LD_INT 1
14326: PPUSH
14327: CALL_OW 80
// speaker := FilterAllUnits ( [ [ f_side , 3 ] , [ f_sex , sex_male ] , [ f_nation , 3 ] ] ) diff [ Platonov , Yakotich ] ;
14331: LD_ADDR_VAR 0 3
14335: PUSH
14336: LD_INT 22
14338: PUSH
14339: LD_INT 3
14341: PUSH
14342: EMPTY
14343: LIST
14344: LIST
14345: PUSH
14346: LD_INT 26
14348: PUSH
14349: LD_INT 1
14351: PUSH
14352: EMPTY
14353: LIST
14354: LIST
14355: PUSH
14356: LD_INT 23
14358: PUSH
14359: LD_INT 3
14361: PUSH
14362: EMPTY
14363: LIST
14364: LIST
14365: PUSH
14366: EMPTY
14367: LIST
14368: LIST
14369: LIST
14370: PPUSH
14371: CALL_OW 69
14375: PUSH
14376: LD_EXP 51
14380: PUSH
14381: LD_EXP 52
14385: PUSH
14386: EMPTY
14387: LIST
14388: LIST
14389: DIFF
14390: ST_TO_ADDR
// if speaker then
14391: LD_VAR 0 3
14395: IFFALSE 14445
// begin DialogueOn ;
14397: CALL_OW 6
// if Burlak then
14401: LD_EXP 44
14405: IFFALSE 14425
// SayRadio ( speaker [ 1 ] , DSurrenderRussians-RSol1-1 ) else
14407: LD_VAR 0 3
14411: PUSH
14412: LD_INT 1
14414: ARRAY
14415: PPUSH
14416: LD_STRING DSurrenderRussians-RSol1-1
14418: PPUSH
14419: CALL_OW 94
14423: GO 14441
// SayRadio ( speaker [ 1 ] , DSurrenderRussians-RSol1-1a ) ;
14425: LD_VAR 0 3
14429: PUSH
14430: LD_INT 1
14432: ARRAY
14433: PPUSH
14434: LD_STRING DSurrenderRussians-RSol1-1a
14436: PPUSH
14437: CALL_OW 94
// DialogueOff ;
14441: CALL_OW 7
// end ; tmp := FilterAllUnits ( [ [ f_side , 3 ] , [ f_type , unit_human ] ] ) ^ FilterAllUnits ( [ [ f_side , 3 ] , [ f_type , unit_vehicle ] , [ control_manual ] ] ) ;
14445: LD_ADDR_VAR 0 2
14449: PUSH
14450: LD_INT 22
14452: PUSH
14453: LD_INT 3
14455: PUSH
14456: EMPTY
14457: LIST
14458: LIST
14459: PUSH
14460: LD_INT 21
14462: PUSH
14463: LD_INT 1
14465: PUSH
14466: EMPTY
14467: LIST
14468: LIST
14469: PUSH
14470: EMPTY
14471: LIST
14472: LIST
14473: PPUSH
14474: CALL_OW 69
14478: PUSH
14479: LD_INT 22
14481: PUSH
14482: LD_INT 3
14484: PUSH
14485: EMPTY
14486: LIST
14487: LIST
14488: PUSH
14489: LD_INT 21
14491: PUSH
14492: LD_INT 2
14494: PUSH
14495: EMPTY
14496: LIST
14497: LIST
14498: PUSH
14499: LD_INT 1
14501: PUSH
14502: EMPTY
14503: LIST
14504: PUSH
14505: EMPTY
14506: LIST
14507: LIST
14508: LIST
14509: PPUSH
14510: CALL_OW 69
14514: ADD
14515: ST_TO_ADDR
// if tmp then
14516: LD_VAR 0 2
14520: IFFALSE 14673
// repeat wait ( 0 0$1 ) ;
14522: LD_INT 35
14524: PPUSH
14525: CALL_OW 67
// for i in tmp do
14529: LD_ADDR_VAR 0 1
14533: PUSH
14534: LD_VAR 0 2
14538: PUSH
14539: FOR_IN
14540: IFFALSE 14622
// begin if IsInUnit ( i ) and GetType ( IsInUnit ( i ) ) = unit_building then
14542: LD_VAR 0 1
14546: PPUSH
14547: CALL_OW 310
14551: PUSH
14552: LD_VAR 0 1
14556: PPUSH
14557: CALL_OW 310
14561: PPUSH
14562: CALL_OW 247
14566: PUSH
14567: LD_INT 3
14569: EQUAL
14570: AND
14571: IFFALSE 14582
// ComExitBuilding ( i ) ;
14573: LD_VAR 0 1
14577: PPUSH
14578: CALL_OW 122
// AddComMoveXY ( i , 154 , 1 ) ;
14582: LD_VAR 0 1
14586: PPUSH
14587: LD_INT 154
14589: PPUSH
14590: LD_INT 1
14592: PPUSH
14593: CALL_OW 171
// if IsInArea ( i , russianEscape ) then
14597: LD_VAR 0 1
14601: PPUSH
14602: LD_INT 36
14604: PPUSH
14605: CALL_OW 308
14609: IFFALSE 14620
// RemoveUnit ( i ) ;
14611: LD_VAR 0 1
14615: PPUSH
14616: CALL_OW 64
// end ;
14620: GO 14539
14622: POP
14623: POP
// until not FilterAllUnits ( [ [ f_side , 3 ] , [ f_or , [ f_type , unit_human ] , [ f_control , control_manual ] ] ] ) ;
14624: LD_INT 22
14626: PUSH
14627: LD_INT 3
14629: PUSH
14630: EMPTY
14631: LIST
14632: LIST
14633: PUSH
14634: LD_INT 2
14636: PUSH
14637: LD_INT 21
14639: PUSH
14640: LD_INT 1
14642: PUSH
14643: EMPTY
14644: LIST
14645: LIST
14646: PUSH
14647: LD_INT 33
14649: PUSH
14650: LD_INT 1
14652: PUSH
14653: EMPTY
14654: LIST
14655: LIST
14656: PUSH
14657: EMPTY
14658: LIST
14659: LIST
14660: LIST
14661: PUSH
14662: EMPTY
14663: LIST
14664: LIST
14665: PPUSH
14666: CALL_OW 69
14670: NOT
14671: IFFALSE 14522
// end ;
14673: PPOPN 3
14675: END
// every 0 0$3 trigger FilterAllUnits ( [ [ f_side , 8 ] , [ f_type , unit_human ] , [ f_nation , 2 ] ] ) < 18 or IsDead ( Kozlov ) do
14676: LD_INT 22
14678: PUSH
14679: LD_INT 8
14681: PUSH
14682: EMPTY
14683: LIST
14684: LIST
14685: PUSH
14686: LD_INT 21
14688: PUSH
14689: LD_INT 1
14691: PUSH
14692: EMPTY
14693: LIST
14694: LIST
14695: PUSH
14696: LD_INT 23
14698: PUSH
14699: LD_INT 2
14701: PUSH
14702: EMPTY
14703: LIST
14704: LIST
14705: PUSH
14706: EMPTY
14707: LIST
14708: LIST
14709: LIST
14710: PPUSH
14711: CALL_OW 69
14715: PUSH
14716: LD_INT 18
14718: LESS
14719: PUSH
14720: LD_EXP 50
14724: PPUSH
14725: CALL_OW 301
14729: OR
14730: IFFALSE 14743
14732: GO 14734
14734: DISABLE
// legionDestroyed := true ;
14735: LD_ADDR_EXP 3
14739: PUSH
14740: LD_INT 1
14742: ST_TO_ADDR
14743: END
// every 0 0$3 trigger FilterAllUnits ( [ [ f_side , 2 ] , [ f_type , unit_human ] , [ f_nation , 2 ] ] ) < 9 do
14744: LD_INT 22
14746: PUSH
14747: LD_INT 2
14749: PUSH
14750: EMPTY
14751: LIST
14752: LIST
14753: PUSH
14754: LD_INT 21
14756: PUSH
14757: LD_INT 1
14759: PUSH
14760: EMPTY
14761: LIST
14762: LIST
14763: PUSH
14764: LD_INT 23
14766: PUSH
14767: LD_INT 2
14769: PUSH
14770: EMPTY
14771: LIST
14772: LIST
14773: PUSH
14774: EMPTY
14775: LIST
14776: LIST
14777: LIST
14778: PPUSH
14779: CALL_OW 69
14783: PUSH
14784: LD_INT 9
14786: LESS
14787: IFFALSE 14800
14789: GO 14791
14791: DISABLE
// arabianDestroyed := true ;
14792: LD_ADDR_EXP 5
14796: PUSH
14797: LD_INT 1
14799: ST_TO_ADDR
14800: END
// every 0 0$1 trigger arabianDestroyed do var i , tmp ;
14801: LD_EXP 5
14805: IFFALSE 15065
14807: GO 14809
14809: DISABLE
14810: LD_INT 0
14812: PPUSH
14813: PPUSH
// begin MC_Kill ( 1 ) ;
14814: LD_INT 1
14816: PPUSH
14817: CALL 20307 0 1
// SetAttitude ( 2 , 7 , att_friend , true ) ;
14821: LD_INT 2
14823: PPUSH
14824: LD_INT 7
14826: PPUSH
14827: LD_INT 1
14829: PPUSH
14830: LD_INT 1
14832: PPUSH
14833: CALL_OW 80
// tmp := FilterAllUnits ( [ [ f_side , 2 ] , [ f_type , unit_human ] ] ) ^ FilterAllUnits ( [ [ f_side , 8 ] , [ f_type , unit_vehicle ] , [ control_manual ] ] ) ;
14837: LD_ADDR_VAR 0 2
14841: PUSH
14842: LD_INT 22
14844: PUSH
14845: LD_INT 2
14847: PUSH
14848: EMPTY
14849: LIST
14850: LIST
14851: PUSH
14852: LD_INT 21
14854: PUSH
14855: LD_INT 1
14857: PUSH
14858: EMPTY
14859: LIST
14860: LIST
14861: PUSH
14862: EMPTY
14863: LIST
14864: LIST
14865: PPUSH
14866: CALL_OW 69
14870: PUSH
14871: LD_INT 22
14873: PUSH
14874: LD_INT 8
14876: PUSH
14877: EMPTY
14878: LIST
14879: LIST
14880: PUSH
14881: LD_INT 21
14883: PUSH
14884: LD_INT 2
14886: PUSH
14887: EMPTY
14888: LIST
14889: LIST
14890: PUSH
14891: LD_INT 1
14893: PUSH
14894: EMPTY
14895: LIST
14896: PUSH
14897: EMPTY
14898: LIST
14899: LIST
14900: LIST
14901: PPUSH
14902: CALL_OW 69
14906: ADD
14907: ST_TO_ADDR
// if tmp then
14908: LD_VAR 0 2
14912: IFFALSE 15065
// repeat wait ( 0 0$1 ) ;
14914: LD_INT 35
14916: PPUSH
14917: CALL_OW 67
// for i in tmp do
14921: LD_ADDR_VAR 0 1
14925: PUSH
14926: LD_VAR 0 2
14930: PUSH
14931: FOR_IN
14932: IFFALSE 15014
// begin if IsInUnit ( i ) and GetType ( IsInUnit ( i ) ) = unit_building then
14934: LD_VAR 0 1
14938: PPUSH
14939: CALL_OW 310
14943: PUSH
14944: LD_VAR 0 1
14948: PPUSH
14949: CALL_OW 310
14953: PPUSH
14954: CALL_OW 247
14958: PUSH
14959: LD_INT 3
14961: EQUAL
14962: AND
14963: IFFALSE 14974
// ComExitBuilding ( i ) ;
14965: LD_VAR 0 1
14969: PPUSH
14970: CALL_OW 122
// AddComMoveXY ( i , 254 , 268 ) ;
14974: LD_VAR 0 1
14978: PPUSH
14979: LD_INT 254
14981: PPUSH
14982: LD_INT 268
14984: PPUSH
14985: CALL_OW 171
// if IsInArea ( i , arabEscape ) then
14989: LD_VAR 0 1
14993: PPUSH
14994: LD_INT 34
14996: PPUSH
14997: CALL_OW 308
15001: IFFALSE 15012
// RemoveUnit ( i ) ;
15003: LD_VAR 0 1
15007: PPUSH
15008: CALL_OW 64
// end ;
15012: GO 14931
15014: POP
15015: POP
// until not FilterAllUnits ( [ [ f_side , 2 ] , [ f_or , [ f_type , unit_human ] , [ f_control , control_manual ] ] ] ) ;
15016: LD_INT 22
15018: PUSH
15019: LD_INT 2
15021: PUSH
15022: EMPTY
15023: LIST
15024: LIST
15025: PUSH
15026: LD_INT 2
15028: PUSH
15029: LD_INT 21
15031: PUSH
15032: LD_INT 1
15034: PUSH
15035: EMPTY
15036: LIST
15037: LIST
15038: PUSH
15039: LD_INT 33
15041: PUSH
15042: LD_INT 1
15044: PUSH
15045: EMPTY
15046: LIST
15047: LIST
15048: PUSH
15049: EMPTY
15050: LIST
15051: LIST
15052: LIST
15053: PUSH
15054: EMPTY
15055: LIST
15056: LIST
15057: PPUSH
15058: CALL_OW 69
15062: NOT
15063: IFFALSE 14914
// end ;
15065: PPOPN 2
15067: END
// every 0 0$1 trigger legionDestroyed do var i , tmp ;
15068: LD_EXP 3
15072: IFFALSE 15413
15074: GO 15076
15076: DISABLE
15077: LD_INT 0
15079: PPUSH
15080: PPUSH
// begin MC_Kill ( 3 ) ;
15081: LD_INT 3
15083: PPUSH
15084: CALL 20307 0 1
// SetAttitude ( 8 , 7 , att_friend , true ) ;
15088: LD_INT 8
15090: PPUSH
15091: LD_INT 7
15093: PPUSH
15094: LD_INT 1
15096: PPUSH
15097: LD_INT 1
15099: PPUSH
15100: CALL_OW 80
// DialogueOn ;
15104: CALL_OW 6
// SayRadio ( Schulz , D15-Szulc-1 ) ;
15108: LD_EXP 49
15112: PPUSH
15113: LD_STRING D15-Szulc-1
15115: PPUSH
15116: CALL_OW 94
// DialogueOff ;
15120: CALL_OW 7
// for i in FilterAllUnits ( [ [ f_side , 8 ] , [ f_type , unit_building ] , [ f_nation , 3 ] ] ) do
15124: LD_ADDR_VAR 0 1
15128: PUSH
15129: LD_INT 22
15131: PUSH
15132: LD_INT 8
15134: PUSH
15135: EMPTY
15136: LIST
15137: LIST
15138: PUSH
15139: LD_INT 21
15141: PUSH
15142: LD_INT 3
15144: PUSH
15145: EMPTY
15146: LIST
15147: LIST
15148: PUSH
15149: LD_INT 23
15151: PUSH
15152: LD_INT 3
15154: PUSH
15155: EMPTY
15156: LIST
15157: LIST
15158: PUSH
15159: EMPTY
15160: LIST
15161: LIST
15162: LIST
15163: PPUSH
15164: CALL_OW 69
15168: PUSH
15169: FOR_IN
15170: IFFALSE 15183
// DestroyUnit ( i ) ;
15172: LD_VAR 0 1
15176: PPUSH
15177: CALL_OW 65
15181: GO 15169
15183: POP
15184: POP
// tmp := FilterAllUnits ( [ [ f_side , 8 ] , [ f_type , unit_human ] ] ) ^ FilterAllUnits ( [ [ f_side , 8 ] , [ f_type , unit_vehicle ] , [ control_manual ] ] ) ;
15185: LD_ADDR_VAR 0 2
15189: PUSH
15190: LD_INT 22
15192: PUSH
15193: LD_INT 8
15195: PUSH
15196: EMPTY
15197: LIST
15198: LIST
15199: PUSH
15200: LD_INT 21
15202: PUSH
15203: LD_INT 1
15205: PUSH
15206: EMPTY
15207: LIST
15208: LIST
15209: PUSH
15210: EMPTY
15211: LIST
15212: LIST
15213: PPUSH
15214: CALL_OW 69
15218: PUSH
15219: LD_INT 22
15221: PUSH
15222: LD_INT 8
15224: PUSH
15225: EMPTY
15226: LIST
15227: LIST
15228: PUSH
15229: LD_INT 21
15231: PUSH
15232: LD_INT 2
15234: PUSH
15235: EMPTY
15236: LIST
15237: LIST
15238: PUSH
15239: LD_INT 1
15241: PUSH
15242: EMPTY
15243: LIST
15244: PUSH
15245: EMPTY
15246: LIST
15247: LIST
15248: LIST
15249: PPUSH
15250: CALL_OW 69
15254: ADD
15255: ST_TO_ADDR
// if tmp then
15256: LD_VAR 0 2
15260: IFFALSE 15413
// repeat wait ( 0 0$1 ) ;
15262: LD_INT 35
15264: PPUSH
15265: CALL_OW 67
// for i in tmp do
15269: LD_ADDR_VAR 0 1
15273: PUSH
15274: LD_VAR 0 2
15278: PUSH
15279: FOR_IN
15280: IFFALSE 15362
// begin if IsInUnit ( i ) and GetType ( IsInUnit ( i ) ) = unit_building then
15282: LD_VAR 0 1
15286: PPUSH
15287: CALL_OW 310
15291: PUSH
15292: LD_VAR 0 1
15296: PPUSH
15297: CALL_OW 310
15301: PPUSH
15302: CALL_OW 247
15306: PUSH
15307: LD_INT 3
15309: EQUAL
15310: AND
15311: IFFALSE 15322
// ComExitBuilding ( i ) ;
15313: LD_VAR 0 1
15317: PPUSH
15318: CALL_OW 122
// AddComMoveXY ( i , 10 , 1 ) ;
15322: LD_VAR 0 1
15326: PPUSH
15327: LD_INT 10
15329: PPUSH
15330: LD_INT 1
15332: PPUSH
15333: CALL_OW 171
// if IsInArea ( i , legionEscape ) then
15337: LD_VAR 0 1
15341: PPUSH
15342: LD_INT 32
15344: PPUSH
15345: CALL_OW 308
15349: IFFALSE 15360
// RemoveUnit ( i ) ;
15351: LD_VAR 0 1
15355: PPUSH
15356: CALL_OW 64
// end ;
15360: GO 15279
15362: POP
15363: POP
// until not FilterAllUnits ( [ [ f_side , 8 ] , [ f_or , [ f_type , unit_human ] , [ f_control , control_manual ] ] ] ) ;
15364: LD_INT 22
15366: PUSH
15367: LD_INT 8
15369: PUSH
15370: EMPTY
15371: LIST
15372: LIST
15373: PUSH
15374: LD_INT 2
15376: PUSH
15377: LD_INT 21
15379: PUSH
15380: LD_INT 1
15382: PUSH
15383: EMPTY
15384: LIST
15385: LIST
15386: PUSH
15387: LD_INT 33
15389: PUSH
15390: LD_INT 1
15392: PUSH
15393: EMPTY
15394: LIST
15395: LIST
15396: PUSH
15397: EMPTY
15398: LIST
15399: LIST
15400: LIST
15401: PUSH
15402: EMPTY
15403: LIST
15404: LIST
15405: PPUSH
15406: CALL_OW 69
15410: NOT
15411: IFFALSE 15262
// end ;
15413: PPOPN 2
15415: END
// every 0 0$3 trigger americanDestroyed and russianDestroyed and legionDestroyed and arabianDestroyed do var med1 , med2 ;
15416: LD_EXP 4
15420: PUSH
15421: LD_EXP 2
15425: AND
15426: PUSH
15427: LD_EXP 3
15431: AND
15432: PUSH
15433: LD_EXP 5
15437: AND
15438: IFFALSE 16741
15440: GO 15442
15442: DISABLE
15443: LD_INT 0
15445: PPUSH
15446: PPUSH
// begin music_class := 5 ;
15447: LD_ADDR_OWVAR 72
15451: PUSH
15452: LD_INT 5
15454: ST_TO_ADDR
// music_nat := 5 ;
15455: LD_ADDR_OWVAR 71
15459: PUSH
15460: LD_INT 5
15462: ST_TO_ADDR
// CenterNowOnUnits ( JMM ) ;
15463: LD_EXP 12
15467: PPUSH
15468: CALL_OW 87
// InGameOn ;
15472: CALL_OW 8
// DialogueOn ;
15476: CALL_OW 6
// Say ( JMM , DEnd-JMM-JMM-1 ) ;
15480: LD_EXP 12
15484: PPUSH
15485: LD_STRING DEnd-JMM-JMM-1
15487: PPUSH
15488: CALL_OW 88
// if Joan then
15492: LD_EXP 27
15496: IFFALSE 15512
// Say ( Joan , DEnd-JMM-Joan-1 ) else
15498: LD_EXP 27
15502: PPUSH
15503: LD_STRING DEnd-JMM-Joan-1
15505: PPUSH
15506: CALL_OW 88
15510: GO 15556
// if Lisa and GetSide ( Lisa ) = 7 and IsPlaced ( Lisa ) then
15512: LD_EXP 14
15516: PUSH
15517: LD_EXP 14
15521: PPUSH
15522: CALL_OW 255
15526: PUSH
15527: LD_INT 7
15529: EQUAL
15530: AND
15531: PUSH
15532: LD_EXP 14
15536: PPUSH
15537: CALL_OW 305
15541: AND
15542: IFFALSE 15556
// Say ( Lisa , DEnd-JMM-Lisa-1 ) ;
15544: LD_EXP 14
15548: PPUSH
15549: LD_STRING DEnd-JMM-Lisa-1
15551: PPUSH
15552: CALL_OW 88
// if Frank and IsPlaced ( Frank ) then
15556: LD_EXP 24
15560: PUSH
15561: LD_EXP 24
15565: PPUSH
15566: CALL_OW 305
15570: AND
15571: IFFALSE 15585
// Say ( Frank , DEnd-JMM-Frank-1 ) ;
15573: LD_EXP 24
15577: PPUSH
15578: LD_STRING DEnd-JMM-Frank-1
15580: PPUSH
15581: CALL_OW 88
// if Cyrus and GetSide ( Cyrus ) = 7 and IsPlaced ( Cyrus ) then
15585: LD_EXP 17
15589: PUSH
15590: LD_EXP 17
15594: PPUSH
15595: CALL_OW 255
15599: PUSH
15600: LD_INT 7
15602: EQUAL
15603: AND
15604: PUSH
15605: LD_EXP 17
15609: PPUSH
15610: CALL_OW 305
15614: AND
15615: IFFALSE 15629
// Say ( Cyrus , DEnd-JMM-Cyrus-1 ) ;
15617: LD_EXP 17
15621: PPUSH
15622: LD_STRING DEnd-JMM-Cyrus-1
15624: PPUSH
15625: CALL_OW 88
// if Burlak then
15629: LD_EXP 44
15633: IFFALSE 15647
// Say ( Burlak , DEnd-JMM-Bur-1 ) ;
15635: LD_EXP 44
15639: PPUSH
15640: LD_STRING DEnd-JMM-Bur-1
15642: PPUSH
15643: CALL_OW 88
// if Joan and Lisa and GetSide ( Lisa ) = 7 and IsPlaced ( Lisa ) then
15647: LD_EXP 27
15651: PUSH
15652: LD_EXP 14
15656: AND
15657: PUSH
15658: LD_EXP 14
15662: PPUSH
15663: CALL_OW 255
15667: PUSH
15668: LD_INT 7
15670: EQUAL
15671: AND
15672: PUSH
15673: LD_EXP 14
15677: PPUSH
15678: CALL_OW 305
15682: AND
15683: IFFALSE 15697
// Say ( Lisa , DEnd-Burlak-Lisa-1 ) ;
15685: LD_EXP 14
15689: PPUSH
15690: LD_STRING DEnd-Burlak-Lisa-1
15692: PPUSH
15693: CALL_OW 88
// if Belkov and IsPlaced ( Belkov ) then
15697: LD_EXP 45
15701: PUSH
15702: LD_EXP 45
15706: PPUSH
15707: CALL_OW 305
15711: AND
15712: IFFALSE 15726
// Say ( Belkov , DEnd-JMM-Bel-1 ) ;
15714: LD_EXP 45
15718: PPUSH
15719: LD_STRING DEnd-JMM-Bel-1
15721: PPUSH
15722: CALL_OW 88
// if Gnyevko and IsPlaced ( Gnyevko ) then
15726: LD_EXP 46
15730: PUSH
15731: LD_EXP 46
15735: PPUSH
15736: CALL_OW 305
15740: AND
15741: IFFALSE 15755
// Say ( Gnyevko , DEnd-JMM-Gny-1 ) ;
15743: LD_EXP 46
15747: PPUSH
15748: LD_STRING DEnd-JMM-Gny-1
15750: PPUSH
15751: CALL_OW 88
// if Cornel and GetSide ( Cornel ) = 7 and IsPlaced ( Cornel ) then
15755: LD_EXP 22
15759: PUSH
15760: LD_EXP 22
15764: PPUSH
15765: CALL_OW 255
15769: PUSH
15770: LD_INT 7
15772: EQUAL
15773: AND
15774: PUSH
15775: LD_EXP 22
15779: PPUSH
15780: CALL_OW 305
15784: AND
15785: IFFALSE 15799
// Say ( Cornel , DEnd-JMM-Corn-1 ) ;
15787: LD_EXP 22
15791: PPUSH
15792: LD_STRING DEnd-JMM-Corn-1
15794: PPUSH
15795: CALL_OW 88
// if Donaldson and GetSide ( Donaldson ) = 7 and IsPlaced ( Donaldson ) then
15799: LD_EXP 15
15803: PUSH
15804: LD_EXP 15
15808: PPUSH
15809: CALL_OW 255
15813: PUSH
15814: LD_INT 7
15816: EQUAL
15817: AND
15818: PUSH
15819: LD_EXP 15
15823: PPUSH
15824: CALL_OW 305
15828: AND
15829: IFFALSE 15843
// Say ( Donaldson , DEnd-JMM-Don-1 ) ;
15831: LD_EXP 15
15835: PPUSH
15836: LD_STRING DEnd-JMM-Don-1
15838: PPUSH
15839: CALL_OW 88
// if Bobby and GetSide ( Bobby ) = 7 and IsPlaced ( Bobby ) then
15843: LD_EXP 16
15847: PUSH
15848: LD_EXP 16
15852: PPUSH
15853: CALL_OW 255
15857: PUSH
15858: LD_INT 7
15860: EQUAL
15861: AND
15862: PUSH
15863: LD_EXP 16
15867: PPUSH
15868: CALL_OW 305
15872: AND
15873: IFFALSE 15887
// Say ( Bobby , DEnd-JMM-Bobby-1 ) ;
15875: LD_EXP 16
15879: PPUSH
15880: LD_STRING DEnd-JMM-Bobby-1
15882: PPUSH
15883: CALL_OW 88
// if Denis and GetSide ( Denis ) = 7 and IsPlaced ( Denis ) then
15887: LD_EXP 18
15891: PUSH
15892: LD_EXP 18
15896: PPUSH
15897: CALL_OW 255
15901: PUSH
15902: LD_INT 7
15904: EQUAL
15905: AND
15906: PUSH
15907: LD_EXP 18
15911: PPUSH
15912: CALL_OW 305
15916: AND
15917: IFFALSE 15931
// Say ( Denis , DEnd-JMM-Den-1 ) ;
15919: LD_EXP 18
15923: PPUSH
15924: LD_STRING DEnd-JMM-Den-1
15926: PPUSH
15927: CALL_OW 88
// if Gladstone and GetSide ( Gladstone ) = 7 and IsPlaced ( Gladstone ) then
15931: LD_EXP 20
15935: PUSH
15936: LD_EXP 20
15940: PPUSH
15941: CALL_OW 255
15945: PUSH
15946: LD_INT 7
15948: EQUAL
15949: AND
15950: PUSH
15951: LD_EXP 20
15955: PPUSH
15956: CALL_OW 305
15960: AND
15961: IFFALSE 15975
// Say ( Gladstone , DEnd-JMM-Glad-1 ) ;
15963: LD_EXP 20
15967: PPUSH
15968: LD_STRING DEnd-JMM-Glad-1
15970: PPUSH
15971: CALL_OW 88
// if Kikuchi and GetSide ( Kikuchi ) = 7 and IsPlaced ( Kikuchi ) then
15975: LD_EXP 25
15979: PUSH
15980: LD_EXP 25
15984: PPUSH
15985: CALL_OW 255
15989: PUSH
15990: LD_INT 7
15992: EQUAL
15993: AND
15994: PUSH
15995: LD_EXP 25
15999: PPUSH
16000: CALL_OW 305
16004: AND
16005: IFFALSE 16019
// Say ( Kikuchi , DEnd-JMM-Yam-1 ) ;
16007: LD_EXP 25
16011: PPUSH
16012: LD_STRING DEnd-JMM-Yam-1
16014: PPUSH
16015: CALL_OW 88
// if Brown and GetSide ( Brown ) = 7 and IsPlaced ( Brown ) then
16019: LD_EXP 19
16023: PUSH
16024: LD_EXP 19
16028: PPUSH
16029: CALL_OW 255
16033: PUSH
16034: LD_INT 7
16036: EQUAL
16037: AND
16038: PUSH
16039: LD_EXP 19
16043: PPUSH
16044: CALL_OW 305
16048: AND
16049: IFFALSE 16063
// Say ( Brown , DEnd-JMM-Brown-1 ) ;
16051: LD_EXP 19
16055: PPUSH
16056: LD_STRING DEnd-JMM-Brown-1
16058: PPUSH
16059: CALL_OW 88
// if Connie and GetSide ( Connie ) = 7 and IsPlaced ( Connie ) then
16063: LD_EXP 29
16067: PUSH
16068: LD_EXP 29
16072: PPUSH
16073: CALL_OW 255
16077: PUSH
16078: LD_INT 7
16080: EQUAL
16081: AND
16082: PUSH
16083: LD_EXP 29
16087: PPUSH
16088: CALL_OW 305
16092: AND
16093: IFFALSE 16107
// Say ( Connie , DEnd-JMM-Con-1 ) ;
16095: LD_EXP 29
16099: PPUSH
16100: LD_STRING DEnd-JMM-Con-1
16102: PPUSH
16103: CALL_OW 88
// if Gary and GetSide ( Gary ) = 7 and IsPlaced ( Gary ) then
16107: LD_EXP 23
16111: PUSH
16112: LD_EXP 23
16116: PPUSH
16117: CALL_OW 255
16121: PUSH
16122: LD_INT 7
16124: EQUAL
16125: AND
16126: PUSH
16127: LD_EXP 23
16131: PPUSH
16132: CALL_OW 305
16136: AND
16137: IFFALSE 16151
// Say ( Gary , DEnd-JMM-Gary-1 ) ;
16139: LD_EXP 23
16143: PPUSH
16144: LD_STRING DEnd-JMM-Gary-1
16146: PPUSH
16147: CALL_OW 88
// if Simms and Roth and IsPlaced ( Simms ) then
16151: LD_EXP 26
16155: PUSH
16156: LD_EXP 13
16160: AND
16161: PUSH
16162: LD_EXP 26
16166: PPUSH
16167: CALL_OW 305
16171: AND
16172: IFFALSE 16186
// Say ( Simms , DEnd-JMM-Sim-1 ) ;
16174: LD_EXP 26
16178: PPUSH
16179: LD_STRING DEnd-JMM-Sim-1
16181: PPUSH
16182: CALL_OW 88
// if Houten and GetSide ( Houten ) = 7 and IsPlaced ( Houten ) then
16186: LD_EXP 21
16190: PUSH
16191: LD_EXP 21
16195: PPUSH
16196: CALL_OW 255
16200: PUSH
16201: LD_INT 7
16203: EQUAL
16204: AND
16205: PUSH
16206: LD_EXP 21
16210: PPUSH
16211: CALL_OW 305
16215: AND
16216: IFFALSE 16230
// Say ( Houten , DEnd-JMM-VanH-1 ) ;
16218: LD_EXP 21
16222: PPUSH
16223: LD_STRING DEnd-JMM-VanH-1
16225: PPUSH
16226: CALL_OW 88
// if Dolgov and IsPlaced ( Dolgov ) then
16230: LD_EXP 34
16234: PUSH
16235: LD_EXP 34
16239: PPUSH
16240: CALL_OW 305
16244: AND
16245: IFFALSE 16259
// Say ( Dolgov , DEnd-JMM-Dol-1 ) ;
16247: LD_EXP 34
16251: PPUSH
16252: LD_STRING DEnd-JMM-Dol-1
16254: PPUSH
16255: CALL_OW 88
// if Kapitsova and IsPlaced ( Kapitsova ) then
16259: LD_EXP 38
16263: PUSH
16264: LD_EXP 38
16268: PPUSH
16269: CALL_OW 305
16273: AND
16274: IFFALSE 16288
// Say ( Kapitsova , DEnd-JMM-Kap-1 ) ;
16276: LD_EXP 38
16280: PPUSH
16281: LD_STRING DEnd-JMM-Kap-1
16283: PPUSH
16284: CALL_OW 88
// if Kovalyuk and IsPlaced ( Kovalyuk ) then
16288: LD_EXP 41
16292: PUSH
16293: LD_EXP 41
16297: PPUSH
16298: CALL_OW 305
16302: AND
16303: IFFALSE 16317
// Say ( Kovalyuk , DEnd-JMM-Kov-1 ) ;
16305: LD_EXP 41
16309: PPUSH
16310: LD_STRING DEnd-JMM-Kov-1
16312: PPUSH
16313: CALL_OW 88
// if Scholtze and IsPlaced ( Scholtze ) then
16317: LD_EXP 36
16321: PUSH
16322: LD_EXP 36
16326: PPUSH
16327: CALL_OW 305
16331: AND
16332: IFFALSE 16346
// Say ( Scholtze , DEnd-JMM-Sch-1 ) ;
16334: LD_EXP 36
16338: PPUSH
16339: LD_STRING DEnd-JMM-Sch-1
16341: PPUSH
16342: CALL_OW 88
// if Titov and IsPlaced ( Titov ) then
16346: LD_EXP 32
16350: PUSH
16351: LD_EXP 32
16355: PPUSH
16356: CALL_OW 305
16360: AND
16361: IFFALSE 16375
// Say ( Titov , DEnd-JMM-Tit-1 ) ;
16363: LD_EXP 32
16367: PPUSH
16368: LD_STRING DEnd-JMM-Tit-1
16370: PPUSH
16371: CALL_OW 88
// if Oblukov and IsPlaced ( Oblukov ) then
16375: LD_EXP 37
16379: PUSH
16380: LD_EXP 37
16384: PPUSH
16385: CALL_OW 305
16389: AND
16390: IFFALSE 16404
// Say ( Oblukov , DEnd-JMM-Obl-1 ) ;
16392: LD_EXP 37
16396: PPUSH
16397: LD_STRING DEnd-JMM-Obl-1
16399: PPUSH
16400: CALL_OW 88
// if Lipshchin and IsPlaced ( Lipshchin ) then
16404: LD_EXP 39
16408: PUSH
16409: LD_EXP 39
16413: PPUSH
16414: CALL_OW 305
16418: AND
16419: IFFALSE 16433
// Say ( Lipshchin , DEnd-JMM-Lip-1 ) ;
16421: LD_EXP 39
16425: PPUSH
16426: LD_STRING DEnd-JMM-Lip-1
16428: PPUSH
16429: CALL_OW 88
// if Fadeev and IsPlaced ( Fadeev ) and Burlak then
16433: LD_EXP 33
16437: PUSH
16438: LD_EXP 33
16442: PPUSH
16443: CALL_OW 305
16447: AND
16448: PUSH
16449: LD_EXP 44
16453: AND
16454: IFFALSE 16468
// Say ( Fadeev , DEnd-Burlak-Fad-1 ) ;
16456: LD_EXP 33
16460: PPUSH
16461: LD_STRING DEnd-Burlak-Fad-1
16463: PPUSH
16464: CALL_OW 88
// if Petrovova and IsPlaced ( Petrovova ) then
16468: LD_EXP 40
16472: PUSH
16473: LD_EXP 40
16477: PPUSH
16478: CALL_OW 305
16482: AND
16483: IFFALSE 16497
// Say ( Petrovova , DEnd-Burlak-Ptr-1 ) ;
16485: LD_EXP 40
16489: PPUSH
16490: LD_STRING DEnd-Burlak-Ptr-1
16492: PPUSH
16493: CALL_OW 88
// if Kuzmov and IsPlaced ( Kuzmov ) then
16497: LD_EXP 42
16501: PUSH
16502: LD_EXP 42
16506: PPUSH
16507: CALL_OW 305
16511: AND
16512: IFFALSE 16526
// Say ( Kuzmov , DEnd-Burlak-Kuz-1 ) ;
16514: LD_EXP 42
16518: PPUSH
16519: LD_STRING DEnd-Burlak-Kuz-1
16521: PPUSH
16522: CALL_OW 88
// if Kirilenkova and IsPlaced ( Kirilenkova ) and Burlak then
16526: LD_EXP 31
16530: PUSH
16531: LD_EXP 31
16535: PPUSH
16536: CALL_OW 305
16540: AND
16541: PUSH
16542: LD_EXP 44
16546: AND
16547: IFFALSE 16561
// Say ( Kirilenkova , DEnd-Burlak-Kir-1 ) ;
16549: LD_EXP 31
16553: PPUSH
16554: LD_STRING DEnd-Burlak-Kir-1
16556: PPUSH
16557: CALL_OW 88
// if Burlak then
16561: LD_EXP 44
16565: IFFALSE 16579
// Say ( JMM , DEnd-Burlak-JMM-1 ) ;
16567: LD_EXP 12
16571: PPUSH
16572: LD_STRING DEnd-Burlak-JMM-1
16574: PPUSH
16575: CALL_OW 88
// dwait ( 0 0$2 ) ;
16579: LD_INT 70
16581: PPUSH
16582: CALL_OW 68
// SayRadio ( Schulz , DEnd-Szulc ) ;
16586: LD_EXP 49
16590: PPUSH
16591: LD_STRING DEnd-Szulc
16593: PPUSH
16594: CALL_OW 94
// dwait ( 0 0$1 ) ;
16598: LD_INT 35
16600: PPUSH
16601: CALL_OW 68
// if IsLive ( Burlak ) then
16605: LD_EXP 44
16609: PPUSH
16610: CALL_OW 300
16614: IFFALSE 16626
// med1 := 1 else
16616: LD_ADDR_VAR 0 1
16620: PUSH
16621: LD_INT 1
16623: ST_TO_ADDR
16624: GO 16635
// med1 := - 1 ;
16626: LD_ADDR_VAR 0 1
16630: PUSH
16631: LD_INT 1
16633: NEG
16634: ST_TO_ADDR
// if artifactIResearched and artifactIIResearched and artifactIIIResearched then
16635: LD_EXP 9
16639: PUSH
16640: LD_EXP 10
16644: AND
16645: PUSH
16646: LD_EXP 11
16650: AND
16651: IFFALSE 16663
// med2 := 1 else
16653: LD_ADDR_VAR 0 2
16657: PUSH
16658: LD_INT 1
16660: ST_TO_ADDR
16661: GO 16672
// med2 := - 1 ;
16663: LD_ADDR_VAR 0 2
16667: PUSH
16668: LD_INT 1
16670: NEG
16671: ST_TO_ADDR
// AddMedal ( Hero , 1 ) ;
16672: LD_STRING Hero
16674: PPUSH
16675: LD_INT 1
16677: PPUSH
16678: CALL_OW 101
// AddMedal ( Artefact , med2 ) ;
16682: LD_STRING Artefact
16684: PPUSH
16685: LD_VAR 0 2
16689: PPUSH
16690: CALL_OW 101
// AddMedal ( ReconcileBurlak , med1 ) ;
16694: LD_STRING ReconcileBurlak
16696: PPUSH
16697: LD_VAR 0 1
16701: PPUSH
16702: CALL_OW 101
// GiveMedals ( MAIN ) ;
16706: LD_STRING MAIN
16708: PPUSH
16709: CALL_OW 102
// InGameOff ;
16713: CALL_OW 9
// DialogueOff ;
16717: CALL_OW 7
// music_nat := 1 ;
16721: LD_ADDR_OWVAR 71
16725: PUSH
16726: LD_INT 1
16728: ST_TO_ADDR
// music_class := 4 ;
16729: LD_ADDR_OWVAR 72
16733: PUSH
16734: LD_INT 4
16736: ST_TO_ADDR
// YouWin ;
16737: CALL_OW 103
// end ; end_of_file
16741: PPOPN 2
16743: END
// export function InitNature ; begin
16744: LD_INT 0
16746: PPUSH
// PrepareNature ( 3 , 3 , 2 , 1 , 1 , 0 , 0 , natureArea1 , 0 ) ;
16747: LD_INT 3
16749: PPUSH
16750: LD_INT 3
16752: PPUSH
16753: LD_INT 2
16755: PPUSH
16756: LD_INT 1
16758: PPUSH
16759: LD_INT 1
16761: PPUSH
16762: LD_INT 0
16764: PPUSH
16765: LD_INT 0
16767: PPUSH
16768: LD_INT 17
16770: PPUSH
16771: LD_INT 0
16773: PPUSH
16774: CALL 84645 0 9
// PrepareNature ( 2 , 1 , 1 , 1 , 1 , 0 , 0 , natureArea2 , 0 ) ;
16778: LD_INT 2
16780: PPUSH
16781: LD_INT 1
16783: PPUSH
16784: LD_INT 1
16786: PPUSH
16787: LD_INT 1
16789: PPUSH
16790: LD_INT 1
16792: PPUSH
16793: LD_INT 0
16795: PPUSH
16796: LD_INT 0
16798: PPUSH
16799: LD_INT 18
16801: PPUSH
16802: LD_INT 0
16804: PPUSH
16805: CALL 84645 0 9
// PrepareNature ( 4 , 1 , 2 , 4 , 2 , 1 , 0 , natureArea3 , 0 ) ;
16809: LD_INT 4
16811: PPUSH
16812: LD_INT 1
16814: PPUSH
16815: LD_INT 2
16817: PPUSH
16818: LD_INT 4
16820: PPUSH
16821: LD_INT 2
16823: PPUSH
16824: LD_INT 1
16826: PPUSH
16827: LD_INT 0
16829: PPUSH
16830: LD_INT 19
16832: PPUSH
16833: LD_INT 0
16835: PPUSH
16836: CALL 84645 0 9
// PrepareNature ( 0 , 0 , 0 , 0 , 0 , 0 , 9 , 0 , natureWaterArea ) ;
16840: LD_INT 0
16842: PPUSH
16843: LD_INT 0
16845: PPUSH
16846: LD_INT 0
16848: PPUSH
16849: LD_INT 0
16851: PPUSH
16852: LD_INT 0
16854: PPUSH
16855: LD_INT 0
16857: PPUSH
16858: LD_INT 9
16860: PPUSH
16861: LD_INT 0
16863: PPUSH
16864: LD_INT 20
16866: PPUSH
16867: CALL 84645 0 9
// end ; end_of_file
16871: LD_VAR 0 1
16875: RET
// every 0 0$30 do var time ;
16876: GO 16878
16878: DISABLE
16879: LD_INT 0
16881: PPUSH
// begin time := 0 0$50 ;
16882: LD_ADDR_VAR 0 1
16886: PUSH
16887: LD_INT 1750
16889: ST_TO_ADDR
// repeat wait ( time ) ;
16890: LD_VAR 0 1
16894: PPUSH
16895: CALL_OW 67
// if Prob ( 50 ) then
16899: LD_INT 50
16901: PPUSH
16902: CALL_OW 13
16906: IFFALSE 16935
// CreateCratesXYR ( rand ( 1 , 5 ) , 106 , 89 , 45 , true ) ;
16908: LD_INT 1
16910: PPUSH
16911: LD_INT 5
16913: PPUSH
16914: CALL_OW 12
16918: PPUSH
16919: LD_INT 106
16921: PPUSH
16922: LD_INT 89
16924: PPUSH
16925: LD_INT 45
16927: PPUSH
16928: LD_INT 1
16930: PPUSH
16931: CALL_OW 56
// time := time + 0 0$3 ;
16935: LD_ADDR_VAR 0 1
16939: PUSH
16940: LD_VAR 0 1
16944: PUSH
16945: LD_INT 105
16947: PLUS
16948: ST_TO_ADDR
// if Prob ( 30 ) then
16949: LD_INT 30
16951: PPUSH
16952: CALL_OW 13
16956: IFFALSE 17002
// begin wait ( rand ( 0 0$15 , 0 0$21 ) ) ;
16958: LD_INT 525
16960: PPUSH
16961: LD_INT 735
16963: PPUSH
16964: CALL_OW 12
16968: PPUSH
16969: CALL_OW 67
// CreateCratesXYR ( rand ( 1 , 5 ) , 21 , 26 , 12 , true ) ;
16973: LD_INT 1
16975: PPUSH
16976: LD_INT 5
16978: PPUSH
16979: CALL_OW 12
16983: PPUSH
16984: LD_INT 21
16986: PPUSH
16987: LD_INT 26
16989: PPUSH
16990: LD_INT 12
16992: PPUSH
16993: LD_INT 1
16995: PPUSH
16996: CALL_OW 56
// end else
17000: GO 17038
// begin wait ( rand ( 0 0$20 , 0 0$35 ) ) ;
17002: LD_INT 700
17004: PPUSH
17005: LD_INT 1225
17007: PPUSH
17008: CALL_OW 12
17012: PPUSH
17013: CALL_OW 67
// CreateCratesArea ( rand ( 1 , 5 ) , russianCratesArea , true ) ;
17017: LD_INT 1
17019: PPUSH
17020: LD_INT 5
17022: PPUSH
17023: CALL_OW 12
17027: PPUSH
17028: LD_INT 14
17030: PPUSH
17031: LD_INT 1
17033: PPUSH
17034: CALL_OW 55
// end ; if Prob ( 50 ) then
17038: LD_INT 50
17040: PPUSH
17041: CALL_OW 13
17045: IFFALSE 17091
// begin wait ( rand ( 0 0$20 , 0 0$30 ) ) ;
17047: LD_INT 700
17049: PPUSH
17050: LD_INT 1050
17052: PPUSH
17053: CALL_OW 12
17057: PPUSH
17058: CALL_OW 67
// CreateCratesXYR ( rand ( 1 , 5 ) , 181 , 218 , 16 , true ) ;
17062: LD_INT 1
17064: PPUSH
17065: LD_INT 5
17067: PPUSH
17068: CALL_OW 12
17072: PPUSH
17073: LD_INT 181
17075: PPUSH
17076: LD_INT 218
17078: PPUSH
17079: LD_INT 16
17081: PPUSH
17082: LD_INT 1
17084: PPUSH
17085: CALL_OW 56
// end else
17089: GO 17163
// begin wait ( rand ( 0 0$10 , 0 0$15 ) ) ;
17091: LD_INT 350
17093: PPUSH
17094: LD_INT 525
17096: PPUSH
17097: CALL_OW 12
17101: PPUSH
17102: CALL_OW 67
// CreateCratesArea ( rand ( 1 , 5 ) , legionCratesArea , true ) ;
17106: LD_INT 1
17108: PPUSH
17109: LD_INT 5
17111: PPUSH
17112: CALL_OW 12
17116: PPUSH
17117: LD_INT 13
17119: PPUSH
17120: LD_INT 1
17122: PPUSH
17123: CALL_OW 55
// wait ( rand ( 0 0$10 , 0 0$20 ) ) ;
17127: LD_INT 350
17129: PPUSH
17130: LD_INT 700
17132: PPUSH
17133: CALL_OW 12
17137: PPUSH
17138: CALL_OW 67
// CreateCratesArea ( rand ( 1 , 5 ) , americanCratesArea , true ) ;
17142: LD_INT 1
17144: PPUSH
17145: LD_INT 5
17147: PPUSH
17148: CALL_OW 12
17152: PPUSH
17153: LD_INT 33
17155: PPUSH
17156: LD_INT 1
17158: PPUSH
17159: CALL_OW 55
// end ; if Prob ( [ 65 , 62 , 55 ] [ Difficulty ] ) then
17163: LD_INT 65
17165: PUSH
17166: LD_INT 62
17168: PUSH
17169: LD_INT 55
17171: PUSH
17172: EMPTY
17173: LIST
17174: LIST
17175: LIST
17176: PUSH
17177: LD_OWVAR 67
17181: ARRAY
17182: PPUSH
17183: CALL_OW 13
17187: IFFALSE 17233
// begin wait ( rand ( 0 0$15 , 0 0$25 ) ) ;
17189: LD_INT 525
17191: PPUSH
17192: LD_INT 875
17194: PPUSH
17195: CALL_OW 12
17199: PPUSH
17200: CALL_OW 67
// CreateCratesXYR ( rand ( 1 , 5 ) , 294 , 211 , 30 , true ) ;
17204: LD_INT 1
17206: PPUSH
17207: LD_INT 5
17209: PPUSH
17210: CALL_OW 12
17214: PPUSH
17215: LD_INT 294
17217: PPUSH
17218: LD_INT 211
17220: PPUSH
17221: LD_INT 30
17223: PPUSH
17224: LD_INT 1
17226: PPUSH
17227: CALL_OW 56
// end else
17231: GO 17275
// begin wait ( rand ( 0 0$12 , 0 0$22 ) ) ;
17233: LD_INT 420
17235: PPUSH
17236: LD_INT 770
17238: PPUSH
17239: CALL_OW 12
17243: PPUSH
17244: CALL_OW 67
// CreateCratesXYR ( rand ( 1 , 5 ) , 294 , 211 , 30 , true ) ;
17248: LD_INT 1
17250: PPUSH
17251: LD_INT 5
17253: PPUSH
17254: CALL_OW 12
17258: PPUSH
17259: LD_INT 294
17261: PPUSH
17262: LD_INT 211
17264: PPUSH
17265: LD_INT 30
17267: PPUSH
17268: LD_INT 1
17270: PPUSH
17271: CALL_OW 56
// end ; if time > 2 2$20 then
17275: LD_VAR 0 1
17279: PUSH
17280: LD_INT 4900
17282: GREATER
17283: IFFALSE 17293
// time := 0 0$50 ;
17285: LD_ADDR_VAR 0 1
17289: PUSH
17290: LD_INT 1750
17292: ST_TO_ADDR
// until false ;
17293: LD_INT 0
17295: IFFALSE 16890
// end ;
17297: PPOPN 1
17299: END
// every 0 0$45 trigger tick < 10 10$00 do
17300: LD_OWVAR 1
17304: PUSH
17305: LD_INT 21000
17307: LESS
17308: IFFALSE 17356
17310: GO 17312
17312: DISABLE
// begin enable ;
17313: ENABLE
// wait ( rand ( 0 0$10 , 0 0$20 ) ) ;
17314: LD_INT 350
17316: PPUSH
17317: LD_INT 700
17319: PPUSH
17320: CALL_OW 12
17324: PPUSH
17325: CALL_OW 67
// CreateCratesXYR ( rand ( 3 , 5 ) , 181 , 13 , 20 , true ) ;
17329: LD_INT 3
17331: PPUSH
17332: LD_INT 5
17334: PPUSH
17335: CALL_OW 12
17339: PPUSH
17340: LD_INT 181
17342: PPUSH
17343: LD_INT 13
17345: PPUSH
17346: LD_INT 20
17348: PPUSH
17349: LD_INT 1
17351: PPUSH
17352: CALL_OW 56
// end ; end_of_file
17356: END
// export artifactsPos , artifactsRecharge , artifactsSibCost , artifactsResearched , artifactsLabsWorking ; export artifactsResDifficulty , artifactsResProgress , artifactsLabs , artifactsButtons , artifactsReady ; export function InitArtifact ; begin
17357: LD_INT 0
17359: PPUSH
// SetArtifactRes ( 7 , true ) ;
17360: LD_INT 7
17362: PPUSH
17363: LD_INT 1
17365: PPUSH
17366: CALL_OW 467
// artifactsPos := [ [ ] , [ ] , [ ] ] ;
17370: LD_ADDR_EXP 57
17374: PUSH
17375: EMPTY
17376: PUSH
17377: EMPTY
17378: PUSH
17379: EMPTY
17380: PUSH
17381: EMPTY
17382: LIST
17383: LIST
17384: LIST
17385: ST_TO_ADDR
// artifactsRecharge := [ 0 0$30 * Difficulty , 1 1$20 * Difficulty , - 1 ] ;
17386: LD_ADDR_EXP 58
17390: PUSH
17391: LD_INT 1050
17393: PUSH
17394: LD_OWVAR 67
17398: MUL
17399: PUSH
17400: LD_INT 2800
17402: PUSH
17403: LD_OWVAR 67
17407: MUL
17408: PUSH
17409: LD_INT 1
17411: NEG
17412: PUSH
17413: EMPTY
17414: LIST
17415: LIST
17416: LIST
17417: ST_TO_ADDR
// artifactsSibCost := [ 10 , 35 , 100 ] ;
17418: LD_ADDR_EXP 59
17422: PUSH
17423: LD_INT 10
17425: PUSH
17426: LD_INT 35
17428: PUSH
17429: LD_INT 100
17431: PUSH
17432: EMPTY
17433: LIST
17434: LIST
17435: LIST
17436: ST_TO_ADDR
// artifactsResearched := [ 0 , 0 , 0 ] ;
17437: LD_ADDR_EXP 60
17441: PUSH
17442: LD_INT 0
17444: PUSH
17445: LD_INT 0
17447: PUSH
17448: LD_INT 0
17450: PUSH
17451: EMPTY
17452: LIST
17453: LIST
17454: LIST
17455: ST_TO_ADDR
// artifactsResDifficulty := [ 300 , 500 , 800 ] ;
17456: LD_ADDR_EXP 62
17460: PUSH
17461: LD_INT 300
17463: PUSH
17464: LD_INT 500
17466: PUSH
17467: LD_INT 800
17469: PUSH
17470: EMPTY
17471: LIST
17472: LIST
17473: LIST
17474: ST_TO_ADDR
// artifactsResProgress := [ 0 , 0 , 0 ] ;
17475: LD_ADDR_EXP 63
17479: PUSH
17480: LD_INT 0
17482: PUSH
17483: LD_INT 0
17485: PUSH
17486: LD_INT 0
17488: PUSH
17489: EMPTY
17490: LIST
17491: LIST
17492: LIST
17493: ST_TO_ADDR
// artifactsLabs := [ 0 , 0 , 0 ] ;
17494: LD_ADDR_EXP 64
17498: PUSH
17499: LD_INT 0
17501: PUSH
17502: LD_INT 0
17504: PUSH
17505: LD_INT 0
17507: PUSH
17508: EMPTY
17509: LIST
17510: LIST
17511: LIST
17512: ST_TO_ADDR
// artifactsLabsWorking := [ 0 , 0 , 0 ] ;
17513: LD_ADDR_EXP 61
17517: PUSH
17518: LD_INT 0
17520: PUSH
17521: LD_INT 0
17523: PUSH
17524: LD_INT 0
17526: PUSH
17527: EMPTY
17528: LIST
17529: LIST
17530: LIST
17531: ST_TO_ADDR
// artifactsButtons := [ [ art_use_eye , art_place , art_exp_left ] , [ art_use_sibexplosion , art_unit , art_exp_mid ] , [ art_use_teleport , art_place , art_exp_right ] ] ;
17532: LD_ADDR_EXP 65
17536: PUSH
17537: LD_INT 4
17539: PUSH
17540: LD_INT 3
17542: PUSH
17543: LD_INT 1
17545: PUSH
17546: EMPTY
17547: LIST
17548: LIST
17549: LIST
17550: PUSH
17551: LD_INT 5
17553: PUSH
17554: LD_INT 4
17556: PUSH
17557: LD_INT 2
17559: PUSH
17560: EMPTY
17561: LIST
17562: LIST
17563: LIST
17564: PUSH
17565: LD_INT 6
17567: PUSH
17568: LD_INT 3
17570: PUSH
17571: LD_INT 3
17573: PUSH
17574: EMPTY
17575: LIST
17576: LIST
17577: LIST
17578: PUSH
17579: EMPTY
17580: LIST
17581: LIST
17582: LIST
17583: ST_TO_ADDR
// artifactsReady := [ 0 , 0 , 0 ] ;
17584: LD_ADDR_EXP 66
17588: PUSH
17589: LD_INT 0
17591: PUSH
17592: LD_INT 0
17594: PUSH
17595: LD_INT 0
17597: PUSH
17598: EMPTY
17599: LIST
17600: LIST
17601: LIST
17602: ST_TO_ADDR
// end ;
17603: LD_VAR 0 1
17607: RET
// every 0 0$1 trigger GetTech ( tech_artifact , 7 ) = state_researched do var i , pos , j , labs , nearestLab ;
17608: LD_INT 24
17610: PPUSH
17611: LD_INT 7
17613: PPUSH
17614: CALL_OW 321
17618: PUSH
17619: LD_INT 2
17621: EQUAL
17622: IFFALSE 18548
17624: GO 17626
17626: DISABLE
17627: LD_INT 0
17629: PPUSH
17630: PPUSH
17631: PPUSH
17632: PPUSH
17633: PPUSH
// begin enable ;
17634: ENABLE
// for i = 1 to 3 do
17635: LD_ADDR_VAR 0 1
17639: PUSH
17640: DOUBLE
17641: LD_INT 1
17643: DEC
17644: ST_TO_ADDR
17645: LD_INT 3
17647: PUSH
17648: FOR_TO
17649: IFFALSE 18546
// begin pos := FindArtifact ( i + 2 ) ;
17651: LD_ADDR_VAR 0 2
17655: PUSH
17656: LD_VAR 0 1
17660: PUSH
17661: LD_INT 2
17663: PLUS
17664: PPUSH
17665: CALL_OW 469
17669: ST_TO_ADDR
// artifactsPos := Replace ( artifactsPos , i , pos ) ;
17670: LD_ADDR_EXP 57
17674: PUSH
17675: LD_EXP 57
17679: PPUSH
17680: LD_VAR 0 1
17684: PPUSH
17685: LD_VAR 0 2
17689: PPUSH
17690: CALL_OW 1
17694: ST_TO_ADDR
// if pos then
17695: LD_VAR 0 2
17699: IFFALSE 18407
// begin case i of 1 :
17701: LD_VAR 0 1
17705: PUSH
17706: LD_INT 1
17708: DOUBLE
17709: EQUAL
17710: IFTRUE 17714
17712: GO 17791
17714: POP
// labs := FilterAllUnits ( [ [ f_side , 7 ] , [ f_nation , 1 ] , [ f_or , [ f_btype , b_lab_full ] , [ f_btype , b_lab_half ] , [ f_btype , b_lab_siberium ] ] ] ) ; 2 :
17715: LD_ADDR_VAR 0 4
17719: PUSH
17720: LD_INT 22
17722: PUSH
17723: LD_INT 7
17725: PUSH
17726: EMPTY
17727: LIST
17728: LIST
17729: PUSH
17730: LD_INT 23
17732: PUSH
17733: LD_INT 1
17735: PUSH
17736: EMPTY
17737: LIST
17738: LIST
17739: PUSH
17740: LD_INT 2
17742: PUSH
17743: LD_INT 30
17745: PUSH
17746: LD_INT 8
17748: PUSH
17749: EMPTY
17750: LIST
17751: LIST
17752: PUSH
17753: LD_INT 30
17755: PUSH
17756: LD_INT 7
17758: PUSH
17759: EMPTY
17760: LIST
17761: LIST
17762: PUSH
17763: LD_INT 30
17765: PUSH
17766: LD_INT 11
17768: PUSH
17769: EMPTY
17770: LIST
17771: LIST
17772: PUSH
17773: EMPTY
17774: LIST
17775: LIST
17776: LIST
17777: LIST
17778: PUSH
17779: EMPTY
17780: LIST
17781: LIST
17782: LIST
17783: PPUSH
17784: CALL_OW 69
17788: ST_TO_ADDR
17789: GO 17899
17791: LD_INT 2
17793: DOUBLE
17794: EQUAL
17795: IFTRUE 17799
17797: GO 17876
17799: POP
// labs := FilterAllUnits ( [ [ f_side , 7 ] , [ f_nation , 3 ] , [ f_or , [ f_btype , b_lab_full ] , [ f_btype , b_lab_half ] , [ f_btype , b_lab_siberium ] ] ] ) ; 3 :
17800: LD_ADDR_VAR 0 4
17804: PUSH
17805: LD_INT 22
17807: PUSH
17808: LD_INT 7
17810: PUSH
17811: EMPTY
17812: LIST
17813: LIST
17814: PUSH
17815: LD_INT 23
17817: PUSH
17818: LD_INT 3
17820: PUSH
17821: EMPTY
17822: LIST
17823: LIST
17824: PUSH
17825: LD_INT 2
17827: PUSH
17828: LD_INT 30
17830: PUSH
17831: LD_INT 8
17833: PUSH
17834: EMPTY
17835: LIST
17836: LIST
17837: PUSH
17838: LD_INT 30
17840: PUSH
17841: LD_INT 7
17843: PUSH
17844: EMPTY
17845: LIST
17846: LIST
17847: PUSH
17848: LD_INT 30
17850: PUSH
17851: LD_INT 11
17853: PUSH
17854: EMPTY
17855: LIST
17856: LIST
17857: PUSH
17858: EMPTY
17859: LIST
17860: LIST
17861: LIST
17862: LIST
17863: PUSH
17864: EMPTY
17865: LIST
17866: LIST
17867: LIST
17868: PPUSH
17869: CALL_OW 69
17873: ST_TO_ADDR
17874: GO 17899
17876: LD_INT 3
17878: DOUBLE
17879: EQUAL
17880: IFTRUE 17884
17882: GO 17898
17884: POP
// labs := [ alien ] ; end ;
17885: LD_ADDR_VAR 0 4
17889: PUSH
17890: LD_INT 1
17892: PUSH
17893: EMPTY
17894: LIST
17895: ST_TO_ADDR
17896: GO 17899
17898: POP
// if not labs then
17899: LD_VAR 0 4
17903: NOT
17904: IFFALSE 17908
// continue ;
17906: GO 17648
// nearestLab := NearestUnitToXY ( labs , artifactsPos [ i ] [ 1 ] , artifactsPos [ i ] [ 2 ] ) ;
17908: LD_ADDR_VAR 0 5
17912: PUSH
17913: LD_VAR 0 4
17917: PPUSH
17918: LD_EXP 57
17922: PUSH
17923: LD_VAR 0 1
17927: ARRAY
17928: PUSH
17929: LD_INT 1
17931: ARRAY
17932: PPUSH
17933: LD_EXP 57
17937: PUSH
17938: LD_VAR 0 1
17942: ARRAY
17943: PUSH
17944: LD_INT 2
17946: ARRAY
17947: PPUSH
17948: CALL_OW 73
17952: ST_TO_ADDR
// if not nearestLab or nearestLab <> artifactsLabs [ i ] then
17953: LD_VAR 0 5
17957: NOT
17958: PUSH
17959: LD_VAR 0 5
17963: PUSH
17964: LD_EXP 64
17968: PUSH
17969: LD_VAR 0 1
17973: ARRAY
17974: NONEQUAL
17975: OR
17976: IFFALSE 18081
// begin SetArtifactUse ( 7 , artifactsButtons [ i ] [ 3 ] , art_no , artifactsLabs [ i ] ) ;
17978: LD_INT 7
17980: PPUSH
17981: LD_EXP 65
17985: PUSH
17986: LD_VAR 0 1
17990: ARRAY
17991: PUSH
17992: LD_INT 3
17994: ARRAY
17995: PPUSH
17996: LD_INT 0
17998: PPUSH
17999: LD_EXP 64
18003: PUSH
18004: LD_VAR 0 1
18008: ARRAY
18009: PPUSH
18010: CALL_OW 468
// SetArtifactUse ( 7 , artifactsButtons [ i ] [ 1 ] , art_no , artifactsLabs [ i ] ) ;
18014: LD_INT 7
18016: PPUSH
18017: LD_EXP 65
18021: PUSH
18022: LD_VAR 0 1
18026: ARRAY
18027: PUSH
18028: LD_INT 1
18030: ARRAY
18031: PPUSH
18032: LD_INT 0
18034: PPUSH
18035: LD_EXP 64
18039: PUSH
18040: LD_VAR 0 1
18044: ARRAY
18045: PPUSH
18046: CALL_OW 468
// if nearestLab then
18050: LD_VAR 0 5
18054: IFFALSE 18081
// artifactsLabs := Replace ( artifactsLabs , i , nearestLab ) ;
18056: LD_ADDR_EXP 64
18060: PUSH
18061: LD_EXP 64
18065: PPUSH
18066: LD_VAR 0 1
18070: PPUSH
18071: LD_VAR 0 5
18075: PPUSH
18076: CALL_OW 1
18080: ST_TO_ADDR
// end ; if not nearestLab then
18081: LD_VAR 0 5
18085: NOT
18086: IFFALSE 18090
// continue ;
18088: GO 17648
// if GetDistUnitXY ( nearestLab , artifactsPos [ i ] [ 1 ] , artifactsPos [ i ] [ 2 ] ) < 8 then
18090: LD_VAR 0 5
18094: PPUSH
18095: LD_EXP 57
18099: PUSH
18100: LD_VAR 0 1
18104: ARRAY
18105: PUSH
18106: LD_INT 1
18108: ARRAY
18109: PPUSH
18110: LD_EXP 57
18114: PUSH
18115: LD_VAR 0 1
18119: ARRAY
18120: PUSH
18121: LD_INT 2
18123: ARRAY
18124: PPUSH
18125: CALL_OW 297
18129: PUSH
18130: LD_INT 8
18132: LESS
18133: IFFALSE 18330
// begin if not artifactsResearched [ i ] then
18135: LD_EXP 60
18139: PUSH
18140: LD_VAR 0 1
18144: ARRAY
18145: NOT
18146: IFFALSE 18227
// begin if BuildingStatus ( nearestLab ) = bs_idle then
18148: LD_VAR 0 5
18152: PPUSH
18153: CALL_OW 461
18157: PUSH
18158: LD_INT 2
18160: EQUAL
18161: IFFALSE 18195
// SetArtifactUse ( 7 , artifactsButtons [ i ] [ 3 ] , art_instant , nearestLab ) else
18163: LD_INT 7
18165: PPUSH
18166: LD_EXP 65
18170: PUSH
18171: LD_VAR 0 1
18175: ARRAY
18176: PUSH
18177: LD_INT 3
18179: ARRAY
18180: PPUSH
18181: LD_INT 2
18183: PPUSH
18184: LD_VAR 0 5
18188: PPUSH
18189: CALL_OW 468
18193: GO 18225
// SetArtifactUse ( 7 , artifactsButtons [ i ] [ 3 ] , art_gray , nearestLab ) ;
18195: LD_INT 7
18197: PPUSH
18198: LD_EXP 65
18202: PUSH
18203: LD_VAR 0 1
18207: ARRAY
18208: PUSH
18209: LD_INT 3
18211: ARRAY
18212: PPUSH
18213: LD_INT 1
18215: PPUSH
18216: LD_VAR 0 5
18220: PPUSH
18221: CALL_OW 468
// end else
18225: GO 18328
// begin if BuildingStatus ( nearestLab ) = bs_idle and artifactsReady [ i ] then
18227: LD_VAR 0 5
18231: PPUSH
18232: CALL_OW 461
18236: PUSH
18237: LD_INT 2
18239: EQUAL
18240: PUSH
18241: LD_EXP 66
18245: PUSH
18246: LD_VAR 0 1
18250: ARRAY
18251: AND
18252: IFFALSE 18298
// SetArtifactUse ( 7 , artifactsButtons [ i ] [ 1 ] , artifactsButtons [ i ] [ 2 ] , nearestLab ) else
18254: LD_INT 7
18256: PPUSH
18257: LD_EXP 65
18261: PUSH
18262: LD_VAR 0 1
18266: ARRAY
18267: PUSH
18268: LD_INT 1
18270: ARRAY
18271: PPUSH
18272: LD_EXP 65
18276: PUSH
18277: LD_VAR 0 1
18281: ARRAY
18282: PUSH
18283: LD_INT 2
18285: ARRAY
18286: PPUSH
18287: LD_VAR 0 5
18291: PPUSH
18292: CALL_OW 468
18296: GO 18328
// SetArtifactUse ( 7 , artifactsButtons [ i ] [ 1 ] , art_gray , nearestLab ) end ;
18298: LD_INT 7
18300: PPUSH
18301: LD_EXP 65
18305: PUSH
18306: LD_VAR 0 1
18310: ARRAY
18311: PUSH
18312: LD_INT 1
18314: ARRAY
18315: PPUSH
18316: LD_INT 1
18318: PPUSH
18319: LD_VAR 0 5
18323: PPUSH
18324: CALL_OW 468
// end else
18328: GO 18405
// begin if not artifactsResearched [ i ] then
18330: LD_EXP 60
18334: PUSH
18335: LD_VAR 0 1
18339: ARRAY
18340: NOT
18341: IFFALSE 18375
// SetArtifactUse ( 7 , artifactsButtons [ i ] [ 3 ] , art_no , nearestLab ) else
18343: LD_INT 7
18345: PPUSH
18346: LD_EXP 65
18350: PUSH
18351: LD_VAR 0 1
18355: ARRAY
18356: PUSH
18357: LD_INT 3
18359: ARRAY
18360: PPUSH
18361: LD_INT 0
18363: PPUSH
18364: LD_VAR 0 5
18368: PPUSH
18369: CALL_OW 468
18373: GO 18405
// SetArtifactUse ( 7 , artifactsButtons [ i ] [ 1 ] , art_no , nearestLab ) ;
18375: LD_INT 7
18377: PPUSH
18378: LD_EXP 65
18382: PUSH
18383: LD_VAR 0 1
18387: ARRAY
18388: PUSH
18389: LD_INT 1
18391: ARRAY
18392: PPUSH
18393: LD_INT 0
18395: PPUSH
18396: LD_VAR 0 5
18400: PPUSH
18401: CALL_OW 468
// end ; end else
18405: GO 18544
// begin if not artifactsLabs [ i ] then
18407: LD_EXP 64
18411: PUSH
18412: LD_VAR 0 1
18416: ARRAY
18417: NOT
18418: IFFALSE 18422
// continue ;
18420: GO 17648
// SetArtifactUse ( 7 , artifactsButtons [ i ] [ 3 ] , art_no , artifactsLabs [ i ] ) ;
18422: LD_INT 7
18424: PPUSH
18425: LD_EXP 65
18429: PUSH
18430: LD_VAR 0 1
18434: ARRAY
18435: PUSH
18436: LD_INT 3
18438: ARRAY
18439: PPUSH
18440: LD_INT 0
18442: PPUSH
18443: LD_EXP 64
18447: PUSH
18448: LD_VAR 0 1
18452: ARRAY
18453: PPUSH
18454: CALL_OW 468
// SetArtifactUse ( 7 , artifactsButtons [ i ] [ 1 ] , art_no , artifactsLabs [ i ] ) ;
18458: LD_INT 7
18460: PPUSH
18461: LD_EXP 65
18465: PUSH
18466: LD_VAR 0 1
18470: ARRAY
18471: PUSH
18472: LD_INT 1
18474: ARRAY
18475: PPUSH
18476: LD_INT 0
18478: PPUSH
18479: LD_EXP 64
18483: PUSH
18484: LD_VAR 0 1
18488: ARRAY
18489: PPUSH
18490: CALL_OW 468
// if artifactsLabsWorking [ i ] then
18494: LD_EXP 61
18498: PUSH
18499: LD_VAR 0 1
18503: ARRAY
18504: IFFALSE 18544
// begin artifactsLabsWorking := Replace ( artifactsLabsWorking , i , false ) ;
18506: LD_ADDR_EXP 61
18510: PUSH
18511: LD_EXP 61
18515: PPUSH
18516: LD_VAR 0 1
18520: PPUSH
18521: LD_INT 0
18523: PPUSH
18524: CALL_OW 1
18528: ST_TO_ADDR
// ComCancel ( artifactsLabs [ i ] ) ;
18529: LD_EXP 64
18533: PUSH
18534: LD_VAR 0 1
18538: ARRAY
18539: PPUSH
18540: CALL_OW 127
// end ; end ; end ;
18544: GO 17648
18546: POP
18547: POP
// end ;
18548: PPOPN 5
18550: END
// on ArtifactUsed ( side , icon , x , y ) do var i , lab , time , list , un ;
18551: LD_INT 0
18553: PPUSH
18554: PPUSH
18555: PPUSH
18556: PPUSH
18557: PPUSH
// begin if icon = artifactsButtons [ 1 ] [ 3 ] then
18558: LD_VAR 0 2
18562: PUSH
18563: LD_EXP 65
18567: PUSH
18568: LD_INT 1
18570: ARRAY
18571: PUSH
18572: LD_INT 3
18574: ARRAY
18575: EQUAL
18576: IFFALSE 18699
// begin lab := artifactsLabs [ 1 ] ;
18578: LD_ADDR_VAR 0 6
18582: PUSH
18583: LD_EXP 64
18587: PUSH
18588: LD_INT 1
18590: ARRAY
18591: ST_TO_ADDR
// if not lab then
18592: LD_VAR 0 6
18596: NOT
18597: IFFALSE 18601
// exit ;
18599: GO 19633
// SetSpecResearch ( lab , artifactsResDifficulty [ 1 ] , true ) ;
18601: LD_VAR 0 6
18605: PPUSH
18606: LD_EXP 62
18610: PUSH
18611: LD_INT 1
18613: ARRAY
18614: PPUSH
18615: LD_INT 1
18617: PPUSH
18618: CALL_OW 486
// if artifactsResProgress [ 1 ] then
18622: LD_EXP 63
18626: PUSH
18627: LD_INT 1
18629: ARRAY
18630: IFFALSE 18650
// SetWorkingProgress ( lab , artifactsResProgress [ 1 ] ) ;
18632: LD_VAR 0 6
18636: PPUSH
18637: LD_EXP 63
18641: PUSH
18642: LD_INT 1
18644: ARRAY
18645: PPUSH
18646: CALL_OW 329
// artifactsLabsWorking := Replace ( artifactsLabsWorking , 1 , 1 ) ;
18650: LD_ADDR_EXP 61
18654: PUSH
18655: LD_EXP 61
18659: PPUSH
18660: LD_INT 1
18662: PPUSH
18663: LD_INT 1
18665: PPUSH
18666: CALL_OW 1
18670: ST_TO_ADDR
// SetArtifactUse ( 7 , artifactsButtons [ 1 ] [ 3 ] , art_no , lab ) ;
18671: LD_INT 7
18673: PPUSH
18674: LD_EXP 65
18678: PUSH
18679: LD_INT 1
18681: ARRAY
18682: PUSH
18683: LD_INT 3
18685: ARRAY
18686: PPUSH
18687: LD_INT 0
18689: PPUSH
18690: LD_VAR 0 6
18694: PPUSH
18695: CALL_OW 468
// end ; if icon = artifactsButtons [ 2 ] [ 3 ] then
18699: LD_VAR 0 2
18703: PUSH
18704: LD_EXP 65
18708: PUSH
18709: LD_INT 2
18711: ARRAY
18712: PUSH
18713: LD_INT 3
18715: ARRAY
18716: EQUAL
18717: IFFALSE 18840
// begin lab := artifactsLabs [ 2 ] ;
18719: LD_ADDR_VAR 0 6
18723: PUSH
18724: LD_EXP 64
18728: PUSH
18729: LD_INT 2
18731: ARRAY
18732: ST_TO_ADDR
// if not lab then
18733: LD_VAR 0 6
18737: NOT
18738: IFFALSE 18742
// exit ;
18740: GO 19633
// SetSpecResearch ( lab , artifactsResDifficulty [ 2 ] , true ) ;
18742: LD_VAR 0 6
18746: PPUSH
18747: LD_EXP 62
18751: PUSH
18752: LD_INT 2
18754: ARRAY
18755: PPUSH
18756: LD_INT 1
18758: PPUSH
18759: CALL_OW 486
// if artifactsResProgress [ 2 ] then
18763: LD_EXP 63
18767: PUSH
18768: LD_INT 2
18770: ARRAY
18771: IFFALSE 18791
// SetWorkingProgress ( lab , artifactsResProgress [ 2 ] ) ;
18773: LD_VAR 0 6
18777: PPUSH
18778: LD_EXP 63
18782: PUSH
18783: LD_INT 2
18785: ARRAY
18786: PPUSH
18787: CALL_OW 329
// artifactsLabsWorking := Replace ( artifactsLabsWorking , 2 , 1 ) ;
18791: LD_ADDR_EXP 61
18795: PUSH
18796: LD_EXP 61
18800: PPUSH
18801: LD_INT 2
18803: PPUSH
18804: LD_INT 1
18806: PPUSH
18807: CALL_OW 1
18811: ST_TO_ADDR
// SetArtifactUse ( 7 , artifactsButtons [ 2 ] [ 3 ] , art_no , lab ) ;
18812: LD_INT 7
18814: PPUSH
18815: LD_EXP 65
18819: PUSH
18820: LD_INT 2
18822: ARRAY
18823: PUSH
18824: LD_INT 3
18826: ARRAY
18827: PPUSH
18828: LD_INT 0
18830: PPUSH
18831: LD_VAR 0 6
18835: PPUSH
18836: CALL_OW 468
// end ; if icon = artifactsButtons [ 3 ] [ 3 ] then
18840: LD_VAR 0 2
18844: PUSH
18845: LD_EXP 65
18849: PUSH
18850: LD_INT 3
18852: ARRAY
18853: PUSH
18854: LD_INT 3
18856: ARRAY
18857: EQUAL
18858: IFFALSE 18981
// begin lab := artifactsLabs [ 3 ] ;
18860: LD_ADDR_VAR 0 6
18864: PUSH
18865: LD_EXP 64
18869: PUSH
18870: LD_INT 3
18872: ARRAY
18873: ST_TO_ADDR
// if not lab then
18874: LD_VAR 0 6
18878: NOT
18879: IFFALSE 18883
// exit ;
18881: GO 19633
// SetSpecResearch ( lab , artifactsResDifficulty [ 3 ] , true ) ;
18883: LD_VAR 0 6
18887: PPUSH
18888: LD_EXP 62
18892: PUSH
18893: LD_INT 3
18895: ARRAY
18896: PPUSH
18897: LD_INT 1
18899: PPUSH
18900: CALL_OW 486
// if artifactsResProgress [ 3 ] then
18904: LD_EXP 63
18908: PUSH
18909: LD_INT 3
18911: ARRAY
18912: IFFALSE 18932
// SetWorkingProgress ( lab , artifactsResProgress [ 3 ] ) ;
18914: LD_VAR 0 6
18918: PPUSH
18919: LD_EXP 63
18923: PUSH
18924: LD_INT 3
18926: ARRAY
18927: PPUSH
18928: CALL_OW 329
// artifactsLabsWorking := Replace ( artifactsLabsWorking , 3 , 1 ) ;
18932: LD_ADDR_EXP 61
18936: PUSH
18937: LD_EXP 61
18941: PPUSH
18942: LD_INT 3
18944: PPUSH
18945: LD_INT 1
18947: PPUSH
18948: CALL_OW 1
18952: ST_TO_ADDR
// SetArtifactUse ( 7 , artifactsButtons [ 3 ] [ 3 ] , art_no , lab ) ;
18953: LD_INT 7
18955: PPUSH
18956: LD_EXP 65
18960: PUSH
18961: LD_INT 3
18963: ARRAY
18964: PUSH
18965: LD_INT 3
18967: ARRAY
18968: PPUSH
18969: LD_INT 0
18971: PPUSH
18972: LD_VAR 0 6
18976: PPUSH
18977: CALL_OW 468
// end ; if icon = artifactsButtons [ 1 ] [ 1 ] then
18981: LD_VAR 0 2
18985: PUSH
18986: LD_EXP 65
18990: PUSH
18991: LD_INT 1
18993: ARRAY
18994: PUSH
18995: LD_INT 1
18997: ARRAY
18998: EQUAL
18999: IFFALSE 19157
// begin lab := artifactsLabs [ 1 ] ;
19001: LD_ADDR_VAR 0 6
19005: PUSH
19006: LD_EXP 64
19010: PUSH
19011: LD_INT 1
19013: ARRAY
19014: ST_TO_ADDR
// if GetBaseMaterials ( GetBase ( lab ) ) [ 3 ] < artifactsSibCost [ 1 ] then
19015: LD_VAR 0 6
19019: PPUSH
19020: CALL_OW 274
19024: PPUSH
19025: CALL 92793 0 1
19029: PUSH
19030: LD_INT 3
19032: ARRAY
19033: PUSH
19034: LD_EXP 59
19038: PUSH
19039: LD_INT 1
19041: ARRAY
19042: LESS
19043: IFFALSE 19057
// begin HintSpec ( ArtifactCost , 2 ) ;
19045: LD_STRING ArtifactCost
19047: PPUSH
19048: LD_INT 2
19050: PPUSH
19051: CALL_OW 338
// exit ;
19055: GO 19633
// end ; artifactsReady := Replace ( artifactsReady , 1 , false ) ;
19057: LD_ADDR_EXP 66
19061: PUSH
19062: LD_EXP 66
19066: PPUSH
19067: LD_INT 1
19069: PPUSH
19070: LD_INT 0
19072: PPUSH
19073: CALL_OW 1
19077: ST_TO_ADDR
// PlaceSeeing ( x , y , 7 , - 12 ) ;
19078: LD_VAR 0 3
19082: PPUSH
19083: LD_VAR 0 4
19087: PPUSH
19088: LD_INT 7
19090: PPUSH
19091: LD_INT 12
19093: NEG
19094: PPUSH
19095: CALL_OW 330
// wait ( 0 0$30 ) ;
19099: LD_INT 1050
19101: PPUSH
19102: CALL_OW 67
// RemoveSeeing ( x , y , 7 ) ;
19106: LD_VAR 0 3
19110: PPUSH
19111: LD_VAR 0 4
19115: PPUSH
19116: LD_INT 7
19118: PPUSH
19119: CALL_OW 331
// wait ( artifactsRecharge [ 1 ] ) ;
19123: LD_EXP 58
19127: PUSH
19128: LD_INT 1
19130: ARRAY
19131: PPUSH
19132: CALL_OW 67
// artifactsReady := Replace ( artifactsReady , 1 , true ) ;
19136: LD_ADDR_EXP 66
19140: PUSH
19141: LD_EXP 66
19145: PPUSH
19146: LD_INT 1
19148: PPUSH
19149: LD_INT 1
19151: PPUSH
19152: CALL_OW 1
19156: ST_TO_ADDR
// end ; if icon = artifactsButtons [ 2 ] [ 1 ] then
19157: LD_VAR 0 2
19161: PUSH
19162: LD_EXP 65
19166: PUSH
19167: LD_INT 2
19169: ARRAY
19170: PUSH
19171: LD_INT 1
19173: ARRAY
19174: EQUAL
19175: IFFALSE 19387
// begin lab := artifactsLabs [ 2 ] ;
19177: LD_ADDR_VAR 0 6
19181: PUSH
19182: LD_EXP 64
19186: PUSH
19187: LD_INT 2
19189: ARRAY
19190: ST_TO_ADDR
// if not x in FilterAllUnits ( [ [ f_enemy , 7 ] , [ f_or , [ f_engine , engine_siberite ] , [ f_btype , b_siberite_power ] , [ f_btype , b_siberite_mine ] , [ f_bweapon , ru_time_lapser ] , [ f_weapon , ru_time_lapser ] ] ] ) then
19191: LD_VAR 0 3
19195: PUSH
19196: LD_INT 81
19198: PUSH
19199: LD_INT 7
19201: PUSH
19202: EMPTY
19203: LIST
19204: LIST
19205: PUSH
19206: LD_INT 2
19208: PUSH
19209: LD_INT 32
19211: PUSH
19212: LD_INT 3
19214: PUSH
19215: EMPTY
19216: LIST
19217: LIST
19218: PUSH
19219: LD_INT 30
19221: PUSH
19222: LD_INT 28
19224: PUSH
19225: EMPTY
19226: LIST
19227: LIST
19228: PUSH
19229: LD_INT 30
19231: PUSH
19232: LD_INT 30
19234: PUSH
19235: EMPTY
19236: LIST
19237: LIST
19238: PUSH
19239: LD_INT 35
19241: PUSH
19242: LD_INT 49
19244: PUSH
19245: EMPTY
19246: LIST
19247: LIST
19248: PUSH
19249: LD_INT 34
19251: PUSH
19252: LD_INT 49
19254: PUSH
19255: EMPTY
19256: LIST
19257: LIST
19258: PUSH
19259: EMPTY
19260: LIST
19261: LIST
19262: LIST
19263: LIST
19264: LIST
19265: LIST
19266: PUSH
19267: EMPTY
19268: LIST
19269: LIST
19270: PPUSH
19271: CALL_OW 69
19275: IN
19276: NOT
19277: IFFALSE 19281
// exit ;
19279: GO 19633
// if GetBaseMaterials ( GetBase ( lab ) ) [ 3 ] < artifactsSibCost [ 2 ] then
19281: LD_VAR 0 6
19285: PPUSH
19286: CALL_OW 274
19290: PPUSH
19291: CALL 92793 0 1
19295: PUSH
19296: LD_INT 3
19298: ARRAY
19299: PUSH
19300: LD_EXP 59
19304: PUSH
19305: LD_INT 2
19307: ARRAY
19308: LESS
19309: IFFALSE 19323
// begin HintSpec ( ArtifactCost , 2 ) ;
19311: LD_STRING ArtifactCost
19313: PPUSH
19314: LD_INT 2
19316: PPUSH
19317: CALL_OW 338
// exit ;
19321: GO 19633
// end ; artifactsReady := Replace ( artifactsReady , 2 , false ) ;
19323: LD_ADDR_EXP 66
19327: PUSH
19328: LD_EXP 66
19332: PPUSH
19333: LD_INT 2
19335: PPUSH
19336: LD_INT 0
19338: PPUSH
19339: CALL_OW 1
19343: ST_TO_ADDR
// KillUnit ( x ) ;
19344: LD_VAR 0 3
19348: PPUSH
19349: CALL_OW 66
// wait ( artifactsRecharge [ 2 ] ) ;
19353: LD_EXP 58
19357: PUSH
19358: LD_INT 2
19360: ARRAY
19361: PPUSH
19362: CALL_OW 67
// artifactsReady := Replace ( artifactsReady , 2 , true ) ;
19366: LD_ADDR_EXP 66
19370: PUSH
19371: LD_EXP 66
19375: PPUSH
19376: LD_INT 2
19378: PPUSH
19379: LD_INT 1
19381: PPUSH
19382: CALL_OW 1
19386: ST_TO_ADDR
// end ; if icon = artifactsButtons [ 3 ] [ 1 ] then
19387: LD_VAR 0 2
19391: PUSH
19392: LD_EXP 65
19396: PUSH
19397: LD_INT 3
19399: ARRAY
19400: PUSH
19401: LD_INT 1
19403: ARRAY
19404: EQUAL
19405: IFFALSE 19633
// begin lab := artifactsLabs [ 3 ] ;
19407: LD_ADDR_VAR 0 6
19411: PUSH
19412: LD_EXP 64
19416: PUSH
19417: LD_INT 3
19419: ARRAY
19420: ST_TO_ADDR
// if GetBaseMaterials ( GetBase ( lab ) ) [ 3 ] < artifactsSibCost [ 3 ] then
19421: LD_VAR 0 6
19425: PPUSH
19426: CALL_OW 274
19430: PPUSH
19431: CALL 92793 0 1
19435: PUSH
19436: LD_INT 3
19438: ARRAY
19439: PUSH
19440: LD_EXP 59
19444: PUSH
19445: LD_INT 3
19447: ARRAY
19448: LESS
19449: IFFALSE 19463
// begin HintSpec ( ArtifactCost , 2 ) ;
19451: LD_STRING ArtifactCost
19453: PPUSH
19454: LD_INT 2
19456: PPUSH
19457: CALL_OW 338
// exit ;
19461: GO 19633
// end ; SetAreaMapShow ( teleportArea , 1 ) ;
19463: LD_INT 37
19465: PPUSH
19466: LD_INT 1
19468: PPUSH
19469: CALL_OW 424
// time := 0 0$30 ;
19473: LD_ADDR_VAR 0 7
19477: PUSH
19478: LD_INT 1050
19480: ST_TO_ADDR
// repeat display_strings := [ Am15a-1 , time ] ;
19481: LD_ADDR_OWVAR 47
19485: PUSH
19486: LD_STRING Am15a-1
19488: PUSH
19489: LD_VAR 0 7
19493: PUSH
19494: EMPTY
19495: LIST
19496: LIST
19497: ST_TO_ADDR
// wait ( 0 0$1 ) ;
19498: LD_INT 35
19500: PPUSH
19501: CALL_OW 67
// time := time - 0 0$1 ;
19505: LD_ADDR_VAR 0 7
19509: PUSH
19510: LD_VAR 0 7
19514: PUSH
19515: LD_INT 35
19517: MINUS
19518: ST_TO_ADDR
// until time = 0 0$00 ;
19519: LD_VAR 0 7
19523: PUSH
19524: LD_INT 0
19526: EQUAL
19527: IFFALSE 19481
// display_strings :=  ;
19529: LD_ADDR_OWVAR 47
19533: PUSH
19534: LD_STRING 
19536: ST_TO_ADDR
// SetAreaMapShow ( teleportArea , 0 ) ;
19537: LD_INT 37
19539: PPUSH
19540: LD_INT 0
19542: PPUSH
19543: CALL_OW 424
// list := FilterUnitsInArea ( teleportArea , [ f_not , [ f_type , unit_building ] ] ) ;
19547: LD_ADDR_VAR 0 8
19551: PUSH
19552: LD_INT 37
19554: PPUSH
19555: LD_INT 3
19557: PUSH
19558: LD_INT 21
19560: PUSH
19561: LD_INT 3
19563: PUSH
19564: EMPTY
19565: LIST
19566: LIST
19567: PUSH
19568: EMPTY
19569: LIST
19570: LIST
19571: PPUSH
19572: CALL_OW 70
19576: ST_TO_ADDR
// CenterOnXY ( x , y ) ;
19577: LD_VAR 0 3
19581: PPUSH
19582: LD_VAR 0 4
19586: PPUSH
19587: CALL_OW 84
// for un in list do
19591: LD_ADDR_VAR 0 9
19595: PUSH
19596: LD_VAR 0 8
19600: PUSH
19601: FOR_IN
19602: IFFALSE 19631
// TeleportUnit ( un , x , y , 12 , true ) ;
19604: LD_VAR 0 9
19608: PPUSH
19609: LD_VAR 0 3
19613: PPUSH
19614: LD_VAR 0 4
19618: PPUSH
19619: LD_INT 12
19621: PPUSH
19622: LD_INT 1
19624: PPUSH
19625: CALL_OW 483
19629: GO 19601
19631: POP
19632: POP
// end ; end ;
19633: PPOPN 9
19635: END
// on SpecResearchCancel ( lab , progress ) do var i , labNum ;
19636: LD_INT 0
19638: PPUSH
19639: PPUSH
// begin labNum := 0 ;
19640: LD_ADDR_VAR 0 4
19644: PUSH
19645: LD_INT 0
19647: ST_TO_ADDR
// for i = 1 to artifactsLabs do
19648: LD_ADDR_VAR 0 3
19652: PUSH
19653: DOUBLE
19654: LD_INT 1
19656: DEC
19657: ST_TO_ADDR
19658: LD_EXP 64
19662: PUSH
19663: FOR_TO
19664: IFFALSE 19698
// if artifactsLabs [ i ] = lab then
19666: LD_EXP 64
19670: PUSH
19671: LD_VAR 0 3
19675: ARRAY
19676: PUSH
19677: LD_VAR 0 1
19681: EQUAL
19682: IFFALSE 19696
// begin labNum := i ;
19684: LD_ADDR_VAR 0 4
19688: PUSH
19689: LD_VAR 0 3
19693: ST_TO_ADDR
// break ;
19694: GO 19698
// end ;
19696: GO 19663
19698: POP
19699: POP
// if not labNum then
19700: LD_VAR 0 4
19704: NOT
19705: IFFALSE 19709
// exit ;
19707: GO 19787
// SetArtifactUse ( 7 , artifactsButtons [ labNum ] [ 3 ] , art_instant , lab ) ;
19709: LD_INT 7
19711: PPUSH
19712: LD_EXP 65
19716: PUSH
19717: LD_VAR 0 4
19721: ARRAY
19722: PUSH
19723: LD_INT 3
19725: ARRAY
19726: PPUSH
19727: LD_INT 2
19729: PPUSH
19730: LD_VAR 0 1
19734: PPUSH
19735: CALL_OW 468
// artifactsResProgress := Replace ( artifactsResProgress , labNum , progress ) ;
19739: LD_ADDR_EXP 63
19743: PUSH
19744: LD_EXP 63
19748: PPUSH
19749: LD_VAR 0 4
19753: PPUSH
19754: LD_VAR 0 2
19758: PPUSH
19759: CALL_OW 1
19763: ST_TO_ADDR
// artifactsLabsWorking := Replace ( artifactsLabsWorking , labNum , 0 ) ;
19764: LD_ADDR_EXP 61
19768: PUSH
19769: LD_EXP 61
19773: PPUSH
19774: LD_VAR 0 4
19778: PPUSH
19779: LD_INT 0
19781: PPUSH
19782: CALL_OW 1
19786: ST_TO_ADDR
// end ;
19787: PPOPN 4
19789: END
// on SpecResearchComplete ( lab ) do var i , labNum ;
19790: LD_INT 0
19792: PPUSH
19793: PPUSH
// begin labNum := 0 ;
19794: LD_ADDR_VAR 0 3
19798: PUSH
19799: LD_INT 0
19801: ST_TO_ADDR
// for i = 1 to artifactsLabs do
19802: LD_ADDR_VAR 0 2
19806: PUSH
19807: DOUBLE
19808: LD_INT 1
19810: DEC
19811: ST_TO_ADDR
19812: LD_EXP 64
19816: PUSH
19817: FOR_TO
19818: IFFALSE 19852
// if artifactsLabs [ i ] = lab then
19820: LD_EXP 64
19824: PUSH
19825: LD_VAR 0 2
19829: ARRAY
19830: PUSH
19831: LD_VAR 0 1
19835: EQUAL
19836: IFFALSE 19850
// begin labNum := i ;
19838: LD_ADDR_VAR 0 3
19842: PUSH
19843: LD_VAR 0 2
19847: ST_TO_ADDR
// break ;
19848: GO 19852
// end ;
19850: GO 19817
19852: POP
19853: POP
// if not labNum then
19854: LD_VAR 0 3
19858: NOT
19859: IFFALSE 19863
// exit ;
19861: GO 20025
// SetArtifactUse ( 7 , artifactsButtons [ labNum ] [ 3 ] , art_no , lab ) ;
19863: LD_INT 7
19865: PPUSH
19866: LD_EXP 65
19870: PUSH
19871: LD_VAR 0 3
19875: ARRAY
19876: PUSH
19877: LD_INT 3
19879: ARRAY
19880: PPUSH
19881: LD_INT 0
19883: PPUSH
19884: LD_VAR 0 1
19888: PPUSH
19889: CALL_OW 468
// artifactsResearched := Replace ( artifactsResearched , labNum , true ) ;
19893: LD_ADDR_EXP 60
19897: PUSH
19898: LD_EXP 60
19902: PPUSH
19903: LD_VAR 0 3
19907: PPUSH
19908: LD_INT 1
19910: PPUSH
19911: CALL_OW 1
19915: ST_TO_ADDR
// artifactsReady := Replace ( artifactsReady , labNum , true ) ;
19916: LD_ADDR_EXP 66
19920: PUSH
19921: LD_EXP 66
19925: PPUSH
19926: LD_VAR 0 3
19930: PPUSH
19931: LD_INT 1
19933: PPUSH
19934: CALL_OW 1
19938: ST_TO_ADDR
// artifactsLabsWorking := Replace ( artifactsLabsWorking , labNum , false ) ;
19939: LD_ADDR_EXP 61
19943: PUSH
19944: LD_EXP 61
19948: PPUSH
19949: LD_VAR 0 3
19953: PPUSH
19954: LD_INT 0
19956: PPUSH
19957: CALL_OW 1
19961: ST_TO_ADDR
// case labNum of 1 :
19962: LD_VAR 0 3
19966: PUSH
19967: LD_INT 1
19969: DOUBLE
19970: EQUAL
19971: IFTRUE 19975
19973: GO 19986
19975: POP
// artifactIResearched := true ; 2 :
19976: LD_ADDR_EXP 9
19980: PUSH
19981: LD_INT 1
19983: ST_TO_ADDR
19984: GO 20025
19986: LD_INT 2
19988: DOUBLE
19989: EQUAL
19990: IFTRUE 19994
19992: GO 20005
19994: POP
// artifactIIResearched := true ; 3 :
19995: LD_ADDR_EXP 10
19999: PUSH
20000: LD_INT 1
20002: ST_TO_ADDR
20003: GO 20025
20005: LD_INT 3
20007: DOUBLE
20008: EQUAL
20009: IFTRUE 20013
20011: GO 20024
20013: POP
// artifactIIIResearched := true ; end ;
20014: LD_ADDR_EXP 11
20018: PUSH
20019: LD_INT 1
20021: ST_TO_ADDR
20022: GO 20025
20024: POP
// end ; end_of_file
20025: PPOPN 3
20027: END
// export ru_radar , ru_big_cargo_bay , us_hack , us_artillery , ar_bio_bomb ; every 1 do
20028: GO 20030
20030: DISABLE
// begin ru_radar := 98 ;
20031: LD_ADDR_EXP 67
20035: PUSH
20036: LD_INT 98
20038: ST_TO_ADDR
// ru_big_cargo_bay := 89 ;
20039: LD_ADDR_EXP 68
20043: PUSH
20044: LD_INT 89
20046: ST_TO_ADDR
// us_hack := 99 ;
20047: LD_ADDR_EXP 69
20051: PUSH
20052: LD_INT 99
20054: ST_TO_ADDR
// us_artillery := 97 ;
20055: LD_ADDR_EXP 70
20059: PUSH
20060: LD_INT 97
20062: ST_TO_ADDR
// ar_bio_bomb := 91 ;
20063: LD_ADDR_EXP 71
20067: PUSH
20068: LD_INT 91
20070: ST_TO_ADDR
// end ; end_of_file
20071: END
// export skirmish , debug_mc ; export mc_bases , mc_building_need_repair , mc_building_repairs , mc_need_heal , mc_healers , mc_build_list , mc_builders , mc_construct_list , mc_turret_list , mc_empty_turret_list , mc_busy_turret_list , mc_defender_limit , mc_repair_vehicle , mc_mines , mc_miners , mc_minefields , mc_crates , mc_crates_collector , mc_crates_area , mc_vehicles , mc_attack , mc_produce , mc_defender , mc_scan , mc_parking , mc_scan_area , mc_sides , mc_tech , mc_can_tame , mc_ape , mc_ape_in_lab , mc_taming , mc_build_upgrade , mc_lab , mc_lab_upgrade , mc_teleport_exit , mc_teleport_exit_set , mc_deposits_xy , mc_deposits_finder , mc_allowed_tower_weapons , mc_remote_driver , mc_class , mc_class_case_use ; export function InitMacro ; var i ; begin
20072: LD_INT 0
20074: PPUSH
20075: PPUSH
// skirmish := false ;
20076: LD_ADDR_EXP 72
20080: PUSH
20081: LD_INT 0
20083: ST_TO_ADDR
// debug_mc := false ;
20084: LD_ADDR_EXP 73
20088: PUSH
20089: LD_INT 0
20091: ST_TO_ADDR
// mc_bases := [ ] ;
20092: LD_ADDR_EXP 74
20096: PUSH
20097: EMPTY
20098: ST_TO_ADDR
// mc_sides := [ ] ;
20099: LD_ADDR_EXP 100
20103: PUSH
20104: EMPTY
20105: ST_TO_ADDR
// mc_building_need_repair := [ ] ;
20106: LD_ADDR_EXP 75
20110: PUSH
20111: EMPTY
20112: ST_TO_ADDR
// mc_building_repairs := [ ] ;
20113: LD_ADDR_EXP 76
20117: PUSH
20118: EMPTY
20119: ST_TO_ADDR
// mc_need_heal := [ ] ;
20120: LD_ADDR_EXP 77
20124: PUSH
20125: EMPTY
20126: ST_TO_ADDR
// mc_healers := [ ] ;
20127: LD_ADDR_EXP 78
20131: PUSH
20132: EMPTY
20133: ST_TO_ADDR
// mc_build_list := [ ] ;
20134: LD_ADDR_EXP 79
20138: PUSH
20139: EMPTY
20140: ST_TO_ADDR
// mc_build_upgrade := [ ] ;
20141: LD_ADDR_EXP 106
20145: PUSH
20146: EMPTY
20147: ST_TO_ADDR
// mc_builders := [ ] ;
20148: LD_ADDR_EXP 80
20152: PUSH
20153: EMPTY
20154: ST_TO_ADDR
// mc_construct_list := [ ] ;
20155: LD_ADDR_EXP 81
20159: PUSH
20160: EMPTY
20161: ST_TO_ADDR
// mc_turret_list := [ ] ;
20162: LD_ADDR_EXP 82
20166: PUSH
20167: EMPTY
20168: ST_TO_ADDR
// mc_empty_turret_list := [ ] ;
20169: LD_ADDR_EXP 83
20173: PUSH
20174: EMPTY
20175: ST_TO_ADDR
// mc_miners := [ ] ;
20176: LD_ADDR_EXP 88
20180: PUSH
20181: EMPTY
20182: ST_TO_ADDR
// mc_mines := [ ] ;
20183: LD_ADDR_EXP 87
20187: PUSH
20188: EMPTY
20189: ST_TO_ADDR
// mc_minefields := [ ] ;
20190: LD_ADDR_EXP 89
20194: PUSH
20195: EMPTY
20196: ST_TO_ADDR
// mc_crates := [ ] ;
20197: LD_ADDR_EXP 90
20201: PUSH
20202: EMPTY
20203: ST_TO_ADDR
// mc_crates_collector := [ ] ;
20204: LD_ADDR_EXP 91
20208: PUSH
20209: EMPTY
20210: ST_TO_ADDR
// mc_crates_area := [ ] ;
20211: LD_ADDR_EXP 92
20215: PUSH
20216: EMPTY
20217: ST_TO_ADDR
// mc_vehicles := [ ] ;
20218: LD_ADDR_EXP 93
20222: PUSH
20223: EMPTY
20224: ST_TO_ADDR
// mc_attack := [ ] ;
20225: LD_ADDR_EXP 94
20229: PUSH
20230: EMPTY
20231: ST_TO_ADDR
// mc_produce := [ ] ;
20232: LD_ADDR_EXP 95
20236: PUSH
20237: EMPTY
20238: ST_TO_ADDR
// mc_defender := [ ] ;
20239: LD_ADDR_EXP 96
20243: PUSH
20244: EMPTY
20245: ST_TO_ADDR
// mc_parking := [ ] ;
20246: LD_ADDR_EXP 98
20250: PUSH
20251: EMPTY
20252: ST_TO_ADDR
// mc_busy_turret_list := [ ] ;
20253: LD_ADDR_EXP 84
20257: PUSH
20258: EMPTY
20259: ST_TO_ADDR
// mc_repair_vehicle := [ ] ;
20260: LD_ADDR_EXP 86
20264: PUSH
20265: EMPTY
20266: ST_TO_ADDR
// mc_scan := [ ] ;
20267: LD_ADDR_EXP 97
20271: PUSH
20272: EMPTY
20273: ST_TO_ADDR
// mc_scan_area := [ ] ;
20274: LD_ADDR_EXP 99
20278: PUSH
20279: EMPTY
20280: ST_TO_ADDR
// mc_tech := [ ] ;
20281: LD_ADDR_EXP 101
20285: PUSH
20286: EMPTY
20287: ST_TO_ADDR
// mc_class := [ ] ;
20288: LD_ADDR_EXP 115
20292: PUSH
20293: EMPTY
20294: ST_TO_ADDR
// mc_class_case_use := [ ] ;
20295: LD_ADDR_EXP 116
20299: PUSH
20300: EMPTY
20301: ST_TO_ADDR
// end ;
20302: LD_VAR 0 1
20306: RET
// export function MC_Kill ( base ) ; begin
20307: LD_INT 0
20309: PPUSH
// mc_bases := Replace ( mc_bases , base , [ ] ) ;
20310: LD_ADDR_EXP 74
20314: PUSH
20315: LD_EXP 74
20319: PPUSH
20320: LD_VAR 0 1
20324: PPUSH
20325: EMPTY
20326: PPUSH
20327: CALL_OW 1
20331: ST_TO_ADDR
// mc_building_need_repair := Replace ( mc_building_need_repair , base , [ ] ) ;
20332: LD_ADDR_EXP 75
20336: PUSH
20337: LD_EXP 75
20341: PPUSH
20342: LD_VAR 0 1
20346: PPUSH
20347: EMPTY
20348: PPUSH
20349: CALL_OW 1
20353: ST_TO_ADDR
// mc_building_repairs := Replace ( mc_building_repairs , base , [ ] ) ;
20354: LD_ADDR_EXP 76
20358: PUSH
20359: LD_EXP 76
20363: PPUSH
20364: LD_VAR 0 1
20368: PPUSH
20369: EMPTY
20370: PPUSH
20371: CALL_OW 1
20375: ST_TO_ADDR
// mc_need_heal := Replace ( mc_need_heal , base , [ ] ) ;
20376: LD_ADDR_EXP 77
20380: PUSH
20381: LD_EXP 77
20385: PPUSH
20386: LD_VAR 0 1
20390: PPUSH
20391: EMPTY
20392: PPUSH
20393: CALL_OW 1
20397: ST_TO_ADDR
// mc_healers := Replace ( mc_healers , base , [ ] ) ;
20398: LD_ADDR_EXP 78
20402: PUSH
20403: LD_EXP 78
20407: PPUSH
20408: LD_VAR 0 1
20412: PPUSH
20413: EMPTY
20414: PPUSH
20415: CALL_OW 1
20419: ST_TO_ADDR
// mc_build_list := Replace ( mc_build_list , base , [ ] ) ;
20420: LD_ADDR_EXP 79
20424: PUSH
20425: LD_EXP 79
20429: PPUSH
20430: LD_VAR 0 1
20434: PPUSH
20435: EMPTY
20436: PPUSH
20437: CALL_OW 1
20441: ST_TO_ADDR
// mc_builders := Replace ( mc_builders , base , [ ] ) ;
20442: LD_ADDR_EXP 80
20446: PUSH
20447: LD_EXP 80
20451: PPUSH
20452: LD_VAR 0 1
20456: PPUSH
20457: EMPTY
20458: PPUSH
20459: CALL_OW 1
20463: ST_TO_ADDR
// mc_construct_list := Replace ( mc_construct_list , base , [ ] ) ;
20464: LD_ADDR_EXP 81
20468: PUSH
20469: LD_EXP 81
20473: PPUSH
20474: LD_VAR 0 1
20478: PPUSH
20479: EMPTY
20480: PPUSH
20481: CALL_OW 1
20485: ST_TO_ADDR
// mc_turret_list := Replace ( mc_turret_list , base , [ ] ) ;
20486: LD_ADDR_EXP 82
20490: PUSH
20491: LD_EXP 82
20495: PPUSH
20496: LD_VAR 0 1
20500: PPUSH
20501: EMPTY
20502: PPUSH
20503: CALL_OW 1
20507: ST_TO_ADDR
// mc_empty_turret_list := Replace ( mc_empty_turret_list , base , [ ] ) ;
20508: LD_ADDR_EXP 83
20512: PUSH
20513: LD_EXP 83
20517: PPUSH
20518: LD_VAR 0 1
20522: PPUSH
20523: EMPTY
20524: PPUSH
20525: CALL_OW 1
20529: ST_TO_ADDR
// mc_busy_turret_list := Replace ( mc_busy_turret_list , base , [ ] ) ;
20530: LD_ADDR_EXP 84
20534: PUSH
20535: LD_EXP 84
20539: PPUSH
20540: LD_VAR 0 1
20544: PPUSH
20545: EMPTY
20546: PPUSH
20547: CALL_OW 1
20551: ST_TO_ADDR
// mc_defender_limit := Replace ( mc_defender_limit , base , 0 ) ;
20552: LD_ADDR_EXP 85
20556: PUSH
20557: LD_EXP 85
20561: PPUSH
20562: LD_VAR 0 1
20566: PPUSH
20567: LD_INT 0
20569: PPUSH
20570: CALL_OW 1
20574: ST_TO_ADDR
// mc_repair_vehicle := Replace ( mc_repair_vehicle , base , [ ] ) ;
20575: LD_ADDR_EXP 86
20579: PUSH
20580: LD_EXP 86
20584: PPUSH
20585: LD_VAR 0 1
20589: PPUSH
20590: EMPTY
20591: PPUSH
20592: CALL_OW 1
20596: ST_TO_ADDR
// mc_mines := Replace ( mc_mines , base , [ ] ) ;
20597: LD_ADDR_EXP 87
20601: PUSH
20602: LD_EXP 87
20606: PPUSH
20607: LD_VAR 0 1
20611: PPUSH
20612: EMPTY
20613: PPUSH
20614: CALL_OW 1
20618: ST_TO_ADDR
// mc_miners := Replace ( mc_miners , base , [ ] ) ;
20619: LD_ADDR_EXP 88
20623: PUSH
20624: LD_EXP 88
20628: PPUSH
20629: LD_VAR 0 1
20633: PPUSH
20634: EMPTY
20635: PPUSH
20636: CALL_OW 1
20640: ST_TO_ADDR
// mc_minefields := Replace ( mc_minefields , base , [ ] ) ;
20641: LD_ADDR_EXP 89
20645: PUSH
20646: LD_EXP 89
20650: PPUSH
20651: LD_VAR 0 1
20655: PPUSH
20656: EMPTY
20657: PPUSH
20658: CALL_OW 1
20662: ST_TO_ADDR
// mc_crates := Replace ( mc_crates , base , [ ] ) ;
20663: LD_ADDR_EXP 90
20667: PUSH
20668: LD_EXP 90
20672: PPUSH
20673: LD_VAR 0 1
20677: PPUSH
20678: EMPTY
20679: PPUSH
20680: CALL_OW 1
20684: ST_TO_ADDR
// mc_crates_collector := Replace ( mc_crates_collector , base , [ ] ) ;
20685: LD_ADDR_EXP 91
20689: PUSH
20690: LD_EXP 91
20694: PPUSH
20695: LD_VAR 0 1
20699: PPUSH
20700: EMPTY
20701: PPUSH
20702: CALL_OW 1
20706: ST_TO_ADDR
// mc_crates_area := Replace ( mc_crates_area , base , [ ] ) ;
20707: LD_ADDR_EXP 92
20711: PUSH
20712: LD_EXP 92
20716: PPUSH
20717: LD_VAR 0 1
20721: PPUSH
20722: EMPTY
20723: PPUSH
20724: CALL_OW 1
20728: ST_TO_ADDR
// mc_vehicles := Replace ( mc_vehicles , base , [ ] ) ;
20729: LD_ADDR_EXP 93
20733: PUSH
20734: LD_EXP 93
20738: PPUSH
20739: LD_VAR 0 1
20743: PPUSH
20744: EMPTY
20745: PPUSH
20746: CALL_OW 1
20750: ST_TO_ADDR
// mc_attack := Replace ( mc_attack , base , [ ] ) ;
20751: LD_ADDR_EXP 94
20755: PUSH
20756: LD_EXP 94
20760: PPUSH
20761: LD_VAR 0 1
20765: PPUSH
20766: EMPTY
20767: PPUSH
20768: CALL_OW 1
20772: ST_TO_ADDR
// mc_produce := Replace ( mc_produce , base , [ ] ) ;
20773: LD_ADDR_EXP 95
20777: PUSH
20778: LD_EXP 95
20782: PPUSH
20783: LD_VAR 0 1
20787: PPUSH
20788: EMPTY
20789: PPUSH
20790: CALL_OW 1
20794: ST_TO_ADDR
// mc_defender := Replace ( mc_defender , base , [ ] ) ;
20795: LD_ADDR_EXP 96
20799: PUSH
20800: LD_EXP 96
20804: PPUSH
20805: LD_VAR 0 1
20809: PPUSH
20810: EMPTY
20811: PPUSH
20812: CALL_OW 1
20816: ST_TO_ADDR
// mc_scan := Replace ( mc_scan , base , [ ] ) ;
20817: LD_ADDR_EXP 97
20821: PUSH
20822: LD_EXP 97
20826: PPUSH
20827: LD_VAR 0 1
20831: PPUSH
20832: EMPTY
20833: PPUSH
20834: CALL_OW 1
20838: ST_TO_ADDR
// mc_parking := Replace ( mc_parking , base , [ ] ) ;
20839: LD_ADDR_EXP 98
20843: PUSH
20844: LD_EXP 98
20848: PPUSH
20849: LD_VAR 0 1
20853: PPUSH
20854: EMPTY
20855: PPUSH
20856: CALL_OW 1
20860: ST_TO_ADDR
// mc_scan_area := Replace ( mc_scan_area , base , [ ] ) ;
20861: LD_ADDR_EXP 99
20865: PUSH
20866: LD_EXP 99
20870: PPUSH
20871: LD_VAR 0 1
20875: PPUSH
20876: EMPTY
20877: PPUSH
20878: CALL_OW 1
20882: ST_TO_ADDR
// mc_tech := Replace ( mc_tech , base , [ ] ) ;
20883: LD_ADDR_EXP 101
20887: PUSH
20888: LD_EXP 101
20892: PPUSH
20893: LD_VAR 0 1
20897: PPUSH
20898: EMPTY
20899: PPUSH
20900: CALL_OW 1
20904: ST_TO_ADDR
// mc_ape := Replace ( mc_ape , base , [ ] ) ;
20905: LD_ADDR_EXP 103
20909: PUSH
20910: LD_EXP 103
20914: PPUSH
20915: LD_VAR 0 1
20919: PPUSH
20920: EMPTY
20921: PPUSH
20922: CALL_OW 1
20926: ST_TO_ADDR
// mc_ape_in_lab := Replace ( mc_ape_in_lab , base , [ ] ) ;
20927: LD_ADDR_EXP 104
20931: PUSH
20932: LD_EXP 104
20936: PPUSH
20937: LD_VAR 0 1
20941: PPUSH
20942: EMPTY
20943: PPUSH
20944: CALL_OW 1
20948: ST_TO_ADDR
// mc_taming := Replace ( mc_taming , base , [ ] ) ;
20949: LD_ADDR_EXP 105
20953: PUSH
20954: LD_EXP 105
20958: PPUSH
20959: LD_VAR 0 1
20963: PPUSH
20964: EMPTY
20965: PPUSH
20966: CALL_OW 1
20970: ST_TO_ADDR
// mc_build_upgrade := Replace ( mc_build_upgrade , base , [ ] ) ;
20971: LD_ADDR_EXP 106
20975: PUSH
20976: LD_EXP 106
20980: PPUSH
20981: LD_VAR 0 1
20985: PPUSH
20986: EMPTY
20987: PPUSH
20988: CALL_OW 1
20992: ST_TO_ADDR
// mc_lab := Replace ( mc_lab , base , [ ] ) ;
20993: LD_ADDR_EXP 107
20997: PUSH
20998: LD_EXP 107
21002: PPUSH
21003: LD_VAR 0 1
21007: PPUSH
21008: EMPTY
21009: PPUSH
21010: CALL_OW 1
21014: ST_TO_ADDR
// mc_lab_upgrade := Replace ( mc_lab_upgrade , base , [ ] ) ;
21015: LD_ADDR_EXP 108
21019: PUSH
21020: LD_EXP 108
21024: PPUSH
21025: LD_VAR 0 1
21029: PPUSH
21030: EMPTY
21031: PPUSH
21032: CALL_OW 1
21036: ST_TO_ADDR
// mc_teleport_exit := Replace ( mc_teleport_exit , base , [ ] ) ;
21037: LD_ADDR_EXP 109
21041: PUSH
21042: LD_EXP 109
21046: PPUSH
21047: LD_VAR 0 1
21051: PPUSH
21052: EMPTY
21053: PPUSH
21054: CALL_OW 1
21058: ST_TO_ADDR
// mc_teleport_exit_set := Replace ( mc_teleport_exit_set , base , [ ] ) ;
21059: LD_ADDR_EXP 110
21063: PUSH
21064: LD_EXP 110
21068: PPUSH
21069: LD_VAR 0 1
21073: PPUSH
21074: EMPTY
21075: PPUSH
21076: CALL_OW 1
21080: ST_TO_ADDR
// mc_deposits_xy := Replace ( mc_deposits_xy , base , [ ] ) ;
21081: LD_ADDR_EXP 111
21085: PUSH
21086: LD_EXP 111
21090: PPUSH
21091: LD_VAR 0 1
21095: PPUSH
21096: EMPTY
21097: PPUSH
21098: CALL_OW 1
21102: ST_TO_ADDR
// mc_deposits_finder := Replace ( mc_deposits_finder , base , [ ] ) ;
21103: LD_ADDR_EXP 112
21107: PUSH
21108: LD_EXP 112
21112: PPUSH
21113: LD_VAR 0 1
21117: PPUSH
21118: EMPTY
21119: PPUSH
21120: CALL_OW 1
21124: ST_TO_ADDR
// mc_allowed_tower_weapons := Replace ( mc_allowed_tower_weapons , base , [ ] ) ;
21125: LD_ADDR_EXP 113
21129: PUSH
21130: LD_EXP 113
21134: PPUSH
21135: LD_VAR 0 1
21139: PPUSH
21140: EMPTY
21141: PPUSH
21142: CALL_OW 1
21146: ST_TO_ADDR
// mc_remote_driver := Replace ( mc_remote_driver , base , [ ] ) ;
21147: LD_ADDR_EXP 114
21151: PUSH
21152: LD_EXP 114
21156: PPUSH
21157: LD_VAR 0 1
21161: PPUSH
21162: EMPTY
21163: PPUSH
21164: CALL_OW 1
21168: ST_TO_ADDR
// mc_class := Replace ( mc_class , base , [ ] ) ;
21169: LD_ADDR_EXP 115
21173: PUSH
21174: LD_EXP 115
21178: PPUSH
21179: LD_VAR 0 1
21183: PPUSH
21184: EMPTY
21185: PPUSH
21186: CALL_OW 1
21190: ST_TO_ADDR
// mc_class_case_use := Replace ( mc_class_case_use , base , 0 ) ;
21191: LD_ADDR_EXP 116
21195: PUSH
21196: LD_EXP 116
21200: PPUSH
21201: LD_VAR 0 1
21205: PPUSH
21206: LD_INT 0
21208: PPUSH
21209: CALL_OW 1
21213: ST_TO_ADDR
// end ;
21214: LD_VAR 0 2
21218: RET
// export function MC_Add ( side , units ) ; var base ; begin
21219: LD_INT 0
21221: PPUSH
21222: PPUSH
// base := mc_bases + 1 ;
21223: LD_ADDR_VAR 0 4
21227: PUSH
21228: LD_EXP 74
21232: PUSH
21233: LD_INT 1
21235: PLUS
21236: ST_TO_ADDR
// mc_sides := Replace ( mc_sides , base , side ) ;
21237: LD_ADDR_EXP 100
21241: PUSH
21242: LD_EXP 100
21246: PPUSH
21247: LD_VAR 0 4
21251: PPUSH
21252: LD_VAR 0 1
21256: PPUSH
21257: CALL_OW 1
21261: ST_TO_ADDR
// mc_bases := Replace ( mc_bases , base , units ) ;
21262: LD_ADDR_EXP 74
21266: PUSH
21267: LD_EXP 74
21271: PPUSH
21272: LD_VAR 0 4
21276: PPUSH
21277: LD_VAR 0 2
21281: PPUSH
21282: CALL_OW 1
21286: ST_TO_ADDR
// mc_building_need_repair := Replace ( mc_building_need_repair , base , [ ] ) ;
21287: LD_ADDR_EXP 75
21291: PUSH
21292: LD_EXP 75
21296: PPUSH
21297: LD_VAR 0 4
21301: PPUSH
21302: EMPTY
21303: PPUSH
21304: CALL_OW 1
21308: ST_TO_ADDR
// mc_building_repairs := Replace ( mc_building_repairs , base , [ ] ) ;
21309: LD_ADDR_EXP 76
21313: PUSH
21314: LD_EXP 76
21318: PPUSH
21319: LD_VAR 0 4
21323: PPUSH
21324: EMPTY
21325: PPUSH
21326: CALL_OW 1
21330: ST_TO_ADDR
// mc_need_heal := Replace ( mc_need_heal , base , [ ] ) ;
21331: LD_ADDR_EXP 77
21335: PUSH
21336: LD_EXP 77
21340: PPUSH
21341: LD_VAR 0 4
21345: PPUSH
21346: EMPTY
21347: PPUSH
21348: CALL_OW 1
21352: ST_TO_ADDR
// mc_healers := Replace ( mc_healers , base , [ ] ) ;
21353: LD_ADDR_EXP 78
21357: PUSH
21358: LD_EXP 78
21362: PPUSH
21363: LD_VAR 0 4
21367: PPUSH
21368: EMPTY
21369: PPUSH
21370: CALL_OW 1
21374: ST_TO_ADDR
// mc_build_list := Replace ( mc_build_list , base , [ ] ) ;
21375: LD_ADDR_EXP 79
21379: PUSH
21380: LD_EXP 79
21384: PPUSH
21385: LD_VAR 0 4
21389: PPUSH
21390: EMPTY
21391: PPUSH
21392: CALL_OW 1
21396: ST_TO_ADDR
// mc_builders := Replace ( mc_builders , base , [ ] ) ;
21397: LD_ADDR_EXP 80
21401: PUSH
21402: LD_EXP 80
21406: PPUSH
21407: LD_VAR 0 4
21411: PPUSH
21412: EMPTY
21413: PPUSH
21414: CALL_OW 1
21418: ST_TO_ADDR
// mc_construct_list := Replace ( mc_construct_list , base , [ ] ) ;
21419: LD_ADDR_EXP 81
21423: PUSH
21424: LD_EXP 81
21428: PPUSH
21429: LD_VAR 0 4
21433: PPUSH
21434: EMPTY
21435: PPUSH
21436: CALL_OW 1
21440: ST_TO_ADDR
// mc_turret_list := Replace ( mc_turret_list , base , [ ] ) ;
21441: LD_ADDR_EXP 82
21445: PUSH
21446: LD_EXP 82
21450: PPUSH
21451: LD_VAR 0 4
21455: PPUSH
21456: EMPTY
21457: PPUSH
21458: CALL_OW 1
21462: ST_TO_ADDR
// mc_empty_turret_list := Replace ( mc_empty_turret_list , base , [ ] ) ;
21463: LD_ADDR_EXP 83
21467: PUSH
21468: LD_EXP 83
21472: PPUSH
21473: LD_VAR 0 4
21477: PPUSH
21478: EMPTY
21479: PPUSH
21480: CALL_OW 1
21484: ST_TO_ADDR
// mc_busy_turret_list := Replace ( mc_busy_turret_list , base , [ ] ) ;
21485: LD_ADDR_EXP 84
21489: PUSH
21490: LD_EXP 84
21494: PPUSH
21495: LD_VAR 0 4
21499: PPUSH
21500: EMPTY
21501: PPUSH
21502: CALL_OW 1
21506: ST_TO_ADDR
// mc_defender_limit := Replace ( mc_defender_limit , base , 0 ) ;
21507: LD_ADDR_EXP 85
21511: PUSH
21512: LD_EXP 85
21516: PPUSH
21517: LD_VAR 0 4
21521: PPUSH
21522: LD_INT 0
21524: PPUSH
21525: CALL_OW 1
21529: ST_TO_ADDR
// mc_repair_vehicle := Replace ( mc_repair_vehicle , base , [ ] ) ;
21530: LD_ADDR_EXP 86
21534: PUSH
21535: LD_EXP 86
21539: PPUSH
21540: LD_VAR 0 4
21544: PPUSH
21545: EMPTY
21546: PPUSH
21547: CALL_OW 1
21551: ST_TO_ADDR
// mc_mines := Replace ( mc_mines , base , [ ] ) ;
21552: LD_ADDR_EXP 87
21556: PUSH
21557: LD_EXP 87
21561: PPUSH
21562: LD_VAR 0 4
21566: PPUSH
21567: EMPTY
21568: PPUSH
21569: CALL_OW 1
21573: ST_TO_ADDR
// mc_miners := Replace ( mc_miners , base , [ ] ) ;
21574: LD_ADDR_EXP 88
21578: PUSH
21579: LD_EXP 88
21583: PPUSH
21584: LD_VAR 0 4
21588: PPUSH
21589: EMPTY
21590: PPUSH
21591: CALL_OW 1
21595: ST_TO_ADDR
// mc_minefields := Replace ( mc_minefields , base , [ ] ) ;
21596: LD_ADDR_EXP 89
21600: PUSH
21601: LD_EXP 89
21605: PPUSH
21606: LD_VAR 0 4
21610: PPUSH
21611: EMPTY
21612: PPUSH
21613: CALL_OW 1
21617: ST_TO_ADDR
// mc_crates := Replace ( mc_crates , base , [ ] ) ;
21618: LD_ADDR_EXP 90
21622: PUSH
21623: LD_EXP 90
21627: PPUSH
21628: LD_VAR 0 4
21632: PPUSH
21633: EMPTY
21634: PPUSH
21635: CALL_OW 1
21639: ST_TO_ADDR
// mc_crates_collector := Replace ( mc_crates_collector , base , [ ] ) ;
21640: LD_ADDR_EXP 91
21644: PUSH
21645: LD_EXP 91
21649: PPUSH
21650: LD_VAR 0 4
21654: PPUSH
21655: EMPTY
21656: PPUSH
21657: CALL_OW 1
21661: ST_TO_ADDR
// mc_crates_area := Replace ( mc_crates_area , base , [ ] ) ;
21662: LD_ADDR_EXP 92
21666: PUSH
21667: LD_EXP 92
21671: PPUSH
21672: LD_VAR 0 4
21676: PPUSH
21677: EMPTY
21678: PPUSH
21679: CALL_OW 1
21683: ST_TO_ADDR
// mc_vehicles := Replace ( mc_vehicles , base , [ ] ) ;
21684: LD_ADDR_EXP 93
21688: PUSH
21689: LD_EXP 93
21693: PPUSH
21694: LD_VAR 0 4
21698: PPUSH
21699: EMPTY
21700: PPUSH
21701: CALL_OW 1
21705: ST_TO_ADDR
// mc_attack := Replace ( mc_attack , base , [ ] ) ;
21706: LD_ADDR_EXP 94
21710: PUSH
21711: LD_EXP 94
21715: PPUSH
21716: LD_VAR 0 4
21720: PPUSH
21721: EMPTY
21722: PPUSH
21723: CALL_OW 1
21727: ST_TO_ADDR
// mc_produce := Replace ( mc_produce , base , [ ] ) ;
21728: LD_ADDR_EXP 95
21732: PUSH
21733: LD_EXP 95
21737: PPUSH
21738: LD_VAR 0 4
21742: PPUSH
21743: EMPTY
21744: PPUSH
21745: CALL_OW 1
21749: ST_TO_ADDR
// mc_defender := Replace ( mc_defender , base , [ ] ) ;
21750: LD_ADDR_EXP 96
21754: PUSH
21755: LD_EXP 96
21759: PPUSH
21760: LD_VAR 0 4
21764: PPUSH
21765: EMPTY
21766: PPUSH
21767: CALL_OW 1
21771: ST_TO_ADDR
// mc_scan := Replace ( mc_scan , base , [ ] ) ;
21772: LD_ADDR_EXP 97
21776: PUSH
21777: LD_EXP 97
21781: PPUSH
21782: LD_VAR 0 4
21786: PPUSH
21787: EMPTY
21788: PPUSH
21789: CALL_OW 1
21793: ST_TO_ADDR
// mc_parking := Replace ( mc_parking , base , [ ] ) ;
21794: LD_ADDR_EXP 98
21798: PUSH
21799: LD_EXP 98
21803: PPUSH
21804: LD_VAR 0 4
21808: PPUSH
21809: EMPTY
21810: PPUSH
21811: CALL_OW 1
21815: ST_TO_ADDR
// mc_scan_area := Replace ( mc_scan_area , base , [ ] ) ;
21816: LD_ADDR_EXP 99
21820: PUSH
21821: LD_EXP 99
21825: PPUSH
21826: LD_VAR 0 4
21830: PPUSH
21831: EMPTY
21832: PPUSH
21833: CALL_OW 1
21837: ST_TO_ADDR
// mc_tech := Replace ( mc_tech , base , [ ] ) ;
21838: LD_ADDR_EXP 101
21842: PUSH
21843: LD_EXP 101
21847: PPUSH
21848: LD_VAR 0 4
21852: PPUSH
21853: EMPTY
21854: PPUSH
21855: CALL_OW 1
21859: ST_TO_ADDR
// mc_ape := Replace ( mc_ape , base , [ ] ) ;
21860: LD_ADDR_EXP 103
21864: PUSH
21865: LD_EXP 103
21869: PPUSH
21870: LD_VAR 0 4
21874: PPUSH
21875: EMPTY
21876: PPUSH
21877: CALL_OW 1
21881: ST_TO_ADDR
// mc_ape_in_lab := Replace ( mc_ape_in_lab , base , [ ] ) ;
21882: LD_ADDR_EXP 104
21886: PUSH
21887: LD_EXP 104
21891: PPUSH
21892: LD_VAR 0 4
21896: PPUSH
21897: EMPTY
21898: PPUSH
21899: CALL_OW 1
21903: ST_TO_ADDR
// mc_taming := Replace ( mc_taming , base , [ ] ) ;
21904: LD_ADDR_EXP 105
21908: PUSH
21909: LD_EXP 105
21913: PPUSH
21914: LD_VAR 0 4
21918: PPUSH
21919: EMPTY
21920: PPUSH
21921: CALL_OW 1
21925: ST_TO_ADDR
// mc_build_upgrade := Replace ( mc_build_upgrade , base , [ ] ) ;
21926: LD_ADDR_EXP 106
21930: PUSH
21931: LD_EXP 106
21935: PPUSH
21936: LD_VAR 0 4
21940: PPUSH
21941: EMPTY
21942: PPUSH
21943: CALL_OW 1
21947: ST_TO_ADDR
// mc_lab := Replace ( mc_lab , base , [ ] ) ;
21948: LD_ADDR_EXP 107
21952: PUSH
21953: LD_EXP 107
21957: PPUSH
21958: LD_VAR 0 4
21962: PPUSH
21963: EMPTY
21964: PPUSH
21965: CALL_OW 1
21969: ST_TO_ADDR
// mc_lab_upgrade := Replace ( mc_lab_upgrade , base , [ ] ) ;
21970: LD_ADDR_EXP 108
21974: PUSH
21975: LD_EXP 108
21979: PPUSH
21980: LD_VAR 0 4
21984: PPUSH
21985: EMPTY
21986: PPUSH
21987: CALL_OW 1
21991: ST_TO_ADDR
// mc_teleport_exit := Replace ( mc_teleport_exit , base , [ ] ) ;
21992: LD_ADDR_EXP 109
21996: PUSH
21997: LD_EXP 109
22001: PPUSH
22002: LD_VAR 0 4
22006: PPUSH
22007: EMPTY
22008: PPUSH
22009: CALL_OW 1
22013: ST_TO_ADDR
// mc_teleport_exit_set := Replace ( mc_teleport_exit_set , base , [ ] ) ;
22014: LD_ADDR_EXP 110
22018: PUSH
22019: LD_EXP 110
22023: PPUSH
22024: LD_VAR 0 4
22028: PPUSH
22029: EMPTY
22030: PPUSH
22031: CALL_OW 1
22035: ST_TO_ADDR
// mc_deposits_xy := Replace ( mc_deposits_xy , base , [ ] ) ;
22036: LD_ADDR_EXP 111
22040: PUSH
22041: LD_EXP 111
22045: PPUSH
22046: LD_VAR 0 4
22050: PPUSH
22051: EMPTY
22052: PPUSH
22053: CALL_OW 1
22057: ST_TO_ADDR
// mc_deposits_finder := Replace ( mc_deposits_finder , base , [ ] ) ;
22058: LD_ADDR_EXP 112
22062: PUSH
22063: LD_EXP 112
22067: PPUSH
22068: LD_VAR 0 4
22072: PPUSH
22073: EMPTY
22074: PPUSH
22075: CALL_OW 1
22079: ST_TO_ADDR
// mc_allowed_tower_weapons := Replace ( mc_allowed_tower_weapons , base , [ ] ) ;
22080: LD_ADDR_EXP 113
22084: PUSH
22085: LD_EXP 113
22089: PPUSH
22090: LD_VAR 0 4
22094: PPUSH
22095: EMPTY
22096: PPUSH
22097: CALL_OW 1
22101: ST_TO_ADDR
// mc_remote_driver := Replace ( mc_remote_driver , base , [ ] ) ;
22102: LD_ADDR_EXP 114
22106: PUSH
22107: LD_EXP 114
22111: PPUSH
22112: LD_VAR 0 4
22116: PPUSH
22117: EMPTY
22118: PPUSH
22119: CALL_OW 1
22123: ST_TO_ADDR
// mc_class := Replace ( mc_class , base , [ ] ) ;
22124: LD_ADDR_EXP 115
22128: PUSH
22129: LD_EXP 115
22133: PPUSH
22134: LD_VAR 0 4
22138: PPUSH
22139: EMPTY
22140: PPUSH
22141: CALL_OW 1
22145: ST_TO_ADDR
// mc_class_case_use := Replace ( mc_class_case_use , base , 0 ) ;
22146: LD_ADDR_EXP 116
22150: PUSH
22151: LD_EXP 116
22155: PPUSH
22156: LD_VAR 0 4
22160: PPUSH
22161: LD_INT 0
22163: PPUSH
22164: CALL_OW 1
22168: ST_TO_ADDR
// result := base ;
22169: LD_ADDR_VAR 0 3
22173: PUSH
22174: LD_VAR 0 4
22178: ST_TO_ADDR
// end ;
22179: LD_VAR 0 3
22183: RET
// export function MC_Start ( ) ; var i ; begin
22184: LD_INT 0
22186: PPUSH
22187: PPUSH
// for i = 1 to mc_bases do
22188: LD_ADDR_VAR 0 2
22192: PUSH
22193: DOUBLE
22194: LD_INT 1
22196: DEC
22197: ST_TO_ADDR
22198: LD_EXP 74
22202: PUSH
22203: FOR_TO
22204: IFFALSE 23281
// begin mc_bases := Replace ( mc_bases , i , mc_bases [ i ] diff 0 ) ;
22206: LD_ADDR_EXP 74
22210: PUSH
22211: LD_EXP 74
22215: PPUSH
22216: LD_VAR 0 2
22220: PPUSH
22221: LD_EXP 74
22225: PUSH
22226: LD_VAR 0 2
22230: ARRAY
22231: PUSH
22232: LD_INT 0
22234: DIFF
22235: PPUSH
22236: CALL_OW 1
22240: ST_TO_ADDR
// mc_building_need_repair := Replace ( mc_building_need_repair , i , [ ] ) ;
22241: LD_ADDR_EXP 75
22245: PUSH
22246: LD_EXP 75
22250: PPUSH
22251: LD_VAR 0 2
22255: PPUSH
22256: EMPTY
22257: PPUSH
22258: CALL_OW 1
22262: ST_TO_ADDR
// mc_building_repairs := Replace ( mc_building_repairs , i , [ ] ) ;
22263: LD_ADDR_EXP 76
22267: PUSH
22268: LD_EXP 76
22272: PPUSH
22273: LD_VAR 0 2
22277: PPUSH
22278: EMPTY
22279: PPUSH
22280: CALL_OW 1
22284: ST_TO_ADDR
// mc_need_heal := Replace ( mc_need_heal , i , [ ] ) ;
22285: LD_ADDR_EXP 77
22289: PUSH
22290: LD_EXP 77
22294: PPUSH
22295: LD_VAR 0 2
22299: PPUSH
22300: EMPTY
22301: PPUSH
22302: CALL_OW 1
22306: ST_TO_ADDR
// mc_healers := Replace ( mc_healers , i , [ [ ] , [ ] ] ) ;
22307: LD_ADDR_EXP 78
22311: PUSH
22312: LD_EXP 78
22316: PPUSH
22317: LD_VAR 0 2
22321: PPUSH
22322: EMPTY
22323: PUSH
22324: EMPTY
22325: PUSH
22326: EMPTY
22327: LIST
22328: LIST
22329: PPUSH
22330: CALL_OW 1
22334: ST_TO_ADDR
// mc_build_list := Replace ( mc_build_list , i , [ ] ) ;
22335: LD_ADDR_EXP 79
22339: PUSH
22340: LD_EXP 79
22344: PPUSH
22345: LD_VAR 0 2
22349: PPUSH
22350: EMPTY
22351: PPUSH
22352: CALL_OW 1
22356: ST_TO_ADDR
// mc_build_upgrade := Replace ( mc_build_upgrade , i , [ ] ) ;
22357: LD_ADDR_EXP 106
22361: PUSH
22362: LD_EXP 106
22366: PPUSH
22367: LD_VAR 0 2
22371: PPUSH
22372: EMPTY
22373: PPUSH
22374: CALL_OW 1
22378: ST_TO_ADDR
// mc_builders := Replace ( mc_builders , i , [ ] ) ;
22379: LD_ADDR_EXP 80
22383: PUSH
22384: LD_EXP 80
22388: PPUSH
22389: LD_VAR 0 2
22393: PPUSH
22394: EMPTY
22395: PPUSH
22396: CALL_OW 1
22400: ST_TO_ADDR
// mc_construct_list := Replace ( mc_construct_list , i , [ ] ) ;
22401: LD_ADDR_EXP 81
22405: PUSH
22406: LD_EXP 81
22410: PPUSH
22411: LD_VAR 0 2
22415: PPUSH
22416: EMPTY
22417: PPUSH
22418: CALL_OW 1
22422: ST_TO_ADDR
// mc_turret_list := Replace ( mc_turret_list , i , UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_bunker ] , [ f_btype , b_turret ] ] ) ) ;
22423: LD_ADDR_EXP 82
22427: PUSH
22428: LD_EXP 82
22432: PPUSH
22433: LD_VAR 0 2
22437: PPUSH
22438: LD_EXP 74
22442: PUSH
22443: LD_VAR 0 2
22447: ARRAY
22448: PPUSH
22449: LD_INT 2
22451: PUSH
22452: LD_INT 30
22454: PUSH
22455: LD_INT 32
22457: PUSH
22458: EMPTY
22459: LIST
22460: LIST
22461: PUSH
22462: LD_INT 30
22464: PUSH
22465: LD_INT 33
22467: PUSH
22468: EMPTY
22469: LIST
22470: LIST
22471: PUSH
22472: EMPTY
22473: LIST
22474: LIST
22475: LIST
22476: PPUSH
22477: CALL_OW 72
22481: PPUSH
22482: CALL_OW 1
22486: ST_TO_ADDR
// mc_empty_turret_list := Replace ( mc_empty_turret_list , i , UnitFilter ( mc_bases [ i ] , [ [ f_or , [ f_btype , b_bunker ] , [ f_btype , b_breastwork ] ] , [ f_empty ] ] ) ) ;
22487: LD_ADDR_EXP 83
22491: PUSH
22492: LD_EXP 83
22496: PPUSH
22497: LD_VAR 0 2
22501: PPUSH
22502: LD_EXP 74
22506: PUSH
22507: LD_VAR 0 2
22511: ARRAY
22512: PPUSH
22513: LD_INT 2
22515: PUSH
22516: LD_INT 30
22518: PUSH
22519: LD_INT 32
22521: PUSH
22522: EMPTY
22523: LIST
22524: LIST
22525: PUSH
22526: LD_INT 30
22528: PUSH
22529: LD_INT 31
22531: PUSH
22532: EMPTY
22533: LIST
22534: LIST
22535: PUSH
22536: EMPTY
22537: LIST
22538: LIST
22539: LIST
22540: PUSH
22541: LD_INT 58
22543: PUSH
22544: EMPTY
22545: LIST
22546: PUSH
22547: EMPTY
22548: LIST
22549: LIST
22550: PPUSH
22551: CALL_OW 72
22555: PPUSH
22556: CALL_OW 1
22560: ST_TO_ADDR
// mc_busy_turret_list := Replace ( mc_busy_turret_list , i , [ ] ) ;
22561: LD_ADDR_EXP 84
22565: PUSH
22566: LD_EXP 84
22570: PPUSH
22571: LD_VAR 0 2
22575: PPUSH
22576: EMPTY
22577: PPUSH
22578: CALL_OW 1
22582: ST_TO_ADDR
// mc_miners := Replace ( mc_miners , i , [ ] ) ;
22583: LD_ADDR_EXP 88
22587: PUSH
22588: LD_EXP 88
22592: PPUSH
22593: LD_VAR 0 2
22597: PPUSH
22598: EMPTY
22599: PPUSH
22600: CALL_OW 1
22604: ST_TO_ADDR
// mc_mines := Replace ( mc_mines , i , [ ] ) ;
22605: LD_ADDR_EXP 87
22609: PUSH
22610: LD_EXP 87
22614: PPUSH
22615: LD_VAR 0 2
22619: PPUSH
22620: EMPTY
22621: PPUSH
22622: CALL_OW 1
22626: ST_TO_ADDR
// mc_minefields := Replace ( mc_minefields , i , [ ] ) ;
22627: LD_ADDR_EXP 89
22631: PUSH
22632: LD_EXP 89
22636: PPUSH
22637: LD_VAR 0 2
22641: PPUSH
22642: EMPTY
22643: PPUSH
22644: CALL_OW 1
22648: ST_TO_ADDR
// mc_crates := Replace ( mc_crates , i , [ ] ) ;
22649: LD_ADDR_EXP 90
22653: PUSH
22654: LD_EXP 90
22658: PPUSH
22659: LD_VAR 0 2
22663: PPUSH
22664: EMPTY
22665: PPUSH
22666: CALL_OW 1
22670: ST_TO_ADDR
// mc_crates_collector := Replace ( mc_crates_collector , i , [ ] ) ;
22671: LD_ADDR_EXP 91
22675: PUSH
22676: LD_EXP 91
22680: PPUSH
22681: LD_VAR 0 2
22685: PPUSH
22686: EMPTY
22687: PPUSH
22688: CALL_OW 1
22692: ST_TO_ADDR
// mc_crates_area := Replace ( mc_crates_area , i , [ ] ) ;
22693: LD_ADDR_EXP 92
22697: PUSH
22698: LD_EXP 92
22702: PPUSH
22703: LD_VAR 0 2
22707: PPUSH
22708: EMPTY
22709: PPUSH
22710: CALL_OW 1
22714: ST_TO_ADDR
// mc_vehicles := Replace ( mc_vehicles , i , [ ] ) ;
22715: LD_ADDR_EXP 93
22719: PUSH
22720: LD_EXP 93
22724: PPUSH
22725: LD_VAR 0 2
22729: PPUSH
22730: EMPTY
22731: PPUSH
22732: CALL_OW 1
22736: ST_TO_ADDR
// mc_attack := Replace ( mc_attack , i , [ ] ) ;
22737: LD_ADDR_EXP 94
22741: PUSH
22742: LD_EXP 94
22746: PPUSH
22747: LD_VAR 0 2
22751: PPUSH
22752: EMPTY
22753: PPUSH
22754: CALL_OW 1
22758: ST_TO_ADDR
// mc_produce := Replace ( mc_produce , i , [ ] ) ;
22759: LD_ADDR_EXP 95
22763: PUSH
22764: LD_EXP 95
22768: PPUSH
22769: LD_VAR 0 2
22773: PPUSH
22774: EMPTY
22775: PPUSH
22776: CALL_OW 1
22780: ST_TO_ADDR
// mc_defender := Replace ( mc_defender , i , [ ] ) ;
22781: LD_ADDR_EXP 96
22785: PUSH
22786: LD_EXP 96
22790: PPUSH
22791: LD_VAR 0 2
22795: PPUSH
22796: EMPTY
22797: PPUSH
22798: CALL_OW 1
22802: ST_TO_ADDR
// mc_defender_limit := Replace ( mc_defender_limit , i , 0 ) ;
22803: LD_ADDR_EXP 85
22807: PUSH
22808: LD_EXP 85
22812: PPUSH
22813: LD_VAR 0 2
22817: PPUSH
22818: LD_INT 0
22820: PPUSH
22821: CALL_OW 1
22825: ST_TO_ADDR
// mc_parking := Replace ( mc_parking , i , 0 ) ;
22826: LD_ADDR_EXP 98
22830: PUSH
22831: LD_EXP 98
22835: PPUSH
22836: LD_VAR 0 2
22840: PPUSH
22841: LD_INT 0
22843: PPUSH
22844: CALL_OW 1
22848: ST_TO_ADDR
// mc_repair_vehicle := Replace ( mc_repair_vehicle , i , [ ] ) ;
22849: LD_ADDR_EXP 86
22853: PUSH
22854: LD_EXP 86
22858: PPUSH
22859: LD_VAR 0 2
22863: PPUSH
22864: EMPTY
22865: PPUSH
22866: CALL_OW 1
22870: ST_TO_ADDR
// mc_scan := Replace ( mc_scan , i , 0 ) ;
22871: LD_ADDR_EXP 97
22875: PUSH
22876: LD_EXP 97
22880: PPUSH
22881: LD_VAR 0 2
22885: PPUSH
22886: LD_INT 0
22888: PPUSH
22889: CALL_OW 1
22893: ST_TO_ADDR
// mc_scan_area := Replace ( mc_scan_area , i , [ ] ) ;
22894: LD_ADDR_EXP 99
22898: PUSH
22899: LD_EXP 99
22903: PPUSH
22904: LD_VAR 0 2
22908: PPUSH
22909: EMPTY
22910: PPUSH
22911: CALL_OW 1
22915: ST_TO_ADDR
// mc_can_tame := Replace ( mc_can_tame , i , 0 ) ;
22916: LD_ADDR_EXP 102
22920: PUSH
22921: LD_EXP 102
22925: PPUSH
22926: LD_VAR 0 2
22930: PPUSH
22931: LD_INT 0
22933: PPUSH
22934: CALL_OW 1
22938: ST_TO_ADDR
// mc_ape := Replace ( mc_ape , i , [ ] ) ;
22939: LD_ADDR_EXP 103
22943: PUSH
22944: LD_EXP 103
22948: PPUSH
22949: LD_VAR 0 2
22953: PPUSH
22954: EMPTY
22955: PPUSH
22956: CALL_OW 1
22960: ST_TO_ADDR
// mc_ape_in_lab := Replace ( mc_ape_in_lab , i , [ ] ) ;
22961: LD_ADDR_EXP 104
22965: PUSH
22966: LD_EXP 104
22970: PPUSH
22971: LD_VAR 0 2
22975: PPUSH
22976: EMPTY
22977: PPUSH
22978: CALL_OW 1
22982: ST_TO_ADDR
// mc_taming := Replace ( mc_taming , i , [ ] ) ;
22983: LD_ADDR_EXP 105
22987: PUSH
22988: LD_EXP 105
22992: PPUSH
22993: LD_VAR 0 2
22997: PPUSH
22998: EMPTY
22999: PPUSH
23000: CALL_OW 1
23004: ST_TO_ADDR
// mc_lab := Replace ( mc_lab , i , UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_lab ] , [ f_btype , b_lab_half ] , [ f_btype , b_lab_full ] ] ) ) ;
23005: LD_ADDR_EXP 107
23009: PUSH
23010: LD_EXP 107
23014: PPUSH
23015: LD_VAR 0 2
23019: PPUSH
23020: LD_EXP 74
23024: PUSH
23025: LD_VAR 0 2
23029: ARRAY
23030: PPUSH
23031: LD_INT 2
23033: PUSH
23034: LD_INT 30
23036: PUSH
23037: LD_INT 6
23039: PUSH
23040: EMPTY
23041: LIST
23042: LIST
23043: PUSH
23044: LD_INT 30
23046: PUSH
23047: LD_INT 7
23049: PUSH
23050: EMPTY
23051: LIST
23052: LIST
23053: PUSH
23054: LD_INT 30
23056: PUSH
23057: LD_INT 8
23059: PUSH
23060: EMPTY
23061: LIST
23062: LIST
23063: PUSH
23064: EMPTY
23065: LIST
23066: LIST
23067: LIST
23068: LIST
23069: PPUSH
23070: CALL_OW 72
23074: PPUSH
23075: CALL_OW 1
23079: ST_TO_ADDR
// mc_lab_upgrade := Replace ( mc_lab_upgrade , i , [ ] ) ;
23080: LD_ADDR_EXP 108
23084: PUSH
23085: LD_EXP 108
23089: PPUSH
23090: LD_VAR 0 2
23094: PPUSH
23095: EMPTY
23096: PPUSH
23097: CALL_OW 1
23101: ST_TO_ADDR
// mc_teleport_exit := Replace ( mc_teleport_exit , i , [ ] ) ;
23102: LD_ADDR_EXP 109
23106: PUSH
23107: LD_EXP 109
23111: PPUSH
23112: LD_VAR 0 2
23116: PPUSH
23117: EMPTY
23118: PPUSH
23119: CALL_OW 1
23123: ST_TO_ADDR
// mc_teleport_exit_set := Replace ( mc_teleport_exit_set , i , [ ] ) ;
23124: LD_ADDR_EXP 110
23128: PUSH
23129: LD_EXP 110
23133: PPUSH
23134: LD_VAR 0 2
23138: PPUSH
23139: EMPTY
23140: PPUSH
23141: CALL_OW 1
23145: ST_TO_ADDR
// mc_deposits_xy := Replace ( mc_deposits_xy , i , [ ] ) ;
23146: LD_ADDR_EXP 111
23150: PUSH
23151: LD_EXP 111
23155: PPUSH
23156: LD_VAR 0 2
23160: PPUSH
23161: EMPTY
23162: PPUSH
23163: CALL_OW 1
23167: ST_TO_ADDR
// mc_deposits_finder := Replace ( mc_deposits_finder , i , [ ] ) ;
23168: LD_ADDR_EXP 112
23172: PUSH
23173: LD_EXP 112
23177: PPUSH
23178: LD_VAR 0 2
23182: PPUSH
23183: EMPTY
23184: PPUSH
23185: CALL_OW 1
23189: ST_TO_ADDR
// mc_allowed_tower_weapons := Replace ( mc_allowed_tower_weapons , i , [ ] ) ;
23190: LD_ADDR_EXP 113
23194: PUSH
23195: LD_EXP 113
23199: PPUSH
23200: LD_VAR 0 2
23204: PPUSH
23205: EMPTY
23206: PPUSH
23207: CALL_OW 1
23211: ST_TO_ADDR
// mc_remote_driver := Replace ( mc_remote_driver , i , [ ] ) ;
23212: LD_ADDR_EXP 114
23216: PUSH
23217: LD_EXP 114
23221: PPUSH
23222: LD_VAR 0 2
23226: PPUSH
23227: EMPTY
23228: PPUSH
23229: CALL_OW 1
23233: ST_TO_ADDR
// mc_class := Replace ( mc_class , i , [ ] ) ;
23234: LD_ADDR_EXP 115
23238: PUSH
23239: LD_EXP 115
23243: PPUSH
23244: LD_VAR 0 2
23248: PPUSH
23249: EMPTY
23250: PPUSH
23251: CALL_OW 1
23255: ST_TO_ADDR
// mc_class_case_use := Replace ( mc_class_case_use , i , 0 ) ;
23256: LD_ADDR_EXP 116
23260: PUSH
23261: LD_EXP 116
23265: PPUSH
23266: LD_VAR 0 2
23270: PPUSH
23271: LD_INT 0
23273: PPUSH
23274: CALL_OW 1
23278: ST_TO_ADDR
// end ;
23279: GO 22203
23281: POP
23282: POP
// MC_InitSides ( ) ;
23283: CALL 23569 0 0
// MC_InitResearch ( ) ;
23287: CALL 23308 0 0
// CustomInitMacro ( ) ;
23291: CALL 173 0 0
// skirmish := true ;
23295: LD_ADDR_EXP 72
23299: PUSH
23300: LD_INT 1
23302: ST_TO_ADDR
// end ;
23303: LD_VAR 0 1
23307: RET
// export function MC_InitResearch ( ) ; var i , j , nation , tmp , un ; begin
23308: LD_INT 0
23310: PPUSH
23311: PPUSH
23312: PPUSH
23313: PPUSH
23314: PPUSH
23315: PPUSH
// if not mc_bases then
23316: LD_EXP 74
23320: NOT
23321: IFFALSE 23325
// exit ;
23323: GO 23564
// for i = 1 to 8 do
23325: LD_ADDR_VAR 0 2
23329: PUSH
23330: DOUBLE
23331: LD_INT 1
23333: DEC
23334: ST_TO_ADDR
23335: LD_INT 8
23337: PUSH
23338: FOR_TO
23339: IFFALSE 23365
// mc_tech := Replace ( mc_tech , i , [ ] ) ;
23341: LD_ADDR_EXP 101
23345: PUSH
23346: LD_EXP 101
23350: PPUSH
23351: LD_VAR 0 2
23355: PPUSH
23356: EMPTY
23357: PPUSH
23358: CALL_OW 1
23362: ST_TO_ADDR
23363: GO 23338
23365: POP
23366: POP
// tmp := [ ] ;
23367: LD_ADDR_VAR 0 5
23371: PUSH
23372: EMPTY
23373: ST_TO_ADDR
// for i = 1 to mc_sides do
23374: LD_ADDR_VAR 0 2
23378: PUSH
23379: DOUBLE
23380: LD_INT 1
23382: DEC
23383: ST_TO_ADDR
23384: LD_EXP 100
23388: PUSH
23389: FOR_TO
23390: IFFALSE 23448
// if not mc_sides [ i ] in tmp then
23392: LD_EXP 100
23396: PUSH
23397: LD_VAR 0 2
23401: ARRAY
23402: PUSH
23403: LD_VAR 0 5
23407: IN
23408: NOT
23409: IFFALSE 23446
// tmp := Insert ( tmp , tmp + 1 , mc_sides [ i ] ) ;
23411: LD_ADDR_VAR 0 5
23415: PUSH
23416: LD_VAR 0 5
23420: PPUSH
23421: LD_VAR 0 5
23425: PUSH
23426: LD_INT 1
23428: PLUS
23429: PPUSH
23430: LD_EXP 100
23434: PUSH
23435: LD_VAR 0 2
23439: ARRAY
23440: PPUSH
23441: CALL_OW 2
23445: ST_TO_ADDR
23446: GO 23389
23448: POP
23449: POP
// if not tmp then
23450: LD_VAR 0 5
23454: NOT
23455: IFFALSE 23459
// exit ;
23457: GO 23564
// for j in tmp do
23459: LD_ADDR_VAR 0 3
23463: PUSH
23464: LD_VAR 0 5
23468: PUSH
23469: FOR_IN
23470: IFFALSE 23562
// begin un := FilterAllUnits ( [ f_side , j ] ) ;
23472: LD_ADDR_VAR 0 6
23476: PUSH
23477: LD_INT 22
23479: PUSH
23480: LD_VAR 0 3
23484: PUSH
23485: EMPTY
23486: LIST
23487: LIST
23488: PPUSH
23489: CALL_OW 69
23493: ST_TO_ADDR
// if not un then
23494: LD_VAR 0 6
23498: NOT
23499: IFFALSE 23503
// continue ;
23501: GO 23469
// nation := GetNation ( un [ 1 ] ) ;
23503: LD_ADDR_VAR 0 4
23507: PUSH
23508: LD_VAR 0 6
23512: PUSH
23513: LD_INT 1
23515: ARRAY
23516: PPUSH
23517: CALL_OW 248
23521: ST_TO_ADDR
// mc_tech := Replace ( mc_tech , j , GetTechNation ( j , nation , state_enabled ) ) ;
23522: LD_ADDR_EXP 101
23526: PUSH
23527: LD_EXP 101
23531: PPUSH
23532: LD_VAR 0 3
23536: PPUSH
23537: LD_VAR 0 3
23541: PPUSH
23542: LD_VAR 0 4
23546: PPUSH
23547: LD_INT 1
23549: PPUSH
23550: CALL 49928 0 3
23554: PPUSH
23555: CALL_OW 1
23559: ST_TO_ADDR
// end ;
23560: GO 23469
23562: POP
23563: POP
// end ;
23564: LD_VAR 0 1
23568: RET
// export function MC_InitSides ( ) ; var i ; begin
23569: LD_INT 0
23571: PPUSH
23572: PPUSH
// if not mc_bases then
23573: LD_EXP 74
23577: NOT
23578: IFFALSE 23582
// exit ;
23580: GO 23656
// for i = 1 to mc_bases do
23582: LD_ADDR_VAR 0 2
23586: PUSH
23587: DOUBLE
23588: LD_INT 1
23590: DEC
23591: ST_TO_ADDR
23592: LD_EXP 74
23596: PUSH
23597: FOR_TO
23598: IFFALSE 23654
// if mc_bases [ i ] then
23600: LD_EXP 74
23604: PUSH
23605: LD_VAR 0 2
23609: ARRAY
23610: IFFALSE 23652
// mc_sides := Replace ( mc_sides , i , GetSide ( mc_bases [ i ] [ 1 ] ) ) ;
23612: LD_ADDR_EXP 100
23616: PUSH
23617: LD_EXP 100
23621: PPUSH
23622: LD_VAR 0 2
23626: PPUSH
23627: LD_EXP 74
23631: PUSH
23632: LD_VAR 0 2
23636: ARRAY
23637: PUSH
23638: LD_INT 1
23640: ARRAY
23641: PPUSH
23642: CALL_OW 255
23646: PPUSH
23647: CALL_OW 1
23651: ST_TO_ADDR
23652: GO 23597
23654: POP
23655: POP
// end ;
23656: LD_VAR 0 1
23660: RET
// every 0 0$01 trigger skirmish do
23661: LD_EXP 72
23665: IFFALSE 23819
23667: GO 23669
23669: DISABLE
// begin enable ;
23670: ENABLE
// MC_CheckBuildings ( ) ;
23671: CALL 28317 0 0
// MC_CheckPeopleLife ( ) ;
23675: CALL 28442 0 0
// RaiseSailEvent ( 100 ) ;
23679: LD_INT 100
23681: PPUSH
23682: CALL_OW 427
// RaiseSailEvent ( 103 ) ;
23686: LD_INT 103
23688: PPUSH
23689: CALL_OW 427
// RaiseSailEvent ( 104 ) ;
23693: LD_INT 104
23695: PPUSH
23696: CALL_OW 427
// RaiseSailEvent ( 105 ) ;
23700: LD_INT 105
23702: PPUSH
23703: CALL_OW 427
// RaiseSailEvent ( 106 ) ;
23707: LD_INT 106
23709: PPUSH
23710: CALL_OW 427
// RaiseSailEvent ( 107 ) ;
23714: LD_INT 107
23716: PPUSH
23717: CALL_OW 427
// RaiseSailEvent ( 108 ) ;
23721: LD_INT 108
23723: PPUSH
23724: CALL_OW 427
// RaiseSailEvent ( 109 ) ;
23728: LD_INT 109
23730: PPUSH
23731: CALL_OW 427
// RaiseSailEvent ( 110 ) ;
23735: LD_INT 110
23737: PPUSH
23738: CALL_OW 427
// RaiseSailEvent ( 111 ) ;
23742: LD_INT 111
23744: PPUSH
23745: CALL_OW 427
// RaiseSailEvent ( 112 ) ;
23749: LD_INT 112
23751: PPUSH
23752: CALL_OW 427
// RaiseSailEvent ( 113 ) ;
23756: LD_INT 113
23758: PPUSH
23759: CALL_OW 427
// RaiseSailEvent ( 120 ) ;
23763: LD_INT 120
23765: PPUSH
23766: CALL_OW 427
// RaiseSailEvent ( 121 ) ;
23770: LD_INT 121
23772: PPUSH
23773: CALL_OW 427
// RaiseSailEvent ( 122 ) ;
23777: LD_INT 122
23779: PPUSH
23780: CALL_OW 427
// RaiseSailEvent ( 123 ) ;
23784: LD_INT 123
23786: PPUSH
23787: CALL_OW 427
// RaiseSailEvent ( 124 ) ;
23791: LD_INT 124
23793: PPUSH
23794: CALL_OW 427
// RaiseSailEvent ( 125 ) ;
23798: LD_INT 125
23800: PPUSH
23801: CALL_OW 427
// RaiseSailEvent ( 126 ) ;
23805: LD_INT 126
23807: PPUSH
23808: CALL_OW 427
// RaiseSailEvent ( 200 ) ;
23812: LD_INT 200
23814: PPUSH
23815: CALL_OW 427
// end ;
23819: END
// on SailEvent ( event ) do begin if event < 100 then
23820: LD_VAR 0 1
23824: PUSH
23825: LD_INT 100
23827: LESS
23828: IFFALSE 23839
// CustomEvent ( event ) ;
23830: LD_VAR 0 1
23834: PPUSH
23835: CALL 10216 0 1
// if event = 100 then
23839: LD_VAR 0 1
23843: PUSH
23844: LD_INT 100
23846: EQUAL
23847: IFFALSE 23853
// MC_ClassManager ( ) ;
23849: CALL 24245 0 0
// if event = 101 then
23853: LD_VAR 0 1
23857: PUSH
23858: LD_INT 101
23860: EQUAL
23861: IFFALSE 23867
// MC_RepairBuildings ( ) ;
23863: CALL 29038 0 0
// if event = 102 then
23867: LD_VAR 0 1
23871: PUSH
23872: LD_INT 102
23874: EQUAL
23875: IFFALSE 23881
// MC_Heal ( ) ;
23877: CALL 29770 0 0
// if event = 103 then
23881: LD_VAR 0 1
23885: PUSH
23886: LD_INT 103
23888: EQUAL
23889: IFFALSE 23895
// MC_Build ( ) ;
23891: CALL 30192 0 0
// if event = 104 then
23895: LD_VAR 0 1
23899: PUSH
23900: LD_INT 104
23902: EQUAL
23903: IFFALSE 23909
// MC_TurretWeapon ( ) ;
23905: CALL 31805 0 0
// if event = 105 then
23909: LD_VAR 0 1
23913: PUSH
23914: LD_INT 105
23916: EQUAL
23917: IFFALSE 23923
// MC_BuildUpgrade ( ) ;
23919: CALL 31356 0 0
// if event = 106 then
23923: LD_VAR 0 1
23927: PUSH
23928: LD_INT 106
23930: EQUAL
23931: IFFALSE 23937
// MC_PlantMines ( ) ;
23933: CALL 32235 0 0
// if event = 107 then
23937: LD_VAR 0 1
23941: PUSH
23942: LD_INT 107
23944: EQUAL
23945: IFFALSE 23951
// MC_CollectCrates ( ) ;
23947: CALL 33269 0 0
// if event = 108 then
23951: LD_VAR 0 1
23955: PUSH
23956: LD_INT 108
23958: EQUAL
23959: IFFALSE 23965
// MC_LinkRemoteControl ( ) ;
23961: CALL 35045 0 0
// if event = 109 then
23965: LD_VAR 0 1
23969: PUSH
23970: LD_INT 109
23972: EQUAL
23973: IFFALSE 23979
// MC_ProduceVehicle ( ) ;
23975: CALL 35226 0 0
// if event = 110 then
23979: LD_VAR 0 1
23983: PUSH
23984: LD_INT 110
23986: EQUAL
23987: IFFALSE 23993
// MC_SendAttack ( ) ;
23989: CALL 35692 0 0
// if event = 111 then
23993: LD_VAR 0 1
23997: PUSH
23998: LD_INT 111
24000: EQUAL
24001: IFFALSE 24007
// MC_Defend ( ) ;
24003: CALL 35800 0 0
// if event = 112 then
24007: LD_VAR 0 1
24011: PUSH
24012: LD_INT 112
24014: EQUAL
24015: IFFALSE 24021
// MC_Research ( ) ;
24017: CALL 36405 0 0
// if event = 113 then
24021: LD_VAR 0 1
24025: PUSH
24026: LD_INT 113
24028: EQUAL
24029: IFFALSE 24035
// MC_MinesTrigger ( ) ;
24031: CALL 37519 0 0
// if event = 120 then
24035: LD_VAR 0 1
24039: PUSH
24040: LD_INT 120
24042: EQUAL
24043: IFFALSE 24049
// MC_RepairVehicle ( ) ;
24045: CALL 37618 0 0
// if event = 121 then
24049: LD_VAR 0 1
24053: PUSH
24054: LD_INT 121
24056: EQUAL
24057: IFFALSE 24063
// MC_TameApe ( ) ;
24059: CALL 38348 0 0
// if event = 122 then
24063: LD_VAR 0 1
24067: PUSH
24068: LD_INT 122
24070: EQUAL
24071: IFFALSE 24077
// MC_ChangeApeClass ( ) ;
24073: CALL 39177 0 0
// if event = 123 then
24077: LD_VAR 0 1
24081: PUSH
24082: LD_INT 123
24084: EQUAL
24085: IFFALSE 24091
// MC_Bazooka ( ) ;
24087: CALL 39827 0 0
// if event = 124 then
24091: LD_VAR 0 1
24095: PUSH
24096: LD_INT 124
24098: EQUAL
24099: IFFALSE 24105
// MC_TeleportExit ( ) ;
24101: CALL 40025 0 0
// if event = 125 then
24105: LD_VAR 0 1
24109: PUSH
24110: LD_INT 125
24112: EQUAL
24113: IFFALSE 24119
// MC_Deposits ( ) ;
24115: CALL 40672 0 0
// if event = 126 then
24119: LD_VAR 0 1
24123: PUSH
24124: LD_INT 126
24126: EQUAL
24127: IFFALSE 24133
// MC_RemoteDriver ( ) ;
24129: CALL 41297 0 0
// if event = 200 then
24133: LD_VAR 0 1
24137: PUSH
24138: LD_INT 200
24140: EQUAL
24141: IFFALSE 24147
// MC_Idle ( ) ;
24143: CALL 43030 0 0
// end ;
24147: PPOPN 1
24149: END
// export function MC_Reset ( base , tag ) ; var i ; begin
24150: LD_INT 0
24152: PPUSH
24153: PPUSH
// if not mc_bases [ base ] or not tag then
24154: LD_EXP 74
24158: PUSH
24159: LD_VAR 0 1
24163: ARRAY
24164: NOT
24165: PUSH
24166: LD_VAR 0 2
24170: NOT
24171: OR
24172: IFFALSE 24176
// exit ;
24174: GO 24240
// for i in mc_bases [ base ] union mc_ape [ base ] do
24176: LD_ADDR_VAR 0 4
24180: PUSH
24181: LD_EXP 74
24185: PUSH
24186: LD_VAR 0 1
24190: ARRAY
24191: PUSH
24192: LD_EXP 103
24196: PUSH
24197: LD_VAR 0 1
24201: ARRAY
24202: UNION
24203: PUSH
24204: FOR_IN
24205: IFFALSE 24238
// if GetTag ( i ) = tag then
24207: LD_VAR 0 4
24211: PPUSH
24212: CALL_OW 110
24216: PUSH
24217: LD_VAR 0 2
24221: EQUAL
24222: IFFALSE 24236
// SetTag ( i , 0 ) ;
24224: LD_VAR 0 4
24228: PPUSH
24229: LD_INT 0
24231: PPUSH
24232: CALL_OW 109
24236: GO 24204
24238: POP
24239: POP
// end ;
24240: LD_VAR 0 3
24244: RET
// export function MC_ClassManager ( ) ; var i , j , tmp , p , b , e , k ; begin
24245: LD_INT 0
24247: PPUSH
24248: PPUSH
24249: PPUSH
24250: PPUSH
24251: PPUSH
24252: PPUSH
24253: PPUSH
24254: PPUSH
// if not mc_bases then
24255: LD_EXP 74
24259: NOT
24260: IFFALSE 24264
// exit ;
24262: GO 24722
// for i = 1 to mc_bases do
24264: LD_ADDR_VAR 0 2
24268: PUSH
24269: DOUBLE
24270: LD_INT 1
24272: DEC
24273: ST_TO_ADDR
24274: LD_EXP 74
24278: PUSH
24279: FOR_TO
24280: IFFALSE 24720
// begin tmp := MC_ClassCheckReq ( i ) ;
24282: LD_ADDR_VAR 0 4
24286: PUSH
24287: LD_VAR 0 2
24291: PPUSH
24292: CALL 24727 0 1
24296: ST_TO_ADDR
// mc_class := Replace ( mc_class , i , tmp ) ;
24297: LD_ADDR_EXP 115
24301: PUSH
24302: LD_EXP 115
24306: PPUSH
24307: LD_VAR 0 2
24311: PPUSH
24312: LD_VAR 0 4
24316: PPUSH
24317: CALL_OW 1
24321: ST_TO_ADDR
// if not tmp then
24322: LD_VAR 0 4
24326: NOT
24327: IFFALSE 24331
// continue ;
24329: GO 24279
// b := [ UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_armoury ] , [ f_btype , b_barracks ] ] ) , UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) , UnitFilter ( mc_bases [ i ] , [ f_btype , b_factory ] ) , UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_lab ] , [ f_btype , b_lab_half ] , [ f_btype , b_lab_full ] ] ) ] ;
24331: LD_ADDR_VAR 0 6
24335: PUSH
24336: LD_EXP 74
24340: PUSH
24341: LD_VAR 0 2
24345: ARRAY
24346: PPUSH
24347: LD_INT 2
24349: PUSH
24350: LD_INT 30
24352: PUSH
24353: LD_INT 4
24355: PUSH
24356: EMPTY
24357: LIST
24358: LIST
24359: PUSH
24360: LD_INT 30
24362: PUSH
24363: LD_INT 5
24365: PUSH
24366: EMPTY
24367: LIST
24368: LIST
24369: PUSH
24370: EMPTY
24371: LIST
24372: LIST
24373: LIST
24374: PPUSH
24375: CALL_OW 72
24379: PUSH
24380: LD_EXP 74
24384: PUSH
24385: LD_VAR 0 2
24389: ARRAY
24390: PPUSH
24391: LD_INT 2
24393: PUSH
24394: LD_INT 30
24396: PUSH
24397: LD_INT 0
24399: PUSH
24400: EMPTY
24401: LIST
24402: LIST
24403: PUSH
24404: LD_INT 30
24406: PUSH
24407: LD_INT 1
24409: PUSH
24410: EMPTY
24411: LIST
24412: LIST
24413: PUSH
24414: EMPTY
24415: LIST
24416: LIST
24417: LIST
24418: PPUSH
24419: CALL_OW 72
24423: PUSH
24424: LD_EXP 74
24428: PUSH
24429: LD_VAR 0 2
24433: ARRAY
24434: PPUSH
24435: LD_INT 30
24437: PUSH
24438: LD_INT 3
24440: PUSH
24441: EMPTY
24442: LIST
24443: LIST
24444: PPUSH
24445: CALL_OW 72
24449: PUSH
24450: LD_EXP 74
24454: PUSH
24455: LD_VAR 0 2
24459: ARRAY
24460: PPUSH
24461: LD_INT 2
24463: PUSH
24464: LD_INT 30
24466: PUSH
24467: LD_INT 6
24469: PUSH
24470: EMPTY
24471: LIST
24472: LIST
24473: PUSH
24474: LD_INT 30
24476: PUSH
24477: LD_INT 7
24479: PUSH
24480: EMPTY
24481: LIST
24482: LIST
24483: PUSH
24484: LD_INT 30
24486: PUSH
24487: LD_INT 8
24489: PUSH
24490: EMPTY
24491: LIST
24492: LIST
24493: PUSH
24494: EMPTY
24495: LIST
24496: LIST
24497: LIST
24498: LIST
24499: PPUSH
24500: CALL_OW 72
24504: PUSH
24505: EMPTY
24506: LIST
24507: LIST
24508: LIST
24509: LIST
24510: ST_TO_ADDR
// for j = 1 to 4 do
24511: LD_ADDR_VAR 0 3
24515: PUSH
24516: DOUBLE
24517: LD_INT 1
24519: DEC
24520: ST_TO_ADDR
24521: LD_INT 4
24523: PUSH
24524: FOR_TO
24525: IFFALSE 24716
// begin if not tmp [ j ] then
24527: LD_VAR 0 4
24531: PUSH
24532: LD_VAR 0 3
24536: ARRAY
24537: NOT
24538: IFFALSE 24542
// continue ;
24540: GO 24524
// for p in tmp [ j ] do
24542: LD_ADDR_VAR 0 5
24546: PUSH
24547: LD_VAR 0 4
24551: PUSH
24552: LD_VAR 0 3
24556: ARRAY
24557: PUSH
24558: FOR_IN
24559: IFFALSE 24712
// begin if not b [ j ] then
24561: LD_VAR 0 6
24565: PUSH
24566: LD_VAR 0 3
24570: ARRAY
24571: NOT
24572: IFFALSE 24576
// break ;
24574: GO 24712
// e := 0 ;
24576: LD_ADDR_VAR 0 7
24580: PUSH
24581: LD_INT 0
24583: ST_TO_ADDR
// for k in b [ j ] do
24584: LD_ADDR_VAR 0 8
24588: PUSH
24589: LD_VAR 0 6
24593: PUSH
24594: LD_VAR 0 3
24598: ARRAY
24599: PUSH
24600: FOR_IN
24601: IFFALSE 24628
// if IsNotFull ( k ) then
24603: LD_VAR 0 8
24607: PPUSH
24608: CALL 54219 0 1
24612: IFFALSE 24626
// begin e := k ;
24614: LD_ADDR_VAR 0 7
24618: PUSH
24619: LD_VAR 0 8
24623: ST_TO_ADDR
// break ;
24624: GO 24628
// end ;
24626: GO 24600
24628: POP
24629: POP
// if e and not UnitGoingToBuilding ( p , e ) then
24630: LD_VAR 0 7
24634: PUSH
24635: LD_VAR 0 5
24639: PPUSH
24640: LD_VAR 0 7
24644: PPUSH
24645: CALL 91338 0 2
24649: NOT
24650: AND
24651: IFFALSE 24710
// begin if IsInUnit ( p ) then
24653: LD_VAR 0 5
24657: PPUSH
24658: CALL_OW 310
24662: IFFALSE 24673
// ComExitBuilding ( p ) ;
24664: LD_VAR 0 5
24668: PPUSH
24669: CALL_OW 122
// ComEnterUnit ( p , e ) ;
24673: LD_VAR 0 5
24677: PPUSH
24678: LD_VAR 0 7
24682: PPUSH
24683: CALL_OW 120
// AddComChangeProfession ( p , j ) ;
24687: LD_VAR 0 5
24691: PPUSH
24692: LD_VAR 0 3
24696: PPUSH
24697: CALL_OW 183
// AddComExitBuilding ( p ) ;
24701: LD_VAR 0 5
24705: PPUSH
24706: CALL_OW 182
// end ; end ;
24710: GO 24558
24712: POP
24713: POP
// end ;
24714: GO 24524
24716: POP
24717: POP
// end ;
24718: GO 24279
24720: POP
24721: POP
// end ;
24722: LD_VAR 0 1
24726: RET
// export function MC_ClassCheckReq ( base ) ; var i , tmp , sol , eng , mech , sci , sort , j , p , b , bcount ; begin
24727: LD_INT 0
24729: PPUSH
24730: PPUSH
24731: PPUSH
24732: PPUSH
24733: PPUSH
24734: PPUSH
24735: PPUSH
24736: PPUSH
24737: PPUSH
24738: PPUSH
24739: PPUSH
24740: PPUSH
// if not base or not mc_bases [ base ] or not UnitFilter ( mc_bases [ base ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) then
24741: LD_VAR 0 1
24745: NOT
24746: PUSH
24747: LD_EXP 74
24751: PUSH
24752: LD_VAR 0 1
24756: ARRAY
24757: NOT
24758: OR
24759: PUSH
24760: LD_EXP 74
24764: PUSH
24765: LD_VAR 0 1
24769: ARRAY
24770: PPUSH
24771: LD_INT 2
24773: PUSH
24774: LD_INT 30
24776: PUSH
24777: LD_INT 0
24779: PUSH
24780: EMPTY
24781: LIST
24782: LIST
24783: PUSH
24784: LD_INT 30
24786: PUSH
24787: LD_INT 1
24789: PUSH
24790: EMPTY
24791: LIST
24792: LIST
24793: PUSH
24794: EMPTY
24795: LIST
24796: LIST
24797: LIST
24798: PPUSH
24799: CALL_OW 72
24803: NOT
24804: OR
24805: IFFALSE 24809
// exit ;
24807: GO 28312
// tmp := UnitFilter ( mc_bases [ base ] , [ f_or , [ f_class , 1 ] , [ f_class , 2 ] , [ f_class , 3 ] , [ f_class , 4 ] , [ f_class , 5 ] , [ f_class , 8 ] , [ f_class , 9 ] ] ) ;
24809: LD_ADDR_VAR 0 4
24813: PUSH
24814: LD_EXP 74
24818: PUSH
24819: LD_VAR 0 1
24823: ARRAY
24824: PPUSH
24825: LD_INT 2
24827: PUSH
24828: LD_INT 25
24830: PUSH
24831: LD_INT 1
24833: PUSH
24834: EMPTY
24835: LIST
24836: LIST
24837: PUSH
24838: LD_INT 25
24840: PUSH
24841: LD_INT 2
24843: PUSH
24844: EMPTY
24845: LIST
24846: LIST
24847: PUSH
24848: LD_INT 25
24850: PUSH
24851: LD_INT 3
24853: PUSH
24854: EMPTY
24855: LIST
24856: LIST
24857: PUSH
24858: LD_INT 25
24860: PUSH
24861: LD_INT 4
24863: PUSH
24864: EMPTY
24865: LIST
24866: LIST
24867: PUSH
24868: LD_INT 25
24870: PUSH
24871: LD_INT 5
24873: PUSH
24874: EMPTY
24875: LIST
24876: LIST
24877: PUSH
24878: LD_INT 25
24880: PUSH
24881: LD_INT 8
24883: PUSH
24884: EMPTY
24885: LIST
24886: LIST
24887: PUSH
24888: LD_INT 25
24890: PUSH
24891: LD_INT 9
24893: PUSH
24894: EMPTY
24895: LIST
24896: LIST
24897: PUSH
24898: EMPTY
24899: LIST
24900: LIST
24901: LIST
24902: LIST
24903: LIST
24904: LIST
24905: LIST
24906: LIST
24907: PPUSH
24908: CALL_OW 72
24912: ST_TO_ADDR
// if not tmp then
24913: LD_VAR 0 4
24917: NOT
24918: IFFALSE 24922
// exit ;
24920: GO 28312
// for i in tmp do
24922: LD_ADDR_VAR 0 3
24926: PUSH
24927: LD_VAR 0 4
24931: PUSH
24932: FOR_IN
24933: IFFALSE 24964
// if GetTag ( i ) then
24935: LD_VAR 0 3
24939: PPUSH
24940: CALL_OW 110
24944: IFFALSE 24962
// tmp := tmp diff i ;
24946: LD_ADDR_VAR 0 4
24950: PUSH
24951: LD_VAR 0 4
24955: PUSH
24956: LD_VAR 0 3
24960: DIFF
24961: ST_TO_ADDR
24962: GO 24932
24964: POP
24965: POP
// if not tmp then
24966: LD_VAR 0 4
24970: NOT
24971: IFFALSE 24975
// exit ;
24973: GO 28312
// sol := UnitFilter ( mc_bases [ base ] , [ f_or , [ f_class , 1 ] , [ f_class , 5 ] , [ f_class , 8 ] , [ f_class , 9 ] ] ) ;
24975: LD_ADDR_VAR 0 5
24979: PUSH
24980: LD_EXP 74
24984: PUSH
24985: LD_VAR 0 1
24989: ARRAY
24990: PPUSH
24991: LD_INT 2
24993: PUSH
24994: LD_INT 25
24996: PUSH
24997: LD_INT 1
24999: PUSH
25000: EMPTY
25001: LIST
25002: LIST
25003: PUSH
25004: LD_INT 25
25006: PUSH
25007: LD_INT 5
25009: PUSH
25010: EMPTY
25011: LIST
25012: LIST
25013: PUSH
25014: LD_INT 25
25016: PUSH
25017: LD_INT 8
25019: PUSH
25020: EMPTY
25021: LIST
25022: LIST
25023: PUSH
25024: LD_INT 25
25026: PUSH
25027: LD_INT 9
25029: PUSH
25030: EMPTY
25031: LIST
25032: LIST
25033: PUSH
25034: EMPTY
25035: LIST
25036: LIST
25037: LIST
25038: LIST
25039: LIST
25040: PPUSH
25041: CALL_OW 72
25045: ST_TO_ADDR
// eng := UnitFilter ( mc_bases [ base ] , [ f_class , 2 ] ) ;
25046: LD_ADDR_VAR 0 6
25050: PUSH
25051: LD_EXP 74
25055: PUSH
25056: LD_VAR 0 1
25060: ARRAY
25061: PPUSH
25062: LD_INT 25
25064: PUSH
25065: LD_INT 2
25067: PUSH
25068: EMPTY
25069: LIST
25070: LIST
25071: PPUSH
25072: CALL_OW 72
25076: ST_TO_ADDR
// mech := UnitFilter ( mc_bases [ base ] , [ f_class , 3 ] ) ;
25077: LD_ADDR_VAR 0 7
25081: PUSH
25082: LD_EXP 74
25086: PUSH
25087: LD_VAR 0 1
25091: ARRAY
25092: PPUSH
25093: LD_INT 25
25095: PUSH
25096: LD_INT 3
25098: PUSH
25099: EMPTY
25100: LIST
25101: LIST
25102: PPUSH
25103: CALL_OW 72
25107: ST_TO_ADDR
// sci := UnitFilter ( mc_bases [ base ] , [ [ f_class , 4 ] , [ f_lives , 251 ] ] ) ;
25108: LD_ADDR_VAR 0 8
25112: PUSH
25113: LD_EXP 74
25117: PUSH
25118: LD_VAR 0 1
25122: ARRAY
25123: PPUSH
25124: LD_INT 25
25126: PUSH
25127: LD_INT 4
25129: PUSH
25130: EMPTY
25131: LIST
25132: LIST
25133: PUSH
25134: LD_INT 24
25136: PUSH
25137: LD_INT 251
25139: PUSH
25140: EMPTY
25141: LIST
25142: LIST
25143: PUSH
25144: EMPTY
25145: LIST
25146: LIST
25147: PPUSH
25148: CALL_OW 72
25152: ST_TO_ADDR
// if mc_scan [ base ] then
25153: LD_EXP 97
25157: PUSH
25158: LD_VAR 0 1
25162: ARRAY
25163: IFFALSE 25624
// begin mc_class_case_use := Replace ( mc_class_case_use , base , 4 ) ;
25165: LD_ADDR_EXP 116
25169: PUSH
25170: LD_EXP 116
25174: PPUSH
25175: LD_VAR 0 1
25179: PPUSH
25180: LD_INT 4
25182: PPUSH
25183: CALL_OW 1
25187: ST_TO_ADDR
// b := UnitFilter ( mc_bases [ base ] , [ f_or , [ f_btype , b_armoury ] , [ f_btype , b_barracks ] ] ) ;
25188: LD_ADDR_VAR 0 12
25192: PUSH
25193: LD_EXP 74
25197: PUSH
25198: LD_VAR 0 1
25202: ARRAY
25203: PPUSH
25204: LD_INT 2
25206: PUSH
25207: LD_INT 30
25209: PUSH
25210: LD_INT 4
25212: PUSH
25213: EMPTY
25214: LIST
25215: LIST
25216: PUSH
25217: LD_INT 30
25219: PUSH
25220: LD_INT 5
25222: PUSH
25223: EMPTY
25224: LIST
25225: LIST
25226: PUSH
25227: EMPTY
25228: LIST
25229: LIST
25230: LIST
25231: PPUSH
25232: CALL_OW 72
25236: ST_TO_ADDR
// if not b then
25237: LD_VAR 0 12
25241: NOT
25242: IFFALSE 25246
// exit ;
25244: GO 28312
// p := [ ] ;
25246: LD_ADDR_VAR 0 11
25250: PUSH
25251: EMPTY
25252: ST_TO_ADDR
// if sci >= 2 then
25253: LD_VAR 0 8
25257: PUSH
25258: LD_INT 2
25260: GREATEREQUAL
25261: IFFALSE 25292
// sci := [ sci [ 1 ] , sci [ 2 ] ] else
25263: LD_ADDR_VAR 0 8
25267: PUSH
25268: LD_VAR 0 8
25272: PUSH
25273: LD_INT 1
25275: ARRAY
25276: PUSH
25277: LD_VAR 0 8
25281: PUSH
25282: LD_INT 2
25284: ARRAY
25285: PUSH
25286: EMPTY
25287: LIST
25288: LIST
25289: ST_TO_ADDR
25290: GO 25353
// if sci = 1 then
25292: LD_VAR 0 8
25296: PUSH
25297: LD_INT 1
25299: EQUAL
25300: IFFALSE 25321
// sci := [ sci [ 1 ] ] else
25302: LD_ADDR_VAR 0 8
25306: PUSH
25307: LD_VAR 0 8
25311: PUSH
25312: LD_INT 1
25314: ARRAY
25315: PUSH
25316: EMPTY
25317: LIST
25318: ST_TO_ADDR
25319: GO 25353
// if sci = 0 then
25321: LD_VAR 0 8
25325: PUSH
25326: LD_INT 0
25328: EQUAL
25329: IFFALSE 25353
// p := SortBySkill ( tmp , 4 ) [ 1 ] ;
25331: LD_ADDR_VAR 0 11
25335: PUSH
25336: LD_VAR 0 4
25340: PPUSH
25341: LD_INT 4
25343: PPUSH
25344: CALL 91201 0 2
25348: PUSH
25349: LD_INT 1
25351: ARRAY
25352: ST_TO_ADDR
// if eng > 4 then
25353: LD_VAR 0 6
25357: PUSH
25358: LD_INT 4
25360: GREATER
25361: IFFALSE 25407
// for i = eng downto 4 do
25363: LD_ADDR_VAR 0 3
25367: PUSH
25368: DOUBLE
25369: LD_VAR 0 6
25373: INC
25374: ST_TO_ADDR
25375: LD_INT 4
25377: PUSH
25378: FOR_DOWNTO
25379: IFFALSE 25405
// eng := eng diff eng [ i ] ;
25381: LD_ADDR_VAR 0 6
25385: PUSH
25386: LD_VAR 0 6
25390: PUSH
25391: LD_VAR 0 6
25395: PUSH
25396: LD_VAR 0 3
25400: ARRAY
25401: DIFF
25402: ST_TO_ADDR
25403: GO 25378
25405: POP
25406: POP
// tmp := tmp diff ( sol union eng union mech union sci ) ;
25407: LD_ADDR_VAR 0 4
25411: PUSH
25412: LD_VAR 0 4
25416: PUSH
25417: LD_VAR 0 5
25421: PUSH
25422: LD_VAR 0 6
25426: UNION
25427: PUSH
25428: LD_VAR 0 7
25432: UNION
25433: PUSH
25434: LD_VAR 0 8
25438: UNION
25439: DIFF
25440: ST_TO_ADDR
// bcount := UnitFilter ( mc_bases [ base ] , [ f_or , [ f_btype , b_bunker ] , [ f_btype , b_breastwork ] ] ) + UnitFilter ( mc_bases [ base ] , [ f_or , [ f_btype , b_armoury ] , [ f_btype , b_barracks ] ] ) * 6 ;
25441: LD_ADDR_VAR 0 13
25445: PUSH
25446: LD_EXP 74
25450: PUSH
25451: LD_VAR 0 1
25455: ARRAY
25456: PPUSH
25457: LD_INT 2
25459: PUSH
25460: LD_INT 30
25462: PUSH
25463: LD_INT 32
25465: PUSH
25466: EMPTY
25467: LIST
25468: LIST
25469: PUSH
25470: LD_INT 30
25472: PUSH
25473: LD_INT 31
25475: PUSH
25476: EMPTY
25477: LIST
25478: LIST
25479: PUSH
25480: EMPTY
25481: LIST
25482: LIST
25483: LIST
25484: PPUSH
25485: CALL_OW 72
25489: PUSH
25490: LD_EXP 74
25494: PUSH
25495: LD_VAR 0 1
25499: ARRAY
25500: PPUSH
25501: LD_INT 2
25503: PUSH
25504: LD_INT 30
25506: PUSH
25507: LD_INT 4
25509: PUSH
25510: EMPTY
25511: LIST
25512: LIST
25513: PUSH
25514: LD_INT 30
25516: PUSH
25517: LD_INT 5
25519: PUSH
25520: EMPTY
25521: LIST
25522: LIST
25523: PUSH
25524: EMPTY
25525: LIST
25526: LIST
25527: LIST
25528: PPUSH
25529: CALL_OW 72
25533: PUSH
25534: LD_INT 6
25536: MUL
25537: PLUS
25538: ST_TO_ADDR
// if bcount < tmp then
25539: LD_VAR 0 13
25543: PUSH
25544: LD_VAR 0 4
25548: LESS
25549: IFFALSE 25595
// for i = tmp downto bcount do
25551: LD_ADDR_VAR 0 3
25555: PUSH
25556: DOUBLE
25557: LD_VAR 0 4
25561: INC
25562: ST_TO_ADDR
25563: LD_VAR 0 13
25567: PUSH
25568: FOR_DOWNTO
25569: IFFALSE 25593
// tmp := Delete ( tmp , tmp ) ;
25571: LD_ADDR_VAR 0 4
25575: PUSH
25576: LD_VAR 0 4
25580: PPUSH
25581: LD_VAR 0 4
25585: PPUSH
25586: CALL_OW 3
25590: ST_TO_ADDR
25591: GO 25568
25593: POP
25594: POP
// result := [ tmp , 0 , 0 , p ] ;
25595: LD_ADDR_VAR 0 2
25599: PUSH
25600: LD_VAR 0 4
25604: PUSH
25605: LD_INT 0
25607: PUSH
25608: LD_INT 0
25610: PUSH
25611: LD_VAR 0 11
25615: PUSH
25616: EMPTY
25617: LIST
25618: LIST
25619: LIST
25620: LIST
25621: ST_TO_ADDR
// exit ;
25622: GO 28312
// end ; if not UnitFilter ( mc_bases [ base ] , [ f_or , [ f_btype , b_lab ] , [ f_btype , b_lab_half ] , [ f_btype , b_lab_full ] ] ) and not UnitFilter ( mc_bases [ base ] , [ f_btype , b_factory ] ) then
25624: LD_EXP 74
25628: PUSH
25629: LD_VAR 0 1
25633: ARRAY
25634: PPUSH
25635: LD_INT 2
25637: PUSH
25638: LD_INT 30
25640: PUSH
25641: LD_INT 6
25643: PUSH
25644: EMPTY
25645: LIST
25646: LIST
25647: PUSH
25648: LD_INT 30
25650: PUSH
25651: LD_INT 7
25653: PUSH
25654: EMPTY
25655: LIST
25656: LIST
25657: PUSH
25658: LD_INT 30
25660: PUSH
25661: LD_INT 8
25663: PUSH
25664: EMPTY
25665: LIST
25666: LIST
25667: PUSH
25668: EMPTY
25669: LIST
25670: LIST
25671: LIST
25672: LIST
25673: PPUSH
25674: CALL_OW 72
25678: NOT
25679: PUSH
25680: LD_EXP 74
25684: PUSH
25685: LD_VAR 0 1
25689: ARRAY
25690: PPUSH
25691: LD_INT 30
25693: PUSH
25694: LD_INT 3
25696: PUSH
25697: EMPTY
25698: LIST
25699: LIST
25700: PPUSH
25701: CALL_OW 72
25705: NOT
25706: AND
25707: IFFALSE 25779
// begin if eng = tmp then
25709: LD_VAR 0 6
25713: PUSH
25714: LD_VAR 0 4
25718: EQUAL
25719: IFFALSE 25723
// exit ;
25721: GO 28312
// mc_class_case_use := Replace ( mc_class_case_use , base , 1 ) ;
25723: LD_ADDR_EXP 116
25727: PUSH
25728: LD_EXP 116
25732: PPUSH
25733: LD_VAR 0 1
25737: PPUSH
25738: LD_INT 1
25740: PPUSH
25741: CALL_OW 1
25745: ST_TO_ADDR
// result := [ 0 , tmp diff eng , 0 , 0 ] ;
25746: LD_ADDR_VAR 0 2
25750: PUSH
25751: LD_INT 0
25753: PUSH
25754: LD_VAR 0 4
25758: PUSH
25759: LD_VAR 0 6
25763: DIFF
25764: PUSH
25765: LD_INT 0
25767: PUSH
25768: LD_INT 0
25770: PUSH
25771: EMPTY
25772: LIST
25773: LIST
25774: LIST
25775: LIST
25776: ST_TO_ADDR
// exit ;
25777: GO 28312
// end ; if mc_tech [ mc_sides [ base ] ] and UnitFilter ( mc_bases [ base ] , [ f_or , [ f_btype , b_lab ] , [ f_btype , b_lab_half ] , [ f_btype , b_lab_full ] ] ) and not UnitFilter ( mc_bases [ base ] , [ f_btype , b_factory ] ) then
25779: LD_EXP 101
25783: PUSH
25784: LD_EXP 100
25788: PUSH
25789: LD_VAR 0 1
25793: ARRAY
25794: ARRAY
25795: PUSH
25796: LD_EXP 74
25800: PUSH
25801: LD_VAR 0 1
25805: ARRAY
25806: PPUSH
25807: LD_INT 2
25809: PUSH
25810: LD_INT 30
25812: PUSH
25813: LD_INT 6
25815: PUSH
25816: EMPTY
25817: LIST
25818: LIST
25819: PUSH
25820: LD_INT 30
25822: PUSH
25823: LD_INT 7
25825: PUSH
25826: EMPTY
25827: LIST
25828: LIST
25829: PUSH
25830: LD_INT 30
25832: PUSH
25833: LD_INT 8
25835: PUSH
25836: EMPTY
25837: LIST
25838: LIST
25839: PUSH
25840: EMPTY
25841: LIST
25842: LIST
25843: LIST
25844: LIST
25845: PPUSH
25846: CALL_OW 72
25850: AND
25851: PUSH
25852: LD_EXP 74
25856: PUSH
25857: LD_VAR 0 1
25861: ARRAY
25862: PPUSH
25863: LD_INT 30
25865: PUSH
25866: LD_INT 3
25868: PUSH
25869: EMPTY
25870: LIST
25871: LIST
25872: PPUSH
25873: CALL_OW 72
25877: NOT
25878: AND
25879: IFFALSE 26093
// begin if sci >= 6 then
25881: LD_VAR 0 8
25885: PUSH
25886: LD_INT 6
25888: GREATEREQUAL
25889: IFFALSE 25893
// exit ;
25891: GO 28312
// mc_class_case_use := Replace ( mc_class_case_use , base , 2 ) ;
25893: LD_ADDR_EXP 116
25897: PUSH
25898: LD_EXP 116
25902: PPUSH
25903: LD_VAR 0 1
25907: PPUSH
25908: LD_INT 2
25910: PPUSH
25911: CALL_OW 1
25915: ST_TO_ADDR
// sort := SortBySkill ( tmp diff sci , 4 ) ;
25916: LD_ADDR_VAR 0 9
25920: PUSH
25921: LD_VAR 0 4
25925: PUSH
25926: LD_VAR 0 8
25930: DIFF
25931: PPUSH
25932: LD_INT 4
25934: PPUSH
25935: CALL 91201 0 2
25939: ST_TO_ADDR
// p := [ ] ;
25940: LD_ADDR_VAR 0 11
25944: PUSH
25945: EMPTY
25946: ST_TO_ADDR
// if sci < 6 and sort > 6 then
25947: LD_VAR 0 8
25951: PUSH
25952: LD_INT 6
25954: LESS
25955: PUSH
25956: LD_VAR 0 9
25960: PUSH
25961: LD_INT 6
25963: GREATER
25964: AND
25965: IFFALSE 26046
// begin for i = 1 to 6 - sci do
25967: LD_ADDR_VAR 0 3
25971: PUSH
25972: DOUBLE
25973: LD_INT 1
25975: DEC
25976: ST_TO_ADDR
25977: LD_INT 6
25979: PUSH
25980: LD_VAR 0 8
25984: MINUS
25985: PUSH
25986: FOR_TO
25987: IFFALSE 26042
// begin p := Insert ( p , p + 1 , sort [ 1 ] ) ;
25989: LD_ADDR_VAR 0 11
25993: PUSH
25994: LD_VAR 0 11
25998: PPUSH
25999: LD_VAR 0 11
26003: PUSH
26004: LD_INT 1
26006: PLUS
26007: PPUSH
26008: LD_VAR 0 9
26012: PUSH
26013: LD_INT 1
26015: ARRAY
26016: PPUSH
26017: CALL_OW 2
26021: ST_TO_ADDR
// sort := Delete ( sort , 1 ) ;
26022: LD_ADDR_VAR 0 9
26026: PUSH
26027: LD_VAR 0 9
26031: PPUSH
26032: LD_INT 1
26034: PPUSH
26035: CALL_OW 3
26039: ST_TO_ADDR
// end ;
26040: GO 25986
26042: POP
26043: POP
// end else
26044: GO 26066
// if sort then
26046: LD_VAR 0 9
26050: IFFALSE 26066
// p := sort [ 1 ] ;
26052: LD_ADDR_VAR 0 11
26056: PUSH
26057: LD_VAR 0 9
26061: PUSH
26062: LD_INT 1
26064: ARRAY
26065: ST_TO_ADDR
// result := [ 0 , 0 , 0 , p ] ;
26066: LD_ADDR_VAR 0 2
26070: PUSH
26071: LD_INT 0
26073: PUSH
26074: LD_INT 0
26076: PUSH
26077: LD_INT 0
26079: PUSH
26080: LD_VAR 0 11
26084: PUSH
26085: EMPTY
26086: LIST
26087: LIST
26088: LIST
26089: LIST
26090: ST_TO_ADDR
// exit ;
26091: GO 28312
// end ; if mc_tech [ mc_sides [ base ] ] and UnitFilter ( mc_bases [ base ] , [ f_or , [ f_btype , b_lab ] , [ f_btype , b_lab_half ] , [ f_btype , b_lab_full ] ] ) and UnitFilter ( mc_bases [ base ] , [ f_btype , b_factory ] ) then
26093: LD_EXP 101
26097: PUSH
26098: LD_EXP 100
26102: PUSH
26103: LD_VAR 0 1
26107: ARRAY
26108: ARRAY
26109: PUSH
26110: LD_EXP 74
26114: PUSH
26115: LD_VAR 0 1
26119: ARRAY
26120: PPUSH
26121: LD_INT 2
26123: PUSH
26124: LD_INT 30
26126: PUSH
26127: LD_INT 6
26129: PUSH
26130: EMPTY
26131: LIST
26132: LIST
26133: PUSH
26134: LD_INT 30
26136: PUSH
26137: LD_INT 7
26139: PUSH
26140: EMPTY
26141: LIST
26142: LIST
26143: PUSH
26144: LD_INT 30
26146: PUSH
26147: LD_INT 8
26149: PUSH
26150: EMPTY
26151: LIST
26152: LIST
26153: PUSH
26154: EMPTY
26155: LIST
26156: LIST
26157: LIST
26158: LIST
26159: PPUSH
26160: CALL_OW 72
26164: AND
26165: PUSH
26166: LD_EXP 74
26170: PUSH
26171: LD_VAR 0 1
26175: ARRAY
26176: PPUSH
26177: LD_INT 30
26179: PUSH
26180: LD_INT 3
26182: PUSH
26183: EMPTY
26184: LIST
26185: LIST
26186: PPUSH
26187: CALL_OW 72
26191: AND
26192: IFFALSE 26926
// begin mc_class_case_use := Replace ( mc_class_case_use , base , 3 ) ;
26194: LD_ADDR_EXP 116
26198: PUSH
26199: LD_EXP 116
26203: PPUSH
26204: LD_VAR 0 1
26208: PPUSH
26209: LD_INT 3
26211: PPUSH
26212: CALL_OW 1
26216: ST_TO_ADDR
// result := [ 0 , 0 , 0 , 0 ] ;
26217: LD_ADDR_VAR 0 2
26221: PUSH
26222: LD_INT 0
26224: PUSH
26225: LD_INT 0
26227: PUSH
26228: LD_INT 0
26230: PUSH
26231: LD_INT 0
26233: PUSH
26234: EMPTY
26235: LIST
26236: LIST
26237: LIST
26238: LIST
26239: ST_TO_ADDR
// if not eng then
26240: LD_VAR 0 6
26244: NOT
26245: IFFALSE 26308
// begin p := SortBySkill ( tmp , 2 ) [ 1 ] ;
26247: LD_ADDR_VAR 0 11
26251: PUSH
26252: LD_VAR 0 4
26256: PPUSH
26257: LD_INT 2
26259: PPUSH
26260: CALL 91201 0 2
26264: PUSH
26265: LD_INT 1
26267: ARRAY
26268: ST_TO_ADDR
// result := Replace ( result , 2 , p ) ;
26269: LD_ADDR_VAR 0 2
26273: PUSH
26274: LD_VAR 0 2
26278: PPUSH
26279: LD_INT 2
26281: PPUSH
26282: LD_VAR 0 11
26286: PPUSH
26287: CALL_OW 1
26291: ST_TO_ADDR
// tmp := tmp diff p ;
26292: LD_ADDR_VAR 0 4
26296: PUSH
26297: LD_VAR 0 4
26301: PUSH
26302: LD_VAR 0 11
26306: DIFF
26307: ST_TO_ADDR
// end ; if tmp and sci < 6 then
26308: LD_VAR 0 4
26312: PUSH
26313: LD_VAR 0 8
26317: PUSH
26318: LD_INT 6
26320: LESS
26321: AND
26322: IFFALSE 26510
// begin sort := SortBySkill ( tmp diff ( sci union mech ) , 4 ) ;
26324: LD_ADDR_VAR 0 9
26328: PUSH
26329: LD_VAR 0 4
26333: PUSH
26334: LD_VAR 0 8
26338: PUSH
26339: LD_VAR 0 7
26343: UNION
26344: DIFF
26345: PPUSH
26346: LD_INT 4
26348: PPUSH
26349: CALL 91201 0 2
26353: ST_TO_ADDR
// p := [ ] ;
26354: LD_ADDR_VAR 0 11
26358: PUSH
26359: EMPTY
26360: ST_TO_ADDR
// if sort then
26361: LD_VAR 0 9
26365: IFFALSE 26481
// for i = 1 to 6 - sci do
26367: LD_ADDR_VAR 0 3
26371: PUSH
26372: DOUBLE
26373: LD_INT 1
26375: DEC
26376: ST_TO_ADDR
26377: LD_INT 6
26379: PUSH
26380: LD_VAR 0 8
26384: MINUS
26385: PUSH
26386: FOR_TO
26387: IFFALSE 26479
// begin if i = sort then
26389: LD_VAR 0 3
26393: PUSH
26394: LD_VAR 0 9
26398: EQUAL
26399: IFFALSE 26403
// break ;
26401: GO 26479
// if GetClass ( i ) = 4 then
26403: LD_VAR 0 3
26407: PPUSH
26408: CALL_OW 257
26412: PUSH
26413: LD_INT 4
26415: EQUAL
26416: IFFALSE 26420
// continue ;
26418: GO 26386
// p := Insert ( p , p + 1 , sort [ i ] ) ;
26420: LD_ADDR_VAR 0 11
26424: PUSH
26425: LD_VAR 0 11
26429: PPUSH
26430: LD_VAR 0 11
26434: PUSH
26435: LD_INT 1
26437: PLUS
26438: PPUSH
26439: LD_VAR 0 9
26443: PUSH
26444: LD_VAR 0 3
26448: ARRAY
26449: PPUSH
26450: CALL_OW 2
26454: ST_TO_ADDR
// tmp := tmp diff sort [ i ] ;
26455: LD_ADDR_VAR 0 4
26459: PUSH
26460: LD_VAR 0 4
26464: PUSH
26465: LD_VAR 0 9
26469: PUSH
26470: LD_VAR 0 3
26474: ARRAY
26475: DIFF
26476: ST_TO_ADDR
// end ;
26477: GO 26386
26479: POP
26480: POP
// if p then
26481: LD_VAR 0 11
26485: IFFALSE 26510
// result := Replace ( result , 4 , p ) ;
26487: LD_ADDR_VAR 0 2
26491: PUSH
26492: LD_VAR 0 2
26496: PPUSH
26497: LD_INT 4
26499: PPUSH
26500: LD_VAR 0 11
26504: PPUSH
26505: CALL_OW 1
26509: ST_TO_ADDR
// end ; if tmp and mech < 6 then
26510: LD_VAR 0 4
26514: PUSH
26515: LD_VAR 0 7
26519: PUSH
26520: LD_INT 6
26522: LESS
26523: AND
26524: IFFALSE 26712
// begin sort := SortBySkill ( tmp diff ( sci union mech ) , 3 ) ;
26526: LD_ADDR_VAR 0 9
26530: PUSH
26531: LD_VAR 0 4
26535: PUSH
26536: LD_VAR 0 8
26540: PUSH
26541: LD_VAR 0 7
26545: UNION
26546: DIFF
26547: PPUSH
26548: LD_INT 3
26550: PPUSH
26551: CALL 91201 0 2
26555: ST_TO_ADDR
// p := [ ] ;
26556: LD_ADDR_VAR 0 11
26560: PUSH
26561: EMPTY
26562: ST_TO_ADDR
// if sort then
26563: LD_VAR 0 9
26567: IFFALSE 26683
// for i = 1 to 6 - mech do
26569: LD_ADDR_VAR 0 3
26573: PUSH
26574: DOUBLE
26575: LD_INT 1
26577: DEC
26578: ST_TO_ADDR
26579: LD_INT 6
26581: PUSH
26582: LD_VAR 0 7
26586: MINUS
26587: PUSH
26588: FOR_TO
26589: IFFALSE 26681
// begin if i = sort then
26591: LD_VAR 0 3
26595: PUSH
26596: LD_VAR 0 9
26600: EQUAL
26601: IFFALSE 26605
// break ;
26603: GO 26681
// if GetClass ( i ) = 3 then
26605: LD_VAR 0 3
26609: PPUSH
26610: CALL_OW 257
26614: PUSH
26615: LD_INT 3
26617: EQUAL
26618: IFFALSE 26622
// continue ;
26620: GO 26588
// p := Insert ( p , p + 1 , sort [ i ] ) ;
26622: LD_ADDR_VAR 0 11
26626: PUSH
26627: LD_VAR 0 11
26631: PPUSH
26632: LD_VAR 0 11
26636: PUSH
26637: LD_INT 1
26639: PLUS
26640: PPUSH
26641: LD_VAR 0 9
26645: PUSH
26646: LD_VAR 0 3
26650: ARRAY
26651: PPUSH
26652: CALL_OW 2
26656: ST_TO_ADDR
// tmp := tmp diff sort [ i ] ;
26657: LD_ADDR_VAR 0 4
26661: PUSH
26662: LD_VAR 0 4
26666: PUSH
26667: LD_VAR 0 9
26671: PUSH
26672: LD_VAR 0 3
26676: ARRAY
26677: DIFF
26678: ST_TO_ADDR
// end ;
26679: GO 26588
26681: POP
26682: POP
// if p then
26683: LD_VAR 0 11
26687: IFFALSE 26712
// result := Replace ( result , 3 , p ) ;
26689: LD_ADDR_VAR 0 2
26693: PUSH
26694: LD_VAR 0 2
26698: PPUSH
26699: LD_INT 3
26701: PPUSH
26702: LD_VAR 0 11
26706: PPUSH
26707: CALL_OW 1
26711: ST_TO_ADDR
// end ; if tmp > 6 and eng < 6 then
26712: LD_VAR 0 4
26716: PUSH
26717: LD_INT 6
26719: GREATER
26720: PUSH
26721: LD_VAR 0 6
26725: PUSH
26726: LD_INT 6
26728: LESS
26729: AND
26730: IFFALSE 26924
// begin sort := SortBySkill ( tmp diff ( sci union mech union eng ) , 2 ) ;
26732: LD_ADDR_VAR 0 9
26736: PUSH
26737: LD_VAR 0 4
26741: PUSH
26742: LD_VAR 0 8
26746: PUSH
26747: LD_VAR 0 7
26751: UNION
26752: PUSH
26753: LD_VAR 0 6
26757: UNION
26758: DIFF
26759: PPUSH
26760: LD_INT 2
26762: PPUSH
26763: CALL 91201 0 2
26767: ST_TO_ADDR
// p := [ ] ;
26768: LD_ADDR_VAR 0 11
26772: PUSH
26773: EMPTY
26774: ST_TO_ADDR
// if sort then
26775: LD_VAR 0 9
26779: IFFALSE 26895
// for i = 1 to 6 - eng do
26781: LD_ADDR_VAR 0 3
26785: PUSH
26786: DOUBLE
26787: LD_INT 1
26789: DEC
26790: ST_TO_ADDR
26791: LD_INT 6
26793: PUSH
26794: LD_VAR 0 6
26798: MINUS
26799: PUSH
26800: FOR_TO
26801: IFFALSE 26893
// begin if i = sort then
26803: LD_VAR 0 3
26807: PUSH
26808: LD_VAR 0 9
26812: EQUAL
26813: IFFALSE 26817
// break ;
26815: GO 26893
// if GetClass ( i ) = 2 then
26817: LD_VAR 0 3
26821: PPUSH
26822: CALL_OW 257
26826: PUSH
26827: LD_INT 2
26829: EQUAL
26830: IFFALSE 26834
// continue ;
26832: GO 26800
// p := Insert ( p , p + 1 , sort [ i ] ) ;
26834: LD_ADDR_VAR 0 11
26838: PUSH
26839: LD_VAR 0 11
26843: PPUSH
26844: LD_VAR 0 11
26848: PUSH
26849: LD_INT 1
26851: PLUS
26852: PPUSH
26853: LD_VAR 0 9
26857: PUSH
26858: LD_VAR 0 3
26862: ARRAY
26863: PPUSH
26864: CALL_OW 2
26868: ST_TO_ADDR
// tmp := tmp diff sort [ i ] ;
26869: LD_ADDR_VAR 0 4
26873: PUSH
26874: LD_VAR 0 4
26878: PUSH
26879: LD_VAR 0 9
26883: PUSH
26884: LD_VAR 0 3
26888: ARRAY
26889: DIFF
26890: ST_TO_ADDR
// end ;
26891: GO 26800
26893: POP
26894: POP
// if p then
26895: LD_VAR 0 11
26899: IFFALSE 26924
// result := Replace ( result , 2 , p ) ;
26901: LD_ADDR_VAR 0 2
26905: PUSH
26906: LD_VAR 0 2
26910: PPUSH
26911: LD_INT 2
26913: PPUSH
26914: LD_VAR 0 11
26918: PPUSH
26919: CALL_OW 1
26923: ST_TO_ADDR
// end ; exit ;
26924: GO 28312
// end ; if not mc_tech [ mc_sides [ base ] ] and UnitFilter ( mc_bases [ base ] , [ f_btype , b_factory ] ) and mc_build_list [ base ] then
26926: LD_EXP 101
26930: PUSH
26931: LD_EXP 100
26935: PUSH
26936: LD_VAR 0 1
26940: ARRAY
26941: ARRAY
26942: NOT
26943: PUSH
26944: LD_EXP 74
26948: PUSH
26949: LD_VAR 0 1
26953: ARRAY
26954: PPUSH
26955: LD_INT 30
26957: PUSH
26958: LD_INT 3
26960: PUSH
26961: EMPTY
26962: LIST
26963: LIST
26964: PPUSH
26965: CALL_OW 72
26969: AND
26970: PUSH
26971: LD_EXP 79
26975: PUSH
26976: LD_VAR 0 1
26980: ARRAY
26981: AND
26982: IFFALSE 27590
// begin mc_class_case_use := Replace ( mc_class_case_use , base , 5 ) ;
26984: LD_ADDR_EXP 116
26988: PUSH
26989: LD_EXP 116
26993: PPUSH
26994: LD_VAR 0 1
26998: PPUSH
26999: LD_INT 5
27001: PPUSH
27002: CALL_OW 1
27006: ST_TO_ADDR
// result := [ 0 , 0 , 0 , 0 ] ;
27007: LD_ADDR_VAR 0 2
27011: PUSH
27012: LD_INT 0
27014: PUSH
27015: LD_INT 0
27017: PUSH
27018: LD_INT 0
27020: PUSH
27021: LD_INT 0
27023: PUSH
27024: EMPTY
27025: LIST
27026: LIST
27027: LIST
27028: LIST
27029: ST_TO_ADDR
// if sci > 1 then
27030: LD_VAR 0 8
27034: PUSH
27035: LD_INT 1
27037: GREATER
27038: IFFALSE 27066
// tmp := tmp diff ( sci diff sci [ 1 ] ) ;
27040: LD_ADDR_VAR 0 4
27044: PUSH
27045: LD_VAR 0 4
27049: PUSH
27050: LD_VAR 0 8
27054: PUSH
27055: LD_VAR 0 8
27059: PUSH
27060: LD_INT 1
27062: ARRAY
27063: DIFF
27064: DIFF
27065: ST_TO_ADDR
// if tmp and not sci then
27066: LD_VAR 0 4
27070: PUSH
27071: LD_VAR 0 8
27075: NOT
27076: AND
27077: IFFALSE 27146
// begin sort := SortBySkill ( tmp , 4 ) ;
27079: LD_ADDR_VAR 0 9
27083: PUSH
27084: LD_VAR 0 4
27088: PPUSH
27089: LD_INT 4
27091: PPUSH
27092: CALL 91201 0 2
27096: ST_TO_ADDR
// if sort then
27097: LD_VAR 0 9
27101: IFFALSE 27117
// p := sort [ 1 ] ;
27103: LD_ADDR_VAR 0 11
27107: PUSH
27108: LD_VAR 0 9
27112: PUSH
27113: LD_INT 1
27115: ARRAY
27116: ST_TO_ADDR
// if p then
27117: LD_VAR 0 11
27121: IFFALSE 27146
// result := Replace ( result , 4 , p ) ;
27123: LD_ADDR_VAR 0 2
27127: PUSH
27128: LD_VAR 0 2
27132: PPUSH
27133: LD_INT 4
27135: PPUSH
27136: LD_VAR 0 11
27140: PPUSH
27141: CALL_OW 1
27145: ST_TO_ADDR
// end ; tmp := tmp diff mech ;
27146: LD_ADDR_VAR 0 4
27150: PUSH
27151: LD_VAR 0 4
27155: PUSH
27156: LD_VAR 0 7
27160: DIFF
27161: ST_TO_ADDR
// if tmp and mech < 6 then
27162: LD_VAR 0 4
27166: PUSH
27167: LD_VAR 0 7
27171: PUSH
27172: LD_INT 6
27174: LESS
27175: AND
27176: IFFALSE 27364
// begin sort := SortBySkill ( tmp diff ( sci union mech ) , 3 ) ;
27178: LD_ADDR_VAR 0 9
27182: PUSH
27183: LD_VAR 0 4
27187: PUSH
27188: LD_VAR 0 8
27192: PUSH
27193: LD_VAR 0 7
27197: UNION
27198: DIFF
27199: PPUSH
27200: LD_INT 3
27202: PPUSH
27203: CALL 91201 0 2
27207: ST_TO_ADDR
// p := [ ] ;
27208: LD_ADDR_VAR 0 11
27212: PUSH
27213: EMPTY
27214: ST_TO_ADDR
// if sort then
27215: LD_VAR 0 9
27219: IFFALSE 27335
// for i = 1 to 6 - mech do
27221: LD_ADDR_VAR 0 3
27225: PUSH
27226: DOUBLE
27227: LD_INT 1
27229: DEC
27230: ST_TO_ADDR
27231: LD_INT 6
27233: PUSH
27234: LD_VAR 0 7
27238: MINUS
27239: PUSH
27240: FOR_TO
27241: IFFALSE 27333
// begin if i = sort then
27243: LD_VAR 0 3
27247: PUSH
27248: LD_VAR 0 9
27252: EQUAL
27253: IFFALSE 27257
// break ;
27255: GO 27333
// if GetClass ( i ) = 3 then
27257: LD_VAR 0 3
27261: PPUSH
27262: CALL_OW 257
27266: PUSH
27267: LD_INT 3
27269: EQUAL
27270: IFFALSE 27274
// continue ;
27272: GO 27240
// p := Insert ( p , p + 1 , sort [ i ] ) ;
27274: LD_ADDR_VAR 0 11
27278: PUSH
27279: LD_VAR 0 11
27283: PPUSH
27284: LD_VAR 0 11
27288: PUSH
27289: LD_INT 1
27291: PLUS
27292: PPUSH
27293: LD_VAR 0 9
27297: PUSH
27298: LD_VAR 0 3
27302: ARRAY
27303: PPUSH
27304: CALL_OW 2
27308: ST_TO_ADDR
// tmp := tmp diff sort [ i ] ;
27309: LD_ADDR_VAR 0 4
27313: PUSH
27314: LD_VAR 0 4
27318: PUSH
27319: LD_VAR 0 9
27323: PUSH
27324: LD_VAR 0 3
27328: ARRAY
27329: DIFF
27330: ST_TO_ADDR
// end ;
27331: GO 27240
27333: POP
27334: POP
// if p then
27335: LD_VAR 0 11
27339: IFFALSE 27364
// result := Replace ( result , 3 , p ) ;
27341: LD_ADDR_VAR 0 2
27345: PUSH
27346: LD_VAR 0 2
27350: PPUSH
27351: LD_INT 3
27353: PPUSH
27354: LD_VAR 0 11
27358: PPUSH
27359: CALL_OW 1
27363: ST_TO_ADDR
// end ; tmp := tmp diff eng ;
27364: LD_ADDR_VAR 0 4
27368: PUSH
27369: LD_VAR 0 4
27373: PUSH
27374: LD_VAR 0 6
27378: DIFF
27379: ST_TO_ADDR
// if tmp and eng < 6 then
27380: LD_VAR 0 4
27384: PUSH
27385: LD_VAR 0 6
27389: PUSH
27390: LD_INT 6
27392: LESS
27393: AND
27394: IFFALSE 27588
// begin sort := SortBySkill ( tmp diff ( sci union mech union eng ) , 2 ) ;
27396: LD_ADDR_VAR 0 9
27400: PUSH
27401: LD_VAR 0 4
27405: PUSH
27406: LD_VAR 0 8
27410: PUSH
27411: LD_VAR 0 7
27415: UNION
27416: PUSH
27417: LD_VAR 0 6
27421: UNION
27422: DIFF
27423: PPUSH
27424: LD_INT 2
27426: PPUSH
27427: CALL 91201 0 2
27431: ST_TO_ADDR
// p := [ ] ;
27432: LD_ADDR_VAR 0 11
27436: PUSH
27437: EMPTY
27438: ST_TO_ADDR
// if sort then
27439: LD_VAR 0 9
27443: IFFALSE 27559
// for i = 1 to 6 - eng do
27445: LD_ADDR_VAR 0 3
27449: PUSH
27450: DOUBLE
27451: LD_INT 1
27453: DEC
27454: ST_TO_ADDR
27455: LD_INT 6
27457: PUSH
27458: LD_VAR 0 6
27462: MINUS
27463: PUSH
27464: FOR_TO
27465: IFFALSE 27557
// begin if i = sort then
27467: LD_VAR 0 3
27471: PUSH
27472: LD_VAR 0 9
27476: EQUAL
27477: IFFALSE 27481
// break ;
27479: GO 27557
// if GetClass ( i ) = 2 then
27481: LD_VAR 0 3
27485: PPUSH
27486: CALL_OW 257
27490: PUSH
27491: LD_INT 2
27493: EQUAL
27494: IFFALSE 27498
// continue ;
27496: GO 27464
// p := Insert ( p , p + 1 , sort [ i ] ) ;
27498: LD_ADDR_VAR 0 11
27502: PUSH
27503: LD_VAR 0 11
27507: PPUSH
27508: LD_VAR 0 11
27512: PUSH
27513: LD_INT 1
27515: PLUS
27516: PPUSH
27517: LD_VAR 0 9
27521: PUSH
27522: LD_VAR 0 3
27526: ARRAY
27527: PPUSH
27528: CALL_OW 2
27532: ST_TO_ADDR
// tmp := tmp diff sort [ i ] ;
27533: LD_ADDR_VAR 0 4
27537: PUSH
27538: LD_VAR 0 4
27542: PUSH
27543: LD_VAR 0 9
27547: PUSH
27548: LD_VAR 0 3
27552: ARRAY
27553: DIFF
27554: ST_TO_ADDR
// end ;
27555: GO 27464
27557: POP
27558: POP
// if p then
27559: LD_VAR 0 11
27563: IFFALSE 27588
// result := Replace ( result , 2 , p ) ;
27565: LD_ADDR_VAR 0 2
27569: PUSH
27570: LD_VAR 0 2
27574: PPUSH
27575: LD_INT 2
27577: PPUSH
27578: LD_VAR 0 11
27582: PPUSH
27583: CALL_OW 1
27587: ST_TO_ADDR
// end ; exit ;
27588: GO 28312
// end ; if not mc_tech [ mc_sides [ base ] ] and UnitFilter ( mc_bases [ base ] , [ f_btype , b_factory ] ) and not mc_build_list [ base ] then
27590: LD_EXP 101
27594: PUSH
27595: LD_EXP 100
27599: PUSH
27600: LD_VAR 0 1
27604: ARRAY
27605: ARRAY
27606: NOT
27607: PUSH
27608: LD_EXP 74
27612: PUSH
27613: LD_VAR 0 1
27617: ARRAY
27618: PPUSH
27619: LD_INT 30
27621: PUSH
27622: LD_INT 3
27624: PUSH
27625: EMPTY
27626: LIST
27627: LIST
27628: PPUSH
27629: CALL_OW 72
27633: AND
27634: PUSH
27635: LD_EXP 79
27639: PUSH
27640: LD_VAR 0 1
27644: ARRAY
27645: NOT
27646: AND
27647: IFFALSE 28312
// begin mc_class_case_use := Replace ( mc_class_case_use , base , 6 ) ;
27649: LD_ADDR_EXP 116
27653: PUSH
27654: LD_EXP 116
27658: PPUSH
27659: LD_VAR 0 1
27663: PPUSH
27664: LD_INT 6
27666: PPUSH
27667: CALL_OW 1
27671: ST_TO_ADDR
// result := [ 0 , 0 , 0 , 0 ] ;
27672: LD_ADDR_VAR 0 2
27676: PUSH
27677: LD_INT 0
27679: PUSH
27680: LD_INT 0
27682: PUSH
27683: LD_INT 0
27685: PUSH
27686: LD_INT 0
27688: PUSH
27689: EMPTY
27690: LIST
27691: LIST
27692: LIST
27693: LIST
27694: ST_TO_ADDR
// if sci >= 1 then
27695: LD_VAR 0 8
27699: PUSH
27700: LD_INT 1
27702: GREATEREQUAL
27703: IFFALSE 27725
// tmp := tmp diff sci [ 1 ] ;
27705: LD_ADDR_VAR 0 4
27709: PUSH
27710: LD_VAR 0 4
27714: PUSH
27715: LD_VAR 0 8
27719: PUSH
27720: LD_INT 1
27722: ARRAY
27723: DIFF
27724: ST_TO_ADDR
// if tmp and not sci then
27725: LD_VAR 0 4
27729: PUSH
27730: LD_VAR 0 8
27734: NOT
27735: AND
27736: IFFALSE 27805
// begin sort := SortBySkill ( tmp , 4 ) ;
27738: LD_ADDR_VAR 0 9
27742: PUSH
27743: LD_VAR 0 4
27747: PPUSH
27748: LD_INT 4
27750: PPUSH
27751: CALL 91201 0 2
27755: ST_TO_ADDR
// if sort then
27756: LD_VAR 0 9
27760: IFFALSE 27776
// p := sort [ 1 ] ;
27762: LD_ADDR_VAR 0 11
27766: PUSH
27767: LD_VAR 0 9
27771: PUSH
27772: LD_INT 1
27774: ARRAY
27775: ST_TO_ADDR
// if p then
27776: LD_VAR 0 11
27780: IFFALSE 27805
// result := Replace ( result , 4 , p ) ;
27782: LD_ADDR_VAR 0 2
27786: PUSH
27787: LD_VAR 0 2
27791: PPUSH
27792: LD_INT 4
27794: PPUSH
27795: LD_VAR 0 11
27799: PPUSH
27800: CALL_OW 1
27804: ST_TO_ADDR
// end ; tmp := tmp diff mech ;
27805: LD_ADDR_VAR 0 4
27809: PUSH
27810: LD_VAR 0 4
27814: PUSH
27815: LD_VAR 0 7
27819: DIFF
27820: ST_TO_ADDR
// if tmp and mech < 6 then
27821: LD_VAR 0 4
27825: PUSH
27826: LD_VAR 0 7
27830: PUSH
27831: LD_INT 6
27833: LESS
27834: AND
27835: IFFALSE 28017
// begin sort := SortBySkill ( tmp diff mech , 3 ) ;
27837: LD_ADDR_VAR 0 9
27841: PUSH
27842: LD_VAR 0 4
27846: PUSH
27847: LD_VAR 0 7
27851: DIFF
27852: PPUSH
27853: LD_INT 3
27855: PPUSH
27856: CALL 91201 0 2
27860: ST_TO_ADDR
// p := [ ] ;
27861: LD_ADDR_VAR 0 11
27865: PUSH
27866: EMPTY
27867: ST_TO_ADDR
// if sort then
27868: LD_VAR 0 9
27872: IFFALSE 27988
// for i = 1 to 6 - mech do
27874: LD_ADDR_VAR 0 3
27878: PUSH
27879: DOUBLE
27880: LD_INT 1
27882: DEC
27883: ST_TO_ADDR
27884: LD_INT 6
27886: PUSH
27887: LD_VAR 0 7
27891: MINUS
27892: PUSH
27893: FOR_TO
27894: IFFALSE 27986
// begin if i = sort then
27896: LD_VAR 0 3
27900: PUSH
27901: LD_VAR 0 9
27905: EQUAL
27906: IFFALSE 27910
// break ;
27908: GO 27986
// if GetClass ( i ) = 3 then
27910: LD_VAR 0 3
27914: PPUSH
27915: CALL_OW 257
27919: PUSH
27920: LD_INT 3
27922: EQUAL
27923: IFFALSE 27927
// continue ;
27925: GO 27893
// p := Insert ( p , p + 1 , sort [ i ] ) ;
27927: LD_ADDR_VAR 0 11
27931: PUSH
27932: LD_VAR 0 11
27936: PPUSH
27937: LD_VAR 0 11
27941: PUSH
27942: LD_INT 1
27944: PLUS
27945: PPUSH
27946: LD_VAR 0 9
27950: PUSH
27951: LD_VAR 0 3
27955: ARRAY
27956: PPUSH
27957: CALL_OW 2
27961: ST_TO_ADDR
// tmp := tmp diff sort [ i ] ;
27962: LD_ADDR_VAR 0 4
27966: PUSH
27967: LD_VAR 0 4
27971: PUSH
27972: LD_VAR 0 9
27976: PUSH
27977: LD_VAR 0 3
27981: ARRAY
27982: DIFF
27983: ST_TO_ADDR
// end ;
27984: GO 27893
27986: POP
27987: POP
// if p then
27988: LD_VAR 0 11
27992: IFFALSE 28017
// result := Replace ( result , 3 , p ) ;
27994: LD_ADDR_VAR 0 2
27998: PUSH
27999: LD_VAR 0 2
28003: PPUSH
28004: LD_INT 3
28006: PPUSH
28007: LD_VAR 0 11
28011: PPUSH
28012: CALL_OW 1
28016: ST_TO_ADDR
// end ; tmp := tmp diff eng ;
28017: LD_ADDR_VAR 0 4
28021: PUSH
28022: LD_VAR 0 4
28026: PUSH
28027: LD_VAR 0 6
28031: DIFF
28032: ST_TO_ADDR
// if tmp and eng < 4 then
28033: LD_VAR 0 4
28037: PUSH
28038: LD_VAR 0 6
28042: PUSH
28043: LD_INT 4
28045: LESS
28046: AND
28047: IFFALSE 28237
// begin sort := SortBySkill ( tmp diff ( mech union eng ) , 2 ) ;
28049: LD_ADDR_VAR 0 9
28053: PUSH
28054: LD_VAR 0 4
28058: PUSH
28059: LD_VAR 0 7
28063: PUSH
28064: LD_VAR 0 6
28068: UNION
28069: DIFF
28070: PPUSH
28071: LD_INT 2
28073: PPUSH
28074: CALL 91201 0 2
28078: ST_TO_ADDR
// p := [ ] ;
28079: LD_ADDR_VAR 0 11
28083: PUSH
28084: EMPTY
28085: ST_TO_ADDR
// if sort then
28086: LD_VAR 0 9
28090: IFFALSE 28206
// for i = 1 to 4 - eng do
28092: LD_ADDR_VAR 0 3
28096: PUSH
28097: DOUBLE
28098: LD_INT 1
28100: DEC
28101: ST_TO_ADDR
28102: LD_INT 4
28104: PUSH
28105: LD_VAR 0 6
28109: MINUS
28110: PUSH
28111: FOR_TO
28112: IFFALSE 28204
// begin if i = sort then
28114: LD_VAR 0 3
28118: PUSH
28119: LD_VAR 0 9
28123: EQUAL
28124: IFFALSE 28128
// break ;
28126: GO 28204
// if GetClass ( i ) = 2 then
28128: LD_VAR 0 3
28132: PPUSH
28133: CALL_OW 257
28137: PUSH
28138: LD_INT 2
28140: EQUAL
28141: IFFALSE 28145
// continue ;
28143: GO 28111
// p := Insert ( p , p + 1 , sort [ i ] ) ;
28145: LD_ADDR_VAR 0 11
28149: PUSH
28150: LD_VAR 0 11
28154: PPUSH
28155: LD_VAR 0 11
28159: PUSH
28160: LD_INT 1
28162: PLUS
28163: PPUSH
28164: LD_VAR 0 9
28168: PUSH
28169: LD_VAR 0 3
28173: ARRAY
28174: PPUSH
28175: CALL_OW 2
28179: ST_TO_ADDR
// tmp := tmp diff sort [ i ] ;
28180: LD_ADDR_VAR 0 4
28184: PUSH
28185: LD_VAR 0 4
28189: PUSH
28190: LD_VAR 0 9
28194: PUSH
28195: LD_VAR 0 3
28199: ARRAY
28200: DIFF
28201: ST_TO_ADDR
// end ;
28202: GO 28111
28204: POP
28205: POP
// if p then
28206: LD_VAR 0 11
28210: IFFALSE 28235
// result := Replace ( result , 2 , p ) ;
28212: LD_ADDR_VAR 0 2
28216: PUSH
28217: LD_VAR 0 2
28221: PPUSH
28222: LD_INT 2
28224: PPUSH
28225: LD_VAR 0 11
28229: PPUSH
28230: CALL_OW 1
28234: ST_TO_ADDR
// end else
28235: GO 28281
// for i = eng downto 5 do
28237: LD_ADDR_VAR 0 3
28241: PUSH
28242: DOUBLE
28243: LD_VAR 0 6
28247: INC
28248: ST_TO_ADDR
28249: LD_INT 5
28251: PUSH
28252: FOR_DOWNTO
28253: IFFALSE 28279
// tmp := tmp union eng [ i ] ;
28255: LD_ADDR_VAR 0 4
28259: PUSH
28260: LD_VAR 0 4
28264: PUSH
28265: LD_VAR 0 6
28269: PUSH
28270: LD_VAR 0 3
28274: ARRAY
28275: UNION
28276: ST_TO_ADDR
28277: GO 28252
28279: POP
28280: POP
// result := Replace ( result , 1 , tmp diff sol ) ;
28281: LD_ADDR_VAR 0 2
28285: PUSH
28286: LD_VAR 0 2
28290: PPUSH
28291: LD_INT 1
28293: PPUSH
28294: LD_VAR 0 4
28298: PUSH
28299: LD_VAR 0 5
28303: DIFF
28304: PPUSH
28305: CALL_OW 1
28309: ST_TO_ADDR
// exit ;
28310: GO 28312
// end ; end ;
28312: LD_VAR 0 2
28316: RET
// export function MC_CheckBuildings ( ) ; var i , tmp ; begin
28317: LD_INT 0
28319: PPUSH
28320: PPUSH
28321: PPUSH
// if not mc_bases then
28322: LD_EXP 74
28326: NOT
28327: IFFALSE 28331
// exit ;
28329: GO 28437
// for i = 1 to mc_bases do
28331: LD_ADDR_VAR 0 2
28335: PUSH
28336: DOUBLE
28337: LD_INT 1
28339: DEC
28340: ST_TO_ADDR
28341: LD_EXP 74
28345: PUSH
28346: FOR_TO
28347: IFFALSE 28428
// begin tmp := UnitFilter ( mc_bases [ i ] , [ [ f_type , unit_building ] , [ f_not , [ f_lives , 1000 ] ] ] ) ;
28349: LD_ADDR_VAR 0 3
28353: PUSH
28354: LD_EXP 74
28358: PUSH
28359: LD_VAR 0 2
28363: ARRAY
28364: PPUSH
28365: LD_INT 21
28367: PUSH
28368: LD_INT 3
28370: PUSH
28371: EMPTY
28372: LIST
28373: LIST
28374: PUSH
28375: LD_INT 3
28377: PUSH
28378: LD_INT 24
28380: PUSH
28381: LD_INT 1000
28383: PUSH
28384: EMPTY
28385: LIST
28386: LIST
28387: PUSH
28388: EMPTY
28389: LIST
28390: LIST
28391: PUSH
28392: EMPTY
28393: LIST
28394: LIST
28395: PPUSH
28396: CALL_OW 72
28400: ST_TO_ADDR
// mc_building_need_repair := Replace ( mc_building_need_repair , i , tmp ) ;
28401: LD_ADDR_EXP 75
28405: PUSH
28406: LD_EXP 75
28410: PPUSH
28411: LD_VAR 0 2
28415: PPUSH
28416: LD_VAR 0 3
28420: PPUSH
28421: CALL_OW 1
28425: ST_TO_ADDR
// end ;
28426: GO 28346
28428: POP
28429: POP
// RaiseSailEvent ( 101 ) ;
28430: LD_INT 101
28432: PPUSH
28433: CALL_OW 427
// end ;
28437: LD_VAR 0 1
28441: RET
// export function MC_CheckPeopleLife ( ) ; var i , j , k , tmp , need_heal_1 , need_heal_2 ; begin
28442: LD_INT 0
28444: PPUSH
28445: PPUSH
28446: PPUSH
28447: PPUSH
28448: PPUSH
28449: PPUSH
28450: PPUSH
// if not mc_bases then
28451: LD_EXP 74
28455: NOT
28456: IFFALSE 28460
// exit ;
28458: GO 29033
// for i = 1 to mc_bases do
28460: LD_ADDR_VAR 0 2
28464: PUSH
28465: DOUBLE
28466: LD_INT 1
28468: DEC
28469: ST_TO_ADDR
28470: LD_EXP 74
28474: PUSH
28475: FOR_TO
28476: IFFALSE 29024
// begin tmp := UnitFilter ( mc_bases [ i ] union mc_ape [ i ] , [ [ f_type , unit_human ] , [ f_and , [ f_not , [ f_inside ] ] , [ f_not , [ f_lives , 800 ] ] ] ] ) ;
28478: LD_ADDR_VAR 0 5
28482: PUSH
28483: LD_EXP 74
28487: PUSH
28488: LD_VAR 0 2
28492: ARRAY
28493: PUSH
28494: LD_EXP 103
28498: PUSH
28499: LD_VAR 0 2
28503: ARRAY
28504: UNION
28505: PPUSH
28506: LD_INT 21
28508: PUSH
28509: LD_INT 1
28511: PUSH
28512: EMPTY
28513: LIST
28514: LIST
28515: PUSH
28516: LD_INT 1
28518: PUSH
28519: LD_INT 3
28521: PUSH
28522: LD_INT 54
28524: PUSH
28525: EMPTY
28526: LIST
28527: PUSH
28528: EMPTY
28529: LIST
28530: LIST
28531: PUSH
28532: LD_INT 3
28534: PUSH
28535: LD_INT 24
28537: PUSH
28538: LD_INT 800
28540: PUSH
28541: EMPTY
28542: LIST
28543: LIST
28544: PUSH
28545: EMPTY
28546: LIST
28547: LIST
28548: PUSH
28549: EMPTY
28550: LIST
28551: LIST
28552: LIST
28553: PUSH
28554: EMPTY
28555: LIST
28556: LIST
28557: PPUSH
28558: CALL_OW 72
28562: ST_TO_ADDR
// need_heal_1 := UnitFilter ( mc_bases [ i ] , [ [ f_type , unit_human ] , [ f_and , [ f_not , [ f_inside ] ] , [ f_not , [ f_lives , 250 ] ] ] ] ) ;
28563: LD_ADDR_VAR 0 6
28567: PUSH
28568: LD_EXP 74
28572: PUSH
28573: LD_VAR 0 2
28577: ARRAY
28578: PPUSH
28579: LD_INT 21
28581: PUSH
28582: LD_INT 1
28584: PUSH
28585: EMPTY
28586: LIST
28587: LIST
28588: PUSH
28589: LD_INT 1
28591: PUSH
28592: LD_INT 3
28594: PUSH
28595: LD_INT 54
28597: PUSH
28598: EMPTY
28599: LIST
28600: PUSH
28601: EMPTY
28602: LIST
28603: LIST
28604: PUSH
28605: LD_INT 3
28607: PUSH
28608: LD_INT 24
28610: PUSH
28611: LD_INT 250
28613: PUSH
28614: EMPTY
28615: LIST
28616: LIST
28617: PUSH
28618: EMPTY
28619: LIST
28620: LIST
28621: PUSH
28622: EMPTY
28623: LIST
28624: LIST
28625: LIST
28626: PUSH
28627: EMPTY
28628: LIST
28629: LIST
28630: PPUSH
28631: CALL_OW 72
28635: ST_TO_ADDR
// need_heal_2 := tmp diff need_heal_1 ;
28636: LD_ADDR_VAR 0 7
28640: PUSH
28641: LD_VAR 0 5
28645: PUSH
28646: LD_VAR 0 6
28650: DIFF
28651: ST_TO_ADDR
// if not need_heal_1 then
28652: LD_VAR 0 6
28656: NOT
28657: IFFALSE 28690
// mc_need_heal := ReplaceIn ( mc_need_heal , [ i , 1 ] , [ ] ) else
28659: LD_ADDR_EXP 77
28663: PUSH
28664: LD_EXP 77
28668: PPUSH
28669: LD_VAR 0 2
28673: PUSH
28674: LD_INT 1
28676: PUSH
28677: EMPTY
28678: LIST
28679: LIST
28680: PPUSH
28681: EMPTY
28682: PPUSH
28683: CALL 56953 0 3
28687: ST_TO_ADDR
28688: GO 28760
// mc_need_heal := ReplaceIn ( mc_need_heal , [ i , 1 ] , UnitFilter ( mc_need_heal [ i ] [ 1 ] , [ f_not , [ f_lives , 1000 ] ] ) union need_heal_1 ) ;
28690: LD_ADDR_EXP 77
28694: PUSH
28695: LD_EXP 77
28699: PPUSH
28700: LD_VAR 0 2
28704: PUSH
28705: LD_INT 1
28707: PUSH
28708: EMPTY
28709: LIST
28710: LIST
28711: PPUSH
28712: LD_EXP 77
28716: PUSH
28717: LD_VAR 0 2
28721: ARRAY
28722: PUSH
28723: LD_INT 1
28725: ARRAY
28726: PPUSH
28727: LD_INT 3
28729: PUSH
28730: LD_INT 24
28732: PUSH
28733: LD_INT 1000
28735: PUSH
28736: EMPTY
28737: LIST
28738: LIST
28739: PUSH
28740: EMPTY
28741: LIST
28742: LIST
28743: PPUSH
28744: CALL_OW 72
28748: PUSH
28749: LD_VAR 0 6
28753: UNION
28754: PPUSH
28755: CALL 56953 0 3
28759: ST_TO_ADDR
// if not need_heal_2 then
28760: LD_VAR 0 7
28764: NOT
28765: IFFALSE 28798
// mc_need_heal := ReplaceIn ( mc_need_heal , [ i , 2 ] , [ ] ) else
28767: LD_ADDR_EXP 77
28771: PUSH
28772: LD_EXP 77
28776: PPUSH
28777: LD_VAR 0 2
28781: PUSH
28782: LD_INT 2
28784: PUSH
28785: EMPTY
28786: LIST
28787: LIST
28788: PPUSH
28789: EMPTY
28790: PPUSH
28791: CALL 56953 0 3
28795: ST_TO_ADDR
28796: GO 28830
// mc_need_heal := ReplaceIn ( mc_need_heal , [ i , 2 ] , need_heal_2 ) ;
28798: LD_ADDR_EXP 77
28802: PUSH
28803: LD_EXP 77
28807: PPUSH
28808: LD_VAR 0 2
28812: PUSH
28813: LD_INT 2
28815: PUSH
28816: EMPTY
28817: LIST
28818: LIST
28819: PPUSH
28820: LD_VAR 0 7
28824: PPUSH
28825: CALL 56953 0 3
28829: ST_TO_ADDR
// if need_heal_2 then
28830: LD_VAR 0 7
28834: IFFALSE 29006
// for j in need_heal_2 do
28836: LD_ADDR_VAR 0 3
28840: PUSH
28841: LD_VAR 0 7
28845: PUSH
28846: FOR_IN
28847: IFFALSE 29004
// begin tmp := UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_lab ] , [ f_btype , b_lab_half ] , [ f_btype , b_lab_full ] , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] , [ f_class , 4 ] ] ) ;
28849: LD_ADDR_VAR 0 5
28853: PUSH
28854: LD_EXP 74
28858: PUSH
28859: LD_VAR 0 2
28863: ARRAY
28864: PPUSH
28865: LD_INT 2
28867: PUSH
28868: LD_INT 30
28870: PUSH
28871: LD_INT 6
28873: PUSH
28874: EMPTY
28875: LIST
28876: LIST
28877: PUSH
28878: LD_INT 30
28880: PUSH
28881: LD_INT 7
28883: PUSH
28884: EMPTY
28885: LIST
28886: LIST
28887: PUSH
28888: LD_INT 30
28890: PUSH
28891: LD_INT 8
28893: PUSH
28894: EMPTY
28895: LIST
28896: LIST
28897: PUSH
28898: LD_INT 30
28900: PUSH
28901: LD_INT 0
28903: PUSH
28904: EMPTY
28905: LIST
28906: LIST
28907: PUSH
28908: LD_INT 30
28910: PUSH
28911: LD_INT 1
28913: PUSH
28914: EMPTY
28915: LIST
28916: LIST
28917: PUSH
28918: LD_INT 25
28920: PUSH
28921: LD_INT 4
28923: PUSH
28924: EMPTY
28925: LIST
28926: LIST
28927: PUSH
28928: EMPTY
28929: LIST
28930: LIST
28931: LIST
28932: LIST
28933: LIST
28934: LIST
28935: LIST
28936: PPUSH
28937: CALL_OW 72
28941: ST_TO_ADDR
// if tmp then
28942: LD_VAR 0 5
28946: IFFALSE 29002
// begin k := NearestUnitToUnit ( tmp , j ) ;
28948: LD_ADDR_VAR 0 4
28952: PUSH
28953: LD_VAR 0 5
28957: PPUSH
28958: LD_VAR 0 3
28962: PPUSH
28963: CALL_OW 74
28967: ST_TO_ADDR
// if GetDistUnits ( j , k ) > 7 then
28968: LD_VAR 0 3
28972: PPUSH
28973: LD_VAR 0 4
28977: PPUSH
28978: CALL_OW 296
28982: PUSH
28983: LD_INT 7
28985: GREATER
28986: IFFALSE 29002
// ComMoveUnit ( j , k ) ;
28988: LD_VAR 0 3
28992: PPUSH
28993: LD_VAR 0 4
28997: PPUSH
28998: CALL_OW 112
// end ; end ;
29002: GO 28846
29004: POP
29005: POP
// if not need_heal_1 and not need_heal_2 then
29006: LD_VAR 0 6
29010: NOT
29011: PUSH
29012: LD_VAR 0 7
29016: NOT
29017: AND
29018: IFFALSE 29022
// continue ;
29020: GO 28475
// end ;
29022: GO 28475
29024: POP
29025: POP
// RaiseSailEvent ( 102 ) ;
29026: LD_INT 102
29028: PPUSH
29029: CALL_OW 427
// end ;
29033: LD_VAR 0 1
29037: RET
// export function MC_RepairBuildings ( ) ; var i , j , un , tmp , cranes ; begin
29038: LD_INT 0
29040: PPUSH
29041: PPUSH
29042: PPUSH
29043: PPUSH
29044: PPUSH
29045: PPUSH
// if not mc_bases then
29046: LD_EXP 74
29050: NOT
29051: IFFALSE 29055
// exit ;
29053: GO 29765
// for i = 1 to mc_bases do
29055: LD_ADDR_VAR 0 2
29059: PUSH
29060: DOUBLE
29061: LD_INT 1
29063: DEC
29064: ST_TO_ADDR
29065: LD_EXP 74
29069: PUSH
29070: FOR_TO
29071: IFFALSE 29763
// begin if not mc_building_need_repair [ i ] then
29073: LD_EXP 75
29077: PUSH
29078: LD_VAR 0 2
29082: ARRAY
29083: NOT
29084: IFFALSE 29258
// begin cranes := UnitFilter ( mc_vehicles [ i ] , [ [ f_not , [ f_lives , 1000 ] ] , [ f_or , [ f_weapon , us_crane ] , [ f_weapon , ru_crane ] ] ] ) ;
29086: LD_ADDR_VAR 0 6
29090: PUSH
29091: LD_EXP 93
29095: PUSH
29096: LD_VAR 0 2
29100: ARRAY
29101: PPUSH
29102: LD_INT 3
29104: PUSH
29105: LD_INT 24
29107: PUSH
29108: LD_INT 1000
29110: PUSH
29111: EMPTY
29112: LIST
29113: LIST
29114: PUSH
29115: EMPTY
29116: LIST
29117: LIST
29118: PUSH
29119: LD_INT 2
29121: PUSH
29122: LD_INT 34
29124: PUSH
29125: LD_INT 13
29127: PUSH
29128: EMPTY
29129: LIST
29130: LIST
29131: PUSH
29132: LD_INT 34
29134: PUSH
29135: LD_INT 52
29137: PUSH
29138: EMPTY
29139: LIST
29140: LIST
29141: PUSH
29142: EMPTY
29143: LIST
29144: LIST
29145: LIST
29146: PUSH
29147: EMPTY
29148: LIST
29149: LIST
29150: PPUSH
29151: CALL_OW 72
29155: ST_TO_ADDR
// if cranes then
29156: LD_VAR 0 6
29160: IFFALSE 29222
// for j in cranes do
29162: LD_ADDR_VAR 0 3
29166: PUSH
29167: LD_VAR 0 6
29171: PUSH
29172: FOR_IN
29173: IFFALSE 29220
// if not IsInArea ( j , mc_parking [ i ] ) then
29175: LD_VAR 0 3
29179: PPUSH
29180: LD_EXP 98
29184: PUSH
29185: LD_VAR 0 2
29189: ARRAY
29190: PPUSH
29191: CALL_OW 308
29195: NOT
29196: IFFALSE 29218
// ComMoveToArea ( j , mc_parking [ i ] ) ;
29198: LD_VAR 0 3
29202: PPUSH
29203: LD_EXP 98
29207: PUSH
29208: LD_VAR 0 2
29212: ARRAY
29213: PPUSH
29214: CALL_OW 113
29218: GO 29172
29220: POP
29221: POP
// mc_building_repairs := Replace ( mc_building_repairs , i , [ ] ) ;
29222: LD_ADDR_EXP 76
29226: PUSH
29227: LD_EXP 76
29231: PPUSH
29232: LD_VAR 0 2
29236: PPUSH
29237: EMPTY
29238: PPUSH
29239: CALL_OW 1
29243: ST_TO_ADDR
// MC_Reset ( i , 101 ) ;
29244: LD_VAR 0 2
29248: PPUSH
29249: LD_INT 101
29251: PPUSH
29252: CALL 24150 0 2
// continue ;
29256: GO 29070
// end ; mc_builders := Replace ( mc_builders , i , [ ] ) ;
29258: LD_ADDR_EXP 80
29262: PUSH
29263: LD_EXP 80
29267: PPUSH
29268: LD_VAR 0 2
29272: PPUSH
29273: EMPTY
29274: PPUSH
29275: CALL_OW 1
29279: ST_TO_ADDR
// MC_Reset ( i , 103 ) ;
29280: LD_VAR 0 2
29284: PPUSH
29285: LD_INT 103
29287: PPUSH
29288: CALL 24150 0 2
// tmp := UnitFilter ( mc_bases [ i ] union mc_ape [ i ] , [ [ f_or , [ f_class , 2 ] , [ f_class , 16 ] ] ] ) ;
29292: LD_ADDR_VAR 0 5
29296: PUSH
29297: LD_EXP 74
29301: PUSH
29302: LD_VAR 0 2
29306: ARRAY
29307: PUSH
29308: LD_EXP 103
29312: PUSH
29313: LD_VAR 0 2
29317: ARRAY
29318: UNION
29319: PPUSH
29320: LD_INT 2
29322: PUSH
29323: LD_INT 25
29325: PUSH
29326: LD_INT 2
29328: PUSH
29329: EMPTY
29330: LIST
29331: LIST
29332: PUSH
29333: LD_INT 25
29335: PUSH
29336: LD_INT 16
29338: PUSH
29339: EMPTY
29340: LIST
29341: LIST
29342: PUSH
29343: EMPTY
29344: LIST
29345: LIST
29346: LIST
29347: PUSH
29348: EMPTY
29349: LIST
29350: PPUSH
29351: CALL_OW 72
29355: ST_TO_ADDR
// cranes := UnitFilter ( mc_vehicles [ i ] , [ f_or , [ f_weapon , us_crane ] , [ f_weapon , ru_crane ] ] ) ;
29356: LD_ADDR_VAR 0 6
29360: PUSH
29361: LD_EXP 93
29365: PUSH
29366: LD_VAR 0 2
29370: ARRAY
29371: PPUSH
29372: LD_INT 2
29374: PUSH
29375: LD_INT 34
29377: PUSH
29378: LD_INT 13
29380: PUSH
29381: EMPTY
29382: LIST
29383: LIST
29384: PUSH
29385: LD_INT 34
29387: PUSH
29388: LD_INT 52
29390: PUSH
29391: EMPTY
29392: LIST
29393: LIST
29394: PUSH
29395: EMPTY
29396: LIST
29397: LIST
29398: LIST
29399: PPUSH
29400: CALL_OW 72
29404: ST_TO_ADDR
// if cranes then
29405: LD_VAR 0 6
29409: IFFALSE 29545
// begin for j in cranes do
29411: LD_ADDR_VAR 0 3
29415: PUSH
29416: LD_VAR 0 6
29420: PUSH
29421: FOR_IN
29422: IFFALSE 29543
// if GetLives ( j ) >= 500 and not HasTask ( j ) then
29424: LD_VAR 0 3
29428: PPUSH
29429: CALL_OW 256
29433: PUSH
29434: LD_INT 500
29436: GREATEREQUAL
29437: PUSH
29438: LD_VAR 0 3
29442: PPUSH
29443: CALL_OW 314
29447: NOT
29448: AND
29449: IFFALSE 29483
// ComRepairBuilding ( j , NearestUnitToUnit ( mc_building_need_repair [ i ] , j ) ) else
29451: LD_VAR 0 3
29455: PPUSH
29456: LD_EXP 75
29460: PUSH
29461: LD_VAR 0 2
29465: ARRAY
29466: PPUSH
29467: LD_VAR 0 3
29471: PPUSH
29472: CALL_OW 74
29476: PPUSH
29477: CALL_OW 130
29481: GO 29541
// if GetLives ( j ) < 500 and not IsInArea ( j , mc_parking [ i ] ) then
29483: LD_VAR 0 3
29487: PPUSH
29488: CALL_OW 256
29492: PUSH
29493: LD_INT 500
29495: LESS
29496: PUSH
29497: LD_VAR 0 3
29501: PPUSH
29502: LD_EXP 98
29506: PUSH
29507: LD_VAR 0 2
29511: ARRAY
29512: PPUSH
29513: CALL_OW 308
29517: NOT
29518: AND
29519: IFFALSE 29541
// ComMoveToArea ( j , mc_parking [ i ] ) ;
29521: LD_VAR 0 3
29525: PPUSH
29526: LD_EXP 98
29530: PUSH
29531: LD_VAR 0 2
29535: ARRAY
29536: PPUSH
29537: CALL_OW 113
29541: GO 29421
29543: POP
29544: POP
// end ; if not tmp then
29545: LD_VAR 0 5
29549: NOT
29550: IFFALSE 29554
// continue ;
29552: GO 29070
// for j in tmp do
29554: LD_ADDR_VAR 0 3
29558: PUSH
29559: LD_VAR 0 5
29563: PUSH
29564: FOR_IN
29565: IFFALSE 29759
// begin if mc_need_heal [ i ] then
29567: LD_EXP 77
29571: PUSH
29572: LD_VAR 0 2
29576: ARRAY
29577: IFFALSE 29625
// if j in mc_need_heal [ i ] [ 1 ] or j in mc_need_heal [ i ] [ 2 ] then
29579: LD_VAR 0 3
29583: PUSH
29584: LD_EXP 77
29588: PUSH
29589: LD_VAR 0 2
29593: ARRAY
29594: PUSH
29595: LD_INT 1
29597: ARRAY
29598: IN
29599: PUSH
29600: LD_VAR 0 3
29604: PUSH
29605: LD_EXP 77
29609: PUSH
29610: LD_VAR 0 2
29614: ARRAY
29615: PUSH
29616: LD_INT 2
29618: ARRAY
29619: IN
29620: OR
29621: IFFALSE 29625
// continue ;
29623: GO 29564
// if IsInUnit ( j ) then
29625: LD_VAR 0 3
29629: PPUSH
29630: CALL_OW 310
29634: IFFALSE 29645
// ComExitBuilding ( j ) ;
29636: LD_VAR 0 3
29640: PPUSH
29641: CALL_OW 122
// if not j in mc_building_repairs [ i ] then
29645: LD_VAR 0 3
29649: PUSH
29650: LD_EXP 76
29654: PUSH
29655: LD_VAR 0 2
29659: ARRAY
29660: IN
29661: NOT
29662: IFFALSE 29720
// begin SetTag ( j , 101 ) ;
29664: LD_VAR 0 3
29668: PPUSH
29669: LD_INT 101
29671: PPUSH
29672: CALL_OW 109
// mc_building_repairs := ReplaceIn ( mc_building_repairs , [ i , mc_building_repairs [ i ] + 1 ] , j ) ;
29676: LD_ADDR_EXP 76
29680: PUSH
29681: LD_EXP 76
29685: PPUSH
29686: LD_VAR 0 2
29690: PUSH
29691: LD_EXP 76
29695: PUSH
29696: LD_VAR 0 2
29700: ARRAY
29701: PUSH
29702: LD_INT 1
29704: PLUS
29705: PUSH
29706: EMPTY
29707: LIST
29708: LIST
29709: PPUSH
29710: LD_VAR 0 3
29714: PPUSH
29715: CALL 56953 0 3
29719: ST_TO_ADDR
// end ; wait ( 1 ) ;
29720: LD_INT 1
29722: PPUSH
29723: CALL_OW 67
// ComRepairBuilding ( j , NearestUnitToUnit ( mc_building_need_repair [ i ] , j ) ) ;
29727: LD_VAR 0 3
29731: PPUSH
29732: LD_EXP 75
29736: PUSH
29737: LD_VAR 0 2
29741: ARRAY
29742: PPUSH
29743: LD_VAR 0 3
29747: PPUSH
29748: CALL_OW 74
29752: PPUSH
29753: CALL_OW 130
// end ;
29757: GO 29564
29759: POP
29760: POP
// end ;
29761: GO 29070
29763: POP
29764: POP
// end ;
29765: LD_VAR 0 1
29769: RET
// export function MC_Heal ; var i , j , tmp ; begin
29770: LD_INT 0
29772: PPUSH
29773: PPUSH
29774: PPUSH
29775: PPUSH
// if not mc_bases then
29776: LD_EXP 74
29780: NOT
29781: IFFALSE 29785
// exit ;
29783: GO 30187
// for i = 1 to mc_bases do
29785: LD_ADDR_VAR 0 2
29789: PUSH
29790: DOUBLE
29791: LD_INT 1
29793: DEC
29794: ST_TO_ADDR
29795: LD_EXP 74
29799: PUSH
29800: FOR_TO
29801: IFFALSE 30185
// begin if not mc_need_heal [ i ] [ 1 ] and not mc_need_heal [ i ] [ 2 ] then
29803: LD_EXP 77
29807: PUSH
29808: LD_VAR 0 2
29812: ARRAY
29813: PUSH
29814: LD_INT 1
29816: ARRAY
29817: NOT
29818: PUSH
29819: LD_EXP 77
29823: PUSH
29824: LD_VAR 0 2
29828: ARRAY
29829: PUSH
29830: LD_INT 2
29832: ARRAY
29833: NOT
29834: AND
29835: IFFALSE 29873
// begin mc_healers := Replace ( mc_healers , i , [ ] ) ;
29837: LD_ADDR_EXP 78
29841: PUSH
29842: LD_EXP 78
29846: PPUSH
29847: LD_VAR 0 2
29851: PPUSH
29852: EMPTY
29853: PPUSH
29854: CALL_OW 1
29858: ST_TO_ADDR
// MC_Reset ( i , 102 ) ;
29859: LD_VAR 0 2
29863: PPUSH
29864: LD_INT 102
29866: PPUSH
29867: CALL 24150 0 2
// continue ;
29871: GO 29800
// end ; tmp := UnitFilter ( mc_bases [ i ] , [ f_class , 4 ] ) ;
29873: LD_ADDR_VAR 0 4
29877: PUSH
29878: LD_EXP 74
29882: PUSH
29883: LD_VAR 0 2
29887: ARRAY
29888: PPUSH
29889: LD_INT 25
29891: PUSH
29892: LD_INT 4
29894: PUSH
29895: EMPTY
29896: LIST
29897: LIST
29898: PPUSH
29899: CALL_OW 72
29903: ST_TO_ADDR
// if not tmp then
29904: LD_VAR 0 4
29908: NOT
29909: IFFALSE 29913
// continue ;
29911: GO 29800
// if mc_taming [ i ] then
29913: LD_EXP 105
29917: PUSH
29918: LD_VAR 0 2
29922: ARRAY
29923: IFFALSE 29947
// mc_taming := Replace ( mc_taming , i , [ ] ) ;
29925: LD_ADDR_EXP 105
29929: PUSH
29930: LD_EXP 105
29934: PPUSH
29935: LD_VAR 0 2
29939: PPUSH
29940: EMPTY
29941: PPUSH
29942: CALL_OW 1
29946: ST_TO_ADDR
// for j in tmp do
29947: LD_ADDR_VAR 0 3
29951: PUSH
29952: LD_VAR 0 4
29956: PUSH
29957: FOR_IN
29958: IFFALSE 30181
// begin if IsInUnit ( j ) then
29960: LD_VAR 0 3
29964: PPUSH
29965: CALL_OW 310
29969: IFFALSE 29980
// ComExitBuilding ( j ) ;
29971: LD_VAR 0 3
29975: PPUSH
29976: CALL_OW 122
// if not j in mc_healers [ i ] then
29980: LD_VAR 0 3
29984: PUSH
29985: LD_EXP 78
29989: PUSH
29990: LD_VAR 0 2
29994: ARRAY
29995: IN
29996: NOT
29997: IFFALSE 30043
// mc_healers := ReplaceIn ( mc_healers , [ i , mc_healers [ i ] + 1 ] , j ) ;
29999: LD_ADDR_EXP 78
30003: PUSH
30004: LD_EXP 78
30008: PPUSH
30009: LD_VAR 0 2
30013: PUSH
30014: LD_EXP 78
30018: PUSH
30019: LD_VAR 0 2
30023: ARRAY
30024: PUSH
30025: LD_INT 1
30027: PLUS
30028: PUSH
30029: EMPTY
30030: LIST
30031: LIST
30032: PPUSH
30033: LD_VAR 0 3
30037: PPUSH
30038: CALL 56953 0 3
30042: ST_TO_ADDR
// if GetTag ( j ) <> 102 then
30043: LD_VAR 0 3
30047: PPUSH
30048: CALL_OW 110
30052: PUSH
30053: LD_INT 102
30055: NONEQUAL
30056: IFFALSE 30070
// SetTag ( j , 102 ) ;
30058: LD_VAR 0 3
30062: PPUSH
30063: LD_INT 102
30065: PPUSH
30066: CALL_OW 109
// Wait ( 3 ) ;
30070: LD_INT 3
30072: PPUSH
30073: CALL_OW 67
// if mc_need_heal [ i ] [ 1 ] then
30077: LD_EXP 77
30081: PUSH
30082: LD_VAR 0 2
30086: ARRAY
30087: PUSH
30088: LD_INT 1
30090: ARRAY
30091: IFFALSE 30123
// ComHeal ( j , mc_need_heal [ i ] [ 1 ] [ 1 ] ) else
30093: LD_VAR 0 3
30097: PPUSH
30098: LD_EXP 77
30102: PUSH
30103: LD_VAR 0 2
30107: ARRAY
30108: PUSH
30109: LD_INT 1
30111: ARRAY
30112: PUSH
30113: LD_INT 1
30115: ARRAY
30116: PPUSH
30117: CALL_OW 128
30121: GO 30179
// if not HasTask ( j ) and mc_need_heal [ i ] [ 2 ] then
30123: LD_VAR 0 3
30127: PPUSH
30128: CALL_OW 314
30132: NOT
30133: PUSH
30134: LD_EXP 77
30138: PUSH
30139: LD_VAR 0 2
30143: ARRAY
30144: PUSH
30145: LD_INT 2
30147: ARRAY
30148: AND
30149: IFFALSE 30179
// ComHeal ( j , mc_need_heal [ i ] [ 2 ] [ 1 ] ) ;
30151: LD_VAR 0 3
30155: PPUSH
30156: LD_EXP 77
30160: PUSH
30161: LD_VAR 0 2
30165: ARRAY
30166: PUSH
30167: LD_INT 2
30169: ARRAY
30170: PUSH
30171: LD_INT 1
30173: ARRAY
30174: PPUSH
30175: CALL_OW 128
// end ;
30179: GO 29957
30181: POP
30182: POP
// end ;
30183: GO 29800
30185: POP
30186: POP
// end ;
30187: LD_VAR 0 1
30191: RET
// export function MC_Build ( ) ; var i , j , tmp , depot ; begin
30192: LD_INT 0
30194: PPUSH
30195: PPUSH
30196: PPUSH
30197: PPUSH
30198: PPUSH
// if not mc_bases then
30199: LD_EXP 74
30203: NOT
30204: IFFALSE 30208
// exit ;
30206: GO 31351
// for i = 1 to mc_bases do
30208: LD_ADDR_VAR 0 2
30212: PUSH
30213: DOUBLE
30214: LD_INT 1
30216: DEC
30217: ST_TO_ADDR
30218: LD_EXP 74
30222: PUSH
30223: FOR_TO
30224: IFFALSE 31349
// begin if mc_scan [ i ] then
30226: LD_EXP 97
30230: PUSH
30231: LD_VAR 0 2
30235: ARRAY
30236: IFFALSE 30240
// continue ;
30238: GO 30223
// if not mc_build_list [ i ] and not mc_construct_list [ i ] and mc_builders [ i ] then
30240: LD_EXP 79
30244: PUSH
30245: LD_VAR 0 2
30249: ARRAY
30250: NOT
30251: PUSH
30252: LD_EXP 81
30256: PUSH
30257: LD_VAR 0 2
30261: ARRAY
30262: NOT
30263: AND
30264: PUSH
30265: LD_EXP 80
30269: PUSH
30270: LD_VAR 0 2
30274: ARRAY
30275: AND
30276: IFFALSE 30314
// begin mc_builders := Replace ( mc_builders , i , [ ] ) ;
30278: LD_ADDR_EXP 80
30282: PUSH
30283: LD_EXP 80
30287: PPUSH
30288: LD_VAR 0 2
30292: PPUSH
30293: EMPTY
30294: PPUSH
30295: CALL_OW 1
30299: ST_TO_ADDR
// MC_Reset ( i , 103 ) ;
30300: LD_VAR 0 2
30304: PPUSH
30305: LD_INT 103
30307: PPUSH
30308: CALL 24150 0 2
// continue ;
30312: GO 30223
// end ; if mc_construct_list [ i ] then
30314: LD_EXP 81
30318: PUSH
30319: LD_VAR 0 2
30323: ARRAY
30324: IFFALSE 30544
// begin tmp := UnitFilter ( mc_bases [ i ] , [ f_class , 2 ] ) diff mc_building_repairs [ i ] ;
30326: LD_ADDR_VAR 0 4
30330: PUSH
30331: LD_EXP 74
30335: PUSH
30336: LD_VAR 0 2
30340: ARRAY
30341: PPUSH
30342: LD_INT 25
30344: PUSH
30345: LD_INT 2
30347: PUSH
30348: EMPTY
30349: LIST
30350: LIST
30351: PPUSH
30352: CALL_OW 72
30356: PUSH
30357: LD_EXP 76
30361: PUSH
30362: LD_VAR 0 2
30366: ARRAY
30367: DIFF
30368: ST_TO_ADDR
// if not tmp then
30369: LD_VAR 0 4
30373: NOT
30374: IFFALSE 30378
// continue ;
30376: GO 30223
// for j in tmp do
30378: LD_ADDR_VAR 0 3
30382: PUSH
30383: LD_VAR 0 4
30387: PUSH
30388: FOR_IN
30389: IFFALSE 30540
// begin if not mc_builders [ i ] then
30391: LD_EXP 80
30395: PUSH
30396: LD_VAR 0 2
30400: ARRAY
30401: NOT
30402: IFFALSE 30460
// begin SetTag ( j , 103 ) ;
30404: LD_VAR 0 3
30408: PPUSH
30409: LD_INT 103
30411: PPUSH
30412: CALL_OW 109
// mc_builders := ReplaceIn ( mc_builders , [ i , mc_builders [ i ] + 1 ] , j ) ;
30416: LD_ADDR_EXP 80
30420: PUSH
30421: LD_EXP 80
30425: PPUSH
30426: LD_VAR 0 2
30430: PUSH
30431: LD_EXP 80
30435: PUSH
30436: LD_VAR 0 2
30440: ARRAY
30441: PUSH
30442: LD_INT 1
30444: PLUS
30445: PUSH
30446: EMPTY
30447: LIST
30448: LIST
30449: PPUSH
30450: LD_VAR 0 3
30454: PPUSH
30455: CALL 56953 0 3
30459: ST_TO_ADDR
// end ; if IsInUnit ( j ) then
30460: LD_VAR 0 3
30464: PPUSH
30465: CALL_OW 310
30469: IFFALSE 30480
// ComExitBuilding ( j ) ;
30471: LD_VAR 0 3
30475: PPUSH
30476: CALL_OW 122
// wait ( 3 ) ;
30480: LD_INT 3
30482: PPUSH
30483: CALL_OW 67
// if not mc_construct_list [ i ] then
30487: LD_EXP 81
30491: PUSH
30492: LD_VAR 0 2
30496: ARRAY
30497: NOT
30498: IFFALSE 30502
// break ;
30500: GO 30540
// if not HasTask ( j ) then
30502: LD_VAR 0 3
30506: PPUSH
30507: CALL_OW 314
30511: NOT
30512: IFFALSE 30538
// ComComplete ( j , mc_construct_list [ i ] [ 1 ] ) ;
30514: LD_VAR 0 3
30518: PPUSH
30519: LD_EXP 81
30523: PUSH
30524: LD_VAR 0 2
30528: ARRAY
30529: PUSH
30530: LD_INT 1
30532: ARRAY
30533: PPUSH
30534: CALL 59804 0 2
// end ;
30538: GO 30388
30540: POP
30541: POP
// end else
30542: GO 31347
// if mc_build_list [ i ] then
30544: LD_EXP 79
30548: PUSH
30549: LD_VAR 0 2
30553: ARRAY
30554: IFFALSE 31347
// begin depot := UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) ;
30556: LD_ADDR_VAR 0 5
30560: PUSH
30561: LD_EXP 74
30565: PUSH
30566: LD_VAR 0 2
30570: ARRAY
30571: PPUSH
30572: LD_INT 2
30574: PUSH
30575: LD_INT 30
30577: PUSH
30578: LD_INT 0
30580: PUSH
30581: EMPTY
30582: LIST
30583: LIST
30584: PUSH
30585: LD_INT 30
30587: PUSH
30588: LD_INT 1
30590: PUSH
30591: EMPTY
30592: LIST
30593: LIST
30594: PUSH
30595: EMPTY
30596: LIST
30597: LIST
30598: LIST
30599: PPUSH
30600: CALL_OW 72
30604: ST_TO_ADDR
// if depot then
30605: LD_VAR 0 5
30609: IFFALSE 30627
// depot := depot [ 1 ] else
30611: LD_ADDR_VAR 0 5
30615: PUSH
30616: LD_VAR 0 5
30620: PUSH
30621: LD_INT 1
30623: ARRAY
30624: ST_TO_ADDR
30625: GO 30635
// depot := 0 ;
30627: LD_ADDR_VAR 0 5
30631: PUSH
30632: LD_INT 0
30634: ST_TO_ADDR
// if IsExtension ( mc_build_list [ i ] [ 1 ] [ 1 ] ) and not UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_workshop ] , [ f_btype , b_factory ] ] ) then
30635: LD_EXP 79
30639: PUSH
30640: LD_VAR 0 2
30644: ARRAY
30645: PUSH
30646: LD_INT 1
30648: ARRAY
30649: PUSH
30650: LD_INT 1
30652: ARRAY
30653: PPUSH
30654: CALL 59634 0 1
30658: PUSH
30659: LD_EXP 74
30663: PUSH
30664: LD_VAR 0 2
30668: ARRAY
30669: PPUSH
30670: LD_INT 2
30672: PUSH
30673: LD_INT 30
30675: PUSH
30676: LD_INT 2
30678: PUSH
30679: EMPTY
30680: LIST
30681: LIST
30682: PUSH
30683: LD_INT 30
30685: PUSH
30686: LD_INT 3
30688: PUSH
30689: EMPTY
30690: LIST
30691: LIST
30692: PUSH
30693: EMPTY
30694: LIST
30695: LIST
30696: LIST
30697: PPUSH
30698: CALL_OW 72
30702: NOT
30703: AND
30704: IFFALSE 30809
// begin for j = 1 to mc_build_list [ i ] do
30706: LD_ADDR_VAR 0 3
30710: PUSH
30711: DOUBLE
30712: LD_INT 1
30714: DEC
30715: ST_TO_ADDR
30716: LD_EXP 79
30720: PUSH
30721: LD_VAR 0 2
30725: ARRAY
30726: PUSH
30727: FOR_TO
30728: IFFALSE 30807
// if mc_build_list [ i ] [ j ] [ 1 ] = b_workshop then
30730: LD_EXP 79
30734: PUSH
30735: LD_VAR 0 2
30739: ARRAY
30740: PUSH
30741: LD_VAR 0 3
30745: ARRAY
30746: PUSH
30747: LD_INT 1
30749: ARRAY
30750: PUSH
30751: LD_INT 2
30753: EQUAL
30754: IFFALSE 30805
// begin mc_build_list := Replace ( mc_build_list , i , Reindex ( mc_build_list [ i ] , j , 1 , false ) ) ;
30756: LD_ADDR_EXP 79
30760: PUSH
30761: LD_EXP 79
30765: PPUSH
30766: LD_VAR 0 2
30770: PPUSH
30771: LD_EXP 79
30775: PUSH
30776: LD_VAR 0 2
30780: ARRAY
30781: PPUSH
30782: LD_VAR 0 3
30786: PPUSH
30787: LD_INT 1
30789: PPUSH
30790: LD_INT 0
30792: PPUSH
30793: CALL 56371 0 4
30797: PPUSH
30798: CALL_OW 1
30802: ST_TO_ADDR
// break ;
30803: GO 30807
// end ;
30805: GO 30727
30807: POP
30808: POP
// end ; if mc_build_list [ i ] [ 1 ] [ 1 ] = b_depot or ( depot and CanBeBuilt ( depot , mc_build_list [ i ] [ 1 ] [ 1 ] , mc_build_list [ i ] [ 1 ] [ 2 ] , mc_build_list [ i ] [ 1 ] [ 3 ] , mc_build_list [ i ] [ 1 ] [ 4 ] ) ) then
30809: LD_EXP 79
30813: PUSH
30814: LD_VAR 0 2
30818: ARRAY
30819: PUSH
30820: LD_INT 1
30822: ARRAY
30823: PUSH
30824: LD_INT 1
30826: ARRAY
30827: PUSH
30828: LD_INT 0
30830: EQUAL
30831: PUSH
30832: LD_VAR 0 5
30836: PUSH
30837: LD_VAR 0 5
30841: PPUSH
30842: LD_EXP 79
30846: PUSH
30847: LD_VAR 0 2
30851: ARRAY
30852: PUSH
30853: LD_INT 1
30855: ARRAY
30856: PUSH
30857: LD_INT 1
30859: ARRAY
30860: PPUSH
30861: LD_EXP 79
30865: PUSH
30866: LD_VAR 0 2
30870: ARRAY
30871: PUSH
30872: LD_INT 1
30874: ARRAY
30875: PUSH
30876: LD_INT 2
30878: ARRAY
30879: PPUSH
30880: LD_EXP 79
30884: PUSH
30885: LD_VAR 0 2
30889: ARRAY
30890: PUSH
30891: LD_INT 1
30893: ARRAY
30894: PUSH
30895: LD_INT 3
30897: ARRAY
30898: PPUSH
30899: LD_EXP 79
30903: PUSH
30904: LD_VAR 0 2
30908: ARRAY
30909: PUSH
30910: LD_INT 1
30912: ARRAY
30913: PUSH
30914: LD_INT 4
30916: ARRAY
30917: PPUSH
30918: CALL 64368 0 5
30922: AND
30923: OR
30924: IFFALSE 31205
// begin tmp := UnitFilter ( mc_bases [ i ] , [ f_class , 2 ] ) diff mc_building_repairs [ i ] ;
30926: LD_ADDR_VAR 0 4
30930: PUSH
30931: LD_EXP 74
30935: PUSH
30936: LD_VAR 0 2
30940: ARRAY
30941: PPUSH
30942: LD_INT 25
30944: PUSH
30945: LD_INT 2
30947: PUSH
30948: EMPTY
30949: LIST
30950: LIST
30951: PPUSH
30952: CALL_OW 72
30956: PUSH
30957: LD_EXP 76
30961: PUSH
30962: LD_VAR 0 2
30966: ARRAY
30967: DIFF
30968: ST_TO_ADDR
// if not tmp then
30969: LD_VAR 0 4
30973: NOT
30974: IFFALSE 30978
// continue ;
30976: GO 30223
// for j in tmp do
30978: LD_ADDR_VAR 0 3
30982: PUSH
30983: LD_VAR 0 4
30987: PUSH
30988: FOR_IN
30989: IFFALSE 31201
// begin if not mc_builders [ i ] then
30991: LD_EXP 80
30995: PUSH
30996: LD_VAR 0 2
31000: ARRAY
31001: NOT
31002: IFFALSE 31060
// begin SetTag ( j , 103 ) ;
31004: LD_VAR 0 3
31008: PPUSH
31009: LD_INT 103
31011: PPUSH
31012: CALL_OW 109
// mc_builders := ReplaceIn ( mc_builders , [ i , mc_builders [ i ] + 1 ] , j ) ;
31016: LD_ADDR_EXP 80
31020: PUSH
31021: LD_EXP 80
31025: PPUSH
31026: LD_VAR 0 2
31030: PUSH
31031: LD_EXP 80
31035: PUSH
31036: LD_VAR 0 2
31040: ARRAY
31041: PUSH
31042: LD_INT 1
31044: PLUS
31045: PUSH
31046: EMPTY
31047: LIST
31048: LIST
31049: PPUSH
31050: LD_VAR 0 3
31054: PPUSH
31055: CALL 56953 0 3
31059: ST_TO_ADDR
// end ; if IsInUnit ( j ) then
31060: LD_VAR 0 3
31064: PPUSH
31065: CALL_OW 310
31069: IFFALSE 31080
// ComExitBuilding ( j ) ;
31071: LD_VAR 0 3
31075: PPUSH
31076: CALL_OW 122
// wait ( 3 ) ;
31080: LD_INT 3
31082: PPUSH
31083: CALL_OW 67
// if not mc_build_list [ i ] then
31087: LD_EXP 79
31091: PUSH
31092: LD_VAR 0 2
31096: ARRAY
31097: NOT
31098: IFFALSE 31102
// break ;
31100: GO 31201
// if not HasTask ( j ) then
31102: LD_VAR 0 3
31106: PPUSH
31107: CALL_OW 314
31111: NOT
31112: IFFALSE 31199
// ComBuild ( j , mc_build_list [ i ] [ 1 ] [ 1 ] , mc_build_list [ i ] [ 1 ] [ 2 ] , mc_build_list [ i ] [ 1 ] [ 3 ] , mc_build_list [ i ] [ 1 ] [ 4 ] ) ;
31114: LD_VAR 0 3
31118: PPUSH
31119: LD_EXP 79
31123: PUSH
31124: LD_VAR 0 2
31128: ARRAY
31129: PUSH
31130: LD_INT 1
31132: ARRAY
31133: PUSH
31134: LD_INT 1
31136: ARRAY
31137: PPUSH
31138: LD_EXP 79
31142: PUSH
31143: LD_VAR 0 2
31147: ARRAY
31148: PUSH
31149: LD_INT 1
31151: ARRAY
31152: PUSH
31153: LD_INT 2
31155: ARRAY
31156: PPUSH
31157: LD_EXP 79
31161: PUSH
31162: LD_VAR 0 2
31166: ARRAY
31167: PUSH
31168: LD_INT 1
31170: ARRAY
31171: PUSH
31172: LD_INT 3
31174: ARRAY
31175: PPUSH
31176: LD_EXP 79
31180: PUSH
31181: LD_VAR 0 2
31185: ARRAY
31186: PUSH
31187: LD_INT 1
31189: ARRAY
31190: PUSH
31191: LD_INT 4
31193: ARRAY
31194: PPUSH
31195: CALL_OW 145
// end ;
31199: GO 30988
31201: POP
31202: POP
// end else
31203: GO 31347
// if not TryClearPlaceForBuilding ( mc_bases [ i ] , mc_build_list [ i ] [ 1 ] [ 1 ] , mc_build_list [ i ] [ 1 ] [ 2 ] , mc_build_list [ i ] [ 1 ] [ 3 ] , mc_build_list [ i ] [ 1 ] [ 4 ] ) then
31205: LD_EXP 74
31209: PUSH
31210: LD_VAR 0 2
31214: ARRAY
31215: PPUSH
31216: LD_EXP 79
31220: PUSH
31221: LD_VAR 0 2
31225: ARRAY
31226: PUSH
31227: LD_INT 1
31229: ARRAY
31230: PUSH
31231: LD_INT 1
31233: ARRAY
31234: PPUSH
31235: LD_EXP 79
31239: PUSH
31240: LD_VAR 0 2
31244: ARRAY
31245: PUSH
31246: LD_INT 1
31248: ARRAY
31249: PUSH
31250: LD_INT 2
31252: ARRAY
31253: PPUSH
31254: LD_EXP 79
31258: PUSH
31259: LD_VAR 0 2
31263: ARRAY
31264: PUSH
31265: LD_INT 1
31267: ARRAY
31268: PUSH
31269: LD_INT 3
31271: ARRAY
31272: PPUSH
31273: LD_EXP 79
31277: PUSH
31278: LD_VAR 0 2
31282: ARRAY
31283: PUSH
31284: LD_INT 1
31286: ARRAY
31287: PUSH
31288: LD_INT 4
31290: ARRAY
31291: PPUSH
31292: CALL 63704 0 5
31296: NOT
31297: IFFALSE 31347
// begin mc_build_list := Replace ( mc_build_list , i , Reindex ( mc_build_list [ i ] , 1 , - 1 , false ) ) ;
31299: LD_ADDR_EXP 79
31303: PUSH
31304: LD_EXP 79
31308: PPUSH
31309: LD_VAR 0 2
31313: PPUSH
31314: LD_EXP 79
31318: PUSH
31319: LD_VAR 0 2
31323: ARRAY
31324: PPUSH
31325: LD_INT 1
31327: PPUSH
31328: LD_INT 1
31330: NEG
31331: PPUSH
31332: LD_INT 0
31334: PPUSH
31335: CALL 56371 0 4
31339: PPUSH
31340: CALL_OW 1
31344: ST_TO_ADDR
// continue ;
31345: GO 30223
// end ; end ; end ;
31347: GO 30223
31349: POP
31350: POP
// end ;
31351: LD_VAR 0 1
31355: RET
// export function MC_BuildUpgrade ( ) ; var i , j , tmp , depot , lab ; begin
31356: LD_INT 0
31358: PPUSH
31359: PPUSH
31360: PPUSH
31361: PPUSH
31362: PPUSH
31363: PPUSH
// if not mc_bases then
31364: LD_EXP 74
31368: NOT
31369: IFFALSE 31373
// exit ;
31371: GO 31800
// for i = 1 to mc_bases do
31373: LD_ADDR_VAR 0 2
31377: PUSH
31378: DOUBLE
31379: LD_INT 1
31381: DEC
31382: ST_TO_ADDR
31383: LD_EXP 74
31387: PUSH
31388: FOR_TO
31389: IFFALSE 31798
// begin tmp := mc_build_upgrade [ i ] ;
31391: LD_ADDR_VAR 0 4
31395: PUSH
31396: LD_EXP 106
31400: PUSH
31401: LD_VAR 0 2
31405: ARRAY
31406: ST_TO_ADDR
// lab := UnitFilter ( mc_lab [ i ] , [ f_or , [ f_btype , b_lab ] , [ f_btype , b_lab_half ] ] ) ;
31407: LD_ADDR_VAR 0 6
31411: PUSH
31412: LD_EXP 107
31416: PUSH
31417: LD_VAR 0 2
31421: ARRAY
31422: PPUSH
31423: LD_INT 2
31425: PUSH
31426: LD_INT 30
31428: PUSH
31429: LD_INT 6
31431: PUSH
31432: EMPTY
31433: LIST
31434: LIST
31435: PUSH
31436: LD_INT 30
31438: PUSH
31439: LD_INT 7
31441: PUSH
31442: EMPTY
31443: LIST
31444: LIST
31445: PUSH
31446: EMPTY
31447: LIST
31448: LIST
31449: LIST
31450: PPUSH
31451: CALL_OW 72
31455: ST_TO_ADDR
// if not tmp and not lab then
31456: LD_VAR 0 4
31460: NOT
31461: PUSH
31462: LD_VAR 0 6
31466: NOT
31467: AND
31468: IFFALSE 31472
// continue ;
31470: GO 31388
// if tmp then
31472: LD_VAR 0 4
31476: IFFALSE 31596
// for j in tmp do
31478: LD_ADDR_VAR 0 3
31482: PUSH
31483: LD_VAR 0 4
31487: PUSH
31488: FOR_IN
31489: IFFALSE 31594
// begin if UpgradeCost ( j ) then
31491: LD_VAR 0 3
31495: PPUSH
31496: CALL 63364 0 1
31500: IFFALSE 31592
// begin ComUpgrade ( j ) ;
31502: LD_VAR 0 3
31506: PPUSH
31507: CALL_OW 146
// mc_build_upgrade := Replace ( mc_build_upgrade , i , mc_build_upgrade [ i ] diff j ) ;
31511: LD_ADDR_EXP 106
31515: PUSH
31516: LD_EXP 106
31520: PPUSH
31521: LD_VAR 0 2
31525: PPUSH
31526: LD_EXP 106
31530: PUSH
31531: LD_VAR 0 2
31535: ARRAY
31536: PUSH
31537: LD_VAR 0 3
31541: DIFF
31542: PPUSH
31543: CALL_OW 1
31547: ST_TO_ADDR
// mc_construct_list := ReplaceIn ( mc_construct_list , [ i , mc_construct_list [ i ] + 1 ] , j ) ;
31548: LD_ADDR_EXP 81
31552: PUSH
31553: LD_EXP 81
31557: PPUSH
31558: LD_VAR 0 2
31562: PUSH
31563: LD_EXP 81
31567: PUSH
31568: LD_VAR 0 2
31572: ARRAY
31573: PUSH
31574: LD_INT 1
31576: PLUS
31577: PUSH
31578: EMPTY
31579: LIST
31580: LIST
31581: PPUSH
31582: LD_VAR 0 3
31586: PPUSH
31587: CALL 56953 0 3
31591: ST_TO_ADDR
// end ; end ;
31592: GO 31488
31594: POP
31595: POP
// if not lab or not mc_lab_upgrade [ i ] then
31596: LD_VAR 0 6
31600: NOT
31601: PUSH
31602: LD_EXP 108
31606: PUSH
31607: LD_VAR 0 2
31611: ARRAY
31612: NOT
31613: OR
31614: IFFALSE 31618
// continue ;
31616: GO 31388
// for j in lab do
31618: LD_ADDR_VAR 0 3
31622: PUSH
31623: LD_VAR 0 6
31627: PUSH
31628: FOR_IN
31629: IFFALSE 31794
// begin if GetBType ( j ) in [ b_lab , b_lab_half ] and BuildingStatus ( j ) <> bs_build then
31631: LD_VAR 0 3
31635: PPUSH
31636: CALL_OW 266
31640: PUSH
31641: LD_INT 6
31643: PUSH
31644: LD_INT 7
31646: PUSH
31647: EMPTY
31648: LIST
31649: LIST
31650: IN
31651: PUSH
31652: LD_VAR 0 3
31656: PPUSH
31657: CALL_OW 461
31661: PUSH
31662: LD_INT 1
31664: NONEQUAL
31665: AND
31666: IFFALSE 31792
// begin if UpgradeLabCost ( j , mc_lab_upgrade [ i ] [ 1 ] ) then
31668: LD_VAR 0 3
31672: PPUSH
31673: LD_EXP 108
31677: PUSH
31678: LD_VAR 0 2
31682: ARRAY
31683: PUSH
31684: LD_INT 1
31686: ARRAY
31687: PPUSH
31688: CALL 63569 0 2
31692: IFFALSE 31792
// begin ComCancel ( j ) ;
31694: LD_VAR 0 3
31698: PPUSH
31699: CALL_OW 127
// AddComUpgradeLab ( j , mc_lab_upgrade [ i ] [ 1 ] ) ;
31703: LD_VAR 0 3
31707: PPUSH
31708: LD_EXP 108
31712: PUSH
31713: LD_VAR 0 2
31717: ARRAY
31718: PUSH
31719: LD_INT 1
31721: ARRAY
31722: PPUSH
31723: CALL_OW 207
// if not j in mc_construct_list [ i ] then
31727: LD_VAR 0 3
31731: PUSH
31732: LD_EXP 81
31736: PUSH
31737: LD_VAR 0 2
31741: ARRAY
31742: IN
31743: NOT
31744: IFFALSE 31790
// mc_construct_list := ReplaceIn ( mc_construct_list , [ i , mc_construct_list [ i ] + 1 ] , j ) ;
31746: LD_ADDR_EXP 81
31750: PUSH
31751: LD_EXP 81
31755: PPUSH
31756: LD_VAR 0 2
31760: PUSH
31761: LD_EXP 81
31765: PUSH
31766: LD_VAR 0 2
31770: ARRAY
31771: PUSH
31772: LD_INT 1
31774: PLUS
31775: PUSH
31776: EMPTY
31777: LIST
31778: LIST
31779: PPUSH
31780: LD_VAR 0 3
31784: PPUSH
31785: CALL 56953 0 3
31789: ST_TO_ADDR
// break ;
31790: GO 31794
// end ; end ; end ;
31792: GO 31628
31794: POP
31795: POP
// end ;
31796: GO 31388
31798: POP
31799: POP
// end ;
31800: LD_VAR 0 1
31804: RET
// export function MC_TurretWeapon ( ) ; var i , j , tmp , tmp2 , t , tw , busy , weapon ; begin
31805: LD_INT 0
31807: PPUSH
31808: PPUSH
31809: PPUSH
31810: PPUSH
31811: PPUSH
31812: PPUSH
31813: PPUSH
31814: PPUSH
31815: PPUSH
// if not mc_bases then
31816: LD_EXP 74
31820: NOT
31821: IFFALSE 31825
// exit ;
31823: GO 32230
// for i = 1 to mc_bases do
31825: LD_ADDR_VAR 0 2
31829: PUSH
31830: DOUBLE
31831: LD_INT 1
31833: DEC
31834: ST_TO_ADDR
31835: LD_EXP 74
31839: PUSH
31840: FOR_TO
31841: IFFALSE 32228
// begin if not mc_turret_list [ i ] or not UnitFilter ( mc_bases [ i ] , [ f_btype , b_factory ] ) then
31843: LD_EXP 82
31847: PUSH
31848: LD_VAR 0 2
31852: ARRAY
31853: NOT
31854: PUSH
31855: LD_EXP 74
31859: PUSH
31860: LD_VAR 0 2
31864: ARRAY
31865: PPUSH
31866: LD_INT 30
31868: PUSH
31869: LD_INT 3
31871: PUSH
31872: EMPTY
31873: LIST
31874: LIST
31875: PPUSH
31876: CALL_OW 72
31880: NOT
31881: OR
31882: IFFALSE 31886
// continue ;
31884: GO 31840
// busy := false ;
31886: LD_ADDR_VAR 0 8
31890: PUSH
31891: LD_INT 0
31893: ST_TO_ADDR
// tmp := UnitFilter ( mc_bases [ i ] , [ f_btype , b_factory ] ) ;
31894: LD_ADDR_VAR 0 4
31898: PUSH
31899: LD_EXP 74
31903: PUSH
31904: LD_VAR 0 2
31908: ARRAY
31909: PPUSH
31910: LD_INT 30
31912: PUSH
31913: LD_INT 3
31915: PUSH
31916: EMPTY
31917: LIST
31918: LIST
31919: PPUSH
31920: CALL_OW 72
31924: ST_TO_ADDR
// t := UnitFilter ( mc_turret_list [ i ] , [ f_or , [ f_btype , b_bunker ] , [ f_btype , b_turret ] ] ) ;
31925: LD_ADDR_VAR 0 6
31929: PUSH
31930: LD_EXP 82
31934: PUSH
31935: LD_VAR 0 2
31939: ARRAY
31940: PPUSH
31941: LD_INT 2
31943: PUSH
31944: LD_INT 30
31946: PUSH
31947: LD_INT 32
31949: PUSH
31950: EMPTY
31951: LIST
31952: LIST
31953: PUSH
31954: LD_INT 30
31956: PUSH
31957: LD_INT 33
31959: PUSH
31960: EMPTY
31961: LIST
31962: LIST
31963: PUSH
31964: EMPTY
31965: LIST
31966: LIST
31967: LIST
31968: PPUSH
31969: CALL_OW 72
31973: ST_TO_ADDR
// if not t then
31974: LD_VAR 0 6
31978: NOT
31979: IFFALSE 31983
// continue ;
31981: GO 31840
// for j in tmp do
31983: LD_ADDR_VAR 0 3
31987: PUSH
31988: LD_VAR 0 4
31992: PUSH
31993: FOR_IN
31994: IFFALSE 32024
// if not BuildingStatus ( j ) = bs_idle then
31996: LD_VAR 0 3
32000: PPUSH
32001: CALL_OW 461
32005: PUSH
32006: LD_INT 2
32008: EQUAL
32009: NOT
32010: IFFALSE 32022
// begin busy := true ;
32012: LD_ADDR_VAR 0 8
32016: PUSH
32017: LD_INT 1
32019: ST_TO_ADDR
// break ;
32020: GO 32024
// end ;
32022: GO 31993
32024: POP
32025: POP
// if busy then
32026: LD_VAR 0 8
32030: IFFALSE 32034
// continue ;
32032: GO 31840
// tw := UnitFilter ( t , [ f_bweapon , 0 ] ) ;
32034: LD_ADDR_VAR 0 7
32038: PUSH
32039: LD_VAR 0 6
32043: PPUSH
32044: LD_INT 35
32046: PUSH
32047: LD_INT 0
32049: PUSH
32050: EMPTY
32051: LIST
32052: LIST
32053: PPUSH
32054: CALL_OW 72
32058: ST_TO_ADDR
// if tw then
32059: LD_VAR 0 7
32063: IFFALSE 32140
// begin tw := tw [ 1 ] ;
32065: LD_ADDR_VAR 0 7
32069: PUSH
32070: LD_VAR 0 7
32074: PUSH
32075: LD_INT 1
32077: ARRAY
32078: ST_TO_ADDR
// weapon := GetTurretWeapon ( tw , mc_scan_area [ i ] ) ;
32079: LD_ADDR_VAR 0 9
32083: PUSH
32084: LD_VAR 0 7
32088: PPUSH
32089: LD_EXP 99
32093: PUSH
32094: LD_VAR 0 2
32098: ARRAY
32099: PPUSH
32100: CALL 61923 0 2
32104: ST_TO_ADDR
// if mc_allowed_tower_weapons [ i ] then
32105: LD_EXP 113
32109: PUSH
32110: LD_VAR 0 2
32114: ARRAY
32115: IFFALSE 32138
// if not weapon in mc_allowed_tower_weapons [ i ] then
32117: LD_VAR 0 9
32121: PUSH
32122: LD_EXP 113
32126: PUSH
32127: LD_VAR 0 2
32131: ARRAY
32132: IN
32133: NOT
32134: IFFALSE 32138
// continue ;
32136: GO 31840
// end else
32138: GO 32203
// begin tmp2 := UpgradeTurretsWeapon ( mc_turret_list [ i ] , tmp ) ;
32140: LD_ADDR_VAR 0 5
32144: PUSH
32145: LD_EXP 82
32149: PUSH
32150: LD_VAR 0 2
32154: ARRAY
32155: PPUSH
32156: LD_VAR 0 4
32160: PPUSH
32161: CALL 92124 0 2
32165: ST_TO_ADDR
// if not tmp2 then
32166: LD_VAR 0 5
32170: NOT
32171: IFFALSE 32175
// continue ;
32173: GO 31840
// tw := tmp2 [ 1 ] ;
32175: LD_ADDR_VAR 0 7
32179: PUSH
32180: LD_VAR 0 5
32184: PUSH
32185: LD_INT 1
32187: ARRAY
32188: ST_TO_ADDR
// weapon := tmp2 [ 2 ] ;
32189: LD_ADDR_VAR 0 9
32193: PUSH
32194: LD_VAR 0 5
32198: PUSH
32199: LD_INT 2
32201: ARRAY
32202: ST_TO_ADDR
// end ; if not weapon then
32203: LD_VAR 0 9
32207: NOT
32208: IFFALSE 32212
// continue ;
32210: GO 31840
// ComPlaceWeapon ( tw , weapon ) ;
32212: LD_VAR 0 7
32216: PPUSH
32217: LD_VAR 0 9
32221: PPUSH
32222: CALL_OW 148
// end ;
32226: GO 31840
32228: POP
32229: POP
// end ;
32230: LD_VAR 0 1
32234: RET
// export function MC_PlantMines ( ) ; var i , j , k , tmp , list ; begin
32235: LD_INT 0
32237: PPUSH
32238: PPUSH
32239: PPUSH
32240: PPUSH
32241: PPUSH
32242: PPUSH
// if not mc_bases then
32243: LD_EXP 74
32247: NOT
32248: IFFALSE 32252
// exit ;
32250: GO 33264
// for i = 1 to mc_bases do
32252: LD_ADDR_VAR 0 2
32256: PUSH
32257: DOUBLE
32258: LD_INT 1
32260: DEC
32261: ST_TO_ADDR
32262: LD_EXP 74
32266: PUSH
32267: FOR_TO
32268: IFFALSE 33262
// begin if not mc_mines [ i ] or mc_mines [ i ] = mc_miners [ i ] then
32270: LD_EXP 87
32274: PUSH
32275: LD_VAR 0 2
32279: ARRAY
32280: NOT
32281: PUSH
32282: LD_EXP 87
32286: PUSH
32287: LD_VAR 0 2
32291: ARRAY
32292: PUSH
32293: LD_EXP 88
32297: PUSH
32298: LD_VAR 0 2
32302: ARRAY
32303: EQUAL
32304: OR
32305: IFFALSE 32309
// continue ;
32307: GO 32267
// if mc_miners [ i ] then
32309: LD_EXP 88
32313: PUSH
32314: LD_VAR 0 2
32318: ARRAY
32319: IFFALSE 32949
// begin k := 1 ;
32321: LD_ADDR_VAR 0 4
32325: PUSH
32326: LD_INT 1
32328: ST_TO_ADDR
// for j = mc_miners [ i ] downto 1 do
32329: LD_ADDR_VAR 0 3
32333: PUSH
32334: DOUBLE
32335: LD_EXP 88
32339: PUSH
32340: LD_VAR 0 2
32344: ARRAY
32345: INC
32346: ST_TO_ADDR
32347: LD_INT 1
32349: PUSH
32350: FOR_DOWNTO
32351: IFFALSE 32947
// begin if IsDead ( mc_miners [ i ] [ j ] ) or GetClass ( mc_miners [ i ] [ j ] ) <> 1 then
32353: LD_EXP 88
32357: PUSH
32358: LD_VAR 0 2
32362: ARRAY
32363: PUSH
32364: LD_VAR 0 3
32368: ARRAY
32369: PPUSH
32370: CALL_OW 301
32374: PUSH
32375: LD_EXP 88
32379: PUSH
32380: LD_VAR 0 2
32384: ARRAY
32385: PUSH
32386: LD_VAR 0 3
32390: ARRAY
32391: PPUSH
32392: CALL_OW 257
32396: PUSH
32397: LD_INT 1
32399: NONEQUAL
32400: OR
32401: IFFALSE 32464
// begin tmp := mc_miners [ i ] diff mc_miners [ i ] [ j ] ;
32403: LD_ADDR_VAR 0 5
32407: PUSH
32408: LD_EXP 88
32412: PUSH
32413: LD_VAR 0 2
32417: ARRAY
32418: PUSH
32419: LD_EXP 88
32423: PUSH
32424: LD_VAR 0 2
32428: ARRAY
32429: PUSH
32430: LD_VAR 0 3
32434: ARRAY
32435: DIFF
32436: ST_TO_ADDR
// mc_miners := Replace ( mc_miners , i , tmp ) ;
32437: LD_ADDR_EXP 88
32441: PUSH
32442: LD_EXP 88
32446: PPUSH
32447: LD_VAR 0 2
32451: PPUSH
32452: LD_VAR 0 5
32456: PPUSH
32457: CALL_OW 1
32461: ST_TO_ADDR
// continue ;
32462: GO 32350
// end ; if WantPlant ( mc_miners [ i ] [ j ] ) and ( DangerAtRangeXY ( GetSide ( mc_miners [ i ] [ j ] ) , mc_mines [ i ] [ k ] [ 1 ] , mc_mines [ i ] [ k ] [ 2 ] , 15 ) [ 4 ] or DangerAtRange ( mc_miners [ i ] [ j ] , 10 ) [ 4 ] ) then
32464: LD_EXP 88
32468: PUSH
32469: LD_VAR 0 2
32473: ARRAY
32474: PUSH
32475: LD_VAR 0 3
32479: ARRAY
32480: PPUSH
32481: CALL 56889 0 1
32485: PUSH
32486: LD_EXP 88
32490: PUSH
32491: LD_VAR 0 2
32495: ARRAY
32496: PUSH
32497: LD_VAR 0 3
32501: ARRAY
32502: PPUSH
32503: CALL_OW 255
32507: PPUSH
32508: LD_EXP 87
32512: PUSH
32513: LD_VAR 0 2
32517: ARRAY
32518: PUSH
32519: LD_VAR 0 4
32523: ARRAY
32524: PUSH
32525: LD_INT 1
32527: ARRAY
32528: PPUSH
32529: LD_EXP 87
32533: PUSH
32534: LD_VAR 0 2
32538: ARRAY
32539: PUSH
32540: LD_VAR 0 4
32544: ARRAY
32545: PUSH
32546: LD_INT 2
32548: ARRAY
32549: PPUSH
32550: LD_INT 15
32552: PPUSH
32553: CALL 57849 0 4
32557: PUSH
32558: LD_INT 4
32560: ARRAY
32561: PUSH
32562: LD_EXP 88
32566: PUSH
32567: LD_VAR 0 2
32571: ARRAY
32572: PUSH
32573: LD_VAR 0 3
32577: ARRAY
32578: PPUSH
32579: LD_INT 10
32581: PPUSH
32582: CALL 59546 0 2
32586: PUSH
32587: LD_INT 4
32589: ARRAY
32590: OR
32591: AND
32592: IFFALSE 32615
// ComStop ( mc_miners [ i ] [ j ] ) ;
32594: LD_EXP 88
32598: PUSH
32599: LD_VAR 0 2
32603: ARRAY
32604: PUSH
32605: LD_VAR 0 3
32609: ARRAY
32610: PPUSH
32611: CALL_OW 141
// if GetClass ( mc_miners [ i ] [ j ] ) = 1 and not MineOfUnit ( mc_miners [ i ] [ j ] ) and DangerAtRangeXY ( GetSide ( mc_miners [ i ] [ j ] ) , mc_mines [ i ] [ k ] [ 1 ] , mc_mines [ i ] [ k ] [ 2 ] , 15 ) [ 4 ] = 0 and not HasTask ( mc_miners [ i ] [ j ] ) then
32615: LD_EXP 88
32619: PUSH
32620: LD_VAR 0 2
32624: ARRAY
32625: PUSH
32626: LD_VAR 0 3
32630: ARRAY
32631: PPUSH
32632: CALL_OW 257
32636: PUSH
32637: LD_INT 1
32639: EQUAL
32640: PUSH
32641: LD_EXP 88
32645: PUSH
32646: LD_VAR 0 2
32650: ARRAY
32651: PUSH
32652: LD_VAR 0 3
32656: ARRAY
32657: PPUSH
32658: CALL_OW 459
32662: NOT
32663: AND
32664: PUSH
32665: LD_EXP 88
32669: PUSH
32670: LD_VAR 0 2
32674: ARRAY
32675: PUSH
32676: LD_VAR 0 3
32680: ARRAY
32681: PPUSH
32682: CALL_OW 255
32686: PPUSH
32687: LD_EXP 87
32691: PUSH
32692: LD_VAR 0 2
32696: ARRAY
32697: PUSH
32698: LD_VAR 0 4
32702: ARRAY
32703: PUSH
32704: LD_INT 1
32706: ARRAY
32707: PPUSH
32708: LD_EXP 87
32712: PUSH
32713: LD_VAR 0 2
32717: ARRAY
32718: PUSH
32719: LD_VAR 0 4
32723: ARRAY
32724: PUSH
32725: LD_INT 2
32727: ARRAY
32728: PPUSH
32729: LD_INT 15
32731: PPUSH
32732: CALL 57849 0 4
32736: PUSH
32737: LD_INT 4
32739: ARRAY
32740: PUSH
32741: LD_INT 0
32743: EQUAL
32744: AND
32745: PUSH
32746: LD_EXP 88
32750: PUSH
32751: LD_VAR 0 2
32755: ARRAY
32756: PUSH
32757: LD_VAR 0 3
32761: ARRAY
32762: PPUSH
32763: CALL_OW 314
32767: NOT
32768: AND
32769: IFFALSE 32945
// begin if IsInUnit ( mc_miners [ i ] [ j ] ) then
32771: LD_EXP 88
32775: PUSH
32776: LD_VAR 0 2
32780: ARRAY
32781: PUSH
32782: LD_VAR 0 3
32786: ARRAY
32787: PPUSH
32788: CALL_OW 310
32792: IFFALSE 32815
// ComExitBuilding ( mc_miners [ i ] [ j ] ) ;
32794: LD_EXP 88
32798: PUSH
32799: LD_VAR 0 2
32803: ARRAY
32804: PUSH
32805: LD_VAR 0 3
32809: ARRAY
32810: PPUSH
32811: CALL_OW 122
// if not HasTask ( mc_miners [ i ] [ j ] ) then
32815: LD_EXP 88
32819: PUSH
32820: LD_VAR 0 2
32824: ARRAY
32825: PUSH
32826: LD_VAR 0 3
32830: ARRAY
32831: PPUSH
32832: CALL_OW 314
32836: NOT
32837: IFFALSE 32905
// AddComPlaceRemoteCharge ( mc_miners [ i ] [ j ] , mc_mines [ i ] [ k ] [ 1 ] , mc_mines [ i ] [ k ] [ 2 ] , 0 ) ;
32839: LD_EXP 88
32843: PUSH
32844: LD_VAR 0 2
32848: ARRAY
32849: PUSH
32850: LD_VAR 0 3
32854: ARRAY
32855: PPUSH
32856: LD_EXP 87
32860: PUSH
32861: LD_VAR 0 2
32865: ARRAY
32866: PUSH
32867: LD_VAR 0 4
32871: ARRAY
32872: PUSH
32873: LD_INT 1
32875: ARRAY
32876: PPUSH
32877: LD_EXP 87
32881: PUSH
32882: LD_VAR 0 2
32886: ARRAY
32887: PUSH
32888: LD_VAR 0 4
32892: ARRAY
32893: PUSH
32894: LD_INT 2
32896: ARRAY
32897: PPUSH
32898: LD_INT 0
32900: PPUSH
32901: CALL_OW 193
// k := k + 1 ;
32905: LD_ADDR_VAR 0 4
32909: PUSH
32910: LD_VAR 0 4
32914: PUSH
32915: LD_INT 1
32917: PLUS
32918: ST_TO_ADDR
// if k > mc_mines [ i ] then
32919: LD_VAR 0 4
32923: PUSH
32924: LD_EXP 87
32928: PUSH
32929: LD_VAR 0 2
32933: ARRAY
32934: GREATER
32935: IFFALSE 32945
// k := 1 ;
32937: LD_ADDR_VAR 0 4
32941: PUSH
32942: LD_INT 1
32944: ST_TO_ADDR
// end ; end ;
32945: GO 32350
32947: POP
32948: POP
// end ; tmp := UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_armoury ] , [ f_btype , b_barracks ] , [ f_btype , b_bunker ] ] ) ;
32949: LD_ADDR_VAR 0 5
32953: PUSH
32954: LD_EXP 74
32958: PUSH
32959: LD_VAR 0 2
32963: ARRAY
32964: PPUSH
32965: LD_INT 2
32967: PUSH
32968: LD_INT 30
32970: PUSH
32971: LD_INT 4
32973: PUSH
32974: EMPTY
32975: LIST
32976: LIST
32977: PUSH
32978: LD_INT 30
32980: PUSH
32981: LD_INT 5
32983: PUSH
32984: EMPTY
32985: LIST
32986: LIST
32987: PUSH
32988: LD_INT 30
32990: PUSH
32991: LD_INT 32
32993: PUSH
32994: EMPTY
32995: LIST
32996: LIST
32997: PUSH
32998: EMPTY
32999: LIST
33000: LIST
33001: LIST
33002: LIST
33003: PPUSH
33004: CALL_OW 72
33008: ST_TO_ADDR
// if not tmp then
33009: LD_VAR 0 5
33013: NOT
33014: IFFALSE 33018
// continue ;
33016: GO 32267
// list := [ ] ;
33018: LD_ADDR_VAR 0 6
33022: PUSH
33023: EMPTY
33024: ST_TO_ADDR
// for j in tmp do
33025: LD_ADDR_VAR 0 3
33029: PUSH
33030: LD_VAR 0 5
33034: PUSH
33035: FOR_IN
33036: IFFALSE 33105
// begin for k in UnitsInside ( j ) do
33038: LD_ADDR_VAR 0 4
33042: PUSH
33043: LD_VAR 0 3
33047: PPUSH
33048: CALL_OW 313
33052: PUSH
33053: FOR_IN
33054: IFFALSE 33101
// if GetClass ( k ) = 1 and not MineOfUnit ( k ) then
33056: LD_VAR 0 4
33060: PPUSH
33061: CALL_OW 257
33065: PUSH
33066: LD_INT 1
33068: EQUAL
33069: PUSH
33070: LD_VAR 0 4
33074: PPUSH
33075: CALL_OW 459
33079: NOT
33080: AND
33081: IFFALSE 33099
// list := list ^ k ;
33083: LD_ADDR_VAR 0 6
33087: PUSH
33088: LD_VAR 0 6
33092: PUSH
33093: LD_VAR 0 4
33097: ADD
33098: ST_TO_ADDR
33099: GO 33053
33101: POP
33102: POP
// end ;
33103: GO 33035
33105: POP
33106: POP
// list := list diff mc_miners [ i ] ;
33107: LD_ADDR_VAR 0 6
33111: PUSH
33112: LD_VAR 0 6
33116: PUSH
33117: LD_EXP 88
33121: PUSH
33122: LD_VAR 0 2
33126: ARRAY
33127: DIFF
33128: ST_TO_ADDR
// if not list then
33129: LD_VAR 0 6
33133: NOT
33134: IFFALSE 33138
// continue ;
33136: GO 32267
// k := mc_mines [ i ] - mc_miners [ i ] ;
33138: LD_ADDR_VAR 0 4
33142: PUSH
33143: LD_EXP 87
33147: PUSH
33148: LD_VAR 0 2
33152: ARRAY
33153: PUSH
33154: LD_EXP 88
33158: PUSH
33159: LD_VAR 0 2
33163: ARRAY
33164: MINUS
33165: ST_TO_ADDR
// if k > list then
33166: LD_VAR 0 4
33170: PUSH
33171: LD_VAR 0 6
33175: GREATER
33176: IFFALSE 33188
// k := list ;
33178: LD_ADDR_VAR 0 4
33182: PUSH
33183: LD_VAR 0 6
33187: ST_TO_ADDR
// for j = 1 to k do
33188: LD_ADDR_VAR 0 3
33192: PUSH
33193: DOUBLE
33194: LD_INT 1
33196: DEC
33197: ST_TO_ADDR
33198: LD_VAR 0 4
33202: PUSH
33203: FOR_TO
33204: IFFALSE 33258
// mc_miners := ReplaceIn ( mc_miners , [ i , mc_miners [ i ] + 1 ] , list [ j ] ) ;
33206: LD_ADDR_EXP 88
33210: PUSH
33211: LD_EXP 88
33215: PPUSH
33216: LD_VAR 0 2
33220: PUSH
33221: LD_EXP 88
33225: PUSH
33226: LD_VAR 0 2
33230: ARRAY
33231: PUSH
33232: LD_INT 1
33234: PLUS
33235: PUSH
33236: EMPTY
33237: LIST
33238: LIST
33239: PPUSH
33240: LD_VAR 0 6
33244: PUSH
33245: LD_VAR 0 3
33249: ARRAY
33250: PPUSH
33251: CALL 56953 0 3
33255: ST_TO_ADDR
33256: GO 33203
33258: POP
33259: POP
// end ;
33260: GO 32267
33262: POP
33263: POP
// end ;
33264: LD_VAR 0 1
33268: RET
// export function MC_CollectCrates ( ) ; var i , j , k , tmp , target , cargo , depot , fac , components ; begin
33269: LD_INT 0
33271: PPUSH
33272: PPUSH
33273: PPUSH
33274: PPUSH
33275: PPUSH
33276: PPUSH
33277: PPUSH
33278: PPUSH
33279: PPUSH
33280: PPUSH
// if not mc_bases then
33281: LD_EXP 74
33285: NOT
33286: IFFALSE 33290
// exit ;
33288: GO 35040
// for i = 1 to mc_bases do
33290: LD_ADDR_VAR 0 2
33294: PUSH
33295: DOUBLE
33296: LD_INT 1
33298: DEC
33299: ST_TO_ADDR
33300: LD_EXP 74
33304: PUSH
33305: FOR_TO
33306: IFFALSE 35038
// begin if not mc_bases [ i ] or mc_construct_list [ i ] then
33308: LD_EXP 74
33312: PUSH
33313: LD_VAR 0 2
33317: ARRAY
33318: NOT
33319: PUSH
33320: LD_EXP 81
33324: PUSH
33325: LD_VAR 0 2
33329: ARRAY
33330: OR
33331: IFFALSE 33335
// continue ;
33333: GO 33305
// if not mc_crates [ i ] and mc_crates_collector [ i ] then
33335: LD_EXP 90
33339: PUSH
33340: LD_VAR 0 2
33344: ARRAY
33345: NOT
33346: PUSH
33347: LD_EXP 91
33351: PUSH
33352: LD_VAR 0 2
33356: ARRAY
33357: AND
33358: IFFALSE 33396
// begin mc_crates_collector := Replace ( mc_crates_collector , i , [ ] ) ;
33360: LD_ADDR_EXP 91
33364: PUSH
33365: LD_EXP 91
33369: PPUSH
33370: LD_VAR 0 2
33374: PPUSH
33375: EMPTY
33376: PPUSH
33377: CALL_OW 1
33381: ST_TO_ADDR
// MC_Reset ( i , 107 ) ;
33382: LD_VAR 0 2
33386: PPUSH
33387: LD_INT 107
33389: PPUSH
33390: CALL 24150 0 2
// continue ;
33394: GO 33305
// end ; target := [ ] ;
33396: LD_ADDR_VAR 0 6
33400: PUSH
33401: EMPTY
33402: ST_TO_ADDR
// for j = mc_crates [ i ] downto 1 do
33403: LD_ADDR_VAR 0 3
33407: PUSH
33408: DOUBLE
33409: LD_EXP 90
33413: PUSH
33414: LD_VAR 0 2
33418: ARRAY
33419: INC
33420: ST_TO_ADDR
33421: LD_INT 1
33423: PUSH
33424: FOR_DOWNTO
33425: IFFALSE 33685
// begin if ValidHex ( mc_crates [ i ] [ j ] [ 2 ] , mc_crates [ i ] [ j ] [ 3 ] ) and GetResourceAmountXY ( mc_crates [ i ] [ j ] [ 2 ] , mc_crates [ i ] [ j ] [ 3 ] ) = 0 then
33427: LD_EXP 90
33431: PUSH
33432: LD_VAR 0 2
33436: ARRAY
33437: PUSH
33438: LD_VAR 0 3
33442: ARRAY
33443: PUSH
33444: LD_INT 2
33446: ARRAY
33447: PPUSH
33448: LD_EXP 90
33452: PUSH
33453: LD_VAR 0 2
33457: ARRAY
33458: PUSH
33459: LD_VAR 0 3
33463: ARRAY
33464: PUSH
33465: LD_INT 3
33467: ARRAY
33468: PPUSH
33469: CALL_OW 488
33473: PUSH
33474: LD_EXP 90
33478: PUSH
33479: LD_VAR 0 2
33483: ARRAY
33484: PUSH
33485: LD_VAR 0 3
33489: ARRAY
33490: PUSH
33491: LD_INT 2
33493: ARRAY
33494: PPUSH
33495: LD_EXP 90
33499: PUSH
33500: LD_VAR 0 2
33504: ARRAY
33505: PUSH
33506: LD_VAR 0 3
33510: ARRAY
33511: PUSH
33512: LD_INT 3
33514: ARRAY
33515: PPUSH
33516: CALL_OW 284
33520: PUSH
33521: LD_INT 0
33523: EQUAL
33524: AND
33525: IFFALSE 33580
// begin tmp := Delete ( mc_crates [ i ] , j ) ;
33527: LD_ADDR_VAR 0 5
33531: PUSH
33532: LD_EXP 90
33536: PUSH
33537: LD_VAR 0 2
33541: ARRAY
33542: PPUSH
33543: LD_VAR 0 3
33547: PPUSH
33548: CALL_OW 3
33552: ST_TO_ADDR
// mc_crates := Replace ( mc_crates , i , tmp ) ;
33553: LD_ADDR_EXP 90
33557: PUSH
33558: LD_EXP 90
33562: PPUSH
33563: LD_VAR 0 2
33567: PPUSH
33568: LD_VAR 0 5
33572: PPUSH
33573: CALL_OW 1
33577: ST_TO_ADDR
// continue ;
33578: GO 33424
// end ; if DangerAtRangeXY ( GetSide ( mc_bases [ i ] [ 1 ] ) , mc_crates [ i ] [ j ] [ 2 ] , mc_crates [ i ] [ j ] [ 3 ] , 30 ) [ 4 ] = 0 then
33580: LD_EXP 74
33584: PUSH
33585: LD_VAR 0 2
33589: ARRAY
33590: PUSH
33591: LD_INT 1
33593: ARRAY
33594: PPUSH
33595: CALL_OW 255
33599: PPUSH
33600: LD_EXP 90
33604: PUSH
33605: LD_VAR 0 2
33609: ARRAY
33610: PUSH
33611: LD_VAR 0 3
33615: ARRAY
33616: PUSH
33617: LD_INT 2
33619: ARRAY
33620: PPUSH
33621: LD_EXP 90
33625: PUSH
33626: LD_VAR 0 2
33630: ARRAY
33631: PUSH
33632: LD_VAR 0 3
33636: ARRAY
33637: PUSH
33638: LD_INT 3
33640: ARRAY
33641: PPUSH
33642: LD_INT 30
33644: PPUSH
33645: CALL 57849 0 4
33649: PUSH
33650: LD_INT 4
33652: ARRAY
33653: PUSH
33654: LD_INT 0
33656: EQUAL
33657: IFFALSE 33683
// begin target := mc_crates [ i ] [ j ] ;
33659: LD_ADDR_VAR 0 6
33663: PUSH
33664: LD_EXP 90
33668: PUSH
33669: LD_VAR 0 2
33673: ARRAY
33674: PUSH
33675: LD_VAR 0 3
33679: ARRAY
33680: ST_TO_ADDR
// break ;
33681: GO 33685
// end ; end ;
33683: GO 33424
33685: POP
33686: POP
// if not target then
33687: LD_VAR 0 6
33691: NOT
33692: IFFALSE 33696
// continue ;
33694: GO 33305
// cargo := UnitFilter ( mc_vehicles [ i ] , [ [ f_or , [ f_not , [ f_empty ] ] , [ f_linked ] , [ f_control , control_apeman ] , [ f_control , control_computer ] ] , [ f_or , [ f_weapon , ar_cargo_bay ] , [ f_weapon , ru_cargo_bay ] , [ f_weapon , us_cargo_bay ] ] ] ) ;
33696: LD_ADDR_VAR 0 7
33700: PUSH
33701: LD_EXP 93
33705: PUSH
33706: LD_VAR 0 2
33710: ARRAY
33711: PPUSH
33712: LD_INT 2
33714: PUSH
33715: LD_INT 3
33717: PUSH
33718: LD_INT 58
33720: PUSH
33721: EMPTY
33722: LIST
33723: PUSH
33724: EMPTY
33725: LIST
33726: LIST
33727: PUSH
33728: LD_INT 61
33730: PUSH
33731: EMPTY
33732: LIST
33733: PUSH
33734: LD_INT 33
33736: PUSH
33737: LD_INT 5
33739: PUSH
33740: EMPTY
33741: LIST
33742: LIST
33743: PUSH
33744: LD_INT 33
33746: PUSH
33747: LD_INT 3
33749: PUSH
33750: EMPTY
33751: LIST
33752: LIST
33753: PUSH
33754: EMPTY
33755: LIST
33756: LIST
33757: LIST
33758: LIST
33759: LIST
33760: PUSH
33761: LD_INT 2
33763: PUSH
33764: LD_INT 34
33766: PUSH
33767: LD_INT 32
33769: PUSH
33770: EMPTY
33771: LIST
33772: LIST
33773: PUSH
33774: LD_INT 34
33776: PUSH
33777: LD_INT 51
33779: PUSH
33780: EMPTY
33781: LIST
33782: LIST
33783: PUSH
33784: LD_INT 34
33786: PUSH
33787: LD_INT 12
33789: PUSH
33790: EMPTY
33791: LIST
33792: LIST
33793: PUSH
33794: EMPTY
33795: LIST
33796: LIST
33797: LIST
33798: LIST
33799: PUSH
33800: EMPTY
33801: LIST
33802: LIST
33803: PPUSH
33804: CALL_OW 72
33808: ST_TO_ADDR
// if not cargo then
33809: LD_VAR 0 7
33813: NOT
33814: IFFALSE 34457
// begin if mc_crates_collector [ i ] < 5 then
33816: LD_EXP 91
33820: PUSH
33821: LD_VAR 0 2
33825: ARRAY
33826: PUSH
33827: LD_INT 5
33829: LESS
33830: IFFALSE 34196
// begin if mc_ape [ i ] then
33832: LD_EXP 103
33836: PUSH
33837: LD_VAR 0 2
33841: ARRAY
33842: IFFALSE 33889
// tmp := UnitFilter ( mc_ape [ i ] , [ [ f_class , 16 ] , [ f_lives , 750 ] ] ) ;
33844: LD_ADDR_VAR 0 5
33848: PUSH
33849: LD_EXP 103
33853: PUSH
33854: LD_VAR 0 2
33858: ARRAY
33859: PPUSH
33860: LD_INT 25
33862: PUSH
33863: LD_INT 16
33865: PUSH
33866: EMPTY
33867: LIST
33868: LIST
33869: PUSH
33870: LD_INT 24
33872: PUSH
33873: LD_INT 750
33875: PUSH
33876: EMPTY
33877: LIST
33878: LIST
33879: PUSH
33880: EMPTY
33881: LIST
33882: LIST
33883: PPUSH
33884: CALL_OW 72
33888: ST_TO_ADDR
// if not tmp then
33889: LD_VAR 0 5
33893: NOT
33894: IFFALSE 33941
// tmp := UnitFilter ( mc_bases [ i ] , [ [ f_class , 2 ] , [ f_lives , 750 ] ] ) ;
33896: LD_ADDR_VAR 0 5
33900: PUSH
33901: LD_EXP 74
33905: PUSH
33906: LD_VAR 0 2
33910: ARRAY
33911: PPUSH
33912: LD_INT 25
33914: PUSH
33915: LD_INT 2
33917: PUSH
33918: EMPTY
33919: LIST
33920: LIST
33921: PUSH
33922: LD_INT 24
33924: PUSH
33925: LD_INT 750
33927: PUSH
33928: EMPTY
33929: LIST
33930: LIST
33931: PUSH
33932: EMPTY
33933: LIST
33934: LIST
33935: PPUSH
33936: CALL_OW 72
33940: ST_TO_ADDR
// if mc_ape [ i ] and UnitFilter ( mc_bases [ i ] , [ [ f_class , 2 ] , [ f_lives , 750 ] ] ) and tmp < 5 then
33941: LD_EXP 103
33945: PUSH
33946: LD_VAR 0 2
33950: ARRAY
33951: PUSH
33952: LD_EXP 74
33956: PUSH
33957: LD_VAR 0 2
33961: ARRAY
33962: PPUSH
33963: LD_INT 25
33965: PUSH
33966: LD_INT 2
33968: PUSH
33969: EMPTY
33970: LIST
33971: LIST
33972: PUSH
33973: LD_INT 24
33975: PUSH
33976: LD_INT 750
33978: PUSH
33979: EMPTY
33980: LIST
33981: LIST
33982: PUSH
33983: EMPTY
33984: LIST
33985: LIST
33986: PPUSH
33987: CALL_OW 72
33991: AND
33992: PUSH
33993: LD_VAR 0 5
33997: PUSH
33998: LD_INT 5
34000: LESS
34001: AND
34002: IFFALSE 34084
// begin for j in UnitFilter ( mc_bases [ i ] , [ [ f_class , 2 ] , [ f_lives , 750 ] ] ) do
34004: LD_ADDR_VAR 0 3
34008: PUSH
34009: LD_EXP 74
34013: PUSH
34014: LD_VAR 0 2
34018: ARRAY
34019: PPUSH
34020: LD_INT 25
34022: PUSH
34023: LD_INT 2
34025: PUSH
34026: EMPTY
34027: LIST
34028: LIST
34029: PUSH
34030: LD_INT 24
34032: PUSH
34033: LD_INT 750
34035: PUSH
34036: EMPTY
34037: LIST
34038: LIST
34039: PUSH
34040: EMPTY
34041: LIST
34042: LIST
34043: PPUSH
34044: CALL_OW 72
34048: PUSH
34049: FOR_IN
34050: IFFALSE 34082
// begin tmp := tmp union j ;
34052: LD_ADDR_VAR 0 5
34056: PUSH
34057: LD_VAR 0 5
34061: PUSH
34062: LD_VAR 0 3
34066: UNION
34067: ST_TO_ADDR
// if tmp >= 5 then
34068: LD_VAR 0 5
34072: PUSH
34073: LD_INT 5
34075: GREATEREQUAL
34076: IFFALSE 34080
// break ;
34078: GO 34082
// end ;
34080: GO 34049
34082: POP
34083: POP
// end ; if not tmp then
34084: LD_VAR 0 5
34088: NOT
34089: IFFALSE 34093
// continue ;
34091: GO 33305
// for j in tmp do
34093: LD_ADDR_VAR 0 3
34097: PUSH
34098: LD_VAR 0 5
34102: PUSH
34103: FOR_IN
34104: IFFALSE 34194
// if not GetTag ( j ) then
34106: LD_VAR 0 3
34110: PPUSH
34111: CALL_OW 110
34115: NOT
34116: IFFALSE 34192
// begin mc_crates_collector := ReplaceIn ( mc_crates_collector , [ i , mc_crates_collector [ i ] + 1 ] , j ) ;
34118: LD_ADDR_EXP 91
34122: PUSH
34123: LD_EXP 91
34127: PPUSH
34128: LD_VAR 0 2
34132: PUSH
34133: LD_EXP 91
34137: PUSH
34138: LD_VAR 0 2
34142: ARRAY
34143: PUSH
34144: LD_INT 1
34146: PLUS
34147: PUSH
34148: EMPTY
34149: LIST
34150: LIST
34151: PPUSH
34152: LD_VAR 0 3
34156: PPUSH
34157: CALL 56953 0 3
34161: ST_TO_ADDR
// SetTag ( j , 107 ) ;
34162: LD_VAR 0 3
34166: PPUSH
34167: LD_INT 107
34169: PPUSH
34170: CALL_OW 109
// if mc_crates_collector [ i ] >= 5 then
34174: LD_EXP 91
34178: PUSH
34179: LD_VAR 0 2
34183: ARRAY
34184: PUSH
34185: LD_INT 5
34187: GREATEREQUAL
34188: IFFALSE 34192
// break ;
34190: GO 34194
// end ;
34192: GO 34103
34194: POP
34195: POP
// end ; if mc_crates_collector [ i ] and target then
34196: LD_EXP 91
34200: PUSH
34201: LD_VAR 0 2
34205: ARRAY
34206: PUSH
34207: LD_VAR 0 6
34211: AND
34212: IFFALSE 34455
// begin if mc_crates_collector [ i ] < target [ 1 ] then
34214: LD_EXP 91
34218: PUSH
34219: LD_VAR 0 2
34223: ARRAY
34224: PUSH
34225: LD_VAR 0 6
34229: PUSH
34230: LD_INT 1
34232: ARRAY
34233: LESS
34234: IFFALSE 34254
// tmp := mc_crates_collector [ i ] else
34236: LD_ADDR_VAR 0 5
34240: PUSH
34241: LD_EXP 91
34245: PUSH
34246: LD_VAR 0 2
34250: ARRAY
34251: ST_TO_ADDR
34252: GO 34268
// tmp := target [ 1 ] ;
34254: LD_ADDR_VAR 0 5
34258: PUSH
34259: LD_VAR 0 6
34263: PUSH
34264: LD_INT 1
34266: ARRAY
34267: ST_TO_ADDR
// k := 0 ;
34268: LD_ADDR_VAR 0 4
34272: PUSH
34273: LD_INT 0
34275: ST_TO_ADDR
// for j in mc_crates_collector [ i ] do
34276: LD_ADDR_VAR 0 3
34280: PUSH
34281: LD_EXP 91
34285: PUSH
34286: LD_VAR 0 2
34290: ARRAY
34291: PUSH
34292: FOR_IN
34293: IFFALSE 34453
// begin k := k + 1 ;
34295: LD_ADDR_VAR 0 4
34299: PUSH
34300: LD_VAR 0 4
34304: PUSH
34305: LD_INT 1
34307: PLUS
34308: ST_TO_ADDR
// if k > tmp then
34309: LD_VAR 0 4
34313: PUSH
34314: LD_VAR 0 5
34318: GREATER
34319: IFFALSE 34323
// break ;
34321: GO 34453
// if not GetClass ( j ) in [ 2 , 16 ] then
34323: LD_VAR 0 3
34327: PPUSH
34328: CALL_OW 257
34332: PUSH
34333: LD_INT 2
34335: PUSH
34336: LD_INT 16
34338: PUSH
34339: EMPTY
34340: LIST
34341: LIST
34342: IN
34343: NOT
34344: IFFALSE 34397
// begin mc_crates_collector := Replace ( mc_crates_collector , i , mc_crates_collector [ i ] diff j ) ;
34346: LD_ADDR_EXP 91
34350: PUSH
34351: LD_EXP 91
34355: PPUSH
34356: LD_VAR 0 2
34360: PPUSH
34361: LD_EXP 91
34365: PUSH
34366: LD_VAR 0 2
34370: ARRAY
34371: PUSH
34372: LD_VAR 0 3
34376: DIFF
34377: PPUSH
34378: CALL_OW 1
34382: ST_TO_ADDR
// SetTag ( j , 0 ) ;
34383: LD_VAR 0 3
34387: PPUSH
34388: LD_INT 0
34390: PPUSH
34391: CALL_OW 109
// continue ;
34395: GO 34292
// end ; if IsInUnit ( j ) then
34397: LD_VAR 0 3
34401: PPUSH
34402: CALL_OW 310
34406: IFFALSE 34417
// ComExitBuilding ( j ) ;
34408: LD_VAR 0 3
34412: PPUSH
34413: CALL_OW 122
// wait ( 3 ) ;
34417: LD_INT 3
34419: PPUSH
34420: CALL_OW 67
// ComCollect ( j , target [ 2 ] , target [ 3 ] ) ;
34424: LD_VAR 0 3
34428: PPUSH
34429: LD_VAR 0 6
34433: PUSH
34434: LD_INT 2
34436: ARRAY
34437: PPUSH
34438: LD_VAR 0 6
34442: PUSH
34443: LD_INT 3
34445: ARRAY
34446: PPUSH
34447: CALL_OW 117
// end ;
34451: GO 34292
34453: POP
34454: POP
// end ; end else
34455: GO 35036
// begin for j in cargo do
34457: LD_ADDR_VAR 0 3
34461: PUSH
34462: LD_VAR 0 7
34466: PUSH
34467: FOR_IN
34468: IFFALSE 35034
// begin if GetTag ( j ) <> 0 then
34470: LD_VAR 0 3
34474: PPUSH
34475: CALL_OW 110
34479: PUSH
34480: LD_INT 0
34482: NONEQUAL
34483: IFFALSE 34487
// continue ;
34485: GO 34467
// if GetLives ( j ) < 1000 and not IsInArea ( j , mc_parking [ i ] ) then
34487: LD_VAR 0 3
34491: PPUSH
34492: CALL_OW 256
34496: PUSH
34497: LD_INT 1000
34499: LESS
34500: PUSH
34501: LD_VAR 0 3
34505: PPUSH
34506: LD_EXP 98
34510: PUSH
34511: LD_VAR 0 2
34515: ARRAY
34516: PPUSH
34517: CALL_OW 308
34521: NOT
34522: AND
34523: IFFALSE 34545
// ComMoveToArea ( j , mc_parking [ i ] ) ;
34525: LD_VAR 0 3
34529: PPUSH
34530: LD_EXP 98
34534: PUSH
34535: LD_VAR 0 2
34539: ARRAY
34540: PPUSH
34541: CALL_OW 113
// if GetLives ( j ) < 1000 and IsInArea ( j , mc_parking [ i ] ) then
34545: LD_VAR 0 3
34549: PPUSH
34550: CALL_OW 256
34554: PUSH
34555: LD_INT 1000
34557: LESS
34558: PUSH
34559: LD_VAR 0 3
34563: PPUSH
34564: LD_EXP 98
34568: PUSH
34569: LD_VAR 0 2
34573: ARRAY
34574: PPUSH
34575: CALL_OW 308
34579: AND
34580: IFFALSE 34584
// continue ;
34582: GO 34467
// if GetEngine ( j ) = engine_solar and GetFuel ( j ) < 15 then
34584: LD_VAR 0 3
34588: PPUSH
34589: CALL_OW 262
34593: PUSH
34594: LD_INT 2
34596: EQUAL
34597: PUSH
34598: LD_VAR 0 3
34602: PPUSH
34603: CALL_OW 261
34607: PUSH
34608: LD_INT 15
34610: LESS
34611: AND
34612: IFFALSE 34616
// continue ;
34614: GO 34467
// if GetEngine ( j ) = engine_combustion and GetFuel ( j ) < 10 then
34616: LD_VAR 0 3
34620: PPUSH
34621: CALL_OW 262
34625: PUSH
34626: LD_INT 1
34628: EQUAL
34629: PUSH
34630: LD_VAR 0 3
34634: PPUSH
34635: CALL_OW 261
34639: PUSH
34640: LD_INT 10
34642: LESS
34643: AND
34644: IFFALSE 34973
// begin depot := UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) ;
34646: LD_ADDR_VAR 0 8
34650: PUSH
34651: LD_EXP 74
34655: PUSH
34656: LD_VAR 0 2
34660: ARRAY
34661: PPUSH
34662: LD_INT 2
34664: PUSH
34665: LD_INT 30
34667: PUSH
34668: LD_INT 0
34670: PUSH
34671: EMPTY
34672: LIST
34673: LIST
34674: PUSH
34675: LD_INT 30
34677: PUSH
34678: LD_INT 1
34680: PUSH
34681: EMPTY
34682: LIST
34683: LIST
34684: PUSH
34685: EMPTY
34686: LIST
34687: LIST
34688: LIST
34689: PPUSH
34690: CALL_OW 72
34694: ST_TO_ADDR
// if not depot then
34695: LD_VAR 0 8
34699: NOT
34700: IFFALSE 34704
// continue ;
34702: GO 34467
// if GetDistUnits ( j , NearestUnitToUnit ( depot , j ) ) < 6 then
34704: LD_VAR 0 3
34708: PPUSH
34709: LD_VAR 0 8
34713: PPUSH
34714: LD_VAR 0 3
34718: PPUSH
34719: CALL_OW 74
34723: PPUSH
34724: CALL_OW 296
34728: PUSH
34729: LD_INT 6
34731: LESS
34732: IFFALSE 34748
// SetFuel ( j , 100 ) else
34734: LD_VAR 0 3
34738: PPUSH
34739: LD_INT 100
34741: PPUSH
34742: CALL_OW 240
34746: GO 34973
// if GetFuel ( j ) = 0 then
34748: LD_VAR 0 3
34752: PPUSH
34753: CALL_OW 261
34757: PUSH
34758: LD_INT 0
34760: EQUAL
34761: IFFALSE 34973
// begin mc_vehicles := Replace ( mc_vehicles , i , mc_vehicles [ i ] diff j ) ;
34763: LD_ADDR_EXP 93
34767: PUSH
34768: LD_EXP 93
34772: PPUSH
34773: LD_VAR 0 2
34777: PPUSH
34778: LD_EXP 93
34782: PUSH
34783: LD_VAR 0 2
34787: ARRAY
34788: PUSH
34789: LD_VAR 0 3
34793: DIFF
34794: PPUSH
34795: CALL_OW 1
34799: ST_TO_ADDR
// if GetControl ( j ) = control_manual then
34800: LD_VAR 0 3
34804: PPUSH
34805: CALL_OW 263
34809: PUSH
34810: LD_INT 1
34812: EQUAL
34813: IFFALSE 34829
// ComExitVehicle ( IsInUnit ( j ) ) ;
34815: LD_VAR 0 3
34819: PPUSH
34820: CALL_OW 310
34824: PPUSH
34825: CALL_OW 121
// if GetControl ( j ) = control_remote then
34829: LD_VAR 0 3
34833: PPUSH
34834: CALL_OW 263
34838: PUSH
34839: LD_INT 2
34841: EQUAL
34842: IFFALSE 34853
// ComUnlink ( j ) ;
34844: LD_VAR 0 3
34848: PPUSH
34849: CALL_OW 136
// fac := MC_GetBuildings ( i , b_factory ) ;
34853: LD_ADDR_VAR 0 9
34857: PUSH
34858: LD_VAR 0 2
34862: PPUSH
34863: LD_INT 3
34865: PPUSH
34866: CALL 44110 0 2
34870: ST_TO_ADDR
// if fac then
34871: LD_VAR 0 9
34875: IFFALSE 34971
// begin for k in fac do
34877: LD_ADDR_VAR 0 4
34881: PUSH
34882: LD_VAR 0 9
34886: PUSH
34887: FOR_IN
34888: IFFALSE 34969
// begin components := Produce ( fac , GetChassis ( j ) , GetEngine ( j ) , GetControl ( j ) , GetWeapon ( j ) ) ;
34890: LD_ADDR_VAR 0 10
34894: PUSH
34895: LD_VAR 0 9
34899: PPUSH
34900: LD_VAR 0 3
34904: PPUSH
34905: CALL_OW 265
34909: PPUSH
34910: LD_VAR 0 3
34914: PPUSH
34915: CALL_OW 262
34919: PPUSH
34920: LD_VAR 0 3
34924: PPUSH
34925: CALL_OW 263
34929: PPUSH
34930: LD_VAR 0 3
34934: PPUSH
34935: CALL_OW 264
34939: PPUSH
34940: CALL 54485 0 5
34944: ST_TO_ADDR
// if components then
34945: LD_VAR 0 10
34949: IFFALSE 34967
// begin MC_InsertProduceList ( i , components ) ;
34951: LD_VAR 0 2
34955: PPUSH
34956: LD_VAR 0 10
34960: PPUSH
34961: CALL 43655 0 2
// break ;
34965: GO 34969
// end ; end ;
34967: GO 34887
34969: POP
34970: POP
// end ; continue ;
34971: GO 34467
// end ; end ; if GetCargo ( j , mat_cans ) < 100 and not HasTask ( j ) then
34973: LD_VAR 0 3
34977: PPUSH
34978: LD_INT 1
34980: PPUSH
34981: CALL_OW 289
34985: PUSH
34986: LD_INT 100
34988: LESS
34989: PUSH
34990: LD_VAR 0 3
34994: PPUSH
34995: CALL_OW 314
34999: NOT
35000: AND
35001: IFFALSE 35030
// ComCollect ( j , target [ 2 ] , target [ 3 ] ) ;
35003: LD_VAR 0 3
35007: PPUSH
35008: LD_VAR 0 6
35012: PUSH
35013: LD_INT 2
35015: ARRAY
35016: PPUSH
35017: LD_VAR 0 6
35021: PUSH
35022: LD_INT 3
35024: ARRAY
35025: PPUSH
35026: CALL_OW 117
// break ;
35030: GO 35034
// end ;
35032: GO 34467
35034: POP
35035: POP
// end ; end ;
35036: GO 33305
35038: POP
35039: POP
// end ;
35040: LD_VAR 0 1
35044: RET
// export function MC_LinkRemoteControl ( ) ; var i , j , tmp ; begin
35045: LD_INT 0
35047: PPUSH
35048: PPUSH
35049: PPUSH
35050: PPUSH
// if not mc_bases then
35051: LD_EXP 74
35055: NOT
35056: IFFALSE 35060
// exit ;
35058: GO 35221
// for i = 1 to mc_bases do
35060: LD_ADDR_VAR 0 2
35064: PUSH
35065: DOUBLE
35066: LD_INT 1
35068: DEC
35069: ST_TO_ADDR
35070: LD_EXP 74
35074: PUSH
35075: FOR_TO
35076: IFFALSE 35219
// begin tmp := UnitFilter ( mc_vehicles [ i ] union mc_defender [ i ] , [ f_control , control_remote ] ) ;
35078: LD_ADDR_VAR 0 4
35082: PUSH
35083: LD_EXP 93
35087: PUSH
35088: LD_VAR 0 2
35092: ARRAY
35093: PUSH
35094: LD_EXP 96
35098: PUSH
35099: LD_VAR 0 2
35103: ARRAY
35104: UNION
35105: PPUSH
35106: LD_INT 33
35108: PUSH
35109: LD_INT 2
35111: PUSH
35112: EMPTY
35113: LIST
35114: LIST
35115: PPUSH
35116: CALL_OW 72
35120: ST_TO_ADDR
// if tmp then
35121: LD_VAR 0 4
35125: IFFALSE 35217
// for j in tmp do
35127: LD_ADDR_VAR 0 3
35131: PUSH
35132: LD_VAR 0 4
35136: PUSH
35137: FOR_IN
35138: IFFALSE 35215
// if not IsControledBy ( j ) and GetLives ( j ) >= 250 then
35140: LD_VAR 0 3
35144: PPUSH
35145: CALL_OW 312
35149: NOT
35150: PUSH
35151: LD_VAR 0 3
35155: PPUSH
35156: CALL_OW 256
35160: PUSH
35161: LD_INT 250
35163: GREATEREQUAL
35164: AND
35165: IFFALSE 35178
// Connect ( j ) else
35167: LD_VAR 0 3
35171: PPUSH
35172: CALL 59886 0 1
35176: GO 35213
// if GetLives ( j ) < 250 and IsControledBy ( j ) then
35178: LD_VAR 0 3
35182: PPUSH
35183: CALL_OW 256
35187: PUSH
35188: LD_INT 250
35190: LESS
35191: PUSH
35192: LD_VAR 0 3
35196: PPUSH
35197: CALL_OW 312
35201: AND
35202: IFFALSE 35213
// ComUnlink ( j ) ;
35204: LD_VAR 0 3
35208: PPUSH
35209: CALL_OW 136
35213: GO 35137
35215: POP
35216: POP
// end ;
35217: GO 35075
35219: POP
35220: POP
// end ;
35221: LD_VAR 0 1
35225: RET
// export function MC_ProduceVehicle ( ) ; var i , j , tmp , fac ; begin
35226: LD_INT 0
35228: PPUSH
35229: PPUSH
35230: PPUSH
35231: PPUSH
35232: PPUSH
// if not mc_bases then
35233: LD_EXP 74
35237: NOT
35238: IFFALSE 35242
// exit ;
35240: GO 35687
// for i = 1 to mc_bases do
35242: LD_ADDR_VAR 0 2
35246: PUSH
35247: DOUBLE
35248: LD_INT 1
35250: DEC
35251: ST_TO_ADDR
35252: LD_EXP 74
35256: PUSH
35257: FOR_TO
35258: IFFALSE 35685
// begin if not mc_produce [ i ] then
35260: LD_EXP 95
35264: PUSH
35265: LD_VAR 0 2
35269: ARRAY
35270: NOT
35271: IFFALSE 35275
// continue ;
35273: GO 35257
// fac := UnitFilter ( mc_bases [ i ] , [ f_btype , b_factory ] ) ;
35275: LD_ADDR_VAR 0 5
35279: PUSH
35280: LD_EXP 74
35284: PUSH
35285: LD_VAR 0 2
35289: ARRAY
35290: PPUSH
35291: LD_INT 30
35293: PUSH
35294: LD_INT 3
35296: PUSH
35297: EMPTY
35298: LIST
35299: LIST
35300: PPUSH
35301: CALL_OW 72
35305: ST_TO_ADDR
// if not fac then
35306: LD_VAR 0 5
35310: NOT
35311: IFFALSE 35315
// continue ;
35313: GO 35257
// for j in fac do
35315: LD_ADDR_VAR 0 3
35319: PUSH
35320: LD_VAR 0 5
35324: PUSH
35325: FOR_IN
35326: IFFALSE 35681
// begin if BuildingStatus ( j ) <> bs_idle or DangerAtRange ( j , 15 ) [ 4 ] then
35328: LD_VAR 0 3
35332: PPUSH
35333: CALL_OW 461
35337: PUSH
35338: LD_INT 2
35340: NONEQUAL
35341: PUSH
35342: LD_VAR 0 3
35346: PPUSH
35347: LD_INT 15
35349: PPUSH
35350: CALL 59546 0 2
35354: PUSH
35355: LD_INT 4
35357: ARRAY
35358: OR
35359: IFFALSE 35363
// continue ;
35361: GO 35325
// if CanBeConstructed ( j , mc_produce [ i ] [ 1 ] [ 1 ] , mc_produce [ i ] [ 1 ] [ 2 ] , mc_produce [ i ] [ 1 ] [ 3 ] , mc_produce [ i ] [ 1 ] [ 4 ] ) and VehicleCost ( j , [ mc_produce [ i ] [ 1 ] [ 1 ] , mc_produce [ i ] [ 1 ] [ 2 ] , mc_produce [ i ] [ 1 ] [ 3 ] , mc_produce [ i ] [ 1 ] [ 4 ] ] ) then
35363: LD_VAR 0 3
35367: PPUSH
35368: LD_EXP 95
35372: PUSH
35373: LD_VAR 0 2
35377: ARRAY
35378: PUSH
35379: LD_INT 1
35381: ARRAY
35382: PUSH
35383: LD_INT 1
35385: ARRAY
35386: PPUSH
35387: LD_EXP 95
35391: PUSH
35392: LD_VAR 0 2
35396: ARRAY
35397: PUSH
35398: LD_INT 1
35400: ARRAY
35401: PUSH
35402: LD_INT 2
35404: ARRAY
35405: PPUSH
35406: LD_EXP 95
35410: PUSH
35411: LD_VAR 0 2
35415: ARRAY
35416: PUSH
35417: LD_INT 1
35419: ARRAY
35420: PUSH
35421: LD_INT 3
35423: ARRAY
35424: PPUSH
35425: LD_EXP 95
35429: PUSH
35430: LD_VAR 0 2
35434: ARRAY
35435: PUSH
35436: LD_INT 1
35438: ARRAY
35439: PUSH
35440: LD_INT 4
35442: ARRAY
35443: PPUSH
35444: CALL_OW 448
35448: PUSH
35449: LD_VAR 0 3
35453: PPUSH
35454: LD_EXP 95
35458: PUSH
35459: LD_VAR 0 2
35463: ARRAY
35464: PUSH
35465: LD_INT 1
35467: ARRAY
35468: PUSH
35469: LD_INT 1
35471: ARRAY
35472: PUSH
35473: LD_EXP 95
35477: PUSH
35478: LD_VAR 0 2
35482: ARRAY
35483: PUSH
35484: LD_INT 1
35486: ARRAY
35487: PUSH
35488: LD_INT 2
35490: ARRAY
35491: PUSH
35492: LD_EXP 95
35496: PUSH
35497: LD_VAR 0 2
35501: ARRAY
35502: PUSH
35503: LD_INT 1
35505: ARRAY
35506: PUSH
35507: LD_INT 3
35509: ARRAY
35510: PUSH
35511: LD_EXP 95
35515: PUSH
35516: LD_VAR 0 2
35520: ARRAY
35521: PUSH
35522: LD_INT 1
35524: ARRAY
35525: PUSH
35526: LD_INT 4
35528: ARRAY
35529: PUSH
35530: EMPTY
35531: LIST
35532: LIST
35533: LIST
35534: LIST
35535: PPUSH
35536: CALL 63217 0 2
35540: AND
35541: IFFALSE 35679
// begin AddComConstruct ( j , mc_produce [ i ] [ 1 ] [ 1 ] , mc_produce [ i ] [ 1 ] [ 2 ] , mc_produce [ i ] [ 1 ] [ 3 ] , mc_produce [ i ] [ 1 ] [ 4 ] ) ;
35543: LD_VAR 0 3
35547: PPUSH
35548: LD_EXP 95
35552: PUSH
35553: LD_VAR 0 2
35557: ARRAY
35558: PUSH
35559: LD_INT 1
35561: ARRAY
35562: PUSH
35563: LD_INT 1
35565: ARRAY
35566: PPUSH
35567: LD_EXP 95
35571: PUSH
35572: LD_VAR 0 2
35576: ARRAY
35577: PUSH
35578: LD_INT 1
35580: ARRAY
35581: PUSH
35582: LD_INT 2
35584: ARRAY
35585: PPUSH
35586: LD_EXP 95
35590: PUSH
35591: LD_VAR 0 2
35595: ARRAY
35596: PUSH
35597: LD_INT 1
35599: ARRAY
35600: PUSH
35601: LD_INT 3
35603: ARRAY
35604: PPUSH
35605: LD_EXP 95
35609: PUSH
35610: LD_VAR 0 2
35614: ARRAY
35615: PUSH
35616: LD_INT 1
35618: ARRAY
35619: PUSH
35620: LD_INT 4
35622: ARRAY
35623: PPUSH
35624: CALL_OW 185
// tmp := Delete ( mc_produce [ i ] , 1 ) ;
35628: LD_ADDR_VAR 0 4
35632: PUSH
35633: LD_EXP 95
35637: PUSH
35638: LD_VAR 0 2
35642: ARRAY
35643: PPUSH
35644: LD_INT 1
35646: PPUSH
35647: CALL_OW 3
35651: ST_TO_ADDR
// mc_produce := Replace ( mc_produce , i , tmp ) ;
35652: LD_ADDR_EXP 95
35656: PUSH
35657: LD_EXP 95
35661: PPUSH
35662: LD_VAR 0 2
35666: PPUSH
35667: LD_VAR 0 4
35671: PPUSH
35672: CALL_OW 1
35676: ST_TO_ADDR
// break ;
35677: GO 35681
// end ; end ;
35679: GO 35325
35681: POP
35682: POP
// end ;
35683: GO 35257
35685: POP
35686: POP
// end ;
35687: LD_VAR 0 1
35691: RET
// export function MC_SendAttack ( ) ; var i , tmp ; begin
35692: LD_INT 0
35694: PPUSH
35695: PPUSH
35696: PPUSH
// if not mc_bases then
35697: LD_EXP 74
35701: NOT
35702: IFFALSE 35706
// exit ;
35704: GO 35795
// for i = 1 to mc_bases do
35706: LD_ADDR_VAR 0 2
35710: PUSH
35711: DOUBLE
35712: LD_INT 1
35714: DEC
35715: ST_TO_ADDR
35716: LD_EXP 74
35720: PUSH
35721: FOR_TO
35722: IFFALSE 35793
// begin if mc_attack [ i ] then
35724: LD_EXP 94
35728: PUSH
35729: LD_VAR 0 2
35733: ARRAY
35734: IFFALSE 35791
// begin tmp := mc_attack [ i ] [ 1 ] ;
35736: LD_ADDR_VAR 0 3
35740: PUSH
35741: LD_EXP 94
35745: PUSH
35746: LD_VAR 0 2
35750: ARRAY
35751: PUSH
35752: LD_INT 1
35754: ARRAY
35755: ST_TO_ADDR
// mc_attack := Replace ( mc_attack , i , [ ] ) ;
35756: LD_ADDR_EXP 94
35760: PUSH
35761: LD_EXP 94
35765: PPUSH
35766: LD_VAR 0 2
35770: PPUSH
35771: EMPTY
35772: PPUSH
35773: CALL_OW 1
35777: ST_TO_ADDR
// Attack ( tmp ) ;
35778: LD_VAR 0 3
35782: PPUSH
35783: CALL 85430 0 1
// exit ;
35787: POP
35788: POP
35789: GO 35795
// end ; end ;
35791: GO 35721
35793: POP
35794: POP
// end ;
35795: LD_VAR 0 1
35799: RET
// export function MC_Defend ( ) ; var i , j , tmp , t , x , class ; begin
35800: LD_INT 0
35802: PPUSH
35803: PPUSH
35804: PPUSH
35805: PPUSH
35806: PPUSH
35807: PPUSH
35808: PPUSH
// if not mc_bases then
35809: LD_EXP 74
35813: NOT
35814: IFFALSE 35818
// exit ;
35816: GO 36400
// for i = 1 to mc_bases do
35818: LD_ADDR_VAR 0 2
35822: PUSH
35823: DOUBLE
35824: LD_INT 1
35826: DEC
35827: ST_TO_ADDR
35828: LD_EXP 74
35832: PUSH
35833: FOR_TO
35834: IFFALSE 36398
// begin if not mc_bases [ i ] then
35836: LD_EXP 74
35840: PUSH
35841: LD_VAR 0 2
35845: ARRAY
35846: NOT
35847: IFFALSE 35851
// continue ;
35849: GO 35833
// class := AllowSpecClass ( mc_bases [ i ] [ 1 ] ) ;
35851: LD_ADDR_VAR 0 7
35855: PUSH
35856: LD_EXP 74
35860: PUSH
35861: LD_VAR 0 2
35865: ARRAY
35866: PUSH
35867: LD_INT 1
35869: ARRAY
35870: PPUSH
35871: CALL 53789 0 1
35875: ST_TO_ADDR
// mc_scan := Replace ( mc_scan , i , ScanBase ( GetSide ( mc_bases [ i ] [ 1 ] ) , mc_scan_area [ i ] ) ) ;
35876: LD_ADDR_EXP 97
35880: PUSH
35881: LD_EXP 97
35885: PPUSH
35886: LD_VAR 0 2
35890: PPUSH
35891: LD_EXP 74
35895: PUSH
35896: LD_VAR 0 2
35900: ARRAY
35901: PUSH
35902: LD_INT 1
35904: ARRAY
35905: PPUSH
35906: CALL_OW 255
35910: PPUSH
35911: LD_EXP 99
35915: PUSH
35916: LD_VAR 0 2
35920: ARRAY
35921: PPUSH
35922: CALL 51492 0 2
35926: PPUSH
35927: CALL_OW 1
35931: ST_TO_ADDR
// if not mc_scan [ i ] then
35932: LD_EXP 97
35936: PUSH
35937: LD_VAR 0 2
35941: ARRAY
35942: NOT
35943: IFFALSE 36098
// begin tmp := UnitFilter ( mc_bases [ i ] , [ f_or , [ f_class , 5 ] , [ f_class , 8 ] , [ f_class , 9 ] ] ) ;
35945: LD_ADDR_VAR 0 4
35949: PUSH
35950: LD_EXP 74
35954: PUSH
35955: LD_VAR 0 2
35959: ARRAY
35960: PPUSH
35961: LD_INT 2
35963: PUSH
35964: LD_INT 25
35966: PUSH
35967: LD_INT 5
35969: PUSH
35970: EMPTY
35971: LIST
35972: LIST
35973: PUSH
35974: LD_INT 25
35976: PUSH
35977: LD_INT 8
35979: PUSH
35980: EMPTY
35981: LIST
35982: LIST
35983: PUSH
35984: LD_INT 25
35986: PUSH
35987: LD_INT 9
35989: PUSH
35990: EMPTY
35991: LIST
35992: LIST
35993: PUSH
35994: EMPTY
35995: LIST
35996: LIST
35997: LIST
35998: LIST
35999: PPUSH
36000: CALL_OW 72
36004: ST_TO_ADDR
// if not tmp then
36005: LD_VAR 0 4
36009: NOT
36010: IFFALSE 36014
// continue ;
36012: GO 35833
// for j in tmp do
36014: LD_ADDR_VAR 0 3
36018: PUSH
36019: LD_VAR 0 4
36023: PUSH
36024: FOR_IN
36025: IFFALSE 36096
// if GetBType ( IsInUnit ( j ) ) = b_barracks and GetClass ( j ) = 1 and not MineOfUnit ( j ) and class then
36027: LD_VAR 0 3
36031: PPUSH
36032: CALL_OW 310
36036: PPUSH
36037: CALL_OW 266
36041: PUSH
36042: LD_INT 5
36044: EQUAL
36045: PUSH
36046: LD_VAR 0 3
36050: PPUSH
36051: CALL_OW 257
36055: PUSH
36056: LD_INT 1
36058: EQUAL
36059: AND
36060: PUSH
36061: LD_VAR 0 3
36065: PPUSH
36066: CALL_OW 459
36070: NOT
36071: AND
36072: PUSH
36073: LD_VAR 0 7
36077: AND
36078: IFFALSE 36094
// ComChangeProfession ( j , class ) ;
36080: LD_VAR 0 3
36084: PPUSH
36085: LD_VAR 0 7
36089: PPUSH
36090: CALL_OW 123
36094: GO 36024
36096: POP
36097: POP
// end ; if mc_scan [ i ] and not mc_defender [ i ] and not UnitFilter ( mc_bases [ i ] , [ f_btype , b_bunker ] ) and not UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_armoury ] , [ f_btype , b_barracks ] ] ) then
36098: LD_EXP 97
36102: PUSH
36103: LD_VAR 0 2
36107: ARRAY
36108: PUSH
36109: LD_EXP 96
36113: PUSH
36114: LD_VAR 0 2
36118: ARRAY
36119: NOT
36120: AND
36121: PUSH
36122: LD_EXP 74
36126: PUSH
36127: LD_VAR 0 2
36131: ARRAY
36132: PPUSH
36133: LD_INT 30
36135: PUSH
36136: LD_INT 32
36138: PUSH
36139: EMPTY
36140: LIST
36141: LIST
36142: PPUSH
36143: CALL_OW 72
36147: NOT
36148: AND
36149: PUSH
36150: LD_EXP 74
36154: PUSH
36155: LD_VAR 0 2
36159: ARRAY
36160: PPUSH
36161: LD_INT 2
36163: PUSH
36164: LD_INT 30
36166: PUSH
36167: LD_INT 4
36169: PUSH
36170: EMPTY
36171: LIST
36172: LIST
36173: PUSH
36174: LD_INT 30
36176: PUSH
36177: LD_INT 5
36179: PUSH
36180: EMPTY
36181: LIST
36182: LIST
36183: PUSH
36184: EMPTY
36185: LIST
36186: LIST
36187: LIST
36188: PPUSH
36189: CALL_OW 72
36193: NOT
36194: AND
36195: IFFALSE 36327
// begin tmp := UnitFilter ( mc_bases [ i ] , [ f_or , [ f_class , 1 ] , [ f_class , 5 ] , [ f_class , 8 ] , [ f_class , 9 ] ] ) ;
36197: LD_ADDR_VAR 0 4
36201: PUSH
36202: LD_EXP 74
36206: PUSH
36207: LD_VAR 0 2
36211: ARRAY
36212: PPUSH
36213: LD_INT 2
36215: PUSH
36216: LD_INT 25
36218: PUSH
36219: LD_INT 1
36221: PUSH
36222: EMPTY
36223: LIST
36224: LIST
36225: PUSH
36226: LD_INT 25
36228: PUSH
36229: LD_INT 5
36231: PUSH
36232: EMPTY
36233: LIST
36234: LIST
36235: PUSH
36236: LD_INT 25
36238: PUSH
36239: LD_INT 8
36241: PUSH
36242: EMPTY
36243: LIST
36244: LIST
36245: PUSH
36246: LD_INT 25
36248: PUSH
36249: LD_INT 9
36251: PUSH
36252: EMPTY
36253: LIST
36254: LIST
36255: PUSH
36256: EMPTY
36257: LIST
36258: LIST
36259: LIST
36260: LIST
36261: LIST
36262: PPUSH
36263: CALL_OW 72
36267: ST_TO_ADDR
// tmp := tmp diff FilterByTag ( tmp , 18 ) ;
36268: LD_ADDR_VAR 0 4
36272: PUSH
36273: LD_VAR 0 4
36277: PUSH
36278: LD_VAR 0 4
36282: PPUSH
36283: LD_INT 18
36285: PPUSH
36286: CALL 90213 0 2
36290: DIFF
36291: ST_TO_ADDR
// if tmp then
36292: LD_VAR 0 4
36296: IFFALSE 36327
// begin BasicDefend ( i , tmp , mc_scan_area [ i ] ) ;
36298: LD_VAR 0 2
36302: PPUSH
36303: LD_VAR 0 4
36307: PPUSH
36308: LD_EXP 99
36312: PUSH
36313: LD_VAR 0 2
36317: ARRAY
36318: PPUSH
36319: CALL 51527 0 3
// exit ;
36323: POP
36324: POP
36325: GO 36400
// end ; end ; if mc_scan [ i ] and mc_defender [ i ] then
36327: LD_EXP 97
36331: PUSH
36332: LD_VAR 0 2
36336: ARRAY
36337: PUSH
36338: LD_EXP 96
36342: PUSH
36343: LD_VAR 0 2
36347: ARRAY
36348: AND
36349: IFFALSE 36396
// begin tmp := mc_defender [ i ] ;
36351: LD_ADDR_VAR 0 4
36355: PUSH
36356: LD_EXP 96
36360: PUSH
36361: LD_VAR 0 2
36365: ARRAY
36366: ST_TO_ADDR
// Defend ( i , tmp , mc_scan [ i ] ) ;
36367: LD_VAR 0 2
36371: PPUSH
36372: LD_VAR 0 4
36376: PPUSH
36377: LD_EXP 97
36381: PUSH
36382: LD_VAR 0 2
36386: ARRAY
36387: PPUSH
36388: CALL 52088 0 3
// exit ;
36392: POP
36393: POP
36394: GO 36400
// end ; end ;
36396: GO 35833
36398: POP
36399: POP
// end ;
36400: LD_VAR 0 1
36404: RET
// export function MC_Research ( ) ; var i , j , side , t , tmp , x , sci , tmp2 , researching , idle_lab ; begin
36405: LD_INT 0
36407: PPUSH
36408: PPUSH
36409: PPUSH
36410: PPUSH
36411: PPUSH
36412: PPUSH
36413: PPUSH
36414: PPUSH
36415: PPUSH
36416: PPUSH
36417: PPUSH
// if not mc_bases then
36418: LD_EXP 74
36422: NOT
36423: IFFALSE 36427
// exit ;
36425: GO 37514
// for i = 1 to mc_bases do
36427: LD_ADDR_VAR 0 2
36431: PUSH
36432: DOUBLE
36433: LD_INT 1
36435: DEC
36436: ST_TO_ADDR
36437: LD_EXP 74
36441: PUSH
36442: FOR_TO
36443: IFFALSE 37512
// begin tmp := mc_lab [ i ] ;
36445: LD_ADDR_VAR 0 6
36449: PUSH
36450: LD_EXP 107
36454: PUSH
36455: LD_VAR 0 2
36459: ARRAY
36460: ST_TO_ADDR
// if not tmp then
36461: LD_VAR 0 6
36465: NOT
36466: IFFALSE 36470
// continue ;
36468: GO 36442
// idle_lab := 0 ;
36470: LD_ADDR_VAR 0 11
36474: PUSH
36475: LD_INT 0
36477: ST_TO_ADDR
// for j in tmp do
36478: LD_ADDR_VAR 0 3
36482: PUSH
36483: LD_VAR 0 6
36487: PUSH
36488: FOR_IN
36489: IFFALSE 37508
// begin researching := false ;
36491: LD_ADDR_VAR 0 10
36495: PUSH
36496: LD_INT 0
36498: ST_TO_ADDR
// side := GetSide ( j ) ;
36499: LD_ADDR_VAR 0 4
36503: PUSH
36504: LD_VAR 0 3
36508: PPUSH
36509: CALL_OW 255
36513: ST_TO_ADDR
// if not mc_tech [ side ] then
36514: LD_EXP 101
36518: PUSH
36519: LD_VAR 0 4
36523: ARRAY
36524: NOT
36525: IFFALSE 36529
// continue ;
36527: GO 36488
// if BuildingStatus ( j ) = bs_idle then
36529: LD_VAR 0 3
36533: PPUSH
36534: CALL_OW 461
36538: PUSH
36539: LD_INT 2
36541: EQUAL
36542: IFFALSE 36730
// begin if idle_lab and UnitsInside ( j ) < 6 then
36544: LD_VAR 0 11
36548: PUSH
36549: LD_VAR 0 3
36553: PPUSH
36554: CALL_OW 313
36558: PUSH
36559: LD_INT 6
36561: LESS
36562: AND
36563: IFFALSE 36634
// begin tmp2 := UnitsInside ( idle_lab ) ;
36565: LD_ADDR_VAR 0 9
36569: PUSH
36570: LD_VAR 0 11
36574: PPUSH
36575: CALL_OW 313
36579: ST_TO_ADDR
// if tmp2 then
36580: LD_VAR 0 9
36584: IFFALSE 36626
// for x in tmp2 do
36586: LD_ADDR_VAR 0 7
36590: PUSH
36591: LD_VAR 0 9
36595: PUSH
36596: FOR_IN
36597: IFFALSE 36624
// begin ComExitBuilding ( x ) ;
36599: LD_VAR 0 7
36603: PPUSH
36604: CALL_OW 122
// AddComEnterUnit ( x , j ) ;
36608: LD_VAR 0 7
36612: PPUSH
36613: LD_VAR 0 3
36617: PPUSH
36618: CALL_OW 180
// end ;
36622: GO 36596
36624: POP
36625: POP
// idle_lab := 0 ;
36626: LD_ADDR_VAR 0 11
36630: PUSH
36631: LD_INT 0
36633: ST_TO_ADDR
// end ; for t in mc_tech [ side ] do
36634: LD_ADDR_VAR 0 5
36638: PUSH
36639: LD_EXP 101
36643: PUSH
36644: LD_VAR 0 4
36648: ARRAY
36649: PUSH
36650: FOR_IN
36651: IFFALSE 36711
// if CanBeResearched ( j , t ) and TechCanBeResearch ( side , t ) then
36653: LD_VAR 0 3
36657: PPUSH
36658: LD_VAR 0 5
36662: PPUSH
36663: CALL_OW 430
36667: PUSH
36668: LD_VAR 0 4
36672: PPUSH
36673: LD_VAR 0 5
36677: PPUSH
36678: CALL 50597 0 2
36682: AND
36683: IFFALSE 36709
// begin researching := true ;
36685: LD_ADDR_VAR 0 10
36689: PUSH
36690: LD_INT 1
36692: ST_TO_ADDR
// ComResearch ( j , t ) ;
36693: LD_VAR 0 3
36697: PPUSH
36698: LD_VAR 0 5
36702: PPUSH
36703: CALL_OW 124
// break ;
36707: GO 36711
// end ;
36709: GO 36650
36711: POP
36712: POP
// if not researching then
36713: LD_VAR 0 10
36717: NOT
36718: IFFALSE 36730
// idle_lab := j ;
36720: LD_ADDR_VAR 0 11
36724: PUSH
36725: LD_VAR 0 3
36729: ST_TO_ADDR
// end ; if BuildingStatus ( j ) = bs_need_ape then
36730: LD_VAR 0 3
36734: PPUSH
36735: CALL_OW 461
36739: PUSH
36740: LD_INT 10
36742: EQUAL
36743: IFFALSE 37331
// begin if not mc_ape [ i ] and not mc_ape_in_lab [ i ] and mc_tech [ side ] > 1 then
36745: LD_EXP 103
36749: PUSH
36750: LD_VAR 0 2
36754: ARRAY
36755: NOT
36756: PUSH
36757: LD_EXP 104
36761: PUSH
36762: LD_VAR 0 2
36766: ARRAY
36767: NOT
36768: AND
36769: PUSH
36770: LD_EXP 101
36774: PUSH
36775: LD_VAR 0 4
36779: ARRAY
36780: PUSH
36781: LD_INT 1
36783: GREATER
36784: AND
36785: IFFALSE 36916
// begin ComCancel ( j ) ;
36787: LD_VAR 0 3
36791: PPUSH
36792: CALL_OW 127
// mc_tech := Replace ( mc_tech , side , Reindex ( mc_tech [ side ] , mc_tech [ side ] - 1 , mc_tech [ side ] , false ) ) ;
36796: LD_ADDR_EXP 101
36800: PUSH
36801: LD_EXP 101
36805: PPUSH
36806: LD_VAR 0 4
36810: PPUSH
36811: LD_EXP 101
36815: PUSH
36816: LD_VAR 0 4
36820: ARRAY
36821: PPUSH
36822: LD_EXP 101
36826: PUSH
36827: LD_VAR 0 4
36831: ARRAY
36832: PUSH
36833: LD_INT 1
36835: MINUS
36836: PPUSH
36837: LD_EXP 101
36841: PUSH
36842: LD_VAR 0 4
36846: ARRAY
36847: PPUSH
36848: LD_INT 0
36850: PPUSH
36851: CALL 56371 0 4
36855: PPUSH
36856: CALL_OW 1
36860: ST_TO_ADDR
// mc_tech := Replace ( mc_tech , side , Reindex ( mc_tech [ side ] , mc_tech [ side ] , 1 , false ) ) ;
36861: LD_ADDR_EXP 101
36865: PUSH
36866: LD_EXP 101
36870: PPUSH
36871: LD_VAR 0 4
36875: PPUSH
36876: LD_EXP 101
36880: PUSH
36881: LD_VAR 0 4
36885: ARRAY
36886: PPUSH
36887: LD_EXP 101
36891: PUSH
36892: LD_VAR 0 4
36896: ARRAY
36897: PPUSH
36898: LD_INT 1
36900: PPUSH
36901: LD_INT 0
36903: PPUSH
36904: CALL 56371 0 4
36908: PPUSH
36909: CALL_OW 1
36913: ST_TO_ADDR
// continue ;
36914: GO 36488
// end ; if mc_ape [ i ] and not mc_ape_in_lab [ i ] then
36916: LD_EXP 103
36920: PUSH
36921: LD_VAR 0 2
36925: ARRAY
36926: PUSH
36927: LD_EXP 104
36931: PUSH
36932: LD_VAR 0 2
36936: ARRAY
36937: NOT
36938: AND
36939: IFFALSE 37066
// begin mc_ape_in_lab := ReplaceIn ( mc_ape_in_lab , [ i , mc_ape_in_lab [ i ] + 1 ] , mc_ape [ i ] [ 1 ] ) ;
36941: LD_ADDR_EXP 104
36945: PUSH
36946: LD_EXP 104
36950: PPUSH
36951: LD_VAR 0 2
36955: PUSH
36956: LD_EXP 104
36960: PUSH
36961: LD_VAR 0 2
36965: ARRAY
36966: PUSH
36967: LD_INT 1
36969: PLUS
36970: PUSH
36971: EMPTY
36972: LIST
36973: LIST
36974: PPUSH
36975: LD_EXP 103
36979: PUSH
36980: LD_VAR 0 2
36984: ARRAY
36985: PUSH
36986: LD_INT 1
36988: ARRAY
36989: PPUSH
36990: CALL 56953 0 3
36994: ST_TO_ADDR
// SetTag ( mc_ape [ i ] [ 1 ] , 112 ) ;
36995: LD_EXP 103
36999: PUSH
37000: LD_VAR 0 2
37004: ARRAY
37005: PUSH
37006: LD_INT 1
37008: ARRAY
37009: PPUSH
37010: LD_INT 112
37012: PPUSH
37013: CALL_OW 109
// tmp2 := Delete ( mc_ape [ i ] , 1 ) ;
37017: LD_ADDR_VAR 0 9
37021: PUSH
37022: LD_EXP 103
37026: PUSH
37027: LD_VAR 0 2
37031: ARRAY
37032: PPUSH
37033: LD_INT 1
37035: PPUSH
37036: CALL_OW 3
37040: ST_TO_ADDR
// mc_ape := Replace ( mc_ape , i , tmp2 ) ;
37041: LD_ADDR_EXP 103
37045: PUSH
37046: LD_EXP 103
37050: PPUSH
37051: LD_VAR 0 2
37055: PPUSH
37056: LD_VAR 0 9
37060: PPUSH
37061: CALL_OW 1
37065: ST_TO_ADDR
// end ; if mc_ape [ i ] and mc_ape_in_lab [ i ] and not IsInUnit ( mc_ape_in_lab [ i ] [ 1 ] ) and UnitsInside ( j ) = 6 then
37066: LD_EXP 103
37070: PUSH
37071: LD_VAR 0 2
37075: ARRAY
37076: PUSH
37077: LD_EXP 104
37081: PUSH
37082: LD_VAR 0 2
37086: ARRAY
37087: AND
37088: PUSH
37089: LD_EXP 104
37093: PUSH
37094: LD_VAR 0 2
37098: ARRAY
37099: PUSH
37100: LD_INT 1
37102: ARRAY
37103: PPUSH
37104: CALL_OW 310
37108: NOT
37109: AND
37110: PUSH
37111: LD_VAR 0 3
37115: PPUSH
37116: CALL_OW 313
37120: PUSH
37121: LD_INT 6
37123: EQUAL
37124: AND
37125: IFFALSE 37181
// begin tmp2 := UnitsInside ( j ) ;
37127: LD_ADDR_VAR 0 9
37131: PUSH
37132: LD_VAR 0 3
37136: PPUSH
37137: CALL_OW 313
37141: ST_TO_ADDR
// if tmp2 = 6 then
37142: LD_VAR 0 9
37146: PUSH
37147: LD_INT 6
37149: EQUAL
37150: IFFALSE 37181
// begin SetTag ( tmp2 [ 1 ] , 112 ) ;
37152: LD_VAR 0 9
37156: PUSH
37157: LD_INT 1
37159: ARRAY
37160: PPUSH
37161: LD_INT 112
37163: PPUSH
37164: CALL_OW 109
// ComExitBuilding ( tmp2 [ 1 ] ) ;
37168: LD_VAR 0 9
37172: PUSH
37173: LD_INT 1
37175: ARRAY
37176: PPUSH
37177: CALL_OW 122
// end ; end ; if mc_ape_in_lab [ i ] and not HasTask ( mc_ape_in_lab [ i ] [ 1 ] ) and not IsInUnit ( mc_ape_in_lab [ i ] [ 1 ] ) then
37181: LD_EXP 104
37185: PUSH
37186: LD_VAR 0 2
37190: ARRAY
37191: PUSH
37192: LD_EXP 104
37196: PUSH
37197: LD_VAR 0 2
37201: ARRAY
37202: PUSH
37203: LD_INT 1
37205: ARRAY
37206: PPUSH
37207: CALL_OW 314
37211: NOT
37212: AND
37213: PUSH
37214: LD_EXP 104
37218: PUSH
37219: LD_VAR 0 2
37223: ARRAY
37224: PUSH
37225: LD_INT 1
37227: ARRAY
37228: PPUSH
37229: CALL_OW 310
37233: NOT
37234: AND
37235: IFFALSE 37261
// ComEnterUnit ( mc_ape_in_lab [ i ] [ 1 ] , j ) ;
37237: LD_EXP 104
37241: PUSH
37242: LD_VAR 0 2
37246: ARRAY
37247: PUSH
37248: LD_INT 1
37250: ARRAY
37251: PPUSH
37252: LD_VAR 0 3
37256: PPUSH
37257: CALL_OW 120
// if IsInUnit ( mc_ape_in_lab [ i ] [ 1 ] ) and BuildingStatus ( IsInUnit ( mc_ape_in_lab [ i ] [ 1 ] ) ) <> bs_working then
37261: LD_EXP 104
37265: PUSH
37266: LD_VAR 0 2
37270: ARRAY
37271: PUSH
37272: LD_INT 1
37274: ARRAY
37275: PPUSH
37276: CALL_OW 310
37280: PUSH
37281: LD_EXP 104
37285: PUSH
37286: LD_VAR 0 2
37290: ARRAY
37291: PUSH
37292: LD_INT 1
37294: ARRAY
37295: PPUSH
37296: CALL_OW 310
37300: PPUSH
37301: CALL_OW 461
37305: PUSH
37306: LD_INT 3
37308: NONEQUAL
37309: AND
37310: IFFALSE 37331
// ComExitBuilding ( mc_ape_in_lab [ i ] [ 1 ] ) ;
37312: LD_EXP 104
37316: PUSH
37317: LD_VAR 0 2
37321: ARRAY
37322: PUSH
37323: LD_INT 1
37325: ARRAY
37326: PPUSH
37327: CALL_OW 122
// end ; if BuildingStatus ( j ) = bs_need_people and tmp > 1 then
37331: LD_VAR 0 3
37335: PPUSH
37336: CALL_OW 461
37340: PUSH
37341: LD_INT 6
37343: EQUAL
37344: PUSH
37345: LD_VAR 0 6
37349: PUSH
37350: LD_INT 1
37352: GREATER
37353: AND
37354: IFFALSE 37506
// begin sci := [ ] ;
37356: LD_ADDR_VAR 0 8
37360: PUSH
37361: EMPTY
37362: ST_TO_ADDR
// for x in ( tmp diff j ) do
37363: LD_ADDR_VAR 0 7
37367: PUSH
37368: LD_VAR 0 6
37372: PUSH
37373: LD_VAR 0 3
37377: DIFF
37378: PUSH
37379: FOR_IN
37380: IFFALSE 37432
// begin if sci = 6 then
37382: LD_VAR 0 8
37386: PUSH
37387: LD_INT 6
37389: EQUAL
37390: IFFALSE 37394
// break ;
37392: GO 37432
// if BuildingStatus ( x ) = bs_idle then
37394: LD_VAR 0 7
37398: PPUSH
37399: CALL_OW 461
37403: PUSH
37404: LD_INT 2
37406: EQUAL
37407: IFFALSE 37430
// sci := sci ^ UnitsInside ( x ) ;
37409: LD_ADDR_VAR 0 8
37413: PUSH
37414: LD_VAR 0 8
37418: PUSH
37419: LD_VAR 0 7
37423: PPUSH
37424: CALL_OW 313
37428: ADD
37429: ST_TO_ADDR
// end ;
37430: GO 37379
37432: POP
37433: POP
// if not sci then
37434: LD_VAR 0 8
37438: NOT
37439: IFFALSE 37443
// continue ;
37441: GO 36488
// for x in sci do
37443: LD_ADDR_VAR 0 7
37447: PUSH
37448: LD_VAR 0 8
37452: PUSH
37453: FOR_IN
37454: IFFALSE 37504
// if IsInUnit ( x ) and not HasTask ( x ) then
37456: LD_VAR 0 7
37460: PPUSH
37461: CALL_OW 310
37465: PUSH
37466: LD_VAR 0 7
37470: PPUSH
37471: CALL_OW 314
37475: NOT
37476: AND
37477: IFFALSE 37502
// begin ComExitBuilding ( x ) ;
37479: LD_VAR 0 7
37483: PPUSH
37484: CALL_OW 122
// AddComEnterUnit ( x , j ) ;
37488: LD_VAR 0 7
37492: PPUSH
37493: LD_VAR 0 3
37497: PPUSH
37498: CALL_OW 180
// end ;
37502: GO 37453
37504: POP
37505: POP
// end ; end ;
37506: GO 36488
37508: POP
37509: POP
// end ;
37510: GO 36442
37512: POP
37513: POP
// end ;
37514: LD_VAR 0 1
37518: RET
// export function MC_MinesTrigger ( ) ; var i ; begin
37519: LD_INT 0
37521: PPUSH
37522: PPUSH
// if not mc_bases then
37523: LD_EXP 74
37527: NOT
37528: IFFALSE 37532
// exit ;
37530: GO 37613
// for i = 1 to mc_bases do
37532: LD_ADDR_VAR 0 2
37536: PUSH
37537: DOUBLE
37538: LD_INT 1
37540: DEC
37541: ST_TO_ADDR
37542: LD_EXP 74
37546: PUSH
37547: FOR_TO
37548: IFFALSE 37611
// if mc_mines [ i ] and mc_miners [ i ] then
37550: LD_EXP 87
37554: PUSH
37555: LD_VAR 0 2
37559: ARRAY
37560: PUSH
37561: LD_EXP 88
37565: PUSH
37566: LD_VAR 0 2
37570: ARRAY
37571: AND
37572: IFFALSE 37609
// DetonateMines ( GetSide ( mc_miners [ i ] [ 1 ] ) , mc_mines [ i ] ) ;
37574: LD_EXP 88
37578: PUSH
37579: LD_VAR 0 2
37583: ARRAY
37584: PUSH
37585: LD_INT 1
37587: ARRAY
37588: PPUSH
37589: CALL_OW 255
37593: PPUSH
37594: LD_EXP 87
37598: PUSH
37599: LD_VAR 0 2
37603: ARRAY
37604: PPUSH
37605: CALL 53942 0 2
37609: GO 37547
37611: POP
37612: POP
// end ;
37613: LD_VAR 0 1
37617: RET
// export function MC_RepairVehicle ( ) ; var i , j , k , side , fac , vehs , tmp ; begin
37618: LD_INT 0
37620: PPUSH
37621: PPUSH
37622: PPUSH
37623: PPUSH
37624: PPUSH
37625: PPUSH
37626: PPUSH
37627: PPUSH
// if not mc_bases or not mc_parking then
37628: LD_EXP 74
37632: NOT
37633: PUSH
37634: LD_EXP 98
37638: NOT
37639: OR
37640: IFFALSE 37644
// exit ;
37642: GO 38343
// for i = 1 to mc_bases do
37644: LD_ADDR_VAR 0 2
37648: PUSH
37649: DOUBLE
37650: LD_INT 1
37652: DEC
37653: ST_TO_ADDR
37654: LD_EXP 74
37658: PUSH
37659: FOR_TO
37660: IFFALSE 38341
// begin if not mc_bases [ i ] or not mc_parking [ i ] then
37662: LD_EXP 74
37666: PUSH
37667: LD_VAR 0 2
37671: ARRAY
37672: NOT
37673: PUSH
37674: LD_EXP 98
37678: PUSH
37679: LD_VAR 0 2
37683: ARRAY
37684: NOT
37685: OR
37686: IFFALSE 37690
// continue ;
37688: GO 37659
// side := GetSide ( mc_bases [ i ] [ 1 ] ) ;
37690: LD_ADDR_VAR 0 5
37694: PUSH
37695: LD_EXP 74
37699: PUSH
37700: LD_VAR 0 2
37704: ARRAY
37705: PUSH
37706: LD_INT 1
37708: ARRAY
37709: PPUSH
37710: CALL_OW 255
37714: ST_TO_ADDR
// fac := UnitFilter ( mc_bases [ i ] , [ f_btype , b_factory ] ) ;
37715: LD_ADDR_VAR 0 6
37719: PUSH
37720: LD_EXP 74
37724: PUSH
37725: LD_VAR 0 2
37729: ARRAY
37730: PPUSH
37731: LD_INT 30
37733: PUSH
37734: LD_INT 3
37736: PUSH
37737: EMPTY
37738: LIST
37739: LIST
37740: PPUSH
37741: CALL_OW 72
37745: ST_TO_ADDR
// if not fac then
37746: LD_VAR 0 6
37750: NOT
37751: IFFALSE 37802
// fac := UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) ;
37753: LD_ADDR_VAR 0 6
37757: PUSH
37758: LD_EXP 74
37762: PUSH
37763: LD_VAR 0 2
37767: ARRAY
37768: PPUSH
37769: LD_INT 2
37771: PUSH
37772: LD_INT 30
37774: PUSH
37775: LD_INT 0
37777: PUSH
37778: EMPTY
37779: LIST
37780: LIST
37781: PUSH
37782: LD_INT 30
37784: PUSH
37785: LD_INT 1
37787: PUSH
37788: EMPTY
37789: LIST
37790: LIST
37791: PUSH
37792: EMPTY
37793: LIST
37794: LIST
37795: LIST
37796: PPUSH
37797: CALL_OW 72
37801: ST_TO_ADDR
// if not fac then
37802: LD_VAR 0 6
37806: NOT
37807: IFFALSE 37811
// continue ;
37809: GO 37659
// vehs := FilterUnitsInArea ( mc_parking [ i ] , [ [ f_side , side ] , [ f_type , unit_vehicle ] , [ f_not , [ f_lives , 1000 ] ] ] ) ;
37811: LD_ADDR_VAR 0 7
37815: PUSH
37816: LD_EXP 98
37820: PUSH
37821: LD_VAR 0 2
37825: ARRAY
37826: PPUSH
37827: LD_INT 22
37829: PUSH
37830: LD_VAR 0 5
37834: PUSH
37835: EMPTY
37836: LIST
37837: LIST
37838: PUSH
37839: LD_INT 21
37841: PUSH
37842: LD_INT 2
37844: PUSH
37845: EMPTY
37846: LIST
37847: LIST
37848: PUSH
37849: LD_INT 3
37851: PUSH
37852: LD_INT 24
37854: PUSH
37855: LD_INT 1000
37857: PUSH
37858: EMPTY
37859: LIST
37860: LIST
37861: PUSH
37862: EMPTY
37863: LIST
37864: LIST
37865: PUSH
37866: EMPTY
37867: LIST
37868: LIST
37869: LIST
37870: PPUSH
37871: CALL_OW 70
37875: ST_TO_ADDR
// for j in fac do
37876: LD_ADDR_VAR 0 3
37880: PUSH
37881: LD_VAR 0 6
37885: PUSH
37886: FOR_IN
37887: IFFALSE 37968
// vehs := vehs union FilterAllUnits ( [ [ f_side , side ] , [ f_dist , j , 15 ] , [ f_type , unit_vehicle ] , [ f_not , [ f_lives , 1000 ] ] ] ) ;
37889: LD_ADDR_VAR 0 7
37893: PUSH
37894: LD_VAR 0 7
37898: PUSH
37899: LD_INT 22
37901: PUSH
37902: LD_VAR 0 5
37906: PUSH
37907: EMPTY
37908: LIST
37909: LIST
37910: PUSH
37911: LD_INT 91
37913: PUSH
37914: LD_VAR 0 3
37918: PUSH
37919: LD_INT 15
37921: PUSH
37922: EMPTY
37923: LIST
37924: LIST
37925: LIST
37926: PUSH
37927: LD_INT 21
37929: PUSH
37930: LD_INT 2
37932: PUSH
37933: EMPTY
37934: LIST
37935: LIST
37936: PUSH
37937: LD_INT 3
37939: PUSH
37940: LD_INT 24
37942: PUSH
37943: LD_INT 1000
37945: PUSH
37946: EMPTY
37947: LIST
37948: LIST
37949: PUSH
37950: EMPTY
37951: LIST
37952: LIST
37953: PUSH
37954: EMPTY
37955: LIST
37956: LIST
37957: LIST
37958: LIST
37959: PPUSH
37960: CALL_OW 69
37964: UNION
37965: ST_TO_ADDR
37966: GO 37886
37968: POP
37969: POP
// if not vehs then
37970: LD_VAR 0 7
37974: NOT
37975: IFFALSE 38001
// begin mc_repair_vehicle := Replace ( mc_repair_vehicle , i , [ ] ) ;
37977: LD_ADDR_EXP 86
37981: PUSH
37982: LD_EXP 86
37986: PPUSH
37987: LD_VAR 0 2
37991: PPUSH
37992: EMPTY
37993: PPUSH
37994: CALL_OW 1
37998: ST_TO_ADDR
// continue ;
37999: GO 37659
// end ; tmp := UnitFilter ( mc_bases [ i ] , [ f_btype , b_factory ] ) ;
38001: LD_ADDR_VAR 0 8
38005: PUSH
38006: LD_EXP 74
38010: PUSH
38011: LD_VAR 0 2
38015: ARRAY
38016: PPUSH
38017: LD_INT 30
38019: PUSH
38020: LD_INT 3
38022: PUSH
38023: EMPTY
38024: LIST
38025: LIST
38026: PPUSH
38027: CALL_OW 72
38031: ST_TO_ADDR
// if tmp then
38032: LD_VAR 0 8
38036: IFFALSE 38139
// begin for j in tmp do
38038: LD_ADDR_VAR 0 3
38042: PUSH
38043: LD_VAR 0 8
38047: PUSH
38048: FOR_IN
38049: IFFALSE 38137
// for k in UnitsInside ( j ) do
38051: LD_ADDR_VAR 0 4
38055: PUSH
38056: LD_VAR 0 3
38060: PPUSH
38061: CALL_OW 313
38065: PUSH
38066: FOR_IN
38067: IFFALSE 38133
// if k then
38069: LD_VAR 0 4
38073: IFFALSE 38131
// if not k in mc_repair_vehicle [ i ] then
38075: LD_VAR 0 4
38079: PUSH
38080: LD_EXP 86
38084: PUSH
38085: LD_VAR 0 2
38089: ARRAY
38090: IN
38091: NOT
38092: IFFALSE 38131
// mc_repair_vehicle := Replace ( mc_repair_vehicle , i , mc_repair_vehicle [ i ] union k ) ;
38094: LD_ADDR_EXP 86
38098: PUSH
38099: LD_EXP 86
38103: PPUSH
38104: LD_VAR 0 2
38108: PPUSH
38109: LD_EXP 86
38113: PUSH
38114: LD_VAR 0 2
38118: ARRAY
38119: PUSH
38120: LD_VAR 0 4
38124: UNION
38125: PPUSH
38126: CALL_OW 1
38130: ST_TO_ADDR
38131: GO 38066
38133: POP
38134: POP
38135: GO 38048
38137: POP
38138: POP
// end ; if not mc_repair_vehicle [ i ] then
38139: LD_EXP 86
38143: PUSH
38144: LD_VAR 0 2
38148: ARRAY
38149: NOT
38150: IFFALSE 38154
// continue ;
38152: GO 37659
// for j in mc_repair_vehicle [ i ] do
38154: LD_ADDR_VAR 0 3
38158: PUSH
38159: LD_EXP 86
38163: PUSH
38164: LD_VAR 0 2
38168: ARRAY
38169: PUSH
38170: FOR_IN
38171: IFFALSE 38337
// begin if GetClass ( j ) <> 3 then
38173: LD_VAR 0 3
38177: PPUSH
38178: CALL_OW 257
38182: PUSH
38183: LD_INT 3
38185: NONEQUAL
38186: IFFALSE 38227
// begin mc_repair_vehicle := Replace ( mc_repair_vehicle , i , mc_repair_vehicle [ i ] diff j ) ;
38188: LD_ADDR_EXP 86
38192: PUSH
38193: LD_EXP 86
38197: PPUSH
38198: LD_VAR 0 2
38202: PPUSH
38203: LD_EXP 86
38207: PUSH
38208: LD_VAR 0 2
38212: ARRAY
38213: PUSH
38214: LD_VAR 0 3
38218: DIFF
38219: PPUSH
38220: CALL_OW 1
38224: ST_TO_ADDR
// continue ;
38225: GO 38170
// end ; if not IsDrivenBy ( j ) and not j in mc_need_heal [ i ] [ 1 ] and not j in mc_need_heal [ i ] [ 2 ] then
38227: LD_VAR 0 3
38231: PPUSH
38232: CALL_OW 311
38236: NOT
38237: PUSH
38238: LD_VAR 0 3
38242: PUSH
38243: LD_EXP 77
38247: PUSH
38248: LD_VAR 0 2
38252: ARRAY
38253: PUSH
38254: LD_INT 1
38256: ARRAY
38257: IN
38258: NOT
38259: AND
38260: PUSH
38261: LD_VAR 0 3
38265: PUSH
38266: LD_EXP 77
38270: PUSH
38271: LD_VAR 0 2
38275: ARRAY
38276: PUSH
38277: LD_INT 2
38279: ARRAY
38280: IN
38281: NOT
38282: AND
38283: IFFALSE 38335
// begin if IsInUnit ( j ) then
38285: LD_VAR 0 3
38289: PPUSH
38290: CALL_OW 310
38294: IFFALSE 38305
// ComExitBuilding ( j ) ;
38296: LD_VAR 0 3
38300: PPUSH
38301: CALL_OW 122
// if not HasTask ( j ) then
38305: LD_VAR 0 3
38309: PPUSH
38310: CALL_OW 314
38314: NOT
38315: IFFALSE 38335
// AddComRepairVehicle ( j , vehs [ 1 ] ) ;
38317: LD_VAR 0 3
38321: PPUSH
38322: LD_VAR 0 7
38326: PUSH
38327: LD_INT 1
38329: ARRAY
38330: PPUSH
38331: CALL_OW 189
// end ; end ;
38335: GO 38170
38337: POP
38338: POP
// end ;
38339: GO 37659
38341: POP
38342: POP
// end ;
38343: LD_VAR 0 1
38347: RET
// export function MC_TameApe ( ) ; var i , j , x , y , ape , apes , tmp , dep , danger_at_area , side ; begin
38348: LD_INT 0
38350: PPUSH
38351: PPUSH
38352: PPUSH
38353: PPUSH
38354: PPUSH
38355: PPUSH
38356: PPUSH
38357: PPUSH
38358: PPUSH
38359: PPUSH
38360: PPUSH
// if not mc_bases then
38361: LD_EXP 74
38365: NOT
38366: IFFALSE 38370
// exit ;
38368: GO 39172
// for i = 1 to mc_bases do
38370: LD_ADDR_VAR 0 2
38374: PUSH
38375: DOUBLE
38376: LD_INT 1
38378: DEC
38379: ST_TO_ADDR
38380: LD_EXP 74
38384: PUSH
38385: FOR_TO
38386: IFFALSE 39170
// begin if not mc_can_tame [ i ] or mc_need_heal [ i ] [ 1 ] or mc_need_heal [ i ] [ 2 ] or not Researched ( mc_sides [ i ] , tech_apelang ) or mc_scan [ i ] then
38388: LD_EXP 102
38392: PUSH
38393: LD_VAR 0 2
38397: ARRAY
38398: NOT
38399: PUSH
38400: LD_EXP 77
38404: PUSH
38405: LD_VAR 0 2
38409: ARRAY
38410: PUSH
38411: LD_INT 1
38413: ARRAY
38414: OR
38415: PUSH
38416: LD_EXP 77
38420: PUSH
38421: LD_VAR 0 2
38425: ARRAY
38426: PUSH
38427: LD_INT 2
38429: ARRAY
38430: OR
38431: PUSH
38432: LD_EXP 100
38436: PUSH
38437: LD_VAR 0 2
38441: ARRAY
38442: PPUSH
38443: LD_INT 1
38445: PPUSH
38446: CALL_OW 325
38450: NOT
38451: OR
38452: PUSH
38453: LD_EXP 97
38457: PUSH
38458: LD_VAR 0 2
38462: ARRAY
38463: OR
38464: IFFALSE 38468
// continue ;
38466: GO 38385
// tmp := UnitFilter ( mc_bases [ i ] , [ [ f_class , 4 ] , [ f_ok ] , [ f_not , [ f_hastask ] ] ] ) diff mc_healers [ i ] ;
38468: LD_ADDR_VAR 0 8
38472: PUSH
38473: LD_EXP 74
38477: PUSH
38478: LD_VAR 0 2
38482: ARRAY
38483: PPUSH
38484: LD_INT 25
38486: PUSH
38487: LD_INT 4
38489: PUSH
38490: EMPTY
38491: LIST
38492: LIST
38493: PUSH
38494: LD_INT 50
38496: PUSH
38497: EMPTY
38498: LIST
38499: PUSH
38500: LD_INT 3
38502: PUSH
38503: LD_INT 60
38505: PUSH
38506: EMPTY
38507: LIST
38508: PUSH
38509: EMPTY
38510: LIST
38511: LIST
38512: PUSH
38513: EMPTY
38514: LIST
38515: LIST
38516: LIST
38517: PPUSH
38518: CALL_OW 72
38522: PUSH
38523: LD_EXP 78
38527: PUSH
38528: LD_VAR 0 2
38532: ARRAY
38533: DIFF
38534: ST_TO_ADDR
// dep := UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) ;
38535: LD_ADDR_VAR 0 9
38539: PUSH
38540: LD_EXP 74
38544: PUSH
38545: LD_VAR 0 2
38549: ARRAY
38550: PPUSH
38551: LD_INT 2
38553: PUSH
38554: LD_INT 30
38556: PUSH
38557: LD_INT 0
38559: PUSH
38560: EMPTY
38561: LIST
38562: LIST
38563: PUSH
38564: LD_INT 30
38566: PUSH
38567: LD_INT 1
38569: PUSH
38570: EMPTY
38571: LIST
38572: LIST
38573: PUSH
38574: EMPTY
38575: LIST
38576: LIST
38577: LIST
38578: PPUSH
38579: CALL_OW 72
38583: ST_TO_ADDR
// if not tmp or not dep then
38584: LD_VAR 0 8
38588: NOT
38589: PUSH
38590: LD_VAR 0 9
38594: NOT
38595: OR
38596: IFFALSE 38600
// continue ;
38598: GO 38385
// side := GetSide ( tmp [ 1 ] ) ;
38600: LD_ADDR_VAR 0 11
38604: PUSH
38605: LD_VAR 0 8
38609: PUSH
38610: LD_INT 1
38612: ARRAY
38613: PPUSH
38614: CALL_OW 255
38618: ST_TO_ADDR
// dep := dep [ 1 ] ;
38619: LD_ADDR_VAR 0 9
38623: PUSH
38624: LD_VAR 0 9
38628: PUSH
38629: LD_INT 1
38631: ARRAY
38632: ST_TO_ADDR
// apes := FilterUnitsInArea ( mc_can_tame [ i ] , [ [ f_side , 0 ] , [ f_class , class_apeman ] ] ) union FilterAllUnits ( [ [ f_side , 0 ] , [ f_class , class_apeman ] , [ f_dist , dep , 20 ] ] ) ;
38633: LD_ADDR_VAR 0 7
38637: PUSH
38638: LD_EXP 102
38642: PUSH
38643: LD_VAR 0 2
38647: ARRAY
38648: PPUSH
38649: LD_INT 22
38651: PUSH
38652: LD_INT 0
38654: PUSH
38655: EMPTY
38656: LIST
38657: LIST
38658: PUSH
38659: LD_INT 25
38661: PUSH
38662: LD_INT 12
38664: PUSH
38665: EMPTY
38666: LIST
38667: LIST
38668: PUSH
38669: EMPTY
38670: LIST
38671: LIST
38672: PPUSH
38673: CALL_OW 70
38677: PUSH
38678: LD_INT 22
38680: PUSH
38681: LD_INT 0
38683: PUSH
38684: EMPTY
38685: LIST
38686: LIST
38687: PUSH
38688: LD_INT 25
38690: PUSH
38691: LD_INT 12
38693: PUSH
38694: EMPTY
38695: LIST
38696: LIST
38697: PUSH
38698: LD_INT 91
38700: PUSH
38701: LD_VAR 0 9
38705: PUSH
38706: LD_INT 20
38708: PUSH
38709: EMPTY
38710: LIST
38711: LIST
38712: LIST
38713: PUSH
38714: EMPTY
38715: LIST
38716: LIST
38717: LIST
38718: PPUSH
38719: CALL_OW 69
38723: UNION
38724: ST_TO_ADDR
// danger_at_area := FilterUnitsInArea ( mc_can_tame [ i ] , [ f_enemy , side ] ) ;
38725: LD_ADDR_VAR 0 10
38729: PUSH
38730: LD_EXP 102
38734: PUSH
38735: LD_VAR 0 2
38739: ARRAY
38740: PPUSH
38741: LD_INT 81
38743: PUSH
38744: LD_VAR 0 11
38748: PUSH
38749: EMPTY
38750: LIST
38751: LIST
38752: PPUSH
38753: CALL_OW 70
38757: ST_TO_ADDR
// if not apes or danger_at_area then
38758: LD_VAR 0 7
38762: NOT
38763: PUSH
38764: LD_VAR 0 10
38768: OR
38769: IFFALSE 38819
// begin if mc_taming [ i ] then
38771: LD_EXP 105
38775: PUSH
38776: LD_VAR 0 2
38780: ARRAY
38781: IFFALSE 38817
// begin MC_Reset ( i , 121 ) ;
38783: LD_VAR 0 2
38787: PPUSH
38788: LD_INT 121
38790: PPUSH
38791: CALL 24150 0 2
// mc_taming := Replace ( mc_taming , i , [ ] ) ;
38795: LD_ADDR_EXP 105
38799: PUSH
38800: LD_EXP 105
38804: PPUSH
38805: LD_VAR 0 2
38809: PPUSH
38810: EMPTY
38811: PPUSH
38812: CALL_OW 1
38816: ST_TO_ADDR
// end ; continue ;
38817: GO 38385
// end ; for j in tmp do
38819: LD_ADDR_VAR 0 3
38823: PUSH
38824: LD_VAR 0 8
38828: PUSH
38829: FOR_IN
38830: IFFALSE 39166
// begin if not j in mc_taming [ i ] and mc_taming [ i ] < 3 then
38832: LD_VAR 0 3
38836: PUSH
38837: LD_EXP 105
38841: PUSH
38842: LD_VAR 0 2
38846: ARRAY
38847: IN
38848: NOT
38849: PUSH
38850: LD_EXP 105
38854: PUSH
38855: LD_VAR 0 2
38859: ARRAY
38860: PUSH
38861: LD_INT 3
38863: LESS
38864: AND
38865: IFFALSE 38923
// begin SetTag ( j , 121 ) ;
38867: LD_VAR 0 3
38871: PPUSH
38872: LD_INT 121
38874: PPUSH
38875: CALL_OW 109
// mc_taming := ReplaceIn ( mc_taming , [ i , mc_taming [ i ] + 1 ] , j ) ;
38879: LD_ADDR_EXP 105
38883: PUSH
38884: LD_EXP 105
38888: PPUSH
38889: LD_VAR 0 2
38893: PUSH
38894: LD_EXP 105
38898: PUSH
38899: LD_VAR 0 2
38903: ARRAY
38904: PUSH
38905: LD_INT 1
38907: PLUS
38908: PUSH
38909: EMPTY
38910: LIST
38911: LIST
38912: PPUSH
38913: LD_VAR 0 3
38917: PPUSH
38918: CALL 56953 0 3
38922: ST_TO_ADDR
// end ; if j in mc_taming [ i ] then
38923: LD_VAR 0 3
38927: PUSH
38928: LD_EXP 105
38932: PUSH
38933: LD_VAR 0 2
38937: ARRAY
38938: IN
38939: IFFALSE 39164
// begin if GetClass ( j ) <> 4 then
38941: LD_VAR 0 3
38945: PPUSH
38946: CALL_OW 257
38950: PUSH
38951: LD_INT 4
38953: NONEQUAL
38954: IFFALSE 39007
// begin mc_taming := Replace ( mc_taming , i , mc_taming [ i ] diff j ) ;
38956: LD_ADDR_EXP 105
38960: PUSH
38961: LD_EXP 105
38965: PPUSH
38966: LD_VAR 0 2
38970: PPUSH
38971: LD_EXP 105
38975: PUSH
38976: LD_VAR 0 2
38980: ARRAY
38981: PUSH
38982: LD_VAR 0 3
38986: DIFF
38987: PPUSH
38988: CALL_OW 1
38992: ST_TO_ADDR
// SetTag ( j , 0 ) ;
38993: LD_VAR 0 3
38997: PPUSH
38998: LD_INT 0
39000: PPUSH
39001: CALL_OW 109
// continue ;
39005: GO 38829
// end ; if IsInUnit ( j ) then
39007: LD_VAR 0 3
39011: PPUSH
39012: CALL_OW 310
39016: IFFALSE 39027
// ComExitBuilding ( j ) ;
39018: LD_VAR 0 3
39022: PPUSH
39023: CALL_OW 122
// ape := NearestUnitToUnit ( apes , j ) ;
39027: LD_ADDR_VAR 0 6
39031: PUSH
39032: LD_VAR 0 7
39036: PPUSH
39037: LD_VAR 0 3
39041: PPUSH
39042: CALL_OW 74
39046: ST_TO_ADDR
// if not ape then
39047: LD_VAR 0 6
39051: NOT
39052: IFFALSE 39056
// break ;
39054: GO 39166
// x := GetX ( ape ) ;
39056: LD_ADDR_VAR 0 4
39060: PUSH
39061: LD_VAR 0 6
39065: PPUSH
39066: CALL_OW 250
39070: ST_TO_ADDR
// y := GetY ( ape ) ;
39071: LD_ADDR_VAR 0 5
39075: PUSH
39076: LD_VAR 0 6
39080: PPUSH
39081: CALL_OW 251
39085: ST_TO_ADDR
// if not ValidHex ( x , y ) or DangerAtRangeXY ( side , x , y , 20 ) [ 4 ] then
39086: LD_VAR 0 4
39090: PPUSH
39091: LD_VAR 0 5
39095: PPUSH
39096: CALL_OW 488
39100: NOT
39101: PUSH
39102: LD_VAR 0 11
39106: PPUSH
39107: LD_VAR 0 4
39111: PPUSH
39112: LD_VAR 0 5
39116: PPUSH
39117: LD_INT 20
39119: PPUSH
39120: CALL 57849 0 4
39124: PUSH
39125: LD_INT 4
39127: ARRAY
39128: OR
39129: IFFALSE 39133
// break ;
39131: GO 39166
// if not HasTask ( j ) then
39133: LD_VAR 0 3
39137: PPUSH
39138: CALL_OW 314
39142: NOT
39143: IFFALSE 39164
// ComTameXY ( j , x , y ) ;
39145: LD_VAR 0 3
39149: PPUSH
39150: LD_VAR 0 4
39154: PPUSH
39155: LD_VAR 0 5
39159: PPUSH
39160: CALL_OW 131
// end ; end ;
39164: GO 38829
39166: POP
39167: POP
// end ;
39168: GO 38385
39170: POP
39171: POP
// end ;
39172: LD_VAR 0 1
39176: RET
// export function MC_ChangeApeClass ( ) ; var i , j , tmp , side , depot , selected , barracks ; begin
39177: LD_INT 0
39179: PPUSH
39180: PPUSH
39181: PPUSH
39182: PPUSH
39183: PPUSH
39184: PPUSH
39185: PPUSH
39186: PPUSH
// if not mc_bases then
39187: LD_EXP 74
39191: NOT
39192: IFFALSE 39196
// exit ;
39194: GO 39822
// for i = 1 to mc_bases do
39196: LD_ADDR_VAR 0 2
39200: PUSH
39201: DOUBLE
39202: LD_INT 1
39204: DEC
39205: ST_TO_ADDR
39206: LD_EXP 74
39210: PUSH
39211: FOR_TO
39212: IFFALSE 39820
// begin if not mc_ape [ i ] or not UnitFilter ( mc_ape [ i ] , [ f_class , 12 ] ) then
39214: LD_EXP 103
39218: PUSH
39219: LD_VAR 0 2
39223: ARRAY
39224: NOT
39225: PUSH
39226: LD_EXP 103
39230: PUSH
39231: LD_VAR 0 2
39235: ARRAY
39236: PPUSH
39237: LD_INT 25
39239: PUSH
39240: LD_INT 12
39242: PUSH
39243: EMPTY
39244: LIST
39245: LIST
39246: PPUSH
39247: CALL_OW 72
39251: NOT
39252: OR
39253: IFFALSE 39257
// continue ;
39255: GO 39211
// side := GetSide ( mc_ape [ i ] [ 1 ] ) ;
39257: LD_ADDR_VAR 0 5
39261: PUSH
39262: LD_EXP 103
39266: PUSH
39267: LD_VAR 0 2
39271: ARRAY
39272: PUSH
39273: LD_INT 1
39275: ARRAY
39276: PPUSH
39277: CALL_OW 255
39281: ST_TO_ADDR
// if Researched ( side , tech_apepsych ) then
39282: LD_VAR 0 5
39286: PPUSH
39287: LD_INT 2
39289: PPUSH
39290: CALL_OW 325
39294: IFFALSE 39547
// begin tmp := UnitFilter ( mc_ape [ i ] , [ f_class , 16 ] ) ;
39296: LD_ADDR_VAR 0 4
39300: PUSH
39301: LD_EXP 103
39305: PUSH
39306: LD_VAR 0 2
39310: ARRAY
39311: PPUSH
39312: LD_INT 25
39314: PUSH
39315: LD_INT 16
39317: PUSH
39318: EMPTY
39319: LIST
39320: LIST
39321: PPUSH
39322: CALL_OW 72
39326: ST_TO_ADDR
// if tmp < 6 then
39327: LD_VAR 0 4
39331: PUSH
39332: LD_INT 6
39334: LESS
39335: IFFALSE 39547
// begin depot := UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) ;
39337: LD_ADDR_VAR 0 6
39341: PUSH
39342: LD_EXP 74
39346: PUSH
39347: LD_VAR 0 2
39351: ARRAY
39352: PPUSH
39353: LD_INT 2
39355: PUSH
39356: LD_INT 30
39358: PUSH
39359: LD_INT 0
39361: PUSH
39362: EMPTY
39363: LIST
39364: LIST
39365: PUSH
39366: LD_INT 30
39368: PUSH
39369: LD_INT 1
39371: PUSH
39372: EMPTY
39373: LIST
39374: LIST
39375: PUSH
39376: EMPTY
39377: LIST
39378: LIST
39379: LIST
39380: PPUSH
39381: CALL_OW 72
39385: ST_TO_ADDR
// if depot then
39386: LD_VAR 0 6
39390: IFFALSE 39547
// begin selected := 0 ;
39392: LD_ADDR_VAR 0 7
39396: PUSH
39397: LD_INT 0
39399: ST_TO_ADDR
// for j in depot do
39400: LD_ADDR_VAR 0 3
39404: PUSH
39405: LD_VAR 0 6
39409: PUSH
39410: FOR_IN
39411: IFFALSE 39442
// begin if UnitsInside ( j ) < 6 then
39413: LD_VAR 0 3
39417: PPUSH
39418: CALL_OW 313
39422: PUSH
39423: LD_INT 6
39425: LESS
39426: IFFALSE 39440
// begin selected := j ;
39428: LD_ADDR_VAR 0 7
39432: PUSH
39433: LD_VAR 0 3
39437: ST_TO_ADDR
// break ;
39438: GO 39442
// end ; end ;
39440: GO 39410
39442: POP
39443: POP
// if selected then
39444: LD_VAR 0 7
39448: IFFALSE 39547
// begin for j in UnitFilter ( mc_ape [ i ] , [ f_class , 12 ] ) do
39450: LD_ADDR_VAR 0 3
39454: PUSH
39455: LD_EXP 103
39459: PUSH
39460: LD_VAR 0 2
39464: ARRAY
39465: PPUSH
39466: LD_INT 25
39468: PUSH
39469: LD_INT 12
39471: PUSH
39472: EMPTY
39473: LIST
39474: LIST
39475: PPUSH
39476: CALL_OW 72
39480: PUSH
39481: FOR_IN
39482: IFFALSE 39545
// if not HasTask ( j ) then
39484: LD_VAR 0 3
39488: PPUSH
39489: CALL_OW 314
39493: NOT
39494: IFFALSE 39543
// begin if not IsInUnit ( j ) then
39496: LD_VAR 0 3
39500: PPUSH
39501: CALL_OW 310
39505: NOT
39506: IFFALSE 39522
// ComEnterUnit ( j , selected ) ;
39508: LD_VAR 0 3
39512: PPUSH
39513: LD_VAR 0 7
39517: PPUSH
39518: CALL_OW 120
// AddComChangeProfession ( j , 16 ) ;
39522: LD_VAR 0 3
39526: PPUSH
39527: LD_INT 16
39529: PPUSH
39530: CALL_OW 183
// AddComExitBuilding ( j ) ;
39534: LD_VAR 0 3
39538: PPUSH
39539: CALL_OW 182
// end ;
39543: GO 39481
39545: POP
39546: POP
// end ; end ; end ; end ; if Researched ( side , tech_apeagres ) then
39547: LD_VAR 0 5
39551: PPUSH
39552: LD_INT 11
39554: PPUSH
39555: CALL_OW 325
39559: IFFALSE 39818
// begin tmp := UnitFilter ( mc_ape [ i ] , [ f_class , 16 ] ) ;
39561: LD_ADDR_VAR 0 4
39565: PUSH
39566: LD_EXP 103
39570: PUSH
39571: LD_VAR 0 2
39575: ARRAY
39576: PPUSH
39577: LD_INT 25
39579: PUSH
39580: LD_INT 16
39582: PUSH
39583: EMPTY
39584: LIST
39585: LIST
39586: PPUSH
39587: CALL_OW 72
39591: ST_TO_ADDR
// if tmp >= 6 or not Researched ( side , tech_apepsych ) then
39592: LD_VAR 0 4
39596: PUSH
39597: LD_INT 6
39599: GREATEREQUAL
39600: PUSH
39601: LD_VAR 0 5
39605: PPUSH
39606: LD_INT 2
39608: PPUSH
39609: CALL_OW 325
39613: NOT
39614: OR
39615: IFFALSE 39818
// begin barracks := UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_armoury ] , [ f_btype , b_barracks ] ] ) ;
39617: LD_ADDR_VAR 0 8
39621: PUSH
39622: LD_EXP 74
39626: PUSH
39627: LD_VAR 0 2
39631: ARRAY
39632: PPUSH
39633: LD_INT 2
39635: PUSH
39636: LD_INT 30
39638: PUSH
39639: LD_INT 4
39641: PUSH
39642: EMPTY
39643: LIST
39644: LIST
39645: PUSH
39646: LD_INT 30
39648: PUSH
39649: LD_INT 5
39651: PUSH
39652: EMPTY
39653: LIST
39654: LIST
39655: PUSH
39656: EMPTY
39657: LIST
39658: LIST
39659: LIST
39660: PPUSH
39661: CALL_OW 72
39665: ST_TO_ADDR
// if barracks then
39666: LD_VAR 0 8
39670: IFFALSE 39818
// begin selected := 0 ;
39672: LD_ADDR_VAR 0 7
39676: PUSH
39677: LD_INT 0
39679: ST_TO_ADDR
// for j in barracks do
39680: LD_ADDR_VAR 0 3
39684: PUSH
39685: LD_VAR 0 8
39689: PUSH
39690: FOR_IN
39691: IFFALSE 39722
// begin if UnitsInside ( j ) < 6 then
39693: LD_VAR 0 3
39697: PPUSH
39698: CALL_OW 313
39702: PUSH
39703: LD_INT 6
39705: LESS
39706: IFFALSE 39720
// begin selected := j ;
39708: LD_ADDR_VAR 0 7
39712: PUSH
39713: LD_VAR 0 3
39717: ST_TO_ADDR
// break ;
39718: GO 39722
// end ; end ;
39720: GO 39690
39722: POP
39723: POP
// if selected then
39724: LD_VAR 0 7
39728: IFFALSE 39818
// begin for j in UnitFilter ( mc_ape [ i ] , [ f_class , 12 ] ) do
39730: LD_ADDR_VAR 0 3
39734: PUSH
39735: LD_EXP 103
39739: PUSH
39740: LD_VAR 0 2
39744: ARRAY
39745: PPUSH
39746: LD_INT 25
39748: PUSH
39749: LD_INT 12
39751: PUSH
39752: EMPTY
39753: LIST
39754: LIST
39755: PPUSH
39756: CALL_OW 72
39760: PUSH
39761: FOR_IN
39762: IFFALSE 39816
// if not IsInUnit ( j ) and not HasTask ( j ) then
39764: LD_VAR 0 3
39768: PPUSH
39769: CALL_OW 310
39773: NOT
39774: PUSH
39775: LD_VAR 0 3
39779: PPUSH
39780: CALL_OW 314
39784: NOT
39785: AND
39786: IFFALSE 39814
// begin ComEnterUnit ( j , selected ) ;
39788: LD_VAR 0 3
39792: PPUSH
39793: LD_VAR 0 7
39797: PPUSH
39798: CALL_OW 120
// AddComChangeProfession ( j , 15 ) ;
39802: LD_VAR 0 3
39806: PPUSH
39807: LD_INT 15
39809: PPUSH
39810: CALL_OW 183
// end ;
39814: GO 39761
39816: POP
39817: POP
// end ; end ; end ; end ; end ;
39818: GO 39211
39820: POP
39821: POP
// end ;
39822: LD_VAR 0 1
39826: RET
// export function MC_Bazooka ( ) ; var i , j , tmp ; begin
39827: LD_INT 0
39829: PPUSH
39830: PPUSH
39831: PPUSH
39832: PPUSH
// if not mc_bases then
39833: LD_EXP 74
39837: NOT
39838: IFFALSE 39842
// exit ;
39840: GO 40020
// for i = 1 to mc_bases do
39842: LD_ADDR_VAR 0 2
39846: PUSH
39847: DOUBLE
39848: LD_INT 1
39850: DEC
39851: ST_TO_ADDR
39852: LD_EXP 74
39856: PUSH
39857: FOR_TO
39858: IFFALSE 40018
// begin tmp := UnitFilter ( mc_bases [ i ] , [ f_class , class_bazooker ] ) ;
39860: LD_ADDR_VAR 0 4
39864: PUSH
39865: LD_EXP 74
39869: PUSH
39870: LD_VAR 0 2
39874: ARRAY
39875: PPUSH
39876: LD_INT 25
39878: PUSH
39879: LD_INT 9
39881: PUSH
39882: EMPTY
39883: LIST
39884: LIST
39885: PPUSH
39886: CALL_OW 72
39890: ST_TO_ADDR
// if not tmp then
39891: LD_VAR 0 4
39895: NOT
39896: IFFALSE 39900
// continue ;
39898: GO 39857
// if not Researched ( mc_sides [ i ] , tech_spacanom ) and not Researched ( mc_sides [ i ] , tech_taurad ) then
39900: LD_EXP 100
39904: PUSH
39905: LD_VAR 0 2
39909: ARRAY
39910: PPUSH
39911: LD_INT 29
39913: PPUSH
39914: CALL_OW 325
39918: NOT
39919: PUSH
39920: LD_EXP 100
39924: PUSH
39925: LD_VAR 0 2
39929: ARRAY
39930: PPUSH
39931: LD_INT 28
39933: PPUSH
39934: CALL_OW 325
39938: NOT
39939: AND
39940: IFFALSE 39944
// continue ;
39942: GO 39857
// for j in tmp do
39944: LD_ADDR_VAR 0 3
39948: PUSH
39949: LD_VAR 0 4
39953: PUSH
39954: FOR_IN
39955: IFFALSE 40014
// if not j in mc_need_heal [ i ] [ 1 ] and not j in mc_need_heal [ i ] [ 2 ] then
39957: LD_VAR 0 3
39961: PUSH
39962: LD_EXP 77
39966: PUSH
39967: LD_VAR 0 2
39971: ARRAY
39972: PUSH
39973: LD_INT 1
39975: ARRAY
39976: IN
39977: NOT
39978: PUSH
39979: LD_VAR 0 3
39983: PUSH
39984: LD_EXP 77
39988: PUSH
39989: LD_VAR 0 2
39993: ARRAY
39994: PUSH
39995: LD_INT 2
39997: ARRAY
39998: IN
39999: NOT
40000: AND
40001: IFFALSE 40012
// ComSpaceTimeShoot ( j ) ;
40003: LD_VAR 0 3
40007: PPUSH
40008: CALL 50688 0 1
40012: GO 39954
40014: POP
40015: POP
// end ;
40016: GO 39857
40018: POP
40019: POP
// end ;
40020: LD_VAR 0 1
40024: RET
// export function MC_TeleportExit ( ) ; var i , j , x , y , save_point , tmp , teleports , sci ; begin
40025: LD_INT 0
40027: PPUSH
40028: PPUSH
40029: PPUSH
40030: PPUSH
40031: PPUSH
40032: PPUSH
40033: PPUSH
40034: PPUSH
40035: PPUSH
// if not mc_bases then
40036: LD_EXP 74
40040: NOT
40041: IFFALSE 40045
// exit ;
40043: GO 40667
// for i = 1 to mc_bases do
40045: LD_ADDR_VAR 0 2
40049: PUSH
40050: DOUBLE
40051: LD_INT 1
40053: DEC
40054: ST_TO_ADDR
40055: LD_EXP 74
40059: PUSH
40060: FOR_TO
40061: IFFALSE 40665
// begin if not mc_teleport_exit [ i ] or GetTech ( tech_targTeleport , mc_sides [ i ] ) <> state_researched then
40063: LD_EXP 109
40067: PUSH
40068: LD_VAR 0 2
40072: ARRAY
40073: NOT
40074: PUSH
40075: LD_INT 38
40077: PPUSH
40078: LD_EXP 100
40082: PUSH
40083: LD_VAR 0 2
40087: ARRAY
40088: PPUSH
40089: CALL_OW 321
40093: PUSH
40094: LD_INT 2
40096: NONEQUAL
40097: OR
40098: IFFALSE 40102
// continue ;
40100: GO 40060
// teleports := UnitFilter ( mc_bases [ i ] , [ f_btype , b_teleport ] ) ;
40102: LD_ADDR_VAR 0 8
40106: PUSH
40107: LD_EXP 74
40111: PUSH
40112: LD_VAR 0 2
40116: ARRAY
40117: PPUSH
40118: LD_INT 30
40120: PUSH
40121: LD_INT 34
40123: PUSH
40124: EMPTY
40125: LIST
40126: LIST
40127: PPUSH
40128: CALL_OW 72
40132: ST_TO_ADDR
// sci := FilterByTag ( UnitFilter ( mc_bases [ i ] , [ f_class , 4 ] ) , 0 ) ;
40133: LD_ADDR_VAR 0 9
40137: PUSH
40138: LD_EXP 74
40142: PUSH
40143: LD_VAR 0 2
40147: ARRAY
40148: PPUSH
40149: LD_INT 25
40151: PUSH
40152: LD_INT 4
40154: PUSH
40155: EMPTY
40156: LIST
40157: LIST
40158: PPUSH
40159: CALL_OW 72
40163: PPUSH
40164: LD_INT 0
40166: PPUSH
40167: CALL 90213 0 2
40171: ST_TO_ADDR
// if not sci or not teleports or FilterByTag ( mc_bases [ i ] , 124 ) then
40172: LD_VAR 0 9
40176: NOT
40177: PUSH
40178: LD_VAR 0 8
40182: NOT
40183: OR
40184: PUSH
40185: LD_EXP 74
40189: PUSH
40190: LD_VAR 0 2
40194: ARRAY
40195: PPUSH
40196: LD_INT 124
40198: PPUSH
40199: CALL 90213 0 2
40203: OR
40204: IFFALSE 40208
// continue ;
40206: GO 40060
// if mc_teleport_exit_set [ i ] < mc_teleport_exit [ i ] and mc_teleport_exit_set [ i ] < teleports then
40208: LD_EXP 110
40212: PUSH
40213: LD_VAR 0 2
40217: ARRAY
40218: PUSH
40219: LD_EXP 109
40223: PUSH
40224: LD_VAR 0 2
40228: ARRAY
40229: LESS
40230: PUSH
40231: LD_EXP 110
40235: PUSH
40236: LD_VAR 0 2
40240: ARRAY
40241: PUSH
40242: LD_VAR 0 8
40246: LESS
40247: AND
40248: IFFALSE 40663
// begin tmp := sci [ 1 ] ;
40250: LD_ADDR_VAR 0 7
40254: PUSH
40255: LD_VAR 0 9
40259: PUSH
40260: LD_INT 1
40262: ARRAY
40263: ST_TO_ADDR
// SetTag ( tmp , 124 ) ;
40264: LD_VAR 0 7
40268: PPUSH
40269: LD_INT 124
40271: PPUSH
40272: CALL_OW 109
// for j = mc_teleport_exit [ i ] downto mc_teleport_exit [ i ] do
40276: LD_ADDR_VAR 0 3
40280: PUSH
40281: DOUBLE
40282: LD_EXP 109
40286: PUSH
40287: LD_VAR 0 2
40291: ARRAY
40292: INC
40293: ST_TO_ADDR
40294: LD_EXP 109
40298: PUSH
40299: LD_VAR 0 2
40303: ARRAY
40304: PUSH
40305: FOR_DOWNTO
40306: IFFALSE 40649
// begin if IsInUnit ( tmp ) then
40308: LD_VAR 0 7
40312: PPUSH
40313: CALL_OW 310
40317: IFFALSE 40328
// ComExitBuilding ( tmp ) ;
40319: LD_VAR 0 7
40323: PPUSH
40324: CALL_OW 122
// repeat wait ( 0 0$1 ) ;
40328: LD_INT 35
40330: PPUSH
40331: CALL_OW 67
// until not IsInUnit ( tmp ) and not HasTask ( tmp ) ;
40335: LD_VAR 0 7
40339: PPUSH
40340: CALL_OW 310
40344: NOT
40345: PUSH
40346: LD_VAR 0 7
40350: PPUSH
40351: CALL_OW 314
40355: NOT
40356: AND
40357: IFFALSE 40328
// save_point := [ GetX ( tmp ) , GetY ( tmp ) ] ;
40359: LD_ADDR_VAR 0 6
40363: PUSH
40364: LD_VAR 0 7
40368: PPUSH
40369: CALL_OW 250
40373: PUSH
40374: LD_VAR 0 7
40378: PPUSH
40379: CALL_OW 251
40383: PUSH
40384: EMPTY
40385: LIST
40386: LIST
40387: ST_TO_ADDR
// repeat wait ( 0 0$1 ) ;
40388: LD_INT 35
40390: PPUSH
40391: CALL_OW 67
// x := mc_teleport_exit [ i ] [ j ] [ 1 ] ;
40395: LD_ADDR_VAR 0 4
40399: PUSH
40400: LD_EXP 109
40404: PUSH
40405: LD_VAR 0 2
40409: ARRAY
40410: PUSH
40411: LD_VAR 0 3
40415: ARRAY
40416: PUSH
40417: LD_INT 1
40419: ARRAY
40420: ST_TO_ADDR
// y := mc_teleport_exit [ i ] [ j ] [ 2 ] ;
40421: LD_ADDR_VAR 0 5
40425: PUSH
40426: LD_EXP 109
40430: PUSH
40431: LD_VAR 0 2
40435: ARRAY
40436: PUSH
40437: LD_VAR 0 3
40441: ARRAY
40442: PUSH
40443: LD_INT 2
40445: ARRAY
40446: ST_TO_ADDR
// if DangerAtRange ( tmp , 10 ) [ 4 ] then
40447: LD_VAR 0 7
40451: PPUSH
40452: LD_INT 10
40454: PPUSH
40455: CALL 59546 0 2
40459: PUSH
40460: LD_INT 4
40462: ARRAY
40463: IFFALSE 40501
// begin ComMoveXY ( tmp , save_point [ 1 ] , save_point [ 2 ] ) ;
40465: LD_VAR 0 7
40469: PPUSH
40470: LD_VAR 0 6
40474: PUSH
40475: LD_INT 1
40477: ARRAY
40478: PPUSH
40479: LD_VAR 0 6
40483: PUSH
40484: LD_INT 2
40486: ARRAY
40487: PPUSH
40488: CALL_OW 111
// wait ( 0 0$10 ) ;
40492: LD_INT 350
40494: PPUSH
40495: CALL_OW 67
// end else
40499: GO 40527
// begin ComMoveXY ( tmp , x , y ) ;
40501: LD_VAR 0 7
40505: PPUSH
40506: LD_VAR 0 4
40510: PPUSH
40511: LD_VAR 0 5
40515: PPUSH
40516: CALL_OW 111
// wait ( 0 0$3 ) ;
40520: LD_INT 105
40522: PPUSH
40523: CALL_OW 67
// end ; until IsAt ( tmp , x , y ) ;
40527: LD_VAR 0 7
40531: PPUSH
40532: LD_VAR 0 4
40536: PPUSH
40537: LD_VAR 0 5
40541: PPUSH
40542: CALL_OW 307
40546: IFFALSE 40388
// ComTeleportExit ( tmp , x , y , teleports [ j ] ) ;
40548: LD_VAR 0 7
40552: PPUSH
40553: LD_VAR 0 4
40557: PPUSH
40558: LD_VAR 0 5
40562: PPUSH
40563: LD_VAR 0 8
40567: PUSH
40568: LD_VAR 0 3
40572: ARRAY
40573: PPUSH
40574: CALL_OW 156
// repeat wait ( 0 0$1 ) ;
40578: LD_INT 35
40580: PPUSH
40581: CALL_OW 67
// until not HasTask ( tmp ) ;
40585: LD_VAR 0 7
40589: PPUSH
40590: CALL_OW 314
40594: NOT
40595: IFFALSE 40578
// mc_teleport_exit_set := ReplaceIn ( mc_teleport_exit_set , [ i , mc_teleport_exit_set [ i ] + 1 ] , teleports [ j ] ) ;
40597: LD_ADDR_EXP 110
40601: PUSH
40602: LD_EXP 110
40606: PPUSH
40607: LD_VAR 0 2
40611: PUSH
40612: LD_EXP 110
40616: PUSH
40617: LD_VAR 0 2
40621: ARRAY
40622: PUSH
40623: LD_INT 1
40625: PLUS
40626: PUSH
40627: EMPTY
40628: LIST
40629: LIST
40630: PPUSH
40631: LD_VAR 0 8
40635: PUSH
40636: LD_VAR 0 3
40640: ARRAY
40641: PPUSH
40642: CALL 56953 0 3
40646: ST_TO_ADDR
// end ;
40647: GO 40305
40649: POP
40650: POP
// MC_Reset ( i , 124 ) ;
40651: LD_VAR 0 2
40655: PPUSH
40656: LD_INT 124
40658: PPUSH
40659: CALL 24150 0 2
// end ; end ;
40663: GO 40060
40665: POP
40666: POP
// end ;
40667: LD_VAR 0 1
40671: RET
// export function MC_Deposits ( ) ; var i , tmp ; begin
40672: LD_INT 0
40674: PPUSH
40675: PPUSH
40676: PPUSH
// if not mc_bases then
40677: LD_EXP 74
40681: NOT
40682: IFFALSE 40686
// exit ;
40684: GO 41292
// for i = 1 to mc_bases do
40686: LD_ADDR_VAR 0 2
40690: PUSH
40691: DOUBLE
40692: LD_INT 1
40694: DEC
40695: ST_TO_ADDR
40696: LD_EXP 74
40700: PUSH
40701: FOR_TO
40702: IFFALSE 41290
// begin tmp := UnitFilter ( mc_bases [ i ] , [ f_class , 4 ] ) ;
40704: LD_ADDR_VAR 0 3
40708: PUSH
40709: LD_EXP 74
40713: PUSH
40714: LD_VAR 0 2
40718: ARRAY
40719: PPUSH
40720: LD_INT 25
40722: PUSH
40723: LD_INT 4
40725: PUSH
40726: EMPTY
40727: LIST
40728: LIST
40729: PPUSH
40730: CALL_OW 72
40734: ST_TO_ADDR
// if not tmp or not mc_deposits_xy [ i ] or not UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) then
40735: LD_VAR 0 3
40739: NOT
40740: PUSH
40741: LD_EXP 111
40745: PUSH
40746: LD_VAR 0 2
40750: ARRAY
40751: NOT
40752: OR
40753: PUSH
40754: LD_EXP 74
40758: PUSH
40759: LD_VAR 0 2
40763: ARRAY
40764: PPUSH
40765: LD_INT 2
40767: PUSH
40768: LD_INT 30
40770: PUSH
40771: LD_INT 0
40773: PUSH
40774: EMPTY
40775: LIST
40776: LIST
40777: PUSH
40778: LD_INT 30
40780: PUSH
40781: LD_INT 1
40783: PUSH
40784: EMPTY
40785: LIST
40786: LIST
40787: PUSH
40788: EMPTY
40789: LIST
40790: LIST
40791: LIST
40792: PPUSH
40793: CALL_OW 72
40797: NOT
40798: OR
40799: IFFALSE 40849
// begin if mc_deposits_finder [ i ] then
40801: LD_EXP 112
40805: PUSH
40806: LD_VAR 0 2
40810: ARRAY
40811: IFFALSE 40847
// begin MC_Reset ( i , 125 ) ;
40813: LD_VAR 0 2
40817: PPUSH
40818: LD_INT 125
40820: PPUSH
40821: CALL 24150 0 2
// mc_deposits_finder := Replace ( mc_deposits_finder , i , [ ] ) ;
40825: LD_ADDR_EXP 112
40829: PUSH
40830: LD_EXP 112
40834: PPUSH
40835: LD_VAR 0 2
40839: PPUSH
40840: EMPTY
40841: PPUSH
40842: CALL_OW 1
40846: ST_TO_ADDR
// end ; continue ;
40847: GO 40701
// end ; if mc_deposits_xy [ i ] [ 1 ] [ 3 ] = 1 and GetTech ( tech_sibdet , mc_sides [ i ] ) <> state_researched then
40849: LD_EXP 111
40853: PUSH
40854: LD_VAR 0 2
40858: ARRAY
40859: PUSH
40860: LD_INT 1
40862: ARRAY
40863: PUSH
40864: LD_INT 3
40866: ARRAY
40867: PUSH
40868: LD_INT 1
40870: EQUAL
40871: PUSH
40872: LD_INT 20
40874: PPUSH
40875: LD_EXP 100
40879: PUSH
40880: LD_VAR 0 2
40884: ARRAY
40885: PPUSH
40886: CALL_OW 321
40890: PUSH
40891: LD_INT 2
40893: NONEQUAL
40894: AND
40895: IFFALSE 40945
// begin if mc_deposits_finder [ i ] then
40897: LD_EXP 112
40901: PUSH
40902: LD_VAR 0 2
40906: ARRAY
40907: IFFALSE 40943
// begin MC_Reset ( i , 125 ) ;
40909: LD_VAR 0 2
40913: PPUSH
40914: LD_INT 125
40916: PPUSH
40917: CALL 24150 0 2
// mc_deposits_finder := Replace ( mc_deposits_finder , i , [ ] ) ;
40921: LD_ADDR_EXP 112
40925: PUSH
40926: LD_EXP 112
40930: PPUSH
40931: LD_VAR 0 2
40935: PPUSH
40936: EMPTY
40937: PPUSH
40938: CALL_OW 1
40942: ST_TO_ADDR
// end ; continue ;
40943: GO 40701
// end ; if GetResourceVisibility ( mc_deposits_xy [ i ] [ 1 ] [ 1 ] , mc_deposits_xy [ i ] [ 1 ] [ 2 ] , mc_sides [ i ] ) then
40945: LD_EXP 111
40949: PUSH
40950: LD_VAR 0 2
40954: ARRAY
40955: PUSH
40956: LD_INT 1
40958: ARRAY
40959: PUSH
40960: LD_INT 1
40962: ARRAY
40963: PPUSH
40964: LD_EXP 111
40968: PUSH
40969: LD_VAR 0 2
40973: ARRAY
40974: PUSH
40975: LD_INT 1
40977: ARRAY
40978: PUSH
40979: LD_INT 2
40981: ARRAY
40982: PPUSH
40983: LD_EXP 100
40987: PUSH
40988: LD_VAR 0 2
40992: ARRAY
40993: PPUSH
40994: CALL_OW 440
40998: IFFALSE 41041
// mc_deposits_xy := Replace ( mc_deposits_xy , i , Delete ( mc_deposits_xy [ i ] , 1 ) ) else
41000: LD_ADDR_EXP 111
41004: PUSH
41005: LD_EXP 111
41009: PPUSH
41010: LD_VAR 0 2
41014: PPUSH
41015: LD_EXP 111
41019: PUSH
41020: LD_VAR 0 2
41024: ARRAY
41025: PPUSH
41026: LD_INT 1
41028: PPUSH
41029: CALL_OW 3
41033: PPUSH
41034: CALL_OW 1
41038: ST_TO_ADDR
41039: GO 41288
// begin if not mc_deposits_finder [ i ] then
41041: LD_EXP 112
41045: PUSH
41046: LD_VAR 0 2
41050: ARRAY
41051: NOT
41052: IFFALSE 41104
// begin mc_deposits_finder := Replace ( mc_deposits_finder , i , [ tmp [ 1 ] ] ) ;
41054: LD_ADDR_EXP 112
41058: PUSH
41059: LD_EXP 112
41063: PPUSH
41064: LD_VAR 0 2
41068: PPUSH
41069: LD_VAR 0 3
41073: PUSH
41074: LD_INT 1
41076: ARRAY
41077: PUSH
41078: EMPTY
41079: LIST
41080: PPUSH
41081: CALL_OW 1
41085: ST_TO_ADDR
// SetTag ( tmp [ 1 ] , 125 ) ;
41086: LD_VAR 0 3
41090: PUSH
41091: LD_INT 1
41093: ARRAY
41094: PPUSH
41095: LD_INT 125
41097: PPUSH
41098: CALL_OW 109
// end else
41102: GO 41288
// begin if IsInUnit ( mc_deposits_finder [ i ] [ 1 ] ) then
41104: LD_EXP 112
41108: PUSH
41109: LD_VAR 0 2
41113: ARRAY
41114: PUSH
41115: LD_INT 1
41117: ARRAY
41118: PPUSH
41119: CALL_OW 310
41123: IFFALSE 41146
// ComExitBuilding ( mc_deposits_finder [ i ] [ 1 ] ) else
41125: LD_EXP 112
41129: PUSH
41130: LD_VAR 0 2
41134: ARRAY
41135: PUSH
41136: LD_INT 1
41138: ARRAY
41139: PPUSH
41140: CALL_OW 122
41144: GO 41288
// if not HasTask ( mc_deposits_finder [ i ] [ 1 ] ) and GetDistUnitXY ( mc_deposits_finder [ i ] [ 1 ] , mc_deposits_xy [ i ] [ 1 ] [ 1 ] , mc_deposits_xy [ i ] [ 1 ] [ 2 ] ) > 6 then
41146: LD_EXP 112
41150: PUSH
41151: LD_VAR 0 2
41155: ARRAY
41156: PUSH
41157: LD_INT 1
41159: ARRAY
41160: PPUSH
41161: CALL_OW 314
41165: NOT
41166: PUSH
41167: LD_EXP 112
41171: PUSH
41172: LD_VAR 0 2
41176: ARRAY
41177: PUSH
41178: LD_INT 1
41180: ARRAY
41181: PPUSH
41182: LD_EXP 111
41186: PUSH
41187: LD_VAR 0 2
41191: ARRAY
41192: PUSH
41193: LD_INT 1
41195: ARRAY
41196: PUSH
41197: LD_INT 1
41199: ARRAY
41200: PPUSH
41201: LD_EXP 111
41205: PUSH
41206: LD_VAR 0 2
41210: ARRAY
41211: PUSH
41212: LD_INT 1
41214: ARRAY
41215: PUSH
41216: LD_INT 2
41218: ARRAY
41219: PPUSH
41220: CALL_OW 297
41224: PUSH
41225: LD_INT 6
41227: GREATER
41228: AND
41229: IFFALSE 41288
// ComMoveXY ( mc_deposits_finder [ i ] [ 1 ] , mc_deposits_xy [ i ] [ 1 ] [ 1 ] , mc_deposits_xy [ i ] [ 1 ] [ 2 ] ) ;
41231: LD_EXP 112
41235: PUSH
41236: LD_VAR 0 2
41240: ARRAY
41241: PUSH
41242: LD_INT 1
41244: ARRAY
41245: PPUSH
41246: LD_EXP 111
41250: PUSH
41251: LD_VAR 0 2
41255: ARRAY
41256: PUSH
41257: LD_INT 1
41259: ARRAY
41260: PUSH
41261: LD_INT 1
41263: ARRAY
41264: PPUSH
41265: LD_EXP 111
41269: PUSH
41270: LD_VAR 0 2
41274: ARRAY
41275: PUSH
41276: LD_INT 1
41278: ARRAY
41279: PUSH
41280: LD_INT 2
41282: ARRAY
41283: PPUSH
41284: CALL_OW 111
// end ; end ; end ;
41288: GO 40701
41290: POP
41291: POP
// end ;
41292: LD_VAR 0 1
41296: RET
// export function MC_RemoteDriver ( ) ; var i , j , k , places , tmp , nation , ct , cts , mcts , x ; begin
41297: LD_INT 0
41299: PPUSH
41300: PPUSH
41301: PPUSH
41302: PPUSH
41303: PPUSH
41304: PPUSH
41305: PPUSH
41306: PPUSH
41307: PPUSH
41308: PPUSH
41309: PPUSH
// if not mc_bases then
41310: LD_EXP 74
41314: NOT
41315: IFFALSE 41319
// exit ;
41317: GO 42043
// for i = 1 to mc_bases do
41319: LD_ADDR_VAR 0 2
41323: PUSH
41324: DOUBLE
41325: LD_INT 1
41327: DEC
41328: ST_TO_ADDR
41329: LD_EXP 74
41333: PUSH
41334: FOR_TO
41335: IFFALSE 42041
// begin if not mc_bases [ i ] then
41337: LD_EXP 74
41341: PUSH
41342: LD_VAR 0 2
41346: ARRAY
41347: NOT
41348: IFFALSE 41352
// continue ;
41350: GO 41334
// nation := GetNation ( mc_bases [ i ] [ 1 ] ) ;
41352: LD_ADDR_VAR 0 7
41356: PUSH
41357: LD_EXP 74
41361: PUSH
41362: LD_VAR 0 2
41366: ARRAY
41367: PUSH
41368: LD_INT 1
41370: ARRAY
41371: PPUSH
41372: CALL_OW 248
41376: ST_TO_ADDR
// if nation = 3 or not UnitFilter ( mc_vehicles [ i ] union mc_defender [ i ] , [ f_control , control_remote ] ) then
41377: LD_VAR 0 7
41381: PUSH
41382: LD_INT 3
41384: EQUAL
41385: PUSH
41386: LD_EXP 93
41390: PUSH
41391: LD_VAR 0 2
41395: ARRAY
41396: PUSH
41397: LD_EXP 96
41401: PUSH
41402: LD_VAR 0 2
41406: ARRAY
41407: UNION
41408: PPUSH
41409: LD_INT 33
41411: PUSH
41412: LD_INT 2
41414: PUSH
41415: EMPTY
41416: LIST
41417: LIST
41418: PPUSH
41419: CALL_OW 72
41423: NOT
41424: OR
41425: IFFALSE 41429
// continue ;
41427: GO 41334
// cts := UnitFilter ( mc_bases [ i ] , [ f_btype , b_control_tower ] ) ;
41429: LD_ADDR_VAR 0 9
41433: PUSH
41434: LD_EXP 74
41438: PUSH
41439: LD_VAR 0 2
41443: ARRAY
41444: PPUSH
41445: LD_INT 30
41447: PUSH
41448: LD_INT 36
41450: PUSH
41451: EMPTY
41452: LIST
41453: LIST
41454: PPUSH
41455: CALL_OW 72
41459: ST_TO_ADDR
// mcts := UnitFilter ( mc_vehicles [ i ] , [ f_weapon , ar_control_tower ] ) ;
41460: LD_ADDR_VAR 0 10
41464: PUSH
41465: LD_EXP 93
41469: PUSH
41470: LD_VAR 0 2
41474: ARRAY
41475: PPUSH
41476: LD_INT 34
41478: PUSH
41479: LD_INT 31
41481: PUSH
41482: EMPTY
41483: LIST
41484: LIST
41485: PPUSH
41486: CALL_OW 72
41490: ST_TO_ADDR
// if not cts and not mcts then
41491: LD_VAR 0 9
41495: NOT
41496: PUSH
41497: LD_VAR 0 10
41501: NOT
41502: AND
41503: IFFALSE 41507
// continue ;
41505: GO 41334
// x := cts ;
41507: LD_ADDR_VAR 0 11
41511: PUSH
41512: LD_VAR 0 9
41516: ST_TO_ADDR
// if not x then
41517: LD_VAR 0 11
41521: NOT
41522: IFFALSE 41534
// x := mcts ;
41524: LD_ADDR_VAR 0 11
41528: PUSH
41529: LD_VAR 0 10
41533: ST_TO_ADDR
// if mc_remote_driver [ i ] then
41534: LD_EXP 114
41538: PUSH
41539: LD_VAR 0 2
41543: ARRAY
41544: IFFALSE 41813
// for j in mc_remote_driver [ i ] do
41546: LD_ADDR_VAR 0 3
41550: PUSH
41551: LD_EXP 114
41555: PUSH
41556: LD_VAR 0 2
41560: ARRAY
41561: PUSH
41562: FOR_IN
41563: IFFALSE 41811
// begin if GetClass ( j ) <> 3 then
41565: LD_VAR 0 3
41569: PPUSH
41570: CALL_OW 257
41574: PUSH
41575: LD_INT 3
41577: NONEQUAL
41578: IFFALSE 41631
// begin mc_remote_driver := Replace ( mc_remote_driver , i , mc_remote_driver [ i ] diff j ) ;
41580: LD_ADDR_EXP 114
41584: PUSH
41585: LD_EXP 114
41589: PPUSH
41590: LD_VAR 0 2
41594: PPUSH
41595: LD_EXP 114
41599: PUSH
41600: LD_VAR 0 2
41604: ARRAY
41605: PUSH
41606: LD_VAR 0 3
41610: DIFF
41611: PPUSH
41612: CALL_OW 1
41616: ST_TO_ADDR
// SetTag ( j , 0 ) ;
41617: LD_VAR 0 3
41621: PPUSH
41622: LD_INT 0
41624: PPUSH
41625: CALL_OW 109
// continue ;
41629: GO 41562
// end ; if not IsInUnit ( j ) or ( GetBType ( IsInUnit ( j ) ) <> b_control_tower and not IsDriver ( j ) ) then
41631: LD_VAR 0 3
41635: PPUSH
41636: CALL_OW 310
41640: NOT
41641: PUSH
41642: LD_VAR 0 3
41646: PPUSH
41647: CALL_OW 310
41651: PPUSH
41652: CALL_OW 266
41656: PUSH
41657: LD_INT 36
41659: NONEQUAL
41660: PUSH
41661: LD_VAR 0 3
41665: PPUSH
41666: CALL 90301 0 1
41670: NOT
41671: AND
41672: OR
41673: IFFALSE 41809
// begin if IsInUnit ( j ) then
41675: LD_VAR 0 3
41679: PPUSH
41680: CALL_OW 310
41684: IFFALSE 41695
// ComExitBuilding ( j ) ;
41686: LD_VAR 0 3
41690: PPUSH
41691: CALL_OW 122
// ct := 0 ;
41695: LD_ADDR_VAR 0 8
41699: PUSH
41700: LD_INT 0
41702: ST_TO_ADDR
// for k in x do
41703: LD_ADDR_VAR 0 4
41707: PUSH
41708: LD_VAR 0 11
41712: PUSH
41713: FOR_IN
41714: IFFALSE 41787
// if ( GetWeapon ( k ) = ar_control_tower and not IsDrivenBy ( k ) ) or ( GetBType ( k ) = b_control_tower and UnitsInside ( k ) < 3 ) then
41716: LD_VAR 0 4
41720: PPUSH
41721: CALL_OW 264
41725: PUSH
41726: LD_INT 31
41728: EQUAL
41729: PUSH
41730: LD_VAR 0 4
41734: PPUSH
41735: CALL_OW 311
41739: NOT
41740: AND
41741: PUSH
41742: LD_VAR 0 4
41746: PPUSH
41747: CALL_OW 266
41751: PUSH
41752: LD_INT 36
41754: EQUAL
41755: PUSH
41756: LD_VAR 0 4
41760: PPUSH
41761: CALL_OW 313
41765: PUSH
41766: LD_INT 3
41768: LESS
41769: AND
41770: OR
41771: IFFALSE 41785
// begin ct := k ;
41773: LD_ADDR_VAR 0 8
41777: PUSH
41778: LD_VAR 0 4
41782: ST_TO_ADDR
// break ;
41783: GO 41787
// end ;
41785: GO 41713
41787: POP
41788: POP
// if ct then
41789: LD_VAR 0 8
41793: IFFALSE 41809
// ComEnterUnit ( j , ct ) ;
41795: LD_VAR 0 3
41799: PPUSH
41800: LD_VAR 0 8
41804: PPUSH
41805: CALL_OW 120
// end ; end ;
41809: GO 41562
41811: POP
41812: POP
// places := 0 ;
41813: LD_ADDR_VAR 0 5
41817: PUSH
41818: LD_INT 0
41820: ST_TO_ADDR
// for j = 1 to x do
41821: LD_ADDR_VAR 0 3
41825: PUSH
41826: DOUBLE
41827: LD_INT 1
41829: DEC
41830: ST_TO_ADDR
41831: LD_VAR 0 11
41835: PUSH
41836: FOR_TO
41837: IFFALSE 41892
// if GetWeapon ( x [ j ] ) = ar_control_tower then
41839: LD_VAR 0 11
41843: PUSH
41844: LD_VAR 0 3
41848: ARRAY
41849: PPUSH
41850: CALL_OW 264
41854: PUSH
41855: LD_INT 31
41857: EQUAL
41858: IFFALSE 41876
// places := places + 1 else
41860: LD_ADDR_VAR 0 5
41864: PUSH
41865: LD_VAR 0 5
41869: PUSH
41870: LD_INT 1
41872: PLUS
41873: ST_TO_ADDR
41874: GO 41890
// places := places + 3 ;
41876: LD_ADDR_VAR 0 5
41880: PUSH
41881: LD_VAR 0 5
41885: PUSH
41886: LD_INT 3
41888: PLUS
41889: ST_TO_ADDR
41890: GO 41836
41892: POP
41893: POP
// tmp := SortBySkill ( UnitFilter ( mc_bases [ i ] , [ f_class , 3 ] ) diff mc_remote_driver [ i ] , 3 ) ;
41894: LD_ADDR_VAR 0 6
41898: PUSH
41899: LD_EXP 74
41903: PUSH
41904: LD_VAR 0 2
41908: ARRAY
41909: PPUSH
41910: LD_INT 25
41912: PUSH
41913: LD_INT 3
41915: PUSH
41916: EMPTY
41917: LIST
41918: LIST
41919: PPUSH
41920: CALL_OW 72
41924: PUSH
41925: LD_EXP 114
41929: PUSH
41930: LD_VAR 0 2
41934: ARRAY
41935: DIFF
41936: PPUSH
41937: LD_INT 3
41939: PPUSH
41940: CALL 91201 0 2
41944: ST_TO_ADDR
// if not tmp then
41945: LD_VAR 0 6
41949: NOT
41950: IFFALSE 41954
// continue ;
41952: GO 41334
// places := places - mc_remote_driver [ i ] ;
41954: LD_ADDR_VAR 0 5
41958: PUSH
41959: LD_VAR 0 5
41963: PUSH
41964: LD_EXP 114
41968: PUSH
41969: LD_VAR 0 2
41973: ARRAY
41974: MINUS
41975: ST_TO_ADDR
// if places then
41976: LD_VAR 0 5
41980: IFFALSE 42039
// begin mc_remote_driver := Replace ( mc_remote_driver , i , mc_remote_driver [ i ] union tmp [ 1 ] ) ;
41982: LD_ADDR_EXP 114
41986: PUSH
41987: LD_EXP 114
41991: PPUSH
41992: LD_VAR 0 2
41996: PPUSH
41997: LD_EXP 114
42001: PUSH
42002: LD_VAR 0 2
42006: ARRAY
42007: PUSH
42008: LD_VAR 0 6
42012: PUSH
42013: LD_INT 1
42015: ARRAY
42016: UNION
42017: PPUSH
42018: CALL_OW 1
42022: ST_TO_ADDR
// SetTag ( tmp [ 1 ] , 126 ) ;
42023: LD_VAR 0 6
42027: PUSH
42028: LD_INT 1
42030: ARRAY
42031: PPUSH
42032: LD_INT 126
42034: PPUSH
42035: CALL_OW 109
// end ; end ;
42039: GO 41334
42041: POP
42042: POP
// end ;
42043: LD_VAR 0 1
42047: RET
// export function MC_Back ( base , base_unit_list , unit , class ) ; var i , j , tmp , x , depot ; begin
42048: LD_INT 0
42050: PPUSH
42051: PPUSH
42052: PPUSH
42053: PPUSH
42054: PPUSH
42055: PPUSH
// if not base or not base_unit_list or not unit or not class in [ 1 , 2 , 3 , 4 , 5 , 8 , 9 , 15 , 16 ] then
42056: LD_VAR 0 1
42060: NOT
42061: PUSH
42062: LD_VAR 0 2
42066: NOT
42067: OR
42068: PUSH
42069: LD_VAR 0 3
42073: NOT
42074: OR
42075: PUSH
42076: LD_VAR 0 4
42080: PUSH
42081: LD_INT 1
42083: PUSH
42084: LD_INT 2
42086: PUSH
42087: LD_INT 3
42089: PUSH
42090: LD_INT 4
42092: PUSH
42093: LD_INT 5
42095: PUSH
42096: LD_INT 8
42098: PUSH
42099: LD_INT 9
42101: PUSH
42102: LD_INT 15
42104: PUSH
42105: LD_INT 16
42107: PUSH
42108: EMPTY
42109: LIST
42110: LIST
42111: LIST
42112: LIST
42113: LIST
42114: LIST
42115: LIST
42116: LIST
42117: LIST
42118: IN
42119: NOT
42120: OR
42121: IFFALSE 42125
// exit ;
42123: GO 43025
// base_unit_list := UnitFilter ( base_unit_list , [ [ f_type , unit_building ] , [ f_lives , 250 ] ] ) ;
42125: LD_ADDR_VAR 0 2
42129: PUSH
42130: LD_VAR 0 2
42134: PPUSH
42135: LD_INT 21
42137: PUSH
42138: LD_INT 3
42140: PUSH
42141: EMPTY
42142: LIST
42143: LIST
42144: PUSH
42145: LD_INT 24
42147: PUSH
42148: LD_INT 250
42150: PUSH
42151: EMPTY
42152: LIST
42153: LIST
42154: PUSH
42155: EMPTY
42156: LIST
42157: LIST
42158: PPUSH
42159: CALL_OW 72
42163: ST_TO_ADDR
// case class of 1 , 15 :
42164: LD_VAR 0 4
42168: PUSH
42169: LD_INT 1
42171: DOUBLE
42172: EQUAL
42173: IFTRUE 42183
42175: LD_INT 15
42177: DOUBLE
42178: EQUAL
42179: IFTRUE 42183
42181: GO 42268
42183: POP
// tmp := UnitFilter ( base_unit_list , [ f_or , [ f_btype , b_bunker ] , [ f_btype , b_breastwork ] ] ) ^ UnitFilter ( base_unit_list , [ f_or , [ f_btype , b_armoury ] , [ f_btype , b_barracks ] ] ) ; 2 , 16 :
42184: LD_ADDR_VAR 0 8
42188: PUSH
42189: LD_VAR 0 2
42193: PPUSH
42194: LD_INT 2
42196: PUSH
42197: LD_INT 30
42199: PUSH
42200: LD_INT 32
42202: PUSH
42203: EMPTY
42204: LIST
42205: LIST
42206: PUSH
42207: LD_INT 30
42209: PUSH
42210: LD_INT 31
42212: PUSH
42213: EMPTY
42214: LIST
42215: LIST
42216: PUSH
42217: EMPTY
42218: LIST
42219: LIST
42220: LIST
42221: PPUSH
42222: CALL_OW 72
42226: PUSH
42227: LD_VAR 0 2
42231: PPUSH
42232: LD_INT 2
42234: PUSH
42235: LD_INT 30
42237: PUSH
42238: LD_INT 4
42240: PUSH
42241: EMPTY
42242: LIST
42243: LIST
42244: PUSH
42245: LD_INT 30
42247: PUSH
42248: LD_INT 5
42250: PUSH
42251: EMPTY
42252: LIST
42253: LIST
42254: PUSH
42255: EMPTY
42256: LIST
42257: LIST
42258: LIST
42259: PPUSH
42260: CALL_OW 72
42264: ADD
42265: ST_TO_ADDR
42266: GO 42514
42268: LD_INT 2
42270: DOUBLE
42271: EQUAL
42272: IFTRUE 42282
42274: LD_INT 16
42276: DOUBLE
42277: EQUAL
42278: IFTRUE 42282
42280: GO 42328
42282: POP
// tmp := UnitFilter ( base_unit_list , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) ; 3 :
42283: LD_ADDR_VAR 0 8
42287: PUSH
42288: LD_VAR 0 2
42292: PPUSH
42293: LD_INT 2
42295: PUSH
42296: LD_INT 30
42298: PUSH
42299: LD_INT 0
42301: PUSH
42302: EMPTY
42303: LIST
42304: LIST
42305: PUSH
42306: LD_INT 30
42308: PUSH
42309: LD_INT 1
42311: PUSH
42312: EMPTY
42313: LIST
42314: LIST
42315: PUSH
42316: EMPTY
42317: LIST
42318: LIST
42319: LIST
42320: PPUSH
42321: CALL_OW 72
42325: ST_TO_ADDR
42326: GO 42514
42328: LD_INT 3
42330: DOUBLE
42331: EQUAL
42332: IFTRUE 42336
42334: GO 42382
42336: POP
// tmp := UnitFilter ( base_unit_list , [ f_or , [ f_btype , b_workshop ] , [ f_btype , b_factory ] ] ) ; 4 :
42337: LD_ADDR_VAR 0 8
42341: PUSH
42342: LD_VAR 0 2
42346: PPUSH
42347: LD_INT 2
42349: PUSH
42350: LD_INT 30
42352: PUSH
42353: LD_INT 2
42355: PUSH
42356: EMPTY
42357: LIST
42358: LIST
42359: PUSH
42360: LD_INT 30
42362: PUSH
42363: LD_INT 3
42365: PUSH
42366: EMPTY
42367: LIST
42368: LIST
42369: PUSH
42370: EMPTY
42371: LIST
42372: LIST
42373: LIST
42374: PPUSH
42375: CALL_OW 72
42379: ST_TO_ADDR
42380: GO 42514
42382: LD_INT 4
42384: DOUBLE
42385: EQUAL
42386: IFTRUE 42390
42388: GO 42447
42390: POP
// tmp := UnitFilter ( base_unit_list , [ f_or , [ f_btype , b_lab ] , [ f_btype , b_lab_half ] , [ f_btype , b_lab_full ] ] ) ; 5 , 8 , 9 :
42391: LD_ADDR_VAR 0 8
42395: PUSH
42396: LD_VAR 0 2
42400: PPUSH
42401: LD_INT 2
42403: PUSH
42404: LD_INT 30
42406: PUSH
42407: LD_INT 6
42409: PUSH
42410: EMPTY
42411: LIST
42412: LIST
42413: PUSH
42414: LD_INT 30
42416: PUSH
42417: LD_INT 7
42419: PUSH
42420: EMPTY
42421: LIST
42422: LIST
42423: PUSH
42424: LD_INT 30
42426: PUSH
42427: LD_INT 8
42429: PUSH
42430: EMPTY
42431: LIST
42432: LIST
42433: PUSH
42434: EMPTY
42435: LIST
42436: LIST
42437: LIST
42438: LIST
42439: PPUSH
42440: CALL_OW 72
42444: ST_TO_ADDR
42445: GO 42514
42447: LD_INT 5
42449: DOUBLE
42450: EQUAL
42451: IFTRUE 42467
42453: LD_INT 8
42455: DOUBLE
42456: EQUAL
42457: IFTRUE 42467
42459: LD_INT 9
42461: DOUBLE
42462: EQUAL
42463: IFTRUE 42467
42465: GO 42513
42467: POP
// tmp := UnitFilter ( base_unit_list , [ f_or , [ f_btype , b_armoury ] , [ f_btype , b_barracks ] ] ) ; end ;
42468: LD_ADDR_VAR 0 8
42472: PUSH
42473: LD_VAR 0 2
42477: PPUSH
42478: LD_INT 2
42480: PUSH
42481: LD_INT 30
42483: PUSH
42484: LD_INT 4
42486: PUSH
42487: EMPTY
42488: LIST
42489: LIST
42490: PUSH
42491: LD_INT 30
42493: PUSH
42494: LD_INT 5
42496: PUSH
42497: EMPTY
42498: LIST
42499: LIST
42500: PUSH
42501: EMPTY
42502: LIST
42503: LIST
42504: LIST
42505: PPUSH
42506: CALL_OW 72
42510: ST_TO_ADDR
42511: GO 42514
42513: POP
// if not tmp then
42514: LD_VAR 0 8
42518: NOT
42519: IFFALSE 42523
// exit ;
42521: GO 43025
// if class in [ 1 , 15 ] and mc_empty_turret_list [ base ] then
42523: LD_VAR 0 4
42527: PUSH
42528: LD_INT 1
42530: PUSH
42531: LD_INT 15
42533: PUSH
42534: EMPTY
42535: LIST
42536: LIST
42537: IN
42538: PUSH
42539: LD_EXP 83
42543: PUSH
42544: LD_VAR 0 1
42548: ARRAY
42549: AND
42550: IFFALSE 42706
// begin x := mc_empty_turret_list [ base ] [ 1 ] ;
42552: LD_ADDR_VAR 0 9
42556: PUSH
42557: LD_EXP 83
42561: PUSH
42562: LD_VAR 0 1
42566: ARRAY
42567: PUSH
42568: LD_INT 1
42570: ARRAY
42571: ST_TO_ADDR
// if not x in mc_busy_turret_list [ base ] then
42572: LD_VAR 0 9
42576: PUSH
42577: LD_EXP 84
42581: PUSH
42582: LD_VAR 0 1
42586: ARRAY
42587: IN
42588: NOT
42589: IFFALSE 42704
// begin mc_busy_turret_list := ReplaceIn ( mc_busy_turret_list , [ base , mc_busy_turret_list [ base ] + 1 ] , x ) ;
42591: LD_ADDR_EXP 84
42595: PUSH
42596: LD_EXP 84
42600: PPUSH
42601: LD_VAR 0 1
42605: PUSH
42606: LD_EXP 84
42610: PUSH
42611: LD_VAR 0 1
42615: ARRAY
42616: PUSH
42617: LD_INT 1
42619: PLUS
42620: PUSH
42621: EMPTY
42622: LIST
42623: LIST
42624: PPUSH
42625: LD_VAR 0 9
42629: PPUSH
42630: CALL 56953 0 3
42634: ST_TO_ADDR
// mc_empty_turret_list := Replace ( mc_empty_turret_list , base , mc_empty_turret_list [ base ] diff x ) ;
42635: LD_ADDR_EXP 83
42639: PUSH
42640: LD_EXP 83
42644: PPUSH
42645: LD_VAR 0 1
42649: PPUSH
42650: LD_EXP 83
42654: PUSH
42655: LD_VAR 0 1
42659: ARRAY
42660: PUSH
42661: LD_VAR 0 9
42665: DIFF
42666: PPUSH
42667: CALL_OW 1
42671: ST_TO_ADDR
// ComEnterUnit ( unit , mc_busy_turret_list [ base ] [ mc_busy_turret_list [ base ] ] ) ;
42672: LD_VAR 0 3
42676: PPUSH
42677: LD_EXP 84
42681: PUSH
42682: LD_VAR 0 1
42686: ARRAY
42687: PUSH
42688: LD_EXP 84
42692: PUSH
42693: LD_VAR 0 1
42697: ARRAY
42698: ARRAY
42699: PPUSH
42700: CALL_OW 120
// end ; exit ;
42704: GO 43025
// end ; if tmp > 1 then
42706: LD_VAR 0 8
42710: PUSH
42711: LD_INT 1
42713: GREATER
42714: IFFALSE 42818
// for i = 2 to tmp do
42716: LD_ADDR_VAR 0 6
42720: PUSH
42721: DOUBLE
42722: LD_INT 2
42724: DEC
42725: ST_TO_ADDR
42726: LD_VAR 0 8
42730: PUSH
42731: FOR_TO
42732: IFFALSE 42816
// if BuildingStatus ( tmp [ i ] ) = bs_need_people then
42734: LD_VAR 0 8
42738: PUSH
42739: LD_VAR 0 6
42743: ARRAY
42744: PPUSH
42745: CALL_OW 461
42749: PUSH
42750: LD_INT 6
42752: EQUAL
42753: IFFALSE 42814
// begin x := tmp [ i ] ;
42755: LD_ADDR_VAR 0 9
42759: PUSH
42760: LD_VAR 0 8
42764: PUSH
42765: LD_VAR 0 6
42769: ARRAY
42770: ST_TO_ADDR
// tmp := Delete ( tmp , i ) ;
42771: LD_ADDR_VAR 0 8
42775: PUSH
42776: LD_VAR 0 8
42780: PPUSH
42781: LD_VAR 0 6
42785: PPUSH
42786: CALL_OW 3
42790: ST_TO_ADDR
// tmp := Insert ( tmp , 1 , x ) ;
42791: LD_ADDR_VAR 0 8
42795: PUSH
42796: LD_VAR 0 8
42800: PPUSH
42801: LD_INT 1
42803: PPUSH
42804: LD_VAR 0 9
42808: PPUSH
42809: CALL_OW 2
42813: ST_TO_ADDR
// end ;
42814: GO 42731
42816: POP
42817: POP
// for i in tmp do
42818: LD_ADDR_VAR 0 6
42822: PUSH
42823: LD_VAR 0 8
42827: PUSH
42828: FOR_IN
42829: IFFALSE 42898
// begin if ( UnitsInside ( i ) < 6 and not GetBType ( i ) in [ b_breastwork , b_bunker ] ) or UnitsInside ( i ) = 0 then
42831: LD_VAR 0 6
42835: PPUSH
42836: CALL_OW 313
42840: PUSH
42841: LD_INT 6
42843: LESS
42844: PUSH
42845: LD_VAR 0 6
42849: PPUSH
42850: CALL_OW 266
42854: PUSH
42855: LD_INT 31
42857: PUSH
42858: LD_INT 32
42860: PUSH
42861: EMPTY
42862: LIST
42863: LIST
42864: IN
42865: NOT
42866: AND
42867: PUSH
42868: LD_VAR 0 6
42872: PPUSH
42873: CALL_OW 313
42877: PUSH
42878: LD_INT 0
42880: EQUAL
42881: OR
42882: IFFALSE 42896
// begin j := i ;
42884: LD_ADDR_VAR 0 7
42888: PUSH
42889: LD_VAR 0 6
42893: ST_TO_ADDR
// break ;
42894: GO 42898
// end ; end ;
42896: GO 42828
42898: POP
42899: POP
// if j then
42900: LD_VAR 0 7
42904: IFFALSE 42922
// ComEnterUnit ( unit , j ) else
42906: LD_VAR 0 3
42910: PPUSH
42911: LD_VAR 0 7
42915: PPUSH
42916: CALL_OW 120
42920: GO 43025
// begin depot := UnitFilter ( base_unit_list , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) ;
42922: LD_ADDR_VAR 0 10
42926: PUSH
42927: LD_VAR 0 2
42931: PPUSH
42932: LD_INT 2
42934: PUSH
42935: LD_INT 30
42937: PUSH
42938: LD_INT 0
42940: PUSH
42941: EMPTY
42942: LIST
42943: LIST
42944: PUSH
42945: LD_INT 30
42947: PUSH
42948: LD_INT 1
42950: PUSH
42951: EMPTY
42952: LIST
42953: LIST
42954: PUSH
42955: EMPTY
42956: LIST
42957: LIST
42958: LIST
42959: PPUSH
42960: CALL_OW 72
42964: ST_TO_ADDR
// if depot then
42965: LD_VAR 0 10
42969: IFFALSE 43025
// begin depot := NearestUnitToUnit ( depot , unit ) ;
42971: LD_ADDR_VAR 0 10
42975: PUSH
42976: LD_VAR 0 10
42980: PPUSH
42981: LD_VAR 0 3
42985: PPUSH
42986: CALL_OW 74
42990: ST_TO_ADDR
// if GetDistUnits ( unit , depot ) > 10 then
42991: LD_VAR 0 3
42995: PPUSH
42996: LD_VAR 0 10
43000: PPUSH
43001: CALL_OW 296
43005: PUSH
43006: LD_INT 10
43008: GREATER
43009: IFFALSE 43025
// ComStandNearbyBuilding ( unit , depot ) ;
43011: LD_VAR 0 3
43015: PPUSH
43016: LD_VAR 0 10
43020: PPUSH
43021: CALL 51305 0 2
// end ; end ; end ;
43025: LD_VAR 0 5
43029: RET
// export function MC_Idle ( ) ; var i , j , tmp ; begin
43030: LD_INT 0
43032: PPUSH
43033: PPUSH
43034: PPUSH
43035: PPUSH
// if not mc_bases then
43036: LD_EXP 74
43040: NOT
43041: IFFALSE 43045
// exit ;
43043: GO 43284
// for i = 1 to mc_bases do
43045: LD_ADDR_VAR 0 2
43049: PUSH
43050: DOUBLE
43051: LD_INT 1
43053: DEC
43054: ST_TO_ADDR
43055: LD_EXP 74
43059: PUSH
43060: FOR_TO
43061: IFFALSE 43282
// begin tmp := UnitFilter ( mc_bases [ i ] , [ f_type , unit_human ] ) union mc_ape [ i ] ;
43063: LD_ADDR_VAR 0 4
43067: PUSH
43068: LD_EXP 74
43072: PUSH
43073: LD_VAR 0 2
43077: ARRAY
43078: PPUSH
43079: LD_INT 21
43081: PUSH
43082: LD_INT 1
43084: PUSH
43085: EMPTY
43086: LIST
43087: LIST
43088: PPUSH
43089: CALL_OW 72
43093: PUSH
43094: LD_EXP 103
43098: PUSH
43099: LD_VAR 0 2
43103: ARRAY
43104: UNION
43105: ST_TO_ADDR
// if not tmp then
43106: LD_VAR 0 4
43110: NOT
43111: IFFALSE 43115
// continue ;
43113: GO 43060
// for j in tmp do
43115: LD_ADDR_VAR 0 3
43119: PUSH
43120: LD_VAR 0 4
43124: PUSH
43125: FOR_IN
43126: IFFALSE 43278
// begin if not GetTag ( j ) and not HasTask ( j ) and not IsDrivenBy ( j ) and not IsInUnit ( j ) and not j in mc_need_heal [ i ] [ 1 ] and not j in mc_need_heal [ i ] [ 2 ] and not j in mc_repair_vehicle [ i ] then
43128: LD_VAR 0 3
43132: PPUSH
43133: CALL_OW 110
43137: NOT
43138: PUSH
43139: LD_VAR 0 3
43143: PPUSH
43144: CALL_OW 314
43148: NOT
43149: AND
43150: PUSH
43151: LD_VAR 0 3
43155: PPUSH
43156: CALL_OW 311
43160: NOT
43161: AND
43162: PUSH
43163: LD_VAR 0 3
43167: PPUSH
43168: CALL_OW 310
43172: NOT
43173: AND
43174: PUSH
43175: LD_VAR 0 3
43179: PUSH
43180: LD_EXP 77
43184: PUSH
43185: LD_VAR 0 2
43189: ARRAY
43190: PUSH
43191: LD_INT 1
43193: ARRAY
43194: IN
43195: NOT
43196: AND
43197: PUSH
43198: LD_VAR 0 3
43202: PUSH
43203: LD_EXP 77
43207: PUSH
43208: LD_VAR 0 2
43212: ARRAY
43213: PUSH
43214: LD_INT 2
43216: ARRAY
43217: IN
43218: NOT
43219: AND
43220: PUSH
43221: LD_VAR 0 3
43225: PUSH
43226: LD_EXP 86
43230: PUSH
43231: LD_VAR 0 2
43235: ARRAY
43236: IN
43237: NOT
43238: AND
43239: IFFALSE 43276
// MC_Back ( i , mc_bases [ i ] , j , GetClass ( j ) ) ;
43241: LD_VAR 0 2
43245: PPUSH
43246: LD_EXP 74
43250: PUSH
43251: LD_VAR 0 2
43255: ARRAY
43256: PPUSH
43257: LD_VAR 0 3
43261: PPUSH
43262: LD_VAR 0 3
43266: PPUSH
43267: CALL_OW 257
43271: PPUSH
43272: CALL 42048 0 4
// end ;
43276: GO 43125
43278: POP
43279: POP
// end ;
43280: GO 43060
43282: POP
43283: POP
// end ;
43284: LD_VAR 0 1
43288: RET
// export function MC_SetMinesField ( base , amount , area ) ; var i , tmp , list , x , j ; begin
43289: LD_INT 0
43291: PPUSH
43292: PPUSH
43293: PPUSH
43294: PPUSH
43295: PPUSH
43296: PPUSH
// if not mc_bases [ base ] then
43297: LD_EXP 74
43301: PUSH
43302: LD_VAR 0 1
43306: ARRAY
43307: NOT
43308: IFFALSE 43312
// exit ;
43310: GO 43494
// tmp := [ ] ;
43312: LD_ADDR_VAR 0 6
43316: PUSH
43317: EMPTY
43318: ST_TO_ADDR
// list := AreaToList ( area , 0 ) ;
43319: LD_ADDR_VAR 0 7
43323: PUSH
43324: LD_VAR 0 3
43328: PPUSH
43329: LD_INT 0
43331: PPUSH
43332: CALL_OW 517
43336: ST_TO_ADDR
// if not list then
43337: LD_VAR 0 7
43341: NOT
43342: IFFALSE 43346
// exit ;
43344: GO 43494
// for i = 1 to amount do
43346: LD_ADDR_VAR 0 5
43350: PUSH
43351: DOUBLE
43352: LD_INT 1
43354: DEC
43355: ST_TO_ADDR
43356: LD_VAR 0 2
43360: PUSH
43361: FOR_TO
43362: IFFALSE 43442
// begin x := rand ( 1 , list [ 1 ] ) ;
43364: LD_ADDR_VAR 0 8
43368: PUSH
43369: LD_INT 1
43371: PPUSH
43372: LD_VAR 0 7
43376: PUSH
43377: LD_INT 1
43379: ARRAY
43380: PPUSH
43381: CALL_OW 12
43385: ST_TO_ADDR
// tmp := Replace ( tmp , i , [ list [ 1 ] [ x ] , list [ 2 ] [ x ] ] ) ;
43386: LD_ADDR_VAR 0 6
43390: PUSH
43391: LD_VAR 0 6
43395: PPUSH
43396: LD_VAR 0 5
43400: PPUSH
43401: LD_VAR 0 7
43405: PUSH
43406: LD_INT 1
43408: ARRAY
43409: PUSH
43410: LD_VAR 0 8
43414: ARRAY
43415: PUSH
43416: LD_VAR 0 7
43420: PUSH
43421: LD_INT 2
43423: ARRAY
43424: PUSH
43425: LD_VAR 0 8
43429: ARRAY
43430: PUSH
43431: EMPTY
43432: LIST
43433: LIST
43434: PPUSH
43435: CALL_OW 1
43439: ST_TO_ADDR
// end ;
43440: GO 43361
43442: POP
43443: POP
// mc_mines := Replace ( mc_mines , base , tmp ) ;
43444: LD_ADDR_EXP 87
43448: PUSH
43449: LD_EXP 87
43453: PPUSH
43454: LD_VAR 0 1
43458: PPUSH
43459: LD_VAR 0 6
43463: PPUSH
43464: CALL_OW 1
43468: ST_TO_ADDR
// mc_minefields := Replace ( mc_minefields , base , area ) ;
43469: LD_ADDR_EXP 89
43473: PUSH
43474: LD_EXP 89
43478: PPUSH
43479: LD_VAR 0 1
43483: PPUSH
43484: LD_VAR 0 3
43488: PPUSH
43489: CALL_OW 1
43493: ST_TO_ADDR
// end ;
43494: LD_VAR 0 4
43498: RET
// export function MC_SetBuildingList ( base , construct_list ) ; begin
43499: LD_INT 0
43501: PPUSH
// if not mc_bases [ base ] then
43502: LD_EXP 74
43506: PUSH
43507: LD_VAR 0 1
43511: ARRAY
43512: NOT
43513: IFFALSE 43517
// exit ;
43515: GO 43542
// mc_build_list := Replace ( mc_build_list , base , construct_list ) ;
43517: LD_ADDR_EXP 79
43521: PUSH
43522: LD_EXP 79
43526: PPUSH
43527: LD_VAR 0 1
43531: PPUSH
43532: LD_VAR 0 2
43536: PPUSH
43537: CALL_OW 1
43541: ST_TO_ADDR
// end ;
43542: LD_VAR 0 3
43546: RET
// export function MC_InsertBuildingList ( base , list ) ; begin
43547: LD_INT 0
43549: PPUSH
// if not mc_bases [ base ] then
43550: LD_EXP 74
43554: PUSH
43555: LD_VAR 0 1
43559: ARRAY
43560: NOT
43561: IFFALSE 43565
// exit ;
43563: GO 43602
// mc_build_list := Replace ( mc_build_list , base , mc_build_list [ base ] union list ) ;
43565: LD_ADDR_EXP 79
43569: PUSH
43570: LD_EXP 79
43574: PPUSH
43575: LD_VAR 0 1
43579: PPUSH
43580: LD_EXP 79
43584: PUSH
43585: LD_VAR 0 1
43589: ARRAY
43590: PUSH
43591: LD_VAR 0 2
43595: UNION
43596: PPUSH
43597: CALL_OW 1
43601: ST_TO_ADDR
// end ;
43602: LD_VAR 0 3
43606: RET
// export function MC_SetProduceList ( base , produce_list ) ; begin
43607: LD_INT 0
43609: PPUSH
// if not mc_bases [ base ] then
43610: LD_EXP 74
43614: PUSH
43615: LD_VAR 0 1
43619: ARRAY
43620: NOT
43621: IFFALSE 43625
// exit ;
43623: GO 43650
// mc_produce := Replace ( mc_produce , base , produce_list ) ;
43625: LD_ADDR_EXP 95
43629: PUSH
43630: LD_EXP 95
43634: PPUSH
43635: LD_VAR 0 1
43639: PPUSH
43640: LD_VAR 0 2
43644: PPUSH
43645: CALL_OW 1
43649: ST_TO_ADDR
// end ;
43650: LD_VAR 0 3
43654: RET
// export function MC_InsertProduceList ( base , components ) ; begin
43655: LD_INT 0
43657: PPUSH
// if not mc_bases [ base ] then
43658: LD_EXP 74
43662: PUSH
43663: LD_VAR 0 1
43667: ARRAY
43668: NOT
43669: IFFALSE 43673
// exit ;
43671: GO 43710
// mc_produce := Replace ( mc_produce , base , mc_produce [ base ] ^ components ) ;
43673: LD_ADDR_EXP 95
43677: PUSH
43678: LD_EXP 95
43682: PPUSH
43683: LD_VAR 0 1
43687: PPUSH
43688: LD_EXP 95
43692: PUSH
43693: LD_VAR 0 1
43697: ARRAY
43698: PUSH
43699: LD_VAR 0 2
43703: ADD
43704: PPUSH
43705: CALL_OW 1
43709: ST_TO_ADDR
// end ;
43710: LD_VAR 0 3
43714: RET
// export function MC_SetDefenderList ( base , deflist ) ; begin
43715: LD_INT 0
43717: PPUSH
// if not mc_bases [ base ] then
43718: LD_EXP 74
43722: PUSH
43723: LD_VAR 0 1
43727: ARRAY
43728: NOT
43729: IFFALSE 43733
// exit ;
43731: GO 43787
// mc_defender := Replace ( mc_defender , base , deflist ) ;
43733: LD_ADDR_EXP 96
43737: PUSH
43738: LD_EXP 96
43742: PPUSH
43743: LD_VAR 0 1
43747: PPUSH
43748: LD_VAR 0 2
43752: PPUSH
43753: CALL_OW 1
43757: ST_TO_ADDR
// mc_defender_limit := Replace ( mc_defender_limit , base , deflist + 0 ) ;
43758: LD_ADDR_EXP 85
43762: PUSH
43763: LD_EXP 85
43767: PPUSH
43768: LD_VAR 0 1
43772: PPUSH
43773: LD_VAR 0 2
43777: PUSH
43778: LD_INT 0
43780: PLUS
43781: PPUSH
43782: CALL_OW 1
43786: ST_TO_ADDR
// end ;
43787: LD_VAR 0 3
43791: RET
// export function MC_SetDefenderLimit ( base , limit ) ; begin
43792: LD_INT 0
43794: PPUSH
// if not mc_bases [ base ] then
43795: LD_EXP 74
43799: PUSH
43800: LD_VAR 0 1
43804: ARRAY
43805: NOT
43806: IFFALSE 43810
// exit ;
43808: GO 43835
// mc_defender_limit := Replace ( mc_defender_limit , base , limit ) ;
43810: LD_ADDR_EXP 85
43814: PUSH
43815: LD_EXP 85
43819: PPUSH
43820: LD_VAR 0 1
43824: PPUSH
43825: LD_VAR 0 2
43829: PPUSH
43830: CALL_OW 1
43834: ST_TO_ADDR
// end ;
43835: LD_VAR 0 3
43839: RET
// export function MC_PrepareAttack ( base , group , path , flags ) ; var i , j , tmp ; begin
43840: LD_INT 0
43842: PPUSH
43843: PPUSH
43844: PPUSH
43845: PPUSH
// if not mc_bases [ base ] then
43846: LD_EXP 74
43850: PUSH
43851: LD_VAR 0 1
43855: ARRAY
43856: NOT
43857: IFFALSE 43861
// exit ;
43859: GO 43926
// mc_attack := ReplaceIn ( mc_attack , [ base , mc_attack [ base ] + 1 ] , [ base , group , path , flags ] ) ;
43861: LD_ADDR_EXP 94
43865: PUSH
43866: LD_EXP 94
43870: PPUSH
43871: LD_VAR 0 1
43875: PUSH
43876: LD_EXP 94
43880: PUSH
43881: LD_VAR 0 1
43885: ARRAY
43886: PUSH
43887: LD_INT 1
43889: PLUS
43890: PUSH
43891: EMPTY
43892: LIST
43893: LIST
43894: PPUSH
43895: LD_VAR 0 1
43899: PUSH
43900: LD_VAR 0 2
43904: PUSH
43905: LD_VAR 0 3
43909: PUSH
43910: LD_VAR 0 4
43914: PUSH
43915: EMPTY
43916: LIST
43917: LIST
43918: LIST
43919: LIST
43920: PPUSH
43921: CALL 56953 0 3
43925: ST_TO_ADDR
// end ;
43926: LD_VAR 0 5
43930: RET
// export function MC_SetDepositsXY ( base , deposits_list ) ; begin
43931: LD_INT 0
43933: PPUSH
// if not mc_bases [ base ] then
43934: LD_EXP 74
43938: PUSH
43939: LD_VAR 0 1
43943: ARRAY
43944: NOT
43945: IFFALSE 43949
// exit ;
43947: GO 43974
// mc_deposits_xy := Replace ( mc_deposits_xy , base , deposits_list ) ;
43949: LD_ADDR_EXP 111
43953: PUSH
43954: LD_EXP 111
43958: PPUSH
43959: LD_VAR 0 1
43963: PPUSH
43964: LD_VAR 0 2
43968: PPUSH
43969: CALL_OW 1
43973: ST_TO_ADDR
// end ;
43974: LD_VAR 0 3
43978: RET
// export function MC_GetMinesField ( base ) ; begin
43979: LD_INT 0
43981: PPUSH
// result := mc_mines [ base ] ;
43982: LD_ADDR_VAR 0 2
43986: PUSH
43987: LD_EXP 87
43991: PUSH
43992: LD_VAR 0 1
43996: ARRAY
43997: ST_TO_ADDR
// end ;
43998: LD_VAR 0 2
44002: RET
// export function MC_GetProduceList ( base ) ; begin
44003: LD_INT 0
44005: PPUSH
// result := mc_produce [ base ] ;
44006: LD_ADDR_VAR 0 2
44010: PUSH
44011: LD_EXP 95
44015: PUSH
44016: LD_VAR 0 1
44020: ARRAY
44021: ST_TO_ADDR
// end ;
44022: LD_VAR 0 2
44026: RET
// export function MC_GetBuilding ( base , btype ) ; var i ; begin
44027: LD_INT 0
44029: PPUSH
44030: PPUSH
// if not mc_bases then
44031: LD_EXP 74
44035: NOT
44036: IFFALSE 44040
// exit ;
44038: GO 44105
// if mc_bases [ base ] then
44040: LD_EXP 74
44044: PUSH
44045: LD_VAR 0 1
44049: ARRAY
44050: IFFALSE 44105
// begin result := UnitFilter ( mc_bases [ base ] , [ f_btype , btype ] ) ;
44052: LD_ADDR_VAR 0 3
44056: PUSH
44057: LD_EXP 74
44061: PUSH
44062: LD_VAR 0 1
44066: ARRAY
44067: PPUSH
44068: LD_INT 30
44070: PUSH
44071: LD_VAR 0 2
44075: PUSH
44076: EMPTY
44077: LIST
44078: LIST
44079: PPUSH
44080: CALL_OW 72
44084: ST_TO_ADDR
// if result then
44085: LD_VAR 0 3
44089: IFFALSE 44105
// result := result [ 1 ] ;
44091: LD_ADDR_VAR 0 3
44095: PUSH
44096: LD_VAR 0 3
44100: PUSH
44101: LD_INT 1
44103: ARRAY
44104: ST_TO_ADDR
// end ; end ;
44105: LD_VAR 0 3
44109: RET
// export function MC_GetBuildings ( base , btype ) ; var i ; begin
44110: LD_INT 0
44112: PPUSH
44113: PPUSH
// if not mc_bases then
44114: LD_EXP 74
44118: NOT
44119: IFFALSE 44123
// exit ;
44121: GO 44168
// if mc_bases [ base ] then
44123: LD_EXP 74
44127: PUSH
44128: LD_VAR 0 1
44132: ARRAY
44133: IFFALSE 44168
// result := UnitFilter ( mc_bases [ base ] , [ f_btype , btype ] ) ;
44135: LD_ADDR_VAR 0 3
44139: PUSH
44140: LD_EXP 74
44144: PUSH
44145: LD_VAR 0 1
44149: ARRAY
44150: PPUSH
44151: LD_INT 30
44153: PUSH
44154: LD_VAR 0 2
44158: PUSH
44159: EMPTY
44160: LIST
44161: LIST
44162: PPUSH
44163: CALL_OW 72
44167: ST_TO_ADDR
// end ;
44168: LD_VAR 0 3
44172: RET
// export function MC_SetTame ( base , area ) ; begin
44173: LD_INT 0
44175: PPUSH
// if not mc_bases or not base then
44176: LD_EXP 74
44180: NOT
44181: PUSH
44182: LD_VAR 0 1
44186: NOT
44187: OR
44188: IFFALSE 44192
// exit ;
44190: GO 44217
// mc_can_tame := Replace ( mc_can_tame , base , area ) ;
44192: LD_ADDR_EXP 102
44196: PUSH
44197: LD_EXP 102
44201: PPUSH
44202: LD_VAR 0 1
44206: PPUSH
44207: LD_VAR 0 2
44211: PPUSH
44212: CALL_OW 1
44216: ST_TO_ADDR
// end ;
44217: LD_VAR 0 3
44221: RET
// export function MC_SetUpgradeBuilding ( base , btype ) ; var tmp ; begin
44222: LD_INT 0
44224: PPUSH
44225: PPUSH
// if not mc_bases or not base then
44226: LD_EXP 74
44230: NOT
44231: PUSH
44232: LD_VAR 0 1
44236: NOT
44237: OR
44238: IFFALSE 44242
// exit ;
44240: GO 44344
// tmp := UnitFilter ( mc_bases [ base ] , [ f_btype , btype ] ) ;
44242: LD_ADDR_VAR 0 4
44246: PUSH
44247: LD_EXP 74
44251: PUSH
44252: LD_VAR 0 1
44256: ARRAY
44257: PPUSH
44258: LD_INT 30
44260: PUSH
44261: LD_VAR 0 2
44265: PUSH
44266: EMPTY
44267: LIST
44268: LIST
44269: PPUSH
44270: CALL_OW 72
44274: ST_TO_ADDR
// if not tmp then
44275: LD_VAR 0 4
44279: NOT
44280: IFFALSE 44284
// exit ;
44282: GO 44344
// mc_build_upgrade := Replace ( mc_build_upgrade , base , Insert ( mc_build_upgrade [ base ] , mc_build_upgrade [ base ] + 1 , tmp [ 1 ] ) ) ;
44284: LD_ADDR_EXP 106
44288: PUSH
44289: LD_EXP 106
44293: PPUSH
44294: LD_VAR 0 1
44298: PPUSH
44299: LD_EXP 106
44303: PUSH
44304: LD_VAR 0 1
44308: ARRAY
44309: PPUSH
44310: LD_EXP 106
44314: PUSH
44315: LD_VAR 0 1
44319: ARRAY
44320: PUSH
44321: LD_INT 1
44323: PLUS
44324: PPUSH
44325: LD_VAR 0 4
44329: PUSH
44330: LD_INT 1
44332: ARRAY
44333: PPUSH
44334: CALL_OW 2
44338: PPUSH
44339: CALL_OW 1
44343: ST_TO_ADDR
// end ;
44344: LD_VAR 0 3
44348: RET
// export function MC_SetLabKind ( base , kinds ) ; var i ; begin
44349: LD_INT 0
44351: PPUSH
44352: PPUSH
// if not mc_bases or not base or not kinds then
44353: LD_EXP 74
44357: NOT
44358: PUSH
44359: LD_VAR 0 1
44363: NOT
44364: OR
44365: PUSH
44366: LD_VAR 0 2
44370: NOT
44371: OR
44372: IFFALSE 44376
// exit ;
44374: GO 44437
// for i in kinds do
44376: LD_ADDR_VAR 0 4
44380: PUSH
44381: LD_VAR 0 2
44385: PUSH
44386: FOR_IN
44387: IFFALSE 44435
// mc_lab_upgrade := ReplaceIn ( mc_lab_upgrade , [ base , mc_lab_upgrade [ base ] + 1 ] , i ) ;
44389: LD_ADDR_EXP 108
44393: PUSH
44394: LD_EXP 108
44398: PPUSH
44399: LD_VAR 0 1
44403: PUSH
44404: LD_EXP 108
44408: PUSH
44409: LD_VAR 0 1
44413: ARRAY
44414: PUSH
44415: LD_INT 1
44417: PLUS
44418: PUSH
44419: EMPTY
44420: LIST
44421: LIST
44422: PPUSH
44423: LD_VAR 0 4
44427: PPUSH
44428: CALL 56953 0 3
44432: ST_TO_ADDR
44433: GO 44386
44435: POP
44436: POP
// end ;
44437: LD_VAR 0 3
44441: RET
// export function MC_SetCratesArea ( base , areas ) ; begin
44442: LD_INT 0
44444: PPUSH
// if not mc_bases or not base or not areas then
44445: LD_EXP 74
44449: NOT
44450: PUSH
44451: LD_VAR 0 1
44455: NOT
44456: OR
44457: PUSH
44458: LD_VAR 0 2
44462: NOT
44463: OR
44464: IFFALSE 44468
// exit ;
44466: GO 44493
// mc_crates_area := Replace ( mc_crates_area , base , areas ) ;
44468: LD_ADDR_EXP 92
44472: PUSH
44473: LD_EXP 92
44477: PPUSH
44478: LD_VAR 0 1
44482: PPUSH
44483: LD_VAR 0 2
44487: PPUSH
44488: CALL_OW 1
44492: ST_TO_ADDR
// end ;
44493: LD_VAR 0 3
44497: RET
// export function MC_SetTeleportExit ( base , teleports_exit ) ; begin
44498: LD_INT 0
44500: PPUSH
// if not mc_bases or not base or not teleports_exit then
44501: LD_EXP 74
44505: NOT
44506: PUSH
44507: LD_VAR 0 1
44511: NOT
44512: OR
44513: PUSH
44514: LD_VAR 0 2
44518: NOT
44519: OR
44520: IFFALSE 44524
// exit ;
44522: GO 44549
// mc_teleport_exit := Replace ( mc_teleport_exit , base , teleports_exit ) ;
44524: LD_ADDR_EXP 109
44528: PUSH
44529: LD_EXP 109
44533: PPUSH
44534: LD_VAR 0 1
44538: PPUSH
44539: LD_VAR 0 2
44543: PPUSH
44544: CALL_OW 1
44548: ST_TO_ADDR
// end ;
44549: LD_VAR 0 3
44553: RET
// export function MC_SetFactoryExtension ( base , x , y , d , ext_list ) ; var i , tmp ; begin
44554: LD_INT 0
44556: PPUSH
44557: PPUSH
44558: PPUSH
// if not mc_bases or not base or not ext_list then
44559: LD_EXP 74
44563: NOT
44564: PUSH
44565: LD_VAR 0 1
44569: NOT
44570: OR
44571: PUSH
44572: LD_VAR 0 5
44576: NOT
44577: OR
44578: IFFALSE 44582
// exit ;
44580: GO 44755
// tmp := GetFacExtXYD ( x , y , d ) ;
44582: LD_ADDR_VAR 0 8
44586: PUSH
44587: LD_VAR 0 2
44591: PPUSH
44592: LD_VAR 0 3
44596: PPUSH
44597: LD_VAR 0 4
44601: PPUSH
44602: CALL 90331 0 3
44606: ST_TO_ADDR
// if not tmp then
44607: LD_VAR 0 8
44611: NOT
44612: IFFALSE 44616
// exit ;
44614: GO 44755
// for i in tmp do
44616: LD_ADDR_VAR 0 7
44620: PUSH
44621: LD_VAR 0 8
44625: PUSH
44626: FOR_IN
44627: IFFALSE 44753
// begin mc_build_list := Replace ( mc_build_list , base , Insert ( mc_build_list [ base ] , mc_build_list [ base ] + 1 , [ ext_list [ 1 ] , i [ 1 ] , i [ 2 ] , i [ 3 ] ] ) ) ;
44629: LD_ADDR_EXP 79
44633: PUSH
44634: LD_EXP 79
44638: PPUSH
44639: LD_VAR 0 1
44643: PPUSH
44644: LD_EXP 79
44648: PUSH
44649: LD_VAR 0 1
44653: ARRAY
44654: PPUSH
44655: LD_EXP 79
44659: PUSH
44660: LD_VAR 0 1
44664: ARRAY
44665: PUSH
44666: LD_INT 1
44668: PLUS
44669: PPUSH
44670: LD_VAR 0 5
44674: PUSH
44675: LD_INT 1
44677: ARRAY
44678: PUSH
44679: LD_VAR 0 7
44683: PUSH
44684: LD_INT 1
44686: ARRAY
44687: PUSH
44688: LD_VAR 0 7
44692: PUSH
44693: LD_INT 2
44695: ARRAY
44696: PUSH
44697: LD_VAR 0 7
44701: PUSH
44702: LD_INT 3
44704: ARRAY
44705: PUSH
44706: EMPTY
44707: LIST
44708: LIST
44709: LIST
44710: LIST
44711: PPUSH
44712: CALL_OW 2
44716: PPUSH
44717: CALL_OW 1
44721: ST_TO_ADDR
// ext_list := Delete ( ext_list , 1 ) ;
44722: LD_ADDR_VAR 0 5
44726: PUSH
44727: LD_VAR 0 5
44731: PPUSH
44732: LD_INT 1
44734: PPUSH
44735: CALL_OW 3
44739: ST_TO_ADDR
// if not ext_list then
44740: LD_VAR 0 5
44744: NOT
44745: IFFALSE 44751
// exit ;
44747: POP
44748: POP
44749: GO 44755
// end ;
44751: GO 44626
44753: POP
44754: POP
// end ;
44755: LD_VAR 0 6
44759: RET
// export function MC_SetAllowedTurretWeapons ( base , weapon_list ) ; begin
44760: LD_INT 0
44762: PPUSH
// if not mc_bases or not base or not weapon_list then
44763: LD_EXP 74
44767: NOT
44768: PUSH
44769: LD_VAR 0 1
44773: NOT
44774: OR
44775: PUSH
44776: LD_VAR 0 2
44780: NOT
44781: OR
44782: IFFALSE 44786
// exit ;
44784: GO 44811
// mc_allowed_tower_weapons := Replace ( mc_allowed_tower_weapons , base , weapon_list ) ;
44786: LD_ADDR_EXP 113
44790: PUSH
44791: LD_EXP 113
44795: PPUSH
44796: LD_VAR 0 1
44800: PPUSH
44801: LD_VAR 0 2
44805: PPUSH
44806: CALL_OW 1
44810: ST_TO_ADDR
// end ;
44811: LD_VAR 0 3
44815: RET
// export function MC_SetTechList ( base , tech_list ) ; begin
44816: LD_INT 0
44818: PPUSH
// if not mc_bases or not base or not tech_list then
44819: LD_EXP 74
44823: NOT
44824: PUSH
44825: LD_VAR 0 1
44829: NOT
44830: OR
44831: PUSH
44832: LD_VAR 0 2
44836: NOT
44837: OR
44838: IFFALSE 44842
// exit ;
44840: GO 44867
// mc_tech := Replace ( mc_tech , base , tech_list ) ;
44842: LD_ADDR_EXP 101
44846: PUSH
44847: LD_EXP 101
44851: PPUSH
44852: LD_VAR 0 1
44856: PPUSH
44857: LD_VAR 0 2
44861: PPUSH
44862: CALL_OW 1
44866: ST_TO_ADDR
// end ;
44867: LD_VAR 0 3
44871: RET
// export function MC_SetParkingArea ( base , parking_area ) ; begin
44872: LD_INT 0
44874: PPUSH
// if not mc_bases or not parking_area or not base then
44875: LD_EXP 74
44879: NOT
44880: PUSH
44881: LD_VAR 0 2
44885: NOT
44886: OR
44887: PUSH
44888: LD_VAR 0 1
44892: NOT
44893: OR
44894: IFFALSE 44898
// exit ;
44896: GO 44923
// mc_parking := Replace ( mc_parking , base , parking_area ) ;
44898: LD_ADDR_EXP 98
44902: PUSH
44903: LD_EXP 98
44907: PPUSH
44908: LD_VAR 0 1
44912: PPUSH
44913: LD_VAR 0 2
44917: PPUSH
44918: CALL_OW 1
44922: ST_TO_ADDR
// end ;
44923: LD_VAR 0 3
44927: RET
// export function MC_SetScanArea ( base , scan_area ) ; begin
44928: LD_INT 0
44930: PPUSH
// if not mc_bases or not base or not scan_area then
44931: LD_EXP 74
44935: NOT
44936: PUSH
44937: LD_VAR 0 1
44941: NOT
44942: OR
44943: PUSH
44944: LD_VAR 0 2
44948: NOT
44949: OR
44950: IFFALSE 44954
// exit ;
44952: GO 44979
// mc_scan_area := Replace ( mc_scan_area , base , scan_area ) ;
44954: LD_ADDR_EXP 99
44958: PUSH
44959: LD_EXP 99
44963: PPUSH
44964: LD_VAR 0 1
44968: PPUSH
44969: LD_VAR 0 2
44973: PPUSH
44974: CALL_OW 1
44978: ST_TO_ADDR
// end ;
44979: LD_VAR 0 3
44983: RET
// export function MC_NotTameApeman ( base ) ; var ape_techs ; begin
44984: LD_INT 0
44986: PPUSH
44987: PPUSH
// if not mc_bases or not base then
44988: LD_EXP 74
44992: NOT
44993: PUSH
44994: LD_VAR 0 1
44998: NOT
44999: OR
45000: IFFALSE 45004
// exit ;
45002: GO 45068
// ape_techs := [ 1 , 2 , 3 , 4 , 11 ] ;
45004: LD_ADDR_VAR 0 3
45008: PUSH
45009: LD_INT 1
45011: PUSH
45012: LD_INT 2
45014: PUSH
45015: LD_INT 3
45017: PUSH
45018: LD_INT 4
45020: PUSH
45021: LD_INT 11
45023: PUSH
45024: EMPTY
45025: LIST
45026: LIST
45027: LIST
45028: LIST
45029: LIST
45030: ST_TO_ADDR
// mc_tech := Replace ( mc_tech , base , mc_tech [ base ] diff ape_techs ) ;
45031: LD_ADDR_EXP 101
45035: PUSH
45036: LD_EXP 101
45040: PPUSH
45041: LD_VAR 0 1
45045: PPUSH
45046: LD_EXP 101
45050: PUSH
45051: LD_VAR 0 1
45055: ARRAY
45056: PUSH
45057: LD_VAR 0 3
45061: DIFF
45062: PPUSH
45063: CALL_OW 1
45067: ST_TO_ADDR
// end ;
45068: LD_VAR 0 2
45072: RET
// export function MC_GetVehicles ( base , onlyCombat ) ; begin
45073: LD_INT 0
45075: PPUSH
// result := mc_vehicles [ base ] ;
45076: LD_ADDR_VAR 0 3
45080: PUSH
45081: LD_EXP 93
45085: PUSH
45086: LD_VAR 0 1
45090: ARRAY
45091: ST_TO_ADDR
// if onlyCombat then
45092: LD_VAR 0 2
45096: IFFALSE 45261
// result := result diff UnitFilter ( result , [ f_or , [ f_weapon , us_cargo_bay ] , [ f_weapon , ru_cargo_bay ] , [ f_weapon , ru_big_cargo_bay ] , [ f_weapon , ar_cargo_bay ] , [ f_weapon , us_crane ] , [ f_weapon , ru_crane ] , [ f_weapon , us_bulldozer ] , [ f_weapon , ru_bulldozer ] , [ f_weapon , ru_radar ] , [ f_weapon , ar_control_tower ] , [ f_weapon , ru_siberium_rocket ] , [ f_weapon , us_siberium_rocket ] ] ) ;
45098: LD_ADDR_VAR 0 3
45102: PUSH
45103: LD_VAR 0 3
45107: PUSH
45108: LD_VAR 0 3
45112: PPUSH
45113: LD_INT 2
45115: PUSH
45116: LD_INT 34
45118: PUSH
45119: LD_INT 12
45121: PUSH
45122: EMPTY
45123: LIST
45124: LIST
45125: PUSH
45126: LD_INT 34
45128: PUSH
45129: LD_INT 51
45131: PUSH
45132: EMPTY
45133: LIST
45134: LIST
45135: PUSH
45136: LD_INT 34
45138: PUSH
45139: LD_EXP 68
45143: PUSH
45144: EMPTY
45145: LIST
45146: LIST
45147: PUSH
45148: LD_INT 34
45150: PUSH
45151: LD_INT 32
45153: PUSH
45154: EMPTY
45155: LIST
45156: LIST
45157: PUSH
45158: LD_INT 34
45160: PUSH
45161: LD_INT 13
45163: PUSH
45164: EMPTY
45165: LIST
45166: LIST
45167: PUSH
45168: LD_INT 34
45170: PUSH
45171: LD_INT 52
45173: PUSH
45174: EMPTY
45175: LIST
45176: LIST
45177: PUSH
45178: LD_INT 34
45180: PUSH
45181: LD_INT 14
45183: PUSH
45184: EMPTY
45185: LIST
45186: LIST
45187: PUSH
45188: LD_INT 34
45190: PUSH
45191: LD_INT 53
45193: PUSH
45194: EMPTY
45195: LIST
45196: LIST
45197: PUSH
45198: LD_INT 34
45200: PUSH
45201: LD_EXP 67
45205: PUSH
45206: EMPTY
45207: LIST
45208: LIST
45209: PUSH
45210: LD_INT 34
45212: PUSH
45213: LD_INT 31
45215: PUSH
45216: EMPTY
45217: LIST
45218: LIST
45219: PUSH
45220: LD_INT 34
45222: PUSH
45223: LD_INT 48
45225: PUSH
45226: EMPTY
45227: LIST
45228: LIST
45229: PUSH
45230: LD_INT 34
45232: PUSH
45233: LD_INT 8
45235: PUSH
45236: EMPTY
45237: LIST
45238: LIST
45239: PUSH
45240: EMPTY
45241: LIST
45242: LIST
45243: LIST
45244: LIST
45245: LIST
45246: LIST
45247: LIST
45248: LIST
45249: LIST
45250: LIST
45251: LIST
45252: LIST
45253: LIST
45254: PPUSH
45255: CALL_OW 72
45259: DIFF
45260: ST_TO_ADDR
// end ; end_of_file
45261: LD_VAR 0 3
45265: RET
// export function MCE_ApemanTamed ( ape , sci ) ; var i , tmp ; begin
45266: LD_INT 0
45268: PPUSH
45269: PPUSH
45270: PPUSH
// if not mc_bases or not skirmish then
45271: LD_EXP 74
45275: NOT
45276: PUSH
45277: LD_EXP 72
45281: NOT
45282: OR
45283: IFFALSE 45287
// exit ;
45285: GO 45452
// for i = 1 to mc_bases do
45287: LD_ADDR_VAR 0 4
45291: PUSH
45292: DOUBLE
45293: LD_INT 1
45295: DEC
45296: ST_TO_ADDR
45297: LD_EXP 74
45301: PUSH
45302: FOR_TO
45303: IFFALSE 45450
// begin if sci in mc_bases [ i ] then
45305: LD_VAR 0 2
45309: PUSH
45310: LD_EXP 74
45314: PUSH
45315: LD_VAR 0 4
45319: ARRAY
45320: IN
45321: IFFALSE 45448
// begin mc_ape := ReplaceIn ( mc_ape , [ i , mc_ape [ i ] + 1 ] , ape ) ;
45323: LD_ADDR_EXP 103
45327: PUSH
45328: LD_EXP 103
45332: PPUSH
45333: LD_VAR 0 4
45337: PUSH
45338: LD_EXP 103
45342: PUSH
45343: LD_VAR 0 4
45347: ARRAY
45348: PUSH
45349: LD_INT 1
45351: PLUS
45352: PUSH
45353: EMPTY
45354: LIST
45355: LIST
45356: PPUSH
45357: LD_VAR 0 1
45361: PPUSH
45362: CALL 56953 0 3
45366: ST_TO_ADDR
// tmp := NearestUnitToUnit ( UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) , ape ) ;
45367: LD_ADDR_VAR 0 5
45371: PUSH
45372: LD_EXP 74
45376: PUSH
45377: LD_VAR 0 4
45381: ARRAY
45382: PPUSH
45383: LD_INT 2
45385: PUSH
45386: LD_INT 30
45388: PUSH
45389: LD_INT 0
45391: PUSH
45392: EMPTY
45393: LIST
45394: LIST
45395: PUSH
45396: LD_INT 30
45398: PUSH
45399: LD_INT 1
45401: PUSH
45402: EMPTY
45403: LIST
45404: LIST
45405: PUSH
45406: EMPTY
45407: LIST
45408: LIST
45409: LIST
45410: PPUSH
45411: CALL_OW 72
45415: PPUSH
45416: LD_VAR 0 1
45420: PPUSH
45421: CALL_OW 74
45425: ST_TO_ADDR
// if tmp then
45426: LD_VAR 0 5
45430: IFFALSE 45446
// ComStandNearbyBuilding ( ape , tmp ) ;
45432: LD_VAR 0 1
45436: PPUSH
45437: LD_VAR 0 5
45441: PPUSH
45442: CALL 51305 0 2
// break ;
45446: GO 45450
// end ; end ;
45448: GO 45302
45450: POP
45451: POP
// end ;
45452: LD_VAR 0 3
45456: RET
// export function MCE_EnterBuilding ( building , unit ) ; var i , tmp ; begin
45457: LD_INT 0
45459: PPUSH
45460: PPUSH
45461: PPUSH
// if not mc_bases or not skirmish then
45462: LD_EXP 74
45466: NOT
45467: PUSH
45468: LD_EXP 72
45472: NOT
45473: OR
45474: IFFALSE 45478
// exit ;
45476: GO 45567
// for i = 1 to mc_bases do
45478: LD_ADDR_VAR 0 4
45482: PUSH
45483: DOUBLE
45484: LD_INT 1
45486: DEC
45487: ST_TO_ADDR
45488: LD_EXP 74
45492: PUSH
45493: FOR_TO
45494: IFFALSE 45565
// begin if building in mc_busy_turret_list [ i ] then
45496: LD_VAR 0 1
45500: PUSH
45501: LD_EXP 84
45505: PUSH
45506: LD_VAR 0 4
45510: ARRAY
45511: IN
45512: IFFALSE 45563
// begin tmp := mc_busy_turret_list [ i ] diff building ;
45514: LD_ADDR_VAR 0 5
45518: PUSH
45519: LD_EXP 84
45523: PUSH
45524: LD_VAR 0 4
45528: ARRAY
45529: PUSH
45530: LD_VAR 0 1
45534: DIFF
45535: ST_TO_ADDR
// mc_busy_turret_list := Replace ( mc_busy_turret_list , i , tmp ) ;
45536: LD_ADDR_EXP 84
45540: PUSH
45541: LD_EXP 84
45545: PPUSH
45546: LD_VAR 0 4
45550: PPUSH
45551: LD_VAR 0 5
45555: PPUSH
45556: CALL_OW 1
45560: ST_TO_ADDR
// break ;
45561: GO 45565
// end ; end ;
45563: GO 45493
45565: POP
45566: POP
// end ;
45567: LD_VAR 0 3
45571: RET
// export function MCE_BuildingCaptured ( building , side , capturning_unit ) ; var i , tmp ; begin
45572: LD_INT 0
45574: PPUSH
45575: PPUSH
45576: PPUSH
// if not mc_bases or not skirmish then
45577: LD_EXP 74
45581: NOT
45582: PUSH
45583: LD_EXP 72
45587: NOT
45588: OR
45589: IFFALSE 45593
// exit ;
45591: GO 45792
// for i = 1 to mc_bases do
45593: LD_ADDR_VAR 0 5
45597: PUSH
45598: DOUBLE
45599: LD_INT 1
45601: DEC
45602: ST_TO_ADDR
45603: LD_EXP 74
45607: PUSH
45608: FOR_TO
45609: IFFALSE 45790
// if building in mc_bases [ i ] then
45611: LD_VAR 0 1
45615: PUSH
45616: LD_EXP 74
45620: PUSH
45621: LD_VAR 0 5
45625: ARRAY
45626: IN
45627: IFFALSE 45788
// begin tmp := mc_bases [ i ] diff building ;
45629: LD_ADDR_VAR 0 6
45633: PUSH
45634: LD_EXP 74
45638: PUSH
45639: LD_VAR 0 5
45643: ARRAY
45644: PUSH
45645: LD_VAR 0 1
45649: DIFF
45650: ST_TO_ADDR
// mc_bases := Replace ( mc_bases , i , tmp ) ;
45651: LD_ADDR_EXP 74
45655: PUSH
45656: LD_EXP 74
45660: PPUSH
45661: LD_VAR 0 5
45665: PPUSH
45666: LD_VAR 0 6
45670: PPUSH
45671: CALL_OW 1
45675: ST_TO_ADDR
// if building in mc_turret_list [ i ] then
45676: LD_VAR 0 1
45680: PUSH
45681: LD_EXP 82
45685: PUSH
45686: LD_VAR 0 5
45690: ARRAY
45691: IN
45692: IFFALSE 45731
// mc_turret_list := Replace ( mc_turret_list , i , mc_turret_list [ i ] diff building ) ;
45694: LD_ADDR_EXP 82
45698: PUSH
45699: LD_EXP 82
45703: PPUSH
45704: LD_VAR 0 5
45708: PPUSH
45709: LD_EXP 82
45713: PUSH
45714: LD_VAR 0 5
45718: ARRAY
45719: PUSH
45720: LD_VAR 0 1
45724: DIFF
45725: PPUSH
45726: CALL_OW 1
45730: ST_TO_ADDR
// if building in mc_empty_turret_list [ i ] then
45731: LD_VAR 0 1
45735: PUSH
45736: LD_EXP 83
45740: PUSH
45741: LD_VAR 0 5
45745: ARRAY
45746: IN
45747: IFFALSE 45786
// mc_empty_turret_list := Replace ( mc_empty_turret_list , i , mc_empty_turret_list [ i ] diff building ) ;
45749: LD_ADDR_EXP 83
45753: PUSH
45754: LD_EXP 83
45758: PPUSH
45759: LD_VAR 0 5
45763: PPUSH
45764: LD_EXP 83
45768: PUSH
45769: LD_VAR 0 5
45773: ARRAY
45774: PUSH
45775: LD_VAR 0 1
45779: DIFF
45780: PPUSH
45781: CALL_OW 1
45785: ST_TO_ADDR
// break ;
45786: GO 45790
// end ;
45788: GO 45608
45790: POP
45791: POP
// end ;
45792: LD_VAR 0 4
45796: RET
// export function MCE_VehicleCaptured ( new , old , side , capturing_unit ) ; var i , tmp ; begin
45797: LD_INT 0
45799: PPUSH
45800: PPUSH
45801: PPUSH
// if not mc_bases or not skirmish or not side in mc_sides then
45802: LD_EXP 74
45806: NOT
45807: PUSH
45808: LD_EXP 72
45812: NOT
45813: OR
45814: PUSH
45815: LD_VAR 0 3
45819: PUSH
45820: LD_EXP 100
45824: IN
45825: NOT
45826: OR
45827: IFFALSE 45831
// exit ;
45829: GO 45954
// for i = 1 to mc_vehicles do
45831: LD_ADDR_VAR 0 6
45835: PUSH
45836: DOUBLE
45837: LD_INT 1
45839: DEC
45840: ST_TO_ADDR
45841: LD_EXP 93
45845: PUSH
45846: FOR_TO
45847: IFFALSE 45952
// if old in mc_vehicles [ i ] or new in mc_vehicles [ i ] then
45849: LD_VAR 0 2
45853: PUSH
45854: LD_EXP 93
45858: PUSH
45859: LD_VAR 0 6
45863: ARRAY
45864: IN
45865: PUSH
45866: LD_VAR 0 1
45870: PUSH
45871: LD_EXP 93
45875: PUSH
45876: LD_VAR 0 6
45880: ARRAY
45881: IN
45882: OR
45883: IFFALSE 45950
// begin tmp := mc_vehicles [ i ] diff old ;
45885: LD_ADDR_VAR 0 7
45889: PUSH
45890: LD_EXP 93
45894: PUSH
45895: LD_VAR 0 6
45899: ARRAY
45900: PUSH
45901: LD_VAR 0 2
45905: DIFF
45906: ST_TO_ADDR
// tmp := tmp diff new ;
45907: LD_ADDR_VAR 0 7
45911: PUSH
45912: LD_VAR 0 7
45916: PUSH
45917: LD_VAR 0 1
45921: DIFF
45922: ST_TO_ADDR
// mc_vehicles := Replace ( mc_vehicles , i , tmp ) ;
45923: LD_ADDR_EXP 93
45927: PUSH
45928: LD_EXP 93
45932: PPUSH
45933: LD_VAR 0 6
45937: PPUSH
45938: LD_VAR 0 7
45942: PPUSH
45943: CALL_OW 1
45947: ST_TO_ADDR
// break ;
45948: GO 45952
// end ;
45950: GO 45846
45952: POP
45953: POP
// end ;
45954: LD_VAR 0 5
45958: RET
// export function MCE_VehicleConstructed ( vehicle , factory ) ; var i , side , tmp ; begin
45959: LD_INT 0
45961: PPUSH
45962: PPUSH
45963: PPUSH
45964: PPUSH
// if not mc_bases or not skirmish then
45965: LD_EXP 74
45969: NOT
45970: PUSH
45971: LD_EXP 72
45975: NOT
45976: OR
45977: IFFALSE 45981
// exit ;
45979: GO 46358
// side := GetSide ( vehicle ) ;
45981: LD_ADDR_VAR 0 5
45985: PUSH
45986: LD_VAR 0 1
45990: PPUSH
45991: CALL_OW 255
45995: ST_TO_ADDR
// for i = 1 to mc_bases do
45996: LD_ADDR_VAR 0 4
46000: PUSH
46001: DOUBLE
46002: LD_INT 1
46004: DEC
46005: ST_TO_ADDR
46006: LD_EXP 74
46010: PUSH
46011: FOR_TO
46012: IFFALSE 46356
// begin if factory in mc_bases [ i ] then
46014: LD_VAR 0 2
46018: PUSH
46019: LD_EXP 74
46023: PUSH
46024: LD_VAR 0 4
46028: ARRAY
46029: IN
46030: IFFALSE 46354
// begin if mc_defender [ i ] < mc_defender_limit [ i ] and not GetWeapon ( vehicle ) in [ ar_control_tower , ar_cargo_bay , ru_cargo_bay , ru_big_cargo_bay , us_cargo_bay , ar_radar , ru_radar , us_radar , ru_bulldozer , us_bulldozer , ar_bio_bomb , ar_selfpropelled_bomb , us_hack , us_crane , ru_crane , ru_siberium_rocket , us_siberium_rocket ] then
46032: LD_EXP 96
46036: PUSH
46037: LD_VAR 0 4
46041: ARRAY
46042: PUSH
46043: LD_EXP 85
46047: PUSH
46048: LD_VAR 0 4
46052: ARRAY
46053: LESS
46054: PUSH
46055: LD_VAR 0 1
46059: PPUSH
46060: CALL_OW 264
46064: PUSH
46065: LD_INT 31
46067: PUSH
46068: LD_INT 32
46070: PUSH
46071: LD_INT 51
46073: PUSH
46074: LD_EXP 68
46078: PUSH
46079: LD_INT 12
46081: PUSH
46082: LD_INT 30
46084: PUSH
46085: LD_EXP 67
46089: PUSH
46090: LD_INT 11
46092: PUSH
46093: LD_INT 53
46095: PUSH
46096: LD_INT 14
46098: PUSH
46099: LD_EXP 71
46103: PUSH
46104: LD_INT 29
46106: PUSH
46107: LD_EXP 69
46111: PUSH
46112: LD_INT 13
46114: PUSH
46115: LD_INT 52
46117: PUSH
46118: LD_INT 48
46120: PUSH
46121: LD_INT 8
46123: PUSH
46124: EMPTY
46125: LIST
46126: LIST
46127: LIST
46128: LIST
46129: LIST
46130: LIST
46131: LIST
46132: LIST
46133: LIST
46134: LIST
46135: LIST
46136: LIST
46137: LIST
46138: LIST
46139: LIST
46140: LIST
46141: LIST
46142: IN
46143: NOT
46144: AND
46145: IFFALSE 46193
// mc_defender := ReplaceIn ( mc_defender , [ i , mc_defender [ i ] + 1 ] , vehicle ) else
46147: LD_ADDR_EXP 96
46151: PUSH
46152: LD_EXP 96
46156: PPUSH
46157: LD_VAR 0 4
46161: PUSH
46162: LD_EXP 96
46166: PUSH
46167: LD_VAR 0 4
46171: ARRAY
46172: PUSH
46173: LD_INT 1
46175: PLUS
46176: PUSH
46177: EMPTY
46178: LIST
46179: LIST
46180: PPUSH
46181: LD_VAR 0 1
46185: PPUSH
46186: CALL 56953 0 3
46190: ST_TO_ADDR
46191: GO 46237
// mc_vehicles := ReplaceIn ( mc_vehicles , [ i , mc_vehicles [ i ] + 1 ] , vehicle ) ;
46193: LD_ADDR_EXP 93
46197: PUSH
46198: LD_EXP 93
46202: PPUSH
46203: LD_VAR 0 4
46207: PUSH
46208: LD_EXP 93
46212: PUSH
46213: LD_VAR 0 4
46217: ARRAY
46218: PUSH
46219: LD_INT 1
46221: PLUS
46222: PUSH
46223: EMPTY
46224: LIST
46225: LIST
46226: PPUSH
46227: LD_VAR 0 1
46231: PPUSH
46232: CALL 56953 0 3
46236: ST_TO_ADDR
// if GetControl ( vehicle ) = control_remote then
46237: LD_VAR 0 1
46241: PPUSH
46242: CALL_OW 263
46246: PUSH
46247: LD_INT 2
46249: EQUAL
46250: IFFALSE 46270
// begin repeat wait ( 0 0$1 ) ;
46252: LD_INT 35
46254: PPUSH
46255: CALL_OW 67
// until IsControledBy ( vehicle ) ;
46259: LD_VAR 0 1
46263: PPUSH
46264: CALL_OW 312
46268: IFFALSE 46252
// end ; ComMoveToArea ( vehicle , mc_parking [ i ] ) ;
46270: LD_VAR 0 1
46274: PPUSH
46275: LD_EXP 98
46279: PUSH
46280: LD_VAR 0 4
46284: ARRAY
46285: PPUSH
46286: CALL_OW 113
// if GetControl ( vehicle ) <> control_manual then
46290: LD_VAR 0 1
46294: PPUSH
46295: CALL_OW 263
46299: PUSH
46300: LD_INT 1
46302: NONEQUAL
46303: IFFALSE 46307
// break ;
46305: GO 46356
// repeat wait ( 0 0$1 ) ;
46307: LD_INT 35
46309: PPUSH
46310: CALL_OW 67
// until IsInArea ( vehicle , mc_parking [ i ] ) ;
46314: LD_VAR 0 1
46318: PPUSH
46319: LD_EXP 98
46323: PUSH
46324: LD_VAR 0 4
46328: ARRAY
46329: PPUSH
46330: CALL_OW 308
46334: IFFALSE 46307
// ComExitVehicle ( IsDrivenBy ( vehicle ) ) ;
46336: LD_VAR 0 1
46340: PPUSH
46341: CALL_OW 311
46345: PPUSH
46346: CALL_OW 121
// exit ;
46350: POP
46351: POP
46352: GO 46358
// end ; end ;
46354: GO 46011
46356: POP
46357: POP
// end ;
46358: LD_VAR 0 3
46362: RET
// export function MCE_CrateSpawn ( id , x , y , amount , mode ) ; var i , j , depot ; begin
46363: LD_INT 0
46365: PPUSH
46366: PPUSH
46367: PPUSH
46368: PPUSH
// if not mc_bases or not skirmish then
46369: LD_EXP 74
46373: NOT
46374: PUSH
46375: LD_EXP 72
46379: NOT
46380: OR
46381: IFFALSE 46385
// exit ;
46383: GO 46738
// repeat wait ( 0 0$1 ) ;
46385: LD_INT 35
46387: PPUSH
46388: CALL_OW 67
// until GetResourceAmountXY ( x , y ) ;
46392: LD_VAR 0 2
46396: PPUSH
46397: LD_VAR 0 3
46401: PPUSH
46402: CALL_OW 284
46406: IFFALSE 46385
// if GetResourceTypeXY ( x , y ) = mat_artefact then
46408: LD_VAR 0 2
46412: PPUSH
46413: LD_VAR 0 3
46417: PPUSH
46418: CALL_OW 283
46422: PUSH
46423: LD_INT 4
46425: EQUAL
46426: IFFALSE 46430
// exit ;
46428: GO 46738
// for i = 1 to mc_bases do
46430: LD_ADDR_VAR 0 7
46434: PUSH
46435: DOUBLE
46436: LD_INT 1
46438: DEC
46439: ST_TO_ADDR
46440: LD_EXP 74
46444: PUSH
46445: FOR_TO
46446: IFFALSE 46736
// begin if mc_crates_area [ i ] then
46448: LD_EXP 92
46452: PUSH
46453: LD_VAR 0 7
46457: ARRAY
46458: IFFALSE 46569
// for j in mc_crates_area [ i ] do
46460: LD_ADDR_VAR 0 8
46464: PUSH
46465: LD_EXP 92
46469: PUSH
46470: LD_VAR 0 7
46474: ARRAY
46475: PUSH
46476: FOR_IN
46477: IFFALSE 46567
// if InArea ( x , y , j ) then
46479: LD_VAR 0 2
46483: PPUSH
46484: LD_VAR 0 3
46488: PPUSH
46489: LD_VAR 0 8
46493: PPUSH
46494: CALL_OW 309
46498: IFFALSE 46565
// begin mc_crates := ReplaceIn ( mc_crates , [ i , mc_crates [ i ] + 1 ] , [ amount , x , y ] ) ;
46500: LD_ADDR_EXP 90
46504: PUSH
46505: LD_EXP 90
46509: PPUSH
46510: LD_VAR 0 7
46514: PUSH
46515: LD_EXP 90
46519: PUSH
46520: LD_VAR 0 7
46524: ARRAY
46525: PUSH
46526: LD_INT 1
46528: PLUS
46529: PUSH
46530: EMPTY
46531: LIST
46532: LIST
46533: PPUSH
46534: LD_VAR 0 4
46538: PUSH
46539: LD_VAR 0 2
46543: PUSH
46544: LD_VAR 0 3
46548: PUSH
46549: EMPTY
46550: LIST
46551: LIST
46552: LIST
46553: PPUSH
46554: CALL 56953 0 3
46558: ST_TO_ADDR
// exit ;
46559: POP
46560: POP
46561: POP
46562: POP
46563: GO 46738
// end ;
46565: GO 46476
46567: POP
46568: POP
// depot := UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) ;
46569: LD_ADDR_VAR 0 9
46573: PUSH
46574: LD_EXP 74
46578: PUSH
46579: LD_VAR 0 7
46583: ARRAY
46584: PPUSH
46585: LD_INT 2
46587: PUSH
46588: LD_INT 30
46590: PUSH
46591: LD_INT 0
46593: PUSH
46594: EMPTY
46595: LIST
46596: LIST
46597: PUSH
46598: LD_INT 30
46600: PUSH
46601: LD_INT 1
46603: PUSH
46604: EMPTY
46605: LIST
46606: LIST
46607: PUSH
46608: EMPTY
46609: LIST
46610: LIST
46611: LIST
46612: PPUSH
46613: CALL_OW 72
46617: ST_TO_ADDR
// if not depot then
46618: LD_VAR 0 9
46622: NOT
46623: IFFALSE 46627
// continue ;
46625: GO 46445
// for j in depot do
46627: LD_ADDR_VAR 0 8
46631: PUSH
46632: LD_VAR 0 9
46636: PUSH
46637: FOR_IN
46638: IFFALSE 46732
// if GetDistUnitXY ( j , x , y ) < 30 then
46640: LD_VAR 0 8
46644: PPUSH
46645: LD_VAR 0 2
46649: PPUSH
46650: LD_VAR 0 3
46654: PPUSH
46655: CALL_OW 297
46659: PUSH
46660: LD_INT 30
46662: LESS
46663: IFFALSE 46730
// begin mc_crates := ReplaceIn ( mc_crates , [ i , mc_crates [ i ] + 1 ] , [ amount , x , y ] ) ;
46665: LD_ADDR_EXP 90
46669: PUSH
46670: LD_EXP 90
46674: PPUSH
46675: LD_VAR 0 7
46679: PUSH
46680: LD_EXP 90
46684: PUSH
46685: LD_VAR 0 7
46689: ARRAY
46690: PUSH
46691: LD_INT 1
46693: PLUS
46694: PUSH
46695: EMPTY
46696: LIST
46697: LIST
46698: PPUSH
46699: LD_VAR 0 4
46703: PUSH
46704: LD_VAR 0 2
46708: PUSH
46709: LD_VAR 0 3
46713: PUSH
46714: EMPTY
46715: LIST
46716: LIST
46717: LIST
46718: PPUSH
46719: CALL 56953 0 3
46723: ST_TO_ADDR
// exit ;
46724: POP
46725: POP
46726: POP
46727: POP
46728: GO 46738
// end ;
46730: GO 46637
46732: POP
46733: POP
// end ;
46734: GO 46445
46736: POP
46737: POP
// end ;
46738: LD_VAR 0 6
46742: RET
// export function MCE_ResearchComplete ( tech , lab ) ; var side , i , tmp ; begin
46743: LD_INT 0
46745: PPUSH
46746: PPUSH
46747: PPUSH
46748: PPUSH
// if not mc_bases or not skirmish then
46749: LD_EXP 74
46753: NOT
46754: PUSH
46755: LD_EXP 72
46759: NOT
46760: OR
46761: IFFALSE 46765
// exit ;
46763: GO 47042
// side := GetSide ( lab ) ;
46765: LD_ADDR_VAR 0 4
46769: PUSH
46770: LD_VAR 0 2
46774: PPUSH
46775: CALL_OW 255
46779: ST_TO_ADDR
// if not side in mc_sides or not mc_tech or not mc_bases then
46780: LD_VAR 0 4
46784: PUSH
46785: LD_EXP 100
46789: IN
46790: NOT
46791: PUSH
46792: LD_EXP 101
46796: NOT
46797: OR
46798: PUSH
46799: LD_EXP 74
46803: NOT
46804: OR
46805: IFFALSE 46809
// exit ;
46807: GO 47042
// mc_tech := Replace ( mc_tech , side , mc_tech [ side ] diff tech ) ;
46809: LD_ADDR_EXP 101
46813: PUSH
46814: LD_EXP 101
46818: PPUSH
46819: LD_VAR 0 4
46823: PPUSH
46824: LD_EXP 101
46828: PUSH
46829: LD_VAR 0 4
46833: ARRAY
46834: PUSH
46835: LD_VAR 0 1
46839: DIFF
46840: PPUSH
46841: CALL_OW 1
46845: ST_TO_ADDR
// for i = 1 to mc_bases do
46846: LD_ADDR_VAR 0 5
46850: PUSH
46851: DOUBLE
46852: LD_INT 1
46854: DEC
46855: ST_TO_ADDR
46856: LD_EXP 74
46860: PUSH
46861: FOR_TO
46862: IFFALSE 47040
// begin if lab in mc_bases [ i ] then
46864: LD_VAR 0 2
46868: PUSH
46869: LD_EXP 74
46873: PUSH
46874: LD_VAR 0 5
46878: ARRAY
46879: IN
46880: IFFALSE 47038
// begin if tech in [ tech_apeagres , tech_apebrain , tech_apeneural , tech_apepsych ] and mc_ape_in_lab [ i ] then
46882: LD_VAR 0 1
46886: PUSH
46887: LD_INT 11
46889: PUSH
46890: LD_INT 4
46892: PUSH
46893: LD_INT 3
46895: PUSH
46896: LD_INT 2
46898: PUSH
46899: EMPTY
46900: LIST
46901: LIST
46902: LIST
46903: LIST
46904: IN
46905: PUSH
46906: LD_EXP 104
46910: PUSH
46911: LD_VAR 0 5
46915: ARRAY
46916: AND
46917: IFFALSE 47038
// begin tmp := mc_ape_in_lab [ i ] [ 1 ] ;
46919: LD_ADDR_VAR 0 6
46923: PUSH
46924: LD_EXP 104
46928: PUSH
46929: LD_VAR 0 5
46933: ARRAY
46934: PUSH
46935: LD_INT 1
46937: ARRAY
46938: ST_TO_ADDR
// mc_ape_in_lab := Replace ( mc_ape_in_lab , i , [ ] ) ;
46939: LD_ADDR_EXP 104
46943: PUSH
46944: LD_EXP 104
46948: PPUSH
46949: LD_VAR 0 5
46953: PPUSH
46954: EMPTY
46955: PPUSH
46956: CALL_OW 1
46960: ST_TO_ADDR
// SetTag ( tmp , 0 ) ;
46961: LD_VAR 0 6
46965: PPUSH
46966: LD_INT 0
46968: PPUSH
46969: CALL_OW 109
// ComExitBuilding ( tmp ) ;
46973: LD_VAR 0 6
46977: PPUSH
46978: CALL_OW 122
// mc_ape := Replace ( mc_ape , i , Insert ( mc_ape [ i ] , 1 , tmp ) ) ;
46982: LD_ADDR_EXP 103
46986: PUSH
46987: LD_EXP 103
46991: PPUSH
46992: LD_VAR 0 5
46996: PPUSH
46997: LD_EXP 103
47001: PUSH
47002: LD_VAR 0 5
47006: ARRAY
47007: PPUSH
47008: LD_INT 1
47010: PPUSH
47011: LD_VAR 0 6
47015: PPUSH
47016: CALL_OW 2
47020: PPUSH
47021: CALL_OW 1
47025: ST_TO_ADDR
// MC_Reset ( i , 112 ) ;
47026: LD_VAR 0 5
47030: PPUSH
47031: LD_INT 112
47033: PPUSH
47034: CALL 24150 0 2
// end ; end ; end ;
47038: GO 46861
47040: POP
47041: POP
// end ;
47042: LD_VAR 0 3
47046: RET
// export function MCE_UnitDestroyed ( un ) ; var i , j , btype , pos , tmp , fac , components ; begin
47047: LD_INT 0
47049: PPUSH
47050: PPUSH
47051: PPUSH
47052: PPUSH
47053: PPUSH
47054: PPUSH
47055: PPUSH
47056: PPUSH
// if not mc_bases or not skirmish then
47057: LD_EXP 74
47061: NOT
47062: PUSH
47063: LD_EXP 72
47067: NOT
47068: OR
47069: IFFALSE 47073
// exit ;
47071: GO 48310
// for i = 1 to mc_bases do
47073: LD_ADDR_VAR 0 3
47077: PUSH
47078: DOUBLE
47079: LD_INT 1
47081: DEC
47082: ST_TO_ADDR
47083: LD_EXP 74
47087: PUSH
47088: FOR_TO
47089: IFFALSE 48308
// if un in mc_bases [ i ] or un in mc_construct_list [ i ] or un in mc_defender [ i ] or un in mc_vehicles [ i ] or un in mc_ape [ i ] or un in mc_ape_in_lab [ i ] then
47091: LD_VAR 0 1
47095: PUSH
47096: LD_EXP 74
47100: PUSH
47101: LD_VAR 0 3
47105: ARRAY
47106: IN
47107: PUSH
47108: LD_VAR 0 1
47112: PUSH
47113: LD_EXP 81
47117: PUSH
47118: LD_VAR 0 3
47122: ARRAY
47123: IN
47124: OR
47125: PUSH
47126: LD_VAR 0 1
47130: PUSH
47131: LD_EXP 96
47135: PUSH
47136: LD_VAR 0 3
47140: ARRAY
47141: IN
47142: OR
47143: PUSH
47144: LD_VAR 0 1
47148: PUSH
47149: LD_EXP 93
47153: PUSH
47154: LD_VAR 0 3
47158: ARRAY
47159: IN
47160: OR
47161: PUSH
47162: LD_VAR 0 1
47166: PUSH
47167: LD_EXP 103
47171: PUSH
47172: LD_VAR 0 3
47176: ARRAY
47177: IN
47178: OR
47179: PUSH
47180: LD_VAR 0 1
47184: PUSH
47185: LD_EXP 104
47189: PUSH
47190: LD_VAR 0 3
47194: ARRAY
47195: IN
47196: OR
47197: IFFALSE 48306
// begin if un in mc_ape [ i ] then
47199: LD_VAR 0 1
47203: PUSH
47204: LD_EXP 103
47208: PUSH
47209: LD_VAR 0 3
47213: ARRAY
47214: IN
47215: IFFALSE 47254
// begin mc_ape := Replace ( mc_ape , i , mc_ape [ i ] diff un ) ;
47217: LD_ADDR_EXP 103
47221: PUSH
47222: LD_EXP 103
47226: PPUSH
47227: LD_VAR 0 3
47231: PPUSH
47232: LD_EXP 103
47236: PUSH
47237: LD_VAR 0 3
47241: ARRAY
47242: PUSH
47243: LD_VAR 0 1
47247: DIFF
47248: PPUSH
47249: CALL_OW 1
47253: ST_TO_ADDR
// end ; if un in mc_ape_in_lab [ i ] then
47254: LD_VAR 0 1
47258: PUSH
47259: LD_EXP 104
47263: PUSH
47264: LD_VAR 0 3
47268: ARRAY
47269: IN
47270: IFFALSE 47294
// begin mc_ape_in_lab := Replace ( mc_ape_in_lab , i , [ ] ) ;
47272: LD_ADDR_EXP 104
47276: PUSH
47277: LD_EXP 104
47281: PPUSH
47282: LD_VAR 0 3
47286: PPUSH
47287: EMPTY
47288: PPUSH
47289: CALL_OW 1
47293: ST_TO_ADDR
// end ; if GetType ( un ) = unit_vehicle and ( GetTag ( un ) = 20 or un in mc_defender [ i ] or GetWeapon ( un ) in [ us_cargo_bay , ru_cargo_bay , ru_big_cargo_bay , ar_cargo_bay , us_crane , ru_crane ] ) then
47294: LD_VAR 0 1
47298: PPUSH
47299: CALL_OW 247
47303: PUSH
47304: LD_INT 2
47306: EQUAL
47307: PUSH
47308: LD_VAR 0 1
47312: PPUSH
47313: CALL_OW 110
47317: PUSH
47318: LD_INT 20
47320: EQUAL
47321: PUSH
47322: LD_VAR 0 1
47326: PUSH
47327: LD_EXP 96
47331: PUSH
47332: LD_VAR 0 3
47336: ARRAY
47337: IN
47338: OR
47339: PUSH
47340: LD_VAR 0 1
47344: PPUSH
47345: CALL_OW 264
47349: PUSH
47350: LD_INT 12
47352: PUSH
47353: LD_INT 51
47355: PUSH
47356: LD_EXP 68
47360: PUSH
47361: LD_INT 32
47363: PUSH
47364: LD_INT 13
47366: PUSH
47367: LD_INT 52
47369: PUSH
47370: EMPTY
47371: LIST
47372: LIST
47373: LIST
47374: LIST
47375: LIST
47376: LIST
47377: IN
47378: OR
47379: AND
47380: IFFALSE 47558
// begin if un in mc_defender [ i ] then
47382: LD_VAR 0 1
47386: PUSH
47387: LD_EXP 96
47391: PUSH
47392: LD_VAR 0 3
47396: ARRAY
47397: IN
47398: IFFALSE 47437
// mc_defender := Replace ( mc_defender , i , mc_defender [ i ] diff un ) ;
47400: LD_ADDR_EXP 96
47404: PUSH
47405: LD_EXP 96
47409: PPUSH
47410: LD_VAR 0 3
47414: PPUSH
47415: LD_EXP 96
47419: PUSH
47420: LD_VAR 0 3
47424: ARRAY
47425: PUSH
47426: LD_VAR 0 1
47430: DIFF
47431: PPUSH
47432: CALL_OW 1
47436: ST_TO_ADDR
// fac := MC_GetBuildings ( i , b_factory ) ;
47437: LD_ADDR_VAR 0 8
47441: PUSH
47442: LD_VAR 0 3
47446: PPUSH
47447: LD_INT 3
47449: PPUSH
47450: CALL 44110 0 2
47454: ST_TO_ADDR
// if fac then
47455: LD_VAR 0 8
47459: IFFALSE 47558
// begin for j in fac do
47461: LD_ADDR_VAR 0 4
47465: PUSH
47466: LD_VAR 0 8
47470: PUSH
47471: FOR_IN
47472: IFFALSE 47556
// begin components := Produce ( fac , GetChassis ( un ) , GetEngine ( un ) , GetControl ( un ) , GetWeapon ( un ) ) ;
47474: LD_ADDR_VAR 0 9
47478: PUSH
47479: LD_VAR 0 8
47483: PPUSH
47484: LD_VAR 0 1
47488: PPUSH
47489: CALL_OW 265
47493: PPUSH
47494: LD_VAR 0 1
47498: PPUSH
47499: CALL_OW 262
47503: PPUSH
47504: LD_VAR 0 1
47508: PPUSH
47509: CALL_OW 263
47513: PPUSH
47514: LD_VAR 0 1
47518: PPUSH
47519: CALL_OW 264
47523: PPUSH
47524: CALL 54485 0 5
47528: ST_TO_ADDR
// if components then
47529: LD_VAR 0 9
47533: IFFALSE 47554
// begin MC_InsertProduceList ( i , [ components ] ) ;
47535: LD_VAR 0 3
47539: PPUSH
47540: LD_VAR 0 9
47544: PUSH
47545: EMPTY
47546: LIST
47547: PPUSH
47548: CALL 43655 0 2
// break ;
47552: GO 47556
// end ; end ;
47554: GO 47471
47556: POP
47557: POP
// end ; end ; if GetType ( un ) = unit_building then
47558: LD_VAR 0 1
47562: PPUSH
47563: CALL_OW 247
47567: PUSH
47568: LD_INT 3
47570: EQUAL
47571: IFFALSE 47974
// begin btype := GetBType ( un ) ;
47573: LD_ADDR_VAR 0 5
47577: PUSH
47578: LD_VAR 0 1
47582: PPUSH
47583: CALL_OW 266
47587: ST_TO_ADDR
// if btype in [ b_oil_mine , b_siberite_mine ] then
47588: LD_VAR 0 5
47592: PUSH
47593: LD_INT 29
47595: PUSH
47596: LD_INT 30
47598: PUSH
47599: EMPTY
47600: LIST
47601: LIST
47602: IN
47603: IFFALSE 47676
// begin if not GetResourceVisibility ( GetX ( un ) , GetY ( un ) , GetSide ( un ) ) then
47605: LD_VAR 0 1
47609: PPUSH
47610: CALL_OW 250
47614: PPUSH
47615: LD_VAR 0 1
47619: PPUSH
47620: CALL_OW 251
47624: PPUSH
47625: LD_VAR 0 1
47629: PPUSH
47630: CALL_OW 255
47634: PPUSH
47635: CALL_OW 440
47639: NOT
47640: IFFALSE 47676
// SetResourceVisibility ( GetX ( un ) , GetY ( un ) , GetSide ( un ) ) ;
47642: LD_VAR 0 1
47646: PPUSH
47647: CALL_OW 250
47651: PPUSH
47652: LD_VAR 0 1
47656: PPUSH
47657: CALL_OW 251
47661: PPUSH
47662: LD_VAR 0 1
47666: PPUSH
47667: CALL_OW 255
47671: PPUSH
47672: CALL_OW 441
// end ; if btype = b_warehouse then
47676: LD_VAR 0 5
47680: PUSH
47681: LD_INT 1
47683: EQUAL
47684: IFFALSE 47702
// begin btype := b_depot ;
47686: LD_ADDR_VAR 0 5
47690: PUSH
47691: LD_INT 0
47693: ST_TO_ADDR
// pos := 1 ;
47694: LD_ADDR_VAR 0 6
47698: PUSH
47699: LD_INT 1
47701: ST_TO_ADDR
// end ; if btype = b_factory then
47702: LD_VAR 0 5
47706: PUSH
47707: LD_INT 3
47709: EQUAL
47710: IFFALSE 47728
// begin btype := b_workshop ;
47712: LD_ADDR_VAR 0 5
47716: PUSH
47717: LD_INT 2
47719: ST_TO_ADDR
// pos := 1 ;
47720: LD_ADDR_VAR 0 6
47724: PUSH
47725: LD_INT 1
47727: ST_TO_ADDR
// end ; if btype = b_barracks then
47728: LD_VAR 0 5
47732: PUSH
47733: LD_INT 5
47735: EQUAL
47736: IFFALSE 47746
// btype := b_armoury ;
47738: LD_ADDR_VAR 0 5
47742: PUSH
47743: LD_INT 4
47745: ST_TO_ADDR
// if btype in [ b_lab_half , b_lab_full ] then
47746: LD_VAR 0 5
47750: PUSH
47751: LD_INT 7
47753: PUSH
47754: LD_INT 8
47756: PUSH
47757: EMPTY
47758: LIST
47759: LIST
47760: IN
47761: IFFALSE 47771
// btype := b_lab ;
47763: LD_ADDR_VAR 0 5
47767: PUSH
47768: LD_INT 6
47770: ST_TO_ADDR
// mc_build_list := ReplaceIn ( mc_build_list , [ i , mc_build_list [ i ] + 1 ] , [ btype , GetX ( un ) , GetY ( un ) , GetDir ( un ) ] ) ;
47771: LD_ADDR_EXP 79
47775: PUSH
47776: LD_EXP 79
47780: PPUSH
47781: LD_VAR 0 3
47785: PUSH
47786: LD_EXP 79
47790: PUSH
47791: LD_VAR 0 3
47795: ARRAY
47796: PUSH
47797: LD_INT 1
47799: PLUS
47800: PUSH
47801: EMPTY
47802: LIST
47803: LIST
47804: PPUSH
47805: LD_VAR 0 5
47809: PUSH
47810: LD_VAR 0 1
47814: PPUSH
47815: CALL_OW 250
47819: PUSH
47820: LD_VAR 0 1
47824: PPUSH
47825: CALL_OW 251
47829: PUSH
47830: LD_VAR 0 1
47834: PPUSH
47835: CALL_OW 254
47839: PUSH
47840: EMPTY
47841: LIST
47842: LIST
47843: LIST
47844: LIST
47845: PPUSH
47846: CALL 56953 0 3
47850: ST_TO_ADDR
// if pos = 1 then
47851: LD_VAR 0 6
47855: PUSH
47856: LD_INT 1
47858: EQUAL
47859: IFFALSE 47974
// begin tmp := mc_build_list [ i ] ;
47861: LD_ADDR_VAR 0 7
47865: PUSH
47866: LD_EXP 79
47870: PUSH
47871: LD_VAR 0 3
47875: ARRAY
47876: ST_TO_ADDR
// if UnitFilter ( tmp , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) then
47877: LD_VAR 0 7
47881: PPUSH
47882: LD_INT 2
47884: PUSH
47885: LD_INT 30
47887: PUSH
47888: LD_INT 0
47890: PUSH
47891: EMPTY
47892: LIST
47893: LIST
47894: PUSH
47895: LD_INT 30
47897: PUSH
47898: LD_INT 1
47900: PUSH
47901: EMPTY
47902: LIST
47903: LIST
47904: PUSH
47905: EMPTY
47906: LIST
47907: LIST
47908: LIST
47909: PPUSH
47910: CALL_OW 72
47914: IFFALSE 47924
// pos := 2 ;
47916: LD_ADDR_VAR 0 6
47920: PUSH
47921: LD_INT 2
47923: ST_TO_ADDR
// tmp := ReplaceWith ( tmp , pos , tmp ) ;
47924: LD_ADDR_VAR 0 7
47928: PUSH
47929: LD_VAR 0 7
47933: PPUSH
47934: LD_VAR 0 6
47938: PPUSH
47939: LD_VAR 0 7
47943: PPUSH
47944: CALL 57279 0 3
47948: ST_TO_ADDR
// mc_build_list := Replace ( mc_build_list , i , tmp ) ;
47949: LD_ADDR_EXP 79
47953: PUSH
47954: LD_EXP 79
47958: PPUSH
47959: LD_VAR 0 3
47963: PPUSH
47964: LD_VAR 0 7
47968: PPUSH
47969: CALL_OW 1
47973: ST_TO_ADDR
// end ; end ; if un in mc_bases [ i ] then
47974: LD_VAR 0 1
47978: PUSH
47979: LD_EXP 74
47983: PUSH
47984: LD_VAR 0 3
47988: ARRAY
47989: IN
47990: IFFALSE 48029
// begin mc_bases := Replace ( mc_bases , i , mc_bases [ i ] diff un ) ;
47992: LD_ADDR_EXP 74
47996: PUSH
47997: LD_EXP 74
48001: PPUSH
48002: LD_VAR 0 3
48006: PPUSH
48007: LD_EXP 74
48011: PUSH
48012: LD_VAR 0 3
48016: ARRAY
48017: PUSH
48018: LD_VAR 0 1
48022: DIFF
48023: PPUSH
48024: CALL_OW 1
48028: ST_TO_ADDR
// end ; if un in mc_construct_list [ i ] then
48029: LD_VAR 0 1
48033: PUSH
48034: LD_EXP 81
48038: PUSH
48039: LD_VAR 0 3
48043: ARRAY
48044: IN
48045: IFFALSE 48084
// begin mc_construct_list := Replace ( mc_construct_list , i , mc_construct_list [ i ] diff un ) ;
48047: LD_ADDR_EXP 81
48051: PUSH
48052: LD_EXP 81
48056: PPUSH
48057: LD_VAR 0 3
48061: PPUSH
48062: LD_EXP 81
48066: PUSH
48067: LD_VAR 0 3
48071: ARRAY
48072: PUSH
48073: LD_VAR 0 1
48077: DIFF
48078: PPUSH
48079: CALL_OW 1
48083: ST_TO_ADDR
// end ; if un in mc_vehicles [ i ] then
48084: LD_VAR 0 1
48088: PUSH
48089: LD_EXP 93
48093: PUSH
48094: LD_VAR 0 3
48098: ARRAY
48099: IN
48100: IFFALSE 48139
// begin mc_vehicles := Replace ( mc_vehicles , i , mc_vehicles [ i ] diff un ) ;
48102: LD_ADDR_EXP 93
48106: PUSH
48107: LD_EXP 93
48111: PPUSH
48112: LD_VAR 0 3
48116: PPUSH
48117: LD_EXP 93
48121: PUSH
48122: LD_VAR 0 3
48126: ARRAY
48127: PUSH
48128: LD_VAR 0 1
48132: DIFF
48133: PPUSH
48134: CALL_OW 1
48138: ST_TO_ADDR
// end ; if un in mc_defender [ i ] then
48139: LD_VAR 0 1
48143: PUSH
48144: LD_EXP 96
48148: PUSH
48149: LD_VAR 0 3
48153: ARRAY
48154: IN
48155: IFFALSE 48194
// begin mc_defender := Replace ( mc_defender , i , mc_defender [ i ] diff un ) ;
48157: LD_ADDR_EXP 96
48161: PUSH
48162: LD_EXP 96
48166: PPUSH
48167: LD_VAR 0 3
48171: PPUSH
48172: LD_EXP 96
48176: PUSH
48177: LD_VAR 0 3
48181: ARRAY
48182: PUSH
48183: LD_VAR 0 1
48187: DIFF
48188: PPUSH
48189: CALL_OW 1
48193: ST_TO_ADDR
// end ; if un in mc_empty_turret_list [ i ] then
48194: LD_VAR 0 1
48198: PUSH
48199: LD_EXP 83
48203: PUSH
48204: LD_VAR 0 3
48208: ARRAY
48209: IN
48210: IFFALSE 48249
// begin mc_empty_turret_list := Replace ( mc_empty_turret_list , i , mc_empty_turret_list [ i ] diff un ) ;
48212: LD_ADDR_EXP 83
48216: PUSH
48217: LD_EXP 83
48221: PPUSH
48222: LD_VAR 0 3
48226: PPUSH
48227: LD_EXP 83
48231: PUSH
48232: LD_VAR 0 3
48236: ARRAY
48237: PUSH
48238: LD_VAR 0 1
48242: DIFF
48243: PPUSH
48244: CALL_OW 1
48248: ST_TO_ADDR
// end ; if un in mc_turret_list [ i ] then
48249: LD_VAR 0 1
48253: PUSH
48254: LD_EXP 82
48258: PUSH
48259: LD_VAR 0 3
48263: ARRAY
48264: IN
48265: IFFALSE 48304
// begin mc_turret_list := Replace ( mc_turret_list , i , mc_turret_list [ i ] diff un ) ;
48267: LD_ADDR_EXP 82
48271: PUSH
48272: LD_EXP 82
48276: PPUSH
48277: LD_VAR 0 3
48281: PPUSH
48282: LD_EXP 82
48286: PUSH
48287: LD_VAR 0 3
48291: ARRAY
48292: PUSH
48293: LD_VAR 0 1
48297: DIFF
48298: PPUSH
48299: CALL_OW 1
48303: ST_TO_ADDR
// end ; break ;
48304: GO 48308
// end ;
48306: GO 47088
48308: POP
48309: POP
// end ;
48310: LD_VAR 0 2
48314: RET
// export function MCE_UpgradeComplete ( building ) ; var i , j ; begin
48315: LD_INT 0
48317: PPUSH
48318: PPUSH
48319: PPUSH
// if not mc_bases or not skirmish then
48320: LD_EXP 74
48324: NOT
48325: PUSH
48326: LD_EXP 72
48330: NOT
48331: OR
48332: IFFALSE 48336
// exit ;
48334: GO 48551
// for i = 1 to mc_bases do
48336: LD_ADDR_VAR 0 3
48340: PUSH
48341: DOUBLE
48342: LD_INT 1
48344: DEC
48345: ST_TO_ADDR
48346: LD_EXP 74
48350: PUSH
48351: FOR_TO
48352: IFFALSE 48549
// begin if building in mc_construct_list [ i ] then
48354: LD_VAR 0 1
48358: PUSH
48359: LD_EXP 81
48363: PUSH
48364: LD_VAR 0 3
48368: ARRAY
48369: IN
48370: IFFALSE 48547
// begin mc_construct_list := Replace ( mc_construct_list , i , mc_construct_list [ i ] diff building ) ;
48372: LD_ADDR_EXP 81
48376: PUSH
48377: LD_EXP 81
48381: PPUSH
48382: LD_VAR 0 3
48386: PPUSH
48387: LD_EXP 81
48391: PUSH
48392: LD_VAR 0 3
48396: ARRAY
48397: PUSH
48398: LD_VAR 0 1
48402: DIFF
48403: PPUSH
48404: CALL_OW 1
48408: ST_TO_ADDR
// if building in mc_lab [ i ] then
48409: LD_VAR 0 1
48413: PUSH
48414: LD_EXP 107
48418: PUSH
48419: LD_VAR 0 3
48423: ARRAY
48424: IN
48425: IFFALSE 48480
// mc_lab_upgrade := Replace ( mc_lab_upgrade , i , Reindex ( mc_lab_upgrade [ i ] , 1 , mc_lab_upgrade [ i ] , false ) ) ;
48427: LD_ADDR_EXP 108
48431: PUSH
48432: LD_EXP 108
48436: PPUSH
48437: LD_VAR 0 3
48441: PPUSH
48442: LD_EXP 108
48446: PUSH
48447: LD_VAR 0 3
48451: ARRAY
48452: PPUSH
48453: LD_INT 1
48455: PPUSH
48456: LD_EXP 108
48460: PUSH
48461: LD_VAR 0 3
48465: ARRAY
48466: PPUSH
48467: LD_INT 0
48469: PPUSH
48470: CALL 56371 0 4
48474: PPUSH
48475: CALL_OW 1
48479: ST_TO_ADDR
// if not building in mc_bases [ i ] then
48480: LD_VAR 0 1
48484: PUSH
48485: LD_EXP 74
48489: PUSH
48490: LD_VAR 0 3
48494: ARRAY
48495: IN
48496: NOT
48497: IFFALSE 48543
// mc_bases := ReplaceIn ( mc_bases , [ i , mc_bases [ i ] + 1 ] , building ) ;
48499: LD_ADDR_EXP 74
48503: PUSH
48504: LD_EXP 74
48508: PPUSH
48509: LD_VAR 0 3
48513: PUSH
48514: LD_EXP 74
48518: PUSH
48519: LD_VAR 0 3
48523: ARRAY
48524: PUSH
48525: LD_INT 1
48527: PLUS
48528: PUSH
48529: EMPTY
48530: LIST
48531: LIST
48532: PPUSH
48533: LD_VAR 0 1
48537: PPUSH
48538: CALL 56953 0 3
48542: ST_TO_ADDR
// exit ;
48543: POP
48544: POP
48545: GO 48551
// end ; end ;
48547: GO 48351
48549: POP
48550: POP
// end ;
48551: LD_VAR 0 2
48555: RET
// export function MCE_BuildingComplete ( building ) ; var i , j , btype , tmp , units , side ; begin
48556: LD_INT 0
48558: PPUSH
48559: PPUSH
48560: PPUSH
48561: PPUSH
48562: PPUSH
48563: PPUSH
48564: PPUSH
// if not mc_bases or not skirmish then
48565: LD_EXP 74
48569: NOT
48570: PUSH
48571: LD_EXP 72
48575: NOT
48576: OR
48577: IFFALSE 48581
// exit ;
48579: GO 49242
// for i = 1 to mc_bases do
48581: LD_ADDR_VAR 0 3
48585: PUSH
48586: DOUBLE
48587: LD_INT 1
48589: DEC
48590: ST_TO_ADDR
48591: LD_EXP 74
48595: PUSH
48596: FOR_TO
48597: IFFALSE 49240
// begin if building in mc_construct_list [ i ] then
48599: LD_VAR 0 1
48603: PUSH
48604: LD_EXP 81
48608: PUSH
48609: LD_VAR 0 3
48613: ARRAY
48614: IN
48615: IFFALSE 49238
// begin mc_construct_list := Replace ( mc_construct_list , i , mc_construct_list [ i ] diff building ) ;
48617: LD_ADDR_EXP 81
48621: PUSH
48622: LD_EXP 81
48626: PPUSH
48627: LD_VAR 0 3
48631: PPUSH
48632: LD_EXP 81
48636: PUSH
48637: LD_VAR 0 3
48641: ARRAY
48642: PUSH
48643: LD_VAR 0 1
48647: DIFF
48648: PPUSH
48649: CALL_OW 1
48653: ST_TO_ADDR
// mc_bases := ReplaceIn ( mc_bases , [ i , mc_bases [ i ] + 1 ] , building ) ;
48654: LD_ADDR_EXP 74
48658: PUSH
48659: LD_EXP 74
48663: PPUSH
48664: LD_VAR 0 3
48668: PUSH
48669: LD_EXP 74
48673: PUSH
48674: LD_VAR 0 3
48678: ARRAY
48679: PUSH
48680: LD_INT 1
48682: PLUS
48683: PUSH
48684: EMPTY
48685: LIST
48686: LIST
48687: PPUSH
48688: LD_VAR 0 1
48692: PPUSH
48693: CALL 56953 0 3
48697: ST_TO_ADDR
// btype := GetBType ( building ) ;
48698: LD_ADDR_VAR 0 5
48702: PUSH
48703: LD_VAR 0 1
48707: PPUSH
48708: CALL_OW 266
48712: ST_TO_ADDR
// side := GetSide ( building ) ;
48713: LD_ADDR_VAR 0 8
48717: PUSH
48718: LD_VAR 0 1
48722: PPUSH
48723: CALL_OW 255
48727: ST_TO_ADDR
// if btype = b_lab then
48728: LD_VAR 0 5
48732: PUSH
48733: LD_INT 6
48735: EQUAL
48736: IFFALSE 48786
// begin mc_lab := ReplaceIn ( mc_lab , [ i , mc_lab [ i ] + 1 ] , building ) ;
48738: LD_ADDR_EXP 107
48742: PUSH
48743: LD_EXP 107
48747: PPUSH
48748: LD_VAR 0 3
48752: PUSH
48753: LD_EXP 107
48757: PUSH
48758: LD_VAR 0 3
48762: ARRAY
48763: PUSH
48764: LD_INT 1
48766: PLUS
48767: PUSH
48768: EMPTY
48769: LIST
48770: LIST
48771: PPUSH
48772: LD_VAR 0 1
48776: PPUSH
48777: CALL 56953 0 3
48781: ST_TO_ADDR
// exit ;
48782: POP
48783: POP
48784: GO 49242
// end ; if btype in [ b_depot , b_workshop , b_armoury ] then
48786: LD_VAR 0 5
48790: PUSH
48791: LD_INT 0
48793: PUSH
48794: LD_INT 2
48796: PUSH
48797: LD_INT 4
48799: PUSH
48800: EMPTY
48801: LIST
48802: LIST
48803: LIST
48804: IN
48805: IFFALSE 48929
// begin if btype = b_armoury then
48807: LD_VAR 0 5
48811: PUSH
48812: LD_INT 4
48814: EQUAL
48815: IFFALSE 48825
// btype := b_barracks ;
48817: LD_ADDR_VAR 0 5
48821: PUSH
48822: LD_INT 5
48824: ST_TO_ADDR
// if btype = b_depot then
48825: LD_VAR 0 5
48829: PUSH
48830: LD_INT 0
48832: EQUAL
48833: IFFALSE 48843
// btype := b_warehouse ;
48835: LD_ADDR_VAR 0 5
48839: PUSH
48840: LD_INT 1
48842: ST_TO_ADDR
// if btype = b_workshop then
48843: LD_VAR 0 5
48847: PUSH
48848: LD_INT 2
48850: EQUAL
48851: IFFALSE 48861
// btype := b_factory ;
48853: LD_ADDR_VAR 0 5
48857: PUSH
48858: LD_INT 3
48860: ST_TO_ADDR
// if GetRestrict ( btype , side ) = state_enabled then
48861: LD_VAR 0 5
48865: PPUSH
48866: LD_VAR 0 8
48870: PPUSH
48871: CALL_OW 323
48875: PUSH
48876: LD_INT 1
48878: EQUAL
48879: IFFALSE 48925
// mc_build_upgrade := ReplaceIn ( mc_build_upgrade , [ i , mc_build_upgrade [ i ] + 1 ] , building ) ;
48881: LD_ADDR_EXP 106
48885: PUSH
48886: LD_EXP 106
48890: PPUSH
48891: LD_VAR 0 3
48895: PUSH
48896: LD_EXP 106
48900: PUSH
48901: LD_VAR 0 3
48905: ARRAY
48906: PUSH
48907: LD_INT 1
48909: PLUS
48910: PUSH
48911: EMPTY
48912: LIST
48913: LIST
48914: PPUSH
48915: LD_VAR 0 1
48919: PPUSH
48920: CALL 56953 0 3
48924: ST_TO_ADDR
// exit ;
48925: POP
48926: POP
48927: GO 49242
// end ; if btype in [ b_bunker , b_turret ] then
48929: LD_VAR 0 5
48933: PUSH
48934: LD_INT 32
48936: PUSH
48937: LD_INT 33
48939: PUSH
48940: EMPTY
48941: LIST
48942: LIST
48943: IN
48944: IFFALSE 49234
// begin mc_turret_list := ReplaceIn ( mc_turret_list , [ i , mc_turret_list [ i ] + 1 ] , building ) ;
48946: LD_ADDR_EXP 82
48950: PUSH
48951: LD_EXP 82
48955: PPUSH
48956: LD_VAR 0 3
48960: PUSH
48961: LD_EXP 82
48965: PUSH
48966: LD_VAR 0 3
48970: ARRAY
48971: PUSH
48972: LD_INT 1
48974: PLUS
48975: PUSH
48976: EMPTY
48977: LIST
48978: LIST
48979: PPUSH
48980: LD_VAR 0 1
48984: PPUSH
48985: CALL 56953 0 3
48989: ST_TO_ADDR
// if btype = b_bunker then
48990: LD_VAR 0 5
48994: PUSH
48995: LD_INT 32
48997: EQUAL
48998: IFFALSE 49234
// begin mc_empty_turret_list := ReplaceIn ( mc_empty_turret_list , [ i , mc_empty_turret_list [ i ] + 1 ] , building ) ;
49000: LD_ADDR_EXP 83
49004: PUSH
49005: LD_EXP 83
49009: PPUSH
49010: LD_VAR 0 3
49014: PUSH
49015: LD_EXP 83
49019: PUSH
49020: LD_VAR 0 3
49024: ARRAY
49025: PUSH
49026: LD_INT 1
49028: PLUS
49029: PUSH
49030: EMPTY
49031: LIST
49032: LIST
49033: PPUSH
49034: LD_VAR 0 1
49038: PPUSH
49039: CALL 56953 0 3
49043: ST_TO_ADDR
// tmp := UnitFilter ( mc_bases [ i ] , [ [ f_class , 1 ] , [ f_not , [ f_inside ] ] ] ) ;
49044: LD_ADDR_VAR 0 6
49048: PUSH
49049: LD_EXP 74
49053: PUSH
49054: LD_VAR 0 3
49058: ARRAY
49059: PPUSH
49060: LD_INT 25
49062: PUSH
49063: LD_INT 1
49065: PUSH
49066: EMPTY
49067: LIST
49068: LIST
49069: PUSH
49070: LD_INT 3
49072: PUSH
49073: LD_INT 54
49075: PUSH
49076: EMPTY
49077: LIST
49078: PUSH
49079: EMPTY
49080: LIST
49081: LIST
49082: PUSH
49083: EMPTY
49084: LIST
49085: LIST
49086: PPUSH
49087: CALL_OW 72
49091: ST_TO_ADDR
// if tmp then
49092: LD_VAR 0 6
49096: IFFALSE 49102
// exit ;
49098: POP
49099: POP
49100: GO 49242
// tmp := UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_armoury ] , [ f_btype , b_barracks ] ] ) ;
49102: LD_ADDR_VAR 0 6
49106: PUSH
49107: LD_EXP 74
49111: PUSH
49112: LD_VAR 0 3
49116: ARRAY
49117: PPUSH
49118: LD_INT 2
49120: PUSH
49121: LD_INT 30
49123: PUSH
49124: LD_INT 4
49126: PUSH
49127: EMPTY
49128: LIST
49129: LIST
49130: PUSH
49131: LD_INT 30
49133: PUSH
49134: LD_INT 5
49136: PUSH
49137: EMPTY
49138: LIST
49139: LIST
49140: PUSH
49141: EMPTY
49142: LIST
49143: LIST
49144: LIST
49145: PPUSH
49146: CALL_OW 72
49150: ST_TO_ADDR
// if not tmp then
49151: LD_VAR 0 6
49155: NOT
49156: IFFALSE 49162
// exit ;
49158: POP
49159: POP
49160: GO 49242
// for j in tmp do
49162: LD_ADDR_VAR 0 4
49166: PUSH
49167: LD_VAR 0 6
49171: PUSH
49172: FOR_IN
49173: IFFALSE 49232
// begin units := UnitFilter ( UnitsInside ( j ) , [ f_class , 1 ] ) ;
49175: LD_ADDR_VAR 0 7
49179: PUSH
49180: LD_VAR 0 4
49184: PPUSH
49185: CALL_OW 313
49189: PPUSH
49190: LD_INT 25
49192: PUSH
49193: LD_INT 1
49195: PUSH
49196: EMPTY
49197: LIST
49198: LIST
49199: PPUSH
49200: CALL_OW 72
49204: ST_TO_ADDR
// if units then
49205: LD_VAR 0 7
49209: IFFALSE 49230
// begin ComExitBuilding ( units [ 1 ] ) ;
49211: LD_VAR 0 7
49215: PUSH
49216: LD_INT 1
49218: ARRAY
49219: PPUSH
49220: CALL_OW 122
// exit ;
49224: POP
49225: POP
49226: POP
49227: POP
49228: GO 49242
// end ; end ;
49230: GO 49172
49232: POP
49233: POP
// end ; end ; exit ;
49234: POP
49235: POP
49236: GO 49242
// end ; end ;
49238: GO 48596
49240: POP
49241: POP
// end ;
49242: LD_VAR 0 2
49246: RET
// export function MCE_BuildingStarted ( building , builder ) ; var i , j , btype , x , y , d ; begin
49247: LD_INT 0
49249: PPUSH
49250: PPUSH
49251: PPUSH
49252: PPUSH
49253: PPUSH
49254: PPUSH
49255: PPUSH
// if not mc_bases or not skirmish then
49256: LD_EXP 74
49260: NOT
49261: PUSH
49262: LD_EXP 72
49266: NOT
49267: OR
49268: IFFALSE 49272
// exit ;
49270: GO 49503
// btype := GetBType ( building ) ;
49272: LD_ADDR_VAR 0 6
49276: PUSH
49277: LD_VAR 0 1
49281: PPUSH
49282: CALL_OW 266
49286: ST_TO_ADDR
// x := GetX ( building ) ;
49287: LD_ADDR_VAR 0 7
49291: PUSH
49292: LD_VAR 0 1
49296: PPUSH
49297: CALL_OW 250
49301: ST_TO_ADDR
// y := GetY ( building ) ;
49302: LD_ADDR_VAR 0 8
49306: PUSH
49307: LD_VAR 0 1
49311: PPUSH
49312: CALL_OW 251
49316: ST_TO_ADDR
// d := GetDir ( building ) ;
49317: LD_ADDR_VAR 0 9
49321: PUSH
49322: LD_VAR 0 1
49326: PPUSH
49327: CALL_OW 254
49331: ST_TO_ADDR
// for i = 1 to mc_bases do
49332: LD_ADDR_VAR 0 4
49336: PUSH
49337: DOUBLE
49338: LD_INT 1
49340: DEC
49341: ST_TO_ADDR
49342: LD_EXP 74
49346: PUSH
49347: FOR_TO
49348: IFFALSE 49501
// begin if not mc_build_list [ i ] then
49350: LD_EXP 79
49354: PUSH
49355: LD_VAR 0 4
49359: ARRAY
49360: NOT
49361: IFFALSE 49365
// continue ;
49363: GO 49347
// if CompareArray ( [ btype , x , y , d ] , mc_build_list [ i ] [ 1 ] ) then
49365: LD_VAR 0 6
49369: PUSH
49370: LD_VAR 0 7
49374: PUSH
49375: LD_VAR 0 8
49379: PUSH
49380: LD_VAR 0 9
49384: PUSH
49385: EMPTY
49386: LIST
49387: LIST
49388: LIST
49389: LIST
49390: PPUSH
49391: LD_EXP 79
49395: PUSH
49396: LD_VAR 0 4
49400: ARRAY
49401: PUSH
49402: LD_INT 1
49404: ARRAY
49405: PPUSH
49406: CALL 63122 0 2
49410: IFFALSE 49499
// begin mc_build_list := Replace ( mc_build_list , i , Delete ( mc_build_list [ i ] , 1 ) ) ;
49412: LD_ADDR_EXP 79
49416: PUSH
49417: LD_EXP 79
49421: PPUSH
49422: LD_VAR 0 4
49426: PPUSH
49427: LD_EXP 79
49431: PUSH
49432: LD_VAR 0 4
49436: ARRAY
49437: PPUSH
49438: LD_INT 1
49440: PPUSH
49441: CALL_OW 3
49445: PPUSH
49446: CALL_OW 1
49450: ST_TO_ADDR
// mc_construct_list := ReplaceIn ( mc_construct_list , [ i , mc_construct_list [ i ] + 1 ] , building ) ;
49451: LD_ADDR_EXP 81
49455: PUSH
49456: LD_EXP 81
49460: PPUSH
49461: LD_VAR 0 4
49465: PUSH
49466: LD_EXP 81
49470: PUSH
49471: LD_VAR 0 4
49475: ARRAY
49476: PUSH
49477: LD_INT 1
49479: PLUS
49480: PUSH
49481: EMPTY
49482: LIST
49483: LIST
49484: PPUSH
49485: LD_VAR 0 1
49489: PPUSH
49490: CALL 56953 0 3
49494: ST_TO_ADDR
// exit ;
49495: POP
49496: POP
49497: GO 49503
// end ; end ;
49499: GO 49347
49501: POP
49502: POP
// end ;
49503: LD_VAR 0 3
49507: RET
// export function MCE_LeaveBuilding ( building , unit ) ; var i , tmp ; begin
49508: LD_INT 0
49510: PPUSH
49511: PPUSH
49512: PPUSH
// if not mc_bases or not skirmish then
49513: LD_EXP 74
49517: NOT
49518: PUSH
49519: LD_EXP 72
49523: NOT
49524: OR
49525: IFFALSE 49529
// exit ;
49527: GO 49719
// for i = 1 to mc_bases do
49529: LD_ADDR_VAR 0 4
49533: PUSH
49534: DOUBLE
49535: LD_INT 1
49537: DEC
49538: ST_TO_ADDR
49539: LD_EXP 74
49543: PUSH
49544: FOR_TO
49545: IFFALSE 49632
// begin if building in mc_turret_list [ i ] and not building in mc_empty_turret_list [ i ] then
49547: LD_VAR 0 1
49551: PUSH
49552: LD_EXP 82
49556: PUSH
49557: LD_VAR 0 4
49561: ARRAY
49562: IN
49563: PUSH
49564: LD_VAR 0 1
49568: PUSH
49569: LD_EXP 83
49573: PUSH
49574: LD_VAR 0 4
49578: ARRAY
49579: IN
49580: NOT
49581: AND
49582: IFFALSE 49630
// begin mc_empty_turret_list := ReplaceIn ( mc_empty_turret_list , [ i , mc_empty_turret_list [ i ] + 1 ] , building ) ;
49584: LD_ADDR_EXP 83
49588: PUSH
49589: LD_EXP 83
49593: PPUSH
49594: LD_VAR 0 4
49598: PUSH
49599: LD_EXP 83
49603: PUSH
49604: LD_VAR 0 4
49608: ARRAY
49609: PUSH
49610: LD_INT 1
49612: PLUS
49613: PUSH
49614: EMPTY
49615: LIST
49616: LIST
49617: PPUSH
49618: LD_VAR 0 1
49622: PPUSH
49623: CALL 56953 0 3
49627: ST_TO_ADDR
// break ;
49628: GO 49632
// end ; end ;
49630: GO 49544
49632: POP
49633: POP
// if GetClass ( building ) in mc_sides and GetBType ( building ) = b_barracks and GetTag ( unit ) <> 18 then
49634: LD_VAR 0 1
49638: PPUSH
49639: CALL_OW 257
49643: PUSH
49644: LD_EXP 100
49648: IN
49649: PUSH
49650: LD_VAR 0 1
49654: PPUSH
49655: CALL_OW 266
49659: PUSH
49660: LD_INT 5
49662: EQUAL
49663: AND
49664: PUSH
49665: LD_VAR 0 2
49669: PPUSH
49670: CALL_OW 110
49674: PUSH
49675: LD_INT 18
49677: NONEQUAL
49678: AND
49679: IFFALSE 49719
// if GetClass ( unit ) in [ 5 , 8 , 9 ] then
49681: LD_VAR 0 2
49685: PPUSH
49686: CALL_OW 257
49690: PUSH
49691: LD_INT 5
49693: PUSH
49694: LD_INT 8
49696: PUSH
49697: LD_INT 9
49699: PUSH
49700: EMPTY
49701: LIST
49702: LIST
49703: LIST
49704: IN
49705: IFFALSE 49719
// SetClass ( unit , 1 ) ;
49707: LD_VAR 0 2
49711: PPUSH
49712: LD_INT 1
49714: PPUSH
49715: CALL_OW 336
// end ;
49719: LD_VAR 0 3
49723: RET
// export function MCE_EvacuateVehicle ( driver , abandoned_vehicle , unknown1 , unknown2 ) ; var i ; begin
49724: LD_INT 0
49726: PPUSH
49727: PPUSH
// if not mc_bases or not skirmish then
49728: LD_EXP 74
49732: NOT
49733: PUSH
49734: LD_EXP 72
49738: NOT
49739: OR
49740: IFFALSE 49744
// exit ;
49742: GO 49860
// if GetLives ( abandoned_vehicle ) > 250 then
49744: LD_VAR 0 2
49748: PPUSH
49749: CALL_OW 256
49753: PUSH
49754: LD_INT 250
49756: GREATER
49757: IFFALSE 49761
// exit ;
49759: GO 49860
// for i = 1 to mc_bases do
49761: LD_ADDR_VAR 0 6
49765: PUSH
49766: DOUBLE
49767: LD_INT 1
49769: DEC
49770: ST_TO_ADDR
49771: LD_EXP 74
49775: PUSH
49776: FOR_TO
49777: IFFALSE 49858
// begin if driver in mc_bases [ i ] then
49779: LD_VAR 0 1
49783: PUSH
49784: LD_EXP 74
49788: PUSH
49789: LD_VAR 0 6
49793: ARRAY
49794: IN
49795: IFFALSE 49856
// begin ComMoveUnit ( driver , UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) [ 1 ] ) ;
49797: LD_VAR 0 1
49801: PPUSH
49802: LD_EXP 74
49806: PUSH
49807: LD_VAR 0 6
49811: ARRAY
49812: PPUSH
49813: LD_INT 2
49815: PUSH
49816: LD_INT 30
49818: PUSH
49819: LD_INT 0
49821: PUSH
49822: EMPTY
49823: LIST
49824: LIST
49825: PUSH
49826: LD_INT 30
49828: PUSH
49829: LD_INT 1
49831: PUSH
49832: EMPTY
49833: LIST
49834: LIST
49835: PUSH
49836: EMPTY
49837: LIST
49838: LIST
49839: LIST
49840: PPUSH
49841: CALL_OW 72
49845: PUSH
49846: LD_INT 1
49848: ARRAY
49849: PPUSH
49850: CALL_OW 112
// break ;
49854: GO 49858
// end ; end ;
49856: GO 49776
49858: POP
49859: POP
// end ; end_of_file
49860: LD_VAR 0 5
49864: RET
// export function PrepareUnit ( ident , exist_mode , prefix ) ; var unit ; begin
49865: LD_INT 0
49867: PPUSH
49868: PPUSH
// if exist_mode then
49869: LD_VAR 0 2
49873: IFFALSE 49898
// unit := CreateCharacter ( prefix & ident ) else
49875: LD_ADDR_VAR 0 5
49879: PUSH
49880: LD_VAR 0 3
49884: PUSH
49885: LD_VAR 0 1
49889: STR
49890: PPUSH
49891: CALL_OW 34
49895: ST_TO_ADDR
49896: GO 49913
// unit := NewCharacter ( ident ) ;
49898: LD_ADDR_VAR 0 5
49902: PUSH
49903: LD_VAR 0 1
49907: PPUSH
49908: CALL_OW 25
49912: ST_TO_ADDR
// result := unit ;
49913: LD_ADDR_VAR 0 4
49917: PUSH
49918: LD_VAR 0 5
49922: ST_TO_ADDR
// end ;
49923: LD_VAR 0 4
49927: RET
// export function GetTechNation ( side , nation , state ) ; var i ; begin
49928: LD_INT 0
49930: PPUSH
49931: PPUSH
// if not side or not nation then
49932: LD_VAR 0 1
49936: NOT
49937: PUSH
49938: LD_VAR 0 2
49942: NOT
49943: OR
49944: IFFALSE 49948
// exit ;
49946: GO 50592
// case nation of nation_american :
49948: LD_VAR 0 2
49952: PUSH
49953: LD_INT 1
49955: DOUBLE
49956: EQUAL
49957: IFTRUE 49961
49959: GO 50135
49961: POP
// result := [ 35 , 45 , 46 , 47 , 1 , 2 , 6 , 15 , 16 , 7 , 12 , 13 , 10 , 14 , 20 , 21 , 22 , 25 , 32 , 27 , 36 , 69 , 39 , 34 , 40 , 48 , 49 , 50 , 51 , 52 , 53 , 54 , 55 , 56 , 57 , 58 , 59 , 60 , 61 , 62 , 80 ] ; nation_arabian :
49962: LD_ADDR_VAR 0 4
49966: PUSH
49967: LD_INT 35
49969: PUSH
49970: LD_INT 45
49972: PUSH
49973: LD_INT 46
49975: PUSH
49976: LD_INT 47
49978: PUSH
49979: LD_INT 1
49981: PUSH
49982: LD_INT 2
49984: PUSH
49985: LD_INT 6
49987: PUSH
49988: LD_INT 15
49990: PUSH
49991: LD_INT 16
49993: PUSH
49994: LD_INT 7
49996: PUSH
49997: LD_INT 12
49999: PUSH
50000: LD_INT 13
50002: PUSH
50003: LD_INT 10
50005: PUSH
50006: LD_INT 14
50008: PUSH
50009: LD_INT 20
50011: PUSH
50012: LD_INT 21
50014: PUSH
50015: LD_INT 22
50017: PUSH
50018: LD_INT 25
50020: PUSH
50021: LD_INT 32
50023: PUSH
50024: LD_INT 27
50026: PUSH
50027: LD_INT 36
50029: PUSH
50030: LD_INT 69
50032: PUSH
50033: LD_INT 39
50035: PUSH
50036: LD_INT 34
50038: PUSH
50039: LD_INT 40
50041: PUSH
50042: LD_INT 48
50044: PUSH
50045: LD_INT 49
50047: PUSH
50048: LD_INT 50
50050: PUSH
50051: LD_INT 51
50053: PUSH
50054: LD_INT 52
50056: PUSH
50057: LD_INT 53
50059: PUSH
50060: LD_INT 54
50062: PUSH
50063: LD_INT 55
50065: PUSH
50066: LD_INT 56
50068: PUSH
50069: LD_INT 57
50071: PUSH
50072: LD_INT 58
50074: PUSH
50075: LD_INT 59
50077: PUSH
50078: LD_INT 60
50080: PUSH
50081: LD_INT 61
50083: PUSH
50084: LD_INT 62
50086: PUSH
50087: LD_INT 80
50089: PUSH
50090: EMPTY
50091: LIST
50092: LIST
50093: LIST
50094: LIST
50095: LIST
50096: LIST
50097: LIST
50098: LIST
50099: LIST
50100: LIST
50101: LIST
50102: LIST
50103: LIST
50104: LIST
50105: LIST
50106: LIST
50107: LIST
50108: LIST
50109: LIST
50110: LIST
50111: LIST
50112: LIST
50113: LIST
50114: LIST
50115: LIST
50116: LIST
50117: LIST
50118: LIST
50119: LIST
50120: LIST
50121: LIST
50122: LIST
50123: LIST
50124: LIST
50125: LIST
50126: LIST
50127: LIST
50128: LIST
50129: LIST
50130: LIST
50131: LIST
50132: ST_TO_ADDR
50133: GO 50516
50135: LD_INT 2
50137: DOUBLE
50138: EQUAL
50139: IFTRUE 50143
50141: GO 50325
50143: POP
// result := [ 35 , 45 , 46 , 47 , 70 , 1 , 11 , 3 , 4 , 5 , 6 , 15 , 18 , 7 , 17 , 8 , 20 , 21 , 22 , 72 , 26 , 69 , 39 , 40 , 41 , 42 , 43 , 48 , 49 , 50 , 51 , 52 , 53 , 54 , 55 , 56 , 60 , 61 , 62 , 66 , 67 , 68 , 81 ] ; nation_russian :
50144: LD_ADDR_VAR 0 4
50148: PUSH
50149: LD_INT 35
50151: PUSH
50152: LD_INT 45
50154: PUSH
50155: LD_INT 46
50157: PUSH
50158: LD_INT 47
50160: PUSH
50161: LD_INT 70
50163: PUSH
50164: LD_INT 1
50166: PUSH
50167: LD_INT 11
50169: PUSH
50170: LD_INT 3
50172: PUSH
50173: LD_INT 4
50175: PUSH
50176: LD_INT 5
50178: PUSH
50179: LD_INT 6
50181: PUSH
50182: LD_INT 15
50184: PUSH
50185: LD_INT 18
50187: PUSH
50188: LD_INT 7
50190: PUSH
50191: LD_INT 17
50193: PUSH
50194: LD_INT 8
50196: PUSH
50197: LD_INT 20
50199: PUSH
50200: LD_INT 21
50202: PUSH
50203: LD_INT 22
50205: PUSH
50206: LD_INT 72
50208: PUSH
50209: LD_INT 26
50211: PUSH
50212: LD_INT 69
50214: PUSH
50215: LD_INT 39
50217: PUSH
50218: LD_INT 40
50220: PUSH
50221: LD_INT 41
50223: PUSH
50224: LD_INT 42
50226: PUSH
50227: LD_INT 43
50229: PUSH
50230: LD_INT 48
50232: PUSH
50233: LD_INT 49
50235: PUSH
50236: LD_INT 50
50238: PUSH
50239: LD_INT 51
50241: PUSH
50242: LD_INT 52
50244: PUSH
50245: LD_INT 53
50247: PUSH
50248: LD_INT 54
50250: PUSH
50251: LD_INT 55
50253: PUSH
50254: LD_INT 56
50256: PUSH
50257: LD_INT 60
50259: PUSH
50260: LD_INT 61
50262: PUSH
50263: LD_INT 62
50265: PUSH
50266: LD_INT 66
50268: PUSH
50269: LD_INT 67
50271: PUSH
50272: LD_INT 68
50274: PUSH
50275: LD_INT 81
50277: PUSH
50278: EMPTY
50279: LIST
50280: LIST
50281: LIST
50282: LIST
50283: LIST
50284: LIST
50285: LIST
50286: LIST
50287: LIST
50288: LIST
50289: LIST
50290: LIST
50291: LIST
50292: LIST
50293: LIST
50294: LIST
50295: LIST
50296: LIST
50297: LIST
50298: LIST
50299: LIST
50300: LIST
50301: LIST
50302: LIST
50303: LIST
50304: LIST
50305: LIST
50306: LIST
50307: LIST
50308: LIST
50309: LIST
50310: LIST
50311: LIST
50312: LIST
50313: LIST
50314: LIST
50315: LIST
50316: LIST
50317: LIST
50318: LIST
50319: LIST
50320: LIST
50321: LIST
50322: ST_TO_ADDR
50323: GO 50516
50325: LD_INT 3
50327: DOUBLE
50328: EQUAL
50329: IFTRUE 50333
50331: GO 50515
50333: POP
// result := [ 46 , 47 , 1 , 2 , 11 , 9 , 20 , 19 , 21 , 24 , 22 , 25 , 28 , 29 , 30 , 31 , 37 , 38 , 32 , 27 , 33 , 69 , 39 , 34 , 40 , 71 , 23 , 44 , 48 , 49 , 50 , 51 , 52 , 53 , 54 , 55 , 56 , 57 , 58 , 59 , 63 , 64 , 65 ] ; end ;
50334: LD_ADDR_VAR 0 4
50338: PUSH
50339: LD_INT 46
50341: PUSH
50342: LD_INT 47
50344: PUSH
50345: LD_INT 1
50347: PUSH
50348: LD_INT 2
50350: PUSH
50351: LD_INT 11
50353: PUSH
50354: LD_INT 9
50356: PUSH
50357: LD_INT 20
50359: PUSH
50360: LD_INT 19
50362: PUSH
50363: LD_INT 21
50365: PUSH
50366: LD_INT 24
50368: PUSH
50369: LD_INT 22
50371: PUSH
50372: LD_INT 25
50374: PUSH
50375: LD_INT 28
50377: PUSH
50378: LD_INT 29
50380: PUSH
50381: LD_INT 30
50383: PUSH
50384: LD_INT 31
50386: PUSH
50387: LD_INT 37
50389: PUSH
50390: LD_INT 38
50392: PUSH
50393: LD_INT 32
50395: PUSH
50396: LD_INT 27
50398: PUSH
50399: LD_INT 33
50401: PUSH
50402: LD_INT 69
50404: PUSH
50405: LD_INT 39
50407: PUSH
50408: LD_INT 34
50410: PUSH
50411: LD_INT 40
50413: PUSH
50414: LD_INT 71
50416: PUSH
50417: LD_INT 23
50419: PUSH
50420: LD_INT 44
50422: PUSH
50423: LD_INT 48
50425: PUSH
50426: LD_INT 49
50428: PUSH
50429: LD_INT 50
50431: PUSH
50432: LD_INT 51
50434: PUSH
50435: LD_INT 52
50437: PUSH
50438: LD_INT 53
50440: PUSH
50441: LD_INT 54
50443: PUSH
50444: LD_INT 55
50446: PUSH
50447: LD_INT 56
50449: PUSH
50450: LD_INT 57
50452: PUSH
50453: LD_INT 58
50455: PUSH
50456: LD_INT 59
50458: PUSH
50459: LD_INT 63
50461: PUSH
50462: LD_INT 64
50464: PUSH
50465: LD_INT 65
50467: PUSH
50468: EMPTY
50469: LIST
50470: LIST
50471: LIST
50472: LIST
50473: LIST
50474: LIST
50475: LIST
50476: LIST
50477: LIST
50478: LIST
50479: LIST
50480: LIST
50481: LIST
50482: LIST
50483: LIST
50484: LIST
50485: LIST
50486: LIST
50487: LIST
50488: LIST
50489: LIST
50490: LIST
50491: LIST
50492: LIST
50493: LIST
50494: LIST
50495: LIST
50496: LIST
50497: LIST
50498: LIST
50499: LIST
50500: LIST
50501: LIST
50502: LIST
50503: LIST
50504: LIST
50505: LIST
50506: LIST
50507: LIST
50508: LIST
50509: LIST
50510: LIST
50511: LIST
50512: ST_TO_ADDR
50513: GO 50516
50515: POP
// if state > - 1 and state < 3 then
50516: LD_VAR 0 3
50520: PUSH
50521: LD_INT 1
50523: NEG
50524: GREATER
50525: PUSH
50526: LD_VAR 0 3
50530: PUSH
50531: LD_INT 3
50533: LESS
50534: AND
50535: IFFALSE 50592
// for i in result do
50537: LD_ADDR_VAR 0 5
50541: PUSH
50542: LD_VAR 0 4
50546: PUSH
50547: FOR_IN
50548: IFFALSE 50590
// if GetTech ( i , side ) <> state then
50550: LD_VAR 0 5
50554: PPUSH
50555: LD_VAR 0 1
50559: PPUSH
50560: CALL_OW 321
50564: PUSH
50565: LD_VAR 0 3
50569: NONEQUAL
50570: IFFALSE 50588
// result := result diff i ;
50572: LD_ADDR_VAR 0 4
50576: PUSH
50577: LD_VAR 0 4
50581: PUSH
50582: LD_VAR 0 5
50586: DIFF
50587: ST_TO_ADDR
50588: GO 50547
50590: POP
50591: POP
// end ;
50592: LD_VAR 0 4
50596: RET
// export function TechCanBeResearch ( side , tech ) ; var i , tmp ; begin
50597: LD_INT 0
50599: PPUSH
50600: PPUSH
50601: PPUSH
// result := true ;
50602: LD_ADDR_VAR 0 3
50606: PUSH
50607: LD_INT 1
50609: ST_TO_ADDR
// tmp := GetTechTechsReq ( tech ) ;
50610: LD_ADDR_VAR 0 5
50614: PUSH
50615: LD_VAR 0 2
50619: PPUSH
50620: CALL_OW 480
50624: ST_TO_ADDR
// if not tmp then
50625: LD_VAR 0 5
50629: NOT
50630: IFFALSE 50634
// exit ;
50632: GO 50683
// for i in tmp do
50634: LD_ADDR_VAR 0 4
50638: PUSH
50639: LD_VAR 0 5
50643: PUSH
50644: FOR_IN
50645: IFFALSE 50681
// if GetTech ( i , side ) <> state_researched then
50647: LD_VAR 0 4
50651: PPUSH
50652: LD_VAR 0 1
50656: PPUSH
50657: CALL_OW 321
50661: PUSH
50662: LD_INT 2
50664: NONEQUAL
50665: IFFALSE 50679
// begin result := false ;
50667: LD_ADDR_VAR 0 3
50671: PUSH
50672: LD_INT 0
50674: ST_TO_ADDR
// exit ;
50675: POP
50676: POP
50677: GO 50683
// end ;
50679: GO 50644
50681: POP
50682: POP
// end ;
50683: LD_VAR 0 3
50687: RET
// export function ComSpaceTimeShoot ( unit ) ; var i , x , y , _x , _y , tmp , side , enemy , in_unit , tech_space , tech_time , missile ; begin
50688: LD_INT 0
50690: PPUSH
50691: PPUSH
50692: PPUSH
50693: PPUSH
50694: PPUSH
50695: PPUSH
50696: PPUSH
50697: PPUSH
50698: PPUSH
50699: PPUSH
50700: PPUSH
50701: PPUSH
50702: PPUSH
// if not unit or GetClass ( unit ) <> class_bazooker then
50703: LD_VAR 0 1
50707: NOT
50708: PUSH
50709: LD_VAR 0 1
50713: PPUSH
50714: CALL_OW 257
50718: PUSH
50719: LD_INT 9
50721: NONEQUAL
50722: OR
50723: IFFALSE 50727
// exit ;
50725: GO 51300
// side := GetSide ( unit ) ;
50727: LD_ADDR_VAR 0 9
50731: PUSH
50732: LD_VAR 0 1
50736: PPUSH
50737: CALL_OW 255
50741: ST_TO_ADDR
// tech_space := tech_spacanom ;
50742: LD_ADDR_VAR 0 12
50746: PUSH
50747: LD_INT 29
50749: ST_TO_ADDR
// tech_time := tech_taurad ;
50750: LD_ADDR_VAR 0 13
50754: PUSH
50755: LD_INT 28
50757: ST_TO_ADDR
// in_unit := IsInUnit ( unit ) ;
50758: LD_ADDR_VAR 0 11
50762: PUSH
50763: LD_VAR 0 1
50767: PPUSH
50768: CALL_OW 310
50772: ST_TO_ADDR
// if GetType ( in_unit ) = unit_vehicle then
50773: LD_VAR 0 11
50777: PPUSH
50778: CALL_OW 247
50782: PUSH
50783: LD_INT 2
50785: EQUAL
50786: IFFALSE 50790
// exit ;
50788: GO 51300
// tmp := FilterAllUnits ( [ [ f_enemy , side ] , [ f_not , [ f_type , unit_building ] ] ] ) ;
50790: LD_ADDR_VAR 0 8
50794: PUSH
50795: LD_INT 81
50797: PUSH
50798: LD_VAR 0 9
50802: PUSH
50803: EMPTY
50804: LIST
50805: LIST
50806: PUSH
50807: LD_INT 3
50809: PUSH
50810: LD_INT 21
50812: PUSH
50813: LD_INT 3
50815: PUSH
50816: EMPTY
50817: LIST
50818: LIST
50819: PUSH
50820: EMPTY
50821: LIST
50822: LIST
50823: PUSH
50824: EMPTY
50825: LIST
50826: LIST
50827: PPUSH
50828: CALL_OW 69
50832: ST_TO_ADDR
// if not tmp then
50833: LD_VAR 0 8
50837: NOT
50838: IFFALSE 50842
// exit ;
50840: GO 51300
// if in_unit then
50842: LD_VAR 0 11
50846: IFFALSE 50870
// enemy := NearestUnitToUnit ( tmp , in_unit ) else
50848: LD_ADDR_VAR 0 10
50852: PUSH
50853: LD_VAR 0 8
50857: PPUSH
50858: LD_VAR 0 11
50862: PPUSH
50863: CALL_OW 74
50867: ST_TO_ADDR
50868: GO 50890
// enemy := NearestUnitToUnit ( tmp , unit ) ;
50870: LD_ADDR_VAR 0 10
50874: PUSH
50875: LD_VAR 0 8
50879: PPUSH
50880: LD_VAR 0 1
50884: PPUSH
50885: CALL_OW 74
50889: ST_TO_ADDR
// if not enemy then
50890: LD_VAR 0 10
50894: NOT
50895: IFFALSE 50899
// exit ;
50897: GO 51300
// if ( in_unit and GetDistUnits ( in_unit , enemy ) > 13 ) or GetDistUnits ( unit , enemy ) > 12 then
50899: LD_VAR 0 11
50903: PUSH
50904: LD_VAR 0 11
50908: PPUSH
50909: LD_VAR 0 10
50913: PPUSH
50914: CALL_OW 296
50918: PUSH
50919: LD_INT 13
50921: GREATER
50922: AND
50923: PUSH
50924: LD_VAR 0 1
50928: PPUSH
50929: LD_VAR 0 10
50933: PPUSH
50934: CALL_OW 296
50938: PUSH
50939: LD_INT 12
50941: GREATER
50942: OR
50943: IFFALSE 50947
// exit ;
50945: GO 51300
// missile := [ 1 ] ;
50947: LD_ADDR_VAR 0 14
50951: PUSH
50952: LD_INT 1
50954: PUSH
50955: EMPTY
50956: LIST
50957: ST_TO_ADDR
// if Researched ( side , tech_space ) then
50958: LD_VAR 0 9
50962: PPUSH
50963: LD_VAR 0 12
50967: PPUSH
50968: CALL_OW 325
50972: IFFALSE 51001
// missile := Insert ( missile , missile + 1 , 2 ) ;
50974: LD_ADDR_VAR 0 14
50978: PUSH
50979: LD_VAR 0 14
50983: PPUSH
50984: LD_VAR 0 14
50988: PUSH
50989: LD_INT 1
50991: PLUS
50992: PPUSH
50993: LD_INT 2
50995: PPUSH
50996: CALL_OW 2
51000: ST_TO_ADDR
// if Researched ( side , tech_time ) and not Researched ( GetSide ( enemy ) , tech_time ) then
51001: LD_VAR 0 9
51005: PPUSH
51006: LD_VAR 0 13
51010: PPUSH
51011: CALL_OW 325
51015: PUSH
51016: LD_VAR 0 10
51020: PPUSH
51021: CALL_OW 255
51025: PPUSH
51026: LD_VAR 0 13
51030: PPUSH
51031: CALL_OW 325
51035: NOT
51036: AND
51037: IFFALSE 51066
// missile := Insert ( missile , missile + 1 , 3 ) ;
51039: LD_ADDR_VAR 0 14
51043: PUSH
51044: LD_VAR 0 14
51048: PPUSH
51049: LD_VAR 0 14
51053: PUSH
51054: LD_INT 1
51056: PLUS
51057: PPUSH
51058: LD_INT 3
51060: PPUSH
51061: CALL_OW 2
51065: ST_TO_ADDR
// if missile < 2 then
51066: LD_VAR 0 14
51070: PUSH
51071: LD_INT 2
51073: LESS
51074: IFFALSE 51078
// exit ;
51076: GO 51300
// x := GetX ( enemy ) ;
51078: LD_ADDR_VAR 0 4
51082: PUSH
51083: LD_VAR 0 10
51087: PPUSH
51088: CALL_OW 250
51092: ST_TO_ADDR
// y := GetY ( enemy ) ;
51093: LD_ADDR_VAR 0 5
51097: PUSH
51098: LD_VAR 0 10
51102: PPUSH
51103: CALL_OW 251
51107: ST_TO_ADDR
// _x := x + rand ( - 1 , 1 ) ;
51108: LD_ADDR_VAR 0 6
51112: PUSH
51113: LD_VAR 0 4
51117: PUSH
51118: LD_INT 1
51120: NEG
51121: PPUSH
51122: LD_INT 1
51124: PPUSH
51125: CALL_OW 12
51129: PLUS
51130: ST_TO_ADDR
// _y := y + rand ( - 1 , 1 ) ;
51131: LD_ADDR_VAR 0 7
51135: PUSH
51136: LD_VAR 0 5
51140: PUSH
51141: LD_INT 1
51143: NEG
51144: PPUSH
51145: LD_INT 1
51147: PPUSH
51148: CALL_OW 12
51152: PLUS
51153: ST_TO_ADDR
// if not ValidHex ( _x , _y ) then
51154: LD_VAR 0 6
51158: PPUSH
51159: LD_VAR 0 7
51163: PPUSH
51164: CALL_OW 488
51168: NOT
51169: IFFALSE 51191
// begin _x := x ;
51171: LD_ADDR_VAR 0 6
51175: PUSH
51176: LD_VAR 0 4
51180: ST_TO_ADDR
// _y := y ;
51181: LD_ADDR_VAR 0 7
51185: PUSH
51186: LD_VAR 0 5
51190: ST_TO_ADDR
// end ; i := rand ( 1 , missile ) ;
51191: LD_ADDR_VAR 0 3
51195: PUSH
51196: LD_INT 1
51198: PPUSH
51199: LD_VAR 0 14
51203: PPUSH
51204: CALL_OW 12
51208: ST_TO_ADDR
// case i of 1 :
51209: LD_VAR 0 3
51213: PUSH
51214: LD_INT 1
51216: DOUBLE
51217: EQUAL
51218: IFTRUE 51222
51220: GO 51239
51222: POP
// ComAttackUnit ( unit , enemy ) ; 2 :
51223: LD_VAR 0 1
51227: PPUSH
51228: LD_VAR 0 10
51232: PPUSH
51233: CALL_OW 115
51237: GO 51300
51239: LD_INT 2
51241: DOUBLE
51242: EQUAL
51243: IFTRUE 51247
51245: GO 51269
51247: POP
// ComSpaceShift ( unit , _x , _y ) ; 3 :
51248: LD_VAR 0 1
51252: PPUSH
51253: LD_VAR 0 6
51257: PPUSH
51258: LD_VAR 0 7
51262: PPUSH
51263: CALL_OW 153
51267: GO 51300
51269: LD_INT 3
51271: DOUBLE
51272: EQUAL
51273: IFTRUE 51277
51275: GO 51299
51277: POP
// ComTimeShift ( unit , _x , _y ) ; end ;
51278: LD_VAR 0 1
51282: PPUSH
51283: LD_VAR 0 6
51287: PPUSH
51288: LD_VAR 0 7
51292: PPUSH
51293: CALL_OW 154
51297: GO 51300
51299: POP
// end ;
51300: LD_VAR 0 2
51304: RET
// export function ComStandNearbyBuilding ( unit , building ) ; var i , x , y , _x , _y ; begin
51305: LD_INT 0
51307: PPUSH
51308: PPUSH
51309: PPUSH
51310: PPUSH
51311: PPUSH
51312: PPUSH
// if not unit or not building then
51313: LD_VAR 0 1
51317: NOT
51318: PUSH
51319: LD_VAR 0 2
51323: NOT
51324: OR
51325: IFFALSE 51329
// exit ;
51327: GO 51487
// x := GetX ( building ) ;
51329: LD_ADDR_VAR 0 5
51333: PUSH
51334: LD_VAR 0 2
51338: PPUSH
51339: CALL_OW 250
51343: ST_TO_ADDR
// y := GetY ( building ) ;
51344: LD_ADDR_VAR 0 6
51348: PUSH
51349: LD_VAR 0 2
51353: PPUSH
51354: CALL_OW 251
51358: ST_TO_ADDR
// for i = 0 to 5 do
51359: LD_ADDR_VAR 0 4
51363: PUSH
51364: DOUBLE
51365: LD_INT 0
51367: DEC
51368: ST_TO_ADDR
51369: LD_INT 5
51371: PUSH
51372: FOR_TO
51373: IFFALSE 51485
// begin _x := ShiftX ( x , i , 3 ) ;
51375: LD_ADDR_VAR 0 7
51379: PUSH
51380: LD_VAR 0 5
51384: PPUSH
51385: LD_VAR 0 4
51389: PPUSH
51390: LD_INT 3
51392: PPUSH
51393: CALL_OW 272
51397: ST_TO_ADDR
// _y := ShiftY ( y , i , 3 ) ;
51398: LD_ADDR_VAR 0 8
51402: PUSH
51403: LD_VAR 0 6
51407: PPUSH
51408: LD_VAR 0 4
51412: PPUSH
51413: LD_INT 3
51415: PPUSH
51416: CALL_OW 273
51420: ST_TO_ADDR
// if not ValidHex ( _x , _y ) then
51421: LD_VAR 0 7
51425: PPUSH
51426: LD_VAR 0 8
51430: PPUSH
51431: CALL_OW 488
51435: NOT
51436: IFFALSE 51440
// continue ;
51438: GO 51372
// if HexInfo ( _x , _y ) = 0 then
51440: LD_VAR 0 7
51444: PPUSH
51445: LD_VAR 0 8
51449: PPUSH
51450: CALL_OW 428
51454: PUSH
51455: LD_INT 0
51457: EQUAL
51458: IFFALSE 51483
// begin ComMoveXY ( unit , _x , _y ) ;
51460: LD_VAR 0 1
51464: PPUSH
51465: LD_VAR 0 7
51469: PPUSH
51470: LD_VAR 0 8
51474: PPUSH
51475: CALL_OW 111
// exit ;
51479: POP
51480: POP
51481: GO 51487
// end ; end ;
51483: GO 51372
51485: POP
51486: POP
// end ;
51487: LD_VAR 0 3
51491: RET
// export function ScanBase ( side , base_area ) ; begin
51492: LD_INT 0
51494: PPUSH
// result := FilterUnitsInArea ( base_area , [ f_enemy , side ] ) ;
51495: LD_ADDR_VAR 0 3
51499: PUSH
51500: LD_VAR 0 2
51504: PPUSH
51505: LD_INT 81
51507: PUSH
51508: LD_VAR 0 1
51512: PUSH
51513: EMPTY
51514: LIST
51515: LIST
51516: PPUSH
51517: CALL_OW 70
51521: ST_TO_ADDR
// end ;
51522: LD_VAR 0 3
51526: RET
// export function BasicDefend ( base , solds , area ) ; var enemy , side , i , hex ; begin
51527: LD_INT 0
51529: PPUSH
51530: PPUSH
51531: PPUSH
51532: PPUSH
51533: PPUSH
// if not base or not mc_bases [ base ] or not solds or not area then
51534: LD_VAR 0 1
51538: NOT
51539: PUSH
51540: LD_EXP 74
51544: PUSH
51545: LD_VAR 0 1
51549: ARRAY
51550: NOT
51551: OR
51552: PUSH
51553: LD_VAR 0 2
51557: NOT
51558: OR
51559: PUSH
51560: LD_VAR 0 3
51564: NOT
51565: OR
51566: IFFALSE 51570
// exit ;
51568: GO 52083
// side := mc_sides [ base ] ;
51570: LD_ADDR_VAR 0 6
51574: PUSH
51575: LD_EXP 100
51579: PUSH
51580: LD_VAR 0 1
51584: ARRAY
51585: ST_TO_ADDR
// if not side then
51586: LD_VAR 0 6
51590: NOT
51591: IFFALSE 51595
// exit ;
51593: GO 52083
// for i in solds do
51595: LD_ADDR_VAR 0 7
51599: PUSH
51600: LD_VAR 0 2
51604: PUSH
51605: FOR_IN
51606: IFFALSE 51667
// if GetBType ( IsInUnit ( i ) ) in [ b_bunker , b_breastwork ] then
51608: LD_VAR 0 7
51612: PPUSH
51613: CALL_OW 310
51617: PPUSH
51618: CALL_OW 266
51622: PUSH
51623: LD_INT 32
51625: PUSH
51626: LD_INT 31
51628: PUSH
51629: EMPTY
51630: LIST
51631: LIST
51632: IN
51633: IFFALSE 51653
// solds := solds diff i else
51635: LD_ADDR_VAR 0 2
51639: PUSH
51640: LD_VAR 0 2
51644: PUSH
51645: LD_VAR 0 7
51649: DIFF
51650: ST_TO_ADDR
51651: GO 51665
// SetTag ( i , 18 ) ;
51653: LD_VAR 0 7
51657: PPUSH
51658: LD_INT 18
51660: PPUSH
51661: CALL_OW 109
51665: GO 51605
51667: POP
51668: POP
// if not solds then
51669: LD_VAR 0 2
51673: NOT
51674: IFFALSE 51678
// exit ;
51676: GO 52083
// repeat wait ( 0 0$1 ) ;
51678: LD_INT 35
51680: PPUSH
51681: CALL_OW 67
// enemy := ScanBase ( side , area ) ;
51685: LD_ADDR_VAR 0 5
51689: PUSH
51690: LD_VAR 0 6
51694: PPUSH
51695: LD_VAR 0 3
51699: PPUSH
51700: CALL 51492 0 2
51704: ST_TO_ADDR
// if not mc_bases [ base ] or mc_bases [ base ] = [ ] then
51705: LD_EXP 74
51709: PUSH
51710: LD_VAR 0 1
51714: ARRAY
51715: NOT
51716: PUSH
51717: LD_EXP 74
51721: PUSH
51722: LD_VAR 0 1
51726: ARRAY
51727: PUSH
51728: EMPTY
51729: EQUAL
51730: OR
51731: IFFALSE 51768
// begin for i in solds do
51733: LD_ADDR_VAR 0 7
51737: PUSH
51738: LD_VAR 0 2
51742: PUSH
51743: FOR_IN
51744: IFFALSE 51757
// ComStop ( i ) ;
51746: LD_VAR 0 7
51750: PPUSH
51751: CALL_OW 141
51755: GO 51743
51757: POP
51758: POP
// solds := [ ] ;
51759: LD_ADDR_VAR 0 2
51763: PUSH
51764: EMPTY
51765: ST_TO_ADDR
// exit ;
51766: GO 52083
// end ; if not enemy or enemy > 3 or mc_defender [ base ] then
51768: LD_VAR 0 5
51772: NOT
51773: PUSH
51774: LD_VAR 0 5
51778: PUSH
51779: LD_INT 3
51781: GREATER
51782: OR
51783: PUSH
51784: LD_EXP 96
51788: PUSH
51789: LD_VAR 0 1
51793: ARRAY
51794: OR
51795: IFFALSE 51836
// begin for i in solds do
51797: LD_ADDR_VAR 0 7
51801: PUSH
51802: LD_VAR 0 2
51806: PUSH
51807: FOR_IN
51808: IFFALSE 51832
// if HasTask ( i ) then
51810: LD_VAR 0 7
51814: PPUSH
51815: CALL_OW 314
51819: IFFALSE 51830
// ComStop ( i ) ;
51821: LD_VAR 0 7
51825: PPUSH
51826: CALL_OW 141
51830: GO 51807
51832: POP
51833: POP
// break ;
51834: GO 52071
// end ; for i in solds do
51836: LD_ADDR_VAR 0 7
51840: PUSH
51841: LD_VAR 0 2
51845: PUSH
51846: FOR_IN
51847: IFFALSE 52063
// begin if IsInUnit ( i ) then
51849: LD_VAR 0 7
51853: PPUSH
51854: CALL_OW 310
51858: IFFALSE 51869
// ComExitBuilding ( i ) ;
51860: LD_VAR 0 7
51864: PPUSH
51865: CALL_OW 122
// if GetLives ( i ) > 333 then
51869: LD_VAR 0 7
51873: PPUSH
51874: CALL_OW 256
51878: PUSH
51879: LD_INT 333
51881: GREATER
51882: IFFALSE 51910
// ComAttackUnit ( i , NearestUnitToUnit ( enemy , i ) ) else
51884: LD_VAR 0 7
51888: PPUSH
51889: LD_VAR 0 5
51893: PPUSH
51894: LD_VAR 0 7
51898: PPUSH
51899: CALL_OW 74
51903: PPUSH
51904: CALL_OW 115
51908: GO 52061
// begin hex := NearestUnitToUnit ( UnitFilter ( mc_bases [ base ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] , [ f_btype , b_lab ] ] ) , i ) ;
51910: LD_ADDR_VAR 0 8
51914: PUSH
51915: LD_EXP 74
51919: PUSH
51920: LD_VAR 0 1
51924: ARRAY
51925: PPUSH
51926: LD_INT 2
51928: PUSH
51929: LD_INT 30
51931: PUSH
51932: LD_INT 0
51934: PUSH
51935: EMPTY
51936: LIST
51937: LIST
51938: PUSH
51939: LD_INT 30
51941: PUSH
51942: LD_INT 1
51944: PUSH
51945: EMPTY
51946: LIST
51947: LIST
51948: PUSH
51949: LD_INT 30
51951: PUSH
51952: LD_INT 6
51954: PUSH
51955: EMPTY
51956: LIST
51957: LIST
51958: PUSH
51959: EMPTY
51960: LIST
51961: LIST
51962: LIST
51963: LIST
51964: PPUSH
51965: CALL_OW 72
51969: PPUSH
51970: LD_VAR 0 7
51974: PPUSH
51975: CALL_OW 74
51979: ST_TO_ADDR
// ComMoveXY ( i , ShiftX ( GetX ( hex ) , 3 , 5 ) , ShiftY ( GetY ( hex ) , 3 , 5 ) ) ;
51980: LD_VAR 0 7
51984: PPUSH
51985: LD_VAR 0 8
51989: PPUSH
51990: CALL_OW 250
51994: PPUSH
51995: LD_INT 3
51997: PPUSH
51998: LD_INT 5
52000: PPUSH
52001: CALL_OW 272
52005: PPUSH
52006: LD_VAR 0 8
52010: PPUSH
52011: CALL_OW 251
52015: PPUSH
52016: LD_INT 3
52018: PPUSH
52019: LD_INT 5
52021: PPUSH
52022: CALL_OW 273
52026: PPUSH
52027: CALL_OW 111
// SetTag ( i , 0 ) ;
52031: LD_VAR 0 7
52035: PPUSH
52036: LD_INT 0
52038: PPUSH
52039: CALL_OW 109
// solds := solds diff i ;
52043: LD_ADDR_VAR 0 2
52047: PUSH
52048: LD_VAR 0 2
52052: PUSH
52053: LD_VAR 0 7
52057: DIFF
52058: ST_TO_ADDR
// continue ;
52059: GO 51846
// end ; end ;
52061: GO 51846
52063: POP
52064: POP
// until solds ;
52065: LD_VAR 0 2
52069: IFFALSE 51678
// MC_Reset ( base , 18 ) ;
52071: LD_VAR 0 1
52075: PPUSH
52076: LD_INT 18
52078: PPUSH
52079: CALL 24150 0 2
// end ;
52083: LD_VAR 0 4
52087: RET
// export function Defend ( base , defenders , enemy ) ; var i , j , x , solds , mech , un , tmp , mechs , e , fac , components , depot_under_attack , sold_defenders , b , can_defend ; begin
52088: LD_INT 0
52090: PPUSH
52091: PPUSH
52092: PPUSH
52093: PPUSH
52094: PPUSH
52095: PPUSH
52096: PPUSH
52097: PPUSH
52098: PPUSH
52099: PPUSH
52100: PPUSH
52101: PPUSH
52102: PPUSH
52103: PPUSH
52104: PPUSH
52105: PPUSH
// mechs := UnitFilter ( mc_bases [ base ] , [ f_class , 3 ] ) ;
52106: LD_ADDR_VAR 0 12
52110: PUSH
52111: LD_EXP 74
52115: PUSH
52116: LD_VAR 0 1
52120: ARRAY
52121: PPUSH
52122: LD_INT 25
52124: PUSH
52125: LD_INT 3
52127: PUSH
52128: EMPTY
52129: LIST
52130: LIST
52131: PPUSH
52132: CALL_OW 72
52136: ST_TO_ADDR
// if mc_remote_driver [ base ] then
52137: LD_EXP 114
52141: PUSH
52142: LD_VAR 0 1
52146: ARRAY
52147: IFFALSE 52171
// mechs := mechs diff mc_remote_driver [ base ] ;
52149: LD_ADDR_VAR 0 12
52153: PUSH
52154: LD_VAR 0 12
52158: PUSH
52159: LD_EXP 114
52163: PUSH
52164: LD_VAR 0 1
52168: ARRAY
52169: DIFF
52170: ST_TO_ADDR
// solds := UnitFilter ( mc_bases [ base ] , [ f_or , [ f_class , 1 ] , [ f_class , 5 ] , [ f_class , 8 ] , [ f_class , 9 ] ] ) ;
52171: LD_ADDR_VAR 0 8
52175: PUSH
52176: LD_EXP 74
52180: PUSH
52181: LD_VAR 0 1
52185: ARRAY
52186: PPUSH
52187: LD_INT 2
52189: PUSH
52190: LD_INT 25
52192: PUSH
52193: LD_INT 1
52195: PUSH
52196: EMPTY
52197: LIST
52198: LIST
52199: PUSH
52200: LD_INT 25
52202: PUSH
52203: LD_INT 5
52205: PUSH
52206: EMPTY
52207: LIST
52208: LIST
52209: PUSH
52210: LD_INT 25
52212: PUSH
52213: LD_INT 8
52215: PUSH
52216: EMPTY
52217: LIST
52218: LIST
52219: PUSH
52220: LD_INT 25
52222: PUSH
52223: LD_INT 9
52225: PUSH
52226: EMPTY
52227: LIST
52228: LIST
52229: PUSH
52230: EMPTY
52231: LIST
52232: LIST
52233: LIST
52234: LIST
52235: LIST
52236: PPUSH
52237: CALL_OW 72
52241: ST_TO_ADDR
// if not defenders and not solds then
52242: LD_VAR 0 2
52246: NOT
52247: PUSH
52248: LD_VAR 0 8
52252: NOT
52253: AND
52254: IFFALSE 52258
// exit ;
52256: GO 53784
// depot_under_attack := false ;
52258: LD_ADDR_VAR 0 16
52262: PUSH
52263: LD_INT 0
52265: ST_TO_ADDR
// sold_defenders := [ ] ;
52266: LD_ADDR_VAR 0 17
52270: PUSH
52271: EMPTY
52272: ST_TO_ADDR
// if mechs then
52273: LD_VAR 0 12
52277: IFFALSE 52406
// for i in defenders do
52279: LD_ADDR_VAR 0 5
52283: PUSH
52284: LD_VAR 0 2
52288: PUSH
52289: FOR_IN
52290: IFFALSE 52404
// begin SetTag ( i , 20 ) ;
52292: LD_VAR 0 5
52296: PPUSH
52297: LD_INT 20
52299: PPUSH
52300: CALL_OW 109
// if GetControl ( i ) = control_manual and not IsDrivenBy ( i ) and mechs then
52304: LD_VAR 0 5
52308: PPUSH
52309: CALL_OW 263
52313: PUSH
52314: LD_INT 1
52316: EQUAL
52317: PUSH
52318: LD_VAR 0 5
52322: PPUSH
52323: CALL_OW 311
52327: NOT
52328: AND
52329: PUSH
52330: LD_VAR 0 12
52334: AND
52335: IFFALSE 52402
// begin un := mechs [ 1 ] ;
52337: LD_ADDR_VAR 0 10
52341: PUSH
52342: LD_VAR 0 12
52346: PUSH
52347: LD_INT 1
52349: ARRAY
52350: ST_TO_ADDR
// ComExitBuilding ( un ) ;
52351: LD_VAR 0 10
52355: PPUSH
52356: CALL_OW 122
// AddComEnterUnit ( un , i ) ;
52360: LD_VAR 0 10
52364: PPUSH
52365: LD_VAR 0 5
52369: PPUSH
52370: CALL_OW 180
// SetTag ( un , 19 ) ;
52374: LD_VAR 0 10
52378: PPUSH
52379: LD_INT 19
52381: PPUSH
52382: CALL_OW 109
// mechs := mechs diff un ;
52386: LD_ADDR_VAR 0 12
52390: PUSH
52391: LD_VAR 0 12
52395: PUSH
52396: LD_VAR 0 10
52400: DIFF
52401: ST_TO_ADDR
// end ; end ;
52402: GO 52289
52404: POP
52405: POP
// if solds then
52406: LD_VAR 0 8
52410: IFFALSE 52469
// for i in solds do
52412: LD_ADDR_VAR 0 5
52416: PUSH
52417: LD_VAR 0 8
52421: PUSH
52422: FOR_IN
52423: IFFALSE 52467
// if not GetTag ( i ) then
52425: LD_VAR 0 5
52429: PPUSH
52430: CALL_OW 110
52434: NOT
52435: IFFALSE 52465
// begin defenders := defenders union i ;
52437: LD_ADDR_VAR 0 2
52441: PUSH
52442: LD_VAR 0 2
52446: PUSH
52447: LD_VAR 0 5
52451: UNION
52452: ST_TO_ADDR
// SetTag ( i , 18 ) ;
52453: LD_VAR 0 5
52457: PPUSH
52458: LD_INT 18
52460: PPUSH
52461: CALL_OW 109
// end ;
52465: GO 52422
52467: POP
52468: POP
// repeat wait ( 0 0$1 ) ;
52469: LD_INT 35
52471: PPUSH
52472: CALL_OW 67
// enemy := mc_scan [ base ] ;
52476: LD_ADDR_VAR 0 3
52480: PUSH
52481: LD_EXP 97
52485: PUSH
52486: LD_VAR 0 1
52490: ARRAY
52491: ST_TO_ADDR
// if not mc_bases [ base ] or mc_bases [ base ] = [ ] then
52492: LD_EXP 74
52496: PUSH
52497: LD_VAR 0 1
52501: ARRAY
52502: NOT
52503: PUSH
52504: LD_EXP 74
52508: PUSH
52509: LD_VAR 0 1
52513: ARRAY
52514: PUSH
52515: EMPTY
52516: EQUAL
52517: OR
52518: IFFALSE 52555
// begin for i in defenders do
52520: LD_ADDR_VAR 0 5
52524: PUSH
52525: LD_VAR 0 2
52529: PUSH
52530: FOR_IN
52531: IFFALSE 52544
// ComStop ( i ) ;
52533: LD_VAR 0 5
52537: PPUSH
52538: CALL_OW 141
52542: GO 52530
52544: POP
52545: POP
// defenders := [ ] ;
52546: LD_ADDR_VAR 0 2
52550: PUSH
52551: EMPTY
52552: ST_TO_ADDR
// exit ;
52553: GO 53784
// end ; for i in defenders do
52555: LD_ADDR_VAR 0 5
52559: PUSH
52560: LD_VAR 0 2
52564: PUSH
52565: FOR_IN
52566: IFFALSE 53296
// begin e := NearestUnitToUnit ( enemy , i ) ;
52568: LD_ADDR_VAR 0 13
52572: PUSH
52573: LD_VAR 0 3
52577: PPUSH
52578: LD_VAR 0 5
52582: PPUSH
52583: CALL_OW 74
52587: ST_TO_ADDR
// depot_under_attack := ( not UnitFilter ( mc_bases [ base ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) or GetLives ( UnitFilter ( mc_bases [ base ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) ) < 600 ) ;
52588: LD_ADDR_VAR 0 16
52592: PUSH
52593: LD_EXP 74
52597: PUSH
52598: LD_VAR 0 1
52602: ARRAY
52603: PPUSH
52604: LD_INT 2
52606: PUSH
52607: LD_INT 30
52609: PUSH
52610: LD_INT 0
52612: PUSH
52613: EMPTY
52614: LIST
52615: LIST
52616: PUSH
52617: LD_INT 30
52619: PUSH
52620: LD_INT 1
52622: PUSH
52623: EMPTY
52624: LIST
52625: LIST
52626: PUSH
52627: EMPTY
52628: LIST
52629: LIST
52630: LIST
52631: PPUSH
52632: CALL_OW 72
52636: NOT
52637: PUSH
52638: LD_EXP 74
52642: PUSH
52643: LD_VAR 0 1
52647: ARRAY
52648: PPUSH
52649: LD_INT 2
52651: PUSH
52652: LD_INT 30
52654: PUSH
52655: LD_INT 0
52657: PUSH
52658: EMPTY
52659: LIST
52660: LIST
52661: PUSH
52662: LD_INT 30
52664: PUSH
52665: LD_INT 1
52667: PUSH
52668: EMPTY
52669: LIST
52670: LIST
52671: PUSH
52672: EMPTY
52673: LIST
52674: LIST
52675: LIST
52676: PPUSH
52677: CALL_OW 72
52681: PPUSH
52682: CALL_OW 256
52686: PUSH
52687: LD_INT 600
52689: LESS
52690: OR
52691: ST_TO_ADDR
// case GetType ( i ) of unit_vehicle :
52692: LD_VAR 0 5
52696: PPUSH
52697: CALL_OW 247
52701: PUSH
52702: LD_INT 2
52704: DOUBLE
52705: EQUAL
52706: IFTRUE 52710
52708: GO 53002
52710: POP
// begin if GetLives ( i ) > 650 and ( GetDistUnits ( i , e ) < 40 or IsInArea ( e , mc_scan_area [ base ] ) ) then
52711: LD_VAR 0 5
52715: PPUSH
52716: CALL_OW 256
52720: PUSH
52721: LD_INT 650
52723: GREATER
52724: PUSH
52725: LD_VAR 0 5
52729: PPUSH
52730: LD_VAR 0 13
52734: PPUSH
52735: CALL_OW 296
52739: PUSH
52740: LD_INT 40
52742: LESS
52743: PUSH
52744: LD_VAR 0 13
52748: PPUSH
52749: LD_EXP 99
52753: PUSH
52754: LD_VAR 0 1
52758: ARRAY
52759: PPUSH
52760: CALL_OW 308
52764: OR
52765: AND
52766: IFFALSE 52784
// ComAttackUnit ( i , e ) else
52768: LD_VAR 0 5
52772: PPUSH
52773: LD_VAR 0 13
52777: PPUSH
52778: CALL_OW 115
52782: GO 52885
// if ( ( not IsInArea ( e , mc_scan_area [ base ] ) and GetDistUnits ( i , e ) >= 40 ) or GetLives ( i ) <= 650 ) and not IsInArea ( i , mc_parking [ base ] ) then
52784: LD_VAR 0 13
52788: PPUSH
52789: LD_EXP 99
52793: PUSH
52794: LD_VAR 0 1
52798: ARRAY
52799: PPUSH
52800: CALL_OW 308
52804: NOT
52805: PUSH
52806: LD_VAR 0 5
52810: PPUSH
52811: LD_VAR 0 13
52815: PPUSH
52816: CALL_OW 296
52820: PUSH
52821: LD_INT 40
52823: GREATEREQUAL
52824: AND
52825: PUSH
52826: LD_VAR 0 5
52830: PPUSH
52831: CALL_OW 256
52835: PUSH
52836: LD_INT 650
52838: LESSEQUAL
52839: OR
52840: PUSH
52841: LD_VAR 0 5
52845: PPUSH
52846: LD_EXP 98
52850: PUSH
52851: LD_VAR 0 1
52855: ARRAY
52856: PPUSH
52857: CALL_OW 308
52861: NOT
52862: AND
52863: IFFALSE 52885
// ComMoveToArea ( i , mc_parking [ base ] ) ;
52865: LD_VAR 0 5
52869: PPUSH
52870: LD_EXP 98
52874: PUSH
52875: LD_VAR 0 1
52879: ARRAY
52880: PPUSH
52881: CALL_OW 113
// if GetLives ( i ) < 998 and GetControl ( i ) = control_manual and IsDrivenBy ( i ) and IsInArea ( i , mc_parking [ base ] ) then
52885: LD_VAR 0 5
52889: PPUSH
52890: CALL_OW 256
52894: PUSH
52895: LD_INT 998
52897: LESS
52898: PUSH
52899: LD_VAR 0 5
52903: PPUSH
52904: CALL_OW 263
52908: PUSH
52909: LD_INT 1
52911: EQUAL
52912: AND
52913: PUSH
52914: LD_VAR 0 5
52918: PPUSH
52919: CALL_OW 311
52923: AND
52924: PUSH
52925: LD_VAR 0 5
52929: PPUSH
52930: LD_EXP 98
52934: PUSH
52935: LD_VAR 0 1
52939: ARRAY
52940: PPUSH
52941: CALL_OW 308
52945: AND
52946: IFFALSE 53000
// begin mech := IsDrivenBy ( i ) ;
52948: LD_ADDR_VAR 0 9
52952: PUSH
52953: LD_VAR 0 5
52957: PPUSH
52958: CALL_OW 311
52962: ST_TO_ADDR
// ComExitVehicle ( mech ) ;
52963: LD_VAR 0 9
52967: PPUSH
52968: CALL_OW 121
// AddComRepairVehicle ( mech , i ) ;
52972: LD_VAR 0 9
52976: PPUSH
52977: LD_VAR 0 5
52981: PPUSH
52982: CALL_OW 189
// AddComEnterUnit ( mech , i ) ;
52986: LD_VAR 0 9
52990: PPUSH
52991: LD_VAR 0 5
52995: PPUSH
52996: CALL_OW 180
// end ; end ; unit_human :
53000: GO 53267
53002: LD_INT 1
53004: DOUBLE
53005: EQUAL
53006: IFTRUE 53010
53008: GO 53266
53010: POP
// begin b := IsInUnit ( i ) ;
53011: LD_ADDR_VAR 0 18
53015: PUSH
53016: LD_VAR 0 5
53020: PPUSH
53021: CALL_OW 310
53025: ST_TO_ADDR
// can_defend := ( not b or GetBType ( b ) in [ b_bunker , b_breastwork ] ) ;
53026: LD_ADDR_VAR 0 19
53030: PUSH
53031: LD_VAR 0 18
53035: NOT
53036: PUSH
53037: LD_VAR 0 18
53041: PPUSH
53042: CALL_OW 266
53046: PUSH
53047: LD_INT 32
53049: PUSH
53050: LD_INT 31
53052: PUSH
53053: EMPTY
53054: LIST
53055: LIST
53056: IN
53057: OR
53058: ST_TO_ADDR
// if ( depot_under_attack or UnitFilter ( defenders , [ f_type , unit_vehicle ] ) <= 1 ) and can_defend and not i in sold_defenders then
53059: LD_VAR 0 16
53063: PUSH
53064: LD_VAR 0 2
53068: PPUSH
53069: LD_INT 21
53071: PUSH
53072: LD_INT 2
53074: PUSH
53075: EMPTY
53076: LIST
53077: LIST
53078: PPUSH
53079: CALL_OW 72
53083: PUSH
53084: LD_INT 1
53086: LESSEQUAL
53087: OR
53088: PUSH
53089: LD_VAR 0 19
53093: AND
53094: PUSH
53095: LD_VAR 0 5
53099: PUSH
53100: LD_VAR 0 17
53104: IN
53105: NOT
53106: AND
53107: IFFALSE 53200
// begin if b then
53109: LD_VAR 0 18
53113: IFFALSE 53162
// if GetDistUnits ( b , NearestUnitToUnit ( enemy , b ) ) < 10 and BuildingStatus ( b ) <> bs_need_power then
53115: LD_VAR 0 18
53119: PPUSH
53120: LD_VAR 0 3
53124: PPUSH
53125: LD_VAR 0 18
53129: PPUSH
53130: CALL_OW 74
53134: PPUSH
53135: CALL_OW 296
53139: PUSH
53140: LD_INT 10
53142: LESS
53143: PUSH
53144: LD_VAR 0 18
53148: PPUSH
53149: CALL_OW 461
53153: PUSH
53154: LD_INT 7
53156: NONEQUAL
53157: AND
53158: IFFALSE 53162
// continue ;
53160: GO 52565
// sold_defenders := Replace ( sold_defenders , sold_defenders + 1 , i ) ;
53162: LD_ADDR_VAR 0 17
53166: PUSH
53167: LD_VAR 0 17
53171: PPUSH
53172: LD_VAR 0 17
53176: PUSH
53177: LD_INT 1
53179: PLUS
53180: PPUSH
53181: LD_VAR 0 5
53185: PPUSH
53186: CALL_OW 1
53190: ST_TO_ADDR
// ComExitBuilding ( i ) ;
53191: LD_VAR 0 5
53195: PPUSH
53196: CALL_OW 122
// end ; if sold_defenders then
53200: LD_VAR 0 17
53204: IFFALSE 53264
// if i in sold_defenders then
53206: LD_VAR 0 5
53210: PUSH
53211: LD_VAR 0 17
53215: IN
53216: IFFALSE 53264
// begin if not HasTask ( i ) and GetDistUnits ( i , e ) < 30 then
53218: LD_VAR 0 5
53222: PPUSH
53223: CALL_OW 314
53227: NOT
53228: PUSH
53229: LD_VAR 0 5
53233: PPUSH
53234: LD_VAR 0 13
53238: PPUSH
53239: CALL_OW 296
53243: PUSH
53244: LD_INT 30
53246: LESS
53247: AND
53248: IFFALSE 53264
// ComAttackUnit ( i , e ) ;
53250: LD_VAR 0 5
53254: PPUSH
53255: LD_VAR 0 13
53259: PPUSH
53260: CALL_OW 115
// end ; end ; end ;
53264: GO 53267
53266: POP
// if IsDead ( i ) then
53267: LD_VAR 0 5
53271: PPUSH
53272: CALL_OW 301
53276: IFFALSE 53294
// defenders := defenders diff i ;
53278: LD_ADDR_VAR 0 2
53282: PUSH
53283: LD_VAR 0 2
53287: PUSH
53288: LD_VAR 0 5
53292: DIFF
53293: ST_TO_ADDR
// end ;
53294: GO 52565
53296: POP
53297: POP
// until not enemy or not defenders or not mc_bases [ base ] ;
53298: LD_VAR 0 3
53302: NOT
53303: PUSH
53304: LD_VAR 0 2
53308: NOT
53309: OR
53310: PUSH
53311: LD_EXP 74
53315: PUSH
53316: LD_VAR 0 1
53320: ARRAY
53321: NOT
53322: OR
53323: IFFALSE 52469
// MC_Reset ( base , 18 ) ;
53325: LD_VAR 0 1
53329: PPUSH
53330: LD_INT 18
53332: PPUSH
53333: CALL 24150 0 2
// defenders := defenders diff UnitFilter ( defenders , [ f_or , [ f_class , 1 ] , [ f_class , 5 ] , [ f_class , 8 ] , [ f_class , 9 ] ] ) ;
53337: LD_ADDR_VAR 0 2
53341: PUSH
53342: LD_VAR 0 2
53346: PUSH
53347: LD_VAR 0 2
53351: PPUSH
53352: LD_INT 2
53354: PUSH
53355: LD_INT 25
53357: PUSH
53358: LD_INT 1
53360: PUSH
53361: EMPTY
53362: LIST
53363: LIST
53364: PUSH
53365: LD_INT 25
53367: PUSH
53368: LD_INT 5
53370: PUSH
53371: EMPTY
53372: LIST
53373: LIST
53374: PUSH
53375: LD_INT 25
53377: PUSH
53378: LD_INT 8
53380: PUSH
53381: EMPTY
53382: LIST
53383: LIST
53384: PUSH
53385: LD_INT 25
53387: PUSH
53388: LD_INT 9
53390: PUSH
53391: EMPTY
53392: LIST
53393: LIST
53394: PUSH
53395: EMPTY
53396: LIST
53397: LIST
53398: LIST
53399: LIST
53400: LIST
53401: PPUSH
53402: CALL_OW 72
53406: DIFF
53407: ST_TO_ADDR
// if not enemy and UnitFilter ( defenders , [ f_type , unit_vehicle ] ) then
53408: LD_VAR 0 3
53412: NOT
53413: PUSH
53414: LD_VAR 0 2
53418: PPUSH
53419: LD_INT 21
53421: PUSH
53422: LD_INT 2
53424: PUSH
53425: EMPTY
53426: LIST
53427: LIST
53428: PPUSH
53429: CALL_OW 72
53433: AND
53434: IFFALSE 53772
// begin tmp := FilterByTag ( defenders , 19 ) ;
53436: LD_ADDR_VAR 0 11
53440: PUSH
53441: LD_VAR 0 2
53445: PPUSH
53446: LD_INT 19
53448: PPUSH
53449: CALL 90213 0 2
53453: ST_TO_ADDR
// if tmp then
53454: LD_VAR 0 11
53458: IFFALSE 53528
// begin tmp := UnitFilter ( tmp , [ f_class , 3 ] ) ;
53460: LD_ADDR_VAR 0 11
53464: PUSH
53465: LD_VAR 0 11
53469: PPUSH
53470: LD_INT 25
53472: PUSH
53473: LD_INT 3
53475: PUSH
53476: EMPTY
53477: LIST
53478: LIST
53479: PPUSH
53480: CALL_OW 72
53484: ST_TO_ADDR
// if tmp then
53485: LD_VAR 0 11
53489: IFFALSE 53528
// mc_repair_vehicle := Replace ( mc_repair_vehicle , base , mc_repair_vehicle [ base ] union tmp ) ;
53491: LD_ADDR_EXP 86
53495: PUSH
53496: LD_EXP 86
53500: PPUSH
53501: LD_VAR 0 1
53505: PPUSH
53506: LD_EXP 86
53510: PUSH
53511: LD_VAR 0 1
53515: ARRAY
53516: PUSH
53517: LD_VAR 0 11
53521: UNION
53522: PPUSH
53523: CALL_OW 1
53527: ST_TO_ADDR
// end ; MC_Reset ( base , 19 ) ;
53528: LD_VAR 0 1
53532: PPUSH
53533: LD_INT 19
53535: PPUSH
53536: CALL 24150 0 2
// repeat wait ( 0 0$1 ) ;
53540: LD_INT 35
53542: PPUSH
53543: CALL_OW 67
// if not mc_bases [ base ] or mc_bases [ base ] = [ ] then
53547: LD_EXP 74
53551: PUSH
53552: LD_VAR 0 1
53556: ARRAY
53557: NOT
53558: PUSH
53559: LD_EXP 74
53563: PUSH
53564: LD_VAR 0 1
53568: ARRAY
53569: PUSH
53570: EMPTY
53571: EQUAL
53572: OR
53573: IFFALSE 53610
// begin for i in defenders do
53575: LD_ADDR_VAR 0 5
53579: PUSH
53580: LD_VAR 0 2
53584: PUSH
53585: FOR_IN
53586: IFFALSE 53599
// ComStop ( i ) ;
53588: LD_VAR 0 5
53592: PPUSH
53593: CALL_OW 141
53597: GO 53585
53599: POP
53600: POP
// defenders := [ ] ;
53601: LD_ADDR_VAR 0 2
53605: PUSH
53606: EMPTY
53607: ST_TO_ADDR
// exit ;
53608: GO 53784
// end ; for i in defenders do
53610: LD_ADDR_VAR 0 5
53614: PUSH
53615: LD_VAR 0 2
53619: PUSH
53620: FOR_IN
53621: IFFALSE 53710
// begin if not IsInArea ( i , mc_parking [ base ] ) then
53623: LD_VAR 0 5
53627: PPUSH
53628: LD_EXP 98
53632: PUSH
53633: LD_VAR 0 1
53637: ARRAY
53638: PPUSH
53639: CALL_OW 308
53643: NOT
53644: IFFALSE 53668
// ComMoveToArea ( i , mc_parking [ base ] ) else
53646: LD_VAR 0 5
53650: PPUSH
53651: LD_EXP 98
53655: PUSH
53656: LD_VAR 0 1
53660: ARRAY
53661: PPUSH
53662: CALL_OW 113
53666: GO 53708
// if GetControl ( i ) = control_manual then
53668: LD_VAR 0 5
53672: PPUSH
53673: CALL_OW 263
53677: PUSH
53678: LD_INT 1
53680: EQUAL
53681: IFFALSE 53708
// if IsDrivenBy ( i ) then
53683: LD_VAR 0 5
53687: PPUSH
53688: CALL_OW 311
53692: IFFALSE 53708
// ComExitVehicle ( IsDrivenBy ( i ) ) ;
53694: LD_VAR 0 5
53698: PPUSH
53699: CALL_OW 311
53703: PPUSH
53704: CALL_OW 121
// end ;
53708: GO 53620
53710: POP
53711: POP
// until UnitFilter ( defenders , [ f_inarea , mc_parking [ base ] ] ) = defenders or mc_scan [ base ] or not mc_bases [ base ] ;
53712: LD_VAR 0 2
53716: PPUSH
53717: LD_INT 95
53719: PUSH
53720: LD_EXP 98
53724: PUSH
53725: LD_VAR 0 1
53729: ARRAY
53730: PUSH
53731: EMPTY
53732: LIST
53733: LIST
53734: PPUSH
53735: CALL_OW 72
53739: PUSH
53740: LD_VAR 0 2
53744: EQUAL
53745: PUSH
53746: LD_EXP 97
53750: PUSH
53751: LD_VAR 0 1
53755: ARRAY
53756: OR
53757: PUSH
53758: LD_EXP 74
53762: PUSH
53763: LD_VAR 0 1
53767: ARRAY
53768: NOT
53769: OR
53770: IFFALSE 53540
// end ; MC_Reset ( base , 20 ) ;
53772: LD_VAR 0 1
53776: PPUSH
53777: LD_INT 20
53779: PPUSH
53780: CALL 24150 0 2
// end ;
53784: LD_VAR 0 4
53788: RET
// export function AllowSpecClass ( unit ) ; var side , nat , tech ; begin
53789: LD_INT 0
53791: PPUSH
53792: PPUSH
53793: PPUSH
53794: PPUSH
// result := false ;
53795: LD_ADDR_VAR 0 2
53799: PUSH
53800: LD_INT 0
53802: ST_TO_ADDR
// side := GetSide ( unit ) ;
53803: LD_ADDR_VAR 0 3
53807: PUSH
53808: LD_VAR 0 1
53812: PPUSH
53813: CALL_OW 255
53817: ST_TO_ADDR
// nat := GetNation ( unit ) ;
53818: LD_ADDR_VAR 0 4
53822: PUSH
53823: LD_VAR 0 1
53827: PPUSH
53828: CALL_OW 248
53832: ST_TO_ADDR
// case nat of 1 :
53833: LD_VAR 0 4
53837: PUSH
53838: LD_INT 1
53840: DOUBLE
53841: EQUAL
53842: IFTRUE 53846
53844: GO 53857
53846: POP
// tech := tech_lassight ; 2 :
53847: LD_ADDR_VAR 0 5
53851: PUSH
53852: LD_INT 12
53854: ST_TO_ADDR
53855: GO 53896
53857: LD_INT 2
53859: DOUBLE
53860: EQUAL
53861: IFTRUE 53865
53863: GO 53876
53865: POP
// tech := tech_mortar ; 3 :
53866: LD_ADDR_VAR 0 5
53870: PUSH
53871: LD_INT 41
53873: ST_TO_ADDR
53874: GO 53896
53876: LD_INT 3
53878: DOUBLE
53879: EQUAL
53880: IFTRUE 53884
53882: GO 53895
53884: POP
// tech := tech_bazooka ; end ;
53885: LD_ADDR_VAR 0 5
53889: PUSH
53890: LD_INT 44
53892: ST_TO_ADDR
53893: GO 53896
53895: POP
// if Researched ( side , tech ) then
53896: LD_VAR 0 3
53900: PPUSH
53901: LD_VAR 0 5
53905: PPUSH
53906: CALL_OW 325
53910: IFFALSE 53937
// result := [ class_sniper , class_mortar , class_bazooker ] [ nat ] ;
53912: LD_ADDR_VAR 0 2
53916: PUSH
53917: LD_INT 5
53919: PUSH
53920: LD_INT 8
53922: PUSH
53923: LD_INT 9
53925: PUSH
53926: EMPTY
53927: LIST
53928: LIST
53929: LIST
53930: PUSH
53931: LD_VAR 0 4
53935: ARRAY
53936: ST_TO_ADDR
// end ;
53937: LD_VAR 0 2
53941: RET
// export function DetonateMines ( side , mines ) ; var i , tmp ; begin
53942: LD_INT 0
53944: PPUSH
53945: PPUSH
53946: PPUSH
// if not mines then
53947: LD_VAR 0 2
53951: NOT
53952: IFFALSE 53956
// exit ;
53954: GO 54100
// tmp := FilterAllUnits ( [ [ f_enemy , side ] , [ f_not , [ f_type , unit_building ] ] ] ) ;
53956: LD_ADDR_VAR 0 5
53960: PUSH
53961: LD_INT 81
53963: PUSH
53964: LD_VAR 0 1
53968: PUSH
53969: EMPTY
53970: LIST
53971: LIST
53972: PUSH
53973: LD_INT 3
53975: PUSH
53976: LD_INT 21
53978: PUSH
53979: LD_INT 3
53981: PUSH
53982: EMPTY
53983: LIST
53984: LIST
53985: PUSH
53986: EMPTY
53987: LIST
53988: LIST
53989: PUSH
53990: EMPTY
53991: LIST
53992: LIST
53993: PPUSH
53994: CALL_OW 69
53998: ST_TO_ADDR
// for i in mines do
53999: LD_ADDR_VAR 0 4
54003: PUSH
54004: LD_VAR 0 2
54008: PUSH
54009: FOR_IN
54010: IFFALSE 54098
// begin if not MineAtPos ( i [ 1 ] , i [ 2 ] ) then
54012: LD_VAR 0 4
54016: PUSH
54017: LD_INT 1
54019: ARRAY
54020: PPUSH
54021: LD_VAR 0 4
54025: PUSH
54026: LD_INT 2
54028: ARRAY
54029: PPUSH
54030: CALL_OW 458
54034: NOT
54035: IFFALSE 54039
// continue ;
54037: GO 54009
// if HexInfo ( i [ 1 ] , i [ 2 ] ) in tmp then
54039: LD_VAR 0 4
54043: PUSH
54044: LD_INT 1
54046: ARRAY
54047: PPUSH
54048: LD_VAR 0 4
54052: PUSH
54053: LD_INT 2
54055: ARRAY
54056: PPUSH
54057: CALL_OW 428
54061: PUSH
54062: LD_VAR 0 5
54066: IN
54067: IFFALSE 54096
// LaunchMineAtPos ( i [ 1 ] , i [ 2 ] , side ) ;
54069: LD_VAR 0 4
54073: PUSH
54074: LD_INT 1
54076: ARRAY
54077: PPUSH
54078: LD_VAR 0 4
54082: PUSH
54083: LD_INT 2
54085: ARRAY
54086: PPUSH
54087: LD_VAR 0 1
54091: PPUSH
54092: CALL_OW 456
// end ;
54096: GO 54009
54098: POP
54099: POP
// end ;
54100: LD_VAR 0 3
54104: RET
// export function Count ( array ) ; var i ; begin
54105: LD_INT 0
54107: PPUSH
54108: PPUSH
// result := 0 ;
54109: LD_ADDR_VAR 0 2
54113: PUSH
54114: LD_INT 0
54116: ST_TO_ADDR
// for i in array do
54117: LD_ADDR_VAR 0 3
54121: PUSH
54122: LD_VAR 0 1
54126: PUSH
54127: FOR_IN
54128: IFFALSE 54152
// if i then
54130: LD_VAR 0 3
54134: IFFALSE 54150
// result := result + 1 ;
54136: LD_ADDR_VAR 0 2
54140: PUSH
54141: LD_VAR 0 2
54145: PUSH
54146: LD_INT 1
54148: PLUS
54149: ST_TO_ADDR
54150: GO 54127
54152: POP
54153: POP
// end ;
54154: LD_VAR 0 2
54158: RET
// export function IsEmpty ( building ) ; begin
54159: LD_INT 0
54161: PPUSH
// if not building then
54162: LD_VAR 0 1
54166: NOT
54167: IFFALSE 54171
// exit ;
54169: GO 54214
// result := building in FilterAllUnits ( [ [ f_side , GetSide ( building ) ] , [ f_empty ] ] ) ;
54171: LD_ADDR_VAR 0 2
54175: PUSH
54176: LD_VAR 0 1
54180: PUSH
54181: LD_INT 22
54183: PUSH
54184: LD_VAR 0 1
54188: PPUSH
54189: CALL_OW 255
54193: PUSH
54194: EMPTY
54195: LIST
54196: LIST
54197: PUSH
54198: LD_INT 58
54200: PUSH
54201: EMPTY
54202: LIST
54203: PUSH
54204: EMPTY
54205: LIST
54206: LIST
54207: PPUSH
54208: CALL_OW 69
54212: IN
54213: ST_TO_ADDR
// end ;
54214: LD_VAR 0 2
54218: RET
// export function IsNotFull ( building ) ; begin
54219: LD_INT 0
54221: PPUSH
// if not building then
54222: LD_VAR 0 1
54226: NOT
54227: IFFALSE 54231
// exit ;
54229: GO 54250
// result := UnitsInside ( building ) < 6 ;
54231: LD_ADDR_VAR 0 2
54235: PUSH
54236: LD_VAR 0 1
54240: PPUSH
54241: CALL_OW 313
54245: PUSH
54246: LD_INT 6
54248: LESS
54249: ST_TO_ADDR
// end ;
54250: LD_VAR 0 2
54254: RET
// export function GetFacExt ( factory ) ; var tmp , i , list ; begin
54255: LD_INT 0
54257: PPUSH
54258: PPUSH
54259: PPUSH
54260: PPUSH
// tmp := [ ] ;
54261: LD_ADDR_VAR 0 3
54265: PUSH
54266: EMPTY
54267: ST_TO_ADDR
// list := [ ] ;
54268: LD_ADDR_VAR 0 5
54272: PUSH
54273: EMPTY
54274: ST_TO_ADDR
// for i = 16 to 25 do
54275: LD_ADDR_VAR 0 4
54279: PUSH
54280: DOUBLE
54281: LD_INT 16
54283: DEC
54284: ST_TO_ADDR
54285: LD_INT 25
54287: PUSH
54288: FOR_TO
54289: IFFALSE 54362
// tmp := tmp ^ FilterAllUnits ( [ [ [ f_side , GetSide ( factory ) ] , [ f_dist , factory , 6 ] , [ f_btype , i ] ] ] ) ;
54291: LD_ADDR_VAR 0 3
54295: PUSH
54296: LD_VAR 0 3
54300: PUSH
54301: LD_INT 22
54303: PUSH
54304: LD_VAR 0 1
54308: PPUSH
54309: CALL_OW 255
54313: PUSH
54314: EMPTY
54315: LIST
54316: LIST
54317: PUSH
54318: LD_INT 91
54320: PUSH
54321: LD_VAR 0 1
54325: PUSH
54326: LD_INT 6
54328: PUSH
54329: EMPTY
54330: LIST
54331: LIST
54332: LIST
54333: PUSH
54334: LD_INT 30
54336: PUSH
54337: LD_VAR 0 4
54341: PUSH
54342: EMPTY
54343: LIST
54344: LIST
54345: PUSH
54346: EMPTY
54347: LIST
54348: LIST
54349: LIST
54350: PUSH
54351: EMPTY
54352: LIST
54353: PPUSH
54354: CALL_OW 69
54358: ADD
54359: ST_TO_ADDR
54360: GO 54288
54362: POP
54363: POP
// for i = 1 to tmp do
54364: LD_ADDR_VAR 0 4
54368: PUSH
54369: DOUBLE
54370: LD_INT 1
54372: DEC
54373: ST_TO_ADDR
54374: LD_VAR 0 3
54378: PUSH
54379: FOR_TO
54380: IFFALSE 54468
// list := list ^ [ [ GetBType ( tmp [ i ] ) , GetX ( tmp [ i ] ) , GetY ( tmp [ i ] ) , GetDir ( tmp [ i ] ) ] ] ;
54382: LD_ADDR_VAR 0 5
54386: PUSH
54387: LD_VAR 0 5
54391: PUSH
54392: LD_VAR 0 3
54396: PUSH
54397: LD_VAR 0 4
54401: ARRAY
54402: PPUSH
54403: CALL_OW 266
54407: PUSH
54408: LD_VAR 0 3
54412: PUSH
54413: LD_VAR 0 4
54417: ARRAY
54418: PPUSH
54419: CALL_OW 250
54423: PUSH
54424: LD_VAR 0 3
54428: PUSH
54429: LD_VAR 0 4
54433: ARRAY
54434: PPUSH
54435: CALL_OW 251
54439: PUSH
54440: LD_VAR 0 3
54444: PUSH
54445: LD_VAR 0 4
54449: ARRAY
54450: PPUSH
54451: CALL_OW 254
54455: PUSH
54456: EMPTY
54457: LIST
54458: LIST
54459: LIST
54460: LIST
54461: PUSH
54462: EMPTY
54463: LIST
54464: ADD
54465: ST_TO_ADDR
54466: GO 54379
54468: POP
54469: POP
// result := list ;
54470: LD_ADDR_VAR 0 2
54474: PUSH
54475: LD_VAR 0 5
54479: ST_TO_ADDR
// end ;
54480: LD_VAR 0 2
54484: RET
// export function Produce ( factory , chassis , engine , control , weapon ) ; var i , tmp , _chassis , _weapon , _engine , _control ; begin
54485: LD_INT 0
54487: PPUSH
54488: PPUSH
54489: PPUSH
54490: PPUSH
54491: PPUSH
54492: PPUSH
54493: PPUSH
// if not factory then
54494: LD_VAR 0 1
54498: NOT
54499: IFFALSE 54503
// exit ;
54501: GO 55096
// if control = control_apeman then
54503: LD_VAR 0 4
54507: PUSH
54508: LD_INT 5
54510: EQUAL
54511: IFFALSE 54620
// begin tmp := UnitsInside ( factory ) ;
54513: LD_ADDR_VAR 0 8
54517: PUSH
54518: LD_VAR 0 1
54522: PPUSH
54523: CALL_OW 313
54527: ST_TO_ADDR
// if not UnitFilter ( tmp , [ f_class , class_apeman ] ) then
54528: LD_VAR 0 8
54532: PPUSH
54533: LD_INT 25
54535: PUSH
54536: LD_INT 12
54538: PUSH
54539: EMPTY
54540: LIST
54541: LIST
54542: PPUSH
54543: CALL_OW 72
54547: NOT
54548: IFFALSE 54558
// control := control_manual ;
54550: LD_ADDR_VAR 0 4
54554: PUSH
54555: LD_INT 1
54557: ST_TO_ADDR
// tmp := GetFacExt ( factory ) ;
54558: LD_ADDR_VAR 0 8
54562: PUSH
54563: LD_VAR 0 1
54567: PPUSH
54568: CALL 54255 0 1
54572: ST_TO_ADDR
// if tmp then
54573: LD_VAR 0 8
54577: IFFALSE 54620
// begin for i in tmp do
54579: LD_ADDR_VAR 0 7
54583: PUSH
54584: LD_VAR 0 8
54588: PUSH
54589: FOR_IN
54590: IFFALSE 54618
// if i [ 1 ] = b_ext_radio then
54592: LD_VAR 0 7
54596: PUSH
54597: LD_INT 1
54599: ARRAY
54600: PUSH
54601: LD_INT 22
54603: EQUAL
54604: IFFALSE 54616
// begin control := control_remote ;
54606: LD_ADDR_VAR 0 4
54610: PUSH
54611: LD_INT 2
54613: ST_TO_ADDR
// break ;
54614: GO 54618
// end ;
54616: GO 54589
54618: POP
54619: POP
// end ; end ; if CanBeConstructed ( factory , chassis , engine , control , weapon ) then
54620: LD_VAR 0 1
54624: PPUSH
54625: LD_VAR 0 2
54629: PPUSH
54630: LD_VAR 0 3
54634: PPUSH
54635: LD_VAR 0 4
54639: PPUSH
54640: LD_VAR 0 5
54644: PPUSH
54645: CALL_OW 448
54649: IFFALSE 54684
// begin result := [ chassis , engine , control , weapon ] ;
54651: LD_ADDR_VAR 0 6
54655: PUSH
54656: LD_VAR 0 2
54660: PUSH
54661: LD_VAR 0 3
54665: PUSH
54666: LD_VAR 0 4
54670: PUSH
54671: LD_VAR 0 5
54675: PUSH
54676: EMPTY
54677: LIST
54678: LIST
54679: LIST
54680: LIST
54681: ST_TO_ADDR
// exit ;
54682: GO 55096
// end ; _chassis := AvailableChassisList ( factory ) ;
54684: LD_ADDR_VAR 0 9
54688: PUSH
54689: LD_VAR 0 1
54693: PPUSH
54694: CALL_OW 475
54698: ST_TO_ADDR
// _engine := AvailableEngineList ( factory ) ;
54699: LD_ADDR_VAR 0 11
54703: PUSH
54704: LD_VAR 0 1
54708: PPUSH
54709: CALL_OW 476
54713: ST_TO_ADDR
// _control := AvailableControlList ( factory ) ;
54714: LD_ADDR_VAR 0 12
54718: PUSH
54719: LD_VAR 0 1
54723: PPUSH
54724: CALL_OW 477
54728: ST_TO_ADDR
// _weapon := AvailableWeaponList ( factory ) ;
54729: LD_ADDR_VAR 0 10
54733: PUSH
54734: LD_VAR 0 1
54738: PPUSH
54739: CALL_OW 478
54743: ST_TO_ADDR
// if not _chassis or not _engine or not _control or not _weapon then
54744: LD_VAR 0 9
54748: NOT
54749: PUSH
54750: LD_VAR 0 11
54754: NOT
54755: OR
54756: PUSH
54757: LD_VAR 0 12
54761: NOT
54762: OR
54763: PUSH
54764: LD_VAR 0 10
54768: NOT
54769: OR
54770: IFFALSE 54805
// begin result := [ chassis , engine , control , weapon ] ;
54772: LD_ADDR_VAR 0 6
54776: PUSH
54777: LD_VAR 0 2
54781: PUSH
54782: LD_VAR 0 3
54786: PUSH
54787: LD_VAR 0 4
54791: PUSH
54792: LD_VAR 0 5
54796: PUSH
54797: EMPTY
54798: LIST
54799: LIST
54800: LIST
54801: LIST
54802: ST_TO_ADDR
// exit ;
54803: GO 55096
// end ; if not chassis in _chassis then
54805: LD_VAR 0 2
54809: PUSH
54810: LD_VAR 0 9
54814: IN
54815: NOT
54816: IFFALSE 54842
// chassis := _chassis [ rand ( 1 , _chassis ) ] ;
54818: LD_ADDR_VAR 0 2
54822: PUSH
54823: LD_VAR 0 9
54827: PUSH
54828: LD_INT 1
54830: PPUSH
54831: LD_VAR 0 9
54835: PPUSH
54836: CALL_OW 12
54840: ARRAY
54841: ST_TO_ADDR
// if not EngineCanBeMount ( chassis , engine ) then
54842: LD_VAR 0 2
54846: PPUSH
54847: LD_VAR 0 3
54851: PPUSH
54852: CALL 55101 0 2
54856: NOT
54857: IFFALSE 54916
// repeat engine := _engine [ 1 ] ;
54859: LD_ADDR_VAR 0 3
54863: PUSH
54864: LD_VAR 0 11
54868: PUSH
54869: LD_INT 1
54871: ARRAY
54872: ST_TO_ADDR
// _engine := Delete ( _engine , 1 ) ;
54873: LD_ADDR_VAR 0 11
54877: PUSH
54878: LD_VAR 0 11
54882: PPUSH
54883: LD_INT 1
54885: PPUSH
54886: CALL_OW 3
54890: ST_TO_ADDR
// until EngineCanBeMount ( chassis , engine ) or _engine = [ ] ;
54891: LD_VAR 0 2
54895: PPUSH
54896: LD_VAR 0 3
54900: PPUSH
54901: CALL 55101 0 2
54905: PUSH
54906: LD_VAR 0 11
54910: PUSH
54911: EMPTY
54912: EQUAL
54913: OR
54914: IFFALSE 54859
// if not control in _control then
54916: LD_VAR 0 4
54920: PUSH
54921: LD_VAR 0 12
54925: IN
54926: NOT
54927: IFFALSE 54953
// control := _control [ rand ( 1 , _control ) ] ;
54929: LD_ADDR_VAR 0 4
54933: PUSH
54934: LD_VAR 0 12
54938: PUSH
54939: LD_INT 1
54941: PPUSH
54942: LD_VAR 0 12
54946: PPUSH
54947: CALL_OW 12
54951: ARRAY
54952: ST_TO_ADDR
// if not WeaponCanBeMount ( chassis , weapon ) then
54953: LD_VAR 0 2
54957: PPUSH
54958: LD_VAR 0 5
54962: PPUSH
54963: CALL 55321 0 2
54967: NOT
54968: IFFALSE 55027
// repeat weapon := _weapon [ 1 ] ;
54970: LD_ADDR_VAR 0 5
54974: PUSH
54975: LD_VAR 0 10
54979: PUSH
54980: LD_INT 1
54982: ARRAY
54983: ST_TO_ADDR
// _weapon := Delete ( _weapon , 1 ) ;
54984: LD_ADDR_VAR 0 10
54988: PUSH
54989: LD_VAR 0 10
54993: PPUSH
54994: LD_INT 1
54996: PPUSH
54997: CALL_OW 3
55001: ST_TO_ADDR
// until WeaponCanBeMount ( chassis , weapon ) or _weapon = [ ] ;
55002: LD_VAR 0 2
55006: PPUSH
55007: LD_VAR 0 5
55011: PPUSH
55012: CALL 55321 0 2
55016: PUSH
55017: LD_VAR 0 10
55021: PUSH
55022: EMPTY
55023: EQUAL
55024: OR
55025: IFFALSE 54970
// result := [ ] ;
55027: LD_ADDR_VAR 0 6
55031: PUSH
55032: EMPTY
55033: ST_TO_ADDR
// if CanBeConstructed ( factory , chassis , engine , control , weapon ) then
55034: LD_VAR 0 1
55038: PPUSH
55039: LD_VAR 0 2
55043: PPUSH
55044: LD_VAR 0 3
55048: PPUSH
55049: LD_VAR 0 4
55053: PPUSH
55054: LD_VAR 0 5
55058: PPUSH
55059: CALL_OW 448
55063: IFFALSE 55096
// result := [ chassis , engine , control , weapon ] ;
55065: LD_ADDR_VAR 0 6
55069: PUSH
55070: LD_VAR 0 2
55074: PUSH
55075: LD_VAR 0 3
55079: PUSH
55080: LD_VAR 0 4
55084: PUSH
55085: LD_VAR 0 5
55089: PUSH
55090: EMPTY
55091: LIST
55092: LIST
55093: LIST
55094: LIST
55095: ST_TO_ADDR
// end ;
55096: LD_VAR 0 6
55100: RET
// export function EngineCanBeMount ( chassis , engine ) ; begin
55101: LD_INT 0
55103: PPUSH
// if not chassis or not engine then
55104: LD_VAR 0 1
55108: NOT
55109: PUSH
55110: LD_VAR 0 2
55114: NOT
55115: OR
55116: IFFALSE 55120
// exit ;
55118: GO 55316
// case engine of engine_solar :
55120: LD_VAR 0 2
55124: PUSH
55125: LD_INT 2
55127: DOUBLE
55128: EQUAL
55129: IFTRUE 55133
55131: GO 55171
55133: POP
// result := [ ar_hovercraft , ar_light_trike , ar_medium_trike , ar_half_tracked , us_light_wheeled , us_medium_wheeled , us_medium_tracked ] ; engine_combustion :
55134: LD_ADDR_VAR 0 3
55138: PUSH
55139: LD_INT 11
55141: PUSH
55142: LD_INT 12
55144: PUSH
55145: LD_INT 13
55147: PUSH
55148: LD_INT 14
55150: PUSH
55151: LD_INT 1
55153: PUSH
55154: LD_INT 2
55156: PUSH
55157: LD_INT 3
55159: PUSH
55160: EMPTY
55161: LIST
55162: LIST
55163: LIST
55164: LIST
55165: LIST
55166: LIST
55167: LIST
55168: ST_TO_ADDR
55169: GO 55300
55171: LD_INT 1
55173: DOUBLE
55174: EQUAL
55175: IFTRUE 55179
55177: GO 55241
55179: POP
// result := [ ar_hovercraft , ar_light_trike , ar_medium_trike , ar_half_tracked , us_light_wheeled , us_medium_wheeled , us_medium_tracked , us_heavy_tracked , us_morphling , ru_medium_wheeled , ru_heavy_wheeled , ru_medium_tracked , ru_heavy_tracked ] ; engine_siberite :
55180: LD_ADDR_VAR 0 3
55184: PUSH
55185: LD_INT 11
55187: PUSH
55188: LD_INT 12
55190: PUSH
55191: LD_INT 13
55193: PUSH
55194: LD_INT 14
55196: PUSH
55197: LD_INT 1
55199: PUSH
55200: LD_INT 2
55202: PUSH
55203: LD_INT 3
55205: PUSH
55206: LD_INT 4
55208: PUSH
55209: LD_INT 5
55211: PUSH
55212: LD_INT 21
55214: PUSH
55215: LD_INT 23
55217: PUSH
55218: LD_INT 22
55220: PUSH
55221: LD_INT 24
55223: PUSH
55224: EMPTY
55225: LIST
55226: LIST
55227: LIST
55228: LIST
55229: LIST
55230: LIST
55231: LIST
55232: LIST
55233: LIST
55234: LIST
55235: LIST
55236: LIST
55237: LIST
55238: ST_TO_ADDR
55239: GO 55300
55241: LD_INT 3
55243: DOUBLE
55244: EQUAL
55245: IFTRUE 55249
55247: GO 55299
55249: POP
// result := [ ar_medium_trike , ar_half_tracked , us_medium_wheeled , us_medium_tracked , us_heavy_tracked , us_morphling , ru_medium_wheeled , ru_medium_tracked , ru_heavy_wheeled , ru_heavy_tracked ] ; end ;
55250: LD_ADDR_VAR 0 3
55254: PUSH
55255: LD_INT 13
55257: PUSH
55258: LD_INT 14
55260: PUSH
55261: LD_INT 2
55263: PUSH
55264: LD_INT 3
55266: PUSH
55267: LD_INT 4
55269: PUSH
55270: LD_INT 5
55272: PUSH
55273: LD_INT 21
55275: PUSH
55276: LD_INT 22
55278: PUSH
55279: LD_INT 23
55281: PUSH
55282: LD_INT 24
55284: PUSH
55285: EMPTY
55286: LIST
55287: LIST
55288: LIST
55289: LIST
55290: LIST
55291: LIST
55292: LIST
55293: LIST
55294: LIST
55295: LIST
55296: ST_TO_ADDR
55297: GO 55300
55299: POP
// result := ( chassis in result ) ;
55300: LD_ADDR_VAR 0 3
55304: PUSH
55305: LD_VAR 0 1
55309: PUSH
55310: LD_VAR 0 3
55314: IN
55315: ST_TO_ADDR
// end ;
55316: LD_VAR 0 3
55320: RET
// export function WeaponCanBeMount ( chassis , weapon ) ; begin
55321: LD_INT 0
55323: PPUSH
// if not chassis or not weapon then
55324: LD_VAR 0 1
55328: NOT
55329: PUSH
55330: LD_VAR 0 2
55334: NOT
55335: OR
55336: IFFALSE 55340
// exit ;
55338: GO 56366
// case weapon of us_machine_gun :
55340: LD_VAR 0 2
55344: PUSH
55345: LD_INT 2
55347: DOUBLE
55348: EQUAL
55349: IFTRUE 55353
55351: GO 55383
55353: POP
// result := [ us_light_wheeled , us_medium_wheeled , us_medium_tracked , us_heavy_tracked , us_morphling ] ; us_light_gun :
55354: LD_ADDR_VAR 0 3
55358: PUSH
55359: LD_INT 1
55361: PUSH
55362: LD_INT 2
55364: PUSH
55365: LD_INT 3
55367: PUSH
55368: LD_INT 4
55370: PUSH
55371: LD_INT 5
55373: PUSH
55374: EMPTY
55375: LIST
55376: LIST
55377: LIST
55378: LIST
55379: LIST
55380: ST_TO_ADDR
55381: GO 56350
55383: LD_INT 3
55385: DOUBLE
55386: EQUAL
55387: IFTRUE 55391
55389: GO 55421
55391: POP
// result := [ us_light_wheeled , us_medium_wheeled , us_medium_tracked , us_heavy_tracked , us_morphling ] ; us_radar :
55392: LD_ADDR_VAR 0 3
55396: PUSH
55397: LD_INT 1
55399: PUSH
55400: LD_INT 2
55402: PUSH
55403: LD_INT 3
55405: PUSH
55406: LD_INT 4
55408: PUSH
55409: LD_INT 5
55411: PUSH
55412: EMPTY
55413: LIST
55414: LIST
55415: LIST
55416: LIST
55417: LIST
55418: ST_TO_ADDR
55419: GO 56350
55421: LD_INT 11
55423: DOUBLE
55424: EQUAL
55425: IFTRUE 55429
55427: GO 55459
55429: POP
// result := [ us_light_wheeled , us_medium_wheeled , us_medium_tracked , us_heavy_tracked , us_morphling ] ; us_gatling_gun :
55430: LD_ADDR_VAR 0 3
55434: PUSH
55435: LD_INT 1
55437: PUSH
55438: LD_INT 2
55440: PUSH
55441: LD_INT 3
55443: PUSH
55444: LD_INT 4
55446: PUSH
55447: LD_INT 5
55449: PUSH
55450: EMPTY
55451: LIST
55452: LIST
55453: LIST
55454: LIST
55455: LIST
55456: ST_TO_ADDR
55457: GO 56350
55459: LD_INT 4
55461: DOUBLE
55462: EQUAL
55463: IFTRUE 55467
55465: GO 55493
55467: POP
// result := [ us_medium_wheeled , us_medium_tracked , us_heavy_tracked , us_morphling ] ; us_double_gun :
55468: LD_ADDR_VAR 0 3
55472: PUSH
55473: LD_INT 2
55475: PUSH
55476: LD_INT 3
55478: PUSH
55479: LD_INT 4
55481: PUSH
55482: LD_INT 5
55484: PUSH
55485: EMPTY
55486: LIST
55487: LIST
55488: LIST
55489: LIST
55490: ST_TO_ADDR
55491: GO 56350
55493: LD_INT 5
55495: DOUBLE
55496: EQUAL
55497: IFTRUE 55501
55499: GO 55527
55501: POP
// result := [ us_medium_wheeled , us_medium_tracked , us_heavy_tracked , us_morphling ] ; us_laser :
55502: LD_ADDR_VAR 0 3
55506: PUSH
55507: LD_INT 2
55509: PUSH
55510: LD_INT 3
55512: PUSH
55513: LD_INT 4
55515: PUSH
55516: LD_INT 5
55518: PUSH
55519: EMPTY
55520: LIST
55521: LIST
55522: LIST
55523: LIST
55524: ST_TO_ADDR
55525: GO 56350
55527: LD_INT 9
55529: DOUBLE
55530: EQUAL
55531: IFTRUE 55535
55533: GO 55561
55535: POP
// result := [ us_medium_wheeled , us_medium_tracked , us_heavy_tracked , us_morphling ] ; us_rocket_launcher :
55536: LD_ADDR_VAR 0 3
55540: PUSH
55541: LD_INT 2
55543: PUSH
55544: LD_INT 3
55546: PUSH
55547: LD_INT 4
55549: PUSH
55550: LD_INT 5
55552: PUSH
55553: EMPTY
55554: LIST
55555: LIST
55556: LIST
55557: LIST
55558: ST_TO_ADDR
55559: GO 56350
55561: LD_INT 7
55563: DOUBLE
55564: EQUAL
55565: IFTRUE 55569
55567: GO 55595
55569: POP
// result := [ us_medium_wheeled , us_medium_tracked , us_heavy_tracked , us_morphling ] ; us_cargo_bay :
55570: LD_ADDR_VAR 0 3
55574: PUSH
55575: LD_INT 2
55577: PUSH
55578: LD_INT 3
55580: PUSH
55581: LD_INT 4
55583: PUSH
55584: LD_INT 5
55586: PUSH
55587: EMPTY
55588: LIST
55589: LIST
55590: LIST
55591: LIST
55592: ST_TO_ADDR
55593: GO 56350
55595: LD_INT 12
55597: DOUBLE
55598: EQUAL
55599: IFTRUE 55603
55601: GO 55629
55603: POP
// result := [ us_medium_wheeled , us_medium_tracked , us_heavy_tracked , us_morphling ] ; us_crane :
55604: LD_ADDR_VAR 0 3
55608: PUSH
55609: LD_INT 2
55611: PUSH
55612: LD_INT 3
55614: PUSH
55615: LD_INT 4
55617: PUSH
55618: LD_INT 5
55620: PUSH
55621: EMPTY
55622: LIST
55623: LIST
55624: LIST
55625: LIST
55626: ST_TO_ADDR
55627: GO 56350
55629: LD_INT 13
55631: DOUBLE
55632: EQUAL
55633: IFTRUE 55637
55635: GO 55663
55637: POP
// result := [ us_medium_wheeled , us_medium_tracked , us_heavy_tracked , us_morphling ] ; us_bulldozer :
55638: LD_ADDR_VAR 0 3
55642: PUSH
55643: LD_INT 2
55645: PUSH
55646: LD_INT 3
55648: PUSH
55649: LD_INT 4
55651: PUSH
55652: LD_INT 5
55654: PUSH
55655: EMPTY
55656: LIST
55657: LIST
55658: LIST
55659: LIST
55660: ST_TO_ADDR
55661: GO 56350
55663: LD_INT 14
55665: DOUBLE
55666: EQUAL
55667: IFTRUE 55671
55669: GO 55689
55671: POP
// result := [ us_heavy_tracked , us_morphling ] ; us_heavy_gun :
55672: LD_ADDR_VAR 0 3
55676: PUSH
55677: LD_INT 4
55679: PUSH
55680: LD_INT 5
55682: PUSH
55683: EMPTY
55684: LIST
55685: LIST
55686: ST_TO_ADDR
55687: GO 56350
55689: LD_INT 6
55691: DOUBLE
55692: EQUAL
55693: IFTRUE 55697
55695: GO 55715
55697: POP
// result := [ us_heavy_tracked , us_morphling ] ; us_double_laser :
55698: LD_ADDR_VAR 0 3
55702: PUSH
55703: LD_INT 4
55705: PUSH
55706: LD_INT 5
55708: PUSH
55709: EMPTY
55710: LIST
55711: LIST
55712: ST_TO_ADDR
55713: GO 56350
55715: LD_INT 10
55717: DOUBLE
55718: EQUAL
55719: IFTRUE 55723
55721: GO 55741
55723: POP
// result := [ us_heavy_tracked , us_morphling ] ; ar_multimissile_ballista :
55724: LD_ADDR_VAR 0 3
55728: PUSH
55729: LD_INT 4
55731: PUSH
55732: LD_INT 5
55734: PUSH
55735: EMPTY
55736: LIST
55737: LIST
55738: ST_TO_ADDR
55739: GO 56350
55741: LD_INT 22
55743: DOUBLE
55744: EQUAL
55745: IFTRUE 55749
55747: GO 55775
55749: POP
// result := [ ar_hovercraft , ar_light_trike , ar_medium_trike , ar_half_tracked ] ; ar_light_gun :
55750: LD_ADDR_VAR 0 3
55754: PUSH
55755: LD_INT 11
55757: PUSH
55758: LD_INT 12
55760: PUSH
55761: LD_INT 13
55763: PUSH
55764: LD_INT 14
55766: PUSH
55767: EMPTY
55768: LIST
55769: LIST
55770: LIST
55771: LIST
55772: ST_TO_ADDR
55773: GO 56350
55775: LD_INT 23
55777: DOUBLE
55778: EQUAL
55779: IFTRUE 55783
55781: GO 55809
55783: POP
// result := [ ar_hovercraft , ar_light_trike , ar_medium_trike , ar_half_tracked ] ; ar_double_machine_gun :
55784: LD_ADDR_VAR 0 3
55788: PUSH
55789: LD_INT 11
55791: PUSH
55792: LD_INT 12
55794: PUSH
55795: LD_INT 13
55797: PUSH
55798: LD_INT 14
55800: PUSH
55801: EMPTY
55802: LIST
55803: LIST
55804: LIST
55805: LIST
55806: ST_TO_ADDR
55807: GO 56350
55809: LD_INT 24
55811: DOUBLE
55812: EQUAL
55813: IFTRUE 55817
55815: GO 55843
55817: POP
// result := [ ar_hovercraft , ar_light_trike , ar_medium_trike , ar_half_tracked ] ; ar_radar :
55818: LD_ADDR_VAR 0 3
55822: PUSH
55823: LD_INT 11
55825: PUSH
55826: LD_INT 12
55828: PUSH
55829: LD_INT 13
55831: PUSH
55832: LD_INT 14
55834: PUSH
55835: EMPTY
55836: LIST
55837: LIST
55838: LIST
55839: LIST
55840: ST_TO_ADDR
55841: GO 56350
55843: LD_INT 30
55845: DOUBLE
55846: EQUAL
55847: IFTRUE 55851
55849: GO 55877
55851: POP
// result := [ ar_hovercraft , ar_light_trike , ar_medium_trike , ar_half_tracked ] ; ar_gatling_gun :
55852: LD_ADDR_VAR 0 3
55856: PUSH
55857: LD_INT 11
55859: PUSH
55860: LD_INT 12
55862: PUSH
55863: LD_INT 13
55865: PUSH
55866: LD_INT 14
55868: PUSH
55869: EMPTY
55870: LIST
55871: LIST
55872: LIST
55873: LIST
55874: ST_TO_ADDR
55875: GO 56350
55877: LD_INT 25
55879: DOUBLE
55880: EQUAL
55881: IFTRUE 55885
55883: GO 55903
55885: POP
// result := [ ar_medium_trike , ar_half_tracked ] ; ar_gun :
55886: LD_ADDR_VAR 0 3
55890: PUSH
55891: LD_INT 13
55893: PUSH
55894: LD_INT 14
55896: PUSH
55897: EMPTY
55898: LIST
55899: LIST
55900: ST_TO_ADDR
55901: GO 56350
55903: LD_INT 27
55905: DOUBLE
55906: EQUAL
55907: IFTRUE 55911
55909: GO 55929
55911: POP
// result := [ ar_medium_trike , ar_half_tracked ] ; ar_rocket_launcher :
55912: LD_ADDR_VAR 0 3
55916: PUSH
55917: LD_INT 13
55919: PUSH
55920: LD_INT 14
55922: PUSH
55923: EMPTY
55924: LIST
55925: LIST
55926: ST_TO_ADDR
55927: GO 56350
55929: LD_INT 28
55931: DOUBLE
55932: EQUAL
55933: IFTRUE 55937
55935: GO 55955
55937: POP
// result := [ ar_medium_trike , ar_half_tracked ] ; ar_selfpropelled_bomb :
55938: LD_ADDR_VAR 0 3
55942: PUSH
55943: LD_INT 13
55945: PUSH
55946: LD_INT 14
55948: PUSH
55949: EMPTY
55950: LIST
55951: LIST
55952: ST_TO_ADDR
55953: GO 56350
55955: LD_INT 29
55957: DOUBLE
55958: EQUAL
55959: IFTRUE 55963
55961: GO 55981
55963: POP
// result := [ ar_medium_trike , ar_half_tracked ] ; ar_control_tower :
55964: LD_ADDR_VAR 0 3
55968: PUSH
55969: LD_INT 13
55971: PUSH
55972: LD_INT 14
55974: PUSH
55975: EMPTY
55976: LIST
55977: LIST
55978: ST_TO_ADDR
55979: GO 56350
55981: LD_INT 31
55983: DOUBLE
55984: EQUAL
55985: IFTRUE 55989
55987: GO 56007
55989: POP
// result := [ ar_medium_trike , ar_half_tracked ] ; ar_flame_thrower :
55990: LD_ADDR_VAR 0 3
55994: PUSH
55995: LD_INT 13
55997: PUSH
55998: LD_INT 14
56000: PUSH
56001: EMPTY
56002: LIST
56003: LIST
56004: ST_TO_ADDR
56005: GO 56350
56007: LD_INT 26
56009: DOUBLE
56010: EQUAL
56011: IFTRUE 56015
56013: GO 56033
56015: POP
// result := [ ar_medium_trike , ar_half_tracked ] ; ru_heavy_machine_gun :
56016: LD_ADDR_VAR 0 3
56020: PUSH
56021: LD_INT 13
56023: PUSH
56024: LD_INT 14
56026: PUSH
56027: EMPTY
56028: LIST
56029: LIST
56030: ST_TO_ADDR
56031: GO 56350
56033: LD_INT 42
56035: DOUBLE
56036: EQUAL
56037: IFTRUE 56041
56039: GO 56067
56041: POP
// result := [ ru_medium_wheeled , ru_medium_tracked , ru_heavy_wheeled , ru_heavy_tracked ] ; ru_gatling_gun :
56042: LD_ADDR_VAR 0 3
56046: PUSH
56047: LD_INT 21
56049: PUSH
56050: LD_INT 22
56052: PUSH
56053: LD_INT 23
56055: PUSH
56056: LD_INT 24
56058: PUSH
56059: EMPTY
56060: LIST
56061: LIST
56062: LIST
56063: LIST
56064: ST_TO_ADDR
56065: GO 56350
56067: LD_INT 43
56069: DOUBLE
56070: EQUAL
56071: IFTRUE 56075
56073: GO 56101
56075: POP
// result := [ ru_medium_wheeled , ru_medium_tracked , ru_heavy_wheeled , ru_heavy_tracked ] ; ru_gun :
56076: LD_ADDR_VAR 0 3
56080: PUSH
56081: LD_INT 21
56083: PUSH
56084: LD_INT 22
56086: PUSH
56087: LD_INT 23
56089: PUSH
56090: LD_INT 24
56092: PUSH
56093: EMPTY
56094: LIST
56095: LIST
56096: LIST
56097: LIST
56098: ST_TO_ADDR
56099: GO 56350
56101: LD_INT 44
56103: DOUBLE
56104: EQUAL
56105: IFTRUE 56109
56107: GO 56135
56109: POP
// result := [ ru_medium_wheeled , ru_medium_tracked , ru_heavy_wheeled , ru_heavy_tracked ] ; ru_rocket_launcher :
56110: LD_ADDR_VAR 0 3
56114: PUSH
56115: LD_INT 21
56117: PUSH
56118: LD_INT 22
56120: PUSH
56121: LD_INT 23
56123: PUSH
56124: LD_INT 24
56126: PUSH
56127: EMPTY
56128: LIST
56129: LIST
56130: LIST
56131: LIST
56132: ST_TO_ADDR
56133: GO 56350
56135: LD_INT 45
56137: DOUBLE
56138: EQUAL
56139: IFTRUE 56143
56141: GO 56169
56143: POP
// result := [ ru_medium_wheeled , ru_medium_tracked , ru_heavy_wheeled , ru_heavy_tracked ] ; ru_time_lapser :
56144: LD_ADDR_VAR 0 3
56148: PUSH
56149: LD_INT 21
56151: PUSH
56152: LD_INT 22
56154: PUSH
56155: LD_INT 23
56157: PUSH
56158: LD_INT 24
56160: PUSH
56161: EMPTY
56162: LIST
56163: LIST
56164: LIST
56165: LIST
56166: ST_TO_ADDR
56167: GO 56350
56169: LD_INT 49
56171: DOUBLE
56172: EQUAL
56173: IFTRUE 56177
56175: GO 56203
56177: POP
// result := [ ru_medium_wheeled , ru_medium_tracked , ru_heavy_wheeled , ru_heavy_tracked ] ; ru_cargo_bay :
56178: LD_ADDR_VAR 0 3
56182: PUSH
56183: LD_INT 21
56185: PUSH
56186: LD_INT 22
56188: PUSH
56189: LD_INT 23
56191: PUSH
56192: LD_INT 24
56194: PUSH
56195: EMPTY
56196: LIST
56197: LIST
56198: LIST
56199: LIST
56200: ST_TO_ADDR
56201: GO 56350
56203: LD_INT 51
56205: DOUBLE
56206: EQUAL
56207: IFTRUE 56211
56209: GO 56237
56211: POP
// result := [ ru_medium_wheeled , ru_medium_tracked , ru_heavy_wheeled , ru_heavy_tracked ] ; ru_crane :
56212: LD_ADDR_VAR 0 3
56216: PUSH
56217: LD_INT 21
56219: PUSH
56220: LD_INT 22
56222: PUSH
56223: LD_INT 23
56225: PUSH
56226: LD_INT 24
56228: PUSH
56229: EMPTY
56230: LIST
56231: LIST
56232: LIST
56233: LIST
56234: ST_TO_ADDR
56235: GO 56350
56237: LD_INT 52
56239: DOUBLE
56240: EQUAL
56241: IFTRUE 56245
56243: GO 56271
56245: POP
// result := [ ru_medium_wheeled , ru_medium_tracked , ru_heavy_wheeled , ru_heavy_tracked ] ; ru_bulldozer :
56246: LD_ADDR_VAR 0 3
56250: PUSH
56251: LD_INT 21
56253: PUSH
56254: LD_INT 22
56256: PUSH
56257: LD_INT 23
56259: PUSH
56260: LD_INT 24
56262: PUSH
56263: EMPTY
56264: LIST
56265: LIST
56266: LIST
56267: LIST
56268: ST_TO_ADDR
56269: GO 56350
56271: LD_INT 53
56273: DOUBLE
56274: EQUAL
56275: IFTRUE 56279
56277: GO 56297
56279: POP
// result := [ ru_heavy_wheeled , ru_heavy_tracked ] ; ru_heavy_gun :
56280: LD_ADDR_VAR 0 3
56284: PUSH
56285: LD_INT 23
56287: PUSH
56288: LD_INT 24
56290: PUSH
56291: EMPTY
56292: LIST
56293: LIST
56294: ST_TO_ADDR
56295: GO 56350
56297: LD_INT 46
56299: DOUBLE
56300: EQUAL
56301: IFTRUE 56305
56303: GO 56323
56305: POP
// result := [ ru_heavy_wheeled , ru_heavy_tracked ] ; ru_rocket :
56306: LD_ADDR_VAR 0 3
56310: PUSH
56311: LD_INT 23
56313: PUSH
56314: LD_INT 24
56316: PUSH
56317: EMPTY
56318: LIST
56319: LIST
56320: ST_TO_ADDR
56321: GO 56350
56323: LD_INT 47
56325: DOUBLE
56326: EQUAL
56327: IFTRUE 56331
56329: GO 56349
56331: POP
// result := [ ru_heavy_wheeled , ru_heavy_tracked ] ; end ;
56332: LD_ADDR_VAR 0 3
56336: PUSH
56337: LD_INT 23
56339: PUSH
56340: LD_INT 24
56342: PUSH
56343: EMPTY
56344: LIST
56345: LIST
56346: ST_TO_ADDR
56347: GO 56350
56349: POP
// result := ( chassis in result ) ;
56350: LD_ADDR_VAR 0 3
56354: PUSH
56355: LD_VAR 0 1
56359: PUSH
56360: LD_VAR 0 3
56364: IN
56365: ST_TO_ADDR
// end ;
56366: LD_VAR 0 3
56370: RET
// export function Reindex ( array , i_from , i_to , direction ) ; var i , j , k , d , tmp , length ; begin
56371: LD_INT 0
56373: PPUSH
56374: PPUSH
56375: PPUSH
56376: PPUSH
56377: PPUSH
56378: PPUSH
56379: PPUSH
// result := array ;
56380: LD_ADDR_VAR 0 5
56384: PUSH
56385: LD_VAR 0 1
56389: ST_TO_ADDR
// if not array or not i_from or not i_to or i_from > array or i_to > array then
56390: LD_VAR 0 1
56394: NOT
56395: PUSH
56396: LD_VAR 0 2
56400: NOT
56401: OR
56402: PUSH
56403: LD_VAR 0 3
56407: NOT
56408: OR
56409: PUSH
56410: LD_VAR 0 2
56414: PUSH
56415: LD_VAR 0 1
56419: GREATER
56420: OR
56421: PUSH
56422: LD_VAR 0 3
56426: PUSH
56427: LD_VAR 0 1
56431: GREATER
56432: OR
56433: IFFALSE 56437
// exit ;
56435: GO 56733
// if direction then
56437: LD_VAR 0 4
56441: IFFALSE 56505
// begin d := 1 ;
56443: LD_ADDR_VAR 0 9
56447: PUSH
56448: LD_INT 1
56450: ST_TO_ADDR
// if i_from > i_to then
56451: LD_VAR 0 2
56455: PUSH
56456: LD_VAR 0 3
56460: GREATER
56461: IFFALSE 56487
// length := ( array - i_from ) + i_to else
56463: LD_ADDR_VAR 0 11
56467: PUSH
56468: LD_VAR 0 1
56472: PUSH
56473: LD_VAR 0 2
56477: MINUS
56478: PUSH
56479: LD_VAR 0 3
56483: PLUS
56484: ST_TO_ADDR
56485: GO 56503
// length := i_to - i_from ;
56487: LD_ADDR_VAR 0 11
56491: PUSH
56492: LD_VAR 0 3
56496: PUSH
56497: LD_VAR 0 2
56501: MINUS
56502: ST_TO_ADDR
// end else
56503: GO 56566
// begin d := - 1 ;
56505: LD_ADDR_VAR 0 9
56509: PUSH
56510: LD_INT 1
56512: NEG
56513: ST_TO_ADDR
// if i_from > i_to then
56514: LD_VAR 0 2
56518: PUSH
56519: LD_VAR 0 3
56523: GREATER
56524: IFFALSE 56544
// length := i_from - i_to else
56526: LD_ADDR_VAR 0 11
56530: PUSH
56531: LD_VAR 0 2
56535: PUSH
56536: LD_VAR 0 3
56540: MINUS
56541: ST_TO_ADDR
56542: GO 56566
// length := ( array - i_to ) + i_from ;
56544: LD_ADDR_VAR 0 11
56548: PUSH
56549: LD_VAR 0 1
56553: PUSH
56554: LD_VAR 0 3
56558: MINUS
56559: PUSH
56560: LD_VAR 0 2
56564: PLUS
56565: ST_TO_ADDR
// end ; if not length then
56566: LD_VAR 0 11
56570: NOT
56571: IFFALSE 56575
// exit ;
56573: GO 56733
// tmp := array ;
56575: LD_ADDR_VAR 0 10
56579: PUSH
56580: LD_VAR 0 1
56584: ST_TO_ADDR
// for i = 1 to length do
56585: LD_ADDR_VAR 0 6
56589: PUSH
56590: DOUBLE
56591: LD_INT 1
56593: DEC
56594: ST_TO_ADDR
56595: LD_VAR 0 11
56599: PUSH
56600: FOR_TO
56601: IFFALSE 56721
// begin for j = 1 to array do
56603: LD_ADDR_VAR 0 7
56607: PUSH
56608: DOUBLE
56609: LD_INT 1
56611: DEC
56612: ST_TO_ADDR
56613: LD_VAR 0 1
56617: PUSH
56618: FOR_TO
56619: IFFALSE 56707
// begin k := j + d ;
56621: LD_ADDR_VAR 0 8
56625: PUSH
56626: LD_VAR 0 7
56630: PUSH
56631: LD_VAR 0 9
56635: PLUS
56636: ST_TO_ADDR
// if k > array then
56637: LD_VAR 0 8
56641: PUSH
56642: LD_VAR 0 1
56646: GREATER
56647: IFFALSE 56657
// k := 1 ;
56649: LD_ADDR_VAR 0 8
56653: PUSH
56654: LD_INT 1
56656: ST_TO_ADDR
// if not k then
56657: LD_VAR 0 8
56661: NOT
56662: IFFALSE 56674
// k := array ;
56664: LD_ADDR_VAR 0 8
56668: PUSH
56669: LD_VAR 0 1
56673: ST_TO_ADDR
// tmp := Replace ( tmp , k , array [ j ] ) ;
56674: LD_ADDR_VAR 0 10
56678: PUSH
56679: LD_VAR 0 10
56683: PPUSH
56684: LD_VAR 0 8
56688: PPUSH
56689: LD_VAR 0 1
56693: PUSH
56694: LD_VAR 0 7
56698: ARRAY
56699: PPUSH
56700: CALL_OW 1
56704: ST_TO_ADDR
// end ;
56705: GO 56618
56707: POP
56708: POP
// array := tmp ;
56709: LD_ADDR_VAR 0 1
56713: PUSH
56714: LD_VAR 0 10
56718: ST_TO_ADDR
// end ;
56719: GO 56600
56721: POP
56722: POP
// result := array ;
56723: LD_ADDR_VAR 0 5
56727: PUSH
56728: LD_VAR 0 1
56732: ST_TO_ADDR
// end ;
56733: LD_VAR 0 5
56737: RET
// export function GetElementIndex ( array , value ) ; var i ; begin
56738: LD_INT 0
56740: PPUSH
56741: PPUSH
// result := 0 ;
56742: LD_ADDR_VAR 0 3
56746: PUSH
56747: LD_INT 0
56749: ST_TO_ADDR
// if not array or not value in array then
56750: LD_VAR 0 1
56754: NOT
56755: PUSH
56756: LD_VAR 0 2
56760: PUSH
56761: LD_VAR 0 1
56765: IN
56766: NOT
56767: OR
56768: IFFALSE 56772
// exit ;
56770: GO 56826
// for i = 1 to array do
56772: LD_ADDR_VAR 0 4
56776: PUSH
56777: DOUBLE
56778: LD_INT 1
56780: DEC
56781: ST_TO_ADDR
56782: LD_VAR 0 1
56786: PUSH
56787: FOR_TO
56788: IFFALSE 56824
// if value = array [ i ] then
56790: LD_VAR 0 2
56794: PUSH
56795: LD_VAR 0 1
56799: PUSH
56800: LD_VAR 0 4
56804: ARRAY
56805: EQUAL
56806: IFFALSE 56822
// begin result := i ;
56808: LD_ADDR_VAR 0 3
56812: PUSH
56813: LD_VAR 0 4
56817: ST_TO_ADDR
// exit ;
56818: POP
56819: POP
56820: GO 56826
// end ;
56822: GO 56787
56824: POP
56825: POP
// end ;
56826: LD_VAR 0 3
56830: RET
// export function PrepareVehicle ( chassis , engine , control , weapon , fuel ) ; begin
56831: LD_INT 0
56833: PPUSH
// vc_chassis := chassis ;
56834: LD_ADDR_OWVAR 37
56838: PUSH
56839: LD_VAR 0 1
56843: ST_TO_ADDR
// vc_engine := engine ;
56844: LD_ADDR_OWVAR 39
56848: PUSH
56849: LD_VAR 0 2
56853: ST_TO_ADDR
// vc_control := control ;
56854: LD_ADDR_OWVAR 38
56858: PUSH
56859: LD_VAR 0 3
56863: ST_TO_ADDR
// vc_weapon := weapon ;
56864: LD_ADDR_OWVAR 40
56868: PUSH
56869: LD_VAR 0 4
56873: ST_TO_ADDR
// vc_fuel_battery := fuel ;
56874: LD_ADDR_OWVAR 41
56878: PUSH
56879: LD_VAR 0 5
56883: ST_TO_ADDR
// end ;
56884: LD_VAR 0 6
56888: RET
// export function WantPlant ( unit ) ; var task ; begin
56889: LD_INT 0
56891: PPUSH
56892: PPUSH
// result := false ;
56893: LD_ADDR_VAR 0 2
56897: PUSH
56898: LD_INT 0
56900: ST_TO_ADDR
// task := GetTaskList ( unit ) ;
56901: LD_ADDR_VAR 0 3
56905: PUSH
56906: LD_VAR 0 1
56910: PPUSH
56911: CALL_OW 437
56915: ST_TO_ADDR
// if task then
56916: LD_VAR 0 3
56920: IFFALSE 56948
// if task [ 1 ] [ 1 ] = p then
56922: LD_VAR 0 3
56926: PUSH
56927: LD_INT 1
56929: ARRAY
56930: PUSH
56931: LD_INT 1
56933: ARRAY
56934: PUSH
56935: LD_STRING p
56937: EQUAL
56938: IFFALSE 56948
// result := true ;
56940: LD_ADDR_VAR 0 2
56944: PUSH
56945: LD_INT 1
56947: ST_TO_ADDR
// end ;
56948: LD_VAR 0 2
56952: RET
// export function ReplaceIn ( arr , pos , value ) ; var i , tmp , s_arr ; begin
56953: LD_INT 0
56955: PPUSH
56956: PPUSH
56957: PPUSH
56958: PPUSH
// if pos < 1 then
56959: LD_VAR 0 2
56963: PUSH
56964: LD_INT 1
56966: LESS
56967: IFFALSE 56971
// exit ;
56969: GO 57274
// if pos = 1 then
56971: LD_VAR 0 2
56975: PUSH
56976: LD_INT 1
56978: EQUAL
56979: IFFALSE 57012
// result := Replace ( arr , pos [ 1 ] , value ) else
56981: LD_ADDR_VAR 0 4
56985: PUSH
56986: LD_VAR 0 1
56990: PPUSH
56991: LD_VAR 0 2
56995: PUSH
56996: LD_INT 1
56998: ARRAY
56999: PPUSH
57000: LD_VAR 0 3
57004: PPUSH
57005: CALL_OW 1
57009: ST_TO_ADDR
57010: GO 57274
// begin tmp := arr ;
57012: LD_ADDR_VAR 0 6
57016: PUSH
57017: LD_VAR 0 1
57021: ST_TO_ADDR
// s_arr := [ tmp ] ;
57022: LD_ADDR_VAR 0 7
57026: PUSH
57027: LD_VAR 0 6
57031: PUSH
57032: EMPTY
57033: LIST
57034: ST_TO_ADDR
// for i = 1 to pos - 1 do
57035: LD_ADDR_VAR 0 5
57039: PUSH
57040: DOUBLE
57041: LD_INT 1
57043: DEC
57044: ST_TO_ADDR
57045: LD_VAR 0 2
57049: PUSH
57050: LD_INT 1
57052: MINUS
57053: PUSH
57054: FOR_TO
57055: IFFALSE 57100
// begin tmp := tmp [ pos [ i ] ] ;
57057: LD_ADDR_VAR 0 6
57061: PUSH
57062: LD_VAR 0 6
57066: PUSH
57067: LD_VAR 0 2
57071: PUSH
57072: LD_VAR 0 5
57076: ARRAY
57077: ARRAY
57078: ST_TO_ADDR
// s_arr := s_arr ^ [ tmp ] ;
57079: LD_ADDR_VAR 0 7
57083: PUSH
57084: LD_VAR 0 7
57088: PUSH
57089: LD_VAR 0 6
57093: PUSH
57094: EMPTY
57095: LIST
57096: ADD
57097: ST_TO_ADDR
// end ;
57098: GO 57054
57100: POP
57101: POP
// tmp := Replace ( tmp , pos [ pos ] , value ) ;
57102: LD_ADDR_VAR 0 6
57106: PUSH
57107: LD_VAR 0 6
57111: PPUSH
57112: LD_VAR 0 2
57116: PUSH
57117: LD_VAR 0 2
57121: ARRAY
57122: PPUSH
57123: LD_VAR 0 3
57127: PPUSH
57128: CALL_OW 1
57132: ST_TO_ADDR
// s_arr := Replace ( s_arr , s_arr , tmp ) ;
57133: LD_ADDR_VAR 0 7
57137: PUSH
57138: LD_VAR 0 7
57142: PPUSH
57143: LD_VAR 0 7
57147: PPUSH
57148: LD_VAR 0 6
57152: PPUSH
57153: CALL_OW 1
57157: ST_TO_ADDR
// for i = s_arr downto 2 do
57158: LD_ADDR_VAR 0 5
57162: PUSH
57163: DOUBLE
57164: LD_VAR 0 7
57168: INC
57169: ST_TO_ADDR
57170: LD_INT 2
57172: PUSH
57173: FOR_DOWNTO
57174: IFFALSE 57258
// begin tmp := Replace ( s_arr [ i - 1 ] , pos [ i - 1 ] , s_arr [ i ] ) ;
57176: LD_ADDR_VAR 0 6
57180: PUSH
57181: LD_VAR 0 7
57185: PUSH
57186: LD_VAR 0 5
57190: PUSH
57191: LD_INT 1
57193: MINUS
57194: ARRAY
57195: PPUSH
57196: LD_VAR 0 2
57200: PUSH
57201: LD_VAR 0 5
57205: PUSH
57206: LD_INT 1
57208: MINUS
57209: ARRAY
57210: PPUSH
57211: LD_VAR 0 7
57215: PUSH
57216: LD_VAR 0 5
57220: ARRAY
57221: PPUSH
57222: CALL_OW 1
57226: ST_TO_ADDR
// s_arr := Replace ( s_arr , i - 1 , tmp ) ;
57227: LD_ADDR_VAR 0 7
57231: PUSH
57232: LD_VAR 0 7
57236: PPUSH
57237: LD_VAR 0 5
57241: PUSH
57242: LD_INT 1
57244: MINUS
57245: PPUSH
57246: LD_VAR 0 6
57250: PPUSH
57251: CALL_OW 1
57255: ST_TO_ADDR
// end ;
57256: GO 57173
57258: POP
57259: POP
// result := s_arr [ 1 ] ;
57260: LD_ADDR_VAR 0 4
57264: PUSH
57265: LD_VAR 0 7
57269: PUSH
57270: LD_INT 1
57272: ARRAY
57273: ST_TO_ADDR
// end ; end ;
57274: LD_VAR 0 4
57278: RET
// export function ReplaceWith ( list , pos1 , pos2 ) ; var i ; begin
57279: LD_INT 0
57281: PPUSH
57282: PPUSH
// if not list then
57283: LD_VAR 0 1
57287: NOT
57288: IFFALSE 57292
// exit ;
57290: GO 57383
// i := list [ pos1 ] ;
57292: LD_ADDR_VAR 0 5
57296: PUSH
57297: LD_VAR 0 1
57301: PUSH
57302: LD_VAR 0 2
57306: ARRAY
57307: ST_TO_ADDR
// if not i then
57308: LD_VAR 0 5
57312: NOT
57313: IFFALSE 57317
// exit ;
57315: GO 57383
// list := Replace ( list , pos1 , list [ pos2 ] ) ;
57317: LD_ADDR_VAR 0 1
57321: PUSH
57322: LD_VAR 0 1
57326: PPUSH
57327: LD_VAR 0 2
57331: PPUSH
57332: LD_VAR 0 1
57336: PUSH
57337: LD_VAR 0 3
57341: ARRAY
57342: PPUSH
57343: CALL_OW 1
57347: ST_TO_ADDR
// list := Replace ( list , pos2 , i ) ;
57348: LD_ADDR_VAR 0 1
57352: PUSH
57353: LD_VAR 0 1
57357: PPUSH
57358: LD_VAR 0 3
57362: PPUSH
57363: LD_VAR 0 5
57367: PPUSH
57368: CALL_OW 1
57372: ST_TO_ADDR
// result := list ;
57373: LD_ADDR_VAR 0 4
57377: PUSH
57378: LD_VAR 0 1
57382: ST_TO_ADDR
// end ;
57383: LD_VAR 0 4
57387: RET
// export function SortByDistanceUnit ( unit , list , asc , mode ) ; begin
57388: LD_INT 0
57390: PPUSH
// result := SortByDistanceXY ( GetX ( unit ) , GetY ( unit ) , list , asc , mode ) ;
57391: LD_ADDR_VAR 0 5
57395: PUSH
57396: LD_VAR 0 1
57400: PPUSH
57401: CALL_OW 250
57405: PPUSH
57406: LD_VAR 0 1
57410: PPUSH
57411: CALL_OW 251
57415: PPUSH
57416: LD_VAR 0 2
57420: PPUSH
57421: LD_VAR 0 3
57425: PPUSH
57426: LD_VAR 0 4
57430: PPUSH
57431: CALL 57441 0 5
57435: ST_TO_ADDR
// end ;
57436: LD_VAR 0 5
57440: RET
// export function SortByDistanceXY ( x , y , list , asc , mode ) ; var i , j , tmp ; begin
57441: LD_INT 0
57443: PPUSH
57444: PPUSH
57445: PPUSH
57446: PPUSH
// if not list then
57447: LD_VAR 0 3
57451: NOT
57452: IFFALSE 57456
// exit ;
57454: GO 57844
// result := [ ] ;
57456: LD_ADDR_VAR 0 6
57460: PUSH
57461: EMPTY
57462: ST_TO_ADDR
// for i in list do
57463: LD_ADDR_VAR 0 7
57467: PUSH
57468: LD_VAR 0 3
57472: PUSH
57473: FOR_IN
57474: IFFALSE 57676
// begin tmp := GetDistUnitXY ( i , x , y ) ;
57476: LD_ADDR_VAR 0 9
57480: PUSH
57481: LD_VAR 0 7
57485: PPUSH
57486: LD_VAR 0 1
57490: PPUSH
57491: LD_VAR 0 2
57495: PPUSH
57496: CALL_OW 297
57500: ST_TO_ADDR
// if not result then
57501: LD_VAR 0 6
57505: NOT
57506: IFFALSE 57532
// result := [ [ i , tmp ] ] else
57508: LD_ADDR_VAR 0 6
57512: PUSH
57513: LD_VAR 0 7
57517: PUSH
57518: LD_VAR 0 9
57522: PUSH
57523: EMPTY
57524: LIST
57525: LIST
57526: PUSH
57527: EMPTY
57528: LIST
57529: ST_TO_ADDR
57530: GO 57674
// begin if result [ result ] [ 2 ] < tmp then
57532: LD_VAR 0 6
57536: PUSH
57537: LD_VAR 0 6
57541: ARRAY
57542: PUSH
57543: LD_INT 2
57545: ARRAY
57546: PUSH
57547: LD_VAR 0 9
57551: LESS
57552: IFFALSE 57594
// result := Insert ( result , result + 1 , [ i , tmp ] ) else
57554: LD_ADDR_VAR 0 6
57558: PUSH
57559: LD_VAR 0 6
57563: PPUSH
57564: LD_VAR 0 6
57568: PUSH
57569: LD_INT 1
57571: PLUS
57572: PPUSH
57573: LD_VAR 0 7
57577: PUSH
57578: LD_VAR 0 9
57582: PUSH
57583: EMPTY
57584: LIST
57585: LIST
57586: PPUSH
57587: CALL_OW 2
57591: ST_TO_ADDR
57592: GO 57674
// for j = 1 to result do
57594: LD_ADDR_VAR 0 8
57598: PUSH
57599: DOUBLE
57600: LD_INT 1
57602: DEC
57603: ST_TO_ADDR
57604: LD_VAR 0 6
57608: PUSH
57609: FOR_TO
57610: IFFALSE 57672
// begin if tmp < result [ j ] [ 2 ] then
57612: LD_VAR 0 9
57616: PUSH
57617: LD_VAR 0 6
57621: PUSH
57622: LD_VAR 0 8
57626: ARRAY
57627: PUSH
57628: LD_INT 2
57630: ARRAY
57631: LESS
57632: IFFALSE 57670
// begin result := Insert ( result , j , [ i , tmp ] ) ;
57634: LD_ADDR_VAR 0 6
57638: PUSH
57639: LD_VAR 0 6
57643: PPUSH
57644: LD_VAR 0 8
57648: PPUSH
57649: LD_VAR 0 7
57653: PUSH
57654: LD_VAR 0 9
57658: PUSH
57659: EMPTY
57660: LIST
57661: LIST
57662: PPUSH
57663: CALL_OW 2
57667: ST_TO_ADDR
// break ;
57668: GO 57672
// end ; end ;
57670: GO 57609
57672: POP
57673: POP
// end ; end ;
57674: GO 57473
57676: POP
57677: POP
// if result and not asc then
57678: LD_VAR 0 6
57682: PUSH
57683: LD_VAR 0 4
57687: NOT
57688: AND
57689: IFFALSE 57764
// begin tmp := result ;
57691: LD_ADDR_VAR 0 9
57695: PUSH
57696: LD_VAR 0 6
57700: ST_TO_ADDR
// for i = tmp downto 1 do
57701: LD_ADDR_VAR 0 7
57705: PUSH
57706: DOUBLE
57707: LD_VAR 0 9
57711: INC
57712: ST_TO_ADDR
57713: LD_INT 1
57715: PUSH
57716: FOR_DOWNTO
57717: IFFALSE 57762
// result := Replace ( result , tmp - i + 1 , tmp [ i ] ) ;
57719: LD_ADDR_VAR 0 6
57723: PUSH
57724: LD_VAR 0 6
57728: PPUSH
57729: LD_VAR 0 9
57733: PUSH
57734: LD_VAR 0 7
57738: MINUS
57739: PUSH
57740: LD_INT 1
57742: PLUS
57743: PPUSH
57744: LD_VAR 0 9
57748: PUSH
57749: LD_VAR 0 7
57753: ARRAY
57754: PPUSH
57755: CALL_OW 1
57759: ST_TO_ADDR
57760: GO 57716
57762: POP
57763: POP
// end ; tmp := [ ] ;
57764: LD_ADDR_VAR 0 9
57768: PUSH
57769: EMPTY
57770: ST_TO_ADDR
// if mode then
57771: LD_VAR 0 5
57775: IFFALSE 57844
// begin for i = 1 to result do
57777: LD_ADDR_VAR 0 7
57781: PUSH
57782: DOUBLE
57783: LD_INT 1
57785: DEC
57786: ST_TO_ADDR
57787: LD_VAR 0 6
57791: PUSH
57792: FOR_TO
57793: IFFALSE 57832
// tmp := Replace ( tmp , i , result [ i ] [ 1 ] ) ;
57795: LD_ADDR_VAR 0 9
57799: PUSH
57800: LD_VAR 0 9
57804: PPUSH
57805: LD_VAR 0 7
57809: PPUSH
57810: LD_VAR 0 6
57814: PUSH
57815: LD_VAR 0 7
57819: ARRAY
57820: PUSH
57821: LD_INT 1
57823: ARRAY
57824: PPUSH
57825: CALL_OW 1
57829: ST_TO_ADDR
57830: GO 57792
57832: POP
57833: POP
// result := tmp ;
57834: LD_ADDR_VAR 0 6
57838: PUSH
57839: LD_VAR 0 9
57843: ST_TO_ADDR
// end ; end ;
57844: LD_VAR 0 6
57848: RET
// export function DangerAtRangeXY ( side , x , y , range ) ; var i , j , tmp , points , bpoints ; begin
57849: LD_INT 0
57851: PPUSH
57852: PPUSH
57853: PPUSH
57854: PPUSH
57855: PPUSH
57856: PPUSH
// result := [ 0 , 0 , 0 , [ ] ] ;
57857: LD_ADDR_VAR 0 5
57861: PUSH
57862: LD_INT 0
57864: PUSH
57865: LD_INT 0
57867: PUSH
57868: LD_INT 0
57870: PUSH
57871: EMPTY
57872: PUSH
57873: EMPTY
57874: LIST
57875: LIST
57876: LIST
57877: LIST
57878: ST_TO_ADDR
// if not x or not y then
57879: LD_VAR 0 2
57883: NOT
57884: PUSH
57885: LD_VAR 0 3
57889: NOT
57890: OR
57891: IFFALSE 57895
// exit ;
57893: GO 59541
// if not range then
57895: LD_VAR 0 4
57899: NOT
57900: IFFALSE 57910
// range := 10 ;
57902: LD_ADDR_VAR 0 4
57906: PUSH
57907: LD_INT 10
57909: ST_TO_ADDR
// tmp := FilterAllUnits ( [ [ f_enemy , side ] , [ f_distxy , x , y , range ] , [ f_not , [ f_type , unit_building ] ] ] ) ;
57910: LD_ADDR_VAR 0 8
57914: PUSH
57915: LD_INT 81
57917: PUSH
57918: LD_VAR 0 1
57922: PUSH
57923: EMPTY
57924: LIST
57925: LIST
57926: PUSH
57927: LD_INT 92
57929: PUSH
57930: LD_VAR 0 2
57934: PUSH
57935: LD_VAR 0 3
57939: PUSH
57940: LD_VAR 0 4
57944: PUSH
57945: EMPTY
57946: LIST
57947: LIST
57948: LIST
57949: LIST
57950: PUSH
57951: LD_INT 3
57953: PUSH
57954: LD_INT 21
57956: PUSH
57957: LD_INT 3
57959: PUSH
57960: EMPTY
57961: LIST
57962: LIST
57963: PUSH
57964: EMPTY
57965: LIST
57966: LIST
57967: PUSH
57968: EMPTY
57969: LIST
57970: LIST
57971: LIST
57972: PPUSH
57973: CALL_OW 69
57977: ST_TO_ADDR
// if not tmp then
57978: LD_VAR 0 8
57982: NOT
57983: IFFALSE 57987
// exit ;
57985: GO 59541
// for i in tmp do
57987: LD_ADDR_VAR 0 6
57991: PUSH
57992: LD_VAR 0 8
57996: PUSH
57997: FOR_IN
57998: IFFALSE 59516
// begin points := [ 0 , 0 , 0 ] ;
58000: LD_ADDR_VAR 0 9
58004: PUSH
58005: LD_INT 0
58007: PUSH
58008: LD_INT 0
58010: PUSH
58011: LD_INT 0
58013: PUSH
58014: EMPTY
58015: LIST
58016: LIST
58017: LIST
58018: ST_TO_ADDR
// bpoints := 1 ;
58019: LD_ADDR_VAR 0 10
58023: PUSH
58024: LD_INT 1
58026: ST_TO_ADDR
// case GetType ( i ) of unit_human :
58027: LD_VAR 0 6
58031: PPUSH
58032: CALL_OW 247
58036: PUSH
58037: LD_INT 1
58039: DOUBLE
58040: EQUAL
58041: IFTRUE 58045
58043: GO 58623
58045: POP
// begin if GetClass ( i ) = 1 then
58046: LD_VAR 0 6
58050: PPUSH
58051: CALL_OW 257
58055: PUSH
58056: LD_INT 1
58058: EQUAL
58059: IFFALSE 58080
// points := [ 10 , 5 , 3 ] ;
58061: LD_ADDR_VAR 0 9
58065: PUSH
58066: LD_INT 10
58068: PUSH
58069: LD_INT 5
58071: PUSH
58072: LD_INT 3
58074: PUSH
58075: EMPTY
58076: LIST
58077: LIST
58078: LIST
58079: ST_TO_ADDR
// if GetClass ( i ) in [ 2 , 3 , 4 ] then
58080: LD_VAR 0 6
58084: PPUSH
58085: CALL_OW 257
58089: PUSH
58090: LD_INT 2
58092: PUSH
58093: LD_INT 3
58095: PUSH
58096: LD_INT 4
58098: PUSH
58099: EMPTY
58100: LIST
58101: LIST
58102: LIST
58103: IN
58104: IFFALSE 58125
// points := [ 3 , 2 , 1 ] ;
58106: LD_ADDR_VAR 0 9
58110: PUSH
58111: LD_INT 3
58113: PUSH
58114: LD_INT 2
58116: PUSH
58117: LD_INT 1
58119: PUSH
58120: EMPTY
58121: LIST
58122: LIST
58123: LIST
58124: ST_TO_ADDR
// if GetClass ( i ) = 5 then
58125: LD_VAR 0 6
58129: PPUSH
58130: CALL_OW 257
58134: PUSH
58135: LD_INT 5
58137: EQUAL
58138: IFFALSE 58159
// points := [ 130 , 5 , 2 ] ;
58140: LD_ADDR_VAR 0 9
58144: PUSH
58145: LD_INT 130
58147: PUSH
58148: LD_INT 5
58150: PUSH
58151: LD_INT 2
58153: PUSH
58154: EMPTY
58155: LIST
58156: LIST
58157: LIST
58158: ST_TO_ADDR
// if GetClass ( i ) = 8 then
58159: LD_VAR 0 6
58163: PPUSH
58164: CALL_OW 257
58168: PUSH
58169: LD_INT 8
58171: EQUAL
58172: IFFALSE 58193
// points := [ 35 , 35 , 30 ] ;
58174: LD_ADDR_VAR 0 9
58178: PUSH
58179: LD_INT 35
58181: PUSH
58182: LD_INT 35
58184: PUSH
58185: LD_INT 30
58187: PUSH
58188: EMPTY
58189: LIST
58190: LIST
58191: LIST
58192: ST_TO_ADDR
// if GetClass ( i ) = 9 then
58193: LD_VAR 0 6
58197: PPUSH
58198: CALL_OW 257
58202: PUSH
58203: LD_INT 9
58205: EQUAL
58206: IFFALSE 58227
// points := [ 20 , 55 , 40 ] ;
58208: LD_ADDR_VAR 0 9
58212: PUSH
58213: LD_INT 20
58215: PUSH
58216: LD_INT 55
58218: PUSH
58219: LD_INT 40
58221: PUSH
58222: EMPTY
58223: LIST
58224: LIST
58225: LIST
58226: ST_TO_ADDR
// if GetClass ( i ) in [ 12 , 16 ] then
58227: LD_VAR 0 6
58231: PPUSH
58232: CALL_OW 257
58236: PUSH
58237: LD_INT 12
58239: PUSH
58240: LD_INT 16
58242: PUSH
58243: EMPTY
58244: LIST
58245: LIST
58246: IN
58247: IFFALSE 58268
// points := [ 5 , 3 , 2 ] ;
58249: LD_ADDR_VAR 0 9
58253: PUSH
58254: LD_INT 5
58256: PUSH
58257: LD_INT 3
58259: PUSH
58260: LD_INT 2
58262: PUSH
58263: EMPTY
58264: LIST
58265: LIST
58266: LIST
58267: ST_TO_ADDR
// if GetClass ( i ) = 17 then
58268: LD_VAR 0 6
58272: PPUSH
58273: CALL_OW 257
58277: PUSH
58278: LD_INT 17
58280: EQUAL
58281: IFFALSE 58302
// points := [ 100 , 50 , 75 ] ;
58283: LD_ADDR_VAR 0 9
58287: PUSH
58288: LD_INT 100
58290: PUSH
58291: LD_INT 50
58293: PUSH
58294: LD_INT 75
58296: PUSH
58297: EMPTY
58298: LIST
58299: LIST
58300: LIST
58301: ST_TO_ADDR
// if GetClass ( i ) = 15 then
58302: LD_VAR 0 6
58306: PPUSH
58307: CALL_OW 257
58311: PUSH
58312: LD_INT 15
58314: EQUAL
58315: IFFALSE 58336
// points := [ 10 , 5 , 3 ] ;
58317: LD_ADDR_VAR 0 9
58321: PUSH
58322: LD_INT 10
58324: PUSH
58325: LD_INT 5
58327: PUSH
58328: LD_INT 3
58330: PUSH
58331: EMPTY
58332: LIST
58333: LIST
58334: LIST
58335: ST_TO_ADDR
// if GetClass ( i ) = 14 then
58336: LD_VAR 0 6
58340: PPUSH
58341: CALL_OW 257
58345: PUSH
58346: LD_INT 14
58348: EQUAL
58349: IFFALSE 58370
// points := [ 10 , 0 , 0 ] ;
58351: LD_ADDR_VAR 0 9
58355: PUSH
58356: LD_INT 10
58358: PUSH
58359: LD_INT 0
58361: PUSH
58362: LD_INT 0
58364: PUSH
58365: EMPTY
58366: LIST
58367: LIST
58368: LIST
58369: ST_TO_ADDR
// if GetClass ( i ) = 11 then
58370: LD_VAR 0 6
58374: PPUSH
58375: CALL_OW 257
58379: PUSH
58380: LD_INT 11
58382: EQUAL
58383: IFFALSE 58404
// points := [ 30 , 10 , 5 ] ;
58385: LD_ADDR_VAR 0 9
58389: PUSH
58390: LD_INT 30
58392: PUSH
58393: LD_INT 10
58395: PUSH
58396: LD_INT 5
58398: PUSH
58399: EMPTY
58400: LIST
58401: LIST
58402: LIST
58403: ST_TO_ADDR
// if GetTech ( side , tech_stimdrugs ) = state_researched then
58404: LD_VAR 0 1
58408: PPUSH
58409: LD_INT 5
58411: PPUSH
58412: CALL_OW 321
58416: PUSH
58417: LD_INT 2
58419: EQUAL
58420: IFFALSE 58437
// bpoints := bpoints * 1.8 ;
58422: LD_ADDR_VAR 0 10
58426: PUSH
58427: LD_VAR 0 10
58431: PUSH
58432: LD_REAL  1.80000000000000E+0000
58435: MUL
58436: ST_TO_ADDR
// if GetClass ( i ) in [ 1 , 2 , 3 , 4 ] and GetTech ( side , tech_weap1 ) = state_researched then
58437: LD_VAR 0 6
58441: PPUSH
58442: CALL_OW 257
58446: PUSH
58447: LD_INT 1
58449: PUSH
58450: LD_INT 2
58452: PUSH
58453: LD_INT 3
58455: PUSH
58456: LD_INT 4
58458: PUSH
58459: EMPTY
58460: LIST
58461: LIST
58462: LIST
58463: LIST
58464: IN
58465: PUSH
58466: LD_VAR 0 1
58470: PPUSH
58471: LD_INT 51
58473: PPUSH
58474: CALL_OW 321
58478: PUSH
58479: LD_INT 2
58481: EQUAL
58482: AND
58483: IFFALSE 58500
// bpoints := bpoints * 1.2 ;
58485: LD_ADDR_VAR 0 10
58489: PUSH
58490: LD_VAR 0 10
58494: PUSH
58495: LD_REAL  1.20000000000000E+0000
58498: MUL
58499: ST_TO_ADDR
// if GetClass ( i ) in [ 5 , 7 , 9 ] and GetTech ( side , tech_weap2 ) = state_researched then
58500: LD_VAR 0 6
58504: PPUSH
58505: CALL_OW 257
58509: PUSH
58510: LD_INT 5
58512: PUSH
58513: LD_INT 7
58515: PUSH
58516: LD_INT 9
58518: PUSH
58519: EMPTY
58520: LIST
58521: LIST
58522: LIST
58523: IN
58524: PUSH
58525: LD_VAR 0 1
58529: PPUSH
58530: LD_INT 52
58532: PPUSH
58533: CALL_OW 321
58537: PUSH
58538: LD_INT 2
58540: EQUAL
58541: AND
58542: IFFALSE 58559
// bpoints := bpoints * 1.5 ;
58544: LD_ADDR_VAR 0 10
58548: PUSH
58549: LD_VAR 0 10
58553: PUSH
58554: LD_REAL  1.50000000000000E+0000
58557: MUL
58558: ST_TO_ADDR
// if GetTech ( side , tech_bio1 ) = state_researched then
58559: LD_VAR 0 1
58563: PPUSH
58564: LD_INT 66
58566: PPUSH
58567: CALL_OW 321
58571: PUSH
58572: LD_INT 2
58574: EQUAL
58575: IFFALSE 58592
// bpoints := bpoints * 1.1 ;
58577: LD_ADDR_VAR 0 10
58581: PUSH
58582: LD_VAR 0 10
58586: PUSH
58587: LD_REAL  1.10000000000000E+0000
58590: MUL
58591: ST_TO_ADDR
// bpoints := bpoints * ( GetSkill ( i , 1 ) * 1.15 ) ;
58592: LD_ADDR_VAR 0 10
58596: PUSH
58597: LD_VAR 0 10
58601: PUSH
58602: LD_VAR 0 6
58606: PPUSH
58607: LD_INT 1
58609: PPUSH
58610: CALL_OW 259
58614: PUSH
58615: LD_REAL  1.15000000000000E+0000
58618: MUL
58619: MUL
58620: ST_TO_ADDR
// end ; unit_vehicle :
58621: GO 59445
58623: LD_INT 2
58625: DOUBLE
58626: EQUAL
58627: IFTRUE 58631
58629: GO 59433
58631: POP
// begin if GetWeapon ( i ) in [ us_machine_gun , ru_heavy_machine_gun , ar_double_machine_gun ] then
58632: LD_VAR 0 6
58636: PPUSH
58637: CALL_OW 264
58641: PUSH
58642: LD_INT 2
58644: PUSH
58645: LD_INT 42
58647: PUSH
58648: LD_INT 24
58650: PUSH
58651: EMPTY
58652: LIST
58653: LIST
58654: LIST
58655: IN
58656: IFFALSE 58677
// points := [ 25 , 5 , 3 ] ;
58658: LD_ADDR_VAR 0 9
58662: PUSH
58663: LD_INT 25
58665: PUSH
58666: LD_INT 5
58668: PUSH
58669: LD_INT 3
58671: PUSH
58672: EMPTY
58673: LIST
58674: LIST
58675: LIST
58676: ST_TO_ADDR
// if GetWeapon ( i ) in [ us_gatling_gun , ru_gatling_gun , ar_gatling_gun ] then
58677: LD_VAR 0 6
58681: PPUSH
58682: CALL_OW 264
58686: PUSH
58687: LD_INT 4
58689: PUSH
58690: LD_INT 43
58692: PUSH
58693: LD_INT 25
58695: PUSH
58696: EMPTY
58697: LIST
58698: LIST
58699: LIST
58700: IN
58701: IFFALSE 58722
// points := [ 40 , 15 , 5 ] ;
58703: LD_ADDR_VAR 0 9
58707: PUSH
58708: LD_INT 40
58710: PUSH
58711: LD_INT 15
58713: PUSH
58714: LD_INT 5
58716: PUSH
58717: EMPTY
58718: LIST
58719: LIST
58720: LIST
58721: ST_TO_ADDR
// if GetWeapon ( i ) in [ us_light_gun , ar_light_gun ] then
58722: LD_VAR 0 6
58726: PPUSH
58727: CALL_OW 264
58731: PUSH
58732: LD_INT 3
58734: PUSH
58735: LD_INT 23
58737: PUSH
58738: EMPTY
58739: LIST
58740: LIST
58741: IN
58742: IFFALSE 58763
// points := [ 7 , 25 , 8 ] ;
58744: LD_ADDR_VAR 0 9
58748: PUSH
58749: LD_INT 7
58751: PUSH
58752: LD_INT 25
58754: PUSH
58755: LD_INT 8
58757: PUSH
58758: EMPTY
58759: LIST
58760: LIST
58761: LIST
58762: ST_TO_ADDR
// if GetWeapon ( i ) in [ us_double_gun , ar_gun , ru_gun ] then
58763: LD_VAR 0 6
58767: PPUSH
58768: CALL_OW 264
58772: PUSH
58773: LD_INT 5
58775: PUSH
58776: LD_INT 27
58778: PUSH
58779: LD_INT 44
58781: PUSH
58782: EMPTY
58783: LIST
58784: LIST
58785: LIST
58786: IN
58787: IFFALSE 58808
// points := [ 14 , 50 , 16 ] ;
58789: LD_ADDR_VAR 0 9
58793: PUSH
58794: LD_INT 14
58796: PUSH
58797: LD_INT 50
58799: PUSH
58800: LD_INT 16
58802: PUSH
58803: EMPTY
58804: LIST
58805: LIST
58806: LIST
58807: ST_TO_ADDR
// if GetWeapon ( i ) in [ us_heavy_gun , ru_heavy_gun ] then
58808: LD_VAR 0 6
58812: PPUSH
58813: CALL_OW 264
58817: PUSH
58818: LD_INT 6
58820: PUSH
58821: LD_INT 46
58823: PUSH
58824: EMPTY
58825: LIST
58826: LIST
58827: IN
58828: IFFALSE 58849
// points := [ 32 , 120 , 70 ] ;
58830: LD_ADDR_VAR 0 9
58834: PUSH
58835: LD_INT 32
58837: PUSH
58838: LD_INT 120
58840: PUSH
58841: LD_INT 70
58843: PUSH
58844: EMPTY
58845: LIST
58846: LIST
58847: LIST
58848: ST_TO_ADDR
// if GetWeapon ( i ) in [ us_rocket_launcher , ar_rocket_launcher , ru_rocket_launcher ] then
58849: LD_VAR 0 6
58853: PPUSH
58854: CALL_OW 264
58858: PUSH
58859: LD_INT 7
58861: PUSH
58862: LD_INT 28
58864: PUSH
58865: LD_INT 45
58867: PUSH
58868: EMPTY
58869: LIST
58870: LIST
58871: LIST
58872: IN
58873: IFFALSE 58894
// points := [ 35 , 20 , 45 ] ;
58875: LD_ADDR_VAR 0 9
58879: PUSH
58880: LD_INT 35
58882: PUSH
58883: LD_INT 20
58885: PUSH
58886: LD_INT 45
58888: PUSH
58889: EMPTY
58890: LIST
58891: LIST
58892: LIST
58893: ST_TO_ADDR
// if GetWeapon ( i ) in [ ru_rocket ] then
58894: LD_VAR 0 6
58898: PPUSH
58899: CALL_OW 264
58903: PUSH
58904: LD_INT 47
58906: PUSH
58907: EMPTY
58908: LIST
58909: IN
58910: IFFALSE 58931
// points := [ 67 , 45 , 75 ] ;
58912: LD_ADDR_VAR 0 9
58916: PUSH
58917: LD_INT 67
58919: PUSH
58920: LD_INT 45
58922: PUSH
58923: LD_INT 75
58925: PUSH
58926: EMPTY
58927: LIST
58928: LIST
58929: LIST
58930: ST_TO_ADDR
// if GetWeapon ( i ) in [ ar_flame_thrower ] then
58931: LD_VAR 0 6
58935: PPUSH
58936: CALL_OW 264
58940: PUSH
58941: LD_INT 26
58943: PUSH
58944: EMPTY
58945: LIST
58946: IN
58947: IFFALSE 58968
// points := [ 120 , 30 , 80 ] ;
58949: LD_ADDR_VAR 0 9
58953: PUSH
58954: LD_INT 120
58956: PUSH
58957: LD_INT 30
58959: PUSH
58960: LD_INT 80
58962: PUSH
58963: EMPTY
58964: LIST
58965: LIST
58966: LIST
58967: ST_TO_ADDR
// if GetWeapon ( i ) in [ ar_multimissile_ballista ] then
58968: LD_VAR 0 6
58972: PPUSH
58973: CALL_OW 264
58977: PUSH
58978: LD_INT 22
58980: PUSH
58981: EMPTY
58982: LIST
58983: IN
58984: IFFALSE 59005
// points := [ 40 , 1 , 1 ] ;
58986: LD_ADDR_VAR 0 9
58990: PUSH
58991: LD_INT 40
58993: PUSH
58994: LD_INT 1
58996: PUSH
58997: LD_INT 1
58999: PUSH
59000: EMPTY
59001: LIST
59002: LIST
59003: LIST
59004: ST_TO_ADDR
// if GetWeapon ( i ) in [ ar_selfpropelled_bomb ] then
59005: LD_VAR 0 6
59009: PPUSH
59010: CALL_OW 264
59014: PUSH
59015: LD_INT 29
59017: PUSH
59018: EMPTY
59019: LIST
59020: IN
59021: IFFALSE 59042
// points := [ 70 , 200 , 400 ] ;
59023: LD_ADDR_VAR 0 9
59027: PUSH
59028: LD_INT 70
59030: PUSH
59031: LD_INT 200
59033: PUSH
59034: LD_INT 400
59036: PUSH
59037: EMPTY
59038: LIST
59039: LIST
59040: LIST
59041: ST_TO_ADDR
// if GetWeapon ( i ) in [ us_bulldozer , ru_bulldozer ] then
59042: LD_VAR 0 6
59046: PPUSH
59047: CALL_OW 264
59051: PUSH
59052: LD_INT 14
59054: PUSH
59055: LD_INT 53
59057: PUSH
59058: EMPTY
59059: LIST
59060: LIST
59061: IN
59062: IFFALSE 59083
// points := [ 40 , 10 , 20 ] ;
59064: LD_ADDR_VAR 0 9
59068: PUSH
59069: LD_INT 40
59071: PUSH
59072: LD_INT 10
59074: PUSH
59075: LD_INT 20
59077: PUSH
59078: EMPTY
59079: LIST
59080: LIST
59081: LIST
59082: ST_TO_ADDR
// if GetWeapon ( i ) in [ us_laser ] then
59083: LD_VAR 0 6
59087: PPUSH
59088: CALL_OW 264
59092: PUSH
59093: LD_INT 9
59095: PUSH
59096: EMPTY
59097: LIST
59098: IN
59099: IFFALSE 59120
// points := [ 5 , 70 , 20 ] ;
59101: LD_ADDR_VAR 0 9
59105: PUSH
59106: LD_INT 5
59108: PUSH
59109: LD_INT 70
59111: PUSH
59112: LD_INT 20
59114: PUSH
59115: EMPTY
59116: LIST
59117: LIST
59118: LIST
59119: ST_TO_ADDR
// if GetWeapon ( i ) in [ us_double_laser ] then
59120: LD_VAR 0 6
59124: PPUSH
59125: CALL_OW 264
59129: PUSH
59130: LD_INT 10
59132: PUSH
59133: EMPTY
59134: LIST
59135: IN
59136: IFFALSE 59157
// points := [ 35 , 110 , 70 ] ;
59138: LD_ADDR_VAR 0 9
59142: PUSH
59143: LD_INT 35
59145: PUSH
59146: LD_INT 110
59148: PUSH
59149: LD_INT 70
59151: PUSH
59152: EMPTY
59153: LIST
59154: LIST
59155: LIST
59156: ST_TO_ADDR
// if GetChassis ( i ) = 25 then
59157: LD_VAR 0 6
59161: PPUSH
59162: CALL_OW 265
59166: PUSH
59167: LD_INT 25
59169: EQUAL
59170: IFFALSE 59191
// points := [ 80 , 65 , 100 ] ;
59172: LD_ADDR_VAR 0 9
59176: PUSH
59177: LD_INT 80
59179: PUSH
59180: LD_INT 65
59182: PUSH
59183: LD_INT 100
59185: PUSH
59186: EMPTY
59187: LIST
59188: LIST
59189: LIST
59190: ST_TO_ADDR
// if GetControl ( i ) = control_manual then
59191: LD_VAR 0 6
59195: PPUSH
59196: CALL_OW 263
59200: PUSH
59201: LD_INT 1
59203: EQUAL
59204: IFFALSE 59239
// bpoints := bpoints * ( GetSkill ( IsDrivenBy ( i ) , 3 ) * 4 ) ;
59206: LD_ADDR_VAR 0 10
59210: PUSH
59211: LD_VAR 0 10
59215: PUSH
59216: LD_VAR 0 6
59220: PPUSH
59221: CALL_OW 311
59225: PPUSH
59226: LD_INT 3
59228: PPUSH
59229: CALL_OW 259
59233: PUSH
59234: LD_INT 4
59236: MUL
59237: MUL
59238: ST_TO_ADDR
// if GetControl ( i ) = control_remote then
59239: LD_VAR 0 6
59243: PPUSH
59244: CALL_OW 263
59248: PUSH
59249: LD_INT 2
59251: EQUAL
59252: IFFALSE 59303
// begin j := IsControledBy ( i ) ;
59254: LD_ADDR_VAR 0 7
59258: PUSH
59259: LD_VAR 0 6
59263: PPUSH
59264: CALL_OW 312
59268: ST_TO_ADDR
// if j then
59269: LD_VAR 0 7
59273: IFFALSE 59303
// bpoints := bpoints * ( GetSkill ( j , 3 ) * 3 ) ;
59275: LD_ADDR_VAR 0 10
59279: PUSH
59280: LD_VAR 0 10
59284: PUSH
59285: LD_VAR 0 7
59289: PPUSH
59290: LD_INT 3
59292: PPUSH
59293: CALL_OW 259
59297: PUSH
59298: LD_INT 3
59300: MUL
59301: MUL
59302: ST_TO_ADDR
// end ; if GetWeapon ( i ) in [ us_double_gun , us_heavy_gun , ru_heavy_gun , ru_gun , ru_rocket , ru_rocket_launcher , ar_rocket_launcher , us_rocket_launcher , ar_gun , ar_selfpropelled_bomb ] and GetTech ( side , tech_weap2 ) = state_researched then
59303: LD_VAR 0 6
59307: PPUSH
59308: CALL_OW 264
59312: PUSH
59313: LD_INT 5
59315: PUSH
59316: LD_INT 6
59318: PUSH
59319: LD_INT 46
59321: PUSH
59322: LD_INT 44
59324: PUSH
59325: LD_INT 47
59327: PUSH
59328: LD_INT 45
59330: PUSH
59331: LD_INT 28
59333: PUSH
59334: LD_INT 7
59336: PUSH
59337: LD_INT 27
59339: PUSH
59340: LD_INT 29
59342: PUSH
59343: EMPTY
59344: LIST
59345: LIST
59346: LIST
59347: LIST
59348: LIST
59349: LIST
59350: LIST
59351: LIST
59352: LIST
59353: LIST
59354: IN
59355: PUSH
59356: LD_VAR 0 1
59360: PPUSH
59361: LD_INT 52
59363: PPUSH
59364: CALL_OW 321
59368: PUSH
59369: LD_INT 2
59371: EQUAL
59372: AND
59373: IFFALSE 59390
// bpoints := bpoints * 1.2 ;
59375: LD_ADDR_VAR 0 10
59379: PUSH
59380: LD_VAR 0 10
59384: PUSH
59385: LD_REAL  1.20000000000000E+0000
59388: MUL
59389: ST_TO_ADDR
// if GetWeapon ( i ) in [ us_heavy_gun , ru_heavy_gun , ru_rocket ] then
59390: LD_VAR 0 6
59394: PPUSH
59395: CALL_OW 264
59399: PUSH
59400: LD_INT 6
59402: PUSH
59403: LD_INT 46
59405: PUSH
59406: LD_INT 47
59408: PUSH
59409: EMPTY
59410: LIST
59411: LIST
59412: LIST
59413: IN
59414: IFFALSE 59431
// bpoints := bpoints * 1.2 ;
59416: LD_ADDR_VAR 0 10
59420: PUSH
59421: LD_VAR 0 10
59425: PUSH
59426: LD_REAL  1.20000000000000E+0000
59429: MUL
59430: ST_TO_ADDR
// end ; unit_building :
59431: GO 59445
59433: LD_INT 3
59435: DOUBLE
59436: EQUAL
59437: IFTRUE 59441
59439: GO 59444
59441: POP
// ; end ;
59442: GO 59445
59444: POP
// for j = 1 to 3 do
59445: LD_ADDR_VAR 0 7
59449: PUSH
59450: DOUBLE
59451: LD_INT 1
59453: DEC
59454: ST_TO_ADDR
59455: LD_INT 3
59457: PUSH
59458: FOR_TO
59459: IFFALSE 59512
// result := Replace ( result , j , result [ j ] + ( points [ j ] * bpoints ) ) ;
59461: LD_ADDR_VAR 0 5
59465: PUSH
59466: LD_VAR 0 5
59470: PPUSH
59471: LD_VAR 0 7
59475: PPUSH
59476: LD_VAR 0 5
59480: PUSH
59481: LD_VAR 0 7
59485: ARRAY
59486: PUSH
59487: LD_VAR 0 9
59491: PUSH
59492: LD_VAR 0 7
59496: ARRAY
59497: PUSH
59498: LD_VAR 0 10
59502: MUL
59503: PLUS
59504: PPUSH
59505: CALL_OW 1
59509: ST_TO_ADDR
59510: GO 59458
59512: POP
59513: POP
// end ;
59514: GO 57997
59516: POP
59517: POP
// result := Replace ( result , 4 , tmp ) ;
59518: LD_ADDR_VAR 0 5
59522: PUSH
59523: LD_VAR 0 5
59527: PPUSH
59528: LD_INT 4
59530: PPUSH
59531: LD_VAR 0 8
59535: PPUSH
59536: CALL_OW 1
59540: ST_TO_ADDR
// end ;
59541: LD_VAR 0 5
59545: RET
// export function DangerAtRange ( unit , range ) ; begin
59546: LD_INT 0
59548: PPUSH
// result := DangerAtRangeXY ( GetSide ( unit ) , GetX ( unit ) , GetY ( unit ) , range ) ;
59549: LD_ADDR_VAR 0 3
59553: PUSH
59554: LD_VAR 0 1
59558: PPUSH
59559: CALL_OW 255
59563: PPUSH
59564: LD_VAR 0 1
59568: PPUSH
59569: CALL_OW 250
59573: PPUSH
59574: LD_VAR 0 1
59578: PPUSH
59579: CALL_OW 251
59583: PPUSH
59584: LD_VAR 0 2
59588: PPUSH
59589: CALL 57849 0 4
59593: ST_TO_ADDR
// end ;
59594: LD_VAR 0 3
59598: RET
// export function DangerInArea ( side , area ) ; begin
59599: LD_INT 0
59601: PPUSH
// result := FilterUnitsInArea ( area , [ f_enemy , side ] ) ;
59602: LD_ADDR_VAR 0 3
59606: PUSH
59607: LD_VAR 0 2
59611: PPUSH
59612: LD_INT 81
59614: PUSH
59615: LD_VAR 0 1
59619: PUSH
59620: EMPTY
59621: LIST
59622: LIST
59623: PPUSH
59624: CALL_OW 70
59628: ST_TO_ADDR
// end ;
59629: LD_VAR 0 3
59633: RET
// export function IsExtension ( b ) ; begin
59634: LD_INT 0
59636: PPUSH
// result := b in [ b_ext_stitch , b_ext_radar , b_ext_radio , b_ext_gun , b_ext_computer , b_ext_siberium , b_ext_noncombat , b_ext_track , b_ext_laser , b_ext_rocket ] ;
59637: LD_ADDR_VAR 0 2
59641: PUSH
59642: LD_VAR 0 1
59646: PUSH
59647: LD_INT 23
59649: PUSH
59650: LD_INT 20
59652: PUSH
59653: LD_INT 22
59655: PUSH
59656: LD_INT 17
59658: PUSH
59659: LD_INT 24
59661: PUSH
59662: LD_INT 21
59664: PUSH
59665: LD_INT 19
59667: PUSH
59668: LD_INT 16
59670: PUSH
59671: LD_INT 25
59673: PUSH
59674: LD_INT 18
59676: PUSH
59677: EMPTY
59678: LIST
59679: LIST
59680: LIST
59681: LIST
59682: LIST
59683: LIST
59684: LIST
59685: LIST
59686: LIST
59687: LIST
59688: IN
59689: ST_TO_ADDR
// end ;
59690: LD_VAR 0 2
59694: RET
// export function GetBaseBuildings ( base , area ) ; var tmp , i ; begin
59695: LD_INT 0
59697: PPUSH
59698: PPUSH
59699: PPUSH
// result := [ ] ;
59700: LD_ADDR_VAR 0 3
59704: PUSH
59705: EMPTY
59706: ST_TO_ADDR
// tmp := FilterUnitsInArea ( area , [ f_type , unit_building ] ) ;
59707: LD_ADDR_VAR 0 4
59711: PUSH
59712: LD_VAR 0 2
59716: PPUSH
59717: LD_INT 21
59719: PUSH
59720: LD_INT 3
59722: PUSH
59723: EMPTY
59724: LIST
59725: LIST
59726: PPUSH
59727: CALL_OW 70
59731: ST_TO_ADDR
// if not tmp then
59732: LD_VAR 0 4
59736: NOT
59737: IFFALSE 59741
// exit ;
59739: GO 59799
// for i in tmp do
59741: LD_ADDR_VAR 0 5
59745: PUSH
59746: LD_VAR 0 4
59750: PUSH
59751: FOR_IN
59752: IFFALSE 59787
// if GetBase ( i ) <> base then
59754: LD_VAR 0 5
59758: PPUSH
59759: CALL_OW 274
59763: PUSH
59764: LD_VAR 0 1
59768: NONEQUAL
59769: IFFALSE 59785
// ComLinkToBase ( base , i ) ;
59771: LD_VAR 0 1
59775: PPUSH
59776: LD_VAR 0 5
59780: PPUSH
59781: CALL_OW 169
59785: GO 59751
59787: POP
59788: POP
// result := tmp ;
59789: LD_ADDR_VAR 0 3
59793: PUSH
59794: LD_VAR 0 4
59798: ST_TO_ADDR
// end ;
59799: LD_VAR 0 3
59803: RET
// export function ComComplete ( unit , b ) ; var i ; begin
59804: LD_INT 0
59806: PPUSH
59807: PPUSH
// if BuildingStatus ( b ) = bs_build then
59808: LD_VAR 0 2
59812: PPUSH
59813: CALL_OW 461
59817: PUSH
59818: LD_INT 1
59820: EQUAL
59821: IFFALSE 59881
// SetTaskList ( unit , [ [ h , GetX ( b ) , GetY ( b ) , b , 0 , 0 , 0 ] ] ) ;
59823: LD_VAR 0 1
59827: PPUSH
59828: LD_STRING h
59830: PUSH
59831: LD_VAR 0 2
59835: PPUSH
59836: CALL_OW 250
59840: PUSH
59841: LD_VAR 0 2
59845: PPUSH
59846: CALL_OW 251
59850: PUSH
59851: LD_VAR 0 2
59855: PUSH
59856: LD_INT 0
59858: PUSH
59859: LD_INT 0
59861: PUSH
59862: LD_INT 0
59864: PUSH
59865: EMPTY
59866: LIST
59867: LIST
59868: LIST
59869: LIST
59870: LIST
59871: LIST
59872: LIST
59873: PUSH
59874: EMPTY
59875: LIST
59876: PPUSH
59877: CALL_OW 446
// end ;
59881: LD_VAR 0 3
59885: RET
// export function Connect ( vehicle ) ; var i , t , mech , tmp , j ; begin
59886: LD_INT 0
59888: PPUSH
59889: PPUSH
59890: PPUSH
59891: PPUSH
59892: PPUSH
59893: PPUSH
// if not vehicle or not GetControl ( vehicle ) = control_remote then
59894: LD_VAR 0 1
59898: NOT
59899: PUSH
59900: LD_VAR 0 1
59904: PPUSH
59905: CALL_OW 263
59909: PUSH
59910: LD_INT 2
59912: EQUAL
59913: NOT
59914: OR
59915: IFFALSE 59919
// exit ;
59917: GO 60235
// tmp := FilterAllUnits ( [ [ f_side , GetSide ( vehicle ) ] , [ f_or , [ f_btype , b_control_tower ] , [ f_weapon , ar_control_tower ] ] ] ) ;
59919: LD_ADDR_VAR 0 6
59923: PUSH
59924: LD_INT 22
59926: PUSH
59927: LD_VAR 0 1
59931: PPUSH
59932: CALL_OW 255
59936: PUSH
59937: EMPTY
59938: LIST
59939: LIST
59940: PUSH
59941: LD_INT 2
59943: PUSH
59944: LD_INT 30
59946: PUSH
59947: LD_INT 36
59949: PUSH
59950: EMPTY
59951: LIST
59952: LIST
59953: PUSH
59954: LD_INT 34
59956: PUSH
59957: LD_INT 31
59959: PUSH
59960: EMPTY
59961: LIST
59962: LIST
59963: PUSH
59964: EMPTY
59965: LIST
59966: LIST
59967: LIST
59968: PUSH
59969: EMPTY
59970: LIST
59971: LIST
59972: PPUSH
59973: CALL_OW 69
59977: ST_TO_ADDR
// if not tmp then
59978: LD_VAR 0 6
59982: NOT
59983: IFFALSE 59987
// exit ;
59985: GO 60235
// result := [ ] ;
59987: LD_ADDR_VAR 0 2
59991: PUSH
59992: EMPTY
59993: ST_TO_ADDR
// for i in tmp do
59994: LD_ADDR_VAR 0 3
59998: PUSH
59999: LD_VAR 0 6
60003: PUSH
60004: FOR_IN
60005: IFFALSE 60076
// begin t := UnitsInside ( i ) ;
60007: LD_ADDR_VAR 0 4
60011: PUSH
60012: LD_VAR 0 3
60016: PPUSH
60017: CALL_OW 313
60021: ST_TO_ADDR
// if t then
60022: LD_VAR 0 4
60026: IFFALSE 60074
// for j in t do
60028: LD_ADDR_VAR 0 7
60032: PUSH
60033: LD_VAR 0 4
60037: PUSH
60038: FOR_IN
60039: IFFALSE 60072
// result := Insert ( result , result + 1 , j ) ;
60041: LD_ADDR_VAR 0 2
60045: PUSH
60046: LD_VAR 0 2
60050: PPUSH
60051: LD_VAR 0 2
60055: PUSH
60056: LD_INT 1
60058: PLUS
60059: PPUSH
60060: LD_VAR 0 7
60064: PPUSH
60065: CALL_OW 2
60069: ST_TO_ADDR
60070: GO 60038
60072: POP
60073: POP
// end ;
60074: GO 60004
60076: POP
60077: POP
// if not result then
60078: LD_VAR 0 2
60082: NOT
60083: IFFALSE 60087
// exit ;
60085: GO 60235
// mech := result [ 1 ] ;
60087: LD_ADDR_VAR 0 5
60091: PUSH
60092: LD_VAR 0 2
60096: PUSH
60097: LD_INT 1
60099: ARRAY
60100: ST_TO_ADDR
// if result > 1 then
60101: LD_VAR 0 2
60105: PUSH
60106: LD_INT 1
60108: GREATER
60109: IFFALSE 60221
// for i = 2 to result do
60111: LD_ADDR_VAR 0 3
60115: PUSH
60116: DOUBLE
60117: LD_INT 2
60119: DEC
60120: ST_TO_ADDR
60121: LD_VAR 0 2
60125: PUSH
60126: FOR_TO
60127: IFFALSE 60219
// begin t := GetSkill ( result [ i ] , 3 ) - UnitsLinked ( result [ i ] ) ;
60129: LD_ADDR_VAR 0 4
60133: PUSH
60134: LD_VAR 0 2
60138: PUSH
60139: LD_VAR 0 3
60143: ARRAY
60144: PPUSH
60145: LD_INT 3
60147: PPUSH
60148: CALL_OW 259
60152: PUSH
60153: LD_VAR 0 2
60157: PUSH
60158: LD_VAR 0 3
60162: ARRAY
60163: PPUSH
60164: CALL_OW 432
60168: MINUS
60169: ST_TO_ADDR
// if t >= ( GetSkill ( mech , 3 ) - UnitsLinked ( mech ) ) then
60170: LD_VAR 0 4
60174: PUSH
60175: LD_VAR 0 5
60179: PPUSH
60180: LD_INT 3
60182: PPUSH
60183: CALL_OW 259
60187: PUSH
60188: LD_VAR 0 5
60192: PPUSH
60193: CALL_OW 432
60197: MINUS
60198: GREATEREQUAL
60199: IFFALSE 60217
// mech := result [ i ] ;
60201: LD_ADDR_VAR 0 5
60205: PUSH
60206: LD_VAR 0 2
60210: PUSH
60211: LD_VAR 0 3
60215: ARRAY
60216: ST_TO_ADDR
// end ;
60217: GO 60126
60219: POP
60220: POP
// ComLinkTo ( vehicle , mech ) ;
60221: LD_VAR 0 1
60225: PPUSH
60226: LD_VAR 0 5
60230: PPUSH
60231: CALL_OW 135
// end ;
60235: LD_VAR 0 2
60239: RET
// export function PrepareBase ( base_dep , area , name , skill , sources , personel ) ; var i , j , d , b , f , x , un , base , side , nation , buildings , tmp ; begin
60240: LD_INT 0
60242: PPUSH
60243: PPUSH
60244: PPUSH
60245: PPUSH
60246: PPUSH
60247: PPUSH
60248: PPUSH
60249: PPUSH
60250: PPUSH
60251: PPUSH
60252: PPUSH
60253: PPUSH
60254: PPUSH
// result := [ ] ;
60255: LD_ADDR_VAR 0 7
60259: PUSH
60260: EMPTY
60261: ST_TO_ADDR
// if not GetBType ( base_dep ) in [ b_depot , b_warehouse ] then
60262: LD_VAR 0 1
60266: PPUSH
60267: CALL_OW 266
60271: PUSH
60272: LD_INT 0
60274: PUSH
60275: LD_INT 1
60277: PUSH
60278: EMPTY
60279: LIST
60280: LIST
60281: IN
60282: NOT
60283: IFFALSE 60287
// exit ;
60285: GO 61918
// if name then
60287: LD_VAR 0 3
60291: IFFALSE 60307
// SetBName ( base_dep , name ) ;
60293: LD_VAR 0 1
60297: PPUSH
60298: LD_VAR 0 3
60302: PPUSH
60303: CALL_OW 500
// base := GetBase ( base_dep ) ;
60307: LD_ADDR_VAR 0 15
60311: PUSH
60312: LD_VAR 0 1
60316: PPUSH
60317: CALL_OW 274
60321: ST_TO_ADDR
// side := GetSide ( base_dep ) ;
60322: LD_ADDR_VAR 0 16
60326: PUSH
60327: LD_VAR 0 1
60331: PPUSH
60332: CALL_OW 255
60336: ST_TO_ADDR
// nation := GetNation ( base_dep ) ;
60337: LD_ADDR_VAR 0 17
60341: PUSH
60342: LD_VAR 0 1
60346: PPUSH
60347: CALL_OW 248
60351: ST_TO_ADDR
// if sources then
60352: LD_VAR 0 5
60356: IFFALSE 60403
// for i = 1 to 3 do
60358: LD_ADDR_VAR 0 8
60362: PUSH
60363: DOUBLE
60364: LD_INT 1
60366: DEC
60367: ST_TO_ADDR
60368: LD_INT 3
60370: PUSH
60371: FOR_TO
60372: IFFALSE 60401
// AddResourceType ( base , i , sources [ i ] ) ;
60374: LD_VAR 0 15
60378: PPUSH
60379: LD_VAR 0 8
60383: PPUSH
60384: LD_VAR 0 5
60388: PUSH
60389: LD_VAR 0 8
60393: ARRAY
60394: PPUSH
60395: CALL_OW 276
60399: GO 60371
60401: POP
60402: POP
// buildings := GetBaseBuildings ( base , area ) ;
60403: LD_ADDR_VAR 0 18
60407: PUSH
60408: LD_VAR 0 15
60412: PPUSH
60413: LD_VAR 0 2
60417: PPUSH
60418: CALL 59695 0 2
60422: ST_TO_ADDR
// InitHc ;
60423: CALL_OW 19
// InitUc ;
60427: CALL_OW 18
// uc_side := side ;
60431: LD_ADDR_OWVAR 20
60435: PUSH
60436: LD_VAR 0 16
60440: ST_TO_ADDR
// uc_nation := nation ;
60441: LD_ADDR_OWVAR 21
60445: PUSH
60446: LD_VAR 0 17
60450: ST_TO_ADDR
// if buildings then
60451: LD_VAR 0 18
60455: IFFALSE 61777
// begin tmp := UnitFilter ( buildings , [ f_or , [ f_btype , b_oil_mine ] , [ f_btype , b_siberite_mine ] ] ) ;
60457: LD_ADDR_VAR 0 19
60461: PUSH
60462: LD_VAR 0 18
60466: PPUSH
60467: LD_INT 2
60469: PUSH
60470: LD_INT 30
60472: PUSH
60473: LD_INT 29
60475: PUSH
60476: EMPTY
60477: LIST
60478: LIST
60479: PUSH
60480: LD_INT 30
60482: PUSH
60483: LD_INT 30
60485: PUSH
60486: EMPTY
60487: LIST
60488: LIST
60489: PUSH
60490: EMPTY
60491: LIST
60492: LIST
60493: LIST
60494: PPUSH
60495: CALL_OW 72
60499: ST_TO_ADDR
// if tmp then
60500: LD_VAR 0 19
60504: IFFALSE 60552
// for i in tmp do
60506: LD_ADDR_VAR 0 8
60510: PUSH
60511: LD_VAR 0 19
60515: PUSH
60516: FOR_IN
60517: IFFALSE 60550
// SetResourceVisibility ( GetX ( i ) , GetY ( i ) , side ) ;
60519: LD_VAR 0 8
60523: PPUSH
60524: CALL_OW 250
60528: PPUSH
60529: LD_VAR 0 8
60533: PPUSH
60534: CALL_OW 251
60538: PPUSH
60539: LD_VAR 0 16
60543: PPUSH
60544: CALL_OW 441
60548: GO 60516
60550: POP
60551: POP
// if UnitFilter ( buildings , [ f_or , [ f_btype , b_bunker ] , [ f_btype , b_turret ] ] ) then
60552: LD_VAR 0 18
60556: PPUSH
60557: LD_INT 2
60559: PUSH
60560: LD_INT 30
60562: PUSH
60563: LD_INT 32
60565: PUSH
60566: EMPTY
60567: LIST
60568: LIST
60569: PUSH
60570: LD_INT 30
60572: PUSH
60573: LD_INT 33
60575: PUSH
60576: EMPTY
60577: LIST
60578: LIST
60579: PUSH
60580: EMPTY
60581: LIST
60582: LIST
60583: LIST
60584: PPUSH
60585: CALL_OW 72
60589: IFFALSE 60677
// begin for i in UnitFilter ( buildings , [ f_or , [ f_btype , b_bunker ] , [ f_btype , b_turret ] ] ) do
60591: LD_ADDR_VAR 0 8
60595: PUSH
60596: LD_VAR 0 18
60600: PPUSH
60601: LD_INT 2
60603: PUSH
60604: LD_INT 30
60606: PUSH
60607: LD_INT 32
60609: PUSH
60610: EMPTY
60611: LIST
60612: LIST
60613: PUSH
60614: LD_INT 30
60616: PUSH
60617: LD_INT 33
60619: PUSH
60620: EMPTY
60621: LIST
60622: LIST
60623: PUSH
60624: EMPTY
60625: LIST
60626: LIST
60627: LIST
60628: PPUSH
60629: CALL_OW 72
60633: PUSH
60634: FOR_IN
60635: IFFALSE 60675
// begin if not GetBWeapon ( i ) then
60637: LD_VAR 0 8
60641: PPUSH
60642: CALL_OW 269
60646: NOT
60647: IFFALSE 60673
// PlaceWeaponTurret ( i , GetTurretWeapon ( i , area ) ) ;
60649: LD_VAR 0 8
60653: PPUSH
60654: LD_VAR 0 8
60658: PPUSH
60659: LD_VAR 0 2
60663: PPUSH
60664: CALL 61923 0 2
60668: PPUSH
60669: CALL_OW 431
// end ;
60673: GO 60634
60675: POP
60676: POP
// end ; for i = 1 to personel do
60677: LD_ADDR_VAR 0 8
60681: PUSH
60682: DOUBLE
60683: LD_INT 1
60685: DEC
60686: ST_TO_ADDR
60687: LD_VAR 0 6
60691: PUSH
60692: FOR_TO
60693: IFFALSE 61757
// begin if i > 4 then
60695: LD_VAR 0 8
60699: PUSH
60700: LD_INT 4
60702: GREATER
60703: IFFALSE 60707
// break ;
60705: GO 61757
// case i of 1 :
60707: LD_VAR 0 8
60711: PUSH
60712: LD_INT 1
60714: DOUBLE
60715: EQUAL
60716: IFTRUE 60720
60718: GO 60800
60720: POP
// f := UnitFilter ( buildings , [ [ f_side , side ] , [ f_empty ] , [ f_or , [ f_btype , b_bunker ] , [ f_btype , b_armoury ] , [ f_btype , b_barracks ] ] ] ) ; 2 :
60721: LD_ADDR_VAR 0 12
60725: PUSH
60726: LD_VAR 0 18
60730: PPUSH
60731: LD_INT 22
60733: PUSH
60734: LD_VAR 0 16
60738: PUSH
60739: EMPTY
60740: LIST
60741: LIST
60742: PUSH
60743: LD_INT 58
60745: PUSH
60746: EMPTY
60747: LIST
60748: PUSH
60749: LD_INT 2
60751: PUSH
60752: LD_INT 30
60754: PUSH
60755: LD_INT 32
60757: PUSH
60758: EMPTY
60759: LIST
60760: LIST
60761: PUSH
60762: LD_INT 30
60764: PUSH
60765: LD_INT 4
60767: PUSH
60768: EMPTY
60769: LIST
60770: LIST
60771: PUSH
60772: LD_INT 30
60774: PUSH
60775: LD_INT 5
60777: PUSH
60778: EMPTY
60779: LIST
60780: LIST
60781: PUSH
60782: EMPTY
60783: LIST
60784: LIST
60785: LIST
60786: LIST
60787: PUSH
60788: EMPTY
60789: LIST
60790: LIST
60791: LIST
60792: PPUSH
60793: CALL_OW 72
60797: ST_TO_ADDR
60798: GO 61022
60800: LD_INT 2
60802: DOUBLE
60803: EQUAL
60804: IFTRUE 60808
60806: GO 60870
60808: POP
// f := UnitFilter ( buildings , [ [ f_side , side ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ] ) ; 3 :
60809: LD_ADDR_VAR 0 12
60813: PUSH
60814: LD_VAR 0 18
60818: PPUSH
60819: LD_INT 22
60821: PUSH
60822: LD_VAR 0 16
60826: PUSH
60827: EMPTY
60828: LIST
60829: LIST
60830: PUSH
60831: LD_INT 2
60833: PUSH
60834: LD_INT 30
60836: PUSH
60837: LD_INT 0
60839: PUSH
60840: EMPTY
60841: LIST
60842: LIST
60843: PUSH
60844: LD_INT 30
60846: PUSH
60847: LD_INT 1
60849: PUSH
60850: EMPTY
60851: LIST
60852: LIST
60853: PUSH
60854: EMPTY
60855: LIST
60856: LIST
60857: LIST
60858: PUSH
60859: EMPTY
60860: LIST
60861: LIST
60862: PPUSH
60863: CALL_OW 72
60867: ST_TO_ADDR
60868: GO 61022
60870: LD_INT 3
60872: DOUBLE
60873: EQUAL
60874: IFTRUE 60878
60876: GO 60940
60878: POP
// f := UnitFilter ( buildings , [ [ f_side , side ] , [ f_or , [ f_btype , b_workshop ] , [ f_btype , b_factory ] ] ] ) ; 4 :
60879: LD_ADDR_VAR 0 12
60883: PUSH
60884: LD_VAR 0 18
60888: PPUSH
60889: LD_INT 22
60891: PUSH
60892: LD_VAR 0 16
60896: PUSH
60897: EMPTY
60898: LIST
60899: LIST
60900: PUSH
60901: LD_INT 2
60903: PUSH
60904: LD_INT 30
60906: PUSH
60907: LD_INT 2
60909: PUSH
60910: EMPTY
60911: LIST
60912: LIST
60913: PUSH
60914: LD_INT 30
60916: PUSH
60917: LD_INT 3
60919: PUSH
60920: EMPTY
60921: LIST
60922: LIST
60923: PUSH
60924: EMPTY
60925: LIST
60926: LIST
60927: LIST
60928: PUSH
60929: EMPTY
60930: LIST
60931: LIST
60932: PPUSH
60933: CALL_OW 72
60937: ST_TO_ADDR
60938: GO 61022
60940: LD_INT 4
60942: DOUBLE
60943: EQUAL
60944: IFTRUE 60948
60946: GO 61021
60948: POP
// f := UnitFilter ( buildings , [ [ f_side , side ] , [ f_or , [ f_btype , b_lab ] , [ f_btype , b_lab_half ] , [ f_btype , b_lab_full ] ] ] ) ; end ;
60949: LD_ADDR_VAR 0 12
60953: PUSH
60954: LD_VAR 0 18
60958: PPUSH
60959: LD_INT 22
60961: PUSH
60962: LD_VAR 0 16
60966: PUSH
60967: EMPTY
60968: LIST
60969: LIST
60970: PUSH
60971: LD_INT 2
60973: PUSH
60974: LD_INT 30
60976: PUSH
60977: LD_INT 6
60979: PUSH
60980: EMPTY
60981: LIST
60982: LIST
60983: PUSH
60984: LD_INT 30
60986: PUSH
60987: LD_INT 7
60989: PUSH
60990: EMPTY
60991: LIST
60992: LIST
60993: PUSH
60994: LD_INT 30
60996: PUSH
60997: LD_INT 8
60999: PUSH
61000: EMPTY
61001: LIST
61002: LIST
61003: PUSH
61004: EMPTY
61005: LIST
61006: LIST
61007: LIST
61008: LIST
61009: PUSH
61010: EMPTY
61011: LIST
61012: LIST
61013: PPUSH
61014: CALL_OW 72
61018: ST_TO_ADDR
61019: GO 61022
61021: POP
// if i = 1 then
61022: LD_VAR 0 8
61026: PUSH
61027: LD_INT 1
61029: EQUAL
61030: IFFALSE 61141
// begin tmp := [ ] ;
61032: LD_ADDR_VAR 0 19
61036: PUSH
61037: EMPTY
61038: ST_TO_ADDR
// for j in f do
61039: LD_ADDR_VAR 0 9
61043: PUSH
61044: LD_VAR 0 12
61048: PUSH
61049: FOR_IN
61050: IFFALSE 61123
// if GetBType ( j ) = b_bunker then
61052: LD_VAR 0 9
61056: PPUSH
61057: CALL_OW 266
61061: PUSH
61062: LD_INT 32
61064: EQUAL
61065: IFFALSE 61092
// tmp := Insert ( tmp , 1 , j ) else
61067: LD_ADDR_VAR 0 19
61071: PUSH
61072: LD_VAR 0 19
61076: PPUSH
61077: LD_INT 1
61079: PPUSH
61080: LD_VAR 0 9
61084: PPUSH
61085: CALL_OW 2
61089: ST_TO_ADDR
61090: GO 61121
// tmp := Insert ( tmp , tmp + 1 , j ) ;
61092: LD_ADDR_VAR 0 19
61096: PUSH
61097: LD_VAR 0 19
61101: PPUSH
61102: LD_VAR 0 19
61106: PUSH
61107: LD_INT 1
61109: PLUS
61110: PPUSH
61111: LD_VAR 0 9
61115: PPUSH
61116: CALL_OW 2
61120: ST_TO_ADDR
61121: GO 61049
61123: POP
61124: POP
// if tmp then
61125: LD_VAR 0 19
61129: IFFALSE 61141
// f := tmp ;
61131: LD_ADDR_VAR 0 12
61135: PUSH
61136: LD_VAR 0 19
61140: ST_TO_ADDR
// end ; x := personel [ i ] ;
61141: LD_ADDR_VAR 0 13
61145: PUSH
61146: LD_VAR 0 6
61150: PUSH
61151: LD_VAR 0 8
61155: ARRAY
61156: ST_TO_ADDR
// if x = - 1 then
61157: LD_VAR 0 13
61161: PUSH
61162: LD_INT 1
61164: NEG
61165: EQUAL
61166: IFFALSE 61375
// begin for j in f do
61168: LD_ADDR_VAR 0 9
61172: PUSH
61173: LD_VAR 0 12
61177: PUSH
61178: FOR_IN
61179: IFFALSE 61371
// repeat InitHc ;
61181: CALL_OW 19
// if GetBType ( j ) = b_barracks then
61185: LD_VAR 0 9
61189: PPUSH
61190: CALL_OW 266
61194: PUSH
61195: LD_INT 5
61197: EQUAL
61198: IFFALSE 61268
// begin if UnitsInside ( j ) < 3 then
61200: LD_VAR 0 9
61204: PPUSH
61205: CALL_OW 313
61209: PUSH
61210: LD_INT 3
61212: LESS
61213: IFFALSE 61249
// PrepareHuman ( false , [ class_sniper , class_mortar , class_bazooker ] [ nation ] , skill ) else
61215: LD_INT 0
61217: PPUSH
61218: LD_INT 5
61220: PUSH
61221: LD_INT 8
61223: PUSH
61224: LD_INT 9
61226: PUSH
61227: EMPTY
61228: LIST
61229: LIST
61230: LIST
61231: PUSH
61232: LD_VAR 0 17
61236: ARRAY
61237: PPUSH
61238: LD_VAR 0 4
61242: PPUSH
61243: CALL_OW 380
61247: GO 61266
// PrepareHuman ( false , i , skill ) ;
61249: LD_INT 0
61251: PPUSH
61252: LD_VAR 0 8
61256: PPUSH
61257: LD_VAR 0 4
61261: PPUSH
61262: CALL_OW 380
// end else
61266: GO 61285
// PrepareHuman ( false , i , skill ) ;
61268: LD_INT 0
61270: PPUSH
61271: LD_VAR 0 8
61275: PPUSH
61276: LD_VAR 0 4
61280: PPUSH
61281: CALL_OW 380
// un := CreateHuman ;
61285: LD_ADDR_VAR 0 14
61289: PUSH
61290: CALL_OW 44
61294: ST_TO_ADDR
// result := Insert ( result , 1 , un ) ;
61295: LD_ADDR_VAR 0 7
61299: PUSH
61300: LD_VAR 0 7
61304: PPUSH
61305: LD_INT 1
61307: PPUSH
61308: LD_VAR 0 14
61312: PPUSH
61313: CALL_OW 2
61317: ST_TO_ADDR
// PlaceHumanInUnit ( un , j ) ;
61318: LD_VAR 0 14
61322: PPUSH
61323: LD_VAR 0 9
61327: PPUSH
61328: CALL_OW 52
// until UnitsInside ( j ) = 6 or GetBType ( j ) in [ b_bunker , b_breastwork ] ;
61332: LD_VAR 0 9
61336: PPUSH
61337: CALL_OW 313
61341: PUSH
61342: LD_INT 6
61344: EQUAL
61345: PUSH
61346: LD_VAR 0 9
61350: PPUSH
61351: CALL_OW 266
61355: PUSH
61356: LD_INT 32
61358: PUSH
61359: LD_INT 31
61361: PUSH
61362: EMPTY
61363: LIST
61364: LIST
61365: IN
61366: OR
61367: IFFALSE 61181
61369: GO 61178
61371: POP
61372: POP
// end else
61373: GO 61755
// for j = 1 to x do
61375: LD_ADDR_VAR 0 9
61379: PUSH
61380: DOUBLE
61381: LD_INT 1
61383: DEC
61384: ST_TO_ADDR
61385: LD_VAR 0 13
61389: PUSH
61390: FOR_TO
61391: IFFALSE 61753
// begin InitHc ;
61393: CALL_OW 19
// if not f then
61397: LD_VAR 0 12
61401: NOT
61402: IFFALSE 61491
// begin PrepareHuman ( false , i , skill ) ;
61404: LD_INT 0
61406: PPUSH
61407: LD_VAR 0 8
61411: PPUSH
61412: LD_VAR 0 4
61416: PPUSH
61417: CALL_OW 380
// un := CreateHuman ;
61421: LD_ADDR_VAR 0 14
61425: PUSH
61426: CALL_OW 44
61430: ST_TO_ADDR
// result := Insert ( result , 1 , un ) ;
61431: LD_ADDR_VAR 0 7
61435: PUSH
61436: LD_VAR 0 7
61440: PPUSH
61441: LD_INT 1
61443: PPUSH
61444: LD_VAR 0 14
61448: PPUSH
61449: CALL_OW 2
61453: ST_TO_ADDR
// PlaceUnitXYR ( un , GetX ( base_dep ) , GetY ( base_dep ) , 10 , false ) ;
61454: LD_VAR 0 14
61458: PPUSH
61459: LD_VAR 0 1
61463: PPUSH
61464: CALL_OW 250
61468: PPUSH
61469: LD_VAR 0 1
61473: PPUSH
61474: CALL_OW 251
61478: PPUSH
61479: LD_INT 10
61481: PPUSH
61482: LD_INT 0
61484: PPUSH
61485: CALL_OW 50
// continue ;
61489: GO 61390
// end ; if ( UnitsInside ( f [ 1 ] ) and GetBType ( f [ 1 ] ) in [ b_bunker , b_breastwork ] ) or ( UnitsInside ( f [ 1 ] ) = 6 ) then
61491: LD_VAR 0 12
61495: PUSH
61496: LD_INT 1
61498: ARRAY
61499: PPUSH
61500: CALL_OW 313
61504: PUSH
61505: LD_VAR 0 12
61509: PUSH
61510: LD_INT 1
61512: ARRAY
61513: PPUSH
61514: CALL_OW 266
61518: PUSH
61519: LD_INT 32
61521: PUSH
61522: LD_INT 31
61524: PUSH
61525: EMPTY
61526: LIST
61527: LIST
61528: IN
61529: AND
61530: PUSH
61531: LD_VAR 0 12
61535: PUSH
61536: LD_INT 1
61538: ARRAY
61539: PPUSH
61540: CALL_OW 313
61544: PUSH
61545: LD_INT 6
61547: EQUAL
61548: OR
61549: IFFALSE 61569
// f := Delete ( f , 1 ) ;
61551: LD_ADDR_VAR 0 12
61555: PUSH
61556: LD_VAR 0 12
61560: PPUSH
61561: LD_INT 1
61563: PPUSH
61564: CALL_OW 3
61568: ST_TO_ADDR
// if not f then
61569: LD_VAR 0 12
61573: NOT
61574: IFFALSE 61592
// begin x := x + 2 ;
61576: LD_ADDR_VAR 0 13
61580: PUSH
61581: LD_VAR 0 13
61585: PUSH
61586: LD_INT 2
61588: PLUS
61589: ST_TO_ADDR
// continue ;
61590: GO 61390
// end ; if GetBType ( f [ 1 ] ) = b_barracks then
61592: LD_VAR 0 12
61596: PUSH
61597: LD_INT 1
61599: ARRAY
61600: PPUSH
61601: CALL_OW 266
61605: PUSH
61606: LD_INT 5
61608: EQUAL
61609: IFFALSE 61683
// begin if UnitsInside ( f [ 1 ] ) < 3 then
61611: LD_VAR 0 12
61615: PUSH
61616: LD_INT 1
61618: ARRAY
61619: PPUSH
61620: CALL_OW 313
61624: PUSH
61625: LD_INT 3
61627: LESS
61628: IFFALSE 61664
// PrepareHuman ( false , [ class_sniper , class_mortar , class_bazooker ] [ nation ] , skill ) else
61630: LD_INT 0
61632: PPUSH
61633: LD_INT 5
61635: PUSH
61636: LD_INT 8
61638: PUSH
61639: LD_INT 9
61641: PUSH
61642: EMPTY
61643: LIST
61644: LIST
61645: LIST
61646: PUSH
61647: LD_VAR 0 17
61651: ARRAY
61652: PPUSH
61653: LD_VAR 0 4
61657: PPUSH
61658: CALL_OW 380
61662: GO 61681
// PrepareHuman ( false , i , skill ) ;
61664: LD_INT 0
61666: PPUSH
61667: LD_VAR 0 8
61671: PPUSH
61672: LD_VAR 0 4
61676: PPUSH
61677: CALL_OW 380
// end else
61681: GO 61700
// PrepareHuman ( false , i , skill ) ;
61683: LD_INT 0
61685: PPUSH
61686: LD_VAR 0 8
61690: PPUSH
61691: LD_VAR 0 4
61695: PPUSH
61696: CALL_OW 380
// un := CreateHuman ;
61700: LD_ADDR_VAR 0 14
61704: PUSH
61705: CALL_OW 44
61709: ST_TO_ADDR
// result := Insert ( result , 1 , un ) ;
61710: LD_ADDR_VAR 0 7
61714: PUSH
61715: LD_VAR 0 7
61719: PPUSH
61720: LD_INT 1
61722: PPUSH
61723: LD_VAR 0 14
61727: PPUSH
61728: CALL_OW 2
61732: ST_TO_ADDR
// PlaceHumanInUnit ( un , f [ 1 ] ) ;
61733: LD_VAR 0 14
61737: PPUSH
61738: LD_VAR 0 12
61742: PUSH
61743: LD_INT 1
61745: ARRAY
61746: PPUSH
61747: CALL_OW 52
// end ;
61751: GO 61390
61753: POP
61754: POP
// end ;
61755: GO 60692
61757: POP
61758: POP
// result := result ^ buildings ;
61759: LD_ADDR_VAR 0 7
61763: PUSH
61764: LD_VAR 0 7
61768: PUSH
61769: LD_VAR 0 18
61773: ADD
61774: ST_TO_ADDR
// end else
61775: GO 61918
// begin for i = 1 to personel do
61777: LD_ADDR_VAR 0 8
61781: PUSH
61782: DOUBLE
61783: LD_INT 1
61785: DEC
61786: ST_TO_ADDR
61787: LD_VAR 0 6
61791: PUSH
61792: FOR_TO
61793: IFFALSE 61916
// begin if i > 4 then
61795: LD_VAR 0 8
61799: PUSH
61800: LD_INT 4
61802: GREATER
61803: IFFALSE 61807
// break ;
61805: GO 61916
// x := personel [ i ] ;
61807: LD_ADDR_VAR 0 13
61811: PUSH
61812: LD_VAR 0 6
61816: PUSH
61817: LD_VAR 0 8
61821: ARRAY
61822: ST_TO_ADDR
// if x = - 1 then
61823: LD_VAR 0 13
61827: PUSH
61828: LD_INT 1
61830: NEG
61831: EQUAL
61832: IFFALSE 61836
// continue ;
61834: GO 61792
// PrepareHuman ( false , i , skill ) ;
61836: LD_INT 0
61838: PPUSH
61839: LD_VAR 0 8
61843: PPUSH
61844: LD_VAR 0 4
61848: PPUSH
61849: CALL_OW 380
// un := CreateHuman ;
61853: LD_ADDR_VAR 0 14
61857: PUSH
61858: CALL_OW 44
61862: ST_TO_ADDR
// PlaceUnitXYR ( un , GetX ( base_dep ) , GetY ( base_dep ) , 10 , false ) ;
61863: LD_VAR 0 14
61867: PPUSH
61868: LD_VAR 0 1
61872: PPUSH
61873: CALL_OW 250
61877: PPUSH
61878: LD_VAR 0 1
61882: PPUSH
61883: CALL_OW 251
61887: PPUSH
61888: LD_INT 10
61890: PPUSH
61891: LD_INT 0
61893: PPUSH
61894: CALL_OW 50
// result := result ^ un ;
61898: LD_ADDR_VAR 0 7
61902: PUSH
61903: LD_VAR 0 7
61907: PUSH
61908: LD_VAR 0 14
61912: ADD
61913: ST_TO_ADDR
// end ;
61914: GO 61792
61916: POP
61917: POP
// end ; end ;
61918: LD_VAR 0 7
61922: RET
// export function GetTurretWeapon ( tower , area ) ; var hex , list , factories , base , i , j , x , y , nat , h , tmp , height , side , fac_list , weapon ; begin
61923: LD_INT 0
61925: PPUSH
61926: PPUSH
61927: PPUSH
61928: PPUSH
61929: PPUSH
61930: PPUSH
61931: PPUSH
61932: PPUSH
61933: PPUSH
61934: PPUSH
61935: PPUSH
61936: PPUSH
61937: PPUSH
61938: PPUSH
61939: PPUSH
61940: PPUSH
// result := false ;
61941: LD_ADDR_VAR 0 3
61945: PUSH
61946: LD_INT 0
61948: ST_TO_ADDR
// if not tower or not GetBType ( tower ) in [ b_bunker , b_turret ] then
61949: LD_VAR 0 1
61953: NOT
61954: PUSH
61955: LD_VAR 0 1
61959: PPUSH
61960: CALL_OW 266
61964: PUSH
61965: LD_INT 32
61967: PUSH
61968: LD_INT 33
61970: PUSH
61971: EMPTY
61972: LIST
61973: LIST
61974: IN
61975: NOT
61976: OR
61977: IFFALSE 61981
// exit ;
61979: GO 63117
// nat := GetNation ( tower ) ;
61981: LD_ADDR_VAR 0 12
61985: PUSH
61986: LD_VAR 0 1
61990: PPUSH
61991: CALL_OW 248
61995: ST_TO_ADDR
// side := GetSide ( tower ) ;
61996: LD_ADDR_VAR 0 16
62000: PUSH
62001: LD_VAR 0 1
62005: PPUSH
62006: CALL_OW 255
62010: ST_TO_ADDR
// x := GetX ( tower ) ;
62011: LD_ADDR_VAR 0 10
62015: PUSH
62016: LD_VAR 0 1
62020: PPUSH
62021: CALL_OW 250
62025: ST_TO_ADDR
// y := GetY ( tower ) ;
62026: LD_ADDR_VAR 0 11
62030: PUSH
62031: LD_VAR 0 1
62035: PPUSH
62036: CALL_OW 251
62040: ST_TO_ADDR
// if not x or not y then
62041: LD_VAR 0 10
62045: NOT
62046: PUSH
62047: LD_VAR 0 11
62051: NOT
62052: OR
62053: IFFALSE 62057
// exit ;
62055: GO 63117
// weapon := 0 ;
62057: LD_ADDR_VAR 0 18
62061: PUSH
62062: LD_INT 0
62064: ST_TO_ADDR
// fac_list := [ ] ;
62065: LD_ADDR_VAR 0 17
62069: PUSH
62070: EMPTY
62071: ST_TO_ADDR
// factories := UnitFilter ( GetBaseBuildings ( GetBase ( tower ) , area ) , [ f_btype , b_factory ] ) ;
62072: LD_ADDR_VAR 0 6
62076: PUSH
62077: LD_VAR 0 1
62081: PPUSH
62082: CALL_OW 274
62086: PPUSH
62087: LD_VAR 0 2
62091: PPUSH
62092: CALL 59695 0 2
62096: PPUSH
62097: LD_INT 30
62099: PUSH
62100: LD_INT 3
62102: PUSH
62103: EMPTY
62104: LIST
62105: LIST
62106: PPUSH
62107: CALL_OW 72
62111: ST_TO_ADDR
// if not factories then
62112: LD_VAR 0 6
62116: NOT
62117: IFFALSE 62121
// exit ;
62119: GO 63117
// for i in factories do
62121: LD_ADDR_VAR 0 8
62125: PUSH
62126: LD_VAR 0 6
62130: PUSH
62131: FOR_IN
62132: IFFALSE 62157
// fac_list := fac_list union AvailableWeaponList ( i ) ;
62134: LD_ADDR_VAR 0 17
62138: PUSH
62139: LD_VAR 0 17
62143: PUSH
62144: LD_VAR 0 8
62148: PPUSH
62149: CALL_OW 478
62153: UNION
62154: ST_TO_ADDR
62155: GO 62131
62157: POP
62158: POP
// if not fac_list then
62159: LD_VAR 0 17
62163: NOT
62164: IFFALSE 62168
// exit ;
62166: GO 63117
// list := [ [ us_gatling_gun , us_double_gun , us_laser , us_double_laser , us_heavy_gun , us_rocket_launcher , us_radar ] , [ ar_gun , ar_rocket_launcher , ar_flame_thrower , ar_radar ] , [ ru_gatling_gun , ru_gun , ru_heavy_gun , ru_rocket_launcher , ru_rocket , ru_time_lapser ] ] [ nat ] ;
62168: LD_ADDR_VAR 0 5
62172: PUSH
62173: LD_INT 4
62175: PUSH
62176: LD_INT 5
62178: PUSH
62179: LD_INT 9
62181: PUSH
62182: LD_INT 10
62184: PUSH
62185: LD_INT 6
62187: PUSH
62188: LD_INT 7
62190: PUSH
62191: LD_INT 11
62193: PUSH
62194: EMPTY
62195: LIST
62196: LIST
62197: LIST
62198: LIST
62199: LIST
62200: LIST
62201: LIST
62202: PUSH
62203: LD_INT 27
62205: PUSH
62206: LD_INT 28
62208: PUSH
62209: LD_INT 26
62211: PUSH
62212: LD_INT 30
62214: PUSH
62215: EMPTY
62216: LIST
62217: LIST
62218: LIST
62219: LIST
62220: PUSH
62221: LD_INT 43
62223: PUSH
62224: LD_INT 44
62226: PUSH
62227: LD_INT 46
62229: PUSH
62230: LD_INT 45
62232: PUSH
62233: LD_INT 47
62235: PUSH
62236: LD_INT 49
62238: PUSH
62239: EMPTY
62240: LIST
62241: LIST
62242: LIST
62243: LIST
62244: LIST
62245: LIST
62246: PUSH
62247: EMPTY
62248: LIST
62249: LIST
62250: LIST
62251: PUSH
62252: LD_VAR 0 12
62256: ARRAY
62257: ST_TO_ADDR
// for i in list do
62258: LD_ADDR_VAR 0 8
62262: PUSH
62263: LD_VAR 0 5
62267: PUSH
62268: FOR_IN
62269: IFFALSE 62302
// if not i in fac_list then
62271: LD_VAR 0 8
62275: PUSH
62276: LD_VAR 0 17
62280: IN
62281: NOT
62282: IFFALSE 62300
// list := list diff i ;
62284: LD_ADDR_VAR 0 5
62288: PUSH
62289: LD_VAR 0 5
62293: PUSH
62294: LD_VAR 0 8
62298: DIFF
62299: ST_TO_ADDR
62300: GO 62268
62302: POP
62303: POP
// if not list then
62304: LD_VAR 0 5
62308: NOT
62309: IFFALSE 62313
// exit ;
62311: GO 63117
// if nat = nation_russian and ru_time_lapser in list and GetTech ( tech_lapser , side ) = state_researched then
62313: LD_VAR 0 12
62317: PUSH
62318: LD_INT 3
62320: EQUAL
62321: PUSH
62322: LD_INT 49
62324: PUSH
62325: LD_VAR 0 5
62329: IN
62330: AND
62331: PUSH
62332: LD_INT 31
62334: PPUSH
62335: LD_VAR 0 16
62339: PPUSH
62340: CALL_OW 321
62344: PUSH
62345: LD_INT 2
62347: EQUAL
62348: AND
62349: IFFALSE 62409
// begin if not FilterAllUnits ( [ [ f_side , side ] , [ f_bweapon , ru_time_lapser ] , [ f_dist , tower , 10 ] ] ) then
62351: LD_INT 22
62353: PUSH
62354: LD_VAR 0 16
62358: PUSH
62359: EMPTY
62360: LIST
62361: LIST
62362: PUSH
62363: LD_INT 35
62365: PUSH
62366: LD_INT 49
62368: PUSH
62369: EMPTY
62370: LIST
62371: LIST
62372: PUSH
62373: LD_INT 91
62375: PUSH
62376: LD_VAR 0 1
62380: PUSH
62381: LD_INT 10
62383: PUSH
62384: EMPTY
62385: LIST
62386: LIST
62387: LIST
62388: PUSH
62389: EMPTY
62390: LIST
62391: LIST
62392: LIST
62393: PPUSH
62394: CALL_OW 69
62398: NOT
62399: IFFALSE 62409
// weapon := ru_time_lapser ;
62401: LD_ADDR_VAR 0 18
62405: PUSH
62406: LD_INT 49
62408: ST_TO_ADDR
// end ; if nat in [ 1 , 2 ] and ( us_radar in list or ar_radar in list ) and GetTech ( tech_radar , side ) = state_researched then
62409: LD_VAR 0 12
62413: PUSH
62414: LD_INT 1
62416: PUSH
62417: LD_INT 2
62419: PUSH
62420: EMPTY
62421: LIST
62422: LIST
62423: IN
62424: PUSH
62425: LD_INT 11
62427: PUSH
62428: LD_VAR 0 5
62432: IN
62433: PUSH
62434: LD_INT 30
62436: PUSH
62437: LD_VAR 0 5
62441: IN
62442: OR
62443: AND
62444: PUSH
62445: LD_INT 6
62447: PPUSH
62448: LD_VAR 0 16
62452: PPUSH
62453: CALL_OW 321
62457: PUSH
62458: LD_INT 2
62460: EQUAL
62461: AND
62462: IFFALSE 62627
// begin if not FilterAllUnits ( [ [ f_side , side ] , [ f_or , [ f_bweapon , us_radar ] , [ f_bweapon , ar_radar ] ] , [ f_dist , tower , 18 ] ] ) and FilterAllUnits ( [ [ [ f_side , side ] , [ f_or , [ f_btype , b_bunker ] , [ f_btype , b_turret ] ] , [ f_dist , tower , 12 ] ] ] ) > 2 then
62464: LD_INT 22
62466: PUSH
62467: LD_VAR 0 16
62471: PUSH
62472: EMPTY
62473: LIST
62474: LIST
62475: PUSH
62476: LD_INT 2
62478: PUSH
62479: LD_INT 35
62481: PUSH
62482: LD_INT 11
62484: PUSH
62485: EMPTY
62486: LIST
62487: LIST
62488: PUSH
62489: LD_INT 35
62491: PUSH
62492: LD_INT 30
62494: PUSH
62495: EMPTY
62496: LIST
62497: LIST
62498: PUSH
62499: EMPTY
62500: LIST
62501: LIST
62502: LIST
62503: PUSH
62504: LD_INT 91
62506: PUSH
62507: LD_VAR 0 1
62511: PUSH
62512: LD_INT 18
62514: PUSH
62515: EMPTY
62516: LIST
62517: LIST
62518: LIST
62519: PUSH
62520: EMPTY
62521: LIST
62522: LIST
62523: LIST
62524: PPUSH
62525: CALL_OW 69
62529: NOT
62530: PUSH
62531: LD_INT 22
62533: PUSH
62534: LD_VAR 0 16
62538: PUSH
62539: EMPTY
62540: LIST
62541: LIST
62542: PUSH
62543: LD_INT 2
62545: PUSH
62546: LD_INT 30
62548: PUSH
62549: LD_INT 32
62551: PUSH
62552: EMPTY
62553: LIST
62554: LIST
62555: PUSH
62556: LD_INT 30
62558: PUSH
62559: LD_INT 33
62561: PUSH
62562: EMPTY
62563: LIST
62564: LIST
62565: PUSH
62566: EMPTY
62567: LIST
62568: LIST
62569: LIST
62570: PUSH
62571: LD_INT 91
62573: PUSH
62574: LD_VAR 0 1
62578: PUSH
62579: LD_INT 12
62581: PUSH
62582: EMPTY
62583: LIST
62584: LIST
62585: LIST
62586: PUSH
62587: EMPTY
62588: LIST
62589: LIST
62590: LIST
62591: PUSH
62592: EMPTY
62593: LIST
62594: PPUSH
62595: CALL_OW 69
62599: PUSH
62600: LD_INT 2
62602: GREATER
62603: AND
62604: IFFALSE 62627
// weapon := [ us_radar , ar_radar ] [ nat ] ;
62606: LD_ADDR_VAR 0 18
62610: PUSH
62611: LD_INT 11
62613: PUSH
62614: LD_INT 30
62616: PUSH
62617: EMPTY
62618: LIST
62619: LIST
62620: PUSH
62621: LD_VAR 0 12
62625: ARRAY
62626: ST_TO_ADDR
// end ; if not weapon and GetTech ( tech_rocket , side ) = state_researched and ( us_rocket_launcher in list or ar_rocket_launcher in list or ru_rocket_launcher in list ) then
62627: LD_VAR 0 18
62631: NOT
62632: PUSH
62633: LD_INT 40
62635: PPUSH
62636: LD_VAR 0 16
62640: PPUSH
62641: CALL_OW 321
62645: PUSH
62646: LD_INT 2
62648: EQUAL
62649: AND
62650: PUSH
62651: LD_INT 7
62653: PUSH
62654: LD_VAR 0 5
62658: IN
62659: PUSH
62660: LD_INT 28
62662: PUSH
62663: LD_VAR 0 5
62667: IN
62668: OR
62669: PUSH
62670: LD_INT 45
62672: PUSH
62673: LD_VAR 0 5
62677: IN
62678: OR
62679: AND
62680: IFFALSE 62934
// begin hex := GetHexInfo ( x , y ) ;
62682: LD_ADDR_VAR 0 4
62686: PUSH
62687: LD_VAR 0 10
62691: PPUSH
62692: LD_VAR 0 11
62696: PPUSH
62697: CALL_OW 546
62701: ST_TO_ADDR
// if hex [ 1 ] then
62702: LD_VAR 0 4
62706: PUSH
62707: LD_INT 1
62709: ARRAY
62710: IFFALSE 62714
// exit ;
62712: GO 63117
// height := hex [ 2 ] ;
62714: LD_ADDR_VAR 0 15
62718: PUSH
62719: LD_VAR 0 4
62723: PUSH
62724: LD_INT 2
62726: ARRAY
62727: ST_TO_ADDR
// tmp := [ 0 , 2 , 3 , 5 ] ;
62728: LD_ADDR_VAR 0 14
62732: PUSH
62733: LD_INT 0
62735: PUSH
62736: LD_INT 2
62738: PUSH
62739: LD_INT 3
62741: PUSH
62742: LD_INT 5
62744: PUSH
62745: EMPTY
62746: LIST
62747: LIST
62748: LIST
62749: LIST
62750: ST_TO_ADDR
// for i in tmp do
62751: LD_ADDR_VAR 0 8
62755: PUSH
62756: LD_VAR 0 14
62760: PUSH
62761: FOR_IN
62762: IFFALSE 62932
// begin j := [ ShiftX ( x , i , 5 ) , ShiftY ( y , i , 5 ) ] ;
62764: LD_ADDR_VAR 0 9
62768: PUSH
62769: LD_VAR 0 10
62773: PPUSH
62774: LD_VAR 0 8
62778: PPUSH
62779: LD_INT 5
62781: PPUSH
62782: CALL_OW 272
62786: PUSH
62787: LD_VAR 0 11
62791: PPUSH
62792: LD_VAR 0 8
62796: PPUSH
62797: LD_INT 5
62799: PPUSH
62800: CALL_OW 273
62804: PUSH
62805: EMPTY
62806: LIST
62807: LIST
62808: ST_TO_ADDR
// if ValidHex ( j [ 1 ] , j [ 2 ] ) then
62809: LD_VAR 0 9
62813: PUSH
62814: LD_INT 1
62816: ARRAY
62817: PPUSH
62818: LD_VAR 0 9
62822: PUSH
62823: LD_INT 2
62825: ARRAY
62826: PPUSH
62827: CALL_OW 488
62831: IFFALSE 62930
// begin hex := GetHexInfo ( j [ 1 ] , j [ 2 ] ) ;
62833: LD_ADDR_VAR 0 4
62837: PUSH
62838: LD_VAR 0 9
62842: PUSH
62843: LD_INT 1
62845: ARRAY
62846: PPUSH
62847: LD_VAR 0 9
62851: PUSH
62852: LD_INT 2
62854: ARRAY
62855: PPUSH
62856: CALL_OW 546
62860: ST_TO_ADDR
// if hex [ 1 ] then
62861: LD_VAR 0 4
62865: PUSH
62866: LD_INT 1
62868: ARRAY
62869: IFFALSE 62873
// continue ;
62871: GO 62761
// h := hex [ 2 ] ;
62873: LD_ADDR_VAR 0 13
62877: PUSH
62878: LD_VAR 0 4
62882: PUSH
62883: LD_INT 2
62885: ARRAY
62886: ST_TO_ADDR
// if h + 7 < height then
62887: LD_VAR 0 13
62891: PUSH
62892: LD_INT 7
62894: PLUS
62895: PUSH
62896: LD_VAR 0 15
62900: LESS
62901: IFFALSE 62930
// begin weapon := [ us_rocket_launcher , ar_rocket_launcher , ru_rocket_launcher ] [ nat ] ;
62903: LD_ADDR_VAR 0 18
62907: PUSH
62908: LD_INT 7
62910: PUSH
62911: LD_INT 28
62913: PUSH
62914: LD_INT 45
62916: PUSH
62917: EMPTY
62918: LIST
62919: LIST
62920: LIST
62921: PUSH
62922: LD_VAR 0 12
62926: ARRAY
62927: ST_TO_ADDR
// break ;
62928: GO 62932
// end ; end ; end ;
62930: GO 62761
62932: POP
62933: POP
// end ; if not weapon then
62934: LD_VAR 0 18
62938: NOT
62939: IFFALSE 62999
// begin list := list diff [ us_radar , ar_radar , ru_time_lapser ] ;
62941: LD_ADDR_VAR 0 5
62945: PUSH
62946: LD_VAR 0 5
62950: PUSH
62951: LD_INT 11
62953: PUSH
62954: LD_INT 30
62956: PUSH
62957: LD_INT 49
62959: PUSH
62960: EMPTY
62961: LIST
62962: LIST
62963: LIST
62964: DIFF
62965: ST_TO_ADDR
// if not list then
62966: LD_VAR 0 5
62970: NOT
62971: IFFALSE 62975
// exit ;
62973: GO 63117
// weapon := list [ rand ( 1 , list ) ] ;
62975: LD_ADDR_VAR 0 18
62979: PUSH
62980: LD_VAR 0 5
62984: PUSH
62985: LD_INT 1
62987: PPUSH
62988: LD_VAR 0 5
62992: PPUSH
62993: CALL_OW 12
62997: ARRAY
62998: ST_TO_ADDR
// end ; if weapon then
62999: LD_VAR 0 18
63003: IFFALSE 63117
// begin tmp := CostOfWeapon ( weapon ) ;
63005: LD_ADDR_VAR 0 14
63009: PUSH
63010: LD_VAR 0 18
63014: PPUSH
63015: CALL_OW 451
63019: ST_TO_ADDR
// j := GetBase ( tower ) ;
63020: LD_ADDR_VAR 0 9
63024: PUSH
63025: LD_VAR 0 1
63029: PPUSH
63030: CALL_OW 274
63034: ST_TO_ADDR
// if GetResourceType ( j , mat_cans ) >= tmp [ 1 ] and GetResourceType ( j , mat_oil ) >= tmp [ 2 ] and GetResourceType ( j , mat_siberit ) >= tmp [ 3 ] then
63035: LD_VAR 0 9
63039: PPUSH
63040: LD_INT 1
63042: PPUSH
63043: CALL_OW 275
63047: PUSH
63048: LD_VAR 0 14
63052: PUSH
63053: LD_INT 1
63055: ARRAY
63056: GREATEREQUAL
63057: PUSH
63058: LD_VAR 0 9
63062: PPUSH
63063: LD_INT 2
63065: PPUSH
63066: CALL_OW 275
63070: PUSH
63071: LD_VAR 0 14
63075: PUSH
63076: LD_INT 2
63078: ARRAY
63079: GREATEREQUAL
63080: AND
63081: PUSH
63082: LD_VAR 0 9
63086: PPUSH
63087: LD_INT 3
63089: PPUSH
63090: CALL_OW 275
63094: PUSH
63095: LD_VAR 0 14
63099: PUSH
63100: LD_INT 3
63102: ARRAY
63103: GREATEREQUAL
63104: AND
63105: IFFALSE 63117
// result := weapon ;
63107: LD_ADDR_VAR 0 3
63111: PUSH
63112: LD_VAR 0 18
63116: ST_TO_ADDR
// end ; end ;
63117: LD_VAR 0 3
63121: RET
// export function CompareArray ( array1 , array2 ) ; var i ; begin
63122: LD_INT 0
63124: PPUSH
63125: PPUSH
// result := true ;
63126: LD_ADDR_VAR 0 3
63130: PUSH
63131: LD_INT 1
63133: ST_TO_ADDR
// if array1 = array2 then
63134: LD_VAR 0 1
63138: PUSH
63139: LD_VAR 0 2
63143: EQUAL
63144: IFFALSE 63204
// begin for i = 1 to array1 do
63146: LD_ADDR_VAR 0 4
63150: PUSH
63151: DOUBLE
63152: LD_INT 1
63154: DEC
63155: ST_TO_ADDR
63156: LD_VAR 0 1
63160: PUSH
63161: FOR_TO
63162: IFFALSE 63200
// if array1 [ i ] <> array2 [ i ] then
63164: LD_VAR 0 1
63168: PUSH
63169: LD_VAR 0 4
63173: ARRAY
63174: PUSH
63175: LD_VAR 0 2
63179: PUSH
63180: LD_VAR 0 4
63184: ARRAY
63185: NONEQUAL
63186: IFFALSE 63198
// begin result := false ;
63188: LD_ADDR_VAR 0 3
63192: PUSH
63193: LD_INT 0
63195: ST_TO_ADDR
// break ;
63196: GO 63200
// end ;
63198: GO 63161
63200: POP
63201: POP
// end else
63202: GO 63212
// result := false ;
63204: LD_ADDR_VAR 0 3
63208: PUSH
63209: LD_INT 0
63211: ST_TO_ADDR
// end ;
63212: LD_VAR 0 3
63216: RET
// export function VehicleCost ( fac , list ) ; var cost , pom ; begin
63217: LD_INT 0
63219: PPUSH
63220: PPUSH
63221: PPUSH
// pom := GetBase ( fac ) ;
63222: LD_ADDR_VAR 0 5
63226: PUSH
63227: LD_VAR 0 1
63231: PPUSH
63232: CALL_OW 274
63236: ST_TO_ADDR
// cost := CostOfVehicle ( list [ 1 ] , list [ 2 ] , list [ 3 ] , list [ 4 ] ) ;
63237: LD_ADDR_VAR 0 4
63241: PUSH
63242: LD_VAR 0 2
63246: PUSH
63247: LD_INT 1
63249: ARRAY
63250: PPUSH
63251: LD_VAR 0 2
63255: PUSH
63256: LD_INT 2
63258: ARRAY
63259: PPUSH
63260: LD_VAR 0 2
63264: PUSH
63265: LD_INT 3
63267: ARRAY
63268: PPUSH
63269: LD_VAR 0 2
63273: PUSH
63274: LD_INT 4
63276: ARRAY
63277: PPUSH
63278: CALL_OW 449
63282: ST_TO_ADDR
// result := GetResourceType ( pom , mat_cans ) >= cost [ 1 ] and GetResourceType ( pom , mat_oil ) >= cost [ 2 ] and GetResourceType ( pom , mat_siberit ) >= cost [ 3 ] ;
63283: LD_ADDR_VAR 0 3
63287: PUSH
63288: LD_VAR 0 5
63292: PPUSH
63293: LD_INT 1
63295: PPUSH
63296: CALL_OW 275
63300: PUSH
63301: LD_VAR 0 4
63305: PUSH
63306: LD_INT 1
63308: ARRAY
63309: GREATEREQUAL
63310: PUSH
63311: LD_VAR 0 5
63315: PPUSH
63316: LD_INT 2
63318: PPUSH
63319: CALL_OW 275
63323: PUSH
63324: LD_VAR 0 4
63328: PUSH
63329: LD_INT 2
63331: ARRAY
63332: GREATEREQUAL
63333: AND
63334: PUSH
63335: LD_VAR 0 5
63339: PPUSH
63340: LD_INT 3
63342: PPUSH
63343: CALL_OW 275
63347: PUSH
63348: LD_VAR 0 4
63352: PUSH
63353: LD_INT 3
63355: ARRAY
63356: GREATEREQUAL
63357: AND
63358: ST_TO_ADDR
// end ;
63359: LD_VAR 0 3
63363: RET
// export function UpgradeCost ( building ) ; var pom , cost , btype ; begin
63364: LD_INT 0
63366: PPUSH
63367: PPUSH
63368: PPUSH
63369: PPUSH
// pom := GetBase ( building ) ;
63370: LD_ADDR_VAR 0 3
63374: PUSH
63375: LD_VAR 0 1
63379: PPUSH
63380: CALL_OW 274
63384: ST_TO_ADDR
// if not pom then
63385: LD_VAR 0 3
63389: NOT
63390: IFFALSE 63394
// exit ;
63392: GO 63564
// btype := GetBType ( building ) ;
63394: LD_ADDR_VAR 0 5
63398: PUSH
63399: LD_VAR 0 1
63403: PPUSH
63404: CALL_OW 266
63408: ST_TO_ADDR
// if btype = b_armoury then
63409: LD_VAR 0 5
63413: PUSH
63414: LD_INT 4
63416: EQUAL
63417: IFFALSE 63427
// btype := b_barracks ;
63419: LD_ADDR_VAR 0 5
63423: PUSH
63424: LD_INT 5
63426: ST_TO_ADDR
// if btype = b_depot then
63427: LD_VAR 0 5
63431: PUSH
63432: LD_INT 0
63434: EQUAL
63435: IFFALSE 63445
// btype := b_warehouse ;
63437: LD_ADDR_VAR 0 5
63441: PUSH
63442: LD_INT 1
63444: ST_TO_ADDR
// if btype = b_workshop then
63445: LD_VAR 0 5
63449: PUSH
63450: LD_INT 2
63452: EQUAL
63453: IFFALSE 63463
// btype := b_factory ;
63455: LD_ADDR_VAR 0 5
63459: PUSH
63460: LD_INT 3
63462: ST_TO_ADDR
// cost := CostOfBuilding ( btype , GetNation ( building ) ) ;
63463: LD_ADDR_VAR 0 4
63467: PUSH
63468: LD_VAR 0 5
63472: PPUSH
63473: LD_VAR 0 1
63477: PPUSH
63478: CALL_OW 248
63482: PPUSH
63483: CALL_OW 450
63487: ST_TO_ADDR
// result := GetResourceType ( pom , mat_cans ) >= cost [ 1 ] and GetResourceType ( pom , mat_oil ) >= cost [ 2 ] and GetResourceType ( pom , mat_siberit ) >= cost [ 3 ] ;
63488: LD_ADDR_VAR 0 2
63492: PUSH
63493: LD_VAR 0 3
63497: PPUSH
63498: LD_INT 1
63500: PPUSH
63501: CALL_OW 275
63505: PUSH
63506: LD_VAR 0 4
63510: PUSH
63511: LD_INT 1
63513: ARRAY
63514: GREATEREQUAL
63515: PUSH
63516: LD_VAR 0 3
63520: PPUSH
63521: LD_INT 2
63523: PPUSH
63524: CALL_OW 275
63528: PUSH
63529: LD_VAR 0 4
63533: PUSH
63534: LD_INT 2
63536: ARRAY
63537: GREATEREQUAL
63538: AND
63539: PUSH
63540: LD_VAR 0 3
63544: PPUSH
63545: LD_INT 3
63547: PPUSH
63548: CALL_OW 275
63552: PUSH
63553: LD_VAR 0 4
63557: PUSH
63558: LD_INT 3
63560: ARRAY
63561: GREATEREQUAL
63562: AND
63563: ST_TO_ADDR
// end ;
63564: LD_VAR 0 2
63568: RET
// export function UpgradeLabCost ( building , btype ) ; var pom , cost ; begin
63569: LD_INT 0
63571: PPUSH
63572: PPUSH
63573: PPUSH
// pom := GetBase ( building ) ;
63574: LD_ADDR_VAR 0 4
63578: PUSH
63579: LD_VAR 0 1
63583: PPUSH
63584: CALL_OW 274
63588: ST_TO_ADDR
// if not pom then
63589: LD_VAR 0 4
63593: NOT
63594: IFFALSE 63598
// exit ;
63596: GO 63699
// cost := CostOfBuilding ( btype , GetNation ( building ) ) ;
63598: LD_ADDR_VAR 0 5
63602: PUSH
63603: LD_VAR 0 2
63607: PPUSH
63608: LD_VAR 0 1
63612: PPUSH
63613: CALL_OW 248
63617: PPUSH
63618: CALL_OW 450
63622: ST_TO_ADDR
// result := GetResourceType ( pom , mat_cans ) >= cost [ 1 ] and GetResourceType ( pom , mat_oil ) >= cost [ 2 ] and GetResourceType ( pom , mat_siberit ) >= cost [ 3 ] ;
63623: LD_ADDR_VAR 0 3
63627: PUSH
63628: LD_VAR 0 4
63632: PPUSH
63633: LD_INT 1
63635: PPUSH
63636: CALL_OW 275
63640: PUSH
63641: LD_VAR 0 5
63645: PUSH
63646: LD_INT 1
63648: ARRAY
63649: GREATEREQUAL
63650: PUSH
63651: LD_VAR 0 4
63655: PPUSH
63656: LD_INT 2
63658: PPUSH
63659: CALL_OW 275
63663: PUSH
63664: LD_VAR 0 5
63668: PUSH
63669: LD_INT 2
63671: ARRAY
63672: GREATEREQUAL
63673: AND
63674: PUSH
63675: LD_VAR 0 4
63679: PPUSH
63680: LD_INT 3
63682: PPUSH
63683: CALL_OW 275
63687: PUSH
63688: LD_VAR 0 5
63692: PUSH
63693: LD_INT 3
63695: ARRAY
63696: GREATEREQUAL
63697: AND
63698: ST_TO_ADDR
// end ;
63699: LD_VAR 0 3
63703: RET
// export function TryClearPlaceForBuilding ( base , btype , x , y , d ) ; var i , j , _x , _y , tmp , hexes , r , xy , dep ; begin
63704: LD_INT 0
63706: PPUSH
63707: PPUSH
63708: PPUSH
63709: PPUSH
63710: PPUSH
63711: PPUSH
63712: PPUSH
63713: PPUSH
63714: PPUSH
63715: PPUSH
// result := false ;
63716: LD_ADDR_VAR 0 6
63720: PUSH
63721: LD_INT 0
63723: ST_TO_ADDR
// if not base or not btype or not x or not y then
63724: LD_VAR 0 1
63728: NOT
63729: PUSH
63730: LD_VAR 0 2
63734: NOT
63735: OR
63736: PUSH
63737: LD_VAR 0 3
63741: NOT
63742: OR
63743: PUSH
63744: LD_VAR 0 4
63748: NOT
63749: OR
63750: IFFALSE 63754
// exit ;
63752: GO 64363
// hexes := GetBuildingHexes ( btype , x , y , d , GetNation ( base [ 1 ] ) , 0 ) ;
63754: LD_ADDR_VAR 0 12
63758: PUSH
63759: LD_VAR 0 2
63763: PPUSH
63764: LD_VAR 0 3
63768: PPUSH
63769: LD_VAR 0 4
63773: PPUSH
63774: LD_VAR 0 5
63778: PPUSH
63779: LD_VAR 0 1
63783: PUSH
63784: LD_INT 1
63786: ARRAY
63787: PPUSH
63788: CALL_OW 248
63792: PPUSH
63793: LD_INT 0
63795: PPUSH
63796: CALL 65200 0 6
63800: ST_TO_ADDR
// if not hexes then
63801: LD_VAR 0 12
63805: NOT
63806: IFFALSE 63810
// exit ;
63808: GO 64363
// for i = 1 to hexes do
63810: LD_ADDR_VAR 0 7
63814: PUSH
63815: DOUBLE
63816: LD_INT 1
63818: DEC
63819: ST_TO_ADDR
63820: LD_VAR 0 12
63824: PUSH
63825: FOR_TO
63826: IFFALSE 64361
// begin tmp := HexInfo ( hexes [ i ] [ 1 ] , hexes [ i ] [ 2 ] ) ;
63828: LD_ADDR_VAR 0 11
63832: PUSH
63833: LD_VAR 0 12
63837: PUSH
63838: LD_VAR 0 7
63842: ARRAY
63843: PUSH
63844: LD_INT 1
63846: ARRAY
63847: PPUSH
63848: LD_VAR 0 12
63852: PUSH
63853: LD_VAR 0 7
63857: ARRAY
63858: PUSH
63859: LD_INT 2
63861: ARRAY
63862: PPUSH
63863: CALL_OW 428
63867: ST_TO_ADDR
// if IsEnvironment ( hexes [ i ] [ 1 ] , hexes [ i ] [ 2 ] ) or not ValidHex ( hexes [ i ] [ 1 ] , hexes [ i ] [ 2 ] ) or GetType ( tmp ) = unit_building then
63868: LD_VAR 0 12
63872: PUSH
63873: LD_VAR 0 7
63877: ARRAY
63878: PUSH
63879: LD_INT 1
63881: ARRAY
63882: PPUSH
63883: LD_VAR 0 12
63887: PUSH
63888: LD_VAR 0 7
63892: ARRAY
63893: PUSH
63894: LD_INT 2
63896: ARRAY
63897: PPUSH
63898: CALL_OW 351
63902: PUSH
63903: LD_VAR 0 12
63907: PUSH
63908: LD_VAR 0 7
63912: ARRAY
63913: PUSH
63914: LD_INT 1
63916: ARRAY
63917: PPUSH
63918: LD_VAR 0 12
63922: PUSH
63923: LD_VAR 0 7
63927: ARRAY
63928: PUSH
63929: LD_INT 2
63931: ARRAY
63932: PPUSH
63933: CALL_OW 488
63937: NOT
63938: OR
63939: PUSH
63940: LD_VAR 0 11
63944: PPUSH
63945: CALL_OW 247
63949: PUSH
63950: LD_INT 3
63952: EQUAL
63953: OR
63954: IFFALSE 63960
// exit ;
63956: POP
63957: POP
63958: GO 64363
// if not tmp or not tmp in base then
63960: LD_VAR 0 11
63964: NOT
63965: PUSH
63966: LD_VAR 0 11
63970: PUSH
63971: LD_VAR 0 1
63975: IN
63976: NOT
63977: OR
63978: IFFALSE 63982
// continue ;
63980: GO 63825
// result := true ;
63982: LD_ADDR_VAR 0 6
63986: PUSH
63987: LD_INT 1
63989: ST_TO_ADDR
// dep := UnitFilter ( base , [ [ f_side , GetSide ( tmp ) ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ] ) ;
63990: LD_ADDR_VAR 0 15
63994: PUSH
63995: LD_VAR 0 1
63999: PPUSH
64000: LD_INT 22
64002: PUSH
64003: LD_VAR 0 11
64007: PPUSH
64008: CALL_OW 255
64012: PUSH
64013: EMPTY
64014: LIST
64015: LIST
64016: PUSH
64017: LD_INT 2
64019: PUSH
64020: LD_INT 30
64022: PUSH
64023: LD_INT 0
64025: PUSH
64026: EMPTY
64027: LIST
64028: LIST
64029: PUSH
64030: LD_INT 30
64032: PUSH
64033: LD_INT 1
64035: PUSH
64036: EMPTY
64037: LIST
64038: LIST
64039: PUSH
64040: EMPTY
64041: LIST
64042: LIST
64043: LIST
64044: PUSH
64045: EMPTY
64046: LIST
64047: LIST
64048: PPUSH
64049: CALL_OW 72
64053: ST_TO_ADDR
// if dep then
64054: LD_VAR 0 15
64058: IFFALSE 64194
// begin xy := [ ShiftX ( GetX ( dep [ 1 ] ) , GetDir ( dep [ 1 ] ) , 5 ) , ShiftY ( GetY ( dep [ 1 ] ) , GetDir ( dep [ 1 ] ) , 5 ) ] ;
64060: LD_ADDR_VAR 0 14
64064: PUSH
64065: LD_VAR 0 15
64069: PUSH
64070: LD_INT 1
64072: ARRAY
64073: PPUSH
64074: CALL_OW 250
64078: PPUSH
64079: LD_VAR 0 15
64083: PUSH
64084: LD_INT 1
64086: ARRAY
64087: PPUSH
64088: CALL_OW 254
64092: PPUSH
64093: LD_INT 5
64095: PPUSH
64096: CALL_OW 272
64100: PUSH
64101: LD_VAR 0 15
64105: PUSH
64106: LD_INT 1
64108: ARRAY
64109: PPUSH
64110: CALL_OW 251
64114: PPUSH
64115: LD_VAR 0 15
64119: PUSH
64120: LD_INT 1
64122: ARRAY
64123: PPUSH
64124: CALL_OW 254
64128: PPUSH
64129: LD_INT 5
64131: PPUSH
64132: CALL_OW 273
64136: PUSH
64137: EMPTY
64138: LIST
64139: LIST
64140: ST_TO_ADDR
// if ValidHex ( xy [ 1 ] , xy [ 2 ] ) then
64141: LD_VAR 0 14
64145: PUSH
64146: LD_INT 1
64148: ARRAY
64149: PPUSH
64150: LD_VAR 0 14
64154: PUSH
64155: LD_INT 2
64157: ARRAY
64158: PPUSH
64159: CALL_OW 488
64163: IFFALSE 64194
// begin ComMoveXY ( tmp , xy [ 1 ] , xy [ 2 ] ) ;
64165: LD_VAR 0 11
64169: PPUSH
64170: LD_VAR 0 14
64174: PUSH
64175: LD_INT 1
64177: ARRAY
64178: PPUSH
64179: LD_VAR 0 14
64183: PUSH
64184: LD_INT 2
64186: ARRAY
64187: PPUSH
64188: CALL_OW 111
// continue ;
64192: GO 63825
// end ; end ; r := GetDir ( tmp ) ;
64194: LD_ADDR_VAR 0 13
64198: PUSH
64199: LD_VAR 0 11
64203: PPUSH
64204: CALL_OW 254
64208: ST_TO_ADDR
// if r = 5 then
64209: LD_VAR 0 13
64213: PUSH
64214: LD_INT 5
64216: EQUAL
64217: IFFALSE 64227
// r := 0 ;
64219: LD_ADDR_VAR 0 13
64223: PUSH
64224: LD_INT 0
64226: ST_TO_ADDR
// for j = r to 5 do
64227: LD_ADDR_VAR 0 8
64231: PUSH
64232: DOUBLE
64233: LD_VAR 0 13
64237: DEC
64238: ST_TO_ADDR
64239: LD_INT 5
64241: PUSH
64242: FOR_TO
64243: IFFALSE 64357
// begin _x := ShiftX ( GetX ( tmp ) , j , 2 ) ;
64245: LD_ADDR_VAR 0 9
64249: PUSH
64250: LD_VAR 0 11
64254: PPUSH
64255: CALL_OW 250
64259: PPUSH
64260: LD_VAR 0 8
64264: PPUSH
64265: LD_INT 2
64267: PPUSH
64268: CALL_OW 272
64272: ST_TO_ADDR
// _y := ShiftY ( GetY ( tmp ) , j , 2 ) ;
64273: LD_ADDR_VAR 0 10
64277: PUSH
64278: LD_VAR 0 11
64282: PPUSH
64283: CALL_OW 251
64287: PPUSH
64288: LD_VAR 0 8
64292: PPUSH
64293: LD_INT 2
64295: PPUSH
64296: CALL_OW 273
64300: ST_TO_ADDR
// if ValidHex ( _x , _y ) and not HexInfo ( _x , _y ) then
64301: LD_VAR 0 9
64305: PPUSH
64306: LD_VAR 0 10
64310: PPUSH
64311: CALL_OW 488
64315: PUSH
64316: LD_VAR 0 9
64320: PPUSH
64321: LD_VAR 0 10
64325: PPUSH
64326: CALL_OW 428
64330: NOT
64331: AND
64332: IFFALSE 64355
// begin ComMoveXY ( tmp , _x , _y ) ;
64334: LD_VAR 0 11
64338: PPUSH
64339: LD_VAR 0 9
64343: PPUSH
64344: LD_VAR 0 10
64348: PPUSH
64349: CALL_OW 111
// break ;
64353: GO 64357
// end ; end ;
64355: GO 64242
64357: POP
64358: POP
// end ;
64359: GO 63825
64361: POP
64362: POP
// end ;
64363: LD_VAR 0 6
64367: RET
// export function CanBeBuilt ( depot , btype , x , y , d ) ; var i , j , side , pom , cost , hexes , height , dist , hex ; begin
64368: LD_INT 0
64370: PPUSH
64371: PPUSH
64372: PPUSH
64373: PPUSH
64374: PPUSH
64375: PPUSH
64376: PPUSH
64377: PPUSH
64378: PPUSH
64379: PPUSH
// result := false ;
64380: LD_ADDR_VAR 0 6
64384: PUSH
64385: LD_INT 0
64387: ST_TO_ADDR
// if not depot or not GetBType ( depot ) in [ b_depot , b_warehouse ] or not btype or not d in [ 0 , 1 , 2 , 3 , 4 , 5 ] or not ValidHex ( x , y ) then
64388: LD_VAR 0 1
64392: NOT
64393: PUSH
64394: LD_VAR 0 1
64398: PPUSH
64399: CALL_OW 266
64403: PUSH
64404: LD_INT 0
64406: PUSH
64407: LD_INT 1
64409: PUSH
64410: EMPTY
64411: LIST
64412: LIST
64413: IN
64414: NOT
64415: OR
64416: PUSH
64417: LD_VAR 0 2
64421: NOT
64422: OR
64423: PUSH
64424: LD_VAR 0 5
64428: PUSH
64429: LD_INT 0
64431: PUSH
64432: LD_INT 1
64434: PUSH
64435: LD_INT 2
64437: PUSH
64438: LD_INT 3
64440: PUSH
64441: LD_INT 4
64443: PUSH
64444: LD_INT 5
64446: PUSH
64447: EMPTY
64448: LIST
64449: LIST
64450: LIST
64451: LIST
64452: LIST
64453: LIST
64454: IN
64455: NOT
64456: OR
64457: PUSH
64458: LD_VAR 0 3
64462: PPUSH
64463: LD_VAR 0 4
64467: PPUSH
64468: CALL_OW 488
64472: NOT
64473: OR
64474: IFFALSE 64478
// exit ;
64476: GO 65195
// pom := GetBase ( depot ) ;
64478: LD_ADDR_VAR 0 10
64482: PUSH
64483: LD_VAR 0 1
64487: PPUSH
64488: CALL_OW 274
64492: ST_TO_ADDR
// cost := CostOfBuilding ( btype , GetNation ( depot ) ) ;
64493: LD_ADDR_VAR 0 11
64497: PUSH
64498: LD_VAR 0 2
64502: PPUSH
64503: LD_VAR 0 1
64507: PPUSH
64508: CALL_OW 248
64512: PPUSH
64513: CALL_OW 450
64517: ST_TO_ADDR
// if not ( GetResourceType ( pom , mat_cans ) >= cost [ 1 ] and GetResourceType ( pom , mat_oil ) >= cost [ 2 ] and GetResourceType ( pom , mat_siberit ) >= cost [ 3 ] ) then
64518: LD_VAR 0 10
64522: PPUSH
64523: LD_INT 1
64525: PPUSH
64526: CALL_OW 275
64530: PUSH
64531: LD_VAR 0 11
64535: PUSH
64536: LD_INT 1
64538: ARRAY
64539: GREATEREQUAL
64540: PUSH
64541: LD_VAR 0 10
64545: PPUSH
64546: LD_INT 2
64548: PPUSH
64549: CALL_OW 275
64553: PUSH
64554: LD_VAR 0 11
64558: PUSH
64559: LD_INT 2
64561: ARRAY
64562: GREATEREQUAL
64563: AND
64564: PUSH
64565: LD_VAR 0 10
64569: PPUSH
64570: LD_INT 3
64572: PPUSH
64573: CALL_OW 275
64577: PUSH
64578: LD_VAR 0 11
64582: PUSH
64583: LD_INT 3
64585: ARRAY
64586: GREATEREQUAL
64587: AND
64588: NOT
64589: IFFALSE 64593
// exit ;
64591: GO 65195
// if GetBType ( depot ) = b_depot then
64593: LD_VAR 0 1
64597: PPUSH
64598: CALL_OW 266
64602: PUSH
64603: LD_INT 0
64605: EQUAL
64606: IFFALSE 64618
// dist := 28 else
64608: LD_ADDR_VAR 0 14
64612: PUSH
64613: LD_INT 28
64615: ST_TO_ADDR
64616: GO 64626
// dist := 36 ;
64618: LD_ADDR_VAR 0 14
64622: PUSH
64623: LD_INT 36
64625: ST_TO_ADDR
// if GetDistUnitXY ( depot , x , y ) > dist then
64626: LD_VAR 0 1
64630: PPUSH
64631: LD_VAR 0 3
64635: PPUSH
64636: LD_VAR 0 4
64640: PPUSH
64641: CALL_OW 297
64645: PUSH
64646: LD_VAR 0 14
64650: GREATER
64651: IFFALSE 64655
// exit ;
64653: GO 65195
// hexes := GetBuildingHexes ( btype , x , y , d , GetNation ( depot ) , 0 ) ;
64655: LD_ADDR_VAR 0 12
64659: PUSH
64660: LD_VAR 0 2
64664: PPUSH
64665: LD_VAR 0 3
64669: PPUSH
64670: LD_VAR 0 4
64674: PPUSH
64675: LD_VAR 0 5
64679: PPUSH
64680: LD_VAR 0 1
64684: PPUSH
64685: CALL_OW 248
64689: PPUSH
64690: LD_INT 0
64692: PPUSH
64693: CALL 65200 0 6
64697: ST_TO_ADDR
// if not hexes then
64698: LD_VAR 0 12
64702: NOT
64703: IFFALSE 64707
// exit ;
64705: GO 65195
// hex := GetHexInfo ( x , y ) ;
64707: LD_ADDR_VAR 0 15
64711: PUSH
64712: LD_VAR 0 3
64716: PPUSH
64717: LD_VAR 0 4
64721: PPUSH
64722: CALL_OW 546
64726: ST_TO_ADDR
// if hex [ 1 ] then
64727: LD_VAR 0 15
64731: PUSH
64732: LD_INT 1
64734: ARRAY
64735: IFFALSE 64739
// exit ;
64737: GO 65195
// height := hex [ 2 ] ;
64739: LD_ADDR_VAR 0 13
64743: PUSH
64744: LD_VAR 0 15
64748: PUSH
64749: LD_INT 2
64751: ARRAY
64752: ST_TO_ADDR
// for i = 1 to hexes do
64753: LD_ADDR_VAR 0 7
64757: PUSH
64758: DOUBLE
64759: LD_INT 1
64761: DEC
64762: ST_TO_ADDR
64763: LD_VAR 0 12
64767: PUSH
64768: FOR_TO
64769: IFFALSE 65099
// begin if not ValidHex ( hexes [ i ] [ 1 ] , hexes [ i ] [ 2 ] ) or HexInfo ( hexes [ i ] [ 1 ] , hexes [ i ] [ 2 ] ) > 0 or IsEnvironment ( hexes [ i ] [ 1 ] , hexes [ i ] [ 2 ] ) then
64771: LD_VAR 0 12
64775: PUSH
64776: LD_VAR 0 7
64780: ARRAY
64781: PUSH
64782: LD_INT 1
64784: ARRAY
64785: PPUSH
64786: LD_VAR 0 12
64790: PUSH
64791: LD_VAR 0 7
64795: ARRAY
64796: PUSH
64797: LD_INT 2
64799: ARRAY
64800: PPUSH
64801: CALL_OW 488
64805: NOT
64806: PUSH
64807: LD_VAR 0 12
64811: PUSH
64812: LD_VAR 0 7
64816: ARRAY
64817: PUSH
64818: LD_INT 1
64820: ARRAY
64821: PPUSH
64822: LD_VAR 0 12
64826: PUSH
64827: LD_VAR 0 7
64831: ARRAY
64832: PUSH
64833: LD_INT 2
64835: ARRAY
64836: PPUSH
64837: CALL_OW 428
64841: PUSH
64842: LD_INT 0
64844: GREATER
64845: OR
64846: PUSH
64847: LD_VAR 0 12
64851: PUSH
64852: LD_VAR 0 7
64856: ARRAY
64857: PUSH
64858: LD_INT 1
64860: ARRAY
64861: PPUSH
64862: LD_VAR 0 12
64866: PUSH
64867: LD_VAR 0 7
64871: ARRAY
64872: PUSH
64873: LD_INT 2
64875: ARRAY
64876: PPUSH
64877: CALL_OW 351
64881: OR
64882: IFFALSE 64888
// exit ;
64884: POP
64885: POP
64886: GO 65195
// j := GetHexInfo ( hexes [ i ] [ 1 ] , hexes [ i ] [ 2 ] ) ;
64888: LD_ADDR_VAR 0 8
64892: PUSH
64893: LD_VAR 0 12
64897: PUSH
64898: LD_VAR 0 7
64902: ARRAY
64903: PUSH
64904: LD_INT 1
64906: ARRAY
64907: PPUSH
64908: LD_VAR 0 12
64912: PUSH
64913: LD_VAR 0 7
64917: ARRAY
64918: PUSH
64919: LD_INT 2
64921: ARRAY
64922: PPUSH
64923: CALL_OW 546
64927: ST_TO_ADDR
// if j [ 1 ] or j [ 2 ] > height + 2 or j [ 2 ] < height - 2 or not j [ 3 ] in [ 0 , 8 , 9 , 10 , 11 , 12 , 13 , 16 , 17 , 18 , 19 , 20 , 21 ] or not j [ 5 ] or not j [ 6 ] in [ 1 , 2 , 7 , 9 , 10 , 11 ] then
64928: LD_VAR 0 8
64932: PUSH
64933: LD_INT 1
64935: ARRAY
64936: PUSH
64937: LD_VAR 0 8
64941: PUSH
64942: LD_INT 2
64944: ARRAY
64945: PUSH
64946: LD_VAR 0 13
64950: PUSH
64951: LD_INT 2
64953: PLUS
64954: GREATER
64955: OR
64956: PUSH
64957: LD_VAR 0 8
64961: PUSH
64962: LD_INT 2
64964: ARRAY
64965: PUSH
64966: LD_VAR 0 13
64970: PUSH
64971: LD_INT 2
64973: MINUS
64974: LESS
64975: OR
64976: PUSH
64977: LD_VAR 0 8
64981: PUSH
64982: LD_INT 3
64984: ARRAY
64985: PUSH
64986: LD_INT 0
64988: PUSH
64989: LD_INT 8
64991: PUSH
64992: LD_INT 9
64994: PUSH
64995: LD_INT 10
64997: PUSH
64998: LD_INT 11
65000: PUSH
65001: LD_INT 12
65003: PUSH
65004: LD_INT 13
65006: PUSH
65007: LD_INT 16
65009: PUSH
65010: LD_INT 17
65012: PUSH
65013: LD_INT 18
65015: PUSH
65016: LD_INT 19
65018: PUSH
65019: LD_INT 20
65021: PUSH
65022: LD_INT 21
65024: PUSH
65025: EMPTY
65026: LIST
65027: LIST
65028: LIST
65029: LIST
65030: LIST
65031: LIST
65032: LIST
65033: LIST
65034: LIST
65035: LIST
65036: LIST
65037: LIST
65038: LIST
65039: IN
65040: NOT
65041: OR
65042: PUSH
65043: LD_VAR 0 8
65047: PUSH
65048: LD_INT 5
65050: ARRAY
65051: NOT
65052: OR
65053: PUSH
65054: LD_VAR 0 8
65058: PUSH
65059: LD_INT 6
65061: ARRAY
65062: PUSH
65063: LD_INT 1
65065: PUSH
65066: LD_INT 2
65068: PUSH
65069: LD_INT 7
65071: PUSH
65072: LD_INT 9
65074: PUSH
65075: LD_INT 10
65077: PUSH
65078: LD_INT 11
65080: PUSH
65081: EMPTY
65082: LIST
65083: LIST
65084: LIST
65085: LIST
65086: LIST
65087: LIST
65088: IN
65089: NOT
65090: OR
65091: IFFALSE 65097
// exit ;
65093: POP
65094: POP
65095: GO 65195
// end ;
65097: GO 64768
65099: POP
65100: POP
// side := GetSide ( depot ) ;
65101: LD_ADDR_VAR 0 9
65105: PUSH
65106: LD_VAR 0 1
65110: PPUSH
65111: CALL_OW 255
65115: ST_TO_ADDR
// if DangerAtRangeXY ( side , x , y , 20 ) [ 4 ] then
65116: LD_VAR 0 9
65120: PPUSH
65121: LD_VAR 0 3
65125: PPUSH
65126: LD_VAR 0 4
65130: PPUSH
65131: LD_INT 20
65133: PPUSH
65134: CALL 57849 0 4
65138: PUSH
65139: LD_INT 4
65141: ARRAY
65142: IFFALSE 65146
// exit ;
65144: GO 65195
// if btype in [ b_oil_mine , b_siberite_mine ] and not GetResourceVisibility ( x , y , side ) then
65146: LD_VAR 0 2
65150: PUSH
65151: LD_INT 29
65153: PUSH
65154: LD_INT 30
65156: PUSH
65157: EMPTY
65158: LIST
65159: LIST
65160: IN
65161: PUSH
65162: LD_VAR 0 3
65166: PPUSH
65167: LD_VAR 0 4
65171: PPUSH
65172: LD_VAR 0 9
65176: PPUSH
65177: CALL_OW 440
65181: NOT
65182: AND
65183: IFFALSE 65187
// exit ;
65185: GO 65195
// result := true ;
65187: LD_ADDR_VAR 0 6
65191: PUSH
65192: LD_INT 1
65194: ST_TO_ADDR
// end ;
65195: LD_VAR 0 6
65199: RET
// export function GetBuildingHexes ( btype , x , y , dir , nation , mode ) ; var i , temp_list , temp_list2 ; var DepotAm0 , DepotAm1 , DepotAm2 , DepotAm3 , DepotAm4 , DepotAm5 , DepotAr0 , DepotAr1 , DepotAr2 , DepotAr3 , DepotAr4 , DepotAr5 , DepotRu0 , DepotRu1 , DepotRu2 , DepotRu3 , DepotRu4 , DepotRu5 ; var Factory0 , Factory1 , Factory2 , Factory3 , Factory4 , Factory5 , Ext0 , Ext1 , Ext2 , Ext3 , Ext4 , Ext5 ; var Lab0 , Lab1 , Lab2 , Lab3 , Lab4 , Lab5 , ControlTower0 , ControlTower1 , ControlTower2 , ControlTower3 , ControlTower4 , ControlTower5 ; var Barracks0 , Barracks1 , Barracks2 , Barracks3 , Barracks4 , Barracks5 , Bunker0 , Bunker1 , Bunker2 , Bunker3 , Bunker4 , Bunker5 ; begin
65200: LD_INT 0
65202: PPUSH
65203: PPUSH
65204: PPUSH
65205: PPUSH
65206: PPUSH
65207: PPUSH
65208: PPUSH
65209: PPUSH
65210: PPUSH
65211: PPUSH
65212: PPUSH
65213: PPUSH
65214: PPUSH
65215: PPUSH
65216: PPUSH
65217: PPUSH
65218: PPUSH
65219: PPUSH
65220: PPUSH
65221: PPUSH
65222: PPUSH
65223: PPUSH
65224: PPUSH
65225: PPUSH
65226: PPUSH
65227: PPUSH
65228: PPUSH
65229: PPUSH
65230: PPUSH
65231: PPUSH
65232: PPUSH
65233: PPUSH
65234: PPUSH
65235: PPUSH
65236: PPUSH
65237: PPUSH
65238: PPUSH
65239: PPUSH
65240: PPUSH
65241: PPUSH
65242: PPUSH
65243: PPUSH
65244: PPUSH
65245: PPUSH
65246: PPUSH
65247: PPUSH
65248: PPUSH
65249: PPUSH
65250: PPUSH
65251: PPUSH
65252: PPUSH
65253: PPUSH
65254: PPUSH
65255: PPUSH
65256: PPUSH
65257: PPUSH
65258: PPUSH
65259: PPUSH
// result = [ ] ;
65260: LD_ADDR_VAR 0 7
65264: PUSH
65265: EMPTY
65266: ST_TO_ADDR
// temp_list = [ ] ;
65267: LD_ADDR_VAR 0 9
65271: PUSH
65272: EMPTY
65273: ST_TO_ADDR
// if not dir in [ 0 , 1 , 2 , 3 , 4 , 5 ] or ( btype in [ b_depot , b_warehouse ] and not nation in [ nation_american , nation_arabian , nation_russian ] ) then
65274: LD_VAR 0 4
65278: PUSH
65279: LD_INT 0
65281: PUSH
65282: LD_INT 1
65284: PUSH
65285: LD_INT 2
65287: PUSH
65288: LD_INT 3
65290: PUSH
65291: LD_INT 4
65293: PUSH
65294: LD_INT 5
65296: PUSH
65297: EMPTY
65298: LIST
65299: LIST
65300: LIST
65301: LIST
65302: LIST
65303: LIST
65304: IN
65305: NOT
65306: PUSH
65307: LD_VAR 0 1
65311: PUSH
65312: LD_INT 0
65314: PUSH
65315: LD_INT 1
65317: PUSH
65318: EMPTY
65319: LIST
65320: LIST
65321: IN
65322: PUSH
65323: LD_VAR 0 5
65327: PUSH
65328: LD_INT 1
65330: PUSH
65331: LD_INT 2
65333: PUSH
65334: LD_INT 3
65336: PUSH
65337: EMPTY
65338: LIST
65339: LIST
65340: LIST
65341: IN
65342: NOT
65343: AND
65344: OR
65345: IFFALSE 65349
// exit ;
65347: GO 83740
// if btype in [ b_lab , b_lab_half , b_lab_full , b_lab_biological , b_lab_computer , b_lab_opto , b_lab_siberium , b_lab_spacetime , b_lab_weapon ] then
65349: LD_VAR 0 1
65353: PUSH
65354: LD_INT 6
65356: PUSH
65357: LD_INT 7
65359: PUSH
65360: LD_INT 8
65362: PUSH
65363: LD_INT 13
65365: PUSH
65366: LD_INT 12
65368: PUSH
65369: LD_INT 15
65371: PUSH
65372: LD_INT 11
65374: PUSH
65375: LD_INT 14
65377: PUSH
65378: LD_INT 10
65380: PUSH
65381: EMPTY
65382: LIST
65383: LIST
65384: LIST
65385: LIST
65386: LIST
65387: LIST
65388: LIST
65389: LIST
65390: LIST
65391: IN
65392: IFFALSE 65402
// btype = b_lab ;
65394: LD_ADDR_VAR 0 1
65398: PUSH
65399: LD_INT 6
65401: ST_TO_ADDR
// if not mode in [ 0 , 1 , 2 ] or ( not btype in [ b_depot , b_warehouse , b_workshop , b_factory , b_lab , b_control_tower , b_armoury , b_barracks , b_breastwork , b_bunker , b_turret ] and mode = 1 ) or ( not btype in [ b_workshop , b_factory ] and mode = 2 ) then
65402: LD_VAR 0 6
65406: PUSH
65407: LD_INT 0
65409: PUSH
65410: LD_INT 1
65412: PUSH
65413: LD_INT 2
65415: PUSH
65416: EMPTY
65417: LIST
65418: LIST
65419: LIST
65420: IN
65421: NOT
65422: PUSH
65423: LD_VAR 0 1
65427: PUSH
65428: LD_INT 0
65430: PUSH
65431: LD_INT 1
65433: PUSH
65434: LD_INT 2
65436: PUSH
65437: LD_INT 3
65439: PUSH
65440: LD_INT 6
65442: PUSH
65443: LD_INT 36
65445: PUSH
65446: LD_INT 4
65448: PUSH
65449: LD_INT 5
65451: PUSH
65452: LD_INT 31
65454: PUSH
65455: LD_INT 32
65457: PUSH
65458: LD_INT 33
65460: PUSH
65461: EMPTY
65462: LIST
65463: LIST
65464: LIST
65465: LIST
65466: LIST
65467: LIST
65468: LIST
65469: LIST
65470: LIST
65471: LIST
65472: LIST
65473: IN
65474: NOT
65475: PUSH
65476: LD_VAR 0 6
65480: PUSH
65481: LD_INT 1
65483: EQUAL
65484: AND
65485: OR
65486: PUSH
65487: LD_VAR 0 1
65491: PUSH
65492: LD_INT 2
65494: PUSH
65495: LD_INT 3
65497: PUSH
65498: EMPTY
65499: LIST
65500: LIST
65501: IN
65502: NOT
65503: PUSH
65504: LD_VAR 0 6
65508: PUSH
65509: LD_INT 2
65511: EQUAL
65512: AND
65513: OR
65514: IFFALSE 65524
// mode = 0 ;
65516: LD_ADDR_VAR 0 6
65520: PUSH
65521: LD_INT 0
65523: ST_TO_ADDR
// case mode of 0 :
65524: LD_VAR 0 6
65528: PUSH
65529: LD_INT 0
65531: DOUBLE
65532: EQUAL
65533: IFTRUE 65537
65535: GO 76990
65537: POP
// begin DepotAm0 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ 1 , 3 ] , [ 0 , 3 ] , [ - 1 , 2 ] ] ;
65538: LD_ADDR_VAR 0 11
65542: PUSH
65543: LD_INT 0
65545: PUSH
65546: LD_INT 0
65548: PUSH
65549: EMPTY
65550: LIST
65551: LIST
65552: PUSH
65553: LD_INT 0
65555: PUSH
65556: LD_INT 1
65558: NEG
65559: PUSH
65560: EMPTY
65561: LIST
65562: LIST
65563: PUSH
65564: LD_INT 1
65566: PUSH
65567: LD_INT 0
65569: PUSH
65570: EMPTY
65571: LIST
65572: LIST
65573: PUSH
65574: LD_INT 1
65576: PUSH
65577: LD_INT 1
65579: PUSH
65580: EMPTY
65581: LIST
65582: LIST
65583: PUSH
65584: LD_INT 0
65586: PUSH
65587: LD_INT 1
65589: PUSH
65590: EMPTY
65591: LIST
65592: LIST
65593: PUSH
65594: LD_INT 1
65596: NEG
65597: PUSH
65598: LD_INT 0
65600: PUSH
65601: EMPTY
65602: LIST
65603: LIST
65604: PUSH
65605: LD_INT 1
65607: NEG
65608: PUSH
65609: LD_INT 1
65611: NEG
65612: PUSH
65613: EMPTY
65614: LIST
65615: LIST
65616: PUSH
65617: LD_INT 1
65619: NEG
65620: PUSH
65621: LD_INT 2
65623: NEG
65624: PUSH
65625: EMPTY
65626: LIST
65627: LIST
65628: PUSH
65629: LD_INT 0
65631: PUSH
65632: LD_INT 2
65634: NEG
65635: PUSH
65636: EMPTY
65637: LIST
65638: LIST
65639: PUSH
65640: LD_INT 1
65642: PUSH
65643: LD_INT 1
65645: NEG
65646: PUSH
65647: EMPTY
65648: LIST
65649: LIST
65650: PUSH
65651: LD_INT 1
65653: PUSH
65654: LD_INT 2
65656: PUSH
65657: EMPTY
65658: LIST
65659: LIST
65660: PUSH
65661: LD_INT 0
65663: PUSH
65664: LD_INT 2
65666: PUSH
65667: EMPTY
65668: LIST
65669: LIST
65670: PUSH
65671: LD_INT 1
65673: NEG
65674: PUSH
65675: LD_INT 1
65677: PUSH
65678: EMPTY
65679: LIST
65680: LIST
65681: PUSH
65682: LD_INT 1
65684: PUSH
65685: LD_INT 3
65687: PUSH
65688: EMPTY
65689: LIST
65690: LIST
65691: PUSH
65692: LD_INT 0
65694: PUSH
65695: LD_INT 3
65697: PUSH
65698: EMPTY
65699: LIST
65700: LIST
65701: PUSH
65702: LD_INT 1
65704: NEG
65705: PUSH
65706: LD_INT 2
65708: PUSH
65709: EMPTY
65710: LIST
65711: LIST
65712: PUSH
65713: EMPTY
65714: LIST
65715: LIST
65716: LIST
65717: LIST
65718: LIST
65719: LIST
65720: LIST
65721: LIST
65722: LIST
65723: LIST
65724: LIST
65725: LIST
65726: LIST
65727: LIST
65728: LIST
65729: LIST
65730: ST_TO_ADDR
// DepotAm1 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , 1 ] , [ - 3 , 0 ] , [ - 3 , - 1 ] ] ;
65731: LD_ADDR_VAR 0 12
65735: PUSH
65736: LD_INT 0
65738: PUSH
65739: LD_INT 0
65741: PUSH
65742: EMPTY
65743: LIST
65744: LIST
65745: PUSH
65746: LD_INT 0
65748: PUSH
65749: LD_INT 1
65751: NEG
65752: PUSH
65753: EMPTY
65754: LIST
65755: LIST
65756: PUSH
65757: LD_INT 1
65759: PUSH
65760: LD_INT 0
65762: PUSH
65763: EMPTY
65764: LIST
65765: LIST
65766: PUSH
65767: LD_INT 1
65769: PUSH
65770: LD_INT 1
65772: PUSH
65773: EMPTY
65774: LIST
65775: LIST
65776: PUSH
65777: LD_INT 0
65779: PUSH
65780: LD_INT 1
65782: PUSH
65783: EMPTY
65784: LIST
65785: LIST
65786: PUSH
65787: LD_INT 1
65789: NEG
65790: PUSH
65791: LD_INT 0
65793: PUSH
65794: EMPTY
65795: LIST
65796: LIST
65797: PUSH
65798: LD_INT 1
65800: NEG
65801: PUSH
65802: LD_INT 1
65804: NEG
65805: PUSH
65806: EMPTY
65807: LIST
65808: LIST
65809: PUSH
65810: LD_INT 1
65812: PUSH
65813: LD_INT 1
65815: NEG
65816: PUSH
65817: EMPTY
65818: LIST
65819: LIST
65820: PUSH
65821: LD_INT 2
65823: PUSH
65824: LD_INT 0
65826: PUSH
65827: EMPTY
65828: LIST
65829: LIST
65830: PUSH
65831: LD_INT 2
65833: PUSH
65834: LD_INT 1
65836: PUSH
65837: EMPTY
65838: LIST
65839: LIST
65840: PUSH
65841: LD_INT 1
65843: NEG
65844: PUSH
65845: LD_INT 1
65847: PUSH
65848: EMPTY
65849: LIST
65850: LIST
65851: PUSH
65852: LD_INT 2
65854: NEG
65855: PUSH
65856: LD_INT 0
65858: PUSH
65859: EMPTY
65860: LIST
65861: LIST
65862: PUSH
65863: LD_INT 2
65865: NEG
65866: PUSH
65867: LD_INT 1
65869: NEG
65870: PUSH
65871: EMPTY
65872: LIST
65873: LIST
65874: PUSH
65875: LD_INT 2
65877: NEG
65878: PUSH
65879: LD_INT 1
65881: PUSH
65882: EMPTY
65883: LIST
65884: LIST
65885: PUSH
65886: LD_INT 3
65888: NEG
65889: PUSH
65890: LD_INT 0
65892: PUSH
65893: EMPTY
65894: LIST
65895: LIST
65896: PUSH
65897: LD_INT 3
65899: NEG
65900: PUSH
65901: LD_INT 1
65903: NEG
65904: PUSH
65905: EMPTY
65906: LIST
65907: LIST
65908: PUSH
65909: EMPTY
65910: LIST
65911: LIST
65912: LIST
65913: LIST
65914: LIST
65915: LIST
65916: LIST
65917: LIST
65918: LIST
65919: LIST
65920: LIST
65921: LIST
65922: LIST
65923: LIST
65924: LIST
65925: LIST
65926: ST_TO_ADDR
// DepotAm2 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ - 2 , - 3 ] , [ - 3 , - 2 ] , [ - 3 , - 3 ] ] ;
65927: LD_ADDR_VAR 0 13
65931: PUSH
65932: LD_INT 0
65934: PUSH
65935: LD_INT 0
65937: PUSH
65938: EMPTY
65939: LIST
65940: LIST
65941: PUSH
65942: LD_INT 0
65944: PUSH
65945: LD_INT 1
65947: NEG
65948: PUSH
65949: EMPTY
65950: LIST
65951: LIST
65952: PUSH
65953: LD_INT 1
65955: PUSH
65956: LD_INT 0
65958: PUSH
65959: EMPTY
65960: LIST
65961: LIST
65962: PUSH
65963: LD_INT 1
65965: PUSH
65966: LD_INT 1
65968: PUSH
65969: EMPTY
65970: LIST
65971: LIST
65972: PUSH
65973: LD_INT 0
65975: PUSH
65976: LD_INT 1
65978: PUSH
65979: EMPTY
65980: LIST
65981: LIST
65982: PUSH
65983: LD_INT 1
65985: NEG
65986: PUSH
65987: LD_INT 0
65989: PUSH
65990: EMPTY
65991: LIST
65992: LIST
65993: PUSH
65994: LD_INT 1
65996: NEG
65997: PUSH
65998: LD_INT 1
66000: NEG
66001: PUSH
66002: EMPTY
66003: LIST
66004: LIST
66005: PUSH
66006: LD_INT 1
66008: NEG
66009: PUSH
66010: LD_INT 2
66012: NEG
66013: PUSH
66014: EMPTY
66015: LIST
66016: LIST
66017: PUSH
66018: LD_INT 2
66020: PUSH
66021: LD_INT 1
66023: PUSH
66024: EMPTY
66025: LIST
66026: LIST
66027: PUSH
66028: LD_INT 2
66030: PUSH
66031: LD_INT 2
66033: PUSH
66034: EMPTY
66035: LIST
66036: LIST
66037: PUSH
66038: LD_INT 1
66040: PUSH
66041: LD_INT 2
66043: PUSH
66044: EMPTY
66045: LIST
66046: LIST
66047: PUSH
66048: LD_INT 2
66050: NEG
66051: PUSH
66052: LD_INT 1
66054: NEG
66055: PUSH
66056: EMPTY
66057: LIST
66058: LIST
66059: PUSH
66060: LD_INT 2
66062: NEG
66063: PUSH
66064: LD_INT 2
66066: NEG
66067: PUSH
66068: EMPTY
66069: LIST
66070: LIST
66071: PUSH
66072: LD_INT 2
66074: NEG
66075: PUSH
66076: LD_INT 3
66078: NEG
66079: PUSH
66080: EMPTY
66081: LIST
66082: LIST
66083: PUSH
66084: LD_INT 3
66086: NEG
66087: PUSH
66088: LD_INT 2
66090: NEG
66091: PUSH
66092: EMPTY
66093: LIST
66094: LIST
66095: PUSH
66096: LD_INT 3
66098: NEG
66099: PUSH
66100: LD_INT 3
66102: NEG
66103: PUSH
66104: EMPTY
66105: LIST
66106: LIST
66107: PUSH
66108: EMPTY
66109: LIST
66110: LIST
66111: LIST
66112: LIST
66113: LIST
66114: LIST
66115: LIST
66116: LIST
66117: LIST
66118: LIST
66119: LIST
66120: LIST
66121: LIST
66122: LIST
66123: LIST
66124: LIST
66125: ST_TO_ADDR
// DepotAm3 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 1 , - 3 ] , [ 0 , - 3 ] , [ 1 , - 2 ] ] ;
66126: LD_ADDR_VAR 0 14
66130: PUSH
66131: LD_INT 0
66133: PUSH
66134: LD_INT 0
66136: PUSH
66137: EMPTY
66138: LIST
66139: LIST
66140: PUSH
66141: LD_INT 0
66143: PUSH
66144: LD_INT 1
66146: NEG
66147: PUSH
66148: EMPTY
66149: LIST
66150: LIST
66151: PUSH
66152: LD_INT 1
66154: PUSH
66155: LD_INT 0
66157: PUSH
66158: EMPTY
66159: LIST
66160: LIST
66161: PUSH
66162: LD_INT 1
66164: PUSH
66165: LD_INT 1
66167: PUSH
66168: EMPTY
66169: LIST
66170: LIST
66171: PUSH
66172: LD_INT 0
66174: PUSH
66175: LD_INT 1
66177: PUSH
66178: EMPTY
66179: LIST
66180: LIST
66181: PUSH
66182: LD_INT 1
66184: NEG
66185: PUSH
66186: LD_INT 0
66188: PUSH
66189: EMPTY
66190: LIST
66191: LIST
66192: PUSH
66193: LD_INT 1
66195: NEG
66196: PUSH
66197: LD_INT 1
66199: NEG
66200: PUSH
66201: EMPTY
66202: LIST
66203: LIST
66204: PUSH
66205: LD_INT 1
66207: NEG
66208: PUSH
66209: LD_INT 2
66211: NEG
66212: PUSH
66213: EMPTY
66214: LIST
66215: LIST
66216: PUSH
66217: LD_INT 0
66219: PUSH
66220: LD_INT 2
66222: NEG
66223: PUSH
66224: EMPTY
66225: LIST
66226: LIST
66227: PUSH
66228: LD_INT 1
66230: PUSH
66231: LD_INT 1
66233: NEG
66234: PUSH
66235: EMPTY
66236: LIST
66237: LIST
66238: PUSH
66239: LD_INT 1
66241: PUSH
66242: LD_INT 2
66244: PUSH
66245: EMPTY
66246: LIST
66247: LIST
66248: PUSH
66249: LD_INT 0
66251: PUSH
66252: LD_INT 2
66254: PUSH
66255: EMPTY
66256: LIST
66257: LIST
66258: PUSH
66259: LD_INT 1
66261: NEG
66262: PUSH
66263: LD_INT 1
66265: PUSH
66266: EMPTY
66267: LIST
66268: LIST
66269: PUSH
66270: LD_INT 1
66272: NEG
66273: PUSH
66274: LD_INT 3
66276: NEG
66277: PUSH
66278: EMPTY
66279: LIST
66280: LIST
66281: PUSH
66282: LD_INT 0
66284: PUSH
66285: LD_INT 3
66287: NEG
66288: PUSH
66289: EMPTY
66290: LIST
66291: LIST
66292: PUSH
66293: LD_INT 1
66295: PUSH
66296: LD_INT 2
66298: NEG
66299: PUSH
66300: EMPTY
66301: LIST
66302: LIST
66303: PUSH
66304: EMPTY
66305: LIST
66306: LIST
66307: LIST
66308: LIST
66309: LIST
66310: LIST
66311: LIST
66312: LIST
66313: LIST
66314: LIST
66315: LIST
66316: LIST
66317: LIST
66318: LIST
66319: LIST
66320: LIST
66321: ST_TO_ADDR
// DepotAm4 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ 2 , - 1 ] , [ 3 , 0 ] , [ 3 , 1 ] ] ;
66322: LD_ADDR_VAR 0 15
66326: PUSH
66327: LD_INT 0
66329: PUSH
66330: LD_INT 0
66332: PUSH
66333: EMPTY
66334: LIST
66335: LIST
66336: PUSH
66337: LD_INT 0
66339: PUSH
66340: LD_INT 1
66342: NEG
66343: PUSH
66344: EMPTY
66345: LIST
66346: LIST
66347: PUSH
66348: LD_INT 1
66350: PUSH
66351: LD_INT 0
66353: PUSH
66354: EMPTY
66355: LIST
66356: LIST
66357: PUSH
66358: LD_INT 1
66360: PUSH
66361: LD_INT 1
66363: PUSH
66364: EMPTY
66365: LIST
66366: LIST
66367: PUSH
66368: LD_INT 0
66370: PUSH
66371: LD_INT 1
66373: PUSH
66374: EMPTY
66375: LIST
66376: LIST
66377: PUSH
66378: LD_INT 1
66380: NEG
66381: PUSH
66382: LD_INT 0
66384: PUSH
66385: EMPTY
66386: LIST
66387: LIST
66388: PUSH
66389: LD_INT 1
66391: NEG
66392: PUSH
66393: LD_INT 1
66395: NEG
66396: PUSH
66397: EMPTY
66398: LIST
66399: LIST
66400: PUSH
66401: LD_INT 1
66403: PUSH
66404: LD_INT 1
66406: NEG
66407: PUSH
66408: EMPTY
66409: LIST
66410: LIST
66411: PUSH
66412: LD_INT 2
66414: PUSH
66415: LD_INT 0
66417: PUSH
66418: EMPTY
66419: LIST
66420: LIST
66421: PUSH
66422: LD_INT 2
66424: PUSH
66425: LD_INT 1
66427: PUSH
66428: EMPTY
66429: LIST
66430: LIST
66431: PUSH
66432: LD_INT 1
66434: NEG
66435: PUSH
66436: LD_INT 1
66438: PUSH
66439: EMPTY
66440: LIST
66441: LIST
66442: PUSH
66443: LD_INT 2
66445: NEG
66446: PUSH
66447: LD_INT 0
66449: PUSH
66450: EMPTY
66451: LIST
66452: LIST
66453: PUSH
66454: LD_INT 2
66456: NEG
66457: PUSH
66458: LD_INT 1
66460: NEG
66461: PUSH
66462: EMPTY
66463: LIST
66464: LIST
66465: PUSH
66466: LD_INT 2
66468: PUSH
66469: LD_INT 1
66471: NEG
66472: PUSH
66473: EMPTY
66474: LIST
66475: LIST
66476: PUSH
66477: LD_INT 3
66479: PUSH
66480: LD_INT 0
66482: PUSH
66483: EMPTY
66484: LIST
66485: LIST
66486: PUSH
66487: LD_INT 3
66489: PUSH
66490: LD_INT 1
66492: PUSH
66493: EMPTY
66494: LIST
66495: LIST
66496: PUSH
66497: EMPTY
66498: LIST
66499: LIST
66500: LIST
66501: LIST
66502: LIST
66503: LIST
66504: LIST
66505: LIST
66506: LIST
66507: LIST
66508: LIST
66509: LIST
66510: LIST
66511: LIST
66512: LIST
66513: LIST
66514: ST_TO_ADDR
// DepotAm5 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ 3 , 2 ] , [ 3 , 3 ] , [ 2 , 3 ] ] ;
66515: LD_ADDR_VAR 0 16
66519: PUSH
66520: LD_INT 0
66522: PUSH
66523: LD_INT 0
66525: PUSH
66526: EMPTY
66527: LIST
66528: LIST
66529: PUSH
66530: LD_INT 0
66532: PUSH
66533: LD_INT 1
66535: NEG
66536: PUSH
66537: EMPTY
66538: LIST
66539: LIST
66540: PUSH
66541: LD_INT 1
66543: PUSH
66544: LD_INT 0
66546: PUSH
66547: EMPTY
66548: LIST
66549: LIST
66550: PUSH
66551: LD_INT 1
66553: PUSH
66554: LD_INT 1
66556: PUSH
66557: EMPTY
66558: LIST
66559: LIST
66560: PUSH
66561: LD_INT 0
66563: PUSH
66564: LD_INT 1
66566: PUSH
66567: EMPTY
66568: LIST
66569: LIST
66570: PUSH
66571: LD_INT 1
66573: NEG
66574: PUSH
66575: LD_INT 0
66577: PUSH
66578: EMPTY
66579: LIST
66580: LIST
66581: PUSH
66582: LD_INT 1
66584: NEG
66585: PUSH
66586: LD_INT 1
66588: NEG
66589: PUSH
66590: EMPTY
66591: LIST
66592: LIST
66593: PUSH
66594: LD_INT 1
66596: NEG
66597: PUSH
66598: LD_INT 2
66600: NEG
66601: PUSH
66602: EMPTY
66603: LIST
66604: LIST
66605: PUSH
66606: LD_INT 2
66608: PUSH
66609: LD_INT 1
66611: PUSH
66612: EMPTY
66613: LIST
66614: LIST
66615: PUSH
66616: LD_INT 2
66618: PUSH
66619: LD_INT 2
66621: PUSH
66622: EMPTY
66623: LIST
66624: LIST
66625: PUSH
66626: LD_INT 1
66628: PUSH
66629: LD_INT 2
66631: PUSH
66632: EMPTY
66633: LIST
66634: LIST
66635: PUSH
66636: LD_INT 2
66638: NEG
66639: PUSH
66640: LD_INT 1
66642: NEG
66643: PUSH
66644: EMPTY
66645: LIST
66646: LIST
66647: PUSH
66648: LD_INT 2
66650: NEG
66651: PUSH
66652: LD_INT 2
66654: NEG
66655: PUSH
66656: EMPTY
66657: LIST
66658: LIST
66659: PUSH
66660: LD_INT 3
66662: PUSH
66663: LD_INT 2
66665: PUSH
66666: EMPTY
66667: LIST
66668: LIST
66669: PUSH
66670: LD_INT 3
66672: PUSH
66673: LD_INT 3
66675: PUSH
66676: EMPTY
66677: LIST
66678: LIST
66679: PUSH
66680: LD_INT 2
66682: PUSH
66683: LD_INT 3
66685: PUSH
66686: EMPTY
66687: LIST
66688: LIST
66689: PUSH
66690: EMPTY
66691: LIST
66692: LIST
66693: LIST
66694: LIST
66695: LIST
66696: LIST
66697: LIST
66698: LIST
66699: LIST
66700: LIST
66701: LIST
66702: LIST
66703: LIST
66704: LIST
66705: LIST
66706: LIST
66707: ST_TO_ADDR
// DepotAr0 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
66708: LD_ADDR_VAR 0 17
66712: PUSH
66713: LD_INT 0
66715: PUSH
66716: LD_INT 0
66718: PUSH
66719: EMPTY
66720: LIST
66721: LIST
66722: PUSH
66723: LD_INT 0
66725: PUSH
66726: LD_INT 1
66728: NEG
66729: PUSH
66730: EMPTY
66731: LIST
66732: LIST
66733: PUSH
66734: LD_INT 1
66736: PUSH
66737: LD_INT 0
66739: PUSH
66740: EMPTY
66741: LIST
66742: LIST
66743: PUSH
66744: LD_INT 1
66746: PUSH
66747: LD_INT 1
66749: PUSH
66750: EMPTY
66751: LIST
66752: LIST
66753: PUSH
66754: LD_INT 0
66756: PUSH
66757: LD_INT 1
66759: PUSH
66760: EMPTY
66761: LIST
66762: LIST
66763: PUSH
66764: LD_INT 1
66766: NEG
66767: PUSH
66768: LD_INT 0
66770: PUSH
66771: EMPTY
66772: LIST
66773: LIST
66774: PUSH
66775: LD_INT 1
66777: NEG
66778: PUSH
66779: LD_INT 1
66781: NEG
66782: PUSH
66783: EMPTY
66784: LIST
66785: LIST
66786: PUSH
66787: LD_INT 1
66789: NEG
66790: PUSH
66791: LD_INT 2
66793: NEG
66794: PUSH
66795: EMPTY
66796: LIST
66797: LIST
66798: PUSH
66799: LD_INT 0
66801: PUSH
66802: LD_INT 2
66804: NEG
66805: PUSH
66806: EMPTY
66807: LIST
66808: LIST
66809: PUSH
66810: LD_INT 1
66812: PUSH
66813: LD_INT 1
66815: NEG
66816: PUSH
66817: EMPTY
66818: LIST
66819: LIST
66820: PUSH
66821: LD_INT 2
66823: PUSH
66824: LD_INT 0
66826: PUSH
66827: EMPTY
66828: LIST
66829: LIST
66830: PUSH
66831: LD_INT 2
66833: PUSH
66834: LD_INT 1
66836: PUSH
66837: EMPTY
66838: LIST
66839: LIST
66840: PUSH
66841: LD_INT 2
66843: PUSH
66844: LD_INT 2
66846: PUSH
66847: EMPTY
66848: LIST
66849: LIST
66850: PUSH
66851: LD_INT 1
66853: PUSH
66854: LD_INT 2
66856: PUSH
66857: EMPTY
66858: LIST
66859: LIST
66860: PUSH
66861: LD_INT 0
66863: PUSH
66864: LD_INT 2
66866: PUSH
66867: EMPTY
66868: LIST
66869: LIST
66870: PUSH
66871: LD_INT 1
66873: NEG
66874: PUSH
66875: LD_INT 1
66877: PUSH
66878: EMPTY
66879: LIST
66880: LIST
66881: PUSH
66882: LD_INT 2
66884: NEG
66885: PUSH
66886: LD_INT 0
66888: PUSH
66889: EMPTY
66890: LIST
66891: LIST
66892: PUSH
66893: LD_INT 2
66895: NEG
66896: PUSH
66897: LD_INT 1
66899: NEG
66900: PUSH
66901: EMPTY
66902: LIST
66903: LIST
66904: PUSH
66905: LD_INT 2
66907: NEG
66908: PUSH
66909: LD_INT 2
66911: NEG
66912: PUSH
66913: EMPTY
66914: LIST
66915: LIST
66916: PUSH
66917: EMPTY
66918: LIST
66919: LIST
66920: LIST
66921: LIST
66922: LIST
66923: LIST
66924: LIST
66925: LIST
66926: LIST
66927: LIST
66928: LIST
66929: LIST
66930: LIST
66931: LIST
66932: LIST
66933: LIST
66934: LIST
66935: LIST
66936: LIST
66937: ST_TO_ADDR
// DepotAr1 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
66938: LD_ADDR_VAR 0 18
66942: PUSH
66943: LD_INT 0
66945: PUSH
66946: LD_INT 0
66948: PUSH
66949: EMPTY
66950: LIST
66951: LIST
66952: PUSH
66953: LD_INT 0
66955: PUSH
66956: LD_INT 1
66958: NEG
66959: PUSH
66960: EMPTY
66961: LIST
66962: LIST
66963: PUSH
66964: LD_INT 1
66966: PUSH
66967: LD_INT 0
66969: PUSH
66970: EMPTY
66971: LIST
66972: LIST
66973: PUSH
66974: LD_INT 1
66976: PUSH
66977: LD_INT 1
66979: PUSH
66980: EMPTY
66981: LIST
66982: LIST
66983: PUSH
66984: LD_INT 0
66986: PUSH
66987: LD_INT 1
66989: PUSH
66990: EMPTY
66991: LIST
66992: LIST
66993: PUSH
66994: LD_INT 1
66996: NEG
66997: PUSH
66998: LD_INT 0
67000: PUSH
67001: EMPTY
67002: LIST
67003: LIST
67004: PUSH
67005: LD_INT 1
67007: NEG
67008: PUSH
67009: LD_INT 1
67011: NEG
67012: PUSH
67013: EMPTY
67014: LIST
67015: LIST
67016: PUSH
67017: LD_INT 1
67019: NEG
67020: PUSH
67021: LD_INT 2
67023: NEG
67024: PUSH
67025: EMPTY
67026: LIST
67027: LIST
67028: PUSH
67029: LD_INT 0
67031: PUSH
67032: LD_INT 2
67034: NEG
67035: PUSH
67036: EMPTY
67037: LIST
67038: LIST
67039: PUSH
67040: LD_INT 1
67042: PUSH
67043: LD_INT 1
67045: NEG
67046: PUSH
67047: EMPTY
67048: LIST
67049: LIST
67050: PUSH
67051: LD_INT 2
67053: PUSH
67054: LD_INT 0
67056: PUSH
67057: EMPTY
67058: LIST
67059: LIST
67060: PUSH
67061: LD_INT 2
67063: PUSH
67064: LD_INT 1
67066: PUSH
67067: EMPTY
67068: LIST
67069: LIST
67070: PUSH
67071: LD_INT 2
67073: PUSH
67074: LD_INT 2
67076: PUSH
67077: EMPTY
67078: LIST
67079: LIST
67080: PUSH
67081: LD_INT 1
67083: PUSH
67084: LD_INT 2
67086: PUSH
67087: EMPTY
67088: LIST
67089: LIST
67090: PUSH
67091: LD_INT 0
67093: PUSH
67094: LD_INT 2
67096: PUSH
67097: EMPTY
67098: LIST
67099: LIST
67100: PUSH
67101: LD_INT 1
67103: NEG
67104: PUSH
67105: LD_INT 1
67107: PUSH
67108: EMPTY
67109: LIST
67110: LIST
67111: PUSH
67112: LD_INT 2
67114: NEG
67115: PUSH
67116: LD_INT 0
67118: PUSH
67119: EMPTY
67120: LIST
67121: LIST
67122: PUSH
67123: LD_INT 2
67125: NEG
67126: PUSH
67127: LD_INT 1
67129: NEG
67130: PUSH
67131: EMPTY
67132: LIST
67133: LIST
67134: PUSH
67135: LD_INT 2
67137: NEG
67138: PUSH
67139: LD_INT 2
67141: NEG
67142: PUSH
67143: EMPTY
67144: LIST
67145: LIST
67146: PUSH
67147: EMPTY
67148: LIST
67149: LIST
67150: LIST
67151: LIST
67152: LIST
67153: LIST
67154: LIST
67155: LIST
67156: LIST
67157: LIST
67158: LIST
67159: LIST
67160: LIST
67161: LIST
67162: LIST
67163: LIST
67164: LIST
67165: LIST
67166: LIST
67167: ST_TO_ADDR
// DepotAr2 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
67168: LD_ADDR_VAR 0 19
67172: PUSH
67173: LD_INT 0
67175: PUSH
67176: LD_INT 0
67178: PUSH
67179: EMPTY
67180: LIST
67181: LIST
67182: PUSH
67183: LD_INT 0
67185: PUSH
67186: LD_INT 1
67188: NEG
67189: PUSH
67190: EMPTY
67191: LIST
67192: LIST
67193: PUSH
67194: LD_INT 1
67196: PUSH
67197: LD_INT 0
67199: PUSH
67200: EMPTY
67201: LIST
67202: LIST
67203: PUSH
67204: LD_INT 1
67206: PUSH
67207: LD_INT 1
67209: PUSH
67210: EMPTY
67211: LIST
67212: LIST
67213: PUSH
67214: LD_INT 0
67216: PUSH
67217: LD_INT 1
67219: PUSH
67220: EMPTY
67221: LIST
67222: LIST
67223: PUSH
67224: LD_INT 1
67226: NEG
67227: PUSH
67228: LD_INT 0
67230: PUSH
67231: EMPTY
67232: LIST
67233: LIST
67234: PUSH
67235: LD_INT 1
67237: NEG
67238: PUSH
67239: LD_INT 1
67241: NEG
67242: PUSH
67243: EMPTY
67244: LIST
67245: LIST
67246: PUSH
67247: LD_INT 1
67249: NEG
67250: PUSH
67251: LD_INT 2
67253: NEG
67254: PUSH
67255: EMPTY
67256: LIST
67257: LIST
67258: PUSH
67259: LD_INT 0
67261: PUSH
67262: LD_INT 2
67264: NEG
67265: PUSH
67266: EMPTY
67267: LIST
67268: LIST
67269: PUSH
67270: LD_INT 1
67272: PUSH
67273: LD_INT 1
67275: NEG
67276: PUSH
67277: EMPTY
67278: LIST
67279: LIST
67280: PUSH
67281: LD_INT 2
67283: PUSH
67284: LD_INT 0
67286: PUSH
67287: EMPTY
67288: LIST
67289: LIST
67290: PUSH
67291: LD_INT 2
67293: PUSH
67294: LD_INT 1
67296: PUSH
67297: EMPTY
67298: LIST
67299: LIST
67300: PUSH
67301: LD_INT 2
67303: PUSH
67304: LD_INT 2
67306: PUSH
67307: EMPTY
67308: LIST
67309: LIST
67310: PUSH
67311: LD_INT 1
67313: PUSH
67314: LD_INT 2
67316: PUSH
67317: EMPTY
67318: LIST
67319: LIST
67320: PUSH
67321: LD_INT 0
67323: PUSH
67324: LD_INT 2
67326: PUSH
67327: EMPTY
67328: LIST
67329: LIST
67330: PUSH
67331: LD_INT 1
67333: NEG
67334: PUSH
67335: LD_INT 1
67337: PUSH
67338: EMPTY
67339: LIST
67340: LIST
67341: PUSH
67342: LD_INT 2
67344: NEG
67345: PUSH
67346: LD_INT 0
67348: PUSH
67349: EMPTY
67350: LIST
67351: LIST
67352: PUSH
67353: LD_INT 2
67355: NEG
67356: PUSH
67357: LD_INT 1
67359: NEG
67360: PUSH
67361: EMPTY
67362: LIST
67363: LIST
67364: PUSH
67365: LD_INT 2
67367: NEG
67368: PUSH
67369: LD_INT 2
67371: NEG
67372: PUSH
67373: EMPTY
67374: LIST
67375: LIST
67376: PUSH
67377: EMPTY
67378: LIST
67379: LIST
67380: LIST
67381: LIST
67382: LIST
67383: LIST
67384: LIST
67385: LIST
67386: LIST
67387: LIST
67388: LIST
67389: LIST
67390: LIST
67391: LIST
67392: LIST
67393: LIST
67394: LIST
67395: LIST
67396: LIST
67397: ST_TO_ADDR
// DepotAr3 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
67398: LD_ADDR_VAR 0 20
67402: PUSH
67403: LD_INT 0
67405: PUSH
67406: LD_INT 0
67408: PUSH
67409: EMPTY
67410: LIST
67411: LIST
67412: PUSH
67413: LD_INT 0
67415: PUSH
67416: LD_INT 1
67418: NEG
67419: PUSH
67420: EMPTY
67421: LIST
67422: LIST
67423: PUSH
67424: LD_INT 1
67426: PUSH
67427: LD_INT 0
67429: PUSH
67430: EMPTY
67431: LIST
67432: LIST
67433: PUSH
67434: LD_INT 1
67436: PUSH
67437: LD_INT 1
67439: PUSH
67440: EMPTY
67441: LIST
67442: LIST
67443: PUSH
67444: LD_INT 0
67446: PUSH
67447: LD_INT 1
67449: PUSH
67450: EMPTY
67451: LIST
67452: LIST
67453: PUSH
67454: LD_INT 1
67456: NEG
67457: PUSH
67458: LD_INT 0
67460: PUSH
67461: EMPTY
67462: LIST
67463: LIST
67464: PUSH
67465: LD_INT 1
67467: NEG
67468: PUSH
67469: LD_INT 1
67471: NEG
67472: PUSH
67473: EMPTY
67474: LIST
67475: LIST
67476: PUSH
67477: LD_INT 1
67479: NEG
67480: PUSH
67481: LD_INT 2
67483: NEG
67484: PUSH
67485: EMPTY
67486: LIST
67487: LIST
67488: PUSH
67489: LD_INT 0
67491: PUSH
67492: LD_INT 2
67494: NEG
67495: PUSH
67496: EMPTY
67497: LIST
67498: LIST
67499: PUSH
67500: LD_INT 1
67502: PUSH
67503: LD_INT 1
67505: NEG
67506: PUSH
67507: EMPTY
67508: LIST
67509: LIST
67510: PUSH
67511: LD_INT 2
67513: PUSH
67514: LD_INT 0
67516: PUSH
67517: EMPTY
67518: LIST
67519: LIST
67520: PUSH
67521: LD_INT 2
67523: PUSH
67524: LD_INT 1
67526: PUSH
67527: EMPTY
67528: LIST
67529: LIST
67530: PUSH
67531: LD_INT 2
67533: PUSH
67534: LD_INT 2
67536: PUSH
67537: EMPTY
67538: LIST
67539: LIST
67540: PUSH
67541: LD_INT 1
67543: PUSH
67544: LD_INT 2
67546: PUSH
67547: EMPTY
67548: LIST
67549: LIST
67550: PUSH
67551: LD_INT 0
67553: PUSH
67554: LD_INT 2
67556: PUSH
67557: EMPTY
67558: LIST
67559: LIST
67560: PUSH
67561: LD_INT 1
67563: NEG
67564: PUSH
67565: LD_INT 1
67567: PUSH
67568: EMPTY
67569: LIST
67570: LIST
67571: PUSH
67572: LD_INT 2
67574: NEG
67575: PUSH
67576: LD_INT 0
67578: PUSH
67579: EMPTY
67580: LIST
67581: LIST
67582: PUSH
67583: LD_INT 2
67585: NEG
67586: PUSH
67587: LD_INT 1
67589: NEG
67590: PUSH
67591: EMPTY
67592: LIST
67593: LIST
67594: PUSH
67595: LD_INT 2
67597: NEG
67598: PUSH
67599: LD_INT 2
67601: NEG
67602: PUSH
67603: EMPTY
67604: LIST
67605: LIST
67606: PUSH
67607: EMPTY
67608: LIST
67609: LIST
67610: LIST
67611: LIST
67612: LIST
67613: LIST
67614: LIST
67615: LIST
67616: LIST
67617: LIST
67618: LIST
67619: LIST
67620: LIST
67621: LIST
67622: LIST
67623: LIST
67624: LIST
67625: LIST
67626: LIST
67627: ST_TO_ADDR
// DepotAr4 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
67628: LD_ADDR_VAR 0 21
67632: PUSH
67633: LD_INT 0
67635: PUSH
67636: LD_INT 0
67638: PUSH
67639: EMPTY
67640: LIST
67641: LIST
67642: PUSH
67643: LD_INT 0
67645: PUSH
67646: LD_INT 1
67648: NEG
67649: PUSH
67650: EMPTY
67651: LIST
67652: LIST
67653: PUSH
67654: LD_INT 1
67656: PUSH
67657: LD_INT 0
67659: PUSH
67660: EMPTY
67661: LIST
67662: LIST
67663: PUSH
67664: LD_INT 1
67666: PUSH
67667: LD_INT 1
67669: PUSH
67670: EMPTY
67671: LIST
67672: LIST
67673: PUSH
67674: LD_INT 0
67676: PUSH
67677: LD_INT 1
67679: PUSH
67680: EMPTY
67681: LIST
67682: LIST
67683: PUSH
67684: LD_INT 1
67686: NEG
67687: PUSH
67688: LD_INT 0
67690: PUSH
67691: EMPTY
67692: LIST
67693: LIST
67694: PUSH
67695: LD_INT 1
67697: NEG
67698: PUSH
67699: LD_INT 1
67701: NEG
67702: PUSH
67703: EMPTY
67704: LIST
67705: LIST
67706: PUSH
67707: LD_INT 1
67709: NEG
67710: PUSH
67711: LD_INT 2
67713: NEG
67714: PUSH
67715: EMPTY
67716: LIST
67717: LIST
67718: PUSH
67719: LD_INT 0
67721: PUSH
67722: LD_INT 2
67724: NEG
67725: PUSH
67726: EMPTY
67727: LIST
67728: LIST
67729: PUSH
67730: LD_INT 1
67732: PUSH
67733: LD_INT 1
67735: NEG
67736: PUSH
67737: EMPTY
67738: LIST
67739: LIST
67740: PUSH
67741: LD_INT 2
67743: PUSH
67744: LD_INT 0
67746: PUSH
67747: EMPTY
67748: LIST
67749: LIST
67750: PUSH
67751: LD_INT 2
67753: PUSH
67754: LD_INT 1
67756: PUSH
67757: EMPTY
67758: LIST
67759: LIST
67760: PUSH
67761: LD_INT 2
67763: PUSH
67764: LD_INT 2
67766: PUSH
67767: EMPTY
67768: LIST
67769: LIST
67770: PUSH
67771: LD_INT 1
67773: PUSH
67774: LD_INT 2
67776: PUSH
67777: EMPTY
67778: LIST
67779: LIST
67780: PUSH
67781: LD_INT 0
67783: PUSH
67784: LD_INT 2
67786: PUSH
67787: EMPTY
67788: LIST
67789: LIST
67790: PUSH
67791: LD_INT 1
67793: NEG
67794: PUSH
67795: LD_INT 1
67797: PUSH
67798: EMPTY
67799: LIST
67800: LIST
67801: PUSH
67802: LD_INT 2
67804: NEG
67805: PUSH
67806: LD_INT 0
67808: PUSH
67809: EMPTY
67810: LIST
67811: LIST
67812: PUSH
67813: LD_INT 2
67815: NEG
67816: PUSH
67817: LD_INT 1
67819: NEG
67820: PUSH
67821: EMPTY
67822: LIST
67823: LIST
67824: PUSH
67825: LD_INT 2
67827: NEG
67828: PUSH
67829: LD_INT 2
67831: NEG
67832: PUSH
67833: EMPTY
67834: LIST
67835: LIST
67836: PUSH
67837: EMPTY
67838: LIST
67839: LIST
67840: LIST
67841: LIST
67842: LIST
67843: LIST
67844: LIST
67845: LIST
67846: LIST
67847: LIST
67848: LIST
67849: LIST
67850: LIST
67851: LIST
67852: LIST
67853: LIST
67854: LIST
67855: LIST
67856: LIST
67857: ST_TO_ADDR
// DepotAr5 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
67858: LD_ADDR_VAR 0 22
67862: PUSH
67863: LD_INT 0
67865: PUSH
67866: LD_INT 0
67868: PUSH
67869: EMPTY
67870: LIST
67871: LIST
67872: PUSH
67873: LD_INT 0
67875: PUSH
67876: LD_INT 1
67878: NEG
67879: PUSH
67880: EMPTY
67881: LIST
67882: LIST
67883: PUSH
67884: LD_INT 1
67886: PUSH
67887: LD_INT 0
67889: PUSH
67890: EMPTY
67891: LIST
67892: LIST
67893: PUSH
67894: LD_INT 1
67896: PUSH
67897: LD_INT 1
67899: PUSH
67900: EMPTY
67901: LIST
67902: LIST
67903: PUSH
67904: LD_INT 0
67906: PUSH
67907: LD_INT 1
67909: PUSH
67910: EMPTY
67911: LIST
67912: LIST
67913: PUSH
67914: LD_INT 1
67916: NEG
67917: PUSH
67918: LD_INT 0
67920: PUSH
67921: EMPTY
67922: LIST
67923: LIST
67924: PUSH
67925: LD_INT 1
67927: NEG
67928: PUSH
67929: LD_INT 1
67931: NEG
67932: PUSH
67933: EMPTY
67934: LIST
67935: LIST
67936: PUSH
67937: LD_INT 1
67939: NEG
67940: PUSH
67941: LD_INT 2
67943: NEG
67944: PUSH
67945: EMPTY
67946: LIST
67947: LIST
67948: PUSH
67949: LD_INT 0
67951: PUSH
67952: LD_INT 2
67954: NEG
67955: PUSH
67956: EMPTY
67957: LIST
67958: LIST
67959: PUSH
67960: LD_INT 1
67962: PUSH
67963: LD_INT 1
67965: NEG
67966: PUSH
67967: EMPTY
67968: LIST
67969: LIST
67970: PUSH
67971: LD_INT 2
67973: PUSH
67974: LD_INT 0
67976: PUSH
67977: EMPTY
67978: LIST
67979: LIST
67980: PUSH
67981: LD_INT 2
67983: PUSH
67984: LD_INT 1
67986: PUSH
67987: EMPTY
67988: LIST
67989: LIST
67990: PUSH
67991: LD_INT 2
67993: PUSH
67994: LD_INT 2
67996: PUSH
67997: EMPTY
67998: LIST
67999: LIST
68000: PUSH
68001: LD_INT 1
68003: PUSH
68004: LD_INT 2
68006: PUSH
68007: EMPTY
68008: LIST
68009: LIST
68010: PUSH
68011: LD_INT 0
68013: PUSH
68014: LD_INT 2
68016: PUSH
68017: EMPTY
68018: LIST
68019: LIST
68020: PUSH
68021: LD_INT 1
68023: NEG
68024: PUSH
68025: LD_INT 1
68027: PUSH
68028: EMPTY
68029: LIST
68030: LIST
68031: PUSH
68032: LD_INT 2
68034: NEG
68035: PUSH
68036: LD_INT 0
68038: PUSH
68039: EMPTY
68040: LIST
68041: LIST
68042: PUSH
68043: LD_INT 2
68045: NEG
68046: PUSH
68047: LD_INT 1
68049: NEG
68050: PUSH
68051: EMPTY
68052: LIST
68053: LIST
68054: PUSH
68055: LD_INT 2
68057: NEG
68058: PUSH
68059: LD_INT 2
68061: NEG
68062: PUSH
68063: EMPTY
68064: LIST
68065: LIST
68066: PUSH
68067: EMPTY
68068: LIST
68069: LIST
68070: LIST
68071: LIST
68072: LIST
68073: LIST
68074: LIST
68075: LIST
68076: LIST
68077: LIST
68078: LIST
68079: LIST
68080: LIST
68081: LIST
68082: LIST
68083: LIST
68084: LIST
68085: LIST
68086: LIST
68087: ST_TO_ADDR
// DepotRu0 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ - 2 , - 3 ] , [ - 1 , - 3 ] , [ 1 , - 2 ] , [ 2 , - 1 ] ] ;
68088: LD_ADDR_VAR 0 23
68092: PUSH
68093: LD_INT 0
68095: PUSH
68096: LD_INT 0
68098: PUSH
68099: EMPTY
68100: LIST
68101: LIST
68102: PUSH
68103: LD_INT 0
68105: PUSH
68106: LD_INT 1
68108: NEG
68109: PUSH
68110: EMPTY
68111: LIST
68112: LIST
68113: PUSH
68114: LD_INT 1
68116: PUSH
68117: LD_INT 0
68119: PUSH
68120: EMPTY
68121: LIST
68122: LIST
68123: PUSH
68124: LD_INT 1
68126: PUSH
68127: LD_INT 1
68129: PUSH
68130: EMPTY
68131: LIST
68132: LIST
68133: PUSH
68134: LD_INT 0
68136: PUSH
68137: LD_INT 1
68139: PUSH
68140: EMPTY
68141: LIST
68142: LIST
68143: PUSH
68144: LD_INT 1
68146: NEG
68147: PUSH
68148: LD_INT 0
68150: PUSH
68151: EMPTY
68152: LIST
68153: LIST
68154: PUSH
68155: LD_INT 1
68157: NEG
68158: PUSH
68159: LD_INT 1
68161: NEG
68162: PUSH
68163: EMPTY
68164: LIST
68165: LIST
68166: PUSH
68167: LD_INT 1
68169: NEG
68170: PUSH
68171: LD_INT 2
68173: NEG
68174: PUSH
68175: EMPTY
68176: LIST
68177: LIST
68178: PUSH
68179: LD_INT 0
68181: PUSH
68182: LD_INT 2
68184: NEG
68185: PUSH
68186: EMPTY
68187: LIST
68188: LIST
68189: PUSH
68190: LD_INT 1
68192: PUSH
68193: LD_INT 1
68195: NEG
68196: PUSH
68197: EMPTY
68198: LIST
68199: LIST
68200: PUSH
68201: LD_INT 2
68203: PUSH
68204: LD_INT 0
68206: PUSH
68207: EMPTY
68208: LIST
68209: LIST
68210: PUSH
68211: LD_INT 2
68213: PUSH
68214: LD_INT 1
68216: PUSH
68217: EMPTY
68218: LIST
68219: LIST
68220: PUSH
68221: LD_INT 2
68223: PUSH
68224: LD_INT 2
68226: PUSH
68227: EMPTY
68228: LIST
68229: LIST
68230: PUSH
68231: LD_INT 1
68233: PUSH
68234: LD_INT 2
68236: PUSH
68237: EMPTY
68238: LIST
68239: LIST
68240: PUSH
68241: LD_INT 0
68243: PUSH
68244: LD_INT 2
68246: PUSH
68247: EMPTY
68248: LIST
68249: LIST
68250: PUSH
68251: LD_INT 1
68253: NEG
68254: PUSH
68255: LD_INT 1
68257: PUSH
68258: EMPTY
68259: LIST
68260: LIST
68261: PUSH
68262: LD_INT 2
68264: NEG
68265: PUSH
68266: LD_INT 0
68268: PUSH
68269: EMPTY
68270: LIST
68271: LIST
68272: PUSH
68273: LD_INT 2
68275: NEG
68276: PUSH
68277: LD_INT 1
68279: NEG
68280: PUSH
68281: EMPTY
68282: LIST
68283: LIST
68284: PUSH
68285: LD_INT 2
68287: NEG
68288: PUSH
68289: LD_INT 2
68291: NEG
68292: PUSH
68293: EMPTY
68294: LIST
68295: LIST
68296: PUSH
68297: LD_INT 2
68299: NEG
68300: PUSH
68301: LD_INT 3
68303: NEG
68304: PUSH
68305: EMPTY
68306: LIST
68307: LIST
68308: PUSH
68309: LD_INT 1
68311: NEG
68312: PUSH
68313: LD_INT 3
68315: NEG
68316: PUSH
68317: EMPTY
68318: LIST
68319: LIST
68320: PUSH
68321: LD_INT 1
68323: PUSH
68324: LD_INT 2
68326: NEG
68327: PUSH
68328: EMPTY
68329: LIST
68330: LIST
68331: PUSH
68332: LD_INT 2
68334: PUSH
68335: LD_INT 1
68337: NEG
68338: PUSH
68339: EMPTY
68340: LIST
68341: LIST
68342: PUSH
68343: EMPTY
68344: LIST
68345: LIST
68346: LIST
68347: LIST
68348: LIST
68349: LIST
68350: LIST
68351: LIST
68352: LIST
68353: LIST
68354: LIST
68355: LIST
68356: LIST
68357: LIST
68358: LIST
68359: LIST
68360: LIST
68361: LIST
68362: LIST
68363: LIST
68364: LIST
68365: LIST
68366: LIST
68367: ST_TO_ADDR
// DepotRu1 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ 1 , - 2 ] , [ 2 , - 1 ] , [ 3 , 1 ] , [ 3 , 2 ] ] ;
68368: LD_ADDR_VAR 0 24
68372: PUSH
68373: LD_INT 0
68375: PUSH
68376: LD_INT 0
68378: PUSH
68379: EMPTY
68380: LIST
68381: LIST
68382: PUSH
68383: LD_INT 0
68385: PUSH
68386: LD_INT 1
68388: NEG
68389: PUSH
68390: EMPTY
68391: LIST
68392: LIST
68393: PUSH
68394: LD_INT 1
68396: PUSH
68397: LD_INT 0
68399: PUSH
68400: EMPTY
68401: LIST
68402: LIST
68403: PUSH
68404: LD_INT 1
68406: PUSH
68407: LD_INT 1
68409: PUSH
68410: EMPTY
68411: LIST
68412: LIST
68413: PUSH
68414: LD_INT 0
68416: PUSH
68417: LD_INT 1
68419: PUSH
68420: EMPTY
68421: LIST
68422: LIST
68423: PUSH
68424: LD_INT 1
68426: NEG
68427: PUSH
68428: LD_INT 0
68430: PUSH
68431: EMPTY
68432: LIST
68433: LIST
68434: PUSH
68435: LD_INT 1
68437: NEG
68438: PUSH
68439: LD_INT 1
68441: NEG
68442: PUSH
68443: EMPTY
68444: LIST
68445: LIST
68446: PUSH
68447: LD_INT 1
68449: NEG
68450: PUSH
68451: LD_INT 2
68453: NEG
68454: PUSH
68455: EMPTY
68456: LIST
68457: LIST
68458: PUSH
68459: LD_INT 0
68461: PUSH
68462: LD_INT 2
68464: NEG
68465: PUSH
68466: EMPTY
68467: LIST
68468: LIST
68469: PUSH
68470: LD_INT 1
68472: PUSH
68473: LD_INT 1
68475: NEG
68476: PUSH
68477: EMPTY
68478: LIST
68479: LIST
68480: PUSH
68481: LD_INT 2
68483: PUSH
68484: LD_INT 0
68486: PUSH
68487: EMPTY
68488: LIST
68489: LIST
68490: PUSH
68491: LD_INT 2
68493: PUSH
68494: LD_INT 1
68496: PUSH
68497: EMPTY
68498: LIST
68499: LIST
68500: PUSH
68501: LD_INT 2
68503: PUSH
68504: LD_INT 2
68506: PUSH
68507: EMPTY
68508: LIST
68509: LIST
68510: PUSH
68511: LD_INT 1
68513: PUSH
68514: LD_INT 2
68516: PUSH
68517: EMPTY
68518: LIST
68519: LIST
68520: PUSH
68521: LD_INT 0
68523: PUSH
68524: LD_INT 2
68526: PUSH
68527: EMPTY
68528: LIST
68529: LIST
68530: PUSH
68531: LD_INT 1
68533: NEG
68534: PUSH
68535: LD_INT 1
68537: PUSH
68538: EMPTY
68539: LIST
68540: LIST
68541: PUSH
68542: LD_INT 2
68544: NEG
68545: PUSH
68546: LD_INT 0
68548: PUSH
68549: EMPTY
68550: LIST
68551: LIST
68552: PUSH
68553: LD_INT 2
68555: NEG
68556: PUSH
68557: LD_INT 1
68559: NEG
68560: PUSH
68561: EMPTY
68562: LIST
68563: LIST
68564: PUSH
68565: LD_INT 2
68567: NEG
68568: PUSH
68569: LD_INT 2
68571: NEG
68572: PUSH
68573: EMPTY
68574: LIST
68575: LIST
68576: PUSH
68577: LD_INT 1
68579: PUSH
68580: LD_INT 2
68582: NEG
68583: PUSH
68584: EMPTY
68585: LIST
68586: LIST
68587: PUSH
68588: LD_INT 2
68590: PUSH
68591: LD_INT 1
68593: NEG
68594: PUSH
68595: EMPTY
68596: LIST
68597: LIST
68598: PUSH
68599: LD_INT 3
68601: PUSH
68602: LD_INT 1
68604: PUSH
68605: EMPTY
68606: LIST
68607: LIST
68608: PUSH
68609: LD_INT 3
68611: PUSH
68612: LD_INT 2
68614: PUSH
68615: EMPTY
68616: LIST
68617: LIST
68618: PUSH
68619: EMPTY
68620: LIST
68621: LIST
68622: LIST
68623: LIST
68624: LIST
68625: LIST
68626: LIST
68627: LIST
68628: LIST
68629: LIST
68630: LIST
68631: LIST
68632: LIST
68633: LIST
68634: LIST
68635: LIST
68636: LIST
68637: LIST
68638: LIST
68639: LIST
68640: LIST
68641: LIST
68642: LIST
68643: ST_TO_ADDR
// DepotRu2 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ 3 , 1 ] , [ 3 , 2 ] , [ 2 , 3 ] , [ 1 , 3 ] ] ;
68644: LD_ADDR_VAR 0 25
68648: PUSH
68649: LD_INT 0
68651: PUSH
68652: LD_INT 0
68654: PUSH
68655: EMPTY
68656: LIST
68657: LIST
68658: PUSH
68659: LD_INT 0
68661: PUSH
68662: LD_INT 1
68664: NEG
68665: PUSH
68666: EMPTY
68667: LIST
68668: LIST
68669: PUSH
68670: LD_INT 1
68672: PUSH
68673: LD_INT 0
68675: PUSH
68676: EMPTY
68677: LIST
68678: LIST
68679: PUSH
68680: LD_INT 1
68682: PUSH
68683: LD_INT 1
68685: PUSH
68686: EMPTY
68687: LIST
68688: LIST
68689: PUSH
68690: LD_INT 0
68692: PUSH
68693: LD_INT 1
68695: PUSH
68696: EMPTY
68697: LIST
68698: LIST
68699: PUSH
68700: LD_INT 1
68702: NEG
68703: PUSH
68704: LD_INT 0
68706: PUSH
68707: EMPTY
68708: LIST
68709: LIST
68710: PUSH
68711: LD_INT 1
68713: NEG
68714: PUSH
68715: LD_INT 1
68717: NEG
68718: PUSH
68719: EMPTY
68720: LIST
68721: LIST
68722: PUSH
68723: LD_INT 1
68725: NEG
68726: PUSH
68727: LD_INT 2
68729: NEG
68730: PUSH
68731: EMPTY
68732: LIST
68733: LIST
68734: PUSH
68735: LD_INT 0
68737: PUSH
68738: LD_INT 2
68740: NEG
68741: PUSH
68742: EMPTY
68743: LIST
68744: LIST
68745: PUSH
68746: LD_INT 1
68748: PUSH
68749: LD_INT 1
68751: NEG
68752: PUSH
68753: EMPTY
68754: LIST
68755: LIST
68756: PUSH
68757: LD_INT 2
68759: PUSH
68760: LD_INT 0
68762: PUSH
68763: EMPTY
68764: LIST
68765: LIST
68766: PUSH
68767: LD_INT 2
68769: PUSH
68770: LD_INT 1
68772: PUSH
68773: EMPTY
68774: LIST
68775: LIST
68776: PUSH
68777: LD_INT 2
68779: PUSH
68780: LD_INT 2
68782: PUSH
68783: EMPTY
68784: LIST
68785: LIST
68786: PUSH
68787: LD_INT 1
68789: PUSH
68790: LD_INT 2
68792: PUSH
68793: EMPTY
68794: LIST
68795: LIST
68796: PUSH
68797: LD_INT 0
68799: PUSH
68800: LD_INT 2
68802: PUSH
68803: EMPTY
68804: LIST
68805: LIST
68806: PUSH
68807: LD_INT 1
68809: NEG
68810: PUSH
68811: LD_INT 1
68813: PUSH
68814: EMPTY
68815: LIST
68816: LIST
68817: PUSH
68818: LD_INT 2
68820: NEG
68821: PUSH
68822: LD_INT 0
68824: PUSH
68825: EMPTY
68826: LIST
68827: LIST
68828: PUSH
68829: LD_INT 2
68831: NEG
68832: PUSH
68833: LD_INT 1
68835: NEG
68836: PUSH
68837: EMPTY
68838: LIST
68839: LIST
68840: PUSH
68841: LD_INT 2
68843: NEG
68844: PUSH
68845: LD_INT 2
68847: NEG
68848: PUSH
68849: EMPTY
68850: LIST
68851: LIST
68852: PUSH
68853: LD_INT 3
68855: PUSH
68856: LD_INT 1
68858: PUSH
68859: EMPTY
68860: LIST
68861: LIST
68862: PUSH
68863: LD_INT 3
68865: PUSH
68866: LD_INT 2
68868: PUSH
68869: EMPTY
68870: LIST
68871: LIST
68872: PUSH
68873: LD_INT 2
68875: PUSH
68876: LD_INT 3
68878: PUSH
68879: EMPTY
68880: LIST
68881: LIST
68882: PUSH
68883: LD_INT 1
68885: PUSH
68886: LD_INT 3
68888: PUSH
68889: EMPTY
68890: LIST
68891: LIST
68892: PUSH
68893: EMPTY
68894: LIST
68895: LIST
68896: LIST
68897: LIST
68898: LIST
68899: LIST
68900: LIST
68901: LIST
68902: LIST
68903: LIST
68904: LIST
68905: LIST
68906: LIST
68907: LIST
68908: LIST
68909: LIST
68910: LIST
68911: LIST
68912: LIST
68913: LIST
68914: LIST
68915: LIST
68916: LIST
68917: ST_TO_ADDR
// DepotRu3 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ 2 , 3 ] , [ 1 , 3 ] , [ - 1 , 2 ] , [ - 2 , 1 ] ] ;
68918: LD_ADDR_VAR 0 26
68922: PUSH
68923: LD_INT 0
68925: PUSH
68926: LD_INT 0
68928: PUSH
68929: EMPTY
68930: LIST
68931: LIST
68932: PUSH
68933: LD_INT 0
68935: PUSH
68936: LD_INT 1
68938: NEG
68939: PUSH
68940: EMPTY
68941: LIST
68942: LIST
68943: PUSH
68944: LD_INT 1
68946: PUSH
68947: LD_INT 0
68949: PUSH
68950: EMPTY
68951: LIST
68952: LIST
68953: PUSH
68954: LD_INT 1
68956: PUSH
68957: LD_INT 1
68959: PUSH
68960: EMPTY
68961: LIST
68962: LIST
68963: PUSH
68964: LD_INT 0
68966: PUSH
68967: LD_INT 1
68969: PUSH
68970: EMPTY
68971: LIST
68972: LIST
68973: PUSH
68974: LD_INT 1
68976: NEG
68977: PUSH
68978: LD_INT 0
68980: PUSH
68981: EMPTY
68982: LIST
68983: LIST
68984: PUSH
68985: LD_INT 1
68987: NEG
68988: PUSH
68989: LD_INT 1
68991: NEG
68992: PUSH
68993: EMPTY
68994: LIST
68995: LIST
68996: PUSH
68997: LD_INT 1
68999: NEG
69000: PUSH
69001: LD_INT 2
69003: NEG
69004: PUSH
69005: EMPTY
69006: LIST
69007: LIST
69008: PUSH
69009: LD_INT 0
69011: PUSH
69012: LD_INT 2
69014: NEG
69015: PUSH
69016: EMPTY
69017: LIST
69018: LIST
69019: PUSH
69020: LD_INT 1
69022: PUSH
69023: LD_INT 1
69025: NEG
69026: PUSH
69027: EMPTY
69028: LIST
69029: LIST
69030: PUSH
69031: LD_INT 2
69033: PUSH
69034: LD_INT 0
69036: PUSH
69037: EMPTY
69038: LIST
69039: LIST
69040: PUSH
69041: LD_INT 2
69043: PUSH
69044: LD_INT 1
69046: PUSH
69047: EMPTY
69048: LIST
69049: LIST
69050: PUSH
69051: LD_INT 2
69053: PUSH
69054: LD_INT 2
69056: PUSH
69057: EMPTY
69058: LIST
69059: LIST
69060: PUSH
69061: LD_INT 1
69063: PUSH
69064: LD_INT 2
69066: PUSH
69067: EMPTY
69068: LIST
69069: LIST
69070: PUSH
69071: LD_INT 0
69073: PUSH
69074: LD_INT 2
69076: PUSH
69077: EMPTY
69078: LIST
69079: LIST
69080: PUSH
69081: LD_INT 1
69083: NEG
69084: PUSH
69085: LD_INT 1
69087: PUSH
69088: EMPTY
69089: LIST
69090: LIST
69091: PUSH
69092: LD_INT 2
69094: NEG
69095: PUSH
69096: LD_INT 0
69098: PUSH
69099: EMPTY
69100: LIST
69101: LIST
69102: PUSH
69103: LD_INT 2
69105: NEG
69106: PUSH
69107: LD_INT 1
69109: NEG
69110: PUSH
69111: EMPTY
69112: LIST
69113: LIST
69114: PUSH
69115: LD_INT 2
69117: NEG
69118: PUSH
69119: LD_INT 2
69121: NEG
69122: PUSH
69123: EMPTY
69124: LIST
69125: LIST
69126: PUSH
69127: LD_INT 2
69129: PUSH
69130: LD_INT 3
69132: PUSH
69133: EMPTY
69134: LIST
69135: LIST
69136: PUSH
69137: LD_INT 1
69139: PUSH
69140: LD_INT 3
69142: PUSH
69143: EMPTY
69144: LIST
69145: LIST
69146: PUSH
69147: LD_INT 1
69149: NEG
69150: PUSH
69151: LD_INT 2
69153: PUSH
69154: EMPTY
69155: LIST
69156: LIST
69157: PUSH
69158: LD_INT 2
69160: NEG
69161: PUSH
69162: LD_INT 1
69164: PUSH
69165: EMPTY
69166: LIST
69167: LIST
69168: PUSH
69169: EMPTY
69170: LIST
69171: LIST
69172: LIST
69173: LIST
69174: LIST
69175: LIST
69176: LIST
69177: LIST
69178: LIST
69179: LIST
69180: LIST
69181: LIST
69182: LIST
69183: LIST
69184: LIST
69185: LIST
69186: LIST
69187: LIST
69188: LIST
69189: LIST
69190: LIST
69191: LIST
69192: LIST
69193: ST_TO_ADDR
// DepotRu4 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ - 1 , 2 ] , [ - 2 , 1 ] , [ - 3 , - 1 ] , [ - 3 , - 2 ] ] ;
69194: LD_ADDR_VAR 0 27
69198: PUSH
69199: LD_INT 0
69201: PUSH
69202: LD_INT 0
69204: PUSH
69205: EMPTY
69206: LIST
69207: LIST
69208: PUSH
69209: LD_INT 0
69211: PUSH
69212: LD_INT 1
69214: NEG
69215: PUSH
69216: EMPTY
69217: LIST
69218: LIST
69219: PUSH
69220: LD_INT 1
69222: PUSH
69223: LD_INT 0
69225: PUSH
69226: EMPTY
69227: LIST
69228: LIST
69229: PUSH
69230: LD_INT 1
69232: PUSH
69233: LD_INT 1
69235: PUSH
69236: EMPTY
69237: LIST
69238: LIST
69239: PUSH
69240: LD_INT 0
69242: PUSH
69243: LD_INT 1
69245: PUSH
69246: EMPTY
69247: LIST
69248: LIST
69249: PUSH
69250: LD_INT 1
69252: NEG
69253: PUSH
69254: LD_INT 0
69256: PUSH
69257: EMPTY
69258: LIST
69259: LIST
69260: PUSH
69261: LD_INT 1
69263: NEG
69264: PUSH
69265: LD_INT 1
69267: NEG
69268: PUSH
69269: EMPTY
69270: LIST
69271: LIST
69272: PUSH
69273: LD_INT 1
69275: NEG
69276: PUSH
69277: LD_INT 2
69279: NEG
69280: PUSH
69281: EMPTY
69282: LIST
69283: LIST
69284: PUSH
69285: LD_INT 0
69287: PUSH
69288: LD_INT 2
69290: NEG
69291: PUSH
69292: EMPTY
69293: LIST
69294: LIST
69295: PUSH
69296: LD_INT 1
69298: PUSH
69299: LD_INT 1
69301: NEG
69302: PUSH
69303: EMPTY
69304: LIST
69305: LIST
69306: PUSH
69307: LD_INT 2
69309: PUSH
69310: LD_INT 0
69312: PUSH
69313: EMPTY
69314: LIST
69315: LIST
69316: PUSH
69317: LD_INT 2
69319: PUSH
69320: LD_INT 1
69322: PUSH
69323: EMPTY
69324: LIST
69325: LIST
69326: PUSH
69327: LD_INT 2
69329: PUSH
69330: LD_INT 2
69332: PUSH
69333: EMPTY
69334: LIST
69335: LIST
69336: PUSH
69337: LD_INT 1
69339: PUSH
69340: LD_INT 2
69342: PUSH
69343: EMPTY
69344: LIST
69345: LIST
69346: PUSH
69347: LD_INT 0
69349: PUSH
69350: LD_INT 2
69352: PUSH
69353: EMPTY
69354: LIST
69355: LIST
69356: PUSH
69357: LD_INT 1
69359: NEG
69360: PUSH
69361: LD_INT 1
69363: PUSH
69364: EMPTY
69365: LIST
69366: LIST
69367: PUSH
69368: LD_INT 2
69370: NEG
69371: PUSH
69372: LD_INT 0
69374: PUSH
69375: EMPTY
69376: LIST
69377: LIST
69378: PUSH
69379: LD_INT 2
69381: NEG
69382: PUSH
69383: LD_INT 1
69385: NEG
69386: PUSH
69387: EMPTY
69388: LIST
69389: LIST
69390: PUSH
69391: LD_INT 2
69393: NEG
69394: PUSH
69395: LD_INT 2
69397: NEG
69398: PUSH
69399: EMPTY
69400: LIST
69401: LIST
69402: PUSH
69403: LD_INT 1
69405: NEG
69406: PUSH
69407: LD_INT 2
69409: PUSH
69410: EMPTY
69411: LIST
69412: LIST
69413: PUSH
69414: LD_INT 2
69416: NEG
69417: PUSH
69418: LD_INT 1
69420: PUSH
69421: EMPTY
69422: LIST
69423: LIST
69424: PUSH
69425: LD_INT 3
69427: NEG
69428: PUSH
69429: LD_INT 1
69431: NEG
69432: PUSH
69433: EMPTY
69434: LIST
69435: LIST
69436: PUSH
69437: LD_INT 3
69439: NEG
69440: PUSH
69441: LD_INT 2
69443: NEG
69444: PUSH
69445: EMPTY
69446: LIST
69447: LIST
69448: PUSH
69449: EMPTY
69450: LIST
69451: LIST
69452: LIST
69453: LIST
69454: LIST
69455: LIST
69456: LIST
69457: LIST
69458: LIST
69459: LIST
69460: LIST
69461: LIST
69462: LIST
69463: LIST
69464: LIST
69465: LIST
69466: LIST
69467: LIST
69468: LIST
69469: LIST
69470: LIST
69471: LIST
69472: LIST
69473: ST_TO_ADDR
// DepotRu5 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ - 2 , - 3 ] , [ - 1 , - 3 ] , [ - 3 , - 1 ] , [ - 3 , - 2 ] ] ;
69474: LD_ADDR_VAR 0 28
69478: PUSH
69479: LD_INT 0
69481: PUSH
69482: LD_INT 0
69484: PUSH
69485: EMPTY
69486: LIST
69487: LIST
69488: PUSH
69489: LD_INT 0
69491: PUSH
69492: LD_INT 1
69494: NEG
69495: PUSH
69496: EMPTY
69497: LIST
69498: LIST
69499: PUSH
69500: LD_INT 1
69502: PUSH
69503: LD_INT 0
69505: PUSH
69506: EMPTY
69507: LIST
69508: LIST
69509: PUSH
69510: LD_INT 1
69512: PUSH
69513: LD_INT 1
69515: PUSH
69516: EMPTY
69517: LIST
69518: LIST
69519: PUSH
69520: LD_INT 0
69522: PUSH
69523: LD_INT 1
69525: PUSH
69526: EMPTY
69527: LIST
69528: LIST
69529: PUSH
69530: LD_INT 1
69532: NEG
69533: PUSH
69534: LD_INT 0
69536: PUSH
69537: EMPTY
69538: LIST
69539: LIST
69540: PUSH
69541: LD_INT 1
69543: NEG
69544: PUSH
69545: LD_INT 1
69547: NEG
69548: PUSH
69549: EMPTY
69550: LIST
69551: LIST
69552: PUSH
69553: LD_INT 1
69555: NEG
69556: PUSH
69557: LD_INT 2
69559: NEG
69560: PUSH
69561: EMPTY
69562: LIST
69563: LIST
69564: PUSH
69565: LD_INT 0
69567: PUSH
69568: LD_INT 2
69570: NEG
69571: PUSH
69572: EMPTY
69573: LIST
69574: LIST
69575: PUSH
69576: LD_INT 1
69578: PUSH
69579: LD_INT 1
69581: NEG
69582: PUSH
69583: EMPTY
69584: LIST
69585: LIST
69586: PUSH
69587: LD_INT 2
69589: PUSH
69590: LD_INT 0
69592: PUSH
69593: EMPTY
69594: LIST
69595: LIST
69596: PUSH
69597: LD_INT 2
69599: PUSH
69600: LD_INT 1
69602: PUSH
69603: EMPTY
69604: LIST
69605: LIST
69606: PUSH
69607: LD_INT 2
69609: PUSH
69610: LD_INT 2
69612: PUSH
69613: EMPTY
69614: LIST
69615: LIST
69616: PUSH
69617: LD_INT 1
69619: PUSH
69620: LD_INT 2
69622: PUSH
69623: EMPTY
69624: LIST
69625: LIST
69626: PUSH
69627: LD_INT 0
69629: PUSH
69630: LD_INT 2
69632: PUSH
69633: EMPTY
69634: LIST
69635: LIST
69636: PUSH
69637: LD_INT 1
69639: NEG
69640: PUSH
69641: LD_INT 1
69643: PUSH
69644: EMPTY
69645: LIST
69646: LIST
69647: PUSH
69648: LD_INT 2
69650: NEG
69651: PUSH
69652: LD_INT 0
69654: PUSH
69655: EMPTY
69656: LIST
69657: LIST
69658: PUSH
69659: LD_INT 2
69661: NEG
69662: PUSH
69663: LD_INT 1
69665: NEG
69666: PUSH
69667: EMPTY
69668: LIST
69669: LIST
69670: PUSH
69671: LD_INT 2
69673: NEG
69674: PUSH
69675: LD_INT 2
69677: NEG
69678: PUSH
69679: EMPTY
69680: LIST
69681: LIST
69682: PUSH
69683: LD_INT 2
69685: NEG
69686: PUSH
69687: LD_INT 3
69689: NEG
69690: PUSH
69691: EMPTY
69692: LIST
69693: LIST
69694: PUSH
69695: LD_INT 1
69697: NEG
69698: PUSH
69699: LD_INT 3
69701: NEG
69702: PUSH
69703: EMPTY
69704: LIST
69705: LIST
69706: PUSH
69707: LD_INT 3
69709: NEG
69710: PUSH
69711: LD_INT 1
69713: NEG
69714: PUSH
69715: EMPTY
69716: LIST
69717: LIST
69718: PUSH
69719: LD_INT 3
69721: NEG
69722: PUSH
69723: LD_INT 2
69725: NEG
69726: PUSH
69727: EMPTY
69728: LIST
69729: LIST
69730: PUSH
69731: EMPTY
69732: LIST
69733: LIST
69734: LIST
69735: LIST
69736: LIST
69737: LIST
69738: LIST
69739: LIST
69740: LIST
69741: LIST
69742: LIST
69743: LIST
69744: LIST
69745: LIST
69746: LIST
69747: LIST
69748: LIST
69749: LIST
69750: LIST
69751: LIST
69752: LIST
69753: LIST
69754: LIST
69755: ST_TO_ADDR
// Factory0 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ - 2 , - 3 ] , [ 2 , - 1 ] , [ 3 , 1 ] , [ 1 , 3 ] , [ - 1 , 2 ] , [ - 3 , - 2 ] ] ;
69756: LD_ADDR_VAR 0 29
69760: PUSH
69761: LD_INT 0
69763: PUSH
69764: LD_INT 0
69766: PUSH
69767: EMPTY
69768: LIST
69769: LIST
69770: PUSH
69771: LD_INT 0
69773: PUSH
69774: LD_INT 1
69776: NEG
69777: PUSH
69778: EMPTY
69779: LIST
69780: LIST
69781: PUSH
69782: LD_INT 1
69784: PUSH
69785: LD_INT 0
69787: PUSH
69788: EMPTY
69789: LIST
69790: LIST
69791: PUSH
69792: LD_INT 1
69794: PUSH
69795: LD_INT 1
69797: PUSH
69798: EMPTY
69799: LIST
69800: LIST
69801: PUSH
69802: LD_INT 0
69804: PUSH
69805: LD_INT 1
69807: PUSH
69808: EMPTY
69809: LIST
69810: LIST
69811: PUSH
69812: LD_INT 1
69814: NEG
69815: PUSH
69816: LD_INT 0
69818: PUSH
69819: EMPTY
69820: LIST
69821: LIST
69822: PUSH
69823: LD_INT 1
69825: NEG
69826: PUSH
69827: LD_INT 1
69829: NEG
69830: PUSH
69831: EMPTY
69832: LIST
69833: LIST
69834: PUSH
69835: LD_INT 1
69837: NEG
69838: PUSH
69839: LD_INT 2
69841: NEG
69842: PUSH
69843: EMPTY
69844: LIST
69845: LIST
69846: PUSH
69847: LD_INT 0
69849: PUSH
69850: LD_INT 2
69852: NEG
69853: PUSH
69854: EMPTY
69855: LIST
69856: LIST
69857: PUSH
69858: LD_INT 1
69860: PUSH
69861: LD_INT 1
69863: NEG
69864: PUSH
69865: EMPTY
69866: LIST
69867: LIST
69868: PUSH
69869: LD_INT 2
69871: PUSH
69872: LD_INT 0
69874: PUSH
69875: EMPTY
69876: LIST
69877: LIST
69878: PUSH
69879: LD_INT 2
69881: PUSH
69882: LD_INT 1
69884: PUSH
69885: EMPTY
69886: LIST
69887: LIST
69888: PUSH
69889: LD_INT 1
69891: PUSH
69892: LD_INT 2
69894: PUSH
69895: EMPTY
69896: LIST
69897: LIST
69898: PUSH
69899: LD_INT 0
69901: PUSH
69902: LD_INT 2
69904: PUSH
69905: EMPTY
69906: LIST
69907: LIST
69908: PUSH
69909: LD_INT 1
69911: NEG
69912: PUSH
69913: LD_INT 1
69915: PUSH
69916: EMPTY
69917: LIST
69918: LIST
69919: PUSH
69920: LD_INT 2
69922: NEG
69923: PUSH
69924: LD_INT 1
69926: NEG
69927: PUSH
69928: EMPTY
69929: LIST
69930: LIST
69931: PUSH
69932: LD_INT 2
69934: NEG
69935: PUSH
69936: LD_INT 2
69938: NEG
69939: PUSH
69940: EMPTY
69941: LIST
69942: LIST
69943: PUSH
69944: LD_INT 2
69946: NEG
69947: PUSH
69948: LD_INT 3
69950: NEG
69951: PUSH
69952: EMPTY
69953: LIST
69954: LIST
69955: PUSH
69956: LD_INT 2
69958: PUSH
69959: LD_INT 1
69961: NEG
69962: PUSH
69963: EMPTY
69964: LIST
69965: LIST
69966: PUSH
69967: LD_INT 3
69969: PUSH
69970: LD_INT 1
69972: PUSH
69973: EMPTY
69974: LIST
69975: LIST
69976: PUSH
69977: LD_INT 1
69979: PUSH
69980: LD_INT 3
69982: PUSH
69983: EMPTY
69984: LIST
69985: LIST
69986: PUSH
69987: LD_INT 1
69989: NEG
69990: PUSH
69991: LD_INT 2
69993: PUSH
69994: EMPTY
69995: LIST
69996: LIST
69997: PUSH
69998: LD_INT 3
70000: NEG
70001: PUSH
70002: LD_INT 2
70004: NEG
70005: PUSH
70006: EMPTY
70007: LIST
70008: LIST
70009: PUSH
70010: EMPTY
70011: LIST
70012: LIST
70013: LIST
70014: LIST
70015: LIST
70016: LIST
70017: LIST
70018: LIST
70019: LIST
70020: LIST
70021: LIST
70022: LIST
70023: LIST
70024: LIST
70025: LIST
70026: LIST
70027: LIST
70028: LIST
70029: LIST
70030: LIST
70031: LIST
70032: LIST
70033: LIST
70034: ST_TO_ADDR
// Factory1 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 1 , - 3 ] , [ 1 , - 2 ] , [ 3 , 2 ] , [ 2 , 3 ] , [ - 2 , 1 ] , [ - 3 , - 1 ] ] ;
70035: LD_ADDR_VAR 0 30
70039: PUSH
70040: LD_INT 0
70042: PUSH
70043: LD_INT 0
70045: PUSH
70046: EMPTY
70047: LIST
70048: LIST
70049: PUSH
70050: LD_INT 0
70052: PUSH
70053: LD_INT 1
70055: NEG
70056: PUSH
70057: EMPTY
70058: LIST
70059: LIST
70060: PUSH
70061: LD_INT 1
70063: PUSH
70064: LD_INT 0
70066: PUSH
70067: EMPTY
70068: LIST
70069: LIST
70070: PUSH
70071: LD_INT 1
70073: PUSH
70074: LD_INT 1
70076: PUSH
70077: EMPTY
70078: LIST
70079: LIST
70080: PUSH
70081: LD_INT 0
70083: PUSH
70084: LD_INT 1
70086: PUSH
70087: EMPTY
70088: LIST
70089: LIST
70090: PUSH
70091: LD_INT 1
70093: NEG
70094: PUSH
70095: LD_INT 0
70097: PUSH
70098: EMPTY
70099: LIST
70100: LIST
70101: PUSH
70102: LD_INT 1
70104: NEG
70105: PUSH
70106: LD_INT 1
70108: NEG
70109: PUSH
70110: EMPTY
70111: LIST
70112: LIST
70113: PUSH
70114: LD_INT 1
70116: NEG
70117: PUSH
70118: LD_INT 2
70120: NEG
70121: PUSH
70122: EMPTY
70123: LIST
70124: LIST
70125: PUSH
70126: LD_INT 0
70128: PUSH
70129: LD_INT 2
70131: NEG
70132: PUSH
70133: EMPTY
70134: LIST
70135: LIST
70136: PUSH
70137: LD_INT 1
70139: PUSH
70140: LD_INT 1
70142: NEG
70143: PUSH
70144: EMPTY
70145: LIST
70146: LIST
70147: PUSH
70148: LD_INT 2
70150: PUSH
70151: LD_INT 0
70153: PUSH
70154: EMPTY
70155: LIST
70156: LIST
70157: PUSH
70158: LD_INT 2
70160: PUSH
70161: LD_INT 1
70163: PUSH
70164: EMPTY
70165: LIST
70166: LIST
70167: PUSH
70168: LD_INT 2
70170: PUSH
70171: LD_INT 2
70173: PUSH
70174: EMPTY
70175: LIST
70176: LIST
70177: PUSH
70178: LD_INT 1
70180: PUSH
70181: LD_INT 2
70183: PUSH
70184: EMPTY
70185: LIST
70186: LIST
70187: PUSH
70188: LD_INT 1
70190: NEG
70191: PUSH
70192: LD_INT 1
70194: PUSH
70195: EMPTY
70196: LIST
70197: LIST
70198: PUSH
70199: LD_INT 2
70201: NEG
70202: PUSH
70203: LD_INT 0
70205: PUSH
70206: EMPTY
70207: LIST
70208: LIST
70209: PUSH
70210: LD_INT 2
70212: NEG
70213: PUSH
70214: LD_INT 1
70216: NEG
70217: PUSH
70218: EMPTY
70219: LIST
70220: LIST
70221: PUSH
70222: LD_INT 1
70224: NEG
70225: PUSH
70226: LD_INT 3
70228: NEG
70229: PUSH
70230: EMPTY
70231: LIST
70232: LIST
70233: PUSH
70234: LD_INT 1
70236: PUSH
70237: LD_INT 2
70239: NEG
70240: PUSH
70241: EMPTY
70242: LIST
70243: LIST
70244: PUSH
70245: LD_INT 3
70247: PUSH
70248: LD_INT 2
70250: PUSH
70251: EMPTY
70252: LIST
70253: LIST
70254: PUSH
70255: LD_INT 2
70257: PUSH
70258: LD_INT 3
70260: PUSH
70261: EMPTY
70262: LIST
70263: LIST
70264: PUSH
70265: LD_INT 2
70267: NEG
70268: PUSH
70269: LD_INT 1
70271: PUSH
70272: EMPTY
70273: LIST
70274: LIST
70275: PUSH
70276: LD_INT 3
70278: NEG
70279: PUSH
70280: LD_INT 1
70282: NEG
70283: PUSH
70284: EMPTY
70285: LIST
70286: LIST
70287: PUSH
70288: EMPTY
70289: LIST
70290: LIST
70291: LIST
70292: LIST
70293: LIST
70294: LIST
70295: LIST
70296: LIST
70297: LIST
70298: LIST
70299: LIST
70300: LIST
70301: LIST
70302: LIST
70303: LIST
70304: LIST
70305: LIST
70306: LIST
70307: LIST
70308: LIST
70309: LIST
70310: LIST
70311: LIST
70312: ST_TO_ADDR
// Factory2 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ - 2 , - 3 ] , [ 2 , - 1 ] , [ 3 , 1 ] , [ 1 , 3 ] , [ - 1 , 2 ] , [ - 3 , - 2 ] ] ;
70313: LD_ADDR_VAR 0 31
70317: PUSH
70318: LD_INT 0
70320: PUSH
70321: LD_INT 0
70323: PUSH
70324: EMPTY
70325: LIST
70326: LIST
70327: PUSH
70328: LD_INT 0
70330: PUSH
70331: LD_INT 1
70333: NEG
70334: PUSH
70335: EMPTY
70336: LIST
70337: LIST
70338: PUSH
70339: LD_INT 1
70341: PUSH
70342: LD_INT 0
70344: PUSH
70345: EMPTY
70346: LIST
70347: LIST
70348: PUSH
70349: LD_INT 1
70351: PUSH
70352: LD_INT 1
70354: PUSH
70355: EMPTY
70356: LIST
70357: LIST
70358: PUSH
70359: LD_INT 0
70361: PUSH
70362: LD_INT 1
70364: PUSH
70365: EMPTY
70366: LIST
70367: LIST
70368: PUSH
70369: LD_INT 1
70371: NEG
70372: PUSH
70373: LD_INT 0
70375: PUSH
70376: EMPTY
70377: LIST
70378: LIST
70379: PUSH
70380: LD_INT 1
70382: NEG
70383: PUSH
70384: LD_INT 1
70386: NEG
70387: PUSH
70388: EMPTY
70389: LIST
70390: LIST
70391: PUSH
70392: LD_INT 1
70394: NEG
70395: PUSH
70396: LD_INT 2
70398: NEG
70399: PUSH
70400: EMPTY
70401: LIST
70402: LIST
70403: PUSH
70404: LD_INT 1
70406: PUSH
70407: LD_INT 1
70409: NEG
70410: PUSH
70411: EMPTY
70412: LIST
70413: LIST
70414: PUSH
70415: LD_INT 2
70417: PUSH
70418: LD_INT 0
70420: PUSH
70421: EMPTY
70422: LIST
70423: LIST
70424: PUSH
70425: LD_INT 2
70427: PUSH
70428: LD_INT 1
70430: PUSH
70431: EMPTY
70432: LIST
70433: LIST
70434: PUSH
70435: LD_INT 2
70437: PUSH
70438: LD_INT 2
70440: PUSH
70441: EMPTY
70442: LIST
70443: LIST
70444: PUSH
70445: LD_INT 1
70447: PUSH
70448: LD_INT 2
70450: PUSH
70451: EMPTY
70452: LIST
70453: LIST
70454: PUSH
70455: LD_INT 0
70457: PUSH
70458: LD_INT 2
70460: PUSH
70461: EMPTY
70462: LIST
70463: LIST
70464: PUSH
70465: LD_INT 1
70467: NEG
70468: PUSH
70469: LD_INT 1
70471: PUSH
70472: EMPTY
70473: LIST
70474: LIST
70475: PUSH
70476: LD_INT 2
70478: NEG
70479: PUSH
70480: LD_INT 1
70482: NEG
70483: PUSH
70484: EMPTY
70485: LIST
70486: LIST
70487: PUSH
70488: LD_INT 2
70490: NEG
70491: PUSH
70492: LD_INT 2
70494: NEG
70495: PUSH
70496: EMPTY
70497: LIST
70498: LIST
70499: PUSH
70500: LD_INT 2
70502: NEG
70503: PUSH
70504: LD_INT 3
70506: NEG
70507: PUSH
70508: EMPTY
70509: LIST
70510: LIST
70511: PUSH
70512: LD_INT 2
70514: PUSH
70515: LD_INT 1
70517: NEG
70518: PUSH
70519: EMPTY
70520: LIST
70521: LIST
70522: PUSH
70523: LD_INT 3
70525: PUSH
70526: LD_INT 1
70528: PUSH
70529: EMPTY
70530: LIST
70531: LIST
70532: PUSH
70533: LD_INT 1
70535: PUSH
70536: LD_INT 3
70538: PUSH
70539: EMPTY
70540: LIST
70541: LIST
70542: PUSH
70543: LD_INT 1
70545: NEG
70546: PUSH
70547: LD_INT 2
70549: PUSH
70550: EMPTY
70551: LIST
70552: LIST
70553: PUSH
70554: LD_INT 3
70556: NEG
70557: PUSH
70558: LD_INT 2
70560: NEG
70561: PUSH
70562: EMPTY
70563: LIST
70564: LIST
70565: PUSH
70566: EMPTY
70567: LIST
70568: LIST
70569: LIST
70570: LIST
70571: LIST
70572: LIST
70573: LIST
70574: LIST
70575: LIST
70576: LIST
70577: LIST
70578: LIST
70579: LIST
70580: LIST
70581: LIST
70582: LIST
70583: LIST
70584: LIST
70585: LIST
70586: LIST
70587: LIST
70588: LIST
70589: LIST
70590: ST_TO_ADDR
// Factory3 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 1 , - 3 ] , [ 1 , - 2 ] , [ 3 , 2 ] , [ 2 , 3 ] , [ - 2 , 1 ] , [ - 3 , - 1 ] ] ;
70591: LD_ADDR_VAR 0 32
70595: PUSH
70596: LD_INT 0
70598: PUSH
70599: LD_INT 0
70601: PUSH
70602: EMPTY
70603: LIST
70604: LIST
70605: PUSH
70606: LD_INT 0
70608: PUSH
70609: LD_INT 1
70611: NEG
70612: PUSH
70613: EMPTY
70614: LIST
70615: LIST
70616: PUSH
70617: LD_INT 1
70619: PUSH
70620: LD_INT 0
70622: PUSH
70623: EMPTY
70624: LIST
70625: LIST
70626: PUSH
70627: LD_INT 1
70629: PUSH
70630: LD_INT 1
70632: PUSH
70633: EMPTY
70634: LIST
70635: LIST
70636: PUSH
70637: LD_INT 0
70639: PUSH
70640: LD_INT 1
70642: PUSH
70643: EMPTY
70644: LIST
70645: LIST
70646: PUSH
70647: LD_INT 1
70649: NEG
70650: PUSH
70651: LD_INT 0
70653: PUSH
70654: EMPTY
70655: LIST
70656: LIST
70657: PUSH
70658: LD_INT 1
70660: NEG
70661: PUSH
70662: LD_INT 1
70664: NEG
70665: PUSH
70666: EMPTY
70667: LIST
70668: LIST
70669: PUSH
70670: LD_INT 1
70672: NEG
70673: PUSH
70674: LD_INT 2
70676: NEG
70677: PUSH
70678: EMPTY
70679: LIST
70680: LIST
70681: PUSH
70682: LD_INT 0
70684: PUSH
70685: LD_INT 2
70687: NEG
70688: PUSH
70689: EMPTY
70690: LIST
70691: LIST
70692: PUSH
70693: LD_INT 1
70695: PUSH
70696: LD_INT 1
70698: NEG
70699: PUSH
70700: EMPTY
70701: LIST
70702: LIST
70703: PUSH
70704: LD_INT 2
70706: PUSH
70707: LD_INT 1
70709: PUSH
70710: EMPTY
70711: LIST
70712: LIST
70713: PUSH
70714: LD_INT 2
70716: PUSH
70717: LD_INT 2
70719: PUSH
70720: EMPTY
70721: LIST
70722: LIST
70723: PUSH
70724: LD_INT 1
70726: PUSH
70727: LD_INT 2
70729: PUSH
70730: EMPTY
70731: LIST
70732: LIST
70733: PUSH
70734: LD_INT 0
70736: PUSH
70737: LD_INT 2
70739: PUSH
70740: EMPTY
70741: LIST
70742: LIST
70743: PUSH
70744: LD_INT 1
70746: NEG
70747: PUSH
70748: LD_INT 1
70750: PUSH
70751: EMPTY
70752: LIST
70753: LIST
70754: PUSH
70755: LD_INT 2
70757: NEG
70758: PUSH
70759: LD_INT 0
70761: PUSH
70762: EMPTY
70763: LIST
70764: LIST
70765: PUSH
70766: LD_INT 2
70768: NEG
70769: PUSH
70770: LD_INT 1
70772: NEG
70773: PUSH
70774: EMPTY
70775: LIST
70776: LIST
70777: PUSH
70778: LD_INT 1
70780: NEG
70781: PUSH
70782: LD_INT 3
70784: NEG
70785: PUSH
70786: EMPTY
70787: LIST
70788: LIST
70789: PUSH
70790: LD_INT 1
70792: PUSH
70793: LD_INT 2
70795: NEG
70796: PUSH
70797: EMPTY
70798: LIST
70799: LIST
70800: PUSH
70801: LD_INT 3
70803: PUSH
70804: LD_INT 2
70806: PUSH
70807: EMPTY
70808: LIST
70809: LIST
70810: PUSH
70811: LD_INT 2
70813: PUSH
70814: LD_INT 3
70816: PUSH
70817: EMPTY
70818: LIST
70819: LIST
70820: PUSH
70821: LD_INT 2
70823: NEG
70824: PUSH
70825: LD_INT 1
70827: PUSH
70828: EMPTY
70829: LIST
70830: LIST
70831: PUSH
70832: LD_INT 3
70834: NEG
70835: PUSH
70836: LD_INT 1
70838: NEG
70839: PUSH
70840: EMPTY
70841: LIST
70842: LIST
70843: PUSH
70844: EMPTY
70845: LIST
70846: LIST
70847: LIST
70848: LIST
70849: LIST
70850: LIST
70851: LIST
70852: LIST
70853: LIST
70854: LIST
70855: LIST
70856: LIST
70857: LIST
70858: LIST
70859: LIST
70860: LIST
70861: LIST
70862: LIST
70863: LIST
70864: LIST
70865: LIST
70866: LIST
70867: LIST
70868: ST_TO_ADDR
// Factory4 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ - 2 , - 3 ] , [ 2 , - 1 ] , [ 3 , 1 ] , [ 1 , 3 ] , [ - 1 , 2 ] , [ - 3 , - 2 ] ] ;
70869: LD_ADDR_VAR 0 33
70873: PUSH
70874: LD_INT 0
70876: PUSH
70877: LD_INT 0
70879: PUSH
70880: EMPTY
70881: LIST
70882: LIST
70883: PUSH
70884: LD_INT 0
70886: PUSH
70887: LD_INT 1
70889: NEG
70890: PUSH
70891: EMPTY
70892: LIST
70893: LIST
70894: PUSH
70895: LD_INT 1
70897: PUSH
70898: LD_INT 0
70900: PUSH
70901: EMPTY
70902: LIST
70903: LIST
70904: PUSH
70905: LD_INT 1
70907: PUSH
70908: LD_INT 1
70910: PUSH
70911: EMPTY
70912: LIST
70913: LIST
70914: PUSH
70915: LD_INT 0
70917: PUSH
70918: LD_INT 1
70920: PUSH
70921: EMPTY
70922: LIST
70923: LIST
70924: PUSH
70925: LD_INT 1
70927: NEG
70928: PUSH
70929: LD_INT 0
70931: PUSH
70932: EMPTY
70933: LIST
70934: LIST
70935: PUSH
70936: LD_INT 1
70938: NEG
70939: PUSH
70940: LD_INT 1
70942: NEG
70943: PUSH
70944: EMPTY
70945: LIST
70946: LIST
70947: PUSH
70948: LD_INT 1
70950: NEG
70951: PUSH
70952: LD_INT 2
70954: NEG
70955: PUSH
70956: EMPTY
70957: LIST
70958: LIST
70959: PUSH
70960: LD_INT 1
70962: PUSH
70963: LD_INT 1
70965: NEG
70966: PUSH
70967: EMPTY
70968: LIST
70969: LIST
70970: PUSH
70971: LD_INT 2
70973: PUSH
70974: LD_INT 0
70976: PUSH
70977: EMPTY
70978: LIST
70979: LIST
70980: PUSH
70981: LD_INT 2
70983: PUSH
70984: LD_INT 1
70986: PUSH
70987: EMPTY
70988: LIST
70989: LIST
70990: PUSH
70991: LD_INT 1
70993: PUSH
70994: LD_INT 2
70996: PUSH
70997: EMPTY
70998: LIST
70999: LIST
71000: PUSH
71001: LD_INT 0
71003: PUSH
71004: LD_INT 2
71006: PUSH
71007: EMPTY
71008: LIST
71009: LIST
71010: PUSH
71011: LD_INT 1
71013: NEG
71014: PUSH
71015: LD_INT 1
71017: PUSH
71018: EMPTY
71019: LIST
71020: LIST
71021: PUSH
71022: LD_INT 2
71024: NEG
71025: PUSH
71026: LD_INT 0
71028: PUSH
71029: EMPTY
71030: LIST
71031: LIST
71032: PUSH
71033: LD_INT 2
71035: NEG
71036: PUSH
71037: LD_INT 1
71039: NEG
71040: PUSH
71041: EMPTY
71042: LIST
71043: LIST
71044: PUSH
71045: LD_INT 2
71047: NEG
71048: PUSH
71049: LD_INT 2
71051: NEG
71052: PUSH
71053: EMPTY
71054: LIST
71055: LIST
71056: PUSH
71057: LD_INT 2
71059: NEG
71060: PUSH
71061: LD_INT 3
71063: NEG
71064: PUSH
71065: EMPTY
71066: LIST
71067: LIST
71068: PUSH
71069: LD_INT 2
71071: PUSH
71072: LD_INT 1
71074: NEG
71075: PUSH
71076: EMPTY
71077: LIST
71078: LIST
71079: PUSH
71080: LD_INT 3
71082: PUSH
71083: LD_INT 1
71085: PUSH
71086: EMPTY
71087: LIST
71088: LIST
71089: PUSH
71090: LD_INT 1
71092: PUSH
71093: LD_INT 3
71095: PUSH
71096: EMPTY
71097: LIST
71098: LIST
71099: PUSH
71100: LD_INT 1
71102: NEG
71103: PUSH
71104: LD_INT 2
71106: PUSH
71107: EMPTY
71108: LIST
71109: LIST
71110: PUSH
71111: LD_INT 3
71113: NEG
71114: PUSH
71115: LD_INT 2
71117: NEG
71118: PUSH
71119: EMPTY
71120: LIST
71121: LIST
71122: PUSH
71123: EMPTY
71124: LIST
71125: LIST
71126: LIST
71127: LIST
71128: LIST
71129: LIST
71130: LIST
71131: LIST
71132: LIST
71133: LIST
71134: LIST
71135: LIST
71136: LIST
71137: LIST
71138: LIST
71139: LIST
71140: LIST
71141: LIST
71142: LIST
71143: LIST
71144: LIST
71145: LIST
71146: LIST
71147: ST_TO_ADDR
// Factory5 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ - 1 , - 3 ] , [ 1 , - 2 ] , [ 3 , 2 ] , [ 2 , 3 ] , [ - 2 , 1 ] , [ - 3 , - 1 ] ] ;
71148: LD_ADDR_VAR 0 34
71152: PUSH
71153: LD_INT 0
71155: PUSH
71156: LD_INT 0
71158: PUSH
71159: EMPTY
71160: LIST
71161: LIST
71162: PUSH
71163: LD_INT 0
71165: PUSH
71166: LD_INT 1
71168: NEG
71169: PUSH
71170: EMPTY
71171: LIST
71172: LIST
71173: PUSH
71174: LD_INT 1
71176: PUSH
71177: LD_INT 0
71179: PUSH
71180: EMPTY
71181: LIST
71182: LIST
71183: PUSH
71184: LD_INT 1
71186: PUSH
71187: LD_INT 1
71189: PUSH
71190: EMPTY
71191: LIST
71192: LIST
71193: PUSH
71194: LD_INT 0
71196: PUSH
71197: LD_INT 1
71199: PUSH
71200: EMPTY
71201: LIST
71202: LIST
71203: PUSH
71204: LD_INT 1
71206: NEG
71207: PUSH
71208: LD_INT 0
71210: PUSH
71211: EMPTY
71212: LIST
71213: LIST
71214: PUSH
71215: LD_INT 1
71217: NEG
71218: PUSH
71219: LD_INT 1
71221: NEG
71222: PUSH
71223: EMPTY
71224: LIST
71225: LIST
71226: PUSH
71227: LD_INT 1
71229: NEG
71230: PUSH
71231: LD_INT 2
71233: NEG
71234: PUSH
71235: EMPTY
71236: LIST
71237: LIST
71238: PUSH
71239: LD_INT 0
71241: PUSH
71242: LD_INT 2
71244: NEG
71245: PUSH
71246: EMPTY
71247: LIST
71248: LIST
71249: PUSH
71250: LD_INT 1
71252: PUSH
71253: LD_INT 1
71255: NEG
71256: PUSH
71257: EMPTY
71258: LIST
71259: LIST
71260: PUSH
71261: LD_INT 2
71263: PUSH
71264: LD_INT 1
71266: PUSH
71267: EMPTY
71268: LIST
71269: LIST
71270: PUSH
71271: LD_INT 2
71273: PUSH
71274: LD_INT 2
71276: PUSH
71277: EMPTY
71278: LIST
71279: LIST
71280: PUSH
71281: LD_INT 1
71283: PUSH
71284: LD_INT 2
71286: PUSH
71287: EMPTY
71288: LIST
71289: LIST
71290: PUSH
71291: LD_INT 1
71293: NEG
71294: PUSH
71295: LD_INT 1
71297: PUSH
71298: EMPTY
71299: LIST
71300: LIST
71301: PUSH
71302: LD_INT 2
71304: NEG
71305: PUSH
71306: LD_INT 0
71308: PUSH
71309: EMPTY
71310: LIST
71311: LIST
71312: PUSH
71313: LD_INT 2
71315: NEG
71316: PUSH
71317: LD_INT 1
71319: NEG
71320: PUSH
71321: EMPTY
71322: LIST
71323: LIST
71324: PUSH
71325: LD_INT 2
71327: NEG
71328: PUSH
71329: LD_INT 2
71331: NEG
71332: PUSH
71333: EMPTY
71334: LIST
71335: LIST
71336: PUSH
71337: LD_INT 1
71339: NEG
71340: PUSH
71341: LD_INT 3
71343: NEG
71344: PUSH
71345: EMPTY
71346: LIST
71347: LIST
71348: PUSH
71349: LD_INT 1
71351: PUSH
71352: LD_INT 2
71354: NEG
71355: PUSH
71356: EMPTY
71357: LIST
71358: LIST
71359: PUSH
71360: LD_INT 3
71362: PUSH
71363: LD_INT 2
71365: PUSH
71366: EMPTY
71367: LIST
71368: LIST
71369: PUSH
71370: LD_INT 2
71372: PUSH
71373: LD_INT 3
71375: PUSH
71376: EMPTY
71377: LIST
71378: LIST
71379: PUSH
71380: LD_INT 2
71382: NEG
71383: PUSH
71384: LD_INT 1
71386: PUSH
71387: EMPTY
71388: LIST
71389: LIST
71390: PUSH
71391: LD_INT 3
71393: NEG
71394: PUSH
71395: LD_INT 1
71397: NEG
71398: PUSH
71399: EMPTY
71400: LIST
71401: LIST
71402: PUSH
71403: EMPTY
71404: LIST
71405: LIST
71406: LIST
71407: LIST
71408: LIST
71409: LIST
71410: LIST
71411: LIST
71412: LIST
71413: LIST
71414: LIST
71415: LIST
71416: LIST
71417: LIST
71418: LIST
71419: LIST
71420: LIST
71421: LIST
71422: LIST
71423: LIST
71424: LIST
71425: LIST
71426: LIST
71427: ST_TO_ADDR
// Ext0 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ 2 , 1 ] , [ - 2 , - 1 ] ] ;
71428: LD_ADDR_VAR 0 35
71432: PUSH
71433: LD_INT 0
71435: PUSH
71436: LD_INT 0
71438: PUSH
71439: EMPTY
71440: LIST
71441: LIST
71442: PUSH
71443: LD_INT 0
71445: PUSH
71446: LD_INT 1
71448: NEG
71449: PUSH
71450: EMPTY
71451: LIST
71452: LIST
71453: PUSH
71454: LD_INT 1
71456: PUSH
71457: LD_INT 0
71459: PUSH
71460: EMPTY
71461: LIST
71462: LIST
71463: PUSH
71464: LD_INT 1
71466: PUSH
71467: LD_INT 1
71469: PUSH
71470: EMPTY
71471: LIST
71472: LIST
71473: PUSH
71474: LD_INT 0
71476: PUSH
71477: LD_INT 1
71479: PUSH
71480: EMPTY
71481: LIST
71482: LIST
71483: PUSH
71484: LD_INT 1
71486: NEG
71487: PUSH
71488: LD_INT 0
71490: PUSH
71491: EMPTY
71492: LIST
71493: LIST
71494: PUSH
71495: LD_INT 1
71497: NEG
71498: PUSH
71499: LD_INT 1
71501: NEG
71502: PUSH
71503: EMPTY
71504: LIST
71505: LIST
71506: PUSH
71507: LD_INT 2
71509: PUSH
71510: LD_INT 1
71512: PUSH
71513: EMPTY
71514: LIST
71515: LIST
71516: PUSH
71517: LD_INT 2
71519: NEG
71520: PUSH
71521: LD_INT 1
71523: NEG
71524: PUSH
71525: EMPTY
71526: LIST
71527: LIST
71528: PUSH
71529: EMPTY
71530: LIST
71531: LIST
71532: LIST
71533: LIST
71534: LIST
71535: LIST
71536: LIST
71537: LIST
71538: LIST
71539: ST_TO_ADDR
// Ext1 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 1 , 2 ] ] ;
71540: LD_ADDR_VAR 0 36
71544: PUSH
71545: LD_INT 0
71547: PUSH
71548: LD_INT 0
71550: PUSH
71551: EMPTY
71552: LIST
71553: LIST
71554: PUSH
71555: LD_INT 0
71557: PUSH
71558: LD_INT 1
71560: NEG
71561: PUSH
71562: EMPTY
71563: LIST
71564: LIST
71565: PUSH
71566: LD_INT 1
71568: PUSH
71569: LD_INT 0
71571: PUSH
71572: EMPTY
71573: LIST
71574: LIST
71575: PUSH
71576: LD_INT 1
71578: PUSH
71579: LD_INT 1
71581: PUSH
71582: EMPTY
71583: LIST
71584: LIST
71585: PUSH
71586: LD_INT 0
71588: PUSH
71589: LD_INT 1
71591: PUSH
71592: EMPTY
71593: LIST
71594: LIST
71595: PUSH
71596: LD_INT 1
71598: NEG
71599: PUSH
71600: LD_INT 0
71602: PUSH
71603: EMPTY
71604: LIST
71605: LIST
71606: PUSH
71607: LD_INT 1
71609: NEG
71610: PUSH
71611: LD_INT 1
71613: NEG
71614: PUSH
71615: EMPTY
71616: LIST
71617: LIST
71618: PUSH
71619: LD_INT 1
71621: NEG
71622: PUSH
71623: LD_INT 2
71625: NEG
71626: PUSH
71627: EMPTY
71628: LIST
71629: LIST
71630: PUSH
71631: LD_INT 1
71633: PUSH
71634: LD_INT 2
71636: PUSH
71637: EMPTY
71638: LIST
71639: LIST
71640: PUSH
71641: EMPTY
71642: LIST
71643: LIST
71644: LIST
71645: LIST
71646: LIST
71647: LIST
71648: LIST
71649: LIST
71650: LIST
71651: ST_TO_ADDR
// Ext2 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ 1 , - 1 ] , [ - 1 , 1 ] ] ;
71652: LD_ADDR_VAR 0 37
71656: PUSH
71657: LD_INT 0
71659: PUSH
71660: LD_INT 0
71662: PUSH
71663: EMPTY
71664: LIST
71665: LIST
71666: PUSH
71667: LD_INT 0
71669: PUSH
71670: LD_INT 1
71672: NEG
71673: PUSH
71674: EMPTY
71675: LIST
71676: LIST
71677: PUSH
71678: LD_INT 1
71680: PUSH
71681: LD_INT 0
71683: PUSH
71684: EMPTY
71685: LIST
71686: LIST
71687: PUSH
71688: LD_INT 1
71690: PUSH
71691: LD_INT 1
71693: PUSH
71694: EMPTY
71695: LIST
71696: LIST
71697: PUSH
71698: LD_INT 0
71700: PUSH
71701: LD_INT 1
71703: PUSH
71704: EMPTY
71705: LIST
71706: LIST
71707: PUSH
71708: LD_INT 1
71710: NEG
71711: PUSH
71712: LD_INT 0
71714: PUSH
71715: EMPTY
71716: LIST
71717: LIST
71718: PUSH
71719: LD_INT 1
71721: NEG
71722: PUSH
71723: LD_INT 1
71725: NEG
71726: PUSH
71727: EMPTY
71728: LIST
71729: LIST
71730: PUSH
71731: LD_INT 1
71733: PUSH
71734: LD_INT 1
71736: NEG
71737: PUSH
71738: EMPTY
71739: LIST
71740: LIST
71741: PUSH
71742: LD_INT 1
71744: NEG
71745: PUSH
71746: LD_INT 1
71748: PUSH
71749: EMPTY
71750: LIST
71751: LIST
71752: PUSH
71753: EMPTY
71754: LIST
71755: LIST
71756: LIST
71757: LIST
71758: LIST
71759: LIST
71760: LIST
71761: LIST
71762: LIST
71763: ST_TO_ADDR
// Ext3 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ 2 , 1 ] , [ - 2 , - 1 ] ] ;
71764: LD_ADDR_VAR 0 38
71768: PUSH
71769: LD_INT 0
71771: PUSH
71772: LD_INT 0
71774: PUSH
71775: EMPTY
71776: LIST
71777: LIST
71778: PUSH
71779: LD_INT 0
71781: PUSH
71782: LD_INT 1
71784: NEG
71785: PUSH
71786: EMPTY
71787: LIST
71788: LIST
71789: PUSH
71790: LD_INT 1
71792: PUSH
71793: LD_INT 0
71795: PUSH
71796: EMPTY
71797: LIST
71798: LIST
71799: PUSH
71800: LD_INT 1
71802: PUSH
71803: LD_INT 1
71805: PUSH
71806: EMPTY
71807: LIST
71808: LIST
71809: PUSH
71810: LD_INT 0
71812: PUSH
71813: LD_INT 1
71815: PUSH
71816: EMPTY
71817: LIST
71818: LIST
71819: PUSH
71820: LD_INT 1
71822: NEG
71823: PUSH
71824: LD_INT 0
71826: PUSH
71827: EMPTY
71828: LIST
71829: LIST
71830: PUSH
71831: LD_INT 1
71833: NEG
71834: PUSH
71835: LD_INT 1
71837: NEG
71838: PUSH
71839: EMPTY
71840: LIST
71841: LIST
71842: PUSH
71843: LD_INT 2
71845: PUSH
71846: LD_INT 1
71848: PUSH
71849: EMPTY
71850: LIST
71851: LIST
71852: PUSH
71853: LD_INT 2
71855: NEG
71856: PUSH
71857: LD_INT 1
71859: NEG
71860: PUSH
71861: EMPTY
71862: LIST
71863: LIST
71864: PUSH
71865: EMPTY
71866: LIST
71867: LIST
71868: LIST
71869: LIST
71870: LIST
71871: LIST
71872: LIST
71873: LIST
71874: LIST
71875: ST_TO_ADDR
// Ext4 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 1 , 2 ] ] ;
71876: LD_ADDR_VAR 0 39
71880: PUSH
71881: LD_INT 0
71883: PUSH
71884: LD_INT 0
71886: PUSH
71887: EMPTY
71888: LIST
71889: LIST
71890: PUSH
71891: LD_INT 0
71893: PUSH
71894: LD_INT 1
71896: NEG
71897: PUSH
71898: EMPTY
71899: LIST
71900: LIST
71901: PUSH
71902: LD_INT 1
71904: PUSH
71905: LD_INT 0
71907: PUSH
71908: EMPTY
71909: LIST
71910: LIST
71911: PUSH
71912: LD_INT 1
71914: PUSH
71915: LD_INT 1
71917: PUSH
71918: EMPTY
71919: LIST
71920: LIST
71921: PUSH
71922: LD_INT 0
71924: PUSH
71925: LD_INT 1
71927: PUSH
71928: EMPTY
71929: LIST
71930: LIST
71931: PUSH
71932: LD_INT 1
71934: NEG
71935: PUSH
71936: LD_INT 0
71938: PUSH
71939: EMPTY
71940: LIST
71941: LIST
71942: PUSH
71943: LD_INT 1
71945: NEG
71946: PUSH
71947: LD_INT 1
71949: NEG
71950: PUSH
71951: EMPTY
71952: LIST
71953: LIST
71954: PUSH
71955: LD_INT 1
71957: NEG
71958: PUSH
71959: LD_INT 2
71961: NEG
71962: PUSH
71963: EMPTY
71964: LIST
71965: LIST
71966: PUSH
71967: LD_INT 1
71969: PUSH
71970: LD_INT 2
71972: PUSH
71973: EMPTY
71974: LIST
71975: LIST
71976: PUSH
71977: EMPTY
71978: LIST
71979: LIST
71980: LIST
71981: LIST
71982: LIST
71983: LIST
71984: LIST
71985: LIST
71986: LIST
71987: ST_TO_ADDR
// Ext5 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ 1 , - 1 ] , [ - 1 , 1 ] ] ;
71988: LD_ADDR_VAR 0 40
71992: PUSH
71993: LD_INT 0
71995: PUSH
71996: LD_INT 0
71998: PUSH
71999: EMPTY
72000: LIST
72001: LIST
72002: PUSH
72003: LD_INT 0
72005: PUSH
72006: LD_INT 1
72008: NEG
72009: PUSH
72010: EMPTY
72011: LIST
72012: LIST
72013: PUSH
72014: LD_INT 1
72016: PUSH
72017: LD_INT 0
72019: PUSH
72020: EMPTY
72021: LIST
72022: LIST
72023: PUSH
72024: LD_INT 1
72026: PUSH
72027: LD_INT 1
72029: PUSH
72030: EMPTY
72031: LIST
72032: LIST
72033: PUSH
72034: LD_INT 0
72036: PUSH
72037: LD_INT 1
72039: PUSH
72040: EMPTY
72041: LIST
72042: LIST
72043: PUSH
72044: LD_INT 1
72046: NEG
72047: PUSH
72048: LD_INT 0
72050: PUSH
72051: EMPTY
72052: LIST
72053: LIST
72054: PUSH
72055: LD_INT 1
72057: NEG
72058: PUSH
72059: LD_INT 1
72061: NEG
72062: PUSH
72063: EMPTY
72064: LIST
72065: LIST
72066: PUSH
72067: LD_INT 1
72069: PUSH
72070: LD_INT 1
72072: NEG
72073: PUSH
72074: EMPTY
72075: LIST
72076: LIST
72077: PUSH
72078: LD_INT 1
72080: NEG
72081: PUSH
72082: LD_INT 1
72084: PUSH
72085: EMPTY
72086: LIST
72087: LIST
72088: PUSH
72089: EMPTY
72090: LIST
72091: LIST
72092: LIST
72093: LIST
72094: LIST
72095: LIST
72096: LIST
72097: LIST
72098: LIST
72099: ST_TO_ADDR
// Lab0 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ - 2 , - 3 ] , [ 2 , - 1 ] , [ 3 , 0 ] , [ 3 , 1 ] , [ 3 , 2 ] , [ 3 , 3 ] , [ 2 , 3 ] , [ - 2 , 1 ] , [ - 3 , 0 ] , [ - 3 , - 1 ] , [ - 3 , - 2 ] , [ - 3 , - 3 ] ] ;
72100: LD_ADDR_VAR 0 41
72104: PUSH
72105: LD_INT 0
72107: PUSH
72108: LD_INT 0
72110: PUSH
72111: EMPTY
72112: LIST
72113: LIST
72114: PUSH
72115: LD_INT 0
72117: PUSH
72118: LD_INT 1
72120: NEG
72121: PUSH
72122: EMPTY
72123: LIST
72124: LIST
72125: PUSH
72126: LD_INT 1
72128: PUSH
72129: LD_INT 0
72131: PUSH
72132: EMPTY
72133: LIST
72134: LIST
72135: PUSH
72136: LD_INT 1
72138: PUSH
72139: LD_INT 1
72141: PUSH
72142: EMPTY
72143: LIST
72144: LIST
72145: PUSH
72146: LD_INT 0
72148: PUSH
72149: LD_INT 1
72151: PUSH
72152: EMPTY
72153: LIST
72154: LIST
72155: PUSH
72156: LD_INT 1
72158: NEG
72159: PUSH
72160: LD_INT 0
72162: PUSH
72163: EMPTY
72164: LIST
72165: LIST
72166: PUSH
72167: LD_INT 1
72169: NEG
72170: PUSH
72171: LD_INT 1
72173: NEG
72174: PUSH
72175: EMPTY
72176: LIST
72177: LIST
72178: PUSH
72179: LD_INT 1
72181: NEG
72182: PUSH
72183: LD_INT 2
72185: NEG
72186: PUSH
72187: EMPTY
72188: LIST
72189: LIST
72190: PUSH
72191: LD_INT 1
72193: PUSH
72194: LD_INT 1
72196: NEG
72197: PUSH
72198: EMPTY
72199: LIST
72200: LIST
72201: PUSH
72202: LD_INT 2
72204: PUSH
72205: LD_INT 0
72207: PUSH
72208: EMPTY
72209: LIST
72210: LIST
72211: PUSH
72212: LD_INT 2
72214: PUSH
72215: LD_INT 1
72217: PUSH
72218: EMPTY
72219: LIST
72220: LIST
72221: PUSH
72222: LD_INT 2
72224: PUSH
72225: LD_INT 2
72227: PUSH
72228: EMPTY
72229: LIST
72230: LIST
72231: PUSH
72232: LD_INT 1
72234: PUSH
72235: LD_INT 2
72237: PUSH
72238: EMPTY
72239: LIST
72240: LIST
72241: PUSH
72242: LD_INT 1
72244: NEG
72245: PUSH
72246: LD_INT 1
72248: PUSH
72249: EMPTY
72250: LIST
72251: LIST
72252: PUSH
72253: LD_INT 2
72255: NEG
72256: PUSH
72257: LD_INT 0
72259: PUSH
72260: EMPTY
72261: LIST
72262: LIST
72263: PUSH
72264: LD_INT 2
72266: NEG
72267: PUSH
72268: LD_INT 1
72270: NEG
72271: PUSH
72272: EMPTY
72273: LIST
72274: LIST
72275: PUSH
72276: LD_INT 2
72278: NEG
72279: PUSH
72280: LD_INT 2
72282: NEG
72283: PUSH
72284: EMPTY
72285: LIST
72286: LIST
72287: PUSH
72288: LD_INT 2
72290: NEG
72291: PUSH
72292: LD_INT 3
72294: NEG
72295: PUSH
72296: EMPTY
72297: LIST
72298: LIST
72299: PUSH
72300: LD_INT 2
72302: PUSH
72303: LD_INT 1
72305: NEG
72306: PUSH
72307: EMPTY
72308: LIST
72309: LIST
72310: PUSH
72311: LD_INT 3
72313: PUSH
72314: LD_INT 0
72316: PUSH
72317: EMPTY
72318: LIST
72319: LIST
72320: PUSH
72321: LD_INT 3
72323: PUSH
72324: LD_INT 1
72326: PUSH
72327: EMPTY
72328: LIST
72329: LIST
72330: PUSH
72331: LD_INT 3
72333: PUSH
72334: LD_INT 2
72336: PUSH
72337: EMPTY
72338: LIST
72339: LIST
72340: PUSH
72341: LD_INT 3
72343: PUSH
72344: LD_INT 3
72346: PUSH
72347: EMPTY
72348: LIST
72349: LIST
72350: PUSH
72351: LD_INT 2
72353: PUSH
72354: LD_INT 3
72356: PUSH
72357: EMPTY
72358: LIST
72359: LIST
72360: PUSH
72361: LD_INT 2
72363: NEG
72364: PUSH
72365: LD_INT 1
72367: PUSH
72368: EMPTY
72369: LIST
72370: LIST
72371: PUSH
72372: LD_INT 3
72374: NEG
72375: PUSH
72376: LD_INT 0
72378: PUSH
72379: EMPTY
72380: LIST
72381: LIST
72382: PUSH
72383: LD_INT 3
72385: NEG
72386: PUSH
72387: LD_INT 1
72389: NEG
72390: PUSH
72391: EMPTY
72392: LIST
72393: LIST
72394: PUSH
72395: LD_INT 3
72397: NEG
72398: PUSH
72399: LD_INT 2
72401: NEG
72402: PUSH
72403: EMPTY
72404: LIST
72405: LIST
72406: PUSH
72407: LD_INT 3
72409: NEG
72410: PUSH
72411: LD_INT 3
72413: NEG
72414: PUSH
72415: EMPTY
72416: LIST
72417: LIST
72418: PUSH
72419: EMPTY
72420: LIST
72421: LIST
72422: LIST
72423: LIST
72424: LIST
72425: LIST
72426: LIST
72427: LIST
72428: LIST
72429: LIST
72430: LIST
72431: LIST
72432: LIST
72433: LIST
72434: LIST
72435: LIST
72436: LIST
72437: LIST
72438: LIST
72439: LIST
72440: LIST
72441: LIST
72442: LIST
72443: LIST
72444: LIST
72445: LIST
72446: LIST
72447: LIST
72448: LIST
72449: ST_TO_ADDR
// Lab1 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ - 2 , - 3 ] , [ - 1 , - 3 ] , [ 0 , - 3 ] , [ 1 , - 2 ] , [ 3 , 2 ] , [ 3 , 3 ] , [ 2 , 3 ] , [ 1 , 3 ] , [ 0 , 3 ] , [ - 1 , 2 ] , [ - 3 , - 2 ] , [ - 3 , - 3 ] ] ;
72450: LD_ADDR_VAR 0 42
72454: PUSH
72455: LD_INT 0
72457: PUSH
72458: LD_INT 0
72460: PUSH
72461: EMPTY
72462: LIST
72463: LIST
72464: PUSH
72465: LD_INT 0
72467: PUSH
72468: LD_INT 1
72470: NEG
72471: PUSH
72472: EMPTY
72473: LIST
72474: LIST
72475: PUSH
72476: LD_INT 1
72478: PUSH
72479: LD_INT 0
72481: PUSH
72482: EMPTY
72483: LIST
72484: LIST
72485: PUSH
72486: LD_INT 1
72488: PUSH
72489: LD_INT 1
72491: PUSH
72492: EMPTY
72493: LIST
72494: LIST
72495: PUSH
72496: LD_INT 0
72498: PUSH
72499: LD_INT 1
72501: PUSH
72502: EMPTY
72503: LIST
72504: LIST
72505: PUSH
72506: LD_INT 1
72508: NEG
72509: PUSH
72510: LD_INT 0
72512: PUSH
72513: EMPTY
72514: LIST
72515: LIST
72516: PUSH
72517: LD_INT 1
72519: NEG
72520: PUSH
72521: LD_INT 1
72523: NEG
72524: PUSH
72525: EMPTY
72526: LIST
72527: LIST
72528: PUSH
72529: LD_INT 1
72531: NEG
72532: PUSH
72533: LD_INT 2
72535: NEG
72536: PUSH
72537: EMPTY
72538: LIST
72539: LIST
72540: PUSH
72541: LD_INT 0
72543: PUSH
72544: LD_INT 2
72546: NEG
72547: PUSH
72548: EMPTY
72549: LIST
72550: LIST
72551: PUSH
72552: LD_INT 1
72554: PUSH
72555: LD_INT 1
72557: NEG
72558: PUSH
72559: EMPTY
72560: LIST
72561: LIST
72562: PUSH
72563: LD_INT 2
72565: PUSH
72566: LD_INT 1
72568: PUSH
72569: EMPTY
72570: LIST
72571: LIST
72572: PUSH
72573: LD_INT 2
72575: PUSH
72576: LD_INT 2
72578: PUSH
72579: EMPTY
72580: LIST
72581: LIST
72582: PUSH
72583: LD_INT 1
72585: PUSH
72586: LD_INT 2
72588: PUSH
72589: EMPTY
72590: LIST
72591: LIST
72592: PUSH
72593: LD_INT 0
72595: PUSH
72596: LD_INT 2
72598: PUSH
72599: EMPTY
72600: LIST
72601: LIST
72602: PUSH
72603: LD_INT 1
72605: NEG
72606: PUSH
72607: LD_INT 1
72609: PUSH
72610: EMPTY
72611: LIST
72612: LIST
72613: PUSH
72614: LD_INT 2
72616: NEG
72617: PUSH
72618: LD_INT 1
72620: NEG
72621: PUSH
72622: EMPTY
72623: LIST
72624: LIST
72625: PUSH
72626: LD_INT 2
72628: NEG
72629: PUSH
72630: LD_INT 2
72632: NEG
72633: PUSH
72634: EMPTY
72635: LIST
72636: LIST
72637: PUSH
72638: LD_INT 2
72640: NEG
72641: PUSH
72642: LD_INT 3
72644: NEG
72645: PUSH
72646: EMPTY
72647: LIST
72648: LIST
72649: PUSH
72650: LD_INT 1
72652: NEG
72653: PUSH
72654: LD_INT 3
72656: NEG
72657: PUSH
72658: EMPTY
72659: LIST
72660: LIST
72661: PUSH
72662: LD_INT 0
72664: PUSH
72665: LD_INT 3
72667: NEG
72668: PUSH
72669: EMPTY
72670: LIST
72671: LIST
72672: PUSH
72673: LD_INT 1
72675: PUSH
72676: LD_INT 2
72678: NEG
72679: PUSH
72680: EMPTY
72681: LIST
72682: LIST
72683: PUSH
72684: LD_INT 3
72686: PUSH
72687: LD_INT 2
72689: PUSH
72690: EMPTY
72691: LIST
72692: LIST
72693: PUSH
72694: LD_INT 3
72696: PUSH
72697: LD_INT 3
72699: PUSH
72700: EMPTY
72701: LIST
72702: LIST
72703: PUSH
72704: LD_INT 2
72706: PUSH
72707: LD_INT 3
72709: PUSH
72710: EMPTY
72711: LIST
72712: LIST
72713: PUSH
72714: LD_INT 1
72716: PUSH
72717: LD_INT 3
72719: PUSH
72720: EMPTY
72721: LIST
72722: LIST
72723: PUSH
72724: LD_INT 0
72726: PUSH
72727: LD_INT 3
72729: PUSH
72730: EMPTY
72731: LIST
72732: LIST
72733: PUSH
72734: LD_INT 1
72736: NEG
72737: PUSH
72738: LD_INT 2
72740: PUSH
72741: EMPTY
72742: LIST
72743: LIST
72744: PUSH
72745: LD_INT 3
72747: NEG
72748: PUSH
72749: LD_INT 2
72751: NEG
72752: PUSH
72753: EMPTY
72754: LIST
72755: LIST
72756: PUSH
72757: LD_INT 3
72759: NEG
72760: PUSH
72761: LD_INT 3
72763: NEG
72764: PUSH
72765: EMPTY
72766: LIST
72767: LIST
72768: PUSH
72769: EMPTY
72770: LIST
72771: LIST
72772: LIST
72773: LIST
72774: LIST
72775: LIST
72776: LIST
72777: LIST
72778: LIST
72779: LIST
72780: LIST
72781: LIST
72782: LIST
72783: LIST
72784: LIST
72785: LIST
72786: LIST
72787: LIST
72788: LIST
72789: LIST
72790: LIST
72791: LIST
72792: LIST
72793: LIST
72794: LIST
72795: LIST
72796: LIST
72797: LIST
72798: LIST
72799: ST_TO_ADDR
// Lab2 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 1 , - 3 ] , [ 0 , - 3 ] , [ 1 , - 2 ] , [ 2 , - 1 ] , [ 3 , 0 ] , [ 3 , 1 ] , [ 1 , 3 ] , [ 0 , 3 ] , [ - 1 , 2 ] , [ - 2 , 1 ] , [ - 3 , 0 ] , [ - 3 , - 1 ] ] ;
72800: LD_ADDR_VAR 0 43
72804: PUSH
72805: LD_INT 0
72807: PUSH
72808: LD_INT 0
72810: PUSH
72811: EMPTY
72812: LIST
72813: LIST
72814: PUSH
72815: LD_INT 0
72817: PUSH
72818: LD_INT 1
72820: NEG
72821: PUSH
72822: EMPTY
72823: LIST
72824: LIST
72825: PUSH
72826: LD_INT 1
72828: PUSH
72829: LD_INT 0
72831: PUSH
72832: EMPTY
72833: LIST
72834: LIST
72835: PUSH
72836: LD_INT 1
72838: PUSH
72839: LD_INT 1
72841: PUSH
72842: EMPTY
72843: LIST
72844: LIST
72845: PUSH
72846: LD_INT 0
72848: PUSH
72849: LD_INT 1
72851: PUSH
72852: EMPTY
72853: LIST
72854: LIST
72855: PUSH
72856: LD_INT 1
72858: NEG
72859: PUSH
72860: LD_INT 0
72862: PUSH
72863: EMPTY
72864: LIST
72865: LIST
72866: PUSH
72867: LD_INT 1
72869: NEG
72870: PUSH
72871: LD_INT 1
72873: NEG
72874: PUSH
72875: EMPTY
72876: LIST
72877: LIST
72878: PUSH
72879: LD_INT 1
72881: NEG
72882: PUSH
72883: LD_INT 2
72885: NEG
72886: PUSH
72887: EMPTY
72888: LIST
72889: LIST
72890: PUSH
72891: LD_INT 0
72893: PUSH
72894: LD_INT 2
72896: NEG
72897: PUSH
72898: EMPTY
72899: LIST
72900: LIST
72901: PUSH
72902: LD_INT 1
72904: PUSH
72905: LD_INT 1
72907: NEG
72908: PUSH
72909: EMPTY
72910: LIST
72911: LIST
72912: PUSH
72913: LD_INT 2
72915: PUSH
72916: LD_INT 0
72918: PUSH
72919: EMPTY
72920: LIST
72921: LIST
72922: PUSH
72923: LD_INT 2
72925: PUSH
72926: LD_INT 1
72928: PUSH
72929: EMPTY
72930: LIST
72931: LIST
72932: PUSH
72933: LD_INT 1
72935: PUSH
72936: LD_INT 2
72938: PUSH
72939: EMPTY
72940: LIST
72941: LIST
72942: PUSH
72943: LD_INT 0
72945: PUSH
72946: LD_INT 2
72948: PUSH
72949: EMPTY
72950: LIST
72951: LIST
72952: PUSH
72953: LD_INT 1
72955: NEG
72956: PUSH
72957: LD_INT 1
72959: PUSH
72960: EMPTY
72961: LIST
72962: LIST
72963: PUSH
72964: LD_INT 2
72966: NEG
72967: PUSH
72968: LD_INT 0
72970: PUSH
72971: EMPTY
72972: LIST
72973: LIST
72974: PUSH
72975: LD_INT 2
72977: NEG
72978: PUSH
72979: LD_INT 1
72981: NEG
72982: PUSH
72983: EMPTY
72984: LIST
72985: LIST
72986: PUSH
72987: LD_INT 1
72989: NEG
72990: PUSH
72991: LD_INT 3
72993: NEG
72994: PUSH
72995: EMPTY
72996: LIST
72997: LIST
72998: PUSH
72999: LD_INT 0
73001: PUSH
73002: LD_INT 3
73004: NEG
73005: PUSH
73006: EMPTY
73007: LIST
73008: LIST
73009: PUSH
73010: LD_INT 1
73012: PUSH
73013: LD_INT 2
73015: NEG
73016: PUSH
73017: EMPTY
73018: LIST
73019: LIST
73020: PUSH
73021: LD_INT 2
73023: PUSH
73024: LD_INT 1
73026: NEG
73027: PUSH
73028: EMPTY
73029: LIST
73030: LIST
73031: PUSH
73032: LD_INT 3
73034: PUSH
73035: LD_INT 0
73037: PUSH
73038: EMPTY
73039: LIST
73040: LIST
73041: PUSH
73042: LD_INT 3
73044: PUSH
73045: LD_INT 1
73047: PUSH
73048: EMPTY
73049: LIST
73050: LIST
73051: PUSH
73052: LD_INT 1
73054: PUSH
73055: LD_INT 3
73057: PUSH
73058: EMPTY
73059: LIST
73060: LIST
73061: PUSH
73062: LD_INT 0
73064: PUSH
73065: LD_INT 3
73067: PUSH
73068: EMPTY
73069: LIST
73070: LIST
73071: PUSH
73072: LD_INT 1
73074: NEG
73075: PUSH
73076: LD_INT 2
73078: PUSH
73079: EMPTY
73080: LIST
73081: LIST
73082: PUSH
73083: LD_INT 2
73085: NEG
73086: PUSH
73087: LD_INT 1
73089: PUSH
73090: EMPTY
73091: LIST
73092: LIST
73093: PUSH
73094: LD_INT 3
73096: NEG
73097: PUSH
73098: LD_INT 0
73100: PUSH
73101: EMPTY
73102: LIST
73103: LIST
73104: PUSH
73105: LD_INT 3
73107: NEG
73108: PUSH
73109: LD_INT 1
73111: NEG
73112: PUSH
73113: EMPTY
73114: LIST
73115: LIST
73116: PUSH
73117: EMPTY
73118: LIST
73119: LIST
73120: LIST
73121: LIST
73122: LIST
73123: LIST
73124: LIST
73125: LIST
73126: LIST
73127: LIST
73128: LIST
73129: LIST
73130: LIST
73131: LIST
73132: LIST
73133: LIST
73134: LIST
73135: LIST
73136: LIST
73137: LIST
73138: LIST
73139: LIST
73140: LIST
73141: LIST
73142: LIST
73143: LIST
73144: LIST
73145: LIST
73146: LIST
73147: ST_TO_ADDR
// Lab3 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ - 2 , - 3 ] , [ 2 , - 1 ] , [ 3 , 0 ] , [ 3 , 1 ] , [ 3 , 2 ] , [ 3 , 3 ] , [ 2 , 3 ] , [ - 2 , 1 ] , [ - 3 , 0 ] , [ - 3 , - 1 ] , [ - 3 , - 2 ] , [ - 3 , - 3 ] ] ;
73148: LD_ADDR_VAR 0 44
73152: PUSH
73153: LD_INT 0
73155: PUSH
73156: LD_INT 0
73158: PUSH
73159: EMPTY
73160: LIST
73161: LIST
73162: PUSH
73163: LD_INT 0
73165: PUSH
73166: LD_INT 1
73168: NEG
73169: PUSH
73170: EMPTY
73171: LIST
73172: LIST
73173: PUSH
73174: LD_INT 1
73176: PUSH
73177: LD_INT 0
73179: PUSH
73180: EMPTY
73181: LIST
73182: LIST
73183: PUSH
73184: LD_INT 1
73186: PUSH
73187: LD_INT 1
73189: PUSH
73190: EMPTY
73191: LIST
73192: LIST
73193: PUSH
73194: LD_INT 0
73196: PUSH
73197: LD_INT 1
73199: PUSH
73200: EMPTY
73201: LIST
73202: LIST
73203: PUSH
73204: LD_INT 1
73206: NEG
73207: PUSH
73208: LD_INT 0
73210: PUSH
73211: EMPTY
73212: LIST
73213: LIST
73214: PUSH
73215: LD_INT 1
73217: NEG
73218: PUSH
73219: LD_INT 1
73221: NEG
73222: PUSH
73223: EMPTY
73224: LIST
73225: LIST
73226: PUSH
73227: LD_INT 1
73229: NEG
73230: PUSH
73231: LD_INT 2
73233: NEG
73234: PUSH
73235: EMPTY
73236: LIST
73237: LIST
73238: PUSH
73239: LD_INT 1
73241: PUSH
73242: LD_INT 1
73244: NEG
73245: PUSH
73246: EMPTY
73247: LIST
73248: LIST
73249: PUSH
73250: LD_INT 2
73252: PUSH
73253: LD_INT 0
73255: PUSH
73256: EMPTY
73257: LIST
73258: LIST
73259: PUSH
73260: LD_INT 2
73262: PUSH
73263: LD_INT 1
73265: PUSH
73266: EMPTY
73267: LIST
73268: LIST
73269: PUSH
73270: LD_INT 2
73272: PUSH
73273: LD_INT 2
73275: PUSH
73276: EMPTY
73277: LIST
73278: LIST
73279: PUSH
73280: LD_INT 1
73282: PUSH
73283: LD_INT 2
73285: PUSH
73286: EMPTY
73287: LIST
73288: LIST
73289: PUSH
73290: LD_INT 1
73292: NEG
73293: PUSH
73294: LD_INT 1
73296: PUSH
73297: EMPTY
73298: LIST
73299: LIST
73300: PUSH
73301: LD_INT 2
73303: NEG
73304: PUSH
73305: LD_INT 0
73307: PUSH
73308: EMPTY
73309: LIST
73310: LIST
73311: PUSH
73312: LD_INT 2
73314: NEG
73315: PUSH
73316: LD_INT 1
73318: NEG
73319: PUSH
73320: EMPTY
73321: LIST
73322: LIST
73323: PUSH
73324: LD_INT 2
73326: NEG
73327: PUSH
73328: LD_INT 2
73330: NEG
73331: PUSH
73332: EMPTY
73333: LIST
73334: LIST
73335: PUSH
73336: LD_INT 2
73338: NEG
73339: PUSH
73340: LD_INT 3
73342: NEG
73343: PUSH
73344: EMPTY
73345: LIST
73346: LIST
73347: PUSH
73348: LD_INT 2
73350: PUSH
73351: LD_INT 1
73353: NEG
73354: PUSH
73355: EMPTY
73356: LIST
73357: LIST
73358: PUSH
73359: LD_INT 3
73361: PUSH
73362: LD_INT 0
73364: PUSH
73365: EMPTY
73366: LIST
73367: LIST
73368: PUSH
73369: LD_INT 3
73371: PUSH
73372: LD_INT 1
73374: PUSH
73375: EMPTY
73376: LIST
73377: LIST
73378: PUSH
73379: LD_INT 3
73381: PUSH
73382: LD_INT 2
73384: PUSH
73385: EMPTY
73386: LIST
73387: LIST
73388: PUSH
73389: LD_INT 3
73391: PUSH
73392: LD_INT 3
73394: PUSH
73395: EMPTY
73396: LIST
73397: LIST
73398: PUSH
73399: LD_INT 2
73401: PUSH
73402: LD_INT 3
73404: PUSH
73405: EMPTY
73406: LIST
73407: LIST
73408: PUSH
73409: LD_INT 2
73411: NEG
73412: PUSH
73413: LD_INT 1
73415: PUSH
73416: EMPTY
73417: LIST
73418: LIST
73419: PUSH
73420: LD_INT 3
73422: NEG
73423: PUSH
73424: LD_INT 0
73426: PUSH
73427: EMPTY
73428: LIST
73429: LIST
73430: PUSH
73431: LD_INT 3
73433: NEG
73434: PUSH
73435: LD_INT 1
73437: NEG
73438: PUSH
73439: EMPTY
73440: LIST
73441: LIST
73442: PUSH
73443: LD_INT 3
73445: NEG
73446: PUSH
73447: LD_INT 2
73449: NEG
73450: PUSH
73451: EMPTY
73452: LIST
73453: LIST
73454: PUSH
73455: LD_INT 3
73457: NEG
73458: PUSH
73459: LD_INT 3
73461: NEG
73462: PUSH
73463: EMPTY
73464: LIST
73465: LIST
73466: PUSH
73467: EMPTY
73468: LIST
73469: LIST
73470: LIST
73471: LIST
73472: LIST
73473: LIST
73474: LIST
73475: LIST
73476: LIST
73477: LIST
73478: LIST
73479: LIST
73480: LIST
73481: LIST
73482: LIST
73483: LIST
73484: LIST
73485: LIST
73486: LIST
73487: LIST
73488: LIST
73489: LIST
73490: LIST
73491: LIST
73492: LIST
73493: LIST
73494: LIST
73495: LIST
73496: LIST
73497: ST_TO_ADDR
// Lab4 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ - 2 , - 3 ] , [ - 1 , - 3 ] , [ 0 , - 3 ] , [ 1 , - 2 ] , [ 3 , 2 ] , [ 3 , 3 ] , [ 2 , 3 ] , [ 1 , 3 ] , [ 0 , 3 ] , [ - 1 , 2 ] , [ - 3 , - 2 ] , [ - 3 , - 3 ] ] ;
73498: LD_ADDR_VAR 0 45
73502: PUSH
73503: LD_INT 0
73505: PUSH
73506: LD_INT 0
73508: PUSH
73509: EMPTY
73510: LIST
73511: LIST
73512: PUSH
73513: LD_INT 0
73515: PUSH
73516: LD_INT 1
73518: NEG
73519: PUSH
73520: EMPTY
73521: LIST
73522: LIST
73523: PUSH
73524: LD_INT 1
73526: PUSH
73527: LD_INT 0
73529: PUSH
73530: EMPTY
73531: LIST
73532: LIST
73533: PUSH
73534: LD_INT 1
73536: PUSH
73537: LD_INT 1
73539: PUSH
73540: EMPTY
73541: LIST
73542: LIST
73543: PUSH
73544: LD_INT 0
73546: PUSH
73547: LD_INT 1
73549: PUSH
73550: EMPTY
73551: LIST
73552: LIST
73553: PUSH
73554: LD_INT 1
73556: NEG
73557: PUSH
73558: LD_INT 0
73560: PUSH
73561: EMPTY
73562: LIST
73563: LIST
73564: PUSH
73565: LD_INT 1
73567: NEG
73568: PUSH
73569: LD_INT 1
73571: NEG
73572: PUSH
73573: EMPTY
73574: LIST
73575: LIST
73576: PUSH
73577: LD_INT 1
73579: NEG
73580: PUSH
73581: LD_INT 2
73583: NEG
73584: PUSH
73585: EMPTY
73586: LIST
73587: LIST
73588: PUSH
73589: LD_INT 0
73591: PUSH
73592: LD_INT 2
73594: NEG
73595: PUSH
73596: EMPTY
73597: LIST
73598: LIST
73599: PUSH
73600: LD_INT 1
73602: PUSH
73603: LD_INT 1
73605: NEG
73606: PUSH
73607: EMPTY
73608: LIST
73609: LIST
73610: PUSH
73611: LD_INT 2
73613: PUSH
73614: LD_INT 1
73616: PUSH
73617: EMPTY
73618: LIST
73619: LIST
73620: PUSH
73621: LD_INT 2
73623: PUSH
73624: LD_INT 2
73626: PUSH
73627: EMPTY
73628: LIST
73629: LIST
73630: PUSH
73631: LD_INT 1
73633: PUSH
73634: LD_INT 2
73636: PUSH
73637: EMPTY
73638: LIST
73639: LIST
73640: PUSH
73641: LD_INT 0
73643: PUSH
73644: LD_INT 2
73646: PUSH
73647: EMPTY
73648: LIST
73649: LIST
73650: PUSH
73651: LD_INT 1
73653: NEG
73654: PUSH
73655: LD_INT 1
73657: PUSH
73658: EMPTY
73659: LIST
73660: LIST
73661: PUSH
73662: LD_INT 2
73664: NEG
73665: PUSH
73666: LD_INT 1
73668: NEG
73669: PUSH
73670: EMPTY
73671: LIST
73672: LIST
73673: PUSH
73674: LD_INT 2
73676: NEG
73677: PUSH
73678: LD_INT 2
73680: NEG
73681: PUSH
73682: EMPTY
73683: LIST
73684: LIST
73685: PUSH
73686: LD_INT 2
73688: NEG
73689: PUSH
73690: LD_INT 3
73692: NEG
73693: PUSH
73694: EMPTY
73695: LIST
73696: LIST
73697: PUSH
73698: LD_INT 1
73700: NEG
73701: PUSH
73702: LD_INT 3
73704: NEG
73705: PUSH
73706: EMPTY
73707: LIST
73708: LIST
73709: PUSH
73710: LD_INT 0
73712: PUSH
73713: LD_INT 3
73715: NEG
73716: PUSH
73717: EMPTY
73718: LIST
73719: LIST
73720: PUSH
73721: LD_INT 1
73723: PUSH
73724: LD_INT 2
73726: NEG
73727: PUSH
73728: EMPTY
73729: LIST
73730: LIST
73731: PUSH
73732: LD_INT 3
73734: PUSH
73735: LD_INT 2
73737: PUSH
73738: EMPTY
73739: LIST
73740: LIST
73741: PUSH
73742: LD_INT 3
73744: PUSH
73745: LD_INT 3
73747: PUSH
73748: EMPTY
73749: LIST
73750: LIST
73751: PUSH
73752: LD_INT 2
73754: PUSH
73755: LD_INT 3
73757: PUSH
73758: EMPTY
73759: LIST
73760: LIST
73761: PUSH
73762: LD_INT 1
73764: PUSH
73765: LD_INT 3
73767: PUSH
73768: EMPTY
73769: LIST
73770: LIST
73771: PUSH
73772: LD_INT 0
73774: PUSH
73775: LD_INT 3
73777: PUSH
73778: EMPTY
73779: LIST
73780: LIST
73781: PUSH
73782: LD_INT 1
73784: NEG
73785: PUSH
73786: LD_INT 2
73788: PUSH
73789: EMPTY
73790: LIST
73791: LIST
73792: PUSH
73793: LD_INT 3
73795: NEG
73796: PUSH
73797: LD_INT 2
73799: NEG
73800: PUSH
73801: EMPTY
73802: LIST
73803: LIST
73804: PUSH
73805: LD_INT 3
73807: NEG
73808: PUSH
73809: LD_INT 3
73811: NEG
73812: PUSH
73813: EMPTY
73814: LIST
73815: LIST
73816: PUSH
73817: EMPTY
73818: LIST
73819: LIST
73820: LIST
73821: LIST
73822: LIST
73823: LIST
73824: LIST
73825: LIST
73826: LIST
73827: LIST
73828: LIST
73829: LIST
73830: LIST
73831: LIST
73832: LIST
73833: LIST
73834: LIST
73835: LIST
73836: LIST
73837: LIST
73838: LIST
73839: LIST
73840: LIST
73841: LIST
73842: LIST
73843: LIST
73844: LIST
73845: LIST
73846: LIST
73847: ST_TO_ADDR
// Lab5 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 1 , - 3 ] , [ 0 , - 3 ] , [ 1 , - 2 ] , [ 2 , - 1 ] , [ 3 , 0 ] , [ 3 , 1 ] , [ 1 , 3 ] , [ 0 , 3 ] , [ - 1 , 2 ] , [ - 2 , 1 ] , [ - 3 , 0 ] , [ - 3 , - 1 ] ] ;
73848: LD_ADDR_VAR 0 46
73852: PUSH
73853: LD_INT 0
73855: PUSH
73856: LD_INT 0
73858: PUSH
73859: EMPTY
73860: LIST
73861: LIST
73862: PUSH
73863: LD_INT 0
73865: PUSH
73866: LD_INT 1
73868: NEG
73869: PUSH
73870: EMPTY
73871: LIST
73872: LIST
73873: PUSH
73874: LD_INT 1
73876: PUSH
73877: LD_INT 0
73879: PUSH
73880: EMPTY
73881: LIST
73882: LIST
73883: PUSH
73884: LD_INT 1
73886: PUSH
73887: LD_INT 1
73889: PUSH
73890: EMPTY
73891: LIST
73892: LIST
73893: PUSH
73894: LD_INT 0
73896: PUSH
73897: LD_INT 1
73899: PUSH
73900: EMPTY
73901: LIST
73902: LIST
73903: PUSH
73904: LD_INT 1
73906: NEG
73907: PUSH
73908: LD_INT 0
73910: PUSH
73911: EMPTY
73912: LIST
73913: LIST
73914: PUSH
73915: LD_INT 1
73917: NEG
73918: PUSH
73919: LD_INT 1
73921: NEG
73922: PUSH
73923: EMPTY
73924: LIST
73925: LIST
73926: PUSH
73927: LD_INT 1
73929: NEG
73930: PUSH
73931: LD_INT 2
73933: NEG
73934: PUSH
73935: EMPTY
73936: LIST
73937: LIST
73938: PUSH
73939: LD_INT 0
73941: PUSH
73942: LD_INT 2
73944: NEG
73945: PUSH
73946: EMPTY
73947: LIST
73948: LIST
73949: PUSH
73950: LD_INT 1
73952: PUSH
73953: LD_INT 1
73955: NEG
73956: PUSH
73957: EMPTY
73958: LIST
73959: LIST
73960: PUSH
73961: LD_INT 2
73963: PUSH
73964: LD_INT 0
73966: PUSH
73967: EMPTY
73968: LIST
73969: LIST
73970: PUSH
73971: LD_INT 2
73973: PUSH
73974: LD_INT 1
73976: PUSH
73977: EMPTY
73978: LIST
73979: LIST
73980: PUSH
73981: LD_INT 1
73983: PUSH
73984: LD_INT 2
73986: PUSH
73987: EMPTY
73988: LIST
73989: LIST
73990: PUSH
73991: LD_INT 0
73993: PUSH
73994: LD_INT 2
73996: PUSH
73997: EMPTY
73998: LIST
73999: LIST
74000: PUSH
74001: LD_INT 1
74003: NEG
74004: PUSH
74005: LD_INT 1
74007: PUSH
74008: EMPTY
74009: LIST
74010: LIST
74011: PUSH
74012: LD_INT 2
74014: NEG
74015: PUSH
74016: LD_INT 0
74018: PUSH
74019: EMPTY
74020: LIST
74021: LIST
74022: PUSH
74023: LD_INT 2
74025: NEG
74026: PUSH
74027: LD_INT 1
74029: NEG
74030: PUSH
74031: EMPTY
74032: LIST
74033: LIST
74034: PUSH
74035: LD_INT 1
74037: NEG
74038: PUSH
74039: LD_INT 3
74041: NEG
74042: PUSH
74043: EMPTY
74044: LIST
74045: LIST
74046: PUSH
74047: LD_INT 0
74049: PUSH
74050: LD_INT 3
74052: NEG
74053: PUSH
74054: EMPTY
74055: LIST
74056: LIST
74057: PUSH
74058: LD_INT 1
74060: PUSH
74061: LD_INT 2
74063: NEG
74064: PUSH
74065: EMPTY
74066: LIST
74067: LIST
74068: PUSH
74069: LD_INT 2
74071: PUSH
74072: LD_INT 1
74074: NEG
74075: PUSH
74076: EMPTY
74077: LIST
74078: LIST
74079: PUSH
74080: LD_INT 3
74082: PUSH
74083: LD_INT 0
74085: PUSH
74086: EMPTY
74087: LIST
74088: LIST
74089: PUSH
74090: LD_INT 3
74092: PUSH
74093: LD_INT 1
74095: PUSH
74096: EMPTY
74097: LIST
74098: LIST
74099: PUSH
74100: LD_INT 1
74102: PUSH
74103: LD_INT 3
74105: PUSH
74106: EMPTY
74107: LIST
74108: LIST
74109: PUSH
74110: LD_INT 0
74112: PUSH
74113: LD_INT 3
74115: PUSH
74116: EMPTY
74117: LIST
74118: LIST
74119: PUSH
74120: LD_INT 1
74122: NEG
74123: PUSH
74124: LD_INT 2
74126: PUSH
74127: EMPTY
74128: LIST
74129: LIST
74130: PUSH
74131: LD_INT 2
74133: NEG
74134: PUSH
74135: LD_INT 1
74137: PUSH
74138: EMPTY
74139: LIST
74140: LIST
74141: PUSH
74142: LD_INT 3
74144: NEG
74145: PUSH
74146: LD_INT 0
74148: PUSH
74149: EMPTY
74150: LIST
74151: LIST
74152: PUSH
74153: LD_INT 3
74155: NEG
74156: PUSH
74157: LD_INT 1
74159: NEG
74160: PUSH
74161: EMPTY
74162: LIST
74163: LIST
74164: PUSH
74165: EMPTY
74166: LIST
74167: LIST
74168: LIST
74169: LIST
74170: LIST
74171: LIST
74172: LIST
74173: LIST
74174: LIST
74175: LIST
74176: LIST
74177: LIST
74178: LIST
74179: LIST
74180: LIST
74181: LIST
74182: LIST
74183: LIST
74184: LIST
74185: LIST
74186: LIST
74187: LIST
74188: LIST
74189: LIST
74190: LIST
74191: LIST
74192: LIST
74193: LIST
74194: LIST
74195: ST_TO_ADDR
// ControlTower0 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
74196: LD_ADDR_VAR 0 47
74200: PUSH
74201: LD_INT 0
74203: PUSH
74204: LD_INT 0
74206: PUSH
74207: EMPTY
74208: LIST
74209: LIST
74210: PUSH
74211: LD_INT 0
74213: PUSH
74214: LD_INT 1
74216: NEG
74217: PUSH
74218: EMPTY
74219: LIST
74220: LIST
74221: PUSH
74222: LD_INT 1
74224: PUSH
74225: LD_INT 0
74227: PUSH
74228: EMPTY
74229: LIST
74230: LIST
74231: PUSH
74232: LD_INT 1
74234: PUSH
74235: LD_INT 1
74237: PUSH
74238: EMPTY
74239: LIST
74240: LIST
74241: PUSH
74242: LD_INT 0
74244: PUSH
74245: LD_INT 1
74247: PUSH
74248: EMPTY
74249: LIST
74250: LIST
74251: PUSH
74252: LD_INT 1
74254: NEG
74255: PUSH
74256: LD_INT 0
74258: PUSH
74259: EMPTY
74260: LIST
74261: LIST
74262: PUSH
74263: LD_INT 1
74265: NEG
74266: PUSH
74267: LD_INT 1
74269: NEG
74270: PUSH
74271: EMPTY
74272: LIST
74273: LIST
74274: PUSH
74275: LD_INT 1
74277: NEG
74278: PUSH
74279: LD_INT 2
74281: NEG
74282: PUSH
74283: EMPTY
74284: LIST
74285: LIST
74286: PUSH
74287: LD_INT 0
74289: PUSH
74290: LD_INT 2
74292: NEG
74293: PUSH
74294: EMPTY
74295: LIST
74296: LIST
74297: PUSH
74298: LD_INT 1
74300: PUSH
74301: LD_INT 1
74303: NEG
74304: PUSH
74305: EMPTY
74306: LIST
74307: LIST
74308: PUSH
74309: LD_INT 2
74311: NEG
74312: PUSH
74313: LD_INT 1
74315: NEG
74316: PUSH
74317: EMPTY
74318: LIST
74319: LIST
74320: PUSH
74321: LD_INT 2
74323: NEG
74324: PUSH
74325: LD_INT 2
74327: NEG
74328: PUSH
74329: EMPTY
74330: LIST
74331: LIST
74332: PUSH
74333: EMPTY
74334: LIST
74335: LIST
74336: LIST
74337: LIST
74338: LIST
74339: LIST
74340: LIST
74341: LIST
74342: LIST
74343: LIST
74344: LIST
74345: LIST
74346: ST_TO_ADDR
// ControlTower1 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] ] ;
74347: LD_ADDR_VAR 0 48
74351: PUSH
74352: LD_INT 0
74354: PUSH
74355: LD_INT 0
74357: PUSH
74358: EMPTY
74359: LIST
74360: LIST
74361: PUSH
74362: LD_INT 0
74364: PUSH
74365: LD_INT 1
74367: NEG
74368: PUSH
74369: EMPTY
74370: LIST
74371: LIST
74372: PUSH
74373: LD_INT 1
74375: PUSH
74376: LD_INT 0
74378: PUSH
74379: EMPTY
74380: LIST
74381: LIST
74382: PUSH
74383: LD_INT 1
74385: PUSH
74386: LD_INT 1
74388: PUSH
74389: EMPTY
74390: LIST
74391: LIST
74392: PUSH
74393: LD_INT 0
74395: PUSH
74396: LD_INT 1
74398: PUSH
74399: EMPTY
74400: LIST
74401: LIST
74402: PUSH
74403: LD_INT 1
74405: NEG
74406: PUSH
74407: LD_INT 0
74409: PUSH
74410: EMPTY
74411: LIST
74412: LIST
74413: PUSH
74414: LD_INT 1
74416: NEG
74417: PUSH
74418: LD_INT 1
74420: NEG
74421: PUSH
74422: EMPTY
74423: LIST
74424: LIST
74425: PUSH
74426: LD_INT 1
74428: NEG
74429: PUSH
74430: LD_INT 2
74432: NEG
74433: PUSH
74434: EMPTY
74435: LIST
74436: LIST
74437: PUSH
74438: LD_INT 0
74440: PUSH
74441: LD_INT 2
74443: NEG
74444: PUSH
74445: EMPTY
74446: LIST
74447: LIST
74448: PUSH
74449: LD_INT 1
74451: PUSH
74452: LD_INT 1
74454: NEG
74455: PUSH
74456: EMPTY
74457: LIST
74458: LIST
74459: PUSH
74460: LD_INT 2
74462: PUSH
74463: LD_INT 0
74465: PUSH
74466: EMPTY
74467: LIST
74468: LIST
74469: PUSH
74470: LD_INT 2
74472: PUSH
74473: LD_INT 1
74475: PUSH
74476: EMPTY
74477: LIST
74478: LIST
74479: PUSH
74480: EMPTY
74481: LIST
74482: LIST
74483: LIST
74484: LIST
74485: LIST
74486: LIST
74487: LIST
74488: LIST
74489: LIST
74490: LIST
74491: LIST
74492: LIST
74493: ST_TO_ADDR
// ControlTower2 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] ] ;
74494: LD_ADDR_VAR 0 49
74498: PUSH
74499: LD_INT 0
74501: PUSH
74502: LD_INT 0
74504: PUSH
74505: EMPTY
74506: LIST
74507: LIST
74508: PUSH
74509: LD_INT 0
74511: PUSH
74512: LD_INT 1
74514: NEG
74515: PUSH
74516: EMPTY
74517: LIST
74518: LIST
74519: PUSH
74520: LD_INT 1
74522: PUSH
74523: LD_INT 0
74525: PUSH
74526: EMPTY
74527: LIST
74528: LIST
74529: PUSH
74530: LD_INT 1
74532: PUSH
74533: LD_INT 1
74535: PUSH
74536: EMPTY
74537: LIST
74538: LIST
74539: PUSH
74540: LD_INT 0
74542: PUSH
74543: LD_INT 1
74545: PUSH
74546: EMPTY
74547: LIST
74548: LIST
74549: PUSH
74550: LD_INT 1
74552: NEG
74553: PUSH
74554: LD_INT 0
74556: PUSH
74557: EMPTY
74558: LIST
74559: LIST
74560: PUSH
74561: LD_INT 1
74563: NEG
74564: PUSH
74565: LD_INT 1
74567: NEG
74568: PUSH
74569: EMPTY
74570: LIST
74571: LIST
74572: PUSH
74573: LD_INT 1
74575: PUSH
74576: LD_INT 1
74578: NEG
74579: PUSH
74580: EMPTY
74581: LIST
74582: LIST
74583: PUSH
74584: LD_INT 2
74586: PUSH
74587: LD_INT 0
74589: PUSH
74590: EMPTY
74591: LIST
74592: LIST
74593: PUSH
74594: LD_INT 2
74596: PUSH
74597: LD_INT 1
74599: PUSH
74600: EMPTY
74601: LIST
74602: LIST
74603: PUSH
74604: LD_INT 2
74606: PUSH
74607: LD_INT 2
74609: PUSH
74610: EMPTY
74611: LIST
74612: LIST
74613: PUSH
74614: LD_INT 1
74616: PUSH
74617: LD_INT 2
74619: PUSH
74620: EMPTY
74621: LIST
74622: LIST
74623: PUSH
74624: EMPTY
74625: LIST
74626: LIST
74627: LIST
74628: LIST
74629: LIST
74630: LIST
74631: LIST
74632: LIST
74633: LIST
74634: LIST
74635: LIST
74636: LIST
74637: ST_TO_ADDR
// ControlTower3 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] ] ;
74638: LD_ADDR_VAR 0 50
74642: PUSH
74643: LD_INT 0
74645: PUSH
74646: LD_INT 0
74648: PUSH
74649: EMPTY
74650: LIST
74651: LIST
74652: PUSH
74653: LD_INT 0
74655: PUSH
74656: LD_INT 1
74658: NEG
74659: PUSH
74660: EMPTY
74661: LIST
74662: LIST
74663: PUSH
74664: LD_INT 1
74666: PUSH
74667: LD_INT 0
74669: PUSH
74670: EMPTY
74671: LIST
74672: LIST
74673: PUSH
74674: LD_INT 1
74676: PUSH
74677: LD_INT 1
74679: PUSH
74680: EMPTY
74681: LIST
74682: LIST
74683: PUSH
74684: LD_INT 0
74686: PUSH
74687: LD_INT 1
74689: PUSH
74690: EMPTY
74691: LIST
74692: LIST
74693: PUSH
74694: LD_INT 1
74696: NEG
74697: PUSH
74698: LD_INT 0
74700: PUSH
74701: EMPTY
74702: LIST
74703: LIST
74704: PUSH
74705: LD_INT 1
74707: NEG
74708: PUSH
74709: LD_INT 1
74711: NEG
74712: PUSH
74713: EMPTY
74714: LIST
74715: LIST
74716: PUSH
74717: LD_INT 2
74719: PUSH
74720: LD_INT 1
74722: PUSH
74723: EMPTY
74724: LIST
74725: LIST
74726: PUSH
74727: LD_INT 2
74729: PUSH
74730: LD_INT 2
74732: PUSH
74733: EMPTY
74734: LIST
74735: LIST
74736: PUSH
74737: LD_INT 1
74739: PUSH
74740: LD_INT 2
74742: PUSH
74743: EMPTY
74744: LIST
74745: LIST
74746: PUSH
74747: LD_INT 0
74749: PUSH
74750: LD_INT 2
74752: PUSH
74753: EMPTY
74754: LIST
74755: LIST
74756: PUSH
74757: LD_INT 1
74759: NEG
74760: PUSH
74761: LD_INT 1
74763: PUSH
74764: EMPTY
74765: LIST
74766: LIST
74767: PUSH
74768: EMPTY
74769: LIST
74770: LIST
74771: LIST
74772: LIST
74773: LIST
74774: LIST
74775: LIST
74776: LIST
74777: LIST
74778: LIST
74779: LIST
74780: LIST
74781: ST_TO_ADDR
// ControlTower4 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] ] ;
74782: LD_ADDR_VAR 0 51
74786: PUSH
74787: LD_INT 0
74789: PUSH
74790: LD_INT 0
74792: PUSH
74793: EMPTY
74794: LIST
74795: LIST
74796: PUSH
74797: LD_INT 0
74799: PUSH
74800: LD_INT 1
74802: NEG
74803: PUSH
74804: EMPTY
74805: LIST
74806: LIST
74807: PUSH
74808: LD_INT 1
74810: PUSH
74811: LD_INT 0
74813: PUSH
74814: EMPTY
74815: LIST
74816: LIST
74817: PUSH
74818: LD_INT 1
74820: PUSH
74821: LD_INT 1
74823: PUSH
74824: EMPTY
74825: LIST
74826: LIST
74827: PUSH
74828: LD_INT 0
74830: PUSH
74831: LD_INT 1
74833: PUSH
74834: EMPTY
74835: LIST
74836: LIST
74837: PUSH
74838: LD_INT 1
74840: NEG
74841: PUSH
74842: LD_INT 0
74844: PUSH
74845: EMPTY
74846: LIST
74847: LIST
74848: PUSH
74849: LD_INT 1
74851: NEG
74852: PUSH
74853: LD_INT 1
74855: NEG
74856: PUSH
74857: EMPTY
74858: LIST
74859: LIST
74860: PUSH
74861: LD_INT 1
74863: PUSH
74864: LD_INT 2
74866: PUSH
74867: EMPTY
74868: LIST
74869: LIST
74870: PUSH
74871: LD_INT 0
74873: PUSH
74874: LD_INT 2
74876: PUSH
74877: EMPTY
74878: LIST
74879: LIST
74880: PUSH
74881: LD_INT 1
74883: NEG
74884: PUSH
74885: LD_INT 1
74887: PUSH
74888: EMPTY
74889: LIST
74890: LIST
74891: PUSH
74892: LD_INT 2
74894: NEG
74895: PUSH
74896: LD_INT 0
74898: PUSH
74899: EMPTY
74900: LIST
74901: LIST
74902: PUSH
74903: LD_INT 2
74905: NEG
74906: PUSH
74907: LD_INT 1
74909: NEG
74910: PUSH
74911: EMPTY
74912: LIST
74913: LIST
74914: PUSH
74915: EMPTY
74916: LIST
74917: LIST
74918: LIST
74919: LIST
74920: LIST
74921: LIST
74922: LIST
74923: LIST
74924: LIST
74925: LIST
74926: LIST
74927: LIST
74928: ST_TO_ADDR
// ControlTower5 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
74929: LD_ADDR_VAR 0 52
74933: PUSH
74934: LD_INT 0
74936: PUSH
74937: LD_INT 0
74939: PUSH
74940: EMPTY
74941: LIST
74942: LIST
74943: PUSH
74944: LD_INT 0
74946: PUSH
74947: LD_INT 1
74949: NEG
74950: PUSH
74951: EMPTY
74952: LIST
74953: LIST
74954: PUSH
74955: LD_INT 1
74957: PUSH
74958: LD_INT 0
74960: PUSH
74961: EMPTY
74962: LIST
74963: LIST
74964: PUSH
74965: LD_INT 1
74967: PUSH
74968: LD_INT 1
74970: PUSH
74971: EMPTY
74972: LIST
74973: LIST
74974: PUSH
74975: LD_INT 0
74977: PUSH
74978: LD_INT 1
74980: PUSH
74981: EMPTY
74982: LIST
74983: LIST
74984: PUSH
74985: LD_INT 1
74987: NEG
74988: PUSH
74989: LD_INT 0
74991: PUSH
74992: EMPTY
74993: LIST
74994: LIST
74995: PUSH
74996: LD_INT 1
74998: NEG
74999: PUSH
75000: LD_INT 1
75002: NEG
75003: PUSH
75004: EMPTY
75005: LIST
75006: LIST
75007: PUSH
75008: LD_INT 1
75010: NEG
75011: PUSH
75012: LD_INT 2
75014: NEG
75015: PUSH
75016: EMPTY
75017: LIST
75018: LIST
75019: PUSH
75020: LD_INT 1
75022: NEG
75023: PUSH
75024: LD_INT 1
75026: PUSH
75027: EMPTY
75028: LIST
75029: LIST
75030: PUSH
75031: LD_INT 2
75033: NEG
75034: PUSH
75035: LD_INT 0
75037: PUSH
75038: EMPTY
75039: LIST
75040: LIST
75041: PUSH
75042: LD_INT 2
75044: NEG
75045: PUSH
75046: LD_INT 1
75048: NEG
75049: PUSH
75050: EMPTY
75051: LIST
75052: LIST
75053: PUSH
75054: LD_INT 2
75056: NEG
75057: PUSH
75058: LD_INT 2
75060: NEG
75061: PUSH
75062: EMPTY
75063: LIST
75064: LIST
75065: PUSH
75066: EMPTY
75067: LIST
75068: LIST
75069: LIST
75070: LIST
75071: LIST
75072: LIST
75073: LIST
75074: LIST
75075: LIST
75076: LIST
75077: LIST
75078: LIST
75079: ST_TO_ADDR
// Barracks0 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
75080: LD_ADDR_VAR 0 53
75084: PUSH
75085: LD_INT 0
75087: PUSH
75088: LD_INT 0
75090: PUSH
75091: EMPTY
75092: LIST
75093: LIST
75094: PUSH
75095: LD_INT 0
75097: PUSH
75098: LD_INT 1
75100: NEG
75101: PUSH
75102: EMPTY
75103: LIST
75104: LIST
75105: PUSH
75106: LD_INT 1
75108: PUSH
75109: LD_INT 0
75111: PUSH
75112: EMPTY
75113: LIST
75114: LIST
75115: PUSH
75116: LD_INT 1
75118: PUSH
75119: LD_INT 1
75121: PUSH
75122: EMPTY
75123: LIST
75124: LIST
75125: PUSH
75126: LD_INT 0
75128: PUSH
75129: LD_INT 1
75131: PUSH
75132: EMPTY
75133: LIST
75134: LIST
75135: PUSH
75136: LD_INT 1
75138: NEG
75139: PUSH
75140: LD_INT 0
75142: PUSH
75143: EMPTY
75144: LIST
75145: LIST
75146: PUSH
75147: LD_INT 1
75149: NEG
75150: PUSH
75151: LD_INT 1
75153: NEG
75154: PUSH
75155: EMPTY
75156: LIST
75157: LIST
75158: PUSH
75159: LD_INT 1
75161: NEG
75162: PUSH
75163: LD_INT 2
75165: NEG
75166: PUSH
75167: EMPTY
75168: LIST
75169: LIST
75170: PUSH
75171: LD_INT 0
75173: PUSH
75174: LD_INT 2
75176: NEG
75177: PUSH
75178: EMPTY
75179: LIST
75180: LIST
75181: PUSH
75182: LD_INT 1
75184: PUSH
75185: LD_INT 1
75187: NEG
75188: PUSH
75189: EMPTY
75190: LIST
75191: LIST
75192: PUSH
75193: LD_INT 2
75195: PUSH
75196: LD_INT 0
75198: PUSH
75199: EMPTY
75200: LIST
75201: LIST
75202: PUSH
75203: LD_INT 2
75205: PUSH
75206: LD_INT 1
75208: PUSH
75209: EMPTY
75210: LIST
75211: LIST
75212: PUSH
75213: LD_INT 2
75215: PUSH
75216: LD_INT 2
75218: PUSH
75219: EMPTY
75220: LIST
75221: LIST
75222: PUSH
75223: LD_INT 1
75225: PUSH
75226: LD_INT 2
75228: PUSH
75229: EMPTY
75230: LIST
75231: LIST
75232: PUSH
75233: LD_INT 0
75235: PUSH
75236: LD_INT 2
75238: PUSH
75239: EMPTY
75240: LIST
75241: LIST
75242: PUSH
75243: LD_INT 1
75245: NEG
75246: PUSH
75247: LD_INT 1
75249: PUSH
75250: EMPTY
75251: LIST
75252: LIST
75253: PUSH
75254: LD_INT 2
75256: NEG
75257: PUSH
75258: LD_INT 0
75260: PUSH
75261: EMPTY
75262: LIST
75263: LIST
75264: PUSH
75265: LD_INT 2
75267: NEG
75268: PUSH
75269: LD_INT 1
75271: NEG
75272: PUSH
75273: EMPTY
75274: LIST
75275: LIST
75276: PUSH
75277: LD_INT 2
75279: NEG
75280: PUSH
75281: LD_INT 2
75283: NEG
75284: PUSH
75285: EMPTY
75286: LIST
75287: LIST
75288: PUSH
75289: EMPTY
75290: LIST
75291: LIST
75292: LIST
75293: LIST
75294: LIST
75295: LIST
75296: LIST
75297: LIST
75298: LIST
75299: LIST
75300: LIST
75301: LIST
75302: LIST
75303: LIST
75304: LIST
75305: LIST
75306: LIST
75307: LIST
75308: LIST
75309: ST_TO_ADDR
// Barracks1 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
75310: LD_ADDR_VAR 0 54
75314: PUSH
75315: LD_INT 0
75317: PUSH
75318: LD_INT 0
75320: PUSH
75321: EMPTY
75322: LIST
75323: LIST
75324: PUSH
75325: LD_INT 0
75327: PUSH
75328: LD_INT 1
75330: NEG
75331: PUSH
75332: EMPTY
75333: LIST
75334: LIST
75335: PUSH
75336: LD_INT 1
75338: PUSH
75339: LD_INT 0
75341: PUSH
75342: EMPTY
75343: LIST
75344: LIST
75345: PUSH
75346: LD_INT 1
75348: PUSH
75349: LD_INT 1
75351: PUSH
75352: EMPTY
75353: LIST
75354: LIST
75355: PUSH
75356: LD_INT 0
75358: PUSH
75359: LD_INT 1
75361: PUSH
75362: EMPTY
75363: LIST
75364: LIST
75365: PUSH
75366: LD_INT 1
75368: NEG
75369: PUSH
75370: LD_INT 0
75372: PUSH
75373: EMPTY
75374: LIST
75375: LIST
75376: PUSH
75377: LD_INT 1
75379: NEG
75380: PUSH
75381: LD_INT 1
75383: NEG
75384: PUSH
75385: EMPTY
75386: LIST
75387: LIST
75388: PUSH
75389: LD_INT 1
75391: NEG
75392: PUSH
75393: LD_INT 2
75395: NEG
75396: PUSH
75397: EMPTY
75398: LIST
75399: LIST
75400: PUSH
75401: LD_INT 0
75403: PUSH
75404: LD_INT 2
75406: NEG
75407: PUSH
75408: EMPTY
75409: LIST
75410: LIST
75411: PUSH
75412: LD_INT 1
75414: PUSH
75415: LD_INT 1
75417: NEG
75418: PUSH
75419: EMPTY
75420: LIST
75421: LIST
75422: PUSH
75423: LD_INT 2
75425: PUSH
75426: LD_INT 0
75428: PUSH
75429: EMPTY
75430: LIST
75431: LIST
75432: PUSH
75433: LD_INT 2
75435: PUSH
75436: LD_INT 1
75438: PUSH
75439: EMPTY
75440: LIST
75441: LIST
75442: PUSH
75443: LD_INT 2
75445: PUSH
75446: LD_INT 2
75448: PUSH
75449: EMPTY
75450: LIST
75451: LIST
75452: PUSH
75453: LD_INT 1
75455: PUSH
75456: LD_INT 2
75458: PUSH
75459: EMPTY
75460: LIST
75461: LIST
75462: PUSH
75463: LD_INT 0
75465: PUSH
75466: LD_INT 2
75468: PUSH
75469: EMPTY
75470: LIST
75471: LIST
75472: PUSH
75473: LD_INT 1
75475: NEG
75476: PUSH
75477: LD_INT 1
75479: PUSH
75480: EMPTY
75481: LIST
75482: LIST
75483: PUSH
75484: LD_INT 2
75486: NEG
75487: PUSH
75488: LD_INT 0
75490: PUSH
75491: EMPTY
75492: LIST
75493: LIST
75494: PUSH
75495: LD_INT 2
75497: NEG
75498: PUSH
75499: LD_INT 1
75501: NEG
75502: PUSH
75503: EMPTY
75504: LIST
75505: LIST
75506: PUSH
75507: LD_INT 2
75509: NEG
75510: PUSH
75511: LD_INT 2
75513: NEG
75514: PUSH
75515: EMPTY
75516: LIST
75517: LIST
75518: PUSH
75519: EMPTY
75520: LIST
75521: LIST
75522: LIST
75523: LIST
75524: LIST
75525: LIST
75526: LIST
75527: LIST
75528: LIST
75529: LIST
75530: LIST
75531: LIST
75532: LIST
75533: LIST
75534: LIST
75535: LIST
75536: LIST
75537: LIST
75538: LIST
75539: ST_TO_ADDR
// Barracks2 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
75540: LD_ADDR_VAR 0 55
75544: PUSH
75545: LD_INT 0
75547: PUSH
75548: LD_INT 0
75550: PUSH
75551: EMPTY
75552: LIST
75553: LIST
75554: PUSH
75555: LD_INT 0
75557: PUSH
75558: LD_INT 1
75560: NEG
75561: PUSH
75562: EMPTY
75563: LIST
75564: LIST
75565: PUSH
75566: LD_INT 1
75568: PUSH
75569: LD_INT 0
75571: PUSH
75572: EMPTY
75573: LIST
75574: LIST
75575: PUSH
75576: LD_INT 1
75578: PUSH
75579: LD_INT 1
75581: PUSH
75582: EMPTY
75583: LIST
75584: LIST
75585: PUSH
75586: LD_INT 0
75588: PUSH
75589: LD_INT 1
75591: PUSH
75592: EMPTY
75593: LIST
75594: LIST
75595: PUSH
75596: LD_INT 1
75598: NEG
75599: PUSH
75600: LD_INT 0
75602: PUSH
75603: EMPTY
75604: LIST
75605: LIST
75606: PUSH
75607: LD_INT 1
75609: NEG
75610: PUSH
75611: LD_INT 1
75613: NEG
75614: PUSH
75615: EMPTY
75616: LIST
75617: LIST
75618: PUSH
75619: LD_INT 1
75621: NEG
75622: PUSH
75623: LD_INT 2
75625: NEG
75626: PUSH
75627: EMPTY
75628: LIST
75629: LIST
75630: PUSH
75631: LD_INT 0
75633: PUSH
75634: LD_INT 2
75636: NEG
75637: PUSH
75638: EMPTY
75639: LIST
75640: LIST
75641: PUSH
75642: LD_INT 1
75644: PUSH
75645: LD_INT 1
75647: NEG
75648: PUSH
75649: EMPTY
75650: LIST
75651: LIST
75652: PUSH
75653: LD_INT 2
75655: PUSH
75656: LD_INT 0
75658: PUSH
75659: EMPTY
75660: LIST
75661: LIST
75662: PUSH
75663: LD_INT 2
75665: PUSH
75666: LD_INT 1
75668: PUSH
75669: EMPTY
75670: LIST
75671: LIST
75672: PUSH
75673: LD_INT 2
75675: PUSH
75676: LD_INT 2
75678: PUSH
75679: EMPTY
75680: LIST
75681: LIST
75682: PUSH
75683: LD_INT 1
75685: PUSH
75686: LD_INT 2
75688: PUSH
75689: EMPTY
75690: LIST
75691: LIST
75692: PUSH
75693: LD_INT 0
75695: PUSH
75696: LD_INT 2
75698: PUSH
75699: EMPTY
75700: LIST
75701: LIST
75702: PUSH
75703: LD_INT 1
75705: NEG
75706: PUSH
75707: LD_INT 1
75709: PUSH
75710: EMPTY
75711: LIST
75712: LIST
75713: PUSH
75714: LD_INT 2
75716: NEG
75717: PUSH
75718: LD_INT 0
75720: PUSH
75721: EMPTY
75722: LIST
75723: LIST
75724: PUSH
75725: LD_INT 2
75727: NEG
75728: PUSH
75729: LD_INT 1
75731: NEG
75732: PUSH
75733: EMPTY
75734: LIST
75735: LIST
75736: PUSH
75737: LD_INT 2
75739: NEG
75740: PUSH
75741: LD_INT 2
75743: NEG
75744: PUSH
75745: EMPTY
75746: LIST
75747: LIST
75748: PUSH
75749: EMPTY
75750: LIST
75751: LIST
75752: LIST
75753: LIST
75754: LIST
75755: LIST
75756: LIST
75757: LIST
75758: LIST
75759: LIST
75760: LIST
75761: LIST
75762: LIST
75763: LIST
75764: LIST
75765: LIST
75766: LIST
75767: LIST
75768: LIST
75769: ST_TO_ADDR
// Barracks3 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
75770: LD_ADDR_VAR 0 56
75774: PUSH
75775: LD_INT 0
75777: PUSH
75778: LD_INT 0
75780: PUSH
75781: EMPTY
75782: LIST
75783: LIST
75784: PUSH
75785: LD_INT 0
75787: PUSH
75788: LD_INT 1
75790: NEG
75791: PUSH
75792: EMPTY
75793: LIST
75794: LIST
75795: PUSH
75796: LD_INT 1
75798: PUSH
75799: LD_INT 0
75801: PUSH
75802: EMPTY
75803: LIST
75804: LIST
75805: PUSH
75806: LD_INT 1
75808: PUSH
75809: LD_INT 1
75811: PUSH
75812: EMPTY
75813: LIST
75814: LIST
75815: PUSH
75816: LD_INT 0
75818: PUSH
75819: LD_INT 1
75821: PUSH
75822: EMPTY
75823: LIST
75824: LIST
75825: PUSH
75826: LD_INT 1
75828: NEG
75829: PUSH
75830: LD_INT 0
75832: PUSH
75833: EMPTY
75834: LIST
75835: LIST
75836: PUSH
75837: LD_INT 1
75839: NEG
75840: PUSH
75841: LD_INT 1
75843: NEG
75844: PUSH
75845: EMPTY
75846: LIST
75847: LIST
75848: PUSH
75849: LD_INT 1
75851: NEG
75852: PUSH
75853: LD_INT 2
75855: NEG
75856: PUSH
75857: EMPTY
75858: LIST
75859: LIST
75860: PUSH
75861: LD_INT 0
75863: PUSH
75864: LD_INT 2
75866: NEG
75867: PUSH
75868: EMPTY
75869: LIST
75870: LIST
75871: PUSH
75872: LD_INT 1
75874: PUSH
75875: LD_INT 1
75877: NEG
75878: PUSH
75879: EMPTY
75880: LIST
75881: LIST
75882: PUSH
75883: LD_INT 2
75885: PUSH
75886: LD_INT 0
75888: PUSH
75889: EMPTY
75890: LIST
75891: LIST
75892: PUSH
75893: LD_INT 2
75895: PUSH
75896: LD_INT 1
75898: PUSH
75899: EMPTY
75900: LIST
75901: LIST
75902: PUSH
75903: LD_INT 2
75905: PUSH
75906: LD_INT 2
75908: PUSH
75909: EMPTY
75910: LIST
75911: LIST
75912: PUSH
75913: LD_INT 1
75915: PUSH
75916: LD_INT 2
75918: PUSH
75919: EMPTY
75920: LIST
75921: LIST
75922: PUSH
75923: LD_INT 0
75925: PUSH
75926: LD_INT 2
75928: PUSH
75929: EMPTY
75930: LIST
75931: LIST
75932: PUSH
75933: LD_INT 1
75935: NEG
75936: PUSH
75937: LD_INT 1
75939: PUSH
75940: EMPTY
75941: LIST
75942: LIST
75943: PUSH
75944: LD_INT 2
75946: NEG
75947: PUSH
75948: LD_INT 0
75950: PUSH
75951: EMPTY
75952: LIST
75953: LIST
75954: PUSH
75955: LD_INT 2
75957: NEG
75958: PUSH
75959: LD_INT 1
75961: NEG
75962: PUSH
75963: EMPTY
75964: LIST
75965: LIST
75966: PUSH
75967: LD_INT 2
75969: NEG
75970: PUSH
75971: LD_INT 2
75973: NEG
75974: PUSH
75975: EMPTY
75976: LIST
75977: LIST
75978: PUSH
75979: EMPTY
75980: LIST
75981: LIST
75982: LIST
75983: LIST
75984: LIST
75985: LIST
75986: LIST
75987: LIST
75988: LIST
75989: LIST
75990: LIST
75991: LIST
75992: LIST
75993: LIST
75994: LIST
75995: LIST
75996: LIST
75997: LIST
75998: LIST
75999: ST_TO_ADDR
// Barracks4 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
76000: LD_ADDR_VAR 0 57
76004: PUSH
76005: LD_INT 0
76007: PUSH
76008: LD_INT 0
76010: PUSH
76011: EMPTY
76012: LIST
76013: LIST
76014: PUSH
76015: LD_INT 0
76017: PUSH
76018: LD_INT 1
76020: NEG
76021: PUSH
76022: EMPTY
76023: LIST
76024: LIST
76025: PUSH
76026: LD_INT 1
76028: PUSH
76029: LD_INT 0
76031: PUSH
76032: EMPTY
76033: LIST
76034: LIST
76035: PUSH
76036: LD_INT 1
76038: PUSH
76039: LD_INT 1
76041: PUSH
76042: EMPTY
76043: LIST
76044: LIST
76045: PUSH
76046: LD_INT 0
76048: PUSH
76049: LD_INT 1
76051: PUSH
76052: EMPTY
76053: LIST
76054: LIST
76055: PUSH
76056: LD_INT 1
76058: NEG
76059: PUSH
76060: LD_INT 0
76062: PUSH
76063: EMPTY
76064: LIST
76065: LIST
76066: PUSH
76067: LD_INT 1
76069: NEG
76070: PUSH
76071: LD_INT 1
76073: NEG
76074: PUSH
76075: EMPTY
76076: LIST
76077: LIST
76078: PUSH
76079: LD_INT 1
76081: NEG
76082: PUSH
76083: LD_INT 2
76085: NEG
76086: PUSH
76087: EMPTY
76088: LIST
76089: LIST
76090: PUSH
76091: LD_INT 0
76093: PUSH
76094: LD_INT 2
76096: NEG
76097: PUSH
76098: EMPTY
76099: LIST
76100: LIST
76101: PUSH
76102: LD_INT 1
76104: PUSH
76105: LD_INT 1
76107: NEG
76108: PUSH
76109: EMPTY
76110: LIST
76111: LIST
76112: PUSH
76113: LD_INT 2
76115: PUSH
76116: LD_INT 0
76118: PUSH
76119: EMPTY
76120: LIST
76121: LIST
76122: PUSH
76123: LD_INT 2
76125: PUSH
76126: LD_INT 1
76128: PUSH
76129: EMPTY
76130: LIST
76131: LIST
76132: PUSH
76133: LD_INT 2
76135: PUSH
76136: LD_INT 2
76138: PUSH
76139: EMPTY
76140: LIST
76141: LIST
76142: PUSH
76143: LD_INT 1
76145: PUSH
76146: LD_INT 2
76148: PUSH
76149: EMPTY
76150: LIST
76151: LIST
76152: PUSH
76153: LD_INT 0
76155: PUSH
76156: LD_INT 2
76158: PUSH
76159: EMPTY
76160: LIST
76161: LIST
76162: PUSH
76163: LD_INT 1
76165: NEG
76166: PUSH
76167: LD_INT 1
76169: PUSH
76170: EMPTY
76171: LIST
76172: LIST
76173: PUSH
76174: LD_INT 2
76176: NEG
76177: PUSH
76178: LD_INT 0
76180: PUSH
76181: EMPTY
76182: LIST
76183: LIST
76184: PUSH
76185: LD_INT 2
76187: NEG
76188: PUSH
76189: LD_INT 1
76191: NEG
76192: PUSH
76193: EMPTY
76194: LIST
76195: LIST
76196: PUSH
76197: LD_INT 2
76199: NEG
76200: PUSH
76201: LD_INT 2
76203: NEG
76204: PUSH
76205: EMPTY
76206: LIST
76207: LIST
76208: PUSH
76209: EMPTY
76210: LIST
76211: LIST
76212: LIST
76213: LIST
76214: LIST
76215: LIST
76216: LIST
76217: LIST
76218: LIST
76219: LIST
76220: LIST
76221: LIST
76222: LIST
76223: LIST
76224: LIST
76225: LIST
76226: LIST
76227: LIST
76228: LIST
76229: ST_TO_ADDR
// Barracks5 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
76230: LD_ADDR_VAR 0 58
76234: PUSH
76235: LD_INT 0
76237: PUSH
76238: LD_INT 0
76240: PUSH
76241: EMPTY
76242: LIST
76243: LIST
76244: PUSH
76245: LD_INT 0
76247: PUSH
76248: LD_INT 1
76250: NEG
76251: PUSH
76252: EMPTY
76253: LIST
76254: LIST
76255: PUSH
76256: LD_INT 1
76258: PUSH
76259: LD_INT 0
76261: PUSH
76262: EMPTY
76263: LIST
76264: LIST
76265: PUSH
76266: LD_INT 1
76268: PUSH
76269: LD_INT 1
76271: PUSH
76272: EMPTY
76273: LIST
76274: LIST
76275: PUSH
76276: LD_INT 0
76278: PUSH
76279: LD_INT 1
76281: PUSH
76282: EMPTY
76283: LIST
76284: LIST
76285: PUSH
76286: LD_INT 1
76288: NEG
76289: PUSH
76290: LD_INT 0
76292: PUSH
76293: EMPTY
76294: LIST
76295: LIST
76296: PUSH
76297: LD_INT 1
76299: NEG
76300: PUSH
76301: LD_INT 1
76303: NEG
76304: PUSH
76305: EMPTY
76306: LIST
76307: LIST
76308: PUSH
76309: LD_INT 1
76311: NEG
76312: PUSH
76313: LD_INT 2
76315: NEG
76316: PUSH
76317: EMPTY
76318: LIST
76319: LIST
76320: PUSH
76321: LD_INT 0
76323: PUSH
76324: LD_INT 2
76326: NEG
76327: PUSH
76328: EMPTY
76329: LIST
76330: LIST
76331: PUSH
76332: LD_INT 1
76334: PUSH
76335: LD_INT 1
76337: NEG
76338: PUSH
76339: EMPTY
76340: LIST
76341: LIST
76342: PUSH
76343: LD_INT 2
76345: PUSH
76346: LD_INT 0
76348: PUSH
76349: EMPTY
76350: LIST
76351: LIST
76352: PUSH
76353: LD_INT 2
76355: PUSH
76356: LD_INT 1
76358: PUSH
76359: EMPTY
76360: LIST
76361: LIST
76362: PUSH
76363: LD_INT 2
76365: PUSH
76366: LD_INT 2
76368: PUSH
76369: EMPTY
76370: LIST
76371: LIST
76372: PUSH
76373: LD_INT 1
76375: PUSH
76376: LD_INT 2
76378: PUSH
76379: EMPTY
76380: LIST
76381: LIST
76382: PUSH
76383: LD_INT 0
76385: PUSH
76386: LD_INT 2
76388: PUSH
76389: EMPTY
76390: LIST
76391: LIST
76392: PUSH
76393: LD_INT 1
76395: NEG
76396: PUSH
76397: LD_INT 1
76399: PUSH
76400: EMPTY
76401: LIST
76402: LIST
76403: PUSH
76404: LD_INT 2
76406: NEG
76407: PUSH
76408: LD_INT 0
76410: PUSH
76411: EMPTY
76412: LIST
76413: LIST
76414: PUSH
76415: LD_INT 2
76417: NEG
76418: PUSH
76419: LD_INT 1
76421: NEG
76422: PUSH
76423: EMPTY
76424: LIST
76425: LIST
76426: PUSH
76427: LD_INT 2
76429: NEG
76430: PUSH
76431: LD_INT 2
76433: NEG
76434: PUSH
76435: EMPTY
76436: LIST
76437: LIST
76438: PUSH
76439: EMPTY
76440: LIST
76441: LIST
76442: LIST
76443: LIST
76444: LIST
76445: LIST
76446: LIST
76447: LIST
76448: LIST
76449: LIST
76450: LIST
76451: LIST
76452: LIST
76453: LIST
76454: LIST
76455: LIST
76456: LIST
76457: LIST
76458: LIST
76459: ST_TO_ADDR
// Bunker0 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] ] ;
76460: LD_ADDR_VAR 0 59
76464: PUSH
76465: LD_INT 0
76467: PUSH
76468: LD_INT 0
76470: PUSH
76471: EMPTY
76472: LIST
76473: LIST
76474: PUSH
76475: LD_INT 0
76477: PUSH
76478: LD_INT 1
76480: NEG
76481: PUSH
76482: EMPTY
76483: LIST
76484: LIST
76485: PUSH
76486: LD_INT 1
76488: PUSH
76489: LD_INT 0
76491: PUSH
76492: EMPTY
76493: LIST
76494: LIST
76495: PUSH
76496: LD_INT 1
76498: PUSH
76499: LD_INT 1
76501: PUSH
76502: EMPTY
76503: LIST
76504: LIST
76505: PUSH
76506: LD_INT 0
76508: PUSH
76509: LD_INT 1
76511: PUSH
76512: EMPTY
76513: LIST
76514: LIST
76515: PUSH
76516: LD_INT 1
76518: NEG
76519: PUSH
76520: LD_INT 0
76522: PUSH
76523: EMPTY
76524: LIST
76525: LIST
76526: PUSH
76527: LD_INT 1
76529: NEG
76530: PUSH
76531: LD_INT 1
76533: NEG
76534: PUSH
76535: EMPTY
76536: LIST
76537: LIST
76538: PUSH
76539: EMPTY
76540: LIST
76541: LIST
76542: LIST
76543: LIST
76544: LIST
76545: LIST
76546: LIST
76547: ST_TO_ADDR
// Bunker1 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] ] ;
76548: LD_ADDR_VAR 0 60
76552: PUSH
76553: LD_INT 0
76555: PUSH
76556: LD_INT 0
76558: PUSH
76559: EMPTY
76560: LIST
76561: LIST
76562: PUSH
76563: LD_INT 0
76565: PUSH
76566: LD_INT 1
76568: NEG
76569: PUSH
76570: EMPTY
76571: LIST
76572: LIST
76573: PUSH
76574: LD_INT 1
76576: PUSH
76577: LD_INT 0
76579: PUSH
76580: EMPTY
76581: LIST
76582: LIST
76583: PUSH
76584: LD_INT 1
76586: PUSH
76587: LD_INT 1
76589: PUSH
76590: EMPTY
76591: LIST
76592: LIST
76593: PUSH
76594: LD_INT 0
76596: PUSH
76597: LD_INT 1
76599: PUSH
76600: EMPTY
76601: LIST
76602: LIST
76603: PUSH
76604: LD_INT 1
76606: NEG
76607: PUSH
76608: LD_INT 0
76610: PUSH
76611: EMPTY
76612: LIST
76613: LIST
76614: PUSH
76615: LD_INT 1
76617: NEG
76618: PUSH
76619: LD_INT 1
76621: NEG
76622: PUSH
76623: EMPTY
76624: LIST
76625: LIST
76626: PUSH
76627: EMPTY
76628: LIST
76629: LIST
76630: LIST
76631: LIST
76632: LIST
76633: LIST
76634: LIST
76635: ST_TO_ADDR
// Bunker2 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] ] ;
76636: LD_ADDR_VAR 0 61
76640: PUSH
76641: LD_INT 0
76643: PUSH
76644: LD_INT 0
76646: PUSH
76647: EMPTY
76648: LIST
76649: LIST
76650: PUSH
76651: LD_INT 0
76653: PUSH
76654: LD_INT 1
76656: NEG
76657: PUSH
76658: EMPTY
76659: LIST
76660: LIST
76661: PUSH
76662: LD_INT 1
76664: PUSH
76665: LD_INT 0
76667: PUSH
76668: EMPTY
76669: LIST
76670: LIST
76671: PUSH
76672: LD_INT 1
76674: PUSH
76675: LD_INT 1
76677: PUSH
76678: EMPTY
76679: LIST
76680: LIST
76681: PUSH
76682: LD_INT 0
76684: PUSH
76685: LD_INT 1
76687: PUSH
76688: EMPTY
76689: LIST
76690: LIST
76691: PUSH
76692: LD_INT 1
76694: NEG
76695: PUSH
76696: LD_INT 0
76698: PUSH
76699: EMPTY
76700: LIST
76701: LIST
76702: PUSH
76703: LD_INT 1
76705: NEG
76706: PUSH
76707: LD_INT 1
76709: NEG
76710: PUSH
76711: EMPTY
76712: LIST
76713: LIST
76714: PUSH
76715: EMPTY
76716: LIST
76717: LIST
76718: LIST
76719: LIST
76720: LIST
76721: LIST
76722: LIST
76723: ST_TO_ADDR
// Bunker3 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] ] ;
76724: LD_ADDR_VAR 0 62
76728: PUSH
76729: LD_INT 0
76731: PUSH
76732: LD_INT 0
76734: PUSH
76735: EMPTY
76736: LIST
76737: LIST
76738: PUSH
76739: LD_INT 0
76741: PUSH
76742: LD_INT 1
76744: NEG
76745: PUSH
76746: EMPTY
76747: LIST
76748: LIST
76749: PUSH
76750: LD_INT 1
76752: PUSH
76753: LD_INT 0
76755: PUSH
76756: EMPTY
76757: LIST
76758: LIST
76759: PUSH
76760: LD_INT 1
76762: PUSH
76763: LD_INT 1
76765: PUSH
76766: EMPTY
76767: LIST
76768: LIST
76769: PUSH
76770: LD_INT 0
76772: PUSH
76773: LD_INT 1
76775: PUSH
76776: EMPTY
76777: LIST
76778: LIST
76779: PUSH
76780: LD_INT 1
76782: NEG
76783: PUSH
76784: LD_INT 0
76786: PUSH
76787: EMPTY
76788: LIST
76789: LIST
76790: PUSH
76791: LD_INT 1
76793: NEG
76794: PUSH
76795: LD_INT 1
76797: NEG
76798: PUSH
76799: EMPTY
76800: LIST
76801: LIST
76802: PUSH
76803: EMPTY
76804: LIST
76805: LIST
76806: LIST
76807: LIST
76808: LIST
76809: LIST
76810: LIST
76811: ST_TO_ADDR
// Bunker4 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] ] ;
76812: LD_ADDR_VAR 0 63
76816: PUSH
76817: LD_INT 0
76819: PUSH
76820: LD_INT 0
76822: PUSH
76823: EMPTY
76824: LIST
76825: LIST
76826: PUSH
76827: LD_INT 0
76829: PUSH
76830: LD_INT 1
76832: NEG
76833: PUSH
76834: EMPTY
76835: LIST
76836: LIST
76837: PUSH
76838: LD_INT 1
76840: PUSH
76841: LD_INT 0
76843: PUSH
76844: EMPTY
76845: LIST
76846: LIST
76847: PUSH
76848: LD_INT 1
76850: PUSH
76851: LD_INT 1
76853: PUSH
76854: EMPTY
76855: LIST
76856: LIST
76857: PUSH
76858: LD_INT 0
76860: PUSH
76861: LD_INT 1
76863: PUSH
76864: EMPTY
76865: LIST
76866: LIST
76867: PUSH
76868: LD_INT 1
76870: NEG
76871: PUSH
76872: LD_INT 0
76874: PUSH
76875: EMPTY
76876: LIST
76877: LIST
76878: PUSH
76879: LD_INT 1
76881: NEG
76882: PUSH
76883: LD_INT 1
76885: NEG
76886: PUSH
76887: EMPTY
76888: LIST
76889: LIST
76890: PUSH
76891: EMPTY
76892: LIST
76893: LIST
76894: LIST
76895: LIST
76896: LIST
76897: LIST
76898: LIST
76899: ST_TO_ADDR
// Bunker5 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] ] ;
76900: LD_ADDR_VAR 0 64
76904: PUSH
76905: LD_INT 0
76907: PUSH
76908: LD_INT 0
76910: PUSH
76911: EMPTY
76912: LIST
76913: LIST
76914: PUSH
76915: LD_INT 0
76917: PUSH
76918: LD_INT 1
76920: NEG
76921: PUSH
76922: EMPTY
76923: LIST
76924: LIST
76925: PUSH
76926: LD_INT 1
76928: PUSH
76929: LD_INT 0
76931: PUSH
76932: EMPTY
76933: LIST
76934: LIST
76935: PUSH
76936: LD_INT 1
76938: PUSH
76939: LD_INT 1
76941: PUSH
76942: EMPTY
76943: LIST
76944: LIST
76945: PUSH
76946: LD_INT 0
76948: PUSH
76949: LD_INT 1
76951: PUSH
76952: EMPTY
76953: LIST
76954: LIST
76955: PUSH
76956: LD_INT 1
76958: NEG
76959: PUSH
76960: LD_INT 0
76962: PUSH
76963: EMPTY
76964: LIST
76965: LIST
76966: PUSH
76967: LD_INT 1
76969: NEG
76970: PUSH
76971: LD_INT 1
76973: NEG
76974: PUSH
76975: EMPTY
76976: LIST
76977: LIST
76978: PUSH
76979: EMPTY
76980: LIST
76981: LIST
76982: LIST
76983: LIST
76984: LIST
76985: LIST
76986: LIST
76987: ST_TO_ADDR
// end ; 1 :
76988: GO 82885
76990: LD_INT 1
76992: DOUBLE
76993: EQUAL
76994: IFTRUE 76998
76996: GO 79621
76998: POP
// begin DepotAm0 = [ [ - 1 , - 3 ] , [ 0 , - 3 ] , [ 1 , - 2 ] ] ;
76999: LD_ADDR_VAR 0 11
77003: PUSH
77004: LD_INT 1
77006: NEG
77007: PUSH
77008: LD_INT 3
77010: NEG
77011: PUSH
77012: EMPTY
77013: LIST
77014: LIST
77015: PUSH
77016: LD_INT 0
77018: PUSH
77019: LD_INT 3
77021: NEG
77022: PUSH
77023: EMPTY
77024: LIST
77025: LIST
77026: PUSH
77027: LD_INT 1
77029: PUSH
77030: LD_INT 2
77032: NEG
77033: PUSH
77034: EMPTY
77035: LIST
77036: LIST
77037: PUSH
77038: EMPTY
77039: LIST
77040: LIST
77041: LIST
77042: ST_TO_ADDR
// DepotAm1 = [ [ 2 , - 1 ] , [ 3 , 0 ] , [ 3 , 1 ] ] ;
77043: LD_ADDR_VAR 0 12
77047: PUSH
77048: LD_INT 2
77050: PUSH
77051: LD_INT 1
77053: NEG
77054: PUSH
77055: EMPTY
77056: LIST
77057: LIST
77058: PUSH
77059: LD_INT 3
77061: PUSH
77062: LD_INT 0
77064: PUSH
77065: EMPTY
77066: LIST
77067: LIST
77068: PUSH
77069: LD_INT 3
77071: PUSH
77072: LD_INT 1
77074: PUSH
77075: EMPTY
77076: LIST
77077: LIST
77078: PUSH
77079: EMPTY
77080: LIST
77081: LIST
77082: LIST
77083: ST_TO_ADDR
// DepotAm2 = [ [ 3 , 2 ] , [ 3 , 3 ] , [ 2 , 3 ] ] ;
77084: LD_ADDR_VAR 0 13
77088: PUSH
77089: LD_INT 3
77091: PUSH
77092: LD_INT 2
77094: PUSH
77095: EMPTY
77096: LIST
77097: LIST
77098: PUSH
77099: LD_INT 3
77101: PUSH
77102: LD_INT 3
77104: PUSH
77105: EMPTY
77106: LIST
77107: LIST
77108: PUSH
77109: LD_INT 2
77111: PUSH
77112: LD_INT 3
77114: PUSH
77115: EMPTY
77116: LIST
77117: LIST
77118: PUSH
77119: EMPTY
77120: LIST
77121: LIST
77122: LIST
77123: ST_TO_ADDR
// DepotAm3 = [ [ 1 , 3 ] , [ 0 , 3 ] , [ - 1 , 2 ] ] ;
77124: LD_ADDR_VAR 0 14
77128: PUSH
77129: LD_INT 1
77131: PUSH
77132: LD_INT 3
77134: PUSH
77135: EMPTY
77136: LIST
77137: LIST
77138: PUSH
77139: LD_INT 0
77141: PUSH
77142: LD_INT 3
77144: PUSH
77145: EMPTY
77146: LIST
77147: LIST
77148: PUSH
77149: LD_INT 1
77151: NEG
77152: PUSH
77153: LD_INT 2
77155: PUSH
77156: EMPTY
77157: LIST
77158: LIST
77159: PUSH
77160: EMPTY
77161: LIST
77162: LIST
77163: LIST
77164: ST_TO_ADDR
// DepotAm4 = [ [ - 2 , 1 ] , [ - 3 , 0 ] , [ - 3 , - 1 ] ] ;
77165: LD_ADDR_VAR 0 15
77169: PUSH
77170: LD_INT 2
77172: NEG
77173: PUSH
77174: LD_INT 1
77176: PUSH
77177: EMPTY
77178: LIST
77179: LIST
77180: PUSH
77181: LD_INT 3
77183: NEG
77184: PUSH
77185: LD_INT 0
77187: PUSH
77188: EMPTY
77189: LIST
77190: LIST
77191: PUSH
77192: LD_INT 3
77194: NEG
77195: PUSH
77196: LD_INT 1
77198: NEG
77199: PUSH
77200: EMPTY
77201: LIST
77202: LIST
77203: PUSH
77204: EMPTY
77205: LIST
77206: LIST
77207: LIST
77208: ST_TO_ADDR
// DepotAm5 = [ [ - 2 , - 3 ] , [ - 3 , - 2 ] , [ - 3 , - 3 ] ] ;
77209: LD_ADDR_VAR 0 16
77213: PUSH
77214: LD_INT 2
77216: NEG
77217: PUSH
77218: LD_INT 3
77220: NEG
77221: PUSH
77222: EMPTY
77223: LIST
77224: LIST
77225: PUSH
77226: LD_INT 3
77228: NEG
77229: PUSH
77230: LD_INT 2
77232: NEG
77233: PUSH
77234: EMPTY
77235: LIST
77236: LIST
77237: PUSH
77238: LD_INT 3
77240: NEG
77241: PUSH
77242: LD_INT 3
77244: NEG
77245: PUSH
77246: EMPTY
77247: LIST
77248: LIST
77249: PUSH
77250: EMPTY
77251: LIST
77252: LIST
77253: LIST
77254: ST_TO_ADDR
// DepotAr0 = [ [ - 1 , - 3 ] , [ 0 , - 3 ] , [ 1 , - 2 ] ] ;
77255: LD_ADDR_VAR 0 17
77259: PUSH
77260: LD_INT 1
77262: NEG
77263: PUSH
77264: LD_INT 3
77266: NEG
77267: PUSH
77268: EMPTY
77269: LIST
77270: LIST
77271: PUSH
77272: LD_INT 0
77274: PUSH
77275: LD_INT 3
77277: NEG
77278: PUSH
77279: EMPTY
77280: LIST
77281: LIST
77282: PUSH
77283: LD_INT 1
77285: PUSH
77286: LD_INT 2
77288: NEG
77289: PUSH
77290: EMPTY
77291: LIST
77292: LIST
77293: PUSH
77294: EMPTY
77295: LIST
77296: LIST
77297: LIST
77298: ST_TO_ADDR
// DepotAr1 = [ [ 2 , - 1 ] , [ 3 , 0 ] , [ 3 , 1 ] ] ;
77299: LD_ADDR_VAR 0 18
77303: PUSH
77304: LD_INT 2
77306: PUSH
77307: LD_INT 1
77309: NEG
77310: PUSH
77311: EMPTY
77312: LIST
77313: LIST
77314: PUSH
77315: LD_INT 3
77317: PUSH
77318: LD_INT 0
77320: PUSH
77321: EMPTY
77322: LIST
77323: LIST
77324: PUSH
77325: LD_INT 3
77327: PUSH
77328: LD_INT 1
77330: PUSH
77331: EMPTY
77332: LIST
77333: LIST
77334: PUSH
77335: EMPTY
77336: LIST
77337: LIST
77338: LIST
77339: ST_TO_ADDR
// DepotAr2 = [ [ 3 , 2 ] , [ 3 , 3 ] , [ 2 , 3 ] ] ;
77340: LD_ADDR_VAR 0 19
77344: PUSH
77345: LD_INT 3
77347: PUSH
77348: LD_INT 2
77350: PUSH
77351: EMPTY
77352: LIST
77353: LIST
77354: PUSH
77355: LD_INT 3
77357: PUSH
77358: LD_INT 3
77360: PUSH
77361: EMPTY
77362: LIST
77363: LIST
77364: PUSH
77365: LD_INT 2
77367: PUSH
77368: LD_INT 3
77370: PUSH
77371: EMPTY
77372: LIST
77373: LIST
77374: PUSH
77375: EMPTY
77376: LIST
77377: LIST
77378: LIST
77379: ST_TO_ADDR
// DepotAr3 = [ [ 1 , 3 ] , [ 0 , 3 ] , [ - 1 , 2 ] ] ;
77380: LD_ADDR_VAR 0 20
77384: PUSH
77385: LD_INT 1
77387: PUSH
77388: LD_INT 3
77390: PUSH
77391: EMPTY
77392: LIST
77393: LIST
77394: PUSH
77395: LD_INT 0
77397: PUSH
77398: LD_INT 3
77400: PUSH
77401: EMPTY
77402: LIST
77403: LIST
77404: PUSH
77405: LD_INT 1
77407: NEG
77408: PUSH
77409: LD_INT 2
77411: PUSH
77412: EMPTY
77413: LIST
77414: LIST
77415: PUSH
77416: EMPTY
77417: LIST
77418: LIST
77419: LIST
77420: ST_TO_ADDR
// DepotAr4 = [ [ - 2 , 1 ] , [ - 3 , 0 ] , [ - 3 , - 1 ] ] ;
77421: LD_ADDR_VAR 0 21
77425: PUSH
77426: LD_INT 2
77428: NEG
77429: PUSH
77430: LD_INT 1
77432: PUSH
77433: EMPTY
77434: LIST
77435: LIST
77436: PUSH
77437: LD_INT 3
77439: NEG
77440: PUSH
77441: LD_INT 0
77443: PUSH
77444: EMPTY
77445: LIST
77446: LIST
77447: PUSH
77448: LD_INT 3
77450: NEG
77451: PUSH
77452: LD_INT 1
77454: NEG
77455: PUSH
77456: EMPTY
77457: LIST
77458: LIST
77459: PUSH
77460: EMPTY
77461: LIST
77462: LIST
77463: LIST
77464: ST_TO_ADDR
// DepotAr5 = [ [ - 2 , - 3 ] , [ - 3 , - 2 ] , [ - 3 , - 3 ] ] ;
77465: LD_ADDR_VAR 0 22
77469: PUSH
77470: LD_INT 2
77472: NEG
77473: PUSH
77474: LD_INT 3
77476: NEG
77477: PUSH
77478: EMPTY
77479: LIST
77480: LIST
77481: PUSH
77482: LD_INT 3
77484: NEG
77485: PUSH
77486: LD_INT 2
77488: NEG
77489: PUSH
77490: EMPTY
77491: LIST
77492: LIST
77493: PUSH
77494: LD_INT 3
77496: NEG
77497: PUSH
77498: LD_INT 3
77500: NEG
77501: PUSH
77502: EMPTY
77503: LIST
77504: LIST
77505: PUSH
77506: EMPTY
77507: LIST
77508: LIST
77509: LIST
77510: ST_TO_ADDR
// DepotRu0 = [ [ 0 , - 3 ] , [ - 1 , - 4 ] , [ 1 , - 3 ] ] ;
77511: LD_ADDR_VAR 0 23
77515: PUSH
77516: LD_INT 0
77518: PUSH
77519: LD_INT 3
77521: NEG
77522: PUSH
77523: EMPTY
77524: LIST
77525: LIST
77526: PUSH
77527: LD_INT 1
77529: NEG
77530: PUSH
77531: LD_INT 4
77533: NEG
77534: PUSH
77535: EMPTY
77536: LIST
77537: LIST
77538: PUSH
77539: LD_INT 1
77541: PUSH
77542: LD_INT 3
77544: NEG
77545: PUSH
77546: EMPTY
77547: LIST
77548: LIST
77549: PUSH
77550: EMPTY
77551: LIST
77552: LIST
77553: LIST
77554: ST_TO_ADDR
// DepotRu1 = [ [ 3 , 0 ] , [ 3 , - 1 ] , [ 4 , 1 ] ] ;
77555: LD_ADDR_VAR 0 24
77559: PUSH
77560: LD_INT 3
77562: PUSH
77563: LD_INT 0
77565: PUSH
77566: EMPTY
77567: LIST
77568: LIST
77569: PUSH
77570: LD_INT 3
77572: PUSH
77573: LD_INT 1
77575: NEG
77576: PUSH
77577: EMPTY
77578: LIST
77579: LIST
77580: PUSH
77581: LD_INT 4
77583: PUSH
77584: LD_INT 1
77586: PUSH
77587: EMPTY
77588: LIST
77589: LIST
77590: PUSH
77591: EMPTY
77592: LIST
77593: LIST
77594: LIST
77595: ST_TO_ADDR
// DepotRu2 = [ [ 3 , 3 ] , [ 4 , 3 ] , [ 3 , 4 ] ] ;
77596: LD_ADDR_VAR 0 25
77600: PUSH
77601: LD_INT 3
77603: PUSH
77604: LD_INT 3
77606: PUSH
77607: EMPTY
77608: LIST
77609: LIST
77610: PUSH
77611: LD_INT 4
77613: PUSH
77614: LD_INT 3
77616: PUSH
77617: EMPTY
77618: LIST
77619: LIST
77620: PUSH
77621: LD_INT 3
77623: PUSH
77624: LD_INT 4
77626: PUSH
77627: EMPTY
77628: LIST
77629: LIST
77630: PUSH
77631: EMPTY
77632: LIST
77633: LIST
77634: LIST
77635: ST_TO_ADDR
// DepotRu3 = [ [ 0 , 3 ] , [ 1 , 4 ] , [ - 1 , 3 ] ] ;
77636: LD_ADDR_VAR 0 26
77640: PUSH
77641: LD_INT 0
77643: PUSH
77644: LD_INT 3
77646: PUSH
77647: EMPTY
77648: LIST
77649: LIST
77650: PUSH
77651: LD_INT 1
77653: PUSH
77654: LD_INT 4
77656: PUSH
77657: EMPTY
77658: LIST
77659: LIST
77660: PUSH
77661: LD_INT 1
77663: NEG
77664: PUSH
77665: LD_INT 3
77667: PUSH
77668: EMPTY
77669: LIST
77670: LIST
77671: PUSH
77672: EMPTY
77673: LIST
77674: LIST
77675: LIST
77676: ST_TO_ADDR
// DepotRu4 = [ [ - 3 , 0 ] , [ - 3 , 1 ] , [ - 4 , - 1 ] ] ;
77677: LD_ADDR_VAR 0 27
77681: PUSH
77682: LD_INT 3
77684: NEG
77685: PUSH
77686: LD_INT 0
77688: PUSH
77689: EMPTY
77690: LIST
77691: LIST
77692: PUSH
77693: LD_INT 3
77695: NEG
77696: PUSH
77697: LD_INT 1
77699: PUSH
77700: EMPTY
77701: LIST
77702: LIST
77703: PUSH
77704: LD_INT 4
77706: NEG
77707: PUSH
77708: LD_INT 1
77710: NEG
77711: PUSH
77712: EMPTY
77713: LIST
77714: LIST
77715: PUSH
77716: EMPTY
77717: LIST
77718: LIST
77719: LIST
77720: ST_TO_ADDR
// DepotRu5 = [ [ - 3 , - 3 ] , [ - 3 , - 4 ] , [ - 4 , - 3 ] ] ;
77721: LD_ADDR_VAR 0 28
77725: PUSH
77726: LD_INT 3
77728: NEG
77729: PUSH
77730: LD_INT 3
77732: NEG
77733: PUSH
77734: EMPTY
77735: LIST
77736: LIST
77737: PUSH
77738: LD_INT 3
77740: NEG
77741: PUSH
77742: LD_INT 4
77744: NEG
77745: PUSH
77746: EMPTY
77747: LIST
77748: LIST
77749: PUSH
77750: LD_INT 4
77752: NEG
77753: PUSH
77754: LD_INT 3
77756: NEG
77757: PUSH
77758: EMPTY
77759: LIST
77760: LIST
77761: PUSH
77762: EMPTY
77763: LIST
77764: LIST
77765: LIST
77766: ST_TO_ADDR
// Factory0 = [ [ - 1 , - 3 ] , [ 0 , - 3 ] , [ 1 , - 2 ] , [ - 1 , - 4 ] , [ 0 , - 4 ] , [ 1 , - 3 ] , [ - 1 , - 5 ] , [ 0 , - 5 ] , [ 1 , - 4 ] , [ - 1 , - 6 ] , [ 0 , - 6 ] , [ 1 , - 5 ] ] ;
77767: LD_ADDR_VAR 0 29
77771: PUSH
77772: LD_INT 1
77774: NEG
77775: PUSH
77776: LD_INT 3
77778: NEG
77779: PUSH
77780: EMPTY
77781: LIST
77782: LIST
77783: PUSH
77784: LD_INT 0
77786: PUSH
77787: LD_INT 3
77789: NEG
77790: PUSH
77791: EMPTY
77792: LIST
77793: LIST
77794: PUSH
77795: LD_INT 1
77797: PUSH
77798: LD_INT 2
77800: NEG
77801: PUSH
77802: EMPTY
77803: LIST
77804: LIST
77805: PUSH
77806: LD_INT 1
77808: NEG
77809: PUSH
77810: LD_INT 4
77812: NEG
77813: PUSH
77814: EMPTY
77815: LIST
77816: LIST
77817: PUSH
77818: LD_INT 0
77820: PUSH
77821: LD_INT 4
77823: NEG
77824: PUSH
77825: EMPTY
77826: LIST
77827: LIST
77828: PUSH
77829: LD_INT 1
77831: PUSH
77832: LD_INT 3
77834: NEG
77835: PUSH
77836: EMPTY
77837: LIST
77838: LIST
77839: PUSH
77840: LD_INT 1
77842: NEG
77843: PUSH
77844: LD_INT 5
77846: NEG
77847: PUSH
77848: EMPTY
77849: LIST
77850: LIST
77851: PUSH
77852: LD_INT 0
77854: PUSH
77855: LD_INT 5
77857: NEG
77858: PUSH
77859: EMPTY
77860: LIST
77861: LIST
77862: PUSH
77863: LD_INT 1
77865: PUSH
77866: LD_INT 4
77868: NEG
77869: PUSH
77870: EMPTY
77871: LIST
77872: LIST
77873: PUSH
77874: LD_INT 1
77876: NEG
77877: PUSH
77878: LD_INT 6
77880: NEG
77881: PUSH
77882: EMPTY
77883: LIST
77884: LIST
77885: PUSH
77886: LD_INT 0
77888: PUSH
77889: LD_INT 6
77891: NEG
77892: PUSH
77893: EMPTY
77894: LIST
77895: LIST
77896: PUSH
77897: LD_INT 1
77899: PUSH
77900: LD_INT 5
77902: NEG
77903: PUSH
77904: EMPTY
77905: LIST
77906: LIST
77907: PUSH
77908: EMPTY
77909: LIST
77910: LIST
77911: LIST
77912: LIST
77913: LIST
77914: LIST
77915: LIST
77916: LIST
77917: LIST
77918: LIST
77919: LIST
77920: LIST
77921: ST_TO_ADDR
// Factory1 = [ [ 2 , - 1 ] , [ 3 , 0 ] , [ 3 , 1 ] , [ 3 , - 1 ] , [ 4 , 0 ] , [ 4 , 1 ] , [ 4 , - 1 ] , [ 5 , 0 ] , [ 5 , 1 ] , [ 5 , - 1 ] , [ 6 , 0 ] , [ 6 , 1 ] ] ;
77922: LD_ADDR_VAR 0 30
77926: PUSH
77927: LD_INT 2
77929: PUSH
77930: LD_INT 1
77932: NEG
77933: PUSH
77934: EMPTY
77935: LIST
77936: LIST
77937: PUSH
77938: LD_INT 3
77940: PUSH
77941: LD_INT 0
77943: PUSH
77944: EMPTY
77945: LIST
77946: LIST
77947: PUSH
77948: LD_INT 3
77950: PUSH
77951: LD_INT 1
77953: PUSH
77954: EMPTY
77955: LIST
77956: LIST
77957: PUSH
77958: LD_INT 3
77960: PUSH
77961: LD_INT 1
77963: NEG
77964: PUSH
77965: EMPTY
77966: LIST
77967: LIST
77968: PUSH
77969: LD_INT 4
77971: PUSH
77972: LD_INT 0
77974: PUSH
77975: EMPTY
77976: LIST
77977: LIST
77978: PUSH
77979: LD_INT 4
77981: PUSH
77982: LD_INT 1
77984: PUSH
77985: EMPTY
77986: LIST
77987: LIST
77988: PUSH
77989: LD_INT 4
77991: PUSH
77992: LD_INT 1
77994: NEG
77995: PUSH
77996: EMPTY
77997: LIST
77998: LIST
77999: PUSH
78000: LD_INT 5
78002: PUSH
78003: LD_INT 0
78005: PUSH
78006: EMPTY
78007: LIST
78008: LIST
78009: PUSH
78010: LD_INT 5
78012: PUSH
78013: LD_INT 1
78015: PUSH
78016: EMPTY
78017: LIST
78018: LIST
78019: PUSH
78020: LD_INT 5
78022: PUSH
78023: LD_INT 1
78025: NEG
78026: PUSH
78027: EMPTY
78028: LIST
78029: LIST
78030: PUSH
78031: LD_INT 6
78033: PUSH
78034: LD_INT 0
78036: PUSH
78037: EMPTY
78038: LIST
78039: LIST
78040: PUSH
78041: LD_INT 6
78043: PUSH
78044: LD_INT 1
78046: PUSH
78047: EMPTY
78048: LIST
78049: LIST
78050: PUSH
78051: EMPTY
78052: LIST
78053: LIST
78054: LIST
78055: LIST
78056: LIST
78057: LIST
78058: LIST
78059: LIST
78060: LIST
78061: LIST
78062: LIST
78063: LIST
78064: ST_TO_ADDR
// Factory2 = [ [ 3 , 2 ] , [ 3 , 3 ] , [ 2 , 3 ] , [ 4 , 3 ] , [ 4 , 4 ] , [ 3 , 4 ] , [ 5 , 4 ] , [ 5 , 5 ] , [ 4 , 5 ] , [ 6 , 5 ] , [ 6 , 6 ] , [ 5 , 6 ] ] ;
78065: LD_ADDR_VAR 0 31
78069: PUSH
78070: LD_INT 3
78072: PUSH
78073: LD_INT 2
78075: PUSH
78076: EMPTY
78077: LIST
78078: LIST
78079: PUSH
78080: LD_INT 3
78082: PUSH
78083: LD_INT 3
78085: PUSH
78086: EMPTY
78087: LIST
78088: LIST
78089: PUSH
78090: LD_INT 2
78092: PUSH
78093: LD_INT 3
78095: PUSH
78096: EMPTY
78097: LIST
78098: LIST
78099: PUSH
78100: LD_INT 4
78102: PUSH
78103: LD_INT 3
78105: PUSH
78106: EMPTY
78107: LIST
78108: LIST
78109: PUSH
78110: LD_INT 4
78112: PUSH
78113: LD_INT 4
78115: PUSH
78116: EMPTY
78117: LIST
78118: LIST
78119: PUSH
78120: LD_INT 3
78122: PUSH
78123: LD_INT 4
78125: PUSH
78126: EMPTY
78127: LIST
78128: LIST
78129: PUSH
78130: LD_INT 5
78132: PUSH
78133: LD_INT 4
78135: PUSH
78136: EMPTY
78137: LIST
78138: LIST
78139: PUSH
78140: LD_INT 5
78142: PUSH
78143: LD_INT 5
78145: PUSH
78146: EMPTY
78147: LIST
78148: LIST
78149: PUSH
78150: LD_INT 4
78152: PUSH
78153: LD_INT 5
78155: PUSH
78156: EMPTY
78157: LIST
78158: LIST
78159: PUSH
78160: LD_INT 6
78162: PUSH
78163: LD_INT 5
78165: PUSH
78166: EMPTY
78167: LIST
78168: LIST
78169: PUSH
78170: LD_INT 6
78172: PUSH
78173: LD_INT 6
78175: PUSH
78176: EMPTY
78177: LIST
78178: LIST
78179: PUSH
78180: LD_INT 5
78182: PUSH
78183: LD_INT 6
78185: PUSH
78186: EMPTY
78187: LIST
78188: LIST
78189: PUSH
78190: EMPTY
78191: LIST
78192: LIST
78193: LIST
78194: LIST
78195: LIST
78196: LIST
78197: LIST
78198: LIST
78199: LIST
78200: LIST
78201: LIST
78202: LIST
78203: ST_TO_ADDR
// Factory3 = [ [ 1 , 3 ] , [ 0 , 3 ] , [ - 1 , 2 ] , [ 1 , 4 ] , [ 0 , 4 ] , [ - 1 , 3 ] , [ 1 , 5 ] , [ 0 , 5 ] , [ - 1 , 4 ] , [ 1 , 6 ] , [ 0 , 6 ] , [ - 1 , 5 ] ] ;
78204: LD_ADDR_VAR 0 32
78208: PUSH
78209: LD_INT 1
78211: PUSH
78212: LD_INT 3
78214: PUSH
78215: EMPTY
78216: LIST
78217: LIST
78218: PUSH
78219: LD_INT 0
78221: PUSH
78222: LD_INT 3
78224: PUSH
78225: EMPTY
78226: LIST
78227: LIST
78228: PUSH
78229: LD_INT 1
78231: NEG
78232: PUSH
78233: LD_INT 2
78235: PUSH
78236: EMPTY
78237: LIST
78238: LIST
78239: PUSH
78240: LD_INT 1
78242: PUSH
78243: LD_INT 4
78245: PUSH
78246: EMPTY
78247: LIST
78248: LIST
78249: PUSH
78250: LD_INT 0
78252: PUSH
78253: LD_INT 4
78255: PUSH
78256: EMPTY
78257: LIST
78258: LIST
78259: PUSH
78260: LD_INT 1
78262: NEG
78263: PUSH
78264: LD_INT 3
78266: PUSH
78267: EMPTY
78268: LIST
78269: LIST
78270: PUSH
78271: LD_INT 1
78273: PUSH
78274: LD_INT 5
78276: PUSH
78277: EMPTY
78278: LIST
78279: LIST
78280: PUSH
78281: LD_INT 0
78283: PUSH
78284: LD_INT 5
78286: PUSH
78287: EMPTY
78288: LIST
78289: LIST
78290: PUSH
78291: LD_INT 1
78293: NEG
78294: PUSH
78295: LD_INT 4
78297: PUSH
78298: EMPTY
78299: LIST
78300: LIST
78301: PUSH
78302: LD_INT 1
78304: PUSH
78305: LD_INT 6
78307: PUSH
78308: EMPTY
78309: LIST
78310: LIST
78311: PUSH
78312: LD_INT 0
78314: PUSH
78315: LD_INT 6
78317: PUSH
78318: EMPTY
78319: LIST
78320: LIST
78321: PUSH
78322: LD_INT 1
78324: NEG
78325: PUSH
78326: LD_INT 5
78328: PUSH
78329: EMPTY
78330: LIST
78331: LIST
78332: PUSH
78333: EMPTY
78334: LIST
78335: LIST
78336: LIST
78337: LIST
78338: LIST
78339: LIST
78340: LIST
78341: LIST
78342: LIST
78343: LIST
78344: LIST
78345: LIST
78346: ST_TO_ADDR
// Factory4 = [ [ - 2 , 1 ] , [ - 3 , 0 ] , [ - 3 , - 1 ] , [ - 3 , 1 ] , [ - 4 , 0 ] , [ - 4 , - 1 ] , [ - 4 , 1 ] , [ - 5 , 0 ] , [ - 5 , - 1 ] , [ - 5 , 1 ] , [ - 6 , 0 ] , [ - 6 , - 1 ] ] ;
78347: LD_ADDR_VAR 0 33
78351: PUSH
78352: LD_INT 2
78354: NEG
78355: PUSH
78356: LD_INT 1
78358: PUSH
78359: EMPTY
78360: LIST
78361: LIST
78362: PUSH
78363: LD_INT 3
78365: NEG
78366: PUSH
78367: LD_INT 0
78369: PUSH
78370: EMPTY
78371: LIST
78372: LIST
78373: PUSH
78374: LD_INT 3
78376: NEG
78377: PUSH
78378: LD_INT 1
78380: NEG
78381: PUSH
78382: EMPTY
78383: LIST
78384: LIST
78385: PUSH
78386: LD_INT 3
78388: NEG
78389: PUSH
78390: LD_INT 1
78392: PUSH
78393: EMPTY
78394: LIST
78395: LIST
78396: PUSH
78397: LD_INT 4
78399: NEG
78400: PUSH
78401: LD_INT 0
78403: PUSH
78404: EMPTY
78405: LIST
78406: LIST
78407: PUSH
78408: LD_INT 4
78410: NEG
78411: PUSH
78412: LD_INT 1
78414: NEG
78415: PUSH
78416: EMPTY
78417: LIST
78418: LIST
78419: PUSH
78420: LD_INT 4
78422: NEG
78423: PUSH
78424: LD_INT 1
78426: PUSH
78427: EMPTY
78428: LIST
78429: LIST
78430: PUSH
78431: LD_INT 5
78433: NEG
78434: PUSH
78435: LD_INT 0
78437: PUSH
78438: EMPTY
78439: LIST
78440: LIST
78441: PUSH
78442: LD_INT 5
78444: NEG
78445: PUSH
78446: LD_INT 1
78448: NEG
78449: PUSH
78450: EMPTY
78451: LIST
78452: LIST
78453: PUSH
78454: LD_INT 5
78456: NEG
78457: PUSH
78458: LD_INT 1
78460: PUSH
78461: EMPTY
78462: LIST
78463: LIST
78464: PUSH
78465: LD_INT 6
78467: NEG
78468: PUSH
78469: LD_INT 0
78471: PUSH
78472: EMPTY
78473: LIST
78474: LIST
78475: PUSH
78476: LD_INT 6
78478: NEG
78479: PUSH
78480: LD_INT 1
78482: NEG
78483: PUSH
78484: EMPTY
78485: LIST
78486: LIST
78487: PUSH
78488: EMPTY
78489: LIST
78490: LIST
78491: LIST
78492: LIST
78493: LIST
78494: LIST
78495: LIST
78496: LIST
78497: LIST
78498: LIST
78499: LIST
78500: LIST
78501: ST_TO_ADDR
// Factory5 = [ [ - 2 , - 3 ] , [ - 3 , - 2 ] , [ - 3 , - 3 ] , [ - 3 , - 4 ] , [ - 4 , - 3 ] , [ - 4 , - 4 ] , [ - 4 , - 5 ] , [ - 5 , - 4 ] , [ - 5 , - 5 ] , [ - 5 , - 6 ] , [ - 6 , - 5 ] , [ - 6 , - 6 ] ] ;
78502: LD_ADDR_VAR 0 34
78506: PUSH
78507: LD_INT 2
78509: NEG
78510: PUSH
78511: LD_INT 3
78513: NEG
78514: PUSH
78515: EMPTY
78516: LIST
78517: LIST
78518: PUSH
78519: LD_INT 3
78521: NEG
78522: PUSH
78523: LD_INT 2
78525: NEG
78526: PUSH
78527: EMPTY
78528: LIST
78529: LIST
78530: PUSH
78531: LD_INT 3
78533: NEG
78534: PUSH
78535: LD_INT 3
78537: NEG
78538: PUSH
78539: EMPTY
78540: LIST
78541: LIST
78542: PUSH
78543: LD_INT 3
78545: NEG
78546: PUSH
78547: LD_INT 4
78549: NEG
78550: PUSH
78551: EMPTY
78552: LIST
78553: LIST
78554: PUSH
78555: LD_INT 4
78557: NEG
78558: PUSH
78559: LD_INT 3
78561: NEG
78562: PUSH
78563: EMPTY
78564: LIST
78565: LIST
78566: PUSH
78567: LD_INT 4
78569: NEG
78570: PUSH
78571: LD_INT 4
78573: NEG
78574: PUSH
78575: EMPTY
78576: LIST
78577: LIST
78578: PUSH
78579: LD_INT 4
78581: NEG
78582: PUSH
78583: LD_INT 5
78585: NEG
78586: PUSH
78587: EMPTY
78588: LIST
78589: LIST
78590: PUSH
78591: LD_INT 5
78593: NEG
78594: PUSH
78595: LD_INT 4
78597: NEG
78598: PUSH
78599: EMPTY
78600: LIST
78601: LIST
78602: PUSH
78603: LD_INT 5
78605: NEG
78606: PUSH
78607: LD_INT 5
78609: NEG
78610: PUSH
78611: EMPTY
78612: LIST
78613: LIST
78614: PUSH
78615: LD_INT 5
78617: NEG
78618: PUSH
78619: LD_INT 6
78621: NEG
78622: PUSH
78623: EMPTY
78624: LIST
78625: LIST
78626: PUSH
78627: LD_INT 6
78629: NEG
78630: PUSH
78631: LD_INT 5
78633: NEG
78634: PUSH
78635: EMPTY
78636: LIST
78637: LIST
78638: PUSH
78639: LD_INT 6
78641: NEG
78642: PUSH
78643: LD_INT 6
78645: NEG
78646: PUSH
78647: EMPTY
78648: LIST
78649: LIST
78650: PUSH
78651: EMPTY
78652: LIST
78653: LIST
78654: LIST
78655: LIST
78656: LIST
78657: LIST
78658: LIST
78659: LIST
78660: LIST
78661: LIST
78662: LIST
78663: LIST
78664: ST_TO_ADDR
// Lab0 = [ [ 0 , - 2 ] , [ - 1 , - 3 ] , [ 1 , - 2 ] ] ;
78665: LD_ADDR_VAR 0 41
78669: PUSH
78670: LD_INT 0
78672: PUSH
78673: LD_INT 2
78675: NEG
78676: PUSH
78677: EMPTY
78678: LIST
78679: LIST
78680: PUSH
78681: LD_INT 1
78683: NEG
78684: PUSH
78685: LD_INT 3
78687: NEG
78688: PUSH
78689: EMPTY
78690: LIST
78691: LIST
78692: PUSH
78693: LD_INT 1
78695: PUSH
78696: LD_INT 2
78698: NEG
78699: PUSH
78700: EMPTY
78701: LIST
78702: LIST
78703: PUSH
78704: EMPTY
78705: LIST
78706: LIST
78707: LIST
78708: ST_TO_ADDR
// Lab1 = [ [ 2 , 0 ] , [ 2 , - 1 ] , [ 3 , 1 ] ] ;
78709: LD_ADDR_VAR 0 42
78713: PUSH
78714: LD_INT 2
78716: PUSH
78717: LD_INT 0
78719: PUSH
78720: EMPTY
78721: LIST
78722: LIST
78723: PUSH
78724: LD_INT 2
78726: PUSH
78727: LD_INT 1
78729: NEG
78730: PUSH
78731: EMPTY
78732: LIST
78733: LIST
78734: PUSH
78735: LD_INT 3
78737: PUSH
78738: LD_INT 1
78740: PUSH
78741: EMPTY
78742: LIST
78743: LIST
78744: PUSH
78745: EMPTY
78746: LIST
78747: LIST
78748: LIST
78749: ST_TO_ADDR
// Lab2 = [ [ 2 , 2 ] , [ 3 , 2 ] , [ 2 , 3 ] ] ;
78750: LD_ADDR_VAR 0 43
78754: PUSH
78755: LD_INT 2
78757: PUSH
78758: LD_INT 2
78760: PUSH
78761: EMPTY
78762: LIST
78763: LIST
78764: PUSH
78765: LD_INT 3
78767: PUSH
78768: LD_INT 2
78770: PUSH
78771: EMPTY
78772: LIST
78773: LIST
78774: PUSH
78775: LD_INT 2
78777: PUSH
78778: LD_INT 3
78780: PUSH
78781: EMPTY
78782: LIST
78783: LIST
78784: PUSH
78785: EMPTY
78786: LIST
78787: LIST
78788: LIST
78789: ST_TO_ADDR
// Lab3 = [ [ 0 , 2 ] , [ 1 , 3 ] , [ - 1 , 2 ] ] ;
78790: LD_ADDR_VAR 0 44
78794: PUSH
78795: LD_INT 0
78797: PUSH
78798: LD_INT 2
78800: PUSH
78801: EMPTY
78802: LIST
78803: LIST
78804: PUSH
78805: LD_INT 1
78807: PUSH
78808: LD_INT 3
78810: PUSH
78811: EMPTY
78812: LIST
78813: LIST
78814: PUSH
78815: LD_INT 1
78817: NEG
78818: PUSH
78819: LD_INT 2
78821: PUSH
78822: EMPTY
78823: LIST
78824: LIST
78825: PUSH
78826: EMPTY
78827: LIST
78828: LIST
78829: LIST
78830: ST_TO_ADDR
// Lab4 = [ [ - 2 , 0 ] , [ - 2 , 1 ] , [ - 3 , - 1 ] ] ;
78831: LD_ADDR_VAR 0 45
78835: PUSH
78836: LD_INT 2
78838: NEG
78839: PUSH
78840: LD_INT 0
78842: PUSH
78843: EMPTY
78844: LIST
78845: LIST
78846: PUSH
78847: LD_INT 2
78849: NEG
78850: PUSH
78851: LD_INT 1
78853: PUSH
78854: EMPTY
78855: LIST
78856: LIST
78857: PUSH
78858: LD_INT 3
78860: NEG
78861: PUSH
78862: LD_INT 1
78864: NEG
78865: PUSH
78866: EMPTY
78867: LIST
78868: LIST
78869: PUSH
78870: EMPTY
78871: LIST
78872: LIST
78873: LIST
78874: ST_TO_ADDR
// Lab5 = [ [ - 2 , - 2 ] , [ - 2 , - 3 ] , [ - 3 , - 2 ] ] ;
78875: LD_ADDR_VAR 0 46
78879: PUSH
78880: LD_INT 2
78882: NEG
78883: PUSH
78884: LD_INT 2
78886: NEG
78887: PUSH
78888: EMPTY
78889: LIST
78890: LIST
78891: PUSH
78892: LD_INT 2
78894: NEG
78895: PUSH
78896: LD_INT 3
78898: NEG
78899: PUSH
78900: EMPTY
78901: LIST
78902: LIST
78903: PUSH
78904: LD_INT 3
78906: NEG
78907: PUSH
78908: LD_INT 2
78910: NEG
78911: PUSH
78912: EMPTY
78913: LIST
78914: LIST
78915: PUSH
78916: EMPTY
78917: LIST
78918: LIST
78919: LIST
78920: ST_TO_ADDR
// ControlTower0 = [ [ - 2 , - 3 ] , [ - 1 , - 3 ] ] ;
78921: LD_ADDR_VAR 0 47
78925: PUSH
78926: LD_INT 2
78928: NEG
78929: PUSH
78930: LD_INT 3
78932: NEG
78933: PUSH
78934: EMPTY
78935: LIST
78936: LIST
78937: PUSH
78938: LD_INT 1
78940: NEG
78941: PUSH
78942: LD_INT 3
78944: NEG
78945: PUSH
78946: EMPTY
78947: LIST
78948: LIST
78949: PUSH
78950: EMPTY
78951: LIST
78952: LIST
78953: ST_TO_ADDR
// ControlTower1 = [ [ 1 , - 2 ] , [ 2 , - 1 ] ] ;
78954: LD_ADDR_VAR 0 48
78958: PUSH
78959: LD_INT 1
78961: PUSH
78962: LD_INT 2
78964: NEG
78965: PUSH
78966: EMPTY
78967: LIST
78968: LIST
78969: PUSH
78970: LD_INT 2
78972: PUSH
78973: LD_INT 1
78975: NEG
78976: PUSH
78977: EMPTY
78978: LIST
78979: LIST
78980: PUSH
78981: EMPTY
78982: LIST
78983: LIST
78984: ST_TO_ADDR
// ControlTower2 = [ [ 3 , 1 ] , [ 3 , 2 ] ] ;
78985: LD_ADDR_VAR 0 49
78989: PUSH
78990: LD_INT 3
78992: PUSH
78993: LD_INT 1
78995: PUSH
78996: EMPTY
78997: LIST
78998: LIST
78999: PUSH
79000: LD_INT 3
79002: PUSH
79003: LD_INT 2
79005: PUSH
79006: EMPTY
79007: LIST
79008: LIST
79009: PUSH
79010: EMPTY
79011: LIST
79012: LIST
79013: ST_TO_ADDR
// ControlTower3 = [ [ 2 , 3 ] , [ 1 , 3 ] ] ;
79014: LD_ADDR_VAR 0 50
79018: PUSH
79019: LD_INT 2
79021: PUSH
79022: LD_INT 3
79024: PUSH
79025: EMPTY
79026: LIST
79027: LIST
79028: PUSH
79029: LD_INT 1
79031: PUSH
79032: LD_INT 3
79034: PUSH
79035: EMPTY
79036: LIST
79037: LIST
79038: PUSH
79039: EMPTY
79040: LIST
79041: LIST
79042: ST_TO_ADDR
// ControlTower4 = [ [ - 1 , 2 ] , [ - 2 , 1 ] ] ;
79043: LD_ADDR_VAR 0 51
79047: PUSH
79048: LD_INT 1
79050: NEG
79051: PUSH
79052: LD_INT 2
79054: PUSH
79055: EMPTY
79056: LIST
79057: LIST
79058: PUSH
79059: LD_INT 2
79061: NEG
79062: PUSH
79063: LD_INT 1
79065: PUSH
79066: EMPTY
79067: LIST
79068: LIST
79069: PUSH
79070: EMPTY
79071: LIST
79072: LIST
79073: ST_TO_ADDR
// ControlTower5 = [ [ - 3 , - 1 ] , [ - 3 , - 2 ] ] ;
79074: LD_ADDR_VAR 0 52
79078: PUSH
79079: LD_INT 3
79081: NEG
79082: PUSH
79083: LD_INT 1
79085: NEG
79086: PUSH
79087: EMPTY
79088: LIST
79089: LIST
79090: PUSH
79091: LD_INT 3
79093: NEG
79094: PUSH
79095: LD_INT 2
79097: NEG
79098: PUSH
79099: EMPTY
79100: LIST
79101: LIST
79102: PUSH
79103: EMPTY
79104: LIST
79105: LIST
79106: ST_TO_ADDR
// Barracks0 = [ [ - 1 , - 3 ] , [ 0 , - 3 ] , [ 1 , - 2 ] ] ;
79107: LD_ADDR_VAR 0 53
79111: PUSH
79112: LD_INT 1
79114: NEG
79115: PUSH
79116: LD_INT 3
79118: NEG
79119: PUSH
79120: EMPTY
79121: LIST
79122: LIST
79123: PUSH
79124: LD_INT 0
79126: PUSH
79127: LD_INT 3
79129: NEG
79130: PUSH
79131: EMPTY
79132: LIST
79133: LIST
79134: PUSH
79135: LD_INT 1
79137: PUSH
79138: LD_INT 2
79140: NEG
79141: PUSH
79142: EMPTY
79143: LIST
79144: LIST
79145: PUSH
79146: EMPTY
79147: LIST
79148: LIST
79149: LIST
79150: ST_TO_ADDR
// Barracks1 = [ [ 2 , - 1 ] , [ 3 , 0 ] , [ 3 , 1 ] ] ;
79151: LD_ADDR_VAR 0 54
79155: PUSH
79156: LD_INT 2
79158: PUSH
79159: LD_INT 1
79161: NEG
79162: PUSH
79163: EMPTY
79164: LIST
79165: LIST
79166: PUSH
79167: LD_INT 3
79169: PUSH
79170: LD_INT 0
79172: PUSH
79173: EMPTY
79174: LIST
79175: LIST
79176: PUSH
79177: LD_INT 3
79179: PUSH
79180: LD_INT 1
79182: PUSH
79183: EMPTY
79184: LIST
79185: LIST
79186: PUSH
79187: EMPTY
79188: LIST
79189: LIST
79190: LIST
79191: ST_TO_ADDR
// Barracks2 = [ [ 3 , 2 ] , [ 3 , 3 ] , [ 2 , 3 ] ] ;
79192: LD_ADDR_VAR 0 55
79196: PUSH
79197: LD_INT 3
79199: PUSH
79200: LD_INT 2
79202: PUSH
79203: EMPTY
79204: LIST
79205: LIST
79206: PUSH
79207: LD_INT 3
79209: PUSH
79210: LD_INT 3
79212: PUSH
79213: EMPTY
79214: LIST
79215: LIST
79216: PUSH
79217: LD_INT 2
79219: PUSH
79220: LD_INT 3
79222: PUSH
79223: EMPTY
79224: LIST
79225: LIST
79226: PUSH
79227: EMPTY
79228: LIST
79229: LIST
79230: LIST
79231: ST_TO_ADDR
// Barracks3 = [ [ 1 , 3 ] , [ 0 , 3 ] , [ - 1 , 2 ] ] ;
79232: LD_ADDR_VAR 0 56
79236: PUSH
79237: LD_INT 1
79239: PUSH
79240: LD_INT 3
79242: PUSH
79243: EMPTY
79244: LIST
79245: LIST
79246: PUSH
79247: LD_INT 0
79249: PUSH
79250: LD_INT 3
79252: PUSH
79253: EMPTY
79254: LIST
79255: LIST
79256: PUSH
79257: LD_INT 1
79259: NEG
79260: PUSH
79261: LD_INT 2
79263: PUSH
79264: EMPTY
79265: LIST
79266: LIST
79267: PUSH
79268: EMPTY
79269: LIST
79270: LIST
79271: LIST
79272: ST_TO_ADDR
// Barracks4 = [ [ - 2 , 1 ] , [ - 3 , 0 ] , [ - 3 , - 1 ] ] ;
79273: LD_ADDR_VAR 0 57
79277: PUSH
79278: LD_INT 2
79280: NEG
79281: PUSH
79282: LD_INT 1
79284: PUSH
79285: EMPTY
79286: LIST
79287: LIST
79288: PUSH
79289: LD_INT 3
79291: NEG
79292: PUSH
79293: LD_INT 0
79295: PUSH
79296: EMPTY
79297: LIST
79298: LIST
79299: PUSH
79300: LD_INT 3
79302: NEG
79303: PUSH
79304: LD_INT 1
79306: NEG
79307: PUSH
79308: EMPTY
79309: LIST
79310: LIST
79311: PUSH
79312: EMPTY
79313: LIST
79314: LIST
79315: LIST
79316: ST_TO_ADDR
// Barracks5 = [ [ - 2 , - 3 ] , [ - 3 , - 2 ] , [ - 3 , - 3 ] ] ;
79317: LD_ADDR_VAR 0 58
79321: PUSH
79322: LD_INT 2
79324: NEG
79325: PUSH
79326: LD_INT 3
79328: NEG
79329: PUSH
79330: EMPTY
79331: LIST
79332: LIST
79333: PUSH
79334: LD_INT 3
79336: NEG
79337: PUSH
79338: LD_INT 2
79340: NEG
79341: PUSH
79342: EMPTY
79343: LIST
79344: LIST
79345: PUSH
79346: LD_INT 3
79348: NEG
79349: PUSH
79350: LD_INT 3
79352: NEG
79353: PUSH
79354: EMPTY
79355: LIST
79356: LIST
79357: PUSH
79358: EMPTY
79359: LIST
79360: LIST
79361: LIST
79362: ST_TO_ADDR
// Bunker0 = [ [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] ] ;
79363: LD_ADDR_VAR 0 59
79367: PUSH
79368: LD_INT 1
79370: NEG
79371: PUSH
79372: LD_INT 2
79374: NEG
79375: PUSH
79376: EMPTY
79377: LIST
79378: LIST
79379: PUSH
79380: LD_INT 0
79382: PUSH
79383: LD_INT 2
79385: NEG
79386: PUSH
79387: EMPTY
79388: LIST
79389: LIST
79390: PUSH
79391: LD_INT 1
79393: PUSH
79394: LD_INT 1
79396: NEG
79397: PUSH
79398: EMPTY
79399: LIST
79400: LIST
79401: PUSH
79402: EMPTY
79403: LIST
79404: LIST
79405: LIST
79406: ST_TO_ADDR
// Bunker1 = [ [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] ] ;
79407: LD_ADDR_VAR 0 60
79411: PUSH
79412: LD_INT 1
79414: PUSH
79415: LD_INT 1
79417: NEG
79418: PUSH
79419: EMPTY
79420: LIST
79421: LIST
79422: PUSH
79423: LD_INT 2
79425: PUSH
79426: LD_INT 0
79428: PUSH
79429: EMPTY
79430: LIST
79431: LIST
79432: PUSH
79433: LD_INT 2
79435: PUSH
79436: LD_INT 1
79438: PUSH
79439: EMPTY
79440: LIST
79441: LIST
79442: PUSH
79443: EMPTY
79444: LIST
79445: LIST
79446: LIST
79447: ST_TO_ADDR
// Bunker2 = [ [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] ] ;
79448: LD_ADDR_VAR 0 61
79452: PUSH
79453: LD_INT 2
79455: PUSH
79456: LD_INT 1
79458: PUSH
79459: EMPTY
79460: LIST
79461: LIST
79462: PUSH
79463: LD_INT 2
79465: PUSH
79466: LD_INT 2
79468: PUSH
79469: EMPTY
79470: LIST
79471: LIST
79472: PUSH
79473: LD_INT 1
79475: PUSH
79476: LD_INT 2
79478: PUSH
79479: EMPTY
79480: LIST
79481: LIST
79482: PUSH
79483: EMPTY
79484: LIST
79485: LIST
79486: LIST
79487: ST_TO_ADDR
// Bunker3 = [ [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] ] ;
79488: LD_ADDR_VAR 0 62
79492: PUSH
79493: LD_INT 1
79495: PUSH
79496: LD_INT 2
79498: PUSH
79499: EMPTY
79500: LIST
79501: LIST
79502: PUSH
79503: LD_INT 0
79505: PUSH
79506: LD_INT 2
79508: PUSH
79509: EMPTY
79510: LIST
79511: LIST
79512: PUSH
79513: LD_INT 1
79515: NEG
79516: PUSH
79517: LD_INT 1
79519: PUSH
79520: EMPTY
79521: LIST
79522: LIST
79523: PUSH
79524: EMPTY
79525: LIST
79526: LIST
79527: LIST
79528: ST_TO_ADDR
// Bunker4 = [ [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] ] ;
79529: LD_ADDR_VAR 0 63
79533: PUSH
79534: LD_INT 1
79536: NEG
79537: PUSH
79538: LD_INT 1
79540: PUSH
79541: EMPTY
79542: LIST
79543: LIST
79544: PUSH
79545: LD_INT 2
79547: NEG
79548: PUSH
79549: LD_INT 0
79551: PUSH
79552: EMPTY
79553: LIST
79554: LIST
79555: PUSH
79556: LD_INT 2
79558: NEG
79559: PUSH
79560: LD_INT 1
79562: NEG
79563: PUSH
79564: EMPTY
79565: LIST
79566: LIST
79567: PUSH
79568: EMPTY
79569: LIST
79570: LIST
79571: LIST
79572: ST_TO_ADDR
// Bunker5 = [ [ - 1 , - 2 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
79573: LD_ADDR_VAR 0 64
79577: PUSH
79578: LD_INT 1
79580: NEG
79581: PUSH
79582: LD_INT 2
79584: NEG
79585: PUSH
79586: EMPTY
79587: LIST
79588: LIST
79589: PUSH
79590: LD_INT 2
79592: NEG
79593: PUSH
79594: LD_INT 1
79596: NEG
79597: PUSH
79598: EMPTY
79599: LIST
79600: LIST
79601: PUSH
79602: LD_INT 2
79604: NEG
79605: PUSH
79606: LD_INT 2
79608: NEG
79609: PUSH
79610: EMPTY
79611: LIST
79612: LIST
79613: PUSH
79614: EMPTY
79615: LIST
79616: LIST
79617: LIST
79618: ST_TO_ADDR
// end ; 2 :
79619: GO 82885
79621: LD_INT 2
79623: DOUBLE
79624: EQUAL
79625: IFTRUE 79629
79627: GO 82884
79629: POP
// begin Factory0 = [ [ 4 , 0 ] , [ 4 , - 1 ] , [ 5 , 0 ] , [ 5 , 1 ] , [ 4 , 1 ] , [ 3 , 0 ] , [ 3 , - 1 ] , [ 3 , - 2 ] , [ 5 , 2 ] , [ 3 , 3 ] , [ 3 , 2 ] , [ 4 , 3 ] , [ 4 , 4 ] , [ 3 , 4 ] , [ 2 , 3 ] , [ 2 , 2 ] , [ 4 , 2 ] , [ 2 , 4 ] , [ 0 , 4 ] , [ 0 , 3 ] , [ 1 , 4 ] , [ 1 , 5 ] , [ 0 , 5 ] , [ - 1 , 4 ] , [ - 1 , 3 ] , [ 2 , 5 ] , [ - 2 , 3 ] , [ - 3 , 0 ] , [ - 3 , - 1 ] , [ - 2 , 0 ] , [ - 2 , 1 ] , [ - 3 , 1 ] , [ - 4 , 0 ] , [ - 4 , - 1 ] , [ - 4 , - 2 ] , [ - 2 , 2 ] , [ - 4 , - 4 ] , [ - 4 , - 5 ] , [ - 3 , - 4 ] , [ - 3 , - 3 ] , [ - 4 , - 3 ] , [ - 5 , - 4 ] , [ - 5 , - 5 ] , [ - 3 , - 5 ] , [ - 5 , - 3 ] ] ;
79630: LD_ADDR_VAR 0 29
79634: PUSH
79635: LD_INT 4
79637: PUSH
79638: LD_INT 0
79640: PUSH
79641: EMPTY
79642: LIST
79643: LIST
79644: PUSH
79645: LD_INT 4
79647: PUSH
79648: LD_INT 1
79650: NEG
79651: PUSH
79652: EMPTY
79653: LIST
79654: LIST
79655: PUSH
79656: LD_INT 5
79658: PUSH
79659: LD_INT 0
79661: PUSH
79662: EMPTY
79663: LIST
79664: LIST
79665: PUSH
79666: LD_INT 5
79668: PUSH
79669: LD_INT 1
79671: PUSH
79672: EMPTY
79673: LIST
79674: LIST
79675: PUSH
79676: LD_INT 4
79678: PUSH
79679: LD_INT 1
79681: PUSH
79682: EMPTY
79683: LIST
79684: LIST
79685: PUSH
79686: LD_INT 3
79688: PUSH
79689: LD_INT 0
79691: PUSH
79692: EMPTY
79693: LIST
79694: LIST
79695: PUSH
79696: LD_INT 3
79698: PUSH
79699: LD_INT 1
79701: NEG
79702: PUSH
79703: EMPTY
79704: LIST
79705: LIST
79706: PUSH
79707: LD_INT 3
79709: PUSH
79710: LD_INT 2
79712: NEG
79713: PUSH
79714: EMPTY
79715: LIST
79716: LIST
79717: PUSH
79718: LD_INT 5
79720: PUSH
79721: LD_INT 2
79723: PUSH
79724: EMPTY
79725: LIST
79726: LIST
79727: PUSH
79728: LD_INT 3
79730: PUSH
79731: LD_INT 3
79733: PUSH
79734: EMPTY
79735: LIST
79736: LIST
79737: PUSH
79738: LD_INT 3
79740: PUSH
79741: LD_INT 2
79743: PUSH
79744: EMPTY
79745: LIST
79746: LIST
79747: PUSH
79748: LD_INT 4
79750: PUSH
79751: LD_INT 3
79753: PUSH
79754: EMPTY
79755: LIST
79756: LIST
79757: PUSH
79758: LD_INT 4
79760: PUSH
79761: LD_INT 4
79763: PUSH
79764: EMPTY
79765: LIST
79766: LIST
79767: PUSH
79768: LD_INT 3
79770: PUSH
79771: LD_INT 4
79773: PUSH
79774: EMPTY
79775: LIST
79776: LIST
79777: PUSH
79778: LD_INT 2
79780: PUSH
79781: LD_INT 3
79783: PUSH
79784: EMPTY
79785: LIST
79786: LIST
79787: PUSH
79788: LD_INT 2
79790: PUSH
79791: LD_INT 2
79793: PUSH
79794: EMPTY
79795: LIST
79796: LIST
79797: PUSH
79798: LD_INT 4
79800: PUSH
79801: LD_INT 2
79803: PUSH
79804: EMPTY
79805: LIST
79806: LIST
79807: PUSH
79808: LD_INT 2
79810: PUSH
79811: LD_INT 4
79813: PUSH
79814: EMPTY
79815: LIST
79816: LIST
79817: PUSH
79818: LD_INT 0
79820: PUSH
79821: LD_INT 4
79823: PUSH
79824: EMPTY
79825: LIST
79826: LIST
79827: PUSH
79828: LD_INT 0
79830: PUSH
79831: LD_INT 3
79833: PUSH
79834: EMPTY
79835: LIST
79836: LIST
79837: PUSH
79838: LD_INT 1
79840: PUSH
79841: LD_INT 4
79843: PUSH
79844: EMPTY
79845: LIST
79846: LIST
79847: PUSH
79848: LD_INT 1
79850: PUSH
79851: LD_INT 5
79853: PUSH
79854: EMPTY
79855: LIST
79856: LIST
79857: PUSH
79858: LD_INT 0
79860: PUSH
79861: LD_INT 5
79863: PUSH
79864: EMPTY
79865: LIST
79866: LIST
79867: PUSH
79868: LD_INT 1
79870: NEG
79871: PUSH
79872: LD_INT 4
79874: PUSH
79875: EMPTY
79876: LIST
79877: LIST
79878: PUSH
79879: LD_INT 1
79881: NEG
79882: PUSH
79883: LD_INT 3
79885: PUSH
79886: EMPTY
79887: LIST
79888: LIST
79889: PUSH
79890: LD_INT 2
79892: PUSH
79893: LD_INT 5
79895: PUSH
79896: EMPTY
79897: LIST
79898: LIST
79899: PUSH
79900: LD_INT 2
79902: NEG
79903: PUSH
79904: LD_INT 3
79906: PUSH
79907: EMPTY
79908: LIST
79909: LIST
79910: PUSH
79911: LD_INT 3
79913: NEG
79914: PUSH
79915: LD_INT 0
79917: PUSH
79918: EMPTY
79919: LIST
79920: LIST
79921: PUSH
79922: LD_INT 3
79924: NEG
79925: PUSH
79926: LD_INT 1
79928: NEG
79929: PUSH
79930: EMPTY
79931: LIST
79932: LIST
79933: PUSH
79934: LD_INT 2
79936: NEG
79937: PUSH
79938: LD_INT 0
79940: PUSH
79941: EMPTY
79942: LIST
79943: LIST
79944: PUSH
79945: LD_INT 2
79947: NEG
79948: PUSH
79949: LD_INT 1
79951: PUSH
79952: EMPTY
79953: LIST
79954: LIST
79955: PUSH
79956: LD_INT 3
79958: NEG
79959: PUSH
79960: LD_INT 1
79962: PUSH
79963: EMPTY
79964: LIST
79965: LIST
79966: PUSH
79967: LD_INT 4
79969: NEG
79970: PUSH
79971: LD_INT 0
79973: PUSH
79974: EMPTY
79975: LIST
79976: LIST
79977: PUSH
79978: LD_INT 4
79980: NEG
79981: PUSH
79982: LD_INT 1
79984: NEG
79985: PUSH
79986: EMPTY
79987: LIST
79988: LIST
79989: PUSH
79990: LD_INT 4
79992: NEG
79993: PUSH
79994: LD_INT 2
79996: NEG
79997: PUSH
79998: EMPTY
79999: LIST
80000: LIST
80001: PUSH
80002: LD_INT 2
80004: NEG
80005: PUSH
80006: LD_INT 2
80008: PUSH
80009: EMPTY
80010: LIST
80011: LIST
80012: PUSH
80013: LD_INT 4
80015: NEG
80016: PUSH
80017: LD_INT 4
80019: NEG
80020: PUSH
80021: EMPTY
80022: LIST
80023: LIST
80024: PUSH
80025: LD_INT 4
80027: NEG
80028: PUSH
80029: LD_INT 5
80031: NEG
80032: PUSH
80033: EMPTY
80034: LIST
80035: LIST
80036: PUSH
80037: LD_INT 3
80039: NEG
80040: PUSH
80041: LD_INT 4
80043: NEG
80044: PUSH
80045: EMPTY
80046: LIST
80047: LIST
80048: PUSH
80049: LD_INT 3
80051: NEG
80052: PUSH
80053: LD_INT 3
80055: NEG
80056: PUSH
80057: EMPTY
80058: LIST
80059: LIST
80060: PUSH
80061: LD_INT 4
80063: NEG
80064: PUSH
80065: LD_INT 3
80067: NEG
80068: PUSH
80069: EMPTY
80070: LIST
80071: LIST
80072: PUSH
80073: LD_INT 5
80075: NEG
80076: PUSH
80077: LD_INT 4
80079: NEG
80080: PUSH
80081: EMPTY
80082: LIST
80083: LIST
80084: PUSH
80085: LD_INT 5
80087: NEG
80088: PUSH
80089: LD_INT 5
80091: NEG
80092: PUSH
80093: EMPTY
80094: LIST
80095: LIST
80096: PUSH
80097: LD_INT 3
80099: NEG
80100: PUSH
80101: LD_INT 5
80103: NEG
80104: PUSH
80105: EMPTY
80106: LIST
80107: LIST
80108: PUSH
80109: LD_INT 5
80111: NEG
80112: PUSH
80113: LD_INT 3
80115: NEG
80116: PUSH
80117: EMPTY
80118: LIST
80119: LIST
80120: PUSH
80121: EMPTY
80122: LIST
80123: LIST
80124: LIST
80125: LIST
80126: LIST
80127: LIST
80128: LIST
80129: LIST
80130: LIST
80131: LIST
80132: LIST
80133: LIST
80134: LIST
80135: LIST
80136: LIST
80137: LIST
80138: LIST
80139: LIST
80140: LIST
80141: LIST
80142: LIST
80143: LIST
80144: LIST
80145: LIST
80146: LIST
80147: LIST
80148: LIST
80149: LIST
80150: LIST
80151: LIST
80152: LIST
80153: LIST
80154: LIST
80155: LIST
80156: LIST
80157: LIST
80158: LIST
80159: LIST
80160: LIST
80161: LIST
80162: LIST
80163: LIST
80164: LIST
80165: LIST
80166: LIST
80167: ST_TO_ADDR
// Factory1 = [ [ 4 , 4 ] , [ 4 , 3 ] , [ 5 , 4 ] , [ 5 , 5 ] , [ 4 , 5 ] , [ 3 , 4 ] , [ 3 , 3 ] , [ 5 , 3 ] , [ 3 , 5 ] , [ 0 , 3 ] , [ 0 , 2 ] , [ 1 , 3 ] , [ 1 , 4 ] , [ 0 , 4 ] , [ - 1 , 3 ] , [ - 1 , 2 ] , [ 2 , 4 ] , [ - 2 , 2 ] , [ - 4 , 0 ] , [ - 4 , - 1 ] , [ - 3 , 0 ] , [ - 3 , 1 ] , [ - 4 , 1 ] , [ - 5 , 0 ] , [ - 5 , - 1 ] , [ - 5 , - 2 ] , [ - 3 , 2 ] , [ - 3 , - 3 ] , [ - 3 , - 4 ] , [ - 2 , - 3 ] , [ - 2 , - 2 ] , [ - 3 , - 2 ] , [ - 4 , - 3 ] , [ - 4 , - 4 ] , [ - 2 , - 4 ] , [ - 4 , - 2 ] , [ 0 , - 4 ] , [ 0 , - 5 ] , [ 1 , - 4 ] , [ 1 , - 3 ] , [ 0 , - 3 ] , [ - 1 , - 4 ] , [ - 1 , - 5 ] , [ 2 , - 3 ] , [ - 2 , - 5 ] ] ;
80168: LD_ADDR_VAR 0 30
80172: PUSH
80173: LD_INT 4
80175: PUSH
80176: LD_INT 4
80178: PUSH
80179: EMPTY
80180: LIST
80181: LIST
80182: PUSH
80183: LD_INT 4
80185: PUSH
80186: LD_INT 3
80188: PUSH
80189: EMPTY
80190: LIST
80191: LIST
80192: PUSH
80193: LD_INT 5
80195: PUSH
80196: LD_INT 4
80198: PUSH
80199: EMPTY
80200: LIST
80201: LIST
80202: PUSH
80203: LD_INT 5
80205: PUSH
80206: LD_INT 5
80208: PUSH
80209: EMPTY
80210: LIST
80211: LIST
80212: PUSH
80213: LD_INT 4
80215: PUSH
80216: LD_INT 5
80218: PUSH
80219: EMPTY
80220: LIST
80221: LIST
80222: PUSH
80223: LD_INT 3
80225: PUSH
80226: LD_INT 4
80228: PUSH
80229: EMPTY
80230: LIST
80231: LIST
80232: PUSH
80233: LD_INT 3
80235: PUSH
80236: LD_INT 3
80238: PUSH
80239: EMPTY
80240: LIST
80241: LIST
80242: PUSH
80243: LD_INT 5
80245: PUSH
80246: LD_INT 3
80248: PUSH
80249: EMPTY
80250: LIST
80251: LIST
80252: PUSH
80253: LD_INT 3
80255: PUSH
80256: LD_INT 5
80258: PUSH
80259: EMPTY
80260: LIST
80261: LIST
80262: PUSH
80263: LD_INT 0
80265: PUSH
80266: LD_INT 3
80268: PUSH
80269: EMPTY
80270: LIST
80271: LIST
80272: PUSH
80273: LD_INT 0
80275: PUSH
80276: LD_INT 2
80278: PUSH
80279: EMPTY
80280: LIST
80281: LIST
80282: PUSH
80283: LD_INT 1
80285: PUSH
80286: LD_INT 3
80288: PUSH
80289: EMPTY
80290: LIST
80291: LIST
80292: PUSH
80293: LD_INT 1
80295: PUSH
80296: LD_INT 4
80298: PUSH
80299: EMPTY
80300: LIST
80301: LIST
80302: PUSH
80303: LD_INT 0
80305: PUSH
80306: LD_INT 4
80308: PUSH
80309: EMPTY
80310: LIST
80311: LIST
80312: PUSH
80313: LD_INT 1
80315: NEG
80316: PUSH
80317: LD_INT 3
80319: PUSH
80320: EMPTY
80321: LIST
80322: LIST
80323: PUSH
80324: LD_INT 1
80326: NEG
80327: PUSH
80328: LD_INT 2
80330: PUSH
80331: EMPTY
80332: LIST
80333: LIST
80334: PUSH
80335: LD_INT 2
80337: PUSH
80338: LD_INT 4
80340: PUSH
80341: EMPTY
80342: LIST
80343: LIST
80344: PUSH
80345: LD_INT 2
80347: NEG
80348: PUSH
80349: LD_INT 2
80351: PUSH
80352: EMPTY
80353: LIST
80354: LIST
80355: PUSH
80356: LD_INT 4
80358: NEG
80359: PUSH
80360: LD_INT 0
80362: PUSH
80363: EMPTY
80364: LIST
80365: LIST
80366: PUSH
80367: LD_INT 4
80369: NEG
80370: PUSH
80371: LD_INT 1
80373: NEG
80374: PUSH
80375: EMPTY
80376: LIST
80377: LIST
80378: PUSH
80379: LD_INT 3
80381: NEG
80382: PUSH
80383: LD_INT 0
80385: PUSH
80386: EMPTY
80387: LIST
80388: LIST
80389: PUSH
80390: LD_INT 3
80392: NEG
80393: PUSH
80394: LD_INT 1
80396: PUSH
80397: EMPTY
80398: LIST
80399: LIST
80400: PUSH
80401: LD_INT 4
80403: NEG
80404: PUSH
80405: LD_INT 1
80407: PUSH
80408: EMPTY
80409: LIST
80410: LIST
80411: PUSH
80412: LD_INT 5
80414: NEG
80415: PUSH
80416: LD_INT 0
80418: PUSH
80419: EMPTY
80420: LIST
80421: LIST
80422: PUSH
80423: LD_INT 5
80425: NEG
80426: PUSH
80427: LD_INT 1
80429: NEG
80430: PUSH
80431: EMPTY
80432: LIST
80433: LIST
80434: PUSH
80435: LD_INT 5
80437: NEG
80438: PUSH
80439: LD_INT 2
80441: NEG
80442: PUSH
80443: EMPTY
80444: LIST
80445: LIST
80446: PUSH
80447: LD_INT 3
80449: NEG
80450: PUSH
80451: LD_INT 2
80453: PUSH
80454: EMPTY
80455: LIST
80456: LIST
80457: PUSH
80458: LD_INT 3
80460: NEG
80461: PUSH
80462: LD_INT 3
80464: NEG
80465: PUSH
80466: EMPTY
80467: LIST
80468: LIST
80469: PUSH
80470: LD_INT 3
80472: NEG
80473: PUSH
80474: LD_INT 4
80476: NEG
80477: PUSH
80478: EMPTY
80479: LIST
80480: LIST
80481: PUSH
80482: LD_INT 2
80484: NEG
80485: PUSH
80486: LD_INT 3
80488: NEG
80489: PUSH
80490: EMPTY
80491: LIST
80492: LIST
80493: PUSH
80494: LD_INT 2
80496: NEG
80497: PUSH
80498: LD_INT 2
80500: NEG
80501: PUSH
80502: EMPTY
80503: LIST
80504: LIST
80505: PUSH
80506: LD_INT 3
80508: NEG
80509: PUSH
80510: LD_INT 2
80512: NEG
80513: PUSH
80514: EMPTY
80515: LIST
80516: LIST
80517: PUSH
80518: LD_INT 4
80520: NEG
80521: PUSH
80522: LD_INT 3
80524: NEG
80525: PUSH
80526: EMPTY
80527: LIST
80528: LIST
80529: PUSH
80530: LD_INT 4
80532: NEG
80533: PUSH
80534: LD_INT 4
80536: NEG
80537: PUSH
80538: EMPTY
80539: LIST
80540: LIST
80541: PUSH
80542: LD_INT 2
80544: NEG
80545: PUSH
80546: LD_INT 4
80548: NEG
80549: PUSH
80550: EMPTY
80551: LIST
80552: LIST
80553: PUSH
80554: LD_INT 4
80556: NEG
80557: PUSH
80558: LD_INT 2
80560: NEG
80561: PUSH
80562: EMPTY
80563: LIST
80564: LIST
80565: PUSH
80566: LD_INT 0
80568: PUSH
80569: LD_INT 4
80571: NEG
80572: PUSH
80573: EMPTY
80574: LIST
80575: LIST
80576: PUSH
80577: LD_INT 0
80579: PUSH
80580: LD_INT 5
80582: NEG
80583: PUSH
80584: EMPTY
80585: LIST
80586: LIST
80587: PUSH
80588: LD_INT 1
80590: PUSH
80591: LD_INT 4
80593: NEG
80594: PUSH
80595: EMPTY
80596: LIST
80597: LIST
80598: PUSH
80599: LD_INT 1
80601: PUSH
80602: LD_INT 3
80604: NEG
80605: PUSH
80606: EMPTY
80607: LIST
80608: LIST
80609: PUSH
80610: LD_INT 0
80612: PUSH
80613: LD_INT 3
80615: NEG
80616: PUSH
80617: EMPTY
80618: LIST
80619: LIST
80620: PUSH
80621: LD_INT 1
80623: NEG
80624: PUSH
80625: LD_INT 4
80627: NEG
80628: PUSH
80629: EMPTY
80630: LIST
80631: LIST
80632: PUSH
80633: LD_INT 1
80635: NEG
80636: PUSH
80637: LD_INT 5
80639: NEG
80640: PUSH
80641: EMPTY
80642: LIST
80643: LIST
80644: PUSH
80645: LD_INT 2
80647: PUSH
80648: LD_INT 3
80650: NEG
80651: PUSH
80652: EMPTY
80653: LIST
80654: LIST
80655: PUSH
80656: LD_INT 2
80658: NEG
80659: PUSH
80660: LD_INT 5
80662: NEG
80663: PUSH
80664: EMPTY
80665: LIST
80666: LIST
80667: PUSH
80668: EMPTY
80669: LIST
80670: LIST
80671: LIST
80672: LIST
80673: LIST
80674: LIST
80675: LIST
80676: LIST
80677: LIST
80678: LIST
80679: LIST
80680: LIST
80681: LIST
80682: LIST
80683: LIST
80684: LIST
80685: LIST
80686: LIST
80687: LIST
80688: LIST
80689: LIST
80690: LIST
80691: LIST
80692: LIST
80693: LIST
80694: LIST
80695: LIST
80696: LIST
80697: LIST
80698: LIST
80699: LIST
80700: LIST
80701: LIST
80702: LIST
80703: LIST
80704: LIST
80705: LIST
80706: LIST
80707: LIST
80708: LIST
80709: LIST
80710: LIST
80711: LIST
80712: LIST
80713: LIST
80714: ST_TO_ADDR
// Factory2 = [ [ 0 , 4 ] , [ 0 , 3 ] , [ 1 , 4 ] , [ 1 , 5 ] , [ 0 , 5 ] , [ - 1 , 4 ] , [ - 1 , 3 ] , [ 2 , 5 ] , [ - 2 , 3 ] , [ - 3 , 0 ] , [ - 3 , - 1 ] , [ - 2 , 0 ] , [ - 2 , 1 ] , [ - 3 , 1 ] , [ - 4 , 0 ] , [ - 4 , - 1 ] , [ - 4 , - 2 ] , [ - 2 , 2 ] , [ - 4 , - 4 ] , [ - 4 , - 5 ] , [ - 3 , - 4 ] , [ - 3 , - 3 ] , [ - 4 , - 3 ] , [ - 5 , - 4 ] , [ - 5 , - 5 ] , [ - 3 , - 5 ] , [ - 5 , - 3 ] , [ 0 , - 3 ] , [ 0 , - 4 ] , [ 1 , - 3 ] , [ 1 , - 2 ] , [ 0 , - 2 ] , [ - 1 , - 3 ] , [ - 1 , - 4 ] , [ 2 , - 2 ] , [ - 2 , - 4 ] , [ 4 , 0 ] , [ 4 , - 1 ] , [ 5 , 0 ] , [ 5 , 1 ] , [ 4 , 1 ] , [ 3 , 0 ] , [ 3 , - 1 ] , [ 3 , - 2 ] , [ 5 , 2 ] ] ;
80715: LD_ADDR_VAR 0 31
80719: PUSH
80720: LD_INT 0
80722: PUSH
80723: LD_INT 4
80725: PUSH
80726: EMPTY
80727: LIST
80728: LIST
80729: PUSH
80730: LD_INT 0
80732: PUSH
80733: LD_INT 3
80735: PUSH
80736: EMPTY
80737: LIST
80738: LIST
80739: PUSH
80740: LD_INT 1
80742: PUSH
80743: LD_INT 4
80745: PUSH
80746: EMPTY
80747: LIST
80748: LIST
80749: PUSH
80750: LD_INT 1
80752: PUSH
80753: LD_INT 5
80755: PUSH
80756: EMPTY
80757: LIST
80758: LIST
80759: PUSH
80760: LD_INT 0
80762: PUSH
80763: LD_INT 5
80765: PUSH
80766: EMPTY
80767: LIST
80768: LIST
80769: PUSH
80770: LD_INT 1
80772: NEG
80773: PUSH
80774: LD_INT 4
80776: PUSH
80777: EMPTY
80778: LIST
80779: LIST
80780: PUSH
80781: LD_INT 1
80783: NEG
80784: PUSH
80785: LD_INT 3
80787: PUSH
80788: EMPTY
80789: LIST
80790: LIST
80791: PUSH
80792: LD_INT 2
80794: PUSH
80795: LD_INT 5
80797: PUSH
80798: EMPTY
80799: LIST
80800: LIST
80801: PUSH
80802: LD_INT 2
80804: NEG
80805: PUSH
80806: LD_INT 3
80808: PUSH
80809: EMPTY
80810: LIST
80811: LIST
80812: PUSH
80813: LD_INT 3
80815: NEG
80816: PUSH
80817: LD_INT 0
80819: PUSH
80820: EMPTY
80821: LIST
80822: LIST
80823: PUSH
80824: LD_INT 3
80826: NEG
80827: PUSH
80828: LD_INT 1
80830: NEG
80831: PUSH
80832: EMPTY
80833: LIST
80834: LIST
80835: PUSH
80836: LD_INT 2
80838: NEG
80839: PUSH
80840: LD_INT 0
80842: PUSH
80843: EMPTY
80844: LIST
80845: LIST
80846: PUSH
80847: LD_INT 2
80849: NEG
80850: PUSH
80851: LD_INT 1
80853: PUSH
80854: EMPTY
80855: LIST
80856: LIST
80857: PUSH
80858: LD_INT 3
80860: NEG
80861: PUSH
80862: LD_INT 1
80864: PUSH
80865: EMPTY
80866: LIST
80867: LIST
80868: PUSH
80869: LD_INT 4
80871: NEG
80872: PUSH
80873: LD_INT 0
80875: PUSH
80876: EMPTY
80877: LIST
80878: LIST
80879: PUSH
80880: LD_INT 4
80882: NEG
80883: PUSH
80884: LD_INT 1
80886: NEG
80887: PUSH
80888: EMPTY
80889: LIST
80890: LIST
80891: PUSH
80892: LD_INT 4
80894: NEG
80895: PUSH
80896: LD_INT 2
80898: NEG
80899: PUSH
80900: EMPTY
80901: LIST
80902: LIST
80903: PUSH
80904: LD_INT 2
80906: NEG
80907: PUSH
80908: LD_INT 2
80910: PUSH
80911: EMPTY
80912: LIST
80913: LIST
80914: PUSH
80915: LD_INT 4
80917: NEG
80918: PUSH
80919: LD_INT 4
80921: NEG
80922: PUSH
80923: EMPTY
80924: LIST
80925: LIST
80926: PUSH
80927: LD_INT 4
80929: NEG
80930: PUSH
80931: LD_INT 5
80933: NEG
80934: PUSH
80935: EMPTY
80936: LIST
80937: LIST
80938: PUSH
80939: LD_INT 3
80941: NEG
80942: PUSH
80943: LD_INT 4
80945: NEG
80946: PUSH
80947: EMPTY
80948: LIST
80949: LIST
80950: PUSH
80951: LD_INT 3
80953: NEG
80954: PUSH
80955: LD_INT 3
80957: NEG
80958: PUSH
80959: EMPTY
80960: LIST
80961: LIST
80962: PUSH
80963: LD_INT 4
80965: NEG
80966: PUSH
80967: LD_INT 3
80969: NEG
80970: PUSH
80971: EMPTY
80972: LIST
80973: LIST
80974: PUSH
80975: LD_INT 5
80977: NEG
80978: PUSH
80979: LD_INT 4
80981: NEG
80982: PUSH
80983: EMPTY
80984: LIST
80985: LIST
80986: PUSH
80987: LD_INT 5
80989: NEG
80990: PUSH
80991: LD_INT 5
80993: NEG
80994: PUSH
80995: EMPTY
80996: LIST
80997: LIST
80998: PUSH
80999: LD_INT 3
81001: NEG
81002: PUSH
81003: LD_INT 5
81005: NEG
81006: PUSH
81007: EMPTY
81008: LIST
81009: LIST
81010: PUSH
81011: LD_INT 5
81013: NEG
81014: PUSH
81015: LD_INT 3
81017: NEG
81018: PUSH
81019: EMPTY
81020: LIST
81021: LIST
81022: PUSH
81023: LD_INT 0
81025: PUSH
81026: LD_INT 3
81028: NEG
81029: PUSH
81030: EMPTY
81031: LIST
81032: LIST
81033: PUSH
81034: LD_INT 0
81036: PUSH
81037: LD_INT 4
81039: NEG
81040: PUSH
81041: EMPTY
81042: LIST
81043: LIST
81044: PUSH
81045: LD_INT 1
81047: PUSH
81048: LD_INT 3
81050: NEG
81051: PUSH
81052: EMPTY
81053: LIST
81054: LIST
81055: PUSH
81056: LD_INT 1
81058: PUSH
81059: LD_INT 2
81061: NEG
81062: PUSH
81063: EMPTY
81064: LIST
81065: LIST
81066: PUSH
81067: LD_INT 0
81069: PUSH
81070: LD_INT 2
81072: NEG
81073: PUSH
81074: EMPTY
81075: LIST
81076: LIST
81077: PUSH
81078: LD_INT 1
81080: NEG
81081: PUSH
81082: LD_INT 3
81084: NEG
81085: PUSH
81086: EMPTY
81087: LIST
81088: LIST
81089: PUSH
81090: LD_INT 1
81092: NEG
81093: PUSH
81094: LD_INT 4
81096: NEG
81097: PUSH
81098: EMPTY
81099: LIST
81100: LIST
81101: PUSH
81102: LD_INT 2
81104: PUSH
81105: LD_INT 2
81107: NEG
81108: PUSH
81109: EMPTY
81110: LIST
81111: LIST
81112: PUSH
81113: LD_INT 2
81115: NEG
81116: PUSH
81117: LD_INT 4
81119: NEG
81120: PUSH
81121: EMPTY
81122: LIST
81123: LIST
81124: PUSH
81125: LD_INT 4
81127: PUSH
81128: LD_INT 0
81130: PUSH
81131: EMPTY
81132: LIST
81133: LIST
81134: PUSH
81135: LD_INT 4
81137: PUSH
81138: LD_INT 1
81140: NEG
81141: PUSH
81142: EMPTY
81143: LIST
81144: LIST
81145: PUSH
81146: LD_INT 5
81148: PUSH
81149: LD_INT 0
81151: PUSH
81152: EMPTY
81153: LIST
81154: LIST
81155: PUSH
81156: LD_INT 5
81158: PUSH
81159: LD_INT 1
81161: PUSH
81162: EMPTY
81163: LIST
81164: LIST
81165: PUSH
81166: LD_INT 4
81168: PUSH
81169: LD_INT 1
81171: PUSH
81172: EMPTY
81173: LIST
81174: LIST
81175: PUSH
81176: LD_INT 3
81178: PUSH
81179: LD_INT 0
81181: PUSH
81182: EMPTY
81183: LIST
81184: LIST
81185: PUSH
81186: LD_INT 3
81188: PUSH
81189: LD_INT 1
81191: NEG
81192: PUSH
81193: EMPTY
81194: LIST
81195: LIST
81196: PUSH
81197: LD_INT 3
81199: PUSH
81200: LD_INT 2
81202: NEG
81203: PUSH
81204: EMPTY
81205: LIST
81206: LIST
81207: PUSH
81208: LD_INT 5
81210: PUSH
81211: LD_INT 2
81213: PUSH
81214: EMPTY
81215: LIST
81216: LIST
81217: PUSH
81218: EMPTY
81219: LIST
81220: LIST
81221: LIST
81222: LIST
81223: LIST
81224: LIST
81225: LIST
81226: LIST
81227: LIST
81228: LIST
81229: LIST
81230: LIST
81231: LIST
81232: LIST
81233: LIST
81234: LIST
81235: LIST
81236: LIST
81237: LIST
81238: LIST
81239: LIST
81240: LIST
81241: LIST
81242: LIST
81243: LIST
81244: LIST
81245: LIST
81246: LIST
81247: LIST
81248: LIST
81249: LIST
81250: LIST
81251: LIST
81252: LIST
81253: LIST
81254: LIST
81255: LIST
81256: LIST
81257: LIST
81258: LIST
81259: LIST
81260: LIST
81261: LIST
81262: LIST
81263: LIST
81264: ST_TO_ADDR
// Factory3 = [ [ - 4 , 0 ] , [ - 4 , - 1 ] , [ - 3 , 0 ] , [ - 3 , 1 ] , [ - 4 , 1 ] , [ - 5 , 0 ] , [ - 5 , - 1 ] , [ - 5 , - 2 ] , [ - 3 , 2 ] , [ - 3 , - 3 ] , [ - 3 , - 4 ] , [ - 2 , - 3 ] , [ - 2 , - 2 ] , [ - 3 , - 2 ] , [ - 4 , - 3 ] , [ - 4 , - 4 ] , [ - 2 , - 4 ] , [ - 4 , - 2 ] , [ 0 , - 4 ] , [ 0 , - 5 ] , [ 1 , - 4 ] , [ 1 , - 3 ] , [ 0 , - 3 ] , [ - 1 , - 4 ] , [ - 1 , - 5 ] , [ 2 , - 3 ] , [ - 2 , - 5 ] , [ 3 , 0 ] , [ 3 , - 1 ] , [ 4 , 0 ] , [ 4 , 1 ] , [ 3 , 1 ] , [ 2 , 0 ] , [ 2 , - 1 ] , [ 2 , - 2 ] , [ 4 , 2 ] , [ 4 , 4 ] , [ 4 , 3 ] , [ 5 , 4 ] , [ 5 , 5 ] , [ 4 , 5 ] , [ 3 , 4 ] , [ 3 , 3 ] , [ 5 , 3 ] , [ 3 , 5 ] ] ;
81265: LD_ADDR_VAR 0 32
81269: PUSH
81270: LD_INT 4
81272: NEG
81273: PUSH
81274: LD_INT 0
81276: PUSH
81277: EMPTY
81278: LIST
81279: LIST
81280: PUSH
81281: LD_INT 4
81283: NEG
81284: PUSH
81285: LD_INT 1
81287: NEG
81288: PUSH
81289: EMPTY
81290: LIST
81291: LIST
81292: PUSH
81293: LD_INT 3
81295: NEG
81296: PUSH
81297: LD_INT 0
81299: PUSH
81300: EMPTY
81301: LIST
81302: LIST
81303: PUSH
81304: LD_INT 3
81306: NEG
81307: PUSH
81308: LD_INT 1
81310: PUSH
81311: EMPTY
81312: LIST
81313: LIST
81314: PUSH
81315: LD_INT 4
81317: NEG
81318: PUSH
81319: LD_INT 1
81321: PUSH
81322: EMPTY
81323: LIST
81324: LIST
81325: PUSH
81326: LD_INT 5
81328: NEG
81329: PUSH
81330: LD_INT 0
81332: PUSH
81333: EMPTY
81334: LIST
81335: LIST
81336: PUSH
81337: LD_INT 5
81339: NEG
81340: PUSH
81341: LD_INT 1
81343: NEG
81344: PUSH
81345: EMPTY
81346: LIST
81347: LIST
81348: PUSH
81349: LD_INT 5
81351: NEG
81352: PUSH
81353: LD_INT 2
81355: NEG
81356: PUSH
81357: EMPTY
81358: LIST
81359: LIST
81360: PUSH
81361: LD_INT 3
81363: NEG
81364: PUSH
81365: LD_INT 2
81367: PUSH
81368: EMPTY
81369: LIST
81370: LIST
81371: PUSH
81372: LD_INT 3
81374: NEG
81375: PUSH
81376: LD_INT 3
81378: NEG
81379: PUSH
81380: EMPTY
81381: LIST
81382: LIST
81383: PUSH
81384: LD_INT 3
81386: NEG
81387: PUSH
81388: LD_INT 4
81390: NEG
81391: PUSH
81392: EMPTY
81393: LIST
81394: LIST
81395: PUSH
81396: LD_INT 2
81398: NEG
81399: PUSH
81400: LD_INT 3
81402: NEG
81403: PUSH
81404: EMPTY
81405: LIST
81406: LIST
81407: PUSH
81408: LD_INT 2
81410: NEG
81411: PUSH
81412: LD_INT 2
81414: NEG
81415: PUSH
81416: EMPTY
81417: LIST
81418: LIST
81419: PUSH
81420: LD_INT 3
81422: NEG
81423: PUSH
81424: LD_INT 2
81426: NEG
81427: PUSH
81428: EMPTY
81429: LIST
81430: LIST
81431: PUSH
81432: LD_INT 4
81434: NEG
81435: PUSH
81436: LD_INT 3
81438: NEG
81439: PUSH
81440: EMPTY
81441: LIST
81442: LIST
81443: PUSH
81444: LD_INT 4
81446: NEG
81447: PUSH
81448: LD_INT 4
81450: NEG
81451: PUSH
81452: EMPTY
81453: LIST
81454: LIST
81455: PUSH
81456: LD_INT 2
81458: NEG
81459: PUSH
81460: LD_INT 4
81462: NEG
81463: PUSH
81464: EMPTY
81465: LIST
81466: LIST
81467: PUSH
81468: LD_INT 4
81470: NEG
81471: PUSH
81472: LD_INT 2
81474: NEG
81475: PUSH
81476: EMPTY
81477: LIST
81478: LIST
81479: PUSH
81480: LD_INT 0
81482: PUSH
81483: LD_INT 4
81485: NEG
81486: PUSH
81487: EMPTY
81488: LIST
81489: LIST
81490: PUSH
81491: LD_INT 0
81493: PUSH
81494: LD_INT 5
81496: NEG
81497: PUSH
81498: EMPTY
81499: LIST
81500: LIST
81501: PUSH
81502: LD_INT 1
81504: PUSH
81505: LD_INT 4
81507: NEG
81508: PUSH
81509: EMPTY
81510: LIST
81511: LIST
81512: PUSH
81513: LD_INT 1
81515: PUSH
81516: LD_INT 3
81518: NEG
81519: PUSH
81520: EMPTY
81521: LIST
81522: LIST
81523: PUSH
81524: LD_INT 0
81526: PUSH
81527: LD_INT 3
81529: NEG
81530: PUSH
81531: EMPTY
81532: LIST
81533: LIST
81534: PUSH
81535: LD_INT 1
81537: NEG
81538: PUSH
81539: LD_INT 4
81541: NEG
81542: PUSH
81543: EMPTY
81544: LIST
81545: LIST
81546: PUSH
81547: LD_INT 1
81549: NEG
81550: PUSH
81551: LD_INT 5
81553: NEG
81554: PUSH
81555: EMPTY
81556: LIST
81557: LIST
81558: PUSH
81559: LD_INT 2
81561: PUSH
81562: LD_INT 3
81564: NEG
81565: PUSH
81566: EMPTY
81567: LIST
81568: LIST
81569: PUSH
81570: LD_INT 2
81572: NEG
81573: PUSH
81574: LD_INT 5
81576: NEG
81577: PUSH
81578: EMPTY
81579: LIST
81580: LIST
81581: PUSH
81582: LD_INT 3
81584: PUSH
81585: LD_INT 0
81587: PUSH
81588: EMPTY
81589: LIST
81590: LIST
81591: PUSH
81592: LD_INT 3
81594: PUSH
81595: LD_INT 1
81597: NEG
81598: PUSH
81599: EMPTY
81600: LIST
81601: LIST
81602: PUSH
81603: LD_INT 4
81605: PUSH
81606: LD_INT 0
81608: PUSH
81609: EMPTY
81610: LIST
81611: LIST
81612: PUSH
81613: LD_INT 4
81615: PUSH
81616: LD_INT 1
81618: PUSH
81619: EMPTY
81620: LIST
81621: LIST
81622: PUSH
81623: LD_INT 3
81625: PUSH
81626: LD_INT 1
81628: PUSH
81629: EMPTY
81630: LIST
81631: LIST
81632: PUSH
81633: LD_INT 2
81635: PUSH
81636: LD_INT 0
81638: PUSH
81639: EMPTY
81640: LIST
81641: LIST
81642: PUSH
81643: LD_INT 2
81645: PUSH
81646: LD_INT 1
81648: NEG
81649: PUSH
81650: EMPTY
81651: LIST
81652: LIST
81653: PUSH
81654: LD_INT 2
81656: PUSH
81657: LD_INT 2
81659: NEG
81660: PUSH
81661: EMPTY
81662: LIST
81663: LIST
81664: PUSH
81665: LD_INT 4
81667: PUSH
81668: LD_INT 2
81670: PUSH
81671: EMPTY
81672: LIST
81673: LIST
81674: PUSH
81675: LD_INT 4
81677: PUSH
81678: LD_INT 4
81680: PUSH
81681: EMPTY
81682: LIST
81683: LIST
81684: PUSH
81685: LD_INT 4
81687: PUSH
81688: LD_INT 3
81690: PUSH
81691: EMPTY
81692: LIST
81693: LIST
81694: PUSH
81695: LD_INT 5
81697: PUSH
81698: LD_INT 4
81700: PUSH
81701: EMPTY
81702: LIST
81703: LIST
81704: PUSH
81705: LD_INT 5
81707: PUSH
81708: LD_INT 5
81710: PUSH
81711: EMPTY
81712: LIST
81713: LIST
81714: PUSH
81715: LD_INT 4
81717: PUSH
81718: LD_INT 5
81720: PUSH
81721: EMPTY
81722: LIST
81723: LIST
81724: PUSH
81725: LD_INT 3
81727: PUSH
81728: LD_INT 4
81730: PUSH
81731: EMPTY
81732: LIST
81733: LIST
81734: PUSH
81735: LD_INT 3
81737: PUSH
81738: LD_INT 3
81740: PUSH
81741: EMPTY
81742: LIST
81743: LIST
81744: PUSH
81745: LD_INT 5
81747: PUSH
81748: LD_INT 3
81750: PUSH
81751: EMPTY
81752: LIST
81753: LIST
81754: PUSH
81755: LD_INT 3
81757: PUSH
81758: LD_INT 5
81760: PUSH
81761: EMPTY
81762: LIST
81763: LIST
81764: PUSH
81765: EMPTY
81766: LIST
81767: LIST
81768: LIST
81769: LIST
81770: LIST
81771: LIST
81772: LIST
81773: LIST
81774: LIST
81775: LIST
81776: LIST
81777: LIST
81778: LIST
81779: LIST
81780: LIST
81781: LIST
81782: LIST
81783: LIST
81784: LIST
81785: LIST
81786: LIST
81787: LIST
81788: LIST
81789: LIST
81790: LIST
81791: LIST
81792: LIST
81793: LIST
81794: LIST
81795: LIST
81796: LIST
81797: LIST
81798: LIST
81799: LIST
81800: LIST
81801: LIST
81802: LIST
81803: LIST
81804: LIST
81805: LIST
81806: LIST
81807: LIST
81808: LIST
81809: LIST
81810: LIST
81811: ST_TO_ADDR
// Factory4 = [ [ - 4 , - 4 ] , [ - 4 , - 5 ] , [ - 3 , - 4 ] , [ - 3 , - 3 ] , [ - 4 , - 3 ] , [ - 5 , - 4 ] , [ - 5 , - 5 ] , [ - 3 , - 5 ] , [ - 5 , - 3 ] , [ 0 , - 3 ] , [ 0 , - 4 ] , [ 1 , - 3 ] , [ 1 , - 2 ] , [ 0 , - 2 ] , [ - 1 , - 3 ] , [ - 1 , - 4 ] , [ 2 , - 2 ] , [ - 2 , - 4 ] , [ 4 , 0 ] , [ 4 , - 1 ] , [ 5 , 0 ] , [ 5 , 1 ] , [ 4 , 1 ] , [ 3 , 0 ] , [ 3 , - 1 ] , [ 3 , - 2 ] , [ 5 , 2 ] , [ 3 , 3 ] , [ 3 , 2 ] , [ 4 , 3 ] , [ 4 , 4 ] , [ 3 , 4 ] , [ 2 , 3 ] , [ 2 , 2 ] , [ 4 , 2 ] , [ 2 , 4 ] , [ 0 , 4 ] , [ 0 , 3 ] , [ 1 , 4 ] , [ 1 , 5 ] , [ 0 , 5 ] , [ - 1 , 4 ] , [ - 1 , 3 ] , [ 2 , 5 ] , [ - 2 , 3 ] ] ;
81812: LD_ADDR_VAR 0 33
81816: PUSH
81817: LD_INT 4
81819: NEG
81820: PUSH
81821: LD_INT 4
81823: NEG
81824: PUSH
81825: EMPTY
81826: LIST
81827: LIST
81828: PUSH
81829: LD_INT 4
81831: NEG
81832: PUSH
81833: LD_INT 5
81835: NEG
81836: PUSH
81837: EMPTY
81838: LIST
81839: LIST
81840: PUSH
81841: LD_INT 3
81843: NEG
81844: PUSH
81845: LD_INT 4
81847: NEG
81848: PUSH
81849: EMPTY
81850: LIST
81851: LIST
81852: PUSH
81853: LD_INT 3
81855: NEG
81856: PUSH
81857: LD_INT 3
81859: NEG
81860: PUSH
81861: EMPTY
81862: LIST
81863: LIST
81864: PUSH
81865: LD_INT 4
81867: NEG
81868: PUSH
81869: LD_INT 3
81871: NEG
81872: PUSH
81873: EMPTY
81874: LIST
81875: LIST
81876: PUSH
81877: LD_INT 5
81879: NEG
81880: PUSH
81881: LD_INT 4
81883: NEG
81884: PUSH
81885: EMPTY
81886: LIST
81887: LIST
81888: PUSH
81889: LD_INT 5
81891: NEG
81892: PUSH
81893: LD_INT 5
81895: NEG
81896: PUSH
81897: EMPTY
81898: LIST
81899: LIST
81900: PUSH
81901: LD_INT 3
81903: NEG
81904: PUSH
81905: LD_INT 5
81907: NEG
81908: PUSH
81909: EMPTY
81910: LIST
81911: LIST
81912: PUSH
81913: LD_INT 5
81915: NEG
81916: PUSH
81917: LD_INT 3
81919: NEG
81920: PUSH
81921: EMPTY
81922: LIST
81923: LIST
81924: PUSH
81925: LD_INT 0
81927: PUSH
81928: LD_INT 3
81930: NEG
81931: PUSH
81932: EMPTY
81933: LIST
81934: LIST
81935: PUSH
81936: LD_INT 0
81938: PUSH
81939: LD_INT 4
81941: NEG
81942: PUSH
81943: EMPTY
81944: LIST
81945: LIST
81946: PUSH
81947: LD_INT 1
81949: PUSH
81950: LD_INT 3
81952: NEG
81953: PUSH
81954: EMPTY
81955: LIST
81956: LIST
81957: PUSH
81958: LD_INT 1
81960: PUSH
81961: LD_INT 2
81963: NEG
81964: PUSH
81965: EMPTY
81966: LIST
81967: LIST
81968: PUSH
81969: LD_INT 0
81971: PUSH
81972: LD_INT 2
81974: NEG
81975: PUSH
81976: EMPTY
81977: LIST
81978: LIST
81979: PUSH
81980: LD_INT 1
81982: NEG
81983: PUSH
81984: LD_INT 3
81986: NEG
81987: PUSH
81988: EMPTY
81989: LIST
81990: LIST
81991: PUSH
81992: LD_INT 1
81994: NEG
81995: PUSH
81996: LD_INT 4
81998: NEG
81999: PUSH
82000: EMPTY
82001: LIST
82002: LIST
82003: PUSH
82004: LD_INT 2
82006: PUSH
82007: LD_INT 2
82009: NEG
82010: PUSH
82011: EMPTY
82012: LIST
82013: LIST
82014: PUSH
82015: LD_INT 2
82017: NEG
82018: PUSH
82019: LD_INT 4
82021: NEG
82022: PUSH
82023: EMPTY
82024: LIST
82025: LIST
82026: PUSH
82027: LD_INT 4
82029: PUSH
82030: LD_INT 0
82032: PUSH
82033: EMPTY
82034: LIST
82035: LIST
82036: PUSH
82037: LD_INT 4
82039: PUSH
82040: LD_INT 1
82042: NEG
82043: PUSH
82044: EMPTY
82045: LIST
82046: LIST
82047: PUSH
82048: LD_INT 5
82050: PUSH
82051: LD_INT 0
82053: PUSH
82054: EMPTY
82055: LIST
82056: LIST
82057: PUSH
82058: LD_INT 5
82060: PUSH
82061: LD_INT 1
82063: PUSH
82064: EMPTY
82065: LIST
82066: LIST
82067: PUSH
82068: LD_INT 4
82070: PUSH
82071: LD_INT 1
82073: PUSH
82074: EMPTY
82075: LIST
82076: LIST
82077: PUSH
82078: LD_INT 3
82080: PUSH
82081: LD_INT 0
82083: PUSH
82084: EMPTY
82085: LIST
82086: LIST
82087: PUSH
82088: LD_INT 3
82090: PUSH
82091: LD_INT 1
82093: NEG
82094: PUSH
82095: EMPTY
82096: LIST
82097: LIST
82098: PUSH
82099: LD_INT 3
82101: PUSH
82102: LD_INT 2
82104: NEG
82105: PUSH
82106: EMPTY
82107: LIST
82108: LIST
82109: PUSH
82110: LD_INT 5
82112: PUSH
82113: LD_INT 2
82115: PUSH
82116: EMPTY
82117: LIST
82118: LIST
82119: PUSH
82120: LD_INT 3
82122: PUSH
82123: LD_INT 3
82125: PUSH
82126: EMPTY
82127: LIST
82128: LIST
82129: PUSH
82130: LD_INT 3
82132: PUSH
82133: LD_INT 2
82135: PUSH
82136: EMPTY
82137: LIST
82138: LIST
82139: PUSH
82140: LD_INT 4
82142: PUSH
82143: LD_INT 3
82145: PUSH
82146: EMPTY
82147: LIST
82148: LIST
82149: PUSH
82150: LD_INT 4
82152: PUSH
82153: LD_INT 4
82155: PUSH
82156: EMPTY
82157: LIST
82158: LIST
82159: PUSH
82160: LD_INT 3
82162: PUSH
82163: LD_INT 4
82165: PUSH
82166: EMPTY
82167: LIST
82168: LIST
82169: PUSH
82170: LD_INT 2
82172: PUSH
82173: LD_INT 3
82175: PUSH
82176: EMPTY
82177: LIST
82178: LIST
82179: PUSH
82180: LD_INT 2
82182: PUSH
82183: LD_INT 2
82185: PUSH
82186: EMPTY
82187: LIST
82188: LIST
82189: PUSH
82190: LD_INT 4
82192: PUSH
82193: LD_INT 2
82195: PUSH
82196: EMPTY
82197: LIST
82198: LIST
82199: PUSH
82200: LD_INT 2
82202: PUSH
82203: LD_INT 4
82205: PUSH
82206: EMPTY
82207: LIST
82208: LIST
82209: PUSH
82210: LD_INT 0
82212: PUSH
82213: LD_INT 4
82215: PUSH
82216: EMPTY
82217: LIST
82218: LIST
82219: PUSH
82220: LD_INT 0
82222: PUSH
82223: LD_INT 3
82225: PUSH
82226: EMPTY
82227: LIST
82228: LIST
82229: PUSH
82230: LD_INT 1
82232: PUSH
82233: LD_INT 4
82235: PUSH
82236: EMPTY
82237: LIST
82238: LIST
82239: PUSH
82240: LD_INT 1
82242: PUSH
82243: LD_INT 5
82245: PUSH
82246: EMPTY
82247: LIST
82248: LIST
82249: PUSH
82250: LD_INT 0
82252: PUSH
82253: LD_INT 5
82255: PUSH
82256: EMPTY
82257: LIST
82258: LIST
82259: PUSH
82260: LD_INT 1
82262: NEG
82263: PUSH
82264: LD_INT 4
82266: PUSH
82267: EMPTY
82268: LIST
82269: LIST
82270: PUSH
82271: LD_INT 1
82273: NEG
82274: PUSH
82275: LD_INT 3
82277: PUSH
82278: EMPTY
82279: LIST
82280: LIST
82281: PUSH
82282: LD_INT 2
82284: PUSH
82285: LD_INT 5
82287: PUSH
82288: EMPTY
82289: LIST
82290: LIST
82291: PUSH
82292: LD_INT 2
82294: NEG
82295: PUSH
82296: LD_INT 3
82298: PUSH
82299: EMPTY
82300: LIST
82301: LIST
82302: PUSH
82303: EMPTY
82304: LIST
82305: LIST
82306: LIST
82307: LIST
82308: LIST
82309: LIST
82310: LIST
82311: LIST
82312: LIST
82313: LIST
82314: LIST
82315: LIST
82316: LIST
82317: LIST
82318: LIST
82319: LIST
82320: LIST
82321: LIST
82322: LIST
82323: LIST
82324: LIST
82325: LIST
82326: LIST
82327: LIST
82328: LIST
82329: LIST
82330: LIST
82331: LIST
82332: LIST
82333: LIST
82334: LIST
82335: LIST
82336: LIST
82337: LIST
82338: LIST
82339: LIST
82340: LIST
82341: LIST
82342: LIST
82343: LIST
82344: LIST
82345: LIST
82346: LIST
82347: LIST
82348: LIST
82349: ST_TO_ADDR
// Factory5 = [ [ 0 , - 4 ] , [ 0 , - 5 ] , [ 1 , - 4 ] , [ 1 , - 3 ] , [ 0 , - 3 ] , [ - 1 , - 4 ] , [ - 1 , - 5 ] , [ 2 , - 3 ] , [ - 2 , - 5 ] , [ 3 , 0 ] , [ 3 , - 1 ] , [ 4 , 0 ] , [ 4 , 1 ] , [ 3 , 1 ] , [ 2 , 0 ] , [ 2 , - 1 ] , [ 2 , - 2 ] , [ 4 , 2 ] , [ 4 , 4 ] , [ 4 , 3 ] , [ 5 , 4 ] , [ 5 , 5 ] , [ 4 , 5 ] , [ 3 , 4 ] , [ 3 , 3 ] , [ 5 , 3 ] , [ 3 , 5 ] , [ 0 , 3 ] , [ 0 , 2 ] , [ 1 , 3 ] , [ 1 , 4 ] , [ 0 , 4 ] , [ - 1 , 3 ] , [ - 1 , 2 ] , [ 2 , 4 ] , [ - 2 , 2 ] , [ - 4 , 0 ] , [ - 4 , - 1 ] , [ - 3 , 0 ] , [ - 3 , 1 ] , [ - 4 , 1 ] , [ - 5 , 0 ] , [ - 5 , - 1 ] , [ - 5 , - 2 ] , [ - 3 , 2 ] ] ;
82350: LD_ADDR_VAR 0 34
82354: PUSH
82355: LD_INT 0
82357: PUSH
82358: LD_INT 4
82360: NEG
82361: PUSH
82362: EMPTY
82363: LIST
82364: LIST
82365: PUSH
82366: LD_INT 0
82368: PUSH
82369: LD_INT 5
82371: NEG
82372: PUSH
82373: EMPTY
82374: LIST
82375: LIST
82376: PUSH
82377: LD_INT 1
82379: PUSH
82380: LD_INT 4
82382: NEG
82383: PUSH
82384: EMPTY
82385: LIST
82386: LIST
82387: PUSH
82388: LD_INT 1
82390: PUSH
82391: LD_INT 3
82393: NEG
82394: PUSH
82395: EMPTY
82396: LIST
82397: LIST
82398: PUSH
82399: LD_INT 0
82401: PUSH
82402: LD_INT 3
82404: NEG
82405: PUSH
82406: EMPTY
82407: LIST
82408: LIST
82409: PUSH
82410: LD_INT 1
82412: NEG
82413: PUSH
82414: LD_INT 4
82416: NEG
82417: PUSH
82418: EMPTY
82419: LIST
82420: LIST
82421: PUSH
82422: LD_INT 1
82424: NEG
82425: PUSH
82426: LD_INT 5
82428: NEG
82429: PUSH
82430: EMPTY
82431: LIST
82432: LIST
82433: PUSH
82434: LD_INT 2
82436: PUSH
82437: LD_INT 3
82439: NEG
82440: PUSH
82441: EMPTY
82442: LIST
82443: LIST
82444: PUSH
82445: LD_INT 2
82447: NEG
82448: PUSH
82449: LD_INT 5
82451: NEG
82452: PUSH
82453: EMPTY
82454: LIST
82455: LIST
82456: PUSH
82457: LD_INT 3
82459: PUSH
82460: LD_INT 0
82462: PUSH
82463: EMPTY
82464: LIST
82465: LIST
82466: PUSH
82467: LD_INT 3
82469: PUSH
82470: LD_INT 1
82472: NEG
82473: PUSH
82474: EMPTY
82475: LIST
82476: LIST
82477: PUSH
82478: LD_INT 4
82480: PUSH
82481: LD_INT 0
82483: PUSH
82484: EMPTY
82485: LIST
82486: LIST
82487: PUSH
82488: LD_INT 4
82490: PUSH
82491: LD_INT 1
82493: PUSH
82494: EMPTY
82495: LIST
82496: LIST
82497: PUSH
82498: LD_INT 3
82500: PUSH
82501: LD_INT 1
82503: PUSH
82504: EMPTY
82505: LIST
82506: LIST
82507: PUSH
82508: LD_INT 2
82510: PUSH
82511: LD_INT 0
82513: PUSH
82514: EMPTY
82515: LIST
82516: LIST
82517: PUSH
82518: LD_INT 2
82520: PUSH
82521: LD_INT 1
82523: NEG
82524: PUSH
82525: EMPTY
82526: LIST
82527: LIST
82528: PUSH
82529: LD_INT 2
82531: PUSH
82532: LD_INT 2
82534: NEG
82535: PUSH
82536: EMPTY
82537: LIST
82538: LIST
82539: PUSH
82540: LD_INT 4
82542: PUSH
82543: LD_INT 2
82545: PUSH
82546: EMPTY
82547: LIST
82548: LIST
82549: PUSH
82550: LD_INT 4
82552: PUSH
82553: LD_INT 4
82555: PUSH
82556: EMPTY
82557: LIST
82558: LIST
82559: PUSH
82560: LD_INT 4
82562: PUSH
82563: LD_INT 3
82565: PUSH
82566: EMPTY
82567: LIST
82568: LIST
82569: PUSH
82570: LD_INT 5
82572: PUSH
82573: LD_INT 4
82575: PUSH
82576: EMPTY
82577: LIST
82578: LIST
82579: PUSH
82580: LD_INT 5
82582: PUSH
82583: LD_INT 5
82585: PUSH
82586: EMPTY
82587: LIST
82588: LIST
82589: PUSH
82590: LD_INT 4
82592: PUSH
82593: LD_INT 5
82595: PUSH
82596: EMPTY
82597: LIST
82598: LIST
82599: PUSH
82600: LD_INT 3
82602: PUSH
82603: LD_INT 4
82605: PUSH
82606: EMPTY
82607: LIST
82608: LIST
82609: PUSH
82610: LD_INT 3
82612: PUSH
82613: LD_INT 3
82615: PUSH
82616: EMPTY
82617: LIST
82618: LIST
82619: PUSH
82620: LD_INT 5
82622: PUSH
82623: LD_INT 3
82625: PUSH
82626: EMPTY
82627: LIST
82628: LIST
82629: PUSH
82630: LD_INT 3
82632: PUSH
82633: LD_INT 5
82635: PUSH
82636: EMPTY
82637: LIST
82638: LIST
82639: PUSH
82640: LD_INT 0
82642: PUSH
82643: LD_INT 3
82645: PUSH
82646: EMPTY
82647: LIST
82648: LIST
82649: PUSH
82650: LD_INT 0
82652: PUSH
82653: LD_INT 2
82655: PUSH
82656: EMPTY
82657: LIST
82658: LIST
82659: PUSH
82660: LD_INT 1
82662: PUSH
82663: LD_INT 3
82665: PUSH
82666: EMPTY
82667: LIST
82668: LIST
82669: PUSH
82670: LD_INT 1
82672: PUSH
82673: LD_INT 4
82675: PUSH
82676: EMPTY
82677: LIST
82678: LIST
82679: PUSH
82680: LD_INT 0
82682: PUSH
82683: LD_INT 4
82685: PUSH
82686: EMPTY
82687: LIST
82688: LIST
82689: PUSH
82690: LD_INT 1
82692: NEG
82693: PUSH
82694: LD_INT 3
82696: PUSH
82697: EMPTY
82698: LIST
82699: LIST
82700: PUSH
82701: LD_INT 1
82703: NEG
82704: PUSH
82705: LD_INT 2
82707: PUSH
82708: EMPTY
82709: LIST
82710: LIST
82711: PUSH
82712: LD_INT 2
82714: PUSH
82715: LD_INT 4
82717: PUSH
82718: EMPTY
82719: LIST
82720: LIST
82721: PUSH
82722: LD_INT 2
82724: NEG
82725: PUSH
82726: LD_INT 2
82728: PUSH
82729: EMPTY
82730: LIST
82731: LIST
82732: PUSH
82733: LD_INT 4
82735: NEG
82736: PUSH
82737: LD_INT 0
82739: PUSH
82740: EMPTY
82741: LIST
82742: LIST
82743: PUSH
82744: LD_INT 4
82746: NEG
82747: PUSH
82748: LD_INT 1
82750: NEG
82751: PUSH
82752: EMPTY
82753: LIST
82754: LIST
82755: PUSH
82756: LD_INT 3
82758: NEG
82759: PUSH
82760: LD_INT 0
82762: PUSH
82763: EMPTY
82764: LIST
82765: LIST
82766: PUSH
82767: LD_INT 3
82769: NEG
82770: PUSH
82771: LD_INT 1
82773: PUSH
82774: EMPTY
82775: LIST
82776: LIST
82777: PUSH
82778: LD_INT 4
82780: NEG
82781: PUSH
82782: LD_INT 1
82784: PUSH
82785: EMPTY
82786: LIST
82787: LIST
82788: PUSH
82789: LD_INT 5
82791: NEG
82792: PUSH
82793: LD_INT 0
82795: PUSH
82796: EMPTY
82797: LIST
82798: LIST
82799: PUSH
82800: LD_INT 5
82802: NEG
82803: PUSH
82804: LD_INT 1
82806: NEG
82807: PUSH
82808: EMPTY
82809: LIST
82810: LIST
82811: PUSH
82812: LD_INT 5
82814: NEG
82815: PUSH
82816: LD_INT 2
82818: NEG
82819: PUSH
82820: EMPTY
82821: LIST
82822: LIST
82823: PUSH
82824: LD_INT 3
82826: NEG
82827: PUSH
82828: LD_INT 2
82830: PUSH
82831: EMPTY
82832: LIST
82833: LIST
82834: PUSH
82835: EMPTY
82836: LIST
82837: LIST
82838: LIST
82839: LIST
82840: LIST
82841: LIST
82842: LIST
82843: LIST
82844: LIST
82845: LIST
82846: LIST
82847: LIST
82848: LIST
82849: LIST
82850: LIST
82851: LIST
82852: LIST
82853: LIST
82854: LIST
82855: LIST
82856: LIST
82857: LIST
82858: LIST
82859: LIST
82860: LIST
82861: LIST
82862: LIST
82863: LIST
82864: LIST
82865: LIST
82866: LIST
82867: LIST
82868: LIST
82869: LIST
82870: LIST
82871: LIST
82872: LIST
82873: LIST
82874: LIST
82875: LIST
82876: LIST
82877: LIST
82878: LIST
82879: LIST
82880: LIST
82881: ST_TO_ADDR
// end ; end ;
82882: GO 82885
82884: POP
// case btype of b_depot , b_warehouse :
82885: LD_VAR 0 1
82889: PUSH
82890: LD_INT 0
82892: DOUBLE
82893: EQUAL
82894: IFTRUE 82904
82896: LD_INT 1
82898: DOUBLE
82899: EQUAL
82900: IFTRUE 82904
82902: GO 83105
82904: POP
// case nation of nation_american :
82905: LD_VAR 0 5
82909: PUSH
82910: LD_INT 1
82912: DOUBLE
82913: EQUAL
82914: IFTRUE 82918
82916: GO 82974
82918: POP
// temp_list = [ DepotAm0 , DepotAm1 , DepotAm2 , DepotAm3 , DepotAm4 , DepotAm5 ] [ dir + 1 ] ; nation_arabian :
82919: LD_ADDR_VAR 0 9
82923: PUSH
82924: LD_VAR 0 11
82928: PUSH
82929: LD_VAR 0 12
82933: PUSH
82934: LD_VAR 0 13
82938: PUSH
82939: LD_VAR 0 14
82943: PUSH
82944: LD_VAR 0 15
82948: PUSH
82949: LD_VAR 0 16
82953: PUSH
82954: EMPTY
82955: LIST
82956: LIST
82957: LIST
82958: LIST
82959: LIST
82960: LIST
82961: PUSH
82962: LD_VAR 0 4
82966: PUSH
82967: LD_INT 1
82969: PLUS
82970: ARRAY
82971: ST_TO_ADDR
82972: GO 83103
82974: LD_INT 2
82976: DOUBLE
82977: EQUAL
82978: IFTRUE 82982
82980: GO 83038
82982: POP
// temp_list = [ DepotAr0 , DepotAr1 , DepotAr2 , DepotAr3 , DepotAr4 , DepotAr5 ] [ dir + 1 ] ; nation_russian :
82983: LD_ADDR_VAR 0 9
82987: PUSH
82988: LD_VAR 0 17
82992: PUSH
82993: LD_VAR 0 18
82997: PUSH
82998: LD_VAR 0 19
83002: PUSH
83003: LD_VAR 0 20
83007: PUSH
83008: LD_VAR 0 21
83012: PUSH
83013: LD_VAR 0 22
83017: PUSH
83018: EMPTY
83019: LIST
83020: LIST
83021: LIST
83022: LIST
83023: LIST
83024: LIST
83025: PUSH
83026: LD_VAR 0 4
83030: PUSH
83031: LD_INT 1
83033: PLUS
83034: ARRAY
83035: ST_TO_ADDR
83036: GO 83103
83038: LD_INT 3
83040: DOUBLE
83041: EQUAL
83042: IFTRUE 83046
83044: GO 83102
83046: POP
// temp_list = [ DepotRu0 , DepotRu1 , DepotRu2 , DepotRu3 , DepotRu4 , DepotRu5 ] [ dir + 1 ] ; end ; b_workshop , b_factory :
83047: LD_ADDR_VAR 0 9
83051: PUSH
83052: LD_VAR 0 23
83056: PUSH
83057: LD_VAR 0 24
83061: PUSH
83062: LD_VAR 0 25
83066: PUSH
83067: LD_VAR 0 26
83071: PUSH
83072: LD_VAR 0 27
83076: PUSH
83077: LD_VAR 0 28
83081: PUSH
83082: EMPTY
83083: LIST
83084: LIST
83085: LIST
83086: LIST
83087: LIST
83088: LIST
83089: PUSH
83090: LD_VAR 0 4
83094: PUSH
83095: LD_INT 1
83097: PLUS
83098: ARRAY
83099: ST_TO_ADDR
83100: GO 83103
83102: POP
83103: GO 83658
83105: LD_INT 2
83107: DOUBLE
83108: EQUAL
83109: IFTRUE 83119
83111: LD_INT 3
83113: DOUBLE
83114: EQUAL
83115: IFTRUE 83119
83117: GO 83175
83119: POP
// temp_list = [ Factory0 , Factory1 , Factory2 , Factory3 , Factory4 , Factory5 ] [ dir + 1 ] ; b_ext_track , b_ext_gun , b_ext_rocket , b_ext_noncombat , b_ext_radio , b_ext_radar , b_ext_siberium , b_ext_stitch , b_ext_computer , b_ext_laser :
83120: LD_ADDR_VAR 0 9
83124: PUSH
83125: LD_VAR 0 29
83129: PUSH
83130: LD_VAR 0 30
83134: PUSH
83135: LD_VAR 0 31
83139: PUSH
83140: LD_VAR 0 32
83144: PUSH
83145: LD_VAR 0 33
83149: PUSH
83150: LD_VAR 0 34
83154: PUSH
83155: EMPTY
83156: LIST
83157: LIST
83158: LIST
83159: LIST
83160: LIST
83161: LIST
83162: PUSH
83163: LD_VAR 0 4
83167: PUSH
83168: LD_INT 1
83170: PLUS
83171: ARRAY
83172: ST_TO_ADDR
83173: GO 83658
83175: LD_INT 16
83177: DOUBLE
83178: EQUAL
83179: IFTRUE 83237
83181: LD_INT 17
83183: DOUBLE
83184: EQUAL
83185: IFTRUE 83237
83187: LD_INT 18
83189: DOUBLE
83190: EQUAL
83191: IFTRUE 83237
83193: LD_INT 19
83195: DOUBLE
83196: EQUAL
83197: IFTRUE 83237
83199: LD_INT 22
83201: DOUBLE
83202: EQUAL
83203: IFTRUE 83237
83205: LD_INT 20
83207: DOUBLE
83208: EQUAL
83209: IFTRUE 83237
83211: LD_INT 21
83213: DOUBLE
83214: EQUAL
83215: IFTRUE 83237
83217: LD_INT 23
83219: DOUBLE
83220: EQUAL
83221: IFTRUE 83237
83223: LD_INT 24
83225: DOUBLE
83226: EQUAL
83227: IFTRUE 83237
83229: LD_INT 25
83231: DOUBLE
83232: EQUAL
83233: IFTRUE 83237
83235: GO 83293
83237: POP
// temp_list = [ Ext0 , Ext1 , Ext2 , Ext3 , Ext4 , Ext5 ] [ dir + 1 ] ; b_lab , b_lab_half , b_lab_full , b_lab_biological , b_lab_computer , b_lab_opto , b_lab_siberium , b_lab_spacetime , b_lab_weapon :
83238: LD_ADDR_VAR 0 9
83242: PUSH
83243: LD_VAR 0 35
83247: PUSH
83248: LD_VAR 0 36
83252: PUSH
83253: LD_VAR 0 37
83257: PUSH
83258: LD_VAR 0 38
83262: PUSH
83263: LD_VAR 0 39
83267: PUSH
83268: LD_VAR 0 40
83272: PUSH
83273: EMPTY
83274: LIST
83275: LIST
83276: LIST
83277: LIST
83278: LIST
83279: LIST
83280: PUSH
83281: LD_VAR 0 4
83285: PUSH
83286: LD_INT 1
83288: PLUS
83289: ARRAY
83290: ST_TO_ADDR
83291: GO 83658
83293: LD_INT 6
83295: DOUBLE
83296: EQUAL
83297: IFTRUE 83349
83299: LD_INT 7
83301: DOUBLE
83302: EQUAL
83303: IFTRUE 83349
83305: LD_INT 8
83307: DOUBLE
83308: EQUAL
83309: IFTRUE 83349
83311: LD_INT 13
83313: DOUBLE
83314: EQUAL
83315: IFTRUE 83349
83317: LD_INT 12
83319: DOUBLE
83320: EQUAL
83321: IFTRUE 83349
83323: LD_INT 15
83325: DOUBLE
83326: EQUAL
83327: IFTRUE 83349
83329: LD_INT 11
83331: DOUBLE
83332: EQUAL
83333: IFTRUE 83349
83335: LD_INT 14
83337: DOUBLE
83338: EQUAL
83339: IFTRUE 83349
83341: LD_INT 10
83343: DOUBLE
83344: EQUAL
83345: IFTRUE 83349
83347: GO 83405
83349: POP
// temp_list = [ Lab0 , Lab1 , Lab2 , Lab3 , Lab4 , Lab5 ] [ dir + 1 ] ; b_control_tower :
83350: LD_ADDR_VAR 0 9
83354: PUSH
83355: LD_VAR 0 41
83359: PUSH
83360: LD_VAR 0 42
83364: PUSH
83365: LD_VAR 0 43
83369: PUSH
83370: LD_VAR 0 44
83374: PUSH
83375: LD_VAR 0 45
83379: PUSH
83380: LD_VAR 0 46
83384: PUSH
83385: EMPTY
83386: LIST
83387: LIST
83388: LIST
83389: LIST
83390: LIST
83391: LIST
83392: PUSH
83393: LD_VAR 0 4
83397: PUSH
83398: LD_INT 1
83400: PLUS
83401: ARRAY
83402: ST_TO_ADDR
83403: GO 83658
83405: LD_INT 36
83407: DOUBLE
83408: EQUAL
83409: IFTRUE 83413
83411: GO 83469
83413: POP
// temp_list = [ ControlTower0 , ControlTower1 , ControlTower2 , ControlTower3 , ControlTower4 , ControlTower5 ] [ dir + 1 ] ; b_armoury , b_barracks , b_teleport , b_behemoth :
83414: LD_ADDR_VAR 0 9
83418: PUSH
83419: LD_VAR 0 47
83423: PUSH
83424: LD_VAR 0 48
83428: PUSH
83429: LD_VAR 0 49
83433: PUSH
83434: LD_VAR 0 50
83438: PUSH
83439: LD_VAR 0 51
83443: PUSH
83444: LD_VAR 0 52
83448: PUSH
83449: EMPTY
83450: LIST
83451: LIST
83452: LIST
83453: LIST
83454: LIST
83455: LIST
83456: PUSH
83457: LD_VAR 0 4
83461: PUSH
83462: LD_INT 1
83464: PLUS
83465: ARRAY
83466: ST_TO_ADDR
83467: GO 83658
83469: LD_INT 4
83471: DOUBLE
83472: EQUAL
83473: IFTRUE 83495
83475: LD_INT 5
83477: DOUBLE
83478: EQUAL
83479: IFTRUE 83495
83481: LD_INT 34
83483: DOUBLE
83484: EQUAL
83485: IFTRUE 83495
83487: LD_INT 37
83489: DOUBLE
83490: EQUAL
83491: IFTRUE 83495
83493: GO 83551
83495: POP
// temp_list = [ Barracks0 , Barracks1 , Barracks2 , Barracks3 , Barracks4 , Barracks5 ] [ dir + 1 ] ; b_breastwork , b_bunker , b_turret , b_solar_power , b_oil_power , b_siberite_power , b_oil_mine , b_siberite_mine :
83496: LD_ADDR_VAR 0 9
83500: PUSH
83501: LD_VAR 0 53
83505: PUSH
83506: LD_VAR 0 54
83510: PUSH
83511: LD_VAR 0 55
83515: PUSH
83516: LD_VAR 0 56
83520: PUSH
83521: LD_VAR 0 57
83525: PUSH
83526: LD_VAR 0 58
83530: PUSH
83531: EMPTY
83532: LIST
83533: LIST
83534: LIST
83535: LIST
83536: LIST
83537: LIST
83538: PUSH
83539: LD_VAR 0 4
83543: PUSH
83544: LD_INT 1
83546: PLUS
83547: ARRAY
83548: ST_TO_ADDR
83549: GO 83658
83551: LD_INT 31
83553: DOUBLE
83554: EQUAL
83555: IFTRUE 83601
83557: LD_INT 32
83559: DOUBLE
83560: EQUAL
83561: IFTRUE 83601
83563: LD_INT 33
83565: DOUBLE
83566: EQUAL
83567: IFTRUE 83601
83569: LD_INT 27
83571: DOUBLE
83572: EQUAL
83573: IFTRUE 83601
83575: LD_INT 26
83577: DOUBLE
83578: EQUAL
83579: IFTRUE 83601
83581: LD_INT 28
83583: DOUBLE
83584: EQUAL
83585: IFTRUE 83601
83587: LD_INT 29
83589: DOUBLE
83590: EQUAL
83591: IFTRUE 83601
83593: LD_INT 30
83595: DOUBLE
83596: EQUAL
83597: IFTRUE 83601
83599: GO 83657
83601: POP
// temp_list = [ Bunker0 , Bunker1 , Bunker2 , Bunker3 , Bunker4 , Bunker5 ] [ dir + 1 ] ; end ;
83602: LD_ADDR_VAR 0 9
83606: PUSH
83607: LD_VAR 0 59
83611: PUSH
83612: LD_VAR 0 60
83616: PUSH
83617: LD_VAR 0 61
83621: PUSH
83622: LD_VAR 0 62
83626: PUSH
83627: LD_VAR 0 63
83631: PUSH
83632: LD_VAR 0 64
83636: PUSH
83637: EMPTY
83638: LIST
83639: LIST
83640: LIST
83641: LIST
83642: LIST
83643: LIST
83644: PUSH
83645: LD_VAR 0 4
83649: PUSH
83650: LD_INT 1
83652: PLUS
83653: ARRAY
83654: ST_TO_ADDR
83655: GO 83658
83657: POP
// temp_list2 = [ ] ;
83658: LD_ADDR_VAR 0 10
83662: PUSH
83663: EMPTY
83664: ST_TO_ADDR
// for i in temp_list do
83665: LD_ADDR_VAR 0 8
83669: PUSH
83670: LD_VAR 0 9
83674: PUSH
83675: FOR_IN
83676: IFFALSE 83728
// temp_list2 = temp_list2 ^ [ [ i [ 1 ] + x , i [ 2 ] + y ] ] ;
83678: LD_ADDR_VAR 0 10
83682: PUSH
83683: LD_VAR 0 10
83687: PUSH
83688: LD_VAR 0 8
83692: PUSH
83693: LD_INT 1
83695: ARRAY
83696: PUSH
83697: LD_VAR 0 2
83701: PLUS
83702: PUSH
83703: LD_VAR 0 8
83707: PUSH
83708: LD_INT 2
83710: ARRAY
83711: PUSH
83712: LD_VAR 0 3
83716: PLUS
83717: PUSH
83718: EMPTY
83719: LIST
83720: LIST
83721: PUSH
83722: EMPTY
83723: LIST
83724: ADD
83725: ST_TO_ADDR
83726: GO 83675
83728: POP
83729: POP
// result = temp_list2 ;
83730: LD_ADDR_VAR 0 7
83734: PUSH
83735: LD_VAR 0 10
83739: ST_TO_ADDR
// end ;
83740: LD_VAR 0 7
83744: RET
// export function EnemyInRange ( unit , dist ) ; begin
83745: LD_INT 0
83747: PPUSH
// result := DangerAtRangeXY ( GetSide ( unit ) , GetX ( unit ) , GetY ( unit ) , dist ) [ 4 ] ;
83748: LD_ADDR_VAR 0 3
83752: PUSH
83753: LD_VAR 0 1
83757: PPUSH
83758: CALL_OW 255
83762: PPUSH
83763: LD_VAR 0 1
83767: PPUSH
83768: CALL_OW 250
83772: PPUSH
83773: LD_VAR 0 1
83777: PPUSH
83778: CALL_OW 251
83782: PPUSH
83783: LD_VAR 0 2
83787: PPUSH
83788: CALL 57849 0 4
83792: PUSH
83793: LD_INT 4
83795: ARRAY
83796: ST_TO_ADDR
// end ;
83797: LD_VAR 0 3
83801: RET
// export function PlayerSeeMe ( unit ) ; begin
83802: LD_INT 0
83804: PPUSH
// result := See ( your_side , unit ) ;
83805: LD_ADDR_VAR 0 2
83809: PUSH
83810: LD_OWVAR 2
83814: PPUSH
83815: LD_VAR 0 1
83819: PPUSH
83820: CALL_OW 292
83824: ST_TO_ADDR
// end ;
83825: LD_VAR 0 2
83829: RET
// export function ReverseDir ( unit ) ; begin
83830: LD_INT 0
83832: PPUSH
// if not unit then
83833: LD_VAR 0 1
83837: NOT
83838: IFFALSE 83842
// exit ;
83840: GO 83888
// result := [ 3 , 4 , 5 , 0 , 1 , 2 ] [ GetDir ( unit ) + 1 ] ;
83842: LD_ADDR_VAR 0 2
83846: PUSH
83847: LD_INT 3
83849: PUSH
83850: LD_INT 4
83852: PUSH
83853: LD_INT 5
83855: PUSH
83856: LD_INT 0
83858: PUSH
83859: LD_INT 1
83861: PUSH
83862: LD_INT 2
83864: PUSH
83865: EMPTY
83866: LIST
83867: LIST
83868: LIST
83869: LIST
83870: LIST
83871: LIST
83872: PUSH
83873: LD_VAR 0 1
83877: PPUSH
83878: CALL_OW 254
83882: PUSH
83883: LD_INT 1
83885: PLUS
83886: ARRAY
83887: ST_TO_ADDR
// end ;
83888: LD_VAR 0 2
83892: RET
// export function GetClosestHex ( unit , hexes ) ; var i , dist , tmp , hex ; begin
83893: LD_INT 0
83895: PPUSH
83896: PPUSH
83897: PPUSH
83898: PPUSH
83899: PPUSH
// if not hexes then
83900: LD_VAR 0 2
83904: NOT
83905: IFFALSE 83909
// exit ;
83907: GO 84057
// dist := 9999 ;
83909: LD_ADDR_VAR 0 5
83913: PUSH
83914: LD_INT 9999
83916: ST_TO_ADDR
// for i = 1 to hexes do
83917: LD_ADDR_VAR 0 4
83921: PUSH
83922: DOUBLE
83923: LD_INT 1
83925: DEC
83926: ST_TO_ADDR
83927: LD_VAR 0 2
83931: PUSH
83932: FOR_TO
83933: IFFALSE 84045
// begin if GetDistUnitXY ( unit , hexes [ i ] [ 1 ] , hexes [ i ] [ 2 ] ) < dist then
83935: LD_VAR 0 1
83939: PPUSH
83940: LD_VAR 0 2
83944: PUSH
83945: LD_VAR 0 4
83949: ARRAY
83950: PUSH
83951: LD_INT 1
83953: ARRAY
83954: PPUSH
83955: LD_VAR 0 2
83959: PUSH
83960: LD_VAR 0 4
83964: ARRAY
83965: PUSH
83966: LD_INT 2
83968: ARRAY
83969: PPUSH
83970: CALL_OW 297
83974: PUSH
83975: LD_VAR 0 5
83979: LESS
83980: IFFALSE 84043
// begin hex := hexes [ i ] ;
83982: LD_ADDR_VAR 0 7
83986: PUSH
83987: LD_VAR 0 2
83991: PUSH
83992: LD_VAR 0 4
83996: ARRAY
83997: ST_TO_ADDR
// dist := GetDistUnitXY ( unit , hexes [ i ] [ 1 ] , hexes [ i ] [ 2 ] ) ;
83998: LD_ADDR_VAR 0 5
84002: PUSH
84003: LD_VAR 0 1
84007: PPUSH
84008: LD_VAR 0 2
84012: PUSH
84013: LD_VAR 0 4
84017: ARRAY
84018: PUSH
84019: LD_INT 1
84021: ARRAY
84022: PPUSH
84023: LD_VAR 0 2
84027: PUSH
84028: LD_VAR 0 4
84032: ARRAY
84033: PUSH
84034: LD_INT 2
84036: ARRAY
84037: PPUSH
84038: CALL_OW 297
84042: ST_TO_ADDR
// end ; end ;
84043: GO 83932
84045: POP
84046: POP
// result := hex ;
84047: LD_ADDR_VAR 0 3
84051: PUSH
84052: LD_VAR 0 7
84056: ST_TO_ADDR
// end ;
84057: LD_VAR 0 3
84061: RET
// export function ComAutodestruct ( unit ) ; var i ; begin
84062: LD_INT 0
84064: PPUSH
84065: PPUSH
// if not unit or not unit in FilterAllUnits ( [ [ f_type , unit_vehicle ] , [ f_nation , 2 ] ] ) then
84066: LD_VAR 0 1
84070: NOT
84071: PUSH
84072: LD_VAR 0 1
84076: PUSH
84077: LD_INT 21
84079: PUSH
84080: LD_INT 2
84082: PUSH
84083: EMPTY
84084: LIST
84085: LIST
84086: PUSH
84087: LD_INT 23
84089: PUSH
84090: LD_INT 2
84092: PUSH
84093: EMPTY
84094: LIST
84095: LIST
84096: PUSH
84097: EMPTY
84098: LIST
84099: LIST
84100: PPUSH
84101: CALL_OW 69
84105: IN
84106: NOT
84107: OR
84108: IFFALSE 84112
// exit ;
84110: GO 84159
// for i = 1 to 3 do
84112: LD_ADDR_VAR 0 3
84116: PUSH
84117: DOUBLE
84118: LD_INT 1
84120: DEC
84121: ST_TO_ADDR
84122: LD_INT 3
84124: PUSH
84125: FOR_TO
84126: IFFALSE 84157
// MineExplosion ( GetX ( unit ) , GetY ( unit ) , 1 ) ;
84128: LD_VAR 0 1
84132: PPUSH
84133: CALL_OW 250
84137: PPUSH
84138: LD_VAR 0 1
84142: PPUSH
84143: CALL_OW 251
84147: PPUSH
84148: LD_INT 1
84150: PPUSH
84151: CALL_OW 453
84155: GO 84125
84157: POP
84158: POP
// end ;
84159: LD_VAR 0 2
84163: RET
// export function AttackHovercraft ( unit , enemy_unit ) ; var i , j , tmp , x , y ; begin
84164: LD_INT 0
84166: PPUSH
84167: PPUSH
84168: PPUSH
84169: PPUSH
84170: PPUSH
84171: PPUSH
// if not unit or not enemy_unit or HasTask ( unit ) then
84172: LD_VAR 0 1
84176: NOT
84177: PUSH
84178: LD_VAR 0 2
84182: NOT
84183: OR
84184: PUSH
84185: LD_VAR 0 1
84189: PPUSH
84190: CALL_OW 314
84194: OR
84195: IFFALSE 84199
// exit ;
84197: GO 84640
// x := GetX ( enemy_unit ) ;
84199: LD_ADDR_VAR 0 7
84203: PUSH
84204: LD_VAR 0 2
84208: PPUSH
84209: CALL_OW 250
84213: ST_TO_ADDR
// y := GetY ( enemy_unit ) ;
84214: LD_ADDR_VAR 0 8
84218: PUSH
84219: LD_VAR 0 2
84223: PPUSH
84224: CALL_OW 251
84228: ST_TO_ADDR
// if not x or not y then
84229: LD_VAR 0 7
84233: NOT
84234: PUSH
84235: LD_VAR 0 8
84239: NOT
84240: OR
84241: IFFALSE 84245
// exit ;
84243: GO 84640
// tmp := [ [ ShiftX ( x , 0 , 4 ) , ShiftY ( y , 0 , 4 ) ] , [ ShiftX ( x , 1 , 4 ) , ShiftY ( y , 1 , 4 ) ] , [ ShiftX ( x , 2 , 4 ) , ShiftY ( y , 2 , 4 ) ] , [ ShiftX ( x , 3 , 4 ) , ShiftY ( y , 3 , 4 ) ] , [ ShiftX ( x , 4 , 4 ) , ShiftY ( y , 4 , 4 ) ] , [ ShiftX ( x , 5 , 4 ) , ShiftY ( y , 5 , 4 ) ] ] ;
84245: LD_ADDR_VAR 0 6
84249: PUSH
84250: LD_VAR 0 7
84254: PPUSH
84255: LD_INT 0
84257: PPUSH
84258: LD_INT 4
84260: PPUSH
84261: CALL_OW 272
84265: PUSH
84266: LD_VAR 0 8
84270: PPUSH
84271: LD_INT 0
84273: PPUSH
84274: LD_INT 4
84276: PPUSH
84277: CALL_OW 273
84281: PUSH
84282: EMPTY
84283: LIST
84284: LIST
84285: PUSH
84286: LD_VAR 0 7
84290: PPUSH
84291: LD_INT 1
84293: PPUSH
84294: LD_INT 4
84296: PPUSH
84297: CALL_OW 272
84301: PUSH
84302: LD_VAR 0 8
84306: PPUSH
84307: LD_INT 1
84309: PPUSH
84310: LD_INT 4
84312: PPUSH
84313: CALL_OW 273
84317: PUSH
84318: EMPTY
84319: LIST
84320: LIST
84321: PUSH
84322: LD_VAR 0 7
84326: PPUSH
84327: LD_INT 2
84329: PPUSH
84330: LD_INT 4
84332: PPUSH
84333: CALL_OW 272
84337: PUSH
84338: LD_VAR 0 8
84342: PPUSH
84343: LD_INT 2
84345: PPUSH
84346: LD_INT 4
84348: PPUSH
84349: CALL_OW 273
84353: PUSH
84354: EMPTY
84355: LIST
84356: LIST
84357: PUSH
84358: LD_VAR 0 7
84362: PPUSH
84363: LD_INT 3
84365: PPUSH
84366: LD_INT 4
84368: PPUSH
84369: CALL_OW 272
84373: PUSH
84374: LD_VAR 0 8
84378: PPUSH
84379: LD_INT 3
84381: PPUSH
84382: LD_INT 4
84384: PPUSH
84385: CALL_OW 273
84389: PUSH
84390: EMPTY
84391: LIST
84392: LIST
84393: PUSH
84394: LD_VAR 0 7
84398: PPUSH
84399: LD_INT 4
84401: PPUSH
84402: LD_INT 4
84404: PPUSH
84405: CALL_OW 272
84409: PUSH
84410: LD_VAR 0 8
84414: PPUSH
84415: LD_INT 4
84417: PPUSH
84418: LD_INT 4
84420: PPUSH
84421: CALL_OW 273
84425: PUSH
84426: EMPTY
84427: LIST
84428: LIST
84429: PUSH
84430: LD_VAR 0 7
84434: PPUSH
84435: LD_INT 5
84437: PPUSH
84438: LD_INT 4
84440: PPUSH
84441: CALL_OW 272
84445: PUSH
84446: LD_VAR 0 8
84450: PPUSH
84451: LD_INT 5
84453: PPUSH
84454: LD_INT 4
84456: PPUSH
84457: CALL_OW 273
84461: PUSH
84462: EMPTY
84463: LIST
84464: LIST
84465: PUSH
84466: EMPTY
84467: LIST
84468: LIST
84469: LIST
84470: LIST
84471: LIST
84472: LIST
84473: ST_TO_ADDR
// for i = tmp downto 1 do
84474: LD_ADDR_VAR 0 4
84478: PUSH
84479: DOUBLE
84480: LD_VAR 0 6
84484: INC
84485: ST_TO_ADDR
84486: LD_INT 1
84488: PUSH
84489: FOR_DOWNTO
84490: IFFALSE 84591
// if not ValidHex ( tmp [ i ] [ 1 ] , tmp [ i ] [ 2 ] ) or HexInfo ( tmp [ i ] [ 1 ] , tmp [ i ] [ 2 ] ) <> 0 then
84492: LD_VAR 0 6
84496: PUSH
84497: LD_VAR 0 4
84501: ARRAY
84502: PUSH
84503: LD_INT 1
84505: ARRAY
84506: PPUSH
84507: LD_VAR 0 6
84511: PUSH
84512: LD_VAR 0 4
84516: ARRAY
84517: PUSH
84518: LD_INT 2
84520: ARRAY
84521: PPUSH
84522: CALL_OW 488
84526: NOT
84527: PUSH
84528: LD_VAR 0 6
84532: PUSH
84533: LD_VAR 0 4
84537: ARRAY
84538: PUSH
84539: LD_INT 1
84541: ARRAY
84542: PPUSH
84543: LD_VAR 0 6
84547: PUSH
84548: LD_VAR 0 4
84552: ARRAY
84553: PUSH
84554: LD_INT 2
84556: ARRAY
84557: PPUSH
84558: CALL_OW 428
84562: PUSH
84563: LD_INT 0
84565: NONEQUAL
84566: OR
84567: IFFALSE 84589
// tmp := Delete ( tmp , i ) ;
84569: LD_ADDR_VAR 0 6
84573: PUSH
84574: LD_VAR 0 6
84578: PPUSH
84579: LD_VAR 0 4
84583: PPUSH
84584: CALL_OW 3
84588: ST_TO_ADDR
84589: GO 84489
84591: POP
84592: POP
// j := GetClosestHex ( unit , tmp ) ;
84593: LD_ADDR_VAR 0 5
84597: PUSH
84598: LD_VAR 0 1
84602: PPUSH
84603: LD_VAR 0 6
84607: PPUSH
84608: CALL 83893 0 2
84612: ST_TO_ADDR
// ComMoveXY ( unit , j [ 1 ] , j [ 2 ] ) ;
84613: LD_VAR 0 1
84617: PPUSH
84618: LD_VAR 0 5
84622: PUSH
84623: LD_INT 1
84625: ARRAY
84626: PPUSH
84627: LD_VAR 0 5
84631: PUSH
84632: LD_INT 2
84634: ARRAY
84635: PPUSH
84636: CALL_OW 111
// end ;
84640: LD_VAR 0 3
84644: RET
// export function PrepareNature ( birds , tigers , apemans , enchidnas , horses , mastodonts , fishes , nat_area , wat_area ) ; var i , animal ; begin
84645: LD_INT 0
84647: PPUSH
84648: PPUSH
84649: PPUSH
// uc_side = 0 ;
84650: LD_ADDR_OWVAR 20
84654: PUSH
84655: LD_INT 0
84657: ST_TO_ADDR
// uc_nation = 0 ;
84658: LD_ADDR_OWVAR 21
84662: PUSH
84663: LD_INT 0
84665: ST_TO_ADDR
// InitHc ;
84666: CALL_OW 19
// InitVc ;
84670: CALL_OW 20
// if mastodonts then
84674: LD_VAR 0 6
84678: IFFALSE 84745
// for i = 1 to mastodonts do
84680: LD_ADDR_VAR 0 11
84684: PUSH
84685: DOUBLE
84686: LD_INT 1
84688: DEC
84689: ST_TO_ADDR
84690: LD_VAR 0 6
84694: PUSH
84695: FOR_TO
84696: IFFALSE 84743
// begin vc_chassis := 31 ;
84698: LD_ADDR_OWVAR 37
84702: PUSH
84703: LD_INT 31
84705: ST_TO_ADDR
// vc_control := control_rider ;
84706: LD_ADDR_OWVAR 38
84710: PUSH
84711: LD_INT 4
84713: ST_TO_ADDR
// animal := CreateVehicle ;
84714: LD_ADDR_VAR 0 12
84718: PUSH
84719: CALL_OW 45
84723: ST_TO_ADDR
// PlaceUnitInArea ( animal , nat_area , false ) ;
84724: LD_VAR 0 12
84728: PPUSH
84729: LD_VAR 0 8
84733: PPUSH
84734: LD_INT 0
84736: PPUSH
84737: CALL 91490 0 3
// end ;
84741: GO 84695
84743: POP
84744: POP
// if horses then
84745: LD_VAR 0 5
84749: IFFALSE 84816
// for i = 1 to horses do
84751: LD_ADDR_VAR 0 11
84755: PUSH
84756: DOUBLE
84757: LD_INT 1
84759: DEC
84760: ST_TO_ADDR
84761: LD_VAR 0 5
84765: PUSH
84766: FOR_TO
84767: IFFALSE 84814
// begin hc_class := 21 ;
84769: LD_ADDR_OWVAR 28
84773: PUSH
84774: LD_INT 21
84776: ST_TO_ADDR
// hc_gallery :=  ;
84777: LD_ADDR_OWVAR 33
84781: PUSH
84782: LD_STRING 
84784: ST_TO_ADDR
// animal := CreateHuman ;
84785: LD_ADDR_VAR 0 12
84789: PUSH
84790: CALL_OW 44
84794: ST_TO_ADDR
// PlaceUnitInArea ( animal , nat_area , false ) ;
84795: LD_VAR 0 12
84799: PPUSH
84800: LD_VAR 0 8
84804: PPUSH
84805: LD_INT 0
84807: PPUSH
84808: CALL 91490 0 3
// end ;
84812: GO 84766
84814: POP
84815: POP
// if birds then
84816: LD_VAR 0 1
84820: IFFALSE 84887
// for i = 1 to birds do
84822: LD_ADDR_VAR 0 11
84826: PUSH
84827: DOUBLE
84828: LD_INT 1
84830: DEC
84831: ST_TO_ADDR
84832: LD_VAR 0 1
84836: PUSH
84837: FOR_TO
84838: IFFALSE 84885
// begin hc_class = 18 ;
84840: LD_ADDR_OWVAR 28
84844: PUSH
84845: LD_INT 18
84847: ST_TO_ADDR
// hc_gallery =  ;
84848: LD_ADDR_OWVAR 33
84852: PUSH
84853: LD_STRING 
84855: ST_TO_ADDR
// animal := CreateHuman ;
84856: LD_ADDR_VAR 0 12
84860: PUSH
84861: CALL_OW 44
84865: ST_TO_ADDR
// PlaceUnitInArea ( animal , nat_area , false ) ;
84866: LD_VAR 0 12
84870: PPUSH
84871: LD_VAR 0 8
84875: PPUSH
84876: LD_INT 0
84878: PPUSH
84879: CALL 91490 0 3
// end ;
84883: GO 84837
84885: POP
84886: POP
// if tigers then
84887: LD_VAR 0 2
84891: IFFALSE 84975
// for i = 1 to tigers do
84893: LD_ADDR_VAR 0 11
84897: PUSH
84898: DOUBLE
84899: LD_INT 1
84901: DEC
84902: ST_TO_ADDR
84903: LD_VAR 0 2
84907: PUSH
84908: FOR_TO
84909: IFFALSE 84973
// begin hc_class = class_tiger ;
84911: LD_ADDR_OWVAR 28
84915: PUSH
84916: LD_INT 14
84918: ST_TO_ADDR
// hc_gallery =  ;
84919: LD_ADDR_OWVAR 33
84923: PUSH
84924: LD_STRING 
84926: ST_TO_ADDR
// hc_agressivity = Rand ( - 7 , 7 ) ;
84927: LD_ADDR_OWVAR 35
84931: PUSH
84932: LD_INT 7
84934: NEG
84935: PPUSH
84936: LD_INT 7
84938: PPUSH
84939: CALL_OW 12
84943: ST_TO_ADDR
// animal := CreateHuman ;
84944: LD_ADDR_VAR 0 12
84948: PUSH
84949: CALL_OW 44
84953: ST_TO_ADDR
// PlaceUnitInArea ( animal , nat_area , false ) ;
84954: LD_VAR 0 12
84958: PPUSH
84959: LD_VAR 0 8
84963: PPUSH
84964: LD_INT 0
84966: PPUSH
84967: CALL 91490 0 3
// end ;
84971: GO 84908
84973: POP
84974: POP
// if apemans then
84975: LD_VAR 0 3
84979: IFFALSE 85102
// for i = 1 to apemans do
84981: LD_ADDR_VAR 0 11
84985: PUSH
84986: DOUBLE
84987: LD_INT 1
84989: DEC
84990: ST_TO_ADDR
84991: LD_VAR 0 3
84995: PUSH
84996: FOR_TO
84997: IFFALSE 85100
// begin hc_class = class_apeman ;
84999: LD_ADDR_OWVAR 28
85003: PUSH
85004: LD_INT 12
85006: ST_TO_ADDR
// hc_gallery =  ;
85007: LD_ADDR_OWVAR 33
85011: PUSH
85012: LD_STRING 
85014: ST_TO_ADDR
// hc_agressivity = rand ( - 5 , 5 ) ;
85015: LD_ADDR_OWVAR 35
85019: PUSH
85020: LD_INT 5
85022: NEG
85023: PPUSH
85024: LD_INT 5
85026: PPUSH
85027: CALL_OW 12
85031: ST_TO_ADDR
// hc_skills := [ rand ( 1 , 3 ) , rand ( 1 , 3 ) , 0 , 0 ] ;
85032: LD_ADDR_OWVAR 31
85036: PUSH
85037: LD_INT 1
85039: PPUSH
85040: LD_INT 3
85042: PPUSH
85043: CALL_OW 12
85047: PUSH
85048: LD_INT 1
85050: PPUSH
85051: LD_INT 3
85053: PPUSH
85054: CALL_OW 12
85058: PUSH
85059: LD_INT 0
85061: PUSH
85062: LD_INT 0
85064: PUSH
85065: EMPTY
85066: LIST
85067: LIST
85068: LIST
85069: LIST
85070: ST_TO_ADDR
// animal := CreateHuman ;
85071: LD_ADDR_VAR 0 12
85075: PUSH
85076: CALL_OW 44
85080: ST_TO_ADDR
// PlaceUnitInArea ( animal , nat_area , false ) ;
85081: LD_VAR 0 12
85085: PPUSH
85086: LD_VAR 0 8
85090: PPUSH
85091: LD_INT 0
85093: PPUSH
85094: CALL 91490 0 3
// end ;
85098: GO 84996
85100: POP
85101: POP
// if enchidnas then
85102: LD_VAR 0 4
85106: IFFALSE 85173
// for i = 1 to enchidnas do
85108: LD_ADDR_VAR 0 11
85112: PUSH
85113: DOUBLE
85114: LD_INT 1
85116: DEC
85117: ST_TO_ADDR
85118: LD_VAR 0 4
85122: PUSH
85123: FOR_TO
85124: IFFALSE 85171
// begin hc_class = 13 ;
85126: LD_ADDR_OWVAR 28
85130: PUSH
85131: LD_INT 13
85133: ST_TO_ADDR
// hc_gallery =  ;
85134: LD_ADDR_OWVAR 33
85138: PUSH
85139: LD_STRING 
85141: ST_TO_ADDR
// animal := CreateHuman ;
85142: LD_ADDR_VAR 0 12
85146: PUSH
85147: CALL_OW 44
85151: ST_TO_ADDR
// PlaceUnitInArea ( animal , nat_area , false ) ;
85152: LD_VAR 0 12
85156: PPUSH
85157: LD_VAR 0 8
85161: PPUSH
85162: LD_INT 0
85164: PPUSH
85165: CALL 91490 0 3
// end ;
85169: GO 85123
85171: POP
85172: POP
// if fishes then
85173: LD_VAR 0 7
85177: IFFALSE 85244
// for i = 1 to fishes do
85179: LD_ADDR_VAR 0 11
85183: PUSH
85184: DOUBLE
85185: LD_INT 1
85187: DEC
85188: ST_TO_ADDR
85189: LD_VAR 0 7
85193: PUSH
85194: FOR_TO
85195: IFFALSE 85242
// begin hc_class = 20 ;
85197: LD_ADDR_OWVAR 28
85201: PUSH
85202: LD_INT 20
85204: ST_TO_ADDR
// hc_gallery =  ;
85205: LD_ADDR_OWVAR 33
85209: PUSH
85210: LD_STRING 
85212: ST_TO_ADDR
// animal := CreateHuman ;
85213: LD_ADDR_VAR 0 12
85217: PUSH
85218: CALL_OW 44
85222: ST_TO_ADDR
// PlaceUnitInArea ( animal , wat_area , false ) ;
85223: LD_VAR 0 12
85227: PPUSH
85228: LD_VAR 0 9
85232: PPUSH
85233: LD_INT 0
85235: PPUSH
85236: CALL 91490 0 3
// end ;
85240: GO 85194
85242: POP
85243: POP
// end ;
85244: LD_VAR 0 10
85248: RET
// export function WantHeal ( sci , unit ) ; begin
85249: LD_INT 0
85251: PPUSH
// if GetTaskList ( sci ) > 0 then
85252: LD_VAR 0 1
85256: PPUSH
85257: CALL_OW 437
85261: PUSH
85262: LD_INT 0
85264: GREATER
85265: IFFALSE 85335
// begin if GetTaskList ( sci ) [ 1 ] [ 1 ] = l and GetTaskList ( sci ) [ 1 ] [ 4 ] = unit then
85267: LD_VAR 0 1
85271: PPUSH
85272: CALL_OW 437
85276: PUSH
85277: LD_INT 1
85279: ARRAY
85280: PUSH
85281: LD_INT 1
85283: ARRAY
85284: PUSH
85285: LD_STRING l
85287: EQUAL
85288: PUSH
85289: LD_VAR 0 1
85293: PPUSH
85294: CALL_OW 437
85298: PUSH
85299: LD_INT 1
85301: ARRAY
85302: PUSH
85303: LD_INT 4
85305: ARRAY
85306: PUSH
85307: LD_VAR 0 2
85311: EQUAL
85312: AND
85313: IFFALSE 85325
// result := true else
85315: LD_ADDR_VAR 0 3
85319: PUSH
85320: LD_INT 1
85322: ST_TO_ADDR
85323: GO 85333
// result := false ;
85325: LD_ADDR_VAR 0 3
85329: PUSH
85330: LD_INT 0
85332: ST_TO_ADDR
// end else
85333: GO 85343
// result := false ;
85335: LD_ADDR_VAR 0 3
85339: PUSH
85340: LD_INT 0
85342: ST_TO_ADDR
// end ;
85343: LD_VAR 0 3
85347: RET
// export function HealTarget ( sci ) ; begin
85348: LD_INT 0
85350: PPUSH
// if not sci then
85351: LD_VAR 0 1
85355: NOT
85356: IFFALSE 85360
// exit ;
85358: GO 85425
// result := 0 ;
85360: LD_ADDR_VAR 0 2
85364: PUSH
85365: LD_INT 0
85367: ST_TO_ADDR
// if GetTaskList ( sci ) then
85368: LD_VAR 0 1
85372: PPUSH
85373: CALL_OW 437
85377: IFFALSE 85425
// if GetTaskList ( sci ) [ 1 ] [ 1 ] = l then
85379: LD_VAR 0 1
85383: PPUSH
85384: CALL_OW 437
85388: PUSH
85389: LD_INT 1
85391: ARRAY
85392: PUSH
85393: LD_INT 1
85395: ARRAY
85396: PUSH
85397: LD_STRING l
85399: EQUAL
85400: IFFALSE 85425
// result := GetTaskList ( sci ) [ 1 ] [ 4 ] ;
85402: LD_ADDR_VAR 0 2
85406: PUSH
85407: LD_VAR 0 1
85411: PPUSH
85412: CALL_OW 437
85416: PUSH
85417: LD_INT 1
85419: ARRAY
85420: PUSH
85421: LD_INT 4
85423: ARRAY
85424: ST_TO_ADDR
// end ;
85425: LD_VAR 0 2
85429: RET
// export function Attack ( list ) ; var base , group , path , flags , i , j , k , x , y , d , z , tmp , tmp2 , units_path , f_ignore_area , f_capture , f_ignore_civ , f_murder , f_mines , f_repair , f_heal , f_spacetime , f_attack_depot , f_crawl , mined , bombed , attacking , to_heal , healers , to_repair , repairs , empty_vehs , side ; begin
85430: LD_INT 0
85432: PPUSH
85433: PPUSH
85434: PPUSH
85435: PPUSH
85436: PPUSH
85437: PPUSH
85438: PPUSH
85439: PPUSH
85440: PPUSH
85441: PPUSH
85442: PPUSH
85443: PPUSH
85444: PPUSH
85445: PPUSH
85446: PPUSH
85447: PPUSH
85448: PPUSH
85449: PPUSH
85450: PPUSH
85451: PPUSH
85452: PPUSH
85453: PPUSH
85454: PPUSH
85455: PPUSH
85456: PPUSH
85457: PPUSH
85458: PPUSH
85459: PPUSH
85460: PPUSH
85461: PPUSH
85462: PPUSH
85463: PPUSH
85464: PPUSH
85465: PPUSH
// if not list then
85466: LD_VAR 0 1
85470: NOT
85471: IFFALSE 85475
// exit ;
85473: GO 90101
// base := list [ 1 ] ;
85475: LD_ADDR_VAR 0 3
85479: PUSH
85480: LD_VAR 0 1
85484: PUSH
85485: LD_INT 1
85487: ARRAY
85488: ST_TO_ADDR
// group := list [ 2 ] ;
85489: LD_ADDR_VAR 0 4
85493: PUSH
85494: LD_VAR 0 1
85498: PUSH
85499: LD_INT 2
85501: ARRAY
85502: ST_TO_ADDR
// path := list [ 3 ] ;
85503: LD_ADDR_VAR 0 5
85507: PUSH
85508: LD_VAR 0 1
85512: PUSH
85513: LD_INT 3
85515: ARRAY
85516: ST_TO_ADDR
// flags := list [ 4 ] ;
85517: LD_ADDR_VAR 0 6
85521: PUSH
85522: LD_VAR 0 1
85526: PUSH
85527: LD_INT 4
85529: ARRAY
85530: ST_TO_ADDR
// mined := [ ] ;
85531: LD_ADDR_VAR 0 27
85535: PUSH
85536: EMPTY
85537: ST_TO_ADDR
// bombed := [ ] ;
85538: LD_ADDR_VAR 0 28
85542: PUSH
85543: EMPTY
85544: ST_TO_ADDR
// healers := [ ] ;
85545: LD_ADDR_VAR 0 31
85549: PUSH
85550: EMPTY
85551: ST_TO_ADDR
// to_heal := [ ] ;
85552: LD_ADDR_VAR 0 30
85556: PUSH
85557: EMPTY
85558: ST_TO_ADDR
// repairs := [ ] ;
85559: LD_ADDR_VAR 0 33
85563: PUSH
85564: EMPTY
85565: ST_TO_ADDR
// to_repair := [ ] ;
85566: LD_ADDR_VAR 0 32
85570: PUSH
85571: EMPTY
85572: ST_TO_ADDR
// if not group or not path then
85573: LD_VAR 0 4
85577: NOT
85578: PUSH
85579: LD_VAR 0 5
85583: NOT
85584: OR
85585: IFFALSE 85589
// exit ;
85587: GO 90101
// side := GetSide ( group [ 1 ] ) ;
85589: LD_ADDR_VAR 0 35
85593: PUSH
85594: LD_VAR 0 4
85598: PUSH
85599: LD_INT 1
85601: ARRAY
85602: PPUSH
85603: CALL_OW 255
85607: ST_TO_ADDR
// if flags then
85608: LD_VAR 0 6
85612: IFFALSE 85756
// begin f_ignore_area := flags [ 1 ] ;
85614: LD_ADDR_VAR 0 17
85618: PUSH
85619: LD_VAR 0 6
85623: PUSH
85624: LD_INT 1
85626: ARRAY
85627: ST_TO_ADDR
// f_capture := flags [ 2 ] ;
85628: LD_ADDR_VAR 0 18
85632: PUSH
85633: LD_VAR 0 6
85637: PUSH
85638: LD_INT 2
85640: ARRAY
85641: ST_TO_ADDR
// f_ignore_civ := flags [ 3 ] ;
85642: LD_ADDR_VAR 0 19
85646: PUSH
85647: LD_VAR 0 6
85651: PUSH
85652: LD_INT 3
85654: ARRAY
85655: ST_TO_ADDR
// f_murder := flags [ 4 ] ;
85656: LD_ADDR_VAR 0 20
85660: PUSH
85661: LD_VAR 0 6
85665: PUSH
85666: LD_INT 4
85668: ARRAY
85669: ST_TO_ADDR
// f_mines := flags [ 5 ] ;
85670: LD_ADDR_VAR 0 21
85674: PUSH
85675: LD_VAR 0 6
85679: PUSH
85680: LD_INT 5
85682: ARRAY
85683: ST_TO_ADDR
// f_repair := flags [ 6 ] ;
85684: LD_ADDR_VAR 0 22
85688: PUSH
85689: LD_VAR 0 6
85693: PUSH
85694: LD_INT 6
85696: ARRAY
85697: ST_TO_ADDR
// f_heal := flags [ 7 ] ;
85698: LD_ADDR_VAR 0 23
85702: PUSH
85703: LD_VAR 0 6
85707: PUSH
85708: LD_INT 7
85710: ARRAY
85711: ST_TO_ADDR
// f_spacetime := flags [ 8 ] ;
85712: LD_ADDR_VAR 0 24
85716: PUSH
85717: LD_VAR 0 6
85721: PUSH
85722: LD_INT 8
85724: ARRAY
85725: ST_TO_ADDR
// f_attack_depot := flags [ 9 ] ;
85726: LD_ADDR_VAR 0 25
85730: PUSH
85731: LD_VAR 0 6
85735: PUSH
85736: LD_INT 9
85738: ARRAY
85739: ST_TO_ADDR
// f_crawl := flags [ 10 ] ;
85740: LD_ADDR_VAR 0 26
85744: PUSH
85745: LD_VAR 0 6
85749: PUSH
85750: LD_INT 10
85752: ARRAY
85753: ST_TO_ADDR
// end else
85754: GO 85836
// begin f_ignore_area := false ;
85756: LD_ADDR_VAR 0 17
85760: PUSH
85761: LD_INT 0
85763: ST_TO_ADDR
// f_capture := false ;
85764: LD_ADDR_VAR 0 18
85768: PUSH
85769: LD_INT 0
85771: ST_TO_ADDR
// f_ignore_civ := false ;
85772: LD_ADDR_VAR 0 19
85776: PUSH
85777: LD_INT 0
85779: ST_TO_ADDR
// f_murder := false ;
85780: LD_ADDR_VAR 0 20
85784: PUSH
85785: LD_INT 0
85787: ST_TO_ADDR
// f_mines := false ;
85788: LD_ADDR_VAR 0 21
85792: PUSH
85793: LD_INT 0
85795: ST_TO_ADDR
// f_repair := false ;
85796: LD_ADDR_VAR 0 22
85800: PUSH
85801: LD_INT 0
85803: ST_TO_ADDR
// f_heal := false ;
85804: LD_ADDR_VAR 0 23
85808: PUSH
85809: LD_INT 0
85811: ST_TO_ADDR
// f_spacetime := false ;
85812: LD_ADDR_VAR 0 24
85816: PUSH
85817: LD_INT 0
85819: ST_TO_ADDR
// f_attack_depot := false ;
85820: LD_ADDR_VAR 0 25
85824: PUSH
85825: LD_INT 0
85827: ST_TO_ADDR
// f_crawl := false ;
85828: LD_ADDR_VAR 0 26
85832: PUSH
85833: LD_INT 0
85835: ST_TO_ADDR
// end ; if f_heal then
85836: LD_VAR 0 23
85840: IFFALSE 85867
// healers := UnitFilter ( group , [ f_class , 4 ] ) ;
85842: LD_ADDR_VAR 0 31
85846: PUSH
85847: LD_VAR 0 4
85851: PPUSH
85852: LD_INT 25
85854: PUSH
85855: LD_INT 4
85857: PUSH
85858: EMPTY
85859: LIST
85860: LIST
85861: PPUSH
85862: CALL_OW 72
85866: ST_TO_ADDR
// if f_repair then
85867: LD_VAR 0 22
85871: IFFALSE 85898
// repairs := UnitFilter ( group , [ f_class , 3 ] ) ;
85873: LD_ADDR_VAR 0 33
85877: PUSH
85878: LD_VAR 0 4
85882: PPUSH
85883: LD_INT 25
85885: PUSH
85886: LD_INT 3
85888: PUSH
85889: EMPTY
85890: LIST
85891: LIST
85892: PPUSH
85893: CALL_OW 72
85897: ST_TO_ADDR
// units_path := [ ] ;
85898: LD_ADDR_VAR 0 16
85902: PUSH
85903: EMPTY
85904: ST_TO_ADDR
// for i = 1 to group do
85905: LD_ADDR_VAR 0 7
85909: PUSH
85910: DOUBLE
85911: LD_INT 1
85913: DEC
85914: ST_TO_ADDR
85915: LD_VAR 0 4
85919: PUSH
85920: FOR_TO
85921: IFFALSE 85950
// units_path := Replace ( units_path , i , path ) ;
85923: LD_ADDR_VAR 0 16
85927: PUSH
85928: LD_VAR 0 16
85932: PPUSH
85933: LD_VAR 0 7
85937: PPUSH
85938: LD_VAR 0 5
85942: PPUSH
85943: CALL_OW 1
85947: ST_TO_ADDR
85948: GO 85920
85950: POP
85951: POP
// repeat for i = group downto 1 do
85952: LD_ADDR_VAR 0 7
85956: PUSH
85957: DOUBLE
85958: LD_VAR 0 4
85962: INC
85963: ST_TO_ADDR
85964: LD_INT 1
85966: PUSH
85967: FOR_DOWNTO
85968: IFFALSE 90064
// begin wait ( 5 ) ;
85970: LD_INT 5
85972: PPUSH
85973: CALL_OW 67
// tmp := [ ] ;
85977: LD_ADDR_VAR 0 14
85981: PUSH
85982: EMPTY
85983: ST_TO_ADDR
// attacking := false ;
85984: LD_ADDR_VAR 0 29
85988: PUSH
85989: LD_INT 0
85991: ST_TO_ADDR
// if IsDead ( group [ i ] ) or not group [ i ] then
85992: LD_VAR 0 4
85996: PUSH
85997: LD_VAR 0 7
86001: ARRAY
86002: PPUSH
86003: CALL_OW 301
86007: PUSH
86008: LD_VAR 0 4
86012: PUSH
86013: LD_VAR 0 7
86017: ARRAY
86018: NOT
86019: OR
86020: IFFALSE 86129
// begin if GetType ( group [ i ] ) = unit_human then
86022: LD_VAR 0 4
86026: PUSH
86027: LD_VAR 0 7
86031: ARRAY
86032: PPUSH
86033: CALL_OW 247
86037: PUSH
86038: LD_INT 1
86040: EQUAL
86041: IFFALSE 86087
// begin to_heal := to_heal diff group [ i ] ;
86043: LD_ADDR_VAR 0 30
86047: PUSH
86048: LD_VAR 0 30
86052: PUSH
86053: LD_VAR 0 4
86057: PUSH
86058: LD_VAR 0 7
86062: ARRAY
86063: DIFF
86064: ST_TO_ADDR
// healers := healers diff group [ i ] ;
86065: LD_ADDR_VAR 0 31
86069: PUSH
86070: LD_VAR 0 31
86074: PUSH
86075: LD_VAR 0 4
86079: PUSH
86080: LD_VAR 0 7
86084: ARRAY
86085: DIFF
86086: ST_TO_ADDR
// end ; group := Delete ( group , i ) ;
86087: LD_ADDR_VAR 0 4
86091: PUSH
86092: LD_VAR 0 4
86096: PPUSH
86097: LD_VAR 0 7
86101: PPUSH
86102: CALL_OW 3
86106: ST_TO_ADDR
// units_path := Delete ( units_path , i ) ;
86107: LD_ADDR_VAR 0 16
86111: PUSH
86112: LD_VAR 0 16
86116: PPUSH
86117: LD_VAR 0 7
86121: PPUSH
86122: CALL_OW 3
86126: ST_TO_ADDR
// continue ;
86127: GO 85967
// end ; if f_repair then
86129: LD_VAR 0 22
86133: IFFALSE 86622
// begin if GetType ( group [ i ] ) = unit_vehicle then
86135: LD_VAR 0 4
86139: PUSH
86140: LD_VAR 0 7
86144: ARRAY
86145: PPUSH
86146: CALL_OW 247
86150: PUSH
86151: LD_INT 2
86153: EQUAL
86154: IFFALSE 86344
// begin if GetLives ( group [ i ] ) < 700 and not group [ i ] in to_repair then
86156: LD_VAR 0 4
86160: PUSH
86161: LD_VAR 0 7
86165: ARRAY
86166: PPUSH
86167: CALL_OW 256
86171: PUSH
86172: LD_INT 700
86174: LESS
86175: PUSH
86176: LD_VAR 0 4
86180: PUSH
86181: LD_VAR 0 7
86185: ARRAY
86186: PUSH
86187: LD_VAR 0 32
86191: IN
86192: NOT
86193: AND
86194: IFFALSE 86218
// to_repair := to_repair union group [ i ] ;
86196: LD_ADDR_VAR 0 32
86200: PUSH
86201: LD_VAR 0 32
86205: PUSH
86206: LD_VAR 0 4
86210: PUSH
86211: LD_VAR 0 7
86215: ARRAY
86216: UNION
86217: ST_TO_ADDR
// if GetLives ( group [ i ] ) = 1000 and group [ i ] in to_repair then
86218: LD_VAR 0 4
86222: PUSH
86223: LD_VAR 0 7
86227: ARRAY
86228: PPUSH
86229: CALL_OW 256
86233: PUSH
86234: LD_INT 1000
86236: EQUAL
86237: PUSH
86238: LD_VAR 0 4
86242: PUSH
86243: LD_VAR 0 7
86247: ARRAY
86248: PUSH
86249: LD_VAR 0 32
86253: IN
86254: AND
86255: IFFALSE 86279
// to_repair := to_repair diff group [ i ] ;
86257: LD_ADDR_VAR 0 32
86261: PUSH
86262: LD_VAR 0 32
86266: PUSH
86267: LD_VAR 0 4
86271: PUSH
86272: LD_VAR 0 7
86276: ARRAY
86277: DIFF
86278: ST_TO_ADDR
// if group [ i ] in to_repair then
86279: LD_VAR 0 4
86283: PUSH
86284: LD_VAR 0 7
86288: ARRAY
86289: PUSH
86290: LD_VAR 0 32
86294: IN
86295: IFFALSE 86342
// begin if not IsInArea ( group [ i ] , f_repair ) then
86297: LD_VAR 0 4
86301: PUSH
86302: LD_VAR 0 7
86306: ARRAY
86307: PPUSH
86308: LD_VAR 0 22
86312: PPUSH
86313: CALL_OW 308
86317: NOT
86318: IFFALSE 86340
// ComMoveToArea ( group [ i ] , f_repair ) ;
86320: LD_VAR 0 4
86324: PUSH
86325: LD_VAR 0 7
86329: ARRAY
86330: PPUSH
86331: LD_VAR 0 22
86335: PPUSH
86336: CALL_OW 113
// continue ;
86340: GO 85967
// end ; end else
86342: GO 86622
// if group [ i ] in repairs then
86344: LD_VAR 0 4
86348: PUSH
86349: LD_VAR 0 7
86353: ARRAY
86354: PUSH
86355: LD_VAR 0 33
86359: IN
86360: IFFALSE 86622
// begin if IsInUnit ( group [ i ] ) then
86362: LD_VAR 0 4
86366: PUSH
86367: LD_VAR 0 7
86371: ARRAY
86372: PPUSH
86373: CALL_OW 310
86377: IFFALSE 86445
// begin z := IsInUnit ( group [ i ] ) ;
86379: LD_ADDR_VAR 0 13
86383: PUSH
86384: LD_VAR 0 4
86388: PUSH
86389: LD_VAR 0 7
86393: ARRAY
86394: PPUSH
86395: CALL_OW 310
86399: ST_TO_ADDR
// if z in to_repair and IsInArea ( z , f_repair ) then
86400: LD_VAR 0 13
86404: PUSH
86405: LD_VAR 0 32
86409: IN
86410: PUSH
86411: LD_VAR 0 13
86415: PPUSH
86416: LD_VAR 0 22
86420: PPUSH
86421: CALL_OW 308
86425: AND
86426: IFFALSE 86443
// ComExitVehicle ( group [ i ] ) ;
86428: LD_VAR 0 4
86432: PUSH
86433: LD_VAR 0 7
86437: ARRAY
86438: PPUSH
86439: CALL_OW 121
// end else
86443: GO 86622
// begin z := UnitFilter ( group , [ [ f_inarea , f_repair ] , [ f_empty ] ] ) ;
86445: LD_ADDR_VAR 0 13
86449: PUSH
86450: LD_VAR 0 4
86454: PPUSH
86455: LD_INT 95
86457: PUSH
86458: LD_VAR 0 22
86462: PUSH
86463: EMPTY
86464: LIST
86465: LIST
86466: PUSH
86467: LD_INT 58
86469: PUSH
86470: EMPTY
86471: LIST
86472: PUSH
86473: EMPTY
86474: LIST
86475: LIST
86476: PPUSH
86477: CALL_OW 72
86481: ST_TO_ADDR
// if not HasTask ( group [ i ] ) then
86482: LD_VAR 0 4
86486: PUSH
86487: LD_VAR 0 7
86491: ARRAY
86492: PPUSH
86493: CALL_OW 314
86497: NOT
86498: IFFALSE 86620
// begin x := NearestUnitToUnit ( z , group [ i ] ) ;
86500: LD_ADDR_VAR 0 10
86504: PUSH
86505: LD_VAR 0 13
86509: PPUSH
86510: LD_VAR 0 4
86514: PUSH
86515: LD_VAR 0 7
86519: ARRAY
86520: PPUSH
86521: CALL_OW 74
86525: ST_TO_ADDR
// if not x then
86526: LD_VAR 0 10
86530: NOT
86531: IFFALSE 86535
// continue ;
86533: GO 85967
// if GetLives ( x ) < 1000 then
86535: LD_VAR 0 10
86539: PPUSH
86540: CALL_OW 256
86544: PUSH
86545: LD_INT 1000
86547: LESS
86548: IFFALSE 86572
// ComRepairVehicle ( group [ i ] , x ) else
86550: LD_VAR 0 4
86554: PUSH
86555: LD_VAR 0 7
86559: ARRAY
86560: PPUSH
86561: LD_VAR 0 10
86565: PPUSH
86566: CALL_OW 129
86570: GO 86620
// if not ( f_heal and GetLives ( group [ i ] ) < 1000 ) then
86572: LD_VAR 0 23
86576: PUSH
86577: LD_VAR 0 4
86581: PUSH
86582: LD_VAR 0 7
86586: ARRAY
86587: PPUSH
86588: CALL_OW 256
86592: PUSH
86593: LD_INT 1000
86595: LESS
86596: AND
86597: NOT
86598: IFFALSE 86620
// ComEnterUnit ( group [ i ] , x ) ;
86600: LD_VAR 0 4
86604: PUSH
86605: LD_VAR 0 7
86609: ARRAY
86610: PPUSH
86611: LD_VAR 0 10
86615: PPUSH
86616: CALL_OW 120
// end ; continue ;
86620: GO 85967
// end ; end ; end ; if f_heal and GetType ( group [ i ] ) = unit_human then
86622: LD_VAR 0 23
86626: PUSH
86627: LD_VAR 0 4
86631: PUSH
86632: LD_VAR 0 7
86636: ARRAY
86637: PPUSH
86638: CALL_OW 247
86642: PUSH
86643: LD_INT 1
86645: EQUAL
86646: AND
86647: IFFALSE 87125
// begin if group [ i ] in healers then
86649: LD_VAR 0 4
86653: PUSH
86654: LD_VAR 0 7
86658: ARRAY
86659: PUSH
86660: LD_VAR 0 31
86664: IN
86665: IFFALSE 86938
// begin if not IsInArea ( group [ i ] , f_heal ) and not HasTask ( group [ i ] ) then
86667: LD_VAR 0 4
86671: PUSH
86672: LD_VAR 0 7
86676: ARRAY
86677: PPUSH
86678: LD_VAR 0 23
86682: PPUSH
86683: CALL_OW 308
86687: NOT
86688: PUSH
86689: LD_VAR 0 4
86693: PUSH
86694: LD_VAR 0 7
86698: ARRAY
86699: PPUSH
86700: CALL_OW 314
86704: NOT
86705: AND
86706: IFFALSE 86730
// ComMoveToArea ( group [ i ] , f_heal ) else
86708: LD_VAR 0 4
86712: PUSH
86713: LD_VAR 0 7
86717: ARRAY
86718: PPUSH
86719: LD_VAR 0 23
86723: PPUSH
86724: CALL_OW 113
86728: GO 86936
// if GetLives ( HealTarget ( group [ i ] ) ) = 1000 then
86730: LD_VAR 0 4
86734: PUSH
86735: LD_VAR 0 7
86739: ARRAY
86740: PPUSH
86741: CALL 85348 0 1
86745: PPUSH
86746: CALL_OW 256
86750: PUSH
86751: LD_INT 1000
86753: EQUAL
86754: IFFALSE 86773
// ComStop ( group [ i ] ) else
86756: LD_VAR 0 4
86760: PUSH
86761: LD_VAR 0 7
86765: ARRAY
86766: PPUSH
86767: CALL_OW 141
86771: GO 86936
// if not HasTask ( group [ i ] ) and to_heal then
86773: LD_VAR 0 4
86777: PUSH
86778: LD_VAR 0 7
86782: ARRAY
86783: PPUSH
86784: CALL_OW 314
86788: NOT
86789: PUSH
86790: LD_VAR 0 30
86794: AND
86795: IFFALSE 86936
// begin z := NearestUnitToUnit ( UnitFilter ( to_heal , [ f_not , [ f_inside ] ] ) , group [ i ] ) ;
86797: LD_ADDR_VAR 0 13
86801: PUSH
86802: LD_VAR 0 30
86806: PPUSH
86807: LD_INT 3
86809: PUSH
86810: LD_INT 54
86812: PUSH
86813: EMPTY
86814: LIST
86815: PUSH
86816: EMPTY
86817: LIST
86818: LIST
86819: PPUSH
86820: CALL_OW 72
86824: PPUSH
86825: LD_VAR 0 4
86829: PUSH
86830: LD_VAR 0 7
86834: ARRAY
86835: PPUSH
86836: CALL_OW 74
86840: ST_TO_ADDR
// if z then
86841: LD_VAR 0 13
86845: IFFALSE 86936
// if FilterAllUnits ( [ [ f_dist , z , 10 ] , [ f_enemy , GetSide ( z ) ] ] ) = 0 then
86847: LD_INT 91
86849: PUSH
86850: LD_VAR 0 13
86854: PUSH
86855: LD_INT 10
86857: PUSH
86858: EMPTY
86859: LIST
86860: LIST
86861: LIST
86862: PUSH
86863: LD_INT 81
86865: PUSH
86866: LD_VAR 0 13
86870: PPUSH
86871: CALL_OW 255
86875: PUSH
86876: EMPTY
86877: LIST
86878: LIST
86879: PUSH
86880: EMPTY
86881: LIST
86882: LIST
86883: PPUSH
86884: CALL_OW 69
86888: PUSH
86889: LD_INT 0
86891: EQUAL
86892: IFFALSE 86916
// ComHeal ( group [ i ] , z ) else
86894: LD_VAR 0 4
86898: PUSH
86899: LD_VAR 0 7
86903: ARRAY
86904: PPUSH
86905: LD_VAR 0 13
86909: PPUSH
86910: CALL_OW 128
86914: GO 86936
// ComMoveToArea ( group [ i ] , f_heal ) ;
86916: LD_VAR 0 4
86920: PUSH
86921: LD_VAR 0 7
86925: ARRAY
86926: PPUSH
86927: LD_VAR 0 23
86931: PPUSH
86932: CALL_OW 113
// end ; continue ;
86936: GO 85967
// end ; if GetLives ( group [ i ] ) < 700 and not group [ i ] in to_heal then
86938: LD_VAR 0 4
86942: PUSH
86943: LD_VAR 0 7
86947: ARRAY
86948: PPUSH
86949: CALL_OW 256
86953: PUSH
86954: LD_INT 700
86956: LESS
86957: PUSH
86958: LD_VAR 0 4
86962: PUSH
86963: LD_VAR 0 7
86967: ARRAY
86968: PUSH
86969: LD_VAR 0 30
86973: IN
86974: NOT
86975: AND
86976: IFFALSE 87000
// to_heal := to_heal union group [ i ] ;
86978: LD_ADDR_VAR 0 30
86982: PUSH
86983: LD_VAR 0 30
86987: PUSH
86988: LD_VAR 0 4
86992: PUSH
86993: LD_VAR 0 7
86997: ARRAY
86998: UNION
86999: ST_TO_ADDR
// if group [ i ] in to_heal then
87000: LD_VAR 0 4
87004: PUSH
87005: LD_VAR 0 7
87009: ARRAY
87010: PUSH
87011: LD_VAR 0 30
87015: IN
87016: IFFALSE 87125
// begin if GetLives ( group [ i ] ) = 1000 then
87018: LD_VAR 0 4
87022: PUSH
87023: LD_VAR 0 7
87027: ARRAY
87028: PPUSH
87029: CALL_OW 256
87033: PUSH
87034: LD_INT 1000
87036: EQUAL
87037: IFFALSE 87063
// to_heal := to_heal diff group [ i ] else
87039: LD_ADDR_VAR 0 30
87043: PUSH
87044: LD_VAR 0 30
87048: PUSH
87049: LD_VAR 0 4
87053: PUSH
87054: LD_VAR 0 7
87058: ARRAY
87059: DIFF
87060: ST_TO_ADDR
87061: GO 87125
// begin if not IsInArea ( group [ i ] , to_heal ) then
87063: LD_VAR 0 4
87067: PUSH
87068: LD_VAR 0 7
87072: ARRAY
87073: PPUSH
87074: LD_VAR 0 30
87078: PPUSH
87079: CALL_OW 308
87083: NOT
87084: IFFALSE 87108
// ComMoveToArea ( group [ i ] , f_heal ) else
87086: LD_VAR 0 4
87090: PUSH
87091: LD_VAR 0 7
87095: ARRAY
87096: PPUSH
87097: LD_VAR 0 23
87101: PPUSH
87102: CALL_OW 113
87106: GO 87123
// ComHold ( group [ i ] ) ;
87108: LD_VAR 0 4
87112: PUSH
87113: LD_VAR 0 7
87117: ARRAY
87118: PPUSH
87119: CALL_OW 140
// continue ;
87123: GO 85967
// end ; end ; end ; if not EnemyInRange ( group [ i ] , 10 ) and not units_path [ i ] = [ ] then
87125: LD_VAR 0 4
87129: PUSH
87130: LD_VAR 0 7
87134: ARRAY
87135: PPUSH
87136: LD_INT 10
87138: PPUSH
87139: CALL 83745 0 2
87143: NOT
87144: PUSH
87145: LD_VAR 0 16
87149: PUSH
87150: LD_VAR 0 7
87154: ARRAY
87155: PUSH
87156: EMPTY
87157: EQUAL
87158: NOT
87159: AND
87160: IFFALSE 87426
// begin if GetEngine ( group [ i ] ) in [ engine_combustion , engine_solar ] then
87162: LD_VAR 0 4
87166: PUSH
87167: LD_VAR 0 7
87171: ARRAY
87172: PPUSH
87173: CALL_OW 262
87177: PUSH
87178: LD_INT 1
87180: PUSH
87181: LD_INT 2
87183: PUSH
87184: EMPTY
87185: LIST
87186: LIST
87187: IN
87188: IFFALSE 87229
// if GetFuel ( group [ i ] ) < 10 then
87190: LD_VAR 0 4
87194: PUSH
87195: LD_VAR 0 7
87199: ARRAY
87200: PPUSH
87201: CALL_OW 261
87205: PUSH
87206: LD_INT 10
87208: LESS
87209: IFFALSE 87229
// SetFuel ( group [ i ] , 12 ) ;
87211: LD_VAR 0 4
87215: PUSH
87216: LD_VAR 0 7
87220: ARRAY
87221: PPUSH
87222: LD_INT 12
87224: PPUSH
87225: CALL_OW 240
// if units_path [ i ] then
87229: LD_VAR 0 16
87233: PUSH
87234: LD_VAR 0 7
87238: ARRAY
87239: IFFALSE 87424
// begin if GetDistUnitXY ( group [ i ] , units_path [ i ] [ 1 ] [ 1 ] , units_path [ i ] [ 1 ] [ 2 ] ) > 6 then
87241: LD_VAR 0 4
87245: PUSH
87246: LD_VAR 0 7
87250: ARRAY
87251: PPUSH
87252: LD_VAR 0 16
87256: PUSH
87257: LD_VAR 0 7
87261: ARRAY
87262: PUSH
87263: LD_INT 1
87265: ARRAY
87266: PUSH
87267: LD_INT 1
87269: ARRAY
87270: PPUSH
87271: LD_VAR 0 16
87275: PUSH
87276: LD_VAR 0 7
87280: ARRAY
87281: PUSH
87282: LD_INT 1
87284: ARRAY
87285: PUSH
87286: LD_INT 2
87288: ARRAY
87289: PPUSH
87290: CALL_OW 297
87294: PUSH
87295: LD_INT 6
87297: GREATER
87298: IFFALSE 87373
// begin if not HasTask ( group [ i ] ) then
87300: LD_VAR 0 4
87304: PUSH
87305: LD_VAR 0 7
87309: ARRAY
87310: PPUSH
87311: CALL_OW 314
87315: NOT
87316: IFFALSE 87371
// ComAgressiveMove ( group [ i ] , units_path [ i ] [ 1 ] [ 1 ] , units_path [ i ] [ 1 ] [ 2 ] ) ;
87318: LD_VAR 0 4
87322: PUSH
87323: LD_VAR 0 7
87327: ARRAY
87328: PPUSH
87329: LD_VAR 0 16
87333: PUSH
87334: LD_VAR 0 7
87338: ARRAY
87339: PUSH
87340: LD_INT 1
87342: ARRAY
87343: PUSH
87344: LD_INT 1
87346: ARRAY
87347: PPUSH
87348: LD_VAR 0 16
87352: PUSH
87353: LD_VAR 0 7
87357: ARRAY
87358: PUSH
87359: LD_INT 1
87361: ARRAY
87362: PUSH
87363: LD_INT 2
87365: ARRAY
87366: PPUSH
87367: CALL_OW 114
// end else
87371: GO 87424
// begin tmp2 := Delete ( units_path [ i ] , 1 ) ;
87373: LD_ADDR_VAR 0 15
87377: PUSH
87378: LD_VAR 0 16
87382: PUSH
87383: LD_VAR 0 7
87387: ARRAY
87388: PPUSH
87389: LD_INT 1
87391: PPUSH
87392: CALL_OW 3
87396: ST_TO_ADDR
// units_path := Replace ( units_path , i , tmp2 ) ;
87397: LD_ADDR_VAR 0 16
87401: PUSH
87402: LD_VAR 0 16
87406: PPUSH
87407: LD_VAR 0 7
87411: PPUSH
87412: LD_VAR 0 15
87416: PPUSH
87417: CALL_OW 1
87421: ST_TO_ADDR
// continue ;
87422: GO 85967
// end ; end ; end else
87424: GO 90062
// begin tmp := FilterAllUnits ( [ f_enemy , GetSide ( group [ i ] ) ] ) ;
87426: LD_ADDR_VAR 0 14
87430: PUSH
87431: LD_INT 81
87433: PUSH
87434: LD_VAR 0 4
87438: PUSH
87439: LD_VAR 0 7
87443: ARRAY
87444: PPUSH
87445: CALL_OW 255
87449: PUSH
87450: EMPTY
87451: LIST
87452: LIST
87453: PPUSH
87454: CALL_OW 69
87458: ST_TO_ADDR
// if not tmp then
87459: LD_VAR 0 14
87463: NOT
87464: IFFALSE 87468
// continue ;
87466: GO 85967
// if f_ignore_area then
87468: LD_VAR 0 17
87472: IFFALSE 87560
// begin tmp2 := UnitFilter ( tmp , [ f_not , [ f_distxy , f_ignore_area [ 1 ] , f_ignore_area [ 2 ] , f_ignore_area [ 3 ] ] ] ) ;
87474: LD_ADDR_VAR 0 15
87478: PUSH
87479: LD_VAR 0 14
87483: PPUSH
87484: LD_INT 3
87486: PUSH
87487: LD_INT 92
87489: PUSH
87490: LD_VAR 0 17
87494: PUSH
87495: LD_INT 1
87497: ARRAY
87498: PUSH
87499: LD_VAR 0 17
87503: PUSH
87504: LD_INT 2
87506: ARRAY
87507: PUSH
87508: LD_VAR 0 17
87512: PUSH
87513: LD_INT 3
87515: ARRAY
87516: PUSH
87517: EMPTY
87518: LIST
87519: LIST
87520: LIST
87521: LIST
87522: PUSH
87523: EMPTY
87524: LIST
87525: LIST
87526: PPUSH
87527: CALL_OW 72
87531: ST_TO_ADDR
// if ( tmp diff tmp2 ) then
87532: LD_VAR 0 14
87536: PUSH
87537: LD_VAR 0 15
87541: DIFF
87542: IFFALSE 87560
// tmp := tmp diff tmp2 ;
87544: LD_ADDR_VAR 0 14
87548: PUSH
87549: LD_VAR 0 14
87553: PUSH
87554: LD_VAR 0 15
87558: DIFF
87559: ST_TO_ADDR
// end ; if not f_murder then
87560: LD_VAR 0 20
87564: NOT
87565: IFFALSE 87623
// begin tmp2 := UnitFilter ( tmp , [ f_not , [ f_ok ] ] ) ;
87567: LD_ADDR_VAR 0 15
87571: PUSH
87572: LD_VAR 0 14
87576: PPUSH
87577: LD_INT 3
87579: PUSH
87580: LD_INT 50
87582: PUSH
87583: EMPTY
87584: LIST
87585: PUSH
87586: EMPTY
87587: LIST
87588: LIST
87589: PPUSH
87590: CALL_OW 72
87594: ST_TO_ADDR
// if ( tmp diff tmp2 ) then
87595: LD_VAR 0 14
87599: PUSH
87600: LD_VAR 0 15
87604: DIFF
87605: IFFALSE 87623
// tmp := tmp diff tmp2 ;
87607: LD_ADDR_VAR 0 14
87611: PUSH
87612: LD_VAR 0 14
87616: PUSH
87617: LD_VAR 0 15
87621: DIFF
87622: ST_TO_ADDR
// end ; tmp := SortByDistanceUnit ( group [ i ] , tmp , true , true ) ;
87623: LD_ADDR_VAR 0 14
87627: PUSH
87628: LD_VAR 0 4
87632: PUSH
87633: LD_VAR 0 7
87637: ARRAY
87638: PPUSH
87639: LD_VAR 0 14
87643: PPUSH
87644: LD_INT 1
87646: PPUSH
87647: LD_INT 1
87649: PPUSH
87650: CALL 57388 0 4
87654: ST_TO_ADDR
// if GetClass ( group [ i ] ) = 1 then
87655: LD_VAR 0 4
87659: PUSH
87660: LD_VAR 0 7
87664: ARRAY
87665: PPUSH
87666: CALL_OW 257
87670: PUSH
87671: LD_INT 1
87673: EQUAL
87674: IFFALSE 88122
// begin if WantPlant ( group [ i ] ) then
87676: LD_VAR 0 4
87680: PUSH
87681: LD_VAR 0 7
87685: ARRAY
87686: PPUSH
87687: CALL 56889 0 1
87691: IFFALSE 87695
// continue ;
87693: GO 85967
// if f_capture and not IsInUnit ( group [ i ] ) and tmp [ 1 ] in UnitFilter ( tmp , [ [ f_type , unit_vehicle ] , [ f_empty ] ] ) then
87695: LD_VAR 0 18
87699: PUSH
87700: LD_VAR 0 4
87704: PUSH
87705: LD_VAR 0 7
87709: ARRAY
87710: PPUSH
87711: CALL_OW 310
87715: NOT
87716: AND
87717: PUSH
87718: LD_VAR 0 14
87722: PUSH
87723: LD_INT 1
87725: ARRAY
87726: PUSH
87727: LD_VAR 0 14
87731: PPUSH
87732: LD_INT 21
87734: PUSH
87735: LD_INT 2
87737: PUSH
87738: EMPTY
87739: LIST
87740: LIST
87741: PUSH
87742: LD_INT 58
87744: PUSH
87745: EMPTY
87746: LIST
87747: PUSH
87748: EMPTY
87749: LIST
87750: LIST
87751: PPUSH
87752: CALL_OW 72
87756: IN
87757: AND
87758: IFFALSE 87794
// begin ComEnterUnit ( group [ i ] , tmp [ 1 ] ) ;
87760: LD_VAR 0 4
87764: PUSH
87765: LD_VAR 0 7
87769: ARRAY
87770: PPUSH
87771: LD_VAR 0 14
87775: PUSH
87776: LD_INT 1
87778: ARRAY
87779: PPUSH
87780: CALL_OW 120
// attacking := true ;
87784: LD_ADDR_VAR 0 29
87788: PUSH
87789: LD_INT 1
87791: ST_TO_ADDR
// continue ;
87792: GO 85967
// end ; if f_crawl and GetClass ( group [ i ] ) = 1 and GetLives ( group [ i ] ) < 800 and not Crawls ( group [ i ] ) then
87794: LD_VAR 0 26
87798: PUSH
87799: LD_VAR 0 4
87803: PUSH
87804: LD_VAR 0 7
87808: ARRAY
87809: PPUSH
87810: CALL_OW 257
87814: PUSH
87815: LD_INT 1
87817: EQUAL
87818: AND
87819: PUSH
87820: LD_VAR 0 4
87824: PUSH
87825: LD_VAR 0 7
87829: ARRAY
87830: PPUSH
87831: CALL_OW 256
87835: PUSH
87836: LD_INT 800
87838: LESS
87839: AND
87840: PUSH
87841: LD_VAR 0 4
87845: PUSH
87846: LD_VAR 0 7
87850: ARRAY
87851: PPUSH
87852: CALL_OW 318
87856: NOT
87857: AND
87858: IFFALSE 87875
// ComCrawl ( group [ i ] ) ;
87860: LD_VAR 0 4
87864: PUSH
87865: LD_VAR 0 7
87869: ARRAY
87870: PPUSH
87871: CALL_OW 137
// if f_mines then
87875: LD_VAR 0 21
87879: IFFALSE 88122
// begin if GetType ( tmp [ 1 ] ) = unit_building and not tmp [ 1 ] in mined then
87881: LD_VAR 0 14
87885: PUSH
87886: LD_INT 1
87888: ARRAY
87889: PPUSH
87890: CALL_OW 247
87894: PUSH
87895: LD_INT 3
87897: EQUAL
87898: PUSH
87899: LD_VAR 0 14
87903: PUSH
87904: LD_INT 1
87906: ARRAY
87907: PUSH
87908: LD_VAR 0 27
87912: IN
87913: NOT
87914: AND
87915: IFFALSE 88122
// begin x := GetX ( tmp [ 1 ] ) ;
87917: LD_ADDR_VAR 0 10
87921: PUSH
87922: LD_VAR 0 14
87926: PUSH
87927: LD_INT 1
87929: ARRAY
87930: PPUSH
87931: CALL_OW 250
87935: ST_TO_ADDR
// y := GetY ( tmp [ 1 ] ) ;
87936: LD_ADDR_VAR 0 11
87940: PUSH
87941: LD_VAR 0 14
87945: PUSH
87946: LD_INT 1
87948: ARRAY
87949: PPUSH
87950: CALL_OW 251
87954: ST_TO_ADDR
// d := ReverseDir ( group [ i ] ) ;
87955: LD_ADDR_VAR 0 12
87959: PUSH
87960: LD_VAR 0 4
87964: PUSH
87965: LD_VAR 0 7
87969: ARRAY
87970: PPUSH
87971: CALL 83830 0 1
87975: ST_TO_ADDR
// ComPlaceDelayedCharge ( group [ i ] , x , y , tmp [ 1 ] ) ;
87976: LD_VAR 0 4
87980: PUSH
87981: LD_VAR 0 7
87985: ARRAY
87986: PPUSH
87987: LD_VAR 0 10
87991: PPUSH
87992: LD_VAR 0 11
87996: PPUSH
87997: LD_VAR 0 14
88001: PUSH
88002: LD_INT 1
88004: ARRAY
88005: PPUSH
88006: CALL_OW 132
// AddComMoveXY ( group [ i ] , ShiftX ( x , d , 7 ) , ShiftY ( y , d , 7 ) ) ;
88010: LD_VAR 0 4
88014: PUSH
88015: LD_VAR 0 7
88019: ARRAY
88020: PPUSH
88021: LD_VAR 0 10
88025: PPUSH
88026: LD_VAR 0 12
88030: PPUSH
88031: LD_INT 7
88033: PPUSH
88034: CALL_OW 272
88038: PPUSH
88039: LD_VAR 0 11
88043: PPUSH
88044: LD_VAR 0 12
88048: PPUSH
88049: LD_INT 7
88051: PPUSH
88052: CALL_OW 273
88056: PPUSH
88057: CALL_OW 171
// SetTag ( group [ i ] , 71 ) ;
88061: LD_VAR 0 4
88065: PUSH
88066: LD_VAR 0 7
88070: ARRAY
88071: PPUSH
88072: LD_INT 71
88074: PPUSH
88075: CALL_OW 109
// mined := Replace ( mined , mined + 1 , tmp [ 1 ] ) ;
88079: LD_ADDR_VAR 0 27
88083: PUSH
88084: LD_VAR 0 27
88088: PPUSH
88089: LD_VAR 0 27
88093: PUSH
88094: LD_INT 1
88096: PLUS
88097: PPUSH
88098: LD_VAR 0 14
88102: PUSH
88103: LD_INT 1
88105: ARRAY
88106: PPUSH
88107: CALL_OW 1
88111: ST_TO_ADDR
// attacking := true ;
88112: LD_ADDR_VAR 0 29
88116: PUSH
88117: LD_INT 1
88119: ST_TO_ADDR
// continue ;
88120: GO 85967
// end ; end ; end ; if GetClass ( group [ i ] ) = 17 and not GetTag ( group [ i ] ) = 71 then
88122: LD_VAR 0 4
88126: PUSH
88127: LD_VAR 0 7
88131: ARRAY
88132: PPUSH
88133: CALL_OW 257
88137: PUSH
88138: LD_INT 17
88140: EQUAL
88141: PUSH
88142: LD_VAR 0 4
88146: PUSH
88147: LD_VAR 0 7
88151: ARRAY
88152: PPUSH
88153: CALL_OW 110
88157: PUSH
88158: LD_INT 71
88160: EQUAL
88161: NOT
88162: AND
88163: IFFALSE 88309
// begin attacking := false ;
88165: LD_ADDR_VAR 0 29
88169: PUSH
88170: LD_INT 0
88172: ST_TO_ADDR
// k := 5 ;
88173: LD_ADDR_VAR 0 9
88177: PUSH
88178: LD_INT 5
88180: ST_TO_ADDR
// if tmp < k then
88181: LD_VAR 0 14
88185: PUSH
88186: LD_VAR 0 9
88190: LESS
88191: IFFALSE 88203
// k := tmp ;
88193: LD_ADDR_VAR 0 9
88197: PUSH
88198: LD_VAR 0 14
88202: ST_TO_ADDR
// for j = 1 to k do
88203: LD_ADDR_VAR 0 8
88207: PUSH
88208: DOUBLE
88209: LD_INT 1
88211: DEC
88212: ST_TO_ADDR
88213: LD_VAR 0 9
88217: PUSH
88218: FOR_TO
88219: IFFALSE 88307
// begin if not tmp [ j ] in UnitFilter ( tmp , [ f_empty ] ) then
88221: LD_VAR 0 14
88225: PUSH
88226: LD_VAR 0 8
88230: ARRAY
88231: PUSH
88232: LD_VAR 0 14
88236: PPUSH
88237: LD_INT 58
88239: PUSH
88240: EMPTY
88241: LIST
88242: PPUSH
88243: CALL_OW 72
88247: IN
88248: NOT
88249: IFFALSE 88305
// begin ComAttackUnit ( group [ i ] , tmp [ j ] ) ;
88251: LD_VAR 0 4
88255: PUSH
88256: LD_VAR 0 7
88260: ARRAY
88261: PPUSH
88262: LD_VAR 0 14
88266: PUSH
88267: LD_VAR 0 8
88271: ARRAY
88272: PPUSH
88273: CALL_OW 115
// attacking := true ;
88277: LD_ADDR_VAR 0 29
88281: PUSH
88282: LD_INT 1
88284: ST_TO_ADDR
// SetTag ( group [ i ] , 71 ) ;
88285: LD_VAR 0 4
88289: PUSH
88290: LD_VAR 0 7
88294: ARRAY
88295: PPUSH
88296: LD_INT 71
88298: PPUSH
88299: CALL_OW 109
// continue ;
88303: GO 88218
// end ; end ;
88305: GO 88218
88307: POP
88308: POP
// end ; if GetClass ( group [ i ] ) = 8 or GetWeapon ( group [ i ] ) in [ ar_rocket_launcher , ru_rocket_launcher , us_rocket_launcher , ru_rocket ] then
88309: LD_VAR 0 4
88313: PUSH
88314: LD_VAR 0 7
88318: ARRAY
88319: PPUSH
88320: CALL_OW 257
88324: PUSH
88325: LD_INT 8
88327: EQUAL
88328: PUSH
88329: LD_VAR 0 4
88333: PUSH
88334: LD_VAR 0 7
88338: ARRAY
88339: PPUSH
88340: CALL_OW 264
88344: PUSH
88345: LD_INT 28
88347: PUSH
88348: LD_INT 45
88350: PUSH
88351: LD_INT 7
88353: PUSH
88354: LD_INT 47
88356: PUSH
88357: EMPTY
88358: LIST
88359: LIST
88360: LIST
88361: LIST
88362: IN
88363: OR
88364: IFFALSE 88594
// begin attacking := false ;
88366: LD_ADDR_VAR 0 29
88370: PUSH
88371: LD_INT 0
88373: ST_TO_ADDR
// if GetBType ( tmp [ 1 ] ) in [ b_bunker , b_breastwork , b_turret , b_armoury , b_barracks ] then
88374: LD_VAR 0 14
88378: PUSH
88379: LD_INT 1
88381: ARRAY
88382: PPUSH
88383: CALL_OW 266
88387: PUSH
88388: LD_INT 32
88390: PUSH
88391: LD_INT 31
88393: PUSH
88394: LD_INT 33
88396: PUSH
88397: LD_INT 4
88399: PUSH
88400: LD_INT 5
88402: PUSH
88403: EMPTY
88404: LIST
88405: LIST
88406: LIST
88407: LIST
88408: LIST
88409: IN
88410: IFFALSE 88594
// begin k := GetBuildingHexes ( GetBType ( tmp [ 1 ] ) , GetX ( tmp [ 1 ] ) , GetY ( tmp [ 1 ] ) , GetDir ( tmp [ 1 ] ) , GetNation ( tmp [ 1 ] ) , 0 ) ;
88412: LD_ADDR_VAR 0 9
88416: PUSH
88417: LD_VAR 0 14
88421: PUSH
88422: LD_INT 1
88424: ARRAY
88425: PPUSH
88426: CALL_OW 266
88430: PPUSH
88431: LD_VAR 0 14
88435: PUSH
88436: LD_INT 1
88438: ARRAY
88439: PPUSH
88440: CALL_OW 250
88444: PPUSH
88445: LD_VAR 0 14
88449: PUSH
88450: LD_INT 1
88452: ARRAY
88453: PPUSH
88454: CALL_OW 251
88458: PPUSH
88459: LD_VAR 0 14
88463: PUSH
88464: LD_INT 1
88466: ARRAY
88467: PPUSH
88468: CALL_OW 254
88472: PPUSH
88473: LD_VAR 0 14
88477: PUSH
88478: LD_INT 1
88480: ARRAY
88481: PPUSH
88482: CALL_OW 248
88486: PPUSH
88487: LD_INT 0
88489: PPUSH
88490: CALL 65200 0 6
88494: ST_TO_ADDR
// j := GetClosestHex ( group [ i ] , k ) ;
88495: LD_ADDR_VAR 0 8
88499: PUSH
88500: LD_VAR 0 4
88504: PUSH
88505: LD_VAR 0 7
88509: ARRAY
88510: PPUSH
88511: LD_VAR 0 9
88515: PPUSH
88516: CALL 83893 0 2
88520: ST_TO_ADDR
// if j then
88521: LD_VAR 0 8
88525: IFFALSE 88594
// if ValidHex ( j [ 1 ] , j [ 2 ] ) then
88527: LD_VAR 0 8
88531: PUSH
88532: LD_INT 1
88534: ARRAY
88535: PPUSH
88536: LD_VAR 0 8
88540: PUSH
88541: LD_INT 2
88543: ARRAY
88544: PPUSH
88545: CALL_OW 488
88549: IFFALSE 88594
// begin ComAttackPlace ( group [ i ] , j [ 1 ] , j [ 2 ] ) ;
88551: LD_VAR 0 4
88555: PUSH
88556: LD_VAR 0 7
88560: ARRAY
88561: PPUSH
88562: LD_VAR 0 8
88566: PUSH
88567: LD_INT 1
88569: ARRAY
88570: PPUSH
88571: LD_VAR 0 8
88575: PUSH
88576: LD_INT 2
88578: ARRAY
88579: PPUSH
88580: CALL_OW 116
// attacking := true ;
88584: LD_ADDR_VAR 0 29
88588: PUSH
88589: LD_INT 1
88591: ST_TO_ADDR
// continue ;
88592: GO 85967
// end ; end ; end ; if GetChassis ( group [ i ] ) = ar_hovercraft then
88594: LD_VAR 0 4
88598: PUSH
88599: LD_VAR 0 7
88603: ARRAY
88604: PPUSH
88605: CALL_OW 265
88609: PUSH
88610: LD_INT 11
88612: EQUAL
88613: IFFALSE 88891
// begin k := 10 ;
88615: LD_ADDR_VAR 0 9
88619: PUSH
88620: LD_INT 10
88622: ST_TO_ADDR
// x := 0 ;
88623: LD_ADDR_VAR 0 10
88627: PUSH
88628: LD_INT 0
88630: ST_TO_ADDR
// if tmp < k then
88631: LD_VAR 0 14
88635: PUSH
88636: LD_VAR 0 9
88640: LESS
88641: IFFALSE 88653
// k := tmp ;
88643: LD_ADDR_VAR 0 9
88647: PUSH
88648: LD_VAR 0 14
88652: ST_TO_ADDR
// for j = k downto 1 do
88653: LD_ADDR_VAR 0 8
88657: PUSH
88658: DOUBLE
88659: LD_VAR 0 9
88663: INC
88664: ST_TO_ADDR
88665: LD_INT 1
88667: PUSH
88668: FOR_DOWNTO
88669: IFFALSE 88744
// begin if GetType ( tmp [ j ] ) = unit_human then
88671: LD_VAR 0 14
88675: PUSH
88676: LD_VAR 0 8
88680: ARRAY
88681: PPUSH
88682: CALL_OW 247
88686: PUSH
88687: LD_INT 1
88689: EQUAL
88690: IFFALSE 88742
// begin AttackHovercraft ( group [ i ] , tmp [ j ] ) ;
88692: LD_VAR 0 4
88696: PUSH
88697: LD_VAR 0 7
88701: ARRAY
88702: PPUSH
88703: LD_VAR 0 14
88707: PUSH
88708: LD_VAR 0 8
88712: ARRAY
88713: PPUSH
88714: CALL 84164 0 2
// x := tmp [ j ] ;
88718: LD_ADDR_VAR 0 10
88722: PUSH
88723: LD_VAR 0 14
88727: PUSH
88728: LD_VAR 0 8
88732: ARRAY
88733: ST_TO_ADDR
// attacking := true ;
88734: LD_ADDR_VAR 0 29
88738: PUSH
88739: LD_INT 1
88741: ST_TO_ADDR
// end ; end ;
88742: GO 88668
88744: POP
88745: POP
// if not x then
88746: LD_VAR 0 10
88750: NOT
88751: IFFALSE 88891
// begin attacking := true ;
88753: LD_ADDR_VAR 0 29
88757: PUSH
88758: LD_INT 1
88760: ST_TO_ADDR
// if GetHexInfo ( GetX ( group [ i ] ) , GetY ( group [ i ] ) ) [ 2 ] = GetHexInfo ( GetX ( tmp [ 1 ] ) , GetY ( tmp [ 1 ] ) ) [ 2 ] then
88761: LD_VAR 0 4
88765: PUSH
88766: LD_VAR 0 7
88770: ARRAY
88771: PPUSH
88772: CALL_OW 250
88776: PPUSH
88777: LD_VAR 0 4
88781: PUSH
88782: LD_VAR 0 7
88786: ARRAY
88787: PPUSH
88788: CALL_OW 251
88792: PPUSH
88793: CALL_OW 546
88797: PUSH
88798: LD_INT 2
88800: ARRAY
88801: PUSH
88802: LD_VAR 0 14
88806: PUSH
88807: LD_INT 1
88809: ARRAY
88810: PPUSH
88811: CALL_OW 250
88815: PPUSH
88816: LD_VAR 0 14
88820: PUSH
88821: LD_INT 1
88823: ARRAY
88824: PPUSH
88825: CALL_OW 251
88829: PPUSH
88830: CALL_OW 546
88834: PUSH
88835: LD_INT 2
88837: ARRAY
88838: EQUAL
88839: IFFALSE 88867
// AttackHovercraft ( group [ i ] , tmp [ 1 ] ) else
88841: LD_VAR 0 4
88845: PUSH
88846: LD_VAR 0 7
88850: ARRAY
88851: PPUSH
88852: LD_VAR 0 14
88856: PUSH
88857: LD_INT 1
88859: ARRAY
88860: PPUSH
88861: CALL 84164 0 2
88865: GO 88891
// ComAttackUnit ( group [ i ] , tmp [ 1 ] ) ;
88867: LD_VAR 0 4
88871: PUSH
88872: LD_VAR 0 7
88876: ARRAY
88877: PPUSH
88878: LD_VAR 0 14
88882: PUSH
88883: LD_INT 1
88885: ARRAY
88886: PPUSH
88887: CALL_OW 115
// end ; end ; if GetWeapon ( group [ i ] ) = ar_selfpropelled_bomb then
88891: LD_VAR 0 4
88895: PUSH
88896: LD_VAR 0 7
88900: ARRAY
88901: PPUSH
88902: CALL_OW 264
88906: PUSH
88907: LD_INT 29
88909: EQUAL
88910: IFFALSE 89276
// begin if WantsToAttack ( group [ i ] ) in bombed then
88912: LD_VAR 0 4
88916: PUSH
88917: LD_VAR 0 7
88921: ARRAY
88922: PPUSH
88923: CALL_OW 319
88927: PUSH
88928: LD_VAR 0 28
88932: IN
88933: IFFALSE 88937
// continue ;
88935: GO 85967
// k := 8 ;
88937: LD_ADDR_VAR 0 9
88941: PUSH
88942: LD_INT 8
88944: ST_TO_ADDR
// x := 0 ;
88945: LD_ADDR_VAR 0 10
88949: PUSH
88950: LD_INT 0
88952: ST_TO_ADDR
// if tmp < k then
88953: LD_VAR 0 14
88957: PUSH
88958: LD_VAR 0 9
88962: LESS
88963: IFFALSE 88975
// k := tmp ;
88965: LD_ADDR_VAR 0 9
88969: PUSH
88970: LD_VAR 0 14
88974: ST_TO_ADDR
// for j = 1 to k do
88975: LD_ADDR_VAR 0 8
88979: PUSH
88980: DOUBLE
88981: LD_INT 1
88983: DEC
88984: ST_TO_ADDR
88985: LD_VAR 0 9
88989: PUSH
88990: FOR_TO
88991: IFFALSE 89123
// begin if GetType ( tmp [ j ] ) = unit_building then
88993: LD_VAR 0 14
88997: PUSH
88998: LD_VAR 0 8
89002: ARRAY
89003: PPUSH
89004: CALL_OW 247
89008: PUSH
89009: LD_INT 3
89011: EQUAL
89012: IFFALSE 89121
// if not tmp [ j ] in bombed and UnitsInside ( tmp [ j ] ) then
89014: LD_VAR 0 14
89018: PUSH
89019: LD_VAR 0 8
89023: ARRAY
89024: PUSH
89025: LD_VAR 0 28
89029: IN
89030: NOT
89031: PUSH
89032: LD_VAR 0 14
89036: PUSH
89037: LD_VAR 0 8
89041: ARRAY
89042: PPUSH
89043: CALL_OW 313
89047: AND
89048: IFFALSE 89121
// begin ComAttackUnit ( group [ i ] , tmp [ j ] ) ;
89050: LD_VAR 0 4
89054: PUSH
89055: LD_VAR 0 7
89059: ARRAY
89060: PPUSH
89061: LD_VAR 0 14
89065: PUSH
89066: LD_VAR 0 8
89070: ARRAY
89071: PPUSH
89072: CALL_OW 115
// bombed := Replace ( bombed , bombed + 1 , tmp [ j ] ) ;
89076: LD_ADDR_VAR 0 28
89080: PUSH
89081: LD_VAR 0 28
89085: PPUSH
89086: LD_VAR 0 28
89090: PUSH
89091: LD_INT 1
89093: PLUS
89094: PPUSH
89095: LD_VAR 0 14
89099: PUSH
89100: LD_VAR 0 8
89104: ARRAY
89105: PPUSH
89106: CALL_OW 1
89110: ST_TO_ADDR
// attacking := true ;
89111: LD_ADDR_VAR 0 29
89115: PUSH
89116: LD_INT 1
89118: ST_TO_ADDR
// break ;
89119: GO 89123
// end ; end ;
89121: GO 88990
89123: POP
89124: POP
// if not attacking and f_attack_depot then
89125: LD_VAR 0 29
89129: NOT
89130: PUSH
89131: LD_VAR 0 25
89135: AND
89136: IFFALSE 89231
// begin z := UnitFilter ( tmp , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) ;
89138: LD_ADDR_VAR 0 13
89142: PUSH
89143: LD_VAR 0 14
89147: PPUSH
89148: LD_INT 2
89150: PUSH
89151: LD_INT 30
89153: PUSH
89154: LD_INT 0
89156: PUSH
89157: EMPTY
89158: LIST
89159: LIST
89160: PUSH
89161: LD_INT 30
89163: PUSH
89164: LD_INT 1
89166: PUSH
89167: EMPTY
89168: LIST
89169: LIST
89170: PUSH
89171: EMPTY
89172: LIST
89173: LIST
89174: LIST
89175: PPUSH
89176: CALL_OW 72
89180: ST_TO_ADDR
// if z then
89181: LD_VAR 0 13
89185: IFFALSE 89231
// begin ComAttackUnit ( group [ i ] , NearestUnitToUnit ( z , group [ i ] ) ) ;
89187: LD_VAR 0 4
89191: PUSH
89192: LD_VAR 0 7
89196: ARRAY
89197: PPUSH
89198: LD_VAR 0 13
89202: PPUSH
89203: LD_VAR 0 4
89207: PUSH
89208: LD_VAR 0 7
89212: ARRAY
89213: PPUSH
89214: CALL_OW 74
89218: PPUSH
89219: CALL_OW 115
// attacking := true ;
89223: LD_ADDR_VAR 0 29
89227: PUSH
89228: LD_INT 1
89230: ST_TO_ADDR
// end ; end ; if GetLives ( group [ i ] ) < 500 then
89231: LD_VAR 0 4
89235: PUSH
89236: LD_VAR 0 7
89240: ARRAY
89241: PPUSH
89242: CALL_OW 256
89246: PUSH
89247: LD_INT 500
89249: LESS
89250: IFFALSE 89276
// ComAttackUnit ( group [ i ] , tmp [ 1 ] ) ;
89252: LD_VAR 0 4
89256: PUSH
89257: LD_VAR 0 7
89261: ARRAY
89262: PPUSH
89263: LD_VAR 0 14
89267: PUSH
89268: LD_INT 1
89270: ARRAY
89271: PPUSH
89272: CALL_OW 115
// end ; if GetWeapon ( group [ i ] ) = ru_time_lapser then
89276: LD_VAR 0 4
89280: PUSH
89281: LD_VAR 0 7
89285: ARRAY
89286: PPUSH
89287: CALL_OW 264
89291: PUSH
89292: LD_INT 49
89294: EQUAL
89295: IFFALSE 89416
// begin if not HasTask ( group [ i ] ) then
89297: LD_VAR 0 4
89301: PUSH
89302: LD_VAR 0 7
89306: ARRAY
89307: PPUSH
89308: CALL_OW 314
89312: NOT
89313: IFFALSE 89416
// begin k := NearestUnitToUnit ( FilterAllUnits ( [ f_enemy , GetSide ( group [ i ] ) ] ) , group [ i ] ) ;
89315: LD_ADDR_VAR 0 9
89319: PUSH
89320: LD_INT 81
89322: PUSH
89323: LD_VAR 0 4
89327: PUSH
89328: LD_VAR 0 7
89332: ARRAY
89333: PPUSH
89334: CALL_OW 255
89338: PUSH
89339: EMPTY
89340: LIST
89341: LIST
89342: PPUSH
89343: CALL_OW 69
89347: PPUSH
89348: LD_VAR 0 4
89352: PUSH
89353: LD_VAR 0 7
89357: ARRAY
89358: PPUSH
89359: CALL_OW 74
89363: ST_TO_ADDR
// if k then
89364: LD_VAR 0 9
89368: IFFALSE 89416
// if GetDistUnits ( group [ i ] , k ) > 10 then
89370: LD_VAR 0 4
89374: PUSH
89375: LD_VAR 0 7
89379: ARRAY
89380: PPUSH
89381: LD_VAR 0 9
89385: PPUSH
89386: CALL_OW 296
89390: PUSH
89391: LD_INT 10
89393: GREATER
89394: IFFALSE 89416
// ComMoveUnit ( group [ i ] , k ) ;
89396: LD_VAR 0 4
89400: PUSH
89401: LD_VAR 0 7
89405: ARRAY
89406: PPUSH
89407: LD_VAR 0 9
89411: PPUSH
89412: CALL_OW 112
// end ; end ; if GetLives ( group [ i ] ) < 250 and group [ i ] in FilterAllUnits ( [ [ f_type , unit_vehicle ] , [ f_nation , 2 ] ] ) then
89416: LD_VAR 0 4
89420: PUSH
89421: LD_VAR 0 7
89425: ARRAY
89426: PPUSH
89427: CALL_OW 256
89431: PUSH
89432: LD_INT 250
89434: LESS
89435: PUSH
89436: LD_VAR 0 4
89440: PUSH
89441: LD_VAR 0 7
89445: ARRAY
89446: PUSH
89447: LD_INT 21
89449: PUSH
89450: LD_INT 2
89452: PUSH
89453: EMPTY
89454: LIST
89455: LIST
89456: PUSH
89457: LD_INT 23
89459: PUSH
89460: LD_INT 2
89462: PUSH
89463: EMPTY
89464: LIST
89465: LIST
89466: PUSH
89467: EMPTY
89468: LIST
89469: LIST
89470: PPUSH
89471: CALL_OW 69
89475: IN
89476: AND
89477: IFFALSE 89602
// begin k := NearestUnitToUnit ( all_units diff group [ i ] , group [ i ] ) ;
89479: LD_ADDR_VAR 0 9
89483: PUSH
89484: LD_OWVAR 3
89488: PUSH
89489: LD_VAR 0 4
89493: PUSH
89494: LD_VAR 0 7
89498: ARRAY
89499: DIFF
89500: PPUSH
89501: LD_VAR 0 4
89505: PUSH
89506: LD_VAR 0 7
89510: ARRAY
89511: PPUSH
89512: CALL_OW 74
89516: ST_TO_ADDR
// if not k then
89517: LD_VAR 0 9
89521: NOT
89522: IFFALSE 89526
// continue ;
89524: GO 85967
// if k in FilterAllUnits ( [ f_enemy , GetSide ( group [ i ] ) ] ) and GetDistUnits ( k , group [ i ] ) < 5 then
89526: LD_VAR 0 9
89530: PUSH
89531: LD_INT 81
89533: PUSH
89534: LD_VAR 0 4
89538: PUSH
89539: LD_VAR 0 7
89543: ARRAY
89544: PPUSH
89545: CALL_OW 255
89549: PUSH
89550: EMPTY
89551: LIST
89552: LIST
89553: PPUSH
89554: CALL_OW 69
89558: IN
89559: PUSH
89560: LD_VAR 0 9
89564: PPUSH
89565: LD_VAR 0 4
89569: PUSH
89570: LD_VAR 0 7
89574: ARRAY
89575: PPUSH
89576: CALL_OW 296
89580: PUSH
89581: LD_INT 5
89583: LESS
89584: AND
89585: IFFALSE 89602
// ComAutodestruct ( group [ i ] ) ;
89587: LD_VAR 0 4
89591: PUSH
89592: LD_VAR 0 7
89596: ARRAY
89597: PPUSH
89598: CALL 84062 0 1
// end ; if f_attack_depot then
89602: LD_VAR 0 25
89606: IFFALSE 89718
// begin k := 6 ;
89608: LD_ADDR_VAR 0 9
89612: PUSH
89613: LD_INT 6
89615: ST_TO_ADDR
// if tmp < k then
89616: LD_VAR 0 14
89620: PUSH
89621: LD_VAR 0 9
89625: LESS
89626: IFFALSE 89638
// k := tmp ;
89628: LD_ADDR_VAR 0 9
89632: PUSH
89633: LD_VAR 0 14
89637: ST_TO_ADDR
// for j = 1 to k do
89638: LD_ADDR_VAR 0 8
89642: PUSH
89643: DOUBLE
89644: LD_INT 1
89646: DEC
89647: ST_TO_ADDR
89648: LD_VAR 0 9
89652: PUSH
89653: FOR_TO
89654: IFFALSE 89716
// if GetBType ( j ) in [ b_depot , b_warehouse ] then
89656: LD_VAR 0 8
89660: PPUSH
89661: CALL_OW 266
89665: PUSH
89666: LD_INT 0
89668: PUSH
89669: LD_INT 1
89671: PUSH
89672: EMPTY
89673: LIST
89674: LIST
89675: IN
89676: IFFALSE 89714
// begin ComAttackUnit ( group [ i ] , tmp [ j ] ) ;
89678: LD_VAR 0 4
89682: PUSH
89683: LD_VAR 0 7
89687: ARRAY
89688: PPUSH
89689: LD_VAR 0 14
89693: PUSH
89694: LD_VAR 0 8
89698: ARRAY
89699: PPUSH
89700: CALL_OW 115
// attacking := true ;
89704: LD_ADDR_VAR 0 29
89708: PUSH
89709: LD_INT 1
89711: ST_TO_ADDR
// break ;
89712: GO 89716
// end ;
89714: GO 89653
89716: POP
89717: POP
// end ; if IsOk ( group [ i ] ) and not attacking then
89718: LD_VAR 0 4
89722: PUSH
89723: LD_VAR 0 7
89727: ARRAY
89728: PPUSH
89729: CALL_OW 302
89733: PUSH
89734: LD_VAR 0 29
89738: NOT
89739: AND
89740: IFFALSE 90062
// begin if GetTag ( group [ i ] ) = 71 then
89742: LD_VAR 0 4
89746: PUSH
89747: LD_VAR 0 7
89751: ARRAY
89752: PPUSH
89753: CALL_OW 110
89757: PUSH
89758: LD_INT 71
89760: EQUAL
89761: IFFALSE 89802
// begin if HasTask ( group [ i ] ) then
89763: LD_VAR 0 4
89767: PUSH
89768: LD_VAR 0 7
89772: ARRAY
89773: PPUSH
89774: CALL_OW 314
89778: IFFALSE 89784
// continue else
89780: GO 85967
89782: GO 89802
// SetTag ( group [ i ] , 0 ) ;
89784: LD_VAR 0 4
89788: PUSH
89789: LD_VAR 0 7
89793: ARRAY
89794: PPUSH
89795: LD_INT 0
89797: PPUSH
89798: CALL_OW 109
// end ; k := 8 ;
89802: LD_ADDR_VAR 0 9
89806: PUSH
89807: LD_INT 8
89809: ST_TO_ADDR
// x := 0 ;
89810: LD_ADDR_VAR 0 10
89814: PUSH
89815: LD_INT 0
89817: ST_TO_ADDR
// if tmp < k then
89818: LD_VAR 0 14
89822: PUSH
89823: LD_VAR 0 9
89827: LESS
89828: IFFALSE 89840
// k := tmp ;
89830: LD_ADDR_VAR 0 9
89834: PUSH
89835: LD_VAR 0 14
89839: ST_TO_ADDR
// for j = 1 to k do
89840: LD_ADDR_VAR 0 8
89844: PUSH
89845: DOUBLE
89846: LD_INT 1
89848: DEC
89849: ST_TO_ADDR
89850: LD_VAR 0 9
89854: PUSH
89855: FOR_TO
89856: IFFALSE 89954
// if GetType ( tmp [ j ] ) = unit_human and ( ( GetLives ( tmp [ j ] ) < 250 and f_murder ) or ( not f_murder and GetLives ( tmp [ j ] ) >= 250 ) ) then
89858: LD_VAR 0 14
89862: PUSH
89863: LD_VAR 0 8
89867: ARRAY
89868: PPUSH
89869: CALL_OW 247
89873: PUSH
89874: LD_INT 1
89876: EQUAL
89877: PUSH
89878: LD_VAR 0 14
89882: PUSH
89883: LD_VAR 0 8
89887: ARRAY
89888: PPUSH
89889: CALL_OW 256
89893: PUSH
89894: LD_INT 250
89896: LESS
89897: PUSH
89898: LD_VAR 0 20
89902: AND
89903: PUSH
89904: LD_VAR 0 20
89908: NOT
89909: PUSH
89910: LD_VAR 0 14
89914: PUSH
89915: LD_VAR 0 8
89919: ARRAY
89920: PPUSH
89921: CALL_OW 256
89925: PUSH
89926: LD_INT 250
89928: GREATEREQUAL
89929: AND
89930: OR
89931: AND
89932: IFFALSE 89952
// begin x := tmp [ j ] ;
89934: LD_ADDR_VAR 0 10
89938: PUSH
89939: LD_VAR 0 14
89943: PUSH
89944: LD_VAR 0 8
89948: ARRAY
89949: ST_TO_ADDR
// break ;
89950: GO 89954
// end ;
89952: GO 89855
89954: POP
89955: POP
// if x then
89956: LD_VAR 0 10
89960: IFFALSE 89984
// ComAttackUnit ( group [ i ] , x ) else
89962: LD_VAR 0 4
89966: PUSH
89967: LD_VAR 0 7
89971: ARRAY
89972: PPUSH
89973: LD_VAR 0 10
89977: PPUSH
89978: CALL_OW 115
89982: GO 90008
// ComAttackUnit ( group [ i ] , tmp [ 1 ] ) ;
89984: LD_VAR 0 4
89988: PUSH
89989: LD_VAR 0 7
89993: ARRAY
89994: PPUSH
89995: LD_VAR 0 14
89999: PUSH
90000: LD_INT 1
90002: ARRAY
90003: PPUSH
90004: CALL_OW 115
// if not HasTask ( group [ i ] ) then
90008: LD_VAR 0 4
90012: PUSH
90013: LD_VAR 0 7
90017: ARRAY
90018: PPUSH
90019: CALL_OW 314
90023: NOT
90024: IFFALSE 90062
// ComAttackUnit ( group [ i ] , NearestUnitToUnit ( tmp , group [ i ] ) ) ;
90026: LD_VAR 0 4
90030: PUSH
90031: LD_VAR 0 7
90035: ARRAY
90036: PPUSH
90037: LD_VAR 0 14
90041: PPUSH
90042: LD_VAR 0 4
90046: PUSH
90047: LD_VAR 0 7
90051: ARRAY
90052: PPUSH
90053: CALL_OW 74
90057: PPUSH
90058: CALL_OW 115
// end ; end ; end ;
90062: GO 85967
90064: POP
90065: POP
// wait ( 0 0$1 ) ;
90066: LD_INT 35
90068: PPUSH
90069: CALL_OW 67
// until group = [ ] or not FilterAllUnits ( [ f_enemy , side ] ) ;
90073: LD_VAR 0 4
90077: PUSH
90078: EMPTY
90079: EQUAL
90080: PUSH
90081: LD_INT 81
90083: PUSH
90084: LD_VAR 0 35
90088: PUSH
90089: EMPTY
90090: LIST
90091: LIST
90092: PPUSH
90093: CALL_OW 69
90097: NOT
90098: OR
90099: IFFALSE 85952
// end ;
90101: LD_VAR 0 2
90105: RET
// export function _ScanBase ( base_units ) ; var i , t , tmp ; begin
90106: LD_INT 0
90108: PPUSH
90109: PPUSH
90110: PPUSH
90111: PPUSH
// if not base_units then
90112: LD_VAR 0 1
90116: NOT
90117: IFFALSE 90121
// exit ;
90119: GO 90208
// result := false ;
90121: LD_ADDR_VAR 0 2
90125: PUSH
90126: LD_INT 0
90128: ST_TO_ADDR
// tmp := UnitFilter ( base_units , [ f_type , unit_building ] ) ;
90129: LD_ADDR_VAR 0 5
90133: PUSH
90134: LD_VAR 0 1
90138: PPUSH
90139: LD_INT 21
90141: PUSH
90142: LD_INT 3
90144: PUSH
90145: EMPTY
90146: LIST
90147: LIST
90148: PPUSH
90149: CALL_OW 72
90153: ST_TO_ADDR
// if not tmp then
90154: LD_VAR 0 5
90158: NOT
90159: IFFALSE 90163
// exit ;
90161: GO 90208
// for i in tmp do
90163: LD_ADDR_VAR 0 3
90167: PUSH
90168: LD_VAR 0 5
90172: PUSH
90173: FOR_IN
90174: IFFALSE 90206
// begin result := EnemyInRange ( i , 22 ) ;
90176: LD_ADDR_VAR 0 2
90180: PUSH
90181: LD_VAR 0 3
90185: PPUSH
90186: LD_INT 22
90188: PPUSH
90189: CALL 83745 0 2
90193: ST_TO_ADDR
// if result then
90194: LD_VAR 0 2
90198: IFFALSE 90204
// exit ;
90200: POP
90201: POP
90202: GO 90208
// end ;
90204: GO 90173
90206: POP
90207: POP
// end ;
90208: LD_VAR 0 2
90212: RET
// export function FilterByTag ( units , tag ) ; var i ; begin
90213: LD_INT 0
90215: PPUSH
90216: PPUSH
// if not units then
90217: LD_VAR 0 1
90221: NOT
90222: IFFALSE 90226
// exit ;
90224: GO 90296
// result := [ ] ;
90226: LD_ADDR_VAR 0 3
90230: PUSH
90231: EMPTY
90232: ST_TO_ADDR
// for i in units do
90233: LD_ADDR_VAR 0 4
90237: PUSH
90238: LD_VAR 0 1
90242: PUSH
90243: FOR_IN
90244: IFFALSE 90294
// if GetTag ( i ) = tag then
90246: LD_VAR 0 4
90250: PPUSH
90251: CALL_OW 110
90255: PUSH
90256: LD_VAR 0 2
90260: EQUAL
90261: IFFALSE 90292
// result := Insert ( result , result + 1 , i ) ;
90263: LD_ADDR_VAR 0 3
90267: PUSH
90268: LD_VAR 0 3
90272: PPUSH
90273: LD_VAR 0 3
90277: PUSH
90278: LD_INT 1
90280: PLUS
90281: PPUSH
90282: LD_VAR 0 4
90286: PPUSH
90287: CALL_OW 2
90291: ST_TO_ADDR
90292: GO 90243
90294: POP
90295: POP
// end ;
90296: LD_VAR 0 3
90300: RET
// export function IsDriver ( un ) ; begin
90301: LD_INT 0
90303: PPUSH
// result := un in FilterAllUnits ( [ f_driving ] ) ;
90304: LD_ADDR_VAR 0 2
90308: PUSH
90309: LD_VAR 0 1
90313: PUSH
90314: LD_INT 55
90316: PUSH
90317: EMPTY
90318: LIST
90319: PPUSH
90320: CALL_OW 69
90324: IN
90325: ST_TO_ADDR
// end ;
90326: LD_VAR 0 2
90330: RET
// export function GetFacExtXYD ( x , y , d ) ; var list ; begin
90331: LD_INT 0
90333: PPUSH
90334: PPUSH
// list := [ ] ;
90335: LD_ADDR_VAR 0 5
90339: PUSH
90340: EMPTY
90341: ST_TO_ADDR
// case d of 0 :
90342: LD_VAR 0 3
90346: PUSH
90347: LD_INT 0
90349: DOUBLE
90350: EQUAL
90351: IFTRUE 90355
90353: GO 90488
90355: POP
// begin list := [ [ x - 4 , y - 4 , 2 ] , [ x - 3 , y , 1 ] , [ x + 4 , y , 4 ] , [ x + 3 , y + 3 , 5 ] , [ x , y + 4 , 0 ] ] ;
90356: LD_ADDR_VAR 0 5
90360: PUSH
90361: LD_VAR 0 1
90365: PUSH
90366: LD_INT 4
90368: MINUS
90369: PUSH
90370: LD_VAR 0 2
90374: PUSH
90375: LD_INT 4
90377: MINUS
90378: PUSH
90379: LD_INT 2
90381: PUSH
90382: EMPTY
90383: LIST
90384: LIST
90385: LIST
90386: PUSH
90387: LD_VAR 0 1
90391: PUSH
90392: LD_INT 3
90394: MINUS
90395: PUSH
90396: LD_VAR 0 2
90400: PUSH
90401: LD_INT 1
90403: PUSH
90404: EMPTY
90405: LIST
90406: LIST
90407: LIST
90408: PUSH
90409: LD_VAR 0 1
90413: PUSH
90414: LD_INT 4
90416: PLUS
90417: PUSH
90418: LD_VAR 0 2
90422: PUSH
90423: LD_INT 4
90425: PUSH
90426: EMPTY
90427: LIST
90428: LIST
90429: LIST
90430: PUSH
90431: LD_VAR 0 1
90435: PUSH
90436: LD_INT 3
90438: PLUS
90439: PUSH
90440: LD_VAR 0 2
90444: PUSH
90445: LD_INT 3
90447: PLUS
90448: PUSH
90449: LD_INT 5
90451: PUSH
90452: EMPTY
90453: LIST
90454: LIST
90455: LIST
90456: PUSH
90457: LD_VAR 0 1
90461: PUSH
90462: LD_VAR 0 2
90466: PUSH
90467: LD_INT 4
90469: PLUS
90470: PUSH
90471: LD_INT 0
90473: PUSH
90474: EMPTY
90475: LIST
90476: LIST
90477: LIST
90478: PUSH
90479: EMPTY
90480: LIST
90481: LIST
90482: LIST
90483: LIST
90484: LIST
90485: ST_TO_ADDR
// end ; 1 :
90486: GO 91186
90488: LD_INT 1
90490: DOUBLE
90491: EQUAL
90492: IFTRUE 90496
90494: GO 90629
90496: POP
// begin list := [ [ x , y - 4 , 3 ] , [ x - 3 , y - 3 , 2 ] , [ x - 4 , y , 1 ] , [ x , y + 3 , 0 ] , [ x + 4 , y + 4 , 5 ] ] ;
90497: LD_ADDR_VAR 0 5
90501: PUSH
90502: LD_VAR 0 1
90506: PUSH
90507: LD_VAR 0 2
90511: PUSH
90512: LD_INT 4
90514: MINUS
90515: PUSH
90516: LD_INT 3
90518: PUSH
90519: EMPTY
90520: LIST
90521: LIST
90522: LIST
90523: PUSH
90524: LD_VAR 0 1
90528: PUSH
90529: LD_INT 3
90531: MINUS
90532: PUSH
90533: LD_VAR 0 2
90537: PUSH
90538: LD_INT 3
90540: MINUS
90541: PUSH
90542: LD_INT 2
90544: PUSH
90545: EMPTY
90546: LIST
90547: LIST
90548: LIST
90549: PUSH
90550: LD_VAR 0 1
90554: PUSH
90555: LD_INT 4
90557: MINUS
90558: PUSH
90559: LD_VAR 0 2
90563: PUSH
90564: LD_INT 1
90566: PUSH
90567: EMPTY
90568: LIST
90569: LIST
90570: LIST
90571: PUSH
90572: LD_VAR 0 1
90576: PUSH
90577: LD_VAR 0 2
90581: PUSH
90582: LD_INT 3
90584: PLUS
90585: PUSH
90586: LD_INT 0
90588: PUSH
90589: EMPTY
90590: LIST
90591: LIST
90592: LIST
90593: PUSH
90594: LD_VAR 0 1
90598: PUSH
90599: LD_INT 4
90601: PLUS
90602: PUSH
90603: LD_VAR 0 2
90607: PUSH
90608: LD_INT 4
90610: PLUS
90611: PUSH
90612: LD_INT 5
90614: PUSH
90615: EMPTY
90616: LIST
90617: LIST
90618: LIST
90619: PUSH
90620: EMPTY
90621: LIST
90622: LIST
90623: LIST
90624: LIST
90625: LIST
90626: ST_TO_ADDR
// end ; 2 :
90627: GO 91186
90629: LD_INT 2
90631: DOUBLE
90632: EQUAL
90633: IFTRUE 90637
90635: GO 90766
90637: POP
// begin list := [ [ x , y - 3 , 3 ] , [ x + 4 , y , 4 ] , [ x , y + 4 , 0 ] , [ x - 3 , y , 1 ] , [ x - 4 , y - 4 , 2 ] ] ;
90638: LD_ADDR_VAR 0 5
90642: PUSH
90643: LD_VAR 0 1
90647: PUSH
90648: LD_VAR 0 2
90652: PUSH
90653: LD_INT 3
90655: MINUS
90656: PUSH
90657: LD_INT 3
90659: PUSH
90660: EMPTY
90661: LIST
90662: LIST
90663: LIST
90664: PUSH
90665: LD_VAR 0 1
90669: PUSH
90670: LD_INT 4
90672: PLUS
90673: PUSH
90674: LD_VAR 0 2
90678: PUSH
90679: LD_INT 4
90681: PUSH
90682: EMPTY
90683: LIST
90684: LIST
90685: LIST
90686: PUSH
90687: LD_VAR 0 1
90691: PUSH
90692: LD_VAR 0 2
90696: PUSH
90697: LD_INT 4
90699: PLUS
90700: PUSH
90701: LD_INT 0
90703: PUSH
90704: EMPTY
90705: LIST
90706: LIST
90707: LIST
90708: PUSH
90709: LD_VAR 0 1
90713: PUSH
90714: LD_INT 3
90716: MINUS
90717: PUSH
90718: LD_VAR 0 2
90722: PUSH
90723: LD_INT 1
90725: PUSH
90726: EMPTY
90727: LIST
90728: LIST
90729: LIST
90730: PUSH
90731: LD_VAR 0 1
90735: PUSH
90736: LD_INT 4
90738: MINUS
90739: PUSH
90740: LD_VAR 0 2
90744: PUSH
90745: LD_INT 4
90747: MINUS
90748: PUSH
90749: LD_INT 2
90751: PUSH
90752: EMPTY
90753: LIST
90754: LIST
90755: LIST
90756: PUSH
90757: EMPTY
90758: LIST
90759: LIST
90760: LIST
90761: LIST
90762: LIST
90763: ST_TO_ADDR
// end ; 3 :
90764: GO 91186
90766: LD_INT 3
90768: DOUBLE
90769: EQUAL
90770: IFTRUE 90774
90772: GO 90907
90774: POP
// begin list := [ [ x + 3 , y , 4 ] , [ x + 4 , y + 4 , 5 ] , [ x - 4 , y , 1 ] , [ x , y - 4 , 3 ] , [ x - 3 , y - 3 , 2 ] ] ;
90775: LD_ADDR_VAR 0 5
90779: PUSH
90780: LD_VAR 0 1
90784: PUSH
90785: LD_INT 3
90787: PLUS
90788: PUSH
90789: LD_VAR 0 2
90793: PUSH
90794: LD_INT 4
90796: PUSH
90797: EMPTY
90798: LIST
90799: LIST
90800: LIST
90801: PUSH
90802: LD_VAR 0 1
90806: PUSH
90807: LD_INT 4
90809: PLUS
90810: PUSH
90811: LD_VAR 0 2
90815: PUSH
90816: LD_INT 4
90818: PLUS
90819: PUSH
90820: LD_INT 5
90822: PUSH
90823: EMPTY
90824: LIST
90825: LIST
90826: LIST
90827: PUSH
90828: LD_VAR 0 1
90832: PUSH
90833: LD_INT 4
90835: MINUS
90836: PUSH
90837: LD_VAR 0 2
90841: PUSH
90842: LD_INT 1
90844: PUSH
90845: EMPTY
90846: LIST
90847: LIST
90848: LIST
90849: PUSH
90850: LD_VAR 0 1
90854: PUSH
90855: LD_VAR 0 2
90859: PUSH
90860: LD_INT 4
90862: MINUS
90863: PUSH
90864: LD_INT 3
90866: PUSH
90867: EMPTY
90868: LIST
90869: LIST
90870: LIST
90871: PUSH
90872: LD_VAR 0 1
90876: PUSH
90877: LD_INT 3
90879: MINUS
90880: PUSH
90881: LD_VAR 0 2
90885: PUSH
90886: LD_INT 3
90888: MINUS
90889: PUSH
90890: LD_INT 2
90892: PUSH
90893: EMPTY
90894: LIST
90895: LIST
90896: LIST
90897: PUSH
90898: EMPTY
90899: LIST
90900: LIST
90901: LIST
90902: LIST
90903: LIST
90904: ST_TO_ADDR
// end ; 4 :
90905: GO 91186
90907: LD_INT 4
90909: DOUBLE
90910: EQUAL
90911: IFTRUE 90915
90913: GO 91048
90915: POP
// begin list := [ [ x , y + 4 , 0 ] , [ x + 3 , y + 3 , 5 ] , [ x + 4 , y , 4 ] , [ x , y - 3 , 3 ] , [ x - 4 , y - 4 , 2 ] ] ;
90916: LD_ADDR_VAR 0 5
90920: PUSH
90921: LD_VAR 0 1
90925: PUSH
90926: LD_VAR 0 2
90930: PUSH
90931: LD_INT 4
90933: PLUS
90934: PUSH
90935: LD_INT 0
90937: PUSH
90938: EMPTY
90939: LIST
90940: LIST
90941: LIST
90942: PUSH
90943: LD_VAR 0 1
90947: PUSH
90948: LD_INT 3
90950: PLUS
90951: PUSH
90952: LD_VAR 0 2
90956: PUSH
90957: LD_INT 3
90959: PLUS
90960: PUSH
90961: LD_INT 5
90963: PUSH
90964: EMPTY
90965: LIST
90966: LIST
90967: LIST
90968: PUSH
90969: LD_VAR 0 1
90973: PUSH
90974: LD_INT 4
90976: PLUS
90977: PUSH
90978: LD_VAR 0 2
90982: PUSH
90983: LD_INT 4
90985: PUSH
90986: EMPTY
90987: LIST
90988: LIST
90989: LIST
90990: PUSH
90991: LD_VAR 0 1
90995: PUSH
90996: LD_VAR 0 2
91000: PUSH
91001: LD_INT 3
91003: MINUS
91004: PUSH
91005: LD_INT 3
91007: PUSH
91008: EMPTY
91009: LIST
91010: LIST
91011: LIST
91012: PUSH
91013: LD_VAR 0 1
91017: PUSH
91018: LD_INT 4
91020: MINUS
91021: PUSH
91022: LD_VAR 0 2
91026: PUSH
91027: LD_INT 4
91029: MINUS
91030: PUSH
91031: LD_INT 2
91033: PUSH
91034: EMPTY
91035: LIST
91036: LIST
91037: LIST
91038: PUSH
91039: EMPTY
91040: LIST
91041: LIST
91042: LIST
91043: LIST
91044: LIST
91045: ST_TO_ADDR
// end ; 5 :
91046: GO 91186
91048: LD_INT 5
91050: DOUBLE
91051: EQUAL
91052: IFTRUE 91056
91054: GO 91185
91056: POP
// begin list := [ [ x - 4 , y , 1 ] , [ x , y - 4 , 3 ] , [ x + 4 , y + 4 , 5 ] , [ x + 3 , y , 4 ] , [ x , y + 3 , 0 ] ] ;
91057: LD_ADDR_VAR 0 5
91061: PUSH
91062: LD_VAR 0 1
91066: PUSH
91067: LD_INT 4
91069: MINUS
91070: PUSH
91071: LD_VAR 0 2
91075: PUSH
91076: LD_INT 1
91078: PUSH
91079: EMPTY
91080: LIST
91081: LIST
91082: LIST
91083: PUSH
91084: LD_VAR 0 1
91088: PUSH
91089: LD_VAR 0 2
91093: PUSH
91094: LD_INT 4
91096: MINUS
91097: PUSH
91098: LD_INT 3
91100: PUSH
91101: EMPTY
91102: LIST
91103: LIST
91104: LIST
91105: PUSH
91106: LD_VAR 0 1
91110: PUSH
91111: LD_INT 4
91113: PLUS
91114: PUSH
91115: LD_VAR 0 2
91119: PUSH
91120: LD_INT 4
91122: PLUS
91123: PUSH
91124: LD_INT 5
91126: PUSH
91127: EMPTY
91128: LIST
91129: LIST
91130: LIST
91131: PUSH
91132: LD_VAR 0 1
91136: PUSH
91137: LD_INT 3
91139: PLUS
91140: PUSH
91141: LD_VAR 0 2
91145: PUSH
91146: LD_INT 4
91148: PUSH
91149: EMPTY
91150: LIST
91151: LIST
91152: LIST
91153: PUSH
91154: LD_VAR 0 1
91158: PUSH
91159: LD_VAR 0 2
91163: PUSH
91164: LD_INT 3
91166: PLUS
91167: PUSH
91168: LD_INT 0
91170: PUSH
91171: EMPTY
91172: LIST
91173: LIST
91174: LIST
91175: PUSH
91176: EMPTY
91177: LIST
91178: LIST
91179: LIST
91180: LIST
91181: LIST
91182: ST_TO_ADDR
// end ; end ;
91183: GO 91186
91185: POP
// result := list ;
91186: LD_ADDR_VAR 0 4
91190: PUSH
91191: LD_VAR 0 5
91195: ST_TO_ADDR
// end ;
91196: LD_VAR 0 4
91200: RET
// export function SortBySkill ( units , class ) ; var i , tmp ; begin
91201: LD_INT 0
91203: PPUSH
91204: PPUSH
91205: PPUSH
// if not units or not class in [ 1 , 2 , 3 , 4 ] then
91206: LD_VAR 0 1
91210: NOT
91211: PUSH
91212: LD_VAR 0 2
91216: PUSH
91217: LD_INT 1
91219: PUSH
91220: LD_INT 2
91222: PUSH
91223: LD_INT 3
91225: PUSH
91226: LD_INT 4
91228: PUSH
91229: EMPTY
91230: LIST
91231: LIST
91232: LIST
91233: LIST
91234: IN
91235: NOT
91236: OR
91237: IFFALSE 91241
// exit ;
91239: GO 91333
// tmp := [ ] ;
91241: LD_ADDR_VAR 0 5
91245: PUSH
91246: EMPTY
91247: ST_TO_ADDR
// for i in units do
91248: LD_ADDR_VAR 0 4
91252: PUSH
91253: LD_VAR 0 1
91257: PUSH
91258: FOR_IN
91259: IFFALSE 91302
// tmp := Insert ( tmp , tmp + 1 , GetSkill ( i , class ) ) ;
91261: LD_ADDR_VAR 0 5
91265: PUSH
91266: LD_VAR 0 5
91270: PPUSH
91271: LD_VAR 0 5
91275: PUSH
91276: LD_INT 1
91278: PLUS
91279: PPUSH
91280: LD_VAR 0 4
91284: PPUSH
91285: LD_VAR 0 2
91289: PPUSH
91290: CALL_OW 259
91294: PPUSH
91295: CALL_OW 2
91299: ST_TO_ADDR
91300: GO 91258
91302: POP
91303: POP
// if not tmp then
91304: LD_VAR 0 5
91308: NOT
91309: IFFALSE 91313
// exit ;
91311: GO 91333
// result := SortListByListDesc ( units , tmp ) ;
91313: LD_ADDR_VAR 0 3
91317: PUSH
91318: LD_VAR 0 1
91322: PPUSH
91323: LD_VAR 0 5
91327: PPUSH
91328: CALL_OW 77
91332: ST_TO_ADDR
// end ;
91333: LD_VAR 0 3
91337: RET
// export function UnitGoingToBuilding ( unit , building ) ; var x , y ; begin
91338: LD_INT 0
91340: PPUSH
91341: PPUSH
91342: PPUSH
// x := GetX ( building ) ;
91343: LD_ADDR_VAR 0 4
91347: PUSH
91348: LD_VAR 0 2
91352: PPUSH
91353: CALL_OW 250
91357: ST_TO_ADDR
// y := GetY ( building ) ;
91358: LD_ADDR_VAR 0 5
91362: PUSH
91363: LD_VAR 0 2
91367: PPUSH
91368: CALL_OW 251
91372: ST_TO_ADDR
// if GetTaskList ( unit ) then
91373: LD_VAR 0 1
91377: PPUSH
91378: CALL_OW 437
91382: IFFALSE 91477
// begin if e = GetTaskList ( unit ) [ 1 ] [ 1 ] and x = GetTaskList ( unit ) [ 1 ] [ 2 ] and y = GetTaskList ( unit ) [ 1 ] [ 3 ] then
91384: LD_STRING e
91386: PUSH
91387: LD_VAR 0 1
91391: PPUSH
91392: CALL_OW 437
91396: PUSH
91397: LD_INT 1
91399: ARRAY
91400: PUSH
91401: LD_INT 1
91403: ARRAY
91404: EQUAL
91405: PUSH
91406: LD_VAR 0 4
91410: PUSH
91411: LD_VAR 0 1
91415: PPUSH
91416: CALL_OW 437
91420: PUSH
91421: LD_INT 1
91423: ARRAY
91424: PUSH
91425: LD_INT 2
91427: ARRAY
91428: EQUAL
91429: AND
91430: PUSH
91431: LD_VAR 0 5
91435: PUSH
91436: LD_VAR 0 1
91440: PPUSH
91441: CALL_OW 437
91445: PUSH
91446: LD_INT 1
91448: ARRAY
91449: PUSH
91450: LD_INT 3
91452: ARRAY
91453: EQUAL
91454: AND
91455: IFFALSE 91467
// result := true else
91457: LD_ADDR_VAR 0 3
91461: PUSH
91462: LD_INT 1
91464: ST_TO_ADDR
91465: GO 91475
// result := false ;
91467: LD_ADDR_VAR 0 3
91471: PUSH
91472: LD_INT 0
91474: ST_TO_ADDR
// end else
91475: GO 91485
// result := false ;
91477: LD_ADDR_VAR 0 3
91481: PUSH
91482: LD_INT 0
91484: ST_TO_ADDR
// end ;
91485: LD_VAR 0 3
91489: RET
// export function PlaceUnitInArea ( unit , area , mode ) ; var i , tmp , hex ; begin
91490: LD_INT 0
91492: PPUSH
91493: PPUSH
91494: PPUSH
91495: PPUSH
// if not unit or not area then
91496: LD_VAR 0 1
91500: NOT
91501: PUSH
91502: LD_VAR 0 2
91506: NOT
91507: OR
91508: IFFALSE 91512
// exit ;
91510: GO 91676
// tmp := AreaToList ( area , i ) ;
91512: LD_ADDR_VAR 0 6
91516: PUSH
91517: LD_VAR 0 2
91521: PPUSH
91522: LD_VAR 0 5
91526: PPUSH
91527: CALL_OW 517
91531: ST_TO_ADDR
// for i = 1 to tmp [ 1 ] do
91532: LD_ADDR_VAR 0 5
91536: PUSH
91537: DOUBLE
91538: LD_INT 1
91540: DEC
91541: ST_TO_ADDR
91542: LD_VAR 0 6
91546: PUSH
91547: LD_INT 1
91549: ARRAY
91550: PUSH
91551: FOR_TO
91552: IFFALSE 91674
// begin hex := [ tmp [ 1 ] [ i ] , tmp [ 2 ] [ i ] ] ;
91554: LD_ADDR_VAR 0 7
91558: PUSH
91559: LD_VAR 0 6
91563: PUSH
91564: LD_INT 1
91566: ARRAY
91567: PUSH
91568: LD_VAR 0 5
91572: ARRAY
91573: PUSH
91574: LD_VAR 0 6
91578: PUSH
91579: LD_INT 2
91581: ARRAY
91582: PUSH
91583: LD_VAR 0 5
91587: ARRAY
91588: PUSH
91589: EMPTY
91590: LIST
91591: LIST
91592: ST_TO_ADDR
// if HexInfo ( hex [ 1 ] , hex [ 2 ] ) = 0 then
91593: LD_VAR 0 7
91597: PUSH
91598: LD_INT 1
91600: ARRAY
91601: PPUSH
91602: LD_VAR 0 7
91606: PUSH
91607: LD_INT 2
91609: ARRAY
91610: PPUSH
91611: CALL_OW 428
91615: PUSH
91616: LD_INT 0
91618: EQUAL
91619: IFFALSE 91672
// begin PlaceUnitXY ( unit , hex [ 1 ] , hex [ 2 ] , mode ) ;
91621: LD_VAR 0 1
91625: PPUSH
91626: LD_VAR 0 7
91630: PUSH
91631: LD_INT 1
91633: ARRAY
91634: PPUSH
91635: LD_VAR 0 7
91639: PUSH
91640: LD_INT 2
91642: ARRAY
91643: PPUSH
91644: LD_VAR 0 3
91648: PPUSH
91649: CALL_OW 48
// result := IsPlaced ( unit ) ;
91653: LD_ADDR_VAR 0 4
91657: PUSH
91658: LD_VAR 0 1
91662: PPUSH
91663: CALL_OW 305
91667: ST_TO_ADDR
// exit ;
91668: POP
91669: POP
91670: GO 91676
// end ; end ;
91672: GO 91551
91674: POP
91675: POP
// end ;
91676: LD_VAR 0 4
91680: RET
// export function BuildingsListDump ( side ) ; var i , tmp ; begin
91681: LD_INT 0
91683: PPUSH
91684: PPUSH
91685: PPUSH
// if not side or side > 8 then
91686: LD_VAR 0 1
91690: NOT
91691: PUSH
91692: LD_VAR 0 1
91696: PUSH
91697: LD_INT 8
91699: GREATER
91700: OR
91701: IFFALSE 91705
// exit ;
91703: GO 91892
// tmp := FilterAllUnits ( [ [ f_side , side ] , [ f_type , unit_building ] ] ) ;
91705: LD_ADDR_VAR 0 4
91709: PUSH
91710: LD_INT 22
91712: PUSH
91713: LD_VAR 0 1
91717: PUSH
91718: EMPTY
91719: LIST
91720: LIST
91721: PUSH
91722: LD_INT 21
91724: PUSH
91725: LD_INT 3
91727: PUSH
91728: EMPTY
91729: LIST
91730: LIST
91731: PUSH
91732: EMPTY
91733: LIST
91734: LIST
91735: PPUSH
91736: CALL_OW 69
91740: ST_TO_ADDR
// if not tmp then
91741: LD_VAR 0 4
91745: NOT
91746: IFFALSE 91750
// exit ;
91748: GO 91892
// enable_addtolog := true ;
91750: LD_ADDR_OWVAR 81
91754: PUSH
91755: LD_INT 1
91757: ST_TO_ADDR
// AddToLog ( [ ) ;
91758: LD_STRING [
91760: PPUSH
91761: CALL_OW 561
// for i in tmp do
91765: LD_ADDR_VAR 0 3
91769: PUSH
91770: LD_VAR 0 4
91774: PUSH
91775: FOR_IN
91776: IFFALSE 91883
// begin AddToLog ( [ & GetBType ( i ) & ,  & GetX ( i ) & ,  & GetY ( i ) & ,  & GetDir ( i ) & ,  & GetLabKind ( i , 1 ) & ,  & GetLabKind ( i , 2 ) & ], ) ;
91778: LD_STRING [
91780: PUSH
91781: LD_VAR 0 3
91785: PPUSH
91786: CALL_OW 266
91790: STR
91791: PUSH
91792: LD_STRING , 
91794: STR
91795: PUSH
91796: LD_VAR 0 3
91800: PPUSH
91801: CALL_OW 250
91805: STR
91806: PUSH
91807: LD_STRING , 
91809: STR
91810: PUSH
91811: LD_VAR 0 3
91815: PPUSH
91816: CALL_OW 251
91820: STR
91821: PUSH
91822: LD_STRING , 
91824: STR
91825: PUSH
91826: LD_VAR 0 3
91830: PPUSH
91831: CALL_OW 254
91835: STR
91836: PUSH
91837: LD_STRING , 
91839: STR
91840: PUSH
91841: LD_VAR 0 3
91845: PPUSH
91846: LD_INT 1
91848: PPUSH
91849: CALL_OW 268
91853: STR
91854: PUSH
91855: LD_STRING , 
91857: STR
91858: PUSH
91859: LD_VAR 0 3
91863: PPUSH
91864: LD_INT 2
91866: PPUSH
91867: CALL_OW 268
91871: STR
91872: PUSH
91873: LD_STRING ],
91875: STR
91876: PPUSH
91877: CALL_OW 561
// end ;
91881: GO 91775
91883: POP
91884: POP
// AddToLog ( ]; ) ;
91885: LD_STRING ];
91887: PPUSH
91888: CALL_OW 561
// end ;
91892: LD_VAR 0 2
91896: RET
// export function Crates ( area , rate , min , max ) ; var i , r , time , amount ; begin
91897: LD_INT 0
91899: PPUSH
91900: PPUSH
91901: PPUSH
91902: PPUSH
91903: PPUSH
// if not area or not rate or not max then
91904: LD_VAR 0 1
91908: NOT
91909: PUSH
91910: LD_VAR 0 2
91914: NOT
91915: OR
91916: PUSH
91917: LD_VAR 0 4
91921: NOT
91922: OR
91923: IFFALSE 91927
// exit ;
91925: GO 92119
// while 1 do
91927: LD_INT 1
91929: IFFALSE 92119
// begin amount := GetResourceArea ( area , mat_cans ) * 10 ;
91931: LD_ADDR_VAR 0 9
91935: PUSH
91936: LD_VAR 0 1
91940: PPUSH
91941: LD_INT 1
91943: PPUSH
91944: CALL_OW 287
91948: PUSH
91949: LD_INT 10
91951: MUL
91952: ST_TO_ADDR
// r := rate / 10 ;
91953: LD_ADDR_VAR 0 7
91957: PUSH
91958: LD_VAR 0 2
91962: PUSH
91963: LD_INT 10
91965: DIVREAL
91966: ST_TO_ADDR
// time := 1 1$00 ;
91967: LD_ADDR_VAR 0 8
91971: PUSH
91972: LD_INT 2100
91974: ST_TO_ADDR
// if amount < min then
91975: LD_VAR 0 9
91979: PUSH
91980: LD_VAR 0 3
91984: LESS
91985: IFFALSE 92003
// r := r * 2 else
91987: LD_ADDR_VAR 0 7
91991: PUSH
91992: LD_VAR 0 7
91996: PUSH
91997: LD_INT 2
91999: MUL
92000: ST_TO_ADDR
92001: GO 92029
// if amount > max then
92003: LD_VAR 0 9
92007: PUSH
92008: LD_VAR 0 4
92012: GREATER
92013: IFFALSE 92029
// r := r / 2 ;
92015: LD_ADDR_VAR 0 7
92019: PUSH
92020: LD_VAR 0 7
92024: PUSH
92025: LD_INT 2
92027: DIVREAL
92028: ST_TO_ADDR
// time := time / r ;
92029: LD_ADDR_VAR 0 8
92033: PUSH
92034: LD_VAR 0 8
92038: PUSH
92039: LD_VAR 0 7
92043: DIVREAL
92044: ST_TO_ADDR
// if time < 0 then
92045: LD_VAR 0 8
92049: PUSH
92050: LD_INT 0
92052: LESS
92053: IFFALSE 92070
// time := time * - 1 ;
92055: LD_ADDR_VAR 0 8
92059: PUSH
92060: LD_VAR 0 8
92064: PUSH
92065: LD_INT 1
92067: NEG
92068: MUL
92069: ST_TO_ADDR
// wait ( time ) ;
92070: LD_VAR 0 8
92074: PPUSH
92075: CALL_OW 67
// wait ( rand ( 0 0$01 , 0 0$25 ) ) ;
92079: LD_INT 35
92081: PPUSH
92082: LD_INT 875
92084: PPUSH
92085: CALL_OW 12
92089: PPUSH
92090: CALL_OW 67
// CreateCratesArea ( rand ( 1 , 5 ) , area , true ) ;
92094: LD_INT 1
92096: PPUSH
92097: LD_INT 5
92099: PPUSH
92100: CALL_OW 12
92104: PPUSH
92105: LD_VAR 0 1
92109: PPUSH
92110: LD_INT 1
92112: PPUSH
92113: CALL_OW 55
// end ;
92117: GO 91927
// end ;
92119: LD_VAR 0 5
92123: RET
// export function UpgradeTurretsWeapon ( turrets , factories ) ; var i , j , k , nat , weapon , weapons , list ; begin
92124: LD_INT 0
92126: PPUSH
92127: PPUSH
92128: PPUSH
92129: PPUSH
92130: PPUSH
92131: PPUSH
92132: PPUSH
92133: PPUSH
// if not turrets or not factories then
92134: LD_VAR 0 1
92138: NOT
92139: PUSH
92140: LD_VAR 0 2
92144: NOT
92145: OR
92146: IFFALSE 92150
// exit ;
92148: GO 92457
// list := [ [ [ us_double_gun , us_heavy_gun ] , [ us_machine_gun , us_gatling_gun ] , [ us_light_gun , us_double_gun ] ] , [ [ ar_double_machine_gun , ar_gatling_gun ] , [ ar_light_gun , ar_gun ] ] , [ [ ru_heavy_machine_gun , ru_gatling_gun ] , [ ru_gun , ru_heavy_gun ] , [ ru_rocket_launcher , ru_rocket ] ] , ] ;
92150: LD_ADDR_VAR 0 10
92154: PUSH
92155: LD_INT 5
92157: PUSH
92158: LD_INT 6
92160: PUSH
92161: EMPTY
92162: LIST
92163: LIST
92164: PUSH
92165: LD_INT 2
92167: PUSH
92168: LD_INT 4
92170: PUSH
92171: EMPTY
92172: LIST
92173: LIST
92174: PUSH
92175: LD_INT 3
92177: PUSH
92178: LD_INT 5
92180: PUSH
92181: EMPTY
92182: LIST
92183: LIST
92184: PUSH
92185: EMPTY
92186: LIST
92187: LIST
92188: LIST
92189: PUSH
92190: LD_INT 24
92192: PUSH
92193: LD_INT 25
92195: PUSH
92196: EMPTY
92197: LIST
92198: LIST
92199: PUSH
92200: LD_INT 23
92202: PUSH
92203: LD_INT 27
92205: PUSH
92206: EMPTY
92207: LIST
92208: LIST
92209: PUSH
92210: EMPTY
92211: LIST
92212: LIST
92213: PUSH
92214: LD_INT 42
92216: PUSH
92217: LD_INT 43
92219: PUSH
92220: EMPTY
92221: LIST
92222: LIST
92223: PUSH
92224: LD_INT 44
92226: PUSH
92227: LD_INT 46
92229: PUSH
92230: EMPTY
92231: LIST
92232: LIST
92233: PUSH
92234: LD_INT 45
92236: PUSH
92237: LD_INT 47
92239: PUSH
92240: EMPTY
92241: LIST
92242: LIST
92243: PUSH
92244: EMPTY
92245: LIST
92246: LIST
92247: LIST
92248: PUSH
92249: EMPTY
92250: LIST
92251: LIST
92252: LIST
92253: ST_TO_ADDR
// result := [ ] ;
92254: LD_ADDR_VAR 0 3
92258: PUSH
92259: EMPTY
92260: ST_TO_ADDR
// for i in turrets do
92261: LD_ADDR_VAR 0 4
92265: PUSH
92266: LD_VAR 0 1
92270: PUSH
92271: FOR_IN
92272: IFFALSE 92455
// begin nat := GetNation ( i ) ;
92274: LD_ADDR_VAR 0 7
92278: PUSH
92279: LD_VAR 0 4
92283: PPUSH
92284: CALL_OW 248
92288: ST_TO_ADDR
// weapon := 0 ;
92289: LD_ADDR_VAR 0 8
92293: PUSH
92294: LD_INT 0
92296: ST_TO_ADDR
// if not nat then
92297: LD_VAR 0 7
92301: NOT
92302: IFFALSE 92306
// continue ;
92304: GO 92271
// for j in list [ nat ] do
92306: LD_ADDR_VAR 0 5
92310: PUSH
92311: LD_VAR 0 10
92315: PUSH
92316: LD_VAR 0 7
92320: ARRAY
92321: PUSH
92322: FOR_IN
92323: IFFALSE 92364
// if GetBWeapon ( i ) = j [ 1 ] then
92325: LD_VAR 0 4
92329: PPUSH
92330: CALL_OW 269
92334: PUSH
92335: LD_VAR 0 5
92339: PUSH
92340: LD_INT 1
92342: ARRAY
92343: EQUAL
92344: IFFALSE 92362
// begin weapon := j [ 2 ] ;
92346: LD_ADDR_VAR 0 8
92350: PUSH
92351: LD_VAR 0 5
92355: PUSH
92356: LD_INT 2
92358: ARRAY
92359: ST_TO_ADDR
// break ;
92360: GO 92364
// end ;
92362: GO 92322
92364: POP
92365: POP
// if not weapon then
92366: LD_VAR 0 8
92370: NOT
92371: IFFALSE 92375
// continue ;
92373: GO 92271
// for k in factories do
92375: LD_ADDR_VAR 0 6
92379: PUSH
92380: LD_VAR 0 2
92384: PUSH
92385: FOR_IN
92386: IFFALSE 92451
// begin weapons := AvailableWeaponList ( k ) ;
92388: LD_ADDR_VAR 0 9
92392: PUSH
92393: LD_VAR 0 6
92397: PPUSH
92398: CALL_OW 478
92402: ST_TO_ADDR
// if not weapons then
92403: LD_VAR 0 9
92407: NOT
92408: IFFALSE 92412
// continue ;
92410: GO 92385
// if weapon in weapons then
92412: LD_VAR 0 8
92416: PUSH
92417: LD_VAR 0 9
92421: IN
92422: IFFALSE 92449
// begin result := [ i , weapon ] ;
92424: LD_ADDR_VAR 0 3
92428: PUSH
92429: LD_VAR 0 4
92433: PUSH
92434: LD_VAR 0 8
92438: PUSH
92439: EMPTY
92440: LIST
92441: LIST
92442: ST_TO_ADDR
// exit ;
92443: POP
92444: POP
92445: POP
92446: POP
92447: GO 92457
// end ; end ;
92449: GO 92385
92451: POP
92452: POP
// end ;
92453: GO 92271
92455: POP
92456: POP
// end ;
92457: LD_VAR 0 3
92461: RET
// export function RevealMapOnXY ( x , y , side , range ) ; begin
92462: LD_INT 0
92464: PPUSH
// if not side or side > 8 then
92465: LD_VAR 0 3
92469: NOT
92470: PUSH
92471: LD_VAR 0 3
92475: PUSH
92476: LD_INT 8
92478: GREATER
92479: OR
92480: IFFALSE 92484
// exit ;
92482: GO 92543
// if not range then
92484: LD_VAR 0 4
92488: NOT
92489: IFFALSE 92500
// range := - 12 ;
92491: LD_ADDR_VAR 0 4
92495: PUSH
92496: LD_INT 12
92498: NEG
92499: ST_TO_ADDR
// PlaceSeeing ( x , y , side , range ) ;
92500: LD_VAR 0 1
92504: PPUSH
92505: LD_VAR 0 2
92509: PPUSH
92510: LD_VAR 0 3
92514: PPUSH
92515: LD_VAR 0 4
92519: PPUSH
92520: CALL_OW 330
// RemoveSeeing ( x , y , side ) ;
92524: LD_VAR 0 1
92528: PPUSH
92529: LD_VAR 0 2
92533: PPUSH
92534: LD_VAR 0 3
92538: PPUSH
92539: CALL_OW 331
// end ;
92543: LD_VAR 0 5
92547: RET
// export function Video ( mode ) ; begin
92548: LD_INT 0
92550: PPUSH
// ingame_video = mode ;
92551: LD_ADDR_OWVAR 52
92555: PUSH
92556: LD_VAR 0 1
92560: ST_TO_ADDR
// interface_hidden = mode ;
92561: LD_ADDR_OWVAR 54
92565: PUSH
92566: LD_VAR 0 1
92570: ST_TO_ADDR
// end ;
92571: LD_VAR 0 2
92575: RET
// export function Join ( array , element ) ; begin
92576: LD_INT 0
92578: PPUSH
// result := array ^ element ;
92579: LD_ADDR_VAR 0 3
92583: PUSH
92584: LD_VAR 0 1
92588: PUSH
92589: LD_VAR 0 2
92593: ADD
92594: ST_TO_ADDR
// end ;
92595: LD_VAR 0 3
92599: RET
// export function JoinUnion ( array , element ) ; begin
92600: LD_INT 0
92602: PPUSH
// result := array union element ;
92603: LD_ADDR_VAR 0 3
92607: PUSH
92608: LD_VAR 0 1
92612: PUSH
92613: LD_VAR 0 2
92617: UNION
92618: ST_TO_ADDR
// end ;
92619: LD_VAR 0 3
92623: RET
// export function GetBehemoths ( side ) ; begin
92624: LD_INT 0
92626: PPUSH
// result := FilterAllUnits ( [ [ f_side , side ] , [ f_chassis , 25 ] ] ) ;
92627: LD_ADDR_VAR 0 2
92631: PUSH
92632: LD_INT 22
92634: PUSH
92635: LD_VAR 0 1
92639: PUSH
92640: EMPTY
92641: LIST
92642: LIST
92643: PUSH
92644: LD_INT 31
92646: PUSH
92647: LD_INT 25
92649: PUSH
92650: EMPTY
92651: LIST
92652: LIST
92653: PUSH
92654: EMPTY
92655: LIST
92656: LIST
92657: PPUSH
92658: CALL_OW 69
92662: ST_TO_ADDR
// end ;
92663: LD_VAR 0 2
92667: RET
// export function Shuffle ( array ) ; var i , index ; begin
92668: LD_INT 0
92670: PPUSH
92671: PPUSH
92672: PPUSH
// result := [ ] ;
92673: LD_ADDR_VAR 0 2
92677: PUSH
92678: EMPTY
92679: ST_TO_ADDR
// if not array then
92680: LD_VAR 0 1
92684: NOT
92685: IFFALSE 92689
// exit ;
92687: GO 92788
// Randomize ;
92689: CALL_OW 10
// for i = array downto 1 do
92693: LD_ADDR_VAR 0 3
92697: PUSH
92698: DOUBLE
92699: LD_VAR 0 1
92703: INC
92704: ST_TO_ADDR
92705: LD_INT 1
92707: PUSH
92708: FOR_DOWNTO
92709: IFFALSE 92786
// begin index := rand ( 1 , array ) ;
92711: LD_ADDR_VAR 0 4
92715: PUSH
92716: LD_INT 1
92718: PPUSH
92719: LD_VAR 0 1
92723: PPUSH
92724: CALL_OW 12
92728: ST_TO_ADDR
// result := Insert ( result , result + 1 , array [ index ] ) ;
92729: LD_ADDR_VAR 0 2
92733: PUSH
92734: LD_VAR 0 2
92738: PPUSH
92739: LD_VAR 0 2
92743: PUSH
92744: LD_INT 1
92746: PLUS
92747: PPUSH
92748: LD_VAR 0 1
92752: PUSH
92753: LD_VAR 0 4
92757: ARRAY
92758: PPUSH
92759: CALL_OW 2
92763: ST_TO_ADDR
// array := Delete ( array , index ) ;
92764: LD_ADDR_VAR 0 1
92768: PUSH
92769: LD_VAR 0 1
92773: PPUSH
92774: LD_VAR 0 4
92778: PPUSH
92779: CALL_OW 3
92783: ST_TO_ADDR
// end ;
92784: GO 92708
92786: POP
92787: POP
// end ;
92788: LD_VAR 0 2
92792: RET
// export function GetBaseMaterials ( base ) ; begin
92793: LD_INT 0
92795: PPUSH
// result := [ 0 , 0 , 0 ] ;
92796: LD_ADDR_VAR 0 2
92800: PUSH
92801: LD_INT 0
92803: PUSH
92804: LD_INT 0
92806: PUSH
92807: LD_INT 0
92809: PUSH
92810: EMPTY
92811: LIST
92812: LIST
92813: LIST
92814: ST_TO_ADDR
// if not base then
92815: LD_VAR 0 1
92819: NOT
92820: IFFALSE 92824
// exit ;
92822: GO 92873
// result := [ GetResourceType ( base , mat_cans ) , GetResourceType ( base , mat_oil ) , GetResourceType ( base , mat_siberit ) ] ;
92824: LD_ADDR_VAR 0 2
92828: PUSH
92829: LD_VAR 0 1
92833: PPUSH
92834: LD_INT 1
92836: PPUSH
92837: CALL_OW 275
92841: PUSH
92842: LD_VAR 0 1
92846: PPUSH
92847: LD_INT 2
92849: PPUSH
92850: CALL_OW 275
92854: PUSH
92855: LD_VAR 0 1
92859: PPUSH
92860: LD_INT 3
92862: PPUSH
92863: CALL_OW 275
92867: PUSH
92868: EMPTY
92869: LIST
92870: LIST
92871: LIST
92872: ST_TO_ADDR
// end ; end_of_file end_of_file end_of_file
92873: LD_VAR 0 2
92877: RET
// export function SOS_UnitExtraDestroyed ( un , killerSide , killerUnit ) ; var i , eff , side ; begin
92878: LD_INT 0
92880: PPUSH
92881: PPUSH
92882: PPUSH
92883: PPUSH
// if GetWeapon ( un ) = ar_bio_bomb then
92884: LD_VAR 0 1
92888: PPUSH
92889: CALL_OW 264
92893: PUSH
92894: LD_EXP 71
92898: EQUAL
92899: IFFALSE 92971
// begin if GetTech ( tech_bio3 , GetSide ( un ) ) = state_researched then
92901: LD_INT 68
92903: PPUSH
92904: LD_VAR 0 1
92908: PPUSH
92909: CALL_OW 255
92913: PPUSH
92914: CALL_OW 321
92918: PUSH
92919: LD_INT 2
92921: EQUAL
92922: IFFALSE 92934
// eff := 70 else
92924: LD_ADDR_VAR 0 6
92928: PUSH
92929: LD_INT 70
92931: ST_TO_ADDR
92932: GO 92942
// eff := 30 ;
92934: LD_ADDR_VAR 0 6
92938: PUSH
92939: LD_INT 30
92941: ST_TO_ADDR
// ArtContamination ( GetX ( un ) , GetY ( un ) , eff ) ;
92942: LD_VAR 0 1
92946: PPUSH
92947: CALL_OW 250
92951: PPUSH
92952: LD_VAR 0 1
92956: PPUSH
92957: CALL_OW 251
92961: PPUSH
92962: LD_VAR 0 6
92966: PPUSH
92967: CALL_OW 495
// end ; end ;
92971: LD_VAR 0 4
92975: RET
// export function SOS_Command ( cmd ) ; var i , j , tmp , taskList , _taskList ; begin
92976: LD_INT 0
92978: PPUSH
92979: PPUSH
92980: PPUSH
92981: PPUSH
92982: PPUSH
92983: PPUSH
// if cmd = 124 then
92984: LD_VAR 0 1
92988: PUSH
92989: LD_INT 124
92991: EQUAL
92992: IFFALSE 93198
// begin tmp := FilterAllUnits ( [ f_or , [ f_weapon , ru_bulldozer ] , [ f_weapon , us_bulldozer ] ] ) ;
92994: LD_ADDR_VAR 0 5
92998: PUSH
92999: LD_INT 2
93001: PUSH
93002: LD_INT 34
93004: PUSH
93005: LD_INT 53
93007: PUSH
93008: EMPTY
93009: LIST
93010: LIST
93011: PUSH
93012: LD_INT 34
93014: PUSH
93015: LD_INT 14
93017: PUSH
93018: EMPTY
93019: LIST
93020: LIST
93021: PUSH
93022: EMPTY
93023: LIST
93024: LIST
93025: LIST
93026: PPUSH
93027: CALL_OW 69
93031: ST_TO_ADDR
// if not tmp then
93032: LD_VAR 0 5
93036: NOT
93037: IFFALSE 93041
// exit ;
93039: GO 93198
// for i in tmp do
93041: LD_ADDR_VAR 0 3
93045: PUSH
93046: LD_VAR 0 5
93050: PUSH
93051: FOR_IN
93052: IFFALSE 93196
// begin taskList := GetTaskList ( i ) ;
93054: LD_ADDR_VAR 0 6
93058: PUSH
93059: LD_VAR 0 3
93063: PPUSH
93064: CALL_OW 437
93068: ST_TO_ADDR
// if not taskList then
93069: LD_VAR 0 6
93073: NOT
93074: IFFALSE 93078
// continue ;
93076: GO 93051
// for j = 1 to taskList do
93078: LD_ADDR_VAR 0 4
93082: PUSH
93083: DOUBLE
93084: LD_INT 1
93086: DEC
93087: ST_TO_ADDR
93088: LD_VAR 0 6
93092: PUSH
93093: FOR_TO
93094: IFFALSE 93192
// if taskList [ j ] [ 1 ] = | then
93096: LD_VAR 0 6
93100: PUSH
93101: LD_VAR 0 4
93105: ARRAY
93106: PUSH
93107: LD_INT 1
93109: ARRAY
93110: PUSH
93111: LD_STRING |
93113: EQUAL
93114: IFFALSE 93190
// begin _taskList := Delete ( taskList , 1 ) ;
93116: LD_ADDR_VAR 0 7
93120: PUSH
93121: LD_VAR 0 6
93125: PPUSH
93126: LD_INT 1
93128: PPUSH
93129: CALL_OW 3
93133: ST_TO_ADDR
// SetTaskList ( i , _taskList ) ;
93134: LD_VAR 0 3
93138: PPUSH
93139: LD_VAR 0 7
93143: PPUSH
93144: CALL_OW 446
// CutTreeXYR ( i , taskList [ j ] [ 2 ] , taskList [ j ] [ 3 ] , 8 ) ;
93148: LD_VAR 0 3
93152: PPUSH
93153: LD_VAR 0 6
93157: PUSH
93158: LD_VAR 0 4
93162: ARRAY
93163: PUSH
93164: LD_INT 2
93166: ARRAY
93167: PPUSH
93168: LD_VAR 0 6
93172: PUSH
93173: LD_VAR 0 4
93177: ARRAY
93178: PUSH
93179: LD_INT 3
93181: ARRAY
93182: PPUSH
93183: LD_INT 8
93185: PPUSH
93186: CALL 93203 0 4
// end ;
93190: GO 93093
93192: POP
93193: POP
// end ;
93194: GO 93051
93196: POP
93197: POP
// end ; end ;
93198: LD_VAR 0 2
93202: RET
// function CutTreeXYR ( bulldozer , x , y , r ) ; var i , min_x , min_y , max_x , max_y , _x , _y , list ; begin
93203: LD_INT 0
93205: PPUSH
93206: PPUSH
93207: PPUSH
93208: PPUSH
93209: PPUSH
93210: PPUSH
93211: PPUSH
93212: PPUSH
93213: PPUSH
// if not bulldozer or not ValidHex ( x , y ) or not r then
93214: LD_VAR 0 1
93218: NOT
93219: PUSH
93220: LD_VAR 0 2
93224: PPUSH
93225: LD_VAR 0 3
93229: PPUSH
93230: CALL_OW 488
93234: NOT
93235: OR
93236: PUSH
93237: LD_VAR 0 4
93241: NOT
93242: OR
93243: IFFALSE 93247
// exit ;
93245: GO 93587
// list := [ ] ;
93247: LD_ADDR_VAR 0 13
93251: PUSH
93252: EMPTY
93253: ST_TO_ADDR
// if x - r < 0 then
93254: LD_VAR 0 2
93258: PUSH
93259: LD_VAR 0 4
93263: MINUS
93264: PUSH
93265: LD_INT 0
93267: LESS
93268: IFFALSE 93280
// min_x := 0 else
93270: LD_ADDR_VAR 0 7
93274: PUSH
93275: LD_INT 0
93277: ST_TO_ADDR
93278: GO 93296
// min_x := x - r ;
93280: LD_ADDR_VAR 0 7
93284: PUSH
93285: LD_VAR 0 2
93289: PUSH
93290: LD_VAR 0 4
93294: MINUS
93295: ST_TO_ADDR
// if y - r < 0 then
93296: LD_VAR 0 3
93300: PUSH
93301: LD_VAR 0 4
93305: MINUS
93306: PUSH
93307: LD_INT 0
93309: LESS
93310: IFFALSE 93322
// min_y := 0 else
93312: LD_ADDR_VAR 0 8
93316: PUSH
93317: LD_INT 0
93319: ST_TO_ADDR
93320: GO 93338
// min_y := y - r ;
93322: LD_ADDR_VAR 0 8
93326: PUSH
93327: LD_VAR 0 3
93331: PUSH
93332: LD_VAR 0 4
93336: MINUS
93337: ST_TO_ADDR
// max_x := x + r ;
93338: LD_ADDR_VAR 0 9
93342: PUSH
93343: LD_VAR 0 2
93347: PUSH
93348: LD_VAR 0 4
93352: PLUS
93353: ST_TO_ADDR
// max_y := y + r ;
93354: LD_ADDR_VAR 0 10
93358: PUSH
93359: LD_VAR 0 3
93363: PUSH
93364: LD_VAR 0 4
93368: PLUS
93369: ST_TO_ADDR
// for _x = min_x to max_x do
93370: LD_ADDR_VAR 0 11
93374: PUSH
93375: DOUBLE
93376: LD_VAR 0 7
93380: DEC
93381: ST_TO_ADDR
93382: LD_VAR 0 9
93386: PUSH
93387: FOR_TO
93388: IFFALSE 93505
// for _y = min_y to max_y do
93390: LD_ADDR_VAR 0 12
93394: PUSH
93395: DOUBLE
93396: LD_VAR 0 8
93400: DEC
93401: ST_TO_ADDR
93402: LD_VAR 0 10
93406: PUSH
93407: FOR_TO
93408: IFFALSE 93501
// begin if not ValidHex ( _x , _y ) then
93410: LD_VAR 0 11
93414: PPUSH
93415: LD_VAR 0 12
93419: PPUSH
93420: CALL_OW 488
93424: NOT
93425: IFFALSE 93429
// continue ;
93427: GO 93407
// if IsEnvironment ( _x , _y ) and IsEnvironmentDestroyable ( _x , _y ) then
93429: LD_VAR 0 11
93433: PPUSH
93434: LD_VAR 0 12
93438: PPUSH
93439: CALL_OW 351
93443: PUSH
93444: LD_VAR 0 11
93448: PPUSH
93449: LD_VAR 0 12
93453: PPUSH
93454: CALL_OW 554
93458: AND
93459: IFFALSE 93499
// list := Insert ( list , list + 1 , [ _x , _y ] ) ;
93461: LD_ADDR_VAR 0 13
93465: PUSH
93466: LD_VAR 0 13
93470: PPUSH
93471: LD_VAR 0 13
93475: PUSH
93476: LD_INT 1
93478: PLUS
93479: PPUSH
93480: LD_VAR 0 11
93484: PUSH
93485: LD_VAR 0 12
93489: PUSH
93490: EMPTY
93491: LIST
93492: LIST
93493: PPUSH
93494: CALL_OW 2
93498: ST_TO_ADDR
// end ;
93499: GO 93407
93501: POP
93502: POP
93503: GO 93387
93505: POP
93506: POP
// if not list then
93507: LD_VAR 0 13
93511: NOT
93512: IFFALSE 93516
// exit ;
93514: GO 93587
// for i in list do
93516: LD_ADDR_VAR 0 6
93520: PUSH
93521: LD_VAR 0 13
93525: PUSH
93526: FOR_IN
93527: IFFALSE 93585
// AddTaskList ( bulldozer , [ [ M , i [ 1 ] , i [ 2 ] , 0 , 0 , 0 , 0 ] ] ) ;
93529: LD_VAR 0 1
93533: PPUSH
93534: LD_STRING M
93536: PUSH
93537: LD_VAR 0 6
93541: PUSH
93542: LD_INT 1
93544: ARRAY
93545: PUSH
93546: LD_VAR 0 6
93550: PUSH
93551: LD_INT 2
93553: ARRAY
93554: PUSH
93555: LD_INT 0
93557: PUSH
93558: LD_INT 0
93560: PUSH
93561: LD_INT 0
93563: PUSH
93564: LD_INT 0
93566: PUSH
93567: EMPTY
93568: LIST
93569: LIST
93570: LIST
93571: LIST
93572: LIST
93573: LIST
93574: LIST
93575: PUSH
93576: EMPTY
93577: LIST
93578: PPUSH
93579: CALL_OW 447
93583: GO 93526
93585: POP
93586: POP
// end ;
93587: LD_VAR 0 5
93591: RET
