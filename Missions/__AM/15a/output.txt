// starting begin ResetFog ;
   0: CALL_OW 335
// AnimateTrees ( true ) ;
   4: LD_INT 1
   6: PPUSH
   7: CALL_OW 573
// InitVariables ;
  11: CALL 69 0 0
// InitMacro ;
  15: CALL 20112 0 0
// InitNature ;
  19: CALL 16784 0 0
// InitArtifact ;
  23: CALL 17397 0 0
// if debug then
  27: LD_EXP 1
  31: IFFALSE 40
// FogOff ( 1 ) ;
  33: LD_INT 1
  35: PPUSH
  36: CALL_OW 344
// PrepareAmerican ;
  40: CALL 4496 0 0
// PrepareAlliance ;
  44: CALL 1314 0 0
// PrepareArabian ;
  48: CALL 6226 0 0
// PrepareRussian ;
  52: CALL 8177 0 0
// PrepareLegion ;
  56: CALL 6620 0 0
// Action ;
  60: CALL 10680 0 0
// MC_Start ( ) ;
  64: CALL 22224 0 0
// end ;
  68: END
// export debug ; export russianDestroyed , legionDestroyed , americanDestroyed , arabianDestroyed ; export artifactArCaptured , alienSpotted , spawnOmar ; export artifactIResearched , artifactIIResearched , artifactIIIResearched ; export function InitVariables ; begin
  69: LD_INT 0
  71: PPUSH
// debug := false ;
  72: LD_ADDR_EXP 1
  76: PUSH
  77: LD_INT 0
  79: ST_TO_ADDR
// artifactArCaptured := LoadVariable ( 11_artifact_captured , 0 ) ;
  80: LD_ADDR_EXP 6
  84: PUSH
  85: LD_STRING 11_artifact_captured
  87: PPUSH
  88: LD_INT 0
  90: PPUSH
  91: CALL_OW 30
  95: ST_TO_ADDR
// russianDestroyed := false ;
  96: LD_ADDR_EXP 2
 100: PUSH
 101: LD_INT 0
 103: ST_TO_ADDR
// legionDestroyed := false ;
 104: LD_ADDR_EXP 3
 108: PUSH
 109: LD_INT 0
 111: ST_TO_ADDR
// americanDestroyed := false ;
 112: LD_ADDR_EXP 4
 116: PUSH
 117: LD_INT 0
 119: ST_TO_ADDR
// arabianDestroyed := false ;
 120: LD_ADDR_EXP 5
 124: PUSH
 125: LD_INT 0
 127: ST_TO_ADDR
// artifactIResearched := false ;
 128: LD_ADDR_EXP 9
 132: PUSH
 133: LD_INT 0
 135: ST_TO_ADDR
// artifactIIResearched := false ;
 136: LD_ADDR_EXP 10
 140: PUSH
 141: LD_INT 0
 143: ST_TO_ADDR
// artifactIIIResearched := false ;
 144: LD_ADDR_EXP 11
 148: PUSH
 149: LD_INT 0
 151: ST_TO_ADDR
// alienSpotted := false ;
 152: LD_ADDR_EXP 7
 156: PUSH
 157: LD_INT 0
 159: ST_TO_ADDR
// spawnOmar := false ;
 160: LD_ADDR_EXP 8
 164: PUSH
 165: LD_INT 0
 167: ST_TO_ADDR
// end ;
 168: LD_VAR 0 1
 172: RET
// export function CustomInitMacro ( ) ; begin
 173: LD_INT 0
 175: PPUSH
// mc_parking := [ arabianParkingArea , russianParkingArea , legionParkingArea , powellParking ] ;
 176: LD_ADDR_EXP 98
 180: PUSH
 181: LD_INT 26
 183: PUSH
 184: LD_INT 1
 186: PUSH
 187: LD_INT 4
 189: PUSH
 190: LD_INT 8
 192: PUSH
 193: EMPTY
 194: LIST
 195: LIST
 196: LIST
 197: LIST
 198: ST_TO_ADDR
// mc_scan_area := [ arabianBaseArea , russianBaseArea , legionBaseArea , powellBase ] ;
 199: LD_ADDR_EXP 99
 203: PUSH
 204: LD_INT 27
 206: PUSH
 207: LD_INT 2
 209: PUSH
 210: LD_INT 3
 212: PUSH
 213: LD_INT 7
 215: PUSH
 216: EMPTY
 217: LIST
 218: LIST
 219: LIST
 220: LIST
 221: ST_TO_ADDR
// MC_SetMinesField ( 1 , [ 6 , 7 , 9 ] [ Difficulty ] , arabianMinefield ) ;
 222: LD_INT 1
 224: PPUSH
 225: LD_INT 6
 227: PUSH
 228: LD_INT 7
 230: PUSH
 231: LD_INT 9
 233: PUSH
 234: EMPTY
 235: LIST
 236: LIST
 237: LIST
 238: PUSH
 239: LD_OWVAR 67
 243: ARRAY
 244: PPUSH
 245: LD_INT 28
 247: PPUSH
 248: CALL 43545 0 3
// MC_SetLabKind ( 1 , [ b_lab_weapon , b_lab_siberium , b_lab_biological , b_lab_opto ] ) ;
 252: LD_INT 1
 254: PPUSH
 255: LD_INT 10
 257: PUSH
 258: LD_INT 11
 260: PUSH
 261: LD_INT 13
 263: PUSH
 264: LD_INT 15
 266: PUSH
 267: EMPTY
 268: LIST
 269: LIST
 270: LIST
 271: LIST
 272: PPUSH
 273: CALL 44605 0 2
// MC_SetCratesArea ( 1 , [ arabianCratesArea ] ) ;
 277: LD_INT 1
 279: PPUSH
 280: LD_INT 29
 282: PUSH
 283: EMPTY
 284: LIST
 285: PPUSH
 286: CALL 44698 0 2
// mc_ape := Replace ( mc_ape , 1 , FilterAllUnits ( [ [ f_side , 2 ] , [ f_class , class_apeman_soldier ] ] ) ) ;
 290: LD_ADDR_EXP 103
 294: PUSH
 295: LD_EXP 103
 299: PPUSH
 300: LD_INT 1
 302: PPUSH
 303: LD_INT 22
 305: PUSH
 306: LD_INT 2
 308: PUSH
 309: EMPTY
 310: LIST
 311: LIST
 312: PUSH
 313: LD_INT 25
 315: PUSH
 316: LD_INT 15
 318: PUSH
 319: EMPTY
 320: LIST
 321: LIST
 322: PUSH
 323: EMPTY
 324: LIST
 325: LIST
 326: PPUSH
 327: CALL_OW 69
 331: PPUSH
 332: CALL_OW 1
 336: ST_TO_ADDR
// MC_SetProduceList ( 1 , [ [ ar_medium_trike , engine_solar , control_manual , ar_control_tower ] , [ ar_medium_trike , engine_solar , control_manual , ar_control_tower ] , [ ar_medium_trike , engine_combustion , control_manual , ar_rocket_launcher ] , [ ar_medium_trike , engine_combustion , control_manual , ar_rocket_launcher ] , [ ar_medium_trike , engine_combustion , control_manual , ar_rocket_launcher ] , [ ar_medium_trike , engine_combustion , control_manual , ar_rocket_launcher ] ] ) ;
 337: LD_INT 1
 339: PPUSH
 340: LD_INT 13
 342: PUSH
 343: LD_INT 2
 345: PUSH
 346: LD_INT 1
 348: PUSH
 349: LD_INT 31
 351: PUSH
 352: EMPTY
 353: LIST
 354: LIST
 355: LIST
 356: LIST
 357: PUSH
 358: LD_INT 13
 360: PUSH
 361: LD_INT 2
 363: PUSH
 364: LD_INT 1
 366: PUSH
 367: LD_INT 31
 369: PUSH
 370: EMPTY
 371: LIST
 372: LIST
 373: LIST
 374: LIST
 375: PUSH
 376: LD_INT 13
 378: PUSH
 379: LD_INT 1
 381: PUSH
 382: LD_INT 1
 384: PUSH
 385: LD_INT 28
 387: PUSH
 388: EMPTY
 389: LIST
 390: LIST
 391: LIST
 392: LIST
 393: PUSH
 394: LD_INT 13
 396: PUSH
 397: LD_INT 1
 399: PUSH
 400: LD_INT 1
 402: PUSH
 403: LD_INT 28
 405: PUSH
 406: EMPTY
 407: LIST
 408: LIST
 409: LIST
 410: LIST
 411: PUSH
 412: LD_INT 13
 414: PUSH
 415: LD_INT 1
 417: PUSH
 418: LD_INT 1
 420: PUSH
 421: LD_INT 28
 423: PUSH
 424: EMPTY
 425: LIST
 426: LIST
 427: LIST
 428: LIST
 429: PUSH
 430: LD_INT 13
 432: PUSH
 433: LD_INT 1
 435: PUSH
 436: LD_INT 1
 438: PUSH
 439: LD_INT 28
 441: PUSH
 442: EMPTY
 443: LIST
 444: LIST
 445: LIST
 446: LIST
 447: PUSH
 448: EMPTY
 449: LIST
 450: LIST
 451: LIST
 452: LIST
 453: LIST
 454: LIST
 455: PPUSH
 456: CALL 43863 0 2
// MC_SetDefenderLimit ( 1 , 4 ) ;
 460: LD_INT 1
 462: PPUSH
 463: LD_INT 4
 465: PPUSH
 466: CALL 44048 0 2
// MC_SetLabKind ( 2 , [ b_lab_weapon , b_lab_siberium , b_lab_computer , b_lab_spacetime ] ) ;
 470: LD_INT 2
 472: PPUSH
 473: LD_INT 10
 475: PUSH
 476: LD_INT 11
 478: PUSH
 479: LD_INT 12
 481: PUSH
 482: LD_INT 14
 484: PUSH
 485: EMPTY
 486: LIST
 487: LIST
 488: LIST
 489: LIST
 490: PPUSH
 491: CALL 44605 0 2
// MC_SetCratesArea ( 2 , [ russianCratesArea ] ) ;
 495: LD_INT 2
 497: PPUSH
 498: LD_INT 14
 500: PUSH
 501: EMPTY
 502: LIST
 503: PPUSH
 504: CALL 44698 0 2
// MC_SetProduceList ( 2 , [ [ ru_medium_wheeled , engine_siberite , control_computer , ru_cargo_bay ] , [ ru_medium_tracked , engine_siberite , control_computer , ru_crane ] , [ ru_medium_tracked , engine_siberite , control_computer , ru_crane ] , [ ru_heavy_tracked , engine_siberite , control_computer , ru_rocket ] , [ ru_heavy_tracked , engine_siberite , control_computer , ru_rocket ] , [ ru_heavy_tracked , engine_siberite , control_computer , ru_rocket ] , [ ru_heavy_tracked , engine_siberite , control_computer , ru_rocket ] , [ ru_heavy_tracked , engine_siberite , control_computer , ru_rocket ] ] ) ;
 508: LD_INT 2
 510: PPUSH
 511: LD_INT 21
 513: PUSH
 514: LD_INT 3
 516: PUSH
 517: LD_INT 3
 519: PUSH
 520: LD_INT 51
 522: PUSH
 523: EMPTY
 524: LIST
 525: LIST
 526: LIST
 527: LIST
 528: PUSH
 529: LD_INT 22
 531: PUSH
 532: LD_INT 3
 534: PUSH
 535: LD_INT 3
 537: PUSH
 538: LD_INT 52
 540: PUSH
 541: EMPTY
 542: LIST
 543: LIST
 544: LIST
 545: LIST
 546: PUSH
 547: LD_INT 22
 549: PUSH
 550: LD_INT 3
 552: PUSH
 553: LD_INT 3
 555: PUSH
 556: LD_INT 52
 558: PUSH
 559: EMPTY
 560: LIST
 561: LIST
 562: LIST
 563: LIST
 564: PUSH
 565: LD_INT 24
 567: PUSH
 568: LD_INT 3
 570: PUSH
 571: LD_INT 3
 573: PUSH
 574: LD_INT 47
 576: PUSH
 577: EMPTY
 578: LIST
 579: LIST
 580: LIST
 581: LIST
 582: PUSH
 583: LD_INT 24
 585: PUSH
 586: LD_INT 3
 588: PUSH
 589: LD_INT 3
 591: PUSH
 592: LD_INT 47
 594: PUSH
 595: EMPTY
 596: LIST
 597: LIST
 598: LIST
 599: LIST
 600: PUSH
 601: LD_INT 24
 603: PUSH
 604: LD_INT 3
 606: PUSH
 607: LD_INT 3
 609: PUSH
 610: LD_INT 47
 612: PUSH
 613: EMPTY
 614: LIST
 615: LIST
 616: LIST
 617: LIST
 618: PUSH
 619: LD_INT 24
 621: PUSH
 622: LD_INT 3
 624: PUSH
 625: LD_INT 3
 627: PUSH
 628: LD_INT 47
 630: PUSH
 631: EMPTY
 632: LIST
 633: LIST
 634: LIST
 635: LIST
 636: PUSH
 637: LD_INT 24
 639: PUSH
 640: LD_INT 3
 642: PUSH
 643: LD_INT 3
 645: PUSH
 646: LD_INT 47
 648: PUSH
 649: EMPTY
 650: LIST
 651: LIST
 652: LIST
 653: LIST
 654: PUSH
 655: EMPTY
 656: LIST
 657: LIST
 658: LIST
 659: LIST
 660: LIST
 661: LIST
 662: LIST
 663: LIST
 664: PPUSH
 665: CALL 43863 0 2
// MC_SetDefenderLimit ( 2 , 5 ) ;
 669: LD_INT 2
 671: PPUSH
 672: LD_INT 5
 674: PPUSH
 675: CALL 44048 0 2
// MC_SetUpgradeBuilding ( 2 , b_depot ) ;
 679: LD_INT 2
 681: PPUSH
 682: LD_INT 0
 684: PPUSH
 685: CALL 44478 0 2
// MC_SetMinesField ( 3 , [ 10 , 12 , 15 ] [ Difficulty ] , legionMinefield ) ;
 689: LD_INT 3
 691: PPUSH
 692: LD_INT 10
 694: PUSH
 695: LD_INT 12
 697: PUSH
 698: LD_INT 15
 700: PUSH
 701: EMPTY
 702: LIST
 703: LIST
 704: LIST
 705: PUSH
 706: LD_OWVAR 67
 710: ARRAY
 711: PPUSH
 712: LD_INT 24
 714: PPUSH
 715: CALL 43545 0 3
// MC_SetLabKind ( 3 , [ b_lab_weapon , b_lab_siberium , b_lab_biological , b_lab_opto ] ) ;
 719: LD_INT 3
 721: PPUSH
 722: LD_INT 10
 724: PUSH
 725: LD_INT 11
 727: PUSH
 728: LD_INT 13
 730: PUSH
 731: LD_INT 15
 733: PUSH
 734: EMPTY
 735: LIST
 736: LIST
 737: LIST
 738: LIST
 739: PPUSH
 740: CALL 44605 0 2
// MC_SetCratesArea ( 3 , [ legionCratesArea ] ) ;
 744: LD_INT 3
 746: PPUSH
 747: LD_INT 13
 749: PUSH
 750: EMPTY
 751: LIST
 752: PPUSH
 753: CALL 44698 0 2
// mc_ape := Replace ( mc_ape , 3 , FilterAllUnits ( [ [ f_side , 8 ] , [ f_class , class_apeman_soldier ] ] ) ) ;
 757: LD_ADDR_EXP 103
 761: PUSH
 762: LD_EXP 103
 766: PPUSH
 767: LD_INT 3
 769: PPUSH
 770: LD_INT 22
 772: PUSH
 773: LD_INT 8
 775: PUSH
 776: EMPTY
 777: LIST
 778: LIST
 779: PUSH
 780: LD_INT 25
 782: PUSH
 783: LD_INT 15
 785: PUSH
 786: EMPTY
 787: LIST
 788: LIST
 789: PUSH
 790: EMPTY
 791: LIST
 792: LIST
 793: PPUSH
 794: CALL_OW 69
 798: PPUSH
 799: CALL_OW 1
 803: ST_TO_ADDR
// MC_SetProduceList ( 3 , [ [ ar_medium_trike , engine_solar , control_manual , ar_control_tower ] , [ ar_medium_trike , engine_solar , control_manual , ar_control_tower ] , [ ar_medium_trike , engine_siberite , control_remote , ar_cargo_bay ] , [ ar_half_tracked , engine_combustion , control_manual , ar_rocket_launcher ] , [ ar_half_tracked , engine_combustion , control_manual , ar_rocket_launcher ] , [ ar_half_tracked , engine_combustion , control_manual , ar_rocket_launcher ] , [ ar_half_tracked , engine_combustion , control_manual , ar_rocket_launcher ] ] ) ;
 804: LD_INT 3
 806: PPUSH
 807: LD_INT 13
 809: PUSH
 810: LD_INT 2
 812: PUSH
 813: LD_INT 1
 815: PUSH
 816: LD_INT 31
 818: PUSH
 819: EMPTY
 820: LIST
 821: LIST
 822: LIST
 823: LIST
 824: PUSH
 825: LD_INT 13
 827: PUSH
 828: LD_INT 2
 830: PUSH
 831: LD_INT 1
 833: PUSH
 834: LD_INT 31
 836: PUSH
 837: EMPTY
 838: LIST
 839: LIST
 840: LIST
 841: LIST
 842: PUSH
 843: LD_INT 13
 845: PUSH
 846: LD_INT 3
 848: PUSH
 849: LD_INT 2
 851: PUSH
 852: LD_INT 32
 854: PUSH
 855: EMPTY
 856: LIST
 857: LIST
 858: LIST
 859: LIST
 860: PUSH
 861: LD_INT 14
 863: PUSH
 864: LD_INT 1
 866: PUSH
 867: LD_INT 1
 869: PUSH
 870: LD_INT 28
 872: PUSH
 873: EMPTY
 874: LIST
 875: LIST
 876: LIST
 877: LIST
 878: PUSH
 879: LD_INT 14
 881: PUSH
 882: LD_INT 1
 884: PUSH
 885: LD_INT 1
 887: PUSH
 888: LD_INT 28
 890: PUSH
 891: EMPTY
 892: LIST
 893: LIST
 894: LIST
 895: LIST
 896: PUSH
 897: LD_INT 14
 899: PUSH
 900: LD_INT 1
 902: PUSH
 903: LD_INT 1
 905: PUSH
 906: LD_INT 28
 908: PUSH
 909: EMPTY
 910: LIST
 911: LIST
 912: LIST
 913: LIST
 914: PUSH
 915: LD_INT 14
 917: PUSH
 918: LD_INT 1
 920: PUSH
 921: LD_INT 1
 923: PUSH
 924: LD_INT 28
 926: PUSH
 927: EMPTY
 928: LIST
 929: LIST
 930: LIST
 931: LIST
 932: PUSH
 933: EMPTY
 934: LIST
 935: LIST
 936: LIST
 937: LIST
 938: LIST
 939: LIST
 940: LIST
 941: PPUSH
 942: CALL 43863 0 2
// MC_SetDefenderLimit ( 3 , 4 ) ;
 946: LD_INT 3
 948: PPUSH
 949: LD_INT 4
 951: PPUSH
 952: CALL 44048 0 2
// MC_SetLabKind ( 4 , [ b_lab_weapon , b_lab_computer , b_lab_siberium , b_lab_opto ] ) ;
 956: LD_INT 4
 958: PPUSH
 959: LD_INT 10
 961: PUSH
 962: LD_INT 12
 964: PUSH
 965: LD_INT 11
 967: PUSH
 968: LD_INT 15
 970: PUSH
 971: EMPTY
 972: LIST
 973: LIST
 974: LIST
 975: LIST
 976: PPUSH
 977: CALL 44605 0 2
// MC_SetCratesArea ( 4 , [ americanCratesArea ] ) ;
 981: LD_INT 4
 983: PPUSH
 984: LD_INT 33
 986: PUSH
 987: EMPTY
 988: LIST
 989: PPUSH
 990: CALL 44698 0 2
// MC_SetAllowedTurretWeapons ( 4 , [ us_double_gun , us_heavy_gun , us_rocket_launcher , us_laser , us_double_laser ] ) ;
 994: LD_INT 4
 996: PPUSH
 997: LD_INT 5
 999: PUSH
1000: LD_INT 6
1002: PUSH
1003: LD_INT 7
1005: PUSH
1006: LD_INT 9
1008: PUSH
1009: LD_INT 10
1011: PUSH
1012: EMPTY
1013: LIST
1014: LIST
1015: LIST
1016: LIST
1017: LIST
1018: PPUSH
1019: CALL 45016 0 2
// MC_SetFactoryExtension ( 4 , 54 , 85 , 2 , [ b_ext_laser , b_ext_track , b_ext_gun , b_ext_rocket , b_ext_radio ] ) ;
1023: LD_INT 4
1025: PPUSH
1026: LD_INT 54
1028: PPUSH
1029: LD_INT 85
1031: PPUSH
1032: LD_INT 2
1034: PPUSH
1035: LD_INT 25
1037: PUSH
1038: LD_INT 16
1040: PUSH
1041: LD_INT 17
1043: PUSH
1044: LD_INT 18
1046: PUSH
1047: LD_INT 22
1049: PUSH
1050: EMPTY
1051: LIST
1052: LIST
1053: LIST
1054: LIST
1055: LIST
1056: PPUSH
1057: CALL 44810 0 5
// MC_SetProduceList ( 4 , [ [ us_morphling , engine_combustion , control_manual , us_rocket_launcher ] , [ us_morphling , engine_combustion , control_manual , us_heavy_gun ] , [ us_morphling , engine_combustion , control_manual , us_rocket_launcher ] , [ us_morphling , engine_combustion , control_manual , us_heavy_gun ] , [ us_morphling , engine_combustion , control_computer , us_cargo_bay ] , [ us_medium_tracked , engine_combustion , control_computer , us_crane ] ] ) ;
1061: LD_INT 4
1063: PPUSH
1064: LD_INT 5
1066: PUSH
1067: LD_INT 1
1069: PUSH
1070: LD_INT 1
1072: PUSH
1073: LD_INT 7
1075: PUSH
1076: EMPTY
1077: LIST
1078: LIST
1079: LIST
1080: LIST
1081: PUSH
1082: LD_INT 5
1084: PUSH
1085: LD_INT 1
1087: PUSH
1088: LD_INT 1
1090: PUSH
1091: LD_INT 6
1093: PUSH
1094: EMPTY
1095: LIST
1096: LIST
1097: LIST
1098: LIST
1099: PUSH
1100: LD_INT 5
1102: PUSH
1103: LD_INT 1
1105: PUSH
1106: LD_INT 1
1108: PUSH
1109: LD_INT 7
1111: PUSH
1112: EMPTY
1113: LIST
1114: LIST
1115: LIST
1116: LIST
1117: PUSH
1118: LD_INT 5
1120: PUSH
1121: LD_INT 1
1123: PUSH
1124: LD_INT 1
1126: PUSH
1127: LD_INT 6
1129: PUSH
1130: EMPTY
1131: LIST
1132: LIST
1133: LIST
1134: LIST
1135: PUSH
1136: LD_INT 5
1138: PUSH
1139: LD_INT 1
1141: PUSH
1142: LD_INT 3
1144: PUSH
1145: LD_INT 12
1147: PUSH
1148: EMPTY
1149: LIST
1150: LIST
1151: LIST
1152: LIST
1153: PUSH
1154: LD_INT 3
1156: PUSH
1157: LD_INT 1
1159: PUSH
1160: LD_INT 3
1162: PUSH
1163: LD_INT 13
1165: PUSH
1166: EMPTY
1167: LIST
1168: LIST
1169: LIST
1170: LIST
1171: PUSH
1172: EMPTY
1173: LIST
1174: LIST
1175: LIST
1176: LIST
1177: LIST
1178: LIST
1179: PPUSH
1180: CALL 43863 0 2
// MC_SetDefenderLimit ( 4 , 4 ) ;
1184: LD_INT 4
1186: PPUSH
1187: LD_INT 4
1189: PPUSH
1190: CALL 44048 0 2
// MC_SetTame ( 4 , powellApe ) ;
1194: LD_INT 4
1196: PPUSH
1197: LD_INT 11
1199: PPUSH
1200: CALL 44429 0 2
// end ;
1204: LD_VAR 0 1
1208: RET
// every 0 0$1 trigger debug do var i ;
1209: LD_EXP 1
1213: IFFALSE 1311
1215: GO 1217
1217: DISABLE
1218: LD_INT 0
1220: PPUSH
// begin enable ;
1221: ENABLE
// for i in FilterAllUnits ( [ [ f_side , 7 ] , [ f_or , [ f_type , unit_human ] , [ f_type , unit_vehicle ] ] , [ f_not , [ f_lives , 1000 ] ] ] ) do
1222: LD_ADDR_VAR 0 1
1226: PUSH
1227: LD_INT 22
1229: PUSH
1230: LD_INT 7
1232: PUSH
1233: EMPTY
1234: LIST
1235: LIST
1236: PUSH
1237: LD_INT 2
1239: PUSH
1240: LD_INT 21
1242: PUSH
1243: LD_INT 1
1245: PUSH
1246: EMPTY
1247: LIST
1248: LIST
1249: PUSH
1250: LD_INT 21
1252: PUSH
1253: LD_INT 2
1255: PUSH
1256: EMPTY
1257: LIST
1258: LIST
1259: PUSH
1260: EMPTY
1261: LIST
1262: LIST
1263: LIST
1264: PUSH
1265: LD_INT 3
1267: PUSH
1268: LD_INT 24
1270: PUSH
1271: LD_INT 1000
1273: PUSH
1274: EMPTY
1275: LIST
1276: LIST
1277: PUSH
1278: EMPTY
1279: LIST
1280: LIST
1281: PUSH
1282: EMPTY
1283: LIST
1284: LIST
1285: LIST
1286: PPUSH
1287: CALL_OW 69
1291: PUSH
1292: FOR_IN
1293: IFFALSE 1309
// SetLives ( i , 1000 ) ;
1295: LD_VAR 0 1
1299: PPUSH
1300: LD_INT 1000
1302: PPUSH
1303: CALL_OW 234
1307: GO 1292
1309: POP
1310: POP
// end ; end_of_file
1311: PPOPN 1
1313: END
// export JMM , Roth , Lisa , Donaldson , Bobby , Cyrus , Denis , Brown , Gladstone , Houten , Cornel , Gary , Frank , Kikuchi , Simms , Joan , DeltaDoctor , Connie ; export Gossudarov , Kirilenkova , Titov , Fadeev , Dolgov , Petrosyan , Scholtze , Oblukov , Kapitsova , Lipshchin , Petrovova , Kovalyuk , Kuzmov , Karamazov ; export Burlak , Belkov , Gnyevko ; export function PrepareAlliance ; var i , veh , selected , tmp ; begin
1314: LD_INT 0
1316: PPUSH
1317: PPUSH
1318: PPUSH
1319: PPUSH
1320: PPUSH
// uc_side := 7 ;
1321: LD_ADDR_OWVAR 20
1325: PUSH
1326: LD_INT 7
1328: ST_TO_ADDR
// tmp := [ ] ;
1329: LD_ADDR_VAR 0 5
1333: PUSH
1334: EMPTY
1335: ST_TO_ADDR
// JMM := PrepareUnit ( JMM , ( not debug ) , 14a_ ) ;
1336: LD_ADDR_EXP 12
1340: PUSH
1341: LD_STRING JMM
1343: PPUSH
1344: LD_EXP 1
1348: NOT
1349: PPUSH
1350: LD_STRING 14a_
1352: PPUSH
1353: CALL 50255 0 3
1357: ST_TO_ADDR
// Burlak := PrepareUnit ( Burlak , ( not debug ) , 14a_ ) ;
1358: LD_ADDR_EXP 44
1362: PUSH
1363: LD_STRING Burlak
1365: PPUSH
1366: LD_EXP 1
1370: NOT
1371: PPUSH
1372: LD_STRING 14a_
1374: PPUSH
1375: CALL 50255 0 3
1379: ST_TO_ADDR
// Joan := PrepareUnit ( Joan , ( not debug ) , 13a_ ) ;
1380: LD_ADDR_EXP 27
1384: PUSH
1385: LD_STRING Joan
1387: PPUSH
1388: LD_EXP 1
1392: NOT
1393: PPUSH
1394: LD_STRING 13a_
1396: PPUSH
1397: CALL 50255 0 3
1401: ST_TO_ADDR
// Roth := PrepareUnit ( Roth , ( not debug ) , 13a_ ) ;
1402: LD_ADDR_EXP 13
1406: PUSH
1407: LD_STRING Roth
1409: PPUSH
1410: LD_EXP 1
1414: NOT
1415: PPUSH
1416: LD_STRING 13a_
1418: PPUSH
1419: CALL 50255 0 3
1423: ST_TO_ADDR
// Gossudarov := PrepareUnit ( Gossudarov , ( not debug ) , 13a_ ) ;
1424: LD_ADDR_EXP 30
1428: PUSH
1429: LD_STRING Gossudarov
1431: PPUSH
1432: LD_EXP 1
1436: NOT
1437: PPUSH
1438: LD_STRING 13a_
1440: PPUSH
1441: CALL 50255 0 3
1445: ST_TO_ADDR
// DeltaDoctor := PrepareUnit ( DeltaDoctor , ( not debug ) , 13a_ ) ;
1446: LD_ADDR_EXP 28
1450: PUSH
1451: LD_STRING DeltaDoctor
1453: PPUSH
1454: LD_EXP 1
1458: NOT
1459: PPUSH
1460: LD_STRING 13a_
1462: PPUSH
1463: CALL 50255 0 3
1467: ST_TO_ADDR
// if DeltaDoctor then
1468: LD_EXP 28
1472: IFFALSE 1490
// tmp := tmp ^ DeltaDoctor ;
1474: LD_ADDR_VAR 0 5
1478: PUSH
1479: LD_VAR 0 5
1483: PUSH
1484: LD_EXP 28
1488: ADD
1489: ST_TO_ADDR
// Simms := PrepareUnit ( Simms , ( not debug ) , 13a_ ) ;
1490: LD_ADDR_EXP 26
1494: PUSH
1495: LD_STRING Simms
1497: PPUSH
1498: LD_EXP 1
1502: NOT
1503: PPUSH
1504: LD_STRING 13a_
1506: PPUSH
1507: CALL 50255 0 3
1511: ST_TO_ADDR
// if Simms then
1512: LD_EXP 26
1516: IFFALSE 1534
// tmp := tmp ^ Simms ;
1518: LD_ADDR_VAR 0 5
1522: PUSH
1523: LD_VAR 0 5
1527: PUSH
1528: LD_EXP 26
1532: ADD
1533: ST_TO_ADDR
// Frank := PrepareUnit ( Frank , ( not debug ) , 13a_ ) ;
1534: LD_ADDR_EXP 24
1538: PUSH
1539: LD_STRING Frank
1541: PPUSH
1542: LD_EXP 1
1546: NOT
1547: PPUSH
1548: LD_STRING 13a_
1550: PPUSH
1551: CALL 50255 0 3
1555: ST_TO_ADDR
// if Frank then
1556: LD_EXP 24
1560: IFFALSE 1578
// tmp := tmp ^ Frank ;
1562: LD_ADDR_VAR 0 5
1566: PUSH
1567: LD_VAR 0 5
1571: PUSH
1572: LD_EXP 24
1576: ADD
1577: ST_TO_ADDR
// Kirilenkova := PrepareUnit ( Kirilenkova , ( not debug ) , 13a_ ) ;
1578: LD_ADDR_EXP 31
1582: PUSH
1583: LD_STRING Kirilenkova
1585: PPUSH
1586: LD_EXP 1
1590: NOT
1591: PPUSH
1592: LD_STRING 13a_
1594: PPUSH
1595: CALL 50255 0 3
1599: ST_TO_ADDR
// if Kirilenkova then
1600: LD_EXP 31
1604: IFFALSE 1622
// tmp := tmp ^ Kirilenkova ;
1606: LD_ADDR_VAR 0 5
1610: PUSH
1611: LD_VAR 0 5
1615: PUSH
1616: LD_EXP 31
1620: ADD
1621: ST_TO_ADDR
// Titov := PrepareUnit ( Titov , ( not debug ) , 13a_ ) ;
1622: LD_ADDR_EXP 32
1626: PUSH
1627: LD_STRING Titov
1629: PPUSH
1630: LD_EXP 1
1634: NOT
1635: PPUSH
1636: LD_STRING 13a_
1638: PPUSH
1639: CALL 50255 0 3
1643: ST_TO_ADDR
// if Titov then
1644: LD_EXP 32
1648: IFFALSE 1666
// tmp := tmp ^ Titov ;
1650: LD_ADDR_VAR 0 5
1654: PUSH
1655: LD_VAR 0 5
1659: PUSH
1660: LD_EXP 32
1664: ADD
1665: ST_TO_ADDR
// Fadeev := PrepareUnit ( Fadeev , ( not debug ) , 13a_ ) ;
1666: LD_ADDR_EXP 33
1670: PUSH
1671: LD_STRING Fadeev
1673: PPUSH
1674: LD_EXP 1
1678: NOT
1679: PPUSH
1680: LD_STRING 13a_
1682: PPUSH
1683: CALL 50255 0 3
1687: ST_TO_ADDR
// if Fadeev then
1688: LD_EXP 33
1692: IFFALSE 1710
// tmp := tmp ^ Fadeev ;
1694: LD_ADDR_VAR 0 5
1698: PUSH
1699: LD_VAR 0 5
1703: PUSH
1704: LD_EXP 33
1708: ADD
1709: ST_TO_ADDR
// Dolgov := PrepareUnit ( Dolgov , ( not debug ) , 13a_ ) ;
1710: LD_ADDR_EXP 34
1714: PUSH
1715: LD_STRING Dolgov
1717: PPUSH
1718: LD_EXP 1
1722: NOT
1723: PPUSH
1724: LD_STRING 13a_
1726: PPUSH
1727: CALL 50255 0 3
1731: ST_TO_ADDR
// if Dolgov then
1732: LD_EXP 34
1736: IFFALSE 1754
// tmp := tmp ^ Dolgov ;
1738: LD_ADDR_VAR 0 5
1742: PUSH
1743: LD_VAR 0 5
1747: PUSH
1748: LD_EXP 34
1752: ADD
1753: ST_TO_ADDR
// Petrosyan := PrepareUnit ( Petrosyan , ( not debug ) , 13a_ ) ;
1754: LD_ADDR_EXP 35
1758: PUSH
1759: LD_STRING Petrosyan
1761: PPUSH
1762: LD_EXP 1
1766: NOT
1767: PPUSH
1768: LD_STRING 13a_
1770: PPUSH
1771: CALL 50255 0 3
1775: ST_TO_ADDR
// if Petrosyan then
1776: LD_EXP 35
1780: IFFALSE 1798
// tmp := tmp ^ Petrosyan ;
1782: LD_ADDR_VAR 0 5
1786: PUSH
1787: LD_VAR 0 5
1791: PUSH
1792: LD_EXP 35
1796: ADD
1797: ST_TO_ADDR
// Scholtze := PrepareUnit ( Scholtze , ( not debug ) , 13a_ ) ;
1798: LD_ADDR_EXP 36
1802: PUSH
1803: LD_STRING Scholtze
1805: PPUSH
1806: LD_EXP 1
1810: NOT
1811: PPUSH
1812: LD_STRING 13a_
1814: PPUSH
1815: CALL 50255 0 3
1819: ST_TO_ADDR
// if Scholtze then
1820: LD_EXP 36
1824: IFFALSE 1842
// tmp := tmp ^ Scholtze ;
1826: LD_ADDR_VAR 0 5
1830: PUSH
1831: LD_VAR 0 5
1835: PUSH
1836: LD_EXP 36
1840: ADD
1841: ST_TO_ADDR
// Oblukov := PrepareUnit ( Oblukov , ( not debug ) , 13a_ ) ;
1842: LD_ADDR_EXP 37
1846: PUSH
1847: LD_STRING Oblukov
1849: PPUSH
1850: LD_EXP 1
1854: NOT
1855: PPUSH
1856: LD_STRING 13a_
1858: PPUSH
1859: CALL 50255 0 3
1863: ST_TO_ADDR
// if Oblukov then
1864: LD_EXP 37
1868: IFFALSE 1886
// tmp := tmp ^ Oblukov ;
1870: LD_ADDR_VAR 0 5
1874: PUSH
1875: LD_VAR 0 5
1879: PUSH
1880: LD_EXP 37
1884: ADD
1885: ST_TO_ADDR
// Kapitsova := PrepareUnit ( Kapitsova , ( not debug ) , 13a_ ) ;
1886: LD_ADDR_EXP 38
1890: PUSH
1891: LD_STRING Kapitsova
1893: PPUSH
1894: LD_EXP 1
1898: NOT
1899: PPUSH
1900: LD_STRING 13a_
1902: PPUSH
1903: CALL 50255 0 3
1907: ST_TO_ADDR
// if Kapitsova then
1908: LD_EXP 38
1912: IFFALSE 1930
// tmp := tmp ^ Kapitsova ;
1914: LD_ADDR_VAR 0 5
1918: PUSH
1919: LD_VAR 0 5
1923: PUSH
1924: LD_EXP 38
1928: ADD
1929: ST_TO_ADDR
// Lipshchin := PrepareUnit ( Lipshchin , ( not debug ) , 13a_ ) ;
1930: LD_ADDR_EXP 39
1934: PUSH
1935: LD_STRING Lipshchin
1937: PPUSH
1938: LD_EXP 1
1942: NOT
1943: PPUSH
1944: LD_STRING 13a_
1946: PPUSH
1947: CALL 50255 0 3
1951: ST_TO_ADDR
// if Lipshchin then
1952: LD_EXP 39
1956: IFFALSE 1974
// tmp := tmp ^ Lipshchin ;
1958: LD_ADDR_VAR 0 5
1962: PUSH
1963: LD_VAR 0 5
1967: PUSH
1968: LD_EXP 39
1972: ADD
1973: ST_TO_ADDR
// Petrovova := PrepareUnit ( Petrovova , ( not debug ) , 13a_ ) ;
1974: LD_ADDR_EXP 40
1978: PUSH
1979: LD_STRING Petrovova
1981: PPUSH
1982: LD_EXP 1
1986: NOT
1987: PPUSH
1988: LD_STRING 13a_
1990: PPUSH
1991: CALL 50255 0 3
1995: ST_TO_ADDR
// if Petrovova then
1996: LD_EXP 40
2000: IFFALSE 2018
// tmp := tmp ^ Petrovova ;
2002: LD_ADDR_VAR 0 5
2006: PUSH
2007: LD_VAR 0 5
2011: PUSH
2012: LD_EXP 40
2016: ADD
2017: ST_TO_ADDR
// Kovalyuk := PrepareUnit ( Kovalyuk , ( not debug ) , 13a_ ) ;
2018: LD_ADDR_EXP 41
2022: PUSH
2023: LD_STRING Kovalyuk
2025: PPUSH
2026: LD_EXP 1
2030: NOT
2031: PPUSH
2032: LD_STRING 13a_
2034: PPUSH
2035: CALL 50255 0 3
2039: ST_TO_ADDR
// if Kovalyuk then
2040: LD_EXP 41
2044: IFFALSE 2062
// tmp := tmp ^ Kovalyuk ;
2046: LD_ADDR_VAR 0 5
2050: PUSH
2051: LD_VAR 0 5
2055: PUSH
2056: LD_EXP 41
2060: ADD
2061: ST_TO_ADDR
// Kuzmov := PrepareUnit ( Kuzmov , ( not debug ) , 13a_ ) ;
2062: LD_ADDR_EXP 42
2066: PUSH
2067: LD_STRING Kuzmov
2069: PPUSH
2070: LD_EXP 1
2074: NOT
2075: PPUSH
2076: LD_STRING 13a_
2078: PPUSH
2079: CALL 50255 0 3
2083: ST_TO_ADDR
// if Kuzmov then
2084: LD_EXP 42
2088: IFFALSE 2106
// tmp := tmp ^ Kuzmov ;
2090: LD_ADDR_VAR 0 5
2094: PUSH
2095: LD_VAR 0 5
2099: PUSH
2100: LD_EXP 42
2104: ADD
2105: ST_TO_ADDR
// Karamazov := PrepareUnit ( Karamazov , ( not debug ) , 13a_ ) ;
2106: LD_ADDR_EXP 43
2110: PUSH
2111: LD_STRING Karamazov
2113: PPUSH
2114: LD_EXP 1
2118: NOT
2119: PPUSH
2120: LD_STRING 13a_
2122: PPUSH
2123: CALL 50255 0 3
2127: ST_TO_ADDR
// if Karamazov then
2128: LD_EXP 43
2132: IFFALSE 2150
// tmp := tmp ^ Karamazov ;
2134: LD_ADDR_VAR 0 5
2138: PUSH
2139: LD_VAR 0 5
2143: PUSH
2144: LD_EXP 43
2148: ADD
2149: ST_TO_ADDR
// Belkov := PrepareUnit ( Belkov , ( not debug ) , 13a_ ) ;
2150: LD_ADDR_EXP 45
2154: PUSH
2155: LD_STRING Belkov
2157: PPUSH
2158: LD_EXP 1
2162: NOT
2163: PPUSH
2164: LD_STRING 13a_
2166: PPUSH
2167: CALL 50255 0 3
2171: ST_TO_ADDR
// if Belkov then
2172: LD_EXP 45
2176: IFFALSE 2194
// tmp := tmp ^ Belkov ;
2178: LD_ADDR_VAR 0 5
2182: PUSH
2183: LD_VAR 0 5
2187: PUSH
2188: LD_EXP 45
2192: ADD
2193: ST_TO_ADDR
// Gnyevko := PrepareUnit ( Gnyevko , ( not debug ) , 13a_ ) ;
2194: LD_ADDR_EXP 46
2198: PUSH
2199: LD_STRING Gnyevko
2201: PPUSH
2202: LD_EXP 1
2206: NOT
2207: PPUSH
2208: LD_STRING 13a_
2210: PPUSH
2211: CALL 50255 0 3
2215: ST_TO_ADDR
// if Gnyevko then
2216: LD_EXP 46
2220: IFFALSE 2238
// tmp := tmp ^ Gnyevko ;
2222: LD_ADDR_VAR 0 5
2226: PUSH
2227: LD_VAR 0 5
2231: PUSH
2232: LD_EXP 46
2236: ADD
2237: ST_TO_ADDR
// Connie = NewCharacter ( Coonie ) ;
2238: LD_ADDR_EXP 29
2242: PUSH
2243: LD_STRING Coonie
2245: PPUSH
2246: CALL_OW 25
2250: ST_TO_ADDR
// if not Lisa then
2251: LD_EXP 14
2255: NOT
2256: IFFALSE 2302
// begin Lisa := PrepareUnit ( Lisa , ( not debug ) , 13a_ ) ;
2258: LD_ADDR_EXP 14
2262: PUSH
2263: LD_STRING Lisa
2265: PPUSH
2266: LD_EXP 1
2270: NOT
2271: PPUSH
2272: LD_STRING 13a_
2274: PPUSH
2275: CALL 50255 0 3
2279: ST_TO_ADDR
// if Lisa then
2280: LD_EXP 14
2284: IFFALSE 2302
// tmp := tmp ^ Lisa ;
2286: LD_ADDR_VAR 0 5
2290: PUSH
2291: LD_VAR 0 5
2295: PUSH
2296: LD_EXP 14
2300: ADD
2301: ST_TO_ADDR
// end ; if not Donaldson then
2302: LD_EXP 15
2306: NOT
2307: IFFALSE 2353
// begin Donaldson := PrepareUnit ( Donaldson , ( not debug ) , 13a_ ) ;
2309: LD_ADDR_EXP 15
2313: PUSH
2314: LD_STRING Donaldson
2316: PPUSH
2317: LD_EXP 1
2321: NOT
2322: PPUSH
2323: LD_STRING 13a_
2325: PPUSH
2326: CALL 50255 0 3
2330: ST_TO_ADDR
// if Donaldson then
2331: LD_EXP 15
2335: IFFALSE 2353
// tmp := tmp ^ Donaldson ;
2337: LD_ADDR_VAR 0 5
2341: PUSH
2342: LD_VAR 0 5
2346: PUSH
2347: LD_EXP 15
2351: ADD
2352: ST_TO_ADDR
// end ; if not Bobby then
2353: LD_EXP 16
2357: NOT
2358: IFFALSE 2404
// begin Bobby := PrepareUnit ( Bobby , ( not debug ) , 13a_ ) ;
2360: LD_ADDR_EXP 16
2364: PUSH
2365: LD_STRING Bobby
2367: PPUSH
2368: LD_EXP 1
2372: NOT
2373: PPUSH
2374: LD_STRING 13a_
2376: PPUSH
2377: CALL 50255 0 3
2381: ST_TO_ADDR
// if Bobby then
2382: LD_EXP 16
2386: IFFALSE 2404
// tmp := tmp ^ Bobby ;
2388: LD_ADDR_VAR 0 5
2392: PUSH
2393: LD_VAR 0 5
2397: PUSH
2398: LD_EXP 16
2402: ADD
2403: ST_TO_ADDR
// end ; if not Cyrus then
2404: LD_EXP 17
2408: NOT
2409: IFFALSE 2455
// begin Cyrus := PrepareUnit ( Cyrus , ( not debug ) , 13a_ ) ;
2411: LD_ADDR_EXP 17
2415: PUSH
2416: LD_STRING Cyrus
2418: PPUSH
2419: LD_EXP 1
2423: NOT
2424: PPUSH
2425: LD_STRING 13a_
2427: PPUSH
2428: CALL 50255 0 3
2432: ST_TO_ADDR
// if Cyrus then
2433: LD_EXP 17
2437: IFFALSE 2455
// tmp := tmp ^ Cyrus ;
2439: LD_ADDR_VAR 0 5
2443: PUSH
2444: LD_VAR 0 5
2448: PUSH
2449: LD_EXP 17
2453: ADD
2454: ST_TO_ADDR
// end ; if not Brown then
2455: LD_EXP 19
2459: NOT
2460: IFFALSE 2506
// begin Brown := PrepareUnit ( Brown , ( not debug ) , 13a_ ) ;
2462: LD_ADDR_EXP 19
2466: PUSH
2467: LD_STRING Brown
2469: PPUSH
2470: LD_EXP 1
2474: NOT
2475: PPUSH
2476: LD_STRING 13a_
2478: PPUSH
2479: CALL 50255 0 3
2483: ST_TO_ADDR
// if Brown then
2484: LD_EXP 19
2488: IFFALSE 2506
// tmp := tmp ^ Brown ;
2490: LD_ADDR_VAR 0 5
2494: PUSH
2495: LD_VAR 0 5
2499: PUSH
2500: LD_EXP 19
2504: ADD
2505: ST_TO_ADDR
// end ; if not Gladstone then
2506: LD_EXP 20
2510: NOT
2511: IFFALSE 2557
// begin Gladstone := PrepareUnit ( Gladstone , ( not debug ) , 13a_ ) ;
2513: LD_ADDR_EXP 20
2517: PUSH
2518: LD_STRING Gladstone
2520: PPUSH
2521: LD_EXP 1
2525: NOT
2526: PPUSH
2527: LD_STRING 13a_
2529: PPUSH
2530: CALL 50255 0 3
2534: ST_TO_ADDR
// if Gladstone then
2535: LD_EXP 20
2539: IFFALSE 2557
// tmp := tmp ^ Gladstone ;
2541: LD_ADDR_VAR 0 5
2545: PUSH
2546: LD_VAR 0 5
2550: PUSH
2551: LD_EXP 20
2555: ADD
2556: ST_TO_ADDR
// end ; if not Cornel then
2557: LD_EXP 22
2561: NOT
2562: IFFALSE 2608
// begin Cornel := PrepareUnit ( Cornel , ( not debug ) , 13a_ ) ;
2564: LD_ADDR_EXP 22
2568: PUSH
2569: LD_STRING Cornel
2571: PPUSH
2572: LD_EXP 1
2576: NOT
2577: PPUSH
2578: LD_STRING 13a_
2580: PPUSH
2581: CALL 50255 0 3
2585: ST_TO_ADDR
// if Cornel then
2586: LD_EXP 22
2590: IFFALSE 2608
// tmp := tmp ^ Cornel ;
2592: LD_ADDR_VAR 0 5
2596: PUSH
2597: LD_VAR 0 5
2601: PUSH
2602: LD_EXP 22
2606: ADD
2607: ST_TO_ADDR
// end ; if not Houten then
2608: LD_EXP 21
2612: NOT
2613: IFFALSE 2659
// begin Houten := PrepareUnit ( Houten , ( not debug ) , 13a_ ) ;
2615: LD_ADDR_EXP 21
2619: PUSH
2620: LD_STRING Houten
2622: PPUSH
2623: LD_EXP 1
2627: NOT
2628: PPUSH
2629: LD_STRING 13a_
2631: PPUSH
2632: CALL 50255 0 3
2636: ST_TO_ADDR
// if Houten then
2637: LD_EXP 21
2641: IFFALSE 2659
// tmp := tmp ^ Houten ;
2643: LD_ADDR_VAR 0 5
2647: PUSH
2648: LD_VAR 0 5
2652: PUSH
2653: LD_EXP 21
2657: ADD
2658: ST_TO_ADDR
// end ; if not Gary then
2659: LD_EXP 23
2663: NOT
2664: IFFALSE 2710
// begin Gary := PrepareUnit ( Gary , ( not debug ) , 13a_ ) ;
2666: LD_ADDR_EXP 23
2670: PUSH
2671: LD_STRING Gary
2673: PPUSH
2674: LD_EXP 1
2678: NOT
2679: PPUSH
2680: LD_STRING 13a_
2682: PPUSH
2683: CALL 50255 0 3
2687: ST_TO_ADDR
// if Gary then
2688: LD_EXP 23
2692: IFFALSE 2710
// tmp := tmp ^ Gary ;
2694: LD_ADDR_VAR 0 5
2698: PUSH
2699: LD_VAR 0 5
2703: PUSH
2704: LD_EXP 23
2708: ADD
2709: ST_TO_ADDR
// end ; if not Kikuchi then
2710: LD_EXP 25
2714: NOT
2715: IFFALSE 2761
// begin Kikuchi := PrepareUnit ( Kikuchi , ( not debug ) , 13a_ ) ;
2717: LD_ADDR_EXP 25
2721: PUSH
2722: LD_STRING Kikuchi
2724: PPUSH
2725: LD_EXP 1
2729: NOT
2730: PPUSH
2731: LD_STRING 13a_
2733: PPUSH
2734: CALL 50255 0 3
2738: ST_TO_ADDR
// if Kikuchi then
2739: LD_EXP 25
2743: IFFALSE 2761
// tmp := tmp ^ Kikuchi ;
2745: LD_ADDR_VAR 0 5
2749: PUSH
2750: LD_VAR 0 5
2754: PUSH
2755: LD_EXP 25
2759: ADD
2760: ST_TO_ADDR
// end ; tmp := tmp union CreateCharacterSet ( 13a_others ) ;
2761: LD_ADDR_VAR 0 5
2765: PUSH
2766: LD_VAR 0 5
2770: PUSH
2771: LD_STRING 13a_others
2773: PPUSH
2774: CALL_OW 31
2778: UNION
2779: ST_TO_ADDR
// tmp := tmp diff 0 ;
2780: LD_ADDR_VAR 0 5
2784: PUSH
2785: LD_VAR 0 5
2789: PUSH
2790: LD_INT 0
2792: DIFF
2793: ST_TO_ADDR
// if tmp < 15 then
2794: LD_VAR 0 5
2798: PUSH
2799: LD_INT 15
2801: LESS
2802: IFFALSE 2890
// for i = 15 downto tmp do
2804: LD_ADDR_VAR 0 2
2808: PUSH
2809: DOUBLE
2810: LD_INT 15
2812: INC
2813: ST_TO_ADDR
2814: LD_VAR 0 5
2818: PUSH
2819: FOR_DOWNTO
2820: IFFALSE 2888
// begin uc_nation := [ 1 , 3 ] [ rand ( 1 , 2 ) ] ;
2822: LD_ADDR_OWVAR 21
2826: PUSH
2827: LD_INT 1
2829: PUSH
2830: LD_INT 3
2832: PUSH
2833: EMPTY
2834: LIST
2835: LIST
2836: PUSH
2837: LD_INT 1
2839: PPUSH
2840: LD_INT 2
2842: PPUSH
2843: CALL_OW 12
2847: ARRAY
2848: ST_TO_ADDR
// PrepareHuman ( false , rand ( 1 , 4 ) , 8 ) ;
2849: LD_INT 0
2851: PPUSH
2852: LD_INT 1
2854: PPUSH
2855: LD_INT 4
2857: PPUSH
2858: CALL_OW 12
2862: PPUSH
2863: LD_INT 8
2865: PPUSH
2866: CALL_OW 380
// tmp := tmp ^ CreateHuman ;
2870: LD_ADDR_VAR 0 5
2874: PUSH
2875: LD_VAR 0 5
2879: PUSH
2880: CALL_OW 44
2884: ADD
2885: ST_TO_ADDR
// end ;
2886: GO 2819
2888: POP
2889: POP
// if not debug then
2890: LD_EXP 1
2894: NOT
2895: IFFALSE 3067
// selected = CharacterSelection (  , [ 15 , 14 , 13 ] [ Difficulty ] , [ 15 , 14 , 13 ] [ Difficulty ] , [ sel_dont_change_class , JMM , Burlak , Roth , Joan , Denis , Gossudarov , sel_not_hired , sel_changeable , sel_change_class ] ^ tmp , [ class_soldier , class_scientistic , [ class_engineer , 1 ] , class_mechanic , [ class_sniper , 0 , 3 ] , [ class_bazooker , 0 , 3 ] ] ) else
2897: LD_ADDR_VAR 0 4
2901: PUSH
2902: LD_STRING 
2904: PPUSH
2905: LD_INT 15
2907: PUSH
2908: LD_INT 14
2910: PUSH
2911: LD_INT 13
2913: PUSH
2914: EMPTY
2915: LIST
2916: LIST
2917: LIST
2918: PUSH
2919: LD_OWVAR 67
2923: ARRAY
2924: PPUSH
2925: LD_INT 15
2927: PUSH
2928: LD_INT 14
2930: PUSH
2931: LD_INT 13
2933: PUSH
2934: EMPTY
2935: LIST
2936: LIST
2937: LIST
2938: PUSH
2939: LD_OWVAR 67
2943: ARRAY
2944: PPUSH
2945: LD_INT -6
2947: PUSH
2948: LD_EXP 12
2952: PUSH
2953: LD_EXP 44
2957: PUSH
2958: LD_EXP 13
2962: PUSH
2963: LD_EXP 27
2967: PUSH
2968: LD_EXP 18
2972: PUSH
2973: LD_EXP 30
2977: PUSH
2978: LD_INT -2
2980: PUSH
2981: LD_INT -3
2983: PUSH
2984: LD_INT -5
2986: PUSH
2987: EMPTY
2988: LIST
2989: LIST
2990: LIST
2991: LIST
2992: LIST
2993: LIST
2994: LIST
2995: LIST
2996: LIST
2997: LIST
2998: PUSH
2999: LD_VAR 0 5
3003: ADD
3004: PPUSH
3005: LD_INT 1
3007: PUSH
3008: LD_INT 4
3010: PUSH
3011: LD_INT 2
3013: PUSH
3014: LD_INT 1
3016: PUSH
3017: EMPTY
3018: LIST
3019: LIST
3020: PUSH
3021: LD_INT 3
3023: PUSH
3024: LD_INT 5
3026: PUSH
3027: LD_INT 0
3029: PUSH
3030: LD_INT 3
3032: PUSH
3033: EMPTY
3034: LIST
3035: LIST
3036: LIST
3037: PUSH
3038: LD_INT 9
3040: PUSH
3041: LD_INT 0
3043: PUSH
3044: LD_INT 3
3046: PUSH
3047: EMPTY
3048: LIST
3049: LIST
3050: LIST
3051: PUSH
3052: EMPTY
3053: LIST
3054: LIST
3055: LIST
3056: LIST
3057: LIST
3058: LIST
3059: PPUSH
3060: CALL_OW 42
3064: ST_TO_ADDR
3065: GO 3146
// selected := [ Titov , Fadeev , Dolgov , Petrosyan , Scholtze , Oblukov , Kapitsova , Lipshchin , Petrovova , Kovalyuk , Kuzmov , Karamazov ] ;
3067: LD_ADDR_VAR 0 4
3071: PUSH
3072: LD_EXP 32
3076: PUSH
3077: LD_EXP 33
3081: PUSH
3082: LD_EXP 34
3086: PUSH
3087: LD_EXP 35
3091: PUSH
3092: LD_EXP 36
3096: PUSH
3097: LD_EXP 37
3101: PUSH
3102: LD_EXP 38
3106: PUSH
3107: LD_EXP 39
3111: PUSH
3112: LD_EXP 40
3116: PUSH
3117: LD_EXP 41
3121: PUSH
3122: LD_EXP 42
3126: PUSH
3127: LD_EXP 43
3131: PUSH
3132: EMPTY
3133: LIST
3134: LIST
3135: LIST
3136: LIST
3137: LIST
3138: LIST
3139: LIST
3140: LIST
3141: LIST
3142: LIST
3143: LIST
3144: LIST
3145: ST_TO_ADDR
// uc_nation := 1 ;
3146: LD_ADDR_OWVAR 21
3150: PUSH
3151: LD_INT 1
3153: ST_TO_ADDR
// PrepareVehicle ( us_morphling , engine_siberite , control_manual , us_heavy_gun , 100 ) ;
3154: LD_INT 5
3156: PPUSH
3157: LD_INT 3
3159: PPUSH
3160: LD_INT 1
3162: PPUSH
3163: LD_INT 6
3165: PPUSH
3166: LD_INT 100
3168: PPUSH
3169: CALL 57281 0 5
// veh := CreateVehicle ;
3173: LD_ADDR_VAR 0 3
3177: PUSH
3178: CALL_OW 45
3182: ST_TO_ADDR
// SetMark ( veh , - 7 ) ;
3183: LD_VAR 0 3
3187: PPUSH
3188: LD_INT 7
3190: NEG
3191: PPUSH
3192: CALL_OW 242
// SetDir ( veh , 3 ) ;
3196: LD_VAR 0 3
3200: PPUSH
3201: LD_INT 3
3203: PPUSH
3204: CALL_OW 233
// PlaceUnitArea ( veh , allianceJMMSpawnArea , false ) ;
3208: LD_VAR 0 3
3212: PPUSH
3213: LD_INT 31
3215: PPUSH
3216: LD_INT 0
3218: PPUSH
3219: CALL_OW 49
// PlaceHumanInUnit ( JMM , veh ) ;
3223: LD_EXP 12
3227: PPUSH
3228: LD_VAR 0 3
3232: PPUSH
3233: CALL_OW 52
// if Joan then
3237: LD_EXP 27
3241: IFFALSE 3313
// begin PrepareVehicle ( us_medium_tracked , engine_siberite , control_manual , us_radar , 100 ) ;
3243: LD_INT 3
3245: PPUSH
3246: LD_INT 3
3248: PPUSH
3249: LD_INT 1
3251: PPUSH
3252: LD_INT 11
3254: PPUSH
3255: LD_INT 100
3257: PPUSH
3258: CALL 57281 0 5
// veh := CreateVehicle ;
3262: LD_ADDR_VAR 0 3
3266: PUSH
3267: CALL_OW 45
3271: ST_TO_ADDR
// SetDir ( veh , 3 ) ;
3272: LD_VAR 0 3
3276: PPUSH
3277: LD_INT 3
3279: PPUSH
3280: CALL_OW 233
// PlaceUnitArea ( veh , allianceSpawnArea , false ) ;
3284: LD_VAR 0 3
3288: PPUSH
3289: LD_INT 30
3291: PPUSH
3292: LD_INT 0
3294: PPUSH
3295: CALL_OW 49
// PlaceHumanInUnit ( Joan , veh ) ;
3299: LD_EXP 27
3303: PPUSH
3304: LD_VAR 0 3
3308: PPUSH
3309: CALL_OW 52
// end ; if Roth then
3313: LD_EXP 13
3317: IFFALSE 3389
// begin PrepareVehicle ( us_medium_tracked , engine_siberite , control_manual , us_radar , 100 ) ;
3319: LD_INT 3
3321: PPUSH
3322: LD_INT 3
3324: PPUSH
3325: LD_INT 1
3327: PPUSH
3328: LD_INT 11
3330: PPUSH
3331: LD_INT 100
3333: PPUSH
3334: CALL 57281 0 5
// veh := CreateVehicle ;
3338: LD_ADDR_VAR 0 3
3342: PUSH
3343: CALL_OW 45
3347: ST_TO_ADDR
// SetDir ( veh , 3 ) ;
3348: LD_VAR 0 3
3352: PPUSH
3353: LD_INT 3
3355: PPUSH
3356: CALL_OW 233
// PlaceUnitArea ( veh , allianceSpawnArea , false ) ;
3360: LD_VAR 0 3
3364: PPUSH
3365: LD_INT 30
3367: PPUSH
3368: LD_INT 0
3370: PPUSH
3371: CALL_OW 49
// PlaceHumanInUnit ( Roth , veh ) ;
3375: LD_EXP 13
3379: PPUSH
3380: LD_VAR 0 3
3384: PPUSH
3385: CALL_OW 52
// end ; if Denis then
3389: LD_EXP 18
3393: IFFALSE 3465
// begin PrepareVehicle ( us_morphling , engine_siberite , control_manual , us_laser , 100 ) ;
3395: LD_INT 5
3397: PPUSH
3398: LD_INT 3
3400: PPUSH
3401: LD_INT 1
3403: PPUSH
3404: LD_INT 9
3406: PPUSH
3407: LD_INT 100
3409: PPUSH
3410: CALL 57281 0 5
// veh := CreateVehicle ;
3414: LD_ADDR_VAR 0 3
3418: PUSH
3419: CALL_OW 45
3423: ST_TO_ADDR
// SetDir ( veh , 3 ) ;
3424: LD_VAR 0 3
3428: PPUSH
3429: LD_INT 3
3431: PPUSH
3432: CALL_OW 233
// PlaceUnitArea ( veh , allianceSpawnArea , false ) ;
3436: LD_VAR 0 3
3440: PPUSH
3441: LD_INT 30
3443: PPUSH
3444: LD_INT 0
3446: PPUSH
3447: CALL_OW 49
// PlaceHumanInUnit ( Denis , veh ) ;
3451: LD_EXP 18
3455: PPUSH
3456: LD_VAR 0 3
3460: PPUSH
3461: CALL_OW 52
// end ; uc_nation := 3 ;
3465: LD_ADDR_OWVAR 21
3469: PUSH
3470: LD_INT 3
3472: ST_TO_ADDR
// PrepareVehicle ( ru_medium_tracked , engine_siberite , control_manual , ru_rocket_launcher , 100 ) ;
3473: LD_INT 22
3475: PPUSH
3476: LD_INT 3
3478: PPUSH
3479: LD_INT 1
3481: PPUSH
3482: LD_INT 45
3484: PPUSH
3485: LD_INT 100
3487: PPUSH
3488: CALL 57281 0 5
// veh := CreateVehicle ;
3492: LD_ADDR_VAR 0 3
3496: PUSH
3497: CALL_OW 45
3501: ST_TO_ADDR
// SetMark ( veh , - 7 ) ;
3502: LD_VAR 0 3
3506: PPUSH
3507: LD_INT 7
3509: NEG
3510: PPUSH
3511: CALL_OW 242
// SetDir ( veh , 3 ) ;
3515: LD_VAR 0 3
3519: PPUSH
3520: LD_INT 3
3522: PPUSH
3523: CALL_OW 233
// PlaceUnitArea ( veh , allianceJMMSpawnArea , false ) ;
3527: LD_VAR 0 3
3531: PPUSH
3532: LD_INT 31
3534: PPUSH
3535: LD_INT 0
3537: PPUSH
3538: CALL_OW 49
// PlaceHumanInUnit ( Burlak , veh ) ;
3542: LD_EXP 44
3546: PPUSH
3547: LD_VAR 0 3
3551: PPUSH
3552: CALL_OW 52
// if Gossudarov then
3556: LD_EXP 30
3560: IFFALSE 3647
// begin PrepareVehicle ( ru_medium_tracked , engine_siberite , control_manual , ru_cargo_bay , 100 ) ;
3562: LD_INT 22
3564: PPUSH
3565: LD_INT 3
3567: PPUSH
3568: LD_INT 1
3570: PPUSH
3571: LD_INT 51
3573: PPUSH
3574: LD_INT 100
3576: PPUSH
3577: CALL 57281 0 5
// veh := CreateVehicle ;
3581: LD_ADDR_VAR 0 3
3585: PUSH
3586: CALL_OW 45
3590: ST_TO_ADDR
// SetDir ( veh , 3 ) ;
3591: LD_VAR 0 3
3595: PPUSH
3596: LD_INT 3
3598: PPUSH
3599: CALL_OW 233
// PlaceUnitArea ( veh , allianceSpawnArea , false ) ;
3603: LD_VAR 0 3
3607: PPUSH
3608: LD_INT 30
3610: PPUSH
3611: LD_INT 0
3613: PPUSH
3614: CALL_OW 49
// PlaceHumanInUnit ( Gossudarov , veh ) ;
3618: LD_EXP 30
3622: PPUSH
3623: LD_VAR 0 3
3627: PPUSH
3628: CALL_OW 52
// SetCargo ( veh , mat_cans , 100 ) ;
3632: LD_VAR 0 3
3636: PPUSH
3637: LD_INT 1
3639: PPUSH
3640: LD_INT 100
3642: PPUSH
3643: CALL_OW 290
// end ; for i in selected do
3647: LD_ADDR_VAR 0 2
3651: PUSH
3652: LD_VAR 0 4
3656: PUSH
3657: FOR_IN
3658: IFFALSE 4216
// begin uc_nation := GetNation ( i ) ;
3660: LD_ADDR_OWVAR 21
3664: PUSH
3665: LD_VAR 0 2
3669: PPUSH
3670: CALL_OW 248
3674: ST_TO_ADDR
// if i in [ Lisa , Donaldson , Cyrus , Bobby ] then
3675: LD_VAR 0 2
3679: PUSH
3680: LD_EXP 14
3684: PUSH
3685: LD_EXP 15
3689: PUSH
3690: LD_EXP 17
3694: PUSH
3695: LD_EXP 16
3699: PUSH
3700: EMPTY
3701: LIST
3702: LIST
3703: LIST
3704: LIST
3705: IN
3706: IFFALSE 3729
// PrepareVehicle ( us_morphling , engine_siberite , control_manual , us_heavy_gun , 100 ) else
3708: LD_INT 5
3710: PPUSH
3711: LD_INT 3
3713: PPUSH
3714: LD_INT 1
3716: PPUSH
3717: LD_INT 6
3719: PPUSH
3720: LD_INT 100
3722: PPUSH
3723: CALL 57281 0 5
3727: GO 4163
// if i in [ Oblukov , Kuzmov , Petrovova , Titov ] then
3729: LD_VAR 0 2
3733: PUSH
3734: LD_EXP 37
3738: PUSH
3739: LD_EXP 42
3743: PUSH
3744: LD_EXP 40
3748: PUSH
3749: LD_EXP 32
3753: PUSH
3754: EMPTY
3755: LIST
3756: LIST
3757: LIST
3758: LIST
3759: IN
3760: IFFALSE 3791
// PrepareVehicle ( ru_heavy_tracked , engine_combustion , control_manual , ru_heavy_gun , rand ( 65 , 75 ) ) else
3762: LD_INT 24
3764: PPUSH
3765: LD_INT 1
3767: PPUSH
3768: LD_INT 1
3770: PPUSH
3771: LD_INT 46
3773: PPUSH
3774: LD_INT 65
3776: PPUSH
3777: LD_INT 75
3779: PPUSH
3780: CALL_OW 12
3784: PPUSH
3785: CALL 57281 0 5
3789: GO 4163
// if i = Karamazov then
3791: LD_VAR 0 2
3795: PUSH
3796: LD_EXP 43
3800: EQUAL
3801: IFFALSE 3824
// PrepareVehicle ( ru_medium_tracked , engine_siberite , control_manual , ru_crane , 100 ) else
3803: LD_INT 22
3805: PPUSH
3806: LD_INT 3
3808: PPUSH
3809: LD_INT 1
3811: PPUSH
3812: LD_INT 52
3814: PPUSH
3815: LD_INT 100
3817: PPUSH
3818: CALL 57281 0 5
3822: GO 4163
// if i = Brown then
3824: LD_VAR 0 2
3828: PUSH
3829: LD_EXP 19
3833: EQUAL
3834: IFFALSE 3857
// PrepareVehicle ( us_medium_tracked , engine_siberite , control_manual , us_crane , 100 ) else
3836: LD_INT 3
3838: PPUSH
3839: LD_INT 3
3841: PPUSH
3842: LD_INT 1
3844: PPUSH
3845: LD_INT 13
3847: PPUSH
3848: LD_INT 100
3850: PPUSH
3851: CALL 57281 0 5
3855: GO 4163
// if uc_nation = nation_american then
3857: LD_OWVAR 21
3861: PUSH
3862: LD_INT 1
3864: EQUAL
3865: IFFALSE 4016
// begin PrepareVehicle ( [ us_medium_tracked , us_morphling , us_morphling ] [ uc_nation mod 3 + 1 ] , [ engine_combustion , engine_siberite , engine_combustion ] [ uc_nation mod 3 + 1 ] , control_manual , [ [ us_radar , us_gatling_gun , us_double_gun ] , [ us_heavy_gun , us_rocket_launcher , us_laser ] , [ us_heavy_gun , us_laser , us_cargo_bay ] ] [ uc_nation mod 3 + 1 ] [ rand ( 1 , 3 ) ] , rand ( 65 , 75 ) ) ;
3867: LD_INT 3
3869: PUSH
3870: LD_INT 5
3872: PUSH
3873: LD_INT 5
3875: PUSH
3876: EMPTY
3877: LIST
3878: LIST
3879: LIST
3880: PUSH
3881: LD_OWVAR 21
3885: PUSH
3886: LD_INT 3
3888: MOD
3889: PUSH
3890: LD_INT 1
3892: PLUS
3893: ARRAY
3894: PPUSH
3895: LD_INT 1
3897: PUSH
3898: LD_INT 3
3900: PUSH
3901: LD_INT 1
3903: PUSH
3904: EMPTY
3905: LIST
3906: LIST
3907: LIST
3908: PUSH
3909: LD_OWVAR 21
3913: PUSH
3914: LD_INT 3
3916: MOD
3917: PUSH
3918: LD_INT 1
3920: PLUS
3921: ARRAY
3922: PPUSH
3923: LD_INT 1
3925: PPUSH
3926: LD_INT 11
3928: PUSH
3929: LD_INT 4
3931: PUSH
3932: LD_INT 5
3934: PUSH
3935: EMPTY
3936: LIST
3937: LIST
3938: LIST
3939: PUSH
3940: LD_INT 6
3942: PUSH
3943: LD_INT 7
3945: PUSH
3946: LD_INT 9
3948: PUSH
3949: EMPTY
3950: LIST
3951: LIST
3952: LIST
3953: PUSH
3954: LD_INT 6
3956: PUSH
3957: LD_INT 9
3959: PUSH
3960: LD_INT 12
3962: PUSH
3963: EMPTY
3964: LIST
3965: LIST
3966: LIST
3967: PUSH
3968: EMPTY
3969: LIST
3970: LIST
3971: LIST
3972: PUSH
3973: LD_OWVAR 21
3977: PUSH
3978: LD_INT 3
3980: MOD
3981: PUSH
3982: LD_INT 1
3984: PLUS
3985: ARRAY
3986: PUSH
3987: LD_INT 1
3989: PPUSH
3990: LD_INT 3
3992: PPUSH
3993: CALL_OW 12
3997: ARRAY
3998: PPUSH
3999: LD_INT 65
4001: PPUSH
4002: LD_INT 75
4004: PPUSH
4005: CALL_OW 12
4009: PPUSH
4010: CALL 57281 0 5
// end else
4014: GO 4163
// begin PrepareVehicle ( [ ru_medium_tracked , ru_heavy_wheeled , ru_heavy_wheeled ] [ uc_nation mod 3 + 1 ] , [ engine_combustion , engine_siberite , engine_combustion ] [ uc_nation mod 3 + 1 ] , control_manual , [ [ ru_rocket_launcher , ru_gatling_gun , ru_gun ] , [ ru_heavy_gun , ru_rocket_launcher , ru_gun ] , [ ru_heavy_gun , ru_gatling_gun , ru_rocket_launcher ] ] [ uc_nation mod 3 + 1 ] [ rand ( 1 , 3 ) ] , rand ( 65 , 75 ) ) ;
4016: LD_INT 22
4018: PUSH
4019: LD_INT 23
4021: PUSH
4022: LD_INT 23
4024: PUSH
4025: EMPTY
4026: LIST
4027: LIST
4028: LIST
4029: PUSH
4030: LD_OWVAR 21
4034: PUSH
4035: LD_INT 3
4037: MOD
4038: PUSH
4039: LD_INT 1
4041: PLUS
4042: ARRAY
4043: PPUSH
4044: LD_INT 1
4046: PUSH
4047: LD_INT 3
4049: PUSH
4050: LD_INT 1
4052: PUSH
4053: EMPTY
4054: LIST
4055: LIST
4056: LIST
4057: PUSH
4058: LD_OWVAR 21
4062: PUSH
4063: LD_INT 3
4065: MOD
4066: PUSH
4067: LD_INT 1
4069: PLUS
4070: ARRAY
4071: PPUSH
4072: LD_INT 1
4074: PPUSH
4075: LD_INT 45
4077: PUSH
4078: LD_INT 43
4080: PUSH
4081: LD_INT 44
4083: PUSH
4084: EMPTY
4085: LIST
4086: LIST
4087: LIST
4088: PUSH
4089: LD_INT 46
4091: PUSH
4092: LD_INT 45
4094: PUSH
4095: LD_INT 44
4097: PUSH
4098: EMPTY
4099: LIST
4100: LIST
4101: LIST
4102: PUSH
4103: LD_INT 46
4105: PUSH
4106: LD_INT 43
4108: PUSH
4109: LD_INT 45
4111: PUSH
4112: EMPTY
4113: LIST
4114: LIST
4115: LIST
4116: PUSH
4117: EMPTY
4118: LIST
4119: LIST
4120: LIST
4121: PUSH
4122: LD_OWVAR 21
4126: PUSH
4127: LD_INT 3
4129: MOD
4130: PUSH
4131: LD_INT 1
4133: PLUS
4134: ARRAY
4135: PUSH
4136: LD_INT 1
4138: PPUSH
4139: LD_INT 3
4141: PPUSH
4142: CALL_OW 12
4146: ARRAY
4147: PPUSH
4148: LD_INT 65
4150: PPUSH
4151: LD_INT 75
4153: PPUSH
4154: CALL_OW 12
4158: PPUSH
4159: CALL 57281 0 5
// end ; veh := CreateVehicle ;
4163: LD_ADDR_VAR 0 3
4167: PUSH
4168: CALL_OW 45
4172: ST_TO_ADDR
// SetDir ( veh , 3 ) ;
4173: LD_VAR 0 3
4177: PPUSH
4178: LD_INT 3
4180: PPUSH
4181: CALL_OW 233
// PlaceUnitArea ( veh , allianceSpawnArea , false ) ;
4185: LD_VAR 0 3
4189: PPUSH
4190: LD_INT 30
4192: PPUSH
4193: LD_INT 0
4195: PPUSH
4196: CALL_OW 49
// PlaceHumanInUnit ( i , veh ) ;
4200: LD_VAR 0 2
4204: PPUSH
4205: LD_VAR 0 3
4209: PPUSH
4210: CALL_OW 52
// end ;
4214: GO 3657
4216: POP
4217: POP
// if artifactArCaptured then
4218: LD_EXP 6
4222: IFFALSE 4308
// begin uc_nation := nation_american ;
4224: LD_ADDR_OWVAR 21
4228: PUSH
4229: LD_INT 1
4231: ST_TO_ADDR
// PrepareVehicle ( us_medium_tracked , engine_siberite , control_computer , us_cargo_bay , 100 ) ;
4232: LD_INT 3
4234: PPUSH
4235: LD_INT 3
4237: PPUSH
4238: LD_INT 3
4240: PPUSH
4241: LD_INT 12
4243: PPUSH
4244: LD_INT 100
4246: PPUSH
4247: CALL 57281 0 5
// veh := CreateVehicle ;
4251: LD_ADDR_VAR 0 3
4255: PUSH
4256: CALL_OW 45
4260: ST_TO_ADDR
// SetDir ( veh , 3 ) ;
4261: LD_VAR 0 3
4265: PPUSH
4266: LD_INT 3
4268: PPUSH
4269: CALL_OW 233
// PlaceUnitXY ( veh , 198 , 22 , false ) ;
4273: LD_VAR 0 3
4277: PPUSH
4278: LD_INT 198
4280: PPUSH
4281: LD_INT 22
4283: PPUSH
4284: LD_INT 0
4286: PPUSH
4287: CALL_OW 48
// SetCargo ( veh , mat_artifact , 50 ) ;
4291: LD_VAR 0 3
4295: PPUSH
4296: LD_INT 4
4298: PPUSH
4299: LD_INT 50
4301: PPUSH
4302: CALL_OW 290
// end else
4306: GO 4327
// begin CreateResourcesXY ( mat_artifact , 267 , 226 , 5 , false ) ;
4308: LD_INT 4
4310: PPUSH
4311: LD_INT 267
4313: PPUSH
4314: LD_INT 226
4316: PPUSH
4317: LD_INT 5
4319: PPUSH
4320: LD_INT 0
4322: PPUSH
4323: CALL_OW 58
// end ; uc_nation := nation_american ;
4327: LD_ADDR_OWVAR 21
4331: PUSH
4332: LD_INT 1
4334: ST_TO_ADDR
// PrepareVehicle ( us_medium_tracked , engine_siberite , control_computer , us_cargo_bay , 100 ) ;
4335: LD_INT 3
4337: PPUSH
4338: LD_INT 3
4340: PPUSH
4341: LD_INT 3
4343: PPUSH
4344: LD_INT 12
4346: PPUSH
4347: LD_INT 100
4349: PPUSH
4350: CALL 57281 0 5
// veh := CreateVehicle ;
4354: LD_ADDR_VAR 0 3
4358: PUSH
4359: CALL_OW 45
4363: ST_TO_ADDR
// SetDir ( veh , 3 ) ;
4364: LD_VAR 0 3
4368: PPUSH
4369: LD_INT 3
4371: PPUSH
4372: CALL_OW 233
// PlaceUnitXY ( veh , 218 , 23 , false ) ;
4376: LD_VAR 0 3
4380: PPUSH
4381: LD_INT 218
4383: PPUSH
4384: LD_INT 23
4386: PPUSH
4387: LD_INT 0
4389: PPUSH
4390: CALL_OW 48
// SetCargo ( veh , mat_artifact , 30 ) ;
4394: LD_VAR 0 3
4398: PPUSH
4399: LD_INT 4
4401: PPUSH
4402: LD_INT 30
4404: PPUSH
4405: CALL_OW 290
// uc_nation := nation_russian ;
4409: LD_ADDR_OWVAR 21
4413: PUSH
4414: LD_INT 3
4416: ST_TO_ADDR
// PrepareVehicle ( ru_medium_tracked , engine_siberite , control_computer , ru_cargo_bay , 100 ) ;
4417: LD_INT 22
4419: PPUSH
4420: LD_INT 3
4422: PPUSH
4423: LD_INT 3
4425: PPUSH
4426: LD_INT 51
4428: PPUSH
4429: LD_INT 100
4431: PPUSH
4432: CALL 57281 0 5
// veh := CreateVehicle ;
4436: LD_ADDR_VAR 0 3
4440: PUSH
4441: CALL_OW 45
4445: ST_TO_ADDR
// SetDir ( veh , 3 ) ;
4446: LD_VAR 0 3
4450: PPUSH
4451: LD_INT 3
4453: PPUSH
4454: CALL_OW 233
// PlaceUnitXY ( veh , 214 , 20 , false ) ;
4458: LD_VAR 0 3
4462: PPUSH
4463: LD_INT 214
4465: PPUSH
4466: LD_INT 20
4468: PPUSH
4469: LD_INT 0
4471: PPUSH
4472: CALL_OW 48
// SetCargo ( veh , mat_artifact , 40 ) ;
4476: LD_VAR 0 3
4480: PPUSH
4481: LD_INT 4
4483: PPUSH
4484: LD_INT 40
4486: PPUSH
4487: CALL_OW 290
// end ; end_of_file
4491: LD_VAR 0 1
4495: RET
// export Powell ; export function PrepareAmerican ; var i , b , veh , cl , tmp , depot , lab , armoury , workshop ; begin
4496: LD_INT 0
4498: PPUSH
4499: PPUSH
4500: PPUSH
4501: PPUSH
4502: PPUSH
4503: PPUSH
4504: PPUSH
4505: PPUSH
4506: PPUSH
4507: PPUSH
// InitHc ;
4508: CALL_OW 19
// uc_side := 1 ;
4512: LD_ADDR_OWVAR 20
4516: PUSH
4517: LD_INT 1
4519: ST_TO_ADDR
// uc_nation := 1 ;
4520: LD_ADDR_OWVAR 21
4524: PUSH
4525: LD_INT 1
4527: ST_TO_ADDR
// SetResourceType ( GetBase ( am_depot ) , mat_cans , 25500 ) ;
4528: LD_INT 387
4530: PPUSH
4531: CALL_OW 274
4535: PPUSH
4536: LD_INT 1
4538: PPUSH
4539: LD_INT 25500
4541: PPUSH
4542: CALL_OW 277
// SetResourceType ( GetBase ( am_depot ) , mat_oil , 4000 ) ;
4546: LD_INT 387
4548: PPUSH
4549: CALL_OW 274
4553: PPUSH
4554: LD_INT 2
4556: PPUSH
4557: LD_INT 4000
4559: PPUSH
4560: CALL_OW 277
// SetResourceType ( GetBase ( am_depot ) , mat_siberit , 50 ) ;
4564: LD_INT 387
4566: PPUSH
4567: CALL_OW 274
4571: PPUSH
4572: LD_INT 3
4574: PPUSH
4575: LD_INT 50
4577: PPUSH
4578: CALL_OW 277
// SetResourceType ( GetBase ( am_depot2 ) , mat_cans , 7500 ) ;
4582: LD_INT 476
4584: PPUSH
4585: CALL_OW 274
4589: PPUSH
4590: LD_INT 1
4592: PPUSH
4593: LD_INT 7500
4595: PPUSH
4596: CALL_OW 277
// SetResourceType ( GetBase ( am_depot2 ) , mat_oil , 4000 ) ;
4600: LD_INT 476
4602: PPUSH
4603: CALL_OW 274
4607: PPUSH
4608: LD_INT 2
4610: PPUSH
4611: LD_INT 4000
4613: PPUSH
4614: CALL_OW 277
// SetResourceType ( GetBase ( am_depot2 ) , mat_siberit , 10 ) ;
4618: LD_INT 476
4620: PPUSH
4621: CALL_OW 274
4625: PPUSH
4626: LD_INT 3
4628: PPUSH
4629: LD_INT 10
4631: PPUSH
4632: CALL_OW 277
// Powell := NewCharacter ( Powell ) ;
4636: LD_ADDR_EXP 47
4640: PUSH
4641: LD_STRING Powell
4643: PPUSH
4644: CALL_OW 25
4648: ST_TO_ADDR
// PlaceUnitXY ( Powell , 57 , 94 , false ) ;
4649: LD_EXP 47
4653: PPUSH
4654: LD_INT 57
4656: PPUSH
4657: LD_INT 94
4659: PPUSH
4660: LD_INT 0
4662: PPUSH
4663: CALL_OW 48
// ComTurnXY ( Powell , 58 , 94 ) ;
4667: LD_EXP 47
4671: PPUSH
4672: LD_INT 58
4674: PPUSH
4675: LD_INT 94
4677: PPUSH
4678: CALL_OW 118
// tmp := [ ] ;
4682: LD_ADDR_VAR 0 6
4686: PUSH
4687: EMPTY
4688: ST_TO_ADDR
// Lisa := PrepareUnit ( Lisa , ( not debug ) , 12p_ ) ;
4689: LD_ADDR_EXP 14
4693: PUSH
4694: LD_STRING Lisa
4696: PPUSH
4697: LD_EXP 1
4701: NOT
4702: PPUSH
4703: LD_STRING 12p_
4705: PPUSH
4706: CALL 50255 0 3
4710: ST_TO_ADDR
// if Lisa then
4711: LD_EXP 14
4715: IFFALSE 4733
// tmp := tmp ^ Lisa ;
4717: LD_ADDR_VAR 0 6
4721: PUSH
4722: LD_VAR 0 6
4726: PUSH
4727: LD_EXP 14
4731: ADD
4732: ST_TO_ADDR
// Donaldson := PrepareUnit ( Donaldson , ( not debug ) , 12p_ ) ;
4733: LD_ADDR_EXP 15
4737: PUSH
4738: LD_STRING Donaldson
4740: PPUSH
4741: LD_EXP 1
4745: NOT
4746: PPUSH
4747: LD_STRING 12p_
4749: PPUSH
4750: CALL 50255 0 3
4754: ST_TO_ADDR
// if Donaldson then
4755: LD_EXP 15
4759: IFFALSE 4777
// tmp := tmp ^ Donaldson ;
4761: LD_ADDR_VAR 0 6
4765: PUSH
4766: LD_VAR 0 6
4770: PUSH
4771: LD_EXP 15
4775: ADD
4776: ST_TO_ADDR
// Bobby := PrepareUnit ( Bobby , ( not debug ) , 12p_ ) ;
4777: LD_ADDR_EXP 16
4781: PUSH
4782: LD_STRING Bobby
4784: PPUSH
4785: LD_EXP 1
4789: NOT
4790: PPUSH
4791: LD_STRING 12p_
4793: PPUSH
4794: CALL 50255 0 3
4798: ST_TO_ADDR
// if Bobby then
4799: LD_EXP 16
4803: IFFALSE 4821
// tmp := tmp ^ Bobby ;
4805: LD_ADDR_VAR 0 6
4809: PUSH
4810: LD_VAR 0 6
4814: PUSH
4815: LD_EXP 16
4819: ADD
4820: ST_TO_ADDR
// Cyrus := PrepareUnit ( Cyrus , ( not debug ) , 12p_ ) ;
4821: LD_ADDR_EXP 17
4825: PUSH
4826: LD_STRING Cyrus
4828: PPUSH
4829: LD_EXP 1
4833: NOT
4834: PPUSH
4835: LD_STRING 12p_
4837: PPUSH
4838: CALL 50255 0 3
4842: ST_TO_ADDR
// if Cyrus then
4843: LD_EXP 17
4847: IFFALSE 4865
// tmp := tmp ^ Cyrus ;
4849: LD_ADDR_VAR 0 6
4853: PUSH
4854: LD_VAR 0 6
4858: PUSH
4859: LD_EXP 17
4863: ADD
4864: ST_TO_ADDR
// Brown := PrepareUnit ( Brown , ( not debug ) , 12p_ ) ;
4865: LD_ADDR_EXP 19
4869: PUSH
4870: LD_STRING Brown
4872: PPUSH
4873: LD_EXP 1
4877: NOT
4878: PPUSH
4879: LD_STRING 12p_
4881: PPUSH
4882: CALL 50255 0 3
4886: ST_TO_ADDR
// if Brown then
4887: LD_EXP 19
4891: IFFALSE 4909
// tmp := tmp ^ Brown ;
4893: LD_ADDR_VAR 0 6
4897: PUSH
4898: LD_VAR 0 6
4902: PUSH
4903: LD_EXP 19
4907: ADD
4908: ST_TO_ADDR
// Gladstone := PrepareUnit ( Gladstone , ( not debug ) , 12p_ ) ;
4909: LD_ADDR_EXP 20
4913: PUSH
4914: LD_STRING Gladstone
4916: PPUSH
4917: LD_EXP 1
4921: NOT
4922: PPUSH
4923: LD_STRING 12p_
4925: PPUSH
4926: CALL 50255 0 3
4930: ST_TO_ADDR
// if Gladstone then
4931: LD_EXP 20
4935: IFFALSE 4953
// tmp := tmp ^ Gladstone ;
4937: LD_ADDR_VAR 0 6
4941: PUSH
4942: LD_VAR 0 6
4946: PUSH
4947: LD_EXP 20
4951: ADD
4952: ST_TO_ADDR
// Houten := PrepareUnit ( Houten , ( not debug ) , 12p_ ) ;
4953: LD_ADDR_EXP 21
4957: PUSH
4958: LD_STRING Houten
4960: PPUSH
4961: LD_EXP 1
4965: NOT
4966: PPUSH
4967: LD_STRING 12p_
4969: PPUSH
4970: CALL 50255 0 3
4974: ST_TO_ADDR
// if Houten then
4975: LD_EXP 21
4979: IFFALSE 4997
// tmp := tmp ^ Houten ;
4981: LD_ADDR_VAR 0 6
4985: PUSH
4986: LD_VAR 0 6
4990: PUSH
4991: LD_EXP 21
4995: ADD
4996: ST_TO_ADDR
// Cornel := PrepareUnit ( Cornel , ( not debug ) , 12p_ ) ;
4997: LD_ADDR_EXP 22
5001: PUSH
5002: LD_STRING Cornel
5004: PPUSH
5005: LD_EXP 1
5009: NOT
5010: PPUSH
5011: LD_STRING 12p_
5013: PPUSH
5014: CALL 50255 0 3
5018: ST_TO_ADDR
// if Cornel then
5019: LD_EXP 22
5023: IFFALSE 5041
// tmp := tmp ^ Cornel ;
5025: LD_ADDR_VAR 0 6
5029: PUSH
5030: LD_VAR 0 6
5034: PUSH
5035: LD_EXP 22
5039: ADD
5040: ST_TO_ADDR
// Gary := PrepareUnit ( Gary , ( not debug ) , 12p_ ) ;
5041: LD_ADDR_EXP 23
5045: PUSH
5046: LD_STRING Gary
5048: PPUSH
5049: LD_EXP 1
5053: NOT
5054: PPUSH
5055: LD_STRING 12p_
5057: PPUSH
5058: CALL 50255 0 3
5062: ST_TO_ADDR
// if Gary then
5063: LD_EXP 23
5067: IFFALSE 5085
// tmp := tmp ^ Gary ;
5069: LD_ADDR_VAR 0 6
5073: PUSH
5074: LD_VAR 0 6
5078: PUSH
5079: LD_EXP 23
5083: ADD
5084: ST_TO_ADDR
// Kikuchi := PrepareUnit ( Kikuchi , ( not debug ) , 12p_ ) ;
5085: LD_ADDR_EXP 25
5089: PUSH
5090: LD_STRING Kikuchi
5092: PPUSH
5093: LD_EXP 1
5097: NOT
5098: PPUSH
5099: LD_STRING 12p_
5101: PPUSH
5102: CALL 50255 0 3
5106: ST_TO_ADDR
// if Kikuchi then
5107: LD_EXP 25
5111: IFFALSE 5129
// tmp := tmp ^ Kikuchi ;
5113: LD_ADDR_VAR 0 6
5117: PUSH
5118: LD_VAR 0 6
5122: PUSH
5123: LD_EXP 25
5127: ADD
5128: ST_TO_ADDR
// tmp := tmp union CreateCharacterSet ( 12p_others ) ;
5129: LD_ADDR_VAR 0 6
5133: PUSH
5134: LD_VAR 0 6
5138: PUSH
5139: LD_STRING 12p_others
5141: PPUSH
5142: CALL_OW 31
5146: UNION
5147: ST_TO_ADDR
// if tmp < 36 then
5148: LD_VAR 0 6
5152: PUSH
5153: LD_INT 36
5155: LESS
5156: IFFALSE 5223
// for i = 1 to 36 - tmp do
5158: LD_ADDR_VAR 0 2
5162: PUSH
5163: DOUBLE
5164: LD_INT 1
5166: DEC
5167: ST_TO_ADDR
5168: LD_INT 36
5170: PUSH
5171: LD_VAR 0 6
5175: MINUS
5176: PUSH
5177: FOR_TO
5178: IFFALSE 5221
// begin PrepareHuman ( sex_male , i mod 4 + 1 , 10 ) ;
5180: LD_INT 1
5182: PPUSH
5183: LD_VAR 0 2
5187: PUSH
5188: LD_INT 4
5190: MOD
5191: PUSH
5192: LD_INT 1
5194: PLUS
5195: PPUSH
5196: LD_INT 10
5198: PPUSH
5199: CALL_OW 380
// tmp := tmp ^ CreateHuman ;
5203: LD_ADDR_VAR 0 6
5207: PUSH
5208: LD_VAR 0 6
5212: PUSH
5213: CALL_OW 44
5217: ADD
5218: ST_TO_ADDR
// end ;
5219: GO 5177
5221: POP
5222: POP
// for i in tmp do
5223: LD_ADDR_VAR 0 2
5227: PUSH
5228: LD_VAR 0 6
5232: PUSH
5233: FOR_IN
5234: IFFALSE 5259
// PlaceUnitXYR ( i , 62 , 93 , 9 , false ) ;
5236: LD_VAR 0 2
5240: PPUSH
5241: LD_INT 62
5243: PPUSH
5244: LD_INT 93
5246: PPUSH
5247: LD_INT 9
5249: PPUSH
5250: LD_INT 0
5252: PPUSH
5253: CALL_OW 50
5257: GO 5233
5259: POP
5260: POP
// mc_bases := Replace ( mc_bases , 4 , FilterAllUnits ( [ f_side , 1 ] ) ) ;
5261: LD_ADDR_EXP 74
5265: PUSH
5266: LD_EXP 74
5270: PPUSH
5271: LD_INT 4
5273: PPUSH
5274: LD_INT 22
5276: PUSH
5277: LD_INT 1
5279: PUSH
5280: EMPTY
5281: LIST
5282: LIST
5283: PPUSH
5284: CALL_OW 69
5288: PPUSH
5289: CALL_OW 1
5293: ST_TO_ADDR
// uc_side := 0 ;
5294: LD_ADDR_OWVAR 20
5298: PUSH
5299: LD_INT 0
5301: ST_TO_ADDR
// uc_nation := 0 ;
5302: LD_ADDR_OWVAR 21
5306: PUSH
5307: LD_INT 0
5309: ST_TO_ADDR
// for i = 1 to 4 do
5310: LD_ADDR_VAR 0 2
5314: PUSH
5315: DOUBLE
5316: LD_INT 1
5318: DEC
5319: ST_TO_ADDR
5320: LD_INT 4
5322: PUSH
5323: FOR_TO
5324: IFFALSE 5355
// begin InitHc ;
5326: CALL_OW 19
// hc_class := class_apeman ;
5330: LD_ADDR_OWVAR 28
5334: PUSH
5335: LD_INT 12
5337: ST_TO_ADDR
// PlaceUnitArea ( CreateHuman , powellApe , false ) ;
5338: CALL_OW 44
5342: PPUSH
5343: LD_INT 11
5345: PPUSH
5346: LD_INT 0
5348: PPUSH
5349: CALL_OW 49
// end ;
5353: GO 5323
5355: POP
5356: POP
// end ;
5357: LD_VAR 0 1
5361: RET
// every 11 11$30 trigger not americanDestroyed and not MC_GetVehicles ( 4 , true ) do var i , tmp , target ;
5362: LD_EXP 4
5366: NOT
5367: PUSH
5368: LD_INT 4
5370: PPUSH
5371: LD_INT 1
5373: PPUSH
5374: CALL 45329 0 2
5378: NOT
5379: AND
5380: IFFALSE 6152
5382: GO 5384
5384: DISABLE
5385: LD_INT 0
5387: PPUSH
5388: PPUSH
5389: PPUSH
// begin enable ;
5390: ENABLE
// if not FilterAllUnits ( [ [ f_side , 1 ] , [ f_nation , 1 ] , [ f_btype , b_factory ] ] ) then
5391: LD_INT 22
5393: PUSH
5394: LD_INT 1
5396: PUSH
5397: EMPTY
5398: LIST
5399: LIST
5400: PUSH
5401: LD_INT 23
5403: PUSH
5404: LD_INT 1
5406: PUSH
5407: EMPTY
5408: LIST
5409: LIST
5410: PUSH
5411: LD_INT 30
5413: PUSH
5414: LD_INT 3
5416: PUSH
5417: EMPTY
5418: LIST
5419: LIST
5420: PUSH
5421: EMPTY
5422: LIST
5423: LIST
5424: LIST
5425: PPUSH
5426: CALL_OW 69
5430: NOT
5431: IFFALSE 5435
// exit ;
5433: GO 6152
// if Prob ( 40 ) then
5435: LD_INT 40
5437: PPUSH
5438: CALL_OW 13
5442: IFFALSE 5569
// begin MC_InsertProduceList ( 4 , [ [ us_morphling , engine_combustion , control_remote , us_rocket_launcher ] , [ us_morphling , engine_combustion , control_remote , us_rocket_launcher ] , [ us_morphling , engine_combustion , control_remote , us_rocket_launcher ] , [ us_morphling , engine_combustion , control_remote , us_heavy_gun ] , [ us_morphling , engine_combustion , control_remote , us_heavy_gun ] , [ us_morphling , engine_combustion , control_remote , us_heavy_gun ] , ] ) ;
5444: LD_INT 4
5446: PPUSH
5447: LD_INT 5
5449: PUSH
5450: LD_INT 1
5452: PUSH
5453: LD_INT 2
5455: PUSH
5456: LD_INT 7
5458: PUSH
5459: EMPTY
5460: LIST
5461: LIST
5462: LIST
5463: LIST
5464: PUSH
5465: LD_INT 5
5467: PUSH
5468: LD_INT 1
5470: PUSH
5471: LD_INT 2
5473: PUSH
5474: LD_INT 7
5476: PUSH
5477: EMPTY
5478: LIST
5479: LIST
5480: LIST
5481: LIST
5482: PUSH
5483: LD_INT 5
5485: PUSH
5486: LD_INT 1
5488: PUSH
5489: LD_INT 2
5491: PUSH
5492: LD_INT 7
5494: PUSH
5495: EMPTY
5496: LIST
5497: LIST
5498: LIST
5499: LIST
5500: PUSH
5501: LD_INT 5
5503: PUSH
5504: LD_INT 1
5506: PUSH
5507: LD_INT 2
5509: PUSH
5510: LD_INT 6
5512: PUSH
5513: EMPTY
5514: LIST
5515: LIST
5516: LIST
5517: LIST
5518: PUSH
5519: LD_INT 5
5521: PUSH
5522: LD_INT 1
5524: PUSH
5525: LD_INT 2
5527: PUSH
5528: LD_INT 6
5530: PUSH
5531: EMPTY
5532: LIST
5533: LIST
5534: LIST
5535: LIST
5536: PUSH
5537: LD_INT 5
5539: PUSH
5540: LD_INT 1
5542: PUSH
5543: LD_INT 2
5545: PUSH
5546: LD_INT 6
5548: PUSH
5549: EMPTY
5550: LIST
5551: LIST
5552: LIST
5553: LIST
5554: PUSH
5555: EMPTY
5556: LIST
5557: LIST
5558: LIST
5559: LIST
5560: LIST
5561: LIST
5562: PPUSH
5563: CALL 43911 0 2
// end else
5567: GO 5692
// begin MC_InsertProduceList ( 4 , [ [ us_morphling , engine_combustion , control_remote , us_rocket_launcher ] , [ us_morphling , engine_combustion , control_remote , us_laser ] , [ us_morphling , engine_combustion , control_remote , us_laser ] , [ us_morphling , engine_combustion , control_remote , us_heavy_gun ] , [ us_morphling , engine_combustion , control_remote , us_heavy_gun ] , [ us_morphling , engine_combustion , control_remote , us_heavy_gun ] , ] ) ;
5569: LD_INT 4
5571: PPUSH
5572: LD_INT 5
5574: PUSH
5575: LD_INT 1
5577: PUSH
5578: LD_INT 2
5580: PUSH
5581: LD_INT 7
5583: PUSH
5584: EMPTY
5585: LIST
5586: LIST
5587: LIST
5588: LIST
5589: PUSH
5590: LD_INT 5
5592: PUSH
5593: LD_INT 1
5595: PUSH
5596: LD_INT 2
5598: PUSH
5599: LD_INT 9
5601: PUSH
5602: EMPTY
5603: LIST
5604: LIST
5605: LIST
5606: LIST
5607: PUSH
5608: LD_INT 5
5610: PUSH
5611: LD_INT 1
5613: PUSH
5614: LD_INT 2
5616: PUSH
5617: LD_INT 9
5619: PUSH
5620: EMPTY
5621: LIST
5622: LIST
5623: LIST
5624: LIST
5625: PUSH
5626: LD_INT 5
5628: PUSH
5629: LD_INT 1
5631: PUSH
5632: LD_INT 2
5634: PUSH
5635: LD_INT 6
5637: PUSH
5638: EMPTY
5639: LIST
5640: LIST
5641: LIST
5642: LIST
5643: PUSH
5644: LD_INT 5
5646: PUSH
5647: LD_INT 1
5649: PUSH
5650: LD_INT 2
5652: PUSH
5653: LD_INT 6
5655: PUSH
5656: EMPTY
5657: LIST
5658: LIST
5659: LIST
5660: LIST
5661: PUSH
5662: LD_INT 5
5664: PUSH
5665: LD_INT 1
5667: PUSH
5668: LD_INT 2
5670: PUSH
5671: LD_INT 6
5673: PUSH
5674: EMPTY
5675: LIST
5676: LIST
5677: LIST
5678: LIST
5679: PUSH
5680: EMPTY
5681: LIST
5682: LIST
5683: LIST
5684: LIST
5685: LIST
5686: LIST
5687: PPUSH
5688: CALL 43911 0 2
// end ; repeat wait ( 0 0$1 ) ;
5692: LD_INT 35
5694: PPUSH
5695: CALL_OW 67
// until MC_GetVehicles ( 4 , true ) >= 6 ;
5699: LD_INT 4
5701: PPUSH
5702: LD_INT 1
5704: PPUSH
5705: CALL 45329 0 2
5709: PUSH
5710: LD_INT 6
5712: GREATEREQUAL
5713: IFFALSE 5692
// wait ( 0 0$30 ) ;
5715: LD_INT 1050
5717: PPUSH
5718: CALL_OW 67
// tmp := MC_GetVehicles ( 4 , true ) ;
5722: LD_ADDR_VAR 0 2
5726: PUSH
5727: LD_INT 4
5729: PPUSH
5730: LD_INT 1
5732: PPUSH
5733: CALL 45329 0 2
5737: ST_TO_ADDR
// mc_vehicles := Replace ( mc_vehicles , 4 , mc_vehicles [ 4 ] diff tmp ) ;
5738: LD_ADDR_EXP 93
5742: PUSH
5743: LD_EXP 93
5747: PPUSH
5748: LD_INT 4
5750: PPUSH
5751: LD_EXP 93
5755: PUSH
5756: LD_INT 4
5758: ARRAY
5759: PUSH
5760: LD_VAR 0 2
5764: DIFF
5765: PPUSH
5766: CALL_OW 1
5770: ST_TO_ADDR
// target := rand ( 0 , 2 ) ;
5771: LD_ADDR_VAR 0 3
5775: PUSH
5776: LD_INT 0
5778: PPUSH
5779: LD_INT 2
5781: PPUSH
5782: CALL_OW 12
5786: ST_TO_ADDR
// if target then
5787: LD_VAR 0 3
5791: IFFALSE 5919
// begin repeat tmp := UnitFilter ( tmp , [ f_lives , 250 ] ) ;
5793: LD_ADDR_VAR 0 2
5797: PUSH
5798: LD_VAR 0 2
5802: PPUSH
5803: LD_INT 24
5805: PUSH
5806: LD_INT 250
5808: PUSH
5809: EMPTY
5810: LIST
5811: LIST
5812: PPUSH
5813: CALL_OW 72
5817: ST_TO_ADDR
// for i in tmp do
5818: LD_ADDR_VAR 0 1
5822: PUSH
5823: LD_VAR 0 2
5827: PUSH
5828: FOR_IN
5829: IFFALSE 5869
// if GetDistUnitXY ( i , 114 , 108 ) > 9 then
5831: LD_VAR 0 1
5835: PPUSH
5836: LD_INT 114
5838: PPUSH
5839: LD_INT 108
5841: PPUSH
5842: CALL_OW 297
5846: PUSH
5847: LD_INT 9
5849: GREATER
5850: IFFALSE 5867
// ComMoveXY ( i , 114 , 108 ) ;
5852: LD_VAR 0 1
5856: PPUSH
5857: LD_INT 114
5859: PPUSH
5860: LD_INT 108
5862: PPUSH
5863: CALL_OW 111
5867: GO 5828
5869: POP
5870: POP
// wait ( 0 0$1 ) ;
5871: LD_INT 35
5873: PPUSH
5874: CALL_OW 67
// until UnitFilter ( tmp , [ f_distxy , 114 , 108 , 9 ] ) >= ( tmp - 1 ) ;
5878: LD_VAR 0 2
5882: PPUSH
5883: LD_INT 92
5885: PUSH
5886: LD_INT 114
5888: PUSH
5889: LD_INT 108
5891: PUSH
5892: LD_INT 9
5894: PUSH
5895: EMPTY
5896: LIST
5897: LIST
5898: LIST
5899: LIST
5900: PPUSH
5901: CALL_OW 72
5905: PUSH
5906: LD_VAR 0 2
5910: PUSH
5911: LD_INT 1
5913: MINUS
5914: GREATEREQUAL
5915: IFFALSE 5793
// end else
5917: GO 6043
// begin repeat tmp := UnitFilter ( tmp , [ f_lives , 250 ] ) ;
5919: LD_ADDR_VAR 0 2
5923: PUSH
5924: LD_VAR 0 2
5928: PPUSH
5929: LD_INT 24
5931: PUSH
5932: LD_INT 250
5934: PUSH
5935: EMPTY
5936: LIST
5937: LIST
5938: PPUSH
5939: CALL_OW 72
5943: ST_TO_ADDR
// for i in tmp do
5944: LD_ADDR_VAR 0 1
5948: PUSH
5949: LD_VAR 0 2
5953: PUSH
5954: FOR_IN
5955: IFFALSE 5995
// if GetDistUnitXY ( i , 129 , 139 ) > 9 then
5957: LD_VAR 0 1
5961: PPUSH
5962: LD_INT 129
5964: PPUSH
5965: LD_INT 139
5967: PPUSH
5968: CALL_OW 297
5972: PUSH
5973: LD_INT 9
5975: GREATER
5976: IFFALSE 5993
// ComMoveXY ( i , 129 , 139 ) ;
5978: LD_VAR 0 1
5982: PPUSH
5983: LD_INT 129
5985: PPUSH
5986: LD_INT 139
5988: PPUSH
5989: CALL_OW 111
5993: GO 5954
5995: POP
5996: POP
// wait ( 0 0$1 ) ;
5997: LD_INT 35
5999: PPUSH
6000: CALL_OW 67
// until UnitFilter ( tmp , [ f_distxy , 129 , 139 , 9 ] ) >= ( tmp - 1 ) ;
6004: LD_VAR 0 2
6008: PPUSH
6009: LD_INT 92
6011: PUSH
6012: LD_INT 129
6014: PUSH
6015: LD_INT 139
6017: PUSH
6018: LD_INT 9
6020: PUSH
6021: EMPTY
6022: LIST
6023: LIST
6024: LIST
6025: LIST
6026: PPUSH
6027: CALL_OW 72
6031: PUSH
6032: LD_VAR 0 2
6036: PUSH
6037: LD_INT 1
6039: MINUS
6040: GREATEREQUAL
6041: IFFALSE 5919
// end ; repeat wait ( 0 0$1 ) ;
6043: LD_INT 35
6045: PPUSH
6046: CALL_OW 67
// for i in tmp do
6050: LD_ADDR_VAR 0 1
6054: PUSH
6055: LD_VAR 0 2
6059: PUSH
6060: FOR_IN
6061: IFFALSE 6143
// begin if GetLives ( i ) > 251 then
6063: LD_VAR 0 1
6067: PPUSH
6068: CALL_OW 256
6072: PUSH
6073: LD_INT 251
6075: GREATER
6076: IFFALSE 6114
// ComAttackUnit ( i , NearestUnitToUnit ( FilterAllUnits ( [ f_enemy , 1 ] ) , i ) ) else
6078: LD_VAR 0 1
6082: PPUSH
6083: LD_INT 81
6085: PUSH
6086: LD_INT 1
6088: PUSH
6089: EMPTY
6090: LIST
6091: LIST
6092: PPUSH
6093: CALL_OW 69
6097: PPUSH
6098: LD_VAR 0 1
6102: PPUSH
6103: CALL_OW 74
6107: PPUSH
6108: CALL_OW 115
6112: GO 6141
// if IsDead ( i ) then
6114: LD_VAR 0 1
6118: PPUSH
6119: CALL_OW 301
6123: IFFALSE 6141
// tmp := tmp diff i ;
6125: LD_ADDR_VAR 0 2
6129: PUSH
6130: LD_VAR 0 2
6134: PUSH
6135: LD_VAR 0 1
6139: DIFF
6140: ST_TO_ADDR
// end ;
6141: GO 6060
6143: POP
6144: POP
// until not tmp ;
6145: LD_VAR 0 2
6149: NOT
6150: IFFALSE 6043
// end ;
6152: PPOPN 3
6154: END
// every 30 30$00 trigger not americanDestroyed do
6155: LD_EXP 4
6159: NOT
6160: IFFALSE 6225
6162: GO 6164
6164: DISABLE
// begin wait ( [ 30 30$00 , 20 20$00 , 10 10$00 ] [ Difficulty ] ) ;
6165: LD_INT 63000
6167: PUSH
6168: LD_INT 42000
6170: PUSH
6171: LD_INT 21000
6173: PUSH
6174: EMPTY
6175: LIST
6176: LIST
6177: LIST
6178: PUSH
6179: LD_OWVAR 67
6183: ARRAY
6184: PPUSH
6185: CALL_OW 67
// if americanDestroyed then
6189: LD_EXP 4
6193: IFFALSE 6197
// exit ;
6195: GO 6225
// MC_InsertProduceList ( 4 , [ [ us_morphling , engine_siberite , control_manual , us_siberium_rocket ] ] ) ;
6197: LD_INT 4
6199: PPUSH
6200: LD_INT 5
6202: PUSH
6203: LD_INT 3
6205: PUSH
6206: LD_INT 1
6208: PUSH
6209: LD_INT 8
6211: PUSH
6212: EMPTY
6213: LIST
6214: LIST
6215: LIST
6216: LIST
6217: PUSH
6218: EMPTY
6219: LIST
6220: PPUSH
6221: CALL 43911 0 2
// end ; end_of_file
6225: END
// export function PrepareArabian ; var i , un , tmp , side ; begin
6226: LD_INT 0
6228: PPUSH
6229: PPUSH
6230: PPUSH
6231: PPUSH
6232: PPUSH
// side := 2 ;
6233: LD_ADDR_VAR 0 5
6237: PUSH
6238: LD_INT 2
6240: ST_TO_ADDR
// InitHc ;
6241: CALL_OW 19
// uc_side := side ;
6245: LD_ADDR_OWVAR 20
6249: PUSH
6250: LD_VAR 0 5
6254: ST_TO_ADDR
// uc_nation := 2 ;
6255: LD_ADDR_OWVAR 21
6259: PUSH
6260: LD_INT 2
6262: ST_TO_ADDR
// tmp := FilterAllUnits ( [ [ f_side , side ] , [ f_btype , b_bunker ] , [ f_empty ] ] ) ;
6263: LD_ADDR_VAR 0 4
6267: PUSH
6268: LD_INT 22
6270: PUSH
6271: LD_VAR 0 5
6275: PUSH
6276: EMPTY
6277: LIST
6278: LIST
6279: PUSH
6280: LD_INT 30
6282: PUSH
6283: LD_INT 32
6285: PUSH
6286: EMPTY
6287: LIST
6288: LIST
6289: PUSH
6290: LD_INT 58
6292: PUSH
6293: EMPTY
6294: LIST
6295: PUSH
6296: EMPTY
6297: LIST
6298: LIST
6299: LIST
6300: PPUSH
6301: CALL_OW 69
6305: ST_TO_ADDR
// for i = 1 to 10 do
6306: LD_ADDR_VAR 0 2
6310: PUSH
6311: DOUBLE
6312: LD_INT 1
6314: DEC
6315: ST_TO_ADDR
6316: LD_INT 10
6318: PUSH
6319: FOR_TO
6320: IFFALSE 6392
// begin uc_nation := nation_nature ;
6322: LD_ADDR_OWVAR 21
6326: PUSH
6327: LD_INT 0
6329: ST_TO_ADDR
// hc_class := class_apeman_soldier ;
6330: LD_ADDR_OWVAR 28
6334: PUSH
6335: LD_INT 15
6337: ST_TO_ADDR
// hc_gallery :=  ;
6338: LD_ADDR_OWVAR 33
6342: PUSH
6343: LD_STRING 
6345: ST_TO_ADDR
// hc_name :=  ;
6346: LD_ADDR_OWVAR 26
6350: PUSH
6351: LD_STRING 
6353: ST_TO_ADDR
// un := CreateHuman ;
6354: LD_ADDR_VAR 0 3
6358: PUSH
6359: CALL_OW 44
6363: ST_TO_ADDR
// PlaceHumanInUnit ( un , tmp [ tmp - i ] ) ;
6364: LD_VAR 0 3
6368: PPUSH
6369: LD_VAR 0 4
6373: PUSH
6374: LD_VAR 0 4
6378: PUSH
6379: LD_VAR 0 2
6383: MINUS
6384: ARRAY
6385: PPUSH
6386: CALL_OW 52
// end ;
6390: GO 6319
6392: POP
6393: POP
// PrepareBase ( ar_depot , arabianBaseArea ,  , [ 8 , 9 , 10 ] [ Difficulty ] , [ 3000 , 500 , 150 ] , [ 16 , 6 , 6 , 6 ] ) ;
6394: LD_INT 503
6396: PPUSH
6397: LD_INT 27
6399: PPUSH
6400: LD_STRING 
6402: PPUSH
6403: LD_INT 8
6405: PUSH
6406: LD_INT 9
6408: PUSH
6409: LD_INT 10
6411: PUSH
6412: EMPTY
6413: LIST
6414: LIST
6415: LIST
6416: PUSH
6417: LD_OWVAR 67
6421: ARRAY
6422: PPUSH
6423: LD_INT 3000
6425: PUSH
6426: LD_INT 500
6428: PUSH
6429: LD_INT 150
6431: PUSH
6432: EMPTY
6433: LIST
6434: LIST
6435: LIST
6436: PPUSH
6437: LD_INT 16
6439: PUSH
6440: LD_INT 6
6442: PUSH
6443: LD_INT 6
6445: PUSH
6446: LD_INT 6
6448: PUSH
6449: EMPTY
6450: LIST
6451: LIST
6452: LIST
6453: LIST
6454: PPUSH
6455: CALL 60690 0 6
// mc_bases := Replace ( mc_bases , 1 , FilterAllUnits ( [ [ f_side , side ] , [ f_nation , 2 ] , [ f_not , [ f_type , unit_vehicle ] ] ] ) ) ;
6459: LD_ADDR_EXP 74
6463: PUSH
6464: LD_EXP 74
6468: PPUSH
6469: LD_INT 1
6471: PPUSH
6472: LD_INT 22
6474: PUSH
6475: LD_VAR 0 5
6479: PUSH
6480: EMPTY
6481: LIST
6482: LIST
6483: PUSH
6484: LD_INT 23
6486: PUSH
6487: LD_INT 2
6489: PUSH
6490: EMPTY
6491: LIST
6492: LIST
6493: PUSH
6494: LD_INT 3
6496: PUSH
6497: LD_INT 21
6499: PUSH
6500: LD_INT 2
6502: PUSH
6503: EMPTY
6504: LIST
6505: LIST
6506: PUSH
6507: EMPTY
6508: LIST
6509: LIST
6510: PUSH
6511: EMPTY
6512: LIST
6513: LIST
6514: LIST
6515: PPUSH
6516: CALL_OW 69
6520: PPUSH
6521: CALL_OW 1
6525: ST_TO_ADDR
// end ;
6526: LD_VAR 0 1
6530: RET
// export Omar ; export function PrepareOmarAli ; begin
6531: LD_INT 0
6533: PPUSH
// uc_side := 5 ;
6534: LD_ADDR_OWVAR 20
6538: PUSH
6539: LD_INT 5
6541: ST_TO_ADDR
// uc_nation := 2 ;
6542: LD_ADDR_OWVAR 21
6546: PUSH
6547: LD_INT 2
6549: ST_TO_ADDR
// Omar := NewCharacter ( Omar ) ;
6550: LD_ADDR_EXP 48
6554: PUSH
6555: LD_STRING Omar
6557: PPUSH
6558: CALL_OW 25
6562: ST_TO_ADDR
// PlaceUnitXY ( Omar , 330 , 244 , false ) ;
6563: LD_EXP 48
6567: PPUSH
6568: LD_INT 330
6570: PPUSH
6571: LD_INT 244
6573: PPUSH
6574: LD_INT 0
6576: PPUSH
6577: CALL_OW 48
// ComMoveUnit ( Omar , NearestUnitToUnit ( FilterAllUnits ( [ f_side , 7 ] ) , Omar ) ) ;
6581: LD_EXP 48
6585: PPUSH
6586: LD_INT 22
6588: PUSH
6589: LD_INT 7
6591: PUSH
6592: EMPTY
6593: LIST
6594: LIST
6595: PPUSH
6596: CALL_OW 69
6600: PPUSH
6601: LD_EXP 48
6605: PPUSH
6606: CALL_OW 74
6610: PPUSH
6611: CALL_OW 112
// end ; end_of_file
6615: LD_VAR 0 1
6619: RET
// export Schulz , Kozlov ; export function PrepareLegion ; var i , side , un , tmp ; begin
6620: LD_INT 0
6622: PPUSH
6623: PPUSH
6624: PPUSH
6625: PPUSH
6626: PPUSH
// side := 8 ;
6627: LD_ADDR_VAR 0 3
6631: PUSH
6632: LD_INT 8
6634: ST_TO_ADDR
// InitHc ;
6635: CALL_OW 19
// uc_side := side ;
6639: LD_ADDR_OWVAR 20
6643: PUSH
6644: LD_VAR 0 3
6648: ST_TO_ADDR
// uc_nation := 2 ;
6649: LD_ADDR_OWVAR 21
6653: PUSH
6654: LD_INT 2
6656: ST_TO_ADDR
// for i in FilterAllUnits ( [ [ f_side , side ] , [ f_type , unit_building ] ] ) do
6657: LD_ADDR_VAR 0 2
6661: PUSH
6662: LD_INT 22
6664: PUSH
6665: LD_VAR 0 3
6669: PUSH
6670: EMPTY
6671: LIST
6672: LIST
6673: PUSH
6674: LD_INT 21
6676: PUSH
6677: LD_INT 3
6679: PUSH
6680: EMPTY
6681: LIST
6682: LIST
6683: PUSH
6684: EMPTY
6685: LIST
6686: LIST
6687: PPUSH
6688: CALL_OW 69
6692: PUSH
6693: FOR_IN
6694: IFFALSE 6710
// SetBLevel ( i , 10 ) ;
6696: LD_VAR 0 2
6700: PPUSH
6701: LD_INT 10
6703: PPUSH
6704: CALL_OW 241
6708: GO 6693
6710: POP
6711: POP
// Schulz := NewCharacter ( Schulz ) ;
6712: LD_ADDR_EXP 49
6716: PUSH
6717: LD_STRING Schulz
6719: PPUSH
6720: CALL_OW 25
6724: ST_TO_ADDR
// Kozlov := PrepareUnit ( Kozlov , false ,  ) ;
6725: LD_ADDR_EXP 50
6729: PUSH
6730: LD_STRING Kozlov
6732: PPUSH
6733: LD_INT 0
6735: PPUSH
6736: LD_STRING 
6738: PPUSH
6739: CALL 50255 0 3
6743: ST_TO_ADDR
// PlaceHumanInUnit ( Kozlov , FilterAllUnits ( [ [ f_side , 8 ] , [ f_nation , 3 ] , [ f_btype , b_lab_full ] ] ) [ 1 ] ) ;
6744: LD_EXP 50
6748: PPUSH
6749: LD_INT 22
6751: PUSH
6752: LD_INT 8
6754: PUSH
6755: EMPTY
6756: LIST
6757: LIST
6758: PUSH
6759: LD_INT 23
6761: PUSH
6762: LD_INT 3
6764: PUSH
6765: EMPTY
6766: LIST
6767: LIST
6768: PUSH
6769: LD_INT 30
6771: PUSH
6772: LD_INT 8
6774: PUSH
6775: EMPTY
6776: LIST
6777: LIST
6778: PUSH
6779: EMPTY
6780: LIST
6781: LIST
6782: LIST
6783: PPUSH
6784: CALL_OW 69
6788: PUSH
6789: LD_INT 1
6791: ARRAY
6792: PPUSH
6793: CALL_OW 52
// SetSkill ( Kozlov , class_mechanic , 10 ) ;
6797: LD_EXP 50
6801: PPUSH
6802: LD_INT 3
6804: PPUSH
6805: LD_INT 10
6807: PPUSH
6808: CALL_OW 237
// tmp := FilterAllUnits ( [ [ f_side , side ] , [ f_btype , b_bunker ] , [ f_empty ] ] ) ;
6812: LD_ADDR_VAR 0 5
6816: PUSH
6817: LD_INT 22
6819: PUSH
6820: LD_VAR 0 3
6824: PUSH
6825: EMPTY
6826: LIST
6827: LIST
6828: PUSH
6829: LD_INT 30
6831: PUSH
6832: LD_INT 32
6834: PUSH
6835: EMPTY
6836: LIST
6837: LIST
6838: PUSH
6839: LD_INT 58
6841: PUSH
6842: EMPTY
6843: LIST
6844: PUSH
6845: EMPTY
6846: LIST
6847: LIST
6848: LIST
6849: PPUSH
6850: CALL_OW 69
6854: ST_TO_ADDR
// for i = 1 to 10 do
6855: LD_ADDR_VAR 0 2
6859: PUSH
6860: DOUBLE
6861: LD_INT 1
6863: DEC
6864: ST_TO_ADDR
6865: LD_INT 10
6867: PUSH
6868: FOR_TO
6869: IFFALSE 6941
// begin uc_nation := nation_nature ;
6871: LD_ADDR_OWVAR 21
6875: PUSH
6876: LD_INT 0
6878: ST_TO_ADDR
// hc_class := class_apeman_soldier ;
6879: LD_ADDR_OWVAR 28
6883: PUSH
6884: LD_INT 15
6886: ST_TO_ADDR
// hc_gallery :=  ;
6887: LD_ADDR_OWVAR 33
6891: PUSH
6892: LD_STRING 
6894: ST_TO_ADDR
// hc_name :=  ;
6895: LD_ADDR_OWVAR 26
6899: PUSH
6900: LD_STRING 
6902: ST_TO_ADDR
// un := CreateHuman ;
6903: LD_ADDR_VAR 0 4
6907: PUSH
6908: CALL_OW 44
6912: ST_TO_ADDR
// PlaceHumanInUnit ( un , tmp [ tmp - i ] ) ;
6913: LD_VAR 0 4
6917: PPUSH
6918: LD_VAR 0 5
6922: PUSH
6923: LD_VAR 0 5
6927: PUSH
6928: LD_VAR 0 2
6932: MINUS
6933: ARRAY
6934: PPUSH
6935: CALL_OW 52
// end ;
6939: GO 6868
6941: POP
6942: POP
// PrepareBase ( ar_depot1 , legionBaseArea ,  , [ 8 , 9 , 10 ] [ Difficulty ] , [ 3000 , 500 , 150 ] , [ 16 , 6 , 6 , 8 ] ) ;
6943: LD_INT 324
6945: PPUSH
6946: LD_INT 3
6948: PPUSH
6949: LD_STRING 
6951: PPUSH
6952: LD_INT 8
6954: PUSH
6955: LD_INT 9
6957: PUSH
6958: LD_INT 10
6960: PUSH
6961: EMPTY
6962: LIST
6963: LIST
6964: LIST
6965: PUSH
6966: LD_OWVAR 67
6970: ARRAY
6971: PPUSH
6972: LD_INT 3000
6974: PUSH
6975: LD_INT 500
6977: PUSH
6978: LD_INT 150
6980: PUSH
6981: EMPTY
6982: LIST
6983: LIST
6984: LIST
6985: PPUSH
6986: LD_INT 16
6988: PUSH
6989: LD_INT 6
6991: PUSH
6992: LD_INT 6
6994: PUSH
6995: LD_INT 8
6997: PUSH
6998: EMPTY
6999: LIST
7000: LIST
7001: LIST
7002: LIST
7003: PPUSH
7004: CALL 60690 0 6
// mc_bases := Replace ( mc_bases , 3 , FilterAllUnits ( [ [ f_side , side ] , [ f_nation , 2 ] , [ f_not , [ f_type , unit_vehicle ] ] ] ) diff Schulz ) ;
7008: LD_ADDR_EXP 74
7012: PUSH
7013: LD_EXP 74
7017: PPUSH
7018: LD_INT 3
7020: PPUSH
7021: LD_INT 22
7023: PUSH
7024: LD_VAR 0 3
7028: PUSH
7029: EMPTY
7030: LIST
7031: LIST
7032: PUSH
7033: LD_INT 23
7035: PUSH
7036: LD_INT 2
7038: PUSH
7039: EMPTY
7040: LIST
7041: LIST
7042: PUSH
7043: LD_INT 3
7045: PUSH
7046: LD_INT 21
7048: PUSH
7049: LD_INT 2
7051: PUSH
7052: EMPTY
7053: LIST
7054: LIST
7055: PUSH
7056: EMPTY
7057: LIST
7058: LIST
7059: PUSH
7060: EMPTY
7061: LIST
7062: LIST
7063: LIST
7064: PPUSH
7065: CALL_OW 69
7069: PUSH
7070: LD_EXP 49
7074: DIFF
7075: PPUSH
7076: CALL_OW 1
7080: ST_TO_ADDR
// end ;
7081: LD_VAR 0 1
7085: RET
// export function BuildKozlovBomb ; begin
7086: LD_INT 0
7088: PPUSH
// if not IsOk ( kozlov_fac ) or not IsOk ( kozlov_lab ) then
7089: LD_INT 332
7091: PPUSH
7092: CALL_OW 302
7096: NOT
7097: PUSH
7098: LD_INT 336
7100: PPUSH
7101: CALL_OW 302
7105: NOT
7106: OR
7107: IFFALSE 7111
// exit ;
7109: GO 7208
// ComChangeProfession ( Kozlov , 4 ) ;
7111: LD_EXP 50
7115: PPUSH
7116: LD_INT 4
7118: PPUSH
7119: CALL_OW 123
// ComResearch ( kozlov_lab , tech_sibFiss ) ;
7123: LD_INT 336
7125: PPUSH
7126: LD_INT 25
7128: PPUSH
7129: CALL_OW 124
// repeat wait ( 0 0$1 ) ;
7133: LD_INT 35
7135: PPUSH
7136: CALL_OW 67
// until GetTech ( tech_sibFiss , 8 ) = state_researched ;
7140: LD_INT 25
7142: PPUSH
7143: LD_INT 8
7145: PPUSH
7146: CALL_OW 321
7150: PUSH
7151: LD_INT 2
7153: EQUAL
7154: IFFALSE 7133
// ComExitBuilding ( Kozlov ) ;
7156: LD_EXP 50
7160: PPUSH
7161: CALL_OW 122
// AddComEnterUnit ( Kozlov , kozlov_fac ) ;
7165: LD_EXP 50
7169: PPUSH
7170: LD_INT 332
7172: PPUSH
7173: CALL_OW 180
// AddComChangeProfession ( Kozlov , 3 ) ;
7177: LD_EXP 50
7181: PPUSH
7182: LD_INT 3
7184: PPUSH
7185: CALL_OW 183
// ComConstruct ( kozlov_fac , ru_heavy_wheeled , engine_siberite , control_manual , ru_siberium_rocket ) ;
7189: LD_INT 332
7191: PPUSH
7192: LD_INT 23
7194: PPUSH
7195: LD_INT 3
7197: PPUSH
7198: LD_INT 1
7200: PPUSH
7201: LD_INT 48
7203: PPUSH
7204: CALL_OW 125
// end ;
7208: LD_VAR 0 1
7212: RET
// every 11 11$30 trigger not legionDestroyed and not MC_GetVehicles ( 3 , true ) do var i , tmp , target ;
7213: LD_EXP 3
7217: NOT
7218: PUSH
7219: LD_INT 3
7221: PPUSH
7222: LD_INT 1
7224: PPUSH
7225: CALL 45329 0 2
7229: NOT
7230: AND
7231: IFFALSE 8071
7233: GO 7235
7235: DISABLE
7236: LD_INT 0
7238: PPUSH
7239: PPUSH
7240: PPUSH
// begin enable ;
7241: ENABLE
// if not FilterAllUnits ( [ [ f_side , 8 ] , [ f_nation , 2 ] , [ f_btype , b_factory ] ] ) then
7242: LD_INT 22
7244: PUSH
7245: LD_INT 8
7247: PUSH
7248: EMPTY
7249: LIST
7250: LIST
7251: PUSH
7252: LD_INT 23
7254: PUSH
7255: LD_INT 2
7257: PUSH
7258: EMPTY
7259: LIST
7260: LIST
7261: PUSH
7262: LD_INT 30
7264: PUSH
7265: LD_INT 3
7267: PUSH
7268: EMPTY
7269: LIST
7270: LIST
7271: PUSH
7272: EMPTY
7273: LIST
7274: LIST
7275: LIST
7276: PPUSH
7277: CALL_OW 69
7281: NOT
7282: IFFALSE 7286
// exit ;
7284: GO 8071
// if Prob ( 40 ) then
7286: LD_INT 40
7288: PPUSH
7289: CALL_OW 13
7293: IFFALSE 7420
// begin MC_InsertProduceList ( 3 , [ [ ar_half_tracked , engine_combustion , control_remote , ar_rocket_launcher ] , [ ar_half_tracked , engine_combustion , control_remote , ar_rocket_launcher ] , [ ar_half_tracked , engine_combustion , control_remote , ar_rocket_launcher ] , [ ar_half_tracked , engine_combustion , control_remote , ar_rocket_launcher ] , [ ar_half_tracked , engine_combustion , control_remote , ar_rocket_launcher ] , [ ar_half_tracked , engine_combustion , control_remote , ar_flame_thrower ] , ] ) ;
7295: LD_INT 3
7297: PPUSH
7298: LD_INT 14
7300: PUSH
7301: LD_INT 1
7303: PUSH
7304: LD_INT 2
7306: PUSH
7307: LD_INT 28
7309: PUSH
7310: EMPTY
7311: LIST
7312: LIST
7313: LIST
7314: LIST
7315: PUSH
7316: LD_INT 14
7318: PUSH
7319: LD_INT 1
7321: PUSH
7322: LD_INT 2
7324: PUSH
7325: LD_INT 28
7327: PUSH
7328: EMPTY
7329: LIST
7330: LIST
7331: LIST
7332: LIST
7333: PUSH
7334: LD_INT 14
7336: PUSH
7337: LD_INT 1
7339: PUSH
7340: LD_INT 2
7342: PUSH
7343: LD_INT 28
7345: PUSH
7346: EMPTY
7347: LIST
7348: LIST
7349: LIST
7350: LIST
7351: PUSH
7352: LD_INT 14
7354: PUSH
7355: LD_INT 1
7357: PUSH
7358: LD_INT 2
7360: PUSH
7361: LD_INT 28
7363: PUSH
7364: EMPTY
7365: LIST
7366: LIST
7367: LIST
7368: LIST
7369: PUSH
7370: LD_INT 14
7372: PUSH
7373: LD_INT 1
7375: PUSH
7376: LD_INT 2
7378: PUSH
7379: LD_INT 28
7381: PUSH
7382: EMPTY
7383: LIST
7384: LIST
7385: LIST
7386: LIST
7387: PUSH
7388: LD_INT 14
7390: PUSH
7391: LD_INT 1
7393: PUSH
7394: LD_INT 2
7396: PUSH
7397: LD_INT 26
7399: PUSH
7400: EMPTY
7401: LIST
7402: LIST
7403: LIST
7404: LIST
7405: PUSH
7406: EMPTY
7407: LIST
7408: LIST
7409: LIST
7410: LIST
7411: LIST
7412: LIST
7413: PPUSH
7414: CALL 43911 0 2
// end else
7418: GO 7611
// begin MC_InsertProduceList ( 3 , [ [ ar_half_tracked , engine_combustion , control_remote , [ ar_gun , ar_flame_thrower , ar_flame_thrower ] [ Difficulty ] ] , [ ar_half_tracked , engine_combustion , control_remote , [ ar_gun , ar_flame_thrower , ar_flame_thrower ] [ Difficulty ] ] , [ ar_half_tracked , engine_combustion , control_remote , [ ar_flame_thrower , ar_flame_thrower , ar_selfpropelled_bomb ] [ Difficulty ] ] , [ ar_medium_trike , engine_combustion , control_remote , [ ar_flame_thrower , ar_selfpropelled_bomb , ar_selfpropelled_bomb ] [ Difficulty ] ] , [ ar_medium_trike , engine_combustion , control_remote , ar_selfpropelled_bomb ] , [ ar_half_tracked , engine_combustion , control_remote , ar_flame_thrower ] , ] ) ;
7420: LD_INT 3
7422: PPUSH
7423: LD_INT 14
7425: PUSH
7426: LD_INT 1
7428: PUSH
7429: LD_INT 2
7431: PUSH
7432: LD_INT 27
7434: PUSH
7435: LD_INT 26
7437: PUSH
7438: LD_INT 26
7440: PUSH
7441: EMPTY
7442: LIST
7443: LIST
7444: LIST
7445: PUSH
7446: LD_OWVAR 67
7450: ARRAY
7451: PUSH
7452: EMPTY
7453: LIST
7454: LIST
7455: LIST
7456: LIST
7457: PUSH
7458: LD_INT 14
7460: PUSH
7461: LD_INT 1
7463: PUSH
7464: LD_INT 2
7466: PUSH
7467: LD_INT 27
7469: PUSH
7470: LD_INT 26
7472: PUSH
7473: LD_INT 26
7475: PUSH
7476: EMPTY
7477: LIST
7478: LIST
7479: LIST
7480: PUSH
7481: LD_OWVAR 67
7485: ARRAY
7486: PUSH
7487: EMPTY
7488: LIST
7489: LIST
7490: LIST
7491: LIST
7492: PUSH
7493: LD_INT 14
7495: PUSH
7496: LD_INT 1
7498: PUSH
7499: LD_INT 2
7501: PUSH
7502: LD_INT 26
7504: PUSH
7505: LD_INT 26
7507: PUSH
7508: LD_INT 29
7510: PUSH
7511: EMPTY
7512: LIST
7513: LIST
7514: LIST
7515: PUSH
7516: LD_OWVAR 67
7520: ARRAY
7521: PUSH
7522: EMPTY
7523: LIST
7524: LIST
7525: LIST
7526: LIST
7527: PUSH
7528: LD_INT 13
7530: PUSH
7531: LD_INT 1
7533: PUSH
7534: LD_INT 2
7536: PUSH
7537: LD_INT 26
7539: PUSH
7540: LD_INT 29
7542: PUSH
7543: LD_INT 29
7545: PUSH
7546: EMPTY
7547: LIST
7548: LIST
7549: LIST
7550: PUSH
7551: LD_OWVAR 67
7555: ARRAY
7556: PUSH
7557: EMPTY
7558: LIST
7559: LIST
7560: LIST
7561: LIST
7562: PUSH
7563: LD_INT 13
7565: PUSH
7566: LD_INT 1
7568: PUSH
7569: LD_INT 2
7571: PUSH
7572: LD_INT 29
7574: PUSH
7575: EMPTY
7576: LIST
7577: LIST
7578: LIST
7579: LIST
7580: PUSH
7581: LD_INT 14
7583: PUSH
7584: LD_INT 1
7586: PUSH
7587: LD_INT 2
7589: PUSH
7590: LD_INT 26
7592: PUSH
7593: EMPTY
7594: LIST
7595: LIST
7596: LIST
7597: LIST
7598: PUSH
7599: EMPTY
7600: LIST
7601: LIST
7602: LIST
7603: LIST
7604: LIST
7605: LIST
7606: PPUSH
7607: CALL 43911 0 2
// end ; repeat wait ( 0 0$1 ) ;
7611: LD_INT 35
7613: PPUSH
7614: CALL_OW 67
// until MC_GetVehicles ( 3 , true ) >= 6 ;
7618: LD_INT 3
7620: PPUSH
7621: LD_INT 1
7623: PPUSH
7624: CALL 45329 0 2
7628: PUSH
7629: LD_INT 6
7631: GREATEREQUAL
7632: IFFALSE 7611
// wait ( 0 0$30 ) ;
7634: LD_INT 1050
7636: PPUSH
7637: CALL_OW 67
// tmp := MC_GetVehicles ( 3 , true ) ;
7641: LD_ADDR_VAR 0 2
7645: PUSH
7646: LD_INT 3
7648: PPUSH
7649: LD_INT 1
7651: PPUSH
7652: CALL 45329 0 2
7656: ST_TO_ADDR
// mc_vehicles := Replace ( mc_vehicles , 3 , mc_vehicles [ 3 ] diff tmp ) ;
7657: LD_ADDR_EXP 93
7661: PUSH
7662: LD_EXP 93
7666: PPUSH
7667: LD_INT 3
7669: PPUSH
7670: LD_EXP 93
7674: PUSH
7675: LD_INT 3
7677: ARRAY
7678: PUSH
7679: LD_VAR 0 2
7683: DIFF
7684: PPUSH
7685: CALL_OW 1
7689: ST_TO_ADDR
// target := rand ( 0 , 2 ) ;
7690: LD_ADDR_VAR 0 3
7694: PUSH
7695: LD_INT 0
7697: PPUSH
7698: LD_INT 2
7700: PPUSH
7701: CALL_OW 12
7705: ST_TO_ADDR
// if target then
7706: LD_VAR 0 3
7710: IFFALSE 7838
// begin repeat tmp := UnitFilter ( tmp , [ f_lives , 250 ] ) ;
7712: LD_ADDR_VAR 0 2
7716: PUSH
7717: LD_VAR 0 2
7721: PPUSH
7722: LD_INT 24
7724: PUSH
7725: LD_INT 250
7727: PUSH
7728: EMPTY
7729: LIST
7730: LIST
7731: PPUSH
7732: CALL_OW 72
7736: ST_TO_ADDR
// for i in tmp do
7737: LD_ADDR_VAR 0 1
7741: PUSH
7742: LD_VAR 0 2
7746: PUSH
7747: FOR_IN
7748: IFFALSE 7788
// if GetDistUnitXY ( i , 89 , 71 ) > 9 then
7750: LD_VAR 0 1
7754: PPUSH
7755: LD_INT 89
7757: PPUSH
7758: LD_INT 71
7760: PPUSH
7761: CALL_OW 297
7765: PUSH
7766: LD_INT 9
7768: GREATER
7769: IFFALSE 7786
// ComMoveXY ( i , 89 , 71 ) ;
7771: LD_VAR 0 1
7775: PPUSH
7776: LD_INT 89
7778: PPUSH
7779: LD_INT 71
7781: PPUSH
7782: CALL_OW 111
7786: GO 7747
7788: POP
7789: POP
// wait ( 0 0$1 ) ;
7790: LD_INT 35
7792: PPUSH
7793: CALL_OW 67
// until UnitFilter ( tmp , [ f_distxy , 89 , 71 , 9 ] ) >= ( tmp - 1 ) ;
7797: LD_VAR 0 2
7801: PPUSH
7802: LD_INT 92
7804: PUSH
7805: LD_INT 89
7807: PUSH
7808: LD_INT 71
7810: PUSH
7811: LD_INT 9
7813: PUSH
7814: EMPTY
7815: LIST
7816: LIST
7817: LIST
7818: LIST
7819: PPUSH
7820: CALL_OW 72
7824: PUSH
7825: LD_VAR 0 2
7829: PUSH
7830: LD_INT 1
7832: MINUS
7833: GREATEREQUAL
7834: IFFALSE 7712
// end else
7836: GO 7962
// begin repeat tmp := UnitFilter ( tmp , [ f_lives , 250 ] ) ;
7838: LD_ADDR_VAR 0 2
7842: PUSH
7843: LD_VAR 0 2
7847: PPUSH
7848: LD_INT 24
7850: PUSH
7851: LD_INT 250
7853: PUSH
7854: EMPTY
7855: LIST
7856: LIST
7857: PPUSH
7858: CALL_OW 72
7862: ST_TO_ADDR
// for i in tmp do
7863: LD_ADDR_VAR 0 1
7867: PUSH
7868: LD_VAR 0 2
7872: PUSH
7873: FOR_IN
7874: IFFALSE 7914
// if GetDistUnitXY ( i , 147 , 4 ) > 9 then
7876: LD_VAR 0 1
7880: PPUSH
7881: LD_INT 147
7883: PPUSH
7884: LD_INT 4
7886: PPUSH
7887: CALL_OW 297
7891: PUSH
7892: LD_INT 9
7894: GREATER
7895: IFFALSE 7912
// ComMoveXY ( i , 147 , 4 ) ;
7897: LD_VAR 0 1
7901: PPUSH
7902: LD_INT 147
7904: PPUSH
7905: LD_INT 4
7907: PPUSH
7908: CALL_OW 111
7912: GO 7873
7914: POP
7915: POP
// wait ( 0 0$1 ) ;
7916: LD_INT 35
7918: PPUSH
7919: CALL_OW 67
// until UnitFilter ( tmp , [ f_distxy , 147 , 4 , 9 ] ) >= ( tmp - 1 ) ;
7923: LD_VAR 0 2
7927: PPUSH
7928: LD_INT 92
7930: PUSH
7931: LD_INT 147
7933: PUSH
7934: LD_INT 4
7936: PUSH
7937: LD_INT 9
7939: PUSH
7940: EMPTY
7941: LIST
7942: LIST
7943: LIST
7944: LIST
7945: PPUSH
7946: CALL_OW 72
7950: PUSH
7951: LD_VAR 0 2
7955: PUSH
7956: LD_INT 1
7958: MINUS
7959: GREATEREQUAL
7960: IFFALSE 7838
// end ; repeat wait ( 0 0$1 ) ;
7962: LD_INT 35
7964: PPUSH
7965: CALL_OW 67
// for i in tmp do
7969: LD_ADDR_VAR 0 1
7973: PUSH
7974: LD_VAR 0 2
7978: PUSH
7979: FOR_IN
7980: IFFALSE 8062
// begin if GetLives ( i ) > 251 then
7982: LD_VAR 0 1
7986: PPUSH
7987: CALL_OW 256
7991: PUSH
7992: LD_INT 251
7994: GREATER
7995: IFFALSE 8033
// ComAttackUnit ( i , NearestUnitToUnit ( FilterAllUnits ( [ f_enemy , 8 ] ) , i ) ) else
7997: LD_VAR 0 1
8001: PPUSH
8002: LD_INT 81
8004: PUSH
8005: LD_INT 8
8007: PUSH
8008: EMPTY
8009: LIST
8010: LIST
8011: PPUSH
8012: CALL_OW 69
8016: PPUSH
8017: LD_VAR 0 1
8021: PPUSH
8022: CALL_OW 74
8026: PPUSH
8027: CALL_OW 115
8031: GO 8060
// if IsDead ( i ) then
8033: LD_VAR 0 1
8037: PPUSH
8038: CALL_OW 301
8042: IFFALSE 8060
// tmp := tmp diff i ;
8044: LD_ADDR_VAR 0 2
8048: PUSH
8049: LD_VAR 0 2
8053: PUSH
8054: LD_VAR 0 1
8058: DIFF
8059: ST_TO_ADDR
// end ;
8060: GO 7979
8062: POP
8063: POP
// until not tmp ;
8064: LD_VAR 0 2
8068: NOT
8069: IFFALSE 7962
// end ;
8071: PPOPN 3
8073: END
// every 0 0$1 trigger IsOk ( Kozlov ) and not legionDestroyed do
8074: LD_EXP 50
8078: PPUSH
8079: CALL_OW 302
8083: PUSH
8084: LD_EXP 3
8088: NOT
8089: AND
8090: IFFALSE 8099
8092: GO 8094
8094: DISABLE
// BuildKozlovBomb ;
8095: CALL 7086 0 0
8099: END
// every 0 0$3 trigger FilterAllUnits ( [ [ f_side , 8 ] , [ f_weapon , ru_siberium_rocket ] ] ) do
8100: LD_INT 22
8102: PUSH
8103: LD_INT 8
8105: PUSH
8106: EMPTY
8107: LIST
8108: LIST
8109: PUSH
8110: LD_INT 34
8112: PUSH
8113: LD_INT 48
8115: PUSH
8116: EMPTY
8117: LIST
8118: LIST
8119: PUSH
8120: EMPTY
8121: LIST
8122: LIST
8123: PPUSH
8124: CALL_OW 69
8128: IFFALSE 8176
8130: GO 8132
8132: DISABLE
// begin ComAttackPlace ( FilterAllUnits ( [ [ f_side , 8 ] , [ f_weapon , ru_siberium_rocket ] ] ) [ 1 ] , 173 , 96 ) ;
8133: LD_INT 22
8135: PUSH
8136: LD_INT 8
8138: PUSH
8139: EMPTY
8140: LIST
8141: LIST
8142: PUSH
8143: LD_INT 34
8145: PUSH
8146: LD_INT 48
8148: PUSH
8149: EMPTY
8150: LIST
8151: LIST
8152: PUSH
8153: EMPTY
8154: LIST
8155: LIST
8156: PPUSH
8157: CALL_OW 69
8161: PUSH
8162: LD_INT 1
8164: ARRAY
8165: PPUSH
8166: LD_INT 173
8168: PPUSH
8169: LD_INT 96
8171: PPUSH
8172: CALL_OW 116
// end ; end_of_file
8176: END
// export Platonov , Yakotich , Gleb , Bierezov ; export behemoths , behemothBuilders ; export function PrepareRussian ; var i , j , base , tmp , side , xy , b , teleport ; begin
8177: LD_INT 0
8179: PPUSH
8180: PPUSH
8181: PPUSH
8182: PPUSH
8183: PPUSH
8184: PPUSH
8185: PPUSH
8186: PPUSH
8187: PPUSH
// side := 3 ;
8188: LD_ADDR_VAR 0 6
8192: PUSH
8193: LD_INT 3
8195: ST_TO_ADDR
// InitHc ;
8196: CALL_OW 19
// uc_side := side ;
8200: LD_ADDR_OWVAR 20
8204: PUSH
8205: LD_VAR 0 6
8209: ST_TO_ADDR
// uc_nation := 3 ;
8210: LD_ADDR_OWVAR 21
8214: PUSH
8215: LD_INT 3
8217: ST_TO_ADDR
// for i in FilterAllUnits ( [ [ f_side , side ] , [ f_type , unit_building ] ] ) do
8218: LD_ADDR_VAR 0 2
8222: PUSH
8223: LD_INT 22
8225: PUSH
8226: LD_VAR 0 6
8230: PUSH
8231: EMPTY
8232: LIST
8233: LIST
8234: PUSH
8235: LD_INT 21
8237: PUSH
8238: LD_INT 3
8240: PUSH
8241: EMPTY
8242: LIST
8243: LIST
8244: PUSH
8245: EMPTY
8246: LIST
8247: LIST
8248: PPUSH
8249: CALL_OW 69
8253: PUSH
8254: FOR_IN
8255: IFFALSE 8271
// SetBLevel ( i , 10 ) ;
8257: LD_VAR 0 2
8261: PPUSH
8262: LD_INT 10
8264: PPUSH
8265: CALL_OW 241
8269: GO 8254
8271: POP
8272: POP
// teleport := FilterAllUnits ( [ [ f_side , side ] , [ f_btype , b_teleport ] ] ) ;
8273: LD_ADDR_VAR 0 9
8277: PUSH
8278: LD_INT 22
8280: PUSH
8281: LD_VAR 0 6
8285: PUSH
8286: EMPTY
8287: LIST
8288: LIST
8289: PUSH
8290: LD_INT 30
8292: PUSH
8293: LD_INT 34
8295: PUSH
8296: EMPTY
8297: LIST
8298: LIST
8299: PUSH
8300: EMPTY
8301: LIST
8302: LIST
8303: PPUSH
8304: CALL_OW 69
8308: ST_TO_ADDR
// if teleport then
8309: LD_VAR 0 9
8313: IFFALSE 8334
// TeleportExit ( teleport [ 1 ] , 123 , 122 ) ;
8315: LD_VAR 0 9
8319: PUSH
8320: LD_INT 1
8322: ARRAY
8323: PPUSH
8324: LD_INT 123
8326: PPUSH
8327: LD_INT 122
8329: PPUSH
8330: CALL_OW 243
// hc_importance := 0 ;
8334: LD_ADDR_OWVAR 32
8338: PUSH
8339: LD_INT 0
8341: ST_TO_ADDR
// Platonov := NewCharacter ( Platonov ) ;
8342: LD_ADDR_EXP 51
8346: PUSH
8347: LD_STRING Platonov
8349: PPUSH
8350: CALL_OW 25
8354: ST_TO_ADDR
// Yakotich := NewCharacter ( Yakotich ) ;
8355: LD_ADDR_EXP 52
8359: PUSH
8360: LD_STRING Yakotich
8362: PPUSH
8363: CALL_OW 25
8367: ST_TO_ADDR
// Gleb := NewCharacter ( Gleb ) ;
8368: LD_ADDR_EXP 53
8372: PUSH
8373: LD_STRING Gleb
8375: PPUSH
8376: CALL_OW 25
8380: ST_TO_ADDR
// if TestCharacters ( 03_Cornel ) then
8381: LD_STRING 03_Cornel
8383: PPUSH
8384: CALL_OW 28
8388: IFFALSE 8436
// begin Bierezov := NewCharacter ( Mikhail ) ;
8390: LD_ADDR_EXP 54
8394: PUSH
8395: LD_STRING Mikhail
8397: PPUSH
8398: CALL_OW 25
8402: ST_TO_ADDR
// PlaceUnitXYR ( Bierezov , 197 , 111 , 9 , false ) ;
8403: LD_EXP 54
8407: PPUSH
8408: LD_INT 197
8410: PPUSH
8411: LD_INT 111
8413: PPUSH
8414: LD_INT 9
8416: PPUSH
8417: LD_INT 0
8419: PPUSH
8420: CALL_OW 50
// SetClass ( Bierezov , 3 ) ;
8424: LD_EXP 54
8428: PPUSH
8429: LD_INT 3
8431: PPUSH
8432: CALL_OW 336
// end ; PlaceHumanInUnit ( Platonov , ru_depot ) ;
8436: LD_EXP 51
8440: PPUSH
8441: LD_INT 126
8443: PPUSH
8444: CALL_OW 52
// PlaceUnitXYR ( Yakotich , 197 , 111 , 9 , false ) ;
8448: LD_EXP 52
8452: PPUSH
8453: LD_INT 197
8455: PPUSH
8456: LD_INT 111
8458: PPUSH
8459: LD_INT 9
8461: PPUSH
8462: LD_INT 0
8464: PPUSH
8465: CALL_OW 50
// PlaceUnitXYR ( Gleb , 197 , 111 , 9 , false ) ;
8469: LD_EXP 53
8473: PPUSH
8474: LD_INT 197
8476: PPUSH
8477: LD_INT 111
8479: PPUSH
8480: LD_INT 9
8482: PPUSH
8483: LD_INT 0
8485: PPUSH
8486: CALL_OW 50
// tmp := PrepareBase ( ru_depot , russianBaseArea , zhukov , [ 9 , 10 , 10 ] [ Difficulty ] , [ 90000 , 1000 , 300 ] , [ 21 , 8 , 13 , 8 ] ) ;
8490: LD_ADDR_VAR 0 5
8494: PUSH
8495: LD_INT 126
8497: PPUSH
8498: LD_INT 2
8500: PPUSH
8501: LD_STRING zhukov
8503: PPUSH
8504: LD_INT 9
8506: PUSH
8507: LD_INT 10
8509: PUSH
8510: LD_INT 10
8512: PUSH
8513: EMPTY
8514: LIST
8515: LIST
8516: LIST
8517: PUSH
8518: LD_OWVAR 67
8522: ARRAY
8523: PPUSH
8524: LD_INT 90000
8526: PUSH
8527: LD_INT 1000
8529: PUSH
8530: LD_INT 300
8532: PUSH
8533: EMPTY
8534: LIST
8535: LIST
8536: LIST
8537: PPUSH
8538: LD_INT 21
8540: PUSH
8541: LD_INT 8
8543: PUSH
8544: LD_INT 13
8546: PUSH
8547: LD_INT 8
8549: PUSH
8550: EMPTY
8551: LIST
8552: LIST
8553: LIST
8554: LIST
8555: PPUSH
8556: CALL 60690 0 6
8560: ST_TO_ADDR
// base := GetBase ( ru_depot2 ) ;
8561: LD_ADDR_VAR 0 4
8565: PUSH
8566: LD_INT 267
8568: PPUSH
8569: CALL_OW 274
8573: ST_TO_ADDR
// SetResourceType ( base , mat_cans , 5000 ) ;
8574: LD_VAR 0 4
8578: PPUSH
8579: LD_INT 1
8581: PPUSH
8582: LD_INT 5000
8584: PPUSH
8585: CALL_OW 277
// SetResourceType ( base , mat_oil , 200 ) ;
8589: LD_VAR 0 4
8593: PPUSH
8594: LD_INT 2
8596: PPUSH
8597: LD_INT 200
8599: PPUSH
8600: CALL_OW 277
// SetResourceType ( base , mat_siberit , 200 ) ;
8604: LD_VAR 0 4
8608: PPUSH
8609: LD_INT 3
8611: PPUSH
8612: LD_INT 200
8614: PPUSH
8615: CALL_OW 277
// mc_bases := Replace ( mc_bases , 2 , tmp union FilterAllUnits ( [ [ f_side , side ] , [ f_not , [ f_type , unit_vehicle ] ] ] ) diff Platonov ) ;
8619: LD_ADDR_EXP 74
8623: PUSH
8624: LD_EXP 74
8628: PPUSH
8629: LD_INT 2
8631: PPUSH
8632: LD_VAR 0 5
8636: PUSH
8637: LD_INT 22
8639: PUSH
8640: LD_VAR 0 6
8644: PUSH
8645: EMPTY
8646: LIST
8647: LIST
8648: PUSH
8649: LD_INT 3
8651: PUSH
8652: LD_INT 21
8654: PUSH
8655: LD_INT 2
8657: PUSH
8658: EMPTY
8659: LIST
8660: LIST
8661: PUSH
8662: EMPTY
8663: LIST
8664: LIST
8665: PUSH
8666: EMPTY
8667: LIST
8668: LIST
8669: PPUSH
8670: CALL_OW 69
8674: UNION
8675: PUSH
8676: LD_EXP 51
8680: DIFF
8681: PPUSH
8682: CALL_OW 1
8686: ST_TO_ADDR
// behemoths := [ ] ;
8687: LD_ADDR_EXP 55
8691: PUSH
8692: EMPTY
8693: ST_TO_ADDR
// behemothBuilders := [ ] ;
8694: LD_ADDR_EXP 56
8698: PUSH
8699: EMPTY
8700: ST_TO_ADDR
// j := 3 ;
8701: LD_ADDR_VAR 0 3
8705: PUSH
8706: LD_INT 3
8708: ST_TO_ADDR
// for i in FilterAllUnits ( [ [ f_side , 3 ] , [ f_class , 3 ] ] ) do
8709: LD_ADDR_VAR 0 2
8713: PUSH
8714: LD_INT 22
8716: PUSH
8717: LD_INT 3
8719: PUSH
8720: EMPTY
8721: LIST
8722: LIST
8723: PUSH
8724: LD_INT 25
8726: PUSH
8727: LD_INT 3
8729: PUSH
8730: EMPTY
8731: LIST
8732: LIST
8733: PUSH
8734: EMPTY
8735: LIST
8736: LIST
8737: PPUSH
8738: CALL_OW 69
8742: PUSH
8743: FOR_IN
8744: IFFALSE 8794
// begin behemothBuilders := Join ( behemothBuilders , i ) ;
8746: LD_ADDR_EXP 56
8750: PUSH
8751: LD_EXP 56
8755: PPUSH
8756: LD_VAR 0 2
8760: PPUSH
8761: CALL 93026 0 2
8765: ST_TO_ADDR
// j := j - 1 ;
8766: LD_ADDR_VAR 0 3
8770: PUSH
8771: LD_VAR 0 3
8775: PUSH
8776: LD_INT 1
8778: MINUS
8779: ST_TO_ADDR
// if j = 0 then
8780: LD_VAR 0 3
8784: PUSH
8785: LD_INT 0
8787: EQUAL
8788: IFFALSE 8792
// break ;
8790: GO 8794
// end ;
8792: GO 8743
8794: POP
8795: POP
// end ;
8796: LD_VAR 0 1
8800: RET
// export function BuildBehemoths ; var i , j , xy , tmp ; begin
8801: LD_INT 0
8803: PPUSH
8804: PPUSH
8805: PPUSH
8806: PPUSH
8807: PPUSH
// xy := [ [ 209 , 149 ] , [ 219 , 154 ] , [ 223 , 149 ] , [ 232 , 155 ] ] ;
8808: LD_ADDR_VAR 0 4
8812: PUSH
8813: LD_INT 209
8815: PUSH
8816: LD_INT 149
8818: PUSH
8819: EMPTY
8820: LIST
8821: LIST
8822: PUSH
8823: LD_INT 219
8825: PUSH
8826: LD_INT 154
8828: PUSH
8829: EMPTY
8830: LIST
8831: LIST
8832: PUSH
8833: LD_INT 223
8835: PUSH
8836: LD_INT 149
8838: PUSH
8839: EMPTY
8840: LIST
8841: LIST
8842: PUSH
8843: LD_INT 232
8845: PUSH
8846: LD_INT 155
8848: PUSH
8849: EMPTY
8850: LIST
8851: LIST
8852: PUSH
8853: EMPTY
8854: LIST
8855: LIST
8856: LIST
8857: LIST
8858: ST_TO_ADDR
// if not behemothBuilders then
8859: LD_EXP 56
8863: NOT
8864: IFFALSE 8868
// exit ;
8866: GO 8972
// j := 1 ;
8868: LD_ADDR_VAR 0 3
8872: PUSH
8873: LD_INT 1
8875: ST_TO_ADDR
// for i in behemothBuilders do
8876: LD_ADDR_VAR 0 2
8880: PUSH
8881: LD_EXP 56
8885: PUSH
8886: FOR_IN
8887: IFFALSE 8970
// begin if IsInUnit ( i ) then
8889: LD_VAR 0 2
8893: PPUSH
8894: CALL_OW 310
8898: IFFALSE 8909
// ComExitBuilding ( i ) ;
8900: LD_VAR 0 2
8904: PPUSH
8905: CALL_OW 122
// AddComBuildBehemoth ( i , b_behemoth , xy [ j ] [ 1 ] , xy [ j ] [ 2 ] , 0 ) ;
8909: LD_VAR 0 2
8913: PPUSH
8914: LD_INT 37
8916: PPUSH
8917: LD_VAR 0 4
8921: PUSH
8922: LD_VAR 0 3
8926: ARRAY
8927: PUSH
8928: LD_INT 1
8930: ARRAY
8931: PPUSH
8932: LD_VAR 0 4
8936: PUSH
8937: LD_VAR 0 3
8941: ARRAY
8942: PUSH
8943: LD_INT 2
8945: ARRAY
8946: PPUSH
8947: LD_INT 0
8949: PPUSH
8950: CALL_OW 230
// j := j + 1 ;
8954: LD_ADDR_VAR 0 3
8958: PUSH
8959: LD_VAR 0 3
8963: PUSH
8964: LD_INT 1
8966: PLUS
8967: ST_TO_ADDR
// end ;
8968: GO 8886
8970: POP
8971: POP
// end ;
8972: LD_VAR 0 1
8976: RET
// every 0 0$3 trigger GetBehemoths ( 3 ) and not FilterAllUnits ( [ [ f_side , 3 ] , [ f_btype , b_behemoth ] ] ) do var i , tmp ;
8977: LD_INT 3
8979: PPUSH
8980: CALL 93074 0 1
8984: PUSH
8985: LD_INT 22
8987: PUSH
8988: LD_INT 3
8990: PUSH
8991: EMPTY
8992: LIST
8993: LIST
8994: PUSH
8995: LD_INT 30
8997: PUSH
8998: LD_INT 37
9000: PUSH
9001: EMPTY
9002: LIST
9003: LIST
9004: PUSH
9005: EMPTY
9006: LIST
9007: LIST
9008: PPUSH
9009: CALL_OW 69
9013: NOT
9014: AND
9015: IFFALSE 9201
9017: GO 9019
9019: DISABLE
9020: LD_INT 0
9022: PPUSH
9023: PPUSH
// begin enable ;
9024: ENABLE
// tmp := GetBehemoths ( 3 ) ;
9025: LD_ADDR_VAR 0 2
9029: PUSH
9030: LD_INT 3
9032: PPUSH
9033: CALL 93074 0 1
9037: ST_TO_ADDR
// for i in tmp do
9038: LD_ADDR_VAR 0 1
9042: PUSH
9043: LD_VAR 0 2
9047: PUSH
9048: FOR_IN
9049: IFFALSE 9199
// begin if IsInArea ( i , powellBase ) and not GetTag ( i ) = 2 then
9051: LD_VAR 0 1
9055: PPUSH
9056: LD_INT 7
9058: PPUSH
9059: CALL_OW 308
9063: PUSH
9064: LD_VAR 0 1
9068: PPUSH
9069: CALL_OW 110
9073: PUSH
9074: LD_INT 2
9076: EQUAL
9077: NOT
9078: AND
9079: IFFALSE 9093
// SetTag ( i , 2 ) ;
9081: LD_VAR 0 1
9085: PPUSH
9086: LD_INT 2
9088: PPUSH
9089: CALL_OW 109
// if not FilterAllUnits ( [ [ f_enemy , 3 ] , [ f_dist , i , 12 ] ] ) and not GetTag ( i ) = 2 then
9093: LD_INT 81
9095: PUSH
9096: LD_INT 3
9098: PUSH
9099: EMPTY
9100: LIST
9101: LIST
9102: PUSH
9103: LD_INT 91
9105: PUSH
9106: LD_VAR 0 1
9110: PUSH
9111: LD_INT 12
9113: PUSH
9114: EMPTY
9115: LIST
9116: LIST
9117: LIST
9118: PUSH
9119: EMPTY
9120: LIST
9121: LIST
9122: PPUSH
9123: CALL_OW 69
9127: NOT
9128: PUSH
9129: LD_VAR 0 1
9133: PPUSH
9134: CALL_OW 110
9138: PUSH
9139: LD_INT 2
9141: EQUAL
9142: NOT
9143: AND
9144: IFFALSE 9163
// ComAgressiveMove ( i , 64 , 93 ) else
9146: LD_VAR 0 1
9150: PPUSH
9151: LD_INT 64
9153: PPUSH
9154: LD_INT 93
9156: PPUSH
9157: CALL_OW 114
9161: GO 9197
// ComAttackUnit ( i , NearestUnitToUnit ( FilterAllUnits ( [ f_enemy , 3 ] ) , i ) ) ;
9163: LD_VAR 0 1
9167: PPUSH
9168: LD_INT 81
9170: PUSH
9171: LD_INT 3
9173: PUSH
9174: EMPTY
9175: LIST
9176: LIST
9177: PPUSH
9178: CALL_OW 69
9182: PPUSH
9183: LD_VAR 0 1
9187: PPUSH
9188: CALL_OW 74
9192: PPUSH
9193: CALL_OW 115
// end ;
9197: GO 9048
9199: POP
9200: POP
// end ;
9201: PPOPN 2
9203: END
// every 11 11$30 trigger not russianDestroyed and not MC_GetVehicles ( 2 , true ) do var i , tmp , target , teleport ;
9204: LD_EXP 2
9208: NOT
9209: PUSH
9210: LD_INT 2
9212: PPUSH
9213: LD_INT 1
9215: PPUSH
9216: CALL 45329 0 2
9220: NOT
9221: AND
9222: IFFALSE 10142
9224: GO 9226
9226: DISABLE
9227: LD_INT 0
9229: PPUSH
9230: PPUSH
9231: PPUSH
9232: PPUSH
// begin enable ;
9233: ENABLE
// if not FilterAllUnits ( [ [ f_side , 3 ] , [ f_btype , b_factory ] ] ) then
9234: LD_INT 22
9236: PUSH
9237: LD_INT 3
9239: PUSH
9240: EMPTY
9241: LIST
9242: LIST
9243: PUSH
9244: LD_INT 30
9246: PUSH
9247: LD_INT 3
9249: PUSH
9250: EMPTY
9251: LIST
9252: LIST
9253: PUSH
9254: EMPTY
9255: LIST
9256: LIST
9257: PPUSH
9258: CALL_OW 69
9262: NOT
9263: IFFALSE 9267
// exit ;
9265: GO 10142
// teleport := FilterAllUnits ( [ [ f_side , 3 ] , [ f_btype , b_teleport ] ] ) ;
9267: LD_ADDR_VAR 0 4
9271: PUSH
9272: LD_INT 22
9274: PUSH
9275: LD_INT 3
9277: PUSH
9278: EMPTY
9279: LIST
9280: LIST
9281: PUSH
9282: LD_INT 30
9284: PUSH
9285: LD_INT 34
9287: PUSH
9288: EMPTY
9289: LIST
9290: LIST
9291: PUSH
9292: EMPTY
9293: LIST
9294: LIST
9295: PPUSH
9296: CALL_OW 69
9300: ST_TO_ADDR
// if Prob ( 40 ) then
9301: LD_INT 40
9303: PPUSH
9304: CALL_OW 13
9308: IFFALSE 9435
// begin MC_InsertProduceList ( 2 , [ [ ru_medium_tracked , engine_siberite , control_computer , ru_time_lapser ] , [ ru_medium_tracked , engine_siberite , control_computer , ru_time_lapser ] , [ ru_medium_tracked , engine_siberite , control_computer , ru_time_lapser ] , [ ru_heavy_tracked , engine_siberite , control_computer , ru_heavy_gun ] , [ ru_heavy_tracked , engine_siberite , control_computer , ru_heavy_gun ] , [ ru_heavy_tracked , engine_siberite , control_computer , ru_heavy_gun ] ] ) ;
9310: LD_INT 2
9312: PPUSH
9313: LD_INT 22
9315: PUSH
9316: LD_INT 3
9318: PUSH
9319: LD_INT 3
9321: PUSH
9322: LD_INT 49
9324: PUSH
9325: EMPTY
9326: LIST
9327: LIST
9328: LIST
9329: LIST
9330: PUSH
9331: LD_INT 22
9333: PUSH
9334: LD_INT 3
9336: PUSH
9337: LD_INT 3
9339: PUSH
9340: LD_INT 49
9342: PUSH
9343: EMPTY
9344: LIST
9345: LIST
9346: LIST
9347: LIST
9348: PUSH
9349: LD_INT 22
9351: PUSH
9352: LD_INT 3
9354: PUSH
9355: LD_INT 3
9357: PUSH
9358: LD_INT 49
9360: PUSH
9361: EMPTY
9362: LIST
9363: LIST
9364: LIST
9365: LIST
9366: PUSH
9367: LD_INT 24
9369: PUSH
9370: LD_INT 3
9372: PUSH
9373: LD_INT 3
9375: PUSH
9376: LD_INT 46
9378: PUSH
9379: EMPTY
9380: LIST
9381: LIST
9382: LIST
9383: LIST
9384: PUSH
9385: LD_INT 24
9387: PUSH
9388: LD_INT 3
9390: PUSH
9391: LD_INT 3
9393: PUSH
9394: LD_INT 46
9396: PUSH
9397: EMPTY
9398: LIST
9399: LIST
9400: LIST
9401: LIST
9402: PUSH
9403: LD_INT 24
9405: PUSH
9406: LD_INT 3
9408: PUSH
9409: LD_INT 3
9411: PUSH
9412: LD_INT 46
9414: PUSH
9415: EMPTY
9416: LIST
9417: LIST
9418: LIST
9419: LIST
9420: PUSH
9421: EMPTY
9422: LIST
9423: LIST
9424: LIST
9425: LIST
9426: LIST
9427: LIST
9428: PPUSH
9429: CALL 43911 0 2
// end else
9433: GO 9558
// begin MC_InsertProduceList ( 2 , [ [ ru_heavy_tracked , engine_siberite , control_computer , ru_rocket ] , [ ru_heavy_tracked , engine_siberite , control_computer , ru_rocket ] , [ ru_heavy_tracked , engine_siberite , control_computer , ru_rocket ] , [ ru_heavy_tracked , engine_siberite , control_computer , ru_heavy_gun ] , [ ru_heavy_tracked , engine_siberite , control_computer , ru_heavy_gun ] , [ ru_heavy_tracked , engine_siberite , control_computer , ru_heavy_gun ] ] ) ;
9435: LD_INT 2
9437: PPUSH
9438: LD_INT 24
9440: PUSH
9441: LD_INT 3
9443: PUSH
9444: LD_INT 3
9446: PUSH
9447: LD_INT 47
9449: PUSH
9450: EMPTY
9451: LIST
9452: LIST
9453: LIST
9454: LIST
9455: PUSH
9456: LD_INT 24
9458: PUSH
9459: LD_INT 3
9461: PUSH
9462: LD_INT 3
9464: PUSH
9465: LD_INT 47
9467: PUSH
9468: EMPTY
9469: LIST
9470: LIST
9471: LIST
9472: LIST
9473: PUSH
9474: LD_INT 24
9476: PUSH
9477: LD_INT 3
9479: PUSH
9480: LD_INT 3
9482: PUSH
9483: LD_INT 47
9485: PUSH
9486: EMPTY
9487: LIST
9488: LIST
9489: LIST
9490: LIST
9491: PUSH
9492: LD_INT 24
9494: PUSH
9495: LD_INT 3
9497: PUSH
9498: LD_INT 3
9500: PUSH
9501: LD_INT 46
9503: PUSH
9504: EMPTY
9505: LIST
9506: LIST
9507: LIST
9508: LIST
9509: PUSH
9510: LD_INT 24
9512: PUSH
9513: LD_INT 3
9515: PUSH
9516: LD_INT 3
9518: PUSH
9519: LD_INT 46
9521: PUSH
9522: EMPTY
9523: LIST
9524: LIST
9525: LIST
9526: LIST
9527: PUSH
9528: LD_INT 24
9530: PUSH
9531: LD_INT 3
9533: PUSH
9534: LD_INT 3
9536: PUSH
9537: LD_INT 46
9539: PUSH
9540: EMPTY
9541: LIST
9542: LIST
9543: LIST
9544: LIST
9545: PUSH
9546: EMPTY
9547: LIST
9548: LIST
9549: LIST
9550: LIST
9551: LIST
9552: LIST
9553: PPUSH
9554: CALL 43911 0 2
// end ; if Difficulty > 1 then
9558: LD_OWVAR 67
9562: PUSH
9563: LD_INT 1
9565: GREATER
9566: IFFALSE 9596
// MC_InsertProduceList ( 2 , [ [ ru_heavy_tracked , engine_siberite , control_computer , ru_rocket ] ] ) ;
9568: LD_INT 2
9570: PPUSH
9571: LD_INT 24
9573: PUSH
9574: LD_INT 3
9576: PUSH
9577: LD_INT 3
9579: PUSH
9580: LD_INT 47
9582: PUSH
9583: EMPTY
9584: LIST
9585: LIST
9586: LIST
9587: LIST
9588: PUSH
9589: EMPTY
9590: LIST
9591: PPUSH
9592: CALL 43911 0 2
// repeat wait ( 0 0$1 ) ;
9596: LD_INT 35
9598: PPUSH
9599: CALL_OW 67
// until MC_GetVehicles ( 2 , true ) >= [ 6 , 7 , 7 ] [ Difficulty ] ;
9603: LD_INT 2
9605: PPUSH
9606: LD_INT 1
9608: PPUSH
9609: CALL 45329 0 2
9613: PUSH
9614: LD_INT 6
9616: PUSH
9617: LD_INT 7
9619: PUSH
9620: LD_INT 7
9622: PUSH
9623: EMPTY
9624: LIST
9625: LIST
9626: LIST
9627: PUSH
9628: LD_OWVAR 67
9632: ARRAY
9633: GREATEREQUAL
9634: IFFALSE 9596
// wait ( 0 0$30 ) ;
9636: LD_INT 1050
9638: PPUSH
9639: CALL_OW 67
// tmp := MC_GetVehicles ( 2 , true ) ;
9643: LD_ADDR_VAR 0 2
9647: PUSH
9648: LD_INT 2
9650: PPUSH
9651: LD_INT 1
9653: PPUSH
9654: CALL 45329 0 2
9658: ST_TO_ADDR
// mc_vehicles := Replace ( mc_vehicles , 2 , mc_vehicles [ 2 ] diff tmp ) ;
9659: LD_ADDR_EXP 93
9663: PUSH
9664: LD_EXP 93
9668: PPUSH
9669: LD_INT 2
9671: PPUSH
9672: LD_EXP 93
9676: PUSH
9677: LD_INT 2
9679: ARRAY
9680: PUSH
9681: LD_VAR 0 2
9685: DIFF
9686: PPUSH
9687: CALL_OW 1
9691: ST_TO_ADDR
// target := rand ( 0 , 1 ) ;
9692: LD_ADDR_VAR 0 3
9696: PUSH
9697: LD_INT 0
9699: PPUSH
9700: LD_INT 1
9702: PPUSH
9703: CALL_OW 12
9707: ST_TO_ADDR
// if target then
9708: LD_VAR 0 3
9712: IFFALSE 9840
// begin repeat tmp := UnitFilter ( tmp , [ f_lives , 250 ] ) ;
9714: LD_ADDR_VAR 0 2
9718: PUSH
9719: LD_VAR 0 2
9723: PPUSH
9724: LD_INT 24
9726: PUSH
9727: LD_INT 250
9729: PUSH
9730: EMPTY
9731: LIST
9732: LIST
9733: PPUSH
9734: CALL_OW 72
9738: ST_TO_ADDR
// for i in tmp do
9739: LD_ADDR_VAR 0 1
9743: PUSH
9744: LD_VAR 0 2
9748: PUSH
9749: FOR_IN
9750: IFFALSE 9790
// if GetDistUnitXY ( i , 139 , 89 ) > 9 then
9752: LD_VAR 0 1
9756: PPUSH
9757: LD_INT 139
9759: PPUSH
9760: LD_INT 89
9762: PPUSH
9763: CALL_OW 297
9767: PUSH
9768: LD_INT 9
9770: GREATER
9771: IFFALSE 9788
// ComMoveXY ( i , 139 , 89 ) ;
9773: LD_VAR 0 1
9777: PPUSH
9778: LD_INT 139
9780: PPUSH
9781: LD_INT 89
9783: PPUSH
9784: CALL_OW 111
9788: GO 9749
9790: POP
9791: POP
// wait ( 0 0$1 ) ;
9792: LD_INT 35
9794: PPUSH
9795: CALL_OW 67
// until UnitFilter ( tmp , [ f_distxy , 139 , 89 , 9 ] ) >= ( tmp - 1 ) ;
9799: LD_VAR 0 2
9803: PPUSH
9804: LD_INT 92
9806: PUSH
9807: LD_INT 139
9809: PUSH
9810: LD_INT 89
9812: PUSH
9813: LD_INT 9
9815: PUSH
9816: EMPTY
9817: LIST
9818: LIST
9819: LIST
9820: LIST
9821: PPUSH
9822: CALL_OW 72
9826: PUSH
9827: LD_VAR 0 2
9831: PUSH
9832: LD_INT 1
9834: MINUS
9835: GREATEREQUAL
9836: IFFALSE 9714
// end else
9838: GO 9982
// begin ComEnterUnit ( tmp , teleport [ 1 ] ) ;
9840: LD_VAR 0 2
9844: PPUSH
9845: LD_VAR 0 4
9849: PUSH
9850: LD_INT 1
9852: ARRAY
9853: PPUSH
9854: CALL_OW 120
// repeat tmp := UnitFilter ( tmp , [ f_lives , 250 ] ) ;
9858: LD_ADDR_VAR 0 2
9862: PUSH
9863: LD_VAR 0 2
9867: PPUSH
9868: LD_INT 24
9870: PUSH
9871: LD_INT 250
9873: PUSH
9874: EMPTY
9875: LIST
9876: LIST
9877: PPUSH
9878: CALL_OW 72
9882: ST_TO_ADDR
// for i in tmp do
9883: LD_ADDR_VAR 0 1
9887: PUSH
9888: LD_VAR 0 2
9892: PUSH
9893: FOR_IN
9894: IFFALSE 9934
// if GetDistUnitXY ( i , 124 , 139 ) > 9 then
9896: LD_VAR 0 1
9900: PPUSH
9901: LD_INT 124
9903: PPUSH
9904: LD_INT 139
9906: PPUSH
9907: CALL_OW 297
9911: PUSH
9912: LD_INT 9
9914: GREATER
9915: IFFALSE 9932
// ComMoveXY ( i , 124 , 139 ) ;
9917: LD_VAR 0 1
9921: PPUSH
9922: LD_INT 124
9924: PPUSH
9925: LD_INT 139
9927: PPUSH
9928: CALL_OW 111
9932: GO 9893
9934: POP
9935: POP
// wait ( 0 0$1 ) ;
9936: LD_INT 35
9938: PPUSH
9939: CALL_OW 67
// until UnitFilter ( tmp , [ f_distxy , 124 , 139 , 9 ] ) >= ( tmp - 1 ) ;
9943: LD_VAR 0 2
9947: PPUSH
9948: LD_INT 92
9950: PUSH
9951: LD_INT 124
9953: PUSH
9954: LD_INT 139
9956: PUSH
9957: LD_INT 9
9959: PUSH
9960: EMPTY
9961: LIST
9962: LIST
9963: LIST
9964: LIST
9965: PPUSH
9966: CALL_OW 72
9970: PUSH
9971: LD_VAR 0 2
9975: PUSH
9976: LD_INT 1
9978: MINUS
9979: GREATEREQUAL
9980: IFFALSE 9858
// end ; repeat wait ( 0 0$1 ) ;
9982: LD_INT 35
9984: PPUSH
9985: CALL_OW 67
// for i in tmp do
9989: LD_ADDR_VAR 0 1
9993: PUSH
9994: LD_VAR 0 2
9998: PUSH
9999: FOR_IN
10000: IFFALSE 10133
// begin if GetLives ( i ) > 251 then
10002: LD_VAR 0 1
10006: PPUSH
10007: CALL_OW 256
10011: PUSH
10012: LD_INT 251
10014: GREATER
10015: IFFALSE 10104
// begin if GetWeapon ( i ) = ru_time_lapser then
10017: LD_VAR 0 1
10021: PPUSH
10022: CALL_OW 264
10026: PUSH
10027: LD_INT 49
10029: EQUAL
10030: IFFALSE 10068
// ComMoveUnit ( i , NearestUnitToUnit ( FilterAllUnits ( [ f_enemy , 3 ] ) , i ) ) else
10032: LD_VAR 0 1
10036: PPUSH
10037: LD_INT 81
10039: PUSH
10040: LD_INT 3
10042: PUSH
10043: EMPTY
10044: LIST
10045: LIST
10046: PPUSH
10047: CALL_OW 69
10051: PPUSH
10052: LD_VAR 0 1
10056: PPUSH
10057: CALL_OW 74
10061: PPUSH
10062: CALL_OW 112
10066: GO 10102
// ComAttackUnit ( i , NearestUnitToUnit ( FilterAllUnits ( [ f_enemy , 3 ] ) , i ) ) ;
10068: LD_VAR 0 1
10072: PPUSH
10073: LD_INT 81
10075: PUSH
10076: LD_INT 3
10078: PUSH
10079: EMPTY
10080: LIST
10081: LIST
10082: PPUSH
10083: CALL_OW 69
10087: PPUSH
10088: LD_VAR 0 1
10092: PPUSH
10093: CALL_OW 74
10097: PPUSH
10098: CALL_OW 115
// end else
10102: GO 10131
// if IsDead ( i ) then
10104: LD_VAR 0 1
10108: PPUSH
10109: CALL_OW 301
10113: IFFALSE 10131
// tmp := tmp diff i ;
10115: LD_ADDR_VAR 0 2
10119: PUSH
10120: LD_VAR 0 2
10124: PUSH
10125: LD_VAR 0 1
10129: DIFF
10130: ST_TO_ADDR
// end ;
10131: GO 9999
10133: POP
10134: POP
// until not tmp ;
10135: LD_VAR 0 2
10139: NOT
10140: IFFALSE 9982
// end ;
10142: PPOPN 4
10144: END
// every 30 30$00 trigger not russianDestroyed do
10145: LD_EXP 2
10149: NOT
10150: IFFALSE 10215
10152: GO 10154
10154: DISABLE
// begin wait ( [ 50 50$00 , 40 40$00 , 30 30$00 ] [ Difficulty ] ) ;
10155: LD_INT 105000
10157: PUSH
10158: LD_INT 84000
10160: PUSH
10161: LD_INT 63000
10163: PUSH
10164: EMPTY
10165: LIST
10166: LIST
10167: LIST
10168: PUSH
10169: LD_OWVAR 67
10173: ARRAY
10174: PPUSH
10175: CALL_OW 67
// if russianDestroyed then
10179: LD_EXP 2
10183: IFFALSE 10187
// exit ;
10185: GO 10215
// MC_InsertProduceList ( 2 , [ [ ru_heavy_wheeled , engine_siberite , control_manual , ru_siberium_rocket ] ] ) ;
10187: LD_INT 2
10189: PPUSH
10190: LD_INT 23
10192: PUSH
10193: LD_INT 3
10195: PUSH
10196: LD_INT 1
10198: PUSH
10199: LD_INT 48
10201: PUSH
10202: EMPTY
10203: LIST
10204: LIST
10205: LIST
10206: LIST
10207: PUSH
10208: EMPTY
10209: LIST
10210: PPUSH
10211: CALL 43911 0 2
// end ; end_of_file
10215: END
// export function CustomEvent ( event ) ; begin
10216: LD_INT 0
10218: PPUSH
// end ;
10219: LD_VAR 0 2
10223: RET
// on SibDepositContaminated ( unit , x , y ) do begin if InArea ( x , y , motherLodeArea ) then
10224: LD_VAR 0 2
10228: PPUSH
10229: LD_VAR 0 3
10233: PPUSH
10234: LD_INT 15
10236: PPUSH
10237: CALL_OW 309
10241: IFFALSE 10250
// YouLost ( MothContaminate ) ;
10243: LD_STRING MothContaminate
10245: PPUSH
10246: CALL_OW 104
// end ;
10250: PPOPN 3
10252: END
// on SiberiteRocketExploded ( unit , x , y ) do begin if InArea ( x , y , motherLodeArea ) then
10253: LD_VAR 0 2
10257: PPUSH
10258: LD_VAR 0 3
10262: PPUSH
10263: LD_INT 15
10265: PPUSH
10266: CALL_OW 309
10270: IFFALSE 10286
// begin wait ( 0 0$6 ) ;
10272: LD_INT 210
10274: PPUSH
10275: CALL_OW 67
// YouLost ( MothContaminateBomb ) ;
10279: LD_STRING MothContaminateBomb
10281: PPUSH
10282: CALL_OW 104
// end ; end ;
10286: PPOPN 3
10288: END
// on UnitDestroyed ( un ) do begin if un = JMM then
10289: LD_VAR 0 1
10293: PUSH
10294: LD_EXP 12
10298: EQUAL
10299: IFFALSE 10310
// begin YouLost ( JMM ) ;
10301: LD_STRING JMM
10303: PPUSH
10304: CALL_OW 104
// exit ;
10308: GO 10359
// end ; if un = Powell then
10310: LD_VAR 0 1
10314: PUSH
10315: LD_EXP 47
10319: EQUAL
10320: IFFALSE 10330
// americanDestroyed := true ;
10322: LD_ADDR_EXP 4
10326: PUSH
10327: LD_INT 1
10329: ST_TO_ADDR
// if un = Platonov then
10330: LD_VAR 0 1
10334: PUSH
10335: LD_EXP 51
10339: EQUAL
10340: IFFALSE 10350
// russianDestroyed := true ;
10342: LD_ADDR_EXP 2
10346: PUSH
10347: LD_INT 1
10349: ST_TO_ADDR
// MCE_UnitDestroyed ( un ) ;
10350: LD_VAR 0 1
10354: PPUSH
10355: CALL 47303 0 1
// end ;
10359: PPOPN 1
10361: END
// on BuildingStarted ( building , builder ) do begin MCE_BuildingStarted ( building , builder ) ;
10362: LD_VAR 0 1
10366: PPUSH
10367: LD_VAR 0 2
10371: PPUSH
10372: CALL 49637 0 2
// end ;
10376: PPOPN 2
10378: END
// on UpgradeComplete ( building ) do begin MCE_UpgradeComplete ( building ) ;
10379: LD_VAR 0 1
10383: PPUSH
10384: CALL 48705 0 1
// end ;
10388: PPOPN 1
10390: END
// on BuildingComplete ( building ) do begin if building in FilterAllUnits ( [ [ f_side , 8 ] , [ f_btype , b_workshop ] , [ f_nation , 3 ] ] ) then
10391: LD_VAR 0 1
10395: PUSH
10396: LD_INT 22
10398: PUSH
10399: LD_INT 8
10401: PUSH
10402: EMPTY
10403: LIST
10404: LIST
10405: PUSH
10406: LD_INT 30
10408: PUSH
10409: LD_INT 2
10411: PUSH
10412: EMPTY
10413: LIST
10414: LIST
10415: PUSH
10416: LD_INT 23
10418: PUSH
10419: LD_INT 3
10421: PUSH
10422: EMPTY
10423: LIST
10424: LIST
10425: PUSH
10426: EMPTY
10427: LIST
10428: LIST
10429: LIST
10430: PPUSH
10431: CALL_OW 69
10435: IN
10436: IFFALSE 10463
// begin ComUpgrade ( building ) ;
10438: LD_VAR 0 1
10442: PPUSH
10443: CALL_OW 146
// ComComplete ( Kozlov , building ) ;
10447: LD_EXP 50
10451: PPUSH
10452: LD_VAR 0 1
10456: PPUSH
10457: CALL 60254 0 2
// exit ;
10461: GO 10472
// end ; MCE_BuildingComplete ( building ) ;
10463: LD_VAR 0 1
10467: PPUSH
10468: CALL 48946 0 1
// end ;
10472: PPOPN 1
10474: END
// on ResearchComplete ( tech , lab ) do begin MCE_ResearchComplete ( tech , lab ) ;
10475: LD_VAR 0 1
10479: PPUSH
10480: LD_VAR 0 2
10484: PPUSH
10485: CALL 46999 0 2
// end ;
10489: PPOPN 2
10491: END
// on CrateSpawn ( id , x , y , amount , mode ) do begin MCE_CrateSpawn ( id , x , y , amount , mode ) ;
10492: LD_VAR 0 1
10496: PPUSH
10497: LD_VAR 0 2
10501: PPUSH
10502: LD_VAR 0 3
10506: PPUSH
10507: LD_VAR 0 4
10511: PPUSH
10512: LD_VAR 0 5
10516: PPUSH
10517: CALL 46619 0 5
// end ;
10521: PPOPN 5
10523: END
// on VehicleConstructed ( vehicle , factory ) do begin MCE_VehicleConstructed ( vehicle , factory ) ;
10524: LD_VAR 0 1
10528: PPUSH
10529: LD_VAR 0 2
10533: PPUSH
10534: CALL 46215 0 2
// end ;
10538: PPOPN 2
10540: END
// on VehicleCaptured ( new , old , side , capturing_unit ) do begin MCE_VehicleCaptured ( new , old , side , capturing_unit ) ;
10541: LD_VAR 0 1
10545: PPUSH
10546: LD_VAR 0 2
10550: PPUSH
10551: LD_VAR 0 3
10555: PPUSH
10556: LD_VAR 0 4
10560: PPUSH
10561: CALL 46053 0 4
// end ;
10565: PPOPN 4
10567: END
// on BuildingCaptured ( building , side , capturning_unit ) do begin MCE_BuildingCaptured ( building , side , capturning_unit ) ;
10568: LD_VAR 0 1
10572: PPUSH
10573: LD_VAR 0 2
10577: PPUSH
10578: LD_VAR 0 3
10582: PPUSH
10583: CALL 45828 0 3
// end ;
10587: PPOPN 3
10589: END
// on EnterBuilding ( building , unit ) do begin MCE_EnterBuilding ( building , unit ) ;
10590: LD_VAR 0 1
10594: PPUSH
10595: LD_VAR 0 2
10599: PPUSH
10600: CALL 45713 0 2
// end ;
10604: PPOPN 2
10606: END
// on LeaveBuilding ( building , unit ) do begin MCE_LeaveBuilding ( building , unit ) ;
10607: LD_VAR 0 1
10611: PPUSH
10612: LD_VAR 0 2
10616: PPUSH
10617: CALL 49898 0 2
// end ;
10621: PPOPN 2
10623: END
// on EvacuateVehicle ( driver , abandoned_vehicle , unknown1 , unknown2 ) do begin MCE_EvacuateVehicle ( driver , abandoned_vehicle , unknown1 , unknown2 ) ;
10624: LD_VAR 0 1
10628: PPUSH
10629: LD_VAR 0 2
10633: PPUSH
10634: LD_VAR 0 3
10638: PPUSH
10639: LD_VAR 0 4
10643: PPUSH
10644: CALL 50114 0 4
// end ;
10648: PPOPN 4
10650: END
// on ApemanTamed ( ape , sci ) do begin MCE_ApemanTamed ( ape , sci ) ;
10651: LD_VAR 0 1
10655: PPUSH
10656: LD_VAR 0 2
10660: PPUSH
10661: CALL 45522 0 2
// end ;
10665: PPOPN 2
10667: END
// on Command ( cmd ) do begin SOS_Command ( cmd ) ;
10668: LD_VAR 0 1
10672: PPUSH
10673: CALL 93426 0 1
// end ; end_of_file
10677: PPOPN 1
10679: END
// export function Action ; begin
10680: LD_INT 0
10682: PPUSH
// InGameOn ;
10683: CALL_OW 8
// CenterNowOnXY ( 206 , 11 ) ;
10687: LD_INT 206
10689: PPUSH
10690: LD_INT 11
10692: PPUSH
10693: CALL_OW 86
// wait ( 0 0$1 ) ;
10697: LD_INT 35
10699: PPUSH
10700: CALL_OW 67
// Say ( JMM , DStart-JMM-JMM-1 ) ;
10704: LD_EXP 12
10708: PPUSH
10709: LD_STRING DStart-JMM-JMM-1
10711: PPUSH
10712: CALL_OW 88
// Say ( Burlak , DStart-JMM-Bur-1 ) ;
10716: LD_EXP 44
10720: PPUSH
10721: LD_STRING DStart-JMM-Bur-1
10723: PPUSH
10724: CALL_OW 88
// Say ( JMM , DStart-JMM-JMM-2 ) ;
10728: LD_EXP 12
10732: PPUSH
10733: LD_STRING DStart-JMM-JMM-2
10735: PPUSH
10736: CALL_OW 88
// Say ( Burlak , DStart-JMM-Bur-2 ) ;
10740: LD_EXP 44
10744: PPUSH
10745: LD_STRING DStart-JMM-Bur-2
10747: PPUSH
10748: CALL_OW 88
// InGameOff ;
10752: CALL_OW 9
// ChangeMissionObjectives ( MStart ) ;
10756: LD_STRING MStart
10758: PPUSH
10759: CALL_OW 337
// end ;
10763: LD_VAR 0 1
10767: RET
// every 0 0$2 trigger SeeXY ( 7 , 255 , 219 ) do var speaker ;
10768: LD_INT 7
10770: PPUSH
10771: LD_INT 255
10773: PPUSH
10774: LD_INT 219
10776: PPUSH
10777: CALL_OW 293
10781: IFFALSE 11390
10783: GO 10785
10785: DISABLE
10786: LD_INT 0
10788: PPUSH
// begin wait ( 0 0$3 ) ;
10789: LD_INT 105
10791: PPUSH
10792: CALL_OW 67
// alienSpotted := true ;
10796: LD_ADDR_EXP 7
10800: PUSH
10801: LD_INT 1
10803: ST_TO_ADDR
// speaker := FilterAllUnits ( [ [ f_side , 7 ] , [ f_nation , 3 ] , [ f_type , unit_human ] , [ f_sex , sex_male ] ] ) diff [ Burlak , Titov , Dolgov , Petrosyan , Kuzmov , Kovalyuk , Scholtze ] ;
10804: LD_ADDR_VAR 0 1
10808: PUSH
10809: LD_INT 22
10811: PUSH
10812: LD_INT 7
10814: PUSH
10815: EMPTY
10816: LIST
10817: LIST
10818: PUSH
10819: LD_INT 23
10821: PUSH
10822: LD_INT 3
10824: PUSH
10825: EMPTY
10826: LIST
10827: LIST
10828: PUSH
10829: LD_INT 21
10831: PUSH
10832: LD_INT 1
10834: PUSH
10835: EMPTY
10836: LIST
10837: LIST
10838: PUSH
10839: LD_INT 26
10841: PUSH
10842: LD_INT 1
10844: PUSH
10845: EMPTY
10846: LIST
10847: LIST
10848: PUSH
10849: EMPTY
10850: LIST
10851: LIST
10852: LIST
10853: LIST
10854: PPUSH
10855: CALL_OW 69
10859: PUSH
10860: LD_EXP 44
10864: PUSH
10865: LD_EXP 32
10869: PUSH
10870: LD_EXP 34
10874: PUSH
10875: LD_EXP 35
10879: PUSH
10880: LD_EXP 42
10884: PUSH
10885: LD_EXP 41
10889: PUSH
10890: LD_EXP 36
10894: PUSH
10895: EMPTY
10896: LIST
10897: LIST
10898: LIST
10899: LIST
10900: LIST
10901: LIST
10902: LIST
10903: DIFF
10904: ST_TO_ADDR
// DialogueOn ;
10905: CALL_OW 6
// PlaceSeeing ( 255 , 219 , 7 , - 20 ) ;
10909: LD_INT 255
10911: PPUSH
10912: LD_INT 219
10914: PPUSH
10915: LD_INT 7
10917: PPUSH
10918: LD_INT 20
10920: NEG
10921: PPUSH
10922: CALL_OW 330
// CenterNowOnXY ( 255 , 219 ) ;
10926: LD_INT 255
10928: PPUSH
10929: LD_INT 219
10931: PPUSH
10932: CALL_OW 86
// if speaker then
10936: LD_VAR 0 1
10940: IFFALSE 10958
// Say ( speaker [ 1 ] , DAlienBase-RSol1-1 ) ;
10942: LD_VAR 0 1
10946: PUSH
10947: LD_INT 1
10949: ARRAY
10950: PPUSH
10951: LD_STRING DAlienBase-RSol1-1
10953: PPUSH
10954: CALL_OW 88
// Say ( JMM , DAlienBase-JMM-1 ) ;
10958: LD_EXP 12
10962: PPUSH
10963: LD_STRING DAlienBase-JMM-1
10965: PPUSH
10966: CALL_OW 88
// if IsOk ( Burlak ) then
10970: LD_EXP 44
10974: PPUSH
10975: CALL_OW 302
10979: IFFALSE 11000
// begin dwait ( 0 0$1 ) ;
10981: LD_INT 35
10983: PPUSH
10984: CALL_OW 68
// Say ( Burlak , DAlienBase-Bur-1 ) ;
10988: LD_EXP 44
10992: PPUSH
10993: LD_STRING DAlienBase-Bur-1
10995: PPUSH
10996: CALL_OW 88
// end ; if IsOk ( Roth ) then
11000: LD_EXP 13
11004: PPUSH
11005: CALL_OW 302
11009: IFFALSE 11023
// Say ( Roth , DAlienBase-Roth-1 ) ;
11011: LD_EXP 13
11015: PPUSH
11016: LD_STRING DAlienBase-Roth-1
11018: PPUSH
11019: CALL_OW 88
// if IsOk ( Gossudarov ) then
11023: LD_EXP 30
11027: PPUSH
11028: CALL_OW 302
11032: IFFALSE 11048
// Say ( Gossudarov , DAlienBase-Gos-1 ) else
11034: LD_EXP 30
11038: PPUSH
11039: LD_STRING DAlienBase-Gos-1
11041: PPUSH
11042: CALL_OW 88
11046: GO 11165
// begin speaker := FilterAllUnits ( [ [ f_side , 7 ] , [ f_class , 4 ] , [ f_type , unit_human ] , [ f_sex , sex_male ] ] ) diff [ Roth , JMM , Burlak , Titov , Kuzmov , Kovalyuk ] ;
11048: LD_ADDR_VAR 0 1
11052: PUSH
11053: LD_INT 22
11055: PUSH
11056: LD_INT 7
11058: PUSH
11059: EMPTY
11060: LIST
11061: LIST
11062: PUSH
11063: LD_INT 25
11065: PUSH
11066: LD_INT 4
11068: PUSH
11069: EMPTY
11070: LIST
11071: LIST
11072: PUSH
11073: LD_INT 21
11075: PUSH
11076: LD_INT 1
11078: PUSH
11079: EMPTY
11080: LIST
11081: LIST
11082: PUSH
11083: LD_INT 26
11085: PUSH
11086: LD_INT 1
11088: PUSH
11089: EMPTY
11090: LIST
11091: LIST
11092: PUSH
11093: EMPTY
11094: LIST
11095: LIST
11096: LIST
11097: LIST
11098: PPUSH
11099: CALL_OW 69
11103: PUSH
11104: LD_EXP 13
11108: PUSH
11109: LD_EXP 12
11113: PUSH
11114: LD_EXP 44
11118: PUSH
11119: LD_EXP 32
11123: PUSH
11124: LD_EXP 42
11128: PUSH
11129: LD_EXP 41
11133: PUSH
11134: EMPTY
11135: LIST
11136: LIST
11137: LIST
11138: LIST
11139: LIST
11140: LIST
11141: DIFF
11142: ST_TO_ADDR
// if speaker then
11143: LD_VAR 0 1
11147: IFFALSE 11165
// Say ( speaker [ 1 ] , DAlienBase-Sci1-1 ) ;
11149: LD_VAR 0 1
11153: PUSH
11154: LD_INT 1
11156: ARRAY
11157: PPUSH
11158: LD_STRING DAlienBase-Sci1-1
11160: PPUSH
11161: CALL_OW 88
// end ; RemoveSeeing ( 255 , 219 , 7 ) ;
11165: LD_INT 255
11167: PPUSH
11168: LD_INT 219
11170: PPUSH
11171: LD_INT 7
11173: PPUSH
11174: CALL_OW 331
// DialogueOff ;
11178: CALL_OW 7
// repeat wait ( 0 0$1 ) ;
11182: LD_INT 35
11184: PPUSH
11185: CALL_OW 67
// until IsSelected ( alien ) ;
11189: LD_INT 1
11191: PPUSH
11192: CALL_OW 306
11196: IFFALSE 11182
// if not artifactIResearched or not artifactIIResearched then
11198: LD_EXP 9
11202: NOT
11203: PUSH
11204: LD_EXP 10
11208: NOT
11209: OR
11210: IFFALSE 11390
// begin if IsOk ( Roth ) then
11212: LD_EXP 13
11216: PPUSH
11217: CALL_OW 302
11221: IFFALSE 11237
// Say ( Roth , DAlieBaseNotReady-Roth-1 ) else
11223: LD_EXP 13
11227: PPUSH
11228: LD_STRING DAlieBaseNotReady-Roth-1
11230: PPUSH
11231: CALL_OW 88
11235: GO 11390
// if IsOk ( Gossudarov ) then
11237: LD_EXP 30
11241: PPUSH
11242: CALL_OW 302
11246: IFFALSE 11262
// Say ( Gossudarov , DAlieBaseNotReady-Gos-1 ) else
11248: LD_EXP 30
11252: PPUSH
11253: LD_STRING DAlieBaseNotReady-Gos-1
11255: PPUSH
11256: CALL_OW 88
11260: GO 11390
// begin speaker := FilterAllUnits ( [ [ f_side , 7 ] , [ f_nation , 3 ] , [ f_class , 4 ] , [ f_type , unit_human ] , [ f_sex , sex_male ] ] ) diff [ Roth , JMM , Burlak , Titov , Kuzmov , Kovalyuk ] ;
11262: LD_ADDR_VAR 0 1
11266: PUSH
11267: LD_INT 22
11269: PUSH
11270: LD_INT 7
11272: PUSH
11273: EMPTY
11274: LIST
11275: LIST
11276: PUSH
11277: LD_INT 23
11279: PUSH
11280: LD_INT 3
11282: PUSH
11283: EMPTY
11284: LIST
11285: LIST
11286: PUSH
11287: LD_INT 25
11289: PUSH
11290: LD_INT 4
11292: PUSH
11293: EMPTY
11294: LIST
11295: LIST
11296: PUSH
11297: LD_INT 21
11299: PUSH
11300: LD_INT 1
11302: PUSH
11303: EMPTY
11304: LIST
11305: LIST
11306: PUSH
11307: LD_INT 26
11309: PUSH
11310: LD_INT 1
11312: PUSH
11313: EMPTY
11314: LIST
11315: LIST
11316: PUSH
11317: EMPTY
11318: LIST
11319: LIST
11320: LIST
11321: LIST
11322: LIST
11323: PPUSH
11324: CALL_OW 69
11328: PUSH
11329: LD_EXP 13
11333: PUSH
11334: LD_EXP 12
11338: PUSH
11339: LD_EXP 44
11343: PUSH
11344: LD_EXP 32
11348: PUSH
11349: LD_EXP 42
11353: PUSH
11354: LD_EXP 41
11358: PUSH
11359: EMPTY
11360: LIST
11361: LIST
11362: LIST
11363: LIST
11364: LIST
11365: LIST
11366: DIFF
11367: ST_TO_ADDR
// if speaker then
11368: LD_VAR 0 1
11372: IFFALSE 11390
// Say ( speaker [ 1 ] , DAlieBaseNotReady-RSci1-1 ) ;
11374: LD_VAR 0 1
11378: PUSH
11379: LD_INT 1
11381: ARRAY
11382: PPUSH
11383: LD_STRING DAlieBaseNotReady-RSci1-1
11385: PPUSH
11386: CALL_OW 88
// end ; end ; end ;
11390: PPOPN 1
11392: END
// every 0 0$1 trigger GetTech ( tech_Artifact , 7 ) = state_researched do var speaker ;
11393: LD_INT 24
11395: PPUSH
11396: LD_INT 7
11398: PPUSH
11399: CALL_OW 321
11403: PUSH
11404: LD_INT 2
11406: EQUAL
11407: IFFALSE 12098
11409: GO 11411
11411: DISABLE
11412: LD_INT 0
11414: PPUSH
// begin speaker := FilterAllUnits ( [ [ f_side , 7 ] , [ f_nation , 3 ] , [ f_class , 4 ] , [ f_type , unit_human ] , [ f_sex , sex_male ] ] ) diff [ Roth , JMM , Burlak , Titov , Kuzmov , Kovalyuk ] ;
11415: LD_ADDR_VAR 0 1
11419: PUSH
11420: LD_INT 22
11422: PUSH
11423: LD_INT 7
11425: PUSH
11426: EMPTY
11427: LIST
11428: LIST
11429: PUSH
11430: LD_INT 23
11432: PUSH
11433: LD_INT 3
11435: PUSH
11436: EMPTY
11437: LIST
11438: LIST
11439: PUSH
11440: LD_INT 25
11442: PUSH
11443: LD_INT 4
11445: PUSH
11446: EMPTY
11447: LIST
11448: LIST
11449: PUSH
11450: LD_INT 21
11452: PUSH
11453: LD_INT 1
11455: PUSH
11456: EMPTY
11457: LIST
11458: LIST
11459: PUSH
11460: LD_INT 26
11462: PUSH
11463: LD_INT 1
11465: PUSH
11466: EMPTY
11467: LIST
11468: LIST
11469: PUSH
11470: EMPTY
11471: LIST
11472: LIST
11473: LIST
11474: LIST
11475: LIST
11476: PPUSH
11477: CALL_OW 69
11481: PUSH
11482: LD_EXP 13
11486: PUSH
11487: LD_EXP 12
11491: PUSH
11492: LD_EXP 44
11496: PUSH
11497: LD_EXP 32
11501: PUSH
11502: LD_EXP 42
11506: PUSH
11507: LD_EXP 41
11511: PUSH
11512: EMPTY
11513: LIST
11514: LIST
11515: LIST
11516: LIST
11517: LIST
11518: LIST
11519: DIFF
11520: ST_TO_ADDR
// if not speaker then
11521: LD_VAR 0 1
11525: NOT
11526: IFFALSE 11530
// exit ;
11528: GO 12098
// DialogueOn ;
11530: CALL_OW 6
// Say ( speaker [ 1 ] , DArtefTechnology-RSci1-1 ) ;
11534: LD_VAR 0 1
11538: PUSH
11539: LD_INT 1
11541: ARRAY
11542: PPUSH
11543: LD_STRING DArtefTechnology-RSci1-1
11545: PPUSH
11546: CALL_OW 88
// if IsOk ( Burlak ) then
11550: LD_EXP 44
11554: PPUSH
11555: CALL_OW 302
11559: IFFALSE 11573
// Say ( Burlak , DArtefTechnology-Bur-1 ) ;
11561: LD_EXP 44
11565: PPUSH
11566: LD_STRING DArtefTechnology-Bur-1
11568: PPUSH
11569: CALL_OW 88
// Say ( speaker [ 1 ] , DArtefTechnology-RSci1-2 ) ;
11573: LD_VAR 0 1
11577: PUSH
11578: LD_INT 1
11580: ARRAY
11581: PPUSH
11582: LD_STRING DArtefTechnology-RSci1-2
11584: PPUSH
11585: CALL_OW 88
// if Denis then
11589: LD_EXP 18
11593: IFFALSE 11610
// speaker := [ Denis ] else
11595: LD_ADDR_VAR 0 1
11599: PUSH
11600: LD_EXP 18
11604: PUSH
11605: EMPTY
11606: LIST
11607: ST_TO_ADDR
11608: GO 11716
// speaker := FilterAllUnits ( [ [ f_side , 7 ] , [ f_nation , 1 ] , [ f_class , 4 ] , [ f_type , unit_human ] , [ f_sex , sex_male ] ] ) diff [ Roth , JMM , Burlak , Titov , Kuzmov , Kovalyuk ] ;
11610: LD_ADDR_VAR 0 1
11614: PUSH
11615: LD_INT 22
11617: PUSH
11618: LD_INT 7
11620: PUSH
11621: EMPTY
11622: LIST
11623: LIST
11624: PUSH
11625: LD_INT 23
11627: PUSH
11628: LD_INT 1
11630: PUSH
11631: EMPTY
11632: LIST
11633: LIST
11634: PUSH
11635: LD_INT 25
11637: PUSH
11638: LD_INT 4
11640: PUSH
11641: EMPTY
11642: LIST
11643: LIST
11644: PUSH
11645: LD_INT 21
11647: PUSH
11648: LD_INT 1
11650: PUSH
11651: EMPTY
11652: LIST
11653: LIST
11654: PUSH
11655: LD_INT 26
11657: PUSH
11658: LD_INT 1
11660: PUSH
11661: EMPTY
11662: LIST
11663: LIST
11664: PUSH
11665: EMPTY
11666: LIST
11667: LIST
11668: LIST
11669: LIST
11670: LIST
11671: PPUSH
11672: CALL_OW 69
11676: PUSH
11677: LD_EXP 13
11681: PUSH
11682: LD_EXP 12
11686: PUSH
11687: LD_EXP 44
11691: PUSH
11692: LD_EXP 32
11696: PUSH
11697: LD_EXP 42
11701: PUSH
11702: LD_EXP 41
11706: PUSH
11707: EMPTY
11708: LIST
11709: LIST
11710: LIST
11711: LIST
11712: LIST
11713: LIST
11714: DIFF
11715: ST_TO_ADDR
// if speaker then
11716: LD_VAR 0 1
11720: IFFALSE 11738
// Say ( speaker [ 1 ] , DArtefTechnology-Sci1-2 ) ;
11722: LD_VAR 0 1
11726: PUSH
11727: LD_INT 1
11729: ARRAY
11730: PPUSH
11731: LD_STRING DArtefTechnology-Sci1-2
11733: PPUSH
11734: CALL_OW 88
// speaker := FilterAllUnits ( [ [ f_side , 7 ] , [ f_nation , 3 ] , [ f_class , 4 ] , [ f_type , unit_human ] , [ f_sex , sex_male ] ] ) diff [ Roth , JMM , Burlak , Titov , Kuzmov , Kovalyuk ] ;
11738: LD_ADDR_VAR 0 1
11742: PUSH
11743: LD_INT 22
11745: PUSH
11746: LD_INT 7
11748: PUSH
11749: EMPTY
11750: LIST
11751: LIST
11752: PUSH
11753: LD_INT 23
11755: PUSH
11756: LD_INT 3
11758: PUSH
11759: EMPTY
11760: LIST
11761: LIST
11762: PUSH
11763: LD_INT 25
11765: PUSH
11766: LD_INT 4
11768: PUSH
11769: EMPTY
11770: LIST
11771: LIST
11772: PUSH
11773: LD_INT 21
11775: PUSH
11776: LD_INT 1
11778: PUSH
11779: EMPTY
11780: LIST
11781: LIST
11782: PUSH
11783: LD_INT 26
11785: PUSH
11786: LD_INT 1
11788: PUSH
11789: EMPTY
11790: LIST
11791: LIST
11792: PUSH
11793: EMPTY
11794: LIST
11795: LIST
11796: LIST
11797: LIST
11798: LIST
11799: PPUSH
11800: CALL_OW 69
11804: PUSH
11805: LD_EXP 13
11809: PUSH
11810: LD_EXP 12
11814: PUSH
11815: LD_EXP 44
11819: PUSH
11820: LD_EXP 32
11824: PUSH
11825: LD_EXP 42
11829: PUSH
11830: LD_EXP 41
11834: PUSH
11835: EMPTY
11836: LIST
11837: LIST
11838: LIST
11839: LIST
11840: LIST
11841: LIST
11842: DIFF
11843: ST_TO_ADDR
// if speaker and ( artifactArCaptured or arabianDestroyed ) then
11844: LD_VAR 0 1
11848: PUSH
11849: LD_EXP 6
11853: PUSH
11854: LD_EXP 5
11858: OR
11859: AND
11860: IFFALSE 12094
// begin if arabianDestroyed and IsOk ( Burlak ) then
11862: LD_EXP 5
11866: PUSH
11867: LD_EXP 44
11871: PPUSH
11872: CALL_OW 302
11876: AND
11877: IFFALSE 11893
// Say ( Burlak , DArtefTechnology-Bur-2 ) else
11879: LD_EXP 44
11883: PPUSH
11884: LD_STRING DArtefTechnology-Bur-2
11886: PPUSH
11887: CALL_OW 88
11891: GO 11905
// Say ( JMM , DArtefTechnology-JMM-2 ) ;
11893: LD_EXP 12
11897: PPUSH
11898: LD_STRING DArtefTechnology-JMM-2
11900: PPUSH
11901: CALL_OW 88
// Say ( speaker [ 1 ] , DArtefTechnology-RSci1-3 ) ;
11905: LD_VAR 0 1
11909: PUSH
11910: LD_INT 1
11912: ARRAY
11913: PPUSH
11914: LD_STRING DArtefTechnology-RSci1-3
11916: PPUSH
11917: CALL_OW 88
// if Denis then
11921: LD_EXP 18
11925: IFFALSE 11942
// speaker := [ Denis ] else
11927: LD_ADDR_VAR 0 1
11931: PUSH
11932: LD_EXP 18
11936: PUSH
11937: EMPTY
11938: LIST
11939: ST_TO_ADDR
11940: GO 12048
// speaker := FilterAllUnits ( [ [ f_side , 7 ] , [ f_nation , 1 ] , [ f_class , 4 ] , [ f_type , unit_human ] , [ f_sex , sex_male ] ] ) diff [ Roth , JMM , Burlak , Titov , Kuzmov , Kovalyuk ] ;
11942: LD_ADDR_VAR 0 1
11946: PUSH
11947: LD_INT 22
11949: PUSH
11950: LD_INT 7
11952: PUSH
11953: EMPTY
11954: LIST
11955: LIST
11956: PUSH
11957: LD_INT 23
11959: PUSH
11960: LD_INT 1
11962: PUSH
11963: EMPTY
11964: LIST
11965: LIST
11966: PUSH
11967: LD_INT 25
11969: PUSH
11970: LD_INT 4
11972: PUSH
11973: EMPTY
11974: LIST
11975: LIST
11976: PUSH
11977: LD_INT 21
11979: PUSH
11980: LD_INT 1
11982: PUSH
11983: EMPTY
11984: LIST
11985: LIST
11986: PUSH
11987: LD_INT 26
11989: PUSH
11990: LD_INT 1
11992: PUSH
11993: EMPTY
11994: LIST
11995: LIST
11996: PUSH
11997: EMPTY
11998: LIST
11999: LIST
12000: LIST
12001: LIST
12002: LIST
12003: PPUSH
12004: CALL_OW 69
12008: PUSH
12009: LD_EXP 13
12013: PUSH
12014: LD_EXP 12
12018: PUSH
12019: LD_EXP 44
12023: PUSH
12024: LD_EXP 32
12028: PUSH
12029: LD_EXP 42
12033: PUSH
12034: LD_EXP 41
12038: PUSH
12039: EMPTY
12040: LIST
12041: LIST
12042: LIST
12043: LIST
12044: LIST
12045: LIST
12046: DIFF
12047: ST_TO_ADDR
// if speaker then
12048: LD_VAR 0 1
12052: IFFALSE 12094
// if alienSpotted then
12054: LD_EXP 7
12058: IFFALSE 12078
// Say ( speaker [ 1 ] , DArtefTechnology-Sci1-3 ) else
12060: LD_VAR 0 1
12064: PUSH
12065: LD_INT 1
12067: ARRAY
12068: PPUSH
12069: LD_STRING DArtefTechnology-Sci1-3
12071: PPUSH
12072: CALL_OW 88
12076: GO 12094
// Say ( speaker [ 1 ] , DArtefTechnology-Sci1-3a ) ;
12078: LD_VAR 0 1
12082: PUSH
12083: LD_INT 1
12085: ARRAY
12086: PPUSH
12087: LD_STRING DArtefTechnology-Sci1-3a
12089: PPUSH
12090: CALL_OW 88
// end ; DialogueOff ;
12094: CALL_OW 7
// end ;
12098: PPOPN 1
12100: END
// every 0 0$1 trigger artifactIResearched do var speaker ;
12101: LD_EXP 9
12105: IFFALSE 12300
12107: GO 12109
12109: DISABLE
12110: LD_INT 0
12112: PPUSH
// begin if Denis then
12113: LD_EXP 18
12117: IFFALSE 12134
// speaker := [ Denis ] else
12119: LD_ADDR_VAR 0 1
12123: PUSH
12124: LD_EXP 18
12128: PUSH
12129: EMPTY
12130: LIST
12131: ST_TO_ADDR
12132: GO 12240
// speaker := FilterAllUnits ( [ [ f_side , 7 ] , [ f_nation , 1 ] , [ f_class , 4 ] , [ f_type , unit_human ] , [ f_sex , sex_male ] ] ) diff [ Roth , JMM , Burlak , Titov , Kuzmov , Kovalyuk ] ;
12134: LD_ADDR_VAR 0 1
12138: PUSH
12139: LD_INT 22
12141: PUSH
12142: LD_INT 7
12144: PUSH
12145: EMPTY
12146: LIST
12147: LIST
12148: PUSH
12149: LD_INT 23
12151: PUSH
12152: LD_INT 1
12154: PUSH
12155: EMPTY
12156: LIST
12157: LIST
12158: PUSH
12159: LD_INT 25
12161: PUSH
12162: LD_INT 4
12164: PUSH
12165: EMPTY
12166: LIST
12167: LIST
12168: PUSH
12169: LD_INT 21
12171: PUSH
12172: LD_INT 1
12174: PUSH
12175: EMPTY
12176: LIST
12177: LIST
12178: PUSH
12179: LD_INT 26
12181: PUSH
12182: LD_INT 1
12184: PUSH
12185: EMPTY
12186: LIST
12187: LIST
12188: PUSH
12189: EMPTY
12190: LIST
12191: LIST
12192: LIST
12193: LIST
12194: LIST
12195: PPUSH
12196: CALL_OW 69
12200: PUSH
12201: LD_EXP 13
12205: PUSH
12206: LD_EXP 12
12210: PUSH
12211: LD_EXP 44
12215: PUSH
12216: LD_EXP 32
12220: PUSH
12221: LD_EXP 42
12225: PUSH
12226: LD_EXP 41
12230: PUSH
12231: EMPTY
12232: LIST
12233: LIST
12234: LIST
12235: LIST
12236: LIST
12237: LIST
12238: DIFF
12239: ST_TO_ADDR
// if not speaker then
12240: LD_VAR 0 1
12244: NOT
12245: IFFALSE 12249
// exit ;
12247: GO 12300
// Say ( speaker [ 1 ] , DArtefTechnologyAm-Sci1-1 ) ;
12249: LD_VAR 0 1
12253: PUSH
12254: LD_INT 1
12256: ARRAY
12257: PPUSH
12258: LD_STRING DArtefTechnologyAm-Sci1-1
12260: PPUSH
12261: CALL_OW 88
// if IsOk ( Burlak ) then
12265: LD_EXP 44
12269: PPUSH
12270: CALL_OW 302
12274: IFFALSE 12288
// Say ( Burlak , DArtefTechnologyAm-Bur-1 ) ;
12276: LD_EXP 44
12280: PPUSH
12281: LD_STRING DArtefTechnologyAm-Bur-1
12283: PPUSH
12284: CALL_OW 88
// Say ( JMM , DArtefTechnologyAm-JMM-1 ) ;
12288: LD_EXP 12
12292: PPUSH
12293: LD_STRING DArtefTechnologyAm-JMM-1
12295: PPUSH
12296: CALL_OW 88
// end ;
12300: PPOPN 1
12302: END
// every 0 0$1 trigger artifactIIResearched do var speaker ;
12303: LD_EXP 10
12307: IFFALSE 12518
12309: GO 12311
12311: DISABLE
12312: LD_INT 0
12314: PPUSH
// begin if Denis then
12315: LD_EXP 18
12319: IFFALSE 12336
// speaker := [ Denis ] else
12321: LD_ADDR_VAR 0 1
12325: PUSH
12326: LD_EXP 18
12330: PUSH
12331: EMPTY
12332: LIST
12333: ST_TO_ADDR
12334: GO 12442
// speaker := FilterAllUnits ( [ [ f_side , 7 ] , [ f_nation , 3 ] , [ f_class , 4 ] , [ f_type , unit_human ] , [ f_sex , sex_male ] ] ) diff [ Roth , JMM , Burlak , Titov , Kuzmov , Kovalyuk ] ;
12336: LD_ADDR_VAR 0 1
12340: PUSH
12341: LD_INT 22
12343: PUSH
12344: LD_INT 7
12346: PUSH
12347: EMPTY
12348: LIST
12349: LIST
12350: PUSH
12351: LD_INT 23
12353: PUSH
12354: LD_INT 3
12356: PUSH
12357: EMPTY
12358: LIST
12359: LIST
12360: PUSH
12361: LD_INT 25
12363: PUSH
12364: LD_INT 4
12366: PUSH
12367: EMPTY
12368: LIST
12369: LIST
12370: PUSH
12371: LD_INT 21
12373: PUSH
12374: LD_INT 1
12376: PUSH
12377: EMPTY
12378: LIST
12379: LIST
12380: PUSH
12381: LD_INT 26
12383: PUSH
12384: LD_INT 1
12386: PUSH
12387: EMPTY
12388: LIST
12389: LIST
12390: PUSH
12391: EMPTY
12392: LIST
12393: LIST
12394: LIST
12395: LIST
12396: LIST
12397: PPUSH
12398: CALL_OW 69
12402: PUSH
12403: LD_EXP 13
12407: PUSH
12408: LD_EXP 12
12412: PUSH
12413: LD_EXP 44
12417: PUSH
12418: LD_EXP 32
12422: PUSH
12423: LD_EXP 42
12427: PUSH
12428: LD_EXP 41
12432: PUSH
12433: EMPTY
12434: LIST
12435: LIST
12436: LIST
12437: LIST
12438: LIST
12439: LIST
12440: DIFF
12441: ST_TO_ADDR
// if not speaker then
12442: LD_VAR 0 1
12446: NOT
12447: IFFALSE 12451
// exit ;
12449: GO 12518
// Say ( speaker [ 1 ] , DArtefTechnologyRu-RSci1-1 ) ;
12451: LD_VAR 0 1
12455: PUSH
12456: LD_INT 1
12458: ARRAY
12459: PPUSH
12460: LD_STRING DArtefTechnologyRu-RSci1-1
12462: PPUSH
12463: CALL_OW 88
// if IsOk ( Burlak ) then
12467: LD_EXP 44
12471: PPUSH
12472: CALL_OW 302
12476: IFFALSE 12490
// Say ( Burlak , DArtefTechnologyRu-Bur-1 ) ;
12478: LD_EXP 44
12482: PPUSH
12483: LD_STRING DArtefTechnologyRu-Bur-1
12485: PPUSH
12486: CALL_OW 88
// Say ( speaker [ 1 ] , DArtefTechnologyRu-RSci1-2 ) ;
12490: LD_VAR 0 1
12494: PUSH
12495: LD_INT 1
12497: ARRAY
12498: PPUSH
12499: LD_STRING DArtefTechnologyRu-RSci1-2
12501: PPUSH
12502: CALL_OW 88
// Say ( JMM , DArtefTechnologyRu-JMM-1 ) ;
12506: LD_EXP 12
12510: PPUSH
12511: LD_STRING DArtefTechnologyRu-JMM-1
12513: PPUSH
12514: CALL_OW 88
// end ;
12518: PPOPN 1
12520: END
// every 0 0$1 trigger GetTech ( tech_Artifact , 7 ) = state_researched and GetSide ( alien ) = 7 do var speaker ;
12521: LD_INT 24
12523: PPUSH
12524: LD_INT 7
12526: PPUSH
12527: CALL_OW 321
12531: PUSH
12532: LD_INT 2
12534: EQUAL
12535: PUSH
12536: LD_INT 1
12538: PPUSH
12539: CALL_OW 255
12543: PUSH
12544: LD_INT 7
12546: EQUAL
12547: AND
12548: IFFALSE 12708
12550: GO 12552
12552: DISABLE
12553: LD_INT 0
12555: PPUSH
// begin if Denis then
12556: LD_EXP 18
12560: IFFALSE 12577
// speaker := [ Denis ] else
12562: LD_ADDR_VAR 0 1
12566: PUSH
12567: LD_EXP 18
12571: PUSH
12572: EMPTY
12573: LIST
12574: ST_TO_ADDR
12575: GO 12683
// speaker := FilterAllUnits ( [ [ f_side , 7 ] , [ f_nation , 1 ] , [ f_class , 4 ] , [ f_type , unit_human ] , [ f_sex , sex_male ] ] ) diff [ Roth , JMM , Burlak , Titov , Kuzmov , Kovalyuk ] ;
12577: LD_ADDR_VAR 0 1
12581: PUSH
12582: LD_INT 22
12584: PUSH
12585: LD_INT 7
12587: PUSH
12588: EMPTY
12589: LIST
12590: LIST
12591: PUSH
12592: LD_INT 23
12594: PUSH
12595: LD_INT 1
12597: PUSH
12598: EMPTY
12599: LIST
12600: LIST
12601: PUSH
12602: LD_INT 25
12604: PUSH
12605: LD_INT 4
12607: PUSH
12608: EMPTY
12609: LIST
12610: LIST
12611: PUSH
12612: LD_INT 21
12614: PUSH
12615: LD_INT 1
12617: PUSH
12618: EMPTY
12619: LIST
12620: LIST
12621: PUSH
12622: LD_INT 26
12624: PUSH
12625: LD_INT 1
12627: PUSH
12628: EMPTY
12629: LIST
12630: LIST
12631: PUSH
12632: EMPTY
12633: LIST
12634: LIST
12635: LIST
12636: LIST
12637: LIST
12638: PPUSH
12639: CALL_OW 69
12643: PUSH
12644: LD_EXP 13
12648: PUSH
12649: LD_EXP 12
12653: PUSH
12654: LD_EXP 44
12658: PUSH
12659: LD_EXP 32
12663: PUSH
12664: LD_EXP 42
12668: PUSH
12669: LD_EXP 41
12673: PUSH
12674: EMPTY
12675: LIST
12676: LIST
12677: LIST
12678: LIST
12679: LIST
12680: LIST
12681: DIFF
12682: ST_TO_ADDR
// if not speaker then
12683: LD_VAR 0 1
12687: NOT
12688: IFFALSE 12692
// exit ;
12690: GO 12708
// Say ( speaker [ 1 ] , DArtefTechnologyArStart-Sci1-1 ) ;
12692: LD_VAR 0 1
12696: PUSH
12697: LD_INT 1
12699: ARRAY
12700: PPUSH
12701: LD_STRING DArtefTechnologyArStart-Sci1-1
12703: PPUSH
12704: CALL_OW 88
// end ;
12708: PPOPN 1
12710: END
// every 0 0$1 trigger artifactIIIResearched do var speaker ;
12711: LD_EXP 11
12715: IFFALSE 12996
12717: GO 12719
12719: DISABLE
12720: LD_INT 0
12722: PPUSH
// begin speaker := FilterAllUnits ( [ [ f_side , 7 ] , [ f_nation , 3 ] , [ f_class , 4 ] , [ f_type , unit_human ] , [ f_sex , sex_male ] ] ) diff [ Roth , JMM , Burlak , Titov , Kuzmov , Kovalyuk ] ;
12723: LD_ADDR_VAR 0 1
12727: PUSH
12728: LD_INT 22
12730: PUSH
12731: LD_INT 7
12733: PUSH
12734: EMPTY
12735: LIST
12736: LIST
12737: PUSH
12738: LD_INT 23
12740: PUSH
12741: LD_INT 3
12743: PUSH
12744: EMPTY
12745: LIST
12746: LIST
12747: PUSH
12748: LD_INT 25
12750: PUSH
12751: LD_INT 4
12753: PUSH
12754: EMPTY
12755: LIST
12756: LIST
12757: PUSH
12758: LD_INT 21
12760: PUSH
12761: LD_INT 1
12763: PUSH
12764: EMPTY
12765: LIST
12766: LIST
12767: PUSH
12768: LD_INT 26
12770: PUSH
12771: LD_INT 1
12773: PUSH
12774: EMPTY
12775: LIST
12776: LIST
12777: PUSH
12778: EMPTY
12779: LIST
12780: LIST
12781: LIST
12782: LIST
12783: LIST
12784: PPUSH
12785: CALL_OW 69
12789: PUSH
12790: LD_EXP 13
12794: PUSH
12795: LD_EXP 12
12799: PUSH
12800: LD_EXP 44
12804: PUSH
12805: LD_EXP 32
12809: PUSH
12810: LD_EXP 42
12814: PUSH
12815: LD_EXP 41
12819: PUSH
12820: EMPTY
12821: LIST
12822: LIST
12823: LIST
12824: LIST
12825: LIST
12826: LIST
12827: DIFF
12828: ST_TO_ADDR
// if not speaker then
12829: LD_VAR 0 1
12833: NOT
12834: IFFALSE 12838
// exit ;
12836: GO 12996
// DialogueOn ;
12838: CALL_OW 6
// Say ( speaker [ 1 ] , DArtefTechnologyAr-RSci1-1 ) ;
12842: LD_VAR 0 1
12846: PUSH
12847: LD_INT 1
12849: ARRAY
12850: PPUSH
12851: LD_STRING DArtefTechnologyAr-RSci1-1
12853: PPUSH
12854: CALL_OW 88
// Say ( JMM , DArtefTechnologyAr-JMM-1 ) ;
12858: LD_EXP 12
12862: PPUSH
12863: LD_STRING DArtefTechnologyAr-JMM-1
12865: PPUSH
12866: CALL_OW 88
// Say ( speaker [ 1 ] , DArtefTechnologyAr-RSci1-2 ) ;
12870: LD_VAR 0 1
12874: PUSH
12875: LD_INT 1
12877: ARRAY
12878: PPUSH
12879: LD_STRING DArtefTechnologyAr-RSci1-2
12881: PPUSH
12882: CALL_OW 88
// Say ( JMM , DArtefTechnologyAr-JMM-2 ) ;
12886: LD_EXP 12
12890: PPUSH
12891: LD_STRING DArtefTechnologyAr-JMM-2
12893: PPUSH
12894: CALL_OW 88
// Say ( speaker [ 1 ] , DArtefTechnologyAr-RSci1-3 ) ;
12898: LD_VAR 0 1
12902: PUSH
12903: LD_INT 1
12905: ARRAY
12906: PPUSH
12907: LD_STRING DArtefTechnologyAr-RSci1-3
12909: PPUSH
12910: CALL_OW 88
// Say ( JMM , DArtefTechnologyAr-JMM-3 ) ;
12914: LD_EXP 12
12918: PPUSH
12919: LD_STRING DArtefTechnologyAr-JMM-3
12921: PPUSH
12922: CALL_OW 88
// Say ( speaker [ 1 ] , DArtefTechnologyAr-RSci1-4 ) ;
12926: LD_VAR 0 1
12930: PUSH
12931: LD_INT 1
12933: ARRAY
12934: PPUSH
12935: LD_STRING DArtefTechnologyAr-RSci1-4
12937: PPUSH
12938: CALL_OW 88
// if IsOk ( Burlak ) then
12942: LD_EXP 44
12946: PPUSH
12947: CALL_OW 302
12951: IFFALSE 12965
// Say ( Burlak , DArtefTechnologyAr-Bur-4 ) ;
12953: LD_EXP 44
12957: PPUSH
12958: LD_STRING DArtefTechnologyAr-Bur-4
12960: PPUSH
12961: CALL_OW 88
// Say ( JMM , DArtefTechnologyAr-JMM-4 ) ;
12965: LD_EXP 12
12969: PPUSH
12970: LD_STRING DArtefTechnologyAr-JMM-4
12972: PPUSH
12973: CALL_OW 88
// DialogueOff ;
12977: CALL_OW 7
// wait ( 0 0$45 ) ;
12981: LD_INT 1575
12983: PPUSH
12984: CALL_OW 67
// spawnOmar := true ;
12988: LD_ADDR_EXP 8
12992: PUSH
12993: LD_INT 1
12995: ST_TO_ADDR
// end ;
12996: PPOPN 1
12998: END
// every 0 0$1 trigger spawnOmar do
12999: LD_EXP 8
13003: IFFALSE 13301
13005: GO 13007
13007: DISABLE
// begin PrepareOmarAli ;
13008: CALL 6531 0 0
// if not Omar then
13012: LD_EXP 48
13016: NOT
13017: IFFALSE 13021
// exit ;
13019: GO 13301
// repeat wait ( 0 0$1 ) ;
13021: LD_INT 35
13023: PPUSH
13024: CALL_OW 67
// until See ( 7 , Omar ) ;
13028: LD_INT 7
13030: PPUSH
13031: LD_EXP 48
13035: PPUSH
13036: CALL_OW 292
13040: IFFALSE 13021
// CenterNowOnUnits ( Omar ) ;
13042: LD_EXP 48
13046: PPUSH
13047: CALL_OW 87
// DialogueOn ;
13051: CALL_OW 6
// Say ( Omar , DOmar-Omar-1 ) ;
13055: LD_EXP 48
13059: PPUSH
13060: LD_STRING DOmar-Omar-1
13062: PPUSH
13063: CALL_OW 88
// Say ( JMM , DOmar-JMM-1 ) ;
13067: LD_EXP 12
13071: PPUSH
13072: LD_STRING DOmar-JMM-1
13074: PPUSH
13075: CALL_OW 88
// Say ( Omar , DOmar-Omar-2 ) ;
13079: LD_EXP 48
13083: PPUSH
13084: LD_STRING DOmar-Omar-2
13086: PPUSH
13087: CALL_OW 88
// Say ( JMM , DOmar-JMM-2 ) ;
13091: LD_EXP 12
13095: PPUSH
13096: LD_STRING DOmar-JMM-2
13098: PPUSH
13099: CALL_OW 88
// Say ( Omar , DOmar-Omar-3 ) ;
13103: LD_EXP 48
13107: PPUSH
13108: LD_STRING DOmar-Omar-3
13110: PPUSH
13111: CALL_OW 88
// if IsOk ( Burlak ) then
13115: LD_EXP 44
13119: PPUSH
13120: CALL_OW 302
13124: IFFALSE 13140
// Say ( Burlak , DOmar-Bur-3 ) else
13126: LD_EXP 44
13130: PPUSH
13131: LD_STRING DOmar-Bur-3
13133: PPUSH
13134: CALL_OW 88
13138: GO 13152
// Say ( JMM , DOmar-JMM-3 ) ;
13140: LD_EXP 12
13144: PPUSH
13145: LD_STRING DOmar-JMM-3
13147: PPUSH
13148: CALL_OW 88
// Say ( Omar , DOmar-Omar-4 ) ;
13152: LD_EXP 48
13156: PPUSH
13157: LD_STRING DOmar-Omar-4
13159: PPUSH
13160: CALL_OW 88
// case Query ( QAccept ) of 1 :
13164: LD_STRING QAccept
13166: PPUSH
13167: CALL_OW 97
13171: PUSH
13172: LD_INT 1
13174: DOUBLE
13175: EQUAL
13176: IFTRUE 13180
13178: GO 13216
13180: POP
// begin Say ( JMM , DQrAccept#1-JMM-1 ) ;
13181: LD_EXP 12
13185: PPUSH
13186: LD_STRING DQrAccept#1-JMM-1
13188: PPUSH
13189: CALL_OW 88
// SetSide ( Omar , 7 ) ;
13193: LD_EXP 48
13197: PPUSH
13198: LD_INT 7
13200: PPUSH
13201: CALL_OW 235
// ComStop ( Omar ) ;
13205: LD_EXP 48
13209: PPUSH
13210: CALL_OW 141
// end ; 2 :
13214: GO 13265
13216: LD_INT 2
13218: DOUBLE
13219: EQUAL
13220: IFTRUE 13224
13222: GO 13264
13224: POP
// begin if IsOk ( Burlak ) then
13225: LD_EXP 44
13229: PPUSH
13230: CALL_OW 302
13234: IFFALSE 13250
// Say ( Burlak , DQrAccept#2-Bur-1 ) else
13236: LD_EXP 44
13240: PPUSH
13241: LD_STRING DQrAccept#2-Bur-1
13243: PPUSH
13244: CALL_OW 88
13248: GO 13262
// Say ( JMM , DQrAccept#2-JMM-1 ) ;
13250: LD_EXP 12
13254: PPUSH
13255: LD_STRING DQrAccept#2-JMM-1
13257: PPUSH
13258: CALL_OW 88
// end ; end ;
13262: GO 13265
13264: POP
// DialogueOff ;
13265: CALL_OW 7
// if GetSide ( Omar ) = 7 then
13269: LD_EXP 48
13273: PPUSH
13274: CALL_OW 255
13278: PUSH
13279: LD_INT 7
13281: EQUAL
13282: IFFALSE 13286
// exit ;
13284: GO 13301
// ComMoveXY ( Omar , 202 , 115 ) ;
13286: LD_EXP 48
13290: PPUSH
13291: LD_INT 202
13293: PPUSH
13294: LD_INT 115
13296: PPUSH
13297: CALL_OW 111
// end ;
13301: END
// every 0 0$1 trigger GetDistUnitXY ( Omar , 200 , 98 ) < 40 and russianDestroyed do
13302: LD_EXP 48
13306: PPUSH
13307: LD_INT 200
13309: PPUSH
13310: LD_INT 98
13312: PPUSH
13313: CALL_OW 297
13317: PUSH
13318: LD_INT 40
13320: LESS
13321: PUSH
13322: LD_EXP 2
13326: AND
13327: IFFALSE 13545
13329: GO 13331
13331: DISABLE
// begin SetSide ( Omar , 5 ) ;
13332: LD_EXP 48
13336: PPUSH
13337: LD_INT 5
13339: PPUSH
13340: CALL_OW 235
// if IsInUnit ( Omar ) then
13344: LD_EXP 48
13348: PPUSH
13349: CALL_OW 310
13353: IFFALSE 13364
// ComExitVehicle ( Omar ) ;
13355: LD_EXP 48
13359: PPUSH
13360: CALL_OW 121
// if IsInUnit ( Omar ) then
13364: LD_EXP 48
13368: PPUSH
13369: CALL_OW 310
13373: IFFALSE 13384
// ComExitBuilding ( Omar ) ;
13375: LD_EXP 48
13379: PPUSH
13380: CALL_OW 122
// wait ( 0 0$1 ) ;
13384: LD_INT 35
13386: PPUSH
13387: CALL_OW 67
// ComMoveXY ( Omar , 203 , 120 ) ;
13391: LD_EXP 48
13395: PPUSH
13396: LD_INT 203
13398: PPUSH
13399: LD_INT 120
13401: PPUSH
13402: CALL_OW 111
// repeat wait ( 0 0$1 ) ;
13406: LD_INT 35
13408: PPUSH
13409: CALL_OW 67
// until IsSelected ( Omar ) or GetDistUnitXY ( Omar , 203 , 120 ) < 6 ;
13413: LD_EXP 48
13417: PPUSH
13418: CALL_OW 306
13422: PUSH
13423: LD_EXP 48
13427: PPUSH
13428: LD_INT 203
13430: PPUSH
13431: LD_INT 120
13433: PPUSH
13434: CALL_OW 297
13438: PUSH
13439: LD_INT 6
13441: LESS
13442: OR
13443: IFFALSE 13406
// CenterNowOnUnits ( Omar ) ;
13445: LD_EXP 48
13449: PPUSH
13450: CALL_OW 87
// DialogueOn ;
13454: CALL_OW 6
// Say ( JMM , DOmarContam-JMM-1 ) ;
13458: LD_EXP 12
13462: PPUSH
13463: LD_STRING DOmarContam-JMM-1
13465: PPUSH
13466: CALL_OW 88
// Say ( Omar , DOmarContam-Omar-1 ) ;
13470: LD_EXP 48
13474: PPUSH
13475: LD_STRING DOmarContam-Omar-1
13477: PPUSH
13478: CALL_OW 88
// Say ( JMM , DOmarContam-JMM-2 ) ;
13482: LD_EXP 12
13486: PPUSH
13487: LD_STRING DOmarContam-JMM-2
13489: PPUSH
13490: CALL_OW 88
// DialogueOff ;
13494: CALL_OW 7
// SetAttitude ( 5 , 7 , att_enemy , true ) ;
13498: LD_INT 5
13500: PPUSH
13501: LD_INT 7
13503: PPUSH
13504: LD_INT 2
13506: PPUSH
13507: LD_INT 1
13509: PPUSH
13510: CALL_OW 80
// repeat wait ( 0 0$3 ) ;
13514: LD_INT 105
13516: PPUSH
13517: CALL_OW 67
// until IsAt ( Omar , 203 , 120 ) ;
13521: LD_EXP 48
13525: PPUSH
13526: LD_INT 203
13528: PPUSH
13529: LD_INT 120
13531: PPUSH
13532: CALL_OW 307
13536: IFFALSE 13514
// YouLost ( MothContaminate ) ;
13538: LD_STRING MothContaminate
13540: PPUSH
13541: CALL_OW 104
// end ;
13545: END
// every 0 0$2 trigger not americanDestroyed and FilterAllUnits ( [ [ f_side , 1 ] , [ f_weapon , us_siberium_rocket ] ] ) do
13546: LD_EXP 4
13550: NOT
13551: PUSH
13552: LD_INT 22
13554: PUSH
13555: LD_INT 1
13557: PUSH
13558: EMPTY
13559: LIST
13560: LIST
13561: PUSH
13562: LD_INT 34
13564: PUSH
13565: LD_INT 8
13567: PUSH
13568: EMPTY
13569: LIST
13570: LIST
13571: PUSH
13572: EMPTY
13573: LIST
13574: LIST
13575: PPUSH
13576: CALL_OW 69
13580: AND
13581: IFFALSE 13662
13583: GO 13585
13585: DISABLE
// begin if not IsOk ( Powell ) then
13586: LD_EXP 47
13590: PPUSH
13591: CALL_OW 302
13595: NOT
13596: IFFALSE 13600
// exit ;
13598: GO 13662
// DialogueOn ;
13600: CALL_OW 6
// SayRadio ( Powell , DWinAmericans-Pow-1 ) ;
13604: LD_EXP 47
13608: PPUSH
13609: LD_STRING DWinAmericans-Pow-1
13611: PPUSH
13612: CALL_OW 94
// if IsOk ( Burlak ) then
13616: LD_EXP 44
13620: PPUSH
13621: CALL_OW 302
13625: IFFALSE 13639
// Say ( Burlak , DWinAmericans-Bur-1 ) ;
13627: LD_EXP 44
13631: PPUSH
13632: LD_STRING DWinAmericans-Bur-1
13634: PPUSH
13635: CALL_OW 88
// Say ( JMM , DWinAmericans-JMM-1 ) ;
13639: LD_EXP 12
13643: PPUSH
13644: LD_STRING DWinAmericans-JMM-1
13646: PPUSH
13647: CALL_OW 88
// DialogueOff ;
13651: CALL_OW 7
// YouLost ( AmBomb ) ;
13655: LD_STRING AmBomb
13657: PPUSH
13658: CALL_OW 104
// end ;
13662: END
// every 0 0$2 trigger not russianDestroyed and FilterAllUnits ( [ [ f_side , 3 ] , [ f_weapon , ru_siberium_rocket ] ] ) do
13663: LD_EXP 2
13667: NOT
13668: PUSH
13669: LD_INT 22
13671: PUSH
13672: LD_INT 3
13674: PUSH
13675: EMPTY
13676: LIST
13677: LIST
13678: PUSH
13679: LD_INT 34
13681: PUSH
13682: LD_INT 48
13684: PUSH
13685: EMPTY
13686: LIST
13687: LIST
13688: PUSH
13689: EMPTY
13690: LIST
13691: LIST
13692: PPUSH
13693: CALL_OW 69
13697: AND
13698: IFFALSE 13779
13700: GO 13702
13702: DISABLE
// begin if not IsOk ( Platonov ) then
13703: LD_EXP 51
13707: PPUSH
13708: CALL_OW 302
13712: NOT
13713: IFFALSE 13717
// exit ;
13715: GO 13779
// DialogueOn ;
13717: CALL_OW 6
// SayRadio ( Platonov , DWinRussians-Pla-1 ) ;
13721: LD_EXP 51
13725: PPUSH
13726: LD_STRING DWinRussians-Pla-1
13728: PPUSH
13729: CALL_OW 94
// if IsOk ( Burlak ) then
13733: LD_EXP 44
13737: PPUSH
13738: CALL_OW 302
13742: IFFALSE 13756
// Say ( Burlak , DWinRussians-Bur-1 ) ;
13744: LD_EXP 44
13748: PPUSH
13749: LD_STRING DWinRussians-Bur-1
13751: PPUSH
13752: CALL_OW 88
// Say ( JMM , DWinRussians-JMM-1 ) ;
13756: LD_EXP 12
13760: PPUSH
13761: LD_STRING DWinRussians-JMM-1
13763: PPUSH
13764: CALL_OW 88
// DialogueOff ;
13768: CALL_OW 7
// YouLost ( RuBomb ) ;
13772: LD_STRING RuBomb
13774: PPUSH
13775: CALL_OW 104
// end ;
13779: END
// every 0 0$20 trigger FilterUnitsInArea ( powellBase , [ f_side , 7 ] ) and not americanDestroyed do
13780: LD_INT 7
13782: PPUSH
13783: LD_INT 22
13785: PUSH
13786: LD_INT 7
13788: PUSH
13789: EMPTY
13790: LIST
13791: LIST
13792: PPUSH
13793: CALL_OW 70
13797: PUSH
13798: LD_EXP 4
13802: NOT
13803: AND
13804: IFFALSE 13833
13806: GO 13808
13808: DISABLE
// begin SayRadio ( Powell , DSurrenderAmericans-Pow-1 ) ;
13809: LD_EXP 47
13813: PPUSH
13814: LD_STRING DSurrenderAmericans-Pow-1
13816: PPUSH
13817: CALL_OW 94
// Say ( JMM , DSurrenderAmericans-JMM-1 ) ;
13821: LD_EXP 12
13825: PPUSH
13826: LD_STRING DSurrenderAmericans-JMM-1
13828: PPUSH
13829: CALL_OW 88
// end ;
13833: END
// every 0 0$20 trigger FilterUnitsInArea ( russianBaseArea , [ f_side , 7 ] ) and not russianDestroyed and Burlak do
13834: LD_INT 2
13836: PPUSH
13837: LD_INT 22
13839: PUSH
13840: LD_INT 7
13842: PUSH
13843: EMPTY
13844: LIST
13845: LIST
13846: PPUSH
13847: CALL_OW 70
13851: PUSH
13852: LD_EXP 2
13856: NOT
13857: AND
13858: PUSH
13859: LD_EXP 44
13863: AND
13864: IFFALSE 13893
13866: GO 13868
13868: DISABLE
// begin SayRadio ( Platonov , DSurrenderRussians-Pla-1 ) ;
13869: LD_EXP 51
13873: PPUSH
13874: LD_STRING DSurrenderRussians-Pla-1
13876: PPUSH
13877: CALL_OW 94
// Say ( Burlak , DSurrenderRussians-Bur-1 ) ;
13881: LD_EXP 44
13885: PPUSH
13886: LD_STRING DSurrenderRussians-Bur-1
13888: PPUSH
13889: CALL_OW 88
// end ;
13893: END
// every 0 0$2 + 0 0$5 trigger americanDestroyed do var i , tmp , speaker ;
13894: LD_EXP 4
13898: IFFALSE 14273
13900: GO 13902
13902: DISABLE
13903: LD_INT 0
13905: PPUSH
13906: PPUSH
13907: PPUSH
// begin MC_Kill ( 4 ) ;
13908: LD_INT 4
13910: PPUSH
13911: CALL 20347 0 1
// SetAttitude ( 1 , 7 , att_friend , true ) ;
13915: LD_INT 1
13917: PPUSH
13918: LD_INT 7
13920: PPUSH
13921: LD_INT 1
13923: PPUSH
13924: LD_INT 1
13926: PPUSH
13927: CALL_OW 80
// speaker := FilterAllUnits ( [ [ f_side , 1 ] , [ f_sex , sex_male ] , [ f_nation , 1 ] ] ) diff [ Powell , Gladstone , Cyrus , Bobby , Gary , Houten ] ;
13931: LD_ADDR_VAR 0 3
13935: PUSH
13936: LD_INT 22
13938: PUSH
13939: LD_INT 1
13941: PUSH
13942: EMPTY
13943: LIST
13944: LIST
13945: PUSH
13946: LD_INT 26
13948: PUSH
13949: LD_INT 1
13951: PUSH
13952: EMPTY
13953: LIST
13954: LIST
13955: PUSH
13956: LD_INT 23
13958: PUSH
13959: LD_INT 1
13961: PUSH
13962: EMPTY
13963: LIST
13964: LIST
13965: PUSH
13966: EMPTY
13967: LIST
13968: LIST
13969: LIST
13970: PPUSH
13971: CALL_OW 69
13975: PUSH
13976: LD_EXP 47
13980: PUSH
13981: LD_EXP 20
13985: PUSH
13986: LD_EXP 17
13990: PUSH
13991: LD_EXP 16
13995: PUSH
13996: LD_EXP 23
14000: PUSH
14001: LD_EXP 21
14005: PUSH
14006: EMPTY
14007: LIST
14008: LIST
14009: LIST
14010: LIST
14011: LIST
14012: LIST
14013: DIFF
14014: ST_TO_ADDR
// if speaker then
14015: LD_VAR 0 3
14019: IFFALSE 14045
// begin DialogueOn ;
14021: CALL_OW 6
// SayRadio ( speaker [ 1 ] , DSurrenderAmericans-Sol1-1a ) ;
14025: LD_VAR 0 3
14029: PUSH
14030: LD_INT 1
14032: ARRAY
14033: PPUSH
14034: LD_STRING DSurrenderAmericans-Sol1-1a
14036: PPUSH
14037: CALL_OW 94
// DialogueOff ;
14041: CALL_OW 7
// end ; tmp := FilterAllUnits ( [ [ f_side , 1 ] , [ f_type , unit_human ] ] ) ^ FilterAllUnits ( [ [ f_side , 1 ] , [ f_type , unit_vehicle ] , [ control_manual ] ] ) ;
14045: LD_ADDR_VAR 0 2
14049: PUSH
14050: LD_INT 22
14052: PUSH
14053: LD_INT 1
14055: PUSH
14056: EMPTY
14057: LIST
14058: LIST
14059: PUSH
14060: LD_INT 21
14062: PUSH
14063: LD_INT 1
14065: PUSH
14066: EMPTY
14067: LIST
14068: LIST
14069: PUSH
14070: EMPTY
14071: LIST
14072: LIST
14073: PPUSH
14074: CALL_OW 69
14078: PUSH
14079: LD_INT 22
14081: PUSH
14082: LD_INT 1
14084: PUSH
14085: EMPTY
14086: LIST
14087: LIST
14088: PUSH
14089: LD_INT 21
14091: PUSH
14092: LD_INT 2
14094: PUSH
14095: EMPTY
14096: LIST
14097: LIST
14098: PUSH
14099: LD_INT 1
14101: PUSH
14102: EMPTY
14103: LIST
14104: PUSH
14105: EMPTY
14106: LIST
14107: LIST
14108: LIST
14109: PPUSH
14110: CALL_OW 69
14114: ADD
14115: ST_TO_ADDR
// if tmp then
14116: LD_VAR 0 2
14120: IFFALSE 14273
// repeat wait ( 0 0$1 ) ;
14122: LD_INT 35
14124: PPUSH
14125: CALL_OW 67
// for i in tmp do
14129: LD_ADDR_VAR 0 1
14133: PUSH
14134: LD_VAR 0 2
14138: PUSH
14139: FOR_IN
14140: IFFALSE 14222
// begin if IsInUnit ( i ) and GetType ( IsInUnit ( i ) ) = unit_building then
14142: LD_VAR 0 1
14146: PPUSH
14147: CALL_OW 310
14151: PUSH
14152: LD_VAR 0 1
14156: PPUSH
14157: CALL_OW 310
14161: PPUSH
14162: CALL_OW 247
14166: PUSH
14167: LD_INT 3
14169: EQUAL
14170: AND
14171: IFFALSE 14182
// ComExitBuilding ( i ) ;
14173: LD_VAR 0 1
14177: PPUSH
14178: CALL_OW 122
// AddComMoveXY ( i , 122 , 242 ) ;
14182: LD_VAR 0 1
14186: PPUSH
14187: LD_INT 122
14189: PPUSH
14190: LD_INT 242
14192: PPUSH
14193: CALL_OW 171
// if IsInArea ( i , americanEscape ) then
14197: LD_VAR 0 1
14201: PPUSH
14202: LD_INT 35
14204: PPUSH
14205: CALL_OW 308
14209: IFFALSE 14220
// RemoveUnit ( i ) ;
14211: LD_VAR 0 1
14215: PPUSH
14216: CALL_OW 64
// end ;
14220: GO 14139
14222: POP
14223: POP
// until not FilterAllUnits ( [ [ f_side , 1 ] , [ f_or , [ f_type , unit_human ] , [ f_control , control_manual ] ] ] ) ;
14224: LD_INT 22
14226: PUSH
14227: LD_INT 1
14229: PUSH
14230: EMPTY
14231: LIST
14232: LIST
14233: PUSH
14234: LD_INT 2
14236: PUSH
14237: LD_INT 21
14239: PUSH
14240: LD_INT 1
14242: PUSH
14243: EMPTY
14244: LIST
14245: LIST
14246: PUSH
14247: LD_INT 33
14249: PUSH
14250: LD_INT 1
14252: PUSH
14253: EMPTY
14254: LIST
14255: LIST
14256: PUSH
14257: EMPTY
14258: LIST
14259: LIST
14260: LIST
14261: PUSH
14262: EMPTY
14263: LIST
14264: LIST
14265: PPUSH
14266: CALL_OW 69
14270: NOT
14271: IFFALSE 14122
// end ;
14273: PPOPN 3
14275: END
// every 0 0$2 + 0 0$5 trigger russianDestroyed do var i , tmp , speaker ;
14276: LD_EXP 2
14280: IFFALSE 14673
14282: GO 14284
14284: DISABLE
14285: LD_INT 0
14287: PPUSH
14288: PPUSH
14289: PPUSH
// begin repeat wait ( 0 0$1 ) ;
14290: LD_INT 35
14292: PPUSH
14293: CALL_OW 67
// until IsDead ( Yakotich ) ;
14297: LD_EXP 52
14301: PPUSH
14302: CALL_OW 301
14306: IFFALSE 14290
// MC_Kill ( 2 ) ;
14308: LD_INT 2
14310: PPUSH
14311: CALL 20347 0 1
// SetAttitude ( 3 , 7 , att_friend , true ) ;
14315: LD_INT 3
14317: PPUSH
14318: LD_INT 7
14320: PPUSH
14321: LD_INT 1
14323: PPUSH
14324: LD_INT 1
14326: PPUSH
14327: CALL_OW 80
// speaker := FilterAllUnits ( [ [ f_side , 3 ] , [ f_sex , sex_male ] , [ f_nation , 3 ] ] ) diff [ Platonov , Yakotich ] ;
14331: LD_ADDR_VAR 0 3
14335: PUSH
14336: LD_INT 22
14338: PUSH
14339: LD_INT 3
14341: PUSH
14342: EMPTY
14343: LIST
14344: LIST
14345: PUSH
14346: LD_INT 26
14348: PUSH
14349: LD_INT 1
14351: PUSH
14352: EMPTY
14353: LIST
14354: LIST
14355: PUSH
14356: LD_INT 23
14358: PUSH
14359: LD_INT 3
14361: PUSH
14362: EMPTY
14363: LIST
14364: LIST
14365: PUSH
14366: EMPTY
14367: LIST
14368: LIST
14369: LIST
14370: PPUSH
14371: CALL_OW 69
14375: PUSH
14376: LD_EXP 51
14380: PUSH
14381: LD_EXP 52
14385: PUSH
14386: EMPTY
14387: LIST
14388: LIST
14389: DIFF
14390: ST_TO_ADDR
// if speaker then
14391: LD_VAR 0 3
14395: IFFALSE 14445
// begin DialogueOn ;
14397: CALL_OW 6
// if Burlak then
14401: LD_EXP 44
14405: IFFALSE 14425
// SayRadio ( speaker [ 1 ] , DSurrenderRussians-RSol1-1 ) else
14407: LD_VAR 0 3
14411: PUSH
14412: LD_INT 1
14414: ARRAY
14415: PPUSH
14416: LD_STRING DSurrenderRussians-RSol1-1
14418: PPUSH
14419: CALL_OW 94
14423: GO 14441
// SayRadio ( speaker [ 1 ] , DSurrenderRussians-RSol1-1a ) ;
14425: LD_VAR 0 3
14429: PUSH
14430: LD_INT 1
14432: ARRAY
14433: PPUSH
14434: LD_STRING DSurrenderRussians-RSol1-1a
14436: PPUSH
14437: CALL_OW 94
// DialogueOff ;
14441: CALL_OW 7
// end ; tmp := FilterAllUnits ( [ [ f_side , 3 ] , [ f_type , unit_human ] ] ) ^ FilterAllUnits ( [ [ f_side , 3 ] , [ f_type , unit_vehicle ] , [ control_manual ] ] ) ;
14445: LD_ADDR_VAR 0 2
14449: PUSH
14450: LD_INT 22
14452: PUSH
14453: LD_INT 3
14455: PUSH
14456: EMPTY
14457: LIST
14458: LIST
14459: PUSH
14460: LD_INT 21
14462: PUSH
14463: LD_INT 1
14465: PUSH
14466: EMPTY
14467: LIST
14468: LIST
14469: PUSH
14470: EMPTY
14471: LIST
14472: LIST
14473: PPUSH
14474: CALL_OW 69
14478: PUSH
14479: LD_INT 22
14481: PUSH
14482: LD_INT 3
14484: PUSH
14485: EMPTY
14486: LIST
14487: LIST
14488: PUSH
14489: LD_INT 21
14491: PUSH
14492: LD_INT 2
14494: PUSH
14495: EMPTY
14496: LIST
14497: LIST
14498: PUSH
14499: LD_INT 1
14501: PUSH
14502: EMPTY
14503: LIST
14504: PUSH
14505: EMPTY
14506: LIST
14507: LIST
14508: LIST
14509: PPUSH
14510: CALL_OW 69
14514: ADD
14515: ST_TO_ADDR
// if tmp then
14516: LD_VAR 0 2
14520: IFFALSE 14673
// repeat wait ( 0 0$1 ) ;
14522: LD_INT 35
14524: PPUSH
14525: CALL_OW 67
// for i in tmp do
14529: LD_ADDR_VAR 0 1
14533: PUSH
14534: LD_VAR 0 2
14538: PUSH
14539: FOR_IN
14540: IFFALSE 14622
// begin if IsInUnit ( i ) and GetType ( IsInUnit ( i ) ) = unit_building then
14542: LD_VAR 0 1
14546: PPUSH
14547: CALL_OW 310
14551: PUSH
14552: LD_VAR 0 1
14556: PPUSH
14557: CALL_OW 310
14561: PPUSH
14562: CALL_OW 247
14566: PUSH
14567: LD_INT 3
14569: EQUAL
14570: AND
14571: IFFALSE 14582
// ComExitBuilding ( i ) ;
14573: LD_VAR 0 1
14577: PPUSH
14578: CALL_OW 122
// AddComMoveXY ( i , 154 , 1 ) ;
14582: LD_VAR 0 1
14586: PPUSH
14587: LD_INT 154
14589: PPUSH
14590: LD_INT 1
14592: PPUSH
14593: CALL_OW 171
// if IsInArea ( i , russianEscape ) then
14597: LD_VAR 0 1
14601: PPUSH
14602: LD_INT 36
14604: PPUSH
14605: CALL_OW 308
14609: IFFALSE 14620
// RemoveUnit ( i ) ;
14611: LD_VAR 0 1
14615: PPUSH
14616: CALL_OW 64
// end ;
14620: GO 14539
14622: POP
14623: POP
// until not FilterAllUnits ( [ [ f_side , 3 ] , [ f_or , [ f_type , unit_human ] , [ f_control , control_manual ] ] ] ) ;
14624: LD_INT 22
14626: PUSH
14627: LD_INT 3
14629: PUSH
14630: EMPTY
14631: LIST
14632: LIST
14633: PUSH
14634: LD_INT 2
14636: PUSH
14637: LD_INT 21
14639: PUSH
14640: LD_INT 1
14642: PUSH
14643: EMPTY
14644: LIST
14645: LIST
14646: PUSH
14647: LD_INT 33
14649: PUSH
14650: LD_INT 1
14652: PUSH
14653: EMPTY
14654: LIST
14655: LIST
14656: PUSH
14657: EMPTY
14658: LIST
14659: LIST
14660: LIST
14661: PUSH
14662: EMPTY
14663: LIST
14664: LIST
14665: PPUSH
14666: CALL_OW 69
14670: NOT
14671: IFFALSE 14522
// end ;
14673: PPOPN 3
14675: END
// every 0 0$3 trigger FilterAllUnits ( [ [ f_side , 8 ] , [ f_type , unit_human ] , [ f_nation , 2 ] ] ) < 18 or IsDead ( Kozlov ) do
14676: LD_INT 22
14678: PUSH
14679: LD_INT 8
14681: PUSH
14682: EMPTY
14683: LIST
14684: LIST
14685: PUSH
14686: LD_INT 21
14688: PUSH
14689: LD_INT 1
14691: PUSH
14692: EMPTY
14693: LIST
14694: LIST
14695: PUSH
14696: LD_INT 23
14698: PUSH
14699: LD_INT 2
14701: PUSH
14702: EMPTY
14703: LIST
14704: LIST
14705: PUSH
14706: EMPTY
14707: LIST
14708: LIST
14709: LIST
14710: PPUSH
14711: CALL_OW 69
14715: PUSH
14716: LD_INT 18
14718: LESS
14719: PUSH
14720: LD_EXP 50
14724: PPUSH
14725: CALL_OW 301
14729: OR
14730: IFFALSE 14743
14732: GO 14734
14734: DISABLE
// legionDestroyed := true ;
14735: LD_ADDR_EXP 3
14739: PUSH
14740: LD_INT 1
14742: ST_TO_ADDR
14743: END
// every 0 0$3 trigger FilterAllUnits ( [ [ f_side , 2 ] , [ f_type , unit_human ] , [ f_nation , 2 ] ] ) < 9 do
14744: LD_INT 22
14746: PUSH
14747: LD_INT 2
14749: PUSH
14750: EMPTY
14751: LIST
14752: LIST
14753: PUSH
14754: LD_INT 21
14756: PUSH
14757: LD_INT 1
14759: PUSH
14760: EMPTY
14761: LIST
14762: LIST
14763: PUSH
14764: LD_INT 23
14766: PUSH
14767: LD_INT 2
14769: PUSH
14770: EMPTY
14771: LIST
14772: LIST
14773: PUSH
14774: EMPTY
14775: LIST
14776: LIST
14777: LIST
14778: PPUSH
14779: CALL_OW 69
14783: PUSH
14784: LD_INT 9
14786: LESS
14787: IFFALSE 14800
14789: GO 14791
14791: DISABLE
// arabianDestroyed := true ;
14792: LD_ADDR_EXP 5
14796: PUSH
14797: LD_INT 1
14799: ST_TO_ADDR
14800: END
// every 0 0$1 trigger arabianDestroyed do var i , tmp ;
14801: LD_EXP 5
14805: IFFALSE 15065
14807: GO 14809
14809: DISABLE
14810: LD_INT 0
14812: PPUSH
14813: PPUSH
// begin MC_Kill ( 1 ) ;
14814: LD_INT 1
14816: PPUSH
14817: CALL 20347 0 1
// SetAttitude ( 2 , 7 , att_friend , true ) ;
14821: LD_INT 2
14823: PPUSH
14824: LD_INT 7
14826: PPUSH
14827: LD_INT 1
14829: PPUSH
14830: LD_INT 1
14832: PPUSH
14833: CALL_OW 80
// tmp := FilterAllUnits ( [ [ f_side , 2 ] , [ f_type , unit_human ] ] ) ^ FilterAllUnits ( [ [ f_side , 8 ] , [ f_type , unit_vehicle ] , [ control_manual ] ] ) ;
14837: LD_ADDR_VAR 0 2
14841: PUSH
14842: LD_INT 22
14844: PUSH
14845: LD_INT 2
14847: PUSH
14848: EMPTY
14849: LIST
14850: LIST
14851: PUSH
14852: LD_INT 21
14854: PUSH
14855: LD_INT 1
14857: PUSH
14858: EMPTY
14859: LIST
14860: LIST
14861: PUSH
14862: EMPTY
14863: LIST
14864: LIST
14865: PPUSH
14866: CALL_OW 69
14870: PUSH
14871: LD_INT 22
14873: PUSH
14874: LD_INT 8
14876: PUSH
14877: EMPTY
14878: LIST
14879: LIST
14880: PUSH
14881: LD_INT 21
14883: PUSH
14884: LD_INT 2
14886: PUSH
14887: EMPTY
14888: LIST
14889: LIST
14890: PUSH
14891: LD_INT 1
14893: PUSH
14894: EMPTY
14895: LIST
14896: PUSH
14897: EMPTY
14898: LIST
14899: LIST
14900: LIST
14901: PPUSH
14902: CALL_OW 69
14906: ADD
14907: ST_TO_ADDR
// if tmp then
14908: LD_VAR 0 2
14912: IFFALSE 15065
// repeat wait ( 0 0$1 ) ;
14914: LD_INT 35
14916: PPUSH
14917: CALL_OW 67
// for i in tmp do
14921: LD_ADDR_VAR 0 1
14925: PUSH
14926: LD_VAR 0 2
14930: PUSH
14931: FOR_IN
14932: IFFALSE 15014
// begin if IsInUnit ( i ) and GetType ( IsInUnit ( i ) ) = unit_building then
14934: LD_VAR 0 1
14938: PPUSH
14939: CALL_OW 310
14943: PUSH
14944: LD_VAR 0 1
14948: PPUSH
14949: CALL_OW 310
14953: PPUSH
14954: CALL_OW 247
14958: PUSH
14959: LD_INT 3
14961: EQUAL
14962: AND
14963: IFFALSE 14974
// ComExitBuilding ( i ) ;
14965: LD_VAR 0 1
14969: PPUSH
14970: CALL_OW 122
// AddComMoveXY ( i , 254 , 268 ) ;
14974: LD_VAR 0 1
14978: PPUSH
14979: LD_INT 254
14981: PPUSH
14982: LD_INT 268
14984: PPUSH
14985: CALL_OW 171
// if IsInArea ( i , arabEscape ) then
14989: LD_VAR 0 1
14993: PPUSH
14994: LD_INT 34
14996: PPUSH
14997: CALL_OW 308
15001: IFFALSE 15012
// RemoveUnit ( i ) ;
15003: LD_VAR 0 1
15007: PPUSH
15008: CALL_OW 64
// end ;
15012: GO 14931
15014: POP
15015: POP
// until not FilterAllUnits ( [ [ f_side , 2 ] , [ f_or , [ f_type , unit_human ] , [ f_control , control_manual ] ] ] ) ;
15016: LD_INT 22
15018: PUSH
15019: LD_INT 2
15021: PUSH
15022: EMPTY
15023: LIST
15024: LIST
15025: PUSH
15026: LD_INT 2
15028: PUSH
15029: LD_INT 21
15031: PUSH
15032: LD_INT 1
15034: PUSH
15035: EMPTY
15036: LIST
15037: LIST
15038: PUSH
15039: LD_INT 33
15041: PUSH
15042: LD_INT 1
15044: PUSH
15045: EMPTY
15046: LIST
15047: LIST
15048: PUSH
15049: EMPTY
15050: LIST
15051: LIST
15052: LIST
15053: PUSH
15054: EMPTY
15055: LIST
15056: LIST
15057: PPUSH
15058: CALL_OW 69
15062: NOT
15063: IFFALSE 14914
// end ;
15065: PPOPN 2
15067: END
// every 0 0$1 trigger legionDestroyed do var i , tmp ;
15068: LD_EXP 3
15072: IFFALSE 15413
15074: GO 15076
15076: DISABLE
15077: LD_INT 0
15079: PPUSH
15080: PPUSH
// begin MC_Kill ( 3 ) ;
15081: LD_INT 3
15083: PPUSH
15084: CALL 20347 0 1
// SetAttitude ( 8 , 7 , att_friend , true ) ;
15088: LD_INT 8
15090: PPUSH
15091: LD_INT 7
15093: PPUSH
15094: LD_INT 1
15096: PPUSH
15097: LD_INT 1
15099: PPUSH
15100: CALL_OW 80
// DialogueOn ;
15104: CALL_OW 6
// SayRadio ( Schulz , D15-Szulc-1 ) ;
15108: LD_EXP 49
15112: PPUSH
15113: LD_STRING D15-Szulc-1
15115: PPUSH
15116: CALL_OW 94
// DialogueOff ;
15120: CALL_OW 7
// for i in FilterAllUnits ( [ [ f_side , 8 ] , [ f_type , unit_building ] , [ f_nation , 3 ] ] ) do
15124: LD_ADDR_VAR 0 1
15128: PUSH
15129: LD_INT 22
15131: PUSH
15132: LD_INT 8
15134: PUSH
15135: EMPTY
15136: LIST
15137: LIST
15138: PUSH
15139: LD_INT 21
15141: PUSH
15142: LD_INT 3
15144: PUSH
15145: EMPTY
15146: LIST
15147: LIST
15148: PUSH
15149: LD_INT 23
15151: PUSH
15152: LD_INT 3
15154: PUSH
15155: EMPTY
15156: LIST
15157: LIST
15158: PUSH
15159: EMPTY
15160: LIST
15161: LIST
15162: LIST
15163: PPUSH
15164: CALL_OW 69
15168: PUSH
15169: FOR_IN
15170: IFFALSE 15183
// DestroyUnit ( i ) ;
15172: LD_VAR 0 1
15176: PPUSH
15177: CALL_OW 65
15181: GO 15169
15183: POP
15184: POP
// tmp := FilterAllUnits ( [ [ f_side , 8 ] , [ f_type , unit_human ] ] ) ^ FilterAllUnits ( [ [ f_side , 8 ] , [ f_type , unit_vehicle ] , [ control_manual ] ] ) ;
15185: LD_ADDR_VAR 0 2
15189: PUSH
15190: LD_INT 22
15192: PUSH
15193: LD_INT 8
15195: PUSH
15196: EMPTY
15197: LIST
15198: LIST
15199: PUSH
15200: LD_INT 21
15202: PUSH
15203: LD_INT 1
15205: PUSH
15206: EMPTY
15207: LIST
15208: LIST
15209: PUSH
15210: EMPTY
15211: LIST
15212: LIST
15213: PPUSH
15214: CALL_OW 69
15218: PUSH
15219: LD_INT 22
15221: PUSH
15222: LD_INT 8
15224: PUSH
15225: EMPTY
15226: LIST
15227: LIST
15228: PUSH
15229: LD_INT 21
15231: PUSH
15232: LD_INT 2
15234: PUSH
15235: EMPTY
15236: LIST
15237: LIST
15238: PUSH
15239: LD_INT 1
15241: PUSH
15242: EMPTY
15243: LIST
15244: PUSH
15245: EMPTY
15246: LIST
15247: LIST
15248: LIST
15249: PPUSH
15250: CALL_OW 69
15254: ADD
15255: ST_TO_ADDR
// if tmp then
15256: LD_VAR 0 2
15260: IFFALSE 15413
// repeat wait ( 0 0$1 ) ;
15262: LD_INT 35
15264: PPUSH
15265: CALL_OW 67
// for i in tmp do
15269: LD_ADDR_VAR 0 1
15273: PUSH
15274: LD_VAR 0 2
15278: PUSH
15279: FOR_IN
15280: IFFALSE 15362
// begin if IsInUnit ( i ) and GetType ( IsInUnit ( i ) ) = unit_building then
15282: LD_VAR 0 1
15286: PPUSH
15287: CALL_OW 310
15291: PUSH
15292: LD_VAR 0 1
15296: PPUSH
15297: CALL_OW 310
15301: PPUSH
15302: CALL_OW 247
15306: PUSH
15307: LD_INT 3
15309: EQUAL
15310: AND
15311: IFFALSE 15322
// ComExitBuilding ( i ) ;
15313: LD_VAR 0 1
15317: PPUSH
15318: CALL_OW 122
// AddComMoveXY ( i , 10 , 1 ) ;
15322: LD_VAR 0 1
15326: PPUSH
15327: LD_INT 10
15329: PPUSH
15330: LD_INT 1
15332: PPUSH
15333: CALL_OW 171
// if IsInArea ( i , legionEscape ) then
15337: LD_VAR 0 1
15341: PPUSH
15342: LD_INT 32
15344: PPUSH
15345: CALL_OW 308
15349: IFFALSE 15360
// RemoveUnit ( i ) ;
15351: LD_VAR 0 1
15355: PPUSH
15356: CALL_OW 64
// end ;
15360: GO 15279
15362: POP
15363: POP
// until not FilterAllUnits ( [ [ f_side , 8 ] , [ f_or , [ f_type , unit_human ] , [ f_control , control_manual ] ] ] ) ;
15364: LD_INT 22
15366: PUSH
15367: LD_INT 8
15369: PUSH
15370: EMPTY
15371: LIST
15372: LIST
15373: PUSH
15374: LD_INT 2
15376: PUSH
15377: LD_INT 21
15379: PUSH
15380: LD_INT 1
15382: PUSH
15383: EMPTY
15384: LIST
15385: LIST
15386: PUSH
15387: LD_INT 33
15389: PUSH
15390: LD_INT 1
15392: PUSH
15393: EMPTY
15394: LIST
15395: LIST
15396: PUSH
15397: EMPTY
15398: LIST
15399: LIST
15400: LIST
15401: PUSH
15402: EMPTY
15403: LIST
15404: LIST
15405: PPUSH
15406: CALL_OW 69
15410: NOT
15411: IFFALSE 15262
// end ;
15413: PPOPN 2
15415: END
// every 0 0$3 trigger americanDestroyed and russianDestroyed and legionDestroyed and arabianDestroyed do var med1 , med2 ;
15416: LD_EXP 4
15420: PUSH
15421: LD_EXP 2
15425: AND
15426: PUSH
15427: LD_EXP 3
15431: AND
15432: PUSH
15433: LD_EXP 5
15437: AND
15438: IFFALSE 16781
15440: GO 15442
15442: DISABLE
15443: LD_INT 0
15445: PPUSH
15446: PPUSH
// begin music_class := 5 ;
15447: LD_ADDR_OWVAR 72
15451: PUSH
15452: LD_INT 5
15454: ST_TO_ADDR
// music_nat := 5 ;
15455: LD_ADDR_OWVAR 71
15459: PUSH
15460: LD_INT 5
15462: ST_TO_ADDR
// CenterNowOnUnits ( JMM ) ;
15463: LD_EXP 12
15467: PPUSH
15468: CALL_OW 87
// InGameOn ;
15472: CALL_OW 8
// DialogueOn ;
15476: CALL_OW 6
// Say ( JMM , DEnd-JMM-JMM-1 ) ;
15480: LD_EXP 12
15484: PPUSH
15485: LD_STRING DEnd-JMM-JMM-1
15487: PPUSH
15488: CALL_OW 88
// if Joan then
15492: LD_EXP 27
15496: IFFALSE 15512
// Say ( Joan , DEnd-JMM-Joan-1 ) else
15498: LD_EXP 27
15502: PPUSH
15503: LD_STRING DEnd-JMM-Joan-1
15505: PPUSH
15506: CALL_OW 88
15510: GO 15556
// if Lisa and GetSide ( Lisa ) = 7 and IsPlaced ( Lisa ) then
15512: LD_EXP 14
15516: PUSH
15517: LD_EXP 14
15521: PPUSH
15522: CALL_OW 255
15526: PUSH
15527: LD_INT 7
15529: EQUAL
15530: AND
15531: PUSH
15532: LD_EXP 14
15536: PPUSH
15537: CALL_OW 305
15541: AND
15542: IFFALSE 15556
// Say ( Lisa , DEnd-JMM-Lisa-1 ) ;
15544: LD_EXP 14
15548: PPUSH
15549: LD_STRING DEnd-JMM-Lisa-1
15551: PPUSH
15552: CALL_OW 88
// if Frank and IsPlaced ( Frank ) then
15556: LD_EXP 24
15560: PUSH
15561: LD_EXP 24
15565: PPUSH
15566: CALL_OW 305
15570: AND
15571: IFFALSE 15585
// Say ( Frank , DEnd-JMM-Frank-1 ) ;
15573: LD_EXP 24
15577: PPUSH
15578: LD_STRING DEnd-JMM-Frank-1
15580: PPUSH
15581: CALL_OW 88
// if Cyrus and GetSide ( Cyrus ) = 7 and IsPlaced ( Cyrus ) then
15585: LD_EXP 17
15589: PUSH
15590: LD_EXP 17
15594: PPUSH
15595: CALL_OW 255
15599: PUSH
15600: LD_INT 7
15602: EQUAL
15603: AND
15604: PUSH
15605: LD_EXP 17
15609: PPUSH
15610: CALL_OW 305
15614: AND
15615: IFFALSE 15629
// Say ( Cyrus , DEnd-JMM-Cyrus-1 ) ;
15617: LD_EXP 17
15621: PPUSH
15622: LD_STRING DEnd-JMM-Cyrus-1
15624: PPUSH
15625: CALL_OW 88
// if Burlak then
15629: LD_EXP 44
15633: IFFALSE 15647
// Say ( Burlak , DEnd-JMM-Bur-1 ) ;
15635: LD_EXP 44
15639: PPUSH
15640: LD_STRING DEnd-JMM-Bur-1
15642: PPUSH
15643: CALL_OW 88
// if Joan and Lisa and GetSide ( Lisa ) = 7 and IsPlaced ( Lisa ) then
15647: LD_EXP 27
15651: PUSH
15652: LD_EXP 14
15656: AND
15657: PUSH
15658: LD_EXP 14
15662: PPUSH
15663: CALL_OW 255
15667: PUSH
15668: LD_INT 7
15670: EQUAL
15671: AND
15672: PUSH
15673: LD_EXP 14
15677: PPUSH
15678: CALL_OW 305
15682: AND
15683: IFFALSE 15697
// Say ( Lisa , DEnd-Burlak-Lisa-1 ) ;
15685: LD_EXP 14
15689: PPUSH
15690: LD_STRING DEnd-Burlak-Lisa-1
15692: PPUSH
15693: CALL_OW 88
// if Belkov and IsPlaced ( Belkov ) then
15697: LD_EXP 45
15701: PUSH
15702: LD_EXP 45
15706: PPUSH
15707: CALL_OW 305
15711: AND
15712: IFFALSE 15726
// Say ( Belkov , DEnd-JMM-Bel-1 ) ;
15714: LD_EXP 45
15718: PPUSH
15719: LD_STRING DEnd-JMM-Bel-1
15721: PPUSH
15722: CALL_OW 88
// if Gnyevko and IsPlaced ( Gnyevko ) then
15726: LD_EXP 46
15730: PUSH
15731: LD_EXP 46
15735: PPUSH
15736: CALL_OW 305
15740: AND
15741: IFFALSE 15755
// Say ( Gnyevko , DEnd-JMM-Gny-1 ) ;
15743: LD_EXP 46
15747: PPUSH
15748: LD_STRING DEnd-JMM-Gny-1
15750: PPUSH
15751: CALL_OW 88
// if Cornel and GetSide ( Cornel ) = 7 and IsPlaced ( Cornel ) then
15755: LD_EXP 22
15759: PUSH
15760: LD_EXP 22
15764: PPUSH
15765: CALL_OW 255
15769: PUSH
15770: LD_INT 7
15772: EQUAL
15773: AND
15774: PUSH
15775: LD_EXP 22
15779: PPUSH
15780: CALL_OW 305
15784: AND
15785: IFFALSE 15799
// Say ( Cornel , DEnd-JMM-Corn-1 ) ;
15787: LD_EXP 22
15791: PPUSH
15792: LD_STRING DEnd-JMM-Corn-1
15794: PPUSH
15795: CALL_OW 88
// if Donaldson and GetSide ( Donaldson ) = 7 and IsPlaced ( Donaldson ) then
15799: LD_EXP 15
15803: PUSH
15804: LD_EXP 15
15808: PPUSH
15809: CALL_OW 255
15813: PUSH
15814: LD_INT 7
15816: EQUAL
15817: AND
15818: PUSH
15819: LD_EXP 15
15823: PPUSH
15824: CALL_OW 305
15828: AND
15829: IFFALSE 15843
// Say ( Donaldson , DEnd-JMM-Don-1 ) ;
15831: LD_EXP 15
15835: PPUSH
15836: LD_STRING DEnd-JMM-Don-1
15838: PPUSH
15839: CALL_OW 88
// if Bobby and GetSide ( Bobby ) = 7 and IsPlaced ( Bobby ) then
15843: LD_EXP 16
15847: PUSH
15848: LD_EXP 16
15852: PPUSH
15853: CALL_OW 255
15857: PUSH
15858: LD_INT 7
15860: EQUAL
15861: AND
15862: PUSH
15863: LD_EXP 16
15867: PPUSH
15868: CALL_OW 305
15872: AND
15873: IFFALSE 15887
// Say ( Bobby , DEnd-JMM-Bobby-1 ) ;
15875: LD_EXP 16
15879: PPUSH
15880: LD_STRING DEnd-JMM-Bobby-1
15882: PPUSH
15883: CALL_OW 88
// if Denis and GetSide ( Denis ) = 7 and IsPlaced ( Denis ) then
15887: LD_EXP 18
15891: PUSH
15892: LD_EXP 18
15896: PPUSH
15897: CALL_OW 255
15901: PUSH
15902: LD_INT 7
15904: EQUAL
15905: AND
15906: PUSH
15907: LD_EXP 18
15911: PPUSH
15912: CALL_OW 305
15916: AND
15917: IFFALSE 15931
// Say ( Denis , DEnd-JMM-Den-1 ) ;
15919: LD_EXP 18
15923: PPUSH
15924: LD_STRING DEnd-JMM-Den-1
15926: PPUSH
15927: CALL_OW 88
// if Gladstone and GetSide ( Gladstone ) = 7 and IsPlaced ( Gladstone ) then
15931: LD_EXP 20
15935: PUSH
15936: LD_EXP 20
15940: PPUSH
15941: CALL_OW 255
15945: PUSH
15946: LD_INT 7
15948: EQUAL
15949: AND
15950: PUSH
15951: LD_EXP 20
15955: PPUSH
15956: CALL_OW 305
15960: AND
15961: IFFALSE 15975
// Say ( Gladstone , DEnd-JMM-Glad-1 ) ;
15963: LD_EXP 20
15967: PPUSH
15968: LD_STRING DEnd-JMM-Glad-1
15970: PPUSH
15971: CALL_OW 88
// if Kikuchi and GetSide ( Kikuchi ) = 7 and IsPlaced ( Kikuchi ) then
15975: LD_EXP 25
15979: PUSH
15980: LD_EXP 25
15984: PPUSH
15985: CALL_OW 255
15989: PUSH
15990: LD_INT 7
15992: EQUAL
15993: AND
15994: PUSH
15995: LD_EXP 25
15999: PPUSH
16000: CALL_OW 305
16004: AND
16005: IFFALSE 16019
// Say ( Kikuchi , DEnd-JMM-Yam-1 ) ;
16007: LD_EXP 25
16011: PPUSH
16012: LD_STRING DEnd-JMM-Yam-1
16014: PPUSH
16015: CALL_OW 88
// if Brown and GetSide ( Brown ) = 7 and IsPlaced ( Brown ) then
16019: LD_EXP 19
16023: PUSH
16024: LD_EXP 19
16028: PPUSH
16029: CALL_OW 255
16033: PUSH
16034: LD_INT 7
16036: EQUAL
16037: AND
16038: PUSH
16039: LD_EXP 19
16043: PPUSH
16044: CALL_OW 305
16048: AND
16049: IFFALSE 16063
// Say ( Brown , DEnd-JMM-Brown-1 ) ;
16051: LD_EXP 19
16055: PPUSH
16056: LD_STRING DEnd-JMM-Brown-1
16058: PPUSH
16059: CALL_OW 88
// if Connie and GetSide ( Connie ) = 7 and IsPlaced ( Connie ) then
16063: LD_EXP 29
16067: PUSH
16068: LD_EXP 29
16072: PPUSH
16073: CALL_OW 255
16077: PUSH
16078: LD_INT 7
16080: EQUAL
16081: AND
16082: PUSH
16083: LD_EXP 29
16087: PPUSH
16088: CALL_OW 305
16092: AND
16093: IFFALSE 16107
// Say ( Connie , DEnd-JMM-Con-1 ) ;
16095: LD_EXP 29
16099: PPUSH
16100: LD_STRING DEnd-JMM-Con-1
16102: PPUSH
16103: CALL_OW 88
// if Gary and GetSide ( Gary ) = 7 and IsPlaced ( Gary ) then
16107: LD_EXP 23
16111: PUSH
16112: LD_EXP 23
16116: PPUSH
16117: CALL_OW 255
16121: PUSH
16122: LD_INT 7
16124: EQUAL
16125: AND
16126: PUSH
16127: LD_EXP 23
16131: PPUSH
16132: CALL_OW 305
16136: AND
16137: IFFALSE 16151
// Say ( Gary , DEnd-JMM-Gary-1 ) ;
16139: LD_EXP 23
16143: PPUSH
16144: LD_STRING DEnd-JMM-Gary-1
16146: PPUSH
16147: CALL_OW 88
// if Simms and Roth and IsPlaced ( Simms ) then
16151: LD_EXP 26
16155: PUSH
16156: LD_EXP 13
16160: AND
16161: PUSH
16162: LD_EXP 26
16166: PPUSH
16167: CALL_OW 305
16171: AND
16172: IFFALSE 16186
// Say ( Simms , DEnd-JMM-Sim-1 ) ;
16174: LD_EXP 26
16178: PPUSH
16179: LD_STRING DEnd-JMM-Sim-1
16181: PPUSH
16182: CALL_OW 88
// if Houten and GetSide ( Houten ) = 7 and IsPlaced ( Houten ) then
16186: LD_EXP 21
16190: PUSH
16191: LD_EXP 21
16195: PPUSH
16196: CALL_OW 255
16200: PUSH
16201: LD_INT 7
16203: EQUAL
16204: AND
16205: PUSH
16206: LD_EXP 21
16210: PPUSH
16211: CALL_OW 305
16215: AND
16216: IFFALSE 16230
// Say ( Houten , DEnd-JMM-VanH-1 ) ;
16218: LD_EXP 21
16222: PPUSH
16223: LD_STRING DEnd-JMM-VanH-1
16225: PPUSH
16226: CALL_OW 88
// if Dolgov and IsPlaced ( Dolgov ) then
16230: LD_EXP 34
16234: PUSH
16235: LD_EXP 34
16239: PPUSH
16240: CALL_OW 305
16244: AND
16245: IFFALSE 16259
// Say ( Dolgov , DEnd-JMM-Dol-1 ) ;
16247: LD_EXP 34
16251: PPUSH
16252: LD_STRING DEnd-JMM-Dol-1
16254: PPUSH
16255: CALL_OW 88
// if Kapitsova and IsPlaced ( Kapitsova ) then
16259: LD_EXP 38
16263: PUSH
16264: LD_EXP 38
16268: PPUSH
16269: CALL_OW 305
16273: AND
16274: IFFALSE 16288
// Say ( Kapitsova , DEnd-JMM-Kap-1 ) ;
16276: LD_EXP 38
16280: PPUSH
16281: LD_STRING DEnd-JMM-Kap-1
16283: PPUSH
16284: CALL_OW 88
// if Kovalyuk and IsPlaced ( Kovalyuk ) then
16288: LD_EXP 41
16292: PUSH
16293: LD_EXP 41
16297: PPUSH
16298: CALL_OW 305
16302: AND
16303: IFFALSE 16317
// Say ( Kovalyuk , DEnd-JMM-Kov-1 ) ;
16305: LD_EXP 41
16309: PPUSH
16310: LD_STRING DEnd-JMM-Kov-1
16312: PPUSH
16313: CALL_OW 88
// if Scholtze and IsPlaced ( Scholtze ) then
16317: LD_EXP 36
16321: PUSH
16322: LD_EXP 36
16326: PPUSH
16327: CALL_OW 305
16331: AND
16332: IFFALSE 16346
// Say ( Scholtze , DEnd-JMM-Sch-1 ) ;
16334: LD_EXP 36
16338: PPUSH
16339: LD_STRING DEnd-JMM-Sch-1
16341: PPUSH
16342: CALL_OW 88
// if Titov and IsPlaced ( Titov ) then
16346: LD_EXP 32
16350: PUSH
16351: LD_EXP 32
16355: PPUSH
16356: CALL_OW 305
16360: AND
16361: IFFALSE 16375
// Say ( Titov , DEnd-JMM-Tit-1 ) ;
16363: LD_EXP 32
16367: PPUSH
16368: LD_STRING DEnd-JMM-Tit-1
16370: PPUSH
16371: CALL_OW 88
// if Oblukov and IsPlaced ( Oblukov ) then
16375: LD_EXP 37
16379: PUSH
16380: LD_EXP 37
16384: PPUSH
16385: CALL_OW 305
16389: AND
16390: IFFALSE 16404
// Say ( Oblukov , DEnd-JMM-Obl-1 ) ;
16392: LD_EXP 37
16396: PPUSH
16397: LD_STRING DEnd-JMM-Obl-1
16399: PPUSH
16400: CALL_OW 88
// if Lipshchin and IsPlaced ( Lipshchin ) then
16404: LD_EXP 39
16408: PUSH
16409: LD_EXP 39
16413: PPUSH
16414: CALL_OW 305
16418: AND
16419: IFFALSE 16433
// Say ( Lipshchin , DEnd-JMM-Lip-1 ) ;
16421: LD_EXP 39
16425: PPUSH
16426: LD_STRING DEnd-JMM-Lip-1
16428: PPUSH
16429: CALL_OW 88
// if Fadeev and IsPlaced ( Fadeev ) and Burlak then
16433: LD_EXP 33
16437: PUSH
16438: LD_EXP 33
16442: PPUSH
16443: CALL_OW 305
16447: AND
16448: PUSH
16449: LD_EXP 44
16453: AND
16454: IFFALSE 16468
// Say ( Fadeev , DEnd-Burlak-Fad-1 ) ;
16456: LD_EXP 33
16460: PPUSH
16461: LD_STRING DEnd-Burlak-Fad-1
16463: PPUSH
16464: CALL_OW 88
// if Petrovova and IsPlaced ( Petrovova ) then
16468: LD_EXP 40
16472: PUSH
16473: LD_EXP 40
16477: PPUSH
16478: CALL_OW 305
16482: AND
16483: IFFALSE 16497
// Say ( Petrovova , DEnd-Burlak-Ptr-1 ) ;
16485: LD_EXP 40
16489: PPUSH
16490: LD_STRING DEnd-Burlak-Ptr-1
16492: PPUSH
16493: CALL_OW 88
// if Kuzmov and IsPlaced ( Kuzmov ) then
16497: LD_EXP 42
16501: PUSH
16502: LD_EXP 42
16506: PPUSH
16507: CALL_OW 305
16511: AND
16512: IFFALSE 16526
// Say ( Kuzmov , DEnd-Burlak-Kuz-1 ) ;
16514: LD_EXP 42
16518: PPUSH
16519: LD_STRING DEnd-Burlak-Kuz-1
16521: PPUSH
16522: CALL_OW 88
// if Kirilenkova and IsPlaced ( Kirilenkova ) and Burlak then
16526: LD_EXP 31
16530: PUSH
16531: LD_EXP 31
16535: PPUSH
16536: CALL_OW 305
16540: AND
16541: PUSH
16542: LD_EXP 44
16546: AND
16547: IFFALSE 16561
// Say ( Kirilenkova , DEnd-Burlak-Kir-1 ) ;
16549: LD_EXP 31
16553: PPUSH
16554: LD_STRING DEnd-Burlak-Kir-1
16556: PPUSH
16557: CALL_OW 88
// if Burlak then
16561: LD_EXP 44
16565: IFFALSE 16579
// Say ( JMM , DEnd-Burlak-JMM-1 ) ;
16567: LD_EXP 12
16571: PPUSH
16572: LD_STRING DEnd-Burlak-JMM-1
16574: PPUSH
16575: CALL_OW 88
// dwait ( 0 0$2 ) ;
16579: LD_INT 70
16581: PPUSH
16582: CALL_OW 68
// SayRadio ( Schulz , DEnd-Szulc ) ;
16586: LD_EXP 49
16590: PPUSH
16591: LD_STRING DEnd-Szulc
16593: PPUSH
16594: CALL_OW 94
// dwait ( 0 0$1 ) ;
16598: LD_INT 35
16600: PPUSH
16601: CALL_OW 68
// if IsLive ( Burlak ) then
16605: LD_EXP 44
16609: PPUSH
16610: CALL_OW 300
16614: IFFALSE 16626
// med1 := 1 else
16616: LD_ADDR_VAR 0 1
16620: PUSH
16621: LD_INT 1
16623: ST_TO_ADDR
16624: GO 16635
// med1 := - 1 ;
16626: LD_ADDR_VAR 0 1
16630: PUSH
16631: LD_INT 1
16633: NEG
16634: ST_TO_ADDR
// if artifactIResearched and artifactIIResearched and artifactIIIResearched then
16635: LD_EXP 9
16639: PUSH
16640: LD_EXP 10
16644: AND
16645: PUSH
16646: LD_EXP 11
16650: AND
16651: IFFALSE 16663
// med2 := 1 else
16653: LD_ADDR_VAR 0 2
16657: PUSH
16658: LD_INT 1
16660: ST_TO_ADDR
16661: GO 16672
// med2 := - 1 ;
16663: LD_ADDR_VAR 0 2
16667: PUSH
16668: LD_INT 1
16670: NEG
16671: ST_TO_ADDR
// AddMedal ( Hero , 1 ) ;
16672: LD_STRING Hero
16674: PPUSH
16675: LD_INT 1
16677: PPUSH
16678: CALL_OW 101
// AddMedal ( Artefact , med2 ) ;
16682: LD_STRING Artefact
16684: PPUSH
16685: LD_VAR 0 2
16689: PPUSH
16690: CALL_OW 101
// AddMedal ( ReconcileBurlak , med1 ) ;
16694: LD_STRING ReconcileBurlak
16696: PPUSH
16697: LD_VAR 0 1
16701: PPUSH
16702: CALL_OW 101
// if Difficulty = 3 and med1 = 1 and med2 = 1 then
16706: LD_OWVAR 67
16710: PUSH
16711: LD_INT 3
16713: EQUAL
16714: PUSH
16715: LD_VAR 0 1
16719: PUSH
16720: LD_INT 1
16722: EQUAL
16723: AND
16724: PUSH
16725: LD_VAR 0 2
16729: PUSH
16730: LD_INT 1
16732: EQUAL
16733: AND
16734: IFFALSE 16746
// SetAchievementEX ( ACH_AMER , 19 ) ;
16736: LD_STRING ACH_AMER
16738: PPUSH
16739: LD_INT 19
16741: PPUSH
16742: CALL_OW 564
// GiveMedals ( MAIN ) ;
16746: LD_STRING MAIN
16748: PPUSH
16749: CALL_OW 102
// InGameOff ;
16753: CALL_OW 9
// DialogueOff ;
16757: CALL_OW 7
// music_nat := 1 ;
16761: LD_ADDR_OWVAR 71
16765: PUSH
16766: LD_INT 1
16768: ST_TO_ADDR
// music_class := 4 ;
16769: LD_ADDR_OWVAR 72
16773: PUSH
16774: LD_INT 4
16776: ST_TO_ADDR
// YouWin ;
16777: CALL_OW 103
// end ; end_of_file
16781: PPOPN 2
16783: END
// export function InitNature ; begin
16784: LD_INT 0
16786: PPUSH
// PrepareNature ( 3 , 3 , 2 , 1 , 1 , 0 , 0 , natureArea1 , 0 ) ;
16787: LD_INT 3
16789: PPUSH
16790: LD_INT 3
16792: PPUSH
16793: LD_INT 2
16795: PPUSH
16796: LD_INT 1
16798: PPUSH
16799: LD_INT 1
16801: PPUSH
16802: LD_INT 0
16804: PPUSH
16805: LD_INT 0
16807: PPUSH
16808: LD_INT 17
16810: PPUSH
16811: LD_INT 0
16813: PPUSH
16814: CALL 85095 0 9
// PrepareNature ( 2 , 1 , 1 , 1 , 1 , 0 , 0 , natureArea2 , 0 ) ;
16818: LD_INT 2
16820: PPUSH
16821: LD_INT 1
16823: PPUSH
16824: LD_INT 1
16826: PPUSH
16827: LD_INT 1
16829: PPUSH
16830: LD_INT 1
16832: PPUSH
16833: LD_INT 0
16835: PPUSH
16836: LD_INT 0
16838: PPUSH
16839: LD_INT 18
16841: PPUSH
16842: LD_INT 0
16844: PPUSH
16845: CALL 85095 0 9
// PrepareNature ( 4 , 1 , 2 , 4 , 2 , 1 , 0 , natureArea3 , 0 ) ;
16849: LD_INT 4
16851: PPUSH
16852: LD_INT 1
16854: PPUSH
16855: LD_INT 2
16857: PPUSH
16858: LD_INT 4
16860: PPUSH
16861: LD_INT 2
16863: PPUSH
16864: LD_INT 1
16866: PPUSH
16867: LD_INT 0
16869: PPUSH
16870: LD_INT 19
16872: PPUSH
16873: LD_INT 0
16875: PPUSH
16876: CALL 85095 0 9
// PrepareNature ( 0 , 0 , 0 , 0 , 0 , 0 , 9 , 0 , natureWaterArea ) ;
16880: LD_INT 0
16882: PPUSH
16883: LD_INT 0
16885: PPUSH
16886: LD_INT 0
16888: PPUSH
16889: LD_INT 0
16891: PPUSH
16892: LD_INT 0
16894: PPUSH
16895: LD_INT 0
16897: PPUSH
16898: LD_INT 9
16900: PPUSH
16901: LD_INT 0
16903: PPUSH
16904: LD_INT 20
16906: PPUSH
16907: CALL 85095 0 9
// end ; end_of_file
16911: LD_VAR 0 1
16915: RET
// every 0 0$30 do var time ;
16916: GO 16918
16918: DISABLE
16919: LD_INT 0
16921: PPUSH
// begin time := 0 0$50 ;
16922: LD_ADDR_VAR 0 1
16926: PUSH
16927: LD_INT 1750
16929: ST_TO_ADDR
// repeat wait ( time ) ;
16930: LD_VAR 0 1
16934: PPUSH
16935: CALL_OW 67
// if Prob ( 50 ) then
16939: LD_INT 50
16941: PPUSH
16942: CALL_OW 13
16946: IFFALSE 16975
// CreateCratesXYR ( rand ( 1 , 5 ) , 106 , 89 , 45 , true ) ;
16948: LD_INT 1
16950: PPUSH
16951: LD_INT 5
16953: PPUSH
16954: CALL_OW 12
16958: PPUSH
16959: LD_INT 106
16961: PPUSH
16962: LD_INT 89
16964: PPUSH
16965: LD_INT 45
16967: PPUSH
16968: LD_INT 1
16970: PPUSH
16971: CALL_OW 56
// time := time + 0 0$3 ;
16975: LD_ADDR_VAR 0 1
16979: PUSH
16980: LD_VAR 0 1
16984: PUSH
16985: LD_INT 105
16987: PLUS
16988: ST_TO_ADDR
// if Prob ( 30 ) then
16989: LD_INT 30
16991: PPUSH
16992: CALL_OW 13
16996: IFFALSE 17042
// begin wait ( rand ( 0 0$15 , 0 0$21 ) ) ;
16998: LD_INT 525
17000: PPUSH
17001: LD_INT 735
17003: PPUSH
17004: CALL_OW 12
17008: PPUSH
17009: CALL_OW 67
// CreateCratesXYR ( rand ( 1 , 5 ) , 21 , 26 , 12 , true ) ;
17013: LD_INT 1
17015: PPUSH
17016: LD_INT 5
17018: PPUSH
17019: CALL_OW 12
17023: PPUSH
17024: LD_INT 21
17026: PPUSH
17027: LD_INT 26
17029: PPUSH
17030: LD_INT 12
17032: PPUSH
17033: LD_INT 1
17035: PPUSH
17036: CALL_OW 56
// end else
17040: GO 17078
// begin wait ( rand ( 0 0$20 , 0 0$35 ) ) ;
17042: LD_INT 700
17044: PPUSH
17045: LD_INT 1225
17047: PPUSH
17048: CALL_OW 12
17052: PPUSH
17053: CALL_OW 67
// CreateCratesArea ( rand ( 1 , 5 ) , russianCratesArea , true ) ;
17057: LD_INT 1
17059: PPUSH
17060: LD_INT 5
17062: PPUSH
17063: CALL_OW 12
17067: PPUSH
17068: LD_INT 14
17070: PPUSH
17071: LD_INT 1
17073: PPUSH
17074: CALL_OW 55
// end ; if Prob ( 50 ) then
17078: LD_INT 50
17080: PPUSH
17081: CALL_OW 13
17085: IFFALSE 17131
// begin wait ( rand ( 0 0$20 , 0 0$30 ) ) ;
17087: LD_INT 700
17089: PPUSH
17090: LD_INT 1050
17092: PPUSH
17093: CALL_OW 12
17097: PPUSH
17098: CALL_OW 67
// CreateCratesXYR ( rand ( 1 , 5 ) , 181 , 218 , 16 , true ) ;
17102: LD_INT 1
17104: PPUSH
17105: LD_INT 5
17107: PPUSH
17108: CALL_OW 12
17112: PPUSH
17113: LD_INT 181
17115: PPUSH
17116: LD_INT 218
17118: PPUSH
17119: LD_INT 16
17121: PPUSH
17122: LD_INT 1
17124: PPUSH
17125: CALL_OW 56
// end else
17129: GO 17203
// begin wait ( rand ( 0 0$10 , 0 0$15 ) ) ;
17131: LD_INT 350
17133: PPUSH
17134: LD_INT 525
17136: PPUSH
17137: CALL_OW 12
17141: PPUSH
17142: CALL_OW 67
// CreateCratesArea ( rand ( 1 , 5 ) , legionCratesArea , true ) ;
17146: LD_INT 1
17148: PPUSH
17149: LD_INT 5
17151: PPUSH
17152: CALL_OW 12
17156: PPUSH
17157: LD_INT 13
17159: PPUSH
17160: LD_INT 1
17162: PPUSH
17163: CALL_OW 55
// wait ( rand ( 0 0$10 , 0 0$20 ) ) ;
17167: LD_INT 350
17169: PPUSH
17170: LD_INT 700
17172: PPUSH
17173: CALL_OW 12
17177: PPUSH
17178: CALL_OW 67
// CreateCratesArea ( rand ( 1 , 5 ) , americanCratesArea , true ) ;
17182: LD_INT 1
17184: PPUSH
17185: LD_INT 5
17187: PPUSH
17188: CALL_OW 12
17192: PPUSH
17193: LD_INT 33
17195: PPUSH
17196: LD_INT 1
17198: PPUSH
17199: CALL_OW 55
// end ; if Prob ( [ 65 , 62 , 55 ] [ Difficulty ] ) then
17203: LD_INT 65
17205: PUSH
17206: LD_INT 62
17208: PUSH
17209: LD_INT 55
17211: PUSH
17212: EMPTY
17213: LIST
17214: LIST
17215: LIST
17216: PUSH
17217: LD_OWVAR 67
17221: ARRAY
17222: PPUSH
17223: CALL_OW 13
17227: IFFALSE 17273
// begin wait ( rand ( 0 0$15 , 0 0$25 ) ) ;
17229: LD_INT 525
17231: PPUSH
17232: LD_INT 875
17234: PPUSH
17235: CALL_OW 12
17239: PPUSH
17240: CALL_OW 67
// CreateCratesXYR ( rand ( 1 , 5 ) , 294 , 211 , 30 , true ) ;
17244: LD_INT 1
17246: PPUSH
17247: LD_INT 5
17249: PPUSH
17250: CALL_OW 12
17254: PPUSH
17255: LD_INT 294
17257: PPUSH
17258: LD_INT 211
17260: PPUSH
17261: LD_INT 30
17263: PPUSH
17264: LD_INT 1
17266: PPUSH
17267: CALL_OW 56
// end else
17271: GO 17315
// begin wait ( rand ( 0 0$12 , 0 0$22 ) ) ;
17273: LD_INT 420
17275: PPUSH
17276: LD_INT 770
17278: PPUSH
17279: CALL_OW 12
17283: PPUSH
17284: CALL_OW 67
// CreateCratesXYR ( rand ( 1 , 5 ) , 294 , 211 , 30 , true ) ;
17288: LD_INT 1
17290: PPUSH
17291: LD_INT 5
17293: PPUSH
17294: CALL_OW 12
17298: PPUSH
17299: LD_INT 294
17301: PPUSH
17302: LD_INT 211
17304: PPUSH
17305: LD_INT 30
17307: PPUSH
17308: LD_INT 1
17310: PPUSH
17311: CALL_OW 56
// end ; if time > 2 2$20 then
17315: LD_VAR 0 1
17319: PUSH
17320: LD_INT 4900
17322: GREATER
17323: IFFALSE 17333
// time := 0 0$50 ;
17325: LD_ADDR_VAR 0 1
17329: PUSH
17330: LD_INT 1750
17332: ST_TO_ADDR
// until false ;
17333: LD_INT 0
17335: IFFALSE 16930
// end ;
17337: PPOPN 1
17339: END
// every 0 0$45 trigger tick < 10 10$00 do
17340: LD_OWVAR 1
17344: PUSH
17345: LD_INT 21000
17347: LESS
17348: IFFALSE 17396
17350: GO 17352
17352: DISABLE
// begin enable ;
17353: ENABLE
// wait ( rand ( 0 0$10 , 0 0$20 ) ) ;
17354: LD_INT 350
17356: PPUSH
17357: LD_INT 700
17359: PPUSH
17360: CALL_OW 12
17364: PPUSH
17365: CALL_OW 67
// CreateCratesXYR ( rand ( 3 , 5 ) , 181 , 13 , 20 , true ) ;
17369: LD_INT 3
17371: PPUSH
17372: LD_INT 5
17374: PPUSH
17375: CALL_OW 12
17379: PPUSH
17380: LD_INT 181
17382: PPUSH
17383: LD_INT 13
17385: PPUSH
17386: LD_INT 20
17388: PPUSH
17389: LD_INT 1
17391: PPUSH
17392: CALL_OW 56
// end ; end_of_file
17396: END
// export artifactsPos , artifactsRecharge , artifactsSibCost , artifactsResearched , artifactsLabsWorking ; export artifactsResDifficulty , artifactsResProgress , artifactsLabs , artifactsButtons , artifactsReady ; export function InitArtifact ; begin
17397: LD_INT 0
17399: PPUSH
// SetArtifactRes ( 7 , true ) ;
17400: LD_INT 7
17402: PPUSH
17403: LD_INT 1
17405: PPUSH
17406: CALL_OW 467
// artifactsPos := [ [ ] , [ ] , [ ] ] ;
17410: LD_ADDR_EXP 57
17414: PUSH
17415: EMPTY
17416: PUSH
17417: EMPTY
17418: PUSH
17419: EMPTY
17420: PUSH
17421: EMPTY
17422: LIST
17423: LIST
17424: LIST
17425: ST_TO_ADDR
// artifactsRecharge := [ 0 0$30 * Difficulty , 1 1$20 * Difficulty , - 1 ] ;
17426: LD_ADDR_EXP 58
17430: PUSH
17431: LD_INT 1050
17433: PUSH
17434: LD_OWVAR 67
17438: MUL
17439: PUSH
17440: LD_INT 2800
17442: PUSH
17443: LD_OWVAR 67
17447: MUL
17448: PUSH
17449: LD_INT 1
17451: NEG
17452: PUSH
17453: EMPTY
17454: LIST
17455: LIST
17456: LIST
17457: ST_TO_ADDR
// artifactsSibCost := [ 10 , 35 , 100 ] ;
17458: LD_ADDR_EXP 59
17462: PUSH
17463: LD_INT 10
17465: PUSH
17466: LD_INT 35
17468: PUSH
17469: LD_INT 100
17471: PUSH
17472: EMPTY
17473: LIST
17474: LIST
17475: LIST
17476: ST_TO_ADDR
// artifactsResearched := [ 0 , 0 , 0 ] ;
17477: LD_ADDR_EXP 60
17481: PUSH
17482: LD_INT 0
17484: PUSH
17485: LD_INT 0
17487: PUSH
17488: LD_INT 0
17490: PUSH
17491: EMPTY
17492: LIST
17493: LIST
17494: LIST
17495: ST_TO_ADDR
// artifactsResDifficulty := [ 300 , 500 , 800 ] ;
17496: LD_ADDR_EXP 62
17500: PUSH
17501: LD_INT 300
17503: PUSH
17504: LD_INT 500
17506: PUSH
17507: LD_INT 800
17509: PUSH
17510: EMPTY
17511: LIST
17512: LIST
17513: LIST
17514: ST_TO_ADDR
// artifactsResProgress := [ 0 , 0 , 0 ] ;
17515: LD_ADDR_EXP 63
17519: PUSH
17520: LD_INT 0
17522: PUSH
17523: LD_INT 0
17525: PUSH
17526: LD_INT 0
17528: PUSH
17529: EMPTY
17530: LIST
17531: LIST
17532: LIST
17533: ST_TO_ADDR
// artifactsLabs := [ 0 , 0 , 0 ] ;
17534: LD_ADDR_EXP 64
17538: PUSH
17539: LD_INT 0
17541: PUSH
17542: LD_INT 0
17544: PUSH
17545: LD_INT 0
17547: PUSH
17548: EMPTY
17549: LIST
17550: LIST
17551: LIST
17552: ST_TO_ADDR
// artifactsLabsWorking := [ 0 , 0 , 0 ] ;
17553: LD_ADDR_EXP 61
17557: PUSH
17558: LD_INT 0
17560: PUSH
17561: LD_INT 0
17563: PUSH
17564: LD_INT 0
17566: PUSH
17567: EMPTY
17568: LIST
17569: LIST
17570: LIST
17571: ST_TO_ADDR
// artifactsButtons := [ [ art_use_eye , art_place , art_exp_left ] , [ art_use_sibexplosion , art_unit , art_exp_mid ] , [ art_use_teleport , art_place , art_exp_right ] ] ;
17572: LD_ADDR_EXP 65
17576: PUSH
17577: LD_INT 4
17579: PUSH
17580: LD_INT 3
17582: PUSH
17583: LD_INT 1
17585: PUSH
17586: EMPTY
17587: LIST
17588: LIST
17589: LIST
17590: PUSH
17591: LD_INT 5
17593: PUSH
17594: LD_INT 4
17596: PUSH
17597: LD_INT 2
17599: PUSH
17600: EMPTY
17601: LIST
17602: LIST
17603: LIST
17604: PUSH
17605: LD_INT 6
17607: PUSH
17608: LD_INT 3
17610: PUSH
17611: LD_INT 3
17613: PUSH
17614: EMPTY
17615: LIST
17616: LIST
17617: LIST
17618: PUSH
17619: EMPTY
17620: LIST
17621: LIST
17622: LIST
17623: ST_TO_ADDR
// artifactsReady := [ 0 , 0 , 0 ] ;
17624: LD_ADDR_EXP 66
17628: PUSH
17629: LD_INT 0
17631: PUSH
17632: LD_INT 0
17634: PUSH
17635: LD_INT 0
17637: PUSH
17638: EMPTY
17639: LIST
17640: LIST
17641: LIST
17642: ST_TO_ADDR
// end ;
17643: LD_VAR 0 1
17647: RET
// every 0 0$1 trigger GetTech ( tech_artifact , 7 ) = state_researched do var i , pos , j , labs , nearestLab ;
17648: LD_INT 24
17650: PPUSH
17651: LD_INT 7
17653: PPUSH
17654: CALL_OW 321
17658: PUSH
17659: LD_INT 2
17661: EQUAL
17662: IFFALSE 18588
17664: GO 17666
17666: DISABLE
17667: LD_INT 0
17669: PPUSH
17670: PPUSH
17671: PPUSH
17672: PPUSH
17673: PPUSH
// begin enable ;
17674: ENABLE
// for i = 1 to 3 do
17675: LD_ADDR_VAR 0 1
17679: PUSH
17680: DOUBLE
17681: LD_INT 1
17683: DEC
17684: ST_TO_ADDR
17685: LD_INT 3
17687: PUSH
17688: FOR_TO
17689: IFFALSE 18586
// begin pos := FindArtifact ( i + 2 ) ;
17691: LD_ADDR_VAR 0 2
17695: PUSH
17696: LD_VAR 0 1
17700: PUSH
17701: LD_INT 2
17703: PLUS
17704: PPUSH
17705: CALL_OW 469
17709: ST_TO_ADDR
// artifactsPos := Replace ( artifactsPos , i , pos ) ;
17710: LD_ADDR_EXP 57
17714: PUSH
17715: LD_EXP 57
17719: PPUSH
17720: LD_VAR 0 1
17724: PPUSH
17725: LD_VAR 0 2
17729: PPUSH
17730: CALL_OW 1
17734: ST_TO_ADDR
// if pos then
17735: LD_VAR 0 2
17739: IFFALSE 18447
// begin case i of 1 :
17741: LD_VAR 0 1
17745: PUSH
17746: LD_INT 1
17748: DOUBLE
17749: EQUAL
17750: IFTRUE 17754
17752: GO 17831
17754: POP
// labs := FilterAllUnits ( [ [ f_side , 7 ] , [ f_nation , 1 ] , [ f_or , [ f_btype , b_lab_full ] , [ f_btype , b_lab_half ] , [ f_btype , b_lab_siberium ] ] ] ) ; 2 :
17755: LD_ADDR_VAR 0 4
17759: PUSH
17760: LD_INT 22
17762: PUSH
17763: LD_INT 7
17765: PUSH
17766: EMPTY
17767: LIST
17768: LIST
17769: PUSH
17770: LD_INT 23
17772: PUSH
17773: LD_INT 1
17775: PUSH
17776: EMPTY
17777: LIST
17778: LIST
17779: PUSH
17780: LD_INT 2
17782: PUSH
17783: LD_INT 30
17785: PUSH
17786: LD_INT 8
17788: PUSH
17789: EMPTY
17790: LIST
17791: LIST
17792: PUSH
17793: LD_INT 30
17795: PUSH
17796: LD_INT 7
17798: PUSH
17799: EMPTY
17800: LIST
17801: LIST
17802: PUSH
17803: LD_INT 30
17805: PUSH
17806: LD_INT 11
17808: PUSH
17809: EMPTY
17810: LIST
17811: LIST
17812: PUSH
17813: EMPTY
17814: LIST
17815: LIST
17816: LIST
17817: LIST
17818: PUSH
17819: EMPTY
17820: LIST
17821: LIST
17822: LIST
17823: PPUSH
17824: CALL_OW 69
17828: ST_TO_ADDR
17829: GO 17939
17831: LD_INT 2
17833: DOUBLE
17834: EQUAL
17835: IFTRUE 17839
17837: GO 17916
17839: POP
// labs := FilterAllUnits ( [ [ f_side , 7 ] , [ f_nation , 3 ] , [ f_or , [ f_btype , b_lab_full ] , [ f_btype , b_lab_half ] , [ f_btype , b_lab_siberium ] ] ] ) ; 3 :
17840: LD_ADDR_VAR 0 4
17844: PUSH
17845: LD_INT 22
17847: PUSH
17848: LD_INT 7
17850: PUSH
17851: EMPTY
17852: LIST
17853: LIST
17854: PUSH
17855: LD_INT 23
17857: PUSH
17858: LD_INT 3
17860: PUSH
17861: EMPTY
17862: LIST
17863: LIST
17864: PUSH
17865: LD_INT 2
17867: PUSH
17868: LD_INT 30
17870: PUSH
17871: LD_INT 8
17873: PUSH
17874: EMPTY
17875: LIST
17876: LIST
17877: PUSH
17878: LD_INT 30
17880: PUSH
17881: LD_INT 7
17883: PUSH
17884: EMPTY
17885: LIST
17886: LIST
17887: PUSH
17888: LD_INT 30
17890: PUSH
17891: LD_INT 11
17893: PUSH
17894: EMPTY
17895: LIST
17896: LIST
17897: PUSH
17898: EMPTY
17899: LIST
17900: LIST
17901: LIST
17902: LIST
17903: PUSH
17904: EMPTY
17905: LIST
17906: LIST
17907: LIST
17908: PPUSH
17909: CALL_OW 69
17913: ST_TO_ADDR
17914: GO 17939
17916: LD_INT 3
17918: DOUBLE
17919: EQUAL
17920: IFTRUE 17924
17922: GO 17938
17924: POP
// labs := [ alien ] ; end ;
17925: LD_ADDR_VAR 0 4
17929: PUSH
17930: LD_INT 1
17932: PUSH
17933: EMPTY
17934: LIST
17935: ST_TO_ADDR
17936: GO 17939
17938: POP
// if not labs then
17939: LD_VAR 0 4
17943: NOT
17944: IFFALSE 17948
// continue ;
17946: GO 17688
// nearestLab := NearestUnitToXY ( labs , artifactsPos [ i ] [ 1 ] , artifactsPos [ i ] [ 2 ] ) ;
17948: LD_ADDR_VAR 0 5
17952: PUSH
17953: LD_VAR 0 4
17957: PPUSH
17958: LD_EXP 57
17962: PUSH
17963: LD_VAR 0 1
17967: ARRAY
17968: PUSH
17969: LD_INT 1
17971: ARRAY
17972: PPUSH
17973: LD_EXP 57
17977: PUSH
17978: LD_VAR 0 1
17982: ARRAY
17983: PUSH
17984: LD_INT 2
17986: ARRAY
17987: PPUSH
17988: CALL_OW 73
17992: ST_TO_ADDR
// if not nearestLab or nearestLab <> artifactsLabs [ i ] then
17993: LD_VAR 0 5
17997: NOT
17998: PUSH
17999: LD_VAR 0 5
18003: PUSH
18004: LD_EXP 64
18008: PUSH
18009: LD_VAR 0 1
18013: ARRAY
18014: NONEQUAL
18015: OR
18016: IFFALSE 18121
// begin SetArtifactUse ( 7 , artifactsButtons [ i ] [ 3 ] , art_no , artifactsLabs [ i ] ) ;
18018: LD_INT 7
18020: PPUSH
18021: LD_EXP 65
18025: PUSH
18026: LD_VAR 0 1
18030: ARRAY
18031: PUSH
18032: LD_INT 3
18034: ARRAY
18035: PPUSH
18036: LD_INT 0
18038: PPUSH
18039: LD_EXP 64
18043: PUSH
18044: LD_VAR 0 1
18048: ARRAY
18049: PPUSH
18050: CALL_OW 468
// SetArtifactUse ( 7 , artifactsButtons [ i ] [ 1 ] , art_no , artifactsLabs [ i ] ) ;
18054: LD_INT 7
18056: PPUSH
18057: LD_EXP 65
18061: PUSH
18062: LD_VAR 0 1
18066: ARRAY
18067: PUSH
18068: LD_INT 1
18070: ARRAY
18071: PPUSH
18072: LD_INT 0
18074: PPUSH
18075: LD_EXP 64
18079: PUSH
18080: LD_VAR 0 1
18084: ARRAY
18085: PPUSH
18086: CALL_OW 468
// if nearestLab then
18090: LD_VAR 0 5
18094: IFFALSE 18121
// artifactsLabs := Replace ( artifactsLabs , i , nearestLab ) ;
18096: LD_ADDR_EXP 64
18100: PUSH
18101: LD_EXP 64
18105: PPUSH
18106: LD_VAR 0 1
18110: PPUSH
18111: LD_VAR 0 5
18115: PPUSH
18116: CALL_OW 1
18120: ST_TO_ADDR
// end ; if not nearestLab then
18121: LD_VAR 0 5
18125: NOT
18126: IFFALSE 18130
// continue ;
18128: GO 17688
// if GetDistUnitXY ( nearestLab , artifactsPos [ i ] [ 1 ] , artifactsPos [ i ] [ 2 ] ) < 8 then
18130: LD_VAR 0 5
18134: PPUSH
18135: LD_EXP 57
18139: PUSH
18140: LD_VAR 0 1
18144: ARRAY
18145: PUSH
18146: LD_INT 1
18148: ARRAY
18149: PPUSH
18150: LD_EXP 57
18154: PUSH
18155: LD_VAR 0 1
18159: ARRAY
18160: PUSH
18161: LD_INT 2
18163: ARRAY
18164: PPUSH
18165: CALL_OW 297
18169: PUSH
18170: LD_INT 8
18172: LESS
18173: IFFALSE 18370
// begin if not artifactsResearched [ i ] then
18175: LD_EXP 60
18179: PUSH
18180: LD_VAR 0 1
18184: ARRAY
18185: NOT
18186: IFFALSE 18267
// begin if BuildingStatus ( nearestLab ) = bs_idle then
18188: LD_VAR 0 5
18192: PPUSH
18193: CALL_OW 461
18197: PUSH
18198: LD_INT 2
18200: EQUAL
18201: IFFALSE 18235
// SetArtifactUse ( 7 , artifactsButtons [ i ] [ 3 ] , art_instant , nearestLab ) else
18203: LD_INT 7
18205: PPUSH
18206: LD_EXP 65
18210: PUSH
18211: LD_VAR 0 1
18215: ARRAY
18216: PUSH
18217: LD_INT 3
18219: ARRAY
18220: PPUSH
18221: LD_INT 2
18223: PPUSH
18224: LD_VAR 0 5
18228: PPUSH
18229: CALL_OW 468
18233: GO 18265
// SetArtifactUse ( 7 , artifactsButtons [ i ] [ 3 ] , art_gray , nearestLab ) ;
18235: LD_INT 7
18237: PPUSH
18238: LD_EXP 65
18242: PUSH
18243: LD_VAR 0 1
18247: ARRAY
18248: PUSH
18249: LD_INT 3
18251: ARRAY
18252: PPUSH
18253: LD_INT 1
18255: PPUSH
18256: LD_VAR 0 5
18260: PPUSH
18261: CALL_OW 468
// end else
18265: GO 18368
// begin if BuildingStatus ( nearestLab ) = bs_idle and artifactsReady [ i ] then
18267: LD_VAR 0 5
18271: PPUSH
18272: CALL_OW 461
18276: PUSH
18277: LD_INT 2
18279: EQUAL
18280: PUSH
18281: LD_EXP 66
18285: PUSH
18286: LD_VAR 0 1
18290: ARRAY
18291: AND
18292: IFFALSE 18338
// SetArtifactUse ( 7 , artifactsButtons [ i ] [ 1 ] , artifactsButtons [ i ] [ 2 ] , nearestLab ) else
18294: LD_INT 7
18296: PPUSH
18297: LD_EXP 65
18301: PUSH
18302: LD_VAR 0 1
18306: ARRAY
18307: PUSH
18308: LD_INT 1
18310: ARRAY
18311: PPUSH
18312: LD_EXP 65
18316: PUSH
18317: LD_VAR 0 1
18321: ARRAY
18322: PUSH
18323: LD_INT 2
18325: ARRAY
18326: PPUSH
18327: LD_VAR 0 5
18331: PPUSH
18332: CALL_OW 468
18336: GO 18368
// SetArtifactUse ( 7 , artifactsButtons [ i ] [ 1 ] , art_gray , nearestLab ) end ;
18338: LD_INT 7
18340: PPUSH
18341: LD_EXP 65
18345: PUSH
18346: LD_VAR 0 1
18350: ARRAY
18351: PUSH
18352: LD_INT 1
18354: ARRAY
18355: PPUSH
18356: LD_INT 1
18358: PPUSH
18359: LD_VAR 0 5
18363: PPUSH
18364: CALL_OW 468
// end else
18368: GO 18445
// begin if not artifactsResearched [ i ] then
18370: LD_EXP 60
18374: PUSH
18375: LD_VAR 0 1
18379: ARRAY
18380: NOT
18381: IFFALSE 18415
// SetArtifactUse ( 7 , artifactsButtons [ i ] [ 3 ] , art_no , nearestLab ) else
18383: LD_INT 7
18385: PPUSH
18386: LD_EXP 65
18390: PUSH
18391: LD_VAR 0 1
18395: ARRAY
18396: PUSH
18397: LD_INT 3
18399: ARRAY
18400: PPUSH
18401: LD_INT 0
18403: PPUSH
18404: LD_VAR 0 5
18408: PPUSH
18409: CALL_OW 468
18413: GO 18445
// SetArtifactUse ( 7 , artifactsButtons [ i ] [ 1 ] , art_no , nearestLab ) ;
18415: LD_INT 7
18417: PPUSH
18418: LD_EXP 65
18422: PUSH
18423: LD_VAR 0 1
18427: ARRAY
18428: PUSH
18429: LD_INT 1
18431: ARRAY
18432: PPUSH
18433: LD_INT 0
18435: PPUSH
18436: LD_VAR 0 5
18440: PPUSH
18441: CALL_OW 468
// end ; end else
18445: GO 18584
// begin if not artifactsLabs [ i ] then
18447: LD_EXP 64
18451: PUSH
18452: LD_VAR 0 1
18456: ARRAY
18457: NOT
18458: IFFALSE 18462
// continue ;
18460: GO 17688
// SetArtifactUse ( 7 , artifactsButtons [ i ] [ 3 ] , art_no , artifactsLabs [ i ] ) ;
18462: LD_INT 7
18464: PPUSH
18465: LD_EXP 65
18469: PUSH
18470: LD_VAR 0 1
18474: ARRAY
18475: PUSH
18476: LD_INT 3
18478: ARRAY
18479: PPUSH
18480: LD_INT 0
18482: PPUSH
18483: LD_EXP 64
18487: PUSH
18488: LD_VAR 0 1
18492: ARRAY
18493: PPUSH
18494: CALL_OW 468
// SetArtifactUse ( 7 , artifactsButtons [ i ] [ 1 ] , art_no , artifactsLabs [ i ] ) ;
18498: LD_INT 7
18500: PPUSH
18501: LD_EXP 65
18505: PUSH
18506: LD_VAR 0 1
18510: ARRAY
18511: PUSH
18512: LD_INT 1
18514: ARRAY
18515: PPUSH
18516: LD_INT 0
18518: PPUSH
18519: LD_EXP 64
18523: PUSH
18524: LD_VAR 0 1
18528: ARRAY
18529: PPUSH
18530: CALL_OW 468
// if artifactsLabsWorking [ i ] then
18534: LD_EXP 61
18538: PUSH
18539: LD_VAR 0 1
18543: ARRAY
18544: IFFALSE 18584
// begin artifactsLabsWorking := Replace ( artifactsLabsWorking , i , false ) ;
18546: LD_ADDR_EXP 61
18550: PUSH
18551: LD_EXP 61
18555: PPUSH
18556: LD_VAR 0 1
18560: PPUSH
18561: LD_INT 0
18563: PPUSH
18564: CALL_OW 1
18568: ST_TO_ADDR
// ComCancel ( artifactsLabs [ i ] ) ;
18569: LD_EXP 64
18573: PUSH
18574: LD_VAR 0 1
18578: ARRAY
18579: PPUSH
18580: CALL_OW 127
// end ; end ; end ;
18584: GO 17688
18586: POP
18587: POP
// end ;
18588: PPOPN 5
18590: END
// on ArtifactUsed ( side , icon , x , y ) do var i , lab , time , list , un ;
18591: LD_INT 0
18593: PPUSH
18594: PPUSH
18595: PPUSH
18596: PPUSH
18597: PPUSH
// begin if icon = artifactsButtons [ 1 ] [ 3 ] then
18598: LD_VAR 0 2
18602: PUSH
18603: LD_EXP 65
18607: PUSH
18608: LD_INT 1
18610: ARRAY
18611: PUSH
18612: LD_INT 3
18614: ARRAY
18615: EQUAL
18616: IFFALSE 18739
// begin lab := artifactsLabs [ 1 ] ;
18618: LD_ADDR_VAR 0 6
18622: PUSH
18623: LD_EXP 64
18627: PUSH
18628: LD_INT 1
18630: ARRAY
18631: ST_TO_ADDR
// if not lab then
18632: LD_VAR 0 6
18636: NOT
18637: IFFALSE 18641
// exit ;
18639: GO 19673
// SetSpecResearch ( lab , artifactsResDifficulty [ 1 ] , true ) ;
18641: LD_VAR 0 6
18645: PPUSH
18646: LD_EXP 62
18650: PUSH
18651: LD_INT 1
18653: ARRAY
18654: PPUSH
18655: LD_INT 1
18657: PPUSH
18658: CALL_OW 486
// if artifactsResProgress [ 1 ] then
18662: LD_EXP 63
18666: PUSH
18667: LD_INT 1
18669: ARRAY
18670: IFFALSE 18690
// SetWorkingProgress ( lab , artifactsResProgress [ 1 ] ) ;
18672: LD_VAR 0 6
18676: PPUSH
18677: LD_EXP 63
18681: PUSH
18682: LD_INT 1
18684: ARRAY
18685: PPUSH
18686: CALL_OW 329
// artifactsLabsWorking := Replace ( artifactsLabsWorking , 1 , 1 ) ;
18690: LD_ADDR_EXP 61
18694: PUSH
18695: LD_EXP 61
18699: PPUSH
18700: LD_INT 1
18702: PPUSH
18703: LD_INT 1
18705: PPUSH
18706: CALL_OW 1
18710: ST_TO_ADDR
// SetArtifactUse ( 7 , artifactsButtons [ 1 ] [ 3 ] , art_no , lab ) ;
18711: LD_INT 7
18713: PPUSH
18714: LD_EXP 65
18718: PUSH
18719: LD_INT 1
18721: ARRAY
18722: PUSH
18723: LD_INT 3
18725: ARRAY
18726: PPUSH
18727: LD_INT 0
18729: PPUSH
18730: LD_VAR 0 6
18734: PPUSH
18735: CALL_OW 468
// end ; if icon = artifactsButtons [ 2 ] [ 3 ] then
18739: LD_VAR 0 2
18743: PUSH
18744: LD_EXP 65
18748: PUSH
18749: LD_INT 2
18751: ARRAY
18752: PUSH
18753: LD_INT 3
18755: ARRAY
18756: EQUAL
18757: IFFALSE 18880
// begin lab := artifactsLabs [ 2 ] ;
18759: LD_ADDR_VAR 0 6
18763: PUSH
18764: LD_EXP 64
18768: PUSH
18769: LD_INT 2
18771: ARRAY
18772: ST_TO_ADDR
// if not lab then
18773: LD_VAR 0 6
18777: NOT
18778: IFFALSE 18782
// exit ;
18780: GO 19673
// SetSpecResearch ( lab , artifactsResDifficulty [ 2 ] , true ) ;
18782: LD_VAR 0 6
18786: PPUSH
18787: LD_EXP 62
18791: PUSH
18792: LD_INT 2
18794: ARRAY
18795: PPUSH
18796: LD_INT 1
18798: PPUSH
18799: CALL_OW 486
// if artifactsResProgress [ 2 ] then
18803: LD_EXP 63
18807: PUSH
18808: LD_INT 2
18810: ARRAY
18811: IFFALSE 18831
// SetWorkingProgress ( lab , artifactsResProgress [ 2 ] ) ;
18813: LD_VAR 0 6
18817: PPUSH
18818: LD_EXP 63
18822: PUSH
18823: LD_INT 2
18825: ARRAY
18826: PPUSH
18827: CALL_OW 329
// artifactsLabsWorking := Replace ( artifactsLabsWorking , 2 , 1 ) ;
18831: LD_ADDR_EXP 61
18835: PUSH
18836: LD_EXP 61
18840: PPUSH
18841: LD_INT 2
18843: PPUSH
18844: LD_INT 1
18846: PPUSH
18847: CALL_OW 1
18851: ST_TO_ADDR
// SetArtifactUse ( 7 , artifactsButtons [ 2 ] [ 3 ] , art_no , lab ) ;
18852: LD_INT 7
18854: PPUSH
18855: LD_EXP 65
18859: PUSH
18860: LD_INT 2
18862: ARRAY
18863: PUSH
18864: LD_INT 3
18866: ARRAY
18867: PPUSH
18868: LD_INT 0
18870: PPUSH
18871: LD_VAR 0 6
18875: PPUSH
18876: CALL_OW 468
// end ; if icon = artifactsButtons [ 3 ] [ 3 ] then
18880: LD_VAR 0 2
18884: PUSH
18885: LD_EXP 65
18889: PUSH
18890: LD_INT 3
18892: ARRAY
18893: PUSH
18894: LD_INT 3
18896: ARRAY
18897: EQUAL
18898: IFFALSE 19021
// begin lab := artifactsLabs [ 3 ] ;
18900: LD_ADDR_VAR 0 6
18904: PUSH
18905: LD_EXP 64
18909: PUSH
18910: LD_INT 3
18912: ARRAY
18913: ST_TO_ADDR
// if not lab then
18914: LD_VAR 0 6
18918: NOT
18919: IFFALSE 18923
// exit ;
18921: GO 19673
// SetSpecResearch ( lab , artifactsResDifficulty [ 3 ] , true ) ;
18923: LD_VAR 0 6
18927: PPUSH
18928: LD_EXP 62
18932: PUSH
18933: LD_INT 3
18935: ARRAY
18936: PPUSH
18937: LD_INT 1
18939: PPUSH
18940: CALL_OW 486
// if artifactsResProgress [ 3 ] then
18944: LD_EXP 63
18948: PUSH
18949: LD_INT 3
18951: ARRAY
18952: IFFALSE 18972
// SetWorkingProgress ( lab , artifactsResProgress [ 3 ] ) ;
18954: LD_VAR 0 6
18958: PPUSH
18959: LD_EXP 63
18963: PUSH
18964: LD_INT 3
18966: ARRAY
18967: PPUSH
18968: CALL_OW 329
// artifactsLabsWorking := Replace ( artifactsLabsWorking , 3 , 1 ) ;
18972: LD_ADDR_EXP 61
18976: PUSH
18977: LD_EXP 61
18981: PPUSH
18982: LD_INT 3
18984: PPUSH
18985: LD_INT 1
18987: PPUSH
18988: CALL_OW 1
18992: ST_TO_ADDR
// SetArtifactUse ( 7 , artifactsButtons [ 3 ] [ 3 ] , art_no , lab ) ;
18993: LD_INT 7
18995: PPUSH
18996: LD_EXP 65
19000: PUSH
19001: LD_INT 3
19003: ARRAY
19004: PUSH
19005: LD_INT 3
19007: ARRAY
19008: PPUSH
19009: LD_INT 0
19011: PPUSH
19012: LD_VAR 0 6
19016: PPUSH
19017: CALL_OW 468
// end ; if icon = artifactsButtons [ 1 ] [ 1 ] then
19021: LD_VAR 0 2
19025: PUSH
19026: LD_EXP 65
19030: PUSH
19031: LD_INT 1
19033: ARRAY
19034: PUSH
19035: LD_INT 1
19037: ARRAY
19038: EQUAL
19039: IFFALSE 19197
// begin lab := artifactsLabs [ 1 ] ;
19041: LD_ADDR_VAR 0 6
19045: PUSH
19046: LD_EXP 64
19050: PUSH
19051: LD_INT 1
19053: ARRAY
19054: ST_TO_ADDR
// if GetBaseMaterials ( GetBase ( lab ) ) [ 3 ] < artifactsSibCost [ 1 ] then
19055: LD_VAR 0 6
19059: PPUSH
19060: CALL_OW 274
19064: PPUSH
19065: CALL 93243 0 1
19069: PUSH
19070: LD_INT 3
19072: ARRAY
19073: PUSH
19074: LD_EXP 59
19078: PUSH
19079: LD_INT 1
19081: ARRAY
19082: LESS
19083: IFFALSE 19097
// begin HintSpec ( ArtifactCost , 2 ) ;
19085: LD_STRING ArtifactCost
19087: PPUSH
19088: LD_INT 2
19090: PPUSH
19091: CALL_OW 338
// exit ;
19095: GO 19673
// end ; artifactsReady := Replace ( artifactsReady , 1 , false ) ;
19097: LD_ADDR_EXP 66
19101: PUSH
19102: LD_EXP 66
19106: PPUSH
19107: LD_INT 1
19109: PPUSH
19110: LD_INT 0
19112: PPUSH
19113: CALL_OW 1
19117: ST_TO_ADDR
// PlaceSeeing ( x , y , 7 , - 12 ) ;
19118: LD_VAR 0 3
19122: PPUSH
19123: LD_VAR 0 4
19127: PPUSH
19128: LD_INT 7
19130: PPUSH
19131: LD_INT 12
19133: NEG
19134: PPUSH
19135: CALL_OW 330
// wait ( 0 0$30 ) ;
19139: LD_INT 1050
19141: PPUSH
19142: CALL_OW 67
// RemoveSeeing ( x , y , 7 ) ;
19146: LD_VAR 0 3
19150: PPUSH
19151: LD_VAR 0 4
19155: PPUSH
19156: LD_INT 7
19158: PPUSH
19159: CALL_OW 331
// wait ( artifactsRecharge [ 1 ] ) ;
19163: LD_EXP 58
19167: PUSH
19168: LD_INT 1
19170: ARRAY
19171: PPUSH
19172: CALL_OW 67
// artifactsReady := Replace ( artifactsReady , 1 , true ) ;
19176: LD_ADDR_EXP 66
19180: PUSH
19181: LD_EXP 66
19185: PPUSH
19186: LD_INT 1
19188: PPUSH
19189: LD_INT 1
19191: PPUSH
19192: CALL_OW 1
19196: ST_TO_ADDR
// end ; if icon = artifactsButtons [ 2 ] [ 1 ] then
19197: LD_VAR 0 2
19201: PUSH
19202: LD_EXP 65
19206: PUSH
19207: LD_INT 2
19209: ARRAY
19210: PUSH
19211: LD_INT 1
19213: ARRAY
19214: EQUAL
19215: IFFALSE 19427
// begin lab := artifactsLabs [ 2 ] ;
19217: LD_ADDR_VAR 0 6
19221: PUSH
19222: LD_EXP 64
19226: PUSH
19227: LD_INT 2
19229: ARRAY
19230: ST_TO_ADDR
// if not x in FilterAllUnits ( [ [ f_enemy , 7 ] , [ f_or , [ f_engine , engine_siberite ] , [ f_btype , b_siberite_power ] , [ f_btype , b_siberite_mine ] , [ f_bweapon , ru_time_lapser ] , [ f_weapon , ru_time_lapser ] ] ] ) then
19231: LD_VAR 0 3
19235: PUSH
19236: LD_INT 81
19238: PUSH
19239: LD_INT 7
19241: PUSH
19242: EMPTY
19243: LIST
19244: LIST
19245: PUSH
19246: LD_INT 2
19248: PUSH
19249: LD_INT 32
19251: PUSH
19252: LD_INT 3
19254: PUSH
19255: EMPTY
19256: LIST
19257: LIST
19258: PUSH
19259: LD_INT 30
19261: PUSH
19262: LD_INT 28
19264: PUSH
19265: EMPTY
19266: LIST
19267: LIST
19268: PUSH
19269: LD_INT 30
19271: PUSH
19272: LD_INT 30
19274: PUSH
19275: EMPTY
19276: LIST
19277: LIST
19278: PUSH
19279: LD_INT 35
19281: PUSH
19282: LD_INT 49
19284: PUSH
19285: EMPTY
19286: LIST
19287: LIST
19288: PUSH
19289: LD_INT 34
19291: PUSH
19292: LD_INT 49
19294: PUSH
19295: EMPTY
19296: LIST
19297: LIST
19298: PUSH
19299: EMPTY
19300: LIST
19301: LIST
19302: LIST
19303: LIST
19304: LIST
19305: LIST
19306: PUSH
19307: EMPTY
19308: LIST
19309: LIST
19310: PPUSH
19311: CALL_OW 69
19315: IN
19316: NOT
19317: IFFALSE 19321
// exit ;
19319: GO 19673
// if GetBaseMaterials ( GetBase ( lab ) ) [ 3 ] < artifactsSibCost [ 2 ] then
19321: LD_VAR 0 6
19325: PPUSH
19326: CALL_OW 274
19330: PPUSH
19331: CALL 93243 0 1
19335: PUSH
19336: LD_INT 3
19338: ARRAY
19339: PUSH
19340: LD_EXP 59
19344: PUSH
19345: LD_INT 2
19347: ARRAY
19348: LESS
19349: IFFALSE 19363
// begin HintSpec ( ArtifactCost , 2 ) ;
19351: LD_STRING ArtifactCost
19353: PPUSH
19354: LD_INT 2
19356: PPUSH
19357: CALL_OW 338
// exit ;
19361: GO 19673
// end ; artifactsReady := Replace ( artifactsReady , 2 , false ) ;
19363: LD_ADDR_EXP 66
19367: PUSH
19368: LD_EXP 66
19372: PPUSH
19373: LD_INT 2
19375: PPUSH
19376: LD_INT 0
19378: PPUSH
19379: CALL_OW 1
19383: ST_TO_ADDR
// KillUnit ( x ) ;
19384: LD_VAR 0 3
19388: PPUSH
19389: CALL_OW 66
// wait ( artifactsRecharge [ 2 ] ) ;
19393: LD_EXP 58
19397: PUSH
19398: LD_INT 2
19400: ARRAY
19401: PPUSH
19402: CALL_OW 67
// artifactsReady := Replace ( artifactsReady , 2 , true ) ;
19406: LD_ADDR_EXP 66
19410: PUSH
19411: LD_EXP 66
19415: PPUSH
19416: LD_INT 2
19418: PPUSH
19419: LD_INT 1
19421: PPUSH
19422: CALL_OW 1
19426: ST_TO_ADDR
// end ; if icon = artifactsButtons [ 3 ] [ 1 ] then
19427: LD_VAR 0 2
19431: PUSH
19432: LD_EXP 65
19436: PUSH
19437: LD_INT 3
19439: ARRAY
19440: PUSH
19441: LD_INT 1
19443: ARRAY
19444: EQUAL
19445: IFFALSE 19673
// begin lab := artifactsLabs [ 3 ] ;
19447: LD_ADDR_VAR 0 6
19451: PUSH
19452: LD_EXP 64
19456: PUSH
19457: LD_INT 3
19459: ARRAY
19460: ST_TO_ADDR
// if GetBaseMaterials ( GetBase ( lab ) ) [ 3 ] < artifactsSibCost [ 3 ] then
19461: LD_VAR 0 6
19465: PPUSH
19466: CALL_OW 274
19470: PPUSH
19471: CALL 93243 0 1
19475: PUSH
19476: LD_INT 3
19478: ARRAY
19479: PUSH
19480: LD_EXP 59
19484: PUSH
19485: LD_INT 3
19487: ARRAY
19488: LESS
19489: IFFALSE 19503
// begin HintSpec ( ArtifactCost , 2 ) ;
19491: LD_STRING ArtifactCost
19493: PPUSH
19494: LD_INT 2
19496: PPUSH
19497: CALL_OW 338
// exit ;
19501: GO 19673
// end ; SetAreaMapShow ( teleportArea , 1 ) ;
19503: LD_INT 37
19505: PPUSH
19506: LD_INT 1
19508: PPUSH
19509: CALL_OW 424
// time := 0 0$30 ;
19513: LD_ADDR_VAR 0 7
19517: PUSH
19518: LD_INT 1050
19520: ST_TO_ADDR
// repeat display_strings := [ Am15a-1 , time ] ;
19521: LD_ADDR_OWVAR 47
19525: PUSH
19526: LD_STRING Am15a-1
19528: PUSH
19529: LD_VAR 0 7
19533: PUSH
19534: EMPTY
19535: LIST
19536: LIST
19537: ST_TO_ADDR
// wait ( 0 0$1 ) ;
19538: LD_INT 35
19540: PPUSH
19541: CALL_OW 67
// time := time - 0 0$1 ;
19545: LD_ADDR_VAR 0 7
19549: PUSH
19550: LD_VAR 0 7
19554: PUSH
19555: LD_INT 35
19557: MINUS
19558: ST_TO_ADDR
// until time = 0 0$00 ;
19559: LD_VAR 0 7
19563: PUSH
19564: LD_INT 0
19566: EQUAL
19567: IFFALSE 19521
// display_strings :=  ;
19569: LD_ADDR_OWVAR 47
19573: PUSH
19574: LD_STRING 
19576: ST_TO_ADDR
// SetAreaMapShow ( teleportArea , 0 ) ;
19577: LD_INT 37
19579: PPUSH
19580: LD_INT 0
19582: PPUSH
19583: CALL_OW 424
// list := FilterUnitsInArea ( teleportArea , [ f_not , [ f_type , unit_building ] ] ) ;
19587: LD_ADDR_VAR 0 8
19591: PUSH
19592: LD_INT 37
19594: PPUSH
19595: LD_INT 3
19597: PUSH
19598: LD_INT 21
19600: PUSH
19601: LD_INT 3
19603: PUSH
19604: EMPTY
19605: LIST
19606: LIST
19607: PUSH
19608: EMPTY
19609: LIST
19610: LIST
19611: PPUSH
19612: CALL_OW 70
19616: ST_TO_ADDR
// CenterOnXY ( x , y ) ;
19617: LD_VAR 0 3
19621: PPUSH
19622: LD_VAR 0 4
19626: PPUSH
19627: CALL_OW 84
// for un in list do
19631: LD_ADDR_VAR 0 9
19635: PUSH
19636: LD_VAR 0 8
19640: PUSH
19641: FOR_IN
19642: IFFALSE 19671
// TeleportUnit ( un , x , y , 12 , true ) ;
19644: LD_VAR 0 9
19648: PPUSH
19649: LD_VAR 0 3
19653: PPUSH
19654: LD_VAR 0 4
19658: PPUSH
19659: LD_INT 12
19661: PPUSH
19662: LD_INT 1
19664: PPUSH
19665: CALL_OW 483
19669: GO 19641
19671: POP
19672: POP
// end ; end ;
19673: PPOPN 9
19675: END
// on SpecResearchCancel ( lab , progress ) do var i , labNum ;
19676: LD_INT 0
19678: PPUSH
19679: PPUSH
// begin labNum := 0 ;
19680: LD_ADDR_VAR 0 4
19684: PUSH
19685: LD_INT 0
19687: ST_TO_ADDR
// for i = 1 to artifactsLabs do
19688: LD_ADDR_VAR 0 3
19692: PUSH
19693: DOUBLE
19694: LD_INT 1
19696: DEC
19697: ST_TO_ADDR
19698: LD_EXP 64
19702: PUSH
19703: FOR_TO
19704: IFFALSE 19738
// if artifactsLabs [ i ] = lab then
19706: LD_EXP 64
19710: PUSH
19711: LD_VAR 0 3
19715: ARRAY
19716: PUSH
19717: LD_VAR 0 1
19721: EQUAL
19722: IFFALSE 19736
// begin labNum := i ;
19724: LD_ADDR_VAR 0 4
19728: PUSH
19729: LD_VAR 0 3
19733: ST_TO_ADDR
// break ;
19734: GO 19738
// end ;
19736: GO 19703
19738: POP
19739: POP
// if not labNum then
19740: LD_VAR 0 4
19744: NOT
19745: IFFALSE 19749
// exit ;
19747: GO 19827
// SetArtifactUse ( 7 , artifactsButtons [ labNum ] [ 3 ] , art_instant , lab ) ;
19749: LD_INT 7
19751: PPUSH
19752: LD_EXP 65
19756: PUSH
19757: LD_VAR 0 4
19761: ARRAY
19762: PUSH
19763: LD_INT 3
19765: ARRAY
19766: PPUSH
19767: LD_INT 2
19769: PPUSH
19770: LD_VAR 0 1
19774: PPUSH
19775: CALL_OW 468
// artifactsResProgress := Replace ( artifactsResProgress , labNum , progress ) ;
19779: LD_ADDR_EXP 63
19783: PUSH
19784: LD_EXP 63
19788: PPUSH
19789: LD_VAR 0 4
19793: PPUSH
19794: LD_VAR 0 2
19798: PPUSH
19799: CALL_OW 1
19803: ST_TO_ADDR
// artifactsLabsWorking := Replace ( artifactsLabsWorking , labNum , 0 ) ;
19804: LD_ADDR_EXP 61
19808: PUSH
19809: LD_EXP 61
19813: PPUSH
19814: LD_VAR 0 4
19818: PPUSH
19819: LD_INT 0
19821: PPUSH
19822: CALL_OW 1
19826: ST_TO_ADDR
// end ;
19827: PPOPN 4
19829: END
// on SpecResearchComplete ( lab ) do var i , labNum ;
19830: LD_INT 0
19832: PPUSH
19833: PPUSH
// begin labNum := 0 ;
19834: LD_ADDR_VAR 0 3
19838: PUSH
19839: LD_INT 0
19841: ST_TO_ADDR
// for i = 1 to artifactsLabs do
19842: LD_ADDR_VAR 0 2
19846: PUSH
19847: DOUBLE
19848: LD_INT 1
19850: DEC
19851: ST_TO_ADDR
19852: LD_EXP 64
19856: PUSH
19857: FOR_TO
19858: IFFALSE 19892
// if artifactsLabs [ i ] = lab then
19860: LD_EXP 64
19864: PUSH
19865: LD_VAR 0 2
19869: ARRAY
19870: PUSH
19871: LD_VAR 0 1
19875: EQUAL
19876: IFFALSE 19890
// begin labNum := i ;
19878: LD_ADDR_VAR 0 3
19882: PUSH
19883: LD_VAR 0 2
19887: ST_TO_ADDR
// break ;
19888: GO 19892
// end ;
19890: GO 19857
19892: POP
19893: POP
// if not labNum then
19894: LD_VAR 0 3
19898: NOT
19899: IFFALSE 19903
// exit ;
19901: GO 20065
// SetArtifactUse ( 7 , artifactsButtons [ labNum ] [ 3 ] , art_no , lab ) ;
19903: LD_INT 7
19905: PPUSH
19906: LD_EXP 65
19910: PUSH
19911: LD_VAR 0 3
19915: ARRAY
19916: PUSH
19917: LD_INT 3
19919: ARRAY
19920: PPUSH
19921: LD_INT 0
19923: PPUSH
19924: LD_VAR 0 1
19928: PPUSH
19929: CALL_OW 468
// artifactsResearched := Replace ( artifactsResearched , labNum , true ) ;
19933: LD_ADDR_EXP 60
19937: PUSH
19938: LD_EXP 60
19942: PPUSH
19943: LD_VAR 0 3
19947: PPUSH
19948: LD_INT 1
19950: PPUSH
19951: CALL_OW 1
19955: ST_TO_ADDR
// artifactsReady := Replace ( artifactsReady , labNum , true ) ;
19956: LD_ADDR_EXP 66
19960: PUSH
19961: LD_EXP 66
19965: PPUSH
19966: LD_VAR 0 3
19970: PPUSH
19971: LD_INT 1
19973: PPUSH
19974: CALL_OW 1
19978: ST_TO_ADDR
// artifactsLabsWorking := Replace ( artifactsLabsWorking , labNum , false ) ;
19979: LD_ADDR_EXP 61
19983: PUSH
19984: LD_EXP 61
19988: PPUSH
19989: LD_VAR 0 3
19993: PPUSH
19994: LD_INT 0
19996: PPUSH
19997: CALL_OW 1
20001: ST_TO_ADDR
// case labNum of 1 :
20002: LD_VAR 0 3
20006: PUSH
20007: LD_INT 1
20009: DOUBLE
20010: EQUAL
20011: IFTRUE 20015
20013: GO 20026
20015: POP
// artifactIResearched := true ; 2 :
20016: LD_ADDR_EXP 9
20020: PUSH
20021: LD_INT 1
20023: ST_TO_ADDR
20024: GO 20065
20026: LD_INT 2
20028: DOUBLE
20029: EQUAL
20030: IFTRUE 20034
20032: GO 20045
20034: POP
// artifactIIResearched := true ; 3 :
20035: LD_ADDR_EXP 10
20039: PUSH
20040: LD_INT 1
20042: ST_TO_ADDR
20043: GO 20065
20045: LD_INT 3
20047: DOUBLE
20048: EQUAL
20049: IFTRUE 20053
20051: GO 20064
20053: POP
// artifactIIIResearched := true ; end ;
20054: LD_ADDR_EXP 11
20058: PUSH
20059: LD_INT 1
20061: ST_TO_ADDR
20062: GO 20065
20064: POP
// end ; end_of_file
20065: PPOPN 3
20067: END
// export ru_radar , ru_big_cargo_bay , us_hack , us_artillery , ar_bio_bomb ; every 1 do
20068: GO 20070
20070: DISABLE
// begin ru_radar := 98 ;
20071: LD_ADDR_EXP 67
20075: PUSH
20076: LD_INT 98
20078: ST_TO_ADDR
// ru_big_cargo_bay := 89 ;
20079: LD_ADDR_EXP 68
20083: PUSH
20084: LD_INT 89
20086: ST_TO_ADDR
// us_hack := 99 ;
20087: LD_ADDR_EXP 69
20091: PUSH
20092: LD_INT 99
20094: ST_TO_ADDR
// us_artillery := 97 ;
20095: LD_ADDR_EXP 70
20099: PUSH
20100: LD_INT 97
20102: ST_TO_ADDR
// ar_bio_bomb := 91 ;
20103: LD_ADDR_EXP 71
20107: PUSH
20108: LD_INT 91
20110: ST_TO_ADDR
// end ; end_of_file
20111: END
// export skirmish , debug_mc ; export mc_bases , mc_building_need_repair , mc_building_repairs , mc_need_heal , mc_healers , mc_build_list , mc_builders , mc_construct_list , mc_turret_list , mc_empty_turret_list , mc_busy_turret_list , mc_defender_limit , mc_repair_vehicle , mc_mines , mc_miners , mc_minefields , mc_crates , mc_crates_collector , mc_crates_area , mc_vehicles , mc_attack , mc_produce , mc_defender , mc_scan , mc_parking , mc_scan_area , mc_sides , mc_tech , mc_can_tame , mc_ape , mc_ape_in_lab , mc_taming , mc_build_upgrade , mc_lab , mc_lab_upgrade , mc_teleport_exit , mc_teleport_exit_set , mc_deposits_xy , mc_deposits_finder , mc_allowed_tower_weapons , mc_remote_driver , mc_class , mc_class_case_use ; export function InitMacro ; var i ; begin
20112: LD_INT 0
20114: PPUSH
20115: PPUSH
// skirmish := false ;
20116: LD_ADDR_EXP 72
20120: PUSH
20121: LD_INT 0
20123: ST_TO_ADDR
// debug_mc := false ;
20124: LD_ADDR_EXP 73
20128: PUSH
20129: LD_INT 0
20131: ST_TO_ADDR
// mc_bases := [ ] ;
20132: LD_ADDR_EXP 74
20136: PUSH
20137: EMPTY
20138: ST_TO_ADDR
// mc_sides := [ ] ;
20139: LD_ADDR_EXP 100
20143: PUSH
20144: EMPTY
20145: ST_TO_ADDR
// mc_building_need_repair := [ ] ;
20146: LD_ADDR_EXP 75
20150: PUSH
20151: EMPTY
20152: ST_TO_ADDR
// mc_building_repairs := [ ] ;
20153: LD_ADDR_EXP 76
20157: PUSH
20158: EMPTY
20159: ST_TO_ADDR
// mc_need_heal := [ ] ;
20160: LD_ADDR_EXP 77
20164: PUSH
20165: EMPTY
20166: ST_TO_ADDR
// mc_healers := [ ] ;
20167: LD_ADDR_EXP 78
20171: PUSH
20172: EMPTY
20173: ST_TO_ADDR
// mc_build_list := [ ] ;
20174: LD_ADDR_EXP 79
20178: PUSH
20179: EMPTY
20180: ST_TO_ADDR
// mc_build_upgrade := [ ] ;
20181: LD_ADDR_EXP 106
20185: PUSH
20186: EMPTY
20187: ST_TO_ADDR
// mc_builders := [ ] ;
20188: LD_ADDR_EXP 80
20192: PUSH
20193: EMPTY
20194: ST_TO_ADDR
// mc_construct_list := [ ] ;
20195: LD_ADDR_EXP 81
20199: PUSH
20200: EMPTY
20201: ST_TO_ADDR
// mc_turret_list := [ ] ;
20202: LD_ADDR_EXP 82
20206: PUSH
20207: EMPTY
20208: ST_TO_ADDR
// mc_empty_turret_list := [ ] ;
20209: LD_ADDR_EXP 83
20213: PUSH
20214: EMPTY
20215: ST_TO_ADDR
// mc_miners := [ ] ;
20216: LD_ADDR_EXP 88
20220: PUSH
20221: EMPTY
20222: ST_TO_ADDR
// mc_mines := [ ] ;
20223: LD_ADDR_EXP 87
20227: PUSH
20228: EMPTY
20229: ST_TO_ADDR
// mc_minefields := [ ] ;
20230: LD_ADDR_EXP 89
20234: PUSH
20235: EMPTY
20236: ST_TO_ADDR
// mc_crates := [ ] ;
20237: LD_ADDR_EXP 90
20241: PUSH
20242: EMPTY
20243: ST_TO_ADDR
// mc_crates_collector := [ ] ;
20244: LD_ADDR_EXP 91
20248: PUSH
20249: EMPTY
20250: ST_TO_ADDR
// mc_crates_area := [ ] ;
20251: LD_ADDR_EXP 92
20255: PUSH
20256: EMPTY
20257: ST_TO_ADDR
// mc_vehicles := [ ] ;
20258: LD_ADDR_EXP 93
20262: PUSH
20263: EMPTY
20264: ST_TO_ADDR
// mc_attack := [ ] ;
20265: LD_ADDR_EXP 94
20269: PUSH
20270: EMPTY
20271: ST_TO_ADDR
// mc_produce := [ ] ;
20272: LD_ADDR_EXP 95
20276: PUSH
20277: EMPTY
20278: ST_TO_ADDR
// mc_defender := [ ] ;
20279: LD_ADDR_EXP 96
20283: PUSH
20284: EMPTY
20285: ST_TO_ADDR
// mc_parking := [ ] ;
20286: LD_ADDR_EXP 98
20290: PUSH
20291: EMPTY
20292: ST_TO_ADDR
// mc_busy_turret_list := [ ] ;
20293: LD_ADDR_EXP 84
20297: PUSH
20298: EMPTY
20299: ST_TO_ADDR
// mc_repair_vehicle := [ ] ;
20300: LD_ADDR_EXP 86
20304: PUSH
20305: EMPTY
20306: ST_TO_ADDR
// mc_scan := [ ] ;
20307: LD_ADDR_EXP 97
20311: PUSH
20312: EMPTY
20313: ST_TO_ADDR
// mc_scan_area := [ ] ;
20314: LD_ADDR_EXP 99
20318: PUSH
20319: EMPTY
20320: ST_TO_ADDR
// mc_tech := [ ] ;
20321: LD_ADDR_EXP 101
20325: PUSH
20326: EMPTY
20327: ST_TO_ADDR
// mc_class := [ ] ;
20328: LD_ADDR_EXP 115
20332: PUSH
20333: EMPTY
20334: ST_TO_ADDR
// mc_class_case_use := [ ] ;
20335: LD_ADDR_EXP 116
20339: PUSH
20340: EMPTY
20341: ST_TO_ADDR
// end ;
20342: LD_VAR 0 1
20346: RET
// export function MC_Kill ( base ) ; begin
20347: LD_INT 0
20349: PPUSH
// mc_bases := Replace ( mc_bases , base , [ ] ) ;
20350: LD_ADDR_EXP 74
20354: PUSH
20355: LD_EXP 74
20359: PPUSH
20360: LD_VAR 0 1
20364: PPUSH
20365: EMPTY
20366: PPUSH
20367: CALL_OW 1
20371: ST_TO_ADDR
// mc_building_need_repair := Replace ( mc_building_need_repair , base , [ ] ) ;
20372: LD_ADDR_EXP 75
20376: PUSH
20377: LD_EXP 75
20381: PPUSH
20382: LD_VAR 0 1
20386: PPUSH
20387: EMPTY
20388: PPUSH
20389: CALL_OW 1
20393: ST_TO_ADDR
// mc_building_repairs := Replace ( mc_building_repairs , base , [ ] ) ;
20394: LD_ADDR_EXP 76
20398: PUSH
20399: LD_EXP 76
20403: PPUSH
20404: LD_VAR 0 1
20408: PPUSH
20409: EMPTY
20410: PPUSH
20411: CALL_OW 1
20415: ST_TO_ADDR
// mc_need_heal := Replace ( mc_need_heal , base , [ ] ) ;
20416: LD_ADDR_EXP 77
20420: PUSH
20421: LD_EXP 77
20425: PPUSH
20426: LD_VAR 0 1
20430: PPUSH
20431: EMPTY
20432: PPUSH
20433: CALL_OW 1
20437: ST_TO_ADDR
// mc_healers := Replace ( mc_healers , base , [ ] ) ;
20438: LD_ADDR_EXP 78
20442: PUSH
20443: LD_EXP 78
20447: PPUSH
20448: LD_VAR 0 1
20452: PPUSH
20453: EMPTY
20454: PPUSH
20455: CALL_OW 1
20459: ST_TO_ADDR
// mc_build_list := Replace ( mc_build_list , base , [ ] ) ;
20460: LD_ADDR_EXP 79
20464: PUSH
20465: LD_EXP 79
20469: PPUSH
20470: LD_VAR 0 1
20474: PPUSH
20475: EMPTY
20476: PPUSH
20477: CALL_OW 1
20481: ST_TO_ADDR
// mc_builders := Replace ( mc_builders , base , [ ] ) ;
20482: LD_ADDR_EXP 80
20486: PUSH
20487: LD_EXP 80
20491: PPUSH
20492: LD_VAR 0 1
20496: PPUSH
20497: EMPTY
20498: PPUSH
20499: CALL_OW 1
20503: ST_TO_ADDR
// mc_construct_list := Replace ( mc_construct_list , base , [ ] ) ;
20504: LD_ADDR_EXP 81
20508: PUSH
20509: LD_EXP 81
20513: PPUSH
20514: LD_VAR 0 1
20518: PPUSH
20519: EMPTY
20520: PPUSH
20521: CALL_OW 1
20525: ST_TO_ADDR
// mc_turret_list := Replace ( mc_turret_list , base , [ ] ) ;
20526: LD_ADDR_EXP 82
20530: PUSH
20531: LD_EXP 82
20535: PPUSH
20536: LD_VAR 0 1
20540: PPUSH
20541: EMPTY
20542: PPUSH
20543: CALL_OW 1
20547: ST_TO_ADDR
// mc_empty_turret_list := Replace ( mc_empty_turret_list , base , [ ] ) ;
20548: LD_ADDR_EXP 83
20552: PUSH
20553: LD_EXP 83
20557: PPUSH
20558: LD_VAR 0 1
20562: PPUSH
20563: EMPTY
20564: PPUSH
20565: CALL_OW 1
20569: ST_TO_ADDR
// mc_busy_turret_list := Replace ( mc_busy_turret_list , base , [ ] ) ;
20570: LD_ADDR_EXP 84
20574: PUSH
20575: LD_EXP 84
20579: PPUSH
20580: LD_VAR 0 1
20584: PPUSH
20585: EMPTY
20586: PPUSH
20587: CALL_OW 1
20591: ST_TO_ADDR
// mc_defender_limit := Replace ( mc_defender_limit , base , 0 ) ;
20592: LD_ADDR_EXP 85
20596: PUSH
20597: LD_EXP 85
20601: PPUSH
20602: LD_VAR 0 1
20606: PPUSH
20607: LD_INT 0
20609: PPUSH
20610: CALL_OW 1
20614: ST_TO_ADDR
// mc_repair_vehicle := Replace ( mc_repair_vehicle , base , [ ] ) ;
20615: LD_ADDR_EXP 86
20619: PUSH
20620: LD_EXP 86
20624: PPUSH
20625: LD_VAR 0 1
20629: PPUSH
20630: EMPTY
20631: PPUSH
20632: CALL_OW 1
20636: ST_TO_ADDR
// mc_mines := Replace ( mc_mines , base , [ ] ) ;
20637: LD_ADDR_EXP 87
20641: PUSH
20642: LD_EXP 87
20646: PPUSH
20647: LD_VAR 0 1
20651: PPUSH
20652: EMPTY
20653: PPUSH
20654: CALL_OW 1
20658: ST_TO_ADDR
// mc_miners := Replace ( mc_miners , base , [ ] ) ;
20659: LD_ADDR_EXP 88
20663: PUSH
20664: LD_EXP 88
20668: PPUSH
20669: LD_VAR 0 1
20673: PPUSH
20674: EMPTY
20675: PPUSH
20676: CALL_OW 1
20680: ST_TO_ADDR
// mc_minefields := Replace ( mc_minefields , base , [ ] ) ;
20681: LD_ADDR_EXP 89
20685: PUSH
20686: LD_EXP 89
20690: PPUSH
20691: LD_VAR 0 1
20695: PPUSH
20696: EMPTY
20697: PPUSH
20698: CALL_OW 1
20702: ST_TO_ADDR
// mc_crates := Replace ( mc_crates , base , [ ] ) ;
20703: LD_ADDR_EXP 90
20707: PUSH
20708: LD_EXP 90
20712: PPUSH
20713: LD_VAR 0 1
20717: PPUSH
20718: EMPTY
20719: PPUSH
20720: CALL_OW 1
20724: ST_TO_ADDR
// mc_crates_collector := Replace ( mc_crates_collector , base , [ ] ) ;
20725: LD_ADDR_EXP 91
20729: PUSH
20730: LD_EXP 91
20734: PPUSH
20735: LD_VAR 0 1
20739: PPUSH
20740: EMPTY
20741: PPUSH
20742: CALL_OW 1
20746: ST_TO_ADDR
// mc_crates_area := Replace ( mc_crates_area , base , [ ] ) ;
20747: LD_ADDR_EXP 92
20751: PUSH
20752: LD_EXP 92
20756: PPUSH
20757: LD_VAR 0 1
20761: PPUSH
20762: EMPTY
20763: PPUSH
20764: CALL_OW 1
20768: ST_TO_ADDR
// mc_vehicles := Replace ( mc_vehicles , base , [ ] ) ;
20769: LD_ADDR_EXP 93
20773: PUSH
20774: LD_EXP 93
20778: PPUSH
20779: LD_VAR 0 1
20783: PPUSH
20784: EMPTY
20785: PPUSH
20786: CALL_OW 1
20790: ST_TO_ADDR
// mc_attack := Replace ( mc_attack , base , [ ] ) ;
20791: LD_ADDR_EXP 94
20795: PUSH
20796: LD_EXP 94
20800: PPUSH
20801: LD_VAR 0 1
20805: PPUSH
20806: EMPTY
20807: PPUSH
20808: CALL_OW 1
20812: ST_TO_ADDR
// mc_produce := Replace ( mc_produce , base , [ ] ) ;
20813: LD_ADDR_EXP 95
20817: PUSH
20818: LD_EXP 95
20822: PPUSH
20823: LD_VAR 0 1
20827: PPUSH
20828: EMPTY
20829: PPUSH
20830: CALL_OW 1
20834: ST_TO_ADDR
// mc_defender := Replace ( mc_defender , base , [ ] ) ;
20835: LD_ADDR_EXP 96
20839: PUSH
20840: LD_EXP 96
20844: PPUSH
20845: LD_VAR 0 1
20849: PPUSH
20850: EMPTY
20851: PPUSH
20852: CALL_OW 1
20856: ST_TO_ADDR
// mc_scan := Replace ( mc_scan , base , [ ] ) ;
20857: LD_ADDR_EXP 97
20861: PUSH
20862: LD_EXP 97
20866: PPUSH
20867: LD_VAR 0 1
20871: PPUSH
20872: EMPTY
20873: PPUSH
20874: CALL_OW 1
20878: ST_TO_ADDR
// mc_parking := Replace ( mc_parking , base , [ ] ) ;
20879: LD_ADDR_EXP 98
20883: PUSH
20884: LD_EXP 98
20888: PPUSH
20889: LD_VAR 0 1
20893: PPUSH
20894: EMPTY
20895: PPUSH
20896: CALL_OW 1
20900: ST_TO_ADDR
// mc_scan_area := Replace ( mc_scan_area , base , [ ] ) ;
20901: LD_ADDR_EXP 99
20905: PUSH
20906: LD_EXP 99
20910: PPUSH
20911: LD_VAR 0 1
20915: PPUSH
20916: EMPTY
20917: PPUSH
20918: CALL_OW 1
20922: ST_TO_ADDR
// mc_tech := Replace ( mc_tech , base , [ ] ) ;
20923: LD_ADDR_EXP 101
20927: PUSH
20928: LD_EXP 101
20932: PPUSH
20933: LD_VAR 0 1
20937: PPUSH
20938: EMPTY
20939: PPUSH
20940: CALL_OW 1
20944: ST_TO_ADDR
// mc_ape := Replace ( mc_ape , base , [ ] ) ;
20945: LD_ADDR_EXP 103
20949: PUSH
20950: LD_EXP 103
20954: PPUSH
20955: LD_VAR 0 1
20959: PPUSH
20960: EMPTY
20961: PPUSH
20962: CALL_OW 1
20966: ST_TO_ADDR
// mc_ape_in_lab := Replace ( mc_ape_in_lab , base , [ ] ) ;
20967: LD_ADDR_EXP 104
20971: PUSH
20972: LD_EXP 104
20976: PPUSH
20977: LD_VAR 0 1
20981: PPUSH
20982: EMPTY
20983: PPUSH
20984: CALL_OW 1
20988: ST_TO_ADDR
// mc_taming := Replace ( mc_taming , base , [ ] ) ;
20989: LD_ADDR_EXP 105
20993: PUSH
20994: LD_EXP 105
20998: PPUSH
20999: LD_VAR 0 1
21003: PPUSH
21004: EMPTY
21005: PPUSH
21006: CALL_OW 1
21010: ST_TO_ADDR
// mc_build_upgrade := Replace ( mc_build_upgrade , base , [ ] ) ;
21011: LD_ADDR_EXP 106
21015: PUSH
21016: LD_EXP 106
21020: PPUSH
21021: LD_VAR 0 1
21025: PPUSH
21026: EMPTY
21027: PPUSH
21028: CALL_OW 1
21032: ST_TO_ADDR
// mc_lab := Replace ( mc_lab , base , [ ] ) ;
21033: LD_ADDR_EXP 107
21037: PUSH
21038: LD_EXP 107
21042: PPUSH
21043: LD_VAR 0 1
21047: PPUSH
21048: EMPTY
21049: PPUSH
21050: CALL_OW 1
21054: ST_TO_ADDR
// mc_lab_upgrade := Replace ( mc_lab_upgrade , base , [ ] ) ;
21055: LD_ADDR_EXP 108
21059: PUSH
21060: LD_EXP 108
21064: PPUSH
21065: LD_VAR 0 1
21069: PPUSH
21070: EMPTY
21071: PPUSH
21072: CALL_OW 1
21076: ST_TO_ADDR
// mc_teleport_exit := Replace ( mc_teleport_exit , base , [ ] ) ;
21077: LD_ADDR_EXP 109
21081: PUSH
21082: LD_EXP 109
21086: PPUSH
21087: LD_VAR 0 1
21091: PPUSH
21092: EMPTY
21093: PPUSH
21094: CALL_OW 1
21098: ST_TO_ADDR
// mc_teleport_exit_set := Replace ( mc_teleport_exit_set , base , [ ] ) ;
21099: LD_ADDR_EXP 110
21103: PUSH
21104: LD_EXP 110
21108: PPUSH
21109: LD_VAR 0 1
21113: PPUSH
21114: EMPTY
21115: PPUSH
21116: CALL_OW 1
21120: ST_TO_ADDR
// mc_deposits_xy := Replace ( mc_deposits_xy , base , [ ] ) ;
21121: LD_ADDR_EXP 111
21125: PUSH
21126: LD_EXP 111
21130: PPUSH
21131: LD_VAR 0 1
21135: PPUSH
21136: EMPTY
21137: PPUSH
21138: CALL_OW 1
21142: ST_TO_ADDR
// mc_deposits_finder := Replace ( mc_deposits_finder , base , [ ] ) ;
21143: LD_ADDR_EXP 112
21147: PUSH
21148: LD_EXP 112
21152: PPUSH
21153: LD_VAR 0 1
21157: PPUSH
21158: EMPTY
21159: PPUSH
21160: CALL_OW 1
21164: ST_TO_ADDR
// mc_allowed_tower_weapons := Replace ( mc_allowed_tower_weapons , base , [ ] ) ;
21165: LD_ADDR_EXP 113
21169: PUSH
21170: LD_EXP 113
21174: PPUSH
21175: LD_VAR 0 1
21179: PPUSH
21180: EMPTY
21181: PPUSH
21182: CALL_OW 1
21186: ST_TO_ADDR
// mc_remote_driver := Replace ( mc_remote_driver , base , [ ] ) ;
21187: LD_ADDR_EXP 114
21191: PUSH
21192: LD_EXP 114
21196: PPUSH
21197: LD_VAR 0 1
21201: PPUSH
21202: EMPTY
21203: PPUSH
21204: CALL_OW 1
21208: ST_TO_ADDR
// mc_class := Replace ( mc_class , base , [ ] ) ;
21209: LD_ADDR_EXP 115
21213: PUSH
21214: LD_EXP 115
21218: PPUSH
21219: LD_VAR 0 1
21223: PPUSH
21224: EMPTY
21225: PPUSH
21226: CALL_OW 1
21230: ST_TO_ADDR
// mc_class_case_use := Replace ( mc_class_case_use , base , 0 ) ;
21231: LD_ADDR_EXP 116
21235: PUSH
21236: LD_EXP 116
21240: PPUSH
21241: LD_VAR 0 1
21245: PPUSH
21246: LD_INT 0
21248: PPUSH
21249: CALL_OW 1
21253: ST_TO_ADDR
// end ;
21254: LD_VAR 0 2
21258: RET
// export function MC_Add ( side , units ) ; var base ; begin
21259: LD_INT 0
21261: PPUSH
21262: PPUSH
// base := mc_bases + 1 ;
21263: LD_ADDR_VAR 0 4
21267: PUSH
21268: LD_EXP 74
21272: PUSH
21273: LD_INT 1
21275: PLUS
21276: ST_TO_ADDR
// mc_sides := Replace ( mc_sides , base , side ) ;
21277: LD_ADDR_EXP 100
21281: PUSH
21282: LD_EXP 100
21286: PPUSH
21287: LD_VAR 0 4
21291: PPUSH
21292: LD_VAR 0 1
21296: PPUSH
21297: CALL_OW 1
21301: ST_TO_ADDR
// mc_bases := Replace ( mc_bases , base , units ) ;
21302: LD_ADDR_EXP 74
21306: PUSH
21307: LD_EXP 74
21311: PPUSH
21312: LD_VAR 0 4
21316: PPUSH
21317: LD_VAR 0 2
21321: PPUSH
21322: CALL_OW 1
21326: ST_TO_ADDR
// mc_building_need_repair := Replace ( mc_building_need_repair , base , [ ] ) ;
21327: LD_ADDR_EXP 75
21331: PUSH
21332: LD_EXP 75
21336: PPUSH
21337: LD_VAR 0 4
21341: PPUSH
21342: EMPTY
21343: PPUSH
21344: CALL_OW 1
21348: ST_TO_ADDR
// mc_building_repairs := Replace ( mc_building_repairs , base , [ ] ) ;
21349: LD_ADDR_EXP 76
21353: PUSH
21354: LD_EXP 76
21358: PPUSH
21359: LD_VAR 0 4
21363: PPUSH
21364: EMPTY
21365: PPUSH
21366: CALL_OW 1
21370: ST_TO_ADDR
// mc_need_heal := Replace ( mc_need_heal , base , [ ] ) ;
21371: LD_ADDR_EXP 77
21375: PUSH
21376: LD_EXP 77
21380: PPUSH
21381: LD_VAR 0 4
21385: PPUSH
21386: EMPTY
21387: PPUSH
21388: CALL_OW 1
21392: ST_TO_ADDR
// mc_healers := Replace ( mc_healers , base , [ ] ) ;
21393: LD_ADDR_EXP 78
21397: PUSH
21398: LD_EXP 78
21402: PPUSH
21403: LD_VAR 0 4
21407: PPUSH
21408: EMPTY
21409: PPUSH
21410: CALL_OW 1
21414: ST_TO_ADDR
// mc_build_list := Replace ( mc_build_list , base , [ ] ) ;
21415: LD_ADDR_EXP 79
21419: PUSH
21420: LD_EXP 79
21424: PPUSH
21425: LD_VAR 0 4
21429: PPUSH
21430: EMPTY
21431: PPUSH
21432: CALL_OW 1
21436: ST_TO_ADDR
// mc_builders := Replace ( mc_builders , base , [ ] ) ;
21437: LD_ADDR_EXP 80
21441: PUSH
21442: LD_EXP 80
21446: PPUSH
21447: LD_VAR 0 4
21451: PPUSH
21452: EMPTY
21453: PPUSH
21454: CALL_OW 1
21458: ST_TO_ADDR
// mc_construct_list := Replace ( mc_construct_list , base , [ ] ) ;
21459: LD_ADDR_EXP 81
21463: PUSH
21464: LD_EXP 81
21468: PPUSH
21469: LD_VAR 0 4
21473: PPUSH
21474: EMPTY
21475: PPUSH
21476: CALL_OW 1
21480: ST_TO_ADDR
// mc_turret_list := Replace ( mc_turret_list , base , [ ] ) ;
21481: LD_ADDR_EXP 82
21485: PUSH
21486: LD_EXP 82
21490: PPUSH
21491: LD_VAR 0 4
21495: PPUSH
21496: EMPTY
21497: PPUSH
21498: CALL_OW 1
21502: ST_TO_ADDR
// mc_empty_turret_list := Replace ( mc_empty_turret_list , base , [ ] ) ;
21503: LD_ADDR_EXP 83
21507: PUSH
21508: LD_EXP 83
21512: PPUSH
21513: LD_VAR 0 4
21517: PPUSH
21518: EMPTY
21519: PPUSH
21520: CALL_OW 1
21524: ST_TO_ADDR
// mc_busy_turret_list := Replace ( mc_busy_turret_list , base , [ ] ) ;
21525: LD_ADDR_EXP 84
21529: PUSH
21530: LD_EXP 84
21534: PPUSH
21535: LD_VAR 0 4
21539: PPUSH
21540: EMPTY
21541: PPUSH
21542: CALL_OW 1
21546: ST_TO_ADDR
// mc_defender_limit := Replace ( mc_defender_limit , base , 0 ) ;
21547: LD_ADDR_EXP 85
21551: PUSH
21552: LD_EXP 85
21556: PPUSH
21557: LD_VAR 0 4
21561: PPUSH
21562: LD_INT 0
21564: PPUSH
21565: CALL_OW 1
21569: ST_TO_ADDR
// mc_repair_vehicle := Replace ( mc_repair_vehicle , base , [ ] ) ;
21570: LD_ADDR_EXP 86
21574: PUSH
21575: LD_EXP 86
21579: PPUSH
21580: LD_VAR 0 4
21584: PPUSH
21585: EMPTY
21586: PPUSH
21587: CALL_OW 1
21591: ST_TO_ADDR
// mc_mines := Replace ( mc_mines , base , [ ] ) ;
21592: LD_ADDR_EXP 87
21596: PUSH
21597: LD_EXP 87
21601: PPUSH
21602: LD_VAR 0 4
21606: PPUSH
21607: EMPTY
21608: PPUSH
21609: CALL_OW 1
21613: ST_TO_ADDR
// mc_miners := Replace ( mc_miners , base , [ ] ) ;
21614: LD_ADDR_EXP 88
21618: PUSH
21619: LD_EXP 88
21623: PPUSH
21624: LD_VAR 0 4
21628: PPUSH
21629: EMPTY
21630: PPUSH
21631: CALL_OW 1
21635: ST_TO_ADDR
// mc_minefields := Replace ( mc_minefields , base , [ ] ) ;
21636: LD_ADDR_EXP 89
21640: PUSH
21641: LD_EXP 89
21645: PPUSH
21646: LD_VAR 0 4
21650: PPUSH
21651: EMPTY
21652: PPUSH
21653: CALL_OW 1
21657: ST_TO_ADDR
// mc_crates := Replace ( mc_crates , base , [ ] ) ;
21658: LD_ADDR_EXP 90
21662: PUSH
21663: LD_EXP 90
21667: PPUSH
21668: LD_VAR 0 4
21672: PPUSH
21673: EMPTY
21674: PPUSH
21675: CALL_OW 1
21679: ST_TO_ADDR
// mc_crates_collector := Replace ( mc_crates_collector , base , [ ] ) ;
21680: LD_ADDR_EXP 91
21684: PUSH
21685: LD_EXP 91
21689: PPUSH
21690: LD_VAR 0 4
21694: PPUSH
21695: EMPTY
21696: PPUSH
21697: CALL_OW 1
21701: ST_TO_ADDR
// mc_crates_area := Replace ( mc_crates_area , base , [ ] ) ;
21702: LD_ADDR_EXP 92
21706: PUSH
21707: LD_EXP 92
21711: PPUSH
21712: LD_VAR 0 4
21716: PPUSH
21717: EMPTY
21718: PPUSH
21719: CALL_OW 1
21723: ST_TO_ADDR
// mc_vehicles := Replace ( mc_vehicles , base , [ ] ) ;
21724: LD_ADDR_EXP 93
21728: PUSH
21729: LD_EXP 93
21733: PPUSH
21734: LD_VAR 0 4
21738: PPUSH
21739: EMPTY
21740: PPUSH
21741: CALL_OW 1
21745: ST_TO_ADDR
// mc_attack := Replace ( mc_attack , base , [ ] ) ;
21746: LD_ADDR_EXP 94
21750: PUSH
21751: LD_EXP 94
21755: PPUSH
21756: LD_VAR 0 4
21760: PPUSH
21761: EMPTY
21762: PPUSH
21763: CALL_OW 1
21767: ST_TO_ADDR
// mc_produce := Replace ( mc_produce , base , [ ] ) ;
21768: LD_ADDR_EXP 95
21772: PUSH
21773: LD_EXP 95
21777: PPUSH
21778: LD_VAR 0 4
21782: PPUSH
21783: EMPTY
21784: PPUSH
21785: CALL_OW 1
21789: ST_TO_ADDR
// mc_defender := Replace ( mc_defender , base , [ ] ) ;
21790: LD_ADDR_EXP 96
21794: PUSH
21795: LD_EXP 96
21799: PPUSH
21800: LD_VAR 0 4
21804: PPUSH
21805: EMPTY
21806: PPUSH
21807: CALL_OW 1
21811: ST_TO_ADDR
// mc_scan := Replace ( mc_scan , base , [ ] ) ;
21812: LD_ADDR_EXP 97
21816: PUSH
21817: LD_EXP 97
21821: PPUSH
21822: LD_VAR 0 4
21826: PPUSH
21827: EMPTY
21828: PPUSH
21829: CALL_OW 1
21833: ST_TO_ADDR
// mc_parking := Replace ( mc_parking , base , [ ] ) ;
21834: LD_ADDR_EXP 98
21838: PUSH
21839: LD_EXP 98
21843: PPUSH
21844: LD_VAR 0 4
21848: PPUSH
21849: EMPTY
21850: PPUSH
21851: CALL_OW 1
21855: ST_TO_ADDR
// mc_scan_area := Replace ( mc_scan_area , base , [ ] ) ;
21856: LD_ADDR_EXP 99
21860: PUSH
21861: LD_EXP 99
21865: PPUSH
21866: LD_VAR 0 4
21870: PPUSH
21871: EMPTY
21872: PPUSH
21873: CALL_OW 1
21877: ST_TO_ADDR
// mc_tech := Replace ( mc_tech , base , [ ] ) ;
21878: LD_ADDR_EXP 101
21882: PUSH
21883: LD_EXP 101
21887: PPUSH
21888: LD_VAR 0 4
21892: PPUSH
21893: EMPTY
21894: PPUSH
21895: CALL_OW 1
21899: ST_TO_ADDR
// mc_ape := Replace ( mc_ape , base , [ ] ) ;
21900: LD_ADDR_EXP 103
21904: PUSH
21905: LD_EXP 103
21909: PPUSH
21910: LD_VAR 0 4
21914: PPUSH
21915: EMPTY
21916: PPUSH
21917: CALL_OW 1
21921: ST_TO_ADDR
// mc_ape_in_lab := Replace ( mc_ape_in_lab , base , [ ] ) ;
21922: LD_ADDR_EXP 104
21926: PUSH
21927: LD_EXP 104
21931: PPUSH
21932: LD_VAR 0 4
21936: PPUSH
21937: EMPTY
21938: PPUSH
21939: CALL_OW 1
21943: ST_TO_ADDR
// mc_taming := Replace ( mc_taming , base , [ ] ) ;
21944: LD_ADDR_EXP 105
21948: PUSH
21949: LD_EXP 105
21953: PPUSH
21954: LD_VAR 0 4
21958: PPUSH
21959: EMPTY
21960: PPUSH
21961: CALL_OW 1
21965: ST_TO_ADDR
// mc_build_upgrade := Replace ( mc_build_upgrade , base , [ ] ) ;
21966: LD_ADDR_EXP 106
21970: PUSH
21971: LD_EXP 106
21975: PPUSH
21976: LD_VAR 0 4
21980: PPUSH
21981: EMPTY
21982: PPUSH
21983: CALL_OW 1
21987: ST_TO_ADDR
// mc_lab := Replace ( mc_lab , base , [ ] ) ;
21988: LD_ADDR_EXP 107
21992: PUSH
21993: LD_EXP 107
21997: PPUSH
21998: LD_VAR 0 4
22002: PPUSH
22003: EMPTY
22004: PPUSH
22005: CALL_OW 1
22009: ST_TO_ADDR
// mc_lab_upgrade := Replace ( mc_lab_upgrade , base , [ ] ) ;
22010: LD_ADDR_EXP 108
22014: PUSH
22015: LD_EXP 108
22019: PPUSH
22020: LD_VAR 0 4
22024: PPUSH
22025: EMPTY
22026: PPUSH
22027: CALL_OW 1
22031: ST_TO_ADDR
// mc_teleport_exit := Replace ( mc_teleport_exit , base , [ ] ) ;
22032: LD_ADDR_EXP 109
22036: PUSH
22037: LD_EXP 109
22041: PPUSH
22042: LD_VAR 0 4
22046: PPUSH
22047: EMPTY
22048: PPUSH
22049: CALL_OW 1
22053: ST_TO_ADDR
// mc_teleport_exit_set := Replace ( mc_teleport_exit_set , base , [ ] ) ;
22054: LD_ADDR_EXP 110
22058: PUSH
22059: LD_EXP 110
22063: PPUSH
22064: LD_VAR 0 4
22068: PPUSH
22069: EMPTY
22070: PPUSH
22071: CALL_OW 1
22075: ST_TO_ADDR
// mc_deposits_xy := Replace ( mc_deposits_xy , base , [ ] ) ;
22076: LD_ADDR_EXP 111
22080: PUSH
22081: LD_EXP 111
22085: PPUSH
22086: LD_VAR 0 4
22090: PPUSH
22091: EMPTY
22092: PPUSH
22093: CALL_OW 1
22097: ST_TO_ADDR
// mc_deposits_finder := Replace ( mc_deposits_finder , base , [ ] ) ;
22098: LD_ADDR_EXP 112
22102: PUSH
22103: LD_EXP 112
22107: PPUSH
22108: LD_VAR 0 4
22112: PPUSH
22113: EMPTY
22114: PPUSH
22115: CALL_OW 1
22119: ST_TO_ADDR
// mc_allowed_tower_weapons := Replace ( mc_allowed_tower_weapons , base , [ ] ) ;
22120: LD_ADDR_EXP 113
22124: PUSH
22125: LD_EXP 113
22129: PPUSH
22130: LD_VAR 0 4
22134: PPUSH
22135: EMPTY
22136: PPUSH
22137: CALL_OW 1
22141: ST_TO_ADDR
// mc_remote_driver := Replace ( mc_remote_driver , base , [ ] ) ;
22142: LD_ADDR_EXP 114
22146: PUSH
22147: LD_EXP 114
22151: PPUSH
22152: LD_VAR 0 4
22156: PPUSH
22157: EMPTY
22158: PPUSH
22159: CALL_OW 1
22163: ST_TO_ADDR
// mc_class := Replace ( mc_class , base , [ ] ) ;
22164: LD_ADDR_EXP 115
22168: PUSH
22169: LD_EXP 115
22173: PPUSH
22174: LD_VAR 0 4
22178: PPUSH
22179: EMPTY
22180: PPUSH
22181: CALL_OW 1
22185: ST_TO_ADDR
// mc_class_case_use := Replace ( mc_class_case_use , base , 0 ) ;
22186: LD_ADDR_EXP 116
22190: PUSH
22191: LD_EXP 116
22195: PPUSH
22196: LD_VAR 0 4
22200: PPUSH
22201: LD_INT 0
22203: PPUSH
22204: CALL_OW 1
22208: ST_TO_ADDR
// result := base ;
22209: LD_ADDR_VAR 0 3
22213: PUSH
22214: LD_VAR 0 4
22218: ST_TO_ADDR
// end ;
22219: LD_VAR 0 3
22223: RET
// export function MC_Start ( ) ; var i ; begin
22224: LD_INT 0
22226: PPUSH
22227: PPUSH
// for i = 1 to mc_bases do
22228: LD_ADDR_VAR 0 2
22232: PUSH
22233: DOUBLE
22234: LD_INT 1
22236: DEC
22237: ST_TO_ADDR
22238: LD_EXP 74
22242: PUSH
22243: FOR_TO
22244: IFFALSE 23321
// begin mc_bases := Replace ( mc_bases , i , mc_bases [ i ] diff 0 ) ;
22246: LD_ADDR_EXP 74
22250: PUSH
22251: LD_EXP 74
22255: PPUSH
22256: LD_VAR 0 2
22260: PPUSH
22261: LD_EXP 74
22265: PUSH
22266: LD_VAR 0 2
22270: ARRAY
22271: PUSH
22272: LD_INT 0
22274: DIFF
22275: PPUSH
22276: CALL_OW 1
22280: ST_TO_ADDR
// mc_building_need_repair := Replace ( mc_building_need_repair , i , [ ] ) ;
22281: LD_ADDR_EXP 75
22285: PUSH
22286: LD_EXP 75
22290: PPUSH
22291: LD_VAR 0 2
22295: PPUSH
22296: EMPTY
22297: PPUSH
22298: CALL_OW 1
22302: ST_TO_ADDR
// mc_building_repairs := Replace ( mc_building_repairs , i , [ ] ) ;
22303: LD_ADDR_EXP 76
22307: PUSH
22308: LD_EXP 76
22312: PPUSH
22313: LD_VAR 0 2
22317: PPUSH
22318: EMPTY
22319: PPUSH
22320: CALL_OW 1
22324: ST_TO_ADDR
// mc_need_heal := Replace ( mc_need_heal , i , [ ] ) ;
22325: LD_ADDR_EXP 77
22329: PUSH
22330: LD_EXP 77
22334: PPUSH
22335: LD_VAR 0 2
22339: PPUSH
22340: EMPTY
22341: PPUSH
22342: CALL_OW 1
22346: ST_TO_ADDR
// mc_healers := Replace ( mc_healers , i , [ [ ] , [ ] ] ) ;
22347: LD_ADDR_EXP 78
22351: PUSH
22352: LD_EXP 78
22356: PPUSH
22357: LD_VAR 0 2
22361: PPUSH
22362: EMPTY
22363: PUSH
22364: EMPTY
22365: PUSH
22366: EMPTY
22367: LIST
22368: LIST
22369: PPUSH
22370: CALL_OW 1
22374: ST_TO_ADDR
// mc_build_list := Replace ( mc_build_list , i , [ ] ) ;
22375: LD_ADDR_EXP 79
22379: PUSH
22380: LD_EXP 79
22384: PPUSH
22385: LD_VAR 0 2
22389: PPUSH
22390: EMPTY
22391: PPUSH
22392: CALL_OW 1
22396: ST_TO_ADDR
// mc_build_upgrade := Replace ( mc_build_upgrade , i , [ ] ) ;
22397: LD_ADDR_EXP 106
22401: PUSH
22402: LD_EXP 106
22406: PPUSH
22407: LD_VAR 0 2
22411: PPUSH
22412: EMPTY
22413: PPUSH
22414: CALL_OW 1
22418: ST_TO_ADDR
// mc_builders := Replace ( mc_builders , i , [ ] ) ;
22419: LD_ADDR_EXP 80
22423: PUSH
22424: LD_EXP 80
22428: PPUSH
22429: LD_VAR 0 2
22433: PPUSH
22434: EMPTY
22435: PPUSH
22436: CALL_OW 1
22440: ST_TO_ADDR
// mc_construct_list := Replace ( mc_construct_list , i , [ ] ) ;
22441: LD_ADDR_EXP 81
22445: PUSH
22446: LD_EXP 81
22450: PPUSH
22451: LD_VAR 0 2
22455: PPUSH
22456: EMPTY
22457: PPUSH
22458: CALL_OW 1
22462: ST_TO_ADDR
// mc_turret_list := Replace ( mc_turret_list , i , UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_bunker ] , [ f_btype , b_turret ] ] ) ) ;
22463: LD_ADDR_EXP 82
22467: PUSH
22468: LD_EXP 82
22472: PPUSH
22473: LD_VAR 0 2
22477: PPUSH
22478: LD_EXP 74
22482: PUSH
22483: LD_VAR 0 2
22487: ARRAY
22488: PPUSH
22489: LD_INT 2
22491: PUSH
22492: LD_INT 30
22494: PUSH
22495: LD_INT 32
22497: PUSH
22498: EMPTY
22499: LIST
22500: LIST
22501: PUSH
22502: LD_INT 30
22504: PUSH
22505: LD_INT 33
22507: PUSH
22508: EMPTY
22509: LIST
22510: LIST
22511: PUSH
22512: EMPTY
22513: LIST
22514: LIST
22515: LIST
22516: PPUSH
22517: CALL_OW 72
22521: PPUSH
22522: CALL_OW 1
22526: ST_TO_ADDR
// mc_empty_turret_list := Replace ( mc_empty_turret_list , i , UnitFilter ( mc_bases [ i ] , [ [ f_or , [ f_btype , b_bunker ] , [ f_btype , b_breastwork ] ] , [ f_empty ] ] ) ) ;
22527: LD_ADDR_EXP 83
22531: PUSH
22532: LD_EXP 83
22536: PPUSH
22537: LD_VAR 0 2
22541: PPUSH
22542: LD_EXP 74
22546: PUSH
22547: LD_VAR 0 2
22551: ARRAY
22552: PPUSH
22553: LD_INT 2
22555: PUSH
22556: LD_INT 30
22558: PUSH
22559: LD_INT 32
22561: PUSH
22562: EMPTY
22563: LIST
22564: LIST
22565: PUSH
22566: LD_INT 30
22568: PUSH
22569: LD_INT 31
22571: PUSH
22572: EMPTY
22573: LIST
22574: LIST
22575: PUSH
22576: EMPTY
22577: LIST
22578: LIST
22579: LIST
22580: PUSH
22581: LD_INT 58
22583: PUSH
22584: EMPTY
22585: LIST
22586: PUSH
22587: EMPTY
22588: LIST
22589: LIST
22590: PPUSH
22591: CALL_OW 72
22595: PPUSH
22596: CALL_OW 1
22600: ST_TO_ADDR
// mc_busy_turret_list := Replace ( mc_busy_turret_list , i , [ ] ) ;
22601: LD_ADDR_EXP 84
22605: PUSH
22606: LD_EXP 84
22610: PPUSH
22611: LD_VAR 0 2
22615: PPUSH
22616: EMPTY
22617: PPUSH
22618: CALL_OW 1
22622: ST_TO_ADDR
// mc_miners := Replace ( mc_miners , i , [ ] ) ;
22623: LD_ADDR_EXP 88
22627: PUSH
22628: LD_EXP 88
22632: PPUSH
22633: LD_VAR 0 2
22637: PPUSH
22638: EMPTY
22639: PPUSH
22640: CALL_OW 1
22644: ST_TO_ADDR
// mc_mines := Replace ( mc_mines , i , [ ] ) ;
22645: LD_ADDR_EXP 87
22649: PUSH
22650: LD_EXP 87
22654: PPUSH
22655: LD_VAR 0 2
22659: PPUSH
22660: EMPTY
22661: PPUSH
22662: CALL_OW 1
22666: ST_TO_ADDR
// mc_minefields := Replace ( mc_minefields , i , [ ] ) ;
22667: LD_ADDR_EXP 89
22671: PUSH
22672: LD_EXP 89
22676: PPUSH
22677: LD_VAR 0 2
22681: PPUSH
22682: EMPTY
22683: PPUSH
22684: CALL_OW 1
22688: ST_TO_ADDR
// mc_crates := Replace ( mc_crates , i , [ ] ) ;
22689: LD_ADDR_EXP 90
22693: PUSH
22694: LD_EXP 90
22698: PPUSH
22699: LD_VAR 0 2
22703: PPUSH
22704: EMPTY
22705: PPUSH
22706: CALL_OW 1
22710: ST_TO_ADDR
// mc_crates_collector := Replace ( mc_crates_collector , i , [ ] ) ;
22711: LD_ADDR_EXP 91
22715: PUSH
22716: LD_EXP 91
22720: PPUSH
22721: LD_VAR 0 2
22725: PPUSH
22726: EMPTY
22727: PPUSH
22728: CALL_OW 1
22732: ST_TO_ADDR
// mc_crates_area := Replace ( mc_crates_area , i , [ ] ) ;
22733: LD_ADDR_EXP 92
22737: PUSH
22738: LD_EXP 92
22742: PPUSH
22743: LD_VAR 0 2
22747: PPUSH
22748: EMPTY
22749: PPUSH
22750: CALL_OW 1
22754: ST_TO_ADDR
// mc_vehicles := Replace ( mc_vehicles , i , [ ] ) ;
22755: LD_ADDR_EXP 93
22759: PUSH
22760: LD_EXP 93
22764: PPUSH
22765: LD_VAR 0 2
22769: PPUSH
22770: EMPTY
22771: PPUSH
22772: CALL_OW 1
22776: ST_TO_ADDR
// mc_attack := Replace ( mc_attack , i , [ ] ) ;
22777: LD_ADDR_EXP 94
22781: PUSH
22782: LD_EXP 94
22786: PPUSH
22787: LD_VAR 0 2
22791: PPUSH
22792: EMPTY
22793: PPUSH
22794: CALL_OW 1
22798: ST_TO_ADDR
// mc_produce := Replace ( mc_produce , i , [ ] ) ;
22799: LD_ADDR_EXP 95
22803: PUSH
22804: LD_EXP 95
22808: PPUSH
22809: LD_VAR 0 2
22813: PPUSH
22814: EMPTY
22815: PPUSH
22816: CALL_OW 1
22820: ST_TO_ADDR
// mc_defender := Replace ( mc_defender , i , [ ] ) ;
22821: LD_ADDR_EXP 96
22825: PUSH
22826: LD_EXP 96
22830: PPUSH
22831: LD_VAR 0 2
22835: PPUSH
22836: EMPTY
22837: PPUSH
22838: CALL_OW 1
22842: ST_TO_ADDR
// mc_defender_limit := Replace ( mc_defender_limit , i , 0 ) ;
22843: LD_ADDR_EXP 85
22847: PUSH
22848: LD_EXP 85
22852: PPUSH
22853: LD_VAR 0 2
22857: PPUSH
22858: LD_INT 0
22860: PPUSH
22861: CALL_OW 1
22865: ST_TO_ADDR
// mc_parking := Replace ( mc_parking , i , 0 ) ;
22866: LD_ADDR_EXP 98
22870: PUSH
22871: LD_EXP 98
22875: PPUSH
22876: LD_VAR 0 2
22880: PPUSH
22881: LD_INT 0
22883: PPUSH
22884: CALL_OW 1
22888: ST_TO_ADDR
// mc_repair_vehicle := Replace ( mc_repair_vehicle , i , [ ] ) ;
22889: LD_ADDR_EXP 86
22893: PUSH
22894: LD_EXP 86
22898: PPUSH
22899: LD_VAR 0 2
22903: PPUSH
22904: EMPTY
22905: PPUSH
22906: CALL_OW 1
22910: ST_TO_ADDR
// mc_scan := Replace ( mc_scan , i , 0 ) ;
22911: LD_ADDR_EXP 97
22915: PUSH
22916: LD_EXP 97
22920: PPUSH
22921: LD_VAR 0 2
22925: PPUSH
22926: LD_INT 0
22928: PPUSH
22929: CALL_OW 1
22933: ST_TO_ADDR
// mc_scan_area := Replace ( mc_scan_area , i , [ ] ) ;
22934: LD_ADDR_EXP 99
22938: PUSH
22939: LD_EXP 99
22943: PPUSH
22944: LD_VAR 0 2
22948: PPUSH
22949: EMPTY
22950: PPUSH
22951: CALL_OW 1
22955: ST_TO_ADDR
// mc_can_tame := Replace ( mc_can_tame , i , 0 ) ;
22956: LD_ADDR_EXP 102
22960: PUSH
22961: LD_EXP 102
22965: PPUSH
22966: LD_VAR 0 2
22970: PPUSH
22971: LD_INT 0
22973: PPUSH
22974: CALL_OW 1
22978: ST_TO_ADDR
// mc_ape := Replace ( mc_ape , i , [ ] ) ;
22979: LD_ADDR_EXP 103
22983: PUSH
22984: LD_EXP 103
22988: PPUSH
22989: LD_VAR 0 2
22993: PPUSH
22994: EMPTY
22995: PPUSH
22996: CALL_OW 1
23000: ST_TO_ADDR
// mc_ape_in_lab := Replace ( mc_ape_in_lab , i , [ ] ) ;
23001: LD_ADDR_EXP 104
23005: PUSH
23006: LD_EXP 104
23010: PPUSH
23011: LD_VAR 0 2
23015: PPUSH
23016: EMPTY
23017: PPUSH
23018: CALL_OW 1
23022: ST_TO_ADDR
// mc_taming := Replace ( mc_taming , i , [ ] ) ;
23023: LD_ADDR_EXP 105
23027: PUSH
23028: LD_EXP 105
23032: PPUSH
23033: LD_VAR 0 2
23037: PPUSH
23038: EMPTY
23039: PPUSH
23040: CALL_OW 1
23044: ST_TO_ADDR
// mc_lab := Replace ( mc_lab , i , UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_lab ] , [ f_btype , b_lab_half ] , [ f_btype , b_lab_full ] ] ) ) ;
23045: LD_ADDR_EXP 107
23049: PUSH
23050: LD_EXP 107
23054: PPUSH
23055: LD_VAR 0 2
23059: PPUSH
23060: LD_EXP 74
23064: PUSH
23065: LD_VAR 0 2
23069: ARRAY
23070: PPUSH
23071: LD_INT 2
23073: PUSH
23074: LD_INT 30
23076: PUSH
23077: LD_INT 6
23079: PUSH
23080: EMPTY
23081: LIST
23082: LIST
23083: PUSH
23084: LD_INT 30
23086: PUSH
23087: LD_INT 7
23089: PUSH
23090: EMPTY
23091: LIST
23092: LIST
23093: PUSH
23094: LD_INT 30
23096: PUSH
23097: LD_INT 8
23099: PUSH
23100: EMPTY
23101: LIST
23102: LIST
23103: PUSH
23104: EMPTY
23105: LIST
23106: LIST
23107: LIST
23108: LIST
23109: PPUSH
23110: CALL_OW 72
23114: PPUSH
23115: CALL_OW 1
23119: ST_TO_ADDR
// mc_lab_upgrade := Replace ( mc_lab_upgrade , i , [ ] ) ;
23120: LD_ADDR_EXP 108
23124: PUSH
23125: LD_EXP 108
23129: PPUSH
23130: LD_VAR 0 2
23134: PPUSH
23135: EMPTY
23136: PPUSH
23137: CALL_OW 1
23141: ST_TO_ADDR
// mc_teleport_exit := Replace ( mc_teleport_exit , i , [ ] ) ;
23142: LD_ADDR_EXP 109
23146: PUSH
23147: LD_EXP 109
23151: PPUSH
23152: LD_VAR 0 2
23156: PPUSH
23157: EMPTY
23158: PPUSH
23159: CALL_OW 1
23163: ST_TO_ADDR
// mc_teleport_exit_set := Replace ( mc_teleport_exit_set , i , [ ] ) ;
23164: LD_ADDR_EXP 110
23168: PUSH
23169: LD_EXP 110
23173: PPUSH
23174: LD_VAR 0 2
23178: PPUSH
23179: EMPTY
23180: PPUSH
23181: CALL_OW 1
23185: ST_TO_ADDR
// mc_deposits_xy := Replace ( mc_deposits_xy , i , [ ] ) ;
23186: LD_ADDR_EXP 111
23190: PUSH
23191: LD_EXP 111
23195: PPUSH
23196: LD_VAR 0 2
23200: PPUSH
23201: EMPTY
23202: PPUSH
23203: CALL_OW 1
23207: ST_TO_ADDR
// mc_deposits_finder := Replace ( mc_deposits_finder , i , [ ] ) ;
23208: LD_ADDR_EXP 112
23212: PUSH
23213: LD_EXP 112
23217: PPUSH
23218: LD_VAR 0 2
23222: PPUSH
23223: EMPTY
23224: PPUSH
23225: CALL_OW 1
23229: ST_TO_ADDR
// mc_allowed_tower_weapons := Replace ( mc_allowed_tower_weapons , i , [ ] ) ;
23230: LD_ADDR_EXP 113
23234: PUSH
23235: LD_EXP 113
23239: PPUSH
23240: LD_VAR 0 2
23244: PPUSH
23245: EMPTY
23246: PPUSH
23247: CALL_OW 1
23251: ST_TO_ADDR
// mc_remote_driver := Replace ( mc_remote_driver , i , [ ] ) ;
23252: LD_ADDR_EXP 114
23256: PUSH
23257: LD_EXP 114
23261: PPUSH
23262: LD_VAR 0 2
23266: PPUSH
23267: EMPTY
23268: PPUSH
23269: CALL_OW 1
23273: ST_TO_ADDR
// mc_class := Replace ( mc_class , i , [ ] ) ;
23274: LD_ADDR_EXP 115
23278: PUSH
23279: LD_EXP 115
23283: PPUSH
23284: LD_VAR 0 2
23288: PPUSH
23289: EMPTY
23290: PPUSH
23291: CALL_OW 1
23295: ST_TO_ADDR
// mc_class_case_use := Replace ( mc_class_case_use , i , 0 ) ;
23296: LD_ADDR_EXP 116
23300: PUSH
23301: LD_EXP 116
23305: PPUSH
23306: LD_VAR 0 2
23310: PPUSH
23311: LD_INT 0
23313: PPUSH
23314: CALL_OW 1
23318: ST_TO_ADDR
// end ;
23319: GO 22243
23321: POP
23322: POP
// MC_InitSides ( ) ;
23323: CALL 23609 0 0
// MC_InitResearch ( ) ;
23327: CALL 23348 0 0
// CustomInitMacro ( ) ;
23331: CALL 173 0 0
// skirmish := true ;
23335: LD_ADDR_EXP 72
23339: PUSH
23340: LD_INT 1
23342: ST_TO_ADDR
// end ;
23343: LD_VAR 0 1
23347: RET
// export function MC_InitResearch ( ) ; var i , j , nation , tmp , un ; begin
23348: LD_INT 0
23350: PPUSH
23351: PPUSH
23352: PPUSH
23353: PPUSH
23354: PPUSH
23355: PPUSH
// if not mc_bases then
23356: LD_EXP 74
23360: NOT
23361: IFFALSE 23365
// exit ;
23363: GO 23604
// for i = 1 to 8 do
23365: LD_ADDR_VAR 0 2
23369: PUSH
23370: DOUBLE
23371: LD_INT 1
23373: DEC
23374: ST_TO_ADDR
23375: LD_INT 8
23377: PUSH
23378: FOR_TO
23379: IFFALSE 23405
// mc_tech := Replace ( mc_tech , i , [ ] ) ;
23381: LD_ADDR_EXP 101
23385: PUSH
23386: LD_EXP 101
23390: PPUSH
23391: LD_VAR 0 2
23395: PPUSH
23396: EMPTY
23397: PPUSH
23398: CALL_OW 1
23402: ST_TO_ADDR
23403: GO 23378
23405: POP
23406: POP
// tmp := [ ] ;
23407: LD_ADDR_VAR 0 5
23411: PUSH
23412: EMPTY
23413: ST_TO_ADDR
// for i = 1 to mc_sides do
23414: LD_ADDR_VAR 0 2
23418: PUSH
23419: DOUBLE
23420: LD_INT 1
23422: DEC
23423: ST_TO_ADDR
23424: LD_EXP 100
23428: PUSH
23429: FOR_TO
23430: IFFALSE 23488
// if not mc_sides [ i ] in tmp then
23432: LD_EXP 100
23436: PUSH
23437: LD_VAR 0 2
23441: ARRAY
23442: PUSH
23443: LD_VAR 0 5
23447: IN
23448: NOT
23449: IFFALSE 23486
// tmp := Insert ( tmp , tmp + 1 , mc_sides [ i ] ) ;
23451: LD_ADDR_VAR 0 5
23455: PUSH
23456: LD_VAR 0 5
23460: PPUSH
23461: LD_VAR 0 5
23465: PUSH
23466: LD_INT 1
23468: PLUS
23469: PPUSH
23470: LD_EXP 100
23474: PUSH
23475: LD_VAR 0 2
23479: ARRAY
23480: PPUSH
23481: CALL_OW 2
23485: ST_TO_ADDR
23486: GO 23429
23488: POP
23489: POP
// if not tmp then
23490: LD_VAR 0 5
23494: NOT
23495: IFFALSE 23499
// exit ;
23497: GO 23604
// for j in tmp do
23499: LD_ADDR_VAR 0 3
23503: PUSH
23504: LD_VAR 0 5
23508: PUSH
23509: FOR_IN
23510: IFFALSE 23602
// begin un := FilterAllUnits ( [ f_side , j ] ) ;
23512: LD_ADDR_VAR 0 6
23516: PUSH
23517: LD_INT 22
23519: PUSH
23520: LD_VAR 0 3
23524: PUSH
23525: EMPTY
23526: LIST
23527: LIST
23528: PPUSH
23529: CALL_OW 69
23533: ST_TO_ADDR
// if not un then
23534: LD_VAR 0 6
23538: NOT
23539: IFFALSE 23543
// continue ;
23541: GO 23509
// nation := GetNation ( un [ 1 ] ) ;
23543: LD_ADDR_VAR 0 4
23547: PUSH
23548: LD_VAR 0 6
23552: PUSH
23553: LD_INT 1
23555: ARRAY
23556: PPUSH
23557: CALL_OW 248
23561: ST_TO_ADDR
// mc_tech := Replace ( mc_tech , j , GetTechNation ( j , nation , state_enabled ) ) ;
23562: LD_ADDR_EXP 101
23566: PUSH
23567: LD_EXP 101
23571: PPUSH
23572: LD_VAR 0 3
23576: PPUSH
23577: LD_VAR 0 3
23581: PPUSH
23582: LD_VAR 0 4
23586: PPUSH
23587: LD_INT 1
23589: PPUSH
23590: CALL 50318 0 3
23594: PPUSH
23595: CALL_OW 1
23599: ST_TO_ADDR
// end ;
23600: GO 23509
23602: POP
23603: POP
// end ;
23604: LD_VAR 0 1
23608: RET
// export function MC_InitSides ( ) ; var i ; begin
23609: LD_INT 0
23611: PPUSH
23612: PPUSH
// if not mc_bases then
23613: LD_EXP 74
23617: NOT
23618: IFFALSE 23622
// exit ;
23620: GO 23696
// for i = 1 to mc_bases do
23622: LD_ADDR_VAR 0 2
23626: PUSH
23627: DOUBLE
23628: LD_INT 1
23630: DEC
23631: ST_TO_ADDR
23632: LD_EXP 74
23636: PUSH
23637: FOR_TO
23638: IFFALSE 23694
// if mc_bases [ i ] then
23640: LD_EXP 74
23644: PUSH
23645: LD_VAR 0 2
23649: ARRAY
23650: IFFALSE 23692
// mc_sides := Replace ( mc_sides , i , GetSide ( mc_bases [ i ] [ 1 ] ) ) ;
23652: LD_ADDR_EXP 100
23656: PUSH
23657: LD_EXP 100
23661: PPUSH
23662: LD_VAR 0 2
23666: PPUSH
23667: LD_EXP 74
23671: PUSH
23672: LD_VAR 0 2
23676: ARRAY
23677: PUSH
23678: LD_INT 1
23680: ARRAY
23681: PPUSH
23682: CALL_OW 255
23686: PPUSH
23687: CALL_OW 1
23691: ST_TO_ADDR
23692: GO 23637
23694: POP
23695: POP
// end ;
23696: LD_VAR 0 1
23700: RET
// every 0 0$01 trigger skirmish do
23701: LD_EXP 72
23705: IFFALSE 23859
23707: GO 23709
23709: DISABLE
// begin enable ;
23710: ENABLE
// MC_CheckBuildings ( ) ;
23711: CALL 28357 0 0
// MC_CheckPeopleLife ( ) ;
23715: CALL 28482 0 0
// RaiseSailEvent ( 100 ) ;
23719: LD_INT 100
23721: PPUSH
23722: CALL_OW 427
// RaiseSailEvent ( 103 ) ;
23726: LD_INT 103
23728: PPUSH
23729: CALL_OW 427
// RaiseSailEvent ( 104 ) ;
23733: LD_INT 104
23735: PPUSH
23736: CALL_OW 427
// RaiseSailEvent ( 105 ) ;
23740: LD_INT 105
23742: PPUSH
23743: CALL_OW 427
// RaiseSailEvent ( 106 ) ;
23747: LD_INT 106
23749: PPUSH
23750: CALL_OW 427
// RaiseSailEvent ( 107 ) ;
23754: LD_INT 107
23756: PPUSH
23757: CALL_OW 427
// RaiseSailEvent ( 108 ) ;
23761: LD_INT 108
23763: PPUSH
23764: CALL_OW 427
// RaiseSailEvent ( 109 ) ;
23768: LD_INT 109
23770: PPUSH
23771: CALL_OW 427
// RaiseSailEvent ( 110 ) ;
23775: LD_INT 110
23777: PPUSH
23778: CALL_OW 427
// RaiseSailEvent ( 111 ) ;
23782: LD_INT 111
23784: PPUSH
23785: CALL_OW 427
// RaiseSailEvent ( 112 ) ;
23789: LD_INT 112
23791: PPUSH
23792: CALL_OW 427
// RaiseSailEvent ( 113 ) ;
23796: LD_INT 113
23798: PPUSH
23799: CALL_OW 427
// RaiseSailEvent ( 120 ) ;
23803: LD_INT 120
23805: PPUSH
23806: CALL_OW 427
// RaiseSailEvent ( 121 ) ;
23810: LD_INT 121
23812: PPUSH
23813: CALL_OW 427
// RaiseSailEvent ( 122 ) ;
23817: LD_INT 122
23819: PPUSH
23820: CALL_OW 427
// RaiseSailEvent ( 123 ) ;
23824: LD_INT 123
23826: PPUSH
23827: CALL_OW 427
// RaiseSailEvent ( 124 ) ;
23831: LD_INT 124
23833: PPUSH
23834: CALL_OW 427
// RaiseSailEvent ( 125 ) ;
23838: LD_INT 125
23840: PPUSH
23841: CALL_OW 427
// RaiseSailEvent ( 126 ) ;
23845: LD_INT 126
23847: PPUSH
23848: CALL_OW 427
// RaiseSailEvent ( 200 ) ;
23852: LD_INT 200
23854: PPUSH
23855: CALL_OW 427
// end ;
23859: END
// on SailEvent ( event ) do begin if event < 100 then
23860: LD_VAR 0 1
23864: PUSH
23865: LD_INT 100
23867: LESS
23868: IFFALSE 23879
// CustomEvent ( event ) ;
23870: LD_VAR 0 1
23874: PPUSH
23875: CALL 10216 0 1
// if event = 100 then
23879: LD_VAR 0 1
23883: PUSH
23884: LD_INT 100
23886: EQUAL
23887: IFFALSE 23893
// MC_ClassManager ( ) ;
23889: CALL 24285 0 0
// if event = 101 then
23893: LD_VAR 0 1
23897: PUSH
23898: LD_INT 101
23900: EQUAL
23901: IFFALSE 23907
// MC_RepairBuildings ( ) ;
23903: CALL 29078 0 0
// if event = 102 then
23907: LD_VAR 0 1
23911: PUSH
23912: LD_INT 102
23914: EQUAL
23915: IFFALSE 23921
// MC_Heal ( ) ;
23917: CALL 29810 0 0
// if event = 103 then
23921: LD_VAR 0 1
23925: PUSH
23926: LD_INT 103
23928: EQUAL
23929: IFFALSE 23935
// MC_Build ( ) ;
23931: CALL 30232 0 0
// if event = 104 then
23935: LD_VAR 0 1
23939: PUSH
23940: LD_INT 104
23942: EQUAL
23943: IFFALSE 23949
// MC_TurretWeapon ( ) ;
23945: CALL 31845 0 0
// if event = 105 then
23949: LD_VAR 0 1
23953: PUSH
23954: LD_INT 105
23956: EQUAL
23957: IFFALSE 23963
// MC_BuildUpgrade ( ) ;
23959: CALL 31396 0 0
// if event = 106 then
23963: LD_VAR 0 1
23967: PUSH
23968: LD_INT 106
23970: EQUAL
23971: IFFALSE 23977
// MC_PlantMines ( ) ;
23973: CALL 32275 0 0
// if event = 107 then
23977: LD_VAR 0 1
23981: PUSH
23982: LD_INT 107
23984: EQUAL
23985: IFFALSE 23991
// MC_CollectCrates ( ) ;
23987: CALL 33309 0 0
// if event = 108 then
23991: LD_VAR 0 1
23995: PUSH
23996: LD_INT 108
23998: EQUAL
23999: IFFALSE 24005
// MC_LinkRemoteControl ( ) ;
24001: CALL 35085 0 0
// if event = 109 then
24005: LD_VAR 0 1
24009: PUSH
24010: LD_INT 109
24012: EQUAL
24013: IFFALSE 24019
// MC_ProduceVehicle ( ) ;
24015: CALL 35266 0 0
// if event = 110 then
24019: LD_VAR 0 1
24023: PUSH
24024: LD_INT 110
24026: EQUAL
24027: IFFALSE 24033
// MC_SendAttack ( ) ;
24029: CALL 35732 0 0
// if event = 111 then
24033: LD_VAR 0 1
24037: PUSH
24038: LD_INT 111
24040: EQUAL
24041: IFFALSE 24047
// MC_Defend ( ) ;
24043: CALL 35840 0 0
// if event = 112 then
24047: LD_VAR 0 1
24051: PUSH
24052: LD_INT 112
24054: EQUAL
24055: IFFALSE 24061
// MC_Research ( ) ;
24057: CALL 36445 0 0
// if event = 113 then
24061: LD_VAR 0 1
24065: PUSH
24066: LD_INT 113
24068: EQUAL
24069: IFFALSE 24075
// MC_MinesTrigger ( ) ;
24071: CALL 37559 0 0
// if event = 120 then
24075: LD_VAR 0 1
24079: PUSH
24080: LD_INT 120
24082: EQUAL
24083: IFFALSE 24089
// MC_RepairVehicle ( ) ;
24085: CALL 37658 0 0
// if event = 121 then
24089: LD_VAR 0 1
24093: PUSH
24094: LD_INT 121
24096: EQUAL
24097: IFFALSE 24103
// MC_TameApe ( ) ;
24099: CALL 38388 0 0
// if event = 122 then
24103: LD_VAR 0 1
24107: PUSH
24108: LD_INT 122
24110: EQUAL
24111: IFFALSE 24117
// MC_ChangeApeClass ( ) ;
24113: CALL 39217 0 0
// if event = 123 then
24117: LD_VAR 0 1
24121: PUSH
24122: LD_INT 123
24124: EQUAL
24125: IFFALSE 24131
// MC_Bazooka ( ) ;
24127: CALL 39867 0 0
// if event = 124 then
24131: LD_VAR 0 1
24135: PUSH
24136: LD_INT 124
24138: EQUAL
24139: IFFALSE 24145
// MC_TeleportExit ( ) ;
24141: CALL 40065 0 0
// if event = 125 then
24145: LD_VAR 0 1
24149: PUSH
24150: LD_INT 125
24152: EQUAL
24153: IFFALSE 24159
// MC_Deposits ( ) ;
24155: CALL 40712 0 0
// if event = 126 then
24159: LD_VAR 0 1
24163: PUSH
24164: LD_INT 126
24166: EQUAL
24167: IFFALSE 24173
// MC_RemoteDriver ( ) ;
24169: CALL 41337 0 0
// if event = 200 then
24173: LD_VAR 0 1
24177: PUSH
24178: LD_INT 200
24180: EQUAL
24181: IFFALSE 24187
// MC_Idle ( ) ;
24183: CALL 43286 0 0
// end ;
24187: PPOPN 1
24189: END
// export function MC_Reset ( base , tag ) ; var i ; begin
24190: LD_INT 0
24192: PPUSH
24193: PPUSH
// if not mc_bases [ base ] or not tag then
24194: LD_EXP 74
24198: PUSH
24199: LD_VAR 0 1
24203: ARRAY
24204: NOT
24205: PUSH
24206: LD_VAR 0 2
24210: NOT
24211: OR
24212: IFFALSE 24216
// exit ;
24214: GO 24280
// for i in mc_bases [ base ] union mc_ape [ base ] do
24216: LD_ADDR_VAR 0 4
24220: PUSH
24221: LD_EXP 74
24225: PUSH
24226: LD_VAR 0 1
24230: ARRAY
24231: PUSH
24232: LD_EXP 103
24236: PUSH
24237: LD_VAR 0 1
24241: ARRAY
24242: UNION
24243: PUSH
24244: FOR_IN
24245: IFFALSE 24278
// if GetTag ( i ) = tag then
24247: LD_VAR 0 4
24251: PPUSH
24252: CALL_OW 110
24256: PUSH
24257: LD_VAR 0 2
24261: EQUAL
24262: IFFALSE 24276
// SetTag ( i , 0 ) ;
24264: LD_VAR 0 4
24268: PPUSH
24269: LD_INT 0
24271: PPUSH
24272: CALL_OW 109
24276: GO 24244
24278: POP
24279: POP
// end ;
24280: LD_VAR 0 3
24284: RET
// export function MC_ClassManager ( ) ; var i , j , tmp , p , b , e , k ; begin
24285: LD_INT 0
24287: PPUSH
24288: PPUSH
24289: PPUSH
24290: PPUSH
24291: PPUSH
24292: PPUSH
24293: PPUSH
24294: PPUSH
// if not mc_bases then
24295: LD_EXP 74
24299: NOT
24300: IFFALSE 24304
// exit ;
24302: GO 24762
// for i = 1 to mc_bases do
24304: LD_ADDR_VAR 0 2
24308: PUSH
24309: DOUBLE
24310: LD_INT 1
24312: DEC
24313: ST_TO_ADDR
24314: LD_EXP 74
24318: PUSH
24319: FOR_TO
24320: IFFALSE 24760
// begin tmp := MC_ClassCheckReq ( i ) ;
24322: LD_ADDR_VAR 0 4
24326: PUSH
24327: LD_VAR 0 2
24331: PPUSH
24332: CALL 24767 0 1
24336: ST_TO_ADDR
// mc_class := Replace ( mc_class , i , tmp ) ;
24337: LD_ADDR_EXP 115
24341: PUSH
24342: LD_EXP 115
24346: PPUSH
24347: LD_VAR 0 2
24351: PPUSH
24352: LD_VAR 0 4
24356: PPUSH
24357: CALL_OW 1
24361: ST_TO_ADDR
// if not tmp then
24362: LD_VAR 0 4
24366: NOT
24367: IFFALSE 24371
// continue ;
24369: GO 24319
// b := [ UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_armoury ] , [ f_btype , b_barracks ] ] ) , UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) , UnitFilter ( mc_bases [ i ] , [ f_btype , b_factory ] ) , UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_lab ] , [ f_btype , b_lab_half ] , [ f_btype , b_lab_full ] ] ) ] ;
24371: LD_ADDR_VAR 0 6
24375: PUSH
24376: LD_EXP 74
24380: PUSH
24381: LD_VAR 0 2
24385: ARRAY
24386: PPUSH
24387: LD_INT 2
24389: PUSH
24390: LD_INT 30
24392: PUSH
24393: LD_INT 4
24395: PUSH
24396: EMPTY
24397: LIST
24398: LIST
24399: PUSH
24400: LD_INT 30
24402: PUSH
24403: LD_INT 5
24405: PUSH
24406: EMPTY
24407: LIST
24408: LIST
24409: PUSH
24410: EMPTY
24411: LIST
24412: LIST
24413: LIST
24414: PPUSH
24415: CALL_OW 72
24419: PUSH
24420: LD_EXP 74
24424: PUSH
24425: LD_VAR 0 2
24429: ARRAY
24430: PPUSH
24431: LD_INT 2
24433: PUSH
24434: LD_INT 30
24436: PUSH
24437: LD_INT 0
24439: PUSH
24440: EMPTY
24441: LIST
24442: LIST
24443: PUSH
24444: LD_INT 30
24446: PUSH
24447: LD_INT 1
24449: PUSH
24450: EMPTY
24451: LIST
24452: LIST
24453: PUSH
24454: EMPTY
24455: LIST
24456: LIST
24457: LIST
24458: PPUSH
24459: CALL_OW 72
24463: PUSH
24464: LD_EXP 74
24468: PUSH
24469: LD_VAR 0 2
24473: ARRAY
24474: PPUSH
24475: LD_INT 30
24477: PUSH
24478: LD_INT 3
24480: PUSH
24481: EMPTY
24482: LIST
24483: LIST
24484: PPUSH
24485: CALL_OW 72
24489: PUSH
24490: LD_EXP 74
24494: PUSH
24495: LD_VAR 0 2
24499: ARRAY
24500: PPUSH
24501: LD_INT 2
24503: PUSH
24504: LD_INT 30
24506: PUSH
24507: LD_INT 6
24509: PUSH
24510: EMPTY
24511: LIST
24512: LIST
24513: PUSH
24514: LD_INT 30
24516: PUSH
24517: LD_INT 7
24519: PUSH
24520: EMPTY
24521: LIST
24522: LIST
24523: PUSH
24524: LD_INT 30
24526: PUSH
24527: LD_INT 8
24529: PUSH
24530: EMPTY
24531: LIST
24532: LIST
24533: PUSH
24534: EMPTY
24535: LIST
24536: LIST
24537: LIST
24538: LIST
24539: PPUSH
24540: CALL_OW 72
24544: PUSH
24545: EMPTY
24546: LIST
24547: LIST
24548: LIST
24549: LIST
24550: ST_TO_ADDR
// for j = 1 to 4 do
24551: LD_ADDR_VAR 0 3
24555: PUSH
24556: DOUBLE
24557: LD_INT 1
24559: DEC
24560: ST_TO_ADDR
24561: LD_INT 4
24563: PUSH
24564: FOR_TO
24565: IFFALSE 24756
// begin if not tmp [ j ] then
24567: LD_VAR 0 4
24571: PUSH
24572: LD_VAR 0 3
24576: ARRAY
24577: NOT
24578: IFFALSE 24582
// continue ;
24580: GO 24564
// for p in tmp [ j ] do
24582: LD_ADDR_VAR 0 5
24586: PUSH
24587: LD_VAR 0 4
24591: PUSH
24592: LD_VAR 0 3
24596: ARRAY
24597: PUSH
24598: FOR_IN
24599: IFFALSE 24752
// begin if not b [ j ] then
24601: LD_VAR 0 6
24605: PUSH
24606: LD_VAR 0 3
24610: ARRAY
24611: NOT
24612: IFFALSE 24616
// break ;
24614: GO 24752
// e := 0 ;
24616: LD_ADDR_VAR 0 7
24620: PUSH
24621: LD_INT 0
24623: ST_TO_ADDR
// for k in b [ j ] do
24624: LD_ADDR_VAR 0 8
24628: PUSH
24629: LD_VAR 0 6
24633: PUSH
24634: LD_VAR 0 3
24638: ARRAY
24639: PUSH
24640: FOR_IN
24641: IFFALSE 24668
// if IsNotFull ( k ) then
24643: LD_VAR 0 8
24647: PPUSH
24648: CALL 54669 0 1
24652: IFFALSE 24666
// begin e := k ;
24654: LD_ADDR_VAR 0 7
24658: PUSH
24659: LD_VAR 0 8
24663: ST_TO_ADDR
// break ;
24664: GO 24668
// end ;
24666: GO 24640
24668: POP
24669: POP
// if e and not UnitGoingToBuilding ( p , e ) then
24670: LD_VAR 0 7
24674: PUSH
24675: LD_VAR 0 5
24679: PPUSH
24680: LD_VAR 0 7
24684: PPUSH
24685: CALL 91788 0 2
24689: NOT
24690: AND
24691: IFFALSE 24750
// begin if IsInUnit ( p ) then
24693: LD_VAR 0 5
24697: PPUSH
24698: CALL_OW 310
24702: IFFALSE 24713
// ComExitBuilding ( p ) ;
24704: LD_VAR 0 5
24708: PPUSH
24709: CALL_OW 122
// ComEnterUnit ( p , e ) ;
24713: LD_VAR 0 5
24717: PPUSH
24718: LD_VAR 0 7
24722: PPUSH
24723: CALL_OW 120
// AddComChangeProfession ( p , j ) ;
24727: LD_VAR 0 5
24731: PPUSH
24732: LD_VAR 0 3
24736: PPUSH
24737: CALL_OW 183
// AddComExitBuilding ( p ) ;
24741: LD_VAR 0 5
24745: PPUSH
24746: CALL_OW 182
// end ; end ;
24750: GO 24598
24752: POP
24753: POP
// end ;
24754: GO 24564
24756: POP
24757: POP
// end ;
24758: GO 24319
24760: POP
24761: POP
// end ;
24762: LD_VAR 0 1
24766: RET
// export function MC_ClassCheckReq ( base ) ; var i , tmp , sol , eng , mech , sci , sort , j , p , b , bcount ; begin
24767: LD_INT 0
24769: PPUSH
24770: PPUSH
24771: PPUSH
24772: PPUSH
24773: PPUSH
24774: PPUSH
24775: PPUSH
24776: PPUSH
24777: PPUSH
24778: PPUSH
24779: PPUSH
24780: PPUSH
// if not base or not mc_bases [ base ] or not UnitFilter ( mc_bases [ base ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) then
24781: LD_VAR 0 1
24785: NOT
24786: PUSH
24787: LD_EXP 74
24791: PUSH
24792: LD_VAR 0 1
24796: ARRAY
24797: NOT
24798: OR
24799: PUSH
24800: LD_EXP 74
24804: PUSH
24805: LD_VAR 0 1
24809: ARRAY
24810: PPUSH
24811: LD_INT 2
24813: PUSH
24814: LD_INT 30
24816: PUSH
24817: LD_INT 0
24819: PUSH
24820: EMPTY
24821: LIST
24822: LIST
24823: PUSH
24824: LD_INT 30
24826: PUSH
24827: LD_INT 1
24829: PUSH
24830: EMPTY
24831: LIST
24832: LIST
24833: PUSH
24834: EMPTY
24835: LIST
24836: LIST
24837: LIST
24838: PPUSH
24839: CALL_OW 72
24843: NOT
24844: OR
24845: IFFALSE 24849
// exit ;
24847: GO 28352
// tmp := UnitFilter ( mc_bases [ base ] , [ f_or , [ f_class , 1 ] , [ f_class , 2 ] , [ f_class , 3 ] , [ f_class , 4 ] , [ f_class , 5 ] , [ f_class , 8 ] , [ f_class , 9 ] ] ) ;
24849: LD_ADDR_VAR 0 4
24853: PUSH
24854: LD_EXP 74
24858: PUSH
24859: LD_VAR 0 1
24863: ARRAY
24864: PPUSH
24865: LD_INT 2
24867: PUSH
24868: LD_INT 25
24870: PUSH
24871: LD_INT 1
24873: PUSH
24874: EMPTY
24875: LIST
24876: LIST
24877: PUSH
24878: LD_INT 25
24880: PUSH
24881: LD_INT 2
24883: PUSH
24884: EMPTY
24885: LIST
24886: LIST
24887: PUSH
24888: LD_INT 25
24890: PUSH
24891: LD_INT 3
24893: PUSH
24894: EMPTY
24895: LIST
24896: LIST
24897: PUSH
24898: LD_INT 25
24900: PUSH
24901: LD_INT 4
24903: PUSH
24904: EMPTY
24905: LIST
24906: LIST
24907: PUSH
24908: LD_INT 25
24910: PUSH
24911: LD_INT 5
24913: PUSH
24914: EMPTY
24915: LIST
24916: LIST
24917: PUSH
24918: LD_INT 25
24920: PUSH
24921: LD_INT 8
24923: PUSH
24924: EMPTY
24925: LIST
24926: LIST
24927: PUSH
24928: LD_INT 25
24930: PUSH
24931: LD_INT 9
24933: PUSH
24934: EMPTY
24935: LIST
24936: LIST
24937: PUSH
24938: EMPTY
24939: LIST
24940: LIST
24941: LIST
24942: LIST
24943: LIST
24944: LIST
24945: LIST
24946: LIST
24947: PPUSH
24948: CALL_OW 72
24952: ST_TO_ADDR
// if not tmp then
24953: LD_VAR 0 4
24957: NOT
24958: IFFALSE 24962
// exit ;
24960: GO 28352
// for i in tmp do
24962: LD_ADDR_VAR 0 3
24966: PUSH
24967: LD_VAR 0 4
24971: PUSH
24972: FOR_IN
24973: IFFALSE 25004
// if GetTag ( i ) then
24975: LD_VAR 0 3
24979: PPUSH
24980: CALL_OW 110
24984: IFFALSE 25002
// tmp := tmp diff i ;
24986: LD_ADDR_VAR 0 4
24990: PUSH
24991: LD_VAR 0 4
24995: PUSH
24996: LD_VAR 0 3
25000: DIFF
25001: ST_TO_ADDR
25002: GO 24972
25004: POP
25005: POP
// if not tmp then
25006: LD_VAR 0 4
25010: NOT
25011: IFFALSE 25015
// exit ;
25013: GO 28352
// sol := UnitFilter ( mc_bases [ base ] , [ f_or , [ f_class , 1 ] , [ f_class , 5 ] , [ f_class , 8 ] , [ f_class , 9 ] ] ) ;
25015: LD_ADDR_VAR 0 5
25019: PUSH
25020: LD_EXP 74
25024: PUSH
25025: LD_VAR 0 1
25029: ARRAY
25030: PPUSH
25031: LD_INT 2
25033: PUSH
25034: LD_INT 25
25036: PUSH
25037: LD_INT 1
25039: PUSH
25040: EMPTY
25041: LIST
25042: LIST
25043: PUSH
25044: LD_INT 25
25046: PUSH
25047: LD_INT 5
25049: PUSH
25050: EMPTY
25051: LIST
25052: LIST
25053: PUSH
25054: LD_INT 25
25056: PUSH
25057: LD_INT 8
25059: PUSH
25060: EMPTY
25061: LIST
25062: LIST
25063: PUSH
25064: LD_INT 25
25066: PUSH
25067: LD_INT 9
25069: PUSH
25070: EMPTY
25071: LIST
25072: LIST
25073: PUSH
25074: EMPTY
25075: LIST
25076: LIST
25077: LIST
25078: LIST
25079: LIST
25080: PPUSH
25081: CALL_OW 72
25085: ST_TO_ADDR
// eng := UnitFilter ( mc_bases [ base ] , [ f_class , 2 ] ) ;
25086: LD_ADDR_VAR 0 6
25090: PUSH
25091: LD_EXP 74
25095: PUSH
25096: LD_VAR 0 1
25100: ARRAY
25101: PPUSH
25102: LD_INT 25
25104: PUSH
25105: LD_INT 2
25107: PUSH
25108: EMPTY
25109: LIST
25110: LIST
25111: PPUSH
25112: CALL_OW 72
25116: ST_TO_ADDR
// mech := UnitFilter ( mc_bases [ base ] , [ f_class , 3 ] ) ;
25117: LD_ADDR_VAR 0 7
25121: PUSH
25122: LD_EXP 74
25126: PUSH
25127: LD_VAR 0 1
25131: ARRAY
25132: PPUSH
25133: LD_INT 25
25135: PUSH
25136: LD_INT 3
25138: PUSH
25139: EMPTY
25140: LIST
25141: LIST
25142: PPUSH
25143: CALL_OW 72
25147: ST_TO_ADDR
// sci := UnitFilter ( mc_bases [ base ] , [ [ f_class , 4 ] , [ f_lives , 251 ] ] ) ;
25148: LD_ADDR_VAR 0 8
25152: PUSH
25153: LD_EXP 74
25157: PUSH
25158: LD_VAR 0 1
25162: ARRAY
25163: PPUSH
25164: LD_INT 25
25166: PUSH
25167: LD_INT 4
25169: PUSH
25170: EMPTY
25171: LIST
25172: LIST
25173: PUSH
25174: LD_INT 24
25176: PUSH
25177: LD_INT 251
25179: PUSH
25180: EMPTY
25181: LIST
25182: LIST
25183: PUSH
25184: EMPTY
25185: LIST
25186: LIST
25187: PPUSH
25188: CALL_OW 72
25192: ST_TO_ADDR
// if mc_scan [ base ] then
25193: LD_EXP 97
25197: PUSH
25198: LD_VAR 0 1
25202: ARRAY
25203: IFFALSE 25664
// begin mc_class_case_use := Replace ( mc_class_case_use , base , 4 ) ;
25205: LD_ADDR_EXP 116
25209: PUSH
25210: LD_EXP 116
25214: PPUSH
25215: LD_VAR 0 1
25219: PPUSH
25220: LD_INT 4
25222: PPUSH
25223: CALL_OW 1
25227: ST_TO_ADDR
// b := UnitFilter ( mc_bases [ base ] , [ f_or , [ f_btype , b_armoury ] , [ f_btype , b_barracks ] ] ) ;
25228: LD_ADDR_VAR 0 12
25232: PUSH
25233: LD_EXP 74
25237: PUSH
25238: LD_VAR 0 1
25242: ARRAY
25243: PPUSH
25244: LD_INT 2
25246: PUSH
25247: LD_INT 30
25249: PUSH
25250: LD_INT 4
25252: PUSH
25253: EMPTY
25254: LIST
25255: LIST
25256: PUSH
25257: LD_INT 30
25259: PUSH
25260: LD_INT 5
25262: PUSH
25263: EMPTY
25264: LIST
25265: LIST
25266: PUSH
25267: EMPTY
25268: LIST
25269: LIST
25270: LIST
25271: PPUSH
25272: CALL_OW 72
25276: ST_TO_ADDR
// if not b then
25277: LD_VAR 0 12
25281: NOT
25282: IFFALSE 25286
// exit ;
25284: GO 28352
// p := [ ] ;
25286: LD_ADDR_VAR 0 11
25290: PUSH
25291: EMPTY
25292: ST_TO_ADDR
// if sci >= 2 then
25293: LD_VAR 0 8
25297: PUSH
25298: LD_INT 2
25300: GREATEREQUAL
25301: IFFALSE 25332
// sci := [ sci [ 1 ] , sci [ 2 ] ] else
25303: LD_ADDR_VAR 0 8
25307: PUSH
25308: LD_VAR 0 8
25312: PUSH
25313: LD_INT 1
25315: ARRAY
25316: PUSH
25317: LD_VAR 0 8
25321: PUSH
25322: LD_INT 2
25324: ARRAY
25325: PUSH
25326: EMPTY
25327: LIST
25328: LIST
25329: ST_TO_ADDR
25330: GO 25393
// if sci = 1 then
25332: LD_VAR 0 8
25336: PUSH
25337: LD_INT 1
25339: EQUAL
25340: IFFALSE 25361
// sci := [ sci [ 1 ] ] else
25342: LD_ADDR_VAR 0 8
25346: PUSH
25347: LD_VAR 0 8
25351: PUSH
25352: LD_INT 1
25354: ARRAY
25355: PUSH
25356: EMPTY
25357: LIST
25358: ST_TO_ADDR
25359: GO 25393
// if sci = 0 then
25361: LD_VAR 0 8
25365: PUSH
25366: LD_INT 0
25368: EQUAL
25369: IFFALSE 25393
// p := SortBySkill ( tmp , 4 ) [ 1 ] ;
25371: LD_ADDR_VAR 0 11
25375: PUSH
25376: LD_VAR 0 4
25380: PPUSH
25381: LD_INT 4
25383: PPUSH
25384: CALL 91651 0 2
25388: PUSH
25389: LD_INT 1
25391: ARRAY
25392: ST_TO_ADDR
// if eng > 4 then
25393: LD_VAR 0 6
25397: PUSH
25398: LD_INT 4
25400: GREATER
25401: IFFALSE 25447
// for i = eng downto 4 do
25403: LD_ADDR_VAR 0 3
25407: PUSH
25408: DOUBLE
25409: LD_VAR 0 6
25413: INC
25414: ST_TO_ADDR
25415: LD_INT 4
25417: PUSH
25418: FOR_DOWNTO
25419: IFFALSE 25445
// eng := eng diff eng [ i ] ;
25421: LD_ADDR_VAR 0 6
25425: PUSH
25426: LD_VAR 0 6
25430: PUSH
25431: LD_VAR 0 6
25435: PUSH
25436: LD_VAR 0 3
25440: ARRAY
25441: DIFF
25442: ST_TO_ADDR
25443: GO 25418
25445: POP
25446: POP
// tmp := tmp diff ( sol union eng union mech union sci ) ;
25447: LD_ADDR_VAR 0 4
25451: PUSH
25452: LD_VAR 0 4
25456: PUSH
25457: LD_VAR 0 5
25461: PUSH
25462: LD_VAR 0 6
25466: UNION
25467: PUSH
25468: LD_VAR 0 7
25472: UNION
25473: PUSH
25474: LD_VAR 0 8
25478: UNION
25479: DIFF
25480: ST_TO_ADDR
// bcount := UnitFilter ( mc_bases [ base ] , [ f_or , [ f_btype , b_bunker ] , [ f_btype , b_breastwork ] ] ) + UnitFilter ( mc_bases [ base ] , [ f_or , [ f_btype , b_armoury ] , [ f_btype , b_barracks ] ] ) * 6 ;
25481: LD_ADDR_VAR 0 13
25485: PUSH
25486: LD_EXP 74
25490: PUSH
25491: LD_VAR 0 1
25495: ARRAY
25496: PPUSH
25497: LD_INT 2
25499: PUSH
25500: LD_INT 30
25502: PUSH
25503: LD_INT 32
25505: PUSH
25506: EMPTY
25507: LIST
25508: LIST
25509: PUSH
25510: LD_INT 30
25512: PUSH
25513: LD_INT 31
25515: PUSH
25516: EMPTY
25517: LIST
25518: LIST
25519: PUSH
25520: EMPTY
25521: LIST
25522: LIST
25523: LIST
25524: PPUSH
25525: CALL_OW 72
25529: PUSH
25530: LD_EXP 74
25534: PUSH
25535: LD_VAR 0 1
25539: ARRAY
25540: PPUSH
25541: LD_INT 2
25543: PUSH
25544: LD_INT 30
25546: PUSH
25547: LD_INT 4
25549: PUSH
25550: EMPTY
25551: LIST
25552: LIST
25553: PUSH
25554: LD_INT 30
25556: PUSH
25557: LD_INT 5
25559: PUSH
25560: EMPTY
25561: LIST
25562: LIST
25563: PUSH
25564: EMPTY
25565: LIST
25566: LIST
25567: LIST
25568: PPUSH
25569: CALL_OW 72
25573: PUSH
25574: LD_INT 6
25576: MUL
25577: PLUS
25578: ST_TO_ADDR
// if bcount < tmp then
25579: LD_VAR 0 13
25583: PUSH
25584: LD_VAR 0 4
25588: LESS
25589: IFFALSE 25635
// for i = tmp downto bcount do
25591: LD_ADDR_VAR 0 3
25595: PUSH
25596: DOUBLE
25597: LD_VAR 0 4
25601: INC
25602: ST_TO_ADDR
25603: LD_VAR 0 13
25607: PUSH
25608: FOR_DOWNTO
25609: IFFALSE 25633
// tmp := Delete ( tmp , tmp ) ;
25611: LD_ADDR_VAR 0 4
25615: PUSH
25616: LD_VAR 0 4
25620: PPUSH
25621: LD_VAR 0 4
25625: PPUSH
25626: CALL_OW 3
25630: ST_TO_ADDR
25631: GO 25608
25633: POP
25634: POP
// result := [ tmp , 0 , 0 , p ] ;
25635: LD_ADDR_VAR 0 2
25639: PUSH
25640: LD_VAR 0 4
25644: PUSH
25645: LD_INT 0
25647: PUSH
25648: LD_INT 0
25650: PUSH
25651: LD_VAR 0 11
25655: PUSH
25656: EMPTY
25657: LIST
25658: LIST
25659: LIST
25660: LIST
25661: ST_TO_ADDR
// exit ;
25662: GO 28352
// end ; if not UnitFilter ( mc_bases [ base ] , [ f_or , [ f_btype , b_lab ] , [ f_btype , b_lab_half ] , [ f_btype , b_lab_full ] ] ) and not UnitFilter ( mc_bases [ base ] , [ f_btype , b_factory ] ) then
25664: LD_EXP 74
25668: PUSH
25669: LD_VAR 0 1
25673: ARRAY
25674: PPUSH
25675: LD_INT 2
25677: PUSH
25678: LD_INT 30
25680: PUSH
25681: LD_INT 6
25683: PUSH
25684: EMPTY
25685: LIST
25686: LIST
25687: PUSH
25688: LD_INT 30
25690: PUSH
25691: LD_INT 7
25693: PUSH
25694: EMPTY
25695: LIST
25696: LIST
25697: PUSH
25698: LD_INT 30
25700: PUSH
25701: LD_INT 8
25703: PUSH
25704: EMPTY
25705: LIST
25706: LIST
25707: PUSH
25708: EMPTY
25709: LIST
25710: LIST
25711: LIST
25712: LIST
25713: PPUSH
25714: CALL_OW 72
25718: NOT
25719: PUSH
25720: LD_EXP 74
25724: PUSH
25725: LD_VAR 0 1
25729: ARRAY
25730: PPUSH
25731: LD_INT 30
25733: PUSH
25734: LD_INT 3
25736: PUSH
25737: EMPTY
25738: LIST
25739: LIST
25740: PPUSH
25741: CALL_OW 72
25745: NOT
25746: AND
25747: IFFALSE 25819
// begin if eng = tmp then
25749: LD_VAR 0 6
25753: PUSH
25754: LD_VAR 0 4
25758: EQUAL
25759: IFFALSE 25763
// exit ;
25761: GO 28352
// mc_class_case_use := Replace ( mc_class_case_use , base , 1 ) ;
25763: LD_ADDR_EXP 116
25767: PUSH
25768: LD_EXP 116
25772: PPUSH
25773: LD_VAR 0 1
25777: PPUSH
25778: LD_INT 1
25780: PPUSH
25781: CALL_OW 1
25785: ST_TO_ADDR
// result := [ 0 , tmp diff eng , 0 , 0 ] ;
25786: LD_ADDR_VAR 0 2
25790: PUSH
25791: LD_INT 0
25793: PUSH
25794: LD_VAR 0 4
25798: PUSH
25799: LD_VAR 0 6
25803: DIFF
25804: PUSH
25805: LD_INT 0
25807: PUSH
25808: LD_INT 0
25810: PUSH
25811: EMPTY
25812: LIST
25813: LIST
25814: LIST
25815: LIST
25816: ST_TO_ADDR
// exit ;
25817: GO 28352
// end ; if mc_tech [ mc_sides [ base ] ] and UnitFilter ( mc_bases [ base ] , [ f_or , [ f_btype , b_lab ] , [ f_btype , b_lab_half ] , [ f_btype , b_lab_full ] ] ) and not UnitFilter ( mc_bases [ base ] , [ f_btype , b_factory ] ) then
25819: LD_EXP 101
25823: PUSH
25824: LD_EXP 100
25828: PUSH
25829: LD_VAR 0 1
25833: ARRAY
25834: ARRAY
25835: PUSH
25836: LD_EXP 74
25840: PUSH
25841: LD_VAR 0 1
25845: ARRAY
25846: PPUSH
25847: LD_INT 2
25849: PUSH
25850: LD_INT 30
25852: PUSH
25853: LD_INT 6
25855: PUSH
25856: EMPTY
25857: LIST
25858: LIST
25859: PUSH
25860: LD_INT 30
25862: PUSH
25863: LD_INT 7
25865: PUSH
25866: EMPTY
25867: LIST
25868: LIST
25869: PUSH
25870: LD_INT 30
25872: PUSH
25873: LD_INT 8
25875: PUSH
25876: EMPTY
25877: LIST
25878: LIST
25879: PUSH
25880: EMPTY
25881: LIST
25882: LIST
25883: LIST
25884: LIST
25885: PPUSH
25886: CALL_OW 72
25890: AND
25891: PUSH
25892: LD_EXP 74
25896: PUSH
25897: LD_VAR 0 1
25901: ARRAY
25902: PPUSH
25903: LD_INT 30
25905: PUSH
25906: LD_INT 3
25908: PUSH
25909: EMPTY
25910: LIST
25911: LIST
25912: PPUSH
25913: CALL_OW 72
25917: NOT
25918: AND
25919: IFFALSE 26133
// begin if sci >= 6 then
25921: LD_VAR 0 8
25925: PUSH
25926: LD_INT 6
25928: GREATEREQUAL
25929: IFFALSE 25933
// exit ;
25931: GO 28352
// mc_class_case_use := Replace ( mc_class_case_use , base , 2 ) ;
25933: LD_ADDR_EXP 116
25937: PUSH
25938: LD_EXP 116
25942: PPUSH
25943: LD_VAR 0 1
25947: PPUSH
25948: LD_INT 2
25950: PPUSH
25951: CALL_OW 1
25955: ST_TO_ADDR
// sort := SortBySkill ( tmp diff sci , 4 ) ;
25956: LD_ADDR_VAR 0 9
25960: PUSH
25961: LD_VAR 0 4
25965: PUSH
25966: LD_VAR 0 8
25970: DIFF
25971: PPUSH
25972: LD_INT 4
25974: PPUSH
25975: CALL 91651 0 2
25979: ST_TO_ADDR
// p := [ ] ;
25980: LD_ADDR_VAR 0 11
25984: PUSH
25985: EMPTY
25986: ST_TO_ADDR
// if sci < 6 and sort > 6 then
25987: LD_VAR 0 8
25991: PUSH
25992: LD_INT 6
25994: LESS
25995: PUSH
25996: LD_VAR 0 9
26000: PUSH
26001: LD_INT 6
26003: GREATER
26004: AND
26005: IFFALSE 26086
// begin for i = 1 to 6 - sci do
26007: LD_ADDR_VAR 0 3
26011: PUSH
26012: DOUBLE
26013: LD_INT 1
26015: DEC
26016: ST_TO_ADDR
26017: LD_INT 6
26019: PUSH
26020: LD_VAR 0 8
26024: MINUS
26025: PUSH
26026: FOR_TO
26027: IFFALSE 26082
// begin p := Insert ( p , p + 1 , sort [ 1 ] ) ;
26029: LD_ADDR_VAR 0 11
26033: PUSH
26034: LD_VAR 0 11
26038: PPUSH
26039: LD_VAR 0 11
26043: PUSH
26044: LD_INT 1
26046: PLUS
26047: PPUSH
26048: LD_VAR 0 9
26052: PUSH
26053: LD_INT 1
26055: ARRAY
26056: PPUSH
26057: CALL_OW 2
26061: ST_TO_ADDR
// sort := Delete ( sort , 1 ) ;
26062: LD_ADDR_VAR 0 9
26066: PUSH
26067: LD_VAR 0 9
26071: PPUSH
26072: LD_INT 1
26074: PPUSH
26075: CALL_OW 3
26079: ST_TO_ADDR
// end ;
26080: GO 26026
26082: POP
26083: POP
// end else
26084: GO 26106
// if sort then
26086: LD_VAR 0 9
26090: IFFALSE 26106
// p := sort [ 1 ] ;
26092: LD_ADDR_VAR 0 11
26096: PUSH
26097: LD_VAR 0 9
26101: PUSH
26102: LD_INT 1
26104: ARRAY
26105: ST_TO_ADDR
// result := [ 0 , 0 , 0 , p ] ;
26106: LD_ADDR_VAR 0 2
26110: PUSH
26111: LD_INT 0
26113: PUSH
26114: LD_INT 0
26116: PUSH
26117: LD_INT 0
26119: PUSH
26120: LD_VAR 0 11
26124: PUSH
26125: EMPTY
26126: LIST
26127: LIST
26128: LIST
26129: LIST
26130: ST_TO_ADDR
// exit ;
26131: GO 28352
// end ; if mc_tech [ mc_sides [ base ] ] and UnitFilter ( mc_bases [ base ] , [ f_or , [ f_btype , b_lab ] , [ f_btype , b_lab_half ] , [ f_btype , b_lab_full ] ] ) and UnitFilter ( mc_bases [ base ] , [ f_btype , b_factory ] ) then
26133: LD_EXP 101
26137: PUSH
26138: LD_EXP 100
26142: PUSH
26143: LD_VAR 0 1
26147: ARRAY
26148: ARRAY
26149: PUSH
26150: LD_EXP 74
26154: PUSH
26155: LD_VAR 0 1
26159: ARRAY
26160: PPUSH
26161: LD_INT 2
26163: PUSH
26164: LD_INT 30
26166: PUSH
26167: LD_INT 6
26169: PUSH
26170: EMPTY
26171: LIST
26172: LIST
26173: PUSH
26174: LD_INT 30
26176: PUSH
26177: LD_INT 7
26179: PUSH
26180: EMPTY
26181: LIST
26182: LIST
26183: PUSH
26184: LD_INT 30
26186: PUSH
26187: LD_INT 8
26189: PUSH
26190: EMPTY
26191: LIST
26192: LIST
26193: PUSH
26194: EMPTY
26195: LIST
26196: LIST
26197: LIST
26198: LIST
26199: PPUSH
26200: CALL_OW 72
26204: AND
26205: PUSH
26206: LD_EXP 74
26210: PUSH
26211: LD_VAR 0 1
26215: ARRAY
26216: PPUSH
26217: LD_INT 30
26219: PUSH
26220: LD_INT 3
26222: PUSH
26223: EMPTY
26224: LIST
26225: LIST
26226: PPUSH
26227: CALL_OW 72
26231: AND
26232: IFFALSE 26966
// begin mc_class_case_use := Replace ( mc_class_case_use , base , 3 ) ;
26234: LD_ADDR_EXP 116
26238: PUSH
26239: LD_EXP 116
26243: PPUSH
26244: LD_VAR 0 1
26248: PPUSH
26249: LD_INT 3
26251: PPUSH
26252: CALL_OW 1
26256: ST_TO_ADDR
// result := [ 0 , 0 , 0 , 0 ] ;
26257: LD_ADDR_VAR 0 2
26261: PUSH
26262: LD_INT 0
26264: PUSH
26265: LD_INT 0
26267: PUSH
26268: LD_INT 0
26270: PUSH
26271: LD_INT 0
26273: PUSH
26274: EMPTY
26275: LIST
26276: LIST
26277: LIST
26278: LIST
26279: ST_TO_ADDR
// if not eng then
26280: LD_VAR 0 6
26284: NOT
26285: IFFALSE 26348
// begin p := SortBySkill ( tmp , 2 ) [ 1 ] ;
26287: LD_ADDR_VAR 0 11
26291: PUSH
26292: LD_VAR 0 4
26296: PPUSH
26297: LD_INT 2
26299: PPUSH
26300: CALL 91651 0 2
26304: PUSH
26305: LD_INT 1
26307: ARRAY
26308: ST_TO_ADDR
// result := Replace ( result , 2 , p ) ;
26309: LD_ADDR_VAR 0 2
26313: PUSH
26314: LD_VAR 0 2
26318: PPUSH
26319: LD_INT 2
26321: PPUSH
26322: LD_VAR 0 11
26326: PPUSH
26327: CALL_OW 1
26331: ST_TO_ADDR
// tmp := tmp diff p ;
26332: LD_ADDR_VAR 0 4
26336: PUSH
26337: LD_VAR 0 4
26341: PUSH
26342: LD_VAR 0 11
26346: DIFF
26347: ST_TO_ADDR
// end ; if tmp and sci < 6 then
26348: LD_VAR 0 4
26352: PUSH
26353: LD_VAR 0 8
26357: PUSH
26358: LD_INT 6
26360: LESS
26361: AND
26362: IFFALSE 26550
// begin sort := SortBySkill ( tmp diff ( sci union mech ) , 4 ) ;
26364: LD_ADDR_VAR 0 9
26368: PUSH
26369: LD_VAR 0 4
26373: PUSH
26374: LD_VAR 0 8
26378: PUSH
26379: LD_VAR 0 7
26383: UNION
26384: DIFF
26385: PPUSH
26386: LD_INT 4
26388: PPUSH
26389: CALL 91651 0 2
26393: ST_TO_ADDR
// p := [ ] ;
26394: LD_ADDR_VAR 0 11
26398: PUSH
26399: EMPTY
26400: ST_TO_ADDR
// if sort then
26401: LD_VAR 0 9
26405: IFFALSE 26521
// for i = 1 to 6 - sci do
26407: LD_ADDR_VAR 0 3
26411: PUSH
26412: DOUBLE
26413: LD_INT 1
26415: DEC
26416: ST_TO_ADDR
26417: LD_INT 6
26419: PUSH
26420: LD_VAR 0 8
26424: MINUS
26425: PUSH
26426: FOR_TO
26427: IFFALSE 26519
// begin if i = sort then
26429: LD_VAR 0 3
26433: PUSH
26434: LD_VAR 0 9
26438: EQUAL
26439: IFFALSE 26443
// break ;
26441: GO 26519
// if GetClass ( i ) = 4 then
26443: LD_VAR 0 3
26447: PPUSH
26448: CALL_OW 257
26452: PUSH
26453: LD_INT 4
26455: EQUAL
26456: IFFALSE 26460
// continue ;
26458: GO 26426
// p := Insert ( p , p + 1 , sort [ i ] ) ;
26460: LD_ADDR_VAR 0 11
26464: PUSH
26465: LD_VAR 0 11
26469: PPUSH
26470: LD_VAR 0 11
26474: PUSH
26475: LD_INT 1
26477: PLUS
26478: PPUSH
26479: LD_VAR 0 9
26483: PUSH
26484: LD_VAR 0 3
26488: ARRAY
26489: PPUSH
26490: CALL_OW 2
26494: ST_TO_ADDR
// tmp := tmp diff sort [ i ] ;
26495: LD_ADDR_VAR 0 4
26499: PUSH
26500: LD_VAR 0 4
26504: PUSH
26505: LD_VAR 0 9
26509: PUSH
26510: LD_VAR 0 3
26514: ARRAY
26515: DIFF
26516: ST_TO_ADDR
// end ;
26517: GO 26426
26519: POP
26520: POP
// if p then
26521: LD_VAR 0 11
26525: IFFALSE 26550
// result := Replace ( result , 4 , p ) ;
26527: LD_ADDR_VAR 0 2
26531: PUSH
26532: LD_VAR 0 2
26536: PPUSH
26537: LD_INT 4
26539: PPUSH
26540: LD_VAR 0 11
26544: PPUSH
26545: CALL_OW 1
26549: ST_TO_ADDR
// end ; if tmp and mech < 6 then
26550: LD_VAR 0 4
26554: PUSH
26555: LD_VAR 0 7
26559: PUSH
26560: LD_INT 6
26562: LESS
26563: AND
26564: IFFALSE 26752
// begin sort := SortBySkill ( tmp diff ( sci union mech ) , 3 ) ;
26566: LD_ADDR_VAR 0 9
26570: PUSH
26571: LD_VAR 0 4
26575: PUSH
26576: LD_VAR 0 8
26580: PUSH
26581: LD_VAR 0 7
26585: UNION
26586: DIFF
26587: PPUSH
26588: LD_INT 3
26590: PPUSH
26591: CALL 91651 0 2
26595: ST_TO_ADDR
// p := [ ] ;
26596: LD_ADDR_VAR 0 11
26600: PUSH
26601: EMPTY
26602: ST_TO_ADDR
// if sort then
26603: LD_VAR 0 9
26607: IFFALSE 26723
// for i = 1 to 6 - mech do
26609: LD_ADDR_VAR 0 3
26613: PUSH
26614: DOUBLE
26615: LD_INT 1
26617: DEC
26618: ST_TO_ADDR
26619: LD_INT 6
26621: PUSH
26622: LD_VAR 0 7
26626: MINUS
26627: PUSH
26628: FOR_TO
26629: IFFALSE 26721
// begin if i = sort then
26631: LD_VAR 0 3
26635: PUSH
26636: LD_VAR 0 9
26640: EQUAL
26641: IFFALSE 26645
// break ;
26643: GO 26721
// if GetClass ( i ) = 3 then
26645: LD_VAR 0 3
26649: PPUSH
26650: CALL_OW 257
26654: PUSH
26655: LD_INT 3
26657: EQUAL
26658: IFFALSE 26662
// continue ;
26660: GO 26628
// p := Insert ( p , p + 1 , sort [ i ] ) ;
26662: LD_ADDR_VAR 0 11
26666: PUSH
26667: LD_VAR 0 11
26671: PPUSH
26672: LD_VAR 0 11
26676: PUSH
26677: LD_INT 1
26679: PLUS
26680: PPUSH
26681: LD_VAR 0 9
26685: PUSH
26686: LD_VAR 0 3
26690: ARRAY
26691: PPUSH
26692: CALL_OW 2
26696: ST_TO_ADDR
// tmp := tmp diff sort [ i ] ;
26697: LD_ADDR_VAR 0 4
26701: PUSH
26702: LD_VAR 0 4
26706: PUSH
26707: LD_VAR 0 9
26711: PUSH
26712: LD_VAR 0 3
26716: ARRAY
26717: DIFF
26718: ST_TO_ADDR
// end ;
26719: GO 26628
26721: POP
26722: POP
// if p then
26723: LD_VAR 0 11
26727: IFFALSE 26752
// result := Replace ( result , 3 , p ) ;
26729: LD_ADDR_VAR 0 2
26733: PUSH
26734: LD_VAR 0 2
26738: PPUSH
26739: LD_INT 3
26741: PPUSH
26742: LD_VAR 0 11
26746: PPUSH
26747: CALL_OW 1
26751: ST_TO_ADDR
// end ; if tmp > 6 and eng < 6 then
26752: LD_VAR 0 4
26756: PUSH
26757: LD_INT 6
26759: GREATER
26760: PUSH
26761: LD_VAR 0 6
26765: PUSH
26766: LD_INT 6
26768: LESS
26769: AND
26770: IFFALSE 26964
// begin sort := SortBySkill ( tmp diff ( sci union mech union eng ) , 2 ) ;
26772: LD_ADDR_VAR 0 9
26776: PUSH
26777: LD_VAR 0 4
26781: PUSH
26782: LD_VAR 0 8
26786: PUSH
26787: LD_VAR 0 7
26791: UNION
26792: PUSH
26793: LD_VAR 0 6
26797: UNION
26798: DIFF
26799: PPUSH
26800: LD_INT 2
26802: PPUSH
26803: CALL 91651 0 2
26807: ST_TO_ADDR
// p := [ ] ;
26808: LD_ADDR_VAR 0 11
26812: PUSH
26813: EMPTY
26814: ST_TO_ADDR
// if sort then
26815: LD_VAR 0 9
26819: IFFALSE 26935
// for i = 1 to 6 - eng do
26821: LD_ADDR_VAR 0 3
26825: PUSH
26826: DOUBLE
26827: LD_INT 1
26829: DEC
26830: ST_TO_ADDR
26831: LD_INT 6
26833: PUSH
26834: LD_VAR 0 6
26838: MINUS
26839: PUSH
26840: FOR_TO
26841: IFFALSE 26933
// begin if i = sort then
26843: LD_VAR 0 3
26847: PUSH
26848: LD_VAR 0 9
26852: EQUAL
26853: IFFALSE 26857
// break ;
26855: GO 26933
// if GetClass ( i ) = 2 then
26857: LD_VAR 0 3
26861: PPUSH
26862: CALL_OW 257
26866: PUSH
26867: LD_INT 2
26869: EQUAL
26870: IFFALSE 26874
// continue ;
26872: GO 26840
// p := Insert ( p , p + 1 , sort [ i ] ) ;
26874: LD_ADDR_VAR 0 11
26878: PUSH
26879: LD_VAR 0 11
26883: PPUSH
26884: LD_VAR 0 11
26888: PUSH
26889: LD_INT 1
26891: PLUS
26892: PPUSH
26893: LD_VAR 0 9
26897: PUSH
26898: LD_VAR 0 3
26902: ARRAY
26903: PPUSH
26904: CALL_OW 2
26908: ST_TO_ADDR
// tmp := tmp diff sort [ i ] ;
26909: LD_ADDR_VAR 0 4
26913: PUSH
26914: LD_VAR 0 4
26918: PUSH
26919: LD_VAR 0 9
26923: PUSH
26924: LD_VAR 0 3
26928: ARRAY
26929: DIFF
26930: ST_TO_ADDR
// end ;
26931: GO 26840
26933: POP
26934: POP
// if p then
26935: LD_VAR 0 11
26939: IFFALSE 26964
// result := Replace ( result , 2 , p ) ;
26941: LD_ADDR_VAR 0 2
26945: PUSH
26946: LD_VAR 0 2
26950: PPUSH
26951: LD_INT 2
26953: PPUSH
26954: LD_VAR 0 11
26958: PPUSH
26959: CALL_OW 1
26963: ST_TO_ADDR
// end ; exit ;
26964: GO 28352
// end ; if not mc_tech [ mc_sides [ base ] ] and UnitFilter ( mc_bases [ base ] , [ f_btype , b_factory ] ) and mc_build_list [ base ] then
26966: LD_EXP 101
26970: PUSH
26971: LD_EXP 100
26975: PUSH
26976: LD_VAR 0 1
26980: ARRAY
26981: ARRAY
26982: NOT
26983: PUSH
26984: LD_EXP 74
26988: PUSH
26989: LD_VAR 0 1
26993: ARRAY
26994: PPUSH
26995: LD_INT 30
26997: PUSH
26998: LD_INT 3
27000: PUSH
27001: EMPTY
27002: LIST
27003: LIST
27004: PPUSH
27005: CALL_OW 72
27009: AND
27010: PUSH
27011: LD_EXP 79
27015: PUSH
27016: LD_VAR 0 1
27020: ARRAY
27021: AND
27022: IFFALSE 27630
// begin mc_class_case_use := Replace ( mc_class_case_use , base , 5 ) ;
27024: LD_ADDR_EXP 116
27028: PUSH
27029: LD_EXP 116
27033: PPUSH
27034: LD_VAR 0 1
27038: PPUSH
27039: LD_INT 5
27041: PPUSH
27042: CALL_OW 1
27046: ST_TO_ADDR
// result := [ 0 , 0 , 0 , 0 ] ;
27047: LD_ADDR_VAR 0 2
27051: PUSH
27052: LD_INT 0
27054: PUSH
27055: LD_INT 0
27057: PUSH
27058: LD_INT 0
27060: PUSH
27061: LD_INT 0
27063: PUSH
27064: EMPTY
27065: LIST
27066: LIST
27067: LIST
27068: LIST
27069: ST_TO_ADDR
// if sci > 1 then
27070: LD_VAR 0 8
27074: PUSH
27075: LD_INT 1
27077: GREATER
27078: IFFALSE 27106
// tmp := tmp diff ( sci diff sci [ 1 ] ) ;
27080: LD_ADDR_VAR 0 4
27084: PUSH
27085: LD_VAR 0 4
27089: PUSH
27090: LD_VAR 0 8
27094: PUSH
27095: LD_VAR 0 8
27099: PUSH
27100: LD_INT 1
27102: ARRAY
27103: DIFF
27104: DIFF
27105: ST_TO_ADDR
// if tmp and not sci then
27106: LD_VAR 0 4
27110: PUSH
27111: LD_VAR 0 8
27115: NOT
27116: AND
27117: IFFALSE 27186
// begin sort := SortBySkill ( tmp , 4 ) ;
27119: LD_ADDR_VAR 0 9
27123: PUSH
27124: LD_VAR 0 4
27128: PPUSH
27129: LD_INT 4
27131: PPUSH
27132: CALL 91651 0 2
27136: ST_TO_ADDR
// if sort then
27137: LD_VAR 0 9
27141: IFFALSE 27157
// p := sort [ 1 ] ;
27143: LD_ADDR_VAR 0 11
27147: PUSH
27148: LD_VAR 0 9
27152: PUSH
27153: LD_INT 1
27155: ARRAY
27156: ST_TO_ADDR
// if p then
27157: LD_VAR 0 11
27161: IFFALSE 27186
// result := Replace ( result , 4 , p ) ;
27163: LD_ADDR_VAR 0 2
27167: PUSH
27168: LD_VAR 0 2
27172: PPUSH
27173: LD_INT 4
27175: PPUSH
27176: LD_VAR 0 11
27180: PPUSH
27181: CALL_OW 1
27185: ST_TO_ADDR
// end ; tmp := tmp diff mech ;
27186: LD_ADDR_VAR 0 4
27190: PUSH
27191: LD_VAR 0 4
27195: PUSH
27196: LD_VAR 0 7
27200: DIFF
27201: ST_TO_ADDR
// if tmp and mech < 6 then
27202: LD_VAR 0 4
27206: PUSH
27207: LD_VAR 0 7
27211: PUSH
27212: LD_INT 6
27214: LESS
27215: AND
27216: IFFALSE 27404
// begin sort := SortBySkill ( tmp diff ( sci union mech ) , 3 ) ;
27218: LD_ADDR_VAR 0 9
27222: PUSH
27223: LD_VAR 0 4
27227: PUSH
27228: LD_VAR 0 8
27232: PUSH
27233: LD_VAR 0 7
27237: UNION
27238: DIFF
27239: PPUSH
27240: LD_INT 3
27242: PPUSH
27243: CALL 91651 0 2
27247: ST_TO_ADDR
// p := [ ] ;
27248: LD_ADDR_VAR 0 11
27252: PUSH
27253: EMPTY
27254: ST_TO_ADDR
// if sort then
27255: LD_VAR 0 9
27259: IFFALSE 27375
// for i = 1 to 6 - mech do
27261: LD_ADDR_VAR 0 3
27265: PUSH
27266: DOUBLE
27267: LD_INT 1
27269: DEC
27270: ST_TO_ADDR
27271: LD_INT 6
27273: PUSH
27274: LD_VAR 0 7
27278: MINUS
27279: PUSH
27280: FOR_TO
27281: IFFALSE 27373
// begin if i = sort then
27283: LD_VAR 0 3
27287: PUSH
27288: LD_VAR 0 9
27292: EQUAL
27293: IFFALSE 27297
// break ;
27295: GO 27373
// if GetClass ( i ) = 3 then
27297: LD_VAR 0 3
27301: PPUSH
27302: CALL_OW 257
27306: PUSH
27307: LD_INT 3
27309: EQUAL
27310: IFFALSE 27314
// continue ;
27312: GO 27280
// p := Insert ( p , p + 1 , sort [ i ] ) ;
27314: LD_ADDR_VAR 0 11
27318: PUSH
27319: LD_VAR 0 11
27323: PPUSH
27324: LD_VAR 0 11
27328: PUSH
27329: LD_INT 1
27331: PLUS
27332: PPUSH
27333: LD_VAR 0 9
27337: PUSH
27338: LD_VAR 0 3
27342: ARRAY
27343: PPUSH
27344: CALL_OW 2
27348: ST_TO_ADDR
// tmp := tmp diff sort [ i ] ;
27349: LD_ADDR_VAR 0 4
27353: PUSH
27354: LD_VAR 0 4
27358: PUSH
27359: LD_VAR 0 9
27363: PUSH
27364: LD_VAR 0 3
27368: ARRAY
27369: DIFF
27370: ST_TO_ADDR
// end ;
27371: GO 27280
27373: POP
27374: POP
// if p then
27375: LD_VAR 0 11
27379: IFFALSE 27404
// result := Replace ( result , 3 , p ) ;
27381: LD_ADDR_VAR 0 2
27385: PUSH
27386: LD_VAR 0 2
27390: PPUSH
27391: LD_INT 3
27393: PPUSH
27394: LD_VAR 0 11
27398: PPUSH
27399: CALL_OW 1
27403: ST_TO_ADDR
// end ; tmp := tmp diff eng ;
27404: LD_ADDR_VAR 0 4
27408: PUSH
27409: LD_VAR 0 4
27413: PUSH
27414: LD_VAR 0 6
27418: DIFF
27419: ST_TO_ADDR
// if tmp and eng < 6 then
27420: LD_VAR 0 4
27424: PUSH
27425: LD_VAR 0 6
27429: PUSH
27430: LD_INT 6
27432: LESS
27433: AND
27434: IFFALSE 27628
// begin sort := SortBySkill ( tmp diff ( sci union mech union eng ) , 2 ) ;
27436: LD_ADDR_VAR 0 9
27440: PUSH
27441: LD_VAR 0 4
27445: PUSH
27446: LD_VAR 0 8
27450: PUSH
27451: LD_VAR 0 7
27455: UNION
27456: PUSH
27457: LD_VAR 0 6
27461: UNION
27462: DIFF
27463: PPUSH
27464: LD_INT 2
27466: PPUSH
27467: CALL 91651 0 2
27471: ST_TO_ADDR
// p := [ ] ;
27472: LD_ADDR_VAR 0 11
27476: PUSH
27477: EMPTY
27478: ST_TO_ADDR
// if sort then
27479: LD_VAR 0 9
27483: IFFALSE 27599
// for i = 1 to 6 - eng do
27485: LD_ADDR_VAR 0 3
27489: PUSH
27490: DOUBLE
27491: LD_INT 1
27493: DEC
27494: ST_TO_ADDR
27495: LD_INT 6
27497: PUSH
27498: LD_VAR 0 6
27502: MINUS
27503: PUSH
27504: FOR_TO
27505: IFFALSE 27597
// begin if i = sort then
27507: LD_VAR 0 3
27511: PUSH
27512: LD_VAR 0 9
27516: EQUAL
27517: IFFALSE 27521
// break ;
27519: GO 27597
// if GetClass ( i ) = 2 then
27521: LD_VAR 0 3
27525: PPUSH
27526: CALL_OW 257
27530: PUSH
27531: LD_INT 2
27533: EQUAL
27534: IFFALSE 27538
// continue ;
27536: GO 27504
// p := Insert ( p , p + 1 , sort [ i ] ) ;
27538: LD_ADDR_VAR 0 11
27542: PUSH
27543: LD_VAR 0 11
27547: PPUSH
27548: LD_VAR 0 11
27552: PUSH
27553: LD_INT 1
27555: PLUS
27556: PPUSH
27557: LD_VAR 0 9
27561: PUSH
27562: LD_VAR 0 3
27566: ARRAY
27567: PPUSH
27568: CALL_OW 2
27572: ST_TO_ADDR
// tmp := tmp diff sort [ i ] ;
27573: LD_ADDR_VAR 0 4
27577: PUSH
27578: LD_VAR 0 4
27582: PUSH
27583: LD_VAR 0 9
27587: PUSH
27588: LD_VAR 0 3
27592: ARRAY
27593: DIFF
27594: ST_TO_ADDR
// end ;
27595: GO 27504
27597: POP
27598: POP
// if p then
27599: LD_VAR 0 11
27603: IFFALSE 27628
// result := Replace ( result , 2 , p ) ;
27605: LD_ADDR_VAR 0 2
27609: PUSH
27610: LD_VAR 0 2
27614: PPUSH
27615: LD_INT 2
27617: PPUSH
27618: LD_VAR 0 11
27622: PPUSH
27623: CALL_OW 1
27627: ST_TO_ADDR
// end ; exit ;
27628: GO 28352
// end ; if not mc_tech [ mc_sides [ base ] ] and UnitFilter ( mc_bases [ base ] , [ f_btype , b_factory ] ) and not mc_build_list [ base ] then
27630: LD_EXP 101
27634: PUSH
27635: LD_EXP 100
27639: PUSH
27640: LD_VAR 0 1
27644: ARRAY
27645: ARRAY
27646: NOT
27647: PUSH
27648: LD_EXP 74
27652: PUSH
27653: LD_VAR 0 1
27657: ARRAY
27658: PPUSH
27659: LD_INT 30
27661: PUSH
27662: LD_INT 3
27664: PUSH
27665: EMPTY
27666: LIST
27667: LIST
27668: PPUSH
27669: CALL_OW 72
27673: AND
27674: PUSH
27675: LD_EXP 79
27679: PUSH
27680: LD_VAR 0 1
27684: ARRAY
27685: NOT
27686: AND
27687: IFFALSE 28352
// begin mc_class_case_use := Replace ( mc_class_case_use , base , 6 ) ;
27689: LD_ADDR_EXP 116
27693: PUSH
27694: LD_EXP 116
27698: PPUSH
27699: LD_VAR 0 1
27703: PPUSH
27704: LD_INT 6
27706: PPUSH
27707: CALL_OW 1
27711: ST_TO_ADDR
// result := [ 0 , 0 , 0 , 0 ] ;
27712: LD_ADDR_VAR 0 2
27716: PUSH
27717: LD_INT 0
27719: PUSH
27720: LD_INT 0
27722: PUSH
27723: LD_INT 0
27725: PUSH
27726: LD_INT 0
27728: PUSH
27729: EMPTY
27730: LIST
27731: LIST
27732: LIST
27733: LIST
27734: ST_TO_ADDR
// if sci >= 1 then
27735: LD_VAR 0 8
27739: PUSH
27740: LD_INT 1
27742: GREATEREQUAL
27743: IFFALSE 27765
// tmp := tmp diff sci [ 1 ] ;
27745: LD_ADDR_VAR 0 4
27749: PUSH
27750: LD_VAR 0 4
27754: PUSH
27755: LD_VAR 0 8
27759: PUSH
27760: LD_INT 1
27762: ARRAY
27763: DIFF
27764: ST_TO_ADDR
// if tmp and not sci then
27765: LD_VAR 0 4
27769: PUSH
27770: LD_VAR 0 8
27774: NOT
27775: AND
27776: IFFALSE 27845
// begin sort := SortBySkill ( tmp , 4 ) ;
27778: LD_ADDR_VAR 0 9
27782: PUSH
27783: LD_VAR 0 4
27787: PPUSH
27788: LD_INT 4
27790: PPUSH
27791: CALL 91651 0 2
27795: ST_TO_ADDR
// if sort then
27796: LD_VAR 0 9
27800: IFFALSE 27816
// p := sort [ 1 ] ;
27802: LD_ADDR_VAR 0 11
27806: PUSH
27807: LD_VAR 0 9
27811: PUSH
27812: LD_INT 1
27814: ARRAY
27815: ST_TO_ADDR
// if p then
27816: LD_VAR 0 11
27820: IFFALSE 27845
// result := Replace ( result , 4 , p ) ;
27822: LD_ADDR_VAR 0 2
27826: PUSH
27827: LD_VAR 0 2
27831: PPUSH
27832: LD_INT 4
27834: PPUSH
27835: LD_VAR 0 11
27839: PPUSH
27840: CALL_OW 1
27844: ST_TO_ADDR
// end ; tmp := tmp diff mech ;
27845: LD_ADDR_VAR 0 4
27849: PUSH
27850: LD_VAR 0 4
27854: PUSH
27855: LD_VAR 0 7
27859: DIFF
27860: ST_TO_ADDR
// if tmp and mech < 6 then
27861: LD_VAR 0 4
27865: PUSH
27866: LD_VAR 0 7
27870: PUSH
27871: LD_INT 6
27873: LESS
27874: AND
27875: IFFALSE 28057
// begin sort := SortBySkill ( tmp diff mech , 3 ) ;
27877: LD_ADDR_VAR 0 9
27881: PUSH
27882: LD_VAR 0 4
27886: PUSH
27887: LD_VAR 0 7
27891: DIFF
27892: PPUSH
27893: LD_INT 3
27895: PPUSH
27896: CALL 91651 0 2
27900: ST_TO_ADDR
// p := [ ] ;
27901: LD_ADDR_VAR 0 11
27905: PUSH
27906: EMPTY
27907: ST_TO_ADDR
// if sort then
27908: LD_VAR 0 9
27912: IFFALSE 28028
// for i = 1 to 6 - mech do
27914: LD_ADDR_VAR 0 3
27918: PUSH
27919: DOUBLE
27920: LD_INT 1
27922: DEC
27923: ST_TO_ADDR
27924: LD_INT 6
27926: PUSH
27927: LD_VAR 0 7
27931: MINUS
27932: PUSH
27933: FOR_TO
27934: IFFALSE 28026
// begin if i = sort then
27936: LD_VAR 0 3
27940: PUSH
27941: LD_VAR 0 9
27945: EQUAL
27946: IFFALSE 27950
// break ;
27948: GO 28026
// if GetClass ( i ) = 3 then
27950: LD_VAR 0 3
27954: PPUSH
27955: CALL_OW 257
27959: PUSH
27960: LD_INT 3
27962: EQUAL
27963: IFFALSE 27967
// continue ;
27965: GO 27933
// p := Insert ( p , p + 1 , sort [ i ] ) ;
27967: LD_ADDR_VAR 0 11
27971: PUSH
27972: LD_VAR 0 11
27976: PPUSH
27977: LD_VAR 0 11
27981: PUSH
27982: LD_INT 1
27984: PLUS
27985: PPUSH
27986: LD_VAR 0 9
27990: PUSH
27991: LD_VAR 0 3
27995: ARRAY
27996: PPUSH
27997: CALL_OW 2
28001: ST_TO_ADDR
// tmp := tmp diff sort [ i ] ;
28002: LD_ADDR_VAR 0 4
28006: PUSH
28007: LD_VAR 0 4
28011: PUSH
28012: LD_VAR 0 9
28016: PUSH
28017: LD_VAR 0 3
28021: ARRAY
28022: DIFF
28023: ST_TO_ADDR
// end ;
28024: GO 27933
28026: POP
28027: POP
// if p then
28028: LD_VAR 0 11
28032: IFFALSE 28057
// result := Replace ( result , 3 , p ) ;
28034: LD_ADDR_VAR 0 2
28038: PUSH
28039: LD_VAR 0 2
28043: PPUSH
28044: LD_INT 3
28046: PPUSH
28047: LD_VAR 0 11
28051: PPUSH
28052: CALL_OW 1
28056: ST_TO_ADDR
// end ; tmp := tmp diff eng ;
28057: LD_ADDR_VAR 0 4
28061: PUSH
28062: LD_VAR 0 4
28066: PUSH
28067: LD_VAR 0 6
28071: DIFF
28072: ST_TO_ADDR
// if tmp and eng < 4 then
28073: LD_VAR 0 4
28077: PUSH
28078: LD_VAR 0 6
28082: PUSH
28083: LD_INT 4
28085: LESS
28086: AND
28087: IFFALSE 28277
// begin sort := SortBySkill ( tmp diff ( mech union eng ) , 2 ) ;
28089: LD_ADDR_VAR 0 9
28093: PUSH
28094: LD_VAR 0 4
28098: PUSH
28099: LD_VAR 0 7
28103: PUSH
28104: LD_VAR 0 6
28108: UNION
28109: DIFF
28110: PPUSH
28111: LD_INT 2
28113: PPUSH
28114: CALL 91651 0 2
28118: ST_TO_ADDR
// p := [ ] ;
28119: LD_ADDR_VAR 0 11
28123: PUSH
28124: EMPTY
28125: ST_TO_ADDR
// if sort then
28126: LD_VAR 0 9
28130: IFFALSE 28246
// for i = 1 to 4 - eng do
28132: LD_ADDR_VAR 0 3
28136: PUSH
28137: DOUBLE
28138: LD_INT 1
28140: DEC
28141: ST_TO_ADDR
28142: LD_INT 4
28144: PUSH
28145: LD_VAR 0 6
28149: MINUS
28150: PUSH
28151: FOR_TO
28152: IFFALSE 28244
// begin if i = sort then
28154: LD_VAR 0 3
28158: PUSH
28159: LD_VAR 0 9
28163: EQUAL
28164: IFFALSE 28168
// break ;
28166: GO 28244
// if GetClass ( i ) = 2 then
28168: LD_VAR 0 3
28172: PPUSH
28173: CALL_OW 257
28177: PUSH
28178: LD_INT 2
28180: EQUAL
28181: IFFALSE 28185
// continue ;
28183: GO 28151
// p := Insert ( p , p + 1 , sort [ i ] ) ;
28185: LD_ADDR_VAR 0 11
28189: PUSH
28190: LD_VAR 0 11
28194: PPUSH
28195: LD_VAR 0 11
28199: PUSH
28200: LD_INT 1
28202: PLUS
28203: PPUSH
28204: LD_VAR 0 9
28208: PUSH
28209: LD_VAR 0 3
28213: ARRAY
28214: PPUSH
28215: CALL_OW 2
28219: ST_TO_ADDR
// tmp := tmp diff sort [ i ] ;
28220: LD_ADDR_VAR 0 4
28224: PUSH
28225: LD_VAR 0 4
28229: PUSH
28230: LD_VAR 0 9
28234: PUSH
28235: LD_VAR 0 3
28239: ARRAY
28240: DIFF
28241: ST_TO_ADDR
// end ;
28242: GO 28151
28244: POP
28245: POP
// if p then
28246: LD_VAR 0 11
28250: IFFALSE 28275
// result := Replace ( result , 2 , p ) ;
28252: LD_ADDR_VAR 0 2
28256: PUSH
28257: LD_VAR 0 2
28261: PPUSH
28262: LD_INT 2
28264: PPUSH
28265: LD_VAR 0 11
28269: PPUSH
28270: CALL_OW 1
28274: ST_TO_ADDR
// end else
28275: GO 28321
// for i = eng downto 5 do
28277: LD_ADDR_VAR 0 3
28281: PUSH
28282: DOUBLE
28283: LD_VAR 0 6
28287: INC
28288: ST_TO_ADDR
28289: LD_INT 5
28291: PUSH
28292: FOR_DOWNTO
28293: IFFALSE 28319
// tmp := tmp union eng [ i ] ;
28295: LD_ADDR_VAR 0 4
28299: PUSH
28300: LD_VAR 0 4
28304: PUSH
28305: LD_VAR 0 6
28309: PUSH
28310: LD_VAR 0 3
28314: ARRAY
28315: UNION
28316: ST_TO_ADDR
28317: GO 28292
28319: POP
28320: POP
// result := Replace ( result , 1 , tmp diff sol ) ;
28321: LD_ADDR_VAR 0 2
28325: PUSH
28326: LD_VAR 0 2
28330: PPUSH
28331: LD_INT 1
28333: PPUSH
28334: LD_VAR 0 4
28338: PUSH
28339: LD_VAR 0 5
28343: DIFF
28344: PPUSH
28345: CALL_OW 1
28349: ST_TO_ADDR
// exit ;
28350: GO 28352
// end ; end ;
28352: LD_VAR 0 2
28356: RET
// export function MC_CheckBuildings ( ) ; var i , tmp ; begin
28357: LD_INT 0
28359: PPUSH
28360: PPUSH
28361: PPUSH
// if not mc_bases then
28362: LD_EXP 74
28366: NOT
28367: IFFALSE 28371
// exit ;
28369: GO 28477
// for i = 1 to mc_bases do
28371: LD_ADDR_VAR 0 2
28375: PUSH
28376: DOUBLE
28377: LD_INT 1
28379: DEC
28380: ST_TO_ADDR
28381: LD_EXP 74
28385: PUSH
28386: FOR_TO
28387: IFFALSE 28468
// begin tmp := UnitFilter ( mc_bases [ i ] , [ [ f_type , unit_building ] , [ f_not , [ f_lives , 1000 ] ] ] ) ;
28389: LD_ADDR_VAR 0 3
28393: PUSH
28394: LD_EXP 74
28398: PUSH
28399: LD_VAR 0 2
28403: ARRAY
28404: PPUSH
28405: LD_INT 21
28407: PUSH
28408: LD_INT 3
28410: PUSH
28411: EMPTY
28412: LIST
28413: LIST
28414: PUSH
28415: LD_INT 3
28417: PUSH
28418: LD_INT 24
28420: PUSH
28421: LD_INT 1000
28423: PUSH
28424: EMPTY
28425: LIST
28426: LIST
28427: PUSH
28428: EMPTY
28429: LIST
28430: LIST
28431: PUSH
28432: EMPTY
28433: LIST
28434: LIST
28435: PPUSH
28436: CALL_OW 72
28440: ST_TO_ADDR
// mc_building_need_repair := Replace ( mc_building_need_repair , i , tmp ) ;
28441: LD_ADDR_EXP 75
28445: PUSH
28446: LD_EXP 75
28450: PPUSH
28451: LD_VAR 0 2
28455: PPUSH
28456: LD_VAR 0 3
28460: PPUSH
28461: CALL_OW 1
28465: ST_TO_ADDR
// end ;
28466: GO 28386
28468: POP
28469: POP
// RaiseSailEvent ( 101 ) ;
28470: LD_INT 101
28472: PPUSH
28473: CALL_OW 427
// end ;
28477: LD_VAR 0 1
28481: RET
// export function MC_CheckPeopleLife ( ) ; var i , j , k , tmp , need_heal_1 , need_heal_2 ; begin
28482: LD_INT 0
28484: PPUSH
28485: PPUSH
28486: PPUSH
28487: PPUSH
28488: PPUSH
28489: PPUSH
28490: PPUSH
// if not mc_bases then
28491: LD_EXP 74
28495: NOT
28496: IFFALSE 28500
// exit ;
28498: GO 29073
// for i = 1 to mc_bases do
28500: LD_ADDR_VAR 0 2
28504: PUSH
28505: DOUBLE
28506: LD_INT 1
28508: DEC
28509: ST_TO_ADDR
28510: LD_EXP 74
28514: PUSH
28515: FOR_TO
28516: IFFALSE 29064
// begin tmp := UnitFilter ( mc_bases [ i ] union mc_ape [ i ] , [ [ f_type , unit_human ] , [ f_and , [ f_not , [ f_inside ] ] , [ f_not , [ f_lives , 800 ] ] ] ] ) ;
28518: LD_ADDR_VAR 0 5
28522: PUSH
28523: LD_EXP 74
28527: PUSH
28528: LD_VAR 0 2
28532: ARRAY
28533: PUSH
28534: LD_EXP 103
28538: PUSH
28539: LD_VAR 0 2
28543: ARRAY
28544: UNION
28545: PPUSH
28546: LD_INT 21
28548: PUSH
28549: LD_INT 1
28551: PUSH
28552: EMPTY
28553: LIST
28554: LIST
28555: PUSH
28556: LD_INT 1
28558: PUSH
28559: LD_INT 3
28561: PUSH
28562: LD_INT 54
28564: PUSH
28565: EMPTY
28566: LIST
28567: PUSH
28568: EMPTY
28569: LIST
28570: LIST
28571: PUSH
28572: LD_INT 3
28574: PUSH
28575: LD_INT 24
28577: PUSH
28578: LD_INT 800
28580: PUSH
28581: EMPTY
28582: LIST
28583: LIST
28584: PUSH
28585: EMPTY
28586: LIST
28587: LIST
28588: PUSH
28589: EMPTY
28590: LIST
28591: LIST
28592: LIST
28593: PUSH
28594: EMPTY
28595: LIST
28596: LIST
28597: PPUSH
28598: CALL_OW 72
28602: ST_TO_ADDR
// need_heal_1 := UnitFilter ( mc_bases [ i ] , [ [ f_type , unit_human ] , [ f_and , [ f_not , [ f_inside ] ] , [ f_not , [ f_lives , 250 ] ] ] ] ) ;
28603: LD_ADDR_VAR 0 6
28607: PUSH
28608: LD_EXP 74
28612: PUSH
28613: LD_VAR 0 2
28617: ARRAY
28618: PPUSH
28619: LD_INT 21
28621: PUSH
28622: LD_INT 1
28624: PUSH
28625: EMPTY
28626: LIST
28627: LIST
28628: PUSH
28629: LD_INT 1
28631: PUSH
28632: LD_INT 3
28634: PUSH
28635: LD_INT 54
28637: PUSH
28638: EMPTY
28639: LIST
28640: PUSH
28641: EMPTY
28642: LIST
28643: LIST
28644: PUSH
28645: LD_INT 3
28647: PUSH
28648: LD_INT 24
28650: PUSH
28651: LD_INT 250
28653: PUSH
28654: EMPTY
28655: LIST
28656: LIST
28657: PUSH
28658: EMPTY
28659: LIST
28660: LIST
28661: PUSH
28662: EMPTY
28663: LIST
28664: LIST
28665: LIST
28666: PUSH
28667: EMPTY
28668: LIST
28669: LIST
28670: PPUSH
28671: CALL_OW 72
28675: ST_TO_ADDR
// need_heal_2 := tmp diff need_heal_1 ;
28676: LD_ADDR_VAR 0 7
28680: PUSH
28681: LD_VAR 0 5
28685: PUSH
28686: LD_VAR 0 6
28690: DIFF
28691: ST_TO_ADDR
// if not need_heal_1 then
28692: LD_VAR 0 6
28696: NOT
28697: IFFALSE 28730
// mc_need_heal := ReplaceIn ( mc_need_heal , [ i , 1 ] , [ ] ) else
28699: LD_ADDR_EXP 77
28703: PUSH
28704: LD_EXP 77
28708: PPUSH
28709: LD_VAR 0 2
28713: PUSH
28714: LD_INT 1
28716: PUSH
28717: EMPTY
28718: LIST
28719: LIST
28720: PPUSH
28721: EMPTY
28722: PPUSH
28723: CALL 57403 0 3
28727: ST_TO_ADDR
28728: GO 28800
// mc_need_heal := ReplaceIn ( mc_need_heal , [ i , 1 ] , UnitFilter ( mc_need_heal [ i ] [ 1 ] , [ f_not , [ f_lives , 1000 ] ] ) union need_heal_1 ) ;
28730: LD_ADDR_EXP 77
28734: PUSH
28735: LD_EXP 77
28739: PPUSH
28740: LD_VAR 0 2
28744: PUSH
28745: LD_INT 1
28747: PUSH
28748: EMPTY
28749: LIST
28750: LIST
28751: PPUSH
28752: LD_EXP 77
28756: PUSH
28757: LD_VAR 0 2
28761: ARRAY
28762: PUSH
28763: LD_INT 1
28765: ARRAY
28766: PPUSH
28767: LD_INT 3
28769: PUSH
28770: LD_INT 24
28772: PUSH
28773: LD_INT 1000
28775: PUSH
28776: EMPTY
28777: LIST
28778: LIST
28779: PUSH
28780: EMPTY
28781: LIST
28782: LIST
28783: PPUSH
28784: CALL_OW 72
28788: PUSH
28789: LD_VAR 0 6
28793: UNION
28794: PPUSH
28795: CALL 57403 0 3
28799: ST_TO_ADDR
// if not need_heal_2 then
28800: LD_VAR 0 7
28804: NOT
28805: IFFALSE 28838
// mc_need_heal := ReplaceIn ( mc_need_heal , [ i , 2 ] , [ ] ) else
28807: LD_ADDR_EXP 77
28811: PUSH
28812: LD_EXP 77
28816: PPUSH
28817: LD_VAR 0 2
28821: PUSH
28822: LD_INT 2
28824: PUSH
28825: EMPTY
28826: LIST
28827: LIST
28828: PPUSH
28829: EMPTY
28830: PPUSH
28831: CALL 57403 0 3
28835: ST_TO_ADDR
28836: GO 28870
// mc_need_heal := ReplaceIn ( mc_need_heal , [ i , 2 ] , need_heal_2 ) ;
28838: LD_ADDR_EXP 77
28842: PUSH
28843: LD_EXP 77
28847: PPUSH
28848: LD_VAR 0 2
28852: PUSH
28853: LD_INT 2
28855: PUSH
28856: EMPTY
28857: LIST
28858: LIST
28859: PPUSH
28860: LD_VAR 0 7
28864: PPUSH
28865: CALL 57403 0 3
28869: ST_TO_ADDR
// if need_heal_2 then
28870: LD_VAR 0 7
28874: IFFALSE 29046
// for j in need_heal_2 do
28876: LD_ADDR_VAR 0 3
28880: PUSH
28881: LD_VAR 0 7
28885: PUSH
28886: FOR_IN
28887: IFFALSE 29044
// begin tmp := UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_lab ] , [ f_btype , b_lab_half ] , [ f_btype , b_lab_full ] , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] , [ f_class , 4 ] ] ) ;
28889: LD_ADDR_VAR 0 5
28893: PUSH
28894: LD_EXP 74
28898: PUSH
28899: LD_VAR 0 2
28903: ARRAY
28904: PPUSH
28905: LD_INT 2
28907: PUSH
28908: LD_INT 30
28910: PUSH
28911: LD_INT 6
28913: PUSH
28914: EMPTY
28915: LIST
28916: LIST
28917: PUSH
28918: LD_INT 30
28920: PUSH
28921: LD_INT 7
28923: PUSH
28924: EMPTY
28925: LIST
28926: LIST
28927: PUSH
28928: LD_INT 30
28930: PUSH
28931: LD_INT 8
28933: PUSH
28934: EMPTY
28935: LIST
28936: LIST
28937: PUSH
28938: LD_INT 30
28940: PUSH
28941: LD_INT 0
28943: PUSH
28944: EMPTY
28945: LIST
28946: LIST
28947: PUSH
28948: LD_INT 30
28950: PUSH
28951: LD_INT 1
28953: PUSH
28954: EMPTY
28955: LIST
28956: LIST
28957: PUSH
28958: LD_INT 25
28960: PUSH
28961: LD_INT 4
28963: PUSH
28964: EMPTY
28965: LIST
28966: LIST
28967: PUSH
28968: EMPTY
28969: LIST
28970: LIST
28971: LIST
28972: LIST
28973: LIST
28974: LIST
28975: LIST
28976: PPUSH
28977: CALL_OW 72
28981: ST_TO_ADDR
// if tmp then
28982: LD_VAR 0 5
28986: IFFALSE 29042
// begin k := NearestUnitToUnit ( tmp , j ) ;
28988: LD_ADDR_VAR 0 4
28992: PUSH
28993: LD_VAR 0 5
28997: PPUSH
28998: LD_VAR 0 3
29002: PPUSH
29003: CALL_OW 74
29007: ST_TO_ADDR
// if GetDistUnits ( j , k ) > 7 then
29008: LD_VAR 0 3
29012: PPUSH
29013: LD_VAR 0 4
29017: PPUSH
29018: CALL_OW 296
29022: PUSH
29023: LD_INT 7
29025: GREATER
29026: IFFALSE 29042
// ComMoveUnit ( j , k ) ;
29028: LD_VAR 0 3
29032: PPUSH
29033: LD_VAR 0 4
29037: PPUSH
29038: CALL_OW 112
// end ; end ;
29042: GO 28886
29044: POP
29045: POP
// if not need_heal_1 and not need_heal_2 then
29046: LD_VAR 0 6
29050: NOT
29051: PUSH
29052: LD_VAR 0 7
29056: NOT
29057: AND
29058: IFFALSE 29062
// continue ;
29060: GO 28515
// end ;
29062: GO 28515
29064: POP
29065: POP
// RaiseSailEvent ( 102 ) ;
29066: LD_INT 102
29068: PPUSH
29069: CALL_OW 427
// end ;
29073: LD_VAR 0 1
29077: RET
// export function MC_RepairBuildings ( ) ; var i , j , un , tmp , cranes ; begin
29078: LD_INT 0
29080: PPUSH
29081: PPUSH
29082: PPUSH
29083: PPUSH
29084: PPUSH
29085: PPUSH
// if not mc_bases then
29086: LD_EXP 74
29090: NOT
29091: IFFALSE 29095
// exit ;
29093: GO 29805
// for i = 1 to mc_bases do
29095: LD_ADDR_VAR 0 2
29099: PUSH
29100: DOUBLE
29101: LD_INT 1
29103: DEC
29104: ST_TO_ADDR
29105: LD_EXP 74
29109: PUSH
29110: FOR_TO
29111: IFFALSE 29803
// begin if not mc_building_need_repair [ i ] then
29113: LD_EXP 75
29117: PUSH
29118: LD_VAR 0 2
29122: ARRAY
29123: NOT
29124: IFFALSE 29298
// begin cranes := UnitFilter ( mc_vehicles [ i ] , [ [ f_not , [ f_lives , 1000 ] ] , [ f_or , [ f_weapon , us_crane ] , [ f_weapon , ru_crane ] ] ] ) ;
29126: LD_ADDR_VAR 0 6
29130: PUSH
29131: LD_EXP 93
29135: PUSH
29136: LD_VAR 0 2
29140: ARRAY
29141: PPUSH
29142: LD_INT 3
29144: PUSH
29145: LD_INT 24
29147: PUSH
29148: LD_INT 1000
29150: PUSH
29151: EMPTY
29152: LIST
29153: LIST
29154: PUSH
29155: EMPTY
29156: LIST
29157: LIST
29158: PUSH
29159: LD_INT 2
29161: PUSH
29162: LD_INT 34
29164: PUSH
29165: LD_INT 13
29167: PUSH
29168: EMPTY
29169: LIST
29170: LIST
29171: PUSH
29172: LD_INT 34
29174: PUSH
29175: LD_INT 52
29177: PUSH
29178: EMPTY
29179: LIST
29180: LIST
29181: PUSH
29182: EMPTY
29183: LIST
29184: LIST
29185: LIST
29186: PUSH
29187: EMPTY
29188: LIST
29189: LIST
29190: PPUSH
29191: CALL_OW 72
29195: ST_TO_ADDR
// if cranes then
29196: LD_VAR 0 6
29200: IFFALSE 29262
// for j in cranes do
29202: LD_ADDR_VAR 0 3
29206: PUSH
29207: LD_VAR 0 6
29211: PUSH
29212: FOR_IN
29213: IFFALSE 29260
// if not IsInArea ( j , mc_parking [ i ] ) then
29215: LD_VAR 0 3
29219: PPUSH
29220: LD_EXP 98
29224: PUSH
29225: LD_VAR 0 2
29229: ARRAY
29230: PPUSH
29231: CALL_OW 308
29235: NOT
29236: IFFALSE 29258
// ComMoveToArea ( j , mc_parking [ i ] ) ;
29238: LD_VAR 0 3
29242: PPUSH
29243: LD_EXP 98
29247: PUSH
29248: LD_VAR 0 2
29252: ARRAY
29253: PPUSH
29254: CALL_OW 113
29258: GO 29212
29260: POP
29261: POP
// mc_building_repairs := Replace ( mc_building_repairs , i , [ ] ) ;
29262: LD_ADDR_EXP 76
29266: PUSH
29267: LD_EXP 76
29271: PPUSH
29272: LD_VAR 0 2
29276: PPUSH
29277: EMPTY
29278: PPUSH
29279: CALL_OW 1
29283: ST_TO_ADDR
// MC_Reset ( i , 101 ) ;
29284: LD_VAR 0 2
29288: PPUSH
29289: LD_INT 101
29291: PPUSH
29292: CALL 24190 0 2
// continue ;
29296: GO 29110
// end ; mc_builders := Replace ( mc_builders , i , [ ] ) ;
29298: LD_ADDR_EXP 80
29302: PUSH
29303: LD_EXP 80
29307: PPUSH
29308: LD_VAR 0 2
29312: PPUSH
29313: EMPTY
29314: PPUSH
29315: CALL_OW 1
29319: ST_TO_ADDR
// MC_Reset ( i , 103 ) ;
29320: LD_VAR 0 2
29324: PPUSH
29325: LD_INT 103
29327: PPUSH
29328: CALL 24190 0 2
// tmp := UnitFilter ( mc_bases [ i ] union mc_ape [ i ] , [ [ f_or , [ f_class , 2 ] , [ f_class , 16 ] ] ] ) ;
29332: LD_ADDR_VAR 0 5
29336: PUSH
29337: LD_EXP 74
29341: PUSH
29342: LD_VAR 0 2
29346: ARRAY
29347: PUSH
29348: LD_EXP 103
29352: PUSH
29353: LD_VAR 0 2
29357: ARRAY
29358: UNION
29359: PPUSH
29360: LD_INT 2
29362: PUSH
29363: LD_INT 25
29365: PUSH
29366: LD_INT 2
29368: PUSH
29369: EMPTY
29370: LIST
29371: LIST
29372: PUSH
29373: LD_INT 25
29375: PUSH
29376: LD_INT 16
29378: PUSH
29379: EMPTY
29380: LIST
29381: LIST
29382: PUSH
29383: EMPTY
29384: LIST
29385: LIST
29386: LIST
29387: PUSH
29388: EMPTY
29389: LIST
29390: PPUSH
29391: CALL_OW 72
29395: ST_TO_ADDR
// cranes := UnitFilter ( mc_vehicles [ i ] , [ f_or , [ f_weapon , us_crane ] , [ f_weapon , ru_crane ] ] ) ;
29396: LD_ADDR_VAR 0 6
29400: PUSH
29401: LD_EXP 93
29405: PUSH
29406: LD_VAR 0 2
29410: ARRAY
29411: PPUSH
29412: LD_INT 2
29414: PUSH
29415: LD_INT 34
29417: PUSH
29418: LD_INT 13
29420: PUSH
29421: EMPTY
29422: LIST
29423: LIST
29424: PUSH
29425: LD_INT 34
29427: PUSH
29428: LD_INT 52
29430: PUSH
29431: EMPTY
29432: LIST
29433: LIST
29434: PUSH
29435: EMPTY
29436: LIST
29437: LIST
29438: LIST
29439: PPUSH
29440: CALL_OW 72
29444: ST_TO_ADDR
// if cranes then
29445: LD_VAR 0 6
29449: IFFALSE 29585
// begin for j in cranes do
29451: LD_ADDR_VAR 0 3
29455: PUSH
29456: LD_VAR 0 6
29460: PUSH
29461: FOR_IN
29462: IFFALSE 29583
// if GetLives ( j ) >= 500 and not HasTask ( j ) then
29464: LD_VAR 0 3
29468: PPUSH
29469: CALL_OW 256
29473: PUSH
29474: LD_INT 500
29476: GREATEREQUAL
29477: PUSH
29478: LD_VAR 0 3
29482: PPUSH
29483: CALL_OW 314
29487: NOT
29488: AND
29489: IFFALSE 29523
// ComRepairBuilding ( j , NearestUnitToUnit ( mc_building_need_repair [ i ] , j ) ) else
29491: LD_VAR 0 3
29495: PPUSH
29496: LD_EXP 75
29500: PUSH
29501: LD_VAR 0 2
29505: ARRAY
29506: PPUSH
29507: LD_VAR 0 3
29511: PPUSH
29512: CALL_OW 74
29516: PPUSH
29517: CALL_OW 130
29521: GO 29581
// if GetLives ( j ) < 500 and not IsInArea ( j , mc_parking [ i ] ) then
29523: LD_VAR 0 3
29527: PPUSH
29528: CALL_OW 256
29532: PUSH
29533: LD_INT 500
29535: LESS
29536: PUSH
29537: LD_VAR 0 3
29541: PPUSH
29542: LD_EXP 98
29546: PUSH
29547: LD_VAR 0 2
29551: ARRAY
29552: PPUSH
29553: CALL_OW 308
29557: NOT
29558: AND
29559: IFFALSE 29581
// ComMoveToArea ( j , mc_parking [ i ] ) ;
29561: LD_VAR 0 3
29565: PPUSH
29566: LD_EXP 98
29570: PUSH
29571: LD_VAR 0 2
29575: ARRAY
29576: PPUSH
29577: CALL_OW 113
29581: GO 29461
29583: POP
29584: POP
// end ; if not tmp then
29585: LD_VAR 0 5
29589: NOT
29590: IFFALSE 29594
// continue ;
29592: GO 29110
// for j in tmp do
29594: LD_ADDR_VAR 0 3
29598: PUSH
29599: LD_VAR 0 5
29603: PUSH
29604: FOR_IN
29605: IFFALSE 29799
// begin if mc_need_heal [ i ] then
29607: LD_EXP 77
29611: PUSH
29612: LD_VAR 0 2
29616: ARRAY
29617: IFFALSE 29665
// if j in mc_need_heal [ i ] [ 1 ] or j in mc_need_heal [ i ] [ 2 ] then
29619: LD_VAR 0 3
29623: PUSH
29624: LD_EXP 77
29628: PUSH
29629: LD_VAR 0 2
29633: ARRAY
29634: PUSH
29635: LD_INT 1
29637: ARRAY
29638: IN
29639: PUSH
29640: LD_VAR 0 3
29644: PUSH
29645: LD_EXP 77
29649: PUSH
29650: LD_VAR 0 2
29654: ARRAY
29655: PUSH
29656: LD_INT 2
29658: ARRAY
29659: IN
29660: OR
29661: IFFALSE 29665
// continue ;
29663: GO 29604
// if IsInUnit ( j ) then
29665: LD_VAR 0 3
29669: PPUSH
29670: CALL_OW 310
29674: IFFALSE 29685
// ComExitBuilding ( j ) ;
29676: LD_VAR 0 3
29680: PPUSH
29681: CALL_OW 122
// if not j in mc_building_repairs [ i ] then
29685: LD_VAR 0 3
29689: PUSH
29690: LD_EXP 76
29694: PUSH
29695: LD_VAR 0 2
29699: ARRAY
29700: IN
29701: NOT
29702: IFFALSE 29760
// begin SetTag ( j , 101 ) ;
29704: LD_VAR 0 3
29708: PPUSH
29709: LD_INT 101
29711: PPUSH
29712: CALL_OW 109
// mc_building_repairs := ReplaceIn ( mc_building_repairs , [ i , mc_building_repairs [ i ] + 1 ] , j ) ;
29716: LD_ADDR_EXP 76
29720: PUSH
29721: LD_EXP 76
29725: PPUSH
29726: LD_VAR 0 2
29730: PUSH
29731: LD_EXP 76
29735: PUSH
29736: LD_VAR 0 2
29740: ARRAY
29741: PUSH
29742: LD_INT 1
29744: PLUS
29745: PUSH
29746: EMPTY
29747: LIST
29748: LIST
29749: PPUSH
29750: LD_VAR 0 3
29754: PPUSH
29755: CALL 57403 0 3
29759: ST_TO_ADDR
// end ; wait ( 1 ) ;
29760: LD_INT 1
29762: PPUSH
29763: CALL_OW 67
// ComRepairBuilding ( j , NearestUnitToUnit ( mc_building_need_repair [ i ] , j ) ) ;
29767: LD_VAR 0 3
29771: PPUSH
29772: LD_EXP 75
29776: PUSH
29777: LD_VAR 0 2
29781: ARRAY
29782: PPUSH
29783: LD_VAR 0 3
29787: PPUSH
29788: CALL_OW 74
29792: PPUSH
29793: CALL_OW 130
// end ;
29797: GO 29604
29799: POP
29800: POP
// end ;
29801: GO 29110
29803: POP
29804: POP
// end ;
29805: LD_VAR 0 1
29809: RET
// export function MC_Heal ; var i , j , tmp ; begin
29810: LD_INT 0
29812: PPUSH
29813: PPUSH
29814: PPUSH
29815: PPUSH
// if not mc_bases then
29816: LD_EXP 74
29820: NOT
29821: IFFALSE 29825
// exit ;
29823: GO 30227
// for i = 1 to mc_bases do
29825: LD_ADDR_VAR 0 2
29829: PUSH
29830: DOUBLE
29831: LD_INT 1
29833: DEC
29834: ST_TO_ADDR
29835: LD_EXP 74
29839: PUSH
29840: FOR_TO
29841: IFFALSE 30225
// begin if not mc_need_heal [ i ] [ 1 ] and not mc_need_heal [ i ] [ 2 ] then
29843: LD_EXP 77
29847: PUSH
29848: LD_VAR 0 2
29852: ARRAY
29853: PUSH
29854: LD_INT 1
29856: ARRAY
29857: NOT
29858: PUSH
29859: LD_EXP 77
29863: PUSH
29864: LD_VAR 0 2
29868: ARRAY
29869: PUSH
29870: LD_INT 2
29872: ARRAY
29873: NOT
29874: AND
29875: IFFALSE 29913
// begin mc_healers := Replace ( mc_healers , i , [ ] ) ;
29877: LD_ADDR_EXP 78
29881: PUSH
29882: LD_EXP 78
29886: PPUSH
29887: LD_VAR 0 2
29891: PPUSH
29892: EMPTY
29893: PPUSH
29894: CALL_OW 1
29898: ST_TO_ADDR
// MC_Reset ( i , 102 ) ;
29899: LD_VAR 0 2
29903: PPUSH
29904: LD_INT 102
29906: PPUSH
29907: CALL 24190 0 2
// continue ;
29911: GO 29840
// end ; tmp := UnitFilter ( mc_bases [ i ] , [ f_class , 4 ] ) ;
29913: LD_ADDR_VAR 0 4
29917: PUSH
29918: LD_EXP 74
29922: PUSH
29923: LD_VAR 0 2
29927: ARRAY
29928: PPUSH
29929: LD_INT 25
29931: PUSH
29932: LD_INT 4
29934: PUSH
29935: EMPTY
29936: LIST
29937: LIST
29938: PPUSH
29939: CALL_OW 72
29943: ST_TO_ADDR
// if not tmp then
29944: LD_VAR 0 4
29948: NOT
29949: IFFALSE 29953
// continue ;
29951: GO 29840
// if mc_taming [ i ] then
29953: LD_EXP 105
29957: PUSH
29958: LD_VAR 0 2
29962: ARRAY
29963: IFFALSE 29987
// mc_taming := Replace ( mc_taming , i , [ ] ) ;
29965: LD_ADDR_EXP 105
29969: PUSH
29970: LD_EXP 105
29974: PPUSH
29975: LD_VAR 0 2
29979: PPUSH
29980: EMPTY
29981: PPUSH
29982: CALL_OW 1
29986: ST_TO_ADDR
// for j in tmp do
29987: LD_ADDR_VAR 0 3
29991: PUSH
29992: LD_VAR 0 4
29996: PUSH
29997: FOR_IN
29998: IFFALSE 30221
// begin if IsInUnit ( j ) then
30000: LD_VAR 0 3
30004: PPUSH
30005: CALL_OW 310
30009: IFFALSE 30020
// ComExitBuilding ( j ) ;
30011: LD_VAR 0 3
30015: PPUSH
30016: CALL_OW 122
// if not j in mc_healers [ i ] then
30020: LD_VAR 0 3
30024: PUSH
30025: LD_EXP 78
30029: PUSH
30030: LD_VAR 0 2
30034: ARRAY
30035: IN
30036: NOT
30037: IFFALSE 30083
// mc_healers := ReplaceIn ( mc_healers , [ i , mc_healers [ i ] + 1 ] , j ) ;
30039: LD_ADDR_EXP 78
30043: PUSH
30044: LD_EXP 78
30048: PPUSH
30049: LD_VAR 0 2
30053: PUSH
30054: LD_EXP 78
30058: PUSH
30059: LD_VAR 0 2
30063: ARRAY
30064: PUSH
30065: LD_INT 1
30067: PLUS
30068: PUSH
30069: EMPTY
30070: LIST
30071: LIST
30072: PPUSH
30073: LD_VAR 0 3
30077: PPUSH
30078: CALL 57403 0 3
30082: ST_TO_ADDR
// if GetTag ( j ) <> 102 then
30083: LD_VAR 0 3
30087: PPUSH
30088: CALL_OW 110
30092: PUSH
30093: LD_INT 102
30095: NONEQUAL
30096: IFFALSE 30110
// SetTag ( j , 102 ) ;
30098: LD_VAR 0 3
30102: PPUSH
30103: LD_INT 102
30105: PPUSH
30106: CALL_OW 109
// Wait ( 3 ) ;
30110: LD_INT 3
30112: PPUSH
30113: CALL_OW 67
// if mc_need_heal [ i ] [ 1 ] then
30117: LD_EXP 77
30121: PUSH
30122: LD_VAR 0 2
30126: ARRAY
30127: PUSH
30128: LD_INT 1
30130: ARRAY
30131: IFFALSE 30163
// ComHeal ( j , mc_need_heal [ i ] [ 1 ] [ 1 ] ) else
30133: LD_VAR 0 3
30137: PPUSH
30138: LD_EXP 77
30142: PUSH
30143: LD_VAR 0 2
30147: ARRAY
30148: PUSH
30149: LD_INT 1
30151: ARRAY
30152: PUSH
30153: LD_INT 1
30155: ARRAY
30156: PPUSH
30157: CALL_OW 128
30161: GO 30219
// if not HasTask ( j ) and mc_need_heal [ i ] [ 2 ] then
30163: LD_VAR 0 3
30167: PPUSH
30168: CALL_OW 314
30172: NOT
30173: PUSH
30174: LD_EXP 77
30178: PUSH
30179: LD_VAR 0 2
30183: ARRAY
30184: PUSH
30185: LD_INT 2
30187: ARRAY
30188: AND
30189: IFFALSE 30219
// ComHeal ( j , mc_need_heal [ i ] [ 2 ] [ 1 ] ) ;
30191: LD_VAR 0 3
30195: PPUSH
30196: LD_EXP 77
30200: PUSH
30201: LD_VAR 0 2
30205: ARRAY
30206: PUSH
30207: LD_INT 2
30209: ARRAY
30210: PUSH
30211: LD_INT 1
30213: ARRAY
30214: PPUSH
30215: CALL_OW 128
// end ;
30219: GO 29997
30221: POP
30222: POP
// end ;
30223: GO 29840
30225: POP
30226: POP
// end ;
30227: LD_VAR 0 1
30231: RET
// export function MC_Build ( ) ; var i , j , tmp , depot ; begin
30232: LD_INT 0
30234: PPUSH
30235: PPUSH
30236: PPUSH
30237: PPUSH
30238: PPUSH
// if not mc_bases then
30239: LD_EXP 74
30243: NOT
30244: IFFALSE 30248
// exit ;
30246: GO 31391
// for i = 1 to mc_bases do
30248: LD_ADDR_VAR 0 2
30252: PUSH
30253: DOUBLE
30254: LD_INT 1
30256: DEC
30257: ST_TO_ADDR
30258: LD_EXP 74
30262: PUSH
30263: FOR_TO
30264: IFFALSE 31389
// begin if mc_scan [ i ] then
30266: LD_EXP 97
30270: PUSH
30271: LD_VAR 0 2
30275: ARRAY
30276: IFFALSE 30280
// continue ;
30278: GO 30263
// if not mc_build_list [ i ] and not mc_construct_list [ i ] and mc_builders [ i ] then
30280: LD_EXP 79
30284: PUSH
30285: LD_VAR 0 2
30289: ARRAY
30290: NOT
30291: PUSH
30292: LD_EXP 81
30296: PUSH
30297: LD_VAR 0 2
30301: ARRAY
30302: NOT
30303: AND
30304: PUSH
30305: LD_EXP 80
30309: PUSH
30310: LD_VAR 0 2
30314: ARRAY
30315: AND
30316: IFFALSE 30354
// begin mc_builders := Replace ( mc_builders , i , [ ] ) ;
30318: LD_ADDR_EXP 80
30322: PUSH
30323: LD_EXP 80
30327: PPUSH
30328: LD_VAR 0 2
30332: PPUSH
30333: EMPTY
30334: PPUSH
30335: CALL_OW 1
30339: ST_TO_ADDR
// MC_Reset ( i , 103 ) ;
30340: LD_VAR 0 2
30344: PPUSH
30345: LD_INT 103
30347: PPUSH
30348: CALL 24190 0 2
// continue ;
30352: GO 30263
// end ; if mc_construct_list [ i ] then
30354: LD_EXP 81
30358: PUSH
30359: LD_VAR 0 2
30363: ARRAY
30364: IFFALSE 30584
// begin tmp := UnitFilter ( mc_bases [ i ] , [ f_class , 2 ] ) diff mc_building_repairs [ i ] ;
30366: LD_ADDR_VAR 0 4
30370: PUSH
30371: LD_EXP 74
30375: PUSH
30376: LD_VAR 0 2
30380: ARRAY
30381: PPUSH
30382: LD_INT 25
30384: PUSH
30385: LD_INT 2
30387: PUSH
30388: EMPTY
30389: LIST
30390: LIST
30391: PPUSH
30392: CALL_OW 72
30396: PUSH
30397: LD_EXP 76
30401: PUSH
30402: LD_VAR 0 2
30406: ARRAY
30407: DIFF
30408: ST_TO_ADDR
// if not tmp then
30409: LD_VAR 0 4
30413: NOT
30414: IFFALSE 30418
// continue ;
30416: GO 30263
// for j in tmp do
30418: LD_ADDR_VAR 0 3
30422: PUSH
30423: LD_VAR 0 4
30427: PUSH
30428: FOR_IN
30429: IFFALSE 30580
// begin if not mc_builders [ i ] then
30431: LD_EXP 80
30435: PUSH
30436: LD_VAR 0 2
30440: ARRAY
30441: NOT
30442: IFFALSE 30500
// begin SetTag ( j , 103 ) ;
30444: LD_VAR 0 3
30448: PPUSH
30449: LD_INT 103
30451: PPUSH
30452: CALL_OW 109
// mc_builders := ReplaceIn ( mc_builders , [ i , mc_builders [ i ] + 1 ] , j ) ;
30456: LD_ADDR_EXP 80
30460: PUSH
30461: LD_EXP 80
30465: PPUSH
30466: LD_VAR 0 2
30470: PUSH
30471: LD_EXP 80
30475: PUSH
30476: LD_VAR 0 2
30480: ARRAY
30481: PUSH
30482: LD_INT 1
30484: PLUS
30485: PUSH
30486: EMPTY
30487: LIST
30488: LIST
30489: PPUSH
30490: LD_VAR 0 3
30494: PPUSH
30495: CALL 57403 0 3
30499: ST_TO_ADDR
// end ; if IsInUnit ( j ) then
30500: LD_VAR 0 3
30504: PPUSH
30505: CALL_OW 310
30509: IFFALSE 30520
// ComExitBuilding ( j ) ;
30511: LD_VAR 0 3
30515: PPUSH
30516: CALL_OW 122
// wait ( 3 ) ;
30520: LD_INT 3
30522: PPUSH
30523: CALL_OW 67
// if not mc_construct_list [ i ] then
30527: LD_EXP 81
30531: PUSH
30532: LD_VAR 0 2
30536: ARRAY
30537: NOT
30538: IFFALSE 30542
// break ;
30540: GO 30580
// if not HasTask ( j ) then
30542: LD_VAR 0 3
30546: PPUSH
30547: CALL_OW 314
30551: NOT
30552: IFFALSE 30578
// ComComplete ( j , mc_construct_list [ i ] [ 1 ] ) ;
30554: LD_VAR 0 3
30558: PPUSH
30559: LD_EXP 81
30563: PUSH
30564: LD_VAR 0 2
30568: ARRAY
30569: PUSH
30570: LD_INT 1
30572: ARRAY
30573: PPUSH
30574: CALL 60254 0 2
// end ;
30578: GO 30428
30580: POP
30581: POP
// end else
30582: GO 31387
// if mc_build_list [ i ] then
30584: LD_EXP 79
30588: PUSH
30589: LD_VAR 0 2
30593: ARRAY
30594: IFFALSE 31387
// begin depot := UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) ;
30596: LD_ADDR_VAR 0 5
30600: PUSH
30601: LD_EXP 74
30605: PUSH
30606: LD_VAR 0 2
30610: ARRAY
30611: PPUSH
30612: LD_INT 2
30614: PUSH
30615: LD_INT 30
30617: PUSH
30618: LD_INT 0
30620: PUSH
30621: EMPTY
30622: LIST
30623: LIST
30624: PUSH
30625: LD_INT 30
30627: PUSH
30628: LD_INT 1
30630: PUSH
30631: EMPTY
30632: LIST
30633: LIST
30634: PUSH
30635: EMPTY
30636: LIST
30637: LIST
30638: LIST
30639: PPUSH
30640: CALL_OW 72
30644: ST_TO_ADDR
// if depot then
30645: LD_VAR 0 5
30649: IFFALSE 30667
// depot := depot [ 1 ] else
30651: LD_ADDR_VAR 0 5
30655: PUSH
30656: LD_VAR 0 5
30660: PUSH
30661: LD_INT 1
30663: ARRAY
30664: ST_TO_ADDR
30665: GO 30675
// depot := 0 ;
30667: LD_ADDR_VAR 0 5
30671: PUSH
30672: LD_INT 0
30674: ST_TO_ADDR
// if IsExtension ( mc_build_list [ i ] [ 1 ] [ 1 ] ) and not UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_workshop ] , [ f_btype , b_factory ] ] ) then
30675: LD_EXP 79
30679: PUSH
30680: LD_VAR 0 2
30684: ARRAY
30685: PUSH
30686: LD_INT 1
30688: ARRAY
30689: PUSH
30690: LD_INT 1
30692: ARRAY
30693: PPUSH
30694: CALL 60084 0 1
30698: PUSH
30699: LD_EXP 74
30703: PUSH
30704: LD_VAR 0 2
30708: ARRAY
30709: PPUSH
30710: LD_INT 2
30712: PUSH
30713: LD_INT 30
30715: PUSH
30716: LD_INT 2
30718: PUSH
30719: EMPTY
30720: LIST
30721: LIST
30722: PUSH
30723: LD_INT 30
30725: PUSH
30726: LD_INT 3
30728: PUSH
30729: EMPTY
30730: LIST
30731: LIST
30732: PUSH
30733: EMPTY
30734: LIST
30735: LIST
30736: LIST
30737: PPUSH
30738: CALL_OW 72
30742: NOT
30743: AND
30744: IFFALSE 30849
// begin for j = 1 to mc_build_list [ i ] do
30746: LD_ADDR_VAR 0 3
30750: PUSH
30751: DOUBLE
30752: LD_INT 1
30754: DEC
30755: ST_TO_ADDR
30756: LD_EXP 79
30760: PUSH
30761: LD_VAR 0 2
30765: ARRAY
30766: PUSH
30767: FOR_TO
30768: IFFALSE 30847
// if mc_build_list [ i ] [ j ] [ 1 ] = b_workshop then
30770: LD_EXP 79
30774: PUSH
30775: LD_VAR 0 2
30779: ARRAY
30780: PUSH
30781: LD_VAR 0 3
30785: ARRAY
30786: PUSH
30787: LD_INT 1
30789: ARRAY
30790: PUSH
30791: LD_INT 2
30793: EQUAL
30794: IFFALSE 30845
// begin mc_build_list := Replace ( mc_build_list , i , Reindex ( mc_build_list [ i ] , j , 1 , false ) ) ;
30796: LD_ADDR_EXP 79
30800: PUSH
30801: LD_EXP 79
30805: PPUSH
30806: LD_VAR 0 2
30810: PPUSH
30811: LD_EXP 79
30815: PUSH
30816: LD_VAR 0 2
30820: ARRAY
30821: PPUSH
30822: LD_VAR 0 3
30826: PPUSH
30827: LD_INT 1
30829: PPUSH
30830: LD_INT 0
30832: PPUSH
30833: CALL 56821 0 4
30837: PPUSH
30838: CALL_OW 1
30842: ST_TO_ADDR
// break ;
30843: GO 30847
// end ;
30845: GO 30767
30847: POP
30848: POP
// end ; if mc_build_list [ i ] [ 1 ] [ 1 ] = b_depot or ( depot and CanBeBuilt ( depot , mc_build_list [ i ] [ 1 ] [ 1 ] , mc_build_list [ i ] [ 1 ] [ 2 ] , mc_build_list [ i ] [ 1 ] [ 3 ] , mc_build_list [ i ] [ 1 ] [ 4 ] ) ) then
30849: LD_EXP 79
30853: PUSH
30854: LD_VAR 0 2
30858: ARRAY
30859: PUSH
30860: LD_INT 1
30862: ARRAY
30863: PUSH
30864: LD_INT 1
30866: ARRAY
30867: PUSH
30868: LD_INT 0
30870: EQUAL
30871: PUSH
30872: LD_VAR 0 5
30876: PUSH
30877: LD_VAR 0 5
30881: PPUSH
30882: LD_EXP 79
30886: PUSH
30887: LD_VAR 0 2
30891: ARRAY
30892: PUSH
30893: LD_INT 1
30895: ARRAY
30896: PUSH
30897: LD_INT 1
30899: ARRAY
30900: PPUSH
30901: LD_EXP 79
30905: PUSH
30906: LD_VAR 0 2
30910: ARRAY
30911: PUSH
30912: LD_INT 1
30914: ARRAY
30915: PUSH
30916: LD_INT 2
30918: ARRAY
30919: PPUSH
30920: LD_EXP 79
30924: PUSH
30925: LD_VAR 0 2
30929: ARRAY
30930: PUSH
30931: LD_INT 1
30933: ARRAY
30934: PUSH
30935: LD_INT 3
30937: ARRAY
30938: PPUSH
30939: LD_EXP 79
30943: PUSH
30944: LD_VAR 0 2
30948: ARRAY
30949: PUSH
30950: LD_INT 1
30952: ARRAY
30953: PUSH
30954: LD_INT 4
30956: ARRAY
30957: PPUSH
30958: CALL 64818 0 5
30962: AND
30963: OR
30964: IFFALSE 31245
// begin tmp := UnitFilter ( mc_bases [ i ] , [ f_class , 2 ] ) diff mc_building_repairs [ i ] ;
30966: LD_ADDR_VAR 0 4
30970: PUSH
30971: LD_EXP 74
30975: PUSH
30976: LD_VAR 0 2
30980: ARRAY
30981: PPUSH
30982: LD_INT 25
30984: PUSH
30985: LD_INT 2
30987: PUSH
30988: EMPTY
30989: LIST
30990: LIST
30991: PPUSH
30992: CALL_OW 72
30996: PUSH
30997: LD_EXP 76
31001: PUSH
31002: LD_VAR 0 2
31006: ARRAY
31007: DIFF
31008: ST_TO_ADDR
// if not tmp then
31009: LD_VAR 0 4
31013: NOT
31014: IFFALSE 31018
// continue ;
31016: GO 30263
// for j in tmp do
31018: LD_ADDR_VAR 0 3
31022: PUSH
31023: LD_VAR 0 4
31027: PUSH
31028: FOR_IN
31029: IFFALSE 31241
// begin if not mc_builders [ i ] then
31031: LD_EXP 80
31035: PUSH
31036: LD_VAR 0 2
31040: ARRAY
31041: NOT
31042: IFFALSE 31100
// begin SetTag ( j , 103 ) ;
31044: LD_VAR 0 3
31048: PPUSH
31049: LD_INT 103
31051: PPUSH
31052: CALL_OW 109
// mc_builders := ReplaceIn ( mc_builders , [ i , mc_builders [ i ] + 1 ] , j ) ;
31056: LD_ADDR_EXP 80
31060: PUSH
31061: LD_EXP 80
31065: PPUSH
31066: LD_VAR 0 2
31070: PUSH
31071: LD_EXP 80
31075: PUSH
31076: LD_VAR 0 2
31080: ARRAY
31081: PUSH
31082: LD_INT 1
31084: PLUS
31085: PUSH
31086: EMPTY
31087: LIST
31088: LIST
31089: PPUSH
31090: LD_VAR 0 3
31094: PPUSH
31095: CALL 57403 0 3
31099: ST_TO_ADDR
// end ; if IsInUnit ( j ) then
31100: LD_VAR 0 3
31104: PPUSH
31105: CALL_OW 310
31109: IFFALSE 31120
// ComExitBuilding ( j ) ;
31111: LD_VAR 0 3
31115: PPUSH
31116: CALL_OW 122
// wait ( 3 ) ;
31120: LD_INT 3
31122: PPUSH
31123: CALL_OW 67
// if not mc_build_list [ i ] then
31127: LD_EXP 79
31131: PUSH
31132: LD_VAR 0 2
31136: ARRAY
31137: NOT
31138: IFFALSE 31142
// break ;
31140: GO 31241
// if not HasTask ( j ) then
31142: LD_VAR 0 3
31146: PPUSH
31147: CALL_OW 314
31151: NOT
31152: IFFALSE 31239
// ComBuild ( j , mc_build_list [ i ] [ 1 ] [ 1 ] , mc_build_list [ i ] [ 1 ] [ 2 ] , mc_build_list [ i ] [ 1 ] [ 3 ] , mc_build_list [ i ] [ 1 ] [ 4 ] ) ;
31154: LD_VAR 0 3
31158: PPUSH
31159: LD_EXP 79
31163: PUSH
31164: LD_VAR 0 2
31168: ARRAY
31169: PUSH
31170: LD_INT 1
31172: ARRAY
31173: PUSH
31174: LD_INT 1
31176: ARRAY
31177: PPUSH
31178: LD_EXP 79
31182: PUSH
31183: LD_VAR 0 2
31187: ARRAY
31188: PUSH
31189: LD_INT 1
31191: ARRAY
31192: PUSH
31193: LD_INT 2
31195: ARRAY
31196: PPUSH
31197: LD_EXP 79
31201: PUSH
31202: LD_VAR 0 2
31206: ARRAY
31207: PUSH
31208: LD_INT 1
31210: ARRAY
31211: PUSH
31212: LD_INT 3
31214: ARRAY
31215: PPUSH
31216: LD_EXP 79
31220: PUSH
31221: LD_VAR 0 2
31225: ARRAY
31226: PUSH
31227: LD_INT 1
31229: ARRAY
31230: PUSH
31231: LD_INT 4
31233: ARRAY
31234: PPUSH
31235: CALL_OW 145
// end ;
31239: GO 31028
31241: POP
31242: POP
// end else
31243: GO 31387
// if not TryClearPlaceForBuilding ( mc_bases [ i ] , mc_build_list [ i ] [ 1 ] [ 1 ] , mc_build_list [ i ] [ 1 ] [ 2 ] , mc_build_list [ i ] [ 1 ] [ 3 ] , mc_build_list [ i ] [ 1 ] [ 4 ] ) then
31245: LD_EXP 74
31249: PUSH
31250: LD_VAR 0 2
31254: ARRAY
31255: PPUSH
31256: LD_EXP 79
31260: PUSH
31261: LD_VAR 0 2
31265: ARRAY
31266: PUSH
31267: LD_INT 1
31269: ARRAY
31270: PUSH
31271: LD_INT 1
31273: ARRAY
31274: PPUSH
31275: LD_EXP 79
31279: PUSH
31280: LD_VAR 0 2
31284: ARRAY
31285: PUSH
31286: LD_INT 1
31288: ARRAY
31289: PUSH
31290: LD_INT 2
31292: ARRAY
31293: PPUSH
31294: LD_EXP 79
31298: PUSH
31299: LD_VAR 0 2
31303: ARRAY
31304: PUSH
31305: LD_INT 1
31307: ARRAY
31308: PUSH
31309: LD_INT 3
31311: ARRAY
31312: PPUSH
31313: LD_EXP 79
31317: PUSH
31318: LD_VAR 0 2
31322: ARRAY
31323: PUSH
31324: LD_INT 1
31326: ARRAY
31327: PUSH
31328: LD_INT 4
31330: ARRAY
31331: PPUSH
31332: CALL 64154 0 5
31336: NOT
31337: IFFALSE 31387
// begin mc_build_list := Replace ( mc_build_list , i , Reindex ( mc_build_list [ i ] , 1 , - 1 , false ) ) ;
31339: LD_ADDR_EXP 79
31343: PUSH
31344: LD_EXP 79
31348: PPUSH
31349: LD_VAR 0 2
31353: PPUSH
31354: LD_EXP 79
31358: PUSH
31359: LD_VAR 0 2
31363: ARRAY
31364: PPUSH
31365: LD_INT 1
31367: PPUSH
31368: LD_INT 1
31370: NEG
31371: PPUSH
31372: LD_INT 0
31374: PPUSH
31375: CALL 56821 0 4
31379: PPUSH
31380: CALL_OW 1
31384: ST_TO_ADDR
// continue ;
31385: GO 30263
// end ; end ; end ;
31387: GO 30263
31389: POP
31390: POP
// end ;
31391: LD_VAR 0 1
31395: RET
// export function MC_BuildUpgrade ( ) ; var i , j , tmp , depot , lab ; begin
31396: LD_INT 0
31398: PPUSH
31399: PPUSH
31400: PPUSH
31401: PPUSH
31402: PPUSH
31403: PPUSH
// if not mc_bases then
31404: LD_EXP 74
31408: NOT
31409: IFFALSE 31413
// exit ;
31411: GO 31840
// for i = 1 to mc_bases do
31413: LD_ADDR_VAR 0 2
31417: PUSH
31418: DOUBLE
31419: LD_INT 1
31421: DEC
31422: ST_TO_ADDR
31423: LD_EXP 74
31427: PUSH
31428: FOR_TO
31429: IFFALSE 31838
// begin tmp := mc_build_upgrade [ i ] ;
31431: LD_ADDR_VAR 0 4
31435: PUSH
31436: LD_EXP 106
31440: PUSH
31441: LD_VAR 0 2
31445: ARRAY
31446: ST_TO_ADDR
// lab := UnitFilter ( mc_lab [ i ] , [ f_or , [ f_btype , b_lab ] , [ f_btype , b_lab_half ] ] ) ;
31447: LD_ADDR_VAR 0 6
31451: PUSH
31452: LD_EXP 107
31456: PUSH
31457: LD_VAR 0 2
31461: ARRAY
31462: PPUSH
31463: LD_INT 2
31465: PUSH
31466: LD_INT 30
31468: PUSH
31469: LD_INT 6
31471: PUSH
31472: EMPTY
31473: LIST
31474: LIST
31475: PUSH
31476: LD_INT 30
31478: PUSH
31479: LD_INT 7
31481: PUSH
31482: EMPTY
31483: LIST
31484: LIST
31485: PUSH
31486: EMPTY
31487: LIST
31488: LIST
31489: LIST
31490: PPUSH
31491: CALL_OW 72
31495: ST_TO_ADDR
// if not tmp and not lab then
31496: LD_VAR 0 4
31500: NOT
31501: PUSH
31502: LD_VAR 0 6
31506: NOT
31507: AND
31508: IFFALSE 31512
// continue ;
31510: GO 31428
// if tmp then
31512: LD_VAR 0 4
31516: IFFALSE 31636
// for j in tmp do
31518: LD_ADDR_VAR 0 3
31522: PUSH
31523: LD_VAR 0 4
31527: PUSH
31528: FOR_IN
31529: IFFALSE 31634
// begin if UpgradeCost ( j ) then
31531: LD_VAR 0 3
31535: PPUSH
31536: CALL 63814 0 1
31540: IFFALSE 31632
// begin ComUpgrade ( j ) ;
31542: LD_VAR 0 3
31546: PPUSH
31547: CALL_OW 146
// mc_build_upgrade := Replace ( mc_build_upgrade , i , mc_build_upgrade [ i ] diff j ) ;
31551: LD_ADDR_EXP 106
31555: PUSH
31556: LD_EXP 106
31560: PPUSH
31561: LD_VAR 0 2
31565: PPUSH
31566: LD_EXP 106
31570: PUSH
31571: LD_VAR 0 2
31575: ARRAY
31576: PUSH
31577: LD_VAR 0 3
31581: DIFF
31582: PPUSH
31583: CALL_OW 1
31587: ST_TO_ADDR
// mc_construct_list := ReplaceIn ( mc_construct_list , [ i , mc_construct_list [ i ] + 1 ] , j ) ;
31588: LD_ADDR_EXP 81
31592: PUSH
31593: LD_EXP 81
31597: PPUSH
31598: LD_VAR 0 2
31602: PUSH
31603: LD_EXP 81
31607: PUSH
31608: LD_VAR 0 2
31612: ARRAY
31613: PUSH
31614: LD_INT 1
31616: PLUS
31617: PUSH
31618: EMPTY
31619: LIST
31620: LIST
31621: PPUSH
31622: LD_VAR 0 3
31626: PPUSH
31627: CALL 57403 0 3
31631: ST_TO_ADDR
// end ; end ;
31632: GO 31528
31634: POP
31635: POP
// if not lab or not mc_lab_upgrade [ i ] then
31636: LD_VAR 0 6
31640: NOT
31641: PUSH
31642: LD_EXP 108
31646: PUSH
31647: LD_VAR 0 2
31651: ARRAY
31652: NOT
31653: OR
31654: IFFALSE 31658
// continue ;
31656: GO 31428
// for j in lab do
31658: LD_ADDR_VAR 0 3
31662: PUSH
31663: LD_VAR 0 6
31667: PUSH
31668: FOR_IN
31669: IFFALSE 31834
// begin if GetBType ( j ) in [ b_lab , b_lab_half ] and BuildingStatus ( j ) <> bs_build then
31671: LD_VAR 0 3
31675: PPUSH
31676: CALL_OW 266
31680: PUSH
31681: LD_INT 6
31683: PUSH
31684: LD_INT 7
31686: PUSH
31687: EMPTY
31688: LIST
31689: LIST
31690: IN
31691: PUSH
31692: LD_VAR 0 3
31696: PPUSH
31697: CALL_OW 461
31701: PUSH
31702: LD_INT 1
31704: NONEQUAL
31705: AND
31706: IFFALSE 31832
// begin if UpgradeLabCost ( j , mc_lab_upgrade [ i ] [ 1 ] ) then
31708: LD_VAR 0 3
31712: PPUSH
31713: LD_EXP 108
31717: PUSH
31718: LD_VAR 0 2
31722: ARRAY
31723: PUSH
31724: LD_INT 1
31726: ARRAY
31727: PPUSH
31728: CALL 64019 0 2
31732: IFFALSE 31832
// begin ComCancel ( j ) ;
31734: LD_VAR 0 3
31738: PPUSH
31739: CALL_OW 127
// AddComUpgradeLab ( j , mc_lab_upgrade [ i ] [ 1 ] ) ;
31743: LD_VAR 0 3
31747: PPUSH
31748: LD_EXP 108
31752: PUSH
31753: LD_VAR 0 2
31757: ARRAY
31758: PUSH
31759: LD_INT 1
31761: ARRAY
31762: PPUSH
31763: CALL_OW 207
// if not j in mc_construct_list [ i ] then
31767: LD_VAR 0 3
31771: PUSH
31772: LD_EXP 81
31776: PUSH
31777: LD_VAR 0 2
31781: ARRAY
31782: IN
31783: NOT
31784: IFFALSE 31830
// mc_construct_list := ReplaceIn ( mc_construct_list , [ i , mc_construct_list [ i ] + 1 ] , j ) ;
31786: LD_ADDR_EXP 81
31790: PUSH
31791: LD_EXP 81
31795: PPUSH
31796: LD_VAR 0 2
31800: PUSH
31801: LD_EXP 81
31805: PUSH
31806: LD_VAR 0 2
31810: ARRAY
31811: PUSH
31812: LD_INT 1
31814: PLUS
31815: PUSH
31816: EMPTY
31817: LIST
31818: LIST
31819: PPUSH
31820: LD_VAR 0 3
31824: PPUSH
31825: CALL 57403 0 3
31829: ST_TO_ADDR
// break ;
31830: GO 31834
// end ; end ; end ;
31832: GO 31668
31834: POP
31835: POP
// end ;
31836: GO 31428
31838: POP
31839: POP
// end ;
31840: LD_VAR 0 1
31844: RET
// export function MC_TurretWeapon ( ) ; var i , j , tmp , tmp2 , t , tw , busy , weapon ; begin
31845: LD_INT 0
31847: PPUSH
31848: PPUSH
31849: PPUSH
31850: PPUSH
31851: PPUSH
31852: PPUSH
31853: PPUSH
31854: PPUSH
31855: PPUSH
// if not mc_bases then
31856: LD_EXP 74
31860: NOT
31861: IFFALSE 31865
// exit ;
31863: GO 32270
// for i = 1 to mc_bases do
31865: LD_ADDR_VAR 0 2
31869: PUSH
31870: DOUBLE
31871: LD_INT 1
31873: DEC
31874: ST_TO_ADDR
31875: LD_EXP 74
31879: PUSH
31880: FOR_TO
31881: IFFALSE 32268
// begin if not mc_turret_list [ i ] or not UnitFilter ( mc_bases [ i ] , [ f_btype , b_factory ] ) then
31883: LD_EXP 82
31887: PUSH
31888: LD_VAR 0 2
31892: ARRAY
31893: NOT
31894: PUSH
31895: LD_EXP 74
31899: PUSH
31900: LD_VAR 0 2
31904: ARRAY
31905: PPUSH
31906: LD_INT 30
31908: PUSH
31909: LD_INT 3
31911: PUSH
31912: EMPTY
31913: LIST
31914: LIST
31915: PPUSH
31916: CALL_OW 72
31920: NOT
31921: OR
31922: IFFALSE 31926
// continue ;
31924: GO 31880
// busy := false ;
31926: LD_ADDR_VAR 0 8
31930: PUSH
31931: LD_INT 0
31933: ST_TO_ADDR
// tmp := UnitFilter ( mc_bases [ i ] , [ f_btype , b_factory ] ) ;
31934: LD_ADDR_VAR 0 4
31938: PUSH
31939: LD_EXP 74
31943: PUSH
31944: LD_VAR 0 2
31948: ARRAY
31949: PPUSH
31950: LD_INT 30
31952: PUSH
31953: LD_INT 3
31955: PUSH
31956: EMPTY
31957: LIST
31958: LIST
31959: PPUSH
31960: CALL_OW 72
31964: ST_TO_ADDR
// t := UnitFilter ( mc_turret_list [ i ] , [ f_or , [ f_btype , b_bunker ] , [ f_btype , b_turret ] ] ) ;
31965: LD_ADDR_VAR 0 6
31969: PUSH
31970: LD_EXP 82
31974: PUSH
31975: LD_VAR 0 2
31979: ARRAY
31980: PPUSH
31981: LD_INT 2
31983: PUSH
31984: LD_INT 30
31986: PUSH
31987: LD_INT 32
31989: PUSH
31990: EMPTY
31991: LIST
31992: LIST
31993: PUSH
31994: LD_INT 30
31996: PUSH
31997: LD_INT 33
31999: PUSH
32000: EMPTY
32001: LIST
32002: LIST
32003: PUSH
32004: EMPTY
32005: LIST
32006: LIST
32007: LIST
32008: PPUSH
32009: CALL_OW 72
32013: ST_TO_ADDR
// if not t then
32014: LD_VAR 0 6
32018: NOT
32019: IFFALSE 32023
// continue ;
32021: GO 31880
// for j in tmp do
32023: LD_ADDR_VAR 0 3
32027: PUSH
32028: LD_VAR 0 4
32032: PUSH
32033: FOR_IN
32034: IFFALSE 32064
// if not BuildingStatus ( j ) = bs_idle then
32036: LD_VAR 0 3
32040: PPUSH
32041: CALL_OW 461
32045: PUSH
32046: LD_INT 2
32048: EQUAL
32049: NOT
32050: IFFALSE 32062
// begin busy := true ;
32052: LD_ADDR_VAR 0 8
32056: PUSH
32057: LD_INT 1
32059: ST_TO_ADDR
// break ;
32060: GO 32064
// end ;
32062: GO 32033
32064: POP
32065: POP
// if busy then
32066: LD_VAR 0 8
32070: IFFALSE 32074
// continue ;
32072: GO 31880
// tw := UnitFilter ( t , [ f_bweapon , 0 ] ) ;
32074: LD_ADDR_VAR 0 7
32078: PUSH
32079: LD_VAR 0 6
32083: PPUSH
32084: LD_INT 35
32086: PUSH
32087: LD_INT 0
32089: PUSH
32090: EMPTY
32091: LIST
32092: LIST
32093: PPUSH
32094: CALL_OW 72
32098: ST_TO_ADDR
// if tw then
32099: LD_VAR 0 7
32103: IFFALSE 32180
// begin tw := tw [ 1 ] ;
32105: LD_ADDR_VAR 0 7
32109: PUSH
32110: LD_VAR 0 7
32114: PUSH
32115: LD_INT 1
32117: ARRAY
32118: ST_TO_ADDR
// weapon := GetTurretWeapon ( tw , mc_scan_area [ i ] ) ;
32119: LD_ADDR_VAR 0 9
32123: PUSH
32124: LD_VAR 0 7
32128: PPUSH
32129: LD_EXP 99
32133: PUSH
32134: LD_VAR 0 2
32138: ARRAY
32139: PPUSH
32140: CALL 62373 0 2
32144: ST_TO_ADDR
// if mc_allowed_tower_weapons [ i ] then
32145: LD_EXP 113
32149: PUSH
32150: LD_VAR 0 2
32154: ARRAY
32155: IFFALSE 32178
// if not weapon in mc_allowed_tower_weapons [ i ] then
32157: LD_VAR 0 9
32161: PUSH
32162: LD_EXP 113
32166: PUSH
32167: LD_VAR 0 2
32171: ARRAY
32172: IN
32173: NOT
32174: IFFALSE 32178
// continue ;
32176: GO 31880
// end else
32178: GO 32243
// begin tmp2 := UpgradeTurretsWeapon ( mc_turret_list [ i ] , tmp ) ;
32180: LD_ADDR_VAR 0 5
32184: PUSH
32185: LD_EXP 82
32189: PUSH
32190: LD_VAR 0 2
32194: ARRAY
32195: PPUSH
32196: LD_VAR 0 4
32200: PPUSH
32201: CALL 92574 0 2
32205: ST_TO_ADDR
// if not tmp2 then
32206: LD_VAR 0 5
32210: NOT
32211: IFFALSE 32215
// continue ;
32213: GO 31880
// tw := tmp2 [ 1 ] ;
32215: LD_ADDR_VAR 0 7
32219: PUSH
32220: LD_VAR 0 5
32224: PUSH
32225: LD_INT 1
32227: ARRAY
32228: ST_TO_ADDR
// weapon := tmp2 [ 2 ] ;
32229: LD_ADDR_VAR 0 9
32233: PUSH
32234: LD_VAR 0 5
32238: PUSH
32239: LD_INT 2
32241: ARRAY
32242: ST_TO_ADDR
// end ; if not weapon then
32243: LD_VAR 0 9
32247: NOT
32248: IFFALSE 32252
// continue ;
32250: GO 31880
// ComPlaceWeapon ( tw , weapon ) ;
32252: LD_VAR 0 7
32256: PPUSH
32257: LD_VAR 0 9
32261: PPUSH
32262: CALL_OW 148
// end ;
32266: GO 31880
32268: POP
32269: POP
// end ;
32270: LD_VAR 0 1
32274: RET
// export function MC_PlantMines ( ) ; var i , j , k , tmp , list ; begin
32275: LD_INT 0
32277: PPUSH
32278: PPUSH
32279: PPUSH
32280: PPUSH
32281: PPUSH
32282: PPUSH
// if not mc_bases then
32283: LD_EXP 74
32287: NOT
32288: IFFALSE 32292
// exit ;
32290: GO 33304
// for i = 1 to mc_bases do
32292: LD_ADDR_VAR 0 2
32296: PUSH
32297: DOUBLE
32298: LD_INT 1
32300: DEC
32301: ST_TO_ADDR
32302: LD_EXP 74
32306: PUSH
32307: FOR_TO
32308: IFFALSE 33302
// begin if not mc_mines [ i ] or mc_mines [ i ] = mc_miners [ i ] then
32310: LD_EXP 87
32314: PUSH
32315: LD_VAR 0 2
32319: ARRAY
32320: NOT
32321: PUSH
32322: LD_EXP 87
32326: PUSH
32327: LD_VAR 0 2
32331: ARRAY
32332: PUSH
32333: LD_EXP 88
32337: PUSH
32338: LD_VAR 0 2
32342: ARRAY
32343: EQUAL
32344: OR
32345: IFFALSE 32349
// continue ;
32347: GO 32307
// if mc_miners [ i ] then
32349: LD_EXP 88
32353: PUSH
32354: LD_VAR 0 2
32358: ARRAY
32359: IFFALSE 32989
// begin k := 1 ;
32361: LD_ADDR_VAR 0 4
32365: PUSH
32366: LD_INT 1
32368: ST_TO_ADDR
// for j = mc_miners [ i ] downto 1 do
32369: LD_ADDR_VAR 0 3
32373: PUSH
32374: DOUBLE
32375: LD_EXP 88
32379: PUSH
32380: LD_VAR 0 2
32384: ARRAY
32385: INC
32386: ST_TO_ADDR
32387: LD_INT 1
32389: PUSH
32390: FOR_DOWNTO
32391: IFFALSE 32987
// begin if IsDead ( mc_miners [ i ] [ j ] ) or GetClass ( mc_miners [ i ] [ j ] ) <> 1 then
32393: LD_EXP 88
32397: PUSH
32398: LD_VAR 0 2
32402: ARRAY
32403: PUSH
32404: LD_VAR 0 3
32408: ARRAY
32409: PPUSH
32410: CALL_OW 301
32414: PUSH
32415: LD_EXP 88
32419: PUSH
32420: LD_VAR 0 2
32424: ARRAY
32425: PUSH
32426: LD_VAR 0 3
32430: ARRAY
32431: PPUSH
32432: CALL_OW 257
32436: PUSH
32437: LD_INT 1
32439: NONEQUAL
32440: OR
32441: IFFALSE 32504
// begin tmp := mc_miners [ i ] diff mc_miners [ i ] [ j ] ;
32443: LD_ADDR_VAR 0 5
32447: PUSH
32448: LD_EXP 88
32452: PUSH
32453: LD_VAR 0 2
32457: ARRAY
32458: PUSH
32459: LD_EXP 88
32463: PUSH
32464: LD_VAR 0 2
32468: ARRAY
32469: PUSH
32470: LD_VAR 0 3
32474: ARRAY
32475: DIFF
32476: ST_TO_ADDR
// mc_miners := Replace ( mc_miners , i , tmp ) ;
32477: LD_ADDR_EXP 88
32481: PUSH
32482: LD_EXP 88
32486: PPUSH
32487: LD_VAR 0 2
32491: PPUSH
32492: LD_VAR 0 5
32496: PPUSH
32497: CALL_OW 1
32501: ST_TO_ADDR
// continue ;
32502: GO 32390
// end ; if WantPlant ( mc_miners [ i ] [ j ] ) and ( DangerAtRangeXY ( GetSide ( mc_miners [ i ] [ j ] ) , mc_mines [ i ] [ k ] [ 1 ] , mc_mines [ i ] [ k ] [ 2 ] , 15 ) [ 4 ] or DangerAtRange ( mc_miners [ i ] [ j ] , 10 ) [ 4 ] ) then
32504: LD_EXP 88
32508: PUSH
32509: LD_VAR 0 2
32513: ARRAY
32514: PUSH
32515: LD_VAR 0 3
32519: ARRAY
32520: PPUSH
32521: CALL 57339 0 1
32525: PUSH
32526: LD_EXP 88
32530: PUSH
32531: LD_VAR 0 2
32535: ARRAY
32536: PUSH
32537: LD_VAR 0 3
32541: ARRAY
32542: PPUSH
32543: CALL_OW 255
32547: PPUSH
32548: LD_EXP 87
32552: PUSH
32553: LD_VAR 0 2
32557: ARRAY
32558: PUSH
32559: LD_VAR 0 4
32563: ARRAY
32564: PUSH
32565: LD_INT 1
32567: ARRAY
32568: PPUSH
32569: LD_EXP 87
32573: PUSH
32574: LD_VAR 0 2
32578: ARRAY
32579: PUSH
32580: LD_VAR 0 4
32584: ARRAY
32585: PUSH
32586: LD_INT 2
32588: ARRAY
32589: PPUSH
32590: LD_INT 15
32592: PPUSH
32593: CALL 58299 0 4
32597: PUSH
32598: LD_INT 4
32600: ARRAY
32601: PUSH
32602: LD_EXP 88
32606: PUSH
32607: LD_VAR 0 2
32611: ARRAY
32612: PUSH
32613: LD_VAR 0 3
32617: ARRAY
32618: PPUSH
32619: LD_INT 10
32621: PPUSH
32622: CALL 59996 0 2
32626: PUSH
32627: LD_INT 4
32629: ARRAY
32630: OR
32631: AND
32632: IFFALSE 32655
// ComStop ( mc_miners [ i ] [ j ] ) ;
32634: LD_EXP 88
32638: PUSH
32639: LD_VAR 0 2
32643: ARRAY
32644: PUSH
32645: LD_VAR 0 3
32649: ARRAY
32650: PPUSH
32651: CALL_OW 141
// if GetClass ( mc_miners [ i ] [ j ] ) = 1 and not MineOfUnit ( mc_miners [ i ] [ j ] ) and DangerAtRangeXY ( GetSide ( mc_miners [ i ] [ j ] ) , mc_mines [ i ] [ k ] [ 1 ] , mc_mines [ i ] [ k ] [ 2 ] , 15 ) [ 4 ] = 0 and not HasTask ( mc_miners [ i ] [ j ] ) then
32655: LD_EXP 88
32659: PUSH
32660: LD_VAR 0 2
32664: ARRAY
32665: PUSH
32666: LD_VAR 0 3
32670: ARRAY
32671: PPUSH
32672: CALL_OW 257
32676: PUSH
32677: LD_INT 1
32679: EQUAL
32680: PUSH
32681: LD_EXP 88
32685: PUSH
32686: LD_VAR 0 2
32690: ARRAY
32691: PUSH
32692: LD_VAR 0 3
32696: ARRAY
32697: PPUSH
32698: CALL_OW 459
32702: NOT
32703: AND
32704: PUSH
32705: LD_EXP 88
32709: PUSH
32710: LD_VAR 0 2
32714: ARRAY
32715: PUSH
32716: LD_VAR 0 3
32720: ARRAY
32721: PPUSH
32722: CALL_OW 255
32726: PPUSH
32727: LD_EXP 87
32731: PUSH
32732: LD_VAR 0 2
32736: ARRAY
32737: PUSH
32738: LD_VAR 0 4
32742: ARRAY
32743: PUSH
32744: LD_INT 1
32746: ARRAY
32747: PPUSH
32748: LD_EXP 87
32752: PUSH
32753: LD_VAR 0 2
32757: ARRAY
32758: PUSH
32759: LD_VAR 0 4
32763: ARRAY
32764: PUSH
32765: LD_INT 2
32767: ARRAY
32768: PPUSH
32769: LD_INT 15
32771: PPUSH
32772: CALL 58299 0 4
32776: PUSH
32777: LD_INT 4
32779: ARRAY
32780: PUSH
32781: LD_INT 0
32783: EQUAL
32784: AND
32785: PUSH
32786: LD_EXP 88
32790: PUSH
32791: LD_VAR 0 2
32795: ARRAY
32796: PUSH
32797: LD_VAR 0 3
32801: ARRAY
32802: PPUSH
32803: CALL_OW 314
32807: NOT
32808: AND
32809: IFFALSE 32985
// begin if IsInUnit ( mc_miners [ i ] [ j ] ) then
32811: LD_EXP 88
32815: PUSH
32816: LD_VAR 0 2
32820: ARRAY
32821: PUSH
32822: LD_VAR 0 3
32826: ARRAY
32827: PPUSH
32828: CALL_OW 310
32832: IFFALSE 32855
// ComExitBuilding ( mc_miners [ i ] [ j ] ) ;
32834: LD_EXP 88
32838: PUSH
32839: LD_VAR 0 2
32843: ARRAY
32844: PUSH
32845: LD_VAR 0 3
32849: ARRAY
32850: PPUSH
32851: CALL_OW 122
// if not HasTask ( mc_miners [ i ] [ j ] ) then
32855: LD_EXP 88
32859: PUSH
32860: LD_VAR 0 2
32864: ARRAY
32865: PUSH
32866: LD_VAR 0 3
32870: ARRAY
32871: PPUSH
32872: CALL_OW 314
32876: NOT
32877: IFFALSE 32945
// AddComPlaceRemoteCharge ( mc_miners [ i ] [ j ] , mc_mines [ i ] [ k ] [ 1 ] , mc_mines [ i ] [ k ] [ 2 ] , 0 ) ;
32879: LD_EXP 88
32883: PUSH
32884: LD_VAR 0 2
32888: ARRAY
32889: PUSH
32890: LD_VAR 0 3
32894: ARRAY
32895: PPUSH
32896: LD_EXP 87
32900: PUSH
32901: LD_VAR 0 2
32905: ARRAY
32906: PUSH
32907: LD_VAR 0 4
32911: ARRAY
32912: PUSH
32913: LD_INT 1
32915: ARRAY
32916: PPUSH
32917: LD_EXP 87
32921: PUSH
32922: LD_VAR 0 2
32926: ARRAY
32927: PUSH
32928: LD_VAR 0 4
32932: ARRAY
32933: PUSH
32934: LD_INT 2
32936: ARRAY
32937: PPUSH
32938: LD_INT 0
32940: PPUSH
32941: CALL_OW 193
// k := k + 1 ;
32945: LD_ADDR_VAR 0 4
32949: PUSH
32950: LD_VAR 0 4
32954: PUSH
32955: LD_INT 1
32957: PLUS
32958: ST_TO_ADDR
// if k > mc_mines [ i ] then
32959: LD_VAR 0 4
32963: PUSH
32964: LD_EXP 87
32968: PUSH
32969: LD_VAR 0 2
32973: ARRAY
32974: GREATER
32975: IFFALSE 32985
// k := 1 ;
32977: LD_ADDR_VAR 0 4
32981: PUSH
32982: LD_INT 1
32984: ST_TO_ADDR
// end ; end ;
32985: GO 32390
32987: POP
32988: POP
// end ; tmp := UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_armoury ] , [ f_btype , b_barracks ] , [ f_btype , b_bunker ] ] ) ;
32989: LD_ADDR_VAR 0 5
32993: PUSH
32994: LD_EXP 74
32998: PUSH
32999: LD_VAR 0 2
33003: ARRAY
33004: PPUSH
33005: LD_INT 2
33007: PUSH
33008: LD_INT 30
33010: PUSH
33011: LD_INT 4
33013: PUSH
33014: EMPTY
33015: LIST
33016: LIST
33017: PUSH
33018: LD_INT 30
33020: PUSH
33021: LD_INT 5
33023: PUSH
33024: EMPTY
33025: LIST
33026: LIST
33027: PUSH
33028: LD_INT 30
33030: PUSH
33031: LD_INT 32
33033: PUSH
33034: EMPTY
33035: LIST
33036: LIST
33037: PUSH
33038: EMPTY
33039: LIST
33040: LIST
33041: LIST
33042: LIST
33043: PPUSH
33044: CALL_OW 72
33048: ST_TO_ADDR
// if not tmp then
33049: LD_VAR 0 5
33053: NOT
33054: IFFALSE 33058
// continue ;
33056: GO 32307
// list := [ ] ;
33058: LD_ADDR_VAR 0 6
33062: PUSH
33063: EMPTY
33064: ST_TO_ADDR
// for j in tmp do
33065: LD_ADDR_VAR 0 3
33069: PUSH
33070: LD_VAR 0 5
33074: PUSH
33075: FOR_IN
33076: IFFALSE 33145
// begin for k in UnitsInside ( j ) do
33078: LD_ADDR_VAR 0 4
33082: PUSH
33083: LD_VAR 0 3
33087: PPUSH
33088: CALL_OW 313
33092: PUSH
33093: FOR_IN
33094: IFFALSE 33141
// if GetClass ( k ) = 1 and not MineOfUnit ( k ) then
33096: LD_VAR 0 4
33100: PPUSH
33101: CALL_OW 257
33105: PUSH
33106: LD_INT 1
33108: EQUAL
33109: PUSH
33110: LD_VAR 0 4
33114: PPUSH
33115: CALL_OW 459
33119: NOT
33120: AND
33121: IFFALSE 33139
// list := list ^ k ;
33123: LD_ADDR_VAR 0 6
33127: PUSH
33128: LD_VAR 0 6
33132: PUSH
33133: LD_VAR 0 4
33137: ADD
33138: ST_TO_ADDR
33139: GO 33093
33141: POP
33142: POP
// end ;
33143: GO 33075
33145: POP
33146: POP
// list := list diff mc_miners [ i ] ;
33147: LD_ADDR_VAR 0 6
33151: PUSH
33152: LD_VAR 0 6
33156: PUSH
33157: LD_EXP 88
33161: PUSH
33162: LD_VAR 0 2
33166: ARRAY
33167: DIFF
33168: ST_TO_ADDR
// if not list then
33169: LD_VAR 0 6
33173: NOT
33174: IFFALSE 33178
// continue ;
33176: GO 32307
// k := mc_mines [ i ] - mc_miners [ i ] ;
33178: LD_ADDR_VAR 0 4
33182: PUSH
33183: LD_EXP 87
33187: PUSH
33188: LD_VAR 0 2
33192: ARRAY
33193: PUSH
33194: LD_EXP 88
33198: PUSH
33199: LD_VAR 0 2
33203: ARRAY
33204: MINUS
33205: ST_TO_ADDR
// if k > list then
33206: LD_VAR 0 4
33210: PUSH
33211: LD_VAR 0 6
33215: GREATER
33216: IFFALSE 33228
// k := list ;
33218: LD_ADDR_VAR 0 4
33222: PUSH
33223: LD_VAR 0 6
33227: ST_TO_ADDR
// for j = 1 to k do
33228: LD_ADDR_VAR 0 3
33232: PUSH
33233: DOUBLE
33234: LD_INT 1
33236: DEC
33237: ST_TO_ADDR
33238: LD_VAR 0 4
33242: PUSH
33243: FOR_TO
33244: IFFALSE 33298
// mc_miners := ReplaceIn ( mc_miners , [ i , mc_miners [ i ] + 1 ] , list [ j ] ) ;
33246: LD_ADDR_EXP 88
33250: PUSH
33251: LD_EXP 88
33255: PPUSH
33256: LD_VAR 0 2
33260: PUSH
33261: LD_EXP 88
33265: PUSH
33266: LD_VAR 0 2
33270: ARRAY
33271: PUSH
33272: LD_INT 1
33274: PLUS
33275: PUSH
33276: EMPTY
33277: LIST
33278: LIST
33279: PPUSH
33280: LD_VAR 0 6
33284: PUSH
33285: LD_VAR 0 3
33289: ARRAY
33290: PPUSH
33291: CALL 57403 0 3
33295: ST_TO_ADDR
33296: GO 33243
33298: POP
33299: POP
// end ;
33300: GO 32307
33302: POP
33303: POP
// end ;
33304: LD_VAR 0 1
33308: RET
// export function MC_CollectCrates ( ) ; var i , j , k , tmp , target , cargo , depot , fac , components ; begin
33309: LD_INT 0
33311: PPUSH
33312: PPUSH
33313: PPUSH
33314: PPUSH
33315: PPUSH
33316: PPUSH
33317: PPUSH
33318: PPUSH
33319: PPUSH
33320: PPUSH
// if not mc_bases then
33321: LD_EXP 74
33325: NOT
33326: IFFALSE 33330
// exit ;
33328: GO 35080
// for i = 1 to mc_bases do
33330: LD_ADDR_VAR 0 2
33334: PUSH
33335: DOUBLE
33336: LD_INT 1
33338: DEC
33339: ST_TO_ADDR
33340: LD_EXP 74
33344: PUSH
33345: FOR_TO
33346: IFFALSE 35078
// begin if not mc_bases [ i ] or mc_construct_list [ i ] then
33348: LD_EXP 74
33352: PUSH
33353: LD_VAR 0 2
33357: ARRAY
33358: NOT
33359: PUSH
33360: LD_EXP 81
33364: PUSH
33365: LD_VAR 0 2
33369: ARRAY
33370: OR
33371: IFFALSE 33375
// continue ;
33373: GO 33345
// if not mc_crates [ i ] and mc_crates_collector [ i ] then
33375: LD_EXP 90
33379: PUSH
33380: LD_VAR 0 2
33384: ARRAY
33385: NOT
33386: PUSH
33387: LD_EXP 91
33391: PUSH
33392: LD_VAR 0 2
33396: ARRAY
33397: AND
33398: IFFALSE 33436
// begin mc_crates_collector := Replace ( mc_crates_collector , i , [ ] ) ;
33400: LD_ADDR_EXP 91
33404: PUSH
33405: LD_EXP 91
33409: PPUSH
33410: LD_VAR 0 2
33414: PPUSH
33415: EMPTY
33416: PPUSH
33417: CALL_OW 1
33421: ST_TO_ADDR
// MC_Reset ( i , 107 ) ;
33422: LD_VAR 0 2
33426: PPUSH
33427: LD_INT 107
33429: PPUSH
33430: CALL 24190 0 2
// continue ;
33434: GO 33345
// end ; target := [ ] ;
33436: LD_ADDR_VAR 0 6
33440: PUSH
33441: EMPTY
33442: ST_TO_ADDR
// for j = mc_crates [ i ] downto 1 do
33443: LD_ADDR_VAR 0 3
33447: PUSH
33448: DOUBLE
33449: LD_EXP 90
33453: PUSH
33454: LD_VAR 0 2
33458: ARRAY
33459: INC
33460: ST_TO_ADDR
33461: LD_INT 1
33463: PUSH
33464: FOR_DOWNTO
33465: IFFALSE 33725
// begin if ValidHex ( mc_crates [ i ] [ j ] [ 2 ] , mc_crates [ i ] [ j ] [ 3 ] ) and GetResourceAmountXY ( mc_crates [ i ] [ j ] [ 2 ] , mc_crates [ i ] [ j ] [ 3 ] ) = 0 then
33467: LD_EXP 90
33471: PUSH
33472: LD_VAR 0 2
33476: ARRAY
33477: PUSH
33478: LD_VAR 0 3
33482: ARRAY
33483: PUSH
33484: LD_INT 2
33486: ARRAY
33487: PPUSH
33488: LD_EXP 90
33492: PUSH
33493: LD_VAR 0 2
33497: ARRAY
33498: PUSH
33499: LD_VAR 0 3
33503: ARRAY
33504: PUSH
33505: LD_INT 3
33507: ARRAY
33508: PPUSH
33509: CALL_OW 488
33513: PUSH
33514: LD_EXP 90
33518: PUSH
33519: LD_VAR 0 2
33523: ARRAY
33524: PUSH
33525: LD_VAR 0 3
33529: ARRAY
33530: PUSH
33531: LD_INT 2
33533: ARRAY
33534: PPUSH
33535: LD_EXP 90
33539: PUSH
33540: LD_VAR 0 2
33544: ARRAY
33545: PUSH
33546: LD_VAR 0 3
33550: ARRAY
33551: PUSH
33552: LD_INT 3
33554: ARRAY
33555: PPUSH
33556: CALL_OW 284
33560: PUSH
33561: LD_INT 0
33563: EQUAL
33564: AND
33565: IFFALSE 33620
// begin tmp := Delete ( mc_crates [ i ] , j ) ;
33567: LD_ADDR_VAR 0 5
33571: PUSH
33572: LD_EXP 90
33576: PUSH
33577: LD_VAR 0 2
33581: ARRAY
33582: PPUSH
33583: LD_VAR 0 3
33587: PPUSH
33588: CALL_OW 3
33592: ST_TO_ADDR
// mc_crates := Replace ( mc_crates , i , tmp ) ;
33593: LD_ADDR_EXP 90
33597: PUSH
33598: LD_EXP 90
33602: PPUSH
33603: LD_VAR 0 2
33607: PPUSH
33608: LD_VAR 0 5
33612: PPUSH
33613: CALL_OW 1
33617: ST_TO_ADDR
// continue ;
33618: GO 33464
// end ; if DangerAtRangeXY ( GetSide ( mc_bases [ i ] [ 1 ] ) , mc_crates [ i ] [ j ] [ 2 ] , mc_crates [ i ] [ j ] [ 3 ] , 30 ) [ 4 ] = 0 then
33620: LD_EXP 74
33624: PUSH
33625: LD_VAR 0 2
33629: ARRAY
33630: PUSH
33631: LD_INT 1
33633: ARRAY
33634: PPUSH
33635: CALL_OW 255
33639: PPUSH
33640: LD_EXP 90
33644: PUSH
33645: LD_VAR 0 2
33649: ARRAY
33650: PUSH
33651: LD_VAR 0 3
33655: ARRAY
33656: PUSH
33657: LD_INT 2
33659: ARRAY
33660: PPUSH
33661: LD_EXP 90
33665: PUSH
33666: LD_VAR 0 2
33670: ARRAY
33671: PUSH
33672: LD_VAR 0 3
33676: ARRAY
33677: PUSH
33678: LD_INT 3
33680: ARRAY
33681: PPUSH
33682: LD_INT 30
33684: PPUSH
33685: CALL 58299 0 4
33689: PUSH
33690: LD_INT 4
33692: ARRAY
33693: PUSH
33694: LD_INT 0
33696: EQUAL
33697: IFFALSE 33723
// begin target := mc_crates [ i ] [ j ] ;
33699: LD_ADDR_VAR 0 6
33703: PUSH
33704: LD_EXP 90
33708: PUSH
33709: LD_VAR 0 2
33713: ARRAY
33714: PUSH
33715: LD_VAR 0 3
33719: ARRAY
33720: ST_TO_ADDR
// break ;
33721: GO 33725
// end ; end ;
33723: GO 33464
33725: POP
33726: POP
// if not target then
33727: LD_VAR 0 6
33731: NOT
33732: IFFALSE 33736
// continue ;
33734: GO 33345
// cargo := UnitFilter ( mc_vehicles [ i ] , [ [ f_or , [ f_not , [ f_empty ] ] , [ f_linked ] , [ f_control , control_apeman ] , [ f_control , control_computer ] ] , [ f_or , [ f_weapon , ar_cargo_bay ] , [ f_weapon , ru_cargo_bay ] , [ f_weapon , us_cargo_bay ] ] ] ) ;
33736: LD_ADDR_VAR 0 7
33740: PUSH
33741: LD_EXP 93
33745: PUSH
33746: LD_VAR 0 2
33750: ARRAY
33751: PPUSH
33752: LD_INT 2
33754: PUSH
33755: LD_INT 3
33757: PUSH
33758: LD_INT 58
33760: PUSH
33761: EMPTY
33762: LIST
33763: PUSH
33764: EMPTY
33765: LIST
33766: LIST
33767: PUSH
33768: LD_INT 61
33770: PUSH
33771: EMPTY
33772: LIST
33773: PUSH
33774: LD_INT 33
33776: PUSH
33777: LD_INT 5
33779: PUSH
33780: EMPTY
33781: LIST
33782: LIST
33783: PUSH
33784: LD_INT 33
33786: PUSH
33787: LD_INT 3
33789: PUSH
33790: EMPTY
33791: LIST
33792: LIST
33793: PUSH
33794: EMPTY
33795: LIST
33796: LIST
33797: LIST
33798: LIST
33799: LIST
33800: PUSH
33801: LD_INT 2
33803: PUSH
33804: LD_INT 34
33806: PUSH
33807: LD_INT 32
33809: PUSH
33810: EMPTY
33811: LIST
33812: LIST
33813: PUSH
33814: LD_INT 34
33816: PUSH
33817: LD_INT 51
33819: PUSH
33820: EMPTY
33821: LIST
33822: LIST
33823: PUSH
33824: LD_INT 34
33826: PUSH
33827: LD_INT 12
33829: PUSH
33830: EMPTY
33831: LIST
33832: LIST
33833: PUSH
33834: EMPTY
33835: LIST
33836: LIST
33837: LIST
33838: LIST
33839: PUSH
33840: EMPTY
33841: LIST
33842: LIST
33843: PPUSH
33844: CALL_OW 72
33848: ST_TO_ADDR
// if not cargo then
33849: LD_VAR 0 7
33853: NOT
33854: IFFALSE 34497
// begin if mc_crates_collector [ i ] < 5 then
33856: LD_EXP 91
33860: PUSH
33861: LD_VAR 0 2
33865: ARRAY
33866: PUSH
33867: LD_INT 5
33869: LESS
33870: IFFALSE 34236
// begin if mc_ape [ i ] then
33872: LD_EXP 103
33876: PUSH
33877: LD_VAR 0 2
33881: ARRAY
33882: IFFALSE 33929
// tmp := UnitFilter ( mc_ape [ i ] , [ [ f_class , 16 ] , [ f_lives , 750 ] ] ) ;
33884: LD_ADDR_VAR 0 5
33888: PUSH
33889: LD_EXP 103
33893: PUSH
33894: LD_VAR 0 2
33898: ARRAY
33899: PPUSH
33900: LD_INT 25
33902: PUSH
33903: LD_INT 16
33905: PUSH
33906: EMPTY
33907: LIST
33908: LIST
33909: PUSH
33910: LD_INT 24
33912: PUSH
33913: LD_INT 750
33915: PUSH
33916: EMPTY
33917: LIST
33918: LIST
33919: PUSH
33920: EMPTY
33921: LIST
33922: LIST
33923: PPUSH
33924: CALL_OW 72
33928: ST_TO_ADDR
// if not tmp then
33929: LD_VAR 0 5
33933: NOT
33934: IFFALSE 33981
// tmp := UnitFilter ( mc_bases [ i ] , [ [ f_class , 2 ] , [ f_lives , 750 ] ] ) ;
33936: LD_ADDR_VAR 0 5
33940: PUSH
33941: LD_EXP 74
33945: PUSH
33946: LD_VAR 0 2
33950: ARRAY
33951: PPUSH
33952: LD_INT 25
33954: PUSH
33955: LD_INT 2
33957: PUSH
33958: EMPTY
33959: LIST
33960: LIST
33961: PUSH
33962: LD_INT 24
33964: PUSH
33965: LD_INT 750
33967: PUSH
33968: EMPTY
33969: LIST
33970: LIST
33971: PUSH
33972: EMPTY
33973: LIST
33974: LIST
33975: PPUSH
33976: CALL_OW 72
33980: ST_TO_ADDR
// if mc_ape [ i ] and UnitFilter ( mc_bases [ i ] , [ [ f_class , 2 ] , [ f_lives , 750 ] ] ) and tmp < 5 then
33981: LD_EXP 103
33985: PUSH
33986: LD_VAR 0 2
33990: ARRAY
33991: PUSH
33992: LD_EXP 74
33996: PUSH
33997: LD_VAR 0 2
34001: ARRAY
34002: PPUSH
34003: LD_INT 25
34005: PUSH
34006: LD_INT 2
34008: PUSH
34009: EMPTY
34010: LIST
34011: LIST
34012: PUSH
34013: LD_INT 24
34015: PUSH
34016: LD_INT 750
34018: PUSH
34019: EMPTY
34020: LIST
34021: LIST
34022: PUSH
34023: EMPTY
34024: LIST
34025: LIST
34026: PPUSH
34027: CALL_OW 72
34031: AND
34032: PUSH
34033: LD_VAR 0 5
34037: PUSH
34038: LD_INT 5
34040: LESS
34041: AND
34042: IFFALSE 34124
// begin for j in UnitFilter ( mc_bases [ i ] , [ [ f_class , 2 ] , [ f_lives , 750 ] ] ) do
34044: LD_ADDR_VAR 0 3
34048: PUSH
34049: LD_EXP 74
34053: PUSH
34054: LD_VAR 0 2
34058: ARRAY
34059: PPUSH
34060: LD_INT 25
34062: PUSH
34063: LD_INT 2
34065: PUSH
34066: EMPTY
34067: LIST
34068: LIST
34069: PUSH
34070: LD_INT 24
34072: PUSH
34073: LD_INT 750
34075: PUSH
34076: EMPTY
34077: LIST
34078: LIST
34079: PUSH
34080: EMPTY
34081: LIST
34082: LIST
34083: PPUSH
34084: CALL_OW 72
34088: PUSH
34089: FOR_IN
34090: IFFALSE 34122
// begin tmp := tmp union j ;
34092: LD_ADDR_VAR 0 5
34096: PUSH
34097: LD_VAR 0 5
34101: PUSH
34102: LD_VAR 0 3
34106: UNION
34107: ST_TO_ADDR
// if tmp >= 5 then
34108: LD_VAR 0 5
34112: PUSH
34113: LD_INT 5
34115: GREATEREQUAL
34116: IFFALSE 34120
// break ;
34118: GO 34122
// end ;
34120: GO 34089
34122: POP
34123: POP
// end ; if not tmp then
34124: LD_VAR 0 5
34128: NOT
34129: IFFALSE 34133
// continue ;
34131: GO 33345
// for j in tmp do
34133: LD_ADDR_VAR 0 3
34137: PUSH
34138: LD_VAR 0 5
34142: PUSH
34143: FOR_IN
34144: IFFALSE 34234
// if not GetTag ( j ) then
34146: LD_VAR 0 3
34150: PPUSH
34151: CALL_OW 110
34155: NOT
34156: IFFALSE 34232
// begin mc_crates_collector := ReplaceIn ( mc_crates_collector , [ i , mc_crates_collector [ i ] + 1 ] , j ) ;
34158: LD_ADDR_EXP 91
34162: PUSH
34163: LD_EXP 91
34167: PPUSH
34168: LD_VAR 0 2
34172: PUSH
34173: LD_EXP 91
34177: PUSH
34178: LD_VAR 0 2
34182: ARRAY
34183: PUSH
34184: LD_INT 1
34186: PLUS
34187: PUSH
34188: EMPTY
34189: LIST
34190: LIST
34191: PPUSH
34192: LD_VAR 0 3
34196: PPUSH
34197: CALL 57403 0 3
34201: ST_TO_ADDR
// SetTag ( j , 107 ) ;
34202: LD_VAR 0 3
34206: PPUSH
34207: LD_INT 107
34209: PPUSH
34210: CALL_OW 109
// if mc_crates_collector [ i ] >= 5 then
34214: LD_EXP 91
34218: PUSH
34219: LD_VAR 0 2
34223: ARRAY
34224: PUSH
34225: LD_INT 5
34227: GREATEREQUAL
34228: IFFALSE 34232
// break ;
34230: GO 34234
// end ;
34232: GO 34143
34234: POP
34235: POP
// end ; if mc_crates_collector [ i ] and target then
34236: LD_EXP 91
34240: PUSH
34241: LD_VAR 0 2
34245: ARRAY
34246: PUSH
34247: LD_VAR 0 6
34251: AND
34252: IFFALSE 34495
// begin if mc_crates_collector [ i ] < target [ 1 ] then
34254: LD_EXP 91
34258: PUSH
34259: LD_VAR 0 2
34263: ARRAY
34264: PUSH
34265: LD_VAR 0 6
34269: PUSH
34270: LD_INT 1
34272: ARRAY
34273: LESS
34274: IFFALSE 34294
// tmp := mc_crates_collector [ i ] else
34276: LD_ADDR_VAR 0 5
34280: PUSH
34281: LD_EXP 91
34285: PUSH
34286: LD_VAR 0 2
34290: ARRAY
34291: ST_TO_ADDR
34292: GO 34308
// tmp := target [ 1 ] ;
34294: LD_ADDR_VAR 0 5
34298: PUSH
34299: LD_VAR 0 6
34303: PUSH
34304: LD_INT 1
34306: ARRAY
34307: ST_TO_ADDR
// k := 0 ;
34308: LD_ADDR_VAR 0 4
34312: PUSH
34313: LD_INT 0
34315: ST_TO_ADDR
// for j in mc_crates_collector [ i ] do
34316: LD_ADDR_VAR 0 3
34320: PUSH
34321: LD_EXP 91
34325: PUSH
34326: LD_VAR 0 2
34330: ARRAY
34331: PUSH
34332: FOR_IN
34333: IFFALSE 34493
// begin k := k + 1 ;
34335: LD_ADDR_VAR 0 4
34339: PUSH
34340: LD_VAR 0 4
34344: PUSH
34345: LD_INT 1
34347: PLUS
34348: ST_TO_ADDR
// if k > tmp then
34349: LD_VAR 0 4
34353: PUSH
34354: LD_VAR 0 5
34358: GREATER
34359: IFFALSE 34363
// break ;
34361: GO 34493
// if not GetClass ( j ) in [ 2 , 16 ] then
34363: LD_VAR 0 3
34367: PPUSH
34368: CALL_OW 257
34372: PUSH
34373: LD_INT 2
34375: PUSH
34376: LD_INT 16
34378: PUSH
34379: EMPTY
34380: LIST
34381: LIST
34382: IN
34383: NOT
34384: IFFALSE 34437
// begin mc_crates_collector := Replace ( mc_crates_collector , i , mc_crates_collector [ i ] diff j ) ;
34386: LD_ADDR_EXP 91
34390: PUSH
34391: LD_EXP 91
34395: PPUSH
34396: LD_VAR 0 2
34400: PPUSH
34401: LD_EXP 91
34405: PUSH
34406: LD_VAR 0 2
34410: ARRAY
34411: PUSH
34412: LD_VAR 0 3
34416: DIFF
34417: PPUSH
34418: CALL_OW 1
34422: ST_TO_ADDR
// SetTag ( j , 0 ) ;
34423: LD_VAR 0 3
34427: PPUSH
34428: LD_INT 0
34430: PPUSH
34431: CALL_OW 109
// continue ;
34435: GO 34332
// end ; if IsInUnit ( j ) then
34437: LD_VAR 0 3
34441: PPUSH
34442: CALL_OW 310
34446: IFFALSE 34457
// ComExitBuilding ( j ) ;
34448: LD_VAR 0 3
34452: PPUSH
34453: CALL_OW 122
// wait ( 3 ) ;
34457: LD_INT 3
34459: PPUSH
34460: CALL_OW 67
// ComCollect ( j , target [ 2 ] , target [ 3 ] ) ;
34464: LD_VAR 0 3
34468: PPUSH
34469: LD_VAR 0 6
34473: PUSH
34474: LD_INT 2
34476: ARRAY
34477: PPUSH
34478: LD_VAR 0 6
34482: PUSH
34483: LD_INT 3
34485: ARRAY
34486: PPUSH
34487: CALL_OW 117
// end ;
34491: GO 34332
34493: POP
34494: POP
// end ; end else
34495: GO 35076
// begin for j in cargo do
34497: LD_ADDR_VAR 0 3
34501: PUSH
34502: LD_VAR 0 7
34506: PUSH
34507: FOR_IN
34508: IFFALSE 35074
// begin if GetTag ( j ) <> 0 then
34510: LD_VAR 0 3
34514: PPUSH
34515: CALL_OW 110
34519: PUSH
34520: LD_INT 0
34522: NONEQUAL
34523: IFFALSE 34527
// continue ;
34525: GO 34507
// if GetLives ( j ) < 1000 and not IsInArea ( j , mc_parking [ i ] ) then
34527: LD_VAR 0 3
34531: PPUSH
34532: CALL_OW 256
34536: PUSH
34537: LD_INT 1000
34539: LESS
34540: PUSH
34541: LD_VAR 0 3
34545: PPUSH
34546: LD_EXP 98
34550: PUSH
34551: LD_VAR 0 2
34555: ARRAY
34556: PPUSH
34557: CALL_OW 308
34561: NOT
34562: AND
34563: IFFALSE 34585
// ComMoveToArea ( j , mc_parking [ i ] ) ;
34565: LD_VAR 0 3
34569: PPUSH
34570: LD_EXP 98
34574: PUSH
34575: LD_VAR 0 2
34579: ARRAY
34580: PPUSH
34581: CALL_OW 113
// if GetLives ( j ) < 1000 and IsInArea ( j , mc_parking [ i ] ) then
34585: LD_VAR 0 3
34589: PPUSH
34590: CALL_OW 256
34594: PUSH
34595: LD_INT 1000
34597: LESS
34598: PUSH
34599: LD_VAR 0 3
34603: PPUSH
34604: LD_EXP 98
34608: PUSH
34609: LD_VAR 0 2
34613: ARRAY
34614: PPUSH
34615: CALL_OW 308
34619: AND
34620: IFFALSE 34624
// continue ;
34622: GO 34507
// if GetEngine ( j ) = engine_solar and GetFuel ( j ) < 15 then
34624: LD_VAR 0 3
34628: PPUSH
34629: CALL_OW 262
34633: PUSH
34634: LD_INT 2
34636: EQUAL
34637: PUSH
34638: LD_VAR 0 3
34642: PPUSH
34643: CALL_OW 261
34647: PUSH
34648: LD_INT 15
34650: LESS
34651: AND
34652: IFFALSE 34656
// continue ;
34654: GO 34507
// if GetEngine ( j ) = engine_combustion and GetFuel ( j ) < 10 then
34656: LD_VAR 0 3
34660: PPUSH
34661: CALL_OW 262
34665: PUSH
34666: LD_INT 1
34668: EQUAL
34669: PUSH
34670: LD_VAR 0 3
34674: PPUSH
34675: CALL_OW 261
34679: PUSH
34680: LD_INT 10
34682: LESS
34683: AND
34684: IFFALSE 35013
// begin depot := UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) ;
34686: LD_ADDR_VAR 0 8
34690: PUSH
34691: LD_EXP 74
34695: PUSH
34696: LD_VAR 0 2
34700: ARRAY
34701: PPUSH
34702: LD_INT 2
34704: PUSH
34705: LD_INT 30
34707: PUSH
34708: LD_INT 0
34710: PUSH
34711: EMPTY
34712: LIST
34713: LIST
34714: PUSH
34715: LD_INT 30
34717: PUSH
34718: LD_INT 1
34720: PUSH
34721: EMPTY
34722: LIST
34723: LIST
34724: PUSH
34725: EMPTY
34726: LIST
34727: LIST
34728: LIST
34729: PPUSH
34730: CALL_OW 72
34734: ST_TO_ADDR
// if not depot then
34735: LD_VAR 0 8
34739: NOT
34740: IFFALSE 34744
// continue ;
34742: GO 34507
// if GetDistUnits ( j , NearestUnitToUnit ( depot , j ) ) < 6 then
34744: LD_VAR 0 3
34748: PPUSH
34749: LD_VAR 0 8
34753: PPUSH
34754: LD_VAR 0 3
34758: PPUSH
34759: CALL_OW 74
34763: PPUSH
34764: CALL_OW 296
34768: PUSH
34769: LD_INT 6
34771: LESS
34772: IFFALSE 34788
// SetFuel ( j , 100 ) else
34774: LD_VAR 0 3
34778: PPUSH
34779: LD_INT 100
34781: PPUSH
34782: CALL_OW 240
34786: GO 35013
// if GetFuel ( j ) = 0 then
34788: LD_VAR 0 3
34792: PPUSH
34793: CALL_OW 261
34797: PUSH
34798: LD_INT 0
34800: EQUAL
34801: IFFALSE 35013
// begin mc_vehicles := Replace ( mc_vehicles , i , mc_vehicles [ i ] diff j ) ;
34803: LD_ADDR_EXP 93
34807: PUSH
34808: LD_EXP 93
34812: PPUSH
34813: LD_VAR 0 2
34817: PPUSH
34818: LD_EXP 93
34822: PUSH
34823: LD_VAR 0 2
34827: ARRAY
34828: PUSH
34829: LD_VAR 0 3
34833: DIFF
34834: PPUSH
34835: CALL_OW 1
34839: ST_TO_ADDR
// if GetControl ( j ) = control_manual then
34840: LD_VAR 0 3
34844: PPUSH
34845: CALL_OW 263
34849: PUSH
34850: LD_INT 1
34852: EQUAL
34853: IFFALSE 34869
// ComExitVehicle ( IsInUnit ( j ) ) ;
34855: LD_VAR 0 3
34859: PPUSH
34860: CALL_OW 310
34864: PPUSH
34865: CALL_OW 121
// if GetControl ( j ) = control_remote then
34869: LD_VAR 0 3
34873: PPUSH
34874: CALL_OW 263
34878: PUSH
34879: LD_INT 2
34881: EQUAL
34882: IFFALSE 34893
// ComUnlink ( j ) ;
34884: LD_VAR 0 3
34888: PPUSH
34889: CALL_OW 136
// fac := MC_GetBuildings ( i , b_factory ) ;
34893: LD_ADDR_VAR 0 9
34897: PUSH
34898: LD_VAR 0 2
34902: PPUSH
34903: LD_INT 3
34905: PPUSH
34906: CALL 44366 0 2
34910: ST_TO_ADDR
// if fac then
34911: LD_VAR 0 9
34915: IFFALSE 35011
// begin for k in fac do
34917: LD_ADDR_VAR 0 4
34921: PUSH
34922: LD_VAR 0 9
34926: PUSH
34927: FOR_IN
34928: IFFALSE 35009
// begin components := Produce ( fac , GetChassis ( j ) , GetEngine ( j ) , GetControl ( j ) , GetWeapon ( j ) ) ;
34930: LD_ADDR_VAR 0 10
34934: PUSH
34935: LD_VAR 0 9
34939: PPUSH
34940: LD_VAR 0 3
34944: PPUSH
34945: CALL_OW 265
34949: PPUSH
34950: LD_VAR 0 3
34954: PPUSH
34955: CALL_OW 262
34959: PPUSH
34960: LD_VAR 0 3
34964: PPUSH
34965: CALL_OW 263
34969: PPUSH
34970: LD_VAR 0 3
34974: PPUSH
34975: CALL_OW 264
34979: PPUSH
34980: CALL 54935 0 5
34984: ST_TO_ADDR
// if components then
34985: LD_VAR 0 10
34989: IFFALSE 35007
// begin MC_InsertProduceList ( i , components ) ;
34991: LD_VAR 0 2
34995: PPUSH
34996: LD_VAR 0 10
35000: PPUSH
35001: CALL 43911 0 2
// break ;
35005: GO 35009
// end ; end ;
35007: GO 34927
35009: POP
35010: POP
// end ; continue ;
35011: GO 34507
// end ; end ; if GetCargo ( j , mat_cans ) < 100 and not HasTask ( j ) then
35013: LD_VAR 0 3
35017: PPUSH
35018: LD_INT 1
35020: PPUSH
35021: CALL_OW 289
35025: PUSH
35026: LD_INT 100
35028: LESS
35029: PUSH
35030: LD_VAR 0 3
35034: PPUSH
35035: CALL_OW 314
35039: NOT
35040: AND
35041: IFFALSE 35070
// ComCollect ( j , target [ 2 ] , target [ 3 ] ) ;
35043: LD_VAR 0 3
35047: PPUSH
35048: LD_VAR 0 6
35052: PUSH
35053: LD_INT 2
35055: ARRAY
35056: PPUSH
35057: LD_VAR 0 6
35061: PUSH
35062: LD_INT 3
35064: ARRAY
35065: PPUSH
35066: CALL_OW 117
// break ;
35070: GO 35074
// end ;
35072: GO 34507
35074: POP
35075: POP
// end ; end ;
35076: GO 33345
35078: POP
35079: POP
// end ;
35080: LD_VAR 0 1
35084: RET
// export function MC_LinkRemoteControl ( ) ; var i , j , tmp ; begin
35085: LD_INT 0
35087: PPUSH
35088: PPUSH
35089: PPUSH
35090: PPUSH
// if not mc_bases then
35091: LD_EXP 74
35095: NOT
35096: IFFALSE 35100
// exit ;
35098: GO 35261
// for i = 1 to mc_bases do
35100: LD_ADDR_VAR 0 2
35104: PUSH
35105: DOUBLE
35106: LD_INT 1
35108: DEC
35109: ST_TO_ADDR
35110: LD_EXP 74
35114: PUSH
35115: FOR_TO
35116: IFFALSE 35259
// begin tmp := UnitFilter ( mc_vehicles [ i ] union mc_defender [ i ] , [ f_control , control_remote ] ) ;
35118: LD_ADDR_VAR 0 4
35122: PUSH
35123: LD_EXP 93
35127: PUSH
35128: LD_VAR 0 2
35132: ARRAY
35133: PUSH
35134: LD_EXP 96
35138: PUSH
35139: LD_VAR 0 2
35143: ARRAY
35144: UNION
35145: PPUSH
35146: LD_INT 33
35148: PUSH
35149: LD_INT 2
35151: PUSH
35152: EMPTY
35153: LIST
35154: LIST
35155: PPUSH
35156: CALL_OW 72
35160: ST_TO_ADDR
// if tmp then
35161: LD_VAR 0 4
35165: IFFALSE 35257
// for j in tmp do
35167: LD_ADDR_VAR 0 3
35171: PUSH
35172: LD_VAR 0 4
35176: PUSH
35177: FOR_IN
35178: IFFALSE 35255
// if not IsControledBy ( j ) and GetLives ( j ) >= 250 then
35180: LD_VAR 0 3
35184: PPUSH
35185: CALL_OW 312
35189: NOT
35190: PUSH
35191: LD_VAR 0 3
35195: PPUSH
35196: CALL_OW 256
35200: PUSH
35201: LD_INT 250
35203: GREATEREQUAL
35204: AND
35205: IFFALSE 35218
// Connect ( j ) else
35207: LD_VAR 0 3
35211: PPUSH
35212: CALL 60336 0 1
35216: GO 35253
// if GetLives ( j ) < 250 and IsControledBy ( j ) then
35218: LD_VAR 0 3
35222: PPUSH
35223: CALL_OW 256
35227: PUSH
35228: LD_INT 250
35230: LESS
35231: PUSH
35232: LD_VAR 0 3
35236: PPUSH
35237: CALL_OW 312
35241: AND
35242: IFFALSE 35253
// ComUnlink ( j ) ;
35244: LD_VAR 0 3
35248: PPUSH
35249: CALL_OW 136
35253: GO 35177
35255: POP
35256: POP
// end ;
35257: GO 35115
35259: POP
35260: POP
// end ;
35261: LD_VAR 0 1
35265: RET
// export function MC_ProduceVehicle ( ) ; var i , j , tmp , fac ; begin
35266: LD_INT 0
35268: PPUSH
35269: PPUSH
35270: PPUSH
35271: PPUSH
35272: PPUSH
// if not mc_bases then
35273: LD_EXP 74
35277: NOT
35278: IFFALSE 35282
// exit ;
35280: GO 35727
// for i = 1 to mc_bases do
35282: LD_ADDR_VAR 0 2
35286: PUSH
35287: DOUBLE
35288: LD_INT 1
35290: DEC
35291: ST_TO_ADDR
35292: LD_EXP 74
35296: PUSH
35297: FOR_TO
35298: IFFALSE 35725
// begin if not mc_produce [ i ] then
35300: LD_EXP 95
35304: PUSH
35305: LD_VAR 0 2
35309: ARRAY
35310: NOT
35311: IFFALSE 35315
// continue ;
35313: GO 35297
// fac := UnitFilter ( mc_bases [ i ] , [ f_btype , b_factory ] ) ;
35315: LD_ADDR_VAR 0 5
35319: PUSH
35320: LD_EXP 74
35324: PUSH
35325: LD_VAR 0 2
35329: ARRAY
35330: PPUSH
35331: LD_INT 30
35333: PUSH
35334: LD_INT 3
35336: PUSH
35337: EMPTY
35338: LIST
35339: LIST
35340: PPUSH
35341: CALL_OW 72
35345: ST_TO_ADDR
// if not fac then
35346: LD_VAR 0 5
35350: NOT
35351: IFFALSE 35355
// continue ;
35353: GO 35297
// for j in fac do
35355: LD_ADDR_VAR 0 3
35359: PUSH
35360: LD_VAR 0 5
35364: PUSH
35365: FOR_IN
35366: IFFALSE 35721
// begin if BuildingStatus ( j ) <> bs_idle or DangerAtRange ( j , 15 ) [ 4 ] then
35368: LD_VAR 0 3
35372: PPUSH
35373: CALL_OW 461
35377: PUSH
35378: LD_INT 2
35380: NONEQUAL
35381: PUSH
35382: LD_VAR 0 3
35386: PPUSH
35387: LD_INT 15
35389: PPUSH
35390: CALL 59996 0 2
35394: PUSH
35395: LD_INT 4
35397: ARRAY
35398: OR
35399: IFFALSE 35403
// continue ;
35401: GO 35365
// if CanBeConstructed ( j , mc_produce [ i ] [ 1 ] [ 1 ] , mc_produce [ i ] [ 1 ] [ 2 ] , mc_produce [ i ] [ 1 ] [ 3 ] , mc_produce [ i ] [ 1 ] [ 4 ] ) and VehicleCost ( j , [ mc_produce [ i ] [ 1 ] [ 1 ] , mc_produce [ i ] [ 1 ] [ 2 ] , mc_produce [ i ] [ 1 ] [ 3 ] , mc_produce [ i ] [ 1 ] [ 4 ] ] ) then
35403: LD_VAR 0 3
35407: PPUSH
35408: LD_EXP 95
35412: PUSH
35413: LD_VAR 0 2
35417: ARRAY
35418: PUSH
35419: LD_INT 1
35421: ARRAY
35422: PUSH
35423: LD_INT 1
35425: ARRAY
35426: PPUSH
35427: LD_EXP 95
35431: PUSH
35432: LD_VAR 0 2
35436: ARRAY
35437: PUSH
35438: LD_INT 1
35440: ARRAY
35441: PUSH
35442: LD_INT 2
35444: ARRAY
35445: PPUSH
35446: LD_EXP 95
35450: PUSH
35451: LD_VAR 0 2
35455: ARRAY
35456: PUSH
35457: LD_INT 1
35459: ARRAY
35460: PUSH
35461: LD_INT 3
35463: ARRAY
35464: PPUSH
35465: LD_EXP 95
35469: PUSH
35470: LD_VAR 0 2
35474: ARRAY
35475: PUSH
35476: LD_INT 1
35478: ARRAY
35479: PUSH
35480: LD_INT 4
35482: ARRAY
35483: PPUSH
35484: CALL_OW 448
35488: PUSH
35489: LD_VAR 0 3
35493: PPUSH
35494: LD_EXP 95
35498: PUSH
35499: LD_VAR 0 2
35503: ARRAY
35504: PUSH
35505: LD_INT 1
35507: ARRAY
35508: PUSH
35509: LD_INT 1
35511: ARRAY
35512: PUSH
35513: LD_EXP 95
35517: PUSH
35518: LD_VAR 0 2
35522: ARRAY
35523: PUSH
35524: LD_INT 1
35526: ARRAY
35527: PUSH
35528: LD_INT 2
35530: ARRAY
35531: PUSH
35532: LD_EXP 95
35536: PUSH
35537: LD_VAR 0 2
35541: ARRAY
35542: PUSH
35543: LD_INT 1
35545: ARRAY
35546: PUSH
35547: LD_INT 3
35549: ARRAY
35550: PUSH
35551: LD_EXP 95
35555: PUSH
35556: LD_VAR 0 2
35560: ARRAY
35561: PUSH
35562: LD_INT 1
35564: ARRAY
35565: PUSH
35566: LD_INT 4
35568: ARRAY
35569: PUSH
35570: EMPTY
35571: LIST
35572: LIST
35573: LIST
35574: LIST
35575: PPUSH
35576: CALL 63667 0 2
35580: AND
35581: IFFALSE 35719
// begin AddComConstruct ( j , mc_produce [ i ] [ 1 ] [ 1 ] , mc_produce [ i ] [ 1 ] [ 2 ] , mc_produce [ i ] [ 1 ] [ 3 ] , mc_produce [ i ] [ 1 ] [ 4 ] ) ;
35583: LD_VAR 0 3
35587: PPUSH
35588: LD_EXP 95
35592: PUSH
35593: LD_VAR 0 2
35597: ARRAY
35598: PUSH
35599: LD_INT 1
35601: ARRAY
35602: PUSH
35603: LD_INT 1
35605: ARRAY
35606: PPUSH
35607: LD_EXP 95
35611: PUSH
35612: LD_VAR 0 2
35616: ARRAY
35617: PUSH
35618: LD_INT 1
35620: ARRAY
35621: PUSH
35622: LD_INT 2
35624: ARRAY
35625: PPUSH
35626: LD_EXP 95
35630: PUSH
35631: LD_VAR 0 2
35635: ARRAY
35636: PUSH
35637: LD_INT 1
35639: ARRAY
35640: PUSH
35641: LD_INT 3
35643: ARRAY
35644: PPUSH
35645: LD_EXP 95
35649: PUSH
35650: LD_VAR 0 2
35654: ARRAY
35655: PUSH
35656: LD_INT 1
35658: ARRAY
35659: PUSH
35660: LD_INT 4
35662: ARRAY
35663: PPUSH
35664: CALL_OW 185
// tmp := Delete ( mc_produce [ i ] , 1 ) ;
35668: LD_ADDR_VAR 0 4
35672: PUSH
35673: LD_EXP 95
35677: PUSH
35678: LD_VAR 0 2
35682: ARRAY
35683: PPUSH
35684: LD_INT 1
35686: PPUSH
35687: CALL_OW 3
35691: ST_TO_ADDR
// mc_produce := Replace ( mc_produce , i , tmp ) ;
35692: LD_ADDR_EXP 95
35696: PUSH
35697: LD_EXP 95
35701: PPUSH
35702: LD_VAR 0 2
35706: PPUSH
35707: LD_VAR 0 4
35711: PPUSH
35712: CALL_OW 1
35716: ST_TO_ADDR
// break ;
35717: GO 35721
// end ; end ;
35719: GO 35365
35721: POP
35722: POP
// end ;
35723: GO 35297
35725: POP
35726: POP
// end ;
35727: LD_VAR 0 1
35731: RET
// export function MC_SendAttack ( ) ; var i , tmp ; begin
35732: LD_INT 0
35734: PPUSH
35735: PPUSH
35736: PPUSH
// if not mc_bases then
35737: LD_EXP 74
35741: NOT
35742: IFFALSE 35746
// exit ;
35744: GO 35835
// for i = 1 to mc_bases do
35746: LD_ADDR_VAR 0 2
35750: PUSH
35751: DOUBLE
35752: LD_INT 1
35754: DEC
35755: ST_TO_ADDR
35756: LD_EXP 74
35760: PUSH
35761: FOR_TO
35762: IFFALSE 35833
// begin if mc_attack [ i ] then
35764: LD_EXP 94
35768: PUSH
35769: LD_VAR 0 2
35773: ARRAY
35774: IFFALSE 35831
// begin tmp := mc_attack [ i ] [ 1 ] ;
35776: LD_ADDR_VAR 0 3
35780: PUSH
35781: LD_EXP 94
35785: PUSH
35786: LD_VAR 0 2
35790: ARRAY
35791: PUSH
35792: LD_INT 1
35794: ARRAY
35795: ST_TO_ADDR
// mc_attack := Replace ( mc_attack , i , [ ] ) ;
35796: LD_ADDR_EXP 94
35800: PUSH
35801: LD_EXP 94
35805: PPUSH
35806: LD_VAR 0 2
35810: PPUSH
35811: EMPTY
35812: PPUSH
35813: CALL_OW 1
35817: ST_TO_ADDR
// Attack ( tmp ) ;
35818: LD_VAR 0 3
35822: PPUSH
35823: CALL 85880 0 1
// exit ;
35827: POP
35828: POP
35829: GO 35835
// end ; end ;
35831: GO 35761
35833: POP
35834: POP
// end ;
35835: LD_VAR 0 1
35839: RET
// export function MC_Defend ( ) ; var i , j , tmp , t , x , class ; begin
35840: LD_INT 0
35842: PPUSH
35843: PPUSH
35844: PPUSH
35845: PPUSH
35846: PPUSH
35847: PPUSH
35848: PPUSH
// if not mc_bases then
35849: LD_EXP 74
35853: NOT
35854: IFFALSE 35858
// exit ;
35856: GO 36440
// for i = 1 to mc_bases do
35858: LD_ADDR_VAR 0 2
35862: PUSH
35863: DOUBLE
35864: LD_INT 1
35866: DEC
35867: ST_TO_ADDR
35868: LD_EXP 74
35872: PUSH
35873: FOR_TO
35874: IFFALSE 36438
// begin if not mc_bases [ i ] then
35876: LD_EXP 74
35880: PUSH
35881: LD_VAR 0 2
35885: ARRAY
35886: NOT
35887: IFFALSE 35891
// continue ;
35889: GO 35873
// class := AllowSpecClass ( mc_bases [ i ] [ 1 ] ) ;
35891: LD_ADDR_VAR 0 7
35895: PUSH
35896: LD_EXP 74
35900: PUSH
35901: LD_VAR 0 2
35905: ARRAY
35906: PUSH
35907: LD_INT 1
35909: ARRAY
35910: PPUSH
35911: CALL 54239 0 1
35915: ST_TO_ADDR
// mc_scan := Replace ( mc_scan , i , ScanBase ( GetSide ( mc_bases [ i ] [ 1 ] ) , mc_scan_area [ i ] ) ) ;
35916: LD_ADDR_EXP 97
35920: PUSH
35921: LD_EXP 97
35925: PPUSH
35926: LD_VAR 0 2
35930: PPUSH
35931: LD_EXP 74
35935: PUSH
35936: LD_VAR 0 2
35940: ARRAY
35941: PUSH
35942: LD_INT 1
35944: ARRAY
35945: PPUSH
35946: CALL_OW 255
35950: PPUSH
35951: LD_EXP 99
35955: PUSH
35956: LD_VAR 0 2
35960: ARRAY
35961: PPUSH
35962: CALL 51882 0 2
35966: PPUSH
35967: CALL_OW 1
35971: ST_TO_ADDR
// if not mc_scan [ i ] then
35972: LD_EXP 97
35976: PUSH
35977: LD_VAR 0 2
35981: ARRAY
35982: NOT
35983: IFFALSE 36138
// begin tmp := UnitFilter ( mc_bases [ i ] , [ f_or , [ f_class , 5 ] , [ f_class , 8 ] , [ f_class , 9 ] ] ) ;
35985: LD_ADDR_VAR 0 4
35989: PUSH
35990: LD_EXP 74
35994: PUSH
35995: LD_VAR 0 2
35999: ARRAY
36000: PPUSH
36001: LD_INT 2
36003: PUSH
36004: LD_INT 25
36006: PUSH
36007: LD_INT 5
36009: PUSH
36010: EMPTY
36011: LIST
36012: LIST
36013: PUSH
36014: LD_INT 25
36016: PUSH
36017: LD_INT 8
36019: PUSH
36020: EMPTY
36021: LIST
36022: LIST
36023: PUSH
36024: LD_INT 25
36026: PUSH
36027: LD_INT 9
36029: PUSH
36030: EMPTY
36031: LIST
36032: LIST
36033: PUSH
36034: EMPTY
36035: LIST
36036: LIST
36037: LIST
36038: LIST
36039: PPUSH
36040: CALL_OW 72
36044: ST_TO_ADDR
// if not tmp then
36045: LD_VAR 0 4
36049: NOT
36050: IFFALSE 36054
// continue ;
36052: GO 35873
// for j in tmp do
36054: LD_ADDR_VAR 0 3
36058: PUSH
36059: LD_VAR 0 4
36063: PUSH
36064: FOR_IN
36065: IFFALSE 36136
// if GetBType ( IsInUnit ( j ) ) = b_barracks and GetClass ( j ) = 1 and not MineOfUnit ( j ) and class then
36067: LD_VAR 0 3
36071: PPUSH
36072: CALL_OW 310
36076: PPUSH
36077: CALL_OW 266
36081: PUSH
36082: LD_INT 5
36084: EQUAL
36085: PUSH
36086: LD_VAR 0 3
36090: PPUSH
36091: CALL_OW 257
36095: PUSH
36096: LD_INT 1
36098: EQUAL
36099: AND
36100: PUSH
36101: LD_VAR 0 3
36105: PPUSH
36106: CALL_OW 459
36110: NOT
36111: AND
36112: PUSH
36113: LD_VAR 0 7
36117: AND
36118: IFFALSE 36134
// ComChangeProfession ( j , class ) ;
36120: LD_VAR 0 3
36124: PPUSH
36125: LD_VAR 0 7
36129: PPUSH
36130: CALL_OW 123
36134: GO 36064
36136: POP
36137: POP
// end ; if mc_scan [ i ] and not mc_defender [ i ] and not UnitFilter ( mc_bases [ i ] , [ f_btype , b_bunker ] ) and not UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_armoury ] , [ f_btype , b_barracks ] ] ) then
36138: LD_EXP 97
36142: PUSH
36143: LD_VAR 0 2
36147: ARRAY
36148: PUSH
36149: LD_EXP 96
36153: PUSH
36154: LD_VAR 0 2
36158: ARRAY
36159: NOT
36160: AND
36161: PUSH
36162: LD_EXP 74
36166: PUSH
36167: LD_VAR 0 2
36171: ARRAY
36172: PPUSH
36173: LD_INT 30
36175: PUSH
36176: LD_INT 32
36178: PUSH
36179: EMPTY
36180: LIST
36181: LIST
36182: PPUSH
36183: CALL_OW 72
36187: NOT
36188: AND
36189: PUSH
36190: LD_EXP 74
36194: PUSH
36195: LD_VAR 0 2
36199: ARRAY
36200: PPUSH
36201: LD_INT 2
36203: PUSH
36204: LD_INT 30
36206: PUSH
36207: LD_INT 4
36209: PUSH
36210: EMPTY
36211: LIST
36212: LIST
36213: PUSH
36214: LD_INT 30
36216: PUSH
36217: LD_INT 5
36219: PUSH
36220: EMPTY
36221: LIST
36222: LIST
36223: PUSH
36224: EMPTY
36225: LIST
36226: LIST
36227: LIST
36228: PPUSH
36229: CALL_OW 72
36233: NOT
36234: AND
36235: IFFALSE 36367
// begin tmp := UnitFilter ( mc_bases [ i ] , [ f_or , [ f_class , 1 ] , [ f_class , 5 ] , [ f_class , 8 ] , [ f_class , 9 ] ] ) ;
36237: LD_ADDR_VAR 0 4
36241: PUSH
36242: LD_EXP 74
36246: PUSH
36247: LD_VAR 0 2
36251: ARRAY
36252: PPUSH
36253: LD_INT 2
36255: PUSH
36256: LD_INT 25
36258: PUSH
36259: LD_INT 1
36261: PUSH
36262: EMPTY
36263: LIST
36264: LIST
36265: PUSH
36266: LD_INT 25
36268: PUSH
36269: LD_INT 5
36271: PUSH
36272: EMPTY
36273: LIST
36274: LIST
36275: PUSH
36276: LD_INT 25
36278: PUSH
36279: LD_INT 8
36281: PUSH
36282: EMPTY
36283: LIST
36284: LIST
36285: PUSH
36286: LD_INT 25
36288: PUSH
36289: LD_INT 9
36291: PUSH
36292: EMPTY
36293: LIST
36294: LIST
36295: PUSH
36296: EMPTY
36297: LIST
36298: LIST
36299: LIST
36300: LIST
36301: LIST
36302: PPUSH
36303: CALL_OW 72
36307: ST_TO_ADDR
// tmp := tmp diff FilterByTag ( tmp , 18 ) ;
36308: LD_ADDR_VAR 0 4
36312: PUSH
36313: LD_VAR 0 4
36317: PUSH
36318: LD_VAR 0 4
36322: PPUSH
36323: LD_INT 18
36325: PPUSH
36326: CALL 90663 0 2
36330: DIFF
36331: ST_TO_ADDR
// if tmp then
36332: LD_VAR 0 4
36336: IFFALSE 36367
// begin BasicDefend ( i , tmp , mc_scan_area [ i ] ) ;
36338: LD_VAR 0 2
36342: PPUSH
36343: LD_VAR 0 4
36347: PPUSH
36348: LD_EXP 99
36352: PUSH
36353: LD_VAR 0 2
36357: ARRAY
36358: PPUSH
36359: CALL 51917 0 3
// exit ;
36363: POP
36364: POP
36365: GO 36440
// end ; end ; if mc_scan [ i ] and mc_defender [ i ] then
36367: LD_EXP 97
36371: PUSH
36372: LD_VAR 0 2
36376: ARRAY
36377: PUSH
36378: LD_EXP 96
36382: PUSH
36383: LD_VAR 0 2
36387: ARRAY
36388: AND
36389: IFFALSE 36436
// begin tmp := mc_defender [ i ] ;
36391: LD_ADDR_VAR 0 4
36395: PUSH
36396: LD_EXP 96
36400: PUSH
36401: LD_VAR 0 2
36405: ARRAY
36406: ST_TO_ADDR
// Defend ( i , tmp , mc_scan [ i ] ) ;
36407: LD_VAR 0 2
36411: PPUSH
36412: LD_VAR 0 4
36416: PPUSH
36417: LD_EXP 97
36421: PUSH
36422: LD_VAR 0 2
36426: ARRAY
36427: PPUSH
36428: CALL 52478 0 3
// exit ;
36432: POP
36433: POP
36434: GO 36440
// end ; end ;
36436: GO 35873
36438: POP
36439: POP
// end ;
36440: LD_VAR 0 1
36444: RET
// export function MC_Research ( ) ; var i , j , side , t , tmp , x , sci , tmp2 , researching , idle_lab ; begin
36445: LD_INT 0
36447: PPUSH
36448: PPUSH
36449: PPUSH
36450: PPUSH
36451: PPUSH
36452: PPUSH
36453: PPUSH
36454: PPUSH
36455: PPUSH
36456: PPUSH
36457: PPUSH
// if not mc_bases then
36458: LD_EXP 74
36462: NOT
36463: IFFALSE 36467
// exit ;
36465: GO 37554
// for i = 1 to mc_bases do
36467: LD_ADDR_VAR 0 2
36471: PUSH
36472: DOUBLE
36473: LD_INT 1
36475: DEC
36476: ST_TO_ADDR
36477: LD_EXP 74
36481: PUSH
36482: FOR_TO
36483: IFFALSE 37552
// begin tmp := mc_lab [ i ] ;
36485: LD_ADDR_VAR 0 6
36489: PUSH
36490: LD_EXP 107
36494: PUSH
36495: LD_VAR 0 2
36499: ARRAY
36500: ST_TO_ADDR
// if not tmp then
36501: LD_VAR 0 6
36505: NOT
36506: IFFALSE 36510
// continue ;
36508: GO 36482
// idle_lab := 0 ;
36510: LD_ADDR_VAR 0 11
36514: PUSH
36515: LD_INT 0
36517: ST_TO_ADDR
// for j in tmp do
36518: LD_ADDR_VAR 0 3
36522: PUSH
36523: LD_VAR 0 6
36527: PUSH
36528: FOR_IN
36529: IFFALSE 37548
// begin researching := false ;
36531: LD_ADDR_VAR 0 10
36535: PUSH
36536: LD_INT 0
36538: ST_TO_ADDR
// side := GetSide ( j ) ;
36539: LD_ADDR_VAR 0 4
36543: PUSH
36544: LD_VAR 0 3
36548: PPUSH
36549: CALL_OW 255
36553: ST_TO_ADDR
// if not mc_tech [ side ] then
36554: LD_EXP 101
36558: PUSH
36559: LD_VAR 0 4
36563: ARRAY
36564: NOT
36565: IFFALSE 36569
// continue ;
36567: GO 36528
// if BuildingStatus ( j ) = bs_idle then
36569: LD_VAR 0 3
36573: PPUSH
36574: CALL_OW 461
36578: PUSH
36579: LD_INT 2
36581: EQUAL
36582: IFFALSE 36770
// begin if idle_lab and UnitsInside ( j ) < 6 then
36584: LD_VAR 0 11
36588: PUSH
36589: LD_VAR 0 3
36593: PPUSH
36594: CALL_OW 313
36598: PUSH
36599: LD_INT 6
36601: LESS
36602: AND
36603: IFFALSE 36674
// begin tmp2 := UnitsInside ( idle_lab ) ;
36605: LD_ADDR_VAR 0 9
36609: PUSH
36610: LD_VAR 0 11
36614: PPUSH
36615: CALL_OW 313
36619: ST_TO_ADDR
// if tmp2 then
36620: LD_VAR 0 9
36624: IFFALSE 36666
// for x in tmp2 do
36626: LD_ADDR_VAR 0 7
36630: PUSH
36631: LD_VAR 0 9
36635: PUSH
36636: FOR_IN
36637: IFFALSE 36664
// begin ComExitBuilding ( x ) ;
36639: LD_VAR 0 7
36643: PPUSH
36644: CALL_OW 122
// AddComEnterUnit ( x , j ) ;
36648: LD_VAR 0 7
36652: PPUSH
36653: LD_VAR 0 3
36657: PPUSH
36658: CALL_OW 180
// end ;
36662: GO 36636
36664: POP
36665: POP
// idle_lab := 0 ;
36666: LD_ADDR_VAR 0 11
36670: PUSH
36671: LD_INT 0
36673: ST_TO_ADDR
// end ; for t in mc_tech [ side ] do
36674: LD_ADDR_VAR 0 5
36678: PUSH
36679: LD_EXP 101
36683: PUSH
36684: LD_VAR 0 4
36688: ARRAY
36689: PUSH
36690: FOR_IN
36691: IFFALSE 36751
// if CanBeResearched ( j , t ) and TechCanBeResearch ( side , t ) then
36693: LD_VAR 0 3
36697: PPUSH
36698: LD_VAR 0 5
36702: PPUSH
36703: CALL_OW 430
36707: PUSH
36708: LD_VAR 0 4
36712: PPUSH
36713: LD_VAR 0 5
36717: PPUSH
36718: CALL 50987 0 2
36722: AND
36723: IFFALSE 36749
// begin researching := true ;
36725: LD_ADDR_VAR 0 10
36729: PUSH
36730: LD_INT 1
36732: ST_TO_ADDR
// ComResearch ( j , t ) ;
36733: LD_VAR 0 3
36737: PPUSH
36738: LD_VAR 0 5
36742: PPUSH
36743: CALL_OW 124
// break ;
36747: GO 36751
// end ;
36749: GO 36690
36751: POP
36752: POP
// if not researching then
36753: LD_VAR 0 10
36757: NOT
36758: IFFALSE 36770
// idle_lab := j ;
36760: LD_ADDR_VAR 0 11
36764: PUSH
36765: LD_VAR 0 3
36769: ST_TO_ADDR
// end ; if BuildingStatus ( j ) = bs_need_ape then
36770: LD_VAR 0 3
36774: PPUSH
36775: CALL_OW 461
36779: PUSH
36780: LD_INT 10
36782: EQUAL
36783: IFFALSE 37371
// begin if not mc_ape [ i ] and not mc_ape_in_lab [ i ] and mc_tech [ side ] > 1 then
36785: LD_EXP 103
36789: PUSH
36790: LD_VAR 0 2
36794: ARRAY
36795: NOT
36796: PUSH
36797: LD_EXP 104
36801: PUSH
36802: LD_VAR 0 2
36806: ARRAY
36807: NOT
36808: AND
36809: PUSH
36810: LD_EXP 101
36814: PUSH
36815: LD_VAR 0 4
36819: ARRAY
36820: PUSH
36821: LD_INT 1
36823: GREATER
36824: AND
36825: IFFALSE 36956
// begin ComCancel ( j ) ;
36827: LD_VAR 0 3
36831: PPUSH
36832: CALL_OW 127
// mc_tech := Replace ( mc_tech , side , Reindex ( mc_tech [ side ] , mc_tech [ side ] - 1 , mc_tech [ side ] , false ) ) ;
36836: LD_ADDR_EXP 101
36840: PUSH
36841: LD_EXP 101
36845: PPUSH
36846: LD_VAR 0 4
36850: PPUSH
36851: LD_EXP 101
36855: PUSH
36856: LD_VAR 0 4
36860: ARRAY
36861: PPUSH
36862: LD_EXP 101
36866: PUSH
36867: LD_VAR 0 4
36871: ARRAY
36872: PUSH
36873: LD_INT 1
36875: MINUS
36876: PPUSH
36877: LD_EXP 101
36881: PUSH
36882: LD_VAR 0 4
36886: ARRAY
36887: PPUSH
36888: LD_INT 0
36890: PPUSH
36891: CALL 56821 0 4
36895: PPUSH
36896: CALL_OW 1
36900: ST_TO_ADDR
// mc_tech := Replace ( mc_tech , side , Reindex ( mc_tech [ side ] , mc_tech [ side ] , 1 , false ) ) ;
36901: LD_ADDR_EXP 101
36905: PUSH
36906: LD_EXP 101
36910: PPUSH
36911: LD_VAR 0 4
36915: PPUSH
36916: LD_EXP 101
36920: PUSH
36921: LD_VAR 0 4
36925: ARRAY
36926: PPUSH
36927: LD_EXP 101
36931: PUSH
36932: LD_VAR 0 4
36936: ARRAY
36937: PPUSH
36938: LD_INT 1
36940: PPUSH
36941: LD_INT 0
36943: PPUSH
36944: CALL 56821 0 4
36948: PPUSH
36949: CALL_OW 1
36953: ST_TO_ADDR
// continue ;
36954: GO 36528
// end ; if mc_ape [ i ] and not mc_ape_in_lab [ i ] then
36956: LD_EXP 103
36960: PUSH
36961: LD_VAR 0 2
36965: ARRAY
36966: PUSH
36967: LD_EXP 104
36971: PUSH
36972: LD_VAR 0 2
36976: ARRAY
36977: NOT
36978: AND
36979: IFFALSE 37106
// begin mc_ape_in_lab := ReplaceIn ( mc_ape_in_lab , [ i , mc_ape_in_lab [ i ] + 1 ] , mc_ape [ i ] [ 1 ] ) ;
36981: LD_ADDR_EXP 104
36985: PUSH
36986: LD_EXP 104
36990: PPUSH
36991: LD_VAR 0 2
36995: PUSH
36996: LD_EXP 104
37000: PUSH
37001: LD_VAR 0 2
37005: ARRAY
37006: PUSH
37007: LD_INT 1
37009: PLUS
37010: PUSH
37011: EMPTY
37012: LIST
37013: LIST
37014: PPUSH
37015: LD_EXP 103
37019: PUSH
37020: LD_VAR 0 2
37024: ARRAY
37025: PUSH
37026: LD_INT 1
37028: ARRAY
37029: PPUSH
37030: CALL 57403 0 3
37034: ST_TO_ADDR
// SetTag ( mc_ape [ i ] [ 1 ] , 112 ) ;
37035: LD_EXP 103
37039: PUSH
37040: LD_VAR 0 2
37044: ARRAY
37045: PUSH
37046: LD_INT 1
37048: ARRAY
37049: PPUSH
37050: LD_INT 112
37052: PPUSH
37053: CALL_OW 109
// tmp2 := Delete ( mc_ape [ i ] , 1 ) ;
37057: LD_ADDR_VAR 0 9
37061: PUSH
37062: LD_EXP 103
37066: PUSH
37067: LD_VAR 0 2
37071: ARRAY
37072: PPUSH
37073: LD_INT 1
37075: PPUSH
37076: CALL_OW 3
37080: ST_TO_ADDR
// mc_ape := Replace ( mc_ape , i , tmp2 ) ;
37081: LD_ADDR_EXP 103
37085: PUSH
37086: LD_EXP 103
37090: PPUSH
37091: LD_VAR 0 2
37095: PPUSH
37096: LD_VAR 0 9
37100: PPUSH
37101: CALL_OW 1
37105: ST_TO_ADDR
// end ; if mc_ape [ i ] and mc_ape_in_lab [ i ] and not IsInUnit ( mc_ape_in_lab [ i ] [ 1 ] ) and UnitsInside ( j ) = 6 then
37106: LD_EXP 103
37110: PUSH
37111: LD_VAR 0 2
37115: ARRAY
37116: PUSH
37117: LD_EXP 104
37121: PUSH
37122: LD_VAR 0 2
37126: ARRAY
37127: AND
37128: PUSH
37129: LD_EXP 104
37133: PUSH
37134: LD_VAR 0 2
37138: ARRAY
37139: PUSH
37140: LD_INT 1
37142: ARRAY
37143: PPUSH
37144: CALL_OW 310
37148: NOT
37149: AND
37150: PUSH
37151: LD_VAR 0 3
37155: PPUSH
37156: CALL_OW 313
37160: PUSH
37161: LD_INT 6
37163: EQUAL
37164: AND
37165: IFFALSE 37221
// begin tmp2 := UnitsInside ( j ) ;
37167: LD_ADDR_VAR 0 9
37171: PUSH
37172: LD_VAR 0 3
37176: PPUSH
37177: CALL_OW 313
37181: ST_TO_ADDR
// if tmp2 = 6 then
37182: LD_VAR 0 9
37186: PUSH
37187: LD_INT 6
37189: EQUAL
37190: IFFALSE 37221
// begin SetTag ( tmp2 [ 1 ] , 112 ) ;
37192: LD_VAR 0 9
37196: PUSH
37197: LD_INT 1
37199: ARRAY
37200: PPUSH
37201: LD_INT 112
37203: PPUSH
37204: CALL_OW 109
// ComExitBuilding ( tmp2 [ 1 ] ) ;
37208: LD_VAR 0 9
37212: PUSH
37213: LD_INT 1
37215: ARRAY
37216: PPUSH
37217: CALL_OW 122
// end ; end ; if mc_ape_in_lab [ i ] and not HasTask ( mc_ape_in_lab [ i ] [ 1 ] ) and not IsInUnit ( mc_ape_in_lab [ i ] [ 1 ] ) then
37221: LD_EXP 104
37225: PUSH
37226: LD_VAR 0 2
37230: ARRAY
37231: PUSH
37232: LD_EXP 104
37236: PUSH
37237: LD_VAR 0 2
37241: ARRAY
37242: PUSH
37243: LD_INT 1
37245: ARRAY
37246: PPUSH
37247: CALL_OW 314
37251: NOT
37252: AND
37253: PUSH
37254: LD_EXP 104
37258: PUSH
37259: LD_VAR 0 2
37263: ARRAY
37264: PUSH
37265: LD_INT 1
37267: ARRAY
37268: PPUSH
37269: CALL_OW 310
37273: NOT
37274: AND
37275: IFFALSE 37301
// ComEnterUnit ( mc_ape_in_lab [ i ] [ 1 ] , j ) ;
37277: LD_EXP 104
37281: PUSH
37282: LD_VAR 0 2
37286: ARRAY
37287: PUSH
37288: LD_INT 1
37290: ARRAY
37291: PPUSH
37292: LD_VAR 0 3
37296: PPUSH
37297: CALL_OW 120
// if IsInUnit ( mc_ape_in_lab [ i ] [ 1 ] ) and BuildingStatus ( IsInUnit ( mc_ape_in_lab [ i ] [ 1 ] ) ) <> bs_working then
37301: LD_EXP 104
37305: PUSH
37306: LD_VAR 0 2
37310: ARRAY
37311: PUSH
37312: LD_INT 1
37314: ARRAY
37315: PPUSH
37316: CALL_OW 310
37320: PUSH
37321: LD_EXP 104
37325: PUSH
37326: LD_VAR 0 2
37330: ARRAY
37331: PUSH
37332: LD_INT 1
37334: ARRAY
37335: PPUSH
37336: CALL_OW 310
37340: PPUSH
37341: CALL_OW 461
37345: PUSH
37346: LD_INT 3
37348: NONEQUAL
37349: AND
37350: IFFALSE 37371
// ComExitBuilding ( mc_ape_in_lab [ i ] [ 1 ] ) ;
37352: LD_EXP 104
37356: PUSH
37357: LD_VAR 0 2
37361: ARRAY
37362: PUSH
37363: LD_INT 1
37365: ARRAY
37366: PPUSH
37367: CALL_OW 122
// end ; if BuildingStatus ( j ) = bs_need_people and tmp > 1 then
37371: LD_VAR 0 3
37375: PPUSH
37376: CALL_OW 461
37380: PUSH
37381: LD_INT 6
37383: EQUAL
37384: PUSH
37385: LD_VAR 0 6
37389: PUSH
37390: LD_INT 1
37392: GREATER
37393: AND
37394: IFFALSE 37546
// begin sci := [ ] ;
37396: LD_ADDR_VAR 0 8
37400: PUSH
37401: EMPTY
37402: ST_TO_ADDR
// for x in ( tmp diff j ) do
37403: LD_ADDR_VAR 0 7
37407: PUSH
37408: LD_VAR 0 6
37412: PUSH
37413: LD_VAR 0 3
37417: DIFF
37418: PUSH
37419: FOR_IN
37420: IFFALSE 37472
// begin if sci = 6 then
37422: LD_VAR 0 8
37426: PUSH
37427: LD_INT 6
37429: EQUAL
37430: IFFALSE 37434
// break ;
37432: GO 37472
// if BuildingStatus ( x ) = bs_idle then
37434: LD_VAR 0 7
37438: PPUSH
37439: CALL_OW 461
37443: PUSH
37444: LD_INT 2
37446: EQUAL
37447: IFFALSE 37470
// sci := sci ^ UnitsInside ( x ) ;
37449: LD_ADDR_VAR 0 8
37453: PUSH
37454: LD_VAR 0 8
37458: PUSH
37459: LD_VAR 0 7
37463: PPUSH
37464: CALL_OW 313
37468: ADD
37469: ST_TO_ADDR
// end ;
37470: GO 37419
37472: POP
37473: POP
// if not sci then
37474: LD_VAR 0 8
37478: NOT
37479: IFFALSE 37483
// continue ;
37481: GO 36528
// for x in sci do
37483: LD_ADDR_VAR 0 7
37487: PUSH
37488: LD_VAR 0 8
37492: PUSH
37493: FOR_IN
37494: IFFALSE 37544
// if IsInUnit ( x ) and not HasTask ( x ) then
37496: LD_VAR 0 7
37500: PPUSH
37501: CALL_OW 310
37505: PUSH
37506: LD_VAR 0 7
37510: PPUSH
37511: CALL_OW 314
37515: NOT
37516: AND
37517: IFFALSE 37542
// begin ComExitBuilding ( x ) ;
37519: LD_VAR 0 7
37523: PPUSH
37524: CALL_OW 122
// AddComEnterUnit ( x , j ) ;
37528: LD_VAR 0 7
37532: PPUSH
37533: LD_VAR 0 3
37537: PPUSH
37538: CALL_OW 180
// end ;
37542: GO 37493
37544: POP
37545: POP
// end ; end ;
37546: GO 36528
37548: POP
37549: POP
// end ;
37550: GO 36482
37552: POP
37553: POP
// end ;
37554: LD_VAR 0 1
37558: RET
// export function MC_MinesTrigger ( ) ; var i ; begin
37559: LD_INT 0
37561: PPUSH
37562: PPUSH
// if not mc_bases then
37563: LD_EXP 74
37567: NOT
37568: IFFALSE 37572
// exit ;
37570: GO 37653
// for i = 1 to mc_bases do
37572: LD_ADDR_VAR 0 2
37576: PUSH
37577: DOUBLE
37578: LD_INT 1
37580: DEC
37581: ST_TO_ADDR
37582: LD_EXP 74
37586: PUSH
37587: FOR_TO
37588: IFFALSE 37651
// if mc_mines [ i ] and mc_miners [ i ] then
37590: LD_EXP 87
37594: PUSH
37595: LD_VAR 0 2
37599: ARRAY
37600: PUSH
37601: LD_EXP 88
37605: PUSH
37606: LD_VAR 0 2
37610: ARRAY
37611: AND
37612: IFFALSE 37649
// DetonateMines ( GetSide ( mc_miners [ i ] [ 1 ] ) , mc_mines [ i ] ) ;
37614: LD_EXP 88
37618: PUSH
37619: LD_VAR 0 2
37623: ARRAY
37624: PUSH
37625: LD_INT 1
37627: ARRAY
37628: PPUSH
37629: CALL_OW 255
37633: PPUSH
37634: LD_EXP 87
37638: PUSH
37639: LD_VAR 0 2
37643: ARRAY
37644: PPUSH
37645: CALL 54392 0 2
37649: GO 37587
37651: POP
37652: POP
// end ;
37653: LD_VAR 0 1
37657: RET
// export function MC_RepairVehicle ( ) ; var i , j , k , side , fac , vehs , tmp ; begin
37658: LD_INT 0
37660: PPUSH
37661: PPUSH
37662: PPUSH
37663: PPUSH
37664: PPUSH
37665: PPUSH
37666: PPUSH
37667: PPUSH
// if not mc_bases or not mc_parking then
37668: LD_EXP 74
37672: NOT
37673: PUSH
37674: LD_EXP 98
37678: NOT
37679: OR
37680: IFFALSE 37684
// exit ;
37682: GO 38383
// for i = 1 to mc_bases do
37684: LD_ADDR_VAR 0 2
37688: PUSH
37689: DOUBLE
37690: LD_INT 1
37692: DEC
37693: ST_TO_ADDR
37694: LD_EXP 74
37698: PUSH
37699: FOR_TO
37700: IFFALSE 38381
// begin if not mc_bases [ i ] or not mc_parking [ i ] then
37702: LD_EXP 74
37706: PUSH
37707: LD_VAR 0 2
37711: ARRAY
37712: NOT
37713: PUSH
37714: LD_EXP 98
37718: PUSH
37719: LD_VAR 0 2
37723: ARRAY
37724: NOT
37725: OR
37726: IFFALSE 37730
// continue ;
37728: GO 37699
// side := GetSide ( mc_bases [ i ] [ 1 ] ) ;
37730: LD_ADDR_VAR 0 5
37734: PUSH
37735: LD_EXP 74
37739: PUSH
37740: LD_VAR 0 2
37744: ARRAY
37745: PUSH
37746: LD_INT 1
37748: ARRAY
37749: PPUSH
37750: CALL_OW 255
37754: ST_TO_ADDR
// fac := UnitFilter ( mc_bases [ i ] , [ f_btype , b_factory ] ) ;
37755: LD_ADDR_VAR 0 6
37759: PUSH
37760: LD_EXP 74
37764: PUSH
37765: LD_VAR 0 2
37769: ARRAY
37770: PPUSH
37771: LD_INT 30
37773: PUSH
37774: LD_INT 3
37776: PUSH
37777: EMPTY
37778: LIST
37779: LIST
37780: PPUSH
37781: CALL_OW 72
37785: ST_TO_ADDR
// if not fac then
37786: LD_VAR 0 6
37790: NOT
37791: IFFALSE 37842
// fac := UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) ;
37793: LD_ADDR_VAR 0 6
37797: PUSH
37798: LD_EXP 74
37802: PUSH
37803: LD_VAR 0 2
37807: ARRAY
37808: PPUSH
37809: LD_INT 2
37811: PUSH
37812: LD_INT 30
37814: PUSH
37815: LD_INT 0
37817: PUSH
37818: EMPTY
37819: LIST
37820: LIST
37821: PUSH
37822: LD_INT 30
37824: PUSH
37825: LD_INT 1
37827: PUSH
37828: EMPTY
37829: LIST
37830: LIST
37831: PUSH
37832: EMPTY
37833: LIST
37834: LIST
37835: LIST
37836: PPUSH
37837: CALL_OW 72
37841: ST_TO_ADDR
// if not fac then
37842: LD_VAR 0 6
37846: NOT
37847: IFFALSE 37851
// continue ;
37849: GO 37699
// vehs := FilterUnitsInArea ( mc_parking [ i ] , [ [ f_side , side ] , [ f_type , unit_vehicle ] , [ f_not , [ f_lives , 1000 ] ] ] ) ;
37851: LD_ADDR_VAR 0 7
37855: PUSH
37856: LD_EXP 98
37860: PUSH
37861: LD_VAR 0 2
37865: ARRAY
37866: PPUSH
37867: LD_INT 22
37869: PUSH
37870: LD_VAR 0 5
37874: PUSH
37875: EMPTY
37876: LIST
37877: LIST
37878: PUSH
37879: LD_INT 21
37881: PUSH
37882: LD_INT 2
37884: PUSH
37885: EMPTY
37886: LIST
37887: LIST
37888: PUSH
37889: LD_INT 3
37891: PUSH
37892: LD_INT 24
37894: PUSH
37895: LD_INT 1000
37897: PUSH
37898: EMPTY
37899: LIST
37900: LIST
37901: PUSH
37902: EMPTY
37903: LIST
37904: LIST
37905: PUSH
37906: EMPTY
37907: LIST
37908: LIST
37909: LIST
37910: PPUSH
37911: CALL_OW 70
37915: ST_TO_ADDR
// for j in fac do
37916: LD_ADDR_VAR 0 3
37920: PUSH
37921: LD_VAR 0 6
37925: PUSH
37926: FOR_IN
37927: IFFALSE 38008
// vehs := vehs union FilterAllUnits ( [ [ f_side , side ] , [ f_dist , j , 15 ] , [ f_type , unit_vehicle ] , [ f_not , [ f_lives , 1000 ] ] ] ) ;
37929: LD_ADDR_VAR 0 7
37933: PUSH
37934: LD_VAR 0 7
37938: PUSH
37939: LD_INT 22
37941: PUSH
37942: LD_VAR 0 5
37946: PUSH
37947: EMPTY
37948: LIST
37949: LIST
37950: PUSH
37951: LD_INT 91
37953: PUSH
37954: LD_VAR 0 3
37958: PUSH
37959: LD_INT 15
37961: PUSH
37962: EMPTY
37963: LIST
37964: LIST
37965: LIST
37966: PUSH
37967: LD_INT 21
37969: PUSH
37970: LD_INT 2
37972: PUSH
37973: EMPTY
37974: LIST
37975: LIST
37976: PUSH
37977: LD_INT 3
37979: PUSH
37980: LD_INT 24
37982: PUSH
37983: LD_INT 1000
37985: PUSH
37986: EMPTY
37987: LIST
37988: LIST
37989: PUSH
37990: EMPTY
37991: LIST
37992: LIST
37993: PUSH
37994: EMPTY
37995: LIST
37996: LIST
37997: LIST
37998: LIST
37999: PPUSH
38000: CALL_OW 69
38004: UNION
38005: ST_TO_ADDR
38006: GO 37926
38008: POP
38009: POP
// if not vehs then
38010: LD_VAR 0 7
38014: NOT
38015: IFFALSE 38041
// begin mc_repair_vehicle := Replace ( mc_repair_vehicle , i , [ ] ) ;
38017: LD_ADDR_EXP 86
38021: PUSH
38022: LD_EXP 86
38026: PPUSH
38027: LD_VAR 0 2
38031: PPUSH
38032: EMPTY
38033: PPUSH
38034: CALL_OW 1
38038: ST_TO_ADDR
// continue ;
38039: GO 37699
// end ; tmp := UnitFilter ( mc_bases [ i ] , [ f_btype , b_factory ] ) ;
38041: LD_ADDR_VAR 0 8
38045: PUSH
38046: LD_EXP 74
38050: PUSH
38051: LD_VAR 0 2
38055: ARRAY
38056: PPUSH
38057: LD_INT 30
38059: PUSH
38060: LD_INT 3
38062: PUSH
38063: EMPTY
38064: LIST
38065: LIST
38066: PPUSH
38067: CALL_OW 72
38071: ST_TO_ADDR
// if tmp then
38072: LD_VAR 0 8
38076: IFFALSE 38179
// begin for j in tmp do
38078: LD_ADDR_VAR 0 3
38082: PUSH
38083: LD_VAR 0 8
38087: PUSH
38088: FOR_IN
38089: IFFALSE 38177
// for k in UnitsInside ( j ) do
38091: LD_ADDR_VAR 0 4
38095: PUSH
38096: LD_VAR 0 3
38100: PPUSH
38101: CALL_OW 313
38105: PUSH
38106: FOR_IN
38107: IFFALSE 38173
// if k then
38109: LD_VAR 0 4
38113: IFFALSE 38171
// if not k in mc_repair_vehicle [ i ] then
38115: LD_VAR 0 4
38119: PUSH
38120: LD_EXP 86
38124: PUSH
38125: LD_VAR 0 2
38129: ARRAY
38130: IN
38131: NOT
38132: IFFALSE 38171
// mc_repair_vehicle := Replace ( mc_repair_vehicle , i , mc_repair_vehicle [ i ] union k ) ;
38134: LD_ADDR_EXP 86
38138: PUSH
38139: LD_EXP 86
38143: PPUSH
38144: LD_VAR 0 2
38148: PPUSH
38149: LD_EXP 86
38153: PUSH
38154: LD_VAR 0 2
38158: ARRAY
38159: PUSH
38160: LD_VAR 0 4
38164: UNION
38165: PPUSH
38166: CALL_OW 1
38170: ST_TO_ADDR
38171: GO 38106
38173: POP
38174: POP
38175: GO 38088
38177: POP
38178: POP
// end ; if not mc_repair_vehicle [ i ] then
38179: LD_EXP 86
38183: PUSH
38184: LD_VAR 0 2
38188: ARRAY
38189: NOT
38190: IFFALSE 38194
// continue ;
38192: GO 37699
// for j in mc_repair_vehicle [ i ] do
38194: LD_ADDR_VAR 0 3
38198: PUSH
38199: LD_EXP 86
38203: PUSH
38204: LD_VAR 0 2
38208: ARRAY
38209: PUSH
38210: FOR_IN
38211: IFFALSE 38377
// begin if GetClass ( j ) <> 3 then
38213: LD_VAR 0 3
38217: PPUSH
38218: CALL_OW 257
38222: PUSH
38223: LD_INT 3
38225: NONEQUAL
38226: IFFALSE 38267
// begin mc_repair_vehicle := Replace ( mc_repair_vehicle , i , mc_repair_vehicle [ i ] diff j ) ;
38228: LD_ADDR_EXP 86
38232: PUSH
38233: LD_EXP 86
38237: PPUSH
38238: LD_VAR 0 2
38242: PPUSH
38243: LD_EXP 86
38247: PUSH
38248: LD_VAR 0 2
38252: ARRAY
38253: PUSH
38254: LD_VAR 0 3
38258: DIFF
38259: PPUSH
38260: CALL_OW 1
38264: ST_TO_ADDR
// continue ;
38265: GO 38210
// end ; if not IsDrivenBy ( j ) and not j in mc_need_heal [ i ] [ 1 ] and not j in mc_need_heal [ i ] [ 2 ] then
38267: LD_VAR 0 3
38271: PPUSH
38272: CALL_OW 311
38276: NOT
38277: PUSH
38278: LD_VAR 0 3
38282: PUSH
38283: LD_EXP 77
38287: PUSH
38288: LD_VAR 0 2
38292: ARRAY
38293: PUSH
38294: LD_INT 1
38296: ARRAY
38297: IN
38298: NOT
38299: AND
38300: PUSH
38301: LD_VAR 0 3
38305: PUSH
38306: LD_EXP 77
38310: PUSH
38311: LD_VAR 0 2
38315: ARRAY
38316: PUSH
38317: LD_INT 2
38319: ARRAY
38320: IN
38321: NOT
38322: AND
38323: IFFALSE 38375
// begin if IsInUnit ( j ) then
38325: LD_VAR 0 3
38329: PPUSH
38330: CALL_OW 310
38334: IFFALSE 38345
// ComExitBuilding ( j ) ;
38336: LD_VAR 0 3
38340: PPUSH
38341: CALL_OW 122
// if not HasTask ( j ) then
38345: LD_VAR 0 3
38349: PPUSH
38350: CALL_OW 314
38354: NOT
38355: IFFALSE 38375
// AddComRepairVehicle ( j , vehs [ 1 ] ) ;
38357: LD_VAR 0 3
38361: PPUSH
38362: LD_VAR 0 7
38366: PUSH
38367: LD_INT 1
38369: ARRAY
38370: PPUSH
38371: CALL_OW 189
// end ; end ;
38375: GO 38210
38377: POP
38378: POP
// end ;
38379: GO 37699
38381: POP
38382: POP
// end ;
38383: LD_VAR 0 1
38387: RET
// export function MC_TameApe ( ) ; var i , j , x , y , ape , apes , tmp , dep , danger_at_area , side ; begin
38388: LD_INT 0
38390: PPUSH
38391: PPUSH
38392: PPUSH
38393: PPUSH
38394: PPUSH
38395: PPUSH
38396: PPUSH
38397: PPUSH
38398: PPUSH
38399: PPUSH
38400: PPUSH
// if not mc_bases then
38401: LD_EXP 74
38405: NOT
38406: IFFALSE 38410
// exit ;
38408: GO 39212
// for i = 1 to mc_bases do
38410: LD_ADDR_VAR 0 2
38414: PUSH
38415: DOUBLE
38416: LD_INT 1
38418: DEC
38419: ST_TO_ADDR
38420: LD_EXP 74
38424: PUSH
38425: FOR_TO
38426: IFFALSE 39210
// begin if not mc_can_tame [ i ] or mc_need_heal [ i ] [ 1 ] or mc_need_heal [ i ] [ 2 ] or not Researched ( mc_sides [ i ] , tech_apelang ) or mc_scan [ i ] then
38428: LD_EXP 102
38432: PUSH
38433: LD_VAR 0 2
38437: ARRAY
38438: NOT
38439: PUSH
38440: LD_EXP 77
38444: PUSH
38445: LD_VAR 0 2
38449: ARRAY
38450: PUSH
38451: LD_INT 1
38453: ARRAY
38454: OR
38455: PUSH
38456: LD_EXP 77
38460: PUSH
38461: LD_VAR 0 2
38465: ARRAY
38466: PUSH
38467: LD_INT 2
38469: ARRAY
38470: OR
38471: PUSH
38472: LD_EXP 100
38476: PUSH
38477: LD_VAR 0 2
38481: ARRAY
38482: PPUSH
38483: LD_INT 1
38485: PPUSH
38486: CALL_OW 325
38490: NOT
38491: OR
38492: PUSH
38493: LD_EXP 97
38497: PUSH
38498: LD_VAR 0 2
38502: ARRAY
38503: OR
38504: IFFALSE 38508
// continue ;
38506: GO 38425
// tmp := UnitFilter ( mc_bases [ i ] , [ [ f_class , 4 ] , [ f_ok ] , [ f_not , [ f_hastask ] ] ] ) diff mc_healers [ i ] ;
38508: LD_ADDR_VAR 0 8
38512: PUSH
38513: LD_EXP 74
38517: PUSH
38518: LD_VAR 0 2
38522: ARRAY
38523: PPUSH
38524: LD_INT 25
38526: PUSH
38527: LD_INT 4
38529: PUSH
38530: EMPTY
38531: LIST
38532: LIST
38533: PUSH
38534: LD_INT 50
38536: PUSH
38537: EMPTY
38538: LIST
38539: PUSH
38540: LD_INT 3
38542: PUSH
38543: LD_INT 60
38545: PUSH
38546: EMPTY
38547: LIST
38548: PUSH
38549: EMPTY
38550: LIST
38551: LIST
38552: PUSH
38553: EMPTY
38554: LIST
38555: LIST
38556: LIST
38557: PPUSH
38558: CALL_OW 72
38562: PUSH
38563: LD_EXP 78
38567: PUSH
38568: LD_VAR 0 2
38572: ARRAY
38573: DIFF
38574: ST_TO_ADDR
// dep := UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) ;
38575: LD_ADDR_VAR 0 9
38579: PUSH
38580: LD_EXP 74
38584: PUSH
38585: LD_VAR 0 2
38589: ARRAY
38590: PPUSH
38591: LD_INT 2
38593: PUSH
38594: LD_INT 30
38596: PUSH
38597: LD_INT 0
38599: PUSH
38600: EMPTY
38601: LIST
38602: LIST
38603: PUSH
38604: LD_INT 30
38606: PUSH
38607: LD_INT 1
38609: PUSH
38610: EMPTY
38611: LIST
38612: LIST
38613: PUSH
38614: EMPTY
38615: LIST
38616: LIST
38617: LIST
38618: PPUSH
38619: CALL_OW 72
38623: ST_TO_ADDR
// if not tmp or not dep then
38624: LD_VAR 0 8
38628: NOT
38629: PUSH
38630: LD_VAR 0 9
38634: NOT
38635: OR
38636: IFFALSE 38640
// continue ;
38638: GO 38425
// side := GetSide ( tmp [ 1 ] ) ;
38640: LD_ADDR_VAR 0 11
38644: PUSH
38645: LD_VAR 0 8
38649: PUSH
38650: LD_INT 1
38652: ARRAY
38653: PPUSH
38654: CALL_OW 255
38658: ST_TO_ADDR
// dep := dep [ 1 ] ;
38659: LD_ADDR_VAR 0 9
38663: PUSH
38664: LD_VAR 0 9
38668: PUSH
38669: LD_INT 1
38671: ARRAY
38672: ST_TO_ADDR
// apes := FilterUnitsInArea ( mc_can_tame [ i ] , [ [ f_side , 0 ] , [ f_class , class_apeman ] ] ) union FilterAllUnits ( [ [ f_side , 0 ] , [ f_class , class_apeman ] , [ f_dist , dep , 20 ] ] ) ;
38673: LD_ADDR_VAR 0 7
38677: PUSH
38678: LD_EXP 102
38682: PUSH
38683: LD_VAR 0 2
38687: ARRAY
38688: PPUSH
38689: LD_INT 22
38691: PUSH
38692: LD_INT 0
38694: PUSH
38695: EMPTY
38696: LIST
38697: LIST
38698: PUSH
38699: LD_INT 25
38701: PUSH
38702: LD_INT 12
38704: PUSH
38705: EMPTY
38706: LIST
38707: LIST
38708: PUSH
38709: EMPTY
38710: LIST
38711: LIST
38712: PPUSH
38713: CALL_OW 70
38717: PUSH
38718: LD_INT 22
38720: PUSH
38721: LD_INT 0
38723: PUSH
38724: EMPTY
38725: LIST
38726: LIST
38727: PUSH
38728: LD_INT 25
38730: PUSH
38731: LD_INT 12
38733: PUSH
38734: EMPTY
38735: LIST
38736: LIST
38737: PUSH
38738: LD_INT 91
38740: PUSH
38741: LD_VAR 0 9
38745: PUSH
38746: LD_INT 20
38748: PUSH
38749: EMPTY
38750: LIST
38751: LIST
38752: LIST
38753: PUSH
38754: EMPTY
38755: LIST
38756: LIST
38757: LIST
38758: PPUSH
38759: CALL_OW 69
38763: UNION
38764: ST_TO_ADDR
// danger_at_area := FilterUnitsInArea ( mc_can_tame [ i ] , [ f_enemy , side ] ) ;
38765: LD_ADDR_VAR 0 10
38769: PUSH
38770: LD_EXP 102
38774: PUSH
38775: LD_VAR 0 2
38779: ARRAY
38780: PPUSH
38781: LD_INT 81
38783: PUSH
38784: LD_VAR 0 11
38788: PUSH
38789: EMPTY
38790: LIST
38791: LIST
38792: PPUSH
38793: CALL_OW 70
38797: ST_TO_ADDR
// if not apes or danger_at_area then
38798: LD_VAR 0 7
38802: NOT
38803: PUSH
38804: LD_VAR 0 10
38808: OR
38809: IFFALSE 38859
// begin if mc_taming [ i ] then
38811: LD_EXP 105
38815: PUSH
38816: LD_VAR 0 2
38820: ARRAY
38821: IFFALSE 38857
// begin MC_Reset ( i , 121 ) ;
38823: LD_VAR 0 2
38827: PPUSH
38828: LD_INT 121
38830: PPUSH
38831: CALL 24190 0 2
// mc_taming := Replace ( mc_taming , i , [ ] ) ;
38835: LD_ADDR_EXP 105
38839: PUSH
38840: LD_EXP 105
38844: PPUSH
38845: LD_VAR 0 2
38849: PPUSH
38850: EMPTY
38851: PPUSH
38852: CALL_OW 1
38856: ST_TO_ADDR
// end ; continue ;
38857: GO 38425
// end ; for j in tmp do
38859: LD_ADDR_VAR 0 3
38863: PUSH
38864: LD_VAR 0 8
38868: PUSH
38869: FOR_IN
38870: IFFALSE 39206
// begin if not j in mc_taming [ i ] and mc_taming [ i ] < 3 then
38872: LD_VAR 0 3
38876: PUSH
38877: LD_EXP 105
38881: PUSH
38882: LD_VAR 0 2
38886: ARRAY
38887: IN
38888: NOT
38889: PUSH
38890: LD_EXP 105
38894: PUSH
38895: LD_VAR 0 2
38899: ARRAY
38900: PUSH
38901: LD_INT 3
38903: LESS
38904: AND
38905: IFFALSE 38963
// begin SetTag ( j , 121 ) ;
38907: LD_VAR 0 3
38911: PPUSH
38912: LD_INT 121
38914: PPUSH
38915: CALL_OW 109
// mc_taming := ReplaceIn ( mc_taming , [ i , mc_taming [ i ] + 1 ] , j ) ;
38919: LD_ADDR_EXP 105
38923: PUSH
38924: LD_EXP 105
38928: PPUSH
38929: LD_VAR 0 2
38933: PUSH
38934: LD_EXP 105
38938: PUSH
38939: LD_VAR 0 2
38943: ARRAY
38944: PUSH
38945: LD_INT 1
38947: PLUS
38948: PUSH
38949: EMPTY
38950: LIST
38951: LIST
38952: PPUSH
38953: LD_VAR 0 3
38957: PPUSH
38958: CALL 57403 0 3
38962: ST_TO_ADDR
// end ; if j in mc_taming [ i ] then
38963: LD_VAR 0 3
38967: PUSH
38968: LD_EXP 105
38972: PUSH
38973: LD_VAR 0 2
38977: ARRAY
38978: IN
38979: IFFALSE 39204
// begin if GetClass ( j ) <> 4 then
38981: LD_VAR 0 3
38985: PPUSH
38986: CALL_OW 257
38990: PUSH
38991: LD_INT 4
38993: NONEQUAL
38994: IFFALSE 39047
// begin mc_taming := Replace ( mc_taming , i , mc_taming [ i ] diff j ) ;
38996: LD_ADDR_EXP 105
39000: PUSH
39001: LD_EXP 105
39005: PPUSH
39006: LD_VAR 0 2
39010: PPUSH
39011: LD_EXP 105
39015: PUSH
39016: LD_VAR 0 2
39020: ARRAY
39021: PUSH
39022: LD_VAR 0 3
39026: DIFF
39027: PPUSH
39028: CALL_OW 1
39032: ST_TO_ADDR
// SetTag ( j , 0 ) ;
39033: LD_VAR 0 3
39037: PPUSH
39038: LD_INT 0
39040: PPUSH
39041: CALL_OW 109
// continue ;
39045: GO 38869
// end ; if IsInUnit ( j ) then
39047: LD_VAR 0 3
39051: PPUSH
39052: CALL_OW 310
39056: IFFALSE 39067
// ComExitBuilding ( j ) ;
39058: LD_VAR 0 3
39062: PPUSH
39063: CALL_OW 122
// ape := NearestUnitToUnit ( apes , j ) ;
39067: LD_ADDR_VAR 0 6
39071: PUSH
39072: LD_VAR 0 7
39076: PPUSH
39077: LD_VAR 0 3
39081: PPUSH
39082: CALL_OW 74
39086: ST_TO_ADDR
// if not ape then
39087: LD_VAR 0 6
39091: NOT
39092: IFFALSE 39096
// break ;
39094: GO 39206
// x := GetX ( ape ) ;
39096: LD_ADDR_VAR 0 4
39100: PUSH
39101: LD_VAR 0 6
39105: PPUSH
39106: CALL_OW 250
39110: ST_TO_ADDR
// y := GetY ( ape ) ;
39111: LD_ADDR_VAR 0 5
39115: PUSH
39116: LD_VAR 0 6
39120: PPUSH
39121: CALL_OW 251
39125: ST_TO_ADDR
// if not ValidHex ( x , y ) or DangerAtRangeXY ( side , x , y , 20 ) [ 4 ] then
39126: LD_VAR 0 4
39130: PPUSH
39131: LD_VAR 0 5
39135: PPUSH
39136: CALL_OW 488
39140: NOT
39141: PUSH
39142: LD_VAR 0 11
39146: PPUSH
39147: LD_VAR 0 4
39151: PPUSH
39152: LD_VAR 0 5
39156: PPUSH
39157: LD_INT 20
39159: PPUSH
39160: CALL 58299 0 4
39164: PUSH
39165: LD_INT 4
39167: ARRAY
39168: OR
39169: IFFALSE 39173
// break ;
39171: GO 39206
// if not HasTask ( j ) then
39173: LD_VAR 0 3
39177: PPUSH
39178: CALL_OW 314
39182: NOT
39183: IFFALSE 39204
// ComTameXY ( j , x , y ) ;
39185: LD_VAR 0 3
39189: PPUSH
39190: LD_VAR 0 4
39194: PPUSH
39195: LD_VAR 0 5
39199: PPUSH
39200: CALL_OW 131
// end ; end ;
39204: GO 38869
39206: POP
39207: POP
// end ;
39208: GO 38425
39210: POP
39211: POP
// end ;
39212: LD_VAR 0 1
39216: RET
// export function MC_ChangeApeClass ( ) ; var i , j , tmp , side , depot , selected , barracks ; begin
39217: LD_INT 0
39219: PPUSH
39220: PPUSH
39221: PPUSH
39222: PPUSH
39223: PPUSH
39224: PPUSH
39225: PPUSH
39226: PPUSH
// if not mc_bases then
39227: LD_EXP 74
39231: NOT
39232: IFFALSE 39236
// exit ;
39234: GO 39862
// for i = 1 to mc_bases do
39236: LD_ADDR_VAR 0 2
39240: PUSH
39241: DOUBLE
39242: LD_INT 1
39244: DEC
39245: ST_TO_ADDR
39246: LD_EXP 74
39250: PUSH
39251: FOR_TO
39252: IFFALSE 39860
// begin if not mc_ape [ i ] or not UnitFilter ( mc_ape [ i ] , [ f_class , 12 ] ) then
39254: LD_EXP 103
39258: PUSH
39259: LD_VAR 0 2
39263: ARRAY
39264: NOT
39265: PUSH
39266: LD_EXP 103
39270: PUSH
39271: LD_VAR 0 2
39275: ARRAY
39276: PPUSH
39277: LD_INT 25
39279: PUSH
39280: LD_INT 12
39282: PUSH
39283: EMPTY
39284: LIST
39285: LIST
39286: PPUSH
39287: CALL_OW 72
39291: NOT
39292: OR
39293: IFFALSE 39297
// continue ;
39295: GO 39251
// side := GetSide ( mc_ape [ i ] [ 1 ] ) ;
39297: LD_ADDR_VAR 0 5
39301: PUSH
39302: LD_EXP 103
39306: PUSH
39307: LD_VAR 0 2
39311: ARRAY
39312: PUSH
39313: LD_INT 1
39315: ARRAY
39316: PPUSH
39317: CALL_OW 255
39321: ST_TO_ADDR
// if Researched ( side , tech_apepsych ) then
39322: LD_VAR 0 5
39326: PPUSH
39327: LD_INT 2
39329: PPUSH
39330: CALL_OW 325
39334: IFFALSE 39587
// begin tmp := UnitFilter ( mc_ape [ i ] , [ f_class , 16 ] ) ;
39336: LD_ADDR_VAR 0 4
39340: PUSH
39341: LD_EXP 103
39345: PUSH
39346: LD_VAR 0 2
39350: ARRAY
39351: PPUSH
39352: LD_INT 25
39354: PUSH
39355: LD_INT 16
39357: PUSH
39358: EMPTY
39359: LIST
39360: LIST
39361: PPUSH
39362: CALL_OW 72
39366: ST_TO_ADDR
// if tmp < 6 then
39367: LD_VAR 0 4
39371: PUSH
39372: LD_INT 6
39374: LESS
39375: IFFALSE 39587
// begin depot := UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) ;
39377: LD_ADDR_VAR 0 6
39381: PUSH
39382: LD_EXP 74
39386: PUSH
39387: LD_VAR 0 2
39391: ARRAY
39392: PPUSH
39393: LD_INT 2
39395: PUSH
39396: LD_INT 30
39398: PUSH
39399: LD_INT 0
39401: PUSH
39402: EMPTY
39403: LIST
39404: LIST
39405: PUSH
39406: LD_INT 30
39408: PUSH
39409: LD_INT 1
39411: PUSH
39412: EMPTY
39413: LIST
39414: LIST
39415: PUSH
39416: EMPTY
39417: LIST
39418: LIST
39419: LIST
39420: PPUSH
39421: CALL_OW 72
39425: ST_TO_ADDR
// if depot then
39426: LD_VAR 0 6
39430: IFFALSE 39587
// begin selected := 0 ;
39432: LD_ADDR_VAR 0 7
39436: PUSH
39437: LD_INT 0
39439: ST_TO_ADDR
// for j in depot do
39440: LD_ADDR_VAR 0 3
39444: PUSH
39445: LD_VAR 0 6
39449: PUSH
39450: FOR_IN
39451: IFFALSE 39482
// begin if UnitsInside ( j ) < 6 then
39453: LD_VAR 0 3
39457: PPUSH
39458: CALL_OW 313
39462: PUSH
39463: LD_INT 6
39465: LESS
39466: IFFALSE 39480
// begin selected := j ;
39468: LD_ADDR_VAR 0 7
39472: PUSH
39473: LD_VAR 0 3
39477: ST_TO_ADDR
// break ;
39478: GO 39482
// end ; end ;
39480: GO 39450
39482: POP
39483: POP
// if selected then
39484: LD_VAR 0 7
39488: IFFALSE 39587
// begin for j in UnitFilter ( mc_ape [ i ] , [ f_class , 12 ] ) do
39490: LD_ADDR_VAR 0 3
39494: PUSH
39495: LD_EXP 103
39499: PUSH
39500: LD_VAR 0 2
39504: ARRAY
39505: PPUSH
39506: LD_INT 25
39508: PUSH
39509: LD_INT 12
39511: PUSH
39512: EMPTY
39513: LIST
39514: LIST
39515: PPUSH
39516: CALL_OW 72
39520: PUSH
39521: FOR_IN
39522: IFFALSE 39585
// if not HasTask ( j ) then
39524: LD_VAR 0 3
39528: PPUSH
39529: CALL_OW 314
39533: NOT
39534: IFFALSE 39583
// begin if not IsInUnit ( j ) then
39536: LD_VAR 0 3
39540: PPUSH
39541: CALL_OW 310
39545: NOT
39546: IFFALSE 39562
// ComEnterUnit ( j , selected ) ;
39548: LD_VAR 0 3
39552: PPUSH
39553: LD_VAR 0 7
39557: PPUSH
39558: CALL_OW 120
// AddComChangeProfession ( j , 16 ) ;
39562: LD_VAR 0 3
39566: PPUSH
39567: LD_INT 16
39569: PPUSH
39570: CALL_OW 183
// AddComExitBuilding ( j ) ;
39574: LD_VAR 0 3
39578: PPUSH
39579: CALL_OW 182
// end ;
39583: GO 39521
39585: POP
39586: POP
// end ; end ; end ; end ; if Researched ( side , tech_apeagres ) then
39587: LD_VAR 0 5
39591: PPUSH
39592: LD_INT 11
39594: PPUSH
39595: CALL_OW 325
39599: IFFALSE 39858
// begin tmp := UnitFilter ( mc_ape [ i ] , [ f_class , 16 ] ) ;
39601: LD_ADDR_VAR 0 4
39605: PUSH
39606: LD_EXP 103
39610: PUSH
39611: LD_VAR 0 2
39615: ARRAY
39616: PPUSH
39617: LD_INT 25
39619: PUSH
39620: LD_INT 16
39622: PUSH
39623: EMPTY
39624: LIST
39625: LIST
39626: PPUSH
39627: CALL_OW 72
39631: ST_TO_ADDR
// if tmp >= 6 or not Researched ( side , tech_apepsych ) then
39632: LD_VAR 0 4
39636: PUSH
39637: LD_INT 6
39639: GREATEREQUAL
39640: PUSH
39641: LD_VAR 0 5
39645: PPUSH
39646: LD_INT 2
39648: PPUSH
39649: CALL_OW 325
39653: NOT
39654: OR
39655: IFFALSE 39858
// begin barracks := UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_armoury ] , [ f_btype , b_barracks ] ] ) ;
39657: LD_ADDR_VAR 0 8
39661: PUSH
39662: LD_EXP 74
39666: PUSH
39667: LD_VAR 0 2
39671: ARRAY
39672: PPUSH
39673: LD_INT 2
39675: PUSH
39676: LD_INT 30
39678: PUSH
39679: LD_INT 4
39681: PUSH
39682: EMPTY
39683: LIST
39684: LIST
39685: PUSH
39686: LD_INT 30
39688: PUSH
39689: LD_INT 5
39691: PUSH
39692: EMPTY
39693: LIST
39694: LIST
39695: PUSH
39696: EMPTY
39697: LIST
39698: LIST
39699: LIST
39700: PPUSH
39701: CALL_OW 72
39705: ST_TO_ADDR
// if barracks then
39706: LD_VAR 0 8
39710: IFFALSE 39858
// begin selected := 0 ;
39712: LD_ADDR_VAR 0 7
39716: PUSH
39717: LD_INT 0
39719: ST_TO_ADDR
// for j in barracks do
39720: LD_ADDR_VAR 0 3
39724: PUSH
39725: LD_VAR 0 8
39729: PUSH
39730: FOR_IN
39731: IFFALSE 39762
// begin if UnitsInside ( j ) < 6 then
39733: LD_VAR 0 3
39737: PPUSH
39738: CALL_OW 313
39742: PUSH
39743: LD_INT 6
39745: LESS
39746: IFFALSE 39760
// begin selected := j ;
39748: LD_ADDR_VAR 0 7
39752: PUSH
39753: LD_VAR 0 3
39757: ST_TO_ADDR
// break ;
39758: GO 39762
// end ; end ;
39760: GO 39730
39762: POP
39763: POP
// if selected then
39764: LD_VAR 0 7
39768: IFFALSE 39858
// begin for j in UnitFilter ( mc_ape [ i ] , [ f_class , 12 ] ) do
39770: LD_ADDR_VAR 0 3
39774: PUSH
39775: LD_EXP 103
39779: PUSH
39780: LD_VAR 0 2
39784: ARRAY
39785: PPUSH
39786: LD_INT 25
39788: PUSH
39789: LD_INT 12
39791: PUSH
39792: EMPTY
39793: LIST
39794: LIST
39795: PPUSH
39796: CALL_OW 72
39800: PUSH
39801: FOR_IN
39802: IFFALSE 39856
// if not IsInUnit ( j ) and not HasTask ( j ) then
39804: LD_VAR 0 3
39808: PPUSH
39809: CALL_OW 310
39813: NOT
39814: PUSH
39815: LD_VAR 0 3
39819: PPUSH
39820: CALL_OW 314
39824: NOT
39825: AND
39826: IFFALSE 39854
// begin ComEnterUnit ( j , selected ) ;
39828: LD_VAR 0 3
39832: PPUSH
39833: LD_VAR 0 7
39837: PPUSH
39838: CALL_OW 120
// AddComChangeProfession ( j , 15 ) ;
39842: LD_VAR 0 3
39846: PPUSH
39847: LD_INT 15
39849: PPUSH
39850: CALL_OW 183
// end ;
39854: GO 39801
39856: POP
39857: POP
// end ; end ; end ; end ; end ;
39858: GO 39251
39860: POP
39861: POP
// end ;
39862: LD_VAR 0 1
39866: RET
// export function MC_Bazooka ( ) ; var i , j , tmp ; begin
39867: LD_INT 0
39869: PPUSH
39870: PPUSH
39871: PPUSH
39872: PPUSH
// if not mc_bases then
39873: LD_EXP 74
39877: NOT
39878: IFFALSE 39882
// exit ;
39880: GO 40060
// for i = 1 to mc_bases do
39882: LD_ADDR_VAR 0 2
39886: PUSH
39887: DOUBLE
39888: LD_INT 1
39890: DEC
39891: ST_TO_ADDR
39892: LD_EXP 74
39896: PUSH
39897: FOR_TO
39898: IFFALSE 40058
// begin tmp := UnitFilter ( mc_bases [ i ] , [ f_class , class_bazooker ] ) ;
39900: LD_ADDR_VAR 0 4
39904: PUSH
39905: LD_EXP 74
39909: PUSH
39910: LD_VAR 0 2
39914: ARRAY
39915: PPUSH
39916: LD_INT 25
39918: PUSH
39919: LD_INT 9
39921: PUSH
39922: EMPTY
39923: LIST
39924: LIST
39925: PPUSH
39926: CALL_OW 72
39930: ST_TO_ADDR
// if not tmp then
39931: LD_VAR 0 4
39935: NOT
39936: IFFALSE 39940
// continue ;
39938: GO 39897
// if not Researched ( mc_sides [ i ] , tech_spacanom ) and not Researched ( mc_sides [ i ] , tech_taurad ) then
39940: LD_EXP 100
39944: PUSH
39945: LD_VAR 0 2
39949: ARRAY
39950: PPUSH
39951: LD_INT 29
39953: PPUSH
39954: CALL_OW 325
39958: NOT
39959: PUSH
39960: LD_EXP 100
39964: PUSH
39965: LD_VAR 0 2
39969: ARRAY
39970: PPUSH
39971: LD_INT 28
39973: PPUSH
39974: CALL_OW 325
39978: NOT
39979: AND
39980: IFFALSE 39984
// continue ;
39982: GO 39897
// for j in tmp do
39984: LD_ADDR_VAR 0 3
39988: PUSH
39989: LD_VAR 0 4
39993: PUSH
39994: FOR_IN
39995: IFFALSE 40054
// if not j in mc_need_heal [ i ] [ 1 ] and not j in mc_need_heal [ i ] [ 2 ] then
39997: LD_VAR 0 3
40001: PUSH
40002: LD_EXP 77
40006: PUSH
40007: LD_VAR 0 2
40011: ARRAY
40012: PUSH
40013: LD_INT 1
40015: ARRAY
40016: IN
40017: NOT
40018: PUSH
40019: LD_VAR 0 3
40023: PUSH
40024: LD_EXP 77
40028: PUSH
40029: LD_VAR 0 2
40033: ARRAY
40034: PUSH
40035: LD_INT 2
40037: ARRAY
40038: IN
40039: NOT
40040: AND
40041: IFFALSE 40052
// ComSpaceTimeShoot ( j ) ;
40043: LD_VAR 0 3
40047: PPUSH
40048: CALL 51078 0 1
40052: GO 39994
40054: POP
40055: POP
// end ;
40056: GO 39897
40058: POP
40059: POP
// end ;
40060: LD_VAR 0 1
40064: RET
// export function MC_TeleportExit ( ) ; var i , j , x , y , save_point , tmp , teleports , sci ; begin
40065: LD_INT 0
40067: PPUSH
40068: PPUSH
40069: PPUSH
40070: PPUSH
40071: PPUSH
40072: PPUSH
40073: PPUSH
40074: PPUSH
40075: PPUSH
// if not mc_bases then
40076: LD_EXP 74
40080: NOT
40081: IFFALSE 40085
// exit ;
40083: GO 40707
// for i = 1 to mc_bases do
40085: LD_ADDR_VAR 0 2
40089: PUSH
40090: DOUBLE
40091: LD_INT 1
40093: DEC
40094: ST_TO_ADDR
40095: LD_EXP 74
40099: PUSH
40100: FOR_TO
40101: IFFALSE 40705
// begin if not mc_teleport_exit [ i ] or GetTech ( tech_targTeleport , mc_sides [ i ] ) <> state_researched then
40103: LD_EXP 109
40107: PUSH
40108: LD_VAR 0 2
40112: ARRAY
40113: NOT
40114: PUSH
40115: LD_INT 38
40117: PPUSH
40118: LD_EXP 100
40122: PUSH
40123: LD_VAR 0 2
40127: ARRAY
40128: PPUSH
40129: CALL_OW 321
40133: PUSH
40134: LD_INT 2
40136: NONEQUAL
40137: OR
40138: IFFALSE 40142
// continue ;
40140: GO 40100
// teleports := UnitFilter ( mc_bases [ i ] , [ f_btype , b_teleport ] ) ;
40142: LD_ADDR_VAR 0 8
40146: PUSH
40147: LD_EXP 74
40151: PUSH
40152: LD_VAR 0 2
40156: ARRAY
40157: PPUSH
40158: LD_INT 30
40160: PUSH
40161: LD_INT 34
40163: PUSH
40164: EMPTY
40165: LIST
40166: LIST
40167: PPUSH
40168: CALL_OW 72
40172: ST_TO_ADDR
// sci := FilterByTag ( UnitFilter ( mc_bases [ i ] , [ f_class , 4 ] ) , 0 ) ;
40173: LD_ADDR_VAR 0 9
40177: PUSH
40178: LD_EXP 74
40182: PUSH
40183: LD_VAR 0 2
40187: ARRAY
40188: PPUSH
40189: LD_INT 25
40191: PUSH
40192: LD_INT 4
40194: PUSH
40195: EMPTY
40196: LIST
40197: LIST
40198: PPUSH
40199: CALL_OW 72
40203: PPUSH
40204: LD_INT 0
40206: PPUSH
40207: CALL 90663 0 2
40211: ST_TO_ADDR
// if not sci or not teleports or FilterByTag ( mc_bases [ i ] , 124 ) then
40212: LD_VAR 0 9
40216: NOT
40217: PUSH
40218: LD_VAR 0 8
40222: NOT
40223: OR
40224: PUSH
40225: LD_EXP 74
40229: PUSH
40230: LD_VAR 0 2
40234: ARRAY
40235: PPUSH
40236: LD_INT 124
40238: PPUSH
40239: CALL 90663 0 2
40243: OR
40244: IFFALSE 40248
// continue ;
40246: GO 40100
// if mc_teleport_exit_set [ i ] < mc_teleport_exit [ i ] and mc_teleport_exit_set [ i ] < teleports then
40248: LD_EXP 110
40252: PUSH
40253: LD_VAR 0 2
40257: ARRAY
40258: PUSH
40259: LD_EXP 109
40263: PUSH
40264: LD_VAR 0 2
40268: ARRAY
40269: LESS
40270: PUSH
40271: LD_EXP 110
40275: PUSH
40276: LD_VAR 0 2
40280: ARRAY
40281: PUSH
40282: LD_VAR 0 8
40286: LESS
40287: AND
40288: IFFALSE 40703
// begin tmp := sci [ 1 ] ;
40290: LD_ADDR_VAR 0 7
40294: PUSH
40295: LD_VAR 0 9
40299: PUSH
40300: LD_INT 1
40302: ARRAY
40303: ST_TO_ADDR
// SetTag ( tmp , 124 ) ;
40304: LD_VAR 0 7
40308: PPUSH
40309: LD_INT 124
40311: PPUSH
40312: CALL_OW 109
// for j = mc_teleport_exit [ i ] downto mc_teleport_exit [ i ] do
40316: LD_ADDR_VAR 0 3
40320: PUSH
40321: DOUBLE
40322: LD_EXP 109
40326: PUSH
40327: LD_VAR 0 2
40331: ARRAY
40332: INC
40333: ST_TO_ADDR
40334: LD_EXP 109
40338: PUSH
40339: LD_VAR 0 2
40343: ARRAY
40344: PUSH
40345: FOR_DOWNTO
40346: IFFALSE 40689
// begin if IsInUnit ( tmp ) then
40348: LD_VAR 0 7
40352: PPUSH
40353: CALL_OW 310
40357: IFFALSE 40368
// ComExitBuilding ( tmp ) ;
40359: LD_VAR 0 7
40363: PPUSH
40364: CALL_OW 122
// repeat wait ( 0 0$1 ) ;
40368: LD_INT 35
40370: PPUSH
40371: CALL_OW 67
// until not IsInUnit ( tmp ) and not HasTask ( tmp ) ;
40375: LD_VAR 0 7
40379: PPUSH
40380: CALL_OW 310
40384: NOT
40385: PUSH
40386: LD_VAR 0 7
40390: PPUSH
40391: CALL_OW 314
40395: NOT
40396: AND
40397: IFFALSE 40368
// save_point := [ GetX ( tmp ) , GetY ( tmp ) ] ;
40399: LD_ADDR_VAR 0 6
40403: PUSH
40404: LD_VAR 0 7
40408: PPUSH
40409: CALL_OW 250
40413: PUSH
40414: LD_VAR 0 7
40418: PPUSH
40419: CALL_OW 251
40423: PUSH
40424: EMPTY
40425: LIST
40426: LIST
40427: ST_TO_ADDR
// repeat wait ( 0 0$1 ) ;
40428: LD_INT 35
40430: PPUSH
40431: CALL_OW 67
// x := mc_teleport_exit [ i ] [ j ] [ 1 ] ;
40435: LD_ADDR_VAR 0 4
40439: PUSH
40440: LD_EXP 109
40444: PUSH
40445: LD_VAR 0 2
40449: ARRAY
40450: PUSH
40451: LD_VAR 0 3
40455: ARRAY
40456: PUSH
40457: LD_INT 1
40459: ARRAY
40460: ST_TO_ADDR
// y := mc_teleport_exit [ i ] [ j ] [ 2 ] ;
40461: LD_ADDR_VAR 0 5
40465: PUSH
40466: LD_EXP 109
40470: PUSH
40471: LD_VAR 0 2
40475: ARRAY
40476: PUSH
40477: LD_VAR 0 3
40481: ARRAY
40482: PUSH
40483: LD_INT 2
40485: ARRAY
40486: ST_TO_ADDR
// if DangerAtRange ( tmp , 10 ) [ 4 ] then
40487: LD_VAR 0 7
40491: PPUSH
40492: LD_INT 10
40494: PPUSH
40495: CALL 59996 0 2
40499: PUSH
40500: LD_INT 4
40502: ARRAY
40503: IFFALSE 40541
// begin ComMoveXY ( tmp , save_point [ 1 ] , save_point [ 2 ] ) ;
40505: LD_VAR 0 7
40509: PPUSH
40510: LD_VAR 0 6
40514: PUSH
40515: LD_INT 1
40517: ARRAY
40518: PPUSH
40519: LD_VAR 0 6
40523: PUSH
40524: LD_INT 2
40526: ARRAY
40527: PPUSH
40528: CALL_OW 111
// wait ( 0 0$10 ) ;
40532: LD_INT 350
40534: PPUSH
40535: CALL_OW 67
// end else
40539: GO 40567
// begin ComMoveXY ( tmp , x , y ) ;
40541: LD_VAR 0 7
40545: PPUSH
40546: LD_VAR 0 4
40550: PPUSH
40551: LD_VAR 0 5
40555: PPUSH
40556: CALL_OW 111
// wait ( 0 0$3 ) ;
40560: LD_INT 105
40562: PPUSH
40563: CALL_OW 67
// end ; until IsAt ( tmp , x , y ) ;
40567: LD_VAR 0 7
40571: PPUSH
40572: LD_VAR 0 4
40576: PPUSH
40577: LD_VAR 0 5
40581: PPUSH
40582: CALL_OW 307
40586: IFFALSE 40428
// ComTeleportExit ( tmp , x , y , teleports [ j ] ) ;
40588: LD_VAR 0 7
40592: PPUSH
40593: LD_VAR 0 4
40597: PPUSH
40598: LD_VAR 0 5
40602: PPUSH
40603: LD_VAR 0 8
40607: PUSH
40608: LD_VAR 0 3
40612: ARRAY
40613: PPUSH
40614: CALL_OW 156
// repeat wait ( 0 0$1 ) ;
40618: LD_INT 35
40620: PPUSH
40621: CALL_OW 67
// until not HasTask ( tmp ) ;
40625: LD_VAR 0 7
40629: PPUSH
40630: CALL_OW 314
40634: NOT
40635: IFFALSE 40618
// mc_teleport_exit_set := ReplaceIn ( mc_teleport_exit_set , [ i , mc_teleport_exit_set [ i ] + 1 ] , teleports [ j ] ) ;
40637: LD_ADDR_EXP 110
40641: PUSH
40642: LD_EXP 110
40646: PPUSH
40647: LD_VAR 0 2
40651: PUSH
40652: LD_EXP 110
40656: PUSH
40657: LD_VAR 0 2
40661: ARRAY
40662: PUSH
40663: LD_INT 1
40665: PLUS
40666: PUSH
40667: EMPTY
40668: LIST
40669: LIST
40670: PPUSH
40671: LD_VAR 0 8
40675: PUSH
40676: LD_VAR 0 3
40680: ARRAY
40681: PPUSH
40682: CALL 57403 0 3
40686: ST_TO_ADDR
// end ;
40687: GO 40345
40689: POP
40690: POP
// MC_Reset ( i , 124 ) ;
40691: LD_VAR 0 2
40695: PPUSH
40696: LD_INT 124
40698: PPUSH
40699: CALL 24190 0 2
// end ; end ;
40703: GO 40100
40705: POP
40706: POP
// end ;
40707: LD_VAR 0 1
40711: RET
// export function MC_Deposits ( ) ; var i , tmp ; begin
40712: LD_INT 0
40714: PPUSH
40715: PPUSH
40716: PPUSH
// if not mc_bases then
40717: LD_EXP 74
40721: NOT
40722: IFFALSE 40726
// exit ;
40724: GO 41332
// for i = 1 to mc_bases do
40726: LD_ADDR_VAR 0 2
40730: PUSH
40731: DOUBLE
40732: LD_INT 1
40734: DEC
40735: ST_TO_ADDR
40736: LD_EXP 74
40740: PUSH
40741: FOR_TO
40742: IFFALSE 41330
// begin tmp := UnitFilter ( mc_bases [ i ] , [ f_class , 4 ] ) ;
40744: LD_ADDR_VAR 0 3
40748: PUSH
40749: LD_EXP 74
40753: PUSH
40754: LD_VAR 0 2
40758: ARRAY
40759: PPUSH
40760: LD_INT 25
40762: PUSH
40763: LD_INT 4
40765: PUSH
40766: EMPTY
40767: LIST
40768: LIST
40769: PPUSH
40770: CALL_OW 72
40774: ST_TO_ADDR
// if not tmp or not mc_deposits_xy [ i ] or not UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) then
40775: LD_VAR 0 3
40779: NOT
40780: PUSH
40781: LD_EXP 111
40785: PUSH
40786: LD_VAR 0 2
40790: ARRAY
40791: NOT
40792: OR
40793: PUSH
40794: LD_EXP 74
40798: PUSH
40799: LD_VAR 0 2
40803: ARRAY
40804: PPUSH
40805: LD_INT 2
40807: PUSH
40808: LD_INT 30
40810: PUSH
40811: LD_INT 0
40813: PUSH
40814: EMPTY
40815: LIST
40816: LIST
40817: PUSH
40818: LD_INT 30
40820: PUSH
40821: LD_INT 1
40823: PUSH
40824: EMPTY
40825: LIST
40826: LIST
40827: PUSH
40828: EMPTY
40829: LIST
40830: LIST
40831: LIST
40832: PPUSH
40833: CALL_OW 72
40837: NOT
40838: OR
40839: IFFALSE 40889
// begin if mc_deposits_finder [ i ] then
40841: LD_EXP 112
40845: PUSH
40846: LD_VAR 0 2
40850: ARRAY
40851: IFFALSE 40887
// begin MC_Reset ( i , 125 ) ;
40853: LD_VAR 0 2
40857: PPUSH
40858: LD_INT 125
40860: PPUSH
40861: CALL 24190 0 2
// mc_deposits_finder := Replace ( mc_deposits_finder , i , [ ] ) ;
40865: LD_ADDR_EXP 112
40869: PUSH
40870: LD_EXP 112
40874: PPUSH
40875: LD_VAR 0 2
40879: PPUSH
40880: EMPTY
40881: PPUSH
40882: CALL_OW 1
40886: ST_TO_ADDR
// end ; continue ;
40887: GO 40741
// end ; if mc_deposits_xy [ i ] [ 1 ] [ 3 ] = 1 and GetTech ( tech_sibdet , mc_sides [ i ] ) <> state_researched then
40889: LD_EXP 111
40893: PUSH
40894: LD_VAR 0 2
40898: ARRAY
40899: PUSH
40900: LD_INT 1
40902: ARRAY
40903: PUSH
40904: LD_INT 3
40906: ARRAY
40907: PUSH
40908: LD_INT 1
40910: EQUAL
40911: PUSH
40912: LD_INT 20
40914: PPUSH
40915: LD_EXP 100
40919: PUSH
40920: LD_VAR 0 2
40924: ARRAY
40925: PPUSH
40926: CALL_OW 321
40930: PUSH
40931: LD_INT 2
40933: NONEQUAL
40934: AND
40935: IFFALSE 40985
// begin if mc_deposits_finder [ i ] then
40937: LD_EXP 112
40941: PUSH
40942: LD_VAR 0 2
40946: ARRAY
40947: IFFALSE 40983
// begin MC_Reset ( i , 125 ) ;
40949: LD_VAR 0 2
40953: PPUSH
40954: LD_INT 125
40956: PPUSH
40957: CALL 24190 0 2
// mc_deposits_finder := Replace ( mc_deposits_finder , i , [ ] ) ;
40961: LD_ADDR_EXP 112
40965: PUSH
40966: LD_EXP 112
40970: PPUSH
40971: LD_VAR 0 2
40975: PPUSH
40976: EMPTY
40977: PPUSH
40978: CALL_OW 1
40982: ST_TO_ADDR
// end ; continue ;
40983: GO 40741
// end ; if GetResourceVisibility ( mc_deposits_xy [ i ] [ 1 ] [ 1 ] , mc_deposits_xy [ i ] [ 1 ] [ 2 ] , mc_sides [ i ] ) then
40985: LD_EXP 111
40989: PUSH
40990: LD_VAR 0 2
40994: ARRAY
40995: PUSH
40996: LD_INT 1
40998: ARRAY
40999: PUSH
41000: LD_INT 1
41002: ARRAY
41003: PPUSH
41004: LD_EXP 111
41008: PUSH
41009: LD_VAR 0 2
41013: ARRAY
41014: PUSH
41015: LD_INT 1
41017: ARRAY
41018: PUSH
41019: LD_INT 2
41021: ARRAY
41022: PPUSH
41023: LD_EXP 100
41027: PUSH
41028: LD_VAR 0 2
41032: ARRAY
41033: PPUSH
41034: CALL_OW 440
41038: IFFALSE 41081
// mc_deposits_xy := Replace ( mc_deposits_xy , i , Delete ( mc_deposits_xy [ i ] , 1 ) ) else
41040: LD_ADDR_EXP 111
41044: PUSH
41045: LD_EXP 111
41049: PPUSH
41050: LD_VAR 0 2
41054: PPUSH
41055: LD_EXP 111
41059: PUSH
41060: LD_VAR 0 2
41064: ARRAY
41065: PPUSH
41066: LD_INT 1
41068: PPUSH
41069: CALL_OW 3
41073: PPUSH
41074: CALL_OW 1
41078: ST_TO_ADDR
41079: GO 41328
// begin if not mc_deposits_finder [ i ] then
41081: LD_EXP 112
41085: PUSH
41086: LD_VAR 0 2
41090: ARRAY
41091: NOT
41092: IFFALSE 41144
// begin mc_deposits_finder := Replace ( mc_deposits_finder , i , [ tmp [ 1 ] ] ) ;
41094: LD_ADDR_EXP 112
41098: PUSH
41099: LD_EXP 112
41103: PPUSH
41104: LD_VAR 0 2
41108: PPUSH
41109: LD_VAR 0 3
41113: PUSH
41114: LD_INT 1
41116: ARRAY
41117: PUSH
41118: EMPTY
41119: LIST
41120: PPUSH
41121: CALL_OW 1
41125: ST_TO_ADDR
// SetTag ( tmp [ 1 ] , 125 ) ;
41126: LD_VAR 0 3
41130: PUSH
41131: LD_INT 1
41133: ARRAY
41134: PPUSH
41135: LD_INT 125
41137: PPUSH
41138: CALL_OW 109
// end else
41142: GO 41328
// begin if IsInUnit ( mc_deposits_finder [ i ] [ 1 ] ) then
41144: LD_EXP 112
41148: PUSH
41149: LD_VAR 0 2
41153: ARRAY
41154: PUSH
41155: LD_INT 1
41157: ARRAY
41158: PPUSH
41159: CALL_OW 310
41163: IFFALSE 41186
// ComExitBuilding ( mc_deposits_finder [ i ] [ 1 ] ) else
41165: LD_EXP 112
41169: PUSH
41170: LD_VAR 0 2
41174: ARRAY
41175: PUSH
41176: LD_INT 1
41178: ARRAY
41179: PPUSH
41180: CALL_OW 122
41184: GO 41328
// if not HasTask ( mc_deposits_finder [ i ] [ 1 ] ) and GetDistUnitXY ( mc_deposits_finder [ i ] [ 1 ] , mc_deposits_xy [ i ] [ 1 ] [ 1 ] , mc_deposits_xy [ i ] [ 1 ] [ 2 ] ) > 6 then
41186: LD_EXP 112
41190: PUSH
41191: LD_VAR 0 2
41195: ARRAY
41196: PUSH
41197: LD_INT 1
41199: ARRAY
41200: PPUSH
41201: CALL_OW 314
41205: NOT
41206: PUSH
41207: LD_EXP 112
41211: PUSH
41212: LD_VAR 0 2
41216: ARRAY
41217: PUSH
41218: LD_INT 1
41220: ARRAY
41221: PPUSH
41222: LD_EXP 111
41226: PUSH
41227: LD_VAR 0 2
41231: ARRAY
41232: PUSH
41233: LD_INT 1
41235: ARRAY
41236: PUSH
41237: LD_INT 1
41239: ARRAY
41240: PPUSH
41241: LD_EXP 111
41245: PUSH
41246: LD_VAR 0 2
41250: ARRAY
41251: PUSH
41252: LD_INT 1
41254: ARRAY
41255: PUSH
41256: LD_INT 2
41258: ARRAY
41259: PPUSH
41260: CALL_OW 297
41264: PUSH
41265: LD_INT 6
41267: GREATER
41268: AND
41269: IFFALSE 41328
// ComMoveXY ( mc_deposits_finder [ i ] [ 1 ] , mc_deposits_xy [ i ] [ 1 ] [ 1 ] , mc_deposits_xy [ i ] [ 1 ] [ 2 ] ) ;
41271: LD_EXP 112
41275: PUSH
41276: LD_VAR 0 2
41280: ARRAY
41281: PUSH
41282: LD_INT 1
41284: ARRAY
41285: PPUSH
41286: LD_EXP 111
41290: PUSH
41291: LD_VAR 0 2
41295: ARRAY
41296: PUSH
41297: LD_INT 1
41299: ARRAY
41300: PUSH
41301: LD_INT 1
41303: ARRAY
41304: PPUSH
41305: LD_EXP 111
41309: PUSH
41310: LD_VAR 0 2
41314: ARRAY
41315: PUSH
41316: LD_INT 1
41318: ARRAY
41319: PUSH
41320: LD_INT 2
41322: ARRAY
41323: PPUSH
41324: CALL_OW 111
// end ; end ; end ;
41328: GO 40741
41330: POP
41331: POP
// end ;
41332: LD_VAR 0 1
41336: RET
// export function MC_RemoteDriver ( ) ; var i , j , k , places , tmp , nation , ct , cts , mcts , x ; begin
41337: LD_INT 0
41339: PPUSH
41340: PPUSH
41341: PPUSH
41342: PPUSH
41343: PPUSH
41344: PPUSH
41345: PPUSH
41346: PPUSH
41347: PPUSH
41348: PPUSH
41349: PPUSH
// if not mc_bases then
41350: LD_EXP 74
41354: NOT
41355: IFFALSE 41359
// exit ;
41357: GO 42299
// for i = 1 to mc_bases do
41359: LD_ADDR_VAR 0 2
41363: PUSH
41364: DOUBLE
41365: LD_INT 1
41367: DEC
41368: ST_TO_ADDR
41369: LD_EXP 74
41373: PUSH
41374: FOR_TO
41375: IFFALSE 42297
// begin if not mc_bases [ i ] or mc_scan [ i ] then
41377: LD_EXP 74
41381: PUSH
41382: LD_VAR 0 2
41386: ARRAY
41387: NOT
41388: PUSH
41389: LD_EXP 97
41393: PUSH
41394: LD_VAR 0 2
41398: ARRAY
41399: OR
41400: IFFALSE 41404
// continue ;
41402: GO 41374
// nation := GetNation ( mc_bases [ i ] [ 1 ] ) ;
41404: LD_ADDR_VAR 0 7
41408: PUSH
41409: LD_EXP 74
41413: PUSH
41414: LD_VAR 0 2
41418: ARRAY
41419: PUSH
41420: LD_INT 1
41422: ARRAY
41423: PPUSH
41424: CALL_OW 248
41428: ST_TO_ADDR
// if nation = 3 or not UnitFilter ( mc_vehicles [ i ] union mc_defender [ i ] , [ f_control , control_remote ] ) then
41429: LD_VAR 0 7
41433: PUSH
41434: LD_INT 3
41436: EQUAL
41437: PUSH
41438: LD_EXP 93
41442: PUSH
41443: LD_VAR 0 2
41447: ARRAY
41448: PUSH
41449: LD_EXP 96
41453: PUSH
41454: LD_VAR 0 2
41458: ARRAY
41459: UNION
41460: PPUSH
41461: LD_INT 33
41463: PUSH
41464: LD_INT 2
41466: PUSH
41467: EMPTY
41468: LIST
41469: LIST
41470: PPUSH
41471: CALL_OW 72
41475: NOT
41476: OR
41477: IFFALSE 41481
// continue ;
41479: GO 41374
// cts := UnitFilter ( mc_bases [ i ] , [ f_btype , b_control_tower ] ) ;
41481: LD_ADDR_VAR 0 9
41485: PUSH
41486: LD_EXP 74
41490: PUSH
41491: LD_VAR 0 2
41495: ARRAY
41496: PPUSH
41497: LD_INT 30
41499: PUSH
41500: LD_INT 36
41502: PUSH
41503: EMPTY
41504: LIST
41505: LIST
41506: PPUSH
41507: CALL_OW 72
41511: ST_TO_ADDR
// mcts := UnitFilter ( mc_vehicles [ i ] , [ f_weapon , ar_control_tower ] ) ;
41512: LD_ADDR_VAR 0 10
41516: PUSH
41517: LD_EXP 93
41521: PUSH
41522: LD_VAR 0 2
41526: ARRAY
41527: PPUSH
41528: LD_INT 34
41530: PUSH
41531: LD_INT 31
41533: PUSH
41534: EMPTY
41535: LIST
41536: LIST
41537: PPUSH
41538: CALL_OW 72
41542: ST_TO_ADDR
// if not cts and not mcts then
41543: LD_VAR 0 9
41547: NOT
41548: PUSH
41549: LD_VAR 0 10
41553: NOT
41554: AND
41555: IFFALSE 41559
// continue ;
41557: GO 41374
// x := cts ;
41559: LD_ADDR_VAR 0 11
41563: PUSH
41564: LD_VAR 0 9
41568: ST_TO_ADDR
// if not x then
41569: LD_VAR 0 11
41573: NOT
41574: IFFALSE 41586
// x := mcts ;
41576: LD_ADDR_VAR 0 11
41580: PUSH
41581: LD_VAR 0 10
41585: ST_TO_ADDR
// if not x then
41586: LD_VAR 0 11
41590: NOT
41591: IFFALSE 41595
// continue ;
41593: GO 41374
// if mc_remote_driver [ i ] then
41595: LD_EXP 114
41599: PUSH
41600: LD_VAR 0 2
41604: ARRAY
41605: IFFALSE 41992
// for j in mc_remote_driver [ i ] do
41607: LD_ADDR_VAR 0 3
41611: PUSH
41612: LD_EXP 114
41616: PUSH
41617: LD_VAR 0 2
41621: ARRAY
41622: PUSH
41623: FOR_IN
41624: IFFALSE 41990
// begin if GetClass ( j ) <> 3 then
41626: LD_VAR 0 3
41630: PPUSH
41631: CALL_OW 257
41635: PUSH
41636: LD_INT 3
41638: NONEQUAL
41639: IFFALSE 41692
// begin mc_remote_driver := Replace ( mc_remote_driver , i , mc_remote_driver [ i ] diff j ) ;
41641: LD_ADDR_EXP 114
41645: PUSH
41646: LD_EXP 114
41650: PPUSH
41651: LD_VAR 0 2
41655: PPUSH
41656: LD_EXP 114
41660: PUSH
41661: LD_VAR 0 2
41665: ARRAY
41666: PUSH
41667: LD_VAR 0 3
41671: DIFF
41672: PPUSH
41673: CALL_OW 1
41677: ST_TO_ADDR
// SetTag ( j , 0 ) ;
41678: LD_VAR 0 3
41682: PPUSH
41683: LD_INT 0
41685: PPUSH
41686: CALL_OW 109
// continue ;
41690: GO 41623
// end ; if UnitFilter ( mc_vehicles [ i ] , [ [ f_weapon , ar_control_tower ] , [ f_empty ] ] ) and not IsDriver ( j ) then
41692: LD_EXP 93
41696: PUSH
41697: LD_VAR 0 2
41701: ARRAY
41702: PPUSH
41703: LD_INT 34
41705: PUSH
41706: LD_INT 31
41708: PUSH
41709: EMPTY
41710: LIST
41711: LIST
41712: PUSH
41713: LD_INT 58
41715: PUSH
41716: EMPTY
41717: LIST
41718: PUSH
41719: EMPTY
41720: LIST
41721: LIST
41722: PPUSH
41723: CALL_OW 72
41727: PUSH
41728: LD_VAR 0 3
41732: PPUSH
41733: CALL 90751 0 1
41737: NOT
41738: AND
41739: IFFALSE 41810
// begin if IsInUnit ( j ) then
41741: LD_VAR 0 3
41745: PPUSH
41746: CALL_OW 310
41750: IFFALSE 41761
// ComExitBuilding ( j ) ;
41752: LD_VAR 0 3
41756: PPUSH
41757: CALL_OW 122
// AddComEnterUnit ( j , UnitFilter ( mc_vehicles [ i ] , [ [ f_weapon , ar_control_tower ] , [ f_empty ] ] ) [ 1 ] ) ;
41761: LD_VAR 0 3
41765: PPUSH
41766: LD_EXP 93
41770: PUSH
41771: LD_VAR 0 2
41775: ARRAY
41776: PPUSH
41777: LD_INT 34
41779: PUSH
41780: LD_INT 31
41782: PUSH
41783: EMPTY
41784: LIST
41785: LIST
41786: PUSH
41787: LD_INT 58
41789: PUSH
41790: EMPTY
41791: LIST
41792: PUSH
41793: EMPTY
41794: LIST
41795: LIST
41796: PPUSH
41797: CALL_OW 72
41801: PUSH
41802: LD_INT 1
41804: ARRAY
41805: PPUSH
41806: CALL_OW 180
// end ; if not IsInUnit ( j ) or ( GetBType ( IsInUnit ( j ) ) <> b_control_tower and not IsDriver ( j ) ) then
41810: LD_VAR 0 3
41814: PPUSH
41815: CALL_OW 310
41819: NOT
41820: PUSH
41821: LD_VAR 0 3
41825: PPUSH
41826: CALL_OW 310
41830: PPUSH
41831: CALL_OW 266
41835: PUSH
41836: LD_INT 36
41838: NONEQUAL
41839: PUSH
41840: LD_VAR 0 3
41844: PPUSH
41845: CALL 90751 0 1
41849: NOT
41850: AND
41851: OR
41852: IFFALSE 41988
// begin if IsInUnit ( j ) then
41854: LD_VAR 0 3
41858: PPUSH
41859: CALL_OW 310
41863: IFFALSE 41874
// ComExitBuilding ( j ) ;
41865: LD_VAR 0 3
41869: PPUSH
41870: CALL_OW 122
// ct := 0 ;
41874: LD_ADDR_VAR 0 8
41878: PUSH
41879: LD_INT 0
41881: ST_TO_ADDR
// for k in x do
41882: LD_ADDR_VAR 0 4
41886: PUSH
41887: LD_VAR 0 11
41891: PUSH
41892: FOR_IN
41893: IFFALSE 41966
// if ( GetWeapon ( k ) = ar_control_tower and not IsDrivenBy ( k ) ) or ( GetBType ( k ) = b_control_tower and UnitsInside ( k ) < 3 ) then
41895: LD_VAR 0 4
41899: PPUSH
41900: CALL_OW 264
41904: PUSH
41905: LD_INT 31
41907: EQUAL
41908: PUSH
41909: LD_VAR 0 4
41913: PPUSH
41914: CALL_OW 311
41918: NOT
41919: AND
41920: PUSH
41921: LD_VAR 0 4
41925: PPUSH
41926: CALL_OW 266
41930: PUSH
41931: LD_INT 36
41933: EQUAL
41934: PUSH
41935: LD_VAR 0 4
41939: PPUSH
41940: CALL_OW 313
41944: PUSH
41945: LD_INT 3
41947: LESS
41948: AND
41949: OR
41950: IFFALSE 41964
// begin ct := k ;
41952: LD_ADDR_VAR 0 8
41956: PUSH
41957: LD_VAR 0 4
41961: ST_TO_ADDR
// break ;
41962: GO 41966
// end ;
41964: GO 41892
41966: POP
41967: POP
// if ct then
41968: LD_VAR 0 8
41972: IFFALSE 41988
// ComEnterUnit ( j , ct ) ;
41974: LD_VAR 0 3
41978: PPUSH
41979: LD_VAR 0 8
41983: PPUSH
41984: CALL_OW 120
// end ; end ;
41988: GO 41623
41990: POP
41991: POP
// places := 0 ;
41992: LD_ADDR_VAR 0 5
41996: PUSH
41997: LD_INT 0
41999: ST_TO_ADDR
// for j = 1 to x do
42000: LD_ADDR_VAR 0 3
42004: PUSH
42005: DOUBLE
42006: LD_INT 1
42008: DEC
42009: ST_TO_ADDR
42010: LD_VAR 0 11
42014: PUSH
42015: FOR_TO
42016: IFFALSE 42092
// if GetWeapon ( x [ j ] ) = ar_control_tower then
42018: LD_VAR 0 11
42022: PUSH
42023: LD_VAR 0 3
42027: ARRAY
42028: PPUSH
42029: CALL_OW 264
42033: PUSH
42034: LD_INT 31
42036: EQUAL
42037: IFFALSE 42055
// places := places + 1 else
42039: LD_ADDR_VAR 0 5
42043: PUSH
42044: LD_VAR 0 5
42048: PUSH
42049: LD_INT 1
42051: PLUS
42052: ST_TO_ADDR
42053: GO 42090
// if GetBType ( x [ j ] ) = b_control_tower then
42055: LD_VAR 0 11
42059: PUSH
42060: LD_VAR 0 3
42064: ARRAY
42065: PPUSH
42066: CALL_OW 266
42070: PUSH
42071: LD_INT 36
42073: EQUAL
42074: IFFALSE 42090
// places := places + 3 ;
42076: LD_ADDR_VAR 0 5
42080: PUSH
42081: LD_VAR 0 5
42085: PUSH
42086: LD_INT 3
42088: PLUS
42089: ST_TO_ADDR
42090: GO 42015
42092: POP
42093: POP
// if places = 0 or places <= mc_remote_driver [ i ] then
42094: LD_VAR 0 5
42098: PUSH
42099: LD_INT 0
42101: EQUAL
42102: PUSH
42103: LD_VAR 0 5
42107: PUSH
42108: LD_EXP 114
42112: PUSH
42113: LD_VAR 0 2
42117: ARRAY
42118: LESSEQUAL
42119: OR
42120: IFFALSE 42124
// continue ;
42122: GO 41374
// tmp := SortBySkill ( UnitFilter ( mc_bases [ i ] , [ f_class , 3 ] ) diff mc_remote_driver [ i ] , 3 ) ;
42124: LD_ADDR_VAR 0 6
42128: PUSH
42129: LD_EXP 74
42133: PUSH
42134: LD_VAR 0 2
42138: ARRAY
42139: PPUSH
42140: LD_INT 25
42142: PUSH
42143: LD_INT 3
42145: PUSH
42146: EMPTY
42147: LIST
42148: LIST
42149: PPUSH
42150: CALL_OW 72
42154: PUSH
42155: LD_EXP 114
42159: PUSH
42160: LD_VAR 0 2
42164: ARRAY
42165: DIFF
42166: PPUSH
42167: LD_INT 3
42169: PPUSH
42170: CALL 91651 0 2
42174: ST_TO_ADDR
// for j in tmp do
42175: LD_ADDR_VAR 0 3
42179: PUSH
42180: LD_VAR 0 6
42184: PUSH
42185: FOR_IN
42186: IFFALSE 42221
// if GetTag ( j ) > 0 then
42188: LD_VAR 0 3
42192: PPUSH
42193: CALL_OW 110
42197: PUSH
42198: LD_INT 0
42200: GREATER
42201: IFFALSE 42219
// tmp := tmp diff j ;
42203: LD_ADDR_VAR 0 6
42207: PUSH
42208: LD_VAR 0 6
42212: PUSH
42213: LD_VAR 0 3
42217: DIFF
42218: ST_TO_ADDR
42219: GO 42185
42221: POP
42222: POP
// if not tmp then
42223: LD_VAR 0 6
42227: NOT
42228: IFFALSE 42232
// continue ;
42230: GO 41374
// if places then
42232: LD_VAR 0 5
42236: IFFALSE 42295
// begin mc_remote_driver := Replace ( mc_remote_driver , i , mc_remote_driver [ i ] union tmp [ 1 ] ) ;
42238: LD_ADDR_EXP 114
42242: PUSH
42243: LD_EXP 114
42247: PPUSH
42248: LD_VAR 0 2
42252: PPUSH
42253: LD_EXP 114
42257: PUSH
42258: LD_VAR 0 2
42262: ARRAY
42263: PUSH
42264: LD_VAR 0 6
42268: PUSH
42269: LD_INT 1
42271: ARRAY
42272: UNION
42273: PPUSH
42274: CALL_OW 1
42278: ST_TO_ADDR
// SetTag ( tmp [ 1 ] , 126 ) ;
42279: LD_VAR 0 6
42283: PUSH
42284: LD_INT 1
42286: ARRAY
42287: PPUSH
42288: LD_INT 126
42290: PPUSH
42291: CALL_OW 109
// end ; end ;
42295: GO 41374
42297: POP
42298: POP
// end ;
42299: LD_VAR 0 1
42303: RET
// export function MC_Back ( base , base_unit_list , unit , class ) ; var i , j , tmp , x , depot ; begin
42304: LD_INT 0
42306: PPUSH
42307: PPUSH
42308: PPUSH
42309: PPUSH
42310: PPUSH
42311: PPUSH
// if not base or not base_unit_list or not unit or not class in [ 1 , 2 , 3 , 4 , 5 , 8 , 9 , 15 , 16 ] then
42312: LD_VAR 0 1
42316: NOT
42317: PUSH
42318: LD_VAR 0 2
42322: NOT
42323: OR
42324: PUSH
42325: LD_VAR 0 3
42329: NOT
42330: OR
42331: PUSH
42332: LD_VAR 0 4
42336: PUSH
42337: LD_INT 1
42339: PUSH
42340: LD_INT 2
42342: PUSH
42343: LD_INT 3
42345: PUSH
42346: LD_INT 4
42348: PUSH
42349: LD_INT 5
42351: PUSH
42352: LD_INT 8
42354: PUSH
42355: LD_INT 9
42357: PUSH
42358: LD_INT 15
42360: PUSH
42361: LD_INT 16
42363: PUSH
42364: EMPTY
42365: LIST
42366: LIST
42367: LIST
42368: LIST
42369: LIST
42370: LIST
42371: LIST
42372: LIST
42373: LIST
42374: IN
42375: NOT
42376: OR
42377: IFFALSE 42381
// exit ;
42379: GO 43281
// base_unit_list := UnitFilter ( base_unit_list , [ [ f_type , unit_building ] , [ f_lives , 250 ] ] ) ;
42381: LD_ADDR_VAR 0 2
42385: PUSH
42386: LD_VAR 0 2
42390: PPUSH
42391: LD_INT 21
42393: PUSH
42394: LD_INT 3
42396: PUSH
42397: EMPTY
42398: LIST
42399: LIST
42400: PUSH
42401: LD_INT 24
42403: PUSH
42404: LD_INT 250
42406: PUSH
42407: EMPTY
42408: LIST
42409: LIST
42410: PUSH
42411: EMPTY
42412: LIST
42413: LIST
42414: PPUSH
42415: CALL_OW 72
42419: ST_TO_ADDR
// case class of 1 , 15 :
42420: LD_VAR 0 4
42424: PUSH
42425: LD_INT 1
42427: DOUBLE
42428: EQUAL
42429: IFTRUE 42439
42431: LD_INT 15
42433: DOUBLE
42434: EQUAL
42435: IFTRUE 42439
42437: GO 42524
42439: POP
// tmp := UnitFilter ( base_unit_list , [ f_or , [ f_btype , b_bunker ] , [ f_btype , b_breastwork ] ] ) ^ UnitFilter ( base_unit_list , [ f_or , [ f_btype , b_armoury ] , [ f_btype , b_barracks ] ] ) ; 2 , 16 :
42440: LD_ADDR_VAR 0 8
42444: PUSH
42445: LD_VAR 0 2
42449: PPUSH
42450: LD_INT 2
42452: PUSH
42453: LD_INT 30
42455: PUSH
42456: LD_INT 32
42458: PUSH
42459: EMPTY
42460: LIST
42461: LIST
42462: PUSH
42463: LD_INT 30
42465: PUSH
42466: LD_INT 31
42468: PUSH
42469: EMPTY
42470: LIST
42471: LIST
42472: PUSH
42473: EMPTY
42474: LIST
42475: LIST
42476: LIST
42477: PPUSH
42478: CALL_OW 72
42482: PUSH
42483: LD_VAR 0 2
42487: PPUSH
42488: LD_INT 2
42490: PUSH
42491: LD_INT 30
42493: PUSH
42494: LD_INT 4
42496: PUSH
42497: EMPTY
42498: LIST
42499: LIST
42500: PUSH
42501: LD_INT 30
42503: PUSH
42504: LD_INT 5
42506: PUSH
42507: EMPTY
42508: LIST
42509: LIST
42510: PUSH
42511: EMPTY
42512: LIST
42513: LIST
42514: LIST
42515: PPUSH
42516: CALL_OW 72
42520: ADD
42521: ST_TO_ADDR
42522: GO 42770
42524: LD_INT 2
42526: DOUBLE
42527: EQUAL
42528: IFTRUE 42538
42530: LD_INT 16
42532: DOUBLE
42533: EQUAL
42534: IFTRUE 42538
42536: GO 42584
42538: POP
// tmp := UnitFilter ( base_unit_list , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) ; 3 :
42539: LD_ADDR_VAR 0 8
42543: PUSH
42544: LD_VAR 0 2
42548: PPUSH
42549: LD_INT 2
42551: PUSH
42552: LD_INT 30
42554: PUSH
42555: LD_INT 0
42557: PUSH
42558: EMPTY
42559: LIST
42560: LIST
42561: PUSH
42562: LD_INT 30
42564: PUSH
42565: LD_INT 1
42567: PUSH
42568: EMPTY
42569: LIST
42570: LIST
42571: PUSH
42572: EMPTY
42573: LIST
42574: LIST
42575: LIST
42576: PPUSH
42577: CALL_OW 72
42581: ST_TO_ADDR
42582: GO 42770
42584: LD_INT 3
42586: DOUBLE
42587: EQUAL
42588: IFTRUE 42592
42590: GO 42638
42592: POP
// tmp := UnitFilter ( base_unit_list , [ f_or , [ f_btype , b_workshop ] , [ f_btype , b_factory ] ] ) ; 4 :
42593: LD_ADDR_VAR 0 8
42597: PUSH
42598: LD_VAR 0 2
42602: PPUSH
42603: LD_INT 2
42605: PUSH
42606: LD_INT 30
42608: PUSH
42609: LD_INT 2
42611: PUSH
42612: EMPTY
42613: LIST
42614: LIST
42615: PUSH
42616: LD_INT 30
42618: PUSH
42619: LD_INT 3
42621: PUSH
42622: EMPTY
42623: LIST
42624: LIST
42625: PUSH
42626: EMPTY
42627: LIST
42628: LIST
42629: LIST
42630: PPUSH
42631: CALL_OW 72
42635: ST_TO_ADDR
42636: GO 42770
42638: LD_INT 4
42640: DOUBLE
42641: EQUAL
42642: IFTRUE 42646
42644: GO 42703
42646: POP
// tmp := UnitFilter ( base_unit_list , [ f_or , [ f_btype , b_lab ] , [ f_btype , b_lab_half ] , [ f_btype , b_lab_full ] ] ) ; 5 , 8 , 9 :
42647: LD_ADDR_VAR 0 8
42651: PUSH
42652: LD_VAR 0 2
42656: PPUSH
42657: LD_INT 2
42659: PUSH
42660: LD_INT 30
42662: PUSH
42663: LD_INT 6
42665: PUSH
42666: EMPTY
42667: LIST
42668: LIST
42669: PUSH
42670: LD_INT 30
42672: PUSH
42673: LD_INT 7
42675: PUSH
42676: EMPTY
42677: LIST
42678: LIST
42679: PUSH
42680: LD_INT 30
42682: PUSH
42683: LD_INT 8
42685: PUSH
42686: EMPTY
42687: LIST
42688: LIST
42689: PUSH
42690: EMPTY
42691: LIST
42692: LIST
42693: LIST
42694: LIST
42695: PPUSH
42696: CALL_OW 72
42700: ST_TO_ADDR
42701: GO 42770
42703: LD_INT 5
42705: DOUBLE
42706: EQUAL
42707: IFTRUE 42723
42709: LD_INT 8
42711: DOUBLE
42712: EQUAL
42713: IFTRUE 42723
42715: LD_INT 9
42717: DOUBLE
42718: EQUAL
42719: IFTRUE 42723
42721: GO 42769
42723: POP
// tmp := UnitFilter ( base_unit_list , [ f_or , [ f_btype , b_armoury ] , [ f_btype , b_barracks ] ] ) ; end ;
42724: LD_ADDR_VAR 0 8
42728: PUSH
42729: LD_VAR 0 2
42733: PPUSH
42734: LD_INT 2
42736: PUSH
42737: LD_INT 30
42739: PUSH
42740: LD_INT 4
42742: PUSH
42743: EMPTY
42744: LIST
42745: LIST
42746: PUSH
42747: LD_INT 30
42749: PUSH
42750: LD_INT 5
42752: PUSH
42753: EMPTY
42754: LIST
42755: LIST
42756: PUSH
42757: EMPTY
42758: LIST
42759: LIST
42760: LIST
42761: PPUSH
42762: CALL_OW 72
42766: ST_TO_ADDR
42767: GO 42770
42769: POP
// if not tmp then
42770: LD_VAR 0 8
42774: NOT
42775: IFFALSE 42779
// exit ;
42777: GO 43281
// if class in [ 1 , 15 ] and mc_empty_turret_list [ base ] then
42779: LD_VAR 0 4
42783: PUSH
42784: LD_INT 1
42786: PUSH
42787: LD_INT 15
42789: PUSH
42790: EMPTY
42791: LIST
42792: LIST
42793: IN
42794: PUSH
42795: LD_EXP 83
42799: PUSH
42800: LD_VAR 0 1
42804: ARRAY
42805: AND
42806: IFFALSE 42962
// begin x := mc_empty_turret_list [ base ] [ 1 ] ;
42808: LD_ADDR_VAR 0 9
42812: PUSH
42813: LD_EXP 83
42817: PUSH
42818: LD_VAR 0 1
42822: ARRAY
42823: PUSH
42824: LD_INT 1
42826: ARRAY
42827: ST_TO_ADDR
// if not x in mc_busy_turret_list [ base ] then
42828: LD_VAR 0 9
42832: PUSH
42833: LD_EXP 84
42837: PUSH
42838: LD_VAR 0 1
42842: ARRAY
42843: IN
42844: NOT
42845: IFFALSE 42960
// begin mc_busy_turret_list := ReplaceIn ( mc_busy_turret_list , [ base , mc_busy_turret_list [ base ] + 1 ] , x ) ;
42847: LD_ADDR_EXP 84
42851: PUSH
42852: LD_EXP 84
42856: PPUSH
42857: LD_VAR 0 1
42861: PUSH
42862: LD_EXP 84
42866: PUSH
42867: LD_VAR 0 1
42871: ARRAY
42872: PUSH
42873: LD_INT 1
42875: PLUS
42876: PUSH
42877: EMPTY
42878: LIST
42879: LIST
42880: PPUSH
42881: LD_VAR 0 9
42885: PPUSH
42886: CALL 57403 0 3
42890: ST_TO_ADDR
// mc_empty_turret_list := Replace ( mc_empty_turret_list , base , mc_empty_turret_list [ base ] diff x ) ;
42891: LD_ADDR_EXP 83
42895: PUSH
42896: LD_EXP 83
42900: PPUSH
42901: LD_VAR 0 1
42905: PPUSH
42906: LD_EXP 83
42910: PUSH
42911: LD_VAR 0 1
42915: ARRAY
42916: PUSH
42917: LD_VAR 0 9
42921: DIFF
42922: PPUSH
42923: CALL_OW 1
42927: ST_TO_ADDR
// ComEnterUnit ( unit , mc_busy_turret_list [ base ] [ mc_busy_turret_list [ base ] ] ) ;
42928: LD_VAR 0 3
42932: PPUSH
42933: LD_EXP 84
42937: PUSH
42938: LD_VAR 0 1
42942: ARRAY
42943: PUSH
42944: LD_EXP 84
42948: PUSH
42949: LD_VAR 0 1
42953: ARRAY
42954: ARRAY
42955: PPUSH
42956: CALL_OW 120
// end ; exit ;
42960: GO 43281
// end ; if tmp > 1 then
42962: LD_VAR 0 8
42966: PUSH
42967: LD_INT 1
42969: GREATER
42970: IFFALSE 43074
// for i = 2 to tmp do
42972: LD_ADDR_VAR 0 6
42976: PUSH
42977: DOUBLE
42978: LD_INT 2
42980: DEC
42981: ST_TO_ADDR
42982: LD_VAR 0 8
42986: PUSH
42987: FOR_TO
42988: IFFALSE 43072
// if BuildingStatus ( tmp [ i ] ) = bs_need_people then
42990: LD_VAR 0 8
42994: PUSH
42995: LD_VAR 0 6
42999: ARRAY
43000: PPUSH
43001: CALL_OW 461
43005: PUSH
43006: LD_INT 6
43008: EQUAL
43009: IFFALSE 43070
// begin x := tmp [ i ] ;
43011: LD_ADDR_VAR 0 9
43015: PUSH
43016: LD_VAR 0 8
43020: PUSH
43021: LD_VAR 0 6
43025: ARRAY
43026: ST_TO_ADDR
// tmp := Delete ( tmp , i ) ;
43027: LD_ADDR_VAR 0 8
43031: PUSH
43032: LD_VAR 0 8
43036: PPUSH
43037: LD_VAR 0 6
43041: PPUSH
43042: CALL_OW 3
43046: ST_TO_ADDR
// tmp := Insert ( tmp , 1 , x ) ;
43047: LD_ADDR_VAR 0 8
43051: PUSH
43052: LD_VAR 0 8
43056: PPUSH
43057: LD_INT 1
43059: PPUSH
43060: LD_VAR 0 9
43064: PPUSH
43065: CALL_OW 2
43069: ST_TO_ADDR
// end ;
43070: GO 42987
43072: POP
43073: POP
// for i in tmp do
43074: LD_ADDR_VAR 0 6
43078: PUSH
43079: LD_VAR 0 8
43083: PUSH
43084: FOR_IN
43085: IFFALSE 43154
// begin if ( UnitsInside ( i ) < 6 and not GetBType ( i ) in [ b_breastwork , b_bunker ] ) or UnitsInside ( i ) = 0 then
43087: LD_VAR 0 6
43091: PPUSH
43092: CALL_OW 313
43096: PUSH
43097: LD_INT 6
43099: LESS
43100: PUSH
43101: LD_VAR 0 6
43105: PPUSH
43106: CALL_OW 266
43110: PUSH
43111: LD_INT 31
43113: PUSH
43114: LD_INT 32
43116: PUSH
43117: EMPTY
43118: LIST
43119: LIST
43120: IN
43121: NOT
43122: AND
43123: PUSH
43124: LD_VAR 0 6
43128: PPUSH
43129: CALL_OW 313
43133: PUSH
43134: LD_INT 0
43136: EQUAL
43137: OR
43138: IFFALSE 43152
// begin j := i ;
43140: LD_ADDR_VAR 0 7
43144: PUSH
43145: LD_VAR 0 6
43149: ST_TO_ADDR
// break ;
43150: GO 43154
// end ; end ;
43152: GO 43084
43154: POP
43155: POP
// if j then
43156: LD_VAR 0 7
43160: IFFALSE 43178
// ComEnterUnit ( unit , j ) else
43162: LD_VAR 0 3
43166: PPUSH
43167: LD_VAR 0 7
43171: PPUSH
43172: CALL_OW 120
43176: GO 43281
// begin depot := UnitFilter ( base_unit_list , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) ;
43178: LD_ADDR_VAR 0 10
43182: PUSH
43183: LD_VAR 0 2
43187: PPUSH
43188: LD_INT 2
43190: PUSH
43191: LD_INT 30
43193: PUSH
43194: LD_INT 0
43196: PUSH
43197: EMPTY
43198: LIST
43199: LIST
43200: PUSH
43201: LD_INT 30
43203: PUSH
43204: LD_INT 1
43206: PUSH
43207: EMPTY
43208: LIST
43209: LIST
43210: PUSH
43211: EMPTY
43212: LIST
43213: LIST
43214: LIST
43215: PPUSH
43216: CALL_OW 72
43220: ST_TO_ADDR
// if depot then
43221: LD_VAR 0 10
43225: IFFALSE 43281
// begin depot := NearestUnitToUnit ( depot , unit ) ;
43227: LD_ADDR_VAR 0 10
43231: PUSH
43232: LD_VAR 0 10
43236: PPUSH
43237: LD_VAR 0 3
43241: PPUSH
43242: CALL_OW 74
43246: ST_TO_ADDR
// if GetDistUnits ( unit , depot ) > 10 then
43247: LD_VAR 0 3
43251: PPUSH
43252: LD_VAR 0 10
43256: PPUSH
43257: CALL_OW 296
43261: PUSH
43262: LD_INT 10
43264: GREATER
43265: IFFALSE 43281
// ComStandNearbyBuilding ( unit , depot ) ;
43267: LD_VAR 0 3
43271: PPUSH
43272: LD_VAR 0 10
43276: PPUSH
43277: CALL 51695 0 2
// end ; end ; end ;
43281: LD_VAR 0 5
43285: RET
// export function MC_Idle ( ) ; var i , j , tmp ; begin
43286: LD_INT 0
43288: PPUSH
43289: PPUSH
43290: PPUSH
43291: PPUSH
// if not mc_bases then
43292: LD_EXP 74
43296: NOT
43297: IFFALSE 43301
// exit ;
43299: GO 43540
// for i = 1 to mc_bases do
43301: LD_ADDR_VAR 0 2
43305: PUSH
43306: DOUBLE
43307: LD_INT 1
43309: DEC
43310: ST_TO_ADDR
43311: LD_EXP 74
43315: PUSH
43316: FOR_TO
43317: IFFALSE 43538
// begin tmp := UnitFilter ( mc_bases [ i ] , [ f_type , unit_human ] ) union mc_ape [ i ] ;
43319: LD_ADDR_VAR 0 4
43323: PUSH
43324: LD_EXP 74
43328: PUSH
43329: LD_VAR 0 2
43333: ARRAY
43334: PPUSH
43335: LD_INT 21
43337: PUSH
43338: LD_INT 1
43340: PUSH
43341: EMPTY
43342: LIST
43343: LIST
43344: PPUSH
43345: CALL_OW 72
43349: PUSH
43350: LD_EXP 103
43354: PUSH
43355: LD_VAR 0 2
43359: ARRAY
43360: UNION
43361: ST_TO_ADDR
// if not tmp then
43362: LD_VAR 0 4
43366: NOT
43367: IFFALSE 43371
// continue ;
43369: GO 43316
// for j in tmp do
43371: LD_ADDR_VAR 0 3
43375: PUSH
43376: LD_VAR 0 4
43380: PUSH
43381: FOR_IN
43382: IFFALSE 43534
// begin if not GetTag ( j ) and not HasTask ( j ) and not IsDrivenBy ( j ) and not IsInUnit ( j ) and not j in mc_need_heal [ i ] [ 1 ] and not j in mc_need_heal [ i ] [ 2 ] and not j in mc_repair_vehicle [ i ] then
43384: LD_VAR 0 3
43388: PPUSH
43389: CALL_OW 110
43393: NOT
43394: PUSH
43395: LD_VAR 0 3
43399: PPUSH
43400: CALL_OW 314
43404: NOT
43405: AND
43406: PUSH
43407: LD_VAR 0 3
43411: PPUSH
43412: CALL_OW 311
43416: NOT
43417: AND
43418: PUSH
43419: LD_VAR 0 3
43423: PPUSH
43424: CALL_OW 310
43428: NOT
43429: AND
43430: PUSH
43431: LD_VAR 0 3
43435: PUSH
43436: LD_EXP 77
43440: PUSH
43441: LD_VAR 0 2
43445: ARRAY
43446: PUSH
43447: LD_INT 1
43449: ARRAY
43450: IN
43451: NOT
43452: AND
43453: PUSH
43454: LD_VAR 0 3
43458: PUSH
43459: LD_EXP 77
43463: PUSH
43464: LD_VAR 0 2
43468: ARRAY
43469: PUSH
43470: LD_INT 2
43472: ARRAY
43473: IN
43474: NOT
43475: AND
43476: PUSH
43477: LD_VAR 0 3
43481: PUSH
43482: LD_EXP 86
43486: PUSH
43487: LD_VAR 0 2
43491: ARRAY
43492: IN
43493: NOT
43494: AND
43495: IFFALSE 43532
// MC_Back ( i , mc_bases [ i ] , j , GetClass ( j ) ) ;
43497: LD_VAR 0 2
43501: PPUSH
43502: LD_EXP 74
43506: PUSH
43507: LD_VAR 0 2
43511: ARRAY
43512: PPUSH
43513: LD_VAR 0 3
43517: PPUSH
43518: LD_VAR 0 3
43522: PPUSH
43523: CALL_OW 257
43527: PPUSH
43528: CALL 42304 0 4
// end ;
43532: GO 43381
43534: POP
43535: POP
// end ;
43536: GO 43316
43538: POP
43539: POP
// end ;
43540: LD_VAR 0 1
43544: RET
// export function MC_SetMinesField ( base , amount , area ) ; var i , tmp , list , x , j ; begin
43545: LD_INT 0
43547: PPUSH
43548: PPUSH
43549: PPUSH
43550: PPUSH
43551: PPUSH
43552: PPUSH
// if not mc_bases [ base ] then
43553: LD_EXP 74
43557: PUSH
43558: LD_VAR 0 1
43562: ARRAY
43563: NOT
43564: IFFALSE 43568
// exit ;
43566: GO 43750
// tmp := [ ] ;
43568: LD_ADDR_VAR 0 6
43572: PUSH
43573: EMPTY
43574: ST_TO_ADDR
// list := AreaToList ( area , 0 ) ;
43575: LD_ADDR_VAR 0 7
43579: PUSH
43580: LD_VAR 0 3
43584: PPUSH
43585: LD_INT 0
43587: PPUSH
43588: CALL_OW 517
43592: ST_TO_ADDR
// if not list then
43593: LD_VAR 0 7
43597: NOT
43598: IFFALSE 43602
// exit ;
43600: GO 43750
// for i = 1 to amount do
43602: LD_ADDR_VAR 0 5
43606: PUSH
43607: DOUBLE
43608: LD_INT 1
43610: DEC
43611: ST_TO_ADDR
43612: LD_VAR 0 2
43616: PUSH
43617: FOR_TO
43618: IFFALSE 43698
// begin x := rand ( 1 , list [ 1 ] ) ;
43620: LD_ADDR_VAR 0 8
43624: PUSH
43625: LD_INT 1
43627: PPUSH
43628: LD_VAR 0 7
43632: PUSH
43633: LD_INT 1
43635: ARRAY
43636: PPUSH
43637: CALL_OW 12
43641: ST_TO_ADDR
// tmp := Replace ( tmp , i , [ list [ 1 ] [ x ] , list [ 2 ] [ x ] ] ) ;
43642: LD_ADDR_VAR 0 6
43646: PUSH
43647: LD_VAR 0 6
43651: PPUSH
43652: LD_VAR 0 5
43656: PPUSH
43657: LD_VAR 0 7
43661: PUSH
43662: LD_INT 1
43664: ARRAY
43665: PUSH
43666: LD_VAR 0 8
43670: ARRAY
43671: PUSH
43672: LD_VAR 0 7
43676: PUSH
43677: LD_INT 2
43679: ARRAY
43680: PUSH
43681: LD_VAR 0 8
43685: ARRAY
43686: PUSH
43687: EMPTY
43688: LIST
43689: LIST
43690: PPUSH
43691: CALL_OW 1
43695: ST_TO_ADDR
// end ;
43696: GO 43617
43698: POP
43699: POP
// mc_mines := Replace ( mc_mines , base , tmp ) ;
43700: LD_ADDR_EXP 87
43704: PUSH
43705: LD_EXP 87
43709: PPUSH
43710: LD_VAR 0 1
43714: PPUSH
43715: LD_VAR 0 6
43719: PPUSH
43720: CALL_OW 1
43724: ST_TO_ADDR
// mc_minefields := Replace ( mc_minefields , base , area ) ;
43725: LD_ADDR_EXP 89
43729: PUSH
43730: LD_EXP 89
43734: PPUSH
43735: LD_VAR 0 1
43739: PPUSH
43740: LD_VAR 0 3
43744: PPUSH
43745: CALL_OW 1
43749: ST_TO_ADDR
// end ;
43750: LD_VAR 0 4
43754: RET
// export function MC_SetBuildingList ( base , construct_list ) ; begin
43755: LD_INT 0
43757: PPUSH
// if not mc_bases [ base ] then
43758: LD_EXP 74
43762: PUSH
43763: LD_VAR 0 1
43767: ARRAY
43768: NOT
43769: IFFALSE 43773
// exit ;
43771: GO 43798
// mc_build_list := Replace ( mc_build_list , base , construct_list ) ;
43773: LD_ADDR_EXP 79
43777: PUSH
43778: LD_EXP 79
43782: PPUSH
43783: LD_VAR 0 1
43787: PPUSH
43788: LD_VAR 0 2
43792: PPUSH
43793: CALL_OW 1
43797: ST_TO_ADDR
// end ;
43798: LD_VAR 0 3
43802: RET
// export function MC_InsertBuildingList ( base , list ) ; begin
43803: LD_INT 0
43805: PPUSH
// if not mc_bases [ base ] then
43806: LD_EXP 74
43810: PUSH
43811: LD_VAR 0 1
43815: ARRAY
43816: NOT
43817: IFFALSE 43821
// exit ;
43819: GO 43858
// mc_build_list := Replace ( mc_build_list , base , mc_build_list [ base ] union list ) ;
43821: LD_ADDR_EXP 79
43825: PUSH
43826: LD_EXP 79
43830: PPUSH
43831: LD_VAR 0 1
43835: PPUSH
43836: LD_EXP 79
43840: PUSH
43841: LD_VAR 0 1
43845: ARRAY
43846: PUSH
43847: LD_VAR 0 2
43851: UNION
43852: PPUSH
43853: CALL_OW 1
43857: ST_TO_ADDR
// end ;
43858: LD_VAR 0 3
43862: RET
// export function MC_SetProduceList ( base , produce_list ) ; begin
43863: LD_INT 0
43865: PPUSH
// if not mc_bases [ base ] then
43866: LD_EXP 74
43870: PUSH
43871: LD_VAR 0 1
43875: ARRAY
43876: NOT
43877: IFFALSE 43881
// exit ;
43879: GO 43906
// mc_produce := Replace ( mc_produce , base , produce_list ) ;
43881: LD_ADDR_EXP 95
43885: PUSH
43886: LD_EXP 95
43890: PPUSH
43891: LD_VAR 0 1
43895: PPUSH
43896: LD_VAR 0 2
43900: PPUSH
43901: CALL_OW 1
43905: ST_TO_ADDR
// end ;
43906: LD_VAR 0 3
43910: RET
// export function MC_InsertProduceList ( base , components ) ; begin
43911: LD_INT 0
43913: PPUSH
// if not mc_bases [ base ] then
43914: LD_EXP 74
43918: PUSH
43919: LD_VAR 0 1
43923: ARRAY
43924: NOT
43925: IFFALSE 43929
// exit ;
43927: GO 43966
// mc_produce := Replace ( mc_produce , base , mc_produce [ base ] ^ components ) ;
43929: LD_ADDR_EXP 95
43933: PUSH
43934: LD_EXP 95
43938: PPUSH
43939: LD_VAR 0 1
43943: PPUSH
43944: LD_EXP 95
43948: PUSH
43949: LD_VAR 0 1
43953: ARRAY
43954: PUSH
43955: LD_VAR 0 2
43959: ADD
43960: PPUSH
43961: CALL_OW 1
43965: ST_TO_ADDR
// end ;
43966: LD_VAR 0 3
43970: RET
// export function MC_SetDefenderList ( base , deflist ) ; begin
43971: LD_INT 0
43973: PPUSH
// if not mc_bases [ base ] then
43974: LD_EXP 74
43978: PUSH
43979: LD_VAR 0 1
43983: ARRAY
43984: NOT
43985: IFFALSE 43989
// exit ;
43987: GO 44043
// mc_defender := Replace ( mc_defender , base , deflist ) ;
43989: LD_ADDR_EXP 96
43993: PUSH
43994: LD_EXP 96
43998: PPUSH
43999: LD_VAR 0 1
44003: PPUSH
44004: LD_VAR 0 2
44008: PPUSH
44009: CALL_OW 1
44013: ST_TO_ADDR
// mc_defender_limit := Replace ( mc_defender_limit , base , deflist + 0 ) ;
44014: LD_ADDR_EXP 85
44018: PUSH
44019: LD_EXP 85
44023: PPUSH
44024: LD_VAR 0 1
44028: PPUSH
44029: LD_VAR 0 2
44033: PUSH
44034: LD_INT 0
44036: PLUS
44037: PPUSH
44038: CALL_OW 1
44042: ST_TO_ADDR
// end ;
44043: LD_VAR 0 3
44047: RET
// export function MC_SetDefenderLimit ( base , limit ) ; begin
44048: LD_INT 0
44050: PPUSH
// if not mc_bases [ base ] then
44051: LD_EXP 74
44055: PUSH
44056: LD_VAR 0 1
44060: ARRAY
44061: NOT
44062: IFFALSE 44066
// exit ;
44064: GO 44091
// mc_defender_limit := Replace ( mc_defender_limit , base , limit ) ;
44066: LD_ADDR_EXP 85
44070: PUSH
44071: LD_EXP 85
44075: PPUSH
44076: LD_VAR 0 1
44080: PPUSH
44081: LD_VAR 0 2
44085: PPUSH
44086: CALL_OW 1
44090: ST_TO_ADDR
// end ;
44091: LD_VAR 0 3
44095: RET
// export function MC_PrepareAttack ( base , group , path , flags ) ; var i , j , tmp ; begin
44096: LD_INT 0
44098: PPUSH
44099: PPUSH
44100: PPUSH
44101: PPUSH
// if not mc_bases [ base ] then
44102: LD_EXP 74
44106: PUSH
44107: LD_VAR 0 1
44111: ARRAY
44112: NOT
44113: IFFALSE 44117
// exit ;
44115: GO 44182
// mc_attack := ReplaceIn ( mc_attack , [ base , mc_attack [ base ] + 1 ] , [ base , group , path , flags ] ) ;
44117: LD_ADDR_EXP 94
44121: PUSH
44122: LD_EXP 94
44126: PPUSH
44127: LD_VAR 0 1
44131: PUSH
44132: LD_EXP 94
44136: PUSH
44137: LD_VAR 0 1
44141: ARRAY
44142: PUSH
44143: LD_INT 1
44145: PLUS
44146: PUSH
44147: EMPTY
44148: LIST
44149: LIST
44150: PPUSH
44151: LD_VAR 0 1
44155: PUSH
44156: LD_VAR 0 2
44160: PUSH
44161: LD_VAR 0 3
44165: PUSH
44166: LD_VAR 0 4
44170: PUSH
44171: EMPTY
44172: LIST
44173: LIST
44174: LIST
44175: LIST
44176: PPUSH
44177: CALL 57403 0 3
44181: ST_TO_ADDR
// end ;
44182: LD_VAR 0 5
44186: RET
// export function MC_SetDepositsXY ( base , deposits_list ) ; begin
44187: LD_INT 0
44189: PPUSH
// if not mc_bases [ base ] then
44190: LD_EXP 74
44194: PUSH
44195: LD_VAR 0 1
44199: ARRAY
44200: NOT
44201: IFFALSE 44205
// exit ;
44203: GO 44230
// mc_deposits_xy := Replace ( mc_deposits_xy , base , deposits_list ) ;
44205: LD_ADDR_EXP 111
44209: PUSH
44210: LD_EXP 111
44214: PPUSH
44215: LD_VAR 0 1
44219: PPUSH
44220: LD_VAR 0 2
44224: PPUSH
44225: CALL_OW 1
44229: ST_TO_ADDR
// end ;
44230: LD_VAR 0 3
44234: RET
// export function MC_GetMinesField ( base ) ; begin
44235: LD_INT 0
44237: PPUSH
// result := mc_mines [ base ] ;
44238: LD_ADDR_VAR 0 2
44242: PUSH
44243: LD_EXP 87
44247: PUSH
44248: LD_VAR 0 1
44252: ARRAY
44253: ST_TO_ADDR
// end ;
44254: LD_VAR 0 2
44258: RET
// export function MC_GetProduceList ( base ) ; begin
44259: LD_INT 0
44261: PPUSH
// result := mc_produce [ base ] ;
44262: LD_ADDR_VAR 0 2
44266: PUSH
44267: LD_EXP 95
44271: PUSH
44272: LD_VAR 0 1
44276: ARRAY
44277: ST_TO_ADDR
// end ;
44278: LD_VAR 0 2
44282: RET
// export function MC_GetBuilding ( base , btype ) ; var i ; begin
44283: LD_INT 0
44285: PPUSH
44286: PPUSH
// if not mc_bases then
44287: LD_EXP 74
44291: NOT
44292: IFFALSE 44296
// exit ;
44294: GO 44361
// if mc_bases [ base ] then
44296: LD_EXP 74
44300: PUSH
44301: LD_VAR 0 1
44305: ARRAY
44306: IFFALSE 44361
// begin result := UnitFilter ( mc_bases [ base ] , [ f_btype , btype ] ) ;
44308: LD_ADDR_VAR 0 3
44312: PUSH
44313: LD_EXP 74
44317: PUSH
44318: LD_VAR 0 1
44322: ARRAY
44323: PPUSH
44324: LD_INT 30
44326: PUSH
44327: LD_VAR 0 2
44331: PUSH
44332: EMPTY
44333: LIST
44334: LIST
44335: PPUSH
44336: CALL_OW 72
44340: ST_TO_ADDR
// if result then
44341: LD_VAR 0 3
44345: IFFALSE 44361
// result := result [ 1 ] ;
44347: LD_ADDR_VAR 0 3
44351: PUSH
44352: LD_VAR 0 3
44356: PUSH
44357: LD_INT 1
44359: ARRAY
44360: ST_TO_ADDR
// end ; end ;
44361: LD_VAR 0 3
44365: RET
// export function MC_GetBuildings ( base , btype ) ; var i ; begin
44366: LD_INT 0
44368: PPUSH
44369: PPUSH
// if not mc_bases then
44370: LD_EXP 74
44374: NOT
44375: IFFALSE 44379
// exit ;
44377: GO 44424
// if mc_bases [ base ] then
44379: LD_EXP 74
44383: PUSH
44384: LD_VAR 0 1
44388: ARRAY
44389: IFFALSE 44424
// result := UnitFilter ( mc_bases [ base ] , [ f_btype , btype ] ) ;
44391: LD_ADDR_VAR 0 3
44395: PUSH
44396: LD_EXP 74
44400: PUSH
44401: LD_VAR 0 1
44405: ARRAY
44406: PPUSH
44407: LD_INT 30
44409: PUSH
44410: LD_VAR 0 2
44414: PUSH
44415: EMPTY
44416: LIST
44417: LIST
44418: PPUSH
44419: CALL_OW 72
44423: ST_TO_ADDR
// end ;
44424: LD_VAR 0 3
44428: RET
// export function MC_SetTame ( base , area ) ; begin
44429: LD_INT 0
44431: PPUSH
// if not mc_bases or not base then
44432: LD_EXP 74
44436: NOT
44437: PUSH
44438: LD_VAR 0 1
44442: NOT
44443: OR
44444: IFFALSE 44448
// exit ;
44446: GO 44473
// mc_can_tame := Replace ( mc_can_tame , base , area ) ;
44448: LD_ADDR_EXP 102
44452: PUSH
44453: LD_EXP 102
44457: PPUSH
44458: LD_VAR 0 1
44462: PPUSH
44463: LD_VAR 0 2
44467: PPUSH
44468: CALL_OW 1
44472: ST_TO_ADDR
// end ;
44473: LD_VAR 0 3
44477: RET
// export function MC_SetUpgradeBuilding ( base , btype ) ; var tmp ; begin
44478: LD_INT 0
44480: PPUSH
44481: PPUSH
// if not mc_bases or not base then
44482: LD_EXP 74
44486: NOT
44487: PUSH
44488: LD_VAR 0 1
44492: NOT
44493: OR
44494: IFFALSE 44498
// exit ;
44496: GO 44600
// tmp := UnitFilter ( mc_bases [ base ] , [ f_btype , btype ] ) ;
44498: LD_ADDR_VAR 0 4
44502: PUSH
44503: LD_EXP 74
44507: PUSH
44508: LD_VAR 0 1
44512: ARRAY
44513: PPUSH
44514: LD_INT 30
44516: PUSH
44517: LD_VAR 0 2
44521: PUSH
44522: EMPTY
44523: LIST
44524: LIST
44525: PPUSH
44526: CALL_OW 72
44530: ST_TO_ADDR
// if not tmp then
44531: LD_VAR 0 4
44535: NOT
44536: IFFALSE 44540
// exit ;
44538: GO 44600
// mc_build_upgrade := Replace ( mc_build_upgrade , base , Insert ( mc_build_upgrade [ base ] , mc_build_upgrade [ base ] + 1 , tmp [ 1 ] ) ) ;
44540: LD_ADDR_EXP 106
44544: PUSH
44545: LD_EXP 106
44549: PPUSH
44550: LD_VAR 0 1
44554: PPUSH
44555: LD_EXP 106
44559: PUSH
44560: LD_VAR 0 1
44564: ARRAY
44565: PPUSH
44566: LD_EXP 106
44570: PUSH
44571: LD_VAR 0 1
44575: ARRAY
44576: PUSH
44577: LD_INT 1
44579: PLUS
44580: PPUSH
44581: LD_VAR 0 4
44585: PUSH
44586: LD_INT 1
44588: ARRAY
44589: PPUSH
44590: CALL_OW 2
44594: PPUSH
44595: CALL_OW 1
44599: ST_TO_ADDR
// end ;
44600: LD_VAR 0 3
44604: RET
// export function MC_SetLabKind ( base , kinds ) ; var i ; begin
44605: LD_INT 0
44607: PPUSH
44608: PPUSH
// if not mc_bases or not base or not kinds then
44609: LD_EXP 74
44613: NOT
44614: PUSH
44615: LD_VAR 0 1
44619: NOT
44620: OR
44621: PUSH
44622: LD_VAR 0 2
44626: NOT
44627: OR
44628: IFFALSE 44632
// exit ;
44630: GO 44693
// for i in kinds do
44632: LD_ADDR_VAR 0 4
44636: PUSH
44637: LD_VAR 0 2
44641: PUSH
44642: FOR_IN
44643: IFFALSE 44691
// mc_lab_upgrade := ReplaceIn ( mc_lab_upgrade , [ base , mc_lab_upgrade [ base ] + 1 ] , i ) ;
44645: LD_ADDR_EXP 108
44649: PUSH
44650: LD_EXP 108
44654: PPUSH
44655: LD_VAR 0 1
44659: PUSH
44660: LD_EXP 108
44664: PUSH
44665: LD_VAR 0 1
44669: ARRAY
44670: PUSH
44671: LD_INT 1
44673: PLUS
44674: PUSH
44675: EMPTY
44676: LIST
44677: LIST
44678: PPUSH
44679: LD_VAR 0 4
44683: PPUSH
44684: CALL 57403 0 3
44688: ST_TO_ADDR
44689: GO 44642
44691: POP
44692: POP
// end ;
44693: LD_VAR 0 3
44697: RET
// export function MC_SetCratesArea ( base , areas ) ; begin
44698: LD_INT 0
44700: PPUSH
// if not mc_bases or not base or not areas then
44701: LD_EXP 74
44705: NOT
44706: PUSH
44707: LD_VAR 0 1
44711: NOT
44712: OR
44713: PUSH
44714: LD_VAR 0 2
44718: NOT
44719: OR
44720: IFFALSE 44724
// exit ;
44722: GO 44749
// mc_crates_area := Replace ( mc_crates_area , base , areas ) ;
44724: LD_ADDR_EXP 92
44728: PUSH
44729: LD_EXP 92
44733: PPUSH
44734: LD_VAR 0 1
44738: PPUSH
44739: LD_VAR 0 2
44743: PPUSH
44744: CALL_OW 1
44748: ST_TO_ADDR
// end ;
44749: LD_VAR 0 3
44753: RET
// export function MC_SetTeleportExit ( base , teleports_exit ) ; begin
44754: LD_INT 0
44756: PPUSH
// if not mc_bases or not base or not teleports_exit then
44757: LD_EXP 74
44761: NOT
44762: PUSH
44763: LD_VAR 0 1
44767: NOT
44768: OR
44769: PUSH
44770: LD_VAR 0 2
44774: NOT
44775: OR
44776: IFFALSE 44780
// exit ;
44778: GO 44805
// mc_teleport_exit := Replace ( mc_teleport_exit , base , teleports_exit ) ;
44780: LD_ADDR_EXP 109
44784: PUSH
44785: LD_EXP 109
44789: PPUSH
44790: LD_VAR 0 1
44794: PPUSH
44795: LD_VAR 0 2
44799: PPUSH
44800: CALL_OW 1
44804: ST_TO_ADDR
// end ;
44805: LD_VAR 0 3
44809: RET
// export function MC_SetFactoryExtension ( base , x , y , d , ext_list ) ; var i , tmp ; begin
44810: LD_INT 0
44812: PPUSH
44813: PPUSH
44814: PPUSH
// if not mc_bases or not base or not ext_list then
44815: LD_EXP 74
44819: NOT
44820: PUSH
44821: LD_VAR 0 1
44825: NOT
44826: OR
44827: PUSH
44828: LD_VAR 0 5
44832: NOT
44833: OR
44834: IFFALSE 44838
// exit ;
44836: GO 45011
// tmp := GetFacExtXYD ( x , y , d ) ;
44838: LD_ADDR_VAR 0 8
44842: PUSH
44843: LD_VAR 0 2
44847: PPUSH
44848: LD_VAR 0 3
44852: PPUSH
44853: LD_VAR 0 4
44857: PPUSH
44858: CALL 90781 0 3
44862: ST_TO_ADDR
// if not tmp then
44863: LD_VAR 0 8
44867: NOT
44868: IFFALSE 44872
// exit ;
44870: GO 45011
// for i in tmp do
44872: LD_ADDR_VAR 0 7
44876: PUSH
44877: LD_VAR 0 8
44881: PUSH
44882: FOR_IN
44883: IFFALSE 45009
// begin mc_build_list := Replace ( mc_build_list , base , Insert ( mc_build_list [ base ] , mc_build_list [ base ] + 1 , [ ext_list [ 1 ] , i [ 1 ] , i [ 2 ] , i [ 3 ] ] ) ) ;
44885: LD_ADDR_EXP 79
44889: PUSH
44890: LD_EXP 79
44894: PPUSH
44895: LD_VAR 0 1
44899: PPUSH
44900: LD_EXP 79
44904: PUSH
44905: LD_VAR 0 1
44909: ARRAY
44910: PPUSH
44911: LD_EXP 79
44915: PUSH
44916: LD_VAR 0 1
44920: ARRAY
44921: PUSH
44922: LD_INT 1
44924: PLUS
44925: PPUSH
44926: LD_VAR 0 5
44930: PUSH
44931: LD_INT 1
44933: ARRAY
44934: PUSH
44935: LD_VAR 0 7
44939: PUSH
44940: LD_INT 1
44942: ARRAY
44943: PUSH
44944: LD_VAR 0 7
44948: PUSH
44949: LD_INT 2
44951: ARRAY
44952: PUSH
44953: LD_VAR 0 7
44957: PUSH
44958: LD_INT 3
44960: ARRAY
44961: PUSH
44962: EMPTY
44963: LIST
44964: LIST
44965: LIST
44966: LIST
44967: PPUSH
44968: CALL_OW 2
44972: PPUSH
44973: CALL_OW 1
44977: ST_TO_ADDR
// ext_list := Delete ( ext_list , 1 ) ;
44978: LD_ADDR_VAR 0 5
44982: PUSH
44983: LD_VAR 0 5
44987: PPUSH
44988: LD_INT 1
44990: PPUSH
44991: CALL_OW 3
44995: ST_TO_ADDR
// if not ext_list then
44996: LD_VAR 0 5
45000: NOT
45001: IFFALSE 45007
// exit ;
45003: POP
45004: POP
45005: GO 45011
// end ;
45007: GO 44882
45009: POP
45010: POP
// end ;
45011: LD_VAR 0 6
45015: RET
// export function MC_SetAllowedTurretWeapons ( base , weapon_list ) ; begin
45016: LD_INT 0
45018: PPUSH
// if not mc_bases or not base or not weapon_list then
45019: LD_EXP 74
45023: NOT
45024: PUSH
45025: LD_VAR 0 1
45029: NOT
45030: OR
45031: PUSH
45032: LD_VAR 0 2
45036: NOT
45037: OR
45038: IFFALSE 45042
// exit ;
45040: GO 45067
// mc_allowed_tower_weapons := Replace ( mc_allowed_tower_weapons , base , weapon_list ) ;
45042: LD_ADDR_EXP 113
45046: PUSH
45047: LD_EXP 113
45051: PPUSH
45052: LD_VAR 0 1
45056: PPUSH
45057: LD_VAR 0 2
45061: PPUSH
45062: CALL_OW 1
45066: ST_TO_ADDR
// end ;
45067: LD_VAR 0 3
45071: RET
// export function MC_SetTechList ( base , tech_list ) ; begin
45072: LD_INT 0
45074: PPUSH
// if not mc_bases or not base or not tech_list then
45075: LD_EXP 74
45079: NOT
45080: PUSH
45081: LD_VAR 0 1
45085: NOT
45086: OR
45087: PUSH
45088: LD_VAR 0 2
45092: NOT
45093: OR
45094: IFFALSE 45098
// exit ;
45096: GO 45123
// mc_tech := Replace ( mc_tech , base , tech_list ) ;
45098: LD_ADDR_EXP 101
45102: PUSH
45103: LD_EXP 101
45107: PPUSH
45108: LD_VAR 0 1
45112: PPUSH
45113: LD_VAR 0 2
45117: PPUSH
45118: CALL_OW 1
45122: ST_TO_ADDR
// end ;
45123: LD_VAR 0 3
45127: RET
// export function MC_SetParkingArea ( base , parking_area ) ; begin
45128: LD_INT 0
45130: PPUSH
// if not mc_bases or not parking_area or not base then
45131: LD_EXP 74
45135: NOT
45136: PUSH
45137: LD_VAR 0 2
45141: NOT
45142: OR
45143: PUSH
45144: LD_VAR 0 1
45148: NOT
45149: OR
45150: IFFALSE 45154
// exit ;
45152: GO 45179
// mc_parking := Replace ( mc_parking , base , parking_area ) ;
45154: LD_ADDR_EXP 98
45158: PUSH
45159: LD_EXP 98
45163: PPUSH
45164: LD_VAR 0 1
45168: PPUSH
45169: LD_VAR 0 2
45173: PPUSH
45174: CALL_OW 1
45178: ST_TO_ADDR
// end ;
45179: LD_VAR 0 3
45183: RET
// export function MC_SetScanArea ( base , scan_area ) ; begin
45184: LD_INT 0
45186: PPUSH
// if not mc_bases or not base or not scan_area then
45187: LD_EXP 74
45191: NOT
45192: PUSH
45193: LD_VAR 0 1
45197: NOT
45198: OR
45199: PUSH
45200: LD_VAR 0 2
45204: NOT
45205: OR
45206: IFFALSE 45210
// exit ;
45208: GO 45235
// mc_scan_area := Replace ( mc_scan_area , base , scan_area ) ;
45210: LD_ADDR_EXP 99
45214: PUSH
45215: LD_EXP 99
45219: PPUSH
45220: LD_VAR 0 1
45224: PPUSH
45225: LD_VAR 0 2
45229: PPUSH
45230: CALL_OW 1
45234: ST_TO_ADDR
// end ;
45235: LD_VAR 0 3
45239: RET
// export function MC_NotTameApeman ( base ) ; var ape_techs ; begin
45240: LD_INT 0
45242: PPUSH
45243: PPUSH
// if not mc_bases or not base then
45244: LD_EXP 74
45248: NOT
45249: PUSH
45250: LD_VAR 0 1
45254: NOT
45255: OR
45256: IFFALSE 45260
// exit ;
45258: GO 45324
// ape_techs := [ 1 , 2 , 3 , 4 , 11 ] ;
45260: LD_ADDR_VAR 0 3
45264: PUSH
45265: LD_INT 1
45267: PUSH
45268: LD_INT 2
45270: PUSH
45271: LD_INT 3
45273: PUSH
45274: LD_INT 4
45276: PUSH
45277: LD_INT 11
45279: PUSH
45280: EMPTY
45281: LIST
45282: LIST
45283: LIST
45284: LIST
45285: LIST
45286: ST_TO_ADDR
// mc_tech := Replace ( mc_tech , base , mc_tech [ base ] diff ape_techs ) ;
45287: LD_ADDR_EXP 101
45291: PUSH
45292: LD_EXP 101
45296: PPUSH
45297: LD_VAR 0 1
45301: PPUSH
45302: LD_EXP 101
45306: PUSH
45307: LD_VAR 0 1
45311: ARRAY
45312: PUSH
45313: LD_VAR 0 3
45317: DIFF
45318: PPUSH
45319: CALL_OW 1
45323: ST_TO_ADDR
// end ;
45324: LD_VAR 0 2
45328: RET
// export function MC_GetVehicles ( base , onlyCombat ) ; begin
45329: LD_INT 0
45331: PPUSH
// result := mc_vehicles [ base ] ;
45332: LD_ADDR_VAR 0 3
45336: PUSH
45337: LD_EXP 93
45341: PUSH
45342: LD_VAR 0 1
45346: ARRAY
45347: ST_TO_ADDR
// if onlyCombat then
45348: LD_VAR 0 2
45352: IFFALSE 45517
// result := result diff UnitFilter ( result , [ f_or , [ f_weapon , us_cargo_bay ] , [ f_weapon , ru_cargo_bay ] , [ f_weapon , ru_big_cargo_bay ] , [ f_weapon , ar_cargo_bay ] , [ f_weapon , us_crane ] , [ f_weapon , ru_crane ] , [ f_weapon , us_bulldozer ] , [ f_weapon , ru_bulldozer ] , [ f_weapon , ru_radar ] , [ f_weapon , ar_control_tower ] , [ f_weapon , ru_siberium_rocket ] , [ f_weapon , us_siberium_rocket ] ] ) ;
45354: LD_ADDR_VAR 0 3
45358: PUSH
45359: LD_VAR 0 3
45363: PUSH
45364: LD_VAR 0 3
45368: PPUSH
45369: LD_INT 2
45371: PUSH
45372: LD_INT 34
45374: PUSH
45375: LD_INT 12
45377: PUSH
45378: EMPTY
45379: LIST
45380: LIST
45381: PUSH
45382: LD_INT 34
45384: PUSH
45385: LD_INT 51
45387: PUSH
45388: EMPTY
45389: LIST
45390: LIST
45391: PUSH
45392: LD_INT 34
45394: PUSH
45395: LD_EXP 68
45399: PUSH
45400: EMPTY
45401: LIST
45402: LIST
45403: PUSH
45404: LD_INT 34
45406: PUSH
45407: LD_INT 32
45409: PUSH
45410: EMPTY
45411: LIST
45412: LIST
45413: PUSH
45414: LD_INT 34
45416: PUSH
45417: LD_INT 13
45419: PUSH
45420: EMPTY
45421: LIST
45422: LIST
45423: PUSH
45424: LD_INT 34
45426: PUSH
45427: LD_INT 52
45429: PUSH
45430: EMPTY
45431: LIST
45432: LIST
45433: PUSH
45434: LD_INT 34
45436: PUSH
45437: LD_INT 14
45439: PUSH
45440: EMPTY
45441: LIST
45442: LIST
45443: PUSH
45444: LD_INT 34
45446: PUSH
45447: LD_INT 53
45449: PUSH
45450: EMPTY
45451: LIST
45452: LIST
45453: PUSH
45454: LD_INT 34
45456: PUSH
45457: LD_EXP 67
45461: PUSH
45462: EMPTY
45463: LIST
45464: LIST
45465: PUSH
45466: LD_INT 34
45468: PUSH
45469: LD_INT 31
45471: PUSH
45472: EMPTY
45473: LIST
45474: LIST
45475: PUSH
45476: LD_INT 34
45478: PUSH
45479: LD_INT 48
45481: PUSH
45482: EMPTY
45483: LIST
45484: LIST
45485: PUSH
45486: LD_INT 34
45488: PUSH
45489: LD_INT 8
45491: PUSH
45492: EMPTY
45493: LIST
45494: LIST
45495: PUSH
45496: EMPTY
45497: LIST
45498: LIST
45499: LIST
45500: LIST
45501: LIST
45502: LIST
45503: LIST
45504: LIST
45505: LIST
45506: LIST
45507: LIST
45508: LIST
45509: LIST
45510: PPUSH
45511: CALL_OW 72
45515: DIFF
45516: ST_TO_ADDR
// end ; end_of_file
45517: LD_VAR 0 3
45521: RET
// export function MCE_ApemanTamed ( ape , sci ) ; var i , tmp ; begin
45522: LD_INT 0
45524: PPUSH
45525: PPUSH
45526: PPUSH
// if not mc_bases or not skirmish then
45527: LD_EXP 74
45531: NOT
45532: PUSH
45533: LD_EXP 72
45537: NOT
45538: OR
45539: IFFALSE 45543
// exit ;
45541: GO 45708
// for i = 1 to mc_bases do
45543: LD_ADDR_VAR 0 4
45547: PUSH
45548: DOUBLE
45549: LD_INT 1
45551: DEC
45552: ST_TO_ADDR
45553: LD_EXP 74
45557: PUSH
45558: FOR_TO
45559: IFFALSE 45706
// begin if sci in mc_bases [ i ] then
45561: LD_VAR 0 2
45565: PUSH
45566: LD_EXP 74
45570: PUSH
45571: LD_VAR 0 4
45575: ARRAY
45576: IN
45577: IFFALSE 45704
// begin mc_ape := ReplaceIn ( mc_ape , [ i , mc_ape [ i ] + 1 ] , ape ) ;
45579: LD_ADDR_EXP 103
45583: PUSH
45584: LD_EXP 103
45588: PPUSH
45589: LD_VAR 0 4
45593: PUSH
45594: LD_EXP 103
45598: PUSH
45599: LD_VAR 0 4
45603: ARRAY
45604: PUSH
45605: LD_INT 1
45607: PLUS
45608: PUSH
45609: EMPTY
45610: LIST
45611: LIST
45612: PPUSH
45613: LD_VAR 0 1
45617: PPUSH
45618: CALL 57403 0 3
45622: ST_TO_ADDR
// tmp := NearestUnitToUnit ( UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) , ape ) ;
45623: LD_ADDR_VAR 0 5
45627: PUSH
45628: LD_EXP 74
45632: PUSH
45633: LD_VAR 0 4
45637: ARRAY
45638: PPUSH
45639: LD_INT 2
45641: PUSH
45642: LD_INT 30
45644: PUSH
45645: LD_INT 0
45647: PUSH
45648: EMPTY
45649: LIST
45650: LIST
45651: PUSH
45652: LD_INT 30
45654: PUSH
45655: LD_INT 1
45657: PUSH
45658: EMPTY
45659: LIST
45660: LIST
45661: PUSH
45662: EMPTY
45663: LIST
45664: LIST
45665: LIST
45666: PPUSH
45667: CALL_OW 72
45671: PPUSH
45672: LD_VAR 0 1
45676: PPUSH
45677: CALL_OW 74
45681: ST_TO_ADDR
// if tmp then
45682: LD_VAR 0 5
45686: IFFALSE 45702
// ComStandNearbyBuilding ( ape , tmp ) ;
45688: LD_VAR 0 1
45692: PPUSH
45693: LD_VAR 0 5
45697: PPUSH
45698: CALL 51695 0 2
// break ;
45702: GO 45706
// end ; end ;
45704: GO 45558
45706: POP
45707: POP
// end ;
45708: LD_VAR 0 3
45712: RET
// export function MCE_EnterBuilding ( building , unit ) ; var i , tmp ; begin
45713: LD_INT 0
45715: PPUSH
45716: PPUSH
45717: PPUSH
// if not mc_bases or not skirmish then
45718: LD_EXP 74
45722: NOT
45723: PUSH
45724: LD_EXP 72
45728: NOT
45729: OR
45730: IFFALSE 45734
// exit ;
45732: GO 45823
// for i = 1 to mc_bases do
45734: LD_ADDR_VAR 0 4
45738: PUSH
45739: DOUBLE
45740: LD_INT 1
45742: DEC
45743: ST_TO_ADDR
45744: LD_EXP 74
45748: PUSH
45749: FOR_TO
45750: IFFALSE 45821
// begin if building in mc_busy_turret_list [ i ] then
45752: LD_VAR 0 1
45756: PUSH
45757: LD_EXP 84
45761: PUSH
45762: LD_VAR 0 4
45766: ARRAY
45767: IN
45768: IFFALSE 45819
// begin tmp := mc_busy_turret_list [ i ] diff building ;
45770: LD_ADDR_VAR 0 5
45774: PUSH
45775: LD_EXP 84
45779: PUSH
45780: LD_VAR 0 4
45784: ARRAY
45785: PUSH
45786: LD_VAR 0 1
45790: DIFF
45791: ST_TO_ADDR
// mc_busy_turret_list := Replace ( mc_busy_turret_list , i , tmp ) ;
45792: LD_ADDR_EXP 84
45796: PUSH
45797: LD_EXP 84
45801: PPUSH
45802: LD_VAR 0 4
45806: PPUSH
45807: LD_VAR 0 5
45811: PPUSH
45812: CALL_OW 1
45816: ST_TO_ADDR
// break ;
45817: GO 45821
// end ; end ;
45819: GO 45749
45821: POP
45822: POP
// end ;
45823: LD_VAR 0 3
45827: RET
// export function MCE_BuildingCaptured ( building , side , capturning_unit ) ; var i , tmp ; begin
45828: LD_INT 0
45830: PPUSH
45831: PPUSH
45832: PPUSH
// if not mc_bases or not skirmish then
45833: LD_EXP 74
45837: NOT
45838: PUSH
45839: LD_EXP 72
45843: NOT
45844: OR
45845: IFFALSE 45849
// exit ;
45847: GO 46048
// for i = 1 to mc_bases do
45849: LD_ADDR_VAR 0 5
45853: PUSH
45854: DOUBLE
45855: LD_INT 1
45857: DEC
45858: ST_TO_ADDR
45859: LD_EXP 74
45863: PUSH
45864: FOR_TO
45865: IFFALSE 46046
// if building in mc_bases [ i ] then
45867: LD_VAR 0 1
45871: PUSH
45872: LD_EXP 74
45876: PUSH
45877: LD_VAR 0 5
45881: ARRAY
45882: IN
45883: IFFALSE 46044
// begin tmp := mc_bases [ i ] diff building ;
45885: LD_ADDR_VAR 0 6
45889: PUSH
45890: LD_EXP 74
45894: PUSH
45895: LD_VAR 0 5
45899: ARRAY
45900: PUSH
45901: LD_VAR 0 1
45905: DIFF
45906: ST_TO_ADDR
// mc_bases := Replace ( mc_bases , i , tmp ) ;
45907: LD_ADDR_EXP 74
45911: PUSH
45912: LD_EXP 74
45916: PPUSH
45917: LD_VAR 0 5
45921: PPUSH
45922: LD_VAR 0 6
45926: PPUSH
45927: CALL_OW 1
45931: ST_TO_ADDR
// if building in mc_turret_list [ i ] then
45932: LD_VAR 0 1
45936: PUSH
45937: LD_EXP 82
45941: PUSH
45942: LD_VAR 0 5
45946: ARRAY
45947: IN
45948: IFFALSE 45987
// mc_turret_list := Replace ( mc_turret_list , i , mc_turret_list [ i ] diff building ) ;
45950: LD_ADDR_EXP 82
45954: PUSH
45955: LD_EXP 82
45959: PPUSH
45960: LD_VAR 0 5
45964: PPUSH
45965: LD_EXP 82
45969: PUSH
45970: LD_VAR 0 5
45974: ARRAY
45975: PUSH
45976: LD_VAR 0 1
45980: DIFF
45981: PPUSH
45982: CALL_OW 1
45986: ST_TO_ADDR
// if building in mc_empty_turret_list [ i ] then
45987: LD_VAR 0 1
45991: PUSH
45992: LD_EXP 83
45996: PUSH
45997: LD_VAR 0 5
46001: ARRAY
46002: IN
46003: IFFALSE 46042
// mc_empty_turret_list := Replace ( mc_empty_turret_list , i , mc_empty_turret_list [ i ] diff building ) ;
46005: LD_ADDR_EXP 83
46009: PUSH
46010: LD_EXP 83
46014: PPUSH
46015: LD_VAR 0 5
46019: PPUSH
46020: LD_EXP 83
46024: PUSH
46025: LD_VAR 0 5
46029: ARRAY
46030: PUSH
46031: LD_VAR 0 1
46035: DIFF
46036: PPUSH
46037: CALL_OW 1
46041: ST_TO_ADDR
// break ;
46042: GO 46046
// end ;
46044: GO 45864
46046: POP
46047: POP
// end ;
46048: LD_VAR 0 4
46052: RET
// export function MCE_VehicleCaptured ( new , old , side , capturing_unit ) ; var i , tmp ; begin
46053: LD_INT 0
46055: PPUSH
46056: PPUSH
46057: PPUSH
// if not mc_bases or not skirmish or not side in mc_sides then
46058: LD_EXP 74
46062: NOT
46063: PUSH
46064: LD_EXP 72
46068: NOT
46069: OR
46070: PUSH
46071: LD_VAR 0 3
46075: PUSH
46076: LD_EXP 100
46080: IN
46081: NOT
46082: OR
46083: IFFALSE 46087
// exit ;
46085: GO 46210
// for i = 1 to mc_vehicles do
46087: LD_ADDR_VAR 0 6
46091: PUSH
46092: DOUBLE
46093: LD_INT 1
46095: DEC
46096: ST_TO_ADDR
46097: LD_EXP 93
46101: PUSH
46102: FOR_TO
46103: IFFALSE 46208
// if old in mc_vehicles [ i ] or new in mc_vehicles [ i ] then
46105: LD_VAR 0 2
46109: PUSH
46110: LD_EXP 93
46114: PUSH
46115: LD_VAR 0 6
46119: ARRAY
46120: IN
46121: PUSH
46122: LD_VAR 0 1
46126: PUSH
46127: LD_EXP 93
46131: PUSH
46132: LD_VAR 0 6
46136: ARRAY
46137: IN
46138: OR
46139: IFFALSE 46206
// begin tmp := mc_vehicles [ i ] diff old ;
46141: LD_ADDR_VAR 0 7
46145: PUSH
46146: LD_EXP 93
46150: PUSH
46151: LD_VAR 0 6
46155: ARRAY
46156: PUSH
46157: LD_VAR 0 2
46161: DIFF
46162: ST_TO_ADDR
// tmp := tmp diff new ;
46163: LD_ADDR_VAR 0 7
46167: PUSH
46168: LD_VAR 0 7
46172: PUSH
46173: LD_VAR 0 1
46177: DIFF
46178: ST_TO_ADDR
// mc_vehicles := Replace ( mc_vehicles , i , tmp ) ;
46179: LD_ADDR_EXP 93
46183: PUSH
46184: LD_EXP 93
46188: PPUSH
46189: LD_VAR 0 6
46193: PPUSH
46194: LD_VAR 0 7
46198: PPUSH
46199: CALL_OW 1
46203: ST_TO_ADDR
// break ;
46204: GO 46208
// end ;
46206: GO 46102
46208: POP
46209: POP
// end ;
46210: LD_VAR 0 5
46214: RET
// export function MCE_VehicleConstructed ( vehicle , factory ) ; var i , side , tmp ; begin
46215: LD_INT 0
46217: PPUSH
46218: PPUSH
46219: PPUSH
46220: PPUSH
// if not mc_bases or not skirmish then
46221: LD_EXP 74
46225: NOT
46226: PUSH
46227: LD_EXP 72
46231: NOT
46232: OR
46233: IFFALSE 46237
// exit ;
46235: GO 46614
// side := GetSide ( vehicle ) ;
46237: LD_ADDR_VAR 0 5
46241: PUSH
46242: LD_VAR 0 1
46246: PPUSH
46247: CALL_OW 255
46251: ST_TO_ADDR
// for i = 1 to mc_bases do
46252: LD_ADDR_VAR 0 4
46256: PUSH
46257: DOUBLE
46258: LD_INT 1
46260: DEC
46261: ST_TO_ADDR
46262: LD_EXP 74
46266: PUSH
46267: FOR_TO
46268: IFFALSE 46612
// begin if factory in mc_bases [ i ] then
46270: LD_VAR 0 2
46274: PUSH
46275: LD_EXP 74
46279: PUSH
46280: LD_VAR 0 4
46284: ARRAY
46285: IN
46286: IFFALSE 46610
// begin if mc_defender [ i ] < mc_defender_limit [ i ] and not GetWeapon ( vehicle ) in [ ar_control_tower , ar_cargo_bay , ru_cargo_bay , ru_big_cargo_bay , us_cargo_bay , ar_radar , ru_radar , us_radar , ru_bulldozer , us_bulldozer , ar_bio_bomb , ar_selfpropelled_bomb , us_hack , us_crane , ru_crane , ru_siberium_rocket , us_siberium_rocket ] then
46288: LD_EXP 96
46292: PUSH
46293: LD_VAR 0 4
46297: ARRAY
46298: PUSH
46299: LD_EXP 85
46303: PUSH
46304: LD_VAR 0 4
46308: ARRAY
46309: LESS
46310: PUSH
46311: LD_VAR 0 1
46315: PPUSH
46316: CALL_OW 264
46320: PUSH
46321: LD_INT 31
46323: PUSH
46324: LD_INT 32
46326: PUSH
46327: LD_INT 51
46329: PUSH
46330: LD_EXP 68
46334: PUSH
46335: LD_INT 12
46337: PUSH
46338: LD_INT 30
46340: PUSH
46341: LD_EXP 67
46345: PUSH
46346: LD_INT 11
46348: PUSH
46349: LD_INT 53
46351: PUSH
46352: LD_INT 14
46354: PUSH
46355: LD_EXP 71
46359: PUSH
46360: LD_INT 29
46362: PUSH
46363: LD_EXP 69
46367: PUSH
46368: LD_INT 13
46370: PUSH
46371: LD_INT 52
46373: PUSH
46374: LD_INT 48
46376: PUSH
46377: LD_INT 8
46379: PUSH
46380: EMPTY
46381: LIST
46382: LIST
46383: LIST
46384: LIST
46385: LIST
46386: LIST
46387: LIST
46388: LIST
46389: LIST
46390: LIST
46391: LIST
46392: LIST
46393: LIST
46394: LIST
46395: LIST
46396: LIST
46397: LIST
46398: IN
46399: NOT
46400: AND
46401: IFFALSE 46449
// mc_defender := ReplaceIn ( mc_defender , [ i , mc_defender [ i ] + 1 ] , vehicle ) else
46403: LD_ADDR_EXP 96
46407: PUSH
46408: LD_EXP 96
46412: PPUSH
46413: LD_VAR 0 4
46417: PUSH
46418: LD_EXP 96
46422: PUSH
46423: LD_VAR 0 4
46427: ARRAY
46428: PUSH
46429: LD_INT 1
46431: PLUS
46432: PUSH
46433: EMPTY
46434: LIST
46435: LIST
46436: PPUSH
46437: LD_VAR 0 1
46441: PPUSH
46442: CALL 57403 0 3
46446: ST_TO_ADDR
46447: GO 46493
// mc_vehicles := ReplaceIn ( mc_vehicles , [ i , mc_vehicles [ i ] + 1 ] , vehicle ) ;
46449: LD_ADDR_EXP 93
46453: PUSH
46454: LD_EXP 93
46458: PPUSH
46459: LD_VAR 0 4
46463: PUSH
46464: LD_EXP 93
46468: PUSH
46469: LD_VAR 0 4
46473: ARRAY
46474: PUSH
46475: LD_INT 1
46477: PLUS
46478: PUSH
46479: EMPTY
46480: LIST
46481: LIST
46482: PPUSH
46483: LD_VAR 0 1
46487: PPUSH
46488: CALL 57403 0 3
46492: ST_TO_ADDR
// if GetControl ( vehicle ) = control_remote then
46493: LD_VAR 0 1
46497: PPUSH
46498: CALL_OW 263
46502: PUSH
46503: LD_INT 2
46505: EQUAL
46506: IFFALSE 46526
// begin repeat wait ( 0 0$1 ) ;
46508: LD_INT 35
46510: PPUSH
46511: CALL_OW 67
// until IsControledBy ( vehicle ) ;
46515: LD_VAR 0 1
46519: PPUSH
46520: CALL_OW 312
46524: IFFALSE 46508
// end ; ComMoveToArea ( vehicle , mc_parking [ i ] ) ;
46526: LD_VAR 0 1
46530: PPUSH
46531: LD_EXP 98
46535: PUSH
46536: LD_VAR 0 4
46540: ARRAY
46541: PPUSH
46542: CALL_OW 113
// if GetControl ( vehicle ) <> control_manual then
46546: LD_VAR 0 1
46550: PPUSH
46551: CALL_OW 263
46555: PUSH
46556: LD_INT 1
46558: NONEQUAL
46559: IFFALSE 46563
// break ;
46561: GO 46612
// repeat wait ( 0 0$1 ) ;
46563: LD_INT 35
46565: PPUSH
46566: CALL_OW 67
// until IsInArea ( vehicle , mc_parking [ i ] ) ;
46570: LD_VAR 0 1
46574: PPUSH
46575: LD_EXP 98
46579: PUSH
46580: LD_VAR 0 4
46584: ARRAY
46585: PPUSH
46586: CALL_OW 308
46590: IFFALSE 46563
// ComExitVehicle ( IsDrivenBy ( vehicle ) ) ;
46592: LD_VAR 0 1
46596: PPUSH
46597: CALL_OW 311
46601: PPUSH
46602: CALL_OW 121
// exit ;
46606: POP
46607: POP
46608: GO 46614
// end ; end ;
46610: GO 46267
46612: POP
46613: POP
// end ;
46614: LD_VAR 0 3
46618: RET
// export function MCE_CrateSpawn ( id , x , y , amount , mode ) ; var i , j , depot ; begin
46619: LD_INT 0
46621: PPUSH
46622: PPUSH
46623: PPUSH
46624: PPUSH
// if not mc_bases or not skirmish then
46625: LD_EXP 74
46629: NOT
46630: PUSH
46631: LD_EXP 72
46635: NOT
46636: OR
46637: IFFALSE 46641
// exit ;
46639: GO 46994
// repeat wait ( 0 0$1 ) ;
46641: LD_INT 35
46643: PPUSH
46644: CALL_OW 67
// until GetResourceAmountXY ( x , y ) ;
46648: LD_VAR 0 2
46652: PPUSH
46653: LD_VAR 0 3
46657: PPUSH
46658: CALL_OW 284
46662: IFFALSE 46641
// if GetResourceTypeXY ( x , y ) = mat_artefact then
46664: LD_VAR 0 2
46668: PPUSH
46669: LD_VAR 0 3
46673: PPUSH
46674: CALL_OW 283
46678: PUSH
46679: LD_INT 4
46681: EQUAL
46682: IFFALSE 46686
// exit ;
46684: GO 46994
// for i = 1 to mc_bases do
46686: LD_ADDR_VAR 0 7
46690: PUSH
46691: DOUBLE
46692: LD_INT 1
46694: DEC
46695: ST_TO_ADDR
46696: LD_EXP 74
46700: PUSH
46701: FOR_TO
46702: IFFALSE 46992
// begin if mc_crates_area [ i ] then
46704: LD_EXP 92
46708: PUSH
46709: LD_VAR 0 7
46713: ARRAY
46714: IFFALSE 46825
// for j in mc_crates_area [ i ] do
46716: LD_ADDR_VAR 0 8
46720: PUSH
46721: LD_EXP 92
46725: PUSH
46726: LD_VAR 0 7
46730: ARRAY
46731: PUSH
46732: FOR_IN
46733: IFFALSE 46823
// if InArea ( x , y , j ) then
46735: LD_VAR 0 2
46739: PPUSH
46740: LD_VAR 0 3
46744: PPUSH
46745: LD_VAR 0 8
46749: PPUSH
46750: CALL_OW 309
46754: IFFALSE 46821
// begin mc_crates := ReplaceIn ( mc_crates , [ i , mc_crates [ i ] + 1 ] , [ amount , x , y ] ) ;
46756: LD_ADDR_EXP 90
46760: PUSH
46761: LD_EXP 90
46765: PPUSH
46766: LD_VAR 0 7
46770: PUSH
46771: LD_EXP 90
46775: PUSH
46776: LD_VAR 0 7
46780: ARRAY
46781: PUSH
46782: LD_INT 1
46784: PLUS
46785: PUSH
46786: EMPTY
46787: LIST
46788: LIST
46789: PPUSH
46790: LD_VAR 0 4
46794: PUSH
46795: LD_VAR 0 2
46799: PUSH
46800: LD_VAR 0 3
46804: PUSH
46805: EMPTY
46806: LIST
46807: LIST
46808: LIST
46809: PPUSH
46810: CALL 57403 0 3
46814: ST_TO_ADDR
// exit ;
46815: POP
46816: POP
46817: POP
46818: POP
46819: GO 46994
// end ;
46821: GO 46732
46823: POP
46824: POP
// depot := UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) ;
46825: LD_ADDR_VAR 0 9
46829: PUSH
46830: LD_EXP 74
46834: PUSH
46835: LD_VAR 0 7
46839: ARRAY
46840: PPUSH
46841: LD_INT 2
46843: PUSH
46844: LD_INT 30
46846: PUSH
46847: LD_INT 0
46849: PUSH
46850: EMPTY
46851: LIST
46852: LIST
46853: PUSH
46854: LD_INT 30
46856: PUSH
46857: LD_INT 1
46859: PUSH
46860: EMPTY
46861: LIST
46862: LIST
46863: PUSH
46864: EMPTY
46865: LIST
46866: LIST
46867: LIST
46868: PPUSH
46869: CALL_OW 72
46873: ST_TO_ADDR
// if not depot then
46874: LD_VAR 0 9
46878: NOT
46879: IFFALSE 46883
// continue ;
46881: GO 46701
// for j in depot do
46883: LD_ADDR_VAR 0 8
46887: PUSH
46888: LD_VAR 0 9
46892: PUSH
46893: FOR_IN
46894: IFFALSE 46988
// if GetDistUnitXY ( j , x , y ) < 30 then
46896: LD_VAR 0 8
46900: PPUSH
46901: LD_VAR 0 2
46905: PPUSH
46906: LD_VAR 0 3
46910: PPUSH
46911: CALL_OW 297
46915: PUSH
46916: LD_INT 30
46918: LESS
46919: IFFALSE 46986
// begin mc_crates := ReplaceIn ( mc_crates , [ i , mc_crates [ i ] + 1 ] , [ amount , x , y ] ) ;
46921: LD_ADDR_EXP 90
46925: PUSH
46926: LD_EXP 90
46930: PPUSH
46931: LD_VAR 0 7
46935: PUSH
46936: LD_EXP 90
46940: PUSH
46941: LD_VAR 0 7
46945: ARRAY
46946: PUSH
46947: LD_INT 1
46949: PLUS
46950: PUSH
46951: EMPTY
46952: LIST
46953: LIST
46954: PPUSH
46955: LD_VAR 0 4
46959: PUSH
46960: LD_VAR 0 2
46964: PUSH
46965: LD_VAR 0 3
46969: PUSH
46970: EMPTY
46971: LIST
46972: LIST
46973: LIST
46974: PPUSH
46975: CALL 57403 0 3
46979: ST_TO_ADDR
// exit ;
46980: POP
46981: POP
46982: POP
46983: POP
46984: GO 46994
// end ;
46986: GO 46893
46988: POP
46989: POP
// end ;
46990: GO 46701
46992: POP
46993: POP
// end ;
46994: LD_VAR 0 6
46998: RET
// export function MCE_ResearchComplete ( tech , lab ) ; var side , i , tmp ; begin
46999: LD_INT 0
47001: PPUSH
47002: PPUSH
47003: PPUSH
47004: PPUSH
// if not mc_bases or not skirmish then
47005: LD_EXP 74
47009: NOT
47010: PUSH
47011: LD_EXP 72
47015: NOT
47016: OR
47017: IFFALSE 47021
// exit ;
47019: GO 47298
// side := GetSide ( lab ) ;
47021: LD_ADDR_VAR 0 4
47025: PUSH
47026: LD_VAR 0 2
47030: PPUSH
47031: CALL_OW 255
47035: ST_TO_ADDR
// if not side in mc_sides or not mc_tech or not mc_bases then
47036: LD_VAR 0 4
47040: PUSH
47041: LD_EXP 100
47045: IN
47046: NOT
47047: PUSH
47048: LD_EXP 101
47052: NOT
47053: OR
47054: PUSH
47055: LD_EXP 74
47059: NOT
47060: OR
47061: IFFALSE 47065
// exit ;
47063: GO 47298
// mc_tech := Replace ( mc_tech , side , mc_tech [ side ] diff tech ) ;
47065: LD_ADDR_EXP 101
47069: PUSH
47070: LD_EXP 101
47074: PPUSH
47075: LD_VAR 0 4
47079: PPUSH
47080: LD_EXP 101
47084: PUSH
47085: LD_VAR 0 4
47089: ARRAY
47090: PUSH
47091: LD_VAR 0 1
47095: DIFF
47096: PPUSH
47097: CALL_OW 1
47101: ST_TO_ADDR
// for i = 1 to mc_bases do
47102: LD_ADDR_VAR 0 5
47106: PUSH
47107: DOUBLE
47108: LD_INT 1
47110: DEC
47111: ST_TO_ADDR
47112: LD_EXP 74
47116: PUSH
47117: FOR_TO
47118: IFFALSE 47296
// begin if lab in mc_bases [ i ] then
47120: LD_VAR 0 2
47124: PUSH
47125: LD_EXP 74
47129: PUSH
47130: LD_VAR 0 5
47134: ARRAY
47135: IN
47136: IFFALSE 47294
// begin if tech in [ tech_apeagres , tech_apebrain , tech_apeneural , tech_apepsych ] and mc_ape_in_lab [ i ] then
47138: LD_VAR 0 1
47142: PUSH
47143: LD_INT 11
47145: PUSH
47146: LD_INT 4
47148: PUSH
47149: LD_INT 3
47151: PUSH
47152: LD_INT 2
47154: PUSH
47155: EMPTY
47156: LIST
47157: LIST
47158: LIST
47159: LIST
47160: IN
47161: PUSH
47162: LD_EXP 104
47166: PUSH
47167: LD_VAR 0 5
47171: ARRAY
47172: AND
47173: IFFALSE 47294
// begin tmp := mc_ape_in_lab [ i ] [ 1 ] ;
47175: LD_ADDR_VAR 0 6
47179: PUSH
47180: LD_EXP 104
47184: PUSH
47185: LD_VAR 0 5
47189: ARRAY
47190: PUSH
47191: LD_INT 1
47193: ARRAY
47194: ST_TO_ADDR
// mc_ape_in_lab := Replace ( mc_ape_in_lab , i , [ ] ) ;
47195: LD_ADDR_EXP 104
47199: PUSH
47200: LD_EXP 104
47204: PPUSH
47205: LD_VAR 0 5
47209: PPUSH
47210: EMPTY
47211: PPUSH
47212: CALL_OW 1
47216: ST_TO_ADDR
// SetTag ( tmp , 0 ) ;
47217: LD_VAR 0 6
47221: PPUSH
47222: LD_INT 0
47224: PPUSH
47225: CALL_OW 109
// ComExitBuilding ( tmp ) ;
47229: LD_VAR 0 6
47233: PPUSH
47234: CALL_OW 122
// mc_ape := Replace ( mc_ape , i , Insert ( mc_ape [ i ] , 1 , tmp ) ) ;
47238: LD_ADDR_EXP 103
47242: PUSH
47243: LD_EXP 103
47247: PPUSH
47248: LD_VAR 0 5
47252: PPUSH
47253: LD_EXP 103
47257: PUSH
47258: LD_VAR 0 5
47262: ARRAY
47263: PPUSH
47264: LD_INT 1
47266: PPUSH
47267: LD_VAR 0 6
47271: PPUSH
47272: CALL_OW 2
47276: PPUSH
47277: CALL_OW 1
47281: ST_TO_ADDR
// MC_Reset ( i , 112 ) ;
47282: LD_VAR 0 5
47286: PPUSH
47287: LD_INT 112
47289: PPUSH
47290: CALL 24190 0 2
// end ; end ; end ;
47294: GO 47117
47296: POP
47297: POP
// end ;
47298: LD_VAR 0 3
47302: RET
// export function MCE_UnitDestroyed ( un ) ; var i , j , btype , pos , tmp , fac , components ; begin
47303: LD_INT 0
47305: PPUSH
47306: PPUSH
47307: PPUSH
47308: PPUSH
47309: PPUSH
47310: PPUSH
47311: PPUSH
47312: PPUSH
// if not mc_bases or not skirmish then
47313: LD_EXP 74
47317: NOT
47318: PUSH
47319: LD_EXP 72
47323: NOT
47324: OR
47325: IFFALSE 47329
// exit ;
47327: GO 48700
// for i = 1 to mc_bases do
47329: LD_ADDR_VAR 0 3
47333: PUSH
47334: DOUBLE
47335: LD_INT 1
47337: DEC
47338: ST_TO_ADDR
47339: LD_EXP 74
47343: PUSH
47344: FOR_TO
47345: IFFALSE 48698
// if un in mc_bases [ i ] or un in mc_construct_list [ i ] or un in mc_defender [ i ] or un in mc_vehicles [ i ] or un in mc_ape [ i ] or un in mc_ape_in_lab [ i ] then
47347: LD_VAR 0 1
47351: PUSH
47352: LD_EXP 74
47356: PUSH
47357: LD_VAR 0 3
47361: ARRAY
47362: IN
47363: PUSH
47364: LD_VAR 0 1
47368: PUSH
47369: LD_EXP 81
47373: PUSH
47374: LD_VAR 0 3
47378: ARRAY
47379: IN
47380: OR
47381: PUSH
47382: LD_VAR 0 1
47386: PUSH
47387: LD_EXP 96
47391: PUSH
47392: LD_VAR 0 3
47396: ARRAY
47397: IN
47398: OR
47399: PUSH
47400: LD_VAR 0 1
47404: PUSH
47405: LD_EXP 93
47409: PUSH
47410: LD_VAR 0 3
47414: ARRAY
47415: IN
47416: OR
47417: PUSH
47418: LD_VAR 0 1
47422: PUSH
47423: LD_EXP 103
47427: PUSH
47428: LD_VAR 0 3
47432: ARRAY
47433: IN
47434: OR
47435: PUSH
47436: LD_VAR 0 1
47440: PUSH
47441: LD_EXP 104
47445: PUSH
47446: LD_VAR 0 3
47450: ARRAY
47451: IN
47452: OR
47453: IFFALSE 48696
// begin if un in mc_ape [ i ] then
47455: LD_VAR 0 1
47459: PUSH
47460: LD_EXP 103
47464: PUSH
47465: LD_VAR 0 3
47469: ARRAY
47470: IN
47471: IFFALSE 47510
// begin mc_ape := Replace ( mc_ape , i , mc_ape [ i ] diff un ) ;
47473: LD_ADDR_EXP 103
47477: PUSH
47478: LD_EXP 103
47482: PPUSH
47483: LD_VAR 0 3
47487: PPUSH
47488: LD_EXP 103
47492: PUSH
47493: LD_VAR 0 3
47497: ARRAY
47498: PUSH
47499: LD_VAR 0 1
47503: DIFF
47504: PPUSH
47505: CALL_OW 1
47509: ST_TO_ADDR
// end ; if un in mc_ape_in_lab [ i ] then
47510: LD_VAR 0 1
47514: PUSH
47515: LD_EXP 104
47519: PUSH
47520: LD_VAR 0 3
47524: ARRAY
47525: IN
47526: IFFALSE 47550
// begin mc_ape_in_lab := Replace ( mc_ape_in_lab , i , [ ] ) ;
47528: LD_ADDR_EXP 104
47532: PUSH
47533: LD_EXP 104
47537: PPUSH
47538: LD_VAR 0 3
47542: PPUSH
47543: EMPTY
47544: PPUSH
47545: CALL_OW 1
47549: ST_TO_ADDR
// end ; if GetType ( un ) = unit_vehicle and ( GetTag ( un ) = 20 or un in mc_defender [ i ] or GetWeapon ( un ) in [ us_cargo_bay , ru_cargo_bay , ru_big_cargo_bay , ar_cargo_bay , us_crane , ru_crane , ar_control_tower ] ) then
47550: LD_VAR 0 1
47554: PPUSH
47555: CALL_OW 247
47559: PUSH
47560: LD_INT 2
47562: EQUAL
47563: PUSH
47564: LD_VAR 0 1
47568: PPUSH
47569: CALL_OW 110
47573: PUSH
47574: LD_INT 20
47576: EQUAL
47577: PUSH
47578: LD_VAR 0 1
47582: PUSH
47583: LD_EXP 96
47587: PUSH
47588: LD_VAR 0 3
47592: ARRAY
47593: IN
47594: OR
47595: PUSH
47596: LD_VAR 0 1
47600: PPUSH
47601: CALL_OW 264
47605: PUSH
47606: LD_INT 12
47608: PUSH
47609: LD_INT 51
47611: PUSH
47612: LD_EXP 68
47616: PUSH
47617: LD_INT 32
47619: PUSH
47620: LD_INT 13
47622: PUSH
47623: LD_INT 52
47625: PUSH
47626: LD_INT 31
47628: PUSH
47629: EMPTY
47630: LIST
47631: LIST
47632: LIST
47633: LIST
47634: LIST
47635: LIST
47636: LIST
47637: IN
47638: OR
47639: AND
47640: IFFALSE 47948
// begin if un in mc_defender [ i ] then
47642: LD_VAR 0 1
47646: PUSH
47647: LD_EXP 96
47651: PUSH
47652: LD_VAR 0 3
47656: ARRAY
47657: IN
47658: IFFALSE 47697
// mc_defender := Replace ( mc_defender , i , mc_defender [ i ] diff un ) ;
47660: LD_ADDR_EXP 96
47664: PUSH
47665: LD_EXP 96
47669: PPUSH
47670: LD_VAR 0 3
47674: PPUSH
47675: LD_EXP 96
47679: PUSH
47680: LD_VAR 0 3
47684: ARRAY
47685: PUSH
47686: LD_VAR 0 1
47690: DIFF
47691: PPUSH
47692: CALL_OW 1
47696: ST_TO_ADDR
// fac := MC_GetBuildings ( i , b_factory ) ;
47697: LD_ADDR_VAR 0 8
47701: PUSH
47702: LD_VAR 0 3
47706: PPUSH
47707: LD_INT 3
47709: PPUSH
47710: CALL 44366 0 2
47714: ST_TO_ADDR
// if fac then
47715: LD_VAR 0 8
47719: IFFALSE 47948
// begin for j in fac do
47721: LD_ADDR_VAR 0 4
47725: PUSH
47726: LD_VAR 0 8
47730: PUSH
47731: FOR_IN
47732: IFFALSE 47946
// begin components := Produce ( fac , GetChassis ( un ) , GetEngine ( un ) , GetControl ( un ) , GetWeapon ( un ) ) ;
47734: LD_ADDR_VAR 0 9
47738: PUSH
47739: LD_VAR 0 8
47743: PPUSH
47744: LD_VAR 0 1
47748: PPUSH
47749: CALL_OW 265
47753: PPUSH
47754: LD_VAR 0 1
47758: PPUSH
47759: CALL_OW 262
47763: PPUSH
47764: LD_VAR 0 1
47768: PPUSH
47769: CALL_OW 263
47773: PPUSH
47774: LD_VAR 0 1
47778: PPUSH
47779: CALL_OW 264
47783: PPUSH
47784: CALL 54935 0 5
47788: ST_TO_ADDR
// if components then
47789: LD_VAR 0 9
47793: IFFALSE 47944
// begin if GetWeapon ( un ) = ar_control_tower then
47795: LD_VAR 0 1
47799: PPUSH
47800: CALL_OW 264
47804: PUSH
47805: LD_INT 31
47807: EQUAL
47808: IFFALSE 47925
// begin SetTag ( IsDrivenBy ( un ) , 0 ) ;
47810: LD_VAR 0 1
47814: PPUSH
47815: CALL_OW 311
47819: PPUSH
47820: LD_INT 0
47822: PPUSH
47823: CALL_OW 109
// mc_remote_driver := Replace ( mc_remote_driver , i , mc_remote_driver [ i ] diff IsDrivenBy ( un ) ) ;
47827: LD_ADDR_EXP 114
47831: PUSH
47832: LD_EXP 114
47836: PPUSH
47837: LD_VAR 0 3
47841: PPUSH
47842: LD_EXP 114
47846: PUSH
47847: LD_VAR 0 3
47851: ARRAY
47852: PUSH
47853: LD_VAR 0 1
47857: PPUSH
47858: CALL_OW 311
47862: DIFF
47863: PPUSH
47864: CALL_OW 1
47868: ST_TO_ADDR
// tmp := Insert ( mc_produce [ i ] , 1 , components ) ;
47869: LD_ADDR_VAR 0 7
47873: PUSH
47874: LD_EXP 95
47878: PUSH
47879: LD_VAR 0 3
47883: ARRAY
47884: PPUSH
47885: LD_INT 1
47887: PPUSH
47888: LD_VAR 0 9
47892: PPUSH
47893: CALL_OW 2
47897: ST_TO_ADDR
// mc_produce := Replace ( mc_produce , i , tmp ) ;
47898: LD_ADDR_EXP 95
47902: PUSH
47903: LD_EXP 95
47907: PPUSH
47908: LD_VAR 0 3
47912: PPUSH
47913: LD_VAR 0 7
47917: PPUSH
47918: CALL_OW 1
47922: ST_TO_ADDR
// end else
47923: GO 47942
// MC_InsertProduceList ( i , [ components ] ) ;
47925: LD_VAR 0 3
47929: PPUSH
47930: LD_VAR 0 9
47934: PUSH
47935: EMPTY
47936: LIST
47937: PPUSH
47938: CALL 43911 0 2
// break ;
47942: GO 47946
// end ; end ;
47944: GO 47731
47946: POP
47947: POP
// end ; end ; if GetType ( un ) = unit_building then
47948: LD_VAR 0 1
47952: PPUSH
47953: CALL_OW 247
47957: PUSH
47958: LD_INT 3
47960: EQUAL
47961: IFFALSE 48364
// begin btype := GetBType ( un ) ;
47963: LD_ADDR_VAR 0 5
47967: PUSH
47968: LD_VAR 0 1
47972: PPUSH
47973: CALL_OW 266
47977: ST_TO_ADDR
// if btype in [ b_oil_mine , b_siberite_mine ] then
47978: LD_VAR 0 5
47982: PUSH
47983: LD_INT 29
47985: PUSH
47986: LD_INT 30
47988: PUSH
47989: EMPTY
47990: LIST
47991: LIST
47992: IN
47993: IFFALSE 48066
// begin if not GetResourceVisibility ( GetX ( un ) , GetY ( un ) , GetSide ( un ) ) then
47995: LD_VAR 0 1
47999: PPUSH
48000: CALL_OW 250
48004: PPUSH
48005: LD_VAR 0 1
48009: PPUSH
48010: CALL_OW 251
48014: PPUSH
48015: LD_VAR 0 1
48019: PPUSH
48020: CALL_OW 255
48024: PPUSH
48025: CALL_OW 440
48029: NOT
48030: IFFALSE 48066
// SetResourceVisibility ( GetX ( un ) , GetY ( un ) , GetSide ( un ) ) ;
48032: LD_VAR 0 1
48036: PPUSH
48037: CALL_OW 250
48041: PPUSH
48042: LD_VAR 0 1
48046: PPUSH
48047: CALL_OW 251
48051: PPUSH
48052: LD_VAR 0 1
48056: PPUSH
48057: CALL_OW 255
48061: PPUSH
48062: CALL_OW 441
// end ; if btype = b_warehouse then
48066: LD_VAR 0 5
48070: PUSH
48071: LD_INT 1
48073: EQUAL
48074: IFFALSE 48092
// begin btype := b_depot ;
48076: LD_ADDR_VAR 0 5
48080: PUSH
48081: LD_INT 0
48083: ST_TO_ADDR
// pos := 1 ;
48084: LD_ADDR_VAR 0 6
48088: PUSH
48089: LD_INT 1
48091: ST_TO_ADDR
// end ; if btype = b_factory then
48092: LD_VAR 0 5
48096: PUSH
48097: LD_INT 3
48099: EQUAL
48100: IFFALSE 48118
// begin btype := b_workshop ;
48102: LD_ADDR_VAR 0 5
48106: PUSH
48107: LD_INT 2
48109: ST_TO_ADDR
// pos := 1 ;
48110: LD_ADDR_VAR 0 6
48114: PUSH
48115: LD_INT 1
48117: ST_TO_ADDR
// end ; if btype = b_barracks then
48118: LD_VAR 0 5
48122: PUSH
48123: LD_INT 5
48125: EQUAL
48126: IFFALSE 48136
// btype := b_armoury ;
48128: LD_ADDR_VAR 0 5
48132: PUSH
48133: LD_INT 4
48135: ST_TO_ADDR
// if btype in [ b_lab_half , b_lab_full ] then
48136: LD_VAR 0 5
48140: PUSH
48141: LD_INT 7
48143: PUSH
48144: LD_INT 8
48146: PUSH
48147: EMPTY
48148: LIST
48149: LIST
48150: IN
48151: IFFALSE 48161
// btype := b_lab ;
48153: LD_ADDR_VAR 0 5
48157: PUSH
48158: LD_INT 6
48160: ST_TO_ADDR
// mc_build_list := ReplaceIn ( mc_build_list , [ i , mc_build_list [ i ] + 1 ] , [ btype , GetX ( un ) , GetY ( un ) , GetDir ( un ) ] ) ;
48161: LD_ADDR_EXP 79
48165: PUSH
48166: LD_EXP 79
48170: PPUSH
48171: LD_VAR 0 3
48175: PUSH
48176: LD_EXP 79
48180: PUSH
48181: LD_VAR 0 3
48185: ARRAY
48186: PUSH
48187: LD_INT 1
48189: PLUS
48190: PUSH
48191: EMPTY
48192: LIST
48193: LIST
48194: PPUSH
48195: LD_VAR 0 5
48199: PUSH
48200: LD_VAR 0 1
48204: PPUSH
48205: CALL_OW 250
48209: PUSH
48210: LD_VAR 0 1
48214: PPUSH
48215: CALL_OW 251
48219: PUSH
48220: LD_VAR 0 1
48224: PPUSH
48225: CALL_OW 254
48229: PUSH
48230: EMPTY
48231: LIST
48232: LIST
48233: LIST
48234: LIST
48235: PPUSH
48236: CALL 57403 0 3
48240: ST_TO_ADDR
// if pos = 1 then
48241: LD_VAR 0 6
48245: PUSH
48246: LD_INT 1
48248: EQUAL
48249: IFFALSE 48364
// begin tmp := mc_build_list [ i ] ;
48251: LD_ADDR_VAR 0 7
48255: PUSH
48256: LD_EXP 79
48260: PUSH
48261: LD_VAR 0 3
48265: ARRAY
48266: ST_TO_ADDR
// if UnitFilter ( tmp , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) then
48267: LD_VAR 0 7
48271: PPUSH
48272: LD_INT 2
48274: PUSH
48275: LD_INT 30
48277: PUSH
48278: LD_INT 0
48280: PUSH
48281: EMPTY
48282: LIST
48283: LIST
48284: PUSH
48285: LD_INT 30
48287: PUSH
48288: LD_INT 1
48290: PUSH
48291: EMPTY
48292: LIST
48293: LIST
48294: PUSH
48295: EMPTY
48296: LIST
48297: LIST
48298: LIST
48299: PPUSH
48300: CALL_OW 72
48304: IFFALSE 48314
// pos := 2 ;
48306: LD_ADDR_VAR 0 6
48310: PUSH
48311: LD_INT 2
48313: ST_TO_ADDR
// tmp := ReplaceWith ( tmp , pos , tmp ) ;
48314: LD_ADDR_VAR 0 7
48318: PUSH
48319: LD_VAR 0 7
48323: PPUSH
48324: LD_VAR 0 6
48328: PPUSH
48329: LD_VAR 0 7
48333: PPUSH
48334: CALL 57729 0 3
48338: ST_TO_ADDR
// mc_build_list := Replace ( mc_build_list , i , tmp ) ;
48339: LD_ADDR_EXP 79
48343: PUSH
48344: LD_EXP 79
48348: PPUSH
48349: LD_VAR 0 3
48353: PPUSH
48354: LD_VAR 0 7
48358: PPUSH
48359: CALL_OW 1
48363: ST_TO_ADDR
// end ; end ; if un in mc_bases [ i ] then
48364: LD_VAR 0 1
48368: PUSH
48369: LD_EXP 74
48373: PUSH
48374: LD_VAR 0 3
48378: ARRAY
48379: IN
48380: IFFALSE 48419
// begin mc_bases := Replace ( mc_bases , i , mc_bases [ i ] diff un ) ;
48382: LD_ADDR_EXP 74
48386: PUSH
48387: LD_EXP 74
48391: PPUSH
48392: LD_VAR 0 3
48396: PPUSH
48397: LD_EXP 74
48401: PUSH
48402: LD_VAR 0 3
48406: ARRAY
48407: PUSH
48408: LD_VAR 0 1
48412: DIFF
48413: PPUSH
48414: CALL_OW 1
48418: ST_TO_ADDR
// end ; if un in mc_construct_list [ i ] then
48419: LD_VAR 0 1
48423: PUSH
48424: LD_EXP 81
48428: PUSH
48429: LD_VAR 0 3
48433: ARRAY
48434: IN
48435: IFFALSE 48474
// begin mc_construct_list := Replace ( mc_construct_list , i , mc_construct_list [ i ] diff un ) ;
48437: LD_ADDR_EXP 81
48441: PUSH
48442: LD_EXP 81
48446: PPUSH
48447: LD_VAR 0 3
48451: PPUSH
48452: LD_EXP 81
48456: PUSH
48457: LD_VAR 0 3
48461: ARRAY
48462: PUSH
48463: LD_VAR 0 1
48467: DIFF
48468: PPUSH
48469: CALL_OW 1
48473: ST_TO_ADDR
// end ; if un in mc_vehicles [ i ] then
48474: LD_VAR 0 1
48478: PUSH
48479: LD_EXP 93
48483: PUSH
48484: LD_VAR 0 3
48488: ARRAY
48489: IN
48490: IFFALSE 48529
// begin mc_vehicles := Replace ( mc_vehicles , i , mc_vehicles [ i ] diff un ) ;
48492: LD_ADDR_EXP 93
48496: PUSH
48497: LD_EXP 93
48501: PPUSH
48502: LD_VAR 0 3
48506: PPUSH
48507: LD_EXP 93
48511: PUSH
48512: LD_VAR 0 3
48516: ARRAY
48517: PUSH
48518: LD_VAR 0 1
48522: DIFF
48523: PPUSH
48524: CALL_OW 1
48528: ST_TO_ADDR
// end ; if un in mc_defender [ i ] then
48529: LD_VAR 0 1
48533: PUSH
48534: LD_EXP 96
48538: PUSH
48539: LD_VAR 0 3
48543: ARRAY
48544: IN
48545: IFFALSE 48584
// begin mc_defender := Replace ( mc_defender , i , mc_defender [ i ] diff un ) ;
48547: LD_ADDR_EXP 96
48551: PUSH
48552: LD_EXP 96
48556: PPUSH
48557: LD_VAR 0 3
48561: PPUSH
48562: LD_EXP 96
48566: PUSH
48567: LD_VAR 0 3
48571: ARRAY
48572: PUSH
48573: LD_VAR 0 1
48577: DIFF
48578: PPUSH
48579: CALL_OW 1
48583: ST_TO_ADDR
// end ; if un in mc_empty_turret_list [ i ] then
48584: LD_VAR 0 1
48588: PUSH
48589: LD_EXP 83
48593: PUSH
48594: LD_VAR 0 3
48598: ARRAY
48599: IN
48600: IFFALSE 48639
// begin mc_empty_turret_list := Replace ( mc_empty_turret_list , i , mc_empty_turret_list [ i ] diff un ) ;
48602: LD_ADDR_EXP 83
48606: PUSH
48607: LD_EXP 83
48611: PPUSH
48612: LD_VAR 0 3
48616: PPUSH
48617: LD_EXP 83
48621: PUSH
48622: LD_VAR 0 3
48626: ARRAY
48627: PUSH
48628: LD_VAR 0 1
48632: DIFF
48633: PPUSH
48634: CALL_OW 1
48638: ST_TO_ADDR
// end ; if un in mc_turret_list [ i ] then
48639: LD_VAR 0 1
48643: PUSH
48644: LD_EXP 82
48648: PUSH
48649: LD_VAR 0 3
48653: ARRAY
48654: IN
48655: IFFALSE 48694
// begin mc_turret_list := Replace ( mc_turret_list , i , mc_turret_list [ i ] diff un ) ;
48657: LD_ADDR_EXP 82
48661: PUSH
48662: LD_EXP 82
48666: PPUSH
48667: LD_VAR 0 3
48671: PPUSH
48672: LD_EXP 82
48676: PUSH
48677: LD_VAR 0 3
48681: ARRAY
48682: PUSH
48683: LD_VAR 0 1
48687: DIFF
48688: PPUSH
48689: CALL_OW 1
48693: ST_TO_ADDR
// end ; break ;
48694: GO 48698
// end ;
48696: GO 47344
48698: POP
48699: POP
// end ;
48700: LD_VAR 0 2
48704: RET
// export function MCE_UpgradeComplete ( building ) ; var i , j ; begin
48705: LD_INT 0
48707: PPUSH
48708: PPUSH
48709: PPUSH
// if not mc_bases or not skirmish then
48710: LD_EXP 74
48714: NOT
48715: PUSH
48716: LD_EXP 72
48720: NOT
48721: OR
48722: IFFALSE 48726
// exit ;
48724: GO 48941
// for i = 1 to mc_bases do
48726: LD_ADDR_VAR 0 3
48730: PUSH
48731: DOUBLE
48732: LD_INT 1
48734: DEC
48735: ST_TO_ADDR
48736: LD_EXP 74
48740: PUSH
48741: FOR_TO
48742: IFFALSE 48939
// begin if building in mc_construct_list [ i ] then
48744: LD_VAR 0 1
48748: PUSH
48749: LD_EXP 81
48753: PUSH
48754: LD_VAR 0 3
48758: ARRAY
48759: IN
48760: IFFALSE 48937
// begin mc_construct_list := Replace ( mc_construct_list , i , mc_construct_list [ i ] diff building ) ;
48762: LD_ADDR_EXP 81
48766: PUSH
48767: LD_EXP 81
48771: PPUSH
48772: LD_VAR 0 3
48776: PPUSH
48777: LD_EXP 81
48781: PUSH
48782: LD_VAR 0 3
48786: ARRAY
48787: PUSH
48788: LD_VAR 0 1
48792: DIFF
48793: PPUSH
48794: CALL_OW 1
48798: ST_TO_ADDR
// if building in mc_lab [ i ] then
48799: LD_VAR 0 1
48803: PUSH
48804: LD_EXP 107
48808: PUSH
48809: LD_VAR 0 3
48813: ARRAY
48814: IN
48815: IFFALSE 48870
// mc_lab_upgrade := Replace ( mc_lab_upgrade , i , Reindex ( mc_lab_upgrade [ i ] , 1 , mc_lab_upgrade [ i ] , false ) ) ;
48817: LD_ADDR_EXP 108
48821: PUSH
48822: LD_EXP 108
48826: PPUSH
48827: LD_VAR 0 3
48831: PPUSH
48832: LD_EXP 108
48836: PUSH
48837: LD_VAR 0 3
48841: ARRAY
48842: PPUSH
48843: LD_INT 1
48845: PPUSH
48846: LD_EXP 108
48850: PUSH
48851: LD_VAR 0 3
48855: ARRAY
48856: PPUSH
48857: LD_INT 0
48859: PPUSH
48860: CALL 56821 0 4
48864: PPUSH
48865: CALL_OW 1
48869: ST_TO_ADDR
// if not building in mc_bases [ i ] then
48870: LD_VAR 0 1
48874: PUSH
48875: LD_EXP 74
48879: PUSH
48880: LD_VAR 0 3
48884: ARRAY
48885: IN
48886: NOT
48887: IFFALSE 48933
// mc_bases := ReplaceIn ( mc_bases , [ i , mc_bases [ i ] + 1 ] , building ) ;
48889: LD_ADDR_EXP 74
48893: PUSH
48894: LD_EXP 74
48898: PPUSH
48899: LD_VAR 0 3
48903: PUSH
48904: LD_EXP 74
48908: PUSH
48909: LD_VAR 0 3
48913: ARRAY
48914: PUSH
48915: LD_INT 1
48917: PLUS
48918: PUSH
48919: EMPTY
48920: LIST
48921: LIST
48922: PPUSH
48923: LD_VAR 0 1
48927: PPUSH
48928: CALL 57403 0 3
48932: ST_TO_ADDR
// exit ;
48933: POP
48934: POP
48935: GO 48941
// end ; end ;
48937: GO 48741
48939: POP
48940: POP
// end ;
48941: LD_VAR 0 2
48945: RET
// export function MCE_BuildingComplete ( building ) ; var i , j , btype , tmp , units , side ; begin
48946: LD_INT 0
48948: PPUSH
48949: PPUSH
48950: PPUSH
48951: PPUSH
48952: PPUSH
48953: PPUSH
48954: PPUSH
// if not mc_bases or not skirmish then
48955: LD_EXP 74
48959: NOT
48960: PUSH
48961: LD_EXP 72
48965: NOT
48966: OR
48967: IFFALSE 48971
// exit ;
48969: GO 49632
// for i = 1 to mc_bases do
48971: LD_ADDR_VAR 0 3
48975: PUSH
48976: DOUBLE
48977: LD_INT 1
48979: DEC
48980: ST_TO_ADDR
48981: LD_EXP 74
48985: PUSH
48986: FOR_TO
48987: IFFALSE 49630
// begin if building in mc_construct_list [ i ] then
48989: LD_VAR 0 1
48993: PUSH
48994: LD_EXP 81
48998: PUSH
48999: LD_VAR 0 3
49003: ARRAY
49004: IN
49005: IFFALSE 49628
// begin mc_construct_list := Replace ( mc_construct_list , i , mc_construct_list [ i ] diff building ) ;
49007: LD_ADDR_EXP 81
49011: PUSH
49012: LD_EXP 81
49016: PPUSH
49017: LD_VAR 0 3
49021: PPUSH
49022: LD_EXP 81
49026: PUSH
49027: LD_VAR 0 3
49031: ARRAY
49032: PUSH
49033: LD_VAR 0 1
49037: DIFF
49038: PPUSH
49039: CALL_OW 1
49043: ST_TO_ADDR
// mc_bases := ReplaceIn ( mc_bases , [ i , mc_bases [ i ] + 1 ] , building ) ;
49044: LD_ADDR_EXP 74
49048: PUSH
49049: LD_EXP 74
49053: PPUSH
49054: LD_VAR 0 3
49058: PUSH
49059: LD_EXP 74
49063: PUSH
49064: LD_VAR 0 3
49068: ARRAY
49069: PUSH
49070: LD_INT 1
49072: PLUS
49073: PUSH
49074: EMPTY
49075: LIST
49076: LIST
49077: PPUSH
49078: LD_VAR 0 1
49082: PPUSH
49083: CALL 57403 0 3
49087: ST_TO_ADDR
// btype := GetBType ( building ) ;
49088: LD_ADDR_VAR 0 5
49092: PUSH
49093: LD_VAR 0 1
49097: PPUSH
49098: CALL_OW 266
49102: ST_TO_ADDR
// side := GetSide ( building ) ;
49103: LD_ADDR_VAR 0 8
49107: PUSH
49108: LD_VAR 0 1
49112: PPUSH
49113: CALL_OW 255
49117: ST_TO_ADDR
// if btype = b_lab then
49118: LD_VAR 0 5
49122: PUSH
49123: LD_INT 6
49125: EQUAL
49126: IFFALSE 49176
// begin mc_lab := ReplaceIn ( mc_lab , [ i , mc_lab [ i ] + 1 ] , building ) ;
49128: LD_ADDR_EXP 107
49132: PUSH
49133: LD_EXP 107
49137: PPUSH
49138: LD_VAR 0 3
49142: PUSH
49143: LD_EXP 107
49147: PUSH
49148: LD_VAR 0 3
49152: ARRAY
49153: PUSH
49154: LD_INT 1
49156: PLUS
49157: PUSH
49158: EMPTY
49159: LIST
49160: LIST
49161: PPUSH
49162: LD_VAR 0 1
49166: PPUSH
49167: CALL 57403 0 3
49171: ST_TO_ADDR
// exit ;
49172: POP
49173: POP
49174: GO 49632
// end ; if btype in [ b_depot , b_workshop , b_armoury ] then
49176: LD_VAR 0 5
49180: PUSH
49181: LD_INT 0
49183: PUSH
49184: LD_INT 2
49186: PUSH
49187: LD_INT 4
49189: PUSH
49190: EMPTY
49191: LIST
49192: LIST
49193: LIST
49194: IN
49195: IFFALSE 49319
// begin if btype = b_armoury then
49197: LD_VAR 0 5
49201: PUSH
49202: LD_INT 4
49204: EQUAL
49205: IFFALSE 49215
// btype := b_barracks ;
49207: LD_ADDR_VAR 0 5
49211: PUSH
49212: LD_INT 5
49214: ST_TO_ADDR
// if btype = b_depot then
49215: LD_VAR 0 5
49219: PUSH
49220: LD_INT 0
49222: EQUAL
49223: IFFALSE 49233
// btype := b_warehouse ;
49225: LD_ADDR_VAR 0 5
49229: PUSH
49230: LD_INT 1
49232: ST_TO_ADDR
// if btype = b_workshop then
49233: LD_VAR 0 5
49237: PUSH
49238: LD_INT 2
49240: EQUAL
49241: IFFALSE 49251
// btype := b_factory ;
49243: LD_ADDR_VAR 0 5
49247: PUSH
49248: LD_INT 3
49250: ST_TO_ADDR
// if GetRestrict ( btype , side ) = state_enabled then
49251: LD_VAR 0 5
49255: PPUSH
49256: LD_VAR 0 8
49260: PPUSH
49261: CALL_OW 323
49265: PUSH
49266: LD_INT 1
49268: EQUAL
49269: IFFALSE 49315
// mc_build_upgrade := ReplaceIn ( mc_build_upgrade , [ i , mc_build_upgrade [ i ] + 1 ] , building ) ;
49271: LD_ADDR_EXP 106
49275: PUSH
49276: LD_EXP 106
49280: PPUSH
49281: LD_VAR 0 3
49285: PUSH
49286: LD_EXP 106
49290: PUSH
49291: LD_VAR 0 3
49295: ARRAY
49296: PUSH
49297: LD_INT 1
49299: PLUS
49300: PUSH
49301: EMPTY
49302: LIST
49303: LIST
49304: PPUSH
49305: LD_VAR 0 1
49309: PPUSH
49310: CALL 57403 0 3
49314: ST_TO_ADDR
// exit ;
49315: POP
49316: POP
49317: GO 49632
// end ; if btype in [ b_bunker , b_turret ] then
49319: LD_VAR 0 5
49323: PUSH
49324: LD_INT 32
49326: PUSH
49327: LD_INT 33
49329: PUSH
49330: EMPTY
49331: LIST
49332: LIST
49333: IN
49334: IFFALSE 49624
// begin mc_turret_list := ReplaceIn ( mc_turret_list , [ i , mc_turret_list [ i ] + 1 ] , building ) ;
49336: LD_ADDR_EXP 82
49340: PUSH
49341: LD_EXP 82
49345: PPUSH
49346: LD_VAR 0 3
49350: PUSH
49351: LD_EXP 82
49355: PUSH
49356: LD_VAR 0 3
49360: ARRAY
49361: PUSH
49362: LD_INT 1
49364: PLUS
49365: PUSH
49366: EMPTY
49367: LIST
49368: LIST
49369: PPUSH
49370: LD_VAR 0 1
49374: PPUSH
49375: CALL 57403 0 3
49379: ST_TO_ADDR
// if btype = b_bunker then
49380: LD_VAR 0 5
49384: PUSH
49385: LD_INT 32
49387: EQUAL
49388: IFFALSE 49624
// begin mc_empty_turret_list := ReplaceIn ( mc_empty_turret_list , [ i , mc_empty_turret_list [ i ] + 1 ] , building ) ;
49390: LD_ADDR_EXP 83
49394: PUSH
49395: LD_EXP 83
49399: PPUSH
49400: LD_VAR 0 3
49404: PUSH
49405: LD_EXP 83
49409: PUSH
49410: LD_VAR 0 3
49414: ARRAY
49415: PUSH
49416: LD_INT 1
49418: PLUS
49419: PUSH
49420: EMPTY
49421: LIST
49422: LIST
49423: PPUSH
49424: LD_VAR 0 1
49428: PPUSH
49429: CALL 57403 0 3
49433: ST_TO_ADDR
// tmp := UnitFilter ( mc_bases [ i ] , [ [ f_class , 1 ] , [ f_not , [ f_inside ] ] ] ) ;
49434: LD_ADDR_VAR 0 6
49438: PUSH
49439: LD_EXP 74
49443: PUSH
49444: LD_VAR 0 3
49448: ARRAY
49449: PPUSH
49450: LD_INT 25
49452: PUSH
49453: LD_INT 1
49455: PUSH
49456: EMPTY
49457: LIST
49458: LIST
49459: PUSH
49460: LD_INT 3
49462: PUSH
49463: LD_INT 54
49465: PUSH
49466: EMPTY
49467: LIST
49468: PUSH
49469: EMPTY
49470: LIST
49471: LIST
49472: PUSH
49473: EMPTY
49474: LIST
49475: LIST
49476: PPUSH
49477: CALL_OW 72
49481: ST_TO_ADDR
// if tmp then
49482: LD_VAR 0 6
49486: IFFALSE 49492
// exit ;
49488: POP
49489: POP
49490: GO 49632
// tmp := UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_armoury ] , [ f_btype , b_barracks ] ] ) ;
49492: LD_ADDR_VAR 0 6
49496: PUSH
49497: LD_EXP 74
49501: PUSH
49502: LD_VAR 0 3
49506: ARRAY
49507: PPUSH
49508: LD_INT 2
49510: PUSH
49511: LD_INT 30
49513: PUSH
49514: LD_INT 4
49516: PUSH
49517: EMPTY
49518: LIST
49519: LIST
49520: PUSH
49521: LD_INT 30
49523: PUSH
49524: LD_INT 5
49526: PUSH
49527: EMPTY
49528: LIST
49529: LIST
49530: PUSH
49531: EMPTY
49532: LIST
49533: LIST
49534: LIST
49535: PPUSH
49536: CALL_OW 72
49540: ST_TO_ADDR
// if not tmp then
49541: LD_VAR 0 6
49545: NOT
49546: IFFALSE 49552
// exit ;
49548: POP
49549: POP
49550: GO 49632
// for j in tmp do
49552: LD_ADDR_VAR 0 4
49556: PUSH
49557: LD_VAR 0 6
49561: PUSH
49562: FOR_IN
49563: IFFALSE 49622
// begin units := UnitFilter ( UnitsInside ( j ) , [ f_class , 1 ] ) ;
49565: LD_ADDR_VAR 0 7
49569: PUSH
49570: LD_VAR 0 4
49574: PPUSH
49575: CALL_OW 313
49579: PPUSH
49580: LD_INT 25
49582: PUSH
49583: LD_INT 1
49585: PUSH
49586: EMPTY
49587: LIST
49588: LIST
49589: PPUSH
49590: CALL_OW 72
49594: ST_TO_ADDR
// if units then
49595: LD_VAR 0 7
49599: IFFALSE 49620
// begin ComExitBuilding ( units [ 1 ] ) ;
49601: LD_VAR 0 7
49605: PUSH
49606: LD_INT 1
49608: ARRAY
49609: PPUSH
49610: CALL_OW 122
// exit ;
49614: POP
49615: POP
49616: POP
49617: POP
49618: GO 49632
// end ; end ;
49620: GO 49562
49622: POP
49623: POP
// end ; end ; exit ;
49624: POP
49625: POP
49626: GO 49632
// end ; end ;
49628: GO 48986
49630: POP
49631: POP
// end ;
49632: LD_VAR 0 2
49636: RET
// export function MCE_BuildingStarted ( building , builder ) ; var i , j , btype , x , y , d ; begin
49637: LD_INT 0
49639: PPUSH
49640: PPUSH
49641: PPUSH
49642: PPUSH
49643: PPUSH
49644: PPUSH
49645: PPUSH
// if not mc_bases or not skirmish then
49646: LD_EXP 74
49650: NOT
49651: PUSH
49652: LD_EXP 72
49656: NOT
49657: OR
49658: IFFALSE 49662
// exit ;
49660: GO 49893
// btype := GetBType ( building ) ;
49662: LD_ADDR_VAR 0 6
49666: PUSH
49667: LD_VAR 0 1
49671: PPUSH
49672: CALL_OW 266
49676: ST_TO_ADDR
// x := GetX ( building ) ;
49677: LD_ADDR_VAR 0 7
49681: PUSH
49682: LD_VAR 0 1
49686: PPUSH
49687: CALL_OW 250
49691: ST_TO_ADDR
// y := GetY ( building ) ;
49692: LD_ADDR_VAR 0 8
49696: PUSH
49697: LD_VAR 0 1
49701: PPUSH
49702: CALL_OW 251
49706: ST_TO_ADDR
// d := GetDir ( building ) ;
49707: LD_ADDR_VAR 0 9
49711: PUSH
49712: LD_VAR 0 1
49716: PPUSH
49717: CALL_OW 254
49721: ST_TO_ADDR
// for i = 1 to mc_bases do
49722: LD_ADDR_VAR 0 4
49726: PUSH
49727: DOUBLE
49728: LD_INT 1
49730: DEC
49731: ST_TO_ADDR
49732: LD_EXP 74
49736: PUSH
49737: FOR_TO
49738: IFFALSE 49891
// begin if not mc_build_list [ i ] then
49740: LD_EXP 79
49744: PUSH
49745: LD_VAR 0 4
49749: ARRAY
49750: NOT
49751: IFFALSE 49755
// continue ;
49753: GO 49737
// if CompareArray ( [ btype , x , y , d ] , mc_build_list [ i ] [ 1 ] ) then
49755: LD_VAR 0 6
49759: PUSH
49760: LD_VAR 0 7
49764: PUSH
49765: LD_VAR 0 8
49769: PUSH
49770: LD_VAR 0 9
49774: PUSH
49775: EMPTY
49776: LIST
49777: LIST
49778: LIST
49779: LIST
49780: PPUSH
49781: LD_EXP 79
49785: PUSH
49786: LD_VAR 0 4
49790: ARRAY
49791: PUSH
49792: LD_INT 1
49794: ARRAY
49795: PPUSH
49796: CALL 63572 0 2
49800: IFFALSE 49889
// begin mc_build_list := Replace ( mc_build_list , i , Delete ( mc_build_list [ i ] , 1 ) ) ;
49802: LD_ADDR_EXP 79
49806: PUSH
49807: LD_EXP 79
49811: PPUSH
49812: LD_VAR 0 4
49816: PPUSH
49817: LD_EXP 79
49821: PUSH
49822: LD_VAR 0 4
49826: ARRAY
49827: PPUSH
49828: LD_INT 1
49830: PPUSH
49831: CALL_OW 3
49835: PPUSH
49836: CALL_OW 1
49840: ST_TO_ADDR
// mc_construct_list := ReplaceIn ( mc_construct_list , [ i , mc_construct_list [ i ] + 1 ] , building ) ;
49841: LD_ADDR_EXP 81
49845: PUSH
49846: LD_EXP 81
49850: PPUSH
49851: LD_VAR 0 4
49855: PUSH
49856: LD_EXP 81
49860: PUSH
49861: LD_VAR 0 4
49865: ARRAY
49866: PUSH
49867: LD_INT 1
49869: PLUS
49870: PUSH
49871: EMPTY
49872: LIST
49873: LIST
49874: PPUSH
49875: LD_VAR 0 1
49879: PPUSH
49880: CALL 57403 0 3
49884: ST_TO_ADDR
// exit ;
49885: POP
49886: POP
49887: GO 49893
// end ; end ;
49889: GO 49737
49891: POP
49892: POP
// end ;
49893: LD_VAR 0 3
49897: RET
// export function MCE_LeaveBuilding ( building , unit ) ; var i , tmp ; begin
49898: LD_INT 0
49900: PPUSH
49901: PPUSH
49902: PPUSH
// if not mc_bases or not skirmish then
49903: LD_EXP 74
49907: NOT
49908: PUSH
49909: LD_EXP 72
49913: NOT
49914: OR
49915: IFFALSE 49919
// exit ;
49917: GO 50109
// for i = 1 to mc_bases do
49919: LD_ADDR_VAR 0 4
49923: PUSH
49924: DOUBLE
49925: LD_INT 1
49927: DEC
49928: ST_TO_ADDR
49929: LD_EXP 74
49933: PUSH
49934: FOR_TO
49935: IFFALSE 50022
// begin if building in mc_turret_list [ i ] and not building in mc_empty_turret_list [ i ] then
49937: LD_VAR 0 1
49941: PUSH
49942: LD_EXP 82
49946: PUSH
49947: LD_VAR 0 4
49951: ARRAY
49952: IN
49953: PUSH
49954: LD_VAR 0 1
49958: PUSH
49959: LD_EXP 83
49963: PUSH
49964: LD_VAR 0 4
49968: ARRAY
49969: IN
49970: NOT
49971: AND
49972: IFFALSE 50020
// begin mc_empty_turret_list := ReplaceIn ( mc_empty_turret_list , [ i , mc_empty_turret_list [ i ] + 1 ] , building ) ;
49974: LD_ADDR_EXP 83
49978: PUSH
49979: LD_EXP 83
49983: PPUSH
49984: LD_VAR 0 4
49988: PUSH
49989: LD_EXP 83
49993: PUSH
49994: LD_VAR 0 4
49998: ARRAY
49999: PUSH
50000: LD_INT 1
50002: PLUS
50003: PUSH
50004: EMPTY
50005: LIST
50006: LIST
50007: PPUSH
50008: LD_VAR 0 1
50012: PPUSH
50013: CALL 57403 0 3
50017: ST_TO_ADDR
// break ;
50018: GO 50022
// end ; end ;
50020: GO 49934
50022: POP
50023: POP
// if GetClass ( building ) in mc_sides and GetBType ( building ) = b_barracks and GetTag ( unit ) <> 18 then
50024: LD_VAR 0 1
50028: PPUSH
50029: CALL_OW 257
50033: PUSH
50034: LD_EXP 100
50038: IN
50039: PUSH
50040: LD_VAR 0 1
50044: PPUSH
50045: CALL_OW 266
50049: PUSH
50050: LD_INT 5
50052: EQUAL
50053: AND
50054: PUSH
50055: LD_VAR 0 2
50059: PPUSH
50060: CALL_OW 110
50064: PUSH
50065: LD_INT 18
50067: NONEQUAL
50068: AND
50069: IFFALSE 50109
// if GetClass ( unit ) in [ 5 , 8 , 9 ] then
50071: LD_VAR 0 2
50075: PPUSH
50076: CALL_OW 257
50080: PUSH
50081: LD_INT 5
50083: PUSH
50084: LD_INT 8
50086: PUSH
50087: LD_INT 9
50089: PUSH
50090: EMPTY
50091: LIST
50092: LIST
50093: LIST
50094: IN
50095: IFFALSE 50109
// SetClass ( unit , 1 ) ;
50097: LD_VAR 0 2
50101: PPUSH
50102: LD_INT 1
50104: PPUSH
50105: CALL_OW 336
// end ;
50109: LD_VAR 0 3
50113: RET
// export function MCE_EvacuateVehicle ( driver , abandoned_vehicle , unknown1 , unknown2 ) ; var i ; begin
50114: LD_INT 0
50116: PPUSH
50117: PPUSH
// if not mc_bases or not skirmish then
50118: LD_EXP 74
50122: NOT
50123: PUSH
50124: LD_EXP 72
50128: NOT
50129: OR
50130: IFFALSE 50134
// exit ;
50132: GO 50250
// if GetLives ( abandoned_vehicle ) > 250 then
50134: LD_VAR 0 2
50138: PPUSH
50139: CALL_OW 256
50143: PUSH
50144: LD_INT 250
50146: GREATER
50147: IFFALSE 50151
// exit ;
50149: GO 50250
// for i = 1 to mc_bases do
50151: LD_ADDR_VAR 0 6
50155: PUSH
50156: DOUBLE
50157: LD_INT 1
50159: DEC
50160: ST_TO_ADDR
50161: LD_EXP 74
50165: PUSH
50166: FOR_TO
50167: IFFALSE 50248
// begin if driver in mc_bases [ i ] then
50169: LD_VAR 0 1
50173: PUSH
50174: LD_EXP 74
50178: PUSH
50179: LD_VAR 0 6
50183: ARRAY
50184: IN
50185: IFFALSE 50246
// begin ComMoveUnit ( driver , UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) [ 1 ] ) ;
50187: LD_VAR 0 1
50191: PPUSH
50192: LD_EXP 74
50196: PUSH
50197: LD_VAR 0 6
50201: ARRAY
50202: PPUSH
50203: LD_INT 2
50205: PUSH
50206: LD_INT 30
50208: PUSH
50209: LD_INT 0
50211: PUSH
50212: EMPTY
50213: LIST
50214: LIST
50215: PUSH
50216: LD_INT 30
50218: PUSH
50219: LD_INT 1
50221: PUSH
50222: EMPTY
50223: LIST
50224: LIST
50225: PUSH
50226: EMPTY
50227: LIST
50228: LIST
50229: LIST
50230: PPUSH
50231: CALL_OW 72
50235: PUSH
50236: LD_INT 1
50238: ARRAY
50239: PPUSH
50240: CALL_OW 112
// break ;
50244: GO 50248
// end ; end ;
50246: GO 50166
50248: POP
50249: POP
// end ; end_of_file
50250: LD_VAR 0 5
50254: RET
// export function PrepareUnit ( ident , exist_mode , prefix ) ; var unit ; begin
50255: LD_INT 0
50257: PPUSH
50258: PPUSH
// if exist_mode then
50259: LD_VAR 0 2
50263: IFFALSE 50288
// unit := CreateCharacter ( prefix & ident ) else
50265: LD_ADDR_VAR 0 5
50269: PUSH
50270: LD_VAR 0 3
50274: PUSH
50275: LD_VAR 0 1
50279: STR
50280: PPUSH
50281: CALL_OW 34
50285: ST_TO_ADDR
50286: GO 50303
// unit := NewCharacter ( ident ) ;
50288: LD_ADDR_VAR 0 5
50292: PUSH
50293: LD_VAR 0 1
50297: PPUSH
50298: CALL_OW 25
50302: ST_TO_ADDR
// result := unit ;
50303: LD_ADDR_VAR 0 4
50307: PUSH
50308: LD_VAR 0 5
50312: ST_TO_ADDR
// end ;
50313: LD_VAR 0 4
50317: RET
// export function GetTechNation ( side , nation , state ) ; var i ; begin
50318: LD_INT 0
50320: PPUSH
50321: PPUSH
// if not side or not nation then
50322: LD_VAR 0 1
50326: NOT
50327: PUSH
50328: LD_VAR 0 2
50332: NOT
50333: OR
50334: IFFALSE 50338
// exit ;
50336: GO 50982
// case nation of nation_american :
50338: LD_VAR 0 2
50342: PUSH
50343: LD_INT 1
50345: DOUBLE
50346: EQUAL
50347: IFTRUE 50351
50349: GO 50525
50351: POP
// result := [ 35 , 45 , 46 , 47 , 1 , 2 , 6 , 15 , 16 , 7 , 12 , 13 , 10 , 14 , 20 , 21 , 22 , 25 , 32 , 27 , 36 , 69 , 39 , 34 , 40 , 48 , 49 , 50 , 51 , 52 , 53 , 54 , 55 , 56 , 57 , 58 , 59 , 60 , 61 , 62 , 80 ] ; nation_arabian :
50352: LD_ADDR_VAR 0 4
50356: PUSH
50357: LD_INT 35
50359: PUSH
50360: LD_INT 45
50362: PUSH
50363: LD_INT 46
50365: PUSH
50366: LD_INT 47
50368: PUSH
50369: LD_INT 1
50371: PUSH
50372: LD_INT 2
50374: PUSH
50375: LD_INT 6
50377: PUSH
50378: LD_INT 15
50380: PUSH
50381: LD_INT 16
50383: PUSH
50384: LD_INT 7
50386: PUSH
50387: LD_INT 12
50389: PUSH
50390: LD_INT 13
50392: PUSH
50393: LD_INT 10
50395: PUSH
50396: LD_INT 14
50398: PUSH
50399: LD_INT 20
50401: PUSH
50402: LD_INT 21
50404: PUSH
50405: LD_INT 22
50407: PUSH
50408: LD_INT 25
50410: PUSH
50411: LD_INT 32
50413: PUSH
50414: LD_INT 27
50416: PUSH
50417: LD_INT 36
50419: PUSH
50420: LD_INT 69
50422: PUSH
50423: LD_INT 39
50425: PUSH
50426: LD_INT 34
50428: PUSH
50429: LD_INT 40
50431: PUSH
50432: LD_INT 48
50434: PUSH
50435: LD_INT 49
50437: PUSH
50438: LD_INT 50
50440: PUSH
50441: LD_INT 51
50443: PUSH
50444: LD_INT 52
50446: PUSH
50447: LD_INT 53
50449: PUSH
50450: LD_INT 54
50452: PUSH
50453: LD_INT 55
50455: PUSH
50456: LD_INT 56
50458: PUSH
50459: LD_INT 57
50461: PUSH
50462: LD_INT 58
50464: PUSH
50465: LD_INT 59
50467: PUSH
50468: LD_INT 60
50470: PUSH
50471: LD_INT 61
50473: PUSH
50474: LD_INT 62
50476: PUSH
50477: LD_INT 80
50479: PUSH
50480: EMPTY
50481: LIST
50482: LIST
50483: LIST
50484: LIST
50485: LIST
50486: LIST
50487: LIST
50488: LIST
50489: LIST
50490: LIST
50491: LIST
50492: LIST
50493: LIST
50494: LIST
50495: LIST
50496: LIST
50497: LIST
50498: LIST
50499: LIST
50500: LIST
50501: LIST
50502: LIST
50503: LIST
50504: LIST
50505: LIST
50506: LIST
50507: LIST
50508: LIST
50509: LIST
50510: LIST
50511: LIST
50512: LIST
50513: LIST
50514: LIST
50515: LIST
50516: LIST
50517: LIST
50518: LIST
50519: LIST
50520: LIST
50521: LIST
50522: ST_TO_ADDR
50523: GO 50906
50525: LD_INT 2
50527: DOUBLE
50528: EQUAL
50529: IFTRUE 50533
50531: GO 50715
50533: POP
// result := [ 35 , 45 , 46 , 47 , 70 , 1 , 11 , 3 , 4 , 5 , 6 , 15 , 18 , 7 , 17 , 8 , 20 , 21 , 22 , 72 , 26 , 69 , 39 , 40 , 41 , 42 , 43 , 48 , 49 , 50 , 51 , 52 , 53 , 54 , 55 , 56 , 60 , 61 , 62 , 66 , 67 , 68 , 81 ] ; nation_russian :
50534: LD_ADDR_VAR 0 4
50538: PUSH
50539: LD_INT 35
50541: PUSH
50542: LD_INT 45
50544: PUSH
50545: LD_INT 46
50547: PUSH
50548: LD_INT 47
50550: PUSH
50551: LD_INT 70
50553: PUSH
50554: LD_INT 1
50556: PUSH
50557: LD_INT 11
50559: PUSH
50560: LD_INT 3
50562: PUSH
50563: LD_INT 4
50565: PUSH
50566: LD_INT 5
50568: PUSH
50569: LD_INT 6
50571: PUSH
50572: LD_INT 15
50574: PUSH
50575: LD_INT 18
50577: PUSH
50578: LD_INT 7
50580: PUSH
50581: LD_INT 17
50583: PUSH
50584: LD_INT 8
50586: PUSH
50587: LD_INT 20
50589: PUSH
50590: LD_INT 21
50592: PUSH
50593: LD_INT 22
50595: PUSH
50596: LD_INT 72
50598: PUSH
50599: LD_INT 26
50601: PUSH
50602: LD_INT 69
50604: PUSH
50605: LD_INT 39
50607: PUSH
50608: LD_INT 40
50610: PUSH
50611: LD_INT 41
50613: PUSH
50614: LD_INT 42
50616: PUSH
50617: LD_INT 43
50619: PUSH
50620: LD_INT 48
50622: PUSH
50623: LD_INT 49
50625: PUSH
50626: LD_INT 50
50628: PUSH
50629: LD_INT 51
50631: PUSH
50632: LD_INT 52
50634: PUSH
50635: LD_INT 53
50637: PUSH
50638: LD_INT 54
50640: PUSH
50641: LD_INT 55
50643: PUSH
50644: LD_INT 56
50646: PUSH
50647: LD_INT 60
50649: PUSH
50650: LD_INT 61
50652: PUSH
50653: LD_INT 62
50655: PUSH
50656: LD_INT 66
50658: PUSH
50659: LD_INT 67
50661: PUSH
50662: LD_INT 68
50664: PUSH
50665: LD_INT 81
50667: PUSH
50668: EMPTY
50669: LIST
50670: LIST
50671: LIST
50672: LIST
50673: LIST
50674: LIST
50675: LIST
50676: LIST
50677: LIST
50678: LIST
50679: LIST
50680: LIST
50681: LIST
50682: LIST
50683: LIST
50684: LIST
50685: LIST
50686: LIST
50687: LIST
50688: LIST
50689: LIST
50690: LIST
50691: LIST
50692: LIST
50693: LIST
50694: LIST
50695: LIST
50696: LIST
50697: LIST
50698: LIST
50699: LIST
50700: LIST
50701: LIST
50702: LIST
50703: LIST
50704: LIST
50705: LIST
50706: LIST
50707: LIST
50708: LIST
50709: LIST
50710: LIST
50711: LIST
50712: ST_TO_ADDR
50713: GO 50906
50715: LD_INT 3
50717: DOUBLE
50718: EQUAL
50719: IFTRUE 50723
50721: GO 50905
50723: POP
// result := [ 46 , 47 , 1 , 2 , 11 , 9 , 20 , 19 , 21 , 24 , 22 , 25 , 28 , 29 , 30 , 31 , 37 , 38 , 32 , 27 , 33 , 69 , 39 , 34 , 40 , 71 , 23 , 44 , 48 , 49 , 50 , 51 , 52 , 53 , 54 , 55 , 56 , 57 , 58 , 59 , 63 , 64 , 65 ] ; end ;
50724: LD_ADDR_VAR 0 4
50728: PUSH
50729: LD_INT 46
50731: PUSH
50732: LD_INT 47
50734: PUSH
50735: LD_INT 1
50737: PUSH
50738: LD_INT 2
50740: PUSH
50741: LD_INT 11
50743: PUSH
50744: LD_INT 9
50746: PUSH
50747: LD_INT 20
50749: PUSH
50750: LD_INT 19
50752: PUSH
50753: LD_INT 21
50755: PUSH
50756: LD_INT 24
50758: PUSH
50759: LD_INT 22
50761: PUSH
50762: LD_INT 25
50764: PUSH
50765: LD_INT 28
50767: PUSH
50768: LD_INT 29
50770: PUSH
50771: LD_INT 30
50773: PUSH
50774: LD_INT 31
50776: PUSH
50777: LD_INT 37
50779: PUSH
50780: LD_INT 38
50782: PUSH
50783: LD_INT 32
50785: PUSH
50786: LD_INT 27
50788: PUSH
50789: LD_INT 33
50791: PUSH
50792: LD_INT 69
50794: PUSH
50795: LD_INT 39
50797: PUSH
50798: LD_INT 34
50800: PUSH
50801: LD_INT 40
50803: PUSH
50804: LD_INT 71
50806: PUSH
50807: LD_INT 23
50809: PUSH
50810: LD_INT 44
50812: PUSH
50813: LD_INT 48
50815: PUSH
50816: LD_INT 49
50818: PUSH
50819: LD_INT 50
50821: PUSH
50822: LD_INT 51
50824: PUSH
50825: LD_INT 52
50827: PUSH
50828: LD_INT 53
50830: PUSH
50831: LD_INT 54
50833: PUSH
50834: LD_INT 55
50836: PUSH
50837: LD_INT 56
50839: PUSH
50840: LD_INT 57
50842: PUSH
50843: LD_INT 58
50845: PUSH
50846: LD_INT 59
50848: PUSH
50849: LD_INT 63
50851: PUSH
50852: LD_INT 64
50854: PUSH
50855: LD_INT 65
50857: PUSH
50858: EMPTY
50859: LIST
50860: LIST
50861: LIST
50862: LIST
50863: LIST
50864: LIST
50865: LIST
50866: LIST
50867: LIST
50868: LIST
50869: LIST
50870: LIST
50871: LIST
50872: LIST
50873: LIST
50874: LIST
50875: LIST
50876: LIST
50877: LIST
50878: LIST
50879: LIST
50880: LIST
50881: LIST
50882: LIST
50883: LIST
50884: LIST
50885: LIST
50886: LIST
50887: LIST
50888: LIST
50889: LIST
50890: LIST
50891: LIST
50892: LIST
50893: LIST
50894: LIST
50895: LIST
50896: LIST
50897: LIST
50898: LIST
50899: LIST
50900: LIST
50901: LIST
50902: ST_TO_ADDR
50903: GO 50906
50905: POP
// if state > - 1 and state < 3 then
50906: LD_VAR 0 3
50910: PUSH
50911: LD_INT 1
50913: NEG
50914: GREATER
50915: PUSH
50916: LD_VAR 0 3
50920: PUSH
50921: LD_INT 3
50923: LESS
50924: AND
50925: IFFALSE 50982
// for i in result do
50927: LD_ADDR_VAR 0 5
50931: PUSH
50932: LD_VAR 0 4
50936: PUSH
50937: FOR_IN
50938: IFFALSE 50980
// if GetTech ( i , side ) <> state then
50940: LD_VAR 0 5
50944: PPUSH
50945: LD_VAR 0 1
50949: PPUSH
50950: CALL_OW 321
50954: PUSH
50955: LD_VAR 0 3
50959: NONEQUAL
50960: IFFALSE 50978
// result := result diff i ;
50962: LD_ADDR_VAR 0 4
50966: PUSH
50967: LD_VAR 0 4
50971: PUSH
50972: LD_VAR 0 5
50976: DIFF
50977: ST_TO_ADDR
50978: GO 50937
50980: POP
50981: POP
// end ;
50982: LD_VAR 0 4
50986: RET
// export function TechCanBeResearch ( side , tech ) ; var i , tmp ; begin
50987: LD_INT 0
50989: PPUSH
50990: PPUSH
50991: PPUSH
// result := true ;
50992: LD_ADDR_VAR 0 3
50996: PUSH
50997: LD_INT 1
50999: ST_TO_ADDR
// tmp := GetTechTechsReq ( tech ) ;
51000: LD_ADDR_VAR 0 5
51004: PUSH
51005: LD_VAR 0 2
51009: PPUSH
51010: CALL_OW 480
51014: ST_TO_ADDR
// if not tmp then
51015: LD_VAR 0 5
51019: NOT
51020: IFFALSE 51024
// exit ;
51022: GO 51073
// for i in tmp do
51024: LD_ADDR_VAR 0 4
51028: PUSH
51029: LD_VAR 0 5
51033: PUSH
51034: FOR_IN
51035: IFFALSE 51071
// if GetTech ( i , side ) <> state_researched then
51037: LD_VAR 0 4
51041: PPUSH
51042: LD_VAR 0 1
51046: PPUSH
51047: CALL_OW 321
51051: PUSH
51052: LD_INT 2
51054: NONEQUAL
51055: IFFALSE 51069
// begin result := false ;
51057: LD_ADDR_VAR 0 3
51061: PUSH
51062: LD_INT 0
51064: ST_TO_ADDR
// exit ;
51065: POP
51066: POP
51067: GO 51073
// end ;
51069: GO 51034
51071: POP
51072: POP
// end ;
51073: LD_VAR 0 3
51077: RET
// export function ComSpaceTimeShoot ( unit ) ; var i , x , y , _x , _y , tmp , side , enemy , in_unit , tech_space , tech_time , missile ; begin
51078: LD_INT 0
51080: PPUSH
51081: PPUSH
51082: PPUSH
51083: PPUSH
51084: PPUSH
51085: PPUSH
51086: PPUSH
51087: PPUSH
51088: PPUSH
51089: PPUSH
51090: PPUSH
51091: PPUSH
51092: PPUSH
// if not unit or GetClass ( unit ) <> class_bazooker then
51093: LD_VAR 0 1
51097: NOT
51098: PUSH
51099: LD_VAR 0 1
51103: PPUSH
51104: CALL_OW 257
51108: PUSH
51109: LD_INT 9
51111: NONEQUAL
51112: OR
51113: IFFALSE 51117
// exit ;
51115: GO 51690
// side := GetSide ( unit ) ;
51117: LD_ADDR_VAR 0 9
51121: PUSH
51122: LD_VAR 0 1
51126: PPUSH
51127: CALL_OW 255
51131: ST_TO_ADDR
// tech_space := tech_spacanom ;
51132: LD_ADDR_VAR 0 12
51136: PUSH
51137: LD_INT 29
51139: ST_TO_ADDR
// tech_time := tech_taurad ;
51140: LD_ADDR_VAR 0 13
51144: PUSH
51145: LD_INT 28
51147: ST_TO_ADDR
// in_unit := IsInUnit ( unit ) ;
51148: LD_ADDR_VAR 0 11
51152: PUSH
51153: LD_VAR 0 1
51157: PPUSH
51158: CALL_OW 310
51162: ST_TO_ADDR
// if GetType ( in_unit ) = unit_vehicle then
51163: LD_VAR 0 11
51167: PPUSH
51168: CALL_OW 247
51172: PUSH
51173: LD_INT 2
51175: EQUAL
51176: IFFALSE 51180
// exit ;
51178: GO 51690
// tmp := FilterAllUnits ( [ [ f_enemy , side ] , [ f_not , [ f_type , unit_building ] ] ] ) ;
51180: LD_ADDR_VAR 0 8
51184: PUSH
51185: LD_INT 81
51187: PUSH
51188: LD_VAR 0 9
51192: PUSH
51193: EMPTY
51194: LIST
51195: LIST
51196: PUSH
51197: LD_INT 3
51199: PUSH
51200: LD_INT 21
51202: PUSH
51203: LD_INT 3
51205: PUSH
51206: EMPTY
51207: LIST
51208: LIST
51209: PUSH
51210: EMPTY
51211: LIST
51212: LIST
51213: PUSH
51214: EMPTY
51215: LIST
51216: LIST
51217: PPUSH
51218: CALL_OW 69
51222: ST_TO_ADDR
// if not tmp then
51223: LD_VAR 0 8
51227: NOT
51228: IFFALSE 51232
// exit ;
51230: GO 51690
// if in_unit then
51232: LD_VAR 0 11
51236: IFFALSE 51260
// enemy := NearestUnitToUnit ( tmp , in_unit ) else
51238: LD_ADDR_VAR 0 10
51242: PUSH
51243: LD_VAR 0 8
51247: PPUSH
51248: LD_VAR 0 11
51252: PPUSH
51253: CALL_OW 74
51257: ST_TO_ADDR
51258: GO 51280
// enemy := NearestUnitToUnit ( tmp , unit ) ;
51260: LD_ADDR_VAR 0 10
51264: PUSH
51265: LD_VAR 0 8
51269: PPUSH
51270: LD_VAR 0 1
51274: PPUSH
51275: CALL_OW 74
51279: ST_TO_ADDR
// if not enemy then
51280: LD_VAR 0 10
51284: NOT
51285: IFFALSE 51289
// exit ;
51287: GO 51690
// if ( in_unit and GetDistUnits ( in_unit , enemy ) > 13 ) or GetDistUnits ( unit , enemy ) > 12 then
51289: LD_VAR 0 11
51293: PUSH
51294: LD_VAR 0 11
51298: PPUSH
51299: LD_VAR 0 10
51303: PPUSH
51304: CALL_OW 296
51308: PUSH
51309: LD_INT 13
51311: GREATER
51312: AND
51313: PUSH
51314: LD_VAR 0 1
51318: PPUSH
51319: LD_VAR 0 10
51323: PPUSH
51324: CALL_OW 296
51328: PUSH
51329: LD_INT 12
51331: GREATER
51332: OR
51333: IFFALSE 51337
// exit ;
51335: GO 51690
// missile := [ 1 ] ;
51337: LD_ADDR_VAR 0 14
51341: PUSH
51342: LD_INT 1
51344: PUSH
51345: EMPTY
51346: LIST
51347: ST_TO_ADDR
// if Researched ( side , tech_space ) then
51348: LD_VAR 0 9
51352: PPUSH
51353: LD_VAR 0 12
51357: PPUSH
51358: CALL_OW 325
51362: IFFALSE 51391
// missile := Insert ( missile , missile + 1 , 2 ) ;
51364: LD_ADDR_VAR 0 14
51368: PUSH
51369: LD_VAR 0 14
51373: PPUSH
51374: LD_VAR 0 14
51378: PUSH
51379: LD_INT 1
51381: PLUS
51382: PPUSH
51383: LD_INT 2
51385: PPUSH
51386: CALL_OW 2
51390: ST_TO_ADDR
// if Researched ( side , tech_time ) and not Researched ( GetSide ( enemy ) , tech_time ) then
51391: LD_VAR 0 9
51395: PPUSH
51396: LD_VAR 0 13
51400: PPUSH
51401: CALL_OW 325
51405: PUSH
51406: LD_VAR 0 10
51410: PPUSH
51411: CALL_OW 255
51415: PPUSH
51416: LD_VAR 0 13
51420: PPUSH
51421: CALL_OW 325
51425: NOT
51426: AND
51427: IFFALSE 51456
// missile := Insert ( missile , missile + 1 , 3 ) ;
51429: LD_ADDR_VAR 0 14
51433: PUSH
51434: LD_VAR 0 14
51438: PPUSH
51439: LD_VAR 0 14
51443: PUSH
51444: LD_INT 1
51446: PLUS
51447: PPUSH
51448: LD_INT 3
51450: PPUSH
51451: CALL_OW 2
51455: ST_TO_ADDR
// if missile < 2 then
51456: LD_VAR 0 14
51460: PUSH
51461: LD_INT 2
51463: LESS
51464: IFFALSE 51468
// exit ;
51466: GO 51690
// x := GetX ( enemy ) ;
51468: LD_ADDR_VAR 0 4
51472: PUSH
51473: LD_VAR 0 10
51477: PPUSH
51478: CALL_OW 250
51482: ST_TO_ADDR
// y := GetY ( enemy ) ;
51483: LD_ADDR_VAR 0 5
51487: PUSH
51488: LD_VAR 0 10
51492: PPUSH
51493: CALL_OW 251
51497: ST_TO_ADDR
// _x := x + rand ( - 1 , 1 ) ;
51498: LD_ADDR_VAR 0 6
51502: PUSH
51503: LD_VAR 0 4
51507: PUSH
51508: LD_INT 1
51510: NEG
51511: PPUSH
51512: LD_INT 1
51514: PPUSH
51515: CALL_OW 12
51519: PLUS
51520: ST_TO_ADDR
// _y := y + rand ( - 1 , 1 ) ;
51521: LD_ADDR_VAR 0 7
51525: PUSH
51526: LD_VAR 0 5
51530: PUSH
51531: LD_INT 1
51533: NEG
51534: PPUSH
51535: LD_INT 1
51537: PPUSH
51538: CALL_OW 12
51542: PLUS
51543: ST_TO_ADDR
// if not ValidHex ( _x , _y ) then
51544: LD_VAR 0 6
51548: PPUSH
51549: LD_VAR 0 7
51553: PPUSH
51554: CALL_OW 488
51558: NOT
51559: IFFALSE 51581
// begin _x := x ;
51561: LD_ADDR_VAR 0 6
51565: PUSH
51566: LD_VAR 0 4
51570: ST_TO_ADDR
// _y := y ;
51571: LD_ADDR_VAR 0 7
51575: PUSH
51576: LD_VAR 0 5
51580: ST_TO_ADDR
// end ; i := rand ( 1 , missile ) ;
51581: LD_ADDR_VAR 0 3
51585: PUSH
51586: LD_INT 1
51588: PPUSH
51589: LD_VAR 0 14
51593: PPUSH
51594: CALL_OW 12
51598: ST_TO_ADDR
// case i of 1 :
51599: LD_VAR 0 3
51603: PUSH
51604: LD_INT 1
51606: DOUBLE
51607: EQUAL
51608: IFTRUE 51612
51610: GO 51629
51612: POP
// ComAttackUnit ( unit , enemy ) ; 2 :
51613: LD_VAR 0 1
51617: PPUSH
51618: LD_VAR 0 10
51622: PPUSH
51623: CALL_OW 115
51627: GO 51690
51629: LD_INT 2
51631: DOUBLE
51632: EQUAL
51633: IFTRUE 51637
51635: GO 51659
51637: POP
// ComSpaceShift ( unit , _x , _y ) ; 3 :
51638: LD_VAR 0 1
51642: PPUSH
51643: LD_VAR 0 6
51647: PPUSH
51648: LD_VAR 0 7
51652: PPUSH
51653: CALL_OW 153
51657: GO 51690
51659: LD_INT 3
51661: DOUBLE
51662: EQUAL
51663: IFTRUE 51667
51665: GO 51689
51667: POP
// ComTimeShift ( unit , _x , _y ) ; end ;
51668: LD_VAR 0 1
51672: PPUSH
51673: LD_VAR 0 6
51677: PPUSH
51678: LD_VAR 0 7
51682: PPUSH
51683: CALL_OW 154
51687: GO 51690
51689: POP
// end ;
51690: LD_VAR 0 2
51694: RET
// export function ComStandNearbyBuilding ( unit , building ) ; var i , x , y , _x , _y ; begin
51695: LD_INT 0
51697: PPUSH
51698: PPUSH
51699: PPUSH
51700: PPUSH
51701: PPUSH
51702: PPUSH
// if not unit or not building then
51703: LD_VAR 0 1
51707: NOT
51708: PUSH
51709: LD_VAR 0 2
51713: NOT
51714: OR
51715: IFFALSE 51719
// exit ;
51717: GO 51877
// x := GetX ( building ) ;
51719: LD_ADDR_VAR 0 5
51723: PUSH
51724: LD_VAR 0 2
51728: PPUSH
51729: CALL_OW 250
51733: ST_TO_ADDR
// y := GetY ( building ) ;
51734: LD_ADDR_VAR 0 6
51738: PUSH
51739: LD_VAR 0 2
51743: PPUSH
51744: CALL_OW 251
51748: ST_TO_ADDR
// for i = 0 to 5 do
51749: LD_ADDR_VAR 0 4
51753: PUSH
51754: DOUBLE
51755: LD_INT 0
51757: DEC
51758: ST_TO_ADDR
51759: LD_INT 5
51761: PUSH
51762: FOR_TO
51763: IFFALSE 51875
// begin _x := ShiftX ( x , i , 3 ) ;
51765: LD_ADDR_VAR 0 7
51769: PUSH
51770: LD_VAR 0 5
51774: PPUSH
51775: LD_VAR 0 4
51779: PPUSH
51780: LD_INT 3
51782: PPUSH
51783: CALL_OW 272
51787: ST_TO_ADDR
// _y := ShiftY ( y , i , 3 ) ;
51788: LD_ADDR_VAR 0 8
51792: PUSH
51793: LD_VAR 0 6
51797: PPUSH
51798: LD_VAR 0 4
51802: PPUSH
51803: LD_INT 3
51805: PPUSH
51806: CALL_OW 273
51810: ST_TO_ADDR
// if not ValidHex ( _x , _y ) then
51811: LD_VAR 0 7
51815: PPUSH
51816: LD_VAR 0 8
51820: PPUSH
51821: CALL_OW 488
51825: NOT
51826: IFFALSE 51830
// continue ;
51828: GO 51762
// if HexInfo ( _x , _y ) = 0 then
51830: LD_VAR 0 7
51834: PPUSH
51835: LD_VAR 0 8
51839: PPUSH
51840: CALL_OW 428
51844: PUSH
51845: LD_INT 0
51847: EQUAL
51848: IFFALSE 51873
// begin ComMoveXY ( unit , _x , _y ) ;
51850: LD_VAR 0 1
51854: PPUSH
51855: LD_VAR 0 7
51859: PPUSH
51860: LD_VAR 0 8
51864: PPUSH
51865: CALL_OW 111
// exit ;
51869: POP
51870: POP
51871: GO 51877
// end ; end ;
51873: GO 51762
51875: POP
51876: POP
// end ;
51877: LD_VAR 0 3
51881: RET
// export function ScanBase ( side , base_area ) ; begin
51882: LD_INT 0
51884: PPUSH
// result := FilterUnitsInArea ( base_area , [ f_enemy , side ] ) ;
51885: LD_ADDR_VAR 0 3
51889: PUSH
51890: LD_VAR 0 2
51894: PPUSH
51895: LD_INT 81
51897: PUSH
51898: LD_VAR 0 1
51902: PUSH
51903: EMPTY
51904: LIST
51905: LIST
51906: PPUSH
51907: CALL_OW 70
51911: ST_TO_ADDR
// end ;
51912: LD_VAR 0 3
51916: RET
// export function BasicDefend ( base , solds , area ) ; var enemy , side , i , hex ; begin
51917: LD_INT 0
51919: PPUSH
51920: PPUSH
51921: PPUSH
51922: PPUSH
51923: PPUSH
// if not base or not mc_bases [ base ] or not solds or not area then
51924: LD_VAR 0 1
51928: NOT
51929: PUSH
51930: LD_EXP 74
51934: PUSH
51935: LD_VAR 0 1
51939: ARRAY
51940: NOT
51941: OR
51942: PUSH
51943: LD_VAR 0 2
51947: NOT
51948: OR
51949: PUSH
51950: LD_VAR 0 3
51954: NOT
51955: OR
51956: IFFALSE 51960
// exit ;
51958: GO 52473
// side := mc_sides [ base ] ;
51960: LD_ADDR_VAR 0 6
51964: PUSH
51965: LD_EXP 100
51969: PUSH
51970: LD_VAR 0 1
51974: ARRAY
51975: ST_TO_ADDR
// if not side then
51976: LD_VAR 0 6
51980: NOT
51981: IFFALSE 51985
// exit ;
51983: GO 52473
// for i in solds do
51985: LD_ADDR_VAR 0 7
51989: PUSH
51990: LD_VAR 0 2
51994: PUSH
51995: FOR_IN
51996: IFFALSE 52057
// if GetBType ( IsInUnit ( i ) ) in [ b_bunker , b_breastwork ] then
51998: LD_VAR 0 7
52002: PPUSH
52003: CALL_OW 310
52007: PPUSH
52008: CALL_OW 266
52012: PUSH
52013: LD_INT 32
52015: PUSH
52016: LD_INT 31
52018: PUSH
52019: EMPTY
52020: LIST
52021: LIST
52022: IN
52023: IFFALSE 52043
// solds := solds diff i else
52025: LD_ADDR_VAR 0 2
52029: PUSH
52030: LD_VAR 0 2
52034: PUSH
52035: LD_VAR 0 7
52039: DIFF
52040: ST_TO_ADDR
52041: GO 52055
// SetTag ( i , 18 ) ;
52043: LD_VAR 0 7
52047: PPUSH
52048: LD_INT 18
52050: PPUSH
52051: CALL_OW 109
52055: GO 51995
52057: POP
52058: POP
// if not solds then
52059: LD_VAR 0 2
52063: NOT
52064: IFFALSE 52068
// exit ;
52066: GO 52473
// repeat wait ( 0 0$1 ) ;
52068: LD_INT 35
52070: PPUSH
52071: CALL_OW 67
// enemy := ScanBase ( side , area ) ;
52075: LD_ADDR_VAR 0 5
52079: PUSH
52080: LD_VAR 0 6
52084: PPUSH
52085: LD_VAR 0 3
52089: PPUSH
52090: CALL 51882 0 2
52094: ST_TO_ADDR
// if not mc_bases [ base ] or mc_bases [ base ] = [ ] then
52095: LD_EXP 74
52099: PUSH
52100: LD_VAR 0 1
52104: ARRAY
52105: NOT
52106: PUSH
52107: LD_EXP 74
52111: PUSH
52112: LD_VAR 0 1
52116: ARRAY
52117: PUSH
52118: EMPTY
52119: EQUAL
52120: OR
52121: IFFALSE 52158
// begin for i in solds do
52123: LD_ADDR_VAR 0 7
52127: PUSH
52128: LD_VAR 0 2
52132: PUSH
52133: FOR_IN
52134: IFFALSE 52147
// ComStop ( i ) ;
52136: LD_VAR 0 7
52140: PPUSH
52141: CALL_OW 141
52145: GO 52133
52147: POP
52148: POP
// solds := [ ] ;
52149: LD_ADDR_VAR 0 2
52153: PUSH
52154: EMPTY
52155: ST_TO_ADDR
// exit ;
52156: GO 52473
// end ; if not enemy or enemy > 3 or mc_defender [ base ] then
52158: LD_VAR 0 5
52162: NOT
52163: PUSH
52164: LD_VAR 0 5
52168: PUSH
52169: LD_INT 3
52171: GREATER
52172: OR
52173: PUSH
52174: LD_EXP 96
52178: PUSH
52179: LD_VAR 0 1
52183: ARRAY
52184: OR
52185: IFFALSE 52226
// begin for i in solds do
52187: LD_ADDR_VAR 0 7
52191: PUSH
52192: LD_VAR 0 2
52196: PUSH
52197: FOR_IN
52198: IFFALSE 52222
// if HasTask ( i ) then
52200: LD_VAR 0 7
52204: PPUSH
52205: CALL_OW 314
52209: IFFALSE 52220
// ComStop ( i ) ;
52211: LD_VAR 0 7
52215: PPUSH
52216: CALL_OW 141
52220: GO 52197
52222: POP
52223: POP
// break ;
52224: GO 52461
// end ; for i in solds do
52226: LD_ADDR_VAR 0 7
52230: PUSH
52231: LD_VAR 0 2
52235: PUSH
52236: FOR_IN
52237: IFFALSE 52453
// begin if IsInUnit ( i ) then
52239: LD_VAR 0 7
52243: PPUSH
52244: CALL_OW 310
52248: IFFALSE 52259
// ComExitBuilding ( i ) ;
52250: LD_VAR 0 7
52254: PPUSH
52255: CALL_OW 122
// if GetLives ( i ) > 333 then
52259: LD_VAR 0 7
52263: PPUSH
52264: CALL_OW 256
52268: PUSH
52269: LD_INT 333
52271: GREATER
52272: IFFALSE 52300
// ComAttackUnit ( i , NearestUnitToUnit ( enemy , i ) ) else
52274: LD_VAR 0 7
52278: PPUSH
52279: LD_VAR 0 5
52283: PPUSH
52284: LD_VAR 0 7
52288: PPUSH
52289: CALL_OW 74
52293: PPUSH
52294: CALL_OW 115
52298: GO 52451
// begin hex := NearestUnitToUnit ( UnitFilter ( mc_bases [ base ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] , [ f_btype , b_lab ] ] ) , i ) ;
52300: LD_ADDR_VAR 0 8
52304: PUSH
52305: LD_EXP 74
52309: PUSH
52310: LD_VAR 0 1
52314: ARRAY
52315: PPUSH
52316: LD_INT 2
52318: PUSH
52319: LD_INT 30
52321: PUSH
52322: LD_INT 0
52324: PUSH
52325: EMPTY
52326: LIST
52327: LIST
52328: PUSH
52329: LD_INT 30
52331: PUSH
52332: LD_INT 1
52334: PUSH
52335: EMPTY
52336: LIST
52337: LIST
52338: PUSH
52339: LD_INT 30
52341: PUSH
52342: LD_INT 6
52344: PUSH
52345: EMPTY
52346: LIST
52347: LIST
52348: PUSH
52349: EMPTY
52350: LIST
52351: LIST
52352: LIST
52353: LIST
52354: PPUSH
52355: CALL_OW 72
52359: PPUSH
52360: LD_VAR 0 7
52364: PPUSH
52365: CALL_OW 74
52369: ST_TO_ADDR
// ComMoveXY ( i , ShiftX ( GetX ( hex ) , 3 , 5 ) , ShiftY ( GetY ( hex ) , 3 , 5 ) ) ;
52370: LD_VAR 0 7
52374: PPUSH
52375: LD_VAR 0 8
52379: PPUSH
52380: CALL_OW 250
52384: PPUSH
52385: LD_INT 3
52387: PPUSH
52388: LD_INT 5
52390: PPUSH
52391: CALL_OW 272
52395: PPUSH
52396: LD_VAR 0 8
52400: PPUSH
52401: CALL_OW 251
52405: PPUSH
52406: LD_INT 3
52408: PPUSH
52409: LD_INT 5
52411: PPUSH
52412: CALL_OW 273
52416: PPUSH
52417: CALL_OW 111
// SetTag ( i , 0 ) ;
52421: LD_VAR 0 7
52425: PPUSH
52426: LD_INT 0
52428: PPUSH
52429: CALL_OW 109
// solds := solds diff i ;
52433: LD_ADDR_VAR 0 2
52437: PUSH
52438: LD_VAR 0 2
52442: PUSH
52443: LD_VAR 0 7
52447: DIFF
52448: ST_TO_ADDR
// continue ;
52449: GO 52236
// end ; end ;
52451: GO 52236
52453: POP
52454: POP
// until solds ;
52455: LD_VAR 0 2
52459: IFFALSE 52068
// MC_Reset ( base , 18 ) ;
52461: LD_VAR 0 1
52465: PPUSH
52466: LD_INT 18
52468: PPUSH
52469: CALL 24190 0 2
// end ;
52473: LD_VAR 0 4
52477: RET
// export function Defend ( base , defenders , enemy ) ; var i , j , x , solds , mech , un , tmp , mechs , e , fac , components , depot_under_attack , sold_defenders , b , can_defend ; begin
52478: LD_INT 0
52480: PPUSH
52481: PPUSH
52482: PPUSH
52483: PPUSH
52484: PPUSH
52485: PPUSH
52486: PPUSH
52487: PPUSH
52488: PPUSH
52489: PPUSH
52490: PPUSH
52491: PPUSH
52492: PPUSH
52493: PPUSH
52494: PPUSH
52495: PPUSH
// mechs := UnitFilter ( mc_bases [ base ] , [ f_class , 3 ] ) ;
52496: LD_ADDR_VAR 0 12
52500: PUSH
52501: LD_EXP 74
52505: PUSH
52506: LD_VAR 0 1
52510: ARRAY
52511: PPUSH
52512: LD_INT 25
52514: PUSH
52515: LD_INT 3
52517: PUSH
52518: EMPTY
52519: LIST
52520: LIST
52521: PPUSH
52522: CALL_OW 72
52526: ST_TO_ADDR
// if mc_remote_driver [ base ] then
52527: LD_EXP 114
52531: PUSH
52532: LD_VAR 0 1
52536: ARRAY
52537: IFFALSE 52561
// mechs := mechs diff mc_remote_driver [ base ] ;
52539: LD_ADDR_VAR 0 12
52543: PUSH
52544: LD_VAR 0 12
52548: PUSH
52549: LD_EXP 114
52553: PUSH
52554: LD_VAR 0 1
52558: ARRAY
52559: DIFF
52560: ST_TO_ADDR
// for i in mechs do
52561: LD_ADDR_VAR 0 5
52565: PUSH
52566: LD_VAR 0 12
52570: PUSH
52571: FOR_IN
52572: IFFALSE 52607
// if GetTag ( i ) > 0 then
52574: LD_VAR 0 5
52578: PPUSH
52579: CALL_OW 110
52583: PUSH
52584: LD_INT 0
52586: GREATER
52587: IFFALSE 52605
// mechs := mechs diff i ;
52589: LD_ADDR_VAR 0 12
52593: PUSH
52594: LD_VAR 0 12
52598: PUSH
52599: LD_VAR 0 5
52603: DIFF
52604: ST_TO_ADDR
52605: GO 52571
52607: POP
52608: POP
// solds := UnitFilter ( mc_bases [ base ] , [ f_or , [ f_class , 1 ] , [ f_class , 5 ] , [ f_class , 8 ] , [ f_class , 9 ] ] ) ;
52609: LD_ADDR_VAR 0 8
52613: PUSH
52614: LD_EXP 74
52618: PUSH
52619: LD_VAR 0 1
52623: ARRAY
52624: PPUSH
52625: LD_INT 2
52627: PUSH
52628: LD_INT 25
52630: PUSH
52631: LD_INT 1
52633: PUSH
52634: EMPTY
52635: LIST
52636: LIST
52637: PUSH
52638: LD_INT 25
52640: PUSH
52641: LD_INT 5
52643: PUSH
52644: EMPTY
52645: LIST
52646: LIST
52647: PUSH
52648: LD_INT 25
52650: PUSH
52651: LD_INT 8
52653: PUSH
52654: EMPTY
52655: LIST
52656: LIST
52657: PUSH
52658: LD_INT 25
52660: PUSH
52661: LD_INT 9
52663: PUSH
52664: EMPTY
52665: LIST
52666: LIST
52667: PUSH
52668: EMPTY
52669: LIST
52670: LIST
52671: LIST
52672: LIST
52673: LIST
52674: PPUSH
52675: CALL_OW 72
52679: ST_TO_ADDR
// if not defenders and not solds then
52680: LD_VAR 0 2
52684: NOT
52685: PUSH
52686: LD_VAR 0 8
52690: NOT
52691: AND
52692: IFFALSE 52696
// exit ;
52694: GO 54234
// depot_under_attack := false ;
52696: LD_ADDR_VAR 0 16
52700: PUSH
52701: LD_INT 0
52703: ST_TO_ADDR
// sold_defenders := [ ] ;
52704: LD_ADDR_VAR 0 17
52708: PUSH
52709: EMPTY
52710: ST_TO_ADDR
// if mechs then
52711: LD_VAR 0 12
52715: IFFALSE 52844
// for i in defenders do
52717: LD_ADDR_VAR 0 5
52721: PUSH
52722: LD_VAR 0 2
52726: PUSH
52727: FOR_IN
52728: IFFALSE 52842
// begin SetTag ( i , 20 ) ;
52730: LD_VAR 0 5
52734: PPUSH
52735: LD_INT 20
52737: PPUSH
52738: CALL_OW 109
// if GetControl ( i ) = control_manual and not IsDrivenBy ( i ) and mechs then
52742: LD_VAR 0 5
52746: PPUSH
52747: CALL_OW 263
52751: PUSH
52752: LD_INT 1
52754: EQUAL
52755: PUSH
52756: LD_VAR 0 5
52760: PPUSH
52761: CALL_OW 311
52765: NOT
52766: AND
52767: PUSH
52768: LD_VAR 0 12
52772: AND
52773: IFFALSE 52840
// begin un := mechs [ 1 ] ;
52775: LD_ADDR_VAR 0 10
52779: PUSH
52780: LD_VAR 0 12
52784: PUSH
52785: LD_INT 1
52787: ARRAY
52788: ST_TO_ADDR
// ComExitBuilding ( un ) ;
52789: LD_VAR 0 10
52793: PPUSH
52794: CALL_OW 122
// AddComEnterUnit ( un , i ) ;
52798: LD_VAR 0 10
52802: PPUSH
52803: LD_VAR 0 5
52807: PPUSH
52808: CALL_OW 180
// SetTag ( un , 19 ) ;
52812: LD_VAR 0 10
52816: PPUSH
52817: LD_INT 19
52819: PPUSH
52820: CALL_OW 109
// mechs := mechs diff un ;
52824: LD_ADDR_VAR 0 12
52828: PUSH
52829: LD_VAR 0 12
52833: PUSH
52834: LD_VAR 0 10
52838: DIFF
52839: ST_TO_ADDR
// end ; end ;
52840: GO 52727
52842: POP
52843: POP
// if solds then
52844: LD_VAR 0 8
52848: IFFALSE 52907
// for i in solds do
52850: LD_ADDR_VAR 0 5
52854: PUSH
52855: LD_VAR 0 8
52859: PUSH
52860: FOR_IN
52861: IFFALSE 52905
// if not GetTag ( i ) then
52863: LD_VAR 0 5
52867: PPUSH
52868: CALL_OW 110
52872: NOT
52873: IFFALSE 52903
// begin defenders := defenders union i ;
52875: LD_ADDR_VAR 0 2
52879: PUSH
52880: LD_VAR 0 2
52884: PUSH
52885: LD_VAR 0 5
52889: UNION
52890: ST_TO_ADDR
// SetTag ( i , 18 ) ;
52891: LD_VAR 0 5
52895: PPUSH
52896: LD_INT 18
52898: PPUSH
52899: CALL_OW 109
// end ;
52903: GO 52860
52905: POP
52906: POP
// repeat wait ( 0 0$1 ) ;
52907: LD_INT 35
52909: PPUSH
52910: CALL_OW 67
// enemy := mc_scan [ base ] ;
52914: LD_ADDR_VAR 0 3
52918: PUSH
52919: LD_EXP 97
52923: PUSH
52924: LD_VAR 0 1
52928: ARRAY
52929: ST_TO_ADDR
// if not mc_bases [ base ] or mc_bases [ base ] = [ ] then
52930: LD_EXP 74
52934: PUSH
52935: LD_VAR 0 1
52939: ARRAY
52940: NOT
52941: PUSH
52942: LD_EXP 74
52946: PUSH
52947: LD_VAR 0 1
52951: ARRAY
52952: PUSH
52953: EMPTY
52954: EQUAL
52955: OR
52956: IFFALSE 52993
// begin for i in defenders do
52958: LD_ADDR_VAR 0 5
52962: PUSH
52963: LD_VAR 0 2
52967: PUSH
52968: FOR_IN
52969: IFFALSE 52982
// ComStop ( i ) ;
52971: LD_VAR 0 5
52975: PPUSH
52976: CALL_OW 141
52980: GO 52968
52982: POP
52983: POP
// defenders := [ ] ;
52984: LD_ADDR_VAR 0 2
52988: PUSH
52989: EMPTY
52990: ST_TO_ADDR
// exit ;
52991: GO 54234
// end ; for i in defenders do
52993: LD_ADDR_VAR 0 5
52997: PUSH
52998: LD_VAR 0 2
53002: PUSH
53003: FOR_IN
53004: IFFALSE 53734
// begin e := NearestUnitToUnit ( enemy , i ) ;
53006: LD_ADDR_VAR 0 13
53010: PUSH
53011: LD_VAR 0 3
53015: PPUSH
53016: LD_VAR 0 5
53020: PPUSH
53021: CALL_OW 74
53025: ST_TO_ADDR
// depot_under_attack := ( not UnitFilter ( mc_bases [ base ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) or GetLives ( UnitFilter ( mc_bases [ base ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) ) < 600 ) ;
53026: LD_ADDR_VAR 0 16
53030: PUSH
53031: LD_EXP 74
53035: PUSH
53036: LD_VAR 0 1
53040: ARRAY
53041: PPUSH
53042: LD_INT 2
53044: PUSH
53045: LD_INT 30
53047: PUSH
53048: LD_INT 0
53050: PUSH
53051: EMPTY
53052: LIST
53053: LIST
53054: PUSH
53055: LD_INT 30
53057: PUSH
53058: LD_INT 1
53060: PUSH
53061: EMPTY
53062: LIST
53063: LIST
53064: PUSH
53065: EMPTY
53066: LIST
53067: LIST
53068: LIST
53069: PPUSH
53070: CALL_OW 72
53074: NOT
53075: PUSH
53076: LD_EXP 74
53080: PUSH
53081: LD_VAR 0 1
53085: ARRAY
53086: PPUSH
53087: LD_INT 2
53089: PUSH
53090: LD_INT 30
53092: PUSH
53093: LD_INT 0
53095: PUSH
53096: EMPTY
53097: LIST
53098: LIST
53099: PUSH
53100: LD_INT 30
53102: PUSH
53103: LD_INT 1
53105: PUSH
53106: EMPTY
53107: LIST
53108: LIST
53109: PUSH
53110: EMPTY
53111: LIST
53112: LIST
53113: LIST
53114: PPUSH
53115: CALL_OW 72
53119: PPUSH
53120: CALL_OW 256
53124: PUSH
53125: LD_INT 600
53127: LESS
53128: OR
53129: ST_TO_ADDR
// case GetType ( i ) of unit_vehicle :
53130: LD_VAR 0 5
53134: PPUSH
53135: CALL_OW 247
53139: PUSH
53140: LD_INT 2
53142: DOUBLE
53143: EQUAL
53144: IFTRUE 53148
53146: GO 53440
53148: POP
// begin if GetLives ( i ) > 650 and ( GetDistUnits ( i , e ) < 40 or IsInArea ( e , mc_scan_area [ base ] ) ) then
53149: LD_VAR 0 5
53153: PPUSH
53154: CALL_OW 256
53158: PUSH
53159: LD_INT 650
53161: GREATER
53162: PUSH
53163: LD_VAR 0 5
53167: PPUSH
53168: LD_VAR 0 13
53172: PPUSH
53173: CALL_OW 296
53177: PUSH
53178: LD_INT 40
53180: LESS
53181: PUSH
53182: LD_VAR 0 13
53186: PPUSH
53187: LD_EXP 99
53191: PUSH
53192: LD_VAR 0 1
53196: ARRAY
53197: PPUSH
53198: CALL_OW 308
53202: OR
53203: AND
53204: IFFALSE 53222
// ComAttackUnit ( i , e ) else
53206: LD_VAR 0 5
53210: PPUSH
53211: LD_VAR 0 13
53215: PPUSH
53216: CALL_OW 115
53220: GO 53323
// if ( ( not IsInArea ( e , mc_scan_area [ base ] ) and GetDistUnits ( i , e ) >= 40 ) or GetLives ( i ) <= 650 ) and not IsInArea ( i , mc_parking [ base ] ) then
53222: LD_VAR 0 13
53226: PPUSH
53227: LD_EXP 99
53231: PUSH
53232: LD_VAR 0 1
53236: ARRAY
53237: PPUSH
53238: CALL_OW 308
53242: NOT
53243: PUSH
53244: LD_VAR 0 5
53248: PPUSH
53249: LD_VAR 0 13
53253: PPUSH
53254: CALL_OW 296
53258: PUSH
53259: LD_INT 40
53261: GREATEREQUAL
53262: AND
53263: PUSH
53264: LD_VAR 0 5
53268: PPUSH
53269: CALL_OW 256
53273: PUSH
53274: LD_INT 650
53276: LESSEQUAL
53277: OR
53278: PUSH
53279: LD_VAR 0 5
53283: PPUSH
53284: LD_EXP 98
53288: PUSH
53289: LD_VAR 0 1
53293: ARRAY
53294: PPUSH
53295: CALL_OW 308
53299: NOT
53300: AND
53301: IFFALSE 53323
// ComMoveToArea ( i , mc_parking [ base ] ) ;
53303: LD_VAR 0 5
53307: PPUSH
53308: LD_EXP 98
53312: PUSH
53313: LD_VAR 0 1
53317: ARRAY
53318: PPUSH
53319: CALL_OW 113
// if GetLives ( i ) < 998 and GetControl ( i ) = control_manual and IsDrivenBy ( i ) and IsInArea ( i , mc_parking [ base ] ) then
53323: LD_VAR 0 5
53327: PPUSH
53328: CALL_OW 256
53332: PUSH
53333: LD_INT 998
53335: LESS
53336: PUSH
53337: LD_VAR 0 5
53341: PPUSH
53342: CALL_OW 263
53346: PUSH
53347: LD_INT 1
53349: EQUAL
53350: AND
53351: PUSH
53352: LD_VAR 0 5
53356: PPUSH
53357: CALL_OW 311
53361: AND
53362: PUSH
53363: LD_VAR 0 5
53367: PPUSH
53368: LD_EXP 98
53372: PUSH
53373: LD_VAR 0 1
53377: ARRAY
53378: PPUSH
53379: CALL_OW 308
53383: AND
53384: IFFALSE 53438
// begin mech := IsDrivenBy ( i ) ;
53386: LD_ADDR_VAR 0 9
53390: PUSH
53391: LD_VAR 0 5
53395: PPUSH
53396: CALL_OW 311
53400: ST_TO_ADDR
// ComExitVehicle ( mech ) ;
53401: LD_VAR 0 9
53405: PPUSH
53406: CALL_OW 121
// AddComRepairVehicle ( mech , i ) ;
53410: LD_VAR 0 9
53414: PPUSH
53415: LD_VAR 0 5
53419: PPUSH
53420: CALL_OW 189
// AddComEnterUnit ( mech , i ) ;
53424: LD_VAR 0 9
53428: PPUSH
53429: LD_VAR 0 5
53433: PPUSH
53434: CALL_OW 180
// end ; end ; unit_human :
53438: GO 53705
53440: LD_INT 1
53442: DOUBLE
53443: EQUAL
53444: IFTRUE 53448
53446: GO 53704
53448: POP
// begin b := IsInUnit ( i ) ;
53449: LD_ADDR_VAR 0 18
53453: PUSH
53454: LD_VAR 0 5
53458: PPUSH
53459: CALL_OW 310
53463: ST_TO_ADDR
// can_defend := ( not b or GetBType ( b ) in [ b_bunker , b_breastwork ] ) ;
53464: LD_ADDR_VAR 0 19
53468: PUSH
53469: LD_VAR 0 18
53473: NOT
53474: PUSH
53475: LD_VAR 0 18
53479: PPUSH
53480: CALL_OW 266
53484: PUSH
53485: LD_INT 32
53487: PUSH
53488: LD_INT 31
53490: PUSH
53491: EMPTY
53492: LIST
53493: LIST
53494: IN
53495: OR
53496: ST_TO_ADDR
// if ( depot_under_attack or UnitFilter ( defenders , [ f_type , unit_vehicle ] ) <= 1 ) and can_defend and not i in sold_defenders then
53497: LD_VAR 0 16
53501: PUSH
53502: LD_VAR 0 2
53506: PPUSH
53507: LD_INT 21
53509: PUSH
53510: LD_INT 2
53512: PUSH
53513: EMPTY
53514: LIST
53515: LIST
53516: PPUSH
53517: CALL_OW 72
53521: PUSH
53522: LD_INT 1
53524: LESSEQUAL
53525: OR
53526: PUSH
53527: LD_VAR 0 19
53531: AND
53532: PUSH
53533: LD_VAR 0 5
53537: PUSH
53538: LD_VAR 0 17
53542: IN
53543: NOT
53544: AND
53545: IFFALSE 53638
// begin if b then
53547: LD_VAR 0 18
53551: IFFALSE 53600
// if GetDistUnits ( b , NearestUnitToUnit ( enemy , b ) ) < 10 and BuildingStatus ( b ) <> bs_need_power then
53553: LD_VAR 0 18
53557: PPUSH
53558: LD_VAR 0 3
53562: PPUSH
53563: LD_VAR 0 18
53567: PPUSH
53568: CALL_OW 74
53572: PPUSH
53573: CALL_OW 296
53577: PUSH
53578: LD_INT 10
53580: LESS
53581: PUSH
53582: LD_VAR 0 18
53586: PPUSH
53587: CALL_OW 461
53591: PUSH
53592: LD_INT 7
53594: NONEQUAL
53595: AND
53596: IFFALSE 53600
// continue ;
53598: GO 53003
// sold_defenders := Replace ( sold_defenders , sold_defenders + 1 , i ) ;
53600: LD_ADDR_VAR 0 17
53604: PUSH
53605: LD_VAR 0 17
53609: PPUSH
53610: LD_VAR 0 17
53614: PUSH
53615: LD_INT 1
53617: PLUS
53618: PPUSH
53619: LD_VAR 0 5
53623: PPUSH
53624: CALL_OW 1
53628: ST_TO_ADDR
// ComExitBuilding ( i ) ;
53629: LD_VAR 0 5
53633: PPUSH
53634: CALL_OW 122
// end ; if sold_defenders then
53638: LD_VAR 0 17
53642: IFFALSE 53702
// if i in sold_defenders then
53644: LD_VAR 0 5
53648: PUSH
53649: LD_VAR 0 17
53653: IN
53654: IFFALSE 53702
// begin if not HasTask ( i ) and GetDistUnits ( i , e ) < 30 then
53656: LD_VAR 0 5
53660: PPUSH
53661: CALL_OW 314
53665: NOT
53666: PUSH
53667: LD_VAR 0 5
53671: PPUSH
53672: LD_VAR 0 13
53676: PPUSH
53677: CALL_OW 296
53681: PUSH
53682: LD_INT 30
53684: LESS
53685: AND
53686: IFFALSE 53702
// ComAttackUnit ( i , e ) ;
53688: LD_VAR 0 5
53692: PPUSH
53693: LD_VAR 0 13
53697: PPUSH
53698: CALL_OW 115
// end ; end ; end ;
53702: GO 53705
53704: POP
// if IsDead ( i ) then
53705: LD_VAR 0 5
53709: PPUSH
53710: CALL_OW 301
53714: IFFALSE 53732
// defenders := defenders diff i ;
53716: LD_ADDR_VAR 0 2
53720: PUSH
53721: LD_VAR 0 2
53725: PUSH
53726: LD_VAR 0 5
53730: DIFF
53731: ST_TO_ADDR
// end ;
53732: GO 53003
53734: POP
53735: POP
// until not enemy or not defenders or not mc_bases [ base ] ;
53736: LD_VAR 0 3
53740: NOT
53741: PUSH
53742: LD_VAR 0 2
53746: NOT
53747: OR
53748: PUSH
53749: LD_EXP 74
53753: PUSH
53754: LD_VAR 0 1
53758: ARRAY
53759: NOT
53760: OR
53761: IFFALSE 52907
// MC_Reset ( base , 18 ) ;
53763: LD_VAR 0 1
53767: PPUSH
53768: LD_INT 18
53770: PPUSH
53771: CALL 24190 0 2
// defenders := defenders diff UnitFilter ( defenders , [ f_or , [ f_class , 1 ] , [ f_class , 5 ] , [ f_class , 8 ] , [ f_class , 9 ] ] ) ;
53775: LD_ADDR_VAR 0 2
53779: PUSH
53780: LD_VAR 0 2
53784: PUSH
53785: LD_VAR 0 2
53789: PPUSH
53790: LD_INT 2
53792: PUSH
53793: LD_INT 25
53795: PUSH
53796: LD_INT 1
53798: PUSH
53799: EMPTY
53800: LIST
53801: LIST
53802: PUSH
53803: LD_INT 25
53805: PUSH
53806: LD_INT 5
53808: PUSH
53809: EMPTY
53810: LIST
53811: LIST
53812: PUSH
53813: LD_INT 25
53815: PUSH
53816: LD_INT 8
53818: PUSH
53819: EMPTY
53820: LIST
53821: LIST
53822: PUSH
53823: LD_INT 25
53825: PUSH
53826: LD_INT 9
53828: PUSH
53829: EMPTY
53830: LIST
53831: LIST
53832: PUSH
53833: EMPTY
53834: LIST
53835: LIST
53836: LIST
53837: LIST
53838: LIST
53839: PPUSH
53840: CALL_OW 72
53844: DIFF
53845: ST_TO_ADDR
// if not enemy and UnitFilter ( defenders , [ f_type , unit_vehicle ] ) then
53846: LD_VAR 0 3
53850: NOT
53851: PUSH
53852: LD_VAR 0 2
53856: PPUSH
53857: LD_INT 21
53859: PUSH
53860: LD_INT 2
53862: PUSH
53863: EMPTY
53864: LIST
53865: LIST
53866: PPUSH
53867: CALL_OW 72
53871: AND
53872: IFFALSE 54210
// begin tmp := FilterByTag ( defenders , 19 ) ;
53874: LD_ADDR_VAR 0 11
53878: PUSH
53879: LD_VAR 0 2
53883: PPUSH
53884: LD_INT 19
53886: PPUSH
53887: CALL 90663 0 2
53891: ST_TO_ADDR
// if tmp then
53892: LD_VAR 0 11
53896: IFFALSE 53966
// begin tmp := UnitFilter ( tmp , [ f_class , 3 ] ) ;
53898: LD_ADDR_VAR 0 11
53902: PUSH
53903: LD_VAR 0 11
53907: PPUSH
53908: LD_INT 25
53910: PUSH
53911: LD_INT 3
53913: PUSH
53914: EMPTY
53915: LIST
53916: LIST
53917: PPUSH
53918: CALL_OW 72
53922: ST_TO_ADDR
// if tmp then
53923: LD_VAR 0 11
53927: IFFALSE 53966
// mc_repair_vehicle := Replace ( mc_repair_vehicle , base , mc_repair_vehicle [ base ] union tmp ) ;
53929: LD_ADDR_EXP 86
53933: PUSH
53934: LD_EXP 86
53938: PPUSH
53939: LD_VAR 0 1
53943: PPUSH
53944: LD_EXP 86
53948: PUSH
53949: LD_VAR 0 1
53953: ARRAY
53954: PUSH
53955: LD_VAR 0 11
53959: UNION
53960: PPUSH
53961: CALL_OW 1
53965: ST_TO_ADDR
// end ; MC_Reset ( base , 19 ) ;
53966: LD_VAR 0 1
53970: PPUSH
53971: LD_INT 19
53973: PPUSH
53974: CALL 24190 0 2
// repeat wait ( 0 0$1 ) ;
53978: LD_INT 35
53980: PPUSH
53981: CALL_OW 67
// if not mc_bases [ base ] or mc_bases [ base ] = [ ] then
53985: LD_EXP 74
53989: PUSH
53990: LD_VAR 0 1
53994: ARRAY
53995: NOT
53996: PUSH
53997: LD_EXP 74
54001: PUSH
54002: LD_VAR 0 1
54006: ARRAY
54007: PUSH
54008: EMPTY
54009: EQUAL
54010: OR
54011: IFFALSE 54048
// begin for i in defenders do
54013: LD_ADDR_VAR 0 5
54017: PUSH
54018: LD_VAR 0 2
54022: PUSH
54023: FOR_IN
54024: IFFALSE 54037
// ComStop ( i ) ;
54026: LD_VAR 0 5
54030: PPUSH
54031: CALL_OW 141
54035: GO 54023
54037: POP
54038: POP
// defenders := [ ] ;
54039: LD_ADDR_VAR 0 2
54043: PUSH
54044: EMPTY
54045: ST_TO_ADDR
// exit ;
54046: GO 54234
// end ; for i in defenders do
54048: LD_ADDR_VAR 0 5
54052: PUSH
54053: LD_VAR 0 2
54057: PUSH
54058: FOR_IN
54059: IFFALSE 54148
// begin if not IsInArea ( i , mc_parking [ base ] ) then
54061: LD_VAR 0 5
54065: PPUSH
54066: LD_EXP 98
54070: PUSH
54071: LD_VAR 0 1
54075: ARRAY
54076: PPUSH
54077: CALL_OW 308
54081: NOT
54082: IFFALSE 54106
// ComMoveToArea ( i , mc_parking [ base ] ) else
54084: LD_VAR 0 5
54088: PPUSH
54089: LD_EXP 98
54093: PUSH
54094: LD_VAR 0 1
54098: ARRAY
54099: PPUSH
54100: CALL_OW 113
54104: GO 54146
// if GetControl ( i ) = control_manual then
54106: LD_VAR 0 5
54110: PPUSH
54111: CALL_OW 263
54115: PUSH
54116: LD_INT 1
54118: EQUAL
54119: IFFALSE 54146
// if IsDrivenBy ( i ) then
54121: LD_VAR 0 5
54125: PPUSH
54126: CALL_OW 311
54130: IFFALSE 54146
// ComExitVehicle ( IsDrivenBy ( i ) ) ;
54132: LD_VAR 0 5
54136: PPUSH
54137: CALL_OW 311
54141: PPUSH
54142: CALL_OW 121
// end ;
54146: GO 54058
54148: POP
54149: POP
// until UnitFilter ( defenders , [ f_inarea , mc_parking [ base ] ] ) = defenders or mc_scan [ base ] or not mc_bases [ base ] ;
54150: LD_VAR 0 2
54154: PPUSH
54155: LD_INT 95
54157: PUSH
54158: LD_EXP 98
54162: PUSH
54163: LD_VAR 0 1
54167: ARRAY
54168: PUSH
54169: EMPTY
54170: LIST
54171: LIST
54172: PPUSH
54173: CALL_OW 72
54177: PUSH
54178: LD_VAR 0 2
54182: EQUAL
54183: PUSH
54184: LD_EXP 97
54188: PUSH
54189: LD_VAR 0 1
54193: ARRAY
54194: OR
54195: PUSH
54196: LD_EXP 74
54200: PUSH
54201: LD_VAR 0 1
54205: ARRAY
54206: NOT
54207: OR
54208: IFFALSE 53978
// end ; MC_Reset ( base , 19 ) ;
54210: LD_VAR 0 1
54214: PPUSH
54215: LD_INT 19
54217: PPUSH
54218: CALL 24190 0 2
// MC_Reset ( base , 20 ) ;
54222: LD_VAR 0 1
54226: PPUSH
54227: LD_INT 20
54229: PPUSH
54230: CALL 24190 0 2
// end ;
54234: LD_VAR 0 4
54238: RET
// export function AllowSpecClass ( unit ) ; var side , nat , tech ; begin
54239: LD_INT 0
54241: PPUSH
54242: PPUSH
54243: PPUSH
54244: PPUSH
// result := false ;
54245: LD_ADDR_VAR 0 2
54249: PUSH
54250: LD_INT 0
54252: ST_TO_ADDR
// side := GetSide ( unit ) ;
54253: LD_ADDR_VAR 0 3
54257: PUSH
54258: LD_VAR 0 1
54262: PPUSH
54263: CALL_OW 255
54267: ST_TO_ADDR
// nat := GetNation ( unit ) ;
54268: LD_ADDR_VAR 0 4
54272: PUSH
54273: LD_VAR 0 1
54277: PPUSH
54278: CALL_OW 248
54282: ST_TO_ADDR
// case nat of 1 :
54283: LD_VAR 0 4
54287: PUSH
54288: LD_INT 1
54290: DOUBLE
54291: EQUAL
54292: IFTRUE 54296
54294: GO 54307
54296: POP
// tech := tech_lassight ; 2 :
54297: LD_ADDR_VAR 0 5
54301: PUSH
54302: LD_INT 12
54304: ST_TO_ADDR
54305: GO 54346
54307: LD_INT 2
54309: DOUBLE
54310: EQUAL
54311: IFTRUE 54315
54313: GO 54326
54315: POP
// tech := tech_mortar ; 3 :
54316: LD_ADDR_VAR 0 5
54320: PUSH
54321: LD_INT 41
54323: ST_TO_ADDR
54324: GO 54346
54326: LD_INT 3
54328: DOUBLE
54329: EQUAL
54330: IFTRUE 54334
54332: GO 54345
54334: POP
// tech := tech_bazooka ; end ;
54335: LD_ADDR_VAR 0 5
54339: PUSH
54340: LD_INT 44
54342: ST_TO_ADDR
54343: GO 54346
54345: POP
// if Researched ( side , tech ) then
54346: LD_VAR 0 3
54350: PPUSH
54351: LD_VAR 0 5
54355: PPUSH
54356: CALL_OW 325
54360: IFFALSE 54387
// result := [ class_sniper , class_mortar , class_bazooker ] [ nat ] ;
54362: LD_ADDR_VAR 0 2
54366: PUSH
54367: LD_INT 5
54369: PUSH
54370: LD_INT 8
54372: PUSH
54373: LD_INT 9
54375: PUSH
54376: EMPTY
54377: LIST
54378: LIST
54379: LIST
54380: PUSH
54381: LD_VAR 0 4
54385: ARRAY
54386: ST_TO_ADDR
// end ;
54387: LD_VAR 0 2
54391: RET
// export function DetonateMines ( side , mines ) ; var i , tmp ; begin
54392: LD_INT 0
54394: PPUSH
54395: PPUSH
54396: PPUSH
// if not mines then
54397: LD_VAR 0 2
54401: NOT
54402: IFFALSE 54406
// exit ;
54404: GO 54550
// tmp := FilterAllUnits ( [ [ f_enemy , side ] , [ f_not , [ f_type , unit_building ] ] ] ) ;
54406: LD_ADDR_VAR 0 5
54410: PUSH
54411: LD_INT 81
54413: PUSH
54414: LD_VAR 0 1
54418: PUSH
54419: EMPTY
54420: LIST
54421: LIST
54422: PUSH
54423: LD_INT 3
54425: PUSH
54426: LD_INT 21
54428: PUSH
54429: LD_INT 3
54431: PUSH
54432: EMPTY
54433: LIST
54434: LIST
54435: PUSH
54436: EMPTY
54437: LIST
54438: LIST
54439: PUSH
54440: EMPTY
54441: LIST
54442: LIST
54443: PPUSH
54444: CALL_OW 69
54448: ST_TO_ADDR
// for i in mines do
54449: LD_ADDR_VAR 0 4
54453: PUSH
54454: LD_VAR 0 2
54458: PUSH
54459: FOR_IN
54460: IFFALSE 54548
// begin if not MineAtPos ( i [ 1 ] , i [ 2 ] ) then
54462: LD_VAR 0 4
54466: PUSH
54467: LD_INT 1
54469: ARRAY
54470: PPUSH
54471: LD_VAR 0 4
54475: PUSH
54476: LD_INT 2
54478: ARRAY
54479: PPUSH
54480: CALL_OW 458
54484: NOT
54485: IFFALSE 54489
// continue ;
54487: GO 54459
// if HexInfo ( i [ 1 ] , i [ 2 ] ) in tmp then
54489: LD_VAR 0 4
54493: PUSH
54494: LD_INT 1
54496: ARRAY
54497: PPUSH
54498: LD_VAR 0 4
54502: PUSH
54503: LD_INT 2
54505: ARRAY
54506: PPUSH
54507: CALL_OW 428
54511: PUSH
54512: LD_VAR 0 5
54516: IN
54517: IFFALSE 54546
// LaunchMineAtPos ( i [ 1 ] , i [ 2 ] , side ) ;
54519: LD_VAR 0 4
54523: PUSH
54524: LD_INT 1
54526: ARRAY
54527: PPUSH
54528: LD_VAR 0 4
54532: PUSH
54533: LD_INT 2
54535: ARRAY
54536: PPUSH
54537: LD_VAR 0 1
54541: PPUSH
54542: CALL_OW 456
// end ;
54546: GO 54459
54548: POP
54549: POP
// end ;
54550: LD_VAR 0 3
54554: RET
// export function Count ( array ) ; var i ; begin
54555: LD_INT 0
54557: PPUSH
54558: PPUSH
// result := 0 ;
54559: LD_ADDR_VAR 0 2
54563: PUSH
54564: LD_INT 0
54566: ST_TO_ADDR
// for i in array do
54567: LD_ADDR_VAR 0 3
54571: PUSH
54572: LD_VAR 0 1
54576: PUSH
54577: FOR_IN
54578: IFFALSE 54602
// if i then
54580: LD_VAR 0 3
54584: IFFALSE 54600
// result := result + 1 ;
54586: LD_ADDR_VAR 0 2
54590: PUSH
54591: LD_VAR 0 2
54595: PUSH
54596: LD_INT 1
54598: PLUS
54599: ST_TO_ADDR
54600: GO 54577
54602: POP
54603: POP
// end ;
54604: LD_VAR 0 2
54608: RET
// export function IsEmpty ( building ) ; begin
54609: LD_INT 0
54611: PPUSH
// if not building then
54612: LD_VAR 0 1
54616: NOT
54617: IFFALSE 54621
// exit ;
54619: GO 54664
// result := building in FilterAllUnits ( [ [ f_side , GetSide ( building ) ] , [ f_empty ] ] ) ;
54621: LD_ADDR_VAR 0 2
54625: PUSH
54626: LD_VAR 0 1
54630: PUSH
54631: LD_INT 22
54633: PUSH
54634: LD_VAR 0 1
54638: PPUSH
54639: CALL_OW 255
54643: PUSH
54644: EMPTY
54645: LIST
54646: LIST
54647: PUSH
54648: LD_INT 58
54650: PUSH
54651: EMPTY
54652: LIST
54653: PUSH
54654: EMPTY
54655: LIST
54656: LIST
54657: PPUSH
54658: CALL_OW 69
54662: IN
54663: ST_TO_ADDR
// end ;
54664: LD_VAR 0 2
54668: RET
// export function IsNotFull ( building ) ; begin
54669: LD_INT 0
54671: PPUSH
// if not building then
54672: LD_VAR 0 1
54676: NOT
54677: IFFALSE 54681
// exit ;
54679: GO 54700
// result := UnitsInside ( building ) < 6 ;
54681: LD_ADDR_VAR 0 2
54685: PUSH
54686: LD_VAR 0 1
54690: PPUSH
54691: CALL_OW 313
54695: PUSH
54696: LD_INT 6
54698: LESS
54699: ST_TO_ADDR
// end ;
54700: LD_VAR 0 2
54704: RET
// export function GetFacExt ( factory ) ; var tmp , i , list ; begin
54705: LD_INT 0
54707: PPUSH
54708: PPUSH
54709: PPUSH
54710: PPUSH
// tmp := [ ] ;
54711: LD_ADDR_VAR 0 3
54715: PUSH
54716: EMPTY
54717: ST_TO_ADDR
// list := [ ] ;
54718: LD_ADDR_VAR 0 5
54722: PUSH
54723: EMPTY
54724: ST_TO_ADDR
// for i = 16 to 25 do
54725: LD_ADDR_VAR 0 4
54729: PUSH
54730: DOUBLE
54731: LD_INT 16
54733: DEC
54734: ST_TO_ADDR
54735: LD_INT 25
54737: PUSH
54738: FOR_TO
54739: IFFALSE 54812
// tmp := tmp ^ FilterAllUnits ( [ [ [ f_side , GetSide ( factory ) ] , [ f_dist , factory , 6 ] , [ f_btype , i ] ] ] ) ;
54741: LD_ADDR_VAR 0 3
54745: PUSH
54746: LD_VAR 0 3
54750: PUSH
54751: LD_INT 22
54753: PUSH
54754: LD_VAR 0 1
54758: PPUSH
54759: CALL_OW 255
54763: PUSH
54764: EMPTY
54765: LIST
54766: LIST
54767: PUSH
54768: LD_INT 91
54770: PUSH
54771: LD_VAR 0 1
54775: PUSH
54776: LD_INT 6
54778: PUSH
54779: EMPTY
54780: LIST
54781: LIST
54782: LIST
54783: PUSH
54784: LD_INT 30
54786: PUSH
54787: LD_VAR 0 4
54791: PUSH
54792: EMPTY
54793: LIST
54794: LIST
54795: PUSH
54796: EMPTY
54797: LIST
54798: LIST
54799: LIST
54800: PUSH
54801: EMPTY
54802: LIST
54803: PPUSH
54804: CALL_OW 69
54808: ADD
54809: ST_TO_ADDR
54810: GO 54738
54812: POP
54813: POP
// for i = 1 to tmp do
54814: LD_ADDR_VAR 0 4
54818: PUSH
54819: DOUBLE
54820: LD_INT 1
54822: DEC
54823: ST_TO_ADDR
54824: LD_VAR 0 3
54828: PUSH
54829: FOR_TO
54830: IFFALSE 54918
// list := list ^ [ [ GetBType ( tmp [ i ] ) , GetX ( tmp [ i ] ) , GetY ( tmp [ i ] ) , GetDir ( tmp [ i ] ) ] ] ;
54832: LD_ADDR_VAR 0 5
54836: PUSH
54837: LD_VAR 0 5
54841: PUSH
54842: LD_VAR 0 3
54846: PUSH
54847: LD_VAR 0 4
54851: ARRAY
54852: PPUSH
54853: CALL_OW 266
54857: PUSH
54858: LD_VAR 0 3
54862: PUSH
54863: LD_VAR 0 4
54867: ARRAY
54868: PPUSH
54869: CALL_OW 250
54873: PUSH
54874: LD_VAR 0 3
54878: PUSH
54879: LD_VAR 0 4
54883: ARRAY
54884: PPUSH
54885: CALL_OW 251
54889: PUSH
54890: LD_VAR 0 3
54894: PUSH
54895: LD_VAR 0 4
54899: ARRAY
54900: PPUSH
54901: CALL_OW 254
54905: PUSH
54906: EMPTY
54907: LIST
54908: LIST
54909: LIST
54910: LIST
54911: PUSH
54912: EMPTY
54913: LIST
54914: ADD
54915: ST_TO_ADDR
54916: GO 54829
54918: POP
54919: POP
// result := list ;
54920: LD_ADDR_VAR 0 2
54924: PUSH
54925: LD_VAR 0 5
54929: ST_TO_ADDR
// end ;
54930: LD_VAR 0 2
54934: RET
// export function Produce ( factory , chassis , engine , control , weapon ) ; var i , tmp , _chassis , _weapon , _engine , _control ; begin
54935: LD_INT 0
54937: PPUSH
54938: PPUSH
54939: PPUSH
54940: PPUSH
54941: PPUSH
54942: PPUSH
54943: PPUSH
// if not factory then
54944: LD_VAR 0 1
54948: NOT
54949: IFFALSE 54953
// exit ;
54951: GO 55546
// if control = control_apeman then
54953: LD_VAR 0 4
54957: PUSH
54958: LD_INT 5
54960: EQUAL
54961: IFFALSE 55070
// begin tmp := UnitsInside ( factory ) ;
54963: LD_ADDR_VAR 0 8
54967: PUSH
54968: LD_VAR 0 1
54972: PPUSH
54973: CALL_OW 313
54977: ST_TO_ADDR
// if not UnitFilter ( tmp , [ f_class , class_apeman ] ) then
54978: LD_VAR 0 8
54982: PPUSH
54983: LD_INT 25
54985: PUSH
54986: LD_INT 12
54988: PUSH
54989: EMPTY
54990: LIST
54991: LIST
54992: PPUSH
54993: CALL_OW 72
54997: NOT
54998: IFFALSE 55008
// control := control_manual ;
55000: LD_ADDR_VAR 0 4
55004: PUSH
55005: LD_INT 1
55007: ST_TO_ADDR
// tmp := GetFacExt ( factory ) ;
55008: LD_ADDR_VAR 0 8
55012: PUSH
55013: LD_VAR 0 1
55017: PPUSH
55018: CALL 54705 0 1
55022: ST_TO_ADDR
// if tmp then
55023: LD_VAR 0 8
55027: IFFALSE 55070
// begin for i in tmp do
55029: LD_ADDR_VAR 0 7
55033: PUSH
55034: LD_VAR 0 8
55038: PUSH
55039: FOR_IN
55040: IFFALSE 55068
// if i [ 1 ] = b_ext_radio then
55042: LD_VAR 0 7
55046: PUSH
55047: LD_INT 1
55049: ARRAY
55050: PUSH
55051: LD_INT 22
55053: EQUAL
55054: IFFALSE 55066
// begin control := control_remote ;
55056: LD_ADDR_VAR 0 4
55060: PUSH
55061: LD_INT 2
55063: ST_TO_ADDR
// break ;
55064: GO 55068
// end ;
55066: GO 55039
55068: POP
55069: POP
// end ; end ; if CanBeConstructed ( factory , chassis , engine , control , weapon ) then
55070: LD_VAR 0 1
55074: PPUSH
55075: LD_VAR 0 2
55079: PPUSH
55080: LD_VAR 0 3
55084: PPUSH
55085: LD_VAR 0 4
55089: PPUSH
55090: LD_VAR 0 5
55094: PPUSH
55095: CALL_OW 448
55099: IFFALSE 55134
// begin result := [ chassis , engine , control , weapon ] ;
55101: LD_ADDR_VAR 0 6
55105: PUSH
55106: LD_VAR 0 2
55110: PUSH
55111: LD_VAR 0 3
55115: PUSH
55116: LD_VAR 0 4
55120: PUSH
55121: LD_VAR 0 5
55125: PUSH
55126: EMPTY
55127: LIST
55128: LIST
55129: LIST
55130: LIST
55131: ST_TO_ADDR
// exit ;
55132: GO 55546
// end ; _chassis := AvailableChassisList ( factory ) ;
55134: LD_ADDR_VAR 0 9
55138: PUSH
55139: LD_VAR 0 1
55143: PPUSH
55144: CALL_OW 475
55148: ST_TO_ADDR
// _engine := AvailableEngineList ( factory ) ;
55149: LD_ADDR_VAR 0 11
55153: PUSH
55154: LD_VAR 0 1
55158: PPUSH
55159: CALL_OW 476
55163: ST_TO_ADDR
// _control := AvailableControlList ( factory ) ;
55164: LD_ADDR_VAR 0 12
55168: PUSH
55169: LD_VAR 0 1
55173: PPUSH
55174: CALL_OW 477
55178: ST_TO_ADDR
// _weapon := AvailableWeaponList ( factory ) ;
55179: LD_ADDR_VAR 0 10
55183: PUSH
55184: LD_VAR 0 1
55188: PPUSH
55189: CALL_OW 478
55193: ST_TO_ADDR
// if not _chassis or not _engine or not _control or not _weapon then
55194: LD_VAR 0 9
55198: NOT
55199: PUSH
55200: LD_VAR 0 11
55204: NOT
55205: OR
55206: PUSH
55207: LD_VAR 0 12
55211: NOT
55212: OR
55213: PUSH
55214: LD_VAR 0 10
55218: NOT
55219: OR
55220: IFFALSE 55255
// begin result := [ chassis , engine , control , weapon ] ;
55222: LD_ADDR_VAR 0 6
55226: PUSH
55227: LD_VAR 0 2
55231: PUSH
55232: LD_VAR 0 3
55236: PUSH
55237: LD_VAR 0 4
55241: PUSH
55242: LD_VAR 0 5
55246: PUSH
55247: EMPTY
55248: LIST
55249: LIST
55250: LIST
55251: LIST
55252: ST_TO_ADDR
// exit ;
55253: GO 55546
// end ; if not chassis in _chassis then
55255: LD_VAR 0 2
55259: PUSH
55260: LD_VAR 0 9
55264: IN
55265: NOT
55266: IFFALSE 55292
// chassis := _chassis [ rand ( 1 , _chassis ) ] ;
55268: LD_ADDR_VAR 0 2
55272: PUSH
55273: LD_VAR 0 9
55277: PUSH
55278: LD_INT 1
55280: PPUSH
55281: LD_VAR 0 9
55285: PPUSH
55286: CALL_OW 12
55290: ARRAY
55291: ST_TO_ADDR
// if not EngineCanBeMount ( chassis , engine ) then
55292: LD_VAR 0 2
55296: PPUSH
55297: LD_VAR 0 3
55301: PPUSH
55302: CALL 55551 0 2
55306: NOT
55307: IFFALSE 55366
// repeat engine := _engine [ 1 ] ;
55309: LD_ADDR_VAR 0 3
55313: PUSH
55314: LD_VAR 0 11
55318: PUSH
55319: LD_INT 1
55321: ARRAY
55322: ST_TO_ADDR
// _engine := Delete ( _engine , 1 ) ;
55323: LD_ADDR_VAR 0 11
55327: PUSH
55328: LD_VAR 0 11
55332: PPUSH
55333: LD_INT 1
55335: PPUSH
55336: CALL_OW 3
55340: ST_TO_ADDR
// until EngineCanBeMount ( chassis , engine ) or _engine = [ ] ;
55341: LD_VAR 0 2
55345: PPUSH
55346: LD_VAR 0 3
55350: PPUSH
55351: CALL 55551 0 2
55355: PUSH
55356: LD_VAR 0 11
55360: PUSH
55361: EMPTY
55362: EQUAL
55363: OR
55364: IFFALSE 55309
// if not control in _control then
55366: LD_VAR 0 4
55370: PUSH
55371: LD_VAR 0 12
55375: IN
55376: NOT
55377: IFFALSE 55403
// control := _control [ rand ( 1 , _control ) ] ;
55379: LD_ADDR_VAR 0 4
55383: PUSH
55384: LD_VAR 0 12
55388: PUSH
55389: LD_INT 1
55391: PPUSH
55392: LD_VAR 0 12
55396: PPUSH
55397: CALL_OW 12
55401: ARRAY
55402: ST_TO_ADDR
// if not WeaponCanBeMount ( chassis , weapon ) then
55403: LD_VAR 0 2
55407: PPUSH
55408: LD_VAR 0 5
55412: PPUSH
55413: CALL 55771 0 2
55417: NOT
55418: IFFALSE 55477
// repeat weapon := _weapon [ 1 ] ;
55420: LD_ADDR_VAR 0 5
55424: PUSH
55425: LD_VAR 0 10
55429: PUSH
55430: LD_INT 1
55432: ARRAY
55433: ST_TO_ADDR
// _weapon := Delete ( _weapon , 1 ) ;
55434: LD_ADDR_VAR 0 10
55438: PUSH
55439: LD_VAR 0 10
55443: PPUSH
55444: LD_INT 1
55446: PPUSH
55447: CALL_OW 3
55451: ST_TO_ADDR
// until WeaponCanBeMount ( chassis , weapon ) or _weapon = [ ] ;
55452: LD_VAR 0 2
55456: PPUSH
55457: LD_VAR 0 5
55461: PPUSH
55462: CALL 55771 0 2
55466: PUSH
55467: LD_VAR 0 10
55471: PUSH
55472: EMPTY
55473: EQUAL
55474: OR
55475: IFFALSE 55420
// result := [ ] ;
55477: LD_ADDR_VAR 0 6
55481: PUSH
55482: EMPTY
55483: ST_TO_ADDR
// if CanBeConstructed ( factory , chassis , engine , control , weapon ) then
55484: LD_VAR 0 1
55488: PPUSH
55489: LD_VAR 0 2
55493: PPUSH
55494: LD_VAR 0 3
55498: PPUSH
55499: LD_VAR 0 4
55503: PPUSH
55504: LD_VAR 0 5
55508: PPUSH
55509: CALL_OW 448
55513: IFFALSE 55546
// result := [ chassis , engine , control , weapon ] ;
55515: LD_ADDR_VAR 0 6
55519: PUSH
55520: LD_VAR 0 2
55524: PUSH
55525: LD_VAR 0 3
55529: PUSH
55530: LD_VAR 0 4
55534: PUSH
55535: LD_VAR 0 5
55539: PUSH
55540: EMPTY
55541: LIST
55542: LIST
55543: LIST
55544: LIST
55545: ST_TO_ADDR
// end ;
55546: LD_VAR 0 6
55550: RET
// export function EngineCanBeMount ( chassis , engine ) ; begin
55551: LD_INT 0
55553: PPUSH
// if not chassis or not engine then
55554: LD_VAR 0 1
55558: NOT
55559: PUSH
55560: LD_VAR 0 2
55564: NOT
55565: OR
55566: IFFALSE 55570
// exit ;
55568: GO 55766
// case engine of engine_solar :
55570: LD_VAR 0 2
55574: PUSH
55575: LD_INT 2
55577: DOUBLE
55578: EQUAL
55579: IFTRUE 55583
55581: GO 55621
55583: POP
// result := [ ar_hovercraft , ar_light_trike , ar_medium_trike , ar_half_tracked , us_light_wheeled , us_medium_wheeled , us_medium_tracked ] ; engine_combustion :
55584: LD_ADDR_VAR 0 3
55588: PUSH
55589: LD_INT 11
55591: PUSH
55592: LD_INT 12
55594: PUSH
55595: LD_INT 13
55597: PUSH
55598: LD_INT 14
55600: PUSH
55601: LD_INT 1
55603: PUSH
55604: LD_INT 2
55606: PUSH
55607: LD_INT 3
55609: PUSH
55610: EMPTY
55611: LIST
55612: LIST
55613: LIST
55614: LIST
55615: LIST
55616: LIST
55617: LIST
55618: ST_TO_ADDR
55619: GO 55750
55621: LD_INT 1
55623: DOUBLE
55624: EQUAL
55625: IFTRUE 55629
55627: GO 55691
55629: POP
// result := [ ar_hovercraft , ar_light_trike , ar_medium_trike , ar_half_tracked , us_light_wheeled , us_medium_wheeled , us_medium_tracked , us_heavy_tracked , us_morphling , ru_medium_wheeled , ru_heavy_wheeled , ru_medium_tracked , ru_heavy_tracked ] ; engine_siberite :
55630: LD_ADDR_VAR 0 3
55634: PUSH
55635: LD_INT 11
55637: PUSH
55638: LD_INT 12
55640: PUSH
55641: LD_INT 13
55643: PUSH
55644: LD_INT 14
55646: PUSH
55647: LD_INT 1
55649: PUSH
55650: LD_INT 2
55652: PUSH
55653: LD_INT 3
55655: PUSH
55656: LD_INT 4
55658: PUSH
55659: LD_INT 5
55661: PUSH
55662: LD_INT 21
55664: PUSH
55665: LD_INT 23
55667: PUSH
55668: LD_INT 22
55670: PUSH
55671: LD_INT 24
55673: PUSH
55674: EMPTY
55675: LIST
55676: LIST
55677: LIST
55678: LIST
55679: LIST
55680: LIST
55681: LIST
55682: LIST
55683: LIST
55684: LIST
55685: LIST
55686: LIST
55687: LIST
55688: ST_TO_ADDR
55689: GO 55750
55691: LD_INT 3
55693: DOUBLE
55694: EQUAL
55695: IFTRUE 55699
55697: GO 55749
55699: POP
// result := [ ar_medium_trike , ar_half_tracked , us_medium_wheeled , us_medium_tracked , us_heavy_tracked , us_morphling , ru_medium_wheeled , ru_medium_tracked , ru_heavy_wheeled , ru_heavy_tracked ] ; end ;
55700: LD_ADDR_VAR 0 3
55704: PUSH
55705: LD_INT 13
55707: PUSH
55708: LD_INT 14
55710: PUSH
55711: LD_INT 2
55713: PUSH
55714: LD_INT 3
55716: PUSH
55717: LD_INT 4
55719: PUSH
55720: LD_INT 5
55722: PUSH
55723: LD_INT 21
55725: PUSH
55726: LD_INT 22
55728: PUSH
55729: LD_INT 23
55731: PUSH
55732: LD_INT 24
55734: PUSH
55735: EMPTY
55736: LIST
55737: LIST
55738: LIST
55739: LIST
55740: LIST
55741: LIST
55742: LIST
55743: LIST
55744: LIST
55745: LIST
55746: ST_TO_ADDR
55747: GO 55750
55749: POP
// result := ( chassis in result ) ;
55750: LD_ADDR_VAR 0 3
55754: PUSH
55755: LD_VAR 0 1
55759: PUSH
55760: LD_VAR 0 3
55764: IN
55765: ST_TO_ADDR
// end ;
55766: LD_VAR 0 3
55770: RET
// export function WeaponCanBeMount ( chassis , weapon ) ; begin
55771: LD_INT 0
55773: PPUSH
// if not chassis or not weapon then
55774: LD_VAR 0 1
55778: NOT
55779: PUSH
55780: LD_VAR 0 2
55784: NOT
55785: OR
55786: IFFALSE 55790
// exit ;
55788: GO 56816
// case weapon of us_machine_gun :
55790: LD_VAR 0 2
55794: PUSH
55795: LD_INT 2
55797: DOUBLE
55798: EQUAL
55799: IFTRUE 55803
55801: GO 55833
55803: POP
// result := [ us_light_wheeled , us_medium_wheeled , us_medium_tracked , us_heavy_tracked , us_morphling ] ; us_light_gun :
55804: LD_ADDR_VAR 0 3
55808: PUSH
55809: LD_INT 1
55811: PUSH
55812: LD_INT 2
55814: PUSH
55815: LD_INT 3
55817: PUSH
55818: LD_INT 4
55820: PUSH
55821: LD_INT 5
55823: PUSH
55824: EMPTY
55825: LIST
55826: LIST
55827: LIST
55828: LIST
55829: LIST
55830: ST_TO_ADDR
55831: GO 56800
55833: LD_INT 3
55835: DOUBLE
55836: EQUAL
55837: IFTRUE 55841
55839: GO 55871
55841: POP
// result := [ us_light_wheeled , us_medium_wheeled , us_medium_tracked , us_heavy_tracked , us_morphling ] ; us_radar :
55842: LD_ADDR_VAR 0 3
55846: PUSH
55847: LD_INT 1
55849: PUSH
55850: LD_INT 2
55852: PUSH
55853: LD_INT 3
55855: PUSH
55856: LD_INT 4
55858: PUSH
55859: LD_INT 5
55861: PUSH
55862: EMPTY
55863: LIST
55864: LIST
55865: LIST
55866: LIST
55867: LIST
55868: ST_TO_ADDR
55869: GO 56800
55871: LD_INT 11
55873: DOUBLE
55874: EQUAL
55875: IFTRUE 55879
55877: GO 55909
55879: POP
// result := [ us_light_wheeled , us_medium_wheeled , us_medium_tracked , us_heavy_tracked , us_morphling ] ; us_gatling_gun :
55880: LD_ADDR_VAR 0 3
55884: PUSH
55885: LD_INT 1
55887: PUSH
55888: LD_INT 2
55890: PUSH
55891: LD_INT 3
55893: PUSH
55894: LD_INT 4
55896: PUSH
55897: LD_INT 5
55899: PUSH
55900: EMPTY
55901: LIST
55902: LIST
55903: LIST
55904: LIST
55905: LIST
55906: ST_TO_ADDR
55907: GO 56800
55909: LD_INT 4
55911: DOUBLE
55912: EQUAL
55913: IFTRUE 55917
55915: GO 55943
55917: POP
// result := [ us_medium_wheeled , us_medium_tracked , us_heavy_tracked , us_morphling ] ; us_double_gun :
55918: LD_ADDR_VAR 0 3
55922: PUSH
55923: LD_INT 2
55925: PUSH
55926: LD_INT 3
55928: PUSH
55929: LD_INT 4
55931: PUSH
55932: LD_INT 5
55934: PUSH
55935: EMPTY
55936: LIST
55937: LIST
55938: LIST
55939: LIST
55940: ST_TO_ADDR
55941: GO 56800
55943: LD_INT 5
55945: DOUBLE
55946: EQUAL
55947: IFTRUE 55951
55949: GO 55977
55951: POP
// result := [ us_medium_wheeled , us_medium_tracked , us_heavy_tracked , us_morphling ] ; us_laser :
55952: LD_ADDR_VAR 0 3
55956: PUSH
55957: LD_INT 2
55959: PUSH
55960: LD_INT 3
55962: PUSH
55963: LD_INT 4
55965: PUSH
55966: LD_INT 5
55968: PUSH
55969: EMPTY
55970: LIST
55971: LIST
55972: LIST
55973: LIST
55974: ST_TO_ADDR
55975: GO 56800
55977: LD_INT 9
55979: DOUBLE
55980: EQUAL
55981: IFTRUE 55985
55983: GO 56011
55985: POP
// result := [ us_medium_wheeled , us_medium_tracked , us_heavy_tracked , us_morphling ] ; us_rocket_launcher :
55986: LD_ADDR_VAR 0 3
55990: PUSH
55991: LD_INT 2
55993: PUSH
55994: LD_INT 3
55996: PUSH
55997: LD_INT 4
55999: PUSH
56000: LD_INT 5
56002: PUSH
56003: EMPTY
56004: LIST
56005: LIST
56006: LIST
56007: LIST
56008: ST_TO_ADDR
56009: GO 56800
56011: LD_INT 7
56013: DOUBLE
56014: EQUAL
56015: IFTRUE 56019
56017: GO 56045
56019: POP
// result := [ us_medium_wheeled , us_medium_tracked , us_heavy_tracked , us_morphling ] ; us_cargo_bay :
56020: LD_ADDR_VAR 0 3
56024: PUSH
56025: LD_INT 2
56027: PUSH
56028: LD_INT 3
56030: PUSH
56031: LD_INT 4
56033: PUSH
56034: LD_INT 5
56036: PUSH
56037: EMPTY
56038: LIST
56039: LIST
56040: LIST
56041: LIST
56042: ST_TO_ADDR
56043: GO 56800
56045: LD_INT 12
56047: DOUBLE
56048: EQUAL
56049: IFTRUE 56053
56051: GO 56079
56053: POP
// result := [ us_medium_wheeled , us_medium_tracked , us_heavy_tracked , us_morphling ] ; us_crane :
56054: LD_ADDR_VAR 0 3
56058: PUSH
56059: LD_INT 2
56061: PUSH
56062: LD_INT 3
56064: PUSH
56065: LD_INT 4
56067: PUSH
56068: LD_INT 5
56070: PUSH
56071: EMPTY
56072: LIST
56073: LIST
56074: LIST
56075: LIST
56076: ST_TO_ADDR
56077: GO 56800
56079: LD_INT 13
56081: DOUBLE
56082: EQUAL
56083: IFTRUE 56087
56085: GO 56113
56087: POP
// result := [ us_medium_wheeled , us_medium_tracked , us_heavy_tracked , us_morphling ] ; us_bulldozer :
56088: LD_ADDR_VAR 0 3
56092: PUSH
56093: LD_INT 2
56095: PUSH
56096: LD_INT 3
56098: PUSH
56099: LD_INT 4
56101: PUSH
56102: LD_INT 5
56104: PUSH
56105: EMPTY
56106: LIST
56107: LIST
56108: LIST
56109: LIST
56110: ST_TO_ADDR
56111: GO 56800
56113: LD_INT 14
56115: DOUBLE
56116: EQUAL
56117: IFTRUE 56121
56119: GO 56139
56121: POP
// result := [ us_heavy_tracked , us_morphling ] ; us_heavy_gun :
56122: LD_ADDR_VAR 0 3
56126: PUSH
56127: LD_INT 4
56129: PUSH
56130: LD_INT 5
56132: PUSH
56133: EMPTY
56134: LIST
56135: LIST
56136: ST_TO_ADDR
56137: GO 56800
56139: LD_INT 6
56141: DOUBLE
56142: EQUAL
56143: IFTRUE 56147
56145: GO 56165
56147: POP
// result := [ us_heavy_tracked , us_morphling ] ; us_double_laser :
56148: LD_ADDR_VAR 0 3
56152: PUSH
56153: LD_INT 4
56155: PUSH
56156: LD_INT 5
56158: PUSH
56159: EMPTY
56160: LIST
56161: LIST
56162: ST_TO_ADDR
56163: GO 56800
56165: LD_INT 10
56167: DOUBLE
56168: EQUAL
56169: IFTRUE 56173
56171: GO 56191
56173: POP
// result := [ us_heavy_tracked , us_morphling ] ; ar_multimissile_ballista :
56174: LD_ADDR_VAR 0 3
56178: PUSH
56179: LD_INT 4
56181: PUSH
56182: LD_INT 5
56184: PUSH
56185: EMPTY
56186: LIST
56187: LIST
56188: ST_TO_ADDR
56189: GO 56800
56191: LD_INT 22
56193: DOUBLE
56194: EQUAL
56195: IFTRUE 56199
56197: GO 56225
56199: POP
// result := [ ar_hovercraft , ar_light_trike , ar_medium_trike , ar_half_tracked ] ; ar_light_gun :
56200: LD_ADDR_VAR 0 3
56204: PUSH
56205: LD_INT 11
56207: PUSH
56208: LD_INT 12
56210: PUSH
56211: LD_INT 13
56213: PUSH
56214: LD_INT 14
56216: PUSH
56217: EMPTY
56218: LIST
56219: LIST
56220: LIST
56221: LIST
56222: ST_TO_ADDR
56223: GO 56800
56225: LD_INT 23
56227: DOUBLE
56228: EQUAL
56229: IFTRUE 56233
56231: GO 56259
56233: POP
// result := [ ar_hovercraft , ar_light_trike , ar_medium_trike , ar_half_tracked ] ; ar_double_machine_gun :
56234: LD_ADDR_VAR 0 3
56238: PUSH
56239: LD_INT 11
56241: PUSH
56242: LD_INT 12
56244: PUSH
56245: LD_INT 13
56247: PUSH
56248: LD_INT 14
56250: PUSH
56251: EMPTY
56252: LIST
56253: LIST
56254: LIST
56255: LIST
56256: ST_TO_ADDR
56257: GO 56800
56259: LD_INT 24
56261: DOUBLE
56262: EQUAL
56263: IFTRUE 56267
56265: GO 56293
56267: POP
// result := [ ar_hovercraft , ar_light_trike , ar_medium_trike , ar_half_tracked ] ; ar_radar :
56268: LD_ADDR_VAR 0 3
56272: PUSH
56273: LD_INT 11
56275: PUSH
56276: LD_INT 12
56278: PUSH
56279: LD_INT 13
56281: PUSH
56282: LD_INT 14
56284: PUSH
56285: EMPTY
56286: LIST
56287: LIST
56288: LIST
56289: LIST
56290: ST_TO_ADDR
56291: GO 56800
56293: LD_INT 30
56295: DOUBLE
56296: EQUAL
56297: IFTRUE 56301
56299: GO 56327
56301: POP
// result := [ ar_hovercraft , ar_light_trike , ar_medium_trike , ar_half_tracked ] ; ar_gatling_gun :
56302: LD_ADDR_VAR 0 3
56306: PUSH
56307: LD_INT 11
56309: PUSH
56310: LD_INT 12
56312: PUSH
56313: LD_INT 13
56315: PUSH
56316: LD_INT 14
56318: PUSH
56319: EMPTY
56320: LIST
56321: LIST
56322: LIST
56323: LIST
56324: ST_TO_ADDR
56325: GO 56800
56327: LD_INT 25
56329: DOUBLE
56330: EQUAL
56331: IFTRUE 56335
56333: GO 56353
56335: POP
// result := [ ar_medium_trike , ar_half_tracked ] ; ar_gun :
56336: LD_ADDR_VAR 0 3
56340: PUSH
56341: LD_INT 13
56343: PUSH
56344: LD_INT 14
56346: PUSH
56347: EMPTY
56348: LIST
56349: LIST
56350: ST_TO_ADDR
56351: GO 56800
56353: LD_INT 27
56355: DOUBLE
56356: EQUAL
56357: IFTRUE 56361
56359: GO 56379
56361: POP
// result := [ ar_medium_trike , ar_half_tracked ] ; ar_rocket_launcher :
56362: LD_ADDR_VAR 0 3
56366: PUSH
56367: LD_INT 13
56369: PUSH
56370: LD_INT 14
56372: PUSH
56373: EMPTY
56374: LIST
56375: LIST
56376: ST_TO_ADDR
56377: GO 56800
56379: LD_INT 28
56381: DOUBLE
56382: EQUAL
56383: IFTRUE 56387
56385: GO 56405
56387: POP
// result := [ ar_medium_trike , ar_half_tracked ] ; ar_selfpropelled_bomb :
56388: LD_ADDR_VAR 0 3
56392: PUSH
56393: LD_INT 13
56395: PUSH
56396: LD_INT 14
56398: PUSH
56399: EMPTY
56400: LIST
56401: LIST
56402: ST_TO_ADDR
56403: GO 56800
56405: LD_INT 29
56407: DOUBLE
56408: EQUAL
56409: IFTRUE 56413
56411: GO 56431
56413: POP
// result := [ ar_medium_trike , ar_half_tracked ] ; ar_control_tower :
56414: LD_ADDR_VAR 0 3
56418: PUSH
56419: LD_INT 13
56421: PUSH
56422: LD_INT 14
56424: PUSH
56425: EMPTY
56426: LIST
56427: LIST
56428: ST_TO_ADDR
56429: GO 56800
56431: LD_INT 31
56433: DOUBLE
56434: EQUAL
56435: IFTRUE 56439
56437: GO 56457
56439: POP
// result := [ ar_medium_trike , ar_half_tracked ] ; ar_flame_thrower :
56440: LD_ADDR_VAR 0 3
56444: PUSH
56445: LD_INT 13
56447: PUSH
56448: LD_INT 14
56450: PUSH
56451: EMPTY
56452: LIST
56453: LIST
56454: ST_TO_ADDR
56455: GO 56800
56457: LD_INT 26
56459: DOUBLE
56460: EQUAL
56461: IFTRUE 56465
56463: GO 56483
56465: POP
// result := [ ar_medium_trike , ar_half_tracked ] ; ru_heavy_machine_gun :
56466: LD_ADDR_VAR 0 3
56470: PUSH
56471: LD_INT 13
56473: PUSH
56474: LD_INT 14
56476: PUSH
56477: EMPTY
56478: LIST
56479: LIST
56480: ST_TO_ADDR
56481: GO 56800
56483: LD_INT 42
56485: DOUBLE
56486: EQUAL
56487: IFTRUE 56491
56489: GO 56517
56491: POP
// result := [ ru_medium_wheeled , ru_medium_tracked , ru_heavy_wheeled , ru_heavy_tracked ] ; ru_gatling_gun :
56492: LD_ADDR_VAR 0 3
56496: PUSH
56497: LD_INT 21
56499: PUSH
56500: LD_INT 22
56502: PUSH
56503: LD_INT 23
56505: PUSH
56506: LD_INT 24
56508: PUSH
56509: EMPTY
56510: LIST
56511: LIST
56512: LIST
56513: LIST
56514: ST_TO_ADDR
56515: GO 56800
56517: LD_INT 43
56519: DOUBLE
56520: EQUAL
56521: IFTRUE 56525
56523: GO 56551
56525: POP
// result := [ ru_medium_wheeled , ru_medium_tracked , ru_heavy_wheeled , ru_heavy_tracked ] ; ru_gun :
56526: LD_ADDR_VAR 0 3
56530: PUSH
56531: LD_INT 21
56533: PUSH
56534: LD_INT 22
56536: PUSH
56537: LD_INT 23
56539: PUSH
56540: LD_INT 24
56542: PUSH
56543: EMPTY
56544: LIST
56545: LIST
56546: LIST
56547: LIST
56548: ST_TO_ADDR
56549: GO 56800
56551: LD_INT 44
56553: DOUBLE
56554: EQUAL
56555: IFTRUE 56559
56557: GO 56585
56559: POP
// result := [ ru_medium_wheeled , ru_medium_tracked , ru_heavy_wheeled , ru_heavy_tracked ] ; ru_rocket_launcher :
56560: LD_ADDR_VAR 0 3
56564: PUSH
56565: LD_INT 21
56567: PUSH
56568: LD_INT 22
56570: PUSH
56571: LD_INT 23
56573: PUSH
56574: LD_INT 24
56576: PUSH
56577: EMPTY
56578: LIST
56579: LIST
56580: LIST
56581: LIST
56582: ST_TO_ADDR
56583: GO 56800
56585: LD_INT 45
56587: DOUBLE
56588: EQUAL
56589: IFTRUE 56593
56591: GO 56619
56593: POP
// result := [ ru_medium_wheeled , ru_medium_tracked , ru_heavy_wheeled , ru_heavy_tracked ] ; ru_time_lapser :
56594: LD_ADDR_VAR 0 3
56598: PUSH
56599: LD_INT 21
56601: PUSH
56602: LD_INT 22
56604: PUSH
56605: LD_INT 23
56607: PUSH
56608: LD_INT 24
56610: PUSH
56611: EMPTY
56612: LIST
56613: LIST
56614: LIST
56615: LIST
56616: ST_TO_ADDR
56617: GO 56800
56619: LD_INT 49
56621: DOUBLE
56622: EQUAL
56623: IFTRUE 56627
56625: GO 56653
56627: POP
// result := [ ru_medium_wheeled , ru_medium_tracked , ru_heavy_wheeled , ru_heavy_tracked ] ; ru_cargo_bay :
56628: LD_ADDR_VAR 0 3
56632: PUSH
56633: LD_INT 21
56635: PUSH
56636: LD_INT 22
56638: PUSH
56639: LD_INT 23
56641: PUSH
56642: LD_INT 24
56644: PUSH
56645: EMPTY
56646: LIST
56647: LIST
56648: LIST
56649: LIST
56650: ST_TO_ADDR
56651: GO 56800
56653: LD_INT 51
56655: DOUBLE
56656: EQUAL
56657: IFTRUE 56661
56659: GO 56687
56661: POP
// result := [ ru_medium_wheeled , ru_medium_tracked , ru_heavy_wheeled , ru_heavy_tracked ] ; ru_crane :
56662: LD_ADDR_VAR 0 3
56666: PUSH
56667: LD_INT 21
56669: PUSH
56670: LD_INT 22
56672: PUSH
56673: LD_INT 23
56675: PUSH
56676: LD_INT 24
56678: PUSH
56679: EMPTY
56680: LIST
56681: LIST
56682: LIST
56683: LIST
56684: ST_TO_ADDR
56685: GO 56800
56687: LD_INT 52
56689: DOUBLE
56690: EQUAL
56691: IFTRUE 56695
56693: GO 56721
56695: POP
// result := [ ru_medium_wheeled , ru_medium_tracked , ru_heavy_wheeled , ru_heavy_tracked ] ; ru_bulldozer :
56696: LD_ADDR_VAR 0 3
56700: PUSH
56701: LD_INT 21
56703: PUSH
56704: LD_INT 22
56706: PUSH
56707: LD_INT 23
56709: PUSH
56710: LD_INT 24
56712: PUSH
56713: EMPTY
56714: LIST
56715: LIST
56716: LIST
56717: LIST
56718: ST_TO_ADDR
56719: GO 56800
56721: LD_INT 53
56723: DOUBLE
56724: EQUAL
56725: IFTRUE 56729
56727: GO 56747
56729: POP
// result := [ ru_heavy_wheeled , ru_heavy_tracked ] ; ru_heavy_gun :
56730: LD_ADDR_VAR 0 3
56734: PUSH
56735: LD_INT 23
56737: PUSH
56738: LD_INT 24
56740: PUSH
56741: EMPTY
56742: LIST
56743: LIST
56744: ST_TO_ADDR
56745: GO 56800
56747: LD_INT 46
56749: DOUBLE
56750: EQUAL
56751: IFTRUE 56755
56753: GO 56773
56755: POP
// result := [ ru_heavy_wheeled , ru_heavy_tracked ] ; ru_rocket :
56756: LD_ADDR_VAR 0 3
56760: PUSH
56761: LD_INT 23
56763: PUSH
56764: LD_INT 24
56766: PUSH
56767: EMPTY
56768: LIST
56769: LIST
56770: ST_TO_ADDR
56771: GO 56800
56773: LD_INT 47
56775: DOUBLE
56776: EQUAL
56777: IFTRUE 56781
56779: GO 56799
56781: POP
// result := [ ru_heavy_wheeled , ru_heavy_tracked ] ; end ;
56782: LD_ADDR_VAR 0 3
56786: PUSH
56787: LD_INT 23
56789: PUSH
56790: LD_INT 24
56792: PUSH
56793: EMPTY
56794: LIST
56795: LIST
56796: ST_TO_ADDR
56797: GO 56800
56799: POP
// result := ( chassis in result ) ;
56800: LD_ADDR_VAR 0 3
56804: PUSH
56805: LD_VAR 0 1
56809: PUSH
56810: LD_VAR 0 3
56814: IN
56815: ST_TO_ADDR
// end ;
56816: LD_VAR 0 3
56820: RET
// export function Reindex ( array , i_from , i_to , direction ) ; var i , j , k , d , tmp , length ; begin
56821: LD_INT 0
56823: PPUSH
56824: PPUSH
56825: PPUSH
56826: PPUSH
56827: PPUSH
56828: PPUSH
56829: PPUSH
// result := array ;
56830: LD_ADDR_VAR 0 5
56834: PUSH
56835: LD_VAR 0 1
56839: ST_TO_ADDR
// if not array or not i_from or not i_to or i_from > array or i_to > array then
56840: LD_VAR 0 1
56844: NOT
56845: PUSH
56846: LD_VAR 0 2
56850: NOT
56851: OR
56852: PUSH
56853: LD_VAR 0 3
56857: NOT
56858: OR
56859: PUSH
56860: LD_VAR 0 2
56864: PUSH
56865: LD_VAR 0 1
56869: GREATER
56870: OR
56871: PUSH
56872: LD_VAR 0 3
56876: PUSH
56877: LD_VAR 0 1
56881: GREATER
56882: OR
56883: IFFALSE 56887
// exit ;
56885: GO 57183
// if direction then
56887: LD_VAR 0 4
56891: IFFALSE 56955
// begin d := 1 ;
56893: LD_ADDR_VAR 0 9
56897: PUSH
56898: LD_INT 1
56900: ST_TO_ADDR
// if i_from > i_to then
56901: LD_VAR 0 2
56905: PUSH
56906: LD_VAR 0 3
56910: GREATER
56911: IFFALSE 56937
// length := ( array - i_from ) + i_to else
56913: LD_ADDR_VAR 0 11
56917: PUSH
56918: LD_VAR 0 1
56922: PUSH
56923: LD_VAR 0 2
56927: MINUS
56928: PUSH
56929: LD_VAR 0 3
56933: PLUS
56934: ST_TO_ADDR
56935: GO 56953
// length := i_to - i_from ;
56937: LD_ADDR_VAR 0 11
56941: PUSH
56942: LD_VAR 0 3
56946: PUSH
56947: LD_VAR 0 2
56951: MINUS
56952: ST_TO_ADDR
// end else
56953: GO 57016
// begin d := - 1 ;
56955: LD_ADDR_VAR 0 9
56959: PUSH
56960: LD_INT 1
56962: NEG
56963: ST_TO_ADDR
// if i_from > i_to then
56964: LD_VAR 0 2
56968: PUSH
56969: LD_VAR 0 3
56973: GREATER
56974: IFFALSE 56994
// length := i_from - i_to else
56976: LD_ADDR_VAR 0 11
56980: PUSH
56981: LD_VAR 0 2
56985: PUSH
56986: LD_VAR 0 3
56990: MINUS
56991: ST_TO_ADDR
56992: GO 57016
// length := ( array - i_to ) + i_from ;
56994: LD_ADDR_VAR 0 11
56998: PUSH
56999: LD_VAR 0 1
57003: PUSH
57004: LD_VAR 0 3
57008: MINUS
57009: PUSH
57010: LD_VAR 0 2
57014: PLUS
57015: ST_TO_ADDR
// end ; if not length then
57016: LD_VAR 0 11
57020: NOT
57021: IFFALSE 57025
// exit ;
57023: GO 57183
// tmp := array ;
57025: LD_ADDR_VAR 0 10
57029: PUSH
57030: LD_VAR 0 1
57034: ST_TO_ADDR
// for i = 1 to length do
57035: LD_ADDR_VAR 0 6
57039: PUSH
57040: DOUBLE
57041: LD_INT 1
57043: DEC
57044: ST_TO_ADDR
57045: LD_VAR 0 11
57049: PUSH
57050: FOR_TO
57051: IFFALSE 57171
// begin for j = 1 to array do
57053: LD_ADDR_VAR 0 7
57057: PUSH
57058: DOUBLE
57059: LD_INT 1
57061: DEC
57062: ST_TO_ADDR
57063: LD_VAR 0 1
57067: PUSH
57068: FOR_TO
57069: IFFALSE 57157
// begin k := j + d ;
57071: LD_ADDR_VAR 0 8
57075: PUSH
57076: LD_VAR 0 7
57080: PUSH
57081: LD_VAR 0 9
57085: PLUS
57086: ST_TO_ADDR
// if k > array then
57087: LD_VAR 0 8
57091: PUSH
57092: LD_VAR 0 1
57096: GREATER
57097: IFFALSE 57107
// k := 1 ;
57099: LD_ADDR_VAR 0 8
57103: PUSH
57104: LD_INT 1
57106: ST_TO_ADDR
// if not k then
57107: LD_VAR 0 8
57111: NOT
57112: IFFALSE 57124
// k := array ;
57114: LD_ADDR_VAR 0 8
57118: PUSH
57119: LD_VAR 0 1
57123: ST_TO_ADDR
// tmp := Replace ( tmp , k , array [ j ] ) ;
57124: LD_ADDR_VAR 0 10
57128: PUSH
57129: LD_VAR 0 10
57133: PPUSH
57134: LD_VAR 0 8
57138: PPUSH
57139: LD_VAR 0 1
57143: PUSH
57144: LD_VAR 0 7
57148: ARRAY
57149: PPUSH
57150: CALL_OW 1
57154: ST_TO_ADDR
// end ;
57155: GO 57068
57157: POP
57158: POP
// array := tmp ;
57159: LD_ADDR_VAR 0 1
57163: PUSH
57164: LD_VAR 0 10
57168: ST_TO_ADDR
// end ;
57169: GO 57050
57171: POP
57172: POP
// result := array ;
57173: LD_ADDR_VAR 0 5
57177: PUSH
57178: LD_VAR 0 1
57182: ST_TO_ADDR
// end ;
57183: LD_VAR 0 5
57187: RET
// export function GetElementIndex ( array , value ) ; var i ; begin
57188: LD_INT 0
57190: PPUSH
57191: PPUSH
// result := 0 ;
57192: LD_ADDR_VAR 0 3
57196: PUSH
57197: LD_INT 0
57199: ST_TO_ADDR
// if not array or not value in array then
57200: LD_VAR 0 1
57204: NOT
57205: PUSH
57206: LD_VAR 0 2
57210: PUSH
57211: LD_VAR 0 1
57215: IN
57216: NOT
57217: OR
57218: IFFALSE 57222
// exit ;
57220: GO 57276
// for i = 1 to array do
57222: LD_ADDR_VAR 0 4
57226: PUSH
57227: DOUBLE
57228: LD_INT 1
57230: DEC
57231: ST_TO_ADDR
57232: LD_VAR 0 1
57236: PUSH
57237: FOR_TO
57238: IFFALSE 57274
// if value = array [ i ] then
57240: LD_VAR 0 2
57244: PUSH
57245: LD_VAR 0 1
57249: PUSH
57250: LD_VAR 0 4
57254: ARRAY
57255: EQUAL
57256: IFFALSE 57272
// begin result := i ;
57258: LD_ADDR_VAR 0 3
57262: PUSH
57263: LD_VAR 0 4
57267: ST_TO_ADDR
// exit ;
57268: POP
57269: POP
57270: GO 57276
// end ;
57272: GO 57237
57274: POP
57275: POP
// end ;
57276: LD_VAR 0 3
57280: RET
// export function PrepareVehicle ( chassis , engine , control , weapon , fuel ) ; begin
57281: LD_INT 0
57283: PPUSH
// vc_chassis := chassis ;
57284: LD_ADDR_OWVAR 37
57288: PUSH
57289: LD_VAR 0 1
57293: ST_TO_ADDR
// vc_engine := engine ;
57294: LD_ADDR_OWVAR 39
57298: PUSH
57299: LD_VAR 0 2
57303: ST_TO_ADDR
// vc_control := control ;
57304: LD_ADDR_OWVAR 38
57308: PUSH
57309: LD_VAR 0 3
57313: ST_TO_ADDR
// vc_weapon := weapon ;
57314: LD_ADDR_OWVAR 40
57318: PUSH
57319: LD_VAR 0 4
57323: ST_TO_ADDR
// vc_fuel_battery := fuel ;
57324: LD_ADDR_OWVAR 41
57328: PUSH
57329: LD_VAR 0 5
57333: ST_TO_ADDR
// end ;
57334: LD_VAR 0 6
57338: RET
// export function WantPlant ( unit ) ; var task ; begin
57339: LD_INT 0
57341: PPUSH
57342: PPUSH
// result := false ;
57343: LD_ADDR_VAR 0 2
57347: PUSH
57348: LD_INT 0
57350: ST_TO_ADDR
// task := GetTaskList ( unit ) ;
57351: LD_ADDR_VAR 0 3
57355: PUSH
57356: LD_VAR 0 1
57360: PPUSH
57361: CALL_OW 437
57365: ST_TO_ADDR
// if task then
57366: LD_VAR 0 3
57370: IFFALSE 57398
// if task [ 1 ] [ 1 ] = p then
57372: LD_VAR 0 3
57376: PUSH
57377: LD_INT 1
57379: ARRAY
57380: PUSH
57381: LD_INT 1
57383: ARRAY
57384: PUSH
57385: LD_STRING p
57387: EQUAL
57388: IFFALSE 57398
// result := true ;
57390: LD_ADDR_VAR 0 2
57394: PUSH
57395: LD_INT 1
57397: ST_TO_ADDR
// end ;
57398: LD_VAR 0 2
57402: RET
// export function ReplaceIn ( arr , pos , value ) ; var i , tmp , s_arr ; begin
57403: LD_INT 0
57405: PPUSH
57406: PPUSH
57407: PPUSH
57408: PPUSH
// if pos < 1 then
57409: LD_VAR 0 2
57413: PUSH
57414: LD_INT 1
57416: LESS
57417: IFFALSE 57421
// exit ;
57419: GO 57724
// if pos = 1 then
57421: LD_VAR 0 2
57425: PUSH
57426: LD_INT 1
57428: EQUAL
57429: IFFALSE 57462
// result := Replace ( arr , pos [ 1 ] , value ) else
57431: LD_ADDR_VAR 0 4
57435: PUSH
57436: LD_VAR 0 1
57440: PPUSH
57441: LD_VAR 0 2
57445: PUSH
57446: LD_INT 1
57448: ARRAY
57449: PPUSH
57450: LD_VAR 0 3
57454: PPUSH
57455: CALL_OW 1
57459: ST_TO_ADDR
57460: GO 57724
// begin tmp := arr ;
57462: LD_ADDR_VAR 0 6
57466: PUSH
57467: LD_VAR 0 1
57471: ST_TO_ADDR
// s_arr := [ tmp ] ;
57472: LD_ADDR_VAR 0 7
57476: PUSH
57477: LD_VAR 0 6
57481: PUSH
57482: EMPTY
57483: LIST
57484: ST_TO_ADDR
// for i = 1 to pos - 1 do
57485: LD_ADDR_VAR 0 5
57489: PUSH
57490: DOUBLE
57491: LD_INT 1
57493: DEC
57494: ST_TO_ADDR
57495: LD_VAR 0 2
57499: PUSH
57500: LD_INT 1
57502: MINUS
57503: PUSH
57504: FOR_TO
57505: IFFALSE 57550
// begin tmp := tmp [ pos [ i ] ] ;
57507: LD_ADDR_VAR 0 6
57511: PUSH
57512: LD_VAR 0 6
57516: PUSH
57517: LD_VAR 0 2
57521: PUSH
57522: LD_VAR 0 5
57526: ARRAY
57527: ARRAY
57528: ST_TO_ADDR
// s_arr := s_arr ^ [ tmp ] ;
57529: LD_ADDR_VAR 0 7
57533: PUSH
57534: LD_VAR 0 7
57538: PUSH
57539: LD_VAR 0 6
57543: PUSH
57544: EMPTY
57545: LIST
57546: ADD
57547: ST_TO_ADDR
// end ;
57548: GO 57504
57550: POP
57551: POP
// tmp := Replace ( tmp , pos [ pos ] , value ) ;
57552: LD_ADDR_VAR 0 6
57556: PUSH
57557: LD_VAR 0 6
57561: PPUSH
57562: LD_VAR 0 2
57566: PUSH
57567: LD_VAR 0 2
57571: ARRAY
57572: PPUSH
57573: LD_VAR 0 3
57577: PPUSH
57578: CALL_OW 1
57582: ST_TO_ADDR
// s_arr := Replace ( s_arr , s_arr , tmp ) ;
57583: LD_ADDR_VAR 0 7
57587: PUSH
57588: LD_VAR 0 7
57592: PPUSH
57593: LD_VAR 0 7
57597: PPUSH
57598: LD_VAR 0 6
57602: PPUSH
57603: CALL_OW 1
57607: ST_TO_ADDR
// for i = s_arr downto 2 do
57608: LD_ADDR_VAR 0 5
57612: PUSH
57613: DOUBLE
57614: LD_VAR 0 7
57618: INC
57619: ST_TO_ADDR
57620: LD_INT 2
57622: PUSH
57623: FOR_DOWNTO
57624: IFFALSE 57708
// begin tmp := Replace ( s_arr [ i - 1 ] , pos [ i - 1 ] , s_arr [ i ] ) ;
57626: LD_ADDR_VAR 0 6
57630: PUSH
57631: LD_VAR 0 7
57635: PUSH
57636: LD_VAR 0 5
57640: PUSH
57641: LD_INT 1
57643: MINUS
57644: ARRAY
57645: PPUSH
57646: LD_VAR 0 2
57650: PUSH
57651: LD_VAR 0 5
57655: PUSH
57656: LD_INT 1
57658: MINUS
57659: ARRAY
57660: PPUSH
57661: LD_VAR 0 7
57665: PUSH
57666: LD_VAR 0 5
57670: ARRAY
57671: PPUSH
57672: CALL_OW 1
57676: ST_TO_ADDR
// s_arr := Replace ( s_arr , i - 1 , tmp ) ;
57677: LD_ADDR_VAR 0 7
57681: PUSH
57682: LD_VAR 0 7
57686: PPUSH
57687: LD_VAR 0 5
57691: PUSH
57692: LD_INT 1
57694: MINUS
57695: PPUSH
57696: LD_VAR 0 6
57700: PPUSH
57701: CALL_OW 1
57705: ST_TO_ADDR
// end ;
57706: GO 57623
57708: POP
57709: POP
// result := s_arr [ 1 ] ;
57710: LD_ADDR_VAR 0 4
57714: PUSH
57715: LD_VAR 0 7
57719: PUSH
57720: LD_INT 1
57722: ARRAY
57723: ST_TO_ADDR
// end ; end ;
57724: LD_VAR 0 4
57728: RET
// export function ReplaceWith ( list , pos1 , pos2 ) ; var i ; begin
57729: LD_INT 0
57731: PPUSH
57732: PPUSH
// if not list then
57733: LD_VAR 0 1
57737: NOT
57738: IFFALSE 57742
// exit ;
57740: GO 57833
// i := list [ pos1 ] ;
57742: LD_ADDR_VAR 0 5
57746: PUSH
57747: LD_VAR 0 1
57751: PUSH
57752: LD_VAR 0 2
57756: ARRAY
57757: ST_TO_ADDR
// if not i then
57758: LD_VAR 0 5
57762: NOT
57763: IFFALSE 57767
// exit ;
57765: GO 57833
// list := Replace ( list , pos1 , list [ pos2 ] ) ;
57767: LD_ADDR_VAR 0 1
57771: PUSH
57772: LD_VAR 0 1
57776: PPUSH
57777: LD_VAR 0 2
57781: PPUSH
57782: LD_VAR 0 1
57786: PUSH
57787: LD_VAR 0 3
57791: ARRAY
57792: PPUSH
57793: CALL_OW 1
57797: ST_TO_ADDR
// list := Replace ( list , pos2 , i ) ;
57798: LD_ADDR_VAR 0 1
57802: PUSH
57803: LD_VAR 0 1
57807: PPUSH
57808: LD_VAR 0 3
57812: PPUSH
57813: LD_VAR 0 5
57817: PPUSH
57818: CALL_OW 1
57822: ST_TO_ADDR
// result := list ;
57823: LD_ADDR_VAR 0 4
57827: PUSH
57828: LD_VAR 0 1
57832: ST_TO_ADDR
// end ;
57833: LD_VAR 0 4
57837: RET
// export function SortByDistanceUnit ( unit , list , asc , mode ) ; begin
57838: LD_INT 0
57840: PPUSH
// result := SortByDistanceXY ( GetX ( unit ) , GetY ( unit ) , list , asc , mode ) ;
57841: LD_ADDR_VAR 0 5
57845: PUSH
57846: LD_VAR 0 1
57850: PPUSH
57851: CALL_OW 250
57855: PPUSH
57856: LD_VAR 0 1
57860: PPUSH
57861: CALL_OW 251
57865: PPUSH
57866: LD_VAR 0 2
57870: PPUSH
57871: LD_VAR 0 3
57875: PPUSH
57876: LD_VAR 0 4
57880: PPUSH
57881: CALL 57891 0 5
57885: ST_TO_ADDR
// end ;
57886: LD_VAR 0 5
57890: RET
// export function SortByDistanceXY ( x , y , list , asc , mode ) ; var i , j , tmp ; begin
57891: LD_INT 0
57893: PPUSH
57894: PPUSH
57895: PPUSH
57896: PPUSH
// if not list then
57897: LD_VAR 0 3
57901: NOT
57902: IFFALSE 57906
// exit ;
57904: GO 58294
// result := [ ] ;
57906: LD_ADDR_VAR 0 6
57910: PUSH
57911: EMPTY
57912: ST_TO_ADDR
// for i in list do
57913: LD_ADDR_VAR 0 7
57917: PUSH
57918: LD_VAR 0 3
57922: PUSH
57923: FOR_IN
57924: IFFALSE 58126
// begin tmp := GetDistUnitXY ( i , x , y ) ;
57926: LD_ADDR_VAR 0 9
57930: PUSH
57931: LD_VAR 0 7
57935: PPUSH
57936: LD_VAR 0 1
57940: PPUSH
57941: LD_VAR 0 2
57945: PPUSH
57946: CALL_OW 297
57950: ST_TO_ADDR
// if not result then
57951: LD_VAR 0 6
57955: NOT
57956: IFFALSE 57982
// result := [ [ i , tmp ] ] else
57958: LD_ADDR_VAR 0 6
57962: PUSH
57963: LD_VAR 0 7
57967: PUSH
57968: LD_VAR 0 9
57972: PUSH
57973: EMPTY
57974: LIST
57975: LIST
57976: PUSH
57977: EMPTY
57978: LIST
57979: ST_TO_ADDR
57980: GO 58124
// begin if result [ result ] [ 2 ] < tmp then
57982: LD_VAR 0 6
57986: PUSH
57987: LD_VAR 0 6
57991: ARRAY
57992: PUSH
57993: LD_INT 2
57995: ARRAY
57996: PUSH
57997: LD_VAR 0 9
58001: LESS
58002: IFFALSE 58044
// result := Insert ( result , result + 1 , [ i , tmp ] ) else
58004: LD_ADDR_VAR 0 6
58008: PUSH
58009: LD_VAR 0 6
58013: PPUSH
58014: LD_VAR 0 6
58018: PUSH
58019: LD_INT 1
58021: PLUS
58022: PPUSH
58023: LD_VAR 0 7
58027: PUSH
58028: LD_VAR 0 9
58032: PUSH
58033: EMPTY
58034: LIST
58035: LIST
58036: PPUSH
58037: CALL_OW 2
58041: ST_TO_ADDR
58042: GO 58124
// for j = 1 to result do
58044: LD_ADDR_VAR 0 8
58048: PUSH
58049: DOUBLE
58050: LD_INT 1
58052: DEC
58053: ST_TO_ADDR
58054: LD_VAR 0 6
58058: PUSH
58059: FOR_TO
58060: IFFALSE 58122
// begin if tmp < result [ j ] [ 2 ] then
58062: LD_VAR 0 9
58066: PUSH
58067: LD_VAR 0 6
58071: PUSH
58072: LD_VAR 0 8
58076: ARRAY
58077: PUSH
58078: LD_INT 2
58080: ARRAY
58081: LESS
58082: IFFALSE 58120
// begin result := Insert ( result , j , [ i , tmp ] ) ;
58084: LD_ADDR_VAR 0 6
58088: PUSH
58089: LD_VAR 0 6
58093: PPUSH
58094: LD_VAR 0 8
58098: PPUSH
58099: LD_VAR 0 7
58103: PUSH
58104: LD_VAR 0 9
58108: PUSH
58109: EMPTY
58110: LIST
58111: LIST
58112: PPUSH
58113: CALL_OW 2
58117: ST_TO_ADDR
// break ;
58118: GO 58122
// end ; end ;
58120: GO 58059
58122: POP
58123: POP
// end ; end ;
58124: GO 57923
58126: POP
58127: POP
// if result and not asc then
58128: LD_VAR 0 6
58132: PUSH
58133: LD_VAR 0 4
58137: NOT
58138: AND
58139: IFFALSE 58214
// begin tmp := result ;
58141: LD_ADDR_VAR 0 9
58145: PUSH
58146: LD_VAR 0 6
58150: ST_TO_ADDR
// for i = tmp downto 1 do
58151: LD_ADDR_VAR 0 7
58155: PUSH
58156: DOUBLE
58157: LD_VAR 0 9
58161: INC
58162: ST_TO_ADDR
58163: LD_INT 1
58165: PUSH
58166: FOR_DOWNTO
58167: IFFALSE 58212
// result := Replace ( result , tmp - i + 1 , tmp [ i ] ) ;
58169: LD_ADDR_VAR 0 6
58173: PUSH
58174: LD_VAR 0 6
58178: PPUSH
58179: LD_VAR 0 9
58183: PUSH
58184: LD_VAR 0 7
58188: MINUS
58189: PUSH
58190: LD_INT 1
58192: PLUS
58193: PPUSH
58194: LD_VAR 0 9
58198: PUSH
58199: LD_VAR 0 7
58203: ARRAY
58204: PPUSH
58205: CALL_OW 1
58209: ST_TO_ADDR
58210: GO 58166
58212: POP
58213: POP
// end ; tmp := [ ] ;
58214: LD_ADDR_VAR 0 9
58218: PUSH
58219: EMPTY
58220: ST_TO_ADDR
// if mode then
58221: LD_VAR 0 5
58225: IFFALSE 58294
// begin for i = 1 to result do
58227: LD_ADDR_VAR 0 7
58231: PUSH
58232: DOUBLE
58233: LD_INT 1
58235: DEC
58236: ST_TO_ADDR
58237: LD_VAR 0 6
58241: PUSH
58242: FOR_TO
58243: IFFALSE 58282
// tmp := Replace ( tmp , i , result [ i ] [ 1 ] ) ;
58245: LD_ADDR_VAR 0 9
58249: PUSH
58250: LD_VAR 0 9
58254: PPUSH
58255: LD_VAR 0 7
58259: PPUSH
58260: LD_VAR 0 6
58264: PUSH
58265: LD_VAR 0 7
58269: ARRAY
58270: PUSH
58271: LD_INT 1
58273: ARRAY
58274: PPUSH
58275: CALL_OW 1
58279: ST_TO_ADDR
58280: GO 58242
58282: POP
58283: POP
// result := tmp ;
58284: LD_ADDR_VAR 0 6
58288: PUSH
58289: LD_VAR 0 9
58293: ST_TO_ADDR
// end ; end ;
58294: LD_VAR 0 6
58298: RET
// export function DangerAtRangeXY ( side , x , y , range ) ; var i , j , tmp , points , bpoints ; begin
58299: LD_INT 0
58301: PPUSH
58302: PPUSH
58303: PPUSH
58304: PPUSH
58305: PPUSH
58306: PPUSH
// result := [ 0 , 0 , 0 , [ ] ] ;
58307: LD_ADDR_VAR 0 5
58311: PUSH
58312: LD_INT 0
58314: PUSH
58315: LD_INT 0
58317: PUSH
58318: LD_INT 0
58320: PUSH
58321: EMPTY
58322: PUSH
58323: EMPTY
58324: LIST
58325: LIST
58326: LIST
58327: LIST
58328: ST_TO_ADDR
// if not x or not y then
58329: LD_VAR 0 2
58333: NOT
58334: PUSH
58335: LD_VAR 0 3
58339: NOT
58340: OR
58341: IFFALSE 58345
// exit ;
58343: GO 59991
// if not range then
58345: LD_VAR 0 4
58349: NOT
58350: IFFALSE 58360
// range := 10 ;
58352: LD_ADDR_VAR 0 4
58356: PUSH
58357: LD_INT 10
58359: ST_TO_ADDR
// tmp := FilterAllUnits ( [ [ f_enemy , side ] , [ f_distxy , x , y , range ] , [ f_not , [ f_type , unit_building ] ] ] ) ;
58360: LD_ADDR_VAR 0 8
58364: PUSH
58365: LD_INT 81
58367: PUSH
58368: LD_VAR 0 1
58372: PUSH
58373: EMPTY
58374: LIST
58375: LIST
58376: PUSH
58377: LD_INT 92
58379: PUSH
58380: LD_VAR 0 2
58384: PUSH
58385: LD_VAR 0 3
58389: PUSH
58390: LD_VAR 0 4
58394: PUSH
58395: EMPTY
58396: LIST
58397: LIST
58398: LIST
58399: LIST
58400: PUSH
58401: LD_INT 3
58403: PUSH
58404: LD_INT 21
58406: PUSH
58407: LD_INT 3
58409: PUSH
58410: EMPTY
58411: LIST
58412: LIST
58413: PUSH
58414: EMPTY
58415: LIST
58416: LIST
58417: PUSH
58418: EMPTY
58419: LIST
58420: LIST
58421: LIST
58422: PPUSH
58423: CALL_OW 69
58427: ST_TO_ADDR
// if not tmp then
58428: LD_VAR 0 8
58432: NOT
58433: IFFALSE 58437
// exit ;
58435: GO 59991
// for i in tmp do
58437: LD_ADDR_VAR 0 6
58441: PUSH
58442: LD_VAR 0 8
58446: PUSH
58447: FOR_IN
58448: IFFALSE 59966
// begin points := [ 0 , 0 , 0 ] ;
58450: LD_ADDR_VAR 0 9
58454: PUSH
58455: LD_INT 0
58457: PUSH
58458: LD_INT 0
58460: PUSH
58461: LD_INT 0
58463: PUSH
58464: EMPTY
58465: LIST
58466: LIST
58467: LIST
58468: ST_TO_ADDR
// bpoints := 1 ;
58469: LD_ADDR_VAR 0 10
58473: PUSH
58474: LD_INT 1
58476: ST_TO_ADDR
// case GetType ( i ) of unit_human :
58477: LD_VAR 0 6
58481: PPUSH
58482: CALL_OW 247
58486: PUSH
58487: LD_INT 1
58489: DOUBLE
58490: EQUAL
58491: IFTRUE 58495
58493: GO 59073
58495: POP
// begin if GetClass ( i ) = 1 then
58496: LD_VAR 0 6
58500: PPUSH
58501: CALL_OW 257
58505: PUSH
58506: LD_INT 1
58508: EQUAL
58509: IFFALSE 58530
// points := [ 10 , 5 , 3 ] ;
58511: LD_ADDR_VAR 0 9
58515: PUSH
58516: LD_INT 10
58518: PUSH
58519: LD_INT 5
58521: PUSH
58522: LD_INT 3
58524: PUSH
58525: EMPTY
58526: LIST
58527: LIST
58528: LIST
58529: ST_TO_ADDR
// if GetClass ( i ) in [ 2 , 3 , 4 ] then
58530: LD_VAR 0 6
58534: PPUSH
58535: CALL_OW 257
58539: PUSH
58540: LD_INT 2
58542: PUSH
58543: LD_INT 3
58545: PUSH
58546: LD_INT 4
58548: PUSH
58549: EMPTY
58550: LIST
58551: LIST
58552: LIST
58553: IN
58554: IFFALSE 58575
// points := [ 3 , 2 , 1 ] ;
58556: LD_ADDR_VAR 0 9
58560: PUSH
58561: LD_INT 3
58563: PUSH
58564: LD_INT 2
58566: PUSH
58567: LD_INT 1
58569: PUSH
58570: EMPTY
58571: LIST
58572: LIST
58573: LIST
58574: ST_TO_ADDR
// if GetClass ( i ) = 5 then
58575: LD_VAR 0 6
58579: PPUSH
58580: CALL_OW 257
58584: PUSH
58585: LD_INT 5
58587: EQUAL
58588: IFFALSE 58609
// points := [ 130 , 5 , 2 ] ;
58590: LD_ADDR_VAR 0 9
58594: PUSH
58595: LD_INT 130
58597: PUSH
58598: LD_INT 5
58600: PUSH
58601: LD_INT 2
58603: PUSH
58604: EMPTY
58605: LIST
58606: LIST
58607: LIST
58608: ST_TO_ADDR
// if GetClass ( i ) = 8 then
58609: LD_VAR 0 6
58613: PPUSH
58614: CALL_OW 257
58618: PUSH
58619: LD_INT 8
58621: EQUAL
58622: IFFALSE 58643
// points := [ 35 , 35 , 30 ] ;
58624: LD_ADDR_VAR 0 9
58628: PUSH
58629: LD_INT 35
58631: PUSH
58632: LD_INT 35
58634: PUSH
58635: LD_INT 30
58637: PUSH
58638: EMPTY
58639: LIST
58640: LIST
58641: LIST
58642: ST_TO_ADDR
// if GetClass ( i ) = 9 then
58643: LD_VAR 0 6
58647: PPUSH
58648: CALL_OW 257
58652: PUSH
58653: LD_INT 9
58655: EQUAL
58656: IFFALSE 58677
// points := [ 20 , 55 , 40 ] ;
58658: LD_ADDR_VAR 0 9
58662: PUSH
58663: LD_INT 20
58665: PUSH
58666: LD_INT 55
58668: PUSH
58669: LD_INT 40
58671: PUSH
58672: EMPTY
58673: LIST
58674: LIST
58675: LIST
58676: ST_TO_ADDR
// if GetClass ( i ) in [ 12 , 16 ] then
58677: LD_VAR 0 6
58681: PPUSH
58682: CALL_OW 257
58686: PUSH
58687: LD_INT 12
58689: PUSH
58690: LD_INT 16
58692: PUSH
58693: EMPTY
58694: LIST
58695: LIST
58696: IN
58697: IFFALSE 58718
// points := [ 5 , 3 , 2 ] ;
58699: LD_ADDR_VAR 0 9
58703: PUSH
58704: LD_INT 5
58706: PUSH
58707: LD_INT 3
58709: PUSH
58710: LD_INT 2
58712: PUSH
58713: EMPTY
58714: LIST
58715: LIST
58716: LIST
58717: ST_TO_ADDR
// if GetClass ( i ) = 17 then
58718: LD_VAR 0 6
58722: PPUSH
58723: CALL_OW 257
58727: PUSH
58728: LD_INT 17
58730: EQUAL
58731: IFFALSE 58752
// points := [ 100 , 50 , 75 ] ;
58733: LD_ADDR_VAR 0 9
58737: PUSH
58738: LD_INT 100
58740: PUSH
58741: LD_INT 50
58743: PUSH
58744: LD_INT 75
58746: PUSH
58747: EMPTY
58748: LIST
58749: LIST
58750: LIST
58751: ST_TO_ADDR
// if GetClass ( i ) = 15 then
58752: LD_VAR 0 6
58756: PPUSH
58757: CALL_OW 257
58761: PUSH
58762: LD_INT 15
58764: EQUAL
58765: IFFALSE 58786
// points := [ 10 , 5 , 3 ] ;
58767: LD_ADDR_VAR 0 9
58771: PUSH
58772: LD_INT 10
58774: PUSH
58775: LD_INT 5
58777: PUSH
58778: LD_INT 3
58780: PUSH
58781: EMPTY
58782: LIST
58783: LIST
58784: LIST
58785: ST_TO_ADDR
// if GetClass ( i ) = 14 then
58786: LD_VAR 0 6
58790: PPUSH
58791: CALL_OW 257
58795: PUSH
58796: LD_INT 14
58798: EQUAL
58799: IFFALSE 58820
// points := [ 10 , 0 , 0 ] ;
58801: LD_ADDR_VAR 0 9
58805: PUSH
58806: LD_INT 10
58808: PUSH
58809: LD_INT 0
58811: PUSH
58812: LD_INT 0
58814: PUSH
58815: EMPTY
58816: LIST
58817: LIST
58818: LIST
58819: ST_TO_ADDR
// if GetClass ( i ) = 11 then
58820: LD_VAR 0 6
58824: PPUSH
58825: CALL_OW 257
58829: PUSH
58830: LD_INT 11
58832: EQUAL
58833: IFFALSE 58854
// points := [ 30 , 10 , 5 ] ;
58835: LD_ADDR_VAR 0 9
58839: PUSH
58840: LD_INT 30
58842: PUSH
58843: LD_INT 10
58845: PUSH
58846: LD_INT 5
58848: PUSH
58849: EMPTY
58850: LIST
58851: LIST
58852: LIST
58853: ST_TO_ADDR
// if GetTech ( side , tech_stimdrugs ) = state_researched then
58854: LD_VAR 0 1
58858: PPUSH
58859: LD_INT 5
58861: PPUSH
58862: CALL_OW 321
58866: PUSH
58867: LD_INT 2
58869: EQUAL
58870: IFFALSE 58887
// bpoints := bpoints * 1.8 ;
58872: LD_ADDR_VAR 0 10
58876: PUSH
58877: LD_VAR 0 10
58881: PUSH
58882: LD_REAL  1.80000000000000E+0000
58885: MUL
58886: ST_TO_ADDR
// if GetClass ( i ) in [ 1 , 2 , 3 , 4 ] and GetTech ( side , tech_weap1 ) = state_researched then
58887: LD_VAR 0 6
58891: PPUSH
58892: CALL_OW 257
58896: PUSH
58897: LD_INT 1
58899: PUSH
58900: LD_INT 2
58902: PUSH
58903: LD_INT 3
58905: PUSH
58906: LD_INT 4
58908: PUSH
58909: EMPTY
58910: LIST
58911: LIST
58912: LIST
58913: LIST
58914: IN
58915: PUSH
58916: LD_VAR 0 1
58920: PPUSH
58921: LD_INT 51
58923: PPUSH
58924: CALL_OW 321
58928: PUSH
58929: LD_INT 2
58931: EQUAL
58932: AND
58933: IFFALSE 58950
// bpoints := bpoints * 1.2 ;
58935: LD_ADDR_VAR 0 10
58939: PUSH
58940: LD_VAR 0 10
58944: PUSH
58945: LD_REAL  1.20000000000000E+0000
58948: MUL
58949: ST_TO_ADDR
// if GetClass ( i ) in [ 5 , 7 , 9 ] and GetTech ( side , tech_weap2 ) = state_researched then
58950: LD_VAR 0 6
58954: PPUSH
58955: CALL_OW 257
58959: PUSH
58960: LD_INT 5
58962: PUSH
58963: LD_INT 7
58965: PUSH
58966: LD_INT 9
58968: PUSH
58969: EMPTY
58970: LIST
58971: LIST
58972: LIST
58973: IN
58974: PUSH
58975: LD_VAR 0 1
58979: PPUSH
58980: LD_INT 52
58982: PPUSH
58983: CALL_OW 321
58987: PUSH
58988: LD_INT 2
58990: EQUAL
58991: AND
58992: IFFALSE 59009
// bpoints := bpoints * 1.5 ;
58994: LD_ADDR_VAR 0 10
58998: PUSH
58999: LD_VAR 0 10
59003: PUSH
59004: LD_REAL  1.50000000000000E+0000
59007: MUL
59008: ST_TO_ADDR
// if GetTech ( side , tech_bio1 ) = state_researched then
59009: LD_VAR 0 1
59013: PPUSH
59014: LD_INT 66
59016: PPUSH
59017: CALL_OW 321
59021: PUSH
59022: LD_INT 2
59024: EQUAL
59025: IFFALSE 59042
// bpoints := bpoints * 1.1 ;
59027: LD_ADDR_VAR 0 10
59031: PUSH
59032: LD_VAR 0 10
59036: PUSH
59037: LD_REAL  1.10000000000000E+0000
59040: MUL
59041: ST_TO_ADDR
// bpoints := bpoints * ( GetSkill ( i , 1 ) * 1.15 ) ;
59042: LD_ADDR_VAR 0 10
59046: PUSH
59047: LD_VAR 0 10
59051: PUSH
59052: LD_VAR 0 6
59056: PPUSH
59057: LD_INT 1
59059: PPUSH
59060: CALL_OW 259
59064: PUSH
59065: LD_REAL  1.15000000000000E+0000
59068: MUL
59069: MUL
59070: ST_TO_ADDR
// end ; unit_vehicle :
59071: GO 59895
59073: LD_INT 2
59075: DOUBLE
59076: EQUAL
59077: IFTRUE 59081
59079: GO 59883
59081: POP
// begin if GetWeapon ( i ) in [ us_machine_gun , ru_heavy_machine_gun , ar_double_machine_gun ] then
59082: LD_VAR 0 6
59086: PPUSH
59087: CALL_OW 264
59091: PUSH
59092: LD_INT 2
59094: PUSH
59095: LD_INT 42
59097: PUSH
59098: LD_INT 24
59100: PUSH
59101: EMPTY
59102: LIST
59103: LIST
59104: LIST
59105: IN
59106: IFFALSE 59127
// points := [ 25 , 5 , 3 ] ;
59108: LD_ADDR_VAR 0 9
59112: PUSH
59113: LD_INT 25
59115: PUSH
59116: LD_INT 5
59118: PUSH
59119: LD_INT 3
59121: PUSH
59122: EMPTY
59123: LIST
59124: LIST
59125: LIST
59126: ST_TO_ADDR
// if GetWeapon ( i ) in [ us_gatling_gun , ru_gatling_gun , ar_gatling_gun ] then
59127: LD_VAR 0 6
59131: PPUSH
59132: CALL_OW 264
59136: PUSH
59137: LD_INT 4
59139: PUSH
59140: LD_INT 43
59142: PUSH
59143: LD_INT 25
59145: PUSH
59146: EMPTY
59147: LIST
59148: LIST
59149: LIST
59150: IN
59151: IFFALSE 59172
// points := [ 40 , 15 , 5 ] ;
59153: LD_ADDR_VAR 0 9
59157: PUSH
59158: LD_INT 40
59160: PUSH
59161: LD_INT 15
59163: PUSH
59164: LD_INT 5
59166: PUSH
59167: EMPTY
59168: LIST
59169: LIST
59170: LIST
59171: ST_TO_ADDR
// if GetWeapon ( i ) in [ us_light_gun , ar_light_gun ] then
59172: LD_VAR 0 6
59176: PPUSH
59177: CALL_OW 264
59181: PUSH
59182: LD_INT 3
59184: PUSH
59185: LD_INT 23
59187: PUSH
59188: EMPTY
59189: LIST
59190: LIST
59191: IN
59192: IFFALSE 59213
// points := [ 7 , 25 , 8 ] ;
59194: LD_ADDR_VAR 0 9
59198: PUSH
59199: LD_INT 7
59201: PUSH
59202: LD_INT 25
59204: PUSH
59205: LD_INT 8
59207: PUSH
59208: EMPTY
59209: LIST
59210: LIST
59211: LIST
59212: ST_TO_ADDR
// if GetWeapon ( i ) in [ us_double_gun , ar_gun , ru_gun ] then
59213: LD_VAR 0 6
59217: PPUSH
59218: CALL_OW 264
59222: PUSH
59223: LD_INT 5
59225: PUSH
59226: LD_INT 27
59228: PUSH
59229: LD_INT 44
59231: PUSH
59232: EMPTY
59233: LIST
59234: LIST
59235: LIST
59236: IN
59237: IFFALSE 59258
// points := [ 14 , 50 , 16 ] ;
59239: LD_ADDR_VAR 0 9
59243: PUSH
59244: LD_INT 14
59246: PUSH
59247: LD_INT 50
59249: PUSH
59250: LD_INT 16
59252: PUSH
59253: EMPTY
59254: LIST
59255: LIST
59256: LIST
59257: ST_TO_ADDR
// if GetWeapon ( i ) in [ us_heavy_gun , ru_heavy_gun ] then
59258: LD_VAR 0 6
59262: PPUSH
59263: CALL_OW 264
59267: PUSH
59268: LD_INT 6
59270: PUSH
59271: LD_INT 46
59273: PUSH
59274: EMPTY
59275: LIST
59276: LIST
59277: IN
59278: IFFALSE 59299
// points := [ 32 , 120 , 70 ] ;
59280: LD_ADDR_VAR 0 9
59284: PUSH
59285: LD_INT 32
59287: PUSH
59288: LD_INT 120
59290: PUSH
59291: LD_INT 70
59293: PUSH
59294: EMPTY
59295: LIST
59296: LIST
59297: LIST
59298: ST_TO_ADDR
// if GetWeapon ( i ) in [ us_rocket_launcher , ar_rocket_launcher , ru_rocket_launcher ] then
59299: LD_VAR 0 6
59303: PPUSH
59304: CALL_OW 264
59308: PUSH
59309: LD_INT 7
59311: PUSH
59312: LD_INT 28
59314: PUSH
59315: LD_INT 45
59317: PUSH
59318: EMPTY
59319: LIST
59320: LIST
59321: LIST
59322: IN
59323: IFFALSE 59344
// points := [ 35 , 20 , 45 ] ;
59325: LD_ADDR_VAR 0 9
59329: PUSH
59330: LD_INT 35
59332: PUSH
59333: LD_INT 20
59335: PUSH
59336: LD_INT 45
59338: PUSH
59339: EMPTY
59340: LIST
59341: LIST
59342: LIST
59343: ST_TO_ADDR
// if GetWeapon ( i ) in [ ru_rocket ] then
59344: LD_VAR 0 6
59348: PPUSH
59349: CALL_OW 264
59353: PUSH
59354: LD_INT 47
59356: PUSH
59357: EMPTY
59358: LIST
59359: IN
59360: IFFALSE 59381
// points := [ 67 , 45 , 75 ] ;
59362: LD_ADDR_VAR 0 9
59366: PUSH
59367: LD_INT 67
59369: PUSH
59370: LD_INT 45
59372: PUSH
59373: LD_INT 75
59375: PUSH
59376: EMPTY
59377: LIST
59378: LIST
59379: LIST
59380: ST_TO_ADDR
// if GetWeapon ( i ) in [ ar_flame_thrower ] then
59381: LD_VAR 0 6
59385: PPUSH
59386: CALL_OW 264
59390: PUSH
59391: LD_INT 26
59393: PUSH
59394: EMPTY
59395: LIST
59396: IN
59397: IFFALSE 59418
// points := [ 120 , 30 , 80 ] ;
59399: LD_ADDR_VAR 0 9
59403: PUSH
59404: LD_INT 120
59406: PUSH
59407: LD_INT 30
59409: PUSH
59410: LD_INT 80
59412: PUSH
59413: EMPTY
59414: LIST
59415: LIST
59416: LIST
59417: ST_TO_ADDR
// if GetWeapon ( i ) in [ ar_multimissile_ballista ] then
59418: LD_VAR 0 6
59422: PPUSH
59423: CALL_OW 264
59427: PUSH
59428: LD_INT 22
59430: PUSH
59431: EMPTY
59432: LIST
59433: IN
59434: IFFALSE 59455
// points := [ 40 , 1 , 1 ] ;
59436: LD_ADDR_VAR 0 9
59440: PUSH
59441: LD_INT 40
59443: PUSH
59444: LD_INT 1
59446: PUSH
59447: LD_INT 1
59449: PUSH
59450: EMPTY
59451: LIST
59452: LIST
59453: LIST
59454: ST_TO_ADDR
// if GetWeapon ( i ) in [ ar_selfpropelled_bomb ] then
59455: LD_VAR 0 6
59459: PPUSH
59460: CALL_OW 264
59464: PUSH
59465: LD_INT 29
59467: PUSH
59468: EMPTY
59469: LIST
59470: IN
59471: IFFALSE 59492
// points := [ 70 , 200 , 400 ] ;
59473: LD_ADDR_VAR 0 9
59477: PUSH
59478: LD_INT 70
59480: PUSH
59481: LD_INT 200
59483: PUSH
59484: LD_INT 400
59486: PUSH
59487: EMPTY
59488: LIST
59489: LIST
59490: LIST
59491: ST_TO_ADDR
// if GetWeapon ( i ) in [ us_bulldozer , ru_bulldozer ] then
59492: LD_VAR 0 6
59496: PPUSH
59497: CALL_OW 264
59501: PUSH
59502: LD_INT 14
59504: PUSH
59505: LD_INT 53
59507: PUSH
59508: EMPTY
59509: LIST
59510: LIST
59511: IN
59512: IFFALSE 59533
// points := [ 40 , 10 , 20 ] ;
59514: LD_ADDR_VAR 0 9
59518: PUSH
59519: LD_INT 40
59521: PUSH
59522: LD_INT 10
59524: PUSH
59525: LD_INT 20
59527: PUSH
59528: EMPTY
59529: LIST
59530: LIST
59531: LIST
59532: ST_TO_ADDR
// if GetWeapon ( i ) in [ us_laser ] then
59533: LD_VAR 0 6
59537: PPUSH
59538: CALL_OW 264
59542: PUSH
59543: LD_INT 9
59545: PUSH
59546: EMPTY
59547: LIST
59548: IN
59549: IFFALSE 59570
// points := [ 5 , 70 , 20 ] ;
59551: LD_ADDR_VAR 0 9
59555: PUSH
59556: LD_INT 5
59558: PUSH
59559: LD_INT 70
59561: PUSH
59562: LD_INT 20
59564: PUSH
59565: EMPTY
59566: LIST
59567: LIST
59568: LIST
59569: ST_TO_ADDR
// if GetWeapon ( i ) in [ us_double_laser ] then
59570: LD_VAR 0 6
59574: PPUSH
59575: CALL_OW 264
59579: PUSH
59580: LD_INT 10
59582: PUSH
59583: EMPTY
59584: LIST
59585: IN
59586: IFFALSE 59607
// points := [ 35 , 110 , 70 ] ;
59588: LD_ADDR_VAR 0 9
59592: PUSH
59593: LD_INT 35
59595: PUSH
59596: LD_INT 110
59598: PUSH
59599: LD_INT 70
59601: PUSH
59602: EMPTY
59603: LIST
59604: LIST
59605: LIST
59606: ST_TO_ADDR
// if GetChassis ( i ) = 25 then
59607: LD_VAR 0 6
59611: PPUSH
59612: CALL_OW 265
59616: PUSH
59617: LD_INT 25
59619: EQUAL
59620: IFFALSE 59641
// points := [ 80 , 65 , 100 ] ;
59622: LD_ADDR_VAR 0 9
59626: PUSH
59627: LD_INT 80
59629: PUSH
59630: LD_INT 65
59632: PUSH
59633: LD_INT 100
59635: PUSH
59636: EMPTY
59637: LIST
59638: LIST
59639: LIST
59640: ST_TO_ADDR
// if GetControl ( i ) = control_manual then
59641: LD_VAR 0 6
59645: PPUSH
59646: CALL_OW 263
59650: PUSH
59651: LD_INT 1
59653: EQUAL
59654: IFFALSE 59689
// bpoints := bpoints * ( GetSkill ( IsDrivenBy ( i ) , 3 ) * 4 ) ;
59656: LD_ADDR_VAR 0 10
59660: PUSH
59661: LD_VAR 0 10
59665: PUSH
59666: LD_VAR 0 6
59670: PPUSH
59671: CALL_OW 311
59675: PPUSH
59676: LD_INT 3
59678: PPUSH
59679: CALL_OW 259
59683: PUSH
59684: LD_INT 4
59686: MUL
59687: MUL
59688: ST_TO_ADDR
// if GetControl ( i ) = control_remote then
59689: LD_VAR 0 6
59693: PPUSH
59694: CALL_OW 263
59698: PUSH
59699: LD_INT 2
59701: EQUAL
59702: IFFALSE 59753
// begin j := IsControledBy ( i ) ;
59704: LD_ADDR_VAR 0 7
59708: PUSH
59709: LD_VAR 0 6
59713: PPUSH
59714: CALL_OW 312
59718: ST_TO_ADDR
// if j then
59719: LD_VAR 0 7
59723: IFFALSE 59753
// bpoints := bpoints * ( GetSkill ( j , 3 ) * 3 ) ;
59725: LD_ADDR_VAR 0 10
59729: PUSH
59730: LD_VAR 0 10
59734: PUSH
59735: LD_VAR 0 7
59739: PPUSH
59740: LD_INT 3
59742: PPUSH
59743: CALL_OW 259
59747: PUSH
59748: LD_INT 3
59750: MUL
59751: MUL
59752: ST_TO_ADDR
// end ; if GetWeapon ( i ) in [ us_double_gun , us_heavy_gun , ru_heavy_gun , ru_gun , ru_rocket , ru_rocket_launcher , ar_rocket_launcher , us_rocket_launcher , ar_gun , ar_selfpropelled_bomb ] and GetTech ( side , tech_weap2 ) = state_researched then
59753: LD_VAR 0 6
59757: PPUSH
59758: CALL_OW 264
59762: PUSH
59763: LD_INT 5
59765: PUSH
59766: LD_INT 6
59768: PUSH
59769: LD_INT 46
59771: PUSH
59772: LD_INT 44
59774: PUSH
59775: LD_INT 47
59777: PUSH
59778: LD_INT 45
59780: PUSH
59781: LD_INT 28
59783: PUSH
59784: LD_INT 7
59786: PUSH
59787: LD_INT 27
59789: PUSH
59790: LD_INT 29
59792: PUSH
59793: EMPTY
59794: LIST
59795: LIST
59796: LIST
59797: LIST
59798: LIST
59799: LIST
59800: LIST
59801: LIST
59802: LIST
59803: LIST
59804: IN
59805: PUSH
59806: LD_VAR 0 1
59810: PPUSH
59811: LD_INT 52
59813: PPUSH
59814: CALL_OW 321
59818: PUSH
59819: LD_INT 2
59821: EQUAL
59822: AND
59823: IFFALSE 59840
// bpoints := bpoints * 1.2 ;
59825: LD_ADDR_VAR 0 10
59829: PUSH
59830: LD_VAR 0 10
59834: PUSH
59835: LD_REAL  1.20000000000000E+0000
59838: MUL
59839: ST_TO_ADDR
// if GetWeapon ( i ) in [ us_heavy_gun , ru_heavy_gun , ru_rocket ] then
59840: LD_VAR 0 6
59844: PPUSH
59845: CALL_OW 264
59849: PUSH
59850: LD_INT 6
59852: PUSH
59853: LD_INT 46
59855: PUSH
59856: LD_INT 47
59858: PUSH
59859: EMPTY
59860: LIST
59861: LIST
59862: LIST
59863: IN
59864: IFFALSE 59881
// bpoints := bpoints * 1.2 ;
59866: LD_ADDR_VAR 0 10
59870: PUSH
59871: LD_VAR 0 10
59875: PUSH
59876: LD_REAL  1.20000000000000E+0000
59879: MUL
59880: ST_TO_ADDR
// end ; unit_building :
59881: GO 59895
59883: LD_INT 3
59885: DOUBLE
59886: EQUAL
59887: IFTRUE 59891
59889: GO 59894
59891: POP
// ; end ;
59892: GO 59895
59894: POP
// for j = 1 to 3 do
59895: LD_ADDR_VAR 0 7
59899: PUSH
59900: DOUBLE
59901: LD_INT 1
59903: DEC
59904: ST_TO_ADDR
59905: LD_INT 3
59907: PUSH
59908: FOR_TO
59909: IFFALSE 59962
// result := Replace ( result , j , result [ j ] + ( points [ j ] * bpoints ) ) ;
59911: LD_ADDR_VAR 0 5
59915: PUSH
59916: LD_VAR 0 5
59920: PPUSH
59921: LD_VAR 0 7
59925: PPUSH
59926: LD_VAR 0 5
59930: PUSH
59931: LD_VAR 0 7
59935: ARRAY
59936: PUSH
59937: LD_VAR 0 9
59941: PUSH
59942: LD_VAR 0 7
59946: ARRAY
59947: PUSH
59948: LD_VAR 0 10
59952: MUL
59953: PLUS
59954: PPUSH
59955: CALL_OW 1
59959: ST_TO_ADDR
59960: GO 59908
59962: POP
59963: POP
// end ;
59964: GO 58447
59966: POP
59967: POP
// result := Replace ( result , 4 , tmp ) ;
59968: LD_ADDR_VAR 0 5
59972: PUSH
59973: LD_VAR 0 5
59977: PPUSH
59978: LD_INT 4
59980: PPUSH
59981: LD_VAR 0 8
59985: PPUSH
59986: CALL_OW 1
59990: ST_TO_ADDR
// end ;
59991: LD_VAR 0 5
59995: RET
// export function DangerAtRange ( unit , range ) ; begin
59996: LD_INT 0
59998: PPUSH
// result := DangerAtRangeXY ( GetSide ( unit ) , GetX ( unit ) , GetY ( unit ) , range ) ;
59999: LD_ADDR_VAR 0 3
60003: PUSH
60004: LD_VAR 0 1
60008: PPUSH
60009: CALL_OW 255
60013: PPUSH
60014: LD_VAR 0 1
60018: PPUSH
60019: CALL_OW 250
60023: PPUSH
60024: LD_VAR 0 1
60028: PPUSH
60029: CALL_OW 251
60033: PPUSH
60034: LD_VAR 0 2
60038: PPUSH
60039: CALL 58299 0 4
60043: ST_TO_ADDR
// end ;
60044: LD_VAR 0 3
60048: RET
// export function DangerInArea ( side , area ) ; begin
60049: LD_INT 0
60051: PPUSH
// result := FilterUnitsInArea ( area , [ f_enemy , side ] ) ;
60052: LD_ADDR_VAR 0 3
60056: PUSH
60057: LD_VAR 0 2
60061: PPUSH
60062: LD_INT 81
60064: PUSH
60065: LD_VAR 0 1
60069: PUSH
60070: EMPTY
60071: LIST
60072: LIST
60073: PPUSH
60074: CALL_OW 70
60078: ST_TO_ADDR
// end ;
60079: LD_VAR 0 3
60083: RET
// export function IsExtension ( b ) ; begin
60084: LD_INT 0
60086: PPUSH
// result := b in [ b_ext_stitch , b_ext_radar , b_ext_radio , b_ext_gun , b_ext_computer , b_ext_siberium , b_ext_noncombat , b_ext_track , b_ext_laser , b_ext_rocket ] ;
60087: LD_ADDR_VAR 0 2
60091: PUSH
60092: LD_VAR 0 1
60096: PUSH
60097: LD_INT 23
60099: PUSH
60100: LD_INT 20
60102: PUSH
60103: LD_INT 22
60105: PUSH
60106: LD_INT 17
60108: PUSH
60109: LD_INT 24
60111: PUSH
60112: LD_INT 21
60114: PUSH
60115: LD_INT 19
60117: PUSH
60118: LD_INT 16
60120: PUSH
60121: LD_INT 25
60123: PUSH
60124: LD_INT 18
60126: PUSH
60127: EMPTY
60128: LIST
60129: LIST
60130: LIST
60131: LIST
60132: LIST
60133: LIST
60134: LIST
60135: LIST
60136: LIST
60137: LIST
60138: IN
60139: ST_TO_ADDR
// end ;
60140: LD_VAR 0 2
60144: RET
// export function GetBaseBuildings ( base , area ) ; var tmp , i ; begin
60145: LD_INT 0
60147: PPUSH
60148: PPUSH
60149: PPUSH
// result := [ ] ;
60150: LD_ADDR_VAR 0 3
60154: PUSH
60155: EMPTY
60156: ST_TO_ADDR
// tmp := FilterUnitsInArea ( area , [ f_type , unit_building ] ) ;
60157: LD_ADDR_VAR 0 4
60161: PUSH
60162: LD_VAR 0 2
60166: PPUSH
60167: LD_INT 21
60169: PUSH
60170: LD_INT 3
60172: PUSH
60173: EMPTY
60174: LIST
60175: LIST
60176: PPUSH
60177: CALL_OW 70
60181: ST_TO_ADDR
// if not tmp then
60182: LD_VAR 0 4
60186: NOT
60187: IFFALSE 60191
// exit ;
60189: GO 60249
// for i in tmp do
60191: LD_ADDR_VAR 0 5
60195: PUSH
60196: LD_VAR 0 4
60200: PUSH
60201: FOR_IN
60202: IFFALSE 60237
// if GetBase ( i ) <> base then
60204: LD_VAR 0 5
60208: PPUSH
60209: CALL_OW 274
60213: PUSH
60214: LD_VAR 0 1
60218: NONEQUAL
60219: IFFALSE 60235
// ComLinkToBase ( base , i ) ;
60221: LD_VAR 0 1
60225: PPUSH
60226: LD_VAR 0 5
60230: PPUSH
60231: CALL_OW 169
60235: GO 60201
60237: POP
60238: POP
// result := tmp ;
60239: LD_ADDR_VAR 0 3
60243: PUSH
60244: LD_VAR 0 4
60248: ST_TO_ADDR
// end ;
60249: LD_VAR 0 3
60253: RET
// export function ComComplete ( unit , b ) ; var i ; begin
60254: LD_INT 0
60256: PPUSH
60257: PPUSH
// if BuildingStatus ( b ) = bs_build then
60258: LD_VAR 0 2
60262: PPUSH
60263: CALL_OW 461
60267: PUSH
60268: LD_INT 1
60270: EQUAL
60271: IFFALSE 60331
// SetTaskList ( unit , [ [ h , GetX ( b ) , GetY ( b ) , b , 0 , 0 , 0 ] ] ) ;
60273: LD_VAR 0 1
60277: PPUSH
60278: LD_STRING h
60280: PUSH
60281: LD_VAR 0 2
60285: PPUSH
60286: CALL_OW 250
60290: PUSH
60291: LD_VAR 0 2
60295: PPUSH
60296: CALL_OW 251
60300: PUSH
60301: LD_VAR 0 2
60305: PUSH
60306: LD_INT 0
60308: PUSH
60309: LD_INT 0
60311: PUSH
60312: LD_INT 0
60314: PUSH
60315: EMPTY
60316: LIST
60317: LIST
60318: LIST
60319: LIST
60320: LIST
60321: LIST
60322: LIST
60323: PUSH
60324: EMPTY
60325: LIST
60326: PPUSH
60327: CALL_OW 446
// end ;
60331: LD_VAR 0 3
60335: RET
// export function Connect ( vehicle ) ; var i , t , mech , tmp , j ; begin
60336: LD_INT 0
60338: PPUSH
60339: PPUSH
60340: PPUSH
60341: PPUSH
60342: PPUSH
60343: PPUSH
// if not vehicle or not GetControl ( vehicle ) = control_remote then
60344: LD_VAR 0 1
60348: NOT
60349: PUSH
60350: LD_VAR 0 1
60354: PPUSH
60355: CALL_OW 263
60359: PUSH
60360: LD_INT 2
60362: EQUAL
60363: NOT
60364: OR
60365: IFFALSE 60369
// exit ;
60367: GO 60685
// tmp := FilterAllUnits ( [ [ f_side , GetSide ( vehicle ) ] , [ f_or , [ f_btype , b_control_tower ] , [ f_weapon , ar_control_tower ] ] ] ) ;
60369: LD_ADDR_VAR 0 6
60373: PUSH
60374: LD_INT 22
60376: PUSH
60377: LD_VAR 0 1
60381: PPUSH
60382: CALL_OW 255
60386: PUSH
60387: EMPTY
60388: LIST
60389: LIST
60390: PUSH
60391: LD_INT 2
60393: PUSH
60394: LD_INT 30
60396: PUSH
60397: LD_INT 36
60399: PUSH
60400: EMPTY
60401: LIST
60402: LIST
60403: PUSH
60404: LD_INT 34
60406: PUSH
60407: LD_INT 31
60409: PUSH
60410: EMPTY
60411: LIST
60412: LIST
60413: PUSH
60414: EMPTY
60415: LIST
60416: LIST
60417: LIST
60418: PUSH
60419: EMPTY
60420: LIST
60421: LIST
60422: PPUSH
60423: CALL_OW 69
60427: ST_TO_ADDR
// if not tmp then
60428: LD_VAR 0 6
60432: NOT
60433: IFFALSE 60437
// exit ;
60435: GO 60685
// result := [ ] ;
60437: LD_ADDR_VAR 0 2
60441: PUSH
60442: EMPTY
60443: ST_TO_ADDR
// for i in tmp do
60444: LD_ADDR_VAR 0 3
60448: PUSH
60449: LD_VAR 0 6
60453: PUSH
60454: FOR_IN
60455: IFFALSE 60526
// begin t := UnitsInside ( i ) ;
60457: LD_ADDR_VAR 0 4
60461: PUSH
60462: LD_VAR 0 3
60466: PPUSH
60467: CALL_OW 313
60471: ST_TO_ADDR
// if t then
60472: LD_VAR 0 4
60476: IFFALSE 60524
// for j in t do
60478: LD_ADDR_VAR 0 7
60482: PUSH
60483: LD_VAR 0 4
60487: PUSH
60488: FOR_IN
60489: IFFALSE 60522
// result := Insert ( result , result + 1 , j ) ;
60491: LD_ADDR_VAR 0 2
60495: PUSH
60496: LD_VAR 0 2
60500: PPUSH
60501: LD_VAR 0 2
60505: PUSH
60506: LD_INT 1
60508: PLUS
60509: PPUSH
60510: LD_VAR 0 7
60514: PPUSH
60515: CALL_OW 2
60519: ST_TO_ADDR
60520: GO 60488
60522: POP
60523: POP
// end ;
60524: GO 60454
60526: POP
60527: POP
// if not result then
60528: LD_VAR 0 2
60532: NOT
60533: IFFALSE 60537
// exit ;
60535: GO 60685
// mech := result [ 1 ] ;
60537: LD_ADDR_VAR 0 5
60541: PUSH
60542: LD_VAR 0 2
60546: PUSH
60547: LD_INT 1
60549: ARRAY
60550: ST_TO_ADDR
// if result > 1 then
60551: LD_VAR 0 2
60555: PUSH
60556: LD_INT 1
60558: GREATER
60559: IFFALSE 60671
// for i = 2 to result do
60561: LD_ADDR_VAR 0 3
60565: PUSH
60566: DOUBLE
60567: LD_INT 2
60569: DEC
60570: ST_TO_ADDR
60571: LD_VAR 0 2
60575: PUSH
60576: FOR_TO
60577: IFFALSE 60669
// begin t := GetSkill ( result [ i ] , 3 ) - UnitsLinked ( result [ i ] ) ;
60579: LD_ADDR_VAR 0 4
60583: PUSH
60584: LD_VAR 0 2
60588: PUSH
60589: LD_VAR 0 3
60593: ARRAY
60594: PPUSH
60595: LD_INT 3
60597: PPUSH
60598: CALL_OW 259
60602: PUSH
60603: LD_VAR 0 2
60607: PUSH
60608: LD_VAR 0 3
60612: ARRAY
60613: PPUSH
60614: CALL_OW 432
60618: MINUS
60619: ST_TO_ADDR
// if t >= ( GetSkill ( mech , 3 ) - UnitsLinked ( mech ) ) then
60620: LD_VAR 0 4
60624: PUSH
60625: LD_VAR 0 5
60629: PPUSH
60630: LD_INT 3
60632: PPUSH
60633: CALL_OW 259
60637: PUSH
60638: LD_VAR 0 5
60642: PPUSH
60643: CALL_OW 432
60647: MINUS
60648: GREATEREQUAL
60649: IFFALSE 60667
// mech := result [ i ] ;
60651: LD_ADDR_VAR 0 5
60655: PUSH
60656: LD_VAR 0 2
60660: PUSH
60661: LD_VAR 0 3
60665: ARRAY
60666: ST_TO_ADDR
// end ;
60667: GO 60576
60669: POP
60670: POP
// ComLinkTo ( vehicle , mech ) ;
60671: LD_VAR 0 1
60675: PPUSH
60676: LD_VAR 0 5
60680: PPUSH
60681: CALL_OW 135
// end ;
60685: LD_VAR 0 2
60689: RET
// export function PrepareBase ( base_dep , area , name , skill , sources , personel ) ; var i , j , d , b , f , x , un , base , side , nation , buildings , tmp ; begin
60690: LD_INT 0
60692: PPUSH
60693: PPUSH
60694: PPUSH
60695: PPUSH
60696: PPUSH
60697: PPUSH
60698: PPUSH
60699: PPUSH
60700: PPUSH
60701: PPUSH
60702: PPUSH
60703: PPUSH
60704: PPUSH
// result := [ ] ;
60705: LD_ADDR_VAR 0 7
60709: PUSH
60710: EMPTY
60711: ST_TO_ADDR
// if not GetBType ( base_dep ) in [ b_depot , b_warehouse ] then
60712: LD_VAR 0 1
60716: PPUSH
60717: CALL_OW 266
60721: PUSH
60722: LD_INT 0
60724: PUSH
60725: LD_INT 1
60727: PUSH
60728: EMPTY
60729: LIST
60730: LIST
60731: IN
60732: NOT
60733: IFFALSE 60737
// exit ;
60735: GO 62368
// if name then
60737: LD_VAR 0 3
60741: IFFALSE 60757
// SetBName ( base_dep , name ) ;
60743: LD_VAR 0 1
60747: PPUSH
60748: LD_VAR 0 3
60752: PPUSH
60753: CALL_OW 500
// base := GetBase ( base_dep ) ;
60757: LD_ADDR_VAR 0 15
60761: PUSH
60762: LD_VAR 0 1
60766: PPUSH
60767: CALL_OW 274
60771: ST_TO_ADDR
// side := GetSide ( base_dep ) ;
60772: LD_ADDR_VAR 0 16
60776: PUSH
60777: LD_VAR 0 1
60781: PPUSH
60782: CALL_OW 255
60786: ST_TO_ADDR
// nation := GetNation ( base_dep ) ;
60787: LD_ADDR_VAR 0 17
60791: PUSH
60792: LD_VAR 0 1
60796: PPUSH
60797: CALL_OW 248
60801: ST_TO_ADDR
// if sources then
60802: LD_VAR 0 5
60806: IFFALSE 60853
// for i = 1 to 3 do
60808: LD_ADDR_VAR 0 8
60812: PUSH
60813: DOUBLE
60814: LD_INT 1
60816: DEC
60817: ST_TO_ADDR
60818: LD_INT 3
60820: PUSH
60821: FOR_TO
60822: IFFALSE 60851
// AddResourceType ( base , i , sources [ i ] ) ;
60824: LD_VAR 0 15
60828: PPUSH
60829: LD_VAR 0 8
60833: PPUSH
60834: LD_VAR 0 5
60838: PUSH
60839: LD_VAR 0 8
60843: ARRAY
60844: PPUSH
60845: CALL_OW 276
60849: GO 60821
60851: POP
60852: POP
// buildings := GetBaseBuildings ( base , area ) ;
60853: LD_ADDR_VAR 0 18
60857: PUSH
60858: LD_VAR 0 15
60862: PPUSH
60863: LD_VAR 0 2
60867: PPUSH
60868: CALL 60145 0 2
60872: ST_TO_ADDR
// InitHc ;
60873: CALL_OW 19
// InitUc ;
60877: CALL_OW 18
// uc_side := side ;
60881: LD_ADDR_OWVAR 20
60885: PUSH
60886: LD_VAR 0 16
60890: ST_TO_ADDR
// uc_nation := nation ;
60891: LD_ADDR_OWVAR 21
60895: PUSH
60896: LD_VAR 0 17
60900: ST_TO_ADDR
// if buildings then
60901: LD_VAR 0 18
60905: IFFALSE 62227
// begin tmp := UnitFilter ( buildings , [ f_or , [ f_btype , b_oil_mine ] , [ f_btype , b_siberite_mine ] ] ) ;
60907: LD_ADDR_VAR 0 19
60911: PUSH
60912: LD_VAR 0 18
60916: PPUSH
60917: LD_INT 2
60919: PUSH
60920: LD_INT 30
60922: PUSH
60923: LD_INT 29
60925: PUSH
60926: EMPTY
60927: LIST
60928: LIST
60929: PUSH
60930: LD_INT 30
60932: PUSH
60933: LD_INT 30
60935: PUSH
60936: EMPTY
60937: LIST
60938: LIST
60939: PUSH
60940: EMPTY
60941: LIST
60942: LIST
60943: LIST
60944: PPUSH
60945: CALL_OW 72
60949: ST_TO_ADDR
// if tmp then
60950: LD_VAR 0 19
60954: IFFALSE 61002
// for i in tmp do
60956: LD_ADDR_VAR 0 8
60960: PUSH
60961: LD_VAR 0 19
60965: PUSH
60966: FOR_IN
60967: IFFALSE 61000
// SetResourceVisibility ( GetX ( i ) , GetY ( i ) , side ) ;
60969: LD_VAR 0 8
60973: PPUSH
60974: CALL_OW 250
60978: PPUSH
60979: LD_VAR 0 8
60983: PPUSH
60984: CALL_OW 251
60988: PPUSH
60989: LD_VAR 0 16
60993: PPUSH
60994: CALL_OW 441
60998: GO 60966
61000: POP
61001: POP
// if UnitFilter ( buildings , [ f_or , [ f_btype , b_bunker ] , [ f_btype , b_turret ] ] ) then
61002: LD_VAR 0 18
61006: PPUSH
61007: LD_INT 2
61009: PUSH
61010: LD_INT 30
61012: PUSH
61013: LD_INT 32
61015: PUSH
61016: EMPTY
61017: LIST
61018: LIST
61019: PUSH
61020: LD_INT 30
61022: PUSH
61023: LD_INT 33
61025: PUSH
61026: EMPTY
61027: LIST
61028: LIST
61029: PUSH
61030: EMPTY
61031: LIST
61032: LIST
61033: LIST
61034: PPUSH
61035: CALL_OW 72
61039: IFFALSE 61127
// begin for i in UnitFilter ( buildings , [ f_or , [ f_btype , b_bunker ] , [ f_btype , b_turret ] ] ) do
61041: LD_ADDR_VAR 0 8
61045: PUSH
61046: LD_VAR 0 18
61050: PPUSH
61051: LD_INT 2
61053: PUSH
61054: LD_INT 30
61056: PUSH
61057: LD_INT 32
61059: PUSH
61060: EMPTY
61061: LIST
61062: LIST
61063: PUSH
61064: LD_INT 30
61066: PUSH
61067: LD_INT 33
61069: PUSH
61070: EMPTY
61071: LIST
61072: LIST
61073: PUSH
61074: EMPTY
61075: LIST
61076: LIST
61077: LIST
61078: PPUSH
61079: CALL_OW 72
61083: PUSH
61084: FOR_IN
61085: IFFALSE 61125
// begin if not GetBWeapon ( i ) then
61087: LD_VAR 0 8
61091: PPUSH
61092: CALL_OW 269
61096: NOT
61097: IFFALSE 61123
// PlaceWeaponTurret ( i , GetTurretWeapon ( i , area ) ) ;
61099: LD_VAR 0 8
61103: PPUSH
61104: LD_VAR 0 8
61108: PPUSH
61109: LD_VAR 0 2
61113: PPUSH
61114: CALL 62373 0 2
61118: PPUSH
61119: CALL_OW 431
// end ;
61123: GO 61084
61125: POP
61126: POP
// end ; for i = 1 to personel do
61127: LD_ADDR_VAR 0 8
61131: PUSH
61132: DOUBLE
61133: LD_INT 1
61135: DEC
61136: ST_TO_ADDR
61137: LD_VAR 0 6
61141: PUSH
61142: FOR_TO
61143: IFFALSE 62207
// begin if i > 4 then
61145: LD_VAR 0 8
61149: PUSH
61150: LD_INT 4
61152: GREATER
61153: IFFALSE 61157
// break ;
61155: GO 62207
// case i of 1 :
61157: LD_VAR 0 8
61161: PUSH
61162: LD_INT 1
61164: DOUBLE
61165: EQUAL
61166: IFTRUE 61170
61168: GO 61250
61170: POP
// f := UnitFilter ( buildings , [ [ f_side , side ] , [ f_empty ] , [ f_or , [ f_btype , b_bunker ] , [ f_btype , b_armoury ] , [ f_btype , b_barracks ] ] ] ) ; 2 :
61171: LD_ADDR_VAR 0 12
61175: PUSH
61176: LD_VAR 0 18
61180: PPUSH
61181: LD_INT 22
61183: PUSH
61184: LD_VAR 0 16
61188: PUSH
61189: EMPTY
61190: LIST
61191: LIST
61192: PUSH
61193: LD_INT 58
61195: PUSH
61196: EMPTY
61197: LIST
61198: PUSH
61199: LD_INT 2
61201: PUSH
61202: LD_INT 30
61204: PUSH
61205: LD_INT 32
61207: PUSH
61208: EMPTY
61209: LIST
61210: LIST
61211: PUSH
61212: LD_INT 30
61214: PUSH
61215: LD_INT 4
61217: PUSH
61218: EMPTY
61219: LIST
61220: LIST
61221: PUSH
61222: LD_INT 30
61224: PUSH
61225: LD_INT 5
61227: PUSH
61228: EMPTY
61229: LIST
61230: LIST
61231: PUSH
61232: EMPTY
61233: LIST
61234: LIST
61235: LIST
61236: LIST
61237: PUSH
61238: EMPTY
61239: LIST
61240: LIST
61241: LIST
61242: PPUSH
61243: CALL_OW 72
61247: ST_TO_ADDR
61248: GO 61472
61250: LD_INT 2
61252: DOUBLE
61253: EQUAL
61254: IFTRUE 61258
61256: GO 61320
61258: POP
// f := UnitFilter ( buildings , [ [ f_side , side ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ] ) ; 3 :
61259: LD_ADDR_VAR 0 12
61263: PUSH
61264: LD_VAR 0 18
61268: PPUSH
61269: LD_INT 22
61271: PUSH
61272: LD_VAR 0 16
61276: PUSH
61277: EMPTY
61278: LIST
61279: LIST
61280: PUSH
61281: LD_INT 2
61283: PUSH
61284: LD_INT 30
61286: PUSH
61287: LD_INT 0
61289: PUSH
61290: EMPTY
61291: LIST
61292: LIST
61293: PUSH
61294: LD_INT 30
61296: PUSH
61297: LD_INT 1
61299: PUSH
61300: EMPTY
61301: LIST
61302: LIST
61303: PUSH
61304: EMPTY
61305: LIST
61306: LIST
61307: LIST
61308: PUSH
61309: EMPTY
61310: LIST
61311: LIST
61312: PPUSH
61313: CALL_OW 72
61317: ST_TO_ADDR
61318: GO 61472
61320: LD_INT 3
61322: DOUBLE
61323: EQUAL
61324: IFTRUE 61328
61326: GO 61390
61328: POP
// f := UnitFilter ( buildings , [ [ f_side , side ] , [ f_or , [ f_btype , b_workshop ] , [ f_btype , b_factory ] ] ] ) ; 4 :
61329: LD_ADDR_VAR 0 12
61333: PUSH
61334: LD_VAR 0 18
61338: PPUSH
61339: LD_INT 22
61341: PUSH
61342: LD_VAR 0 16
61346: PUSH
61347: EMPTY
61348: LIST
61349: LIST
61350: PUSH
61351: LD_INT 2
61353: PUSH
61354: LD_INT 30
61356: PUSH
61357: LD_INT 2
61359: PUSH
61360: EMPTY
61361: LIST
61362: LIST
61363: PUSH
61364: LD_INT 30
61366: PUSH
61367: LD_INT 3
61369: PUSH
61370: EMPTY
61371: LIST
61372: LIST
61373: PUSH
61374: EMPTY
61375: LIST
61376: LIST
61377: LIST
61378: PUSH
61379: EMPTY
61380: LIST
61381: LIST
61382: PPUSH
61383: CALL_OW 72
61387: ST_TO_ADDR
61388: GO 61472
61390: LD_INT 4
61392: DOUBLE
61393: EQUAL
61394: IFTRUE 61398
61396: GO 61471
61398: POP
// f := UnitFilter ( buildings , [ [ f_side , side ] , [ f_or , [ f_btype , b_lab ] , [ f_btype , b_lab_half ] , [ f_btype , b_lab_full ] ] ] ) ; end ;
61399: LD_ADDR_VAR 0 12
61403: PUSH
61404: LD_VAR 0 18
61408: PPUSH
61409: LD_INT 22
61411: PUSH
61412: LD_VAR 0 16
61416: PUSH
61417: EMPTY
61418: LIST
61419: LIST
61420: PUSH
61421: LD_INT 2
61423: PUSH
61424: LD_INT 30
61426: PUSH
61427: LD_INT 6
61429: PUSH
61430: EMPTY
61431: LIST
61432: LIST
61433: PUSH
61434: LD_INT 30
61436: PUSH
61437: LD_INT 7
61439: PUSH
61440: EMPTY
61441: LIST
61442: LIST
61443: PUSH
61444: LD_INT 30
61446: PUSH
61447: LD_INT 8
61449: PUSH
61450: EMPTY
61451: LIST
61452: LIST
61453: PUSH
61454: EMPTY
61455: LIST
61456: LIST
61457: LIST
61458: LIST
61459: PUSH
61460: EMPTY
61461: LIST
61462: LIST
61463: PPUSH
61464: CALL_OW 72
61468: ST_TO_ADDR
61469: GO 61472
61471: POP
// if i = 1 then
61472: LD_VAR 0 8
61476: PUSH
61477: LD_INT 1
61479: EQUAL
61480: IFFALSE 61591
// begin tmp := [ ] ;
61482: LD_ADDR_VAR 0 19
61486: PUSH
61487: EMPTY
61488: ST_TO_ADDR
// for j in f do
61489: LD_ADDR_VAR 0 9
61493: PUSH
61494: LD_VAR 0 12
61498: PUSH
61499: FOR_IN
61500: IFFALSE 61573
// if GetBType ( j ) = b_bunker then
61502: LD_VAR 0 9
61506: PPUSH
61507: CALL_OW 266
61511: PUSH
61512: LD_INT 32
61514: EQUAL
61515: IFFALSE 61542
// tmp := Insert ( tmp , 1 , j ) else
61517: LD_ADDR_VAR 0 19
61521: PUSH
61522: LD_VAR 0 19
61526: PPUSH
61527: LD_INT 1
61529: PPUSH
61530: LD_VAR 0 9
61534: PPUSH
61535: CALL_OW 2
61539: ST_TO_ADDR
61540: GO 61571
// tmp := Insert ( tmp , tmp + 1 , j ) ;
61542: LD_ADDR_VAR 0 19
61546: PUSH
61547: LD_VAR 0 19
61551: PPUSH
61552: LD_VAR 0 19
61556: PUSH
61557: LD_INT 1
61559: PLUS
61560: PPUSH
61561: LD_VAR 0 9
61565: PPUSH
61566: CALL_OW 2
61570: ST_TO_ADDR
61571: GO 61499
61573: POP
61574: POP
// if tmp then
61575: LD_VAR 0 19
61579: IFFALSE 61591
// f := tmp ;
61581: LD_ADDR_VAR 0 12
61585: PUSH
61586: LD_VAR 0 19
61590: ST_TO_ADDR
// end ; x := personel [ i ] ;
61591: LD_ADDR_VAR 0 13
61595: PUSH
61596: LD_VAR 0 6
61600: PUSH
61601: LD_VAR 0 8
61605: ARRAY
61606: ST_TO_ADDR
// if x = - 1 then
61607: LD_VAR 0 13
61611: PUSH
61612: LD_INT 1
61614: NEG
61615: EQUAL
61616: IFFALSE 61825
// begin for j in f do
61618: LD_ADDR_VAR 0 9
61622: PUSH
61623: LD_VAR 0 12
61627: PUSH
61628: FOR_IN
61629: IFFALSE 61821
// repeat InitHc ;
61631: CALL_OW 19
// if GetBType ( j ) = b_barracks then
61635: LD_VAR 0 9
61639: PPUSH
61640: CALL_OW 266
61644: PUSH
61645: LD_INT 5
61647: EQUAL
61648: IFFALSE 61718
// begin if UnitsInside ( j ) < 3 then
61650: LD_VAR 0 9
61654: PPUSH
61655: CALL_OW 313
61659: PUSH
61660: LD_INT 3
61662: LESS
61663: IFFALSE 61699
// PrepareHuman ( false , [ class_sniper , class_mortar , class_bazooker ] [ nation ] , skill ) else
61665: LD_INT 0
61667: PPUSH
61668: LD_INT 5
61670: PUSH
61671: LD_INT 8
61673: PUSH
61674: LD_INT 9
61676: PUSH
61677: EMPTY
61678: LIST
61679: LIST
61680: LIST
61681: PUSH
61682: LD_VAR 0 17
61686: ARRAY
61687: PPUSH
61688: LD_VAR 0 4
61692: PPUSH
61693: CALL_OW 380
61697: GO 61716
// PrepareHuman ( false , i , skill ) ;
61699: LD_INT 0
61701: PPUSH
61702: LD_VAR 0 8
61706: PPUSH
61707: LD_VAR 0 4
61711: PPUSH
61712: CALL_OW 380
// end else
61716: GO 61735
// PrepareHuman ( false , i , skill ) ;
61718: LD_INT 0
61720: PPUSH
61721: LD_VAR 0 8
61725: PPUSH
61726: LD_VAR 0 4
61730: PPUSH
61731: CALL_OW 380
// un := CreateHuman ;
61735: LD_ADDR_VAR 0 14
61739: PUSH
61740: CALL_OW 44
61744: ST_TO_ADDR
// result := Insert ( result , 1 , un ) ;
61745: LD_ADDR_VAR 0 7
61749: PUSH
61750: LD_VAR 0 7
61754: PPUSH
61755: LD_INT 1
61757: PPUSH
61758: LD_VAR 0 14
61762: PPUSH
61763: CALL_OW 2
61767: ST_TO_ADDR
// PlaceHumanInUnit ( un , j ) ;
61768: LD_VAR 0 14
61772: PPUSH
61773: LD_VAR 0 9
61777: PPUSH
61778: CALL_OW 52
// until UnitsInside ( j ) = 6 or GetBType ( j ) in [ b_bunker , b_breastwork ] ;
61782: LD_VAR 0 9
61786: PPUSH
61787: CALL_OW 313
61791: PUSH
61792: LD_INT 6
61794: EQUAL
61795: PUSH
61796: LD_VAR 0 9
61800: PPUSH
61801: CALL_OW 266
61805: PUSH
61806: LD_INT 32
61808: PUSH
61809: LD_INT 31
61811: PUSH
61812: EMPTY
61813: LIST
61814: LIST
61815: IN
61816: OR
61817: IFFALSE 61631
61819: GO 61628
61821: POP
61822: POP
// end else
61823: GO 62205
// for j = 1 to x do
61825: LD_ADDR_VAR 0 9
61829: PUSH
61830: DOUBLE
61831: LD_INT 1
61833: DEC
61834: ST_TO_ADDR
61835: LD_VAR 0 13
61839: PUSH
61840: FOR_TO
61841: IFFALSE 62203
// begin InitHc ;
61843: CALL_OW 19
// if not f then
61847: LD_VAR 0 12
61851: NOT
61852: IFFALSE 61941
// begin PrepareHuman ( false , i , skill ) ;
61854: LD_INT 0
61856: PPUSH
61857: LD_VAR 0 8
61861: PPUSH
61862: LD_VAR 0 4
61866: PPUSH
61867: CALL_OW 380
// un := CreateHuman ;
61871: LD_ADDR_VAR 0 14
61875: PUSH
61876: CALL_OW 44
61880: ST_TO_ADDR
// result := Insert ( result , 1 , un ) ;
61881: LD_ADDR_VAR 0 7
61885: PUSH
61886: LD_VAR 0 7
61890: PPUSH
61891: LD_INT 1
61893: PPUSH
61894: LD_VAR 0 14
61898: PPUSH
61899: CALL_OW 2
61903: ST_TO_ADDR
// PlaceUnitXYR ( un , GetX ( base_dep ) , GetY ( base_dep ) , 10 , false ) ;
61904: LD_VAR 0 14
61908: PPUSH
61909: LD_VAR 0 1
61913: PPUSH
61914: CALL_OW 250
61918: PPUSH
61919: LD_VAR 0 1
61923: PPUSH
61924: CALL_OW 251
61928: PPUSH
61929: LD_INT 10
61931: PPUSH
61932: LD_INT 0
61934: PPUSH
61935: CALL_OW 50
// continue ;
61939: GO 61840
// end ; if ( UnitsInside ( f [ 1 ] ) and GetBType ( f [ 1 ] ) in [ b_bunker , b_breastwork ] ) or ( UnitsInside ( f [ 1 ] ) = 6 ) then
61941: LD_VAR 0 12
61945: PUSH
61946: LD_INT 1
61948: ARRAY
61949: PPUSH
61950: CALL_OW 313
61954: PUSH
61955: LD_VAR 0 12
61959: PUSH
61960: LD_INT 1
61962: ARRAY
61963: PPUSH
61964: CALL_OW 266
61968: PUSH
61969: LD_INT 32
61971: PUSH
61972: LD_INT 31
61974: PUSH
61975: EMPTY
61976: LIST
61977: LIST
61978: IN
61979: AND
61980: PUSH
61981: LD_VAR 0 12
61985: PUSH
61986: LD_INT 1
61988: ARRAY
61989: PPUSH
61990: CALL_OW 313
61994: PUSH
61995: LD_INT 6
61997: EQUAL
61998: OR
61999: IFFALSE 62019
// f := Delete ( f , 1 ) ;
62001: LD_ADDR_VAR 0 12
62005: PUSH
62006: LD_VAR 0 12
62010: PPUSH
62011: LD_INT 1
62013: PPUSH
62014: CALL_OW 3
62018: ST_TO_ADDR
// if not f then
62019: LD_VAR 0 12
62023: NOT
62024: IFFALSE 62042
// begin x := x + 2 ;
62026: LD_ADDR_VAR 0 13
62030: PUSH
62031: LD_VAR 0 13
62035: PUSH
62036: LD_INT 2
62038: PLUS
62039: ST_TO_ADDR
// continue ;
62040: GO 61840
// end ; if GetBType ( f [ 1 ] ) = b_barracks then
62042: LD_VAR 0 12
62046: PUSH
62047: LD_INT 1
62049: ARRAY
62050: PPUSH
62051: CALL_OW 266
62055: PUSH
62056: LD_INT 5
62058: EQUAL
62059: IFFALSE 62133
// begin if UnitsInside ( f [ 1 ] ) < 3 then
62061: LD_VAR 0 12
62065: PUSH
62066: LD_INT 1
62068: ARRAY
62069: PPUSH
62070: CALL_OW 313
62074: PUSH
62075: LD_INT 3
62077: LESS
62078: IFFALSE 62114
// PrepareHuman ( false , [ class_sniper , class_mortar , class_bazooker ] [ nation ] , skill ) else
62080: LD_INT 0
62082: PPUSH
62083: LD_INT 5
62085: PUSH
62086: LD_INT 8
62088: PUSH
62089: LD_INT 9
62091: PUSH
62092: EMPTY
62093: LIST
62094: LIST
62095: LIST
62096: PUSH
62097: LD_VAR 0 17
62101: ARRAY
62102: PPUSH
62103: LD_VAR 0 4
62107: PPUSH
62108: CALL_OW 380
62112: GO 62131
// PrepareHuman ( false , i , skill ) ;
62114: LD_INT 0
62116: PPUSH
62117: LD_VAR 0 8
62121: PPUSH
62122: LD_VAR 0 4
62126: PPUSH
62127: CALL_OW 380
// end else
62131: GO 62150
// PrepareHuman ( false , i , skill ) ;
62133: LD_INT 0
62135: PPUSH
62136: LD_VAR 0 8
62140: PPUSH
62141: LD_VAR 0 4
62145: PPUSH
62146: CALL_OW 380
// un := CreateHuman ;
62150: LD_ADDR_VAR 0 14
62154: PUSH
62155: CALL_OW 44
62159: ST_TO_ADDR
// result := Insert ( result , 1 , un ) ;
62160: LD_ADDR_VAR 0 7
62164: PUSH
62165: LD_VAR 0 7
62169: PPUSH
62170: LD_INT 1
62172: PPUSH
62173: LD_VAR 0 14
62177: PPUSH
62178: CALL_OW 2
62182: ST_TO_ADDR
// PlaceHumanInUnit ( un , f [ 1 ] ) ;
62183: LD_VAR 0 14
62187: PPUSH
62188: LD_VAR 0 12
62192: PUSH
62193: LD_INT 1
62195: ARRAY
62196: PPUSH
62197: CALL_OW 52
// end ;
62201: GO 61840
62203: POP
62204: POP
// end ;
62205: GO 61142
62207: POP
62208: POP
// result := result ^ buildings ;
62209: LD_ADDR_VAR 0 7
62213: PUSH
62214: LD_VAR 0 7
62218: PUSH
62219: LD_VAR 0 18
62223: ADD
62224: ST_TO_ADDR
// end else
62225: GO 62368
// begin for i = 1 to personel do
62227: LD_ADDR_VAR 0 8
62231: PUSH
62232: DOUBLE
62233: LD_INT 1
62235: DEC
62236: ST_TO_ADDR
62237: LD_VAR 0 6
62241: PUSH
62242: FOR_TO
62243: IFFALSE 62366
// begin if i > 4 then
62245: LD_VAR 0 8
62249: PUSH
62250: LD_INT 4
62252: GREATER
62253: IFFALSE 62257
// break ;
62255: GO 62366
// x := personel [ i ] ;
62257: LD_ADDR_VAR 0 13
62261: PUSH
62262: LD_VAR 0 6
62266: PUSH
62267: LD_VAR 0 8
62271: ARRAY
62272: ST_TO_ADDR
// if x = - 1 then
62273: LD_VAR 0 13
62277: PUSH
62278: LD_INT 1
62280: NEG
62281: EQUAL
62282: IFFALSE 62286
// continue ;
62284: GO 62242
// PrepareHuman ( false , i , skill ) ;
62286: LD_INT 0
62288: PPUSH
62289: LD_VAR 0 8
62293: PPUSH
62294: LD_VAR 0 4
62298: PPUSH
62299: CALL_OW 380
// un := CreateHuman ;
62303: LD_ADDR_VAR 0 14
62307: PUSH
62308: CALL_OW 44
62312: ST_TO_ADDR
// PlaceUnitXYR ( un , GetX ( base_dep ) , GetY ( base_dep ) , 10 , false ) ;
62313: LD_VAR 0 14
62317: PPUSH
62318: LD_VAR 0 1
62322: PPUSH
62323: CALL_OW 250
62327: PPUSH
62328: LD_VAR 0 1
62332: PPUSH
62333: CALL_OW 251
62337: PPUSH
62338: LD_INT 10
62340: PPUSH
62341: LD_INT 0
62343: PPUSH
62344: CALL_OW 50
// result := result ^ un ;
62348: LD_ADDR_VAR 0 7
62352: PUSH
62353: LD_VAR 0 7
62357: PUSH
62358: LD_VAR 0 14
62362: ADD
62363: ST_TO_ADDR
// end ;
62364: GO 62242
62366: POP
62367: POP
// end ; end ;
62368: LD_VAR 0 7
62372: RET
// export function GetTurretWeapon ( tower , area ) ; var hex , list , factories , base , i , j , x , y , nat , h , tmp , height , side , fac_list , weapon ; begin
62373: LD_INT 0
62375: PPUSH
62376: PPUSH
62377: PPUSH
62378: PPUSH
62379: PPUSH
62380: PPUSH
62381: PPUSH
62382: PPUSH
62383: PPUSH
62384: PPUSH
62385: PPUSH
62386: PPUSH
62387: PPUSH
62388: PPUSH
62389: PPUSH
62390: PPUSH
// result := false ;
62391: LD_ADDR_VAR 0 3
62395: PUSH
62396: LD_INT 0
62398: ST_TO_ADDR
// if not tower or not GetBType ( tower ) in [ b_bunker , b_turret ] then
62399: LD_VAR 0 1
62403: NOT
62404: PUSH
62405: LD_VAR 0 1
62409: PPUSH
62410: CALL_OW 266
62414: PUSH
62415: LD_INT 32
62417: PUSH
62418: LD_INT 33
62420: PUSH
62421: EMPTY
62422: LIST
62423: LIST
62424: IN
62425: NOT
62426: OR
62427: IFFALSE 62431
// exit ;
62429: GO 63567
// nat := GetNation ( tower ) ;
62431: LD_ADDR_VAR 0 12
62435: PUSH
62436: LD_VAR 0 1
62440: PPUSH
62441: CALL_OW 248
62445: ST_TO_ADDR
// side := GetSide ( tower ) ;
62446: LD_ADDR_VAR 0 16
62450: PUSH
62451: LD_VAR 0 1
62455: PPUSH
62456: CALL_OW 255
62460: ST_TO_ADDR
// x := GetX ( tower ) ;
62461: LD_ADDR_VAR 0 10
62465: PUSH
62466: LD_VAR 0 1
62470: PPUSH
62471: CALL_OW 250
62475: ST_TO_ADDR
// y := GetY ( tower ) ;
62476: LD_ADDR_VAR 0 11
62480: PUSH
62481: LD_VAR 0 1
62485: PPUSH
62486: CALL_OW 251
62490: ST_TO_ADDR
// if not x or not y then
62491: LD_VAR 0 10
62495: NOT
62496: PUSH
62497: LD_VAR 0 11
62501: NOT
62502: OR
62503: IFFALSE 62507
// exit ;
62505: GO 63567
// weapon := 0 ;
62507: LD_ADDR_VAR 0 18
62511: PUSH
62512: LD_INT 0
62514: ST_TO_ADDR
// fac_list := [ ] ;
62515: LD_ADDR_VAR 0 17
62519: PUSH
62520: EMPTY
62521: ST_TO_ADDR
// factories := UnitFilter ( GetBaseBuildings ( GetBase ( tower ) , area ) , [ f_btype , b_factory ] ) ;
62522: LD_ADDR_VAR 0 6
62526: PUSH
62527: LD_VAR 0 1
62531: PPUSH
62532: CALL_OW 274
62536: PPUSH
62537: LD_VAR 0 2
62541: PPUSH
62542: CALL 60145 0 2
62546: PPUSH
62547: LD_INT 30
62549: PUSH
62550: LD_INT 3
62552: PUSH
62553: EMPTY
62554: LIST
62555: LIST
62556: PPUSH
62557: CALL_OW 72
62561: ST_TO_ADDR
// if not factories then
62562: LD_VAR 0 6
62566: NOT
62567: IFFALSE 62571
// exit ;
62569: GO 63567
// for i in factories do
62571: LD_ADDR_VAR 0 8
62575: PUSH
62576: LD_VAR 0 6
62580: PUSH
62581: FOR_IN
62582: IFFALSE 62607
// fac_list := fac_list union AvailableWeaponList ( i ) ;
62584: LD_ADDR_VAR 0 17
62588: PUSH
62589: LD_VAR 0 17
62593: PUSH
62594: LD_VAR 0 8
62598: PPUSH
62599: CALL_OW 478
62603: UNION
62604: ST_TO_ADDR
62605: GO 62581
62607: POP
62608: POP
// if not fac_list then
62609: LD_VAR 0 17
62613: NOT
62614: IFFALSE 62618
// exit ;
62616: GO 63567
// list := [ [ us_gatling_gun , us_double_gun , us_laser , us_double_laser , us_heavy_gun , us_rocket_launcher , us_radar ] , [ ar_gun , ar_rocket_launcher , ar_flame_thrower , ar_radar ] , [ ru_gatling_gun , ru_gun , ru_heavy_gun , ru_rocket_launcher , ru_rocket , ru_time_lapser ] ] [ nat ] ;
62618: LD_ADDR_VAR 0 5
62622: PUSH
62623: LD_INT 4
62625: PUSH
62626: LD_INT 5
62628: PUSH
62629: LD_INT 9
62631: PUSH
62632: LD_INT 10
62634: PUSH
62635: LD_INT 6
62637: PUSH
62638: LD_INT 7
62640: PUSH
62641: LD_INT 11
62643: PUSH
62644: EMPTY
62645: LIST
62646: LIST
62647: LIST
62648: LIST
62649: LIST
62650: LIST
62651: LIST
62652: PUSH
62653: LD_INT 27
62655: PUSH
62656: LD_INT 28
62658: PUSH
62659: LD_INT 26
62661: PUSH
62662: LD_INT 30
62664: PUSH
62665: EMPTY
62666: LIST
62667: LIST
62668: LIST
62669: LIST
62670: PUSH
62671: LD_INT 43
62673: PUSH
62674: LD_INT 44
62676: PUSH
62677: LD_INT 46
62679: PUSH
62680: LD_INT 45
62682: PUSH
62683: LD_INT 47
62685: PUSH
62686: LD_INT 49
62688: PUSH
62689: EMPTY
62690: LIST
62691: LIST
62692: LIST
62693: LIST
62694: LIST
62695: LIST
62696: PUSH
62697: EMPTY
62698: LIST
62699: LIST
62700: LIST
62701: PUSH
62702: LD_VAR 0 12
62706: ARRAY
62707: ST_TO_ADDR
// for i in list do
62708: LD_ADDR_VAR 0 8
62712: PUSH
62713: LD_VAR 0 5
62717: PUSH
62718: FOR_IN
62719: IFFALSE 62752
// if not i in fac_list then
62721: LD_VAR 0 8
62725: PUSH
62726: LD_VAR 0 17
62730: IN
62731: NOT
62732: IFFALSE 62750
// list := list diff i ;
62734: LD_ADDR_VAR 0 5
62738: PUSH
62739: LD_VAR 0 5
62743: PUSH
62744: LD_VAR 0 8
62748: DIFF
62749: ST_TO_ADDR
62750: GO 62718
62752: POP
62753: POP
// if not list then
62754: LD_VAR 0 5
62758: NOT
62759: IFFALSE 62763
// exit ;
62761: GO 63567
// if nat = nation_russian and ru_time_lapser in list and GetTech ( tech_lapser , side ) = state_researched then
62763: LD_VAR 0 12
62767: PUSH
62768: LD_INT 3
62770: EQUAL
62771: PUSH
62772: LD_INT 49
62774: PUSH
62775: LD_VAR 0 5
62779: IN
62780: AND
62781: PUSH
62782: LD_INT 31
62784: PPUSH
62785: LD_VAR 0 16
62789: PPUSH
62790: CALL_OW 321
62794: PUSH
62795: LD_INT 2
62797: EQUAL
62798: AND
62799: IFFALSE 62859
// begin if not FilterAllUnits ( [ [ f_side , side ] , [ f_bweapon , ru_time_lapser ] , [ f_dist , tower , 10 ] ] ) then
62801: LD_INT 22
62803: PUSH
62804: LD_VAR 0 16
62808: PUSH
62809: EMPTY
62810: LIST
62811: LIST
62812: PUSH
62813: LD_INT 35
62815: PUSH
62816: LD_INT 49
62818: PUSH
62819: EMPTY
62820: LIST
62821: LIST
62822: PUSH
62823: LD_INT 91
62825: PUSH
62826: LD_VAR 0 1
62830: PUSH
62831: LD_INT 10
62833: PUSH
62834: EMPTY
62835: LIST
62836: LIST
62837: LIST
62838: PUSH
62839: EMPTY
62840: LIST
62841: LIST
62842: LIST
62843: PPUSH
62844: CALL_OW 69
62848: NOT
62849: IFFALSE 62859
// weapon := ru_time_lapser ;
62851: LD_ADDR_VAR 0 18
62855: PUSH
62856: LD_INT 49
62858: ST_TO_ADDR
// end ; if nat in [ 1 , 2 ] and ( us_radar in list or ar_radar in list ) and GetTech ( tech_radar , side ) = state_researched then
62859: LD_VAR 0 12
62863: PUSH
62864: LD_INT 1
62866: PUSH
62867: LD_INT 2
62869: PUSH
62870: EMPTY
62871: LIST
62872: LIST
62873: IN
62874: PUSH
62875: LD_INT 11
62877: PUSH
62878: LD_VAR 0 5
62882: IN
62883: PUSH
62884: LD_INT 30
62886: PUSH
62887: LD_VAR 0 5
62891: IN
62892: OR
62893: AND
62894: PUSH
62895: LD_INT 6
62897: PPUSH
62898: LD_VAR 0 16
62902: PPUSH
62903: CALL_OW 321
62907: PUSH
62908: LD_INT 2
62910: EQUAL
62911: AND
62912: IFFALSE 63077
// begin if not FilterAllUnits ( [ [ f_side , side ] , [ f_or , [ f_bweapon , us_radar ] , [ f_bweapon , ar_radar ] ] , [ f_dist , tower , 18 ] ] ) and FilterAllUnits ( [ [ [ f_side , side ] , [ f_or , [ f_btype , b_bunker ] , [ f_btype , b_turret ] ] , [ f_dist , tower , 12 ] ] ] ) > 2 then
62914: LD_INT 22
62916: PUSH
62917: LD_VAR 0 16
62921: PUSH
62922: EMPTY
62923: LIST
62924: LIST
62925: PUSH
62926: LD_INT 2
62928: PUSH
62929: LD_INT 35
62931: PUSH
62932: LD_INT 11
62934: PUSH
62935: EMPTY
62936: LIST
62937: LIST
62938: PUSH
62939: LD_INT 35
62941: PUSH
62942: LD_INT 30
62944: PUSH
62945: EMPTY
62946: LIST
62947: LIST
62948: PUSH
62949: EMPTY
62950: LIST
62951: LIST
62952: LIST
62953: PUSH
62954: LD_INT 91
62956: PUSH
62957: LD_VAR 0 1
62961: PUSH
62962: LD_INT 18
62964: PUSH
62965: EMPTY
62966: LIST
62967: LIST
62968: LIST
62969: PUSH
62970: EMPTY
62971: LIST
62972: LIST
62973: LIST
62974: PPUSH
62975: CALL_OW 69
62979: NOT
62980: PUSH
62981: LD_INT 22
62983: PUSH
62984: LD_VAR 0 16
62988: PUSH
62989: EMPTY
62990: LIST
62991: LIST
62992: PUSH
62993: LD_INT 2
62995: PUSH
62996: LD_INT 30
62998: PUSH
62999: LD_INT 32
63001: PUSH
63002: EMPTY
63003: LIST
63004: LIST
63005: PUSH
63006: LD_INT 30
63008: PUSH
63009: LD_INT 33
63011: PUSH
63012: EMPTY
63013: LIST
63014: LIST
63015: PUSH
63016: EMPTY
63017: LIST
63018: LIST
63019: LIST
63020: PUSH
63021: LD_INT 91
63023: PUSH
63024: LD_VAR 0 1
63028: PUSH
63029: LD_INT 12
63031: PUSH
63032: EMPTY
63033: LIST
63034: LIST
63035: LIST
63036: PUSH
63037: EMPTY
63038: LIST
63039: LIST
63040: LIST
63041: PUSH
63042: EMPTY
63043: LIST
63044: PPUSH
63045: CALL_OW 69
63049: PUSH
63050: LD_INT 2
63052: GREATER
63053: AND
63054: IFFALSE 63077
// weapon := [ us_radar , ar_radar ] [ nat ] ;
63056: LD_ADDR_VAR 0 18
63060: PUSH
63061: LD_INT 11
63063: PUSH
63064: LD_INT 30
63066: PUSH
63067: EMPTY
63068: LIST
63069: LIST
63070: PUSH
63071: LD_VAR 0 12
63075: ARRAY
63076: ST_TO_ADDR
// end ; if not weapon and GetTech ( tech_rocket , side ) = state_researched and ( us_rocket_launcher in list or ar_rocket_launcher in list or ru_rocket_launcher in list ) then
63077: LD_VAR 0 18
63081: NOT
63082: PUSH
63083: LD_INT 40
63085: PPUSH
63086: LD_VAR 0 16
63090: PPUSH
63091: CALL_OW 321
63095: PUSH
63096: LD_INT 2
63098: EQUAL
63099: AND
63100: PUSH
63101: LD_INT 7
63103: PUSH
63104: LD_VAR 0 5
63108: IN
63109: PUSH
63110: LD_INT 28
63112: PUSH
63113: LD_VAR 0 5
63117: IN
63118: OR
63119: PUSH
63120: LD_INT 45
63122: PUSH
63123: LD_VAR 0 5
63127: IN
63128: OR
63129: AND
63130: IFFALSE 63384
// begin hex := GetHexInfo ( x , y ) ;
63132: LD_ADDR_VAR 0 4
63136: PUSH
63137: LD_VAR 0 10
63141: PPUSH
63142: LD_VAR 0 11
63146: PPUSH
63147: CALL_OW 546
63151: ST_TO_ADDR
// if hex [ 1 ] then
63152: LD_VAR 0 4
63156: PUSH
63157: LD_INT 1
63159: ARRAY
63160: IFFALSE 63164
// exit ;
63162: GO 63567
// height := hex [ 2 ] ;
63164: LD_ADDR_VAR 0 15
63168: PUSH
63169: LD_VAR 0 4
63173: PUSH
63174: LD_INT 2
63176: ARRAY
63177: ST_TO_ADDR
// tmp := [ 0 , 2 , 3 , 5 ] ;
63178: LD_ADDR_VAR 0 14
63182: PUSH
63183: LD_INT 0
63185: PUSH
63186: LD_INT 2
63188: PUSH
63189: LD_INT 3
63191: PUSH
63192: LD_INT 5
63194: PUSH
63195: EMPTY
63196: LIST
63197: LIST
63198: LIST
63199: LIST
63200: ST_TO_ADDR
// for i in tmp do
63201: LD_ADDR_VAR 0 8
63205: PUSH
63206: LD_VAR 0 14
63210: PUSH
63211: FOR_IN
63212: IFFALSE 63382
// begin j := [ ShiftX ( x , i , 5 ) , ShiftY ( y , i , 5 ) ] ;
63214: LD_ADDR_VAR 0 9
63218: PUSH
63219: LD_VAR 0 10
63223: PPUSH
63224: LD_VAR 0 8
63228: PPUSH
63229: LD_INT 5
63231: PPUSH
63232: CALL_OW 272
63236: PUSH
63237: LD_VAR 0 11
63241: PPUSH
63242: LD_VAR 0 8
63246: PPUSH
63247: LD_INT 5
63249: PPUSH
63250: CALL_OW 273
63254: PUSH
63255: EMPTY
63256: LIST
63257: LIST
63258: ST_TO_ADDR
// if ValidHex ( j [ 1 ] , j [ 2 ] ) then
63259: LD_VAR 0 9
63263: PUSH
63264: LD_INT 1
63266: ARRAY
63267: PPUSH
63268: LD_VAR 0 9
63272: PUSH
63273: LD_INT 2
63275: ARRAY
63276: PPUSH
63277: CALL_OW 488
63281: IFFALSE 63380
// begin hex := GetHexInfo ( j [ 1 ] , j [ 2 ] ) ;
63283: LD_ADDR_VAR 0 4
63287: PUSH
63288: LD_VAR 0 9
63292: PUSH
63293: LD_INT 1
63295: ARRAY
63296: PPUSH
63297: LD_VAR 0 9
63301: PUSH
63302: LD_INT 2
63304: ARRAY
63305: PPUSH
63306: CALL_OW 546
63310: ST_TO_ADDR
// if hex [ 1 ] then
63311: LD_VAR 0 4
63315: PUSH
63316: LD_INT 1
63318: ARRAY
63319: IFFALSE 63323
// continue ;
63321: GO 63211
// h := hex [ 2 ] ;
63323: LD_ADDR_VAR 0 13
63327: PUSH
63328: LD_VAR 0 4
63332: PUSH
63333: LD_INT 2
63335: ARRAY
63336: ST_TO_ADDR
// if h + 7 < height then
63337: LD_VAR 0 13
63341: PUSH
63342: LD_INT 7
63344: PLUS
63345: PUSH
63346: LD_VAR 0 15
63350: LESS
63351: IFFALSE 63380
// begin weapon := [ us_rocket_launcher , ar_rocket_launcher , ru_rocket_launcher ] [ nat ] ;
63353: LD_ADDR_VAR 0 18
63357: PUSH
63358: LD_INT 7
63360: PUSH
63361: LD_INT 28
63363: PUSH
63364: LD_INT 45
63366: PUSH
63367: EMPTY
63368: LIST
63369: LIST
63370: LIST
63371: PUSH
63372: LD_VAR 0 12
63376: ARRAY
63377: ST_TO_ADDR
// break ;
63378: GO 63382
// end ; end ; end ;
63380: GO 63211
63382: POP
63383: POP
// end ; if not weapon then
63384: LD_VAR 0 18
63388: NOT
63389: IFFALSE 63449
// begin list := list diff [ us_radar , ar_radar , ru_time_lapser ] ;
63391: LD_ADDR_VAR 0 5
63395: PUSH
63396: LD_VAR 0 5
63400: PUSH
63401: LD_INT 11
63403: PUSH
63404: LD_INT 30
63406: PUSH
63407: LD_INT 49
63409: PUSH
63410: EMPTY
63411: LIST
63412: LIST
63413: LIST
63414: DIFF
63415: ST_TO_ADDR
// if not list then
63416: LD_VAR 0 5
63420: NOT
63421: IFFALSE 63425
// exit ;
63423: GO 63567
// weapon := list [ rand ( 1 , list ) ] ;
63425: LD_ADDR_VAR 0 18
63429: PUSH
63430: LD_VAR 0 5
63434: PUSH
63435: LD_INT 1
63437: PPUSH
63438: LD_VAR 0 5
63442: PPUSH
63443: CALL_OW 12
63447: ARRAY
63448: ST_TO_ADDR
// end ; if weapon then
63449: LD_VAR 0 18
63453: IFFALSE 63567
// begin tmp := CostOfWeapon ( weapon ) ;
63455: LD_ADDR_VAR 0 14
63459: PUSH
63460: LD_VAR 0 18
63464: PPUSH
63465: CALL_OW 451
63469: ST_TO_ADDR
// j := GetBase ( tower ) ;
63470: LD_ADDR_VAR 0 9
63474: PUSH
63475: LD_VAR 0 1
63479: PPUSH
63480: CALL_OW 274
63484: ST_TO_ADDR
// if GetResourceType ( j , mat_cans ) >= tmp [ 1 ] and GetResourceType ( j , mat_oil ) >= tmp [ 2 ] and GetResourceType ( j , mat_siberit ) >= tmp [ 3 ] then
63485: LD_VAR 0 9
63489: PPUSH
63490: LD_INT 1
63492: PPUSH
63493: CALL_OW 275
63497: PUSH
63498: LD_VAR 0 14
63502: PUSH
63503: LD_INT 1
63505: ARRAY
63506: GREATEREQUAL
63507: PUSH
63508: LD_VAR 0 9
63512: PPUSH
63513: LD_INT 2
63515: PPUSH
63516: CALL_OW 275
63520: PUSH
63521: LD_VAR 0 14
63525: PUSH
63526: LD_INT 2
63528: ARRAY
63529: GREATEREQUAL
63530: AND
63531: PUSH
63532: LD_VAR 0 9
63536: PPUSH
63537: LD_INT 3
63539: PPUSH
63540: CALL_OW 275
63544: PUSH
63545: LD_VAR 0 14
63549: PUSH
63550: LD_INT 3
63552: ARRAY
63553: GREATEREQUAL
63554: AND
63555: IFFALSE 63567
// result := weapon ;
63557: LD_ADDR_VAR 0 3
63561: PUSH
63562: LD_VAR 0 18
63566: ST_TO_ADDR
// end ; end ;
63567: LD_VAR 0 3
63571: RET
// export function CompareArray ( array1 , array2 ) ; var i ; begin
63572: LD_INT 0
63574: PPUSH
63575: PPUSH
// result := true ;
63576: LD_ADDR_VAR 0 3
63580: PUSH
63581: LD_INT 1
63583: ST_TO_ADDR
// if array1 = array2 then
63584: LD_VAR 0 1
63588: PUSH
63589: LD_VAR 0 2
63593: EQUAL
63594: IFFALSE 63654
// begin for i = 1 to array1 do
63596: LD_ADDR_VAR 0 4
63600: PUSH
63601: DOUBLE
63602: LD_INT 1
63604: DEC
63605: ST_TO_ADDR
63606: LD_VAR 0 1
63610: PUSH
63611: FOR_TO
63612: IFFALSE 63650
// if array1 [ i ] <> array2 [ i ] then
63614: LD_VAR 0 1
63618: PUSH
63619: LD_VAR 0 4
63623: ARRAY
63624: PUSH
63625: LD_VAR 0 2
63629: PUSH
63630: LD_VAR 0 4
63634: ARRAY
63635: NONEQUAL
63636: IFFALSE 63648
// begin result := false ;
63638: LD_ADDR_VAR 0 3
63642: PUSH
63643: LD_INT 0
63645: ST_TO_ADDR
// break ;
63646: GO 63650
// end ;
63648: GO 63611
63650: POP
63651: POP
// end else
63652: GO 63662
// result := false ;
63654: LD_ADDR_VAR 0 3
63658: PUSH
63659: LD_INT 0
63661: ST_TO_ADDR
// end ;
63662: LD_VAR 0 3
63666: RET
// export function VehicleCost ( fac , list ) ; var cost , pom ; begin
63667: LD_INT 0
63669: PPUSH
63670: PPUSH
63671: PPUSH
// pom := GetBase ( fac ) ;
63672: LD_ADDR_VAR 0 5
63676: PUSH
63677: LD_VAR 0 1
63681: PPUSH
63682: CALL_OW 274
63686: ST_TO_ADDR
// cost := CostOfVehicle ( list [ 1 ] , list [ 2 ] , list [ 3 ] , list [ 4 ] ) ;
63687: LD_ADDR_VAR 0 4
63691: PUSH
63692: LD_VAR 0 2
63696: PUSH
63697: LD_INT 1
63699: ARRAY
63700: PPUSH
63701: LD_VAR 0 2
63705: PUSH
63706: LD_INT 2
63708: ARRAY
63709: PPUSH
63710: LD_VAR 0 2
63714: PUSH
63715: LD_INT 3
63717: ARRAY
63718: PPUSH
63719: LD_VAR 0 2
63723: PUSH
63724: LD_INT 4
63726: ARRAY
63727: PPUSH
63728: CALL_OW 449
63732: ST_TO_ADDR
// result := GetResourceType ( pom , mat_cans ) >= cost [ 1 ] and GetResourceType ( pom , mat_oil ) >= cost [ 2 ] and GetResourceType ( pom , mat_siberit ) >= cost [ 3 ] ;
63733: LD_ADDR_VAR 0 3
63737: PUSH
63738: LD_VAR 0 5
63742: PPUSH
63743: LD_INT 1
63745: PPUSH
63746: CALL_OW 275
63750: PUSH
63751: LD_VAR 0 4
63755: PUSH
63756: LD_INT 1
63758: ARRAY
63759: GREATEREQUAL
63760: PUSH
63761: LD_VAR 0 5
63765: PPUSH
63766: LD_INT 2
63768: PPUSH
63769: CALL_OW 275
63773: PUSH
63774: LD_VAR 0 4
63778: PUSH
63779: LD_INT 2
63781: ARRAY
63782: GREATEREQUAL
63783: AND
63784: PUSH
63785: LD_VAR 0 5
63789: PPUSH
63790: LD_INT 3
63792: PPUSH
63793: CALL_OW 275
63797: PUSH
63798: LD_VAR 0 4
63802: PUSH
63803: LD_INT 3
63805: ARRAY
63806: GREATEREQUAL
63807: AND
63808: ST_TO_ADDR
// end ;
63809: LD_VAR 0 3
63813: RET
// export function UpgradeCost ( building ) ; var pom , cost , btype ; begin
63814: LD_INT 0
63816: PPUSH
63817: PPUSH
63818: PPUSH
63819: PPUSH
// pom := GetBase ( building ) ;
63820: LD_ADDR_VAR 0 3
63824: PUSH
63825: LD_VAR 0 1
63829: PPUSH
63830: CALL_OW 274
63834: ST_TO_ADDR
// if not pom then
63835: LD_VAR 0 3
63839: NOT
63840: IFFALSE 63844
// exit ;
63842: GO 64014
// btype := GetBType ( building ) ;
63844: LD_ADDR_VAR 0 5
63848: PUSH
63849: LD_VAR 0 1
63853: PPUSH
63854: CALL_OW 266
63858: ST_TO_ADDR
// if btype = b_armoury then
63859: LD_VAR 0 5
63863: PUSH
63864: LD_INT 4
63866: EQUAL
63867: IFFALSE 63877
// btype := b_barracks ;
63869: LD_ADDR_VAR 0 5
63873: PUSH
63874: LD_INT 5
63876: ST_TO_ADDR
// if btype = b_depot then
63877: LD_VAR 0 5
63881: PUSH
63882: LD_INT 0
63884: EQUAL
63885: IFFALSE 63895
// btype := b_warehouse ;
63887: LD_ADDR_VAR 0 5
63891: PUSH
63892: LD_INT 1
63894: ST_TO_ADDR
// if btype = b_workshop then
63895: LD_VAR 0 5
63899: PUSH
63900: LD_INT 2
63902: EQUAL
63903: IFFALSE 63913
// btype := b_factory ;
63905: LD_ADDR_VAR 0 5
63909: PUSH
63910: LD_INT 3
63912: ST_TO_ADDR
// cost := CostOfBuilding ( btype , GetNation ( building ) ) ;
63913: LD_ADDR_VAR 0 4
63917: PUSH
63918: LD_VAR 0 5
63922: PPUSH
63923: LD_VAR 0 1
63927: PPUSH
63928: CALL_OW 248
63932: PPUSH
63933: CALL_OW 450
63937: ST_TO_ADDR
// result := GetResourceType ( pom , mat_cans ) >= cost [ 1 ] and GetResourceType ( pom , mat_oil ) >= cost [ 2 ] and GetResourceType ( pom , mat_siberit ) >= cost [ 3 ] ;
63938: LD_ADDR_VAR 0 2
63942: PUSH
63943: LD_VAR 0 3
63947: PPUSH
63948: LD_INT 1
63950: PPUSH
63951: CALL_OW 275
63955: PUSH
63956: LD_VAR 0 4
63960: PUSH
63961: LD_INT 1
63963: ARRAY
63964: GREATEREQUAL
63965: PUSH
63966: LD_VAR 0 3
63970: PPUSH
63971: LD_INT 2
63973: PPUSH
63974: CALL_OW 275
63978: PUSH
63979: LD_VAR 0 4
63983: PUSH
63984: LD_INT 2
63986: ARRAY
63987: GREATEREQUAL
63988: AND
63989: PUSH
63990: LD_VAR 0 3
63994: PPUSH
63995: LD_INT 3
63997: PPUSH
63998: CALL_OW 275
64002: PUSH
64003: LD_VAR 0 4
64007: PUSH
64008: LD_INT 3
64010: ARRAY
64011: GREATEREQUAL
64012: AND
64013: ST_TO_ADDR
// end ;
64014: LD_VAR 0 2
64018: RET
// export function UpgradeLabCost ( building , btype ) ; var pom , cost ; begin
64019: LD_INT 0
64021: PPUSH
64022: PPUSH
64023: PPUSH
// pom := GetBase ( building ) ;
64024: LD_ADDR_VAR 0 4
64028: PUSH
64029: LD_VAR 0 1
64033: PPUSH
64034: CALL_OW 274
64038: ST_TO_ADDR
// if not pom then
64039: LD_VAR 0 4
64043: NOT
64044: IFFALSE 64048
// exit ;
64046: GO 64149
// cost := CostOfBuilding ( btype , GetNation ( building ) ) ;
64048: LD_ADDR_VAR 0 5
64052: PUSH
64053: LD_VAR 0 2
64057: PPUSH
64058: LD_VAR 0 1
64062: PPUSH
64063: CALL_OW 248
64067: PPUSH
64068: CALL_OW 450
64072: ST_TO_ADDR
// result := GetResourceType ( pom , mat_cans ) >= cost [ 1 ] and GetResourceType ( pom , mat_oil ) >= cost [ 2 ] and GetResourceType ( pom , mat_siberit ) >= cost [ 3 ] ;
64073: LD_ADDR_VAR 0 3
64077: PUSH
64078: LD_VAR 0 4
64082: PPUSH
64083: LD_INT 1
64085: PPUSH
64086: CALL_OW 275
64090: PUSH
64091: LD_VAR 0 5
64095: PUSH
64096: LD_INT 1
64098: ARRAY
64099: GREATEREQUAL
64100: PUSH
64101: LD_VAR 0 4
64105: PPUSH
64106: LD_INT 2
64108: PPUSH
64109: CALL_OW 275
64113: PUSH
64114: LD_VAR 0 5
64118: PUSH
64119: LD_INT 2
64121: ARRAY
64122: GREATEREQUAL
64123: AND
64124: PUSH
64125: LD_VAR 0 4
64129: PPUSH
64130: LD_INT 3
64132: PPUSH
64133: CALL_OW 275
64137: PUSH
64138: LD_VAR 0 5
64142: PUSH
64143: LD_INT 3
64145: ARRAY
64146: GREATEREQUAL
64147: AND
64148: ST_TO_ADDR
// end ;
64149: LD_VAR 0 3
64153: RET
// export function TryClearPlaceForBuilding ( base , btype , x , y , d ) ; var i , j , _x , _y , tmp , hexes , r , xy , dep ; begin
64154: LD_INT 0
64156: PPUSH
64157: PPUSH
64158: PPUSH
64159: PPUSH
64160: PPUSH
64161: PPUSH
64162: PPUSH
64163: PPUSH
64164: PPUSH
64165: PPUSH
// result := false ;
64166: LD_ADDR_VAR 0 6
64170: PUSH
64171: LD_INT 0
64173: ST_TO_ADDR
// if not base or not btype or not x or not y then
64174: LD_VAR 0 1
64178: NOT
64179: PUSH
64180: LD_VAR 0 2
64184: NOT
64185: OR
64186: PUSH
64187: LD_VAR 0 3
64191: NOT
64192: OR
64193: PUSH
64194: LD_VAR 0 4
64198: NOT
64199: OR
64200: IFFALSE 64204
// exit ;
64202: GO 64813
// hexes := GetBuildingHexes ( btype , x , y , d , GetNation ( base [ 1 ] ) , 0 ) ;
64204: LD_ADDR_VAR 0 12
64208: PUSH
64209: LD_VAR 0 2
64213: PPUSH
64214: LD_VAR 0 3
64218: PPUSH
64219: LD_VAR 0 4
64223: PPUSH
64224: LD_VAR 0 5
64228: PPUSH
64229: LD_VAR 0 1
64233: PUSH
64234: LD_INT 1
64236: ARRAY
64237: PPUSH
64238: CALL_OW 248
64242: PPUSH
64243: LD_INT 0
64245: PPUSH
64246: CALL 65650 0 6
64250: ST_TO_ADDR
// if not hexes then
64251: LD_VAR 0 12
64255: NOT
64256: IFFALSE 64260
// exit ;
64258: GO 64813
// for i = 1 to hexes do
64260: LD_ADDR_VAR 0 7
64264: PUSH
64265: DOUBLE
64266: LD_INT 1
64268: DEC
64269: ST_TO_ADDR
64270: LD_VAR 0 12
64274: PUSH
64275: FOR_TO
64276: IFFALSE 64811
// begin tmp := HexInfo ( hexes [ i ] [ 1 ] , hexes [ i ] [ 2 ] ) ;
64278: LD_ADDR_VAR 0 11
64282: PUSH
64283: LD_VAR 0 12
64287: PUSH
64288: LD_VAR 0 7
64292: ARRAY
64293: PUSH
64294: LD_INT 1
64296: ARRAY
64297: PPUSH
64298: LD_VAR 0 12
64302: PUSH
64303: LD_VAR 0 7
64307: ARRAY
64308: PUSH
64309: LD_INT 2
64311: ARRAY
64312: PPUSH
64313: CALL_OW 428
64317: ST_TO_ADDR
// if IsEnvironment ( hexes [ i ] [ 1 ] , hexes [ i ] [ 2 ] ) or not ValidHex ( hexes [ i ] [ 1 ] , hexes [ i ] [ 2 ] ) or GetType ( tmp ) = unit_building then
64318: LD_VAR 0 12
64322: PUSH
64323: LD_VAR 0 7
64327: ARRAY
64328: PUSH
64329: LD_INT 1
64331: ARRAY
64332: PPUSH
64333: LD_VAR 0 12
64337: PUSH
64338: LD_VAR 0 7
64342: ARRAY
64343: PUSH
64344: LD_INT 2
64346: ARRAY
64347: PPUSH
64348: CALL_OW 351
64352: PUSH
64353: LD_VAR 0 12
64357: PUSH
64358: LD_VAR 0 7
64362: ARRAY
64363: PUSH
64364: LD_INT 1
64366: ARRAY
64367: PPUSH
64368: LD_VAR 0 12
64372: PUSH
64373: LD_VAR 0 7
64377: ARRAY
64378: PUSH
64379: LD_INT 2
64381: ARRAY
64382: PPUSH
64383: CALL_OW 488
64387: NOT
64388: OR
64389: PUSH
64390: LD_VAR 0 11
64394: PPUSH
64395: CALL_OW 247
64399: PUSH
64400: LD_INT 3
64402: EQUAL
64403: OR
64404: IFFALSE 64410
// exit ;
64406: POP
64407: POP
64408: GO 64813
// if not tmp or not tmp in base then
64410: LD_VAR 0 11
64414: NOT
64415: PUSH
64416: LD_VAR 0 11
64420: PUSH
64421: LD_VAR 0 1
64425: IN
64426: NOT
64427: OR
64428: IFFALSE 64432
// continue ;
64430: GO 64275
// result := true ;
64432: LD_ADDR_VAR 0 6
64436: PUSH
64437: LD_INT 1
64439: ST_TO_ADDR
// dep := UnitFilter ( base , [ [ f_side , GetSide ( tmp ) ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ] ) ;
64440: LD_ADDR_VAR 0 15
64444: PUSH
64445: LD_VAR 0 1
64449: PPUSH
64450: LD_INT 22
64452: PUSH
64453: LD_VAR 0 11
64457: PPUSH
64458: CALL_OW 255
64462: PUSH
64463: EMPTY
64464: LIST
64465: LIST
64466: PUSH
64467: LD_INT 2
64469: PUSH
64470: LD_INT 30
64472: PUSH
64473: LD_INT 0
64475: PUSH
64476: EMPTY
64477: LIST
64478: LIST
64479: PUSH
64480: LD_INT 30
64482: PUSH
64483: LD_INT 1
64485: PUSH
64486: EMPTY
64487: LIST
64488: LIST
64489: PUSH
64490: EMPTY
64491: LIST
64492: LIST
64493: LIST
64494: PUSH
64495: EMPTY
64496: LIST
64497: LIST
64498: PPUSH
64499: CALL_OW 72
64503: ST_TO_ADDR
// if dep then
64504: LD_VAR 0 15
64508: IFFALSE 64644
// begin xy := [ ShiftX ( GetX ( dep [ 1 ] ) , GetDir ( dep [ 1 ] ) , 5 ) , ShiftY ( GetY ( dep [ 1 ] ) , GetDir ( dep [ 1 ] ) , 5 ) ] ;
64510: LD_ADDR_VAR 0 14
64514: PUSH
64515: LD_VAR 0 15
64519: PUSH
64520: LD_INT 1
64522: ARRAY
64523: PPUSH
64524: CALL_OW 250
64528: PPUSH
64529: LD_VAR 0 15
64533: PUSH
64534: LD_INT 1
64536: ARRAY
64537: PPUSH
64538: CALL_OW 254
64542: PPUSH
64543: LD_INT 5
64545: PPUSH
64546: CALL_OW 272
64550: PUSH
64551: LD_VAR 0 15
64555: PUSH
64556: LD_INT 1
64558: ARRAY
64559: PPUSH
64560: CALL_OW 251
64564: PPUSH
64565: LD_VAR 0 15
64569: PUSH
64570: LD_INT 1
64572: ARRAY
64573: PPUSH
64574: CALL_OW 254
64578: PPUSH
64579: LD_INT 5
64581: PPUSH
64582: CALL_OW 273
64586: PUSH
64587: EMPTY
64588: LIST
64589: LIST
64590: ST_TO_ADDR
// if ValidHex ( xy [ 1 ] , xy [ 2 ] ) then
64591: LD_VAR 0 14
64595: PUSH
64596: LD_INT 1
64598: ARRAY
64599: PPUSH
64600: LD_VAR 0 14
64604: PUSH
64605: LD_INT 2
64607: ARRAY
64608: PPUSH
64609: CALL_OW 488
64613: IFFALSE 64644
// begin ComMoveXY ( tmp , xy [ 1 ] , xy [ 2 ] ) ;
64615: LD_VAR 0 11
64619: PPUSH
64620: LD_VAR 0 14
64624: PUSH
64625: LD_INT 1
64627: ARRAY
64628: PPUSH
64629: LD_VAR 0 14
64633: PUSH
64634: LD_INT 2
64636: ARRAY
64637: PPUSH
64638: CALL_OW 111
// continue ;
64642: GO 64275
// end ; end ; r := GetDir ( tmp ) ;
64644: LD_ADDR_VAR 0 13
64648: PUSH
64649: LD_VAR 0 11
64653: PPUSH
64654: CALL_OW 254
64658: ST_TO_ADDR
// if r = 5 then
64659: LD_VAR 0 13
64663: PUSH
64664: LD_INT 5
64666: EQUAL
64667: IFFALSE 64677
// r := 0 ;
64669: LD_ADDR_VAR 0 13
64673: PUSH
64674: LD_INT 0
64676: ST_TO_ADDR
// for j = r to 5 do
64677: LD_ADDR_VAR 0 8
64681: PUSH
64682: DOUBLE
64683: LD_VAR 0 13
64687: DEC
64688: ST_TO_ADDR
64689: LD_INT 5
64691: PUSH
64692: FOR_TO
64693: IFFALSE 64807
// begin _x := ShiftX ( GetX ( tmp ) , j , 2 ) ;
64695: LD_ADDR_VAR 0 9
64699: PUSH
64700: LD_VAR 0 11
64704: PPUSH
64705: CALL_OW 250
64709: PPUSH
64710: LD_VAR 0 8
64714: PPUSH
64715: LD_INT 2
64717: PPUSH
64718: CALL_OW 272
64722: ST_TO_ADDR
// _y := ShiftY ( GetY ( tmp ) , j , 2 ) ;
64723: LD_ADDR_VAR 0 10
64727: PUSH
64728: LD_VAR 0 11
64732: PPUSH
64733: CALL_OW 251
64737: PPUSH
64738: LD_VAR 0 8
64742: PPUSH
64743: LD_INT 2
64745: PPUSH
64746: CALL_OW 273
64750: ST_TO_ADDR
// if ValidHex ( _x , _y ) and not HexInfo ( _x , _y ) then
64751: LD_VAR 0 9
64755: PPUSH
64756: LD_VAR 0 10
64760: PPUSH
64761: CALL_OW 488
64765: PUSH
64766: LD_VAR 0 9
64770: PPUSH
64771: LD_VAR 0 10
64775: PPUSH
64776: CALL_OW 428
64780: NOT
64781: AND
64782: IFFALSE 64805
// begin ComMoveXY ( tmp , _x , _y ) ;
64784: LD_VAR 0 11
64788: PPUSH
64789: LD_VAR 0 9
64793: PPUSH
64794: LD_VAR 0 10
64798: PPUSH
64799: CALL_OW 111
// break ;
64803: GO 64807
// end ; end ;
64805: GO 64692
64807: POP
64808: POP
// end ;
64809: GO 64275
64811: POP
64812: POP
// end ;
64813: LD_VAR 0 6
64817: RET
// export function CanBeBuilt ( depot , btype , x , y , d ) ; var i , j , side , pom , cost , hexes , height , dist , hex ; begin
64818: LD_INT 0
64820: PPUSH
64821: PPUSH
64822: PPUSH
64823: PPUSH
64824: PPUSH
64825: PPUSH
64826: PPUSH
64827: PPUSH
64828: PPUSH
64829: PPUSH
// result := false ;
64830: LD_ADDR_VAR 0 6
64834: PUSH
64835: LD_INT 0
64837: ST_TO_ADDR
// if not depot or not GetBType ( depot ) in [ b_depot , b_warehouse ] or not btype or not d in [ 0 , 1 , 2 , 3 , 4 , 5 ] or not ValidHex ( x , y ) then
64838: LD_VAR 0 1
64842: NOT
64843: PUSH
64844: LD_VAR 0 1
64848: PPUSH
64849: CALL_OW 266
64853: PUSH
64854: LD_INT 0
64856: PUSH
64857: LD_INT 1
64859: PUSH
64860: EMPTY
64861: LIST
64862: LIST
64863: IN
64864: NOT
64865: OR
64866: PUSH
64867: LD_VAR 0 2
64871: NOT
64872: OR
64873: PUSH
64874: LD_VAR 0 5
64878: PUSH
64879: LD_INT 0
64881: PUSH
64882: LD_INT 1
64884: PUSH
64885: LD_INT 2
64887: PUSH
64888: LD_INT 3
64890: PUSH
64891: LD_INT 4
64893: PUSH
64894: LD_INT 5
64896: PUSH
64897: EMPTY
64898: LIST
64899: LIST
64900: LIST
64901: LIST
64902: LIST
64903: LIST
64904: IN
64905: NOT
64906: OR
64907: PUSH
64908: LD_VAR 0 3
64912: PPUSH
64913: LD_VAR 0 4
64917: PPUSH
64918: CALL_OW 488
64922: NOT
64923: OR
64924: IFFALSE 64928
// exit ;
64926: GO 65645
// pom := GetBase ( depot ) ;
64928: LD_ADDR_VAR 0 10
64932: PUSH
64933: LD_VAR 0 1
64937: PPUSH
64938: CALL_OW 274
64942: ST_TO_ADDR
// cost := CostOfBuilding ( btype , GetNation ( depot ) ) ;
64943: LD_ADDR_VAR 0 11
64947: PUSH
64948: LD_VAR 0 2
64952: PPUSH
64953: LD_VAR 0 1
64957: PPUSH
64958: CALL_OW 248
64962: PPUSH
64963: CALL_OW 450
64967: ST_TO_ADDR
// if not ( GetResourceType ( pom , mat_cans ) >= cost [ 1 ] and GetResourceType ( pom , mat_oil ) >= cost [ 2 ] and GetResourceType ( pom , mat_siberit ) >= cost [ 3 ] ) then
64968: LD_VAR 0 10
64972: PPUSH
64973: LD_INT 1
64975: PPUSH
64976: CALL_OW 275
64980: PUSH
64981: LD_VAR 0 11
64985: PUSH
64986: LD_INT 1
64988: ARRAY
64989: GREATEREQUAL
64990: PUSH
64991: LD_VAR 0 10
64995: PPUSH
64996: LD_INT 2
64998: PPUSH
64999: CALL_OW 275
65003: PUSH
65004: LD_VAR 0 11
65008: PUSH
65009: LD_INT 2
65011: ARRAY
65012: GREATEREQUAL
65013: AND
65014: PUSH
65015: LD_VAR 0 10
65019: PPUSH
65020: LD_INT 3
65022: PPUSH
65023: CALL_OW 275
65027: PUSH
65028: LD_VAR 0 11
65032: PUSH
65033: LD_INT 3
65035: ARRAY
65036: GREATEREQUAL
65037: AND
65038: NOT
65039: IFFALSE 65043
// exit ;
65041: GO 65645
// if GetBType ( depot ) = b_depot then
65043: LD_VAR 0 1
65047: PPUSH
65048: CALL_OW 266
65052: PUSH
65053: LD_INT 0
65055: EQUAL
65056: IFFALSE 65068
// dist := 28 else
65058: LD_ADDR_VAR 0 14
65062: PUSH
65063: LD_INT 28
65065: ST_TO_ADDR
65066: GO 65076
// dist := 36 ;
65068: LD_ADDR_VAR 0 14
65072: PUSH
65073: LD_INT 36
65075: ST_TO_ADDR
// if GetDistUnitXY ( depot , x , y ) > dist then
65076: LD_VAR 0 1
65080: PPUSH
65081: LD_VAR 0 3
65085: PPUSH
65086: LD_VAR 0 4
65090: PPUSH
65091: CALL_OW 297
65095: PUSH
65096: LD_VAR 0 14
65100: GREATER
65101: IFFALSE 65105
// exit ;
65103: GO 65645
// hexes := GetBuildingHexes ( btype , x , y , d , GetNation ( depot ) , 0 ) ;
65105: LD_ADDR_VAR 0 12
65109: PUSH
65110: LD_VAR 0 2
65114: PPUSH
65115: LD_VAR 0 3
65119: PPUSH
65120: LD_VAR 0 4
65124: PPUSH
65125: LD_VAR 0 5
65129: PPUSH
65130: LD_VAR 0 1
65134: PPUSH
65135: CALL_OW 248
65139: PPUSH
65140: LD_INT 0
65142: PPUSH
65143: CALL 65650 0 6
65147: ST_TO_ADDR
// if not hexes then
65148: LD_VAR 0 12
65152: NOT
65153: IFFALSE 65157
// exit ;
65155: GO 65645
// hex := GetHexInfo ( x , y ) ;
65157: LD_ADDR_VAR 0 15
65161: PUSH
65162: LD_VAR 0 3
65166: PPUSH
65167: LD_VAR 0 4
65171: PPUSH
65172: CALL_OW 546
65176: ST_TO_ADDR
// if hex [ 1 ] then
65177: LD_VAR 0 15
65181: PUSH
65182: LD_INT 1
65184: ARRAY
65185: IFFALSE 65189
// exit ;
65187: GO 65645
// height := hex [ 2 ] ;
65189: LD_ADDR_VAR 0 13
65193: PUSH
65194: LD_VAR 0 15
65198: PUSH
65199: LD_INT 2
65201: ARRAY
65202: ST_TO_ADDR
// for i = 1 to hexes do
65203: LD_ADDR_VAR 0 7
65207: PUSH
65208: DOUBLE
65209: LD_INT 1
65211: DEC
65212: ST_TO_ADDR
65213: LD_VAR 0 12
65217: PUSH
65218: FOR_TO
65219: IFFALSE 65549
// begin if not ValidHex ( hexes [ i ] [ 1 ] , hexes [ i ] [ 2 ] ) or HexInfo ( hexes [ i ] [ 1 ] , hexes [ i ] [ 2 ] ) > 0 or IsEnvironment ( hexes [ i ] [ 1 ] , hexes [ i ] [ 2 ] ) then
65221: LD_VAR 0 12
65225: PUSH
65226: LD_VAR 0 7
65230: ARRAY
65231: PUSH
65232: LD_INT 1
65234: ARRAY
65235: PPUSH
65236: LD_VAR 0 12
65240: PUSH
65241: LD_VAR 0 7
65245: ARRAY
65246: PUSH
65247: LD_INT 2
65249: ARRAY
65250: PPUSH
65251: CALL_OW 488
65255: NOT
65256: PUSH
65257: LD_VAR 0 12
65261: PUSH
65262: LD_VAR 0 7
65266: ARRAY
65267: PUSH
65268: LD_INT 1
65270: ARRAY
65271: PPUSH
65272: LD_VAR 0 12
65276: PUSH
65277: LD_VAR 0 7
65281: ARRAY
65282: PUSH
65283: LD_INT 2
65285: ARRAY
65286: PPUSH
65287: CALL_OW 428
65291: PUSH
65292: LD_INT 0
65294: GREATER
65295: OR
65296: PUSH
65297: LD_VAR 0 12
65301: PUSH
65302: LD_VAR 0 7
65306: ARRAY
65307: PUSH
65308: LD_INT 1
65310: ARRAY
65311: PPUSH
65312: LD_VAR 0 12
65316: PUSH
65317: LD_VAR 0 7
65321: ARRAY
65322: PUSH
65323: LD_INT 2
65325: ARRAY
65326: PPUSH
65327: CALL_OW 351
65331: OR
65332: IFFALSE 65338
// exit ;
65334: POP
65335: POP
65336: GO 65645
// j := GetHexInfo ( hexes [ i ] [ 1 ] , hexes [ i ] [ 2 ] ) ;
65338: LD_ADDR_VAR 0 8
65342: PUSH
65343: LD_VAR 0 12
65347: PUSH
65348: LD_VAR 0 7
65352: ARRAY
65353: PUSH
65354: LD_INT 1
65356: ARRAY
65357: PPUSH
65358: LD_VAR 0 12
65362: PUSH
65363: LD_VAR 0 7
65367: ARRAY
65368: PUSH
65369: LD_INT 2
65371: ARRAY
65372: PPUSH
65373: CALL_OW 546
65377: ST_TO_ADDR
// if j [ 1 ] or j [ 2 ] > height + 2 or j [ 2 ] < height - 2 or not j [ 3 ] in [ 0 , 8 , 9 , 10 , 11 , 12 , 13 , 16 , 17 , 18 , 19 , 20 , 21 ] or not j [ 5 ] or not j [ 6 ] in [ 1 , 2 , 7 , 9 , 10 , 11 ] then
65378: LD_VAR 0 8
65382: PUSH
65383: LD_INT 1
65385: ARRAY
65386: PUSH
65387: LD_VAR 0 8
65391: PUSH
65392: LD_INT 2
65394: ARRAY
65395: PUSH
65396: LD_VAR 0 13
65400: PUSH
65401: LD_INT 2
65403: PLUS
65404: GREATER
65405: OR
65406: PUSH
65407: LD_VAR 0 8
65411: PUSH
65412: LD_INT 2
65414: ARRAY
65415: PUSH
65416: LD_VAR 0 13
65420: PUSH
65421: LD_INT 2
65423: MINUS
65424: LESS
65425: OR
65426: PUSH
65427: LD_VAR 0 8
65431: PUSH
65432: LD_INT 3
65434: ARRAY
65435: PUSH
65436: LD_INT 0
65438: PUSH
65439: LD_INT 8
65441: PUSH
65442: LD_INT 9
65444: PUSH
65445: LD_INT 10
65447: PUSH
65448: LD_INT 11
65450: PUSH
65451: LD_INT 12
65453: PUSH
65454: LD_INT 13
65456: PUSH
65457: LD_INT 16
65459: PUSH
65460: LD_INT 17
65462: PUSH
65463: LD_INT 18
65465: PUSH
65466: LD_INT 19
65468: PUSH
65469: LD_INT 20
65471: PUSH
65472: LD_INT 21
65474: PUSH
65475: EMPTY
65476: LIST
65477: LIST
65478: LIST
65479: LIST
65480: LIST
65481: LIST
65482: LIST
65483: LIST
65484: LIST
65485: LIST
65486: LIST
65487: LIST
65488: LIST
65489: IN
65490: NOT
65491: OR
65492: PUSH
65493: LD_VAR 0 8
65497: PUSH
65498: LD_INT 5
65500: ARRAY
65501: NOT
65502: OR
65503: PUSH
65504: LD_VAR 0 8
65508: PUSH
65509: LD_INT 6
65511: ARRAY
65512: PUSH
65513: LD_INT 1
65515: PUSH
65516: LD_INT 2
65518: PUSH
65519: LD_INT 7
65521: PUSH
65522: LD_INT 9
65524: PUSH
65525: LD_INT 10
65527: PUSH
65528: LD_INT 11
65530: PUSH
65531: EMPTY
65532: LIST
65533: LIST
65534: LIST
65535: LIST
65536: LIST
65537: LIST
65538: IN
65539: NOT
65540: OR
65541: IFFALSE 65547
// exit ;
65543: POP
65544: POP
65545: GO 65645
// end ;
65547: GO 65218
65549: POP
65550: POP
// side := GetSide ( depot ) ;
65551: LD_ADDR_VAR 0 9
65555: PUSH
65556: LD_VAR 0 1
65560: PPUSH
65561: CALL_OW 255
65565: ST_TO_ADDR
// if DangerAtRangeXY ( side , x , y , 20 ) [ 4 ] then
65566: LD_VAR 0 9
65570: PPUSH
65571: LD_VAR 0 3
65575: PPUSH
65576: LD_VAR 0 4
65580: PPUSH
65581: LD_INT 20
65583: PPUSH
65584: CALL 58299 0 4
65588: PUSH
65589: LD_INT 4
65591: ARRAY
65592: IFFALSE 65596
// exit ;
65594: GO 65645
// if btype in [ b_oil_mine , b_siberite_mine ] and not GetResourceVisibility ( x , y , side ) then
65596: LD_VAR 0 2
65600: PUSH
65601: LD_INT 29
65603: PUSH
65604: LD_INT 30
65606: PUSH
65607: EMPTY
65608: LIST
65609: LIST
65610: IN
65611: PUSH
65612: LD_VAR 0 3
65616: PPUSH
65617: LD_VAR 0 4
65621: PPUSH
65622: LD_VAR 0 9
65626: PPUSH
65627: CALL_OW 440
65631: NOT
65632: AND
65633: IFFALSE 65637
// exit ;
65635: GO 65645
// result := true ;
65637: LD_ADDR_VAR 0 6
65641: PUSH
65642: LD_INT 1
65644: ST_TO_ADDR
// end ;
65645: LD_VAR 0 6
65649: RET
// export function GetBuildingHexes ( btype , x , y , dir , nation , mode ) ; var i , temp_list , temp_list2 ; var DepotAm0 , DepotAm1 , DepotAm2 , DepotAm3 , DepotAm4 , DepotAm5 , DepotAr0 , DepotAr1 , DepotAr2 , DepotAr3 , DepotAr4 , DepotAr5 , DepotRu0 , DepotRu1 , DepotRu2 , DepotRu3 , DepotRu4 , DepotRu5 ; var Factory0 , Factory1 , Factory2 , Factory3 , Factory4 , Factory5 , Ext0 , Ext1 , Ext2 , Ext3 , Ext4 , Ext5 ; var Lab0 , Lab1 , Lab2 , Lab3 , Lab4 , Lab5 , ControlTower0 , ControlTower1 , ControlTower2 , ControlTower3 , ControlTower4 , ControlTower5 ; var Barracks0 , Barracks1 , Barracks2 , Barracks3 , Barracks4 , Barracks5 , Bunker0 , Bunker1 , Bunker2 , Bunker3 , Bunker4 , Bunker5 ; begin
65650: LD_INT 0
65652: PPUSH
65653: PPUSH
65654: PPUSH
65655: PPUSH
65656: PPUSH
65657: PPUSH
65658: PPUSH
65659: PPUSH
65660: PPUSH
65661: PPUSH
65662: PPUSH
65663: PPUSH
65664: PPUSH
65665: PPUSH
65666: PPUSH
65667: PPUSH
65668: PPUSH
65669: PPUSH
65670: PPUSH
65671: PPUSH
65672: PPUSH
65673: PPUSH
65674: PPUSH
65675: PPUSH
65676: PPUSH
65677: PPUSH
65678: PPUSH
65679: PPUSH
65680: PPUSH
65681: PPUSH
65682: PPUSH
65683: PPUSH
65684: PPUSH
65685: PPUSH
65686: PPUSH
65687: PPUSH
65688: PPUSH
65689: PPUSH
65690: PPUSH
65691: PPUSH
65692: PPUSH
65693: PPUSH
65694: PPUSH
65695: PPUSH
65696: PPUSH
65697: PPUSH
65698: PPUSH
65699: PPUSH
65700: PPUSH
65701: PPUSH
65702: PPUSH
65703: PPUSH
65704: PPUSH
65705: PPUSH
65706: PPUSH
65707: PPUSH
65708: PPUSH
65709: PPUSH
// result = [ ] ;
65710: LD_ADDR_VAR 0 7
65714: PUSH
65715: EMPTY
65716: ST_TO_ADDR
// temp_list = [ ] ;
65717: LD_ADDR_VAR 0 9
65721: PUSH
65722: EMPTY
65723: ST_TO_ADDR
// if not dir in [ 0 , 1 , 2 , 3 , 4 , 5 ] or ( btype in [ b_depot , b_warehouse ] and not nation in [ nation_american , nation_arabian , nation_russian ] ) then
65724: LD_VAR 0 4
65728: PUSH
65729: LD_INT 0
65731: PUSH
65732: LD_INT 1
65734: PUSH
65735: LD_INT 2
65737: PUSH
65738: LD_INT 3
65740: PUSH
65741: LD_INT 4
65743: PUSH
65744: LD_INT 5
65746: PUSH
65747: EMPTY
65748: LIST
65749: LIST
65750: LIST
65751: LIST
65752: LIST
65753: LIST
65754: IN
65755: NOT
65756: PUSH
65757: LD_VAR 0 1
65761: PUSH
65762: LD_INT 0
65764: PUSH
65765: LD_INT 1
65767: PUSH
65768: EMPTY
65769: LIST
65770: LIST
65771: IN
65772: PUSH
65773: LD_VAR 0 5
65777: PUSH
65778: LD_INT 1
65780: PUSH
65781: LD_INT 2
65783: PUSH
65784: LD_INT 3
65786: PUSH
65787: EMPTY
65788: LIST
65789: LIST
65790: LIST
65791: IN
65792: NOT
65793: AND
65794: OR
65795: IFFALSE 65799
// exit ;
65797: GO 84190
// if btype in [ b_lab , b_lab_half , b_lab_full , b_lab_biological , b_lab_computer , b_lab_opto , b_lab_siberium , b_lab_spacetime , b_lab_weapon ] then
65799: LD_VAR 0 1
65803: PUSH
65804: LD_INT 6
65806: PUSH
65807: LD_INT 7
65809: PUSH
65810: LD_INT 8
65812: PUSH
65813: LD_INT 13
65815: PUSH
65816: LD_INT 12
65818: PUSH
65819: LD_INT 15
65821: PUSH
65822: LD_INT 11
65824: PUSH
65825: LD_INT 14
65827: PUSH
65828: LD_INT 10
65830: PUSH
65831: EMPTY
65832: LIST
65833: LIST
65834: LIST
65835: LIST
65836: LIST
65837: LIST
65838: LIST
65839: LIST
65840: LIST
65841: IN
65842: IFFALSE 65852
// btype = b_lab ;
65844: LD_ADDR_VAR 0 1
65848: PUSH
65849: LD_INT 6
65851: ST_TO_ADDR
// if not mode in [ 0 , 1 , 2 ] or ( not btype in [ b_depot , b_warehouse , b_workshop , b_factory , b_lab , b_control_tower , b_armoury , b_barracks , b_breastwork , b_bunker , b_turret ] and mode = 1 ) or ( not btype in [ b_workshop , b_factory ] and mode = 2 ) then
65852: LD_VAR 0 6
65856: PUSH
65857: LD_INT 0
65859: PUSH
65860: LD_INT 1
65862: PUSH
65863: LD_INT 2
65865: PUSH
65866: EMPTY
65867: LIST
65868: LIST
65869: LIST
65870: IN
65871: NOT
65872: PUSH
65873: LD_VAR 0 1
65877: PUSH
65878: LD_INT 0
65880: PUSH
65881: LD_INT 1
65883: PUSH
65884: LD_INT 2
65886: PUSH
65887: LD_INT 3
65889: PUSH
65890: LD_INT 6
65892: PUSH
65893: LD_INT 36
65895: PUSH
65896: LD_INT 4
65898: PUSH
65899: LD_INT 5
65901: PUSH
65902: LD_INT 31
65904: PUSH
65905: LD_INT 32
65907: PUSH
65908: LD_INT 33
65910: PUSH
65911: EMPTY
65912: LIST
65913: LIST
65914: LIST
65915: LIST
65916: LIST
65917: LIST
65918: LIST
65919: LIST
65920: LIST
65921: LIST
65922: LIST
65923: IN
65924: NOT
65925: PUSH
65926: LD_VAR 0 6
65930: PUSH
65931: LD_INT 1
65933: EQUAL
65934: AND
65935: OR
65936: PUSH
65937: LD_VAR 0 1
65941: PUSH
65942: LD_INT 2
65944: PUSH
65945: LD_INT 3
65947: PUSH
65948: EMPTY
65949: LIST
65950: LIST
65951: IN
65952: NOT
65953: PUSH
65954: LD_VAR 0 6
65958: PUSH
65959: LD_INT 2
65961: EQUAL
65962: AND
65963: OR
65964: IFFALSE 65974
// mode = 0 ;
65966: LD_ADDR_VAR 0 6
65970: PUSH
65971: LD_INT 0
65973: ST_TO_ADDR
// case mode of 0 :
65974: LD_VAR 0 6
65978: PUSH
65979: LD_INT 0
65981: DOUBLE
65982: EQUAL
65983: IFTRUE 65987
65985: GO 77440
65987: POP
// begin DepotAm0 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ 1 , 3 ] , [ 0 , 3 ] , [ - 1 , 2 ] ] ;
65988: LD_ADDR_VAR 0 11
65992: PUSH
65993: LD_INT 0
65995: PUSH
65996: LD_INT 0
65998: PUSH
65999: EMPTY
66000: LIST
66001: LIST
66002: PUSH
66003: LD_INT 0
66005: PUSH
66006: LD_INT 1
66008: NEG
66009: PUSH
66010: EMPTY
66011: LIST
66012: LIST
66013: PUSH
66014: LD_INT 1
66016: PUSH
66017: LD_INT 0
66019: PUSH
66020: EMPTY
66021: LIST
66022: LIST
66023: PUSH
66024: LD_INT 1
66026: PUSH
66027: LD_INT 1
66029: PUSH
66030: EMPTY
66031: LIST
66032: LIST
66033: PUSH
66034: LD_INT 0
66036: PUSH
66037: LD_INT 1
66039: PUSH
66040: EMPTY
66041: LIST
66042: LIST
66043: PUSH
66044: LD_INT 1
66046: NEG
66047: PUSH
66048: LD_INT 0
66050: PUSH
66051: EMPTY
66052: LIST
66053: LIST
66054: PUSH
66055: LD_INT 1
66057: NEG
66058: PUSH
66059: LD_INT 1
66061: NEG
66062: PUSH
66063: EMPTY
66064: LIST
66065: LIST
66066: PUSH
66067: LD_INT 1
66069: NEG
66070: PUSH
66071: LD_INT 2
66073: NEG
66074: PUSH
66075: EMPTY
66076: LIST
66077: LIST
66078: PUSH
66079: LD_INT 0
66081: PUSH
66082: LD_INT 2
66084: NEG
66085: PUSH
66086: EMPTY
66087: LIST
66088: LIST
66089: PUSH
66090: LD_INT 1
66092: PUSH
66093: LD_INT 1
66095: NEG
66096: PUSH
66097: EMPTY
66098: LIST
66099: LIST
66100: PUSH
66101: LD_INT 1
66103: PUSH
66104: LD_INT 2
66106: PUSH
66107: EMPTY
66108: LIST
66109: LIST
66110: PUSH
66111: LD_INT 0
66113: PUSH
66114: LD_INT 2
66116: PUSH
66117: EMPTY
66118: LIST
66119: LIST
66120: PUSH
66121: LD_INT 1
66123: NEG
66124: PUSH
66125: LD_INT 1
66127: PUSH
66128: EMPTY
66129: LIST
66130: LIST
66131: PUSH
66132: LD_INT 1
66134: PUSH
66135: LD_INT 3
66137: PUSH
66138: EMPTY
66139: LIST
66140: LIST
66141: PUSH
66142: LD_INT 0
66144: PUSH
66145: LD_INT 3
66147: PUSH
66148: EMPTY
66149: LIST
66150: LIST
66151: PUSH
66152: LD_INT 1
66154: NEG
66155: PUSH
66156: LD_INT 2
66158: PUSH
66159: EMPTY
66160: LIST
66161: LIST
66162: PUSH
66163: EMPTY
66164: LIST
66165: LIST
66166: LIST
66167: LIST
66168: LIST
66169: LIST
66170: LIST
66171: LIST
66172: LIST
66173: LIST
66174: LIST
66175: LIST
66176: LIST
66177: LIST
66178: LIST
66179: LIST
66180: ST_TO_ADDR
// DepotAm1 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , 1 ] , [ - 3 , 0 ] , [ - 3 , - 1 ] ] ;
66181: LD_ADDR_VAR 0 12
66185: PUSH
66186: LD_INT 0
66188: PUSH
66189: LD_INT 0
66191: PUSH
66192: EMPTY
66193: LIST
66194: LIST
66195: PUSH
66196: LD_INT 0
66198: PUSH
66199: LD_INT 1
66201: NEG
66202: PUSH
66203: EMPTY
66204: LIST
66205: LIST
66206: PUSH
66207: LD_INT 1
66209: PUSH
66210: LD_INT 0
66212: PUSH
66213: EMPTY
66214: LIST
66215: LIST
66216: PUSH
66217: LD_INT 1
66219: PUSH
66220: LD_INT 1
66222: PUSH
66223: EMPTY
66224: LIST
66225: LIST
66226: PUSH
66227: LD_INT 0
66229: PUSH
66230: LD_INT 1
66232: PUSH
66233: EMPTY
66234: LIST
66235: LIST
66236: PUSH
66237: LD_INT 1
66239: NEG
66240: PUSH
66241: LD_INT 0
66243: PUSH
66244: EMPTY
66245: LIST
66246: LIST
66247: PUSH
66248: LD_INT 1
66250: NEG
66251: PUSH
66252: LD_INT 1
66254: NEG
66255: PUSH
66256: EMPTY
66257: LIST
66258: LIST
66259: PUSH
66260: LD_INT 1
66262: PUSH
66263: LD_INT 1
66265: NEG
66266: PUSH
66267: EMPTY
66268: LIST
66269: LIST
66270: PUSH
66271: LD_INT 2
66273: PUSH
66274: LD_INT 0
66276: PUSH
66277: EMPTY
66278: LIST
66279: LIST
66280: PUSH
66281: LD_INT 2
66283: PUSH
66284: LD_INT 1
66286: PUSH
66287: EMPTY
66288: LIST
66289: LIST
66290: PUSH
66291: LD_INT 1
66293: NEG
66294: PUSH
66295: LD_INT 1
66297: PUSH
66298: EMPTY
66299: LIST
66300: LIST
66301: PUSH
66302: LD_INT 2
66304: NEG
66305: PUSH
66306: LD_INT 0
66308: PUSH
66309: EMPTY
66310: LIST
66311: LIST
66312: PUSH
66313: LD_INT 2
66315: NEG
66316: PUSH
66317: LD_INT 1
66319: NEG
66320: PUSH
66321: EMPTY
66322: LIST
66323: LIST
66324: PUSH
66325: LD_INT 2
66327: NEG
66328: PUSH
66329: LD_INT 1
66331: PUSH
66332: EMPTY
66333: LIST
66334: LIST
66335: PUSH
66336: LD_INT 3
66338: NEG
66339: PUSH
66340: LD_INT 0
66342: PUSH
66343: EMPTY
66344: LIST
66345: LIST
66346: PUSH
66347: LD_INT 3
66349: NEG
66350: PUSH
66351: LD_INT 1
66353: NEG
66354: PUSH
66355: EMPTY
66356: LIST
66357: LIST
66358: PUSH
66359: EMPTY
66360: LIST
66361: LIST
66362: LIST
66363: LIST
66364: LIST
66365: LIST
66366: LIST
66367: LIST
66368: LIST
66369: LIST
66370: LIST
66371: LIST
66372: LIST
66373: LIST
66374: LIST
66375: LIST
66376: ST_TO_ADDR
// DepotAm2 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ - 2 , - 3 ] , [ - 3 , - 2 ] , [ - 3 , - 3 ] ] ;
66377: LD_ADDR_VAR 0 13
66381: PUSH
66382: LD_INT 0
66384: PUSH
66385: LD_INT 0
66387: PUSH
66388: EMPTY
66389: LIST
66390: LIST
66391: PUSH
66392: LD_INT 0
66394: PUSH
66395: LD_INT 1
66397: NEG
66398: PUSH
66399: EMPTY
66400: LIST
66401: LIST
66402: PUSH
66403: LD_INT 1
66405: PUSH
66406: LD_INT 0
66408: PUSH
66409: EMPTY
66410: LIST
66411: LIST
66412: PUSH
66413: LD_INT 1
66415: PUSH
66416: LD_INT 1
66418: PUSH
66419: EMPTY
66420: LIST
66421: LIST
66422: PUSH
66423: LD_INT 0
66425: PUSH
66426: LD_INT 1
66428: PUSH
66429: EMPTY
66430: LIST
66431: LIST
66432: PUSH
66433: LD_INT 1
66435: NEG
66436: PUSH
66437: LD_INT 0
66439: PUSH
66440: EMPTY
66441: LIST
66442: LIST
66443: PUSH
66444: LD_INT 1
66446: NEG
66447: PUSH
66448: LD_INT 1
66450: NEG
66451: PUSH
66452: EMPTY
66453: LIST
66454: LIST
66455: PUSH
66456: LD_INT 1
66458: NEG
66459: PUSH
66460: LD_INT 2
66462: NEG
66463: PUSH
66464: EMPTY
66465: LIST
66466: LIST
66467: PUSH
66468: LD_INT 2
66470: PUSH
66471: LD_INT 1
66473: PUSH
66474: EMPTY
66475: LIST
66476: LIST
66477: PUSH
66478: LD_INT 2
66480: PUSH
66481: LD_INT 2
66483: PUSH
66484: EMPTY
66485: LIST
66486: LIST
66487: PUSH
66488: LD_INT 1
66490: PUSH
66491: LD_INT 2
66493: PUSH
66494: EMPTY
66495: LIST
66496: LIST
66497: PUSH
66498: LD_INT 2
66500: NEG
66501: PUSH
66502: LD_INT 1
66504: NEG
66505: PUSH
66506: EMPTY
66507: LIST
66508: LIST
66509: PUSH
66510: LD_INT 2
66512: NEG
66513: PUSH
66514: LD_INT 2
66516: NEG
66517: PUSH
66518: EMPTY
66519: LIST
66520: LIST
66521: PUSH
66522: LD_INT 2
66524: NEG
66525: PUSH
66526: LD_INT 3
66528: NEG
66529: PUSH
66530: EMPTY
66531: LIST
66532: LIST
66533: PUSH
66534: LD_INT 3
66536: NEG
66537: PUSH
66538: LD_INT 2
66540: NEG
66541: PUSH
66542: EMPTY
66543: LIST
66544: LIST
66545: PUSH
66546: LD_INT 3
66548: NEG
66549: PUSH
66550: LD_INT 3
66552: NEG
66553: PUSH
66554: EMPTY
66555: LIST
66556: LIST
66557: PUSH
66558: EMPTY
66559: LIST
66560: LIST
66561: LIST
66562: LIST
66563: LIST
66564: LIST
66565: LIST
66566: LIST
66567: LIST
66568: LIST
66569: LIST
66570: LIST
66571: LIST
66572: LIST
66573: LIST
66574: LIST
66575: ST_TO_ADDR
// DepotAm3 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 1 , - 3 ] , [ 0 , - 3 ] , [ 1 , - 2 ] ] ;
66576: LD_ADDR_VAR 0 14
66580: PUSH
66581: LD_INT 0
66583: PUSH
66584: LD_INT 0
66586: PUSH
66587: EMPTY
66588: LIST
66589: LIST
66590: PUSH
66591: LD_INT 0
66593: PUSH
66594: LD_INT 1
66596: NEG
66597: PUSH
66598: EMPTY
66599: LIST
66600: LIST
66601: PUSH
66602: LD_INT 1
66604: PUSH
66605: LD_INT 0
66607: PUSH
66608: EMPTY
66609: LIST
66610: LIST
66611: PUSH
66612: LD_INT 1
66614: PUSH
66615: LD_INT 1
66617: PUSH
66618: EMPTY
66619: LIST
66620: LIST
66621: PUSH
66622: LD_INT 0
66624: PUSH
66625: LD_INT 1
66627: PUSH
66628: EMPTY
66629: LIST
66630: LIST
66631: PUSH
66632: LD_INT 1
66634: NEG
66635: PUSH
66636: LD_INT 0
66638: PUSH
66639: EMPTY
66640: LIST
66641: LIST
66642: PUSH
66643: LD_INT 1
66645: NEG
66646: PUSH
66647: LD_INT 1
66649: NEG
66650: PUSH
66651: EMPTY
66652: LIST
66653: LIST
66654: PUSH
66655: LD_INT 1
66657: NEG
66658: PUSH
66659: LD_INT 2
66661: NEG
66662: PUSH
66663: EMPTY
66664: LIST
66665: LIST
66666: PUSH
66667: LD_INT 0
66669: PUSH
66670: LD_INT 2
66672: NEG
66673: PUSH
66674: EMPTY
66675: LIST
66676: LIST
66677: PUSH
66678: LD_INT 1
66680: PUSH
66681: LD_INT 1
66683: NEG
66684: PUSH
66685: EMPTY
66686: LIST
66687: LIST
66688: PUSH
66689: LD_INT 1
66691: PUSH
66692: LD_INT 2
66694: PUSH
66695: EMPTY
66696: LIST
66697: LIST
66698: PUSH
66699: LD_INT 0
66701: PUSH
66702: LD_INT 2
66704: PUSH
66705: EMPTY
66706: LIST
66707: LIST
66708: PUSH
66709: LD_INT 1
66711: NEG
66712: PUSH
66713: LD_INT 1
66715: PUSH
66716: EMPTY
66717: LIST
66718: LIST
66719: PUSH
66720: LD_INT 1
66722: NEG
66723: PUSH
66724: LD_INT 3
66726: NEG
66727: PUSH
66728: EMPTY
66729: LIST
66730: LIST
66731: PUSH
66732: LD_INT 0
66734: PUSH
66735: LD_INT 3
66737: NEG
66738: PUSH
66739: EMPTY
66740: LIST
66741: LIST
66742: PUSH
66743: LD_INT 1
66745: PUSH
66746: LD_INT 2
66748: NEG
66749: PUSH
66750: EMPTY
66751: LIST
66752: LIST
66753: PUSH
66754: EMPTY
66755: LIST
66756: LIST
66757: LIST
66758: LIST
66759: LIST
66760: LIST
66761: LIST
66762: LIST
66763: LIST
66764: LIST
66765: LIST
66766: LIST
66767: LIST
66768: LIST
66769: LIST
66770: LIST
66771: ST_TO_ADDR
// DepotAm4 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ 2 , - 1 ] , [ 3 , 0 ] , [ 3 , 1 ] ] ;
66772: LD_ADDR_VAR 0 15
66776: PUSH
66777: LD_INT 0
66779: PUSH
66780: LD_INT 0
66782: PUSH
66783: EMPTY
66784: LIST
66785: LIST
66786: PUSH
66787: LD_INT 0
66789: PUSH
66790: LD_INT 1
66792: NEG
66793: PUSH
66794: EMPTY
66795: LIST
66796: LIST
66797: PUSH
66798: LD_INT 1
66800: PUSH
66801: LD_INT 0
66803: PUSH
66804: EMPTY
66805: LIST
66806: LIST
66807: PUSH
66808: LD_INT 1
66810: PUSH
66811: LD_INT 1
66813: PUSH
66814: EMPTY
66815: LIST
66816: LIST
66817: PUSH
66818: LD_INT 0
66820: PUSH
66821: LD_INT 1
66823: PUSH
66824: EMPTY
66825: LIST
66826: LIST
66827: PUSH
66828: LD_INT 1
66830: NEG
66831: PUSH
66832: LD_INT 0
66834: PUSH
66835: EMPTY
66836: LIST
66837: LIST
66838: PUSH
66839: LD_INT 1
66841: NEG
66842: PUSH
66843: LD_INT 1
66845: NEG
66846: PUSH
66847: EMPTY
66848: LIST
66849: LIST
66850: PUSH
66851: LD_INT 1
66853: PUSH
66854: LD_INT 1
66856: NEG
66857: PUSH
66858: EMPTY
66859: LIST
66860: LIST
66861: PUSH
66862: LD_INT 2
66864: PUSH
66865: LD_INT 0
66867: PUSH
66868: EMPTY
66869: LIST
66870: LIST
66871: PUSH
66872: LD_INT 2
66874: PUSH
66875: LD_INT 1
66877: PUSH
66878: EMPTY
66879: LIST
66880: LIST
66881: PUSH
66882: LD_INT 1
66884: NEG
66885: PUSH
66886: LD_INT 1
66888: PUSH
66889: EMPTY
66890: LIST
66891: LIST
66892: PUSH
66893: LD_INT 2
66895: NEG
66896: PUSH
66897: LD_INT 0
66899: PUSH
66900: EMPTY
66901: LIST
66902: LIST
66903: PUSH
66904: LD_INT 2
66906: NEG
66907: PUSH
66908: LD_INT 1
66910: NEG
66911: PUSH
66912: EMPTY
66913: LIST
66914: LIST
66915: PUSH
66916: LD_INT 2
66918: PUSH
66919: LD_INT 1
66921: NEG
66922: PUSH
66923: EMPTY
66924: LIST
66925: LIST
66926: PUSH
66927: LD_INT 3
66929: PUSH
66930: LD_INT 0
66932: PUSH
66933: EMPTY
66934: LIST
66935: LIST
66936: PUSH
66937: LD_INT 3
66939: PUSH
66940: LD_INT 1
66942: PUSH
66943: EMPTY
66944: LIST
66945: LIST
66946: PUSH
66947: EMPTY
66948: LIST
66949: LIST
66950: LIST
66951: LIST
66952: LIST
66953: LIST
66954: LIST
66955: LIST
66956: LIST
66957: LIST
66958: LIST
66959: LIST
66960: LIST
66961: LIST
66962: LIST
66963: LIST
66964: ST_TO_ADDR
// DepotAm5 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ 3 , 2 ] , [ 3 , 3 ] , [ 2 , 3 ] ] ;
66965: LD_ADDR_VAR 0 16
66969: PUSH
66970: LD_INT 0
66972: PUSH
66973: LD_INT 0
66975: PUSH
66976: EMPTY
66977: LIST
66978: LIST
66979: PUSH
66980: LD_INT 0
66982: PUSH
66983: LD_INT 1
66985: NEG
66986: PUSH
66987: EMPTY
66988: LIST
66989: LIST
66990: PUSH
66991: LD_INT 1
66993: PUSH
66994: LD_INT 0
66996: PUSH
66997: EMPTY
66998: LIST
66999: LIST
67000: PUSH
67001: LD_INT 1
67003: PUSH
67004: LD_INT 1
67006: PUSH
67007: EMPTY
67008: LIST
67009: LIST
67010: PUSH
67011: LD_INT 0
67013: PUSH
67014: LD_INT 1
67016: PUSH
67017: EMPTY
67018: LIST
67019: LIST
67020: PUSH
67021: LD_INT 1
67023: NEG
67024: PUSH
67025: LD_INT 0
67027: PUSH
67028: EMPTY
67029: LIST
67030: LIST
67031: PUSH
67032: LD_INT 1
67034: NEG
67035: PUSH
67036: LD_INT 1
67038: NEG
67039: PUSH
67040: EMPTY
67041: LIST
67042: LIST
67043: PUSH
67044: LD_INT 1
67046: NEG
67047: PUSH
67048: LD_INT 2
67050: NEG
67051: PUSH
67052: EMPTY
67053: LIST
67054: LIST
67055: PUSH
67056: LD_INT 2
67058: PUSH
67059: LD_INT 1
67061: PUSH
67062: EMPTY
67063: LIST
67064: LIST
67065: PUSH
67066: LD_INT 2
67068: PUSH
67069: LD_INT 2
67071: PUSH
67072: EMPTY
67073: LIST
67074: LIST
67075: PUSH
67076: LD_INT 1
67078: PUSH
67079: LD_INT 2
67081: PUSH
67082: EMPTY
67083: LIST
67084: LIST
67085: PUSH
67086: LD_INT 2
67088: NEG
67089: PUSH
67090: LD_INT 1
67092: NEG
67093: PUSH
67094: EMPTY
67095: LIST
67096: LIST
67097: PUSH
67098: LD_INT 2
67100: NEG
67101: PUSH
67102: LD_INT 2
67104: NEG
67105: PUSH
67106: EMPTY
67107: LIST
67108: LIST
67109: PUSH
67110: LD_INT 3
67112: PUSH
67113: LD_INT 2
67115: PUSH
67116: EMPTY
67117: LIST
67118: LIST
67119: PUSH
67120: LD_INT 3
67122: PUSH
67123: LD_INT 3
67125: PUSH
67126: EMPTY
67127: LIST
67128: LIST
67129: PUSH
67130: LD_INT 2
67132: PUSH
67133: LD_INT 3
67135: PUSH
67136: EMPTY
67137: LIST
67138: LIST
67139: PUSH
67140: EMPTY
67141: LIST
67142: LIST
67143: LIST
67144: LIST
67145: LIST
67146: LIST
67147: LIST
67148: LIST
67149: LIST
67150: LIST
67151: LIST
67152: LIST
67153: LIST
67154: LIST
67155: LIST
67156: LIST
67157: ST_TO_ADDR
// DepotAr0 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
67158: LD_ADDR_VAR 0 17
67162: PUSH
67163: LD_INT 0
67165: PUSH
67166: LD_INT 0
67168: PUSH
67169: EMPTY
67170: LIST
67171: LIST
67172: PUSH
67173: LD_INT 0
67175: PUSH
67176: LD_INT 1
67178: NEG
67179: PUSH
67180: EMPTY
67181: LIST
67182: LIST
67183: PUSH
67184: LD_INT 1
67186: PUSH
67187: LD_INT 0
67189: PUSH
67190: EMPTY
67191: LIST
67192: LIST
67193: PUSH
67194: LD_INT 1
67196: PUSH
67197: LD_INT 1
67199: PUSH
67200: EMPTY
67201: LIST
67202: LIST
67203: PUSH
67204: LD_INT 0
67206: PUSH
67207: LD_INT 1
67209: PUSH
67210: EMPTY
67211: LIST
67212: LIST
67213: PUSH
67214: LD_INT 1
67216: NEG
67217: PUSH
67218: LD_INT 0
67220: PUSH
67221: EMPTY
67222: LIST
67223: LIST
67224: PUSH
67225: LD_INT 1
67227: NEG
67228: PUSH
67229: LD_INT 1
67231: NEG
67232: PUSH
67233: EMPTY
67234: LIST
67235: LIST
67236: PUSH
67237: LD_INT 1
67239: NEG
67240: PUSH
67241: LD_INT 2
67243: NEG
67244: PUSH
67245: EMPTY
67246: LIST
67247: LIST
67248: PUSH
67249: LD_INT 0
67251: PUSH
67252: LD_INT 2
67254: NEG
67255: PUSH
67256: EMPTY
67257: LIST
67258: LIST
67259: PUSH
67260: LD_INT 1
67262: PUSH
67263: LD_INT 1
67265: NEG
67266: PUSH
67267: EMPTY
67268: LIST
67269: LIST
67270: PUSH
67271: LD_INT 2
67273: PUSH
67274: LD_INT 0
67276: PUSH
67277: EMPTY
67278: LIST
67279: LIST
67280: PUSH
67281: LD_INT 2
67283: PUSH
67284: LD_INT 1
67286: PUSH
67287: EMPTY
67288: LIST
67289: LIST
67290: PUSH
67291: LD_INT 2
67293: PUSH
67294: LD_INT 2
67296: PUSH
67297: EMPTY
67298: LIST
67299: LIST
67300: PUSH
67301: LD_INT 1
67303: PUSH
67304: LD_INT 2
67306: PUSH
67307: EMPTY
67308: LIST
67309: LIST
67310: PUSH
67311: LD_INT 0
67313: PUSH
67314: LD_INT 2
67316: PUSH
67317: EMPTY
67318: LIST
67319: LIST
67320: PUSH
67321: LD_INT 1
67323: NEG
67324: PUSH
67325: LD_INT 1
67327: PUSH
67328: EMPTY
67329: LIST
67330: LIST
67331: PUSH
67332: LD_INT 2
67334: NEG
67335: PUSH
67336: LD_INT 0
67338: PUSH
67339: EMPTY
67340: LIST
67341: LIST
67342: PUSH
67343: LD_INT 2
67345: NEG
67346: PUSH
67347: LD_INT 1
67349: NEG
67350: PUSH
67351: EMPTY
67352: LIST
67353: LIST
67354: PUSH
67355: LD_INT 2
67357: NEG
67358: PUSH
67359: LD_INT 2
67361: NEG
67362: PUSH
67363: EMPTY
67364: LIST
67365: LIST
67366: PUSH
67367: EMPTY
67368: LIST
67369: LIST
67370: LIST
67371: LIST
67372: LIST
67373: LIST
67374: LIST
67375: LIST
67376: LIST
67377: LIST
67378: LIST
67379: LIST
67380: LIST
67381: LIST
67382: LIST
67383: LIST
67384: LIST
67385: LIST
67386: LIST
67387: ST_TO_ADDR
// DepotAr1 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
67388: LD_ADDR_VAR 0 18
67392: PUSH
67393: LD_INT 0
67395: PUSH
67396: LD_INT 0
67398: PUSH
67399: EMPTY
67400: LIST
67401: LIST
67402: PUSH
67403: LD_INT 0
67405: PUSH
67406: LD_INT 1
67408: NEG
67409: PUSH
67410: EMPTY
67411: LIST
67412: LIST
67413: PUSH
67414: LD_INT 1
67416: PUSH
67417: LD_INT 0
67419: PUSH
67420: EMPTY
67421: LIST
67422: LIST
67423: PUSH
67424: LD_INT 1
67426: PUSH
67427: LD_INT 1
67429: PUSH
67430: EMPTY
67431: LIST
67432: LIST
67433: PUSH
67434: LD_INT 0
67436: PUSH
67437: LD_INT 1
67439: PUSH
67440: EMPTY
67441: LIST
67442: LIST
67443: PUSH
67444: LD_INT 1
67446: NEG
67447: PUSH
67448: LD_INT 0
67450: PUSH
67451: EMPTY
67452: LIST
67453: LIST
67454: PUSH
67455: LD_INT 1
67457: NEG
67458: PUSH
67459: LD_INT 1
67461: NEG
67462: PUSH
67463: EMPTY
67464: LIST
67465: LIST
67466: PUSH
67467: LD_INT 1
67469: NEG
67470: PUSH
67471: LD_INT 2
67473: NEG
67474: PUSH
67475: EMPTY
67476: LIST
67477: LIST
67478: PUSH
67479: LD_INT 0
67481: PUSH
67482: LD_INT 2
67484: NEG
67485: PUSH
67486: EMPTY
67487: LIST
67488: LIST
67489: PUSH
67490: LD_INT 1
67492: PUSH
67493: LD_INT 1
67495: NEG
67496: PUSH
67497: EMPTY
67498: LIST
67499: LIST
67500: PUSH
67501: LD_INT 2
67503: PUSH
67504: LD_INT 0
67506: PUSH
67507: EMPTY
67508: LIST
67509: LIST
67510: PUSH
67511: LD_INT 2
67513: PUSH
67514: LD_INT 1
67516: PUSH
67517: EMPTY
67518: LIST
67519: LIST
67520: PUSH
67521: LD_INT 2
67523: PUSH
67524: LD_INT 2
67526: PUSH
67527: EMPTY
67528: LIST
67529: LIST
67530: PUSH
67531: LD_INT 1
67533: PUSH
67534: LD_INT 2
67536: PUSH
67537: EMPTY
67538: LIST
67539: LIST
67540: PUSH
67541: LD_INT 0
67543: PUSH
67544: LD_INT 2
67546: PUSH
67547: EMPTY
67548: LIST
67549: LIST
67550: PUSH
67551: LD_INT 1
67553: NEG
67554: PUSH
67555: LD_INT 1
67557: PUSH
67558: EMPTY
67559: LIST
67560: LIST
67561: PUSH
67562: LD_INT 2
67564: NEG
67565: PUSH
67566: LD_INT 0
67568: PUSH
67569: EMPTY
67570: LIST
67571: LIST
67572: PUSH
67573: LD_INT 2
67575: NEG
67576: PUSH
67577: LD_INT 1
67579: NEG
67580: PUSH
67581: EMPTY
67582: LIST
67583: LIST
67584: PUSH
67585: LD_INT 2
67587: NEG
67588: PUSH
67589: LD_INT 2
67591: NEG
67592: PUSH
67593: EMPTY
67594: LIST
67595: LIST
67596: PUSH
67597: EMPTY
67598: LIST
67599: LIST
67600: LIST
67601: LIST
67602: LIST
67603: LIST
67604: LIST
67605: LIST
67606: LIST
67607: LIST
67608: LIST
67609: LIST
67610: LIST
67611: LIST
67612: LIST
67613: LIST
67614: LIST
67615: LIST
67616: LIST
67617: ST_TO_ADDR
// DepotAr2 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
67618: LD_ADDR_VAR 0 19
67622: PUSH
67623: LD_INT 0
67625: PUSH
67626: LD_INT 0
67628: PUSH
67629: EMPTY
67630: LIST
67631: LIST
67632: PUSH
67633: LD_INT 0
67635: PUSH
67636: LD_INT 1
67638: NEG
67639: PUSH
67640: EMPTY
67641: LIST
67642: LIST
67643: PUSH
67644: LD_INT 1
67646: PUSH
67647: LD_INT 0
67649: PUSH
67650: EMPTY
67651: LIST
67652: LIST
67653: PUSH
67654: LD_INT 1
67656: PUSH
67657: LD_INT 1
67659: PUSH
67660: EMPTY
67661: LIST
67662: LIST
67663: PUSH
67664: LD_INT 0
67666: PUSH
67667: LD_INT 1
67669: PUSH
67670: EMPTY
67671: LIST
67672: LIST
67673: PUSH
67674: LD_INT 1
67676: NEG
67677: PUSH
67678: LD_INT 0
67680: PUSH
67681: EMPTY
67682: LIST
67683: LIST
67684: PUSH
67685: LD_INT 1
67687: NEG
67688: PUSH
67689: LD_INT 1
67691: NEG
67692: PUSH
67693: EMPTY
67694: LIST
67695: LIST
67696: PUSH
67697: LD_INT 1
67699: NEG
67700: PUSH
67701: LD_INT 2
67703: NEG
67704: PUSH
67705: EMPTY
67706: LIST
67707: LIST
67708: PUSH
67709: LD_INT 0
67711: PUSH
67712: LD_INT 2
67714: NEG
67715: PUSH
67716: EMPTY
67717: LIST
67718: LIST
67719: PUSH
67720: LD_INT 1
67722: PUSH
67723: LD_INT 1
67725: NEG
67726: PUSH
67727: EMPTY
67728: LIST
67729: LIST
67730: PUSH
67731: LD_INT 2
67733: PUSH
67734: LD_INT 0
67736: PUSH
67737: EMPTY
67738: LIST
67739: LIST
67740: PUSH
67741: LD_INT 2
67743: PUSH
67744: LD_INT 1
67746: PUSH
67747: EMPTY
67748: LIST
67749: LIST
67750: PUSH
67751: LD_INT 2
67753: PUSH
67754: LD_INT 2
67756: PUSH
67757: EMPTY
67758: LIST
67759: LIST
67760: PUSH
67761: LD_INT 1
67763: PUSH
67764: LD_INT 2
67766: PUSH
67767: EMPTY
67768: LIST
67769: LIST
67770: PUSH
67771: LD_INT 0
67773: PUSH
67774: LD_INT 2
67776: PUSH
67777: EMPTY
67778: LIST
67779: LIST
67780: PUSH
67781: LD_INT 1
67783: NEG
67784: PUSH
67785: LD_INT 1
67787: PUSH
67788: EMPTY
67789: LIST
67790: LIST
67791: PUSH
67792: LD_INT 2
67794: NEG
67795: PUSH
67796: LD_INT 0
67798: PUSH
67799: EMPTY
67800: LIST
67801: LIST
67802: PUSH
67803: LD_INT 2
67805: NEG
67806: PUSH
67807: LD_INT 1
67809: NEG
67810: PUSH
67811: EMPTY
67812: LIST
67813: LIST
67814: PUSH
67815: LD_INT 2
67817: NEG
67818: PUSH
67819: LD_INT 2
67821: NEG
67822: PUSH
67823: EMPTY
67824: LIST
67825: LIST
67826: PUSH
67827: EMPTY
67828: LIST
67829: LIST
67830: LIST
67831: LIST
67832: LIST
67833: LIST
67834: LIST
67835: LIST
67836: LIST
67837: LIST
67838: LIST
67839: LIST
67840: LIST
67841: LIST
67842: LIST
67843: LIST
67844: LIST
67845: LIST
67846: LIST
67847: ST_TO_ADDR
// DepotAr3 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
67848: LD_ADDR_VAR 0 20
67852: PUSH
67853: LD_INT 0
67855: PUSH
67856: LD_INT 0
67858: PUSH
67859: EMPTY
67860: LIST
67861: LIST
67862: PUSH
67863: LD_INT 0
67865: PUSH
67866: LD_INT 1
67868: NEG
67869: PUSH
67870: EMPTY
67871: LIST
67872: LIST
67873: PUSH
67874: LD_INT 1
67876: PUSH
67877: LD_INT 0
67879: PUSH
67880: EMPTY
67881: LIST
67882: LIST
67883: PUSH
67884: LD_INT 1
67886: PUSH
67887: LD_INT 1
67889: PUSH
67890: EMPTY
67891: LIST
67892: LIST
67893: PUSH
67894: LD_INT 0
67896: PUSH
67897: LD_INT 1
67899: PUSH
67900: EMPTY
67901: LIST
67902: LIST
67903: PUSH
67904: LD_INT 1
67906: NEG
67907: PUSH
67908: LD_INT 0
67910: PUSH
67911: EMPTY
67912: LIST
67913: LIST
67914: PUSH
67915: LD_INT 1
67917: NEG
67918: PUSH
67919: LD_INT 1
67921: NEG
67922: PUSH
67923: EMPTY
67924: LIST
67925: LIST
67926: PUSH
67927: LD_INT 1
67929: NEG
67930: PUSH
67931: LD_INT 2
67933: NEG
67934: PUSH
67935: EMPTY
67936: LIST
67937: LIST
67938: PUSH
67939: LD_INT 0
67941: PUSH
67942: LD_INT 2
67944: NEG
67945: PUSH
67946: EMPTY
67947: LIST
67948: LIST
67949: PUSH
67950: LD_INT 1
67952: PUSH
67953: LD_INT 1
67955: NEG
67956: PUSH
67957: EMPTY
67958: LIST
67959: LIST
67960: PUSH
67961: LD_INT 2
67963: PUSH
67964: LD_INT 0
67966: PUSH
67967: EMPTY
67968: LIST
67969: LIST
67970: PUSH
67971: LD_INT 2
67973: PUSH
67974: LD_INT 1
67976: PUSH
67977: EMPTY
67978: LIST
67979: LIST
67980: PUSH
67981: LD_INT 2
67983: PUSH
67984: LD_INT 2
67986: PUSH
67987: EMPTY
67988: LIST
67989: LIST
67990: PUSH
67991: LD_INT 1
67993: PUSH
67994: LD_INT 2
67996: PUSH
67997: EMPTY
67998: LIST
67999: LIST
68000: PUSH
68001: LD_INT 0
68003: PUSH
68004: LD_INT 2
68006: PUSH
68007: EMPTY
68008: LIST
68009: LIST
68010: PUSH
68011: LD_INT 1
68013: NEG
68014: PUSH
68015: LD_INT 1
68017: PUSH
68018: EMPTY
68019: LIST
68020: LIST
68021: PUSH
68022: LD_INT 2
68024: NEG
68025: PUSH
68026: LD_INT 0
68028: PUSH
68029: EMPTY
68030: LIST
68031: LIST
68032: PUSH
68033: LD_INT 2
68035: NEG
68036: PUSH
68037: LD_INT 1
68039: NEG
68040: PUSH
68041: EMPTY
68042: LIST
68043: LIST
68044: PUSH
68045: LD_INT 2
68047: NEG
68048: PUSH
68049: LD_INT 2
68051: NEG
68052: PUSH
68053: EMPTY
68054: LIST
68055: LIST
68056: PUSH
68057: EMPTY
68058: LIST
68059: LIST
68060: LIST
68061: LIST
68062: LIST
68063: LIST
68064: LIST
68065: LIST
68066: LIST
68067: LIST
68068: LIST
68069: LIST
68070: LIST
68071: LIST
68072: LIST
68073: LIST
68074: LIST
68075: LIST
68076: LIST
68077: ST_TO_ADDR
// DepotAr4 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
68078: LD_ADDR_VAR 0 21
68082: PUSH
68083: LD_INT 0
68085: PUSH
68086: LD_INT 0
68088: PUSH
68089: EMPTY
68090: LIST
68091: LIST
68092: PUSH
68093: LD_INT 0
68095: PUSH
68096: LD_INT 1
68098: NEG
68099: PUSH
68100: EMPTY
68101: LIST
68102: LIST
68103: PUSH
68104: LD_INT 1
68106: PUSH
68107: LD_INT 0
68109: PUSH
68110: EMPTY
68111: LIST
68112: LIST
68113: PUSH
68114: LD_INT 1
68116: PUSH
68117: LD_INT 1
68119: PUSH
68120: EMPTY
68121: LIST
68122: LIST
68123: PUSH
68124: LD_INT 0
68126: PUSH
68127: LD_INT 1
68129: PUSH
68130: EMPTY
68131: LIST
68132: LIST
68133: PUSH
68134: LD_INT 1
68136: NEG
68137: PUSH
68138: LD_INT 0
68140: PUSH
68141: EMPTY
68142: LIST
68143: LIST
68144: PUSH
68145: LD_INT 1
68147: NEG
68148: PUSH
68149: LD_INT 1
68151: NEG
68152: PUSH
68153: EMPTY
68154: LIST
68155: LIST
68156: PUSH
68157: LD_INT 1
68159: NEG
68160: PUSH
68161: LD_INT 2
68163: NEG
68164: PUSH
68165: EMPTY
68166: LIST
68167: LIST
68168: PUSH
68169: LD_INT 0
68171: PUSH
68172: LD_INT 2
68174: NEG
68175: PUSH
68176: EMPTY
68177: LIST
68178: LIST
68179: PUSH
68180: LD_INT 1
68182: PUSH
68183: LD_INT 1
68185: NEG
68186: PUSH
68187: EMPTY
68188: LIST
68189: LIST
68190: PUSH
68191: LD_INT 2
68193: PUSH
68194: LD_INT 0
68196: PUSH
68197: EMPTY
68198: LIST
68199: LIST
68200: PUSH
68201: LD_INT 2
68203: PUSH
68204: LD_INT 1
68206: PUSH
68207: EMPTY
68208: LIST
68209: LIST
68210: PUSH
68211: LD_INT 2
68213: PUSH
68214: LD_INT 2
68216: PUSH
68217: EMPTY
68218: LIST
68219: LIST
68220: PUSH
68221: LD_INT 1
68223: PUSH
68224: LD_INT 2
68226: PUSH
68227: EMPTY
68228: LIST
68229: LIST
68230: PUSH
68231: LD_INT 0
68233: PUSH
68234: LD_INT 2
68236: PUSH
68237: EMPTY
68238: LIST
68239: LIST
68240: PUSH
68241: LD_INT 1
68243: NEG
68244: PUSH
68245: LD_INT 1
68247: PUSH
68248: EMPTY
68249: LIST
68250: LIST
68251: PUSH
68252: LD_INT 2
68254: NEG
68255: PUSH
68256: LD_INT 0
68258: PUSH
68259: EMPTY
68260: LIST
68261: LIST
68262: PUSH
68263: LD_INT 2
68265: NEG
68266: PUSH
68267: LD_INT 1
68269: NEG
68270: PUSH
68271: EMPTY
68272: LIST
68273: LIST
68274: PUSH
68275: LD_INT 2
68277: NEG
68278: PUSH
68279: LD_INT 2
68281: NEG
68282: PUSH
68283: EMPTY
68284: LIST
68285: LIST
68286: PUSH
68287: EMPTY
68288: LIST
68289: LIST
68290: LIST
68291: LIST
68292: LIST
68293: LIST
68294: LIST
68295: LIST
68296: LIST
68297: LIST
68298: LIST
68299: LIST
68300: LIST
68301: LIST
68302: LIST
68303: LIST
68304: LIST
68305: LIST
68306: LIST
68307: ST_TO_ADDR
// DepotAr5 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
68308: LD_ADDR_VAR 0 22
68312: PUSH
68313: LD_INT 0
68315: PUSH
68316: LD_INT 0
68318: PUSH
68319: EMPTY
68320: LIST
68321: LIST
68322: PUSH
68323: LD_INT 0
68325: PUSH
68326: LD_INT 1
68328: NEG
68329: PUSH
68330: EMPTY
68331: LIST
68332: LIST
68333: PUSH
68334: LD_INT 1
68336: PUSH
68337: LD_INT 0
68339: PUSH
68340: EMPTY
68341: LIST
68342: LIST
68343: PUSH
68344: LD_INT 1
68346: PUSH
68347: LD_INT 1
68349: PUSH
68350: EMPTY
68351: LIST
68352: LIST
68353: PUSH
68354: LD_INT 0
68356: PUSH
68357: LD_INT 1
68359: PUSH
68360: EMPTY
68361: LIST
68362: LIST
68363: PUSH
68364: LD_INT 1
68366: NEG
68367: PUSH
68368: LD_INT 0
68370: PUSH
68371: EMPTY
68372: LIST
68373: LIST
68374: PUSH
68375: LD_INT 1
68377: NEG
68378: PUSH
68379: LD_INT 1
68381: NEG
68382: PUSH
68383: EMPTY
68384: LIST
68385: LIST
68386: PUSH
68387: LD_INT 1
68389: NEG
68390: PUSH
68391: LD_INT 2
68393: NEG
68394: PUSH
68395: EMPTY
68396: LIST
68397: LIST
68398: PUSH
68399: LD_INT 0
68401: PUSH
68402: LD_INT 2
68404: NEG
68405: PUSH
68406: EMPTY
68407: LIST
68408: LIST
68409: PUSH
68410: LD_INT 1
68412: PUSH
68413: LD_INT 1
68415: NEG
68416: PUSH
68417: EMPTY
68418: LIST
68419: LIST
68420: PUSH
68421: LD_INT 2
68423: PUSH
68424: LD_INT 0
68426: PUSH
68427: EMPTY
68428: LIST
68429: LIST
68430: PUSH
68431: LD_INT 2
68433: PUSH
68434: LD_INT 1
68436: PUSH
68437: EMPTY
68438: LIST
68439: LIST
68440: PUSH
68441: LD_INT 2
68443: PUSH
68444: LD_INT 2
68446: PUSH
68447: EMPTY
68448: LIST
68449: LIST
68450: PUSH
68451: LD_INT 1
68453: PUSH
68454: LD_INT 2
68456: PUSH
68457: EMPTY
68458: LIST
68459: LIST
68460: PUSH
68461: LD_INT 0
68463: PUSH
68464: LD_INT 2
68466: PUSH
68467: EMPTY
68468: LIST
68469: LIST
68470: PUSH
68471: LD_INT 1
68473: NEG
68474: PUSH
68475: LD_INT 1
68477: PUSH
68478: EMPTY
68479: LIST
68480: LIST
68481: PUSH
68482: LD_INT 2
68484: NEG
68485: PUSH
68486: LD_INT 0
68488: PUSH
68489: EMPTY
68490: LIST
68491: LIST
68492: PUSH
68493: LD_INT 2
68495: NEG
68496: PUSH
68497: LD_INT 1
68499: NEG
68500: PUSH
68501: EMPTY
68502: LIST
68503: LIST
68504: PUSH
68505: LD_INT 2
68507: NEG
68508: PUSH
68509: LD_INT 2
68511: NEG
68512: PUSH
68513: EMPTY
68514: LIST
68515: LIST
68516: PUSH
68517: EMPTY
68518: LIST
68519: LIST
68520: LIST
68521: LIST
68522: LIST
68523: LIST
68524: LIST
68525: LIST
68526: LIST
68527: LIST
68528: LIST
68529: LIST
68530: LIST
68531: LIST
68532: LIST
68533: LIST
68534: LIST
68535: LIST
68536: LIST
68537: ST_TO_ADDR
// DepotRu0 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ - 2 , - 3 ] , [ - 1 , - 3 ] , [ 1 , - 2 ] , [ 2 , - 1 ] ] ;
68538: LD_ADDR_VAR 0 23
68542: PUSH
68543: LD_INT 0
68545: PUSH
68546: LD_INT 0
68548: PUSH
68549: EMPTY
68550: LIST
68551: LIST
68552: PUSH
68553: LD_INT 0
68555: PUSH
68556: LD_INT 1
68558: NEG
68559: PUSH
68560: EMPTY
68561: LIST
68562: LIST
68563: PUSH
68564: LD_INT 1
68566: PUSH
68567: LD_INT 0
68569: PUSH
68570: EMPTY
68571: LIST
68572: LIST
68573: PUSH
68574: LD_INT 1
68576: PUSH
68577: LD_INT 1
68579: PUSH
68580: EMPTY
68581: LIST
68582: LIST
68583: PUSH
68584: LD_INT 0
68586: PUSH
68587: LD_INT 1
68589: PUSH
68590: EMPTY
68591: LIST
68592: LIST
68593: PUSH
68594: LD_INT 1
68596: NEG
68597: PUSH
68598: LD_INT 0
68600: PUSH
68601: EMPTY
68602: LIST
68603: LIST
68604: PUSH
68605: LD_INT 1
68607: NEG
68608: PUSH
68609: LD_INT 1
68611: NEG
68612: PUSH
68613: EMPTY
68614: LIST
68615: LIST
68616: PUSH
68617: LD_INT 1
68619: NEG
68620: PUSH
68621: LD_INT 2
68623: NEG
68624: PUSH
68625: EMPTY
68626: LIST
68627: LIST
68628: PUSH
68629: LD_INT 0
68631: PUSH
68632: LD_INT 2
68634: NEG
68635: PUSH
68636: EMPTY
68637: LIST
68638: LIST
68639: PUSH
68640: LD_INT 1
68642: PUSH
68643: LD_INT 1
68645: NEG
68646: PUSH
68647: EMPTY
68648: LIST
68649: LIST
68650: PUSH
68651: LD_INT 2
68653: PUSH
68654: LD_INT 0
68656: PUSH
68657: EMPTY
68658: LIST
68659: LIST
68660: PUSH
68661: LD_INT 2
68663: PUSH
68664: LD_INT 1
68666: PUSH
68667: EMPTY
68668: LIST
68669: LIST
68670: PUSH
68671: LD_INT 2
68673: PUSH
68674: LD_INT 2
68676: PUSH
68677: EMPTY
68678: LIST
68679: LIST
68680: PUSH
68681: LD_INT 1
68683: PUSH
68684: LD_INT 2
68686: PUSH
68687: EMPTY
68688: LIST
68689: LIST
68690: PUSH
68691: LD_INT 0
68693: PUSH
68694: LD_INT 2
68696: PUSH
68697: EMPTY
68698: LIST
68699: LIST
68700: PUSH
68701: LD_INT 1
68703: NEG
68704: PUSH
68705: LD_INT 1
68707: PUSH
68708: EMPTY
68709: LIST
68710: LIST
68711: PUSH
68712: LD_INT 2
68714: NEG
68715: PUSH
68716: LD_INT 0
68718: PUSH
68719: EMPTY
68720: LIST
68721: LIST
68722: PUSH
68723: LD_INT 2
68725: NEG
68726: PUSH
68727: LD_INT 1
68729: NEG
68730: PUSH
68731: EMPTY
68732: LIST
68733: LIST
68734: PUSH
68735: LD_INT 2
68737: NEG
68738: PUSH
68739: LD_INT 2
68741: NEG
68742: PUSH
68743: EMPTY
68744: LIST
68745: LIST
68746: PUSH
68747: LD_INT 2
68749: NEG
68750: PUSH
68751: LD_INT 3
68753: NEG
68754: PUSH
68755: EMPTY
68756: LIST
68757: LIST
68758: PUSH
68759: LD_INT 1
68761: NEG
68762: PUSH
68763: LD_INT 3
68765: NEG
68766: PUSH
68767: EMPTY
68768: LIST
68769: LIST
68770: PUSH
68771: LD_INT 1
68773: PUSH
68774: LD_INT 2
68776: NEG
68777: PUSH
68778: EMPTY
68779: LIST
68780: LIST
68781: PUSH
68782: LD_INT 2
68784: PUSH
68785: LD_INT 1
68787: NEG
68788: PUSH
68789: EMPTY
68790: LIST
68791: LIST
68792: PUSH
68793: EMPTY
68794: LIST
68795: LIST
68796: LIST
68797: LIST
68798: LIST
68799: LIST
68800: LIST
68801: LIST
68802: LIST
68803: LIST
68804: LIST
68805: LIST
68806: LIST
68807: LIST
68808: LIST
68809: LIST
68810: LIST
68811: LIST
68812: LIST
68813: LIST
68814: LIST
68815: LIST
68816: LIST
68817: ST_TO_ADDR
// DepotRu1 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ 1 , - 2 ] , [ 2 , - 1 ] , [ 3 , 1 ] , [ 3 , 2 ] ] ;
68818: LD_ADDR_VAR 0 24
68822: PUSH
68823: LD_INT 0
68825: PUSH
68826: LD_INT 0
68828: PUSH
68829: EMPTY
68830: LIST
68831: LIST
68832: PUSH
68833: LD_INT 0
68835: PUSH
68836: LD_INT 1
68838: NEG
68839: PUSH
68840: EMPTY
68841: LIST
68842: LIST
68843: PUSH
68844: LD_INT 1
68846: PUSH
68847: LD_INT 0
68849: PUSH
68850: EMPTY
68851: LIST
68852: LIST
68853: PUSH
68854: LD_INT 1
68856: PUSH
68857: LD_INT 1
68859: PUSH
68860: EMPTY
68861: LIST
68862: LIST
68863: PUSH
68864: LD_INT 0
68866: PUSH
68867: LD_INT 1
68869: PUSH
68870: EMPTY
68871: LIST
68872: LIST
68873: PUSH
68874: LD_INT 1
68876: NEG
68877: PUSH
68878: LD_INT 0
68880: PUSH
68881: EMPTY
68882: LIST
68883: LIST
68884: PUSH
68885: LD_INT 1
68887: NEG
68888: PUSH
68889: LD_INT 1
68891: NEG
68892: PUSH
68893: EMPTY
68894: LIST
68895: LIST
68896: PUSH
68897: LD_INT 1
68899: NEG
68900: PUSH
68901: LD_INT 2
68903: NEG
68904: PUSH
68905: EMPTY
68906: LIST
68907: LIST
68908: PUSH
68909: LD_INT 0
68911: PUSH
68912: LD_INT 2
68914: NEG
68915: PUSH
68916: EMPTY
68917: LIST
68918: LIST
68919: PUSH
68920: LD_INT 1
68922: PUSH
68923: LD_INT 1
68925: NEG
68926: PUSH
68927: EMPTY
68928: LIST
68929: LIST
68930: PUSH
68931: LD_INT 2
68933: PUSH
68934: LD_INT 0
68936: PUSH
68937: EMPTY
68938: LIST
68939: LIST
68940: PUSH
68941: LD_INT 2
68943: PUSH
68944: LD_INT 1
68946: PUSH
68947: EMPTY
68948: LIST
68949: LIST
68950: PUSH
68951: LD_INT 2
68953: PUSH
68954: LD_INT 2
68956: PUSH
68957: EMPTY
68958: LIST
68959: LIST
68960: PUSH
68961: LD_INT 1
68963: PUSH
68964: LD_INT 2
68966: PUSH
68967: EMPTY
68968: LIST
68969: LIST
68970: PUSH
68971: LD_INT 0
68973: PUSH
68974: LD_INT 2
68976: PUSH
68977: EMPTY
68978: LIST
68979: LIST
68980: PUSH
68981: LD_INT 1
68983: NEG
68984: PUSH
68985: LD_INT 1
68987: PUSH
68988: EMPTY
68989: LIST
68990: LIST
68991: PUSH
68992: LD_INT 2
68994: NEG
68995: PUSH
68996: LD_INT 0
68998: PUSH
68999: EMPTY
69000: LIST
69001: LIST
69002: PUSH
69003: LD_INT 2
69005: NEG
69006: PUSH
69007: LD_INT 1
69009: NEG
69010: PUSH
69011: EMPTY
69012: LIST
69013: LIST
69014: PUSH
69015: LD_INT 2
69017: NEG
69018: PUSH
69019: LD_INT 2
69021: NEG
69022: PUSH
69023: EMPTY
69024: LIST
69025: LIST
69026: PUSH
69027: LD_INT 1
69029: PUSH
69030: LD_INT 2
69032: NEG
69033: PUSH
69034: EMPTY
69035: LIST
69036: LIST
69037: PUSH
69038: LD_INT 2
69040: PUSH
69041: LD_INT 1
69043: NEG
69044: PUSH
69045: EMPTY
69046: LIST
69047: LIST
69048: PUSH
69049: LD_INT 3
69051: PUSH
69052: LD_INT 1
69054: PUSH
69055: EMPTY
69056: LIST
69057: LIST
69058: PUSH
69059: LD_INT 3
69061: PUSH
69062: LD_INT 2
69064: PUSH
69065: EMPTY
69066: LIST
69067: LIST
69068: PUSH
69069: EMPTY
69070: LIST
69071: LIST
69072: LIST
69073: LIST
69074: LIST
69075: LIST
69076: LIST
69077: LIST
69078: LIST
69079: LIST
69080: LIST
69081: LIST
69082: LIST
69083: LIST
69084: LIST
69085: LIST
69086: LIST
69087: LIST
69088: LIST
69089: LIST
69090: LIST
69091: LIST
69092: LIST
69093: ST_TO_ADDR
// DepotRu2 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ 3 , 1 ] , [ 3 , 2 ] , [ 2 , 3 ] , [ 1 , 3 ] ] ;
69094: LD_ADDR_VAR 0 25
69098: PUSH
69099: LD_INT 0
69101: PUSH
69102: LD_INT 0
69104: PUSH
69105: EMPTY
69106: LIST
69107: LIST
69108: PUSH
69109: LD_INT 0
69111: PUSH
69112: LD_INT 1
69114: NEG
69115: PUSH
69116: EMPTY
69117: LIST
69118: LIST
69119: PUSH
69120: LD_INT 1
69122: PUSH
69123: LD_INT 0
69125: PUSH
69126: EMPTY
69127: LIST
69128: LIST
69129: PUSH
69130: LD_INT 1
69132: PUSH
69133: LD_INT 1
69135: PUSH
69136: EMPTY
69137: LIST
69138: LIST
69139: PUSH
69140: LD_INT 0
69142: PUSH
69143: LD_INT 1
69145: PUSH
69146: EMPTY
69147: LIST
69148: LIST
69149: PUSH
69150: LD_INT 1
69152: NEG
69153: PUSH
69154: LD_INT 0
69156: PUSH
69157: EMPTY
69158: LIST
69159: LIST
69160: PUSH
69161: LD_INT 1
69163: NEG
69164: PUSH
69165: LD_INT 1
69167: NEG
69168: PUSH
69169: EMPTY
69170: LIST
69171: LIST
69172: PUSH
69173: LD_INT 1
69175: NEG
69176: PUSH
69177: LD_INT 2
69179: NEG
69180: PUSH
69181: EMPTY
69182: LIST
69183: LIST
69184: PUSH
69185: LD_INT 0
69187: PUSH
69188: LD_INT 2
69190: NEG
69191: PUSH
69192: EMPTY
69193: LIST
69194: LIST
69195: PUSH
69196: LD_INT 1
69198: PUSH
69199: LD_INT 1
69201: NEG
69202: PUSH
69203: EMPTY
69204: LIST
69205: LIST
69206: PUSH
69207: LD_INT 2
69209: PUSH
69210: LD_INT 0
69212: PUSH
69213: EMPTY
69214: LIST
69215: LIST
69216: PUSH
69217: LD_INT 2
69219: PUSH
69220: LD_INT 1
69222: PUSH
69223: EMPTY
69224: LIST
69225: LIST
69226: PUSH
69227: LD_INT 2
69229: PUSH
69230: LD_INT 2
69232: PUSH
69233: EMPTY
69234: LIST
69235: LIST
69236: PUSH
69237: LD_INT 1
69239: PUSH
69240: LD_INT 2
69242: PUSH
69243: EMPTY
69244: LIST
69245: LIST
69246: PUSH
69247: LD_INT 0
69249: PUSH
69250: LD_INT 2
69252: PUSH
69253: EMPTY
69254: LIST
69255: LIST
69256: PUSH
69257: LD_INT 1
69259: NEG
69260: PUSH
69261: LD_INT 1
69263: PUSH
69264: EMPTY
69265: LIST
69266: LIST
69267: PUSH
69268: LD_INT 2
69270: NEG
69271: PUSH
69272: LD_INT 0
69274: PUSH
69275: EMPTY
69276: LIST
69277: LIST
69278: PUSH
69279: LD_INT 2
69281: NEG
69282: PUSH
69283: LD_INT 1
69285: NEG
69286: PUSH
69287: EMPTY
69288: LIST
69289: LIST
69290: PUSH
69291: LD_INT 2
69293: NEG
69294: PUSH
69295: LD_INT 2
69297: NEG
69298: PUSH
69299: EMPTY
69300: LIST
69301: LIST
69302: PUSH
69303: LD_INT 3
69305: PUSH
69306: LD_INT 1
69308: PUSH
69309: EMPTY
69310: LIST
69311: LIST
69312: PUSH
69313: LD_INT 3
69315: PUSH
69316: LD_INT 2
69318: PUSH
69319: EMPTY
69320: LIST
69321: LIST
69322: PUSH
69323: LD_INT 2
69325: PUSH
69326: LD_INT 3
69328: PUSH
69329: EMPTY
69330: LIST
69331: LIST
69332: PUSH
69333: LD_INT 1
69335: PUSH
69336: LD_INT 3
69338: PUSH
69339: EMPTY
69340: LIST
69341: LIST
69342: PUSH
69343: EMPTY
69344: LIST
69345: LIST
69346: LIST
69347: LIST
69348: LIST
69349: LIST
69350: LIST
69351: LIST
69352: LIST
69353: LIST
69354: LIST
69355: LIST
69356: LIST
69357: LIST
69358: LIST
69359: LIST
69360: LIST
69361: LIST
69362: LIST
69363: LIST
69364: LIST
69365: LIST
69366: LIST
69367: ST_TO_ADDR
// DepotRu3 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ 2 , 3 ] , [ 1 , 3 ] , [ - 1 , 2 ] , [ - 2 , 1 ] ] ;
69368: LD_ADDR_VAR 0 26
69372: PUSH
69373: LD_INT 0
69375: PUSH
69376: LD_INT 0
69378: PUSH
69379: EMPTY
69380: LIST
69381: LIST
69382: PUSH
69383: LD_INT 0
69385: PUSH
69386: LD_INT 1
69388: NEG
69389: PUSH
69390: EMPTY
69391: LIST
69392: LIST
69393: PUSH
69394: LD_INT 1
69396: PUSH
69397: LD_INT 0
69399: PUSH
69400: EMPTY
69401: LIST
69402: LIST
69403: PUSH
69404: LD_INT 1
69406: PUSH
69407: LD_INT 1
69409: PUSH
69410: EMPTY
69411: LIST
69412: LIST
69413: PUSH
69414: LD_INT 0
69416: PUSH
69417: LD_INT 1
69419: PUSH
69420: EMPTY
69421: LIST
69422: LIST
69423: PUSH
69424: LD_INT 1
69426: NEG
69427: PUSH
69428: LD_INT 0
69430: PUSH
69431: EMPTY
69432: LIST
69433: LIST
69434: PUSH
69435: LD_INT 1
69437: NEG
69438: PUSH
69439: LD_INT 1
69441: NEG
69442: PUSH
69443: EMPTY
69444: LIST
69445: LIST
69446: PUSH
69447: LD_INT 1
69449: NEG
69450: PUSH
69451: LD_INT 2
69453: NEG
69454: PUSH
69455: EMPTY
69456: LIST
69457: LIST
69458: PUSH
69459: LD_INT 0
69461: PUSH
69462: LD_INT 2
69464: NEG
69465: PUSH
69466: EMPTY
69467: LIST
69468: LIST
69469: PUSH
69470: LD_INT 1
69472: PUSH
69473: LD_INT 1
69475: NEG
69476: PUSH
69477: EMPTY
69478: LIST
69479: LIST
69480: PUSH
69481: LD_INT 2
69483: PUSH
69484: LD_INT 0
69486: PUSH
69487: EMPTY
69488: LIST
69489: LIST
69490: PUSH
69491: LD_INT 2
69493: PUSH
69494: LD_INT 1
69496: PUSH
69497: EMPTY
69498: LIST
69499: LIST
69500: PUSH
69501: LD_INT 2
69503: PUSH
69504: LD_INT 2
69506: PUSH
69507: EMPTY
69508: LIST
69509: LIST
69510: PUSH
69511: LD_INT 1
69513: PUSH
69514: LD_INT 2
69516: PUSH
69517: EMPTY
69518: LIST
69519: LIST
69520: PUSH
69521: LD_INT 0
69523: PUSH
69524: LD_INT 2
69526: PUSH
69527: EMPTY
69528: LIST
69529: LIST
69530: PUSH
69531: LD_INT 1
69533: NEG
69534: PUSH
69535: LD_INT 1
69537: PUSH
69538: EMPTY
69539: LIST
69540: LIST
69541: PUSH
69542: LD_INT 2
69544: NEG
69545: PUSH
69546: LD_INT 0
69548: PUSH
69549: EMPTY
69550: LIST
69551: LIST
69552: PUSH
69553: LD_INT 2
69555: NEG
69556: PUSH
69557: LD_INT 1
69559: NEG
69560: PUSH
69561: EMPTY
69562: LIST
69563: LIST
69564: PUSH
69565: LD_INT 2
69567: NEG
69568: PUSH
69569: LD_INT 2
69571: NEG
69572: PUSH
69573: EMPTY
69574: LIST
69575: LIST
69576: PUSH
69577: LD_INT 2
69579: PUSH
69580: LD_INT 3
69582: PUSH
69583: EMPTY
69584: LIST
69585: LIST
69586: PUSH
69587: LD_INT 1
69589: PUSH
69590: LD_INT 3
69592: PUSH
69593: EMPTY
69594: LIST
69595: LIST
69596: PUSH
69597: LD_INT 1
69599: NEG
69600: PUSH
69601: LD_INT 2
69603: PUSH
69604: EMPTY
69605: LIST
69606: LIST
69607: PUSH
69608: LD_INT 2
69610: NEG
69611: PUSH
69612: LD_INT 1
69614: PUSH
69615: EMPTY
69616: LIST
69617: LIST
69618: PUSH
69619: EMPTY
69620: LIST
69621: LIST
69622: LIST
69623: LIST
69624: LIST
69625: LIST
69626: LIST
69627: LIST
69628: LIST
69629: LIST
69630: LIST
69631: LIST
69632: LIST
69633: LIST
69634: LIST
69635: LIST
69636: LIST
69637: LIST
69638: LIST
69639: LIST
69640: LIST
69641: LIST
69642: LIST
69643: ST_TO_ADDR
// DepotRu4 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ - 1 , 2 ] , [ - 2 , 1 ] , [ - 3 , - 1 ] , [ - 3 , - 2 ] ] ;
69644: LD_ADDR_VAR 0 27
69648: PUSH
69649: LD_INT 0
69651: PUSH
69652: LD_INT 0
69654: PUSH
69655: EMPTY
69656: LIST
69657: LIST
69658: PUSH
69659: LD_INT 0
69661: PUSH
69662: LD_INT 1
69664: NEG
69665: PUSH
69666: EMPTY
69667: LIST
69668: LIST
69669: PUSH
69670: LD_INT 1
69672: PUSH
69673: LD_INT 0
69675: PUSH
69676: EMPTY
69677: LIST
69678: LIST
69679: PUSH
69680: LD_INT 1
69682: PUSH
69683: LD_INT 1
69685: PUSH
69686: EMPTY
69687: LIST
69688: LIST
69689: PUSH
69690: LD_INT 0
69692: PUSH
69693: LD_INT 1
69695: PUSH
69696: EMPTY
69697: LIST
69698: LIST
69699: PUSH
69700: LD_INT 1
69702: NEG
69703: PUSH
69704: LD_INT 0
69706: PUSH
69707: EMPTY
69708: LIST
69709: LIST
69710: PUSH
69711: LD_INT 1
69713: NEG
69714: PUSH
69715: LD_INT 1
69717: NEG
69718: PUSH
69719: EMPTY
69720: LIST
69721: LIST
69722: PUSH
69723: LD_INT 1
69725: NEG
69726: PUSH
69727: LD_INT 2
69729: NEG
69730: PUSH
69731: EMPTY
69732: LIST
69733: LIST
69734: PUSH
69735: LD_INT 0
69737: PUSH
69738: LD_INT 2
69740: NEG
69741: PUSH
69742: EMPTY
69743: LIST
69744: LIST
69745: PUSH
69746: LD_INT 1
69748: PUSH
69749: LD_INT 1
69751: NEG
69752: PUSH
69753: EMPTY
69754: LIST
69755: LIST
69756: PUSH
69757: LD_INT 2
69759: PUSH
69760: LD_INT 0
69762: PUSH
69763: EMPTY
69764: LIST
69765: LIST
69766: PUSH
69767: LD_INT 2
69769: PUSH
69770: LD_INT 1
69772: PUSH
69773: EMPTY
69774: LIST
69775: LIST
69776: PUSH
69777: LD_INT 2
69779: PUSH
69780: LD_INT 2
69782: PUSH
69783: EMPTY
69784: LIST
69785: LIST
69786: PUSH
69787: LD_INT 1
69789: PUSH
69790: LD_INT 2
69792: PUSH
69793: EMPTY
69794: LIST
69795: LIST
69796: PUSH
69797: LD_INT 0
69799: PUSH
69800: LD_INT 2
69802: PUSH
69803: EMPTY
69804: LIST
69805: LIST
69806: PUSH
69807: LD_INT 1
69809: NEG
69810: PUSH
69811: LD_INT 1
69813: PUSH
69814: EMPTY
69815: LIST
69816: LIST
69817: PUSH
69818: LD_INT 2
69820: NEG
69821: PUSH
69822: LD_INT 0
69824: PUSH
69825: EMPTY
69826: LIST
69827: LIST
69828: PUSH
69829: LD_INT 2
69831: NEG
69832: PUSH
69833: LD_INT 1
69835: NEG
69836: PUSH
69837: EMPTY
69838: LIST
69839: LIST
69840: PUSH
69841: LD_INT 2
69843: NEG
69844: PUSH
69845: LD_INT 2
69847: NEG
69848: PUSH
69849: EMPTY
69850: LIST
69851: LIST
69852: PUSH
69853: LD_INT 1
69855: NEG
69856: PUSH
69857: LD_INT 2
69859: PUSH
69860: EMPTY
69861: LIST
69862: LIST
69863: PUSH
69864: LD_INT 2
69866: NEG
69867: PUSH
69868: LD_INT 1
69870: PUSH
69871: EMPTY
69872: LIST
69873: LIST
69874: PUSH
69875: LD_INT 3
69877: NEG
69878: PUSH
69879: LD_INT 1
69881: NEG
69882: PUSH
69883: EMPTY
69884: LIST
69885: LIST
69886: PUSH
69887: LD_INT 3
69889: NEG
69890: PUSH
69891: LD_INT 2
69893: NEG
69894: PUSH
69895: EMPTY
69896: LIST
69897: LIST
69898: PUSH
69899: EMPTY
69900: LIST
69901: LIST
69902: LIST
69903: LIST
69904: LIST
69905: LIST
69906: LIST
69907: LIST
69908: LIST
69909: LIST
69910: LIST
69911: LIST
69912: LIST
69913: LIST
69914: LIST
69915: LIST
69916: LIST
69917: LIST
69918: LIST
69919: LIST
69920: LIST
69921: LIST
69922: LIST
69923: ST_TO_ADDR
// DepotRu5 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ - 2 , - 3 ] , [ - 1 , - 3 ] , [ - 3 , - 1 ] , [ - 3 , - 2 ] ] ;
69924: LD_ADDR_VAR 0 28
69928: PUSH
69929: LD_INT 0
69931: PUSH
69932: LD_INT 0
69934: PUSH
69935: EMPTY
69936: LIST
69937: LIST
69938: PUSH
69939: LD_INT 0
69941: PUSH
69942: LD_INT 1
69944: NEG
69945: PUSH
69946: EMPTY
69947: LIST
69948: LIST
69949: PUSH
69950: LD_INT 1
69952: PUSH
69953: LD_INT 0
69955: PUSH
69956: EMPTY
69957: LIST
69958: LIST
69959: PUSH
69960: LD_INT 1
69962: PUSH
69963: LD_INT 1
69965: PUSH
69966: EMPTY
69967: LIST
69968: LIST
69969: PUSH
69970: LD_INT 0
69972: PUSH
69973: LD_INT 1
69975: PUSH
69976: EMPTY
69977: LIST
69978: LIST
69979: PUSH
69980: LD_INT 1
69982: NEG
69983: PUSH
69984: LD_INT 0
69986: PUSH
69987: EMPTY
69988: LIST
69989: LIST
69990: PUSH
69991: LD_INT 1
69993: NEG
69994: PUSH
69995: LD_INT 1
69997: NEG
69998: PUSH
69999: EMPTY
70000: LIST
70001: LIST
70002: PUSH
70003: LD_INT 1
70005: NEG
70006: PUSH
70007: LD_INT 2
70009: NEG
70010: PUSH
70011: EMPTY
70012: LIST
70013: LIST
70014: PUSH
70015: LD_INT 0
70017: PUSH
70018: LD_INT 2
70020: NEG
70021: PUSH
70022: EMPTY
70023: LIST
70024: LIST
70025: PUSH
70026: LD_INT 1
70028: PUSH
70029: LD_INT 1
70031: NEG
70032: PUSH
70033: EMPTY
70034: LIST
70035: LIST
70036: PUSH
70037: LD_INT 2
70039: PUSH
70040: LD_INT 0
70042: PUSH
70043: EMPTY
70044: LIST
70045: LIST
70046: PUSH
70047: LD_INT 2
70049: PUSH
70050: LD_INT 1
70052: PUSH
70053: EMPTY
70054: LIST
70055: LIST
70056: PUSH
70057: LD_INT 2
70059: PUSH
70060: LD_INT 2
70062: PUSH
70063: EMPTY
70064: LIST
70065: LIST
70066: PUSH
70067: LD_INT 1
70069: PUSH
70070: LD_INT 2
70072: PUSH
70073: EMPTY
70074: LIST
70075: LIST
70076: PUSH
70077: LD_INT 0
70079: PUSH
70080: LD_INT 2
70082: PUSH
70083: EMPTY
70084: LIST
70085: LIST
70086: PUSH
70087: LD_INT 1
70089: NEG
70090: PUSH
70091: LD_INT 1
70093: PUSH
70094: EMPTY
70095: LIST
70096: LIST
70097: PUSH
70098: LD_INT 2
70100: NEG
70101: PUSH
70102: LD_INT 0
70104: PUSH
70105: EMPTY
70106: LIST
70107: LIST
70108: PUSH
70109: LD_INT 2
70111: NEG
70112: PUSH
70113: LD_INT 1
70115: NEG
70116: PUSH
70117: EMPTY
70118: LIST
70119: LIST
70120: PUSH
70121: LD_INT 2
70123: NEG
70124: PUSH
70125: LD_INT 2
70127: NEG
70128: PUSH
70129: EMPTY
70130: LIST
70131: LIST
70132: PUSH
70133: LD_INT 2
70135: NEG
70136: PUSH
70137: LD_INT 3
70139: NEG
70140: PUSH
70141: EMPTY
70142: LIST
70143: LIST
70144: PUSH
70145: LD_INT 1
70147: NEG
70148: PUSH
70149: LD_INT 3
70151: NEG
70152: PUSH
70153: EMPTY
70154: LIST
70155: LIST
70156: PUSH
70157: LD_INT 3
70159: NEG
70160: PUSH
70161: LD_INT 1
70163: NEG
70164: PUSH
70165: EMPTY
70166: LIST
70167: LIST
70168: PUSH
70169: LD_INT 3
70171: NEG
70172: PUSH
70173: LD_INT 2
70175: NEG
70176: PUSH
70177: EMPTY
70178: LIST
70179: LIST
70180: PUSH
70181: EMPTY
70182: LIST
70183: LIST
70184: LIST
70185: LIST
70186: LIST
70187: LIST
70188: LIST
70189: LIST
70190: LIST
70191: LIST
70192: LIST
70193: LIST
70194: LIST
70195: LIST
70196: LIST
70197: LIST
70198: LIST
70199: LIST
70200: LIST
70201: LIST
70202: LIST
70203: LIST
70204: LIST
70205: ST_TO_ADDR
// Factory0 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ - 2 , - 3 ] , [ 2 , - 1 ] , [ 3 , 1 ] , [ 1 , 3 ] , [ - 1 , 2 ] , [ - 3 , - 2 ] ] ;
70206: LD_ADDR_VAR 0 29
70210: PUSH
70211: LD_INT 0
70213: PUSH
70214: LD_INT 0
70216: PUSH
70217: EMPTY
70218: LIST
70219: LIST
70220: PUSH
70221: LD_INT 0
70223: PUSH
70224: LD_INT 1
70226: NEG
70227: PUSH
70228: EMPTY
70229: LIST
70230: LIST
70231: PUSH
70232: LD_INT 1
70234: PUSH
70235: LD_INT 0
70237: PUSH
70238: EMPTY
70239: LIST
70240: LIST
70241: PUSH
70242: LD_INT 1
70244: PUSH
70245: LD_INT 1
70247: PUSH
70248: EMPTY
70249: LIST
70250: LIST
70251: PUSH
70252: LD_INT 0
70254: PUSH
70255: LD_INT 1
70257: PUSH
70258: EMPTY
70259: LIST
70260: LIST
70261: PUSH
70262: LD_INT 1
70264: NEG
70265: PUSH
70266: LD_INT 0
70268: PUSH
70269: EMPTY
70270: LIST
70271: LIST
70272: PUSH
70273: LD_INT 1
70275: NEG
70276: PUSH
70277: LD_INT 1
70279: NEG
70280: PUSH
70281: EMPTY
70282: LIST
70283: LIST
70284: PUSH
70285: LD_INT 1
70287: NEG
70288: PUSH
70289: LD_INT 2
70291: NEG
70292: PUSH
70293: EMPTY
70294: LIST
70295: LIST
70296: PUSH
70297: LD_INT 0
70299: PUSH
70300: LD_INT 2
70302: NEG
70303: PUSH
70304: EMPTY
70305: LIST
70306: LIST
70307: PUSH
70308: LD_INT 1
70310: PUSH
70311: LD_INT 1
70313: NEG
70314: PUSH
70315: EMPTY
70316: LIST
70317: LIST
70318: PUSH
70319: LD_INT 2
70321: PUSH
70322: LD_INT 0
70324: PUSH
70325: EMPTY
70326: LIST
70327: LIST
70328: PUSH
70329: LD_INT 2
70331: PUSH
70332: LD_INT 1
70334: PUSH
70335: EMPTY
70336: LIST
70337: LIST
70338: PUSH
70339: LD_INT 1
70341: PUSH
70342: LD_INT 2
70344: PUSH
70345: EMPTY
70346: LIST
70347: LIST
70348: PUSH
70349: LD_INT 0
70351: PUSH
70352: LD_INT 2
70354: PUSH
70355: EMPTY
70356: LIST
70357: LIST
70358: PUSH
70359: LD_INT 1
70361: NEG
70362: PUSH
70363: LD_INT 1
70365: PUSH
70366: EMPTY
70367: LIST
70368: LIST
70369: PUSH
70370: LD_INT 2
70372: NEG
70373: PUSH
70374: LD_INT 1
70376: NEG
70377: PUSH
70378: EMPTY
70379: LIST
70380: LIST
70381: PUSH
70382: LD_INT 2
70384: NEG
70385: PUSH
70386: LD_INT 2
70388: NEG
70389: PUSH
70390: EMPTY
70391: LIST
70392: LIST
70393: PUSH
70394: LD_INT 2
70396: NEG
70397: PUSH
70398: LD_INT 3
70400: NEG
70401: PUSH
70402: EMPTY
70403: LIST
70404: LIST
70405: PUSH
70406: LD_INT 2
70408: PUSH
70409: LD_INT 1
70411: NEG
70412: PUSH
70413: EMPTY
70414: LIST
70415: LIST
70416: PUSH
70417: LD_INT 3
70419: PUSH
70420: LD_INT 1
70422: PUSH
70423: EMPTY
70424: LIST
70425: LIST
70426: PUSH
70427: LD_INT 1
70429: PUSH
70430: LD_INT 3
70432: PUSH
70433: EMPTY
70434: LIST
70435: LIST
70436: PUSH
70437: LD_INT 1
70439: NEG
70440: PUSH
70441: LD_INT 2
70443: PUSH
70444: EMPTY
70445: LIST
70446: LIST
70447: PUSH
70448: LD_INT 3
70450: NEG
70451: PUSH
70452: LD_INT 2
70454: NEG
70455: PUSH
70456: EMPTY
70457: LIST
70458: LIST
70459: PUSH
70460: EMPTY
70461: LIST
70462: LIST
70463: LIST
70464: LIST
70465: LIST
70466: LIST
70467: LIST
70468: LIST
70469: LIST
70470: LIST
70471: LIST
70472: LIST
70473: LIST
70474: LIST
70475: LIST
70476: LIST
70477: LIST
70478: LIST
70479: LIST
70480: LIST
70481: LIST
70482: LIST
70483: LIST
70484: ST_TO_ADDR
// Factory1 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 1 , - 3 ] , [ 1 , - 2 ] , [ 3 , 2 ] , [ 2 , 3 ] , [ - 2 , 1 ] , [ - 3 , - 1 ] ] ;
70485: LD_ADDR_VAR 0 30
70489: PUSH
70490: LD_INT 0
70492: PUSH
70493: LD_INT 0
70495: PUSH
70496: EMPTY
70497: LIST
70498: LIST
70499: PUSH
70500: LD_INT 0
70502: PUSH
70503: LD_INT 1
70505: NEG
70506: PUSH
70507: EMPTY
70508: LIST
70509: LIST
70510: PUSH
70511: LD_INT 1
70513: PUSH
70514: LD_INT 0
70516: PUSH
70517: EMPTY
70518: LIST
70519: LIST
70520: PUSH
70521: LD_INT 1
70523: PUSH
70524: LD_INT 1
70526: PUSH
70527: EMPTY
70528: LIST
70529: LIST
70530: PUSH
70531: LD_INT 0
70533: PUSH
70534: LD_INT 1
70536: PUSH
70537: EMPTY
70538: LIST
70539: LIST
70540: PUSH
70541: LD_INT 1
70543: NEG
70544: PUSH
70545: LD_INT 0
70547: PUSH
70548: EMPTY
70549: LIST
70550: LIST
70551: PUSH
70552: LD_INT 1
70554: NEG
70555: PUSH
70556: LD_INT 1
70558: NEG
70559: PUSH
70560: EMPTY
70561: LIST
70562: LIST
70563: PUSH
70564: LD_INT 1
70566: NEG
70567: PUSH
70568: LD_INT 2
70570: NEG
70571: PUSH
70572: EMPTY
70573: LIST
70574: LIST
70575: PUSH
70576: LD_INT 0
70578: PUSH
70579: LD_INT 2
70581: NEG
70582: PUSH
70583: EMPTY
70584: LIST
70585: LIST
70586: PUSH
70587: LD_INT 1
70589: PUSH
70590: LD_INT 1
70592: NEG
70593: PUSH
70594: EMPTY
70595: LIST
70596: LIST
70597: PUSH
70598: LD_INT 2
70600: PUSH
70601: LD_INT 0
70603: PUSH
70604: EMPTY
70605: LIST
70606: LIST
70607: PUSH
70608: LD_INT 2
70610: PUSH
70611: LD_INT 1
70613: PUSH
70614: EMPTY
70615: LIST
70616: LIST
70617: PUSH
70618: LD_INT 2
70620: PUSH
70621: LD_INT 2
70623: PUSH
70624: EMPTY
70625: LIST
70626: LIST
70627: PUSH
70628: LD_INT 1
70630: PUSH
70631: LD_INT 2
70633: PUSH
70634: EMPTY
70635: LIST
70636: LIST
70637: PUSH
70638: LD_INT 1
70640: NEG
70641: PUSH
70642: LD_INT 1
70644: PUSH
70645: EMPTY
70646: LIST
70647: LIST
70648: PUSH
70649: LD_INT 2
70651: NEG
70652: PUSH
70653: LD_INT 0
70655: PUSH
70656: EMPTY
70657: LIST
70658: LIST
70659: PUSH
70660: LD_INT 2
70662: NEG
70663: PUSH
70664: LD_INT 1
70666: NEG
70667: PUSH
70668: EMPTY
70669: LIST
70670: LIST
70671: PUSH
70672: LD_INT 1
70674: NEG
70675: PUSH
70676: LD_INT 3
70678: NEG
70679: PUSH
70680: EMPTY
70681: LIST
70682: LIST
70683: PUSH
70684: LD_INT 1
70686: PUSH
70687: LD_INT 2
70689: NEG
70690: PUSH
70691: EMPTY
70692: LIST
70693: LIST
70694: PUSH
70695: LD_INT 3
70697: PUSH
70698: LD_INT 2
70700: PUSH
70701: EMPTY
70702: LIST
70703: LIST
70704: PUSH
70705: LD_INT 2
70707: PUSH
70708: LD_INT 3
70710: PUSH
70711: EMPTY
70712: LIST
70713: LIST
70714: PUSH
70715: LD_INT 2
70717: NEG
70718: PUSH
70719: LD_INT 1
70721: PUSH
70722: EMPTY
70723: LIST
70724: LIST
70725: PUSH
70726: LD_INT 3
70728: NEG
70729: PUSH
70730: LD_INT 1
70732: NEG
70733: PUSH
70734: EMPTY
70735: LIST
70736: LIST
70737: PUSH
70738: EMPTY
70739: LIST
70740: LIST
70741: LIST
70742: LIST
70743: LIST
70744: LIST
70745: LIST
70746: LIST
70747: LIST
70748: LIST
70749: LIST
70750: LIST
70751: LIST
70752: LIST
70753: LIST
70754: LIST
70755: LIST
70756: LIST
70757: LIST
70758: LIST
70759: LIST
70760: LIST
70761: LIST
70762: ST_TO_ADDR
// Factory2 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ - 2 , - 3 ] , [ 2 , - 1 ] , [ 3 , 1 ] , [ 1 , 3 ] , [ - 1 , 2 ] , [ - 3 , - 2 ] ] ;
70763: LD_ADDR_VAR 0 31
70767: PUSH
70768: LD_INT 0
70770: PUSH
70771: LD_INT 0
70773: PUSH
70774: EMPTY
70775: LIST
70776: LIST
70777: PUSH
70778: LD_INT 0
70780: PUSH
70781: LD_INT 1
70783: NEG
70784: PUSH
70785: EMPTY
70786: LIST
70787: LIST
70788: PUSH
70789: LD_INT 1
70791: PUSH
70792: LD_INT 0
70794: PUSH
70795: EMPTY
70796: LIST
70797: LIST
70798: PUSH
70799: LD_INT 1
70801: PUSH
70802: LD_INT 1
70804: PUSH
70805: EMPTY
70806: LIST
70807: LIST
70808: PUSH
70809: LD_INT 0
70811: PUSH
70812: LD_INT 1
70814: PUSH
70815: EMPTY
70816: LIST
70817: LIST
70818: PUSH
70819: LD_INT 1
70821: NEG
70822: PUSH
70823: LD_INT 0
70825: PUSH
70826: EMPTY
70827: LIST
70828: LIST
70829: PUSH
70830: LD_INT 1
70832: NEG
70833: PUSH
70834: LD_INT 1
70836: NEG
70837: PUSH
70838: EMPTY
70839: LIST
70840: LIST
70841: PUSH
70842: LD_INT 1
70844: NEG
70845: PUSH
70846: LD_INT 2
70848: NEG
70849: PUSH
70850: EMPTY
70851: LIST
70852: LIST
70853: PUSH
70854: LD_INT 1
70856: PUSH
70857: LD_INT 1
70859: NEG
70860: PUSH
70861: EMPTY
70862: LIST
70863: LIST
70864: PUSH
70865: LD_INT 2
70867: PUSH
70868: LD_INT 0
70870: PUSH
70871: EMPTY
70872: LIST
70873: LIST
70874: PUSH
70875: LD_INT 2
70877: PUSH
70878: LD_INT 1
70880: PUSH
70881: EMPTY
70882: LIST
70883: LIST
70884: PUSH
70885: LD_INT 2
70887: PUSH
70888: LD_INT 2
70890: PUSH
70891: EMPTY
70892: LIST
70893: LIST
70894: PUSH
70895: LD_INT 1
70897: PUSH
70898: LD_INT 2
70900: PUSH
70901: EMPTY
70902: LIST
70903: LIST
70904: PUSH
70905: LD_INT 0
70907: PUSH
70908: LD_INT 2
70910: PUSH
70911: EMPTY
70912: LIST
70913: LIST
70914: PUSH
70915: LD_INT 1
70917: NEG
70918: PUSH
70919: LD_INT 1
70921: PUSH
70922: EMPTY
70923: LIST
70924: LIST
70925: PUSH
70926: LD_INT 2
70928: NEG
70929: PUSH
70930: LD_INT 1
70932: NEG
70933: PUSH
70934: EMPTY
70935: LIST
70936: LIST
70937: PUSH
70938: LD_INT 2
70940: NEG
70941: PUSH
70942: LD_INT 2
70944: NEG
70945: PUSH
70946: EMPTY
70947: LIST
70948: LIST
70949: PUSH
70950: LD_INT 2
70952: NEG
70953: PUSH
70954: LD_INT 3
70956: NEG
70957: PUSH
70958: EMPTY
70959: LIST
70960: LIST
70961: PUSH
70962: LD_INT 2
70964: PUSH
70965: LD_INT 1
70967: NEG
70968: PUSH
70969: EMPTY
70970: LIST
70971: LIST
70972: PUSH
70973: LD_INT 3
70975: PUSH
70976: LD_INT 1
70978: PUSH
70979: EMPTY
70980: LIST
70981: LIST
70982: PUSH
70983: LD_INT 1
70985: PUSH
70986: LD_INT 3
70988: PUSH
70989: EMPTY
70990: LIST
70991: LIST
70992: PUSH
70993: LD_INT 1
70995: NEG
70996: PUSH
70997: LD_INT 2
70999: PUSH
71000: EMPTY
71001: LIST
71002: LIST
71003: PUSH
71004: LD_INT 3
71006: NEG
71007: PUSH
71008: LD_INT 2
71010: NEG
71011: PUSH
71012: EMPTY
71013: LIST
71014: LIST
71015: PUSH
71016: EMPTY
71017: LIST
71018: LIST
71019: LIST
71020: LIST
71021: LIST
71022: LIST
71023: LIST
71024: LIST
71025: LIST
71026: LIST
71027: LIST
71028: LIST
71029: LIST
71030: LIST
71031: LIST
71032: LIST
71033: LIST
71034: LIST
71035: LIST
71036: LIST
71037: LIST
71038: LIST
71039: LIST
71040: ST_TO_ADDR
// Factory3 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 1 , - 3 ] , [ 1 , - 2 ] , [ 3 , 2 ] , [ 2 , 3 ] , [ - 2 , 1 ] , [ - 3 , - 1 ] ] ;
71041: LD_ADDR_VAR 0 32
71045: PUSH
71046: LD_INT 0
71048: PUSH
71049: LD_INT 0
71051: PUSH
71052: EMPTY
71053: LIST
71054: LIST
71055: PUSH
71056: LD_INT 0
71058: PUSH
71059: LD_INT 1
71061: NEG
71062: PUSH
71063: EMPTY
71064: LIST
71065: LIST
71066: PUSH
71067: LD_INT 1
71069: PUSH
71070: LD_INT 0
71072: PUSH
71073: EMPTY
71074: LIST
71075: LIST
71076: PUSH
71077: LD_INT 1
71079: PUSH
71080: LD_INT 1
71082: PUSH
71083: EMPTY
71084: LIST
71085: LIST
71086: PUSH
71087: LD_INT 0
71089: PUSH
71090: LD_INT 1
71092: PUSH
71093: EMPTY
71094: LIST
71095: LIST
71096: PUSH
71097: LD_INT 1
71099: NEG
71100: PUSH
71101: LD_INT 0
71103: PUSH
71104: EMPTY
71105: LIST
71106: LIST
71107: PUSH
71108: LD_INT 1
71110: NEG
71111: PUSH
71112: LD_INT 1
71114: NEG
71115: PUSH
71116: EMPTY
71117: LIST
71118: LIST
71119: PUSH
71120: LD_INT 1
71122: NEG
71123: PUSH
71124: LD_INT 2
71126: NEG
71127: PUSH
71128: EMPTY
71129: LIST
71130: LIST
71131: PUSH
71132: LD_INT 0
71134: PUSH
71135: LD_INT 2
71137: NEG
71138: PUSH
71139: EMPTY
71140: LIST
71141: LIST
71142: PUSH
71143: LD_INT 1
71145: PUSH
71146: LD_INT 1
71148: NEG
71149: PUSH
71150: EMPTY
71151: LIST
71152: LIST
71153: PUSH
71154: LD_INT 2
71156: PUSH
71157: LD_INT 1
71159: PUSH
71160: EMPTY
71161: LIST
71162: LIST
71163: PUSH
71164: LD_INT 2
71166: PUSH
71167: LD_INT 2
71169: PUSH
71170: EMPTY
71171: LIST
71172: LIST
71173: PUSH
71174: LD_INT 1
71176: PUSH
71177: LD_INT 2
71179: PUSH
71180: EMPTY
71181: LIST
71182: LIST
71183: PUSH
71184: LD_INT 0
71186: PUSH
71187: LD_INT 2
71189: PUSH
71190: EMPTY
71191: LIST
71192: LIST
71193: PUSH
71194: LD_INT 1
71196: NEG
71197: PUSH
71198: LD_INT 1
71200: PUSH
71201: EMPTY
71202: LIST
71203: LIST
71204: PUSH
71205: LD_INT 2
71207: NEG
71208: PUSH
71209: LD_INT 0
71211: PUSH
71212: EMPTY
71213: LIST
71214: LIST
71215: PUSH
71216: LD_INT 2
71218: NEG
71219: PUSH
71220: LD_INT 1
71222: NEG
71223: PUSH
71224: EMPTY
71225: LIST
71226: LIST
71227: PUSH
71228: LD_INT 1
71230: NEG
71231: PUSH
71232: LD_INT 3
71234: NEG
71235: PUSH
71236: EMPTY
71237: LIST
71238: LIST
71239: PUSH
71240: LD_INT 1
71242: PUSH
71243: LD_INT 2
71245: NEG
71246: PUSH
71247: EMPTY
71248: LIST
71249: LIST
71250: PUSH
71251: LD_INT 3
71253: PUSH
71254: LD_INT 2
71256: PUSH
71257: EMPTY
71258: LIST
71259: LIST
71260: PUSH
71261: LD_INT 2
71263: PUSH
71264: LD_INT 3
71266: PUSH
71267: EMPTY
71268: LIST
71269: LIST
71270: PUSH
71271: LD_INT 2
71273: NEG
71274: PUSH
71275: LD_INT 1
71277: PUSH
71278: EMPTY
71279: LIST
71280: LIST
71281: PUSH
71282: LD_INT 3
71284: NEG
71285: PUSH
71286: LD_INT 1
71288: NEG
71289: PUSH
71290: EMPTY
71291: LIST
71292: LIST
71293: PUSH
71294: EMPTY
71295: LIST
71296: LIST
71297: LIST
71298: LIST
71299: LIST
71300: LIST
71301: LIST
71302: LIST
71303: LIST
71304: LIST
71305: LIST
71306: LIST
71307: LIST
71308: LIST
71309: LIST
71310: LIST
71311: LIST
71312: LIST
71313: LIST
71314: LIST
71315: LIST
71316: LIST
71317: LIST
71318: ST_TO_ADDR
// Factory4 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ - 2 , - 3 ] , [ 2 , - 1 ] , [ 3 , 1 ] , [ 1 , 3 ] , [ - 1 , 2 ] , [ - 3 , - 2 ] ] ;
71319: LD_ADDR_VAR 0 33
71323: PUSH
71324: LD_INT 0
71326: PUSH
71327: LD_INT 0
71329: PUSH
71330: EMPTY
71331: LIST
71332: LIST
71333: PUSH
71334: LD_INT 0
71336: PUSH
71337: LD_INT 1
71339: NEG
71340: PUSH
71341: EMPTY
71342: LIST
71343: LIST
71344: PUSH
71345: LD_INT 1
71347: PUSH
71348: LD_INT 0
71350: PUSH
71351: EMPTY
71352: LIST
71353: LIST
71354: PUSH
71355: LD_INT 1
71357: PUSH
71358: LD_INT 1
71360: PUSH
71361: EMPTY
71362: LIST
71363: LIST
71364: PUSH
71365: LD_INT 0
71367: PUSH
71368: LD_INT 1
71370: PUSH
71371: EMPTY
71372: LIST
71373: LIST
71374: PUSH
71375: LD_INT 1
71377: NEG
71378: PUSH
71379: LD_INT 0
71381: PUSH
71382: EMPTY
71383: LIST
71384: LIST
71385: PUSH
71386: LD_INT 1
71388: NEG
71389: PUSH
71390: LD_INT 1
71392: NEG
71393: PUSH
71394: EMPTY
71395: LIST
71396: LIST
71397: PUSH
71398: LD_INT 1
71400: NEG
71401: PUSH
71402: LD_INT 2
71404: NEG
71405: PUSH
71406: EMPTY
71407: LIST
71408: LIST
71409: PUSH
71410: LD_INT 1
71412: PUSH
71413: LD_INT 1
71415: NEG
71416: PUSH
71417: EMPTY
71418: LIST
71419: LIST
71420: PUSH
71421: LD_INT 2
71423: PUSH
71424: LD_INT 0
71426: PUSH
71427: EMPTY
71428: LIST
71429: LIST
71430: PUSH
71431: LD_INT 2
71433: PUSH
71434: LD_INT 1
71436: PUSH
71437: EMPTY
71438: LIST
71439: LIST
71440: PUSH
71441: LD_INT 1
71443: PUSH
71444: LD_INT 2
71446: PUSH
71447: EMPTY
71448: LIST
71449: LIST
71450: PUSH
71451: LD_INT 0
71453: PUSH
71454: LD_INT 2
71456: PUSH
71457: EMPTY
71458: LIST
71459: LIST
71460: PUSH
71461: LD_INT 1
71463: NEG
71464: PUSH
71465: LD_INT 1
71467: PUSH
71468: EMPTY
71469: LIST
71470: LIST
71471: PUSH
71472: LD_INT 2
71474: NEG
71475: PUSH
71476: LD_INT 0
71478: PUSH
71479: EMPTY
71480: LIST
71481: LIST
71482: PUSH
71483: LD_INT 2
71485: NEG
71486: PUSH
71487: LD_INT 1
71489: NEG
71490: PUSH
71491: EMPTY
71492: LIST
71493: LIST
71494: PUSH
71495: LD_INT 2
71497: NEG
71498: PUSH
71499: LD_INT 2
71501: NEG
71502: PUSH
71503: EMPTY
71504: LIST
71505: LIST
71506: PUSH
71507: LD_INT 2
71509: NEG
71510: PUSH
71511: LD_INT 3
71513: NEG
71514: PUSH
71515: EMPTY
71516: LIST
71517: LIST
71518: PUSH
71519: LD_INT 2
71521: PUSH
71522: LD_INT 1
71524: NEG
71525: PUSH
71526: EMPTY
71527: LIST
71528: LIST
71529: PUSH
71530: LD_INT 3
71532: PUSH
71533: LD_INT 1
71535: PUSH
71536: EMPTY
71537: LIST
71538: LIST
71539: PUSH
71540: LD_INT 1
71542: PUSH
71543: LD_INT 3
71545: PUSH
71546: EMPTY
71547: LIST
71548: LIST
71549: PUSH
71550: LD_INT 1
71552: NEG
71553: PUSH
71554: LD_INT 2
71556: PUSH
71557: EMPTY
71558: LIST
71559: LIST
71560: PUSH
71561: LD_INT 3
71563: NEG
71564: PUSH
71565: LD_INT 2
71567: NEG
71568: PUSH
71569: EMPTY
71570: LIST
71571: LIST
71572: PUSH
71573: EMPTY
71574: LIST
71575: LIST
71576: LIST
71577: LIST
71578: LIST
71579: LIST
71580: LIST
71581: LIST
71582: LIST
71583: LIST
71584: LIST
71585: LIST
71586: LIST
71587: LIST
71588: LIST
71589: LIST
71590: LIST
71591: LIST
71592: LIST
71593: LIST
71594: LIST
71595: LIST
71596: LIST
71597: ST_TO_ADDR
// Factory5 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ - 1 , - 3 ] , [ 1 , - 2 ] , [ 3 , 2 ] , [ 2 , 3 ] , [ - 2 , 1 ] , [ - 3 , - 1 ] ] ;
71598: LD_ADDR_VAR 0 34
71602: PUSH
71603: LD_INT 0
71605: PUSH
71606: LD_INT 0
71608: PUSH
71609: EMPTY
71610: LIST
71611: LIST
71612: PUSH
71613: LD_INT 0
71615: PUSH
71616: LD_INT 1
71618: NEG
71619: PUSH
71620: EMPTY
71621: LIST
71622: LIST
71623: PUSH
71624: LD_INT 1
71626: PUSH
71627: LD_INT 0
71629: PUSH
71630: EMPTY
71631: LIST
71632: LIST
71633: PUSH
71634: LD_INT 1
71636: PUSH
71637: LD_INT 1
71639: PUSH
71640: EMPTY
71641: LIST
71642: LIST
71643: PUSH
71644: LD_INT 0
71646: PUSH
71647: LD_INT 1
71649: PUSH
71650: EMPTY
71651: LIST
71652: LIST
71653: PUSH
71654: LD_INT 1
71656: NEG
71657: PUSH
71658: LD_INT 0
71660: PUSH
71661: EMPTY
71662: LIST
71663: LIST
71664: PUSH
71665: LD_INT 1
71667: NEG
71668: PUSH
71669: LD_INT 1
71671: NEG
71672: PUSH
71673: EMPTY
71674: LIST
71675: LIST
71676: PUSH
71677: LD_INT 1
71679: NEG
71680: PUSH
71681: LD_INT 2
71683: NEG
71684: PUSH
71685: EMPTY
71686: LIST
71687: LIST
71688: PUSH
71689: LD_INT 0
71691: PUSH
71692: LD_INT 2
71694: NEG
71695: PUSH
71696: EMPTY
71697: LIST
71698: LIST
71699: PUSH
71700: LD_INT 1
71702: PUSH
71703: LD_INT 1
71705: NEG
71706: PUSH
71707: EMPTY
71708: LIST
71709: LIST
71710: PUSH
71711: LD_INT 2
71713: PUSH
71714: LD_INT 1
71716: PUSH
71717: EMPTY
71718: LIST
71719: LIST
71720: PUSH
71721: LD_INT 2
71723: PUSH
71724: LD_INT 2
71726: PUSH
71727: EMPTY
71728: LIST
71729: LIST
71730: PUSH
71731: LD_INT 1
71733: PUSH
71734: LD_INT 2
71736: PUSH
71737: EMPTY
71738: LIST
71739: LIST
71740: PUSH
71741: LD_INT 1
71743: NEG
71744: PUSH
71745: LD_INT 1
71747: PUSH
71748: EMPTY
71749: LIST
71750: LIST
71751: PUSH
71752: LD_INT 2
71754: NEG
71755: PUSH
71756: LD_INT 0
71758: PUSH
71759: EMPTY
71760: LIST
71761: LIST
71762: PUSH
71763: LD_INT 2
71765: NEG
71766: PUSH
71767: LD_INT 1
71769: NEG
71770: PUSH
71771: EMPTY
71772: LIST
71773: LIST
71774: PUSH
71775: LD_INT 2
71777: NEG
71778: PUSH
71779: LD_INT 2
71781: NEG
71782: PUSH
71783: EMPTY
71784: LIST
71785: LIST
71786: PUSH
71787: LD_INT 1
71789: NEG
71790: PUSH
71791: LD_INT 3
71793: NEG
71794: PUSH
71795: EMPTY
71796: LIST
71797: LIST
71798: PUSH
71799: LD_INT 1
71801: PUSH
71802: LD_INT 2
71804: NEG
71805: PUSH
71806: EMPTY
71807: LIST
71808: LIST
71809: PUSH
71810: LD_INT 3
71812: PUSH
71813: LD_INT 2
71815: PUSH
71816: EMPTY
71817: LIST
71818: LIST
71819: PUSH
71820: LD_INT 2
71822: PUSH
71823: LD_INT 3
71825: PUSH
71826: EMPTY
71827: LIST
71828: LIST
71829: PUSH
71830: LD_INT 2
71832: NEG
71833: PUSH
71834: LD_INT 1
71836: PUSH
71837: EMPTY
71838: LIST
71839: LIST
71840: PUSH
71841: LD_INT 3
71843: NEG
71844: PUSH
71845: LD_INT 1
71847: NEG
71848: PUSH
71849: EMPTY
71850: LIST
71851: LIST
71852: PUSH
71853: EMPTY
71854: LIST
71855: LIST
71856: LIST
71857: LIST
71858: LIST
71859: LIST
71860: LIST
71861: LIST
71862: LIST
71863: LIST
71864: LIST
71865: LIST
71866: LIST
71867: LIST
71868: LIST
71869: LIST
71870: LIST
71871: LIST
71872: LIST
71873: LIST
71874: LIST
71875: LIST
71876: LIST
71877: ST_TO_ADDR
// Ext0 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ 2 , 1 ] , [ - 2 , - 1 ] ] ;
71878: LD_ADDR_VAR 0 35
71882: PUSH
71883: LD_INT 0
71885: PUSH
71886: LD_INT 0
71888: PUSH
71889: EMPTY
71890: LIST
71891: LIST
71892: PUSH
71893: LD_INT 0
71895: PUSH
71896: LD_INT 1
71898: NEG
71899: PUSH
71900: EMPTY
71901: LIST
71902: LIST
71903: PUSH
71904: LD_INT 1
71906: PUSH
71907: LD_INT 0
71909: PUSH
71910: EMPTY
71911: LIST
71912: LIST
71913: PUSH
71914: LD_INT 1
71916: PUSH
71917: LD_INT 1
71919: PUSH
71920: EMPTY
71921: LIST
71922: LIST
71923: PUSH
71924: LD_INT 0
71926: PUSH
71927: LD_INT 1
71929: PUSH
71930: EMPTY
71931: LIST
71932: LIST
71933: PUSH
71934: LD_INT 1
71936: NEG
71937: PUSH
71938: LD_INT 0
71940: PUSH
71941: EMPTY
71942: LIST
71943: LIST
71944: PUSH
71945: LD_INT 1
71947: NEG
71948: PUSH
71949: LD_INT 1
71951: NEG
71952: PUSH
71953: EMPTY
71954: LIST
71955: LIST
71956: PUSH
71957: LD_INT 2
71959: PUSH
71960: LD_INT 1
71962: PUSH
71963: EMPTY
71964: LIST
71965: LIST
71966: PUSH
71967: LD_INT 2
71969: NEG
71970: PUSH
71971: LD_INT 1
71973: NEG
71974: PUSH
71975: EMPTY
71976: LIST
71977: LIST
71978: PUSH
71979: EMPTY
71980: LIST
71981: LIST
71982: LIST
71983: LIST
71984: LIST
71985: LIST
71986: LIST
71987: LIST
71988: LIST
71989: ST_TO_ADDR
// Ext1 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 1 , 2 ] ] ;
71990: LD_ADDR_VAR 0 36
71994: PUSH
71995: LD_INT 0
71997: PUSH
71998: LD_INT 0
72000: PUSH
72001: EMPTY
72002: LIST
72003: LIST
72004: PUSH
72005: LD_INT 0
72007: PUSH
72008: LD_INT 1
72010: NEG
72011: PUSH
72012: EMPTY
72013: LIST
72014: LIST
72015: PUSH
72016: LD_INT 1
72018: PUSH
72019: LD_INT 0
72021: PUSH
72022: EMPTY
72023: LIST
72024: LIST
72025: PUSH
72026: LD_INT 1
72028: PUSH
72029: LD_INT 1
72031: PUSH
72032: EMPTY
72033: LIST
72034: LIST
72035: PUSH
72036: LD_INT 0
72038: PUSH
72039: LD_INT 1
72041: PUSH
72042: EMPTY
72043: LIST
72044: LIST
72045: PUSH
72046: LD_INT 1
72048: NEG
72049: PUSH
72050: LD_INT 0
72052: PUSH
72053: EMPTY
72054: LIST
72055: LIST
72056: PUSH
72057: LD_INT 1
72059: NEG
72060: PUSH
72061: LD_INT 1
72063: NEG
72064: PUSH
72065: EMPTY
72066: LIST
72067: LIST
72068: PUSH
72069: LD_INT 1
72071: NEG
72072: PUSH
72073: LD_INT 2
72075: NEG
72076: PUSH
72077: EMPTY
72078: LIST
72079: LIST
72080: PUSH
72081: LD_INT 1
72083: PUSH
72084: LD_INT 2
72086: PUSH
72087: EMPTY
72088: LIST
72089: LIST
72090: PUSH
72091: EMPTY
72092: LIST
72093: LIST
72094: LIST
72095: LIST
72096: LIST
72097: LIST
72098: LIST
72099: LIST
72100: LIST
72101: ST_TO_ADDR
// Ext2 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ 1 , - 1 ] , [ - 1 , 1 ] ] ;
72102: LD_ADDR_VAR 0 37
72106: PUSH
72107: LD_INT 0
72109: PUSH
72110: LD_INT 0
72112: PUSH
72113: EMPTY
72114: LIST
72115: LIST
72116: PUSH
72117: LD_INT 0
72119: PUSH
72120: LD_INT 1
72122: NEG
72123: PUSH
72124: EMPTY
72125: LIST
72126: LIST
72127: PUSH
72128: LD_INT 1
72130: PUSH
72131: LD_INT 0
72133: PUSH
72134: EMPTY
72135: LIST
72136: LIST
72137: PUSH
72138: LD_INT 1
72140: PUSH
72141: LD_INT 1
72143: PUSH
72144: EMPTY
72145: LIST
72146: LIST
72147: PUSH
72148: LD_INT 0
72150: PUSH
72151: LD_INT 1
72153: PUSH
72154: EMPTY
72155: LIST
72156: LIST
72157: PUSH
72158: LD_INT 1
72160: NEG
72161: PUSH
72162: LD_INT 0
72164: PUSH
72165: EMPTY
72166: LIST
72167: LIST
72168: PUSH
72169: LD_INT 1
72171: NEG
72172: PUSH
72173: LD_INT 1
72175: NEG
72176: PUSH
72177: EMPTY
72178: LIST
72179: LIST
72180: PUSH
72181: LD_INT 1
72183: PUSH
72184: LD_INT 1
72186: NEG
72187: PUSH
72188: EMPTY
72189: LIST
72190: LIST
72191: PUSH
72192: LD_INT 1
72194: NEG
72195: PUSH
72196: LD_INT 1
72198: PUSH
72199: EMPTY
72200: LIST
72201: LIST
72202: PUSH
72203: EMPTY
72204: LIST
72205: LIST
72206: LIST
72207: LIST
72208: LIST
72209: LIST
72210: LIST
72211: LIST
72212: LIST
72213: ST_TO_ADDR
// Ext3 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ 2 , 1 ] , [ - 2 , - 1 ] ] ;
72214: LD_ADDR_VAR 0 38
72218: PUSH
72219: LD_INT 0
72221: PUSH
72222: LD_INT 0
72224: PUSH
72225: EMPTY
72226: LIST
72227: LIST
72228: PUSH
72229: LD_INT 0
72231: PUSH
72232: LD_INT 1
72234: NEG
72235: PUSH
72236: EMPTY
72237: LIST
72238: LIST
72239: PUSH
72240: LD_INT 1
72242: PUSH
72243: LD_INT 0
72245: PUSH
72246: EMPTY
72247: LIST
72248: LIST
72249: PUSH
72250: LD_INT 1
72252: PUSH
72253: LD_INT 1
72255: PUSH
72256: EMPTY
72257: LIST
72258: LIST
72259: PUSH
72260: LD_INT 0
72262: PUSH
72263: LD_INT 1
72265: PUSH
72266: EMPTY
72267: LIST
72268: LIST
72269: PUSH
72270: LD_INT 1
72272: NEG
72273: PUSH
72274: LD_INT 0
72276: PUSH
72277: EMPTY
72278: LIST
72279: LIST
72280: PUSH
72281: LD_INT 1
72283: NEG
72284: PUSH
72285: LD_INT 1
72287: NEG
72288: PUSH
72289: EMPTY
72290: LIST
72291: LIST
72292: PUSH
72293: LD_INT 2
72295: PUSH
72296: LD_INT 1
72298: PUSH
72299: EMPTY
72300: LIST
72301: LIST
72302: PUSH
72303: LD_INT 2
72305: NEG
72306: PUSH
72307: LD_INT 1
72309: NEG
72310: PUSH
72311: EMPTY
72312: LIST
72313: LIST
72314: PUSH
72315: EMPTY
72316: LIST
72317: LIST
72318: LIST
72319: LIST
72320: LIST
72321: LIST
72322: LIST
72323: LIST
72324: LIST
72325: ST_TO_ADDR
// Ext4 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 1 , 2 ] ] ;
72326: LD_ADDR_VAR 0 39
72330: PUSH
72331: LD_INT 0
72333: PUSH
72334: LD_INT 0
72336: PUSH
72337: EMPTY
72338: LIST
72339: LIST
72340: PUSH
72341: LD_INT 0
72343: PUSH
72344: LD_INT 1
72346: NEG
72347: PUSH
72348: EMPTY
72349: LIST
72350: LIST
72351: PUSH
72352: LD_INT 1
72354: PUSH
72355: LD_INT 0
72357: PUSH
72358: EMPTY
72359: LIST
72360: LIST
72361: PUSH
72362: LD_INT 1
72364: PUSH
72365: LD_INT 1
72367: PUSH
72368: EMPTY
72369: LIST
72370: LIST
72371: PUSH
72372: LD_INT 0
72374: PUSH
72375: LD_INT 1
72377: PUSH
72378: EMPTY
72379: LIST
72380: LIST
72381: PUSH
72382: LD_INT 1
72384: NEG
72385: PUSH
72386: LD_INT 0
72388: PUSH
72389: EMPTY
72390: LIST
72391: LIST
72392: PUSH
72393: LD_INT 1
72395: NEG
72396: PUSH
72397: LD_INT 1
72399: NEG
72400: PUSH
72401: EMPTY
72402: LIST
72403: LIST
72404: PUSH
72405: LD_INT 1
72407: NEG
72408: PUSH
72409: LD_INT 2
72411: NEG
72412: PUSH
72413: EMPTY
72414: LIST
72415: LIST
72416: PUSH
72417: LD_INT 1
72419: PUSH
72420: LD_INT 2
72422: PUSH
72423: EMPTY
72424: LIST
72425: LIST
72426: PUSH
72427: EMPTY
72428: LIST
72429: LIST
72430: LIST
72431: LIST
72432: LIST
72433: LIST
72434: LIST
72435: LIST
72436: LIST
72437: ST_TO_ADDR
// Ext5 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ 1 , - 1 ] , [ - 1 , 1 ] ] ;
72438: LD_ADDR_VAR 0 40
72442: PUSH
72443: LD_INT 0
72445: PUSH
72446: LD_INT 0
72448: PUSH
72449: EMPTY
72450: LIST
72451: LIST
72452: PUSH
72453: LD_INT 0
72455: PUSH
72456: LD_INT 1
72458: NEG
72459: PUSH
72460: EMPTY
72461: LIST
72462: LIST
72463: PUSH
72464: LD_INT 1
72466: PUSH
72467: LD_INT 0
72469: PUSH
72470: EMPTY
72471: LIST
72472: LIST
72473: PUSH
72474: LD_INT 1
72476: PUSH
72477: LD_INT 1
72479: PUSH
72480: EMPTY
72481: LIST
72482: LIST
72483: PUSH
72484: LD_INT 0
72486: PUSH
72487: LD_INT 1
72489: PUSH
72490: EMPTY
72491: LIST
72492: LIST
72493: PUSH
72494: LD_INT 1
72496: NEG
72497: PUSH
72498: LD_INT 0
72500: PUSH
72501: EMPTY
72502: LIST
72503: LIST
72504: PUSH
72505: LD_INT 1
72507: NEG
72508: PUSH
72509: LD_INT 1
72511: NEG
72512: PUSH
72513: EMPTY
72514: LIST
72515: LIST
72516: PUSH
72517: LD_INT 1
72519: PUSH
72520: LD_INT 1
72522: NEG
72523: PUSH
72524: EMPTY
72525: LIST
72526: LIST
72527: PUSH
72528: LD_INT 1
72530: NEG
72531: PUSH
72532: LD_INT 1
72534: PUSH
72535: EMPTY
72536: LIST
72537: LIST
72538: PUSH
72539: EMPTY
72540: LIST
72541: LIST
72542: LIST
72543: LIST
72544: LIST
72545: LIST
72546: LIST
72547: LIST
72548: LIST
72549: ST_TO_ADDR
// Lab0 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ - 2 , - 3 ] , [ 2 , - 1 ] , [ 3 , 0 ] , [ 3 , 1 ] , [ 3 , 2 ] , [ 3 , 3 ] , [ 2 , 3 ] , [ - 2 , 1 ] , [ - 3 , 0 ] , [ - 3 , - 1 ] , [ - 3 , - 2 ] , [ - 3 , - 3 ] ] ;
72550: LD_ADDR_VAR 0 41
72554: PUSH
72555: LD_INT 0
72557: PUSH
72558: LD_INT 0
72560: PUSH
72561: EMPTY
72562: LIST
72563: LIST
72564: PUSH
72565: LD_INT 0
72567: PUSH
72568: LD_INT 1
72570: NEG
72571: PUSH
72572: EMPTY
72573: LIST
72574: LIST
72575: PUSH
72576: LD_INT 1
72578: PUSH
72579: LD_INT 0
72581: PUSH
72582: EMPTY
72583: LIST
72584: LIST
72585: PUSH
72586: LD_INT 1
72588: PUSH
72589: LD_INT 1
72591: PUSH
72592: EMPTY
72593: LIST
72594: LIST
72595: PUSH
72596: LD_INT 0
72598: PUSH
72599: LD_INT 1
72601: PUSH
72602: EMPTY
72603: LIST
72604: LIST
72605: PUSH
72606: LD_INT 1
72608: NEG
72609: PUSH
72610: LD_INT 0
72612: PUSH
72613: EMPTY
72614: LIST
72615: LIST
72616: PUSH
72617: LD_INT 1
72619: NEG
72620: PUSH
72621: LD_INT 1
72623: NEG
72624: PUSH
72625: EMPTY
72626: LIST
72627: LIST
72628: PUSH
72629: LD_INT 1
72631: NEG
72632: PUSH
72633: LD_INT 2
72635: NEG
72636: PUSH
72637: EMPTY
72638: LIST
72639: LIST
72640: PUSH
72641: LD_INT 1
72643: PUSH
72644: LD_INT 1
72646: NEG
72647: PUSH
72648: EMPTY
72649: LIST
72650: LIST
72651: PUSH
72652: LD_INT 2
72654: PUSH
72655: LD_INT 0
72657: PUSH
72658: EMPTY
72659: LIST
72660: LIST
72661: PUSH
72662: LD_INT 2
72664: PUSH
72665: LD_INT 1
72667: PUSH
72668: EMPTY
72669: LIST
72670: LIST
72671: PUSH
72672: LD_INT 2
72674: PUSH
72675: LD_INT 2
72677: PUSH
72678: EMPTY
72679: LIST
72680: LIST
72681: PUSH
72682: LD_INT 1
72684: PUSH
72685: LD_INT 2
72687: PUSH
72688: EMPTY
72689: LIST
72690: LIST
72691: PUSH
72692: LD_INT 1
72694: NEG
72695: PUSH
72696: LD_INT 1
72698: PUSH
72699: EMPTY
72700: LIST
72701: LIST
72702: PUSH
72703: LD_INT 2
72705: NEG
72706: PUSH
72707: LD_INT 0
72709: PUSH
72710: EMPTY
72711: LIST
72712: LIST
72713: PUSH
72714: LD_INT 2
72716: NEG
72717: PUSH
72718: LD_INT 1
72720: NEG
72721: PUSH
72722: EMPTY
72723: LIST
72724: LIST
72725: PUSH
72726: LD_INT 2
72728: NEG
72729: PUSH
72730: LD_INT 2
72732: NEG
72733: PUSH
72734: EMPTY
72735: LIST
72736: LIST
72737: PUSH
72738: LD_INT 2
72740: NEG
72741: PUSH
72742: LD_INT 3
72744: NEG
72745: PUSH
72746: EMPTY
72747: LIST
72748: LIST
72749: PUSH
72750: LD_INT 2
72752: PUSH
72753: LD_INT 1
72755: NEG
72756: PUSH
72757: EMPTY
72758: LIST
72759: LIST
72760: PUSH
72761: LD_INT 3
72763: PUSH
72764: LD_INT 0
72766: PUSH
72767: EMPTY
72768: LIST
72769: LIST
72770: PUSH
72771: LD_INT 3
72773: PUSH
72774: LD_INT 1
72776: PUSH
72777: EMPTY
72778: LIST
72779: LIST
72780: PUSH
72781: LD_INT 3
72783: PUSH
72784: LD_INT 2
72786: PUSH
72787: EMPTY
72788: LIST
72789: LIST
72790: PUSH
72791: LD_INT 3
72793: PUSH
72794: LD_INT 3
72796: PUSH
72797: EMPTY
72798: LIST
72799: LIST
72800: PUSH
72801: LD_INT 2
72803: PUSH
72804: LD_INT 3
72806: PUSH
72807: EMPTY
72808: LIST
72809: LIST
72810: PUSH
72811: LD_INT 2
72813: NEG
72814: PUSH
72815: LD_INT 1
72817: PUSH
72818: EMPTY
72819: LIST
72820: LIST
72821: PUSH
72822: LD_INT 3
72824: NEG
72825: PUSH
72826: LD_INT 0
72828: PUSH
72829: EMPTY
72830: LIST
72831: LIST
72832: PUSH
72833: LD_INT 3
72835: NEG
72836: PUSH
72837: LD_INT 1
72839: NEG
72840: PUSH
72841: EMPTY
72842: LIST
72843: LIST
72844: PUSH
72845: LD_INT 3
72847: NEG
72848: PUSH
72849: LD_INT 2
72851: NEG
72852: PUSH
72853: EMPTY
72854: LIST
72855: LIST
72856: PUSH
72857: LD_INT 3
72859: NEG
72860: PUSH
72861: LD_INT 3
72863: NEG
72864: PUSH
72865: EMPTY
72866: LIST
72867: LIST
72868: PUSH
72869: EMPTY
72870: LIST
72871: LIST
72872: LIST
72873: LIST
72874: LIST
72875: LIST
72876: LIST
72877: LIST
72878: LIST
72879: LIST
72880: LIST
72881: LIST
72882: LIST
72883: LIST
72884: LIST
72885: LIST
72886: LIST
72887: LIST
72888: LIST
72889: LIST
72890: LIST
72891: LIST
72892: LIST
72893: LIST
72894: LIST
72895: LIST
72896: LIST
72897: LIST
72898: LIST
72899: ST_TO_ADDR
// Lab1 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ - 2 , - 3 ] , [ - 1 , - 3 ] , [ 0 , - 3 ] , [ 1 , - 2 ] , [ 3 , 2 ] , [ 3 , 3 ] , [ 2 , 3 ] , [ 1 , 3 ] , [ 0 , 3 ] , [ - 1 , 2 ] , [ - 3 , - 2 ] , [ - 3 , - 3 ] ] ;
72900: LD_ADDR_VAR 0 42
72904: PUSH
72905: LD_INT 0
72907: PUSH
72908: LD_INT 0
72910: PUSH
72911: EMPTY
72912: LIST
72913: LIST
72914: PUSH
72915: LD_INT 0
72917: PUSH
72918: LD_INT 1
72920: NEG
72921: PUSH
72922: EMPTY
72923: LIST
72924: LIST
72925: PUSH
72926: LD_INT 1
72928: PUSH
72929: LD_INT 0
72931: PUSH
72932: EMPTY
72933: LIST
72934: LIST
72935: PUSH
72936: LD_INT 1
72938: PUSH
72939: LD_INT 1
72941: PUSH
72942: EMPTY
72943: LIST
72944: LIST
72945: PUSH
72946: LD_INT 0
72948: PUSH
72949: LD_INT 1
72951: PUSH
72952: EMPTY
72953: LIST
72954: LIST
72955: PUSH
72956: LD_INT 1
72958: NEG
72959: PUSH
72960: LD_INT 0
72962: PUSH
72963: EMPTY
72964: LIST
72965: LIST
72966: PUSH
72967: LD_INT 1
72969: NEG
72970: PUSH
72971: LD_INT 1
72973: NEG
72974: PUSH
72975: EMPTY
72976: LIST
72977: LIST
72978: PUSH
72979: LD_INT 1
72981: NEG
72982: PUSH
72983: LD_INT 2
72985: NEG
72986: PUSH
72987: EMPTY
72988: LIST
72989: LIST
72990: PUSH
72991: LD_INT 0
72993: PUSH
72994: LD_INT 2
72996: NEG
72997: PUSH
72998: EMPTY
72999: LIST
73000: LIST
73001: PUSH
73002: LD_INT 1
73004: PUSH
73005: LD_INT 1
73007: NEG
73008: PUSH
73009: EMPTY
73010: LIST
73011: LIST
73012: PUSH
73013: LD_INT 2
73015: PUSH
73016: LD_INT 1
73018: PUSH
73019: EMPTY
73020: LIST
73021: LIST
73022: PUSH
73023: LD_INT 2
73025: PUSH
73026: LD_INT 2
73028: PUSH
73029: EMPTY
73030: LIST
73031: LIST
73032: PUSH
73033: LD_INT 1
73035: PUSH
73036: LD_INT 2
73038: PUSH
73039: EMPTY
73040: LIST
73041: LIST
73042: PUSH
73043: LD_INT 0
73045: PUSH
73046: LD_INT 2
73048: PUSH
73049: EMPTY
73050: LIST
73051: LIST
73052: PUSH
73053: LD_INT 1
73055: NEG
73056: PUSH
73057: LD_INT 1
73059: PUSH
73060: EMPTY
73061: LIST
73062: LIST
73063: PUSH
73064: LD_INT 2
73066: NEG
73067: PUSH
73068: LD_INT 1
73070: NEG
73071: PUSH
73072: EMPTY
73073: LIST
73074: LIST
73075: PUSH
73076: LD_INT 2
73078: NEG
73079: PUSH
73080: LD_INT 2
73082: NEG
73083: PUSH
73084: EMPTY
73085: LIST
73086: LIST
73087: PUSH
73088: LD_INT 2
73090: NEG
73091: PUSH
73092: LD_INT 3
73094: NEG
73095: PUSH
73096: EMPTY
73097: LIST
73098: LIST
73099: PUSH
73100: LD_INT 1
73102: NEG
73103: PUSH
73104: LD_INT 3
73106: NEG
73107: PUSH
73108: EMPTY
73109: LIST
73110: LIST
73111: PUSH
73112: LD_INT 0
73114: PUSH
73115: LD_INT 3
73117: NEG
73118: PUSH
73119: EMPTY
73120: LIST
73121: LIST
73122: PUSH
73123: LD_INT 1
73125: PUSH
73126: LD_INT 2
73128: NEG
73129: PUSH
73130: EMPTY
73131: LIST
73132: LIST
73133: PUSH
73134: LD_INT 3
73136: PUSH
73137: LD_INT 2
73139: PUSH
73140: EMPTY
73141: LIST
73142: LIST
73143: PUSH
73144: LD_INT 3
73146: PUSH
73147: LD_INT 3
73149: PUSH
73150: EMPTY
73151: LIST
73152: LIST
73153: PUSH
73154: LD_INT 2
73156: PUSH
73157: LD_INT 3
73159: PUSH
73160: EMPTY
73161: LIST
73162: LIST
73163: PUSH
73164: LD_INT 1
73166: PUSH
73167: LD_INT 3
73169: PUSH
73170: EMPTY
73171: LIST
73172: LIST
73173: PUSH
73174: LD_INT 0
73176: PUSH
73177: LD_INT 3
73179: PUSH
73180: EMPTY
73181: LIST
73182: LIST
73183: PUSH
73184: LD_INT 1
73186: NEG
73187: PUSH
73188: LD_INT 2
73190: PUSH
73191: EMPTY
73192: LIST
73193: LIST
73194: PUSH
73195: LD_INT 3
73197: NEG
73198: PUSH
73199: LD_INT 2
73201: NEG
73202: PUSH
73203: EMPTY
73204: LIST
73205: LIST
73206: PUSH
73207: LD_INT 3
73209: NEG
73210: PUSH
73211: LD_INT 3
73213: NEG
73214: PUSH
73215: EMPTY
73216: LIST
73217: LIST
73218: PUSH
73219: EMPTY
73220: LIST
73221: LIST
73222: LIST
73223: LIST
73224: LIST
73225: LIST
73226: LIST
73227: LIST
73228: LIST
73229: LIST
73230: LIST
73231: LIST
73232: LIST
73233: LIST
73234: LIST
73235: LIST
73236: LIST
73237: LIST
73238: LIST
73239: LIST
73240: LIST
73241: LIST
73242: LIST
73243: LIST
73244: LIST
73245: LIST
73246: LIST
73247: LIST
73248: LIST
73249: ST_TO_ADDR
// Lab2 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 1 , - 3 ] , [ 0 , - 3 ] , [ 1 , - 2 ] , [ 2 , - 1 ] , [ 3 , 0 ] , [ 3 , 1 ] , [ 1 , 3 ] , [ 0 , 3 ] , [ - 1 , 2 ] , [ - 2 , 1 ] , [ - 3 , 0 ] , [ - 3 , - 1 ] ] ;
73250: LD_ADDR_VAR 0 43
73254: PUSH
73255: LD_INT 0
73257: PUSH
73258: LD_INT 0
73260: PUSH
73261: EMPTY
73262: LIST
73263: LIST
73264: PUSH
73265: LD_INT 0
73267: PUSH
73268: LD_INT 1
73270: NEG
73271: PUSH
73272: EMPTY
73273: LIST
73274: LIST
73275: PUSH
73276: LD_INT 1
73278: PUSH
73279: LD_INT 0
73281: PUSH
73282: EMPTY
73283: LIST
73284: LIST
73285: PUSH
73286: LD_INT 1
73288: PUSH
73289: LD_INT 1
73291: PUSH
73292: EMPTY
73293: LIST
73294: LIST
73295: PUSH
73296: LD_INT 0
73298: PUSH
73299: LD_INT 1
73301: PUSH
73302: EMPTY
73303: LIST
73304: LIST
73305: PUSH
73306: LD_INT 1
73308: NEG
73309: PUSH
73310: LD_INT 0
73312: PUSH
73313: EMPTY
73314: LIST
73315: LIST
73316: PUSH
73317: LD_INT 1
73319: NEG
73320: PUSH
73321: LD_INT 1
73323: NEG
73324: PUSH
73325: EMPTY
73326: LIST
73327: LIST
73328: PUSH
73329: LD_INT 1
73331: NEG
73332: PUSH
73333: LD_INT 2
73335: NEG
73336: PUSH
73337: EMPTY
73338: LIST
73339: LIST
73340: PUSH
73341: LD_INT 0
73343: PUSH
73344: LD_INT 2
73346: NEG
73347: PUSH
73348: EMPTY
73349: LIST
73350: LIST
73351: PUSH
73352: LD_INT 1
73354: PUSH
73355: LD_INT 1
73357: NEG
73358: PUSH
73359: EMPTY
73360: LIST
73361: LIST
73362: PUSH
73363: LD_INT 2
73365: PUSH
73366: LD_INT 0
73368: PUSH
73369: EMPTY
73370: LIST
73371: LIST
73372: PUSH
73373: LD_INT 2
73375: PUSH
73376: LD_INT 1
73378: PUSH
73379: EMPTY
73380: LIST
73381: LIST
73382: PUSH
73383: LD_INT 1
73385: PUSH
73386: LD_INT 2
73388: PUSH
73389: EMPTY
73390: LIST
73391: LIST
73392: PUSH
73393: LD_INT 0
73395: PUSH
73396: LD_INT 2
73398: PUSH
73399: EMPTY
73400: LIST
73401: LIST
73402: PUSH
73403: LD_INT 1
73405: NEG
73406: PUSH
73407: LD_INT 1
73409: PUSH
73410: EMPTY
73411: LIST
73412: LIST
73413: PUSH
73414: LD_INT 2
73416: NEG
73417: PUSH
73418: LD_INT 0
73420: PUSH
73421: EMPTY
73422: LIST
73423: LIST
73424: PUSH
73425: LD_INT 2
73427: NEG
73428: PUSH
73429: LD_INT 1
73431: NEG
73432: PUSH
73433: EMPTY
73434: LIST
73435: LIST
73436: PUSH
73437: LD_INT 1
73439: NEG
73440: PUSH
73441: LD_INT 3
73443: NEG
73444: PUSH
73445: EMPTY
73446: LIST
73447: LIST
73448: PUSH
73449: LD_INT 0
73451: PUSH
73452: LD_INT 3
73454: NEG
73455: PUSH
73456: EMPTY
73457: LIST
73458: LIST
73459: PUSH
73460: LD_INT 1
73462: PUSH
73463: LD_INT 2
73465: NEG
73466: PUSH
73467: EMPTY
73468: LIST
73469: LIST
73470: PUSH
73471: LD_INT 2
73473: PUSH
73474: LD_INT 1
73476: NEG
73477: PUSH
73478: EMPTY
73479: LIST
73480: LIST
73481: PUSH
73482: LD_INT 3
73484: PUSH
73485: LD_INT 0
73487: PUSH
73488: EMPTY
73489: LIST
73490: LIST
73491: PUSH
73492: LD_INT 3
73494: PUSH
73495: LD_INT 1
73497: PUSH
73498: EMPTY
73499: LIST
73500: LIST
73501: PUSH
73502: LD_INT 1
73504: PUSH
73505: LD_INT 3
73507: PUSH
73508: EMPTY
73509: LIST
73510: LIST
73511: PUSH
73512: LD_INT 0
73514: PUSH
73515: LD_INT 3
73517: PUSH
73518: EMPTY
73519: LIST
73520: LIST
73521: PUSH
73522: LD_INT 1
73524: NEG
73525: PUSH
73526: LD_INT 2
73528: PUSH
73529: EMPTY
73530: LIST
73531: LIST
73532: PUSH
73533: LD_INT 2
73535: NEG
73536: PUSH
73537: LD_INT 1
73539: PUSH
73540: EMPTY
73541: LIST
73542: LIST
73543: PUSH
73544: LD_INT 3
73546: NEG
73547: PUSH
73548: LD_INT 0
73550: PUSH
73551: EMPTY
73552: LIST
73553: LIST
73554: PUSH
73555: LD_INT 3
73557: NEG
73558: PUSH
73559: LD_INT 1
73561: NEG
73562: PUSH
73563: EMPTY
73564: LIST
73565: LIST
73566: PUSH
73567: EMPTY
73568: LIST
73569: LIST
73570: LIST
73571: LIST
73572: LIST
73573: LIST
73574: LIST
73575: LIST
73576: LIST
73577: LIST
73578: LIST
73579: LIST
73580: LIST
73581: LIST
73582: LIST
73583: LIST
73584: LIST
73585: LIST
73586: LIST
73587: LIST
73588: LIST
73589: LIST
73590: LIST
73591: LIST
73592: LIST
73593: LIST
73594: LIST
73595: LIST
73596: LIST
73597: ST_TO_ADDR
// Lab3 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ - 2 , - 3 ] , [ 2 , - 1 ] , [ 3 , 0 ] , [ 3 , 1 ] , [ 3 , 2 ] , [ 3 , 3 ] , [ 2 , 3 ] , [ - 2 , 1 ] , [ - 3 , 0 ] , [ - 3 , - 1 ] , [ - 3 , - 2 ] , [ - 3 , - 3 ] ] ;
73598: LD_ADDR_VAR 0 44
73602: PUSH
73603: LD_INT 0
73605: PUSH
73606: LD_INT 0
73608: PUSH
73609: EMPTY
73610: LIST
73611: LIST
73612: PUSH
73613: LD_INT 0
73615: PUSH
73616: LD_INT 1
73618: NEG
73619: PUSH
73620: EMPTY
73621: LIST
73622: LIST
73623: PUSH
73624: LD_INT 1
73626: PUSH
73627: LD_INT 0
73629: PUSH
73630: EMPTY
73631: LIST
73632: LIST
73633: PUSH
73634: LD_INT 1
73636: PUSH
73637: LD_INT 1
73639: PUSH
73640: EMPTY
73641: LIST
73642: LIST
73643: PUSH
73644: LD_INT 0
73646: PUSH
73647: LD_INT 1
73649: PUSH
73650: EMPTY
73651: LIST
73652: LIST
73653: PUSH
73654: LD_INT 1
73656: NEG
73657: PUSH
73658: LD_INT 0
73660: PUSH
73661: EMPTY
73662: LIST
73663: LIST
73664: PUSH
73665: LD_INT 1
73667: NEG
73668: PUSH
73669: LD_INT 1
73671: NEG
73672: PUSH
73673: EMPTY
73674: LIST
73675: LIST
73676: PUSH
73677: LD_INT 1
73679: NEG
73680: PUSH
73681: LD_INT 2
73683: NEG
73684: PUSH
73685: EMPTY
73686: LIST
73687: LIST
73688: PUSH
73689: LD_INT 1
73691: PUSH
73692: LD_INT 1
73694: NEG
73695: PUSH
73696: EMPTY
73697: LIST
73698: LIST
73699: PUSH
73700: LD_INT 2
73702: PUSH
73703: LD_INT 0
73705: PUSH
73706: EMPTY
73707: LIST
73708: LIST
73709: PUSH
73710: LD_INT 2
73712: PUSH
73713: LD_INT 1
73715: PUSH
73716: EMPTY
73717: LIST
73718: LIST
73719: PUSH
73720: LD_INT 2
73722: PUSH
73723: LD_INT 2
73725: PUSH
73726: EMPTY
73727: LIST
73728: LIST
73729: PUSH
73730: LD_INT 1
73732: PUSH
73733: LD_INT 2
73735: PUSH
73736: EMPTY
73737: LIST
73738: LIST
73739: PUSH
73740: LD_INT 1
73742: NEG
73743: PUSH
73744: LD_INT 1
73746: PUSH
73747: EMPTY
73748: LIST
73749: LIST
73750: PUSH
73751: LD_INT 2
73753: NEG
73754: PUSH
73755: LD_INT 0
73757: PUSH
73758: EMPTY
73759: LIST
73760: LIST
73761: PUSH
73762: LD_INT 2
73764: NEG
73765: PUSH
73766: LD_INT 1
73768: NEG
73769: PUSH
73770: EMPTY
73771: LIST
73772: LIST
73773: PUSH
73774: LD_INT 2
73776: NEG
73777: PUSH
73778: LD_INT 2
73780: NEG
73781: PUSH
73782: EMPTY
73783: LIST
73784: LIST
73785: PUSH
73786: LD_INT 2
73788: NEG
73789: PUSH
73790: LD_INT 3
73792: NEG
73793: PUSH
73794: EMPTY
73795: LIST
73796: LIST
73797: PUSH
73798: LD_INT 2
73800: PUSH
73801: LD_INT 1
73803: NEG
73804: PUSH
73805: EMPTY
73806: LIST
73807: LIST
73808: PUSH
73809: LD_INT 3
73811: PUSH
73812: LD_INT 0
73814: PUSH
73815: EMPTY
73816: LIST
73817: LIST
73818: PUSH
73819: LD_INT 3
73821: PUSH
73822: LD_INT 1
73824: PUSH
73825: EMPTY
73826: LIST
73827: LIST
73828: PUSH
73829: LD_INT 3
73831: PUSH
73832: LD_INT 2
73834: PUSH
73835: EMPTY
73836: LIST
73837: LIST
73838: PUSH
73839: LD_INT 3
73841: PUSH
73842: LD_INT 3
73844: PUSH
73845: EMPTY
73846: LIST
73847: LIST
73848: PUSH
73849: LD_INT 2
73851: PUSH
73852: LD_INT 3
73854: PUSH
73855: EMPTY
73856: LIST
73857: LIST
73858: PUSH
73859: LD_INT 2
73861: NEG
73862: PUSH
73863: LD_INT 1
73865: PUSH
73866: EMPTY
73867: LIST
73868: LIST
73869: PUSH
73870: LD_INT 3
73872: NEG
73873: PUSH
73874: LD_INT 0
73876: PUSH
73877: EMPTY
73878: LIST
73879: LIST
73880: PUSH
73881: LD_INT 3
73883: NEG
73884: PUSH
73885: LD_INT 1
73887: NEG
73888: PUSH
73889: EMPTY
73890: LIST
73891: LIST
73892: PUSH
73893: LD_INT 3
73895: NEG
73896: PUSH
73897: LD_INT 2
73899: NEG
73900: PUSH
73901: EMPTY
73902: LIST
73903: LIST
73904: PUSH
73905: LD_INT 3
73907: NEG
73908: PUSH
73909: LD_INT 3
73911: NEG
73912: PUSH
73913: EMPTY
73914: LIST
73915: LIST
73916: PUSH
73917: EMPTY
73918: LIST
73919: LIST
73920: LIST
73921: LIST
73922: LIST
73923: LIST
73924: LIST
73925: LIST
73926: LIST
73927: LIST
73928: LIST
73929: LIST
73930: LIST
73931: LIST
73932: LIST
73933: LIST
73934: LIST
73935: LIST
73936: LIST
73937: LIST
73938: LIST
73939: LIST
73940: LIST
73941: LIST
73942: LIST
73943: LIST
73944: LIST
73945: LIST
73946: LIST
73947: ST_TO_ADDR
// Lab4 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ - 2 , - 3 ] , [ - 1 , - 3 ] , [ 0 , - 3 ] , [ 1 , - 2 ] , [ 3 , 2 ] , [ 3 , 3 ] , [ 2 , 3 ] , [ 1 , 3 ] , [ 0 , 3 ] , [ - 1 , 2 ] , [ - 3 , - 2 ] , [ - 3 , - 3 ] ] ;
73948: LD_ADDR_VAR 0 45
73952: PUSH
73953: LD_INT 0
73955: PUSH
73956: LD_INT 0
73958: PUSH
73959: EMPTY
73960: LIST
73961: LIST
73962: PUSH
73963: LD_INT 0
73965: PUSH
73966: LD_INT 1
73968: NEG
73969: PUSH
73970: EMPTY
73971: LIST
73972: LIST
73973: PUSH
73974: LD_INT 1
73976: PUSH
73977: LD_INT 0
73979: PUSH
73980: EMPTY
73981: LIST
73982: LIST
73983: PUSH
73984: LD_INT 1
73986: PUSH
73987: LD_INT 1
73989: PUSH
73990: EMPTY
73991: LIST
73992: LIST
73993: PUSH
73994: LD_INT 0
73996: PUSH
73997: LD_INT 1
73999: PUSH
74000: EMPTY
74001: LIST
74002: LIST
74003: PUSH
74004: LD_INT 1
74006: NEG
74007: PUSH
74008: LD_INT 0
74010: PUSH
74011: EMPTY
74012: LIST
74013: LIST
74014: PUSH
74015: LD_INT 1
74017: NEG
74018: PUSH
74019: LD_INT 1
74021: NEG
74022: PUSH
74023: EMPTY
74024: LIST
74025: LIST
74026: PUSH
74027: LD_INT 1
74029: NEG
74030: PUSH
74031: LD_INT 2
74033: NEG
74034: PUSH
74035: EMPTY
74036: LIST
74037: LIST
74038: PUSH
74039: LD_INT 0
74041: PUSH
74042: LD_INT 2
74044: NEG
74045: PUSH
74046: EMPTY
74047: LIST
74048: LIST
74049: PUSH
74050: LD_INT 1
74052: PUSH
74053: LD_INT 1
74055: NEG
74056: PUSH
74057: EMPTY
74058: LIST
74059: LIST
74060: PUSH
74061: LD_INT 2
74063: PUSH
74064: LD_INT 1
74066: PUSH
74067: EMPTY
74068: LIST
74069: LIST
74070: PUSH
74071: LD_INT 2
74073: PUSH
74074: LD_INT 2
74076: PUSH
74077: EMPTY
74078: LIST
74079: LIST
74080: PUSH
74081: LD_INT 1
74083: PUSH
74084: LD_INT 2
74086: PUSH
74087: EMPTY
74088: LIST
74089: LIST
74090: PUSH
74091: LD_INT 0
74093: PUSH
74094: LD_INT 2
74096: PUSH
74097: EMPTY
74098: LIST
74099: LIST
74100: PUSH
74101: LD_INT 1
74103: NEG
74104: PUSH
74105: LD_INT 1
74107: PUSH
74108: EMPTY
74109: LIST
74110: LIST
74111: PUSH
74112: LD_INT 2
74114: NEG
74115: PUSH
74116: LD_INT 1
74118: NEG
74119: PUSH
74120: EMPTY
74121: LIST
74122: LIST
74123: PUSH
74124: LD_INT 2
74126: NEG
74127: PUSH
74128: LD_INT 2
74130: NEG
74131: PUSH
74132: EMPTY
74133: LIST
74134: LIST
74135: PUSH
74136: LD_INT 2
74138: NEG
74139: PUSH
74140: LD_INT 3
74142: NEG
74143: PUSH
74144: EMPTY
74145: LIST
74146: LIST
74147: PUSH
74148: LD_INT 1
74150: NEG
74151: PUSH
74152: LD_INT 3
74154: NEG
74155: PUSH
74156: EMPTY
74157: LIST
74158: LIST
74159: PUSH
74160: LD_INT 0
74162: PUSH
74163: LD_INT 3
74165: NEG
74166: PUSH
74167: EMPTY
74168: LIST
74169: LIST
74170: PUSH
74171: LD_INT 1
74173: PUSH
74174: LD_INT 2
74176: NEG
74177: PUSH
74178: EMPTY
74179: LIST
74180: LIST
74181: PUSH
74182: LD_INT 3
74184: PUSH
74185: LD_INT 2
74187: PUSH
74188: EMPTY
74189: LIST
74190: LIST
74191: PUSH
74192: LD_INT 3
74194: PUSH
74195: LD_INT 3
74197: PUSH
74198: EMPTY
74199: LIST
74200: LIST
74201: PUSH
74202: LD_INT 2
74204: PUSH
74205: LD_INT 3
74207: PUSH
74208: EMPTY
74209: LIST
74210: LIST
74211: PUSH
74212: LD_INT 1
74214: PUSH
74215: LD_INT 3
74217: PUSH
74218: EMPTY
74219: LIST
74220: LIST
74221: PUSH
74222: LD_INT 0
74224: PUSH
74225: LD_INT 3
74227: PUSH
74228: EMPTY
74229: LIST
74230: LIST
74231: PUSH
74232: LD_INT 1
74234: NEG
74235: PUSH
74236: LD_INT 2
74238: PUSH
74239: EMPTY
74240: LIST
74241: LIST
74242: PUSH
74243: LD_INT 3
74245: NEG
74246: PUSH
74247: LD_INT 2
74249: NEG
74250: PUSH
74251: EMPTY
74252: LIST
74253: LIST
74254: PUSH
74255: LD_INT 3
74257: NEG
74258: PUSH
74259: LD_INT 3
74261: NEG
74262: PUSH
74263: EMPTY
74264: LIST
74265: LIST
74266: PUSH
74267: EMPTY
74268: LIST
74269: LIST
74270: LIST
74271: LIST
74272: LIST
74273: LIST
74274: LIST
74275: LIST
74276: LIST
74277: LIST
74278: LIST
74279: LIST
74280: LIST
74281: LIST
74282: LIST
74283: LIST
74284: LIST
74285: LIST
74286: LIST
74287: LIST
74288: LIST
74289: LIST
74290: LIST
74291: LIST
74292: LIST
74293: LIST
74294: LIST
74295: LIST
74296: LIST
74297: ST_TO_ADDR
// Lab5 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 1 , - 3 ] , [ 0 , - 3 ] , [ 1 , - 2 ] , [ 2 , - 1 ] , [ 3 , 0 ] , [ 3 , 1 ] , [ 1 , 3 ] , [ 0 , 3 ] , [ - 1 , 2 ] , [ - 2 , 1 ] , [ - 3 , 0 ] , [ - 3 , - 1 ] ] ;
74298: LD_ADDR_VAR 0 46
74302: PUSH
74303: LD_INT 0
74305: PUSH
74306: LD_INT 0
74308: PUSH
74309: EMPTY
74310: LIST
74311: LIST
74312: PUSH
74313: LD_INT 0
74315: PUSH
74316: LD_INT 1
74318: NEG
74319: PUSH
74320: EMPTY
74321: LIST
74322: LIST
74323: PUSH
74324: LD_INT 1
74326: PUSH
74327: LD_INT 0
74329: PUSH
74330: EMPTY
74331: LIST
74332: LIST
74333: PUSH
74334: LD_INT 1
74336: PUSH
74337: LD_INT 1
74339: PUSH
74340: EMPTY
74341: LIST
74342: LIST
74343: PUSH
74344: LD_INT 0
74346: PUSH
74347: LD_INT 1
74349: PUSH
74350: EMPTY
74351: LIST
74352: LIST
74353: PUSH
74354: LD_INT 1
74356: NEG
74357: PUSH
74358: LD_INT 0
74360: PUSH
74361: EMPTY
74362: LIST
74363: LIST
74364: PUSH
74365: LD_INT 1
74367: NEG
74368: PUSH
74369: LD_INT 1
74371: NEG
74372: PUSH
74373: EMPTY
74374: LIST
74375: LIST
74376: PUSH
74377: LD_INT 1
74379: NEG
74380: PUSH
74381: LD_INT 2
74383: NEG
74384: PUSH
74385: EMPTY
74386: LIST
74387: LIST
74388: PUSH
74389: LD_INT 0
74391: PUSH
74392: LD_INT 2
74394: NEG
74395: PUSH
74396: EMPTY
74397: LIST
74398: LIST
74399: PUSH
74400: LD_INT 1
74402: PUSH
74403: LD_INT 1
74405: NEG
74406: PUSH
74407: EMPTY
74408: LIST
74409: LIST
74410: PUSH
74411: LD_INT 2
74413: PUSH
74414: LD_INT 0
74416: PUSH
74417: EMPTY
74418: LIST
74419: LIST
74420: PUSH
74421: LD_INT 2
74423: PUSH
74424: LD_INT 1
74426: PUSH
74427: EMPTY
74428: LIST
74429: LIST
74430: PUSH
74431: LD_INT 1
74433: PUSH
74434: LD_INT 2
74436: PUSH
74437: EMPTY
74438: LIST
74439: LIST
74440: PUSH
74441: LD_INT 0
74443: PUSH
74444: LD_INT 2
74446: PUSH
74447: EMPTY
74448: LIST
74449: LIST
74450: PUSH
74451: LD_INT 1
74453: NEG
74454: PUSH
74455: LD_INT 1
74457: PUSH
74458: EMPTY
74459: LIST
74460: LIST
74461: PUSH
74462: LD_INT 2
74464: NEG
74465: PUSH
74466: LD_INT 0
74468: PUSH
74469: EMPTY
74470: LIST
74471: LIST
74472: PUSH
74473: LD_INT 2
74475: NEG
74476: PUSH
74477: LD_INT 1
74479: NEG
74480: PUSH
74481: EMPTY
74482: LIST
74483: LIST
74484: PUSH
74485: LD_INT 1
74487: NEG
74488: PUSH
74489: LD_INT 3
74491: NEG
74492: PUSH
74493: EMPTY
74494: LIST
74495: LIST
74496: PUSH
74497: LD_INT 0
74499: PUSH
74500: LD_INT 3
74502: NEG
74503: PUSH
74504: EMPTY
74505: LIST
74506: LIST
74507: PUSH
74508: LD_INT 1
74510: PUSH
74511: LD_INT 2
74513: NEG
74514: PUSH
74515: EMPTY
74516: LIST
74517: LIST
74518: PUSH
74519: LD_INT 2
74521: PUSH
74522: LD_INT 1
74524: NEG
74525: PUSH
74526: EMPTY
74527: LIST
74528: LIST
74529: PUSH
74530: LD_INT 3
74532: PUSH
74533: LD_INT 0
74535: PUSH
74536: EMPTY
74537: LIST
74538: LIST
74539: PUSH
74540: LD_INT 3
74542: PUSH
74543: LD_INT 1
74545: PUSH
74546: EMPTY
74547: LIST
74548: LIST
74549: PUSH
74550: LD_INT 1
74552: PUSH
74553: LD_INT 3
74555: PUSH
74556: EMPTY
74557: LIST
74558: LIST
74559: PUSH
74560: LD_INT 0
74562: PUSH
74563: LD_INT 3
74565: PUSH
74566: EMPTY
74567: LIST
74568: LIST
74569: PUSH
74570: LD_INT 1
74572: NEG
74573: PUSH
74574: LD_INT 2
74576: PUSH
74577: EMPTY
74578: LIST
74579: LIST
74580: PUSH
74581: LD_INT 2
74583: NEG
74584: PUSH
74585: LD_INT 1
74587: PUSH
74588: EMPTY
74589: LIST
74590: LIST
74591: PUSH
74592: LD_INT 3
74594: NEG
74595: PUSH
74596: LD_INT 0
74598: PUSH
74599: EMPTY
74600: LIST
74601: LIST
74602: PUSH
74603: LD_INT 3
74605: NEG
74606: PUSH
74607: LD_INT 1
74609: NEG
74610: PUSH
74611: EMPTY
74612: LIST
74613: LIST
74614: PUSH
74615: EMPTY
74616: LIST
74617: LIST
74618: LIST
74619: LIST
74620: LIST
74621: LIST
74622: LIST
74623: LIST
74624: LIST
74625: LIST
74626: LIST
74627: LIST
74628: LIST
74629: LIST
74630: LIST
74631: LIST
74632: LIST
74633: LIST
74634: LIST
74635: LIST
74636: LIST
74637: LIST
74638: LIST
74639: LIST
74640: LIST
74641: LIST
74642: LIST
74643: LIST
74644: LIST
74645: ST_TO_ADDR
// ControlTower0 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
74646: LD_ADDR_VAR 0 47
74650: PUSH
74651: LD_INT 0
74653: PUSH
74654: LD_INT 0
74656: PUSH
74657: EMPTY
74658: LIST
74659: LIST
74660: PUSH
74661: LD_INT 0
74663: PUSH
74664: LD_INT 1
74666: NEG
74667: PUSH
74668: EMPTY
74669: LIST
74670: LIST
74671: PUSH
74672: LD_INT 1
74674: PUSH
74675: LD_INT 0
74677: PUSH
74678: EMPTY
74679: LIST
74680: LIST
74681: PUSH
74682: LD_INT 1
74684: PUSH
74685: LD_INT 1
74687: PUSH
74688: EMPTY
74689: LIST
74690: LIST
74691: PUSH
74692: LD_INT 0
74694: PUSH
74695: LD_INT 1
74697: PUSH
74698: EMPTY
74699: LIST
74700: LIST
74701: PUSH
74702: LD_INT 1
74704: NEG
74705: PUSH
74706: LD_INT 0
74708: PUSH
74709: EMPTY
74710: LIST
74711: LIST
74712: PUSH
74713: LD_INT 1
74715: NEG
74716: PUSH
74717: LD_INT 1
74719: NEG
74720: PUSH
74721: EMPTY
74722: LIST
74723: LIST
74724: PUSH
74725: LD_INT 1
74727: NEG
74728: PUSH
74729: LD_INT 2
74731: NEG
74732: PUSH
74733: EMPTY
74734: LIST
74735: LIST
74736: PUSH
74737: LD_INT 0
74739: PUSH
74740: LD_INT 2
74742: NEG
74743: PUSH
74744: EMPTY
74745: LIST
74746: LIST
74747: PUSH
74748: LD_INT 1
74750: PUSH
74751: LD_INT 1
74753: NEG
74754: PUSH
74755: EMPTY
74756: LIST
74757: LIST
74758: PUSH
74759: LD_INT 2
74761: NEG
74762: PUSH
74763: LD_INT 1
74765: NEG
74766: PUSH
74767: EMPTY
74768: LIST
74769: LIST
74770: PUSH
74771: LD_INT 2
74773: NEG
74774: PUSH
74775: LD_INT 2
74777: NEG
74778: PUSH
74779: EMPTY
74780: LIST
74781: LIST
74782: PUSH
74783: EMPTY
74784: LIST
74785: LIST
74786: LIST
74787: LIST
74788: LIST
74789: LIST
74790: LIST
74791: LIST
74792: LIST
74793: LIST
74794: LIST
74795: LIST
74796: ST_TO_ADDR
// ControlTower1 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] ] ;
74797: LD_ADDR_VAR 0 48
74801: PUSH
74802: LD_INT 0
74804: PUSH
74805: LD_INT 0
74807: PUSH
74808: EMPTY
74809: LIST
74810: LIST
74811: PUSH
74812: LD_INT 0
74814: PUSH
74815: LD_INT 1
74817: NEG
74818: PUSH
74819: EMPTY
74820: LIST
74821: LIST
74822: PUSH
74823: LD_INT 1
74825: PUSH
74826: LD_INT 0
74828: PUSH
74829: EMPTY
74830: LIST
74831: LIST
74832: PUSH
74833: LD_INT 1
74835: PUSH
74836: LD_INT 1
74838: PUSH
74839: EMPTY
74840: LIST
74841: LIST
74842: PUSH
74843: LD_INT 0
74845: PUSH
74846: LD_INT 1
74848: PUSH
74849: EMPTY
74850: LIST
74851: LIST
74852: PUSH
74853: LD_INT 1
74855: NEG
74856: PUSH
74857: LD_INT 0
74859: PUSH
74860: EMPTY
74861: LIST
74862: LIST
74863: PUSH
74864: LD_INT 1
74866: NEG
74867: PUSH
74868: LD_INT 1
74870: NEG
74871: PUSH
74872: EMPTY
74873: LIST
74874: LIST
74875: PUSH
74876: LD_INT 1
74878: NEG
74879: PUSH
74880: LD_INT 2
74882: NEG
74883: PUSH
74884: EMPTY
74885: LIST
74886: LIST
74887: PUSH
74888: LD_INT 0
74890: PUSH
74891: LD_INT 2
74893: NEG
74894: PUSH
74895: EMPTY
74896: LIST
74897: LIST
74898: PUSH
74899: LD_INT 1
74901: PUSH
74902: LD_INT 1
74904: NEG
74905: PUSH
74906: EMPTY
74907: LIST
74908: LIST
74909: PUSH
74910: LD_INT 2
74912: PUSH
74913: LD_INT 0
74915: PUSH
74916: EMPTY
74917: LIST
74918: LIST
74919: PUSH
74920: LD_INT 2
74922: PUSH
74923: LD_INT 1
74925: PUSH
74926: EMPTY
74927: LIST
74928: LIST
74929: PUSH
74930: EMPTY
74931: LIST
74932: LIST
74933: LIST
74934: LIST
74935: LIST
74936: LIST
74937: LIST
74938: LIST
74939: LIST
74940: LIST
74941: LIST
74942: LIST
74943: ST_TO_ADDR
// ControlTower2 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] ] ;
74944: LD_ADDR_VAR 0 49
74948: PUSH
74949: LD_INT 0
74951: PUSH
74952: LD_INT 0
74954: PUSH
74955: EMPTY
74956: LIST
74957: LIST
74958: PUSH
74959: LD_INT 0
74961: PUSH
74962: LD_INT 1
74964: NEG
74965: PUSH
74966: EMPTY
74967: LIST
74968: LIST
74969: PUSH
74970: LD_INT 1
74972: PUSH
74973: LD_INT 0
74975: PUSH
74976: EMPTY
74977: LIST
74978: LIST
74979: PUSH
74980: LD_INT 1
74982: PUSH
74983: LD_INT 1
74985: PUSH
74986: EMPTY
74987: LIST
74988: LIST
74989: PUSH
74990: LD_INT 0
74992: PUSH
74993: LD_INT 1
74995: PUSH
74996: EMPTY
74997: LIST
74998: LIST
74999: PUSH
75000: LD_INT 1
75002: NEG
75003: PUSH
75004: LD_INT 0
75006: PUSH
75007: EMPTY
75008: LIST
75009: LIST
75010: PUSH
75011: LD_INT 1
75013: NEG
75014: PUSH
75015: LD_INT 1
75017: NEG
75018: PUSH
75019: EMPTY
75020: LIST
75021: LIST
75022: PUSH
75023: LD_INT 1
75025: PUSH
75026: LD_INT 1
75028: NEG
75029: PUSH
75030: EMPTY
75031: LIST
75032: LIST
75033: PUSH
75034: LD_INT 2
75036: PUSH
75037: LD_INT 0
75039: PUSH
75040: EMPTY
75041: LIST
75042: LIST
75043: PUSH
75044: LD_INT 2
75046: PUSH
75047: LD_INT 1
75049: PUSH
75050: EMPTY
75051: LIST
75052: LIST
75053: PUSH
75054: LD_INT 2
75056: PUSH
75057: LD_INT 2
75059: PUSH
75060: EMPTY
75061: LIST
75062: LIST
75063: PUSH
75064: LD_INT 1
75066: PUSH
75067: LD_INT 2
75069: PUSH
75070: EMPTY
75071: LIST
75072: LIST
75073: PUSH
75074: EMPTY
75075: LIST
75076: LIST
75077: LIST
75078: LIST
75079: LIST
75080: LIST
75081: LIST
75082: LIST
75083: LIST
75084: LIST
75085: LIST
75086: LIST
75087: ST_TO_ADDR
// ControlTower3 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] ] ;
75088: LD_ADDR_VAR 0 50
75092: PUSH
75093: LD_INT 0
75095: PUSH
75096: LD_INT 0
75098: PUSH
75099: EMPTY
75100: LIST
75101: LIST
75102: PUSH
75103: LD_INT 0
75105: PUSH
75106: LD_INT 1
75108: NEG
75109: PUSH
75110: EMPTY
75111: LIST
75112: LIST
75113: PUSH
75114: LD_INT 1
75116: PUSH
75117: LD_INT 0
75119: PUSH
75120: EMPTY
75121: LIST
75122: LIST
75123: PUSH
75124: LD_INT 1
75126: PUSH
75127: LD_INT 1
75129: PUSH
75130: EMPTY
75131: LIST
75132: LIST
75133: PUSH
75134: LD_INT 0
75136: PUSH
75137: LD_INT 1
75139: PUSH
75140: EMPTY
75141: LIST
75142: LIST
75143: PUSH
75144: LD_INT 1
75146: NEG
75147: PUSH
75148: LD_INT 0
75150: PUSH
75151: EMPTY
75152: LIST
75153: LIST
75154: PUSH
75155: LD_INT 1
75157: NEG
75158: PUSH
75159: LD_INT 1
75161: NEG
75162: PUSH
75163: EMPTY
75164: LIST
75165: LIST
75166: PUSH
75167: LD_INT 2
75169: PUSH
75170: LD_INT 1
75172: PUSH
75173: EMPTY
75174: LIST
75175: LIST
75176: PUSH
75177: LD_INT 2
75179: PUSH
75180: LD_INT 2
75182: PUSH
75183: EMPTY
75184: LIST
75185: LIST
75186: PUSH
75187: LD_INT 1
75189: PUSH
75190: LD_INT 2
75192: PUSH
75193: EMPTY
75194: LIST
75195: LIST
75196: PUSH
75197: LD_INT 0
75199: PUSH
75200: LD_INT 2
75202: PUSH
75203: EMPTY
75204: LIST
75205: LIST
75206: PUSH
75207: LD_INT 1
75209: NEG
75210: PUSH
75211: LD_INT 1
75213: PUSH
75214: EMPTY
75215: LIST
75216: LIST
75217: PUSH
75218: EMPTY
75219: LIST
75220: LIST
75221: LIST
75222: LIST
75223: LIST
75224: LIST
75225: LIST
75226: LIST
75227: LIST
75228: LIST
75229: LIST
75230: LIST
75231: ST_TO_ADDR
// ControlTower4 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] ] ;
75232: LD_ADDR_VAR 0 51
75236: PUSH
75237: LD_INT 0
75239: PUSH
75240: LD_INT 0
75242: PUSH
75243: EMPTY
75244: LIST
75245: LIST
75246: PUSH
75247: LD_INT 0
75249: PUSH
75250: LD_INT 1
75252: NEG
75253: PUSH
75254: EMPTY
75255: LIST
75256: LIST
75257: PUSH
75258: LD_INT 1
75260: PUSH
75261: LD_INT 0
75263: PUSH
75264: EMPTY
75265: LIST
75266: LIST
75267: PUSH
75268: LD_INT 1
75270: PUSH
75271: LD_INT 1
75273: PUSH
75274: EMPTY
75275: LIST
75276: LIST
75277: PUSH
75278: LD_INT 0
75280: PUSH
75281: LD_INT 1
75283: PUSH
75284: EMPTY
75285: LIST
75286: LIST
75287: PUSH
75288: LD_INT 1
75290: NEG
75291: PUSH
75292: LD_INT 0
75294: PUSH
75295: EMPTY
75296: LIST
75297: LIST
75298: PUSH
75299: LD_INT 1
75301: NEG
75302: PUSH
75303: LD_INT 1
75305: NEG
75306: PUSH
75307: EMPTY
75308: LIST
75309: LIST
75310: PUSH
75311: LD_INT 1
75313: PUSH
75314: LD_INT 2
75316: PUSH
75317: EMPTY
75318: LIST
75319: LIST
75320: PUSH
75321: LD_INT 0
75323: PUSH
75324: LD_INT 2
75326: PUSH
75327: EMPTY
75328: LIST
75329: LIST
75330: PUSH
75331: LD_INT 1
75333: NEG
75334: PUSH
75335: LD_INT 1
75337: PUSH
75338: EMPTY
75339: LIST
75340: LIST
75341: PUSH
75342: LD_INT 2
75344: NEG
75345: PUSH
75346: LD_INT 0
75348: PUSH
75349: EMPTY
75350: LIST
75351: LIST
75352: PUSH
75353: LD_INT 2
75355: NEG
75356: PUSH
75357: LD_INT 1
75359: NEG
75360: PUSH
75361: EMPTY
75362: LIST
75363: LIST
75364: PUSH
75365: EMPTY
75366: LIST
75367: LIST
75368: LIST
75369: LIST
75370: LIST
75371: LIST
75372: LIST
75373: LIST
75374: LIST
75375: LIST
75376: LIST
75377: LIST
75378: ST_TO_ADDR
// ControlTower5 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
75379: LD_ADDR_VAR 0 52
75383: PUSH
75384: LD_INT 0
75386: PUSH
75387: LD_INT 0
75389: PUSH
75390: EMPTY
75391: LIST
75392: LIST
75393: PUSH
75394: LD_INT 0
75396: PUSH
75397: LD_INT 1
75399: NEG
75400: PUSH
75401: EMPTY
75402: LIST
75403: LIST
75404: PUSH
75405: LD_INT 1
75407: PUSH
75408: LD_INT 0
75410: PUSH
75411: EMPTY
75412: LIST
75413: LIST
75414: PUSH
75415: LD_INT 1
75417: PUSH
75418: LD_INT 1
75420: PUSH
75421: EMPTY
75422: LIST
75423: LIST
75424: PUSH
75425: LD_INT 0
75427: PUSH
75428: LD_INT 1
75430: PUSH
75431: EMPTY
75432: LIST
75433: LIST
75434: PUSH
75435: LD_INT 1
75437: NEG
75438: PUSH
75439: LD_INT 0
75441: PUSH
75442: EMPTY
75443: LIST
75444: LIST
75445: PUSH
75446: LD_INT 1
75448: NEG
75449: PUSH
75450: LD_INT 1
75452: NEG
75453: PUSH
75454: EMPTY
75455: LIST
75456: LIST
75457: PUSH
75458: LD_INT 1
75460: NEG
75461: PUSH
75462: LD_INT 2
75464: NEG
75465: PUSH
75466: EMPTY
75467: LIST
75468: LIST
75469: PUSH
75470: LD_INT 1
75472: NEG
75473: PUSH
75474: LD_INT 1
75476: PUSH
75477: EMPTY
75478: LIST
75479: LIST
75480: PUSH
75481: LD_INT 2
75483: NEG
75484: PUSH
75485: LD_INT 0
75487: PUSH
75488: EMPTY
75489: LIST
75490: LIST
75491: PUSH
75492: LD_INT 2
75494: NEG
75495: PUSH
75496: LD_INT 1
75498: NEG
75499: PUSH
75500: EMPTY
75501: LIST
75502: LIST
75503: PUSH
75504: LD_INT 2
75506: NEG
75507: PUSH
75508: LD_INT 2
75510: NEG
75511: PUSH
75512: EMPTY
75513: LIST
75514: LIST
75515: PUSH
75516: EMPTY
75517: LIST
75518: LIST
75519: LIST
75520: LIST
75521: LIST
75522: LIST
75523: LIST
75524: LIST
75525: LIST
75526: LIST
75527: LIST
75528: LIST
75529: ST_TO_ADDR
// Barracks0 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
75530: LD_ADDR_VAR 0 53
75534: PUSH
75535: LD_INT 0
75537: PUSH
75538: LD_INT 0
75540: PUSH
75541: EMPTY
75542: LIST
75543: LIST
75544: PUSH
75545: LD_INT 0
75547: PUSH
75548: LD_INT 1
75550: NEG
75551: PUSH
75552: EMPTY
75553: LIST
75554: LIST
75555: PUSH
75556: LD_INT 1
75558: PUSH
75559: LD_INT 0
75561: PUSH
75562: EMPTY
75563: LIST
75564: LIST
75565: PUSH
75566: LD_INT 1
75568: PUSH
75569: LD_INT 1
75571: PUSH
75572: EMPTY
75573: LIST
75574: LIST
75575: PUSH
75576: LD_INT 0
75578: PUSH
75579: LD_INT 1
75581: PUSH
75582: EMPTY
75583: LIST
75584: LIST
75585: PUSH
75586: LD_INT 1
75588: NEG
75589: PUSH
75590: LD_INT 0
75592: PUSH
75593: EMPTY
75594: LIST
75595: LIST
75596: PUSH
75597: LD_INT 1
75599: NEG
75600: PUSH
75601: LD_INT 1
75603: NEG
75604: PUSH
75605: EMPTY
75606: LIST
75607: LIST
75608: PUSH
75609: LD_INT 1
75611: NEG
75612: PUSH
75613: LD_INT 2
75615: NEG
75616: PUSH
75617: EMPTY
75618: LIST
75619: LIST
75620: PUSH
75621: LD_INT 0
75623: PUSH
75624: LD_INT 2
75626: NEG
75627: PUSH
75628: EMPTY
75629: LIST
75630: LIST
75631: PUSH
75632: LD_INT 1
75634: PUSH
75635: LD_INT 1
75637: NEG
75638: PUSH
75639: EMPTY
75640: LIST
75641: LIST
75642: PUSH
75643: LD_INT 2
75645: PUSH
75646: LD_INT 0
75648: PUSH
75649: EMPTY
75650: LIST
75651: LIST
75652: PUSH
75653: LD_INT 2
75655: PUSH
75656: LD_INT 1
75658: PUSH
75659: EMPTY
75660: LIST
75661: LIST
75662: PUSH
75663: LD_INT 2
75665: PUSH
75666: LD_INT 2
75668: PUSH
75669: EMPTY
75670: LIST
75671: LIST
75672: PUSH
75673: LD_INT 1
75675: PUSH
75676: LD_INT 2
75678: PUSH
75679: EMPTY
75680: LIST
75681: LIST
75682: PUSH
75683: LD_INT 0
75685: PUSH
75686: LD_INT 2
75688: PUSH
75689: EMPTY
75690: LIST
75691: LIST
75692: PUSH
75693: LD_INT 1
75695: NEG
75696: PUSH
75697: LD_INT 1
75699: PUSH
75700: EMPTY
75701: LIST
75702: LIST
75703: PUSH
75704: LD_INT 2
75706: NEG
75707: PUSH
75708: LD_INT 0
75710: PUSH
75711: EMPTY
75712: LIST
75713: LIST
75714: PUSH
75715: LD_INT 2
75717: NEG
75718: PUSH
75719: LD_INT 1
75721: NEG
75722: PUSH
75723: EMPTY
75724: LIST
75725: LIST
75726: PUSH
75727: LD_INT 2
75729: NEG
75730: PUSH
75731: LD_INT 2
75733: NEG
75734: PUSH
75735: EMPTY
75736: LIST
75737: LIST
75738: PUSH
75739: EMPTY
75740: LIST
75741: LIST
75742: LIST
75743: LIST
75744: LIST
75745: LIST
75746: LIST
75747: LIST
75748: LIST
75749: LIST
75750: LIST
75751: LIST
75752: LIST
75753: LIST
75754: LIST
75755: LIST
75756: LIST
75757: LIST
75758: LIST
75759: ST_TO_ADDR
// Barracks1 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
75760: LD_ADDR_VAR 0 54
75764: PUSH
75765: LD_INT 0
75767: PUSH
75768: LD_INT 0
75770: PUSH
75771: EMPTY
75772: LIST
75773: LIST
75774: PUSH
75775: LD_INT 0
75777: PUSH
75778: LD_INT 1
75780: NEG
75781: PUSH
75782: EMPTY
75783: LIST
75784: LIST
75785: PUSH
75786: LD_INT 1
75788: PUSH
75789: LD_INT 0
75791: PUSH
75792: EMPTY
75793: LIST
75794: LIST
75795: PUSH
75796: LD_INT 1
75798: PUSH
75799: LD_INT 1
75801: PUSH
75802: EMPTY
75803: LIST
75804: LIST
75805: PUSH
75806: LD_INT 0
75808: PUSH
75809: LD_INT 1
75811: PUSH
75812: EMPTY
75813: LIST
75814: LIST
75815: PUSH
75816: LD_INT 1
75818: NEG
75819: PUSH
75820: LD_INT 0
75822: PUSH
75823: EMPTY
75824: LIST
75825: LIST
75826: PUSH
75827: LD_INT 1
75829: NEG
75830: PUSH
75831: LD_INT 1
75833: NEG
75834: PUSH
75835: EMPTY
75836: LIST
75837: LIST
75838: PUSH
75839: LD_INT 1
75841: NEG
75842: PUSH
75843: LD_INT 2
75845: NEG
75846: PUSH
75847: EMPTY
75848: LIST
75849: LIST
75850: PUSH
75851: LD_INT 0
75853: PUSH
75854: LD_INT 2
75856: NEG
75857: PUSH
75858: EMPTY
75859: LIST
75860: LIST
75861: PUSH
75862: LD_INT 1
75864: PUSH
75865: LD_INT 1
75867: NEG
75868: PUSH
75869: EMPTY
75870: LIST
75871: LIST
75872: PUSH
75873: LD_INT 2
75875: PUSH
75876: LD_INT 0
75878: PUSH
75879: EMPTY
75880: LIST
75881: LIST
75882: PUSH
75883: LD_INT 2
75885: PUSH
75886: LD_INT 1
75888: PUSH
75889: EMPTY
75890: LIST
75891: LIST
75892: PUSH
75893: LD_INT 2
75895: PUSH
75896: LD_INT 2
75898: PUSH
75899: EMPTY
75900: LIST
75901: LIST
75902: PUSH
75903: LD_INT 1
75905: PUSH
75906: LD_INT 2
75908: PUSH
75909: EMPTY
75910: LIST
75911: LIST
75912: PUSH
75913: LD_INT 0
75915: PUSH
75916: LD_INT 2
75918: PUSH
75919: EMPTY
75920: LIST
75921: LIST
75922: PUSH
75923: LD_INT 1
75925: NEG
75926: PUSH
75927: LD_INT 1
75929: PUSH
75930: EMPTY
75931: LIST
75932: LIST
75933: PUSH
75934: LD_INT 2
75936: NEG
75937: PUSH
75938: LD_INT 0
75940: PUSH
75941: EMPTY
75942: LIST
75943: LIST
75944: PUSH
75945: LD_INT 2
75947: NEG
75948: PUSH
75949: LD_INT 1
75951: NEG
75952: PUSH
75953: EMPTY
75954: LIST
75955: LIST
75956: PUSH
75957: LD_INT 2
75959: NEG
75960: PUSH
75961: LD_INT 2
75963: NEG
75964: PUSH
75965: EMPTY
75966: LIST
75967: LIST
75968: PUSH
75969: EMPTY
75970: LIST
75971: LIST
75972: LIST
75973: LIST
75974: LIST
75975: LIST
75976: LIST
75977: LIST
75978: LIST
75979: LIST
75980: LIST
75981: LIST
75982: LIST
75983: LIST
75984: LIST
75985: LIST
75986: LIST
75987: LIST
75988: LIST
75989: ST_TO_ADDR
// Barracks2 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
75990: LD_ADDR_VAR 0 55
75994: PUSH
75995: LD_INT 0
75997: PUSH
75998: LD_INT 0
76000: PUSH
76001: EMPTY
76002: LIST
76003: LIST
76004: PUSH
76005: LD_INT 0
76007: PUSH
76008: LD_INT 1
76010: NEG
76011: PUSH
76012: EMPTY
76013: LIST
76014: LIST
76015: PUSH
76016: LD_INT 1
76018: PUSH
76019: LD_INT 0
76021: PUSH
76022: EMPTY
76023: LIST
76024: LIST
76025: PUSH
76026: LD_INT 1
76028: PUSH
76029: LD_INT 1
76031: PUSH
76032: EMPTY
76033: LIST
76034: LIST
76035: PUSH
76036: LD_INT 0
76038: PUSH
76039: LD_INT 1
76041: PUSH
76042: EMPTY
76043: LIST
76044: LIST
76045: PUSH
76046: LD_INT 1
76048: NEG
76049: PUSH
76050: LD_INT 0
76052: PUSH
76053: EMPTY
76054: LIST
76055: LIST
76056: PUSH
76057: LD_INT 1
76059: NEG
76060: PUSH
76061: LD_INT 1
76063: NEG
76064: PUSH
76065: EMPTY
76066: LIST
76067: LIST
76068: PUSH
76069: LD_INT 1
76071: NEG
76072: PUSH
76073: LD_INT 2
76075: NEG
76076: PUSH
76077: EMPTY
76078: LIST
76079: LIST
76080: PUSH
76081: LD_INT 0
76083: PUSH
76084: LD_INT 2
76086: NEG
76087: PUSH
76088: EMPTY
76089: LIST
76090: LIST
76091: PUSH
76092: LD_INT 1
76094: PUSH
76095: LD_INT 1
76097: NEG
76098: PUSH
76099: EMPTY
76100: LIST
76101: LIST
76102: PUSH
76103: LD_INT 2
76105: PUSH
76106: LD_INT 0
76108: PUSH
76109: EMPTY
76110: LIST
76111: LIST
76112: PUSH
76113: LD_INT 2
76115: PUSH
76116: LD_INT 1
76118: PUSH
76119: EMPTY
76120: LIST
76121: LIST
76122: PUSH
76123: LD_INT 2
76125: PUSH
76126: LD_INT 2
76128: PUSH
76129: EMPTY
76130: LIST
76131: LIST
76132: PUSH
76133: LD_INT 1
76135: PUSH
76136: LD_INT 2
76138: PUSH
76139: EMPTY
76140: LIST
76141: LIST
76142: PUSH
76143: LD_INT 0
76145: PUSH
76146: LD_INT 2
76148: PUSH
76149: EMPTY
76150: LIST
76151: LIST
76152: PUSH
76153: LD_INT 1
76155: NEG
76156: PUSH
76157: LD_INT 1
76159: PUSH
76160: EMPTY
76161: LIST
76162: LIST
76163: PUSH
76164: LD_INT 2
76166: NEG
76167: PUSH
76168: LD_INT 0
76170: PUSH
76171: EMPTY
76172: LIST
76173: LIST
76174: PUSH
76175: LD_INT 2
76177: NEG
76178: PUSH
76179: LD_INT 1
76181: NEG
76182: PUSH
76183: EMPTY
76184: LIST
76185: LIST
76186: PUSH
76187: LD_INT 2
76189: NEG
76190: PUSH
76191: LD_INT 2
76193: NEG
76194: PUSH
76195: EMPTY
76196: LIST
76197: LIST
76198: PUSH
76199: EMPTY
76200: LIST
76201: LIST
76202: LIST
76203: LIST
76204: LIST
76205: LIST
76206: LIST
76207: LIST
76208: LIST
76209: LIST
76210: LIST
76211: LIST
76212: LIST
76213: LIST
76214: LIST
76215: LIST
76216: LIST
76217: LIST
76218: LIST
76219: ST_TO_ADDR
// Barracks3 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
76220: LD_ADDR_VAR 0 56
76224: PUSH
76225: LD_INT 0
76227: PUSH
76228: LD_INT 0
76230: PUSH
76231: EMPTY
76232: LIST
76233: LIST
76234: PUSH
76235: LD_INT 0
76237: PUSH
76238: LD_INT 1
76240: NEG
76241: PUSH
76242: EMPTY
76243: LIST
76244: LIST
76245: PUSH
76246: LD_INT 1
76248: PUSH
76249: LD_INT 0
76251: PUSH
76252: EMPTY
76253: LIST
76254: LIST
76255: PUSH
76256: LD_INT 1
76258: PUSH
76259: LD_INT 1
76261: PUSH
76262: EMPTY
76263: LIST
76264: LIST
76265: PUSH
76266: LD_INT 0
76268: PUSH
76269: LD_INT 1
76271: PUSH
76272: EMPTY
76273: LIST
76274: LIST
76275: PUSH
76276: LD_INT 1
76278: NEG
76279: PUSH
76280: LD_INT 0
76282: PUSH
76283: EMPTY
76284: LIST
76285: LIST
76286: PUSH
76287: LD_INT 1
76289: NEG
76290: PUSH
76291: LD_INT 1
76293: NEG
76294: PUSH
76295: EMPTY
76296: LIST
76297: LIST
76298: PUSH
76299: LD_INT 1
76301: NEG
76302: PUSH
76303: LD_INT 2
76305: NEG
76306: PUSH
76307: EMPTY
76308: LIST
76309: LIST
76310: PUSH
76311: LD_INT 0
76313: PUSH
76314: LD_INT 2
76316: NEG
76317: PUSH
76318: EMPTY
76319: LIST
76320: LIST
76321: PUSH
76322: LD_INT 1
76324: PUSH
76325: LD_INT 1
76327: NEG
76328: PUSH
76329: EMPTY
76330: LIST
76331: LIST
76332: PUSH
76333: LD_INT 2
76335: PUSH
76336: LD_INT 0
76338: PUSH
76339: EMPTY
76340: LIST
76341: LIST
76342: PUSH
76343: LD_INT 2
76345: PUSH
76346: LD_INT 1
76348: PUSH
76349: EMPTY
76350: LIST
76351: LIST
76352: PUSH
76353: LD_INT 2
76355: PUSH
76356: LD_INT 2
76358: PUSH
76359: EMPTY
76360: LIST
76361: LIST
76362: PUSH
76363: LD_INT 1
76365: PUSH
76366: LD_INT 2
76368: PUSH
76369: EMPTY
76370: LIST
76371: LIST
76372: PUSH
76373: LD_INT 0
76375: PUSH
76376: LD_INT 2
76378: PUSH
76379: EMPTY
76380: LIST
76381: LIST
76382: PUSH
76383: LD_INT 1
76385: NEG
76386: PUSH
76387: LD_INT 1
76389: PUSH
76390: EMPTY
76391: LIST
76392: LIST
76393: PUSH
76394: LD_INT 2
76396: NEG
76397: PUSH
76398: LD_INT 0
76400: PUSH
76401: EMPTY
76402: LIST
76403: LIST
76404: PUSH
76405: LD_INT 2
76407: NEG
76408: PUSH
76409: LD_INT 1
76411: NEG
76412: PUSH
76413: EMPTY
76414: LIST
76415: LIST
76416: PUSH
76417: LD_INT 2
76419: NEG
76420: PUSH
76421: LD_INT 2
76423: NEG
76424: PUSH
76425: EMPTY
76426: LIST
76427: LIST
76428: PUSH
76429: EMPTY
76430: LIST
76431: LIST
76432: LIST
76433: LIST
76434: LIST
76435: LIST
76436: LIST
76437: LIST
76438: LIST
76439: LIST
76440: LIST
76441: LIST
76442: LIST
76443: LIST
76444: LIST
76445: LIST
76446: LIST
76447: LIST
76448: LIST
76449: ST_TO_ADDR
// Barracks4 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
76450: LD_ADDR_VAR 0 57
76454: PUSH
76455: LD_INT 0
76457: PUSH
76458: LD_INT 0
76460: PUSH
76461: EMPTY
76462: LIST
76463: LIST
76464: PUSH
76465: LD_INT 0
76467: PUSH
76468: LD_INT 1
76470: NEG
76471: PUSH
76472: EMPTY
76473: LIST
76474: LIST
76475: PUSH
76476: LD_INT 1
76478: PUSH
76479: LD_INT 0
76481: PUSH
76482: EMPTY
76483: LIST
76484: LIST
76485: PUSH
76486: LD_INT 1
76488: PUSH
76489: LD_INT 1
76491: PUSH
76492: EMPTY
76493: LIST
76494: LIST
76495: PUSH
76496: LD_INT 0
76498: PUSH
76499: LD_INT 1
76501: PUSH
76502: EMPTY
76503: LIST
76504: LIST
76505: PUSH
76506: LD_INT 1
76508: NEG
76509: PUSH
76510: LD_INT 0
76512: PUSH
76513: EMPTY
76514: LIST
76515: LIST
76516: PUSH
76517: LD_INT 1
76519: NEG
76520: PUSH
76521: LD_INT 1
76523: NEG
76524: PUSH
76525: EMPTY
76526: LIST
76527: LIST
76528: PUSH
76529: LD_INT 1
76531: NEG
76532: PUSH
76533: LD_INT 2
76535: NEG
76536: PUSH
76537: EMPTY
76538: LIST
76539: LIST
76540: PUSH
76541: LD_INT 0
76543: PUSH
76544: LD_INT 2
76546: NEG
76547: PUSH
76548: EMPTY
76549: LIST
76550: LIST
76551: PUSH
76552: LD_INT 1
76554: PUSH
76555: LD_INT 1
76557: NEG
76558: PUSH
76559: EMPTY
76560: LIST
76561: LIST
76562: PUSH
76563: LD_INT 2
76565: PUSH
76566: LD_INT 0
76568: PUSH
76569: EMPTY
76570: LIST
76571: LIST
76572: PUSH
76573: LD_INT 2
76575: PUSH
76576: LD_INT 1
76578: PUSH
76579: EMPTY
76580: LIST
76581: LIST
76582: PUSH
76583: LD_INT 2
76585: PUSH
76586: LD_INT 2
76588: PUSH
76589: EMPTY
76590: LIST
76591: LIST
76592: PUSH
76593: LD_INT 1
76595: PUSH
76596: LD_INT 2
76598: PUSH
76599: EMPTY
76600: LIST
76601: LIST
76602: PUSH
76603: LD_INT 0
76605: PUSH
76606: LD_INT 2
76608: PUSH
76609: EMPTY
76610: LIST
76611: LIST
76612: PUSH
76613: LD_INT 1
76615: NEG
76616: PUSH
76617: LD_INT 1
76619: PUSH
76620: EMPTY
76621: LIST
76622: LIST
76623: PUSH
76624: LD_INT 2
76626: NEG
76627: PUSH
76628: LD_INT 0
76630: PUSH
76631: EMPTY
76632: LIST
76633: LIST
76634: PUSH
76635: LD_INT 2
76637: NEG
76638: PUSH
76639: LD_INT 1
76641: NEG
76642: PUSH
76643: EMPTY
76644: LIST
76645: LIST
76646: PUSH
76647: LD_INT 2
76649: NEG
76650: PUSH
76651: LD_INT 2
76653: NEG
76654: PUSH
76655: EMPTY
76656: LIST
76657: LIST
76658: PUSH
76659: EMPTY
76660: LIST
76661: LIST
76662: LIST
76663: LIST
76664: LIST
76665: LIST
76666: LIST
76667: LIST
76668: LIST
76669: LIST
76670: LIST
76671: LIST
76672: LIST
76673: LIST
76674: LIST
76675: LIST
76676: LIST
76677: LIST
76678: LIST
76679: ST_TO_ADDR
// Barracks5 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
76680: LD_ADDR_VAR 0 58
76684: PUSH
76685: LD_INT 0
76687: PUSH
76688: LD_INT 0
76690: PUSH
76691: EMPTY
76692: LIST
76693: LIST
76694: PUSH
76695: LD_INT 0
76697: PUSH
76698: LD_INT 1
76700: NEG
76701: PUSH
76702: EMPTY
76703: LIST
76704: LIST
76705: PUSH
76706: LD_INT 1
76708: PUSH
76709: LD_INT 0
76711: PUSH
76712: EMPTY
76713: LIST
76714: LIST
76715: PUSH
76716: LD_INT 1
76718: PUSH
76719: LD_INT 1
76721: PUSH
76722: EMPTY
76723: LIST
76724: LIST
76725: PUSH
76726: LD_INT 0
76728: PUSH
76729: LD_INT 1
76731: PUSH
76732: EMPTY
76733: LIST
76734: LIST
76735: PUSH
76736: LD_INT 1
76738: NEG
76739: PUSH
76740: LD_INT 0
76742: PUSH
76743: EMPTY
76744: LIST
76745: LIST
76746: PUSH
76747: LD_INT 1
76749: NEG
76750: PUSH
76751: LD_INT 1
76753: NEG
76754: PUSH
76755: EMPTY
76756: LIST
76757: LIST
76758: PUSH
76759: LD_INT 1
76761: NEG
76762: PUSH
76763: LD_INT 2
76765: NEG
76766: PUSH
76767: EMPTY
76768: LIST
76769: LIST
76770: PUSH
76771: LD_INT 0
76773: PUSH
76774: LD_INT 2
76776: NEG
76777: PUSH
76778: EMPTY
76779: LIST
76780: LIST
76781: PUSH
76782: LD_INT 1
76784: PUSH
76785: LD_INT 1
76787: NEG
76788: PUSH
76789: EMPTY
76790: LIST
76791: LIST
76792: PUSH
76793: LD_INT 2
76795: PUSH
76796: LD_INT 0
76798: PUSH
76799: EMPTY
76800: LIST
76801: LIST
76802: PUSH
76803: LD_INT 2
76805: PUSH
76806: LD_INT 1
76808: PUSH
76809: EMPTY
76810: LIST
76811: LIST
76812: PUSH
76813: LD_INT 2
76815: PUSH
76816: LD_INT 2
76818: PUSH
76819: EMPTY
76820: LIST
76821: LIST
76822: PUSH
76823: LD_INT 1
76825: PUSH
76826: LD_INT 2
76828: PUSH
76829: EMPTY
76830: LIST
76831: LIST
76832: PUSH
76833: LD_INT 0
76835: PUSH
76836: LD_INT 2
76838: PUSH
76839: EMPTY
76840: LIST
76841: LIST
76842: PUSH
76843: LD_INT 1
76845: NEG
76846: PUSH
76847: LD_INT 1
76849: PUSH
76850: EMPTY
76851: LIST
76852: LIST
76853: PUSH
76854: LD_INT 2
76856: NEG
76857: PUSH
76858: LD_INT 0
76860: PUSH
76861: EMPTY
76862: LIST
76863: LIST
76864: PUSH
76865: LD_INT 2
76867: NEG
76868: PUSH
76869: LD_INT 1
76871: NEG
76872: PUSH
76873: EMPTY
76874: LIST
76875: LIST
76876: PUSH
76877: LD_INT 2
76879: NEG
76880: PUSH
76881: LD_INT 2
76883: NEG
76884: PUSH
76885: EMPTY
76886: LIST
76887: LIST
76888: PUSH
76889: EMPTY
76890: LIST
76891: LIST
76892: LIST
76893: LIST
76894: LIST
76895: LIST
76896: LIST
76897: LIST
76898: LIST
76899: LIST
76900: LIST
76901: LIST
76902: LIST
76903: LIST
76904: LIST
76905: LIST
76906: LIST
76907: LIST
76908: LIST
76909: ST_TO_ADDR
// Bunker0 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] ] ;
76910: LD_ADDR_VAR 0 59
76914: PUSH
76915: LD_INT 0
76917: PUSH
76918: LD_INT 0
76920: PUSH
76921: EMPTY
76922: LIST
76923: LIST
76924: PUSH
76925: LD_INT 0
76927: PUSH
76928: LD_INT 1
76930: NEG
76931: PUSH
76932: EMPTY
76933: LIST
76934: LIST
76935: PUSH
76936: LD_INT 1
76938: PUSH
76939: LD_INT 0
76941: PUSH
76942: EMPTY
76943: LIST
76944: LIST
76945: PUSH
76946: LD_INT 1
76948: PUSH
76949: LD_INT 1
76951: PUSH
76952: EMPTY
76953: LIST
76954: LIST
76955: PUSH
76956: LD_INT 0
76958: PUSH
76959: LD_INT 1
76961: PUSH
76962: EMPTY
76963: LIST
76964: LIST
76965: PUSH
76966: LD_INT 1
76968: NEG
76969: PUSH
76970: LD_INT 0
76972: PUSH
76973: EMPTY
76974: LIST
76975: LIST
76976: PUSH
76977: LD_INT 1
76979: NEG
76980: PUSH
76981: LD_INT 1
76983: NEG
76984: PUSH
76985: EMPTY
76986: LIST
76987: LIST
76988: PUSH
76989: EMPTY
76990: LIST
76991: LIST
76992: LIST
76993: LIST
76994: LIST
76995: LIST
76996: LIST
76997: ST_TO_ADDR
// Bunker1 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] ] ;
76998: LD_ADDR_VAR 0 60
77002: PUSH
77003: LD_INT 0
77005: PUSH
77006: LD_INT 0
77008: PUSH
77009: EMPTY
77010: LIST
77011: LIST
77012: PUSH
77013: LD_INT 0
77015: PUSH
77016: LD_INT 1
77018: NEG
77019: PUSH
77020: EMPTY
77021: LIST
77022: LIST
77023: PUSH
77024: LD_INT 1
77026: PUSH
77027: LD_INT 0
77029: PUSH
77030: EMPTY
77031: LIST
77032: LIST
77033: PUSH
77034: LD_INT 1
77036: PUSH
77037: LD_INT 1
77039: PUSH
77040: EMPTY
77041: LIST
77042: LIST
77043: PUSH
77044: LD_INT 0
77046: PUSH
77047: LD_INT 1
77049: PUSH
77050: EMPTY
77051: LIST
77052: LIST
77053: PUSH
77054: LD_INT 1
77056: NEG
77057: PUSH
77058: LD_INT 0
77060: PUSH
77061: EMPTY
77062: LIST
77063: LIST
77064: PUSH
77065: LD_INT 1
77067: NEG
77068: PUSH
77069: LD_INT 1
77071: NEG
77072: PUSH
77073: EMPTY
77074: LIST
77075: LIST
77076: PUSH
77077: EMPTY
77078: LIST
77079: LIST
77080: LIST
77081: LIST
77082: LIST
77083: LIST
77084: LIST
77085: ST_TO_ADDR
// Bunker2 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] ] ;
77086: LD_ADDR_VAR 0 61
77090: PUSH
77091: LD_INT 0
77093: PUSH
77094: LD_INT 0
77096: PUSH
77097: EMPTY
77098: LIST
77099: LIST
77100: PUSH
77101: LD_INT 0
77103: PUSH
77104: LD_INT 1
77106: NEG
77107: PUSH
77108: EMPTY
77109: LIST
77110: LIST
77111: PUSH
77112: LD_INT 1
77114: PUSH
77115: LD_INT 0
77117: PUSH
77118: EMPTY
77119: LIST
77120: LIST
77121: PUSH
77122: LD_INT 1
77124: PUSH
77125: LD_INT 1
77127: PUSH
77128: EMPTY
77129: LIST
77130: LIST
77131: PUSH
77132: LD_INT 0
77134: PUSH
77135: LD_INT 1
77137: PUSH
77138: EMPTY
77139: LIST
77140: LIST
77141: PUSH
77142: LD_INT 1
77144: NEG
77145: PUSH
77146: LD_INT 0
77148: PUSH
77149: EMPTY
77150: LIST
77151: LIST
77152: PUSH
77153: LD_INT 1
77155: NEG
77156: PUSH
77157: LD_INT 1
77159: NEG
77160: PUSH
77161: EMPTY
77162: LIST
77163: LIST
77164: PUSH
77165: EMPTY
77166: LIST
77167: LIST
77168: LIST
77169: LIST
77170: LIST
77171: LIST
77172: LIST
77173: ST_TO_ADDR
// Bunker3 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] ] ;
77174: LD_ADDR_VAR 0 62
77178: PUSH
77179: LD_INT 0
77181: PUSH
77182: LD_INT 0
77184: PUSH
77185: EMPTY
77186: LIST
77187: LIST
77188: PUSH
77189: LD_INT 0
77191: PUSH
77192: LD_INT 1
77194: NEG
77195: PUSH
77196: EMPTY
77197: LIST
77198: LIST
77199: PUSH
77200: LD_INT 1
77202: PUSH
77203: LD_INT 0
77205: PUSH
77206: EMPTY
77207: LIST
77208: LIST
77209: PUSH
77210: LD_INT 1
77212: PUSH
77213: LD_INT 1
77215: PUSH
77216: EMPTY
77217: LIST
77218: LIST
77219: PUSH
77220: LD_INT 0
77222: PUSH
77223: LD_INT 1
77225: PUSH
77226: EMPTY
77227: LIST
77228: LIST
77229: PUSH
77230: LD_INT 1
77232: NEG
77233: PUSH
77234: LD_INT 0
77236: PUSH
77237: EMPTY
77238: LIST
77239: LIST
77240: PUSH
77241: LD_INT 1
77243: NEG
77244: PUSH
77245: LD_INT 1
77247: NEG
77248: PUSH
77249: EMPTY
77250: LIST
77251: LIST
77252: PUSH
77253: EMPTY
77254: LIST
77255: LIST
77256: LIST
77257: LIST
77258: LIST
77259: LIST
77260: LIST
77261: ST_TO_ADDR
// Bunker4 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] ] ;
77262: LD_ADDR_VAR 0 63
77266: PUSH
77267: LD_INT 0
77269: PUSH
77270: LD_INT 0
77272: PUSH
77273: EMPTY
77274: LIST
77275: LIST
77276: PUSH
77277: LD_INT 0
77279: PUSH
77280: LD_INT 1
77282: NEG
77283: PUSH
77284: EMPTY
77285: LIST
77286: LIST
77287: PUSH
77288: LD_INT 1
77290: PUSH
77291: LD_INT 0
77293: PUSH
77294: EMPTY
77295: LIST
77296: LIST
77297: PUSH
77298: LD_INT 1
77300: PUSH
77301: LD_INT 1
77303: PUSH
77304: EMPTY
77305: LIST
77306: LIST
77307: PUSH
77308: LD_INT 0
77310: PUSH
77311: LD_INT 1
77313: PUSH
77314: EMPTY
77315: LIST
77316: LIST
77317: PUSH
77318: LD_INT 1
77320: NEG
77321: PUSH
77322: LD_INT 0
77324: PUSH
77325: EMPTY
77326: LIST
77327: LIST
77328: PUSH
77329: LD_INT 1
77331: NEG
77332: PUSH
77333: LD_INT 1
77335: NEG
77336: PUSH
77337: EMPTY
77338: LIST
77339: LIST
77340: PUSH
77341: EMPTY
77342: LIST
77343: LIST
77344: LIST
77345: LIST
77346: LIST
77347: LIST
77348: LIST
77349: ST_TO_ADDR
// Bunker5 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] ] ;
77350: LD_ADDR_VAR 0 64
77354: PUSH
77355: LD_INT 0
77357: PUSH
77358: LD_INT 0
77360: PUSH
77361: EMPTY
77362: LIST
77363: LIST
77364: PUSH
77365: LD_INT 0
77367: PUSH
77368: LD_INT 1
77370: NEG
77371: PUSH
77372: EMPTY
77373: LIST
77374: LIST
77375: PUSH
77376: LD_INT 1
77378: PUSH
77379: LD_INT 0
77381: PUSH
77382: EMPTY
77383: LIST
77384: LIST
77385: PUSH
77386: LD_INT 1
77388: PUSH
77389: LD_INT 1
77391: PUSH
77392: EMPTY
77393: LIST
77394: LIST
77395: PUSH
77396: LD_INT 0
77398: PUSH
77399: LD_INT 1
77401: PUSH
77402: EMPTY
77403: LIST
77404: LIST
77405: PUSH
77406: LD_INT 1
77408: NEG
77409: PUSH
77410: LD_INT 0
77412: PUSH
77413: EMPTY
77414: LIST
77415: LIST
77416: PUSH
77417: LD_INT 1
77419: NEG
77420: PUSH
77421: LD_INT 1
77423: NEG
77424: PUSH
77425: EMPTY
77426: LIST
77427: LIST
77428: PUSH
77429: EMPTY
77430: LIST
77431: LIST
77432: LIST
77433: LIST
77434: LIST
77435: LIST
77436: LIST
77437: ST_TO_ADDR
// end ; 1 :
77438: GO 83335
77440: LD_INT 1
77442: DOUBLE
77443: EQUAL
77444: IFTRUE 77448
77446: GO 80071
77448: POP
// begin DepotAm0 = [ [ - 1 , - 3 ] , [ 0 , - 3 ] , [ 1 , - 2 ] ] ;
77449: LD_ADDR_VAR 0 11
77453: PUSH
77454: LD_INT 1
77456: NEG
77457: PUSH
77458: LD_INT 3
77460: NEG
77461: PUSH
77462: EMPTY
77463: LIST
77464: LIST
77465: PUSH
77466: LD_INT 0
77468: PUSH
77469: LD_INT 3
77471: NEG
77472: PUSH
77473: EMPTY
77474: LIST
77475: LIST
77476: PUSH
77477: LD_INT 1
77479: PUSH
77480: LD_INT 2
77482: NEG
77483: PUSH
77484: EMPTY
77485: LIST
77486: LIST
77487: PUSH
77488: EMPTY
77489: LIST
77490: LIST
77491: LIST
77492: ST_TO_ADDR
// DepotAm1 = [ [ 2 , - 1 ] , [ 3 , 0 ] , [ 3 , 1 ] ] ;
77493: LD_ADDR_VAR 0 12
77497: PUSH
77498: LD_INT 2
77500: PUSH
77501: LD_INT 1
77503: NEG
77504: PUSH
77505: EMPTY
77506: LIST
77507: LIST
77508: PUSH
77509: LD_INT 3
77511: PUSH
77512: LD_INT 0
77514: PUSH
77515: EMPTY
77516: LIST
77517: LIST
77518: PUSH
77519: LD_INT 3
77521: PUSH
77522: LD_INT 1
77524: PUSH
77525: EMPTY
77526: LIST
77527: LIST
77528: PUSH
77529: EMPTY
77530: LIST
77531: LIST
77532: LIST
77533: ST_TO_ADDR
// DepotAm2 = [ [ 3 , 2 ] , [ 3 , 3 ] , [ 2 , 3 ] ] ;
77534: LD_ADDR_VAR 0 13
77538: PUSH
77539: LD_INT 3
77541: PUSH
77542: LD_INT 2
77544: PUSH
77545: EMPTY
77546: LIST
77547: LIST
77548: PUSH
77549: LD_INT 3
77551: PUSH
77552: LD_INT 3
77554: PUSH
77555: EMPTY
77556: LIST
77557: LIST
77558: PUSH
77559: LD_INT 2
77561: PUSH
77562: LD_INT 3
77564: PUSH
77565: EMPTY
77566: LIST
77567: LIST
77568: PUSH
77569: EMPTY
77570: LIST
77571: LIST
77572: LIST
77573: ST_TO_ADDR
// DepotAm3 = [ [ 1 , 3 ] , [ 0 , 3 ] , [ - 1 , 2 ] ] ;
77574: LD_ADDR_VAR 0 14
77578: PUSH
77579: LD_INT 1
77581: PUSH
77582: LD_INT 3
77584: PUSH
77585: EMPTY
77586: LIST
77587: LIST
77588: PUSH
77589: LD_INT 0
77591: PUSH
77592: LD_INT 3
77594: PUSH
77595: EMPTY
77596: LIST
77597: LIST
77598: PUSH
77599: LD_INT 1
77601: NEG
77602: PUSH
77603: LD_INT 2
77605: PUSH
77606: EMPTY
77607: LIST
77608: LIST
77609: PUSH
77610: EMPTY
77611: LIST
77612: LIST
77613: LIST
77614: ST_TO_ADDR
// DepotAm4 = [ [ - 2 , 1 ] , [ - 3 , 0 ] , [ - 3 , - 1 ] ] ;
77615: LD_ADDR_VAR 0 15
77619: PUSH
77620: LD_INT 2
77622: NEG
77623: PUSH
77624: LD_INT 1
77626: PUSH
77627: EMPTY
77628: LIST
77629: LIST
77630: PUSH
77631: LD_INT 3
77633: NEG
77634: PUSH
77635: LD_INT 0
77637: PUSH
77638: EMPTY
77639: LIST
77640: LIST
77641: PUSH
77642: LD_INT 3
77644: NEG
77645: PUSH
77646: LD_INT 1
77648: NEG
77649: PUSH
77650: EMPTY
77651: LIST
77652: LIST
77653: PUSH
77654: EMPTY
77655: LIST
77656: LIST
77657: LIST
77658: ST_TO_ADDR
// DepotAm5 = [ [ - 2 , - 3 ] , [ - 3 , - 2 ] , [ - 3 , - 3 ] ] ;
77659: LD_ADDR_VAR 0 16
77663: PUSH
77664: LD_INT 2
77666: NEG
77667: PUSH
77668: LD_INT 3
77670: NEG
77671: PUSH
77672: EMPTY
77673: LIST
77674: LIST
77675: PUSH
77676: LD_INT 3
77678: NEG
77679: PUSH
77680: LD_INT 2
77682: NEG
77683: PUSH
77684: EMPTY
77685: LIST
77686: LIST
77687: PUSH
77688: LD_INT 3
77690: NEG
77691: PUSH
77692: LD_INT 3
77694: NEG
77695: PUSH
77696: EMPTY
77697: LIST
77698: LIST
77699: PUSH
77700: EMPTY
77701: LIST
77702: LIST
77703: LIST
77704: ST_TO_ADDR
// DepotAr0 = [ [ - 1 , - 3 ] , [ 0 , - 3 ] , [ 1 , - 2 ] ] ;
77705: LD_ADDR_VAR 0 17
77709: PUSH
77710: LD_INT 1
77712: NEG
77713: PUSH
77714: LD_INT 3
77716: NEG
77717: PUSH
77718: EMPTY
77719: LIST
77720: LIST
77721: PUSH
77722: LD_INT 0
77724: PUSH
77725: LD_INT 3
77727: NEG
77728: PUSH
77729: EMPTY
77730: LIST
77731: LIST
77732: PUSH
77733: LD_INT 1
77735: PUSH
77736: LD_INT 2
77738: NEG
77739: PUSH
77740: EMPTY
77741: LIST
77742: LIST
77743: PUSH
77744: EMPTY
77745: LIST
77746: LIST
77747: LIST
77748: ST_TO_ADDR
// DepotAr1 = [ [ 2 , - 1 ] , [ 3 , 0 ] , [ 3 , 1 ] ] ;
77749: LD_ADDR_VAR 0 18
77753: PUSH
77754: LD_INT 2
77756: PUSH
77757: LD_INT 1
77759: NEG
77760: PUSH
77761: EMPTY
77762: LIST
77763: LIST
77764: PUSH
77765: LD_INT 3
77767: PUSH
77768: LD_INT 0
77770: PUSH
77771: EMPTY
77772: LIST
77773: LIST
77774: PUSH
77775: LD_INT 3
77777: PUSH
77778: LD_INT 1
77780: PUSH
77781: EMPTY
77782: LIST
77783: LIST
77784: PUSH
77785: EMPTY
77786: LIST
77787: LIST
77788: LIST
77789: ST_TO_ADDR
// DepotAr2 = [ [ 3 , 2 ] , [ 3 , 3 ] , [ 2 , 3 ] ] ;
77790: LD_ADDR_VAR 0 19
77794: PUSH
77795: LD_INT 3
77797: PUSH
77798: LD_INT 2
77800: PUSH
77801: EMPTY
77802: LIST
77803: LIST
77804: PUSH
77805: LD_INT 3
77807: PUSH
77808: LD_INT 3
77810: PUSH
77811: EMPTY
77812: LIST
77813: LIST
77814: PUSH
77815: LD_INT 2
77817: PUSH
77818: LD_INT 3
77820: PUSH
77821: EMPTY
77822: LIST
77823: LIST
77824: PUSH
77825: EMPTY
77826: LIST
77827: LIST
77828: LIST
77829: ST_TO_ADDR
// DepotAr3 = [ [ 1 , 3 ] , [ 0 , 3 ] , [ - 1 , 2 ] ] ;
77830: LD_ADDR_VAR 0 20
77834: PUSH
77835: LD_INT 1
77837: PUSH
77838: LD_INT 3
77840: PUSH
77841: EMPTY
77842: LIST
77843: LIST
77844: PUSH
77845: LD_INT 0
77847: PUSH
77848: LD_INT 3
77850: PUSH
77851: EMPTY
77852: LIST
77853: LIST
77854: PUSH
77855: LD_INT 1
77857: NEG
77858: PUSH
77859: LD_INT 2
77861: PUSH
77862: EMPTY
77863: LIST
77864: LIST
77865: PUSH
77866: EMPTY
77867: LIST
77868: LIST
77869: LIST
77870: ST_TO_ADDR
// DepotAr4 = [ [ - 2 , 1 ] , [ - 3 , 0 ] , [ - 3 , - 1 ] ] ;
77871: LD_ADDR_VAR 0 21
77875: PUSH
77876: LD_INT 2
77878: NEG
77879: PUSH
77880: LD_INT 1
77882: PUSH
77883: EMPTY
77884: LIST
77885: LIST
77886: PUSH
77887: LD_INT 3
77889: NEG
77890: PUSH
77891: LD_INT 0
77893: PUSH
77894: EMPTY
77895: LIST
77896: LIST
77897: PUSH
77898: LD_INT 3
77900: NEG
77901: PUSH
77902: LD_INT 1
77904: NEG
77905: PUSH
77906: EMPTY
77907: LIST
77908: LIST
77909: PUSH
77910: EMPTY
77911: LIST
77912: LIST
77913: LIST
77914: ST_TO_ADDR
// DepotAr5 = [ [ - 2 , - 3 ] , [ - 3 , - 2 ] , [ - 3 , - 3 ] ] ;
77915: LD_ADDR_VAR 0 22
77919: PUSH
77920: LD_INT 2
77922: NEG
77923: PUSH
77924: LD_INT 3
77926: NEG
77927: PUSH
77928: EMPTY
77929: LIST
77930: LIST
77931: PUSH
77932: LD_INT 3
77934: NEG
77935: PUSH
77936: LD_INT 2
77938: NEG
77939: PUSH
77940: EMPTY
77941: LIST
77942: LIST
77943: PUSH
77944: LD_INT 3
77946: NEG
77947: PUSH
77948: LD_INT 3
77950: NEG
77951: PUSH
77952: EMPTY
77953: LIST
77954: LIST
77955: PUSH
77956: EMPTY
77957: LIST
77958: LIST
77959: LIST
77960: ST_TO_ADDR
// DepotRu0 = [ [ 0 , - 3 ] , [ - 1 , - 4 ] , [ 1 , - 3 ] ] ;
77961: LD_ADDR_VAR 0 23
77965: PUSH
77966: LD_INT 0
77968: PUSH
77969: LD_INT 3
77971: NEG
77972: PUSH
77973: EMPTY
77974: LIST
77975: LIST
77976: PUSH
77977: LD_INT 1
77979: NEG
77980: PUSH
77981: LD_INT 4
77983: NEG
77984: PUSH
77985: EMPTY
77986: LIST
77987: LIST
77988: PUSH
77989: LD_INT 1
77991: PUSH
77992: LD_INT 3
77994: NEG
77995: PUSH
77996: EMPTY
77997: LIST
77998: LIST
77999: PUSH
78000: EMPTY
78001: LIST
78002: LIST
78003: LIST
78004: ST_TO_ADDR
// DepotRu1 = [ [ 3 , 0 ] , [ 3 , - 1 ] , [ 4 , 1 ] ] ;
78005: LD_ADDR_VAR 0 24
78009: PUSH
78010: LD_INT 3
78012: PUSH
78013: LD_INT 0
78015: PUSH
78016: EMPTY
78017: LIST
78018: LIST
78019: PUSH
78020: LD_INT 3
78022: PUSH
78023: LD_INT 1
78025: NEG
78026: PUSH
78027: EMPTY
78028: LIST
78029: LIST
78030: PUSH
78031: LD_INT 4
78033: PUSH
78034: LD_INT 1
78036: PUSH
78037: EMPTY
78038: LIST
78039: LIST
78040: PUSH
78041: EMPTY
78042: LIST
78043: LIST
78044: LIST
78045: ST_TO_ADDR
// DepotRu2 = [ [ 3 , 3 ] , [ 4 , 3 ] , [ 3 , 4 ] ] ;
78046: LD_ADDR_VAR 0 25
78050: PUSH
78051: LD_INT 3
78053: PUSH
78054: LD_INT 3
78056: PUSH
78057: EMPTY
78058: LIST
78059: LIST
78060: PUSH
78061: LD_INT 4
78063: PUSH
78064: LD_INT 3
78066: PUSH
78067: EMPTY
78068: LIST
78069: LIST
78070: PUSH
78071: LD_INT 3
78073: PUSH
78074: LD_INT 4
78076: PUSH
78077: EMPTY
78078: LIST
78079: LIST
78080: PUSH
78081: EMPTY
78082: LIST
78083: LIST
78084: LIST
78085: ST_TO_ADDR
// DepotRu3 = [ [ 0 , 3 ] , [ 1 , 4 ] , [ - 1 , 3 ] ] ;
78086: LD_ADDR_VAR 0 26
78090: PUSH
78091: LD_INT 0
78093: PUSH
78094: LD_INT 3
78096: PUSH
78097: EMPTY
78098: LIST
78099: LIST
78100: PUSH
78101: LD_INT 1
78103: PUSH
78104: LD_INT 4
78106: PUSH
78107: EMPTY
78108: LIST
78109: LIST
78110: PUSH
78111: LD_INT 1
78113: NEG
78114: PUSH
78115: LD_INT 3
78117: PUSH
78118: EMPTY
78119: LIST
78120: LIST
78121: PUSH
78122: EMPTY
78123: LIST
78124: LIST
78125: LIST
78126: ST_TO_ADDR
// DepotRu4 = [ [ - 3 , 0 ] , [ - 3 , 1 ] , [ - 4 , - 1 ] ] ;
78127: LD_ADDR_VAR 0 27
78131: PUSH
78132: LD_INT 3
78134: NEG
78135: PUSH
78136: LD_INT 0
78138: PUSH
78139: EMPTY
78140: LIST
78141: LIST
78142: PUSH
78143: LD_INT 3
78145: NEG
78146: PUSH
78147: LD_INT 1
78149: PUSH
78150: EMPTY
78151: LIST
78152: LIST
78153: PUSH
78154: LD_INT 4
78156: NEG
78157: PUSH
78158: LD_INT 1
78160: NEG
78161: PUSH
78162: EMPTY
78163: LIST
78164: LIST
78165: PUSH
78166: EMPTY
78167: LIST
78168: LIST
78169: LIST
78170: ST_TO_ADDR
// DepotRu5 = [ [ - 3 , - 3 ] , [ - 3 , - 4 ] , [ - 4 , - 3 ] ] ;
78171: LD_ADDR_VAR 0 28
78175: PUSH
78176: LD_INT 3
78178: NEG
78179: PUSH
78180: LD_INT 3
78182: NEG
78183: PUSH
78184: EMPTY
78185: LIST
78186: LIST
78187: PUSH
78188: LD_INT 3
78190: NEG
78191: PUSH
78192: LD_INT 4
78194: NEG
78195: PUSH
78196: EMPTY
78197: LIST
78198: LIST
78199: PUSH
78200: LD_INT 4
78202: NEG
78203: PUSH
78204: LD_INT 3
78206: NEG
78207: PUSH
78208: EMPTY
78209: LIST
78210: LIST
78211: PUSH
78212: EMPTY
78213: LIST
78214: LIST
78215: LIST
78216: ST_TO_ADDR
// Factory0 = [ [ - 1 , - 3 ] , [ 0 , - 3 ] , [ 1 , - 2 ] , [ - 1 , - 4 ] , [ 0 , - 4 ] , [ 1 , - 3 ] , [ - 1 , - 5 ] , [ 0 , - 5 ] , [ 1 , - 4 ] , [ - 1 , - 6 ] , [ 0 , - 6 ] , [ 1 , - 5 ] ] ;
78217: LD_ADDR_VAR 0 29
78221: PUSH
78222: LD_INT 1
78224: NEG
78225: PUSH
78226: LD_INT 3
78228: NEG
78229: PUSH
78230: EMPTY
78231: LIST
78232: LIST
78233: PUSH
78234: LD_INT 0
78236: PUSH
78237: LD_INT 3
78239: NEG
78240: PUSH
78241: EMPTY
78242: LIST
78243: LIST
78244: PUSH
78245: LD_INT 1
78247: PUSH
78248: LD_INT 2
78250: NEG
78251: PUSH
78252: EMPTY
78253: LIST
78254: LIST
78255: PUSH
78256: LD_INT 1
78258: NEG
78259: PUSH
78260: LD_INT 4
78262: NEG
78263: PUSH
78264: EMPTY
78265: LIST
78266: LIST
78267: PUSH
78268: LD_INT 0
78270: PUSH
78271: LD_INT 4
78273: NEG
78274: PUSH
78275: EMPTY
78276: LIST
78277: LIST
78278: PUSH
78279: LD_INT 1
78281: PUSH
78282: LD_INT 3
78284: NEG
78285: PUSH
78286: EMPTY
78287: LIST
78288: LIST
78289: PUSH
78290: LD_INT 1
78292: NEG
78293: PUSH
78294: LD_INT 5
78296: NEG
78297: PUSH
78298: EMPTY
78299: LIST
78300: LIST
78301: PUSH
78302: LD_INT 0
78304: PUSH
78305: LD_INT 5
78307: NEG
78308: PUSH
78309: EMPTY
78310: LIST
78311: LIST
78312: PUSH
78313: LD_INT 1
78315: PUSH
78316: LD_INT 4
78318: NEG
78319: PUSH
78320: EMPTY
78321: LIST
78322: LIST
78323: PUSH
78324: LD_INT 1
78326: NEG
78327: PUSH
78328: LD_INT 6
78330: NEG
78331: PUSH
78332: EMPTY
78333: LIST
78334: LIST
78335: PUSH
78336: LD_INT 0
78338: PUSH
78339: LD_INT 6
78341: NEG
78342: PUSH
78343: EMPTY
78344: LIST
78345: LIST
78346: PUSH
78347: LD_INT 1
78349: PUSH
78350: LD_INT 5
78352: NEG
78353: PUSH
78354: EMPTY
78355: LIST
78356: LIST
78357: PUSH
78358: EMPTY
78359: LIST
78360: LIST
78361: LIST
78362: LIST
78363: LIST
78364: LIST
78365: LIST
78366: LIST
78367: LIST
78368: LIST
78369: LIST
78370: LIST
78371: ST_TO_ADDR
// Factory1 = [ [ 2 , - 1 ] , [ 3 , 0 ] , [ 3 , 1 ] , [ 3 , - 1 ] , [ 4 , 0 ] , [ 4 , 1 ] , [ 4 , - 1 ] , [ 5 , 0 ] , [ 5 , 1 ] , [ 5 , - 1 ] , [ 6 , 0 ] , [ 6 , 1 ] ] ;
78372: LD_ADDR_VAR 0 30
78376: PUSH
78377: LD_INT 2
78379: PUSH
78380: LD_INT 1
78382: NEG
78383: PUSH
78384: EMPTY
78385: LIST
78386: LIST
78387: PUSH
78388: LD_INT 3
78390: PUSH
78391: LD_INT 0
78393: PUSH
78394: EMPTY
78395: LIST
78396: LIST
78397: PUSH
78398: LD_INT 3
78400: PUSH
78401: LD_INT 1
78403: PUSH
78404: EMPTY
78405: LIST
78406: LIST
78407: PUSH
78408: LD_INT 3
78410: PUSH
78411: LD_INT 1
78413: NEG
78414: PUSH
78415: EMPTY
78416: LIST
78417: LIST
78418: PUSH
78419: LD_INT 4
78421: PUSH
78422: LD_INT 0
78424: PUSH
78425: EMPTY
78426: LIST
78427: LIST
78428: PUSH
78429: LD_INT 4
78431: PUSH
78432: LD_INT 1
78434: PUSH
78435: EMPTY
78436: LIST
78437: LIST
78438: PUSH
78439: LD_INT 4
78441: PUSH
78442: LD_INT 1
78444: NEG
78445: PUSH
78446: EMPTY
78447: LIST
78448: LIST
78449: PUSH
78450: LD_INT 5
78452: PUSH
78453: LD_INT 0
78455: PUSH
78456: EMPTY
78457: LIST
78458: LIST
78459: PUSH
78460: LD_INT 5
78462: PUSH
78463: LD_INT 1
78465: PUSH
78466: EMPTY
78467: LIST
78468: LIST
78469: PUSH
78470: LD_INT 5
78472: PUSH
78473: LD_INT 1
78475: NEG
78476: PUSH
78477: EMPTY
78478: LIST
78479: LIST
78480: PUSH
78481: LD_INT 6
78483: PUSH
78484: LD_INT 0
78486: PUSH
78487: EMPTY
78488: LIST
78489: LIST
78490: PUSH
78491: LD_INT 6
78493: PUSH
78494: LD_INT 1
78496: PUSH
78497: EMPTY
78498: LIST
78499: LIST
78500: PUSH
78501: EMPTY
78502: LIST
78503: LIST
78504: LIST
78505: LIST
78506: LIST
78507: LIST
78508: LIST
78509: LIST
78510: LIST
78511: LIST
78512: LIST
78513: LIST
78514: ST_TO_ADDR
// Factory2 = [ [ 3 , 2 ] , [ 3 , 3 ] , [ 2 , 3 ] , [ 4 , 3 ] , [ 4 , 4 ] , [ 3 , 4 ] , [ 5 , 4 ] , [ 5 , 5 ] , [ 4 , 5 ] , [ 6 , 5 ] , [ 6 , 6 ] , [ 5 , 6 ] ] ;
78515: LD_ADDR_VAR 0 31
78519: PUSH
78520: LD_INT 3
78522: PUSH
78523: LD_INT 2
78525: PUSH
78526: EMPTY
78527: LIST
78528: LIST
78529: PUSH
78530: LD_INT 3
78532: PUSH
78533: LD_INT 3
78535: PUSH
78536: EMPTY
78537: LIST
78538: LIST
78539: PUSH
78540: LD_INT 2
78542: PUSH
78543: LD_INT 3
78545: PUSH
78546: EMPTY
78547: LIST
78548: LIST
78549: PUSH
78550: LD_INT 4
78552: PUSH
78553: LD_INT 3
78555: PUSH
78556: EMPTY
78557: LIST
78558: LIST
78559: PUSH
78560: LD_INT 4
78562: PUSH
78563: LD_INT 4
78565: PUSH
78566: EMPTY
78567: LIST
78568: LIST
78569: PUSH
78570: LD_INT 3
78572: PUSH
78573: LD_INT 4
78575: PUSH
78576: EMPTY
78577: LIST
78578: LIST
78579: PUSH
78580: LD_INT 5
78582: PUSH
78583: LD_INT 4
78585: PUSH
78586: EMPTY
78587: LIST
78588: LIST
78589: PUSH
78590: LD_INT 5
78592: PUSH
78593: LD_INT 5
78595: PUSH
78596: EMPTY
78597: LIST
78598: LIST
78599: PUSH
78600: LD_INT 4
78602: PUSH
78603: LD_INT 5
78605: PUSH
78606: EMPTY
78607: LIST
78608: LIST
78609: PUSH
78610: LD_INT 6
78612: PUSH
78613: LD_INT 5
78615: PUSH
78616: EMPTY
78617: LIST
78618: LIST
78619: PUSH
78620: LD_INT 6
78622: PUSH
78623: LD_INT 6
78625: PUSH
78626: EMPTY
78627: LIST
78628: LIST
78629: PUSH
78630: LD_INT 5
78632: PUSH
78633: LD_INT 6
78635: PUSH
78636: EMPTY
78637: LIST
78638: LIST
78639: PUSH
78640: EMPTY
78641: LIST
78642: LIST
78643: LIST
78644: LIST
78645: LIST
78646: LIST
78647: LIST
78648: LIST
78649: LIST
78650: LIST
78651: LIST
78652: LIST
78653: ST_TO_ADDR
// Factory3 = [ [ 1 , 3 ] , [ 0 , 3 ] , [ - 1 , 2 ] , [ 1 , 4 ] , [ 0 , 4 ] , [ - 1 , 3 ] , [ 1 , 5 ] , [ 0 , 5 ] , [ - 1 , 4 ] , [ 1 , 6 ] , [ 0 , 6 ] , [ - 1 , 5 ] ] ;
78654: LD_ADDR_VAR 0 32
78658: PUSH
78659: LD_INT 1
78661: PUSH
78662: LD_INT 3
78664: PUSH
78665: EMPTY
78666: LIST
78667: LIST
78668: PUSH
78669: LD_INT 0
78671: PUSH
78672: LD_INT 3
78674: PUSH
78675: EMPTY
78676: LIST
78677: LIST
78678: PUSH
78679: LD_INT 1
78681: NEG
78682: PUSH
78683: LD_INT 2
78685: PUSH
78686: EMPTY
78687: LIST
78688: LIST
78689: PUSH
78690: LD_INT 1
78692: PUSH
78693: LD_INT 4
78695: PUSH
78696: EMPTY
78697: LIST
78698: LIST
78699: PUSH
78700: LD_INT 0
78702: PUSH
78703: LD_INT 4
78705: PUSH
78706: EMPTY
78707: LIST
78708: LIST
78709: PUSH
78710: LD_INT 1
78712: NEG
78713: PUSH
78714: LD_INT 3
78716: PUSH
78717: EMPTY
78718: LIST
78719: LIST
78720: PUSH
78721: LD_INT 1
78723: PUSH
78724: LD_INT 5
78726: PUSH
78727: EMPTY
78728: LIST
78729: LIST
78730: PUSH
78731: LD_INT 0
78733: PUSH
78734: LD_INT 5
78736: PUSH
78737: EMPTY
78738: LIST
78739: LIST
78740: PUSH
78741: LD_INT 1
78743: NEG
78744: PUSH
78745: LD_INT 4
78747: PUSH
78748: EMPTY
78749: LIST
78750: LIST
78751: PUSH
78752: LD_INT 1
78754: PUSH
78755: LD_INT 6
78757: PUSH
78758: EMPTY
78759: LIST
78760: LIST
78761: PUSH
78762: LD_INT 0
78764: PUSH
78765: LD_INT 6
78767: PUSH
78768: EMPTY
78769: LIST
78770: LIST
78771: PUSH
78772: LD_INT 1
78774: NEG
78775: PUSH
78776: LD_INT 5
78778: PUSH
78779: EMPTY
78780: LIST
78781: LIST
78782: PUSH
78783: EMPTY
78784: LIST
78785: LIST
78786: LIST
78787: LIST
78788: LIST
78789: LIST
78790: LIST
78791: LIST
78792: LIST
78793: LIST
78794: LIST
78795: LIST
78796: ST_TO_ADDR
// Factory4 = [ [ - 2 , 1 ] , [ - 3 , 0 ] , [ - 3 , - 1 ] , [ - 3 , 1 ] , [ - 4 , 0 ] , [ - 4 , - 1 ] , [ - 4 , 1 ] , [ - 5 , 0 ] , [ - 5 , - 1 ] , [ - 5 , 1 ] , [ - 6 , 0 ] , [ - 6 , - 1 ] ] ;
78797: LD_ADDR_VAR 0 33
78801: PUSH
78802: LD_INT 2
78804: NEG
78805: PUSH
78806: LD_INT 1
78808: PUSH
78809: EMPTY
78810: LIST
78811: LIST
78812: PUSH
78813: LD_INT 3
78815: NEG
78816: PUSH
78817: LD_INT 0
78819: PUSH
78820: EMPTY
78821: LIST
78822: LIST
78823: PUSH
78824: LD_INT 3
78826: NEG
78827: PUSH
78828: LD_INT 1
78830: NEG
78831: PUSH
78832: EMPTY
78833: LIST
78834: LIST
78835: PUSH
78836: LD_INT 3
78838: NEG
78839: PUSH
78840: LD_INT 1
78842: PUSH
78843: EMPTY
78844: LIST
78845: LIST
78846: PUSH
78847: LD_INT 4
78849: NEG
78850: PUSH
78851: LD_INT 0
78853: PUSH
78854: EMPTY
78855: LIST
78856: LIST
78857: PUSH
78858: LD_INT 4
78860: NEG
78861: PUSH
78862: LD_INT 1
78864: NEG
78865: PUSH
78866: EMPTY
78867: LIST
78868: LIST
78869: PUSH
78870: LD_INT 4
78872: NEG
78873: PUSH
78874: LD_INT 1
78876: PUSH
78877: EMPTY
78878: LIST
78879: LIST
78880: PUSH
78881: LD_INT 5
78883: NEG
78884: PUSH
78885: LD_INT 0
78887: PUSH
78888: EMPTY
78889: LIST
78890: LIST
78891: PUSH
78892: LD_INT 5
78894: NEG
78895: PUSH
78896: LD_INT 1
78898: NEG
78899: PUSH
78900: EMPTY
78901: LIST
78902: LIST
78903: PUSH
78904: LD_INT 5
78906: NEG
78907: PUSH
78908: LD_INT 1
78910: PUSH
78911: EMPTY
78912: LIST
78913: LIST
78914: PUSH
78915: LD_INT 6
78917: NEG
78918: PUSH
78919: LD_INT 0
78921: PUSH
78922: EMPTY
78923: LIST
78924: LIST
78925: PUSH
78926: LD_INT 6
78928: NEG
78929: PUSH
78930: LD_INT 1
78932: NEG
78933: PUSH
78934: EMPTY
78935: LIST
78936: LIST
78937: PUSH
78938: EMPTY
78939: LIST
78940: LIST
78941: LIST
78942: LIST
78943: LIST
78944: LIST
78945: LIST
78946: LIST
78947: LIST
78948: LIST
78949: LIST
78950: LIST
78951: ST_TO_ADDR
// Factory5 = [ [ - 2 , - 3 ] , [ - 3 , - 2 ] , [ - 3 , - 3 ] , [ - 3 , - 4 ] , [ - 4 , - 3 ] , [ - 4 , - 4 ] , [ - 4 , - 5 ] , [ - 5 , - 4 ] , [ - 5 , - 5 ] , [ - 5 , - 6 ] , [ - 6 , - 5 ] , [ - 6 , - 6 ] ] ;
78952: LD_ADDR_VAR 0 34
78956: PUSH
78957: LD_INT 2
78959: NEG
78960: PUSH
78961: LD_INT 3
78963: NEG
78964: PUSH
78965: EMPTY
78966: LIST
78967: LIST
78968: PUSH
78969: LD_INT 3
78971: NEG
78972: PUSH
78973: LD_INT 2
78975: NEG
78976: PUSH
78977: EMPTY
78978: LIST
78979: LIST
78980: PUSH
78981: LD_INT 3
78983: NEG
78984: PUSH
78985: LD_INT 3
78987: NEG
78988: PUSH
78989: EMPTY
78990: LIST
78991: LIST
78992: PUSH
78993: LD_INT 3
78995: NEG
78996: PUSH
78997: LD_INT 4
78999: NEG
79000: PUSH
79001: EMPTY
79002: LIST
79003: LIST
79004: PUSH
79005: LD_INT 4
79007: NEG
79008: PUSH
79009: LD_INT 3
79011: NEG
79012: PUSH
79013: EMPTY
79014: LIST
79015: LIST
79016: PUSH
79017: LD_INT 4
79019: NEG
79020: PUSH
79021: LD_INT 4
79023: NEG
79024: PUSH
79025: EMPTY
79026: LIST
79027: LIST
79028: PUSH
79029: LD_INT 4
79031: NEG
79032: PUSH
79033: LD_INT 5
79035: NEG
79036: PUSH
79037: EMPTY
79038: LIST
79039: LIST
79040: PUSH
79041: LD_INT 5
79043: NEG
79044: PUSH
79045: LD_INT 4
79047: NEG
79048: PUSH
79049: EMPTY
79050: LIST
79051: LIST
79052: PUSH
79053: LD_INT 5
79055: NEG
79056: PUSH
79057: LD_INT 5
79059: NEG
79060: PUSH
79061: EMPTY
79062: LIST
79063: LIST
79064: PUSH
79065: LD_INT 5
79067: NEG
79068: PUSH
79069: LD_INT 6
79071: NEG
79072: PUSH
79073: EMPTY
79074: LIST
79075: LIST
79076: PUSH
79077: LD_INT 6
79079: NEG
79080: PUSH
79081: LD_INT 5
79083: NEG
79084: PUSH
79085: EMPTY
79086: LIST
79087: LIST
79088: PUSH
79089: LD_INT 6
79091: NEG
79092: PUSH
79093: LD_INT 6
79095: NEG
79096: PUSH
79097: EMPTY
79098: LIST
79099: LIST
79100: PUSH
79101: EMPTY
79102: LIST
79103: LIST
79104: LIST
79105: LIST
79106: LIST
79107: LIST
79108: LIST
79109: LIST
79110: LIST
79111: LIST
79112: LIST
79113: LIST
79114: ST_TO_ADDR
// Lab0 = [ [ 0 , - 2 ] , [ - 1 , - 3 ] , [ 1 , - 2 ] ] ;
79115: LD_ADDR_VAR 0 41
79119: PUSH
79120: LD_INT 0
79122: PUSH
79123: LD_INT 2
79125: NEG
79126: PUSH
79127: EMPTY
79128: LIST
79129: LIST
79130: PUSH
79131: LD_INT 1
79133: NEG
79134: PUSH
79135: LD_INT 3
79137: NEG
79138: PUSH
79139: EMPTY
79140: LIST
79141: LIST
79142: PUSH
79143: LD_INT 1
79145: PUSH
79146: LD_INT 2
79148: NEG
79149: PUSH
79150: EMPTY
79151: LIST
79152: LIST
79153: PUSH
79154: EMPTY
79155: LIST
79156: LIST
79157: LIST
79158: ST_TO_ADDR
// Lab1 = [ [ 2 , 0 ] , [ 2 , - 1 ] , [ 3 , 1 ] ] ;
79159: LD_ADDR_VAR 0 42
79163: PUSH
79164: LD_INT 2
79166: PUSH
79167: LD_INT 0
79169: PUSH
79170: EMPTY
79171: LIST
79172: LIST
79173: PUSH
79174: LD_INT 2
79176: PUSH
79177: LD_INT 1
79179: NEG
79180: PUSH
79181: EMPTY
79182: LIST
79183: LIST
79184: PUSH
79185: LD_INT 3
79187: PUSH
79188: LD_INT 1
79190: PUSH
79191: EMPTY
79192: LIST
79193: LIST
79194: PUSH
79195: EMPTY
79196: LIST
79197: LIST
79198: LIST
79199: ST_TO_ADDR
// Lab2 = [ [ 2 , 2 ] , [ 3 , 2 ] , [ 2 , 3 ] ] ;
79200: LD_ADDR_VAR 0 43
79204: PUSH
79205: LD_INT 2
79207: PUSH
79208: LD_INT 2
79210: PUSH
79211: EMPTY
79212: LIST
79213: LIST
79214: PUSH
79215: LD_INT 3
79217: PUSH
79218: LD_INT 2
79220: PUSH
79221: EMPTY
79222: LIST
79223: LIST
79224: PUSH
79225: LD_INT 2
79227: PUSH
79228: LD_INT 3
79230: PUSH
79231: EMPTY
79232: LIST
79233: LIST
79234: PUSH
79235: EMPTY
79236: LIST
79237: LIST
79238: LIST
79239: ST_TO_ADDR
// Lab3 = [ [ 0 , 2 ] , [ 1 , 3 ] , [ - 1 , 2 ] ] ;
79240: LD_ADDR_VAR 0 44
79244: PUSH
79245: LD_INT 0
79247: PUSH
79248: LD_INT 2
79250: PUSH
79251: EMPTY
79252: LIST
79253: LIST
79254: PUSH
79255: LD_INT 1
79257: PUSH
79258: LD_INT 3
79260: PUSH
79261: EMPTY
79262: LIST
79263: LIST
79264: PUSH
79265: LD_INT 1
79267: NEG
79268: PUSH
79269: LD_INT 2
79271: PUSH
79272: EMPTY
79273: LIST
79274: LIST
79275: PUSH
79276: EMPTY
79277: LIST
79278: LIST
79279: LIST
79280: ST_TO_ADDR
// Lab4 = [ [ - 2 , 0 ] , [ - 2 , 1 ] , [ - 3 , - 1 ] ] ;
79281: LD_ADDR_VAR 0 45
79285: PUSH
79286: LD_INT 2
79288: NEG
79289: PUSH
79290: LD_INT 0
79292: PUSH
79293: EMPTY
79294: LIST
79295: LIST
79296: PUSH
79297: LD_INT 2
79299: NEG
79300: PUSH
79301: LD_INT 1
79303: PUSH
79304: EMPTY
79305: LIST
79306: LIST
79307: PUSH
79308: LD_INT 3
79310: NEG
79311: PUSH
79312: LD_INT 1
79314: NEG
79315: PUSH
79316: EMPTY
79317: LIST
79318: LIST
79319: PUSH
79320: EMPTY
79321: LIST
79322: LIST
79323: LIST
79324: ST_TO_ADDR
// Lab5 = [ [ - 2 , - 2 ] , [ - 2 , - 3 ] , [ - 3 , - 2 ] ] ;
79325: LD_ADDR_VAR 0 46
79329: PUSH
79330: LD_INT 2
79332: NEG
79333: PUSH
79334: LD_INT 2
79336: NEG
79337: PUSH
79338: EMPTY
79339: LIST
79340: LIST
79341: PUSH
79342: LD_INT 2
79344: NEG
79345: PUSH
79346: LD_INT 3
79348: NEG
79349: PUSH
79350: EMPTY
79351: LIST
79352: LIST
79353: PUSH
79354: LD_INT 3
79356: NEG
79357: PUSH
79358: LD_INT 2
79360: NEG
79361: PUSH
79362: EMPTY
79363: LIST
79364: LIST
79365: PUSH
79366: EMPTY
79367: LIST
79368: LIST
79369: LIST
79370: ST_TO_ADDR
// ControlTower0 = [ [ - 2 , - 3 ] , [ - 1 , - 3 ] ] ;
79371: LD_ADDR_VAR 0 47
79375: PUSH
79376: LD_INT 2
79378: NEG
79379: PUSH
79380: LD_INT 3
79382: NEG
79383: PUSH
79384: EMPTY
79385: LIST
79386: LIST
79387: PUSH
79388: LD_INT 1
79390: NEG
79391: PUSH
79392: LD_INT 3
79394: NEG
79395: PUSH
79396: EMPTY
79397: LIST
79398: LIST
79399: PUSH
79400: EMPTY
79401: LIST
79402: LIST
79403: ST_TO_ADDR
// ControlTower1 = [ [ 1 , - 2 ] , [ 2 , - 1 ] ] ;
79404: LD_ADDR_VAR 0 48
79408: PUSH
79409: LD_INT 1
79411: PUSH
79412: LD_INT 2
79414: NEG
79415: PUSH
79416: EMPTY
79417: LIST
79418: LIST
79419: PUSH
79420: LD_INT 2
79422: PUSH
79423: LD_INT 1
79425: NEG
79426: PUSH
79427: EMPTY
79428: LIST
79429: LIST
79430: PUSH
79431: EMPTY
79432: LIST
79433: LIST
79434: ST_TO_ADDR
// ControlTower2 = [ [ 3 , 1 ] , [ 3 , 2 ] ] ;
79435: LD_ADDR_VAR 0 49
79439: PUSH
79440: LD_INT 3
79442: PUSH
79443: LD_INT 1
79445: PUSH
79446: EMPTY
79447: LIST
79448: LIST
79449: PUSH
79450: LD_INT 3
79452: PUSH
79453: LD_INT 2
79455: PUSH
79456: EMPTY
79457: LIST
79458: LIST
79459: PUSH
79460: EMPTY
79461: LIST
79462: LIST
79463: ST_TO_ADDR
// ControlTower3 = [ [ 2 , 3 ] , [ 1 , 3 ] ] ;
79464: LD_ADDR_VAR 0 50
79468: PUSH
79469: LD_INT 2
79471: PUSH
79472: LD_INT 3
79474: PUSH
79475: EMPTY
79476: LIST
79477: LIST
79478: PUSH
79479: LD_INT 1
79481: PUSH
79482: LD_INT 3
79484: PUSH
79485: EMPTY
79486: LIST
79487: LIST
79488: PUSH
79489: EMPTY
79490: LIST
79491: LIST
79492: ST_TO_ADDR
// ControlTower4 = [ [ - 1 , 2 ] , [ - 2 , 1 ] ] ;
79493: LD_ADDR_VAR 0 51
79497: PUSH
79498: LD_INT 1
79500: NEG
79501: PUSH
79502: LD_INT 2
79504: PUSH
79505: EMPTY
79506: LIST
79507: LIST
79508: PUSH
79509: LD_INT 2
79511: NEG
79512: PUSH
79513: LD_INT 1
79515: PUSH
79516: EMPTY
79517: LIST
79518: LIST
79519: PUSH
79520: EMPTY
79521: LIST
79522: LIST
79523: ST_TO_ADDR
// ControlTower5 = [ [ - 3 , - 1 ] , [ - 3 , - 2 ] ] ;
79524: LD_ADDR_VAR 0 52
79528: PUSH
79529: LD_INT 3
79531: NEG
79532: PUSH
79533: LD_INT 1
79535: NEG
79536: PUSH
79537: EMPTY
79538: LIST
79539: LIST
79540: PUSH
79541: LD_INT 3
79543: NEG
79544: PUSH
79545: LD_INT 2
79547: NEG
79548: PUSH
79549: EMPTY
79550: LIST
79551: LIST
79552: PUSH
79553: EMPTY
79554: LIST
79555: LIST
79556: ST_TO_ADDR
// Barracks0 = [ [ - 1 , - 3 ] , [ 0 , - 3 ] , [ 1 , - 2 ] ] ;
79557: LD_ADDR_VAR 0 53
79561: PUSH
79562: LD_INT 1
79564: NEG
79565: PUSH
79566: LD_INT 3
79568: NEG
79569: PUSH
79570: EMPTY
79571: LIST
79572: LIST
79573: PUSH
79574: LD_INT 0
79576: PUSH
79577: LD_INT 3
79579: NEG
79580: PUSH
79581: EMPTY
79582: LIST
79583: LIST
79584: PUSH
79585: LD_INT 1
79587: PUSH
79588: LD_INT 2
79590: NEG
79591: PUSH
79592: EMPTY
79593: LIST
79594: LIST
79595: PUSH
79596: EMPTY
79597: LIST
79598: LIST
79599: LIST
79600: ST_TO_ADDR
// Barracks1 = [ [ 2 , - 1 ] , [ 3 , 0 ] , [ 3 , 1 ] ] ;
79601: LD_ADDR_VAR 0 54
79605: PUSH
79606: LD_INT 2
79608: PUSH
79609: LD_INT 1
79611: NEG
79612: PUSH
79613: EMPTY
79614: LIST
79615: LIST
79616: PUSH
79617: LD_INT 3
79619: PUSH
79620: LD_INT 0
79622: PUSH
79623: EMPTY
79624: LIST
79625: LIST
79626: PUSH
79627: LD_INT 3
79629: PUSH
79630: LD_INT 1
79632: PUSH
79633: EMPTY
79634: LIST
79635: LIST
79636: PUSH
79637: EMPTY
79638: LIST
79639: LIST
79640: LIST
79641: ST_TO_ADDR
// Barracks2 = [ [ 3 , 2 ] , [ 3 , 3 ] , [ 2 , 3 ] ] ;
79642: LD_ADDR_VAR 0 55
79646: PUSH
79647: LD_INT 3
79649: PUSH
79650: LD_INT 2
79652: PUSH
79653: EMPTY
79654: LIST
79655: LIST
79656: PUSH
79657: LD_INT 3
79659: PUSH
79660: LD_INT 3
79662: PUSH
79663: EMPTY
79664: LIST
79665: LIST
79666: PUSH
79667: LD_INT 2
79669: PUSH
79670: LD_INT 3
79672: PUSH
79673: EMPTY
79674: LIST
79675: LIST
79676: PUSH
79677: EMPTY
79678: LIST
79679: LIST
79680: LIST
79681: ST_TO_ADDR
// Barracks3 = [ [ 1 , 3 ] , [ 0 , 3 ] , [ - 1 , 2 ] ] ;
79682: LD_ADDR_VAR 0 56
79686: PUSH
79687: LD_INT 1
79689: PUSH
79690: LD_INT 3
79692: PUSH
79693: EMPTY
79694: LIST
79695: LIST
79696: PUSH
79697: LD_INT 0
79699: PUSH
79700: LD_INT 3
79702: PUSH
79703: EMPTY
79704: LIST
79705: LIST
79706: PUSH
79707: LD_INT 1
79709: NEG
79710: PUSH
79711: LD_INT 2
79713: PUSH
79714: EMPTY
79715: LIST
79716: LIST
79717: PUSH
79718: EMPTY
79719: LIST
79720: LIST
79721: LIST
79722: ST_TO_ADDR
// Barracks4 = [ [ - 2 , 1 ] , [ - 3 , 0 ] , [ - 3 , - 1 ] ] ;
79723: LD_ADDR_VAR 0 57
79727: PUSH
79728: LD_INT 2
79730: NEG
79731: PUSH
79732: LD_INT 1
79734: PUSH
79735: EMPTY
79736: LIST
79737: LIST
79738: PUSH
79739: LD_INT 3
79741: NEG
79742: PUSH
79743: LD_INT 0
79745: PUSH
79746: EMPTY
79747: LIST
79748: LIST
79749: PUSH
79750: LD_INT 3
79752: NEG
79753: PUSH
79754: LD_INT 1
79756: NEG
79757: PUSH
79758: EMPTY
79759: LIST
79760: LIST
79761: PUSH
79762: EMPTY
79763: LIST
79764: LIST
79765: LIST
79766: ST_TO_ADDR
// Barracks5 = [ [ - 2 , - 3 ] , [ - 3 , - 2 ] , [ - 3 , - 3 ] ] ;
79767: LD_ADDR_VAR 0 58
79771: PUSH
79772: LD_INT 2
79774: NEG
79775: PUSH
79776: LD_INT 3
79778: NEG
79779: PUSH
79780: EMPTY
79781: LIST
79782: LIST
79783: PUSH
79784: LD_INT 3
79786: NEG
79787: PUSH
79788: LD_INT 2
79790: NEG
79791: PUSH
79792: EMPTY
79793: LIST
79794: LIST
79795: PUSH
79796: LD_INT 3
79798: NEG
79799: PUSH
79800: LD_INT 3
79802: NEG
79803: PUSH
79804: EMPTY
79805: LIST
79806: LIST
79807: PUSH
79808: EMPTY
79809: LIST
79810: LIST
79811: LIST
79812: ST_TO_ADDR
// Bunker0 = [ [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] ] ;
79813: LD_ADDR_VAR 0 59
79817: PUSH
79818: LD_INT 1
79820: NEG
79821: PUSH
79822: LD_INT 2
79824: NEG
79825: PUSH
79826: EMPTY
79827: LIST
79828: LIST
79829: PUSH
79830: LD_INT 0
79832: PUSH
79833: LD_INT 2
79835: NEG
79836: PUSH
79837: EMPTY
79838: LIST
79839: LIST
79840: PUSH
79841: LD_INT 1
79843: PUSH
79844: LD_INT 1
79846: NEG
79847: PUSH
79848: EMPTY
79849: LIST
79850: LIST
79851: PUSH
79852: EMPTY
79853: LIST
79854: LIST
79855: LIST
79856: ST_TO_ADDR
// Bunker1 = [ [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] ] ;
79857: LD_ADDR_VAR 0 60
79861: PUSH
79862: LD_INT 1
79864: PUSH
79865: LD_INT 1
79867: NEG
79868: PUSH
79869: EMPTY
79870: LIST
79871: LIST
79872: PUSH
79873: LD_INT 2
79875: PUSH
79876: LD_INT 0
79878: PUSH
79879: EMPTY
79880: LIST
79881: LIST
79882: PUSH
79883: LD_INT 2
79885: PUSH
79886: LD_INT 1
79888: PUSH
79889: EMPTY
79890: LIST
79891: LIST
79892: PUSH
79893: EMPTY
79894: LIST
79895: LIST
79896: LIST
79897: ST_TO_ADDR
// Bunker2 = [ [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] ] ;
79898: LD_ADDR_VAR 0 61
79902: PUSH
79903: LD_INT 2
79905: PUSH
79906: LD_INT 1
79908: PUSH
79909: EMPTY
79910: LIST
79911: LIST
79912: PUSH
79913: LD_INT 2
79915: PUSH
79916: LD_INT 2
79918: PUSH
79919: EMPTY
79920: LIST
79921: LIST
79922: PUSH
79923: LD_INT 1
79925: PUSH
79926: LD_INT 2
79928: PUSH
79929: EMPTY
79930: LIST
79931: LIST
79932: PUSH
79933: EMPTY
79934: LIST
79935: LIST
79936: LIST
79937: ST_TO_ADDR
// Bunker3 = [ [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] ] ;
79938: LD_ADDR_VAR 0 62
79942: PUSH
79943: LD_INT 1
79945: PUSH
79946: LD_INT 2
79948: PUSH
79949: EMPTY
79950: LIST
79951: LIST
79952: PUSH
79953: LD_INT 0
79955: PUSH
79956: LD_INT 2
79958: PUSH
79959: EMPTY
79960: LIST
79961: LIST
79962: PUSH
79963: LD_INT 1
79965: NEG
79966: PUSH
79967: LD_INT 1
79969: PUSH
79970: EMPTY
79971: LIST
79972: LIST
79973: PUSH
79974: EMPTY
79975: LIST
79976: LIST
79977: LIST
79978: ST_TO_ADDR
// Bunker4 = [ [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] ] ;
79979: LD_ADDR_VAR 0 63
79983: PUSH
79984: LD_INT 1
79986: NEG
79987: PUSH
79988: LD_INT 1
79990: PUSH
79991: EMPTY
79992: LIST
79993: LIST
79994: PUSH
79995: LD_INT 2
79997: NEG
79998: PUSH
79999: LD_INT 0
80001: PUSH
80002: EMPTY
80003: LIST
80004: LIST
80005: PUSH
80006: LD_INT 2
80008: NEG
80009: PUSH
80010: LD_INT 1
80012: NEG
80013: PUSH
80014: EMPTY
80015: LIST
80016: LIST
80017: PUSH
80018: EMPTY
80019: LIST
80020: LIST
80021: LIST
80022: ST_TO_ADDR
// Bunker5 = [ [ - 1 , - 2 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
80023: LD_ADDR_VAR 0 64
80027: PUSH
80028: LD_INT 1
80030: NEG
80031: PUSH
80032: LD_INT 2
80034: NEG
80035: PUSH
80036: EMPTY
80037: LIST
80038: LIST
80039: PUSH
80040: LD_INT 2
80042: NEG
80043: PUSH
80044: LD_INT 1
80046: NEG
80047: PUSH
80048: EMPTY
80049: LIST
80050: LIST
80051: PUSH
80052: LD_INT 2
80054: NEG
80055: PUSH
80056: LD_INT 2
80058: NEG
80059: PUSH
80060: EMPTY
80061: LIST
80062: LIST
80063: PUSH
80064: EMPTY
80065: LIST
80066: LIST
80067: LIST
80068: ST_TO_ADDR
// end ; 2 :
80069: GO 83335
80071: LD_INT 2
80073: DOUBLE
80074: EQUAL
80075: IFTRUE 80079
80077: GO 83334
80079: POP
// begin Factory0 = [ [ 4 , 0 ] , [ 4 , - 1 ] , [ 5 , 0 ] , [ 5 , 1 ] , [ 4 , 1 ] , [ 3 , 0 ] , [ 3 , - 1 ] , [ 3 , - 2 ] , [ 5 , 2 ] , [ 3 , 3 ] , [ 3 , 2 ] , [ 4 , 3 ] , [ 4 , 4 ] , [ 3 , 4 ] , [ 2 , 3 ] , [ 2 , 2 ] , [ 4 , 2 ] , [ 2 , 4 ] , [ 0 , 4 ] , [ 0 , 3 ] , [ 1 , 4 ] , [ 1 , 5 ] , [ 0 , 5 ] , [ - 1 , 4 ] , [ - 1 , 3 ] , [ 2 , 5 ] , [ - 2 , 3 ] , [ - 3 , 0 ] , [ - 3 , - 1 ] , [ - 2 , 0 ] , [ - 2 , 1 ] , [ - 3 , 1 ] , [ - 4 , 0 ] , [ - 4 , - 1 ] , [ - 4 , - 2 ] , [ - 2 , 2 ] , [ - 4 , - 4 ] , [ - 4 , - 5 ] , [ - 3 , - 4 ] , [ - 3 , - 3 ] , [ - 4 , - 3 ] , [ - 5 , - 4 ] , [ - 5 , - 5 ] , [ - 3 , - 5 ] , [ - 5 , - 3 ] ] ;
80080: LD_ADDR_VAR 0 29
80084: PUSH
80085: LD_INT 4
80087: PUSH
80088: LD_INT 0
80090: PUSH
80091: EMPTY
80092: LIST
80093: LIST
80094: PUSH
80095: LD_INT 4
80097: PUSH
80098: LD_INT 1
80100: NEG
80101: PUSH
80102: EMPTY
80103: LIST
80104: LIST
80105: PUSH
80106: LD_INT 5
80108: PUSH
80109: LD_INT 0
80111: PUSH
80112: EMPTY
80113: LIST
80114: LIST
80115: PUSH
80116: LD_INT 5
80118: PUSH
80119: LD_INT 1
80121: PUSH
80122: EMPTY
80123: LIST
80124: LIST
80125: PUSH
80126: LD_INT 4
80128: PUSH
80129: LD_INT 1
80131: PUSH
80132: EMPTY
80133: LIST
80134: LIST
80135: PUSH
80136: LD_INT 3
80138: PUSH
80139: LD_INT 0
80141: PUSH
80142: EMPTY
80143: LIST
80144: LIST
80145: PUSH
80146: LD_INT 3
80148: PUSH
80149: LD_INT 1
80151: NEG
80152: PUSH
80153: EMPTY
80154: LIST
80155: LIST
80156: PUSH
80157: LD_INT 3
80159: PUSH
80160: LD_INT 2
80162: NEG
80163: PUSH
80164: EMPTY
80165: LIST
80166: LIST
80167: PUSH
80168: LD_INT 5
80170: PUSH
80171: LD_INT 2
80173: PUSH
80174: EMPTY
80175: LIST
80176: LIST
80177: PUSH
80178: LD_INT 3
80180: PUSH
80181: LD_INT 3
80183: PUSH
80184: EMPTY
80185: LIST
80186: LIST
80187: PUSH
80188: LD_INT 3
80190: PUSH
80191: LD_INT 2
80193: PUSH
80194: EMPTY
80195: LIST
80196: LIST
80197: PUSH
80198: LD_INT 4
80200: PUSH
80201: LD_INT 3
80203: PUSH
80204: EMPTY
80205: LIST
80206: LIST
80207: PUSH
80208: LD_INT 4
80210: PUSH
80211: LD_INT 4
80213: PUSH
80214: EMPTY
80215: LIST
80216: LIST
80217: PUSH
80218: LD_INT 3
80220: PUSH
80221: LD_INT 4
80223: PUSH
80224: EMPTY
80225: LIST
80226: LIST
80227: PUSH
80228: LD_INT 2
80230: PUSH
80231: LD_INT 3
80233: PUSH
80234: EMPTY
80235: LIST
80236: LIST
80237: PUSH
80238: LD_INT 2
80240: PUSH
80241: LD_INT 2
80243: PUSH
80244: EMPTY
80245: LIST
80246: LIST
80247: PUSH
80248: LD_INT 4
80250: PUSH
80251: LD_INT 2
80253: PUSH
80254: EMPTY
80255: LIST
80256: LIST
80257: PUSH
80258: LD_INT 2
80260: PUSH
80261: LD_INT 4
80263: PUSH
80264: EMPTY
80265: LIST
80266: LIST
80267: PUSH
80268: LD_INT 0
80270: PUSH
80271: LD_INT 4
80273: PUSH
80274: EMPTY
80275: LIST
80276: LIST
80277: PUSH
80278: LD_INT 0
80280: PUSH
80281: LD_INT 3
80283: PUSH
80284: EMPTY
80285: LIST
80286: LIST
80287: PUSH
80288: LD_INT 1
80290: PUSH
80291: LD_INT 4
80293: PUSH
80294: EMPTY
80295: LIST
80296: LIST
80297: PUSH
80298: LD_INT 1
80300: PUSH
80301: LD_INT 5
80303: PUSH
80304: EMPTY
80305: LIST
80306: LIST
80307: PUSH
80308: LD_INT 0
80310: PUSH
80311: LD_INT 5
80313: PUSH
80314: EMPTY
80315: LIST
80316: LIST
80317: PUSH
80318: LD_INT 1
80320: NEG
80321: PUSH
80322: LD_INT 4
80324: PUSH
80325: EMPTY
80326: LIST
80327: LIST
80328: PUSH
80329: LD_INT 1
80331: NEG
80332: PUSH
80333: LD_INT 3
80335: PUSH
80336: EMPTY
80337: LIST
80338: LIST
80339: PUSH
80340: LD_INT 2
80342: PUSH
80343: LD_INT 5
80345: PUSH
80346: EMPTY
80347: LIST
80348: LIST
80349: PUSH
80350: LD_INT 2
80352: NEG
80353: PUSH
80354: LD_INT 3
80356: PUSH
80357: EMPTY
80358: LIST
80359: LIST
80360: PUSH
80361: LD_INT 3
80363: NEG
80364: PUSH
80365: LD_INT 0
80367: PUSH
80368: EMPTY
80369: LIST
80370: LIST
80371: PUSH
80372: LD_INT 3
80374: NEG
80375: PUSH
80376: LD_INT 1
80378: NEG
80379: PUSH
80380: EMPTY
80381: LIST
80382: LIST
80383: PUSH
80384: LD_INT 2
80386: NEG
80387: PUSH
80388: LD_INT 0
80390: PUSH
80391: EMPTY
80392: LIST
80393: LIST
80394: PUSH
80395: LD_INT 2
80397: NEG
80398: PUSH
80399: LD_INT 1
80401: PUSH
80402: EMPTY
80403: LIST
80404: LIST
80405: PUSH
80406: LD_INT 3
80408: NEG
80409: PUSH
80410: LD_INT 1
80412: PUSH
80413: EMPTY
80414: LIST
80415: LIST
80416: PUSH
80417: LD_INT 4
80419: NEG
80420: PUSH
80421: LD_INT 0
80423: PUSH
80424: EMPTY
80425: LIST
80426: LIST
80427: PUSH
80428: LD_INT 4
80430: NEG
80431: PUSH
80432: LD_INT 1
80434: NEG
80435: PUSH
80436: EMPTY
80437: LIST
80438: LIST
80439: PUSH
80440: LD_INT 4
80442: NEG
80443: PUSH
80444: LD_INT 2
80446: NEG
80447: PUSH
80448: EMPTY
80449: LIST
80450: LIST
80451: PUSH
80452: LD_INT 2
80454: NEG
80455: PUSH
80456: LD_INT 2
80458: PUSH
80459: EMPTY
80460: LIST
80461: LIST
80462: PUSH
80463: LD_INT 4
80465: NEG
80466: PUSH
80467: LD_INT 4
80469: NEG
80470: PUSH
80471: EMPTY
80472: LIST
80473: LIST
80474: PUSH
80475: LD_INT 4
80477: NEG
80478: PUSH
80479: LD_INT 5
80481: NEG
80482: PUSH
80483: EMPTY
80484: LIST
80485: LIST
80486: PUSH
80487: LD_INT 3
80489: NEG
80490: PUSH
80491: LD_INT 4
80493: NEG
80494: PUSH
80495: EMPTY
80496: LIST
80497: LIST
80498: PUSH
80499: LD_INT 3
80501: NEG
80502: PUSH
80503: LD_INT 3
80505: NEG
80506: PUSH
80507: EMPTY
80508: LIST
80509: LIST
80510: PUSH
80511: LD_INT 4
80513: NEG
80514: PUSH
80515: LD_INT 3
80517: NEG
80518: PUSH
80519: EMPTY
80520: LIST
80521: LIST
80522: PUSH
80523: LD_INT 5
80525: NEG
80526: PUSH
80527: LD_INT 4
80529: NEG
80530: PUSH
80531: EMPTY
80532: LIST
80533: LIST
80534: PUSH
80535: LD_INT 5
80537: NEG
80538: PUSH
80539: LD_INT 5
80541: NEG
80542: PUSH
80543: EMPTY
80544: LIST
80545: LIST
80546: PUSH
80547: LD_INT 3
80549: NEG
80550: PUSH
80551: LD_INT 5
80553: NEG
80554: PUSH
80555: EMPTY
80556: LIST
80557: LIST
80558: PUSH
80559: LD_INT 5
80561: NEG
80562: PUSH
80563: LD_INT 3
80565: NEG
80566: PUSH
80567: EMPTY
80568: LIST
80569: LIST
80570: PUSH
80571: EMPTY
80572: LIST
80573: LIST
80574: LIST
80575: LIST
80576: LIST
80577: LIST
80578: LIST
80579: LIST
80580: LIST
80581: LIST
80582: LIST
80583: LIST
80584: LIST
80585: LIST
80586: LIST
80587: LIST
80588: LIST
80589: LIST
80590: LIST
80591: LIST
80592: LIST
80593: LIST
80594: LIST
80595: LIST
80596: LIST
80597: LIST
80598: LIST
80599: LIST
80600: LIST
80601: LIST
80602: LIST
80603: LIST
80604: LIST
80605: LIST
80606: LIST
80607: LIST
80608: LIST
80609: LIST
80610: LIST
80611: LIST
80612: LIST
80613: LIST
80614: LIST
80615: LIST
80616: LIST
80617: ST_TO_ADDR
// Factory1 = [ [ 4 , 4 ] , [ 4 , 3 ] , [ 5 , 4 ] , [ 5 , 5 ] , [ 4 , 5 ] , [ 3 , 4 ] , [ 3 , 3 ] , [ 5 , 3 ] , [ 3 , 5 ] , [ 0 , 3 ] , [ 0 , 2 ] , [ 1 , 3 ] , [ 1 , 4 ] , [ 0 , 4 ] , [ - 1 , 3 ] , [ - 1 , 2 ] , [ 2 , 4 ] , [ - 2 , 2 ] , [ - 4 , 0 ] , [ - 4 , - 1 ] , [ - 3 , 0 ] , [ - 3 , 1 ] , [ - 4 , 1 ] , [ - 5 , 0 ] , [ - 5 , - 1 ] , [ - 5 , - 2 ] , [ - 3 , 2 ] , [ - 3 , - 3 ] , [ - 3 , - 4 ] , [ - 2 , - 3 ] , [ - 2 , - 2 ] , [ - 3 , - 2 ] , [ - 4 , - 3 ] , [ - 4 , - 4 ] , [ - 2 , - 4 ] , [ - 4 , - 2 ] , [ 0 , - 4 ] , [ 0 , - 5 ] , [ 1 , - 4 ] , [ 1 , - 3 ] , [ 0 , - 3 ] , [ - 1 , - 4 ] , [ - 1 , - 5 ] , [ 2 , - 3 ] , [ - 2 , - 5 ] ] ;
80618: LD_ADDR_VAR 0 30
80622: PUSH
80623: LD_INT 4
80625: PUSH
80626: LD_INT 4
80628: PUSH
80629: EMPTY
80630: LIST
80631: LIST
80632: PUSH
80633: LD_INT 4
80635: PUSH
80636: LD_INT 3
80638: PUSH
80639: EMPTY
80640: LIST
80641: LIST
80642: PUSH
80643: LD_INT 5
80645: PUSH
80646: LD_INT 4
80648: PUSH
80649: EMPTY
80650: LIST
80651: LIST
80652: PUSH
80653: LD_INT 5
80655: PUSH
80656: LD_INT 5
80658: PUSH
80659: EMPTY
80660: LIST
80661: LIST
80662: PUSH
80663: LD_INT 4
80665: PUSH
80666: LD_INT 5
80668: PUSH
80669: EMPTY
80670: LIST
80671: LIST
80672: PUSH
80673: LD_INT 3
80675: PUSH
80676: LD_INT 4
80678: PUSH
80679: EMPTY
80680: LIST
80681: LIST
80682: PUSH
80683: LD_INT 3
80685: PUSH
80686: LD_INT 3
80688: PUSH
80689: EMPTY
80690: LIST
80691: LIST
80692: PUSH
80693: LD_INT 5
80695: PUSH
80696: LD_INT 3
80698: PUSH
80699: EMPTY
80700: LIST
80701: LIST
80702: PUSH
80703: LD_INT 3
80705: PUSH
80706: LD_INT 5
80708: PUSH
80709: EMPTY
80710: LIST
80711: LIST
80712: PUSH
80713: LD_INT 0
80715: PUSH
80716: LD_INT 3
80718: PUSH
80719: EMPTY
80720: LIST
80721: LIST
80722: PUSH
80723: LD_INT 0
80725: PUSH
80726: LD_INT 2
80728: PUSH
80729: EMPTY
80730: LIST
80731: LIST
80732: PUSH
80733: LD_INT 1
80735: PUSH
80736: LD_INT 3
80738: PUSH
80739: EMPTY
80740: LIST
80741: LIST
80742: PUSH
80743: LD_INT 1
80745: PUSH
80746: LD_INT 4
80748: PUSH
80749: EMPTY
80750: LIST
80751: LIST
80752: PUSH
80753: LD_INT 0
80755: PUSH
80756: LD_INT 4
80758: PUSH
80759: EMPTY
80760: LIST
80761: LIST
80762: PUSH
80763: LD_INT 1
80765: NEG
80766: PUSH
80767: LD_INT 3
80769: PUSH
80770: EMPTY
80771: LIST
80772: LIST
80773: PUSH
80774: LD_INT 1
80776: NEG
80777: PUSH
80778: LD_INT 2
80780: PUSH
80781: EMPTY
80782: LIST
80783: LIST
80784: PUSH
80785: LD_INT 2
80787: PUSH
80788: LD_INT 4
80790: PUSH
80791: EMPTY
80792: LIST
80793: LIST
80794: PUSH
80795: LD_INT 2
80797: NEG
80798: PUSH
80799: LD_INT 2
80801: PUSH
80802: EMPTY
80803: LIST
80804: LIST
80805: PUSH
80806: LD_INT 4
80808: NEG
80809: PUSH
80810: LD_INT 0
80812: PUSH
80813: EMPTY
80814: LIST
80815: LIST
80816: PUSH
80817: LD_INT 4
80819: NEG
80820: PUSH
80821: LD_INT 1
80823: NEG
80824: PUSH
80825: EMPTY
80826: LIST
80827: LIST
80828: PUSH
80829: LD_INT 3
80831: NEG
80832: PUSH
80833: LD_INT 0
80835: PUSH
80836: EMPTY
80837: LIST
80838: LIST
80839: PUSH
80840: LD_INT 3
80842: NEG
80843: PUSH
80844: LD_INT 1
80846: PUSH
80847: EMPTY
80848: LIST
80849: LIST
80850: PUSH
80851: LD_INT 4
80853: NEG
80854: PUSH
80855: LD_INT 1
80857: PUSH
80858: EMPTY
80859: LIST
80860: LIST
80861: PUSH
80862: LD_INT 5
80864: NEG
80865: PUSH
80866: LD_INT 0
80868: PUSH
80869: EMPTY
80870: LIST
80871: LIST
80872: PUSH
80873: LD_INT 5
80875: NEG
80876: PUSH
80877: LD_INT 1
80879: NEG
80880: PUSH
80881: EMPTY
80882: LIST
80883: LIST
80884: PUSH
80885: LD_INT 5
80887: NEG
80888: PUSH
80889: LD_INT 2
80891: NEG
80892: PUSH
80893: EMPTY
80894: LIST
80895: LIST
80896: PUSH
80897: LD_INT 3
80899: NEG
80900: PUSH
80901: LD_INT 2
80903: PUSH
80904: EMPTY
80905: LIST
80906: LIST
80907: PUSH
80908: LD_INT 3
80910: NEG
80911: PUSH
80912: LD_INT 3
80914: NEG
80915: PUSH
80916: EMPTY
80917: LIST
80918: LIST
80919: PUSH
80920: LD_INT 3
80922: NEG
80923: PUSH
80924: LD_INT 4
80926: NEG
80927: PUSH
80928: EMPTY
80929: LIST
80930: LIST
80931: PUSH
80932: LD_INT 2
80934: NEG
80935: PUSH
80936: LD_INT 3
80938: NEG
80939: PUSH
80940: EMPTY
80941: LIST
80942: LIST
80943: PUSH
80944: LD_INT 2
80946: NEG
80947: PUSH
80948: LD_INT 2
80950: NEG
80951: PUSH
80952: EMPTY
80953: LIST
80954: LIST
80955: PUSH
80956: LD_INT 3
80958: NEG
80959: PUSH
80960: LD_INT 2
80962: NEG
80963: PUSH
80964: EMPTY
80965: LIST
80966: LIST
80967: PUSH
80968: LD_INT 4
80970: NEG
80971: PUSH
80972: LD_INT 3
80974: NEG
80975: PUSH
80976: EMPTY
80977: LIST
80978: LIST
80979: PUSH
80980: LD_INT 4
80982: NEG
80983: PUSH
80984: LD_INT 4
80986: NEG
80987: PUSH
80988: EMPTY
80989: LIST
80990: LIST
80991: PUSH
80992: LD_INT 2
80994: NEG
80995: PUSH
80996: LD_INT 4
80998: NEG
80999: PUSH
81000: EMPTY
81001: LIST
81002: LIST
81003: PUSH
81004: LD_INT 4
81006: NEG
81007: PUSH
81008: LD_INT 2
81010: NEG
81011: PUSH
81012: EMPTY
81013: LIST
81014: LIST
81015: PUSH
81016: LD_INT 0
81018: PUSH
81019: LD_INT 4
81021: NEG
81022: PUSH
81023: EMPTY
81024: LIST
81025: LIST
81026: PUSH
81027: LD_INT 0
81029: PUSH
81030: LD_INT 5
81032: NEG
81033: PUSH
81034: EMPTY
81035: LIST
81036: LIST
81037: PUSH
81038: LD_INT 1
81040: PUSH
81041: LD_INT 4
81043: NEG
81044: PUSH
81045: EMPTY
81046: LIST
81047: LIST
81048: PUSH
81049: LD_INT 1
81051: PUSH
81052: LD_INT 3
81054: NEG
81055: PUSH
81056: EMPTY
81057: LIST
81058: LIST
81059: PUSH
81060: LD_INT 0
81062: PUSH
81063: LD_INT 3
81065: NEG
81066: PUSH
81067: EMPTY
81068: LIST
81069: LIST
81070: PUSH
81071: LD_INT 1
81073: NEG
81074: PUSH
81075: LD_INT 4
81077: NEG
81078: PUSH
81079: EMPTY
81080: LIST
81081: LIST
81082: PUSH
81083: LD_INT 1
81085: NEG
81086: PUSH
81087: LD_INT 5
81089: NEG
81090: PUSH
81091: EMPTY
81092: LIST
81093: LIST
81094: PUSH
81095: LD_INT 2
81097: PUSH
81098: LD_INT 3
81100: NEG
81101: PUSH
81102: EMPTY
81103: LIST
81104: LIST
81105: PUSH
81106: LD_INT 2
81108: NEG
81109: PUSH
81110: LD_INT 5
81112: NEG
81113: PUSH
81114: EMPTY
81115: LIST
81116: LIST
81117: PUSH
81118: EMPTY
81119: LIST
81120: LIST
81121: LIST
81122: LIST
81123: LIST
81124: LIST
81125: LIST
81126: LIST
81127: LIST
81128: LIST
81129: LIST
81130: LIST
81131: LIST
81132: LIST
81133: LIST
81134: LIST
81135: LIST
81136: LIST
81137: LIST
81138: LIST
81139: LIST
81140: LIST
81141: LIST
81142: LIST
81143: LIST
81144: LIST
81145: LIST
81146: LIST
81147: LIST
81148: LIST
81149: LIST
81150: LIST
81151: LIST
81152: LIST
81153: LIST
81154: LIST
81155: LIST
81156: LIST
81157: LIST
81158: LIST
81159: LIST
81160: LIST
81161: LIST
81162: LIST
81163: LIST
81164: ST_TO_ADDR
// Factory2 = [ [ 0 , 4 ] , [ 0 , 3 ] , [ 1 , 4 ] , [ 1 , 5 ] , [ 0 , 5 ] , [ - 1 , 4 ] , [ - 1 , 3 ] , [ 2 , 5 ] , [ - 2 , 3 ] , [ - 3 , 0 ] , [ - 3 , - 1 ] , [ - 2 , 0 ] , [ - 2 , 1 ] , [ - 3 , 1 ] , [ - 4 , 0 ] , [ - 4 , - 1 ] , [ - 4 , - 2 ] , [ - 2 , 2 ] , [ - 4 , - 4 ] , [ - 4 , - 5 ] , [ - 3 , - 4 ] , [ - 3 , - 3 ] , [ - 4 , - 3 ] , [ - 5 , - 4 ] , [ - 5 , - 5 ] , [ - 3 , - 5 ] , [ - 5 , - 3 ] , [ 0 , - 3 ] , [ 0 , - 4 ] , [ 1 , - 3 ] , [ 1 , - 2 ] , [ 0 , - 2 ] , [ - 1 , - 3 ] , [ - 1 , - 4 ] , [ 2 , - 2 ] , [ - 2 , - 4 ] , [ 4 , 0 ] , [ 4 , - 1 ] , [ 5 , 0 ] , [ 5 , 1 ] , [ 4 , 1 ] , [ 3 , 0 ] , [ 3 , - 1 ] , [ 3 , - 2 ] , [ 5 , 2 ] ] ;
81165: LD_ADDR_VAR 0 31
81169: PUSH
81170: LD_INT 0
81172: PUSH
81173: LD_INT 4
81175: PUSH
81176: EMPTY
81177: LIST
81178: LIST
81179: PUSH
81180: LD_INT 0
81182: PUSH
81183: LD_INT 3
81185: PUSH
81186: EMPTY
81187: LIST
81188: LIST
81189: PUSH
81190: LD_INT 1
81192: PUSH
81193: LD_INT 4
81195: PUSH
81196: EMPTY
81197: LIST
81198: LIST
81199: PUSH
81200: LD_INT 1
81202: PUSH
81203: LD_INT 5
81205: PUSH
81206: EMPTY
81207: LIST
81208: LIST
81209: PUSH
81210: LD_INT 0
81212: PUSH
81213: LD_INT 5
81215: PUSH
81216: EMPTY
81217: LIST
81218: LIST
81219: PUSH
81220: LD_INT 1
81222: NEG
81223: PUSH
81224: LD_INT 4
81226: PUSH
81227: EMPTY
81228: LIST
81229: LIST
81230: PUSH
81231: LD_INT 1
81233: NEG
81234: PUSH
81235: LD_INT 3
81237: PUSH
81238: EMPTY
81239: LIST
81240: LIST
81241: PUSH
81242: LD_INT 2
81244: PUSH
81245: LD_INT 5
81247: PUSH
81248: EMPTY
81249: LIST
81250: LIST
81251: PUSH
81252: LD_INT 2
81254: NEG
81255: PUSH
81256: LD_INT 3
81258: PUSH
81259: EMPTY
81260: LIST
81261: LIST
81262: PUSH
81263: LD_INT 3
81265: NEG
81266: PUSH
81267: LD_INT 0
81269: PUSH
81270: EMPTY
81271: LIST
81272: LIST
81273: PUSH
81274: LD_INT 3
81276: NEG
81277: PUSH
81278: LD_INT 1
81280: NEG
81281: PUSH
81282: EMPTY
81283: LIST
81284: LIST
81285: PUSH
81286: LD_INT 2
81288: NEG
81289: PUSH
81290: LD_INT 0
81292: PUSH
81293: EMPTY
81294: LIST
81295: LIST
81296: PUSH
81297: LD_INT 2
81299: NEG
81300: PUSH
81301: LD_INT 1
81303: PUSH
81304: EMPTY
81305: LIST
81306: LIST
81307: PUSH
81308: LD_INT 3
81310: NEG
81311: PUSH
81312: LD_INT 1
81314: PUSH
81315: EMPTY
81316: LIST
81317: LIST
81318: PUSH
81319: LD_INT 4
81321: NEG
81322: PUSH
81323: LD_INT 0
81325: PUSH
81326: EMPTY
81327: LIST
81328: LIST
81329: PUSH
81330: LD_INT 4
81332: NEG
81333: PUSH
81334: LD_INT 1
81336: NEG
81337: PUSH
81338: EMPTY
81339: LIST
81340: LIST
81341: PUSH
81342: LD_INT 4
81344: NEG
81345: PUSH
81346: LD_INT 2
81348: NEG
81349: PUSH
81350: EMPTY
81351: LIST
81352: LIST
81353: PUSH
81354: LD_INT 2
81356: NEG
81357: PUSH
81358: LD_INT 2
81360: PUSH
81361: EMPTY
81362: LIST
81363: LIST
81364: PUSH
81365: LD_INT 4
81367: NEG
81368: PUSH
81369: LD_INT 4
81371: NEG
81372: PUSH
81373: EMPTY
81374: LIST
81375: LIST
81376: PUSH
81377: LD_INT 4
81379: NEG
81380: PUSH
81381: LD_INT 5
81383: NEG
81384: PUSH
81385: EMPTY
81386: LIST
81387: LIST
81388: PUSH
81389: LD_INT 3
81391: NEG
81392: PUSH
81393: LD_INT 4
81395: NEG
81396: PUSH
81397: EMPTY
81398: LIST
81399: LIST
81400: PUSH
81401: LD_INT 3
81403: NEG
81404: PUSH
81405: LD_INT 3
81407: NEG
81408: PUSH
81409: EMPTY
81410: LIST
81411: LIST
81412: PUSH
81413: LD_INT 4
81415: NEG
81416: PUSH
81417: LD_INT 3
81419: NEG
81420: PUSH
81421: EMPTY
81422: LIST
81423: LIST
81424: PUSH
81425: LD_INT 5
81427: NEG
81428: PUSH
81429: LD_INT 4
81431: NEG
81432: PUSH
81433: EMPTY
81434: LIST
81435: LIST
81436: PUSH
81437: LD_INT 5
81439: NEG
81440: PUSH
81441: LD_INT 5
81443: NEG
81444: PUSH
81445: EMPTY
81446: LIST
81447: LIST
81448: PUSH
81449: LD_INT 3
81451: NEG
81452: PUSH
81453: LD_INT 5
81455: NEG
81456: PUSH
81457: EMPTY
81458: LIST
81459: LIST
81460: PUSH
81461: LD_INT 5
81463: NEG
81464: PUSH
81465: LD_INT 3
81467: NEG
81468: PUSH
81469: EMPTY
81470: LIST
81471: LIST
81472: PUSH
81473: LD_INT 0
81475: PUSH
81476: LD_INT 3
81478: NEG
81479: PUSH
81480: EMPTY
81481: LIST
81482: LIST
81483: PUSH
81484: LD_INT 0
81486: PUSH
81487: LD_INT 4
81489: NEG
81490: PUSH
81491: EMPTY
81492: LIST
81493: LIST
81494: PUSH
81495: LD_INT 1
81497: PUSH
81498: LD_INT 3
81500: NEG
81501: PUSH
81502: EMPTY
81503: LIST
81504: LIST
81505: PUSH
81506: LD_INT 1
81508: PUSH
81509: LD_INT 2
81511: NEG
81512: PUSH
81513: EMPTY
81514: LIST
81515: LIST
81516: PUSH
81517: LD_INT 0
81519: PUSH
81520: LD_INT 2
81522: NEG
81523: PUSH
81524: EMPTY
81525: LIST
81526: LIST
81527: PUSH
81528: LD_INT 1
81530: NEG
81531: PUSH
81532: LD_INT 3
81534: NEG
81535: PUSH
81536: EMPTY
81537: LIST
81538: LIST
81539: PUSH
81540: LD_INT 1
81542: NEG
81543: PUSH
81544: LD_INT 4
81546: NEG
81547: PUSH
81548: EMPTY
81549: LIST
81550: LIST
81551: PUSH
81552: LD_INT 2
81554: PUSH
81555: LD_INT 2
81557: NEG
81558: PUSH
81559: EMPTY
81560: LIST
81561: LIST
81562: PUSH
81563: LD_INT 2
81565: NEG
81566: PUSH
81567: LD_INT 4
81569: NEG
81570: PUSH
81571: EMPTY
81572: LIST
81573: LIST
81574: PUSH
81575: LD_INT 4
81577: PUSH
81578: LD_INT 0
81580: PUSH
81581: EMPTY
81582: LIST
81583: LIST
81584: PUSH
81585: LD_INT 4
81587: PUSH
81588: LD_INT 1
81590: NEG
81591: PUSH
81592: EMPTY
81593: LIST
81594: LIST
81595: PUSH
81596: LD_INT 5
81598: PUSH
81599: LD_INT 0
81601: PUSH
81602: EMPTY
81603: LIST
81604: LIST
81605: PUSH
81606: LD_INT 5
81608: PUSH
81609: LD_INT 1
81611: PUSH
81612: EMPTY
81613: LIST
81614: LIST
81615: PUSH
81616: LD_INT 4
81618: PUSH
81619: LD_INT 1
81621: PUSH
81622: EMPTY
81623: LIST
81624: LIST
81625: PUSH
81626: LD_INT 3
81628: PUSH
81629: LD_INT 0
81631: PUSH
81632: EMPTY
81633: LIST
81634: LIST
81635: PUSH
81636: LD_INT 3
81638: PUSH
81639: LD_INT 1
81641: NEG
81642: PUSH
81643: EMPTY
81644: LIST
81645: LIST
81646: PUSH
81647: LD_INT 3
81649: PUSH
81650: LD_INT 2
81652: NEG
81653: PUSH
81654: EMPTY
81655: LIST
81656: LIST
81657: PUSH
81658: LD_INT 5
81660: PUSH
81661: LD_INT 2
81663: PUSH
81664: EMPTY
81665: LIST
81666: LIST
81667: PUSH
81668: EMPTY
81669: LIST
81670: LIST
81671: LIST
81672: LIST
81673: LIST
81674: LIST
81675: LIST
81676: LIST
81677: LIST
81678: LIST
81679: LIST
81680: LIST
81681: LIST
81682: LIST
81683: LIST
81684: LIST
81685: LIST
81686: LIST
81687: LIST
81688: LIST
81689: LIST
81690: LIST
81691: LIST
81692: LIST
81693: LIST
81694: LIST
81695: LIST
81696: LIST
81697: LIST
81698: LIST
81699: LIST
81700: LIST
81701: LIST
81702: LIST
81703: LIST
81704: LIST
81705: LIST
81706: LIST
81707: LIST
81708: LIST
81709: LIST
81710: LIST
81711: LIST
81712: LIST
81713: LIST
81714: ST_TO_ADDR
// Factory3 = [ [ - 4 , 0 ] , [ - 4 , - 1 ] , [ - 3 , 0 ] , [ - 3 , 1 ] , [ - 4 , 1 ] , [ - 5 , 0 ] , [ - 5 , - 1 ] , [ - 5 , - 2 ] , [ - 3 , 2 ] , [ - 3 , - 3 ] , [ - 3 , - 4 ] , [ - 2 , - 3 ] , [ - 2 , - 2 ] , [ - 3 , - 2 ] , [ - 4 , - 3 ] , [ - 4 , - 4 ] , [ - 2 , - 4 ] , [ - 4 , - 2 ] , [ 0 , - 4 ] , [ 0 , - 5 ] , [ 1 , - 4 ] , [ 1 , - 3 ] , [ 0 , - 3 ] , [ - 1 , - 4 ] , [ - 1 , - 5 ] , [ 2 , - 3 ] , [ - 2 , - 5 ] , [ 3 , 0 ] , [ 3 , - 1 ] , [ 4 , 0 ] , [ 4 , 1 ] , [ 3 , 1 ] , [ 2 , 0 ] , [ 2 , - 1 ] , [ 2 , - 2 ] , [ 4 , 2 ] , [ 4 , 4 ] , [ 4 , 3 ] , [ 5 , 4 ] , [ 5 , 5 ] , [ 4 , 5 ] , [ 3 , 4 ] , [ 3 , 3 ] , [ 5 , 3 ] , [ 3 , 5 ] ] ;
81715: LD_ADDR_VAR 0 32
81719: PUSH
81720: LD_INT 4
81722: NEG
81723: PUSH
81724: LD_INT 0
81726: PUSH
81727: EMPTY
81728: LIST
81729: LIST
81730: PUSH
81731: LD_INT 4
81733: NEG
81734: PUSH
81735: LD_INT 1
81737: NEG
81738: PUSH
81739: EMPTY
81740: LIST
81741: LIST
81742: PUSH
81743: LD_INT 3
81745: NEG
81746: PUSH
81747: LD_INT 0
81749: PUSH
81750: EMPTY
81751: LIST
81752: LIST
81753: PUSH
81754: LD_INT 3
81756: NEG
81757: PUSH
81758: LD_INT 1
81760: PUSH
81761: EMPTY
81762: LIST
81763: LIST
81764: PUSH
81765: LD_INT 4
81767: NEG
81768: PUSH
81769: LD_INT 1
81771: PUSH
81772: EMPTY
81773: LIST
81774: LIST
81775: PUSH
81776: LD_INT 5
81778: NEG
81779: PUSH
81780: LD_INT 0
81782: PUSH
81783: EMPTY
81784: LIST
81785: LIST
81786: PUSH
81787: LD_INT 5
81789: NEG
81790: PUSH
81791: LD_INT 1
81793: NEG
81794: PUSH
81795: EMPTY
81796: LIST
81797: LIST
81798: PUSH
81799: LD_INT 5
81801: NEG
81802: PUSH
81803: LD_INT 2
81805: NEG
81806: PUSH
81807: EMPTY
81808: LIST
81809: LIST
81810: PUSH
81811: LD_INT 3
81813: NEG
81814: PUSH
81815: LD_INT 2
81817: PUSH
81818: EMPTY
81819: LIST
81820: LIST
81821: PUSH
81822: LD_INT 3
81824: NEG
81825: PUSH
81826: LD_INT 3
81828: NEG
81829: PUSH
81830: EMPTY
81831: LIST
81832: LIST
81833: PUSH
81834: LD_INT 3
81836: NEG
81837: PUSH
81838: LD_INT 4
81840: NEG
81841: PUSH
81842: EMPTY
81843: LIST
81844: LIST
81845: PUSH
81846: LD_INT 2
81848: NEG
81849: PUSH
81850: LD_INT 3
81852: NEG
81853: PUSH
81854: EMPTY
81855: LIST
81856: LIST
81857: PUSH
81858: LD_INT 2
81860: NEG
81861: PUSH
81862: LD_INT 2
81864: NEG
81865: PUSH
81866: EMPTY
81867: LIST
81868: LIST
81869: PUSH
81870: LD_INT 3
81872: NEG
81873: PUSH
81874: LD_INT 2
81876: NEG
81877: PUSH
81878: EMPTY
81879: LIST
81880: LIST
81881: PUSH
81882: LD_INT 4
81884: NEG
81885: PUSH
81886: LD_INT 3
81888: NEG
81889: PUSH
81890: EMPTY
81891: LIST
81892: LIST
81893: PUSH
81894: LD_INT 4
81896: NEG
81897: PUSH
81898: LD_INT 4
81900: NEG
81901: PUSH
81902: EMPTY
81903: LIST
81904: LIST
81905: PUSH
81906: LD_INT 2
81908: NEG
81909: PUSH
81910: LD_INT 4
81912: NEG
81913: PUSH
81914: EMPTY
81915: LIST
81916: LIST
81917: PUSH
81918: LD_INT 4
81920: NEG
81921: PUSH
81922: LD_INT 2
81924: NEG
81925: PUSH
81926: EMPTY
81927: LIST
81928: LIST
81929: PUSH
81930: LD_INT 0
81932: PUSH
81933: LD_INT 4
81935: NEG
81936: PUSH
81937: EMPTY
81938: LIST
81939: LIST
81940: PUSH
81941: LD_INT 0
81943: PUSH
81944: LD_INT 5
81946: NEG
81947: PUSH
81948: EMPTY
81949: LIST
81950: LIST
81951: PUSH
81952: LD_INT 1
81954: PUSH
81955: LD_INT 4
81957: NEG
81958: PUSH
81959: EMPTY
81960: LIST
81961: LIST
81962: PUSH
81963: LD_INT 1
81965: PUSH
81966: LD_INT 3
81968: NEG
81969: PUSH
81970: EMPTY
81971: LIST
81972: LIST
81973: PUSH
81974: LD_INT 0
81976: PUSH
81977: LD_INT 3
81979: NEG
81980: PUSH
81981: EMPTY
81982: LIST
81983: LIST
81984: PUSH
81985: LD_INT 1
81987: NEG
81988: PUSH
81989: LD_INT 4
81991: NEG
81992: PUSH
81993: EMPTY
81994: LIST
81995: LIST
81996: PUSH
81997: LD_INT 1
81999: NEG
82000: PUSH
82001: LD_INT 5
82003: NEG
82004: PUSH
82005: EMPTY
82006: LIST
82007: LIST
82008: PUSH
82009: LD_INT 2
82011: PUSH
82012: LD_INT 3
82014: NEG
82015: PUSH
82016: EMPTY
82017: LIST
82018: LIST
82019: PUSH
82020: LD_INT 2
82022: NEG
82023: PUSH
82024: LD_INT 5
82026: NEG
82027: PUSH
82028: EMPTY
82029: LIST
82030: LIST
82031: PUSH
82032: LD_INT 3
82034: PUSH
82035: LD_INT 0
82037: PUSH
82038: EMPTY
82039: LIST
82040: LIST
82041: PUSH
82042: LD_INT 3
82044: PUSH
82045: LD_INT 1
82047: NEG
82048: PUSH
82049: EMPTY
82050: LIST
82051: LIST
82052: PUSH
82053: LD_INT 4
82055: PUSH
82056: LD_INT 0
82058: PUSH
82059: EMPTY
82060: LIST
82061: LIST
82062: PUSH
82063: LD_INT 4
82065: PUSH
82066: LD_INT 1
82068: PUSH
82069: EMPTY
82070: LIST
82071: LIST
82072: PUSH
82073: LD_INT 3
82075: PUSH
82076: LD_INT 1
82078: PUSH
82079: EMPTY
82080: LIST
82081: LIST
82082: PUSH
82083: LD_INT 2
82085: PUSH
82086: LD_INT 0
82088: PUSH
82089: EMPTY
82090: LIST
82091: LIST
82092: PUSH
82093: LD_INT 2
82095: PUSH
82096: LD_INT 1
82098: NEG
82099: PUSH
82100: EMPTY
82101: LIST
82102: LIST
82103: PUSH
82104: LD_INT 2
82106: PUSH
82107: LD_INT 2
82109: NEG
82110: PUSH
82111: EMPTY
82112: LIST
82113: LIST
82114: PUSH
82115: LD_INT 4
82117: PUSH
82118: LD_INT 2
82120: PUSH
82121: EMPTY
82122: LIST
82123: LIST
82124: PUSH
82125: LD_INT 4
82127: PUSH
82128: LD_INT 4
82130: PUSH
82131: EMPTY
82132: LIST
82133: LIST
82134: PUSH
82135: LD_INT 4
82137: PUSH
82138: LD_INT 3
82140: PUSH
82141: EMPTY
82142: LIST
82143: LIST
82144: PUSH
82145: LD_INT 5
82147: PUSH
82148: LD_INT 4
82150: PUSH
82151: EMPTY
82152: LIST
82153: LIST
82154: PUSH
82155: LD_INT 5
82157: PUSH
82158: LD_INT 5
82160: PUSH
82161: EMPTY
82162: LIST
82163: LIST
82164: PUSH
82165: LD_INT 4
82167: PUSH
82168: LD_INT 5
82170: PUSH
82171: EMPTY
82172: LIST
82173: LIST
82174: PUSH
82175: LD_INT 3
82177: PUSH
82178: LD_INT 4
82180: PUSH
82181: EMPTY
82182: LIST
82183: LIST
82184: PUSH
82185: LD_INT 3
82187: PUSH
82188: LD_INT 3
82190: PUSH
82191: EMPTY
82192: LIST
82193: LIST
82194: PUSH
82195: LD_INT 5
82197: PUSH
82198: LD_INT 3
82200: PUSH
82201: EMPTY
82202: LIST
82203: LIST
82204: PUSH
82205: LD_INT 3
82207: PUSH
82208: LD_INT 5
82210: PUSH
82211: EMPTY
82212: LIST
82213: LIST
82214: PUSH
82215: EMPTY
82216: LIST
82217: LIST
82218: LIST
82219: LIST
82220: LIST
82221: LIST
82222: LIST
82223: LIST
82224: LIST
82225: LIST
82226: LIST
82227: LIST
82228: LIST
82229: LIST
82230: LIST
82231: LIST
82232: LIST
82233: LIST
82234: LIST
82235: LIST
82236: LIST
82237: LIST
82238: LIST
82239: LIST
82240: LIST
82241: LIST
82242: LIST
82243: LIST
82244: LIST
82245: LIST
82246: LIST
82247: LIST
82248: LIST
82249: LIST
82250: LIST
82251: LIST
82252: LIST
82253: LIST
82254: LIST
82255: LIST
82256: LIST
82257: LIST
82258: LIST
82259: LIST
82260: LIST
82261: ST_TO_ADDR
// Factory4 = [ [ - 4 , - 4 ] , [ - 4 , - 5 ] , [ - 3 , - 4 ] , [ - 3 , - 3 ] , [ - 4 , - 3 ] , [ - 5 , - 4 ] , [ - 5 , - 5 ] , [ - 3 , - 5 ] , [ - 5 , - 3 ] , [ 0 , - 3 ] , [ 0 , - 4 ] , [ 1 , - 3 ] , [ 1 , - 2 ] , [ 0 , - 2 ] , [ - 1 , - 3 ] , [ - 1 , - 4 ] , [ 2 , - 2 ] , [ - 2 , - 4 ] , [ 4 , 0 ] , [ 4 , - 1 ] , [ 5 , 0 ] , [ 5 , 1 ] , [ 4 , 1 ] , [ 3 , 0 ] , [ 3 , - 1 ] , [ 3 , - 2 ] , [ 5 , 2 ] , [ 3 , 3 ] , [ 3 , 2 ] , [ 4 , 3 ] , [ 4 , 4 ] , [ 3 , 4 ] , [ 2 , 3 ] , [ 2 , 2 ] , [ 4 , 2 ] , [ 2 , 4 ] , [ 0 , 4 ] , [ 0 , 3 ] , [ 1 , 4 ] , [ 1 , 5 ] , [ 0 , 5 ] , [ - 1 , 4 ] , [ - 1 , 3 ] , [ 2 , 5 ] , [ - 2 , 3 ] ] ;
82262: LD_ADDR_VAR 0 33
82266: PUSH
82267: LD_INT 4
82269: NEG
82270: PUSH
82271: LD_INT 4
82273: NEG
82274: PUSH
82275: EMPTY
82276: LIST
82277: LIST
82278: PUSH
82279: LD_INT 4
82281: NEG
82282: PUSH
82283: LD_INT 5
82285: NEG
82286: PUSH
82287: EMPTY
82288: LIST
82289: LIST
82290: PUSH
82291: LD_INT 3
82293: NEG
82294: PUSH
82295: LD_INT 4
82297: NEG
82298: PUSH
82299: EMPTY
82300: LIST
82301: LIST
82302: PUSH
82303: LD_INT 3
82305: NEG
82306: PUSH
82307: LD_INT 3
82309: NEG
82310: PUSH
82311: EMPTY
82312: LIST
82313: LIST
82314: PUSH
82315: LD_INT 4
82317: NEG
82318: PUSH
82319: LD_INT 3
82321: NEG
82322: PUSH
82323: EMPTY
82324: LIST
82325: LIST
82326: PUSH
82327: LD_INT 5
82329: NEG
82330: PUSH
82331: LD_INT 4
82333: NEG
82334: PUSH
82335: EMPTY
82336: LIST
82337: LIST
82338: PUSH
82339: LD_INT 5
82341: NEG
82342: PUSH
82343: LD_INT 5
82345: NEG
82346: PUSH
82347: EMPTY
82348: LIST
82349: LIST
82350: PUSH
82351: LD_INT 3
82353: NEG
82354: PUSH
82355: LD_INT 5
82357: NEG
82358: PUSH
82359: EMPTY
82360: LIST
82361: LIST
82362: PUSH
82363: LD_INT 5
82365: NEG
82366: PUSH
82367: LD_INT 3
82369: NEG
82370: PUSH
82371: EMPTY
82372: LIST
82373: LIST
82374: PUSH
82375: LD_INT 0
82377: PUSH
82378: LD_INT 3
82380: NEG
82381: PUSH
82382: EMPTY
82383: LIST
82384: LIST
82385: PUSH
82386: LD_INT 0
82388: PUSH
82389: LD_INT 4
82391: NEG
82392: PUSH
82393: EMPTY
82394: LIST
82395: LIST
82396: PUSH
82397: LD_INT 1
82399: PUSH
82400: LD_INT 3
82402: NEG
82403: PUSH
82404: EMPTY
82405: LIST
82406: LIST
82407: PUSH
82408: LD_INT 1
82410: PUSH
82411: LD_INT 2
82413: NEG
82414: PUSH
82415: EMPTY
82416: LIST
82417: LIST
82418: PUSH
82419: LD_INT 0
82421: PUSH
82422: LD_INT 2
82424: NEG
82425: PUSH
82426: EMPTY
82427: LIST
82428: LIST
82429: PUSH
82430: LD_INT 1
82432: NEG
82433: PUSH
82434: LD_INT 3
82436: NEG
82437: PUSH
82438: EMPTY
82439: LIST
82440: LIST
82441: PUSH
82442: LD_INT 1
82444: NEG
82445: PUSH
82446: LD_INT 4
82448: NEG
82449: PUSH
82450: EMPTY
82451: LIST
82452: LIST
82453: PUSH
82454: LD_INT 2
82456: PUSH
82457: LD_INT 2
82459: NEG
82460: PUSH
82461: EMPTY
82462: LIST
82463: LIST
82464: PUSH
82465: LD_INT 2
82467: NEG
82468: PUSH
82469: LD_INT 4
82471: NEG
82472: PUSH
82473: EMPTY
82474: LIST
82475: LIST
82476: PUSH
82477: LD_INT 4
82479: PUSH
82480: LD_INT 0
82482: PUSH
82483: EMPTY
82484: LIST
82485: LIST
82486: PUSH
82487: LD_INT 4
82489: PUSH
82490: LD_INT 1
82492: NEG
82493: PUSH
82494: EMPTY
82495: LIST
82496: LIST
82497: PUSH
82498: LD_INT 5
82500: PUSH
82501: LD_INT 0
82503: PUSH
82504: EMPTY
82505: LIST
82506: LIST
82507: PUSH
82508: LD_INT 5
82510: PUSH
82511: LD_INT 1
82513: PUSH
82514: EMPTY
82515: LIST
82516: LIST
82517: PUSH
82518: LD_INT 4
82520: PUSH
82521: LD_INT 1
82523: PUSH
82524: EMPTY
82525: LIST
82526: LIST
82527: PUSH
82528: LD_INT 3
82530: PUSH
82531: LD_INT 0
82533: PUSH
82534: EMPTY
82535: LIST
82536: LIST
82537: PUSH
82538: LD_INT 3
82540: PUSH
82541: LD_INT 1
82543: NEG
82544: PUSH
82545: EMPTY
82546: LIST
82547: LIST
82548: PUSH
82549: LD_INT 3
82551: PUSH
82552: LD_INT 2
82554: NEG
82555: PUSH
82556: EMPTY
82557: LIST
82558: LIST
82559: PUSH
82560: LD_INT 5
82562: PUSH
82563: LD_INT 2
82565: PUSH
82566: EMPTY
82567: LIST
82568: LIST
82569: PUSH
82570: LD_INT 3
82572: PUSH
82573: LD_INT 3
82575: PUSH
82576: EMPTY
82577: LIST
82578: LIST
82579: PUSH
82580: LD_INT 3
82582: PUSH
82583: LD_INT 2
82585: PUSH
82586: EMPTY
82587: LIST
82588: LIST
82589: PUSH
82590: LD_INT 4
82592: PUSH
82593: LD_INT 3
82595: PUSH
82596: EMPTY
82597: LIST
82598: LIST
82599: PUSH
82600: LD_INT 4
82602: PUSH
82603: LD_INT 4
82605: PUSH
82606: EMPTY
82607: LIST
82608: LIST
82609: PUSH
82610: LD_INT 3
82612: PUSH
82613: LD_INT 4
82615: PUSH
82616: EMPTY
82617: LIST
82618: LIST
82619: PUSH
82620: LD_INT 2
82622: PUSH
82623: LD_INT 3
82625: PUSH
82626: EMPTY
82627: LIST
82628: LIST
82629: PUSH
82630: LD_INT 2
82632: PUSH
82633: LD_INT 2
82635: PUSH
82636: EMPTY
82637: LIST
82638: LIST
82639: PUSH
82640: LD_INT 4
82642: PUSH
82643: LD_INT 2
82645: PUSH
82646: EMPTY
82647: LIST
82648: LIST
82649: PUSH
82650: LD_INT 2
82652: PUSH
82653: LD_INT 4
82655: PUSH
82656: EMPTY
82657: LIST
82658: LIST
82659: PUSH
82660: LD_INT 0
82662: PUSH
82663: LD_INT 4
82665: PUSH
82666: EMPTY
82667: LIST
82668: LIST
82669: PUSH
82670: LD_INT 0
82672: PUSH
82673: LD_INT 3
82675: PUSH
82676: EMPTY
82677: LIST
82678: LIST
82679: PUSH
82680: LD_INT 1
82682: PUSH
82683: LD_INT 4
82685: PUSH
82686: EMPTY
82687: LIST
82688: LIST
82689: PUSH
82690: LD_INT 1
82692: PUSH
82693: LD_INT 5
82695: PUSH
82696: EMPTY
82697: LIST
82698: LIST
82699: PUSH
82700: LD_INT 0
82702: PUSH
82703: LD_INT 5
82705: PUSH
82706: EMPTY
82707: LIST
82708: LIST
82709: PUSH
82710: LD_INT 1
82712: NEG
82713: PUSH
82714: LD_INT 4
82716: PUSH
82717: EMPTY
82718: LIST
82719: LIST
82720: PUSH
82721: LD_INT 1
82723: NEG
82724: PUSH
82725: LD_INT 3
82727: PUSH
82728: EMPTY
82729: LIST
82730: LIST
82731: PUSH
82732: LD_INT 2
82734: PUSH
82735: LD_INT 5
82737: PUSH
82738: EMPTY
82739: LIST
82740: LIST
82741: PUSH
82742: LD_INT 2
82744: NEG
82745: PUSH
82746: LD_INT 3
82748: PUSH
82749: EMPTY
82750: LIST
82751: LIST
82752: PUSH
82753: EMPTY
82754: LIST
82755: LIST
82756: LIST
82757: LIST
82758: LIST
82759: LIST
82760: LIST
82761: LIST
82762: LIST
82763: LIST
82764: LIST
82765: LIST
82766: LIST
82767: LIST
82768: LIST
82769: LIST
82770: LIST
82771: LIST
82772: LIST
82773: LIST
82774: LIST
82775: LIST
82776: LIST
82777: LIST
82778: LIST
82779: LIST
82780: LIST
82781: LIST
82782: LIST
82783: LIST
82784: LIST
82785: LIST
82786: LIST
82787: LIST
82788: LIST
82789: LIST
82790: LIST
82791: LIST
82792: LIST
82793: LIST
82794: LIST
82795: LIST
82796: LIST
82797: LIST
82798: LIST
82799: ST_TO_ADDR
// Factory5 = [ [ 0 , - 4 ] , [ 0 , - 5 ] , [ 1 , - 4 ] , [ 1 , - 3 ] , [ 0 , - 3 ] , [ - 1 , - 4 ] , [ - 1 , - 5 ] , [ 2 , - 3 ] , [ - 2 , - 5 ] , [ 3 , 0 ] , [ 3 , - 1 ] , [ 4 , 0 ] , [ 4 , 1 ] , [ 3 , 1 ] , [ 2 , 0 ] , [ 2 , - 1 ] , [ 2 , - 2 ] , [ 4 , 2 ] , [ 4 , 4 ] , [ 4 , 3 ] , [ 5 , 4 ] , [ 5 , 5 ] , [ 4 , 5 ] , [ 3 , 4 ] , [ 3 , 3 ] , [ 5 , 3 ] , [ 3 , 5 ] , [ 0 , 3 ] , [ 0 , 2 ] , [ 1 , 3 ] , [ 1 , 4 ] , [ 0 , 4 ] , [ - 1 , 3 ] , [ - 1 , 2 ] , [ 2 , 4 ] , [ - 2 , 2 ] , [ - 4 , 0 ] , [ - 4 , - 1 ] , [ - 3 , 0 ] , [ - 3 , 1 ] , [ - 4 , 1 ] , [ - 5 , 0 ] , [ - 5 , - 1 ] , [ - 5 , - 2 ] , [ - 3 , 2 ] ] ;
82800: LD_ADDR_VAR 0 34
82804: PUSH
82805: LD_INT 0
82807: PUSH
82808: LD_INT 4
82810: NEG
82811: PUSH
82812: EMPTY
82813: LIST
82814: LIST
82815: PUSH
82816: LD_INT 0
82818: PUSH
82819: LD_INT 5
82821: NEG
82822: PUSH
82823: EMPTY
82824: LIST
82825: LIST
82826: PUSH
82827: LD_INT 1
82829: PUSH
82830: LD_INT 4
82832: NEG
82833: PUSH
82834: EMPTY
82835: LIST
82836: LIST
82837: PUSH
82838: LD_INT 1
82840: PUSH
82841: LD_INT 3
82843: NEG
82844: PUSH
82845: EMPTY
82846: LIST
82847: LIST
82848: PUSH
82849: LD_INT 0
82851: PUSH
82852: LD_INT 3
82854: NEG
82855: PUSH
82856: EMPTY
82857: LIST
82858: LIST
82859: PUSH
82860: LD_INT 1
82862: NEG
82863: PUSH
82864: LD_INT 4
82866: NEG
82867: PUSH
82868: EMPTY
82869: LIST
82870: LIST
82871: PUSH
82872: LD_INT 1
82874: NEG
82875: PUSH
82876: LD_INT 5
82878: NEG
82879: PUSH
82880: EMPTY
82881: LIST
82882: LIST
82883: PUSH
82884: LD_INT 2
82886: PUSH
82887: LD_INT 3
82889: NEG
82890: PUSH
82891: EMPTY
82892: LIST
82893: LIST
82894: PUSH
82895: LD_INT 2
82897: NEG
82898: PUSH
82899: LD_INT 5
82901: NEG
82902: PUSH
82903: EMPTY
82904: LIST
82905: LIST
82906: PUSH
82907: LD_INT 3
82909: PUSH
82910: LD_INT 0
82912: PUSH
82913: EMPTY
82914: LIST
82915: LIST
82916: PUSH
82917: LD_INT 3
82919: PUSH
82920: LD_INT 1
82922: NEG
82923: PUSH
82924: EMPTY
82925: LIST
82926: LIST
82927: PUSH
82928: LD_INT 4
82930: PUSH
82931: LD_INT 0
82933: PUSH
82934: EMPTY
82935: LIST
82936: LIST
82937: PUSH
82938: LD_INT 4
82940: PUSH
82941: LD_INT 1
82943: PUSH
82944: EMPTY
82945: LIST
82946: LIST
82947: PUSH
82948: LD_INT 3
82950: PUSH
82951: LD_INT 1
82953: PUSH
82954: EMPTY
82955: LIST
82956: LIST
82957: PUSH
82958: LD_INT 2
82960: PUSH
82961: LD_INT 0
82963: PUSH
82964: EMPTY
82965: LIST
82966: LIST
82967: PUSH
82968: LD_INT 2
82970: PUSH
82971: LD_INT 1
82973: NEG
82974: PUSH
82975: EMPTY
82976: LIST
82977: LIST
82978: PUSH
82979: LD_INT 2
82981: PUSH
82982: LD_INT 2
82984: NEG
82985: PUSH
82986: EMPTY
82987: LIST
82988: LIST
82989: PUSH
82990: LD_INT 4
82992: PUSH
82993: LD_INT 2
82995: PUSH
82996: EMPTY
82997: LIST
82998: LIST
82999: PUSH
83000: LD_INT 4
83002: PUSH
83003: LD_INT 4
83005: PUSH
83006: EMPTY
83007: LIST
83008: LIST
83009: PUSH
83010: LD_INT 4
83012: PUSH
83013: LD_INT 3
83015: PUSH
83016: EMPTY
83017: LIST
83018: LIST
83019: PUSH
83020: LD_INT 5
83022: PUSH
83023: LD_INT 4
83025: PUSH
83026: EMPTY
83027: LIST
83028: LIST
83029: PUSH
83030: LD_INT 5
83032: PUSH
83033: LD_INT 5
83035: PUSH
83036: EMPTY
83037: LIST
83038: LIST
83039: PUSH
83040: LD_INT 4
83042: PUSH
83043: LD_INT 5
83045: PUSH
83046: EMPTY
83047: LIST
83048: LIST
83049: PUSH
83050: LD_INT 3
83052: PUSH
83053: LD_INT 4
83055: PUSH
83056: EMPTY
83057: LIST
83058: LIST
83059: PUSH
83060: LD_INT 3
83062: PUSH
83063: LD_INT 3
83065: PUSH
83066: EMPTY
83067: LIST
83068: LIST
83069: PUSH
83070: LD_INT 5
83072: PUSH
83073: LD_INT 3
83075: PUSH
83076: EMPTY
83077: LIST
83078: LIST
83079: PUSH
83080: LD_INT 3
83082: PUSH
83083: LD_INT 5
83085: PUSH
83086: EMPTY
83087: LIST
83088: LIST
83089: PUSH
83090: LD_INT 0
83092: PUSH
83093: LD_INT 3
83095: PUSH
83096: EMPTY
83097: LIST
83098: LIST
83099: PUSH
83100: LD_INT 0
83102: PUSH
83103: LD_INT 2
83105: PUSH
83106: EMPTY
83107: LIST
83108: LIST
83109: PUSH
83110: LD_INT 1
83112: PUSH
83113: LD_INT 3
83115: PUSH
83116: EMPTY
83117: LIST
83118: LIST
83119: PUSH
83120: LD_INT 1
83122: PUSH
83123: LD_INT 4
83125: PUSH
83126: EMPTY
83127: LIST
83128: LIST
83129: PUSH
83130: LD_INT 0
83132: PUSH
83133: LD_INT 4
83135: PUSH
83136: EMPTY
83137: LIST
83138: LIST
83139: PUSH
83140: LD_INT 1
83142: NEG
83143: PUSH
83144: LD_INT 3
83146: PUSH
83147: EMPTY
83148: LIST
83149: LIST
83150: PUSH
83151: LD_INT 1
83153: NEG
83154: PUSH
83155: LD_INT 2
83157: PUSH
83158: EMPTY
83159: LIST
83160: LIST
83161: PUSH
83162: LD_INT 2
83164: PUSH
83165: LD_INT 4
83167: PUSH
83168: EMPTY
83169: LIST
83170: LIST
83171: PUSH
83172: LD_INT 2
83174: NEG
83175: PUSH
83176: LD_INT 2
83178: PUSH
83179: EMPTY
83180: LIST
83181: LIST
83182: PUSH
83183: LD_INT 4
83185: NEG
83186: PUSH
83187: LD_INT 0
83189: PUSH
83190: EMPTY
83191: LIST
83192: LIST
83193: PUSH
83194: LD_INT 4
83196: NEG
83197: PUSH
83198: LD_INT 1
83200: NEG
83201: PUSH
83202: EMPTY
83203: LIST
83204: LIST
83205: PUSH
83206: LD_INT 3
83208: NEG
83209: PUSH
83210: LD_INT 0
83212: PUSH
83213: EMPTY
83214: LIST
83215: LIST
83216: PUSH
83217: LD_INT 3
83219: NEG
83220: PUSH
83221: LD_INT 1
83223: PUSH
83224: EMPTY
83225: LIST
83226: LIST
83227: PUSH
83228: LD_INT 4
83230: NEG
83231: PUSH
83232: LD_INT 1
83234: PUSH
83235: EMPTY
83236: LIST
83237: LIST
83238: PUSH
83239: LD_INT 5
83241: NEG
83242: PUSH
83243: LD_INT 0
83245: PUSH
83246: EMPTY
83247: LIST
83248: LIST
83249: PUSH
83250: LD_INT 5
83252: NEG
83253: PUSH
83254: LD_INT 1
83256: NEG
83257: PUSH
83258: EMPTY
83259: LIST
83260: LIST
83261: PUSH
83262: LD_INT 5
83264: NEG
83265: PUSH
83266: LD_INT 2
83268: NEG
83269: PUSH
83270: EMPTY
83271: LIST
83272: LIST
83273: PUSH
83274: LD_INT 3
83276: NEG
83277: PUSH
83278: LD_INT 2
83280: PUSH
83281: EMPTY
83282: LIST
83283: LIST
83284: PUSH
83285: EMPTY
83286: LIST
83287: LIST
83288: LIST
83289: LIST
83290: LIST
83291: LIST
83292: LIST
83293: LIST
83294: LIST
83295: LIST
83296: LIST
83297: LIST
83298: LIST
83299: LIST
83300: LIST
83301: LIST
83302: LIST
83303: LIST
83304: LIST
83305: LIST
83306: LIST
83307: LIST
83308: LIST
83309: LIST
83310: LIST
83311: LIST
83312: LIST
83313: LIST
83314: LIST
83315: LIST
83316: LIST
83317: LIST
83318: LIST
83319: LIST
83320: LIST
83321: LIST
83322: LIST
83323: LIST
83324: LIST
83325: LIST
83326: LIST
83327: LIST
83328: LIST
83329: LIST
83330: LIST
83331: ST_TO_ADDR
// end ; end ;
83332: GO 83335
83334: POP
// case btype of b_depot , b_warehouse :
83335: LD_VAR 0 1
83339: PUSH
83340: LD_INT 0
83342: DOUBLE
83343: EQUAL
83344: IFTRUE 83354
83346: LD_INT 1
83348: DOUBLE
83349: EQUAL
83350: IFTRUE 83354
83352: GO 83555
83354: POP
// case nation of nation_american :
83355: LD_VAR 0 5
83359: PUSH
83360: LD_INT 1
83362: DOUBLE
83363: EQUAL
83364: IFTRUE 83368
83366: GO 83424
83368: POP
// temp_list = [ DepotAm0 , DepotAm1 , DepotAm2 , DepotAm3 , DepotAm4 , DepotAm5 ] [ dir + 1 ] ; nation_arabian :
83369: LD_ADDR_VAR 0 9
83373: PUSH
83374: LD_VAR 0 11
83378: PUSH
83379: LD_VAR 0 12
83383: PUSH
83384: LD_VAR 0 13
83388: PUSH
83389: LD_VAR 0 14
83393: PUSH
83394: LD_VAR 0 15
83398: PUSH
83399: LD_VAR 0 16
83403: PUSH
83404: EMPTY
83405: LIST
83406: LIST
83407: LIST
83408: LIST
83409: LIST
83410: LIST
83411: PUSH
83412: LD_VAR 0 4
83416: PUSH
83417: LD_INT 1
83419: PLUS
83420: ARRAY
83421: ST_TO_ADDR
83422: GO 83553
83424: LD_INT 2
83426: DOUBLE
83427: EQUAL
83428: IFTRUE 83432
83430: GO 83488
83432: POP
// temp_list = [ DepotAr0 , DepotAr1 , DepotAr2 , DepotAr3 , DepotAr4 , DepotAr5 ] [ dir + 1 ] ; nation_russian :
83433: LD_ADDR_VAR 0 9
83437: PUSH
83438: LD_VAR 0 17
83442: PUSH
83443: LD_VAR 0 18
83447: PUSH
83448: LD_VAR 0 19
83452: PUSH
83453: LD_VAR 0 20
83457: PUSH
83458: LD_VAR 0 21
83462: PUSH
83463: LD_VAR 0 22
83467: PUSH
83468: EMPTY
83469: LIST
83470: LIST
83471: LIST
83472: LIST
83473: LIST
83474: LIST
83475: PUSH
83476: LD_VAR 0 4
83480: PUSH
83481: LD_INT 1
83483: PLUS
83484: ARRAY
83485: ST_TO_ADDR
83486: GO 83553
83488: LD_INT 3
83490: DOUBLE
83491: EQUAL
83492: IFTRUE 83496
83494: GO 83552
83496: POP
// temp_list = [ DepotRu0 , DepotRu1 , DepotRu2 , DepotRu3 , DepotRu4 , DepotRu5 ] [ dir + 1 ] ; end ; b_workshop , b_factory :
83497: LD_ADDR_VAR 0 9
83501: PUSH
83502: LD_VAR 0 23
83506: PUSH
83507: LD_VAR 0 24
83511: PUSH
83512: LD_VAR 0 25
83516: PUSH
83517: LD_VAR 0 26
83521: PUSH
83522: LD_VAR 0 27
83526: PUSH
83527: LD_VAR 0 28
83531: PUSH
83532: EMPTY
83533: LIST
83534: LIST
83535: LIST
83536: LIST
83537: LIST
83538: LIST
83539: PUSH
83540: LD_VAR 0 4
83544: PUSH
83545: LD_INT 1
83547: PLUS
83548: ARRAY
83549: ST_TO_ADDR
83550: GO 83553
83552: POP
83553: GO 84108
83555: LD_INT 2
83557: DOUBLE
83558: EQUAL
83559: IFTRUE 83569
83561: LD_INT 3
83563: DOUBLE
83564: EQUAL
83565: IFTRUE 83569
83567: GO 83625
83569: POP
// temp_list = [ Factory0 , Factory1 , Factory2 , Factory3 , Factory4 , Factory5 ] [ dir + 1 ] ; b_ext_track , b_ext_gun , b_ext_rocket , b_ext_noncombat , b_ext_radio , b_ext_radar , b_ext_siberium , b_ext_stitch , b_ext_computer , b_ext_laser :
83570: LD_ADDR_VAR 0 9
83574: PUSH
83575: LD_VAR 0 29
83579: PUSH
83580: LD_VAR 0 30
83584: PUSH
83585: LD_VAR 0 31
83589: PUSH
83590: LD_VAR 0 32
83594: PUSH
83595: LD_VAR 0 33
83599: PUSH
83600: LD_VAR 0 34
83604: PUSH
83605: EMPTY
83606: LIST
83607: LIST
83608: LIST
83609: LIST
83610: LIST
83611: LIST
83612: PUSH
83613: LD_VAR 0 4
83617: PUSH
83618: LD_INT 1
83620: PLUS
83621: ARRAY
83622: ST_TO_ADDR
83623: GO 84108
83625: LD_INT 16
83627: DOUBLE
83628: EQUAL
83629: IFTRUE 83687
83631: LD_INT 17
83633: DOUBLE
83634: EQUAL
83635: IFTRUE 83687
83637: LD_INT 18
83639: DOUBLE
83640: EQUAL
83641: IFTRUE 83687
83643: LD_INT 19
83645: DOUBLE
83646: EQUAL
83647: IFTRUE 83687
83649: LD_INT 22
83651: DOUBLE
83652: EQUAL
83653: IFTRUE 83687
83655: LD_INT 20
83657: DOUBLE
83658: EQUAL
83659: IFTRUE 83687
83661: LD_INT 21
83663: DOUBLE
83664: EQUAL
83665: IFTRUE 83687
83667: LD_INT 23
83669: DOUBLE
83670: EQUAL
83671: IFTRUE 83687
83673: LD_INT 24
83675: DOUBLE
83676: EQUAL
83677: IFTRUE 83687
83679: LD_INT 25
83681: DOUBLE
83682: EQUAL
83683: IFTRUE 83687
83685: GO 83743
83687: POP
// temp_list = [ Ext0 , Ext1 , Ext2 , Ext3 , Ext4 , Ext5 ] [ dir + 1 ] ; b_lab , b_lab_half , b_lab_full , b_lab_biological , b_lab_computer , b_lab_opto , b_lab_siberium , b_lab_spacetime , b_lab_weapon :
83688: LD_ADDR_VAR 0 9
83692: PUSH
83693: LD_VAR 0 35
83697: PUSH
83698: LD_VAR 0 36
83702: PUSH
83703: LD_VAR 0 37
83707: PUSH
83708: LD_VAR 0 38
83712: PUSH
83713: LD_VAR 0 39
83717: PUSH
83718: LD_VAR 0 40
83722: PUSH
83723: EMPTY
83724: LIST
83725: LIST
83726: LIST
83727: LIST
83728: LIST
83729: LIST
83730: PUSH
83731: LD_VAR 0 4
83735: PUSH
83736: LD_INT 1
83738: PLUS
83739: ARRAY
83740: ST_TO_ADDR
83741: GO 84108
83743: LD_INT 6
83745: DOUBLE
83746: EQUAL
83747: IFTRUE 83799
83749: LD_INT 7
83751: DOUBLE
83752: EQUAL
83753: IFTRUE 83799
83755: LD_INT 8
83757: DOUBLE
83758: EQUAL
83759: IFTRUE 83799
83761: LD_INT 13
83763: DOUBLE
83764: EQUAL
83765: IFTRUE 83799
83767: LD_INT 12
83769: DOUBLE
83770: EQUAL
83771: IFTRUE 83799
83773: LD_INT 15
83775: DOUBLE
83776: EQUAL
83777: IFTRUE 83799
83779: LD_INT 11
83781: DOUBLE
83782: EQUAL
83783: IFTRUE 83799
83785: LD_INT 14
83787: DOUBLE
83788: EQUAL
83789: IFTRUE 83799
83791: LD_INT 10
83793: DOUBLE
83794: EQUAL
83795: IFTRUE 83799
83797: GO 83855
83799: POP
// temp_list = [ Lab0 , Lab1 , Lab2 , Lab3 , Lab4 , Lab5 ] [ dir + 1 ] ; b_control_tower :
83800: LD_ADDR_VAR 0 9
83804: PUSH
83805: LD_VAR 0 41
83809: PUSH
83810: LD_VAR 0 42
83814: PUSH
83815: LD_VAR 0 43
83819: PUSH
83820: LD_VAR 0 44
83824: PUSH
83825: LD_VAR 0 45
83829: PUSH
83830: LD_VAR 0 46
83834: PUSH
83835: EMPTY
83836: LIST
83837: LIST
83838: LIST
83839: LIST
83840: LIST
83841: LIST
83842: PUSH
83843: LD_VAR 0 4
83847: PUSH
83848: LD_INT 1
83850: PLUS
83851: ARRAY
83852: ST_TO_ADDR
83853: GO 84108
83855: LD_INT 36
83857: DOUBLE
83858: EQUAL
83859: IFTRUE 83863
83861: GO 83919
83863: POP
// temp_list = [ ControlTower0 , ControlTower1 , ControlTower2 , ControlTower3 , ControlTower4 , ControlTower5 ] [ dir + 1 ] ; b_armoury , b_barracks , b_teleport , b_behemoth :
83864: LD_ADDR_VAR 0 9
83868: PUSH
83869: LD_VAR 0 47
83873: PUSH
83874: LD_VAR 0 48
83878: PUSH
83879: LD_VAR 0 49
83883: PUSH
83884: LD_VAR 0 50
83888: PUSH
83889: LD_VAR 0 51
83893: PUSH
83894: LD_VAR 0 52
83898: PUSH
83899: EMPTY
83900: LIST
83901: LIST
83902: LIST
83903: LIST
83904: LIST
83905: LIST
83906: PUSH
83907: LD_VAR 0 4
83911: PUSH
83912: LD_INT 1
83914: PLUS
83915: ARRAY
83916: ST_TO_ADDR
83917: GO 84108
83919: LD_INT 4
83921: DOUBLE
83922: EQUAL
83923: IFTRUE 83945
83925: LD_INT 5
83927: DOUBLE
83928: EQUAL
83929: IFTRUE 83945
83931: LD_INT 34
83933: DOUBLE
83934: EQUAL
83935: IFTRUE 83945
83937: LD_INT 37
83939: DOUBLE
83940: EQUAL
83941: IFTRUE 83945
83943: GO 84001
83945: POP
// temp_list = [ Barracks0 , Barracks1 , Barracks2 , Barracks3 , Barracks4 , Barracks5 ] [ dir + 1 ] ; b_breastwork , b_bunker , b_turret , b_solar_power , b_oil_power , b_siberite_power , b_oil_mine , b_siberite_mine :
83946: LD_ADDR_VAR 0 9
83950: PUSH
83951: LD_VAR 0 53
83955: PUSH
83956: LD_VAR 0 54
83960: PUSH
83961: LD_VAR 0 55
83965: PUSH
83966: LD_VAR 0 56
83970: PUSH
83971: LD_VAR 0 57
83975: PUSH
83976: LD_VAR 0 58
83980: PUSH
83981: EMPTY
83982: LIST
83983: LIST
83984: LIST
83985: LIST
83986: LIST
83987: LIST
83988: PUSH
83989: LD_VAR 0 4
83993: PUSH
83994: LD_INT 1
83996: PLUS
83997: ARRAY
83998: ST_TO_ADDR
83999: GO 84108
84001: LD_INT 31
84003: DOUBLE
84004: EQUAL
84005: IFTRUE 84051
84007: LD_INT 32
84009: DOUBLE
84010: EQUAL
84011: IFTRUE 84051
84013: LD_INT 33
84015: DOUBLE
84016: EQUAL
84017: IFTRUE 84051
84019: LD_INT 27
84021: DOUBLE
84022: EQUAL
84023: IFTRUE 84051
84025: LD_INT 26
84027: DOUBLE
84028: EQUAL
84029: IFTRUE 84051
84031: LD_INT 28
84033: DOUBLE
84034: EQUAL
84035: IFTRUE 84051
84037: LD_INT 29
84039: DOUBLE
84040: EQUAL
84041: IFTRUE 84051
84043: LD_INT 30
84045: DOUBLE
84046: EQUAL
84047: IFTRUE 84051
84049: GO 84107
84051: POP
// temp_list = [ Bunker0 , Bunker1 , Bunker2 , Bunker3 , Bunker4 , Bunker5 ] [ dir + 1 ] ; end ;
84052: LD_ADDR_VAR 0 9
84056: PUSH
84057: LD_VAR 0 59
84061: PUSH
84062: LD_VAR 0 60
84066: PUSH
84067: LD_VAR 0 61
84071: PUSH
84072: LD_VAR 0 62
84076: PUSH
84077: LD_VAR 0 63
84081: PUSH
84082: LD_VAR 0 64
84086: PUSH
84087: EMPTY
84088: LIST
84089: LIST
84090: LIST
84091: LIST
84092: LIST
84093: LIST
84094: PUSH
84095: LD_VAR 0 4
84099: PUSH
84100: LD_INT 1
84102: PLUS
84103: ARRAY
84104: ST_TO_ADDR
84105: GO 84108
84107: POP
// temp_list2 = [ ] ;
84108: LD_ADDR_VAR 0 10
84112: PUSH
84113: EMPTY
84114: ST_TO_ADDR
// for i in temp_list do
84115: LD_ADDR_VAR 0 8
84119: PUSH
84120: LD_VAR 0 9
84124: PUSH
84125: FOR_IN
84126: IFFALSE 84178
// temp_list2 = temp_list2 ^ [ [ i [ 1 ] + x , i [ 2 ] + y ] ] ;
84128: LD_ADDR_VAR 0 10
84132: PUSH
84133: LD_VAR 0 10
84137: PUSH
84138: LD_VAR 0 8
84142: PUSH
84143: LD_INT 1
84145: ARRAY
84146: PUSH
84147: LD_VAR 0 2
84151: PLUS
84152: PUSH
84153: LD_VAR 0 8
84157: PUSH
84158: LD_INT 2
84160: ARRAY
84161: PUSH
84162: LD_VAR 0 3
84166: PLUS
84167: PUSH
84168: EMPTY
84169: LIST
84170: LIST
84171: PUSH
84172: EMPTY
84173: LIST
84174: ADD
84175: ST_TO_ADDR
84176: GO 84125
84178: POP
84179: POP
// result = temp_list2 ;
84180: LD_ADDR_VAR 0 7
84184: PUSH
84185: LD_VAR 0 10
84189: ST_TO_ADDR
// end ;
84190: LD_VAR 0 7
84194: RET
// export function EnemyInRange ( unit , dist ) ; begin
84195: LD_INT 0
84197: PPUSH
// result := DangerAtRangeXY ( GetSide ( unit ) , GetX ( unit ) , GetY ( unit ) , dist ) [ 4 ] ;
84198: LD_ADDR_VAR 0 3
84202: PUSH
84203: LD_VAR 0 1
84207: PPUSH
84208: CALL_OW 255
84212: PPUSH
84213: LD_VAR 0 1
84217: PPUSH
84218: CALL_OW 250
84222: PPUSH
84223: LD_VAR 0 1
84227: PPUSH
84228: CALL_OW 251
84232: PPUSH
84233: LD_VAR 0 2
84237: PPUSH
84238: CALL 58299 0 4
84242: PUSH
84243: LD_INT 4
84245: ARRAY
84246: ST_TO_ADDR
// end ;
84247: LD_VAR 0 3
84251: RET
// export function PlayerSeeMe ( unit ) ; begin
84252: LD_INT 0
84254: PPUSH
// result := See ( your_side , unit ) ;
84255: LD_ADDR_VAR 0 2
84259: PUSH
84260: LD_OWVAR 2
84264: PPUSH
84265: LD_VAR 0 1
84269: PPUSH
84270: CALL_OW 292
84274: ST_TO_ADDR
// end ;
84275: LD_VAR 0 2
84279: RET
// export function ReverseDir ( unit ) ; begin
84280: LD_INT 0
84282: PPUSH
// if not unit then
84283: LD_VAR 0 1
84287: NOT
84288: IFFALSE 84292
// exit ;
84290: GO 84338
// result := [ 3 , 4 , 5 , 0 , 1 , 2 ] [ GetDir ( unit ) + 1 ] ;
84292: LD_ADDR_VAR 0 2
84296: PUSH
84297: LD_INT 3
84299: PUSH
84300: LD_INT 4
84302: PUSH
84303: LD_INT 5
84305: PUSH
84306: LD_INT 0
84308: PUSH
84309: LD_INT 1
84311: PUSH
84312: LD_INT 2
84314: PUSH
84315: EMPTY
84316: LIST
84317: LIST
84318: LIST
84319: LIST
84320: LIST
84321: LIST
84322: PUSH
84323: LD_VAR 0 1
84327: PPUSH
84328: CALL_OW 254
84332: PUSH
84333: LD_INT 1
84335: PLUS
84336: ARRAY
84337: ST_TO_ADDR
// end ;
84338: LD_VAR 0 2
84342: RET
// export function GetClosestHex ( unit , hexes ) ; var i , dist , tmp , hex ; begin
84343: LD_INT 0
84345: PPUSH
84346: PPUSH
84347: PPUSH
84348: PPUSH
84349: PPUSH
// if not hexes then
84350: LD_VAR 0 2
84354: NOT
84355: IFFALSE 84359
// exit ;
84357: GO 84507
// dist := 9999 ;
84359: LD_ADDR_VAR 0 5
84363: PUSH
84364: LD_INT 9999
84366: ST_TO_ADDR
// for i = 1 to hexes do
84367: LD_ADDR_VAR 0 4
84371: PUSH
84372: DOUBLE
84373: LD_INT 1
84375: DEC
84376: ST_TO_ADDR
84377: LD_VAR 0 2
84381: PUSH
84382: FOR_TO
84383: IFFALSE 84495
// begin if GetDistUnitXY ( unit , hexes [ i ] [ 1 ] , hexes [ i ] [ 2 ] ) < dist then
84385: LD_VAR 0 1
84389: PPUSH
84390: LD_VAR 0 2
84394: PUSH
84395: LD_VAR 0 4
84399: ARRAY
84400: PUSH
84401: LD_INT 1
84403: ARRAY
84404: PPUSH
84405: LD_VAR 0 2
84409: PUSH
84410: LD_VAR 0 4
84414: ARRAY
84415: PUSH
84416: LD_INT 2
84418: ARRAY
84419: PPUSH
84420: CALL_OW 297
84424: PUSH
84425: LD_VAR 0 5
84429: LESS
84430: IFFALSE 84493
// begin hex := hexes [ i ] ;
84432: LD_ADDR_VAR 0 7
84436: PUSH
84437: LD_VAR 0 2
84441: PUSH
84442: LD_VAR 0 4
84446: ARRAY
84447: ST_TO_ADDR
// dist := GetDistUnitXY ( unit , hexes [ i ] [ 1 ] , hexes [ i ] [ 2 ] ) ;
84448: LD_ADDR_VAR 0 5
84452: PUSH
84453: LD_VAR 0 1
84457: PPUSH
84458: LD_VAR 0 2
84462: PUSH
84463: LD_VAR 0 4
84467: ARRAY
84468: PUSH
84469: LD_INT 1
84471: ARRAY
84472: PPUSH
84473: LD_VAR 0 2
84477: PUSH
84478: LD_VAR 0 4
84482: ARRAY
84483: PUSH
84484: LD_INT 2
84486: ARRAY
84487: PPUSH
84488: CALL_OW 297
84492: ST_TO_ADDR
// end ; end ;
84493: GO 84382
84495: POP
84496: POP
// result := hex ;
84497: LD_ADDR_VAR 0 3
84501: PUSH
84502: LD_VAR 0 7
84506: ST_TO_ADDR
// end ;
84507: LD_VAR 0 3
84511: RET
// export function ComAutodestruct ( unit ) ; var i ; begin
84512: LD_INT 0
84514: PPUSH
84515: PPUSH
// if not unit or not unit in FilterAllUnits ( [ [ f_type , unit_vehicle ] , [ f_nation , 2 ] ] ) then
84516: LD_VAR 0 1
84520: NOT
84521: PUSH
84522: LD_VAR 0 1
84526: PUSH
84527: LD_INT 21
84529: PUSH
84530: LD_INT 2
84532: PUSH
84533: EMPTY
84534: LIST
84535: LIST
84536: PUSH
84537: LD_INT 23
84539: PUSH
84540: LD_INT 2
84542: PUSH
84543: EMPTY
84544: LIST
84545: LIST
84546: PUSH
84547: EMPTY
84548: LIST
84549: LIST
84550: PPUSH
84551: CALL_OW 69
84555: IN
84556: NOT
84557: OR
84558: IFFALSE 84562
// exit ;
84560: GO 84609
// for i = 1 to 3 do
84562: LD_ADDR_VAR 0 3
84566: PUSH
84567: DOUBLE
84568: LD_INT 1
84570: DEC
84571: ST_TO_ADDR
84572: LD_INT 3
84574: PUSH
84575: FOR_TO
84576: IFFALSE 84607
// MineExplosion ( GetX ( unit ) , GetY ( unit ) , 1 ) ;
84578: LD_VAR 0 1
84582: PPUSH
84583: CALL_OW 250
84587: PPUSH
84588: LD_VAR 0 1
84592: PPUSH
84593: CALL_OW 251
84597: PPUSH
84598: LD_INT 1
84600: PPUSH
84601: CALL_OW 453
84605: GO 84575
84607: POP
84608: POP
// end ;
84609: LD_VAR 0 2
84613: RET
// export function AttackHovercraft ( unit , enemy_unit ) ; var i , j , tmp , x , y ; begin
84614: LD_INT 0
84616: PPUSH
84617: PPUSH
84618: PPUSH
84619: PPUSH
84620: PPUSH
84621: PPUSH
// if not unit or not enemy_unit or HasTask ( unit ) then
84622: LD_VAR 0 1
84626: NOT
84627: PUSH
84628: LD_VAR 0 2
84632: NOT
84633: OR
84634: PUSH
84635: LD_VAR 0 1
84639: PPUSH
84640: CALL_OW 314
84644: OR
84645: IFFALSE 84649
// exit ;
84647: GO 85090
// x := GetX ( enemy_unit ) ;
84649: LD_ADDR_VAR 0 7
84653: PUSH
84654: LD_VAR 0 2
84658: PPUSH
84659: CALL_OW 250
84663: ST_TO_ADDR
// y := GetY ( enemy_unit ) ;
84664: LD_ADDR_VAR 0 8
84668: PUSH
84669: LD_VAR 0 2
84673: PPUSH
84674: CALL_OW 251
84678: ST_TO_ADDR
// if not x or not y then
84679: LD_VAR 0 7
84683: NOT
84684: PUSH
84685: LD_VAR 0 8
84689: NOT
84690: OR
84691: IFFALSE 84695
// exit ;
84693: GO 85090
// tmp := [ [ ShiftX ( x , 0 , 4 ) , ShiftY ( y , 0 , 4 ) ] , [ ShiftX ( x , 1 , 4 ) , ShiftY ( y , 1 , 4 ) ] , [ ShiftX ( x , 2 , 4 ) , ShiftY ( y , 2 , 4 ) ] , [ ShiftX ( x , 3 , 4 ) , ShiftY ( y , 3 , 4 ) ] , [ ShiftX ( x , 4 , 4 ) , ShiftY ( y , 4 , 4 ) ] , [ ShiftX ( x , 5 , 4 ) , ShiftY ( y , 5 , 4 ) ] ] ;
84695: LD_ADDR_VAR 0 6
84699: PUSH
84700: LD_VAR 0 7
84704: PPUSH
84705: LD_INT 0
84707: PPUSH
84708: LD_INT 4
84710: PPUSH
84711: CALL_OW 272
84715: PUSH
84716: LD_VAR 0 8
84720: PPUSH
84721: LD_INT 0
84723: PPUSH
84724: LD_INT 4
84726: PPUSH
84727: CALL_OW 273
84731: PUSH
84732: EMPTY
84733: LIST
84734: LIST
84735: PUSH
84736: LD_VAR 0 7
84740: PPUSH
84741: LD_INT 1
84743: PPUSH
84744: LD_INT 4
84746: PPUSH
84747: CALL_OW 272
84751: PUSH
84752: LD_VAR 0 8
84756: PPUSH
84757: LD_INT 1
84759: PPUSH
84760: LD_INT 4
84762: PPUSH
84763: CALL_OW 273
84767: PUSH
84768: EMPTY
84769: LIST
84770: LIST
84771: PUSH
84772: LD_VAR 0 7
84776: PPUSH
84777: LD_INT 2
84779: PPUSH
84780: LD_INT 4
84782: PPUSH
84783: CALL_OW 272
84787: PUSH
84788: LD_VAR 0 8
84792: PPUSH
84793: LD_INT 2
84795: PPUSH
84796: LD_INT 4
84798: PPUSH
84799: CALL_OW 273
84803: PUSH
84804: EMPTY
84805: LIST
84806: LIST
84807: PUSH
84808: LD_VAR 0 7
84812: PPUSH
84813: LD_INT 3
84815: PPUSH
84816: LD_INT 4
84818: PPUSH
84819: CALL_OW 272
84823: PUSH
84824: LD_VAR 0 8
84828: PPUSH
84829: LD_INT 3
84831: PPUSH
84832: LD_INT 4
84834: PPUSH
84835: CALL_OW 273
84839: PUSH
84840: EMPTY
84841: LIST
84842: LIST
84843: PUSH
84844: LD_VAR 0 7
84848: PPUSH
84849: LD_INT 4
84851: PPUSH
84852: LD_INT 4
84854: PPUSH
84855: CALL_OW 272
84859: PUSH
84860: LD_VAR 0 8
84864: PPUSH
84865: LD_INT 4
84867: PPUSH
84868: LD_INT 4
84870: PPUSH
84871: CALL_OW 273
84875: PUSH
84876: EMPTY
84877: LIST
84878: LIST
84879: PUSH
84880: LD_VAR 0 7
84884: PPUSH
84885: LD_INT 5
84887: PPUSH
84888: LD_INT 4
84890: PPUSH
84891: CALL_OW 272
84895: PUSH
84896: LD_VAR 0 8
84900: PPUSH
84901: LD_INT 5
84903: PPUSH
84904: LD_INT 4
84906: PPUSH
84907: CALL_OW 273
84911: PUSH
84912: EMPTY
84913: LIST
84914: LIST
84915: PUSH
84916: EMPTY
84917: LIST
84918: LIST
84919: LIST
84920: LIST
84921: LIST
84922: LIST
84923: ST_TO_ADDR
// for i = tmp downto 1 do
84924: LD_ADDR_VAR 0 4
84928: PUSH
84929: DOUBLE
84930: LD_VAR 0 6
84934: INC
84935: ST_TO_ADDR
84936: LD_INT 1
84938: PUSH
84939: FOR_DOWNTO
84940: IFFALSE 85041
// if not ValidHex ( tmp [ i ] [ 1 ] , tmp [ i ] [ 2 ] ) or HexInfo ( tmp [ i ] [ 1 ] , tmp [ i ] [ 2 ] ) <> 0 then
84942: LD_VAR 0 6
84946: PUSH
84947: LD_VAR 0 4
84951: ARRAY
84952: PUSH
84953: LD_INT 1
84955: ARRAY
84956: PPUSH
84957: LD_VAR 0 6
84961: PUSH
84962: LD_VAR 0 4
84966: ARRAY
84967: PUSH
84968: LD_INT 2
84970: ARRAY
84971: PPUSH
84972: CALL_OW 488
84976: NOT
84977: PUSH
84978: LD_VAR 0 6
84982: PUSH
84983: LD_VAR 0 4
84987: ARRAY
84988: PUSH
84989: LD_INT 1
84991: ARRAY
84992: PPUSH
84993: LD_VAR 0 6
84997: PUSH
84998: LD_VAR 0 4
85002: ARRAY
85003: PUSH
85004: LD_INT 2
85006: ARRAY
85007: PPUSH
85008: CALL_OW 428
85012: PUSH
85013: LD_INT 0
85015: NONEQUAL
85016: OR
85017: IFFALSE 85039
// tmp := Delete ( tmp , i ) ;
85019: LD_ADDR_VAR 0 6
85023: PUSH
85024: LD_VAR 0 6
85028: PPUSH
85029: LD_VAR 0 4
85033: PPUSH
85034: CALL_OW 3
85038: ST_TO_ADDR
85039: GO 84939
85041: POP
85042: POP
// j := GetClosestHex ( unit , tmp ) ;
85043: LD_ADDR_VAR 0 5
85047: PUSH
85048: LD_VAR 0 1
85052: PPUSH
85053: LD_VAR 0 6
85057: PPUSH
85058: CALL 84343 0 2
85062: ST_TO_ADDR
// ComMoveXY ( unit , j [ 1 ] , j [ 2 ] ) ;
85063: LD_VAR 0 1
85067: PPUSH
85068: LD_VAR 0 5
85072: PUSH
85073: LD_INT 1
85075: ARRAY
85076: PPUSH
85077: LD_VAR 0 5
85081: PUSH
85082: LD_INT 2
85084: ARRAY
85085: PPUSH
85086: CALL_OW 111
// end ;
85090: LD_VAR 0 3
85094: RET
// export function PrepareNature ( birds , tigers , apemans , enchidnas , horses , mastodonts , fishes , nat_area , wat_area ) ; var i , animal ; begin
85095: LD_INT 0
85097: PPUSH
85098: PPUSH
85099: PPUSH
// uc_side = 0 ;
85100: LD_ADDR_OWVAR 20
85104: PUSH
85105: LD_INT 0
85107: ST_TO_ADDR
// uc_nation = 0 ;
85108: LD_ADDR_OWVAR 21
85112: PUSH
85113: LD_INT 0
85115: ST_TO_ADDR
// InitHc ;
85116: CALL_OW 19
// InitVc ;
85120: CALL_OW 20
// if mastodonts then
85124: LD_VAR 0 6
85128: IFFALSE 85195
// for i = 1 to mastodonts do
85130: LD_ADDR_VAR 0 11
85134: PUSH
85135: DOUBLE
85136: LD_INT 1
85138: DEC
85139: ST_TO_ADDR
85140: LD_VAR 0 6
85144: PUSH
85145: FOR_TO
85146: IFFALSE 85193
// begin vc_chassis := 31 ;
85148: LD_ADDR_OWVAR 37
85152: PUSH
85153: LD_INT 31
85155: ST_TO_ADDR
// vc_control := control_rider ;
85156: LD_ADDR_OWVAR 38
85160: PUSH
85161: LD_INT 4
85163: ST_TO_ADDR
// animal := CreateVehicle ;
85164: LD_ADDR_VAR 0 12
85168: PUSH
85169: CALL_OW 45
85173: ST_TO_ADDR
// PlaceUnitInArea ( animal , nat_area , false ) ;
85174: LD_VAR 0 12
85178: PPUSH
85179: LD_VAR 0 8
85183: PPUSH
85184: LD_INT 0
85186: PPUSH
85187: CALL 91940 0 3
// end ;
85191: GO 85145
85193: POP
85194: POP
// if horses then
85195: LD_VAR 0 5
85199: IFFALSE 85266
// for i = 1 to horses do
85201: LD_ADDR_VAR 0 11
85205: PUSH
85206: DOUBLE
85207: LD_INT 1
85209: DEC
85210: ST_TO_ADDR
85211: LD_VAR 0 5
85215: PUSH
85216: FOR_TO
85217: IFFALSE 85264
// begin hc_class := 21 ;
85219: LD_ADDR_OWVAR 28
85223: PUSH
85224: LD_INT 21
85226: ST_TO_ADDR
// hc_gallery :=  ;
85227: LD_ADDR_OWVAR 33
85231: PUSH
85232: LD_STRING 
85234: ST_TO_ADDR
// animal := CreateHuman ;
85235: LD_ADDR_VAR 0 12
85239: PUSH
85240: CALL_OW 44
85244: ST_TO_ADDR
// PlaceUnitInArea ( animal , nat_area , false ) ;
85245: LD_VAR 0 12
85249: PPUSH
85250: LD_VAR 0 8
85254: PPUSH
85255: LD_INT 0
85257: PPUSH
85258: CALL 91940 0 3
// end ;
85262: GO 85216
85264: POP
85265: POP
// if birds then
85266: LD_VAR 0 1
85270: IFFALSE 85337
// for i = 1 to birds do
85272: LD_ADDR_VAR 0 11
85276: PUSH
85277: DOUBLE
85278: LD_INT 1
85280: DEC
85281: ST_TO_ADDR
85282: LD_VAR 0 1
85286: PUSH
85287: FOR_TO
85288: IFFALSE 85335
// begin hc_class = 18 ;
85290: LD_ADDR_OWVAR 28
85294: PUSH
85295: LD_INT 18
85297: ST_TO_ADDR
// hc_gallery =  ;
85298: LD_ADDR_OWVAR 33
85302: PUSH
85303: LD_STRING 
85305: ST_TO_ADDR
// animal := CreateHuman ;
85306: LD_ADDR_VAR 0 12
85310: PUSH
85311: CALL_OW 44
85315: ST_TO_ADDR
// PlaceUnitInArea ( animal , nat_area , false ) ;
85316: LD_VAR 0 12
85320: PPUSH
85321: LD_VAR 0 8
85325: PPUSH
85326: LD_INT 0
85328: PPUSH
85329: CALL 91940 0 3
// end ;
85333: GO 85287
85335: POP
85336: POP
// if tigers then
85337: LD_VAR 0 2
85341: IFFALSE 85425
// for i = 1 to tigers do
85343: LD_ADDR_VAR 0 11
85347: PUSH
85348: DOUBLE
85349: LD_INT 1
85351: DEC
85352: ST_TO_ADDR
85353: LD_VAR 0 2
85357: PUSH
85358: FOR_TO
85359: IFFALSE 85423
// begin hc_class = class_tiger ;
85361: LD_ADDR_OWVAR 28
85365: PUSH
85366: LD_INT 14
85368: ST_TO_ADDR
// hc_gallery =  ;
85369: LD_ADDR_OWVAR 33
85373: PUSH
85374: LD_STRING 
85376: ST_TO_ADDR
// hc_agressivity = Rand ( - 7 , 7 ) ;
85377: LD_ADDR_OWVAR 35
85381: PUSH
85382: LD_INT 7
85384: NEG
85385: PPUSH
85386: LD_INT 7
85388: PPUSH
85389: CALL_OW 12
85393: ST_TO_ADDR
// animal := CreateHuman ;
85394: LD_ADDR_VAR 0 12
85398: PUSH
85399: CALL_OW 44
85403: ST_TO_ADDR
// PlaceUnitInArea ( animal , nat_area , false ) ;
85404: LD_VAR 0 12
85408: PPUSH
85409: LD_VAR 0 8
85413: PPUSH
85414: LD_INT 0
85416: PPUSH
85417: CALL 91940 0 3
// end ;
85421: GO 85358
85423: POP
85424: POP
// if apemans then
85425: LD_VAR 0 3
85429: IFFALSE 85552
// for i = 1 to apemans do
85431: LD_ADDR_VAR 0 11
85435: PUSH
85436: DOUBLE
85437: LD_INT 1
85439: DEC
85440: ST_TO_ADDR
85441: LD_VAR 0 3
85445: PUSH
85446: FOR_TO
85447: IFFALSE 85550
// begin hc_class = class_apeman ;
85449: LD_ADDR_OWVAR 28
85453: PUSH
85454: LD_INT 12
85456: ST_TO_ADDR
// hc_gallery =  ;
85457: LD_ADDR_OWVAR 33
85461: PUSH
85462: LD_STRING 
85464: ST_TO_ADDR
// hc_agressivity = rand ( - 5 , 5 ) ;
85465: LD_ADDR_OWVAR 35
85469: PUSH
85470: LD_INT 5
85472: NEG
85473: PPUSH
85474: LD_INT 5
85476: PPUSH
85477: CALL_OW 12
85481: ST_TO_ADDR
// hc_skills := [ rand ( 1 , 3 ) , rand ( 1 , 3 ) , 0 , 0 ] ;
85482: LD_ADDR_OWVAR 31
85486: PUSH
85487: LD_INT 1
85489: PPUSH
85490: LD_INT 3
85492: PPUSH
85493: CALL_OW 12
85497: PUSH
85498: LD_INT 1
85500: PPUSH
85501: LD_INT 3
85503: PPUSH
85504: CALL_OW 12
85508: PUSH
85509: LD_INT 0
85511: PUSH
85512: LD_INT 0
85514: PUSH
85515: EMPTY
85516: LIST
85517: LIST
85518: LIST
85519: LIST
85520: ST_TO_ADDR
// animal := CreateHuman ;
85521: LD_ADDR_VAR 0 12
85525: PUSH
85526: CALL_OW 44
85530: ST_TO_ADDR
// PlaceUnitInArea ( animal , nat_area , false ) ;
85531: LD_VAR 0 12
85535: PPUSH
85536: LD_VAR 0 8
85540: PPUSH
85541: LD_INT 0
85543: PPUSH
85544: CALL 91940 0 3
// end ;
85548: GO 85446
85550: POP
85551: POP
// if enchidnas then
85552: LD_VAR 0 4
85556: IFFALSE 85623
// for i = 1 to enchidnas do
85558: LD_ADDR_VAR 0 11
85562: PUSH
85563: DOUBLE
85564: LD_INT 1
85566: DEC
85567: ST_TO_ADDR
85568: LD_VAR 0 4
85572: PUSH
85573: FOR_TO
85574: IFFALSE 85621
// begin hc_class = 13 ;
85576: LD_ADDR_OWVAR 28
85580: PUSH
85581: LD_INT 13
85583: ST_TO_ADDR
// hc_gallery =  ;
85584: LD_ADDR_OWVAR 33
85588: PUSH
85589: LD_STRING 
85591: ST_TO_ADDR
// animal := CreateHuman ;
85592: LD_ADDR_VAR 0 12
85596: PUSH
85597: CALL_OW 44
85601: ST_TO_ADDR
// PlaceUnitInArea ( animal , nat_area , false ) ;
85602: LD_VAR 0 12
85606: PPUSH
85607: LD_VAR 0 8
85611: PPUSH
85612: LD_INT 0
85614: PPUSH
85615: CALL 91940 0 3
// end ;
85619: GO 85573
85621: POP
85622: POP
// if fishes then
85623: LD_VAR 0 7
85627: IFFALSE 85694
// for i = 1 to fishes do
85629: LD_ADDR_VAR 0 11
85633: PUSH
85634: DOUBLE
85635: LD_INT 1
85637: DEC
85638: ST_TO_ADDR
85639: LD_VAR 0 7
85643: PUSH
85644: FOR_TO
85645: IFFALSE 85692
// begin hc_class = 20 ;
85647: LD_ADDR_OWVAR 28
85651: PUSH
85652: LD_INT 20
85654: ST_TO_ADDR
// hc_gallery =  ;
85655: LD_ADDR_OWVAR 33
85659: PUSH
85660: LD_STRING 
85662: ST_TO_ADDR
// animal := CreateHuman ;
85663: LD_ADDR_VAR 0 12
85667: PUSH
85668: CALL_OW 44
85672: ST_TO_ADDR
// PlaceUnitInArea ( animal , wat_area , false ) ;
85673: LD_VAR 0 12
85677: PPUSH
85678: LD_VAR 0 9
85682: PPUSH
85683: LD_INT 0
85685: PPUSH
85686: CALL 91940 0 3
// end ;
85690: GO 85644
85692: POP
85693: POP
// end ;
85694: LD_VAR 0 10
85698: RET
// export function WantHeal ( sci , unit ) ; begin
85699: LD_INT 0
85701: PPUSH
// if GetTaskList ( sci ) > 0 then
85702: LD_VAR 0 1
85706: PPUSH
85707: CALL_OW 437
85711: PUSH
85712: LD_INT 0
85714: GREATER
85715: IFFALSE 85785
// begin if GetTaskList ( sci ) [ 1 ] [ 1 ] = l and GetTaskList ( sci ) [ 1 ] [ 4 ] = unit then
85717: LD_VAR 0 1
85721: PPUSH
85722: CALL_OW 437
85726: PUSH
85727: LD_INT 1
85729: ARRAY
85730: PUSH
85731: LD_INT 1
85733: ARRAY
85734: PUSH
85735: LD_STRING l
85737: EQUAL
85738: PUSH
85739: LD_VAR 0 1
85743: PPUSH
85744: CALL_OW 437
85748: PUSH
85749: LD_INT 1
85751: ARRAY
85752: PUSH
85753: LD_INT 4
85755: ARRAY
85756: PUSH
85757: LD_VAR 0 2
85761: EQUAL
85762: AND
85763: IFFALSE 85775
// result := true else
85765: LD_ADDR_VAR 0 3
85769: PUSH
85770: LD_INT 1
85772: ST_TO_ADDR
85773: GO 85783
// result := false ;
85775: LD_ADDR_VAR 0 3
85779: PUSH
85780: LD_INT 0
85782: ST_TO_ADDR
// end else
85783: GO 85793
// result := false ;
85785: LD_ADDR_VAR 0 3
85789: PUSH
85790: LD_INT 0
85792: ST_TO_ADDR
// end ;
85793: LD_VAR 0 3
85797: RET
// export function HealTarget ( sci ) ; begin
85798: LD_INT 0
85800: PPUSH
// if not sci then
85801: LD_VAR 0 1
85805: NOT
85806: IFFALSE 85810
// exit ;
85808: GO 85875
// result := 0 ;
85810: LD_ADDR_VAR 0 2
85814: PUSH
85815: LD_INT 0
85817: ST_TO_ADDR
// if GetTaskList ( sci ) then
85818: LD_VAR 0 1
85822: PPUSH
85823: CALL_OW 437
85827: IFFALSE 85875
// if GetTaskList ( sci ) [ 1 ] [ 1 ] = l then
85829: LD_VAR 0 1
85833: PPUSH
85834: CALL_OW 437
85838: PUSH
85839: LD_INT 1
85841: ARRAY
85842: PUSH
85843: LD_INT 1
85845: ARRAY
85846: PUSH
85847: LD_STRING l
85849: EQUAL
85850: IFFALSE 85875
// result := GetTaskList ( sci ) [ 1 ] [ 4 ] ;
85852: LD_ADDR_VAR 0 2
85856: PUSH
85857: LD_VAR 0 1
85861: PPUSH
85862: CALL_OW 437
85866: PUSH
85867: LD_INT 1
85869: ARRAY
85870: PUSH
85871: LD_INT 4
85873: ARRAY
85874: ST_TO_ADDR
// end ;
85875: LD_VAR 0 2
85879: RET
// export function Attack ( list ) ; var base , group , path , flags , i , j , k , x , y , d , z , tmp , tmp2 , units_path , f_ignore_area , f_capture , f_ignore_civ , f_murder , f_mines , f_repair , f_heal , f_spacetime , f_attack_depot , f_crawl , mined , bombed , attacking , to_heal , healers , to_repair , repairs , empty_vehs , side ; begin
85880: LD_INT 0
85882: PPUSH
85883: PPUSH
85884: PPUSH
85885: PPUSH
85886: PPUSH
85887: PPUSH
85888: PPUSH
85889: PPUSH
85890: PPUSH
85891: PPUSH
85892: PPUSH
85893: PPUSH
85894: PPUSH
85895: PPUSH
85896: PPUSH
85897: PPUSH
85898: PPUSH
85899: PPUSH
85900: PPUSH
85901: PPUSH
85902: PPUSH
85903: PPUSH
85904: PPUSH
85905: PPUSH
85906: PPUSH
85907: PPUSH
85908: PPUSH
85909: PPUSH
85910: PPUSH
85911: PPUSH
85912: PPUSH
85913: PPUSH
85914: PPUSH
85915: PPUSH
// if not list then
85916: LD_VAR 0 1
85920: NOT
85921: IFFALSE 85925
// exit ;
85923: GO 90551
// base := list [ 1 ] ;
85925: LD_ADDR_VAR 0 3
85929: PUSH
85930: LD_VAR 0 1
85934: PUSH
85935: LD_INT 1
85937: ARRAY
85938: ST_TO_ADDR
// group := list [ 2 ] ;
85939: LD_ADDR_VAR 0 4
85943: PUSH
85944: LD_VAR 0 1
85948: PUSH
85949: LD_INT 2
85951: ARRAY
85952: ST_TO_ADDR
// path := list [ 3 ] ;
85953: LD_ADDR_VAR 0 5
85957: PUSH
85958: LD_VAR 0 1
85962: PUSH
85963: LD_INT 3
85965: ARRAY
85966: ST_TO_ADDR
// flags := list [ 4 ] ;
85967: LD_ADDR_VAR 0 6
85971: PUSH
85972: LD_VAR 0 1
85976: PUSH
85977: LD_INT 4
85979: ARRAY
85980: ST_TO_ADDR
// mined := [ ] ;
85981: LD_ADDR_VAR 0 27
85985: PUSH
85986: EMPTY
85987: ST_TO_ADDR
// bombed := [ ] ;
85988: LD_ADDR_VAR 0 28
85992: PUSH
85993: EMPTY
85994: ST_TO_ADDR
// healers := [ ] ;
85995: LD_ADDR_VAR 0 31
85999: PUSH
86000: EMPTY
86001: ST_TO_ADDR
// to_heal := [ ] ;
86002: LD_ADDR_VAR 0 30
86006: PUSH
86007: EMPTY
86008: ST_TO_ADDR
// repairs := [ ] ;
86009: LD_ADDR_VAR 0 33
86013: PUSH
86014: EMPTY
86015: ST_TO_ADDR
// to_repair := [ ] ;
86016: LD_ADDR_VAR 0 32
86020: PUSH
86021: EMPTY
86022: ST_TO_ADDR
// if not group or not path then
86023: LD_VAR 0 4
86027: NOT
86028: PUSH
86029: LD_VAR 0 5
86033: NOT
86034: OR
86035: IFFALSE 86039
// exit ;
86037: GO 90551
// side := GetSide ( group [ 1 ] ) ;
86039: LD_ADDR_VAR 0 35
86043: PUSH
86044: LD_VAR 0 4
86048: PUSH
86049: LD_INT 1
86051: ARRAY
86052: PPUSH
86053: CALL_OW 255
86057: ST_TO_ADDR
// if flags then
86058: LD_VAR 0 6
86062: IFFALSE 86206
// begin f_ignore_area := flags [ 1 ] ;
86064: LD_ADDR_VAR 0 17
86068: PUSH
86069: LD_VAR 0 6
86073: PUSH
86074: LD_INT 1
86076: ARRAY
86077: ST_TO_ADDR
// f_capture := flags [ 2 ] ;
86078: LD_ADDR_VAR 0 18
86082: PUSH
86083: LD_VAR 0 6
86087: PUSH
86088: LD_INT 2
86090: ARRAY
86091: ST_TO_ADDR
// f_ignore_civ := flags [ 3 ] ;
86092: LD_ADDR_VAR 0 19
86096: PUSH
86097: LD_VAR 0 6
86101: PUSH
86102: LD_INT 3
86104: ARRAY
86105: ST_TO_ADDR
// f_murder := flags [ 4 ] ;
86106: LD_ADDR_VAR 0 20
86110: PUSH
86111: LD_VAR 0 6
86115: PUSH
86116: LD_INT 4
86118: ARRAY
86119: ST_TO_ADDR
// f_mines := flags [ 5 ] ;
86120: LD_ADDR_VAR 0 21
86124: PUSH
86125: LD_VAR 0 6
86129: PUSH
86130: LD_INT 5
86132: ARRAY
86133: ST_TO_ADDR
// f_repair := flags [ 6 ] ;
86134: LD_ADDR_VAR 0 22
86138: PUSH
86139: LD_VAR 0 6
86143: PUSH
86144: LD_INT 6
86146: ARRAY
86147: ST_TO_ADDR
// f_heal := flags [ 7 ] ;
86148: LD_ADDR_VAR 0 23
86152: PUSH
86153: LD_VAR 0 6
86157: PUSH
86158: LD_INT 7
86160: ARRAY
86161: ST_TO_ADDR
// f_spacetime := flags [ 8 ] ;
86162: LD_ADDR_VAR 0 24
86166: PUSH
86167: LD_VAR 0 6
86171: PUSH
86172: LD_INT 8
86174: ARRAY
86175: ST_TO_ADDR
// f_attack_depot := flags [ 9 ] ;
86176: LD_ADDR_VAR 0 25
86180: PUSH
86181: LD_VAR 0 6
86185: PUSH
86186: LD_INT 9
86188: ARRAY
86189: ST_TO_ADDR
// f_crawl := flags [ 10 ] ;
86190: LD_ADDR_VAR 0 26
86194: PUSH
86195: LD_VAR 0 6
86199: PUSH
86200: LD_INT 10
86202: ARRAY
86203: ST_TO_ADDR
// end else
86204: GO 86286
// begin f_ignore_area := false ;
86206: LD_ADDR_VAR 0 17
86210: PUSH
86211: LD_INT 0
86213: ST_TO_ADDR
// f_capture := false ;
86214: LD_ADDR_VAR 0 18
86218: PUSH
86219: LD_INT 0
86221: ST_TO_ADDR
// f_ignore_civ := false ;
86222: LD_ADDR_VAR 0 19
86226: PUSH
86227: LD_INT 0
86229: ST_TO_ADDR
// f_murder := false ;
86230: LD_ADDR_VAR 0 20
86234: PUSH
86235: LD_INT 0
86237: ST_TO_ADDR
// f_mines := false ;
86238: LD_ADDR_VAR 0 21
86242: PUSH
86243: LD_INT 0
86245: ST_TO_ADDR
// f_repair := false ;
86246: LD_ADDR_VAR 0 22
86250: PUSH
86251: LD_INT 0
86253: ST_TO_ADDR
// f_heal := false ;
86254: LD_ADDR_VAR 0 23
86258: PUSH
86259: LD_INT 0
86261: ST_TO_ADDR
// f_spacetime := false ;
86262: LD_ADDR_VAR 0 24
86266: PUSH
86267: LD_INT 0
86269: ST_TO_ADDR
// f_attack_depot := false ;
86270: LD_ADDR_VAR 0 25
86274: PUSH
86275: LD_INT 0
86277: ST_TO_ADDR
// f_crawl := false ;
86278: LD_ADDR_VAR 0 26
86282: PUSH
86283: LD_INT 0
86285: ST_TO_ADDR
// end ; if f_heal then
86286: LD_VAR 0 23
86290: IFFALSE 86317
// healers := UnitFilter ( group , [ f_class , 4 ] ) ;
86292: LD_ADDR_VAR 0 31
86296: PUSH
86297: LD_VAR 0 4
86301: PPUSH
86302: LD_INT 25
86304: PUSH
86305: LD_INT 4
86307: PUSH
86308: EMPTY
86309: LIST
86310: LIST
86311: PPUSH
86312: CALL_OW 72
86316: ST_TO_ADDR
// if f_repair then
86317: LD_VAR 0 22
86321: IFFALSE 86348
// repairs := UnitFilter ( group , [ f_class , 3 ] ) ;
86323: LD_ADDR_VAR 0 33
86327: PUSH
86328: LD_VAR 0 4
86332: PPUSH
86333: LD_INT 25
86335: PUSH
86336: LD_INT 3
86338: PUSH
86339: EMPTY
86340: LIST
86341: LIST
86342: PPUSH
86343: CALL_OW 72
86347: ST_TO_ADDR
// units_path := [ ] ;
86348: LD_ADDR_VAR 0 16
86352: PUSH
86353: EMPTY
86354: ST_TO_ADDR
// for i = 1 to group do
86355: LD_ADDR_VAR 0 7
86359: PUSH
86360: DOUBLE
86361: LD_INT 1
86363: DEC
86364: ST_TO_ADDR
86365: LD_VAR 0 4
86369: PUSH
86370: FOR_TO
86371: IFFALSE 86400
// units_path := Replace ( units_path , i , path ) ;
86373: LD_ADDR_VAR 0 16
86377: PUSH
86378: LD_VAR 0 16
86382: PPUSH
86383: LD_VAR 0 7
86387: PPUSH
86388: LD_VAR 0 5
86392: PPUSH
86393: CALL_OW 1
86397: ST_TO_ADDR
86398: GO 86370
86400: POP
86401: POP
// repeat for i = group downto 1 do
86402: LD_ADDR_VAR 0 7
86406: PUSH
86407: DOUBLE
86408: LD_VAR 0 4
86412: INC
86413: ST_TO_ADDR
86414: LD_INT 1
86416: PUSH
86417: FOR_DOWNTO
86418: IFFALSE 90514
// begin wait ( 5 ) ;
86420: LD_INT 5
86422: PPUSH
86423: CALL_OW 67
// tmp := [ ] ;
86427: LD_ADDR_VAR 0 14
86431: PUSH
86432: EMPTY
86433: ST_TO_ADDR
// attacking := false ;
86434: LD_ADDR_VAR 0 29
86438: PUSH
86439: LD_INT 0
86441: ST_TO_ADDR
// if IsDead ( group [ i ] ) or not group [ i ] then
86442: LD_VAR 0 4
86446: PUSH
86447: LD_VAR 0 7
86451: ARRAY
86452: PPUSH
86453: CALL_OW 301
86457: PUSH
86458: LD_VAR 0 4
86462: PUSH
86463: LD_VAR 0 7
86467: ARRAY
86468: NOT
86469: OR
86470: IFFALSE 86579
// begin if GetType ( group [ i ] ) = unit_human then
86472: LD_VAR 0 4
86476: PUSH
86477: LD_VAR 0 7
86481: ARRAY
86482: PPUSH
86483: CALL_OW 247
86487: PUSH
86488: LD_INT 1
86490: EQUAL
86491: IFFALSE 86537
// begin to_heal := to_heal diff group [ i ] ;
86493: LD_ADDR_VAR 0 30
86497: PUSH
86498: LD_VAR 0 30
86502: PUSH
86503: LD_VAR 0 4
86507: PUSH
86508: LD_VAR 0 7
86512: ARRAY
86513: DIFF
86514: ST_TO_ADDR
// healers := healers diff group [ i ] ;
86515: LD_ADDR_VAR 0 31
86519: PUSH
86520: LD_VAR 0 31
86524: PUSH
86525: LD_VAR 0 4
86529: PUSH
86530: LD_VAR 0 7
86534: ARRAY
86535: DIFF
86536: ST_TO_ADDR
// end ; group := Delete ( group , i ) ;
86537: LD_ADDR_VAR 0 4
86541: PUSH
86542: LD_VAR 0 4
86546: PPUSH
86547: LD_VAR 0 7
86551: PPUSH
86552: CALL_OW 3
86556: ST_TO_ADDR
// units_path := Delete ( units_path , i ) ;
86557: LD_ADDR_VAR 0 16
86561: PUSH
86562: LD_VAR 0 16
86566: PPUSH
86567: LD_VAR 0 7
86571: PPUSH
86572: CALL_OW 3
86576: ST_TO_ADDR
// continue ;
86577: GO 86417
// end ; if f_repair then
86579: LD_VAR 0 22
86583: IFFALSE 87072
// begin if GetType ( group [ i ] ) = unit_vehicle then
86585: LD_VAR 0 4
86589: PUSH
86590: LD_VAR 0 7
86594: ARRAY
86595: PPUSH
86596: CALL_OW 247
86600: PUSH
86601: LD_INT 2
86603: EQUAL
86604: IFFALSE 86794
// begin if GetLives ( group [ i ] ) < 700 and not group [ i ] in to_repair then
86606: LD_VAR 0 4
86610: PUSH
86611: LD_VAR 0 7
86615: ARRAY
86616: PPUSH
86617: CALL_OW 256
86621: PUSH
86622: LD_INT 700
86624: LESS
86625: PUSH
86626: LD_VAR 0 4
86630: PUSH
86631: LD_VAR 0 7
86635: ARRAY
86636: PUSH
86637: LD_VAR 0 32
86641: IN
86642: NOT
86643: AND
86644: IFFALSE 86668
// to_repair := to_repair union group [ i ] ;
86646: LD_ADDR_VAR 0 32
86650: PUSH
86651: LD_VAR 0 32
86655: PUSH
86656: LD_VAR 0 4
86660: PUSH
86661: LD_VAR 0 7
86665: ARRAY
86666: UNION
86667: ST_TO_ADDR
// if GetLives ( group [ i ] ) = 1000 and group [ i ] in to_repair then
86668: LD_VAR 0 4
86672: PUSH
86673: LD_VAR 0 7
86677: ARRAY
86678: PPUSH
86679: CALL_OW 256
86683: PUSH
86684: LD_INT 1000
86686: EQUAL
86687: PUSH
86688: LD_VAR 0 4
86692: PUSH
86693: LD_VAR 0 7
86697: ARRAY
86698: PUSH
86699: LD_VAR 0 32
86703: IN
86704: AND
86705: IFFALSE 86729
// to_repair := to_repair diff group [ i ] ;
86707: LD_ADDR_VAR 0 32
86711: PUSH
86712: LD_VAR 0 32
86716: PUSH
86717: LD_VAR 0 4
86721: PUSH
86722: LD_VAR 0 7
86726: ARRAY
86727: DIFF
86728: ST_TO_ADDR
// if group [ i ] in to_repair then
86729: LD_VAR 0 4
86733: PUSH
86734: LD_VAR 0 7
86738: ARRAY
86739: PUSH
86740: LD_VAR 0 32
86744: IN
86745: IFFALSE 86792
// begin if not IsInArea ( group [ i ] , f_repair ) then
86747: LD_VAR 0 4
86751: PUSH
86752: LD_VAR 0 7
86756: ARRAY
86757: PPUSH
86758: LD_VAR 0 22
86762: PPUSH
86763: CALL_OW 308
86767: NOT
86768: IFFALSE 86790
// ComMoveToArea ( group [ i ] , f_repair ) ;
86770: LD_VAR 0 4
86774: PUSH
86775: LD_VAR 0 7
86779: ARRAY
86780: PPUSH
86781: LD_VAR 0 22
86785: PPUSH
86786: CALL_OW 113
// continue ;
86790: GO 86417
// end ; end else
86792: GO 87072
// if group [ i ] in repairs then
86794: LD_VAR 0 4
86798: PUSH
86799: LD_VAR 0 7
86803: ARRAY
86804: PUSH
86805: LD_VAR 0 33
86809: IN
86810: IFFALSE 87072
// begin if IsInUnit ( group [ i ] ) then
86812: LD_VAR 0 4
86816: PUSH
86817: LD_VAR 0 7
86821: ARRAY
86822: PPUSH
86823: CALL_OW 310
86827: IFFALSE 86895
// begin z := IsInUnit ( group [ i ] ) ;
86829: LD_ADDR_VAR 0 13
86833: PUSH
86834: LD_VAR 0 4
86838: PUSH
86839: LD_VAR 0 7
86843: ARRAY
86844: PPUSH
86845: CALL_OW 310
86849: ST_TO_ADDR
// if z in to_repair and IsInArea ( z , f_repair ) then
86850: LD_VAR 0 13
86854: PUSH
86855: LD_VAR 0 32
86859: IN
86860: PUSH
86861: LD_VAR 0 13
86865: PPUSH
86866: LD_VAR 0 22
86870: PPUSH
86871: CALL_OW 308
86875: AND
86876: IFFALSE 86893
// ComExitVehicle ( group [ i ] ) ;
86878: LD_VAR 0 4
86882: PUSH
86883: LD_VAR 0 7
86887: ARRAY
86888: PPUSH
86889: CALL_OW 121
// end else
86893: GO 87072
// begin z := UnitFilter ( group , [ [ f_inarea , f_repair ] , [ f_empty ] ] ) ;
86895: LD_ADDR_VAR 0 13
86899: PUSH
86900: LD_VAR 0 4
86904: PPUSH
86905: LD_INT 95
86907: PUSH
86908: LD_VAR 0 22
86912: PUSH
86913: EMPTY
86914: LIST
86915: LIST
86916: PUSH
86917: LD_INT 58
86919: PUSH
86920: EMPTY
86921: LIST
86922: PUSH
86923: EMPTY
86924: LIST
86925: LIST
86926: PPUSH
86927: CALL_OW 72
86931: ST_TO_ADDR
// if not HasTask ( group [ i ] ) then
86932: LD_VAR 0 4
86936: PUSH
86937: LD_VAR 0 7
86941: ARRAY
86942: PPUSH
86943: CALL_OW 314
86947: NOT
86948: IFFALSE 87070
// begin x := NearestUnitToUnit ( z , group [ i ] ) ;
86950: LD_ADDR_VAR 0 10
86954: PUSH
86955: LD_VAR 0 13
86959: PPUSH
86960: LD_VAR 0 4
86964: PUSH
86965: LD_VAR 0 7
86969: ARRAY
86970: PPUSH
86971: CALL_OW 74
86975: ST_TO_ADDR
// if not x then
86976: LD_VAR 0 10
86980: NOT
86981: IFFALSE 86985
// continue ;
86983: GO 86417
// if GetLives ( x ) < 1000 then
86985: LD_VAR 0 10
86989: PPUSH
86990: CALL_OW 256
86994: PUSH
86995: LD_INT 1000
86997: LESS
86998: IFFALSE 87022
// ComRepairVehicle ( group [ i ] , x ) else
87000: LD_VAR 0 4
87004: PUSH
87005: LD_VAR 0 7
87009: ARRAY
87010: PPUSH
87011: LD_VAR 0 10
87015: PPUSH
87016: CALL_OW 129
87020: GO 87070
// if not ( f_heal and GetLives ( group [ i ] ) < 1000 ) then
87022: LD_VAR 0 23
87026: PUSH
87027: LD_VAR 0 4
87031: PUSH
87032: LD_VAR 0 7
87036: ARRAY
87037: PPUSH
87038: CALL_OW 256
87042: PUSH
87043: LD_INT 1000
87045: LESS
87046: AND
87047: NOT
87048: IFFALSE 87070
// ComEnterUnit ( group [ i ] , x ) ;
87050: LD_VAR 0 4
87054: PUSH
87055: LD_VAR 0 7
87059: ARRAY
87060: PPUSH
87061: LD_VAR 0 10
87065: PPUSH
87066: CALL_OW 120
// end ; continue ;
87070: GO 86417
// end ; end ; end ; if f_heal and GetType ( group [ i ] ) = unit_human then
87072: LD_VAR 0 23
87076: PUSH
87077: LD_VAR 0 4
87081: PUSH
87082: LD_VAR 0 7
87086: ARRAY
87087: PPUSH
87088: CALL_OW 247
87092: PUSH
87093: LD_INT 1
87095: EQUAL
87096: AND
87097: IFFALSE 87575
// begin if group [ i ] in healers then
87099: LD_VAR 0 4
87103: PUSH
87104: LD_VAR 0 7
87108: ARRAY
87109: PUSH
87110: LD_VAR 0 31
87114: IN
87115: IFFALSE 87388
// begin if not IsInArea ( group [ i ] , f_heal ) and not HasTask ( group [ i ] ) then
87117: LD_VAR 0 4
87121: PUSH
87122: LD_VAR 0 7
87126: ARRAY
87127: PPUSH
87128: LD_VAR 0 23
87132: PPUSH
87133: CALL_OW 308
87137: NOT
87138: PUSH
87139: LD_VAR 0 4
87143: PUSH
87144: LD_VAR 0 7
87148: ARRAY
87149: PPUSH
87150: CALL_OW 314
87154: NOT
87155: AND
87156: IFFALSE 87180
// ComMoveToArea ( group [ i ] , f_heal ) else
87158: LD_VAR 0 4
87162: PUSH
87163: LD_VAR 0 7
87167: ARRAY
87168: PPUSH
87169: LD_VAR 0 23
87173: PPUSH
87174: CALL_OW 113
87178: GO 87386
// if GetLives ( HealTarget ( group [ i ] ) ) = 1000 then
87180: LD_VAR 0 4
87184: PUSH
87185: LD_VAR 0 7
87189: ARRAY
87190: PPUSH
87191: CALL 85798 0 1
87195: PPUSH
87196: CALL_OW 256
87200: PUSH
87201: LD_INT 1000
87203: EQUAL
87204: IFFALSE 87223
// ComStop ( group [ i ] ) else
87206: LD_VAR 0 4
87210: PUSH
87211: LD_VAR 0 7
87215: ARRAY
87216: PPUSH
87217: CALL_OW 141
87221: GO 87386
// if not HasTask ( group [ i ] ) and to_heal then
87223: LD_VAR 0 4
87227: PUSH
87228: LD_VAR 0 7
87232: ARRAY
87233: PPUSH
87234: CALL_OW 314
87238: NOT
87239: PUSH
87240: LD_VAR 0 30
87244: AND
87245: IFFALSE 87386
// begin z := NearestUnitToUnit ( UnitFilter ( to_heal , [ f_not , [ f_inside ] ] ) , group [ i ] ) ;
87247: LD_ADDR_VAR 0 13
87251: PUSH
87252: LD_VAR 0 30
87256: PPUSH
87257: LD_INT 3
87259: PUSH
87260: LD_INT 54
87262: PUSH
87263: EMPTY
87264: LIST
87265: PUSH
87266: EMPTY
87267: LIST
87268: LIST
87269: PPUSH
87270: CALL_OW 72
87274: PPUSH
87275: LD_VAR 0 4
87279: PUSH
87280: LD_VAR 0 7
87284: ARRAY
87285: PPUSH
87286: CALL_OW 74
87290: ST_TO_ADDR
// if z then
87291: LD_VAR 0 13
87295: IFFALSE 87386
// if FilterAllUnits ( [ [ f_dist , z , 10 ] , [ f_enemy , GetSide ( z ) ] ] ) = 0 then
87297: LD_INT 91
87299: PUSH
87300: LD_VAR 0 13
87304: PUSH
87305: LD_INT 10
87307: PUSH
87308: EMPTY
87309: LIST
87310: LIST
87311: LIST
87312: PUSH
87313: LD_INT 81
87315: PUSH
87316: LD_VAR 0 13
87320: PPUSH
87321: CALL_OW 255
87325: PUSH
87326: EMPTY
87327: LIST
87328: LIST
87329: PUSH
87330: EMPTY
87331: LIST
87332: LIST
87333: PPUSH
87334: CALL_OW 69
87338: PUSH
87339: LD_INT 0
87341: EQUAL
87342: IFFALSE 87366
// ComHeal ( group [ i ] , z ) else
87344: LD_VAR 0 4
87348: PUSH
87349: LD_VAR 0 7
87353: ARRAY
87354: PPUSH
87355: LD_VAR 0 13
87359: PPUSH
87360: CALL_OW 128
87364: GO 87386
// ComMoveToArea ( group [ i ] , f_heal ) ;
87366: LD_VAR 0 4
87370: PUSH
87371: LD_VAR 0 7
87375: ARRAY
87376: PPUSH
87377: LD_VAR 0 23
87381: PPUSH
87382: CALL_OW 113
// end ; continue ;
87386: GO 86417
// end ; if GetLives ( group [ i ] ) < 700 and not group [ i ] in to_heal then
87388: LD_VAR 0 4
87392: PUSH
87393: LD_VAR 0 7
87397: ARRAY
87398: PPUSH
87399: CALL_OW 256
87403: PUSH
87404: LD_INT 700
87406: LESS
87407: PUSH
87408: LD_VAR 0 4
87412: PUSH
87413: LD_VAR 0 7
87417: ARRAY
87418: PUSH
87419: LD_VAR 0 30
87423: IN
87424: NOT
87425: AND
87426: IFFALSE 87450
// to_heal := to_heal union group [ i ] ;
87428: LD_ADDR_VAR 0 30
87432: PUSH
87433: LD_VAR 0 30
87437: PUSH
87438: LD_VAR 0 4
87442: PUSH
87443: LD_VAR 0 7
87447: ARRAY
87448: UNION
87449: ST_TO_ADDR
// if group [ i ] in to_heal then
87450: LD_VAR 0 4
87454: PUSH
87455: LD_VAR 0 7
87459: ARRAY
87460: PUSH
87461: LD_VAR 0 30
87465: IN
87466: IFFALSE 87575
// begin if GetLives ( group [ i ] ) = 1000 then
87468: LD_VAR 0 4
87472: PUSH
87473: LD_VAR 0 7
87477: ARRAY
87478: PPUSH
87479: CALL_OW 256
87483: PUSH
87484: LD_INT 1000
87486: EQUAL
87487: IFFALSE 87513
// to_heal := to_heal diff group [ i ] else
87489: LD_ADDR_VAR 0 30
87493: PUSH
87494: LD_VAR 0 30
87498: PUSH
87499: LD_VAR 0 4
87503: PUSH
87504: LD_VAR 0 7
87508: ARRAY
87509: DIFF
87510: ST_TO_ADDR
87511: GO 87575
// begin if not IsInArea ( group [ i ] , to_heal ) then
87513: LD_VAR 0 4
87517: PUSH
87518: LD_VAR 0 7
87522: ARRAY
87523: PPUSH
87524: LD_VAR 0 30
87528: PPUSH
87529: CALL_OW 308
87533: NOT
87534: IFFALSE 87558
// ComMoveToArea ( group [ i ] , f_heal ) else
87536: LD_VAR 0 4
87540: PUSH
87541: LD_VAR 0 7
87545: ARRAY
87546: PPUSH
87547: LD_VAR 0 23
87551: PPUSH
87552: CALL_OW 113
87556: GO 87573
// ComHold ( group [ i ] ) ;
87558: LD_VAR 0 4
87562: PUSH
87563: LD_VAR 0 7
87567: ARRAY
87568: PPUSH
87569: CALL_OW 140
// continue ;
87573: GO 86417
// end ; end ; end ; if not EnemyInRange ( group [ i ] , 10 ) and not units_path [ i ] = [ ] then
87575: LD_VAR 0 4
87579: PUSH
87580: LD_VAR 0 7
87584: ARRAY
87585: PPUSH
87586: LD_INT 10
87588: PPUSH
87589: CALL 84195 0 2
87593: NOT
87594: PUSH
87595: LD_VAR 0 16
87599: PUSH
87600: LD_VAR 0 7
87604: ARRAY
87605: PUSH
87606: EMPTY
87607: EQUAL
87608: NOT
87609: AND
87610: IFFALSE 87876
// begin if GetEngine ( group [ i ] ) in [ engine_combustion , engine_solar ] then
87612: LD_VAR 0 4
87616: PUSH
87617: LD_VAR 0 7
87621: ARRAY
87622: PPUSH
87623: CALL_OW 262
87627: PUSH
87628: LD_INT 1
87630: PUSH
87631: LD_INT 2
87633: PUSH
87634: EMPTY
87635: LIST
87636: LIST
87637: IN
87638: IFFALSE 87679
// if GetFuel ( group [ i ] ) < 10 then
87640: LD_VAR 0 4
87644: PUSH
87645: LD_VAR 0 7
87649: ARRAY
87650: PPUSH
87651: CALL_OW 261
87655: PUSH
87656: LD_INT 10
87658: LESS
87659: IFFALSE 87679
// SetFuel ( group [ i ] , 12 ) ;
87661: LD_VAR 0 4
87665: PUSH
87666: LD_VAR 0 7
87670: ARRAY
87671: PPUSH
87672: LD_INT 12
87674: PPUSH
87675: CALL_OW 240
// if units_path [ i ] then
87679: LD_VAR 0 16
87683: PUSH
87684: LD_VAR 0 7
87688: ARRAY
87689: IFFALSE 87874
// begin if GetDistUnitXY ( group [ i ] , units_path [ i ] [ 1 ] [ 1 ] , units_path [ i ] [ 1 ] [ 2 ] ) > 6 then
87691: LD_VAR 0 4
87695: PUSH
87696: LD_VAR 0 7
87700: ARRAY
87701: PPUSH
87702: LD_VAR 0 16
87706: PUSH
87707: LD_VAR 0 7
87711: ARRAY
87712: PUSH
87713: LD_INT 1
87715: ARRAY
87716: PUSH
87717: LD_INT 1
87719: ARRAY
87720: PPUSH
87721: LD_VAR 0 16
87725: PUSH
87726: LD_VAR 0 7
87730: ARRAY
87731: PUSH
87732: LD_INT 1
87734: ARRAY
87735: PUSH
87736: LD_INT 2
87738: ARRAY
87739: PPUSH
87740: CALL_OW 297
87744: PUSH
87745: LD_INT 6
87747: GREATER
87748: IFFALSE 87823
// begin if not HasTask ( group [ i ] ) then
87750: LD_VAR 0 4
87754: PUSH
87755: LD_VAR 0 7
87759: ARRAY
87760: PPUSH
87761: CALL_OW 314
87765: NOT
87766: IFFALSE 87821
// ComAgressiveMove ( group [ i ] , units_path [ i ] [ 1 ] [ 1 ] , units_path [ i ] [ 1 ] [ 2 ] ) ;
87768: LD_VAR 0 4
87772: PUSH
87773: LD_VAR 0 7
87777: ARRAY
87778: PPUSH
87779: LD_VAR 0 16
87783: PUSH
87784: LD_VAR 0 7
87788: ARRAY
87789: PUSH
87790: LD_INT 1
87792: ARRAY
87793: PUSH
87794: LD_INT 1
87796: ARRAY
87797: PPUSH
87798: LD_VAR 0 16
87802: PUSH
87803: LD_VAR 0 7
87807: ARRAY
87808: PUSH
87809: LD_INT 1
87811: ARRAY
87812: PUSH
87813: LD_INT 2
87815: ARRAY
87816: PPUSH
87817: CALL_OW 114
// end else
87821: GO 87874
// begin tmp2 := Delete ( units_path [ i ] , 1 ) ;
87823: LD_ADDR_VAR 0 15
87827: PUSH
87828: LD_VAR 0 16
87832: PUSH
87833: LD_VAR 0 7
87837: ARRAY
87838: PPUSH
87839: LD_INT 1
87841: PPUSH
87842: CALL_OW 3
87846: ST_TO_ADDR
// units_path := Replace ( units_path , i , tmp2 ) ;
87847: LD_ADDR_VAR 0 16
87851: PUSH
87852: LD_VAR 0 16
87856: PPUSH
87857: LD_VAR 0 7
87861: PPUSH
87862: LD_VAR 0 15
87866: PPUSH
87867: CALL_OW 1
87871: ST_TO_ADDR
// continue ;
87872: GO 86417
// end ; end ; end else
87874: GO 90512
// begin tmp := FilterAllUnits ( [ f_enemy , GetSide ( group [ i ] ) ] ) ;
87876: LD_ADDR_VAR 0 14
87880: PUSH
87881: LD_INT 81
87883: PUSH
87884: LD_VAR 0 4
87888: PUSH
87889: LD_VAR 0 7
87893: ARRAY
87894: PPUSH
87895: CALL_OW 255
87899: PUSH
87900: EMPTY
87901: LIST
87902: LIST
87903: PPUSH
87904: CALL_OW 69
87908: ST_TO_ADDR
// if not tmp then
87909: LD_VAR 0 14
87913: NOT
87914: IFFALSE 87918
// continue ;
87916: GO 86417
// if f_ignore_area then
87918: LD_VAR 0 17
87922: IFFALSE 88010
// begin tmp2 := UnitFilter ( tmp , [ f_not , [ f_distxy , f_ignore_area [ 1 ] , f_ignore_area [ 2 ] , f_ignore_area [ 3 ] ] ] ) ;
87924: LD_ADDR_VAR 0 15
87928: PUSH
87929: LD_VAR 0 14
87933: PPUSH
87934: LD_INT 3
87936: PUSH
87937: LD_INT 92
87939: PUSH
87940: LD_VAR 0 17
87944: PUSH
87945: LD_INT 1
87947: ARRAY
87948: PUSH
87949: LD_VAR 0 17
87953: PUSH
87954: LD_INT 2
87956: ARRAY
87957: PUSH
87958: LD_VAR 0 17
87962: PUSH
87963: LD_INT 3
87965: ARRAY
87966: PUSH
87967: EMPTY
87968: LIST
87969: LIST
87970: LIST
87971: LIST
87972: PUSH
87973: EMPTY
87974: LIST
87975: LIST
87976: PPUSH
87977: CALL_OW 72
87981: ST_TO_ADDR
// if ( tmp diff tmp2 ) then
87982: LD_VAR 0 14
87986: PUSH
87987: LD_VAR 0 15
87991: DIFF
87992: IFFALSE 88010
// tmp := tmp diff tmp2 ;
87994: LD_ADDR_VAR 0 14
87998: PUSH
87999: LD_VAR 0 14
88003: PUSH
88004: LD_VAR 0 15
88008: DIFF
88009: ST_TO_ADDR
// end ; if not f_murder then
88010: LD_VAR 0 20
88014: NOT
88015: IFFALSE 88073
// begin tmp2 := UnitFilter ( tmp , [ f_not , [ f_ok ] ] ) ;
88017: LD_ADDR_VAR 0 15
88021: PUSH
88022: LD_VAR 0 14
88026: PPUSH
88027: LD_INT 3
88029: PUSH
88030: LD_INT 50
88032: PUSH
88033: EMPTY
88034: LIST
88035: PUSH
88036: EMPTY
88037: LIST
88038: LIST
88039: PPUSH
88040: CALL_OW 72
88044: ST_TO_ADDR
// if ( tmp diff tmp2 ) then
88045: LD_VAR 0 14
88049: PUSH
88050: LD_VAR 0 15
88054: DIFF
88055: IFFALSE 88073
// tmp := tmp diff tmp2 ;
88057: LD_ADDR_VAR 0 14
88061: PUSH
88062: LD_VAR 0 14
88066: PUSH
88067: LD_VAR 0 15
88071: DIFF
88072: ST_TO_ADDR
// end ; tmp := SortByDistanceUnit ( group [ i ] , tmp , true , true ) ;
88073: LD_ADDR_VAR 0 14
88077: PUSH
88078: LD_VAR 0 4
88082: PUSH
88083: LD_VAR 0 7
88087: ARRAY
88088: PPUSH
88089: LD_VAR 0 14
88093: PPUSH
88094: LD_INT 1
88096: PPUSH
88097: LD_INT 1
88099: PPUSH
88100: CALL 57838 0 4
88104: ST_TO_ADDR
// if GetClass ( group [ i ] ) = 1 then
88105: LD_VAR 0 4
88109: PUSH
88110: LD_VAR 0 7
88114: ARRAY
88115: PPUSH
88116: CALL_OW 257
88120: PUSH
88121: LD_INT 1
88123: EQUAL
88124: IFFALSE 88572
// begin if WantPlant ( group [ i ] ) then
88126: LD_VAR 0 4
88130: PUSH
88131: LD_VAR 0 7
88135: ARRAY
88136: PPUSH
88137: CALL 57339 0 1
88141: IFFALSE 88145
// continue ;
88143: GO 86417
// if f_capture and not IsInUnit ( group [ i ] ) and tmp [ 1 ] in UnitFilter ( tmp , [ [ f_type , unit_vehicle ] , [ f_empty ] ] ) then
88145: LD_VAR 0 18
88149: PUSH
88150: LD_VAR 0 4
88154: PUSH
88155: LD_VAR 0 7
88159: ARRAY
88160: PPUSH
88161: CALL_OW 310
88165: NOT
88166: AND
88167: PUSH
88168: LD_VAR 0 14
88172: PUSH
88173: LD_INT 1
88175: ARRAY
88176: PUSH
88177: LD_VAR 0 14
88181: PPUSH
88182: LD_INT 21
88184: PUSH
88185: LD_INT 2
88187: PUSH
88188: EMPTY
88189: LIST
88190: LIST
88191: PUSH
88192: LD_INT 58
88194: PUSH
88195: EMPTY
88196: LIST
88197: PUSH
88198: EMPTY
88199: LIST
88200: LIST
88201: PPUSH
88202: CALL_OW 72
88206: IN
88207: AND
88208: IFFALSE 88244
// begin ComEnterUnit ( group [ i ] , tmp [ 1 ] ) ;
88210: LD_VAR 0 4
88214: PUSH
88215: LD_VAR 0 7
88219: ARRAY
88220: PPUSH
88221: LD_VAR 0 14
88225: PUSH
88226: LD_INT 1
88228: ARRAY
88229: PPUSH
88230: CALL_OW 120
// attacking := true ;
88234: LD_ADDR_VAR 0 29
88238: PUSH
88239: LD_INT 1
88241: ST_TO_ADDR
// continue ;
88242: GO 86417
// end ; if f_crawl and GetClass ( group [ i ] ) = 1 and GetLives ( group [ i ] ) < 800 and not Crawls ( group [ i ] ) then
88244: LD_VAR 0 26
88248: PUSH
88249: LD_VAR 0 4
88253: PUSH
88254: LD_VAR 0 7
88258: ARRAY
88259: PPUSH
88260: CALL_OW 257
88264: PUSH
88265: LD_INT 1
88267: EQUAL
88268: AND
88269: PUSH
88270: LD_VAR 0 4
88274: PUSH
88275: LD_VAR 0 7
88279: ARRAY
88280: PPUSH
88281: CALL_OW 256
88285: PUSH
88286: LD_INT 800
88288: LESS
88289: AND
88290: PUSH
88291: LD_VAR 0 4
88295: PUSH
88296: LD_VAR 0 7
88300: ARRAY
88301: PPUSH
88302: CALL_OW 318
88306: NOT
88307: AND
88308: IFFALSE 88325
// ComCrawl ( group [ i ] ) ;
88310: LD_VAR 0 4
88314: PUSH
88315: LD_VAR 0 7
88319: ARRAY
88320: PPUSH
88321: CALL_OW 137
// if f_mines then
88325: LD_VAR 0 21
88329: IFFALSE 88572
// begin if GetType ( tmp [ 1 ] ) = unit_building and not tmp [ 1 ] in mined then
88331: LD_VAR 0 14
88335: PUSH
88336: LD_INT 1
88338: ARRAY
88339: PPUSH
88340: CALL_OW 247
88344: PUSH
88345: LD_INT 3
88347: EQUAL
88348: PUSH
88349: LD_VAR 0 14
88353: PUSH
88354: LD_INT 1
88356: ARRAY
88357: PUSH
88358: LD_VAR 0 27
88362: IN
88363: NOT
88364: AND
88365: IFFALSE 88572
// begin x := GetX ( tmp [ 1 ] ) ;
88367: LD_ADDR_VAR 0 10
88371: PUSH
88372: LD_VAR 0 14
88376: PUSH
88377: LD_INT 1
88379: ARRAY
88380: PPUSH
88381: CALL_OW 250
88385: ST_TO_ADDR
// y := GetY ( tmp [ 1 ] ) ;
88386: LD_ADDR_VAR 0 11
88390: PUSH
88391: LD_VAR 0 14
88395: PUSH
88396: LD_INT 1
88398: ARRAY
88399: PPUSH
88400: CALL_OW 251
88404: ST_TO_ADDR
// d := ReverseDir ( group [ i ] ) ;
88405: LD_ADDR_VAR 0 12
88409: PUSH
88410: LD_VAR 0 4
88414: PUSH
88415: LD_VAR 0 7
88419: ARRAY
88420: PPUSH
88421: CALL 84280 0 1
88425: ST_TO_ADDR
// ComPlaceDelayedCharge ( group [ i ] , x , y , tmp [ 1 ] ) ;
88426: LD_VAR 0 4
88430: PUSH
88431: LD_VAR 0 7
88435: ARRAY
88436: PPUSH
88437: LD_VAR 0 10
88441: PPUSH
88442: LD_VAR 0 11
88446: PPUSH
88447: LD_VAR 0 14
88451: PUSH
88452: LD_INT 1
88454: ARRAY
88455: PPUSH
88456: CALL_OW 132
// AddComMoveXY ( group [ i ] , ShiftX ( x , d , 7 ) , ShiftY ( y , d , 7 ) ) ;
88460: LD_VAR 0 4
88464: PUSH
88465: LD_VAR 0 7
88469: ARRAY
88470: PPUSH
88471: LD_VAR 0 10
88475: PPUSH
88476: LD_VAR 0 12
88480: PPUSH
88481: LD_INT 7
88483: PPUSH
88484: CALL_OW 272
88488: PPUSH
88489: LD_VAR 0 11
88493: PPUSH
88494: LD_VAR 0 12
88498: PPUSH
88499: LD_INT 7
88501: PPUSH
88502: CALL_OW 273
88506: PPUSH
88507: CALL_OW 171
// SetTag ( group [ i ] , 71 ) ;
88511: LD_VAR 0 4
88515: PUSH
88516: LD_VAR 0 7
88520: ARRAY
88521: PPUSH
88522: LD_INT 71
88524: PPUSH
88525: CALL_OW 109
// mined := Replace ( mined , mined + 1 , tmp [ 1 ] ) ;
88529: LD_ADDR_VAR 0 27
88533: PUSH
88534: LD_VAR 0 27
88538: PPUSH
88539: LD_VAR 0 27
88543: PUSH
88544: LD_INT 1
88546: PLUS
88547: PPUSH
88548: LD_VAR 0 14
88552: PUSH
88553: LD_INT 1
88555: ARRAY
88556: PPUSH
88557: CALL_OW 1
88561: ST_TO_ADDR
// attacking := true ;
88562: LD_ADDR_VAR 0 29
88566: PUSH
88567: LD_INT 1
88569: ST_TO_ADDR
// continue ;
88570: GO 86417
// end ; end ; end ; if GetClass ( group [ i ] ) = 17 and not GetTag ( group [ i ] ) = 71 then
88572: LD_VAR 0 4
88576: PUSH
88577: LD_VAR 0 7
88581: ARRAY
88582: PPUSH
88583: CALL_OW 257
88587: PUSH
88588: LD_INT 17
88590: EQUAL
88591: PUSH
88592: LD_VAR 0 4
88596: PUSH
88597: LD_VAR 0 7
88601: ARRAY
88602: PPUSH
88603: CALL_OW 110
88607: PUSH
88608: LD_INT 71
88610: EQUAL
88611: NOT
88612: AND
88613: IFFALSE 88759
// begin attacking := false ;
88615: LD_ADDR_VAR 0 29
88619: PUSH
88620: LD_INT 0
88622: ST_TO_ADDR
// k := 5 ;
88623: LD_ADDR_VAR 0 9
88627: PUSH
88628: LD_INT 5
88630: ST_TO_ADDR
// if tmp < k then
88631: LD_VAR 0 14
88635: PUSH
88636: LD_VAR 0 9
88640: LESS
88641: IFFALSE 88653
// k := tmp ;
88643: LD_ADDR_VAR 0 9
88647: PUSH
88648: LD_VAR 0 14
88652: ST_TO_ADDR
// for j = 1 to k do
88653: LD_ADDR_VAR 0 8
88657: PUSH
88658: DOUBLE
88659: LD_INT 1
88661: DEC
88662: ST_TO_ADDR
88663: LD_VAR 0 9
88667: PUSH
88668: FOR_TO
88669: IFFALSE 88757
// begin if not tmp [ j ] in UnitFilter ( tmp , [ f_empty ] ) then
88671: LD_VAR 0 14
88675: PUSH
88676: LD_VAR 0 8
88680: ARRAY
88681: PUSH
88682: LD_VAR 0 14
88686: PPUSH
88687: LD_INT 58
88689: PUSH
88690: EMPTY
88691: LIST
88692: PPUSH
88693: CALL_OW 72
88697: IN
88698: NOT
88699: IFFALSE 88755
// begin ComAttackUnit ( group [ i ] , tmp [ j ] ) ;
88701: LD_VAR 0 4
88705: PUSH
88706: LD_VAR 0 7
88710: ARRAY
88711: PPUSH
88712: LD_VAR 0 14
88716: PUSH
88717: LD_VAR 0 8
88721: ARRAY
88722: PPUSH
88723: CALL_OW 115
// attacking := true ;
88727: LD_ADDR_VAR 0 29
88731: PUSH
88732: LD_INT 1
88734: ST_TO_ADDR
// SetTag ( group [ i ] , 71 ) ;
88735: LD_VAR 0 4
88739: PUSH
88740: LD_VAR 0 7
88744: ARRAY
88745: PPUSH
88746: LD_INT 71
88748: PPUSH
88749: CALL_OW 109
// continue ;
88753: GO 88668
// end ; end ;
88755: GO 88668
88757: POP
88758: POP
// end ; if GetClass ( group [ i ] ) = 8 or GetWeapon ( group [ i ] ) in [ ar_rocket_launcher , ru_rocket_launcher , us_rocket_launcher , ru_rocket ] then
88759: LD_VAR 0 4
88763: PUSH
88764: LD_VAR 0 7
88768: ARRAY
88769: PPUSH
88770: CALL_OW 257
88774: PUSH
88775: LD_INT 8
88777: EQUAL
88778: PUSH
88779: LD_VAR 0 4
88783: PUSH
88784: LD_VAR 0 7
88788: ARRAY
88789: PPUSH
88790: CALL_OW 264
88794: PUSH
88795: LD_INT 28
88797: PUSH
88798: LD_INT 45
88800: PUSH
88801: LD_INT 7
88803: PUSH
88804: LD_INT 47
88806: PUSH
88807: EMPTY
88808: LIST
88809: LIST
88810: LIST
88811: LIST
88812: IN
88813: OR
88814: IFFALSE 89044
// begin attacking := false ;
88816: LD_ADDR_VAR 0 29
88820: PUSH
88821: LD_INT 0
88823: ST_TO_ADDR
// if GetBType ( tmp [ 1 ] ) in [ b_bunker , b_breastwork , b_turret , b_armoury , b_barracks ] then
88824: LD_VAR 0 14
88828: PUSH
88829: LD_INT 1
88831: ARRAY
88832: PPUSH
88833: CALL_OW 266
88837: PUSH
88838: LD_INT 32
88840: PUSH
88841: LD_INT 31
88843: PUSH
88844: LD_INT 33
88846: PUSH
88847: LD_INT 4
88849: PUSH
88850: LD_INT 5
88852: PUSH
88853: EMPTY
88854: LIST
88855: LIST
88856: LIST
88857: LIST
88858: LIST
88859: IN
88860: IFFALSE 89044
// begin k := GetBuildingHexes ( GetBType ( tmp [ 1 ] ) , GetX ( tmp [ 1 ] ) , GetY ( tmp [ 1 ] ) , GetDir ( tmp [ 1 ] ) , GetNation ( tmp [ 1 ] ) , 0 ) ;
88862: LD_ADDR_VAR 0 9
88866: PUSH
88867: LD_VAR 0 14
88871: PUSH
88872: LD_INT 1
88874: ARRAY
88875: PPUSH
88876: CALL_OW 266
88880: PPUSH
88881: LD_VAR 0 14
88885: PUSH
88886: LD_INT 1
88888: ARRAY
88889: PPUSH
88890: CALL_OW 250
88894: PPUSH
88895: LD_VAR 0 14
88899: PUSH
88900: LD_INT 1
88902: ARRAY
88903: PPUSH
88904: CALL_OW 251
88908: PPUSH
88909: LD_VAR 0 14
88913: PUSH
88914: LD_INT 1
88916: ARRAY
88917: PPUSH
88918: CALL_OW 254
88922: PPUSH
88923: LD_VAR 0 14
88927: PUSH
88928: LD_INT 1
88930: ARRAY
88931: PPUSH
88932: CALL_OW 248
88936: PPUSH
88937: LD_INT 0
88939: PPUSH
88940: CALL 65650 0 6
88944: ST_TO_ADDR
// j := GetClosestHex ( group [ i ] , k ) ;
88945: LD_ADDR_VAR 0 8
88949: PUSH
88950: LD_VAR 0 4
88954: PUSH
88955: LD_VAR 0 7
88959: ARRAY
88960: PPUSH
88961: LD_VAR 0 9
88965: PPUSH
88966: CALL 84343 0 2
88970: ST_TO_ADDR
// if j then
88971: LD_VAR 0 8
88975: IFFALSE 89044
// if ValidHex ( j [ 1 ] , j [ 2 ] ) then
88977: LD_VAR 0 8
88981: PUSH
88982: LD_INT 1
88984: ARRAY
88985: PPUSH
88986: LD_VAR 0 8
88990: PUSH
88991: LD_INT 2
88993: ARRAY
88994: PPUSH
88995: CALL_OW 488
88999: IFFALSE 89044
// begin ComAttackPlace ( group [ i ] , j [ 1 ] , j [ 2 ] ) ;
89001: LD_VAR 0 4
89005: PUSH
89006: LD_VAR 0 7
89010: ARRAY
89011: PPUSH
89012: LD_VAR 0 8
89016: PUSH
89017: LD_INT 1
89019: ARRAY
89020: PPUSH
89021: LD_VAR 0 8
89025: PUSH
89026: LD_INT 2
89028: ARRAY
89029: PPUSH
89030: CALL_OW 116
// attacking := true ;
89034: LD_ADDR_VAR 0 29
89038: PUSH
89039: LD_INT 1
89041: ST_TO_ADDR
// continue ;
89042: GO 86417
// end ; end ; end ; if GetChassis ( group [ i ] ) = ar_hovercraft then
89044: LD_VAR 0 4
89048: PUSH
89049: LD_VAR 0 7
89053: ARRAY
89054: PPUSH
89055: CALL_OW 265
89059: PUSH
89060: LD_INT 11
89062: EQUAL
89063: IFFALSE 89341
// begin k := 10 ;
89065: LD_ADDR_VAR 0 9
89069: PUSH
89070: LD_INT 10
89072: ST_TO_ADDR
// x := 0 ;
89073: LD_ADDR_VAR 0 10
89077: PUSH
89078: LD_INT 0
89080: ST_TO_ADDR
// if tmp < k then
89081: LD_VAR 0 14
89085: PUSH
89086: LD_VAR 0 9
89090: LESS
89091: IFFALSE 89103
// k := tmp ;
89093: LD_ADDR_VAR 0 9
89097: PUSH
89098: LD_VAR 0 14
89102: ST_TO_ADDR
// for j = k downto 1 do
89103: LD_ADDR_VAR 0 8
89107: PUSH
89108: DOUBLE
89109: LD_VAR 0 9
89113: INC
89114: ST_TO_ADDR
89115: LD_INT 1
89117: PUSH
89118: FOR_DOWNTO
89119: IFFALSE 89194
// begin if GetType ( tmp [ j ] ) = unit_human then
89121: LD_VAR 0 14
89125: PUSH
89126: LD_VAR 0 8
89130: ARRAY
89131: PPUSH
89132: CALL_OW 247
89136: PUSH
89137: LD_INT 1
89139: EQUAL
89140: IFFALSE 89192
// begin AttackHovercraft ( group [ i ] , tmp [ j ] ) ;
89142: LD_VAR 0 4
89146: PUSH
89147: LD_VAR 0 7
89151: ARRAY
89152: PPUSH
89153: LD_VAR 0 14
89157: PUSH
89158: LD_VAR 0 8
89162: ARRAY
89163: PPUSH
89164: CALL 84614 0 2
// x := tmp [ j ] ;
89168: LD_ADDR_VAR 0 10
89172: PUSH
89173: LD_VAR 0 14
89177: PUSH
89178: LD_VAR 0 8
89182: ARRAY
89183: ST_TO_ADDR
// attacking := true ;
89184: LD_ADDR_VAR 0 29
89188: PUSH
89189: LD_INT 1
89191: ST_TO_ADDR
// end ; end ;
89192: GO 89118
89194: POP
89195: POP
// if not x then
89196: LD_VAR 0 10
89200: NOT
89201: IFFALSE 89341
// begin attacking := true ;
89203: LD_ADDR_VAR 0 29
89207: PUSH
89208: LD_INT 1
89210: ST_TO_ADDR
// if GetHexInfo ( GetX ( group [ i ] ) , GetY ( group [ i ] ) ) [ 2 ] = GetHexInfo ( GetX ( tmp [ 1 ] ) , GetY ( tmp [ 1 ] ) ) [ 2 ] then
89211: LD_VAR 0 4
89215: PUSH
89216: LD_VAR 0 7
89220: ARRAY
89221: PPUSH
89222: CALL_OW 250
89226: PPUSH
89227: LD_VAR 0 4
89231: PUSH
89232: LD_VAR 0 7
89236: ARRAY
89237: PPUSH
89238: CALL_OW 251
89242: PPUSH
89243: CALL_OW 546
89247: PUSH
89248: LD_INT 2
89250: ARRAY
89251: PUSH
89252: LD_VAR 0 14
89256: PUSH
89257: LD_INT 1
89259: ARRAY
89260: PPUSH
89261: CALL_OW 250
89265: PPUSH
89266: LD_VAR 0 14
89270: PUSH
89271: LD_INT 1
89273: ARRAY
89274: PPUSH
89275: CALL_OW 251
89279: PPUSH
89280: CALL_OW 546
89284: PUSH
89285: LD_INT 2
89287: ARRAY
89288: EQUAL
89289: IFFALSE 89317
// AttackHovercraft ( group [ i ] , tmp [ 1 ] ) else
89291: LD_VAR 0 4
89295: PUSH
89296: LD_VAR 0 7
89300: ARRAY
89301: PPUSH
89302: LD_VAR 0 14
89306: PUSH
89307: LD_INT 1
89309: ARRAY
89310: PPUSH
89311: CALL 84614 0 2
89315: GO 89341
// ComAttackUnit ( group [ i ] , tmp [ 1 ] ) ;
89317: LD_VAR 0 4
89321: PUSH
89322: LD_VAR 0 7
89326: ARRAY
89327: PPUSH
89328: LD_VAR 0 14
89332: PUSH
89333: LD_INT 1
89335: ARRAY
89336: PPUSH
89337: CALL_OW 115
// end ; end ; if GetWeapon ( group [ i ] ) = ar_selfpropelled_bomb then
89341: LD_VAR 0 4
89345: PUSH
89346: LD_VAR 0 7
89350: ARRAY
89351: PPUSH
89352: CALL_OW 264
89356: PUSH
89357: LD_INT 29
89359: EQUAL
89360: IFFALSE 89726
// begin if WantsToAttack ( group [ i ] ) in bombed then
89362: LD_VAR 0 4
89366: PUSH
89367: LD_VAR 0 7
89371: ARRAY
89372: PPUSH
89373: CALL_OW 319
89377: PUSH
89378: LD_VAR 0 28
89382: IN
89383: IFFALSE 89387
// continue ;
89385: GO 86417
// k := 8 ;
89387: LD_ADDR_VAR 0 9
89391: PUSH
89392: LD_INT 8
89394: ST_TO_ADDR
// x := 0 ;
89395: LD_ADDR_VAR 0 10
89399: PUSH
89400: LD_INT 0
89402: ST_TO_ADDR
// if tmp < k then
89403: LD_VAR 0 14
89407: PUSH
89408: LD_VAR 0 9
89412: LESS
89413: IFFALSE 89425
// k := tmp ;
89415: LD_ADDR_VAR 0 9
89419: PUSH
89420: LD_VAR 0 14
89424: ST_TO_ADDR
// for j = 1 to k do
89425: LD_ADDR_VAR 0 8
89429: PUSH
89430: DOUBLE
89431: LD_INT 1
89433: DEC
89434: ST_TO_ADDR
89435: LD_VAR 0 9
89439: PUSH
89440: FOR_TO
89441: IFFALSE 89573
// begin if GetType ( tmp [ j ] ) = unit_building then
89443: LD_VAR 0 14
89447: PUSH
89448: LD_VAR 0 8
89452: ARRAY
89453: PPUSH
89454: CALL_OW 247
89458: PUSH
89459: LD_INT 3
89461: EQUAL
89462: IFFALSE 89571
// if not tmp [ j ] in bombed and UnitsInside ( tmp [ j ] ) then
89464: LD_VAR 0 14
89468: PUSH
89469: LD_VAR 0 8
89473: ARRAY
89474: PUSH
89475: LD_VAR 0 28
89479: IN
89480: NOT
89481: PUSH
89482: LD_VAR 0 14
89486: PUSH
89487: LD_VAR 0 8
89491: ARRAY
89492: PPUSH
89493: CALL_OW 313
89497: AND
89498: IFFALSE 89571
// begin ComAttackUnit ( group [ i ] , tmp [ j ] ) ;
89500: LD_VAR 0 4
89504: PUSH
89505: LD_VAR 0 7
89509: ARRAY
89510: PPUSH
89511: LD_VAR 0 14
89515: PUSH
89516: LD_VAR 0 8
89520: ARRAY
89521: PPUSH
89522: CALL_OW 115
// bombed := Replace ( bombed , bombed + 1 , tmp [ j ] ) ;
89526: LD_ADDR_VAR 0 28
89530: PUSH
89531: LD_VAR 0 28
89535: PPUSH
89536: LD_VAR 0 28
89540: PUSH
89541: LD_INT 1
89543: PLUS
89544: PPUSH
89545: LD_VAR 0 14
89549: PUSH
89550: LD_VAR 0 8
89554: ARRAY
89555: PPUSH
89556: CALL_OW 1
89560: ST_TO_ADDR
// attacking := true ;
89561: LD_ADDR_VAR 0 29
89565: PUSH
89566: LD_INT 1
89568: ST_TO_ADDR
// break ;
89569: GO 89573
// end ; end ;
89571: GO 89440
89573: POP
89574: POP
// if not attacking and f_attack_depot then
89575: LD_VAR 0 29
89579: NOT
89580: PUSH
89581: LD_VAR 0 25
89585: AND
89586: IFFALSE 89681
// begin z := UnitFilter ( tmp , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) ;
89588: LD_ADDR_VAR 0 13
89592: PUSH
89593: LD_VAR 0 14
89597: PPUSH
89598: LD_INT 2
89600: PUSH
89601: LD_INT 30
89603: PUSH
89604: LD_INT 0
89606: PUSH
89607: EMPTY
89608: LIST
89609: LIST
89610: PUSH
89611: LD_INT 30
89613: PUSH
89614: LD_INT 1
89616: PUSH
89617: EMPTY
89618: LIST
89619: LIST
89620: PUSH
89621: EMPTY
89622: LIST
89623: LIST
89624: LIST
89625: PPUSH
89626: CALL_OW 72
89630: ST_TO_ADDR
// if z then
89631: LD_VAR 0 13
89635: IFFALSE 89681
// begin ComAttackUnit ( group [ i ] , NearestUnitToUnit ( z , group [ i ] ) ) ;
89637: LD_VAR 0 4
89641: PUSH
89642: LD_VAR 0 7
89646: ARRAY
89647: PPUSH
89648: LD_VAR 0 13
89652: PPUSH
89653: LD_VAR 0 4
89657: PUSH
89658: LD_VAR 0 7
89662: ARRAY
89663: PPUSH
89664: CALL_OW 74
89668: PPUSH
89669: CALL_OW 115
// attacking := true ;
89673: LD_ADDR_VAR 0 29
89677: PUSH
89678: LD_INT 1
89680: ST_TO_ADDR
// end ; end ; if GetLives ( group [ i ] ) < 500 then
89681: LD_VAR 0 4
89685: PUSH
89686: LD_VAR 0 7
89690: ARRAY
89691: PPUSH
89692: CALL_OW 256
89696: PUSH
89697: LD_INT 500
89699: LESS
89700: IFFALSE 89726
// ComAttackUnit ( group [ i ] , tmp [ 1 ] ) ;
89702: LD_VAR 0 4
89706: PUSH
89707: LD_VAR 0 7
89711: ARRAY
89712: PPUSH
89713: LD_VAR 0 14
89717: PUSH
89718: LD_INT 1
89720: ARRAY
89721: PPUSH
89722: CALL_OW 115
// end ; if GetWeapon ( group [ i ] ) = ru_time_lapser then
89726: LD_VAR 0 4
89730: PUSH
89731: LD_VAR 0 7
89735: ARRAY
89736: PPUSH
89737: CALL_OW 264
89741: PUSH
89742: LD_INT 49
89744: EQUAL
89745: IFFALSE 89866
// begin if not HasTask ( group [ i ] ) then
89747: LD_VAR 0 4
89751: PUSH
89752: LD_VAR 0 7
89756: ARRAY
89757: PPUSH
89758: CALL_OW 314
89762: NOT
89763: IFFALSE 89866
// begin k := NearestUnitToUnit ( FilterAllUnits ( [ f_enemy , GetSide ( group [ i ] ) ] ) , group [ i ] ) ;
89765: LD_ADDR_VAR 0 9
89769: PUSH
89770: LD_INT 81
89772: PUSH
89773: LD_VAR 0 4
89777: PUSH
89778: LD_VAR 0 7
89782: ARRAY
89783: PPUSH
89784: CALL_OW 255
89788: PUSH
89789: EMPTY
89790: LIST
89791: LIST
89792: PPUSH
89793: CALL_OW 69
89797: PPUSH
89798: LD_VAR 0 4
89802: PUSH
89803: LD_VAR 0 7
89807: ARRAY
89808: PPUSH
89809: CALL_OW 74
89813: ST_TO_ADDR
// if k then
89814: LD_VAR 0 9
89818: IFFALSE 89866
// if GetDistUnits ( group [ i ] , k ) > 10 then
89820: LD_VAR 0 4
89824: PUSH
89825: LD_VAR 0 7
89829: ARRAY
89830: PPUSH
89831: LD_VAR 0 9
89835: PPUSH
89836: CALL_OW 296
89840: PUSH
89841: LD_INT 10
89843: GREATER
89844: IFFALSE 89866
// ComMoveUnit ( group [ i ] , k ) ;
89846: LD_VAR 0 4
89850: PUSH
89851: LD_VAR 0 7
89855: ARRAY
89856: PPUSH
89857: LD_VAR 0 9
89861: PPUSH
89862: CALL_OW 112
// end ; end ; if GetLives ( group [ i ] ) < 250 and group [ i ] in FilterAllUnits ( [ [ f_type , unit_vehicle ] , [ f_nation , 2 ] ] ) then
89866: LD_VAR 0 4
89870: PUSH
89871: LD_VAR 0 7
89875: ARRAY
89876: PPUSH
89877: CALL_OW 256
89881: PUSH
89882: LD_INT 250
89884: LESS
89885: PUSH
89886: LD_VAR 0 4
89890: PUSH
89891: LD_VAR 0 7
89895: ARRAY
89896: PUSH
89897: LD_INT 21
89899: PUSH
89900: LD_INT 2
89902: PUSH
89903: EMPTY
89904: LIST
89905: LIST
89906: PUSH
89907: LD_INT 23
89909: PUSH
89910: LD_INT 2
89912: PUSH
89913: EMPTY
89914: LIST
89915: LIST
89916: PUSH
89917: EMPTY
89918: LIST
89919: LIST
89920: PPUSH
89921: CALL_OW 69
89925: IN
89926: AND
89927: IFFALSE 90052
// begin k := NearestUnitToUnit ( all_units diff group [ i ] , group [ i ] ) ;
89929: LD_ADDR_VAR 0 9
89933: PUSH
89934: LD_OWVAR 3
89938: PUSH
89939: LD_VAR 0 4
89943: PUSH
89944: LD_VAR 0 7
89948: ARRAY
89949: DIFF
89950: PPUSH
89951: LD_VAR 0 4
89955: PUSH
89956: LD_VAR 0 7
89960: ARRAY
89961: PPUSH
89962: CALL_OW 74
89966: ST_TO_ADDR
// if not k then
89967: LD_VAR 0 9
89971: NOT
89972: IFFALSE 89976
// continue ;
89974: GO 86417
// if k in FilterAllUnits ( [ f_enemy , GetSide ( group [ i ] ) ] ) and GetDistUnits ( k , group [ i ] ) < 5 then
89976: LD_VAR 0 9
89980: PUSH
89981: LD_INT 81
89983: PUSH
89984: LD_VAR 0 4
89988: PUSH
89989: LD_VAR 0 7
89993: ARRAY
89994: PPUSH
89995: CALL_OW 255
89999: PUSH
90000: EMPTY
90001: LIST
90002: LIST
90003: PPUSH
90004: CALL_OW 69
90008: IN
90009: PUSH
90010: LD_VAR 0 9
90014: PPUSH
90015: LD_VAR 0 4
90019: PUSH
90020: LD_VAR 0 7
90024: ARRAY
90025: PPUSH
90026: CALL_OW 296
90030: PUSH
90031: LD_INT 5
90033: LESS
90034: AND
90035: IFFALSE 90052
// ComAutodestruct ( group [ i ] ) ;
90037: LD_VAR 0 4
90041: PUSH
90042: LD_VAR 0 7
90046: ARRAY
90047: PPUSH
90048: CALL 84512 0 1
// end ; if f_attack_depot then
90052: LD_VAR 0 25
90056: IFFALSE 90168
// begin k := 6 ;
90058: LD_ADDR_VAR 0 9
90062: PUSH
90063: LD_INT 6
90065: ST_TO_ADDR
// if tmp < k then
90066: LD_VAR 0 14
90070: PUSH
90071: LD_VAR 0 9
90075: LESS
90076: IFFALSE 90088
// k := tmp ;
90078: LD_ADDR_VAR 0 9
90082: PUSH
90083: LD_VAR 0 14
90087: ST_TO_ADDR
// for j = 1 to k do
90088: LD_ADDR_VAR 0 8
90092: PUSH
90093: DOUBLE
90094: LD_INT 1
90096: DEC
90097: ST_TO_ADDR
90098: LD_VAR 0 9
90102: PUSH
90103: FOR_TO
90104: IFFALSE 90166
// if GetBType ( j ) in [ b_depot , b_warehouse ] then
90106: LD_VAR 0 8
90110: PPUSH
90111: CALL_OW 266
90115: PUSH
90116: LD_INT 0
90118: PUSH
90119: LD_INT 1
90121: PUSH
90122: EMPTY
90123: LIST
90124: LIST
90125: IN
90126: IFFALSE 90164
// begin ComAttackUnit ( group [ i ] , tmp [ j ] ) ;
90128: LD_VAR 0 4
90132: PUSH
90133: LD_VAR 0 7
90137: ARRAY
90138: PPUSH
90139: LD_VAR 0 14
90143: PUSH
90144: LD_VAR 0 8
90148: ARRAY
90149: PPUSH
90150: CALL_OW 115
// attacking := true ;
90154: LD_ADDR_VAR 0 29
90158: PUSH
90159: LD_INT 1
90161: ST_TO_ADDR
// break ;
90162: GO 90166
// end ;
90164: GO 90103
90166: POP
90167: POP
// end ; if IsOk ( group [ i ] ) and not attacking then
90168: LD_VAR 0 4
90172: PUSH
90173: LD_VAR 0 7
90177: ARRAY
90178: PPUSH
90179: CALL_OW 302
90183: PUSH
90184: LD_VAR 0 29
90188: NOT
90189: AND
90190: IFFALSE 90512
// begin if GetTag ( group [ i ] ) = 71 then
90192: LD_VAR 0 4
90196: PUSH
90197: LD_VAR 0 7
90201: ARRAY
90202: PPUSH
90203: CALL_OW 110
90207: PUSH
90208: LD_INT 71
90210: EQUAL
90211: IFFALSE 90252
// begin if HasTask ( group [ i ] ) then
90213: LD_VAR 0 4
90217: PUSH
90218: LD_VAR 0 7
90222: ARRAY
90223: PPUSH
90224: CALL_OW 314
90228: IFFALSE 90234
// continue else
90230: GO 86417
90232: GO 90252
// SetTag ( group [ i ] , 0 ) ;
90234: LD_VAR 0 4
90238: PUSH
90239: LD_VAR 0 7
90243: ARRAY
90244: PPUSH
90245: LD_INT 0
90247: PPUSH
90248: CALL_OW 109
// end ; k := 8 ;
90252: LD_ADDR_VAR 0 9
90256: PUSH
90257: LD_INT 8
90259: ST_TO_ADDR
// x := 0 ;
90260: LD_ADDR_VAR 0 10
90264: PUSH
90265: LD_INT 0
90267: ST_TO_ADDR
// if tmp < k then
90268: LD_VAR 0 14
90272: PUSH
90273: LD_VAR 0 9
90277: LESS
90278: IFFALSE 90290
// k := tmp ;
90280: LD_ADDR_VAR 0 9
90284: PUSH
90285: LD_VAR 0 14
90289: ST_TO_ADDR
// for j = 1 to k do
90290: LD_ADDR_VAR 0 8
90294: PUSH
90295: DOUBLE
90296: LD_INT 1
90298: DEC
90299: ST_TO_ADDR
90300: LD_VAR 0 9
90304: PUSH
90305: FOR_TO
90306: IFFALSE 90404
// if GetType ( tmp [ j ] ) = unit_human and ( ( GetLives ( tmp [ j ] ) < 250 and f_murder ) or ( not f_murder and GetLives ( tmp [ j ] ) >= 250 ) ) then
90308: LD_VAR 0 14
90312: PUSH
90313: LD_VAR 0 8
90317: ARRAY
90318: PPUSH
90319: CALL_OW 247
90323: PUSH
90324: LD_INT 1
90326: EQUAL
90327: PUSH
90328: LD_VAR 0 14
90332: PUSH
90333: LD_VAR 0 8
90337: ARRAY
90338: PPUSH
90339: CALL_OW 256
90343: PUSH
90344: LD_INT 250
90346: LESS
90347: PUSH
90348: LD_VAR 0 20
90352: AND
90353: PUSH
90354: LD_VAR 0 20
90358: NOT
90359: PUSH
90360: LD_VAR 0 14
90364: PUSH
90365: LD_VAR 0 8
90369: ARRAY
90370: PPUSH
90371: CALL_OW 256
90375: PUSH
90376: LD_INT 250
90378: GREATEREQUAL
90379: AND
90380: OR
90381: AND
90382: IFFALSE 90402
// begin x := tmp [ j ] ;
90384: LD_ADDR_VAR 0 10
90388: PUSH
90389: LD_VAR 0 14
90393: PUSH
90394: LD_VAR 0 8
90398: ARRAY
90399: ST_TO_ADDR
// break ;
90400: GO 90404
// end ;
90402: GO 90305
90404: POP
90405: POP
// if x then
90406: LD_VAR 0 10
90410: IFFALSE 90434
// ComAttackUnit ( group [ i ] , x ) else
90412: LD_VAR 0 4
90416: PUSH
90417: LD_VAR 0 7
90421: ARRAY
90422: PPUSH
90423: LD_VAR 0 10
90427: PPUSH
90428: CALL_OW 115
90432: GO 90458
// ComAttackUnit ( group [ i ] , tmp [ 1 ] ) ;
90434: LD_VAR 0 4
90438: PUSH
90439: LD_VAR 0 7
90443: ARRAY
90444: PPUSH
90445: LD_VAR 0 14
90449: PUSH
90450: LD_INT 1
90452: ARRAY
90453: PPUSH
90454: CALL_OW 115
// if not HasTask ( group [ i ] ) then
90458: LD_VAR 0 4
90462: PUSH
90463: LD_VAR 0 7
90467: ARRAY
90468: PPUSH
90469: CALL_OW 314
90473: NOT
90474: IFFALSE 90512
// ComAttackUnit ( group [ i ] , NearestUnitToUnit ( tmp , group [ i ] ) ) ;
90476: LD_VAR 0 4
90480: PUSH
90481: LD_VAR 0 7
90485: ARRAY
90486: PPUSH
90487: LD_VAR 0 14
90491: PPUSH
90492: LD_VAR 0 4
90496: PUSH
90497: LD_VAR 0 7
90501: ARRAY
90502: PPUSH
90503: CALL_OW 74
90507: PPUSH
90508: CALL_OW 115
// end ; end ; end ;
90512: GO 86417
90514: POP
90515: POP
// wait ( 0 0$1 ) ;
90516: LD_INT 35
90518: PPUSH
90519: CALL_OW 67
// until group = [ ] or not FilterAllUnits ( [ f_enemy , side ] ) ;
90523: LD_VAR 0 4
90527: PUSH
90528: EMPTY
90529: EQUAL
90530: PUSH
90531: LD_INT 81
90533: PUSH
90534: LD_VAR 0 35
90538: PUSH
90539: EMPTY
90540: LIST
90541: LIST
90542: PPUSH
90543: CALL_OW 69
90547: NOT
90548: OR
90549: IFFALSE 86402
// end ;
90551: LD_VAR 0 2
90555: RET
// export function _ScanBase ( base_units ) ; var i , t , tmp ; begin
90556: LD_INT 0
90558: PPUSH
90559: PPUSH
90560: PPUSH
90561: PPUSH
// if not base_units then
90562: LD_VAR 0 1
90566: NOT
90567: IFFALSE 90571
// exit ;
90569: GO 90658
// result := false ;
90571: LD_ADDR_VAR 0 2
90575: PUSH
90576: LD_INT 0
90578: ST_TO_ADDR
// tmp := UnitFilter ( base_units , [ f_type , unit_building ] ) ;
90579: LD_ADDR_VAR 0 5
90583: PUSH
90584: LD_VAR 0 1
90588: PPUSH
90589: LD_INT 21
90591: PUSH
90592: LD_INT 3
90594: PUSH
90595: EMPTY
90596: LIST
90597: LIST
90598: PPUSH
90599: CALL_OW 72
90603: ST_TO_ADDR
// if not tmp then
90604: LD_VAR 0 5
90608: NOT
90609: IFFALSE 90613
// exit ;
90611: GO 90658
// for i in tmp do
90613: LD_ADDR_VAR 0 3
90617: PUSH
90618: LD_VAR 0 5
90622: PUSH
90623: FOR_IN
90624: IFFALSE 90656
// begin result := EnemyInRange ( i , 22 ) ;
90626: LD_ADDR_VAR 0 2
90630: PUSH
90631: LD_VAR 0 3
90635: PPUSH
90636: LD_INT 22
90638: PPUSH
90639: CALL 84195 0 2
90643: ST_TO_ADDR
// if result then
90644: LD_VAR 0 2
90648: IFFALSE 90654
// exit ;
90650: POP
90651: POP
90652: GO 90658
// end ;
90654: GO 90623
90656: POP
90657: POP
// end ;
90658: LD_VAR 0 2
90662: RET
// export function FilterByTag ( units , tag ) ; var i ; begin
90663: LD_INT 0
90665: PPUSH
90666: PPUSH
// if not units then
90667: LD_VAR 0 1
90671: NOT
90672: IFFALSE 90676
// exit ;
90674: GO 90746
// result := [ ] ;
90676: LD_ADDR_VAR 0 3
90680: PUSH
90681: EMPTY
90682: ST_TO_ADDR
// for i in units do
90683: LD_ADDR_VAR 0 4
90687: PUSH
90688: LD_VAR 0 1
90692: PUSH
90693: FOR_IN
90694: IFFALSE 90744
// if GetTag ( i ) = tag then
90696: LD_VAR 0 4
90700: PPUSH
90701: CALL_OW 110
90705: PUSH
90706: LD_VAR 0 2
90710: EQUAL
90711: IFFALSE 90742
// result := Insert ( result , result + 1 , i ) ;
90713: LD_ADDR_VAR 0 3
90717: PUSH
90718: LD_VAR 0 3
90722: PPUSH
90723: LD_VAR 0 3
90727: PUSH
90728: LD_INT 1
90730: PLUS
90731: PPUSH
90732: LD_VAR 0 4
90736: PPUSH
90737: CALL_OW 2
90741: ST_TO_ADDR
90742: GO 90693
90744: POP
90745: POP
// end ;
90746: LD_VAR 0 3
90750: RET
// export function IsDriver ( un ) ; begin
90751: LD_INT 0
90753: PPUSH
// result := un in FilterAllUnits ( [ f_driving ] ) ;
90754: LD_ADDR_VAR 0 2
90758: PUSH
90759: LD_VAR 0 1
90763: PUSH
90764: LD_INT 55
90766: PUSH
90767: EMPTY
90768: LIST
90769: PPUSH
90770: CALL_OW 69
90774: IN
90775: ST_TO_ADDR
// end ;
90776: LD_VAR 0 2
90780: RET
// export function GetFacExtXYD ( x , y , d ) ; var list ; begin
90781: LD_INT 0
90783: PPUSH
90784: PPUSH
// list := [ ] ;
90785: LD_ADDR_VAR 0 5
90789: PUSH
90790: EMPTY
90791: ST_TO_ADDR
// case d of 0 :
90792: LD_VAR 0 3
90796: PUSH
90797: LD_INT 0
90799: DOUBLE
90800: EQUAL
90801: IFTRUE 90805
90803: GO 90938
90805: POP
// begin list := [ [ x - 4 , y - 4 , 2 ] , [ x - 3 , y , 1 ] , [ x + 4 , y , 4 ] , [ x + 3 , y + 3 , 5 ] , [ x , y + 4 , 0 ] ] ;
90806: LD_ADDR_VAR 0 5
90810: PUSH
90811: LD_VAR 0 1
90815: PUSH
90816: LD_INT 4
90818: MINUS
90819: PUSH
90820: LD_VAR 0 2
90824: PUSH
90825: LD_INT 4
90827: MINUS
90828: PUSH
90829: LD_INT 2
90831: PUSH
90832: EMPTY
90833: LIST
90834: LIST
90835: LIST
90836: PUSH
90837: LD_VAR 0 1
90841: PUSH
90842: LD_INT 3
90844: MINUS
90845: PUSH
90846: LD_VAR 0 2
90850: PUSH
90851: LD_INT 1
90853: PUSH
90854: EMPTY
90855: LIST
90856: LIST
90857: LIST
90858: PUSH
90859: LD_VAR 0 1
90863: PUSH
90864: LD_INT 4
90866: PLUS
90867: PUSH
90868: LD_VAR 0 2
90872: PUSH
90873: LD_INT 4
90875: PUSH
90876: EMPTY
90877: LIST
90878: LIST
90879: LIST
90880: PUSH
90881: LD_VAR 0 1
90885: PUSH
90886: LD_INT 3
90888: PLUS
90889: PUSH
90890: LD_VAR 0 2
90894: PUSH
90895: LD_INT 3
90897: PLUS
90898: PUSH
90899: LD_INT 5
90901: PUSH
90902: EMPTY
90903: LIST
90904: LIST
90905: LIST
90906: PUSH
90907: LD_VAR 0 1
90911: PUSH
90912: LD_VAR 0 2
90916: PUSH
90917: LD_INT 4
90919: PLUS
90920: PUSH
90921: LD_INT 0
90923: PUSH
90924: EMPTY
90925: LIST
90926: LIST
90927: LIST
90928: PUSH
90929: EMPTY
90930: LIST
90931: LIST
90932: LIST
90933: LIST
90934: LIST
90935: ST_TO_ADDR
// end ; 1 :
90936: GO 91636
90938: LD_INT 1
90940: DOUBLE
90941: EQUAL
90942: IFTRUE 90946
90944: GO 91079
90946: POP
// begin list := [ [ x , y - 4 , 3 ] , [ x - 3 , y - 3 , 2 ] , [ x - 4 , y , 1 ] , [ x , y + 3 , 0 ] , [ x + 4 , y + 4 , 5 ] ] ;
90947: LD_ADDR_VAR 0 5
90951: PUSH
90952: LD_VAR 0 1
90956: PUSH
90957: LD_VAR 0 2
90961: PUSH
90962: LD_INT 4
90964: MINUS
90965: PUSH
90966: LD_INT 3
90968: PUSH
90969: EMPTY
90970: LIST
90971: LIST
90972: LIST
90973: PUSH
90974: LD_VAR 0 1
90978: PUSH
90979: LD_INT 3
90981: MINUS
90982: PUSH
90983: LD_VAR 0 2
90987: PUSH
90988: LD_INT 3
90990: MINUS
90991: PUSH
90992: LD_INT 2
90994: PUSH
90995: EMPTY
90996: LIST
90997: LIST
90998: LIST
90999: PUSH
91000: LD_VAR 0 1
91004: PUSH
91005: LD_INT 4
91007: MINUS
91008: PUSH
91009: LD_VAR 0 2
91013: PUSH
91014: LD_INT 1
91016: PUSH
91017: EMPTY
91018: LIST
91019: LIST
91020: LIST
91021: PUSH
91022: LD_VAR 0 1
91026: PUSH
91027: LD_VAR 0 2
91031: PUSH
91032: LD_INT 3
91034: PLUS
91035: PUSH
91036: LD_INT 0
91038: PUSH
91039: EMPTY
91040: LIST
91041: LIST
91042: LIST
91043: PUSH
91044: LD_VAR 0 1
91048: PUSH
91049: LD_INT 4
91051: PLUS
91052: PUSH
91053: LD_VAR 0 2
91057: PUSH
91058: LD_INT 4
91060: PLUS
91061: PUSH
91062: LD_INT 5
91064: PUSH
91065: EMPTY
91066: LIST
91067: LIST
91068: LIST
91069: PUSH
91070: EMPTY
91071: LIST
91072: LIST
91073: LIST
91074: LIST
91075: LIST
91076: ST_TO_ADDR
// end ; 2 :
91077: GO 91636
91079: LD_INT 2
91081: DOUBLE
91082: EQUAL
91083: IFTRUE 91087
91085: GO 91216
91087: POP
// begin list := [ [ x , y - 3 , 3 ] , [ x + 4 , y , 4 ] , [ x , y + 4 , 0 ] , [ x - 3 , y , 1 ] , [ x - 4 , y - 4 , 2 ] ] ;
91088: LD_ADDR_VAR 0 5
91092: PUSH
91093: LD_VAR 0 1
91097: PUSH
91098: LD_VAR 0 2
91102: PUSH
91103: LD_INT 3
91105: MINUS
91106: PUSH
91107: LD_INT 3
91109: PUSH
91110: EMPTY
91111: LIST
91112: LIST
91113: LIST
91114: PUSH
91115: LD_VAR 0 1
91119: PUSH
91120: LD_INT 4
91122: PLUS
91123: PUSH
91124: LD_VAR 0 2
91128: PUSH
91129: LD_INT 4
91131: PUSH
91132: EMPTY
91133: LIST
91134: LIST
91135: LIST
91136: PUSH
91137: LD_VAR 0 1
91141: PUSH
91142: LD_VAR 0 2
91146: PUSH
91147: LD_INT 4
91149: PLUS
91150: PUSH
91151: LD_INT 0
91153: PUSH
91154: EMPTY
91155: LIST
91156: LIST
91157: LIST
91158: PUSH
91159: LD_VAR 0 1
91163: PUSH
91164: LD_INT 3
91166: MINUS
91167: PUSH
91168: LD_VAR 0 2
91172: PUSH
91173: LD_INT 1
91175: PUSH
91176: EMPTY
91177: LIST
91178: LIST
91179: LIST
91180: PUSH
91181: LD_VAR 0 1
91185: PUSH
91186: LD_INT 4
91188: MINUS
91189: PUSH
91190: LD_VAR 0 2
91194: PUSH
91195: LD_INT 4
91197: MINUS
91198: PUSH
91199: LD_INT 2
91201: PUSH
91202: EMPTY
91203: LIST
91204: LIST
91205: LIST
91206: PUSH
91207: EMPTY
91208: LIST
91209: LIST
91210: LIST
91211: LIST
91212: LIST
91213: ST_TO_ADDR
// end ; 3 :
91214: GO 91636
91216: LD_INT 3
91218: DOUBLE
91219: EQUAL
91220: IFTRUE 91224
91222: GO 91357
91224: POP
// begin list := [ [ x + 3 , y , 4 ] , [ x + 4 , y + 4 , 5 ] , [ x - 4 , y , 1 ] , [ x , y - 4 , 3 ] , [ x - 3 , y - 3 , 2 ] ] ;
91225: LD_ADDR_VAR 0 5
91229: PUSH
91230: LD_VAR 0 1
91234: PUSH
91235: LD_INT 3
91237: PLUS
91238: PUSH
91239: LD_VAR 0 2
91243: PUSH
91244: LD_INT 4
91246: PUSH
91247: EMPTY
91248: LIST
91249: LIST
91250: LIST
91251: PUSH
91252: LD_VAR 0 1
91256: PUSH
91257: LD_INT 4
91259: PLUS
91260: PUSH
91261: LD_VAR 0 2
91265: PUSH
91266: LD_INT 4
91268: PLUS
91269: PUSH
91270: LD_INT 5
91272: PUSH
91273: EMPTY
91274: LIST
91275: LIST
91276: LIST
91277: PUSH
91278: LD_VAR 0 1
91282: PUSH
91283: LD_INT 4
91285: MINUS
91286: PUSH
91287: LD_VAR 0 2
91291: PUSH
91292: LD_INT 1
91294: PUSH
91295: EMPTY
91296: LIST
91297: LIST
91298: LIST
91299: PUSH
91300: LD_VAR 0 1
91304: PUSH
91305: LD_VAR 0 2
91309: PUSH
91310: LD_INT 4
91312: MINUS
91313: PUSH
91314: LD_INT 3
91316: PUSH
91317: EMPTY
91318: LIST
91319: LIST
91320: LIST
91321: PUSH
91322: LD_VAR 0 1
91326: PUSH
91327: LD_INT 3
91329: MINUS
91330: PUSH
91331: LD_VAR 0 2
91335: PUSH
91336: LD_INT 3
91338: MINUS
91339: PUSH
91340: LD_INT 2
91342: PUSH
91343: EMPTY
91344: LIST
91345: LIST
91346: LIST
91347: PUSH
91348: EMPTY
91349: LIST
91350: LIST
91351: LIST
91352: LIST
91353: LIST
91354: ST_TO_ADDR
// end ; 4 :
91355: GO 91636
91357: LD_INT 4
91359: DOUBLE
91360: EQUAL
91361: IFTRUE 91365
91363: GO 91498
91365: POP
// begin list := [ [ x , y + 4 , 0 ] , [ x + 3 , y + 3 , 5 ] , [ x + 4 , y , 4 ] , [ x , y - 3 , 3 ] , [ x - 4 , y - 4 , 2 ] ] ;
91366: LD_ADDR_VAR 0 5
91370: PUSH
91371: LD_VAR 0 1
91375: PUSH
91376: LD_VAR 0 2
91380: PUSH
91381: LD_INT 4
91383: PLUS
91384: PUSH
91385: LD_INT 0
91387: PUSH
91388: EMPTY
91389: LIST
91390: LIST
91391: LIST
91392: PUSH
91393: LD_VAR 0 1
91397: PUSH
91398: LD_INT 3
91400: PLUS
91401: PUSH
91402: LD_VAR 0 2
91406: PUSH
91407: LD_INT 3
91409: PLUS
91410: PUSH
91411: LD_INT 5
91413: PUSH
91414: EMPTY
91415: LIST
91416: LIST
91417: LIST
91418: PUSH
91419: LD_VAR 0 1
91423: PUSH
91424: LD_INT 4
91426: PLUS
91427: PUSH
91428: LD_VAR 0 2
91432: PUSH
91433: LD_INT 4
91435: PUSH
91436: EMPTY
91437: LIST
91438: LIST
91439: LIST
91440: PUSH
91441: LD_VAR 0 1
91445: PUSH
91446: LD_VAR 0 2
91450: PUSH
91451: LD_INT 3
91453: MINUS
91454: PUSH
91455: LD_INT 3
91457: PUSH
91458: EMPTY
91459: LIST
91460: LIST
91461: LIST
91462: PUSH
91463: LD_VAR 0 1
91467: PUSH
91468: LD_INT 4
91470: MINUS
91471: PUSH
91472: LD_VAR 0 2
91476: PUSH
91477: LD_INT 4
91479: MINUS
91480: PUSH
91481: LD_INT 2
91483: PUSH
91484: EMPTY
91485: LIST
91486: LIST
91487: LIST
91488: PUSH
91489: EMPTY
91490: LIST
91491: LIST
91492: LIST
91493: LIST
91494: LIST
91495: ST_TO_ADDR
// end ; 5 :
91496: GO 91636
91498: LD_INT 5
91500: DOUBLE
91501: EQUAL
91502: IFTRUE 91506
91504: GO 91635
91506: POP
// begin list := [ [ x - 4 , y , 1 ] , [ x , y - 4 , 3 ] , [ x + 4 , y + 4 , 5 ] , [ x + 3 , y , 4 ] , [ x , y + 3 , 0 ] ] ;
91507: LD_ADDR_VAR 0 5
91511: PUSH
91512: LD_VAR 0 1
91516: PUSH
91517: LD_INT 4
91519: MINUS
91520: PUSH
91521: LD_VAR 0 2
91525: PUSH
91526: LD_INT 1
91528: PUSH
91529: EMPTY
91530: LIST
91531: LIST
91532: LIST
91533: PUSH
91534: LD_VAR 0 1
91538: PUSH
91539: LD_VAR 0 2
91543: PUSH
91544: LD_INT 4
91546: MINUS
91547: PUSH
91548: LD_INT 3
91550: PUSH
91551: EMPTY
91552: LIST
91553: LIST
91554: LIST
91555: PUSH
91556: LD_VAR 0 1
91560: PUSH
91561: LD_INT 4
91563: PLUS
91564: PUSH
91565: LD_VAR 0 2
91569: PUSH
91570: LD_INT 4
91572: PLUS
91573: PUSH
91574: LD_INT 5
91576: PUSH
91577: EMPTY
91578: LIST
91579: LIST
91580: LIST
91581: PUSH
91582: LD_VAR 0 1
91586: PUSH
91587: LD_INT 3
91589: PLUS
91590: PUSH
91591: LD_VAR 0 2
91595: PUSH
91596: LD_INT 4
91598: PUSH
91599: EMPTY
91600: LIST
91601: LIST
91602: LIST
91603: PUSH
91604: LD_VAR 0 1
91608: PUSH
91609: LD_VAR 0 2
91613: PUSH
91614: LD_INT 3
91616: PLUS
91617: PUSH
91618: LD_INT 0
91620: PUSH
91621: EMPTY
91622: LIST
91623: LIST
91624: LIST
91625: PUSH
91626: EMPTY
91627: LIST
91628: LIST
91629: LIST
91630: LIST
91631: LIST
91632: ST_TO_ADDR
// end ; end ;
91633: GO 91636
91635: POP
// result := list ;
91636: LD_ADDR_VAR 0 4
91640: PUSH
91641: LD_VAR 0 5
91645: ST_TO_ADDR
// end ;
91646: LD_VAR 0 4
91650: RET
// export function SortBySkill ( units , class ) ; var i , tmp ; begin
91651: LD_INT 0
91653: PPUSH
91654: PPUSH
91655: PPUSH
// if not units or not class in [ 1 , 2 , 3 , 4 ] then
91656: LD_VAR 0 1
91660: NOT
91661: PUSH
91662: LD_VAR 0 2
91666: PUSH
91667: LD_INT 1
91669: PUSH
91670: LD_INT 2
91672: PUSH
91673: LD_INT 3
91675: PUSH
91676: LD_INT 4
91678: PUSH
91679: EMPTY
91680: LIST
91681: LIST
91682: LIST
91683: LIST
91684: IN
91685: NOT
91686: OR
91687: IFFALSE 91691
// exit ;
91689: GO 91783
// tmp := [ ] ;
91691: LD_ADDR_VAR 0 5
91695: PUSH
91696: EMPTY
91697: ST_TO_ADDR
// for i in units do
91698: LD_ADDR_VAR 0 4
91702: PUSH
91703: LD_VAR 0 1
91707: PUSH
91708: FOR_IN
91709: IFFALSE 91752
// tmp := Insert ( tmp , tmp + 1 , GetSkill ( i , class ) ) ;
91711: LD_ADDR_VAR 0 5
91715: PUSH
91716: LD_VAR 0 5
91720: PPUSH
91721: LD_VAR 0 5
91725: PUSH
91726: LD_INT 1
91728: PLUS
91729: PPUSH
91730: LD_VAR 0 4
91734: PPUSH
91735: LD_VAR 0 2
91739: PPUSH
91740: CALL_OW 259
91744: PPUSH
91745: CALL_OW 2
91749: ST_TO_ADDR
91750: GO 91708
91752: POP
91753: POP
// if not tmp then
91754: LD_VAR 0 5
91758: NOT
91759: IFFALSE 91763
// exit ;
91761: GO 91783
// result := SortListByListDesc ( units , tmp ) ;
91763: LD_ADDR_VAR 0 3
91767: PUSH
91768: LD_VAR 0 1
91772: PPUSH
91773: LD_VAR 0 5
91777: PPUSH
91778: CALL_OW 77
91782: ST_TO_ADDR
// end ;
91783: LD_VAR 0 3
91787: RET
// export function UnitGoingToBuilding ( unit , building ) ; var x , y ; begin
91788: LD_INT 0
91790: PPUSH
91791: PPUSH
91792: PPUSH
// x := GetX ( building ) ;
91793: LD_ADDR_VAR 0 4
91797: PUSH
91798: LD_VAR 0 2
91802: PPUSH
91803: CALL_OW 250
91807: ST_TO_ADDR
// y := GetY ( building ) ;
91808: LD_ADDR_VAR 0 5
91812: PUSH
91813: LD_VAR 0 2
91817: PPUSH
91818: CALL_OW 251
91822: ST_TO_ADDR
// if GetTaskList ( unit ) then
91823: LD_VAR 0 1
91827: PPUSH
91828: CALL_OW 437
91832: IFFALSE 91927
// begin if e = GetTaskList ( unit ) [ 1 ] [ 1 ] and x = GetTaskList ( unit ) [ 1 ] [ 2 ] and y = GetTaskList ( unit ) [ 1 ] [ 3 ] then
91834: LD_STRING e
91836: PUSH
91837: LD_VAR 0 1
91841: PPUSH
91842: CALL_OW 437
91846: PUSH
91847: LD_INT 1
91849: ARRAY
91850: PUSH
91851: LD_INT 1
91853: ARRAY
91854: EQUAL
91855: PUSH
91856: LD_VAR 0 4
91860: PUSH
91861: LD_VAR 0 1
91865: PPUSH
91866: CALL_OW 437
91870: PUSH
91871: LD_INT 1
91873: ARRAY
91874: PUSH
91875: LD_INT 2
91877: ARRAY
91878: EQUAL
91879: AND
91880: PUSH
91881: LD_VAR 0 5
91885: PUSH
91886: LD_VAR 0 1
91890: PPUSH
91891: CALL_OW 437
91895: PUSH
91896: LD_INT 1
91898: ARRAY
91899: PUSH
91900: LD_INT 3
91902: ARRAY
91903: EQUAL
91904: AND
91905: IFFALSE 91917
// result := true else
91907: LD_ADDR_VAR 0 3
91911: PUSH
91912: LD_INT 1
91914: ST_TO_ADDR
91915: GO 91925
// result := false ;
91917: LD_ADDR_VAR 0 3
91921: PUSH
91922: LD_INT 0
91924: ST_TO_ADDR
// end else
91925: GO 91935
// result := false ;
91927: LD_ADDR_VAR 0 3
91931: PUSH
91932: LD_INT 0
91934: ST_TO_ADDR
// end ;
91935: LD_VAR 0 3
91939: RET
// export function PlaceUnitInArea ( unit , area , mode ) ; var i , tmp , hex ; begin
91940: LD_INT 0
91942: PPUSH
91943: PPUSH
91944: PPUSH
91945: PPUSH
// if not unit or not area then
91946: LD_VAR 0 1
91950: NOT
91951: PUSH
91952: LD_VAR 0 2
91956: NOT
91957: OR
91958: IFFALSE 91962
// exit ;
91960: GO 92126
// tmp := AreaToList ( area , i ) ;
91962: LD_ADDR_VAR 0 6
91966: PUSH
91967: LD_VAR 0 2
91971: PPUSH
91972: LD_VAR 0 5
91976: PPUSH
91977: CALL_OW 517
91981: ST_TO_ADDR
// for i = 1 to tmp [ 1 ] do
91982: LD_ADDR_VAR 0 5
91986: PUSH
91987: DOUBLE
91988: LD_INT 1
91990: DEC
91991: ST_TO_ADDR
91992: LD_VAR 0 6
91996: PUSH
91997: LD_INT 1
91999: ARRAY
92000: PUSH
92001: FOR_TO
92002: IFFALSE 92124
// begin hex := [ tmp [ 1 ] [ i ] , tmp [ 2 ] [ i ] ] ;
92004: LD_ADDR_VAR 0 7
92008: PUSH
92009: LD_VAR 0 6
92013: PUSH
92014: LD_INT 1
92016: ARRAY
92017: PUSH
92018: LD_VAR 0 5
92022: ARRAY
92023: PUSH
92024: LD_VAR 0 6
92028: PUSH
92029: LD_INT 2
92031: ARRAY
92032: PUSH
92033: LD_VAR 0 5
92037: ARRAY
92038: PUSH
92039: EMPTY
92040: LIST
92041: LIST
92042: ST_TO_ADDR
// if HexInfo ( hex [ 1 ] , hex [ 2 ] ) = 0 then
92043: LD_VAR 0 7
92047: PUSH
92048: LD_INT 1
92050: ARRAY
92051: PPUSH
92052: LD_VAR 0 7
92056: PUSH
92057: LD_INT 2
92059: ARRAY
92060: PPUSH
92061: CALL_OW 428
92065: PUSH
92066: LD_INT 0
92068: EQUAL
92069: IFFALSE 92122
// begin PlaceUnitXY ( unit , hex [ 1 ] , hex [ 2 ] , mode ) ;
92071: LD_VAR 0 1
92075: PPUSH
92076: LD_VAR 0 7
92080: PUSH
92081: LD_INT 1
92083: ARRAY
92084: PPUSH
92085: LD_VAR 0 7
92089: PUSH
92090: LD_INT 2
92092: ARRAY
92093: PPUSH
92094: LD_VAR 0 3
92098: PPUSH
92099: CALL_OW 48
// result := IsPlaced ( unit ) ;
92103: LD_ADDR_VAR 0 4
92107: PUSH
92108: LD_VAR 0 1
92112: PPUSH
92113: CALL_OW 305
92117: ST_TO_ADDR
// exit ;
92118: POP
92119: POP
92120: GO 92126
// end ; end ;
92122: GO 92001
92124: POP
92125: POP
// end ;
92126: LD_VAR 0 4
92130: RET
// export function BuildingsListDump ( side ) ; var i , tmp ; begin
92131: LD_INT 0
92133: PPUSH
92134: PPUSH
92135: PPUSH
// if not side or side > 8 then
92136: LD_VAR 0 1
92140: NOT
92141: PUSH
92142: LD_VAR 0 1
92146: PUSH
92147: LD_INT 8
92149: GREATER
92150: OR
92151: IFFALSE 92155
// exit ;
92153: GO 92342
// tmp := FilterAllUnits ( [ [ f_side , side ] , [ f_type , unit_building ] ] ) ;
92155: LD_ADDR_VAR 0 4
92159: PUSH
92160: LD_INT 22
92162: PUSH
92163: LD_VAR 0 1
92167: PUSH
92168: EMPTY
92169: LIST
92170: LIST
92171: PUSH
92172: LD_INT 21
92174: PUSH
92175: LD_INT 3
92177: PUSH
92178: EMPTY
92179: LIST
92180: LIST
92181: PUSH
92182: EMPTY
92183: LIST
92184: LIST
92185: PPUSH
92186: CALL_OW 69
92190: ST_TO_ADDR
// if not tmp then
92191: LD_VAR 0 4
92195: NOT
92196: IFFALSE 92200
// exit ;
92198: GO 92342
// enable_addtolog := true ;
92200: LD_ADDR_OWVAR 81
92204: PUSH
92205: LD_INT 1
92207: ST_TO_ADDR
// AddToLog ( [ ) ;
92208: LD_STRING [
92210: PPUSH
92211: CALL_OW 561
// for i in tmp do
92215: LD_ADDR_VAR 0 3
92219: PUSH
92220: LD_VAR 0 4
92224: PUSH
92225: FOR_IN
92226: IFFALSE 92333
// begin AddToLog ( [ & GetBType ( i ) & ,  & GetX ( i ) & ,  & GetY ( i ) & ,  & GetDir ( i ) & ,  & GetLabKind ( i , 1 ) & ,  & GetLabKind ( i , 2 ) & ], ) ;
92228: LD_STRING [
92230: PUSH
92231: LD_VAR 0 3
92235: PPUSH
92236: CALL_OW 266
92240: STR
92241: PUSH
92242: LD_STRING , 
92244: STR
92245: PUSH
92246: LD_VAR 0 3
92250: PPUSH
92251: CALL_OW 250
92255: STR
92256: PUSH
92257: LD_STRING , 
92259: STR
92260: PUSH
92261: LD_VAR 0 3
92265: PPUSH
92266: CALL_OW 251
92270: STR
92271: PUSH
92272: LD_STRING , 
92274: STR
92275: PUSH
92276: LD_VAR 0 3
92280: PPUSH
92281: CALL_OW 254
92285: STR
92286: PUSH
92287: LD_STRING , 
92289: STR
92290: PUSH
92291: LD_VAR 0 3
92295: PPUSH
92296: LD_INT 1
92298: PPUSH
92299: CALL_OW 268
92303: STR
92304: PUSH
92305: LD_STRING , 
92307: STR
92308: PUSH
92309: LD_VAR 0 3
92313: PPUSH
92314: LD_INT 2
92316: PPUSH
92317: CALL_OW 268
92321: STR
92322: PUSH
92323: LD_STRING ],
92325: STR
92326: PPUSH
92327: CALL_OW 561
// end ;
92331: GO 92225
92333: POP
92334: POP
// AddToLog ( ]; ) ;
92335: LD_STRING ];
92337: PPUSH
92338: CALL_OW 561
// end ;
92342: LD_VAR 0 2
92346: RET
// export function Crates ( area , rate , min , max ) ; var i , r , time , amount ; begin
92347: LD_INT 0
92349: PPUSH
92350: PPUSH
92351: PPUSH
92352: PPUSH
92353: PPUSH
// if not area or not rate or not max then
92354: LD_VAR 0 1
92358: NOT
92359: PUSH
92360: LD_VAR 0 2
92364: NOT
92365: OR
92366: PUSH
92367: LD_VAR 0 4
92371: NOT
92372: OR
92373: IFFALSE 92377
// exit ;
92375: GO 92569
// while 1 do
92377: LD_INT 1
92379: IFFALSE 92569
// begin amount := GetResourceArea ( area , mat_cans ) * 10 ;
92381: LD_ADDR_VAR 0 9
92385: PUSH
92386: LD_VAR 0 1
92390: PPUSH
92391: LD_INT 1
92393: PPUSH
92394: CALL_OW 287
92398: PUSH
92399: LD_INT 10
92401: MUL
92402: ST_TO_ADDR
// r := rate / 10 ;
92403: LD_ADDR_VAR 0 7
92407: PUSH
92408: LD_VAR 0 2
92412: PUSH
92413: LD_INT 10
92415: DIVREAL
92416: ST_TO_ADDR
// time := 1 1$00 ;
92417: LD_ADDR_VAR 0 8
92421: PUSH
92422: LD_INT 2100
92424: ST_TO_ADDR
// if amount < min then
92425: LD_VAR 0 9
92429: PUSH
92430: LD_VAR 0 3
92434: LESS
92435: IFFALSE 92453
// r := r * 2 else
92437: LD_ADDR_VAR 0 7
92441: PUSH
92442: LD_VAR 0 7
92446: PUSH
92447: LD_INT 2
92449: MUL
92450: ST_TO_ADDR
92451: GO 92479
// if amount > max then
92453: LD_VAR 0 9
92457: PUSH
92458: LD_VAR 0 4
92462: GREATER
92463: IFFALSE 92479
// r := r / 2 ;
92465: LD_ADDR_VAR 0 7
92469: PUSH
92470: LD_VAR 0 7
92474: PUSH
92475: LD_INT 2
92477: DIVREAL
92478: ST_TO_ADDR
// time := time / r ;
92479: LD_ADDR_VAR 0 8
92483: PUSH
92484: LD_VAR 0 8
92488: PUSH
92489: LD_VAR 0 7
92493: DIVREAL
92494: ST_TO_ADDR
// if time < 0 then
92495: LD_VAR 0 8
92499: PUSH
92500: LD_INT 0
92502: LESS
92503: IFFALSE 92520
// time := time * - 1 ;
92505: LD_ADDR_VAR 0 8
92509: PUSH
92510: LD_VAR 0 8
92514: PUSH
92515: LD_INT 1
92517: NEG
92518: MUL
92519: ST_TO_ADDR
// wait ( time ) ;
92520: LD_VAR 0 8
92524: PPUSH
92525: CALL_OW 67
// wait ( rand ( 0 0$01 , 0 0$25 ) ) ;
92529: LD_INT 35
92531: PPUSH
92532: LD_INT 875
92534: PPUSH
92535: CALL_OW 12
92539: PPUSH
92540: CALL_OW 67
// CreateCratesArea ( rand ( 1 , 5 ) , area , true ) ;
92544: LD_INT 1
92546: PPUSH
92547: LD_INT 5
92549: PPUSH
92550: CALL_OW 12
92554: PPUSH
92555: LD_VAR 0 1
92559: PPUSH
92560: LD_INT 1
92562: PPUSH
92563: CALL_OW 55
// end ;
92567: GO 92377
// end ;
92569: LD_VAR 0 5
92573: RET
// export function UpgradeTurretsWeapon ( turrets , factories ) ; var i , j , k , nat , weapon , weapons , list ; begin
92574: LD_INT 0
92576: PPUSH
92577: PPUSH
92578: PPUSH
92579: PPUSH
92580: PPUSH
92581: PPUSH
92582: PPUSH
92583: PPUSH
// if not turrets or not factories then
92584: LD_VAR 0 1
92588: NOT
92589: PUSH
92590: LD_VAR 0 2
92594: NOT
92595: OR
92596: IFFALSE 92600
// exit ;
92598: GO 92907
// list := [ [ [ us_double_gun , us_heavy_gun ] , [ us_machine_gun , us_gatling_gun ] , [ us_light_gun , us_double_gun ] ] , [ [ ar_double_machine_gun , ar_gatling_gun ] , [ ar_light_gun , ar_gun ] ] , [ [ ru_heavy_machine_gun , ru_gatling_gun ] , [ ru_gun , ru_heavy_gun ] , [ ru_rocket_launcher , ru_rocket ] ] , ] ;
92600: LD_ADDR_VAR 0 10
92604: PUSH
92605: LD_INT 5
92607: PUSH
92608: LD_INT 6
92610: PUSH
92611: EMPTY
92612: LIST
92613: LIST
92614: PUSH
92615: LD_INT 2
92617: PUSH
92618: LD_INT 4
92620: PUSH
92621: EMPTY
92622: LIST
92623: LIST
92624: PUSH
92625: LD_INT 3
92627: PUSH
92628: LD_INT 5
92630: PUSH
92631: EMPTY
92632: LIST
92633: LIST
92634: PUSH
92635: EMPTY
92636: LIST
92637: LIST
92638: LIST
92639: PUSH
92640: LD_INT 24
92642: PUSH
92643: LD_INT 25
92645: PUSH
92646: EMPTY
92647: LIST
92648: LIST
92649: PUSH
92650: LD_INT 23
92652: PUSH
92653: LD_INT 27
92655: PUSH
92656: EMPTY
92657: LIST
92658: LIST
92659: PUSH
92660: EMPTY
92661: LIST
92662: LIST
92663: PUSH
92664: LD_INT 42
92666: PUSH
92667: LD_INT 43
92669: PUSH
92670: EMPTY
92671: LIST
92672: LIST
92673: PUSH
92674: LD_INT 44
92676: PUSH
92677: LD_INT 46
92679: PUSH
92680: EMPTY
92681: LIST
92682: LIST
92683: PUSH
92684: LD_INT 45
92686: PUSH
92687: LD_INT 47
92689: PUSH
92690: EMPTY
92691: LIST
92692: LIST
92693: PUSH
92694: EMPTY
92695: LIST
92696: LIST
92697: LIST
92698: PUSH
92699: EMPTY
92700: LIST
92701: LIST
92702: LIST
92703: ST_TO_ADDR
// result := [ ] ;
92704: LD_ADDR_VAR 0 3
92708: PUSH
92709: EMPTY
92710: ST_TO_ADDR
// for i in turrets do
92711: LD_ADDR_VAR 0 4
92715: PUSH
92716: LD_VAR 0 1
92720: PUSH
92721: FOR_IN
92722: IFFALSE 92905
// begin nat := GetNation ( i ) ;
92724: LD_ADDR_VAR 0 7
92728: PUSH
92729: LD_VAR 0 4
92733: PPUSH
92734: CALL_OW 248
92738: ST_TO_ADDR
// weapon := 0 ;
92739: LD_ADDR_VAR 0 8
92743: PUSH
92744: LD_INT 0
92746: ST_TO_ADDR
// if not nat then
92747: LD_VAR 0 7
92751: NOT
92752: IFFALSE 92756
// continue ;
92754: GO 92721
// for j in list [ nat ] do
92756: LD_ADDR_VAR 0 5
92760: PUSH
92761: LD_VAR 0 10
92765: PUSH
92766: LD_VAR 0 7
92770: ARRAY
92771: PUSH
92772: FOR_IN
92773: IFFALSE 92814
// if GetBWeapon ( i ) = j [ 1 ] then
92775: LD_VAR 0 4
92779: PPUSH
92780: CALL_OW 269
92784: PUSH
92785: LD_VAR 0 5
92789: PUSH
92790: LD_INT 1
92792: ARRAY
92793: EQUAL
92794: IFFALSE 92812
// begin weapon := j [ 2 ] ;
92796: LD_ADDR_VAR 0 8
92800: PUSH
92801: LD_VAR 0 5
92805: PUSH
92806: LD_INT 2
92808: ARRAY
92809: ST_TO_ADDR
// break ;
92810: GO 92814
// end ;
92812: GO 92772
92814: POP
92815: POP
// if not weapon then
92816: LD_VAR 0 8
92820: NOT
92821: IFFALSE 92825
// continue ;
92823: GO 92721
// for k in factories do
92825: LD_ADDR_VAR 0 6
92829: PUSH
92830: LD_VAR 0 2
92834: PUSH
92835: FOR_IN
92836: IFFALSE 92901
// begin weapons := AvailableWeaponList ( k ) ;
92838: LD_ADDR_VAR 0 9
92842: PUSH
92843: LD_VAR 0 6
92847: PPUSH
92848: CALL_OW 478
92852: ST_TO_ADDR
// if not weapons then
92853: LD_VAR 0 9
92857: NOT
92858: IFFALSE 92862
// continue ;
92860: GO 92835
// if weapon in weapons then
92862: LD_VAR 0 8
92866: PUSH
92867: LD_VAR 0 9
92871: IN
92872: IFFALSE 92899
// begin result := [ i , weapon ] ;
92874: LD_ADDR_VAR 0 3
92878: PUSH
92879: LD_VAR 0 4
92883: PUSH
92884: LD_VAR 0 8
92888: PUSH
92889: EMPTY
92890: LIST
92891: LIST
92892: ST_TO_ADDR
// exit ;
92893: POP
92894: POP
92895: POP
92896: POP
92897: GO 92907
// end ; end ;
92899: GO 92835
92901: POP
92902: POP
// end ;
92903: GO 92721
92905: POP
92906: POP
// end ;
92907: LD_VAR 0 3
92911: RET
// export function RevealMapOnXY ( x , y , side , range ) ; begin
92912: LD_INT 0
92914: PPUSH
// if not side or side > 8 then
92915: LD_VAR 0 3
92919: NOT
92920: PUSH
92921: LD_VAR 0 3
92925: PUSH
92926: LD_INT 8
92928: GREATER
92929: OR
92930: IFFALSE 92934
// exit ;
92932: GO 92993
// if not range then
92934: LD_VAR 0 4
92938: NOT
92939: IFFALSE 92950
// range := - 12 ;
92941: LD_ADDR_VAR 0 4
92945: PUSH
92946: LD_INT 12
92948: NEG
92949: ST_TO_ADDR
// PlaceSeeing ( x , y , side , range ) ;
92950: LD_VAR 0 1
92954: PPUSH
92955: LD_VAR 0 2
92959: PPUSH
92960: LD_VAR 0 3
92964: PPUSH
92965: LD_VAR 0 4
92969: PPUSH
92970: CALL_OW 330
// RemoveSeeing ( x , y , side ) ;
92974: LD_VAR 0 1
92978: PPUSH
92979: LD_VAR 0 2
92983: PPUSH
92984: LD_VAR 0 3
92988: PPUSH
92989: CALL_OW 331
// end ;
92993: LD_VAR 0 5
92997: RET
// export function Video ( mode ) ; begin
92998: LD_INT 0
93000: PPUSH
// ingame_video = mode ;
93001: LD_ADDR_OWVAR 52
93005: PUSH
93006: LD_VAR 0 1
93010: ST_TO_ADDR
// interface_hidden = mode ;
93011: LD_ADDR_OWVAR 54
93015: PUSH
93016: LD_VAR 0 1
93020: ST_TO_ADDR
// end ;
93021: LD_VAR 0 2
93025: RET
// export function Join ( array , element ) ; begin
93026: LD_INT 0
93028: PPUSH
// result := array ^ element ;
93029: LD_ADDR_VAR 0 3
93033: PUSH
93034: LD_VAR 0 1
93038: PUSH
93039: LD_VAR 0 2
93043: ADD
93044: ST_TO_ADDR
// end ;
93045: LD_VAR 0 3
93049: RET
// export function JoinUnion ( array , element ) ; begin
93050: LD_INT 0
93052: PPUSH
// result := array union element ;
93053: LD_ADDR_VAR 0 3
93057: PUSH
93058: LD_VAR 0 1
93062: PUSH
93063: LD_VAR 0 2
93067: UNION
93068: ST_TO_ADDR
// end ;
93069: LD_VAR 0 3
93073: RET
// export function GetBehemoths ( side ) ; begin
93074: LD_INT 0
93076: PPUSH
// result := FilterAllUnits ( [ [ f_side , side ] , [ f_chassis , 25 ] ] ) ;
93077: LD_ADDR_VAR 0 2
93081: PUSH
93082: LD_INT 22
93084: PUSH
93085: LD_VAR 0 1
93089: PUSH
93090: EMPTY
93091: LIST
93092: LIST
93093: PUSH
93094: LD_INT 31
93096: PUSH
93097: LD_INT 25
93099: PUSH
93100: EMPTY
93101: LIST
93102: LIST
93103: PUSH
93104: EMPTY
93105: LIST
93106: LIST
93107: PPUSH
93108: CALL_OW 69
93112: ST_TO_ADDR
// end ;
93113: LD_VAR 0 2
93117: RET
// export function Shuffle ( array ) ; var i , index ; begin
93118: LD_INT 0
93120: PPUSH
93121: PPUSH
93122: PPUSH
// result := [ ] ;
93123: LD_ADDR_VAR 0 2
93127: PUSH
93128: EMPTY
93129: ST_TO_ADDR
// if not array then
93130: LD_VAR 0 1
93134: NOT
93135: IFFALSE 93139
// exit ;
93137: GO 93238
// Randomize ;
93139: CALL_OW 10
// for i = array downto 1 do
93143: LD_ADDR_VAR 0 3
93147: PUSH
93148: DOUBLE
93149: LD_VAR 0 1
93153: INC
93154: ST_TO_ADDR
93155: LD_INT 1
93157: PUSH
93158: FOR_DOWNTO
93159: IFFALSE 93236
// begin index := rand ( 1 , array ) ;
93161: LD_ADDR_VAR 0 4
93165: PUSH
93166: LD_INT 1
93168: PPUSH
93169: LD_VAR 0 1
93173: PPUSH
93174: CALL_OW 12
93178: ST_TO_ADDR
// result := Insert ( result , result + 1 , array [ index ] ) ;
93179: LD_ADDR_VAR 0 2
93183: PUSH
93184: LD_VAR 0 2
93188: PPUSH
93189: LD_VAR 0 2
93193: PUSH
93194: LD_INT 1
93196: PLUS
93197: PPUSH
93198: LD_VAR 0 1
93202: PUSH
93203: LD_VAR 0 4
93207: ARRAY
93208: PPUSH
93209: CALL_OW 2
93213: ST_TO_ADDR
// array := Delete ( array , index ) ;
93214: LD_ADDR_VAR 0 1
93218: PUSH
93219: LD_VAR 0 1
93223: PPUSH
93224: LD_VAR 0 4
93228: PPUSH
93229: CALL_OW 3
93233: ST_TO_ADDR
// end ;
93234: GO 93158
93236: POP
93237: POP
// end ;
93238: LD_VAR 0 2
93242: RET
// export function GetBaseMaterials ( base ) ; begin
93243: LD_INT 0
93245: PPUSH
// result := [ 0 , 0 , 0 ] ;
93246: LD_ADDR_VAR 0 2
93250: PUSH
93251: LD_INT 0
93253: PUSH
93254: LD_INT 0
93256: PUSH
93257: LD_INT 0
93259: PUSH
93260: EMPTY
93261: LIST
93262: LIST
93263: LIST
93264: ST_TO_ADDR
// if not base then
93265: LD_VAR 0 1
93269: NOT
93270: IFFALSE 93274
// exit ;
93272: GO 93323
// result := [ GetResourceType ( base , mat_cans ) , GetResourceType ( base , mat_oil ) , GetResourceType ( base , mat_siberit ) ] ;
93274: LD_ADDR_VAR 0 2
93278: PUSH
93279: LD_VAR 0 1
93283: PPUSH
93284: LD_INT 1
93286: PPUSH
93287: CALL_OW 275
93291: PUSH
93292: LD_VAR 0 1
93296: PPUSH
93297: LD_INT 2
93299: PPUSH
93300: CALL_OW 275
93304: PUSH
93305: LD_VAR 0 1
93309: PPUSH
93310: LD_INT 3
93312: PPUSH
93313: CALL_OW 275
93317: PUSH
93318: EMPTY
93319: LIST
93320: LIST
93321: LIST
93322: ST_TO_ADDR
// end ; end_of_file end_of_file end_of_file
93323: LD_VAR 0 2
93327: RET
// export function SOS_UnitExtraDestroyed ( un , killerSide , killerUnit ) ; var i , eff , side ; begin
93328: LD_INT 0
93330: PPUSH
93331: PPUSH
93332: PPUSH
93333: PPUSH
// if GetWeapon ( un ) = ar_bio_bomb then
93334: LD_VAR 0 1
93338: PPUSH
93339: CALL_OW 264
93343: PUSH
93344: LD_EXP 71
93348: EQUAL
93349: IFFALSE 93421
// begin if GetTech ( tech_bio3 , GetSide ( un ) ) = state_researched then
93351: LD_INT 68
93353: PPUSH
93354: LD_VAR 0 1
93358: PPUSH
93359: CALL_OW 255
93363: PPUSH
93364: CALL_OW 321
93368: PUSH
93369: LD_INT 2
93371: EQUAL
93372: IFFALSE 93384
// eff := 70 else
93374: LD_ADDR_VAR 0 6
93378: PUSH
93379: LD_INT 70
93381: ST_TO_ADDR
93382: GO 93392
// eff := 30 ;
93384: LD_ADDR_VAR 0 6
93388: PUSH
93389: LD_INT 30
93391: ST_TO_ADDR
// ArtContamination ( GetX ( un ) , GetY ( un ) , eff ) ;
93392: LD_VAR 0 1
93396: PPUSH
93397: CALL_OW 250
93401: PPUSH
93402: LD_VAR 0 1
93406: PPUSH
93407: CALL_OW 251
93411: PPUSH
93412: LD_VAR 0 6
93416: PPUSH
93417: CALL_OW 495
// end ; end ;
93421: LD_VAR 0 4
93425: RET
// export function SOS_Command ( cmd ) ; var i , j , tmp , taskList , _taskList ; begin
93426: LD_INT 0
93428: PPUSH
93429: PPUSH
93430: PPUSH
93431: PPUSH
93432: PPUSH
93433: PPUSH
// if cmd = 124 then
93434: LD_VAR 0 1
93438: PUSH
93439: LD_INT 124
93441: EQUAL
93442: IFFALSE 93648
// begin tmp := FilterAllUnits ( [ f_or , [ f_weapon , ru_bulldozer ] , [ f_weapon , us_bulldozer ] ] ) ;
93444: LD_ADDR_VAR 0 5
93448: PUSH
93449: LD_INT 2
93451: PUSH
93452: LD_INT 34
93454: PUSH
93455: LD_INT 53
93457: PUSH
93458: EMPTY
93459: LIST
93460: LIST
93461: PUSH
93462: LD_INT 34
93464: PUSH
93465: LD_INT 14
93467: PUSH
93468: EMPTY
93469: LIST
93470: LIST
93471: PUSH
93472: EMPTY
93473: LIST
93474: LIST
93475: LIST
93476: PPUSH
93477: CALL_OW 69
93481: ST_TO_ADDR
// if not tmp then
93482: LD_VAR 0 5
93486: NOT
93487: IFFALSE 93491
// exit ;
93489: GO 93648
// for i in tmp do
93491: LD_ADDR_VAR 0 3
93495: PUSH
93496: LD_VAR 0 5
93500: PUSH
93501: FOR_IN
93502: IFFALSE 93646
// begin taskList := GetTaskList ( i ) ;
93504: LD_ADDR_VAR 0 6
93508: PUSH
93509: LD_VAR 0 3
93513: PPUSH
93514: CALL_OW 437
93518: ST_TO_ADDR
// if not taskList then
93519: LD_VAR 0 6
93523: NOT
93524: IFFALSE 93528
// continue ;
93526: GO 93501
// for j = 1 to taskList do
93528: LD_ADDR_VAR 0 4
93532: PUSH
93533: DOUBLE
93534: LD_INT 1
93536: DEC
93537: ST_TO_ADDR
93538: LD_VAR 0 6
93542: PUSH
93543: FOR_TO
93544: IFFALSE 93642
// if taskList [ j ] [ 1 ] = | then
93546: LD_VAR 0 6
93550: PUSH
93551: LD_VAR 0 4
93555: ARRAY
93556: PUSH
93557: LD_INT 1
93559: ARRAY
93560: PUSH
93561: LD_STRING |
93563: EQUAL
93564: IFFALSE 93640
// begin _taskList := Delete ( taskList , 1 ) ;
93566: LD_ADDR_VAR 0 7
93570: PUSH
93571: LD_VAR 0 6
93575: PPUSH
93576: LD_INT 1
93578: PPUSH
93579: CALL_OW 3
93583: ST_TO_ADDR
// SetTaskList ( i , _taskList ) ;
93584: LD_VAR 0 3
93588: PPUSH
93589: LD_VAR 0 7
93593: PPUSH
93594: CALL_OW 446
// CutTreeXYR ( i , taskList [ j ] [ 2 ] , taskList [ j ] [ 3 ] , 8 ) ;
93598: LD_VAR 0 3
93602: PPUSH
93603: LD_VAR 0 6
93607: PUSH
93608: LD_VAR 0 4
93612: ARRAY
93613: PUSH
93614: LD_INT 2
93616: ARRAY
93617: PPUSH
93618: LD_VAR 0 6
93622: PUSH
93623: LD_VAR 0 4
93627: ARRAY
93628: PUSH
93629: LD_INT 3
93631: ARRAY
93632: PPUSH
93633: LD_INT 8
93635: PPUSH
93636: CALL 93653 0 4
// end ;
93640: GO 93543
93642: POP
93643: POP
// end ;
93644: GO 93501
93646: POP
93647: POP
// end ; end ;
93648: LD_VAR 0 2
93652: RET
// function CutTreeXYR ( bulldozer , x , y , r ) ; var i , min_x , min_y , max_x , max_y , _x , _y , list ; begin
93653: LD_INT 0
93655: PPUSH
93656: PPUSH
93657: PPUSH
93658: PPUSH
93659: PPUSH
93660: PPUSH
93661: PPUSH
93662: PPUSH
93663: PPUSH
// if not bulldozer or not ValidHex ( x , y ) or not r then
93664: LD_VAR 0 1
93668: NOT
93669: PUSH
93670: LD_VAR 0 2
93674: PPUSH
93675: LD_VAR 0 3
93679: PPUSH
93680: CALL_OW 488
93684: NOT
93685: OR
93686: PUSH
93687: LD_VAR 0 4
93691: NOT
93692: OR
93693: IFFALSE 93697
// exit ;
93695: GO 94037
// list := [ ] ;
93697: LD_ADDR_VAR 0 13
93701: PUSH
93702: EMPTY
93703: ST_TO_ADDR
// if x - r < 0 then
93704: LD_VAR 0 2
93708: PUSH
93709: LD_VAR 0 4
93713: MINUS
93714: PUSH
93715: LD_INT 0
93717: LESS
93718: IFFALSE 93730
// min_x := 0 else
93720: LD_ADDR_VAR 0 7
93724: PUSH
93725: LD_INT 0
93727: ST_TO_ADDR
93728: GO 93746
// min_x := x - r ;
93730: LD_ADDR_VAR 0 7
93734: PUSH
93735: LD_VAR 0 2
93739: PUSH
93740: LD_VAR 0 4
93744: MINUS
93745: ST_TO_ADDR
// if y - r < 0 then
93746: LD_VAR 0 3
93750: PUSH
93751: LD_VAR 0 4
93755: MINUS
93756: PUSH
93757: LD_INT 0
93759: LESS
93760: IFFALSE 93772
// min_y := 0 else
93762: LD_ADDR_VAR 0 8
93766: PUSH
93767: LD_INT 0
93769: ST_TO_ADDR
93770: GO 93788
// min_y := y - r ;
93772: LD_ADDR_VAR 0 8
93776: PUSH
93777: LD_VAR 0 3
93781: PUSH
93782: LD_VAR 0 4
93786: MINUS
93787: ST_TO_ADDR
// max_x := x + r ;
93788: LD_ADDR_VAR 0 9
93792: PUSH
93793: LD_VAR 0 2
93797: PUSH
93798: LD_VAR 0 4
93802: PLUS
93803: ST_TO_ADDR
// max_y := y + r ;
93804: LD_ADDR_VAR 0 10
93808: PUSH
93809: LD_VAR 0 3
93813: PUSH
93814: LD_VAR 0 4
93818: PLUS
93819: ST_TO_ADDR
// for _x = min_x to max_x do
93820: LD_ADDR_VAR 0 11
93824: PUSH
93825: DOUBLE
93826: LD_VAR 0 7
93830: DEC
93831: ST_TO_ADDR
93832: LD_VAR 0 9
93836: PUSH
93837: FOR_TO
93838: IFFALSE 93955
// for _y = min_y to max_y do
93840: LD_ADDR_VAR 0 12
93844: PUSH
93845: DOUBLE
93846: LD_VAR 0 8
93850: DEC
93851: ST_TO_ADDR
93852: LD_VAR 0 10
93856: PUSH
93857: FOR_TO
93858: IFFALSE 93951
// begin if not ValidHex ( _x , _y ) then
93860: LD_VAR 0 11
93864: PPUSH
93865: LD_VAR 0 12
93869: PPUSH
93870: CALL_OW 488
93874: NOT
93875: IFFALSE 93879
// continue ;
93877: GO 93857
// if IsEnvironment ( _x , _y ) and IsEnvironmentDestroyable ( _x , _y ) then
93879: LD_VAR 0 11
93883: PPUSH
93884: LD_VAR 0 12
93888: PPUSH
93889: CALL_OW 351
93893: PUSH
93894: LD_VAR 0 11
93898: PPUSH
93899: LD_VAR 0 12
93903: PPUSH
93904: CALL_OW 554
93908: AND
93909: IFFALSE 93949
// list := Insert ( list , list + 1 , [ _x , _y ] ) ;
93911: LD_ADDR_VAR 0 13
93915: PUSH
93916: LD_VAR 0 13
93920: PPUSH
93921: LD_VAR 0 13
93925: PUSH
93926: LD_INT 1
93928: PLUS
93929: PPUSH
93930: LD_VAR 0 11
93934: PUSH
93935: LD_VAR 0 12
93939: PUSH
93940: EMPTY
93941: LIST
93942: LIST
93943: PPUSH
93944: CALL_OW 2
93948: ST_TO_ADDR
// end ;
93949: GO 93857
93951: POP
93952: POP
93953: GO 93837
93955: POP
93956: POP
// if not list then
93957: LD_VAR 0 13
93961: NOT
93962: IFFALSE 93966
// exit ;
93964: GO 94037
// for i in list do
93966: LD_ADDR_VAR 0 6
93970: PUSH
93971: LD_VAR 0 13
93975: PUSH
93976: FOR_IN
93977: IFFALSE 94035
// AddTaskList ( bulldozer , [ [ M , i [ 1 ] , i [ 2 ] , 0 , 0 , 0 , 0 ] ] ) ;
93979: LD_VAR 0 1
93983: PPUSH
93984: LD_STRING M
93986: PUSH
93987: LD_VAR 0 6
93991: PUSH
93992: LD_INT 1
93994: ARRAY
93995: PUSH
93996: LD_VAR 0 6
94000: PUSH
94001: LD_INT 2
94003: ARRAY
94004: PUSH
94005: LD_INT 0
94007: PUSH
94008: LD_INT 0
94010: PUSH
94011: LD_INT 0
94013: PUSH
94014: LD_INT 0
94016: PUSH
94017: EMPTY
94018: LIST
94019: LIST
94020: LIST
94021: LIST
94022: LIST
94023: LIST
94024: LIST
94025: PUSH
94026: EMPTY
94027: LIST
94028: PPUSH
94029: CALL_OW 447
94033: GO 93976
94035: POP
94036: POP
// end ;
94037: LD_VAR 0 5
94041: RET
