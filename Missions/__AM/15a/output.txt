// starting begin ResetFog ;
   0: CALL_OW 335
// AnimateTrees ( true ) ;
   4: LD_INT 1
   6: PPUSH
   7: CALL_OW 573
// InitVariables ;
  11: CALL 69 0 0
// InitMacro ;
  15: CALL 22770 0 0
// InitNature ;
  19: CALL 19436 0 0
// InitArtifact ;
  23: CALL 20053 0 0
// if debug then
  27: LD_EXP 1
  31: IFFALSE 40
// FogOff ( 1 ) ;
  33: LD_INT 1
  35: PPUSH
  36: CALL_OW 344
// PrepareAmerican ;
  40: CALL 5136 0 0
// PrepareAlliance ;
  44: CALL 1460 0 0
// PrepareArabian ;
  48: CALL 7119 0 0
// PrepareRussian ;
  52: CALL 9412 0 0
// PrepareLegion ;
  56: CALL 7686 0 0
// Action ;
  60: CALL 12359 0 0
// MC_Start ( ) ;
  64: CALL 24950 0 0
// end ;
  68: END
// export debug ; export russianDestroyed , legionDestroyed , americanDestroyed , arabianDestroyed ; export americanCapitulated , russianCapitulated , legionCapitulated ; export artifactArCaptured , alienSpotted , spawnOmar ; export artifactIResearched , artifactIIResearched , artifactIIIResearched ; export vehicleLostCounter , artifactDestroyCounter ; export allianceTeam , arabianAttacked , negotiationWithArabs , omarKilled ; export function InitVariables ; begin
  69: LD_INT 0
  71: PPUSH
// debug := false ;
  72: LD_ADDR_EXP 1
  76: PUSH
  77: LD_INT 0
  79: ST_TO_ADDR
// artifactArCaptured := LoadVariable ( 11_artifact_captured , 0 ) ;
  80: LD_ADDR_EXP 9
  84: PUSH
  85: LD_STRING 11_artifact_captured
  87: PPUSH
  88: LD_INT 0
  90: PPUSH
  91: CALL_OW 30
  95: ST_TO_ADDR
// negotiationWithArabs := LoadVariable ( 13a_negotiationWithArabs , false ) ;
  96: LD_ADDR_EXP 19
 100: PUSH
 101: LD_STRING 13a_negotiationWithArabs
 103: PPUSH
 104: LD_INT 0
 106: PPUSH
 107: CALL_OW 30
 111: ST_TO_ADDR
// omarKilled := false ;
 112: LD_ADDR_EXP 20
 116: PUSH
 117: LD_INT 0
 119: ST_TO_ADDR
// russianDestroyed := false ;
 120: LD_ADDR_EXP 2
 124: PUSH
 125: LD_INT 0
 127: ST_TO_ADDR
// legionDestroyed := false ;
 128: LD_ADDR_EXP 3
 132: PUSH
 133: LD_INT 0
 135: ST_TO_ADDR
// americanDestroyed := false ;
 136: LD_ADDR_EXP 4
 140: PUSH
 141: LD_INT 0
 143: ST_TO_ADDR
// arabianDestroyed := false ;
 144: LD_ADDR_EXP 5
 148: PUSH
 149: LD_INT 0
 151: ST_TO_ADDR
// americanCapitulated := false ;
 152: LD_ADDR_EXP 6
 156: PUSH
 157: LD_INT 0
 159: ST_TO_ADDR
// russianCapitulated := false ;
 160: LD_ADDR_EXP 7
 164: PUSH
 165: LD_INT 0
 167: ST_TO_ADDR
// legionCapitulated := false ;
 168: LD_ADDR_EXP 8
 172: PUSH
 173: LD_INT 0
 175: ST_TO_ADDR
// artifactIResearched := false ;
 176: LD_ADDR_EXP 12
 180: PUSH
 181: LD_INT 0
 183: ST_TO_ADDR
// artifactIIResearched := false ;
 184: LD_ADDR_EXP 13
 188: PUSH
 189: LD_INT 0
 191: ST_TO_ADDR
// artifactIIIResearched := false ;
 192: LD_ADDR_EXP 14
 196: PUSH
 197: LD_INT 0
 199: ST_TO_ADDR
// alienSpotted := false ;
 200: LD_ADDR_EXP 10
 204: PUSH
 205: LD_INT 0
 207: ST_TO_ADDR
// spawnOmar := false ;
 208: LD_ADDR_EXP 11
 212: PUSH
 213: LD_INT 0
 215: ST_TO_ADDR
// vehicleLostCounter := 0 ;
 216: LD_ADDR_EXP 15
 220: PUSH
 221: LD_INT 0
 223: ST_TO_ADDR
// artifactDestroyCounter := 0 ;
 224: LD_ADDR_EXP 16
 228: PUSH
 229: LD_INT 0
 231: ST_TO_ADDR
// allianceTeam := [ ] ;
 232: LD_ADDR_EXP 17
 236: PUSH
 237: EMPTY
 238: ST_TO_ADDR
// arabianAttacked := false ;
 239: LD_ADDR_EXP 18
 243: PUSH
 244: LD_INT 0
 246: ST_TO_ADDR
// end ;
 247: LD_VAR 0 1
 251: RET
// export function CustomInitMacro ( ) ; begin
 252: LD_INT 0
 254: PPUSH
// mc_parking := [ arabianParkingArea , russianParkingArea , legionParkingArea , powellParking ] ;
 255: LD_ADDR_EXP 104
 259: PUSH
 260: LD_INT 26
 262: PUSH
 263: LD_INT 1
 265: PUSH
 266: LD_INT 4
 268: PUSH
 269: LD_INT 8
 271: PUSH
 272: EMPTY
 273: LIST
 274: LIST
 275: LIST
 276: LIST
 277: ST_TO_ADDR
// mc_scan_area := [ arabianBaseArea , russianBaseArea , legionBaseArea , powellBase ] ;
 278: LD_ADDR_EXP 105
 282: PUSH
 283: LD_INT 27
 285: PUSH
 286: LD_INT 2
 288: PUSH
 289: LD_INT 3
 291: PUSH
 292: LD_INT 7
 294: PUSH
 295: EMPTY
 296: LIST
 297: LIST
 298: LIST
 299: LIST
 300: ST_TO_ADDR
// MC_SetMinesField ( 1 , [ 6 , 7 , 9 , 10 ] [ Difficulty ] , arabianMinefield ) ;
 301: LD_INT 1
 303: PPUSH
 304: LD_INT 6
 306: PUSH
 307: LD_INT 7
 309: PUSH
 310: LD_INT 9
 312: PUSH
 313: LD_INT 10
 315: PUSH
 316: EMPTY
 317: LIST
 318: LIST
 319: LIST
 320: LIST
 321: PUSH
 322: LD_OWVAR 67
 326: ARRAY
 327: PPUSH
 328: LD_INT 28
 330: PPUSH
 331: CALL 46667 0 3
// MC_SetLabKind ( 1 , [ b_lab_weapon , b_lab_siberium , b_lab_biological , b_lab_opto ] ) ;
 335: LD_INT 1
 337: PPUSH
 338: LD_INT 10
 340: PUSH
 341: LD_INT 11
 343: PUSH
 344: LD_INT 13
 346: PUSH
 347: LD_INT 15
 349: PUSH
 350: EMPTY
 351: LIST
 352: LIST
 353: LIST
 354: LIST
 355: PPUSH
 356: CALL 47746 0 2
// MC_SetCratesArea ( 1 , [ arabianCratesArea ] ) ;
 360: LD_INT 1
 362: PPUSH
 363: LD_INT 29
 365: PUSH
 366: EMPTY
 367: LIST
 368: PPUSH
 369: CALL 47839 0 2
// mc_ape := Replace ( mc_ape , 1 , FilterAllUnits ( [ [ f_side , 2 ] , [ f_class , class_apeman_soldier ] ] ) ) ;
 373: LD_ADDR_EXP 109
 377: PUSH
 378: LD_EXP 109
 382: PPUSH
 383: LD_INT 1
 385: PPUSH
 386: LD_INT 22
 388: PUSH
 389: LD_INT 2
 391: PUSH
 392: EMPTY
 393: LIST
 394: LIST
 395: PUSH
 396: LD_INT 25
 398: PUSH
 399: LD_INT 15
 401: PUSH
 402: EMPTY
 403: LIST
 404: LIST
 405: PUSH
 406: EMPTY
 407: LIST
 408: LIST
 409: PPUSH
 410: CALL_OW 69
 414: PPUSH
 415: CALL_OW 1
 419: ST_TO_ADDR
// MC_SetProduceList ( 1 , [ [ ar_medium_trike , engine_solar , control_manual , ar_control_tower ] , [ ar_medium_trike , engine_solar , control_manual , ar_control_tower ] , [ ar_medium_trike , engine_combustion , control_manual , ar_rocket_launcher ] , [ ar_medium_trike , engine_combustion , control_manual , ar_rocket_launcher ] , [ ar_medium_trike , engine_combustion , control_manual , ar_rocket_launcher ] , [ ar_medium_trike , engine_combustion , control_manual , ar_rocket_launcher ] , [ ar_medium_trike , engine_combustion , control_remote , ar_crane ] ] ) ;
 420: LD_INT 1
 422: PPUSH
 423: LD_INT 13
 425: PUSH
 426: LD_INT 2
 428: PUSH
 429: LD_INT 1
 431: PUSH
 432: LD_INT 31
 434: PUSH
 435: EMPTY
 436: LIST
 437: LIST
 438: LIST
 439: LIST
 440: PUSH
 441: LD_INT 13
 443: PUSH
 444: LD_INT 2
 446: PUSH
 447: LD_INT 1
 449: PUSH
 450: LD_INT 31
 452: PUSH
 453: EMPTY
 454: LIST
 455: LIST
 456: LIST
 457: LIST
 458: PUSH
 459: LD_INT 13
 461: PUSH
 462: LD_INT 1
 464: PUSH
 465: LD_INT 1
 467: PUSH
 468: LD_INT 28
 470: PUSH
 471: EMPTY
 472: LIST
 473: LIST
 474: LIST
 475: LIST
 476: PUSH
 477: LD_INT 13
 479: PUSH
 480: LD_INT 1
 482: PUSH
 483: LD_INT 1
 485: PUSH
 486: LD_INT 28
 488: PUSH
 489: EMPTY
 490: LIST
 491: LIST
 492: LIST
 493: LIST
 494: PUSH
 495: LD_INT 13
 497: PUSH
 498: LD_INT 1
 500: PUSH
 501: LD_INT 1
 503: PUSH
 504: LD_INT 28
 506: PUSH
 507: EMPTY
 508: LIST
 509: LIST
 510: LIST
 511: LIST
 512: PUSH
 513: LD_INT 13
 515: PUSH
 516: LD_INT 1
 518: PUSH
 519: LD_INT 1
 521: PUSH
 522: LD_INT 28
 524: PUSH
 525: EMPTY
 526: LIST
 527: LIST
 528: LIST
 529: LIST
 530: PUSH
 531: LD_INT 13
 533: PUSH
 534: LD_INT 1
 536: PUSH
 537: LD_INT 2
 539: PUSH
 540: LD_INT 88
 542: PUSH
 543: EMPTY
 544: LIST
 545: LIST
 546: LIST
 547: LIST
 548: PUSH
 549: EMPTY
 550: LIST
 551: LIST
 552: LIST
 553: LIST
 554: LIST
 555: LIST
 556: LIST
 557: PPUSH
 558: CALL 47004 0 2
// MC_SetDefenderLimit ( 1 , 4 ) ;
 562: LD_INT 1
 564: PPUSH
 565: LD_INT 4
 567: PPUSH
 568: CALL 47189 0 2
// MC_SetLabKind ( 2 , [ b_lab_weapon , b_lab_siberium , b_lab_computer , b_lab_spacetime ] ) ;
 572: LD_INT 2
 574: PPUSH
 575: LD_INT 10
 577: PUSH
 578: LD_INT 11
 580: PUSH
 581: LD_INT 12
 583: PUSH
 584: LD_INT 14
 586: PUSH
 587: EMPTY
 588: LIST
 589: LIST
 590: LIST
 591: LIST
 592: PPUSH
 593: CALL 47746 0 2
// MC_SetCratesArea ( 2 , [ russianCratesArea ] ) ;
 597: LD_INT 2
 599: PPUSH
 600: LD_INT 14
 602: PUSH
 603: EMPTY
 604: LIST
 605: PPUSH
 606: CALL 47839 0 2
// MC_SetProduceList ( 2 , [ [ ru_medium_wheeled , engine_siberite , control_computer , ru_cargo_bay ] , [ ru_medium_tracked , engine_siberite , control_computer , ru_crane ] , [ ru_medium_tracked , engine_siberite , control_computer , ru_crane ] , [ ru_heavy_tracked , engine_siberite , control_computer , ru_rocket ] , [ ru_heavy_tracked , engine_siberite , control_computer , ru_rocket ] , [ ru_heavy_tracked , engine_siberite , control_computer , ru_rocket ] , [ ru_heavy_tracked , engine_siberite , control_computer , ru_rocket ] , [ ru_heavy_tracked , engine_siberite , control_computer , ru_rocket ] ] ) ;
 610: LD_INT 2
 612: PPUSH
 613: LD_INT 21
 615: PUSH
 616: LD_INT 3
 618: PUSH
 619: LD_INT 3
 621: PUSH
 622: LD_INT 51
 624: PUSH
 625: EMPTY
 626: LIST
 627: LIST
 628: LIST
 629: LIST
 630: PUSH
 631: LD_INT 22
 633: PUSH
 634: LD_INT 3
 636: PUSH
 637: LD_INT 3
 639: PUSH
 640: LD_INT 52
 642: PUSH
 643: EMPTY
 644: LIST
 645: LIST
 646: LIST
 647: LIST
 648: PUSH
 649: LD_INT 22
 651: PUSH
 652: LD_INT 3
 654: PUSH
 655: LD_INT 3
 657: PUSH
 658: LD_INT 52
 660: PUSH
 661: EMPTY
 662: LIST
 663: LIST
 664: LIST
 665: LIST
 666: PUSH
 667: LD_INT 24
 669: PUSH
 670: LD_INT 3
 672: PUSH
 673: LD_INT 3
 675: PUSH
 676: LD_INT 47
 678: PUSH
 679: EMPTY
 680: LIST
 681: LIST
 682: LIST
 683: LIST
 684: PUSH
 685: LD_INT 24
 687: PUSH
 688: LD_INT 3
 690: PUSH
 691: LD_INT 3
 693: PUSH
 694: LD_INT 47
 696: PUSH
 697: EMPTY
 698: LIST
 699: LIST
 700: LIST
 701: LIST
 702: PUSH
 703: LD_INT 24
 705: PUSH
 706: LD_INT 3
 708: PUSH
 709: LD_INT 3
 711: PUSH
 712: LD_INT 47
 714: PUSH
 715: EMPTY
 716: LIST
 717: LIST
 718: LIST
 719: LIST
 720: PUSH
 721: LD_INT 24
 723: PUSH
 724: LD_INT 3
 726: PUSH
 727: LD_INT 3
 729: PUSH
 730: LD_INT 47
 732: PUSH
 733: EMPTY
 734: LIST
 735: LIST
 736: LIST
 737: LIST
 738: PUSH
 739: LD_INT 24
 741: PUSH
 742: LD_INT 3
 744: PUSH
 745: LD_INT 3
 747: PUSH
 748: LD_INT 47
 750: PUSH
 751: EMPTY
 752: LIST
 753: LIST
 754: LIST
 755: LIST
 756: PUSH
 757: EMPTY
 758: LIST
 759: LIST
 760: LIST
 761: LIST
 762: LIST
 763: LIST
 764: LIST
 765: LIST
 766: PPUSH
 767: CALL 47004 0 2
// MC_SetDefenderLimit ( 2 , 5 ) ;
 771: LD_INT 2
 773: PPUSH
 774: LD_INT 5
 776: PPUSH
 777: CALL 47189 0 2
// MC_SetUpgradeBuilding ( 2 , b_depot ) ;
 781: LD_INT 2
 783: PPUSH
 784: LD_INT 0
 786: PPUSH
 787: CALL 47619 0 2
// MC_SetMinesField ( 3 , [ 10 , 12 , 14 , 15 ] [ Difficulty ] , legionMinefield ) ;
 791: LD_INT 3
 793: PPUSH
 794: LD_INT 10
 796: PUSH
 797: LD_INT 12
 799: PUSH
 800: LD_INT 14
 802: PUSH
 803: LD_INT 15
 805: PUSH
 806: EMPTY
 807: LIST
 808: LIST
 809: LIST
 810: LIST
 811: PUSH
 812: LD_OWVAR 67
 816: ARRAY
 817: PPUSH
 818: LD_INT 24
 820: PPUSH
 821: CALL 46667 0 3
// MC_SetLabKind ( 3 , [ b_lab_weapon , b_lab_siberium , b_lab_biological , b_lab_opto ] ) ;
 825: LD_INT 3
 827: PPUSH
 828: LD_INT 10
 830: PUSH
 831: LD_INT 11
 833: PUSH
 834: LD_INT 13
 836: PUSH
 837: LD_INT 15
 839: PUSH
 840: EMPTY
 841: LIST
 842: LIST
 843: LIST
 844: LIST
 845: PPUSH
 846: CALL 47746 0 2
// MC_SetCratesArea ( 3 , [ legionCratesArea ] ) ;
 850: LD_INT 3
 852: PPUSH
 853: LD_INT 13
 855: PUSH
 856: EMPTY
 857: LIST
 858: PPUSH
 859: CALL 47839 0 2
// mc_ape := Replace ( mc_ape , 3 , FilterAllUnits ( [ [ f_side , 8 ] , [ f_class , class_apeman_soldier ] ] ) ) ;
 863: LD_ADDR_EXP 109
 867: PUSH
 868: LD_EXP 109
 872: PPUSH
 873: LD_INT 3
 875: PPUSH
 876: LD_INT 22
 878: PUSH
 879: LD_INT 8
 881: PUSH
 882: EMPTY
 883: LIST
 884: LIST
 885: PUSH
 886: LD_INT 25
 888: PUSH
 889: LD_INT 15
 891: PUSH
 892: EMPTY
 893: LIST
 894: LIST
 895: PUSH
 896: EMPTY
 897: LIST
 898: LIST
 899: PPUSH
 900: CALL_OW 69
 904: PPUSH
 905: CALL_OW 1
 909: ST_TO_ADDR
// MC_SetProduceList ( 3 , [ [ ar_medium_trike , engine_solar , control_manual , ar_control_tower ] , [ ar_medium_trike , engine_solar , control_manual , ar_control_tower ] , [ ar_medium_trike , engine_siberite , control_remote , ar_cargo_bay ] , [ ar_half_tracked , engine_combustion , control_manual , ar_rocket_launcher ] , [ ar_half_tracked , engine_combustion , control_manual , ar_rocket_launcher ] , [ ar_half_tracked , engine_combustion , control_manual , ar_rocket_launcher ] , [ ar_half_tracked , engine_combustion , control_manual , ar_rocket_launcher ] , [ ar_half_tracked , engine_combustion , control_remote , ar_crane ] ] ) ;
 910: LD_INT 3
 912: PPUSH
 913: LD_INT 13
 915: PUSH
 916: LD_INT 2
 918: PUSH
 919: LD_INT 1
 921: PUSH
 922: LD_INT 31
 924: PUSH
 925: EMPTY
 926: LIST
 927: LIST
 928: LIST
 929: LIST
 930: PUSH
 931: LD_INT 13
 933: PUSH
 934: LD_INT 2
 936: PUSH
 937: LD_INT 1
 939: PUSH
 940: LD_INT 31
 942: PUSH
 943: EMPTY
 944: LIST
 945: LIST
 946: LIST
 947: LIST
 948: PUSH
 949: LD_INT 13
 951: PUSH
 952: LD_INT 3
 954: PUSH
 955: LD_INT 2
 957: PUSH
 958: LD_INT 32
 960: PUSH
 961: EMPTY
 962: LIST
 963: LIST
 964: LIST
 965: LIST
 966: PUSH
 967: LD_INT 14
 969: PUSH
 970: LD_INT 1
 972: PUSH
 973: LD_INT 1
 975: PUSH
 976: LD_INT 28
 978: PUSH
 979: EMPTY
 980: LIST
 981: LIST
 982: LIST
 983: LIST
 984: PUSH
 985: LD_INT 14
 987: PUSH
 988: LD_INT 1
 990: PUSH
 991: LD_INT 1
 993: PUSH
 994: LD_INT 28
 996: PUSH
 997: EMPTY
 998: LIST
 999: LIST
1000: LIST
1001: LIST
1002: PUSH
1003: LD_INT 14
1005: PUSH
1006: LD_INT 1
1008: PUSH
1009: LD_INT 1
1011: PUSH
1012: LD_INT 28
1014: PUSH
1015: EMPTY
1016: LIST
1017: LIST
1018: LIST
1019: LIST
1020: PUSH
1021: LD_INT 14
1023: PUSH
1024: LD_INT 1
1026: PUSH
1027: LD_INT 1
1029: PUSH
1030: LD_INT 28
1032: PUSH
1033: EMPTY
1034: LIST
1035: LIST
1036: LIST
1037: LIST
1038: PUSH
1039: LD_INT 14
1041: PUSH
1042: LD_INT 1
1044: PUSH
1045: LD_INT 2
1047: PUSH
1048: LD_INT 88
1050: PUSH
1051: EMPTY
1052: LIST
1053: LIST
1054: LIST
1055: LIST
1056: PUSH
1057: EMPTY
1058: LIST
1059: LIST
1060: LIST
1061: LIST
1062: LIST
1063: LIST
1064: LIST
1065: LIST
1066: PPUSH
1067: CALL 47004 0 2
// MC_SetDefenderLimit ( 3 , 4 ) ;
1071: LD_INT 3
1073: PPUSH
1074: LD_INT 4
1076: PPUSH
1077: CALL 47189 0 2
// MC_SetLabKind ( 4 , [ b_lab_weapon , b_lab_computer , b_lab_siberium , b_lab_opto ] ) ;
1081: LD_INT 4
1083: PPUSH
1084: LD_INT 10
1086: PUSH
1087: LD_INT 12
1089: PUSH
1090: LD_INT 11
1092: PUSH
1093: LD_INT 15
1095: PUSH
1096: EMPTY
1097: LIST
1098: LIST
1099: LIST
1100: LIST
1101: PPUSH
1102: CALL 47746 0 2
// MC_SetCratesArea ( 4 , [ americanCratesArea ] ) ;
1106: LD_INT 4
1108: PPUSH
1109: LD_INT 33
1111: PUSH
1112: EMPTY
1113: LIST
1114: PPUSH
1115: CALL 47839 0 2
// MC_SetAllowedTurretWeapons ( 4 , [ us_double_gun , us_heavy_gun , us_rocket_launcher , us_laser , us_double_laser ] ) ;
1119: LD_INT 4
1121: PPUSH
1122: LD_INT 5
1124: PUSH
1125: LD_INT 6
1127: PUSH
1128: LD_INT 7
1130: PUSH
1131: LD_INT 9
1133: PUSH
1134: LD_INT 10
1136: PUSH
1137: EMPTY
1138: LIST
1139: LIST
1140: LIST
1141: LIST
1142: LIST
1143: PPUSH
1144: CALL 48157 0 2
// MC_SetFactoryExtension ( 4 , 54 , 85 , 2 , [ b_ext_laser , b_ext_track , b_ext_gun , b_ext_rocket , b_ext_radio ] ) ;
1148: LD_INT 4
1150: PPUSH
1151: LD_INT 54
1153: PPUSH
1154: LD_INT 85
1156: PPUSH
1157: LD_INT 2
1159: PPUSH
1160: LD_INT 25
1162: PUSH
1163: LD_INT 16
1165: PUSH
1166: LD_INT 17
1168: PUSH
1169: LD_INT 18
1171: PUSH
1172: LD_INT 22
1174: PUSH
1175: EMPTY
1176: LIST
1177: LIST
1178: LIST
1179: LIST
1180: LIST
1181: PPUSH
1182: CALL 47951 0 5
// MC_SetProduceList ( 4 , [ [ us_morphling , engine_combustion , control_manual , us_rocket_launcher ] , [ us_morphling , engine_combustion , control_manual , us_heavy_gun ] , [ us_morphling , engine_combustion , control_manual , us_rocket_launcher ] , [ us_morphling , engine_combustion , control_manual , us_heavy_gun ] , [ us_morphling , engine_combustion , control_computer , us_cargo_bay ] , [ us_medium_tracked , engine_combustion , control_computer , us_crane ] ] ) ;
1186: LD_INT 4
1188: PPUSH
1189: LD_INT 5
1191: PUSH
1192: LD_INT 1
1194: PUSH
1195: LD_INT 1
1197: PUSH
1198: LD_INT 7
1200: PUSH
1201: EMPTY
1202: LIST
1203: LIST
1204: LIST
1205: LIST
1206: PUSH
1207: LD_INT 5
1209: PUSH
1210: LD_INT 1
1212: PUSH
1213: LD_INT 1
1215: PUSH
1216: LD_INT 6
1218: PUSH
1219: EMPTY
1220: LIST
1221: LIST
1222: LIST
1223: LIST
1224: PUSH
1225: LD_INT 5
1227: PUSH
1228: LD_INT 1
1230: PUSH
1231: LD_INT 1
1233: PUSH
1234: LD_INT 7
1236: PUSH
1237: EMPTY
1238: LIST
1239: LIST
1240: LIST
1241: LIST
1242: PUSH
1243: LD_INT 5
1245: PUSH
1246: LD_INT 1
1248: PUSH
1249: LD_INT 1
1251: PUSH
1252: LD_INT 6
1254: PUSH
1255: EMPTY
1256: LIST
1257: LIST
1258: LIST
1259: LIST
1260: PUSH
1261: LD_INT 5
1263: PUSH
1264: LD_INT 1
1266: PUSH
1267: LD_INT 3
1269: PUSH
1270: LD_INT 12
1272: PUSH
1273: EMPTY
1274: LIST
1275: LIST
1276: LIST
1277: LIST
1278: PUSH
1279: LD_INT 3
1281: PUSH
1282: LD_INT 1
1284: PUSH
1285: LD_INT 3
1287: PUSH
1288: LD_INT 13
1290: PUSH
1291: EMPTY
1292: LIST
1293: LIST
1294: LIST
1295: LIST
1296: PUSH
1297: EMPTY
1298: LIST
1299: LIST
1300: LIST
1301: LIST
1302: LIST
1303: LIST
1304: PPUSH
1305: CALL 47004 0 2
// MC_SetDefenderLimit ( 4 , 4 ) ;
1309: LD_INT 4
1311: PPUSH
1312: LD_INT 4
1314: PPUSH
1315: CALL 47189 0 2
// MC_SetTame ( 4 , powellApe ) ;
1319: LD_INT 4
1321: PPUSH
1322: LD_INT 11
1324: PPUSH
1325: CALL 47570 0 2
// end ;
1329: LD_VAR 0 1
1333: RET
// every 0 0$1 trigger debug do var i ;
1334: LD_EXP 1
1338: IFFALSE 1436
1340: GO 1342
1342: DISABLE
1343: LD_INT 0
1345: PPUSH
// begin enable ;
1346: ENABLE
// for i in FilterAllUnits ( [ [ f_side , 7 ] , [ f_or , [ f_type , unit_human ] , [ f_type , unit_vehicle ] ] , [ f_not , [ f_lives , 1000 ] ] ] ) do
1347: LD_ADDR_VAR 0 1
1351: PUSH
1352: LD_INT 22
1354: PUSH
1355: LD_INT 7
1357: PUSH
1358: EMPTY
1359: LIST
1360: LIST
1361: PUSH
1362: LD_INT 2
1364: PUSH
1365: LD_INT 21
1367: PUSH
1368: LD_INT 1
1370: PUSH
1371: EMPTY
1372: LIST
1373: LIST
1374: PUSH
1375: LD_INT 21
1377: PUSH
1378: LD_INT 2
1380: PUSH
1381: EMPTY
1382: LIST
1383: LIST
1384: PUSH
1385: EMPTY
1386: LIST
1387: LIST
1388: LIST
1389: PUSH
1390: LD_INT 3
1392: PUSH
1393: LD_INT 24
1395: PUSH
1396: LD_INT 1000
1398: PUSH
1399: EMPTY
1400: LIST
1401: LIST
1402: PUSH
1403: EMPTY
1404: LIST
1405: LIST
1406: PUSH
1407: EMPTY
1408: LIST
1409: LIST
1410: LIST
1411: PPUSH
1412: CALL_OW 69
1416: PUSH
1417: FOR_IN
1418: IFFALSE 1434
// SetLives ( i , 1000 ) ;
1420: LD_VAR 0 1
1424: PPUSH
1425: LD_INT 1000
1427: PPUSH
1428: CALL_OW 234
1432: GO 1417
1434: POP
1435: POP
// end ;
1436: PPOPN 1
1438: END
// every 0 0$1 trigger artifactDestroyCounter >= 5 do
1439: LD_EXP 16
1443: PUSH
1444: LD_INT 5
1446: GREATEREQUAL
1447: IFFALSE 1459
1449: GO 1451
1451: DISABLE
// SetAchievement ( ACH_ARTIFACT ) ; end_of_file
1452: LD_STRING ACH_ARTIFACT
1454: PPUSH
1455: CALL_OW 543
1459: END
// export JMM , Roth , Lisa , Donaldson , Bobby , Cyrus , Denis , Brown , Gladstone , Houten , Cornel , Gary , Frank , Kikuchi , Simms , Joan , DeltaDoctor , Connie , Mike ; export Gossudarov , Kirilenkova , Titov , Fadeev , Dolgov , Petrosyan , Scholtze , Oblukov , Kapitsova , Lipshchin , Petrovova , Kovalyuk , Kuzmov , Karamazov ; export Burlak , Belkov , Gnyevko ; export function PrepareAlliance ; var i , veh , selected , tmp ; begin
1460: LD_INT 0
1462: PPUSH
1463: PPUSH
1464: PPUSH
1465: PPUSH
1466: PPUSH
// SetInvulnrability ( alien , true ) ;
1467: LD_INT 1
1469: PPUSH
1470: LD_INT 1
1472: PPUSH
1473: CALL_OW 607
// uc_side := 7 ;
1477: LD_ADDR_OWVAR 20
1481: PUSH
1482: LD_INT 7
1484: ST_TO_ADDR
// tmp := [ ] ;
1485: LD_ADDR_VAR 0 5
1489: PUSH
1490: EMPTY
1491: ST_TO_ADDR
// JMM := PrepareUnit ( JMM , ( not debug ) , 14a_ ) ;
1492: LD_ADDR_EXP 21
1496: PUSH
1497: LD_STRING JMM
1499: PPUSH
1500: LD_EXP 1
1504: NOT
1505: PPUSH
1506: LD_STRING 14a_
1508: PPUSH
1509: CALL 53478 0 3
1513: ST_TO_ADDR
// Burlak := PrepareUnit ( Burlak , ( not debug ) , 14a_ ) ;
1514: LD_ADDR_EXP 54
1518: PUSH
1519: LD_STRING Burlak
1521: PPUSH
1522: LD_EXP 1
1526: NOT
1527: PPUSH
1528: LD_STRING 14a_
1530: PPUSH
1531: CALL 53478 0 3
1535: ST_TO_ADDR
// Joan := PrepareUnit ( Joan , ( not debug ) , 13a_ ) ;
1536: LD_ADDR_EXP 36
1540: PUSH
1541: LD_STRING Joan
1543: PPUSH
1544: LD_EXP 1
1548: NOT
1549: PPUSH
1550: LD_STRING 13a_
1552: PPUSH
1553: CALL 53478 0 3
1557: ST_TO_ADDR
// Roth := PrepareUnit ( Roth , ( not debug ) , 13a_ ) ;
1558: LD_ADDR_EXP 22
1562: PUSH
1563: LD_STRING Roth
1565: PPUSH
1566: LD_EXP 1
1570: NOT
1571: PPUSH
1572: LD_STRING 13a_
1574: PPUSH
1575: CALL 53478 0 3
1579: ST_TO_ADDR
// Gossudarov := PrepareUnit ( Gossudarov , ( not debug ) , 13a_ ) ;
1580: LD_ADDR_EXP 40
1584: PUSH
1585: LD_STRING Gossudarov
1587: PPUSH
1588: LD_EXP 1
1592: NOT
1593: PPUSH
1594: LD_STRING 13a_
1596: PPUSH
1597: CALL 53478 0 3
1601: ST_TO_ADDR
// Denis := PrepareUnit ( Denis , ( not debug ) , 13a_ ) ;
1602: LD_ADDR_EXP 27
1606: PUSH
1607: LD_STRING Denis
1609: PPUSH
1610: LD_EXP 1
1614: NOT
1615: PPUSH
1616: LD_STRING 13a_
1618: PPUSH
1619: CALL 53478 0 3
1623: ST_TO_ADDR
// DeltaDoctor := PrepareUnit ( DeltaDoctor , ( not debug ) , 13a_ ) ;
1624: LD_ADDR_EXP 37
1628: PUSH
1629: LD_STRING DeltaDoctor
1631: PPUSH
1632: LD_EXP 1
1636: NOT
1637: PPUSH
1638: LD_STRING 13a_
1640: PPUSH
1641: CALL 53478 0 3
1645: ST_TO_ADDR
// Mike := PrepareUnit ( Mike , ( not debug ) , 13a_ ) ;
1646: LD_ADDR_EXP 39
1650: PUSH
1651: LD_STRING Mike
1653: PPUSH
1654: LD_EXP 1
1658: NOT
1659: PPUSH
1660: LD_STRING 13a_
1662: PPUSH
1663: CALL 53478 0 3
1667: ST_TO_ADDR
// if DeltaDoctor then
1668: LD_EXP 37
1672: IFFALSE 1690
// tmp := tmp ^ DeltaDoctor ;
1674: LD_ADDR_VAR 0 5
1678: PUSH
1679: LD_VAR 0 5
1683: PUSH
1684: LD_EXP 37
1688: ADD
1689: ST_TO_ADDR
// Simms := PrepareUnit ( Simms , ( not debug ) , 13a_ ) ;
1690: LD_ADDR_EXP 35
1694: PUSH
1695: LD_STRING Simms
1697: PPUSH
1698: LD_EXP 1
1702: NOT
1703: PPUSH
1704: LD_STRING 13a_
1706: PPUSH
1707: CALL 53478 0 3
1711: ST_TO_ADDR
// if Simms then
1712: LD_EXP 35
1716: IFFALSE 1734
// tmp := tmp ^ Simms ;
1718: LD_ADDR_VAR 0 5
1722: PUSH
1723: LD_VAR 0 5
1727: PUSH
1728: LD_EXP 35
1732: ADD
1733: ST_TO_ADDR
// Frank := PrepareUnit ( Frank , ( not debug ) , 13a_ ) ;
1734: LD_ADDR_EXP 33
1738: PUSH
1739: LD_STRING Frank
1741: PPUSH
1742: LD_EXP 1
1746: NOT
1747: PPUSH
1748: LD_STRING 13a_
1750: PPUSH
1751: CALL 53478 0 3
1755: ST_TO_ADDR
// if Frank then
1756: LD_EXP 33
1760: IFFALSE 1778
// tmp := tmp ^ Frank ;
1762: LD_ADDR_VAR 0 5
1766: PUSH
1767: LD_VAR 0 5
1771: PUSH
1772: LD_EXP 33
1776: ADD
1777: ST_TO_ADDR
// Kirilenkova := PrepareUnit ( Kirilenkova , ( not debug ) , 13a_ ) ;
1778: LD_ADDR_EXP 41
1782: PUSH
1783: LD_STRING Kirilenkova
1785: PPUSH
1786: LD_EXP 1
1790: NOT
1791: PPUSH
1792: LD_STRING 13a_
1794: PPUSH
1795: CALL 53478 0 3
1799: ST_TO_ADDR
// if Kirilenkova then
1800: LD_EXP 41
1804: IFFALSE 1822
// tmp := tmp ^ Kirilenkova ;
1806: LD_ADDR_VAR 0 5
1810: PUSH
1811: LD_VAR 0 5
1815: PUSH
1816: LD_EXP 41
1820: ADD
1821: ST_TO_ADDR
// Titov := PrepareUnit ( Titov , ( not debug ) , 13a_ ) ;
1822: LD_ADDR_EXP 42
1826: PUSH
1827: LD_STRING Titov
1829: PPUSH
1830: LD_EXP 1
1834: NOT
1835: PPUSH
1836: LD_STRING 13a_
1838: PPUSH
1839: CALL 53478 0 3
1843: ST_TO_ADDR
// if Titov then
1844: LD_EXP 42
1848: IFFALSE 1866
// tmp := tmp ^ Titov ;
1850: LD_ADDR_VAR 0 5
1854: PUSH
1855: LD_VAR 0 5
1859: PUSH
1860: LD_EXP 42
1864: ADD
1865: ST_TO_ADDR
// Fadeev := PrepareUnit ( Fadeev , ( not debug ) , 13a_ ) ;
1866: LD_ADDR_EXP 43
1870: PUSH
1871: LD_STRING Fadeev
1873: PPUSH
1874: LD_EXP 1
1878: NOT
1879: PPUSH
1880: LD_STRING 13a_
1882: PPUSH
1883: CALL 53478 0 3
1887: ST_TO_ADDR
// if Fadeev then
1888: LD_EXP 43
1892: IFFALSE 1910
// tmp := tmp ^ Fadeev ;
1894: LD_ADDR_VAR 0 5
1898: PUSH
1899: LD_VAR 0 5
1903: PUSH
1904: LD_EXP 43
1908: ADD
1909: ST_TO_ADDR
// Dolgov := PrepareUnit ( Dolgov , ( not debug ) , 13a_ ) ;
1910: LD_ADDR_EXP 44
1914: PUSH
1915: LD_STRING Dolgov
1917: PPUSH
1918: LD_EXP 1
1922: NOT
1923: PPUSH
1924: LD_STRING 13a_
1926: PPUSH
1927: CALL 53478 0 3
1931: ST_TO_ADDR
// if Dolgov then
1932: LD_EXP 44
1936: IFFALSE 1954
// tmp := tmp ^ Dolgov ;
1938: LD_ADDR_VAR 0 5
1942: PUSH
1943: LD_VAR 0 5
1947: PUSH
1948: LD_EXP 44
1952: ADD
1953: ST_TO_ADDR
// Petrosyan := PrepareUnit ( Petrosyan , ( not debug ) , 13a_ ) ;
1954: LD_ADDR_EXP 45
1958: PUSH
1959: LD_STRING Petrosyan
1961: PPUSH
1962: LD_EXP 1
1966: NOT
1967: PPUSH
1968: LD_STRING 13a_
1970: PPUSH
1971: CALL 53478 0 3
1975: ST_TO_ADDR
// if Petrosyan then
1976: LD_EXP 45
1980: IFFALSE 1998
// tmp := tmp ^ Petrosyan ;
1982: LD_ADDR_VAR 0 5
1986: PUSH
1987: LD_VAR 0 5
1991: PUSH
1992: LD_EXP 45
1996: ADD
1997: ST_TO_ADDR
// Scholtze := PrepareUnit ( Scholtze , ( not debug ) , 13a_ ) ;
1998: LD_ADDR_EXP 46
2002: PUSH
2003: LD_STRING Scholtze
2005: PPUSH
2006: LD_EXP 1
2010: NOT
2011: PPUSH
2012: LD_STRING 13a_
2014: PPUSH
2015: CALL 53478 0 3
2019: ST_TO_ADDR
// if Scholtze then
2020: LD_EXP 46
2024: IFFALSE 2042
// tmp := tmp ^ Scholtze ;
2026: LD_ADDR_VAR 0 5
2030: PUSH
2031: LD_VAR 0 5
2035: PUSH
2036: LD_EXP 46
2040: ADD
2041: ST_TO_ADDR
// Oblukov := PrepareUnit ( Oblukov , ( not debug ) , 13a_ ) ;
2042: LD_ADDR_EXP 47
2046: PUSH
2047: LD_STRING Oblukov
2049: PPUSH
2050: LD_EXP 1
2054: NOT
2055: PPUSH
2056: LD_STRING 13a_
2058: PPUSH
2059: CALL 53478 0 3
2063: ST_TO_ADDR
// if Oblukov then
2064: LD_EXP 47
2068: IFFALSE 2086
// tmp := tmp ^ Oblukov ;
2070: LD_ADDR_VAR 0 5
2074: PUSH
2075: LD_VAR 0 5
2079: PUSH
2080: LD_EXP 47
2084: ADD
2085: ST_TO_ADDR
// Kapitsova := PrepareUnit ( Kapitsova , ( not debug ) , 13a_ ) ;
2086: LD_ADDR_EXP 48
2090: PUSH
2091: LD_STRING Kapitsova
2093: PPUSH
2094: LD_EXP 1
2098: NOT
2099: PPUSH
2100: LD_STRING 13a_
2102: PPUSH
2103: CALL 53478 0 3
2107: ST_TO_ADDR
// if Kapitsova then
2108: LD_EXP 48
2112: IFFALSE 2130
// tmp := tmp ^ Kapitsova ;
2114: LD_ADDR_VAR 0 5
2118: PUSH
2119: LD_VAR 0 5
2123: PUSH
2124: LD_EXP 48
2128: ADD
2129: ST_TO_ADDR
// Lipshchin := PrepareUnit ( Lipshchin , ( not debug ) , 13a_ ) ;
2130: LD_ADDR_EXP 49
2134: PUSH
2135: LD_STRING Lipshchin
2137: PPUSH
2138: LD_EXP 1
2142: NOT
2143: PPUSH
2144: LD_STRING 13a_
2146: PPUSH
2147: CALL 53478 0 3
2151: ST_TO_ADDR
// if Lipshchin then
2152: LD_EXP 49
2156: IFFALSE 2174
// tmp := tmp ^ Lipshchin ;
2158: LD_ADDR_VAR 0 5
2162: PUSH
2163: LD_VAR 0 5
2167: PUSH
2168: LD_EXP 49
2172: ADD
2173: ST_TO_ADDR
// Petrovova := PrepareUnit ( Petrovova , ( not debug ) , 13a_ ) ;
2174: LD_ADDR_EXP 50
2178: PUSH
2179: LD_STRING Petrovova
2181: PPUSH
2182: LD_EXP 1
2186: NOT
2187: PPUSH
2188: LD_STRING 13a_
2190: PPUSH
2191: CALL 53478 0 3
2195: ST_TO_ADDR
// if Petrovova then
2196: LD_EXP 50
2200: IFFALSE 2218
// tmp := tmp ^ Petrovova ;
2202: LD_ADDR_VAR 0 5
2206: PUSH
2207: LD_VAR 0 5
2211: PUSH
2212: LD_EXP 50
2216: ADD
2217: ST_TO_ADDR
// Kovalyuk := PrepareUnit ( Kovalyuk , ( not debug ) , 13a_ ) ;
2218: LD_ADDR_EXP 51
2222: PUSH
2223: LD_STRING Kovalyuk
2225: PPUSH
2226: LD_EXP 1
2230: NOT
2231: PPUSH
2232: LD_STRING 13a_
2234: PPUSH
2235: CALL 53478 0 3
2239: ST_TO_ADDR
// if Kovalyuk then
2240: LD_EXP 51
2244: IFFALSE 2262
// tmp := tmp ^ Kovalyuk ;
2246: LD_ADDR_VAR 0 5
2250: PUSH
2251: LD_VAR 0 5
2255: PUSH
2256: LD_EXP 51
2260: ADD
2261: ST_TO_ADDR
// Kuzmov := PrepareUnit ( Kuzmov , ( not debug ) , 13a_ ) ;
2262: LD_ADDR_EXP 52
2266: PUSH
2267: LD_STRING Kuzmov
2269: PPUSH
2270: LD_EXP 1
2274: NOT
2275: PPUSH
2276: LD_STRING 13a_
2278: PPUSH
2279: CALL 53478 0 3
2283: ST_TO_ADDR
// if Kuzmov then
2284: LD_EXP 52
2288: IFFALSE 2306
// tmp := tmp ^ Kuzmov ;
2290: LD_ADDR_VAR 0 5
2294: PUSH
2295: LD_VAR 0 5
2299: PUSH
2300: LD_EXP 52
2304: ADD
2305: ST_TO_ADDR
// Karamazov := PrepareUnit ( Karamazov , ( not debug ) , 13a_ ) ;
2306: LD_ADDR_EXP 53
2310: PUSH
2311: LD_STRING Karamazov
2313: PPUSH
2314: LD_EXP 1
2318: NOT
2319: PPUSH
2320: LD_STRING 13a_
2322: PPUSH
2323: CALL 53478 0 3
2327: ST_TO_ADDR
// if Karamazov then
2328: LD_EXP 53
2332: IFFALSE 2350
// tmp := tmp ^ Karamazov ;
2334: LD_ADDR_VAR 0 5
2338: PUSH
2339: LD_VAR 0 5
2343: PUSH
2344: LD_EXP 53
2348: ADD
2349: ST_TO_ADDR
// Belkov := PrepareUnit ( Belkov , ( not debug ) , 13a_ ) ;
2350: LD_ADDR_EXP 55
2354: PUSH
2355: LD_STRING Belkov
2357: PPUSH
2358: LD_EXP 1
2362: NOT
2363: PPUSH
2364: LD_STRING 13a_
2366: PPUSH
2367: CALL 53478 0 3
2371: ST_TO_ADDR
// if Belkov then
2372: LD_EXP 55
2376: IFFALSE 2394
// tmp := tmp ^ Belkov ;
2378: LD_ADDR_VAR 0 5
2382: PUSH
2383: LD_VAR 0 5
2387: PUSH
2388: LD_EXP 55
2392: ADD
2393: ST_TO_ADDR
// Gnyevko := PrepareUnit ( Gnyevko , ( not debug ) , 13a_ ) ;
2394: LD_ADDR_EXP 56
2398: PUSH
2399: LD_STRING Gnyevko
2401: PPUSH
2402: LD_EXP 1
2406: NOT
2407: PPUSH
2408: LD_STRING 13a_
2410: PPUSH
2411: CALL 53478 0 3
2415: ST_TO_ADDR
// if Gnyevko then
2416: LD_EXP 56
2420: IFFALSE 2438
// tmp := tmp ^ Gnyevko ;
2422: LD_ADDR_VAR 0 5
2426: PUSH
2427: LD_VAR 0 5
2431: PUSH
2432: LD_EXP 56
2436: ADD
2437: ST_TO_ADDR
// Connie := NewCharacter ( Coonie ) ;
2438: LD_ADDR_EXP 38
2442: PUSH
2443: LD_STRING Coonie
2445: PPUSH
2446: CALL_OW 25
2450: ST_TO_ADDR
// if not Lisa then
2451: LD_EXP 23
2455: NOT
2456: IFFALSE 2502
// begin Lisa := PrepareUnit ( Lisa , ( not debug ) , 13a_ ) ;
2458: LD_ADDR_EXP 23
2462: PUSH
2463: LD_STRING Lisa
2465: PPUSH
2466: LD_EXP 1
2470: NOT
2471: PPUSH
2472: LD_STRING 13a_
2474: PPUSH
2475: CALL 53478 0 3
2479: ST_TO_ADDR
// if Lisa then
2480: LD_EXP 23
2484: IFFALSE 2502
// tmp := tmp ^ Lisa ;
2486: LD_ADDR_VAR 0 5
2490: PUSH
2491: LD_VAR 0 5
2495: PUSH
2496: LD_EXP 23
2500: ADD
2501: ST_TO_ADDR
// end ; if not Donaldson then
2502: LD_EXP 24
2506: NOT
2507: IFFALSE 2553
// begin Donaldson := PrepareUnit ( Donaldson , ( not debug ) , 13a_ ) ;
2509: LD_ADDR_EXP 24
2513: PUSH
2514: LD_STRING Donaldson
2516: PPUSH
2517: LD_EXP 1
2521: NOT
2522: PPUSH
2523: LD_STRING 13a_
2525: PPUSH
2526: CALL 53478 0 3
2530: ST_TO_ADDR
// if Donaldson then
2531: LD_EXP 24
2535: IFFALSE 2553
// tmp := tmp ^ Donaldson ;
2537: LD_ADDR_VAR 0 5
2541: PUSH
2542: LD_VAR 0 5
2546: PUSH
2547: LD_EXP 24
2551: ADD
2552: ST_TO_ADDR
// end ; if not Bobby then
2553: LD_EXP 25
2557: NOT
2558: IFFALSE 2604
// begin Bobby := PrepareUnit ( Bobby , ( not debug ) , 13a_ ) ;
2560: LD_ADDR_EXP 25
2564: PUSH
2565: LD_STRING Bobby
2567: PPUSH
2568: LD_EXP 1
2572: NOT
2573: PPUSH
2574: LD_STRING 13a_
2576: PPUSH
2577: CALL 53478 0 3
2581: ST_TO_ADDR
// if Bobby then
2582: LD_EXP 25
2586: IFFALSE 2604
// tmp := tmp ^ Bobby ;
2588: LD_ADDR_VAR 0 5
2592: PUSH
2593: LD_VAR 0 5
2597: PUSH
2598: LD_EXP 25
2602: ADD
2603: ST_TO_ADDR
// end ; if not Cyrus then
2604: LD_EXP 26
2608: NOT
2609: IFFALSE 2655
// begin Cyrus := PrepareUnit ( Cyrus , ( not debug ) , 13a_ ) ;
2611: LD_ADDR_EXP 26
2615: PUSH
2616: LD_STRING Cyrus
2618: PPUSH
2619: LD_EXP 1
2623: NOT
2624: PPUSH
2625: LD_STRING 13a_
2627: PPUSH
2628: CALL 53478 0 3
2632: ST_TO_ADDR
// if Cyrus then
2633: LD_EXP 26
2637: IFFALSE 2655
// tmp := tmp ^ Cyrus ;
2639: LD_ADDR_VAR 0 5
2643: PUSH
2644: LD_VAR 0 5
2648: PUSH
2649: LD_EXP 26
2653: ADD
2654: ST_TO_ADDR
// end ; if not Brown then
2655: LD_EXP 28
2659: NOT
2660: IFFALSE 2706
// begin Brown := PrepareUnit ( Brown , ( not debug ) , 13a_ ) ;
2662: LD_ADDR_EXP 28
2666: PUSH
2667: LD_STRING Brown
2669: PPUSH
2670: LD_EXP 1
2674: NOT
2675: PPUSH
2676: LD_STRING 13a_
2678: PPUSH
2679: CALL 53478 0 3
2683: ST_TO_ADDR
// if Brown then
2684: LD_EXP 28
2688: IFFALSE 2706
// tmp := tmp ^ Brown ;
2690: LD_ADDR_VAR 0 5
2694: PUSH
2695: LD_VAR 0 5
2699: PUSH
2700: LD_EXP 28
2704: ADD
2705: ST_TO_ADDR
// end ; if not Gladstone then
2706: LD_EXP 29
2710: NOT
2711: IFFALSE 2757
// begin Gladstone := PrepareUnit ( Gladstone , ( not debug ) , 13a_ ) ;
2713: LD_ADDR_EXP 29
2717: PUSH
2718: LD_STRING Gladstone
2720: PPUSH
2721: LD_EXP 1
2725: NOT
2726: PPUSH
2727: LD_STRING 13a_
2729: PPUSH
2730: CALL 53478 0 3
2734: ST_TO_ADDR
// if Gladstone then
2735: LD_EXP 29
2739: IFFALSE 2757
// tmp := tmp ^ Gladstone ;
2741: LD_ADDR_VAR 0 5
2745: PUSH
2746: LD_VAR 0 5
2750: PUSH
2751: LD_EXP 29
2755: ADD
2756: ST_TO_ADDR
// end ; if not Cornel then
2757: LD_EXP 31
2761: NOT
2762: IFFALSE 2808
// begin Cornel := PrepareUnit ( Cornel , ( not debug ) , 13a_ ) ;
2764: LD_ADDR_EXP 31
2768: PUSH
2769: LD_STRING Cornel
2771: PPUSH
2772: LD_EXP 1
2776: NOT
2777: PPUSH
2778: LD_STRING 13a_
2780: PPUSH
2781: CALL 53478 0 3
2785: ST_TO_ADDR
// if Cornel then
2786: LD_EXP 31
2790: IFFALSE 2808
// tmp := tmp ^ Cornel ;
2792: LD_ADDR_VAR 0 5
2796: PUSH
2797: LD_VAR 0 5
2801: PUSH
2802: LD_EXP 31
2806: ADD
2807: ST_TO_ADDR
// end ; if not Houten then
2808: LD_EXP 30
2812: NOT
2813: IFFALSE 2859
// begin Houten := PrepareUnit ( Houten , ( not debug ) , 13a_ ) ;
2815: LD_ADDR_EXP 30
2819: PUSH
2820: LD_STRING Houten
2822: PPUSH
2823: LD_EXP 1
2827: NOT
2828: PPUSH
2829: LD_STRING 13a_
2831: PPUSH
2832: CALL 53478 0 3
2836: ST_TO_ADDR
// if Houten then
2837: LD_EXP 30
2841: IFFALSE 2859
// tmp := tmp ^ Houten ;
2843: LD_ADDR_VAR 0 5
2847: PUSH
2848: LD_VAR 0 5
2852: PUSH
2853: LD_EXP 30
2857: ADD
2858: ST_TO_ADDR
// end ; if not Gary then
2859: LD_EXP 32
2863: NOT
2864: IFFALSE 2910
// begin Gary := PrepareUnit ( Gary , ( not debug ) , 13a_ ) ;
2866: LD_ADDR_EXP 32
2870: PUSH
2871: LD_STRING Gary
2873: PPUSH
2874: LD_EXP 1
2878: NOT
2879: PPUSH
2880: LD_STRING 13a_
2882: PPUSH
2883: CALL 53478 0 3
2887: ST_TO_ADDR
// if Gary then
2888: LD_EXP 32
2892: IFFALSE 2910
// tmp := tmp ^ Gary ;
2894: LD_ADDR_VAR 0 5
2898: PUSH
2899: LD_VAR 0 5
2903: PUSH
2904: LD_EXP 32
2908: ADD
2909: ST_TO_ADDR
// end ; if not Kikuchi then
2910: LD_EXP 34
2914: NOT
2915: IFFALSE 2961
// begin Kikuchi := PrepareUnit ( Kikuchi , ( not debug ) , 13a_ ) ;
2917: LD_ADDR_EXP 34
2921: PUSH
2922: LD_STRING Kikuchi
2924: PPUSH
2925: LD_EXP 1
2929: NOT
2930: PPUSH
2931: LD_STRING 13a_
2933: PPUSH
2934: CALL 53478 0 3
2938: ST_TO_ADDR
// if Kikuchi then
2939: LD_EXP 34
2943: IFFALSE 2961
// tmp := tmp ^ Kikuchi ;
2945: LD_ADDR_VAR 0 5
2949: PUSH
2950: LD_VAR 0 5
2954: PUSH
2955: LD_EXP 34
2959: ADD
2960: ST_TO_ADDR
// end ; tmp := tmp union CreateCharacterSet ( 13a_others ) ;
2961: LD_ADDR_VAR 0 5
2965: PUSH
2966: LD_VAR 0 5
2970: PUSH
2971: LD_STRING 13a_others
2973: PPUSH
2974: CALL_OW 31
2978: UNION
2979: ST_TO_ADDR
// tmp := tmp diff 0 ;
2980: LD_ADDR_VAR 0 5
2984: PUSH
2985: LD_VAR 0 5
2989: PUSH
2990: LD_INT 0
2992: DIFF
2993: ST_TO_ADDR
// if tmp < 15 then
2994: LD_VAR 0 5
2998: PUSH
2999: LD_INT 15
3001: LESS
3002: IFFALSE 3090
// for i = 15 downto tmp do
3004: LD_ADDR_VAR 0 2
3008: PUSH
3009: DOUBLE
3010: LD_INT 15
3012: INC
3013: ST_TO_ADDR
3014: LD_VAR 0 5
3018: PUSH
3019: FOR_DOWNTO
3020: IFFALSE 3088
// begin uc_nation := [ 1 , 3 ] [ rand ( 1 , 2 ) ] ;
3022: LD_ADDR_OWVAR 21
3026: PUSH
3027: LD_INT 1
3029: PUSH
3030: LD_INT 3
3032: PUSH
3033: EMPTY
3034: LIST
3035: LIST
3036: PUSH
3037: LD_INT 1
3039: PPUSH
3040: LD_INT 2
3042: PPUSH
3043: CALL_OW 12
3047: ARRAY
3048: ST_TO_ADDR
// PrepareHuman ( false , rand ( 1 , 4 ) , 8 ) ;
3049: LD_INT 0
3051: PPUSH
3052: LD_INT 1
3054: PPUSH
3055: LD_INT 4
3057: PPUSH
3058: CALL_OW 12
3062: PPUSH
3063: LD_INT 8
3065: PPUSH
3066: CALL_OW 380
// tmp := tmp ^ CreateHuman ;
3070: LD_ADDR_VAR 0 5
3074: PUSH
3075: LD_VAR 0 5
3079: PUSH
3080: CALL_OW 44
3084: ADD
3085: ST_TO_ADDR
// end ;
3086: GO 3019
3088: POP
3089: POP
// if not debug then
3090: LD_EXP 1
3094: NOT
3095: IFFALSE 3275
// selected = CharacterSelection (  , [ 14 , 13 , 12 , 11 ] [ Difficulty ] , [ 14 , 13 , 12 , 11 ] [ Difficulty ] , [ sel_change_class , JMM , Burlak , Roth , Joan , Denis , Gossudarov , sel_not_hired , sel_changeable , sel_change_class ] ^ tmp , [ class_soldier , class_scientistic , [ class_engineer , 1 ] , class_mechanic , [ class_sniper , 0 , 3 ] , [ class_bazooker , 0 , 3 ] ] ) else
3097: LD_ADDR_VAR 0 4
3101: PUSH
3102: LD_STRING 
3104: PPUSH
3105: LD_INT 14
3107: PUSH
3108: LD_INT 13
3110: PUSH
3111: LD_INT 12
3113: PUSH
3114: LD_INT 11
3116: PUSH
3117: EMPTY
3118: LIST
3119: LIST
3120: LIST
3121: LIST
3122: PUSH
3123: LD_OWVAR 67
3127: ARRAY
3128: PPUSH
3129: LD_INT 14
3131: PUSH
3132: LD_INT 13
3134: PUSH
3135: LD_INT 12
3137: PUSH
3138: LD_INT 11
3140: PUSH
3141: EMPTY
3142: LIST
3143: LIST
3144: LIST
3145: LIST
3146: PUSH
3147: LD_OWVAR 67
3151: ARRAY
3152: PPUSH
3153: LD_INT -5
3155: PUSH
3156: LD_EXP 21
3160: PUSH
3161: LD_EXP 54
3165: PUSH
3166: LD_EXP 22
3170: PUSH
3171: LD_EXP 36
3175: PUSH
3176: LD_EXP 27
3180: PUSH
3181: LD_EXP 40
3185: PUSH
3186: LD_INT -2
3188: PUSH
3189: LD_INT -3
3191: PUSH
3192: LD_INT -5
3194: PUSH
3195: EMPTY
3196: LIST
3197: LIST
3198: LIST
3199: LIST
3200: LIST
3201: LIST
3202: LIST
3203: LIST
3204: LIST
3205: LIST
3206: PUSH
3207: LD_VAR 0 5
3211: ADD
3212: PPUSH
3213: LD_INT 1
3215: PUSH
3216: LD_INT 4
3218: PUSH
3219: LD_INT 2
3221: PUSH
3222: LD_INT 1
3224: PUSH
3225: EMPTY
3226: LIST
3227: LIST
3228: PUSH
3229: LD_INT 3
3231: PUSH
3232: LD_INT 5
3234: PUSH
3235: LD_INT 0
3237: PUSH
3238: LD_INT 3
3240: PUSH
3241: EMPTY
3242: LIST
3243: LIST
3244: LIST
3245: PUSH
3246: LD_INT 9
3248: PUSH
3249: LD_INT 0
3251: PUSH
3252: LD_INT 3
3254: PUSH
3255: EMPTY
3256: LIST
3257: LIST
3258: LIST
3259: PUSH
3260: EMPTY
3261: LIST
3262: LIST
3263: LIST
3264: LIST
3265: LIST
3266: LIST
3267: PPUSH
3268: CALL_OW 42
3272: ST_TO_ADDR
3273: GO 3324
// selected := [ Titov , Fadeev , Dolgov , Petrosyan , Scholtze , Oblukov , Kapitsova ] ;
3275: LD_ADDR_VAR 0 4
3279: PUSH
3280: LD_EXP 42
3284: PUSH
3285: LD_EXP 43
3289: PUSH
3290: LD_EXP 44
3294: PUSH
3295: LD_EXP 45
3299: PUSH
3300: LD_EXP 46
3304: PUSH
3305: LD_EXP 47
3309: PUSH
3310: LD_EXP 48
3314: PUSH
3315: EMPTY
3316: LIST
3317: LIST
3318: LIST
3319: LIST
3320: LIST
3321: LIST
3322: LIST
3323: ST_TO_ADDR
// allianceTeam := tmp diff selected ;
3324: LD_ADDR_EXP 17
3328: PUSH
3329: LD_VAR 0 5
3333: PUSH
3334: LD_VAR 0 4
3338: DIFF
3339: ST_TO_ADDR
// uc_nation := 1 ;
3340: LD_ADDR_OWVAR 21
3344: PUSH
3345: LD_INT 1
3347: ST_TO_ADDR
// PrepareVehicle ( us_morphling , engine_siberite , control_manual , us_heavy_gun , 100 ) ;
3348: LD_INT 5
3350: PPUSH
3351: LD_INT 3
3353: PPUSH
3354: LD_INT 1
3356: PPUSH
3357: LD_INT 6
3359: PPUSH
3360: LD_INT 100
3362: PPUSH
3363: CALL 58318 0 5
// veh := CreateVehicle ;
3367: LD_ADDR_VAR 0 3
3371: PUSH
3372: CALL_OW 45
3376: ST_TO_ADDR
// SetMark ( veh , - 7 ) ;
3377: LD_VAR 0 3
3381: PPUSH
3382: LD_INT 7
3384: NEG
3385: PPUSH
3386: CALL_OW 242
// SetDir ( veh , 3 ) ;
3390: LD_VAR 0 3
3394: PPUSH
3395: LD_INT 3
3397: PPUSH
3398: CALL_OW 233
// PlaceUnitArea ( veh , allianceJMMSpawnArea , false ) ;
3402: LD_VAR 0 3
3406: PPUSH
3407: LD_INT 31
3409: PPUSH
3410: LD_INT 0
3412: PPUSH
3413: CALL_OW 49
// PlaceHumanInUnit ( JMM , veh ) ;
3417: LD_EXP 21
3421: PPUSH
3422: LD_VAR 0 3
3426: PPUSH
3427: CALL_OW 52
// if Joan then
3431: LD_EXP 36
3435: IFFALSE 3507
// begin PrepareVehicle ( us_medium_tracked , engine_siberite , control_manual , us_radar , 100 ) ;
3437: LD_INT 3
3439: PPUSH
3440: LD_INT 3
3442: PPUSH
3443: LD_INT 1
3445: PPUSH
3446: LD_INT 11
3448: PPUSH
3449: LD_INT 100
3451: PPUSH
3452: CALL 58318 0 5
// veh := CreateVehicle ;
3456: LD_ADDR_VAR 0 3
3460: PUSH
3461: CALL_OW 45
3465: ST_TO_ADDR
// SetDir ( veh , 3 ) ;
3466: LD_VAR 0 3
3470: PPUSH
3471: LD_INT 3
3473: PPUSH
3474: CALL_OW 233
// PlaceUnitArea ( veh , allianceSpawnArea , false ) ;
3478: LD_VAR 0 3
3482: PPUSH
3483: LD_INT 30
3485: PPUSH
3486: LD_INT 0
3488: PPUSH
3489: CALL_OW 49
// PlaceHumanInUnit ( Joan , veh ) ;
3493: LD_EXP 36
3497: PPUSH
3498: LD_VAR 0 3
3502: PPUSH
3503: CALL_OW 52
// end ; if Roth then
3507: LD_EXP 22
3511: IFFALSE 3583
// begin PrepareVehicle ( us_medium_tracked , engine_siberite , control_manual , us_radar , 100 ) ;
3513: LD_INT 3
3515: PPUSH
3516: LD_INT 3
3518: PPUSH
3519: LD_INT 1
3521: PPUSH
3522: LD_INT 11
3524: PPUSH
3525: LD_INT 100
3527: PPUSH
3528: CALL 58318 0 5
// veh := CreateVehicle ;
3532: LD_ADDR_VAR 0 3
3536: PUSH
3537: CALL_OW 45
3541: ST_TO_ADDR
// SetDir ( veh , 3 ) ;
3542: LD_VAR 0 3
3546: PPUSH
3547: LD_INT 3
3549: PPUSH
3550: CALL_OW 233
// PlaceUnitArea ( veh , allianceSpawnArea , false ) ;
3554: LD_VAR 0 3
3558: PPUSH
3559: LD_INT 30
3561: PPUSH
3562: LD_INT 0
3564: PPUSH
3565: CALL_OW 49
// PlaceHumanInUnit ( Roth , veh ) ;
3569: LD_EXP 22
3573: PPUSH
3574: LD_VAR 0 3
3578: PPUSH
3579: CALL_OW 52
// end ; if Denis then
3583: LD_EXP 27
3587: IFFALSE 3659
// begin PrepareVehicle ( us_morphling , engine_siberite , control_manual , us_laser , 100 ) ;
3589: LD_INT 5
3591: PPUSH
3592: LD_INT 3
3594: PPUSH
3595: LD_INT 1
3597: PPUSH
3598: LD_INT 9
3600: PPUSH
3601: LD_INT 100
3603: PPUSH
3604: CALL 58318 0 5
// veh := CreateVehicle ;
3608: LD_ADDR_VAR 0 3
3612: PUSH
3613: CALL_OW 45
3617: ST_TO_ADDR
// SetDir ( veh , 3 ) ;
3618: LD_VAR 0 3
3622: PPUSH
3623: LD_INT 3
3625: PPUSH
3626: CALL_OW 233
// PlaceUnitArea ( veh , allianceSpawnArea , false ) ;
3630: LD_VAR 0 3
3634: PPUSH
3635: LD_INT 30
3637: PPUSH
3638: LD_INT 0
3640: PPUSH
3641: CALL_OW 49
// PlaceHumanInUnit ( Denis , veh ) ;
3645: LD_EXP 27
3649: PPUSH
3650: LD_VAR 0 3
3654: PPUSH
3655: CALL_OW 52
// end ; uc_nation := 3 ;
3659: LD_ADDR_OWVAR 21
3663: PUSH
3664: LD_INT 3
3666: ST_TO_ADDR
// PrepareVehicle ( ru_medium_tracked , engine_siberite , control_manual , ru_rocket_launcher , 100 ) ;
3667: LD_INT 22
3669: PPUSH
3670: LD_INT 3
3672: PPUSH
3673: LD_INT 1
3675: PPUSH
3676: LD_INT 45
3678: PPUSH
3679: LD_INT 100
3681: PPUSH
3682: CALL 58318 0 5
// veh := CreateVehicle ;
3686: LD_ADDR_VAR 0 3
3690: PUSH
3691: CALL_OW 45
3695: ST_TO_ADDR
// SetMark ( veh , - 7 ) ;
3696: LD_VAR 0 3
3700: PPUSH
3701: LD_INT 7
3703: NEG
3704: PPUSH
3705: CALL_OW 242
// SetDir ( veh , 3 ) ;
3709: LD_VAR 0 3
3713: PPUSH
3714: LD_INT 3
3716: PPUSH
3717: CALL_OW 233
// PlaceUnitArea ( veh , allianceJMMSpawnArea , false ) ;
3721: LD_VAR 0 3
3725: PPUSH
3726: LD_INT 31
3728: PPUSH
3729: LD_INT 0
3731: PPUSH
3732: CALL_OW 49
// PlaceHumanInUnit ( Burlak , veh ) ;
3736: LD_EXP 54
3740: PPUSH
3741: LD_VAR 0 3
3745: PPUSH
3746: CALL_OW 52
// if Gossudarov then
3750: LD_EXP 40
3754: IFFALSE 3841
// begin PrepareVehicle ( ru_medium_tracked , engine_siberite , control_manual , ru_cargo_bay , 100 ) ;
3756: LD_INT 22
3758: PPUSH
3759: LD_INT 3
3761: PPUSH
3762: LD_INT 1
3764: PPUSH
3765: LD_INT 51
3767: PPUSH
3768: LD_INT 100
3770: PPUSH
3771: CALL 58318 0 5
// veh := CreateVehicle ;
3775: LD_ADDR_VAR 0 3
3779: PUSH
3780: CALL_OW 45
3784: ST_TO_ADDR
// SetDir ( veh , 3 ) ;
3785: LD_VAR 0 3
3789: PPUSH
3790: LD_INT 3
3792: PPUSH
3793: CALL_OW 233
// PlaceUnitArea ( veh , allianceSpawnArea , false ) ;
3797: LD_VAR 0 3
3801: PPUSH
3802: LD_INT 30
3804: PPUSH
3805: LD_INT 0
3807: PPUSH
3808: CALL_OW 49
// PlaceHumanInUnit ( Gossudarov , veh ) ;
3812: LD_EXP 40
3816: PPUSH
3817: LD_VAR 0 3
3821: PPUSH
3822: CALL_OW 52
// SetCargo ( veh , mat_cans , 100 ) ;
3826: LD_VAR 0 3
3830: PPUSH
3831: LD_INT 1
3833: PPUSH
3834: LD_INT 100
3836: PPUSH
3837: CALL_OW 290
// end ; if Mike then
3841: LD_EXP 39
3845: IFFALSE 3862
// PlaceUnitArea ( Mike , allianceSpawnArea , false ) ;
3847: LD_EXP 39
3851: PPUSH
3852: LD_INT 30
3854: PPUSH
3855: LD_INT 0
3857: PPUSH
3858: CALL_OW 49
// for i in selected do
3862: LD_ADDR_VAR 0 2
3866: PUSH
3867: LD_VAR 0 4
3871: PUSH
3872: FOR_IN
3873: IFFALSE 4431
// begin uc_nation := GetNation ( i ) ;
3875: LD_ADDR_OWVAR 21
3879: PUSH
3880: LD_VAR 0 2
3884: PPUSH
3885: CALL_OW 248
3889: ST_TO_ADDR
// if i in [ Lisa , Donaldson , Cyrus , Bobby ] then
3890: LD_VAR 0 2
3894: PUSH
3895: LD_EXP 23
3899: PUSH
3900: LD_EXP 24
3904: PUSH
3905: LD_EXP 26
3909: PUSH
3910: LD_EXP 25
3914: PUSH
3915: EMPTY
3916: LIST
3917: LIST
3918: LIST
3919: LIST
3920: IN
3921: IFFALSE 3944
// PrepareVehicle ( us_morphling , engine_siberite , control_manual , us_heavy_gun , 100 ) else
3923: LD_INT 5
3925: PPUSH
3926: LD_INT 3
3928: PPUSH
3929: LD_INT 1
3931: PPUSH
3932: LD_INT 6
3934: PPUSH
3935: LD_INT 100
3937: PPUSH
3938: CALL 58318 0 5
3942: GO 4378
// if i in [ Oblukov , Kuzmov , Petrovova , Titov ] then
3944: LD_VAR 0 2
3948: PUSH
3949: LD_EXP 47
3953: PUSH
3954: LD_EXP 52
3958: PUSH
3959: LD_EXP 50
3963: PUSH
3964: LD_EXP 42
3968: PUSH
3969: EMPTY
3970: LIST
3971: LIST
3972: LIST
3973: LIST
3974: IN
3975: IFFALSE 4006
// PrepareVehicle ( ru_heavy_tracked , engine_combustion , control_manual , ru_heavy_gun , rand ( 65 , 75 ) ) else
3977: LD_INT 24
3979: PPUSH
3980: LD_INT 1
3982: PPUSH
3983: LD_INT 1
3985: PPUSH
3986: LD_INT 46
3988: PPUSH
3989: LD_INT 65
3991: PPUSH
3992: LD_INT 75
3994: PPUSH
3995: CALL_OW 12
3999: PPUSH
4000: CALL 58318 0 5
4004: GO 4378
// if i = Karamazov then
4006: LD_VAR 0 2
4010: PUSH
4011: LD_EXP 53
4015: EQUAL
4016: IFFALSE 4039
// PrepareVehicle ( ru_medium_tracked , engine_siberite , control_manual , ru_crane , 100 ) else
4018: LD_INT 22
4020: PPUSH
4021: LD_INT 3
4023: PPUSH
4024: LD_INT 1
4026: PPUSH
4027: LD_INT 52
4029: PPUSH
4030: LD_INT 100
4032: PPUSH
4033: CALL 58318 0 5
4037: GO 4378
// if i = Brown then
4039: LD_VAR 0 2
4043: PUSH
4044: LD_EXP 28
4048: EQUAL
4049: IFFALSE 4072
// PrepareVehicle ( us_medium_tracked , engine_siberite , control_manual , us_crane , 100 ) else
4051: LD_INT 3
4053: PPUSH
4054: LD_INT 3
4056: PPUSH
4057: LD_INT 1
4059: PPUSH
4060: LD_INT 13
4062: PPUSH
4063: LD_INT 100
4065: PPUSH
4066: CALL 58318 0 5
4070: GO 4378
// if uc_nation = nation_american then
4072: LD_OWVAR 21
4076: PUSH
4077: LD_INT 1
4079: EQUAL
4080: IFFALSE 4231
// begin PrepareVehicle ( [ us_medium_tracked , us_morphling , us_morphling ] [ uc_nation mod 3 + 1 ] , [ engine_combustion , engine_siberite , engine_combustion ] [ uc_nation mod 3 + 1 ] , control_manual , [ [ us_radar , us_gatling_gun , us_double_gun ] , [ us_heavy_gun , us_rocket_launcher , us_laser ] , [ us_heavy_gun , us_laser , us_cargo_bay ] ] [ uc_nation mod 3 + 1 ] [ rand ( 1 , 3 ) ] , rand ( 65 , 75 ) ) ;
4082: LD_INT 3
4084: PUSH
4085: LD_INT 5
4087: PUSH
4088: LD_INT 5
4090: PUSH
4091: EMPTY
4092: LIST
4093: LIST
4094: LIST
4095: PUSH
4096: LD_OWVAR 21
4100: PUSH
4101: LD_INT 3
4103: MOD
4104: PUSH
4105: LD_INT 1
4107: PLUS
4108: ARRAY
4109: PPUSH
4110: LD_INT 1
4112: PUSH
4113: LD_INT 3
4115: PUSH
4116: LD_INT 1
4118: PUSH
4119: EMPTY
4120: LIST
4121: LIST
4122: LIST
4123: PUSH
4124: LD_OWVAR 21
4128: PUSH
4129: LD_INT 3
4131: MOD
4132: PUSH
4133: LD_INT 1
4135: PLUS
4136: ARRAY
4137: PPUSH
4138: LD_INT 1
4140: PPUSH
4141: LD_INT 11
4143: PUSH
4144: LD_INT 4
4146: PUSH
4147: LD_INT 5
4149: PUSH
4150: EMPTY
4151: LIST
4152: LIST
4153: LIST
4154: PUSH
4155: LD_INT 6
4157: PUSH
4158: LD_INT 7
4160: PUSH
4161: LD_INT 9
4163: PUSH
4164: EMPTY
4165: LIST
4166: LIST
4167: LIST
4168: PUSH
4169: LD_INT 6
4171: PUSH
4172: LD_INT 9
4174: PUSH
4175: LD_INT 12
4177: PUSH
4178: EMPTY
4179: LIST
4180: LIST
4181: LIST
4182: PUSH
4183: EMPTY
4184: LIST
4185: LIST
4186: LIST
4187: PUSH
4188: LD_OWVAR 21
4192: PUSH
4193: LD_INT 3
4195: MOD
4196: PUSH
4197: LD_INT 1
4199: PLUS
4200: ARRAY
4201: PUSH
4202: LD_INT 1
4204: PPUSH
4205: LD_INT 3
4207: PPUSH
4208: CALL_OW 12
4212: ARRAY
4213: PPUSH
4214: LD_INT 65
4216: PPUSH
4217: LD_INT 75
4219: PPUSH
4220: CALL_OW 12
4224: PPUSH
4225: CALL 58318 0 5
// end else
4229: GO 4378
// begin PrepareVehicle ( [ ru_medium_tracked , ru_heavy_wheeled , ru_heavy_wheeled ] [ uc_nation mod 3 + 1 ] , [ engine_combustion , engine_siberite , engine_combustion ] [ uc_nation mod 3 + 1 ] , control_manual , [ [ ru_rocket_launcher , ru_gatling_gun , ru_gun ] , [ ru_heavy_gun , ru_rocket_launcher , ru_gun ] , [ ru_heavy_gun , ru_gatling_gun , ru_rocket_launcher ] ] [ uc_nation mod 3 + 1 ] [ rand ( 1 , 3 ) ] , rand ( 65 , 75 ) ) ;
4231: LD_INT 22
4233: PUSH
4234: LD_INT 23
4236: PUSH
4237: LD_INT 23
4239: PUSH
4240: EMPTY
4241: LIST
4242: LIST
4243: LIST
4244: PUSH
4245: LD_OWVAR 21
4249: PUSH
4250: LD_INT 3
4252: MOD
4253: PUSH
4254: LD_INT 1
4256: PLUS
4257: ARRAY
4258: PPUSH
4259: LD_INT 1
4261: PUSH
4262: LD_INT 3
4264: PUSH
4265: LD_INT 1
4267: PUSH
4268: EMPTY
4269: LIST
4270: LIST
4271: LIST
4272: PUSH
4273: LD_OWVAR 21
4277: PUSH
4278: LD_INT 3
4280: MOD
4281: PUSH
4282: LD_INT 1
4284: PLUS
4285: ARRAY
4286: PPUSH
4287: LD_INT 1
4289: PPUSH
4290: LD_INT 45
4292: PUSH
4293: LD_INT 43
4295: PUSH
4296: LD_INT 44
4298: PUSH
4299: EMPTY
4300: LIST
4301: LIST
4302: LIST
4303: PUSH
4304: LD_INT 46
4306: PUSH
4307: LD_INT 45
4309: PUSH
4310: LD_INT 44
4312: PUSH
4313: EMPTY
4314: LIST
4315: LIST
4316: LIST
4317: PUSH
4318: LD_INT 46
4320: PUSH
4321: LD_INT 43
4323: PUSH
4324: LD_INT 45
4326: PUSH
4327: EMPTY
4328: LIST
4329: LIST
4330: LIST
4331: PUSH
4332: EMPTY
4333: LIST
4334: LIST
4335: LIST
4336: PUSH
4337: LD_OWVAR 21
4341: PUSH
4342: LD_INT 3
4344: MOD
4345: PUSH
4346: LD_INT 1
4348: PLUS
4349: ARRAY
4350: PUSH
4351: LD_INT 1
4353: PPUSH
4354: LD_INT 3
4356: PPUSH
4357: CALL_OW 12
4361: ARRAY
4362: PPUSH
4363: LD_INT 65
4365: PPUSH
4366: LD_INT 75
4368: PPUSH
4369: CALL_OW 12
4373: PPUSH
4374: CALL 58318 0 5
// end ; veh := CreateVehicle ;
4378: LD_ADDR_VAR 0 3
4382: PUSH
4383: CALL_OW 45
4387: ST_TO_ADDR
// SetDir ( veh , 3 ) ;
4388: LD_VAR 0 3
4392: PPUSH
4393: LD_INT 3
4395: PPUSH
4396: CALL_OW 233
// PlaceUnitArea ( veh , allianceSpawnArea , false ) ;
4400: LD_VAR 0 3
4404: PPUSH
4405: LD_INT 30
4407: PPUSH
4408: LD_INT 0
4410: PPUSH
4411: CALL_OW 49
// PlaceHumanInUnit ( i , veh ) ;
4415: LD_VAR 0 2
4419: PPUSH
4420: LD_VAR 0 3
4424: PPUSH
4425: CALL_OW 52
// end ;
4429: GO 3872
4431: POP
4432: POP
// if artifactArCaptured then
4433: LD_EXP 9
4437: IFFALSE 4523
// begin uc_nation := nation_american ;
4439: LD_ADDR_OWVAR 21
4443: PUSH
4444: LD_INT 1
4446: ST_TO_ADDR
// PrepareVehicle ( us_medium_tracked , engine_siberite , control_computer , us_cargo_bay , 100 ) ;
4447: LD_INT 3
4449: PPUSH
4450: LD_INT 3
4452: PPUSH
4453: LD_INT 3
4455: PPUSH
4456: LD_INT 12
4458: PPUSH
4459: LD_INT 100
4461: PPUSH
4462: CALL 58318 0 5
// veh := CreateVehicle ;
4466: LD_ADDR_VAR 0 3
4470: PUSH
4471: CALL_OW 45
4475: ST_TO_ADDR
// SetDir ( veh , 3 ) ;
4476: LD_VAR 0 3
4480: PPUSH
4481: LD_INT 3
4483: PPUSH
4484: CALL_OW 233
// PlaceUnitXY ( veh , 198 , 22 , false ) ;
4488: LD_VAR 0 3
4492: PPUSH
4493: LD_INT 198
4495: PPUSH
4496: LD_INT 22
4498: PPUSH
4499: LD_INT 0
4501: PPUSH
4502: CALL_OW 48
// SetCargo ( veh , mat_artifact , 50 ) ;
4506: LD_VAR 0 3
4510: PPUSH
4511: LD_INT 4
4513: PPUSH
4514: LD_INT 50
4516: PPUSH
4517: CALL_OW 290
// end else
4521: GO 4542
// begin CreateResourcesXY ( mat_artifact , 5 , 267 , 226 , false ) ;
4523: LD_INT 4
4525: PPUSH
4526: LD_INT 5
4528: PPUSH
4529: LD_INT 267
4531: PPUSH
4532: LD_INT 226
4534: PPUSH
4535: LD_INT 0
4537: PPUSH
4538: CALL_OW 58
// end ; uc_nation := nation_american ;
4542: LD_ADDR_OWVAR 21
4546: PUSH
4547: LD_INT 1
4549: ST_TO_ADDR
// PrepareVehicle ( us_medium_tracked , engine_siberite , control_computer , us_cargo_bay , 100 ) ;
4550: LD_INT 3
4552: PPUSH
4553: LD_INT 3
4555: PPUSH
4556: LD_INT 3
4558: PPUSH
4559: LD_INT 12
4561: PPUSH
4562: LD_INT 100
4564: PPUSH
4565: CALL 58318 0 5
// veh := CreateVehicle ;
4569: LD_ADDR_VAR 0 3
4573: PUSH
4574: CALL_OW 45
4578: ST_TO_ADDR
// SetDir ( veh , 3 ) ;
4579: LD_VAR 0 3
4583: PPUSH
4584: LD_INT 3
4586: PPUSH
4587: CALL_OW 233
// PlaceUnitXY ( veh , 218 , 23 , false ) ;
4591: LD_VAR 0 3
4595: PPUSH
4596: LD_INT 218
4598: PPUSH
4599: LD_INT 23
4601: PPUSH
4602: LD_INT 0
4604: PPUSH
4605: CALL_OW 48
// SetCargo ( veh , mat_artifact , 30 ) ;
4609: LD_VAR 0 3
4613: PPUSH
4614: LD_INT 4
4616: PPUSH
4617: LD_INT 30
4619: PPUSH
4620: CALL_OW 290
// uc_nation := nation_russian ;
4624: LD_ADDR_OWVAR 21
4628: PUSH
4629: LD_INT 3
4631: ST_TO_ADDR
// PrepareVehicle ( ru_medium_tracked , engine_siberite , control_computer , ru_cargo_bay , 100 ) ;
4632: LD_INT 22
4634: PPUSH
4635: LD_INT 3
4637: PPUSH
4638: LD_INT 3
4640: PPUSH
4641: LD_INT 51
4643: PPUSH
4644: LD_INT 100
4646: PPUSH
4647: CALL 58318 0 5
// veh := CreateVehicle ;
4651: LD_ADDR_VAR 0 3
4655: PUSH
4656: CALL_OW 45
4660: ST_TO_ADDR
// SetDir ( veh , 3 ) ;
4661: LD_VAR 0 3
4665: PPUSH
4666: LD_INT 3
4668: PPUSH
4669: CALL_OW 233
// PlaceUnitXY ( veh , 214 , 20 , false ) ;
4673: LD_VAR 0 3
4677: PPUSH
4678: LD_INT 214
4680: PPUSH
4681: LD_INT 20
4683: PPUSH
4684: LD_INT 0
4686: PPUSH
4687: CALL_OW 48
// SetCargo ( veh , mat_artifact , 40 ) ;
4691: LD_VAR 0 3
4695: PPUSH
4696: LD_INT 4
4698: PPUSH
4699: LD_INT 40
4701: PPUSH
4702: CALL_OW 290
// end ;
4706: LD_VAR 0 1
4710: RET
// export function AllianceSupport ; var i , veh ; begin
4711: LD_INT 0
4713: PPUSH
4714: PPUSH
4715: PPUSH
// if not allianceTeam then
4716: LD_EXP 17
4720: NOT
4721: IFFALSE 4725
// exit ;
4723: GO 5131
// for i := 1 to 6 do
4725: LD_ADDR_VAR 0 2
4729: PUSH
4730: DOUBLE
4731: LD_INT 1
4733: DEC
4734: ST_TO_ADDR
4735: LD_INT 6
4737: PUSH
4738: FOR_TO
4739: IFFALSE 5035
// begin uc_side := 7 ;
4741: LD_ADDR_OWVAR 20
4745: PUSH
4746: LD_INT 7
4748: ST_TO_ADDR
// uc_nation := [ 1 , 3 ] [ i mod 2 + 1 ] ;
4749: LD_ADDR_OWVAR 21
4753: PUSH
4754: LD_INT 1
4756: PUSH
4757: LD_INT 3
4759: PUSH
4760: EMPTY
4761: LIST
4762: LIST
4763: PUSH
4764: LD_VAR 0 2
4768: PUSH
4769: LD_INT 2
4771: MOD
4772: PUSH
4773: LD_INT 1
4775: PLUS
4776: ARRAY
4777: ST_TO_ADDR
// if uc_nation = 1 then
4778: LD_OWVAR 21
4782: PUSH
4783: LD_INT 1
4785: EQUAL
4786: IFFALSE 4828
// PrepareVehicle ( us_morphling , engine_siberite , control_manual , [ us_heavy_gun , us_rocket_launcher ] [ rand ( 1 , 2 ) ] , 100 ) else
4788: LD_INT 5
4790: PPUSH
4791: LD_INT 3
4793: PPUSH
4794: LD_INT 1
4796: PPUSH
4797: LD_INT 6
4799: PUSH
4800: LD_INT 7
4802: PUSH
4803: EMPTY
4804: LIST
4805: LIST
4806: PUSH
4807: LD_INT 1
4809: PPUSH
4810: LD_INT 2
4812: PPUSH
4813: CALL_OW 12
4817: ARRAY
4818: PPUSH
4819: LD_INT 100
4821: PPUSH
4822: CALL 58318 0 5
4826: GO 4866
// PrepareVehicle ( ru_heavy_wheeled , engine_siberite , control_manual , [ ru_heavy_gun , ru_rocket ] [ rand ( 1 , 2 ) ] , 100 ) ;
4828: LD_INT 23
4830: PPUSH
4831: LD_INT 3
4833: PPUSH
4834: LD_INT 1
4836: PPUSH
4837: LD_INT 46
4839: PUSH
4840: LD_INT 47
4842: PUSH
4843: EMPTY
4844: LIST
4845: LIST
4846: PUSH
4847: LD_INT 1
4849: PPUSH
4850: LD_INT 2
4852: PPUSH
4853: CALL_OW 12
4857: ARRAY
4858: PPUSH
4859: LD_INT 100
4861: PPUSH
4862: CALL 58318 0 5
// if not allianceTeam then
4866: LD_EXP 17
4870: NOT
4871: IFFALSE 4875
// break ;
4873: GO 5035
// veh := CreateVehicle ;
4875: LD_ADDR_VAR 0 3
4879: PUSH
4880: CALL_OW 45
4884: ST_TO_ADDR
// SetDir ( veh , 4 ) ;
4885: LD_VAR 0 3
4889: PPUSH
4890: LD_INT 4
4892: PPUSH
4893: CALL_OW 233
// PlaceUnitArea ( veh , allianceSouthSupp , false ) ;
4897: LD_VAR 0 3
4901: PPUSH
4902: LD_INT 38
4904: PPUSH
4905: LD_INT 0
4907: PPUSH
4908: CALL_OW 49
// if GetSkill ( allianceTeam [ 1 ] , class_mechanic ) > 4 then
4912: LD_EXP 17
4916: PUSH
4917: LD_INT 1
4919: ARRAY
4920: PPUSH
4921: LD_INT 3
4923: PPUSH
4924: CALL_OW 259
4928: PUSH
4929: LD_INT 4
4931: GREATER
4932: IFFALSE 4950
// SetClass ( allianceTeam [ 1 ] , class_mechanic ) ;
4934: LD_EXP 17
4938: PUSH
4939: LD_INT 1
4941: ARRAY
4942: PPUSH
4943: LD_INT 3
4945: PPUSH
4946: CALL_OW 336
// if GetSkill ( allianceTeam [ 1 ] , class_scientistic ) > 8 then
4950: LD_EXP 17
4954: PUSH
4955: LD_INT 1
4957: ARRAY
4958: PPUSH
4959: LD_INT 4
4961: PPUSH
4962: CALL_OW 259
4966: PUSH
4967: LD_INT 8
4969: GREATER
4970: IFFALSE 4988
// SetClass ( allianceTeam [ 1 ] , class_scientistic ) ;
4972: LD_EXP 17
4976: PUSH
4977: LD_INT 1
4979: ARRAY
4980: PPUSH
4981: LD_INT 4
4983: PPUSH
4984: CALL_OW 336
// PlaceHumanInUnit ( allianceTeam [ 1 ] , veh ) ;
4988: LD_EXP 17
4992: PUSH
4993: LD_INT 1
4995: ARRAY
4996: PPUSH
4997: LD_VAR 0 3
5001: PPUSH
5002: CALL_OW 52
// allianceTeam := Delete ( allianceTeam , 1 ) ;
5006: LD_ADDR_EXP 17
5010: PUSH
5011: LD_EXP 17
5015: PPUSH
5016: LD_INT 1
5018: PPUSH
5019: CALL_OW 3
5023: ST_TO_ADDR
// ComHold ( veh ) ;
5024: LD_VAR 0 3
5028: PPUSH
5029: CALL_OW 140
// end ;
5033: GO 4738
5035: POP
5036: POP
// uc_side := 7 ;
5037: LD_ADDR_OWVAR 20
5041: PUSH
5042: LD_INT 7
5044: ST_TO_ADDR
// uc_nation := 1 ;
5045: LD_ADDR_OWVAR 21
5049: PUSH
5050: LD_INT 1
5052: ST_TO_ADDR
// PrepareVehicle ( us_morphling , engine_siberite , control_computer , us_radar , 100 ) ;
5053: LD_INT 5
5055: PPUSH
5056: LD_INT 3
5058: PPUSH
5059: LD_INT 3
5061: PPUSH
5062: LD_INT 11
5064: PPUSH
5065: LD_INT 100
5067: PPUSH
5068: CALL 58318 0 5
// veh := CreateVehicle ;
5072: LD_ADDR_VAR 0 3
5076: PUSH
5077: CALL_OW 45
5081: ST_TO_ADDR
// SetDir ( veh , 4 ) ;
5082: LD_VAR 0 3
5086: PPUSH
5087: LD_INT 4
5089: PPUSH
5090: CALL_OW 233
// PlaceUnitXY ( veh , 305 , 218 , false ) ;
5094: LD_VAR 0 3
5098: PPUSH
5099: LD_INT 305
5101: PPUSH
5102: LD_INT 218
5104: PPUSH
5105: LD_INT 0
5107: PPUSH
5108: CALL_OW 48
// ComHold ( veh ) ;
5112: LD_VAR 0 3
5116: PPUSH
5117: CALL_OW 140
// CenterNowOnXY ( 313 , 220 ) ;
5121: LD_INT 313
5123: PPUSH
5124: LD_INT 220
5126: PPUSH
5127: CALL_OW 86
// end ; end_of_file
5131: LD_VAR 0 1
5135: RET
// export Powell ; export function PrepareAmerican ; var i , b , veh , cl , p , tmp , depot , lab , armoury , workshop ; begin
5136: LD_INT 0
5138: PPUSH
5139: PPUSH
5140: PPUSH
5141: PPUSH
5142: PPUSH
5143: PPUSH
5144: PPUSH
5145: PPUSH
5146: PPUSH
5147: PPUSH
5148: PPUSH
// InitHc ;
5149: CALL_OW 19
// SetBName ( am_depot , sigma ) ;
5153: LD_INT 387
5155: PPUSH
5156: LD_STRING sigma
5158: PPUSH
5159: CALL_OW 500
// uc_side := 1 ;
5163: LD_ADDR_OWVAR 20
5167: PUSH
5168: LD_INT 1
5170: ST_TO_ADDR
// uc_nation := 1 ;
5171: LD_ADDR_OWVAR 21
5175: PUSH
5176: LD_INT 1
5178: ST_TO_ADDR
// for i in FilterAllUnits ( [ [ f_side , 1 ] , [ f_type , unit_building ] ] ) do
5179: LD_ADDR_VAR 0 2
5183: PUSH
5184: LD_INT 22
5186: PUSH
5187: LD_INT 1
5189: PUSH
5190: EMPTY
5191: LIST
5192: LIST
5193: PUSH
5194: LD_INT 21
5196: PUSH
5197: LD_INT 3
5199: PUSH
5200: EMPTY
5201: LIST
5202: LIST
5203: PUSH
5204: EMPTY
5205: LIST
5206: LIST
5207: PPUSH
5208: CALL_OW 69
5212: PUSH
5213: FOR_IN
5214: IFFALSE 5230
// SetBLevel ( i , 10 ) ;
5216: LD_VAR 0 2
5220: PPUSH
5221: LD_INT 10
5223: PPUSH
5224: CALL_OW 241
5228: GO 5213
5230: POP
5231: POP
// SetResourceType ( GetBase ( am_depot ) , mat_cans , 7500 ) ;
5232: LD_INT 387
5234: PPUSH
5235: CALL_OW 274
5239: PPUSH
5240: LD_INT 1
5242: PPUSH
5243: LD_INT 7500
5245: PPUSH
5246: CALL_OW 277
// SetResourceType ( GetBase ( am_depot ) , mat_oil , 4000 ) ;
5250: LD_INT 387
5252: PPUSH
5253: CALL_OW 274
5257: PPUSH
5258: LD_INT 2
5260: PPUSH
5261: LD_INT 4000
5263: PPUSH
5264: CALL_OW 277
// SetResourceType ( GetBase ( am_depot ) , mat_siberit , 50 ) ;
5268: LD_INT 387
5270: PPUSH
5271: CALL_OW 274
5275: PPUSH
5276: LD_INT 3
5278: PPUSH
5279: LD_INT 50
5281: PPUSH
5282: CALL_OW 277
// SetResourceType ( GetBase ( am_depot2 ) , mat_cans , 5500 ) ;
5286: LD_INT 476
5288: PPUSH
5289: CALL_OW 274
5293: PPUSH
5294: LD_INT 1
5296: PPUSH
5297: LD_INT 5500
5299: PPUSH
5300: CALL_OW 277
// SetResourceType ( GetBase ( am_depot2 ) , mat_oil , 4000 ) ;
5304: LD_INT 476
5306: PPUSH
5307: CALL_OW 274
5311: PPUSH
5312: LD_INT 2
5314: PPUSH
5315: LD_INT 4000
5317: PPUSH
5318: CALL_OW 277
// SetResourceType ( GetBase ( am_depot2 ) , mat_siberit , 10 ) ;
5322: LD_INT 476
5324: PPUSH
5325: CALL_OW 274
5329: PPUSH
5330: LD_INT 3
5332: PPUSH
5333: LD_INT 10
5335: PPUSH
5336: CALL_OW 277
// if LoadVariable ( 12a_PowellKilled , false ) then
5340: LD_STRING 12a_PowellKilled
5342: PPUSH
5343: LD_INT 0
5345: PPUSH
5346: CALL_OW 30
5350: IFFALSE 5377
// begin PrepareHuman ( sex_male , class_soldier , 10 ) ;
5352: LD_INT 1
5354: PPUSH
5355: LD_INT 1
5357: PPUSH
5358: LD_INT 10
5360: PPUSH
5361: CALL_OW 380
// Powell := CreateHuman ;
5365: LD_ADDR_EXP 57
5369: PUSH
5370: CALL_OW 44
5374: ST_TO_ADDR
// end else
5375: GO 5390
// Powell := NewCharacter ( Powell ) ;
5377: LD_ADDR_EXP 57
5381: PUSH
5382: LD_STRING Powell
5384: PPUSH
5385: CALL_OW 25
5389: ST_TO_ADDR
// PlaceHumanInUnit ( Powell , am_depot ) ;
5390: LD_EXP 57
5394: PPUSH
5395: LD_INT 387
5397: PPUSH
5398: CALL_OW 52
// tmp := [ ] ;
5402: LD_ADDR_VAR 0 7
5406: PUSH
5407: EMPTY
5408: ST_TO_ADDR
// Lisa := PrepareUnit ( Lisa , ( not debug ) , 12p_ ) ;
5409: LD_ADDR_EXP 23
5413: PUSH
5414: LD_STRING Lisa
5416: PPUSH
5417: LD_EXP 1
5421: NOT
5422: PPUSH
5423: LD_STRING 12p_
5425: PPUSH
5426: CALL 53478 0 3
5430: ST_TO_ADDR
// if Lisa then
5431: LD_EXP 23
5435: IFFALSE 5453
// tmp := tmp ^ Lisa ;
5437: LD_ADDR_VAR 0 7
5441: PUSH
5442: LD_VAR 0 7
5446: PUSH
5447: LD_EXP 23
5451: ADD
5452: ST_TO_ADDR
// Donaldson := PrepareUnit ( Donaldson , ( not debug ) , 12p_ ) ;
5453: LD_ADDR_EXP 24
5457: PUSH
5458: LD_STRING Donaldson
5460: PPUSH
5461: LD_EXP 1
5465: NOT
5466: PPUSH
5467: LD_STRING 12p_
5469: PPUSH
5470: CALL 53478 0 3
5474: ST_TO_ADDR
// if Donaldson then
5475: LD_EXP 24
5479: IFFALSE 5497
// tmp := tmp ^ Donaldson ;
5481: LD_ADDR_VAR 0 7
5485: PUSH
5486: LD_VAR 0 7
5490: PUSH
5491: LD_EXP 24
5495: ADD
5496: ST_TO_ADDR
// Bobby := PrepareUnit ( Bobby , ( not debug ) , 12p_ ) ;
5497: LD_ADDR_EXP 25
5501: PUSH
5502: LD_STRING Bobby
5504: PPUSH
5505: LD_EXP 1
5509: NOT
5510: PPUSH
5511: LD_STRING 12p_
5513: PPUSH
5514: CALL 53478 0 3
5518: ST_TO_ADDR
// if Bobby then
5519: LD_EXP 25
5523: IFFALSE 5541
// tmp := tmp ^ Bobby ;
5525: LD_ADDR_VAR 0 7
5529: PUSH
5530: LD_VAR 0 7
5534: PUSH
5535: LD_EXP 25
5539: ADD
5540: ST_TO_ADDR
// Cyrus := PrepareUnit ( Cyrus , ( not debug ) , 12p_ ) ;
5541: LD_ADDR_EXP 26
5545: PUSH
5546: LD_STRING Cyrus
5548: PPUSH
5549: LD_EXP 1
5553: NOT
5554: PPUSH
5555: LD_STRING 12p_
5557: PPUSH
5558: CALL 53478 0 3
5562: ST_TO_ADDR
// if Cyrus then
5563: LD_EXP 26
5567: IFFALSE 5585
// tmp := tmp ^ Cyrus ;
5569: LD_ADDR_VAR 0 7
5573: PUSH
5574: LD_VAR 0 7
5578: PUSH
5579: LD_EXP 26
5583: ADD
5584: ST_TO_ADDR
// Brown := PrepareUnit ( Brown , ( not debug ) , 12p_ ) ;
5585: LD_ADDR_EXP 28
5589: PUSH
5590: LD_STRING Brown
5592: PPUSH
5593: LD_EXP 1
5597: NOT
5598: PPUSH
5599: LD_STRING 12p_
5601: PPUSH
5602: CALL 53478 0 3
5606: ST_TO_ADDR
// if Brown then
5607: LD_EXP 28
5611: IFFALSE 5629
// tmp := tmp ^ Brown ;
5613: LD_ADDR_VAR 0 7
5617: PUSH
5618: LD_VAR 0 7
5622: PUSH
5623: LD_EXP 28
5627: ADD
5628: ST_TO_ADDR
// Gladstone := PrepareUnit ( Gladstone , ( not debug ) , 12p_ ) ;
5629: LD_ADDR_EXP 29
5633: PUSH
5634: LD_STRING Gladstone
5636: PPUSH
5637: LD_EXP 1
5641: NOT
5642: PPUSH
5643: LD_STRING 12p_
5645: PPUSH
5646: CALL 53478 0 3
5650: ST_TO_ADDR
// if Gladstone then
5651: LD_EXP 29
5655: IFFALSE 5673
// tmp := tmp ^ Gladstone ;
5657: LD_ADDR_VAR 0 7
5661: PUSH
5662: LD_VAR 0 7
5666: PUSH
5667: LD_EXP 29
5671: ADD
5672: ST_TO_ADDR
// Houten := PrepareUnit ( Houten , ( not debug ) , 12p_ ) ;
5673: LD_ADDR_EXP 30
5677: PUSH
5678: LD_STRING Houten
5680: PPUSH
5681: LD_EXP 1
5685: NOT
5686: PPUSH
5687: LD_STRING 12p_
5689: PPUSH
5690: CALL 53478 0 3
5694: ST_TO_ADDR
// if Houten then
5695: LD_EXP 30
5699: IFFALSE 5717
// tmp := tmp ^ Houten ;
5701: LD_ADDR_VAR 0 7
5705: PUSH
5706: LD_VAR 0 7
5710: PUSH
5711: LD_EXP 30
5715: ADD
5716: ST_TO_ADDR
// Cornel := PrepareUnit ( Cornel , ( not debug ) , 12p_ ) ;
5717: LD_ADDR_EXP 31
5721: PUSH
5722: LD_STRING Cornel
5724: PPUSH
5725: LD_EXP 1
5729: NOT
5730: PPUSH
5731: LD_STRING 12p_
5733: PPUSH
5734: CALL 53478 0 3
5738: ST_TO_ADDR
// if Cornel then
5739: LD_EXP 31
5743: IFFALSE 5761
// tmp := tmp ^ Cornel ;
5745: LD_ADDR_VAR 0 7
5749: PUSH
5750: LD_VAR 0 7
5754: PUSH
5755: LD_EXP 31
5759: ADD
5760: ST_TO_ADDR
// Gary := PrepareUnit ( Gary , ( not debug ) , 12p_ ) ;
5761: LD_ADDR_EXP 32
5765: PUSH
5766: LD_STRING Gary
5768: PPUSH
5769: LD_EXP 1
5773: NOT
5774: PPUSH
5775: LD_STRING 12p_
5777: PPUSH
5778: CALL 53478 0 3
5782: ST_TO_ADDR
// if Gary then
5783: LD_EXP 32
5787: IFFALSE 5805
// tmp := tmp ^ Gary ;
5789: LD_ADDR_VAR 0 7
5793: PUSH
5794: LD_VAR 0 7
5798: PUSH
5799: LD_EXP 32
5803: ADD
5804: ST_TO_ADDR
// Kikuchi := PrepareUnit ( Kikuchi , ( not debug ) , 12p_ ) ;
5805: LD_ADDR_EXP 34
5809: PUSH
5810: LD_STRING Kikuchi
5812: PPUSH
5813: LD_EXP 1
5817: NOT
5818: PPUSH
5819: LD_STRING 12p_
5821: PPUSH
5822: CALL 53478 0 3
5826: ST_TO_ADDR
// if Kikuchi then
5827: LD_EXP 34
5831: IFFALSE 5849
// tmp := tmp ^ Kikuchi ;
5833: LD_ADDR_VAR 0 7
5837: PUSH
5838: LD_VAR 0 7
5842: PUSH
5843: LD_EXP 34
5847: ADD
5848: ST_TO_ADDR
// tmp := tmp union CreateCharacterSet ( 12p_others ) ;
5849: LD_ADDR_VAR 0 7
5853: PUSH
5854: LD_VAR 0 7
5858: PUSH
5859: LD_STRING 12p_others
5861: PPUSH
5862: CALL_OW 31
5866: UNION
5867: ST_TO_ADDR
// InitHc_All ( ) ;
5868: CALL_OW 584
// if tmp < 36 then
5872: LD_VAR 0 7
5876: PUSH
5877: LD_INT 36
5879: LESS
5880: IFFALSE 5947
// for i = 1 to 36 - tmp do
5882: LD_ADDR_VAR 0 2
5886: PUSH
5887: DOUBLE
5888: LD_INT 1
5890: DEC
5891: ST_TO_ADDR
5892: LD_INT 36
5894: PUSH
5895: LD_VAR 0 7
5899: MINUS
5900: PUSH
5901: FOR_TO
5902: IFFALSE 5945
// begin PrepareHuman ( sex_male , i mod 4 + 1 , 10 ) ;
5904: LD_INT 1
5906: PPUSH
5907: LD_VAR 0 2
5911: PUSH
5912: LD_INT 4
5914: MOD
5915: PUSH
5916: LD_INT 1
5918: PLUS
5919: PPUSH
5920: LD_INT 10
5922: PPUSH
5923: CALL_OW 380
// tmp := tmp ^ CreateHuman ;
5927: LD_ADDR_VAR 0 7
5931: PUSH
5932: LD_VAR 0 7
5936: PUSH
5937: CALL_OW 44
5941: ADD
5942: ST_TO_ADDR
// end ;
5943: GO 5901
5945: POP
5946: POP
// p := 0 ;
5947: LD_ADDR_VAR 0 6
5951: PUSH
5952: LD_INT 0
5954: ST_TO_ADDR
// for i in tmp do
5955: LD_ADDR_VAR 0 2
5959: PUSH
5960: LD_VAR 0 7
5964: PUSH
5965: FOR_IN
5966: IFFALSE 6018
// begin p := Inc ( p ) ;
5968: LD_ADDR_VAR 0 6
5972: PUSH
5973: LD_VAR 0 6
5977: PPUSH
5978: CALL 92530 0 1
5982: ST_TO_ADDR
// PlaceUnitXYR ( i , 62 , 93 , 9 , false ) ;
5983: LD_VAR 0 2
5987: PPUSH
5988: LD_INT 62
5990: PPUSH
5991: LD_INT 93
5993: PPUSH
5994: LD_INT 9
5996: PPUSH
5997: LD_INT 0
5999: PPUSH
6000: CALL_OW 50
// if p > 36 then
6004: LD_VAR 0 6
6008: PUSH
6009: LD_INT 36
6011: GREATER
6012: IFFALSE 6016
// break ;
6014: GO 6018
// end ;
6016: GO 5965
6018: POP
6019: POP
// mc_bases := Replace ( mc_bases , 4 , FilterAllUnits ( [ f_side , 1 ] ) diff Powell ) ;
6020: LD_ADDR_EXP 80
6024: PUSH
6025: LD_EXP 80
6029: PPUSH
6030: LD_INT 4
6032: PPUSH
6033: LD_INT 22
6035: PUSH
6036: LD_INT 1
6038: PUSH
6039: EMPTY
6040: LIST
6041: LIST
6042: PPUSH
6043: CALL_OW 69
6047: PUSH
6048: LD_EXP 57
6052: DIFF
6053: PPUSH
6054: CALL_OW 1
6058: ST_TO_ADDR
// uc_side := 0 ;
6059: LD_ADDR_OWVAR 20
6063: PUSH
6064: LD_INT 0
6066: ST_TO_ADDR
// uc_nation := 0 ;
6067: LD_ADDR_OWVAR 21
6071: PUSH
6072: LD_INT 0
6074: ST_TO_ADDR
// for i = 1 to 4 do
6075: LD_ADDR_VAR 0 2
6079: PUSH
6080: DOUBLE
6081: LD_INT 1
6083: DEC
6084: ST_TO_ADDR
6085: LD_INT 4
6087: PUSH
6088: FOR_TO
6089: IFFALSE 6120
// begin InitHc ;
6091: CALL_OW 19
// hc_class := class_apeman ;
6095: LD_ADDR_OWVAR 28
6099: PUSH
6100: LD_INT 12
6102: ST_TO_ADDR
// PlaceUnitArea ( CreateHuman , powellApe , false ) ;
6103: CALL_OW 44
6107: PPUSH
6108: LD_INT 11
6110: PPUSH
6111: LD_INT 0
6113: PPUSH
6114: CALL_OW 49
// end ;
6118: GO 6088
6120: POP
6121: POP
// end ;
6122: LD_VAR 0 1
6126: RET
// every 9 9$30 + 7 7$00 trigger not americanDestroyed do var i , tmp , target , p ;
6127: LD_EXP 4
6131: NOT
6132: IFFALSE 7041
6134: GO 6136
6136: DISABLE
6137: LD_INT 0
6139: PPUSH
6140: PPUSH
6141: PPUSH
6142: PPUSH
// begin enable ;
6143: ENABLE
// if not FilterAllUnits ( [ [ f_side , 1 ] , [ f_nation , 1 ] , [ f_btype , b_factory ] ] ) then
6144: LD_INT 22
6146: PUSH
6147: LD_INT 1
6149: PUSH
6150: EMPTY
6151: LIST
6152: LIST
6153: PUSH
6154: LD_INT 23
6156: PUSH
6157: LD_INT 1
6159: PUSH
6160: EMPTY
6161: LIST
6162: LIST
6163: PUSH
6164: LD_INT 30
6166: PUSH
6167: LD_INT 3
6169: PUSH
6170: EMPTY
6171: LIST
6172: LIST
6173: PUSH
6174: EMPTY
6175: LIST
6176: LIST
6177: LIST
6178: PPUSH
6179: CALL_OW 69
6183: NOT
6184: IFFALSE 6188
// exit ;
6186: GO 7041
// if Prob ( 40 ) then
6188: LD_INT 40
6190: PPUSH
6191: CALL_OW 13
6195: IFFALSE 6322
// begin MC_InsertProduceList ( 4 , [ [ us_morphling , engine_combustion , control_remote , us_rocket_launcher ] , [ us_morphling , engine_combustion , control_remote , us_rocket_launcher ] , [ us_morphling , engine_combustion , control_remote , us_rocket_launcher ] , [ us_morphling , engine_combustion , control_remote , us_heavy_gun ] , [ us_morphling , engine_combustion , control_remote , us_heavy_gun ] , [ us_morphling , engine_combustion , control_remote , us_heavy_gun ] , ] ) ;
6197: LD_INT 4
6199: PPUSH
6200: LD_INT 5
6202: PUSH
6203: LD_INT 1
6205: PUSH
6206: LD_INT 2
6208: PUSH
6209: LD_INT 7
6211: PUSH
6212: EMPTY
6213: LIST
6214: LIST
6215: LIST
6216: LIST
6217: PUSH
6218: LD_INT 5
6220: PUSH
6221: LD_INT 1
6223: PUSH
6224: LD_INT 2
6226: PUSH
6227: LD_INT 7
6229: PUSH
6230: EMPTY
6231: LIST
6232: LIST
6233: LIST
6234: LIST
6235: PUSH
6236: LD_INT 5
6238: PUSH
6239: LD_INT 1
6241: PUSH
6242: LD_INT 2
6244: PUSH
6245: LD_INT 7
6247: PUSH
6248: EMPTY
6249: LIST
6250: LIST
6251: LIST
6252: LIST
6253: PUSH
6254: LD_INT 5
6256: PUSH
6257: LD_INT 1
6259: PUSH
6260: LD_INT 2
6262: PUSH
6263: LD_INT 6
6265: PUSH
6266: EMPTY
6267: LIST
6268: LIST
6269: LIST
6270: LIST
6271: PUSH
6272: LD_INT 5
6274: PUSH
6275: LD_INT 1
6277: PUSH
6278: LD_INT 2
6280: PUSH
6281: LD_INT 6
6283: PUSH
6284: EMPTY
6285: LIST
6286: LIST
6287: LIST
6288: LIST
6289: PUSH
6290: LD_INT 5
6292: PUSH
6293: LD_INT 1
6295: PUSH
6296: LD_INT 2
6298: PUSH
6299: LD_INT 6
6301: PUSH
6302: EMPTY
6303: LIST
6304: LIST
6305: LIST
6306: LIST
6307: PUSH
6308: EMPTY
6309: LIST
6310: LIST
6311: LIST
6312: LIST
6313: LIST
6314: LIST
6315: PPUSH
6316: CALL 47052 0 2
// end else
6320: GO 6445
// begin MC_InsertProduceList ( 4 , [ [ us_morphling , engine_combustion , control_remote , us_rocket_launcher ] , [ us_morphling , engine_combustion , control_remote , us_laser ] , [ us_morphling , engine_combustion , control_remote , us_laser ] , [ us_morphling , engine_combustion , control_remote , us_heavy_gun ] , [ us_morphling , engine_combustion , control_remote , us_heavy_gun ] , [ us_morphling , engine_combustion , control_remote , us_heavy_gun ] , ] ) ;
6322: LD_INT 4
6324: PPUSH
6325: LD_INT 5
6327: PUSH
6328: LD_INT 1
6330: PUSH
6331: LD_INT 2
6333: PUSH
6334: LD_INT 7
6336: PUSH
6337: EMPTY
6338: LIST
6339: LIST
6340: LIST
6341: LIST
6342: PUSH
6343: LD_INT 5
6345: PUSH
6346: LD_INT 1
6348: PUSH
6349: LD_INT 2
6351: PUSH
6352: LD_INT 9
6354: PUSH
6355: EMPTY
6356: LIST
6357: LIST
6358: LIST
6359: LIST
6360: PUSH
6361: LD_INT 5
6363: PUSH
6364: LD_INT 1
6366: PUSH
6367: LD_INT 2
6369: PUSH
6370: LD_INT 9
6372: PUSH
6373: EMPTY
6374: LIST
6375: LIST
6376: LIST
6377: LIST
6378: PUSH
6379: LD_INT 5
6381: PUSH
6382: LD_INT 1
6384: PUSH
6385: LD_INT 2
6387: PUSH
6388: LD_INT 6
6390: PUSH
6391: EMPTY
6392: LIST
6393: LIST
6394: LIST
6395: LIST
6396: PUSH
6397: LD_INT 5
6399: PUSH
6400: LD_INT 1
6402: PUSH
6403: LD_INT 2
6405: PUSH
6406: LD_INT 6
6408: PUSH
6409: EMPTY
6410: LIST
6411: LIST
6412: LIST
6413: LIST
6414: PUSH
6415: LD_INT 5
6417: PUSH
6418: LD_INT 1
6420: PUSH
6421: LD_INT 2
6423: PUSH
6424: LD_INT 6
6426: PUSH
6427: EMPTY
6428: LIST
6429: LIST
6430: LIST
6431: LIST
6432: PUSH
6433: EMPTY
6434: LIST
6435: LIST
6436: LIST
6437: LIST
6438: LIST
6439: LIST
6440: PPUSH
6441: CALL 47052 0 2
// end ; p := 0 ;
6445: LD_ADDR_VAR 0 4
6449: PUSH
6450: LD_INT 0
6452: ST_TO_ADDR
// repeat wait ( 0 0$1 ) ;
6453: LD_INT 35
6455: PPUSH
6456: CALL_OW 67
// p := Inc ( p ) ;
6460: LD_ADDR_VAR 0 4
6464: PUSH
6465: LD_VAR 0 4
6469: PPUSH
6470: CALL 92530 0 1
6474: ST_TO_ADDR
// until MC_GetVehicles ( 4 , true ) >= 6 or p > 100 ;
6475: LD_INT 4
6477: PPUSH
6478: LD_INT 1
6480: PPUSH
6481: CALL 48470 0 2
6485: PUSH
6486: LD_INT 6
6488: GREATEREQUAL
6489: PUSH
6490: LD_VAR 0 4
6494: PUSH
6495: LD_INT 100
6497: GREATER
6498: OR
6499: IFFALSE 6453
// wait ( 0 0$30 ) ;
6501: LD_INT 1050
6503: PPUSH
6504: CALL_OW 67
// tmp := FilterAllUnits ( [ [ f_side , 1 ] , [ f_type , unit_vehicle ] , [ f_not , [ f_weapon , us_siberium_rocket ] , [ f_weapon , us_cargo_bay ] , [ f_weapon , us_crane ] ] ] ) diff mc_defender [ 4 ] ;
6508: LD_ADDR_VAR 0 2
6512: PUSH
6513: LD_INT 22
6515: PUSH
6516: LD_INT 1
6518: PUSH
6519: EMPTY
6520: LIST
6521: LIST
6522: PUSH
6523: LD_INT 21
6525: PUSH
6526: LD_INT 2
6528: PUSH
6529: EMPTY
6530: LIST
6531: LIST
6532: PUSH
6533: LD_INT 3
6535: PUSH
6536: LD_INT 34
6538: PUSH
6539: LD_INT 8
6541: PUSH
6542: EMPTY
6543: LIST
6544: LIST
6545: PUSH
6546: LD_INT 34
6548: PUSH
6549: LD_INT 12
6551: PUSH
6552: EMPTY
6553: LIST
6554: LIST
6555: PUSH
6556: LD_INT 34
6558: PUSH
6559: LD_INT 13
6561: PUSH
6562: EMPTY
6563: LIST
6564: LIST
6565: PUSH
6566: EMPTY
6567: LIST
6568: LIST
6569: LIST
6570: LIST
6571: PUSH
6572: EMPTY
6573: LIST
6574: LIST
6575: LIST
6576: PPUSH
6577: CALL_OW 69
6581: PUSH
6582: LD_EXP 102
6586: PUSH
6587: LD_INT 4
6589: ARRAY
6590: DIFF
6591: ST_TO_ADDR
// mc_vehicles := Replace ( mc_vehicles , 4 , mc_vehicles [ 4 ] diff tmp ) ;
6592: LD_ADDR_EXP 99
6596: PUSH
6597: LD_EXP 99
6601: PPUSH
6602: LD_INT 4
6604: PPUSH
6605: LD_EXP 99
6609: PUSH
6610: LD_INT 4
6612: ARRAY
6613: PUSH
6614: LD_VAR 0 2
6618: DIFF
6619: PPUSH
6620: CALL_OW 1
6624: ST_TO_ADDR
// target := rand ( 0 , 2 ) ;
6625: LD_ADDR_VAR 0 3
6629: PUSH
6630: LD_INT 0
6632: PPUSH
6633: LD_INT 2
6635: PPUSH
6636: CALL_OW 12
6640: ST_TO_ADDR
// p := 0 ;
6641: LD_ADDR_VAR 0 4
6645: PUSH
6646: LD_INT 0
6648: ST_TO_ADDR
// if target then
6649: LD_VAR 0 3
6653: IFFALSE 6806
// begin repeat tmp := UnitFilter ( tmp , [ f_lives , 250 ] ) ;
6655: LD_ADDR_VAR 0 2
6659: PUSH
6660: LD_VAR 0 2
6664: PPUSH
6665: LD_INT 24
6667: PUSH
6668: LD_INT 250
6670: PUSH
6671: EMPTY
6672: LIST
6673: LIST
6674: PPUSH
6675: CALL_OW 72
6679: ST_TO_ADDR
// for i in tmp do
6680: LD_ADDR_VAR 0 1
6684: PUSH
6685: LD_VAR 0 2
6689: PUSH
6690: FOR_IN
6691: IFFALSE 6731
// if GetDistUnitXY ( i , 114 , 108 ) > 9 then
6693: LD_VAR 0 1
6697: PPUSH
6698: LD_INT 114
6700: PPUSH
6701: LD_INT 108
6703: PPUSH
6704: CALL_OW 297
6708: PUSH
6709: LD_INT 9
6711: GREATER
6712: IFFALSE 6729
// ComMoveXY ( i , 114 , 108 ) ;
6714: LD_VAR 0 1
6718: PPUSH
6719: LD_INT 114
6721: PPUSH
6722: LD_INT 108
6724: PPUSH
6725: CALL_OW 111
6729: GO 6690
6731: POP
6732: POP
// wait ( 0 0$1 ) ;
6733: LD_INT 35
6735: PPUSH
6736: CALL_OW 67
// p := Inc ( p ) ;
6740: LD_ADDR_VAR 0 4
6744: PUSH
6745: LD_VAR 0 4
6749: PPUSH
6750: CALL 92530 0 1
6754: ST_TO_ADDR
// until UnitFilter ( tmp , [ f_distxy , 114 , 108 , 9 ] ) >= ( tmp - 1 ) or p > 30 ;
6755: LD_VAR 0 2
6759: PPUSH
6760: LD_INT 92
6762: PUSH
6763: LD_INT 114
6765: PUSH
6766: LD_INT 108
6768: PUSH
6769: LD_INT 9
6771: PUSH
6772: EMPTY
6773: LIST
6774: LIST
6775: LIST
6776: LIST
6777: PPUSH
6778: CALL_OW 72
6782: PUSH
6783: LD_VAR 0 2
6787: PUSH
6788: LD_INT 1
6790: MINUS
6791: GREATEREQUAL
6792: PUSH
6793: LD_VAR 0 4
6797: PUSH
6798: LD_INT 30
6800: GREATER
6801: OR
6802: IFFALSE 6655
// end else
6804: GO 6955
// begin repeat tmp := UnitFilter ( tmp , [ f_lives , 250 ] ) ;
6806: LD_ADDR_VAR 0 2
6810: PUSH
6811: LD_VAR 0 2
6815: PPUSH
6816: LD_INT 24
6818: PUSH
6819: LD_INT 250
6821: PUSH
6822: EMPTY
6823: LIST
6824: LIST
6825: PPUSH
6826: CALL_OW 72
6830: ST_TO_ADDR
// for i in tmp do
6831: LD_ADDR_VAR 0 1
6835: PUSH
6836: LD_VAR 0 2
6840: PUSH
6841: FOR_IN
6842: IFFALSE 6882
// if GetDistUnitXY ( i , 129 , 139 ) > 9 then
6844: LD_VAR 0 1
6848: PPUSH
6849: LD_INT 129
6851: PPUSH
6852: LD_INT 139
6854: PPUSH
6855: CALL_OW 297
6859: PUSH
6860: LD_INT 9
6862: GREATER
6863: IFFALSE 6880
// ComMoveXY ( i , 129 , 139 ) ;
6865: LD_VAR 0 1
6869: PPUSH
6870: LD_INT 129
6872: PPUSH
6873: LD_INT 139
6875: PPUSH
6876: CALL_OW 111
6880: GO 6841
6882: POP
6883: POP
// wait ( 0 0$1 ) ;
6884: LD_INT 35
6886: PPUSH
6887: CALL_OW 67
// p := Inc ( p ) ;
6891: LD_ADDR_VAR 0 4
6895: PUSH
6896: LD_VAR 0 4
6900: PPUSH
6901: CALL 92530 0 1
6905: ST_TO_ADDR
// until UnitFilter ( tmp , [ f_distxy , 129 , 139 , 9 ] ) >= ( tmp - 1 ) or p > 30 ;
6906: LD_VAR 0 2
6910: PPUSH
6911: LD_INT 92
6913: PUSH
6914: LD_INT 129
6916: PUSH
6917: LD_INT 139
6919: PUSH
6920: LD_INT 9
6922: PUSH
6923: EMPTY
6924: LIST
6925: LIST
6926: LIST
6927: LIST
6928: PPUSH
6929: CALL_OW 72
6933: PUSH
6934: LD_VAR 0 2
6938: PUSH
6939: LD_INT 1
6941: MINUS
6942: GREATEREQUAL
6943: PUSH
6944: LD_VAR 0 4
6948: PUSH
6949: LD_INT 30
6951: GREATER
6952: OR
6953: IFFALSE 6806
// end ; repeat wait ( 0 0$1 ) ;
6955: LD_INT 35
6957: PPUSH
6958: CALL_OW 67
// tmp := UnitFilter ( tmp , [ f_ok ] ) ;
6962: LD_ADDR_VAR 0 2
6966: PUSH
6967: LD_VAR 0 2
6971: PPUSH
6972: LD_INT 50
6974: PUSH
6975: EMPTY
6976: LIST
6977: PPUSH
6978: CALL_OW 72
6982: ST_TO_ADDR
// for i in tmp do
6983: LD_ADDR_VAR 0 1
6987: PUSH
6988: LD_VAR 0 2
6992: PUSH
6993: FOR_IN
6994: IFFALSE 7032
// ComAttackUnit ( i , NearestUnitToUnit ( FilterAllUnits ( [ f_enemy , 1 ] ) , i ) ) ;
6996: LD_VAR 0 1
7000: PPUSH
7001: LD_INT 81
7003: PUSH
7004: LD_INT 1
7006: PUSH
7007: EMPTY
7008: LIST
7009: LIST
7010: PPUSH
7011: CALL_OW 69
7015: PPUSH
7016: LD_VAR 0 1
7020: PPUSH
7021: CALL_OW 74
7025: PPUSH
7026: CALL_OW 115
7030: GO 6993
7032: POP
7033: POP
// until not tmp ;
7034: LD_VAR 0 2
7038: NOT
7039: IFFALSE 6955
// end ;
7041: PPOPN 4
7043: END
// every 30 30$00 trigger not americanDestroyed do
7044: LD_EXP 4
7048: NOT
7049: IFFALSE 7118
7051: GO 7053
7053: DISABLE
// begin wait ( [ 30 30$00 , 20 20$00 , 15 15$00 , 10 10$00 ] [ Difficulty ] ) ;
7054: LD_INT 63000
7056: PUSH
7057: LD_INT 42000
7059: PUSH
7060: LD_INT 31500
7062: PUSH
7063: LD_INT 21000
7065: PUSH
7066: EMPTY
7067: LIST
7068: LIST
7069: LIST
7070: LIST
7071: PUSH
7072: LD_OWVAR 67
7076: ARRAY
7077: PPUSH
7078: CALL_OW 67
// if americanDestroyed then
7082: LD_EXP 4
7086: IFFALSE 7090
// exit ;
7088: GO 7118
// MC_InsertProduceList ( 4 , [ [ us_morphling , engine_siberite , control_manual , us_siberium_rocket ] ] ) ;
7090: LD_INT 4
7092: PPUSH
7093: LD_INT 5
7095: PUSH
7096: LD_INT 3
7098: PUSH
7099: LD_INT 1
7101: PUSH
7102: LD_INT 8
7104: PUSH
7105: EMPTY
7106: LIST
7107: LIST
7108: LIST
7109: LIST
7110: PUSH
7111: EMPTY
7112: LIST
7113: PPUSH
7114: CALL 47052 0 2
// end ; end_of_file
7118: END
// export function PrepareArabian ; var i , un , tmp , side ; begin
7119: LD_INT 0
7121: PPUSH
7122: PPUSH
7123: PPUSH
7124: PPUSH
7125: PPUSH
// side := 2 ;
7126: LD_ADDR_VAR 0 5
7130: PUSH
7131: LD_INT 2
7133: ST_TO_ADDR
// InitHc ;
7134: CALL_OW 19
// uc_side := side ;
7138: LD_ADDR_OWVAR 20
7142: PUSH
7143: LD_VAR 0 5
7147: ST_TO_ADDR
// uc_nation := 2 ;
7148: LD_ADDR_OWVAR 21
7152: PUSH
7153: LD_INT 2
7155: ST_TO_ADDR
// for i in FilterAllUnits ( [ [ f_side , 2 ] , [ f_type , unit_building ] ] ) do
7156: LD_ADDR_VAR 0 2
7160: PUSH
7161: LD_INT 22
7163: PUSH
7164: LD_INT 2
7166: PUSH
7167: EMPTY
7168: LIST
7169: LIST
7170: PUSH
7171: LD_INT 21
7173: PUSH
7174: LD_INT 3
7176: PUSH
7177: EMPTY
7178: LIST
7179: LIST
7180: PUSH
7181: EMPTY
7182: LIST
7183: LIST
7184: PPUSH
7185: CALL_OW 69
7189: PUSH
7190: FOR_IN
7191: IFFALSE 7207
// SetBLevel ( i , 10 ) ;
7193: LD_VAR 0 2
7197: PPUSH
7198: LD_INT 10
7200: PPUSH
7201: CALL_OW 241
7205: GO 7190
7207: POP
7208: POP
// tmp := FilterAllUnits ( [ [ f_side , side ] , [ f_btype , b_bunker ] , [ f_empty ] ] ) ;
7209: LD_ADDR_VAR 0 4
7213: PUSH
7214: LD_INT 22
7216: PUSH
7217: LD_VAR 0 5
7221: PUSH
7222: EMPTY
7223: LIST
7224: LIST
7225: PUSH
7226: LD_INT 30
7228: PUSH
7229: LD_INT 32
7231: PUSH
7232: EMPTY
7233: LIST
7234: LIST
7235: PUSH
7236: LD_INT 58
7238: PUSH
7239: EMPTY
7240: LIST
7241: PUSH
7242: EMPTY
7243: LIST
7244: LIST
7245: LIST
7246: PPUSH
7247: CALL_OW 69
7251: ST_TO_ADDR
// for i = 1 to 10 do
7252: LD_ADDR_VAR 0 2
7256: PUSH
7257: DOUBLE
7258: LD_INT 1
7260: DEC
7261: ST_TO_ADDR
7262: LD_INT 10
7264: PUSH
7265: FOR_TO
7266: IFFALSE 7338
// begin uc_nation := nation_nature ;
7268: LD_ADDR_OWVAR 21
7272: PUSH
7273: LD_INT 0
7275: ST_TO_ADDR
// hc_class := class_apeman_soldier ;
7276: LD_ADDR_OWVAR 28
7280: PUSH
7281: LD_INT 15
7283: ST_TO_ADDR
// hc_gallery :=  ;
7284: LD_ADDR_OWVAR 33
7288: PUSH
7289: LD_STRING 
7291: ST_TO_ADDR
// hc_name :=  ;
7292: LD_ADDR_OWVAR 26
7296: PUSH
7297: LD_STRING 
7299: ST_TO_ADDR
// un := CreateHuman ;
7300: LD_ADDR_VAR 0 3
7304: PUSH
7305: CALL_OW 44
7309: ST_TO_ADDR
// PlaceHumanInUnit ( un , tmp [ tmp - i ] ) ;
7310: LD_VAR 0 3
7314: PPUSH
7315: LD_VAR 0 4
7319: PUSH
7320: LD_VAR 0 4
7324: PUSH
7325: LD_VAR 0 2
7329: MINUS
7330: ARRAY
7331: PPUSH
7332: CALL_OW 52
// end ;
7336: GO 7265
7338: POP
7339: POP
// PrepareBase ( ar_depot , arabianBaseArea ,  , [ 8 , 9 , 10 , 10 ] [ Difficulty ] , [ 3000 , 500 , 150 ] , [ 16 , 6 , 6 , 6 ] ) ;
7340: LD_INT 503
7342: PPUSH
7343: LD_INT 27
7345: PPUSH
7346: LD_STRING 
7348: PPUSH
7349: LD_INT 8
7351: PUSH
7352: LD_INT 9
7354: PUSH
7355: LD_INT 10
7357: PUSH
7358: LD_INT 10
7360: PUSH
7361: EMPTY
7362: LIST
7363: LIST
7364: LIST
7365: LIST
7366: PUSH
7367: LD_OWVAR 67
7371: ARRAY
7372: PPUSH
7373: LD_INT 3000
7375: PUSH
7376: LD_INT 500
7378: PUSH
7379: LD_INT 150
7381: PUSH
7382: EMPTY
7383: LIST
7384: LIST
7385: LIST
7386: PPUSH
7387: LD_INT 16
7389: PUSH
7390: LD_INT 6
7392: PUSH
7393: LD_INT 6
7395: PUSH
7396: LD_INT 6
7398: PUSH
7399: EMPTY
7400: LIST
7401: LIST
7402: LIST
7403: LIST
7404: PPUSH
7405: CALL 62139 0 6
// mc_bases := Replace ( mc_bases , 1 , FilterAllUnits ( [ [ f_side , side ] , [ f_nation , 2 ] , [ f_not , [ f_type , unit_vehicle ] ] ] ) ) ;
7409: LD_ADDR_EXP 80
7413: PUSH
7414: LD_EXP 80
7418: PPUSH
7419: LD_INT 1
7421: PPUSH
7422: LD_INT 22
7424: PUSH
7425: LD_VAR 0 5
7429: PUSH
7430: EMPTY
7431: LIST
7432: LIST
7433: PUSH
7434: LD_INT 23
7436: PUSH
7437: LD_INT 2
7439: PUSH
7440: EMPTY
7441: LIST
7442: LIST
7443: PUSH
7444: LD_INT 3
7446: PUSH
7447: LD_INT 21
7449: PUSH
7450: LD_INT 2
7452: PUSH
7453: EMPTY
7454: LIST
7455: LIST
7456: PUSH
7457: EMPTY
7458: LIST
7459: LIST
7460: PUSH
7461: EMPTY
7462: LIST
7463: LIST
7464: LIST
7465: PPUSH
7466: CALL_OW 69
7470: PPUSH
7471: CALL_OW 1
7475: ST_TO_ADDR
// HiddenCamera ( 216 , 228 , 2 ) ;
7476: LD_INT 216
7478: PPUSH
7479: LD_INT 228
7481: PPUSH
7482: LD_INT 2
7484: PPUSH
7485: CALL_OW 244
// HiddenCamera ( 223 , 241 , 2 ) ;
7489: LD_INT 223
7491: PPUSH
7492: LD_INT 241
7494: PPUSH
7495: LD_INT 2
7497: PPUSH
7498: CALL_OW 244
// HiddenCamera ( 216 , 217 , 2 ) ;
7502: LD_INT 216
7504: PPUSH
7505: LD_INT 217
7507: PPUSH
7508: LD_INT 2
7510: PPUSH
7511: CALL_OW 244
// HiddenCamera ( 233 , 257 , 2 ) ;
7515: LD_INT 233
7517: PPUSH
7518: LD_INT 257
7520: PPUSH
7521: LD_INT 2
7523: PPUSH
7524: CALL_OW 244
// HiddenCamera ( 230 , 199 , 2 ) ;
7528: LD_INT 230
7530: PPUSH
7531: LD_INT 199
7533: PPUSH
7534: LD_INT 2
7536: PPUSH
7537: CALL_OW 244
// end ;
7541: LD_VAR 0 1
7545: RET
// export Omar ; export function PrepareOmarAli ; begin
7546: LD_INT 0
7548: PPUSH
// uc_side := 5 ;
7549: LD_ADDR_OWVAR 20
7553: PUSH
7554: LD_INT 5
7556: ST_TO_ADDR
// uc_nation := 2 ;
7557: LD_ADDR_OWVAR 21
7561: PUSH
7562: LD_INT 2
7564: ST_TO_ADDR
// Omar := NewCharacter ( Omar ) ;
7565: LD_ADDR_EXP 58
7569: PUSH
7570: LD_STRING Omar
7572: PPUSH
7573: CALL_OW 25
7577: ST_TO_ADDR
// PlaceUnitXY ( Omar , 330 , 244 , false ) ;
7578: LD_EXP 58
7582: PPUSH
7583: LD_INT 330
7585: PPUSH
7586: LD_INT 244
7588: PPUSH
7589: LD_INT 0
7591: PPUSH
7592: CALL_OW 48
// ComMoveXY ( Omar , 252 , 220 ) ;
7596: LD_EXP 58
7600: PPUSH
7601: LD_INT 252
7603: PPUSH
7604: LD_INT 220
7606: PPUSH
7607: CALL_OW 111
// end ;
7611: LD_VAR 0 1
7615: RET
// export function PrepareOmarAli2 ; begin
7616: LD_INT 0
7618: PPUSH
// uc_side := 5 ;
7619: LD_ADDR_OWVAR 20
7623: PUSH
7624: LD_INT 5
7626: ST_TO_ADDR
// uc_nation := 2 ;
7627: LD_ADDR_OWVAR 21
7631: PUSH
7632: LD_INT 2
7634: ST_TO_ADDR
// Omar := NewCharacter ( Omar ) ;
7635: LD_ADDR_EXP 58
7639: PUSH
7640: LD_STRING Omar
7642: PPUSH
7643: CALL_OW 25
7647: ST_TO_ADDR
// PlaceUnitXY ( Omar , 289 , 164 , false ) ;
7648: LD_EXP 58
7652: PPUSH
7653: LD_INT 289
7655: PPUSH
7656: LD_INT 164
7658: PPUSH
7659: LD_INT 0
7661: PPUSH
7662: CALL_OW 48
// ComMoveXY ( Omar , 254 , 166 ) ;
7666: LD_EXP 58
7670: PPUSH
7671: LD_INT 254
7673: PPUSH
7674: LD_INT 166
7676: PPUSH
7677: CALL_OW 111
// end ; end_of_file
7681: LD_VAR 0 1
7685: RET
// export Schulz , Kozlov , Kaia ; export function PrepareLegion ; var i , side , un , tmp ; begin
7686: LD_INT 0
7688: PPUSH
7689: PPUSH
7690: PPUSH
7691: PPUSH
7692: PPUSH
// side := 8 ;
7693: LD_ADDR_VAR 0 3
7697: PUSH
7698: LD_INT 8
7700: ST_TO_ADDR
// InitHc ;
7701: CALL_OW 19
// uc_side := side ;
7705: LD_ADDR_OWVAR 20
7709: PUSH
7710: LD_VAR 0 3
7714: ST_TO_ADDR
// uc_nation := 2 ;
7715: LD_ADDR_OWVAR 21
7719: PUSH
7720: LD_INT 2
7722: ST_TO_ADDR
// for i in FilterAllUnits ( [ [ f_side , side ] , [ f_type , unit_building ] ] ) do
7723: LD_ADDR_VAR 0 2
7727: PUSH
7728: LD_INT 22
7730: PUSH
7731: LD_VAR 0 3
7735: PUSH
7736: EMPTY
7737: LIST
7738: LIST
7739: PUSH
7740: LD_INT 21
7742: PUSH
7743: LD_INT 3
7745: PUSH
7746: EMPTY
7747: LIST
7748: LIST
7749: PUSH
7750: EMPTY
7751: LIST
7752: LIST
7753: PPUSH
7754: CALL_OW 69
7758: PUSH
7759: FOR_IN
7760: IFFALSE 7776
// SetBLevel ( i , 10 ) ;
7762: LD_VAR 0 2
7766: PPUSH
7767: LD_INT 10
7769: PPUSH
7770: CALL_OW 241
7774: GO 7759
7776: POP
7777: POP
// Schulz := NewCharacter ( Schulz ) ;
7778: LD_ADDR_EXP 59
7782: PUSH
7783: LD_STRING Schulz
7785: PPUSH
7786: CALL_OW 25
7790: ST_TO_ADDR
// Kaia := NewCharacter ( Kaia ) ;
7791: LD_ADDR_EXP 61
7795: PUSH
7796: LD_STRING Kaia
7798: PPUSH
7799: CALL_OW 25
7803: ST_TO_ADDR
// PlaceHumanInUnit ( Kaia , ar_depot1 ) ;
7804: LD_EXP 61
7808: PPUSH
7809: LD_INT 324
7811: PPUSH
7812: CALL_OW 52
// Kozlov := PrepareUnit ( Kozlov , false ,  ) ;
7816: LD_ADDR_EXP 60
7820: PUSH
7821: LD_STRING Kozlov
7823: PPUSH
7824: LD_INT 0
7826: PPUSH
7827: LD_STRING 
7829: PPUSH
7830: CALL 53478 0 3
7834: ST_TO_ADDR
// PlaceHumanInUnit ( Kozlov , FilterAllUnits ( [ [ f_side , 8 ] , [ f_nation , 3 ] , [ f_btype , b_lab_full ] ] ) [ 1 ] ) ;
7835: LD_EXP 60
7839: PPUSH
7840: LD_INT 22
7842: PUSH
7843: LD_INT 8
7845: PUSH
7846: EMPTY
7847: LIST
7848: LIST
7849: PUSH
7850: LD_INT 23
7852: PUSH
7853: LD_INT 3
7855: PUSH
7856: EMPTY
7857: LIST
7858: LIST
7859: PUSH
7860: LD_INT 30
7862: PUSH
7863: LD_INT 8
7865: PUSH
7866: EMPTY
7867: LIST
7868: LIST
7869: PUSH
7870: EMPTY
7871: LIST
7872: LIST
7873: LIST
7874: PPUSH
7875: CALL_OW 69
7879: PUSH
7880: LD_INT 1
7882: ARRAY
7883: PPUSH
7884: CALL_OW 52
// SetSkill ( Kozlov , class_mechanic , 10 ) ;
7888: LD_EXP 60
7892: PPUSH
7893: LD_INT 3
7895: PPUSH
7896: LD_INT 10
7898: PPUSH
7899: CALL_OW 237
// tmp := FilterAllUnits ( [ [ f_side , side ] , [ f_btype , b_bunker ] , [ f_empty ] ] ) ;
7903: LD_ADDR_VAR 0 5
7907: PUSH
7908: LD_INT 22
7910: PUSH
7911: LD_VAR 0 3
7915: PUSH
7916: EMPTY
7917: LIST
7918: LIST
7919: PUSH
7920: LD_INT 30
7922: PUSH
7923: LD_INT 32
7925: PUSH
7926: EMPTY
7927: LIST
7928: LIST
7929: PUSH
7930: LD_INT 58
7932: PUSH
7933: EMPTY
7934: LIST
7935: PUSH
7936: EMPTY
7937: LIST
7938: LIST
7939: LIST
7940: PPUSH
7941: CALL_OW 69
7945: ST_TO_ADDR
// for i = 1 to 10 do
7946: LD_ADDR_VAR 0 2
7950: PUSH
7951: DOUBLE
7952: LD_INT 1
7954: DEC
7955: ST_TO_ADDR
7956: LD_INT 10
7958: PUSH
7959: FOR_TO
7960: IFFALSE 8032
// begin uc_nation := nation_nature ;
7962: LD_ADDR_OWVAR 21
7966: PUSH
7967: LD_INT 0
7969: ST_TO_ADDR
// hc_class := class_apeman_soldier ;
7970: LD_ADDR_OWVAR 28
7974: PUSH
7975: LD_INT 15
7977: ST_TO_ADDR
// hc_gallery :=  ;
7978: LD_ADDR_OWVAR 33
7982: PUSH
7983: LD_STRING 
7985: ST_TO_ADDR
// hc_name :=  ;
7986: LD_ADDR_OWVAR 26
7990: PUSH
7991: LD_STRING 
7993: ST_TO_ADDR
// un := CreateHuman ;
7994: LD_ADDR_VAR 0 4
7998: PUSH
7999: CALL_OW 44
8003: ST_TO_ADDR
// PlaceHumanInUnit ( un , tmp [ tmp - i ] ) ;
8004: LD_VAR 0 4
8008: PPUSH
8009: LD_VAR 0 5
8013: PUSH
8014: LD_VAR 0 5
8018: PUSH
8019: LD_VAR 0 2
8023: MINUS
8024: ARRAY
8025: PPUSH
8026: CALL_OW 52
// end ;
8030: GO 7959
8032: POP
8033: POP
// PrepareBase ( ar_depot1 , legionBaseArea ,  , [ 8 , 9 , 10 , 10 ] [ Difficulty ] , [ 3000 , 500 , 150 ] , [ 16 , 6 , 6 , 8 ] ) ;
8034: LD_INT 324
8036: PPUSH
8037: LD_INT 3
8039: PPUSH
8040: LD_STRING 
8042: PPUSH
8043: LD_INT 8
8045: PUSH
8046: LD_INT 9
8048: PUSH
8049: LD_INT 10
8051: PUSH
8052: LD_INT 10
8054: PUSH
8055: EMPTY
8056: LIST
8057: LIST
8058: LIST
8059: LIST
8060: PUSH
8061: LD_OWVAR 67
8065: ARRAY
8066: PPUSH
8067: LD_INT 3000
8069: PUSH
8070: LD_INT 500
8072: PUSH
8073: LD_INT 150
8075: PUSH
8076: EMPTY
8077: LIST
8078: LIST
8079: LIST
8080: PPUSH
8081: LD_INT 16
8083: PUSH
8084: LD_INT 6
8086: PUSH
8087: LD_INT 6
8089: PUSH
8090: LD_INT 8
8092: PUSH
8093: EMPTY
8094: LIST
8095: LIST
8096: LIST
8097: LIST
8098: PPUSH
8099: CALL 62139 0 6
// mc_bases := Replace ( mc_bases , 3 , FilterAllUnits ( [ [ f_side , side ] , [ f_nation , 2 ] , [ f_not , [ f_type , unit_vehicle ] ] ] ) diff Schulz ) ;
8103: LD_ADDR_EXP 80
8107: PUSH
8108: LD_EXP 80
8112: PPUSH
8113: LD_INT 3
8115: PPUSH
8116: LD_INT 22
8118: PUSH
8119: LD_VAR 0 3
8123: PUSH
8124: EMPTY
8125: LIST
8126: LIST
8127: PUSH
8128: LD_INT 23
8130: PUSH
8131: LD_INT 2
8133: PUSH
8134: EMPTY
8135: LIST
8136: LIST
8137: PUSH
8138: LD_INT 3
8140: PUSH
8141: LD_INT 21
8143: PUSH
8144: LD_INT 2
8146: PUSH
8147: EMPTY
8148: LIST
8149: LIST
8150: PUSH
8151: EMPTY
8152: LIST
8153: LIST
8154: PUSH
8155: EMPTY
8156: LIST
8157: LIST
8158: LIST
8159: PPUSH
8160: CALL_OW 69
8164: PUSH
8165: LD_EXP 59
8169: DIFF
8170: PPUSH
8171: CALL_OW 1
8175: ST_TO_ADDR
// end ;
8176: LD_VAR 0 1
8180: RET
// export function BuildKozlovBomb ; begin
8181: LD_INT 0
8183: PPUSH
// if not IsOk ( kozlov_fac ) or not IsOk ( kozlov_lab ) then
8184: LD_INT 332
8186: PPUSH
8187: CALL_OW 302
8191: NOT
8192: PUSH
8193: LD_INT 336
8195: PPUSH
8196: CALL_OW 302
8200: NOT
8201: OR
8202: IFFALSE 8206
// exit ;
8204: GO 8303
// ComChangeProfession ( Kozlov , 4 ) ;
8206: LD_EXP 60
8210: PPUSH
8211: LD_INT 4
8213: PPUSH
8214: CALL_OW 123
// ComResearch ( kozlov_lab , tech_sibFiss ) ;
8218: LD_INT 336
8220: PPUSH
8221: LD_INT 25
8223: PPUSH
8224: CALL_OW 124
// repeat wait ( 0 0$1 ) ;
8228: LD_INT 35
8230: PPUSH
8231: CALL_OW 67
// until GetTech ( tech_sibFiss , 8 ) = state_researched ;
8235: LD_INT 25
8237: PPUSH
8238: LD_INT 8
8240: PPUSH
8241: CALL_OW 321
8245: PUSH
8246: LD_INT 2
8248: EQUAL
8249: IFFALSE 8228
// ComExitBuilding ( Kozlov ) ;
8251: LD_EXP 60
8255: PPUSH
8256: CALL_OW 122
// AddComEnterUnit ( Kozlov , kozlov_fac ) ;
8260: LD_EXP 60
8264: PPUSH
8265: LD_INT 332
8267: PPUSH
8268: CALL_OW 180
// AddComChangeProfession ( Kozlov , 3 ) ;
8272: LD_EXP 60
8276: PPUSH
8277: LD_INT 3
8279: PPUSH
8280: CALL_OW 183
// ComConstruct ( kozlov_fac , ru_heavy_wheeled , engine_siberite , control_manual , ru_siberium_rocket ) ;
8284: LD_INT 332
8286: PPUSH
8287: LD_INT 23
8289: PPUSH
8290: LD_INT 3
8292: PPUSH
8293: LD_INT 1
8295: PPUSH
8296: LD_INT 48
8298: PPUSH
8299: CALL_OW 125
// end ;
8303: LD_VAR 0 1
8307: RET
// every 9 9$30 + 7 7$00 trigger not legionDestroyed do var i , tmp , target , p ;
8308: LD_EXP 3
8312: NOT
8313: IFFALSE 9306
8315: GO 8317
8317: DISABLE
8318: LD_INT 0
8320: PPUSH
8321: PPUSH
8322: PPUSH
8323: PPUSH
// begin enable ;
8324: ENABLE
// if not FilterAllUnits ( [ [ f_side , 8 ] , [ f_nation , 2 ] , [ f_btype , b_factory ] ] ) then
8325: LD_INT 22
8327: PUSH
8328: LD_INT 8
8330: PUSH
8331: EMPTY
8332: LIST
8333: LIST
8334: PUSH
8335: LD_INT 23
8337: PUSH
8338: LD_INT 2
8340: PUSH
8341: EMPTY
8342: LIST
8343: LIST
8344: PUSH
8345: LD_INT 30
8347: PUSH
8348: LD_INT 3
8350: PUSH
8351: EMPTY
8352: LIST
8353: LIST
8354: PUSH
8355: EMPTY
8356: LIST
8357: LIST
8358: LIST
8359: PPUSH
8360: CALL_OW 69
8364: NOT
8365: IFFALSE 8369
// exit ;
8367: GO 9306
// if Prob ( 40 ) then
8369: LD_INT 40
8371: PPUSH
8372: CALL_OW 13
8376: IFFALSE 8503
// begin MC_InsertProduceList ( 3 , [ [ ar_half_tracked , engine_combustion , control_remote , ar_rocket_launcher ] , [ ar_half_tracked , engine_combustion , control_remote , ar_rocket_launcher ] , [ ar_half_tracked , engine_combustion , control_remote , ar_rocket_launcher ] , [ ar_half_tracked , engine_combustion , control_remote , ar_rocket_launcher ] , [ ar_half_tracked , engine_combustion , control_remote , ar_rocket_launcher ] , [ ar_half_tracked , engine_combustion , control_remote , ar_flame_thrower ] , ] ) ;
8378: LD_INT 3
8380: PPUSH
8381: LD_INT 14
8383: PUSH
8384: LD_INT 1
8386: PUSH
8387: LD_INT 2
8389: PUSH
8390: LD_INT 28
8392: PUSH
8393: EMPTY
8394: LIST
8395: LIST
8396: LIST
8397: LIST
8398: PUSH
8399: LD_INT 14
8401: PUSH
8402: LD_INT 1
8404: PUSH
8405: LD_INT 2
8407: PUSH
8408: LD_INT 28
8410: PUSH
8411: EMPTY
8412: LIST
8413: LIST
8414: LIST
8415: LIST
8416: PUSH
8417: LD_INT 14
8419: PUSH
8420: LD_INT 1
8422: PUSH
8423: LD_INT 2
8425: PUSH
8426: LD_INT 28
8428: PUSH
8429: EMPTY
8430: LIST
8431: LIST
8432: LIST
8433: LIST
8434: PUSH
8435: LD_INT 14
8437: PUSH
8438: LD_INT 1
8440: PUSH
8441: LD_INT 2
8443: PUSH
8444: LD_INT 28
8446: PUSH
8447: EMPTY
8448: LIST
8449: LIST
8450: LIST
8451: LIST
8452: PUSH
8453: LD_INT 14
8455: PUSH
8456: LD_INT 1
8458: PUSH
8459: LD_INT 2
8461: PUSH
8462: LD_INT 28
8464: PUSH
8465: EMPTY
8466: LIST
8467: LIST
8468: LIST
8469: LIST
8470: PUSH
8471: LD_INT 14
8473: PUSH
8474: LD_INT 1
8476: PUSH
8477: LD_INT 2
8479: PUSH
8480: LD_INT 26
8482: PUSH
8483: EMPTY
8484: LIST
8485: LIST
8486: LIST
8487: LIST
8488: PUSH
8489: EMPTY
8490: LIST
8491: LIST
8492: LIST
8493: LIST
8494: LIST
8495: LIST
8496: PPUSH
8497: CALL 47052 0 2
// end else
8501: GO 8710
// begin MC_InsertProduceList ( 3 , [ [ ar_half_tracked , engine_combustion , control_remote , [ ar_gun , ar_flame_thrower , ar_flame_thrower , ar_rocket_launcher ] [ Difficulty ] ] , [ ar_half_tracked , engine_combustion , control_remote , [ ar_gun , ar_flame_thrower , ar_flame_thrower , ar_flame_thrower ] [ Difficulty ] ] , [ ar_half_tracked , engine_combustion , control_remote , [ ar_flame_thrower , ar_flame_thrower , ar_selfpropelled_bomb , ar_selfpropelled_bomb ] [ Difficulty ] ] , [ ar_medium_trike , engine_combustion , control_remote , [ ar_flame_thrower , ar_selfpropelled_bomb , ar_selfpropelled_bomb , ar_selfpropelled_bomb ] [ Difficulty ] ] , [ ar_medium_trike , engine_combustion , control_remote , ar_selfpropelled_bomb ] , [ ar_half_tracked , engine_combustion , control_remote , ar_flame_thrower ] , ] ) ;
8503: LD_INT 3
8505: PPUSH
8506: LD_INT 14
8508: PUSH
8509: LD_INT 1
8511: PUSH
8512: LD_INT 2
8514: PUSH
8515: LD_INT 27
8517: PUSH
8518: LD_INT 26
8520: PUSH
8521: LD_INT 26
8523: PUSH
8524: LD_INT 28
8526: PUSH
8527: EMPTY
8528: LIST
8529: LIST
8530: LIST
8531: LIST
8532: PUSH
8533: LD_OWVAR 67
8537: ARRAY
8538: PUSH
8539: EMPTY
8540: LIST
8541: LIST
8542: LIST
8543: LIST
8544: PUSH
8545: LD_INT 14
8547: PUSH
8548: LD_INT 1
8550: PUSH
8551: LD_INT 2
8553: PUSH
8554: LD_INT 27
8556: PUSH
8557: LD_INT 26
8559: PUSH
8560: LD_INT 26
8562: PUSH
8563: LD_INT 26
8565: PUSH
8566: EMPTY
8567: LIST
8568: LIST
8569: LIST
8570: LIST
8571: PUSH
8572: LD_OWVAR 67
8576: ARRAY
8577: PUSH
8578: EMPTY
8579: LIST
8580: LIST
8581: LIST
8582: LIST
8583: PUSH
8584: LD_INT 14
8586: PUSH
8587: LD_INT 1
8589: PUSH
8590: LD_INT 2
8592: PUSH
8593: LD_INT 26
8595: PUSH
8596: LD_INT 26
8598: PUSH
8599: LD_INT 29
8601: PUSH
8602: LD_INT 29
8604: PUSH
8605: EMPTY
8606: LIST
8607: LIST
8608: LIST
8609: LIST
8610: PUSH
8611: LD_OWVAR 67
8615: ARRAY
8616: PUSH
8617: EMPTY
8618: LIST
8619: LIST
8620: LIST
8621: LIST
8622: PUSH
8623: LD_INT 13
8625: PUSH
8626: LD_INT 1
8628: PUSH
8629: LD_INT 2
8631: PUSH
8632: LD_INT 26
8634: PUSH
8635: LD_INT 29
8637: PUSH
8638: LD_INT 29
8640: PUSH
8641: LD_INT 29
8643: PUSH
8644: EMPTY
8645: LIST
8646: LIST
8647: LIST
8648: LIST
8649: PUSH
8650: LD_OWVAR 67
8654: ARRAY
8655: PUSH
8656: EMPTY
8657: LIST
8658: LIST
8659: LIST
8660: LIST
8661: PUSH
8662: LD_INT 13
8664: PUSH
8665: LD_INT 1
8667: PUSH
8668: LD_INT 2
8670: PUSH
8671: LD_INT 29
8673: PUSH
8674: EMPTY
8675: LIST
8676: LIST
8677: LIST
8678: LIST
8679: PUSH
8680: LD_INT 14
8682: PUSH
8683: LD_INT 1
8685: PUSH
8686: LD_INT 2
8688: PUSH
8689: LD_INT 26
8691: PUSH
8692: EMPTY
8693: LIST
8694: LIST
8695: LIST
8696: LIST
8697: PUSH
8698: EMPTY
8699: LIST
8700: LIST
8701: LIST
8702: LIST
8703: LIST
8704: LIST
8705: PPUSH
8706: CALL 47052 0 2
// end ; p := 0 ;
8710: LD_ADDR_VAR 0 4
8714: PUSH
8715: LD_INT 0
8717: ST_TO_ADDR
// repeat wait ( 0 0$1 ) ;
8718: LD_INT 35
8720: PPUSH
8721: CALL_OW 67
// p := Inc ( p ) ;
8725: LD_ADDR_VAR 0 4
8729: PUSH
8730: LD_VAR 0 4
8734: PPUSH
8735: CALL 92530 0 1
8739: ST_TO_ADDR
// until MC_GetVehicles ( 3 , true ) >= 6 or p > 100 ;
8740: LD_INT 3
8742: PPUSH
8743: LD_INT 1
8745: PPUSH
8746: CALL 48470 0 2
8750: PUSH
8751: LD_INT 6
8753: GREATEREQUAL
8754: PUSH
8755: LD_VAR 0 4
8759: PUSH
8760: LD_INT 100
8762: GREATER
8763: OR
8764: IFFALSE 8718
// wait ( 0 0$30 ) ;
8766: LD_INT 1050
8768: PPUSH
8769: CALL_OW 67
// tmp := FilterAllUnits ( [ [ f_side , 8 ] , [ f_type , unit_vehicle ] , [ f_not , [ f_weapon , ar_control_tower ] , [ f_weapon , ar_cargo_bay ] , [ f_weapon , ar_crane ] ] ] ) diff mc_defender [ 3 ] ;
8773: LD_ADDR_VAR 0 2
8777: PUSH
8778: LD_INT 22
8780: PUSH
8781: LD_INT 8
8783: PUSH
8784: EMPTY
8785: LIST
8786: LIST
8787: PUSH
8788: LD_INT 21
8790: PUSH
8791: LD_INT 2
8793: PUSH
8794: EMPTY
8795: LIST
8796: LIST
8797: PUSH
8798: LD_INT 3
8800: PUSH
8801: LD_INT 34
8803: PUSH
8804: LD_INT 31
8806: PUSH
8807: EMPTY
8808: LIST
8809: LIST
8810: PUSH
8811: LD_INT 34
8813: PUSH
8814: LD_INT 32
8816: PUSH
8817: EMPTY
8818: LIST
8819: LIST
8820: PUSH
8821: LD_INT 34
8823: PUSH
8824: LD_INT 88
8826: PUSH
8827: EMPTY
8828: LIST
8829: LIST
8830: PUSH
8831: EMPTY
8832: LIST
8833: LIST
8834: LIST
8835: LIST
8836: PUSH
8837: EMPTY
8838: LIST
8839: LIST
8840: LIST
8841: PPUSH
8842: CALL_OW 69
8846: PUSH
8847: LD_EXP 102
8851: PUSH
8852: LD_INT 3
8854: ARRAY
8855: DIFF
8856: ST_TO_ADDR
// mc_vehicles := Replace ( mc_vehicles , 3 , mc_vehicles [ 3 ] diff tmp ) ;
8857: LD_ADDR_EXP 99
8861: PUSH
8862: LD_EXP 99
8866: PPUSH
8867: LD_INT 3
8869: PPUSH
8870: LD_EXP 99
8874: PUSH
8875: LD_INT 3
8877: ARRAY
8878: PUSH
8879: LD_VAR 0 2
8883: DIFF
8884: PPUSH
8885: CALL_OW 1
8889: ST_TO_ADDR
// target := rand ( 0 , 2 ) ;
8890: LD_ADDR_VAR 0 3
8894: PUSH
8895: LD_INT 0
8897: PPUSH
8898: LD_INT 2
8900: PPUSH
8901: CALL_OW 12
8905: ST_TO_ADDR
// p := 0 ;
8906: LD_ADDR_VAR 0 4
8910: PUSH
8911: LD_INT 0
8913: ST_TO_ADDR
// if target then
8914: LD_VAR 0 3
8918: IFFALSE 9071
// begin repeat tmp := UnitFilter ( tmp , [ f_lives , 250 ] ) ;
8920: LD_ADDR_VAR 0 2
8924: PUSH
8925: LD_VAR 0 2
8929: PPUSH
8930: LD_INT 24
8932: PUSH
8933: LD_INT 250
8935: PUSH
8936: EMPTY
8937: LIST
8938: LIST
8939: PPUSH
8940: CALL_OW 72
8944: ST_TO_ADDR
// for i in tmp do
8945: LD_ADDR_VAR 0 1
8949: PUSH
8950: LD_VAR 0 2
8954: PUSH
8955: FOR_IN
8956: IFFALSE 8996
// if GetDistUnitXY ( i , 89 , 71 ) > 9 then
8958: LD_VAR 0 1
8962: PPUSH
8963: LD_INT 89
8965: PPUSH
8966: LD_INT 71
8968: PPUSH
8969: CALL_OW 297
8973: PUSH
8974: LD_INT 9
8976: GREATER
8977: IFFALSE 8994
// ComMoveXY ( i , 89 , 71 ) ;
8979: LD_VAR 0 1
8983: PPUSH
8984: LD_INT 89
8986: PPUSH
8987: LD_INT 71
8989: PPUSH
8990: CALL_OW 111
8994: GO 8955
8996: POP
8997: POP
// wait ( 0 0$1 ) ;
8998: LD_INT 35
9000: PPUSH
9001: CALL_OW 67
// p := Inc ( p ) ;
9005: LD_ADDR_VAR 0 4
9009: PUSH
9010: LD_VAR 0 4
9014: PPUSH
9015: CALL 92530 0 1
9019: ST_TO_ADDR
// until UnitFilter ( tmp , [ f_distxy , 89 , 71 , 9 ] ) >= ( tmp - 1 ) or p > 30 ;
9020: LD_VAR 0 2
9024: PPUSH
9025: LD_INT 92
9027: PUSH
9028: LD_INT 89
9030: PUSH
9031: LD_INT 71
9033: PUSH
9034: LD_INT 9
9036: PUSH
9037: EMPTY
9038: LIST
9039: LIST
9040: LIST
9041: LIST
9042: PPUSH
9043: CALL_OW 72
9047: PUSH
9048: LD_VAR 0 2
9052: PUSH
9053: LD_INT 1
9055: MINUS
9056: GREATEREQUAL
9057: PUSH
9058: LD_VAR 0 4
9062: PUSH
9063: LD_INT 30
9065: GREATER
9066: OR
9067: IFFALSE 8920
// end else
9069: GO 9220
// begin repeat tmp := UnitFilter ( tmp , [ f_lives , 250 ] ) ;
9071: LD_ADDR_VAR 0 2
9075: PUSH
9076: LD_VAR 0 2
9080: PPUSH
9081: LD_INT 24
9083: PUSH
9084: LD_INT 250
9086: PUSH
9087: EMPTY
9088: LIST
9089: LIST
9090: PPUSH
9091: CALL_OW 72
9095: ST_TO_ADDR
// for i in tmp do
9096: LD_ADDR_VAR 0 1
9100: PUSH
9101: LD_VAR 0 2
9105: PUSH
9106: FOR_IN
9107: IFFALSE 9147
// if GetDistUnitXY ( i , 147 , 4 ) > 9 then
9109: LD_VAR 0 1
9113: PPUSH
9114: LD_INT 147
9116: PPUSH
9117: LD_INT 4
9119: PPUSH
9120: CALL_OW 297
9124: PUSH
9125: LD_INT 9
9127: GREATER
9128: IFFALSE 9145
// ComMoveXY ( i , 147 , 4 ) ;
9130: LD_VAR 0 1
9134: PPUSH
9135: LD_INT 147
9137: PPUSH
9138: LD_INT 4
9140: PPUSH
9141: CALL_OW 111
9145: GO 9106
9147: POP
9148: POP
// wait ( 0 0$1 ) ;
9149: LD_INT 35
9151: PPUSH
9152: CALL_OW 67
// p := Inc ( p ) ;
9156: LD_ADDR_VAR 0 4
9160: PUSH
9161: LD_VAR 0 4
9165: PPUSH
9166: CALL 92530 0 1
9170: ST_TO_ADDR
// until UnitFilter ( tmp , [ f_distxy , 147 , 4 , 9 ] ) >= ( tmp - 1 ) or p > 30 ;
9171: LD_VAR 0 2
9175: PPUSH
9176: LD_INT 92
9178: PUSH
9179: LD_INT 147
9181: PUSH
9182: LD_INT 4
9184: PUSH
9185: LD_INT 9
9187: PUSH
9188: EMPTY
9189: LIST
9190: LIST
9191: LIST
9192: LIST
9193: PPUSH
9194: CALL_OW 72
9198: PUSH
9199: LD_VAR 0 2
9203: PUSH
9204: LD_INT 1
9206: MINUS
9207: GREATEREQUAL
9208: PUSH
9209: LD_VAR 0 4
9213: PUSH
9214: LD_INT 30
9216: GREATER
9217: OR
9218: IFFALSE 9071
// end ; repeat wait ( 0 0$1 ) ;
9220: LD_INT 35
9222: PPUSH
9223: CALL_OW 67
// tmp := UnitFilter ( tmp , [ f_ok ] ) ;
9227: LD_ADDR_VAR 0 2
9231: PUSH
9232: LD_VAR 0 2
9236: PPUSH
9237: LD_INT 50
9239: PUSH
9240: EMPTY
9241: LIST
9242: PPUSH
9243: CALL_OW 72
9247: ST_TO_ADDR
// for i in tmp do
9248: LD_ADDR_VAR 0 1
9252: PUSH
9253: LD_VAR 0 2
9257: PUSH
9258: FOR_IN
9259: IFFALSE 9297
// ComAttackUnit ( i , NearestUnitToUnit ( FilterAllUnits ( [ f_enemy , 8 ] ) , i ) ) ;
9261: LD_VAR 0 1
9265: PPUSH
9266: LD_INT 81
9268: PUSH
9269: LD_INT 8
9271: PUSH
9272: EMPTY
9273: LIST
9274: LIST
9275: PPUSH
9276: CALL_OW 69
9280: PPUSH
9281: LD_VAR 0 1
9285: PPUSH
9286: CALL_OW 74
9290: PPUSH
9291: CALL_OW 115
9295: GO 9258
9297: POP
9298: POP
// until not tmp ;
9299: LD_VAR 0 2
9303: NOT
9304: IFFALSE 9220
// end ;
9306: PPOPN 4
9308: END
// every 0 0$1 trigger IsOk ( Kozlov ) and not legionDestroyed do
9309: LD_EXP 60
9313: PPUSH
9314: CALL_OW 302
9318: PUSH
9319: LD_EXP 3
9323: NOT
9324: AND
9325: IFFALSE 9334
9327: GO 9329
9329: DISABLE
// BuildKozlovBomb ;
9330: CALL 8181 0 0
9334: END
// every 0 0$3 trigger FilterAllUnits ( [ [ f_side , 8 ] , [ f_weapon , ru_siberium_rocket ] ] ) do
9335: LD_INT 22
9337: PUSH
9338: LD_INT 8
9340: PUSH
9341: EMPTY
9342: LIST
9343: LIST
9344: PUSH
9345: LD_INT 34
9347: PUSH
9348: LD_INT 48
9350: PUSH
9351: EMPTY
9352: LIST
9353: LIST
9354: PUSH
9355: EMPTY
9356: LIST
9357: LIST
9358: PPUSH
9359: CALL_OW 69
9363: IFFALSE 9411
9365: GO 9367
9367: DISABLE
// begin ComAttackPlace ( FilterAllUnits ( [ [ f_side , 8 ] , [ f_weapon , ru_siberium_rocket ] ] ) [ 1 ] , 173 , 96 ) ;
9368: LD_INT 22
9370: PUSH
9371: LD_INT 8
9373: PUSH
9374: EMPTY
9375: LIST
9376: LIST
9377: PUSH
9378: LD_INT 34
9380: PUSH
9381: LD_INT 48
9383: PUSH
9384: EMPTY
9385: LIST
9386: LIST
9387: PUSH
9388: EMPTY
9389: LIST
9390: LIST
9391: PPUSH
9392: CALL_OW 69
9396: PUSH
9397: LD_INT 1
9399: ARRAY
9400: PPUSH
9401: LD_INT 173
9403: PPUSH
9404: LD_INT 96
9406: PPUSH
9407: CALL_OW 116
// end ; end_of_file
9411: END
// export Platonov , Yakotich , Gleb , Bierezov ; export behemoths , behemothBuilders ; export function PrepareRussian ; var i , j , base , tmp , side , xy , un , b , teleport ; begin
9412: LD_INT 0
9414: PPUSH
9415: PPUSH
9416: PPUSH
9417: PPUSH
9418: PPUSH
9419: PPUSH
9420: PPUSH
9421: PPUSH
9422: PPUSH
9423: PPUSH
// side := 3 ;
9424: LD_ADDR_VAR 0 6
9428: PUSH
9429: LD_INT 3
9431: ST_TO_ADDR
// InitHc ;
9432: CALL_OW 19
// uc_side := side ;
9436: LD_ADDR_OWVAR 20
9440: PUSH
9441: LD_VAR 0 6
9445: ST_TO_ADDR
// uc_nation := 3 ;
9446: LD_ADDR_OWVAR 21
9450: PUSH
9451: LD_INT 3
9453: ST_TO_ADDR
// for i in FilterAllUnits ( [ [ f_side , side ] , [ f_type , unit_building ] ] ) do
9454: LD_ADDR_VAR 0 2
9458: PUSH
9459: LD_INT 22
9461: PUSH
9462: LD_VAR 0 6
9466: PUSH
9467: EMPTY
9468: LIST
9469: LIST
9470: PUSH
9471: LD_INT 21
9473: PUSH
9474: LD_INT 3
9476: PUSH
9477: EMPTY
9478: LIST
9479: LIST
9480: PUSH
9481: EMPTY
9482: LIST
9483: LIST
9484: PPUSH
9485: CALL_OW 69
9489: PUSH
9490: FOR_IN
9491: IFFALSE 9507
// SetBLevel ( i , 10 ) ;
9493: LD_VAR 0 2
9497: PPUSH
9498: LD_INT 10
9500: PPUSH
9501: CALL_OW 241
9505: GO 9490
9507: POP
9508: POP
// teleport := FilterAllUnits ( [ [ f_side , side ] , [ f_btype , b_teleport ] ] ) ;
9509: LD_ADDR_VAR 0 10
9513: PUSH
9514: LD_INT 22
9516: PUSH
9517: LD_VAR 0 6
9521: PUSH
9522: EMPTY
9523: LIST
9524: LIST
9525: PUSH
9526: LD_INT 30
9528: PUSH
9529: LD_INT 34
9531: PUSH
9532: EMPTY
9533: LIST
9534: LIST
9535: PUSH
9536: EMPTY
9537: LIST
9538: LIST
9539: PPUSH
9540: CALL_OW 69
9544: ST_TO_ADDR
// if teleport then
9545: LD_VAR 0 10
9549: IFFALSE 9570
// TeleportExit ( teleport [ 1 ] , 123 , 122 ) ;
9551: LD_VAR 0 10
9555: PUSH
9556: LD_INT 1
9558: ARRAY
9559: PPUSH
9560: LD_INT 123
9562: PPUSH
9563: LD_INT 122
9565: PPUSH
9566: CALL_OW 243
// hc_importance := 0 ;
9570: LD_ADDR_OWVAR 32
9574: PUSH
9575: LD_INT 0
9577: ST_TO_ADDR
// Platonov := NewCharacter ( Platonov ) ;
9578: LD_ADDR_EXP 62
9582: PUSH
9583: LD_STRING Platonov
9585: PPUSH
9586: CALL_OW 25
9590: ST_TO_ADDR
// Yakotich := PrepareUnit ( Yakotich , ( not debug ) , 09_ ) ;
9591: LD_ADDR_EXP 63
9595: PUSH
9596: LD_STRING Yakotich
9598: PPUSH
9599: LD_EXP 1
9603: NOT
9604: PPUSH
9605: LD_STRING 09_
9607: PPUSH
9608: CALL 53478 0 3
9612: ST_TO_ADDR
// Gleb := NewCharacter ( Gleb ) ;
9613: LD_ADDR_EXP 64
9617: PUSH
9618: LD_STRING Gleb
9620: PPUSH
9621: CALL_OW 25
9625: ST_TO_ADDR
// if TestCharacters ( 03_Cornel ) then
9626: LD_STRING 03_Cornel
9628: PPUSH
9629: CALL_OW 28
9633: IFFALSE 9681
// begin Bierezov := NewCharacter ( Mikhail ) ;
9635: LD_ADDR_EXP 65
9639: PUSH
9640: LD_STRING Mikhail
9642: PPUSH
9643: CALL_OW 25
9647: ST_TO_ADDR
// PlaceUnitXYR ( Bierezov , 197 , 111 , 9 , false ) ;
9648: LD_EXP 65
9652: PPUSH
9653: LD_INT 197
9655: PPUSH
9656: LD_INT 111
9658: PPUSH
9659: LD_INT 9
9661: PPUSH
9662: LD_INT 0
9664: PPUSH
9665: CALL_OW 50
// SetClass ( Bierezov , 3 ) ;
9669: LD_EXP 65
9673: PPUSH
9674: LD_INT 3
9676: PPUSH
9677: CALL_OW 336
// end ; PlaceHumanInUnit ( Platonov , ru_depot ) ;
9681: LD_EXP 62
9685: PPUSH
9686: LD_INT 126
9688: PPUSH
9689: CALL_OW 52
// if Yakotich then
9693: LD_EXP 63
9697: IFFALSE 9720
// PlaceUnitXYR ( Yakotich , 197 , 111 , 9 , false ) ;
9699: LD_EXP 63
9703: PPUSH
9704: LD_INT 197
9706: PPUSH
9707: LD_INT 111
9709: PPUSH
9710: LD_INT 9
9712: PPUSH
9713: LD_INT 0
9715: PPUSH
9716: CALL_OW 50
// PlaceUnitXYR ( Gleb , 197 , 111 , 9 , false ) ;
9720: LD_EXP 64
9724: PPUSH
9725: LD_INT 197
9727: PPUSH
9728: LD_INT 111
9730: PPUSH
9731: LD_INT 9
9733: PPUSH
9734: LD_INT 0
9736: PPUSH
9737: CALL_OW 50
// tmp := PrepareBase ( ru_depot , russianBaseArea , zhukov , [ 9 , 10 , 10 , 10 ] [ Difficulty ] , [ 9000 , 1000 , 300 ] , [ 21 , 8 , 13 , 8 ] ) ;
9741: LD_ADDR_VAR 0 5
9745: PUSH
9746: LD_INT 126
9748: PPUSH
9749: LD_INT 2
9751: PPUSH
9752: LD_STRING zhukov
9754: PPUSH
9755: LD_INT 9
9757: PUSH
9758: LD_INT 10
9760: PUSH
9761: LD_INT 10
9763: PUSH
9764: LD_INT 10
9766: PUSH
9767: EMPTY
9768: LIST
9769: LIST
9770: LIST
9771: LIST
9772: PUSH
9773: LD_OWVAR 67
9777: ARRAY
9778: PPUSH
9779: LD_INT 9000
9781: PUSH
9782: LD_INT 1000
9784: PUSH
9785: LD_INT 300
9787: PUSH
9788: EMPTY
9789: LIST
9790: LIST
9791: LIST
9792: PPUSH
9793: LD_INT 21
9795: PUSH
9796: LD_INT 8
9798: PUSH
9799: LD_INT 13
9801: PUSH
9802: LD_INT 8
9804: PUSH
9805: EMPTY
9806: LIST
9807: LIST
9808: LIST
9809: LIST
9810: PPUSH
9811: CALL 62139 0 6
9815: ST_TO_ADDR
// mc_bases := Replace ( mc_bases , 2 , tmp union [ Yakotich , Gleb , Bierezov ] ) ;
9816: LD_ADDR_EXP 80
9820: PUSH
9821: LD_EXP 80
9825: PPUSH
9826: LD_INT 2
9828: PPUSH
9829: LD_VAR 0 5
9833: PUSH
9834: LD_EXP 63
9838: PUSH
9839: LD_EXP 64
9843: PUSH
9844: LD_EXP 65
9848: PUSH
9849: EMPTY
9850: LIST
9851: LIST
9852: LIST
9853: UNION
9854: PPUSH
9855: CALL_OW 1
9859: ST_TO_ADDR
// base := GetBase ( ru_depot2 ) ;
9860: LD_ADDR_VAR 0 4
9864: PUSH
9865: LD_INT 267
9867: PPUSH
9868: CALL_OW 274
9872: ST_TO_ADDR
// SetResourceType ( base , mat_cans , 5000 ) ;
9873: LD_VAR 0 4
9877: PPUSH
9878: LD_INT 1
9880: PPUSH
9881: LD_INT 5000
9883: PPUSH
9884: CALL_OW 277
// SetResourceType ( base , mat_oil , 200 ) ;
9888: LD_VAR 0 4
9892: PPUSH
9893: LD_INT 2
9895: PPUSH
9896: LD_INT 200
9898: PPUSH
9899: CALL_OW 277
// SetResourceType ( base , mat_siberit , 200 ) ;
9903: LD_VAR 0 4
9907: PPUSH
9908: LD_INT 3
9910: PPUSH
9911: LD_INT 200
9913: PPUSH
9914: CALL_OW 277
// for i := 1 to 6 do
9918: LD_ADDR_VAR 0 2
9922: PUSH
9923: DOUBLE
9924: LD_INT 1
9926: DEC
9927: ST_TO_ADDR
9928: LD_INT 6
9930: PUSH
9931: FOR_TO
9932: IFFALSE 10015
// begin PrepareSoldier ( false , [ 8 , 9 , 10 , 10 ] [ Difficulty ] ) ;
9934: LD_INT 0
9936: PPUSH
9937: LD_INT 8
9939: PUSH
9940: LD_INT 9
9942: PUSH
9943: LD_INT 10
9945: PUSH
9946: LD_INT 10
9948: PUSH
9949: EMPTY
9950: LIST
9951: LIST
9952: LIST
9953: LIST
9954: PUSH
9955: LD_OWVAR 67
9959: ARRAY
9960: PPUSH
9961: CALL_OW 381
// un := CreateHuman ;
9965: LD_ADDR_VAR 0 8
9969: PUSH
9970: CALL_OW 44
9974: ST_TO_ADDR
// if i mod 2 = 0 then
9975: LD_VAR 0 2
9979: PUSH
9980: LD_INT 2
9982: MOD
9983: PUSH
9984: LD_INT 0
9986: EQUAL
9987: IFFALSE 10001
// SetClass ( un , class_bazooker ) ;
9989: LD_VAR 0 8
9993: PPUSH
9994: LD_INT 9
9996: PPUSH
9997: CALL_OW 336
// PlaceHumanInUnit ( un , ru_specBar ) ;
10001: LD_VAR 0 8
10005: PPUSH
10006: LD_INT 674
10008: PPUSH
10009: CALL_OW 52
// end ;
10013: GO 9931
10015: POP
10016: POP
// PrepareVehicle ( ru_medium_wheeled , engine_siberite , control_computer , ru_crane , 100 ) ;
10017: LD_INT 21
10019: PPUSH
10020: LD_INT 3
10022: PPUSH
10023: LD_INT 3
10025: PPUSH
10026: LD_INT 52
10028: PPUSH
10029: LD_INT 100
10031: PPUSH
10032: CALL 58318 0 5
// PlaceUnitXYD ( CreateVehicle , 259 , 145 , 3 , false ) ;
10036: CALL_OW 45
10040: PPUSH
10041: LD_INT 259
10043: PPUSH
10044: LD_INT 145
10046: PPUSH
10047: LD_INT 3
10049: PPUSH
10050: LD_INT 0
10052: PPUSH
10053: CALL 93309 0 5
// PlaceUnitXYD ( CreateVehicle , 245 , 139 , 3 , false ) ;
10057: CALL_OW 45
10061: PPUSH
10062: LD_INT 245
10064: PPUSH
10065: LD_INT 139
10067: PPUSH
10068: LD_INT 3
10070: PPUSH
10071: LD_INT 0
10073: PPUSH
10074: CALL 93309 0 5
// behemoths := [ ] ;
10078: LD_ADDR_EXP 66
10082: PUSH
10083: EMPTY
10084: ST_TO_ADDR
// behemothBuilders := [ ] ;
10085: LD_ADDR_EXP 67
10089: PUSH
10090: EMPTY
10091: ST_TO_ADDR
// j := 3 ;
10092: LD_ADDR_VAR 0 3
10096: PUSH
10097: LD_INT 3
10099: ST_TO_ADDR
// for i in FilterAllUnits ( [ [ f_side , 3 ] , [ f_class , 3 ] ] ) do
10100: LD_ADDR_VAR 0 2
10104: PUSH
10105: LD_INT 22
10107: PUSH
10108: LD_INT 3
10110: PUSH
10111: EMPTY
10112: LIST
10113: LIST
10114: PUSH
10115: LD_INT 25
10117: PUSH
10118: LD_INT 3
10120: PUSH
10121: EMPTY
10122: LIST
10123: LIST
10124: PUSH
10125: EMPTY
10126: LIST
10127: LIST
10128: PPUSH
10129: CALL_OW 69
10133: PUSH
10134: FOR_IN
10135: IFFALSE 10185
// begin behemothBuilders := Join ( behemothBuilders , i ) ;
10137: LD_ADDR_EXP 67
10141: PUSH
10142: LD_EXP 67
10146: PPUSH
10147: LD_VAR 0 2
10151: PPUSH
10152: CALL 91169 0 2
10156: ST_TO_ADDR
// j := j - 1 ;
10157: LD_ADDR_VAR 0 3
10161: PUSH
10162: LD_VAR 0 3
10166: PUSH
10167: LD_INT 1
10169: MINUS
10170: ST_TO_ADDR
// if j = 0 then
10171: LD_VAR 0 3
10175: PUSH
10176: LD_INT 0
10178: EQUAL
10179: IFFALSE 10183
// break ;
10181: GO 10185
// end ;
10183: GO 10134
10185: POP
10186: POP
// end ;
10187: LD_VAR 0 1
10191: RET
// export function BuildBehemoths ; var i , j , xy , tmp ; begin
10192: LD_INT 0
10194: PPUSH
10195: PPUSH
10196: PPUSH
10197: PPUSH
10198: PPUSH
// xy := [ [ 209 , 149 ] , [ 219 , 154 ] , [ 223 , 149 ] , [ 232 , 155 ] ] ;
10199: LD_ADDR_VAR 0 4
10203: PUSH
10204: LD_INT 209
10206: PUSH
10207: LD_INT 149
10209: PUSH
10210: EMPTY
10211: LIST
10212: LIST
10213: PUSH
10214: LD_INT 219
10216: PUSH
10217: LD_INT 154
10219: PUSH
10220: EMPTY
10221: LIST
10222: LIST
10223: PUSH
10224: LD_INT 223
10226: PUSH
10227: LD_INT 149
10229: PUSH
10230: EMPTY
10231: LIST
10232: LIST
10233: PUSH
10234: LD_INT 232
10236: PUSH
10237: LD_INT 155
10239: PUSH
10240: EMPTY
10241: LIST
10242: LIST
10243: PUSH
10244: EMPTY
10245: LIST
10246: LIST
10247: LIST
10248: LIST
10249: ST_TO_ADDR
// if not behemothBuilders then
10250: LD_EXP 67
10254: NOT
10255: IFFALSE 10259
// exit ;
10257: GO 10363
// j := 1 ;
10259: LD_ADDR_VAR 0 3
10263: PUSH
10264: LD_INT 1
10266: ST_TO_ADDR
// for i in behemothBuilders do
10267: LD_ADDR_VAR 0 2
10271: PUSH
10272: LD_EXP 67
10276: PUSH
10277: FOR_IN
10278: IFFALSE 10361
// begin if IsInUnit ( i ) then
10280: LD_VAR 0 2
10284: PPUSH
10285: CALL_OW 310
10289: IFFALSE 10300
// ComExitBuilding ( i ) ;
10291: LD_VAR 0 2
10295: PPUSH
10296: CALL_OW 122
// AddComBuildBehemoth ( i , b_behemoth , xy [ j ] [ 1 ] , xy [ j ] [ 2 ] , 0 ) ;
10300: LD_VAR 0 2
10304: PPUSH
10305: LD_INT 37
10307: PPUSH
10308: LD_VAR 0 4
10312: PUSH
10313: LD_VAR 0 3
10317: ARRAY
10318: PUSH
10319: LD_INT 1
10321: ARRAY
10322: PPUSH
10323: LD_VAR 0 4
10327: PUSH
10328: LD_VAR 0 3
10332: ARRAY
10333: PUSH
10334: LD_INT 2
10336: ARRAY
10337: PPUSH
10338: LD_INT 0
10340: PPUSH
10341: CALL_OW 230
// j := j + 1 ;
10345: LD_ADDR_VAR 0 3
10349: PUSH
10350: LD_VAR 0 3
10354: PUSH
10355: LD_INT 1
10357: PLUS
10358: ST_TO_ADDR
// end ;
10359: GO 10277
10361: POP
10362: POP
// end ;
10363: LD_VAR 0 1
10367: RET
// every 0 0$3 trigger GetBehemoths ( 3 ) and not FilterAllUnits ( [ [ f_side , 3 ] , [ f_btype , b_behemoth ] ] ) do var i , tmp ;
10368: LD_INT 3
10370: PPUSH
10371: CALL 91230 0 1
10375: PUSH
10376: LD_INT 22
10378: PUSH
10379: LD_INT 3
10381: PUSH
10382: EMPTY
10383: LIST
10384: LIST
10385: PUSH
10386: LD_INT 30
10388: PUSH
10389: LD_INT 37
10391: PUSH
10392: EMPTY
10393: LIST
10394: LIST
10395: PUSH
10396: EMPTY
10397: LIST
10398: LIST
10399: PPUSH
10400: CALL_OW 69
10404: NOT
10405: AND
10406: IFFALSE 10592
10408: GO 10410
10410: DISABLE
10411: LD_INT 0
10413: PPUSH
10414: PPUSH
// begin enable ;
10415: ENABLE
// tmp := GetBehemoths ( 3 ) ;
10416: LD_ADDR_VAR 0 2
10420: PUSH
10421: LD_INT 3
10423: PPUSH
10424: CALL 91230 0 1
10428: ST_TO_ADDR
// for i in tmp do
10429: LD_ADDR_VAR 0 1
10433: PUSH
10434: LD_VAR 0 2
10438: PUSH
10439: FOR_IN
10440: IFFALSE 10590
// begin if IsInArea ( i , powellBase ) and not GetTag ( i ) = 2 then
10442: LD_VAR 0 1
10446: PPUSH
10447: LD_INT 7
10449: PPUSH
10450: CALL_OW 308
10454: PUSH
10455: LD_VAR 0 1
10459: PPUSH
10460: CALL_OW 110
10464: PUSH
10465: LD_INT 2
10467: EQUAL
10468: NOT
10469: AND
10470: IFFALSE 10484
// SetTag ( i , 2 ) ;
10472: LD_VAR 0 1
10476: PPUSH
10477: LD_INT 2
10479: PPUSH
10480: CALL_OW 109
// if not FilterAllUnits ( [ [ f_enemy , 3 ] , [ f_dist , i , 12 ] ] ) and not GetTag ( i ) = 2 then
10484: LD_INT 81
10486: PUSH
10487: LD_INT 3
10489: PUSH
10490: EMPTY
10491: LIST
10492: LIST
10493: PUSH
10494: LD_INT 91
10496: PUSH
10497: LD_VAR 0 1
10501: PUSH
10502: LD_INT 12
10504: PUSH
10505: EMPTY
10506: LIST
10507: LIST
10508: LIST
10509: PUSH
10510: EMPTY
10511: LIST
10512: LIST
10513: PPUSH
10514: CALL_OW 69
10518: NOT
10519: PUSH
10520: LD_VAR 0 1
10524: PPUSH
10525: CALL_OW 110
10529: PUSH
10530: LD_INT 2
10532: EQUAL
10533: NOT
10534: AND
10535: IFFALSE 10554
// ComAgressiveMove ( i , 64 , 93 ) else
10537: LD_VAR 0 1
10541: PPUSH
10542: LD_INT 64
10544: PPUSH
10545: LD_INT 93
10547: PPUSH
10548: CALL_OW 114
10552: GO 10588
// ComAttackUnit ( i , NearestUnitToUnit ( FilterAllUnits ( [ f_enemy , 3 ] ) , i ) ) ;
10554: LD_VAR 0 1
10558: PPUSH
10559: LD_INT 81
10561: PUSH
10562: LD_INT 3
10564: PUSH
10565: EMPTY
10566: LIST
10567: LIST
10568: PPUSH
10569: CALL_OW 69
10573: PPUSH
10574: LD_VAR 0 1
10578: PPUSH
10579: CALL_OW 74
10583: PPUSH
10584: CALL_OW 115
// end ;
10588: GO 10439
10590: POP
10591: POP
// end ;
10592: PPOPN 2
10594: END
// every 9 9$30 + 7 7$00 trigger not russianDestroyed do var i , tmp , target , teleport , p ;
10595: LD_EXP 2
10599: NOT
10600: IFFALSE 11661
10602: GO 10604
10604: DISABLE
10605: LD_INT 0
10607: PPUSH
10608: PPUSH
10609: PPUSH
10610: PPUSH
10611: PPUSH
// begin enable ;
10612: ENABLE
// if not FilterAllUnits ( [ [ f_side , 3 ] , [ f_btype , b_factory ] ] ) then
10613: LD_INT 22
10615: PUSH
10616: LD_INT 3
10618: PUSH
10619: EMPTY
10620: LIST
10621: LIST
10622: PUSH
10623: LD_INT 30
10625: PUSH
10626: LD_INT 3
10628: PUSH
10629: EMPTY
10630: LIST
10631: LIST
10632: PUSH
10633: EMPTY
10634: LIST
10635: LIST
10636: PPUSH
10637: CALL_OW 69
10641: NOT
10642: IFFALSE 10646
// exit ;
10644: GO 11661
// teleport := FilterAllUnits ( [ [ f_side , 3 ] , [ f_btype , b_teleport ] ] ) ;
10646: LD_ADDR_VAR 0 4
10650: PUSH
10651: LD_INT 22
10653: PUSH
10654: LD_INT 3
10656: PUSH
10657: EMPTY
10658: LIST
10659: LIST
10660: PUSH
10661: LD_INT 30
10663: PUSH
10664: LD_INT 34
10666: PUSH
10667: EMPTY
10668: LIST
10669: LIST
10670: PUSH
10671: EMPTY
10672: LIST
10673: LIST
10674: PPUSH
10675: CALL_OW 69
10679: ST_TO_ADDR
// if Prob ( 40 ) then
10680: LD_INT 40
10682: PPUSH
10683: CALL_OW 13
10687: IFFALSE 10814
// begin MC_InsertProduceList ( 2 , [ [ ru_medium_tracked , engine_siberite , control_computer , ru_time_lapser ] , [ ru_medium_tracked , engine_siberite , control_computer , ru_time_lapser ] , [ ru_medium_tracked , engine_siberite , control_computer , ru_time_lapser ] , [ ru_heavy_tracked , engine_siberite , control_computer , ru_heavy_gun ] , [ ru_heavy_tracked , engine_siberite , control_computer , ru_heavy_gun ] , [ ru_heavy_tracked , engine_siberite , control_computer , ru_heavy_gun ] ] ) ;
10689: LD_INT 2
10691: PPUSH
10692: LD_INT 22
10694: PUSH
10695: LD_INT 3
10697: PUSH
10698: LD_INT 3
10700: PUSH
10701: LD_INT 49
10703: PUSH
10704: EMPTY
10705: LIST
10706: LIST
10707: LIST
10708: LIST
10709: PUSH
10710: LD_INT 22
10712: PUSH
10713: LD_INT 3
10715: PUSH
10716: LD_INT 3
10718: PUSH
10719: LD_INT 49
10721: PUSH
10722: EMPTY
10723: LIST
10724: LIST
10725: LIST
10726: LIST
10727: PUSH
10728: LD_INT 22
10730: PUSH
10731: LD_INT 3
10733: PUSH
10734: LD_INT 3
10736: PUSH
10737: LD_INT 49
10739: PUSH
10740: EMPTY
10741: LIST
10742: LIST
10743: LIST
10744: LIST
10745: PUSH
10746: LD_INT 24
10748: PUSH
10749: LD_INT 3
10751: PUSH
10752: LD_INT 3
10754: PUSH
10755: LD_INT 46
10757: PUSH
10758: EMPTY
10759: LIST
10760: LIST
10761: LIST
10762: LIST
10763: PUSH
10764: LD_INT 24
10766: PUSH
10767: LD_INT 3
10769: PUSH
10770: LD_INT 3
10772: PUSH
10773: LD_INT 46
10775: PUSH
10776: EMPTY
10777: LIST
10778: LIST
10779: LIST
10780: LIST
10781: PUSH
10782: LD_INT 24
10784: PUSH
10785: LD_INT 3
10787: PUSH
10788: LD_INT 3
10790: PUSH
10791: LD_INT 46
10793: PUSH
10794: EMPTY
10795: LIST
10796: LIST
10797: LIST
10798: LIST
10799: PUSH
10800: EMPTY
10801: LIST
10802: LIST
10803: LIST
10804: LIST
10805: LIST
10806: LIST
10807: PPUSH
10808: CALL 47052 0 2
// end else
10812: GO 10937
// begin MC_InsertProduceList ( 2 , [ [ ru_heavy_tracked , engine_siberite , control_computer , ru_rocket ] , [ ru_heavy_tracked , engine_siberite , control_computer , ru_rocket ] , [ ru_heavy_tracked , engine_siberite , control_computer , ru_rocket ] , [ ru_heavy_tracked , engine_siberite , control_computer , ru_heavy_gun ] , [ ru_heavy_tracked , engine_siberite , control_computer , ru_heavy_gun ] , [ ru_heavy_tracked , engine_siberite , control_computer , ru_heavy_gun ] ] ) ;
10814: LD_INT 2
10816: PPUSH
10817: LD_INT 24
10819: PUSH
10820: LD_INT 3
10822: PUSH
10823: LD_INT 3
10825: PUSH
10826: LD_INT 47
10828: PUSH
10829: EMPTY
10830: LIST
10831: LIST
10832: LIST
10833: LIST
10834: PUSH
10835: LD_INT 24
10837: PUSH
10838: LD_INT 3
10840: PUSH
10841: LD_INT 3
10843: PUSH
10844: LD_INT 47
10846: PUSH
10847: EMPTY
10848: LIST
10849: LIST
10850: LIST
10851: LIST
10852: PUSH
10853: LD_INT 24
10855: PUSH
10856: LD_INT 3
10858: PUSH
10859: LD_INT 3
10861: PUSH
10862: LD_INT 47
10864: PUSH
10865: EMPTY
10866: LIST
10867: LIST
10868: LIST
10869: LIST
10870: PUSH
10871: LD_INT 24
10873: PUSH
10874: LD_INT 3
10876: PUSH
10877: LD_INT 3
10879: PUSH
10880: LD_INT 46
10882: PUSH
10883: EMPTY
10884: LIST
10885: LIST
10886: LIST
10887: LIST
10888: PUSH
10889: LD_INT 24
10891: PUSH
10892: LD_INT 3
10894: PUSH
10895: LD_INT 3
10897: PUSH
10898: LD_INT 46
10900: PUSH
10901: EMPTY
10902: LIST
10903: LIST
10904: LIST
10905: LIST
10906: PUSH
10907: LD_INT 24
10909: PUSH
10910: LD_INT 3
10912: PUSH
10913: LD_INT 3
10915: PUSH
10916: LD_INT 46
10918: PUSH
10919: EMPTY
10920: LIST
10921: LIST
10922: LIST
10923: LIST
10924: PUSH
10925: EMPTY
10926: LIST
10927: LIST
10928: LIST
10929: LIST
10930: LIST
10931: LIST
10932: PPUSH
10933: CALL 47052 0 2
// end ; if Difficulty > 1 then
10937: LD_OWVAR 67
10941: PUSH
10942: LD_INT 1
10944: GREATER
10945: IFFALSE 10975
// MC_InsertProduceList ( 2 , [ [ ru_heavy_tracked , engine_siberite , control_computer , ru_rocket ] ] ) ;
10947: LD_INT 2
10949: PPUSH
10950: LD_INT 24
10952: PUSH
10953: LD_INT 3
10955: PUSH
10956: LD_INT 3
10958: PUSH
10959: LD_INT 47
10961: PUSH
10962: EMPTY
10963: LIST
10964: LIST
10965: LIST
10966: LIST
10967: PUSH
10968: EMPTY
10969: LIST
10970: PPUSH
10971: CALL 47052 0 2
// p := 0 ;
10975: LD_ADDR_VAR 0 5
10979: PUSH
10980: LD_INT 0
10982: ST_TO_ADDR
// repeat wait ( 0 0$1 ) ;
10983: LD_INT 35
10985: PPUSH
10986: CALL_OW 67
// p := Inc ( p ) ;
10990: LD_ADDR_VAR 0 5
10994: PUSH
10995: LD_VAR 0 5
10999: PPUSH
11000: CALL 92530 0 1
11004: ST_TO_ADDR
// until MC_GetVehicles ( 2 , true ) >= [ 6 , 7 , 7 , 7 ] [ Difficulty ] or p > 120 ;
11005: LD_INT 2
11007: PPUSH
11008: LD_INT 1
11010: PPUSH
11011: CALL 48470 0 2
11015: PUSH
11016: LD_INT 6
11018: PUSH
11019: LD_INT 7
11021: PUSH
11022: LD_INT 7
11024: PUSH
11025: LD_INT 7
11027: PUSH
11028: EMPTY
11029: LIST
11030: LIST
11031: LIST
11032: LIST
11033: PUSH
11034: LD_OWVAR 67
11038: ARRAY
11039: GREATEREQUAL
11040: PUSH
11041: LD_VAR 0 5
11045: PUSH
11046: LD_INT 120
11048: GREATER
11049: OR
11050: IFFALSE 10983
// wait ( 0 0$30 ) ;
11052: LD_INT 1050
11054: PPUSH
11055: CALL_OW 67
// tmp := FilterAllUnits ( [ [ f_side , 3 ] , [ f_type , unit_vehicle ] , [ f_not , [ f_weapon , ru_siberium_rocket ] , [ f_weapon , ru_cargo_bay ] , [ f_weapon , ru_crane ] ] ] ) diff mc_defender [ 2 ] ;
11059: LD_ADDR_VAR 0 2
11063: PUSH
11064: LD_INT 22
11066: PUSH
11067: LD_INT 3
11069: PUSH
11070: EMPTY
11071: LIST
11072: LIST
11073: PUSH
11074: LD_INT 21
11076: PUSH
11077: LD_INT 2
11079: PUSH
11080: EMPTY
11081: LIST
11082: LIST
11083: PUSH
11084: LD_INT 3
11086: PUSH
11087: LD_INT 34
11089: PUSH
11090: LD_INT 48
11092: PUSH
11093: EMPTY
11094: LIST
11095: LIST
11096: PUSH
11097: LD_INT 34
11099: PUSH
11100: LD_INT 51
11102: PUSH
11103: EMPTY
11104: LIST
11105: LIST
11106: PUSH
11107: LD_INT 34
11109: PUSH
11110: LD_INT 52
11112: PUSH
11113: EMPTY
11114: LIST
11115: LIST
11116: PUSH
11117: EMPTY
11118: LIST
11119: LIST
11120: LIST
11121: LIST
11122: PUSH
11123: EMPTY
11124: LIST
11125: LIST
11126: LIST
11127: PPUSH
11128: CALL_OW 69
11132: PUSH
11133: LD_EXP 102
11137: PUSH
11138: LD_INT 2
11140: ARRAY
11141: DIFF
11142: ST_TO_ADDR
// mc_vehicles := Replace ( mc_vehicles , 2 , mc_vehicles [ 2 ] diff tmp ) ;
11143: LD_ADDR_EXP 99
11147: PUSH
11148: LD_EXP 99
11152: PPUSH
11153: LD_INT 2
11155: PPUSH
11156: LD_EXP 99
11160: PUSH
11161: LD_INT 2
11163: ARRAY
11164: PUSH
11165: LD_VAR 0 2
11169: DIFF
11170: PPUSH
11171: CALL_OW 1
11175: ST_TO_ADDR
// target := rand ( 0 , 1 ) ;
11176: LD_ADDR_VAR 0 3
11180: PUSH
11181: LD_INT 0
11183: PPUSH
11184: LD_INT 1
11186: PPUSH
11187: CALL_OW 12
11191: ST_TO_ADDR
// p := 0 ;
11192: LD_ADDR_VAR 0 5
11196: PUSH
11197: LD_INT 0
11199: ST_TO_ADDR
// if target then
11200: LD_VAR 0 3
11204: IFFALSE 11357
// begin repeat tmp := UnitFilter ( tmp , [ f_lives , 250 ] ) ;
11206: LD_ADDR_VAR 0 2
11210: PUSH
11211: LD_VAR 0 2
11215: PPUSH
11216: LD_INT 24
11218: PUSH
11219: LD_INT 250
11221: PUSH
11222: EMPTY
11223: LIST
11224: LIST
11225: PPUSH
11226: CALL_OW 72
11230: ST_TO_ADDR
// for i in tmp do
11231: LD_ADDR_VAR 0 1
11235: PUSH
11236: LD_VAR 0 2
11240: PUSH
11241: FOR_IN
11242: IFFALSE 11282
// if GetDistUnitXY ( i , 139 , 89 ) > 9 then
11244: LD_VAR 0 1
11248: PPUSH
11249: LD_INT 139
11251: PPUSH
11252: LD_INT 89
11254: PPUSH
11255: CALL_OW 297
11259: PUSH
11260: LD_INT 9
11262: GREATER
11263: IFFALSE 11280
// ComMoveXY ( i , 139 , 89 ) ;
11265: LD_VAR 0 1
11269: PPUSH
11270: LD_INT 139
11272: PPUSH
11273: LD_INT 89
11275: PPUSH
11276: CALL_OW 111
11280: GO 11241
11282: POP
11283: POP
// wait ( 0 0$1 ) ;
11284: LD_INT 35
11286: PPUSH
11287: CALL_OW 67
// p := Inc ( p ) ;
11291: LD_ADDR_VAR 0 5
11295: PUSH
11296: LD_VAR 0 5
11300: PPUSH
11301: CALL 92530 0 1
11305: ST_TO_ADDR
// until UnitFilter ( tmp , [ f_distxy , 139 , 89 , 9 ] ) >= ( tmp - 1 ) or p > 30 ;
11306: LD_VAR 0 2
11310: PPUSH
11311: LD_INT 92
11313: PUSH
11314: LD_INT 139
11316: PUSH
11317: LD_INT 89
11319: PUSH
11320: LD_INT 9
11322: PUSH
11323: EMPTY
11324: LIST
11325: LIST
11326: LIST
11327: LIST
11328: PPUSH
11329: CALL_OW 72
11333: PUSH
11334: LD_VAR 0 2
11338: PUSH
11339: LD_INT 1
11341: MINUS
11342: GREATEREQUAL
11343: PUSH
11344: LD_VAR 0 5
11348: PUSH
11349: LD_INT 30
11351: GREATER
11352: OR
11353: IFFALSE 11206
// end else
11355: GO 11524
// begin ComEnterUnit ( tmp , teleport [ 1 ] ) ;
11357: LD_VAR 0 2
11361: PPUSH
11362: LD_VAR 0 4
11366: PUSH
11367: LD_INT 1
11369: ARRAY
11370: PPUSH
11371: CALL_OW 120
// repeat tmp := UnitFilter ( tmp , [ f_lives , 250 ] ) ;
11375: LD_ADDR_VAR 0 2
11379: PUSH
11380: LD_VAR 0 2
11384: PPUSH
11385: LD_INT 24
11387: PUSH
11388: LD_INT 250
11390: PUSH
11391: EMPTY
11392: LIST
11393: LIST
11394: PPUSH
11395: CALL_OW 72
11399: ST_TO_ADDR
// for i in tmp do
11400: LD_ADDR_VAR 0 1
11404: PUSH
11405: LD_VAR 0 2
11409: PUSH
11410: FOR_IN
11411: IFFALSE 11451
// if GetDistUnitXY ( i , 124 , 139 ) > 9 then
11413: LD_VAR 0 1
11417: PPUSH
11418: LD_INT 124
11420: PPUSH
11421: LD_INT 139
11423: PPUSH
11424: CALL_OW 297
11428: PUSH
11429: LD_INT 9
11431: GREATER
11432: IFFALSE 11449
// ComMoveXY ( i , 124 , 139 ) ;
11434: LD_VAR 0 1
11438: PPUSH
11439: LD_INT 124
11441: PPUSH
11442: LD_INT 139
11444: PPUSH
11445: CALL_OW 111
11449: GO 11410
11451: POP
11452: POP
// wait ( 0 0$1 ) ;
11453: LD_INT 35
11455: PPUSH
11456: CALL_OW 67
// p := Inc ( p ) ;
11460: LD_ADDR_VAR 0 5
11464: PUSH
11465: LD_VAR 0 5
11469: PPUSH
11470: CALL 92530 0 1
11474: ST_TO_ADDR
// until UnitFilter ( tmp , [ f_distxy , 124 , 139 , 9 ] ) >= ( tmp - 1 ) or p > 30 ;
11475: LD_VAR 0 2
11479: PPUSH
11480: LD_INT 92
11482: PUSH
11483: LD_INT 124
11485: PUSH
11486: LD_INT 139
11488: PUSH
11489: LD_INT 9
11491: PUSH
11492: EMPTY
11493: LIST
11494: LIST
11495: LIST
11496: LIST
11497: PPUSH
11498: CALL_OW 72
11502: PUSH
11503: LD_VAR 0 2
11507: PUSH
11508: LD_INT 1
11510: MINUS
11511: GREATEREQUAL
11512: PUSH
11513: LD_VAR 0 5
11517: PUSH
11518: LD_INT 30
11520: GREATER
11521: OR
11522: IFFALSE 11375
// end ; repeat wait ( 0 0$1 ) ;
11524: LD_INT 35
11526: PPUSH
11527: CALL_OW 67
// tmp := UnitFilter ( tmp , [ f_ok ] ) ;
11531: LD_ADDR_VAR 0 2
11535: PUSH
11536: LD_VAR 0 2
11540: PPUSH
11541: LD_INT 50
11543: PUSH
11544: EMPTY
11545: LIST
11546: PPUSH
11547: CALL_OW 72
11551: ST_TO_ADDR
// for i in tmp do
11552: LD_ADDR_VAR 0 1
11556: PUSH
11557: LD_VAR 0 2
11561: PUSH
11562: FOR_IN
11563: IFFALSE 11652
// begin if GetWeapon ( i ) = ru_time_lapser then
11565: LD_VAR 0 1
11569: PPUSH
11570: CALL_OW 264
11574: PUSH
11575: LD_INT 49
11577: EQUAL
11578: IFFALSE 11616
// ComMoveUnit ( i , NearestUnitToUnit ( FilterAllUnits ( [ f_enemy , 3 ] ) , i ) ) else
11580: LD_VAR 0 1
11584: PPUSH
11585: LD_INT 81
11587: PUSH
11588: LD_INT 3
11590: PUSH
11591: EMPTY
11592: LIST
11593: LIST
11594: PPUSH
11595: CALL_OW 69
11599: PPUSH
11600: LD_VAR 0 1
11604: PPUSH
11605: CALL_OW 74
11609: PPUSH
11610: CALL_OW 112
11614: GO 11650
// ComAttackUnit ( i , NearestUnitToUnit ( FilterAllUnits ( [ f_enemy , 3 ] ) , i ) ) ;
11616: LD_VAR 0 1
11620: PPUSH
11621: LD_INT 81
11623: PUSH
11624: LD_INT 3
11626: PUSH
11627: EMPTY
11628: LIST
11629: LIST
11630: PPUSH
11631: CALL_OW 69
11635: PPUSH
11636: LD_VAR 0 1
11640: PPUSH
11641: CALL_OW 74
11645: PPUSH
11646: CALL_OW 115
// end ;
11650: GO 11562
11652: POP
11653: POP
// until not tmp ;
11654: LD_VAR 0 2
11658: NOT
11659: IFFALSE 11524
// end ;
11661: PPOPN 5
11663: END
// every 30 30$00 trigger not russianDestroyed do
11664: LD_EXP 2
11668: NOT
11669: IFFALSE 11738
11671: GO 11673
11673: DISABLE
// begin wait ( [ 50 50$00 , 40 40$00 , 30 30$00 , 25 25$00 ] [ Difficulty ] ) ;
11674: LD_INT 105000
11676: PUSH
11677: LD_INT 84000
11679: PUSH
11680: LD_INT 63000
11682: PUSH
11683: LD_INT 52500
11685: PUSH
11686: EMPTY
11687: LIST
11688: LIST
11689: LIST
11690: LIST
11691: PUSH
11692: LD_OWVAR 67
11696: ARRAY
11697: PPUSH
11698: CALL_OW 67
// if russianDestroyed then
11702: LD_EXP 2
11706: IFFALSE 11710
// exit ;
11708: GO 11738
// MC_InsertProduceList ( 2 , [ [ ru_heavy_wheeled , engine_siberite , control_manual , ru_siberium_rocket ] ] ) ;
11710: LD_INT 2
11712: PPUSH
11713: LD_INT 23
11715: PUSH
11716: LD_INT 3
11718: PUSH
11719: LD_INT 1
11721: PUSH
11722: LD_INT 48
11724: PUSH
11725: EMPTY
11726: LIST
11727: LIST
11728: LIST
11729: LIST
11730: PUSH
11731: EMPTY
11732: LIST
11733: PPUSH
11734: CALL 47052 0 2
// end ; end_of_file
11738: END
// export function CustomEvent ( event ) ; begin
11739: LD_INT 0
11741: PPUSH
// end ;
11742: LD_VAR 0 2
11746: RET
// on SibDepositContaminated ( unit , x , y ) do begin if InArea ( x , y , motherLodeArea ) then
11747: LD_VAR 0 2
11751: PPUSH
11752: LD_VAR 0 3
11756: PPUSH
11757: LD_INT 15
11759: PPUSH
11760: CALL_OW 309
11764: IFFALSE 11773
// YouLost ( MothContaminate ) ;
11766: LD_STRING MothContaminate
11768: PPUSH
11769: CALL_OW 104
// end ;
11773: PPOPN 3
11775: END
// on SiberiteRocketExploded ( unit , x , y ) do begin if InArea ( x , y , motherLodeArea ) then
11776: LD_VAR 0 2
11780: PPUSH
11781: LD_VAR 0 3
11785: PPUSH
11786: LD_INT 15
11788: PPUSH
11789: CALL_OW 309
11793: IFFALSE 11809
// begin wait ( 0 0$6 ) ;
11795: LD_INT 210
11797: PPUSH
11798: CALL_OW 67
// YouLost ( MothContaminateBomb ) ;
11802: LD_STRING MothContaminateBomb
11804: PPUSH
11805: CALL_OW 104
// end ; end ;
11809: PPOPN 3
11811: END
// on UnitDestroyed ( un ) do begin SOS_UnitDestroyed ( un ) ;
11812: LD_VAR 0 1
11816: PPUSH
11817: CALL 112068 0 1
// if un = JMM then
11821: LD_VAR 0 1
11825: PUSH
11826: LD_EXP 21
11830: EQUAL
11831: IFFALSE 11842
// begin YouLost ( JMM ) ;
11833: LD_STRING JMM
11835: PPUSH
11836: CALL_OW 104
// exit ;
11840: GO 11991
// end ; if un = Omar then
11842: LD_VAR 0 1
11846: PUSH
11847: LD_EXP 58
11851: EQUAL
11852: IFFALSE 11862
// omarKilled := true ;
11854: LD_ADDR_EXP 20
11858: PUSH
11859: LD_INT 1
11861: ST_TO_ADDR
// if GetSide ( un ) = 2 and not arabianAttacked then
11862: LD_VAR 0 1
11866: PPUSH
11867: CALL_OW 255
11871: PUSH
11872: LD_INT 2
11874: EQUAL
11875: PUSH
11876: LD_EXP 18
11880: NOT
11881: AND
11882: IFFALSE 11892
// arabianAttacked := true ;
11884: LD_ADDR_EXP 18
11888: PUSH
11889: LD_INT 1
11891: ST_TO_ADDR
// if un = Powell then
11892: LD_VAR 0 1
11896: PUSH
11897: LD_EXP 57
11901: EQUAL
11902: IFFALSE 11912
// americanDestroyed := true ;
11904: LD_ADDR_EXP 4
11908: PUSH
11909: LD_INT 1
11911: ST_TO_ADDR
// if un = Platonov then
11912: LD_VAR 0 1
11916: PUSH
11917: LD_EXP 62
11921: EQUAL
11922: IFFALSE 11932
// russianDestroyed := true ;
11924: LD_ADDR_EXP 2
11928: PUSH
11929: LD_INT 1
11931: ST_TO_ADDR
// if un in FilterAllUnits ( [ [ f_side , 7 ] , [ f_type , unit_vehicle ] ] ) then
11932: LD_VAR 0 1
11936: PUSH
11937: LD_INT 22
11939: PUSH
11940: LD_INT 7
11942: PUSH
11943: EMPTY
11944: LIST
11945: LIST
11946: PUSH
11947: LD_INT 21
11949: PUSH
11950: LD_INT 2
11952: PUSH
11953: EMPTY
11954: LIST
11955: LIST
11956: PUSH
11957: EMPTY
11958: LIST
11959: LIST
11960: PPUSH
11961: CALL_OW 69
11965: IN
11966: IFFALSE 11982
// vehicleLostCounter := vehicleLostCounter + 1 ;
11968: LD_ADDR_EXP 15
11972: PUSH
11973: LD_EXP 15
11977: PUSH
11978: LD_INT 1
11980: PLUS
11981: ST_TO_ADDR
// MCE_UnitDestroyed ( un ) ;
11982: LD_VAR 0 1
11986: PPUSH
11987: CALL 50494 0 1
// end ;
11991: PPOPN 1
11993: END
// on BuildingStarted ( building , builder ) do begin MCE_BuildingStarted ( building , builder ) ;
11994: LD_VAR 0 1
11998: PPUSH
11999: LD_VAR 0 2
12003: PPUSH
12004: CALL 52826 0 2
// end ;
12008: PPOPN 2
12010: END
// on UpgradeComplete ( building ) do begin MCE_UpgradeComplete ( building ) ;
12011: LD_VAR 0 1
12015: PPUSH
12016: CALL 51894 0 1
// end ;
12020: PPOPN 1
12022: END
// on BuildingComplete ( building ) do begin if building in FilterAllUnits ( [ [ f_side , 8 ] , [ f_btype , b_workshop ] , [ f_nation , 3 ] ] ) then
12023: LD_VAR 0 1
12027: PUSH
12028: LD_INT 22
12030: PUSH
12031: LD_INT 8
12033: PUSH
12034: EMPTY
12035: LIST
12036: LIST
12037: PUSH
12038: LD_INT 30
12040: PUSH
12041: LD_INT 2
12043: PUSH
12044: EMPTY
12045: LIST
12046: LIST
12047: PUSH
12048: LD_INT 23
12050: PUSH
12051: LD_INT 3
12053: PUSH
12054: EMPTY
12055: LIST
12056: LIST
12057: PUSH
12058: EMPTY
12059: LIST
12060: LIST
12061: LIST
12062: PPUSH
12063: CALL_OW 69
12067: IN
12068: IFFALSE 12095
// begin ComUpgrade ( building ) ;
12070: LD_VAR 0 1
12074: PPUSH
12075: CALL_OW 146
// ComComplete ( Kozlov , building ) ;
12079: LD_EXP 60
12083: PPUSH
12084: LD_VAR 0 1
12088: PPUSH
12089: CALL 61678 0 2
// exit ;
12093: GO 12104
// end ; MCE_BuildingComplete ( building ) ;
12095: LD_VAR 0 1
12099: PPUSH
12100: CALL 52135 0 1
// end ;
12104: PPOPN 1
12106: END
// on ResearchComplete ( tech , lab ) do begin MCE_ResearchComplete ( tech , lab ) ;
12107: LD_VAR 0 1
12111: PPUSH
12112: LD_VAR 0 2
12116: PPUSH
12117: CALL 50190 0 2
// end ;
12121: PPOPN 2
12123: END
// on CrateSpawn ( id , x , y , amount , mode ) do begin MCE_CrateSpawn ( id , x , y , amount , mode ) ;
12124: LD_VAR 0 1
12128: PPUSH
12129: LD_VAR 0 2
12133: PPUSH
12134: LD_VAR 0 3
12138: PPUSH
12139: LD_VAR 0 4
12143: PPUSH
12144: LD_VAR 0 5
12148: PPUSH
12149: CALL 49810 0 5
// end ;
12153: PPOPN 5
12155: END
// on VehicleConstructed ( vehicle , factory ) do begin SOS_VehicleConstructed ( vehicle , factory ) ;
12156: LD_VAR 0 1
12160: PPUSH
12161: LD_VAR 0 2
12165: PPUSH
12166: CALL 112188 0 2
// MCE_VehicleConstructed ( vehicle , factory ) ;
12170: LD_VAR 0 1
12174: PPUSH
12175: LD_VAR 0 2
12179: PPUSH
12180: CALL 49363 0 2
// end ;
12184: PPOPN 2
12186: END
// on VehicleCaptured ( new , old , side , capturing_unit ) do begin MCE_VehicleCaptured ( new , old , side , capturing_unit ) ;
12187: LD_VAR 0 1
12191: PPUSH
12192: LD_VAR 0 2
12196: PPUSH
12197: LD_VAR 0 3
12201: PPUSH
12202: LD_VAR 0 4
12206: PPUSH
12207: CALL 49201 0 4
// end ;
12211: PPOPN 4
12213: END
// on BuildingCaptured ( building , side , capturning_unit ) do begin MCE_BuildingCaptured ( building , side , capturning_unit ) ;
12214: LD_VAR 0 1
12218: PPUSH
12219: LD_VAR 0 2
12223: PPUSH
12224: LD_VAR 0 3
12228: PPUSH
12229: CALL 48976 0 3
// end ;
12233: PPOPN 3
12235: END
// on EnterBuilding ( building , unit ) do begin MCE_EnterBuilding ( building , unit ) ;
12236: LD_VAR 0 1
12240: PPUSH
12241: LD_VAR 0 2
12245: PPUSH
12246: CALL 48861 0 2
// end ;
12250: PPOPN 2
12252: END
// on LeaveBuilding ( building , unit ) do begin MCE_LeaveBuilding ( building , unit ) ;
12253: LD_VAR 0 1
12257: PPUSH
12258: LD_VAR 0 2
12262: PPUSH
12263: CALL 53121 0 2
// end ;
12267: PPOPN 2
12269: END
// on EvacuateBuilding ( building , unit ) do begin if building = ru_specBar then
12270: LD_VAR 0 1
12274: PUSH
12275: LD_INT 674
12277: EQUAL
12278: IFFALSE 12300
// ComEnterUnit ( unit , HexInfo ( 227 , 136 ) ) ;
12280: LD_VAR 0 2
12284: PPUSH
12285: LD_INT 227
12287: PPUSH
12288: LD_INT 136
12290: PPUSH
12291: CALL_OW 428
12295: PPUSH
12296: CALL_OW 120
// end ;
12300: PPOPN 2
12302: END
// on EvacuateVehicle ( driver , abandoned_vehicle , unknown1 , unknown2 ) do begin MCE_EvacuateVehicle ( driver , abandoned_vehicle , unknown1 , unknown2 ) ;
12303: LD_VAR 0 1
12307: PPUSH
12308: LD_VAR 0 2
12312: PPUSH
12313: LD_VAR 0 3
12317: PPUSH
12318: LD_VAR 0 4
12322: PPUSH
12323: CALL 53337 0 4
// end ;
12327: PPOPN 4
12329: END
// on ApemanTamed ( ape , sci ) do begin MCE_ApemanTamed ( ape , sci ) ;
12330: LD_VAR 0 1
12334: PPUSH
12335: LD_VAR 0 2
12339: PPUSH
12340: CALL 48670 0 2
// end ;
12344: PPOPN 2
12346: END
// on Command ( cmd ) do begin SOS_Command ( cmd ) ;
12347: LD_VAR 0 1
12351: PPUSH
12352: CALL 112172 0 1
// end ; end_of_file
12356: PPOPN 1
12358: END
// export function Action ; begin
12359: LD_INT 0
12361: PPUSH
// InGameOn ;
12362: CALL_OW 8
// CenterNowOnXY ( 206 , 11 ) ;
12366: LD_INT 206
12368: PPUSH
12369: LD_INT 11
12371: PPUSH
12372: CALL_OW 86
// wait ( 0 0$1 ) ;
12376: LD_INT 35
12378: PPUSH
12379: CALL_OW 67
// Say ( JMM , DStart-JMM-JMM-1 ) ;
12383: LD_EXP 21
12387: PPUSH
12388: LD_STRING DStart-JMM-JMM-1
12390: PPUSH
12391: CALL_OW 88
// Say ( Burlak , DStart-JMM-Bur-1 ) ;
12395: LD_EXP 54
12399: PPUSH
12400: LD_STRING DStart-JMM-Bur-1
12402: PPUSH
12403: CALL_OW 88
// Say ( JMM , DStart-JMM-JMM-2 ) ;
12407: LD_EXP 21
12411: PPUSH
12412: LD_STRING DStart-JMM-JMM-2
12414: PPUSH
12415: CALL_OW 88
// Say ( Burlak , DStart-JMM-Bur-2 ) ;
12419: LD_EXP 54
12423: PPUSH
12424: LD_STRING DStart-JMM-Bur-2
12426: PPUSH
12427: CALL_OW 88
// InGameOff ;
12431: CALL_OW 9
// ChangeMissionObjectives ( MStart ) ;
12435: LD_STRING MStart
12437: PPUSH
12438: CALL_OW 337
// SaveForQuickRestart ;
12442: CALL_OW 22
// end ;
12446: LD_VAR 0 1
12450: RET
// every 0 0$2 trigger SeeXY ( 7 , 255 , 219 ) do var speaker ;
12451: LD_INT 7
12453: PPUSH
12454: LD_INT 255
12456: PPUSH
12457: LD_INT 219
12459: PPUSH
12460: CALL_OW 293
12464: IFFALSE 13073
12466: GO 12468
12468: DISABLE
12469: LD_INT 0
12471: PPUSH
// begin wait ( 0 0$3 ) ;
12472: LD_INT 105
12474: PPUSH
12475: CALL_OW 67
// alienSpotted := true ;
12479: LD_ADDR_EXP 10
12483: PUSH
12484: LD_INT 1
12486: ST_TO_ADDR
// speaker := FilterAllUnits ( [ [ f_side , 7 ] , [ f_nation , 3 ] , [ f_type , unit_human ] , [ f_sex , sex_male ] ] ) diff [ Burlak , Titov , Dolgov , Petrosyan , Kuzmov , Kovalyuk , Scholtze ] ;
12487: LD_ADDR_VAR 0 1
12491: PUSH
12492: LD_INT 22
12494: PUSH
12495: LD_INT 7
12497: PUSH
12498: EMPTY
12499: LIST
12500: LIST
12501: PUSH
12502: LD_INT 23
12504: PUSH
12505: LD_INT 3
12507: PUSH
12508: EMPTY
12509: LIST
12510: LIST
12511: PUSH
12512: LD_INT 21
12514: PUSH
12515: LD_INT 1
12517: PUSH
12518: EMPTY
12519: LIST
12520: LIST
12521: PUSH
12522: LD_INT 26
12524: PUSH
12525: LD_INT 1
12527: PUSH
12528: EMPTY
12529: LIST
12530: LIST
12531: PUSH
12532: EMPTY
12533: LIST
12534: LIST
12535: LIST
12536: LIST
12537: PPUSH
12538: CALL_OW 69
12542: PUSH
12543: LD_EXP 54
12547: PUSH
12548: LD_EXP 42
12552: PUSH
12553: LD_EXP 44
12557: PUSH
12558: LD_EXP 45
12562: PUSH
12563: LD_EXP 52
12567: PUSH
12568: LD_EXP 51
12572: PUSH
12573: LD_EXP 46
12577: PUSH
12578: EMPTY
12579: LIST
12580: LIST
12581: LIST
12582: LIST
12583: LIST
12584: LIST
12585: LIST
12586: DIFF
12587: ST_TO_ADDR
// DialogueOn ;
12588: CALL_OW 6
// PlaceSeeing ( 255 , 219 , 7 , - 20 ) ;
12592: LD_INT 255
12594: PPUSH
12595: LD_INT 219
12597: PPUSH
12598: LD_INT 7
12600: PPUSH
12601: LD_INT 20
12603: NEG
12604: PPUSH
12605: CALL_OW 330
// CenterNowOnXY ( 255 , 219 ) ;
12609: LD_INT 255
12611: PPUSH
12612: LD_INT 219
12614: PPUSH
12615: CALL_OW 86
// if speaker then
12619: LD_VAR 0 1
12623: IFFALSE 12641
// Say ( speaker [ 1 ] , DAlienBase-RSol1-1 ) ;
12625: LD_VAR 0 1
12629: PUSH
12630: LD_INT 1
12632: ARRAY
12633: PPUSH
12634: LD_STRING DAlienBase-RSol1-1
12636: PPUSH
12637: CALL_OW 88
// Say ( JMM , DAlienBase-JMM-1 ) ;
12641: LD_EXP 21
12645: PPUSH
12646: LD_STRING DAlienBase-JMM-1
12648: PPUSH
12649: CALL_OW 88
// if IsOk ( Burlak ) then
12653: LD_EXP 54
12657: PPUSH
12658: CALL_OW 302
12662: IFFALSE 12683
// begin dwait ( 0 0$1 ) ;
12664: LD_INT 35
12666: PPUSH
12667: CALL_OW 68
// Say ( Burlak , DAlienBase-Bur-1 ) ;
12671: LD_EXP 54
12675: PPUSH
12676: LD_STRING DAlienBase-Bur-1
12678: PPUSH
12679: CALL_OW 88
// end ; if IsOk ( Roth ) then
12683: LD_EXP 22
12687: PPUSH
12688: CALL_OW 302
12692: IFFALSE 12706
// Say ( Roth , DAlienBase-Roth-1 ) ;
12694: LD_EXP 22
12698: PPUSH
12699: LD_STRING DAlienBase-Roth-1
12701: PPUSH
12702: CALL_OW 88
// if IsOk ( Gossudarov ) then
12706: LD_EXP 40
12710: PPUSH
12711: CALL_OW 302
12715: IFFALSE 12731
// Say ( Gossudarov , DAlienBase-Gos-1 ) else
12717: LD_EXP 40
12721: PPUSH
12722: LD_STRING DAlienBase-Gos-1
12724: PPUSH
12725: CALL_OW 88
12729: GO 12848
// begin speaker := FilterAllUnits ( [ [ f_side , 7 ] , [ f_class , 4 ] , [ f_type , unit_human ] , [ f_sex , sex_male ] ] ) diff [ Roth , JMM , Burlak , Titov , Kuzmov , Kovalyuk ] ;
12731: LD_ADDR_VAR 0 1
12735: PUSH
12736: LD_INT 22
12738: PUSH
12739: LD_INT 7
12741: PUSH
12742: EMPTY
12743: LIST
12744: LIST
12745: PUSH
12746: LD_INT 25
12748: PUSH
12749: LD_INT 4
12751: PUSH
12752: EMPTY
12753: LIST
12754: LIST
12755: PUSH
12756: LD_INT 21
12758: PUSH
12759: LD_INT 1
12761: PUSH
12762: EMPTY
12763: LIST
12764: LIST
12765: PUSH
12766: LD_INT 26
12768: PUSH
12769: LD_INT 1
12771: PUSH
12772: EMPTY
12773: LIST
12774: LIST
12775: PUSH
12776: EMPTY
12777: LIST
12778: LIST
12779: LIST
12780: LIST
12781: PPUSH
12782: CALL_OW 69
12786: PUSH
12787: LD_EXP 22
12791: PUSH
12792: LD_EXP 21
12796: PUSH
12797: LD_EXP 54
12801: PUSH
12802: LD_EXP 42
12806: PUSH
12807: LD_EXP 52
12811: PUSH
12812: LD_EXP 51
12816: PUSH
12817: EMPTY
12818: LIST
12819: LIST
12820: LIST
12821: LIST
12822: LIST
12823: LIST
12824: DIFF
12825: ST_TO_ADDR
// if speaker then
12826: LD_VAR 0 1
12830: IFFALSE 12848
// Say ( speaker [ 1 ] , DAlienBase-Sci1-1 ) ;
12832: LD_VAR 0 1
12836: PUSH
12837: LD_INT 1
12839: ARRAY
12840: PPUSH
12841: LD_STRING DAlienBase-Sci1-1
12843: PPUSH
12844: CALL_OW 88
// end ; RemoveSeeing ( 255 , 219 , 7 ) ;
12848: LD_INT 255
12850: PPUSH
12851: LD_INT 219
12853: PPUSH
12854: LD_INT 7
12856: PPUSH
12857: CALL_OW 331
// DialogueOff ;
12861: CALL_OW 7
// repeat wait ( 0 0$1 ) ;
12865: LD_INT 35
12867: PPUSH
12868: CALL_OW 67
// until IsSelected ( alien ) ;
12872: LD_INT 1
12874: PPUSH
12875: CALL_OW 306
12879: IFFALSE 12865
// if not artifactIResearched or not artifactIIResearched then
12881: LD_EXP 12
12885: NOT
12886: PUSH
12887: LD_EXP 13
12891: NOT
12892: OR
12893: IFFALSE 13073
// begin if IsOk ( Roth ) then
12895: LD_EXP 22
12899: PPUSH
12900: CALL_OW 302
12904: IFFALSE 12920
// Say ( Roth , DAlieBaseNotReady-Roth-1 ) else
12906: LD_EXP 22
12910: PPUSH
12911: LD_STRING DAlieBaseNotReady-Roth-1
12913: PPUSH
12914: CALL_OW 88
12918: GO 13073
// if IsOk ( Gossudarov ) then
12920: LD_EXP 40
12924: PPUSH
12925: CALL_OW 302
12929: IFFALSE 12945
// Say ( Gossudarov , DAlieBaseNotReady-Gos-1 ) else
12931: LD_EXP 40
12935: PPUSH
12936: LD_STRING DAlieBaseNotReady-Gos-1
12938: PPUSH
12939: CALL_OW 88
12943: GO 13073
// begin speaker := FilterAllUnits ( [ [ f_side , 7 ] , [ f_nation , 3 ] , [ f_class , 4 ] , [ f_type , unit_human ] , [ f_sex , sex_male ] ] ) diff [ Roth , JMM , Burlak , Titov , Kuzmov , Kovalyuk ] ;
12945: LD_ADDR_VAR 0 1
12949: PUSH
12950: LD_INT 22
12952: PUSH
12953: LD_INT 7
12955: PUSH
12956: EMPTY
12957: LIST
12958: LIST
12959: PUSH
12960: LD_INT 23
12962: PUSH
12963: LD_INT 3
12965: PUSH
12966: EMPTY
12967: LIST
12968: LIST
12969: PUSH
12970: LD_INT 25
12972: PUSH
12973: LD_INT 4
12975: PUSH
12976: EMPTY
12977: LIST
12978: LIST
12979: PUSH
12980: LD_INT 21
12982: PUSH
12983: LD_INT 1
12985: PUSH
12986: EMPTY
12987: LIST
12988: LIST
12989: PUSH
12990: LD_INT 26
12992: PUSH
12993: LD_INT 1
12995: PUSH
12996: EMPTY
12997: LIST
12998: LIST
12999: PUSH
13000: EMPTY
13001: LIST
13002: LIST
13003: LIST
13004: LIST
13005: LIST
13006: PPUSH
13007: CALL_OW 69
13011: PUSH
13012: LD_EXP 22
13016: PUSH
13017: LD_EXP 21
13021: PUSH
13022: LD_EXP 54
13026: PUSH
13027: LD_EXP 42
13031: PUSH
13032: LD_EXP 52
13036: PUSH
13037: LD_EXP 51
13041: PUSH
13042: EMPTY
13043: LIST
13044: LIST
13045: LIST
13046: LIST
13047: LIST
13048: LIST
13049: DIFF
13050: ST_TO_ADDR
// if speaker then
13051: LD_VAR 0 1
13055: IFFALSE 13073
// Say ( speaker [ 1 ] , DAlieBaseNotReady-RSci1-1 ) ;
13057: LD_VAR 0 1
13061: PUSH
13062: LD_INT 1
13064: ARRAY
13065: PPUSH
13066: LD_STRING DAlieBaseNotReady-RSci1-1
13068: PPUSH
13069: CALL_OW 88
// end ; end ; end ;
13073: PPOPN 1
13075: END
// every 0 0$1 trigger GetTech ( tech_Artifact , 7 ) = state_researched do var speaker ;
13076: LD_INT 24
13078: PPUSH
13079: LD_INT 7
13081: PPUSH
13082: CALL_OW 321
13086: PUSH
13087: LD_INT 2
13089: EQUAL
13090: IFFALSE 13781
13092: GO 13094
13094: DISABLE
13095: LD_INT 0
13097: PPUSH
// begin speaker := FilterAllUnits ( [ [ f_side , 7 ] , [ f_nation , 3 ] , [ f_class , 4 ] , [ f_type , unit_human ] , [ f_sex , sex_male ] ] ) diff [ Roth , JMM , Burlak , Titov , Kuzmov , Kovalyuk ] ;
13098: LD_ADDR_VAR 0 1
13102: PUSH
13103: LD_INT 22
13105: PUSH
13106: LD_INT 7
13108: PUSH
13109: EMPTY
13110: LIST
13111: LIST
13112: PUSH
13113: LD_INT 23
13115: PUSH
13116: LD_INT 3
13118: PUSH
13119: EMPTY
13120: LIST
13121: LIST
13122: PUSH
13123: LD_INT 25
13125: PUSH
13126: LD_INT 4
13128: PUSH
13129: EMPTY
13130: LIST
13131: LIST
13132: PUSH
13133: LD_INT 21
13135: PUSH
13136: LD_INT 1
13138: PUSH
13139: EMPTY
13140: LIST
13141: LIST
13142: PUSH
13143: LD_INT 26
13145: PUSH
13146: LD_INT 1
13148: PUSH
13149: EMPTY
13150: LIST
13151: LIST
13152: PUSH
13153: EMPTY
13154: LIST
13155: LIST
13156: LIST
13157: LIST
13158: LIST
13159: PPUSH
13160: CALL_OW 69
13164: PUSH
13165: LD_EXP 22
13169: PUSH
13170: LD_EXP 21
13174: PUSH
13175: LD_EXP 54
13179: PUSH
13180: LD_EXP 42
13184: PUSH
13185: LD_EXP 52
13189: PUSH
13190: LD_EXP 51
13194: PUSH
13195: EMPTY
13196: LIST
13197: LIST
13198: LIST
13199: LIST
13200: LIST
13201: LIST
13202: DIFF
13203: ST_TO_ADDR
// if not speaker then
13204: LD_VAR 0 1
13208: NOT
13209: IFFALSE 13213
// exit ;
13211: GO 13781
// DialogueOn ;
13213: CALL_OW 6
// Say ( speaker [ 1 ] , DArtefTechnology-RSci1-1 ) ;
13217: LD_VAR 0 1
13221: PUSH
13222: LD_INT 1
13224: ARRAY
13225: PPUSH
13226: LD_STRING DArtefTechnology-RSci1-1
13228: PPUSH
13229: CALL_OW 88
// if IsOk ( Burlak ) then
13233: LD_EXP 54
13237: PPUSH
13238: CALL_OW 302
13242: IFFALSE 13256
// Say ( Burlak , DArtefTechnology-Bur-1 ) ;
13244: LD_EXP 54
13248: PPUSH
13249: LD_STRING DArtefTechnology-Bur-1
13251: PPUSH
13252: CALL_OW 88
// Say ( speaker [ 1 ] , DArtefTechnology-RSci1-2 ) ;
13256: LD_VAR 0 1
13260: PUSH
13261: LD_INT 1
13263: ARRAY
13264: PPUSH
13265: LD_STRING DArtefTechnology-RSci1-2
13267: PPUSH
13268: CALL_OW 88
// if Denis then
13272: LD_EXP 27
13276: IFFALSE 13293
// speaker := [ Denis ] else
13278: LD_ADDR_VAR 0 1
13282: PUSH
13283: LD_EXP 27
13287: PUSH
13288: EMPTY
13289: LIST
13290: ST_TO_ADDR
13291: GO 13399
// speaker := FilterAllUnits ( [ [ f_side , 7 ] , [ f_nation , 1 ] , [ f_class , 4 ] , [ f_type , unit_human ] , [ f_sex , sex_male ] ] ) diff [ Roth , JMM , Burlak , Titov , Kuzmov , Kovalyuk ] ;
13293: LD_ADDR_VAR 0 1
13297: PUSH
13298: LD_INT 22
13300: PUSH
13301: LD_INT 7
13303: PUSH
13304: EMPTY
13305: LIST
13306: LIST
13307: PUSH
13308: LD_INT 23
13310: PUSH
13311: LD_INT 1
13313: PUSH
13314: EMPTY
13315: LIST
13316: LIST
13317: PUSH
13318: LD_INT 25
13320: PUSH
13321: LD_INT 4
13323: PUSH
13324: EMPTY
13325: LIST
13326: LIST
13327: PUSH
13328: LD_INT 21
13330: PUSH
13331: LD_INT 1
13333: PUSH
13334: EMPTY
13335: LIST
13336: LIST
13337: PUSH
13338: LD_INT 26
13340: PUSH
13341: LD_INT 1
13343: PUSH
13344: EMPTY
13345: LIST
13346: LIST
13347: PUSH
13348: EMPTY
13349: LIST
13350: LIST
13351: LIST
13352: LIST
13353: LIST
13354: PPUSH
13355: CALL_OW 69
13359: PUSH
13360: LD_EXP 22
13364: PUSH
13365: LD_EXP 21
13369: PUSH
13370: LD_EXP 54
13374: PUSH
13375: LD_EXP 42
13379: PUSH
13380: LD_EXP 52
13384: PUSH
13385: LD_EXP 51
13389: PUSH
13390: EMPTY
13391: LIST
13392: LIST
13393: LIST
13394: LIST
13395: LIST
13396: LIST
13397: DIFF
13398: ST_TO_ADDR
// if speaker then
13399: LD_VAR 0 1
13403: IFFALSE 13421
// Say ( speaker [ 1 ] , DArtefTechnology-Sci1-2 ) ;
13405: LD_VAR 0 1
13409: PUSH
13410: LD_INT 1
13412: ARRAY
13413: PPUSH
13414: LD_STRING DArtefTechnology-Sci1-2
13416: PPUSH
13417: CALL_OW 88
// speaker := FilterAllUnits ( [ [ f_side , 7 ] , [ f_nation , 3 ] , [ f_class , 4 ] , [ f_type , unit_human ] , [ f_sex , sex_male ] ] ) diff [ Roth , JMM , Burlak , Titov , Kuzmov , Kovalyuk ] ;
13421: LD_ADDR_VAR 0 1
13425: PUSH
13426: LD_INT 22
13428: PUSH
13429: LD_INT 7
13431: PUSH
13432: EMPTY
13433: LIST
13434: LIST
13435: PUSH
13436: LD_INT 23
13438: PUSH
13439: LD_INT 3
13441: PUSH
13442: EMPTY
13443: LIST
13444: LIST
13445: PUSH
13446: LD_INT 25
13448: PUSH
13449: LD_INT 4
13451: PUSH
13452: EMPTY
13453: LIST
13454: LIST
13455: PUSH
13456: LD_INT 21
13458: PUSH
13459: LD_INT 1
13461: PUSH
13462: EMPTY
13463: LIST
13464: LIST
13465: PUSH
13466: LD_INT 26
13468: PUSH
13469: LD_INT 1
13471: PUSH
13472: EMPTY
13473: LIST
13474: LIST
13475: PUSH
13476: EMPTY
13477: LIST
13478: LIST
13479: LIST
13480: LIST
13481: LIST
13482: PPUSH
13483: CALL_OW 69
13487: PUSH
13488: LD_EXP 22
13492: PUSH
13493: LD_EXP 21
13497: PUSH
13498: LD_EXP 54
13502: PUSH
13503: LD_EXP 42
13507: PUSH
13508: LD_EXP 52
13512: PUSH
13513: LD_EXP 51
13517: PUSH
13518: EMPTY
13519: LIST
13520: LIST
13521: LIST
13522: LIST
13523: LIST
13524: LIST
13525: DIFF
13526: ST_TO_ADDR
// if speaker and ( artifactArCaptured or arabianDestroyed ) then
13527: LD_VAR 0 1
13531: PUSH
13532: LD_EXP 9
13536: PUSH
13537: LD_EXP 5
13541: OR
13542: AND
13543: IFFALSE 13777
// begin if arabianDestroyed and IsOk ( Burlak ) then
13545: LD_EXP 5
13549: PUSH
13550: LD_EXP 54
13554: PPUSH
13555: CALL_OW 302
13559: AND
13560: IFFALSE 13576
// Say ( Burlak , DArtefTechnology-Bur-2 ) else
13562: LD_EXP 54
13566: PPUSH
13567: LD_STRING DArtefTechnology-Bur-2
13569: PPUSH
13570: CALL_OW 88
13574: GO 13588
// Say ( JMM , DArtefTechnology-JMM-2 ) ;
13576: LD_EXP 21
13580: PPUSH
13581: LD_STRING DArtefTechnology-JMM-2
13583: PPUSH
13584: CALL_OW 88
// Say ( speaker [ 1 ] , DArtefTechnology-RSci1-3 ) ;
13588: LD_VAR 0 1
13592: PUSH
13593: LD_INT 1
13595: ARRAY
13596: PPUSH
13597: LD_STRING DArtefTechnology-RSci1-3
13599: PPUSH
13600: CALL_OW 88
// if Denis then
13604: LD_EXP 27
13608: IFFALSE 13625
// speaker := [ Denis ] else
13610: LD_ADDR_VAR 0 1
13614: PUSH
13615: LD_EXP 27
13619: PUSH
13620: EMPTY
13621: LIST
13622: ST_TO_ADDR
13623: GO 13731
// speaker := FilterAllUnits ( [ [ f_side , 7 ] , [ f_nation , 1 ] , [ f_class , 4 ] , [ f_type , unit_human ] , [ f_sex , sex_male ] ] ) diff [ Roth , JMM , Burlak , Titov , Kuzmov , Kovalyuk ] ;
13625: LD_ADDR_VAR 0 1
13629: PUSH
13630: LD_INT 22
13632: PUSH
13633: LD_INT 7
13635: PUSH
13636: EMPTY
13637: LIST
13638: LIST
13639: PUSH
13640: LD_INT 23
13642: PUSH
13643: LD_INT 1
13645: PUSH
13646: EMPTY
13647: LIST
13648: LIST
13649: PUSH
13650: LD_INT 25
13652: PUSH
13653: LD_INT 4
13655: PUSH
13656: EMPTY
13657: LIST
13658: LIST
13659: PUSH
13660: LD_INT 21
13662: PUSH
13663: LD_INT 1
13665: PUSH
13666: EMPTY
13667: LIST
13668: LIST
13669: PUSH
13670: LD_INT 26
13672: PUSH
13673: LD_INT 1
13675: PUSH
13676: EMPTY
13677: LIST
13678: LIST
13679: PUSH
13680: EMPTY
13681: LIST
13682: LIST
13683: LIST
13684: LIST
13685: LIST
13686: PPUSH
13687: CALL_OW 69
13691: PUSH
13692: LD_EXP 22
13696: PUSH
13697: LD_EXP 21
13701: PUSH
13702: LD_EXP 54
13706: PUSH
13707: LD_EXP 42
13711: PUSH
13712: LD_EXP 52
13716: PUSH
13717: LD_EXP 51
13721: PUSH
13722: EMPTY
13723: LIST
13724: LIST
13725: LIST
13726: LIST
13727: LIST
13728: LIST
13729: DIFF
13730: ST_TO_ADDR
// if speaker then
13731: LD_VAR 0 1
13735: IFFALSE 13777
// if alienSpotted then
13737: LD_EXP 10
13741: IFFALSE 13761
// Say ( speaker [ 1 ] , DArtefTechnology-Sci1-3 ) else
13743: LD_VAR 0 1
13747: PUSH
13748: LD_INT 1
13750: ARRAY
13751: PPUSH
13752: LD_STRING DArtefTechnology-Sci1-3
13754: PPUSH
13755: CALL_OW 88
13759: GO 13777
// Say ( speaker [ 1 ] , DArtefTechnology-Sci1-3a ) ;
13761: LD_VAR 0 1
13765: PUSH
13766: LD_INT 1
13768: ARRAY
13769: PPUSH
13770: LD_STRING DArtefTechnology-Sci1-3a
13772: PPUSH
13773: CALL_OW 88
// end ; DialogueOff ;
13777: CALL_OW 7
// end ;
13781: PPOPN 1
13783: END
// every 0 0$1 trigger artifactIResearched do var speaker ;
13784: LD_EXP 12
13788: IFFALSE 13991
13790: GO 13792
13792: DISABLE
13793: LD_INT 0
13795: PPUSH
// begin if Denis then
13796: LD_EXP 27
13800: IFFALSE 13817
// speaker := [ Denis ] else
13802: LD_ADDR_VAR 0 1
13806: PUSH
13807: LD_EXP 27
13811: PUSH
13812: EMPTY
13813: LIST
13814: ST_TO_ADDR
13815: GO 13923
// speaker := FilterAllUnits ( [ [ f_side , 7 ] , [ f_nation , 1 ] , [ f_class , 4 ] , [ f_type , unit_human ] , [ f_sex , sex_male ] ] ) diff [ Roth , JMM , Burlak , Titov , Kuzmov , Kovalyuk ] ;
13817: LD_ADDR_VAR 0 1
13821: PUSH
13822: LD_INT 22
13824: PUSH
13825: LD_INT 7
13827: PUSH
13828: EMPTY
13829: LIST
13830: LIST
13831: PUSH
13832: LD_INT 23
13834: PUSH
13835: LD_INT 1
13837: PUSH
13838: EMPTY
13839: LIST
13840: LIST
13841: PUSH
13842: LD_INT 25
13844: PUSH
13845: LD_INT 4
13847: PUSH
13848: EMPTY
13849: LIST
13850: LIST
13851: PUSH
13852: LD_INT 21
13854: PUSH
13855: LD_INT 1
13857: PUSH
13858: EMPTY
13859: LIST
13860: LIST
13861: PUSH
13862: LD_INT 26
13864: PUSH
13865: LD_INT 1
13867: PUSH
13868: EMPTY
13869: LIST
13870: LIST
13871: PUSH
13872: EMPTY
13873: LIST
13874: LIST
13875: LIST
13876: LIST
13877: LIST
13878: PPUSH
13879: CALL_OW 69
13883: PUSH
13884: LD_EXP 22
13888: PUSH
13889: LD_EXP 21
13893: PUSH
13894: LD_EXP 54
13898: PUSH
13899: LD_EXP 42
13903: PUSH
13904: LD_EXP 52
13908: PUSH
13909: LD_EXP 51
13913: PUSH
13914: EMPTY
13915: LIST
13916: LIST
13917: LIST
13918: LIST
13919: LIST
13920: LIST
13921: DIFF
13922: ST_TO_ADDR
// if not speaker then
13923: LD_VAR 0 1
13927: NOT
13928: IFFALSE 13932
// exit ;
13930: GO 13991
// DialogueOn ;
13932: CALL_OW 6
// Say ( speaker [ 1 ] , DArtefTechnologyAm-Sci1-1 ) ;
13936: LD_VAR 0 1
13940: PUSH
13941: LD_INT 1
13943: ARRAY
13944: PPUSH
13945: LD_STRING DArtefTechnologyAm-Sci1-1
13947: PPUSH
13948: CALL_OW 88
// if IsOk ( Burlak ) then
13952: LD_EXP 54
13956: PPUSH
13957: CALL_OW 302
13961: IFFALSE 13975
// Say ( Burlak , DArtefTechnologyAm-Bur-1 ) ;
13963: LD_EXP 54
13967: PPUSH
13968: LD_STRING DArtefTechnologyAm-Bur-1
13970: PPUSH
13971: CALL_OW 88
// Say ( JMM , DArtefTechnologyAm-JMM-1 ) ;
13975: LD_EXP 21
13979: PPUSH
13980: LD_STRING DArtefTechnologyAm-JMM-1
13982: PPUSH
13983: CALL_OW 88
// DialogueOff ;
13987: CALL_OW 7
// end ;
13991: PPOPN 1
13993: END
// every 0 0$1 trigger artifactIIResearched do var speaker ;
13994: LD_EXP 13
13998: IFFALSE 14200
14000: GO 14002
14002: DISABLE
14003: LD_INT 0
14005: PPUSH
// begin speaker := FilterAllUnits ( [ [ f_side , 7 ] , [ f_nation , 3 ] , [ f_class , 4 ] , [ f_type , unit_human ] , [ f_sex , sex_male ] ] ) diff [ Roth , JMM , Burlak , Titov , Kuzmov , Kovalyuk ] ;
14006: LD_ADDR_VAR 0 1
14010: PUSH
14011: LD_INT 22
14013: PUSH
14014: LD_INT 7
14016: PUSH
14017: EMPTY
14018: LIST
14019: LIST
14020: PUSH
14021: LD_INT 23
14023: PUSH
14024: LD_INT 3
14026: PUSH
14027: EMPTY
14028: LIST
14029: LIST
14030: PUSH
14031: LD_INT 25
14033: PUSH
14034: LD_INT 4
14036: PUSH
14037: EMPTY
14038: LIST
14039: LIST
14040: PUSH
14041: LD_INT 21
14043: PUSH
14044: LD_INT 1
14046: PUSH
14047: EMPTY
14048: LIST
14049: LIST
14050: PUSH
14051: LD_INT 26
14053: PUSH
14054: LD_INT 1
14056: PUSH
14057: EMPTY
14058: LIST
14059: LIST
14060: PUSH
14061: EMPTY
14062: LIST
14063: LIST
14064: LIST
14065: LIST
14066: LIST
14067: PPUSH
14068: CALL_OW 69
14072: PUSH
14073: LD_EXP 22
14077: PUSH
14078: LD_EXP 21
14082: PUSH
14083: LD_EXP 54
14087: PUSH
14088: LD_EXP 42
14092: PUSH
14093: LD_EXP 52
14097: PUSH
14098: LD_EXP 51
14102: PUSH
14103: EMPTY
14104: LIST
14105: LIST
14106: LIST
14107: LIST
14108: LIST
14109: LIST
14110: DIFF
14111: ST_TO_ADDR
// if not speaker then
14112: LD_VAR 0 1
14116: NOT
14117: IFFALSE 14121
// exit ;
14119: GO 14200
// DialogueOn ;
14121: CALL_OW 6
// Say ( speaker [ speaker ] , DArtefTechnologyRu-RSci1-1 ) ;
14125: LD_VAR 0 1
14129: PUSH
14130: LD_VAR 0 1
14134: ARRAY
14135: PPUSH
14136: LD_STRING DArtefTechnologyRu-RSci1-1
14138: PPUSH
14139: CALL_OW 88
// if IsOk ( Burlak ) then
14143: LD_EXP 54
14147: PPUSH
14148: CALL_OW 302
14152: IFFALSE 14166
// Say ( Burlak , DArtefTechnologyRu-Bur-1 ) ;
14154: LD_EXP 54
14158: PPUSH
14159: LD_STRING DArtefTechnologyRu-Bur-1
14161: PPUSH
14162: CALL_OW 88
// Say ( speaker [ speaker ] , DArtefTechnologyRu-RSci1-2 ) ;
14166: LD_VAR 0 1
14170: PUSH
14171: LD_VAR 0 1
14175: ARRAY
14176: PPUSH
14177: LD_STRING DArtefTechnologyRu-RSci1-2
14179: PPUSH
14180: CALL_OW 88
// Say ( JMM , DArtefTechnologyRu-JMM-1 ) ;
14184: LD_EXP 21
14188: PPUSH
14189: LD_STRING DArtefTechnologyRu-JMM-1
14191: PPUSH
14192: CALL_OW 88
// DialogueOff ;
14196: CALL_OW 7
// end ;
14200: PPOPN 1
14202: END
// every 0 0$1 trigger GetTech ( tech_Artifact , 7 ) = state_researched and GetSide ( alien ) = 7 do var speaker ;
14203: LD_INT 24
14205: PPUSH
14206: LD_INT 7
14208: PPUSH
14209: CALL_OW 321
14213: PUSH
14214: LD_INT 2
14216: EQUAL
14217: PUSH
14218: LD_INT 1
14220: PPUSH
14221: CALL_OW 255
14225: PUSH
14226: LD_INT 7
14228: EQUAL
14229: AND
14230: IFFALSE 14398
14232: GO 14234
14234: DISABLE
14235: LD_INT 0
14237: PPUSH
// begin if Denis then
14238: LD_EXP 27
14242: IFFALSE 14259
// speaker := [ Denis ] else
14244: LD_ADDR_VAR 0 1
14248: PUSH
14249: LD_EXP 27
14253: PUSH
14254: EMPTY
14255: LIST
14256: ST_TO_ADDR
14257: GO 14365
// speaker := FilterAllUnits ( [ [ f_side , 7 ] , [ f_nation , 1 ] , [ f_class , 4 ] , [ f_type , unit_human ] , [ f_sex , sex_male ] ] ) diff [ Roth , JMM , Burlak , Titov , Kuzmov , Kovalyuk ] ;
14259: LD_ADDR_VAR 0 1
14263: PUSH
14264: LD_INT 22
14266: PUSH
14267: LD_INT 7
14269: PUSH
14270: EMPTY
14271: LIST
14272: LIST
14273: PUSH
14274: LD_INT 23
14276: PUSH
14277: LD_INT 1
14279: PUSH
14280: EMPTY
14281: LIST
14282: LIST
14283: PUSH
14284: LD_INT 25
14286: PUSH
14287: LD_INT 4
14289: PUSH
14290: EMPTY
14291: LIST
14292: LIST
14293: PUSH
14294: LD_INT 21
14296: PUSH
14297: LD_INT 1
14299: PUSH
14300: EMPTY
14301: LIST
14302: LIST
14303: PUSH
14304: LD_INT 26
14306: PUSH
14307: LD_INT 1
14309: PUSH
14310: EMPTY
14311: LIST
14312: LIST
14313: PUSH
14314: EMPTY
14315: LIST
14316: LIST
14317: LIST
14318: LIST
14319: LIST
14320: PPUSH
14321: CALL_OW 69
14325: PUSH
14326: LD_EXP 22
14330: PUSH
14331: LD_EXP 21
14335: PUSH
14336: LD_EXP 54
14340: PUSH
14341: LD_EXP 42
14345: PUSH
14346: LD_EXP 52
14350: PUSH
14351: LD_EXP 51
14355: PUSH
14356: EMPTY
14357: LIST
14358: LIST
14359: LIST
14360: LIST
14361: LIST
14362: LIST
14363: DIFF
14364: ST_TO_ADDR
// if not speaker then
14365: LD_VAR 0 1
14369: NOT
14370: IFFALSE 14374
// exit ;
14372: GO 14398
// DialogueOn ;
14374: CALL_OW 6
// Say ( speaker [ 1 ] , DArtefTechnologyArStart-Sci1-1 ) ;
14378: LD_VAR 0 1
14382: PUSH
14383: LD_INT 1
14385: ARRAY
14386: PPUSH
14387: LD_STRING DArtefTechnologyArStart-Sci1-1
14389: PPUSH
14390: CALL_OW 88
// DialogueOff ;
14394: CALL_OW 7
// end ;
14398: PPOPN 1
14400: END
// every 0 0$1 trigger artifactIIIResearched do var speaker ;
14401: LD_EXP 14
14405: IFFALSE 14686
14407: GO 14409
14409: DISABLE
14410: LD_INT 0
14412: PPUSH
// begin speaker := FilterAllUnits ( [ [ f_side , 7 ] , [ f_nation , 3 ] , [ f_class , 4 ] , [ f_type , unit_human ] , [ f_sex , sex_male ] ] ) diff [ Roth , JMM , Burlak , Titov , Kuzmov , Kovalyuk ] ;
14413: LD_ADDR_VAR 0 1
14417: PUSH
14418: LD_INT 22
14420: PUSH
14421: LD_INT 7
14423: PUSH
14424: EMPTY
14425: LIST
14426: LIST
14427: PUSH
14428: LD_INT 23
14430: PUSH
14431: LD_INT 3
14433: PUSH
14434: EMPTY
14435: LIST
14436: LIST
14437: PUSH
14438: LD_INT 25
14440: PUSH
14441: LD_INT 4
14443: PUSH
14444: EMPTY
14445: LIST
14446: LIST
14447: PUSH
14448: LD_INT 21
14450: PUSH
14451: LD_INT 1
14453: PUSH
14454: EMPTY
14455: LIST
14456: LIST
14457: PUSH
14458: LD_INT 26
14460: PUSH
14461: LD_INT 1
14463: PUSH
14464: EMPTY
14465: LIST
14466: LIST
14467: PUSH
14468: EMPTY
14469: LIST
14470: LIST
14471: LIST
14472: LIST
14473: LIST
14474: PPUSH
14475: CALL_OW 69
14479: PUSH
14480: LD_EXP 22
14484: PUSH
14485: LD_EXP 21
14489: PUSH
14490: LD_EXP 54
14494: PUSH
14495: LD_EXP 42
14499: PUSH
14500: LD_EXP 52
14504: PUSH
14505: LD_EXP 51
14509: PUSH
14510: EMPTY
14511: LIST
14512: LIST
14513: LIST
14514: LIST
14515: LIST
14516: LIST
14517: DIFF
14518: ST_TO_ADDR
// if not speaker then
14519: LD_VAR 0 1
14523: NOT
14524: IFFALSE 14528
// exit ;
14526: GO 14686
// DialogueOn ;
14528: CALL_OW 6
// Say ( speaker [ 1 ] , DArtefTechnologyAr-RSci1-1 ) ;
14532: LD_VAR 0 1
14536: PUSH
14537: LD_INT 1
14539: ARRAY
14540: PPUSH
14541: LD_STRING DArtefTechnologyAr-RSci1-1
14543: PPUSH
14544: CALL_OW 88
// Say ( JMM , DArtefTechnologyAr-JMM-1 ) ;
14548: LD_EXP 21
14552: PPUSH
14553: LD_STRING DArtefTechnologyAr-JMM-1
14555: PPUSH
14556: CALL_OW 88
// Say ( speaker [ 1 ] , DArtefTechnologyAr-RSci1-2 ) ;
14560: LD_VAR 0 1
14564: PUSH
14565: LD_INT 1
14567: ARRAY
14568: PPUSH
14569: LD_STRING DArtefTechnologyAr-RSci1-2
14571: PPUSH
14572: CALL_OW 88
// Say ( JMM , DArtefTechnologyAr-JMM-2 ) ;
14576: LD_EXP 21
14580: PPUSH
14581: LD_STRING DArtefTechnologyAr-JMM-2
14583: PPUSH
14584: CALL_OW 88
// Say ( speaker [ 1 ] , DArtefTechnologyAr-RSci1-3 ) ;
14588: LD_VAR 0 1
14592: PUSH
14593: LD_INT 1
14595: ARRAY
14596: PPUSH
14597: LD_STRING DArtefTechnologyAr-RSci1-3
14599: PPUSH
14600: CALL_OW 88
// Say ( JMM , DArtefTechnologyAr-JMM-3 ) ;
14604: LD_EXP 21
14608: PPUSH
14609: LD_STRING DArtefTechnologyAr-JMM-3
14611: PPUSH
14612: CALL_OW 88
// Say ( speaker [ 1 ] , DArtefTechnologyAr-RSci1-4 ) ;
14616: LD_VAR 0 1
14620: PUSH
14621: LD_INT 1
14623: ARRAY
14624: PPUSH
14625: LD_STRING DArtefTechnologyAr-RSci1-4
14627: PPUSH
14628: CALL_OW 88
// if IsOk ( Burlak ) then
14632: LD_EXP 54
14636: PPUSH
14637: CALL_OW 302
14641: IFFALSE 14655
// Say ( Burlak , DArtefTechnologyAr-Bur-4 ) ;
14643: LD_EXP 54
14647: PPUSH
14648: LD_STRING DArtefTechnologyAr-Bur-4
14650: PPUSH
14651: CALL_OW 88
// Say ( JMM , DArtefTechnologyAr-JMM-4 ) ;
14655: LD_EXP 21
14659: PPUSH
14660: LD_STRING DArtefTechnologyAr-JMM-4
14662: PPUSH
14663: CALL_OW 88
// DialogueOff ;
14667: CALL_OW 7
// wait ( 0 0$45 ) ;
14671: LD_INT 1575
14673: PPUSH
14674: CALL_OW 67
// spawnOmar := true ;
14678: LD_ADDR_EXP 11
14682: PUSH
14683: LD_INT 1
14685: ST_TO_ADDR
// end ;
14686: PPOPN 1
14688: END
// every 0 0$1 trigger spawnOmar and negotiationWithArabs do
14689: LD_EXP 11
14693: PUSH
14694: LD_EXP 19
14698: AND
14699: IFFALSE 15078
14701: GO 14703
14703: DISABLE
// begin PrepareOmarAli ;
14704: CALL 7546 0 0
// if not HasTask ( Omar ) then
14708: LD_EXP 58
14712: PPUSH
14713: CALL_OW 314
14717: NOT
14718: IFFALSE 14735
// ComMoveXY ( Omar , 252 , 220 ) ;
14720: LD_EXP 58
14724: PPUSH
14725: LD_INT 252
14727: PPUSH
14728: LD_INT 220
14730: PPUSH
14731: CALL_OW 111
// repeat wait ( 0 0$1 ) ;
14735: LD_INT 35
14737: PPUSH
14738: CALL_OW 67
// if omarKilled then
14742: LD_EXP 20
14746: IFFALSE 14750
// exit ;
14748: GO 15078
// if not HasTask ( Omar ) and GetDistUnitXY ( Omar , 252 , 220 ) > 6 then
14750: LD_EXP 58
14754: PPUSH
14755: CALL_OW 314
14759: NOT
14760: PUSH
14761: LD_EXP 58
14765: PPUSH
14766: LD_INT 252
14768: PPUSH
14769: LD_INT 220
14771: PPUSH
14772: CALL_OW 297
14776: PUSH
14777: LD_INT 6
14779: GREATER
14780: AND
14781: IFFALSE 14798
// ComMoveXY ( Omar , 252 , 220 ) ;
14783: LD_EXP 58
14787: PPUSH
14788: LD_INT 252
14790: PPUSH
14791: LD_INT 220
14793: PPUSH
14794: CALL_OW 111
// until See ( 7 , Omar ) ;
14798: LD_INT 7
14800: PPUSH
14801: LD_EXP 58
14805: PPUSH
14806: CALL_OW 292
14810: IFFALSE 14735
// CenterNowOnUnits ( Omar ) ;
14812: LD_EXP 58
14816: PPUSH
14817: CALL_OW 87
// DialogueOn ;
14821: CALL_OW 6
// Say ( Omar , DOmar-Omar-1 ) ;
14825: LD_EXP 58
14829: PPUSH
14830: LD_STRING DOmar-Omar-1
14832: PPUSH
14833: CALL_OW 88
// Say ( JMM , DOmar-JMM-1 ) ;
14837: LD_EXP 21
14841: PPUSH
14842: LD_STRING DOmar-JMM-1
14844: PPUSH
14845: CALL_OW 88
// Say ( Omar , DOmar-Omar-2 ) ;
14849: LD_EXP 58
14853: PPUSH
14854: LD_STRING DOmar-Omar-2
14856: PPUSH
14857: CALL_OW 88
// Say ( JMM , DOmar-JMM-2 ) ;
14861: LD_EXP 21
14865: PPUSH
14866: LD_STRING DOmar-JMM-2
14868: PPUSH
14869: CALL_OW 88
// Say ( Omar , DOmar-Omar-3 ) ;
14873: LD_EXP 58
14877: PPUSH
14878: LD_STRING DOmar-Omar-3
14880: PPUSH
14881: CALL_OW 88
// if IsOk ( Burlak ) then
14885: LD_EXP 54
14889: PPUSH
14890: CALL_OW 302
14894: IFFALSE 14910
// Say ( Burlak , DOmar-Bur-3 ) else
14896: LD_EXP 54
14900: PPUSH
14901: LD_STRING DOmar-Bur-3
14903: PPUSH
14904: CALL_OW 88
14908: GO 14922
// Say ( JMM , DOmar-JMM-3 ) ;
14910: LD_EXP 21
14914: PPUSH
14915: LD_STRING DOmar-JMM-3
14917: PPUSH
14918: CALL_OW 88
// Say ( Omar , DOmar-Omar-4 ) ;
14922: LD_EXP 58
14926: PPUSH
14927: LD_STRING DOmar-Omar-4
14929: PPUSH
14930: CALL_OW 88
// case Query ( QAccept ) of 1 :
14934: LD_STRING QAccept
14936: PPUSH
14937: CALL_OW 97
14941: PUSH
14942: LD_INT 1
14944: DOUBLE
14945: EQUAL
14946: IFTRUE 14950
14948: GO 14986
14950: POP
// begin Say ( JMM , DQrAccept#1-JMM-1 ) ;
14951: LD_EXP 21
14955: PPUSH
14956: LD_STRING DQrAccept#1-JMM-1
14958: PPUSH
14959: CALL_OW 88
// SetSide ( Omar , 7 ) ;
14963: LD_EXP 58
14967: PPUSH
14968: LD_INT 7
14970: PPUSH
14971: CALL_OW 235
// ComStop ( Omar ) ;
14975: LD_EXP 58
14979: PPUSH
14980: CALL_OW 141
// end ; 2 :
14984: GO 15035
14986: LD_INT 2
14988: DOUBLE
14989: EQUAL
14990: IFTRUE 14994
14992: GO 15034
14994: POP
// begin if IsOk ( Burlak ) then
14995: LD_EXP 54
14999: PPUSH
15000: CALL_OW 302
15004: IFFALSE 15020
// Say ( Burlak , DQrAccept#2-Bur-1 ) else
15006: LD_EXP 54
15010: PPUSH
15011: LD_STRING DQrAccept#2-Bur-1
15013: PPUSH
15014: CALL_OW 88
15018: GO 15032
// Say ( JMM , DQrAccept#2-JMM-1 ) ;
15020: LD_EXP 21
15024: PPUSH
15025: LD_STRING DQrAccept#2-JMM-1
15027: PPUSH
15028: CALL_OW 88
// end ; end ;
15032: GO 15035
15034: POP
// DialogueOff ;
15035: CALL_OW 7
// if GetSide ( Omar ) = 7 then
15039: LD_EXP 58
15043: PPUSH
15044: CALL_OW 255
15048: PUSH
15049: LD_INT 7
15051: EQUAL
15052: IFFALSE 15063
// begin SetAchievement ( ACH_OMAR ) ;
15054: LD_STRING ACH_OMAR
15056: PPUSH
15057: CALL_OW 543
// exit ;
15061: GO 15078
// end ; ComMoveXY ( Omar , 202 , 115 ) ;
15063: LD_EXP 58
15067: PPUSH
15068: LD_INT 202
15070: PPUSH
15071: LD_INT 115
15073: PPUSH
15074: CALL_OW 111
// end ;
15078: END
// every 0 0$1 trigger not omarKilled and russianDestroyed and ( ( IsOk ( Omar ) and GetSide ( Omar ) = 7 ) or not negotiationWithArabs ) do var i ;
15079: LD_EXP 20
15083: NOT
15084: PUSH
15085: LD_EXP 2
15089: AND
15090: PUSH
15091: LD_EXP 58
15095: PPUSH
15096: CALL_OW 302
15100: PUSH
15101: LD_EXP 58
15105: PPUSH
15106: CALL_OW 255
15110: PUSH
15111: LD_INT 7
15113: EQUAL
15114: AND
15115: PUSH
15116: LD_EXP 19
15120: NOT
15121: OR
15122: AND
15123: IFFALSE 15641
15125: GO 15127
15127: DISABLE
15128: LD_INT 0
15130: PPUSH
// begin if not negotiationWithArabs and not omarKilled then
15131: LD_EXP 19
15135: NOT
15136: PUSH
15137: LD_EXP 20
15141: NOT
15142: AND
15143: IFFALSE 15149
// PrepareOmarAli2 ;
15145: CALL 7616 0 0
// wait ( 0 0$2 ) ;
15149: LD_INT 70
15151: PPUSH
15152: CALL_OW 67
// SetSide ( Omar , 5 ) ;
15156: LD_EXP 58
15160: PPUSH
15161: LD_INT 5
15163: PPUSH
15164: CALL_OW 235
// if IsInUnit ( Omar ) then
15168: LD_EXP 58
15172: PPUSH
15173: CALL_OW 310
15177: IFFALSE 15188
// ComExitVehicle ( Omar ) ;
15179: LD_EXP 58
15183: PPUSH
15184: CALL_OW 121
// if IsInUnit ( Omar ) then
15188: LD_EXP 58
15192: PPUSH
15193: CALL_OW 310
15197: IFFALSE 15208
// ComExitBuilding ( Omar ) ;
15199: LD_EXP 58
15203: PPUSH
15204: CALL_OW 122
// wait ( 0 0$1 ) ;
15208: LD_INT 35
15210: PPUSH
15211: CALL_OW 67
// ComMoveXY ( Omar , 203 , 120 ) ;
15215: LD_EXP 58
15219: PPUSH
15220: LD_INT 203
15222: PPUSH
15223: LD_INT 120
15225: PPUSH
15226: CALL_OW 111
// repeat wait ( 0 0$1 ) ;
15230: LD_INT 35
15232: PPUSH
15233: CALL_OW 67
// if omarKilled then
15237: LD_EXP 20
15241: IFFALSE 15245
// exit ;
15243: GO 15641
// until IsSelected ( Omar ) or GetDistUnitXY ( Omar , 203 , 120 ) < 20 ;
15245: LD_EXP 58
15249: PPUSH
15250: CALL_OW 306
15254: PUSH
15255: LD_EXP 58
15259: PPUSH
15260: LD_INT 203
15262: PPUSH
15263: LD_INT 120
15265: PPUSH
15266: CALL_OW 297
15270: PUSH
15271: LD_INT 20
15273: LESS
15274: OR
15275: IFFALSE 15230
// DialogueOn ;
15277: CALL_OW 6
// PlaceSeeing ( GetX ( Omar ) , GetY ( Omar ) , 7 , - 6 ) ;
15281: LD_EXP 58
15285: PPUSH
15286: CALL_OW 250
15290: PPUSH
15291: LD_EXP 58
15295: PPUSH
15296: CALL_OW 251
15300: PPUSH
15301: LD_INT 7
15303: PPUSH
15304: LD_INT 6
15306: NEG
15307: PPUSH
15308: CALL_OW 330
// CenterNowOnUnits ( Omar ) ;
15312: LD_EXP 58
15316: PPUSH
15317: CALL_OW 87
// Say ( JMM , DOmarContam-JMM-1 ) ;
15321: LD_EXP 21
15325: PPUSH
15326: LD_STRING DOmarContam-JMM-1
15328: PPUSH
15329: CALL_OW 88
// Say ( Omar , DOmarContam-Omar-1 ) ;
15333: LD_EXP 58
15337: PPUSH
15338: LD_STRING DOmarContam-Omar-1
15340: PPUSH
15341: CALL_OW 88
// Say ( JMM , DOmarContam-JMM-2 ) ;
15345: LD_EXP 21
15349: PPUSH
15350: LD_STRING DOmarContam-JMM-2
15352: PPUSH
15353: CALL_OW 88
// RemoveSeeing ( GetX ( Omar ) , GetY ( Omar ) , 7 ) ;
15357: LD_EXP 58
15361: PPUSH
15362: CALL_OW 250
15366: PPUSH
15367: LD_EXP 58
15371: PPUSH
15372: CALL_OW 251
15376: PPUSH
15377: LD_INT 7
15379: PPUSH
15380: CALL_OW 331
// DialogueOff ;
15384: CALL_OW 7
// SetAttitude ( 5 , 7 , att_enemy , true ) ;
15388: LD_INT 5
15390: PPUSH
15391: LD_INT 7
15393: PPUSH
15394: LD_INT 2
15396: PPUSH
15397: LD_INT 1
15399: PPUSH
15400: CALL_OW 80
// repeat wait ( 0 0$3 ) ;
15404: LD_INT 105
15406: PPUSH
15407: CALL_OW 67
// ComMoveXY ( Omar , 203 , 120 ) ;
15411: LD_EXP 58
15415: PPUSH
15416: LD_INT 203
15418: PPUSH
15419: LD_INT 120
15421: PPUSH
15422: CALL_OW 111
// until IsAt ( Omar , 203 , 120 ) ;
15426: LD_EXP 58
15430: PPUSH
15431: LD_INT 203
15433: PPUSH
15434: LD_INT 120
15436: PPUSH
15437: CALL_OW 307
15441: IFFALSE 15404
// ComHold ( Omar ) ;
15443: LD_EXP 58
15447: PPUSH
15448: CALL_OW 140
// InGameOn ;
15452: CALL_OW 8
// CenterNowOnXY ( 203 , 120 ) ;
15456: LD_INT 203
15458: PPUSH
15459: LD_INT 120
15461: PPUSH
15462: CALL_OW 86
// PlaceSeeing ( 203 , 120 , 7 , - 30 ) ;
15466: LD_INT 203
15468: PPUSH
15469: LD_INT 120
15471: PPUSH
15472: LD_INT 7
15474: PPUSH
15475: LD_INT 30
15477: NEG
15478: PPUSH
15479: CALL_OW 330
// for i in [ [ 203 , 120 ] , [ 202 , 125 ] , [ 195 , 117 ] , [ 216 , 123 ] , [ 224 , 131 ] , [ 212 , 133 ] ] do
15483: LD_ADDR_VAR 0 1
15487: PUSH
15488: LD_INT 203
15490: PUSH
15491: LD_INT 120
15493: PUSH
15494: EMPTY
15495: LIST
15496: LIST
15497: PUSH
15498: LD_INT 202
15500: PUSH
15501: LD_INT 125
15503: PUSH
15504: EMPTY
15505: LIST
15506: LIST
15507: PUSH
15508: LD_INT 195
15510: PUSH
15511: LD_INT 117
15513: PUSH
15514: EMPTY
15515: LIST
15516: LIST
15517: PUSH
15518: LD_INT 216
15520: PUSH
15521: LD_INT 123
15523: PUSH
15524: EMPTY
15525: LIST
15526: LIST
15527: PUSH
15528: LD_INT 224
15530: PUSH
15531: LD_INT 131
15533: PUSH
15534: EMPTY
15535: LIST
15536: LIST
15537: PUSH
15538: LD_INT 212
15540: PUSH
15541: LD_INT 133
15543: PUSH
15544: EMPTY
15545: LIST
15546: LIST
15547: PUSH
15548: EMPTY
15549: LIST
15550: LIST
15551: LIST
15552: LIST
15553: LIST
15554: LIST
15555: PUSH
15556: FOR_IN
15557: IFFALSE 15593
// begin wait ( 0 0$0.5 ) ;
15559: LD_INT 18
15561: PPUSH
15562: CALL_OW 67
// ArtContamination ( i [ 1 ] , i [ 2 ] , 5 ) ;
15566: LD_VAR 0 1
15570: PUSH
15571: LD_INT 1
15573: ARRAY
15574: PPUSH
15575: LD_VAR 0 1
15579: PUSH
15580: LD_INT 2
15582: ARRAY
15583: PPUSH
15584: LD_INT 5
15586: PPUSH
15587: CALL_OW 495
// end ;
15591: GO 15556
15593: POP
15594: POP
// KillUnit ( Omar ) ;
15595: LD_EXP 58
15599: PPUSH
15600: CALL_OW 66
// wait ( 0 0$3 ) ;
15604: LD_INT 105
15606: PPUSH
15607: CALL_OW 67
// ForceSay ( JMM , D16b-JMM-1 ) ;
15611: LD_EXP 21
15615: PPUSH
15616: LD_STRING D16b-JMM-1
15618: PPUSH
15619: CALL_OW 91
// wait ( 0 0$2 ) ;
15623: LD_INT 70
15625: PPUSH
15626: CALL_OW 67
// InGameOff ;
15630: CALL_OW 9
// YouLost ( MothContaminate ) ;
15634: LD_STRING MothContaminate
15636: PPUSH
15637: CALL_OW 104
// end ;
15641: PPOPN 1
15643: END
// every 0 0$2 trigger not americanDestroyed and FilterAllUnits ( [ [ f_side , 1 ] , [ f_weapon , us_siberium_rocket ] ] ) do
15644: LD_EXP 4
15648: NOT
15649: PUSH
15650: LD_INT 22
15652: PUSH
15653: LD_INT 1
15655: PUSH
15656: EMPTY
15657: LIST
15658: LIST
15659: PUSH
15660: LD_INT 34
15662: PUSH
15663: LD_INT 8
15665: PUSH
15666: EMPTY
15667: LIST
15668: LIST
15669: PUSH
15670: EMPTY
15671: LIST
15672: LIST
15673: PPUSH
15674: CALL_OW 69
15678: AND
15679: IFFALSE 15798
15681: GO 15683
15683: DISABLE
// begin wait ( 0 0$10 ) ;
15684: LD_INT 350
15686: PPUSH
15687: CALL_OW 67
// if not IsOk ( Powell ) or not FilterAllUnits ( [ [ f_side , 1 ] , [ f_weapon , us_siberium_rocket ] ] ) then
15691: LD_EXP 57
15695: PPUSH
15696: CALL_OW 302
15700: NOT
15701: PUSH
15702: LD_INT 22
15704: PUSH
15705: LD_INT 1
15707: PUSH
15708: EMPTY
15709: LIST
15710: LIST
15711: PUSH
15712: LD_INT 34
15714: PUSH
15715: LD_INT 8
15717: PUSH
15718: EMPTY
15719: LIST
15720: LIST
15721: PUSH
15722: EMPTY
15723: LIST
15724: LIST
15725: PPUSH
15726: CALL_OW 69
15730: NOT
15731: OR
15732: IFFALSE 15736
// exit ;
15734: GO 15798
// DialogueOn ;
15736: CALL_OW 6
// SayRadio ( Powell , DWinAmericans-Pow-1 ) ;
15740: LD_EXP 57
15744: PPUSH
15745: LD_STRING DWinAmericans-Pow-1
15747: PPUSH
15748: CALL_OW 94
// if IsOk ( Burlak ) then
15752: LD_EXP 54
15756: PPUSH
15757: CALL_OW 302
15761: IFFALSE 15775
// Say ( Burlak , DWinAmericans-Bur-1 ) ;
15763: LD_EXP 54
15767: PPUSH
15768: LD_STRING DWinAmericans-Bur-1
15770: PPUSH
15771: CALL_OW 88
// Say ( JMM , DWinAmericans-JMM-1 ) ;
15775: LD_EXP 21
15779: PPUSH
15780: LD_STRING DWinAmericans-JMM-1
15782: PPUSH
15783: CALL_OW 88
// DialogueOff ;
15787: CALL_OW 7
// YouLost ( AmBomb ) ;
15791: LD_STRING AmBomb
15793: PPUSH
15794: CALL_OW 104
// end ;
15798: END
// every 0 0$2 trigger not russianDestroyed and FilterAllUnits ( [ [ f_side , 3 ] , [ f_weapon , ru_siberium_rocket ] ] ) do
15799: LD_EXP 2
15803: NOT
15804: PUSH
15805: LD_INT 22
15807: PUSH
15808: LD_INT 3
15810: PUSH
15811: EMPTY
15812: LIST
15813: LIST
15814: PUSH
15815: LD_INT 34
15817: PUSH
15818: LD_INT 48
15820: PUSH
15821: EMPTY
15822: LIST
15823: LIST
15824: PUSH
15825: EMPTY
15826: LIST
15827: LIST
15828: PPUSH
15829: CALL_OW 69
15833: AND
15834: IFFALSE 15953
15836: GO 15838
15838: DISABLE
// begin wait ( 0 0$10 ) ;
15839: LD_INT 350
15841: PPUSH
15842: CALL_OW 67
// if not IsOk ( Platonov ) or not FilterAllUnits ( [ [ f_side , 3 ] , [ f_weapon , ru_siberium_rocket ] ] ) then
15846: LD_EXP 62
15850: PPUSH
15851: CALL_OW 302
15855: NOT
15856: PUSH
15857: LD_INT 22
15859: PUSH
15860: LD_INT 3
15862: PUSH
15863: EMPTY
15864: LIST
15865: LIST
15866: PUSH
15867: LD_INT 34
15869: PUSH
15870: LD_INT 48
15872: PUSH
15873: EMPTY
15874: LIST
15875: LIST
15876: PUSH
15877: EMPTY
15878: LIST
15879: LIST
15880: PPUSH
15881: CALL_OW 69
15885: NOT
15886: OR
15887: IFFALSE 15891
// exit ;
15889: GO 15953
// DialogueOn ;
15891: CALL_OW 6
// SayRadio ( Platonov , DWinRussians-Pla-1 ) ;
15895: LD_EXP 62
15899: PPUSH
15900: LD_STRING DWinRussians-Pla-1
15902: PPUSH
15903: CALL_OW 94
// if IsOk ( Burlak ) then
15907: LD_EXP 54
15911: PPUSH
15912: CALL_OW 302
15916: IFFALSE 15930
// Say ( Burlak , DWinRussians-Bur-1 ) ;
15918: LD_EXP 54
15922: PPUSH
15923: LD_STRING DWinRussians-Bur-1
15925: PPUSH
15926: CALL_OW 88
// Say ( JMM , DWinRussians-JMM-1 ) ;
15930: LD_EXP 21
15934: PPUSH
15935: LD_STRING DWinRussians-JMM-1
15937: PPUSH
15938: CALL_OW 88
// DialogueOff ;
15942: CALL_OW 7
// YouLost ( RuBomb ) ;
15946: LD_STRING RuBomb
15948: PPUSH
15949: CALL_OW 104
// end ;
15953: END
// every 0 0$20 trigger FilterUnitsInArea ( powellBase , [ f_side , 7 ] ) and not americanDestroyed do
15954: LD_INT 7
15956: PPUSH
15957: LD_INT 22
15959: PUSH
15960: LD_INT 7
15962: PUSH
15963: EMPTY
15964: LIST
15965: LIST
15966: PPUSH
15967: CALL_OW 70
15971: PUSH
15972: LD_EXP 4
15976: NOT
15977: AND
15978: IFFALSE 16007
15980: GO 15982
15982: DISABLE
// begin SayRadio ( Powell , DSurrenderAmericans-Pow-1 ) ;
15983: LD_EXP 57
15987: PPUSH
15988: LD_STRING DSurrenderAmericans-Pow-1
15990: PPUSH
15991: CALL_OW 94
// Say ( JMM , DSurrenderAmericans-JMM-1 ) ;
15995: LD_EXP 21
15999: PPUSH
16000: LD_STRING DSurrenderAmericans-JMM-1
16002: PPUSH
16003: CALL_OW 88
// end ;
16007: END
// every 0 0$20 trigger FilterUnitsInArea ( russianBaseArea , [ f_side , 7 ] ) and not russianDestroyed and Burlak do
16008: LD_INT 2
16010: PPUSH
16011: LD_INT 22
16013: PUSH
16014: LD_INT 7
16016: PUSH
16017: EMPTY
16018: LIST
16019: LIST
16020: PPUSH
16021: CALL_OW 70
16025: PUSH
16026: LD_EXP 2
16030: NOT
16031: AND
16032: PUSH
16033: LD_EXP 54
16037: AND
16038: IFFALSE 16067
16040: GO 16042
16042: DISABLE
// begin SayRadio ( Platonov , DSurrenderRussians-Pla-1 ) ;
16043: LD_EXP 62
16047: PPUSH
16048: LD_STRING DSurrenderRussians-Pla-1
16050: PPUSH
16051: CALL_OW 94
// Say ( Burlak , DSurrenderRussians-Bur-1 ) ;
16055: LD_EXP 54
16059: PPUSH
16060: LD_STRING DSurrenderRussians-Bur-1
16062: PPUSH
16063: CALL_OW 88
// end ;
16067: END
// every 0 0$2 + 0 0$5 trigger americanDestroyed do var i , tmp , speaker ;
16068: LD_EXP 4
16072: IFFALSE 16511
16074: GO 16076
16076: DISABLE
16077: LD_INT 0
16079: PPUSH
16080: PPUSH
16081: PPUSH
// begin MC_Kill ( 4 ) ;
16082: LD_INT 4
16084: PPUSH
16085: CALL 23027 0 1
// SetAttitude ( 1 , 7 , att_friend , true ) ;
16089: LD_INT 1
16091: PPUSH
16092: LD_INT 7
16094: PPUSH
16095: LD_INT 1
16097: PPUSH
16098: LD_INT 1
16100: PPUSH
16101: CALL_OW 80
// speaker := FilterAllUnits ( [ [ f_side , 1 ] , [ f_ok ] , [ f_sex , sex_male ] , [ f_nation , 1 ] ] ) diff [ Powell , Gladstone , Cyrus , Bobby , Gary , Houten ] ;
16105: LD_ADDR_VAR 0 3
16109: PUSH
16110: LD_INT 22
16112: PUSH
16113: LD_INT 1
16115: PUSH
16116: EMPTY
16117: LIST
16118: LIST
16119: PUSH
16120: LD_INT 50
16122: PUSH
16123: EMPTY
16124: LIST
16125: PUSH
16126: LD_INT 26
16128: PUSH
16129: LD_INT 1
16131: PUSH
16132: EMPTY
16133: LIST
16134: LIST
16135: PUSH
16136: LD_INT 23
16138: PUSH
16139: LD_INT 1
16141: PUSH
16142: EMPTY
16143: LIST
16144: LIST
16145: PUSH
16146: EMPTY
16147: LIST
16148: LIST
16149: LIST
16150: LIST
16151: PPUSH
16152: CALL_OW 69
16156: PUSH
16157: LD_EXP 57
16161: PUSH
16162: LD_EXP 29
16166: PUSH
16167: LD_EXP 26
16171: PUSH
16172: LD_EXP 25
16176: PUSH
16177: LD_EXP 32
16181: PUSH
16182: LD_EXP 30
16186: PUSH
16187: EMPTY
16188: LIST
16189: LIST
16190: LIST
16191: LIST
16192: LIST
16193: LIST
16194: DIFF
16195: ST_TO_ADDR
// if not speaker then
16196: LD_VAR 0 3
16200: NOT
16201: IFFALSE 16241
// begin uc_side := 1 ;
16203: LD_ADDR_OWVAR 20
16207: PUSH
16208: LD_INT 1
16210: ST_TO_ADDR
// uc_nation := 1 ;
16211: LD_ADDR_OWVAR 21
16215: PUSH
16216: LD_INT 1
16218: ST_TO_ADDR
// PrepareSoldier ( sex_male , 0 ) ;
16219: LD_INT 1
16221: PPUSH
16222: LD_INT 0
16224: PPUSH
16225: CALL_OW 381
// speaker := CreateHuman ;
16229: LD_ADDR_VAR 0 3
16233: PUSH
16234: CALL_OW 44
16238: ST_TO_ADDR
// end else
16239: GO 16255
// speaker := speaker [ 1 ] ;
16241: LD_ADDR_VAR 0 3
16245: PUSH
16246: LD_VAR 0 3
16250: PUSH
16251: LD_INT 1
16253: ARRAY
16254: ST_TO_ADDR
// DialogueOn ;
16255: CALL_OW 6
// SayRadio ( speaker , DSurrenderAmericans-Sol1-1a ) ;
16259: LD_VAR 0 3
16263: PPUSH
16264: LD_STRING DSurrenderAmericans-Sol1-1a
16266: PPUSH
16267: CALL_OW 94
// DialogueOff ;
16271: CALL_OW 7
// americanCapitulated := true ;
16275: LD_ADDR_EXP 6
16279: PUSH
16280: LD_INT 1
16282: ST_TO_ADDR
// tmp := FilterAllUnits ( [ [ f_side , 1 ] , [ f_type , unit_human ] ] ) ^ FilterAllUnits ( [ [ f_side , 1 ] , [ f_type , unit_vehicle ] , [ control_manual ] ] ) ;
16283: LD_ADDR_VAR 0 2
16287: PUSH
16288: LD_INT 22
16290: PUSH
16291: LD_INT 1
16293: PUSH
16294: EMPTY
16295: LIST
16296: LIST
16297: PUSH
16298: LD_INT 21
16300: PUSH
16301: LD_INT 1
16303: PUSH
16304: EMPTY
16305: LIST
16306: LIST
16307: PUSH
16308: EMPTY
16309: LIST
16310: LIST
16311: PPUSH
16312: CALL_OW 69
16316: PUSH
16317: LD_INT 22
16319: PUSH
16320: LD_INT 1
16322: PUSH
16323: EMPTY
16324: LIST
16325: LIST
16326: PUSH
16327: LD_INT 21
16329: PUSH
16330: LD_INT 2
16332: PUSH
16333: EMPTY
16334: LIST
16335: LIST
16336: PUSH
16337: LD_INT 1
16339: PUSH
16340: EMPTY
16341: LIST
16342: PUSH
16343: EMPTY
16344: LIST
16345: LIST
16346: LIST
16347: PPUSH
16348: CALL_OW 69
16352: ADD
16353: ST_TO_ADDR
// if tmp then
16354: LD_VAR 0 2
16358: IFFALSE 16511
// repeat wait ( 0 0$1 ) ;
16360: LD_INT 35
16362: PPUSH
16363: CALL_OW 67
// for i in tmp do
16367: LD_ADDR_VAR 0 1
16371: PUSH
16372: LD_VAR 0 2
16376: PUSH
16377: FOR_IN
16378: IFFALSE 16460
// begin if IsInUnit ( i ) and GetType ( IsInUnit ( i ) ) = unit_building then
16380: LD_VAR 0 1
16384: PPUSH
16385: CALL_OW 310
16389: PUSH
16390: LD_VAR 0 1
16394: PPUSH
16395: CALL_OW 310
16399: PPUSH
16400: CALL_OW 247
16404: PUSH
16405: LD_INT 3
16407: EQUAL
16408: AND
16409: IFFALSE 16420
// ComExitBuilding ( i ) ;
16411: LD_VAR 0 1
16415: PPUSH
16416: CALL_OW 122
// AddComMoveXY ( i , 122 , 242 ) ;
16420: LD_VAR 0 1
16424: PPUSH
16425: LD_INT 122
16427: PPUSH
16428: LD_INT 242
16430: PPUSH
16431: CALL_OW 171
// if IsInArea ( i , americanEscape ) then
16435: LD_VAR 0 1
16439: PPUSH
16440: LD_INT 35
16442: PPUSH
16443: CALL_OW 308
16447: IFFALSE 16458
// RemoveUnit ( i ) ;
16449: LD_VAR 0 1
16453: PPUSH
16454: CALL_OW 64
// end ;
16458: GO 16377
16460: POP
16461: POP
// until not FilterAllUnits ( [ [ f_side , 1 ] , [ f_or , [ f_type , unit_human ] , [ f_control , control_manual ] ] ] ) ;
16462: LD_INT 22
16464: PUSH
16465: LD_INT 1
16467: PUSH
16468: EMPTY
16469: LIST
16470: LIST
16471: PUSH
16472: LD_INT 2
16474: PUSH
16475: LD_INT 21
16477: PUSH
16478: LD_INT 1
16480: PUSH
16481: EMPTY
16482: LIST
16483: LIST
16484: PUSH
16485: LD_INT 33
16487: PUSH
16488: LD_INT 1
16490: PUSH
16491: EMPTY
16492: LIST
16493: LIST
16494: PUSH
16495: EMPTY
16496: LIST
16497: LIST
16498: LIST
16499: PUSH
16500: EMPTY
16501: LIST
16502: LIST
16503: PPUSH
16504: CALL_OW 69
16508: NOT
16509: IFFALSE 16360
// end ;
16511: PPOPN 3
16513: END
// every 0 0$2 + 0 0$5 trigger russianDestroyed do var i , tmp , speaker ;
16514: LD_EXP 2
16518: IFFALSE 16967
16520: GO 16522
16522: DISABLE
16523: LD_INT 0
16525: PPUSH
16526: PPUSH
16527: PPUSH
// begin repeat wait ( 0 0$1 ) ;
16528: LD_INT 35
16530: PPUSH
16531: CALL_OW 67
// until IsDead ( Yakotich ) ;
16535: LD_EXP 63
16539: PPUSH
16540: CALL_OW 301
16544: IFFALSE 16528
// MC_Kill ( 2 ) ;
16546: LD_INT 2
16548: PPUSH
16549: CALL 23027 0 1
// SetAttitude ( 3 , 7 , att_friend , true ) ;
16553: LD_INT 3
16555: PPUSH
16556: LD_INT 7
16558: PPUSH
16559: LD_INT 1
16561: PPUSH
16562: LD_INT 1
16564: PPUSH
16565: CALL_OW 80
// speaker := FilterAllUnits ( [ [ f_side , 3 ] , [ f_ok ] , [ f_sex , sex_male ] , [ f_nation , 3 ] ] ) diff Platonov ;
16569: LD_ADDR_VAR 0 3
16573: PUSH
16574: LD_INT 22
16576: PUSH
16577: LD_INT 3
16579: PUSH
16580: EMPTY
16581: LIST
16582: LIST
16583: PUSH
16584: LD_INT 50
16586: PUSH
16587: EMPTY
16588: LIST
16589: PUSH
16590: LD_INT 26
16592: PUSH
16593: LD_INT 1
16595: PUSH
16596: EMPTY
16597: LIST
16598: LIST
16599: PUSH
16600: LD_INT 23
16602: PUSH
16603: LD_INT 3
16605: PUSH
16606: EMPTY
16607: LIST
16608: LIST
16609: PUSH
16610: EMPTY
16611: LIST
16612: LIST
16613: LIST
16614: LIST
16615: PPUSH
16616: CALL_OW 69
16620: PUSH
16621: LD_EXP 62
16625: DIFF
16626: ST_TO_ADDR
// if not speaker then
16627: LD_VAR 0 3
16631: NOT
16632: IFFALSE 16672
// begin uc_side := 3 ;
16634: LD_ADDR_OWVAR 20
16638: PUSH
16639: LD_INT 3
16641: ST_TO_ADDR
// uc_nation := 3 ;
16642: LD_ADDR_OWVAR 21
16646: PUSH
16647: LD_INT 3
16649: ST_TO_ADDR
// PrepareSoldier ( sex_male , 0 ) ;
16650: LD_INT 1
16652: PPUSH
16653: LD_INT 0
16655: PPUSH
16656: CALL_OW 381
// speaker := CreateHuman ;
16660: LD_ADDR_VAR 0 3
16664: PUSH
16665: CALL_OW 44
16669: ST_TO_ADDR
// end else
16670: GO 16686
// speaker := speaker [ 1 ] ;
16672: LD_ADDR_VAR 0 3
16676: PUSH
16677: LD_VAR 0 3
16681: PUSH
16682: LD_INT 1
16684: ARRAY
16685: ST_TO_ADDR
// DialogueOn ;
16686: CALL_OW 6
// if IsOK ( Burlak ) then
16690: LD_EXP 54
16694: PPUSH
16695: CALL_OW 302
16699: IFFALSE 16715
// SayRadio ( speaker , DSurrenderRussians-RSol1-1 ) else
16701: LD_VAR 0 3
16705: PPUSH
16706: LD_STRING DSurrenderRussians-RSol1-1
16708: PPUSH
16709: CALL_OW 94
16713: GO 16727
// SayRadio ( speaker , DSurrenderRussians-RSol1-1a ) ;
16715: LD_VAR 0 3
16719: PPUSH
16720: LD_STRING DSurrenderRussians-RSol1-1a
16722: PPUSH
16723: CALL_OW 94
// DialogueOff ;
16727: CALL_OW 7
// russianCapitulated := true ;
16731: LD_ADDR_EXP 7
16735: PUSH
16736: LD_INT 1
16738: ST_TO_ADDR
// tmp := FilterAllUnits ( [ [ f_side , 3 ] , [ f_type , unit_human ] ] ) ^ FilterAllUnits ( [ [ f_side , 3 ] , [ f_type , unit_vehicle ] , [ control_manual ] ] ) ;
16739: LD_ADDR_VAR 0 2
16743: PUSH
16744: LD_INT 22
16746: PUSH
16747: LD_INT 3
16749: PUSH
16750: EMPTY
16751: LIST
16752: LIST
16753: PUSH
16754: LD_INT 21
16756: PUSH
16757: LD_INT 1
16759: PUSH
16760: EMPTY
16761: LIST
16762: LIST
16763: PUSH
16764: EMPTY
16765: LIST
16766: LIST
16767: PPUSH
16768: CALL_OW 69
16772: PUSH
16773: LD_INT 22
16775: PUSH
16776: LD_INT 3
16778: PUSH
16779: EMPTY
16780: LIST
16781: LIST
16782: PUSH
16783: LD_INT 21
16785: PUSH
16786: LD_INT 2
16788: PUSH
16789: EMPTY
16790: LIST
16791: LIST
16792: PUSH
16793: LD_INT 1
16795: PUSH
16796: EMPTY
16797: LIST
16798: PUSH
16799: EMPTY
16800: LIST
16801: LIST
16802: LIST
16803: PPUSH
16804: CALL_OW 69
16808: ADD
16809: ST_TO_ADDR
// if tmp then
16810: LD_VAR 0 2
16814: IFFALSE 16967
// repeat wait ( 0 0$1 ) ;
16816: LD_INT 35
16818: PPUSH
16819: CALL_OW 67
// for i in tmp do
16823: LD_ADDR_VAR 0 1
16827: PUSH
16828: LD_VAR 0 2
16832: PUSH
16833: FOR_IN
16834: IFFALSE 16916
// begin if IsInUnit ( i ) and GetType ( IsInUnit ( i ) ) = unit_building then
16836: LD_VAR 0 1
16840: PPUSH
16841: CALL_OW 310
16845: PUSH
16846: LD_VAR 0 1
16850: PPUSH
16851: CALL_OW 310
16855: PPUSH
16856: CALL_OW 247
16860: PUSH
16861: LD_INT 3
16863: EQUAL
16864: AND
16865: IFFALSE 16876
// ComExitBuilding ( i ) ;
16867: LD_VAR 0 1
16871: PPUSH
16872: CALL_OW 122
// AddComMoveXY ( i , 154 , 1 ) ;
16876: LD_VAR 0 1
16880: PPUSH
16881: LD_INT 154
16883: PPUSH
16884: LD_INT 1
16886: PPUSH
16887: CALL_OW 171
// if IsInArea ( i , russianEscape ) then
16891: LD_VAR 0 1
16895: PPUSH
16896: LD_INT 36
16898: PPUSH
16899: CALL_OW 308
16903: IFFALSE 16914
// RemoveUnit ( i ) ;
16905: LD_VAR 0 1
16909: PPUSH
16910: CALL_OW 64
// end ;
16914: GO 16833
16916: POP
16917: POP
// until not FilterAllUnits ( [ [ f_side , 3 ] , [ f_or , [ f_type , unit_human ] , [ f_control , control_manual ] ] ] ) ;
16918: LD_INT 22
16920: PUSH
16921: LD_INT 3
16923: PUSH
16924: EMPTY
16925: LIST
16926: LIST
16927: PUSH
16928: LD_INT 2
16930: PUSH
16931: LD_INT 21
16933: PUSH
16934: LD_INT 1
16936: PUSH
16937: EMPTY
16938: LIST
16939: LIST
16940: PUSH
16941: LD_INT 33
16943: PUSH
16944: LD_INT 1
16946: PUSH
16947: EMPTY
16948: LIST
16949: LIST
16950: PUSH
16951: EMPTY
16952: LIST
16953: LIST
16954: LIST
16955: PUSH
16956: EMPTY
16957: LIST
16958: LIST
16959: PPUSH
16960: CALL_OW 69
16964: NOT
16965: IFFALSE 16816
// end ;
16967: PPOPN 3
16969: END
// every 0 0$3 trigger FilterAllUnits ( [ [ f_side , 8 ] , [ f_type , unit_human ] , [ f_nation , 2 ] ] ) < 18 or IsDead ( Kozlov ) or GetSide ( ar_depot1 ) = 7 do
16970: LD_INT 22
16972: PUSH
16973: LD_INT 8
16975: PUSH
16976: EMPTY
16977: LIST
16978: LIST
16979: PUSH
16980: LD_INT 21
16982: PUSH
16983: LD_INT 1
16985: PUSH
16986: EMPTY
16987: LIST
16988: LIST
16989: PUSH
16990: LD_INT 23
16992: PUSH
16993: LD_INT 2
16995: PUSH
16996: EMPTY
16997: LIST
16998: LIST
16999: PUSH
17000: EMPTY
17001: LIST
17002: LIST
17003: LIST
17004: PPUSH
17005: CALL_OW 69
17009: PUSH
17010: LD_INT 18
17012: LESS
17013: PUSH
17014: LD_EXP 60
17018: PPUSH
17019: CALL_OW 301
17023: OR
17024: PUSH
17025: LD_INT 324
17027: PPUSH
17028: CALL_OW 255
17032: PUSH
17033: LD_INT 7
17035: EQUAL
17036: OR
17037: IFFALSE 17050
17039: GO 17041
17041: DISABLE
// legionDestroyed := true ;
17042: LD_ADDR_EXP 3
17046: PUSH
17047: LD_INT 1
17049: ST_TO_ADDR
17050: END
// every 0 0$3 trigger FilterAllUnits ( [ [ f_side , 2 ] , [ f_type , unit_human ] , [ f_nation , 2 ] ] ) < 9 or IsDead ( ar_depot ) or GetSide ( ar_depot ) = 7 do
17051: LD_INT 22
17053: PUSH
17054: LD_INT 2
17056: PUSH
17057: EMPTY
17058: LIST
17059: LIST
17060: PUSH
17061: LD_INT 21
17063: PUSH
17064: LD_INT 1
17066: PUSH
17067: EMPTY
17068: LIST
17069: LIST
17070: PUSH
17071: LD_INT 23
17073: PUSH
17074: LD_INT 2
17076: PUSH
17077: EMPTY
17078: LIST
17079: LIST
17080: PUSH
17081: EMPTY
17082: LIST
17083: LIST
17084: LIST
17085: PPUSH
17086: CALL_OW 69
17090: PUSH
17091: LD_INT 9
17093: LESS
17094: PUSH
17095: LD_INT 503
17097: PPUSH
17098: CALL_OW 301
17102: OR
17103: PUSH
17104: LD_INT 503
17106: PPUSH
17107: CALL_OW 255
17111: PUSH
17112: LD_INT 7
17114: EQUAL
17115: OR
17116: IFFALSE 17129
17118: GO 17120
17120: DISABLE
// arabianDestroyed := true ;
17121: LD_ADDR_EXP 5
17125: PUSH
17126: LD_INT 1
17128: ST_TO_ADDR
17129: END
// every 0 0$1 trigger arabianDestroyed do var i , tmp ;
17130: LD_EXP 5
17134: IFFALSE 17378
17136: GO 17138
17138: DISABLE
17139: LD_INT 0
17141: PPUSH
17142: PPUSH
// begin MC_Kill ( 1 ) ;
17143: LD_INT 1
17145: PPUSH
17146: CALL 23027 0 1
// tmp := FilterAllUnits ( [ [ f_side , 2 ] , [ f_type , unit_human ] ] ) ^ FilterAllUnits ( [ [ f_side , 2 ] , [ f_type , unit_vehicle ] , [ control_manual ] ] ) ;
17150: LD_ADDR_VAR 0 2
17154: PUSH
17155: LD_INT 22
17157: PUSH
17158: LD_INT 2
17160: PUSH
17161: EMPTY
17162: LIST
17163: LIST
17164: PUSH
17165: LD_INT 21
17167: PUSH
17168: LD_INT 1
17170: PUSH
17171: EMPTY
17172: LIST
17173: LIST
17174: PUSH
17175: EMPTY
17176: LIST
17177: LIST
17178: PPUSH
17179: CALL_OW 69
17183: PUSH
17184: LD_INT 22
17186: PUSH
17187: LD_INT 2
17189: PUSH
17190: EMPTY
17191: LIST
17192: LIST
17193: PUSH
17194: LD_INT 21
17196: PUSH
17197: LD_INT 2
17199: PUSH
17200: EMPTY
17201: LIST
17202: LIST
17203: PUSH
17204: LD_INT 1
17206: PUSH
17207: EMPTY
17208: LIST
17209: PUSH
17210: EMPTY
17211: LIST
17212: LIST
17213: LIST
17214: PPUSH
17215: CALL_OW 69
17219: ADD
17220: ST_TO_ADDR
// if tmp then
17221: LD_VAR 0 2
17225: IFFALSE 17378
// repeat wait ( 0 0$1 ) ;
17227: LD_INT 35
17229: PPUSH
17230: CALL_OW 67
// for i in tmp do
17234: LD_ADDR_VAR 0 1
17238: PUSH
17239: LD_VAR 0 2
17243: PUSH
17244: FOR_IN
17245: IFFALSE 17327
// begin if IsInUnit ( i ) and GetType ( IsInUnit ( i ) ) = unit_building then
17247: LD_VAR 0 1
17251: PPUSH
17252: CALL_OW 310
17256: PUSH
17257: LD_VAR 0 1
17261: PPUSH
17262: CALL_OW 310
17266: PPUSH
17267: CALL_OW 247
17271: PUSH
17272: LD_INT 3
17274: EQUAL
17275: AND
17276: IFFALSE 17287
// ComExitBuilding ( i ) ;
17278: LD_VAR 0 1
17282: PPUSH
17283: CALL_OW 122
// AddComMoveXY ( i , 254 , 268 ) ;
17287: LD_VAR 0 1
17291: PPUSH
17292: LD_INT 254
17294: PPUSH
17295: LD_INT 268
17297: PPUSH
17298: CALL_OW 171
// if IsInArea ( i , arabEscape ) then
17302: LD_VAR 0 1
17306: PPUSH
17307: LD_INT 34
17309: PPUSH
17310: CALL_OW 308
17314: IFFALSE 17325
// RemoveUnit ( i ) ;
17316: LD_VAR 0 1
17320: PPUSH
17321: CALL_OW 64
// end ;
17325: GO 17244
17327: POP
17328: POP
// until not FilterAllUnits ( [ [ f_side , 2 ] , [ f_or , [ f_type , unit_human ] , [ f_control , control_manual ] ] ] ) ;
17329: LD_INT 22
17331: PUSH
17332: LD_INT 2
17334: PUSH
17335: EMPTY
17336: LIST
17337: LIST
17338: PUSH
17339: LD_INT 2
17341: PUSH
17342: LD_INT 21
17344: PUSH
17345: LD_INT 1
17347: PUSH
17348: EMPTY
17349: LIST
17350: LIST
17351: PUSH
17352: LD_INT 33
17354: PUSH
17355: LD_INT 1
17357: PUSH
17358: EMPTY
17359: LIST
17360: LIST
17361: PUSH
17362: EMPTY
17363: LIST
17364: LIST
17365: LIST
17366: PUSH
17367: EMPTY
17368: LIST
17369: LIST
17370: PPUSH
17371: CALL_OW 69
17375: NOT
17376: IFFALSE 17227
// end ;
17378: PPOPN 2
17380: END
// every 0 0$1 trigger legionDestroyed do var i , tmp ;
17381: LD_EXP 3
17385: IFFALSE 17737
17387: GO 17389
17389: DISABLE
17390: LD_INT 0
17392: PPUSH
17393: PPUSH
// begin MC_Kill ( 3 ) ;
17394: LD_INT 3
17396: PPUSH
17397: CALL 23027 0 1
// SetAttitude ( 8 , 7 , att_friend , true ) ;
17401: LD_INT 8
17403: PPUSH
17404: LD_INT 7
17406: PPUSH
17407: LD_INT 1
17409: PPUSH
17410: LD_INT 1
17412: PPUSH
17413: CALL_OW 80
// DialogueOn ;
17417: CALL_OW 6
// SayRadio ( Schulz , D15-Szulc-1 ) ;
17421: LD_EXP 59
17425: PPUSH
17426: LD_STRING D15-Szulc-1
17428: PPUSH
17429: CALL_OW 94
// DialogueOff ;
17433: CALL_OW 7
// legionCapitulated := true ;
17437: LD_ADDR_EXP 8
17441: PUSH
17442: LD_INT 1
17444: ST_TO_ADDR
// for i in FilterAllUnits ( [ [ f_side , 8 ] , [ f_type , unit_building ] , [ f_nation , 3 ] ] ) do
17445: LD_ADDR_VAR 0 1
17449: PUSH
17450: LD_INT 22
17452: PUSH
17453: LD_INT 8
17455: PUSH
17456: EMPTY
17457: LIST
17458: LIST
17459: PUSH
17460: LD_INT 21
17462: PUSH
17463: LD_INT 3
17465: PUSH
17466: EMPTY
17467: LIST
17468: LIST
17469: PUSH
17470: LD_INT 23
17472: PUSH
17473: LD_INT 3
17475: PUSH
17476: EMPTY
17477: LIST
17478: LIST
17479: PUSH
17480: EMPTY
17481: LIST
17482: LIST
17483: LIST
17484: PPUSH
17485: CALL_OW 69
17489: PUSH
17490: FOR_IN
17491: IFFALSE 17507
// SetLives ( i , 3 ) ;
17493: LD_VAR 0 1
17497: PPUSH
17498: LD_INT 3
17500: PPUSH
17501: CALL_OW 234
17505: GO 17490
17507: POP
17508: POP
// tmp := FilterAllUnits ( [ [ f_side , 8 ] , [ f_type , unit_human ] ] ) ^ FilterAllUnits ( [ [ f_side , 8 ] , [ f_type , unit_vehicle ] , [ control_manual ] ] ) ;
17509: LD_ADDR_VAR 0 2
17513: PUSH
17514: LD_INT 22
17516: PUSH
17517: LD_INT 8
17519: PUSH
17520: EMPTY
17521: LIST
17522: LIST
17523: PUSH
17524: LD_INT 21
17526: PUSH
17527: LD_INT 1
17529: PUSH
17530: EMPTY
17531: LIST
17532: LIST
17533: PUSH
17534: EMPTY
17535: LIST
17536: LIST
17537: PPUSH
17538: CALL_OW 69
17542: PUSH
17543: LD_INT 22
17545: PUSH
17546: LD_INT 8
17548: PUSH
17549: EMPTY
17550: LIST
17551: LIST
17552: PUSH
17553: LD_INT 21
17555: PUSH
17556: LD_INT 2
17558: PUSH
17559: EMPTY
17560: LIST
17561: LIST
17562: PUSH
17563: LD_INT 1
17565: PUSH
17566: EMPTY
17567: LIST
17568: PUSH
17569: EMPTY
17570: LIST
17571: LIST
17572: LIST
17573: PPUSH
17574: CALL_OW 69
17578: ADD
17579: ST_TO_ADDR
// if tmp then
17580: LD_VAR 0 2
17584: IFFALSE 17737
// repeat wait ( 0 0$1 ) ;
17586: LD_INT 35
17588: PPUSH
17589: CALL_OW 67
// for i in tmp do
17593: LD_ADDR_VAR 0 1
17597: PUSH
17598: LD_VAR 0 2
17602: PUSH
17603: FOR_IN
17604: IFFALSE 17686
// begin if IsInUnit ( i ) and GetType ( IsInUnit ( i ) ) = unit_building then
17606: LD_VAR 0 1
17610: PPUSH
17611: CALL_OW 310
17615: PUSH
17616: LD_VAR 0 1
17620: PPUSH
17621: CALL_OW 310
17625: PPUSH
17626: CALL_OW 247
17630: PUSH
17631: LD_INT 3
17633: EQUAL
17634: AND
17635: IFFALSE 17646
// ComExitBuilding ( i ) ;
17637: LD_VAR 0 1
17641: PPUSH
17642: CALL_OW 122
// AddComMoveXY ( i , 10 , 1 ) ;
17646: LD_VAR 0 1
17650: PPUSH
17651: LD_INT 10
17653: PPUSH
17654: LD_INT 1
17656: PPUSH
17657: CALL_OW 171
// if IsInArea ( i , legionEscape ) then
17661: LD_VAR 0 1
17665: PPUSH
17666: LD_INT 32
17668: PPUSH
17669: CALL_OW 308
17673: IFFALSE 17684
// RemoveUnit ( i ) ;
17675: LD_VAR 0 1
17679: PPUSH
17680: CALL_OW 64
// end ;
17684: GO 17603
17686: POP
17687: POP
// until not FilterAllUnits ( [ [ f_side , 8 ] , [ f_or , [ f_type , unit_human ] , [ f_control , control_manual ] ] ] ) ;
17688: LD_INT 22
17690: PUSH
17691: LD_INT 8
17693: PUSH
17694: EMPTY
17695: LIST
17696: LIST
17697: PUSH
17698: LD_INT 2
17700: PUSH
17701: LD_INT 21
17703: PUSH
17704: LD_INT 1
17706: PUSH
17707: EMPTY
17708: LIST
17709: LIST
17710: PUSH
17711: LD_INT 33
17713: PUSH
17714: LD_INT 1
17716: PUSH
17717: EMPTY
17718: LIST
17719: LIST
17720: PUSH
17721: EMPTY
17722: LIST
17723: LIST
17724: LIST
17725: PUSH
17726: EMPTY
17727: LIST
17728: LIST
17729: PPUSH
17730: CALL_OW 69
17734: NOT
17735: IFFALSE 17586
// end ;
17737: PPOPN 2
17739: END
// every 0 0$10 trigger not arabianDestroyed and tick >= 30 30$00 and Difficulty < 3 do
17740: LD_EXP 5
17744: NOT
17745: PUSH
17746: LD_OWVAR 1
17750: PUSH
17751: LD_INT 63000
17753: GREATEREQUAL
17754: AND
17755: PUSH
17756: LD_OWVAR 67
17760: PUSH
17761: LD_INT 3
17763: LESS
17764: AND
17765: IFFALSE 17774
17767: GO 17769
17769: DISABLE
// AllianceSupport ;
17770: CALL 4711 0 0
17774: END
// every 0 0$5 trigger americanDestroyed and russianDestroyed and legionDestroyed and arabianDestroyed and americanCapitulated and russianCapitulated and legionCapitulated and ( GetSide ( Omar ) <> 5 or omarKilled or not IsPlaced ( Omar ) ) do var med1 , med2 ;
17775: LD_EXP 4
17779: PUSH
17780: LD_EXP 2
17784: AND
17785: PUSH
17786: LD_EXP 3
17790: AND
17791: PUSH
17792: LD_EXP 5
17796: AND
17797: PUSH
17798: LD_EXP 6
17802: AND
17803: PUSH
17804: LD_EXP 7
17808: AND
17809: PUSH
17810: LD_EXP 8
17814: AND
17815: PUSH
17816: LD_EXP 58
17820: PPUSH
17821: CALL_OW 255
17825: PUSH
17826: LD_INT 5
17828: NONEQUAL
17829: PUSH
17830: LD_EXP 20
17834: OR
17835: PUSH
17836: LD_EXP 58
17840: PPUSH
17841: CALL_OW 305
17845: NOT
17846: OR
17847: AND
17848: IFFALSE 19433
17850: GO 17852
17852: DISABLE
17853: LD_INT 0
17855: PPUSH
17856: PPUSH
// begin wait ( 0 0$5 ) ;
17857: LD_INT 175
17859: PPUSH
17860: CALL_OW 67
// if Count ( FilterAllUnits ( [ [ f_side , 7 ] , [ f_type , unit_human ] , [ f_nation , 1 ] , [ f_ok ] ] ) ) < 3 then
17864: LD_INT 22
17866: PUSH
17867: LD_INT 7
17869: PUSH
17870: EMPTY
17871: LIST
17872: LIST
17873: PUSH
17874: LD_INT 21
17876: PUSH
17877: LD_INT 1
17879: PUSH
17880: EMPTY
17881: LIST
17882: LIST
17883: PUSH
17884: LD_INT 23
17886: PUSH
17887: LD_INT 1
17889: PUSH
17890: EMPTY
17891: LIST
17892: LIST
17893: PUSH
17894: LD_INT 50
17896: PUSH
17897: EMPTY
17898: LIST
17899: PUSH
17900: EMPTY
17901: LIST
17902: LIST
17903: LIST
17904: LIST
17905: PPUSH
17906: CALL_OW 69
17910: PPUSH
17911: CALL 55580 0 1
17915: PUSH
17916: LD_INT 3
17918: LESS
17919: IFFALSE 17930
// begin YouLost ( LostVictory ) ;
17921: LD_STRING LostVictory
17923: PPUSH
17924: CALL_OW 104
// exit ;
17928: GO 19433
// end ; music_class := 5 ;
17930: LD_ADDR_OWVAR 72
17934: PUSH
17935: LD_INT 5
17937: ST_TO_ADDR
// music_nat := 5 ;
17938: LD_ADDR_OWVAR 71
17942: PUSH
17943: LD_INT 5
17945: ST_TO_ADDR
// if vehicleLostCounter < 3 then
17946: LD_EXP 15
17950: PUSH
17951: LD_INT 3
17953: LESS
17954: IFFALSE 17963
// SetAchievement ( ACH_ECONOMY ) ;
17956: LD_STRING ACH_ECONOMY
17958: PPUSH
17959: CALL_OW 543
// if tick < 60 60$00 then
17963: LD_OWVAR 1
17967: PUSH
17968: LD_INT 126000
17970: LESS
17971: IFFALSE 17987
// begin wait ( 3 ) ;
17973: LD_INT 3
17975: PPUSH
17976: CALL_OW 67
// SetAchievement ( ACH_ASPEED_19 ) ;
17980: LD_STRING ACH_ASPEED_19
17982: PPUSH
17983: CALL_OW 543
// end ; CenterNowOnUnits ( JMM ) ;
17987: LD_EXP 21
17991: PPUSH
17992: CALL_OW 87
// InGameOn ;
17996: CALL_OW 8
// DialogueOn ;
18000: CALL_OW 6
// Say ( JMM , DEnd-JMM-JMM-1 ) ;
18004: LD_EXP 21
18008: PPUSH
18009: LD_STRING DEnd-JMM-JMM-1
18011: PPUSH
18012: CALL_OW 88
// if Joan then
18016: LD_EXP 36
18020: IFFALSE 18036
// Say ( Joan , DEnd-JMM-Joan-1 ) else
18022: LD_EXP 36
18026: PPUSH
18027: LD_STRING DEnd-JMM-Joan-1
18029: PPUSH
18030: CALL_OW 88
18034: GO 18080
// if Lisa and GetSide ( Lisa ) = 7 and IsPlaced ( Lisa ) then
18036: LD_EXP 23
18040: PUSH
18041: LD_EXP 23
18045: PPUSH
18046: CALL_OW 255
18050: PUSH
18051: LD_INT 7
18053: EQUAL
18054: AND
18055: PUSH
18056: LD_EXP 23
18060: PPUSH
18061: CALL_OW 305
18065: AND
18066: IFFALSE 18080
// Say ( Lisa , DEnd-JMM-Lisa-1 ) ;
18068: LD_EXP 23
18072: PPUSH
18073: LD_STRING DEnd-JMM-Lisa-1
18075: PPUSH
18076: CALL_OW 88
// if Frank and IsPlaced ( Frank ) then
18080: LD_EXP 33
18084: PUSH
18085: LD_EXP 33
18089: PPUSH
18090: CALL_OW 305
18094: AND
18095: IFFALSE 18109
// Say ( Frank , DEnd-JMM-Frank-1 ) ;
18097: LD_EXP 33
18101: PPUSH
18102: LD_STRING DEnd-JMM-Frank-1
18104: PPUSH
18105: CALL_OW 88
// if Cyrus and GetSide ( Cyrus ) = 7 and IsPlaced ( Cyrus ) then
18109: LD_EXP 26
18113: PUSH
18114: LD_EXP 26
18118: PPUSH
18119: CALL_OW 255
18123: PUSH
18124: LD_INT 7
18126: EQUAL
18127: AND
18128: PUSH
18129: LD_EXP 26
18133: PPUSH
18134: CALL_OW 305
18138: AND
18139: IFFALSE 18153
// Say ( Cyrus , DEnd-JMM-Cyrus-1 ) ;
18141: LD_EXP 26
18145: PPUSH
18146: LD_STRING DEnd-JMM-Cyrus-1
18148: PPUSH
18149: CALL_OW 88
// if Burlak then
18153: LD_EXP 54
18157: IFFALSE 18171
// Say ( Burlak , DEnd-JMM-Bur-1 ) ;
18159: LD_EXP 54
18163: PPUSH
18164: LD_STRING DEnd-JMM-Bur-1
18166: PPUSH
18167: CALL_OW 88
// if Joan and Lisa and GetSide ( Lisa ) = 7 and IsPlaced ( Lisa ) and IsOk ( Burlak ) then
18171: LD_EXP 36
18175: PUSH
18176: LD_EXP 23
18180: AND
18181: PUSH
18182: LD_EXP 23
18186: PPUSH
18187: CALL_OW 255
18191: PUSH
18192: LD_INT 7
18194: EQUAL
18195: AND
18196: PUSH
18197: LD_EXP 23
18201: PPUSH
18202: CALL_OW 305
18206: AND
18207: PUSH
18208: LD_EXP 54
18212: PPUSH
18213: CALL_OW 302
18217: AND
18218: IFFALSE 18232
// Say ( Lisa , DEnd-Burlak-Lisa-1 ) ;
18220: LD_EXP 23
18224: PPUSH
18225: LD_STRING DEnd-Burlak-Lisa-1
18227: PPUSH
18228: CALL_OW 88
// if Belkov and IsPlaced ( Belkov ) then
18232: LD_EXP 55
18236: PUSH
18237: LD_EXP 55
18241: PPUSH
18242: CALL_OW 305
18246: AND
18247: IFFALSE 18261
// Say ( Belkov , DEnd-JMM-Bel-1 ) ;
18249: LD_EXP 55
18253: PPUSH
18254: LD_STRING DEnd-JMM-Bel-1
18256: PPUSH
18257: CALL_OW 88
// if Gnyevko and IsPlaced ( Gnyevko ) then
18261: LD_EXP 56
18265: PUSH
18266: LD_EXP 56
18270: PPUSH
18271: CALL_OW 305
18275: AND
18276: IFFALSE 18290
// Say ( Gnyevko , DEnd-JMM-Gny-1 ) ;
18278: LD_EXP 56
18282: PPUSH
18283: LD_STRING DEnd-JMM-Gny-1
18285: PPUSH
18286: CALL_OW 88
// if Cornel and GetSide ( Cornel ) = 7 and IsPlaced ( Cornel ) then
18290: LD_EXP 31
18294: PUSH
18295: LD_EXP 31
18299: PPUSH
18300: CALL_OW 255
18304: PUSH
18305: LD_INT 7
18307: EQUAL
18308: AND
18309: PUSH
18310: LD_EXP 31
18314: PPUSH
18315: CALL_OW 305
18319: AND
18320: IFFALSE 18334
// Say ( Cornel , DEnd-JMM-Corn-1 ) ;
18322: LD_EXP 31
18326: PPUSH
18327: LD_STRING DEnd-JMM-Corn-1
18329: PPUSH
18330: CALL_OW 88
// if Donaldson and GetSide ( Donaldson ) = 7 and IsPlaced ( Donaldson ) then
18334: LD_EXP 24
18338: PUSH
18339: LD_EXP 24
18343: PPUSH
18344: CALL_OW 255
18348: PUSH
18349: LD_INT 7
18351: EQUAL
18352: AND
18353: PUSH
18354: LD_EXP 24
18358: PPUSH
18359: CALL_OW 305
18363: AND
18364: IFFALSE 18378
// Say ( Donaldson , DEnd-JMM-Don-1 ) ;
18366: LD_EXP 24
18370: PPUSH
18371: LD_STRING DEnd-JMM-Don-1
18373: PPUSH
18374: CALL_OW 88
// if Bobby and GetSide ( Bobby ) = 7 and IsPlaced ( Bobby ) then
18378: LD_EXP 25
18382: PUSH
18383: LD_EXP 25
18387: PPUSH
18388: CALL_OW 255
18392: PUSH
18393: LD_INT 7
18395: EQUAL
18396: AND
18397: PUSH
18398: LD_EXP 25
18402: PPUSH
18403: CALL_OW 305
18407: AND
18408: IFFALSE 18422
// Say ( Bobby , DEnd-JMM-Bobby-1 ) ;
18410: LD_EXP 25
18414: PPUSH
18415: LD_STRING DEnd-JMM-Bobby-1
18417: PPUSH
18418: CALL_OW 88
// if Denis and GetSide ( Denis ) = 7 and IsPlaced ( Denis ) then
18422: LD_EXP 27
18426: PUSH
18427: LD_EXP 27
18431: PPUSH
18432: CALL_OW 255
18436: PUSH
18437: LD_INT 7
18439: EQUAL
18440: AND
18441: PUSH
18442: LD_EXP 27
18446: PPUSH
18447: CALL_OW 305
18451: AND
18452: IFFALSE 18466
// Say ( Denis , DEnd-JMM-Den-1 ) ;
18454: LD_EXP 27
18458: PPUSH
18459: LD_STRING DEnd-JMM-Den-1
18461: PPUSH
18462: CALL_OW 88
// if Gladstone and GetSide ( Gladstone ) = 7 and IsPlaced ( Gladstone ) then
18466: LD_EXP 29
18470: PUSH
18471: LD_EXP 29
18475: PPUSH
18476: CALL_OW 255
18480: PUSH
18481: LD_INT 7
18483: EQUAL
18484: AND
18485: PUSH
18486: LD_EXP 29
18490: PPUSH
18491: CALL_OW 305
18495: AND
18496: IFFALSE 18510
// Say ( Gladstone , DEnd-JMM-Glad-1 ) ;
18498: LD_EXP 29
18502: PPUSH
18503: LD_STRING DEnd-JMM-Glad-1
18505: PPUSH
18506: CALL_OW 88
// if Kikuchi and GetSide ( Kikuchi ) = 7 and IsPlaced ( Kikuchi ) then
18510: LD_EXP 34
18514: PUSH
18515: LD_EXP 34
18519: PPUSH
18520: CALL_OW 255
18524: PUSH
18525: LD_INT 7
18527: EQUAL
18528: AND
18529: PUSH
18530: LD_EXP 34
18534: PPUSH
18535: CALL_OW 305
18539: AND
18540: IFFALSE 18554
// Say ( Kikuchi , DEnd-JMM-Yam-1 ) ;
18542: LD_EXP 34
18546: PPUSH
18547: LD_STRING DEnd-JMM-Yam-1
18549: PPUSH
18550: CALL_OW 88
// if Brown and GetSide ( Brown ) = 7 and IsPlaced ( Brown ) then
18554: LD_EXP 28
18558: PUSH
18559: LD_EXP 28
18563: PPUSH
18564: CALL_OW 255
18568: PUSH
18569: LD_INT 7
18571: EQUAL
18572: AND
18573: PUSH
18574: LD_EXP 28
18578: PPUSH
18579: CALL_OW 305
18583: AND
18584: IFFALSE 18598
// Say ( Brown , DEnd-JMM-Brown-1 ) ;
18586: LD_EXP 28
18590: PPUSH
18591: LD_STRING DEnd-JMM-Brown-1
18593: PPUSH
18594: CALL_OW 88
// if Connie and GetSide ( Connie ) = 7 and IsPlaced ( Connie ) then
18598: LD_EXP 38
18602: PUSH
18603: LD_EXP 38
18607: PPUSH
18608: CALL_OW 255
18612: PUSH
18613: LD_INT 7
18615: EQUAL
18616: AND
18617: PUSH
18618: LD_EXP 38
18622: PPUSH
18623: CALL_OW 305
18627: AND
18628: IFFALSE 18642
// Say ( Connie , DEnd-JMM-Con-1 ) ;
18630: LD_EXP 38
18634: PPUSH
18635: LD_STRING DEnd-JMM-Con-1
18637: PPUSH
18638: CALL_OW 88
// if Gary and GetSide ( Gary ) = 7 and IsPlaced ( Gary ) then
18642: LD_EXP 32
18646: PUSH
18647: LD_EXP 32
18651: PPUSH
18652: CALL_OW 255
18656: PUSH
18657: LD_INT 7
18659: EQUAL
18660: AND
18661: PUSH
18662: LD_EXP 32
18666: PPUSH
18667: CALL_OW 305
18671: AND
18672: IFFALSE 18686
// Say ( Gary , DEnd-JMM-Gary-1 ) ;
18674: LD_EXP 32
18678: PPUSH
18679: LD_STRING DEnd-JMM-Gary-1
18681: PPUSH
18682: CALL_OW 88
// if Roth and IsPlaced ( Roth ) then
18686: LD_EXP 22
18690: PUSH
18691: LD_EXP 22
18695: PPUSH
18696: CALL_OW 305
18700: AND
18701: IFFALSE 18715
// Say ( Roth , DEnd-JMM-Roth-1 ) ;
18703: LD_EXP 22
18707: PPUSH
18708: LD_STRING DEnd-JMM-Roth-1
18710: PPUSH
18711: CALL_OW 88
// if Simms and Roth and IsPlaced ( Simms ) then
18715: LD_EXP 35
18719: PUSH
18720: LD_EXP 22
18724: AND
18725: PUSH
18726: LD_EXP 35
18730: PPUSH
18731: CALL_OW 305
18735: AND
18736: IFFALSE 18750
// Say ( Simms , DEnd-JMM-Sim-1 ) ;
18738: LD_EXP 35
18742: PPUSH
18743: LD_STRING DEnd-JMM-Sim-1
18745: PPUSH
18746: CALL_OW 88
// if Houten and GetSide ( Houten ) = 7 and IsPlaced ( Houten ) then
18750: LD_EXP 30
18754: PUSH
18755: LD_EXP 30
18759: PPUSH
18760: CALL_OW 255
18764: PUSH
18765: LD_INT 7
18767: EQUAL
18768: AND
18769: PUSH
18770: LD_EXP 30
18774: PPUSH
18775: CALL_OW 305
18779: AND
18780: IFFALSE 18794
// Say ( Houten , DEnd-JMM-VanH-1 ) ;
18782: LD_EXP 30
18786: PPUSH
18787: LD_STRING DEnd-JMM-VanH-1
18789: PPUSH
18790: CALL_OW 88
// if Dolgov and IsPlaced ( Dolgov ) then
18794: LD_EXP 44
18798: PUSH
18799: LD_EXP 44
18803: PPUSH
18804: CALL_OW 305
18808: AND
18809: IFFALSE 18823
// Say ( Dolgov , DEnd-JMM-Dol-1 ) ;
18811: LD_EXP 44
18815: PPUSH
18816: LD_STRING DEnd-JMM-Dol-1
18818: PPUSH
18819: CALL_OW 88
// if Kikuchi and GetSide ( Kikuchi ) = 7 and IsPlaced ( Kikuchi ) then
18823: LD_EXP 34
18827: PUSH
18828: LD_EXP 34
18832: PPUSH
18833: CALL_OW 255
18837: PUSH
18838: LD_INT 7
18840: EQUAL
18841: AND
18842: PUSH
18843: LD_EXP 34
18847: PPUSH
18848: CALL_OW 305
18852: AND
18853: IFFALSE 18867
// Say ( Kikuchi , DEnd-JMM-Yam-1 ) ;
18855: LD_EXP 34
18859: PPUSH
18860: LD_STRING DEnd-JMM-Yam-1
18862: PPUSH
18863: CALL_OW 88
// if Kapitsova and IsPlaced ( Kapitsova ) then
18867: LD_EXP 48
18871: PUSH
18872: LD_EXP 48
18876: PPUSH
18877: CALL_OW 305
18881: AND
18882: IFFALSE 18896
// Say ( Kapitsova , DEnd-JMM-Kap-1 ) ;
18884: LD_EXP 48
18888: PPUSH
18889: LD_STRING DEnd-JMM-Kap-1
18891: PPUSH
18892: CALL_OW 88
// if Kovalyuk and IsPlaced ( Kovalyuk ) then
18896: LD_EXP 51
18900: PUSH
18901: LD_EXP 51
18905: PPUSH
18906: CALL_OW 305
18910: AND
18911: IFFALSE 18925
// Say ( Kovalyuk , DEnd-JMM-Kov-1 ) ;
18913: LD_EXP 51
18917: PPUSH
18918: LD_STRING DEnd-JMM-Kov-1
18920: PPUSH
18921: CALL_OW 88
// if Scholtze and IsPlaced ( Scholtze ) then
18925: LD_EXP 46
18929: PUSH
18930: LD_EXP 46
18934: PPUSH
18935: CALL_OW 305
18939: AND
18940: IFFALSE 18954
// Say ( Scholtze , DEnd-JMM-Sch-1 ) ;
18942: LD_EXP 46
18946: PPUSH
18947: LD_STRING DEnd-JMM-Sch-1
18949: PPUSH
18950: CALL_OW 88
// if Titov and IsPlaced ( Titov ) and IsOk ( Burlak ) then
18954: LD_EXP 42
18958: PUSH
18959: LD_EXP 42
18963: PPUSH
18964: CALL_OW 305
18968: AND
18969: PUSH
18970: LD_EXP 54
18974: PPUSH
18975: CALL_OW 302
18979: AND
18980: IFFALSE 18994
// Say ( Titov , DEnd-JMM-Tit-1 ) ;
18982: LD_EXP 42
18986: PPUSH
18987: LD_STRING DEnd-JMM-Tit-1
18989: PPUSH
18990: CALL_OW 88
// if Oblukov and IsPlaced ( Oblukov ) then
18994: LD_EXP 47
18998: PUSH
18999: LD_EXP 47
19003: PPUSH
19004: CALL_OW 305
19008: AND
19009: IFFALSE 19023
// Say ( Oblukov , DEnd-JMM-Obl-1 ) ;
19011: LD_EXP 47
19015: PPUSH
19016: LD_STRING DEnd-JMM-Obl-1
19018: PPUSH
19019: CALL_OW 88
// if Lipshchin and IsPlaced ( Lipshchin ) then
19023: LD_EXP 49
19027: PUSH
19028: LD_EXP 49
19032: PPUSH
19033: CALL_OW 305
19037: AND
19038: IFFALSE 19052
// Say ( Lipshchin , DEnd-JMM-Lip-1 ) ;
19040: LD_EXP 49
19044: PPUSH
19045: LD_STRING DEnd-JMM-Lip-1
19047: PPUSH
19048: CALL_OW 88
// if Fadeev and IsPlaced ( Fadeev ) and IsOk ( Burlak ) then
19052: LD_EXP 43
19056: PUSH
19057: LD_EXP 43
19061: PPUSH
19062: CALL_OW 305
19066: AND
19067: PUSH
19068: LD_EXP 54
19072: PPUSH
19073: CALL_OW 302
19077: AND
19078: IFFALSE 19092
// Say ( Fadeev , DEnd-Burlak-Fad-1 ) ;
19080: LD_EXP 43
19084: PPUSH
19085: LD_STRING DEnd-Burlak-Fad-1
19087: PPUSH
19088: CALL_OW 88
// if Petrovova and IsPlaced ( Petrovova ) then
19092: LD_EXP 50
19096: PUSH
19097: LD_EXP 50
19101: PPUSH
19102: CALL_OW 305
19106: AND
19107: IFFALSE 19121
// Say ( Petrovova , DEnd-Burlak-Ptr-1 ) ;
19109: LD_EXP 50
19113: PPUSH
19114: LD_STRING DEnd-Burlak-Ptr-1
19116: PPUSH
19117: CALL_OW 88
// if Kuzmov and IsPlaced ( Kuzmov ) then
19121: LD_EXP 52
19125: PUSH
19126: LD_EXP 52
19130: PPUSH
19131: CALL_OW 305
19135: AND
19136: IFFALSE 19150
// Say ( Kuzmov , DEnd-Burlak-Kuz-1 ) ;
19138: LD_EXP 52
19142: PPUSH
19143: LD_STRING DEnd-Burlak-Kuz-1
19145: PPUSH
19146: CALL_OW 88
// if Kirilenkova and IsPlaced ( Kirilenkova ) and IsOk ( Burlak ) then
19150: LD_EXP 41
19154: PUSH
19155: LD_EXP 41
19159: PPUSH
19160: CALL_OW 305
19164: AND
19165: PUSH
19166: LD_EXP 54
19170: PPUSH
19171: CALL_OW 302
19175: AND
19176: IFFALSE 19190
// Say ( Kirilenkova , DEnd-Burlak-Kir-1 ) ;
19178: LD_EXP 41
19182: PPUSH
19183: LD_STRING DEnd-Burlak-Kir-1
19185: PPUSH
19186: CALL_OW 88
// if Joan then
19190: LD_EXP 36
19194: IFFALSE 19208
// Say ( Joan , DEnd-Burlak-Joan-1 ) ;
19196: LD_EXP 36
19200: PPUSH
19201: LD_STRING DEnd-Burlak-Joan-1
19203: PPUSH
19204: CALL_OW 88
// if IsOk ( Burlak ) then
19208: LD_EXP 54
19212: PPUSH
19213: CALL_OW 302
19217: IFFALSE 19231
// Say ( JMM , DEnd-Burlak-JMM-1 ) ;
19219: LD_EXP 21
19223: PPUSH
19224: LD_STRING DEnd-Burlak-JMM-1
19226: PPUSH
19227: CALL_OW 88
// dwait ( 0 0$2 ) ;
19231: LD_INT 70
19233: PPUSH
19234: CALL_OW 68
// SayRadio ( Schulz , DEnd-Szulc ) ;
19238: LD_EXP 59
19242: PPUSH
19243: LD_STRING DEnd-Szulc
19245: PPUSH
19246: CALL_OW 94
// dwait ( 0 0$1 ) ;
19250: LD_INT 35
19252: PPUSH
19253: CALL_OW 68
// if IsLive ( Burlak ) then
19257: LD_EXP 54
19261: PPUSH
19262: CALL_OW 300
19266: IFFALSE 19278
// med1 := 1 else
19268: LD_ADDR_VAR 0 1
19272: PUSH
19273: LD_INT 1
19275: ST_TO_ADDR
19276: GO 19287
// med1 := - 1 ;
19278: LD_ADDR_VAR 0 1
19282: PUSH
19283: LD_INT 1
19285: NEG
19286: ST_TO_ADDR
// if artifactIResearched and artifactIIResearched and artifactIIIResearched then
19287: LD_EXP 12
19291: PUSH
19292: LD_EXP 13
19296: AND
19297: PUSH
19298: LD_EXP 14
19302: AND
19303: IFFALSE 19315
// med2 := 1 else
19305: LD_ADDR_VAR 0 2
19309: PUSH
19310: LD_INT 1
19312: ST_TO_ADDR
19313: GO 19324
// med2 := - 1 ;
19315: LD_ADDR_VAR 0 2
19319: PUSH
19320: LD_INT 1
19322: NEG
19323: ST_TO_ADDR
// AddMedal ( Hero , 1 ) ;
19324: LD_STRING Hero
19326: PPUSH
19327: LD_INT 1
19329: PPUSH
19330: CALL_OW 101
// AddMedal ( Artefact , med2 ) ;
19334: LD_STRING Artefact
19336: PPUSH
19337: LD_VAR 0 2
19341: PPUSH
19342: CALL_OW 101
// AddMedal ( ReconcileBurlak , med1 ) ;
19346: LD_STRING ReconcileBurlak
19348: PPUSH
19349: LD_VAR 0 1
19353: PPUSH
19354: CALL_OW 101
// if Difficulty >= 3 and med1 = 1 and med2 = 1 then
19358: LD_OWVAR 67
19362: PUSH
19363: LD_INT 3
19365: GREATEREQUAL
19366: PUSH
19367: LD_VAR 0 1
19371: PUSH
19372: LD_INT 1
19374: EQUAL
19375: AND
19376: PUSH
19377: LD_VAR 0 2
19381: PUSH
19382: LD_INT 1
19384: EQUAL
19385: AND
19386: IFFALSE 19398
// SetAchievementEX ( ACH_AMER , 19 ) ;
19388: LD_STRING ACH_AMER
19390: PPUSH
19391: LD_INT 19
19393: PPUSH
19394: CALL_OW 564
// GiveMedals ( MAIN ) ;
19398: LD_STRING MAIN
19400: PPUSH
19401: CALL_OW 102
// InGameOff ;
19405: CALL_OW 9
// DialogueOff ;
19409: CALL_OW 7
// music_nat := 1 ;
19413: LD_ADDR_OWVAR 71
19417: PUSH
19418: LD_INT 1
19420: ST_TO_ADDR
// music_class := 4 ;
19421: LD_ADDR_OWVAR 72
19425: PUSH
19426: LD_INT 4
19428: ST_TO_ADDR
// YouWin ;
19429: CALL_OW 103
// end ; end_of_file
19433: PPOPN 2
19435: END
// export function InitNature ; begin
19436: LD_INT 0
19438: PPUSH
// PrepareNature ( 3 , 3 , 2 , 1 , 1 , 0 , 0 , natureArea1 , 0 ) ;
19439: LD_INT 3
19441: PPUSH
19442: LD_INT 3
19444: PPUSH
19445: LD_INT 2
19447: PPUSH
19448: LD_INT 1
19450: PPUSH
19451: LD_INT 1
19453: PPUSH
19454: LD_INT 0
19456: PPUSH
19457: LD_INT 0
19459: PPUSH
19460: LD_INT 17
19462: PPUSH
19463: LD_INT 0
19465: PPUSH
19466: CALL 87846 0 9
// PrepareNature ( 2 , 1 , 1 , 1 , 1 , 0 , 0 , natureArea2 , 0 ) ;
19470: LD_INT 2
19472: PPUSH
19473: LD_INT 1
19475: PPUSH
19476: LD_INT 1
19478: PPUSH
19479: LD_INT 1
19481: PPUSH
19482: LD_INT 1
19484: PPUSH
19485: LD_INT 0
19487: PPUSH
19488: LD_INT 0
19490: PPUSH
19491: LD_INT 18
19493: PPUSH
19494: LD_INT 0
19496: PPUSH
19497: CALL 87846 0 9
// PrepareNature ( 4 , 1 , 2 , 4 , 2 , 1 , 0 , natureArea3 , 0 ) ;
19501: LD_INT 4
19503: PPUSH
19504: LD_INT 1
19506: PPUSH
19507: LD_INT 2
19509: PPUSH
19510: LD_INT 4
19512: PPUSH
19513: LD_INT 2
19515: PPUSH
19516: LD_INT 1
19518: PPUSH
19519: LD_INT 0
19521: PPUSH
19522: LD_INT 19
19524: PPUSH
19525: LD_INT 0
19527: PPUSH
19528: CALL 87846 0 9
// PrepareNature ( 0 , 0 , 0 , 0 , 0 , 0 , 9 , 0 , natureWaterArea ) ;
19532: LD_INT 0
19534: PPUSH
19535: LD_INT 0
19537: PPUSH
19538: LD_INT 0
19540: PPUSH
19541: LD_INT 0
19543: PPUSH
19544: LD_INT 0
19546: PPUSH
19547: LD_INT 0
19549: PPUSH
19550: LD_INT 9
19552: PPUSH
19553: LD_INT 0
19555: PPUSH
19556: LD_INT 20
19558: PPUSH
19559: CALL 87846 0 9
// end ; end_of_file
19563: LD_VAR 0 1
19567: RET
// every 0 0$30 do var time ;
19568: GO 19570
19570: DISABLE
19571: LD_INT 0
19573: PPUSH
// begin time := 0 0$30 ;
19574: LD_ADDR_VAR 0 1
19578: PUSH
19579: LD_INT 1050
19581: ST_TO_ADDR
// repeat wait ( time ) ;
19582: LD_VAR 0 1
19586: PPUSH
19587: CALL_OW 67
// if Prob ( 50 ) then
19591: LD_INT 50
19593: PPUSH
19594: CALL_OW 13
19598: IFFALSE 19627
// CreateCratesXYR ( rand ( 1 , 5 ) , 106 , 89 , 45 , true ) ;
19600: LD_INT 1
19602: PPUSH
19603: LD_INT 5
19605: PPUSH
19606: CALL_OW 12
19610: PPUSH
19611: LD_INT 106
19613: PPUSH
19614: LD_INT 89
19616: PPUSH
19617: LD_INT 45
19619: PPUSH
19620: LD_INT 1
19622: PPUSH
19623: CALL_OW 56
// time := time + 0 0$3 ;
19627: LD_ADDR_VAR 0 1
19631: PUSH
19632: LD_VAR 0 1
19636: PUSH
19637: LD_INT 105
19639: PLUS
19640: ST_TO_ADDR
// if Prob ( 30 ) then
19641: LD_INT 30
19643: PPUSH
19644: CALL_OW 13
19648: IFFALSE 19694
// begin wait ( rand ( 0 0$15 , 0 0$21 ) ) ;
19650: LD_INT 525
19652: PPUSH
19653: LD_INT 735
19655: PPUSH
19656: CALL_OW 12
19660: PPUSH
19661: CALL_OW 67
// CreateCratesXYR ( rand ( 1 , 5 ) , 21 , 26 , 12 , true ) ;
19665: LD_INT 1
19667: PPUSH
19668: LD_INT 5
19670: PPUSH
19671: CALL_OW 12
19675: PPUSH
19676: LD_INT 21
19678: PPUSH
19679: LD_INT 26
19681: PPUSH
19682: LD_INT 12
19684: PPUSH
19685: LD_INT 1
19687: PPUSH
19688: CALL_OW 56
// end else
19692: GO 19730
// begin wait ( rand ( 0 0$20 , 0 0$35 ) ) ;
19694: LD_INT 700
19696: PPUSH
19697: LD_INT 1225
19699: PPUSH
19700: CALL_OW 12
19704: PPUSH
19705: CALL_OW 67
// CreateCratesArea ( rand ( 1 , 5 ) , russianCratesArea , true ) ;
19709: LD_INT 1
19711: PPUSH
19712: LD_INT 5
19714: PPUSH
19715: CALL_OW 12
19719: PPUSH
19720: LD_INT 14
19722: PPUSH
19723: LD_INT 1
19725: PPUSH
19726: CALL_OW 55
// end ; if Prob ( 50 ) then
19730: LD_INT 50
19732: PPUSH
19733: CALL_OW 13
19737: IFFALSE 19783
// begin wait ( rand ( 0 0$20 , 0 0$30 ) ) ;
19739: LD_INT 700
19741: PPUSH
19742: LD_INT 1050
19744: PPUSH
19745: CALL_OW 12
19749: PPUSH
19750: CALL_OW 67
// CreateCratesXYR ( rand ( 1 , 5 ) , 181 , 218 , 16 , true ) ;
19754: LD_INT 1
19756: PPUSH
19757: LD_INT 5
19759: PPUSH
19760: CALL_OW 12
19764: PPUSH
19765: LD_INT 181
19767: PPUSH
19768: LD_INT 218
19770: PPUSH
19771: LD_INT 16
19773: PPUSH
19774: LD_INT 1
19776: PPUSH
19777: CALL_OW 56
// end else
19781: GO 19855
// begin wait ( rand ( 0 0$10 , 0 0$15 ) ) ;
19783: LD_INT 350
19785: PPUSH
19786: LD_INT 525
19788: PPUSH
19789: CALL_OW 12
19793: PPUSH
19794: CALL_OW 67
// CreateCratesArea ( rand ( 1 , 5 ) , legionCratesArea , true ) ;
19798: LD_INT 1
19800: PPUSH
19801: LD_INT 5
19803: PPUSH
19804: CALL_OW 12
19808: PPUSH
19809: LD_INT 13
19811: PPUSH
19812: LD_INT 1
19814: PPUSH
19815: CALL_OW 55
// wait ( rand ( 0 0$10 , 0 0$20 ) ) ;
19819: LD_INT 350
19821: PPUSH
19822: LD_INT 700
19824: PPUSH
19825: CALL_OW 12
19829: PPUSH
19830: CALL_OW 67
// CreateCratesArea ( rand ( 1 , 5 ) , americanCratesArea , true ) ;
19834: LD_INT 1
19836: PPUSH
19837: LD_INT 5
19839: PPUSH
19840: CALL_OW 12
19844: PPUSH
19845: LD_INT 33
19847: PPUSH
19848: LD_INT 1
19850: PPUSH
19851: CALL_OW 55
// end ; if Prob ( [ 65 , 62 , 55 , 50 ] [ Difficulty ] ) then
19855: LD_INT 65
19857: PUSH
19858: LD_INT 62
19860: PUSH
19861: LD_INT 55
19863: PUSH
19864: LD_INT 50
19866: PUSH
19867: EMPTY
19868: LIST
19869: LIST
19870: LIST
19871: LIST
19872: PUSH
19873: LD_OWVAR 67
19877: ARRAY
19878: PPUSH
19879: CALL_OW 13
19883: IFFALSE 19929
// begin wait ( rand ( 0 0$15 , 0 0$25 ) ) ;
19885: LD_INT 525
19887: PPUSH
19888: LD_INT 875
19890: PPUSH
19891: CALL_OW 12
19895: PPUSH
19896: CALL_OW 67
// CreateCratesXYR ( rand ( 1 , 5 ) , 294 , 211 , 30 , true ) ;
19900: LD_INT 1
19902: PPUSH
19903: LD_INT 5
19905: PPUSH
19906: CALL_OW 12
19910: PPUSH
19911: LD_INT 294
19913: PPUSH
19914: LD_INT 211
19916: PPUSH
19917: LD_INT 30
19919: PPUSH
19920: LD_INT 1
19922: PPUSH
19923: CALL_OW 56
// end else
19927: GO 19971
// begin wait ( rand ( 0 0$12 , 0 0$22 ) ) ;
19929: LD_INT 420
19931: PPUSH
19932: LD_INT 770
19934: PPUSH
19935: CALL_OW 12
19939: PPUSH
19940: CALL_OW 67
// CreateCratesXYR ( rand ( 1 , 5 ) , 294 , 211 , 30 , true ) ;
19944: LD_INT 1
19946: PPUSH
19947: LD_INT 5
19949: PPUSH
19950: CALL_OW 12
19954: PPUSH
19955: LD_INT 294
19957: PPUSH
19958: LD_INT 211
19960: PPUSH
19961: LD_INT 30
19963: PPUSH
19964: LD_INT 1
19966: PPUSH
19967: CALL_OW 56
// end ; if time > 2 2$20 then
19971: LD_VAR 0 1
19975: PUSH
19976: LD_INT 4900
19978: GREATER
19979: IFFALSE 19989
// time := 0 0$50 ;
19981: LD_ADDR_VAR 0 1
19985: PUSH
19986: LD_INT 1750
19988: ST_TO_ADDR
// until false ;
19989: LD_INT 0
19991: IFFALSE 19582
// end ;
19993: PPOPN 1
19995: END
// every 0 0$45 trigger tick < 10 10$00 do
19996: LD_OWVAR 1
20000: PUSH
20001: LD_INT 21000
20003: LESS
20004: IFFALSE 20052
20006: GO 20008
20008: DISABLE
// begin enable ;
20009: ENABLE
// wait ( rand ( 0 0$10 , 0 0$20 ) ) ;
20010: LD_INT 350
20012: PPUSH
20013: LD_INT 700
20015: PPUSH
20016: CALL_OW 12
20020: PPUSH
20021: CALL_OW 67
// CreateCratesXYR ( rand ( 3 , 5 ) , 181 , 13 , 20 , true ) ;
20025: LD_INT 3
20027: PPUSH
20028: LD_INT 5
20030: PPUSH
20031: CALL_OW 12
20035: PPUSH
20036: LD_INT 181
20038: PPUSH
20039: LD_INT 13
20041: PPUSH
20042: LD_INT 20
20044: PPUSH
20045: LD_INT 1
20047: PPUSH
20048: CALL_OW 56
// end ; end_of_file
20052: END
// export artifactsPos , artifactsRecharge , artifactsSibCost , artifactsResearched , artifactsLabsWorking ; export artifactsResDifficulty , artifactsResProgress , artifactsLabs , artifactsButtons , artifactsReady ; export function InitArtifact ; begin
20053: LD_INT 0
20055: PPUSH
// SetArtifactRes ( 7 , true ) ;
20056: LD_INT 7
20058: PPUSH
20059: LD_INT 1
20061: PPUSH
20062: CALL_OW 467
// artifactsPos := [ [ ] , [ ] , [ ] ] ;
20066: LD_ADDR_EXP 68
20070: PUSH
20071: EMPTY
20072: PUSH
20073: EMPTY
20074: PUSH
20075: EMPTY
20076: PUSH
20077: EMPTY
20078: LIST
20079: LIST
20080: LIST
20081: ST_TO_ADDR
// artifactsRecharge := [ 0 0$30 * Difficulty , 1 1$20 * Difficulty , - 1 ] ;
20082: LD_ADDR_EXP 69
20086: PUSH
20087: LD_INT 1050
20089: PUSH
20090: LD_OWVAR 67
20094: MUL
20095: PUSH
20096: LD_INT 2800
20098: PUSH
20099: LD_OWVAR 67
20103: MUL
20104: PUSH
20105: LD_INT 1
20107: NEG
20108: PUSH
20109: EMPTY
20110: LIST
20111: LIST
20112: LIST
20113: ST_TO_ADDR
// artifactsSibCost := [ 10 , 35 , 100 ] ;
20114: LD_ADDR_EXP 70
20118: PUSH
20119: LD_INT 10
20121: PUSH
20122: LD_INT 35
20124: PUSH
20125: LD_INT 100
20127: PUSH
20128: EMPTY
20129: LIST
20130: LIST
20131: LIST
20132: ST_TO_ADDR
// artifactsResearched := [ 0 , 0 , 0 ] ;
20133: LD_ADDR_EXP 71
20137: PUSH
20138: LD_INT 0
20140: PUSH
20141: LD_INT 0
20143: PUSH
20144: LD_INT 0
20146: PUSH
20147: EMPTY
20148: LIST
20149: LIST
20150: LIST
20151: ST_TO_ADDR
// artifactsResDifficulty := [ 300 , 500 , 800 ] ;
20152: LD_ADDR_EXP 73
20156: PUSH
20157: LD_INT 300
20159: PUSH
20160: LD_INT 500
20162: PUSH
20163: LD_INT 800
20165: PUSH
20166: EMPTY
20167: LIST
20168: LIST
20169: LIST
20170: ST_TO_ADDR
// artifactsResProgress := [ 0 , 0 , 0 ] ;
20171: LD_ADDR_EXP 74
20175: PUSH
20176: LD_INT 0
20178: PUSH
20179: LD_INT 0
20181: PUSH
20182: LD_INT 0
20184: PUSH
20185: EMPTY
20186: LIST
20187: LIST
20188: LIST
20189: ST_TO_ADDR
// artifactsLabs := [ 0 , 0 , 0 ] ;
20190: LD_ADDR_EXP 75
20194: PUSH
20195: LD_INT 0
20197: PUSH
20198: LD_INT 0
20200: PUSH
20201: LD_INT 0
20203: PUSH
20204: EMPTY
20205: LIST
20206: LIST
20207: LIST
20208: ST_TO_ADDR
// artifactsLabsWorking := [ 0 , 0 , 0 ] ;
20209: LD_ADDR_EXP 72
20213: PUSH
20214: LD_INT 0
20216: PUSH
20217: LD_INT 0
20219: PUSH
20220: LD_INT 0
20222: PUSH
20223: EMPTY
20224: LIST
20225: LIST
20226: LIST
20227: ST_TO_ADDR
// artifactsButtons := [ [ art_use_eye , art_place , art_exp_left ] , [ art_use_sibexplosion , art_unit , art_exp_mid ] , [ art_use_teleport , art_place , art_exp_right ] ] ;
20228: LD_ADDR_EXP 76
20232: PUSH
20233: LD_INT 4
20235: PUSH
20236: LD_INT 3
20238: PUSH
20239: LD_INT 1
20241: PUSH
20242: EMPTY
20243: LIST
20244: LIST
20245: LIST
20246: PUSH
20247: LD_INT 5
20249: PUSH
20250: LD_INT 4
20252: PUSH
20253: LD_INT 2
20255: PUSH
20256: EMPTY
20257: LIST
20258: LIST
20259: LIST
20260: PUSH
20261: LD_INT 6
20263: PUSH
20264: LD_INT 3
20266: PUSH
20267: LD_INT 3
20269: PUSH
20270: EMPTY
20271: LIST
20272: LIST
20273: LIST
20274: PUSH
20275: EMPTY
20276: LIST
20277: LIST
20278: LIST
20279: ST_TO_ADDR
// artifactsReady := [ 0 , 0 , 0 ] ;
20280: LD_ADDR_EXP 77
20284: PUSH
20285: LD_INT 0
20287: PUSH
20288: LD_INT 0
20290: PUSH
20291: LD_INT 0
20293: PUSH
20294: EMPTY
20295: LIST
20296: LIST
20297: LIST
20298: ST_TO_ADDR
// end ;
20299: LD_VAR 0 1
20303: RET
// every 0 0$1 trigger GetTech ( tech_artifact , 7 ) = state_researched do var i , pos , j , labs , nearestLab ;
20304: LD_INT 24
20306: PPUSH
20307: LD_INT 7
20309: PPUSH
20310: CALL_OW 321
20314: PUSH
20315: LD_INT 2
20317: EQUAL
20318: IFFALSE 21244
20320: GO 20322
20322: DISABLE
20323: LD_INT 0
20325: PPUSH
20326: PPUSH
20327: PPUSH
20328: PPUSH
20329: PPUSH
// begin enable ;
20330: ENABLE
// for i = 1 to 3 do
20331: LD_ADDR_VAR 0 1
20335: PUSH
20336: DOUBLE
20337: LD_INT 1
20339: DEC
20340: ST_TO_ADDR
20341: LD_INT 3
20343: PUSH
20344: FOR_TO
20345: IFFALSE 21242
// begin pos := FindArtifact ( i + 2 ) ;
20347: LD_ADDR_VAR 0 2
20351: PUSH
20352: LD_VAR 0 1
20356: PUSH
20357: LD_INT 2
20359: PLUS
20360: PPUSH
20361: CALL_OW 469
20365: ST_TO_ADDR
// artifactsPos := Replace ( artifactsPos , i , pos ) ;
20366: LD_ADDR_EXP 68
20370: PUSH
20371: LD_EXP 68
20375: PPUSH
20376: LD_VAR 0 1
20380: PPUSH
20381: LD_VAR 0 2
20385: PPUSH
20386: CALL_OW 1
20390: ST_TO_ADDR
// if pos then
20391: LD_VAR 0 2
20395: IFFALSE 21103
// begin case i of 1 :
20397: LD_VAR 0 1
20401: PUSH
20402: LD_INT 1
20404: DOUBLE
20405: EQUAL
20406: IFTRUE 20410
20408: GO 20487
20410: POP
// labs := FilterAllUnits ( [ [ f_side , 7 ] , [ f_nation , 1 ] , [ f_or , [ f_btype , b_lab_full ] , [ f_btype , b_lab_half ] , [ f_btype , b_lab_siberium ] ] ] ) ; 2 :
20411: LD_ADDR_VAR 0 4
20415: PUSH
20416: LD_INT 22
20418: PUSH
20419: LD_INT 7
20421: PUSH
20422: EMPTY
20423: LIST
20424: LIST
20425: PUSH
20426: LD_INT 23
20428: PUSH
20429: LD_INT 1
20431: PUSH
20432: EMPTY
20433: LIST
20434: LIST
20435: PUSH
20436: LD_INT 2
20438: PUSH
20439: LD_INT 30
20441: PUSH
20442: LD_INT 8
20444: PUSH
20445: EMPTY
20446: LIST
20447: LIST
20448: PUSH
20449: LD_INT 30
20451: PUSH
20452: LD_INT 7
20454: PUSH
20455: EMPTY
20456: LIST
20457: LIST
20458: PUSH
20459: LD_INT 30
20461: PUSH
20462: LD_INT 11
20464: PUSH
20465: EMPTY
20466: LIST
20467: LIST
20468: PUSH
20469: EMPTY
20470: LIST
20471: LIST
20472: LIST
20473: LIST
20474: PUSH
20475: EMPTY
20476: LIST
20477: LIST
20478: LIST
20479: PPUSH
20480: CALL_OW 69
20484: ST_TO_ADDR
20485: GO 20595
20487: LD_INT 2
20489: DOUBLE
20490: EQUAL
20491: IFTRUE 20495
20493: GO 20572
20495: POP
// labs := FilterAllUnits ( [ [ f_side , 7 ] , [ f_nation , 3 ] , [ f_or , [ f_btype , b_lab_full ] , [ f_btype , b_lab_half ] , [ f_btype , b_lab_siberium ] ] ] ) ; 3 :
20496: LD_ADDR_VAR 0 4
20500: PUSH
20501: LD_INT 22
20503: PUSH
20504: LD_INT 7
20506: PUSH
20507: EMPTY
20508: LIST
20509: LIST
20510: PUSH
20511: LD_INT 23
20513: PUSH
20514: LD_INT 3
20516: PUSH
20517: EMPTY
20518: LIST
20519: LIST
20520: PUSH
20521: LD_INT 2
20523: PUSH
20524: LD_INT 30
20526: PUSH
20527: LD_INT 8
20529: PUSH
20530: EMPTY
20531: LIST
20532: LIST
20533: PUSH
20534: LD_INT 30
20536: PUSH
20537: LD_INT 7
20539: PUSH
20540: EMPTY
20541: LIST
20542: LIST
20543: PUSH
20544: LD_INT 30
20546: PUSH
20547: LD_INT 11
20549: PUSH
20550: EMPTY
20551: LIST
20552: LIST
20553: PUSH
20554: EMPTY
20555: LIST
20556: LIST
20557: LIST
20558: LIST
20559: PUSH
20560: EMPTY
20561: LIST
20562: LIST
20563: LIST
20564: PPUSH
20565: CALL_OW 69
20569: ST_TO_ADDR
20570: GO 20595
20572: LD_INT 3
20574: DOUBLE
20575: EQUAL
20576: IFTRUE 20580
20578: GO 20594
20580: POP
// labs := [ alien ] ; end ;
20581: LD_ADDR_VAR 0 4
20585: PUSH
20586: LD_INT 1
20588: PUSH
20589: EMPTY
20590: LIST
20591: ST_TO_ADDR
20592: GO 20595
20594: POP
// if not labs then
20595: LD_VAR 0 4
20599: NOT
20600: IFFALSE 20604
// continue ;
20602: GO 20344
// nearestLab := NearestUnitToXY ( labs , artifactsPos [ i ] [ 1 ] , artifactsPos [ i ] [ 2 ] ) ;
20604: LD_ADDR_VAR 0 5
20608: PUSH
20609: LD_VAR 0 4
20613: PPUSH
20614: LD_EXP 68
20618: PUSH
20619: LD_VAR 0 1
20623: ARRAY
20624: PUSH
20625: LD_INT 1
20627: ARRAY
20628: PPUSH
20629: LD_EXP 68
20633: PUSH
20634: LD_VAR 0 1
20638: ARRAY
20639: PUSH
20640: LD_INT 2
20642: ARRAY
20643: PPUSH
20644: CALL_OW 73
20648: ST_TO_ADDR
// if not nearestLab or nearestLab <> artifactsLabs [ i ] then
20649: LD_VAR 0 5
20653: NOT
20654: PUSH
20655: LD_VAR 0 5
20659: PUSH
20660: LD_EXP 75
20664: PUSH
20665: LD_VAR 0 1
20669: ARRAY
20670: NONEQUAL
20671: OR
20672: IFFALSE 20777
// begin SetArtifactUse ( 7 , artifactsButtons [ i ] [ 3 ] , art_no , artifactsLabs [ i ] ) ;
20674: LD_INT 7
20676: PPUSH
20677: LD_EXP 76
20681: PUSH
20682: LD_VAR 0 1
20686: ARRAY
20687: PUSH
20688: LD_INT 3
20690: ARRAY
20691: PPUSH
20692: LD_INT 0
20694: PPUSH
20695: LD_EXP 75
20699: PUSH
20700: LD_VAR 0 1
20704: ARRAY
20705: PPUSH
20706: CALL_OW 468
// SetArtifactUse ( 7 , artifactsButtons [ i ] [ 1 ] , art_no , artifactsLabs [ i ] ) ;
20710: LD_INT 7
20712: PPUSH
20713: LD_EXP 76
20717: PUSH
20718: LD_VAR 0 1
20722: ARRAY
20723: PUSH
20724: LD_INT 1
20726: ARRAY
20727: PPUSH
20728: LD_INT 0
20730: PPUSH
20731: LD_EXP 75
20735: PUSH
20736: LD_VAR 0 1
20740: ARRAY
20741: PPUSH
20742: CALL_OW 468
// if nearestLab then
20746: LD_VAR 0 5
20750: IFFALSE 20777
// artifactsLabs := Replace ( artifactsLabs , i , nearestLab ) ;
20752: LD_ADDR_EXP 75
20756: PUSH
20757: LD_EXP 75
20761: PPUSH
20762: LD_VAR 0 1
20766: PPUSH
20767: LD_VAR 0 5
20771: PPUSH
20772: CALL_OW 1
20776: ST_TO_ADDR
// end ; if not nearestLab then
20777: LD_VAR 0 5
20781: NOT
20782: IFFALSE 20786
// continue ;
20784: GO 20344
// if GetDistUnitXY ( nearestLab , artifactsPos [ i ] [ 1 ] , artifactsPos [ i ] [ 2 ] ) < 8 then
20786: LD_VAR 0 5
20790: PPUSH
20791: LD_EXP 68
20795: PUSH
20796: LD_VAR 0 1
20800: ARRAY
20801: PUSH
20802: LD_INT 1
20804: ARRAY
20805: PPUSH
20806: LD_EXP 68
20810: PUSH
20811: LD_VAR 0 1
20815: ARRAY
20816: PUSH
20817: LD_INT 2
20819: ARRAY
20820: PPUSH
20821: CALL_OW 297
20825: PUSH
20826: LD_INT 8
20828: LESS
20829: IFFALSE 21026
// begin if not artifactsResearched [ i ] then
20831: LD_EXP 71
20835: PUSH
20836: LD_VAR 0 1
20840: ARRAY
20841: NOT
20842: IFFALSE 20923
// begin if BuildingStatus ( nearestLab ) = bs_idle then
20844: LD_VAR 0 5
20848: PPUSH
20849: CALL_OW 461
20853: PUSH
20854: LD_INT 2
20856: EQUAL
20857: IFFALSE 20891
// SetArtifactUse ( 7 , artifactsButtons [ i ] [ 3 ] , art_instant , nearestLab ) else
20859: LD_INT 7
20861: PPUSH
20862: LD_EXP 76
20866: PUSH
20867: LD_VAR 0 1
20871: ARRAY
20872: PUSH
20873: LD_INT 3
20875: ARRAY
20876: PPUSH
20877: LD_INT 2
20879: PPUSH
20880: LD_VAR 0 5
20884: PPUSH
20885: CALL_OW 468
20889: GO 20921
// SetArtifactUse ( 7 , artifactsButtons [ i ] [ 3 ] , art_gray , nearestLab ) ;
20891: LD_INT 7
20893: PPUSH
20894: LD_EXP 76
20898: PUSH
20899: LD_VAR 0 1
20903: ARRAY
20904: PUSH
20905: LD_INT 3
20907: ARRAY
20908: PPUSH
20909: LD_INT 1
20911: PPUSH
20912: LD_VAR 0 5
20916: PPUSH
20917: CALL_OW 468
// end else
20921: GO 21024
// begin if BuildingStatus ( nearestLab ) = bs_idle and artifactsReady [ i ] then
20923: LD_VAR 0 5
20927: PPUSH
20928: CALL_OW 461
20932: PUSH
20933: LD_INT 2
20935: EQUAL
20936: PUSH
20937: LD_EXP 77
20941: PUSH
20942: LD_VAR 0 1
20946: ARRAY
20947: AND
20948: IFFALSE 20994
// SetArtifactUse ( 7 , artifactsButtons [ i ] [ 1 ] , artifactsButtons [ i ] [ 2 ] , nearestLab ) else
20950: LD_INT 7
20952: PPUSH
20953: LD_EXP 76
20957: PUSH
20958: LD_VAR 0 1
20962: ARRAY
20963: PUSH
20964: LD_INT 1
20966: ARRAY
20967: PPUSH
20968: LD_EXP 76
20972: PUSH
20973: LD_VAR 0 1
20977: ARRAY
20978: PUSH
20979: LD_INT 2
20981: ARRAY
20982: PPUSH
20983: LD_VAR 0 5
20987: PPUSH
20988: CALL_OW 468
20992: GO 21024
// SetArtifactUse ( 7 , artifactsButtons [ i ] [ 1 ] , art_gray , nearestLab ) end ;
20994: LD_INT 7
20996: PPUSH
20997: LD_EXP 76
21001: PUSH
21002: LD_VAR 0 1
21006: ARRAY
21007: PUSH
21008: LD_INT 1
21010: ARRAY
21011: PPUSH
21012: LD_INT 1
21014: PPUSH
21015: LD_VAR 0 5
21019: PPUSH
21020: CALL_OW 468
// end else
21024: GO 21101
// begin if not artifactsResearched [ i ] then
21026: LD_EXP 71
21030: PUSH
21031: LD_VAR 0 1
21035: ARRAY
21036: NOT
21037: IFFALSE 21071
// SetArtifactUse ( 7 , artifactsButtons [ i ] [ 3 ] , art_no , nearestLab ) else
21039: LD_INT 7
21041: PPUSH
21042: LD_EXP 76
21046: PUSH
21047: LD_VAR 0 1
21051: ARRAY
21052: PUSH
21053: LD_INT 3
21055: ARRAY
21056: PPUSH
21057: LD_INT 0
21059: PPUSH
21060: LD_VAR 0 5
21064: PPUSH
21065: CALL_OW 468
21069: GO 21101
// SetArtifactUse ( 7 , artifactsButtons [ i ] [ 1 ] , art_no , nearestLab ) ;
21071: LD_INT 7
21073: PPUSH
21074: LD_EXP 76
21078: PUSH
21079: LD_VAR 0 1
21083: ARRAY
21084: PUSH
21085: LD_INT 1
21087: ARRAY
21088: PPUSH
21089: LD_INT 0
21091: PPUSH
21092: LD_VAR 0 5
21096: PPUSH
21097: CALL_OW 468
// end ; end else
21101: GO 21240
// begin if not artifactsLabs [ i ] then
21103: LD_EXP 75
21107: PUSH
21108: LD_VAR 0 1
21112: ARRAY
21113: NOT
21114: IFFALSE 21118
// continue ;
21116: GO 20344
// SetArtifactUse ( 7 , artifactsButtons [ i ] [ 3 ] , art_no , artifactsLabs [ i ] ) ;
21118: LD_INT 7
21120: PPUSH
21121: LD_EXP 76
21125: PUSH
21126: LD_VAR 0 1
21130: ARRAY
21131: PUSH
21132: LD_INT 3
21134: ARRAY
21135: PPUSH
21136: LD_INT 0
21138: PPUSH
21139: LD_EXP 75
21143: PUSH
21144: LD_VAR 0 1
21148: ARRAY
21149: PPUSH
21150: CALL_OW 468
// SetArtifactUse ( 7 , artifactsButtons [ i ] [ 1 ] , art_no , artifactsLabs [ i ] ) ;
21154: LD_INT 7
21156: PPUSH
21157: LD_EXP 76
21161: PUSH
21162: LD_VAR 0 1
21166: ARRAY
21167: PUSH
21168: LD_INT 1
21170: ARRAY
21171: PPUSH
21172: LD_INT 0
21174: PPUSH
21175: LD_EXP 75
21179: PUSH
21180: LD_VAR 0 1
21184: ARRAY
21185: PPUSH
21186: CALL_OW 468
// if artifactsLabsWorking [ i ] then
21190: LD_EXP 72
21194: PUSH
21195: LD_VAR 0 1
21199: ARRAY
21200: IFFALSE 21240
// begin artifactsLabsWorking := Replace ( artifactsLabsWorking , i , false ) ;
21202: LD_ADDR_EXP 72
21206: PUSH
21207: LD_EXP 72
21211: PPUSH
21212: LD_VAR 0 1
21216: PPUSH
21217: LD_INT 0
21219: PPUSH
21220: CALL_OW 1
21224: ST_TO_ADDR
// ComCancel ( artifactsLabs [ i ] ) ;
21225: LD_EXP 75
21229: PUSH
21230: LD_VAR 0 1
21234: ARRAY
21235: PPUSH
21236: CALL_OW 127
// end ; end ; end ;
21240: GO 20344
21242: POP
21243: POP
// end ;
21244: PPOPN 5
21246: END
// on ArtifactUsed ( side , icon , x , y ) do var i , lab , time , list , un ;
21247: LD_INT 0
21249: PPUSH
21250: PPUSH
21251: PPUSH
21252: PPUSH
21253: PPUSH
// begin if icon = artifactsButtons [ 1 ] [ 3 ] then
21254: LD_VAR 0 2
21258: PUSH
21259: LD_EXP 76
21263: PUSH
21264: LD_INT 1
21266: ARRAY
21267: PUSH
21268: LD_INT 3
21270: ARRAY
21271: EQUAL
21272: IFFALSE 21395
// begin lab := artifactsLabs [ 1 ] ;
21274: LD_ADDR_VAR 0 6
21278: PUSH
21279: LD_EXP 75
21283: PUSH
21284: LD_INT 1
21286: ARRAY
21287: ST_TO_ADDR
// if not lab then
21288: LD_VAR 0 6
21292: NOT
21293: IFFALSE 21297
// exit ;
21295: GO 22375
// SetSpecResearch ( lab , artifactsResDifficulty [ 1 ] , true ) ;
21297: LD_VAR 0 6
21301: PPUSH
21302: LD_EXP 73
21306: PUSH
21307: LD_INT 1
21309: ARRAY
21310: PPUSH
21311: LD_INT 1
21313: PPUSH
21314: CALL_OW 486
// if artifactsResProgress [ 1 ] then
21318: LD_EXP 74
21322: PUSH
21323: LD_INT 1
21325: ARRAY
21326: IFFALSE 21346
// SetWorkingProgress ( lab , artifactsResProgress [ 1 ] ) ;
21328: LD_VAR 0 6
21332: PPUSH
21333: LD_EXP 74
21337: PUSH
21338: LD_INT 1
21340: ARRAY
21341: PPUSH
21342: CALL_OW 329
// artifactsLabsWorking := Replace ( artifactsLabsWorking , 1 , 1 ) ;
21346: LD_ADDR_EXP 72
21350: PUSH
21351: LD_EXP 72
21355: PPUSH
21356: LD_INT 1
21358: PPUSH
21359: LD_INT 1
21361: PPUSH
21362: CALL_OW 1
21366: ST_TO_ADDR
// SetArtifactUse ( 7 , artifactsButtons [ 1 ] [ 3 ] , art_no , lab ) ;
21367: LD_INT 7
21369: PPUSH
21370: LD_EXP 76
21374: PUSH
21375: LD_INT 1
21377: ARRAY
21378: PUSH
21379: LD_INT 3
21381: ARRAY
21382: PPUSH
21383: LD_INT 0
21385: PPUSH
21386: LD_VAR 0 6
21390: PPUSH
21391: CALL_OW 468
// end ; if icon = artifactsButtons [ 2 ] [ 3 ] then
21395: LD_VAR 0 2
21399: PUSH
21400: LD_EXP 76
21404: PUSH
21405: LD_INT 2
21407: ARRAY
21408: PUSH
21409: LD_INT 3
21411: ARRAY
21412: EQUAL
21413: IFFALSE 21536
// begin lab := artifactsLabs [ 2 ] ;
21415: LD_ADDR_VAR 0 6
21419: PUSH
21420: LD_EXP 75
21424: PUSH
21425: LD_INT 2
21427: ARRAY
21428: ST_TO_ADDR
// if not lab then
21429: LD_VAR 0 6
21433: NOT
21434: IFFALSE 21438
// exit ;
21436: GO 22375
// SetSpecResearch ( lab , artifactsResDifficulty [ 2 ] , true ) ;
21438: LD_VAR 0 6
21442: PPUSH
21443: LD_EXP 73
21447: PUSH
21448: LD_INT 2
21450: ARRAY
21451: PPUSH
21452: LD_INT 1
21454: PPUSH
21455: CALL_OW 486
// if artifactsResProgress [ 2 ] then
21459: LD_EXP 74
21463: PUSH
21464: LD_INT 2
21466: ARRAY
21467: IFFALSE 21487
// SetWorkingProgress ( lab , artifactsResProgress [ 2 ] ) ;
21469: LD_VAR 0 6
21473: PPUSH
21474: LD_EXP 74
21478: PUSH
21479: LD_INT 2
21481: ARRAY
21482: PPUSH
21483: CALL_OW 329
// artifactsLabsWorking := Replace ( artifactsLabsWorking , 2 , 1 ) ;
21487: LD_ADDR_EXP 72
21491: PUSH
21492: LD_EXP 72
21496: PPUSH
21497: LD_INT 2
21499: PPUSH
21500: LD_INT 1
21502: PPUSH
21503: CALL_OW 1
21507: ST_TO_ADDR
// SetArtifactUse ( 7 , artifactsButtons [ 2 ] [ 3 ] , art_no , lab ) ;
21508: LD_INT 7
21510: PPUSH
21511: LD_EXP 76
21515: PUSH
21516: LD_INT 2
21518: ARRAY
21519: PUSH
21520: LD_INT 3
21522: ARRAY
21523: PPUSH
21524: LD_INT 0
21526: PPUSH
21527: LD_VAR 0 6
21531: PPUSH
21532: CALL_OW 468
// end ; if icon = artifactsButtons [ 3 ] [ 3 ] then
21536: LD_VAR 0 2
21540: PUSH
21541: LD_EXP 76
21545: PUSH
21546: LD_INT 3
21548: ARRAY
21549: PUSH
21550: LD_INT 3
21552: ARRAY
21553: EQUAL
21554: IFFALSE 21677
// begin lab := artifactsLabs [ 3 ] ;
21556: LD_ADDR_VAR 0 6
21560: PUSH
21561: LD_EXP 75
21565: PUSH
21566: LD_INT 3
21568: ARRAY
21569: ST_TO_ADDR
// if not lab then
21570: LD_VAR 0 6
21574: NOT
21575: IFFALSE 21579
// exit ;
21577: GO 22375
// SetSpecResearch ( lab , artifactsResDifficulty [ 3 ] , true ) ;
21579: LD_VAR 0 6
21583: PPUSH
21584: LD_EXP 73
21588: PUSH
21589: LD_INT 3
21591: ARRAY
21592: PPUSH
21593: LD_INT 1
21595: PPUSH
21596: CALL_OW 486
// if artifactsResProgress [ 3 ] then
21600: LD_EXP 74
21604: PUSH
21605: LD_INT 3
21607: ARRAY
21608: IFFALSE 21628
// SetWorkingProgress ( lab , artifactsResProgress [ 3 ] ) ;
21610: LD_VAR 0 6
21614: PPUSH
21615: LD_EXP 74
21619: PUSH
21620: LD_INT 3
21622: ARRAY
21623: PPUSH
21624: CALL_OW 329
// artifactsLabsWorking := Replace ( artifactsLabsWorking , 3 , 1 ) ;
21628: LD_ADDR_EXP 72
21632: PUSH
21633: LD_EXP 72
21637: PPUSH
21638: LD_INT 3
21640: PPUSH
21641: LD_INT 1
21643: PPUSH
21644: CALL_OW 1
21648: ST_TO_ADDR
// SetArtifactUse ( 7 , artifactsButtons [ 3 ] [ 3 ] , art_no , lab ) ;
21649: LD_INT 7
21651: PPUSH
21652: LD_EXP 76
21656: PUSH
21657: LD_INT 3
21659: ARRAY
21660: PUSH
21661: LD_INT 3
21663: ARRAY
21664: PPUSH
21665: LD_INT 0
21667: PPUSH
21668: LD_VAR 0 6
21672: PPUSH
21673: CALL_OW 468
// end ; if icon = artifactsButtons [ 1 ] [ 1 ] then
21677: LD_VAR 0 2
21681: PUSH
21682: LD_EXP 76
21686: PUSH
21687: LD_INT 1
21689: ARRAY
21690: PUSH
21691: LD_INT 1
21693: ARRAY
21694: EQUAL
21695: IFFALSE 21853
// begin lab := artifactsLabs [ 1 ] ;
21697: LD_ADDR_VAR 0 6
21701: PUSH
21702: LD_EXP 75
21706: PUSH
21707: LD_INT 1
21709: ARRAY
21710: ST_TO_ADDR
// if GetBaseMaterials ( GetBase ( lab ) ) [ 3 ] < artifactsSibCost [ 1 ] then
21711: LD_VAR 0 6
21715: PPUSH
21716: CALL_OW 274
21720: PPUSH
21721: CALL 91399 0 1
21725: PUSH
21726: LD_INT 3
21728: ARRAY
21729: PUSH
21730: LD_EXP 70
21734: PUSH
21735: LD_INT 1
21737: ARRAY
21738: LESS
21739: IFFALSE 21753
// begin HintSpec ( ArtifactCost , 2 ) ;
21741: LD_STRING ArtifactCost
21743: PPUSH
21744: LD_INT 2
21746: PPUSH
21747: CALL_OW 338
// exit ;
21751: GO 22375
// end ; artifactsReady := Replace ( artifactsReady , 1 , false ) ;
21753: LD_ADDR_EXP 77
21757: PUSH
21758: LD_EXP 77
21762: PPUSH
21763: LD_INT 1
21765: PPUSH
21766: LD_INT 0
21768: PPUSH
21769: CALL_OW 1
21773: ST_TO_ADDR
// PlaceSeeing ( x , y , 7 , - 12 ) ;
21774: LD_VAR 0 3
21778: PPUSH
21779: LD_VAR 0 4
21783: PPUSH
21784: LD_INT 7
21786: PPUSH
21787: LD_INT 12
21789: NEG
21790: PPUSH
21791: CALL_OW 330
// wait ( 0 0$30 ) ;
21795: LD_INT 1050
21797: PPUSH
21798: CALL_OW 67
// RemoveSeeing ( x , y , 7 ) ;
21802: LD_VAR 0 3
21806: PPUSH
21807: LD_VAR 0 4
21811: PPUSH
21812: LD_INT 7
21814: PPUSH
21815: CALL_OW 331
// wait ( artifactsRecharge [ 1 ] ) ;
21819: LD_EXP 69
21823: PUSH
21824: LD_INT 1
21826: ARRAY
21827: PPUSH
21828: CALL_OW 67
// artifactsReady := Replace ( artifactsReady , 1 , true ) ;
21832: LD_ADDR_EXP 77
21836: PUSH
21837: LD_EXP 77
21841: PPUSH
21842: LD_INT 1
21844: PPUSH
21845: LD_INT 1
21847: PPUSH
21848: CALL_OW 1
21852: ST_TO_ADDR
// end ; if icon = artifactsButtons [ 2 ] [ 1 ] then
21853: LD_VAR 0 2
21857: PUSH
21858: LD_EXP 76
21862: PUSH
21863: LD_INT 2
21865: ARRAY
21866: PUSH
21867: LD_INT 1
21869: ARRAY
21870: EQUAL
21871: IFFALSE 22108
// begin lab := artifactsLabs [ 2 ] ;
21873: LD_ADDR_VAR 0 6
21877: PUSH
21878: LD_EXP 75
21882: PUSH
21883: LD_INT 2
21885: ARRAY
21886: ST_TO_ADDR
// if not x in FilterAllUnits ( [ [ f_enemy , 7 ] , [ f_or , [ f_engine , engine_siberite ] , [ f_btype , b_siberite_power ] , [ f_btype , b_siberite_mine ] , [ f_bweapon , ru_time_lapser ] , [ f_weapon , ru_time_lapser ] , [ f_btype , b_ext_siberium ] ] ] ) then
21887: LD_VAR 0 3
21891: PUSH
21892: LD_INT 81
21894: PUSH
21895: LD_INT 7
21897: PUSH
21898: EMPTY
21899: LIST
21900: LIST
21901: PUSH
21902: LD_INT 2
21904: PUSH
21905: LD_INT 32
21907: PUSH
21908: LD_INT 3
21910: PUSH
21911: EMPTY
21912: LIST
21913: LIST
21914: PUSH
21915: LD_INT 30
21917: PUSH
21918: LD_INT 28
21920: PUSH
21921: EMPTY
21922: LIST
21923: LIST
21924: PUSH
21925: LD_INT 30
21927: PUSH
21928: LD_INT 30
21930: PUSH
21931: EMPTY
21932: LIST
21933: LIST
21934: PUSH
21935: LD_INT 35
21937: PUSH
21938: LD_INT 49
21940: PUSH
21941: EMPTY
21942: LIST
21943: LIST
21944: PUSH
21945: LD_INT 34
21947: PUSH
21948: LD_INT 49
21950: PUSH
21951: EMPTY
21952: LIST
21953: LIST
21954: PUSH
21955: LD_INT 30
21957: PUSH
21958: LD_INT 21
21960: PUSH
21961: EMPTY
21962: LIST
21963: LIST
21964: PUSH
21965: EMPTY
21966: LIST
21967: LIST
21968: LIST
21969: LIST
21970: LIST
21971: LIST
21972: LIST
21973: PUSH
21974: EMPTY
21975: LIST
21976: LIST
21977: PPUSH
21978: CALL_OW 69
21982: IN
21983: NOT
21984: IFFALSE 21988
// exit ;
21986: GO 22375
// if GetBaseMaterials ( GetBase ( lab ) ) [ 3 ] < artifactsSibCost [ 2 ] then
21988: LD_VAR 0 6
21992: PPUSH
21993: CALL_OW 274
21997: PPUSH
21998: CALL 91399 0 1
22002: PUSH
22003: LD_INT 3
22005: ARRAY
22006: PUSH
22007: LD_EXP 70
22011: PUSH
22012: LD_INT 2
22014: ARRAY
22015: LESS
22016: IFFALSE 22030
// begin HintSpec ( ArtifactCost , 2 ) ;
22018: LD_STRING ArtifactCost
22020: PPUSH
22021: LD_INT 2
22023: PPUSH
22024: CALL_OW 338
// exit ;
22028: GO 22375
// end ; artifactsReady := Replace ( artifactsReady , 2 , false ) ;
22030: LD_ADDR_EXP 77
22034: PUSH
22035: LD_EXP 77
22039: PPUSH
22040: LD_INT 2
22042: PPUSH
22043: LD_INT 0
22045: PPUSH
22046: CALL_OW 1
22050: ST_TO_ADDR
// KillUnit ( x ) ;
22051: LD_VAR 0 3
22055: PPUSH
22056: CALL_OW 66
// artifactDestroyCounter := artifactDestroyCounter + 1 ;
22060: LD_ADDR_EXP 16
22064: PUSH
22065: LD_EXP 16
22069: PUSH
22070: LD_INT 1
22072: PLUS
22073: ST_TO_ADDR
// wait ( artifactsRecharge [ 2 ] ) ;
22074: LD_EXP 69
22078: PUSH
22079: LD_INT 2
22081: ARRAY
22082: PPUSH
22083: CALL_OW 67
// artifactsReady := Replace ( artifactsReady , 2 , true ) ;
22087: LD_ADDR_EXP 77
22091: PUSH
22092: LD_EXP 77
22096: PPUSH
22097: LD_INT 2
22099: PPUSH
22100: LD_INT 1
22102: PPUSH
22103: CALL_OW 1
22107: ST_TO_ADDR
// end ; if icon = artifactsButtons [ 3 ] [ 1 ] then
22108: LD_VAR 0 2
22112: PUSH
22113: LD_EXP 76
22117: PUSH
22118: LD_INT 3
22120: ARRAY
22121: PUSH
22122: LD_INT 1
22124: ARRAY
22125: EQUAL
22126: IFFALSE 22375
// begin lab := artifactsLabs [ 3 ] ;
22128: LD_ADDR_VAR 0 6
22132: PUSH
22133: LD_EXP 75
22137: PUSH
22138: LD_INT 3
22140: ARRAY
22141: ST_TO_ADDR
// if GetBaseMaterials ( GetBase ( lab ) ) [ 3 ] < artifactsSibCost [ 3 ] then
22142: LD_VAR 0 6
22146: PPUSH
22147: CALL_OW 274
22151: PPUSH
22152: CALL 91399 0 1
22156: PUSH
22157: LD_INT 3
22159: ARRAY
22160: PUSH
22161: LD_EXP 70
22165: PUSH
22166: LD_INT 3
22168: ARRAY
22169: LESS
22170: IFFALSE 22184
// begin HintSpec ( ArtifactCost , 2 ) ;
22172: LD_STRING ArtifactCost
22174: PPUSH
22175: LD_INT 2
22177: PPUSH
22178: CALL_OW 338
// exit ;
22182: GO 22375
// end ; SetAreaMapShow ( teleportArea , 1 ) ;
22184: LD_INT 37
22186: PPUSH
22187: LD_INT 1
22189: PPUSH
22190: CALL_OW 424
// time := 0 0$30 ;
22194: LD_ADDR_VAR 0 7
22198: PUSH
22199: LD_INT 1050
22201: ST_TO_ADDR
// artifactsReady := Replace ( artifactsReady , 3 , false ) ;
22202: LD_ADDR_EXP 77
22206: PUSH
22207: LD_EXP 77
22211: PPUSH
22212: LD_INT 3
22214: PPUSH
22215: LD_INT 0
22217: PPUSH
22218: CALL_OW 1
22222: ST_TO_ADDR
// repeat display_strings := [ #Am15a-1 , time ] ;
22223: LD_ADDR_OWVAR 47
22227: PUSH
22228: LD_STRING #Am15a-1
22230: PUSH
22231: LD_VAR 0 7
22235: PUSH
22236: EMPTY
22237: LIST
22238: LIST
22239: ST_TO_ADDR
// wait ( 0 0$1 ) ;
22240: LD_INT 35
22242: PPUSH
22243: CALL_OW 67
// time := time - 0 0$1 ;
22247: LD_ADDR_VAR 0 7
22251: PUSH
22252: LD_VAR 0 7
22256: PUSH
22257: LD_INT 35
22259: MINUS
22260: ST_TO_ADDR
// until time = 0 0$00 ;
22261: LD_VAR 0 7
22265: PUSH
22266: LD_INT 0
22268: EQUAL
22269: IFFALSE 22223
// display_strings :=  ;
22271: LD_ADDR_OWVAR 47
22275: PUSH
22276: LD_STRING 
22278: ST_TO_ADDR
// SetAreaMapShow ( teleportArea , 0 ) ;
22279: LD_INT 37
22281: PPUSH
22282: LD_INT 0
22284: PPUSH
22285: CALL_OW 424
// list := FilterUnitsInArea ( teleportArea , [ f_not , [ f_type , unit_building ] ] ) ;
22289: LD_ADDR_VAR 0 8
22293: PUSH
22294: LD_INT 37
22296: PPUSH
22297: LD_INT 3
22299: PUSH
22300: LD_INT 21
22302: PUSH
22303: LD_INT 3
22305: PUSH
22306: EMPTY
22307: LIST
22308: LIST
22309: PUSH
22310: EMPTY
22311: LIST
22312: LIST
22313: PPUSH
22314: CALL_OW 70
22318: ST_TO_ADDR
// CenterOnXY ( x , y ) ;
22319: LD_VAR 0 3
22323: PPUSH
22324: LD_VAR 0 4
22328: PPUSH
22329: CALL_OW 84
// for un in list do
22333: LD_ADDR_VAR 0 9
22337: PUSH
22338: LD_VAR 0 8
22342: PUSH
22343: FOR_IN
22344: IFFALSE 22373
// TeleportUnit ( un , x , y , 12 , true ) ;
22346: LD_VAR 0 9
22350: PPUSH
22351: LD_VAR 0 3
22355: PPUSH
22356: LD_VAR 0 4
22360: PPUSH
22361: LD_INT 12
22363: PPUSH
22364: LD_INT 1
22366: PPUSH
22367: CALL_OW 483
22371: GO 22343
22373: POP
22374: POP
// end ; end ;
22375: PPOPN 9
22377: END
// on SpecResearchCancel ( lab , progress ) do var i , labNum ;
22378: LD_INT 0
22380: PPUSH
22381: PPUSH
// begin labNum := 0 ;
22382: LD_ADDR_VAR 0 4
22386: PUSH
22387: LD_INT 0
22389: ST_TO_ADDR
// for i = 1 to artifactsLabs do
22390: LD_ADDR_VAR 0 3
22394: PUSH
22395: DOUBLE
22396: LD_INT 1
22398: DEC
22399: ST_TO_ADDR
22400: LD_EXP 75
22404: PUSH
22405: FOR_TO
22406: IFFALSE 22440
// if artifactsLabs [ i ] = lab then
22408: LD_EXP 75
22412: PUSH
22413: LD_VAR 0 3
22417: ARRAY
22418: PUSH
22419: LD_VAR 0 1
22423: EQUAL
22424: IFFALSE 22438
// begin labNum := i ;
22426: LD_ADDR_VAR 0 4
22430: PUSH
22431: LD_VAR 0 3
22435: ST_TO_ADDR
// break ;
22436: GO 22440
// end ;
22438: GO 22405
22440: POP
22441: POP
// if not labNum then
22442: LD_VAR 0 4
22446: NOT
22447: IFFALSE 22451
// exit ;
22449: GO 22529
// SetArtifactUse ( 7 , artifactsButtons [ labNum ] [ 3 ] , art_instant , lab ) ;
22451: LD_INT 7
22453: PPUSH
22454: LD_EXP 76
22458: PUSH
22459: LD_VAR 0 4
22463: ARRAY
22464: PUSH
22465: LD_INT 3
22467: ARRAY
22468: PPUSH
22469: LD_INT 2
22471: PPUSH
22472: LD_VAR 0 1
22476: PPUSH
22477: CALL_OW 468
// artifactsResProgress := Replace ( artifactsResProgress , labNum , progress ) ;
22481: LD_ADDR_EXP 74
22485: PUSH
22486: LD_EXP 74
22490: PPUSH
22491: LD_VAR 0 4
22495: PPUSH
22496: LD_VAR 0 2
22500: PPUSH
22501: CALL_OW 1
22505: ST_TO_ADDR
// artifactsLabsWorking := Replace ( artifactsLabsWorking , labNum , 0 ) ;
22506: LD_ADDR_EXP 72
22510: PUSH
22511: LD_EXP 72
22515: PPUSH
22516: LD_VAR 0 4
22520: PPUSH
22521: LD_INT 0
22523: PPUSH
22524: CALL_OW 1
22528: ST_TO_ADDR
// end ;
22529: PPOPN 4
22531: END
// on SpecResearchComplete ( lab ) do var i , labNum ;
22532: LD_INT 0
22534: PPUSH
22535: PPUSH
// begin labNum := 0 ;
22536: LD_ADDR_VAR 0 3
22540: PUSH
22541: LD_INT 0
22543: ST_TO_ADDR
// for i = 1 to artifactsLabs do
22544: LD_ADDR_VAR 0 2
22548: PUSH
22549: DOUBLE
22550: LD_INT 1
22552: DEC
22553: ST_TO_ADDR
22554: LD_EXP 75
22558: PUSH
22559: FOR_TO
22560: IFFALSE 22594
// if artifactsLabs [ i ] = lab then
22562: LD_EXP 75
22566: PUSH
22567: LD_VAR 0 2
22571: ARRAY
22572: PUSH
22573: LD_VAR 0 1
22577: EQUAL
22578: IFFALSE 22592
// begin labNum := i ;
22580: LD_ADDR_VAR 0 3
22584: PUSH
22585: LD_VAR 0 2
22589: ST_TO_ADDR
// break ;
22590: GO 22594
// end ;
22592: GO 22559
22594: POP
22595: POP
// if not labNum then
22596: LD_VAR 0 3
22600: NOT
22601: IFFALSE 22605
// exit ;
22603: GO 22767
// SetArtifactUse ( 7 , artifactsButtons [ labNum ] [ 3 ] , art_no , lab ) ;
22605: LD_INT 7
22607: PPUSH
22608: LD_EXP 76
22612: PUSH
22613: LD_VAR 0 3
22617: ARRAY
22618: PUSH
22619: LD_INT 3
22621: ARRAY
22622: PPUSH
22623: LD_INT 0
22625: PPUSH
22626: LD_VAR 0 1
22630: PPUSH
22631: CALL_OW 468
// artifactsResearched := Replace ( artifactsResearched , labNum , true ) ;
22635: LD_ADDR_EXP 71
22639: PUSH
22640: LD_EXP 71
22644: PPUSH
22645: LD_VAR 0 3
22649: PPUSH
22650: LD_INT 1
22652: PPUSH
22653: CALL_OW 1
22657: ST_TO_ADDR
// artifactsReady := Replace ( artifactsReady , labNum , true ) ;
22658: LD_ADDR_EXP 77
22662: PUSH
22663: LD_EXP 77
22667: PPUSH
22668: LD_VAR 0 3
22672: PPUSH
22673: LD_INT 1
22675: PPUSH
22676: CALL_OW 1
22680: ST_TO_ADDR
// artifactsLabsWorking := Replace ( artifactsLabsWorking , labNum , false ) ;
22681: LD_ADDR_EXP 72
22685: PUSH
22686: LD_EXP 72
22690: PPUSH
22691: LD_VAR 0 3
22695: PPUSH
22696: LD_INT 0
22698: PPUSH
22699: CALL_OW 1
22703: ST_TO_ADDR
// case labNum of 1 :
22704: LD_VAR 0 3
22708: PUSH
22709: LD_INT 1
22711: DOUBLE
22712: EQUAL
22713: IFTRUE 22717
22715: GO 22728
22717: POP
// artifactIResearched := true ; 2 :
22718: LD_ADDR_EXP 12
22722: PUSH
22723: LD_INT 1
22725: ST_TO_ADDR
22726: GO 22767
22728: LD_INT 2
22730: DOUBLE
22731: EQUAL
22732: IFTRUE 22736
22734: GO 22747
22736: POP
// artifactIIResearched := true ; 3 :
22737: LD_ADDR_EXP 13
22741: PUSH
22742: LD_INT 1
22744: ST_TO_ADDR
22745: GO 22767
22747: LD_INT 3
22749: DOUBLE
22750: EQUAL
22751: IFTRUE 22755
22753: GO 22766
22755: POP
// artifactIIIResearched := true ; end ;
22756: LD_ADDR_EXP 14
22760: PUSH
22761: LD_INT 1
22763: ST_TO_ADDR
22764: GO 22767
22766: POP
// end ; end_of_file
22767: PPOPN 3
22769: END
// export skirmish , debug_mc ; export mc_bases , mc_building_need_repair , mc_building_repairs , mc_need_heal , mc_healers , mc_build_list , mc_builders , mc_construct_list , mc_turret_list , mc_empty_turret_list , mc_busy_turret_list , mc_defender_limit , mc_repair_vehicle , mc_mines , mc_miners , mc_minefields , mc_crates , mc_crates_collector , mc_crates_area , mc_vehicles , mc_attack , mc_produce , mc_defender , mc_scan , mc_parking , mc_scan_area , mc_sides , mc_tech , mc_can_tame , mc_ape , mc_ape_in_lab , mc_taming , mc_build_upgrade , mc_lab , mc_lab_upgrade , mc_teleport_exit , mc_teleport_exit_set , mc_deposits_xy , mc_deposits_finder , mc_allowed_tower_weapons , mc_remote_driver , mc_class , mc_class_case_use , mc_is_defending ; export mc_block_vehicle_constructed_thread ; export function InitMacro ; var i ; begin
22770: LD_INT 0
22772: PPUSH
22773: PPUSH
// skirmish := false ;
22774: LD_ADDR_EXP 78
22778: PUSH
22779: LD_INT 0
22781: ST_TO_ADDR
// debug_mc := false ;
22782: LD_ADDR_EXP 79
22786: PUSH
22787: LD_INT 0
22789: ST_TO_ADDR
// mc_bases := [ ] ;
22790: LD_ADDR_EXP 80
22794: PUSH
22795: EMPTY
22796: ST_TO_ADDR
// mc_sides := [ ] ;
22797: LD_ADDR_EXP 106
22801: PUSH
22802: EMPTY
22803: ST_TO_ADDR
// mc_building_need_repair := [ ] ;
22804: LD_ADDR_EXP 81
22808: PUSH
22809: EMPTY
22810: ST_TO_ADDR
// mc_building_repairs := [ ] ;
22811: LD_ADDR_EXP 82
22815: PUSH
22816: EMPTY
22817: ST_TO_ADDR
// mc_need_heal := [ ] ;
22818: LD_ADDR_EXP 83
22822: PUSH
22823: EMPTY
22824: ST_TO_ADDR
// mc_healers := [ ] ;
22825: LD_ADDR_EXP 84
22829: PUSH
22830: EMPTY
22831: ST_TO_ADDR
// mc_build_list := [ ] ;
22832: LD_ADDR_EXP 85
22836: PUSH
22837: EMPTY
22838: ST_TO_ADDR
// mc_build_upgrade := [ ] ;
22839: LD_ADDR_EXP 112
22843: PUSH
22844: EMPTY
22845: ST_TO_ADDR
// mc_builders := [ ] ;
22846: LD_ADDR_EXP 86
22850: PUSH
22851: EMPTY
22852: ST_TO_ADDR
// mc_construct_list := [ ] ;
22853: LD_ADDR_EXP 87
22857: PUSH
22858: EMPTY
22859: ST_TO_ADDR
// mc_turret_list := [ ] ;
22860: LD_ADDR_EXP 88
22864: PUSH
22865: EMPTY
22866: ST_TO_ADDR
// mc_empty_turret_list := [ ] ;
22867: LD_ADDR_EXP 89
22871: PUSH
22872: EMPTY
22873: ST_TO_ADDR
// mc_miners := [ ] ;
22874: LD_ADDR_EXP 94
22878: PUSH
22879: EMPTY
22880: ST_TO_ADDR
// mc_mines := [ ] ;
22881: LD_ADDR_EXP 93
22885: PUSH
22886: EMPTY
22887: ST_TO_ADDR
// mc_minefields := [ ] ;
22888: LD_ADDR_EXP 95
22892: PUSH
22893: EMPTY
22894: ST_TO_ADDR
// mc_crates := [ ] ;
22895: LD_ADDR_EXP 96
22899: PUSH
22900: EMPTY
22901: ST_TO_ADDR
// mc_crates_collector := [ ] ;
22902: LD_ADDR_EXP 97
22906: PUSH
22907: EMPTY
22908: ST_TO_ADDR
// mc_crates_area := [ ] ;
22909: LD_ADDR_EXP 98
22913: PUSH
22914: EMPTY
22915: ST_TO_ADDR
// mc_vehicles := [ ] ;
22916: LD_ADDR_EXP 99
22920: PUSH
22921: EMPTY
22922: ST_TO_ADDR
// mc_attack := [ ] ;
22923: LD_ADDR_EXP 100
22927: PUSH
22928: EMPTY
22929: ST_TO_ADDR
// mc_produce := [ ] ;
22930: LD_ADDR_EXP 101
22934: PUSH
22935: EMPTY
22936: ST_TO_ADDR
// mc_defender := [ ] ;
22937: LD_ADDR_EXP 102
22941: PUSH
22942: EMPTY
22943: ST_TO_ADDR
// mc_parking := [ ] ;
22944: LD_ADDR_EXP 104
22948: PUSH
22949: EMPTY
22950: ST_TO_ADDR
// mc_busy_turret_list := [ ] ;
22951: LD_ADDR_EXP 90
22955: PUSH
22956: EMPTY
22957: ST_TO_ADDR
// mc_repair_vehicle := [ ] ;
22958: LD_ADDR_EXP 92
22962: PUSH
22963: EMPTY
22964: ST_TO_ADDR
// mc_scan := [ ] ;
22965: LD_ADDR_EXP 103
22969: PUSH
22970: EMPTY
22971: ST_TO_ADDR
// mc_scan_area := [ ] ;
22972: LD_ADDR_EXP 105
22976: PUSH
22977: EMPTY
22978: ST_TO_ADDR
// mc_tech := [ ] ;
22979: LD_ADDR_EXP 107
22983: PUSH
22984: EMPTY
22985: ST_TO_ADDR
// mc_class := [ ] ;
22986: LD_ADDR_EXP 121
22990: PUSH
22991: EMPTY
22992: ST_TO_ADDR
// mc_class_case_use := [ ] ;
22993: LD_ADDR_EXP 122
22997: PUSH
22998: EMPTY
22999: ST_TO_ADDR
// mc_is_defending := [ ] ;
23000: LD_ADDR_EXP 123
23004: PUSH
23005: EMPTY
23006: ST_TO_ADDR
// mc_lab_upgrade := [ ] ;
23007: LD_ADDR_EXP 114
23011: PUSH
23012: EMPTY
23013: ST_TO_ADDR
// mc_block_vehicle_constructed_thread := false ;
23014: LD_ADDR_EXP 124
23018: PUSH
23019: LD_INT 0
23021: ST_TO_ADDR
// end ;
23022: LD_VAR 0 1
23026: RET
// export function MC_Kill ( base ) ; begin
23027: LD_INT 0
23029: PPUSH
// mc_bases := Replace ( mc_bases , base , [ ] ) ;
23030: LD_ADDR_EXP 80
23034: PUSH
23035: LD_EXP 80
23039: PPUSH
23040: LD_VAR 0 1
23044: PPUSH
23045: EMPTY
23046: PPUSH
23047: CALL_OW 1
23051: ST_TO_ADDR
// mc_building_need_repair := Replace ( mc_building_need_repair , base , [ ] ) ;
23052: LD_ADDR_EXP 81
23056: PUSH
23057: LD_EXP 81
23061: PPUSH
23062: LD_VAR 0 1
23066: PPUSH
23067: EMPTY
23068: PPUSH
23069: CALL_OW 1
23073: ST_TO_ADDR
// mc_building_repairs := Replace ( mc_building_repairs , base , [ ] ) ;
23074: LD_ADDR_EXP 82
23078: PUSH
23079: LD_EXP 82
23083: PPUSH
23084: LD_VAR 0 1
23088: PPUSH
23089: EMPTY
23090: PPUSH
23091: CALL_OW 1
23095: ST_TO_ADDR
// mc_need_heal := Replace ( mc_need_heal , base , [ ] ) ;
23096: LD_ADDR_EXP 83
23100: PUSH
23101: LD_EXP 83
23105: PPUSH
23106: LD_VAR 0 1
23110: PPUSH
23111: EMPTY
23112: PPUSH
23113: CALL_OW 1
23117: ST_TO_ADDR
// mc_healers := Replace ( mc_healers , base , [ ] ) ;
23118: LD_ADDR_EXP 84
23122: PUSH
23123: LD_EXP 84
23127: PPUSH
23128: LD_VAR 0 1
23132: PPUSH
23133: EMPTY
23134: PPUSH
23135: CALL_OW 1
23139: ST_TO_ADDR
// mc_build_list := Replace ( mc_build_list , base , [ ] ) ;
23140: LD_ADDR_EXP 85
23144: PUSH
23145: LD_EXP 85
23149: PPUSH
23150: LD_VAR 0 1
23154: PPUSH
23155: EMPTY
23156: PPUSH
23157: CALL_OW 1
23161: ST_TO_ADDR
// mc_builders := Replace ( mc_builders , base , [ ] ) ;
23162: LD_ADDR_EXP 86
23166: PUSH
23167: LD_EXP 86
23171: PPUSH
23172: LD_VAR 0 1
23176: PPUSH
23177: EMPTY
23178: PPUSH
23179: CALL_OW 1
23183: ST_TO_ADDR
// mc_construct_list := Replace ( mc_construct_list , base , [ ] ) ;
23184: LD_ADDR_EXP 87
23188: PUSH
23189: LD_EXP 87
23193: PPUSH
23194: LD_VAR 0 1
23198: PPUSH
23199: EMPTY
23200: PPUSH
23201: CALL_OW 1
23205: ST_TO_ADDR
// mc_turret_list := Replace ( mc_turret_list , base , [ ] ) ;
23206: LD_ADDR_EXP 88
23210: PUSH
23211: LD_EXP 88
23215: PPUSH
23216: LD_VAR 0 1
23220: PPUSH
23221: EMPTY
23222: PPUSH
23223: CALL_OW 1
23227: ST_TO_ADDR
// mc_empty_turret_list := Replace ( mc_empty_turret_list , base , [ ] ) ;
23228: LD_ADDR_EXP 89
23232: PUSH
23233: LD_EXP 89
23237: PPUSH
23238: LD_VAR 0 1
23242: PPUSH
23243: EMPTY
23244: PPUSH
23245: CALL_OW 1
23249: ST_TO_ADDR
// mc_busy_turret_list := Replace ( mc_busy_turret_list , base , [ ] ) ;
23250: LD_ADDR_EXP 90
23254: PUSH
23255: LD_EXP 90
23259: PPUSH
23260: LD_VAR 0 1
23264: PPUSH
23265: EMPTY
23266: PPUSH
23267: CALL_OW 1
23271: ST_TO_ADDR
// mc_defender_limit := Replace ( mc_defender_limit , base , 0 ) ;
23272: LD_ADDR_EXP 91
23276: PUSH
23277: LD_EXP 91
23281: PPUSH
23282: LD_VAR 0 1
23286: PPUSH
23287: LD_INT 0
23289: PPUSH
23290: CALL_OW 1
23294: ST_TO_ADDR
// mc_repair_vehicle := Replace ( mc_repair_vehicle , base , [ ] ) ;
23295: LD_ADDR_EXP 92
23299: PUSH
23300: LD_EXP 92
23304: PPUSH
23305: LD_VAR 0 1
23309: PPUSH
23310: EMPTY
23311: PPUSH
23312: CALL_OW 1
23316: ST_TO_ADDR
// mc_mines := Replace ( mc_mines , base , [ ] ) ;
23317: LD_ADDR_EXP 93
23321: PUSH
23322: LD_EXP 93
23326: PPUSH
23327: LD_VAR 0 1
23331: PPUSH
23332: EMPTY
23333: PPUSH
23334: CALL_OW 1
23338: ST_TO_ADDR
// mc_miners := Replace ( mc_miners , base , [ ] ) ;
23339: LD_ADDR_EXP 94
23343: PUSH
23344: LD_EXP 94
23348: PPUSH
23349: LD_VAR 0 1
23353: PPUSH
23354: EMPTY
23355: PPUSH
23356: CALL_OW 1
23360: ST_TO_ADDR
// mc_minefields := Replace ( mc_minefields , base , [ ] ) ;
23361: LD_ADDR_EXP 95
23365: PUSH
23366: LD_EXP 95
23370: PPUSH
23371: LD_VAR 0 1
23375: PPUSH
23376: EMPTY
23377: PPUSH
23378: CALL_OW 1
23382: ST_TO_ADDR
// mc_crates := Replace ( mc_crates , base , [ ] ) ;
23383: LD_ADDR_EXP 96
23387: PUSH
23388: LD_EXP 96
23392: PPUSH
23393: LD_VAR 0 1
23397: PPUSH
23398: EMPTY
23399: PPUSH
23400: CALL_OW 1
23404: ST_TO_ADDR
// mc_crates_collector := Replace ( mc_crates_collector , base , [ ] ) ;
23405: LD_ADDR_EXP 97
23409: PUSH
23410: LD_EXP 97
23414: PPUSH
23415: LD_VAR 0 1
23419: PPUSH
23420: EMPTY
23421: PPUSH
23422: CALL_OW 1
23426: ST_TO_ADDR
// mc_crates_area := Replace ( mc_crates_area , base , [ ] ) ;
23427: LD_ADDR_EXP 98
23431: PUSH
23432: LD_EXP 98
23436: PPUSH
23437: LD_VAR 0 1
23441: PPUSH
23442: EMPTY
23443: PPUSH
23444: CALL_OW 1
23448: ST_TO_ADDR
// mc_vehicles := Replace ( mc_vehicles , base , [ ] ) ;
23449: LD_ADDR_EXP 99
23453: PUSH
23454: LD_EXP 99
23458: PPUSH
23459: LD_VAR 0 1
23463: PPUSH
23464: EMPTY
23465: PPUSH
23466: CALL_OW 1
23470: ST_TO_ADDR
// mc_attack := Replace ( mc_attack , base , [ ] ) ;
23471: LD_ADDR_EXP 100
23475: PUSH
23476: LD_EXP 100
23480: PPUSH
23481: LD_VAR 0 1
23485: PPUSH
23486: EMPTY
23487: PPUSH
23488: CALL_OW 1
23492: ST_TO_ADDR
// mc_produce := Replace ( mc_produce , base , [ ] ) ;
23493: LD_ADDR_EXP 101
23497: PUSH
23498: LD_EXP 101
23502: PPUSH
23503: LD_VAR 0 1
23507: PPUSH
23508: EMPTY
23509: PPUSH
23510: CALL_OW 1
23514: ST_TO_ADDR
// mc_defender := Replace ( mc_defender , base , [ ] ) ;
23515: LD_ADDR_EXP 102
23519: PUSH
23520: LD_EXP 102
23524: PPUSH
23525: LD_VAR 0 1
23529: PPUSH
23530: EMPTY
23531: PPUSH
23532: CALL_OW 1
23536: ST_TO_ADDR
// mc_scan := Replace ( mc_scan , base , [ ] ) ;
23537: LD_ADDR_EXP 103
23541: PUSH
23542: LD_EXP 103
23546: PPUSH
23547: LD_VAR 0 1
23551: PPUSH
23552: EMPTY
23553: PPUSH
23554: CALL_OW 1
23558: ST_TO_ADDR
// mc_parking := Replace ( mc_parking , base , [ ] ) ;
23559: LD_ADDR_EXP 104
23563: PUSH
23564: LD_EXP 104
23568: PPUSH
23569: LD_VAR 0 1
23573: PPUSH
23574: EMPTY
23575: PPUSH
23576: CALL_OW 1
23580: ST_TO_ADDR
// mc_scan_area := Replace ( mc_scan_area , base , [ ] ) ;
23581: LD_ADDR_EXP 105
23585: PUSH
23586: LD_EXP 105
23590: PPUSH
23591: LD_VAR 0 1
23595: PPUSH
23596: EMPTY
23597: PPUSH
23598: CALL_OW 1
23602: ST_TO_ADDR
// mc_tech := Replace ( mc_tech , base , [ ] ) ;
23603: LD_ADDR_EXP 107
23607: PUSH
23608: LD_EXP 107
23612: PPUSH
23613: LD_VAR 0 1
23617: PPUSH
23618: EMPTY
23619: PPUSH
23620: CALL_OW 1
23624: ST_TO_ADDR
// mc_ape := Replace ( mc_ape , base , [ ] ) ;
23625: LD_ADDR_EXP 109
23629: PUSH
23630: LD_EXP 109
23634: PPUSH
23635: LD_VAR 0 1
23639: PPUSH
23640: EMPTY
23641: PPUSH
23642: CALL_OW 1
23646: ST_TO_ADDR
// mc_ape_in_lab := Replace ( mc_ape_in_lab , base , [ ] ) ;
23647: LD_ADDR_EXP 110
23651: PUSH
23652: LD_EXP 110
23656: PPUSH
23657: LD_VAR 0 1
23661: PPUSH
23662: EMPTY
23663: PPUSH
23664: CALL_OW 1
23668: ST_TO_ADDR
// mc_taming := Replace ( mc_taming , base , [ ] ) ;
23669: LD_ADDR_EXP 111
23673: PUSH
23674: LD_EXP 111
23678: PPUSH
23679: LD_VAR 0 1
23683: PPUSH
23684: EMPTY
23685: PPUSH
23686: CALL_OW 1
23690: ST_TO_ADDR
// mc_build_upgrade := Replace ( mc_build_upgrade , base , [ ] ) ;
23691: LD_ADDR_EXP 112
23695: PUSH
23696: LD_EXP 112
23700: PPUSH
23701: LD_VAR 0 1
23705: PPUSH
23706: EMPTY
23707: PPUSH
23708: CALL_OW 1
23712: ST_TO_ADDR
// mc_lab := Replace ( mc_lab , base , [ ] ) ;
23713: LD_ADDR_EXP 113
23717: PUSH
23718: LD_EXP 113
23722: PPUSH
23723: LD_VAR 0 1
23727: PPUSH
23728: EMPTY
23729: PPUSH
23730: CALL_OW 1
23734: ST_TO_ADDR
// mc_lab_upgrade := Replace ( mc_lab_upgrade , base , [ ] ) ;
23735: LD_ADDR_EXP 114
23739: PUSH
23740: LD_EXP 114
23744: PPUSH
23745: LD_VAR 0 1
23749: PPUSH
23750: EMPTY
23751: PPUSH
23752: CALL_OW 1
23756: ST_TO_ADDR
// mc_teleport_exit := Replace ( mc_teleport_exit , base , [ ] ) ;
23757: LD_ADDR_EXP 115
23761: PUSH
23762: LD_EXP 115
23766: PPUSH
23767: LD_VAR 0 1
23771: PPUSH
23772: EMPTY
23773: PPUSH
23774: CALL_OW 1
23778: ST_TO_ADDR
// mc_teleport_exit_set := Replace ( mc_teleport_exit_set , base , [ ] ) ;
23779: LD_ADDR_EXP 116
23783: PUSH
23784: LD_EXP 116
23788: PPUSH
23789: LD_VAR 0 1
23793: PPUSH
23794: EMPTY
23795: PPUSH
23796: CALL_OW 1
23800: ST_TO_ADDR
// mc_deposits_xy := Replace ( mc_deposits_xy , base , [ ] ) ;
23801: LD_ADDR_EXP 117
23805: PUSH
23806: LD_EXP 117
23810: PPUSH
23811: LD_VAR 0 1
23815: PPUSH
23816: EMPTY
23817: PPUSH
23818: CALL_OW 1
23822: ST_TO_ADDR
// mc_deposits_finder := Replace ( mc_deposits_finder , base , [ ] ) ;
23823: LD_ADDR_EXP 118
23827: PUSH
23828: LD_EXP 118
23832: PPUSH
23833: LD_VAR 0 1
23837: PPUSH
23838: EMPTY
23839: PPUSH
23840: CALL_OW 1
23844: ST_TO_ADDR
// mc_allowed_tower_weapons := Replace ( mc_allowed_tower_weapons , base , [ ] ) ;
23845: LD_ADDR_EXP 119
23849: PUSH
23850: LD_EXP 119
23854: PPUSH
23855: LD_VAR 0 1
23859: PPUSH
23860: EMPTY
23861: PPUSH
23862: CALL_OW 1
23866: ST_TO_ADDR
// mc_remote_driver := Replace ( mc_remote_driver , base , [ ] ) ;
23867: LD_ADDR_EXP 120
23871: PUSH
23872: LD_EXP 120
23876: PPUSH
23877: LD_VAR 0 1
23881: PPUSH
23882: EMPTY
23883: PPUSH
23884: CALL_OW 1
23888: ST_TO_ADDR
// mc_class := Replace ( mc_class , base , [ ] ) ;
23889: LD_ADDR_EXP 121
23893: PUSH
23894: LD_EXP 121
23898: PPUSH
23899: LD_VAR 0 1
23903: PPUSH
23904: EMPTY
23905: PPUSH
23906: CALL_OW 1
23910: ST_TO_ADDR
// mc_class_case_use := Replace ( mc_class_case_use , base , 0 ) ;
23911: LD_ADDR_EXP 122
23915: PUSH
23916: LD_EXP 122
23920: PPUSH
23921: LD_VAR 0 1
23925: PPUSH
23926: LD_INT 0
23928: PPUSH
23929: CALL_OW 1
23933: ST_TO_ADDR
// mc_is_defending := Replace ( mc_is_defending , base , false ) ;
23934: LD_ADDR_EXP 123
23938: PUSH
23939: LD_EXP 123
23943: PPUSH
23944: LD_VAR 0 1
23948: PPUSH
23949: LD_INT 0
23951: PPUSH
23952: CALL_OW 1
23956: ST_TO_ADDR
// end ;
23957: LD_VAR 0 2
23961: RET
// export function MC_Add ( side , units ) ; var base ; begin
23962: LD_INT 0
23964: PPUSH
23965: PPUSH
// base := mc_bases + 1 ;
23966: LD_ADDR_VAR 0 4
23970: PUSH
23971: LD_EXP 80
23975: PUSH
23976: LD_INT 1
23978: PLUS
23979: ST_TO_ADDR
// mc_sides := Replace ( mc_sides , base , side ) ;
23980: LD_ADDR_EXP 106
23984: PUSH
23985: LD_EXP 106
23989: PPUSH
23990: LD_VAR 0 4
23994: PPUSH
23995: LD_VAR 0 1
23999: PPUSH
24000: CALL_OW 1
24004: ST_TO_ADDR
// mc_bases := Replace ( mc_bases , base , units ) ;
24005: LD_ADDR_EXP 80
24009: PUSH
24010: LD_EXP 80
24014: PPUSH
24015: LD_VAR 0 4
24019: PPUSH
24020: LD_VAR 0 2
24024: PPUSH
24025: CALL_OW 1
24029: ST_TO_ADDR
// mc_building_need_repair := Replace ( mc_building_need_repair , base , [ ] ) ;
24030: LD_ADDR_EXP 81
24034: PUSH
24035: LD_EXP 81
24039: PPUSH
24040: LD_VAR 0 4
24044: PPUSH
24045: EMPTY
24046: PPUSH
24047: CALL_OW 1
24051: ST_TO_ADDR
// mc_building_repairs := Replace ( mc_building_repairs , base , [ ] ) ;
24052: LD_ADDR_EXP 82
24056: PUSH
24057: LD_EXP 82
24061: PPUSH
24062: LD_VAR 0 4
24066: PPUSH
24067: EMPTY
24068: PPUSH
24069: CALL_OW 1
24073: ST_TO_ADDR
// mc_need_heal := Replace ( mc_need_heal , base , [ ] ) ;
24074: LD_ADDR_EXP 83
24078: PUSH
24079: LD_EXP 83
24083: PPUSH
24084: LD_VAR 0 4
24088: PPUSH
24089: EMPTY
24090: PPUSH
24091: CALL_OW 1
24095: ST_TO_ADDR
// mc_healers := Replace ( mc_healers , base , [ ] ) ;
24096: LD_ADDR_EXP 84
24100: PUSH
24101: LD_EXP 84
24105: PPUSH
24106: LD_VAR 0 4
24110: PPUSH
24111: EMPTY
24112: PPUSH
24113: CALL_OW 1
24117: ST_TO_ADDR
// mc_build_list := Replace ( mc_build_list , base , [ ] ) ;
24118: LD_ADDR_EXP 85
24122: PUSH
24123: LD_EXP 85
24127: PPUSH
24128: LD_VAR 0 4
24132: PPUSH
24133: EMPTY
24134: PPUSH
24135: CALL_OW 1
24139: ST_TO_ADDR
// mc_builders := Replace ( mc_builders , base , [ ] ) ;
24140: LD_ADDR_EXP 86
24144: PUSH
24145: LD_EXP 86
24149: PPUSH
24150: LD_VAR 0 4
24154: PPUSH
24155: EMPTY
24156: PPUSH
24157: CALL_OW 1
24161: ST_TO_ADDR
// mc_construct_list := Replace ( mc_construct_list , base , [ ] ) ;
24162: LD_ADDR_EXP 87
24166: PUSH
24167: LD_EXP 87
24171: PPUSH
24172: LD_VAR 0 4
24176: PPUSH
24177: EMPTY
24178: PPUSH
24179: CALL_OW 1
24183: ST_TO_ADDR
// mc_turret_list := Replace ( mc_turret_list , base , [ ] ) ;
24184: LD_ADDR_EXP 88
24188: PUSH
24189: LD_EXP 88
24193: PPUSH
24194: LD_VAR 0 4
24198: PPUSH
24199: EMPTY
24200: PPUSH
24201: CALL_OW 1
24205: ST_TO_ADDR
// mc_empty_turret_list := Replace ( mc_empty_turret_list , base , [ ] ) ;
24206: LD_ADDR_EXP 89
24210: PUSH
24211: LD_EXP 89
24215: PPUSH
24216: LD_VAR 0 4
24220: PPUSH
24221: EMPTY
24222: PPUSH
24223: CALL_OW 1
24227: ST_TO_ADDR
// mc_busy_turret_list := Replace ( mc_busy_turret_list , base , [ ] ) ;
24228: LD_ADDR_EXP 90
24232: PUSH
24233: LD_EXP 90
24237: PPUSH
24238: LD_VAR 0 4
24242: PPUSH
24243: EMPTY
24244: PPUSH
24245: CALL_OW 1
24249: ST_TO_ADDR
// mc_defender_limit := Replace ( mc_defender_limit , base , 0 ) ;
24250: LD_ADDR_EXP 91
24254: PUSH
24255: LD_EXP 91
24259: PPUSH
24260: LD_VAR 0 4
24264: PPUSH
24265: LD_INT 0
24267: PPUSH
24268: CALL_OW 1
24272: ST_TO_ADDR
// mc_repair_vehicle := Replace ( mc_repair_vehicle , base , [ ] ) ;
24273: LD_ADDR_EXP 92
24277: PUSH
24278: LD_EXP 92
24282: PPUSH
24283: LD_VAR 0 4
24287: PPUSH
24288: EMPTY
24289: PPUSH
24290: CALL_OW 1
24294: ST_TO_ADDR
// mc_mines := Replace ( mc_mines , base , [ ] ) ;
24295: LD_ADDR_EXP 93
24299: PUSH
24300: LD_EXP 93
24304: PPUSH
24305: LD_VAR 0 4
24309: PPUSH
24310: EMPTY
24311: PPUSH
24312: CALL_OW 1
24316: ST_TO_ADDR
// mc_miners := Replace ( mc_miners , base , [ ] ) ;
24317: LD_ADDR_EXP 94
24321: PUSH
24322: LD_EXP 94
24326: PPUSH
24327: LD_VAR 0 4
24331: PPUSH
24332: EMPTY
24333: PPUSH
24334: CALL_OW 1
24338: ST_TO_ADDR
// mc_minefields := Replace ( mc_minefields , base , [ ] ) ;
24339: LD_ADDR_EXP 95
24343: PUSH
24344: LD_EXP 95
24348: PPUSH
24349: LD_VAR 0 4
24353: PPUSH
24354: EMPTY
24355: PPUSH
24356: CALL_OW 1
24360: ST_TO_ADDR
// mc_crates := Replace ( mc_crates , base , [ ] ) ;
24361: LD_ADDR_EXP 96
24365: PUSH
24366: LD_EXP 96
24370: PPUSH
24371: LD_VAR 0 4
24375: PPUSH
24376: EMPTY
24377: PPUSH
24378: CALL_OW 1
24382: ST_TO_ADDR
// mc_crates_collector := Replace ( mc_crates_collector , base , [ ] ) ;
24383: LD_ADDR_EXP 97
24387: PUSH
24388: LD_EXP 97
24392: PPUSH
24393: LD_VAR 0 4
24397: PPUSH
24398: EMPTY
24399: PPUSH
24400: CALL_OW 1
24404: ST_TO_ADDR
// mc_crates_area := Replace ( mc_crates_area , base , [ ] ) ;
24405: LD_ADDR_EXP 98
24409: PUSH
24410: LD_EXP 98
24414: PPUSH
24415: LD_VAR 0 4
24419: PPUSH
24420: EMPTY
24421: PPUSH
24422: CALL_OW 1
24426: ST_TO_ADDR
// mc_vehicles := Replace ( mc_vehicles , base , [ ] ) ;
24427: LD_ADDR_EXP 99
24431: PUSH
24432: LD_EXP 99
24436: PPUSH
24437: LD_VAR 0 4
24441: PPUSH
24442: EMPTY
24443: PPUSH
24444: CALL_OW 1
24448: ST_TO_ADDR
// mc_attack := Replace ( mc_attack , base , [ ] ) ;
24449: LD_ADDR_EXP 100
24453: PUSH
24454: LD_EXP 100
24458: PPUSH
24459: LD_VAR 0 4
24463: PPUSH
24464: EMPTY
24465: PPUSH
24466: CALL_OW 1
24470: ST_TO_ADDR
// mc_produce := Replace ( mc_produce , base , [ ] ) ;
24471: LD_ADDR_EXP 101
24475: PUSH
24476: LD_EXP 101
24480: PPUSH
24481: LD_VAR 0 4
24485: PPUSH
24486: EMPTY
24487: PPUSH
24488: CALL_OW 1
24492: ST_TO_ADDR
// mc_defender := Replace ( mc_defender , base , [ ] ) ;
24493: LD_ADDR_EXP 102
24497: PUSH
24498: LD_EXP 102
24502: PPUSH
24503: LD_VAR 0 4
24507: PPUSH
24508: EMPTY
24509: PPUSH
24510: CALL_OW 1
24514: ST_TO_ADDR
// mc_scan := Replace ( mc_scan , base , [ ] ) ;
24515: LD_ADDR_EXP 103
24519: PUSH
24520: LD_EXP 103
24524: PPUSH
24525: LD_VAR 0 4
24529: PPUSH
24530: EMPTY
24531: PPUSH
24532: CALL_OW 1
24536: ST_TO_ADDR
// mc_parking := Replace ( mc_parking , base , [ ] ) ;
24537: LD_ADDR_EXP 104
24541: PUSH
24542: LD_EXP 104
24546: PPUSH
24547: LD_VAR 0 4
24551: PPUSH
24552: EMPTY
24553: PPUSH
24554: CALL_OW 1
24558: ST_TO_ADDR
// mc_scan_area := Replace ( mc_scan_area , base , [ ] ) ;
24559: LD_ADDR_EXP 105
24563: PUSH
24564: LD_EXP 105
24568: PPUSH
24569: LD_VAR 0 4
24573: PPUSH
24574: EMPTY
24575: PPUSH
24576: CALL_OW 1
24580: ST_TO_ADDR
// mc_tech := Replace ( mc_tech , base , [ ] ) ;
24581: LD_ADDR_EXP 107
24585: PUSH
24586: LD_EXP 107
24590: PPUSH
24591: LD_VAR 0 4
24595: PPUSH
24596: EMPTY
24597: PPUSH
24598: CALL_OW 1
24602: ST_TO_ADDR
// mc_ape := Replace ( mc_ape , base , [ ] ) ;
24603: LD_ADDR_EXP 109
24607: PUSH
24608: LD_EXP 109
24612: PPUSH
24613: LD_VAR 0 4
24617: PPUSH
24618: EMPTY
24619: PPUSH
24620: CALL_OW 1
24624: ST_TO_ADDR
// mc_ape_in_lab := Replace ( mc_ape_in_lab , base , [ ] ) ;
24625: LD_ADDR_EXP 110
24629: PUSH
24630: LD_EXP 110
24634: PPUSH
24635: LD_VAR 0 4
24639: PPUSH
24640: EMPTY
24641: PPUSH
24642: CALL_OW 1
24646: ST_TO_ADDR
// mc_taming := Replace ( mc_taming , base , [ ] ) ;
24647: LD_ADDR_EXP 111
24651: PUSH
24652: LD_EXP 111
24656: PPUSH
24657: LD_VAR 0 4
24661: PPUSH
24662: EMPTY
24663: PPUSH
24664: CALL_OW 1
24668: ST_TO_ADDR
// mc_build_upgrade := Replace ( mc_build_upgrade , base , [ ] ) ;
24669: LD_ADDR_EXP 112
24673: PUSH
24674: LD_EXP 112
24678: PPUSH
24679: LD_VAR 0 4
24683: PPUSH
24684: EMPTY
24685: PPUSH
24686: CALL_OW 1
24690: ST_TO_ADDR
// mc_lab := Replace ( mc_lab , base , [ ] ) ;
24691: LD_ADDR_EXP 113
24695: PUSH
24696: LD_EXP 113
24700: PPUSH
24701: LD_VAR 0 4
24705: PPUSH
24706: EMPTY
24707: PPUSH
24708: CALL_OW 1
24712: ST_TO_ADDR
// mc_lab_upgrade := Replace ( mc_lab_upgrade , base , [ ] ) ;
24713: LD_ADDR_EXP 114
24717: PUSH
24718: LD_EXP 114
24722: PPUSH
24723: LD_VAR 0 4
24727: PPUSH
24728: EMPTY
24729: PPUSH
24730: CALL_OW 1
24734: ST_TO_ADDR
// mc_teleport_exit := Replace ( mc_teleport_exit , base , [ ] ) ;
24735: LD_ADDR_EXP 115
24739: PUSH
24740: LD_EXP 115
24744: PPUSH
24745: LD_VAR 0 4
24749: PPUSH
24750: EMPTY
24751: PPUSH
24752: CALL_OW 1
24756: ST_TO_ADDR
// mc_teleport_exit_set := Replace ( mc_teleport_exit_set , base , [ ] ) ;
24757: LD_ADDR_EXP 116
24761: PUSH
24762: LD_EXP 116
24766: PPUSH
24767: LD_VAR 0 4
24771: PPUSH
24772: EMPTY
24773: PPUSH
24774: CALL_OW 1
24778: ST_TO_ADDR
// mc_deposits_xy := Replace ( mc_deposits_xy , base , [ ] ) ;
24779: LD_ADDR_EXP 117
24783: PUSH
24784: LD_EXP 117
24788: PPUSH
24789: LD_VAR 0 4
24793: PPUSH
24794: EMPTY
24795: PPUSH
24796: CALL_OW 1
24800: ST_TO_ADDR
// mc_deposits_finder := Replace ( mc_deposits_finder , base , [ ] ) ;
24801: LD_ADDR_EXP 118
24805: PUSH
24806: LD_EXP 118
24810: PPUSH
24811: LD_VAR 0 4
24815: PPUSH
24816: EMPTY
24817: PPUSH
24818: CALL_OW 1
24822: ST_TO_ADDR
// mc_allowed_tower_weapons := Replace ( mc_allowed_tower_weapons , base , [ ] ) ;
24823: LD_ADDR_EXP 119
24827: PUSH
24828: LD_EXP 119
24832: PPUSH
24833: LD_VAR 0 4
24837: PPUSH
24838: EMPTY
24839: PPUSH
24840: CALL_OW 1
24844: ST_TO_ADDR
// mc_remote_driver := Replace ( mc_remote_driver , base , [ ] ) ;
24845: LD_ADDR_EXP 120
24849: PUSH
24850: LD_EXP 120
24854: PPUSH
24855: LD_VAR 0 4
24859: PPUSH
24860: EMPTY
24861: PPUSH
24862: CALL_OW 1
24866: ST_TO_ADDR
// mc_class := Replace ( mc_class , base , [ ] ) ;
24867: LD_ADDR_EXP 121
24871: PUSH
24872: LD_EXP 121
24876: PPUSH
24877: LD_VAR 0 4
24881: PPUSH
24882: EMPTY
24883: PPUSH
24884: CALL_OW 1
24888: ST_TO_ADDR
// mc_class_case_use := Replace ( mc_class_case_use , base , 0 ) ;
24889: LD_ADDR_EXP 122
24893: PUSH
24894: LD_EXP 122
24898: PPUSH
24899: LD_VAR 0 4
24903: PPUSH
24904: LD_INT 0
24906: PPUSH
24907: CALL_OW 1
24911: ST_TO_ADDR
// mc_is_defending := Replace ( mc_is_defending , base , false ) ;
24912: LD_ADDR_EXP 123
24916: PUSH
24917: LD_EXP 123
24921: PPUSH
24922: LD_VAR 0 4
24926: PPUSH
24927: LD_INT 0
24929: PPUSH
24930: CALL_OW 1
24934: ST_TO_ADDR
// result := base ;
24935: LD_ADDR_VAR 0 3
24939: PUSH
24940: LD_VAR 0 4
24944: ST_TO_ADDR
// end ;
24945: LD_VAR 0 3
24949: RET
// export function MC_Start ( ) ; var i ; begin
24950: LD_INT 0
24952: PPUSH
24953: PPUSH
// for i = 1 to mc_bases do
24954: LD_ADDR_VAR 0 2
24958: PUSH
24959: DOUBLE
24960: LD_INT 1
24962: DEC
24963: ST_TO_ADDR
24964: LD_EXP 80
24968: PUSH
24969: FOR_TO
24970: IFFALSE 26070
// begin mc_bases := Replace ( mc_bases , i , mc_bases [ i ] diff 0 ) ;
24972: LD_ADDR_EXP 80
24976: PUSH
24977: LD_EXP 80
24981: PPUSH
24982: LD_VAR 0 2
24986: PPUSH
24987: LD_EXP 80
24991: PUSH
24992: LD_VAR 0 2
24996: ARRAY
24997: PUSH
24998: LD_INT 0
25000: DIFF
25001: PPUSH
25002: CALL_OW 1
25006: ST_TO_ADDR
// mc_building_need_repair := Replace ( mc_building_need_repair , i , [ ] ) ;
25007: LD_ADDR_EXP 81
25011: PUSH
25012: LD_EXP 81
25016: PPUSH
25017: LD_VAR 0 2
25021: PPUSH
25022: EMPTY
25023: PPUSH
25024: CALL_OW 1
25028: ST_TO_ADDR
// mc_building_repairs := Replace ( mc_building_repairs , i , [ ] ) ;
25029: LD_ADDR_EXP 82
25033: PUSH
25034: LD_EXP 82
25038: PPUSH
25039: LD_VAR 0 2
25043: PPUSH
25044: EMPTY
25045: PPUSH
25046: CALL_OW 1
25050: ST_TO_ADDR
// mc_need_heal := Replace ( mc_need_heal , i , [ ] ) ;
25051: LD_ADDR_EXP 83
25055: PUSH
25056: LD_EXP 83
25060: PPUSH
25061: LD_VAR 0 2
25065: PPUSH
25066: EMPTY
25067: PPUSH
25068: CALL_OW 1
25072: ST_TO_ADDR
// mc_healers := Replace ( mc_healers , i , [ [ ] , [ ] ] ) ;
25073: LD_ADDR_EXP 84
25077: PUSH
25078: LD_EXP 84
25082: PPUSH
25083: LD_VAR 0 2
25087: PPUSH
25088: EMPTY
25089: PUSH
25090: EMPTY
25091: PUSH
25092: EMPTY
25093: LIST
25094: LIST
25095: PPUSH
25096: CALL_OW 1
25100: ST_TO_ADDR
// mc_build_list := Replace ( mc_build_list , i , [ ] ) ;
25101: LD_ADDR_EXP 85
25105: PUSH
25106: LD_EXP 85
25110: PPUSH
25111: LD_VAR 0 2
25115: PPUSH
25116: EMPTY
25117: PPUSH
25118: CALL_OW 1
25122: ST_TO_ADDR
// mc_build_upgrade := Replace ( mc_build_upgrade , i , [ ] ) ;
25123: LD_ADDR_EXP 112
25127: PUSH
25128: LD_EXP 112
25132: PPUSH
25133: LD_VAR 0 2
25137: PPUSH
25138: EMPTY
25139: PPUSH
25140: CALL_OW 1
25144: ST_TO_ADDR
// mc_builders := Replace ( mc_builders , i , [ ] ) ;
25145: LD_ADDR_EXP 86
25149: PUSH
25150: LD_EXP 86
25154: PPUSH
25155: LD_VAR 0 2
25159: PPUSH
25160: EMPTY
25161: PPUSH
25162: CALL_OW 1
25166: ST_TO_ADDR
// mc_construct_list := Replace ( mc_construct_list , i , [ ] ) ;
25167: LD_ADDR_EXP 87
25171: PUSH
25172: LD_EXP 87
25176: PPUSH
25177: LD_VAR 0 2
25181: PPUSH
25182: EMPTY
25183: PPUSH
25184: CALL_OW 1
25188: ST_TO_ADDR
// mc_turret_list := Replace ( mc_turret_list , i , UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_bunker ] , [ f_btype , b_turret ] ] ) ) ;
25189: LD_ADDR_EXP 88
25193: PUSH
25194: LD_EXP 88
25198: PPUSH
25199: LD_VAR 0 2
25203: PPUSH
25204: LD_EXP 80
25208: PUSH
25209: LD_VAR 0 2
25213: ARRAY
25214: PPUSH
25215: LD_INT 2
25217: PUSH
25218: LD_INT 30
25220: PUSH
25221: LD_INT 32
25223: PUSH
25224: EMPTY
25225: LIST
25226: LIST
25227: PUSH
25228: LD_INT 30
25230: PUSH
25231: LD_INT 33
25233: PUSH
25234: EMPTY
25235: LIST
25236: LIST
25237: PUSH
25238: EMPTY
25239: LIST
25240: LIST
25241: LIST
25242: PPUSH
25243: CALL_OW 72
25247: PPUSH
25248: CALL_OW 1
25252: ST_TO_ADDR
// mc_empty_turret_list := Replace ( mc_empty_turret_list , i , UnitFilter ( mc_bases [ i ] , [ [ f_or , [ f_btype , b_bunker ] , [ f_btype , b_breastwork ] ] , [ f_empty ] ] ) ) ;
25253: LD_ADDR_EXP 89
25257: PUSH
25258: LD_EXP 89
25262: PPUSH
25263: LD_VAR 0 2
25267: PPUSH
25268: LD_EXP 80
25272: PUSH
25273: LD_VAR 0 2
25277: ARRAY
25278: PPUSH
25279: LD_INT 2
25281: PUSH
25282: LD_INT 30
25284: PUSH
25285: LD_INT 32
25287: PUSH
25288: EMPTY
25289: LIST
25290: LIST
25291: PUSH
25292: LD_INT 30
25294: PUSH
25295: LD_INT 31
25297: PUSH
25298: EMPTY
25299: LIST
25300: LIST
25301: PUSH
25302: EMPTY
25303: LIST
25304: LIST
25305: LIST
25306: PUSH
25307: LD_INT 58
25309: PUSH
25310: EMPTY
25311: LIST
25312: PUSH
25313: EMPTY
25314: LIST
25315: LIST
25316: PPUSH
25317: CALL_OW 72
25321: PPUSH
25322: CALL_OW 1
25326: ST_TO_ADDR
// mc_busy_turret_list := Replace ( mc_busy_turret_list , i , [ ] ) ;
25327: LD_ADDR_EXP 90
25331: PUSH
25332: LD_EXP 90
25336: PPUSH
25337: LD_VAR 0 2
25341: PPUSH
25342: EMPTY
25343: PPUSH
25344: CALL_OW 1
25348: ST_TO_ADDR
// mc_miners := Replace ( mc_miners , i , [ ] ) ;
25349: LD_ADDR_EXP 94
25353: PUSH
25354: LD_EXP 94
25358: PPUSH
25359: LD_VAR 0 2
25363: PPUSH
25364: EMPTY
25365: PPUSH
25366: CALL_OW 1
25370: ST_TO_ADDR
// mc_mines := Replace ( mc_mines , i , [ ] ) ;
25371: LD_ADDR_EXP 93
25375: PUSH
25376: LD_EXP 93
25380: PPUSH
25381: LD_VAR 0 2
25385: PPUSH
25386: EMPTY
25387: PPUSH
25388: CALL_OW 1
25392: ST_TO_ADDR
// mc_minefields := Replace ( mc_minefields , i , [ ] ) ;
25393: LD_ADDR_EXP 95
25397: PUSH
25398: LD_EXP 95
25402: PPUSH
25403: LD_VAR 0 2
25407: PPUSH
25408: EMPTY
25409: PPUSH
25410: CALL_OW 1
25414: ST_TO_ADDR
// mc_crates := Replace ( mc_crates , i , [ ] ) ;
25415: LD_ADDR_EXP 96
25419: PUSH
25420: LD_EXP 96
25424: PPUSH
25425: LD_VAR 0 2
25429: PPUSH
25430: EMPTY
25431: PPUSH
25432: CALL_OW 1
25436: ST_TO_ADDR
// mc_crates_collector := Replace ( mc_crates_collector , i , [ ] ) ;
25437: LD_ADDR_EXP 97
25441: PUSH
25442: LD_EXP 97
25446: PPUSH
25447: LD_VAR 0 2
25451: PPUSH
25452: EMPTY
25453: PPUSH
25454: CALL_OW 1
25458: ST_TO_ADDR
// mc_crates_area := Replace ( mc_crates_area , i , [ ] ) ;
25459: LD_ADDR_EXP 98
25463: PUSH
25464: LD_EXP 98
25468: PPUSH
25469: LD_VAR 0 2
25473: PPUSH
25474: EMPTY
25475: PPUSH
25476: CALL_OW 1
25480: ST_TO_ADDR
// mc_vehicles := Replace ( mc_vehicles , i , [ ] ) ;
25481: LD_ADDR_EXP 99
25485: PUSH
25486: LD_EXP 99
25490: PPUSH
25491: LD_VAR 0 2
25495: PPUSH
25496: EMPTY
25497: PPUSH
25498: CALL_OW 1
25502: ST_TO_ADDR
// mc_attack := Replace ( mc_attack , i , [ ] ) ;
25503: LD_ADDR_EXP 100
25507: PUSH
25508: LD_EXP 100
25512: PPUSH
25513: LD_VAR 0 2
25517: PPUSH
25518: EMPTY
25519: PPUSH
25520: CALL_OW 1
25524: ST_TO_ADDR
// mc_produce := Replace ( mc_produce , i , [ ] ) ;
25525: LD_ADDR_EXP 101
25529: PUSH
25530: LD_EXP 101
25534: PPUSH
25535: LD_VAR 0 2
25539: PPUSH
25540: EMPTY
25541: PPUSH
25542: CALL_OW 1
25546: ST_TO_ADDR
// mc_defender := Replace ( mc_defender , i , [ ] ) ;
25547: LD_ADDR_EXP 102
25551: PUSH
25552: LD_EXP 102
25556: PPUSH
25557: LD_VAR 0 2
25561: PPUSH
25562: EMPTY
25563: PPUSH
25564: CALL_OW 1
25568: ST_TO_ADDR
// mc_defender_limit := Replace ( mc_defender_limit , i , 0 ) ;
25569: LD_ADDR_EXP 91
25573: PUSH
25574: LD_EXP 91
25578: PPUSH
25579: LD_VAR 0 2
25583: PPUSH
25584: LD_INT 0
25586: PPUSH
25587: CALL_OW 1
25591: ST_TO_ADDR
// mc_parking := Replace ( mc_parking , i , 0 ) ;
25592: LD_ADDR_EXP 104
25596: PUSH
25597: LD_EXP 104
25601: PPUSH
25602: LD_VAR 0 2
25606: PPUSH
25607: LD_INT 0
25609: PPUSH
25610: CALL_OW 1
25614: ST_TO_ADDR
// mc_repair_vehicle := Replace ( mc_repair_vehicle , i , [ ] ) ;
25615: LD_ADDR_EXP 92
25619: PUSH
25620: LD_EXP 92
25624: PPUSH
25625: LD_VAR 0 2
25629: PPUSH
25630: EMPTY
25631: PPUSH
25632: CALL_OW 1
25636: ST_TO_ADDR
// mc_scan := Replace ( mc_scan , i , 0 ) ;
25637: LD_ADDR_EXP 103
25641: PUSH
25642: LD_EXP 103
25646: PPUSH
25647: LD_VAR 0 2
25651: PPUSH
25652: LD_INT 0
25654: PPUSH
25655: CALL_OW 1
25659: ST_TO_ADDR
// mc_scan_area := Replace ( mc_scan_area , i , [ ] ) ;
25660: LD_ADDR_EXP 105
25664: PUSH
25665: LD_EXP 105
25669: PPUSH
25670: LD_VAR 0 2
25674: PPUSH
25675: EMPTY
25676: PPUSH
25677: CALL_OW 1
25681: ST_TO_ADDR
// mc_can_tame := Replace ( mc_can_tame , i , 0 ) ;
25682: LD_ADDR_EXP 108
25686: PUSH
25687: LD_EXP 108
25691: PPUSH
25692: LD_VAR 0 2
25696: PPUSH
25697: LD_INT 0
25699: PPUSH
25700: CALL_OW 1
25704: ST_TO_ADDR
// mc_ape := Replace ( mc_ape , i , [ ] ) ;
25705: LD_ADDR_EXP 109
25709: PUSH
25710: LD_EXP 109
25714: PPUSH
25715: LD_VAR 0 2
25719: PPUSH
25720: EMPTY
25721: PPUSH
25722: CALL_OW 1
25726: ST_TO_ADDR
// mc_ape_in_lab := Replace ( mc_ape_in_lab , i , [ ] ) ;
25727: LD_ADDR_EXP 110
25731: PUSH
25732: LD_EXP 110
25736: PPUSH
25737: LD_VAR 0 2
25741: PPUSH
25742: EMPTY
25743: PPUSH
25744: CALL_OW 1
25748: ST_TO_ADDR
// mc_taming := Replace ( mc_taming , i , [ ] ) ;
25749: LD_ADDR_EXP 111
25753: PUSH
25754: LD_EXP 111
25758: PPUSH
25759: LD_VAR 0 2
25763: PPUSH
25764: EMPTY
25765: PPUSH
25766: CALL_OW 1
25770: ST_TO_ADDR
// mc_lab := Replace ( mc_lab , i , UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_lab ] , [ f_btype , b_lab_half ] , [ f_btype , b_lab_full ] ] ) ) ;
25771: LD_ADDR_EXP 113
25775: PUSH
25776: LD_EXP 113
25780: PPUSH
25781: LD_VAR 0 2
25785: PPUSH
25786: LD_EXP 80
25790: PUSH
25791: LD_VAR 0 2
25795: ARRAY
25796: PPUSH
25797: LD_INT 2
25799: PUSH
25800: LD_INT 30
25802: PUSH
25803: LD_INT 6
25805: PUSH
25806: EMPTY
25807: LIST
25808: LIST
25809: PUSH
25810: LD_INT 30
25812: PUSH
25813: LD_INT 7
25815: PUSH
25816: EMPTY
25817: LIST
25818: LIST
25819: PUSH
25820: LD_INT 30
25822: PUSH
25823: LD_INT 8
25825: PUSH
25826: EMPTY
25827: LIST
25828: LIST
25829: PUSH
25830: EMPTY
25831: LIST
25832: LIST
25833: LIST
25834: LIST
25835: PPUSH
25836: CALL_OW 72
25840: PPUSH
25841: CALL_OW 1
25845: ST_TO_ADDR
// mc_lab_upgrade := Replace ( mc_lab_upgrade , i , [ ] ) ;
25846: LD_ADDR_EXP 114
25850: PUSH
25851: LD_EXP 114
25855: PPUSH
25856: LD_VAR 0 2
25860: PPUSH
25861: EMPTY
25862: PPUSH
25863: CALL_OW 1
25867: ST_TO_ADDR
// mc_teleport_exit := Replace ( mc_teleport_exit , i , [ ] ) ;
25868: LD_ADDR_EXP 115
25872: PUSH
25873: LD_EXP 115
25877: PPUSH
25878: LD_VAR 0 2
25882: PPUSH
25883: EMPTY
25884: PPUSH
25885: CALL_OW 1
25889: ST_TO_ADDR
// mc_teleport_exit_set := Replace ( mc_teleport_exit_set , i , [ ] ) ;
25890: LD_ADDR_EXP 116
25894: PUSH
25895: LD_EXP 116
25899: PPUSH
25900: LD_VAR 0 2
25904: PPUSH
25905: EMPTY
25906: PPUSH
25907: CALL_OW 1
25911: ST_TO_ADDR
// mc_deposits_xy := Replace ( mc_deposits_xy , i , [ ] ) ;
25912: LD_ADDR_EXP 117
25916: PUSH
25917: LD_EXP 117
25921: PPUSH
25922: LD_VAR 0 2
25926: PPUSH
25927: EMPTY
25928: PPUSH
25929: CALL_OW 1
25933: ST_TO_ADDR
// mc_deposits_finder := Replace ( mc_deposits_finder , i , [ ] ) ;
25934: LD_ADDR_EXP 118
25938: PUSH
25939: LD_EXP 118
25943: PPUSH
25944: LD_VAR 0 2
25948: PPUSH
25949: EMPTY
25950: PPUSH
25951: CALL_OW 1
25955: ST_TO_ADDR
// mc_allowed_tower_weapons := Replace ( mc_allowed_tower_weapons , i , [ ] ) ;
25956: LD_ADDR_EXP 119
25960: PUSH
25961: LD_EXP 119
25965: PPUSH
25966: LD_VAR 0 2
25970: PPUSH
25971: EMPTY
25972: PPUSH
25973: CALL_OW 1
25977: ST_TO_ADDR
// mc_remote_driver := Replace ( mc_remote_driver , i , [ ] ) ;
25978: LD_ADDR_EXP 120
25982: PUSH
25983: LD_EXP 120
25987: PPUSH
25988: LD_VAR 0 2
25992: PPUSH
25993: EMPTY
25994: PPUSH
25995: CALL_OW 1
25999: ST_TO_ADDR
// mc_class := Replace ( mc_class , i , [ ] ) ;
26000: LD_ADDR_EXP 121
26004: PUSH
26005: LD_EXP 121
26009: PPUSH
26010: LD_VAR 0 2
26014: PPUSH
26015: EMPTY
26016: PPUSH
26017: CALL_OW 1
26021: ST_TO_ADDR
// mc_class_case_use := Replace ( mc_class_case_use , i , 0 ) ;
26022: LD_ADDR_EXP 122
26026: PUSH
26027: LD_EXP 122
26031: PPUSH
26032: LD_VAR 0 2
26036: PPUSH
26037: LD_INT 0
26039: PPUSH
26040: CALL_OW 1
26044: ST_TO_ADDR
// mc_is_defending := Replace ( mc_is_defending , i , false ) ;
26045: LD_ADDR_EXP 123
26049: PUSH
26050: LD_EXP 123
26054: PPUSH
26055: LD_VAR 0 2
26059: PPUSH
26060: LD_INT 0
26062: PPUSH
26063: CALL_OW 1
26067: ST_TO_ADDR
// end ;
26068: GO 24969
26070: POP
26071: POP
// MC_InitSides ( ) ;
26072: CALL 26358 0 0
// MC_InitResearch ( ) ;
26076: CALL 26097 0 0
// CustomInitMacro ( ) ;
26080: CALL 252 0 0
// skirmish := true ;
26084: LD_ADDR_EXP 78
26088: PUSH
26089: LD_INT 1
26091: ST_TO_ADDR
// end ;
26092: LD_VAR 0 1
26096: RET
// export function MC_InitResearch ( ) ; var i , j , nation , tmp , un ; begin
26097: LD_INT 0
26099: PPUSH
26100: PPUSH
26101: PPUSH
26102: PPUSH
26103: PPUSH
26104: PPUSH
// if not mc_bases then
26105: LD_EXP 80
26109: NOT
26110: IFFALSE 26114
// exit ;
26112: GO 26353
// for i = 1 to 8 do
26114: LD_ADDR_VAR 0 2
26118: PUSH
26119: DOUBLE
26120: LD_INT 1
26122: DEC
26123: ST_TO_ADDR
26124: LD_INT 8
26126: PUSH
26127: FOR_TO
26128: IFFALSE 26154
// mc_tech := Replace ( mc_tech , i , [ ] ) ;
26130: LD_ADDR_EXP 107
26134: PUSH
26135: LD_EXP 107
26139: PPUSH
26140: LD_VAR 0 2
26144: PPUSH
26145: EMPTY
26146: PPUSH
26147: CALL_OW 1
26151: ST_TO_ADDR
26152: GO 26127
26154: POP
26155: POP
// tmp := [ ] ;
26156: LD_ADDR_VAR 0 5
26160: PUSH
26161: EMPTY
26162: ST_TO_ADDR
// for i = 1 to mc_sides do
26163: LD_ADDR_VAR 0 2
26167: PUSH
26168: DOUBLE
26169: LD_INT 1
26171: DEC
26172: ST_TO_ADDR
26173: LD_EXP 106
26177: PUSH
26178: FOR_TO
26179: IFFALSE 26237
// if not mc_sides [ i ] in tmp then
26181: LD_EXP 106
26185: PUSH
26186: LD_VAR 0 2
26190: ARRAY
26191: PUSH
26192: LD_VAR 0 5
26196: IN
26197: NOT
26198: IFFALSE 26235
// tmp := Insert ( tmp , tmp + 1 , mc_sides [ i ] ) ;
26200: LD_ADDR_VAR 0 5
26204: PUSH
26205: LD_VAR 0 5
26209: PPUSH
26210: LD_VAR 0 5
26214: PUSH
26215: LD_INT 1
26217: PLUS
26218: PPUSH
26219: LD_EXP 106
26223: PUSH
26224: LD_VAR 0 2
26228: ARRAY
26229: PPUSH
26230: CALL_OW 2
26234: ST_TO_ADDR
26235: GO 26178
26237: POP
26238: POP
// if not tmp then
26239: LD_VAR 0 5
26243: NOT
26244: IFFALSE 26248
// exit ;
26246: GO 26353
// for j in tmp do
26248: LD_ADDR_VAR 0 3
26252: PUSH
26253: LD_VAR 0 5
26257: PUSH
26258: FOR_IN
26259: IFFALSE 26351
// begin un := FilterAllUnits ( [ f_side , j ] ) ;
26261: LD_ADDR_VAR 0 6
26265: PUSH
26266: LD_INT 22
26268: PUSH
26269: LD_VAR 0 3
26273: PUSH
26274: EMPTY
26275: LIST
26276: LIST
26277: PPUSH
26278: CALL_OW 69
26282: ST_TO_ADDR
// if not un then
26283: LD_VAR 0 6
26287: NOT
26288: IFFALSE 26292
// continue ;
26290: GO 26258
// nation := GetNation ( un [ 1 ] ) ;
26292: LD_ADDR_VAR 0 4
26296: PUSH
26297: LD_VAR 0 6
26301: PUSH
26302: LD_INT 1
26304: ARRAY
26305: PPUSH
26306: CALL_OW 248
26310: ST_TO_ADDR
// mc_tech := Replace ( mc_tech , j , GetTechNation ( j , nation , state_enabled ) ) ;
26311: LD_ADDR_EXP 107
26315: PUSH
26316: LD_EXP 107
26320: PPUSH
26321: LD_VAR 0 3
26325: PPUSH
26326: LD_VAR 0 3
26330: PPUSH
26331: LD_VAR 0 4
26335: PPUSH
26336: LD_INT 1
26338: PPUSH
26339: CALL 53541 0 3
26343: PPUSH
26344: CALL_OW 1
26348: ST_TO_ADDR
// end ;
26349: GO 26258
26351: POP
26352: POP
// end ;
26353: LD_VAR 0 1
26357: RET
// export function MC_InitSides ( ) ; var i ; begin
26358: LD_INT 0
26360: PPUSH
26361: PPUSH
// if not mc_bases then
26362: LD_EXP 80
26366: NOT
26367: IFFALSE 26371
// exit ;
26369: GO 26445
// for i = 1 to mc_bases do
26371: LD_ADDR_VAR 0 2
26375: PUSH
26376: DOUBLE
26377: LD_INT 1
26379: DEC
26380: ST_TO_ADDR
26381: LD_EXP 80
26385: PUSH
26386: FOR_TO
26387: IFFALSE 26443
// if mc_bases [ i ] then
26389: LD_EXP 80
26393: PUSH
26394: LD_VAR 0 2
26398: ARRAY
26399: IFFALSE 26441
// mc_sides := Replace ( mc_sides , i , GetSide ( mc_bases [ i ] [ 1 ] ) ) ;
26401: LD_ADDR_EXP 106
26405: PUSH
26406: LD_EXP 106
26410: PPUSH
26411: LD_VAR 0 2
26415: PPUSH
26416: LD_EXP 80
26420: PUSH
26421: LD_VAR 0 2
26425: ARRAY
26426: PUSH
26427: LD_INT 1
26429: ARRAY
26430: PPUSH
26431: CALL_OW 255
26435: PPUSH
26436: CALL_OW 1
26440: ST_TO_ADDR
26441: GO 26386
26443: POP
26444: POP
// end ;
26445: LD_VAR 0 1
26449: RET
// every 0 0$03 trigger skirmish do
26450: LD_EXP 78
26454: IFFALSE 26608
26456: GO 26458
26458: DISABLE
// begin enable ;
26459: ENABLE
// MC_CheckBuildings ( ) ;
26460: CALL 31120 0 0
// MC_CheckPeopleLife ( ) ;
26464: CALL 31281 0 0
// RaiseSailEvent ( 100 ) ;
26468: LD_INT 100
26470: PPUSH
26471: CALL_OW 427
// RaiseSailEvent ( 103 ) ;
26475: LD_INT 103
26477: PPUSH
26478: CALL_OW 427
// RaiseSailEvent ( 104 ) ;
26482: LD_INT 104
26484: PPUSH
26485: CALL_OW 427
// RaiseSailEvent ( 105 ) ;
26489: LD_INT 105
26491: PPUSH
26492: CALL_OW 427
// RaiseSailEvent ( 106 ) ;
26496: LD_INT 106
26498: PPUSH
26499: CALL_OW 427
// RaiseSailEvent ( 107 ) ;
26503: LD_INT 107
26505: PPUSH
26506: CALL_OW 427
// RaiseSailEvent ( 108 ) ;
26510: LD_INT 108
26512: PPUSH
26513: CALL_OW 427
// RaiseSailEvent ( 109 ) ;
26517: LD_INT 109
26519: PPUSH
26520: CALL_OW 427
// RaiseSailEvent ( 110 ) ;
26524: LD_INT 110
26526: PPUSH
26527: CALL_OW 427
// RaiseSailEvent ( 111 ) ;
26531: LD_INT 111
26533: PPUSH
26534: CALL_OW 427
// RaiseSailEvent ( 112 ) ;
26538: LD_INT 112
26540: PPUSH
26541: CALL_OW 427
// RaiseSailEvent ( 113 ) ;
26545: LD_INT 113
26547: PPUSH
26548: CALL_OW 427
// RaiseSailEvent ( 120 ) ;
26552: LD_INT 120
26554: PPUSH
26555: CALL_OW 427
// RaiseSailEvent ( 121 ) ;
26559: LD_INT 121
26561: PPUSH
26562: CALL_OW 427
// RaiseSailEvent ( 122 ) ;
26566: LD_INT 122
26568: PPUSH
26569: CALL_OW 427
// RaiseSailEvent ( 123 ) ;
26573: LD_INT 123
26575: PPUSH
26576: CALL_OW 427
// RaiseSailEvent ( 124 ) ;
26580: LD_INT 124
26582: PPUSH
26583: CALL_OW 427
// RaiseSailEvent ( 125 ) ;
26587: LD_INT 125
26589: PPUSH
26590: CALL_OW 427
// RaiseSailEvent ( 126 ) ;
26594: LD_INT 126
26596: PPUSH
26597: CALL_OW 427
// RaiseSailEvent ( 200 ) ;
26601: LD_INT 200
26603: PPUSH
26604: CALL_OW 427
// end ;
26608: END
// on SailEvent ( event ) do begin if event < 100 then
26609: LD_VAR 0 1
26613: PUSH
26614: LD_INT 100
26616: LESS
26617: IFFALSE 26628
// CustomEvent ( event ) ;
26619: LD_VAR 0 1
26623: PPUSH
26624: CALL 11739 0 1
// if event = 100 then
26628: LD_VAR 0 1
26632: PUSH
26633: LD_INT 100
26635: EQUAL
26636: IFFALSE 26642
// MC_ClassManager ( ) ;
26638: CALL 27034 0 0
// if event = 101 then
26642: LD_VAR 0 1
26646: PUSH
26647: LD_INT 101
26649: EQUAL
26650: IFFALSE 26656
// MC_RepairBuildings ( ) ;
26652: CALL 31866 0 0
// if event = 102 then
26656: LD_VAR 0 1
26660: PUSH
26661: LD_INT 102
26663: EQUAL
26664: IFFALSE 26670
// MC_Heal ( ) ;
26666: CALL 32801 0 0
// if event = 103 then
26670: LD_VAR 0 1
26674: PUSH
26675: LD_INT 103
26677: EQUAL
26678: IFFALSE 26684
// MC_Build ( ) ;
26680: CALL 33223 0 0
// if event = 104 then
26684: LD_VAR 0 1
26688: PUSH
26689: LD_INT 104
26691: EQUAL
26692: IFFALSE 26698
// MC_TurretWeapon ( ) ;
26694: CALL 34857 0 0
// if event = 105 then
26698: LD_VAR 0 1
26702: PUSH
26703: LD_INT 105
26705: EQUAL
26706: IFFALSE 26712
// MC_BuildUpgrade ( ) ;
26708: CALL 34408 0 0
// if event = 106 then
26712: LD_VAR 0 1
26716: PUSH
26717: LD_INT 106
26719: EQUAL
26720: IFFALSE 26726
// MC_PlantMines ( ) ;
26722: CALL 35287 0 0
// if event = 107 then
26726: LD_VAR 0 1
26730: PUSH
26731: LD_INT 107
26733: EQUAL
26734: IFFALSE 26740
// MC_CollectCrates ( ) ;
26736: CALL 36085 0 0
// if event = 108 then
26740: LD_VAR 0 1
26744: PUSH
26745: LD_INT 108
26747: EQUAL
26748: IFFALSE 26754
// MC_LinkRemoteControl ( ) ;
26750: CALL 37935 0 0
// if event = 109 then
26754: LD_VAR 0 1
26758: PUSH
26759: LD_INT 109
26761: EQUAL
26762: IFFALSE 26768
// MC_ProduceVehicle ( ) ;
26764: CALL 38116 0 0
// if event = 110 then
26768: LD_VAR 0 1
26772: PUSH
26773: LD_INT 110
26775: EQUAL
26776: IFFALSE 26782
// MC_SendAttack ( ) ;
26778: CALL 38582 0 0
// if event = 111 then
26782: LD_VAR 0 1
26786: PUSH
26787: LD_INT 111
26789: EQUAL
26790: IFFALSE 26796
// MC_Defend ( ) ;
26792: CALL 38690 0 0
// if event = 112 then
26796: LD_VAR 0 1
26800: PUSH
26801: LD_INT 112
26803: EQUAL
26804: IFFALSE 26810
// MC_Research ( ) ;
26806: CALL 39570 0 0
// if event = 113 then
26810: LD_VAR 0 1
26814: PUSH
26815: LD_INT 113
26817: EQUAL
26818: IFFALSE 26824
// MC_MinesTrigger ( ) ;
26820: CALL 40684 0 0
// if event = 120 then
26824: LD_VAR 0 1
26828: PUSH
26829: LD_INT 120
26831: EQUAL
26832: IFFALSE 26838
// MC_RepairVehicle ( ) ;
26834: CALL 40783 0 0
// if event = 121 then
26838: LD_VAR 0 1
26842: PUSH
26843: LD_INT 121
26845: EQUAL
26846: IFFALSE 26852
// MC_TameApe ( ) ;
26848: CALL 41552 0 0
// if event = 122 then
26852: LD_VAR 0 1
26856: PUSH
26857: LD_INT 122
26859: EQUAL
26860: IFFALSE 26866
// MC_ChangeApeClass ( ) ;
26862: CALL 42381 0 0
// if event = 123 then
26866: LD_VAR 0 1
26870: PUSH
26871: LD_INT 123
26873: EQUAL
26874: IFFALSE 26880
// MC_Bazooka ( ) ;
26876: CALL 43031 0 0
// if event = 124 then
26880: LD_VAR 0 1
26884: PUSH
26885: LD_INT 124
26887: EQUAL
26888: IFFALSE 26894
// MC_TeleportExit ( ) ;
26890: CALL 43229 0 0
// if event = 125 then
26894: LD_VAR 0 1
26898: PUSH
26899: LD_INT 125
26901: EQUAL
26902: IFFALSE 26908
// MC_Deposits ( ) ;
26904: CALL 43876 0 0
// if event = 126 then
26908: LD_VAR 0 1
26912: PUSH
26913: LD_INT 126
26915: EQUAL
26916: IFFALSE 26922
// MC_RemoteDriver ( ) ;
26918: CALL 44501 0 0
// if event = 200 then
26922: LD_VAR 0 1
26926: PUSH
26927: LD_INT 200
26929: EQUAL
26930: IFFALSE 26936
// MC_Idle ( ) ;
26932: CALL 46408 0 0
// end ;
26936: PPOPN 1
26938: END
// export function MC_Reset ( base , tag ) ; var i ; begin
26939: LD_INT 0
26941: PPUSH
26942: PPUSH
// if not mc_bases [ base ] or not tag then
26943: LD_EXP 80
26947: PUSH
26948: LD_VAR 0 1
26952: ARRAY
26953: NOT
26954: PUSH
26955: LD_VAR 0 2
26959: NOT
26960: OR
26961: IFFALSE 26965
// exit ;
26963: GO 27029
// for i in mc_bases [ base ] union mc_ape [ base ] do
26965: LD_ADDR_VAR 0 4
26969: PUSH
26970: LD_EXP 80
26974: PUSH
26975: LD_VAR 0 1
26979: ARRAY
26980: PUSH
26981: LD_EXP 109
26985: PUSH
26986: LD_VAR 0 1
26990: ARRAY
26991: UNION
26992: PUSH
26993: FOR_IN
26994: IFFALSE 27027
// if GetTag ( i ) = tag then
26996: LD_VAR 0 4
27000: PPUSH
27001: CALL_OW 110
27005: PUSH
27006: LD_VAR 0 2
27010: EQUAL
27011: IFFALSE 27025
// SetTag ( i , 0 ) ;
27013: LD_VAR 0 4
27017: PPUSH
27018: LD_INT 0
27020: PPUSH
27021: CALL_OW 109
27025: GO 26993
27027: POP
27028: POP
// end ;
27029: LD_VAR 0 3
27033: RET
// export function MC_ClassManager ( ) ; var i , j , tmp , p , b , e , k ; begin
27034: LD_INT 0
27036: PPUSH
27037: PPUSH
27038: PPUSH
27039: PPUSH
27040: PPUSH
27041: PPUSH
27042: PPUSH
27043: PPUSH
// if not mc_bases then
27044: LD_EXP 80
27048: NOT
27049: IFFALSE 27053
// exit ;
27051: GO 27502
// for i = 1 to mc_bases do
27053: LD_ADDR_VAR 0 2
27057: PUSH
27058: DOUBLE
27059: LD_INT 1
27061: DEC
27062: ST_TO_ADDR
27063: LD_EXP 80
27067: PUSH
27068: FOR_TO
27069: IFFALSE 27500
// begin tmp := MC_ClassCheckReq ( i ) ;
27071: LD_ADDR_VAR 0 4
27075: PUSH
27076: LD_VAR 0 2
27080: PPUSH
27081: CALL 27507 0 1
27085: ST_TO_ADDR
// mc_class := Replace ( mc_class , i , tmp ) ;
27086: LD_ADDR_EXP 121
27090: PUSH
27091: LD_EXP 121
27095: PPUSH
27096: LD_VAR 0 2
27100: PPUSH
27101: LD_VAR 0 4
27105: PPUSH
27106: CALL_OW 1
27110: ST_TO_ADDR
// b := [ UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_armoury ] , [ f_btype , b_barracks ] ] ) , UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) , UnitFilter ( mc_bases [ i ] , [ f_btype , b_factory ] ) , UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_lab ] , [ f_btype , b_lab_half ] , [ f_btype , b_lab_full ] ] ) ] ;
27111: LD_ADDR_VAR 0 6
27115: PUSH
27116: LD_EXP 80
27120: PUSH
27121: LD_VAR 0 2
27125: ARRAY
27126: PPUSH
27127: LD_INT 2
27129: PUSH
27130: LD_INT 30
27132: PUSH
27133: LD_INT 4
27135: PUSH
27136: EMPTY
27137: LIST
27138: LIST
27139: PUSH
27140: LD_INT 30
27142: PUSH
27143: LD_INT 5
27145: PUSH
27146: EMPTY
27147: LIST
27148: LIST
27149: PUSH
27150: EMPTY
27151: LIST
27152: LIST
27153: LIST
27154: PPUSH
27155: CALL_OW 72
27159: PUSH
27160: LD_EXP 80
27164: PUSH
27165: LD_VAR 0 2
27169: ARRAY
27170: PPUSH
27171: LD_INT 2
27173: PUSH
27174: LD_INT 30
27176: PUSH
27177: LD_INT 0
27179: PUSH
27180: EMPTY
27181: LIST
27182: LIST
27183: PUSH
27184: LD_INT 30
27186: PUSH
27187: LD_INT 1
27189: PUSH
27190: EMPTY
27191: LIST
27192: LIST
27193: PUSH
27194: EMPTY
27195: LIST
27196: LIST
27197: LIST
27198: PPUSH
27199: CALL_OW 72
27203: PUSH
27204: LD_EXP 80
27208: PUSH
27209: LD_VAR 0 2
27213: ARRAY
27214: PPUSH
27215: LD_INT 30
27217: PUSH
27218: LD_INT 3
27220: PUSH
27221: EMPTY
27222: LIST
27223: LIST
27224: PPUSH
27225: CALL_OW 72
27229: PUSH
27230: LD_EXP 80
27234: PUSH
27235: LD_VAR 0 2
27239: ARRAY
27240: PPUSH
27241: LD_INT 2
27243: PUSH
27244: LD_INT 30
27246: PUSH
27247: LD_INT 6
27249: PUSH
27250: EMPTY
27251: LIST
27252: LIST
27253: PUSH
27254: LD_INT 30
27256: PUSH
27257: LD_INT 7
27259: PUSH
27260: EMPTY
27261: LIST
27262: LIST
27263: PUSH
27264: LD_INT 30
27266: PUSH
27267: LD_INT 8
27269: PUSH
27270: EMPTY
27271: LIST
27272: LIST
27273: PUSH
27274: EMPTY
27275: LIST
27276: LIST
27277: LIST
27278: LIST
27279: PPUSH
27280: CALL_OW 72
27284: PUSH
27285: EMPTY
27286: LIST
27287: LIST
27288: LIST
27289: LIST
27290: ST_TO_ADDR
// for j := 1 to 4 do
27291: LD_ADDR_VAR 0 3
27295: PUSH
27296: DOUBLE
27297: LD_INT 1
27299: DEC
27300: ST_TO_ADDR
27301: LD_INT 4
27303: PUSH
27304: FOR_TO
27305: IFFALSE 27496
// begin if not tmp [ j ] then
27307: LD_VAR 0 4
27311: PUSH
27312: LD_VAR 0 3
27316: ARRAY
27317: NOT
27318: IFFALSE 27322
// continue ;
27320: GO 27304
// for p in tmp [ j ] do
27322: LD_ADDR_VAR 0 5
27326: PUSH
27327: LD_VAR 0 4
27331: PUSH
27332: LD_VAR 0 3
27336: ARRAY
27337: PUSH
27338: FOR_IN
27339: IFFALSE 27492
// begin if not b [ j ] then
27341: LD_VAR 0 6
27345: PUSH
27346: LD_VAR 0 3
27350: ARRAY
27351: NOT
27352: IFFALSE 27356
// break ;
27354: GO 27492
// e := 0 ;
27356: LD_ADDR_VAR 0 7
27360: PUSH
27361: LD_INT 0
27363: ST_TO_ADDR
// for k in b [ j ] do
27364: LD_ADDR_VAR 0 8
27368: PUSH
27369: LD_VAR 0 6
27373: PUSH
27374: LD_VAR 0 3
27378: ARRAY
27379: PUSH
27380: FOR_IN
27381: IFFALSE 27408
// if IsNotFull ( k ) then
27383: LD_VAR 0 8
27387: PPUSH
27388: CALL 55662 0 1
27392: IFFALSE 27406
// begin e := k ;
27394: LD_ADDR_VAR 0 7
27398: PUSH
27399: LD_VAR 0 8
27403: ST_TO_ADDR
// break ;
27404: GO 27408
// end ;
27406: GO 27380
27408: POP
27409: POP
// if e and not UnitGoingToBuilding ( p , e ) then
27410: LD_VAR 0 7
27414: PUSH
27415: LD_VAR 0 5
27419: PPUSH
27420: LD_VAR 0 7
27424: PPUSH
27425: CALL 89801 0 2
27429: NOT
27430: AND
27431: IFFALSE 27490
// begin if IsInUnit ( p ) then
27433: LD_VAR 0 5
27437: PPUSH
27438: CALL_OW 310
27442: IFFALSE 27453
// ComExitBuilding ( p ) ;
27444: LD_VAR 0 5
27448: PPUSH
27449: CALL_OW 122
// ComEnterUnit ( p , e ) ;
27453: LD_VAR 0 5
27457: PPUSH
27458: LD_VAR 0 7
27462: PPUSH
27463: CALL_OW 120
// AddComChangeProfession ( p , j ) ;
27467: LD_VAR 0 5
27471: PPUSH
27472: LD_VAR 0 3
27476: PPUSH
27477: CALL_OW 183
// AddComExitBuilding ( p ) ;
27481: LD_VAR 0 5
27485: PPUSH
27486: CALL_OW 182
// end ; end ;
27490: GO 27338
27492: POP
27493: POP
// end ;
27494: GO 27304
27496: POP
27497: POP
// end ;
27498: GO 27068
27500: POP
27501: POP
// end ;
27502: LD_VAR 0 1
27506: RET
// export function MC_ClassCheckReq ( base ) ; var i , tmp , sol , eng , mech , sci , sort , j , p , b , bcount ; begin
27507: LD_INT 0
27509: PPUSH
27510: PPUSH
27511: PPUSH
27512: PPUSH
27513: PPUSH
27514: PPUSH
27515: PPUSH
27516: PPUSH
27517: PPUSH
27518: PPUSH
27519: PPUSH
27520: PPUSH
// result := [ 0 , 0 , 0 , 0 ] ;
27521: LD_ADDR_VAR 0 2
27525: PUSH
27526: LD_INT 0
27528: PUSH
27529: LD_INT 0
27531: PUSH
27532: LD_INT 0
27534: PUSH
27535: LD_INT 0
27537: PUSH
27538: EMPTY
27539: LIST
27540: LIST
27541: LIST
27542: LIST
27543: ST_TO_ADDR
// if not base or not mc_bases [ base ] or not UnitFilter ( mc_bases [ base ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) then
27544: LD_VAR 0 1
27548: NOT
27549: PUSH
27550: LD_EXP 80
27554: PUSH
27555: LD_VAR 0 1
27559: ARRAY
27560: NOT
27561: OR
27562: PUSH
27563: LD_EXP 80
27567: PUSH
27568: LD_VAR 0 1
27572: ARRAY
27573: PPUSH
27574: LD_INT 2
27576: PUSH
27577: LD_INT 30
27579: PUSH
27580: LD_INT 0
27582: PUSH
27583: EMPTY
27584: LIST
27585: LIST
27586: PUSH
27587: LD_INT 30
27589: PUSH
27590: LD_INT 1
27592: PUSH
27593: EMPTY
27594: LIST
27595: LIST
27596: PUSH
27597: EMPTY
27598: LIST
27599: LIST
27600: LIST
27601: PPUSH
27602: CALL_OW 72
27606: NOT
27607: OR
27608: IFFALSE 27612
// exit ;
27610: GO 31115
// tmp := UnitFilter ( mc_bases [ base ] , [ f_or , [ f_class , 1 ] , [ f_class , 2 ] , [ f_class , 3 ] , [ f_class , 4 ] , [ f_class , 5 ] , [ f_class , 8 ] , [ f_class , 9 ] ] ) ;
27612: LD_ADDR_VAR 0 4
27616: PUSH
27617: LD_EXP 80
27621: PUSH
27622: LD_VAR 0 1
27626: ARRAY
27627: PPUSH
27628: LD_INT 2
27630: PUSH
27631: LD_INT 25
27633: PUSH
27634: LD_INT 1
27636: PUSH
27637: EMPTY
27638: LIST
27639: LIST
27640: PUSH
27641: LD_INT 25
27643: PUSH
27644: LD_INT 2
27646: PUSH
27647: EMPTY
27648: LIST
27649: LIST
27650: PUSH
27651: LD_INT 25
27653: PUSH
27654: LD_INT 3
27656: PUSH
27657: EMPTY
27658: LIST
27659: LIST
27660: PUSH
27661: LD_INT 25
27663: PUSH
27664: LD_INT 4
27666: PUSH
27667: EMPTY
27668: LIST
27669: LIST
27670: PUSH
27671: LD_INT 25
27673: PUSH
27674: LD_INT 5
27676: PUSH
27677: EMPTY
27678: LIST
27679: LIST
27680: PUSH
27681: LD_INT 25
27683: PUSH
27684: LD_INT 8
27686: PUSH
27687: EMPTY
27688: LIST
27689: LIST
27690: PUSH
27691: LD_INT 25
27693: PUSH
27694: LD_INT 9
27696: PUSH
27697: EMPTY
27698: LIST
27699: LIST
27700: PUSH
27701: EMPTY
27702: LIST
27703: LIST
27704: LIST
27705: LIST
27706: LIST
27707: LIST
27708: LIST
27709: LIST
27710: PPUSH
27711: CALL_OW 72
27715: ST_TO_ADDR
// if not tmp then
27716: LD_VAR 0 4
27720: NOT
27721: IFFALSE 27725
// exit ;
27723: GO 31115
// for i in tmp do
27725: LD_ADDR_VAR 0 3
27729: PUSH
27730: LD_VAR 0 4
27734: PUSH
27735: FOR_IN
27736: IFFALSE 27767
// if GetTag ( i ) then
27738: LD_VAR 0 3
27742: PPUSH
27743: CALL_OW 110
27747: IFFALSE 27765
// tmp := tmp diff i ;
27749: LD_ADDR_VAR 0 4
27753: PUSH
27754: LD_VAR 0 4
27758: PUSH
27759: LD_VAR 0 3
27763: DIFF
27764: ST_TO_ADDR
27765: GO 27735
27767: POP
27768: POP
// if not tmp then
27769: LD_VAR 0 4
27773: NOT
27774: IFFALSE 27778
// exit ;
27776: GO 31115
// sol := UnitFilter ( mc_bases [ base ] , [ f_or , [ f_class , 1 ] , [ f_class , 5 ] , [ f_class , 8 ] , [ f_class , 9 ] ] ) ;
27778: LD_ADDR_VAR 0 5
27782: PUSH
27783: LD_EXP 80
27787: PUSH
27788: LD_VAR 0 1
27792: ARRAY
27793: PPUSH
27794: LD_INT 2
27796: PUSH
27797: LD_INT 25
27799: PUSH
27800: LD_INT 1
27802: PUSH
27803: EMPTY
27804: LIST
27805: LIST
27806: PUSH
27807: LD_INT 25
27809: PUSH
27810: LD_INT 5
27812: PUSH
27813: EMPTY
27814: LIST
27815: LIST
27816: PUSH
27817: LD_INT 25
27819: PUSH
27820: LD_INT 8
27822: PUSH
27823: EMPTY
27824: LIST
27825: LIST
27826: PUSH
27827: LD_INT 25
27829: PUSH
27830: LD_INT 9
27832: PUSH
27833: EMPTY
27834: LIST
27835: LIST
27836: PUSH
27837: EMPTY
27838: LIST
27839: LIST
27840: LIST
27841: LIST
27842: LIST
27843: PPUSH
27844: CALL_OW 72
27848: ST_TO_ADDR
// eng := UnitFilter ( mc_bases [ base ] , [ f_class , 2 ] ) ;
27849: LD_ADDR_VAR 0 6
27853: PUSH
27854: LD_EXP 80
27858: PUSH
27859: LD_VAR 0 1
27863: ARRAY
27864: PPUSH
27865: LD_INT 25
27867: PUSH
27868: LD_INT 2
27870: PUSH
27871: EMPTY
27872: LIST
27873: LIST
27874: PPUSH
27875: CALL_OW 72
27879: ST_TO_ADDR
// mech := UnitFilter ( mc_bases [ base ] , [ f_class , 3 ] ) ;
27880: LD_ADDR_VAR 0 7
27884: PUSH
27885: LD_EXP 80
27889: PUSH
27890: LD_VAR 0 1
27894: ARRAY
27895: PPUSH
27896: LD_INT 25
27898: PUSH
27899: LD_INT 3
27901: PUSH
27902: EMPTY
27903: LIST
27904: LIST
27905: PPUSH
27906: CALL_OW 72
27910: ST_TO_ADDR
// sci := UnitFilter ( mc_bases [ base ] , [ [ f_class , 4 ] , [ f_lives , 251 ] ] ) ;
27911: LD_ADDR_VAR 0 8
27915: PUSH
27916: LD_EXP 80
27920: PUSH
27921: LD_VAR 0 1
27925: ARRAY
27926: PPUSH
27927: LD_INT 25
27929: PUSH
27930: LD_INT 4
27932: PUSH
27933: EMPTY
27934: LIST
27935: LIST
27936: PUSH
27937: LD_INT 24
27939: PUSH
27940: LD_INT 251
27942: PUSH
27943: EMPTY
27944: LIST
27945: LIST
27946: PUSH
27947: EMPTY
27948: LIST
27949: LIST
27950: PPUSH
27951: CALL_OW 72
27955: ST_TO_ADDR
// if mc_is_defending [ base ] then
27956: LD_EXP 123
27960: PUSH
27961: LD_VAR 0 1
27965: ARRAY
27966: IFFALSE 28427
// begin mc_class_case_use := Replace ( mc_class_case_use , base , 4 ) ;
27968: LD_ADDR_EXP 122
27972: PUSH
27973: LD_EXP 122
27977: PPUSH
27978: LD_VAR 0 1
27982: PPUSH
27983: LD_INT 4
27985: PPUSH
27986: CALL_OW 1
27990: ST_TO_ADDR
// b := UnitFilter ( mc_bases [ base ] , [ f_or , [ f_btype , b_armoury ] , [ f_btype , b_barracks ] ] ) ;
27991: LD_ADDR_VAR 0 12
27995: PUSH
27996: LD_EXP 80
28000: PUSH
28001: LD_VAR 0 1
28005: ARRAY
28006: PPUSH
28007: LD_INT 2
28009: PUSH
28010: LD_INT 30
28012: PUSH
28013: LD_INT 4
28015: PUSH
28016: EMPTY
28017: LIST
28018: LIST
28019: PUSH
28020: LD_INT 30
28022: PUSH
28023: LD_INT 5
28025: PUSH
28026: EMPTY
28027: LIST
28028: LIST
28029: PUSH
28030: EMPTY
28031: LIST
28032: LIST
28033: LIST
28034: PPUSH
28035: CALL_OW 72
28039: ST_TO_ADDR
// if not b then
28040: LD_VAR 0 12
28044: NOT
28045: IFFALSE 28049
// exit ;
28047: GO 31115
// p := [ ] ;
28049: LD_ADDR_VAR 0 11
28053: PUSH
28054: EMPTY
28055: ST_TO_ADDR
// if sci >= 2 then
28056: LD_VAR 0 8
28060: PUSH
28061: LD_INT 2
28063: GREATEREQUAL
28064: IFFALSE 28095
// sci := [ sci [ 1 ] , sci [ 2 ] ] else
28066: LD_ADDR_VAR 0 8
28070: PUSH
28071: LD_VAR 0 8
28075: PUSH
28076: LD_INT 1
28078: ARRAY
28079: PUSH
28080: LD_VAR 0 8
28084: PUSH
28085: LD_INT 2
28087: ARRAY
28088: PUSH
28089: EMPTY
28090: LIST
28091: LIST
28092: ST_TO_ADDR
28093: GO 28156
// if sci = 1 then
28095: LD_VAR 0 8
28099: PUSH
28100: LD_INT 1
28102: EQUAL
28103: IFFALSE 28124
// sci := [ sci [ 1 ] ] else
28105: LD_ADDR_VAR 0 8
28109: PUSH
28110: LD_VAR 0 8
28114: PUSH
28115: LD_INT 1
28117: ARRAY
28118: PUSH
28119: EMPTY
28120: LIST
28121: ST_TO_ADDR
28122: GO 28156
// if sci = 0 then
28124: LD_VAR 0 8
28128: PUSH
28129: LD_INT 0
28131: EQUAL
28132: IFFALSE 28156
// p := SortBySkill ( tmp , 4 ) [ 1 ] ;
28134: LD_ADDR_VAR 0 11
28138: PUSH
28139: LD_VAR 0 4
28143: PPUSH
28144: LD_INT 4
28146: PPUSH
28147: CALL 89673 0 2
28151: PUSH
28152: LD_INT 1
28154: ARRAY
28155: ST_TO_ADDR
// if eng > 4 then
28156: LD_VAR 0 6
28160: PUSH
28161: LD_INT 4
28163: GREATER
28164: IFFALSE 28210
// for i = eng downto 4 do
28166: LD_ADDR_VAR 0 3
28170: PUSH
28171: DOUBLE
28172: LD_VAR 0 6
28176: INC
28177: ST_TO_ADDR
28178: LD_INT 4
28180: PUSH
28181: FOR_DOWNTO
28182: IFFALSE 28208
// eng := eng diff eng [ i ] ;
28184: LD_ADDR_VAR 0 6
28188: PUSH
28189: LD_VAR 0 6
28193: PUSH
28194: LD_VAR 0 6
28198: PUSH
28199: LD_VAR 0 3
28203: ARRAY
28204: DIFF
28205: ST_TO_ADDR
28206: GO 28181
28208: POP
28209: POP
// tmp := tmp diff ( sol union eng union mech union sci ) ;
28210: LD_ADDR_VAR 0 4
28214: PUSH
28215: LD_VAR 0 4
28219: PUSH
28220: LD_VAR 0 5
28224: PUSH
28225: LD_VAR 0 6
28229: UNION
28230: PUSH
28231: LD_VAR 0 7
28235: UNION
28236: PUSH
28237: LD_VAR 0 8
28241: UNION
28242: DIFF
28243: ST_TO_ADDR
// bcount := UnitFilter ( mc_bases [ base ] , [ f_or , [ f_btype , b_bunker ] , [ f_btype , b_breastwork ] ] ) + UnitFilter ( mc_bases [ base ] , [ f_or , [ f_btype , b_armoury ] , [ f_btype , b_barracks ] ] ) * 6 ;
28244: LD_ADDR_VAR 0 13
28248: PUSH
28249: LD_EXP 80
28253: PUSH
28254: LD_VAR 0 1
28258: ARRAY
28259: PPUSH
28260: LD_INT 2
28262: PUSH
28263: LD_INT 30
28265: PUSH
28266: LD_INT 32
28268: PUSH
28269: EMPTY
28270: LIST
28271: LIST
28272: PUSH
28273: LD_INT 30
28275: PUSH
28276: LD_INT 31
28278: PUSH
28279: EMPTY
28280: LIST
28281: LIST
28282: PUSH
28283: EMPTY
28284: LIST
28285: LIST
28286: LIST
28287: PPUSH
28288: CALL_OW 72
28292: PUSH
28293: LD_EXP 80
28297: PUSH
28298: LD_VAR 0 1
28302: ARRAY
28303: PPUSH
28304: LD_INT 2
28306: PUSH
28307: LD_INT 30
28309: PUSH
28310: LD_INT 4
28312: PUSH
28313: EMPTY
28314: LIST
28315: LIST
28316: PUSH
28317: LD_INT 30
28319: PUSH
28320: LD_INT 5
28322: PUSH
28323: EMPTY
28324: LIST
28325: LIST
28326: PUSH
28327: EMPTY
28328: LIST
28329: LIST
28330: LIST
28331: PPUSH
28332: CALL_OW 72
28336: PUSH
28337: LD_INT 6
28339: MUL
28340: PLUS
28341: ST_TO_ADDR
// if bcount < tmp then
28342: LD_VAR 0 13
28346: PUSH
28347: LD_VAR 0 4
28351: LESS
28352: IFFALSE 28398
// for i = tmp downto bcount do
28354: LD_ADDR_VAR 0 3
28358: PUSH
28359: DOUBLE
28360: LD_VAR 0 4
28364: INC
28365: ST_TO_ADDR
28366: LD_VAR 0 13
28370: PUSH
28371: FOR_DOWNTO
28372: IFFALSE 28396
// tmp := Delete ( tmp , tmp ) ;
28374: LD_ADDR_VAR 0 4
28378: PUSH
28379: LD_VAR 0 4
28383: PPUSH
28384: LD_VAR 0 4
28388: PPUSH
28389: CALL_OW 3
28393: ST_TO_ADDR
28394: GO 28371
28396: POP
28397: POP
// result := [ tmp , 0 , 0 , p ] ;
28398: LD_ADDR_VAR 0 2
28402: PUSH
28403: LD_VAR 0 4
28407: PUSH
28408: LD_INT 0
28410: PUSH
28411: LD_INT 0
28413: PUSH
28414: LD_VAR 0 11
28418: PUSH
28419: EMPTY
28420: LIST
28421: LIST
28422: LIST
28423: LIST
28424: ST_TO_ADDR
// exit ;
28425: GO 31115
// end ; if not UnitFilter ( mc_bases [ base ] , [ f_or , [ f_btype , b_lab ] , [ f_btype , b_lab_half ] , [ f_btype , b_lab_full ] ] ) and not UnitFilter ( mc_bases [ base ] , [ f_btype , b_factory ] ) then
28427: LD_EXP 80
28431: PUSH
28432: LD_VAR 0 1
28436: ARRAY
28437: PPUSH
28438: LD_INT 2
28440: PUSH
28441: LD_INT 30
28443: PUSH
28444: LD_INT 6
28446: PUSH
28447: EMPTY
28448: LIST
28449: LIST
28450: PUSH
28451: LD_INT 30
28453: PUSH
28454: LD_INT 7
28456: PUSH
28457: EMPTY
28458: LIST
28459: LIST
28460: PUSH
28461: LD_INT 30
28463: PUSH
28464: LD_INT 8
28466: PUSH
28467: EMPTY
28468: LIST
28469: LIST
28470: PUSH
28471: EMPTY
28472: LIST
28473: LIST
28474: LIST
28475: LIST
28476: PPUSH
28477: CALL_OW 72
28481: NOT
28482: PUSH
28483: LD_EXP 80
28487: PUSH
28488: LD_VAR 0 1
28492: ARRAY
28493: PPUSH
28494: LD_INT 30
28496: PUSH
28497: LD_INT 3
28499: PUSH
28500: EMPTY
28501: LIST
28502: LIST
28503: PPUSH
28504: CALL_OW 72
28508: NOT
28509: AND
28510: IFFALSE 28582
// begin if eng = tmp then
28512: LD_VAR 0 6
28516: PUSH
28517: LD_VAR 0 4
28521: EQUAL
28522: IFFALSE 28526
// exit ;
28524: GO 31115
// mc_class_case_use := Replace ( mc_class_case_use , base , 1 ) ;
28526: LD_ADDR_EXP 122
28530: PUSH
28531: LD_EXP 122
28535: PPUSH
28536: LD_VAR 0 1
28540: PPUSH
28541: LD_INT 1
28543: PPUSH
28544: CALL_OW 1
28548: ST_TO_ADDR
// result := [ 0 , tmp diff eng , 0 , 0 ] ;
28549: LD_ADDR_VAR 0 2
28553: PUSH
28554: LD_INT 0
28556: PUSH
28557: LD_VAR 0 4
28561: PUSH
28562: LD_VAR 0 6
28566: DIFF
28567: PUSH
28568: LD_INT 0
28570: PUSH
28571: LD_INT 0
28573: PUSH
28574: EMPTY
28575: LIST
28576: LIST
28577: LIST
28578: LIST
28579: ST_TO_ADDR
// exit ;
28580: GO 31115
// end ; if mc_tech [ mc_sides [ base ] ] and UnitFilter ( mc_bases [ base ] , [ f_or , [ f_btype , b_lab ] , [ f_btype , b_lab_half ] , [ f_btype , b_lab_full ] ] ) and not UnitFilter ( mc_bases [ base ] , [ f_btype , b_factory ] ) then
28582: LD_EXP 107
28586: PUSH
28587: LD_EXP 106
28591: PUSH
28592: LD_VAR 0 1
28596: ARRAY
28597: ARRAY
28598: PUSH
28599: LD_EXP 80
28603: PUSH
28604: LD_VAR 0 1
28608: ARRAY
28609: PPUSH
28610: LD_INT 2
28612: PUSH
28613: LD_INT 30
28615: PUSH
28616: LD_INT 6
28618: PUSH
28619: EMPTY
28620: LIST
28621: LIST
28622: PUSH
28623: LD_INT 30
28625: PUSH
28626: LD_INT 7
28628: PUSH
28629: EMPTY
28630: LIST
28631: LIST
28632: PUSH
28633: LD_INT 30
28635: PUSH
28636: LD_INT 8
28638: PUSH
28639: EMPTY
28640: LIST
28641: LIST
28642: PUSH
28643: EMPTY
28644: LIST
28645: LIST
28646: LIST
28647: LIST
28648: PPUSH
28649: CALL_OW 72
28653: AND
28654: PUSH
28655: LD_EXP 80
28659: PUSH
28660: LD_VAR 0 1
28664: ARRAY
28665: PPUSH
28666: LD_INT 30
28668: PUSH
28669: LD_INT 3
28671: PUSH
28672: EMPTY
28673: LIST
28674: LIST
28675: PPUSH
28676: CALL_OW 72
28680: NOT
28681: AND
28682: IFFALSE 28896
// begin if sci >= 6 then
28684: LD_VAR 0 8
28688: PUSH
28689: LD_INT 6
28691: GREATEREQUAL
28692: IFFALSE 28696
// exit ;
28694: GO 31115
// mc_class_case_use := Replace ( mc_class_case_use , base , 2 ) ;
28696: LD_ADDR_EXP 122
28700: PUSH
28701: LD_EXP 122
28705: PPUSH
28706: LD_VAR 0 1
28710: PPUSH
28711: LD_INT 2
28713: PPUSH
28714: CALL_OW 1
28718: ST_TO_ADDR
// sort := SortBySkill ( tmp diff sci , 4 ) ;
28719: LD_ADDR_VAR 0 9
28723: PUSH
28724: LD_VAR 0 4
28728: PUSH
28729: LD_VAR 0 8
28733: DIFF
28734: PPUSH
28735: LD_INT 4
28737: PPUSH
28738: CALL 89673 0 2
28742: ST_TO_ADDR
// p := [ ] ;
28743: LD_ADDR_VAR 0 11
28747: PUSH
28748: EMPTY
28749: ST_TO_ADDR
// if sci < 6 and sort > 6 then
28750: LD_VAR 0 8
28754: PUSH
28755: LD_INT 6
28757: LESS
28758: PUSH
28759: LD_VAR 0 9
28763: PUSH
28764: LD_INT 6
28766: GREATER
28767: AND
28768: IFFALSE 28849
// begin for i = 1 to 6 - sci do
28770: LD_ADDR_VAR 0 3
28774: PUSH
28775: DOUBLE
28776: LD_INT 1
28778: DEC
28779: ST_TO_ADDR
28780: LD_INT 6
28782: PUSH
28783: LD_VAR 0 8
28787: MINUS
28788: PUSH
28789: FOR_TO
28790: IFFALSE 28845
// begin p := Insert ( p , p + 1 , sort [ 1 ] ) ;
28792: LD_ADDR_VAR 0 11
28796: PUSH
28797: LD_VAR 0 11
28801: PPUSH
28802: LD_VAR 0 11
28806: PUSH
28807: LD_INT 1
28809: PLUS
28810: PPUSH
28811: LD_VAR 0 9
28815: PUSH
28816: LD_INT 1
28818: ARRAY
28819: PPUSH
28820: CALL_OW 2
28824: ST_TO_ADDR
// sort := Delete ( sort , 1 ) ;
28825: LD_ADDR_VAR 0 9
28829: PUSH
28830: LD_VAR 0 9
28834: PPUSH
28835: LD_INT 1
28837: PPUSH
28838: CALL_OW 3
28842: ST_TO_ADDR
// end ;
28843: GO 28789
28845: POP
28846: POP
// end else
28847: GO 28869
// if sort then
28849: LD_VAR 0 9
28853: IFFALSE 28869
// p := sort [ 1 ] ;
28855: LD_ADDR_VAR 0 11
28859: PUSH
28860: LD_VAR 0 9
28864: PUSH
28865: LD_INT 1
28867: ARRAY
28868: ST_TO_ADDR
// result := [ 0 , 0 , 0 , p ] ;
28869: LD_ADDR_VAR 0 2
28873: PUSH
28874: LD_INT 0
28876: PUSH
28877: LD_INT 0
28879: PUSH
28880: LD_INT 0
28882: PUSH
28883: LD_VAR 0 11
28887: PUSH
28888: EMPTY
28889: LIST
28890: LIST
28891: LIST
28892: LIST
28893: ST_TO_ADDR
// exit ;
28894: GO 31115
// end ; if mc_tech [ mc_sides [ base ] ] and UnitFilter ( mc_bases [ base ] , [ f_or , [ f_btype , b_lab ] , [ f_btype , b_lab_half ] , [ f_btype , b_lab_full ] ] ) and UnitFilter ( mc_bases [ base ] , [ f_btype , b_factory ] ) then
28896: LD_EXP 107
28900: PUSH
28901: LD_EXP 106
28905: PUSH
28906: LD_VAR 0 1
28910: ARRAY
28911: ARRAY
28912: PUSH
28913: LD_EXP 80
28917: PUSH
28918: LD_VAR 0 1
28922: ARRAY
28923: PPUSH
28924: LD_INT 2
28926: PUSH
28927: LD_INT 30
28929: PUSH
28930: LD_INT 6
28932: PUSH
28933: EMPTY
28934: LIST
28935: LIST
28936: PUSH
28937: LD_INT 30
28939: PUSH
28940: LD_INT 7
28942: PUSH
28943: EMPTY
28944: LIST
28945: LIST
28946: PUSH
28947: LD_INT 30
28949: PUSH
28950: LD_INT 8
28952: PUSH
28953: EMPTY
28954: LIST
28955: LIST
28956: PUSH
28957: EMPTY
28958: LIST
28959: LIST
28960: LIST
28961: LIST
28962: PPUSH
28963: CALL_OW 72
28967: AND
28968: PUSH
28969: LD_EXP 80
28973: PUSH
28974: LD_VAR 0 1
28978: ARRAY
28979: PPUSH
28980: LD_INT 30
28982: PUSH
28983: LD_INT 3
28985: PUSH
28986: EMPTY
28987: LIST
28988: LIST
28989: PPUSH
28990: CALL_OW 72
28994: AND
28995: IFFALSE 29729
// begin mc_class_case_use := Replace ( mc_class_case_use , base , 3 ) ;
28997: LD_ADDR_EXP 122
29001: PUSH
29002: LD_EXP 122
29006: PPUSH
29007: LD_VAR 0 1
29011: PPUSH
29012: LD_INT 3
29014: PPUSH
29015: CALL_OW 1
29019: ST_TO_ADDR
// result := [ 0 , 0 , 0 , 0 ] ;
29020: LD_ADDR_VAR 0 2
29024: PUSH
29025: LD_INT 0
29027: PUSH
29028: LD_INT 0
29030: PUSH
29031: LD_INT 0
29033: PUSH
29034: LD_INT 0
29036: PUSH
29037: EMPTY
29038: LIST
29039: LIST
29040: LIST
29041: LIST
29042: ST_TO_ADDR
// if not eng then
29043: LD_VAR 0 6
29047: NOT
29048: IFFALSE 29111
// begin p := SortBySkill ( tmp , 2 ) [ 1 ] ;
29050: LD_ADDR_VAR 0 11
29054: PUSH
29055: LD_VAR 0 4
29059: PPUSH
29060: LD_INT 2
29062: PPUSH
29063: CALL 89673 0 2
29067: PUSH
29068: LD_INT 1
29070: ARRAY
29071: ST_TO_ADDR
// result := Replace ( result , 2 , p ) ;
29072: LD_ADDR_VAR 0 2
29076: PUSH
29077: LD_VAR 0 2
29081: PPUSH
29082: LD_INT 2
29084: PPUSH
29085: LD_VAR 0 11
29089: PPUSH
29090: CALL_OW 1
29094: ST_TO_ADDR
// tmp := tmp diff p ;
29095: LD_ADDR_VAR 0 4
29099: PUSH
29100: LD_VAR 0 4
29104: PUSH
29105: LD_VAR 0 11
29109: DIFF
29110: ST_TO_ADDR
// end ; if tmp and sci < 6 then
29111: LD_VAR 0 4
29115: PUSH
29116: LD_VAR 0 8
29120: PUSH
29121: LD_INT 6
29123: LESS
29124: AND
29125: IFFALSE 29313
// begin sort := SortBySkill ( tmp diff ( sci union mech ) , 4 ) ;
29127: LD_ADDR_VAR 0 9
29131: PUSH
29132: LD_VAR 0 4
29136: PUSH
29137: LD_VAR 0 8
29141: PUSH
29142: LD_VAR 0 7
29146: UNION
29147: DIFF
29148: PPUSH
29149: LD_INT 4
29151: PPUSH
29152: CALL 89673 0 2
29156: ST_TO_ADDR
// p := [ ] ;
29157: LD_ADDR_VAR 0 11
29161: PUSH
29162: EMPTY
29163: ST_TO_ADDR
// if sort then
29164: LD_VAR 0 9
29168: IFFALSE 29284
// for i = 1 to 6 - sci do
29170: LD_ADDR_VAR 0 3
29174: PUSH
29175: DOUBLE
29176: LD_INT 1
29178: DEC
29179: ST_TO_ADDR
29180: LD_INT 6
29182: PUSH
29183: LD_VAR 0 8
29187: MINUS
29188: PUSH
29189: FOR_TO
29190: IFFALSE 29282
// begin if i = sort then
29192: LD_VAR 0 3
29196: PUSH
29197: LD_VAR 0 9
29201: EQUAL
29202: IFFALSE 29206
// break ;
29204: GO 29282
// if GetClass ( i ) = 4 then
29206: LD_VAR 0 3
29210: PPUSH
29211: CALL_OW 257
29215: PUSH
29216: LD_INT 4
29218: EQUAL
29219: IFFALSE 29223
// continue ;
29221: GO 29189
// p := Insert ( p , p + 1 , sort [ i ] ) ;
29223: LD_ADDR_VAR 0 11
29227: PUSH
29228: LD_VAR 0 11
29232: PPUSH
29233: LD_VAR 0 11
29237: PUSH
29238: LD_INT 1
29240: PLUS
29241: PPUSH
29242: LD_VAR 0 9
29246: PUSH
29247: LD_VAR 0 3
29251: ARRAY
29252: PPUSH
29253: CALL_OW 2
29257: ST_TO_ADDR
// tmp := tmp diff sort [ i ] ;
29258: LD_ADDR_VAR 0 4
29262: PUSH
29263: LD_VAR 0 4
29267: PUSH
29268: LD_VAR 0 9
29272: PUSH
29273: LD_VAR 0 3
29277: ARRAY
29278: DIFF
29279: ST_TO_ADDR
// end ;
29280: GO 29189
29282: POP
29283: POP
// if p then
29284: LD_VAR 0 11
29288: IFFALSE 29313
// result := Replace ( result , 4 , p ) ;
29290: LD_ADDR_VAR 0 2
29294: PUSH
29295: LD_VAR 0 2
29299: PPUSH
29300: LD_INT 4
29302: PPUSH
29303: LD_VAR 0 11
29307: PPUSH
29308: CALL_OW 1
29312: ST_TO_ADDR
// end ; if tmp and mech < 6 then
29313: LD_VAR 0 4
29317: PUSH
29318: LD_VAR 0 7
29322: PUSH
29323: LD_INT 6
29325: LESS
29326: AND
29327: IFFALSE 29515
// begin sort := SortBySkill ( tmp diff ( sci union mech ) , 3 ) ;
29329: LD_ADDR_VAR 0 9
29333: PUSH
29334: LD_VAR 0 4
29338: PUSH
29339: LD_VAR 0 8
29343: PUSH
29344: LD_VAR 0 7
29348: UNION
29349: DIFF
29350: PPUSH
29351: LD_INT 3
29353: PPUSH
29354: CALL 89673 0 2
29358: ST_TO_ADDR
// p := [ ] ;
29359: LD_ADDR_VAR 0 11
29363: PUSH
29364: EMPTY
29365: ST_TO_ADDR
// if sort then
29366: LD_VAR 0 9
29370: IFFALSE 29486
// for i = 1 to 6 - mech do
29372: LD_ADDR_VAR 0 3
29376: PUSH
29377: DOUBLE
29378: LD_INT 1
29380: DEC
29381: ST_TO_ADDR
29382: LD_INT 6
29384: PUSH
29385: LD_VAR 0 7
29389: MINUS
29390: PUSH
29391: FOR_TO
29392: IFFALSE 29484
// begin if i = sort then
29394: LD_VAR 0 3
29398: PUSH
29399: LD_VAR 0 9
29403: EQUAL
29404: IFFALSE 29408
// break ;
29406: GO 29484
// if GetClass ( i ) = 3 then
29408: LD_VAR 0 3
29412: PPUSH
29413: CALL_OW 257
29417: PUSH
29418: LD_INT 3
29420: EQUAL
29421: IFFALSE 29425
// continue ;
29423: GO 29391
// p := Insert ( p , p + 1 , sort [ i ] ) ;
29425: LD_ADDR_VAR 0 11
29429: PUSH
29430: LD_VAR 0 11
29434: PPUSH
29435: LD_VAR 0 11
29439: PUSH
29440: LD_INT 1
29442: PLUS
29443: PPUSH
29444: LD_VAR 0 9
29448: PUSH
29449: LD_VAR 0 3
29453: ARRAY
29454: PPUSH
29455: CALL_OW 2
29459: ST_TO_ADDR
// tmp := tmp diff sort [ i ] ;
29460: LD_ADDR_VAR 0 4
29464: PUSH
29465: LD_VAR 0 4
29469: PUSH
29470: LD_VAR 0 9
29474: PUSH
29475: LD_VAR 0 3
29479: ARRAY
29480: DIFF
29481: ST_TO_ADDR
// end ;
29482: GO 29391
29484: POP
29485: POP
// if p then
29486: LD_VAR 0 11
29490: IFFALSE 29515
// result := Replace ( result , 3 , p ) ;
29492: LD_ADDR_VAR 0 2
29496: PUSH
29497: LD_VAR 0 2
29501: PPUSH
29502: LD_INT 3
29504: PPUSH
29505: LD_VAR 0 11
29509: PPUSH
29510: CALL_OW 1
29514: ST_TO_ADDR
// end ; if tmp > 6 and eng < 6 then
29515: LD_VAR 0 4
29519: PUSH
29520: LD_INT 6
29522: GREATER
29523: PUSH
29524: LD_VAR 0 6
29528: PUSH
29529: LD_INT 6
29531: LESS
29532: AND
29533: IFFALSE 29727
// begin sort := SortBySkill ( tmp diff ( sci union mech union eng ) , 2 ) ;
29535: LD_ADDR_VAR 0 9
29539: PUSH
29540: LD_VAR 0 4
29544: PUSH
29545: LD_VAR 0 8
29549: PUSH
29550: LD_VAR 0 7
29554: UNION
29555: PUSH
29556: LD_VAR 0 6
29560: UNION
29561: DIFF
29562: PPUSH
29563: LD_INT 2
29565: PPUSH
29566: CALL 89673 0 2
29570: ST_TO_ADDR
// p := [ ] ;
29571: LD_ADDR_VAR 0 11
29575: PUSH
29576: EMPTY
29577: ST_TO_ADDR
// if sort then
29578: LD_VAR 0 9
29582: IFFALSE 29698
// for i = 1 to 6 - eng do
29584: LD_ADDR_VAR 0 3
29588: PUSH
29589: DOUBLE
29590: LD_INT 1
29592: DEC
29593: ST_TO_ADDR
29594: LD_INT 6
29596: PUSH
29597: LD_VAR 0 6
29601: MINUS
29602: PUSH
29603: FOR_TO
29604: IFFALSE 29696
// begin if i = sort then
29606: LD_VAR 0 3
29610: PUSH
29611: LD_VAR 0 9
29615: EQUAL
29616: IFFALSE 29620
// break ;
29618: GO 29696
// if GetClass ( i ) = 2 then
29620: LD_VAR 0 3
29624: PPUSH
29625: CALL_OW 257
29629: PUSH
29630: LD_INT 2
29632: EQUAL
29633: IFFALSE 29637
// continue ;
29635: GO 29603
// p := Insert ( p , p + 1 , sort [ i ] ) ;
29637: LD_ADDR_VAR 0 11
29641: PUSH
29642: LD_VAR 0 11
29646: PPUSH
29647: LD_VAR 0 11
29651: PUSH
29652: LD_INT 1
29654: PLUS
29655: PPUSH
29656: LD_VAR 0 9
29660: PUSH
29661: LD_VAR 0 3
29665: ARRAY
29666: PPUSH
29667: CALL_OW 2
29671: ST_TO_ADDR
// tmp := tmp diff sort [ i ] ;
29672: LD_ADDR_VAR 0 4
29676: PUSH
29677: LD_VAR 0 4
29681: PUSH
29682: LD_VAR 0 9
29686: PUSH
29687: LD_VAR 0 3
29691: ARRAY
29692: DIFF
29693: ST_TO_ADDR
// end ;
29694: GO 29603
29696: POP
29697: POP
// if p then
29698: LD_VAR 0 11
29702: IFFALSE 29727
// result := Replace ( result , 2 , p ) ;
29704: LD_ADDR_VAR 0 2
29708: PUSH
29709: LD_VAR 0 2
29713: PPUSH
29714: LD_INT 2
29716: PPUSH
29717: LD_VAR 0 11
29721: PPUSH
29722: CALL_OW 1
29726: ST_TO_ADDR
// end ; exit ;
29727: GO 31115
// end ; if not mc_tech [ mc_sides [ base ] ] and UnitFilter ( mc_bases [ base ] , [ f_btype , b_factory ] ) and mc_build_list [ base ] then
29729: LD_EXP 107
29733: PUSH
29734: LD_EXP 106
29738: PUSH
29739: LD_VAR 0 1
29743: ARRAY
29744: ARRAY
29745: NOT
29746: PUSH
29747: LD_EXP 80
29751: PUSH
29752: LD_VAR 0 1
29756: ARRAY
29757: PPUSH
29758: LD_INT 30
29760: PUSH
29761: LD_INT 3
29763: PUSH
29764: EMPTY
29765: LIST
29766: LIST
29767: PPUSH
29768: CALL_OW 72
29772: AND
29773: PUSH
29774: LD_EXP 85
29778: PUSH
29779: LD_VAR 0 1
29783: ARRAY
29784: AND
29785: IFFALSE 30393
// begin mc_class_case_use := Replace ( mc_class_case_use , base , 5 ) ;
29787: LD_ADDR_EXP 122
29791: PUSH
29792: LD_EXP 122
29796: PPUSH
29797: LD_VAR 0 1
29801: PPUSH
29802: LD_INT 5
29804: PPUSH
29805: CALL_OW 1
29809: ST_TO_ADDR
// result := [ 0 , 0 , 0 , 0 ] ;
29810: LD_ADDR_VAR 0 2
29814: PUSH
29815: LD_INT 0
29817: PUSH
29818: LD_INT 0
29820: PUSH
29821: LD_INT 0
29823: PUSH
29824: LD_INT 0
29826: PUSH
29827: EMPTY
29828: LIST
29829: LIST
29830: LIST
29831: LIST
29832: ST_TO_ADDR
// if sci > 1 then
29833: LD_VAR 0 8
29837: PUSH
29838: LD_INT 1
29840: GREATER
29841: IFFALSE 29869
// tmp := tmp diff ( sci diff sci [ 1 ] ) ;
29843: LD_ADDR_VAR 0 4
29847: PUSH
29848: LD_VAR 0 4
29852: PUSH
29853: LD_VAR 0 8
29857: PUSH
29858: LD_VAR 0 8
29862: PUSH
29863: LD_INT 1
29865: ARRAY
29866: DIFF
29867: DIFF
29868: ST_TO_ADDR
// if tmp and not sci then
29869: LD_VAR 0 4
29873: PUSH
29874: LD_VAR 0 8
29878: NOT
29879: AND
29880: IFFALSE 29949
// begin sort := SortBySkill ( tmp , 4 ) ;
29882: LD_ADDR_VAR 0 9
29886: PUSH
29887: LD_VAR 0 4
29891: PPUSH
29892: LD_INT 4
29894: PPUSH
29895: CALL 89673 0 2
29899: ST_TO_ADDR
// if sort then
29900: LD_VAR 0 9
29904: IFFALSE 29920
// p := sort [ 1 ] ;
29906: LD_ADDR_VAR 0 11
29910: PUSH
29911: LD_VAR 0 9
29915: PUSH
29916: LD_INT 1
29918: ARRAY
29919: ST_TO_ADDR
// if p then
29920: LD_VAR 0 11
29924: IFFALSE 29949
// result := Replace ( result , 4 , p ) ;
29926: LD_ADDR_VAR 0 2
29930: PUSH
29931: LD_VAR 0 2
29935: PPUSH
29936: LD_INT 4
29938: PPUSH
29939: LD_VAR 0 11
29943: PPUSH
29944: CALL_OW 1
29948: ST_TO_ADDR
// end ; tmp := tmp diff mech ;
29949: LD_ADDR_VAR 0 4
29953: PUSH
29954: LD_VAR 0 4
29958: PUSH
29959: LD_VAR 0 7
29963: DIFF
29964: ST_TO_ADDR
// if tmp and mech < 6 then
29965: LD_VAR 0 4
29969: PUSH
29970: LD_VAR 0 7
29974: PUSH
29975: LD_INT 6
29977: LESS
29978: AND
29979: IFFALSE 30167
// begin sort := SortBySkill ( tmp diff ( sci union mech ) , 3 ) ;
29981: LD_ADDR_VAR 0 9
29985: PUSH
29986: LD_VAR 0 4
29990: PUSH
29991: LD_VAR 0 8
29995: PUSH
29996: LD_VAR 0 7
30000: UNION
30001: DIFF
30002: PPUSH
30003: LD_INT 3
30005: PPUSH
30006: CALL 89673 0 2
30010: ST_TO_ADDR
// p := [ ] ;
30011: LD_ADDR_VAR 0 11
30015: PUSH
30016: EMPTY
30017: ST_TO_ADDR
// if sort then
30018: LD_VAR 0 9
30022: IFFALSE 30138
// for i = 1 to 6 - mech do
30024: LD_ADDR_VAR 0 3
30028: PUSH
30029: DOUBLE
30030: LD_INT 1
30032: DEC
30033: ST_TO_ADDR
30034: LD_INT 6
30036: PUSH
30037: LD_VAR 0 7
30041: MINUS
30042: PUSH
30043: FOR_TO
30044: IFFALSE 30136
// begin if i = sort then
30046: LD_VAR 0 3
30050: PUSH
30051: LD_VAR 0 9
30055: EQUAL
30056: IFFALSE 30060
// break ;
30058: GO 30136
// if GetClass ( i ) = 3 then
30060: LD_VAR 0 3
30064: PPUSH
30065: CALL_OW 257
30069: PUSH
30070: LD_INT 3
30072: EQUAL
30073: IFFALSE 30077
// continue ;
30075: GO 30043
// p := Insert ( p , p + 1 , sort [ i ] ) ;
30077: LD_ADDR_VAR 0 11
30081: PUSH
30082: LD_VAR 0 11
30086: PPUSH
30087: LD_VAR 0 11
30091: PUSH
30092: LD_INT 1
30094: PLUS
30095: PPUSH
30096: LD_VAR 0 9
30100: PUSH
30101: LD_VAR 0 3
30105: ARRAY
30106: PPUSH
30107: CALL_OW 2
30111: ST_TO_ADDR
// tmp := tmp diff sort [ i ] ;
30112: LD_ADDR_VAR 0 4
30116: PUSH
30117: LD_VAR 0 4
30121: PUSH
30122: LD_VAR 0 9
30126: PUSH
30127: LD_VAR 0 3
30131: ARRAY
30132: DIFF
30133: ST_TO_ADDR
// end ;
30134: GO 30043
30136: POP
30137: POP
// if p then
30138: LD_VAR 0 11
30142: IFFALSE 30167
// result := Replace ( result , 3 , p ) ;
30144: LD_ADDR_VAR 0 2
30148: PUSH
30149: LD_VAR 0 2
30153: PPUSH
30154: LD_INT 3
30156: PPUSH
30157: LD_VAR 0 11
30161: PPUSH
30162: CALL_OW 1
30166: ST_TO_ADDR
// end ; tmp := tmp diff eng ;
30167: LD_ADDR_VAR 0 4
30171: PUSH
30172: LD_VAR 0 4
30176: PUSH
30177: LD_VAR 0 6
30181: DIFF
30182: ST_TO_ADDR
// if tmp and eng < 6 then
30183: LD_VAR 0 4
30187: PUSH
30188: LD_VAR 0 6
30192: PUSH
30193: LD_INT 6
30195: LESS
30196: AND
30197: IFFALSE 30391
// begin sort := SortBySkill ( tmp diff ( sci union mech union eng ) , 2 ) ;
30199: LD_ADDR_VAR 0 9
30203: PUSH
30204: LD_VAR 0 4
30208: PUSH
30209: LD_VAR 0 8
30213: PUSH
30214: LD_VAR 0 7
30218: UNION
30219: PUSH
30220: LD_VAR 0 6
30224: UNION
30225: DIFF
30226: PPUSH
30227: LD_INT 2
30229: PPUSH
30230: CALL 89673 0 2
30234: ST_TO_ADDR
// p := [ ] ;
30235: LD_ADDR_VAR 0 11
30239: PUSH
30240: EMPTY
30241: ST_TO_ADDR
// if sort then
30242: LD_VAR 0 9
30246: IFFALSE 30362
// for i = 1 to 6 - eng do
30248: LD_ADDR_VAR 0 3
30252: PUSH
30253: DOUBLE
30254: LD_INT 1
30256: DEC
30257: ST_TO_ADDR
30258: LD_INT 6
30260: PUSH
30261: LD_VAR 0 6
30265: MINUS
30266: PUSH
30267: FOR_TO
30268: IFFALSE 30360
// begin if i = sort then
30270: LD_VAR 0 3
30274: PUSH
30275: LD_VAR 0 9
30279: EQUAL
30280: IFFALSE 30284
// break ;
30282: GO 30360
// if GetClass ( i ) = 2 then
30284: LD_VAR 0 3
30288: PPUSH
30289: CALL_OW 257
30293: PUSH
30294: LD_INT 2
30296: EQUAL
30297: IFFALSE 30301
// continue ;
30299: GO 30267
// p := Insert ( p , p + 1 , sort [ i ] ) ;
30301: LD_ADDR_VAR 0 11
30305: PUSH
30306: LD_VAR 0 11
30310: PPUSH
30311: LD_VAR 0 11
30315: PUSH
30316: LD_INT 1
30318: PLUS
30319: PPUSH
30320: LD_VAR 0 9
30324: PUSH
30325: LD_VAR 0 3
30329: ARRAY
30330: PPUSH
30331: CALL_OW 2
30335: ST_TO_ADDR
// tmp := tmp diff sort [ i ] ;
30336: LD_ADDR_VAR 0 4
30340: PUSH
30341: LD_VAR 0 4
30345: PUSH
30346: LD_VAR 0 9
30350: PUSH
30351: LD_VAR 0 3
30355: ARRAY
30356: DIFF
30357: ST_TO_ADDR
// end ;
30358: GO 30267
30360: POP
30361: POP
// if p then
30362: LD_VAR 0 11
30366: IFFALSE 30391
// result := Replace ( result , 2 , p ) ;
30368: LD_ADDR_VAR 0 2
30372: PUSH
30373: LD_VAR 0 2
30377: PPUSH
30378: LD_INT 2
30380: PPUSH
30381: LD_VAR 0 11
30385: PPUSH
30386: CALL_OW 1
30390: ST_TO_ADDR
// end ; exit ;
30391: GO 31115
// end ; if not mc_tech [ mc_sides [ base ] ] and UnitFilter ( mc_bases [ base ] , [ f_btype , b_factory ] ) and not mc_build_list [ base ] then
30393: LD_EXP 107
30397: PUSH
30398: LD_EXP 106
30402: PUSH
30403: LD_VAR 0 1
30407: ARRAY
30408: ARRAY
30409: NOT
30410: PUSH
30411: LD_EXP 80
30415: PUSH
30416: LD_VAR 0 1
30420: ARRAY
30421: PPUSH
30422: LD_INT 30
30424: PUSH
30425: LD_INT 3
30427: PUSH
30428: EMPTY
30429: LIST
30430: LIST
30431: PPUSH
30432: CALL_OW 72
30436: AND
30437: PUSH
30438: LD_EXP 85
30442: PUSH
30443: LD_VAR 0 1
30447: ARRAY
30448: NOT
30449: AND
30450: IFFALSE 31115
// begin mc_class_case_use := Replace ( mc_class_case_use , base , 6 ) ;
30452: LD_ADDR_EXP 122
30456: PUSH
30457: LD_EXP 122
30461: PPUSH
30462: LD_VAR 0 1
30466: PPUSH
30467: LD_INT 6
30469: PPUSH
30470: CALL_OW 1
30474: ST_TO_ADDR
// result := [ 0 , 0 , 0 , 0 ] ;
30475: LD_ADDR_VAR 0 2
30479: PUSH
30480: LD_INT 0
30482: PUSH
30483: LD_INT 0
30485: PUSH
30486: LD_INT 0
30488: PUSH
30489: LD_INT 0
30491: PUSH
30492: EMPTY
30493: LIST
30494: LIST
30495: LIST
30496: LIST
30497: ST_TO_ADDR
// if sci >= 1 then
30498: LD_VAR 0 8
30502: PUSH
30503: LD_INT 1
30505: GREATEREQUAL
30506: IFFALSE 30528
// tmp := tmp diff sci [ 1 ] ;
30508: LD_ADDR_VAR 0 4
30512: PUSH
30513: LD_VAR 0 4
30517: PUSH
30518: LD_VAR 0 8
30522: PUSH
30523: LD_INT 1
30525: ARRAY
30526: DIFF
30527: ST_TO_ADDR
// if tmp and not sci then
30528: LD_VAR 0 4
30532: PUSH
30533: LD_VAR 0 8
30537: NOT
30538: AND
30539: IFFALSE 30608
// begin sort := SortBySkill ( tmp , 4 ) ;
30541: LD_ADDR_VAR 0 9
30545: PUSH
30546: LD_VAR 0 4
30550: PPUSH
30551: LD_INT 4
30553: PPUSH
30554: CALL 89673 0 2
30558: ST_TO_ADDR
// if sort then
30559: LD_VAR 0 9
30563: IFFALSE 30579
// p := sort [ 1 ] ;
30565: LD_ADDR_VAR 0 11
30569: PUSH
30570: LD_VAR 0 9
30574: PUSH
30575: LD_INT 1
30577: ARRAY
30578: ST_TO_ADDR
// if p then
30579: LD_VAR 0 11
30583: IFFALSE 30608
// result := Replace ( result , 4 , p ) ;
30585: LD_ADDR_VAR 0 2
30589: PUSH
30590: LD_VAR 0 2
30594: PPUSH
30595: LD_INT 4
30597: PPUSH
30598: LD_VAR 0 11
30602: PPUSH
30603: CALL_OW 1
30607: ST_TO_ADDR
// end ; tmp := tmp diff mech ;
30608: LD_ADDR_VAR 0 4
30612: PUSH
30613: LD_VAR 0 4
30617: PUSH
30618: LD_VAR 0 7
30622: DIFF
30623: ST_TO_ADDR
// if tmp and mech < 6 then
30624: LD_VAR 0 4
30628: PUSH
30629: LD_VAR 0 7
30633: PUSH
30634: LD_INT 6
30636: LESS
30637: AND
30638: IFFALSE 30820
// begin sort := SortBySkill ( tmp diff mech , 3 ) ;
30640: LD_ADDR_VAR 0 9
30644: PUSH
30645: LD_VAR 0 4
30649: PUSH
30650: LD_VAR 0 7
30654: DIFF
30655: PPUSH
30656: LD_INT 3
30658: PPUSH
30659: CALL 89673 0 2
30663: ST_TO_ADDR
// p := [ ] ;
30664: LD_ADDR_VAR 0 11
30668: PUSH
30669: EMPTY
30670: ST_TO_ADDR
// if sort then
30671: LD_VAR 0 9
30675: IFFALSE 30791
// for i = 1 to 6 - mech do
30677: LD_ADDR_VAR 0 3
30681: PUSH
30682: DOUBLE
30683: LD_INT 1
30685: DEC
30686: ST_TO_ADDR
30687: LD_INT 6
30689: PUSH
30690: LD_VAR 0 7
30694: MINUS
30695: PUSH
30696: FOR_TO
30697: IFFALSE 30789
// begin if i = sort then
30699: LD_VAR 0 3
30703: PUSH
30704: LD_VAR 0 9
30708: EQUAL
30709: IFFALSE 30713
// break ;
30711: GO 30789
// if GetClass ( i ) = 3 then
30713: LD_VAR 0 3
30717: PPUSH
30718: CALL_OW 257
30722: PUSH
30723: LD_INT 3
30725: EQUAL
30726: IFFALSE 30730
// continue ;
30728: GO 30696
// p := Insert ( p , p + 1 , sort [ i ] ) ;
30730: LD_ADDR_VAR 0 11
30734: PUSH
30735: LD_VAR 0 11
30739: PPUSH
30740: LD_VAR 0 11
30744: PUSH
30745: LD_INT 1
30747: PLUS
30748: PPUSH
30749: LD_VAR 0 9
30753: PUSH
30754: LD_VAR 0 3
30758: ARRAY
30759: PPUSH
30760: CALL_OW 2
30764: ST_TO_ADDR
// tmp := tmp diff sort [ i ] ;
30765: LD_ADDR_VAR 0 4
30769: PUSH
30770: LD_VAR 0 4
30774: PUSH
30775: LD_VAR 0 9
30779: PUSH
30780: LD_VAR 0 3
30784: ARRAY
30785: DIFF
30786: ST_TO_ADDR
// end ;
30787: GO 30696
30789: POP
30790: POP
// if p then
30791: LD_VAR 0 11
30795: IFFALSE 30820
// result := Replace ( result , 3 , p ) ;
30797: LD_ADDR_VAR 0 2
30801: PUSH
30802: LD_VAR 0 2
30806: PPUSH
30807: LD_INT 3
30809: PPUSH
30810: LD_VAR 0 11
30814: PPUSH
30815: CALL_OW 1
30819: ST_TO_ADDR
// end ; tmp := tmp diff eng ;
30820: LD_ADDR_VAR 0 4
30824: PUSH
30825: LD_VAR 0 4
30829: PUSH
30830: LD_VAR 0 6
30834: DIFF
30835: ST_TO_ADDR
// if tmp and eng < 4 then
30836: LD_VAR 0 4
30840: PUSH
30841: LD_VAR 0 6
30845: PUSH
30846: LD_INT 4
30848: LESS
30849: AND
30850: IFFALSE 31040
// begin sort := SortBySkill ( tmp diff ( mech union eng ) , 2 ) ;
30852: LD_ADDR_VAR 0 9
30856: PUSH
30857: LD_VAR 0 4
30861: PUSH
30862: LD_VAR 0 7
30866: PUSH
30867: LD_VAR 0 6
30871: UNION
30872: DIFF
30873: PPUSH
30874: LD_INT 2
30876: PPUSH
30877: CALL 89673 0 2
30881: ST_TO_ADDR
// p := [ ] ;
30882: LD_ADDR_VAR 0 11
30886: PUSH
30887: EMPTY
30888: ST_TO_ADDR
// if sort then
30889: LD_VAR 0 9
30893: IFFALSE 31009
// for i = 1 to 4 - eng do
30895: LD_ADDR_VAR 0 3
30899: PUSH
30900: DOUBLE
30901: LD_INT 1
30903: DEC
30904: ST_TO_ADDR
30905: LD_INT 4
30907: PUSH
30908: LD_VAR 0 6
30912: MINUS
30913: PUSH
30914: FOR_TO
30915: IFFALSE 31007
// begin if i = sort then
30917: LD_VAR 0 3
30921: PUSH
30922: LD_VAR 0 9
30926: EQUAL
30927: IFFALSE 30931
// break ;
30929: GO 31007
// if GetClass ( i ) = 2 then
30931: LD_VAR 0 3
30935: PPUSH
30936: CALL_OW 257
30940: PUSH
30941: LD_INT 2
30943: EQUAL
30944: IFFALSE 30948
// continue ;
30946: GO 30914
// p := Insert ( p , p + 1 , sort [ i ] ) ;
30948: LD_ADDR_VAR 0 11
30952: PUSH
30953: LD_VAR 0 11
30957: PPUSH
30958: LD_VAR 0 11
30962: PUSH
30963: LD_INT 1
30965: PLUS
30966: PPUSH
30967: LD_VAR 0 9
30971: PUSH
30972: LD_VAR 0 3
30976: ARRAY
30977: PPUSH
30978: CALL_OW 2
30982: ST_TO_ADDR
// tmp := tmp diff sort [ i ] ;
30983: LD_ADDR_VAR 0 4
30987: PUSH
30988: LD_VAR 0 4
30992: PUSH
30993: LD_VAR 0 9
30997: PUSH
30998: LD_VAR 0 3
31002: ARRAY
31003: DIFF
31004: ST_TO_ADDR
// end ;
31005: GO 30914
31007: POP
31008: POP
// if p then
31009: LD_VAR 0 11
31013: IFFALSE 31038
// result := Replace ( result , 2 , p ) ;
31015: LD_ADDR_VAR 0 2
31019: PUSH
31020: LD_VAR 0 2
31024: PPUSH
31025: LD_INT 2
31027: PPUSH
31028: LD_VAR 0 11
31032: PPUSH
31033: CALL_OW 1
31037: ST_TO_ADDR
// end else
31038: GO 31084
// for i = eng downto 5 do
31040: LD_ADDR_VAR 0 3
31044: PUSH
31045: DOUBLE
31046: LD_VAR 0 6
31050: INC
31051: ST_TO_ADDR
31052: LD_INT 5
31054: PUSH
31055: FOR_DOWNTO
31056: IFFALSE 31082
// tmp := tmp union eng [ i ] ;
31058: LD_ADDR_VAR 0 4
31062: PUSH
31063: LD_VAR 0 4
31067: PUSH
31068: LD_VAR 0 6
31072: PUSH
31073: LD_VAR 0 3
31077: ARRAY
31078: UNION
31079: ST_TO_ADDR
31080: GO 31055
31082: POP
31083: POP
// result := Replace ( result , 1 , tmp diff sol ) ;
31084: LD_ADDR_VAR 0 2
31088: PUSH
31089: LD_VAR 0 2
31093: PPUSH
31094: LD_INT 1
31096: PPUSH
31097: LD_VAR 0 4
31101: PUSH
31102: LD_VAR 0 5
31106: DIFF
31107: PPUSH
31108: CALL_OW 1
31112: ST_TO_ADDR
// exit ;
31113: GO 31115
// end ; end ;
31115: LD_VAR 0 2
31119: RET
// export function MC_CheckBuildings ( ) ; var i , tmp ; begin
31120: LD_INT 0
31122: PPUSH
31123: PPUSH
31124: PPUSH
// if not mc_bases then
31125: LD_EXP 80
31129: NOT
31130: IFFALSE 31134
// exit ;
31132: GO 31276
// for i = 1 to mc_bases do
31134: LD_ADDR_VAR 0 2
31138: PUSH
31139: DOUBLE
31140: LD_INT 1
31142: DEC
31143: ST_TO_ADDR
31144: LD_EXP 80
31148: PUSH
31149: FOR_TO
31150: IFFALSE 31267
// begin tmp := UnitFilter ( mc_bases [ i ] , [ [ f_type , unit_building ] , [ f_not , [ f_or , [ f_btype , b_oil_mine ] , [ f_btype , b_siberite_mine ] ] ] , [ f_not , [ f_lives , 1000 ] ] ] ) ;
31152: LD_ADDR_VAR 0 3
31156: PUSH
31157: LD_EXP 80
31161: PUSH
31162: LD_VAR 0 2
31166: ARRAY
31167: PPUSH
31168: LD_INT 21
31170: PUSH
31171: LD_INT 3
31173: PUSH
31174: EMPTY
31175: LIST
31176: LIST
31177: PUSH
31178: LD_INT 3
31180: PUSH
31181: LD_INT 2
31183: PUSH
31184: LD_INT 30
31186: PUSH
31187: LD_INT 29
31189: PUSH
31190: EMPTY
31191: LIST
31192: LIST
31193: PUSH
31194: LD_INT 30
31196: PUSH
31197: LD_INT 30
31199: PUSH
31200: EMPTY
31201: LIST
31202: LIST
31203: PUSH
31204: EMPTY
31205: LIST
31206: LIST
31207: LIST
31208: PUSH
31209: EMPTY
31210: LIST
31211: LIST
31212: PUSH
31213: LD_INT 3
31215: PUSH
31216: LD_INT 24
31218: PUSH
31219: LD_INT 1000
31221: PUSH
31222: EMPTY
31223: LIST
31224: LIST
31225: PUSH
31226: EMPTY
31227: LIST
31228: LIST
31229: PUSH
31230: EMPTY
31231: LIST
31232: LIST
31233: LIST
31234: PPUSH
31235: CALL_OW 72
31239: ST_TO_ADDR
// mc_building_need_repair := Replace ( mc_building_need_repair , i , tmp ) ;
31240: LD_ADDR_EXP 81
31244: PUSH
31245: LD_EXP 81
31249: PPUSH
31250: LD_VAR 0 2
31254: PPUSH
31255: LD_VAR 0 3
31259: PPUSH
31260: CALL_OW 1
31264: ST_TO_ADDR
// end ;
31265: GO 31149
31267: POP
31268: POP
// RaiseSailEvent ( 101 ) ;
31269: LD_INT 101
31271: PPUSH
31272: CALL_OW 427
// end ;
31276: LD_VAR 0 1
31280: RET
// export function MC_CheckPeopleLife ( ) ; var i , j , k , tmp , need_heal_1 , need_heal_2 ; begin
31281: LD_INT 0
31283: PPUSH
31284: PPUSH
31285: PPUSH
31286: PPUSH
31287: PPUSH
31288: PPUSH
31289: PPUSH
// if not mc_bases then
31290: LD_EXP 80
31294: NOT
31295: IFFALSE 31299
// exit ;
31297: GO 31861
// for i = 1 to mc_bases do
31299: LD_ADDR_VAR 0 2
31303: PUSH
31304: DOUBLE
31305: LD_INT 1
31307: DEC
31308: ST_TO_ADDR
31309: LD_EXP 80
31313: PUSH
31314: FOR_TO
31315: IFFALSE 31852
// begin tmp := UnitFilter ( mc_bases [ i ] union mc_ape [ i ] , [ [ f_type , unit_human ] , [ f_and , [ f_not , [ f_inside ] ] , [ f_not , [ f_lives , 1000 ] ] ] ] ) ;
31317: LD_ADDR_VAR 0 5
31321: PUSH
31322: LD_EXP 80
31326: PUSH
31327: LD_VAR 0 2
31331: ARRAY
31332: PUSH
31333: LD_EXP 109
31337: PUSH
31338: LD_VAR 0 2
31342: ARRAY
31343: UNION
31344: PPUSH
31345: LD_INT 21
31347: PUSH
31348: LD_INT 1
31350: PUSH
31351: EMPTY
31352: LIST
31353: LIST
31354: PUSH
31355: LD_INT 1
31357: PUSH
31358: LD_INT 3
31360: PUSH
31361: LD_INT 54
31363: PUSH
31364: EMPTY
31365: LIST
31366: PUSH
31367: EMPTY
31368: LIST
31369: LIST
31370: PUSH
31371: LD_INT 3
31373: PUSH
31374: LD_INT 24
31376: PUSH
31377: LD_INT 1000
31379: PUSH
31380: EMPTY
31381: LIST
31382: LIST
31383: PUSH
31384: EMPTY
31385: LIST
31386: LIST
31387: PUSH
31388: EMPTY
31389: LIST
31390: LIST
31391: LIST
31392: PUSH
31393: EMPTY
31394: LIST
31395: LIST
31396: PPUSH
31397: CALL_OW 72
31401: ST_TO_ADDR
// need_heal_1 := UnitFilter ( mc_bases [ i ] , [ [ f_type , unit_human ] , [ f_and , [ f_not , [ f_inside ] ] , [ f_not , [ f_lives , 250 ] ] ] ] ) ;
31402: LD_ADDR_VAR 0 6
31406: PUSH
31407: LD_EXP 80
31411: PUSH
31412: LD_VAR 0 2
31416: ARRAY
31417: PPUSH
31418: LD_INT 21
31420: PUSH
31421: LD_INT 1
31423: PUSH
31424: EMPTY
31425: LIST
31426: LIST
31427: PUSH
31428: LD_INT 1
31430: PUSH
31431: LD_INT 3
31433: PUSH
31434: LD_INT 54
31436: PUSH
31437: EMPTY
31438: LIST
31439: PUSH
31440: EMPTY
31441: LIST
31442: LIST
31443: PUSH
31444: LD_INT 3
31446: PUSH
31447: LD_INT 24
31449: PUSH
31450: LD_INT 250
31452: PUSH
31453: EMPTY
31454: LIST
31455: LIST
31456: PUSH
31457: EMPTY
31458: LIST
31459: LIST
31460: PUSH
31461: EMPTY
31462: LIST
31463: LIST
31464: LIST
31465: PUSH
31466: EMPTY
31467: LIST
31468: LIST
31469: PPUSH
31470: CALL_OW 72
31474: ST_TO_ADDR
// need_heal_2 := tmp diff need_heal_1 ;
31475: LD_ADDR_VAR 0 7
31479: PUSH
31480: LD_VAR 0 5
31484: PUSH
31485: LD_VAR 0 6
31489: DIFF
31490: ST_TO_ADDR
// if not need_heal_1 then
31491: LD_VAR 0 6
31495: NOT
31496: IFFALSE 31529
// mc_need_heal := ReplaceIn ( mc_need_heal , [ i , 1 ] , [ ] ) else
31498: LD_ADDR_EXP 83
31502: PUSH
31503: LD_EXP 83
31507: PPUSH
31508: LD_VAR 0 2
31512: PUSH
31513: LD_INT 1
31515: PUSH
31516: EMPTY
31517: LIST
31518: LIST
31519: PPUSH
31520: EMPTY
31521: PPUSH
31522: CALL 58440 0 3
31526: ST_TO_ADDR
31527: GO 31599
// mc_need_heal := ReplaceIn ( mc_need_heal , [ i , 1 ] , UnitFilter ( mc_need_heal [ i ] [ 1 ] , [ f_not , [ f_lives , 1000 ] ] ) union need_heal_1 ) ;
31529: LD_ADDR_EXP 83
31533: PUSH
31534: LD_EXP 83
31538: PPUSH
31539: LD_VAR 0 2
31543: PUSH
31544: LD_INT 1
31546: PUSH
31547: EMPTY
31548: LIST
31549: LIST
31550: PPUSH
31551: LD_EXP 83
31555: PUSH
31556: LD_VAR 0 2
31560: ARRAY
31561: PUSH
31562: LD_INT 1
31564: ARRAY
31565: PPUSH
31566: LD_INT 3
31568: PUSH
31569: LD_INT 24
31571: PUSH
31572: LD_INT 1000
31574: PUSH
31575: EMPTY
31576: LIST
31577: LIST
31578: PUSH
31579: EMPTY
31580: LIST
31581: LIST
31582: PPUSH
31583: CALL_OW 72
31587: PUSH
31588: LD_VAR 0 6
31592: UNION
31593: PPUSH
31594: CALL 58440 0 3
31598: ST_TO_ADDR
// if not need_heal_2 then
31599: LD_VAR 0 7
31603: NOT
31604: IFFALSE 31637
// mc_need_heal := ReplaceIn ( mc_need_heal , [ i , 2 ] , [ ] ) else
31606: LD_ADDR_EXP 83
31610: PUSH
31611: LD_EXP 83
31615: PPUSH
31616: LD_VAR 0 2
31620: PUSH
31621: LD_INT 2
31623: PUSH
31624: EMPTY
31625: LIST
31626: LIST
31627: PPUSH
31628: EMPTY
31629: PPUSH
31630: CALL 58440 0 3
31634: ST_TO_ADDR
31635: GO 31669
// mc_need_heal := ReplaceIn ( mc_need_heal , [ i , 2 ] , need_heal_2 ) ;
31637: LD_ADDR_EXP 83
31641: PUSH
31642: LD_EXP 83
31646: PPUSH
31647: LD_VAR 0 2
31651: PUSH
31652: LD_INT 2
31654: PUSH
31655: EMPTY
31656: LIST
31657: LIST
31658: PPUSH
31659: LD_VAR 0 7
31663: PPUSH
31664: CALL 58440 0 3
31668: ST_TO_ADDR
// if need_heal_2 then
31669: LD_VAR 0 7
31673: IFFALSE 31834
// for j in need_heal_2 do
31675: LD_ADDR_VAR 0 3
31679: PUSH
31680: LD_VAR 0 7
31684: PUSH
31685: FOR_IN
31686: IFFALSE 31832
// begin tmp := UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_lab ] , [ f_btype , b_lab_half ] , [ f_btype , b_lab_full ] , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) ;
31688: LD_ADDR_VAR 0 5
31692: PUSH
31693: LD_EXP 80
31697: PUSH
31698: LD_VAR 0 2
31702: ARRAY
31703: PPUSH
31704: LD_INT 2
31706: PUSH
31707: LD_INT 30
31709: PUSH
31710: LD_INT 6
31712: PUSH
31713: EMPTY
31714: LIST
31715: LIST
31716: PUSH
31717: LD_INT 30
31719: PUSH
31720: LD_INT 7
31722: PUSH
31723: EMPTY
31724: LIST
31725: LIST
31726: PUSH
31727: LD_INT 30
31729: PUSH
31730: LD_INT 8
31732: PUSH
31733: EMPTY
31734: LIST
31735: LIST
31736: PUSH
31737: LD_INT 30
31739: PUSH
31740: LD_INT 0
31742: PUSH
31743: EMPTY
31744: LIST
31745: LIST
31746: PUSH
31747: LD_INT 30
31749: PUSH
31750: LD_INT 1
31752: PUSH
31753: EMPTY
31754: LIST
31755: LIST
31756: PUSH
31757: EMPTY
31758: LIST
31759: LIST
31760: LIST
31761: LIST
31762: LIST
31763: LIST
31764: PPUSH
31765: CALL_OW 72
31769: ST_TO_ADDR
// if tmp then
31770: LD_VAR 0 5
31774: IFFALSE 31830
// begin k := NearestUnitToUnit ( tmp , j ) ;
31776: LD_ADDR_VAR 0 4
31780: PUSH
31781: LD_VAR 0 5
31785: PPUSH
31786: LD_VAR 0 3
31790: PPUSH
31791: CALL_OW 74
31795: ST_TO_ADDR
// if GetDistUnits ( j , k ) > 5 then
31796: LD_VAR 0 3
31800: PPUSH
31801: LD_VAR 0 4
31805: PPUSH
31806: CALL_OW 296
31810: PUSH
31811: LD_INT 5
31813: GREATER
31814: IFFALSE 31830
// ComMoveToNearbyEntrance ( j , k ) ;
31816: LD_VAR 0 3
31820: PPUSH
31821: LD_VAR 0 4
31825: PPUSH
31826: CALL 92046 0 2
// end ; end ;
31830: GO 31685
31832: POP
31833: POP
// if not need_heal_1 and not need_heal_2 then
31834: LD_VAR 0 6
31838: NOT
31839: PUSH
31840: LD_VAR 0 7
31844: NOT
31845: AND
31846: IFFALSE 31850
// continue ;
31848: GO 31314
// end ;
31850: GO 31314
31852: POP
31853: POP
// RaiseSailEvent ( 102 ) ;
31854: LD_INT 102
31856: PPUSH
31857: CALL_OW 427
// end ;
31861: LD_VAR 0 1
31865: RET
// export function MC_RepairBuildings ( ) ; var i , j , un , tmp , cranes , to_repair_tmp , to_repair ; begin
31866: LD_INT 0
31868: PPUSH
31869: PPUSH
31870: PPUSH
31871: PPUSH
31872: PPUSH
31873: PPUSH
31874: PPUSH
31875: PPUSH
// if not mc_bases then
31876: LD_EXP 80
31880: NOT
31881: IFFALSE 31885
// exit ;
31883: GO 32796
// for i = 1 to mc_bases do
31885: LD_ADDR_VAR 0 2
31889: PUSH
31890: DOUBLE
31891: LD_INT 1
31893: DEC
31894: ST_TO_ADDR
31895: LD_EXP 80
31899: PUSH
31900: FOR_TO
31901: IFFALSE 32794
// begin if not mc_building_need_repair [ i ] then
31903: LD_EXP 81
31907: PUSH
31908: LD_VAR 0 2
31912: ARRAY
31913: NOT
31914: IFFALSE 32099
// begin cranes := UnitFilter ( mc_vehicles [ i ] , [ [ f_not , [ f_lives , 1000 ] ] , [ f_or , [ f_weapon , us_crane ] , [ f_weapon , ru_crane ] , [ f_weapon , ar_crane ] ] ] ) ;
31916: LD_ADDR_VAR 0 6
31920: PUSH
31921: LD_EXP 99
31925: PUSH
31926: LD_VAR 0 2
31930: ARRAY
31931: PPUSH
31932: LD_INT 3
31934: PUSH
31935: LD_INT 24
31937: PUSH
31938: LD_INT 1000
31940: PUSH
31941: EMPTY
31942: LIST
31943: LIST
31944: PUSH
31945: EMPTY
31946: LIST
31947: LIST
31948: PUSH
31949: LD_INT 2
31951: PUSH
31952: LD_INT 34
31954: PUSH
31955: LD_INT 13
31957: PUSH
31958: EMPTY
31959: LIST
31960: LIST
31961: PUSH
31962: LD_INT 34
31964: PUSH
31965: LD_INT 52
31967: PUSH
31968: EMPTY
31969: LIST
31970: LIST
31971: PUSH
31972: LD_INT 34
31974: PUSH
31975: LD_INT 88
31977: PUSH
31978: EMPTY
31979: LIST
31980: LIST
31981: PUSH
31982: EMPTY
31983: LIST
31984: LIST
31985: LIST
31986: LIST
31987: PUSH
31988: EMPTY
31989: LIST
31990: LIST
31991: PPUSH
31992: CALL_OW 72
31996: ST_TO_ADDR
// if cranes then
31997: LD_VAR 0 6
32001: IFFALSE 32063
// for j in cranes do
32003: LD_ADDR_VAR 0 3
32007: PUSH
32008: LD_VAR 0 6
32012: PUSH
32013: FOR_IN
32014: IFFALSE 32061
// if not IsInArea ( j , mc_parking [ i ] ) then
32016: LD_VAR 0 3
32020: PPUSH
32021: LD_EXP 104
32025: PUSH
32026: LD_VAR 0 2
32030: ARRAY
32031: PPUSH
32032: CALL_OW 308
32036: NOT
32037: IFFALSE 32059
// ComMoveToArea ( j , mc_parking [ i ] ) ;
32039: LD_VAR 0 3
32043: PPUSH
32044: LD_EXP 104
32048: PUSH
32049: LD_VAR 0 2
32053: ARRAY
32054: PPUSH
32055: CALL_OW 113
32059: GO 32013
32061: POP
32062: POP
// mc_building_repairs := Replace ( mc_building_repairs , i , [ ] ) ;
32063: LD_ADDR_EXP 82
32067: PUSH
32068: LD_EXP 82
32072: PPUSH
32073: LD_VAR 0 2
32077: PPUSH
32078: EMPTY
32079: PPUSH
32080: CALL_OW 1
32084: ST_TO_ADDR
// MC_Reset ( i , 101 ) ;
32085: LD_VAR 0 2
32089: PPUSH
32090: LD_INT 101
32092: PPUSH
32093: CALL 26939 0 2
// continue ;
32097: GO 31900
// end ; mc_builders := Replace ( mc_builders , i , [ ] ) ;
32099: LD_ADDR_EXP 86
32103: PUSH
32104: LD_EXP 86
32108: PPUSH
32109: LD_VAR 0 2
32113: PPUSH
32114: EMPTY
32115: PPUSH
32116: CALL_OW 1
32120: ST_TO_ADDR
// MC_Reset ( i , 103 ) ;
32121: LD_VAR 0 2
32125: PPUSH
32126: LD_INT 103
32128: PPUSH
32129: CALL 26939 0 2
// tmp := UnitFilter ( mc_bases [ i ] union mc_ape [ i ] , [ [ f_or , [ f_class , 2 ] , [ f_class , 16 ] ] ] ) ;
32133: LD_ADDR_VAR 0 5
32137: PUSH
32138: LD_EXP 80
32142: PUSH
32143: LD_VAR 0 2
32147: ARRAY
32148: PUSH
32149: LD_EXP 109
32153: PUSH
32154: LD_VAR 0 2
32158: ARRAY
32159: UNION
32160: PPUSH
32161: LD_INT 2
32163: PUSH
32164: LD_INT 25
32166: PUSH
32167: LD_INT 2
32169: PUSH
32170: EMPTY
32171: LIST
32172: LIST
32173: PUSH
32174: LD_INT 25
32176: PUSH
32177: LD_INT 16
32179: PUSH
32180: EMPTY
32181: LIST
32182: LIST
32183: PUSH
32184: EMPTY
32185: LIST
32186: LIST
32187: LIST
32188: PUSH
32189: EMPTY
32190: LIST
32191: PPUSH
32192: CALL_OW 72
32196: ST_TO_ADDR
// if mc_need_heal [ i ] then
32197: LD_EXP 83
32201: PUSH
32202: LD_VAR 0 2
32206: ARRAY
32207: IFFALSE 32251
// tmp := tmp diff ( mc_need_heal [ i ] [ 1 ] union mc_need_heal [ i ] [ 2 ] ) ;
32209: LD_ADDR_VAR 0 5
32213: PUSH
32214: LD_VAR 0 5
32218: PUSH
32219: LD_EXP 83
32223: PUSH
32224: LD_VAR 0 2
32228: ARRAY
32229: PUSH
32230: LD_INT 1
32232: ARRAY
32233: PUSH
32234: LD_EXP 83
32238: PUSH
32239: LD_VAR 0 2
32243: ARRAY
32244: PUSH
32245: LD_INT 2
32247: ARRAY
32248: UNION
32249: DIFF
32250: ST_TO_ADDR
// cranes := UnitFilter ( mc_vehicles [ i ] , [ f_or , [ f_weapon , us_crane ] , [ f_weapon , ru_crane ] , [ f_weapon , ar_crane ] ] ) ;
32251: LD_ADDR_VAR 0 6
32255: PUSH
32256: LD_EXP 99
32260: PUSH
32261: LD_VAR 0 2
32265: ARRAY
32266: PPUSH
32267: LD_INT 2
32269: PUSH
32270: LD_INT 34
32272: PUSH
32273: LD_INT 13
32275: PUSH
32276: EMPTY
32277: LIST
32278: LIST
32279: PUSH
32280: LD_INT 34
32282: PUSH
32283: LD_INT 52
32285: PUSH
32286: EMPTY
32287: LIST
32288: LIST
32289: PUSH
32290: LD_INT 34
32292: PUSH
32293: LD_INT 88
32295: PUSH
32296: EMPTY
32297: LIST
32298: LIST
32299: PUSH
32300: EMPTY
32301: LIST
32302: LIST
32303: LIST
32304: LIST
32305: PPUSH
32306: CALL_OW 72
32310: ST_TO_ADDR
// if cranes then
32311: LD_VAR 0 6
32315: IFFALSE 32483
// begin for j in cranes do
32317: LD_ADDR_VAR 0 3
32321: PUSH
32322: LD_VAR 0 6
32326: PUSH
32327: FOR_IN
32328: IFFALSE 32481
// begin if GetLives ( j ) = 1000 and not HasTask ( j ) then
32330: LD_VAR 0 3
32334: PPUSH
32335: CALL_OW 256
32339: PUSH
32340: LD_INT 1000
32342: EQUAL
32343: PUSH
32344: LD_VAR 0 3
32348: PPUSH
32349: CALL_OW 314
32353: NOT
32354: AND
32355: IFFALSE 32421
// begin to_repair := NearestUnitToUnit ( mc_building_need_repair [ i ] , j ) ;
32357: LD_ADDR_VAR 0 8
32361: PUSH
32362: LD_EXP 81
32366: PUSH
32367: LD_VAR 0 2
32371: ARRAY
32372: PPUSH
32373: LD_VAR 0 3
32377: PPUSH
32378: CALL_OW 74
32382: ST_TO_ADDR
// if DangerAtRange ( to_repair , 16 ) [ 4 ] < 10 then
32383: LD_VAR 0 8
32387: PPUSH
32388: LD_INT 16
32390: PPUSH
32391: CALL 61405 0 2
32395: PUSH
32396: LD_INT 4
32398: ARRAY
32399: PUSH
32400: LD_INT 10
32402: LESS
32403: IFFALSE 32419
// ComRepairBuilding ( j , to_repair ) ;
32405: LD_VAR 0 3
32409: PPUSH
32410: LD_VAR 0 8
32414: PPUSH
32415: CALL_OW 130
// end else
32419: GO 32479
// if GetLives ( j ) < 500 and not IsInArea ( j , mc_parking [ i ] ) then
32421: LD_VAR 0 3
32425: PPUSH
32426: CALL_OW 256
32430: PUSH
32431: LD_INT 500
32433: LESS
32434: PUSH
32435: LD_VAR 0 3
32439: PPUSH
32440: LD_EXP 104
32444: PUSH
32445: LD_VAR 0 2
32449: ARRAY
32450: PPUSH
32451: CALL_OW 308
32455: NOT
32456: AND
32457: IFFALSE 32479
// ComMoveToArea ( j , mc_parking [ i ] ) ;
32459: LD_VAR 0 3
32463: PPUSH
32464: LD_EXP 104
32468: PUSH
32469: LD_VAR 0 2
32473: ARRAY
32474: PPUSH
32475: CALL_OW 113
// end ;
32479: GO 32327
32481: POP
32482: POP
// end ; if tmp > 3 then
32483: LD_VAR 0 5
32487: PUSH
32488: LD_INT 3
32490: GREATER
32491: IFFALSE 32511
// tmp := ShrinkArray ( tmp , 4 ) ;
32493: LD_ADDR_VAR 0 5
32497: PUSH
32498: LD_VAR 0 5
32502: PPUSH
32503: LD_INT 4
32505: PPUSH
32506: CALL 91484 0 2
32510: ST_TO_ADDR
// if not tmp then
32511: LD_VAR 0 5
32515: NOT
32516: IFFALSE 32520
// continue ;
32518: GO 31900
// for j in tmp do
32520: LD_ADDR_VAR 0 3
32524: PUSH
32525: LD_VAR 0 5
32529: PUSH
32530: FOR_IN
32531: IFFALSE 32790
// begin if IsInUnit ( j ) then
32533: LD_VAR 0 3
32537: PPUSH
32538: CALL_OW 310
32542: IFFALSE 32553
// ComExitBuilding ( j ) ;
32544: LD_VAR 0 3
32548: PPUSH
32549: CALL_OW 122
// if not j in mc_building_repairs [ i ] then
32553: LD_VAR 0 3
32557: PUSH
32558: LD_EXP 82
32562: PUSH
32563: LD_VAR 0 2
32567: ARRAY
32568: IN
32569: NOT
32570: IFFALSE 32628
// begin SetTag ( j , 101 ) ;
32572: LD_VAR 0 3
32576: PPUSH
32577: LD_INT 101
32579: PPUSH
32580: CALL_OW 109
// mc_building_repairs := ReplaceIn ( mc_building_repairs , [ i , mc_building_repairs [ i ] + 1 ] , j ) ;
32584: LD_ADDR_EXP 82
32588: PUSH
32589: LD_EXP 82
32593: PPUSH
32594: LD_VAR 0 2
32598: PUSH
32599: LD_EXP 82
32603: PUSH
32604: LD_VAR 0 2
32608: ARRAY
32609: PUSH
32610: LD_INT 1
32612: PLUS
32613: PUSH
32614: EMPTY
32615: LIST
32616: LIST
32617: PPUSH
32618: LD_VAR 0 3
32622: PPUSH
32623: CALL 58440 0 3
32627: ST_TO_ADDR
// end ; wait ( 1 ) ;
32628: LD_INT 1
32630: PPUSH
32631: CALL_OW 67
// to_repair_tmp := mc_building_need_repair [ i ] ;
32635: LD_ADDR_VAR 0 7
32639: PUSH
32640: LD_EXP 81
32644: PUSH
32645: LD_VAR 0 2
32649: ARRAY
32650: ST_TO_ADDR
// if mc_scan [ i ] then
32651: LD_EXP 103
32655: PUSH
32656: LD_VAR 0 2
32660: ARRAY
32661: IFFALSE 32723
// to_repair_tmp := UnitFilter ( mc_building_need_repair [ i ] , [ f_not , [ f_btype , b_bunker ] , [ f_btype , b_turret ] , [ f_btype , b_breastwork ] ] ) ;
32663: LD_ADDR_VAR 0 7
32667: PUSH
32668: LD_EXP 81
32672: PUSH
32673: LD_VAR 0 2
32677: ARRAY
32678: PPUSH
32679: LD_INT 3
32681: PUSH
32682: LD_INT 30
32684: PUSH
32685: LD_INT 32
32687: PUSH
32688: EMPTY
32689: LIST
32690: LIST
32691: PUSH
32692: LD_INT 30
32694: PUSH
32695: LD_INT 33
32697: PUSH
32698: EMPTY
32699: LIST
32700: LIST
32701: PUSH
32702: LD_INT 30
32704: PUSH
32705: LD_INT 31
32707: PUSH
32708: EMPTY
32709: LIST
32710: LIST
32711: PUSH
32712: EMPTY
32713: LIST
32714: LIST
32715: LIST
32716: LIST
32717: PPUSH
32718: CALL_OW 72
32722: ST_TO_ADDR
// if not to_repair_tmp then
32723: LD_VAR 0 7
32727: NOT
32728: IFFALSE 32732
// continue ;
32730: GO 32530
// to_repair := NearestUnitToUnit ( to_repair_tmp , j ) ;
32732: LD_ADDR_VAR 0 8
32736: PUSH
32737: LD_VAR 0 7
32741: PPUSH
32742: LD_VAR 0 3
32746: PPUSH
32747: CALL_OW 74
32751: ST_TO_ADDR
// if DangerAtRange ( to_repair , 16 ) [ 4 ] < 14 then
32752: LD_VAR 0 8
32756: PPUSH
32757: LD_INT 16
32759: PPUSH
32760: CALL 61405 0 2
32764: PUSH
32765: LD_INT 4
32767: ARRAY
32768: PUSH
32769: LD_INT 14
32771: LESS
32772: IFFALSE 32788
// ComRepairBuilding ( j , to_repair ) ;
32774: LD_VAR 0 3
32778: PPUSH
32779: LD_VAR 0 8
32783: PPUSH
32784: CALL_OW 130
// end ;
32788: GO 32530
32790: POP
32791: POP
// end ;
32792: GO 31900
32794: POP
32795: POP
// end ;
32796: LD_VAR 0 1
32800: RET
// export function MC_Heal ; var i , j , tmp ; begin
32801: LD_INT 0
32803: PPUSH
32804: PPUSH
32805: PPUSH
32806: PPUSH
// if not mc_bases then
32807: LD_EXP 80
32811: NOT
32812: IFFALSE 32816
// exit ;
32814: GO 33218
// for i = 1 to mc_bases do
32816: LD_ADDR_VAR 0 2
32820: PUSH
32821: DOUBLE
32822: LD_INT 1
32824: DEC
32825: ST_TO_ADDR
32826: LD_EXP 80
32830: PUSH
32831: FOR_TO
32832: IFFALSE 33216
// begin if not mc_need_heal [ i ] [ 1 ] and not mc_need_heal [ i ] [ 2 ] then
32834: LD_EXP 83
32838: PUSH
32839: LD_VAR 0 2
32843: ARRAY
32844: PUSH
32845: LD_INT 1
32847: ARRAY
32848: NOT
32849: PUSH
32850: LD_EXP 83
32854: PUSH
32855: LD_VAR 0 2
32859: ARRAY
32860: PUSH
32861: LD_INT 2
32863: ARRAY
32864: NOT
32865: AND
32866: IFFALSE 32904
// begin mc_healers := Replace ( mc_healers , i , [ ] ) ;
32868: LD_ADDR_EXP 84
32872: PUSH
32873: LD_EXP 84
32877: PPUSH
32878: LD_VAR 0 2
32882: PPUSH
32883: EMPTY
32884: PPUSH
32885: CALL_OW 1
32889: ST_TO_ADDR
// MC_Reset ( i , 102 ) ;
32890: LD_VAR 0 2
32894: PPUSH
32895: LD_INT 102
32897: PPUSH
32898: CALL 26939 0 2
// continue ;
32902: GO 32831
// end ; tmp := UnitFilter ( mc_bases [ i ] , [ f_class , 4 ] ) ;
32904: LD_ADDR_VAR 0 4
32908: PUSH
32909: LD_EXP 80
32913: PUSH
32914: LD_VAR 0 2
32918: ARRAY
32919: PPUSH
32920: LD_INT 25
32922: PUSH
32923: LD_INT 4
32925: PUSH
32926: EMPTY
32927: LIST
32928: LIST
32929: PPUSH
32930: CALL_OW 72
32934: ST_TO_ADDR
// if not tmp then
32935: LD_VAR 0 4
32939: NOT
32940: IFFALSE 32944
// continue ;
32942: GO 32831
// if mc_taming [ i ] then
32944: LD_EXP 111
32948: PUSH
32949: LD_VAR 0 2
32953: ARRAY
32954: IFFALSE 32978
// mc_taming := Replace ( mc_taming , i , [ ] ) ;
32956: LD_ADDR_EXP 111
32960: PUSH
32961: LD_EXP 111
32965: PPUSH
32966: LD_VAR 0 2
32970: PPUSH
32971: EMPTY
32972: PPUSH
32973: CALL_OW 1
32977: ST_TO_ADDR
// for j in tmp do
32978: LD_ADDR_VAR 0 3
32982: PUSH
32983: LD_VAR 0 4
32987: PUSH
32988: FOR_IN
32989: IFFALSE 33212
// begin if IsInUnit ( j ) then
32991: LD_VAR 0 3
32995: PPUSH
32996: CALL_OW 310
33000: IFFALSE 33011
// ComExitBuilding ( j ) ;
33002: LD_VAR 0 3
33006: PPUSH
33007: CALL_OW 122
// if not j in mc_healers [ i ] then
33011: LD_VAR 0 3
33015: PUSH
33016: LD_EXP 84
33020: PUSH
33021: LD_VAR 0 2
33025: ARRAY
33026: IN
33027: NOT
33028: IFFALSE 33074
// mc_healers := ReplaceIn ( mc_healers , [ i , mc_healers [ i ] + 1 ] , j ) ;
33030: LD_ADDR_EXP 84
33034: PUSH
33035: LD_EXP 84
33039: PPUSH
33040: LD_VAR 0 2
33044: PUSH
33045: LD_EXP 84
33049: PUSH
33050: LD_VAR 0 2
33054: ARRAY
33055: PUSH
33056: LD_INT 1
33058: PLUS
33059: PUSH
33060: EMPTY
33061: LIST
33062: LIST
33063: PPUSH
33064: LD_VAR 0 3
33068: PPUSH
33069: CALL 58440 0 3
33073: ST_TO_ADDR
// if GetTag ( j ) <> 102 then
33074: LD_VAR 0 3
33078: PPUSH
33079: CALL_OW 110
33083: PUSH
33084: LD_INT 102
33086: NONEQUAL
33087: IFFALSE 33101
// SetTag ( j , 102 ) ;
33089: LD_VAR 0 3
33093: PPUSH
33094: LD_INT 102
33096: PPUSH
33097: CALL_OW 109
// Wait ( 3 ) ;
33101: LD_INT 3
33103: PPUSH
33104: CALL_OW 67
// if mc_need_heal [ i ] [ 1 ] then
33108: LD_EXP 83
33112: PUSH
33113: LD_VAR 0 2
33117: ARRAY
33118: PUSH
33119: LD_INT 1
33121: ARRAY
33122: IFFALSE 33154
// ComHeal ( j , mc_need_heal [ i ] [ 1 ] [ 1 ] ) else
33124: LD_VAR 0 3
33128: PPUSH
33129: LD_EXP 83
33133: PUSH
33134: LD_VAR 0 2
33138: ARRAY
33139: PUSH
33140: LD_INT 1
33142: ARRAY
33143: PUSH
33144: LD_INT 1
33146: ARRAY
33147: PPUSH
33148: CALL_OW 128
33152: GO 33210
// if not HasTask ( j ) and mc_need_heal [ i ] [ 2 ] then
33154: LD_VAR 0 3
33158: PPUSH
33159: CALL_OW 314
33163: NOT
33164: PUSH
33165: LD_EXP 83
33169: PUSH
33170: LD_VAR 0 2
33174: ARRAY
33175: PUSH
33176: LD_INT 2
33178: ARRAY
33179: AND
33180: IFFALSE 33210
// ComHeal ( j , mc_need_heal [ i ] [ 2 ] [ 1 ] ) ;
33182: LD_VAR 0 3
33186: PPUSH
33187: LD_EXP 83
33191: PUSH
33192: LD_VAR 0 2
33196: ARRAY
33197: PUSH
33198: LD_INT 2
33200: ARRAY
33201: PUSH
33202: LD_INT 1
33204: ARRAY
33205: PPUSH
33206: CALL_OW 128
// end ;
33210: GO 32988
33212: POP
33213: POP
// end ;
33214: GO 32831
33216: POP
33217: POP
// end ;
33218: LD_VAR 0 1
33222: RET
// export function MC_Build ( ) ; var i , j , k , tmp , depot ; begin
33223: LD_INT 0
33225: PPUSH
33226: PPUSH
33227: PPUSH
33228: PPUSH
33229: PPUSH
33230: PPUSH
// if not mc_bases then
33231: LD_EXP 80
33235: NOT
33236: IFFALSE 33240
// exit ;
33238: GO 34403
// for i = 1 to mc_bases do
33240: LD_ADDR_VAR 0 2
33244: PUSH
33245: DOUBLE
33246: LD_INT 1
33248: DEC
33249: ST_TO_ADDR
33250: LD_EXP 80
33254: PUSH
33255: FOR_TO
33256: IFFALSE 34401
// begin if mc_scan [ i ] then
33258: LD_EXP 103
33262: PUSH
33263: LD_VAR 0 2
33267: ARRAY
33268: IFFALSE 33272
// continue ;
33270: GO 33255
// if not mc_build_list [ i ] and not mc_construct_list [ i ] and mc_builders [ i ] then
33272: LD_EXP 85
33276: PUSH
33277: LD_VAR 0 2
33281: ARRAY
33282: NOT
33283: PUSH
33284: LD_EXP 87
33288: PUSH
33289: LD_VAR 0 2
33293: ARRAY
33294: NOT
33295: AND
33296: PUSH
33297: LD_EXP 86
33301: PUSH
33302: LD_VAR 0 2
33306: ARRAY
33307: AND
33308: IFFALSE 33346
// begin mc_builders := Replace ( mc_builders , i , [ ] ) ;
33310: LD_ADDR_EXP 86
33314: PUSH
33315: LD_EXP 86
33319: PPUSH
33320: LD_VAR 0 2
33324: PPUSH
33325: EMPTY
33326: PPUSH
33327: CALL_OW 1
33331: ST_TO_ADDR
// MC_Reset ( i , 103 ) ;
33332: LD_VAR 0 2
33336: PPUSH
33337: LD_INT 103
33339: PPUSH
33340: CALL 26939 0 2
// continue ;
33344: GO 33255
// end ; if mc_construct_list [ i ] then
33346: LD_EXP 87
33350: PUSH
33351: LD_VAR 0 2
33355: ARRAY
33356: IFFALSE 33576
// begin tmp := UnitFilter ( mc_bases [ i ] , [ f_class , 2 ] ) diff mc_building_repairs [ i ] ;
33358: LD_ADDR_VAR 0 5
33362: PUSH
33363: LD_EXP 80
33367: PUSH
33368: LD_VAR 0 2
33372: ARRAY
33373: PPUSH
33374: LD_INT 25
33376: PUSH
33377: LD_INT 2
33379: PUSH
33380: EMPTY
33381: LIST
33382: LIST
33383: PPUSH
33384: CALL_OW 72
33388: PUSH
33389: LD_EXP 82
33393: PUSH
33394: LD_VAR 0 2
33398: ARRAY
33399: DIFF
33400: ST_TO_ADDR
// if not tmp then
33401: LD_VAR 0 5
33405: NOT
33406: IFFALSE 33410
// continue ;
33408: GO 33255
// for j in tmp do
33410: LD_ADDR_VAR 0 3
33414: PUSH
33415: LD_VAR 0 5
33419: PUSH
33420: FOR_IN
33421: IFFALSE 33572
// begin if not mc_builders [ i ] then
33423: LD_EXP 86
33427: PUSH
33428: LD_VAR 0 2
33432: ARRAY
33433: NOT
33434: IFFALSE 33492
// begin SetTag ( j , 103 ) ;
33436: LD_VAR 0 3
33440: PPUSH
33441: LD_INT 103
33443: PPUSH
33444: CALL_OW 109
// mc_builders := ReplaceIn ( mc_builders , [ i , mc_builders [ i ] + 1 ] , j ) ;
33448: LD_ADDR_EXP 86
33452: PUSH
33453: LD_EXP 86
33457: PPUSH
33458: LD_VAR 0 2
33462: PUSH
33463: LD_EXP 86
33467: PUSH
33468: LD_VAR 0 2
33472: ARRAY
33473: PUSH
33474: LD_INT 1
33476: PLUS
33477: PUSH
33478: EMPTY
33479: LIST
33480: LIST
33481: PPUSH
33482: LD_VAR 0 3
33486: PPUSH
33487: CALL 58440 0 3
33491: ST_TO_ADDR
// end ; if IsInUnit ( j ) then
33492: LD_VAR 0 3
33496: PPUSH
33497: CALL_OW 310
33501: IFFALSE 33512
// ComExitBuilding ( j ) ;
33503: LD_VAR 0 3
33507: PPUSH
33508: CALL_OW 122
// wait ( 3 ) ;
33512: LD_INT 3
33514: PPUSH
33515: CALL_OW 67
// if not mc_construct_list [ i ] then
33519: LD_EXP 87
33523: PUSH
33524: LD_VAR 0 2
33528: ARRAY
33529: NOT
33530: IFFALSE 33534
// break ;
33532: GO 33572
// if not HasTask ( j ) then
33534: LD_VAR 0 3
33538: PPUSH
33539: CALL_OW 314
33543: NOT
33544: IFFALSE 33570
// ComComplete ( j , mc_construct_list [ i ] [ 1 ] ) ;
33546: LD_VAR 0 3
33550: PPUSH
33551: LD_EXP 87
33555: PUSH
33556: LD_VAR 0 2
33560: ARRAY
33561: PUSH
33562: LD_INT 1
33564: ARRAY
33565: PPUSH
33566: CALL 61678 0 2
// end ;
33570: GO 33420
33572: POP
33573: POP
// end else
33574: GO 34399
// if mc_build_list [ i ] then
33576: LD_EXP 85
33580: PUSH
33581: LD_VAR 0 2
33585: ARRAY
33586: IFFALSE 34399
// begin if IsExtension ( mc_build_list [ i ] [ 1 ] [ 1 ] ) and not UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_workshop ] , [ f_btype , b_factory ] ] ) then
33588: LD_EXP 85
33592: PUSH
33593: LD_VAR 0 2
33597: ARRAY
33598: PUSH
33599: LD_INT 1
33601: ARRAY
33602: PUSH
33603: LD_INT 1
33605: ARRAY
33606: PPUSH
33607: CALL 61502 0 1
33611: PUSH
33612: LD_EXP 80
33616: PUSH
33617: LD_VAR 0 2
33621: ARRAY
33622: PPUSH
33623: LD_INT 2
33625: PUSH
33626: LD_INT 30
33628: PUSH
33629: LD_INT 2
33631: PUSH
33632: EMPTY
33633: LIST
33634: LIST
33635: PUSH
33636: LD_INT 30
33638: PUSH
33639: LD_INT 3
33641: PUSH
33642: EMPTY
33643: LIST
33644: LIST
33645: PUSH
33646: EMPTY
33647: LIST
33648: LIST
33649: LIST
33650: PPUSH
33651: CALL_OW 72
33655: NOT
33656: AND
33657: IFFALSE 33762
// begin for j = 1 to mc_build_list [ i ] do
33659: LD_ADDR_VAR 0 3
33663: PUSH
33664: DOUBLE
33665: LD_INT 1
33667: DEC
33668: ST_TO_ADDR
33669: LD_EXP 85
33673: PUSH
33674: LD_VAR 0 2
33678: ARRAY
33679: PUSH
33680: FOR_TO
33681: IFFALSE 33760
// if mc_build_list [ i ] [ j ] [ 1 ] = b_workshop then
33683: LD_EXP 85
33687: PUSH
33688: LD_VAR 0 2
33692: ARRAY
33693: PUSH
33694: LD_VAR 0 3
33698: ARRAY
33699: PUSH
33700: LD_INT 1
33702: ARRAY
33703: PUSH
33704: LD_INT 2
33706: EQUAL
33707: IFFALSE 33758
// begin mc_build_list := Replace ( mc_build_list , i , Reindex ( mc_build_list [ i ] , j , 1 , false ) ) ;
33709: LD_ADDR_EXP 85
33713: PUSH
33714: LD_EXP 85
33718: PPUSH
33719: LD_VAR 0 2
33723: PPUSH
33724: LD_EXP 85
33728: PUSH
33729: LD_VAR 0 2
33733: ARRAY
33734: PPUSH
33735: LD_VAR 0 3
33739: PPUSH
33740: LD_INT 1
33742: PPUSH
33743: LD_INT 0
33745: PPUSH
33746: CALL 57858 0 4
33750: PPUSH
33751: CALL_OW 1
33755: ST_TO_ADDR
// break ;
33756: GO 33760
// end ;
33758: GO 33680
33760: POP
33761: POP
// end ; depot := UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) ;
33762: LD_ADDR_VAR 0 6
33766: PUSH
33767: LD_EXP 80
33771: PUSH
33772: LD_VAR 0 2
33776: ARRAY
33777: PPUSH
33778: LD_INT 2
33780: PUSH
33781: LD_INT 30
33783: PUSH
33784: LD_INT 0
33786: PUSH
33787: EMPTY
33788: LIST
33789: LIST
33790: PUSH
33791: LD_INT 30
33793: PUSH
33794: LD_INT 1
33796: PUSH
33797: EMPTY
33798: LIST
33799: LIST
33800: PUSH
33801: EMPTY
33802: LIST
33803: LIST
33804: LIST
33805: PPUSH
33806: CALL_OW 72
33810: ST_TO_ADDR
// for k := 1 to depot do
33811: LD_ADDR_VAR 0 4
33815: PUSH
33816: DOUBLE
33817: LD_INT 1
33819: DEC
33820: ST_TO_ADDR
33821: LD_VAR 0 6
33825: PUSH
33826: FOR_TO
33827: IFFALSE 34397
// begin if mc_build_list [ i ] [ 1 ] [ 1 ] = b_depot or CanBeBuilt ( depot [ k ] , mc_build_list [ i ] [ 1 ] [ 1 ] , mc_build_list [ i ] [ 1 ] [ 2 ] , mc_build_list [ i ] [ 1 ] [ 3 ] , mc_build_list [ i ] [ 1 ] [ 4 ] ) then
33829: LD_EXP 85
33833: PUSH
33834: LD_VAR 0 2
33838: ARRAY
33839: PUSH
33840: LD_INT 1
33842: ARRAY
33843: PUSH
33844: LD_INT 1
33846: ARRAY
33847: PUSH
33848: LD_INT 0
33850: EQUAL
33851: PUSH
33852: LD_VAR 0 6
33856: PUSH
33857: LD_VAR 0 4
33861: ARRAY
33862: PPUSH
33863: LD_EXP 85
33867: PUSH
33868: LD_VAR 0 2
33872: ARRAY
33873: PUSH
33874: LD_INT 1
33876: ARRAY
33877: PUSH
33878: LD_INT 1
33880: ARRAY
33881: PPUSH
33882: LD_EXP 85
33886: PUSH
33887: LD_VAR 0 2
33891: ARRAY
33892: PUSH
33893: LD_INT 1
33895: ARRAY
33896: PUSH
33897: LD_INT 2
33899: ARRAY
33900: PPUSH
33901: LD_EXP 85
33905: PUSH
33906: LD_VAR 0 2
33910: ARRAY
33911: PUSH
33912: LD_INT 1
33914: ARRAY
33915: PUSH
33916: LD_INT 3
33918: ARRAY
33919: PPUSH
33920: LD_EXP 85
33924: PUSH
33925: LD_VAR 0 2
33929: ARRAY
33930: PUSH
33931: LD_INT 1
33933: ARRAY
33934: PUSH
33935: LD_INT 4
33937: ARRAY
33938: PPUSH
33939: CALL 66914 0 5
33943: OR
33944: IFFALSE 34225
// begin tmp := UnitFilter ( mc_bases [ i ] , [ f_class , 2 ] ) diff mc_building_repairs [ i ] ;
33946: LD_ADDR_VAR 0 5
33950: PUSH
33951: LD_EXP 80
33955: PUSH
33956: LD_VAR 0 2
33960: ARRAY
33961: PPUSH
33962: LD_INT 25
33964: PUSH
33965: LD_INT 2
33967: PUSH
33968: EMPTY
33969: LIST
33970: LIST
33971: PPUSH
33972: CALL_OW 72
33976: PUSH
33977: LD_EXP 82
33981: PUSH
33982: LD_VAR 0 2
33986: ARRAY
33987: DIFF
33988: ST_TO_ADDR
// if not tmp then
33989: LD_VAR 0 5
33993: NOT
33994: IFFALSE 33998
// continue ;
33996: GO 33826
// for j in tmp do
33998: LD_ADDR_VAR 0 3
34002: PUSH
34003: LD_VAR 0 5
34007: PUSH
34008: FOR_IN
34009: IFFALSE 34221
// begin if not mc_builders [ i ] then
34011: LD_EXP 86
34015: PUSH
34016: LD_VAR 0 2
34020: ARRAY
34021: NOT
34022: IFFALSE 34080
// begin SetTag ( j , 103 ) ;
34024: LD_VAR 0 3
34028: PPUSH
34029: LD_INT 103
34031: PPUSH
34032: CALL_OW 109
// mc_builders := ReplaceIn ( mc_builders , [ i , mc_builders [ i ] + 1 ] , j ) ;
34036: LD_ADDR_EXP 86
34040: PUSH
34041: LD_EXP 86
34045: PPUSH
34046: LD_VAR 0 2
34050: PUSH
34051: LD_EXP 86
34055: PUSH
34056: LD_VAR 0 2
34060: ARRAY
34061: PUSH
34062: LD_INT 1
34064: PLUS
34065: PUSH
34066: EMPTY
34067: LIST
34068: LIST
34069: PPUSH
34070: LD_VAR 0 3
34074: PPUSH
34075: CALL 58440 0 3
34079: ST_TO_ADDR
// end ; if IsInUnit ( j ) then
34080: LD_VAR 0 3
34084: PPUSH
34085: CALL_OW 310
34089: IFFALSE 34100
// ComExitBuilding ( j ) ;
34091: LD_VAR 0 3
34095: PPUSH
34096: CALL_OW 122
// wait ( 3 ) ;
34100: LD_INT 3
34102: PPUSH
34103: CALL_OW 67
// if not mc_build_list [ i ] then
34107: LD_EXP 85
34111: PUSH
34112: LD_VAR 0 2
34116: ARRAY
34117: NOT
34118: IFFALSE 34122
// break ;
34120: GO 34221
// if not HasTask ( j ) then
34122: LD_VAR 0 3
34126: PPUSH
34127: CALL_OW 314
34131: NOT
34132: IFFALSE 34219
// ComBuild ( j , mc_build_list [ i ] [ 1 ] [ 1 ] , mc_build_list [ i ] [ 1 ] [ 2 ] , mc_build_list [ i ] [ 1 ] [ 3 ] , mc_build_list [ i ] [ 1 ] [ 4 ] ) ;
34134: LD_VAR 0 3
34138: PPUSH
34139: LD_EXP 85
34143: PUSH
34144: LD_VAR 0 2
34148: ARRAY
34149: PUSH
34150: LD_INT 1
34152: ARRAY
34153: PUSH
34154: LD_INT 1
34156: ARRAY
34157: PPUSH
34158: LD_EXP 85
34162: PUSH
34163: LD_VAR 0 2
34167: ARRAY
34168: PUSH
34169: LD_INT 1
34171: ARRAY
34172: PUSH
34173: LD_INT 2
34175: ARRAY
34176: PPUSH
34177: LD_EXP 85
34181: PUSH
34182: LD_VAR 0 2
34186: ARRAY
34187: PUSH
34188: LD_INT 1
34190: ARRAY
34191: PUSH
34192: LD_INT 3
34194: ARRAY
34195: PPUSH
34196: LD_EXP 85
34200: PUSH
34201: LD_VAR 0 2
34205: ARRAY
34206: PUSH
34207: LD_INT 1
34209: ARRAY
34210: PUSH
34211: LD_INT 4
34213: ARRAY
34214: PPUSH
34215: CALL_OW 145
// end ;
34219: GO 34008
34221: POP
34222: POP
// end else
34223: GO 34395
// if not TryClearPlaceForBuilding ( mc_bases [ i ] , mc_build_list [ i ] [ 1 ] [ 1 ] , mc_build_list [ i ] [ 1 ] [ 2 ] , mc_build_list [ i ] [ 1 ] [ 3 ] , mc_build_list [ i ] [ 1 ] [ 4 ] , UnitFilter ( mc_bases [ i ] , [ f_type , unit_building ] ) , [ ] ) then
34225: LD_EXP 80
34229: PUSH
34230: LD_VAR 0 2
34234: ARRAY
34235: PPUSH
34236: LD_EXP 85
34240: PUSH
34241: LD_VAR 0 2
34245: ARRAY
34246: PUSH
34247: LD_INT 1
34249: ARRAY
34250: PUSH
34251: LD_INT 1
34253: ARRAY
34254: PPUSH
34255: LD_EXP 85
34259: PUSH
34260: LD_VAR 0 2
34264: ARRAY
34265: PUSH
34266: LD_INT 1
34268: ARRAY
34269: PUSH
34270: LD_INT 2
34272: ARRAY
34273: PPUSH
34274: LD_EXP 85
34278: PUSH
34279: LD_VAR 0 2
34283: ARRAY
34284: PUSH
34285: LD_INT 1
34287: ARRAY
34288: PUSH
34289: LD_INT 3
34291: ARRAY
34292: PPUSH
34293: LD_EXP 85
34297: PUSH
34298: LD_VAR 0 2
34302: ARRAY
34303: PUSH
34304: LD_INT 1
34306: ARRAY
34307: PUSH
34308: LD_INT 4
34310: ARRAY
34311: PPUSH
34312: LD_EXP 80
34316: PUSH
34317: LD_VAR 0 2
34321: ARRAY
34322: PPUSH
34323: LD_INT 21
34325: PUSH
34326: LD_INT 3
34328: PUSH
34329: EMPTY
34330: LIST
34331: LIST
34332: PPUSH
34333: CALL_OW 72
34337: PPUSH
34338: EMPTY
34339: PPUSH
34340: CALL 65668 0 7
34344: NOT
34345: IFFALSE 34395
// begin mc_build_list := Replace ( mc_build_list , i , Reindex ( mc_build_list [ i ] , 1 , - 1 , false ) ) ;
34347: LD_ADDR_EXP 85
34351: PUSH
34352: LD_EXP 85
34356: PPUSH
34357: LD_VAR 0 2
34361: PPUSH
34362: LD_EXP 85
34366: PUSH
34367: LD_VAR 0 2
34371: ARRAY
34372: PPUSH
34373: LD_INT 1
34375: PPUSH
34376: LD_INT 1
34378: NEG
34379: PPUSH
34380: LD_INT 0
34382: PPUSH
34383: CALL 57858 0 4
34387: PPUSH
34388: CALL_OW 1
34392: ST_TO_ADDR
// continue ;
34393: GO 33826
// end ; end ;
34395: GO 33826
34397: POP
34398: POP
// end ; end ;
34399: GO 33255
34401: POP
34402: POP
// end ;
34403: LD_VAR 0 1
34407: RET
// export function MC_BuildUpgrade ( ) ; var i , j , tmp , depot , lab ; begin
34408: LD_INT 0
34410: PPUSH
34411: PPUSH
34412: PPUSH
34413: PPUSH
34414: PPUSH
34415: PPUSH
// if not mc_bases then
34416: LD_EXP 80
34420: NOT
34421: IFFALSE 34425
// exit ;
34423: GO 34852
// for i = 1 to mc_bases do
34425: LD_ADDR_VAR 0 2
34429: PUSH
34430: DOUBLE
34431: LD_INT 1
34433: DEC
34434: ST_TO_ADDR
34435: LD_EXP 80
34439: PUSH
34440: FOR_TO
34441: IFFALSE 34850
// begin tmp := mc_build_upgrade [ i ] ;
34443: LD_ADDR_VAR 0 4
34447: PUSH
34448: LD_EXP 112
34452: PUSH
34453: LD_VAR 0 2
34457: ARRAY
34458: ST_TO_ADDR
// lab := UnitFilter ( mc_lab [ i ] , [ f_or , [ f_btype , b_lab ] , [ f_btype , b_lab_half ] ] ) ;
34459: LD_ADDR_VAR 0 6
34463: PUSH
34464: LD_EXP 113
34468: PUSH
34469: LD_VAR 0 2
34473: ARRAY
34474: PPUSH
34475: LD_INT 2
34477: PUSH
34478: LD_INT 30
34480: PUSH
34481: LD_INT 6
34483: PUSH
34484: EMPTY
34485: LIST
34486: LIST
34487: PUSH
34488: LD_INT 30
34490: PUSH
34491: LD_INT 7
34493: PUSH
34494: EMPTY
34495: LIST
34496: LIST
34497: PUSH
34498: EMPTY
34499: LIST
34500: LIST
34501: LIST
34502: PPUSH
34503: CALL_OW 72
34507: ST_TO_ADDR
// if not tmp and not lab then
34508: LD_VAR 0 4
34512: NOT
34513: PUSH
34514: LD_VAR 0 6
34518: NOT
34519: AND
34520: IFFALSE 34524
// continue ;
34522: GO 34440
// if tmp then
34524: LD_VAR 0 4
34528: IFFALSE 34648
// for j in tmp do
34530: LD_ADDR_VAR 0 3
34534: PUSH
34535: LD_VAR 0 4
34539: PUSH
34540: FOR_IN
34541: IFFALSE 34646
// begin if UpgradeCost ( j ) then
34543: LD_VAR 0 3
34547: PPUSH
34548: CALL 65328 0 1
34552: IFFALSE 34644
// begin ComUpgrade ( j ) ;
34554: LD_VAR 0 3
34558: PPUSH
34559: CALL_OW 146
// mc_build_upgrade := Replace ( mc_build_upgrade , i , mc_build_upgrade [ i ] diff j ) ;
34563: LD_ADDR_EXP 112
34567: PUSH
34568: LD_EXP 112
34572: PPUSH
34573: LD_VAR 0 2
34577: PPUSH
34578: LD_EXP 112
34582: PUSH
34583: LD_VAR 0 2
34587: ARRAY
34588: PUSH
34589: LD_VAR 0 3
34593: DIFF
34594: PPUSH
34595: CALL_OW 1
34599: ST_TO_ADDR
// mc_construct_list := ReplaceIn ( mc_construct_list , [ i , mc_construct_list [ i ] + 1 ] , j ) ;
34600: LD_ADDR_EXP 87
34604: PUSH
34605: LD_EXP 87
34609: PPUSH
34610: LD_VAR 0 2
34614: PUSH
34615: LD_EXP 87
34619: PUSH
34620: LD_VAR 0 2
34624: ARRAY
34625: PUSH
34626: LD_INT 1
34628: PLUS
34629: PUSH
34630: EMPTY
34631: LIST
34632: LIST
34633: PPUSH
34634: LD_VAR 0 3
34638: PPUSH
34639: CALL 58440 0 3
34643: ST_TO_ADDR
// end ; end ;
34644: GO 34540
34646: POP
34647: POP
// if not lab or not mc_lab_upgrade [ i ] then
34648: LD_VAR 0 6
34652: NOT
34653: PUSH
34654: LD_EXP 114
34658: PUSH
34659: LD_VAR 0 2
34663: ARRAY
34664: NOT
34665: OR
34666: IFFALSE 34670
// continue ;
34668: GO 34440
// for j in lab do
34670: LD_ADDR_VAR 0 3
34674: PUSH
34675: LD_VAR 0 6
34679: PUSH
34680: FOR_IN
34681: IFFALSE 34846
// begin if GetBType ( j ) in [ b_lab , b_lab_half ] and BuildingStatus ( j ) <> bs_build then
34683: LD_VAR 0 3
34687: PPUSH
34688: CALL_OW 266
34692: PUSH
34693: LD_INT 6
34695: PUSH
34696: LD_INT 7
34698: PUSH
34699: EMPTY
34700: LIST
34701: LIST
34702: IN
34703: PUSH
34704: LD_VAR 0 3
34708: PPUSH
34709: CALL_OW 461
34713: PUSH
34714: LD_INT 1
34716: NONEQUAL
34717: AND
34718: IFFALSE 34844
// begin if UpgradeLabCost ( j , mc_lab_upgrade [ i ] [ 1 ] ) then
34720: LD_VAR 0 3
34724: PPUSH
34725: LD_EXP 114
34729: PUSH
34730: LD_VAR 0 2
34734: ARRAY
34735: PUSH
34736: LD_INT 1
34738: ARRAY
34739: PPUSH
34740: CALL 65533 0 2
34744: IFFALSE 34844
// begin ComCancel ( j ) ;
34746: LD_VAR 0 3
34750: PPUSH
34751: CALL_OW 127
// AddComUpgradeLab ( j , mc_lab_upgrade [ i ] [ 1 ] ) ;
34755: LD_VAR 0 3
34759: PPUSH
34760: LD_EXP 114
34764: PUSH
34765: LD_VAR 0 2
34769: ARRAY
34770: PUSH
34771: LD_INT 1
34773: ARRAY
34774: PPUSH
34775: CALL_OW 207
// if not j in mc_construct_list [ i ] then
34779: LD_VAR 0 3
34783: PUSH
34784: LD_EXP 87
34788: PUSH
34789: LD_VAR 0 2
34793: ARRAY
34794: IN
34795: NOT
34796: IFFALSE 34842
// mc_construct_list := ReplaceIn ( mc_construct_list , [ i , mc_construct_list [ i ] + 1 ] , j ) ;
34798: LD_ADDR_EXP 87
34802: PUSH
34803: LD_EXP 87
34807: PPUSH
34808: LD_VAR 0 2
34812: PUSH
34813: LD_EXP 87
34817: PUSH
34818: LD_VAR 0 2
34822: ARRAY
34823: PUSH
34824: LD_INT 1
34826: PLUS
34827: PUSH
34828: EMPTY
34829: LIST
34830: LIST
34831: PPUSH
34832: LD_VAR 0 3
34836: PPUSH
34837: CALL 58440 0 3
34841: ST_TO_ADDR
// break ;
34842: GO 34846
// end ; end ; end ;
34844: GO 34680
34846: POP
34847: POP
// end ;
34848: GO 34440
34850: POP
34851: POP
// end ;
34852: LD_VAR 0 1
34856: RET
// export function MC_TurretWeapon ( ) ; var i , j , tmp , tmp2 , t , tw , busy , weapon ; begin
34857: LD_INT 0
34859: PPUSH
34860: PPUSH
34861: PPUSH
34862: PPUSH
34863: PPUSH
34864: PPUSH
34865: PPUSH
34866: PPUSH
34867: PPUSH
// if not mc_bases then
34868: LD_EXP 80
34872: NOT
34873: IFFALSE 34877
// exit ;
34875: GO 35282
// for i = 1 to mc_bases do
34877: LD_ADDR_VAR 0 2
34881: PUSH
34882: DOUBLE
34883: LD_INT 1
34885: DEC
34886: ST_TO_ADDR
34887: LD_EXP 80
34891: PUSH
34892: FOR_TO
34893: IFFALSE 35280
// begin if not mc_turret_list [ i ] or not UnitFilter ( mc_bases [ i ] , [ f_btype , b_factory ] ) then
34895: LD_EXP 88
34899: PUSH
34900: LD_VAR 0 2
34904: ARRAY
34905: NOT
34906: PUSH
34907: LD_EXP 80
34911: PUSH
34912: LD_VAR 0 2
34916: ARRAY
34917: PPUSH
34918: LD_INT 30
34920: PUSH
34921: LD_INT 3
34923: PUSH
34924: EMPTY
34925: LIST
34926: LIST
34927: PPUSH
34928: CALL_OW 72
34932: NOT
34933: OR
34934: IFFALSE 34938
// continue ;
34936: GO 34892
// busy := false ;
34938: LD_ADDR_VAR 0 8
34942: PUSH
34943: LD_INT 0
34945: ST_TO_ADDR
// tmp := UnitFilter ( mc_bases [ i ] , [ f_btype , b_factory ] ) ;
34946: LD_ADDR_VAR 0 4
34950: PUSH
34951: LD_EXP 80
34955: PUSH
34956: LD_VAR 0 2
34960: ARRAY
34961: PPUSH
34962: LD_INT 30
34964: PUSH
34965: LD_INT 3
34967: PUSH
34968: EMPTY
34969: LIST
34970: LIST
34971: PPUSH
34972: CALL_OW 72
34976: ST_TO_ADDR
// t := UnitFilter ( mc_turret_list [ i ] , [ f_or , [ f_btype , b_bunker ] , [ f_btype , b_turret ] ] ) ;
34977: LD_ADDR_VAR 0 6
34981: PUSH
34982: LD_EXP 88
34986: PUSH
34987: LD_VAR 0 2
34991: ARRAY
34992: PPUSH
34993: LD_INT 2
34995: PUSH
34996: LD_INT 30
34998: PUSH
34999: LD_INT 32
35001: PUSH
35002: EMPTY
35003: LIST
35004: LIST
35005: PUSH
35006: LD_INT 30
35008: PUSH
35009: LD_INT 33
35011: PUSH
35012: EMPTY
35013: LIST
35014: LIST
35015: PUSH
35016: EMPTY
35017: LIST
35018: LIST
35019: LIST
35020: PPUSH
35021: CALL_OW 72
35025: ST_TO_ADDR
// if not t then
35026: LD_VAR 0 6
35030: NOT
35031: IFFALSE 35035
// continue ;
35033: GO 34892
// for j in tmp do
35035: LD_ADDR_VAR 0 3
35039: PUSH
35040: LD_VAR 0 4
35044: PUSH
35045: FOR_IN
35046: IFFALSE 35076
// if not BuildingStatus ( j ) = bs_idle then
35048: LD_VAR 0 3
35052: PPUSH
35053: CALL_OW 461
35057: PUSH
35058: LD_INT 2
35060: EQUAL
35061: NOT
35062: IFFALSE 35074
// begin busy := true ;
35064: LD_ADDR_VAR 0 8
35068: PUSH
35069: LD_INT 1
35071: ST_TO_ADDR
// break ;
35072: GO 35076
// end ;
35074: GO 35045
35076: POP
35077: POP
// if busy then
35078: LD_VAR 0 8
35082: IFFALSE 35086
// continue ;
35084: GO 34892
// tw := UnitFilter ( t , [ f_bweapon , 0 ] ) ;
35086: LD_ADDR_VAR 0 7
35090: PUSH
35091: LD_VAR 0 6
35095: PPUSH
35096: LD_INT 35
35098: PUSH
35099: LD_INT 0
35101: PUSH
35102: EMPTY
35103: LIST
35104: LIST
35105: PPUSH
35106: CALL_OW 72
35110: ST_TO_ADDR
// if tw then
35111: LD_VAR 0 7
35115: IFFALSE 35192
// begin tw := tw [ 1 ] ;
35117: LD_ADDR_VAR 0 7
35121: PUSH
35122: LD_VAR 0 7
35126: PUSH
35127: LD_INT 1
35129: ARRAY
35130: ST_TO_ADDR
// weapon := GetTurretWeapon ( tw , mc_scan_area [ i ] ) ;
35131: LD_ADDR_VAR 0 9
35135: PUSH
35136: LD_VAR 0 7
35140: PPUSH
35141: LD_EXP 105
35145: PUSH
35146: LD_VAR 0 2
35150: ARRAY
35151: PPUSH
35152: CALL 63825 0 2
35156: ST_TO_ADDR
// if mc_allowed_tower_weapons [ i ] then
35157: LD_EXP 119
35161: PUSH
35162: LD_VAR 0 2
35166: ARRAY
35167: IFFALSE 35190
// if not weapon in mc_allowed_tower_weapons [ i ] then
35169: LD_VAR 0 9
35173: PUSH
35174: LD_EXP 119
35178: PUSH
35179: LD_VAR 0 2
35183: ARRAY
35184: IN
35185: NOT
35186: IFFALSE 35190
// continue ;
35188: GO 34892
// end else
35190: GO 35255
// begin tmp2 := UpgradeTurretsWeapon ( mc_turret_list [ i ] , tmp ) ;
35192: LD_ADDR_VAR 0 5
35196: PUSH
35197: LD_EXP 88
35201: PUSH
35202: LD_VAR 0 2
35206: ARRAY
35207: PPUSH
35208: LD_VAR 0 4
35212: PPUSH
35213: CALL 90717 0 2
35217: ST_TO_ADDR
// if not tmp2 then
35218: LD_VAR 0 5
35222: NOT
35223: IFFALSE 35227
// continue ;
35225: GO 34892
// tw := tmp2 [ 1 ] ;
35227: LD_ADDR_VAR 0 7
35231: PUSH
35232: LD_VAR 0 5
35236: PUSH
35237: LD_INT 1
35239: ARRAY
35240: ST_TO_ADDR
// weapon := tmp2 [ 2 ] ;
35241: LD_ADDR_VAR 0 9
35245: PUSH
35246: LD_VAR 0 5
35250: PUSH
35251: LD_INT 2
35253: ARRAY
35254: ST_TO_ADDR
// end ; if not weapon then
35255: LD_VAR 0 9
35259: NOT
35260: IFFALSE 35264
// continue ;
35262: GO 34892
// ComPlaceWeapon ( tw , weapon ) ;
35264: LD_VAR 0 7
35268: PPUSH
35269: LD_VAR 0 9
35273: PPUSH
35274: CALL_OW 148
// end ;
35278: GO 34892
35280: POP
35281: POP
// end ;
35282: LD_VAR 0 1
35286: RET
// export function MC_PlantMines ( ) ; var i , j , k , tmp , list , r ; begin
35287: LD_INT 0
35289: PPUSH
35290: PPUSH
35291: PPUSH
35292: PPUSH
35293: PPUSH
35294: PPUSH
35295: PPUSH
// if not mc_bases then
35296: LD_EXP 80
35300: NOT
35301: IFFALSE 35305
// exit ;
35303: GO 36080
// for i = 1 to mc_bases do
35305: LD_ADDR_VAR 0 2
35309: PUSH
35310: DOUBLE
35311: LD_INT 1
35313: DEC
35314: ST_TO_ADDR
35315: LD_EXP 80
35319: PUSH
35320: FOR_TO
35321: IFFALSE 36078
// begin if not mc_mines [ i ] or mc_mines [ i ] = mc_miners [ i ] or mc_scan [ i ] then
35323: LD_EXP 93
35327: PUSH
35328: LD_VAR 0 2
35332: ARRAY
35333: NOT
35334: PUSH
35335: LD_EXP 93
35339: PUSH
35340: LD_VAR 0 2
35344: ARRAY
35345: PUSH
35346: LD_EXP 94
35350: PUSH
35351: LD_VAR 0 2
35355: ARRAY
35356: EQUAL
35357: OR
35358: PUSH
35359: LD_EXP 103
35363: PUSH
35364: LD_VAR 0 2
35368: ARRAY
35369: OR
35370: IFFALSE 35374
// continue ;
35372: GO 35320
// if mc_miners [ i ] then
35374: LD_EXP 94
35378: PUSH
35379: LD_VAR 0 2
35383: ARRAY
35384: IFFALSE 35765
// begin for j = mc_miners [ i ] downto 1 do
35386: LD_ADDR_VAR 0 3
35390: PUSH
35391: DOUBLE
35392: LD_EXP 94
35396: PUSH
35397: LD_VAR 0 2
35401: ARRAY
35402: INC
35403: ST_TO_ADDR
35404: LD_INT 1
35406: PUSH
35407: FOR_DOWNTO
35408: IFFALSE 35763
// begin if IsDead ( mc_miners [ i ] [ j ] ) or GetClass ( mc_miners [ i ] [ j ] ) <> 1 then
35410: LD_EXP 94
35414: PUSH
35415: LD_VAR 0 2
35419: ARRAY
35420: PUSH
35421: LD_VAR 0 3
35425: ARRAY
35426: PPUSH
35427: CALL_OW 301
35431: PUSH
35432: LD_EXP 94
35436: PUSH
35437: LD_VAR 0 2
35441: ARRAY
35442: PUSH
35443: LD_VAR 0 3
35447: ARRAY
35448: PPUSH
35449: CALL_OW 257
35453: PUSH
35454: LD_INT 1
35456: NONEQUAL
35457: OR
35458: IFFALSE 35521
// begin tmp := mc_miners [ i ] diff mc_miners [ i ] [ j ] ;
35460: LD_ADDR_VAR 0 5
35464: PUSH
35465: LD_EXP 94
35469: PUSH
35470: LD_VAR 0 2
35474: ARRAY
35475: PUSH
35476: LD_EXP 94
35480: PUSH
35481: LD_VAR 0 2
35485: ARRAY
35486: PUSH
35487: LD_VAR 0 3
35491: ARRAY
35492: DIFF
35493: ST_TO_ADDR
// mc_miners := Replace ( mc_miners , i , tmp ) ;
35494: LD_ADDR_EXP 94
35498: PUSH
35499: LD_EXP 94
35503: PPUSH
35504: LD_VAR 0 2
35508: PPUSH
35509: LD_VAR 0 5
35513: PPUSH
35514: CALL_OW 1
35518: ST_TO_ADDR
// continue ;
35519: GO 35407
// end ; if GetClass ( mc_miners [ i ] [ j ] ) = 1 and not MineOfUnit ( mc_miners [ i ] [ j ] ) and not HasTask ( mc_miners [ i ] [ j ] ) then
35521: LD_EXP 94
35525: PUSH
35526: LD_VAR 0 2
35530: ARRAY
35531: PUSH
35532: LD_VAR 0 3
35536: ARRAY
35537: PPUSH
35538: CALL_OW 257
35542: PUSH
35543: LD_INT 1
35545: EQUAL
35546: PUSH
35547: LD_EXP 94
35551: PUSH
35552: LD_VAR 0 2
35556: ARRAY
35557: PUSH
35558: LD_VAR 0 3
35562: ARRAY
35563: PPUSH
35564: CALL_OW 459
35568: NOT
35569: AND
35570: PUSH
35571: LD_EXP 94
35575: PUSH
35576: LD_VAR 0 2
35580: ARRAY
35581: PUSH
35582: LD_VAR 0 3
35586: ARRAY
35587: PPUSH
35588: CALL_OW 314
35592: NOT
35593: AND
35594: IFFALSE 35761
// begin if IsInUnit ( mc_miners [ i ] [ j ] ) then
35596: LD_EXP 94
35600: PUSH
35601: LD_VAR 0 2
35605: ARRAY
35606: PUSH
35607: LD_VAR 0 3
35611: ARRAY
35612: PPUSH
35613: CALL_OW 310
35617: IFFALSE 35640
// ComExitBuilding ( mc_miners [ i ] [ j ] ) ;
35619: LD_EXP 94
35623: PUSH
35624: LD_VAR 0 2
35628: ARRAY
35629: PUSH
35630: LD_VAR 0 3
35634: ARRAY
35635: PPUSH
35636: CALL_OW 122
// if not HasTask ( mc_miners [ i ] [ j ] ) then
35640: LD_EXP 94
35644: PUSH
35645: LD_VAR 0 2
35649: ARRAY
35650: PUSH
35651: LD_VAR 0 3
35655: ARRAY
35656: PPUSH
35657: CALL_OW 314
35661: NOT
35662: IFFALSE 35761
// begin r := ( j mod Count ( mc_mines [ i ] ) ) + 1 ;
35664: LD_ADDR_VAR 0 7
35668: PUSH
35669: LD_VAR 0 3
35673: PUSH
35674: LD_EXP 93
35678: PUSH
35679: LD_VAR 0 2
35683: ARRAY
35684: PPUSH
35685: CALL 55580 0 1
35689: MOD
35690: PUSH
35691: LD_INT 1
35693: PLUS
35694: ST_TO_ADDR
// AddComPlaceRemoteCharge ( mc_miners [ i ] [ j ] , mc_mines [ i ] [ r ] [ 1 ] , mc_mines [ i ] [ r ] [ 2 ] , 0 ) ;
35695: LD_EXP 94
35699: PUSH
35700: LD_VAR 0 2
35704: ARRAY
35705: PUSH
35706: LD_VAR 0 3
35710: ARRAY
35711: PPUSH
35712: LD_EXP 93
35716: PUSH
35717: LD_VAR 0 2
35721: ARRAY
35722: PUSH
35723: LD_VAR 0 7
35727: ARRAY
35728: PUSH
35729: LD_INT 1
35731: ARRAY
35732: PPUSH
35733: LD_EXP 93
35737: PUSH
35738: LD_VAR 0 2
35742: ARRAY
35743: PUSH
35744: LD_VAR 0 7
35748: ARRAY
35749: PUSH
35750: LD_INT 2
35752: ARRAY
35753: PPUSH
35754: LD_INT 0
35756: PPUSH
35757: CALL_OW 193
// end ; end ; end ;
35761: GO 35407
35763: POP
35764: POP
// end ; tmp := UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_armoury ] , [ f_btype , b_barracks ] , [ f_btype , b_bunker ] ] ) ;
35765: LD_ADDR_VAR 0 5
35769: PUSH
35770: LD_EXP 80
35774: PUSH
35775: LD_VAR 0 2
35779: ARRAY
35780: PPUSH
35781: LD_INT 2
35783: PUSH
35784: LD_INT 30
35786: PUSH
35787: LD_INT 4
35789: PUSH
35790: EMPTY
35791: LIST
35792: LIST
35793: PUSH
35794: LD_INT 30
35796: PUSH
35797: LD_INT 5
35799: PUSH
35800: EMPTY
35801: LIST
35802: LIST
35803: PUSH
35804: LD_INT 30
35806: PUSH
35807: LD_INT 32
35809: PUSH
35810: EMPTY
35811: LIST
35812: LIST
35813: PUSH
35814: EMPTY
35815: LIST
35816: LIST
35817: LIST
35818: LIST
35819: PPUSH
35820: CALL_OW 72
35824: ST_TO_ADDR
// if not tmp then
35825: LD_VAR 0 5
35829: NOT
35830: IFFALSE 35834
// continue ;
35832: GO 35320
// list := [ ] ;
35834: LD_ADDR_VAR 0 6
35838: PUSH
35839: EMPTY
35840: ST_TO_ADDR
// for j in tmp do
35841: LD_ADDR_VAR 0 3
35845: PUSH
35846: LD_VAR 0 5
35850: PUSH
35851: FOR_IN
35852: IFFALSE 35921
// begin for k in UnitsInside ( j ) do
35854: LD_ADDR_VAR 0 4
35858: PUSH
35859: LD_VAR 0 3
35863: PPUSH
35864: CALL_OW 313
35868: PUSH
35869: FOR_IN
35870: IFFALSE 35917
// if GetClass ( k ) = 1 and not MineOfUnit ( k ) then
35872: LD_VAR 0 4
35876: PPUSH
35877: CALL_OW 257
35881: PUSH
35882: LD_INT 1
35884: EQUAL
35885: PUSH
35886: LD_VAR 0 4
35890: PPUSH
35891: CALL_OW 459
35895: NOT
35896: AND
35897: IFFALSE 35915
// list := list ^ k ;
35899: LD_ADDR_VAR 0 6
35903: PUSH
35904: LD_VAR 0 6
35908: PUSH
35909: LD_VAR 0 4
35913: ADD
35914: ST_TO_ADDR
35915: GO 35869
35917: POP
35918: POP
// end ;
35919: GO 35851
35921: POP
35922: POP
// list := list diff mc_miners [ i ] ;
35923: LD_ADDR_VAR 0 6
35927: PUSH
35928: LD_VAR 0 6
35932: PUSH
35933: LD_EXP 94
35937: PUSH
35938: LD_VAR 0 2
35942: ARRAY
35943: DIFF
35944: ST_TO_ADDR
// if not list then
35945: LD_VAR 0 6
35949: NOT
35950: IFFALSE 35954
// continue ;
35952: GO 35320
// k := mc_mines [ i ] - mc_miners [ i ] ;
35954: LD_ADDR_VAR 0 4
35958: PUSH
35959: LD_EXP 93
35963: PUSH
35964: LD_VAR 0 2
35968: ARRAY
35969: PUSH
35970: LD_EXP 94
35974: PUSH
35975: LD_VAR 0 2
35979: ARRAY
35980: MINUS
35981: ST_TO_ADDR
// if k > list then
35982: LD_VAR 0 4
35986: PUSH
35987: LD_VAR 0 6
35991: GREATER
35992: IFFALSE 36004
// k := list ;
35994: LD_ADDR_VAR 0 4
35998: PUSH
35999: LD_VAR 0 6
36003: ST_TO_ADDR
// for j = 1 to k do
36004: LD_ADDR_VAR 0 3
36008: PUSH
36009: DOUBLE
36010: LD_INT 1
36012: DEC
36013: ST_TO_ADDR
36014: LD_VAR 0 4
36018: PUSH
36019: FOR_TO
36020: IFFALSE 36074
// mc_miners := ReplaceIn ( mc_miners , [ i , mc_miners [ i ] + 1 ] , list [ j ] ) ;
36022: LD_ADDR_EXP 94
36026: PUSH
36027: LD_EXP 94
36031: PPUSH
36032: LD_VAR 0 2
36036: PUSH
36037: LD_EXP 94
36041: PUSH
36042: LD_VAR 0 2
36046: ARRAY
36047: PUSH
36048: LD_INT 1
36050: PLUS
36051: PUSH
36052: EMPTY
36053: LIST
36054: LIST
36055: PPUSH
36056: LD_VAR 0 6
36060: PUSH
36061: LD_VAR 0 3
36065: ARRAY
36066: PPUSH
36067: CALL 58440 0 3
36071: ST_TO_ADDR
36072: GO 36019
36074: POP
36075: POP
// end ;
36076: GO 35320
36078: POP
36079: POP
// end ;
36080: LD_VAR 0 1
36084: RET
// export function MC_CollectCrates ( ) ; var i , j , k , tmp , side , target , cargo , depot , fac , components ; begin
36085: LD_INT 0
36087: PPUSH
36088: PPUSH
36089: PPUSH
36090: PPUSH
36091: PPUSH
36092: PPUSH
36093: PPUSH
36094: PPUSH
36095: PPUSH
36096: PPUSH
36097: PPUSH
// if not mc_bases then
36098: LD_EXP 80
36102: NOT
36103: IFFALSE 36107
// exit ;
36105: GO 37930
// for i = 1 to mc_bases do
36107: LD_ADDR_VAR 0 2
36111: PUSH
36112: DOUBLE
36113: LD_INT 1
36115: DEC
36116: ST_TO_ADDR
36117: LD_EXP 80
36121: PUSH
36122: FOR_TO
36123: IFFALSE 37928
// begin if not mc_bases [ i ] or mc_construct_list [ i ] then
36125: LD_EXP 80
36129: PUSH
36130: LD_VAR 0 2
36134: ARRAY
36135: NOT
36136: PUSH
36137: LD_EXP 87
36141: PUSH
36142: LD_VAR 0 2
36146: ARRAY
36147: OR
36148: IFFALSE 36152
// continue ;
36150: GO 36122
// if not mc_crates [ i ] and mc_crates_collector [ i ] then
36152: LD_EXP 96
36156: PUSH
36157: LD_VAR 0 2
36161: ARRAY
36162: NOT
36163: PUSH
36164: LD_EXP 97
36168: PUSH
36169: LD_VAR 0 2
36173: ARRAY
36174: AND
36175: IFFALSE 36213
// begin mc_crates_collector := Replace ( mc_crates_collector , i , [ ] ) ;
36177: LD_ADDR_EXP 97
36181: PUSH
36182: LD_EXP 97
36186: PPUSH
36187: LD_VAR 0 2
36191: PPUSH
36192: EMPTY
36193: PPUSH
36194: CALL_OW 1
36198: ST_TO_ADDR
// MC_Reset ( i , 107 ) ;
36199: LD_VAR 0 2
36203: PPUSH
36204: LD_INT 107
36206: PPUSH
36207: CALL 26939 0 2
// continue ;
36211: GO 36122
// end ; target := [ ] ;
36213: LD_ADDR_VAR 0 7
36217: PUSH
36218: EMPTY
36219: ST_TO_ADDR
// side := GetSide ( mc_bases [ i ] [ 1 ] ) ;
36220: LD_ADDR_VAR 0 6
36224: PUSH
36225: LD_EXP 80
36229: PUSH
36230: LD_VAR 0 2
36234: ARRAY
36235: PUSH
36236: LD_INT 1
36238: ARRAY
36239: PPUSH
36240: CALL_OW 255
36244: ST_TO_ADDR
// depot := UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) ;
36245: LD_ADDR_VAR 0 9
36249: PUSH
36250: LD_EXP 80
36254: PUSH
36255: LD_VAR 0 2
36259: ARRAY
36260: PPUSH
36261: LD_INT 2
36263: PUSH
36264: LD_INT 30
36266: PUSH
36267: LD_INT 0
36269: PUSH
36270: EMPTY
36271: LIST
36272: LIST
36273: PUSH
36274: LD_INT 30
36276: PUSH
36277: LD_INT 1
36279: PUSH
36280: EMPTY
36281: LIST
36282: LIST
36283: PUSH
36284: EMPTY
36285: LIST
36286: LIST
36287: LIST
36288: PPUSH
36289: CALL_OW 72
36293: ST_TO_ADDR
// for j = mc_crates [ i ] downto 1 do
36294: LD_ADDR_VAR 0 3
36298: PUSH
36299: DOUBLE
36300: LD_EXP 96
36304: PUSH
36305: LD_VAR 0 2
36309: ARRAY
36310: INC
36311: ST_TO_ADDR
36312: LD_INT 1
36314: PUSH
36315: FOR_DOWNTO
36316: IFFALSE 36561
// begin if ValidHex ( mc_crates [ i ] [ j ] [ 2 ] , mc_crates [ i ] [ j ] [ 3 ] ) and GetResourceAmountXY ( mc_crates [ i ] [ j ] [ 2 ] , mc_crates [ i ] [ j ] [ 3 ] ) = 0 then
36318: LD_EXP 96
36322: PUSH
36323: LD_VAR 0 2
36327: ARRAY
36328: PUSH
36329: LD_VAR 0 3
36333: ARRAY
36334: PUSH
36335: LD_INT 2
36337: ARRAY
36338: PPUSH
36339: LD_EXP 96
36343: PUSH
36344: LD_VAR 0 2
36348: ARRAY
36349: PUSH
36350: LD_VAR 0 3
36354: ARRAY
36355: PUSH
36356: LD_INT 3
36358: ARRAY
36359: PPUSH
36360: CALL_OW 488
36364: PUSH
36365: LD_EXP 96
36369: PUSH
36370: LD_VAR 0 2
36374: ARRAY
36375: PUSH
36376: LD_VAR 0 3
36380: ARRAY
36381: PUSH
36382: LD_INT 2
36384: ARRAY
36385: PPUSH
36386: LD_EXP 96
36390: PUSH
36391: LD_VAR 0 2
36395: ARRAY
36396: PUSH
36397: LD_VAR 0 3
36401: ARRAY
36402: PUSH
36403: LD_INT 3
36405: ARRAY
36406: PPUSH
36407: CALL_OW 284
36411: PUSH
36412: LD_INT 0
36414: EQUAL
36415: AND
36416: IFFALSE 36471
// begin tmp := Delete ( mc_crates [ i ] , j ) ;
36418: LD_ADDR_VAR 0 5
36422: PUSH
36423: LD_EXP 96
36427: PUSH
36428: LD_VAR 0 2
36432: ARRAY
36433: PPUSH
36434: LD_VAR 0 3
36438: PPUSH
36439: CALL_OW 3
36443: ST_TO_ADDR
// mc_crates := Replace ( mc_crates , i , tmp ) ;
36444: LD_ADDR_EXP 96
36448: PUSH
36449: LD_EXP 96
36453: PPUSH
36454: LD_VAR 0 2
36458: PPUSH
36459: LD_VAR 0 5
36463: PPUSH
36464: CALL_OW 1
36468: ST_TO_ADDR
// continue ;
36469: GO 36315
// end ; if DangerAtRangeXY ( side , mc_crates [ i ] [ j ] [ 2 ] , mc_crates [ i ] [ j ] [ 3 ] , 30 ) [ 4 ] = 0 then
36471: LD_VAR 0 6
36475: PPUSH
36476: LD_EXP 96
36480: PUSH
36481: LD_VAR 0 2
36485: ARRAY
36486: PUSH
36487: LD_VAR 0 3
36491: ARRAY
36492: PUSH
36493: LD_INT 2
36495: ARRAY
36496: PPUSH
36497: LD_EXP 96
36501: PUSH
36502: LD_VAR 0 2
36506: ARRAY
36507: PUSH
36508: LD_VAR 0 3
36512: ARRAY
36513: PUSH
36514: LD_INT 3
36516: ARRAY
36517: PPUSH
36518: LD_INT 30
36520: PPUSH
36521: CALL 59704 0 4
36525: PUSH
36526: LD_INT 4
36528: ARRAY
36529: PUSH
36530: LD_INT 0
36532: EQUAL
36533: IFFALSE 36559
// begin target := mc_crates [ i ] [ j ] ;
36535: LD_ADDR_VAR 0 7
36539: PUSH
36540: LD_EXP 96
36544: PUSH
36545: LD_VAR 0 2
36549: ARRAY
36550: PUSH
36551: LD_VAR 0 3
36555: ARRAY
36556: ST_TO_ADDR
// break ;
36557: GO 36561
// end ; end ;
36559: GO 36315
36561: POP
36562: POP
// if not target then
36563: LD_VAR 0 7
36567: NOT
36568: IFFALSE 36572
// continue ;
36570: GO 36122
// cargo := UnitFilter ( mc_vehicles [ i ] , [ [ f_or , [ f_not , [ f_empty ] ] , [ f_linked ] , [ f_control , control_apeman ] , [ f_control , control_computer ] ] , [ f_or , [ f_weapon , ar_cargo_bay ] , [ f_weapon , ru_cargo_bay ] , [ f_weapon , us_cargo_bay ] ] ] ) ;
36572: LD_ADDR_VAR 0 8
36576: PUSH
36577: LD_EXP 99
36581: PUSH
36582: LD_VAR 0 2
36586: ARRAY
36587: PPUSH
36588: LD_INT 2
36590: PUSH
36591: LD_INT 3
36593: PUSH
36594: LD_INT 58
36596: PUSH
36597: EMPTY
36598: LIST
36599: PUSH
36600: EMPTY
36601: LIST
36602: LIST
36603: PUSH
36604: LD_INT 61
36606: PUSH
36607: EMPTY
36608: LIST
36609: PUSH
36610: LD_INT 33
36612: PUSH
36613: LD_INT 5
36615: PUSH
36616: EMPTY
36617: LIST
36618: LIST
36619: PUSH
36620: LD_INT 33
36622: PUSH
36623: LD_INT 3
36625: PUSH
36626: EMPTY
36627: LIST
36628: LIST
36629: PUSH
36630: EMPTY
36631: LIST
36632: LIST
36633: LIST
36634: LIST
36635: LIST
36636: PUSH
36637: LD_INT 2
36639: PUSH
36640: LD_INT 34
36642: PUSH
36643: LD_INT 32
36645: PUSH
36646: EMPTY
36647: LIST
36648: LIST
36649: PUSH
36650: LD_INT 34
36652: PUSH
36653: LD_INT 51
36655: PUSH
36656: EMPTY
36657: LIST
36658: LIST
36659: PUSH
36660: LD_INT 34
36662: PUSH
36663: LD_INT 12
36665: PUSH
36666: EMPTY
36667: LIST
36668: LIST
36669: PUSH
36670: EMPTY
36671: LIST
36672: LIST
36673: LIST
36674: LIST
36675: PUSH
36676: EMPTY
36677: LIST
36678: LIST
36679: PPUSH
36680: CALL_OW 72
36684: ST_TO_ADDR
// if not cargo then
36685: LD_VAR 0 8
36689: NOT
36690: IFFALSE 37396
// begin if mc_crates_collector [ i ] < 5 then
36692: LD_EXP 97
36696: PUSH
36697: LD_VAR 0 2
36701: ARRAY
36702: PUSH
36703: LD_INT 5
36705: LESS
36706: IFFALSE 37072
// begin if mc_ape [ i ] then
36708: LD_EXP 109
36712: PUSH
36713: LD_VAR 0 2
36717: ARRAY
36718: IFFALSE 36765
// tmp := UnitFilter ( mc_ape [ i ] , [ [ f_class , 16 ] , [ f_lives , 750 ] ] ) ;
36720: LD_ADDR_VAR 0 5
36724: PUSH
36725: LD_EXP 109
36729: PUSH
36730: LD_VAR 0 2
36734: ARRAY
36735: PPUSH
36736: LD_INT 25
36738: PUSH
36739: LD_INT 16
36741: PUSH
36742: EMPTY
36743: LIST
36744: LIST
36745: PUSH
36746: LD_INT 24
36748: PUSH
36749: LD_INT 750
36751: PUSH
36752: EMPTY
36753: LIST
36754: LIST
36755: PUSH
36756: EMPTY
36757: LIST
36758: LIST
36759: PPUSH
36760: CALL_OW 72
36764: ST_TO_ADDR
// if not tmp then
36765: LD_VAR 0 5
36769: NOT
36770: IFFALSE 36817
// tmp := UnitFilter ( mc_bases [ i ] , [ [ f_class , 2 ] , [ f_lives , 750 ] ] ) ;
36772: LD_ADDR_VAR 0 5
36776: PUSH
36777: LD_EXP 80
36781: PUSH
36782: LD_VAR 0 2
36786: ARRAY
36787: PPUSH
36788: LD_INT 25
36790: PUSH
36791: LD_INT 2
36793: PUSH
36794: EMPTY
36795: LIST
36796: LIST
36797: PUSH
36798: LD_INT 24
36800: PUSH
36801: LD_INT 750
36803: PUSH
36804: EMPTY
36805: LIST
36806: LIST
36807: PUSH
36808: EMPTY
36809: LIST
36810: LIST
36811: PPUSH
36812: CALL_OW 72
36816: ST_TO_ADDR
// if mc_ape [ i ] and UnitFilter ( mc_bases [ i ] , [ [ f_class , 2 ] , [ f_lives , 750 ] ] ) and tmp < 5 then
36817: LD_EXP 109
36821: PUSH
36822: LD_VAR 0 2
36826: ARRAY
36827: PUSH
36828: LD_EXP 80
36832: PUSH
36833: LD_VAR 0 2
36837: ARRAY
36838: PPUSH
36839: LD_INT 25
36841: PUSH
36842: LD_INT 2
36844: PUSH
36845: EMPTY
36846: LIST
36847: LIST
36848: PUSH
36849: LD_INT 24
36851: PUSH
36852: LD_INT 750
36854: PUSH
36855: EMPTY
36856: LIST
36857: LIST
36858: PUSH
36859: EMPTY
36860: LIST
36861: LIST
36862: PPUSH
36863: CALL_OW 72
36867: AND
36868: PUSH
36869: LD_VAR 0 5
36873: PUSH
36874: LD_INT 5
36876: LESS
36877: AND
36878: IFFALSE 36960
// begin for j in UnitFilter ( mc_bases [ i ] , [ [ f_class , 2 ] , [ f_lives , 750 ] ] ) do
36880: LD_ADDR_VAR 0 3
36884: PUSH
36885: LD_EXP 80
36889: PUSH
36890: LD_VAR 0 2
36894: ARRAY
36895: PPUSH
36896: LD_INT 25
36898: PUSH
36899: LD_INT 2
36901: PUSH
36902: EMPTY
36903: LIST
36904: LIST
36905: PUSH
36906: LD_INT 24
36908: PUSH
36909: LD_INT 750
36911: PUSH
36912: EMPTY
36913: LIST
36914: LIST
36915: PUSH
36916: EMPTY
36917: LIST
36918: LIST
36919: PPUSH
36920: CALL_OW 72
36924: PUSH
36925: FOR_IN
36926: IFFALSE 36958
// begin tmp := tmp union j ;
36928: LD_ADDR_VAR 0 5
36932: PUSH
36933: LD_VAR 0 5
36937: PUSH
36938: LD_VAR 0 3
36942: UNION
36943: ST_TO_ADDR
// if tmp >= 5 then
36944: LD_VAR 0 5
36948: PUSH
36949: LD_INT 5
36951: GREATEREQUAL
36952: IFFALSE 36956
// break ;
36954: GO 36958
// end ;
36956: GO 36925
36958: POP
36959: POP
// end ; if not tmp then
36960: LD_VAR 0 5
36964: NOT
36965: IFFALSE 36969
// continue ;
36967: GO 36122
// for j in tmp do
36969: LD_ADDR_VAR 0 3
36973: PUSH
36974: LD_VAR 0 5
36978: PUSH
36979: FOR_IN
36980: IFFALSE 37070
// if not GetTag ( j ) then
36982: LD_VAR 0 3
36986: PPUSH
36987: CALL_OW 110
36991: NOT
36992: IFFALSE 37068
// begin mc_crates_collector := ReplaceIn ( mc_crates_collector , [ i , mc_crates_collector [ i ] + 1 ] , j ) ;
36994: LD_ADDR_EXP 97
36998: PUSH
36999: LD_EXP 97
37003: PPUSH
37004: LD_VAR 0 2
37008: PUSH
37009: LD_EXP 97
37013: PUSH
37014: LD_VAR 0 2
37018: ARRAY
37019: PUSH
37020: LD_INT 1
37022: PLUS
37023: PUSH
37024: EMPTY
37025: LIST
37026: LIST
37027: PPUSH
37028: LD_VAR 0 3
37032: PPUSH
37033: CALL 58440 0 3
37037: ST_TO_ADDR
// SetTag ( j , 107 ) ;
37038: LD_VAR 0 3
37042: PPUSH
37043: LD_INT 107
37045: PPUSH
37046: CALL_OW 109
// if mc_crates_collector [ i ] >= 5 then
37050: LD_EXP 97
37054: PUSH
37055: LD_VAR 0 2
37059: ARRAY
37060: PUSH
37061: LD_INT 5
37063: GREATEREQUAL
37064: IFFALSE 37068
// break ;
37066: GO 37070
// end ;
37068: GO 36979
37070: POP
37071: POP
// end ; if mc_crates_collector [ i ] and target then
37072: LD_EXP 97
37076: PUSH
37077: LD_VAR 0 2
37081: ARRAY
37082: PUSH
37083: LD_VAR 0 7
37087: AND
37088: IFFALSE 37394
// begin if mc_crates_collector [ i ] < target [ 1 ] then
37090: LD_EXP 97
37094: PUSH
37095: LD_VAR 0 2
37099: ARRAY
37100: PUSH
37101: LD_VAR 0 7
37105: PUSH
37106: LD_INT 1
37108: ARRAY
37109: LESS
37110: IFFALSE 37130
// tmp := mc_crates_collector [ i ] else
37112: LD_ADDR_VAR 0 5
37116: PUSH
37117: LD_EXP 97
37121: PUSH
37122: LD_VAR 0 2
37126: ARRAY
37127: ST_TO_ADDR
37128: GO 37144
// tmp := target [ 1 ] ;
37130: LD_ADDR_VAR 0 5
37134: PUSH
37135: LD_VAR 0 7
37139: PUSH
37140: LD_INT 1
37142: ARRAY
37143: ST_TO_ADDR
// k := 0 ;
37144: LD_ADDR_VAR 0 4
37148: PUSH
37149: LD_INT 0
37151: ST_TO_ADDR
// for j in mc_crates_collector [ i ] do
37152: LD_ADDR_VAR 0 3
37156: PUSH
37157: LD_EXP 97
37161: PUSH
37162: LD_VAR 0 2
37166: ARRAY
37167: PUSH
37168: FOR_IN
37169: IFFALSE 37392
// begin k := k + 1 ;
37171: LD_ADDR_VAR 0 4
37175: PUSH
37176: LD_VAR 0 4
37180: PUSH
37181: LD_INT 1
37183: PLUS
37184: ST_TO_ADDR
// if k > tmp then
37185: LD_VAR 0 4
37189: PUSH
37190: LD_VAR 0 5
37194: GREATER
37195: IFFALSE 37199
// break ;
37197: GO 37392
// if not GetClass ( j ) in [ 2 , 16 ] then
37199: LD_VAR 0 3
37203: PPUSH
37204: CALL_OW 257
37208: PUSH
37209: LD_INT 2
37211: PUSH
37212: LD_INT 16
37214: PUSH
37215: EMPTY
37216: LIST
37217: LIST
37218: IN
37219: NOT
37220: IFFALSE 37273
// begin mc_crates_collector := Replace ( mc_crates_collector , i , mc_crates_collector [ i ] diff j ) ;
37222: LD_ADDR_EXP 97
37226: PUSH
37227: LD_EXP 97
37231: PPUSH
37232: LD_VAR 0 2
37236: PPUSH
37237: LD_EXP 97
37241: PUSH
37242: LD_VAR 0 2
37246: ARRAY
37247: PUSH
37248: LD_VAR 0 3
37252: DIFF
37253: PPUSH
37254: CALL_OW 1
37258: ST_TO_ADDR
// SetTag ( j , 0 ) ;
37259: LD_VAR 0 3
37263: PPUSH
37264: LD_INT 0
37266: PPUSH
37267: CALL_OW 109
// continue ;
37271: GO 37168
// end ; if IsInUnit ( j ) then
37273: LD_VAR 0 3
37277: PPUSH
37278: CALL_OW 310
37282: IFFALSE 37293
// ComExitBuilding ( j ) ;
37284: LD_VAR 0 3
37288: PPUSH
37289: CALL_OW 122
// wait ( 3 ) ;
37293: LD_INT 3
37295: PPUSH
37296: CALL_OW 67
// if HasTask ( j ) and DangerAtRangeXY ( side , target [ 2 ] , target [ 3 ] , 30 ) [ 4 ] then
37300: LD_VAR 0 3
37304: PPUSH
37305: CALL_OW 314
37309: PUSH
37310: LD_VAR 0 6
37314: PPUSH
37315: LD_VAR 0 7
37319: PUSH
37320: LD_INT 2
37322: ARRAY
37323: PPUSH
37324: LD_VAR 0 7
37328: PUSH
37329: LD_INT 3
37331: ARRAY
37332: PPUSH
37333: LD_INT 30
37335: PPUSH
37336: CALL 59704 0 4
37340: PUSH
37341: LD_INT 4
37343: ARRAY
37344: AND
37345: IFFALSE 37363
// ComStandNearbyBuilding ( j , depot ) else
37347: LD_VAR 0 3
37351: PPUSH
37352: LD_VAR 0 9
37356: PPUSH
37357: CALL 55042 0 2
37361: GO 37390
// ComCollect ( j , target [ 2 ] , target [ 3 ] ) ;
37363: LD_VAR 0 3
37367: PPUSH
37368: LD_VAR 0 7
37372: PUSH
37373: LD_INT 2
37375: ARRAY
37376: PPUSH
37377: LD_VAR 0 7
37381: PUSH
37382: LD_INT 3
37384: ARRAY
37385: PPUSH
37386: CALL_OW 117
// end ;
37390: GO 37168
37392: POP
37393: POP
// end ; end else
37394: GO 37926
// begin for j in cargo do
37396: LD_ADDR_VAR 0 3
37400: PUSH
37401: LD_VAR 0 8
37405: PUSH
37406: FOR_IN
37407: IFFALSE 37924
// begin if GetTag ( j ) <> 0 then
37409: LD_VAR 0 3
37413: PPUSH
37414: CALL_OW 110
37418: PUSH
37419: LD_INT 0
37421: NONEQUAL
37422: IFFALSE 37426
// continue ;
37424: GO 37406
// if GetLives ( j ) < 1000 and not IsInArea ( j , mc_parking [ i ] ) then
37426: LD_VAR 0 3
37430: PPUSH
37431: CALL_OW 256
37435: PUSH
37436: LD_INT 1000
37438: LESS
37439: PUSH
37440: LD_VAR 0 3
37444: PPUSH
37445: LD_EXP 104
37449: PUSH
37450: LD_VAR 0 2
37454: ARRAY
37455: PPUSH
37456: CALL_OW 308
37460: NOT
37461: AND
37462: IFFALSE 37484
// ComMoveToArea ( j , mc_parking [ i ] ) ;
37464: LD_VAR 0 3
37468: PPUSH
37469: LD_EXP 104
37473: PUSH
37474: LD_VAR 0 2
37478: ARRAY
37479: PPUSH
37480: CALL_OW 113
// if GetLives ( j ) < 1000 and IsInArea ( j , mc_parking [ i ] ) then
37484: LD_VAR 0 3
37488: PPUSH
37489: CALL_OW 256
37493: PUSH
37494: LD_INT 1000
37496: LESS
37497: PUSH
37498: LD_VAR 0 3
37502: PPUSH
37503: LD_EXP 104
37507: PUSH
37508: LD_VAR 0 2
37512: ARRAY
37513: PPUSH
37514: CALL_OW 308
37518: AND
37519: IFFALSE 37523
// continue ;
37521: GO 37406
// if GetEngine ( j ) = engine_solar and GetFuel ( j ) < 15 then
37523: LD_VAR 0 3
37527: PPUSH
37528: CALL_OW 262
37532: PUSH
37533: LD_INT 2
37535: EQUAL
37536: PUSH
37537: LD_VAR 0 3
37541: PPUSH
37542: CALL_OW 261
37546: PUSH
37547: LD_INT 15
37549: LESS
37550: AND
37551: IFFALSE 37555
// continue ;
37553: GO 37406
// if GetEngine ( j ) = engine_combustion and GetFuel ( j ) < 10 then
37555: LD_VAR 0 3
37559: PPUSH
37560: CALL_OW 262
37564: PUSH
37565: LD_INT 1
37567: EQUAL
37568: PUSH
37569: LD_VAR 0 3
37573: PPUSH
37574: CALL_OW 261
37578: PUSH
37579: LD_INT 10
37581: LESS
37582: AND
37583: IFFALSE 37863
// begin if not depot then
37585: LD_VAR 0 9
37589: NOT
37590: IFFALSE 37594
// continue ;
37592: GO 37406
// if GetDistUnits ( j , NearestUnitToUnit ( depot , j ) ) < 6 then
37594: LD_VAR 0 3
37598: PPUSH
37599: LD_VAR 0 9
37603: PPUSH
37604: LD_VAR 0 3
37608: PPUSH
37609: CALL_OW 74
37613: PPUSH
37614: CALL_OW 296
37618: PUSH
37619: LD_INT 6
37621: LESS
37622: IFFALSE 37638
// SetFuel ( j , 100 ) else
37624: LD_VAR 0 3
37628: PPUSH
37629: LD_INT 100
37631: PPUSH
37632: CALL_OW 240
37636: GO 37863
// if GetFuel ( j ) = 0 then
37638: LD_VAR 0 3
37642: PPUSH
37643: CALL_OW 261
37647: PUSH
37648: LD_INT 0
37650: EQUAL
37651: IFFALSE 37863
// begin mc_vehicles := Replace ( mc_vehicles , i , mc_vehicles [ i ] diff j ) ;
37653: LD_ADDR_EXP 99
37657: PUSH
37658: LD_EXP 99
37662: PPUSH
37663: LD_VAR 0 2
37667: PPUSH
37668: LD_EXP 99
37672: PUSH
37673: LD_VAR 0 2
37677: ARRAY
37678: PUSH
37679: LD_VAR 0 3
37683: DIFF
37684: PPUSH
37685: CALL_OW 1
37689: ST_TO_ADDR
// if GetControl ( j ) = control_manual then
37690: LD_VAR 0 3
37694: PPUSH
37695: CALL_OW 263
37699: PUSH
37700: LD_INT 1
37702: EQUAL
37703: IFFALSE 37719
// ComExitVehicle ( IsInUnit ( j ) ) ;
37705: LD_VAR 0 3
37709: PPUSH
37710: CALL_OW 310
37714: PPUSH
37715: CALL_OW 121
// if GetControl ( j ) = control_remote then
37719: LD_VAR 0 3
37723: PPUSH
37724: CALL_OW 263
37728: PUSH
37729: LD_INT 2
37731: EQUAL
37732: IFFALSE 37743
// ComUnlink ( j ) ;
37734: LD_VAR 0 3
37738: PPUSH
37739: CALL_OW 136
// fac := MC_GetBuildings ( i , b_factory ) ;
37743: LD_ADDR_VAR 0 10
37747: PUSH
37748: LD_VAR 0 2
37752: PPUSH
37753: LD_INT 3
37755: PPUSH
37756: CALL 47507 0 2
37760: ST_TO_ADDR
// if fac then
37761: LD_VAR 0 10
37765: IFFALSE 37861
// begin for k in fac do
37767: LD_ADDR_VAR 0 4
37771: PUSH
37772: LD_VAR 0 10
37776: PUSH
37777: FOR_IN
37778: IFFALSE 37859
// begin components := Produce ( fac , GetChassis ( j ) , GetEngine ( j ) , GetControl ( j ) , GetWeapon ( j ) ) ;
37780: LD_ADDR_VAR 0 11
37784: PUSH
37785: LD_VAR 0 10
37789: PPUSH
37790: LD_VAR 0 3
37794: PPUSH
37795: CALL_OW 265
37799: PPUSH
37800: LD_VAR 0 3
37804: PPUSH
37805: CALL_OW 262
37809: PPUSH
37810: LD_VAR 0 3
37814: PPUSH
37815: CALL_OW 263
37819: PPUSH
37820: LD_VAR 0 3
37824: PPUSH
37825: CALL_OW 264
37829: PPUSH
37830: CALL 55938 0 5
37834: ST_TO_ADDR
// if components then
37835: LD_VAR 0 11
37839: IFFALSE 37857
// begin MC_InsertProduceList ( i , components ) ;
37841: LD_VAR 0 2
37845: PPUSH
37846: LD_VAR 0 11
37850: PPUSH
37851: CALL 47052 0 2
// break ;
37855: GO 37859
// end ; end ;
37857: GO 37777
37859: POP
37860: POP
// end ; continue ;
37861: GO 37406
// end ; end ; if GetCargo ( j , mat_cans ) < 100 and not HasTask ( j ) then
37863: LD_VAR 0 3
37867: PPUSH
37868: LD_INT 1
37870: PPUSH
37871: CALL_OW 289
37875: PUSH
37876: LD_INT 100
37878: LESS
37879: PUSH
37880: LD_VAR 0 3
37884: PPUSH
37885: CALL_OW 314
37889: NOT
37890: AND
37891: IFFALSE 37920
// ComCollect ( j , target [ 2 ] , target [ 3 ] ) ;
37893: LD_VAR 0 3
37897: PPUSH
37898: LD_VAR 0 7
37902: PUSH
37903: LD_INT 2
37905: ARRAY
37906: PPUSH
37907: LD_VAR 0 7
37911: PUSH
37912: LD_INT 3
37914: ARRAY
37915: PPUSH
37916: CALL_OW 117
// break ;
37920: GO 37924
// end ;
37922: GO 37406
37924: POP
37925: POP
// end ; end ;
37926: GO 36122
37928: POP
37929: POP
// end ;
37930: LD_VAR 0 1
37934: RET
// export function MC_LinkRemoteControl ( ) ; var i , j , tmp ; begin
37935: LD_INT 0
37937: PPUSH
37938: PPUSH
37939: PPUSH
37940: PPUSH
// if not mc_bases then
37941: LD_EXP 80
37945: NOT
37946: IFFALSE 37950
// exit ;
37948: GO 38111
// for i = 1 to mc_bases do
37950: LD_ADDR_VAR 0 2
37954: PUSH
37955: DOUBLE
37956: LD_INT 1
37958: DEC
37959: ST_TO_ADDR
37960: LD_EXP 80
37964: PUSH
37965: FOR_TO
37966: IFFALSE 38109
// begin tmp := UnitFilter ( mc_vehicles [ i ] union mc_defender [ i ] , [ f_control , control_remote ] ) ;
37968: LD_ADDR_VAR 0 4
37972: PUSH
37973: LD_EXP 99
37977: PUSH
37978: LD_VAR 0 2
37982: ARRAY
37983: PUSH
37984: LD_EXP 102
37988: PUSH
37989: LD_VAR 0 2
37993: ARRAY
37994: UNION
37995: PPUSH
37996: LD_INT 33
37998: PUSH
37999: LD_INT 2
38001: PUSH
38002: EMPTY
38003: LIST
38004: LIST
38005: PPUSH
38006: CALL_OW 72
38010: ST_TO_ADDR
// if tmp then
38011: LD_VAR 0 4
38015: IFFALSE 38107
// for j in tmp do
38017: LD_ADDR_VAR 0 3
38021: PUSH
38022: LD_VAR 0 4
38026: PUSH
38027: FOR_IN
38028: IFFALSE 38105
// if not IsControledBy ( j ) and GetLives ( j ) >= 250 then
38030: LD_VAR 0 3
38034: PPUSH
38035: CALL_OW 312
38039: NOT
38040: PUSH
38041: LD_VAR 0 3
38045: PPUSH
38046: CALL_OW 256
38050: PUSH
38051: LD_INT 250
38053: GREATEREQUAL
38054: AND
38055: IFFALSE 38068
// Connect ( j ) else
38057: LD_VAR 0 3
38061: PPUSH
38062: CALL 61786 0 1
38066: GO 38103
// if GetLives ( j ) < 250 and IsControledBy ( j ) then
38068: LD_VAR 0 3
38072: PPUSH
38073: CALL_OW 256
38077: PUSH
38078: LD_INT 250
38080: LESS
38081: PUSH
38082: LD_VAR 0 3
38086: PPUSH
38087: CALL_OW 312
38091: AND
38092: IFFALSE 38103
// ComUnlink ( j ) ;
38094: LD_VAR 0 3
38098: PPUSH
38099: CALL_OW 136
38103: GO 38027
38105: POP
38106: POP
// end ;
38107: GO 37965
38109: POP
38110: POP
// end ;
38111: LD_VAR 0 1
38115: RET
// export function MC_ProduceVehicle ( ) ; var i , j , tmp , fac ; begin
38116: LD_INT 0
38118: PPUSH
38119: PPUSH
38120: PPUSH
38121: PPUSH
38122: PPUSH
// if not mc_bases then
38123: LD_EXP 80
38127: NOT
38128: IFFALSE 38132
// exit ;
38130: GO 38577
// for i = 1 to mc_bases do
38132: LD_ADDR_VAR 0 2
38136: PUSH
38137: DOUBLE
38138: LD_INT 1
38140: DEC
38141: ST_TO_ADDR
38142: LD_EXP 80
38146: PUSH
38147: FOR_TO
38148: IFFALSE 38575
// begin if not mc_produce [ i ] then
38150: LD_EXP 101
38154: PUSH
38155: LD_VAR 0 2
38159: ARRAY
38160: NOT
38161: IFFALSE 38165
// continue ;
38163: GO 38147
// fac := UnitFilter ( mc_bases [ i ] , [ f_btype , b_factory ] ) ;
38165: LD_ADDR_VAR 0 5
38169: PUSH
38170: LD_EXP 80
38174: PUSH
38175: LD_VAR 0 2
38179: ARRAY
38180: PPUSH
38181: LD_INT 30
38183: PUSH
38184: LD_INT 3
38186: PUSH
38187: EMPTY
38188: LIST
38189: LIST
38190: PPUSH
38191: CALL_OW 72
38195: ST_TO_ADDR
// if not fac then
38196: LD_VAR 0 5
38200: NOT
38201: IFFALSE 38205
// continue ;
38203: GO 38147
// for j in fac do
38205: LD_ADDR_VAR 0 3
38209: PUSH
38210: LD_VAR 0 5
38214: PUSH
38215: FOR_IN
38216: IFFALSE 38571
// begin if BuildingStatus ( j ) <> bs_idle or DangerAtRange ( j , 15 ) [ 4 ] then
38218: LD_VAR 0 3
38222: PPUSH
38223: CALL_OW 461
38227: PUSH
38228: LD_INT 2
38230: NONEQUAL
38231: PUSH
38232: LD_VAR 0 3
38236: PPUSH
38237: LD_INT 15
38239: PPUSH
38240: CALL 61405 0 2
38244: PUSH
38245: LD_INT 4
38247: ARRAY
38248: OR
38249: IFFALSE 38253
// continue ;
38251: GO 38215
// if CanBeConstructed ( j , mc_produce [ i ] [ 1 ] [ 1 ] , mc_produce [ i ] [ 1 ] [ 2 ] , mc_produce [ i ] [ 1 ] [ 3 ] , mc_produce [ i ] [ 1 ] [ 4 ] ) and VehicleCost ( j , [ mc_produce [ i ] [ 1 ] [ 1 ] , mc_produce [ i ] [ 1 ] [ 2 ] , mc_produce [ i ] [ 1 ] [ 3 ] , mc_produce [ i ] [ 1 ] [ 4 ] ] ) then
38253: LD_VAR 0 3
38257: PPUSH
38258: LD_EXP 101
38262: PUSH
38263: LD_VAR 0 2
38267: ARRAY
38268: PUSH
38269: LD_INT 1
38271: ARRAY
38272: PUSH
38273: LD_INT 1
38275: ARRAY
38276: PPUSH
38277: LD_EXP 101
38281: PUSH
38282: LD_VAR 0 2
38286: ARRAY
38287: PUSH
38288: LD_INT 1
38290: ARRAY
38291: PUSH
38292: LD_INT 2
38294: ARRAY
38295: PPUSH
38296: LD_EXP 101
38300: PUSH
38301: LD_VAR 0 2
38305: ARRAY
38306: PUSH
38307: LD_INT 1
38309: ARRAY
38310: PUSH
38311: LD_INT 3
38313: ARRAY
38314: PPUSH
38315: LD_EXP 101
38319: PUSH
38320: LD_VAR 0 2
38324: ARRAY
38325: PUSH
38326: LD_INT 1
38328: ARRAY
38329: PUSH
38330: LD_INT 4
38332: ARRAY
38333: PPUSH
38334: CALL_OW 448
38338: PUSH
38339: LD_VAR 0 3
38343: PPUSH
38344: LD_EXP 101
38348: PUSH
38349: LD_VAR 0 2
38353: ARRAY
38354: PUSH
38355: LD_INT 1
38357: ARRAY
38358: PUSH
38359: LD_INT 1
38361: ARRAY
38362: PUSH
38363: LD_EXP 101
38367: PUSH
38368: LD_VAR 0 2
38372: ARRAY
38373: PUSH
38374: LD_INT 1
38376: ARRAY
38377: PUSH
38378: LD_INT 2
38380: ARRAY
38381: PUSH
38382: LD_EXP 101
38386: PUSH
38387: LD_VAR 0 2
38391: ARRAY
38392: PUSH
38393: LD_INT 1
38395: ARRAY
38396: PUSH
38397: LD_INT 3
38399: ARRAY
38400: PUSH
38401: LD_EXP 101
38405: PUSH
38406: LD_VAR 0 2
38410: ARRAY
38411: PUSH
38412: LD_INT 1
38414: ARRAY
38415: PUSH
38416: LD_INT 4
38418: ARRAY
38419: PUSH
38420: EMPTY
38421: LIST
38422: LIST
38423: LIST
38424: LIST
38425: PPUSH
38426: CALL 65181 0 2
38430: AND
38431: IFFALSE 38569
// begin AddComConstruct ( j , mc_produce [ i ] [ 1 ] [ 1 ] , mc_produce [ i ] [ 1 ] [ 2 ] , mc_produce [ i ] [ 1 ] [ 3 ] , mc_produce [ i ] [ 1 ] [ 4 ] ) ;
38433: LD_VAR 0 3
38437: PPUSH
38438: LD_EXP 101
38442: PUSH
38443: LD_VAR 0 2
38447: ARRAY
38448: PUSH
38449: LD_INT 1
38451: ARRAY
38452: PUSH
38453: LD_INT 1
38455: ARRAY
38456: PPUSH
38457: LD_EXP 101
38461: PUSH
38462: LD_VAR 0 2
38466: ARRAY
38467: PUSH
38468: LD_INT 1
38470: ARRAY
38471: PUSH
38472: LD_INT 2
38474: ARRAY
38475: PPUSH
38476: LD_EXP 101
38480: PUSH
38481: LD_VAR 0 2
38485: ARRAY
38486: PUSH
38487: LD_INT 1
38489: ARRAY
38490: PUSH
38491: LD_INT 3
38493: ARRAY
38494: PPUSH
38495: LD_EXP 101
38499: PUSH
38500: LD_VAR 0 2
38504: ARRAY
38505: PUSH
38506: LD_INT 1
38508: ARRAY
38509: PUSH
38510: LD_INT 4
38512: ARRAY
38513: PPUSH
38514: CALL_OW 185
// tmp := Delete ( mc_produce [ i ] , 1 ) ;
38518: LD_ADDR_VAR 0 4
38522: PUSH
38523: LD_EXP 101
38527: PUSH
38528: LD_VAR 0 2
38532: ARRAY
38533: PPUSH
38534: LD_INT 1
38536: PPUSH
38537: CALL_OW 3
38541: ST_TO_ADDR
// mc_produce := Replace ( mc_produce , i , tmp ) ;
38542: LD_ADDR_EXP 101
38546: PUSH
38547: LD_EXP 101
38551: PPUSH
38552: LD_VAR 0 2
38556: PPUSH
38557: LD_VAR 0 4
38561: PPUSH
38562: CALL_OW 1
38566: ST_TO_ADDR
// break ;
38567: GO 38571
// end ; end ;
38569: GO 38215
38571: POP
38572: POP
// end ;
38573: GO 38147
38575: POP
38576: POP
// end ;
38577: LD_VAR 0 1
38581: RET
// export function MC_SendAttack ( ) ; var i , tmp ; begin
38582: LD_INT 0
38584: PPUSH
38585: PPUSH
38586: PPUSH
// if not mc_bases then
38587: LD_EXP 80
38591: NOT
38592: IFFALSE 38596
// exit ;
38594: GO 38685
// for i = 1 to mc_bases do
38596: LD_ADDR_VAR 0 2
38600: PUSH
38601: DOUBLE
38602: LD_INT 1
38604: DEC
38605: ST_TO_ADDR
38606: LD_EXP 80
38610: PUSH
38611: FOR_TO
38612: IFFALSE 38683
// begin if mc_attack [ i ] then
38614: LD_EXP 100
38618: PUSH
38619: LD_VAR 0 2
38623: ARRAY
38624: IFFALSE 38681
// begin tmp := mc_attack [ i ] [ 1 ] ;
38626: LD_ADDR_VAR 0 3
38630: PUSH
38631: LD_EXP 100
38635: PUSH
38636: LD_VAR 0 2
38640: ARRAY
38641: PUSH
38642: LD_INT 1
38644: ARRAY
38645: ST_TO_ADDR
// mc_attack := Replace ( mc_attack , i , [ ] ) ;
38646: LD_ADDR_EXP 100
38650: PUSH
38651: LD_EXP 100
38655: PPUSH
38656: LD_VAR 0 2
38660: PPUSH
38661: EMPTY
38662: PPUSH
38663: CALL_OW 1
38667: ST_TO_ADDR
// Attack ( tmp ) ;
38668: LD_VAR 0 3
38672: PPUSH
38673: CALL 116962 0 1
// exit ;
38677: POP
38678: POP
38679: GO 38685
// end ; end ;
38681: GO 38611
38683: POP
38684: POP
// end ;
38685: LD_VAR 0 1
38689: RET
// export function MC_Defend ( ) ; var i , j , tmp , t , x , class ; begin
38690: LD_INT 0
38692: PPUSH
38693: PPUSH
38694: PPUSH
38695: PPUSH
38696: PPUSH
38697: PPUSH
38698: PPUSH
// if not mc_bases then
38699: LD_EXP 80
38703: NOT
38704: IFFALSE 38708
// exit ;
38706: GO 39565
// for i = 1 to mc_bases do
38708: LD_ADDR_VAR 0 2
38712: PUSH
38713: DOUBLE
38714: LD_INT 1
38716: DEC
38717: ST_TO_ADDR
38718: LD_EXP 80
38722: PUSH
38723: FOR_TO
38724: IFFALSE 39563
// begin if not mc_bases [ i ] then
38726: LD_EXP 80
38730: PUSH
38731: LD_VAR 0 2
38735: ARRAY
38736: NOT
38737: IFFALSE 38741
// continue ;
38739: GO 38723
// class := AllowSpecClass ( mc_bases [ i ] [ 1 ] ) ;
38741: LD_ADDR_VAR 0 7
38745: PUSH
38746: LD_EXP 80
38750: PUSH
38751: LD_VAR 0 2
38755: ARRAY
38756: PUSH
38757: LD_INT 1
38759: ARRAY
38760: PPUSH
38761: CALL 55264 0 1
38765: ST_TO_ADDR
// mc_scan := Replace ( mc_scan , i , ScanBase ( GetSide ( mc_bases [ i ] [ 1 ] ) , mc_scan_area [ i ] ) ) ;
38766: LD_ADDR_EXP 103
38770: PUSH
38771: LD_EXP 103
38775: PPUSH
38776: LD_VAR 0 2
38780: PPUSH
38781: LD_EXP 80
38785: PUSH
38786: LD_VAR 0 2
38790: ARRAY
38791: PUSH
38792: LD_INT 1
38794: ARRAY
38795: PPUSH
38796: CALL_OW 255
38800: PPUSH
38801: LD_EXP 105
38805: PUSH
38806: LD_VAR 0 2
38810: ARRAY
38811: PPUSH
38812: CALL 55229 0 2
38816: PPUSH
38817: CALL_OW 1
38821: ST_TO_ADDR
// if not mc_scan [ i ] then
38822: LD_EXP 103
38826: PUSH
38827: LD_VAR 0 2
38831: ARRAY
38832: NOT
38833: IFFALSE 39011
// begin mc_is_defending := Replace ( mc_is_defending , i , false ) ;
38835: LD_ADDR_EXP 123
38839: PUSH
38840: LD_EXP 123
38844: PPUSH
38845: LD_VAR 0 2
38849: PPUSH
38850: LD_INT 0
38852: PPUSH
38853: CALL_OW 1
38857: ST_TO_ADDR
// tmp := UnitFilter ( mc_bases [ i ] , [ f_or , [ f_class , 5 ] , [ f_class , 8 ] , [ f_class , 9 ] ] ) ;
38858: LD_ADDR_VAR 0 4
38862: PUSH
38863: LD_EXP 80
38867: PUSH
38868: LD_VAR 0 2
38872: ARRAY
38873: PPUSH
38874: LD_INT 2
38876: PUSH
38877: LD_INT 25
38879: PUSH
38880: LD_INT 5
38882: PUSH
38883: EMPTY
38884: LIST
38885: LIST
38886: PUSH
38887: LD_INT 25
38889: PUSH
38890: LD_INT 8
38892: PUSH
38893: EMPTY
38894: LIST
38895: LIST
38896: PUSH
38897: LD_INT 25
38899: PUSH
38900: LD_INT 9
38902: PUSH
38903: EMPTY
38904: LIST
38905: LIST
38906: PUSH
38907: EMPTY
38908: LIST
38909: LIST
38910: LIST
38911: LIST
38912: PPUSH
38913: CALL_OW 72
38917: ST_TO_ADDR
// if not tmp then
38918: LD_VAR 0 4
38922: NOT
38923: IFFALSE 38927
// continue ;
38925: GO 38723
// for j in tmp do
38927: LD_ADDR_VAR 0 3
38931: PUSH
38932: LD_VAR 0 4
38936: PUSH
38937: FOR_IN
38938: IFFALSE 39009
// if GetBType ( IsInUnit ( j ) ) = b_barracks and GetClass ( j ) = 1 and not MineOfUnit ( j ) and class then
38940: LD_VAR 0 3
38944: PPUSH
38945: CALL_OW 310
38949: PPUSH
38950: CALL_OW 266
38954: PUSH
38955: LD_INT 5
38957: EQUAL
38958: PUSH
38959: LD_VAR 0 3
38963: PPUSH
38964: CALL_OW 257
38968: PUSH
38969: LD_INT 1
38971: EQUAL
38972: AND
38973: PUSH
38974: LD_VAR 0 3
38978: PPUSH
38979: CALL_OW 459
38983: NOT
38984: AND
38985: PUSH
38986: LD_VAR 0 7
38990: AND
38991: IFFALSE 39007
// ComChangeProfession ( j , class ) ;
38993: LD_VAR 0 3
38997: PPUSH
38998: LD_VAR 0 7
39002: PPUSH
39003: CALL_OW 123
39007: GO 38937
39009: POP
39010: POP
// end ; if mc_scan [ i ] and not mc_is_defending [ i ] and not mc_defender [ i ] and ( UnitFilter ( mc_bases [ i ] , [ [ f_ok ] , [ f_or , [ f_btype , b_bunker ] , [ f_btype , b_turret ] , [ f_btype , b_armoury ] , [ f_btype , b_barracks ] ] ] ) < 4 or UnitFilter ( mc_bases [ i ] , [ [ f_not , [ f_lives , 1000 ] ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ] ) ) then
39011: LD_EXP 103
39015: PUSH
39016: LD_VAR 0 2
39020: ARRAY
39021: PUSH
39022: LD_EXP 123
39026: PUSH
39027: LD_VAR 0 2
39031: ARRAY
39032: NOT
39033: AND
39034: PUSH
39035: LD_EXP 102
39039: PUSH
39040: LD_VAR 0 2
39044: ARRAY
39045: NOT
39046: AND
39047: PUSH
39048: LD_EXP 80
39052: PUSH
39053: LD_VAR 0 2
39057: ARRAY
39058: PPUSH
39059: LD_INT 50
39061: PUSH
39062: EMPTY
39063: LIST
39064: PUSH
39065: LD_INT 2
39067: PUSH
39068: LD_INT 30
39070: PUSH
39071: LD_INT 32
39073: PUSH
39074: EMPTY
39075: LIST
39076: LIST
39077: PUSH
39078: LD_INT 30
39080: PUSH
39081: LD_INT 33
39083: PUSH
39084: EMPTY
39085: LIST
39086: LIST
39087: PUSH
39088: LD_INT 30
39090: PUSH
39091: LD_INT 4
39093: PUSH
39094: EMPTY
39095: LIST
39096: LIST
39097: PUSH
39098: LD_INT 30
39100: PUSH
39101: LD_INT 5
39103: PUSH
39104: EMPTY
39105: LIST
39106: LIST
39107: PUSH
39108: EMPTY
39109: LIST
39110: LIST
39111: LIST
39112: LIST
39113: LIST
39114: PUSH
39115: EMPTY
39116: LIST
39117: LIST
39118: PPUSH
39119: CALL_OW 72
39123: PUSH
39124: LD_INT 4
39126: LESS
39127: PUSH
39128: LD_EXP 80
39132: PUSH
39133: LD_VAR 0 2
39137: ARRAY
39138: PPUSH
39139: LD_INT 3
39141: PUSH
39142: LD_INT 24
39144: PUSH
39145: LD_INT 1000
39147: PUSH
39148: EMPTY
39149: LIST
39150: LIST
39151: PUSH
39152: EMPTY
39153: LIST
39154: LIST
39155: PUSH
39156: LD_INT 2
39158: PUSH
39159: LD_INT 30
39161: PUSH
39162: LD_INT 0
39164: PUSH
39165: EMPTY
39166: LIST
39167: LIST
39168: PUSH
39169: LD_INT 30
39171: PUSH
39172: LD_INT 1
39174: PUSH
39175: EMPTY
39176: LIST
39177: LIST
39178: PUSH
39179: EMPTY
39180: LIST
39181: LIST
39182: LIST
39183: PUSH
39184: EMPTY
39185: LIST
39186: LIST
39187: PPUSH
39188: CALL_OW 72
39192: OR
39193: AND
39194: IFFALSE 39445
// begin mc_is_defending := Replace ( mc_is_defending , i , true ) ;
39196: LD_ADDR_EXP 123
39200: PUSH
39201: LD_EXP 123
39205: PPUSH
39206: LD_VAR 0 2
39210: PPUSH
39211: LD_INT 1
39213: PPUSH
39214: CALL_OW 1
39218: ST_TO_ADDR
// tmp := UnitFilter ( mc_bases [ i ] , [ f_or , [ f_class , 1 ] , [ f_class , 5 ] , [ f_class , 8 ] , [ f_class , 9 ] ] ) ;
39219: LD_ADDR_VAR 0 4
39223: PUSH
39224: LD_EXP 80
39228: PUSH
39229: LD_VAR 0 2
39233: ARRAY
39234: PPUSH
39235: LD_INT 2
39237: PUSH
39238: LD_INT 25
39240: PUSH
39241: LD_INT 1
39243: PUSH
39244: EMPTY
39245: LIST
39246: LIST
39247: PUSH
39248: LD_INT 25
39250: PUSH
39251: LD_INT 5
39253: PUSH
39254: EMPTY
39255: LIST
39256: LIST
39257: PUSH
39258: LD_INT 25
39260: PUSH
39261: LD_INT 8
39263: PUSH
39264: EMPTY
39265: LIST
39266: LIST
39267: PUSH
39268: LD_INT 25
39270: PUSH
39271: LD_INT 9
39273: PUSH
39274: EMPTY
39275: LIST
39276: LIST
39277: PUSH
39278: EMPTY
39279: LIST
39280: LIST
39281: LIST
39282: LIST
39283: LIST
39284: PPUSH
39285: CALL_OW 72
39289: ST_TO_ADDR
// tmp := tmp diff FilterByTag ( tmp , 18 ) ;
39290: LD_ADDR_VAR 0 4
39294: PUSH
39295: LD_VAR 0 4
39299: PUSH
39300: LD_VAR 0 4
39304: PPUSH
39305: LD_INT 18
39307: PPUSH
39308: CALL 88738 0 2
39312: DIFF
39313: ST_TO_ADDR
// if not tmp and not UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_armoury ] , [ f_btype , b_barracks ] ] ) then
39314: LD_VAR 0 4
39318: NOT
39319: PUSH
39320: LD_EXP 80
39324: PUSH
39325: LD_VAR 0 2
39329: ARRAY
39330: PPUSH
39331: LD_INT 2
39333: PUSH
39334: LD_INT 30
39336: PUSH
39337: LD_INT 4
39339: PUSH
39340: EMPTY
39341: LIST
39342: LIST
39343: PUSH
39344: LD_INT 30
39346: PUSH
39347: LD_INT 5
39349: PUSH
39350: EMPTY
39351: LIST
39352: LIST
39353: PUSH
39354: EMPTY
39355: LIST
39356: LIST
39357: LIST
39358: PPUSH
39359: CALL_OW 72
39363: NOT
39364: AND
39365: IFFALSE 39427
// tmp := UnitFilter ( mc_bases [ i ] , [ f_or , [ f_class , 2 ] , [ f_class , 3 ] , [ f_class , 4 ] ] ) ;
39367: LD_ADDR_VAR 0 4
39371: PUSH
39372: LD_EXP 80
39376: PUSH
39377: LD_VAR 0 2
39381: ARRAY
39382: PPUSH
39383: LD_INT 2
39385: PUSH
39386: LD_INT 25
39388: PUSH
39389: LD_INT 2
39391: PUSH
39392: EMPTY
39393: LIST
39394: LIST
39395: PUSH
39396: LD_INT 25
39398: PUSH
39399: LD_INT 3
39401: PUSH
39402: EMPTY
39403: LIST
39404: LIST
39405: PUSH
39406: LD_INT 25
39408: PUSH
39409: LD_INT 4
39411: PUSH
39412: EMPTY
39413: LIST
39414: LIST
39415: PUSH
39416: EMPTY
39417: LIST
39418: LIST
39419: LIST
39420: LIST
39421: PPUSH
39422: CALL_OW 72
39426: ST_TO_ADDR
// BasicDefend ( i , tmp ) ;
39427: LD_VAR 0 2
39431: PPUSH
39432: LD_VAR 0 4
39436: PPUSH
39437: CALL 121671 0 2
// exit ;
39441: POP
39442: POP
39443: GO 39565
// end ; if mc_scan [ i ] and not mc_is_defending [ i ] and mc_defender [ i ] then
39445: LD_EXP 103
39449: PUSH
39450: LD_VAR 0 2
39454: ARRAY
39455: PUSH
39456: LD_EXP 123
39460: PUSH
39461: LD_VAR 0 2
39465: ARRAY
39466: NOT
39467: AND
39468: PUSH
39469: LD_EXP 102
39473: PUSH
39474: LD_VAR 0 2
39478: ARRAY
39479: AND
39480: IFFALSE 39561
// begin mc_is_defending := Replace ( mc_is_defending , i , true ) ;
39482: LD_ADDR_EXP 123
39486: PUSH
39487: LD_EXP 123
39491: PPUSH
39492: LD_VAR 0 2
39496: PPUSH
39497: LD_INT 1
39499: PPUSH
39500: CALL_OW 1
39504: ST_TO_ADDR
// tmp := mc_defender [ i ] ;
39505: LD_ADDR_VAR 0 4
39509: PUSH
39510: LD_EXP 102
39514: PUSH
39515: LD_VAR 0 2
39519: ARRAY
39520: ST_TO_ADDR
// mc_defender := Replace ( mc_defender , i , [ ] ) ;
39521: LD_ADDR_EXP 102
39525: PUSH
39526: LD_EXP 102
39530: PPUSH
39531: LD_VAR 0 2
39535: PPUSH
39536: EMPTY
39537: PPUSH
39538: CALL_OW 1
39542: ST_TO_ADDR
// Defend ( i , tmp ) ;
39543: LD_VAR 0 2
39547: PPUSH
39548: LD_VAR 0 4
39552: PPUSH
39553: CALL 122267 0 2
// exit ;
39557: POP
39558: POP
39559: GO 39565
// end ; end ;
39561: GO 38723
39563: POP
39564: POP
// end ;
39565: LD_VAR 0 1
39569: RET
// export function MC_Research ( ) ; var i , j , side , t , tmp , x , sci , tmp2 , researching , idle_lab ; begin
39570: LD_INT 0
39572: PPUSH
39573: PPUSH
39574: PPUSH
39575: PPUSH
39576: PPUSH
39577: PPUSH
39578: PPUSH
39579: PPUSH
39580: PPUSH
39581: PPUSH
39582: PPUSH
// if not mc_bases then
39583: LD_EXP 80
39587: NOT
39588: IFFALSE 39592
// exit ;
39590: GO 40679
// for i = 1 to mc_bases do
39592: LD_ADDR_VAR 0 2
39596: PUSH
39597: DOUBLE
39598: LD_INT 1
39600: DEC
39601: ST_TO_ADDR
39602: LD_EXP 80
39606: PUSH
39607: FOR_TO
39608: IFFALSE 40677
// begin tmp := mc_lab [ i ] ;
39610: LD_ADDR_VAR 0 6
39614: PUSH
39615: LD_EXP 113
39619: PUSH
39620: LD_VAR 0 2
39624: ARRAY
39625: ST_TO_ADDR
// if not tmp then
39626: LD_VAR 0 6
39630: NOT
39631: IFFALSE 39635
// continue ;
39633: GO 39607
// idle_lab := 0 ;
39635: LD_ADDR_VAR 0 11
39639: PUSH
39640: LD_INT 0
39642: ST_TO_ADDR
// for j in tmp do
39643: LD_ADDR_VAR 0 3
39647: PUSH
39648: LD_VAR 0 6
39652: PUSH
39653: FOR_IN
39654: IFFALSE 40673
// begin researching := false ;
39656: LD_ADDR_VAR 0 10
39660: PUSH
39661: LD_INT 0
39663: ST_TO_ADDR
// side := GetSide ( j ) ;
39664: LD_ADDR_VAR 0 4
39668: PUSH
39669: LD_VAR 0 3
39673: PPUSH
39674: CALL_OW 255
39678: ST_TO_ADDR
// if not mc_tech [ side ] then
39679: LD_EXP 107
39683: PUSH
39684: LD_VAR 0 4
39688: ARRAY
39689: NOT
39690: IFFALSE 39694
// continue ;
39692: GO 39653
// if BuildingStatus ( j ) = bs_idle then
39694: LD_VAR 0 3
39698: PPUSH
39699: CALL_OW 461
39703: PUSH
39704: LD_INT 2
39706: EQUAL
39707: IFFALSE 39895
// begin if idle_lab and UnitsInside ( j ) < 6 then
39709: LD_VAR 0 11
39713: PUSH
39714: LD_VAR 0 3
39718: PPUSH
39719: CALL_OW 313
39723: PUSH
39724: LD_INT 6
39726: LESS
39727: AND
39728: IFFALSE 39799
// begin tmp2 := UnitsInside ( idle_lab ) ;
39730: LD_ADDR_VAR 0 9
39734: PUSH
39735: LD_VAR 0 11
39739: PPUSH
39740: CALL_OW 313
39744: ST_TO_ADDR
// if tmp2 then
39745: LD_VAR 0 9
39749: IFFALSE 39791
// for x in tmp2 do
39751: LD_ADDR_VAR 0 7
39755: PUSH
39756: LD_VAR 0 9
39760: PUSH
39761: FOR_IN
39762: IFFALSE 39789
// begin ComExitBuilding ( x ) ;
39764: LD_VAR 0 7
39768: PPUSH
39769: CALL_OW 122
// AddComEnterUnit ( x , j ) ;
39773: LD_VAR 0 7
39777: PPUSH
39778: LD_VAR 0 3
39782: PPUSH
39783: CALL_OW 180
// end ;
39787: GO 39761
39789: POP
39790: POP
// idle_lab := 0 ;
39791: LD_ADDR_VAR 0 11
39795: PUSH
39796: LD_INT 0
39798: ST_TO_ADDR
// end ; for t in mc_tech [ side ] do
39799: LD_ADDR_VAR 0 5
39803: PUSH
39804: LD_EXP 107
39808: PUSH
39809: LD_VAR 0 4
39813: ARRAY
39814: PUSH
39815: FOR_IN
39816: IFFALSE 39876
// if CanBeResearched ( j , t ) and TechCanBeResearch ( side , t ) then
39818: LD_VAR 0 3
39822: PPUSH
39823: LD_VAR 0 5
39827: PPUSH
39828: CALL_OW 430
39832: PUSH
39833: LD_VAR 0 4
39837: PPUSH
39838: LD_VAR 0 5
39842: PPUSH
39843: CALL 54334 0 2
39847: AND
39848: IFFALSE 39874
// begin researching := true ;
39850: LD_ADDR_VAR 0 10
39854: PUSH
39855: LD_INT 1
39857: ST_TO_ADDR
// ComResearch ( j , t ) ;
39858: LD_VAR 0 3
39862: PPUSH
39863: LD_VAR 0 5
39867: PPUSH
39868: CALL_OW 124
// break ;
39872: GO 39876
// end ;
39874: GO 39815
39876: POP
39877: POP
// if not researching then
39878: LD_VAR 0 10
39882: NOT
39883: IFFALSE 39895
// idle_lab := j ;
39885: LD_ADDR_VAR 0 11
39889: PUSH
39890: LD_VAR 0 3
39894: ST_TO_ADDR
// end ; if BuildingStatus ( j ) = bs_need_ape then
39895: LD_VAR 0 3
39899: PPUSH
39900: CALL_OW 461
39904: PUSH
39905: LD_INT 10
39907: EQUAL
39908: IFFALSE 40496
// begin if not mc_ape [ i ] and not mc_ape_in_lab [ i ] and mc_tech [ side ] > 1 then
39910: LD_EXP 109
39914: PUSH
39915: LD_VAR 0 2
39919: ARRAY
39920: NOT
39921: PUSH
39922: LD_EXP 110
39926: PUSH
39927: LD_VAR 0 2
39931: ARRAY
39932: NOT
39933: AND
39934: PUSH
39935: LD_EXP 107
39939: PUSH
39940: LD_VAR 0 4
39944: ARRAY
39945: PUSH
39946: LD_INT 1
39948: GREATER
39949: AND
39950: IFFALSE 40081
// begin ComCancel ( j ) ;
39952: LD_VAR 0 3
39956: PPUSH
39957: CALL_OW 127
// mc_tech := Replace ( mc_tech , side , Reindex ( mc_tech [ side ] , mc_tech [ side ] - 1 , mc_tech [ side ] , false ) ) ;
39961: LD_ADDR_EXP 107
39965: PUSH
39966: LD_EXP 107
39970: PPUSH
39971: LD_VAR 0 4
39975: PPUSH
39976: LD_EXP 107
39980: PUSH
39981: LD_VAR 0 4
39985: ARRAY
39986: PPUSH
39987: LD_EXP 107
39991: PUSH
39992: LD_VAR 0 4
39996: ARRAY
39997: PUSH
39998: LD_INT 1
40000: MINUS
40001: PPUSH
40002: LD_EXP 107
40006: PUSH
40007: LD_VAR 0 4
40011: ARRAY
40012: PPUSH
40013: LD_INT 0
40015: PPUSH
40016: CALL 57858 0 4
40020: PPUSH
40021: CALL_OW 1
40025: ST_TO_ADDR
// mc_tech := Replace ( mc_tech , side , Reindex ( mc_tech [ side ] , mc_tech [ side ] , 1 , false ) ) ;
40026: LD_ADDR_EXP 107
40030: PUSH
40031: LD_EXP 107
40035: PPUSH
40036: LD_VAR 0 4
40040: PPUSH
40041: LD_EXP 107
40045: PUSH
40046: LD_VAR 0 4
40050: ARRAY
40051: PPUSH
40052: LD_EXP 107
40056: PUSH
40057: LD_VAR 0 4
40061: ARRAY
40062: PPUSH
40063: LD_INT 1
40065: PPUSH
40066: LD_INT 0
40068: PPUSH
40069: CALL 57858 0 4
40073: PPUSH
40074: CALL_OW 1
40078: ST_TO_ADDR
// continue ;
40079: GO 39653
// end ; if mc_ape [ i ] and not mc_ape_in_lab [ i ] then
40081: LD_EXP 109
40085: PUSH
40086: LD_VAR 0 2
40090: ARRAY
40091: PUSH
40092: LD_EXP 110
40096: PUSH
40097: LD_VAR 0 2
40101: ARRAY
40102: NOT
40103: AND
40104: IFFALSE 40231
// begin mc_ape_in_lab := ReplaceIn ( mc_ape_in_lab , [ i , mc_ape_in_lab [ i ] + 1 ] , mc_ape [ i ] [ 1 ] ) ;
40106: LD_ADDR_EXP 110
40110: PUSH
40111: LD_EXP 110
40115: PPUSH
40116: LD_VAR 0 2
40120: PUSH
40121: LD_EXP 110
40125: PUSH
40126: LD_VAR 0 2
40130: ARRAY
40131: PUSH
40132: LD_INT 1
40134: PLUS
40135: PUSH
40136: EMPTY
40137: LIST
40138: LIST
40139: PPUSH
40140: LD_EXP 109
40144: PUSH
40145: LD_VAR 0 2
40149: ARRAY
40150: PUSH
40151: LD_INT 1
40153: ARRAY
40154: PPUSH
40155: CALL 58440 0 3
40159: ST_TO_ADDR
// SetTag ( mc_ape [ i ] [ 1 ] , 112 ) ;
40160: LD_EXP 109
40164: PUSH
40165: LD_VAR 0 2
40169: ARRAY
40170: PUSH
40171: LD_INT 1
40173: ARRAY
40174: PPUSH
40175: LD_INT 112
40177: PPUSH
40178: CALL_OW 109
// tmp2 := Delete ( mc_ape [ i ] , 1 ) ;
40182: LD_ADDR_VAR 0 9
40186: PUSH
40187: LD_EXP 109
40191: PUSH
40192: LD_VAR 0 2
40196: ARRAY
40197: PPUSH
40198: LD_INT 1
40200: PPUSH
40201: CALL_OW 3
40205: ST_TO_ADDR
// mc_ape := Replace ( mc_ape , i , tmp2 ) ;
40206: LD_ADDR_EXP 109
40210: PUSH
40211: LD_EXP 109
40215: PPUSH
40216: LD_VAR 0 2
40220: PPUSH
40221: LD_VAR 0 9
40225: PPUSH
40226: CALL_OW 1
40230: ST_TO_ADDR
// end ; if mc_ape [ i ] and mc_ape_in_lab [ i ] and not IsInUnit ( mc_ape_in_lab [ i ] [ 1 ] ) and UnitsInside ( j ) = 6 then
40231: LD_EXP 109
40235: PUSH
40236: LD_VAR 0 2
40240: ARRAY
40241: PUSH
40242: LD_EXP 110
40246: PUSH
40247: LD_VAR 0 2
40251: ARRAY
40252: AND
40253: PUSH
40254: LD_EXP 110
40258: PUSH
40259: LD_VAR 0 2
40263: ARRAY
40264: PUSH
40265: LD_INT 1
40267: ARRAY
40268: PPUSH
40269: CALL_OW 310
40273: NOT
40274: AND
40275: PUSH
40276: LD_VAR 0 3
40280: PPUSH
40281: CALL_OW 313
40285: PUSH
40286: LD_INT 6
40288: EQUAL
40289: AND
40290: IFFALSE 40346
// begin tmp2 := UnitsInside ( j ) ;
40292: LD_ADDR_VAR 0 9
40296: PUSH
40297: LD_VAR 0 3
40301: PPUSH
40302: CALL_OW 313
40306: ST_TO_ADDR
// if tmp2 = 6 then
40307: LD_VAR 0 9
40311: PUSH
40312: LD_INT 6
40314: EQUAL
40315: IFFALSE 40346
// begin SetTag ( tmp2 [ 1 ] , 112 ) ;
40317: LD_VAR 0 9
40321: PUSH
40322: LD_INT 1
40324: ARRAY
40325: PPUSH
40326: LD_INT 112
40328: PPUSH
40329: CALL_OW 109
// ComExitBuilding ( tmp2 [ 1 ] ) ;
40333: LD_VAR 0 9
40337: PUSH
40338: LD_INT 1
40340: ARRAY
40341: PPUSH
40342: CALL_OW 122
// end ; end ; if mc_ape_in_lab [ i ] and not HasTask ( mc_ape_in_lab [ i ] [ 1 ] ) and not IsInUnit ( mc_ape_in_lab [ i ] [ 1 ] ) then
40346: LD_EXP 110
40350: PUSH
40351: LD_VAR 0 2
40355: ARRAY
40356: PUSH
40357: LD_EXP 110
40361: PUSH
40362: LD_VAR 0 2
40366: ARRAY
40367: PUSH
40368: LD_INT 1
40370: ARRAY
40371: PPUSH
40372: CALL_OW 314
40376: NOT
40377: AND
40378: PUSH
40379: LD_EXP 110
40383: PUSH
40384: LD_VAR 0 2
40388: ARRAY
40389: PUSH
40390: LD_INT 1
40392: ARRAY
40393: PPUSH
40394: CALL_OW 310
40398: NOT
40399: AND
40400: IFFALSE 40426
// ComEnterUnit ( mc_ape_in_lab [ i ] [ 1 ] , j ) ;
40402: LD_EXP 110
40406: PUSH
40407: LD_VAR 0 2
40411: ARRAY
40412: PUSH
40413: LD_INT 1
40415: ARRAY
40416: PPUSH
40417: LD_VAR 0 3
40421: PPUSH
40422: CALL_OW 120
// if IsInUnit ( mc_ape_in_lab [ i ] [ 1 ] ) and BuildingStatus ( IsInUnit ( mc_ape_in_lab [ i ] [ 1 ] ) ) <> bs_working then
40426: LD_EXP 110
40430: PUSH
40431: LD_VAR 0 2
40435: ARRAY
40436: PUSH
40437: LD_INT 1
40439: ARRAY
40440: PPUSH
40441: CALL_OW 310
40445: PUSH
40446: LD_EXP 110
40450: PUSH
40451: LD_VAR 0 2
40455: ARRAY
40456: PUSH
40457: LD_INT 1
40459: ARRAY
40460: PPUSH
40461: CALL_OW 310
40465: PPUSH
40466: CALL_OW 461
40470: PUSH
40471: LD_INT 3
40473: NONEQUAL
40474: AND
40475: IFFALSE 40496
// ComExitBuilding ( mc_ape_in_lab [ i ] [ 1 ] ) ;
40477: LD_EXP 110
40481: PUSH
40482: LD_VAR 0 2
40486: ARRAY
40487: PUSH
40488: LD_INT 1
40490: ARRAY
40491: PPUSH
40492: CALL_OW 122
// end ; if BuildingStatus ( j ) = bs_need_people and tmp > 1 then
40496: LD_VAR 0 3
40500: PPUSH
40501: CALL_OW 461
40505: PUSH
40506: LD_INT 6
40508: EQUAL
40509: PUSH
40510: LD_VAR 0 6
40514: PUSH
40515: LD_INT 1
40517: GREATER
40518: AND
40519: IFFALSE 40671
// begin sci := [ ] ;
40521: LD_ADDR_VAR 0 8
40525: PUSH
40526: EMPTY
40527: ST_TO_ADDR
// for x in ( tmp diff j ) do
40528: LD_ADDR_VAR 0 7
40532: PUSH
40533: LD_VAR 0 6
40537: PUSH
40538: LD_VAR 0 3
40542: DIFF
40543: PUSH
40544: FOR_IN
40545: IFFALSE 40597
// begin if sci = 6 then
40547: LD_VAR 0 8
40551: PUSH
40552: LD_INT 6
40554: EQUAL
40555: IFFALSE 40559
// break ;
40557: GO 40597
// if BuildingStatus ( x ) = bs_idle then
40559: LD_VAR 0 7
40563: PPUSH
40564: CALL_OW 461
40568: PUSH
40569: LD_INT 2
40571: EQUAL
40572: IFFALSE 40595
// sci := sci ^ UnitsInside ( x ) ;
40574: LD_ADDR_VAR 0 8
40578: PUSH
40579: LD_VAR 0 8
40583: PUSH
40584: LD_VAR 0 7
40588: PPUSH
40589: CALL_OW 313
40593: ADD
40594: ST_TO_ADDR
// end ;
40595: GO 40544
40597: POP
40598: POP
// if not sci then
40599: LD_VAR 0 8
40603: NOT
40604: IFFALSE 40608
// continue ;
40606: GO 39653
// for x in sci do
40608: LD_ADDR_VAR 0 7
40612: PUSH
40613: LD_VAR 0 8
40617: PUSH
40618: FOR_IN
40619: IFFALSE 40669
// if IsInUnit ( x ) and not HasTask ( x ) then
40621: LD_VAR 0 7
40625: PPUSH
40626: CALL_OW 310
40630: PUSH
40631: LD_VAR 0 7
40635: PPUSH
40636: CALL_OW 314
40640: NOT
40641: AND
40642: IFFALSE 40667
// begin ComExitBuilding ( x ) ;
40644: LD_VAR 0 7
40648: PPUSH
40649: CALL_OW 122
// AddComEnterUnit ( x , j ) ;
40653: LD_VAR 0 7
40657: PPUSH
40658: LD_VAR 0 3
40662: PPUSH
40663: CALL_OW 180
// end ;
40667: GO 40618
40669: POP
40670: POP
// end ; end ;
40671: GO 39653
40673: POP
40674: POP
// end ;
40675: GO 39607
40677: POP
40678: POP
// end ;
40679: LD_VAR 0 1
40683: RET
// export function MC_MinesTrigger ( ) ; var i ; begin
40684: LD_INT 0
40686: PPUSH
40687: PPUSH
// if not mc_bases then
40688: LD_EXP 80
40692: NOT
40693: IFFALSE 40697
// exit ;
40695: GO 40778
// for i = 1 to mc_bases do
40697: LD_ADDR_VAR 0 2
40701: PUSH
40702: DOUBLE
40703: LD_INT 1
40705: DEC
40706: ST_TO_ADDR
40707: LD_EXP 80
40711: PUSH
40712: FOR_TO
40713: IFFALSE 40776
// if mc_mines [ i ] and mc_miners [ i ] then
40715: LD_EXP 93
40719: PUSH
40720: LD_VAR 0 2
40724: ARRAY
40725: PUSH
40726: LD_EXP 94
40730: PUSH
40731: LD_VAR 0 2
40735: ARRAY
40736: AND
40737: IFFALSE 40774
// DetonateMines ( GetSide ( mc_miners [ i ] [ 1 ] ) , mc_mines [ i ] ) ;
40739: LD_EXP 94
40743: PUSH
40744: LD_VAR 0 2
40748: ARRAY
40749: PUSH
40750: LD_INT 1
40752: ARRAY
40753: PPUSH
40754: CALL_OW 255
40758: PPUSH
40759: LD_EXP 93
40763: PUSH
40764: LD_VAR 0 2
40768: ARRAY
40769: PPUSH
40770: CALL 55417 0 2
40774: GO 40712
40776: POP
40777: POP
// end ;
40778: LD_VAR 0 1
40782: RET
// export function MC_RepairVehicle ( ) ; var i , j , k , side , fac , vehs , tmp ; begin
40783: LD_INT 0
40785: PPUSH
40786: PPUSH
40787: PPUSH
40788: PPUSH
40789: PPUSH
40790: PPUSH
40791: PPUSH
40792: PPUSH
// if not mc_bases or not mc_parking then
40793: LD_EXP 80
40797: NOT
40798: PUSH
40799: LD_EXP 104
40803: NOT
40804: OR
40805: IFFALSE 40809
// exit ;
40807: GO 41547
// for i = 1 to mc_bases do
40809: LD_ADDR_VAR 0 2
40813: PUSH
40814: DOUBLE
40815: LD_INT 1
40817: DEC
40818: ST_TO_ADDR
40819: LD_EXP 80
40823: PUSH
40824: FOR_TO
40825: IFFALSE 41545
// begin if not mc_bases [ i ] or not mc_parking [ i ] then
40827: LD_EXP 80
40831: PUSH
40832: LD_VAR 0 2
40836: ARRAY
40837: NOT
40838: PUSH
40839: LD_EXP 104
40843: PUSH
40844: LD_VAR 0 2
40848: ARRAY
40849: NOT
40850: OR
40851: IFFALSE 40855
// continue ;
40853: GO 40824
// side := GetSide ( mc_bases [ i ] [ 1 ] ) ;
40855: LD_ADDR_VAR 0 5
40859: PUSH
40860: LD_EXP 80
40864: PUSH
40865: LD_VAR 0 2
40869: ARRAY
40870: PUSH
40871: LD_INT 1
40873: ARRAY
40874: PPUSH
40875: CALL_OW 255
40879: ST_TO_ADDR
// fac := UnitFilter ( mc_bases [ i ] , [ f_btype , b_factory ] ) ;
40880: LD_ADDR_VAR 0 6
40884: PUSH
40885: LD_EXP 80
40889: PUSH
40890: LD_VAR 0 2
40894: ARRAY
40895: PPUSH
40896: LD_INT 30
40898: PUSH
40899: LD_INT 3
40901: PUSH
40902: EMPTY
40903: LIST
40904: LIST
40905: PPUSH
40906: CALL_OW 72
40910: ST_TO_ADDR
// if not fac then
40911: LD_VAR 0 6
40915: NOT
40916: IFFALSE 40967
// fac := UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) ;
40918: LD_ADDR_VAR 0 6
40922: PUSH
40923: LD_EXP 80
40927: PUSH
40928: LD_VAR 0 2
40932: ARRAY
40933: PPUSH
40934: LD_INT 2
40936: PUSH
40937: LD_INT 30
40939: PUSH
40940: LD_INT 0
40942: PUSH
40943: EMPTY
40944: LIST
40945: LIST
40946: PUSH
40947: LD_INT 30
40949: PUSH
40950: LD_INT 1
40952: PUSH
40953: EMPTY
40954: LIST
40955: LIST
40956: PUSH
40957: EMPTY
40958: LIST
40959: LIST
40960: LIST
40961: PPUSH
40962: CALL_OW 72
40966: ST_TO_ADDR
// if not fac then
40967: LD_VAR 0 6
40971: NOT
40972: IFFALSE 40976
// continue ;
40974: GO 40824
// vehs := FilterUnitsInArea ( mc_parking [ i ] , [ [ f_side , side ] , [ f_type , unit_vehicle ] , [ f_not , [ f_hastask ] ] , [ f_not , [ f_lives , 1000 ] ] ] ) ;
40976: LD_ADDR_VAR 0 7
40980: PUSH
40981: LD_EXP 104
40985: PUSH
40986: LD_VAR 0 2
40990: ARRAY
40991: PPUSH
40992: LD_INT 22
40994: PUSH
40995: LD_VAR 0 5
40999: PUSH
41000: EMPTY
41001: LIST
41002: LIST
41003: PUSH
41004: LD_INT 21
41006: PUSH
41007: LD_INT 2
41009: PUSH
41010: EMPTY
41011: LIST
41012: LIST
41013: PUSH
41014: LD_INT 3
41016: PUSH
41017: LD_INT 60
41019: PUSH
41020: EMPTY
41021: LIST
41022: PUSH
41023: EMPTY
41024: LIST
41025: LIST
41026: PUSH
41027: LD_INT 3
41029: PUSH
41030: LD_INT 24
41032: PUSH
41033: LD_INT 1000
41035: PUSH
41036: EMPTY
41037: LIST
41038: LIST
41039: PUSH
41040: EMPTY
41041: LIST
41042: LIST
41043: PUSH
41044: EMPTY
41045: LIST
41046: LIST
41047: LIST
41048: LIST
41049: PPUSH
41050: CALL_OW 70
41054: ST_TO_ADDR
// for j in fac do
41055: LD_ADDR_VAR 0 3
41059: PUSH
41060: LD_VAR 0 6
41064: PUSH
41065: FOR_IN
41066: IFFALSE 41161
// vehs := vehs union FilterAllUnits ( [ [ f_side , side ] , [ f_dist , j , 15 ] , [ f_type , unit_vehicle ] , [ f_not , [ f_hastask ] ] , [ f_not , [ f_lives , 1000 ] ] ] ) ;
41068: LD_ADDR_VAR 0 7
41072: PUSH
41073: LD_VAR 0 7
41077: PUSH
41078: LD_INT 22
41080: PUSH
41081: LD_VAR 0 5
41085: PUSH
41086: EMPTY
41087: LIST
41088: LIST
41089: PUSH
41090: LD_INT 91
41092: PUSH
41093: LD_VAR 0 3
41097: PUSH
41098: LD_INT 15
41100: PUSH
41101: EMPTY
41102: LIST
41103: LIST
41104: LIST
41105: PUSH
41106: LD_INT 21
41108: PUSH
41109: LD_INT 2
41111: PUSH
41112: EMPTY
41113: LIST
41114: LIST
41115: PUSH
41116: LD_INT 3
41118: PUSH
41119: LD_INT 60
41121: PUSH
41122: EMPTY
41123: LIST
41124: PUSH
41125: EMPTY
41126: LIST
41127: LIST
41128: PUSH
41129: LD_INT 3
41131: PUSH
41132: LD_INT 24
41134: PUSH
41135: LD_INT 1000
41137: PUSH
41138: EMPTY
41139: LIST
41140: LIST
41141: PUSH
41142: EMPTY
41143: LIST
41144: LIST
41145: PUSH
41146: EMPTY
41147: LIST
41148: LIST
41149: LIST
41150: LIST
41151: LIST
41152: PPUSH
41153: CALL_OW 69
41157: UNION
41158: ST_TO_ADDR
41159: GO 41065
41161: POP
41162: POP
// if not vehs then
41163: LD_VAR 0 7
41167: NOT
41168: IFFALSE 41194
// begin mc_repair_vehicle := Replace ( mc_repair_vehicle , i , [ ] ) ;
41170: LD_ADDR_EXP 92
41174: PUSH
41175: LD_EXP 92
41179: PPUSH
41180: LD_VAR 0 2
41184: PPUSH
41185: EMPTY
41186: PPUSH
41187: CALL_OW 1
41191: ST_TO_ADDR
// continue ;
41192: GO 40824
// end ; tmp := UnitFilter ( mc_bases [ i ] , [ f_btype , b_factory ] ) ;
41194: LD_ADDR_VAR 0 8
41198: PUSH
41199: LD_EXP 80
41203: PUSH
41204: LD_VAR 0 2
41208: ARRAY
41209: PPUSH
41210: LD_INT 30
41212: PUSH
41213: LD_INT 3
41215: PUSH
41216: EMPTY
41217: LIST
41218: LIST
41219: PPUSH
41220: CALL_OW 72
41224: ST_TO_ADDR
// if tmp then
41225: LD_VAR 0 8
41229: IFFALSE 41332
// begin for j in tmp do
41231: LD_ADDR_VAR 0 3
41235: PUSH
41236: LD_VAR 0 8
41240: PUSH
41241: FOR_IN
41242: IFFALSE 41330
// for k in UnitsInside ( j ) do
41244: LD_ADDR_VAR 0 4
41248: PUSH
41249: LD_VAR 0 3
41253: PPUSH
41254: CALL_OW 313
41258: PUSH
41259: FOR_IN
41260: IFFALSE 41326
// if k then
41262: LD_VAR 0 4
41266: IFFALSE 41324
// if not k in mc_repair_vehicle [ i ] then
41268: LD_VAR 0 4
41272: PUSH
41273: LD_EXP 92
41277: PUSH
41278: LD_VAR 0 2
41282: ARRAY
41283: IN
41284: NOT
41285: IFFALSE 41324
// mc_repair_vehicle := Replace ( mc_repair_vehicle , i , mc_repair_vehicle [ i ] union k ) ;
41287: LD_ADDR_EXP 92
41291: PUSH
41292: LD_EXP 92
41296: PPUSH
41297: LD_VAR 0 2
41301: PPUSH
41302: LD_EXP 92
41306: PUSH
41307: LD_VAR 0 2
41311: ARRAY
41312: PUSH
41313: LD_VAR 0 4
41317: UNION
41318: PPUSH
41319: CALL_OW 1
41323: ST_TO_ADDR
41324: GO 41259
41326: POP
41327: POP
41328: GO 41241
41330: POP
41331: POP
// end ; if not mc_repair_vehicle [ i ] then
41332: LD_EXP 92
41336: PUSH
41337: LD_VAR 0 2
41341: ARRAY
41342: NOT
41343: IFFALSE 41347
// continue ;
41345: GO 40824
// for j in mc_repair_vehicle [ i ] do
41347: LD_ADDR_VAR 0 3
41351: PUSH
41352: LD_EXP 92
41356: PUSH
41357: LD_VAR 0 2
41361: ARRAY
41362: PUSH
41363: FOR_IN
41364: IFFALSE 41541
// begin if GetClass ( j ) <> 3 then
41366: LD_VAR 0 3
41370: PPUSH
41371: CALL_OW 257
41375: PUSH
41376: LD_INT 3
41378: NONEQUAL
41379: IFFALSE 41420
// begin mc_repair_vehicle := Replace ( mc_repair_vehicle , i , mc_repair_vehicle [ i ] diff j ) ;
41381: LD_ADDR_EXP 92
41385: PUSH
41386: LD_EXP 92
41390: PPUSH
41391: LD_VAR 0 2
41395: PPUSH
41396: LD_EXP 92
41400: PUSH
41401: LD_VAR 0 2
41405: ARRAY
41406: PUSH
41407: LD_VAR 0 3
41411: DIFF
41412: PPUSH
41413: CALL_OW 1
41417: ST_TO_ADDR
// continue ;
41418: GO 41363
// end ; if not IsDrivenBy ( j ) and not j in mc_need_heal [ i ] [ 1 ] and not j in mc_need_heal [ i ] [ 2 ] then
41420: LD_VAR 0 3
41424: PPUSH
41425: CALL_OW 311
41429: NOT
41430: PUSH
41431: LD_VAR 0 3
41435: PUSH
41436: LD_EXP 83
41440: PUSH
41441: LD_VAR 0 2
41445: ARRAY
41446: PUSH
41447: LD_INT 1
41449: ARRAY
41450: IN
41451: NOT
41452: AND
41453: PUSH
41454: LD_VAR 0 3
41458: PUSH
41459: LD_EXP 83
41463: PUSH
41464: LD_VAR 0 2
41468: ARRAY
41469: PUSH
41470: LD_INT 2
41472: ARRAY
41473: IN
41474: NOT
41475: AND
41476: IFFALSE 41539
// begin if IsInUnit ( j ) then
41478: LD_VAR 0 3
41482: PPUSH
41483: CALL_OW 310
41487: IFFALSE 41500
// ComExitBuilding ( j ) else
41489: LD_VAR 0 3
41493: PPUSH
41494: CALL_OW 122
41498: GO 41539
// if not WantToRepairVehicle ( j , vehs [ 1 ] ) then
41500: LD_VAR 0 3
41504: PPUSH
41505: LD_VAR 0 7
41509: PUSH
41510: LD_INT 1
41512: ARRAY
41513: PPUSH
41514: CALL 93234 0 2
41518: NOT
41519: IFFALSE 41539
// ComRepairVehicle ( j , vehs [ 1 ] ) ;
41521: LD_VAR 0 3
41525: PPUSH
41526: LD_VAR 0 7
41530: PUSH
41531: LD_INT 1
41533: ARRAY
41534: PPUSH
41535: CALL_OW 129
// end ; end ;
41539: GO 41363
41541: POP
41542: POP
// end ;
41543: GO 40824
41545: POP
41546: POP
// end ;
41547: LD_VAR 0 1
41551: RET
// export function MC_TameApe ( ) ; var i , j , x , y , ape , apes , tmp , dep , danger_at_area , side ; begin
41552: LD_INT 0
41554: PPUSH
41555: PPUSH
41556: PPUSH
41557: PPUSH
41558: PPUSH
41559: PPUSH
41560: PPUSH
41561: PPUSH
41562: PPUSH
41563: PPUSH
41564: PPUSH
// if not mc_bases then
41565: LD_EXP 80
41569: NOT
41570: IFFALSE 41574
// exit ;
41572: GO 42376
// for i = 1 to mc_bases do
41574: LD_ADDR_VAR 0 2
41578: PUSH
41579: DOUBLE
41580: LD_INT 1
41582: DEC
41583: ST_TO_ADDR
41584: LD_EXP 80
41588: PUSH
41589: FOR_TO
41590: IFFALSE 42374
// begin if not mc_can_tame [ i ] or mc_need_heal [ i ] [ 1 ] or mc_need_heal [ i ] [ 2 ] or not Researched ( mc_sides [ i ] , tech_apelang ) or mc_scan [ i ] then
41592: LD_EXP 108
41596: PUSH
41597: LD_VAR 0 2
41601: ARRAY
41602: NOT
41603: PUSH
41604: LD_EXP 83
41608: PUSH
41609: LD_VAR 0 2
41613: ARRAY
41614: PUSH
41615: LD_INT 1
41617: ARRAY
41618: OR
41619: PUSH
41620: LD_EXP 83
41624: PUSH
41625: LD_VAR 0 2
41629: ARRAY
41630: PUSH
41631: LD_INT 2
41633: ARRAY
41634: OR
41635: PUSH
41636: LD_EXP 106
41640: PUSH
41641: LD_VAR 0 2
41645: ARRAY
41646: PPUSH
41647: LD_INT 1
41649: PPUSH
41650: CALL_OW 325
41654: NOT
41655: OR
41656: PUSH
41657: LD_EXP 103
41661: PUSH
41662: LD_VAR 0 2
41666: ARRAY
41667: OR
41668: IFFALSE 41672
// continue ;
41670: GO 41589
// tmp := UnitFilter ( mc_bases [ i ] , [ [ f_class , 4 ] , [ f_ok ] , [ f_not , [ f_hastask ] ] ] ) diff mc_healers [ i ] ;
41672: LD_ADDR_VAR 0 8
41676: PUSH
41677: LD_EXP 80
41681: PUSH
41682: LD_VAR 0 2
41686: ARRAY
41687: PPUSH
41688: LD_INT 25
41690: PUSH
41691: LD_INT 4
41693: PUSH
41694: EMPTY
41695: LIST
41696: LIST
41697: PUSH
41698: LD_INT 50
41700: PUSH
41701: EMPTY
41702: LIST
41703: PUSH
41704: LD_INT 3
41706: PUSH
41707: LD_INT 60
41709: PUSH
41710: EMPTY
41711: LIST
41712: PUSH
41713: EMPTY
41714: LIST
41715: LIST
41716: PUSH
41717: EMPTY
41718: LIST
41719: LIST
41720: LIST
41721: PPUSH
41722: CALL_OW 72
41726: PUSH
41727: LD_EXP 84
41731: PUSH
41732: LD_VAR 0 2
41736: ARRAY
41737: DIFF
41738: ST_TO_ADDR
// dep := UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) ;
41739: LD_ADDR_VAR 0 9
41743: PUSH
41744: LD_EXP 80
41748: PUSH
41749: LD_VAR 0 2
41753: ARRAY
41754: PPUSH
41755: LD_INT 2
41757: PUSH
41758: LD_INT 30
41760: PUSH
41761: LD_INT 0
41763: PUSH
41764: EMPTY
41765: LIST
41766: LIST
41767: PUSH
41768: LD_INT 30
41770: PUSH
41771: LD_INT 1
41773: PUSH
41774: EMPTY
41775: LIST
41776: LIST
41777: PUSH
41778: EMPTY
41779: LIST
41780: LIST
41781: LIST
41782: PPUSH
41783: CALL_OW 72
41787: ST_TO_ADDR
// if not tmp or not dep then
41788: LD_VAR 0 8
41792: NOT
41793: PUSH
41794: LD_VAR 0 9
41798: NOT
41799: OR
41800: IFFALSE 41804
// continue ;
41802: GO 41589
// side := GetSide ( tmp [ 1 ] ) ;
41804: LD_ADDR_VAR 0 11
41808: PUSH
41809: LD_VAR 0 8
41813: PUSH
41814: LD_INT 1
41816: ARRAY
41817: PPUSH
41818: CALL_OW 255
41822: ST_TO_ADDR
// dep := dep [ 1 ] ;
41823: LD_ADDR_VAR 0 9
41827: PUSH
41828: LD_VAR 0 9
41832: PUSH
41833: LD_INT 1
41835: ARRAY
41836: ST_TO_ADDR
// apes := FilterUnitsInArea ( mc_can_tame [ i ] , [ [ f_side , 0 ] , [ f_class , class_apeman ] ] ) union FilterAllUnits ( [ [ f_side , 0 ] , [ f_class , class_apeman ] , [ f_dist , dep , 20 ] ] ) ;
41837: LD_ADDR_VAR 0 7
41841: PUSH
41842: LD_EXP 108
41846: PUSH
41847: LD_VAR 0 2
41851: ARRAY
41852: PPUSH
41853: LD_INT 22
41855: PUSH
41856: LD_INT 0
41858: PUSH
41859: EMPTY
41860: LIST
41861: LIST
41862: PUSH
41863: LD_INT 25
41865: PUSH
41866: LD_INT 12
41868: PUSH
41869: EMPTY
41870: LIST
41871: LIST
41872: PUSH
41873: EMPTY
41874: LIST
41875: LIST
41876: PPUSH
41877: CALL_OW 70
41881: PUSH
41882: LD_INT 22
41884: PUSH
41885: LD_INT 0
41887: PUSH
41888: EMPTY
41889: LIST
41890: LIST
41891: PUSH
41892: LD_INT 25
41894: PUSH
41895: LD_INT 12
41897: PUSH
41898: EMPTY
41899: LIST
41900: LIST
41901: PUSH
41902: LD_INT 91
41904: PUSH
41905: LD_VAR 0 9
41909: PUSH
41910: LD_INT 20
41912: PUSH
41913: EMPTY
41914: LIST
41915: LIST
41916: LIST
41917: PUSH
41918: EMPTY
41919: LIST
41920: LIST
41921: LIST
41922: PPUSH
41923: CALL_OW 69
41927: UNION
41928: ST_TO_ADDR
// danger_at_area := FilterUnitsInArea ( mc_can_tame [ i ] , [ f_enemy , side ] ) ;
41929: LD_ADDR_VAR 0 10
41933: PUSH
41934: LD_EXP 108
41938: PUSH
41939: LD_VAR 0 2
41943: ARRAY
41944: PPUSH
41945: LD_INT 81
41947: PUSH
41948: LD_VAR 0 11
41952: PUSH
41953: EMPTY
41954: LIST
41955: LIST
41956: PPUSH
41957: CALL_OW 70
41961: ST_TO_ADDR
// if not apes or danger_at_area then
41962: LD_VAR 0 7
41966: NOT
41967: PUSH
41968: LD_VAR 0 10
41972: OR
41973: IFFALSE 42023
// begin if mc_taming [ i ] then
41975: LD_EXP 111
41979: PUSH
41980: LD_VAR 0 2
41984: ARRAY
41985: IFFALSE 42021
// begin MC_Reset ( i , 121 ) ;
41987: LD_VAR 0 2
41991: PPUSH
41992: LD_INT 121
41994: PPUSH
41995: CALL 26939 0 2
// mc_taming := Replace ( mc_taming , i , [ ] ) ;
41999: LD_ADDR_EXP 111
42003: PUSH
42004: LD_EXP 111
42008: PPUSH
42009: LD_VAR 0 2
42013: PPUSH
42014: EMPTY
42015: PPUSH
42016: CALL_OW 1
42020: ST_TO_ADDR
// end ; continue ;
42021: GO 41589
// end ; for j in tmp do
42023: LD_ADDR_VAR 0 3
42027: PUSH
42028: LD_VAR 0 8
42032: PUSH
42033: FOR_IN
42034: IFFALSE 42370
// begin if not j in mc_taming [ i ] and mc_taming [ i ] < 3 then
42036: LD_VAR 0 3
42040: PUSH
42041: LD_EXP 111
42045: PUSH
42046: LD_VAR 0 2
42050: ARRAY
42051: IN
42052: NOT
42053: PUSH
42054: LD_EXP 111
42058: PUSH
42059: LD_VAR 0 2
42063: ARRAY
42064: PUSH
42065: LD_INT 3
42067: LESS
42068: AND
42069: IFFALSE 42127
// begin SetTag ( j , 121 ) ;
42071: LD_VAR 0 3
42075: PPUSH
42076: LD_INT 121
42078: PPUSH
42079: CALL_OW 109
// mc_taming := ReplaceIn ( mc_taming , [ i , mc_taming [ i ] + 1 ] , j ) ;
42083: LD_ADDR_EXP 111
42087: PUSH
42088: LD_EXP 111
42092: PPUSH
42093: LD_VAR 0 2
42097: PUSH
42098: LD_EXP 111
42102: PUSH
42103: LD_VAR 0 2
42107: ARRAY
42108: PUSH
42109: LD_INT 1
42111: PLUS
42112: PUSH
42113: EMPTY
42114: LIST
42115: LIST
42116: PPUSH
42117: LD_VAR 0 3
42121: PPUSH
42122: CALL 58440 0 3
42126: ST_TO_ADDR
// end ; if j in mc_taming [ i ] then
42127: LD_VAR 0 3
42131: PUSH
42132: LD_EXP 111
42136: PUSH
42137: LD_VAR 0 2
42141: ARRAY
42142: IN
42143: IFFALSE 42368
// begin if GetClass ( j ) <> 4 then
42145: LD_VAR 0 3
42149: PPUSH
42150: CALL_OW 257
42154: PUSH
42155: LD_INT 4
42157: NONEQUAL
42158: IFFALSE 42211
// begin mc_taming := Replace ( mc_taming , i , mc_taming [ i ] diff j ) ;
42160: LD_ADDR_EXP 111
42164: PUSH
42165: LD_EXP 111
42169: PPUSH
42170: LD_VAR 0 2
42174: PPUSH
42175: LD_EXP 111
42179: PUSH
42180: LD_VAR 0 2
42184: ARRAY
42185: PUSH
42186: LD_VAR 0 3
42190: DIFF
42191: PPUSH
42192: CALL_OW 1
42196: ST_TO_ADDR
// SetTag ( j , 0 ) ;
42197: LD_VAR 0 3
42201: PPUSH
42202: LD_INT 0
42204: PPUSH
42205: CALL_OW 109
// continue ;
42209: GO 42033
// end ; if IsInUnit ( j ) then
42211: LD_VAR 0 3
42215: PPUSH
42216: CALL_OW 310
42220: IFFALSE 42231
// ComExitBuilding ( j ) ;
42222: LD_VAR 0 3
42226: PPUSH
42227: CALL_OW 122
// ape := NearestUnitToUnit ( apes , j ) ;
42231: LD_ADDR_VAR 0 6
42235: PUSH
42236: LD_VAR 0 7
42240: PPUSH
42241: LD_VAR 0 3
42245: PPUSH
42246: CALL_OW 74
42250: ST_TO_ADDR
// if not ape then
42251: LD_VAR 0 6
42255: NOT
42256: IFFALSE 42260
// break ;
42258: GO 42370
// x := GetX ( ape ) ;
42260: LD_ADDR_VAR 0 4
42264: PUSH
42265: LD_VAR 0 6
42269: PPUSH
42270: CALL_OW 250
42274: ST_TO_ADDR
// y := GetY ( ape ) ;
42275: LD_ADDR_VAR 0 5
42279: PUSH
42280: LD_VAR 0 6
42284: PPUSH
42285: CALL_OW 251
42289: ST_TO_ADDR
// if not ValidHex ( x , y ) or DangerAtRangeXY ( side , x , y , 20 ) [ 4 ] then
42290: LD_VAR 0 4
42294: PPUSH
42295: LD_VAR 0 5
42299: PPUSH
42300: CALL_OW 488
42304: NOT
42305: PUSH
42306: LD_VAR 0 11
42310: PPUSH
42311: LD_VAR 0 4
42315: PPUSH
42316: LD_VAR 0 5
42320: PPUSH
42321: LD_INT 20
42323: PPUSH
42324: CALL 59704 0 4
42328: PUSH
42329: LD_INT 4
42331: ARRAY
42332: OR
42333: IFFALSE 42337
// break ;
42335: GO 42370
// if not HasTask ( j ) then
42337: LD_VAR 0 3
42341: PPUSH
42342: CALL_OW 314
42346: NOT
42347: IFFALSE 42368
// ComTameXY ( j , x , y ) ;
42349: LD_VAR 0 3
42353: PPUSH
42354: LD_VAR 0 4
42358: PPUSH
42359: LD_VAR 0 5
42363: PPUSH
42364: CALL_OW 131
// end ; end ;
42368: GO 42033
42370: POP
42371: POP
// end ;
42372: GO 41589
42374: POP
42375: POP
// end ;
42376: LD_VAR 0 1
42380: RET
// export function MC_ChangeApeClass ( ) ; var i , j , tmp , side , depot , selected , barracks ; begin
42381: LD_INT 0
42383: PPUSH
42384: PPUSH
42385: PPUSH
42386: PPUSH
42387: PPUSH
42388: PPUSH
42389: PPUSH
42390: PPUSH
// if not mc_bases then
42391: LD_EXP 80
42395: NOT
42396: IFFALSE 42400
// exit ;
42398: GO 43026
// for i = 1 to mc_bases do
42400: LD_ADDR_VAR 0 2
42404: PUSH
42405: DOUBLE
42406: LD_INT 1
42408: DEC
42409: ST_TO_ADDR
42410: LD_EXP 80
42414: PUSH
42415: FOR_TO
42416: IFFALSE 43024
// begin if not mc_ape [ i ] or not UnitFilter ( mc_ape [ i ] , [ f_class , 12 ] ) then
42418: LD_EXP 109
42422: PUSH
42423: LD_VAR 0 2
42427: ARRAY
42428: NOT
42429: PUSH
42430: LD_EXP 109
42434: PUSH
42435: LD_VAR 0 2
42439: ARRAY
42440: PPUSH
42441: LD_INT 25
42443: PUSH
42444: LD_INT 12
42446: PUSH
42447: EMPTY
42448: LIST
42449: LIST
42450: PPUSH
42451: CALL_OW 72
42455: NOT
42456: OR
42457: IFFALSE 42461
// continue ;
42459: GO 42415
// side := GetSide ( mc_ape [ i ] [ 1 ] ) ;
42461: LD_ADDR_VAR 0 5
42465: PUSH
42466: LD_EXP 109
42470: PUSH
42471: LD_VAR 0 2
42475: ARRAY
42476: PUSH
42477: LD_INT 1
42479: ARRAY
42480: PPUSH
42481: CALL_OW 255
42485: ST_TO_ADDR
// if Researched ( side , tech_apepsych ) then
42486: LD_VAR 0 5
42490: PPUSH
42491: LD_INT 2
42493: PPUSH
42494: CALL_OW 325
42498: IFFALSE 42751
// begin tmp := UnitFilter ( mc_ape [ i ] , [ f_class , 16 ] ) ;
42500: LD_ADDR_VAR 0 4
42504: PUSH
42505: LD_EXP 109
42509: PUSH
42510: LD_VAR 0 2
42514: ARRAY
42515: PPUSH
42516: LD_INT 25
42518: PUSH
42519: LD_INT 16
42521: PUSH
42522: EMPTY
42523: LIST
42524: LIST
42525: PPUSH
42526: CALL_OW 72
42530: ST_TO_ADDR
// if tmp < 6 then
42531: LD_VAR 0 4
42535: PUSH
42536: LD_INT 6
42538: LESS
42539: IFFALSE 42751
// begin depot := UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) ;
42541: LD_ADDR_VAR 0 6
42545: PUSH
42546: LD_EXP 80
42550: PUSH
42551: LD_VAR 0 2
42555: ARRAY
42556: PPUSH
42557: LD_INT 2
42559: PUSH
42560: LD_INT 30
42562: PUSH
42563: LD_INT 0
42565: PUSH
42566: EMPTY
42567: LIST
42568: LIST
42569: PUSH
42570: LD_INT 30
42572: PUSH
42573: LD_INT 1
42575: PUSH
42576: EMPTY
42577: LIST
42578: LIST
42579: PUSH
42580: EMPTY
42581: LIST
42582: LIST
42583: LIST
42584: PPUSH
42585: CALL_OW 72
42589: ST_TO_ADDR
// if depot then
42590: LD_VAR 0 6
42594: IFFALSE 42751
// begin selected := 0 ;
42596: LD_ADDR_VAR 0 7
42600: PUSH
42601: LD_INT 0
42603: ST_TO_ADDR
// for j in depot do
42604: LD_ADDR_VAR 0 3
42608: PUSH
42609: LD_VAR 0 6
42613: PUSH
42614: FOR_IN
42615: IFFALSE 42646
// begin if UnitsInside ( j ) < 6 then
42617: LD_VAR 0 3
42621: PPUSH
42622: CALL_OW 313
42626: PUSH
42627: LD_INT 6
42629: LESS
42630: IFFALSE 42644
// begin selected := j ;
42632: LD_ADDR_VAR 0 7
42636: PUSH
42637: LD_VAR 0 3
42641: ST_TO_ADDR
// break ;
42642: GO 42646
// end ; end ;
42644: GO 42614
42646: POP
42647: POP
// if selected then
42648: LD_VAR 0 7
42652: IFFALSE 42751
// begin for j in UnitFilter ( mc_ape [ i ] , [ f_class , 12 ] ) do
42654: LD_ADDR_VAR 0 3
42658: PUSH
42659: LD_EXP 109
42663: PUSH
42664: LD_VAR 0 2
42668: ARRAY
42669: PPUSH
42670: LD_INT 25
42672: PUSH
42673: LD_INT 12
42675: PUSH
42676: EMPTY
42677: LIST
42678: LIST
42679: PPUSH
42680: CALL_OW 72
42684: PUSH
42685: FOR_IN
42686: IFFALSE 42749
// if not HasTask ( j ) then
42688: LD_VAR 0 3
42692: PPUSH
42693: CALL_OW 314
42697: NOT
42698: IFFALSE 42747
// begin if not IsInUnit ( j ) then
42700: LD_VAR 0 3
42704: PPUSH
42705: CALL_OW 310
42709: NOT
42710: IFFALSE 42726
// ComEnterUnit ( j , selected ) ;
42712: LD_VAR 0 3
42716: PPUSH
42717: LD_VAR 0 7
42721: PPUSH
42722: CALL_OW 120
// AddComChangeProfession ( j , 16 ) ;
42726: LD_VAR 0 3
42730: PPUSH
42731: LD_INT 16
42733: PPUSH
42734: CALL_OW 183
// AddComExitBuilding ( j ) ;
42738: LD_VAR 0 3
42742: PPUSH
42743: CALL_OW 182
// end ;
42747: GO 42685
42749: POP
42750: POP
// end ; end ; end ; end ; if Researched ( side , tech_apeagres ) then
42751: LD_VAR 0 5
42755: PPUSH
42756: LD_INT 11
42758: PPUSH
42759: CALL_OW 325
42763: IFFALSE 43022
// begin tmp := UnitFilter ( mc_ape [ i ] , [ f_class , 16 ] ) ;
42765: LD_ADDR_VAR 0 4
42769: PUSH
42770: LD_EXP 109
42774: PUSH
42775: LD_VAR 0 2
42779: ARRAY
42780: PPUSH
42781: LD_INT 25
42783: PUSH
42784: LD_INT 16
42786: PUSH
42787: EMPTY
42788: LIST
42789: LIST
42790: PPUSH
42791: CALL_OW 72
42795: ST_TO_ADDR
// if tmp >= 6 or not Researched ( side , tech_apepsych ) then
42796: LD_VAR 0 4
42800: PUSH
42801: LD_INT 6
42803: GREATEREQUAL
42804: PUSH
42805: LD_VAR 0 5
42809: PPUSH
42810: LD_INT 2
42812: PPUSH
42813: CALL_OW 325
42817: NOT
42818: OR
42819: IFFALSE 43022
// begin barracks := UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_armoury ] , [ f_btype , b_barracks ] ] ) ;
42821: LD_ADDR_VAR 0 8
42825: PUSH
42826: LD_EXP 80
42830: PUSH
42831: LD_VAR 0 2
42835: ARRAY
42836: PPUSH
42837: LD_INT 2
42839: PUSH
42840: LD_INT 30
42842: PUSH
42843: LD_INT 4
42845: PUSH
42846: EMPTY
42847: LIST
42848: LIST
42849: PUSH
42850: LD_INT 30
42852: PUSH
42853: LD_INT 5
42855: PUSH
42856: EMPTY
42857: LIST
42858: LIST
42859: PUSH
42860: EMPTY
42861: LIST
42862: LIST
42863: LIST
42864: PPUSH
42865: CALL_OW 72
42869: ST_TO_ADDR
// if barracks then
42870: LD_VAR 0 8
42874: IFFALSE 43022
// begin selected := 0 ;
42876: LD_ADDR_VAR 0 7
42880: PUSH
42881: LD_INT 0
42883: ST_TO_ADDR
// for j in barracks do
42884: LD_ADDR_VAR 0 3
42888: PUSH
42889: LD_VAR 0 8
42893: PUSH
42894: FOR_IN
42895: IFFALSE 42926
// begin if UnitsInside ( j ) < 6 then
42897: LD_VAR 0 3
42901: PPUSH
42902: CALL_OW 313
42906: PUSH
42907: LD_INT 6
42909: LESS
42910: IFFALSE 42924
// begin selected := j ;
42912: LD_ADDR_VAR 0 7
42916: PUSH
42917: LD_VAR 0 3
42921: ST_TO_ADDR
// break ;
42922: GO 42926
// end ; end ;
42924: GO 42894
42926: POP
42927: POP
// if selected then
42928: LD_VAR 0 7
42932: IFFALSE 43022
// begin for j in UnitFilter ( mc_ape [ i ] , [ f_class , 12 ] ) do
42934: LD_ADDR_VAR 0 3
42938: PUSH
42939: LD_EXP 109
42943: PUSH
42944: LD_VAR 0 2
42948: ARRAY
42949: PPUSH
42950: LD_INT 25
42952: PUSH
42953: LD_INT 12
42955: PUSH
42956: EMPTY
42957: LIST
42958: LIST
42959: PPUSH
42960: CALL_OW 72
42964: PUSH
42965: FOR_IN
42966: IFFALSE 43020
// if not IsInUnit ( j ) and not HasTask ( j ) then
42968: LD_VAR 0 3
42972: PPUSH
42973: CALL_OW 310
42977: NOT
42978: PUSH
42979: LD_VAR 0 3
42983: PPUSH
42984: CALL_OW 314
42988: NOT
42989: AND
42990: IFFALSE 43018
// begin ComEnterUnit ( j , selected ) ;
42992: LD_VAR 0 3
42996: PPUSH
42997: LD_VAR 0 7
43001: PPUSH
43002: CALL_OW 120
// AddComChangeProfession ( j , 15 ) ;
43006: LD_VAR 0 3
43010: PPUSH
43011: LD_INT 15
43013: PPUSH
43014: CALL_OW 183
// end ;
43018: GO 42965
43020: POP
43021: POP
// end ; end ; end ; end ; end ;
43022: GO 42415
43024: POP
43025: POP
// end ;
43026: LD_VAR 0 1
43030: RET
// export function MC_Bazooka ( ) ; var i , j , tmp ; begin
43031: LD_INT 0
43033: PPUSH
43034: PPUSH
43035: PPUSH
43036: PPUSH
// if not mc_bases then
43037: LD_EXP 80
43041: NOT
43042: IFFALSE 43046
// exit ;
43044: GO 43224
// for i = 1 to mc_bases do
43046: LD_ADDR_VAR 0 2
43050: PUSH
43051: DOUBLE
43052: LD_INT 1
43054: DEC
43055: ST_TO_ADDR
43056: LD_EXP 80
43060: PUSH
43061: FOR_TO
43062: IFFALSE 43222
// begin tmp := UnitFilter ( mc_bases [ i ] , [ f_class , class_bazooker ] ) ;
43064: LD_ADDR_VAR 0 4
43068: PUSH
43069: LD_EXP 80
43073: PUSH
43074: LD_VAR 0 2
43078: ARRAY
43079: PPUSH
43080: LD_INT 25
43082: PUSH
43083: LD_INT 9
43085: PUSH
43086: EMPTY
43087: LIST
43088: LIST
43089: PPUSH
43090: CALL_OW 72
43094: ST_TO_ADDR
// if not tmp then
43095: LD_VAR 0 4
43099: NOT
43100: IFFALSE 43104
// continue ;
43102: GO 43061
// if not Researched ( mc_sides [ i ] , tech_spacanom ) and not Researched ( mc_sides [ i ] , tech_taurad ) then
43104: LD_EXP 106
43108: PUSH
43109: LD_VAR 0 2
43113: ARRAY
43114: PPUSH
43115: LD_INT 29
43117: PPUSH
43118: CALL_OW 325
43122: NOT
43123: PUSH
43124: LD_EXP 106
43128: PUSH
43129: LD_VAR 0 2
43133: ARRAY
43134: PPUSH
43135: LD_INT 28
43137: PPUSH
43138: CALL_OW 325
43142: NOT
43143: AND
43144: IFFALSE 43148
// continue ;
43146: GO 43061
// for j in tmp do
43148: LD_ADDR_VAR 0 3
43152: PUSH
43153: LD_VAR 0 4
43157: PUSH
43158: FOR_IN
43159: IFFALSE 43218
// if not j in mc_need_heal [ i ] [ 1 ] and not j in mc_need_heal [ i ] [ 2 ] then
43161: LD_VAR 0 3
43165: PUSH
43166: LD_EXP 83
43170: PUSH
43171: LD_VAR 0 2
43175: ARRAY
43176: PUSH
43177: LD_INT 1
43179: ARRAY
43180: IN
43181: NOT
43182: PUSH
43183: LD_VAR 0 3
43187: PUSH
43188: LD_EXP 83
43192: PUSH
43193: LD_VAR 0 2
43197: ARRAY
43198: PUSH
43199: LD_INT 2
43201: ARRAY
43202: IN
43203: NOT
43204: AND
43205: IFFALSE 43216
// ComSpaceTimeShoot ( j ) ;
43207: LD_VAR 0 3
43211: PPUSH
43212: CALL 54425 0 1
43216: GO 43158
43218: POP
43219: POP
// end ;
43220: GO 43061
43222: POP
43223: POP
// end ;
43224: LD_VAR 0 1
43228: RET
// export function MC_TeleportExit ( ) ; var i , j , x , y , save_point , tmp , teleports , sci ; begin
43229: LD_INT 0
43231: PPUSH
43232: PPUSH
43233: PPUSH
43234: PPUSH
43235: PPUSH
43236: PPUSH
43237: PPUSH
43238: PPUSH
43239: PPUSH
// if not mc_bases then
43240: LD_EXP 80
43244: NOT
43245: IFFALSE 43249
// exit ;
43247: GO 43871
// for i = 1 to mc_bases do
43249: LD_ADDR_VAR 0 2
43253: PUSH
43254: DOUBLE
43255: LD_INT 1
43257: DEC
43258: ST_TO_ADDR
43259: LD_EXP 80
43263: PUSH
43264: FOR_TO
43265: IFFALSE 43869
// begin if not mc_teleport_exit [ i ] or GetTech ( tech_targTeleport , mc_sides [ i ] ) <> state_researched then
43267: LD_EXP 115
43271: PUSH
43272: LD_VAR 0 2
43276: ARRAY
43277: NOT
43278: PUSH
43279: LD_INT 38
43281: PPUSH
43282: LD_EXP 106
43286: PUSH
43287: LD_VAR 0 2
43291: ARRAY
43292: PPUSH
43293: CALL_OW 321
43297: PUSH
43298: LD_INT 2
43300: NONEQUAL
43301: OR
43302: IFFALSE 43306
// continue ;
43304: GO 43264
// teleports := UnitFilter ( mc_bases [ i ] , [ f_btype , b_teleport ] ) ;
43306: LD_ADDR_VAR 0 8
43310: PUSH
43311: LD_EXP 80
43315: PUSH
43316: LD_VAR 0 2
43320: ARRAY
43321: PPUSH
43322: LD_INT 30
43324: PUSH
43325: LD_INT 34
43327: PUSH
43328: EMPTY
43329: LIST
43330: LIST
43331: PPUSH
43332: CALL_OW 72
43336: ST_TO_ADDR
// sci := FilterByTag ( UnitFilter ( mc_bases [ i ] , [ f_class , 4 ] ) , 0 ) ;
43337: LD_ADDR_VAR 0 9
43341: PUSH
43342: LD_EXP 80
43346: PUSH
43347: LD_VAR 0 2
43351: ARRAY
43352: PPUSH
43353: LD_INT 25
43355: PUSH
43356: LD_INT 4
43358: PUSH
43359: EMPTY
43360: LIST
43361: LIST
43362: PPUSH
43363: CALL_OW 72
43367: PPUSH
43368: LD_INT 0
43370: PPUSH
43371: CALL 88738 0 2
43375: ST_TO_ADDR
// if not sci or not teleports or FilterByTag ( mc_bases [ i ] , 124 ) then
43376: LD_VAR 0 9
43380: NOT
43381: PUSH
43382: LD_VAR 0 8
43386: NOT
43387: OR
43388: PUSH
43389: LD_EXP 80
43393: PUSH
43394: LD_VAR 0 2
43398: ARRAY
43399: PPUSH
43400: LD_INT 124
43402: PPUSH
43403: CALL 88738 0 2
43407: OR
43408: IFFALSE 43412
// continue ;
43410: GO 43264
// if mc_teleport_exit_set [ i ] < mc_teleport_exit [ i ] and mc_teleport_exit_set [ i ] < teleports then
43412: LD_EXP 116
43416: PUSH
43417: LD_VAR 0 2
43421: ARRAY
43422: PUSH
43423: LD_EXP 115
43427: PUSH
43428: LD_VAR 0 2
43432: ARRAY
43433: LESS
43434: PUSH
43435: LD_EXP 116
43439: PUSH
43440: LD_VAR 0 2
43444: ARRAY
43445: PUSH
43446: LD_VAR 0 8
43450: LESS
43451: AND
43452: IFFALSE 43867
// begin tmp := sci [ 1 ] ;
43454: LD_ADDR_VAR 0 7
43458: PUSH
43459: LD_VAR 0 9
43463: PUSH
43464: LD_INT 1
43466: ARRAY
43467: ST_TO_ADDR
// SetTag ( tmp , 124 ) ;
43468: LD_VAR 0 7
43472: PPUSH
43473: LD_INT 124
43475: PPUSH
43476: CALL_OW 109
// for j = mc_teleport_exit [ i ] downto mc_teleport_exit [ i ] do
43480: LD_ADDR_VAR 0 3
43484: PUSH
43485: DOUBLE
43486: LD_EXP 115
43490: PUSH
43491: LD_VAR 0 2
43495: ARRAY
43496: INC
43497: ST_TO_ADDR
43498: LD_EXP 115
43502: PUSH
43503: LD_VAR 0 2
43507: ARRAY
43508: PUSH
43509: FOR_DOWNTO
43510: IFFALSE 43853
// begin if IsInUnit ( tmp ) then
43512: LD_VAR 0 7
43516: PPUSH
43517: CALL_OW 310
43521: IFFALSE 43532
// ComExitBuilding ( tmp ) ;
43523: LD_VAR 0 7
43527: PPUSH
43528: CALL_OW 122
// repeat wait ( 0 0$1 ) ;
43532: LD_INT 35
43534: PPUSH
43535: CALL_OW 67
// until not IsInUnit ( tmp ) and not HasTask ( tmp ) ;
43539: LD_VAR 0 7
43543: PPUSH
43544: CALL_OW 310
43548: NOT
43549: PUSH
43550: LD_VAR 0 7
43554: PPUSH
43555: CALL_OW 314
43559: NOT
43560: AND
43561: IFFALSE 43532
// save_point := [ GetX ( tmp ) , GetY ( tmp ) ] ;
43563: LD_ADDR_VAR 0 6
43567: PUSH
43568: LD_VAR 0 7
43572: PPUSH
43573: CALL_OW 250
43577: PUSH
43578: LD_VAR 0 7
43582: PPUSH
43583: CALL_OW 251
43587: PUSH
43588: EMPTY
43589: LIST
43590: LIST
43591: ST_TO_ADDR
// repeat wait ( 0 0$1 ) ;
43592: LD_INT 35
43594: PPUSH
43595: CALL_OW 67
// x := mc_teleport_exit [ i ] [ j ] [ 1 ] ;
43599: LD_ADDR_VAR 0 4
43603: PUSH
43604: LD_EXP 115
43608: PUSH
43609: LD_VAR 0 2
43613: ARRAY
43614: PUSH
43615: LD_VAR 0 3
43619: ARRAY
43620: PUSH
43621: LD_INT 1
43623: ARRAY
43624: ST_TO_ADDR
// y := mc_teleport_exit [ i ] [ j ] [ 2 ] ;
43625: LD_ADDR_VAR 0 5
43629: PUSH
43630: LD_EXP 115
43634: PUSH
43635: LD_VAR 0 2
43639: ARRAY
43640: PUSH
43641: LD_VAR 0 3
43645: ARRAY
43646: PUSH
43647: LD_INT 2
43649: ARRAY
43650: ST_TO_ADDR
// if DangerAtRange ( tmp , 10 ) [ 4 ] then
43651: LD_VAR 0 7
43655: PPUSH
43656: LD_INT 10
43658: PPUSH
43659: CALL 61405 0 2
43663: PUSH
43664: LD_INT 4
43666: ARRAY
43667: IFFALSE 43705
// begin ComMoveXY ( tmp , save_point [ 1 ] , save_point [ 2 ] ) ;
43669: LD_VAR 0 7
43673: PPUSH
43674: LD_VAR 0 6
43678: PUSH
43679: LD_INT 1
43681: ARRAY
43682: PPUSH
43683: LD_VAR 0 6
43687: PUSH
43688: LD_INT 2
43690: ARRAY
43691: PPUSH
43692: CALL_OW 111
// wait ( 0 0$10 ) ;
43696: LD_INT 350
43698: PPUSH
43699: CALL_OW 67
// end else
43703: GO 43731
// begin ComMoveXY ( tmp , x , y ) ;
43705: LD_VAR 0 7
43709: PPUSH
43710: LD_VAR 0 4
43714: PPUSH
43715: LD_VAR 0 5
43719: PPUSH
43720: CALL_OW 111
// wait ( 0 0$3 ) ;
43724: LD_INT 105
43726: PPUSH
43727: CALL_OW 67
// end ; until IsAt ( tmp , x , y ) ;
43731: LD_VAR 0 7
43735: PPUSH
43736: LD_VAR 0 4
43740: PPUSH
43741: LD_VAR 0 5
43745: PPUSH
43746: CALL_OW 307
43750: IFFALSE 43592
// ComTeleportExit ( tmp , x , y , teleports [ j ] ) ;
43752: LD_VAR 0 7
43756: PPUSH
43757: LD_VAR 0 4
43761: PPUSH
43762: LD_VAR 0 5
43766: PPUSH
43767: LD_VAR 0 8
43771: PUSH
43772: LD_VAR 0 3
43776: ARRAY
43777: PPUSH
43778: CALL_OW 156
// repeat wait ( 0 0$1 ) ;
43782: LD_INT 35
43784: PPUSH
43785: CALL_OW 67
// until not HasTask ( tmp ) ;
43789: LD_VAR 0 7
43793: PPUSH
43794: CALL_OW 314
43798: NOT
43799: IFFALSE 43782
// mc_teleport_exit_set := ReplaceIn ( mc_teleport_exit_set , [ i , mc_teleport_exit_set [ i ] + 1 ] , teleports [ j ] ) ;
43801: LD_ADDR_EXP 116
43805: PUSH
43806: LD_EXP 116
43810: PPUSH
43811: LD_VAR 0 2
43815: PUSH
43816: LD_EXP 116
43820: PUSH
43821: LD_VAR 0 2
43825: ARRAY
43826: PUSH
43827: LD_INT 1
43829: PLUS
43830: PUSH
43831: EMPTY
43832: LIST
43833: LIST
43834: PPUSH
43835: LD_VAR 0 8
43839: PUSH
43840: LD_VAR 0 3
43844: ARRAY
43845: PPUSH
43846: CALL 58440 0 3
43850: ST_TO_ADDR
// end ;
43851: GO 43509
43853: POP
43854: POP
// MC_Reset ( i , 124 ) ;
43855: LD_VAR 0 2
43859: PPUSH
43860: LD_INT 124
43862: PPUSH
43863: CALL 26939 0 2
// end ; end ;
43867: GO 43264
43869: POP
43870: POP
// end ;
43871: LD_VAR 0 1
43875: RET
// export function MC_Deposits ( ) ; var i , tmp ; begin
43876: LD_INT 0
43878: PPUSH
43879: PPUSH
43880: PPUSH
// if not mc_bases then
43881: LD_EXP 80
43885: NOT
43886: IFFALSE 43890
// exit ;
43888: GO 44496
// for i = 1 to mc_bases do
43890: LD_ADDR_VAR 0 2
43894: PUSH
43895: DOUBLE
43896: LD_INT 1
43898: DEC
43899: ST_TO_ADDR
43900: LD_EXP 80
43904: PUSH
43905: FOR_TO
43906: IFFALSE 44494
// begin tmp := UnitFilter ( mc_bases [ i ] , [ f_class , 4 ] ) ;
43908: LD_ADDR_VAR 0 3
43912: PUSH
43913: LD_EXP 80
43917: PUSH
43918: LD_VAR 0 2
43922: ARRAY
43923: PPUSH
43924: LD_INT 25
43926: PUSH
43927: LD_INT 4
43929: PUSH
43930: EMPTY
43931: LIST
43932: LIST
43933: PPUSH
43934: CALL_OW 72
43938: ST_TO_ADDR
// if not tmp or not mc_deposits_xy [ i ] or not UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) then
43939: LD_VAR 0 3
43943: NOT
43944: PUSH
43945: LD_EXP 117
43949: PUSH
43950: LD_VAR 0 2
43954: ARRAY
43955: NOT
43956: OR
43957: PUSH
43958: LD_EXP 80
43962: PUSH
43963: LD_VAR 0 2
43967: ARRAY
43968: PPUSH
43969: LD_INT 2
43971: PUSH
43972: LD_INT 30
43974: PUSH
43975: LD_INT 0
43977: PUSH
43978: EMPTY
43979: LIST
43980: LIST
43981: PUSH
43982: LD_INT 30
43984: PUSH
43985: LD_INT 1
43987: PUSH
43988: EMPTY
43989: LIST
43990: LIST
43991: PUSH
43992: EMPTY
43993: LIST
43994: LIST
43995: LIST
43996: PPUSH
43997: CALL_OW 72
44001: NOT
44002: OR
44003: IFFALSE 44053
// begin if mc_deposits_finder [ i ] then
44005: LD_EXP 118
44009: PUSH
44010: LD_VAR 0 2
44014: ARRAY
44015: IFFALSE 44051
// begin MC_Reset ( i , 125 ) ;
44017: LD_VAR 0 2
44021: PPUSH
44022: LD_INT 125
44024: PPUSH
44025: CALL 26939 0 2
// mc_deposits_finder := Replace ( mc_deposits_finder , i , [ ] ) ;
44029: LD_ADDR_EXP 118
44033: PUSH
44034: LD_EXP 118
44038: PPUSH
44039: LD_VAR 0 2
44043: PPUSH
44044: EMPTY
44045: PPUSH
44046: CALL_OW 1
44050: ST_TO_ADDR
// end ; continue ;
44051: GO 43905
// end ; if mc_deposits_xy [ i ] [ 1 ] [ 3 ] = 1 and GetTech ( tech_sibdet , mc_sides [ i ] ) <> state_researched then
44053: LD_EXP 117
44057: PUSH
44058: LD_VAR 0 2
44062: ARRAY
44063: PUSH
44064: LD_INT 1
44066: ARRAY
44067: PUSH
44068: LD_INT 3
44070: ARRAY
44071: PUSH
44072: LD_INT 1
44074: EQUAL
44075: PUSH
44076: LD_INT 20
44078: PPUSH
44079: LD_EXP 106
44083: PUSH
44084: LD_VAR 0 2
44088: ARRAY
44089: PPUSH
44090: CALL_OW 321
44094: PUSH
44095: LD_INT 2
44097: NONEQUAL
44098: AND
44099: IFFALSE 44149
// begin if mc_deposits_finder [ i ] then
44101: LD_EXP 118
44105: PUSH
44106: LD_VAR 0 2
44110: ARRAY
44111: IFFALSE 44147
// begin MC_Reset ( i , 125 ) ;
44113: LD_VAR 0 2
44117: PPUSH
44118: LD_INT 125
44120: PPUSH
44121: CALL 26939 0 2
// mc_deposits_finder := Replace ( mc_deposits_finder , i , [ ] ) ;
44125: LD_ADDR_EXP 118
44129: PUSH
44130: LD_EXP 118
44134: PPUSH
44135: LD_VAR 0 2
44139: PPUSH
44140: EMPTY
44141: PPUSH
44142: CALL_OW 1
44146: ST_TO_ADDR
// end ; continue ;
44147: GO 43905
// end ; if GetResourceVisibility ( mc_deposits_xy [ i ] [ 1 ] [ 1 ] , mc_deposits_xy [ i ] [ 1 ] [ 2 ] , mc_sides [ i ] ) then
44149: LD_EXP 117
44153: PUSH
44154: LD_VAR 0 2
44158: ARRAY
44159: PUSH
44160: LD_INT 1
44162: ARRAY
44163: PUSH
44164: LD_INT 1
44166: ARRAY
44167: PPUSH
44168: LD_EXP 117
44172: PUSH
44173: LD_VAR 0 2
44177: ARRAY
44178: PUSH
44179: LD_INT 1
44181: ARRAY
44182: PUSH
44183: LD_INT 2
44185: ARRAY
44186: PPUSH
44187: LD_EXP 106
44191: PUSH
44192: LD_VAR 0 2
44196: ARRAY
44197: PPUSH
44198: CALL_OW 440
44202: IFFALSE 44245
// mc_deposits_xy := Replace ( mc_deposits_xy , i , Delete ( mc_deposits_xy [ i ] , 1 ) ) else
44204: LD_ADDR_EXP 117
44208: PUSH
44209: LD_EXP 117
44213: PPUSH
44214: LD_VAR 0 2
44218: PPUSH
44219: LD_EXP 117
44223: PUSH
44224: LD_VAR 0 2
44228: ARRAY
44229: PPUSH
44230: LD_INT 1
44232: PPUSH
44233: CALL_OW 3
44237: PPUSH
44238: CALL_OW 1
44242: ST_TO_ADDR
44243: GO 44492
// begin if not mc_deposits_finder [ i ] then
44245: LD_EXP 118
44249: PUSH
44250: LD_VAR 0 2
44254: ARRAY
44255: NOT
44256: IFFALSE 44308
// begin mc_deposits_finder := Replace ( mc_deposits_finder , i , [ tmp [ 1 ] ] ) ;
44258: LD_ADDR_EXP 118
44262: PUSH
44263: LD_EXP 118
44267: PPUSH
44268: LD_VAR 0 2
44272: PPUSH
44273: LD_VAR 0 3
44277: PUSH
44278: LD_INT 1
44280: ARRAY
44281: PUSH
44282: EMPTY
44283: LIST
44284: PPUSH
44285: CALL_OW 1
44289: ST_TO_ADDR
// SetTag ( tmp [ 1 ] , 125 ) ;
44290: LD_VAR 0 3
44294: PUSH
44295: LD_INT 1
44297: ARRAY
44298: PPUSH
44299: LD_INT 125
44301: PPUSH
44302: CALL_OW 109
// end else
44306: GO 44492
// begin if IsInUnit ( mc_deposits_finder [ i ] [ 1 ] ) then
44308: LD_EXP 118
44312: PUSH
44313: LD_VAR 0 2
44317: ARRAY
44318: PUSH
44319: LD_INT 1
44321: ARRAY
44322: PPUSH
44323: CALL_OW 310
44327: IFFALSE 44350
// ComExitBuilding ( mc_deposits_finder [ i ] [ 1 ] ) else
44329: LD_EXP 118
44333: PUSH
44334: LD_VAR 0 2
44338: ARRAY
44339: PUSH
44340: LD_INT 1
44342: ARRAY
44343: PPUSH
44344: CALL_OW 122
44348: GO 44492
// if not HasTask ( mc_deposits_finder [ i ] [ 1 ] ) and GetDistUnitXY ( mc_deposits_finder [ i ] [ 1 ] , mc_deposits_xy [ i ] [ 1 ] [ 1 ] , mc_deposits_xy [ i ] [ 1 ] [ 2 ] ) > 6 then
44350: LD_EXP 118
44354: PUSH
44355: LD_VAR 0 2
44359: ARRAY
44360: PUSH
44361: LD_INT 1
44363: ARRAY
44364: PPUSH
44365: CALL_OW 314
44369: NOT
44370: PUSH
44371: LD_EXP 118
44375: PUSH
44376: LD_VAR 0 2
44380: ARRAY
44381: PUSH
44382: LD_INT 1
44384: ARRAY
44385: PPUSH
44386: LD_EXP 117
44390: PUSH
44391: LD_VAR 0 2
44395: ARRAY
44396: PUSH
44397: LD_INT 1
44399: ARRAY
44400: PUSH
44401: LD_INT 1
44403: ARRAY
44404: PPUSH
44405: LD_EXP 117
44409: PUSH
44410: LD_VAR 0 2
44414: ARRAY
44415: PUSH
44416: LD_INT 1
44418: ARRAY
44419: PUSH
44420: LD_INT 2
44422: ARRAY
44423: PPUSH
44424: CALL_OW 297
44428: PUSH
44429: LD_INT 6
44431: GREATER
44432: AND
44433: IFFALSE 44492
// ComMoveXY ( mc_deposits_finder [ i ] [ 1 ] , mc_deposits_xy [ i ] [ 1 ] [ 1 ] , mc_deposits_xy [ i ] [ 1 ] [ 2 ] ) ;
44435: LD_EXP 118
44439: PUSH
44440: LD_VAR 0 2
44444: ARRAY
44445: PUSH
44446: LD_INT 1
44448: ARRAY
44449: PPUSH
44450: LD_EXP 117
44454: PUSH
44455: LD_VAR 0 2
44459: ARRAY
44460: PUSH
44461: LD_INT 1
44463: ARRAY
44464: PUSH
44465: LD_INT 1
44467: ARRAY
44468: PPUSH
44469: LD_EXP 117
44473: PUSH
44474: LD_VAR 0 2
44478: ARRAY
44479: PUSH
44480: LD_INT 1
44482: ARRAY
44483: PUSH
44484: LD_INT 2
44486: ARRAY
44487: PPUSH
44488: CALL_OW 111
// end ; end ; end ;
44492: GO 43905
44494: POP
44495: POP
// end ;
44496: LD_VAR 0 1
44500: RET
// export function MC_RemoteDriver ( ) ; var i , j , k , places , tmp , nation , ct , cts , mcts , x ; begin
44501: LD_INT 0
44503: PPUSH
44504: PPUSH
44505: PPUSH
44506: PPUSH
44507: PPUSH
44508: PPUSH
44509: PPUSH
44510: PPUSH
44511: PPUSH
44512: PPUSH
44513: PPUSH
// if not mc_bases then
44514: LD_EXP 80
44518: NOT
44519: IFFALSE 44523
// exit ;
44521: GO 45463
// for i = 1 to mc_bases do
44523: LD_ADDR_VAR 0 2
44527: PUSH
44528: DOUBLE
44529: LD_INT 1
44531: DEC
44532: ST_TO_ADDR
44533: LD_EXP 80
44537: PUSH
44538: FOR_TO
44539: IFFALSE 45461
// begin if not mc_bases [ i ] or mc_scan [ i ] then
44541: LD_EXP 80
44545: PUSH
44546: LD_VAR 0 2
44550: ARRAY
44551: NOT
44552: PUSH
44553: LD_EXP 103
44557: PUSH
44558: LD_VAR 0 2
44562: ARRAY
44563: OR
44564: IFFALSE 44568
// continue ;
44566: GO 44538
// nation := GetNation ( mc_bases [ i ] [ 1 ] ) ;
44568: LD_ADDR_VAR 0 7
44572: PUSH
44573: LD_EXP 80
44577: PUSH
44578: LD_VAR 0 2
44582: ARRAY
44583: PUSH
44584: LD_INT 1
44586: ARRAY
44587: PPUSH
44588: CALL_OW 248
44592: ST_TO_ADDR
// if nation = 3 or not UnitFilter ( mc_vehicles [ i ] union mc_defender [ i ] , [ f_control , control_remote ] ) then
44593: LD_VAR 0 7
44597: PUSH
44598: LD_INT 3
44600: EQUAL
44601: PUSH
44602: LD_EXP 99
44606: PUSH
44607: LD_VAR 0 2
44611: ARRAY
44612: PUSH
44613: LD_EXP 102
44617: PUSH
44618: LD_VAR 0 2
44622: ARRAY
44623: UNION
44624: PPUSH
44625: LD_INT 33
44627: PUSH
44628: LD_INT 2
44630: PUSH
44631: EMPTY
44632: LIST
44633: LIST
44634: PPUSH
44635: CALL_OW 72
44639: NOT
44640: OR
44641: IFFALSE 44645
// continue ;
44643: GO 44538
// cts := UnitFilter ( mc_bases [ i ] , [ f_btype , b_control_tower ] ) ;
44645: LD_ADDR_VAR 0 9
44649: PUSH
44650: LD_EXP 80
44654: PUSH
44655: LD_VAR 0 2
44659: ARRAY
44660: PPUSH
44661: LD_INT 30
44663: PUSH
44664: LD_INT 36
44666: PUSH
44667: EMPTY
44668: LIST
44669: LIST
44670: PPUSH
44671: CALL_OW 72
44675: ST_TO_ADDR
// mcts := UnitFilter ( mc_vehicles [ i ] , [ f_weapon , ar_control_tower ] ) ;
44676: LD_ADDR_VAR 0 10
44680: PUSH
44681: LD_EXP 99
44685: PUSH
44686: LD_VAR 0 2
44690: ARRAY
44691: PPUSH
44692: LD_INT 34
44694: PUSH
44695: LD_INT 31
44697: PUSH
44698: EMPTY
44699: LIST
44700: LIST
44701: PPUSH
44702: CALL_OW 72
44706: ST_TO_ADDR
// if not cts and not mcts then
44707: LD_VAR 0 9
44711: NOT
44712: PUSH
44713: LD_VAR 0 10
44717: NOT
44718: AND
44719: IFFALSE 44723
// continue ;
44721: GO 44538
// x := cts ;
44723: LD_ADDR_VAR 0 11
44727: PUSH
44728: LD_VAR 0 9
44732: ST_TO_ADDR
// if not x then
44733: LD_VAR 0 11
44737: NOT
44738: IFFALSE 44750
// x := mcts ;
44740: LD_ADDR_VAR 0 11
44744: PUSH
44745: LD_VAR 0 10
44749: ST_TO_ADDR
// if not x then
44750: LD_VAR 0 11
44754: NOT
44755: IFFALSE 44759
// continue ;
44757: GO 44538
// if mc_remote_driver [ i ] then
44759: LD_EXP 120
44763: PUSH
44764: LD_VAR 0 2
44768: ARRAY
44769: IFFALSE 45156
// for j in mc_remote_driver [ i ] do
44771: LD_ADDR_VAR 0 3
44775: PUSH
44776: LD_EXP 120
44780: PUSH
44781: LD_VAR 0 2
44785: ARRAY
44786: PUSH
44787: FOR_IN
44788: IFFALSE 45154
// begin if GetClass ( j ) <> 3 then
44790: LD_VAR 0 3
44794: PPUSH
44795: CALL_OW 257
44799: PUSH
44800: LD_INT 3
44802: NONEQUAL
44803: IFFALSE 44856
// begin mc_remote_driver := Replace ( mc_remote_driver , i , mc_remote_driver [ i ] diff j ) ;
44805: LD_ADDR_EXP 120
44809: PUSH
44810: LD_EXP 120
44814: PPUSH
44815: LD_VAR 0 2
44819: PPUSH
44820: LD_EXP 120
44824: PUSH
44825: LD_VAR 0 2
44829: ARRAY
44830: PUSH
44831: LD_VAR 0 3
44835: DIFF
44836: PPUSH
44837: CALL_OW 1
44841: ST_TO_ADDR
// SetTag ( j , 0 ) ;
44842: LD_VAR 0 3
44846: PPUSH
44847: LD_INT 0
44849: PPUSH
44850: CALL_OW 109
// continue ;
44854: GO 44787
// end ; if UnitFilter ( mc_vehicles [ i ] , [ [ f_weapon , ar_control_tower ] , [ f_empty ] ] ) and not IsDriver ( j ) then
44856: LD_EXP 99
44860: PUSH
44861: LD_VAR 0 2
44865: ARRAY
44866: PPUSH
44867: LD_INT 34
44869: PUSH
44870: LD_INT 31
44872: PUSH
44873: EMPTY
44874: LIST
44875: LIST
44876: PUSH
44877: LD_INT 58
44879: PUSH
44880: EMPTY
44881: LIST
44882: PUSH
44883: EMPTY
44884: LIST
44885: LIST
44886: PPUSH
44887: CALL_OW 72
44891: PUSH
44892: LD_VAR 0 3
44896: PPUSH
44897: CALL 88773 0 1
44901: NOT
44902: AND
44903: IFFALSE 44974
// begin if IsInUnit ( j ) then
44905: LD_VAR 0 3
44909: PPUSH
44910: CALL_OW 310
44914: IFFALSE 44925
// ComExitBuilding ( j ) ;
44916: LD_VAR 0 3
44920: PPUSH
44921: CALL_OW 122
// AddComEnterUnit ( j , UnitFilter ( mc_vehicles [ i ] , [ [ f_weapon , ar_control_tower ] , [ f_empty ] ] ) [ 1 ] ) ;
44925: LD_VAR 0 3
44929: PPUSH
44930: LD_EXP 99
44934: PUSH
44935: LD_VAR 0 2
44939: ARRAY
44940: PPUSH
44941: LD_INT 34
44943: PUSH
44944: LD_INT 31
44946: PUSH
44947: EMPTY
44948: LIST
44949: LIST
44950: PUSH
44951: LD_INT 58
44953: PUSH
44954: EMPTY
44955: LIST
44956: PUSH
44957: EMPTY
44958: LIST
44959: LIST
44960: PPUSH
44961: CALL_OW 72
44965: PUSH
44966: LD_INT 1
44968: ARRAY
44969: PPUSH
44970: CALL_OW 180
// end ; if not IsInUnit ( j ) or ( GetBType ( IsInUnit ( j ) ) <> b_control_tower and not IsDriver ( j ) ) then
44974: LD_VAR 0 3
44978: PPUSH
44979: CALL_OW 310
44983: NOT
44984: PUSH
44985: LD_VAR 0 3
44989: PPUSH
44990: CALL_OW 310
44994: PPUSH
44995: CALL_OW 266
44999: PUSH
45000: LD_INT 36
45002: NONEQUAL
45003: PUSH
45004: LD_VAR 0 3
45008: PPUSH
45009: CALL 88773 0 1
45013: NOT
45014: AND
45015: OR
45016: IFFALSE 45152
// begin if IsInUnit ( j ) then
45018: LD_VAR 0 3
45022: PPUSH
45023: CALL_OW 310
45027: IFFALSE 45038
// ComExitBuilding ( j ) ;
45029: LD_VAR 0 3
45033: PPUSH
45034: CALL_OW 122
// ct := 0 ;
45038: LD_ADDR_VAR 0 8
45042: PUSH
45043: LD_INT 0
45045: ST_TO_ADDR
// for k in x do
45046: LD_ADDR_VAR 0 4
45050: PUSH
45051: LD_VAR 0 11
45055: PUSH
45056: FOR_IN
45057: IFFALSE 45130
// if ( GetWeapon ( k ) = ar_control_tower and not IsDrivenBy ( k ) ) or ( GetBType ( k ) = b_control_tower and UnitsInside ( k ) < 3 ) then
45059: LD_VAR 0 4
45063: PPUSH
45064: CALL_OW 264
45068: PUSH
45069: LD_INT 31
45071: EQUAL
45072: PUSH
45073: LD_VAR 0 4
45077: PPUSH
45078: CALL_OW 311
45082: NOT
45083: AND
45084: PUSH
45085: LD_VAR 0 4
45089: PPUSH
45090: CALL_OW 266
45094: PUSH
45095: LD_INT 36
45097: EQUAL
45098: PUSH
45099: LD_VAR 0 4
45103: PPUSH
45104: CALL_OW 313
45108: PUSH
45109: LD_INT 3
45111: LESS
45112: AND
45113: OR
45114: IFFALSE 45128
// begin ct := k ;
45116: LD_ADDR_VAR 0 8
45120: PUSH
45121: LD_VAR 0 4
45125: ST_TO_ADDR
// break ;
45126: GO 45130
// end ;
45128: GO 45056
45130: POP
45131: POP
// if ct then
45132: LD_VAR 0 8
45136: IFFALSE 45152
// ComEnterUnit ( j , ct ) ;
45138: LD_VAR 0 3
45142: PPUSH
45143: LD_VAR 0 8
45147: PPUSH
45148: CALL_OW 120
// end ; end ;
45152: GO 44787
45154: POP
45155: POP
// places := 0 ;
45156: LD_ADDR_VAR 0 5
45160: PUSH
45161: LD_INT 0
45163: ST_TO_ADDR
// for j = 1 to x do
45164: LD_ADDR_VAR 0 3
45168: PUSH
45169: DOUBLE
45170: LD_INT 1
45172: DEC
45173: ST_TO_ADDR
45174: LD_VAR 0 11
45178: PUSH
45179: FOR_TO
45180: IFFALSE 45256
// if GetWeapon ( x [ j ] ) = ar_control_tower then
45182: LD_VAR 0 11
45186: PUSH
45187: LD_VAR 0 3
45191: ARRAY
45192: PPUSH
45193: CALL_OW 264
45197: PUSH
45198: LD_INT 31
45200: EQUAL
45201: IFFALSE 45219
// places := places + 1 else
45203: LD_ADDR_VAR 0 5
45207: PUSH
45208: LD_VAR 0 5
45212: PUSH
45213: LD_INT 1
45215: PLUS
45216: ST_TO_ADDR
45217: GO 45254
// if GetBType ( x [ j ] ) = b_control_tower then
45219: LD_VAR 0 11
45223: PUSH
45224: LD_VAR 0 3
45228: ARRAY
45229: PPUSH
45230: CALL_OW 266
45234: PUSH
45235: LD_INT 36
45237: EQUAL
45238: IFFALSE 45254
// places := places + 3 ;
45240: LD_ADDR_VAR 0 5
45244: PUSH
45245: LD_VAR 0 5
45249: PUSH
45250: LD_INT 3
45252: PLUS
45253: ST_TO_ADDR
45254: GO 45179
45256: POP
45257: POP
// if places = 0 or places <= mc_remote_driver [ i ] then
45258: LD_VAR 0 5
45262: PUSH
45263: LD_INT 0
45265: EQUAL
45266: PUSH
45267: LD_VAR 0 5
45271: PUSH
45272: LD_EXP 120
45276: PUSH
45277: LD_VAR 0 2
45281: ARRAY
45282: LESSEQUAL
45283: OR
45284: IFFALSE 45288
// continue ;
45286: GO 44538
// tmp := SortBySkill ( UnitFilter ( mc_bases [ i ] , [ f_class , 3 ] ) diff mc_remote_driver [ i ] , 3 ) ;
45288: LD_ADDR_VAR 0 6
45292: PUSH
45293: LD_EXP 80
45297: PUSH
45298: LD_VAR 0 2
45302: ARRAY
45303: PPUSH
45304: LD_INT 25
45306: PUSH
45307: LD_INT 3
45309: PUSH
45310: EMPTY
45311: LIST
45312: LIST
45313: PPUSH
45314: CALL_OW 72
45318: PUSH
45319: LD_EXP 120
45323: PUSH
45324: LD_VAR 0 2
45328: ARRAY
45329: DIFF
45330: PPUSH
45331: LD_INT 3
45333: PPUSH
45334: CALL 89673 0 2
45338: ST_TO_ADDR
// for j in tmp do
45339: LD_ADDR_VAR 0 3
45343: PUSH
45344: LD_VAR 0 6
45348: PUSH
45349: FOR_IN
45350: IFFALSE 45385
// if GetTag ( j ) > 0 then
45352: LD_VAR 0 3
45356: PPUSH
45357: CALL_OW 110
45361: PUSH
45362: LD_INT 0
45364: GREATER
45365: IFFALSE 45383
// tmp := tmp diff j ;
45367: LD_ADDR_VAR 0 6
45371: PUSH
45372: LD_VAR 0 6
45376: PUSH
45377: LD_VAR 0 3
45381: DIFF
45382: ST_TO_ADDR
45383: GO 45349
45385: POP
45386: POP
// if not tmp then
45387: LD_VAR 0 6
45391: NOT
45392: IFFALSE 45396
// continue ;
45394: GO 44538
// if places then
45396: LD_VAR 0 5
45400: IFFALSE 45459
// begin mc_remote_driver := Replace ( mc_remote_driver , i , mc_remote_driver [ i ] union tmp [ 1 ] ) ;
45402: LD_ADDR_EXP 120
45406: PUSH
45407: LD_EXP 120
45411: PPUSH
45412: LD_VAR 0 2
45416: PPUSH
45417: LD_EXP 120
45421: PUSH
45422: LD_VAR 0 2
45426: ARRAY
45427: PUSH
45428: LD_VAR 0 6
45432: PUSH
45433: LD_INT 1
45435: ARRAY
45436: UNION
45437: PPUSH
45438: CALL_OW 1
45442: ST_TO_ADDR
// SetTag ( tmp [ 1 ] , 126 ) ;
45443: LD_VAR 0 6
45447: PUSH
45448: LD_INT 1
45450: ARRAY
45451: PPUSH
45452: LD_INT 126
45454: PPUSH
45455: CALL_OW 109
// end ; end ;
45459: GO 44538
45461: POP
45462: POP
// end ;
45463: LD_VAR 0 1
45467: RET
// export function MC_Back ( base , base_unit_list , unit , class ) ; var i , j , tmp , x , depot ; begin
45468: LD_INT 0
45470: PPUSH
45471: PPUSH
45472: PPUSH
45473: PPUSH
45474: PPUSH
45475: PPUSH
// if not base or not base_unit_list or not unit or not class in [ 1 , 2 , 3 , 4 , 5 , 8 , 9 , 15 , 16 ] then
45476: LD_VAR 0 1
45480: NOT
45481: PUSH
45482: LD_VAR 0 2
45486: NOT
45487: OR
45488: PUSH
45489: LD_VAR 0 3
45493: NOT
45494: OR
45495: PUSH
45496: LD_VAR 0 4
45500: PUSH
45501: LD_INT 1
45503: PUSH
45504: LD_INT 2
45506: PUSH
45507: LD_INT 3
45509: PUSH
45510: LD_INT 4
45512: PUSH
45513: LD_INT 5
45515: PUSH
45516: LD_INT 8
45518: PUSH
45519: LD_INT 9
45521: PUSH
45522: LD_INT 15
45524: PUSH
45525: LD_INT 16
45527: PUSH
45528: EMPTY
45529: LIST
45530: LIST
45531: LIST
45532: LIST
45533: LIST
45534: LIST
45535: LIST
45536: LIST
45537: LIST
45538: IN
45539: NOT
45540: OR
45541: IFFALSE 45545
// exit ;
45543: GO 46403
// base_unit_list := UnitFilter ( base_unit_list , [ [ f_type , unit_building ] , [ f_lives , 250 ] ] ) ;
45545: LD_ADDR_VAR 0 2
45549: PUSH
45550: LD_VAR 0 2
45554: PPUSH
45555: LD_INT 21
45557: PUSH
45558: LD_INT 3
45560: PUSH
45561: EMPTY
45562: LIST
45563: LIST
45564: PUSH
45565: LD_INT 24
45567: PUSH
45568: LD_INT 250
45570: PUSH
45571: EMPTY
45572: LIST
45573: LIST
45574: PUSH
45575: EMPTY
45576: LIST
45577: LIST
45578: PPUSH
45579: CALL_OW 72
45583: ST_TO_ADDR
// case class of 1 , 15 :
45584: LD_VAR 0 4
45588: PUSH
45589: LD_INT 1
45591: DOUBLE
45592: EQUAL
45593: IFTRUE 45603
45595: LD_INT 15
45597: DOUBLE
45598: EQUAL
45599: IFTRUE 45603
45601: GO 45688
45603: POP
// tmp := UnitFilter ( base_unit_list , [ f_or , [ f_btype , b_bunker ] , [ f_btype , b_breastwork ] ] ) ^ UnitFilter ( base_unit_list , [ f_or , [ f_btype , b_armoury ] , [ f_btype , b_barracks ] ] ) ; 2 , 16 :
45604: LD_ADDR_VAR 0 8
45608: PUSH
45609: LD_VAR 0 2
45613: PPUSH
45614: LD_INT 2
45616: PUSH
45617: LD_INT 30
45619: PUSH
45620: LD_INT 32
45622: PUSH
45623: EMPTY
45624: LIST
45625: LIST
45626: PUSH
45627: LD_INT 30
45629: PUSH
45630: LD_INT 31
45632: PUSH
45633: EMPTY
45634: LIST
45635: LIST
45636: PUSH
45637: EMPTY
45638: LIST
45639: LIST
45640: LIST
45641: PPUSH
45642: CALL_OW 72
45646: PUSH
45647: LD_VAR 0 2
45651: PPUSH
45652: LD_INT 2
45654: PUSH
45655: LD_INT 30
45657: PUSH
45658: LD_INT 4
45660: PUSH
45661: EMPTY
45662: LIST
45663: LIST
45664: PUSH
45665: LD_INT 30
45667: PUSH
45668: LD_INT 5
45670: PUSH
45671: EMPTY
45672: LIST
45673: LIST
45674: PUSH
45675: EMPTY
45676: LIST
45677: LIST
45678: LIST
45679: PPUSH
45680: CALL_OW 72
45684: ADD
45685: ST_TO_ADDR
45686: GO 45934
45688: LD_INT 2
45690: DOUBLE
45691: EQUAL
45692: IFTRUE 45702
45694: LD_INT 16
45696: DOUBLE
45697: EQUAL
45698: IFTRUE 45702
45700: GO 45748
45702: POP
// tmp := UnitFilter ( base_unit_list , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) ; 3 :
45703: LD_ADDR_VAR 0 8
45707: PUSH
45708: LD_VAR 0 2
45712: PPUSH
45713: LD_INT 2
45715: PUSH
45716: LD_INT 30
45718: PUSH
45719: LD_INT 0
45721: PUSH
45722: EMPTY
45723: LIST
45724: LIST
45725: PUSH
45726: LD_INT 30
45728: PUSH
45729: LD_INT 1
45731: PUSH
45732: EMPTY
45733: LIST
45734: LIST
45735: PUSH
45736: EMPTY
45737: LIST
45738: LIST
45739: LIST
45740: PPUSH
45741: CALL_OW 72
45745: ST_TO_ADDR
45746: GO 45934
45748: LD_INT 3
45750: DOUBLE
45751: EQUAL
45752: IFTRUE 45756
45754: GO 45802
45756: POP
// tmp := UnitFilter ( base_unit_list , [ f_or , [ f_btype , b_workshop ] , [ f_btype , b_factory ] ] ) ; 4 :
45757: LD_ADDR_VAR 0 8
45761: PUSH
45762: LD_VAR 0 2
45766: PPUSH
45767: LD_INT 2
45769: PUSH
45770: LD_INT 30
45772: PUSH
45773: LD_INT 2
45775: PUSH
45776: EMPTY
45777: LIST
45778: LIST
45779: PUSH
45780: LD_INT 30
45782: PUSH
45783: LD_INT 3
45785: PUSH
45786: EMPTY
45787: LIST
45788: LIST
45789: PUSH
45790: EMPTY
45791: LIST
45792: LIST
45793: LIST
45794: PPUSH
45795: CALL_OW 72
45799: ST_TO_ADDR
45800: GO 45934
45802: LD_INT 4
45804: DOUBLE
45805: EQUAL
45806: IFTRUE 45810
45808: GO 45867
45810: POP
// tmp := UnitFilter ( base_unit_list , [ f_or , [ f_btype , b_lab ] , [ f_btype , b_lab_half ] , [ f_btype , b_lab_full ] ] ) ; 5 , 8 , 9 :
45811: LD_ADDR_VAR 0 8
45815: PUSH
45816: LD_VAR 0 2
45820: PPUSH
45821: LD_INT 2
45823: PUSH
45824: LD_INT 30
45826: PUSH
45827: LD_INT 6
45829: PUSH
45830: EMPTY
45831: LIST
45832: LIST
45833: PUSH
45834: LD_INT 30
45836: PUSH
45837: LD_INT 7
45839: PUSH
45840: EMPTY
45841: LIST
45842: LIST
45843: PUSH
45844: LD_INT 30
45846: PUSH
45847: LD_INT 8
45849: PUSH
45850: EMPTY
45851: LIST
45852: LIST
45853: PUSH
45854: EMPTY
45855: LIST
45856: LIST
45857: LIST
45858: LIST
45859: PPUSH
45860: CALL_OW 72
45864: ST_TO_ADDR
45865: GO 45934
45867: LD_INT 5
45869: DOUBLE
45870: EQUAL
45871: IFTRUE 45887
45873: LD_INT 8
45875: DOUBLE
45876: EQUAL
45877: IFTRUE 45887
45879: LD_INT 9
45881: DOUBLE
45882: EQUAL
45883: IFTRUE 45887
45885: GO 45933
45887: POP
// tmp := UnitFilter ( base_unit_list , [ f_or , [ f_btype , b_armoury ] , [ f_btype , b_barracks ] ] ) ; end ;
45888: LD_ADDR_VAR 0 8
45892: PUSH
45893: LD_VAR 0 2
45897: PPUSH
45898: LD_INT 2
45900: PUSH
45901: LD_INT 30
45903: PUSH
45904: LD_INT 4
45906: PUSH
45907: EMPTY
45908: LIST
45909: LIST
45910: PUSH
45911: LD_INT 30
45913: PUSH
45914: LD_INT 5
45916: PUSH
45917: EMPTY
45918: LIST
45919: LIST
45920: PUSH
45921: EMPTY
45922: LIST
45923: LIST
45924: LIST
45925: PPUSH
45926: CALL_OW 72
45930: ST_TO_ADDR
45931: GO 45934
45933: POP
// if not tmp then
45934: LD_VAR 0 8
45938: NOT
45939: IFFALSE 45943
// exit ;
45941: GO 46403
// if class in [ 1 , 15 ] and mc_empty_turret_list [ base ] then
45943: LD_VAR 0 4
45947: PUSH
45948: LD_INT 1
45950: PUSH
45951: LD_INT 15
45953: PUSH
45954: EMPTY
45955: LIST
45956: LIST
45957: IN
45958: PUSH
45959: LD_EXP 89
45963: PUSH
45964: LD_VAR 0 1
45968: ARRAY
45969: AND
45970: IFFALSE 46126
// begin x := mc_empty_turret_list [ base ] [ 1 ] ;
45972: LD_ADDR_VAR 0 9
45976: PUSH
45977: LD_EXP 89
45981: PUSH
45982: LD_VAR 0 1
45986: ARRAY
45987: PUSH
45988: LD_INT 1
45990: ARRAY
45991: ST_TO_ADDR
// if not x in mc_busy_turret_list [ base ] then
45992: LD_VAR 0 9
45996: PUSH
45997: LD_EXP 90
46001: PUSH
46002: LD_VAR 0 1
46006: ARRAY
46007: IN
46008: NOT
46009: IFFALSE 46124
// begin mc_busy_turret_list := ReplaceIn ( mc_busy_turret_list , [ base , mc_busy_turret_list [ base ] + 1 ] , x ) ;
46011: LD_ADDR_EXP 90
46015: PUSH
46016: LD_EXP 90
46020: PPUSH
46021: LD_VAR 0 1
46025: PUSH
46026: LD_EXP 90
46030: PUSH
46031: LD_VAR 0 1
46035: ARRAY
46036: PUSH
46037: LD_INT 1
46039: PLUS
46040: PUSH
46041: EMPTY
46042: LIST
46043: LIST
46044: PPUSH
46045: LD_VAR 0 9
46049: PPUSH
46050: CALL 58440 0 3
46054: ST_TO_ADDR
// mc_empty_turret_list := Replace ( mc_empty_turret_list , base , mc_empty_turret_list [ base ] diff x ) ;
46055: LD_ADDR_EXP 89
46059: PUSH
46060: LD_EXP 89
46064: PPUSH
46065: LD_VAR 0 1
46069: PPUSH
46070: LD_EXP 89
46074: PUSH
46075: LD_VAR 0 1
46079: ARRAY
46080: PUSH
46081: LD_VAR 0 9
46085: DIFF
46086: PPUSH
46087: CALL_OW 1
46091: ST_TO_ADDR
// ComEnterUnit ( unit , mc_busy_turret_list [ base ] [ mc_busy_turret_list [ base ] ] ) ;
46092: LD_VAR 0 3
46096: PPUSH
46097: LD_EXP 90
46101: PUSH
46102: LD_VAR 0 1
46106: ARRAY
46107: PUSH
46108: LD_EXP 90
46112: PUSH
46113: LD_VAR 0 1
46117: ARRAY
46118: ARRAY
46119: PPUSH
46120: CALL_OW 120
// end ; exit ;
46124: GO 46403
// end ; if tmp > 1 then
46126: LD_VAR 0 8
46130: PUSH
46131: LD_INT 1
46133: GREATER
46134: IFFALSE 46238
// for i = 2 to tmp do
46136: LD_ADDR_VAR 0 6
46140: PUSH
46141: DOUBLE
46142: LD_INT 2
46144: DEC
46145: ST_TO_ADDR
46146: LD_VAR 0 8
46150: PUSH
46151: FOR_TO
46152: IFFALSE 46236
// if BuildingStatus ( tmp [ i ] ) = bs_need_people then
46154: LD_VAR 0 8
46158: PUSH
46159: LD_VAR 0 6
46163: ARRAY
46164: PPUSH
46165: CALL_OW 461
46169: PUSH
46170: LD_INT 6
46172: EQUAL
46173: IFFALSE 46234
// begin x := tmp [ i ] ;
46175: LD_ADDR_VAR 0 9
46179: PUSH
46180: LD_VAR 0 8
46184: PUSH
46185: LD_VAR 0 6
46189: ARRAY
46190: ST_TO_ADDR
// tmp := Delete ( tmp , i ) ;
46191: LD_ADDR_VAR 0 8
46195: PUSH
46196: LD_VAR 0 8
46200: PPUSH
46201: LD_VAR 0 6
46205: PPUSH
46206: CALL_OW 3
46210: ST_TO_ADDR
// tmp := Insert ( tmp , 1 , x ) ;
46211: LD_ADDR_VAR 0 8
46215: PUSH
46216: LD_VAR 0 8
46220: PPUSH
46221: LD_INT 1
46223: PPUSH
46224: LD_VAR 0 9
46228: PPUSH
46229: CALL_OW 2
46233: ST_TO_ADDR
// end ;
46234: GO 46151
46236: POP
46237: POP
// for i in tmp do
46238: LD_ADDR_VAR 0 6
46242: PUSH
46243: LD_VAR 0 8
46247: PUSH
46248: FOR_IN
46249: IFFALSE 46276
// begin if IsNotFull ( i ) then
46251: LD_VAR 0 6
46255: PPUSH
46256: CALL 55662 0 1
46260: IFFALSE 46274
// begin j := i ;
46262: LD_ADDR_VAR 0 7
46266: PUSH
46267: LD_VAR 0 6
46271: ST_TO_ADDR
// break ;
46272: GO 46276
// end ; end ;
46274: GO 46248
46276: POP
46277: POP
// if j then
46278: LD_VAR 0 7
46282: IFFALSE 46300
// ComEnterUnit ( unit , j ) else
46284: LD_VAR 0 3
46288: PPUSH
46289: LD_VAR 0 7
46293: PPUSH
46294: CALL_OW 120
46298: GO 46403
// begin depot := UnitFilter ( base_unit_list , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) ;
46300: LD_ADDR_VAR 0 10
46304: PUSH
46305: LD_VAR 0 2
46309: PPUSH
46310: LD_INT 2
46312: PUSH
46313: LD_INT 30
46315: PUSH
46316: LD_INT 0
46318: PUSH
46319: EMPTY
46320: LIST
46321: LIST
46322: PUSH
46323: LD_INT 30
46325: PUSH
46326: LD_INT 1
46328: PUSH
46329: EMPTY
46330: LIST
46331: LIST
46332: PUSH
46333: EMPTY
46334: LIST
46335: LIST
46336: LIST
46337: PPUSH
46338: CALL_OW 72
46342: ST_TO_ADDR
// if depot then
46343: LD_VAR 0 10
46347: IFFALSE 46403
// begin depot := NearestUnitToUnit ( depot , unit ) ;
46349: LD_ADDR_VAR 0 10
46353: PUSH
46354: LD_VAR 0 10
46358: PPUSH
46359: LD_VAR 0 3
46363: PPUSH
46364: CALL_OW 74
46368: ST_TO_ADDR
// if GetDistUnits ( unit , depot ) > 10 then
46369: LD_VAR 0 3
46373: PPUSH
46374: LD_VAR 0 10
46378: PPUSH
46379: CALL_OW 296
46383: PUSH
46384: LD_INT 10
46386: GREATER
46387: IFFALSE 46403
// ComStandNearbyBuilding ( unit , depot ) ;
46389: LD_VAR 0 3
46393: PPUSH
46394: LD_VAR 0 10
46398: PPUSH
46399: CALL 55042 0 2
// end ; end ; end ;
46403: LD_VAR 0 5
46407: RET
// export function MC_Idle ( ) ; var i , j , tmp ; begin
46408: LD_INT 0
46410: PPUSH
46411: PPUSH
46412: PPUSH
46413: PPUSH
// if not mc_bases then
46414: LD_EXP 80
46418: NOT
46419: IFFALSE 46423
// exit ;
46421: GO 46662
// for i = 1 to mc_bases do
46423: LD_ADDR_VAR 0 2
46427: PUSH
46428: DOUBLE
46429: LD_INT 1
46431: DEC
46432: ST_TO_ADDR
46433: LD_EXP 80
46437: PUSH
46438: FOR_TO
46439: IFFALSE 46660
// begin tmp := UnitFilter ( mc_bases [ i ] , [ f_type , unit_human ] ) union mc_ape [ i ] ;
46441: LD_ADDR_VAR 0 4
46445: PUSH
46446: LD_EXP 80
46450: PUSH
46451: LD_VAR 0 2
46455: ARRAY
46456: PPUSH
46457: LD_INT 21
46459: PUSH
46460: LD_INT 1
46462: PUSH
46463: EMPTY
46464: LIST
46465: LIST
46466: PPUSH
46467: CALL_OW 72
46471: PUSH
46472: LD_EXP 109
46476: PUSH
46477: LD_VAR 0 2
46481: ARRAY
46482: UNION
46483: ST_TO_ADDR
// if not tmp then
46484: LD_VAR 0 4
46488: NOT
46489: IFFALSE 46493
// continue ;
46491: GO 46438
// for j in tmp do
46493: LD_ADDR_VAR 0 3
46497: PUSH
46498: LD_VAR 0 4
46502: PUSH
46503: FOR_IN
46504: IFFALSE 46656
// begin if not GetTag ( j ) and not HasTask ( j ) and not IsDrivenBy ( j ) and not IsInUnit ( j ) and not j in mc_need_heal [ i ] [ 1 ] and not j in mc_need_heal [ i ] [ 2 ] and not j in mc_repair_vehicle [ i ] then
46506: LD_VAR 0 3
46510: PPUSH
46511: CALL_OW 110
46515: NOT
46516: PUSH
46517: LD_VAR 0 3
46521: PPUSH
46522: CALL_OW 314
46526: NOT
46527: AND
46528: PUSH
46529: LD_VAR 0 3
46533: PPUSH
46534: CALL_OW 311
46538: NOT
46539: AND
46540: PUSH
46541: LD_VAR 0 3
46545: PPUSH
46546: CALL_OW 310
46550: NOT
46551: AND
46552: PUSH
46553: LD_VAR 0 3
46557: PUSH
46558: LD_EXP 83
46562: PUSH
46563: LD_VAR 0 2
46567: ARRAY
46568: PUSH
46569: LD_INT 1
46571: ARRAY
46572: IN
46573: NOT
46574: AND
46575: PUSH
46576: LD_VAR 0 3
46580: PUSH
46581: LD_EXP 83
46585: PUSH
46586: LD_VAR 0 2
46590: ARRAY
46591: PUSH
46592: LD_INT 2
46594: ARRAY
46595: IN
46596: NOT
46597: AND
46598: PUSH
46599: LD_VAR 0 3
46603: PUSH
46604: LD_EXP 92
46608: PUSH
46609: LD_VAR 0 2
46613: ARRAY
46614: IN
46615: NOT
46616: AND
46617: IFFALSE 46654
// MC_Back ( i , mc_bases [ i ] , j , GetClass ( j ) ) ;
46619: LD_VAR 0 2
46623: PPUSH
46624: LD_EXP 80
46628: PUSH
46629: LD_VAR 0 2
46633: ARRAY
46634: PPUSH
46635: LD_VAR 0 3
46639: PPUSH
46640: LD_VAR 0 3
46644: PPUSH
46645: CALL_OW 257
46649: PPUSH
46650: CALL 45468 0 4
// end ;
46654: GO 46503
46656: POP
46657: POP
// end ;
46658: GO 46438
46660: POP
46661: POP
// end ;
46662: LD_VAR 0 1
46666: RET
// export function MC_SetMinesField ( base , amount , area ) ; var i , tmp , list , j , c ; begin
46667: LD_INT 0
46669: PPUSH
46670: PPUSH
46671: PPUSH
46672: PPUSH
46673: PPUSH
46674: PPUSH
// if not mc_bases [ base ] then
46675: LD_EXP 80
46679: PUSH
46680: LD_VAR 0 1
46684: ARRAY
46685: NOT
46686: IFFALSE 46690
// exit ;
46688: GO 46891
// tmp := [ ] ;
46690: LD_ADDR_VAR 0 6
46694: PUSH
46695: EMPTY
46696: ST_TO_ADDR
// list := AreaToList ( area , 0 ) ;
46697: LD_ADDR_VAR 0 7
46701: PUSH
46702: LD_VAR 0 3
46706: PPUSH
46707: LD_INT 0
46709: PPUSH
46710: CALL_OW 517
46714: ST_TO_ADDR
// if not list then
46715: LD_VAR 0 7
46719: NOT
46720: IFFALSE 46724
// exit ;
46722: GO 46891
// c := Count ( list [ 1 ] ) ;
46724: LD_ADDR_VAR 0 9
46728: PUSH
46729: LD_VAR 0 7
46733: PUSH
46734: LD_INT 1
46736: ARRAY
46737: PPUSH
46738: CALL 55580 0 1
46742: ST_TO_ADDR
// if amount > c then
46743: LD_VAR 0 2
46747: PUSH
46748: LD_VAR 0 9
46752: GREATER
46753: IFFALSE 46765
// amount := c ;
46755: LD_ADDR_VAR 0 2
46759: PUSH
46760: LD_VAR 0 9
46764: ST_TO_ADDR
// for i := 1 to amount do
46765: LD_ADDR_VAR 0 5
46769: PUSH
46770: DOUBLE
46771: LD_INT 1
46773: DEC
46774: ST_TO_ADDR
46775: LD_VAR 0 2
46779: PUSH
46780: FOR_TO
46781: IFFALSE 46839
// tmp := Replace ( tmp , i , [ list [ 1 ] [ i ] , list [ 2 ] [ i ] ] ) ;
46783: LD_ADDR_VAR 0 6
46787: PUSH
46788: LD_VAR 0 6
46792: PPUSH
46793: LD_VAR 0 5
46797: PPUSH
46798: LD_VAR 0 7
46802: PUSH
46803: LD_INT 1
46805: ARRAY
46806: PUSH
46807: LD_VAR 0 5
46811: ARRAY
46812: PUSH
46813: LD_VAR 0 7
46817: PUSH
46818: LD_INT 2
46820: ARRAY
46821: PUSH
46822: LD_VAR 0 5
46826: ARRAY
46827: PUSH
46828: EMPTY
46829: LIST
46830: LIST
46831: PPUSH
46832: CALL_OW 1
46836: ST_TO_ADDR
46837: GO 46780
46839: POP
46840: POP
// mc_mines := Replace ( mc_mines , base , tmp ) ;
46841: LD_ADDR_EXP 93
46845: PUSH
46846: LD_EXP 93
46850: PPUSH
46851: LD_VAR 0 1
46855: PPUSH
46856: LD_VAR 0 6
46860: PPUSH
46861: CALL_OW 1
46865: ST_TO_ADDR
// mc_minefields := Replace ( mc_minefields , base , area ) ;
46866: LD_ADDR_EXP 95
46870: PUSH
46871: LD_EXP 95
46875: PPUSH
46876: LD_VAR 0 1
46880: PPUSH
46881: LD_VAR 0 3
46885: PPUSH
46886: CALL_OW 1
46890: ST_TO_ADDR
// end ;
46891: LD_VAR 0 4
46895: RET
// export function MC_SetBuildingList ( base , construct_list ) ; begin
46896: LD_INT 0
46898: PPUSH
// if not mc_bases [ base ] then
46899: LD_EXP 80
46903: PUSH
46904: LD_VAR 0 1
46908: ARRAY
46909: NOT
46910: IFFALSE 46914
// exit ;
46912: GO 46939
// mc_build_list := Replace ( mc_build_list , base , construct_list ) ;
46914: LD_ADDR_EXP 85
46918: PUSH
46919: LD_EXP 85
46923: PPUSH
46924: LD_VAR 0 1
46928: PPUSH
46929: LD_VAR 0 2
46933: PPUSH
46934: CALL_OW 1
46938: ST_TO_ADDR
// end ;
46939: LD_VAR 0 3
46943: RET
// export function MC_InsertBuildingList ( base , list ) ; begin
46944: LD_INT 0
46946: PPUSH
// if not mc_bases [ base ] then
46947: LD_EXP 80
46951: PUSH
46952: LD_VAR 0 1
46956: ARRAY
46957: NOT
46958: IFFALSE 46962
// exit ;
46960: GO 46999
// mc_build_list := Replace ( mc_build_list , base , mc_build_list [ base ] union list ) ;
46962: LD_ADDR_EXP 85
46966: PUSH
46967: LD_EXP 85
46971: PPUSH
46972: LD_VAR 0 1
46976: PPUSH
46977: LD_EXP 85
46981: PUSH
46982: LD_VAR 0 1
46986: ARRAY
46987: PUSH
46988: LD_VAR 0 2
46992: UNION
46993: PPUSH
46994: CALL_OW 1
46998: ST_TO_ADDR
// end ;
46999: LD_VAR 0 3
47003: RET
// export function MC_SetProduceList ( base , produce_list ) ; begin
47004: LD_INT 0
47006: PPUSH
// if not mc_bases [ base ] then
47007: LD_EXP 80
47011: PUSH
47012: LD_VAR 0 1
47016: ARRAY
47017: NOT
47018: IFFALSE 47022
// exit ;
47020: GO 47047
// mc_produce := Replace ( mc_produce , base , produce_list ) ;
47022: LD_ADDR_EXP 101
47026: PUSH
47027: LD_EXP 101
47031: PPUSH
47032: LD_VAR 0 1
47036: PPUSH
47037: LD_VAR 0 2
47041: PPUSH
47042: CALL_OW 1
47046: ST_TO_ADDR
// end ;
47047: LD_VAR 0 3
47051: RET
// export function MC_InsertProduceList ( base , components ) ; begin
47052: LD_INT 0
47054: PPUSH
// if not mc_bases [ base ] then
47055: LD_EXP 80
47059: PUSH
47060: LD_VAR 0 1
47064: ARRAY
47065: NOT
47066: IFFALSE 47070
// exit ;
47068: GO 47107
// mc_produce := Replace ( mc_produce , base , mc_produce [ base ] ^ components ) ;
47070: LD_ADDR_EXP 101
47074: PUSH
47075: LD_EXP 101
47079: PPUSH
47080: LD_VAR 0 1
47084: PPUSH
47085: LD_EXP 101
47089: PUSH
47090: LD_VAR 0 1
47094: ARRAY
47095: PUSH
47096: LD_VAR 0 2
47100: ADD
47101: PPUSH
47102: CALL_OW 1
47106: ST_TO_ADDR
// end ;
47107: LD_VAR 0 3
47111: RET
// export function MC_SetDefenderList ( base , deflist ) ; begin
47112: LD_INT 0
47114: PPUSH
// if not mc_bases [ base ] then
47115: LD_EXP 80
47119: PUSH
47120: LD_VAR 0 1
47124: ARRAY
47125: NOT
47126: IFFALSE 47130
// exit ;
47128: GO 47184
// mc_defender := Replace ( mc_defender , base , deflist ) ;
47130: LD_ADDR_EXP 102
47134: PUSH
47135: LD_EXP 102
47139: PPUSH
47140: LD_VAR 0 1
47144: PPUSH
47145: LD_VAR 0 2
47149: PPUSH
47150: CALL_OW 1
47154: ST_TO_ADDR
// mc_defender_limit := Replace ( mc_defender_limit , base , deflist + 0 ) ;
47155: LD_ADDR_EXP 91
47159: PUSH
47160: LD_EXP 91
47164: PPUSH
47165: LD_VAR 0 1
47169: PPUSH
47170: LD_VAR 0 2
47174: PUSH
47175: LD_INT 0
47177: PLUS
47178: PPUSH
47179: CALL_OW 1
47183: ST_TO_ADDR
// end ;
47184: LD_VAR 0 3
47188: RET
// export function MC_SetDefenderLimit ( base , limit ) ; begin
47189: LD_INT 0
47191: PPUSH
// if not mc_bases [ base ] then
47192: LD_EXP 80
47196: PUSH
47197: LD_VAR 0 1
47201: ARRAY
47202: NOT
47203: IFFALSE 47207
// exit ;
47205: GO 47232
// mc_defender_limit := Replace ( mc_defender_limit , base , limit ) ;
47207: LD_ADDR_EXP 91
47211: PUSH
47212: LD_EXP 91
47216: PPUSH
47217: LD_VAR 0 1
47221: PPUSH
47222: LD_VAR 0 2
47226: PPUSH
47227: CALL_OW 1
47231: ST_TO_ADDR
// end ;
47232: LD_VAR 0 3
47236: RET
// export function MC_PrepareAttack ( base , group , path , flags ) ; var i , j , tmp ; begin
47237: LD_INT 0
47239: PPUSH
47240: PPUSH
47241: PPUSH
47242: PPUSH
// if not mc_bases [ base ] then
47243: LD_EXP 80
47247: PUSH
47248: LD_VAR 0 1
47252: ARRAY
47253: NOT
47254: IFFALSE 47258
// exit ;
47256: GO 47323
// mc_attack := ReplaceIn ( mc_attack , [ base , mc_attack [ base ] + 1 ] , [ base , group , path , flags ] ) ;
47258: LD_ADDR_EXP 100
47262: PUSH
47263: LD_EXP 100
47267: PPUSH
47268: LD_VAR 0 1
47272: PUSH
47273: LD_EXP 100
47277: PUSH
47278: LD_VAR 0 1
47282: ARRAY
47283: PUSH
47284: LD_INT 1
47286: PLUS
47287: PUSH
47288: EMPTY
47289: LIST
47290: LIST
47291: PPUSH
47292: LD_VAR 0 1
47296: PUSH
47297: LD_VAR 0 2
47301: PUSH
47302: LD_VAR 0 3
47306: PUSH
47307: LD_VAR 0 4
47311: PUSH
47312: EMPTY
47313: LIST
47314: LIST
47315: LIST
47316: LIST
47317: PPUSH
47318: CALL 58440 0 3
47322: ST_TO_ADDR
// end ;
47323: LD_VAR 0 5
47327: RET
// export function MC_SetDepositsXY ( base , deposits_list ) ; begin
47328: LD_INT 0
47330: PPUSH
// if not mc_bases [ base ] then
47331: LD_EXP 80
47335: PUSH
47336: LD_VAR 0 1
47340: ARRAY
47341: NOT
47342: IFFALSE 47346
// exit ;
47344: GO 47371
// mc_deposits_xy := Replace ( mc_deposits_xy , base , deposits_list ) ;
47346: LD_ADDR_EXP 117
47350: PUSH
47351: LD_EXP 117
47355: PPUSH
47356: LD_VAR 0 1
47360: PPUSH
47361: LD_VAR 0 2
47365: PPUSH
47366: CALL_OW 1
47370: ST_TO_ADDR
// end ;
47371: LD_VAR 0 3
47375: RET
// export function MC_GetMinesField ( base ) ; begin
47376: LD_INT 0
47378: PPUSH
// result := mc_mines [ base ] ;
47379: LD_ADDR_VAR 0 2
47383: PUSH
47384: LD_EXP 93
47388: PUSH
47389: LD_VAR 0 1
47393: ARRAY
47394: ST_TO_ADDR
// end ;
47395: LD_VAR 0 2
47399: RET
// export function MC_GetProduceList ( base ) ; begin
47400: LD_INT 0
47402: PPUSH
// result := mc_produce [ base ] ;
47403: LD_ADDR_VAR 0 2
47407: PUSH
47408: LD_EXP 101
47412: PUSH
47413: LD_VAR 0 1
47417: ARRAY
47418: ST_TO_ADDR
// end ;
47419: LD_VAR 0 2
47423: RET
// export function MC_GetBuilding ( base , btype ) ; var i ; begin
47424: LD_INT 0
47426: PPUSH
47427: PPUSH
// if not mc_bases then
47428: LD_EXP 80
47432: NOT
47433: IFFALSE 47437
// exit ;
47435: GO 47502
// if mc_bases [ base ] then
47437: LD_EXP 80
47441: PUSH
47442: LD_VAR 0 1
47446: ARRAY
47447: IFFALSE 47502
// begin result := UnitFilter ( mc_bases [ base ] , [ f_btype , btype ] ) ;
47449: LD_ADDR_VAR 0 3
47453: PUSH
47454: LD_EXP 80
47458: PUSH
47459: LD_VAR 0 1
47463: ARRAY
47464: PPUSH
47465: LD_INT 30
47467: PUSH
47468: LD_VAR 0 2
47472: PUSH
47473: EMPTY
47474: LIST
47475: LIST
47476: PPUSH
47477: CALL_OW 72
47481: ST_TO_ADDR
// if result then
47482: LD_VAR 0 3
47486: IFFALSE 47502
// result := result [ 1 ] ;
47488: LD_ADDR_VAR 0 3
47492: PUSH
47493: LD_VAR 0 3
47497: PUSH
47498: LD_INT 1
47500: ARRAY
47501: ST_TO_ADDR
// end ; end ;
47502: LD_VAR 0 3
47506: RET
// export function MC_GetBuildings ( base , btype ) ; var i ; begin
47507: LD_INT 0
47509: PPUSH
47510: PPUSH
// if not mc_bases then
47511: LD_EXP 80
47515: NOT
47516: IFFALSE 47520
// exit ;
47518: GO 47565
// if mc_bases [ base ] then
47520: LD_EXP 80
47524: PUSH
47525: LD_VAR 0 1
47529: ARRAY
47530: IFFALSE 47565
// result := UnitFilter ( mc_bases [ base ] , [ f_btype , btype ] ) ;
47532: LD_ADDR_VAR 0 3
47536: PUSH
47537: LD_EXP 80
47541: PUSH
47542: LD_VAR 0 1
47546: ARRAY
47547: PPUSH
47548: LD_INT 30
47550: PUSH
47551: LD_VAR 0 2
47555: PUSH
47556: EMPTY
47557: LIST
47558: LIST
47559: PPUSH
47560: CALL_OW 72
47564: ST_TO_ADDR
// end ;
47565: LD_VAR 0 3
47569: RET
// export function MC_SetTame ( base , area ) ; begin
47570: LD_INT 0
47572: PPUSH
// if not mc_bases or not base then
47573: LD_EXP 80
47577: NOT
47578: PUSH
47579: LD_VAR 0 1
47583: NOT
47584: OR
47585: IFFALSE 47589
// exit ;
47587: GO 47614
// mc_can_tame := Replace ( mc_can_tame , base , area ) ;
47589: LD_ADDR_EXP 108
47593: PUSH
47594: LD_EXP 108
47598: PPUSH
47599: LD_VAR 0 1
47603: PPUSH
47604: LD_VAR 0 2
47608: PPUSH
47609: CALL_OW 1
47613: ST_TO_ADDR
// end ;
47614: LD_VAR 0 3
47618: RET
// export function MC_SetUpgradeBuilding ( base , btype ) ; var tmp ; begin
47619: LD_INT 0
47621: PPUSH
47622: PPUSH
// if not mc_bases or not base then
47623: LD_EXP 80
47627: NOT
47628: PUSH
47629: LD_VAR 0 1
47633: NOT
47634: OR
47635: IFFALSE 47639
// exit ;
47637: GO 47741
// tmp := UnitFilter ( mc_bases [ base ] , [ f_btype , btype ] ) ;
47639: LD_ADDR_VAR 0 4
47643: PUSH
47644: LD_EXP 80
47648: PUSH
47649: LD_VAR 0 1
47653: ARRAY
47654: PPUSH
47655: LD_INT 30
47657: PUSH
47658: LD_VAR 0 2
47662: PUSH
47663: EMPTY
47664: LIST
47665: LIST
47666: PPUSH
47667: CALL_OW 72
47671: ST_TO_ADDR
// if not tmp then
47672: LD_VAR 0 4
47676: NOT
47677: IFFALSE 47681
// exit ;
47679: GO 47741
// mc_build_upgrade := Replace ( mc_build_upgrade , base , Insert ( mc_build_upgrade [ base ] , mc_build_upgrade [ base ] + 1 , tmp [ 1 ] ) ) ;
47681: LD_ADDR_EXP 112
47685: PUSH
47686: LD_EXP 112
47690: PPUSH
47691: LD_VAR 0 1
47695: PPUSH
47696: LD_EXP 112
47700: PUSH
47701: LD_VAR 0 1
47705: ARRAY
47706: PPUSH
47707: LD_EXP 112
47711: PUSH
47712: LD_VAR 0 1
47716: ARRAY
47717: PUSH
47718: LD_INT 1
47720: PLUS
47721: PPUSH
47722: LD_VAR 0 4
47726: PUSH
47727: LD_INT 1
47729: ARRAY
47730: PPUSH
47731: CALL_OW 2
47735: PPUSH
47736: CALL_OW 1
47740: ST_TO_ADDR
// end ;
47741: LD_VAR 0 3
47745: RET
// export function MC_SetLabKind ( base , kinds ) ; var i ; begin
47746: LD_INT 0
47748: PPUSH
47749: PPUSH
// if not mc_bases or not base or not kinds then
47750: LD_EXP 80
47754: NOT
47755: PUSH
47756: LD_VAR 0 1
47760: NOT
47761: OR
47762: PUSH
47763: LD_VAR 0 2
47767: NOT
47768: OR
47769: IFFALSE 47773
// exit ;
47771: GO 47834
// for i in kinds do
47773: LD_ADDR_VAR 0 4
47777: PUSH
47778: LD_VAR 0 2
47782: PUSH
47783: FOR_IN
47784: IFFALSE 47832
// mc_lab_upgrade := ReplaceIn ( mc_lab_upgrade , [ base , mc_lab_upgrade [ base ] + 1 ] , i ) ;
47786: LD_ADDR_EXP 114
47790: PUSH
47791: LD_EXP 114
47795: PPUSH
47796: LD_VAR 0 1
47800: PUSH
47801: LD_EXP 114
47805: PUSH
47806: LD_VAR 0 1
47810: ARRAY
47811: PUSH
47812: LD_INT 1
47814: PLUS
47815: PUSH
47816: EMPTY
47817: LIST
47818: LIST
47819: PPUSH
47820: LD_VAR 0 4
47824: PPUSH
47825: CALL 58440 0 3
47829: ST_TO_ADDR
47830: GO 47783
47832: POP
47833: POP
// end ;
47834: LD_VAR 0 3
47838: RET
// export function MC_SetCratesArea ( base , areas ) ; begin
47839: LD_INT 0
47841: PPUSH
// if not mc_bases or not base or not areas then
47842: LD_EXP 80
47846: NOT
47847: PUSH
47848: LD_VAR 0 1
47852: NOT
47853: OR
47854: PUSH
47855: LD_VAR 0 2
47859: NOT
47860: OR
47861: IFFALSE 47865
// exit ;
47863: GO 47890
// mc_crates_area := Replace ( mc_crates_area , base , areas ) ;
47865: LD_ADDR_EXP 98
47869: PUSH
47870: LD_EXP 98
47874: PPUSH
47875: LD_VAR 0 1
47879: PPUSH
47880: LD_VAR 0 2
47884: PPUSH
47885: CALL_OW 1
47889: ST_TO_ADDR
// end ;
47890: LD_VAR 0 3
47894: RET
// export function MC_SetTeleportExit ( base , teleports_exit ) ; begin
47895: LD_INT 0
47897: PPUSH
// if not mc_bases or not base or not teleports_exit then
47898: LD_EXP 80
47902: NOT
47903: PUSH
47904: LD_VAR 0 1
47908: NOT
47909: OR
47910: PUSH
47911: LD_VAR 0 2
47915: NOT
47916: OR
47917: IFFALSE 47921
// exit ;
47919: GO 47946
// mc_teleport_exit := Replace ( mc_teleport_exit , base , teleports_exit ) ;
47921: LD_ADDR_EXP 115
47925: PUSH
47926: LD_EXP 115
47930: PPUSH
47931: LD_VAR 0 1
47935: PPUSH
47936: LD_VAR 0 2
47940: PPUSH
47941: CALL_OW 1
47945: ST_TO_ADDR
// end ;
47946: LD_VAR 0 3
47950: RET
// export function MC_SetFactoryExtension ( base , x , y , d , ext_list ) ; var i , tmp ; begin
47951: LD_INT 0
47953: PPUSH
47954: PPUSH
47955: PPUSH
// if not mc_bases or not base or not ext_list then
47956: LD_EXP 80
47960: NOT
47961: PUSH
47962: LD_VAR 0 1
47966: NOT
47967: OR
47968: PUSH
47969: LD_VAR 0 5
47973: NOT
47974: OR
47975: IFFALSE 47979
// exit ;
47977: GO 48152
// tmp := GetFacExtXYD ( x , y , d ) ;
47979: LD_ADDR_VAR 0 8
47983: PUSH
47984: LD_VAR 0 2
47988: PPUSH
47989: LD_VAR 0 3
47993: PPUSH
47994: LD_VAR 0 4
47998: PPUSH
47999: CALL 88803 0 3
48003: ST_TO_ADDR
// if not tmp then
48004: LD_VAR 0 8
48008: NOT
48009: IFFALSE 48013
// exit ;
48011: GO 48152
// for i in tmp do
48013: LD_ADDR_VAR 0 7
48017: PUSH
48018: LD_VAR 0 8
48022: PUSH
48023: FOR_IN
48024: IFFALSE 48150
// begin mc_build_list := Replace ( mc_build_list , base , Insert ( mc_build_list [ base ] , mc_build_list [ base ] + 1 , [ ext_list [ 1 ] , i [ 1 ] , i [ 2 ] , i [ 3 ] ] ) ) ;
48026: LD_ADDR_EXP 85
48030: PUSH
48031: LD_EXP 85
48035: PPUSH
48036: LD_VAR 0 1
48040: PPUSH
48041: LD_EXP 85
48045: PUSH
48046: LD_VAR 0 1
48050: ARRAY
48051: PPUSH
48052: LD_EXP 85
48056: PUSH
48057: LD_VAR 0 1
48061: ARRAY
48062: PUSH
48063: LD_INT 1
48065: PLUS
48066: PPUSH
48067: LD_VAR 0 5
48071: PUSH
48072: LD_INT 1
48074: ARRAY
48075: PUSH
48076: LD_VAR 0 7
48080: PUSH
48081: LD_INT 1
48083: ARRAY
48084: PUSH
48085: LD_VAR 0 7
48089: PUSH
48090: LD_INT 2
48092: ARRAY
48093: PUSH
48094: LD_VAR 0 7
48098: PUSH
48099: LD_INT 3
48101: ARRAY
48102: PUSH
48103: EMPTY
48104: LIST
48105: LIST
48106: LIST
48107: LIST
48108: PPUSH
48109: CALL_OW 2
48113: PPUSH
48114: CALL_OW 1
48118: ST_TO_ADDR
// ext_list := Delete ( ext_list , 1 ) ;
48119: LD_ADDR_VAR 0 5
48123: PUSH
48124: LD_VAR 0 5
48128: PPUSH
48129: LD_INT 1
48131: PPUSH
48132: CALL_OW 3
48136: ST_TO_ADDR
// if not ext_list then
48137: LD_VAR 0 5
48141: NOT
48142: IFFALSE 48148
// exit ;
48144: POP
48145: POP
48146: GO 48152
// end ;
48148: GO 48023
48150: POP
48151: POP
// end ;
48152: LD_VAR 0 6
48156: RET
// export function MC_SetAllowedTurretWeapons ( base , weapon_list ) ; begin
48157: LD_INT 0
48159: PPUSH
// if not mc_bases or not base or not weapon_list then
48160: LD_EXP 80
48164: NOT
48165: PUSH
48166: LD_VAR 0 1
48170: NOT
48171: OR
48172: PUSH
48173: LD_VAR 0 2
48177: NOT
48178: OR
48179: IFFALSE 48183
// exit ;
48181: GO 48208
// mc_allowed_tower_weapons := Replace ( mc_allowed_tower_weapons , base , weapon_list ) ;
48183: LD_ADDR_EXP 119
48187: PUSH
48188: LD_EXP 119
48192: PPUSH
48193: LD_VAR 0 1
48197: PPUSH
48198: LD_VAR 0 2
48202: PPUSH
48203: CALL_OW 1
48207: ST_TO_ADDR
// end ;
48208: LD_VAR 0 3
48212: RET
// export function MC_SetTechList ( base , tech_list ) ; begin
48213: LD_INT 0
48215: PPUSH
// if not mc_bases or not base or not tech_list then
48216: LD_EXP 80
48220: NOT
48221: PUSH
48222: LD_VAR 0 1
48226: NOT
48227: OR
48228: PUSH
48229: LD_VAR 0 2
48233: NOT
48234: OR
48235: IFFALSE 48239
// exit ;
48237: GO 48264
// mc_tech := Replace ( mc_tech , base , tech_list ) ;
48239: LD_ADDR_EXP 107
48243: PUSH
48244: LD_EXP 107
48248: PPUSH
48249: LD_VAR 0 1
48253: PPUSH
48254: LD_VAR 0 2
48258: PPUSH
48259: CALL_OW 1
48263: ST_TO_ADDR
// end ;
48264: LD_VAR 0 3
48268: RET
// export function MC_SetParkingArea ( base , parking_area ) ; begin
48269: LD_INT 0
48271: PPUSH
// if not mc_bases or not parking_area or not base then
48272: LD_EXP 80
48276: NOT
48277: PUSH
48278: LD_VAR 0 2
48282: NOT
48283: OR
48284: PUSH
48285: LD_VAR 0 1
48289: NOT
48290: OR
48291: IFFALSE 48295
// exit ;
48293: GO 48320
// mc_parking := Replace ( mc_parking , base , parking_area ) ;
48295: LD_ADDR_EXP 104
48299: PUSH
48300: LD_EXP 104
48304: PPUSH
48305: LD_VAR 0 1
48309: PPUSH
48310: LD_VAR 0 2
48314: PPUSH
48315: CALL_OW 1
48319: ST_TO_ADDR
// end ;
48320: LD_VAR 0 3
48324: RET
// export function MC_SetScanArea ( base , scan_area ) ; begin
48325: LD_INT 0
48327: PPUSH
// if not mc_bases or not base or not scan_area then
48328: LD_EXP 80
48332: NOT
48333: PUSH
48334: LD_VAR 0 1
48338: NOT
48339: OR
48340: PUSH
48341: LD_VAR 0 2
48345: NOT
48346: OR
48347: IFFALSE 48351
// exit ;
48349: GO 48376
// mc_scan_area := Replace ( mc_scan_area , base , scan_area ) ;
48351: LD_ADDR_EXP 105
48355: PUSH
48356: LD_EXP 105
48360: PPUSH
48361: LD_VAR 0 1
48365: PPUSH
48366: LD_VAR 0 2
48370: PPUSH
48371: CALL_OW 1
48375: ST_TO_ADDR
// end ;
48376: LD_VAR 0 3
48380: RET
// export function MC_NotTameApeman ( base ) ; var ape_techs ; begin
48381: LD_INT 0
48383: PPUSH
48384: PPUSH
// if not mc_bases or not base then
48385: LD_EXP 80
48389: NOT
48390: PUSH
48391: LD_VAR 0 1
48395: NOT
48396: OR
48397: IFFALSE 48401
// exit ;
48399: GO 48465
// ape_techs := [ 1 , 2 , 3 , 4 , 11 ] ;
48401: LD_ADDR_VAR 0 3
48405: PUSH
48406: LD_INT 1
48408: PUSH
48409: LD_INT 2
48411: PUSH
48412: LD_INT 3
48414: PUSH
48415: LD_INT 4
48417: PUSH
48418: LD_INT 11
48420: PUSH
48421: EMPTY
48422: LIST
48423: LIST
48424: LIST
48425: LIST
48426: LIST
48427: ST_TO_ADDR
// mc_tech := Replace ( mc_tech , base , mc_tech [ base ] diff ape_techs ) ;
48428: LD_ADDR_EXP 107
48432: PUSH
48433: LD_EXP 107
48437: PPUSH
48438: LD_VAR 0 1
48442: PPUSH
48443: LD_EXP 107
48447: PUSH
48448: LD_VAR 0 1
48452: ARRAY
48453: PUSH
48454: LD_VAR 0 3
48458: DIFF
48459: PPUSH
48460: CALL_OW 1
48464: ST_TO_ADDR
// end ;
48465: LD_VAR 0 2
48469: RET
// export function MC_GetVehicles ( base , onlyCombat ) ; begin
48470: LD_INT 0
48472: PPUSH
// result := mc_vehicles [ base ] ;
48473: LD_ADDR_VAR 0 3
48477: PUSH
48478: LD_EXP 99
48482: PUSH
48483: LD_VAR 0 1
48487: ARRAY
48488: ST_TO_ADDR
// if onlyCombat then
48489: LD_VAR 0 2
48493: IFFALSE 48665
// result := result diff UnitFilter ( result , [ f_or , [ f_weapon , us_cargo_bay ] , [ f_weapon , ru_cargo_bay ] , [ f_weapon , ru_big_cargo_bay ] , [ f_weapon , ar_cargo_bay ] , [ f_weapon , us_crane ] , [ f_weapon , ru_crane ] , [ f_weapon , ar_crane ] , [ f_weapon , us_bulldozer ] , [ f_weapon , ru_bulldozer ] , [ f_weapon , ru_radar ] , [ f_weapon , ar_control_tower ] , [ f_weapon , ru_siberium_rocket ] , [ f_weapon , us_siberium_rocket ] ] ) ;
48495: LD_ADDR_VAR 0 3
48499: PUSH
48500: LD_VAR 0 3
48504: PUSH
48505: LD_VAR 0 3
48509: PPUSH
48510: LD_INT 2
48512: PUSH
48513: LD_INT 34
48515: PUSH
48516: LD_INT 12
48518: PUSH
48519: EMPTY
48520: LIST
48521: LIST
48522: PUSH
48523: LD_INT 34
48525: PUSH
48526: LD_INT 51
48528: PUSH
48529: EMPTY
48530: LIST
48531: LIST
48532: PUSH
48533: LD_INT 34
48535: PUSH
48536: LD_INT 89
48538: PUSH
48539: EMPTY
48540: LIST
48541: LIST
48542: PUSH
48543: LD_INT 34
48545: PUSH
48546: LD_INT 32
48548: PUSH
48549: EMPTY
48550: LIST
48551: LIST
48552: PUSH
48553: LD_INT 34
48555: PUSH
48556: LD_INT 13
48558: PUSH
48559: EMPTY
48560: LIST
48561: LIST
48562: PUSH
48563: LD_INT 34
48565: PUSH
48566: LD_INT 52
48568: PUSH
48569: EMPTY
48570: LIST
48571: LIST
48572: PUSH
48573: LD_INT 34
48575: PUSH
48576: LD_INT 88
48578: PUSH
48579: EMPTY
48580: LIST
48581: LIST
48582: PUSH
48583: LD_INT 34
48585: PUSH
48586: LD_INT 14
48588: PUSH
48589: EMPTY
48590: LIST
48591: LIST
48592: PUSH
48593: LD_INT 34
48595: PUSH
48596: LD_INT 53
48598: PUSH
48599: EMPTY
48600: LIST
48601: LIST
48602: PUSH
48603: LD_INT 34
48605: PUSH
48606: LD_INT 98
48608: PUSH
48609: EMPTY
48610: LIST
48611: LIST
48612: PUSH
48613: LD_INT 34
48615: PUSH
48616: LD_INT 31
48618: PUSH
48619: EMPTY
48620: LIST
48621: LIST
48622: PUSH
48623: LD_INT 34
48625: PUSH
48626: LD_INT 48
48628: PUSH
48629: EMPTY
48630: LIST
48631: LIST
48632: PUSH
48633: LD_INT 34
48635: PUSH
48636: LD_INT 8
48638: PUSH
48639: EMPTY
48640: LIST
48641: LIST
48642: PUSH
48643: EMPTY
48644: LIST
48645: LIST
48646: LIST
48647: LIST
48648: LIST
48649: LIST
48650: LIST
48651: LIST
48652: LIST
48653: LIST
48654: LIST
48655: LIST
48656: LIST
48657: LIST
48658: PPUSH
48659: CALL_OW 72
48663: DIFF
48664: ST_TO_ADDR
// end ; end_of_file
48665: LD_VAR 0 3
48669: RET
// export function MCE_ApemanTamed ( ape , sci ) ; var i , tmp ; begin
48670: LD_INT 0
48672: PPUSH
48673: PPUSH
48674: PPUSH
// if not mc_bases or not skirmish then
48675: LD_EXP 80
48679: NOT
48680: PUSH
48681: LD_EXP 78
48685: NOT
48686: OR
48687: IFFALSE 48691
// exit ;
48689: GO 48856
// for i = 1 to mc_bases do
48691: LD_ADDR_VAR 0 4
48695: PUSH
48696: DOUBLE
48697: LD_INT 1
48699: DEC
48700: ST_TO_ADDR
48701: LD_EXP 80
48705: PUSH
48706: FOR_TO
48707: IFFALSE 48854
// begin if sci in mc_bases [ i ] then
48709: LD_VAR 0 2
48713: PUSH
48714: LD_EXP 80
48718: PUSH
48719: LD_VAR 0 4
48723: ARRAY
48724: IN
48725: IFFALSE 48852
// begin mc_ape := ReplaceIn ( mc_ape , [ i , mc_ape [ i ] + 1 ] , ape ) ;
48727: LD_ADDR_EXP 109
48731: PUSH
48732: LD_EXP 109
48736: PPUSH
48737: LD_VAR 0 4
48741: PUSH
48742: LD_EXP 109
48746: PUSH
48747: LD_VAR 0 4
48751: ARRAY
48752: PUSH
48753: LD_INT 1
48755: PLUS
48756: PUSH
48757: EMPTY
48758: LIST
48759: LIST
48760: PPUSH
48761: LD_VAR 0 1
48765: PPUSH
48766: CALL 58440 0 3
48770: ST_TO_ADDR
// tmp := NearestUnitToUnit ( UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) , ape ) ;
48771: LD_ADDR_VAR 0 5
48775: PUSH
48776: LD_EXP 80
48780: PUSH
48781: LD_VAR 0 4
48785: ARRAY
48786: PPUSH
48787: LD_INT 2
48789: PUSH
48790: LD_INT 30
48792: PUSH
48793: LD_INT 0
48795: PUSH
48796: EMPTY
48797: LIST
48798: LIST
48799: PUSH
48800: LD_INT 30
48802: PUSH
48803: LD_INT 1
48805: PUSH
48806: EMPTY
48807: LIST
48808: LIST
48809: PUSH
48810: EMPTY
48811: LIST
48812: LIST
48813: LIST
48814: PPUSH
48815: CALL_OW 72
48819: PPUSH
48820: LD_VAR 0 1
48824: PPUSH
48825: CALL_OW 74
48829: ST_TO_ADDR
// if tmp then
48830: LD_VAR 0 5
48834: IFFALSE 48850
// ComStandNearbyBuilding ( ape , tmp ) ;
48836: LD_VAR 0 1
48840: PPUSH
48841: LD_VAR 0 5
48845: PPUSH
48846: CALL 55042 0 2
// break ;
48850: GO 48854
// end ; end ;
48852: GO 48706
48854: POP
48855: POP
// end ;
48856: LD_VAR 0 3
48860: RET
// export function MCE_EnterBuilding ( building , unit ) ; var i , tmp ; begin
48861: LD_INT 0
48863: PPUSH
48864: PPUSH
48865: PPUSH
// if not mc_bases or not skirmish then
48866: LD_EXP 80
48870: NOT
48871: PUSH
48872: LD_EXP 78
48876: NOT
48877: OR
48878: IFFALSE 48882
// exit ;
48880: GO 48971
// for i = 1 to mc_bases do
48882: LD_ADDR_VAR 0 4
48886: PUSH
48887: DOUBLE
48888: LD_INT 1
48890: DEC
48891: ST_TO_ADDR
48892: LD_EXP 80
48896: PUSH
48897: FOR_TO
48898: IFFALSE 48969
// begin if building in mc_busy_turret_list [ i ] then
48900: LD_VAR 0 1
48904: PUSH
48905: LD_EXP 90
48909: PUSH
48910: LD_VAR 0 4
48914: ARRAY
48915: IN
48916: IFFALSE 48967
// begin tmp := mc_busy_turret_list [ i ] diff building ;
48918: LD_ADDR_VAR 0 5
48922: PUSH
48923: LD_EXP 90
48927: PUSH
48928: LD_VAR 0 4
48932: ARRAY
48933: PUSH
48934: LD_VAR 0 1
48938: DIFF
48939: ST_TO_ADDR
// mc_busy_turret_list := Replace ( mc_busy_turret_list , i , tmp ) ;
48940: LD_ADDR_EXP 90
48944: PUSH
48945: LD_EXP 90
48949: PPUSH
48950: LD_VAR 0 4
48954: PPUSH
48955: LD_VAR 0 5
48959: PPUSH
48960: CALL_OW 1
48964: ST_TO_ADDR
// break ;
48965: GO 48969
// end ; end ;
48967: GO 48897
48969: POP
48970: POP
// end ;
48971: LD_VAR 0 3
48975: RET
// export function MCE_BuildingCaptured ( building , side , capturning_unit ) ; var i , tmp ; begin
48976: LD_INT 0
48978: PPUSH
48979: PPUSH
48980: PPUSH
// if not mc_bases or not skirmish then
48981: LD_EXP 80
48985: NOT
48986: PUSH
48987: LD_EXP 78
48991: NOT
48992: OR
48993: IFFALSE 48997
// exit ;
48995: GO 49196
// for i = 1 to mc_bases do
48997: LD_ADDR_VAR 0 5
49001: PUSH
49002: DOUBLE
49003: LD_INT 1
49005: DEC
49006: ST_TO_ADDR
49007: LD_EXP 80
49011: PUSH
49012: FOR_TO
49013: IFFALSE 49194
// if building in mc_bases [ i ] then
49015: LD_VAR 0 1
49019: PUSH
49020: LD_EXP 80
49024: PUSH
49025: LD_VAR 0 5
49029: ARRAY
49030: IN
49031: IFFALSE 49192
// begin tmp := mc_bases [ i ] diff building ;
49033: LD_ADDR_VAR 0 6
49037: PUSH
49038: LD_EXP 80
49042: PUSH
49043: LD_VAR 0 5
49047: ARRAY
49048: PUSH
49049: LD_VAR 0 1
49053: DIFF
49054: ST_TO_ADDR
// mc_bases := Replace ( mc_bases , i , tmp ) ;
49055: LD_ADDR_EXP 80
49059: PUSH
49060: LD_EXP 80
49064: PPUSH
49065: LD_VAR 0 5
49069: PPUSH
49070: LD_VAR 0 6
49074: PPUSH
49075: CALL_OW 1
49079: ST_TO_ADDR
// if building in mc_turret_list [ i ] then
49080: LD_VAR 0 1
49084: PUSH
49085: LD_EXP 88
49089: PUSH
49090: LD_VAR 0 5
49094: ARRAY
49095: IN
49096: IFFALSE 49135
// mc_turret_list := Replace ( mc_turret_list , i , mc_turret_list [ i ] diff building ) ;
49098: LD_ADDR_EXP 88
49102: PUSH
49103: LD_EXP 88
49107: PPUSH
49108: LD_VAR 0 5
49112: PPUSH
49113: LD_EXP 88
49117: PUSH
49118: LD_VAR 0 5
49122: ARRAY
49123: PUSH
49124: LD_VAR 0 1
49128: DIFF
49129: PPUSH
49130: CALL_OW 1
49134: ST_TO_ADDR
// if building in mc_empty_turret_list [ i ] then
49135: LD_VAR 0 1
49139: PUSH
49140: LD_EXP 89
49144: PUSH
49145: LD_VAR 0 5
49149: ARRAY
49150: IN
49151: IFFALSE 49190
// mc_empty_turret_list := Replace ( mc_empty_turret_list , i , mc_empty_turret_list [ i ] diff building ) ;
49153: LD_ADDR_EXP 89
49157: PUSH
49158: LD_EXP 89
49162: PPUSH
49163: LD_VAR 0 5
49167: PPUSH
49168: LD_EXP 89
49172: PUSH
49173: LD_VAR 0 5
49177: ARRAY
49178: PUSH
49179: LD_VAR 0 1
49183: DIFF
49184: PPUSH
49185: CALL_OW 1
49189: ST_TO_ADDR
// break ;
49190: GO 49194
// end ;
49192: GO 49012
49194: POP
49195: POP
// end ;
49196: LD_VAR 0 4
49200: RET
// export function MCE_VehicleCaptured ( new , old , side , capturing_unit ) ; var i , tmp ; begin
49201: LD_INT 0
49203: PPUSH
49204: PPUSH
49205: PPUSH
// if not mc_bases or not skirmish or not side in mc_sides then
49206: LD_EXP 80
49210: NOT
49211: PUSH
49212: LD_EXP 78
49216: NOT
49217: OR
49218: PUSH
49219: LD_VAR 0 3
49223: PUSH
49224: LD_EXP 106
49228: IN
49229: NOT
49230: OR
49231: IFFALSE 49235
// exit ;
49233: GO 49358
// for i = 1 to mc_vehicles do
49235: LD_ADDR_VAR 0 6
49239: PUSH
49240: DOUBLE
49241: LD_INT 1
49243: DEC
49244: ST_TO_ADDR
49245: LD_EXP 99
49249: PUSH
49250: FOR_TO
49251: IFFALSE 49356
// if old in mc_vehicles [ i ] or new in mc_vehicles [ i ] then
49253: LD_VAR 0 2
49257: PUSH
49258: LD_EXP 99
49262: PUSH
49263: LD_VAR 0 6
49267: ARRAY
49268: IN
49269: PUSH
49270: LD_VAR 0 1
49274: PUSH
49275: LD_EXP 99
49279: PUSH
49280: LD_VAR 0 6
49284: ARRAY
49285: IN
49286: OR
49287: IFFALSE 49354
// begin tmp := mc_vehicles [ i ] diff old ;
49289: LD_ADDR_VAR 0 7
49293: PUSH
49294: LD_EXP 99
49298: PUSH
49299: LD_VAR 0 6
49303: ARRAY
49304: PUSH
49305: LD_VAR 0 2
49309: DIFF
49310: ST_TO_ADDR
// tmp := tmp diff new ;
49311: LD_ADDR_VAR 0 7
49315: PUSH
49316: LD_VAR 0 7
49320: PUSH
49321: LD_VAR 0 1
49325: DIFF
49326: ST_TO_ADDR
// mc_vehicles := Replace ( mc_vehicles , i , tmp ) ;
49327: LD_ADDR_EXP 99
49331: PUSH
49332: LD_EXP 99
49336: PPUSH
49337: LD_VAR 0 6
49341: PPUSH
49342: LD_VAR 0 7
49346: PPUSH
49347: CALL_OW 1
49351: ST_TO_ADDR
// break ;
49352: GO 49356
// end ;
49354: GO 49250
49356: POP
49357: POP
// end ;
49358: LD_VAR 0 5
49362: RET
// export function MCE_VehicleConstructed ( vehicle , factory ) ; var i , side , tmp ; begin
49363: LD_INT 0
49365: PPUSH
49366: PPUSH
49367: PPUSH
49368: PPUSH
// if not mc_bases or not skirmish then
49369: LD_EXP 80
49373: NOT
49374: PUSH
49375: LD_EXP 78
49379: NOT
49380: OR
49381: IFFALSE 49385
// exit ;
49383: GO 49805
// repeat wait ( 0 0$1 ) ;
49385: LD_INT 35
49387: PPUSH
49388: CALL_OW 67
// until not mc_block_vehicle_constructed_thread ;
49392: LD_EXP 124
49396: NOT
49397: IFFALSE 49385
// mc_block_vehicle_constructed_thread := true ;
49399: LD_ADDR_EXP 124
49403: PUSH
49404: LD_INT 1
49406: ST_TO_ADDR
// side := GetSide ( vehicle ) ;
49407: LD_ADDR_VAR 0 5
49411: PUSH
49412: LD_VAR 0 1
49416: PPUSH
49417: CALL_OW 255
49421: ST_TO_ADDR
// for i = 1 to mc_bases do
49422: LD_ADDR_VAR 0 4
49426: PUSH
49427: DOUBLE
49428: LD_INT 1
49430: DEC
49431: ST_TO_ADDR
49432: LD_EXP 80
49436: PUSH
49437: FOR_TO
49438: IFFALSE 49795
// begin if factory in mc_bases [ i ] then
49440: LD_VAR 0 2
49444: PUSH
49445: LD_EXP 80
49449: PUSH
49450: LD_VAR 0 4
49454: ARRAY
49455: IN
49456: IFFALSE 49793
// begin if mc_defender [ i ] < mc_defender_limit [ i ] and not GetWeapon ( vehicle ) in [ ar_control_tower , ar_cargo_bay , ru_cargo_bay , ru_big_cargo_bay , us_cargo_bay , ar_radar , ru_radar , us_radar , ru_bulldozer , us_bulldozer , ar_bio_bomb , ar_selfpropelled_bomb , us_hack , us_crane , ru_crane , ar_crane , ru_siberium_rocket , us_siberium_rocket ] then
49458: LD_EXP 102
49462: PUSH
49463: LD_VAR 0 4
49467: ARRAY
49468: PUSH
49469: LD_EXP 91
49473: PUSH
49474: LD_VAR 0 4
49478: ARRAY
49479: LESS
49480: PUSH
49481: LD_VAR 0 1
49485: PPUSH
49486: CALL_OW 264
49490: PUSH
49491: LD_INT 31
49493: PUSH
49494: LD_INT 32
49496: PUSH
49497: LD_INT 51
49499: PUSH
49500: LD_INT 89
49502: PUSH
49503: LD_INT 12
49505: PUSH
49506: LD_INT 30
49508: PUSH
49509: LD_INT 98
49511: PUSH
49512: LD_INT 11
49514: PUSH
49515: LD_INT 53
49517: PUSH
49518: LD_INT 14
49520: PUSH
49521: LD_INT 91
49523: PUSH
49524: LD_INT 29
49526: PUSH
49527: LD_INT 99
49529: PUSH
49530: LD_INT 13
49532: PUSH
49533: LD_INT 52
49535: PUSH
49536: LD_INT 88
49538: PUSH
49539: LD_INT 48
49541: PUSH
49542: LD_INT 8
49544: PUSH
49545: EMPTY
49546: LIST
49547: LIST
49548: LIST
49549: LIST
49550: LIST
49551: LIST
49552: LIST
49553: LIST
49554: LIST
49555: LIST
49556: LIST
49557: LIST
49558: LIST
49559: LIST
49560: LIST
49561: LIST
49562: LIST
49563: LIST
49564: IN
49565: NOT
49566: AND
49567: IFFALSE 49615
// mc_defender := ReplaceIn ( mc_defender , [ i , mc_defender [ i ] + 1 ] , vehicle ) else
49569: LD_ADDR_EXP 102
49573: PUSH
49574: LD_EXP 102
49578: PPUSH
49579: LD_VAR 0 4
49583: PUSH
49584: LD_EXP 102
49588: PUSH
49589: LD_VAR 0 4
49593: ARRAY
49594: PUSH
49595: LD_INT 1
49597: PLUS
49598: PUSH
49599: EMPTY
49600: LIST
49601: LIST
49602: PPUSH
49603: LD_VAR 0 1
49607: PPUSH
49608: CALL 58440 0 3
49612: ST_TO_ADDR
49613: GO 49659
// mc_vehicles := ReplaceIn ( mc_vehicles , [ i , mc_vehicles [ i ] + 1 ] , vehicle ) ;
49615: LD_ADDR_EXP 99
49619: PUSH
49620: LD_EXP 99
49624: PPUSH
49625: LD_VAR 0 4
49629: PUSH
49630: LD_EXP 99
49634: PUSH
49635: LD_VAR 0 4
49639: ARRAY
49640: PUSH
49641: LD_INT 1
49643: PLUS
49644: PUSH
49645: EMPTY
49646: LIST
49647: LIST
49648: PPUSH
49649: LD_VAR 0 1
49653: PPUSH
49654: CALL 58440 0 3
49658: ST_TO_ADDR
// mc_block_vehicle_constructed_thread := false ;
49659: LD_ADDR_EXP 124
49663: PUSH
49664: LD_INT 0
49666: ST_TO_ADDR
// if GetControl ( vehicle ) = control_remote then
49667: LD_VAR 0 1
49671: PPUSH
49672: CALL_OW 263
49676: PUSH
49677: LD_INT 2
49679: EQUAL
49680: IFFALSE 49709
// begin repeat wait ( 0 0$3 ) ;
49682: LD_INT 105
49684: PPUSH
49685: CALL_OW 67
// Connect ( vehicle ) ;
49689: LD_VAR 0 1
49693: PPUSH
49694: CALL 61786 0 1
// until IsControledBy ( vehicle ) ;
49698: LD_VAR 0 1
49702: PPUSH
49703: CALL_OW 312
49707: IFFALSE 49682
// end ; ComMoveToArea ( vehicle , mc_parking [ i ] ) ;
49709: LD_VAR 0 1
49713: PPUSH
49714: LD_EXP 104
49718: PUSH
49719: LD_VAR 0 4
49723: ARRAY
49724: PPUSH
49725: CALL_OW 113
// if GetControl ( vehicle ) <> control_manual then
49729: LD_VAR 0 1
49733: PPUSH
49734: CALL_OW 263
49738: PUSH
49739: LD_INT 1
49741: NONEQUAL
49742: IFFALSE 49746
// break ;
49744: GO 49795
// repeat wait ( 0 0$1 ) ;
49746: LD_INT 35
49748: PPUSH
49749: CALL_OW 67
// until IsInArea ( vehicle , mc_parking [ i ] ) ;
49753: LD_VAR 0 1
49757: PPUSH
49758: LD_EXP 104
49762: PUSH
49763: LD_VAR 0 4
49767: ARRAY
49768: PPUSH
49769: CALL_OW 308
49773: IFFALSE 49746
// ComExitVehicle ( IsDrivenBy ( vehicle ) ) ;
49775: LD_VAR 0 1
49779: PPUSH
49780: CALL_OW 311
49784: PPUSH
49785: CALL_OW 121
// exit ;
49789: POP
49790: POP
49791: GO 49805
// end ; end ;
49793: GO 49437
49795: POP
49796: POP
// mc_block_vehicle_constructed_thread := false ;
49797: LD_ADDR_EXP 124
49801: PUSH
49802: LD_INT 0
49804: ST_TO_ADDR
// end ;
49805: LD_VAR 0 3
49809: RET
// export function MCE_CrateSpawn ( id , x , y , amount , mode ) ; var i , j , depot ; begin
49810: LD_INT 0
49812: PPUSH
49813: PPUSH
49814: PPUSH
49815: PPUSH
// if not mc_bases or not skirmish then
49816: LD_EXP 80
49820: NOT
49821: PUSH
49822: LD_EXP 78
49826: NOT
49827: OR
49828: IFFALSE 49832
// exit ;
49830: GO 50185
// repeat wait ( 0 0$1 ) ;
49832: LD_INT 35
49834: PPUSH
49835: CALL_OW 67
// until GetResourceAmountXY ( x , y ) ;
49839: LD_VAR 0 2
49843: PPUSH
49844: LD_VAR 0 3
49848: PPUSH
49849: CALL_OW 284
49853: IFFALSE 49832
// if GetResourceTypeXY ( x , y ) = mat_artefact then
49855: LD_VAR 0 2
49859: PPUSH
49860: LD_VAR 0 3
49864: PPUSH
49865: CALL_OW 283
49869: PUSH
49870: LD_INT 4
49872: EQUAL
49873: IFFALSE 49877
// exit ;
49875: GO 50185
// for i = 1 to mc_bases do
49877: LD_ADDR_VAR 0 7
49881: PUSH
49882: DOUBLE
49883: LD_INT 1
49885: DEC
49886: ST_TO_ADDR
49887: LD_EXP 80
49891: PUSH
49892: FOR_TO
49893: IFFALSE 50183
// begin if mc_crates_area [ i ] then
49895: LD_EXP 98
49899: PUSH
49900: LD_VAR 0 7
49904: ARRAY
49905: IFFALSE 50016
// for j in mc_crates_area [ i ] do
49907: LD_ADDR_VAR 0 8
49911: PUSH
49912: LD_EXP 98
49916: PUSH
49917: LD_VAR 0 7
49921: ARRAY
49922: PUSH
49923: FOR_IN
49924: IFFALSE 50014
// if InArea ( x , y , j ) then
49926: LD_VAR 0 2
49930: PPUSH
49931: LD_VAR 0 3
49935: PPUSH
49936: LD_VAR 0 8
49940: PPUSH
49941: CALL_OW 309
49945: IFFALSE 50012
// begin mc_crates := ReplaceIn ( mc_crates , [ i , mc_crates [ i ] + 1 ] , [ amount , x , y ] ) ;
49947: LD_ADDR_EXP 96
49951: PUSH
49952: LD_EXP 96
49956: PPUSH
49957: LD_VAR 0 7
49961: PUSH
49962: LD_EXP 96
49966: PUSH
49967: LD_VAR 0 7
49971: ARRAY
49972: PUSH
49973: LD_INT 1
49975: PLUS
49976: PUSH
49977: EMPTY
49978: LIST
49979: LIST
49980: PPUSH
49981: LD_VAR 0 4
49985: PUSH
49986: LD_VAR 0 2
49990: PUSH
49991: LD_VAR 0 3
49995: PUSH
49996: EMPTY
49997: LIST
49998: LIST
49999: LIST
50000: PPUSH
50001: CALL 58440 0 3
50005: ST_TO_ADDR
// exit ;
50006: POP
50007: POP
50008: POP
50009: POP
50010: GO 50185
// end ;
50012: GO 49923
50014: POP
50015: POP
// depot := UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) ;
50016: LD_ADDR_VAR 0 9
50020: PUSH
50021: LD_EXP 80
50025: PUSH
50026: LD_VAR 0 7
50030: ARRAY
50031: PPUSH
50032: LD_INT 2
50034: PUSH
50035: LD_INT 30
50037: PUSH
50038: LD_INT 0
50040: PUSH
50041: EMPTY
50042: LIST
50043: LIST
50044: PUSH
50045: LD_INT 30
50047: PUSH
50048: LD_INT 1
50050: PUSH
50051: EMPTY
50052: LIST
50053: LIST
50054: PUSH
50055: EMPTY
50056: LIST
50057: LIST
50058: LIST
50059: PPUSH
50060: CALL_OW 72
50064: ST_TO_ADDR
// if not depot then
50065: LD_VAR 0 9
50069: NOT
50070: IFFALSE 50074
// continue ;
50072: GO 49892
// for j in depot do
50074: LD_ADDR_VAR 0 8
50078: PUSH
50079: LD_VAR 0 9
50083: PUSH
50084: FOR_IN
50085: IFFALSE 50179
// if GetDistUnitXY ( j , x , y ) < 30 then
50087: LD_VAR 0 8
50091: PPUSH
50092: LD_VAR 0 2
50096: PPUSH
50097: LD_VAR 0 3
50101: PPUSH
50102: CALL_OW 297
50106: PUSH
50107: LD_INT 30
50109: LESS
50110: IFFALSE 50177
// begin mc_crates := ReplaceIn ( mc_crates , [ i , mc_crates [ i ] + 1 ] , [ amount , x , y ] ) ;
50112: LD_ADDR_EXP 96
50116: PUSH
50117: LD_EXP 96
50121: PPUSH
50122: LD_VAR 0 7
50126: PUSH
50127: LD_EXP 96
50131: PUSH
50132: LD_VAR 0 7
50136: ARRAY
50137: PUSH
50138: LD_INT 1
50140: PLUS
50141: PUSH
50142: EMPTY
50143: LIST
50144: LIST
50145: PPUSH
50146: LD_VAR 0 4
50150: PUSH
50151: LD_VAR 0 2
50155: PUSH
50156: LD_VAR 0 3
50160: PUSH
50161: EMPTY
50162: LIST
50163: LIST
50164: LIST
50165: PPUSH
50166: CALL 58440 0 3
50170: ST_TO_ADDR
// exit ;
50171: POP
50172: POP
50173: POP
50174: POP
50175: GO 50185
// end ;
50177: GO 50084
50179: POP
50180: POP
// end ;
50181: GO 49892
50183: POP
50184: POP
// end ;
50185: LD_VAR 0 6
50189: RET
// export function MCE_ResearchComplete ( tech , lab ) ; var side , i , tmp ; begin
50190: LD_INT 0
50192: PPUSH
50193: PPUSH
50194: PPUSH
50195: PPUSH
// if not mc_bases or not skirmish then
50196: LD_EXP 80
50200: NOT
50201: PUSH
50202: LD_EXP 78
50206: NOT
50207: OR
50208: IFFALSE 50212
// exit ;
50210: GO 50489
// side := GetSide ( lab ) ;
50212: LD_ADDR_VAR 0 4
50216: PUSH
50217: LD_VAR 0 2
50221: PPUSH
50222: CALL_OW 255
50226: ST_TO_ADDR
// if not side in mc_sides or not mc_tech or not mc_bases then
50227: LD_VAR 0 4
50231: PUSH
50232: LD_EXP 106
50236: IN
50237: NOT
50238: PUSH
50239: LD_EXP 107
50243: NOT
50244: OR
50245: PUSH
50246: LD_EXP 80
50250: NOT
50251: OR
50252: IFFALSE 50256
// exit ;
50254: GO 50489
// mc_tech := Replace ( mc_tech , side , mc_tech [ side ] diff tech ) ;
50256: LD_ADDR_EXP 107
50260: PUSH
50261: LD_EXP 107
50265: PPUSH
50266: LD_VAR 0 4
50270: PPUSH
50271: LD_EXP 107
50275: PUSH
50276: LD_VAR 0 4
50280: ARRAY
50281: PUSH
50282: LD_VAR 0 1
50286: DIFF
50287: PPUSH
50288: CALL_OW 1
50292: ST_TO_ADDR
// for i = 1 to mc_bases do
50293: LD_ADDR_VAR 0 5
50297: PUSH
50298: DOUBLE
50299: LD_INT 1
50301: DEC
50302: ST_TO_ADDR
50303: LD_EXP 80
50307: PUSH
50308: FOR_TO
50309: IFFALSE 50487
// begin if lab in mc_bases [ i ] then
50311: LD_VAR 0 2
50315: PUSH
50316: LD_EXP 80
50320: PUSH
50321: LD_VAR 0 5
50325: ARRAY
50326: IN
50327: IFFALSE 50485
// begin if tech in [ tech_apeagres , tech_apebrain , tech_apeneural , tech_apepsych ] and mc_ape_in_lab [ i ] then
50329: LD_VAR 0 1
50333: PUSH
50334: LD_INT 11
50336: PUSH
50337: LD_INT 4
50339: PUSH
50340: LD_INT 3
50342: PUSH
50343: LD_INT 2
50345: PUSH
50346: EMPTY
50347: LIST
50348: LIST
50349: LIST
50350: LIST
50351: IN
50352: PUSH
50353: LD_EXP 110
50357: PUSH
50358: LD_VAR 0 5
50362: ARRAY
50363: AND
50364: IFFALSE 50485
// begin tmp := mc_ape_in_lab [ i ] [ 1 ] ;
50366: LD_ADDR_VAR 0 6
50370: PUSH
50371: LD_EXP 110
50375: PUSH
50376: LD_VAR 0 5
50380: ARRAY
50381: PUSH
50382: LD_INT 1
50384: ARRAY
50385: ST_TO_ADDR
// mc_ape_in_lab := Replace ( mc_ape_in_lab , i , [ ] ) ;
50386: LD_ADDR_EXP 110
50390: PUSH
50391: LD_EXP 110
50395: PPUSH
50396: LD_VAR 0 5
50400: PPUSH
50401: EMPTY
50402: PPUSH
50403: CALL_OW 1
50407: ST_TO_ADDR
// SetTag ( tmp , 0 ) ;
50408: LD_VAR 0 6
50412: PPUSH
50413: LD_INT 0
50415: PPUSH
50416: CALL_OW 109
// ComExitBuilding ( tmp ) ;
50420: LD_VAR 0 6
50424: PPUSH
50425: CALL_OW 122
// mc_ape := Replace ( mc_ape , i , Insert ( mc_ape [ i ] , 1 , tmp ) ) ;
50429: LD_ADDR_EXP 109
50433: PUSH
50434: LD_EXP 109
50438: PPUSH
50439: LD_VAR 0 5
50443: PPUSH
50444: LD_EXP 109
50448: PUSH
50449: LD_VAR 0 5
50453: ARRAY
50454: PPUSH
50455: LD_INT 1
50457: PPUSH
50458: LD_VAR 0 6
50462: PPUSH
50463: CALL_OW 2
50467: PPUSH
50468: CALL_OW 1
50472: ST_TO_ADDR
// MC_Reset ( i , 112 ) ;
50473: LD_VAR 0 5
50477: PPUSH
50478: LD_INT 112
50480: PPUSH
50481: CALL 26939 0 2
// end ; end ; end ;
50485: GO 50308
50487: POP
50488: POP
// end ;
50489: LD_VAR 0 3
50493: RET
// export function MCE_UnitDestroyed ( un ) ; var i , j , btype , pos , tmp , fac , components ; begin
50494: LD_INT 0
50496: PPUSH
50497: PPUSH
50498: PPUSH
50499: PPUSH
50500: PPUSH
50501: PPUSH
50502: PPUSH
50503: PPUSH
// if not mc_bases or not skirmish then
50504: LD_EXP 80
50508: NOT
50509: PUSH
50510: LD_EXP 78
50514: NOT
50515: OR
50516: IFFALSE 50520
// exit ;
50518: GO 51889
// for i = 1 to mc_bases do
50520: LD_ADDR_VAR 0 3
50524: PUSH
50525: DOUBLE
50526: LD_INT 1
50528: DEC
50529: ST_TO_ADDR
50530: LD_EXP 80
50534: PUSH
50535: FOR_TO
50536: IFFALSE 51887
// if un in mc_bases [ i ] or un in mc_construct_list [ i ] or un in mc_defender [ i ] or un in mc_vehicles [ i ] or un in mc_ape [ i ] or un in mc_ape_in_lab [ i ] then
50538: LD_VAR 0 1
50542: PUSH
50543: LD_EXP 80
50547: PUSH
50548: LD_VAR 0 3
50552: ARRAY
50553: IN
50554: PUSH
50555: LD_VAR 0 1
50559: PUSH
50560: LD_EXP 87
50564: PUSH
50565: LD_VAR 0 3
50569: ARRAY
50570: IN
50571: OR
50572: PUSH
50573: LD_VAR 0 1
50577: PUSH
50578: LD_EXP 102
50582: PUSH
50583: LD_VAR 0 3
50587: ARRAY
50588: IN
50589: OR
50590: PUSH
50591: LD_VAR 0 1
50595: PUSH
50596: LD_EXP 99
50600: PUSH
50601: LD_VAR 0 3
50605: ARRAY
50606: IN
50607: OR
50608: PUSH
50609: LD_VAR 0 1
50613: PUSH
50614: LD_EXP 109
50618: PUSH
50619: LD_VAR 0 3
50623: ARRAY
50624: IN
50625: OR
50626: PUSH
50627: LD_VAR 0 1
50631: PUSH
50632: LD_EXP 110
50636: PUSH
50637: LD_VAR 0 3
50641: ARRAY
50642: IN
50643: OR
50644: IFFALSE 51885
// begin if un in mc_ape [ i ] then
50646: LD_VAR 0 1
50650: PUSH
50651: LD_EXP 109
50655: PUSH
50656: LD_VAR 0 3
50660: ARRAY
50661: IN
50662: IFFALSE 50701
// begin mc_ape := Replace ( mc_ape , i , mc_ape [ i ] diff un ) ;
50664: LD_ADDR_EXP 109
50668: PUSH
50669: LD_EXP 109
50673: PPUSH
50674: LD_VAR 0 3
50678: PPUSH
50679: LD_EXP 109
50683: PUSH
50684: LD_VAR 0 3
50688: ARRAY
50689: PUSH
50690: LD_VAR 0 1
50694: DIFF
50695: PPUSH
50696: CALL_OW 1
50700: ST_TO_ADDR
// end ; if un in mc_ape_in_lab [ i ] then
50701: LD_VAR 0 1
50705: PUSH
50706: LD_EXP 110
50710: PUSH
50711: LD_VAR 0 3
50715: ARRAY
50716: IN
50717: IFFALSE 50741
// begin mc_ape_in_lab := Replace ( mc_ape_in_lab , i , [ ] ) ;
50719: LD_ADDR_EXP 110
50723: PUSH
50724: LD_EXP 110
50728: PPUSH
50729: LD_VAR 0 3
50733: PPUSH
50734: EMPTY
50735: PPUSH
50736: CALL_OW 1
50740: ST_TO_ADDR
// end ; if GetType ( un ) = unit_vehicle and ( GetTag ( un ) = 20 or un in mc_defender [ i ] or GetWeapon ( un ) in [ us_cargo_bay , ru_cargo_bay , ru_big_cargo_bay , ar_cargo_bay , us_crane , ru_crane , ar_control_tower ] ) then
50741: LD_VAR 0 1
50745: PPUSH
50746: CALL_OW 247
50750: PUSH
50751: LD_INT 2
50753: EQUAL
50754: PUSH
50755: LD_VAR 0 1
50759: PPUSH
50760: CALL_OW 110
50764: PUSH
50765: LD_INT 20
50767: EQUAL
50768: PUSH
50769: LD_VAR 0 1
50773: PUSH
50774: LD_EXP 102
50778: PUSH
50779: LD_VAR 0 3
50783: ARRAY
50784: IN
50785: OR
50786: PUSH
50787: LD_VAR 0 1
50791: PPUSH
50792: CALL_OW 264
50796: PUSH
50797: LD_INT 12
50799: PUSH
50800: LD_INT 51
50802: PUSH
50803: LD_INT 89
50805: PUSH
50806: LD_INT 32
50808: PUSH
50809: LD_INT 13
50811: PUSH
50812: LD_INT 52
50814: PUSH
50815: LD_INT 31
50817: PUSH
50818: EMPTY
50819: LIST
50820: LIST
50821: LIST
50822: LIST
50823: LIST
50824: LIST
50825: LIST
50826: IN
50827: OR
50828: AND
50829: IFFALSE 51137
// begin if un in mc_defender [ i ] then
50831: LD_VAR 0 1
50835: PUSH
50836: LD_EXP 102
50840: PUSH
50841: LD_VAR 0 3
50845: ARRAY
50846: IN
50847: IFFALSE 50886
// mc_defender := Replace ( mc_defender , i , mc_defender [ i ] diff un ) ;
50849: LD_ADDR_EXP 102
50853: PUSH
50854: LD_EXP 102
50858: PPUSH
50859: LD_VAR 0 3
50863: PPUSH
50864: LD_EXP 102
50868: PUSH
50869: LD_VAR 0 3
50873: ARRAY
50874: PUSH
50875: LD_VAR 0 1
50879: DIFF
50880: PPUSH
50881: CALL_OW 1
50885: ST_TO_ADDR
// fac := MC_GetBuildings ( i , b_factory ) ;
50886: LD_ADDR_VAR 0 8
50890: PUSH
50891: LD_VAR 0 3
50895: PPUSH
50896: LD_INT 3
50898: PPUSH
50899: CALL 47507 0 2
50903: ST_TO_ADDR
// if fac then
50904: LD_VAR 0 8
50908: IFFALSE 51137
// begin for j in fac do
50910: LD_ADDR_VAR 0 4
50914: PUSH
50915: LD_VAR 0 8
50919: PUSH
50920: FOR_IN
50921: IFFALSE 51135
// begin components := Produce ( fac , GetChassis ( un ) , GetEngine ( un ) , GetControl ( un ) , GetWeapon ( un ) ) ;
50923: LD_ADDR_VAR 0 9
50927: PUSH
50928: LD_VAR 0 8
50932: PPUSH
50933: LD_VAR 0 1
50937: PPUSH
50938: CALL_OW 265
50942: PPUSH
50943: LD_VAR 0 1
50947: PPUSH
50948: CALL_OW 262
50952: PPUSH
50953: LD_VAR 0 1
50957: PPUSH
50958: CALL_OW 263
50962: PPUSH
50963: LD_VAR 0 1
50967: PPUSH
50968: CALL_OW 264
50972: PPUSH
50973: CALL 55938 0 5
50977: ST_TO_ADDR
// if components then
50978: LD_VAR 0 9
50982: IFFALSE 51133
// begin if GetWeapon ( un ) = ar_control_tower then
50984: LD_VAR 0 1
50988: PPUSH
50989: CALL_OW 264
50993: PUSH
50994: LD_INT 31
50996: EQUAL
50997: IFFALSE 51114
// begin SetTag ( IsDrivenBy ( un ) , 0 ) ;
50999: LD_VAR 0 1
51003: PPUSH
51004: CALL_OW 311
51008: PPUSH
51009: LD_INT 0
51011: PPUSH
51012: CALL_OW 109
// mc_remote_driver := Replace ( mc_remote_driver , i , mc_remote_driver [ i ] diff IsDrivenBy ( un ) ) ;
51016: LD_ADDR_EXP 120
51020: PUSH
51021: LD_EXP 120
51025: PPUSH
51026: LD_VAR 0 3
51030: PPUSH
51031: LD_EXP 120
51035: PUSH
51036: LD_VAR 0 3
51040: ARRAY
51041: PUSH
51042: LD_VAR 0 1
51046: PPUSH
51047: CALL_OW 311
51051: DIFF
51052: PPUSH
51053: CALL_OW 1
51057: ST_TO_ADDR
// tmp := Insert ( mc_produce [ i ] , 1 , components ) ;
51058: LD_ADDR_VAR 0 7
51062: PUSH
51063: LD_EXP 101
51067: PUSH
51068: LD_VAR 0 3
51072: ARRAY
51073: PPUSH
51074: LD_INT 1
51076: PPUSH
51077: LD_VAR 0 9
51081: PPUSH
51082: CALL_OW 2
51086: ST_TO_ADDR
// mc_produce := Replace ( mc_produce , i , tmp ) ;
51087: LD_ADDR_EXP 101
51091: PUSH
51092: LD_EXP 101
51096: PPUSH
51097: LD_VAR 0 3
51101: PPUSH
51102: LD_VAR 0 7
51106: PPUSH
51107: CALL_OW 1
51111: ST_TO_ADDR
// end else
51112: GO 51131
// MC_InsertProduceList ( i , [ components ] ) ;
51114: LD_VAR 0 3
51118: PPUSH
51119: LD_VAR 0 9
51123: PUSH
51124: EMPTY
51125: LIST
51126: PPUSH
51127: CALL 47052 0 2
// break ;
51131: GO 51135
// end ; end ;
51133: GO 50920
51135: POP
51136: POP
// end ; end ; if GetType ( un ) = unit_building then
51137: LD_VAR 0 1
51141: PPUSH
51142: CALL_OW 247
51146: PUSH
51147: LD_INT 3
51149: EQUAL
51150: IFFALSE 51553
// begin btype := GetBType ( un ) ;
51152: LD_ADDR_VAR 0 5
51156: PUSH
51157: LD_VAR 0 1
51161: PPUSH
51162: CALL_OW 266
51166: ST_TO_ADDR
// if btype in [ b_oil_mine , b_siberite_mine ] then
51167: LD_VAR 0 5
51171: PUSH
51172: LD_INT 29
51174: PUSH
51175: LD_INT 30
51177: PUSH
51178: EMPTY
51179: LIST
51180: LIST
51181: IN
51182: IFFALSE 51255
// begin if not GetResourceVisibility ( GetX ( un ) , GetY ( un ) , GetSide ( un ) ) then
51184: LD_VAR 0 1
51188: PPUSH
51189: CALL_OW 250
51193: PPUSH
51194: LD_VAR 0 1
51198: PPUSH
51199: CALL_OW 251
51203: PPUSH
51204: LD_VAR 0 1
51208: PPUSH
51209: CALL_OW 255
51213: PPUSH
51214: CALL_OW 440
51218: NOT
51219: IFFALSE 51255
// SetResourceVisibility ( GetX ( un ) , GetY ( un ) , GetSide ( un ) ) ;
51221: LD_VAR 0 1
51225: PPUSH
51226: CALL_OW 250
51230: PPUSH
51231: LD_VAR 0 1
51235: PPUSH
51236: CALL_OW 251
51240: PPUSH
51241: LD_VAR 0 1
51245: PPUSH
51246: CALL_OW 255
51250: PPUSH
51251: CALL_OW 441
// end ; if btype = b_warehouse then
51255: LD_VAR 0 5
51259: PUSH
51260: LD_INT 1
51262: EQUAL
51263: IFFALSE 51281
// begin btype := b_depot ;
51265: LD_ADDR_VAR 0 5
51269: PUSH
51270: LD_INT 0
51272: ST_TO_ADDR
// pos := 1 ;
51273: LD_ADDR_VAR 0 6
51277: PUSH
51278: LD_INT 1
51280: ST_TO_ADDR
// end ; if btype = b_factory then
51281: LD_VAR 0 5
51285: PUSH
51286: LD_INT 3
51288: EQUAL
51289: IFFALSE 51307
// begin btype := b_workshop ;
51291: LD_ADDR_VAR 0 5
51295: PUSH
51296: LD_INT 2
51298: ST_TO_ADDR
// pos := 1 ;
51299: LD_ADDR_VAR 0 6
51303: PUSH
51304: LD_INT 1
51306: ST_TO_ADDR
// end ; if btype = b_barracks then
51307: LD_VAR 0 5
51311: PUSH
51312: LD_INT 5
51314: EQUAL
51315: IFFALSE 51325
// btype := b_armoury ;
51317: LD_ADDR_VAR 0 5
51321: PUSH
51322: LD_INT 4
51324: ST_TO_ADDR
// if btype in [ b_lab_half , b_lab_full ] then
51325: LD_VAR 0 5
51329: PUSH
51330: LD_INT 7
51332: PUSH
51333: LD_INT 8
51335: PUSH
51336: EMPTY
51337: LIST
51338: LIST
51339: IN
51340: IFFALSE 51350
// btype := b_lab ;
51342: LD_ADDR_VAR 0 5
51346: PUSH
51347: LD_INT 6
51349: ST_TO_ADDR
// mc_build_list := ReplaceIn ( mc_build_list , [ i , mc_build_list [ i ] + 1 ] , [ btype , GetX ( un ) , GetY ( un ) , GetDir ( un ) ] ) ;
51350: LD_ADDR_EXP 85
51354: PUSH
51355: LD_EXP 85
51359: PPUSH
51360: LD_VAR 0 3
51364: PUSH
51365: LD_EXP 85
51369: PUSH
51370: LD_VAR 0 3
51374: ARRAY
51375: PUSH
51376: LD_INT 1
51378: PLUS
51379: PUSH
51380: EMPTY
51381: LIST
51382: LIST
51383: PPUSH
51384: LD_VAR 0 5
51388: PUSH
51389: LD_VAR 0 1
51393: PPUSH
51394: CALL_OW 250
51398: PUSH
51399: LD_VAR 0 1
51403: PPUSH
51404: CALL_OW 251
51408: PUSH
51409: LD_VAR 0 1
51413: PPUSH
51414: CALL_OW 254
51418: PUSH
51419: EMPTY
51420: LIST
51421: LIST
51422: LIST
51423: LIST
51424: PPUSH
51425: CALL 58440 0 3
51429: ST_TO_ADDR
// if pos = 1 then
51430: LD_VAR 0 6
51434: PUSH
51435: LD_INT 1
51437: EQUAL
51438: IFFALSE 51553
// begin tmp := mc_build_list [ i ] ;
51440: LD_ADDR_VAR 0 7
51444: PUSH
51445: LD_EXP 85
51449: PUSH
51450: LD_VAR 0 3
51454: ARRAY
51455: ST_TO_ADDR
// if UnitFilter ( tmp , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) then
51456: LD_VAR 0 7
51460: PPUSH
51461: LD_INT 2
51463: PUSH
51464: LD_INT 30
51466: PUSH
51467: LD_INT 0
51469: PUSH
51470: EMPTY
51471: LIST
51472: LIST
51473: PUSH
51474: LD_INT 30
51476: PUSH
51477: LD_INT 1
51479: PUSH
51480: EMPTY
51481: LIST
51482: LIST
51483: PUSH
51484: EMPTY
51485: LIST
51486: LIST
51487: LIST
51488: PPUSH
51489: CALL_OW 72
51493: IFFALSE 51503
// pos := 2 ;
51495: LD_ADDR_VAR 0 6
51499: PUSH
51500: LD_INT 2
51502: ST_TO_ADDR
// tmp := ReplaceWith ( tmp , pos , tmp ) ;
51503: LD_ADDR_VAR 0 7
51507: PUSH
51508: LD_VAR 0 7
51512: PPUSH
51513: LD_VAR 0 6
51517: PPUSH
51518: LD_VAR 0 7
51522: PPUSH
51523: CALL 58766 0 3
51527: ST_TO_ADDR
// mc_build_list := Replace ( mc_build_list , i , tmp ) ;
51528: LD_ADDR_EXP 85
51532: PUSH
51533: LD_EXP 85
51537: PPUSH
51538: LD_VAR 0 3
51542: PPUSH
51543: LD_VAR 0 7
51547: PPUSH
51548: CALL_OW 1
51552: ST_TO_ADDR
// end ; end ; if un in mc_bases [ i ] then
51553: LD_VAR 0 1
51557: PUSH
51558: LD_EXP 80
51562: PUSH
51563: LD_VAR 0 3
51567: ARRAY
51568: IN
51569: IFFALSE 51608
// begin mc_bases := Replace ( mc_bases , i , mc_bases [ i ] diff un ) ;
51571: LD_ADDR_EXP 80
51575: PUSH
51576: LD_EXP 80
51580: PPUSH
51581: LD_VAR 0 3
51585: PPUSH
51586: LD_EXP 80
51590: PUSH
51591: LD_VAR 0 3
51595: ARRAY
51596: PUSH
51597: LD_VAR 0 1
51601: DIFF
51602: PPUSH
51603: CALL_OW 1
51607: ST_TO_ADDR
// end ; if un in mc_construct_list [ i ] then
51608: LD_VAR 0 1
51612: PUSH
51613: LD_EXP 87
51617: PUSH
51618: LD_VAR 0 3
51622: ARRAY
51623: IN
51624: IFFALSE 51663
// begin mc_construct_list := Replace ( mc_construct_list , i , mc_construct_list [ i ] diff un ) ;
51626: LD_ADDR_EXP 87
51630: PUSH
51631: LD_EXP 87
51635: PPUSH
51636: LD_VAR 0 3
51640: PPUSH
51641: LD_EXP 87
51645: PUSH
51646: LD_VAR 0 3
51650: ARRAY
51651: PUSH
51652: LD_VAR 0 1
51656: DIFF
51657: PPUSH
51658: CALL_OW 1
51662: ST_TO_ADDR
// end ; if un in mc_vehicles [ i ] then
51663: LD_VAR 0 1
51667: PUSH
51668: LD_EXP 99
51672: PUSH
51673: LD_VAR 0 3
51677: ARRAY
51678: IN
51679: IFFALSE 51718
// begin mc_vehicles := Replace ( mc_vehicles , i , mc_vehicles [ i ] diff un ) ;
51681: LD_ADDR_EXP 99
51685: PUSH
51686: LD_EXP 99
51690: PPUSH
51691: LD_VAR 0 3
51695: PPUSH
51696: LD_EXP 99
51700: PUSH
51701: LD_VAR 0 3
51705: ARRAY
51706: PUSH
51707: LD_VAR 0 1
51711: DIFF
51712: PPUSH
51713: CALL_OW 1
51717: ST_TO_ADDR
// end ; if un in mc_defender [ i ] then
51718: LD_VAR 0 1
51722: PUSH
51723: LD_EXP 102
51727: PUSH
51728: LD_VAR 0 3
51732: ARRAY
51733: IN
51734: IFFALSE 51773
// begin mc_defender := Replace ( mc_defender , i , mc_defender [ i ] diff un ) ;
51736: LD_ADDR_EXP 102
51740: PUSH
51741: LD_EXP 102
51745: PPUSH
51746: LD_VAR 0 3
51750: PPUSH
51751: LD_EXP 102
51755: PUSH
51756: LD_VAR 0 3
51760: ARRAY
51761: PUSH
51762: LD_VAR 0 1
51766: DIFF
51767: PPUSH
51768: CALL_OW 1
51772: ST_TO_ADDR
// end ; if un in mc_empty_turret_list [ i ] then
51773: LD_VAR 0 1
51777: PUSH
51778: LD_EXP 89
51782: PUSH
51783: LD_VAR 0 3
51787: ARRAY
51788: IN
51789: IFFALSE 51828
// begin mc_empty_turret_list := Replace ( mc_empty_turret_list , i , mc_empty_turret_list [ i ] diff un ) ;
51791: LD_ADDR_EXP 89
51795: PUSH
51796: LD_EXP 89
51800: PPUSH
51801: LD_VAR 0 3
51805: PPUSH
51806: LD_EXP 89
51810: PUSH
51811: LD_VAR 0 3
51815: ARRAY
51816: PUSH
51817: LD_VAR 0 1
51821: DIFF
51822: PPUSH
51823: CALL_OW 1
51827: ST_TO_ADDR
// end ; if un in mc_turret_list [ i ] then
51828: LD_VAR 0 1
51832: PUSH
51833: LD_EXP 88
51837: PUSH
51838: LD_VAR 0 3
51842: ARRAY
51843: IN
51844: IFFALSE 51883
// begin mc_turret_list := Replace ( mc_turret_list , i , mc_turret_list [ i ] diff un ) ;
51846: LD_ADDR_EXP 88
51850: PUSH
51851: LD_EXP 88
51855: PPUSH
51856: LD_VAR 0 3
51860: PPUSH
51861: LD_EXP 88
51865: PUSH
51866: LD_VAR 0 3
51870: ARRAY
51871: PUSH
51872: LD_VAR 0 1
51876: DIFF
51877: PPUSH
51878: CALL_OW 1
51882: ST_TO_ADDR
// end ; break ;
51883: GO 51887
// end ;
51885: GO 50535
51887: POP
51888: POP
// end ;
51889: LD_VAR 0 2
51893: RET
// export function MCE_UpgradeComplete ( building ) ; var i , j ; begin
51894: LD_INT 0
51896: PPUSH
51897: PPUSH
51898: PPUSH
// if not mc_bases or not skirmish then
51899: LD_EXP 80
51903: NOT
51904: PUSH
51905: LD_EXP 78
51909: NOT
51910: OR
51911: IFFALSE 51915
// exit ;
51913: GO 52130
// for i = 1 to mc_bases do
51915: LD_ADDR_VAR 0 3
51919: PUSH
51920: DOUBLE
51921: LD_INT 1
51923: DEC
51924: ST_TO_ADDR
51925: LD_EXP 80
51929: PUSH
51930: FOR_TO
51931: IFFALSE 52128
// begin if building in mc_construct_list [ i ] then
51933: LD_VAR 0 1
51937: PUSH
51938: LD_EXP 87
51942: PUSH
51943: LD_VAR 0 3
51947: ARRAY
51948: IN
51949: IFFALSE 52126
// begin mc_construct_list := Replace ( mc_construct_list , i , mc_construct_list [ i ] diff building ) ;
51951: LD_ADDR_EXP 87
51955: PUSH
51956: LD_EXP 87
51960: PPUSH
51961: LD_VAR 0 3
51965: PPUSH
51966: LD_EXP 87
51970: PUSH
51971: LD_VAR 0 3
51975: ARRAY
51976: PUSH
51977: LD_VAR 0 1
51981: DIFF
51982: PPUSH
51983: CALL_OW 1
51987: ST_TO_ADDR
// if building in mc_lab [ i ] then
51988: LD_VAR 0 1
51992: PUSH
51993: LD_EXP 113
51997: PUSH
51998: LD_VAR 0 3
52002: ARRAY
52003: IN
52004: IFFALSE 52059
// mc_lab_upgrade := Replace ( mc_lab_upgrade , i , Reindex ( mc_lab_upgrade [ i ] , 1 , mc_lab_upgrade [ i ] , false ) ) ;
52006: LD_ADDR_EXP 114
52010: PUSH
52011: LD_EXP 114
52015: PPUSH
52016: LD_VAR 0 3
52020: PPUSH
52021: LD_EXP 114
52025: PUSH
52026: LD_VAR 0 3
52030: ARRAY
52031: PPUSH
52032: LD_INT 1
52034: PPUSH
52035: LD_EXP 114
52039: PUSH
52040: LD_VAR 0 3
52044: ARRAY
52045: PPUSH
52046: LD_INT 0
52048: PPUSH
52049: CALL 57858 0 4
52053: PPUSH
52054: CALL_OW 1
52058: ST_TO_ADDR
// if not building in mc_bases [ i ] then
52059: LD_VAR 0 1
52063: PUSH
52064: LD_EXP 80
52068: PUSH
52069: LD_VAR 0 3
52073: ARRAY
52074: IN
52075: NOT
52076: IFFALSE 52122
// mc_bases := ReplaceIn ( mc_bases , [ i , mc_bases [ i ] + 1 ] , building ) ;
52078: LD_ADDR_EXP 80
52082: PUSH
52083: LD_EXP 80
52087: PPUSH
52088: LD_VAR 0 3
52092: PUSH
52093: LD_EXP 80
52097: PUSH
52098: LD_VAR 0 3
52102: ARRAY
52103: PUSH
52104: LD_INT 1
52106: PLUS
52107: PUSH
52108: EMPTY
52109: LIST
52110: LIST
52111: PPUSH
52112: LD_VAR 0 1
52116: PPUSH
52117: CALL 58440 0 3
52121: ST_TO_ADDR
// exit ;
52122: POP
52123: POP
52124: GO 52130
// end ; end ;
52126: GO 51930
52128: POP
52129: POP
// end ;
52130: LD_VAR 0 2
52134: RET
// export function MCE_BuildingComplete ( building ) ; var i , j , btype , tmp , units , side ; begin
52135: LD_INT 0
52137: PPUSH
52138: PPUSH
52139: PPUSH
52140: PPUSH
52141: PPUSH
52142: PPUSH
52143: PPUSH
// if not mc_bases or not skirmish then
52144: LD_EXP 80
52148: NOT
52149: PUSH
52150: LD_EXP 78
52154: NOT
52155: OR
52156: IFFALSE 52160
// exit ;
52158: GO 52821
// for i = 1 to mc_bases do
52160: LD_ADDR_VAR 0 3
52164: PUSH
52165: DOUBLE
52166: LD_INT 1
52168: DEC
52169: ST_TO_ADDR
52170: LD_EXP 80
52174: PUSH
52175: FOR_TO
52176: IFFALSE 52819
// begin if building in mc_construct_list [ i ] then
52178: LD_VAR 0 1
52182: PUSH
52183: LD_EXP 87
52187: PUSH
52188: LD_VAR 0 3
52192: ARRAY
52193: IN
52194: IFFALSE 52817
// begin mc_construct_list := Replace ( mc_construct_list , i , mc_construct_list [ i ] diff building ) ;
52196: LD_ADDR_EXP 87
52200: PUSH
52201: LD_EXP 87
52205: PPUSH
52206: LD_VAR 0 3
52210: PPUSH
52211: LD_EXP 87
52215: PUSH
52216: LD_VAR 0 3
52220: ARRAY
52221: PUSH
52222: LD_VAR 0 1
52226: DIFF
52227: PPUSH
52228: CALL_OW 1
52232: ST_TO_ADDR
// mc_bases := ReplaceIn ( mc_bases , [ i , mc_bases [ i ] + 1 ] , building ) ;
52233: LD_ADDR_EXP 80
52237: PUSH
52238: LD_EXP 80
52242: PPUSH
52243: LD_VAR 0 3
52247: PUSH
52248: LD_EXP 80
52252: PUSH
52253: LD_VAR 0 3
52257: ARRAY
52258: PUSH
52259: LD_INT 1
52261: PLUS
52262: PUSH
52263: EMPTY
52264: LIST
52265: LIST
52266: PPUSH
52267: LD_VAR 0 1
52271: PPUSH
52272: CALL 58440 0 3
52276: ST_TO_ADDR
// btype := GetBType ( building ) ;
52277: LD_ADDR_VAR 0 5
52281: PUSH
52282: LD_VAR 0 1
52286: PPUSH
52287: CALL_OW 266
52291: ST_TO_ADDR
// side := GetSide ( building ) ;
52292: LD_ADDR_VAR 0 8
52296: PUSH
52297: LD_VAR 0 1
52301: PPUSH
52302: CALL_OW 255
52306: ST_TO_ADDR
// if btype = b_lab then
52307: LD_VAR 0 5
52311: PUSH
52312: LD_INT 6
52314: EQUAL
52315: IFFALSE 52365
// begin mc_lab := ReplaceIn ( mc_lab , [ i , mc_lab [ i ] + 1 ] , building ) ;
52317: LD_ADDR_EXP 113
52321: PUSH
52322: LD_EXP 113
52326: PPUSH
52327: LD_VAR 0 3
52331: PUSH
52332: LD_EXP 113
52336: PUSH
52337: LD_VAR 0 3
52341: ARRAY
52342: PUSH
52343: LD_INT 1
52345: PLUS
52346: PUSH
52347: EMPTY
52348: LIST
52349: LIST
52350: PPUSH
52351: LD_VAR 0 1
52355: PPUSH
52356: CALL 58440 0 3
52360: ST_TO_ADDR
// exit ;
52361: POP
52362: POP
52363: GO 52821
// end ; if btype in [ b_depot , b_workshop , b_armoury ] then
52365: LD_VAR 0 5
52369: PUSH
52370: LD_INT 0
52372: PUSH
52373: LD_INT 2
52375: PUSH
52376: LD_INT 4
52378: PUSH
52379: EMPTY
52380: LIST
52381: LIST
52382: LIST
52383: IN
52384: IFFALSE 52508
// begin if btype = b_armoury then
52386: LD_VAR 0 5
52390: PUSH
52391: LD_INT 4
52393: EQUAL
52394: IFFALSE 52404
// btype := b_barracks ;
52396: LD_ADDR_VAR 0 5
52400: PUSH
52401: LD_INT 5
52403: ST_TO_ADDR
// if btype = b_depot then
52404: LD_VAR 0 5
52408: PUSH
52409: LD_INT 0
52411: EQUAL
52412: IFFALSE 52422
// btype := b_warehouse ;
52414: LD_ADDR_VAR 0 5
52418: PUSH
52419: LD_INT 1
52421: ST_TO_ADDR
// if btype = b_workshop then
52422: LD_VAR 0 5
52426: PUSH
52427: LD_INT 2
52429: EQUAL
52430: IFFALSE 52440
// btype := b_factory ;
52432: LD_ADDR_VAR 0 5
52436: PUSH
52437: LD_INT 3
52439: ST_TO_ADDR
// if GetRestrict ( btype , side ) = state_enabled then
52440: LD_VAR 0 5
52444: PPUSH
52445: LD_VAR 0 8
52449: PPUSH
52450: CALL_OW 323
52454: PUSH
52455: LD_INT 1
52457: EQUAL
52458: IFFALSE 52504
// mc_build_upgrade := ReplaceIn ( mc_build_upgrade , [ i , mc_build_upgrade [ i ] + 1 ] , building ) ;
52460: LD_ADDR_EXP 112
52464: PUSH
52465: LD_EXP 112
52469: PPUSH
52470: LD_VAR 0 3
52474: PUSH
52475: LD_EXP 112
52479: PUSH
52480: LD_VAR 0 3
52484: ARRAY
52485: PUSH
52486: LD_INT 1
52488: PLUS
52489: PUSH
52490: EMPTY
52491: LIST
52492: LIST
52493: PPUSH
52494: LD_VAR 0 1
52498: PPUSH
52499: CALL 58440 0 3
52503: ST_TO_ADDR
// exit ;
52504: POP
52505: POP
52506: GO 52821
// end ; if btype in [ b_bunker , b_turret ] then
52508: LD_VAR 0 5
52512: PUSH
52513: LD_INT 32
52515: PUSH
52516: LD_INT 33
52518: PUSH
52519: EMPTY
52520: LIST
52521: LIST
52522: IN
52523: IFFALSE 52813
// begin mc_turret_list := ReplaceIn ( mc_turret_list , [ i , mc_turret_list [ i ] + 1 ] , building ) ;
52525: LD_ADDR_EXP 88
52529: PUSH
52530: LD_EXP 88
52534: PPUSH
52535: LD_VAR 0 3
52539: PUSH
52540: LD_EXP 88
52544: PUSH
52545: LD_VAR 0 3
52549: ARRAY
52550: PUSH
52551: LD_INT 1
52553: PLUS
52554: PUSH
52555: EMPTY
52556: LIST
52557: LIST
52558: PPUSH
52559: LD_VAR 0 1
52563: PPUSH
52564: CALL 58440 0 3
52568: ST_TO_ADDR
// if btype = b_bunker then
52569: LD_VAR 0 5
52573: PUSH
52574: LD_INT 32
52576: EQUAL
52577: IFFALSE 52813
// begin mc_empty_turret_list := ReplaceIn ( mc_empty_turret_list , [ i , mc_empty_turret_list [ i ] + 1 ] , building ) ;
52579: LD_ADDR_EXP 89
52583: PUSH
52584: LD_EXP 89
52588: PPUSH
52589: LD_VAR 0 3
52593: PUSH
52594: LD_EXP 89
52598: PUSH
52599: LD_VAR 0 3
52603: ARRAY
52604: PUSH
52605: LD_INT 1
52607: PLUS
52608: PUSH
52609: EMPTY
52610: LIST
52611: LIST
52612: PPUSH
52613: LD_VAR 0 1
52617: PPUSH
52618: CALL 58440 0 3
52622: ST_TO_ADDR
// tmp := UnitFilter ( mc_bases [ i ] , [ [ f_class , 1 ] , [ f_not , [ f_inside ] ] ] ) ;
52623: LD_ADDR_VAR 0 6
52627: PUSH
52628: LD_EXP 80
52632: PUSH
52633: LD_VAR 0 3
52637: ARRAY
52638: PPUSH
52639: LD_INT 25
52641: PUSH
52642: LD_INT 1
52644: PUSH
52645: EMPTY
52646: LIST
52647: LIST
52648: PUSH
52649: LD_INT 3
52651: PUSH
52652: LD_INT 54
52654: PUSH
52655: EMPTY
52656: LIST
52657: PUSH
52658: EMPTY
52659: LIST
52660: LIST
52661: PUSH
52662: EMPTY
52663: LIST
52664: LIST
52665: PPUSH
52666: CALL_OW 72
52670: ST_TO_ADDR
// if tmp then
52671: LD_VAR 0 6
52675: IFFALSE 52681
// exit ;
52677: POP
52678: POP
52679: GO 52821
// tmp := UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_armoury ] , [ f_btype , b_barracks ] ] ) ;
52681: LD_ADDR_VAR 0 6
52685: PUSH
52686: LD_EXP 80
52690: PUSH
52691: LD_VAR 0 3
52695: ARRAY
52696: PPUSH
52697: LD_INT 2
52699: PUSH
52700: LD_INT 30
52702: PUSH
52703: LD_INT 4
52705: PUSH
52706: EMPTY
52707: LIST
52708: LIST
52709: PUSH
52710: LD_INT 30
52712: PUSH
52713: LD_INT 5
52715: PUSH
52716: EMPTY
52717: LIST
52718: LIST
52719: PUSH
52720: EMPTY
52721: LIST
52722: LIST
52723: LIST
52724: PPUSH
52725: CALL_OW 72
52729: ST_TO_ADDR
// if not tmp then
52730: LD_VAR 0 6
52734: NOT
52735: IFFALSE 52741
// exit ;
52737: POP
52738: POP
52739: GO 52821
// for j in tmp do
52741: LD_ADDR_VAR 0 4
52745: PUSH
52746: LD_VAR 0 6
52750: PUSH
52751: FOR_IN
52752: IFFALSE 52811
// begin units := UnitFilter ( UnitsInside ( j ) , [ f_class , 1 ] ) ;
52754: LD_ADDR_VAR 0 7
52758: PUSH
52759: LD_VAR 0 4
52763: PPUSH
52764: CALL_OW 313
52768: PPUSH
52769: LD_INT 25
52771: PUSH
52772: LD_INT 1
52774: PUSH
52775: EMPTY
52776: LIST
52777: LIST
52778: PPUSH
52779: CALL_OW 72
52783: ST_TO_ADDR
// if units then
52784: LD_VAR 0 7
52788: IFFALSE 52809
// begin ComExitBuilding ( units [ 1 ] ) ;
52790: LD_VAR 0 7
52794: PUSH
52795: LD_INT 1
52797: ARRAY
52798: PPUSH
52799: CALL_OW 122
// exit ;
52803: POP
52804: POP
52805: POP
52806: POP
52807: GO 52821
// end ; end ;
52809: GO 52751
52811: POP
52812: POP
// end ; end ; exit ;
52813: POP
52814: POP
52815: GO 52821
// end ; end ;
52817: GO 52175
52819: POP
52820: POP
// end ;
52821: LD_VAR 0 2
52825: RET
// export function MCE_BuildingStarted ( building , builder ) ; var i , j , btype , x , y , d ; begin
52826: LD_INT 0
52828: PPUSH
52829: PPUSH
52830: PPUSH
52831: PPUSH
52832: PPUSH
52833: PPUSH
52834: PPUSH
// if not mc_bases or not skirmish then
52835: LD_EXP 80
52839: NOT
52840: PUSH
52841: LD_EXP 78
52845: NOT
52846: OR
52847: IFFALSE 52851
// exit ;
52849: GO 53116
// btype := GetBType ( building ) ;
52851: LD_ADDR_VAR 0 6
52855: PUSH
52856: LD_VAR 0 1
52860: PPUSH
52861: CALL_OW 266
52865: ST_TO_ADDR
// x := GetX ( building ) ;
52866: LD_ADDR_VAR 0 7
52870: PUSH
52871: LD_VAR 0 1
52875: PPUSH
52876: CALL_OW 250
52880: ST_TO_ADDR
// y := GetY ( building ) ;
52881: LD_ADDR_VAR 0 8
52885: PUSH
52886: LD_VAR 0 1
52890: PPUSH
52891: CALL_OW 251
52895: ST_TO_ADDR
// d := GetDir ( building ) ;
52896: LD_ADDR_VAR 0 9
52900: PUSH
52901: LD_VAR 0 1
52905: PPUSH
52906: CALL_OW 254
52910: ST_TO_ADDR
// for i = 1 to mc_bases do
52911: LD_ADDR_VAR 0 4
52915: PUSH
52916: DOUBLE
52917: LD_INT 1
52919: DEC
52920: ST_TO_ADDR
52921: LD_EXP 80
52925: PUSH
52926: FOR_TO
52927: IFFALSE 53114
// begin if not mc_build_list [ i ] then
52929: LD_EXP 85
52933: PUSH
52934: LD_VAR 0 4
52938: ARRAY
52939: NOT
52940: IFFALSE 52944
// continue ;
52942: GO 52926
// for j := 1 to mc_build_list [ i ] do
52944: LD_ADDR_VAR 0 5
52948: PUSH
52949: DOUBLE
52950: LD_INT 1
52952: DEC
52953: ST_TO_ADDR
52954: LD_EXP 85
52958: PUSH
52959: LD_VAR 0 4
52963: ARRAY
52964: PUSH
52965: FOR_TO
52966: IFFALSE 53110
// if CompareArray ( [ btype , x , y , d ] , mc_build_list [ i ] [ j ] ) then
52968: LD_VAR 0 6
52972: PUSH
52973: LD_VAR 0 7
52977: PUSH
52978: LD_VAR 0 8
52982: PUSH
52983: LD_VAR 0 9
52987: PUSH
52988: EMPTY
52989: LIST
52990: LIST
52991: LIST
52992: LIST
52993: PPUSH
52994: LD_EXP 85
52998: PUSH
52999: LD_VAR 0 4
53003: ARRAY
53004: PUSH
53005: LD_VAR 0 5
53009: ARRAY
53010: PPUSH
53011: CALL 64997 0 2
53015: IFFALSE 53108
// begin mc_build_list := Replace ( mc_build_list , i , Delete ( mc_build_list [ i ] , j ) ) ;
53017: LD_ADDR_EXP 85
53021: PUSH
53022: LD_EXP 85
53026: PPUSH
53027: LD_VAR 0 4
53031: PPUSH
53032: LD_EXP 85
53036: PUSH
53037: LD_VAR 0 4
53041: ARRAY
53042: PPUSH
53043: LD_VAR 0 5
53047: PPUSH
53048: CALL_OW 3
53052: PPUSH
53053: CALL_OW 1
53057: ST_TO_ADDR
// mc_construct_list := ReplaceIn ( mc_construct_list , [ i , mc_construct_list [ i ] + 1 ] , building ) ;
53058: LD_ADDR_EXP 87
53062: PUSH
53063: LD_EXP 87
53067: PPUSH
53068: LD_VAR 0 4
53072: PUSH
53073: LD_EXP 87
53077: PUSH
53078: LD_VAR 0 4
53082: ARRAY
53083: PUSH
53084: LD_INT 1
53086: PLUS
53087: PUSH
53088: EMPTY
53089: LIST
53090: LIST
53091: PPUSH
53092: LD_VAR 0 1
53096: PPUSH
53097: CALL 58440 0 3
53101: ST_TO_ADDR
// exit ;
53102: POP
53103: POP
53104: POP
53105: POP
53106: GO 53116
// end ;
53108: GO 52965
53110: POP
53111: POP
// end ;
53112: GO 52926
53114: POP
53115: POP
// end ;
53116: LD_VAR 0 3
53120: RET
// export function MCE_LeaveBuilding ( building , unit ) ; var i , tmp ; begin
53121: LD_INT 0
53123: PPUSH
53124: PPUSH
53125: PPUSH
// if not mc_bases or not skirmish then
53126: LD_EXP 80
53130: NOT
53131: PUSH
53132: LD_EXP 78
53136: NOT
53137: OR
53138: IFFALSE 53142
// exit ;
53140: GO 53332
// for i = 1 to mc_bases do
53142: LD_ADDR_VAR 0 4
53146: PUSH
53147: DOUBLE
53148: LD_INT 1
53150: DEC
53151: ST_TO_ADDR
53152: LD_EXP 80
53156: PUSH
53157: FOR_TO
53158: IFFALSE 53245
// begin if building in mc_turret_list [ i ] and not building in mc_empty_turret_list [ i ] then
53160: LD_VAR 0 1
53164: PUSH
53165: LD_EXP 88
53169: PUSH
53170: LD_VAR 0 4
53174: ARRAY
53175: IN
53176: PUSH
53177: LD_VAR 0 1
53181: PUSH
53182: LD_EXP 89
53186: PUSH
53187: LD_VAR 0 4
53191: ARRAY
53192: IN
53193: NOT
53194: AND
53195: IFFALSE 53243
// begin mc_empty_turret_list := ReplaceIn ( mc_empty_turret_list , [ i , mc_empty_turret_list [ i ] + 1 ] , building ) ;
53197: LD_ADDR_EXP 89
53201: PUSH
53202: LD_EXP 89
53206: PPUSH
53207: LD_VAR 0 4
53211: PUSH
53212: LD_EXP 89
53216: PUSH
53217: LD_VAR 0 4
53221: ARRAY
53222: PUSH
53223: LD_INT 1
53225: PLUS
53226: PUSH
53227: EMPTY
53228: LIST
53229: LIST
53230: PPUSH
53231: LD_VAR 0 1
53235: PPUSH
53236: CALL 58440 0 3
53240: ST_TO_ADDR
// break ;
53241: GO 53245
// end ; end ;
53243: GO 53157
53245: POP
53246: POP
// if GetClass ( building ) in mc_sides and GetBType ( building ) = b_barracks and GetTag ( unit ) <> 18 then
53247: LD_VAR 0 1
53251: PPUSH
53252: CALL_OW 257
53256: PUSH
53257: LD_EXP 106
53261: IN
53262: PUSH
53263: LD_VAR 0 1
53267: PPUSH
53268: CALL_OW 266
53272: PUSH
53273: LD_INT 5
53275: EQUAL
53276: AND
53277: PUSH
53278: LD_VAR 0 2
53282: PPUSH
53283: CALL_OW 110
53287: PUSH
53288: LD_INT 18
53290: NONEQUAL
53291: AND
53292: IFFALSE 53332
// if GetClass ( unit ) in [ 5 , 8 , 9 ] then
53294: LD_VAR 0 2
53298: PPUSH
53299: CALL_OW 257
53303: PUSH
53304: LD_INT 5
53306: PUSH
53307: LD_INT 8
53309: PUSH
53310: LD_INT 9
53312: PUSH
53313: EMPTY
53314: LIST
53315: LIST
53316: LIST
53317: IN
53318: IFFALSE 53332
// SetClass ( unit , 1 ) ;
53320: LD_VAR 0 2
53324: PPUSH
53325: LD_INT 1
53327: PPUSH
53328: CALL_OW 336
// end ;
53332: LD_VAR 0 3
53336: RET
// export function MCE_EvacuateVehicle ( driver , abandoned_vehicle , unknown1 , unknown2 ) ; var i ; begin
53337: LD_INT 0
53339: PPUSH
53340: PPUSH
// if not mc_bases or not skirmish then
53341: LD_EXP 80
53345: NOT
53346: PUSH
53347: LD_EXP 78
53351: NOT
53352: OR
53353: IFFALSE 53357
// exit ;
53355: GO 53473
// if GetLives ( abandoned_vehicle ) > 250 then
53357: LD_VAR 0 2
53361: PPUSH
53362: CALL_OW 256
53366: PUSH
53367: LD_INT 250
53369: GREATER
53370: IFFALSE 53374
// exit ;
53372: GO 53473
// for i = 1 to mc_bases do
53374: LD_ADDR_VAR 0 6
53378: PUSH
53379: DOUBLE
53380: LD_INT 1
53382: DEC
53383: ST_TO_ADDR
53384: LD_EXP 80
53388: PUSH
53389: FOR_TO
53390: IFFALSE 53471
// begin if driver in mc_bases [ i ] then
53392: LD_VAR 0 1
53396: PUSH
53397: LD_EXP 80
53401: PUSH
53402: LD_VAR 0 6
53406: ARRAY
53407: IN
53408: IFFALSE 53469
// begin ComMoveToNearbyEntrance ( driver , UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) [ 1 ] ) ;
53410: LD_VAR 0 1
53414: PPUSH
53415: LD_EXP 80
53419: PUSH
53420: LD_VAR 0 6
53424: ARRAY
53425: PPUSH
53426: LD_INT 2
53428: PUSH
53429: LD_INT 30
53431: PUSH
53432: LD_INT 0
53434: PUSH
53435: EMPTY
53436: LIST
53437: LIST
53438: PUSH
53439: LD_INT 30
53441: PUSH
53442: LD_INT 1
53444: PUSH
53445: EMPTY
53446: LIST
53447: LIST
53448: PUSH
53449: EMPTY
53450: LIST
53451: LIST
53452: LIST
53453: PPUSH
53454: CALL_OW 72
53458: PUSH
53459: LD_INT 1
53461: ARRAY
53462: PPUSH
53463: CALL 92046 0 2
// break ;
53467: GO 53471
// end ; end ;
53469: GO 53389
53471: POP
53472: POP
// end ; end_of_file
53473: LD_VAR 0 5
53477: RET
// export function PrepareUnit ( ident , exist_mode , prefix ) ; var unit ; begin
53478: LD_INT 0
53480: PPUSH
53481: PPUSH
// if exist_mode then
53482: LD_VAR 0 2
53486: IFFALSE 53511
// unit := CreateCharacter ( prefix & ident ) else
53488: LD_ADDR_VAR 0 5
53492: PUSH
53493: LD_VAR 0 3
53497: PUSH
53498: LD_VAR 0 1
53502: STR
53503: PPUSH
53504: CALL_OW 34
53508: ST_TO_ADDR
53509: GO 53526
// unit := NewCharacter ( ident ) ;
53511: LD_ADDR_VAR 0 5
53515: PUSH
53516: LD_VAR 0 1
53520: PPUSH
53521: CALL_OW 25
53525: ST_TO_ADDR
// result := unit ;
53526: LD_ADDR_VAR 0 4
53530: PUSH
53531: LD_VAR 0 5
53535: ST_TO_ADDR
// end ;
53536: LD_VAR 0 4
53540: RET
// export function GetTechNation ( side , nation , state ) ; var i ; begin
53541: LD_INT 0
53543: PPUSH
53544: PPUSH
// if not side or not nation then
53545: LD_VAR 0 1
53549: NOT
53550: PUSH
53551: LD_VAR 0 2
53555: NOT
53556: OR
53557: IFFALSE 53561
// exit ;
53559: GO 54329
// case nation of nation_american :
53561: LD_VAR 0 2
53565: PUSH
53566: LD_INT 1
53568: DOUBLE
53569: EQUAL
53570: IFTRUE 53574
53572: GO 53788
53574: POP
// result := [ 35 , 45 , 46 , 47 , 82 , 83 , 84 , 85 , 86 , 1 , 2 , 6 , 15 , 16 , 7 , 12 , 13 , 10 , 14 , 20 , 21 , 22 , 25 , 32 , 27 , 36 , 69 , 39 , 34 , 40 , 48 , 49 , 50 , 51 , 52 , 53 , 54 , 55 , 56 , 57 , 58 , 59 , 60 , 61 , 62 , 80 , 82 , 83 , 84 , 85 , 86 ] ; nation_arabian :
53575: LD_ADDR_VAR 0 4
53579: PUSH
53580: LD_INT 35
53582: PUSH
53583: LD_INT 45
53585: PUSH
53586: LD_INT 46
53588: PUSH
53589: LD_INT 47
53591: PUSH
53592: LD_INT 82
53594: PUSH
53595: LD_INT 83
53597: PUSH
53598: LD_INT 84
53600: PUSH
53601: LD_INT 85
53603: PUSH
53604: LD_INT 86
53606: PUSH
53607: LD_INT 1
53609: PUSH
53610: LD_INT 2
53612: PUSH
53613: LD_INT 6
53615: PUSH
53616: LD_INT 15
53618: PUSH
53619: LD_INT 16
53621: PUSH
53622: LD_INT 7
53624: PUSH
53625: LD_INT 12
53627: PUSH
53628: LD_INT 13
53630: PUSH
53631: LD_INT 10
53633: PUSH
53634: LD_INT 14
53636: PUSH
53637: LD_INT 20
53639: PUSH
53640: LD_INT 21
53642: PUSH
53643: LD_INT 22
53645: PUSH
53646: LD_INT 25
53648: PUSH
53649: LD_INT 32
53651: PUSH
53652: LD_INT 27
53654: PUSH
53655: LD_INT 36
53657: PUSH
53658: LD_INT 69
53660: PUSH
53661: LD_INT 39
53663: PUSH
53664: LD_INT 34
53666: PUSH
53667: LD_INT 40
53669: PUSH
53670: LD_INT 48
53672: PUSH
53673: LD_INT 49
53675: PUSH
53676: LD_INT 50
53678: PUSH
53679: LD_INT 51
53681: PUSH
53682: LD_INT 52
53684: PUSH
53685: LD_INT 53
53687: PUSH
53688: LD_INT 54
53690: PUSH
53691: LD_INT 55
53693: PUSH
53694: LD_INT 56
53696: PUSH
53697: LD_INT 57
53699: PUSH
53700: LD_INT 58
53702: PUSH
53703: LD_INT 59
53705: PUSH
53706: LD_INT 60
53708: PUSH
53709: LD_INT 61
53711: PUSH
53712: LD_INT 62
53714: PUSH
53715: LD_INT 80
53717: PUSH
53718: LD_INT 82
53720: PUSH
53721: LD_INT 83
53723: PUSH
53724: LD_INT 84
53726: PUSH
53727: LD_INT 85
53729: PUSH
53730: LD_INT 86
53732: PUSH
53733: EMPTY
53734: LIST
53735: LIST
53736: LIST
53737: LIST
53738: LIST
53739: LIST
53740: LIST
53741: LIST
53742: LIST
53743: LIST
53744: LIST
53745: LIST
53746: LIST
53747: LIST
53748: LIST
53749: LIST
53750: LIST
53751: LIST
53752: LIST
53753: LIST
53754: LIST
53755: LIST
53756: LIST
53757: LIST
53758: LIST
53759: LIST
53760: LIST
53761: LIST
53762: LIST
53763: LIST
53764: LIST
53765: LIST
53766: LIST
53767: LIST
53768: LIST
53769: LIST
53770: LIST
53771: LIST
53772: LIST
53773: LIST
53774: LIST
53775: LIST
53776: LIST
53777: LIST
53778: LIST
53779: LIST
53780: LIST
53781: LIST
53782: LIST
53783: LIST
53784: LIST
53785: ST_TO_ADDR
53786: GO 54253
53788: LD_INT 2
53790: DOUBLE
53791: EQUAL
53792: IFTRUE 53796
53794: GO 54022
53796: POP
// result := [ 35 , 45 , 46 , 47 , 82 , 83 , 84 , 85 , 87 , 70 , 1 , 11 , 3 , 4 , 5 , 6 , 15 , 18 , 7 , 17 , 8 , 20 , 21 , 22 , 72 , 26 , 69 , 39 , 40 , 41 , 42 , 43 , 48 , 49 , 50 , 51 , 52 , 53 , 54 , 55 , 56 , 60 , 61 , 62 , 66 , 67 , 68 , 81 , 82 , 83 , 84 , 85 , 87 , 88 ] ; nation_russian :
53797: LD_ADDR_VAR 0 4
53801: PUSH
53802: LD_INT 35
53804: PUSH
53805: LD_INT 45
53807: PUSH
53808: LD_INT 46
53810: PUSH
53811: LD_INT 47
53813: PUSH
53814: LD_INT 82
53816: PUSH
53817: LD_INT 83
53819: PUSH
53820: LD_INT 84
53822: PUSH
53823: LD_INT 85
53825: PUSH
53826: LD_INT 87
53828: PUSH
53829: LD_INT 70
53831: PUSH
53832: LD_INT 1
53834: PUSH
53835: LD_INT 11
53837: PUSH
53838: LD_INT 3
53840: PUSH
53841: LD_INT 4
53843: PUSH
53844: LD_INT 5
53846: PUSH
53847: LD_INT 6
53849: PUSH
53850: LD_INT 15
53852: PUSH
53853: LD_INT 18
53855: PUSH
53856: LD_INT 7
53858: PUSH
53859: LD_INT 17
53861: PUSH
53862: LD_INT 8
53864: PUSH
53865: LD_INT 20
53867: PUSH
53868: LD_INT 21
53870: PUSH
53871: LD_INT 22
53873: PUSH
53874: LD_INT 72
53876: PUSH
53877: LD_INT 26
53879: PUSH
53880: LD_INT 69
53882: PUSH
53883: LD_INT 39
53885: PUSH
53886: LD_INT 40
53888: PUSH
53889: LD_INT 41
53891: PUSH
53892: LD_INT 42
53894: PUSH
53895: LD_INT 43
53897: PUSH
53898: LD_INT 48
53900: PUSH
53901: LD_INT 49
53903: PUSH
53904: LD_INT 50
53906: PUSH
53907: LD_INT 51
53909: PUSH
53910: LD_INT 52
53912: PUSH
53913: LD_INT 53
53915: PUSH
53916: LD_INT 54
53918: PUSH
53919: LD_INT 55
53921: PUSH
53922: LD_INT 56
53924: PUSH
53925: LD_INT 60
53927: PUSH
53928: LD_INT 61
53930: PUSH
53931: LD_INT 62
53933: PUSH
53934: LD_INT 66
53936: PUSH
53937: LD_INT 67
53939: PUSH
53940: LD_INT 68
53942: PUSH
53943: LD_INT 81
53945: PUSH
53946: LD_INT 82
53948: PUSH
53949: LD_INT 83
53951: PUSH
53952: LD_INT 84
53954: PUSH
53955: LD_INT 85
53957: PUSH
53958: LD_INT 87
53960: PUSH
53961: LD_INT 88
53963: PUSH
53964: EMPTY
53965: LIST
53966: LIST
53967: LIST
53968: LIST
53969: LIST
53970: LIST
53971: LIST
53972: LIST
53973: LIST
53974: LIST
53975: LIST
53976: LIST
53977: LIST
53978: LIST
53979: LIST
53980: LIST
53981: LIST
53982: LIST
53983: LIST
53984: LIST
53985: LIST
53986: LIST
53987: LIST
53988: LIST
53989: LIST
53990: LIST
53991: LIST
53992: LIST
53993: LIST
53994: LIST
53995: LIST
53996: LIST
53997: LIST
53998: LIST
53999: LIST
54000: LIST
54001: LIST
54002: LIST
54003: LIST
54004: LIST
54005: LIST
54006: LIST
54007: LIST
54008: LIST
54009: LIST
54010: LIST
54011: LIST
54012: LIST
54013: LIST
54014: LIST
54015: LIST
54016: LIST
54017: LIST
54018: LIST
54019: ST_TO_ADDR
54020: GO 54253
54022: LD_INT 3
54024: DOUBLE
54025: EQUAL
54026: IFTRUE 54030
54028: GO 54252
54030: POP
// result := [ 46 , 47 , 1 , 2 , 82 , 83 , 84 , 85 , 86 , 11 , 9 , 20 , 19 , 21 , 24 , 22 , 25 , 28 , 29 , 30 , 31 , 37 , 38 , 32 , 27 , 33 , 69 , 39 , 34 , 40 , 71 , 23 , 44 , 48 , 49 , 50 , 51 , 52 , 53 , 54 , 55 , 56 , 57 , 58 , 59 , 63 , 64 , 65 , 82 , 83 , 84 , 85 , 86 ] ; end ;
54031: LD_ADDR_VAR 0 4
54035: PUSH
54036: LD_INT 46
54038: PUSH
54039: LD_INT 47
54041: PUSH
54042: LD_INT 1
54044: PUSH
54045: LD_INT 2
54047: PUSH
54048: LD_INT 82
54050: PUSH
54051: LD_INT 83
54053: PUSH
54054: LD_INT 84
54056: PUSH
54057: LD_INT 85
54059: PUSH
54060: LD_INT 86
54062: PUSH
54063: LD_INT 11
54065: PUSH
54066: LD_INT 9
54068: PUSH
54069: LD_INT 20
54071: PUSH
54072: LD_INT 19
54074: PUSH
54075: LD_INT 21
54077: PUSH
54078: LD_INT 24
54080: PUSH
54081: LD_INT 22
54083: PUSH
54084: LD_INT 25
54086: PUSH
54087: LD_INT 28
54089: PUSH
54090: LD_INT 29
54092: PUSH
54093: LD_INT 30
54095: PUSH
54096: LD_INT 31
54098: PUSH
54099: LD_INT 37
54101: PUSH
54102: LD_INT 38
54104: PUSH
54105: LD_INT 32
54107: PUSH
54108: LD_INT 27
54110: PUSH
54111: LD_INT 33
54113: PUSH
54114: LD_INT 69
54116: PUSH
54117: LD_INT 39
54119: PUSH
54120: LD_INT 34
54122: PUSH
54123: LD_INT 40
54125: PUSH
54126: LD_INT 71
54128: PUSH
54129: LD_INT 23
54131: PUSH
54132: LD_INT 44
54134: PUSH
54135: LD_INT 48
54137: PUSH
54138: LD_INT 49
54140: PUSH
54141: LD_INT 50
54143: PUSH
54144: LD_INT 51
54146: PUSH
54147: LD_INT 52
54149: PUSH
54150: LD_INT 53
54152: PUSH
54153: LD_INT 54
54155: PUSH
54156: LD_INT 55
54158: PUSH
54159: LD_INT 56
54161: PUSH
54162: LD_INT 57
54164: PUSH
54165: LD_INT 58
54167: PUSH
54168: LD_INT 59
54170: PUSH
54171: LD_INT 63
54173: PUSH
54174: LD_INT 64
54176: PUSH
54177: LD_INT 65
54179: PUSH
54180: LD_INT 82
54182: PUSH
54183: LD_INT 83
54185: PUSH
54186: LD_INT 84
54188: PUSH
54189: LD_INT 85
54191: PUSH
54192: LD_INT 86
54194: PUSH
54195: EMPTY
54196: LIST
54197: LIST
54198: LIST
54199: LIST
54200: LIST
54201: LIST
54202: LIST
54203: LIST
54204: LIST
54205: LIST
54206: LIST
54207: LIST
54208: LIST
54209: LIST
54210: LIST
54211: LIST
54212: LIST
54213: LIST
54214: LIST
54215: LIST
54216: LIST
54217: LIST
54218: LIST
54219: LIST
54220: LIST
54221: LIST
54222: LIST
54223: LIST
54224: LIST
54225: LIST
54226: LIST
54227: LIST
54228: LIST
54229: LIST
54230: LIST
54231: LIST
54232: LIST
54233: LIST
54234: LIST
54235: LIST
54236: LIST
54237: LIST
54238: LIST
54239: LIST
54240: LIST
54241: LIST
54242: LIST
54243: LIST
54244: LIST
54245: LIST
54246: LIST
54247: LIST
54248: LIST
54249: ST_TO_ADDR
54250: GO 54253
54252: POP
// if state > - 1 and state < 3 then
54253: LD_VAR 0 3
54257: PUSH
54258: LD_INT 1
54260: NEG
54261: GREATER
54262: PUSH
54263: LD_VAR 0 3
54267: PUSH
54268: LD_INT 3
54270: LESS
54271: AND
54272: IFFALSE 54329
// for i in result do
54274: LD_ADDR_VAR 0 5
54278: PUSH
54279: LD_VAR 0 4
54283: PUSH
54284: FOR_IN
54285: IFFALSE 54327
// if GetTech ( i , side ) <> state then
54287: LD_VAR 0 5
54291: PPUSH
54292: LD_VAR 0 1
54296: PPUSH
54297: CALL_OW 321
54301: PUSH
54302: LD_VAR 0 3
54306: NONEQUAL
54307: IFFALSE 54325
// result := result diff i ;
54309: LD_ADDR_VAR 0 4
54313: PUSH
54314: LD_VAR 0 4
54318: PUSH
54319: LD_VAR 0 5
54323: DIFF
54324: ST_TO_ADDR
54325: GO 54284
54327: POP
54328: POP
// end ;
54329: LD_VAR 0 4
54333: RET
// export function TechCanBeResearch ( side , tech ) ; var i , tmp ; begin
54334: LD_INT 0
54336: PPUSH
54337: PPUSH
54338: PPUSH
// result := true ;
54339: LD_ADDR_VAR 0 3
54343: PUSH
54344: LD_INT 1
54346: ST_TO_ADDR
// tmp := GetTechTechsReq ( tech ) ;
54347: LD_ADDR_VAR 0 5
54351: PUSH
54352: LD_VAR 0 2
54356: PPUSH
54357: CALL_OW 480
54361: ST_TO_ADDR
// if not tmp then
54362: LD_VAR 0 5
54366: NOT
54367: IFFALSE 54371
// exit ;
54369: GO 54420
// for i in tmp do
54371: LD_ADDR_VAR 0 4
54375: PUSH
54376: LD_VAR 0 5
54380: PUSH
54381: FOR_IN
54382: IFFALSE 54418
// if GetTech ( i , side ) <> state_researched then
54384: LD_VAR 0 4
54388: PPUSH
54389: LD_VAR 0 1
54393: PPUSH
54394: CALL_OW 321
54398: PUSH
54399: LD_INT 2
54401: NONEQUAL
54402: IFFALSE 54416
// begin result := false ;
54404: LD_ADDR_VAR 0 3
54408: PUSH
54409: LD_INT 0
54411: ST_TO_ADDR
// exit ;
54412: POP
54413: POP
54414: GO 54420
// end ;
54416: GO 54381
54418: POP
54419: POP
// end ;
54420: LD_VAR 0 3
54424: RET
// export function ComSpaceTimeShoot ( unit ) ; var i , x , y , _x , _y , tmp , side , enemy , in_unit , tech_space , tech_time , missile ; begin
54425: LD_INT 0
54427: PPUSH
54428: PPUSH
54429: PPUSH
54430: PPUSH
54431: PPUSH
54432: PPUSH
54433: PPUSH
54434: PPUSH
54435: PPUSH
54436: PPUSH
54437: PPUSH
54438: PPUSH
54439: PPUSH
// if not unit or GetClass ( unit ) <> class_bazooker then
54440: LD_VAR 0 1
54444: NOT
54445: PUSH
54446: LD_VAR 0 1
54450: PPUSH
54451: CALL_OW 257
54455: PUSH
54456: LD_INT 9
54458: NONEQUAL
54459: OR
54460: IFFALSE 54464
// exit ;
54462: GO 55037
// side := GetSide ( unit ) ;
54464: LD_ADDR_VAR 0 9
54468: PUSH
54469: LD_VAR 0 1
54473: PPUSH
54474: CALL_OW 255
54478: ST_TO_ADDR
// tech_space := tech_spacanom ;
54479: LD_ADDR_VAR 0 12
54483: PUSH
54484: LD_INT 29
54486: ST_TO_ADDR
// tech_time := tech_taurad ;
54487: LD_ADDR_VAR 0 13
54491: PUSH
54492: LD_INT 28
54494: ST_TO_ADDR
// in_unit := IsInUnit ( unit ) ;
54495: LD_ADDR_VAR 0 11
54499: PUSH
54500: LD_VAR 0 1
54504: PPUSH
54505: CALL_OW 310
54509: ST_TO_ADDR
// if GetType ( in_unit ) = unit_vehicle then
54510: LD_VAR 0 11
54514: PPUSH
54515: CALL_OW 247
54519: PUSH
54520: LD_INT 2
54522: EQUAL
54523: IFFALSE 54527
// exit ;
54525: GO 55037
// tmp := FilterAllUnits ( [ [ f_enemy , side ] , [ f_not , [ f_type , unit_building ] ] ] ) ;
54527: LD_ADDR_VAR 0 8
54531: PUSH
54532: LD_INT 81
54534: PUSH
54535: LD_VAR 0 9
54539: PUSH
54540: EMPTY
54541: LIST
54542: LIST
54543: PUSH
54544: LD_INT 3
54546: PUSH
54547: LD_INT 21
54549: PUSH
54550: LD_INT 3
54552: PUSH
54553: EMPTY
54554: LIST
54555: LIST
54556: PUSH
54557: EMPTY
54558: LIST
54559: LIST
54560: PUSH
54561: EMPTY
54562: LIST
54563: LIST
54564: PPUSH
54565: CALL_OW 69
54569: ST_TO_ADDR
// if not tmp then
54570: LD_VAR 0 8
54574: NOT
54575: IFFALSE 54579
// exit ;
54577: GO 55037
// if in_unit then
54579: LD_VAR 0 11
54583: IFFALSE 54607
// enemy := NearestUnitToUnit ( tmp , in_unit ) else
54585: LD_ADDR_VAR 0 10
54589: PUSH
54590: LD_VAR 0 8
54594: PPUSH
54595: LD_VAR 0 11
54599: PPUSH
54600: CALL_OW 74
54604: ST_TO_ADDR
54605: GO 54627
// enemy := NearestUnitToUnit ( tmp , unit ) ;
54607: LD_ADDR_VAR 0 10
54611: PUSH
54612: LD_VAR 0 8
54616: PPUSH
54617: LD_VAR 0 1
54621: PPUSH
54622: CALL_OW 74
54626: ST_TO_ADDR
// if not enemy then
54627: LD_VAR 0 10
54631: NOT
54632: IFFALSE 54636
// exit ;
54634: GO 55037
// if ( in_unit and GetDistUnits ( in_unit , enemy ) > 13 ) or GetDistUnits ( unit , enemy ) > 12 then
54636: LD_VAR 0 11
54640: PUSH
54641: LD_VAR 0 11
54645: PPUSH
54646: LD_VAR 0 10
54650: PPUSH
54651: CALL_OW 296
54655: PUSH
54656: LD_INT 13
54658: GREATER
54659: AND
54660: PUSH
54661: LD_VAR 0 1
54665: PPUSH
54666: LD_VAR 0 10
54670: PPUSH
54671: CALL_OW 296
54675: PUSH
54676: LD_INT 12
54678: GREATER
54679: OR
54680: IFFALSE 54684
// exit ;
54682: GO 55037
// missile := [ 1 ] ;
54684: LD_ADDR_VAR 0 14
54688: PUSH
54689: LD_INT 1
54691: PUSH
54692: EMPTY
54693: LIST
54694: ST_TO_ADDR
// if Researched ( side , tech_space ) then
54695: LD_VAR 0 9
54699: PPUSH
54700: LD_VAR 0 12
54704: PPUSH
54705: CALL_OW 325
54709: IFFALSE 54738
// missile := Replace ( missile , missile + 1 , 2 ) ;
54711: LD_ADDR_VAR 0 14
54715: PUSH
54716: LD_VAR 0 14
54720: PPUSH
54721: LD_VAR 0 14
54725: PUSH
54726: LD_INT 1
54728: PLUS
54729: PPUSH
54730: LD_INT 2
54732: PPUSH
54733: CALL_OW 1
54737: ST_TO_ADDR
// if Researched ( side , tech_time ) and not Researched ( GetSide ( enemy ) , tech_time ) then
54738: LD_VAR 0 9
54742: PPUSH
54743: LD_VAR 0 13
54747: PPUSH
54748: CALL_OW 325
54752: PUSH
54753: LD_VAR 0 10
54757: PPUSH
54758: CALL_OW 255
54762: PPUSH
54763: LD_VAR 0 13
54767: PPUSH
54768: CALL_OW 325
54772: NOT
54773: AND
54774: IFFALSE 54803
// missile := Replace ( missile , missile + 1 , 3 ) ;
54776: LD_ADDR_VAR 0 14
54780: PUSH
54781: LD_VAR 0 14
54785: PPUSH
54786: LD_VAR 0 14
54790: PUSH
54791: LD_INT 1
54793: PLUS
54794: PPUSH
54795: LD_INT 3
54797: PPUSH
54798: CALL_OW 1
54802: ST_TO_ADDR
// if missile < 2 then
54803: LD_VAR 0 14
54807: PUSH
54808: LD_INT 2
54810: LESS
54811: IFFALSE 54815
// exit ;
54813: GO 55037
// x := GetX ( enemy ) ;
54815: LD_ADDR_VAR 0 4
54819: PUSH
54820: LD_VAR 0 10
54824: PPUSH
54825: CALL_OW 250
54829: ST_TO_ADDR
// y := GetY ( enemy ) ;
54830: LD_ADDR_VAR 0 5
54834: PUSH
54835: LD_VAR 0 10
54839: PPUSH
54840: CALL_OW 251
54844: ST_TO_ADDR
// _x := x + rand ( - 1 , 1 ) ;
54845: LD_ADDR_VAR 0 6
54849: PUSH
54850: LD_VAR 0 4
54854: PUSH
54855: LD_INT 1
54857: NEG
54858: PPUSH
54859: LD_INT 1
54861: PPUSH
54862: CALL_OW 12
54866: PLUS
54867: ST_TO_ADDR
// _y := y + rand ( - 1 , 1 ) ;
54868: LD_ADDR_VAR 0 7
54872: PUSH
54873: LD_VAR 0 5
54877: PUSH
54878: LD_INT 1
54880: NEG
54881: PPUSH
54882: LD_INT 1
54884: PPUSH
54885: CALL_OW 12
54889: PLUS
54890: ST_TO_ADDR
// if not ValidHex ( _x , _y ) then
54891: LD_VAR 0 6
54895: PPUSH
54896: LD_VAR 0 7
54900: PPUSH
54901: CALL_OW 488
54905: NOT
54906: IFFALSE 54928
// begin _x := x ;
54908: LD_ADDR_VAR 0 6
54912: PUSH
54913: LD_VAR 0 4
54917: ST_TO_ADDR
// _y := y ;
54918: LD_ADDR_VAR 0 7
54922: PUSH
54923: LD_VAR 0 5
54927: ST_TO_ADDR
// end ; i := rand ( 1 , missile ) ;
54928: LD_ADDR_VAR 0 3
54932: PUSH
54933: LD_INT 1
54935: PPUSH
54936: LD_VAR 0 14
54940: PPUSH
54941: CALL_OW 12
54945: ST_TO_ADDR
// case i of 1 :
54946: LD_VAR 0 3
54950: PUSH
54951: LD_INT 1
54953: DOUBLE
54954: EQUAL
54955: IFTRUE 54959
54957: GO 54976
54959: POP
// ComAttackUnit ( unit , enemy ) ; 2 :
54960: LD_VAR 0 1
54964: PPUSH
54965: LD_VAR 0 10
54969: PPUSH
54970: CALL_OW 115
54974: GO 55037
54976: LD_INT 2
54978: DOUBLE
54979: EQUAL
54980: IFTRUE 54984
54982: GO 55006
54984: POP
// ComSpaceShift ( unit , _x , _y ) ; 3 :
54985: LD_VAR 0 1
54989: PPUSH
54990: LD_VAR 0 6
54994: PPUSH
54995: LD_VAR 0 7
54999: PPUSH
55000: CALL_OW 153
55004: GO 55037
55006: LD_INT 3
55008: DOUBLE
55009: EQUAL
55010: IFTRUE 55014
55012: GO 55036
55014: POP
// ComTimeShift ( unit , _x , _y ) ; end ;
55015: LD_VAR 0 1
55019: PPUSH
55020: LD_VAR 0 6
55024: PPUSH
55025: LD_VAR 0 7
55029: PPUSH
55030: CALL_OW 154
55034: GO 55037
55036: POP
// end ;
55037: LD_VAR 0 2
55041: RET
// export function ComStandNearbyBuilding ( unit , building ) ; var i , x , y , _x , _y ; begin
55042: LD_INT 0
55044: PPUSH
55045: PPUSH
55046: PPUSH
55047: PPUSH
55048: PPUSH
55049: PPUSH
// if not unit or not building then
55050: LD_VAR 0 1
55054: NOT
55055: PUSH
55056: LD_VAR 0 2
55060: NOT
55061: OR
55062: IFFALSE 55066
// exit ;
55064: GO 55224
// x := GetX ( building ) ;
55066: LD_ADDR_VAR 0 5
55070: PUSH
55071: LD_VAR 0 2
55075: PPUSH
55076: CALL_OW 250
55080: ST_TO_ADDR
// y := GetY ( building ) ;
55081: LD_ADDR_VAR 0 6
55085: PUSH
55086: LD_VAR 0 2
55090: PPUSH
55091: CALL_OW 251
55095: ST_TO_ADDR
// for i = 0 to 5 do
55096: LD_ADDR_VAR 0 4
55100: PUSH
55101: DOUBLE
55102: LD_INT 0
55104: DEC
55105: ST_TO_ADDR
55106: LD_INT 5
55108: PUSH
55109: FOR_TO
55110: IFFALSE 55222
// begin _x := ShiftX ( x , i , 3 ) ;
55112: LD_ADDR_VAR 0 7
55116: PUSH
55117: LD_VAR 0 5
55121: PPUSH
55122: LD_VAR 0 4
55126: PPUSH
55127: LD_INT 3
55129: PPUSH
55130: CALL_OW 272
55134: ST_TO_ADDR
// _y := ShiftY ( y , i , 3 ) ;
55135: LD_ADDR_VAR 0 8
55139: PUSH
55140: LD_VAR 0 6
55144: PPUSH
55145: LD_VAR 0 4
55149: PPUSH
55150: LD_INT 3
55152: PPUSH
55153: CALL_OW 273
55157: ST_TO_ADDR
// if not ValidHex ( _x , _y ) then
55158: LD_VAR 0 7
55162: PPUSH
55163: LD_VAR 0 8
55167: PPUSH
55168: CALL_OW 488
55172: NOT
55173: IFFALSE 55177
// continue ;
55175: GO 55109
// if HexInfo ( _x , _y ) = 0 then
55177: LD_VAR 0 7
55181: PPUSH
55182: LD_VAR 0 8
55186: PPUSH
55187: CALL_OW 428
55191: PUSH
55192: LD_INT 0
55194: EQUAL
55195: IFFALSE 55220
// begin ComMoveXY ( unit , _x , _y ) ;
55197: LD_VAR 0 1
55201: PPUSH
55202: LD_VAR 0 7
55206: PPUSH
55207: LD_VAR 0 8
55211: PPUSH
55212: CALL_OW 111
// exit ;
55216: POP
55217: POP
55218: GO 55224
// end ; end ;
55220: GO 55109
55222: POP
55223: POP
// end ;
55224: LD_VAR 0 3
55228: RET
// export function ScanBase ( side , base_area ) ; begin
55229: LD_INT 0
55231: PPUSH
// result := FilterUnitsInArea ( base_area , [ f_enemy , side ] ) ;
55232: LD_ADDR_VAR 0 3
55236: PUSH
55237: LD_VAR 0 2
55241: PPUSH
55242: LD_INT 81
55244: PUSH
55245: LD_VAR 0 1
55249: PUSH
55250: EMPTY
55251: LIST
55252: LIST
55253: PPUSH
55254: CALL_OW 70
55258: ST_TO_ADDR
// end ;
55259: LD_VAR 0 3
55263: RET
// export function AllowSpecClass ( unit ) ; var side , nat , tech ; begin
55264: LD_INT 0
55266: PPUSH
55267: PPUSH
55268: PPUSH
55269: PPUSH
// result := false ;
55270: LD_ADDR_VAR 0 2
55274: PUSH
55275: LD_INT 0
55277: ST_TO_ADDR
// side := GetSide ( unit ) ;
55278: LD_ADDR_VAR 0 3
55282: PUSH
55283: LD_VAR 0 1
55287: PPUSH
55288: CALL_OW 255
55292: ST_TO_ADDR
// nat := GetNation ( unit ) ;
55293: LD_ADDR_VAR 0 4
55297: PUSH
55298: LD_VAR 0 1
55302: PPUSH
55303: CALL_OW 248
55307: ST_TO_ADDR
// case nat of 1 :
55308: LD_VAR 0 4
55312: PUSH
55313: LD_INT 1
55315: DOUBLE
55316: EQUAL
55317: IFTRUE 55321
55319: GO 55332
55321: POP
// tech := tech_lassight ; 2 :
55322: LD_ADDR_VAR 0 5
55326: PUSH
55327: LD_INT 12
55329: ST_TO_ADDR
55330: GO 55371
55332: LD_INT 2
55334: DOUBLE
55335: EQUAL
55336: IFTRUE 55340
55338: GO 55351
55340: POP
// tech := tech_mortar ; 3 :
55341: LD_ADDR_VAR 0 5
55345: PUSH
55346: LD_INT 41
55348: ST_TO_ADDR
55349: GO 55371
55351: LD_INT 3
55353: DOUBLE
55354: EQUAL
55355: IFTRUE 55359
55357: GO 55370
55359: POP
// tech := tech_bazooka ; end ;
55360: LD_ADDR_VAR 0 5
55364: PUSH
55365: LD_INT 44
55367: ST_TO_ADDR
55368: GO 55371
55370: POP
// if Researched ( side , tech ) then
55371: LD_VAR 0 3
55375: PPUSH
55376: LD_VAR 0 5
55380: PPUSH
55381: CALL_OW 325
55385: IFFALSE 55412
// result := [ class_sniper , class_mortar , class_bazooker ] [ nat ] ;
55387: LD_ADDR_VAR 0 2
55391: PUSH
55392: LD_INT 5
55394: PUSH
55395: LD_INT 8
55397: PUSH
55398: LD_INT 9
55400: PUSH
55401: EMPTY
55402: LIST
55403: LIST
55404: LIST
55405: PUSH
55406: LD_VAR 0 4
55410: ARRAY
55411: ST_TO_ADDR
// end ;
55412: LD_VAR 0 2
55416: RET
// export function DetonateMines ( side , mines ) ; var i , tmp ; begin
55417: LD_INT 0
55419: PPUSH
55420: PPUSH
55421: PPUSH
// if not mines then
55422: LD_VAR 0 2
55426: NOT
55427: IFFALSE 55431
// exit ;
55429: GO 55575
// tmp := FilterAllUnits ( [ [ f_enemy , side ] , [ f_not , [ f_type , unit_building ] ] ] ) ;
55431: LD_ADDR_VAR 0 5
55435: PUSH
55436: LD_INT 81
55438: PUSH
55439: LD_VAR 0 1
55443: PUSH
55444: EMPTY
55445: LIST
55446: LIST
55447: PUSH
55448: LD_INT 3
55450: PUSH
55451: LD_INT 21
55453: PUSH
55454: LD_INT 3
55456: PUSH
55457: EMPTY
55458: LIST
55459: LIST
55460: PUSH
55461: EMPTY
55462: LIST
55463: LIST
55464: PUSH
55465: EMPTY
55466: LIST
55467: LIST
55468: PPUSH
55469: CALL_OW 69
55473: ST_TO_ADDR
// for i in mines do
55474: LD_ADDR_VAR 0 4
55478: PUSH
55479: LD_VAR 0 2
55483: PUSH
55484: FOR_IN
55485: IFFALSE 55573
// begin if not MineAtPos ( i [ 1 ] , i [ 2 ] ) then
55487: LD_VAR 0 4
55491: PUSH
55492: LD_INT 1
55494: ARRAY
55495: PPUSH
55496: LD_VAR 0 4
55500: PUSH
55501: LD_INT 2
55503: ARRAY
55504: PPUSH
55505: CALL_OW 458
55509: NOT
55510: IFFALSE 55514
// continue ;
55512: GO 55484
// if HexInfo ( i [ 1 ] , i [ 2 ] ) in tmp then
55514: LD_VAR 0 4
55518: PUSH
55519: LD_INT 1
55521: ARRAY
55522: PPUSH
55523: LD_VAR 0 4
55527: PUSH
55528: LD_INT 2
55530: ARRAY
55531: PPUSH
55532: CALL_OW 428
55536: PUSH
55537: LD_VAR 0 5
55541: IN
55542: IFFALSE 55571
// LaunchMineAtPos ( i [ 1 ] , i [ 2 ] , side ) ;
55544: LD_VAR 0 4
55548: PUSH
55549: LD_INT 1
55551: ARRAY
55552: PPUSH
55553: LD_VAR 0 4
55557: PUSH
55558: LD_INT 2
55560: ARRAY
55561: PPUSH
55562: LD_VAR 0 1
55566: PPUSH
55567: CALL_OW 456
// end ;
55571: GO 55484
55573: POP
55574: POP
// end ;
55575: LD_VAR 0 3
55579: RET
// export function Count ( array ) ; begin
55580: LD_INT 0
55582: PPUSH
// result := array + 0 ;
55583: LD_ADDR_VAR 0 2
55587: PUSH
55588: LD_VAR 0 1
55592: PUSH
55593: LD_INT 0
55595: PLUS
55596: ST_TO_ADDR
// end ;
55597: LD_VAR 0 2
55601: RET
// export function IsEmpty ( building ) ; begin
55602: LD_INT 0
55604: PPUSH
// if not building then
55605: LD_VAR 0 1
55609: NOT
55610: IFFALSE 55614
// exit ;
55612: GO 55657
// result := building in FilterAllUnits ( [ [ f_side , GetSide ( building ) ] , [ f_empty ] ] ) ;
55614: LD_ADDR_VAR 0 2
55618: PUSH
55619: LD_VAR 0 1
55623: PUSH
55624: LD_INT 22
55626: PUSH
55627: LD_VAR 0 1
55631: PPUSH
55632: CALL_OW 255
55636: PUSH
55637: EMPTY
55638: LIST
55639: LIST
55640: PUSH
55641: LD_INT 58
55643: PUSH
55644: EMPTY
55645: LIST
55646: PUSH
55647: EMPTY
55648: LIST
55649: LIST
55650: PPUSH
55651: CALL_OW 69
55655: IN
55656: ST_TO_ADDR
// end ;
55657: LD_VAR 0 2
55661: RET
// export function IsNotFull ( building ) ; var places ; begin
55662: LD_INT 0
55664: PPUSH
55665: PPUSH
// if not building then
55666: LD_VAR 0 1
55670: NOT
55671: IFFALSE 55675
// exit ;
55673: GO 55703
// result := UnitFilter ( building , [ f_not , [ f_full ] ] ) ;
55675: LD_ADDR_VAR 0 2
55679: PUSH
55680: LD_VAR 0 1
55684: PPUSH
55685: LD_INT 3
55687: PUSH
55688: LD_INT 62
55690: PUSH
55691: EMPTY
55692: LIST
55693: PUSH
55694: EMPTY
55695: LIST
55696: LIST
55697: PPUSH
55698: CALL_OW 72
55702: ST_TO_ADDR
// end ;
55703: LD_VAR 0 2
55707: RET
// export function GetFacExt ( factory ) ; var tmp , i , list ; begin
55708: LD_INT 0
55710: PPUSH
55711: PPUSH
55712: PPUSH
55713: PPUSH
// tmp := [ ] ;
55714: LD_ADDR_VAR 0 3
55718: PUSH
55719: EMPTY
55720: ST_TO_ADDR
// list := [ ] ;
55721: LD_ADDR_VAR 0 5
55725: PUSH
55726: EMPTY
55727: ST_TO_ADDR
// for i = 16 to 25 do
55728: LD_ADDR_VAR 0 4
55732: PUSH
55733: DOUBLE
55734: LD_INT 16
55736: DEC
55737: ST_TO_ADDR
55738: LD_INT 25
55740: PUSH
55741: FOR_TO
55742: IFFALSE 55815
// tmp := tmp ^ FilterAllUnits ( [ [ [ f_side , GetSide ( factory ) ] , [ f_dist , factory , 6 ] , [ f_btype , i ] ] ] ) ;
55744: LD_ADDR_VAR 0 3
55748: PUSH
55749: LD_VAR 0 3
55753: PUSH
55754: LD_INT 22
55756: PUSH
55757: LD_VAR 0 1
55761: PPUSH
55762: CALL_OW 255
55766: PUSH
55767: EMPTY
55768: LIST
55769: LIST
55770: PUSH
55771: LD_INT 91
55773: PUSH
55774: LD_VAR 0 1
55778: PUSH
55779: LD_INT 6
55781: PUSH
55782: EMPTY
55783: LIST
55784: LIST
55785: LIST
55786: PUSH
55787: LD_INT 30
55789: PUSH
55790: LD_VAR 0 4
55794: PUSH
55795: EMPTY
55796: LIST
55797: LIST
55798: PUSH
55799: EMPTY
55800: LIST
55801: LIST
55802: LIST
55803: PUSH
55804: EMPTY
55805: LIST
55806: PPUSH
55807: CALL_OW 69
55811: ADD
55812: ST_TO_ADDR
55813: GO 55741
55815: POP
55816: POP
// for i = 1 to tmp do
55817: LD_ADDR_VAR 0 4
55821: PUSH
55822: DOUBLE
55823: LD_INT 1
55825: DEC
55826: ST_TO_ADDR
55827: LD_VAR 0 3
55831: PUSH
55832: FOR_TO
55833: IFFALSE 55921
// list := list ^ [ [ GetBType ( tmp [ i ] ) , GetX ( tmp [ i ] ) , GetY ( tmp [ i ] ) , GetDir ( tmp [ i ] ) ] ] ;
55835: LD_ADDR_VAR 0 5
55839: PUSH
55840: LD_VAR 0 5
55844: PUSH
55845: LD_VAR 0 3
55849: PUSH
55850: LD_VAR 0 4
55854: ARRAY
55855: PPUSH
55856: CALL_OW 266
55860: PUSH
55861: LD_VAR 0 3
55865: PUSH
55866: LD_VAR 0 4
55870: ARRAY
55871: PPUSH
55872: CALL_OW 250
55876: PUSH
55877: LD_VAR 0 3
55881: PUSH
55882: LD_VAR 0 4
55886: ARRAY
55887: PPUSH
55888: CALL_OW 251
55892: PUSH
55893: LD_VAR 0 3
55897: PUSH
55898: LD_VAR 0 4
55902: ARRAY
55903: PPUSH
55904: CALL_OW 254
55908: PUSH
55909: EMPTY
55910: LIST
55911: LIST
55912: LIST
55913: LIST
55914: PUSH
55915: EMPTY
55916: LIST
55917: ADD
55918: ST_TO_ADDR
55919: GO 55832
55921: POP
55922: POP
// result := list ;
55923: LD_ADDR_VAR 0 2
55927: PUSH
55928: LD_VAR 0 5
55932: ST_TO_ADDR
// end ;
55933: LD_VAR 0 2
55937: RET
// export function Produce ( factory , chassis , engine , control , weapon ) ; var i , tmp , _chassis , _weapon , _engine , _control ; begin
55938: LD_INT 0
55940: PPUSH
55941: PPUSH
55942: PPUSH
55943: PPUSH
55944: PPUSH
55945: PPUSH
55946: PPUSH
// if not factory then
55947: LD_VAR 0 1
55951: NOT
55952: IFFALSE 55956
// exit ;
55954: GO 56549
// if control = control_apeman then
55956: LD_VAR 0 4
55960: PUSH
55961: LD_INT 5
55963: EQUAL
55964: IFFALSE 56073
// begin tmp := UnitsInside ( factory ) ;
55966: LD_ADDR_VAR 0 8
55970: PUSH
55971: LD_VAR 0 1
55975: PPUSH
55976: CALL_OW 313
55980: ST_TO_ADDR
// if not UnitFilter ( tmp , [ f_class , class_apeman ] ) then
55981: LD_VAR 0 8
55985: PPUSH
55986: LD_INT 25
55988: PUSH
55989: LD_INT 12
55991: PUSH
55992: EMPTY
55993: LIST
55994: LIST
55995: PPUSH
55996: CALL_OW 72
56000: NOT
56001: IFFALSE 56011
// control := control_manual ;
56003: LD_ADDR_VAR 0 4
56007: PUSH
56008: LD_INT 1
56010: ST_TO_ADDR
// tmp := GetFacExt ( factory ) ;
56011: LD_ADDR_VAR 0 8
56015: PUSH
56016: LD_VAR 0 1
56020: PPUSH
56021: CALL 55708 0 1
56025: ST_TO_ADDR
// if tmp then
56026: LD_VAR 0 8
56030: IFFALSE 56073
// begin for i in tmp do
56032: LD_ADDR_VAR 0 7
56036: PUSH
56037: LD_VAR 0 8
56041: PUSH
56042: FOR_IN
56043: IFFALSE 56071
// if i [ 1 ] = b_ext_radio then
56045: LD_VAR 0 7
56049: PUSH
56050: LD_INT 1
56052: ARRAY
56053: PUSH
56054: LD_INT 22
56056: EQUAL
56057: IFFALSE 56069
// begin control := control_remote ;
56059: LD_ADDR_VAR 0 4
56063: PUSH
56064: LD_INT 2
56066: ST_TO_ADDR
// break ;
56067: GO 56071
// end ;
56069: GO 56042
56071: POP
56072: POP
// end ; end ; if CanBeConstructed ( factory , chassis , engine , control , weapon ) then
56073: LD_VAR 0 1
56077: PPUSH
56078: LD_VAR 0 2
56082: PPUSH
56083: LD_VAR 0 3
56087: PPUSH
56088: LD_VAR 0 4
56092: PPUSH
56093: LD_VAR 0 5
56097: PPUSH
56098: CALL_OW 448
56102: IFFALSE 56137
// begin result := [ chassis , engine , control , weapon ] ;
56104: LD_ADDR_VAR 0 6
56108: PUSH
56109: LD_VAR 0 2
56113: PUSH
56114: LD_VAR 0 3
56118: PUSH
56119: LD_VAR 0 4
56123: PUSH
56124: LD_VAR 0 5
56128: PUSH
56129: EMPTY
56130: LIST
56131: LIST
56132: LIST
56133: LIST
56134: ST_TO_ADDR
// exit ;
56135: GO 56549
// end ; _chassis := AvailableChassisList ( factory ) ;
56137: LD_ADDR_VAR 0 9
56141: PUSH
56142: LD_VAR 0 1
56146: PPUSH
56147: CALL_OW 475
56151: ST_TO_ADDR
// _engine := AvailableEngineList ( factory ) ;
56152: LD_ADDR_VAR 0 11
56156: PUSH
56157: LD_VAR 0 1
56161: PPUSH
56162: CALL_OW 476
56166: ST_TO_ADDR
// _control := AvailableControlList ( factory ) ;
56167: LD_ADDR_VAR 0 12
56171: PUSH
56172: LD_VAR 0 1
56176: PPUSH
56177: CALL_OW 477
56181: ST_TO_ADDR
// _weapon := AvailableWeaponList ( factory ) ;
56182: LD_ADDR_VAR 0 10
56186: PUSH
56187: LD_VAR 0 1
56191: PPUSH
56192: CALL_OW 478
56196: ST_TO_ADDR
// if not _chassis or not _engine or not _control or not _weapon then
56197: LD_VAR 0 9
56201: NOT
56202: PUSH
56203: LD_VAR 0 11
56207: NOT
56208: OR
56209: PUSH
56210: LD_VAR 0 12
56214: NOT
56215: OR
56216: PUSH
56217: LD_VAR 0 10
56221: NOT
56222: OR
56223: IFFALSE 56258
// begin result := [ chassis , engine , control , weapon ] ;
56225: LD_ADDR_VAR 0 6
56229: PUSH
56230: LD_VAR 0 2
56234: PUSH
56235: LD_VAR 0 3
56239: PUSH
56240: LD_VAR 0 4
56244: PUSH
56245: LD_VAR 0 5
56249: PUSH
56250: EMPTY
56251: LIST
56252: LIST
56253: LIST
56254: LIST
56255: ST_TO_ADDR
// exit ;
56256: GO 56549
// end ; if not chassis in _chassis then
56258: LD_VAR 0 2
56262: PUSH
56263: LD_VAR 0 9
56267: IN
56268: NOT
56269: IFFALSE 56295
// chassis := _chassis [ rand ( 1 , _chassis ) ] ;
56271: LD_ADDR_VAR 0 2
56275: PUSH
56276: LD_VAR 0 9
56280: PUSH
56281: LD_INT 1
56283: PPUSH
56284: LD_VAR 0 9
56288: PPUSH
56289: CALL_OW 12
56293: ARRAY
56294: ST_TO_ADDR
// if not EngineCanBeMount ( chassis , engine ) then
56295: LD_VAR 0 2
56299: PPUSH
56300: LD_VAR 0 3
56304: PPUSH
56305: CALL 56554 0 2
56309: NOT
56310: IFFALSE 56369
// repeat engine := _engine [ 1 ] ;
56312: LD_ADDR_VAR 0 3
56316: PUSH
56317: LD_VAR 0 11
56321: PUSH
56322: LD_INT 1
56324: ARRAY
56325: ST_TO_ADDR
// _engine := Delete ( _engine , 1 ) ;
56326: LD_ADDR_VAR 0 11
56330: PUSH
56331: LD_VAR 0 11
56335: PPUSH
56336: LD_INT 1
56338: PPUSH
56339: CALL_OW 3
56343: ST_TO_ADDR
// until EngineCanBeMount ( chassis , engine ) or _engine = [ ] ;
56344: LD_VAR 0 2
56348: PPUSH
56349: LD_VAR 0 3
56353: PPUSH
56354: CALL 56554 0 2
56358: PUSH
56359: LD_VAR 0 11
56363: PUSH
56364: EMPTY
56365: EQUAL
56366: OR
56367: IFFALSE 56312
// if not control in _control then
56369: LD_VAR 0 4
56373: PUSH
56374: LD_VAR 0 12
56378: IN
56379: NOT
56380: IFFALSE 56406
// control := _control [ rand ( 1 , _control ) ] ;
56382: LD_ADDR_VAR 0 4
56386: PUSH
56387: LD_VAR 0 12
56391: PUSH
56392: LD_INT 1
56394: PPUSH
56395: LD_VAR 0 12
56399: PPUSH
56400: CALL_OW 12
56404: ARRAY
56405: ST_TO_ADDR
// if not WeaponCanBeMount ( chassis , weapon ) then
56406: LD_VAR 0 2
56410: PPUSH
56411: LD_VAR 0 5
56415: PPUSH
56416: CALL 56774 0 2
56420: NOT
56421: IFFALSE 56480
// repeat weapon := _weapon [ 1 ] ;
56423: LD_ADDR_VAR 0 5
56427: PUSH
56428: LD_VAR 0 10
56432: PUSH
56433: LD_INT 1
56435: ARRAY
56436: ST_TO_ADDR
// _weapon := Delete ( _weapon , 1 ) ;
56437: LD_ADDR_VAR 0 10
56441: PUSH
56442: LD_VAR 0 10
56446: PPUSH
56447: LD_INT 1
56449: PPUSH
56450: CALL_OW 3
56454: ST_TO_ADDR
// until WeaponCanBeMount ( chassis , weapon ) or _weapon = [ ] ;
56455: LD_VAR 0 2
56459: PPUSH
56460: LD_VAR 0 5
56464: PPUSH
56465: CALL 56774 0 2
56469: PUSH
56470: LD_VAR 0 10
56474: PUSH
56475: EMPTY
56476: EQUAL
56477: OR
56478: IFFALSE 56423
// result := [ ] ;
56480: LD_ADDR_VAR 0 6
56484: PUSH
56485: EMPTY
56486: ST_TO_ADDR
// if CanBeConstructed ( factory , chassis , engine , control , weapon ) then
56487: LD_VAR 0 1
56491: PPUSH
56492: LD_VAR 0 2
56496: PPUSH
56497: LD_VAR 0 3
56501: PPUSH
56502: LD_VAR 0 4
56506: PPUSH
56507: LD_VAR 0 5
56511: PPUSH
56512: CALL_OW 448
56516: IFFALSE 56549
// result := [ chassis , engine , control , weapon ] ;
56518: LD_ADDR_VAR 0 6
56522: PUSH
56523: LD_VAR 0 2
56527: PUSH
56528: LD_VAR 0 3
56532: PUSH
56533: LD_VAR 0 4
56537: PUSH
56538: LD_VAR 0 5
56542: PUSH
56543: EMPTY
56544: LIST
56545: LIST
56546: LIST
56547: LIST
56548: ST_TO_ADDR
// end ;
56549: LD_VAR 0 6
56553: RET
// export function EngineCanBeMount ( chassis , engine ) ; begin
56554: LD_INT 0
56556: PPUSH
// if not chassis or not engine then
56557: LD_VAR 0 1
56561: NOT
56562: PUSH
56563: LD_VAR 0 2
56567: NOT
56568: OR
56569: IFFALSE 56573
// exit ;
56571: GO 56769
// case engine of engine_solar :
56573: LD_VAR 0 2
56577: PUSH
56578: LD_INT 2
56580: DOUBLE
56581: EQUAL
56582: IFTRUE 56586
56584: GO 56624
56586: POP
// result := [ ar_hovercraft , ar_light_trike , ar_medium_trike , ar_half_tracked , us_light_wheeled , us_medium_wheeled , us_medium_tracked ] ; engine_combustion :
56587: LD_ADDR_VAR 0 3
56591: PUSH
56592: LD_INT 11
56594: PUSH
56595: LD_INT 12
56597: PUSH
56598: LD_INT 13
56600: PUSH
56601: LD_INT 14
56603: PUSH
56604: LD_INT 1
56606: PUSH
56607: LD_INT 2
56609: PUSH
56610: LD_INT 3
56612: PUSH
56613: EMPTY
56614: LIST
56615: LIST
56616: LIST
56617: LIST
56618: LIST
56619: LIST
56620: LIST
56621: ST_TO_ADDR
56622: GO 56753
56624: LD_INT 1
56626: DOUBLE
56627: EQUAL
56628: IFTRUE 56632
56630: GO 56694
56632: POP
// result := [ ar_hovercraft , ar_light_trike , ar_medium_trike , ar_half_tracked , us_light_wheeled , us_medium_wheeled , us_medium_tracked , us_heavy_tracked , us_morphling , ru_medium_wheeled , ru_heavy_wheeled , ru_medium_tracked , ru_heavy_tracked ] ; engine_siberite :
56633: LD_ADDR_VAR 0 3
56637: PUSH
56638: LD_INT 11
56640: PUSH
56641: LD_INT 12
56643: PUSH
56644: LD_INT 13
56646: PUSH
56647: LD_INT 14
56649: PUSH
56650: LD_INT 1
56652: PUSH
56653: LD_INT 2
56655: PUSH
56656: LD_INT 3
56658: PUSH
56659: LD_INT 4
56661: PUSH
56662: LD_INT 5
56664: PUSH
56665: LD_INT 21
56667: PUSH
56668: LD_INT 23
56670: PUSH
56671: LD_INT 22
56673: PUSH
56674: LD_INT 24
56676: PUSH
56677: EMPTY
56678: LIST
56679: LIST
56680: LIST
56681: LIST
56682: LIST
56683: LIST
56684: LIST
56685: LIST
56686: LIST
56687: LIST
56688: LIST
56689: LIST
56690: LIST
56691: ST_TO_ADDR
56692: GO 56753
56694: LD_INT 3
56696: DOUBLE
56697: EQUAL
56698: IFTRUE 56702
56700: GO 56752
56702: POP
// result := [ ar_medium_trike , ar_half_tracked , us_medium_wheeled , us_medium_tracked , us_heavy_tracked , us_morphling , ru_medium_wheeled , ru_medium_tracked , ru_heavy_wheeled , ru_heavy_tracked ] ; end ;
56703: LD_ADDR_VAR 0 3
56707: PUSH
56708: LD_INT 13
56710: PUSH
56711: LD_INT 14
56713: PUSH
56714: LD_INT 2
56716: PUSH
56717: LD_INT 3
56719: PUSH
56720: LD_INT 4
56722: PUSH
56723: LD_INT 5
56725: PUSH
56726: LD_INT 21
56728: PUSH
56729: LD_INT 22
56731: PUSH
56732: LD_INT 23
56734: PUSH
56735: LD_INT 24
56737: PUSH
56738: EMPTY
56739: LIST
56740: LIST
56741: LIST
56742: LIST
56743: LIST
56744: LIST
56745: LIST
56746: LIST
56747: LIST
56748: LIST
56749: ST_TO_ADDR
56750: GO 56753
56752: POP
// result := ( chassis in result ) ;
56753: LD_ADDR_VAR 0 3
56757: PUSH
56758: LD_VAR 0 1
56762: PUSH
56763: LD_VAR 0 3
56767: IN
56768: ST_TO_ADDR
// end ;
56769: LD_VAR 0 3
56773: RET
// export function WeaponCanBeMount ( chassis , weapon ) ; begin
56774: LD_INT 0
56776: PPUSH
// if not chassis or not weapon then
56777: LD_VAR 0 1
56781: NOT
56782: PUSH
56783: LD_VAR 0 2
56787: NOT
56788: OR
56789: IFFALSE 56793
// exit ;
56791: GO 57853
// case weapon of us_machine_gun :
56793: LD_VAR 0 2
56797: PUSH
56798: LD_INT 2
56800: DOUBLE
56801: EQUAL
56802: IFTRUE 56806
56804: GO 56836
56806: POP
// result := [ us_light_wheeled , us_medium_wheeled , us_medium_tracked , us_heavy_tracked , us_morphling ] ; us_light_gun :
56807: LD_ADDR_VAR 0 3
56811: PUSH
56812: LD_INT 1
56814: PUSH
56815: LD_INT 2
56817: PUSH
56818: LD_INT 3
56820: PUSH
56821: LD_INT 4
56823: PUSH
56824: LD_INT 5
56826: PUSH
56827: EMPTY
56828: LIST
56829: LIST
56830: LIST
56831: LIST
56832: LIST
56833: ST_TO_ADDR
56834: GO 57837
56836: LD_INT 3
56838: DOUBLE
56839: EQUAL
56840: IFTRUE 56844
56842: GO 56874
56844: POP
// result := [ us_light_wheeled , us_medium_wheeled , us_medium_tracked , us_heavy_tracked , us_morphling ] ; us_radar :
56845: LD_ADDR_VAR 0 3
56849: PUSH
56850: LD_INT 1
56852: PUSH
56853: LD_INT 2
56855: PUSH
56856: LD_INT 3
56858: PUSH
56859: LD_INT 4
56861: PUSH
56862: LD_INT 5
56864: PUSH
56865: EMPTY
56866: LIST
56867: LIST
56868: LIST
56869: LIST
56870: LIST
56871: ST_TO_ADDR
56872: GO 57837
56874: LD_INT 11
56876: DOUBLE
56877: EQUAL
56878: IFTRUE 56882
56880: GO 56912
56882: POP
// result := [ us_light_wheeled , us_medium_wheeled , us_medium_tracked , us_heavy_tracked , us_morphling ] ; us_gatling_gun :
56883: LD_ADDR_VAR 0 3
56887: PUSH
56888: LD_INT 1
56890: PUSH
56891: LD_INT 2
56893: PUSH
56894: LD_INT 3
56896: PUSH
56897: LD_INT 4
56899: PUSH
56900: LD_INT 5
56902: PUSH
56903: EMPTY
56904: LIST
56905: LIST
56906: LIST
56907: LIST
56908: LIST
56909: ST_TO_ADDR
56910: GO 57837
56912: LD_INT 4
56914: DOUBLE
56915: EQUAL
56916: IFTRUE 56920
56918: GO 56946
56920: POP
// result := [ us_medium_wheeled , us_medium_tracked , us_heavy_tracked , us_morphling ] ; us_double_gun :
56921: LD_ADDR_VAR 0 3
56925: PUSH
56926: LD_INT 2
56928: PUSH
56929: LD_INT 3
56931: PUSH
56932: LD_INT 4
56934: PUSH
56935: LD_INT 5
56937: PUSH
56938: EMPTY
56939: LIST
56940: LIST
56941: LIST
56942: LIST
56943: ST_TO_ADDR
56944: GO 57837
56946: LD_INT 5
56948: DOUBLE
56949: EQUAL
56950: IFTRUE 56954
56952: GO 56980
56954: POP
// result := [ us_medium_wheeled , us_medium_tracked , us_heavy_tracked , us_morphling ] ; us_laser :
56955: LD_ADDR_VAR 0 3
56959: PUSH
56960: LD_INT 2
56962: PUSH
56963: LD_INT 3
56965: PUSH
56966: LD_INT 4
56968: PUSH
56969: LD_INT 5
56971: PUSH
56972: EMPTY
56973: LIST
56974: LIST
56975: LIST
56976: LIST
56977: ST_TO_ADDR
56978: GO 57837
56980: LD_INT 9
56982: DOUBLE
56983: EQUAL
56984: IFTRUE 56988
56986: GO 57014
56988: POP
// result := [ us_medium_wheeled , us_medium_tracked , us_heavy_tracked , us_morphling ] ; us_rocket_launcher :
56989: LD_ADDR_VAR 0 3
56993: PUSH
56994: LD_INT 2
56996: PUSH
56997: LD_INT 3
56999: PUSH
57000: LD_INT 4
57002: PUSH
57003: LD_INT 5
57005: PUSH
57006: EMPTY
57007: LIST
57008: LIST
57009: LIST
57010: LIST
57011: ST_TO_ADDR
57012: GO 57837
57014: LD_INT 7
57016: DOUBLE
57017: EQUAL
57018: IFTRUE 57022
57020: GO 57048
57022: POP
// result := [ us_medium_wheeled , us_medium_tracked , us_heavy_tracked , us_morphling ] ; us_cargo_bay :
57023: LD_ADDR_VAR 0 3
57027: PUSH
57028: LD_INT 2
57030: PUSH
57031: LD_INT 3
57033: PUSH
57034: LD_INT 4
57036: PUSH
57037: LD_INT 5
57039: PUSH
57040: EMPTY
57041: LIST
57042: LIST
57043: LIST
57044: LIST
57045: ST_TO_ADDR
57046: GO 57837
57048: LD_INT 12
57050: DOUBLE
57051: EQUAL
57052: IFTRUE 57056
57054: GO 57082
57056: POP
// result := [ us_medium_wheeled , us_medium_tracked , us_heavy_tracked , us_morphling ] ; us_crane :
57057: LD_ADDR_VAR 0 3
57061: PUSH
57062: LD_INT 2
57064: PUSH
57065: LD_INT 3
57067: PUSH
57068: LD_INT 4
57070: PUSH
57071: LD_INT 5
57073: PUSH
57074: EMPTY
57075: LIST
57076: LIST
57077: LIST
57078: LIST
57079: ST_TO_ADDR
57080: GO 57837
57082: LD_INT 13
57084: DOUBLE
57085: EQUAL
57086: IFTRUE 57090
57088: GO 57116
57090: POP
// result := [ us_medium_wheeled , us_medium_tracked , us_heavy_tracked , us_morphling ] ; us_bulldozer :
57091: LD_ADDR_VAR 0 3
57095: PUSH
57096: LD_INT 2
57098: PUSH
57099: LD_INT 3
57101: PUSH
57102: LD_INT 4
57104: PUSH
57105: LD_INT 5
57107: PUSH
57108: EMPTY
57109: LIST
57110: LIST
57111: LIST
57112: LIST
57113: ST_TO_ADDR
57114: GO 57837
57116: LD_INT 14
57118: DOUBLE
57119: EQUAL
57120: IFTRUE 57124
57122: GO 57142
57124: POP
// result := [ us_heavy_tracked , us_morphling ] ; us_heavy_gun :
57125: LD_ADDR_VAR 0 3
57129: PUSH
57130: LD_INT 4
57132: PUSH
57133: LD_INT 5
57135: PUSH
57136: EMPTY
57137: LIST
57138: LIST
57139: ST_TO_ADDR
57140: GO 57837
57142: LD_INT 6
57144: DOUBLE
57145: EQUAL
57146: IFTRUE 57150
57148: GO 57168
57150: POP
// result := [ us_heavy_tracked , us_morphling ] ; us_double_laser :
57151: LD_ADDR_VAR 0 3
57155: PUSH
57156: LD_INT 4
57158: PUSH
57159: LD_INT 5
57161: PUSH
57162: EMPTY
57163: LIST
57164: LIST
57165: ST_TO_ADDR
57166: GO 57837
57168: LD_INT 10
57170: DOUBLE
57171: EQUAL
57172: IFTRUE 57176
57174: GO 57194
57176: POP
// result := [ us_heavy_tracked , us_morphling ] ; ar_multimissile_ballista :
57177: LD_ADDR_VAR 0 3
57181: PUSH
57182: LD_INT 4
57184: PUSH
57185: LD_INT 5
57187: PUSH
57188: EMPTY
57189: LIST
57190: LIST
57191: ST_TO_ADDR
57192: GO 57837
57194: LD_INT 22
57196: DOUBLE
57197: EQUAL
57198: IFTRUE 57202
57200: GO 57228
57202: POP
// result := [ ar_hovercraft , ar_light_trike , ar_medium_trike , ar_half_tracked ] ; ar_light_gun :
57203: LD_ADDR_VAR 0 3
57207: PUSH
57208: LD_INT 11
57210: PUSH
57211: LD_INT 12
57213: PUSH
57214: LD_INT 13
57216: PUSH
57217: LD_INT 14
57219: PUSH
57220: EMPTY
57221: LIST
57222: LIST
57223: LIST
57224: LIST
57225: ST_TO_ADDR
57226: GO 57837
57228: LD_INT 23
57230: DOUBLE
57231: EQUAL
57232: IFTRUE 57236
57234: GO 57262
57236: POP
// result := [ ar_hovercraft , ar_light_trike , ar_medium_trike , ar_half_tracked ] ; ar_double_machine_gun :
57237: LD_ADDR_VAR 0 3
57241: PUSH
57242: LD_INT 11
57244: PUSH
57245: LD_INT 12
57247: PUSH
57248: LD_INT 13
57250: PUSH
57251: LD_INT 14
57253: PUSH
57254: EMPTY
57255: LIST
57256: LIST
57257: LIST
57258: LIST
57259: ST_TO_ADDR
57260: GO 57837
57262: LD_INT 24
57264: DOUBLE
57265: EQUAL
57266: IFTRUE 57270
57268: GO 57296
57270: POP
// result := [ ar_hovercraft , ar_light_trike , ar_medium_trike , ar_half_tracked ] ; ar_radar :
57271: LD_ADDR_VAR 0 3
57275: PUSH
57276: LD_INT 11
57278: PUSH
57279: LD_INT 12
57281: PUSH
57282: LD_INT 13
57284: PUSH
57285: LD_INT 14
57287: PUSH
57288: EMPTY
57289: LIST
57290: LIST
57291: LIST
57292: LIST
57293: ST_TO_ADDR
57294: GO 57837
57296: LD_INT 30
57298: DOUBLE
57299: EQUAL
57300: IFTRUE 57304
57302: GO 57330
57304: POP
// result := [ ar_hovercraft , ar_light_trike , ar_medium_trike , ar_half_tracked ] ; ar_gatling_gun :
57305: LD_ADDR_VAR 0 3
57309: PUSH
57310: LD_INT 11
57312: PUSH
57313: LD_INT 12
57315: PUSH
57316: LD_INT 13
57318: PUSH
57319: LD_INT 14
57321: PUSH
57322: EMPTY
57323: LIST
57324: LIST
57325: LIST
57326: LIST
57327: ST_TO_ADDR
57328: GO 57837
57330: LD_INT 25
57332: DOUBLE
57333: EQUAL
57334: IFTRUE 57338
57336: GO 57356
57338: POP
// result := [ ar_medium_trike , ar_half_tracked ] ; ar_gun :
57339: LD_ADDR_VAR 0 3
57343: PUSH
57344: LD_INT 13
57346: PUSH
57347: LD_INT 14
57349: PUSH
57350: EMPTY
57351: LIST
57352: LIST
57353: ST_TO_ADDR
57354: GO 57837
57356: LD_INT 27
57358: DOUBLE
57359: EQUAL
57360: IFTRUE 57364
57362: GO 57382
57364: POP
// result := [ ar_medium_trike , ar_half_tracked ] ; ar_mortar :
57365: LD_ADDR_VAR 0 3
57369: PUSH
57370: LD_INT 13
57372: PUSH
57373: LD_INT 14
57375: PUSH
57376: EMPTY
57377: LIST
57378: LIST
57379: ST_TO_ADDR
57380: GO 57837
57382: LD_INT 92
57384: DOUBLE
57385: EQUAL
57386: IFTRUE 57390
57388: GO 57416
57390: POP
// result := [ ar_hovercraft , ar_light_trike , ar_medium_trike , ar_half_tracked ] ; ar_rocket_launcher :
57391: LD_ADDR_VAR 0 3
57395: PUSH
57396: LD_INT 11
57398: PUSH
57399: LD_INT 12
57401: PUSH
57402: LD_INT 13
57404: PUSH
57405: LD_INT 14
57407: PUSH
57408: EMPTY
57409: LIST
57410: LIST
57411: LIST
57412: LIST
57413: ST_TO_ADDR
57414: GO 57837
57416: LD_INT 28
57418: DOUBLE
57419: EQUAL
57420: IFTRUE 57424
57422: GO 57442
57424: POP
// result := [ ar_medium_trike , ar_half_tracked ] ; ar_selfpropelled_bomb :
57425: LD_ADDR_VAR 0 3
57429: PUSH
57430: LD_INT 13
57432: PUSH
57433: LD_INT 14
57435: PUSH
57436: EMPTY
57437: LIST
57438: LIST
57439: ST_TO_ADDR
57440: GO 57837
57442: LD_INT 29
57444: DOUBLE
57445: EQUAL
57446: IFTRUE 57450
57448: GO 57468
57450: POP
// result := [ ar_medium_trike , ar_half_tracked ] ; ar_control_tower :
57451: LD_ADDR_VAR 0 3
57455: PUSH
57456: LD_INT 13
57458: PUSH
57459: LD_INT 14
57461: PUSH
57462: EMPTY
57463: LIST
57464: LIST
57465: ST_TO_ADDR
57466: GO 57837
57468: LD_INT 31
57470: DOUBLE
57471: EQUAL
57472: IFTRUE 57476
57474: GO 57494
57476: POP
// result := [ ar_medium_trike , ar_half_tracked ] ; ar_flame_thrower :
57477: LD_ADDR_VAR 0 3
57481: PUSH
57482: LD_INT 13
57484: PUSH
57485: LD_INT 14
57487: PUSH
57488: EMPTY
57489: LIST
57490: LIST
57491: ST_TO_ADDR
57492: GO 57837
57494: LD_INT 26
57496: DOUBLE
57497: EQUAL
57498: IFTRUE 57502
57500: GO 57520
57502: POP
// result := [ ar_medium_trike , ar_half_tracked ] ; ru_heavy_machine_gun :
57503: LD_ADDR_VAR 0 3
57507: PUSH
57508: LD_INT 13
57510: PUSH
57511: LD_INT 14
57513: PUSH
57514: EMPTY
57515: LIST
57516: LIST
57517: ST_TO_ADDR
57518: GO 57837
57520: LD_INT 42
57522: DOUBLE
57523: EQUAL
57524: IFTRUE 57528
57526: GO 57554
57528: POP
// result := [ ru_medium_wheeled , ru_medium_tracked , ru_heavy_wheeled , ru_heavy_tracked ] ; ru_gatling_gun :
57529: LD_ADDR_VAR 0 3
57533: PUSH
57534: LD_INT 21
57536: PUSH
57537: LD_INT 22
57539: PUSH
57540: LD_INT 23
57542: PUSH
57543: LD_INT 24
57545: PUSH
57546: EMPTY
57547: LIST
57548: LIST
57549: LIST
57550: LIST
57551: ST_TO_ADDR
57552: GO 57837
57554: LD_INT 43
57556: DOUBLE
57557: EQUAL
57558: IFTRUE 57562
57560: GO 57588
57562: POP
// result := [ ru_medium_wheeled , ru_medium_tracked , ru_heavy_wheeled , ru_heavy_tracked ] ; ru_gun :
57563: LD_ADDR_VAR 0 3
57567: PUSH
57568: LD_INT 21
57570: PUSH
57571: LD_INT 22
57573: PUSH
57574: LD_INT 23
57576: PUSH
57577: LD_INT 24
57579: PUSH
57580: EMPTY
57581: LIST
57582: LIST
57583: LIST
57584: LIST
57585: ST_TO_ADDR
57586: GO 57837
57588: LD_INT 44
57590: DOUBLE
57591: EQUAL
57592: IFTRUE 57596
57594: GO 57622
57596: POP
// result := [ ru_medium_wheeled , ru_medium_tracked , ru_heavy_wheeled , ru_heavy_tracked ] ; ru_rocket_launcher :
57597: LD_ADDR_VAR 0 3
57601: PUSH
57602: LD_INT 21
57604: PUSH
57605: LD_INT 22
57607: PUSH
57608: LD_INT 23
57610: PUSH
57611: LD_INT 24
57613: PUSH
57614: EMPTY
57615: LIST
57616: LIST
57617: LIST
57618: LIST
57619: ST_TO_ADDR
57620: GO 57837
57622: LD_INT 45
57624: DOUBLE
57625: EQUAL
57626: IFTRUE 57630
57628: GO 57656
57630: POP
// result := [ ru_medium_wheeled , ru_medium_tracked , ru_heavy_wheeled , ru_heavy_tracked ] ; ru_time_lapser :
57631: LD_ADDR_VAR 0 3
57635: PUSH
57636: LD_INT 21
57638: PUSH
57639: LD_INT 22
57641: PUSH
57642: LD_INT 23
57644: PUSH
57645: LD_INT 24
57647: PUSH
57648: EMPTY
57649: LIST
57650: LIST
57651: LIST
57652: LIST
57653: ST_TO_ADDR
57654: GO 57837
57656: LD_INT 49
57658: DOUBLE
57659: EQUAL
57660: IFTRUE 57664
57662: GO 57690
57664: POP
// result := [ ru_medium_wheeled , ru_medium_tracked , ru_heavy_wheeled , ru_heavy_tracked ] ; ru_cargo_bay :
57665: LD_ADDR_VAR 0 3
57669: PUSH
57670: LD_INT 21
57672: PUSH
57673: LD_INT 22
57675: PUSH
57676: LD_INT 23
57678: PUSH
57679: LD_INT 24
57681: PUSH
57682: EMPTY
57683: LIST
57684: LIST
57685: LIST
57686: LIST
57687: ST_TO_ADDR
57688: GO 57837
57690: LD_INT 51
57692: DOUBLE
57693: EQUAL
57694: IFTRUE 57698
57696: GO 57724
57698: POP
// result := [ ru_medium_wheeled , ru_medium_tracked , ru_heavy_wheeled , ru_heavy_tracked ] ; ru_crane :
57699: LD_ADDR_VAR 0 3
57703: PUSH
57704: LD_INT 21
57706: PUSH
57707: LD_INT 22
57709: PUSH
57710: LD_INT 23
57712: PUSH
57713: LD_INT 24
57715: PUSH
57716: EMPTY
57717: LIST
57718: LIST
57719: LIST
57720: LIST
57721: ST_TO_ADDR
57722: GO 57837
57724: LD_INT 52
57726: DOUBLE
57727: EQUAL
57728: IFTRUE 57732
57730: GO 57758
57732: POP
// result := [ ru_medium_wheeled , ru_medium_tracked , ru_heavy_wheeled , ru_heavy_tracked ] ; ru_bulldozer :
57733: LD_ADDR_VAR 0 3
57737: PUSH
57738: LD_INT 21
57740: PUSH
57741: LD_INT 22
57743: PUSH
57744: LD_INT 23
57746: PUSH
57747: LD_INT 24
57749: PUSH
57750: EMPTY
57751: LIST
57752: LIST
57753: LIST
57754: LIST
57755: ST_TO_ADDR
57756: GO 57837
57758: LD_INT 53
57760: DOUBLE
57761: EQUAL
57762: IFTRUE 57766
57764: GO 57784
57766: POP
// result := [ ru_heavy_wheeled , ru_heavy_tracked ] ; ru_heavy_gun :
57767: LD_ADDR_VAR 0 3
57771: PUSH
57772: LD_INT 23
57774: PUSH
57775: LD_INT 24
57777: PUSH
57778: EMPTY
57779: LIST
57780: LIST
57781: ST_TO_ADDR
57782: GO 57837
57784: LD_INT 46
57786: DOUBLE
57787: EQUAL
57788: IFTRUE 57792
57790: GO 57810
57792: POP
// result := [ ru_heavy_wheeled , ru_heavy_tracked ] ; ru_rocket :
57793: LD_ADDR_VAR 0 3
57797: PUSH
57798: LD_INT 23
57800: PUSH
57801: LD_INT 24
57803: PUSH
57804: EMPTY
57805: LIST
57806: LIST
57807: ST_TO_ADDR
57808: GO 57837
57810: LD_INT 47
57812: DOUBLE
57813: EQUAL
57814: IFTRUE 57818
57816: GO 57836
57818: POP
// result := [ ru_heavy_wheeled , ru_heavy_tracked ] ; end ;
57819: LD_ADDR_VAR 0 3
57823: PUSH
57824: LD_INT 23
57826: PUSH
57827: LD_INT 24
57829: PUSH
57830: EMPTY
57831: LIST
57832: LIST
57833: ST_TO_ADDR
57834: GO 57837
57836: POP
// result := ( chassis in result ) ;
57837: LD_ADDR_VAR 0 3
57841: PUSH
57842: LD_VAR 0 1
57846: PUSH
57847: LD_VAR 0 3
57851: IN
57852: ST_TO_ADDR
// end ;
57853: LD_VAR 0 3
57857: RET
// export function Reindex ( array , i_from , i_to , direction ) ; var i , j , k , d , tmp , length ; begin
57858: LD_INT 0
57860: PPUSH
57861: PPUSH
57862: PPUSH
57863: PPUSH
57864: PPUSH
57865: PPUSH
57866: PPUSH
// result := array ;
57867: LD_ADDR_VAR 0 5
57871: PUSH
57872: LD_VAR 0 1
57876: ST_TO_ADDR
// if not array or not i_from or not i_to or i_from > array or i_to > array then
57877: LD_VAR 0 1
57881: NOT
57882: PUSH
57883: LD_VAR 0 2
57887: NOT
57888: OR
57889: PUSH
57890: LD_VAR 0 3
57894: NOT
57895: OR
57896: PUSH
57897: LD_VAR 0 2
57901: PUSH
57902: LD_VAR 0 1
57906: GREATER
57907: OR
57908: PUSH
57909: LD_VAR 0 3
57913: PUSH
57914: LD_VAR 0 1
57918: GREATER
57919: OR
57920: IFFALSE 57924
// exit ;
57922: GO 58220
// if direction then
57924: LD_VAR 0 4
57928: IFFALSE 57992
// begin d := 1 ;
57930: LD_ADDR_VAR 0 9
57934: PUSH
57935: LD_INT 1
57937: ST_TO_ADDR
// if i_from > i_to then
57938: LD_VAR 0 2
57942: PUSH
57943: LD_VAR 0 3
57947: GREATER
57948: IFFALSE 57974
// length := ( array - i_from ) + i_to else
57950: LD_ADDR_VAR 0 11
57954: PUSH
57955: LD_VAR 0 1
57959: PUSH
57960: LD_VAR 0 2
57964: MINUS
57965: PUSH
57966: LD_VAR 0 3
57970: PLUS
57971: ST_TO_ADDR
57972: GO 57990
// length := i_to - i_from ;
57974: LD_ADDR_VAR 0 11
57978: PUSH
57979: LD_VAR 0 3
57983: PUSH
57984: LD_VAR 0 2
57988: MINUS
57989: ST_TO_ADDR
// end else
57990: GO 58053
// begin d := - 1 ;
57992: LD_ADDR_VAR 0 9
57996: PUSH
57997: LD_INT 1
57999: NEG
58000: ST_TO_ADDR
// if i_from > i_to then
58001: LD_VAR 0 2
58005: PUSH
58006: LD_VAR 0 3
58010: GREATER
58011: IFFALSE 58031
// length := i_from - i_to else
58013: LD_ADDR_VAR 0 11
58017: PUSH
58018: LD_VAR 0 2
58022: PUSH
58023: LD_VAR 0 3
58027: MINUS
58028: ST_TO_ADDR
58029: GO 58053
// length := ( array - i_to ) + i_from ;
58031: LD_ADDR_VAR 0 11
58035: PUSH
58036: LD_VAR 0 1
58040: PUSH
58041: LD_VAR 0 3
58045: MINUS
58046: PUSH
58047: LD_VAR 0 2
58051: PLUS
58052: ST_TO_ADDR
// end ; if not length then
58053: LD_VAR 0 11
58057: NOT
58058: IFFALSE 58062
// exit ;
58060: GO 58220
// tmp := array ;
58062: LD_ADDR_VAR 0 10
58066: PUSH
58067: LD_VAR 0 1
58071: ST_TO_ADDR
// for i = 1 to length do
58072: LD_ADDR_VAR 0 6
58076: PUSH
58077: DOUBLE
58078: LD_INT 1
58080: DEC
58081: ST_TO_ADDR
58082: LD_VAR 0 11
58086: PUSH
58087: FOR_TO
58088: IFFALSE 58208
// begin for j = 1 to array do
58090: LD_ADDR_VAR 0 7
58094: PUSH
58095: DOUBLE
58096: LD_INT 1
58098: DEC
58099: ST_TO_ADDR
58100: LD_VAR 0 1
58104: PUSH
58105: FOR_TO
58106: IFFALSE 58194
// begin k := j + d ;
58108: LD_ADDR_VAR 0 8
58112: PUSH
58113: LD_VAR 0 7
58117: PUSH
58118: LD_VAR 0 9
58122: PLUS
58123: ST_TO_ADDR
// if k > array then
58124: LD_VAR 0 8
58128: PUSH
58129: LD_VAR 0 1
58133: GREATER
58134: IFFALSE 58144
// k := 1 ;
58136: LD_ADDR_VAR 0 8
58140: PUSH
58141: LD_INT 1
58143: ST_TO_ADDR
// if not k then
58144: LD_VAR 0 8
58148: NOT
58149: IFFALSE 58161
// k := array ;
58151: LD_ADDR_VAR 0 8
58155: PUSH
58156: LD_VAR 0 1
58160: ST_TO_ADDR
// tmp := Replace ( tmp , k , array [ j ] ) ;
58161: LD_ADDR_VAR 0 10
58165: PUSH
58166: LD_VAR 0 10
58170: PPUSH
58171: LD_VAR 0 8
58175: PPUSH
58176: LD_VAR 0 1
58180: PUSH
58181: LD_VAR 0 7
58185: ARRAY
58186: PPUSH
58187: CALL_OW 1
58191: ST_TO_ADDR
// end ;
58192: GO 58105
58194: POP
58195: POP
// array := tmp ;
58196: LD_ADDR_VAR 0 1
58200: PUSH
58201: LD_VAR 0 10
58205: ST_TO_ADDR
// end ;
58206: GO 58087
58208: POP
58209: POP
// result := array ;
58210: LD_ADDR_VAR 0 5
58214: PUSH
58215: LD_VAR 0 1
58219: ST_TO_ADDR
// end ;
58220: LD_VAR 0 5
58224: RET
// export function GetElementIndex ( array , value ) ; var i ; begin
58225: LD_INT 0
58227: PPUSH
58228: PPUSH
// result := 0 ;
58229: LD_ADDR_VAR 0 3
58233: PUSH
58234: LD_INT 0
58236: ST_TO_ADDR
// if not array or not value in array then
58237: LD_VAR 0 1
58241: NOT
58242: PUSH
58243: LD_VAR 0 2
58247: PUSH
58248: LD_VAR 0 1
58252: IN
58253: NOT
58254: OR
58255: IFFALSE 58259
// exit ;
58257: GO 58313
// for i = 1 to array do
58259: LD_ADDR_VAR 0 4
58263: PUSH
58264: DOUBLE
58265: LD_INT 1
58267: DEC
58268: ST_TO_ADDR
58269: LD_VAR 0 1
58273: PUSH
58274: FOR_TO
58275: IFFALSE 58311
// if value = array [ i ] then
58277: LD_VAR 0 2
58281: PUSH
58282: LD_VAR 0 1
58286: PUSH
58287: LD_VAR 0 4
58291: ARRAY
58292: EQUAL
58293: IFFALSE 58309
// begin result := i ;
58295: LD_ADDR_VAR 0 3
58299: PUSH
58300: LD_VAR 0 4
58304: ST_TO_ADDR
// exit ;
58305: POP
58306: POP
58307: GO 58313
// end ;
58309: GO 58274
58311: POP
58312: POP
// end ;
58313: LD_VAR 0 3
58317: RET
// export function PrepareVehicle ( chassis , engine , control , weapon , fuel ) ; begin
58318: LD_INT 0
58320: PPUSH
// vc_chassis := chassis ;
58321: LD_ADDR_OWVAR 37
58325: PUSH
58326: LD_VAR 0 1
58330: ST_TO_ADDR
// vc_engine := engine ;
58331: LD_ADDR_OWVAR 39
58335: PUSH
58336: LD_VAR 0 2
58340: ST_TO_ADDR
// vc_control := control ;
58341: LD_ADDR_OWVAR 38
58345: PUSH
58346: LD_VAR 0 3
58350: ST_TO_ADDR
// vc_weapon := weapon ;
58351: LD_ADDR_OWVAR 40
58355: PUSH
58356: LD_VAR 0 4
58360: ST_TO_ADDR
// vc_fuel_battery := fuel ;
58361: LD_ADDR_OWVAR 41
58365: PUSH
58366: LD_VAR 0 5
58370: ST_TO_ADDR
// end ;
58371: LD_VAR 0 6
58375: RET
// export function WantPlant ( unit ) ; var task ; begin
58376: LD_INT 0
58378: PPUSH
58379: PPUSH
// result := false ;
58380: LD_ADDR_VAR 0 2
58384: PUSH
58385: LD_INT 0
58387: ST_TO_ADDR
// task := GetTaskList ( unit ) ;
58388: LD_ADDR_VAR 0 3
58392: PUSH
58393: LD_VAR 0 1
58397: PPUSH
58398: CALL_OW 437
58402: ST_TO_ADDR
// if task then
58403: LD_VAR 0 3
58407: IFFALSE 58435
// if task [ 1 ] [ 1 ] = p then
58409: LD_VAR 0 3
58413: PUSH
58414: LD_INT 1
58416: ARRAY
58417: PUSH
58418: LD_INT 1
58420: ARRAY
58421: PUSH
58422: LD_STRING p
58424: EQUAL
58425: IFFALSE 58435
// result := true ;
58427: LD_ADDR_VAR 0 2
58431: PUSH
58432: LD_INT 1
58434: ST_TO_ADDR
// end ;
58435: LD_VAR 0 2
58439: RET
// export function ReplaceIn ( arr , pos , value ) ; var i , tmp , s_arr ; begin
58440: LD_INT 0
58442: PPUSH
58443: PPUSH
58444: PPUSH
58445: PPUSH
// if pos < 1 then
58446: LD_VAR 0 2
58450: PUSH
58451: LD_INT 1
58453: LESS
58454: IFFALSE 58458
// exit ;
58456: GO 58761
// if pos = 1 then
58458: LD_VAR 0 2
58462: PUSH
58463: LD_INT 1
58465: EQUAL
58466: IFFALSE 58499
// result := Replace ( arr , pos [ 1 ] , value ) else
58468: LD_ADDR_VAR 0 4
58472: PUSH
58473: LD_VAR 0 1
58477: PPUSH
58478: LD_VAR 0 2
58482: PUSH
58483: LD_INT 1
58485: ARRAY
58486: PPUSH
58487: LD_VAR 0 3
58491: PPUSH
58492: CALL_OW 1
58496: ST_TO_ADDR
58497: GO 58761
// begin tmp := arr ;
58499: LD_ADDR_VAR 0 6
58503: PUSH
58504: LD_VAR 0 1
58508: ST_TO_ADDR
// s_arr := [ tmp ] ;
58509: LD_ADDR_VAR 0 7
58513: PUSH
58514: LD_VAR 0 6
58518: PUSH
58519: EMPTY
58520: LIST
58521: ST_TO_ADDR
// for i = 1 to pos - 1 do
58522: LD_ADDR_VAR 0 5
58526: PUSH
58527: DOUBLE
58528: LD_INT 1
58530: DEC
58531: ST_TO_ADDR
58532: LD_VAR 0 2
58536: PUSH
58537: LD_INT 1
58539: MINUS
58540: PUSH
58541: FOR_TO
58542: IFFALSE 58587
// begin tmp := tmp [ pos [ i ] ] ;
58544: LD_ADDR_VAR 0 6
58548: PUSH
58549: LD_VAR 0 6
58553: PUSH
58554: LD_VAR 0 2
58558: PUSH
58559: LD_VAR 0 5
58563: ARRAY
58564: ARRAY
58565: ST_TO_ADDR
// s_arr := s_arr ^ [ tmp ] ;
58566: LD_ADDR_VAR 0 7
58570: PUSH
58571: LD_VAR 0 7
58575: PUSH
58576: LD_VAR 0 6
58580: PUSH
58581: EMPTY
58582: LIST
58583: ADD
58584: ST_TO_ADDR
// end ;
58585: GO 58541
58587: POP
58588: POP
// tmp := Replace ( tmp , pos [ pos ] , value ) ;
58589: LD_ADDR_VAR 0 6
58593: PUSH
58594: LD_VAR 0 6
58598: PPUSH
58599: LD_VAR 0 2
58603: PUSH
58604: LD_VAR 0 2
58608: ARRAY
58609: PPUSH
58610: LD_VAR 0 3
58614: PPUSH
58615: CALL_OW 1
58619: ST_TO_ADDR
// s_arr := Replace ( s_arr , s_arr , tmp ) ;
58620: LD_ADDR_VAR 0 7
58624: PUSH
58625: LD_VAR 0 7
58629: PPUSH
58630: LD_VAR 0 7
58634: PPUSH
58635: LD_VAR 0 6
58639: PPUSH
58640: CALL_OW 1
58644: ST_TO_ADDR
// for i = s_arr downto 2 do
58645: LD_ADDR_VAR 0 5
58649: PUSH
58650: DOUBLE
58651: LD_VAR 0 7
58655: INC
58656: ST_TO_ADDR
58657: LD_INT 2
58659: PUSH
58660: FOR_DOWNTO
58661: IFFALSE 58745
// begin tmp := Replace ( s_arr [ i - 1 ] , pos [ i - 1 ] , s_arr [ i ] ) ;
58663: LD_ADDR_VAR 0 6
58667: PUSH
58668: LD_VAR 0 7
58672: PUSH
58673: LD_VAR 0 5
58677: PUSH
58678: LD_INT 1
58680: MINUS
58681: ARRAY
58682: PPUSH
58683: LD_VAR 0 2
58687: PUSH
58688: LD_VAR 0 5
58692: PUSH
58693: LD_INT 1
58695: MINUS
58696: ARRAY
58697: PPUSH
58698: LD_VAR 0 7
58702: PUSH
58703: LD_VAR 0 5
58707: ARRAY
58708: PPUSH
58709: CALL_OW 1
58713: ST_TO_ADDR
// s_arr := Replace ( s_arr , i - 1 , tmp ) ;
58714: LD_ADDR_VAR 0 7
58718: PUSH
58719: LD_VAR 0 7
58723: PPUSH
58724: LD_VAR 0 5
58728: PUSH
58729: LD_INT 1
58731: MINUS
58732: PPUSH
58733: LD_VAR 0 6
58737: PPUSH
58738: CALL_OW 1
58742: ST_TO_ADDR
// end ;
58743: GO 58660
58745: POP
58746: POP
// result := s_arr [ 1 ] ;
58747: LD_ADDR_VAR 0 4
58751: PUSH
58752: LD_VAR 0 7
58756: PUSH
58757: LD_INT 1
58759: ARRAY
58760: ST_TO_ADDR
// end ; end ;
58761: LD_VAR 0 4
58765: RET
// export function ReplaceWith ( list , pos1 , pos2 ) ; var i ; begin
58766: LD_INT 0
58768: PPUSH
58769: PPUSH
// if not list then
58770: LD_VAR 0 1
58774: NOT
58775: IFFALSE 58779
// exit ;
58777: GO 58870
// i := list [ pos1 ] ;
58779: LD_ADDR_VAR 0 5
58783: PUSH
58784: LD_VAR 0 1
58788: PUSH
58789: LD_VAR 0 2
58793: ARRAY
58794: ST_TO_ADDR
// if not i then
58795: LD_VAR 0 5
58799: NOT
58800: IFFALSE 58804
// exit ;
58802: GO 58870
// list := Replace ( list , pos1 , list [ pos2 ] ) ;
58804: LD_ADDR_VAR 0 1
58808: PUSH
58809: LD_VAR 0 1
58813: PPUSH
58814: LD_VAR 0 2
58818: PPUSH
58819: LD_VAR 0 1
58823: PUSH
58824: LD_VAR 0 3
58828: ARRAY
58829: PPUSH
58830: CALL_OW 1
58834: ST_TO_ADDR
// list := Replace ( list , pos2 , i ) ;
58835: LD_ADDR_VAR 0 1
58839: PUSH
58840: LD_VAR 0 1
58844: PPUSH
58845: LD_VAR 0 3
58849: PPUSH
58850: LD_VAR 0 5
58854: PPUSH
58855: CALL_OW 1
58859: ST_TO_ADDR
// result := list ;
58860: LD_ADDR_VAR 0 4
58864: PUSH
58865: LD_VAR 0 1
58869: ST_TO_ADDR
// end ;
58870: LD_VAR 0 4
58874: RET
// export function SortByDistanceUnit ( unit , list , asc , mode ) ; begin
58875: LD_INT 0
58877: PPUSH
// result := SortByDistanceXY ( GetX ( unit ) , GetY ( unit ) , list , asc , mode ) ;
58878: LD_ADDR_VAR 0 5
58882: PUSH
58883: LD_VAR 0 1
58887: PPUSH
58888: CALL_OW 250
58892: PPUSH
58893: LD_VAR 0 1
58897: PPUSH
58898: CALL_OW 251
58902: PPUSH
58903: LD_VAR 0 2
58907: PPUSH
58908: LD_VAR 0 3
58912: PPUSH
58913: LD_VAR 0 4
58917: PPUSH
58918: CALL 59296 0 5
58922: ST_TO_ADDR
// end ;
58923: LD_VAR 0 5
58927: RET
// export function SortHexesByDistanceFromUnit ( unit , list , asc , mode ) ; var i , j , tmp ; begin
58928: LD_INT 0
58930: PPUSH
58931: PPUSH
58932: PPUSH
58933: PPUSH
// if not list or not unit then
58934: LD_VAR 0 2
58938: NOT
58939: PUSH
58940: LD_VAR 0 1
58944: NOT
58945: OR
58946: IFFALSE 58950
// exit ;
58948: GO 59291
// result := [ ] ;
58950: LD_ADDR_VAR 0 5
58954: PUSH
58955: EMPTY
58956: ST_TO_ADDR
// for i in list do
58957: LD_ADDR_VAR 0 6
58961: PUSH
58962: LD_VAR 0 2
58966: PUSH
58967: FOR_IN
58968: IFFALSE 59186
// begin tmp := GetDistUnitXY ( unit , i [ 1 ] , i [ 2 ] ) ;
58970: LD_ADDR_VAR 0 8
58974: PUSH
58975: LD_VAR 0 1
58979: PPUSH
58980: LD_VAR 0 6
58984: PUSH
58985: LD_INT 1
58987: ARRAY
58988: PPUSH
58989: LD_VAR 0 6
58993: PUSH
58994: LD_INT 2
58996: ARRAY
58997: PPUSH
58998: CALL_OW 297
59002: ST_TO_ADDR
// if not Count ( result ) then
59003: LD_VAR 0 5
59007: PPUSH
59008: CALL 55580 0 1
59012: NOT
59013: IFFALSE 59046
// begin result := Join ( result , [ i , tmp ] ) ;
59015: LD_ADDR_VAR 0 5
59019: PUSH
59020: LD_VAR 0 5
59024: PPUSH
59025: LD_VAR 0 6
59029: PUSH
59030: LD_VAR 0 8
59034: PUSH
59035: EMPTY
59036: LIST
59037: LIST
59038: PPUSH
59039: CALL 91169 0 2
59043: ST_TO_ADDR
// continue ;
59044: GO 58967
// end ; if result [ result ] [ 2 ] <= tmp then
59046: LD_VAR 0 5
59050: PUSH
59051: LD_VAR 0 5
59055: ARRAY
59056: PUSH
59057: LD_INT 2
59059: ARRAY
59060: PUSH
59061: LD_VAR 0 8
59065: LESSEQUAL
59066: IFFALSE 59099
// result := Join ( result , [ i , tmp ] ) else
59068: LD_ADDR_VAR 0 5
59072: PUSH
59073: LD_VAR 0 5
59077: PPUSH
59078: LD_VAR 0 6
59082: PUSH
59083: LD_VAR 0 8
59087: PUSH
59088: EMPTY
59089: LIST
59090: LIST
59091: PPUSH
59092: CALL 91169 0 2
59096: ST_TO_ADDR
59097: GO 59184
// begin for j := 1 to Count ( result ) do
59099: LD_ADDR_VAR 0 7
59103: PUSH
59104: DOUBLE
59105: LD_INT 1
59107: DEC
59108: ST_TO_ADDR
59109: LD_VAR 0 5
59113: PPUSH
59114: CALL 55580 0 1
59118: PUSH
59119: FOR_TO
59120: IFFALSE 59182
// begin if tmp < result [ j ] [ 2 ] then
59122: LD_VAR 0 8
59126: PUSH
59127: LD_VAR 0 5
59131: PUSH
59132: LD_VAR 0 7
59136: ARRAY
59137: PUSH
59138: LD_INT 2
59140: ARRAY
59141: LESS
59142: IFFALSE 59180
// begin result := Insert ( result , j , [ i , tmp ] ) ;
59144: LD_ADDR_VAR 0 5
59148: PUSH
59149: LD_VAR 0 5
59153: PPUSH
59154: LD_VAR 0 7
59158: PPUSH
59159: LD_VAR 0 6
59163: PUSH
59164: LD_VAR 0 8
59168: PUSH
59169: EMPTY
59170: LIST
59171: LIST
59172: PPUSH
59173: CALL_OW 2
59177: ST_TO_ADDR
// break ;
59178: GO 59182
// end ; end ;
59180: GO 59119
59182: POP
59183: POP
// end ; end ;
59184: GO 58967
59186: POP
59187: POP
// if result and not asc then
59188: LD_VAR 0 5
59192: PUSH
59193: LD_VAR 0 3
59197: NOT
59198: AND
59199: IFFALSE 59216
// result := ReverseArray ( result ) ;
59201: LD_ADDR_VAR 0 5
59205: PUSH
59206: LD_VAR 0 5
59210: PPUSH
59211: CALL 86456 0 1
59215: ST_TO_ADDR
// tmp := [ ] ;
59216: LD_ADDR_VAR 0 8
59220: PUSH
59221: EMPTY
59222: ST_TO_ADDR
// if mode then
59223: LD_VAR 0 4
59227: IFFALSE 59291
// begin for i := 1 to result do
59229: LD_ADDR_VAR 0 6
59233: PUSH
59234: DOUBLE
59235: LD_INT 1
59237: DEC
59238: ST_TO_ADDR
59239: LD_VAR 0 5
59243: PUSH
59244: FOR_TO
59245: IFFALSE 59279
// tmp := Join ( tmp , result [ i ] [ 1 ] ) ;
59247: LD_ADDR_VAR 0 8
59251: PUSH
59252: LD_VAR 0 8
59256: PPUSH
59257: LD_VAR 0 5
59261: PUSH
59262: LD_VAR 0 6
59266: ARRAY
59267: PUSH
59268: LD_INT 1
59270: ARRAY
59271: PPUSH
59272: CALL 91169 0 2
59276: ST_TO_ADDR
59277: GO 59244
59279: POP
59280: POP
// result := tmp ;
59281: LD_ADDR_VAR 0 5
59285: PUSH
59286: LD_VAR 0 8
59290: ST_TO_ADDR
// end ; end ;
59291: LD_VAR 0 5
59295: RET
// export function SortByDistanceXY ( x , y , list , asc , mode ) ; var i , j , tmp ; begin
59296: LD_INT 0
59298: PPUSH
59299: PPUSH
59300: PPUSH
59301: PPUSH
// if not list then
59302: LD_VAR 0 3
59306: NOT
59307: IFFALSE 59311
// exit ;
59309: GO 59699
// result := [ ] ;
59311: LD_ADDR_VAR 0 6
59315: PUSH
59316: EMPTY
59317: ST_TO_ADDR
// for i in list do
59318: LD_ADDR_VAR 0 7
59322: PUSH
59323: LD_VAR 0 3
59327: PUSH
59328: FOR_IN
59329: IFFALSE 59531
// begin tmp := GetDistUnitXY ( i , x , y ) ;
59331: LD_ADDR_VAR 0 9
59335: PUSH
59336: LD_VAR 0 7
59340: PPUSH
59341: LD_VAR 0 1
59345: PPUSH
59346: LD_VAR 0 2
59350: PPUSH
59351: CALL_OW 297
59355: ST_TO_ADDR
// if not result then
59356: LD_VAR 0 6
59360: NOT
59361: IFFALSE 59387
// result := [ [ i , tmp ] ] else
59363: LD_ADDR_VAR 0 6
59367: PUSH
59368: LD_VAR 0 7
59372: PUSH
59373: LD_VAR 0 9
59377: PUSH
59378: EMPTY
59379: LIST
59380: LIST
59381: PUSH
59382: EMPTY
59383: LIST
59384: ST_TO_ADDR
59385: GO 59529
// begin if result [ result ] [ 2 ] < tmp then
59387: LD_VAR 0 6
59391: PUSH
59392: LD_VAR 0 6
59396: ARRAY
59397: PUSH
59398: LD_INT 2
59400: ARRAY
59401: PUSH
59402: LD_VAR 0 9
59406: LESS
59407: IFFALSE 59449
// result := Insert ( result , result + 1 , [ i , tmp ] ) else
59409: LD_ADDR_VAR 0 6
59413: PUSH
59414: LD_VAR 0 6
59418: PPUSH
59419: LD_VAR 0 6
59423: PUSH
59424: LD_INT 1
59426: PLUS
59427: PPUSH
59428: LD_VAR 0 7
59432: PUSH
59433: LD_VAR 0 9
59437: PUSH
59438: EMPTY
59439: LIST
59440: LIST
59441: PPUSH
59442: CALL_OW 2
59446: ST_TO_ADDR
59447: GO 59529
// for j = 1 to result do
59449: LD_ADDR_VAR 0 8
59453: PUSH
59454: DOUBLE
59455: LD_INT 1
59457: DEC
59458: ST_TO_ADDR
59459: LD_VAR 0 6
59463: PUSH
59464: FOR_TO
59465: IFFALSE 59527
// begin if tmp < result [ j ] [ 2 ] then
59467: LD_VAR 0 9
59471: PUSH
59472: LD_VAR 0 6
59476: PUSH
59477: LD_VAR 0 8
59481: ARRAY
59482: PUSH
59483: LD_INT 2
59485: ARRAY
59486: LESS
59487: IFFALSE 59525
// begin result := Insert ( result , j , [ i , tmp ] ) ;
59489: LD_ADDR_VAR 0 6
59493: PUSH
59494: LD_VAR 0 6
59498: PPUSH
59499: LD_VAR 0 8
59503: PPUSH
59504: LD_VAR 0 7
59508: PUSH
59509: LD_VAR 0 9
59513: PUSH
59514: EMPTY
59515: LIST
59516: LIST
59517: PPUSH
59518: CALL_OW 2
59522: ST_TO_ADDR
// break ;
59523: GO 59527
// end ; end ;
59525: GO 59464
59527: POP
59528: POP
// end ; end ;
59529: GO 59328
59531: POP
59532: POP
// if result and not asc then
59533: LD_VAR 0 6
59537: PUSH
59538: LD_VAR 0 4
59542: NOT
59543: AND
59544: IFFALSE 59619
// begin tmp := result ;
59546: LD_ADDR_VAR 0 9
59550: PUSH
59551: LD_VAR 0 6
59555: ST_TO_ADDR
// for i = tmp downto 1 do
59556: LD_ADDR_VAR 0 7
59560: PUSH
59561: DOUBLE
59562: LD_VAR 0 9
59566: INC
59567: ST_TO_ADDR
59568: LD_INT 1
59570: PUSH
59571: FOR_DOWNTO
59572: IFFALSE 59617
// result := Replace ( result , tmp - i + 1 , tmp [ i ] ) ;
59574: LD_ADDR_VAR 0 6
59578: PUSH
59579: LD_VAR 0 6
59583: PPUSH
59584: LD_VAR 0 9
59588: PUSH
59589: LD_VAR 0 7
59593: MINUS
59594: PUSH
59595: LD_INT 1
59597: PLUS
59598: PPUSH
59599: LD_VAR 0 9
59603: PUSH
59604: LD_VAR 0 7
59608: ARRAY
59609: PPUSH
59610: CALL_OW 1
59614: ST_TO_ADDR
59615: GO 59571
59617: POP
59618: POP
// end ; tmp := [ ] ;
59619: LD_ADDR_VAR 0 9
59623: PUSH
59624: EMPTY
59625: ST_TO_ADDR
// if mode then
59626: LD_VAR 0 5
59630: IFFALSE 59699
// begin for i = 1 to result do
59632: LD_ADDR_VAR 0 7
59636: PUSH
59637: DOUBLE
59638: LD_INT 1
59640: DEC
59641: ST_TO_ADDR
59642: LD_VAR 0 6
59646: PUSH
59647: FOR_TO
59648: IFFALSE 59687
// tmp := Replace ( tmp , i , result [ i ] [ 1 ] ) ;
59650: LD_ADDR_VAR 0 9
59654: PUSH
59655: LD_VAR 0 9
59659: PPUSH
59660: LD_VAR 0 7
59664: PPUSH
59665: LD_VAR 0 6
59669: PUSH
59670: LD_VAR 0 7
59674: ARRAY
59675: PUSH
59676: LD_INT 1
59678: ARRAY
59679: PPUSH
59680: CALL_OW 1
59684: ST_TO_ADDR
59685: GO 59647
59687: POP
59688: POP
// result := tmp ;
59689: LD_ADDR_VAR 0 6
59693: PUSH
59694: LD_VAR 0 9
59698: ST_TO_ADDR
// end ; end ;
59699: LD_VAR 0 6
59703: RET
// export function DangerAtRangeXY ( side , x , y , range ) ; var i , j , tmp , points , bpoints ; begin
59704: LD_INT 0
59706: PPUSH
59707: PPUSH
59708: PPUSH
59709: PPUSH
59710: PPUSH
59711: PPUSH
// result := [ 0 , 0 , 0 , [ ] ] ;
59712: LD_ADDR_VAR 0 5
59716: PUSH
59717: LD_INT 0
59719: PUSH
59720: LD_INT 0
59722: PUSH
59723: LD_INT 0
59725: PUSH
59726: EMPTY
59727: PUSH
59728: EMPTY
59729: LIST
59730: LIST
59731: LIST
59732: LIST
59733: ST_TO_ADDR
// if not x or not y then
59734: LD_VAR 0 2
59738: NOT
59739: PUSH
59740: LD_VAR 0 3
59744: NOT
59745: OR
59746: IFFALSE 59750
// exit ;
59748: GO 61400
// if not range then
59750: LD_VAR 0 4
59754: NOT
59755: IFFALSE 59765
// range := 10 ;
59757: LD_ADDR_VAR 0 4
59761: PUSH
59762: LD_INT 10
59764: ST_TO_ADDR
// tmp := FilterAllUnits ( [ [ f_enemy , side ] , [ f_distxy , x , y , range ] , [ f_not , [ f_type , unit_building ] ] ] ) ;
59765: LD_ADDR_VAR 0 8
59769: PUSH
59770: LD_INT 81
59772: PUSH
59773: LD_VAR 0 1
59777: PUSH
59778: EMPTY
59779: LIST
59780: LIST
59781: PUSH
59782: LD_INT 92
59784: PUSH
59785: LD_VAR 0 2
59789: PUSH
59790: LD_VAR 0 3
59794: PUSH
59795: LD_VAR 0 4
59799: PUSH
59800: EMPTY
59801: LIST
59802: LIST
59803: LIST
59804: LIST
59805: PUSH
59806: LD_INT 3
59808: PUSH
59809: LD_INT 21
59811: PUSH
59812: LD_INT 3
59814: PUSH
59815: EMPTY
59816: LIST
59817: LIST
59818: PUSH
59819: EMPTY
59820: LIST
59821: LIST
59822: PUSH
59823: EMPTY
59824: LIST
59825: LIST
59826: LIST
59827: PPUSH
59828: CALL_OW 69
59832: ST_TO_ADDR
// if not tmp then
59833: LD_VAR 0 8
59837: NOT
59838: IFFALSE 59842
// exit ;
59840: GO 61400
// for i in tmp do
59842: LD_ADDR_VAR 0 6
59846: PUSH
59847: LD_VAR 0 8
59851: PUSH
59852: FOR_IN
59853: IFFALSE 61375
// begin points := [ 0 , 0 , 0 ] ;
59855: LD_ADDR_VAR 0 9
59859: PUSH
59860: LD_INT 0
59862: PUSH
59863: LD_INT 0
59865: PUSH
59866: LD_INT 0
59868: PUSH
59869: EMPTY
59870: LIST
59871: LIST
59872: LIST
59873: ST_TO_ADDR
// bpoints := 1 ;
59874: LD_ADDR_VAR 0 10
59878: PUSH
59879: LD_INT 1
59881: ST_TO_ADDR
// case GetType ( i ) of unit_human :
59882: LD_VAR 0 6
59886: PPUSH
59887: CALL_OW 247
59891: PUSH
59892: LD_INT 1
59894: DOUBLE
59895: EQUAL
59896: IFTRUE 59900
59898: GO 60478
59900: POP
// begin if GetClass ( i ) = 1 then
59901: LD_VAR 0 6
59905: PPUSH
59906: CALL_OW 257
59910: PUSH
59911: LD_INT 1
59913: EQUAL
59914: IFFALSE 59935
// points := [ 10 , 5 , 3 ] ;
59916: LD_ADDR_VAR 0 9
59920: PUSH
59921: LD_INT 10
59923: PUSH
59924: LD_INT 5
59926: PUSH
59927: LD_INT 3
59929: PUSH
59930: EMPTY
59931: LIST
59932: LIST
59933: LIST
59934: ST_TO_ADDR
// if GetClass ( i ) in [ 2 , 3 , 4 ] then
59935: LD_VAR 0 6
59939: PPUSH
59940: CALL_OW 257
59944: PUSH
59945: LD_INT 2
59947: PUSH
59948: LD_INT 3
59950: PUSH
59951: LD_INT 4
59953: PUSH
59954: EMPTY
59955: LIST
59956: LIST
59957: LIST
59958: IN
59959: IFFALSE 59980
// points := [ 3 , 2 , 1 ] ;
59961: LD_ADDR_VAR 0 9
59965: PUSH
59966: LD_INT 3
59968: PUSH
59969: LD_INT 2
59971: PUSH
59972: LD_INT 1
59974: PUSH
59975: EMPTY
59976: LIST
59977: LIST
59978: LIST
59979: ST_TO_ADDR
// if GetClass ( i ) = 5 then
59980: LD_VAR 0 6
59984: PPUSH
59985: CALL_OW 257
59989: PUSH
59990: LD_INT 5
59992: EQUAL
59993: IFFALSE 60014
// points := [ 130 , 5 , 2 ] ;
59995: LD_ADDR_VAR 0 9
59999: PUSH
60000: LD_INT 130
60002: PUSH
60003: LD_INT 5
60005: PUSH
60006: LD_INT 2
60008: PUSH
60009: EMPTY
60010: LIST
60011: LIST
60012: LIST
60013: ST_TO_ADDR
// if GetClass ( i ) = 8 then
60014: LD_VAR 0 6
60018: PPUSH
60019: CALL_OW 257
60023: PUSH
60024: LD_INT 8
60026: EQUAL
60027: IFFALSE 60048
// points := [ 35 , 35 , 30 ] ;
60029: LD_ADDR_VAR 0 9
60033: PUSH
60034: LD_INT 35
60036: PUSH
60037: LD_INT 35
60039: PUSH
60040: LD_INT 30
60042: PUSH
60043: EMPTY
60044: LIST
60045: LIST
60046: LIST
60047: ST_TO_ADDR
// if GetClass ( i ) = 9 then
60048: LD_VAR 0 6
60052: PPUSH
60053: CALL_OW 257
60057: PUSH
60058: LD_INT 9
60060: EQUAL
60061: IFFALSE 60082
// points := [ 20 , 55 , 40 ] ;
60063: LD_ADDR_VAR 0 9
60067: PUSH
60068: LD_INT 20
60070: PUSH
60071: LD_INT 55
60073: PUSH
60074: LD_INT 40
60076: PUSH
60077: EMPTY
60078: LIST
60079: LIST
60080: LIST
60081: ST_TO_ADDR
// if GetClass ( i ) in [ 12 , 16 ] then
60082: LD_VAR 0 6
60086: PPUSH
60087: CALL_OW 257
60091: PUSH
60092: LD_INT 12
60094: PUSH
60095: LD_INT 16
60097: PUSH
60098: EMPTY
60099: LIST
60100: LIST
60101: IN
60102: IFFALSE 60123
// points := [ 5 , 3 , 2 ] ;
60104: LD_ADDR_VAR 0 9
60108: PUSH
60109: LD_INT 5
60111: PUSH
60112: LD_INT 3
60114: PUSH
60115: LD_INT 2
60117: PUSH
60118: EMPTY
60119: LIST
60120: LIST
60121: LIST
60122: ST_TO_ADDR
// if GetClass ( i ) = 17 then
60123: LD_VAR 0 6
60127: PPUSH
60128: CALL_OW 257
60132: PUSH
60133: LD_INT 17
60135: EQUAL
60136: IFFALSE 60157
// points := [ 100 , 50 , 75 ] ;
60138: LD_ADDR_VAR 0 9
60142: PUSH
60143: LD_INT 100
60145: PUSH
60146: LD_INT 50
60148: PUSH
60149: LD_INT 75
60151: PUSH
60152: EMPTY
60153: LIST
60154: LIST
60155: LIST
60156: ST_TO_ADDR
// if GetClass ( i ) = 15 then
60157: LD_VAR 0 6
60161: PPUSH
60162: CALL_OW 257
60166: PUSH
60167: LD_INT 15
60169: EQUAL
60170: IFFALSE 60191
// points := [ 10 , 5 , 3 ] ;
60172: LD_ADDR_VAR 0 9
60176: PUSH
60177: LD_INT 10
60179: PUSH
60180: LD_INT 5
60182: PUSH
60183: LD_INT 3
60185: PUSH
60186: EMPTY
60187: LIST
60188: LIST
60189: LIST
60190: ST_TO_ADDR
// if GetClass ( i ) = 14 then
60191: LD_VAR 0 6
60195: PPUSH
60196: CALL_OW 257
60200: PUSH
60201: LD_INT 14
60203: EQUAL
60204: IFFALSE 60225
// points := [ 10 , 0 , 0 ] ;
60206: LD_ADDR_VAR 0 9
60210: PUSH
60211: LD_INT 10
60213: PUSH
60214: LD_INT 0
60216: PUSH
60217: LD_INT 0
60219: PUSH
60220: EMPTY
60221: LIST
60222: LIST
60223: LIST
60224: ST_TO_ADDR
// if GetClass ( i ) = 11 then
60225: LD_VAR 0 6
60229: PPUSH
60230: CALL_OW 257
60234: PUSH
60235: LD_INT 11
60237: EQUAL
60238: IFFALSE 60259
// points := [ 30 , 10 , 5 ] ;
60240: LD_ADDR_VAR 0 9
60244: PUSH
60245: LD_INT 30
60247: PUSH
60248: LD_INT 10
60250: PUSH
60251: LD_INT 5
60253: PUSH
60254: EMPTY
60255: LIST
60256: LIST
60257: LIST
60258: ST_TO_ADDR
// if GetTech ( side , tech_stimdrugs ) = state_researched then
60259: LD_VAR 0 1
60263: PPUSH
60264: LD_INT 5
60266: PPUSH
60267: CALL_OW 321
60271: PUSH
60272: LD_INT 2
60274: EQUAL
60275: IFFALSE 60292
// bpoints := bpoints * 1.8 ;
60277: LD_ADDR_VAR 0 10
60281: PUSH
60282: LD_VAR 0 10
60286: PUSH
60287: LD_REAL  1.80000000000000E+0000
60290: MUL
60291: ST_TO_ADDR
// if GetClass ( i ) in [ 1 , 2 , 3 , 4 ] and GetTech ( side , tech_weap1 ) = state_researched then
60292: LD_VAR 0 6
60296: PPUSH
60297: CALL_OW 257
60301: PUSH
60302: LD_INT 1
60304: PUSH
60305: LD_INT 2
60307: PUSH
60308: LD_INT 3
60310: PUSH
60311: LD_INT 4
60313: PUSH
60314: EMPTY
60315: LIST
60316: LIST
60317: LIST
60318: LIST
60319: IN
60320: PUSH
60321: LD_VAR 0 1
60325: PPUSH
60326: LD_INT 51
60328: PPUSH
60329: CALL_OW 321
60333: PUSH
60334: LD_INT 2
60336: EQUAL
60337: AND
60338: IFFALSE 60355
// bpoints := bpoints * 1.2 ;
60340: LD_ADDR_VAR 0 10
60344: PUSH
60345: LD_VAR 0 10
60349: PUSH
60350: LD_REAL  1.20000000000000E+0000
60353: MUL
60354: ST_TO_ADDR
// if GetClass ( i ) in [ 5 , 7 , 9 ] and GetTech ( side , tech_weap2 ) = state_researched then
60355: LD_VAR 0 6
60359: PPUSH
60360: CALL_OW 257
60364: PUSH
60365: LD_INT 5
60367: PUSH
60368: LD_INT 7
60370: PUSH
60371: LD_INT 9
60373: PUSH
60374: EMPTY
60375: LIST
60376: LIST
60377: LIST
60378: IN
60379: PUSH
60380: LD_VAR 0 1
60384: PPUSH
60385: LD_INT 52
60387: PPUSH
60388: CALL_OW 321
60392: PUSH
60393: LD_INT 2
60395: EQUAL
60396: AND
60397: IFFALSE 60414
// bpoints := bpoints * 1.5 ;
60399: LD_ADDR_VAR 0 10
60403: PUSH
60404: LD_VAR 0 10
60408: PUSH
60409: LD_REAL  1.50000000000000E+0000
60412: MUL
60413: ST_TO_ADDR
// if GetTech ( side , tech_bio1 ) = state_researched then
60414: LD_VAR 0 1
60418: PPUSH
60419: LD_INT 66
60421: PPUSH
60422: CALL_OW 321
60426: PUSH
60427: LD_INT 2
60429: EQUAL
60430: IFFALSE 60447
// bpoints := bpoints * 1.1 ;
60432: LD_ADDR_VAR 0 10
60436: PUSH
60437: LD_VAR 0 10
60441: PUSH
60442: LD_REAL  1.10000000000000E+0000
60445: MUL
60446: ST_TO_ADDR
// bpoints := bpoints * ( GetSkill ( i , 1 ) * 1.15 ) ;
60447: LD_ADDR_VAR 0 10
60451: PUSH
60452: LD_VAR 0 10
60456: PUSH
60457: LD_VAR 0 6
60461: PPUSH
60462: LD_INT 1
60464: PPUSH
60465: CALL_OW 259
60469: PUSH
60470: LD_REAL  1.15000000000000E+0000
60473: MUL
60474: MUL
60475: ST_TO_ADDR
// end ; unit_vehicle :
60476: GO 61304
60478: LD_INT 2
60480: DOUBLE
60481: EQUAL
60482: IFTRUE 60486
60484: GO 61292
60486: POP
// begin if GetWeapon ( i ) in [ us_machine_gun , ru_heavy_machine_gun , ar_double_machine_gun ] then
60487: LD_VAR 0 6
60491: PPUSH
60492: CALL_OW 264
60496: PUSH
60497: LD_INT 2
60499: PUSH
60500: LD_INT 42
60502: PUSH
60503: LD_INT 24
60505: PUSH
60506: EMPTY
60507: LIST
60508: LIST
60509: LIST
60510: IN
60511: IFFALSE 60532
// points := [ 25 , 5 , 3 ] ;
60513: LD_ADDR_VAR 0 9
60517: PUSH
60518: LD_INT 25
60520: PUSH
60521: LD_INT 5
60523: PUSH
60524: LD_INT 3
60526: PUSH
60527: EMPTY
60528: LIST
60529: LIST
60530: LIST
60531: ST_TO_ADDR
// if GetWeapon ( i ) in [ us_gatling_gun , ru_gatling_gun , ar_gatling_gun ] then
60532: LD_VAR 0 6
60536: PPUSH
60537: CALL_OW 264
60541: PUSH
60542: LD_INT 4
60544: PUSH
60545: LD_INT 43
60547: PUSH
60548: LD_INT 25
60550: PUSH
60551: EMPTY
60552: LIST
60553: LIST
60554: LIST
60555: IN
60556: IFFALSE 60577
// points := [ 40 , 15 , 5 ] ;
60558: LD_ADDR_VAR 0 9
60562: PUSH
60563: LD_INT 40
60565: PUSH
60566: LD_INT 15
60568: PUSH
60569: LD_INT 5
60571: PUSH
60572: EMPTY
60573: LIST
60574: LIST
60575: LIST
60576: ST_TO_ADDR
// if GetWeapon ( i ) in [ us_light_gun , ar_light_gun ] then
60577: LD_VAR 0 6
60581: PPUSH
60582: CALL_OW 264
60586: PUSH
60587: LD_INT 3
60589: PUSH
60590: LD_INT 23
60592: PUSH
60593: EMPTY
60594: LIST
60595: LIST
60596: IN
60597: IFFALSE 60618
// points := [ 7 , 25 , 8 ] ;
60599: LD_ADDR_VAR 0 9
60603: PUSH
60604: LD_INT 7
60606: PUSH
60607: LD_INT 25
60609: PUSH
60610: LD_INT 8
60612: PUSH
60613: EMPTY
60614: LIST
60615: LIST
60616: LIST
60617: ST_TO_ADDR
// if GetWeapon ( i ) in [ us_double_gun , ar_gun , ru_gun ] then
60618: LD_VAR 0 6
60622: PPUSH
60623: CALL_OW 264
60627: PUSH
60628: LD_INT 5
60630: PUSH
60631: LD_INT 27
60633: PUSH
60634: LD_INT 44
60636: PUSH
60637: EMPTY
60638: LIST
60639: LIST
60640: LIST
60641: IN
60642: IFFALSE 60663
// points := [ 14 , 50 , 16 ] ;
60644: LD_ADDR_VAR 0 9
60648: PUSH
60649: LD_INT 14
60651: PUSH
60652: LD_INT 50
60654: PUSH
60655: LD_INT 16
60657: PUSH
60658: EMPTY
60659: LIST
60660: LIST
60661: LIST
60662: ST_TO_ADDR
// if GetWeapon ( i ) in [ us_heavy_gun , ru_heavy_gun ] then
60663: LD_VAR 0 6
60667: PPUSH
60668: CALL_OW 264
60672: PUSH
60673: LD_INT 6
60675: PUSH
60676: LD_INT 46
60678: PUSH
60679: EMPTY
60680: LIST
60681: LIST
60682: IN
60683: IFFALSE 60704
// points := [ 32 , 120 , 70 ] ;
60685: LD_ADDR_VAR 0 9
60689: PUSH
60690: LD_INT 32
60692: PUSH
60693: LD_INT 120
60695: PUSH
60696: LD_INT 70
60698: PUSH
60699: EMPTY
60700: LIST
60701: LIST
60702: LIST
60703: ST_TO_ADDR
// if GetWeapon ( i ) in [ us_rocket_launcher , ar_rocket_launcher , ru_rocket_launcher , ar_mortar ] then
60704: LD_VAR 0 6
60708: PPUSH
60709: CALL_OW 264
60713: PUSH
60714: LD_INT 7
60716: PUSH
60717: LD_INT 28
60719: PUSH
60720: LD_INT 45
60722: PUSH
60723: LD_INT 92
60725: PUSH
60726: EMPTY
60727: LIST
60728: LIST
60729: LIST
60730: LIST
60731: IN
60732: IFFALSE 60753
// points := [ 35 , 20 , 45 ] ;
60734: LD_ADDR_VAR 0 9
60738: PUSH
60739: LD_INT 35
60741: PUSH
60742: LD_INT 20
60744: PUSH
60745: LD_INT 45
60747: PUSH
60748: EMPTY
60749: LIST
60750: LIST
60751: LIST
60752: ST_TO_ADDR
// if GetWeapon ( i ) in [ ru_rocket ] then
60753: LD_VAR 0 6
60757: PPUSH
60758: CALL_OW 264
60762: PUSH
60763: LD_INT 47
60765: PUSH
60766: EMPTY
60767: LIST
60768: IN
60769: IFFALSE 60790
// points := [ 67 , 45 , 75 ] ;
60771: LD_ADDR_VAR 0 9
60775: PUSH
60776: LD_INT 67
60778: PUSH
60779: LD_INT 45
60781: PUSH
60782: LD_INT 75
60784: PUSH
60785: EMPTY
60786: LIST
60787: LIST
60788: LIST
60789: ST_TO_ADDR
// if GetWeapon ( i ) in [ ar_flame_thrower ] then
60790: LD_VAR 0 6
60794: PPUSH
60795: CALL_OW 264
60799: PUSH
60800: LD_INT 26
60802: PUSH
60803: EMPTY
60804: LIST
60805: IN
60806: IFFALSE 60827
// points := [ 120 , 30 , 80 ] ;
60808: LD_ADDR_VAR 0 9
60812: PUSH
60813: LD_INT 120
60815: PUSH
60816: LD_INT 30
60818: PUSH
60819: LD_INT 80
60821: PUSH
60822: EMPTY
60823: LIST
60824: LIST
60825: LIST
60826: ST_TO_ADDR
// if GetWeapon ( i ) in [ ar_multimissile_ballista ] then
60827: LD_VAR 0 6
60831: PPUSH
60832: CALL_OW 264
60836: PUSH
60837: LD_INT 22
60839: PUSH
60840: EMPTY
60841: LIST
60842: IN
60843: IFFALSE 60864
// points := [ 40 , 1 , 1 ] ;
60845: LD_ADDR_VAR 0 9
60849: PUSH
60850: LD_INT 40
60852: PUSH
60853: LD_INT 1
60855: PUSH
60856: LD_INT 1
60858: PUSH
60859: EMPTY
60860: LIST
60861: LIST
60862: LIST
60863: ST_TO_ADDR
// if GetWeapon ( i ) in [ ar_selfpropelled_bomb ] then
60864: LD_VAR 0 6
60868: PPUSH
60869: CALL_OW 264
60873: PUSH
60874: LD_INT 29
60876: PUSH
60877: EMPTY
60878: LIST
60879: IN
60880: IFFALSE 60901
// points := [ 70 , 200 , 400 ] ;
60882: LD_ADDR_VAR 0 9
60886: PUSH
60887: LD_INT 70
60889: PUSH
60890: LD_INT 200
60892: PUSH
60893: LD_INT 400
60895: PUSH
60896: EMPTY
60897: LIST
60898: LIST
60899: LIST
60900: ST_TO_ADDR
// if GetWeapon ( i ) in [ us_bulldozer , ru_bulldozer ] then
60901: LD_VAR 0 6
60905: PPUSH
60906: CALL_OW 264
60910: PUSH
60911: LD_INT 14
60913: PUSH
60914: LD_INT 53
60916: PUSH
60917: EMPTY
60918: LIST
60919: LIST
60920: IN
60921: IFFALSE 60942
// points := [ 40 , 10 , 20 ] ;
60923: LD_ADDR_VAR 0 9
60927: PUSH
60928: LD_INT 40
60930: PUSH
60931: LD_INT 10
60933: PUSH
60934: LD_INT 20
60936: PUSH
60937: EMPTY
60938: LIST
60939: LIST
60940: LIST
60941: ST_TO_ADDR
// if GetWeapon ( i ) in [ us_laser ] then
60942: LD_VAR 0 6
60946: PPUSH
60947: CALL_OW 264
60951: PUSH
60952: LD_INT 9
60954: PUSH
60955: EMPTY
60956: LIST
60957: IN
60958: IFFALSE 60979
// points := [ 5 , 70 , 20 ] ;
60960: LD_ADDR_VAR 0 9
60964: PUSH
60965: LD_INT 5
60967: PUSH
60968: LD_INT 70
60970: PUSH
60971: LD_INT 20
60973: PUSH
60974: EMPTY
60975: LIST
60976: LIST
60977: LIST
60978: ST_TO_ADDR
// if GetWeapon ( i ) in [ us_double_laser ] then
60979: LD_VAR 0 6
60983: PPUSH
60984: CALL_OW 264
60988: PUSH
60989: LD_INT 10
60991: PUSH
60992: EMPTY
60993: LIST
60994: IN
60995: IFFALSE 61016
// points := [ 35 , 110 , 70 ] ;
60997: LD_ADDR_VAR 0 9
61001: PUSH
61002: LD_INT 35
61004: PUSH
61005: LD_INT 110
61007: PUSH
61008: LD_INT 70
61010: PUSH
61011: EMPTY
61012: LIST
61013: LIST
61014: LIST
61015: ST_TO_ADDR
// if GetChassis ( i ) = 25 then
61016: LD_VAR 0 6
61020: PPUSH
61021: CALL_OW 265
61025: PUSH
61026: LD_INT 25
61028: EQUAL
61029: IFFALSE 61050
// points := [ 80 , 65 , 100 ] ;
61031: LD_ADDR_VAR 0 9
61035: PUSH
61036: LD_INT 80
61038: PUSH
61039: LD_INT 65
61041: PUSH
61042: LD_INT 100
61044: PUSH
61045: EMPTY
61046: LIST
61047: LIST
61048: LIST
61049: ST_TO_ADDR
// if GetControl ( i ) = control_manual then
61050: LD_VAR 0 6
61054: PPUSH
61055: CALL_OW 263
61059: PUSH
61060: LD_INT 1
61062: EQUAL
61063: IFFALSE 61098
// bpoints := bpoints * ( GetSkill ( IsDrivenBy ( i ) , 3 ) * 4 ) ;
61065: LD_ADDR_VAR 0 10
61069: PUSH
61070: LD_VAR 0 10
61074: PUSH
61075: LD_VAR 0 6
61079: PPUSH
61080: CALL_OW 311
61084: PPUSH
61085: LD_INT 3
61087: PPUSH
61088: CALL_OW 259
61092: PUSH
61093: LD_INT 4
61095: MUL
61096: MUL
61097: ST_TO_ADDR
// if GetControl ( i ) = control_remote then
61098: LD_VAR 0 6
61102: PPUSH
61103: CALL_OW 263
61107: PUSH
61108: LD_INT 2
61110: EQUAL
61111: IFFALSE 61162
// begin j := IsControledBy ( i ) ;
61113: LD_ADDR_VAR 0 7
61117: PUSH
61118: LD_VAR 0 6
61122: PPUSH
61123: CALL_OW 312
61127: ST_TO_ADDR
// if j then
61128: LD_VAR 0 7
61132: IFFALSE 61162
// bpoints := bpoints * ( GetSkill ( j , 3 ) * 3 ) ;
61134: LD_ADDR_VAR 0 10
61138: PUSH
61139: LD_VAR 0 10
61143: PUSH
61144: LD_VAR 0 7
61148: PPUSH
61149: LD_INT 3
61151: PPUSH
61152: CALL_OW 259
61156: PUSH
61157: LD_INT 3
61159: MUL
61160: MUL
61161: ST_TO_ADDR
// end ; if GetWeapon ( i ) in [ us_double_gun , us_heavy_gun , ru_heavy_gun , ru_gun , ru_rocket , ru_rocket_launcher , ar_rocket_launcher , us_rocket_launcher , ar_gun , ar_selfpropelled_bomb ] and GetTech ( side , tech_weap2 ) = state_researched then
61162: LD_VAR 0 6
61166: PPUSH
61167: CALL_OW 264
61171: PUSH
61172: LD_INT 5
61174: PUSH
61175: LD_INT 6
61177: PUSH
61178: LD_INT 46
61180: PUSH
61181: LD_INT 44
61183: PUSH
61184: LD_INT 47
61186: PUSH
61187: LD_INT 45
61189: PUSH
61190: LD_INT 28
61192: PUSH
61193: LD_INT 7
61195: PUSH
61196: LD_INT 27
61198: PUSH
61199: LD_INT 29
61201: PUSH
61202: EMPTY
61203: LIST
61204: LIST
61205: LIST
61206: LIST
61207: LIST
61208: LIST
61209: LIST
61210: LIST
61211: LIST
61212: LIST
61213: IN
61214: PUSH
61215: LD_VAR 0 1
61219: PPUSH
61220: LD_INT 52
61222: PPUSH
61223: CALL_OW 321
61227: PUSH
61228: LD_INT 2
61230: EQUAL
61231: AND
61232: IFFALSE 61249
// bpoints := bpoints * 1.2 ;
61234: LD_ADDR_VAR 0 10
61238: PUSH
61239: LD_VAR 0 10
61243: PUSH
61244: LD_REAL  1.20000000000000E+0000
61247: MUL
61248: ST_TO_ADDR
// if GetWeapon ( i ) in [ us_heavy_gun , ru_heavy_gun , ru_rocket ] then
61249: LD_VAR 0 6
61253: PPUSH
61254: CALL_OW 264
61258: PUSH
61259: LD_INT 6
61261: PUSH
61262: LD_INT 46
61264: PUSH
61265: LD_INT 47
61267: PUSH
61268: EMPTY
61269: LIST
61270: LIST
61271: LIST
61272: IN
61273: IFFALSE 61290
// bpoints := bpoints * 1.2 ;
61275: LD_ADDR_VAR 0 10
61279: PUSH
61280: LD_VAR 0 10
61284: PUSH
61285: LD_REAL  1.20000000000000E+0000
61288: MUL
61289: ST_TO_ADDR
// end ; unit_building :
61290: GO 61304
61292: LD_INT 3
61294: DOUBLE
61295: EQUAL
61296: IFTRUE 61300
61298: GO 61303
61300: POP
// ; end ;
61301: GO 61304
61303: POP
// for j = 1 to 3 do
61304: LD_ADDR_VAR 0 7
61308: PUSH
61309: DOUBLE
61310: LD_INT 1
61312: DEC
61313: ST_TO_ADDR
61314: LD_INT 3
61316: PUSH
61317: FOR_TO
61318: IFFALSE 61371
// result := Replace ( result , j , result [ j ] + ( points [ j ] * bpoints ) ) ;
61320: LD_ADDR_VAR 0 5
61324: PUSH
61325: LD_VAR 0 5
61329: PPUSH
61330: LD_VAR 0 7
61334: PPUSH
61335: LD_VAR 0 5
61339: PUSH
61340: LD_VAR 0 7
61344: ARRAY
61345: PUSH
61346: LD_VAR 0 9
61350: PUSH
61351: LD_VAR 0 7
61355: ARRAY
61356: PUSH
61357: LD_VAR 0 10
61361: MUL
61362: PLUS
61363: PPUSH
61364: CALL_OW 1
61368: ST_TO_ADDR
61369: GO 61317
61371: POP
61372: POP
// end ;
61373: GO 59852
61375: POP
61376: POP
// result := Replace ( result , 4 , tmp ) ;
61377: LD_ADDR_VAR 0 5
61381: PUSH
61382: LD_VAR 0 5
61386: PPUSH
61387: LD_INT 4
61389: PPUSH
61390: LD_VAR 0 8
61394: PPUSH
61395: CALL_OW 1
61399: ST_TO_ADDR
// end ;
61400: LD_VAR 0 5
61404: RET
// export function DangerAtRange ( unit , range ) ; begin
61405: LD_INT 0
61407: PPUSH
// if not unit then
61408: LD_VAR 0 1
61412: NOT
61413: IFFALSE 61417
// exit ;
61415: GO 61462
// result := DangerAtRangeXY ( GetSide ( unit ) , GetX ( unit ) , GetY ( unit ) , range ) ;
61417: LD_ADDR_VAR 0 3
61421: PUSH
61422: LD_VAR 0 1
61426: PPUSH
61427: CALL_OW 255
61431: PPUSH
61432: LD_VAR 0 1
61436: PPUSH
61437: CALL_OW 250
61441: PPUSH
61442: LD_VAR 0 1
61446: PPUSH
61447: CALL_OW 251
61451: PPUSH
61452: LD_VAR 0 2
61456: PPUSH
61457: CALL 59704 0 4
61461: ST_TO_ADDR
// end ;
61462: LD_VAR 0 3
61466: RET
// export function DangerInArea ( side , area ) ; begin
61467: LD_INT 0
61469: PPUSH
// result := FilterUnitsInArea ( area , [ f_enemy , side ] ) ;
61470: LD_ADDR_VAR 0 3
61474: PUSH
61475: LD_VAR 0 2
61479: PPUSH
61480: LD_INT 81
61482: PUSH
61483: LD_VAR 0 1
61487: PUSH
61488: EMPTY
61489: LIST
61490: LIST
61491: PPUSH
61492: CALL_OW 70
61496: ST_TO_ADDR
// end ;
61497: LD_VAR 0 3
61501: RET
// export function IsExtension ( b ) ; begin
61502: LD_INT 0
61504: PPUSH
// result := b in [ b_ext_stitch , b_ext_radar , b_ext_radio , b_ext_gun , b_ext_computer , b_ext_siberium , b_ext_noncombat , b_ext_track , b_ext_laser , b_ext_rocket ] ;
61505: LD_ADDR_VAR 0 2
61509: PUSH
61510: LD_VAR 0 1
61514: PUSH
61515: LD_INT 23
61517: PUSH
61518: LD_INT 20
61520: PUSH
61521: LD_INT 22
61523: PUSH
61524: LD_INT 17
61526: PUSH
61527: LD_INT 24
61529: PUSH
61530: LD_INT 21
61532: PUSH
61533: LD_INT 19
61535: PUSH
61536: LD_INT 16
61538: PUSH
61539: LD_INT 25
61541: PUSH
61542: LD_INT 18
61544: PUSH
61545: EMPTY
61546: LIST
61547: LIST
61548: LIST
61549: LIST
61550: LIST
61551: LIST
61552: LIST
61553: LIST
61554: LIST
61555: LIST
61556: IN
61557: ST_TO_ADDR
// end ;
61558: LD_VAR 0 2
61562: RET
// export function GetBaseBuildings ( base , area , checkLink ) ; var tmp , i ; begin
61563: LD_INT 0
61565: PPUSH
61566: PPUSH
61567: PPUSH
// result := [ ] ;
61568: LD_ADDR_VAR 0 4
61572: PUSH
61573: EMPTY
61574: ST_TO_ADDR
// tmp := FilterUnitsInArea ( area , [ f_type , unit_building ] ) ;
61575: LD_ADDR_VAR 0 5
61579: PUSH
61580: LD_VAR 0 2
61584: PPUSH
61585: LD_INT 21
61587: PUSH
61588: LD_INT 3
61590: PUSH
61591: EMPTY
61592: LIST
61593: LIST
61594: PPUSH
61595: CALL_OW 70
61599: ST_TO_ADDR
// if not tmp then
61600: LD_VAR 0 5
61604: NOT
61605: IFFALSE 61609
// exit ;
61607: GO 61673
// if checkLink then
61609: LD_VAR 0 3
61613: IFFALSE 61663
// begin for i in tmp do
61615: LD_ADDR_VAR 0 6
61619: PUSH
61620: LD_VAR 0 5
61624: PUSH
61625: FOR_IN
61626: IFFALSE 61661
// if GetBase ( i ) <> base then
61628: LD_VAR 0 6
61632: PPUSH
61633: CALL_OW 274
61637: PUSH
61638: LD_VAR 0 1
61642: NONEQUAL
61643: IFFALSE 61659
// ComLinkToBase ( base , i ) ;
61645: LD_VAR 0 1
61649: PPUSH
61650: LD_VAR 0 6
61654: PPUSH
61655: CALL_OW 169
61659: GO 61625
61661: POP
61662: POP
// end ; result := tmp ;
61663: LD_ADDR_VAR 0 4
61667: PUSH
61668: LD_VAR 0 5
61672: ST_TO_ADDR
// end ;
61673: LD_VAR 0 4
61677: RET
// export function ComComplete ( units , b ) ; var i ; begin
61678: LD_INT 0
61680: PPUSH
61681: PPUSH
// if not units then
61682: LD_VAR 0 1
61686: NOT
61687: IFFALSE 61691
// exit ;
61689: GO 61781
// for i in units do
61691: LD_ADDR_VAR 0 4
61695: PUSH
61696: LD_VAR 0 1
61700: PUSH
61701: FOR_IN
61702: IFFALSE 61779
// if BuildingStatus ( b ) = bs_build then
61704: LD_VAR 0 2
61708: PPUSH
61709: CALL_OW 461
61713: PUSH
61714: LD_INT 1
61716: EQUAL
61717: IFFALSE 61777
// SetTaskList ( i , [ [ h , GetX ( b ) , GetY ( b ) , b , 0 , 0 , 0 ] ] ) ;
61719: LD_VAR 0 4
61723: PPUSH
61724: LD_STRING h
61726: PUSH
61727: LD_VAR 0 2
61731: PPUSH
61732: CALL_OW 250
61736: PUSH
61737: LD_VAR 0 2
61741: PPUSH
61742: CALL_OW 251
61746: PUSH
61747: LD_VAR 0 2
61751: PUSH
61752: LD_INT 0
61754: PUSH
61755: LD_INT 0
61757: PUSH
61758: LD_INT 0
61760: PUSH
61761: EMPTY
61762: LIST
61763: LIST
61764: LIST
61765: LIST
61766: LIST
61767: LIST
61768: LIST
61769: PUSH
61770: EMPTY
61771: LIST
61772: PPUSH
61773: CALL_OW 446
61777: GO 61701
61779: POP
61780: POP
// end ;
61781: LD_VAR 0 3
61785: RET
// export function Connect ( vehicle ) ; var i , t , mech , tmp , j ; begin
61786: LD_INT 0
61788: PPUSH
61789: PPUSH
61790: PPUSH
61791: PPUSH
61792: PPUSH
61793: PPUSH
// if not vehicle or GetControl ( vehicle ) <> control_remote then
61794: LD_VAR 0 1
61798: NOT
61799: PUSH
61800: LD_VAR 0 1
61804: PPUSH
61805: CALL_OW 263
61809: PUSH
61810: LD_INT 2
61812: NONEQUAL
61813: OR
61814: IFFALSE 61818
// exit ;
61816: GO 62134
// tmp := FilterAllUnits ( [ [ f_side , GetSide ( vehicle ) ] , [ f_or , [ f_btype , b_control_tower ] , [ f_weapon , ar_control_tower ] ] ] ) ;
61818: LD_ADDR_VAR 0 6
61822: PUSH
61823: LD_INT 22
61825: PUSH
61826: LD_VAR 0 1
61830: PPUSH
61831: CALL_OW 255
61835: PUSH
61836: EMPTY
61837: LIST
61838: LIST
61839: PUSH
61840: LD_INT 2
61842: PUSH
61843: LD_INT 30
61845: PUSH
61846: LD_INT 36
61848: PUSH
61849: EMPTY
61850: LIST
61851: LIST
61852: PUSH
61853: LD_INT 34
61855: PUSH
61856: LD_INT 31
61858: PUSH
61859: EMPTY
61860: LIST
61861: LIST
61862: PUSH
61863: EMPTY
61864: LIST
61865: LIST
61866: LIST
61867: PUSH
61868: EMPTY
61869: LIST
61870: LIST
61871: PPUSH
61872: CALL_OW 69
61876: ST_TO_ADDR
// if not tmp then
61877: LD_VAR 0 6
61881: NOT
61882: IFFALSE 61886
// exit ;
61884: GO 62134
// result := [ ] ;
61886: LD_ADDR_VAR 0 2
61890: PUSH
61891: EMPTY
61892: ST_TO_ADDR
// for i in tmp do
61893: LD_ADDR_VAR 0 3
61897: PUSH
61898: LD_VAR 0 6
61902: PUSH
61903: FOR_IN
61904: IFFALSE 61975
// begin t := UnitsInside ( i ) ;
61906: LD_ADDR_VAR 0 4
61910: PUSH
61911: LD_VAR 0 3
61915: PPUSH
61916: CALL_OW 313
61920: ST_TO_ADDR
// if t then
61921: LD_VAR 0 4
61925: IFFALSE 61973
// for j in t do
61927: LD_ADDR_VAR 0 7
61931: PUSH
61932: LD_VAR 0 4
61936: PUSH
61937: FOR_IN
61938: IFFALSE 61971
// result := Replace ( result , result + 1 , j ) ;
61940: LD_ADDR_VAR 0 2
61944: PUSH
61945: LD_VAR 0 2
61949: PPUSH
61950: LD_VAR 0 2
61954: PUSH
61955: LD_INT 1
61957: PLUS
61958: PPUSH
61959: LD_VAR 0 7
61963: PPUSH
61964: CALL_OW 1
61968: ST_TO_ADDR
61969: GO 61937
61971: POP
61972: POP
// end ;
61973: GO 61903
61975: POP
61976: POP
// if not result then
61977: LD_VAR 0 2
61981: NOT
61982: IFFALSE 61986
// exit ;
61984: GO 62134
// mech := result [ 1 ] ;
61986: LD_ADDR_VAR 0 5
61990: PUSH
61991: LD_VAR 0 2
61995: PUSH
61996: LD_INT 1
61998: ARRAY
61999: ST_TO_ADDR
// if result > 1 then
62000: LD_VAR 0 2
62004: PUSH
62005: LD_INT 1
62007: GREATER
62008: IFFALSE 62120
// begin for i = 2 to result do
62010: LD_ADDR_VAR 0 3
62014: PUSH
62015: DOUBLE
62016: LD_INT 2
62018: DEC
62019: ST_TO_ADDR
62020: LD_VAR 0 2
62024: PUSH
62025: FOR_TO
62026: IFFALSE 62118
// begin t := GetSkill ( result [ i ] , 3 ) - UnitsLinked ( result [ i ] ) ;
62028: LD_ADDR_VAR 0 4
62032: PUSH
62033: LD_VAR 0 2
62037: PUSH
62038: LD_VAR 0 3
62042: ARRAY
62043: PPUSH
62044: LD_INT 3
62046: PPUSH
62047: CALL_OW 259
62051: PUSH
62052: LD_VAR 0 2
62056: PUSH
62057: LD_VAR 0 3
62061: ARRAY
62062: PPUSH
62063: CALL_OW 432
62067: MINUS
62068: ST_TO_ADDR
// if t >= ( GetSkill ( mech , 3 ) - UnitsLinked ( mech ) ) then
62069: LD_VAR 0 4
62073: PUSH
62074: LD_VAR 0 5
62078: PPUSH
62079: LD_INT 3
62081: PPUSH
62082: CALL_OW 259
62086: PUSH
62087: LD_VAR 0 5
62091: PPUSH
62092: CALL_OW 432
62096: MINUS
62097: GREATEREQUAL
62098: IFFALSE 62116
// mech := result [ i ] ;
62100: LD_ADDR_VAR 0 5
62104: PUSH
62105: LD_VAR 0 2
62109: PUSH
62110: LD_VAR 0 3
62114: ARRAY
62115: ST_TO_ADDR
// end ;
62116: GO 62025
62118: POP
62119: POP
// end ; ComLinkTo ( vehicle , mech ) ;
62120: LD_VAR 0 1
62124: PPUSH
62125: LD_VAR 0 5
62129: PPUSH
62130: CALL_OW 135
// end ;
62134: LD_VAR 0 2
62138: RET
// export function PrepareBase ( base_dep , area , name , skill , sources , personel ) ; var i , j , d , b , f , x , un , base , side , nation , buildings , tmp ; begin
62139: LD_INT 0
62141: PPUSH
62142: PPUSH
62143: PPUSH
62144: PPUSH
62145: PPUSH
62146: PPUSH
62147: PPUSH
62148: PPUSH
62149: PPUSH
62150: PPUSH
62151: PPUSH
62152: PPUSH
62153: PPUSH
// result := [ ] ;
62154: LD_ADDR_VAR 0 7
62158: PUSH
62159: EMPTY
62160: ST_TO_ADDR
// if not GetBType ( base_dep ) in [ b_depot , b_warehouse ] then
62161: LD_VAR 0 1
62165: PPUSH
62166: CALL_OW 266
62170: PUSH
62171: LD_INT 0
62173: PUSH
62174: LD_INT 1
62176: PUSH
62177: EMPTY
62178: LIST
62179: LIST
62180: IN
62181: NOT
62182: IFFALSE 62186
// exit ;
62184: GO 63820
// if name then
62186: LD_VAR 0 3
62190: IFFALSE 62206
// SetBName ( base_dep , name ) ;
62192: LD_VAR 0 1
62196: PPUSH
62197: LD_VAR 0 3
62201: PPUSH
62202: CALL_OW 500
// base := GetBase ( base_dep ) ;
62206: LD_ADDR_VAR 0 15
62210: PUSH
62211: LD_VAR 0 1
62215: PPUSH
62216: CALL_OW 274
62220: ST_TO_ADDR
// side := GetSide ( base_dep ) ;
62221: LD_ADDR_VAR 0 16
62225: PUSH
62226: LD_VAR 0 1
62230: PPUSH
62231: CALL_OW 255
62235: ST_TO_ADDR
// nation := GetNation ( base_dep ) ;
62236: LD_ADDR_VAR 0 17
62240: PUSH
62241: LD_VAR 0 1
62245: PPUSH
62246: CALL_OW 248
62250: ST_TO_ADDR
// if sources then
62251: LD_VAR 0 5
62255: IFFALSE 62302
// for i = 1 to 3 do
62257: LD_ADDR_VAR 0 8
62261: PUSH
62262: DOUBLE
62263: LD_INT 1
62265: DEC
62266: ST_TO_ADDR
62267: LD_INT 3
62269: PUSH
62270: FOR_TO
62271: IFFALSE 62300
// AddResourceType ( base , i , sources [ i ] ) ;
62273: LD_VAR 0 15
62277: PPUSH
62278: LD_VAR 0 8
62282: PPUSH
62283: LD_VAR 0 5
62287: PUSH
62288: LD_VAR 0 8
62292: ARRAY
62293: PPUSH
62294: CALL_OW 276
62298: GO 62270
62300: POP
62301: POP
// buildings := GetBaseBuildings ( base , area , true ) ;
62302: LD_ADDR_VAR 0 18
62306: PUSH
62307: LD_VAR 0 15
62311: PPUSH
62312: LD_VAR 0 2
62316: PPUSH
62317: LD_INT 1
62319: PPUSH
62320: CALL 61563 0 3
62324: ST_TO_ADDR
// InitHc ;
62325: CALL_OW 19
// InitUc ;
62329: CALL_OW 18
// uc_side := side ;
62333: LD_ADDR_OWVAR 20
62337: PUSH
62338: LD_VAR 0 16
62342: ST_TO_ADDR
// uc_nation := nation ;
62343: LD_ADDR_OWVAR 21
62347: PUSH
62348: LD_VAR 0 17
62352: ST_TO_ADDR
// if buildings then
62353: LD_VAR 0 18
62357: IFFALSE 63679
// begin tmp := UnitFilter ( buildings , [ f_or , [ f_btype , b_oil_mine ] , [ f_btype , b_siberite_mine ] ] ) ;
62359: LD_ADDR_VAR 0 19
62363: PUSH
62364: LD_VAR 0 18
62368: PPUSH
62369: LD_INT 2
62371: PUSH
62372: LD_INT 30
62374: PUSH
62375: LD_INT 29
62377: PUSH
62378: EMPTY
62379: LIST
62380: LIST
62381: PUSH
62382: LD_INT 30
62384: PUSH
62385: LD_INT 30
62387: PUSH
62388: EMPTY
62389: LIST
62390: LIST
62391: PUSH
62392: EMPTY
62393: LIST
62394: LIST
62395: LIST
62396: PPUSH
62397: CALL_OW 72
62401: ST_TO_ADDR
// if tmp then
62402: LD_VAR 0 19
62406: IFFALSE 62454
// for i in tmp do
62408: LD_ADDR_VAR 0 8
62412: PUSH
62413: LD_VAR 0 19
62417: PUSH
62418: FOR_IN
62419: IFFALSE 62452
// SetResourceVisibility ( GetX ( i ) , GetY ( i ) , side ) ;
62421: LD_VAR 0 8
62425: PPUSH
62426: CALL_OW 250
62430: PPUSH
62431: LD_VAR 0 8
62435: PPUSH
62436: CALL_OW 251
62440: PPUSH
62441: LD_VAR 0 16
62445: PPUSH
62446: CALL_OW 441
62450: GO 62418
62452: POP
62453: POP
// if UnitFilter ( buildings , [ f_or , [ f_btype , b_bunker ] , [ f_btype , b_turret ] ] ) then
62454: LD_VAR 0 18
62458: PPUSH
62459: LD_INT 2
62461: PUSH
62462: LD_INT 30
62464: PUSH
62465: LD_INT 32
62467: PUSH
62468: EMPTY
62469: LIST
62470: LIST
62471: PUSH
62472: LD_INT 30
62474: PUSH
62475: LD_INT 33
62477: PUSH
62478: EMPTY
62479: LIST
62480: LIST
62481: PUSH
62482: EMPTY
62483: LIST
62484: LIST
62485: LIST
62486: PPUSH
62487: CALL_OW 72
62491: IFFALSE 62579
// begin for i in UnitFilter ( buildings , [ f_or , [ f_btype , b_bunker ] , [ f_btype , b_turret ] ] ) do
62493: LD_ADDR_VAR 0 8
62497: PUSH
62498: LD_VAR 0 18
62502: PPUSH
62503: LD_INT 2
62505: PUSH
62506: LD_INT 30
62508: PUSH
62509: LD_INT 32
62511: PUSH
62512: EMPTY
62513: LIST
62514: LIST
62515: PUSH
62516: LD_INT 30
62518: PUSH
62519: LD_INT 33
62521: PUSH
62522: EMPTY
62523: LIST
62524: LIST
62525: PUSH
62526: EMPTY
62527: LIST
62528: LIST
62529: LIST
62530: PPUSH
62531: CALL_OW 72
62535: PUSH
62536: FOR_IN
62537: IFFALSE 62577
// begin if not GetBWeapon ( i ) then
62539: LD_VAR 0 8
62543: PPUSH
62544: CALL_OW 269
62548: NOT
62549: IFFALSE 62575
// PlaceWeaponTurret ( i , GetTurretWeapon ( i , area ) ) ;
62551: LD_VAR 0 8
62555: PPUSH
62556: LD_VAR 0 8
62560: PPUSH
62561: LD_VAR 0 2
62565: PPUSH
62566: CALL 63825 0 2
62570: PPUSH
62571: CALL_OW 431
// end ;
62575: GO 62536
62577: POP
62578: POP
// end ; for i = 1 to personel do
62579: LD_ADDR_VAR 0 8
62583: PUSH
62584: DOUBLE
62585: LD_INT 1
62587: DEC
62588: ST_TO_ADDR
62589: LD_VAR 0 6
62593: PUSH
62594: FOR_TO
62595: IFFALSE 63659
// begin if i > 4 then
62597: LD_VAR 0 8
62601: PUSH
62602: LD_INT 4
62604: GREATER
62605: IFFALSE 62609
// break ;
62607: GO 63659
// case i of 1 :
62609: LD_VAR 0 8
62613: PUSH
62614: LD_INT 1
62616: DOUBLE
62617: EQUAL
62618: IFTRUE 62622
62620: GO 62702
62622: POP
// f := UnitFilter ( buildings , [ [ f_side , side ] , [ f_empty ] , [ f_or , [ f_btype , b_bunker ] , [ f_btype , b_armoury ] , [ f_btype , b_barracks ] ] ] ) ; 2 :
62623: LD_ADDR_VAR 0 12
62627: PUSH
62628: LD_VAR 0 18
62632: PPUSH
62633: LD_INT 22
62635: PUSH
62636: LD_VAR 0 16
62640: PUSH
62641: EMPTY
62642: LIST
62643: LIST
62644: PUSH
62645: LD_INT 58
62647: PUSH
62648: EMPTY
62649: LIST
62650: PUSH
62651: LD_INT 2
62653: PUSH
62654: LD_INT 30
62656: PUSH
62657: LD_INT 32
62659: PUSH
62660: EMPTY
62661: LIST
62662: LIST
62663: PUSH
62664: LD_INT 30
62666: PUSH
62667: LD_INT 4
62669: PUSH
62670: EMPTY
62671: LIST
62672: LIST
62673: PUSH
62674: LD_INT 30
62676: PUSH
62677: LD_INT 5
62679: PUSH
62680: EMPTY
62681: LIST
62682: LIST
62683: PUSH
62684: EMPTY
62685: LIST
62686: LIST
62687: LIST
62688: LIST
62689: PUSH
62690: EMPTY
62691: LIST
62692: LIST
62693: LIST
62694: PPUSH
62695: CALL_OW 72
62699: ST_TO_ADDR
62700: GO 62924
62702: LD_INT 2
62704: DOUBLE
62705: EQUAL
62706: IFTRUE 62710
62708: GO 62772
62710: POP
// f := UnitFilter ( buildings , [ [ f_side , side ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ] ) ; 3 :
62711: LD_ADDR_VAR 0 12
62715: PUSH
62716: LD_VAR 0 18
62720: PPUSH
62721: LD_INT 22
62723: PUSH
62724: LD_VAR 0 16
62728: PUSH
62729: EMPTY
62730: LIST
62731: LIST
62732: PUSH
62733: LD_INT 2
62735: PUSH
62736: LD_INT 30
62738: PUSH
62739: LD_INT 0
62741: PUSH
62742: EMPTY
62743: LIST
62744: LIST
62745: PUSH
62746: LD_INT 30
62748: PUSH
62749: LD_INT 1
62751: PUSH
62752: EMPTY
62753: LIST
62754: LIST
62755: PUSH
62756: EMPTY
62757: LIST
62758: LIST
62759: LIST
62760: PUSH
62761: EMPTY
62762: LIST
62763: LIST
62764: PPUSH
62765: CALL_OW 72
62769: ST_TO_ADDR
62770: GO 62924
62772: LD_INT 3
62774: DOUBLE
62775: EQUAL
62776: IFTRUE 62780
62778: GO 62842
62780: POP
// f := UnitFilter ( buildings , [ [ f_side , side ] , [ f_or , [ f_btype , b_workshop ] , [ f_btype , b_factory ] ] ] ) ; 4 :
62781: LD_ADDR_VAR 0 12
62785: PUSH
62786: LD_VAR 0 18
62790: PPUSH
62791: LD_INT 22
62793: PUSH
62794: LD_VAR 0 16
62798: PUSH
62799: EMPTY
62800: LIST
62801: LIST
62802: PUSH
62803: LD_INT 2
62805: PUSH
62806: LD_INT 30
62808: PUSH
62809: LD_INT 2
62811: PUSH
62812: EMPTY
62813: LIST
62814: LIST
62815: PUSH
62816: LD_INT 30
62818: PUSH
62819: LD_INT 3
62821: PUSH
62822: EMPTY
62823: LIST
62824: LIST
62825: PUSH
62826: EMPTY
62827: LIST
62828: LIST
62829: LIST
62830: PUSH
62831: EMPTY
62832: LIST
62833: LIST
62834: PPUSH
62835: CALL_OW 72
62839: ST_TO_ADDR
62840: GO 62924
62842: LD_INT 4
62844: DOUBLE
62845: EQUAL
62846: IFTRUE 62850
62848: GO 62923
62850: POP
// f := UnitFilter ( buildings , [ [ f_side , side ] , [ f_or , [ f_btype , b_lab ] , [ f_btype , b_lab_half ] , [ f_btype , b_lab_full ] ] ] ) ; end ;
62851: LD_ADDR_VAR 0 12
62855: PUSH
62856: LD_VAR 0 18
62860: PPUSH
62861: LD_INT 22
62863: PUSH
62864: LD_VAR 0 16
62868: PUSH
62869: EMPTY
62870: LIST
62871: LIST
62872: PUSH
62873: LD_INT 2
62875: PUSH
62876: LD_INT 30
62878: PUSH
62879: LD_INT 6
62881: PUSH
62882: EMPTY
62883: LIST
62884: LIST
62885: PUSH
62886: LD_INT 30
62888: PUSH
62889: LD_INT 7
62891: PUSH
62892: EMPTY
62893: LIST
62894: LIST
62895: PUSH
62896: LD_INT 30
62898: PUSH
62899: LD_INT 8
62901: PUSH
62902: EMPTY
62903: LIST
62904: LIST
62905: PUSH
62906: EMPTY
62907: LIST
62908: LIST
62909: LIST
62910: LIST
62911: PUSH
62912: EMPTY
62913: LIST
62914: LIST
62915: PPUSH
62916: CALL_OW 72
62920: ST_TO_ADDR
62921: GO 62924
62923: POP
// if i = 1 then
62924: LD_VAR 0 8
62928: PUSH
62929: LD_INT 1
62931: EQUAL
62932: IFFALSE 63043
// begin tmp := [ ] ;
62934: LD_ADDR_VAR 0 19
62938: PUSH
62939: EMPTY
62940: ST_TO_ADDR
// for j in f do
62941: LD_ADDR_VAR 0 9
62945: PUSH
62946: LD_VAR 0 12
62950: PUSH
62951: FOR_IN
62952: IFFALSE 63025
// if GetBType ( j ) = b_bunker then
62954: LD_VAR 0 9
62958: PPUSH
62959: CALL_OW 266
62963: PUSH
62964: LD_INT 32
62966: EQUAL
62967: IFFALSE 62994
// tmp := Insert ( tmp , 1 , j ) else
62969: LD_ADDR_VAR 0 19
62973: PUSH
62974: LD_VAR 0 19
62978: PPUSH
62979: LD_INT 1
62981: PPUSH
62982: LD_VAR 0 9
62986: PPUSH
62987: CALL_OW 2
62991: ST_TO_ADDR
62992: GO 63023
// tmp := Insert ( tmp , tmp + 1 , j ) ;
62994: LD_ADDR_VAR 0 19
62998: PUSH
62999: LD_VAR 0 19
63003: PPUSH
63004: LD_VAR 0 19
63008: PUSH
63009: LD_INT 1
63011: PLUS
63012: PPUSH
63013: LD_VAR 0 9
63017: PPUSH
63018: CALL_OW 2
63022: ST_TO_ADDR
63023: GO 62951
63025: POP
63026: POP
// if tmp then
63027: LD_VAR 0 19
63031: IFFALSE 63043
// f := tmp ;
63033: LD_ADDR_VAR 0 12
63037: PUSH
63038: LD_VAR 0 19
63042: ST_TO_ADDR
// end ; x := personel [ i ] ;
63043: LD_ADDR_VAR 0 13
63047: PUSH
63048: LD_VAR 0 6
63052: PUSH
63053: LD_VAR 0 8
63057: ARRAY
63058: ST_TO_ADDR
// if x = - 1 then
63059: LD_VAR 0 13
63063: PUSH
63064: LD_INT 1
63066: NEG
63067: EQUAL
63068: IFFALSE 63277
// begin for j in f do
63070: LD_ADDR_VAR 0 9
63074: PUSH
63075: LD_VAR 0 12
63079: PUSH
63080: FOR_IN
63081: IFFALSE 63273
// repeat InitHc ;
63083: CALL_OW 19
// if GetBType ( j ) = b_barracks then
63087: LD_VAR 0 9
63091: PPUSH
63092: CALL_OW 266
63096: PUSH
63097: LD_INT 5
63099: EQUAL
63100: IFFALSE 63170
// begin if UnitsInside ( j ) < 3 then
63102: LD_VAR 0 9
63106: PPUSH
63107: CALL_OW 313
63111: PUSH
63112: LD_INT 3
63114: LESS
63115: IFFALSE 63151
// PrepareHuman ( false , [ class_sniper , class_mortar , class_bazooker ] [ nation ] , skill ) else
63117: LD_INT 0
63119: PPUSH
63120: LD_INT 5
63122: PUSH
63123: LD_INT 8
63125: PUSH
63126: LD_INT 9
63128: PUSH
63129: EMPTY
63130: LIST
63131: LIST
63132: LIST
63133: PUSH
63134: LD_VAR 0 17
63138: ARRAY
63139: PPUSH
63140: LD_VAR 0 4
63144: PPUSH
63145: CALL_OW 380
63149: GO 63168
// PrepareHuman ( false , i , skill ) ;
63151: LD_INT 0
63153: PPUSH
63154: LD_VAR 0 8
63158: PPUSH
63159: LD_VAR 0 4
63163: PPUSH
63164: CALL_OW 380
// end else
63168: GO 63187
// PrepareHuman ( false , i , skill ) ;
63170: LD_INT 0
63172: PPUSH
63173: LD_VAR 0 8
63177: PPUSH
63178: LD_VAR 0 4
63182: PPUSH
63183: CALL_OW 380
// un := CreateHuman ;
63187: LD_ADDR_VAR 0 14
63191: PUSH
63192: CALL_OW 44
63196: ST_TO_ADDR
// result := Insert ( result , 1 , un ) ;
63197: LD_ADDR_VAR 0 7
63201: PUSH
63202: LD_VAR 0 7
63206: PPUSH
63207: LD_INT 1
63209: PPUSH
63210: LD_VAR 0 14
63214: PPUSH
63215: CALL_OW 2
63219: ST_TO_ADDR
// PlaceHumanInUnit ( un , j ) ;
63220: LD_VAR 0 14
63224: PPUSH
63225: LD_VAR 0 9
63229: PPUSH
63230: CALL_OW 52
// until UnitsInside ( j ) = 6 or GetBType ( j ) in [ b_bunker , b_breastwork ] ;
63234: LD_VAR 0 9
63238: PPUSH
63239: CALL_OW 313
63243: PUSH
63244: LD_INT 6
63246: EQUAL
63247: PUSH
63248: LD_VAR 0 9
63252: PPUSH
63253: CALL_OW 266
63257: PUSH
63258: LD_INT 32
63260: PUSH
63261: LD_INT 31
63263: PUSH
63264: EMPTY
63265: LIST
63266: LIST
63267: IN
63268: OR
63269: IFFALSE 63083
63271: GO 63080
63273: POP
63274: POP
// end else
63275: GO 63657
// for j = 1 to x do
63277: LD_ADDR_VAR 0 9
63281: PUSH
63282: DOUBLE
63283: LD_INT 1
63285: DEC
63286: ST_TO_ADDR
63287: LD_VAR 0 13
63291: PUSH
63292: FOR_TO
63293: IFFALSE 63655
// begin InitHc ;
63295: CALL_OW 19
// if not f then
63299: LD_VAR 0 12
63303: NOT
63304: IFFALSE 63393
// begin PrepareHuman ( false , i , skill ) ;
63306: LD_INT 0
63308: PPUSH
63309: LD_VAR 0 8
63313: PPUSH
63314: LD_VAR 0 4
63318: PPUSH
63319: CALL_OW 380
// un := CreateHuman ;
63323: LD_ADDR_VAR 0 14
63327: PUSH
63328: CALL_OW 44
63332: ST_TO_ADDR
// result := Insert ( result , 1 , un ) ;
63333: LD_ADDR_VAR 0 7
63337: PUSH
63338: LD_VAR 0 7
63342: PPUSH
63343: LD_INT 1
63345: PPUSH
63346: LD_VAR 0 14
63350: PPUSH
63351: CALL_OW 2
63355: ST_TO_ADDR
// PlaceUnitXYR ( un , GetX ( base_dep ) , GetY ( base_dep ) , 10 , false ) ;
63356: LD_VAR 0 14
63360: PPUSH
63361: LD_VAR 0 1
63365: PPUSH
63366: CALL_OW 250
63370: PPUSH
63371: LD_VAR 0 1
63375: PPUSH
63376: CALL_OW 251
63380: PPUSH
63381: LD_INT 10
63383: PPUSH
63384: LD_INT 0
63386: PPUSH
63387: CALL_OW 50
// continue ;
63391: GO 63292
// end ; if ( UnitsInside ( f [ 1 ] ) and GetBType ( f [ 1 ] ) in [ b_bunker , b_breastwork ] ) or ( UnitsInside ( f [ 1 ] ) = 6 ) then
63393: LD_VAR 0 12
63397: PUSH
63398: LD_INT 1
63400: ARRAY
63401: PPUSH
63402: CALL_OW 313
63406: PUSH
63407: LD_VAR 0 12
63411: PUSH
63412: LD_INT 1
63414: ARRAY
63415: PPUSH
63416: CALL_OW 266
63420: PUSH
63421: LD_INT 32
63423: PUSH
63424: LD_INT 31
63426: PUSH
63427: EMPTY
63428: LIST
63429: LIST
63430: IN
63431: AND
63432: PUSH
63433: LD_VAR 0 12
63437: PUSH
63438: LD_INT 1
63440: ARRAY
63441: PPUSH
63442: CALL_OW 313
63446: PUSH
63447: LD_INT 6
63449: EQUAL
63450: OR
63451: IFFALSE 63471
// f := Delete ( f , 1 ) ;
63453: LD_ADDR_VAR 0 12
63457: PUSH
63458: LD_VAR 0 12
63462: PPUSH
63463: LD_INT 1
63465: PPUSH
63466: CALL_OW 3
63470: ST_TO_ADDR
// if not f then
63471: LD_VAR 0 12
63475: NOT
63476: IFFALSE 63494
// begin x := x + 2 ;
63478: LD_ADDR_VAR 0 13
63482: PUSH
63483: LD_VAR 0 13
63487: PUSH
63488: LD_INT 2
63490: PLUS
63491: ST_TO_ADDR
// continue ;
63492: GO 63292
// end ; if GetBType ( f [ 1 ] ) = b_barracks then
63494: LD_VAR 0 12
63498: PUSH
63499: LD_INT 1
63501: ARRAY
63502: PPUSH
63503: CALL_OW 266
63507: PUSH
63508: LD_INT 5
63510: EQUAL
63511: IFFALSE 63585
// begin if UnitsInside ( f [ 1 ] ) < 3 then
63513: LD_VAR 0 12
63517: PUSH
63518: LD_INT 1
63520: ARRAY
63521: PPUSH
63522: CALL_OW 313
63526: PUSH
63527: LD_INT 3
63529: LESS
63530: IFFALSE 63566
// PrepareHuman ( false , [ class_sniper , class_mortar , class_bazooker ] [ nation ] , skill ) else
63532: LD_INT 0
63534: PPUSH
63535: LD_INT 5
63537: PUSH
63538: LD_INT 8
63540: PUSH
63541: LD_INT 9
63543: PUSH
63544: EMPTY
63545: LIST
63546: LIST
63547: LIST
63548: PUSH
63549: LD_VAR 0 17
63553: ARRAY
63554: PPUSH
63555: LD_VAR 0 4
63559: PPUSH
63560: CALL_OW 380
63564: GO 63583
// PrepareHuman ( false , i , skill ) ;
63566: LD_INT 0
63568: PPUSH
63569: LD_VAR 0 8
63573: PPUSH
63574: LD_VAR 0 4
63578: PPUSH
63579: CALL_OW 380
// end else
63583: GO 63602
// PrepareHuman ( false , i , skill ) ;
63585: LD_INT 0
63587: PPUSH
63588: LD_VAR 0 8
63592: PPUSH
63593: LD_VAR 0 4
63597: PPUSH
63598: CALL_OW 380
// un := CreateHuman ;
63602: LD_ADDR_VAR 0 14
63606: PUSH
63607: CALL_OW 44
63611: ST_TO_ADDR
// result := Insert ( result , 1 , un ) ;
63612: LD_ADDR_VAR 0 7
63616: PUSH
63617: LD_VAR 0 7
63621: PPUSH
63622: LD_INT 1
63624: PPUSH
63625: LD_VAR 0 14
63629: PPUSH
63630: CALL_OW 2
63634: ST_TO_ADDR
// PlaceHumanInUnit ( un , f [ 1 ] ) ;
63635: LD_VAR 0 14
63639: PPUSH
63640: LD_VAR 0 12
63644: PUSH
63645: LD_INT 1
63647: ARRAY
63648: PPUSH
63649: CALL_OW 52
// end ;
63653: GO 63292
63655: POP
63656: POP
// end ;
63657: GO 62594
63659: POP
63660: POP
// result := result ^ buildings ;
63661: LD_ADDR_VAR 0 7
63665: PUSH
63666: LD_VAR 0 7
63670: PUSH
63671: LD_VAR 0 18
63675: ADD
63676: ST_TO_ADDR
// end else
63677: GO 63820
// begin for i = 1 to personel do
63679: LD_ADDR_VAR 0 8
63683: PUSH
63684: DOUBLE
63685: LD_INT 1
63687: DEC
63688: ST_TO_ADDR
63689: LD_VAR 0 6
63693: PUSH
63694: FOR_TO
63695: IFFALSE 63818
// begin if i > 4 then
63697: LD_VAR 0 8
63701: PUSH
63702: LD_INT 4
63704: GREATER
63705: IFFALSE 63709
// break ;
63707: GO 63818
// x := personel [ i ] ;
63709: LD_ADDR_VAR 0 13
63713: PUSH
63714: LD_VAR 0 6
63718: PUSH
63719: LD_VAR 0 8
63723: ARRAY
63724: ST_TO_ADDR
// if x = - 1 then
63725: LD_VAR 0 13
63729: PUSH
63730: LD_INT 1
63732: NEG
63733: EQUAL
63734: IFFALSE 63738
// continue ;
63736: GO 63694
// PrepareHuman ( false , i , skill ) ;
63738: LD_INT 0
63740: PPUSH
63741: LD_VAR 0 8
63745: PPUSH
63746: LD_VAR 0 4
63750: PPUSH
63751: CALL_OW 380
// un := CreateHuman ;
63755: LD_ADDR_VAR 0 14
63759: PUSH
63760: CALL_OW 44
63764: ST_TO_ADDR
// PlaceUnitXYR ( un , GetX ( base_dep ) , GetY ( base_dep ) , 10 , false ) ;
63765: LD_VAR 0 14
63769: PPUSH
63770: LD_VAR 0 1
63774: PPUSH
63775: CALL_OW 250
63779: PPUSH
63780: LD_VAR 0 1
63784: PPUSH
63785: CALL_OW 251
63789: PPUSH
63790: LD_INT 10
63792: PPUSH
63793: LD_INT 0
63795: PPUSH
63796: CALL_OW 50
// result := result ^ un ;
63800: LD_ADDR_VAR 0 7
63804: PUSH
63805: LD_VAR 0 7
63809: PUSH
63810: LD_VAR 0 14
63814: ADD
63815: ST_TO_ADDR
// end ;
63816: GO 63694
63818: POP
63819: POP
// end ; end ;
63820: LD_VAR 0 7
63824: RET
// export function GetTurretWeapon ( tower , area ) ; var hex , list , factories , base , i , j , x , y , nat , h , tmp , height , side , fac_list , weapon ; begin
63825: LD_INT 0
63827: PPUSH
63828: PPUSH
63829: PPUSH
63830: PPUSH
63831: PPUSH
63832: PPUSH
63833: PPUSH
63834: PPUSH
63835: PPUSH
63836: PPUSH
63837: PPUSH
63838: PPUSH
63839: PPUSH
63840: PPUSH
63841: PPUSH
63842: PPUSH
// result := false ;
63843: LD_ADDR_VAR 0 3
63847: PUSH
63848: LD_INT 0
63850: ST_TO_ADDR
// if not tower or not GetBType ( tower ) in [ b_bunker , b_turret ] then
63851: LD_VAR 0 1
63855: NOT
63856: PUSH
63857: LD_VAR 0 1
63861: PPUSH
63862: CALL_OW 266
63866: PUSH
63867: LD_INT 32
63869: PUSH
63870: LD_INT 33
63872: PUSH
63873: EMPTY
63874: LIST
63875: LIST
63876: IN
63877: NOT
63878: OR
63879: IFFALSE 63883
// exit ;
63881: GO 64992
// nat := GetNation ( tower ) ;
63883: LD_ADDR_VAR 0 12
63887: PUSH
63888: LD_VAR 0 1
63892: PPUSH
63893: CALL_OW 248
63897: ST_TO_ADDR
// side := GetSide ( tower ) ;
63898: LD_ADDR_VAR 0 16
63902: PUSH
63903: LD_VAR 0 1
63907: PPUSH
63908: CALL_OW 255
63912: ST_TO_ADDR
// x := GetX ( tower ) ;
63913: LD_ADDR_VAR 0 10
63917: PUSH
63918: LD_VAR 0 1
63922: PPUSH
63923: CALL_OW 250
63927: ST_TO_ADDR
// y := GetY ( tower ) ;
63928: LD_ADDR_VAR 0 11
63932: PUSH
63933: LD_VAR 0 1
63937: PPUSH
63938: CALL_OW 251
63942: ST_TO_ADDR
// if not x or not y then
63943: LD_VAR 0 10
63947: NOT
63948: PUSH
63949: LD_VAR 0 11
63953: NOT
63954: OR
63955: IFFALSE 63959
// exit ;
63957: GO 64992
// weapon := 0 ;
63959: LD_ADDR_VAR 0 18
63963: PUSH
63964: LD_INT 0
63966: ST_TO_ADDR
// fac_list := [ ] ;
63967: LD_ADDR_VAR 0 17
63971: PUSH
63972: EMPTY
63973: ST_TO_ADDR
// factories := UnitFilter ( GetBaseBuildings ( GetBase ( tower ) , area , false ) , [ f_btype , b_factory ] ) ;
63974: LD_ADDR_VAR 0 6
63978: PUSH
63979: LD_VAR 0 1
63983: PPUSH
63984: CALL_OW 274
63988: PPUSH
63989: LD_VAR 0 2
63993: PPUSH
63994: LD_INT 0
63996: PPUSH
63997: CALL 61563 0 3
64001: PPUSH
64002: LD_INT 30
64004: PUSH
64005: LD_INT 3
64007: PUSH
64008: EMPTY
64009: LIST
64010: LIST
64011: PPUSH
64012: CALL_OW 72
64016: ST_TO_ADDR
// if not factories then
64017: LD_VAR 0 6
64021: NOT
64022: IFFALSE 64026
// exit ;
64024: GO 64992
// for i in factories do
64026: LD_ADDR_VAR 0 8
64030: PUSH
64031: LD_VAR 0 6
64035: PUSH
64036: FOR_IN
64037: IFFALSE 64062
// fac_list := fac_list union AvailableWeaponList ( i ) ;
64039: LD_ADDR_VAR 0 17
64043: PUSH
64044: LD_VAR 0 17
64048: PUSH
64049: LD_VAR 0 8
64053: PPUSH
64054: CALL_OW 478
64058: UNION
64059: ST_TO_ADDR
64060: GO 64036
64062: POP
64063: POP
// if not fac_list then
64064: LD_VAR 0 17
64068: NOT
64069: IFFALSE 64073
// exit ;
64071: GO 64992
// list := [ [ us_gatling_gun , us_double_gun , us_laser , us_double_laser , us_heavy_gun , us_rocket_launcher , us_radar ] , [ ar_gun , ar_rocket_launcher , ar_flame_thrower , ar_radar ] , [ ru_gatling_gun , ru_gun , ru_heavy_gun , ru_rocket_launcher , ru_rocket , ru_time_lapser ] ] [ nat ] ;
64073: LD_ADDR_VAR 0 5
64077: PUSH
64078: LD_INT 4
64080: PUSH
64081: LD_INT 5
64083: PUSH
64084: LD_INT 9
64086: PUSH
64087: LD_INT 10
64089: PUSH
64090: LD_INT 6
64092: PUSH
64093: LD_INT 7
64095: PUSH
64096: LD_INT 11
64098: PUSH
64099: EMPTY
64100: LIST
64101: LIST
64102: LIST
64103: LIST
64104: LIST
64105: LIST
64106: LIST
64107: PUSH
64108: LD_INT 27
64110: PUSH
64111: LD_INT 28
64113: PUSH
64114: LD_INT 26
64116: PUSH
64117: LD_INT 30
64119: PUSH
64120: EMPTY
64121: LIST
64122: LIST
64123: LIST
64124: LIST
64125: PUSH
64126: LD_INT 43
64128: PUSH
64129: LD_INT 44
64131: PUSH
64132: LD_INT 46
64134: PUSH
64135: LD_INT 45
64137: PUSH
64138: LD_INT 47
64140: PUSH
64141: LD_INT 49
64143: PUSH
64144: EMPTY
64145: LIST
64146: LIST
64147: LIST
64148: LIST
64149: LIST
64150: LIST
64151: PUSH
64152: EMPTY
64153: LIST
64154: LIST
64155: LIST
64156: PUSH
64157: LD_VAR 0 12
64161: ARRAY
64162: ST_TO_ADDR
// list := list isect fac_list ;
64163: LD_ADDR_VAR 0 5
64167: PUSH
64168: LD_VAR 0 5
64172: PUSH
64173: LD_VAR 0 17
64177: ISECT
64178: ST_TO_ADDR
// if not list then
64179: LD_VAR 0 5
64183: NOT
64184: IFFALSE 64188
// exit ;
64186: GO 64992
// if nat = nation_russian and ru_time_lapser in list and GetTech ( tech_lapser , side ) = state_researched then
64188: LD_VAR 0 12
64192: PUSH
64193: LD_INT 3
64195: EQUAL
64196: PUSH
64197: LD_INT 49
64199: PUSH
64200: LD_VAR 0 5
64204: IN
64205: AND
64206: PUSH
64207: LD_INT 31
64209: PPUSH
64210: LD_VAR 0 16
64214: PPUSH
64215: CALL_OW 321
64219: PUSH
64220: LD_INT 2
64222: EQUAL
64223: AND
64224: IFFALSE 64284
// begin if not FilterAllUnits ( [ [ f_side , side ] , [ f_bweapon , ru_time_lapser ] , [ f_dist , tower , 10 ] ] ) then
64226: LD_INT 22
64228: PUSH
64229: LD_VAR 0 16
64233: PUSH
64234: EMPTY
64235: LIST
64236: LIST
64237: PUSH
64238: LD_INT 35
64240: PUSH
64241: LD_INT 49
64243: PUSH
64244: EMPTY
64245: LIST
64246: LIST
64247: PUSH
64248: LD_INT 91
64250: PUSH
64251: LD_VAR 0 1
64255: PUSH
64256: LD_INT 10
64258: PUSH
64259: EMPTY
64260: LIST
64261: LIST
64262: LIST
64263: PUSH
64264: EMPTY
64265: LIST
64266: LIST
64267: LIST
64268: PPUSH
64269: CALL_OW 69
64273: NOT
64274: IFFALSE 64284
// weapon := ru_time_lapser ;
64276: LD_ADDR_VAR 0 18
64280: PUSH
64281: LD_INT 49
64283: ST_TO_ADDR
// end ; if nat in [ 1 , 2 ] and ( us_radar in list or ar_radar in list ) and GetTech ( tech_radar , side ) = state_researched then
64284: LD_VAR 0 12
64288: PUSH
64289: LD_INT 1
64291: PUSH
64292: LD_INT 2
64294: PUSH
64295: EMPTY
64296: LIST
64297: LIST
64298: IN
64299: PUSH
64300: LD_INT 11
64302: PUSH
64303: LD_VAR 0 5
64307: IN
64308: PUSH
64309: LD_INT 30
64311: PUSH
64312: LD_VAR 0 5
64316: IN
64317: OR
64318: AND
64319: PUSH
64320: LD_INT 6
64322: PPUSH
64323: LD_VAR 0 16
64327: PPUSH
64328: CALL_OW 321
64332: PUSH
64333: LD_INT 2
64335: EQUAL
64336: AND
64337: IFFALSE 64502
// begin if not FilterAllUnits ( [ [ f_side , side ] , [ f_or , [ f_bweapon , us_radar ] , [ f_bweapon , ar_radar ] ] , [ f_dist , tower , 18 ] ] ) and FilterAllUnits ( [ [ [ f_side , side ] , [ f_or , [ f_btype , b_bunker ] , [ f_btype , b_turret ] ] , [ f_dist , tower , 12 ] ] ] ) > 2 then
64339: LD_INT 22
64341: PUSH
64342: LD_VAR 0 16
64346: PUSH
64347: EMPTY
64348: LIST
64349: LIST
64350: PUSH
64351: LD_INT 2
64353: PUSH
64354: LD_INT 35
64356: PUSH
64357: LD_INT 11
64359: PUSH
64360: EMPTY
64361: LIST
64362: LIST
64363: PUSH
64364: LD_INT 35
64366: PUSH
64367: LD_INT 30
64369: PUSH
64370: EMPTY
64371: LIST
64372: LIST
64373: PUSH
64374: EMPTY
64375: LIST
64376: LIST
64377: LIST
64378: PUSH
64379: LD_INT 91
64381: PUSH
64382: LD_VAR 0 1
64386: PUSH
64387: LD_INT 18
64389: PUSH
64390: EMPTY
64391: LIST
64392: LIST
64393: LIST
64394: PUSH
64395: EMPTY
64396: LIST
64397: LIST
64398: LIST
64399: PPUSH
64400: CALL_OW 69
64404: NOT
64405: PUSH
64406: LD_INT 22
64408: PUSH
64409: LD_VAR 0 16
64413: PUSH
64414: EMPTY
64415: LIST
64416: LIST
64417: PUSH
64418: LD_INT 2
64420: PUSH
64421: LD_INT 30
64423: PUSH
64424: LD_INT 32
64426: PUSH
64427: EMPTY
64428: LIST
64429: LIST
64430: PUSH
64431: LD_INT 30
64433: PUSH
64434: LD_INT 33
64436: PUSH
64437: EMPTY
64438: LIST
64439: LIST
64440: PUSH
64441: EMPTY
64442: LIST
64443: LIST
64444: LIST
64445: PUSH
64446: LD_INT 91
64448: PUSH
64449: LD_VAR 0 1
64453: PUSH
64454: LD_INT 12
64456: PUSH
64457: EMPTY
64458: LIST
64459: LIST
64460: LIST
64461: PUSH
64462: EMPTY
64463: LIST
64464: LIST
64465: LIST
64466: PUSH
64467: EMPTY
64468: LIST
64469: PPUSH
64470: CALL_OW 69
64474: PUSH
64475: LD_INT 2
64477: GREATER
64478: AND
64479: IFFALSE 64502
// weapon := [ us_radar , ar_radar ] [ nat ] ;
64481: LD_ADDR_VAR 0 18
64485: PUSH
64486: LD_INT 11
64488: PUSH
64489: LD_INT 30
64491: PUSH
64492: EMPTY
64493: LIST
64494: LIST
64495: PUSH
64496: LD_VAR 0 12
64500: ARRAY
64501: ST_TO_ADDR
// end ; if not weapon and GetTech ( tech_rocket , side ) = state_researched and ( us_rocket_launcher in list or ar_rocket_launcher in list or ru_rocket_launcher in list ) then
64502: LD_VAR 0 18
64506: NOT
64507: PUSH
64508: LD_INT 40
64510: PPUSH
64511: LD_VAR 0 16
64515: PPUSH
64516: CALL_OW 321
64520: PUSH
64521: LD_INT 2
64523: EQUAL
64524: AND
64525: PUSH
64526: LD_INT 7
64528: PUSH
64529: LD_VAR 0 5
64533: IN
64534: PUSH
64535: LD_INT 28
64537: PUSH
64538: LD_VAR 0 5
64542: IN
64543: OR
64544: PUSH
64545: LD_INT 45
64547: PUSH
64548: LD_VAR 0 5
64552: IN
64553: OR
64554: AND
64555: IFFALSE 64809
// begin hex := GetHexInfo ( x , y ) ;
64557: LD_ADDR_VAR 0 4
64561: PUSH
64562: LD_VAR 0 10
64566: PPUSH
64567: LD_VAR 0 11
64571: PPUSH
64572: CALL_OW 546
64576: ST_TO_ADDR
// if hex [ 1 ] then
64577: LD_VAR 0 4
64581: PUSH
64582: LD_INT 1
64584: ARRAY
64585: IFFALSE 64589
// exit ;
64587: GO 64992
// height := hex [ 2 ] ;
64589: LD_ADDR_VAR 0 15
64593: PUSH
64594: LD_VAR 0 4
64598: PUSH
64599: LD_INT 2
64601: ARRAY
64602: ST_TO_ADDR
// tmp := [ 0 , 2 , 3 , 5 ] ;
64603: LD_ADDR_VAR 0 14
64607: PUSH
64608: LD_INT 0
64610: PUSH
64611: LD_INT 2
64613: PUSH
64614: LD_INT 3
64616: PUSH
64617: LD_INT 5
64619: PUSH
64620: EMPTY
64621: LIST
64622: LIST
64623: LIST
64624: LIST
64625: ST_TO_ADDR
// for i in tmp do
64626: LD_ADDR_VAR 0 8
64630: PUSH
64631: LD_VAR 0 14
64635: PUSH
64636: FOR_IN
64637: IFFALSE 64807
// begin j := [ ShiftX ( x , i , 5 ) , ShiftY ( y , i , 5 ) ] ;
64639: LD_ADDR_VAR 0 9
64643: PUSH
64644: LD_VAR 0 10
64648: PPUSH
64649: LD_VAR 0 8
64653: PPUSH
64654: LD_INT 5
64656: PPUSH
64657: CALL_OW 272
64661: PUSH
64662: LD_VAR 0 11
64666: PPUSH
64667: LD_VAR 0 8
64671: PPUSH
64672: LD_INT 5
64674: PPUSH
64675: CALL_OW 273
64679: PUSH
64680: EMPTY
64681: LIST
64682: LIST
64683: ST_TO_ADDR
// if ValidHex ( j [ 1 ] , j [ 2 ] ) then
64684: LD_VAR 0 9
64688: PUSH
64689: LD_INT 1
64691: ARRAY
64692: PPUSH
64693: LD_VAR 0 9
64697: PUSH
64698: LD_INT 2
64700: ARRAY
64701: PPUSH
64702: CALL_OW 488
64706: IFFALSE 64805
// begin hex := GetHexInfo ( j [ 1 ] , j [ 2 ] ) ;
64708: LD_ADDR_VAR 0 4
64712: PUSH
64713: LD_VAR 0 9
64717: PUSH
64718: LD_INT 1
64720: ARRAY
64721: PPUSH
64722: LD_VAR 0 9
64726: PUSH
64727: LD_INT 2
64729: ARRAY
64730: PPUSH
64731: CALL_OW 546
64735: ST_TO_ADDR
// if hex [ 1 ] then
64736: LD_VAR 0 4
64740: PUSH
64741: LD_INT 1
64743: ARRAY
64744: IFFALSE 64748
// continue ;
64746: GO 64636
// h := hex [ 2 ] ;
64748: LD_ADDR_VAR 0 13
64752: PUSH
64753: LD_VAR 0 4
64757: PUSH
64758: LD_INT 2
64760: ARRAY
64761: ST_TO_ADDR
// if h + 7 < height then
64762: LD_VAR 0 13
64766: PUSH
64767: LD_INT 7
64769: PLUS
64770: PUSH
64771: LD_VAR 0 15
64775: LESS
64776: IFFALSE 64805
// begin weapon := [ us_rocket_launcher , ar_rocket_launcher , ru_rocket_launcher ] [ nat ] ;
64778: LD_ADDR_VAR 0 18
64782: PUSH
64783: LD_INT 7
64785: PUSH
64786: LD_INT 28
64788: PUSH
64789: LD_INT 45
64791: PUSH
64792: EMPTY
64793: LIST
64794: LIST
64795: LIST
64796: PUSH
64797: LD_VAR 0 12
64801: ARRAY
64802: ST_TO_ADDR
// break ;
64803: GO 64807
// end ; end ; end ;
64805: GO 64636
64807: POP
64808: POP
// end ; if not weapon then
64809: LD_VAR 0 18
64813: NOT
64814: IFFALSE 64874
// begin list := list diff [ us_radar , ar_radar , ru_time_lapser ] ;
64816: LD_ADDR_VAR 0 5
64820: PUSH
64821: LD_VAR 0 5
64825: PUSH
64826: LD_INT 11
64828: PUSH
64829: LD_INT 30
64831: PUSH
64832: LD_INT 49
64834: PUSH
64835: EMPTY
64836: LIST
64837: LIST
64838: LIST
64839: DIFF
64840: ST_TO_ADDR
// if not list then
64841: LD_VAR 0 5
64845: NOT
64846: IFFALSE 64850
// exit ;
64848: GO 64992
// weapon := list [ rand ( 1 , list ) ] ;
64850: LD_ADDR_VAR 0 18
64854: PUSH
64855: LD_VAR 0 5
64859: PUSH
64860: LD_INT 1
64862: PPUSH
64863: LD_VAR 0 5
64867: PPUSH
64868: CALL_OW 12
64872: ARRAY
64873: ST_TO_ADDR
// end ; if weapon then
64874: LD_VAR 0 18
64878: IFFALSE 64992
// begin tmp := CostOfWeapon ( weapon ) ;
64880: LD_ADDR_VAR 0 14
64884: PUSH
64885: LD_VAR 0 18
64889: PPUSH
64890: CALL_OW 451
64894: ST_TO_ADDR
// j := GetBase ( tower ) ;
64895: LD_ADDR_VAR 0 9
64899: PUSH
64900: LD_VAR 0 1
64904: PPUSH
64905: CALL_OW 274
64909: ST_TO_ADDR
// if GetResourceType ( j , mat_cans ) >= tmp [ 1 ] and GetResourceType ( j , mat_oil ) >= tmp [ 2 ] and GetResourceType ( j , mat_siberit ) >= tmp [ 3 ] then
64910: LD_VAR 0 9
64914: PPUSH
64915: LD_INT 1
64917: PPUSH
64918: CALL_OW 275
64922: PUSH
64923: LD_VAR 0 14
64927: PUSH
64928: LD_INT 1
64930: ARRAY
64931: GREATEREQUAL
64932: PUSH
64933: LD_VAR 0 9
64937: PPUSH
64938: LD_INT 2
64940: PPUSH
64941: CALL_OW 275
64945: PUSH
64946: LD_VAR 0 14
64950: PUSH
64951: LD_INT 2
64953: ARRAY
64954: GREATEREQUAL
64955: AND
64956: PUSH
64957: LD_VAR 0 9
64961: PPUSH
64962: LD_INT 3
64964: PPUSH
64965: CALL_OW 275
64969: PUSH
64970: LD_VAR 0 14
64974: PUSH
64975: LD_INT 3
64977: ARRAY
64978: GREATEREQUAL
64979: AND
64980: IFFALSE 64992
// result := weapon ;
64982: LD_ADDR_VAR 0 3
64986: PUSH
64987: LD_VAR 0 18
64991: ST_TO_ADDR
// end ; end ;
64992: LD_VAR 0 3
64996: RET
// export function CompareArray ( array1 , array2 ) ; var i ; begin
64997: LD_INT 0
64999: PPUSH
65000: PPUSH
// result := true ;
65001: LD_ADDR_VAR 0 3
65005: PUSH
65006: LD_INT 1
65008: ST_TO_ADDR
// if array1 = array2 then
65009: LD_VAR 0 1
65013: PUSH
65014: LD_VAR 0 2
65018: EQUAL
65019: IFFALSE 65079
// begin for i = 1 to array1 do
65021: LD_ADDR_VAR 0 4
65025: PUSH
65026: DOUBLE
65027: LD_INT 1
65029: DEC
65030: ST_TO_ADDR
65031: LD_VAR 0 1
65035: PUSH
65036: FOR_TO
65037: IFFALSE 65075
// if array1 [ i ] <> array2 [ i ] then
65039: LD_VAR 0 1
65043: PUSH
65044: LD_VAR 0 4
65048: ARRAY
65049: PUSH
65050: LD_VAR 0 2
65054: PUSH
65055: LD_VAR 0 4
65059: ARRAY
65060: NONEQUAL
65061: IFFALSE 65073
// begin result := false ;
65063: LD_ADDR_VAR 0 3
65067: PUSH
65068: LD_INT 0
65070: ST_TO_ADDR
// break ;
65071: GO 65075
// end ;
65073: GO 65036
65075: POP
65076: POP
// end else
65077: GO 65087
// result := false ;
65079: LD_ADDR_VAR 0 3
65083: PUSH
65084: LD_INT 0
65086: ST_TO_ADDR
// end ;
65087: LD_VAR 0 3
65091: RET
// export function CompareArrayValues ( array1 , array2 ) ; var i ; begin
65092: LD_INT 0
65094: PPUSH
65095: PPUSH
// if not array1 or not array2 then
65096: LD_VAR 0 1
65100: NOT
65101: PUSH
65102: LD_VAR 0 2
65106: NOT
65107: OR
65108: IFFALSE 65112
// exit ;
65110: GO 65176
// result := true ;
65112: LD_ADDR_VAR 0 3
65116: PUSH
65117: LD_INT 1
65119: ST_TO_ADDR
// for i = 1 to array1 do
65120: LD_ADDR_VAR 0 4
65124: PUSH
65125: DOUBLE
65126: LD_INT 1
65128: DEC
65129: ST_TO_ADDR
65130: LD_VAR 0 1
65134: PUSH
65135: FOR_TO
65136: IFFALSE 65174
// if array1 [ i ] <> array2 [ i ] then
65138: LD_VAR 0 1
65142: PUSH
65143: LD_VAR 0 4
65147: ARRAY
65148: PUSH
65149: LD_VAR 0 2
65153: PUSH
65154: LD_VAR 0 4
65158: ARRAY
65159: NONEQUAL
65160: IFFALSE 65172
// begin result := false ;
65162: LD_ADDR_VAR 0 3
65166: PUSH
65167: LD_INT 0
65169: ST_TO_ADDR
// break ;
65170: GO 65174
// end ;
65172: GO 65135
65174: POP
65175: POP
// end ;
65176: LD_VAR 0 3
65180: RET
// export function VehicleCost ( fac , list ) ; var cost , pom ; begin
65181: LD_INT 0
65183: PPUSH
65184: PPUSH
65185: PPUSH
// pom := GetBase ( fac ) ;
65186: LD_ADDR_VAR 0 5
65190: PUSH
65191: LD_VAR 0 1
65195: PPUSH
65196: CALL_OW 274
65200: ST_TO_ADDR
// cost := CostOfVehicle ( list [ 1 ] , list [ 2 ] , list [ 3 ] , list [ 4 ] ) ;
65201: LD_ADDR_VAR 0 4
65205: PUSH
65206: LD_VAR 0 2
65210: PUSH
65211: LD_INT 1
65213: ARRAY
65214: PPUSH
65215: LD_VAR 0 2
65219: PUSH
65220: LD_INT 2
65222: ARRAY
65223: PPUSH
65224: LD_VAR 0 2
65228: PUSH
65229: LD_INT 3
65231: ARRAY
65232: PPUSH
65233: LD_VAR 0 2
65237: PUSH
65238: LD_INT 4
65240: ARRAY
65241: PPUSH
65242: CALL_OW 449
65246: ST_TO_ADDR
// result := GetResourceType ( pom , mat_cans ) >= cost [ 1 ] and GetResourceType ( pom , mat_oil ) >= cost [ 2 ] and GetResourceType ( pom , mat_siberit ) >= cost [ 3 ] ;
65247: LD_ADDR_VAR 0 3
65251: PUSH
65252: LD_VAR 0 5
65256: PPUSH
65257: LD_INT 1
65259: PPUSH
65260: CALL_OW 275
65264: PUSH
65265: LD_VAR 0 4
65269: PUSH
65270: LD_INT 1
65272: ARRAY
65273: GREATEREQUAL
65274: PUSH
65275: LD_VAR 0 5
65279: PPUSH
65280: LD_INT 2
65282: PPUSH
65283: CALL_OW 275
65287: PUSH
65288: LD_VAR 0 4
65292: PUSH
65293: LD_INT 2
65295: ARRAY
65296: GREATEREQUAL
65297: AND
65298: PUSH
65299: LD_VAR 0 5
65303: PPUSH
65304: LD_INT 3
65306: PPUSH
65307: CALL_OW 275
65311: PUSH
65312: LD_VAR 0 4
65316: PUSH
65317: LD_INT 3
65319: ARRAY
65320: GREATEREQUAL
65321: AND
65322: ST_TO_ADDR
// end ;
65323: LD_VAR 0 3
65327: RET
// export function UpgradeCost ( building ) ; var pom , cost , btype ; begin
65328: LD_INT 0
65330: PPUSH
65331: PPUSH
65332: PPUSH
65333: PPUSH
// pom := GetBase ( building ) ;
65334: LD_ADDR_VAR 0 3
65338: PUSH
65339: LD_VAR 0 1
65343: PPUSH
65344: CALL_OW 274
65348: ST_TO_ADDR
// if not pom then
65349: LD_VAR 0 3
65353: NOT
65354: IFFALSE 65358
// exit ;
65356: GO 65528
// btype := GetBType ( building ) ;
65358: LD_ADDR_VAR 0 5
65362: PUSH
65363: LD_VAR 0 1
65367: PPUSH
65368: CALL_OW 266
65372: ST_TO_ADDR
// if btype = b_armoury then
65373: LD_VAR 0 5
65377: PUSH
65378: LD_INT 4
65380: EQUAL
65381: IFFALSE 65391
// btype := b_barracks ;
65383: LD_ADDR_VAR 0 5
65387: PUSH
65388: LD_INT 5
65390: ST_TO_ADDR
// if btype = b_depot then
65391: LD_VAR 0 5
65395: PUSH
65396: LD_INT 0
65398: EQUAL
65399: IFFALSE 65409
// btype := b_warehouse ;
65401: LD_ADDR_VAR 0 5
65405: PUSH
65406: LD_INT 1
65408: ST_TO_ADDR
// if btype = b_workshop then
65409: LD_VAR 0 5
65413: PUSH
65414: LD_INT 2
65416: EQUAL
65417: IFFALSE 65427
// btype := b_factory ;
65419: LD_ADDR_VAR 0 5
65423: PUSH
65424: LD_INT 3
65426: ST_TO_ADDR
// cost := CostOfBuilding ( btype , GetNation ( building ) ) ;
65427: LD_ADDR_VAR 0 4
65431: PUSH
65432: LD_VAR 0 5
65436: PPUSH
65437: LD_VAR 0 1
65441: PPUSH
65442: CALL_OW 248
65446: PPUSH
65447: CALL_OW 450
65451: ST_TO_ADDR
// result := GetResourceType ( pom , mat_cans ) >= cost [ 1 ] and GetResourceType ( pom , mat_oil ) >= cost [ 2 ] and GetResourceType ( pom , mat_siberit ) >= cost [ 3 ] ;
65452: LD_ADDR_VAR 0 2
65456: PUSH
65457: LD_VAR 0 3
65461: PPUSH
65462: LD_INT 1
65464: PPUSH
65465: CALL_OW 275
65469: PUSH
65470: LD_VAR 0 4
65474: PUSH
65475: LD_INT 1
65477: ARRAY
65478: GREATEREQUAL
65479: PUSH
65480: LD_VAR 0 3
65484: PPUSH
65485: LD_INT 2
65487: PPUSH
65488: CALL_OW 275
65492: PUSH
65493: LD_VAR 0 4
65497: PUSH
65498: LD_INT 2
65500: ARRAY
65501: GREATEREQUAL
65502: AND
65503: PUSH
65504: LD_VAR 0 3
65508: PPUSH
65509: LD_INT 3
65511: PPUSH
65512: CALL_OW 275
65516: PUSH
65517: LD_VAR 0 4
65521: PUSH
65522: LD_INT 3
65524: ARRAY
65525: GREATEREQUAL
65526: AND
65527: ST_TO_ADDR
// end ;
65528: LD_VAR 0 2
65532: RET
// export function UpgradeLabCost ( building , btype ) ; var pom , cost ; begin
65533: LD_INT 0
65535: PPUSH
65536: PPUSH
65537: PPUSH
// pom := GetBase ( building ) ;
65538: LD_ADDR_VAR 0 4
65542: PUSH
65543: LD_VAR 0 1
65547: PPUSH
65548: CALL_OW 274
65552: ST_TO_ADDR
// if not pom then
65553: LD_VAR 0 4
65557: NOT
65558: IFFALSE 65562
// exit ;
65560: GO 65663
// cost := CostOfBuilding ( btype , GetNation ( building ) ) ;
65562: LD_ADDR_VAR 0 5
65566: PUSH
65567: LD_VAR 0 2
65571: PPUSH
65572: LD_VAR 0 1
65576: PPUSH
65577: CALL_OW 248
65581: PPUSH
65582: CALL_OW 450
65586: ST_TO_ADDR
// result := GetResourceType ( pom , mat_cans ) >= cost [ 1 ] and GetResourceType ( pom , mat_oil ) >= cost [ 2 ] and GetResourceType ( pom , mat_siberit ) >= cost [ 3 ] ;
65587: LD_ADDR_VAR 0 3
65591: PUSH
65592: LD_VAR 0 4
65596: PPUSH
65597: LD_INT 1
65599: PPUSH
65600: CALL_OW 275
65604: PUSH
65605: LD_VAR 0 5
65609: PUSH
65610: LD_INT 1
65612: ARRAY
65613: GREATEREQUAL
65614: PUSH
65615: LD_VAR 0 4
65619: PPUSH
65620: LD_INT 2
65622: PPUSH
65623: CALL_OW 275
65627: PUSH
65628: LD_VAR 0 5
65632: PUSH
65633: LD_INT 2
65635: ARRAY
65636: GREATEREQUAL
65637: AND
65638: PUSH
65639: LD_VAR 0 4
65643: PPUSH
65644: LD_INT 3
65646: PPUSH
65647: CALL_OW 275
65651: PUSH
65652: LD_VAR 0 5
65656: PUSH
65657: LD_INT 3
65659: ARRAY
65660: GREATEREQUAL
65661: AND
65662: ST_TO_ADDR
// end ;
65663: LD_VAR 0 3
65667: RET
// export function TryClearPlaceForBuilding ( btype , x , y , d , buildings , cleaners , parking ) ; var i , j , _x , _y , tmp , hexes , r , xy , dep , driver ; begin
65668: LD_INT 0
65670: PPUSH
65671: PPUSH
65672: PPUSH
65673: PPUSH
65674: PPUSH
65675: PPUSH
65676: PPUSH
65677: PPUSH
65678: PPUSH
65679: PPUSH
65680: PPUSH
// result := false ;
65681: LD_ADDR_VAR 0 8
65685: PUSH
65686: LD_INT 0
65688: ST_TO_ADDR
// if not buildings or not btype or not x or not y then
65689: LD_VAR 0 5
65693: NOT
65694: PUSH
65695: LD_VAR 0 1
65699: NOT
65700: OR
65701: PUSH
65702: LD_VAR 0 2
65706: NOT
65707: OR
65708: PUSH
65709: LD_VAR 0 3
65713: NOT
65714: OR
65715: IFFALSE 65719
// exit ;
65717: GO 66533
// hexes := GetBuildingHexes ( btype , x , y , d , GetNation ( buildings [ 1 ] ) , 0 ) ;
65719: LD_ADDR_VAR 0 14
65723: PUSH
65724: LD_VAR 0 1
65728: PPUSH
65729: LD_VAR 0 2
65733: PPUSH
65734: LD_VAR 0 3
65738: PPUSH
65739: LD_VAR 0 4
65743: PPUSH
65744: LD_VAR 0 5
65748: PUSH
65749: LD_INT 1
65751: ARRAY
65752: PPUSH
65753: CALL_OW 248
65757: PPUSH
65758: LD_INT 0
65760: PPUSH
65761: CALL 67786 0 6
65765: ST_TO_ADDR
// if not hexes then
65766: LD_VAR 0 14
65770: NOT
65771: IFFALSE 65775
// exit ;
65773: GO 66533
// dep := UnitFilter ( buildings , [ [ f_side , GetSide ( tmp ) ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ] ) ;
65775: LD_ADDR_VAR 0 17
65779: PUSH
65780: LD_VAR 0 5
65784: PPUSH
65785: LD_INT 22
65787: PUSH
65788: LD_VAR 0 13
65792: PPUSH
65793: CALL_OW 255
65797: PUSH
65798: EMPTY
65799: LIST
65800: LIST
65801: PUSH
65802: LD_INT 2
65804: PUSH
65805: LD_INT 30
65807: PUSH
65808: LD_INT 0
65810: PUSH
65811: EMPTY
65812: LIST
65813: LIST
65814: PUSH
65815: LD_INT 30
65817: PUSH
65818: LD_INT 1
65820: PUSH
65821: EMPTY
65822: LIST
65823: LIST
65824: PUSH
65825: EMPTY
65826: LIST
65827: LIST
65828: LIST
65829: PUSH
65830: EMPTY
65831: LIST
65832: LIST
65833: PPUSH
65834: CALL_OW 72
65838: ST_TO_ADDR
// for i = 1 to hexes do
65839: LD_ADDR_VAR 0 9
65843: PUSH
65844: DOUBLE
65845: LD_INT 1
65847: DEC
65848: ST_TO_ADDR
65849: LD_VAR 0 14
65853: PUSH
65854: FOR_TO
65855: IFFALSE 66531
// begin tmp := HexInfo ( hexes [ i ] [ 1 ] , hexes [ i ] [ 2 ] ) ;
65857: LD_ADDR_VAR 0 13
65861: PUSH
65862: LD_VAR 0 14
65866: PUSH
65867: LD_VAR 0 9
65871: ARRAY
65872: PUSH
65873: LD_INT 1
65875: ARRAY
65876: PPUSH
65877: LD_VAR 0 14
65881: PUSH
65882: LD_VAR 0 9
65886: ARRAY
65887: PUSH
65888: LD_INT 2
65890: ARRAY
65891: PPUSH
65892: CALL_OW 428
65896: ST_TO_ADDR
// if IsEnvironment ( hexes [ i ] [ 1 ] , hexes [ i ] [ 2 ] ) or not ValidHex ( hexes [ i ] [ 1 ] , hexes [ i ] [ 2 ] ) or GetType ( tmp ) = unit_building then
65897: LD_VAR 0 14
65901: PUSH
65902: LD_VAR 0 9
65906: ARRAY
65907: PUSH
65908: LD_INT 1
65910: ARRAY
65911: PPUSH
65912: LD_VAR 0 14
65916: PUSH
65917: LD_VAR 0 9
65921: ARRAY
65922: PUSH
65923: LD_INT 2
65925: ARRAY
65926: PPUSH
65927: CALL_OW 351
65931: PUSH
65932: LD_VAR 0 14
65936: PUSH
65937: LD_VAR 0 9
65941: ARRAY
65942: PUSH
65943: LD_INT 1
65945: ARRAY
65946: PPUSH
65947: LD_VAR 0 14
65951: PUSH
65952: LD_VAR 0 9
65956: ARRAY
65957: PUSH
65958: LD_INT 2
65960: ARRAY
65961: PPUSH
65962: CALL_OW 488
65966: NOT
65967: OR
65968: PUSH
65969: LD_VAR 0 13
65973: PPUSH
65974: CALL_OW 247
65978: PUSH
65979: LD_INT 3
65981: EQUAL
65982: OR
65983: IFFALSE 65989
// exit ;
65985: POP
65986: POP
65987: GO 66533
// if not tmp then
65989: LD_VAR 0 13
65993: NOT
65994: IFFALSE 65998
// continue ;
65996: GO 65854
// result := true ;
65998: LD_ADDR_VAR 0 8
66002: PUSH
66003: LD_INT 1
66005: ST_TO_ADDR
// if cleaners and GetType ( tmp ) = unit_vehicle and GetControl ( tmp ) = control_manual then
66006: LD_VAR 0 6
66010: PUSH
66011: LD_VAR 0 13
66015: PPUSH
66016: CALL_OW 247
66020: PUSH
66021: LD_INT 2
66023: EQUAL
66024: AND
66025: PUSH
66026: LD_VAR 0 13
66030: PPUSH
66031: CALL_OW 263
66035: PUSH
66036: LD_INT 1
66038: EQUAL
66039: AND
66040: IFFALSE 66204
// begin if IsDrivenBy ( tmp ) then
66042: LD_VAR 0 13
66046: PPUSH
66047: CALL_OW 311
66051: IFFALSE 66055
// continue ;
66053: GO 65854
// if UnitFilter ( cleaners , [ [ f_not , [ f_hastask ] ] , [ f_not , [ f_driving ] ] ] ) then
66055: LD_VAR 0 6
66059: PPUSH
66060: LD_INT 3
66062: PUSH
66063: LD_INT 60
66065: PUSH
66066: EMPTY
66067: LIST
66068: PUSH
66069: EMPTY
66070: LIST
66071: LIST
66072: PUSH
66073: LD_INT 3
66075: PUSH
66076: LD_INT 55
66078: PUSH
66079: EMPTY
66080: LIST
66081: PUSH
66082: EMPTY
66083: LIST
66084: LIST
66085: PUSH
66086: EMPTY
66087: LIST
66088: LIST
66089: PPUSH
66090: CALL_OW 72
66094: IFFALSE 66202
// begin driver := UnitFilter ( cleaners , [ [ f_not , [ f_hastask ] ] , [ f_not , [ f_driving ] ] ] ) [ 1 ] ;
66096: LD_ADDR_VAR 0 18
66100: PUSH
66101: LD_VAR 0 6
66105: PPUSH
66106: LD_INT 3
66108: PUSH
66109: LD_INT 60
66111: PUSH
66112: EMPTY
66113: LIST
66114: PUSH
66115: EMPTY
66116: LIST
66117: LIST
66118: PUSH
66119: LD_INT 3
66121: PUSH
66122: LD_INT 55
66124: PUSH
66125: EMPTY
66126: LIST
66127: PUSH
66128: EMPTY
66129: LIST
66130: LIST
66131: PUSH
66132: EMPTY
66133: LIST
66134: LIST
66135: PPUSH
66136: CALL_OW 72
66140: PUSH
66141: LD_INT 1
66143: ARRAY
66144: ST_TO_ADDR
// if IsInUnit ( driver ) then
66145: LD_VAR 0 18
66149: PPUSH
66150: CALL_OW 310
66154: IFFALSE 66165
// ComExit ( driver ) ;
66156: LD_VAR 0 18
66160: PPUSH
66161: CALL 91567 0 1
// AddComEnterUnit ( driver , tmp ) ;
66165: LD_VAR 0 18
66169: PPUSH
66170: LD_VAR 0 13
66174: PPUSH
66175: CALL_OW 180
// AddComMoveToArea ( driver , parking ) ;
66179: LD_VAR 0 18
66183: PPUSH
66184: LD_VAR 0 7
66188: PPUSH
66189: CALL_OW 173
// AddComExitVehicle ( driver ) ;
66193: LD_VAR 0 18
66197: PPUSH
66198: CALL_OW 181
// end ; continue ;
66202: GO 65854
// end ; if not cleaners or not tmp in cleaners then
66204: LD_VAR 0 6
66208: NOT
66209: PUSH
66210: LD_VAR 0 13
66214: PUSH
66215: LD_VAR 0 6
66219: IN
66220: NOT
66221: OR
66222: IFFALSE 66529
// begin if dep then
66224: LD_VAR 0 17
66228: IFFALSE 66364
// begin xy := [ ShiftX ( GetX ( dep [ 1 ] ) , GetDir ( dep [ 1 ] ) , 5 ) , ShiftY ( GetY ( dep [ 1 ] ) , GetDir ( dep [ 1 ] ) , 5 ) ] ;
66230: LD_ADDR_VAR 0 16
66234: PUSH
66235: LD_VAR 0 17
66239: PUSH
66240: LD_INT 1
66242: ARRAY
66243: PPUSH
66244: CALL_OW 250
66248: PPUSH
66249: LD_VAR 0 17
66253: PUSH
66254: LD_INT 1
66256: ARRAY
66257: PPUSH
66258: CALL_OW 254
66262: PPUSH
66263: LD_INT 5
66265: PPUSH
66266: CALL_OW 272
66270: PUSH
66271: LD_VAR 0 17
66275: PUSH
66276: LD_INT 1
66278: ARRAY
66279: PPUSH
66280: CALL_OW 251
66284: PPUSH
66285: LD_VAR 0 17
66289: PUSH
66290: LD_INT 1
66292: ARRAY
66293: PPUSH
66294: CALL_OW 254
66298: PPUSH
66299: LD_INT 5
66301: PPUSH
66302: CALL_OW 273
66306: PUSH
66307: EMPTY
66308: LIST
66309: LIST
66310: ST_TO_ADDR
// if ValidHex ( xy [ 1 ] , xy [ 2 ] ) then
66311: LD_VAR 0 16
66315: PUSH
66316: LD_INT 1
66318: ARRAY
66319: PPUSH
66320: LD_VAR 0 16
66324: PUSH
66325: LD_INT 2
66327: ARRAY
66328: PPUSH
66329: CALL_OW 488
66333: IFFALSE 66364
// begin ComMoveXY ( tmp , xy [ 1 ] , xy [ 2 ] ) ;
66335: LD_VAR 0 13
66339: PPUSH
66340: LD_VAR 0 16
66344: PUSH
66345: LD_INT 1
66347: ARRAY
66348: PPUSH
66349: LD_VAR 0 16
66353: PUSH
66354: LD_INT 2
66356: ARRAY
66357: PPUSH
66358: CALL_OW 111
// continue ;
66362: GO 65854
// end ; end ; r := GetDir ( tmp ) ;
66364: LD_ADDR_VAR 0 15
66368: PUSH
66369: LD_VAR 0 13
66373: PPUSH
66374: CALL_OW 254
66378: ST_TO_ADDR
// if r = 5 then
66379: LD_VAR 0 15
66383: PUSH
66384: LD_INT 5
66386: EQUAL
66387: IFFALSE 66397
// r := 0 ;
66389: LD_ADDR_VAR 0 15
66393: PUSH
66394: LD_INT 0
66396: ST_TO_ADDR
// for j = r to 5 do
66397: LD_ADDR_VAR 0 10
66401: PUSH
66402: DOUBLE
66403: LD_VAR 0 15
66407: DEC
66408: ST_TO_ADDR
66409: LD_INT 5
66411: PUSH
66412: FOR_TO
66413: IFFALSE 66527
// begin _x := ShiftX ( GetX ( tmp ) , j , 2 ) ;
66415: LD_ADDR_VAR 0 11
66419: PUSH
66420: LD_VAR 0 13
66424: PPUSH
66425: CALL_OW 250
66429: PPUSH
66430: LD_VAR 0 10
66434: PPUSH
66435: LD_INT 2
66437: PPUSH
66438: CALL_OW 272
66442: ST_TO_ADDR
// _y := ShiftY ( GetY ( tmp ) , j , 2 ) ;
66443: LD_ADDR_VAR 0 12
66447: PUSH
66448: LD_VAR 0 13
66452: PPUSH
66453: CALL_OW 251
66457: PPUSH
66458: LD_VAR 0 10
66462: PPUSH
66463: LD_INT 2
66465: PPUSH
66466: CALL_OW 273
66470: ST_TO_ADDR
// if ValidHex ( _x , _y ) and not HexInfo ( _x , _y ) then
66471: LD_VAR 0 11
66475: PPUSH
66476: LD_VAR 0 12
66480: PPUSH
66481: CALL_OW 488
66485: PUSH
66486: LD_VAR 0 11
66490: PPUSH
66491: LD_VAR 0 12
66495: PPUSH
66496: CALL_OW 428
66500: NOT
66501: AND
66502: IFFALSE 66525
// begin ComMoveXY ( tmp , _x , _y ) ;
66504: LD_VAR 0 13
66508: PPUSH
66509: LD_VAR 0 11
66513: PPUSH
66514: LD_VAR 0 12
66518: PPUSH
66519: CALL_OW 111
// break ;
66523: GO 66527
// end ; end ;
66525: GO 66412
66527: POP
66528: POP
// end ; end ;
66529: GO 65854
66531: POP
66532: POP
// end ;
66533: LD_VAR 0 8
66537: RET
// export function BuildingTechInvented ( side , btype ) ; begin
66538: LD_INT 0
66540: PPUSH
// result := true ;
66541: LD_ADDR_VAR 0 3
66545: PUSH
66546: LD_INT 1
66548: ST_TO_ADDR
// case btype of b_ext_computer , b_turret :
66549: LD_VAR 0 2
66553: PUSH
66554: LD_INT 24
66556: DOUBLE
66557: EQUAL
66558: IFTRUE 66568
66560: LD_INT 33
66562: DOUBLE
66563: EQUAL
66564: IFTRUE 66568
66566: GO 66593
66568: POP
// result := ( GetTech ( tech_ai , side ) = state_researched ) ; b_ext_radar :
66569: LD_ADDR_VAR 0 3
66573: PUSH
66574: LD_INT 32
66576: PPUSH
66577: LD_VAR 0 1
66581: PPUSH
66582: CALL_OW 321
66586: PUSH
66587: LD_INT 2
66589: EQUAL
66590: ST_TO_ADDR
66591: GO 66909
66593: LD_INT 20
66595: DOUBLE
66596: EQUAL
66597: IFTRUE 66601
66599: GO 66626
66601: POP
// result := ( GetTech ( tech_radar , side ) = state_researched ) ; b_ext_radio , b_control_tower :
66602: LD_ADDR_VAR 0 3
66606: PUSH
66607: LD_INT 6
66609: PPUSH
66610: LD_VAR 0 1
66614: PPUSH
66615: CALL_OW 321
66619: PUSH
66620: LD_INT 2
66622: EQUAL
66623: ST_TO_ADDR
66624: GO 66909
66626: LD_INT 22
66628: DOUBLE
66629: EQUAL
66630: IFTRUE 66640
66632: LD_INT 36
66634: DOUBLE
66635: EQUAL
66636: IFTRUE 66640
66638: GO 66665
66640: POP
// result := ( GetTech ( tech_remcont , side ) = state_researched ) ; b_siberite_mine :
66641: LD_ADDR_VAR 0 3
66645: PUSH
66646: LD_INT 15
66648: PPUSH
66649: LD_VAR 0 1
66653: PPUSH
66654: CALL_OW 321
66658: PUSH
66659: LD_INT 2
66661: EQUAL
66662: ST_TO_ADDR
66663: GO 66909
66665: LD_INT 30
66667: DOUBLE
66668: EQUAL
66669: IFTRUE 66673
66671: GO 66698
66673: POP
// result := ( GetTech ( tech_sibdet , side ) = state_researched ) ; b_siberite_power , b_ext_siberium :
66674: LD_ADDR_VAR 0 3
66678: PUSH
66679: LD_INT 20
66681: PPUSH
66682: LD_VAR 0 1
66686: PPUSH
66687: CALL_OW 321
66691: PUSH
66692: LD_INT 2
66694: EQUAL
66695: ST_TO_ADDR
66696: GO 66909
66698: LD_INT 28
66700: DOUBLE
66701: EQUAL
66702: IFTRUE 66712
66704: LD_INT 21
66706: DOUBLE
66707: EQUAL
66708: IFTRUE 66712
66710: GO 66737
66712: POP
// result := ( GetTech ( tech_sibpow , side ) = state_researched ) ; b_ext_track :
66713: LD_ADDR_VAR 0 3
66717: PUSH
66718: LD_INT 21
66720: PPUSH
66721: LD_VAR 0 1
66725: PPUSH
66726: CALL_OW 321
66730: PUSH
66731: LD_INT 2
66733: EQUAL
66734: ST_TO_ADDR
66735: GO 66909
66737: LD_INT 16
66739: DOUBLE
66740: EQUAL
66741: IFTRUE 66745
66743: GO 66770
66745: POP
// result := ( GetTech ( tech_track , side ) = state_researched ) ; b_ext_noncombat , b_ext_stitch :
66746: LD_ADDR_VAR 0 3
66750: PUSH
66751: LD_INT 84
66753: PPUSH
66754: LD_VAR 0 1
66758: PPUSH
66759: CALL_OW 321
66763: PUSH
66764: LD_INT 2
66766: EQUAL
66767: ST_TO_ADDR
66768: GO 66909
66770: LD_INT 19
66772: DOUBLE
66773: EQUAL
66774: IFTRUE 66784
66776: LD_INT 23
66778: DOUBLE
66779: EQUAL
66780: IFTRUE 66784
66782: GO 66809
66784: POP
// result := ( GetTech ( tech_cargo , side ) = state_researched ) ; b_ext_gun :
66785: LD_ADDR_VAR 0 3
66789: PUSH
66790: LD_INT 83
66792: PPUSH
66793: LD_VAR 0 1
66797: PPUSH
66798: CALL_OW 321
66802: PUSH
66803: LD_INT 2
66805: EQUAL
66806: ST_TO_ADDR
66807: GO 66909
66809: LD_INT 17
66811: DOUBLE
66812: EQUAL
66813: IFTRUE 66817
66815: GO 66842
66817: POP
// result := ( GetTech ( tech_gun , side ) = state_researched ) ; b_ext_rocket :
66818: LD_ADDR_VAR 0 3
66822: PUSH
66823: LD_INT 39
66825: PPUSH
66826: LD_VAR 0 1
66830: PPUSH
66831: CALL_OW 321
66835: PUSH
66836: LD_INT 2
66838: EQUAL
66839: ST_TO_ADDR
66840: GO 66909
66842: LD_INT 18
66844: DOUBLE
66845: EQUAL
66846: IFTRUE 66850
66848: GO 66875
66850: POP
// result := ( GetTech ( tech_rocket , side ) = state_researched ) ; b_solar_power :
66851: LD_ADDR_VAR 0 3
66855: PUSH
66856: LD_INT 40
66858: PPUSH
66859: LD_VAR 0 1
66863: PPUSH
66864: CALL_OW 321
66868: PUSH
66869: LD_INT 2
66871: EQUAL
66872: ST_TO_ADDR
66873: GO 66909
66875: LD_INT 27
66877: DOUBLE
66878: EQUAL
66879: IFTRUE 66883
66881: GO 66908
66883: POP
// result := ( GetTech ( tech_solpow , side ) = state_researched ) ; end ;
66884: LD_ADDR_VAR 0 3
66888: PUSH
66889: LD_INT 35
66891: PPUSH
66892: LD_VAR 0 1
66896: PPUSH
66897: CALL_OW 321
66901: PUSH
66902: LD_INT 2
66904: EQUAL
66905: ST_TO_ADDR
66906: GO 66909
66908: POP
// end ;
66909: LD_VAR 0 3
66913: RET
// export function CanBeBuilt ( depot , btype , x , y , d ) ; var i , j , side , pom , cost , hexes , height , dist , hex , tech ; begin
66914: LD_INT 0
66916: PPUSH
66917: PPUSH
66918: PPUSH
66919: PPUSH
66920: PPUSH
66921: PPUSH
66922: PPUSH
66923: PPUSH
66924: PPUSH
66925: PPUSH
66926: PPUSH
// result := false ;
66927: LD_ADDR_VAR 0 6
66931: PUSH
66932: LD_INT 0
66934: ST_TO_ADDR
// if btype = b_depot then
66935: LD_VAR 0 2
66939: PUSH
66940: LD_INT 0
66942: EQUAL
66943: IFFALSE 66955
// begin result := true ;
66945: LD_ADDR_VAR 0 6
66949: PUSH
66950: LD_INT 1
66952: ST_TO_ADDR
// exit ;
66953: GO 67781
// end ; if not depot or not GetBType ( depot ) in [ b_depot , b_warehouse ] or not btype or not d in [ 0 , 1 , 2 , 3 , 4 , 5 ] or not ValidHex ( x , y ) then
66955: LD_VAR 0 1
66959: NOT
66960: PUSH
66961: LD_VAR 0 1
66965: PPUSH
66966: CALL_OW 266
66970: PUSH
66971: LD_INT 0
66973: PUSH
66974: LD_INT 1
66976: PUSH
66977: EMPTY
66978: LIST
66979: LIST
66980: IN
66981: NOT
66982: OR
66983: PUSH
66984: LD_VAR 0 2
66988: NOT
66989: OR
66990: PUSH
66991: LD_VAR 0 5
66995: PUSH
66996: LD_INT 0
66998: PUSH
66999: LD_INT 1
67001: PUSH
67002: LD_INT 2
67004: PUSH
67005: LD_INT 3
67007: PUSH
67008: LD_INT 4
67010: PUSH
67011: LD_INT 5
67013: PUSH
67014: EMPTY
67015: LIST
67016: LIST
67017: LIST
67018: LIST
67019: LIST
67020: LIST
67021: IN
67022: NOT
67023: OR
67024: PUSH
67025: LD_VAR 0 3
67029: PPUSH
67030: LD_VAR 0 4
67034: PPUSH
67035: CALL_OW 488
67039: NOT
67040: OR
67041: IFFALSE 67045
// exit ;
67043: GO 67781
// side := GetSide ( depot ) ;
67045: LD_ADDR_VAR 0 9
67049: PUSH
67050: LD_VAR 0 1
67054: PPUSH
67055: CALL_OW 255
67059: ST_TO_ADDR
// if not BuildingTechInvented ( side , btype ) then
67060: LD_VAR 0 9
67064: PPUSH
67065: LD_VAR 0 2
67069: PPUSH
67070: CALL 66538 0 2
67074: NOT
67075: IFFALSE 67079
// exit ;
67077: GO 67781
// pom := GetBase ( depot ) ;
67079: LD_ADDR_VAR 0 10
67083: PUSH
67084: LD_VAR 0 1
67088: PPUSH
67089: CALL_OW 274
67093: ST_TO_ADDR
// cost := CostOfBuilding ( btype , GetNation ( depot ) ) ;
67094: LD_ADDR_VAR 0 11
67098: PUSH
67099: LD_VAR 0 2
67103: PPUSH
67104: LD_VAR 0 1
67108: PPUSH
67109: CALL_OW 248
67113: PPUSH
67114: CALL_OW 450
67118: ST_TO_ADDR
// if not ( GetResourceType ( pom , mat_cans ) >= cost [ 1 ] and GetResourceType ( pom , mat_oil ) >= cost [ 2 ] and GetResourceType ( pom , mat_siberit ) >= cost [ 3 ] ) then
67119: LD_VAR 0 10
67123: PPUSH
67124: LD_INT 1
67126: PPUSH
67127: CALL_OW 275
67131: PUSH
67132: LD_VAR 0 11
67136: PUSH
67137: LD_INT 1
67139: ARRAY
67140: GREATEREQUAL
67141: PUSH
67142: LD_VAR 0 10
67146: PPUSH
67147: LD_INT 2
67149: PPUSH
67150: CALL_OW 275
67154: PUSH
67155: LD_VAR 0 11
67159: PUSH
67160: LD_INT 2
67162: ARRAY
67163: GREATEREQUAL
67164: AND
67165: PUSH
67166: LD_VAR 0 10
67170: PPUSH
67171: LD_INT 3
67173: PPUSH
67174: CALL_OW 275
67178: PUSH
67179: LD_VAR 0 11
67183: PUSH
67184: LD_INT 3
67186: ARRAY
67187: GREATEREQUAL
67188: AND
67189: NOT
67190: IFFALSE 67194
// exit ;
67192: GO 67781
// if GetBType ( depot ) = b_depot then
67194: LD_VAR 0 1
67198: PPUSH
67199: CALL_OW 266
67203: PUSH
67204: LD_INT 0
67206: EQUAL
67207: IFFALSE 67219
// dist := 28 else
67209: LD_ADDR_VAR 0 14
67213: PUSH
67214: LD_INT 28
67216: ST_TO_ADDR
67217: GO 67227
// dist := 36 ;
67219: LD_ADDR_VAR 0 14
67223: PUSH
67224: LD_INT 36
67226: ST_TO_ADDR
// if GetDistUnitXY ( depot , x , y ) > dist then
67227: LD_VAR 0 1
67231: PPUSH
67232: LD_VAR 0 3
67236: PPUSH
67237: LD_VAR 0 4
67241: PPUSH
67242: CALL_OW 297
67246: PUSH
67247: LD_VAR 0 14
67251: GREATER
67252: IFFALSE 67256
// exit ;
67254: GO 67781
// hexes := GetBuildingHexes ( btype , x , y , d , GetNation ( depot ) , 0 ) ;
67256: LD_ADDR_VAR 0 12
67260: PUSH
67261: LD_VAR 0 2
67265: PPUSH
67266: LD_VAR 0 3
67270: PPUSH
67271: LD_VAR 0 4
67275: PPUSH
67276: LD_VAR 0 5
67280: PPUSH
67281: LD_VAR 0 1
67285: PPUSH
67286: CALL_OW 248
67290: PPUSH
67291: LD_INT 0
67293: PPUSH
67294: CALL 67786 0 6
67298: ST_TO_ADDR
// if not hexes then
67299: LD_VAR 0 12
67303: NOT
67304: IFFALSE 67308
// exit ;
67306: GO 67781
// hex := GetHexInfo ( x , y ) ;
67308: LD_ADDR_VAR 0 15
67312: PUSH
67313: LD_VAR 0 3
67317: PPUSH
67318: LD_VAR 0 4
67322: PPUSH
67323: CALL_OW 546
67327: ST_TO_ADDR
// if hex [ 1 ] then
67328: LD_VAR 0 15
67332: PUSH
67333: LD_INT 1
67335: ARRAY
67336: IFFALSE 67340
// exit ;
67338: GO 67781
// height := hex [ 2 ] ;
67340: LD_ADDR_VAR 0 13
67344: PUSH
67345: LD_VAR 0 15
67349: PUSH
67350: LD_INT 2
67352: ARRAY
67353: ST_TO_ADDR
// for i = 1 to hexes do
67354: LD_ADDR_VAR 0 7
67358: PUSH
67359: DOUBLE
67360: LD_INT 1
67362: DEC
67363: ST_TO_ADDR
67364: LD_VAR 0 12
67368: PUSH
67369: FOR_TO
67370: IFFALSE 67700
// begin if not ValidHex ( hexes [ i ] [ 1 ] , hexes [ i ] [ 2 ] ) or HexInfo ( hexes [ i ] [ 1 ] , hexes [ i ] [ 2 ] ) > 0 or IsEnvironment ( hexes [ i ] [ 1 ] , hexes [ i ] [ 2 ] ) then
67372: LD_VAR 0 12
67376: PUSH
67377: LD_VAR 0 7
67381: ARRAY
67382: PUSH
67383: LD_INT 1
67385: ARRAY
67386: PPUSH
67387: LD_VAR 0 12
67391: PUSH
67392: LD_VAR 0 7
67396: ARRAY
67397: PUSH
67398: LD_INT 2
67400: ARRAY
67401: PPUSH
67402: CALL_OW 488
67406: NOT
67407: PUSH
67408: LD_VAR 0 12
67412: PUSH
67413: LD_VAR 0 7
67417: ARRAY
67418: PUSH
67419: LD_INT 1
67421: ARRAY
67422: PPUSH
67423: LD_VAR 0 12
67427: PUSH
67428: LD_VAR 0 7
67432: ARRAY
67433: PUSH
67434: LD_INT 2
67436: ARRAY
67437: PPUSH
67438: CALL_OW 428
67442: PUSH
67443: LD_INT 0
67445: GREATER
67446: OR
67447: PUSH
67448: LD_VAR 0 12
67452: PUSH
67453: LD_VAR 0 7
67457: ARRAY
67458: PUSH
67459: LD_INT 1
67461: ARRAY
67462: PPUSH
67463: LD_VAR 0 12
67467: PUSH
67468: LD_VAR 0 7
67472: ARRAY
67473: PUSH
67474: LD_INT 2
67476: ARRAY
67477: PPUSH
67478: CALL_OW 351
67482: OR
67483: IFFALSE 67489
// exit ;
67485: POP
67486: POP
67487: GO 67781
// j := GetHexInfo ( hexes [ i ] [ 1 ] , hexes [ i ] [ 2 ] ) ;
67489: LD_ADDR_VAR 0 8
67493: PUSH
67494: LD_VAR 0 12
67498: PUSH
67499: LD_VAR 0 7
67503: ARRAY
67504: PUSH
67505: LD_INT 1
67507: ARRAY
67508: PPUSH
67509: LD_VAR 0 12
67513: PUSH
67514: LD_VAR 0 7
67518: ARRAY
67519: PUSH
67520: LD_INT 2
67522: ARRAY
67523: PPUSH
67524: CALL_OW 546
67528: ST_TO_ADDR
// if j [ 1 ] or j [ 2 ] > height + 2 or j [ 2 ] < height - 2 or not j [ 3 ] in [ 0 , 8 , 9 , 10 , 11 , 12 , 13 , 16 , 17 , 18 , 19 , 20 , 21 ] or not j [ 5 ] or not j [ 6 ] in [ 1 , 2 , 7 , 9 , 10 , 11 ] then
67529: LD_VAR 0 8
67533: PUSH
67534: LD_INT 1
67536: ARRAY
67537: PUSH
67538: LD_VAR 0 8
67542: PUSH
67543: LD_INT 2
67545: ARRAY
67546: PUSH
67547: LD_VAR 0 13
67551: PUSH
67552: LD_INT 2
67554: PLUS
67555: GREATER
67556: OR
67557: PUSH
67558: LD_VAR 0 8
67562: PUSH
67563: LD_INT 2
67565: ARRAY
67566: PUSH
67567: LD_VAR 0 13
67571: PUSH
67572: LD_INT 2
67574: MINUS
67575: LESS
67576: OR
67577: PUSH
67578: LD_VAR 0 8
67582: PUSH
67583: LD_INT 3
67585: ARRAY
67586: PUSH
67587: LD_INT 0
67589: PUSH
67590: LD_INT 8
67592: PUSH
67593: LD_INT 9
67595: PUSH
67596: LD_INT 10
67598: PUSH
67599: LD_INT 11
67601: PUSH
67602: LD_INT 12
67604: PUSH
67605: LD_INT 13
67607: PUSH
67608: LD_INT 16
67610: PUSH
67611: LD_INT 17
67613: PUSH
67614: LD_INT 18
67616: PUSH
67617: LD_INT 19
67619: PUSH
67620: LD_INT 20
67622: PUSH
67623: LD_INT 21
67625: PUSH
67626: EMPTY
67627: LIST
67628: LIST
67629: LIST
67630: LIST
67631: LIST
67632: LIST
67633: LIST
67634: LIST
67635: LIST
67636: LIST
67637: LIST
67638: LIST
67639: LIST
67640: IN
67641: NOT
67642: OR
67643: PUSH
67644: LD_VAR 0 8
67648: PUSH
67649: LD_INT 5
67651: ARRAY
67652: NOT
67653: OR
67654: PUSH
67655: LD_VAR 0 8
67659: PUSH
67660: LD_INT 6
67662: ARRAY
67663: PUSH
67664: LD_INT 1
67666: PUSH
67667: LD_INT 2
67669: PUSH
67670: LD_INT 7
67672: PUSH
67673: LD_INT 9
67675: PUSH
67676: LD_INT 10
67678: PUSH
67679: LD_INT 11
67681: PUSH
67682: EMPTY
67683: LIST
67684: LIST
67685: LIST
67686: LIST
67687: LIST
67688: LIST
67689: IN
67690: NOT
67691: OR
67692: IFFALSE 67698
// exit ;
67694: POP
67695: POP
67696: GO 67781
// end ;
67698: GO 67369
67700: POP
67701: POP
// if DangerAtRangeXY ( side , x , y , 20 ) [ 4 ] then
67702: LD_VAR 0 9
67706: PPUSH
67707: LD_VAR 0 3
67711: PPUSH
67712: LD_VAR 0 4
67716: PPUSH
67717: LD_INT 20
67719: PPUSH
67720: CALL 59704 0 4
67724: PUSH
67725: LD_INT 4
67727: ARRAY
67728: IFFALSE 67732
// exit ;
67730: GO 67781
// if btype in [ b_oil_mine , b_siberite_mine ] and not GetResourceVisibility ( x , y , side ) then
67732: LD_VAR 0 2
67736: PUSH
67737: LD_INT 29
67739: PUSH
67740: LD_INT 30
67742: PUSH
67743: EMPTY
67744: LIST
67745: LIST
67746: IN
67747: PUSH
67748: LD_VAR 0 3
67752: PPUSH
67753: LD_VAR 0 4
67757: PPUSH
67758: LD_VAR 0 9
67762: PPUSH
67763: CALL_OW 440
67767: NOT
67768: AND
67769: IFFALSE 67773
// exit ;
67771: GO 67781
// result := true ;
67773: LD_ADDR_VAR 0 6
67777: PUSH
67778: LD_INT 1
67780: ST_TO_ADDR
// end ;
67781: LD_VAR 0 6
67785: RET
// export function GetBuildingHexes ( btype , x , y , dir , nation , mode ) ; var i , temp_list , temp_list2 ; var fDepotAm0 , fDepotAm1 , fDepotAm2 , fDepotAm3 , fDepotAm4 , fDepotAm5 , fDepotAr0 , fDepotAr1 , fDepotAr2 , fDepotAr3 , fDepotAr4 , fDepotAr5 , fDepotRu0 , fDepotRu1 , fDepotRu2 , fDepotRu3 , fDepotRu4 , fDepotRu5 ; var fFactory0 , fFactory1 , fFactory2 , fFactory3 , fFactory4 , fFactory5 , fExt0 , fExt1 , fExt2 , fExt3 , fExt4 , fExt5 ; var fLab0 , fLab1 , fLab2 , fLab3 , fLab4 , fLab5 , fControlTower0 , fControlTower1 , fControlTower2 , fControlTower3 , fControlTower4 , fControlTower5 ; var fBarracks0 , fBarracks1 , fBarracks2 , fBarracks3 , fBarracks4 , fBarracks5 , fBunker0 , fBunker1 , fBunker2 , fBunker3 , fBunker4 , fBunker5 ; begin
67786: LD_INT 0
67788: PPUSH
67789: PPUSH
67790: PPUSH
67791: PPUSH
67792: PPUSH
67793: PPUSH
67794: PPUSH
67795: PPUSH
67796: PPUSH
67797: PPUSH
67798: PPUSH
67799: PPUSH
67800: PPUSH
67801: PPUSH
67802: PPUSH
67803: PPUSH
67804: PPUSH
67805: PPUSH
67806: PPUSH
67807: PPUSH
67808: PPUSH
67809: PPUSH
67810: PPUSH
67811: PPUSH
67812: PPUSH
67813: PPUSH
67814: PPUSH
67815: PPUSH
67816: PPUSH
67817: PPUSH
67818: PPUSH
67819: PPUSH
67820: PPUSH
67821: PPUSH
67822: PPUSH
67823: PPUSH
67824: PPUSH
67825: PPUSH
67826: PPUSH
67827: PPUSH
67828: PPUSH
67829: PPUSH
67830: PPUSH
67831: PPUSH
67832: PPUSH
67833: PPUSH
67834: PPUSH
67835: PPUSH
67836: PPUSH
67837: PPUSH
67838: PPUSH
67839: PPUSH
67840: PPUSH
67841: PPUSH
67842: PPUSH
67843: PPUSH
67844: PPUSH
67845: PPUSH
// result = [ ] ;
67846: LD_ADDR_VAR 0 7
67850: PUSH
67851: EMPTY
67852: ST_TO_ADDR
// temp_list = [ ] ;
67853: LD_ADDR_VAR 0 9
67857: PUSH
67858: EMPTY
67859: ST_TO_ADDR
// if not dir in [ 0 , 1 , 2 , 3 , 4 , 5 ] or ( btype in [ b_depot , b_warehouse ] and not nation in [ nation_american , nation_arabian , nation_russian ] ) then
67860: LD_VAR 0 4
67864: PUSH
67865: LD_INT 0
67867: PUSH
67868: LD_INT 1
67870: PUSH
67871: LD_INT 2
67873: PUSH
67874: LD_INT 3
67876: PUSH
67877: LD_INT 4
67879: PUSH
67880: LD_INT 5
67882: PUSH
67883: EMPTY
67884: LIST
67885: LIST
67886: LIST
67887: LIST
67888: LIST
67889: LIST
67890: IN
67891: NOT
67892: PUSH
67893: LD_VAR 0 1
67897: PUSH
67898: LD_INT 0
67900: PUSH
67901: LD_INT 1
67903: PUSH
67904: EMPTY
67905: LIST
67906: LIST
67907: IN
67908: PUSH
67909: LD_VAR 0 5
67913: PUSH
67914: LD_INT 1
67916: PUSH
67917: LD_INT 2
67919: PUSH
67920: LD_INT 3
67922: PUSH
67923: EMPTY
67924: LIST
67925: LIST
67926: LIST
67927: IN
67928: NOT
67929: AND
67930: OR
67931: IFFALSE 67935
// exit ;
67933: GO 86326
// if btype in [ b_lab , b_lab_half , b_lab_full , b_lab_biological , b_lab_computer , b_lab_opto , b_lab_siberium , b_lab_spacetime , b_lab_weapon ] then
67935: LD_VAR 0 1
67939: PUSH
67940: LD_INT 6
67942: PUSH
67943: LD_INT 7
67945: PUSH
67946: LD_INT 8
67948: PUSH
67949: LD_INT 13
67951: PUSH
67952: LD_INT 12
67954: PUSH
67955: LD_INT 15
67957: PUSH
67958: LD_INT 11
67960: PUSH
67961: LD_INT 14
67963: PUSH
67964: LD_INT 10
67966: PUSH
67967: EMPTY
67968: LIST
67969: LIST
67970: LIST
67971: LIST
67972: LIST
67973: LIST
67974: LIST
67975: LIST
67976: LIST
67977: IN
67978: IFFALSE 67988
// btype = b_lab ;
67980: LD_ADDR_VAR 0 1
67984: PUSH
67985: LD_INT 6
67987: ST_TO_ADDR
// if not mode in [ 0 , 1 , 2 ] or ( not btype in [ b_depot , b_warehouse , b_workshop , b_factory , b_lab , b_control_tower , b_armoury , b_barracks , b_breastwork , b_bunker , b_turret ] and mode = 1 ) or ( not btype in [ b_workshop , b_factory ] and mode = 2 ) then
67988: LD_VAR 0 6
67992: PUSH
67993: LD_INT 0
67995: PUSH
67996: LD_INT 1
67998: PUSH
67999: LD_INT 2
68001: PUSH
68002: EMPTY
68003: LIST
68004: LIST
68005: LIST
68006: IN
68007: NOT
68008: PUSH
68009: LD_VAR 0 1
68013: PUSH
68014: LD_INT 0
68016: PUSH
68017: LD_INT 1
68019: PUSH
68020: LD_INT 2
68022: PUSH
68023: LD_INT 3
68025: PUSH
68026: LD_INT 6
68028: PUSH
68029: LD_INT 36
68031: PUSH
68032: LD_INT 4
68034: PUSH
68035: LD_INT 5
68037: PUSH
68038: LD_INT 31
68040: PUSH
68041: LD_INT 32
68043: PUSH
68044: LD_INT 33
68046: PUSH
68047: EMPTY
68048: LIST
68049: LIST
68050: LIST
68051: LIST
68052: LIST
68053: LIST
68054: LIST
68055: LIST
68056: LIST
68057: LIST
68058: LIST
68059: IN
68060: NOT
68061: PUSH
68062: LD_VAR 0 6
68066: PUSH
68067: LD_INT 1
68069: EQUAL
68070: AND
68071: OR
68072: PUSH
68073: LD_VAR 0 1
68077: PUSH
68078: LD_INT 2
68080: PUSH
68081: LD_INT 3
68083: PUSH
68084: EMPTY
68085: LIST
68086: LIST
68087: IN
68088: NOT
68089: PUSH
68090: LD_VAR 0 6
68094: PUSH
68095: LD_INT 2
68097: EQUAL
68098: AND
68099: OR
68100: IFFALSE 68110
// mode = 0 ;
68102: LD_ADDR_VAR 0 6
68106: PUSH
68107: LD_INT 0
68109: ST_TO_ADDR
// case mode of 0 :
68110: LD_VAR 0 6
68114: PUSH
68115: LD_INT 0
68117: DOUBLE
68118: EQUAL
68119: IFTRUE 68123
68121: GO 79576
68123: POP
// begin fDepotAm0 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ 1 , 3 ] , [ 0 , 3 ] , [ - 1 , 2 ] ] ;
68124: LD_ADDR_VAR 0 11
68128: PUSH
68129: LD_INT 0
68131: PUSH
68132: LD_INT 0
68134: PUSH
68135: EMPTY
68136: LIST
68137: LIST
68138: PUSH
68139: LD_INT 0
68141: PUSH
68142: LD_INT 1
68144: NEG
68145: PUSH
68146: EMPTY
68147: LIST
68148: LIST
68149: PUSH
68150: LD_INT 1
68152: PUSH
68153: LD_INT 0
68155: PUSH
68156: EMPTY
68157: LIST
68158: LIST
68159: PUSH
68160: LD_INT 1
68162: PUSH
68163: LD_INT 1
68165: PUSH
68166: EMPTY
68167: LIST
68168: LIST
68169: PUSH
68170: LD_INT 0
68172: PUSH
68173: LD_INT 1
68175: PUSH
68176: EMPTY
68177: LIST
68178: LIST
68179: PUSH
68180: LD_INT 1
68182: NEG
68183: PUSH
68184: LD_INT 0
68186: PUSH
68187: EMPTY
68188: LIST
68189: LIST
68190: PUSH
68191: LD_INT 1
68193: NEG
68194: PUSH
68195: LD_INT 1
68197: NEG
68198: PUSH
68199: EMPTY
68200: LIST
68201: LIST
68202: PUSH
68203: LD_INT 1
68205: NEG
68206: PUSH
68207: LD_INT 2
68209: NEG
68210: PUSH
68211: EMPTY
68212: LIST
68213: LIST
68214: PUSH
68215: LD_INT 0
68217: PUSH
68218: LD_INT 2
68220: NEG
68221: PUSH
68222: EMPTY
68223: LIST
68224: LIST
68225: PUSH
68226: LD_INT 1
68228: PUSH
68229: LD_INT 1
68231: NEG
68232: PUSH
68233: EMPTY
68234: LIST
68235: LIST
68236: PUSH
68237: LD_INT 1
68239: PUSH
68240: LD_INT 2
68242: PUSH
68243: EMPTY
68244: LIST
68245: LIST
68246: PUSH
68247: LD_INT 0
68249: PUSH
68250: LD_INT 2
68252: PUSH
68253: EMPTY
68254: LIST
68255: LIST
68256: PUSH
68257: LD_INT 1
68259: NEG
68260: PUSH
68261: LD_INT 1
68263: PUSH
68264: EMPTY
68265: LIST
68266: LIST
68267: PUSH
68268: LD_INT 1
68270: PUSH
68271: LD_INT 3
68273: PUSH
68274: EMPTY
68275: LIST
68276: LIST
68277: PUSH
68278: LD_INT 0
68280: PUSH
68281: LD_INT 3
68283: PUSH
68284: EMPTY
68285: LIST
68286: LIST
68287: PUSH
68288: LD_INT 1
68290: NEG
68291: PUSH
68292: LD_INT 2
68294: PUSH
68295: EMPTY
68296: LIST
68297: LIST
68298: PUSH
68299: EMPTY
68300: LIST
68301: LIST
68302: LIST
68303: LIST
68304: LIST
68305: LIST
68306: LIST
68307: LIST
68308: LIST
68309: LIST
68310: LIST
68311: LIST
68312: LIST
68313: LIST
68314: LIST
68315: LIST
68316: ST_TO_ADDR
// fDepotAm1 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , 1 ] , [ - 3 , 0 ] , [ - 3 , - 1 ] ] ;
68317: LD_ADDR_VAR 0 12
68321: PUSH
68322: LD_INT 0
68324: PUSH
68325: LD_INT 0
68327: PUSH
68328: EMPTY
68329: LIST
68330: LIST
68331: PUSH
68332: LD_INT 0
68334: PUSH
68335: LD_INT 1
68337: NEG
68338: PUSH
68339: EMPTY
68340: LIST
68341: LIST
68342: PUSH
68343: LD_INT 1
68345: PUSH
68346: LD_INT 0
68348: PUSH
68349: EMPTY
68350: LIST
68351: LIST
68352: PUSH
68353: LD_INT 1
68355: PUSH
68356: LD_INT 1
68358: PUSH
68359: EMPTY
68360: LIST
68361: LIST
68362: PUSH
68363: LD_INT 0
68365: PUSH
68366: LD_INT 1
68368: PUSH
68369: EMPTY
68370: LIST
68371: LIST
68372: PUSH
68373: LD_INT 1
68375: NEG
68376: PUSH
68377: LD_INT 0
68379: PUSH
68380: EMPTY
68381: LIST
68382: LIST
68383: PUSH
68384: LD_INT 1
68386: NEG
68387: PUSH
68388: LD_INT 1
68390: NEG
68391: PUSH
68392: EMPTY
68393: LIST
68394: LIST
68395: PUSH
68396: LD_INT 1
68398: PUSH
68399: LD_INT 1
68401: NEG
68402: PUSH
68403: EMPTY
68404: LIST
68405: LIST
68406: PUSH
68407: LD_INT 2
68409: PUSH
68410: LD_INT 0
68412: PUSH
68413: EMPTY
68414: LIST
68415: LIST
68416: PUSH
68417: LD_INT 2
68419: PUSH
68420: LD_INT 1
68422: PUSH
68423: EMPTY
68424: LIST
68425: LIST
68426: PUSH
68427: LD_INT 1
68429: NEG
68430: PUSH
68431: LD_INT 1
68433: PUSH
68434: EMPTY
68435: LIST
68436: LIST
68437: PUSH
68438: LD_INT 2
68440: NEG
68441: PUSH
68442: LD_INT 0
68444: PUSH
68445: EMPTY
68446: LIST
68447: LIST
68448: PUSH
68449: LD_INT 2
68451: NEG
68452: PUSH
68453: LD_INT 1
68455: NEG
68456: PUSH
68457: EMPTY
68458: LIST
68459: LIST
68460: PUSH
68461: LD_INT 2
68463: NEG
68464: PUSH
68465: LD_INT 1
68467: PUSH
68468: EMPTY
68469: LIST
68470: LIST
68471: PUSH
68472: LD_INT 3
68474: NEG
68475: PUSH
68476: LD_INT 0
68478: PUSH
68479: EMPTY
68480: LIST
68481: LIST
68482: PUSH
68483: LD_INT 3
68485: NEG
68486: PUSH
68487: LD_INT 1
68489: NEG
68490: PUSH
68491: EMPTY
68492: LIST
68493: LIST
68494: PUSH
68495: EMPTY
68496: LIST
68497: LIST
68498: LIST
68499: LIST
68500: LIST
68501: LIST
68502: LIST
68503: LIST
68504: LIST
68505: LIST
68506: LIST
68507: LIST
68508: LIST
68509: LIST
68510: LIST
68511: LIST
68512: ST_TO_ADDR
// fDepotAm2 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ - 2 , - 3 ] , [ - 3 , - 2 ] , [ - 3 , - 3 ] ] ;
68513: LD_ADDR_VAR 0 13
68517: PUSH
68518: LD_INT 0
68520: PUSH
68521: LD_INT 0
68523: PUSH
68524: EMPTY
68525: LIST
68526: LIST
68527: PUSH
68528: LD_INT 0
68530: PUSH
68531: LD_INT 1
68533: NEG
68534: PUSH
68535: EMPTY
68536: LIST
68537: LIST
68538: PUSH
68539: LD_INT 1
68541: PUSH
68542: LD_INT 0
68544: PUSH
68545: EMPTY
68546: LIST
68547: LIST
68548: PUSH
68549: LD_INT 1
68551: PUSH
68552: LD_INT 1
68554: PUSH
68555: EMPTY
68556: LIST
68557: LIST
68558: PUSH
68559: LD_INT 0
68561: PUSH
68562: LD_INT 1
68564: PUSH
68565: EMPTY
68566: LIST
68567: LIST
68568: PUSH
68569: LD_INT 1
68571: NEG
68572: PUSH
68573: LD_INT 0
68575: PUSH
68576: EMPTY
68577: LIST
68578: LIST
68579: PUSH
68580: LD_INT 1
68582: NEG
68583: PUSH
68584: LD_INT 1
68586: NEG
68587: PUSH
68588: EMPTY
68589: LIST
68590: LIST
68591: PUSH
68592: LD_INT 1
68594: NEG
68595: PUSH
68596: LD_INT 2
68598: NEG
68599: PUSH
68600: EMPTY
68601: LIST
68602: LIST
68603: PUSH
68604: LD_INT 2
68606: PUSH
68607: LD_INT 1
68609: PUSH
68610: EMPTY
68611: LIST
68612: LIST
68613: PUSH
68614: LD_INT 2
68616: PUSH
68617: LD_INT 2
68619: PUSH
68620: EMPTY
68621: LIST
68622: LIST
68623: PUSH
68624: LD_INT 1
68626: PUSH
68627: LD_INT 2
68629: PUSH
68630: EMPTY
68631: LIST
68632: LIST
68633: PUSH
68634: LD_INT 2
68636: NEG
68637: PUSH
68638: LD_INT 1
68640: NEG
68641: PUSH
68642: EMPTY
68643: LIST
68644: LIST
68645: PUSH
68646: LD_INT 2
68648: NEG
68649: PUSH
68650: LD_INT 2
68652: NEG
68653: PUSH
68654: EMPTY
68655: LIST
68656: LIST
68657: PUSH
68658: LD_INT 2
68660: NEG
68661: PUSH
68662: LD_INT 3
68664: NEG
68665: PUSH
68666: EMPTY
68667: LIST
68668: LIST
68669: PUSH
68670: LD_INT 3
68672: NEG
68673: PUSH
68674: LD_INT 2
68676: NEG
68677: PUSH
68678: EMPTY
68679: LIST
68680: LIST
68681: PUSH
68682: LD_INT 3
68684: NEG
68685: PUSH
68686: LD_INT 3
68688: NEG
68689: PUSH
68690: EMPTY
68691: LIST
68692: LIST
68693: PUSH
68694: EMPTY
68695: LIST
68696: LIST
68697: LIST
68698: LIST
68699: LIST
68700: LIST
68701: LIST
68702: LIST
68703: LIST
68704: LIST
68705: LIST
68706: LIST
68707: LIST
68708: LIST
68709: LIST
68710: LIST
68711: ST_TO_ADDR
// fDepotAm3 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 1 , - 3 ] , [ 0 , - 3 ] , [ 1 , - 2 ] ] ;
68712: LD_ADDR_VAR 0 14
68716: PUSH
68717: LD_INT 0
68719: PUSH
68720: LD_INT 0
68722: PUSH
68723: EMPTY
68724: LIST
68725: LIST
68726: PUSH
68727: LD_INT 0
68729: PUSH
68730: LD_INT 1
68732: NEG
68733: PUSH
68734: EMPTY
68735: LIST
68736: LIST
68737: PUSH
68738: LD_INT 1
68740: PUSH
68741: LD_INT 0
68743: PUSH
68744: EMPTY
68745: LIST
68746: LIST
68747: PUSH
68748: LD_INT 1
68750: PUSH
68751: LD_INT 1
68753: PUSH
68754: EMPTY
68755: LIST
68756: LIST
68757: PUSH
68758: LD_INT 0
68760: PUSH
68761: LD_INT 1
68763: PUSH
68764: EMPTY
68765: LIST
68766: LIST
68767: PUSH
68768: LD_INT 1
68770: NEG
68771: PUSH
68772: LD_INT 0
68774: PUSH
68775: EMPTY
68776: LIST
68777: LIST
68778: PUSH
68779: LD_INT 1
68781: NEG
68782: PUSH
68783: LD_INT 1
68785: NEG
68786: PUSH
68787: EMPTY
68788: LIST
68789: LIST
68790: PUSH
68791: LD_INT 1
68793: NEG
68794: PUSH
68795: LD_INT 2
68797: NEG
68798: PUSH
68799: EMPTY
68800: LIST
68801: LIST
68802: PUSH
68803: LD_INT 0
68805: PUSH
68806: LD_INT 2
68808: NEG
68809: PUSH
68810: EMPTY
68811: LIST
68812: LIST
68813: PUSH
68814: LD_INT 1
68816: PUSH
68817: LD_INT 1
68819: NEG
68820: PUSH
68821: EMPTY
68822: LIST
68823: LIST
68824: PUSH
68825: LD_INT 1
68827: PUSH
68828: LD_INT 2
68830: PUSH
68831: EMPTY
68832: LIST
68833: LIST
68834: PUSH
68835: LD_INT 0
68837: PUSH
68838: LD_INT 2
68840: PUSH
68841: EMPTY
68842: LIST
68843: LIST
68844: PUSH
68845: LD_INT 1
68847: NEG
68848: PUSH
68849: LD_INT 1
68851: PUSH
68852: EMPTY
68853: LIST
68854: LIST
68855: PUSH
68856: LD_INT 1
68858: NEG
68859: PUSH
68860: LD_INT 3
68862: NEG
68863: PUSH
68864: EMPTY
68865: LIST
68866: LIST
68867: PUSH
68868: LD_INT 0
68870: PUSH
68871: LD_INT 3
68873: NEG
68874: PUSH
68875: EMPTY
68876: LIST
68877: LIST
68878: PUSH
68879: LD_INT 1
68881: PUSH
68882: LD_INT 2
68884: NEG
68885: PUSH
68886: EMPTY
68887: LIST
68888: LIST
68889: PUSH
68890: EMPTY
68891: LIST
68892: LIST
68893: LIST
68894: LIST
68895: LIST
68896: LIST
68897: LIST
68898: LIST
68899: LIST
68900: LIST
68901: LIST
68902: LIST
68903: LIST
68904: LIST
68905: LIST
68906: LIST
68907: ST_TO_ADDR
// fDepotAm4 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ 2 , - 1 ] , [ 3 , 0 ] , [ 3 , 1 ] ] ;
68908: LD_ADDR_VAR 0 15
68912: PUSH
68913: LD_INT 0
68915: PUSH
68916: LD_INT 0
68918: PUSH
68919: EMPTY
68920: LIST
68921: LIST
68922: PUSH
68923: LD_INT 0
68925: PUSH
68926: LD_INT 1
68928: NEG
68929: PUSH
68930: EMPTY
68931: LIST
68932: LIST
68933: PUSH
68934: LD_INT 1
68936: PUSH
68937: LD_INT 0
68939: PUSH
68940: EMPTY
68941: LIST
68942: LIST
68943: PUSH
68944: LD_INT 1
68946: PUSH
68947: LD_INT 1
68949: PUSH
68950: EMPTY
68951: LIST
68952: LIST
68953: PUSH
68954: LD_INT 0
68956: PUSH
68957: LD_INT 1
68959: PUSH
68960: EMPTY
68961: LIST
68962: LIST
68963: PUSH
68964: LD_INT 1
68966: NEG
68967: PUSH
68968: LD_INT 0
68970: PUSH
68971: EMPTY
68972: LIST
68973: LIST
68974: PUSH
68975: LD_INT 1
68977: NEG
68978: PUSH
68979: LD_INT 1
68981: NEG
68982: PUSH
68983: EMPTY
68984: LIST
68985: LIST
68986: PUSH
68987: LD_INT 1
68989: PUSH
68990: LD_INT 1
68992: NEG
68993: PUSH
68994: EMPTY
68995: LIST
68996: LIST
68997: PUSH
68998: LD_INT 2
69000: PUSH
69001: LD_INT 0
69003: PUSH
69004: EMPTY
69005: LIST
69006: LIST
69007: PUSH
69008: LD_INT 2
69010: PUSH
69011: LD_INT 1
69013: PUSH
69014: EMPTY
69015: LIST
69016: LIST
69017: PUSH
69018: LD_INT 1
69020: NEG
69021: PUSH
69022: LD_INT 1
69024: PUSH
69025: EMPTY
69026: LIST
69027: LIST
69028: PUSH
69029: LD_INT 2
69031: NEG
69032: PUSH
69033: LD_INT 0
69035: PUSH
69036: EMPTY
69037: LIST
69038: LIST
69039: PUSH
69040: LD_INT 2
69042: NEG
69043: PUSH
69044: LD_INT 1
69046: NEG
69047: PUSH
69048: EMPTY
69049: LIST
69050: LIST
69051: PUSH
69052: LD_INT 2
69054: PUSH
69055: LD_INT 1
69057: NEG
69058: PUSH
69059: EMPTY
69060: LIST
69061: LIST
69062: PUSH
69063: LD_INT 3
69065: PUSH
69066: LD_INT 0
69068: PUSH
69069: EMPTY
69070: LIST
69071: LIST
69072: PUSH
69073: LD_INT 3
69075: PUSH
69076: LD_INT 1
69078: PUSH
69079: EMPTY
69080: LIST
69081: LIST
69082: PUSH
69083: EMPTY
69084: LIST
69085: LIST
69086: LIST
69087: LIST
69088: LIST
69089: LIST
69090: LIST
69091: LIST
69092: LIST
69093: LIST
69094: LIST
69095: LIST
69096: LIST
69097: LIST
69098: LIST
69099: LIST
69100: ST_TO_ADDR
// fDepotAm5 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ 3 , 2 ] , [ 3 , 3 ] , [ 2 , 3 ] ] ;
69101: LD_ADDR_VAR 0 16
69105: PUSH
69106: LD_INT 0
69108: PUSH
69109: LD_INT 0
69111: PUSH
69112: EMPTY
69113: LIST
69114: LIST
69115: PUSH
69116: LD_INT 0
69118: PUSH
69119: LD_INT 1
69121: NEG
69122: PUSH
69123: EMPTY
69124: LIST
69125: LIST
69126: PUSH
69127: LD_INT 1
69129: PUSH
69130: LD_INT 0
69132: PUSH
69133: EMPTY
69134: LIST
69135: LIST
69136: PUSH
69137: LD_INT 1
69139: PUSH
69140: LD_INT 1
69142: PUSH
69143: EMPTY
69144: LIST
69145: LIST
69146: PUSH
69147: LD_INT 0
69149: PUSH
69150: LD_INT 1
69152: PUSH
69153: EMPTY
69154: LIST
69155: LIST
69156: PUSH
69157: LD_INT 1
69159: NEG
69160: PUSH
69161: LD_INT 0
69163: PUSH
69164: EMPTY
69165: LIST
69166: LIST
69167: PUSH
69168: LD_INT 1
69170: NEG
69171: PUSH
69172: LD_INT 1
69174: NEG
69175: PUSH
69176: EMPTY
69177: LIST
69178: LIST
69179: PUSH
69180: LD_INT 1
69182: NEG
69183: PUSH
69184: LD_INT 2
69186: NEG
69187: PUSH
69188: EMPTY
69189: LIST
69190: LIST
69191: PUSH
69192: LD_INT 2
69194: PUSH
69195: LD_INT 1
69197: PUSH
69198: EMPTY
69199: LIST
69200: LIST
69201: PUSH
69202: LD_INT 2
69204: PUSH
69205: LD_INT 2
69207: PUSH
69208: EMPTY
69209: LIST
69210: LIST
69211: PUSH
69212: LD_INT 1
69214: PUSH
69215: LD_INT 2
69217: PUSH
69218: EMPTY
69219: LIST
69220: LIST
69221: PUSH
69222: LD_INT 2
69224: NEG
69225: PUSH
69226: LD_INT 1
69228: NEG
69229: PUSH
69230: EMPTY
69231: LIST
69232: LIST
69233: PUSH
69234: LD_INT 2
69236: NEG
69237: PUSH
69238: LD_INT 2
69240: NEG
69241: PUSH
69242: EMPTY
69243: LIST
69244: LIST
69245: PUSH
69246: LD_INT 3
69248: PUSH
69249: LD_INT 2
69251: PUSH
69252: EMPTY
69253: LIST
69254: LIST
69255: PUSH
69256: LD_INT 3
69258: PUSH
69259: LD_INT 3
69261: PUSH
69262: EMPTY
69263: LIST
69264: LIST
69265: PUSH
69266: LD_INT 2
69268: PUSH
69269: LD_INT 3
69271: PUSH
69272: EMPTY
69273: LIST
69274: LIST
69275: PUSH
69276: EMPTY
69277: LIST
69278: LIST
69279: LIST
69280: LIST
69281: LIST
69282: LIST
69283: LIST
69284: LIST
69285: LIST
69286: LIST
69287: LIST
69288: LIST
69289: LIST
69290: LIST
69291: LIST
69292: LIST
69293: ST_TO_ADDR
// fDepotAr0 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
69294: LD_ADDR_VAR 0 17
69298: PUSH
69299: LD_INT 0
69301: PUSH
69302: LD_INT 0
69304: PUSH
69305: EMPTY
69306: LIST
69307: LIST
69308: PUSH
69309: LD_INT 0
69311: PUSH
69312: LD_INT 1
69314: NEG
69315: PUSH
69316: EMPTY
69317: LIST
69318: LIST
69319: PUSH
69320: LD_INT 1
69322: PUSH
69323: LD_INT 0
69325: PUSH
69326: EMPTY
69327: LIST
69328: LIST
69329: PUSH
69330: LD_INT 1
69332: PUSH
69333: LD_INT 1
69335: PUSH
69336: EMPTY
69337: LIST
69338: LIST
69339: PUSH
69340: LD_INT 0
69342: PUSH
69343: LD_INT 1
69345: PUSH
69346: EMPTY
69347: LIST
69348: LIST
69349: PUSH
69350: LD_INT 1
69352: NEG
69353: PUSH
69354: LD_INT 0
69356: PUSH
69357: EMPTY
69358: LIST
69359: LIST
69360: PUSH
69361: LD_INT 1
69363: NEG
69364: PUSH
69365: LD_INT 1
69367: NEG
69368: PUSH
69369: EMPTY
69370: LIST
69371: LIST
69372: PUSH
69373: LD_INT 1
69375: NEG
69376: PUSH
69377: LD_INT 2
69379: NEG
69380: PUSH
69381: EMPTY
69382: LIST
69383: LIST
69384: PUSH
69385: LD_INT 0
69387: PUSH
69388: LD_INT 2
69390: NEG
69391: PUSH
69392: EMPTY
69393: LIST
69394: LIST
69395: PUSH
69396: LD_INT 1
69398: PUSH
69399: LD_INT 1
69401: NEG
69402: PUSH
69403: EMPTY
69404: LIST
69405: LIST
69406: PUSH
69407: LD_INT 2
69409: PUSH
69410: LD_INT 0
69412: PUSH
69413: EMPTY
69414: LIST
69415: LIST
69416: PUSH
69417: LD_INT 2
69419: PUSH
69420: LD_INT 1
69422: PUSH
69423: EMPTY
69424: LIST
69425: LIST
69426: PUSH
69427: LD_INT 2
69429: PUSH
69430: LD_INT 2
69432: PUSH
69433: EMPTY
69434: LIST
69435: LIST
69436: PUSH
69437: LD_INT 1
69439: PUSH
69440: LD_INT 2
69442: PUSH
69443: EMPTY
69444: LIST
69445: LIST
69446: PUSH
69447: LD_INT 0
69449: PUSH
69450: LD_INT 2
69452: PUSH
69453: EMPTY
69454: LIST
69455: LIST
69456: PUSH
69457: LD_INT 1
69459: NEG
69460: PUSH
69461: LD_INT 1
69463: PUSH
69464: EMPTY
69465: LIST
69466: LIST
69467: PUSH
69468: LD_INT 2
69470: NEG
69471: PUSH
69472: LD_INT 0
69474: PUSH
69475: EMPTY
69476: LIST
69477: LIST
69478: PUSH
69479: LD_INT 2
69481: NEG
69482: PUSH
69483: LD_INT 1
69485: NEG
69486: PUSH
69487: EMPTY
69488: LIST
69489: LIST
69490: PUSH
69491: LD_INT 2
69493: NEG
69494: PUSH
69495: LD_INT 2
69497: NEG
69498: PUSH
69499: EMPTY
69500: LIST
69501: LIST
69502: PUSH
69503: EMPTY
69504: LIST
69505: LIST
69506: LIST
69507: LIST
69508: LIST
69509: LIST
69510: LIST
69511: LIST
69512: LIST
69513: LIST
69514: LIST
69515: LIST
69516: LIST
69517: LIST
69518: LIST
69519: LIST
69520: LIST
69521: LIST
69522: LIST
69523: ST_TO_ADDR
// fDepotAr1 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
69524: LD_ADDR_VAR 0 18
69528: PUSH
69529: LD_INT 0
69531: PUSH
69532: LD_INT 0
69534: PUSH
69535: EMPTY
69536: LIST
69537: LIST
69538: PUSH
69539: LD_INT 0
69541: PUSH
69542: LD_INT 1
69544: NEG
69545: PUSH
69546: EMPTY
69547: LIST
69548: LIST
69549: PUSH
69550: LD_INT 1
69552: PUSH
69553: LD_INT 0
69555: PUSH
69556: EMPTY
69557: LIST
69558: LIST
69559: PUSH
69560: LD_INT 1
69562: PUSH
69563: LD_INT 1
69565: PUSH
69566: EMPTY
69567: LIST
69568: LIST
69569: PUSH
69570: LD_INT 0
69572: PUSH
69573: LD_INT 1
69575: PUSH
69576: EMPTY
69577: LIST
69578: LIST
69579: PUSH
69580: LD_INT 1
69582: NEG
69583: PUSH
69584: LD_INT 0
69586: PUSH
69587: EMPTY
69588: LIST
69589: LIST
69590: PUSH
69591: LD_INT 1
69593: NEG
69594: PUSH
69595: LD_INT 1
69597: NEG
69598: PUSH
69599: EMPTY
69600: LIST
69601: LIST
69602: PUSH
69603: LD_INT 1
69605: NEG
69606: PUSH
69607: LD_INT 2
69609: NEG
69610: PUSH
69611: EMPTY
69612: LIST
69613: LIST
69614: PUSH
69615: LD_INT 0
69617: PUSH
69618: LD_INT 2
69620: NEG
69621: PUSH
69622: EMPTY
69623: LIST
69624: LIST
69625: PUSH
69626: LD_INT 1
69628: PUSH
69629: LD_INT 1
69631: NEG
69632: PUSH
69633: EMPTY
69634: LIST
69635: LIST
69636: PUSH
69637: LD_INT 2
69639: PUSH
69640: LD_INT 0
69642: PUSH
69643: EMPTY
69644: LIST
69645: LIST
69646: PUSH
69647: LD_INT 2
69649: PUSH
69650: LD_INT 1
69652: PUSH
69653: EMPTY
69654: LIST
69655: LIST
69656: PUSH
69657: LD_INT 2
69659: PUSH
69660: LD_INT 2
69662: PUSH
69663: EMPTY
69664: LIST
69665: LIST
69666: PUSH
69667: LD_INT 1
69669: PUSH
69670: LD_INT 2
69672: PUSH
69673: EMPTY
69674: LIST
69675: LIST
69676: PUSH
69677: LD_INT 0
69679: PUSH
69680: LD_INT 2
69682: PUSH
69683: EMPTY
69684: LIST
69685: LIST
69686: PUSH
69687: LD_INT 1
69689: NEG
69690: PUSH
69691: LD_INT 1
69693: PUSH
69694: EMPTY
69695: LIST
69696: LIST
69697: PUSH
69698: LD_INT 2
69700: NEG
69701: PUSH
69702: LD_INT 0
69704: PUSH
69705: EMPTY
69706: LIST
69707: LIST
69708: PUSH
69709: LD_INT 2
69711: NEG
69712: PUSH
69713: LD_INT 1
69715: NEG
69716: PUSH
69717: EMPTY
69718: LIST
69719: LIST
69720: PUSH
69721: LD_INT 2
69723: NEG
69724: PUSH
69725: LD_INT 2
69727: NEG
69728: PUSH
69729: EMPTY
69730: LIST
69731: LIST
69732: PUSH
69733: EMPTY
69734: LIST
69735: LIST
69736: LIST
69737: LIST
69738: LIST
69739: LIST
69740: LIST
69741: LIST
69742: LIST
69743: LIST
69744: LIST
69745: LIST
69746: LIST
69747: LIST
69748: LIST
69749: LIST
69750: LIST
69751: LIST
69752: LIST
69753: ST_TO_ADDR
// fDepotAr2 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
69754: LD_ADDR_VAR 0 19
69758: PUSH
69759: LD_INT 0
69761: PUSH
69762: LD_INT 0
69764: PUSH
69765: EMPTY
69766: LIST
69767: LIST
69768: PUSH
69769: LD_INT 0
69771: PUSH
69772: LD_INT 1
69774: NEG
69775: PUSH
69776: EMPTY
69777: LIST
69778: LIST
69779: PUSH
69780: LD_INT 1
69782: PUSH
69783: LD_INT 0
69785: PUSH
69786: EMPTY
69787: LIST
69788: LIST
69789: PUSH
69790: LD_INT 1
69792: PUSH
69793: LD_INT 1
69795: PUSH
69796: EMPTY
69797: LIST
69798: LIST
69799: PUSH
69800: LD_INT 0
69802: PUSH
69803: LD_INT 1
69805: PUSH
69806: EMPTY
69807: LIST
69808: LIST
69809: PUSH
69810: LD_INT 1
69812: NEG
69813: PUSH
69814: LD_INT 0
69816: PUSH
69817: EMPTY
69818: LIST
69819: LIST
69820: PUSH
69821: LD_INT 1
69823: NEG
69824: PUSH
69825: LD_INT 1
69827: NEG
69828: PUSH
69829: EMPTY
69830: LIST
69831: LIST
69832: PUSH
69833: LD_INT 1
69835: NEG
69836: PUSH
69837: LD_INT 2
69839: NEG
69840: PUSH
69841: EMPTY
69842: LIST
69843: LIST
69844: PUSH
69845: LD_INT 0
69847: PUSH
69848: LD_INT 2
69850: NEG
69851: PUSH
69852: EMPTY
69853: LIST
69854: LIST
69855: PUSH
69856: LD_INT 1
69858: PUSH
69859: LD_INT 1
69861: NEG
69862: PUSH
69863: EMPTY
69864: LIST
69865: LIST
69866: PUSH
69867: LD_INT 2
69869: PUSH
69870: LD_INT 0
69872: PUSH
69873: EMPTY
69874: LIST
69875: LIST
69876: PUSH
69877: LD_INT 2
69879: PUSH
69880: LD_INT 1
69882: PUSH
69883: EMPTY
69884: LIST
69885: LIST
69886: PUSH
69887: LD_INT 2
69889: PUSH
69890: LD_INT 2
69892: PUSH
69893: EMPTY
69894: LIST
69895: LIST
69896: PUSH
69897: LD_INT 1
69899: PUSH
69900: LD_INT 2
69902: PUSH
69903: EMPTY
69904: LIST
69905: LIST
69906: PUSH
69907: LD_INT 0
69909: PUSH
69910: LD_INT 2
69912: PUSH
69913: EMPTY
69914: LIST
69915: LIST
69916: PUSH
69917: LD_INT 1
69919: NEG
69920: PUSH
69921: LD_INT 1
69923: PUSH
69924: EMPTY
69925: LIST
69926: LIST
69927: PUSH
69928: LD_INT 2
69930: NEG
69931: PUSH
69932: LD_INT 0
69934: PUSH
69935: EMPTY
69936: LIST
69937: LIST
69938: PUSH
69939: LD_INT 2
69941: NEG
69942: PUSH
69943: LD_INT 1
69945: NEG
69946: PUSH
69947: EMPTY
69948: LIST
69949: LIST
69950: PUSH
69951: LD_INT 2
69953: NEG
69954: PUSH
69955: LD_INT 2
69957: NEG
69958: PUSH
69959: EMPTY
69960: LIST
69961: LIST
69962: PUSH
69963: EMPTY
69964: LIST
69965: LIST
69966: LIST
69967: LIST
69968: LIST
69969: LIST
69970: LIST
69971: LIST
69972: LIST
69973: LIST
69974: LIST
69975: LIST
69976: LIST
69977: LIST
69978: LIST
69979: LIST
69980: LIST
69981: LIST
69982: LIST
69983: ST_TO_ADDR
// fDepotAr3 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
69984: LD_ADDR_VAR 0 20
69988: PUSH
69989: LD_INT 0
69991: PUSH
69992: LD_INT 0
69994: PUSH
69995: EMPTY
69996: LIST
69997: LIST
69998: PUSH
69999: LD_INT 0
70001: PUSH
70002: LD_INT 1
70004: NEG
70005: PUSH
70006: EMPTY
70007: LIST
70008: LIST
70009: PUSH
70010: LD_INT 1
70012: PUSH
70013: LD_INT 0
70015: PUSH
70016: EMPTY
70017: LIST
70018: LIST
70019: PUSH
70020: LD_INT 1
70022: PUSH
70023: LD_INT 1
70025: PUSH
70026: EMPTY
70027: LIST
70028: LIST
70029: PUSH
70030: LD_INT 0
70032: PUSH
70033: LD_INT 1
70035: PUSH
70036: EMPTY
70037: LIST
70038: LIST
70039: PUSH
70040: LD_INT 1
70042: NEG
70043: PUSH
70044: LD_INT 0
70046: PUSH
70047: EMPTY
70048: LIST
70049: LIST
70050: PUSH
70051: LD_INT 1
70053: NEG
70054: PUSH
70055: LD_INT 1
70057: NEG
70058: PUSH
70059: EMPTY
70060: LIST
70061: LIST
70062: PUSH
70063: LD_INT 1
70065: NEG
70066: PUSH
70067: LD_INT 2
70069: NEG
70070: PUSH
70071: EMPTY
70072: LIST
70073: LIST
70074: PUSH
70075: LD_INT 0
70077: PUSH
70078: LD_INT 2
70080: NEG
70081: PUSH
70082: EMPTY
70083: LIST
70084: LIST
70085: PUSH
70086: LD_INT 1
70088: PUSH
70089: LD_INT 1
70091: NEG
70092: PUSH
70093: EMPTY
70094: LIST
70095: LIST
70096: PUSH
70097: LD_INT 2
70099: PUSH
70100: LD_INT 0
70102: PUSH
70103: EMPTY
70104: LIST
70105: LIST
70106: PUSH
70107: LD_INT 2
70109: PUSH
70110: LD_INT 1
70112: PUSH
70113: EMPTY
70114: LIST
70115: LIST
70116: PUSH
70117: LD_INT 2
70119: PUSH
70120: LD_INT 2
70122: PUSH
70123: EMPTY
70124: LIST
70125: LIST
70126: PUSH
70127: LD_INT 1
70129: PUSH
70130: LD_INT 2
70132: PUSH
70133: EMPTY
70134: LIST
70135: LIST
70136: PUSH
70137: LD_INT 0
70139: PUSH
70140: LD_INT 2
70142: PUSH
70143: EMPTY
70144: LIST
70145: LIST
70146: PUSH
70147: LD_INT 1
70149: NEG
70150: PUSH
70151: LD_INT 1
70153: PUSH
70154: EMPTY
70155: LIST
70156: LIST
70157: PUSH
70158: LD_INT 2
70160: NEG
70161: PUSH
70162: LD_INT 0
70164: PUSH
70165: EMPTY
70166: LIST
70167: LIST
70168: PUSH
70169: LD_INT 2
70171: NEG
70172: PUSH
70173: LD_INT 1
70175: NEG
70176: PUSH
70177: EMPTY
70178: LIST
70179: LIST
70180: PUSH
70181: LD_INT 2
70183: NEG
70184: PUSH
70185: LD_INT 2
70187: NEG
70188: PUSH
70189: EMPTY
70190: LIST
70191: LIST
70192: PUSH
70193: EMPTY
70194: LIST
70195: LIST
70196: LIST
70197: LIST
70198: LIST
70199: LIST
70200: LIST
70201: LIST
70202: LIST
70203: LIST
70204: LIST
70205: LIST
70206: LIST
70207: LIST
70208: LIST
70209: LIST
70210: LIST
70211: LIST
70212: LIST
70213: ST_TO_ADDR
// fDepotAr4 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
70214: LD_ADDR_VAR 0 21
70218: PUSH
70219: LD_INT 0
70221: PUSH
70222: LD_INT 0
70224: PUSH
70225: EMPTY
70226: LIST
70227: LIST
70228: PUSH
70229: LD_INT 0
70231: PUSH
70232: LD_INT 1
70234: NEG
70235: PUSH
70236: EMPTY
70237: LIST
70238: LIST
70239: PUSH
70240: LD_INT 1
70242: PUSH
70243: LD_INT 0
70245: PUSH
70246: EMPTY
70247: LIST
70248: LIST
70249: PUSH
70250: LD_INT 1
70252: PUSH
70253: LD_INT 1
70255: PUSH
70256: EMPTY
70257: LIST
70258: LIST
70259: PUSH
70260: LD_INT 0
70262: PUSH
70263: LD_INT 1
70265: PUSH
70266: EMPTY
70267: LIST
70268: LIST
70269: PUSH
70270: LD_INT 1
70272: NEG
70273: PUSH
70274: LD_INT 0
70276: PUSH
70277: EMPTY
70278: LIST
70279: LIST
70280: PUSH
70281: LD_INT 1
70283: NEG
70284: PUSH
70285: LD_INT 1
70287: NEG
70288: PUSH
70289: EMPTY
70290: LIST
70291: LIST
70292: PUSH
70293: LD_INT 1
70295: NEG
70296: PUSH
70297: LD_INT 2
70299: NEG
70300: PUSH
70301: EMPTY
70302: LIST
70303: LIST
70304: PUSH
70305: LD_INT 0
70307: PUSH
70308: LD_INT 2
70310: NEG
70311: PUSH
70312: EMPTY
70313: LIST
70314: LIST
70315: PUSH
70316: LD_INT 1
70318: PUSH
70319: LD_INT 1
70321: NEG
70322: PUSH
70323: EMPTY
70324: LIST
70325: LIST
70326: PUSH
70327: LD_INT 2
70329: PUSH
70330: LD_INT 0
70332: PUSH
70333: EMPTY
70334: LIST
70335: LIST
70336: PUSH
70337: LD_INT 2
70339: PUSH
70340: LD_INT 1
70342: PUSH
70343: EMPTY
70344: LIST
70345: LIST
70346: PUSH
70347: LD_INT 2
70349: PUSH
70350: LD_INT 2
70352: PUSH
70353: EMPTY
70354: LIST
70355: LIST
70356: PUSH
70357: LD_INT 1
70359: PUSH
70360: LD_INT 2
70362: PUSH
70363: EMPTY
70364: LIST
70365: LIST
70366: PUSH
70367: LD_INT 0
70369: PUSH
70370: LD_INT 2
70372: PUSH
70373: EMPTY
70374: LIST
70375: LIST
70376: PUSH
70377: LD_INT 1
70379: NEG
70380: PUSH
70381: LD_INT 1
70383: PUSH
70384: EMPTY
70385: LIST
70386: LIST
70387: PUSH
70388: LD_INT 2
70390: NEG
70391: PUSH
70392: LD_INT 0
70394: PUSH
70395: EMPTY
70396: LIST
70397: LIST
70398: PUSH
70399: LD_INT 2
70401: NEG
70402: PUSH
70403: LD_INT 1
70405: NEG
70406: PUSH
70407: EMPTY
70408: LIST
70409: LIST
70410: PUSH
70411: LD_INT 2
70413: NEG
70414: PUSH
70415: LD_INT 2
70417: NEG
70418: PUSH
70419: EMPTY
70420: LIST
70421: LIST
70422: PUSH
70423: EMPTY
70424: LIST
70425: LIST
70426: LIST
70427: LIST
70428: LIST
70429: LIST
70430: LIST
70431: LIST
70432: LIST
70433: LIST
70434: LIST
70435: LIST
70436: LIST
70437: LIST
70438: LIST
70439: LIST
70440: LIST
70441: LIST
70442: LIST
70443: ST_TO_ADDR
// fDepotAr5 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
70444: LD_ADDR_VAR 0 22
70448: PUSH
70449: LD_INT 0
70451: PUSH
70452: LD_INT 0
70454: PUSH
70455: EMPTY
70456: LIST
70457: LIST
70458: PUSH
70459: LD_INT 0
70461: PUSH
70462: LD_INT 1
70464: NEG
70465: PUSH
70466: EMPTY
70467: LIST
70468: LIST
70469: PUSH
70470: LD_INT 1
70472: PUSH
70473: LD_INT 0
70475: PUSH
70476: EMPTY
70477: LIST
70478: LIST
70479: PUSH
70480: LD_INT 1
70482: PUSH
70483: LD_INT 1
70485: PUSH
70486: EMPTY
70487: LIST
70488: LIST
70489: PUSH
70490: LD_INT 0
70492: PUSH
70493: LD_INT 1
70495: PUSH
70496: EMPTY
70497: LIST
70498: LIST
70499: PUSH
70500: LD_INT 1
70502: NEG
70503: PUSH
70504: LD_INT 0
70506: PUSH
70507: EMPTY
70508: LIST
70509: LIST
70510: PUSH
70511: LD_INT 1
70513: NEG
70514: PUSH
70515: LD_INT 1
70517: NEG
70518: PUSH
70519: EMPTY
70520: LIST
70521: LIST
70522: PUSH
70523: LD_INT 1
70525: NEG
70526: PUSH
70527: LD_INT 2
70529: NEG
70530: PUSH
70531: EMPTY
70532: LIST
70533: LIST
70534: PUSH
70535: LD_INT 0
70537: PUSH
70538: LD_INT 2
70540: NEG
70541: PUSH
70542: EMPTY
70543: LIST
70544: LIST
70545: PUSH
70546: LD_INT 1
70548: PUSH
70549: LD_INT 1
70551: NEG
70552: PUSH
70553: EMPTY
70554: LIST
70555: LIST
70556: PUSH
70557: LD_INT 2
70559: PUSH
70560: LD_INT 0
70562: PUSH
70563: EMPTY
70564: LIST
70565: LIST
70566: PUSH
70567: LD_INT 2
70569: PUSH
70570: LD_INT 1
70572: PUSH
70573: EMPTY
70574: LIST
70575: LIST
70576: PUSH
70577: LD_INT 2
70579: PUSH
70580: LD_INT 2
70582: PUSH
70583: EMPTY
70584: LIST
70585: LIST
70586: PUSH
70587: LD_INT 1
70589: PUSH
70590: LD_INT 2
70592: PUSH
70593: EMPTY
70594: LIST
70595: LIST
70596: PUSH
70597: LD_INT 0
70599: PUSH
70600: LD_INT 2
70602: PUSH
70603: EMPTY
70604: LIST
70605: LIST
70606: PUSH
70607: LD_INT 1
70609: NEG
70610: PUSH
70611: LD_INT 1
70613: PUSH
70614: EMPTY
70615: LIST
70616: LIST
70617: PUSH
70618: LD_INT 2
70620: NEG
70621: PUSH
70622: LD_INT 0
70624: PUSH
70625: EMPTY
70626: LIST
70627: LIST
70628: PUSH
70629: LD_INT 2
70631: NEG
70632: PUSH
70633: LD_INT 1
70635: NEG
70636: PUSH
70637: EMPTY
70638: LIST
70639: LIST
70640: PUSH
70641: LD_INT 2
70643: NEG
70644: PUSH
70645: LD_INT 2
70647: NEG
70648: PUSH
70649: EMPTY
70650: LIST
70651: LIST
70652: PUSH
70653: EMPTY
70654: LIST
70655: LIST
70656: LIST
70657: LIST
70658: LIST
70659: LIST
70660: LIST
70661: LIST
70662: LIST
70663: LIST
70664: LIST
70665: LIST
70666: LIST
70667: LIST
70668: LIST
70669: LIST
70670: LIST
70671: LIST
70672: LIST
70673: ST_TO_ADDR
// fDepotRu0 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ - 2 , - 3 ] , [ - 1 , - 3 ] , [ 1 , - 2 ] , [ 2 , - 1 ] ] ;
70674: LD_ADDR_VAR 0 23
70678: PUSH
70679: LD_INT 0
70681: PUSH
70682: LD_INT 0
70684: PUSH
70685: EMPTY
70686: LIST
70687: LIST
70688: PUSH
70689: LD_INT 0
70691: PUSH
70692: LD_INT 1
70694: NEG
70695: PUSH
70696: EMPTY
70697: LIST
70698: LIST
70699: PUSH
70700: LD_INT 1
70702: PUSH
70703: LD_INT 0
70705: PUSH
70706: EMPTY
70707: LIST
70708: LIST
70709: PUSH
70710: LD_INT 1
70712: PUSH
70713: LD_INT 1
70715: PUSH
70716: EMPTY
70717: LIST
70718: LIST
70719: PUSH
70720: LD_INT 0
70722: PUSH
70723: LD_INT 1
70725: PUSH
70726: EMPTY
70727: LIST
70728: LIST
70729: PUSH
70730: LD_INT 1
70732: NEG
70733: PUSH
70734: LD_INT 0
70736: PUSH
70737: EMPTY
70738: LIST
70739: LIST
70740: PUSH
70741: LD_INT 1
70743: NEG
70744: PUSH
70745: LD_INT 1
70747: NEG
70748: PUSH
70749: EMPTY
70750: LIST
70751: LIST
70752: PUSH
70753: LD_INT 1
70755: NEG
70756: PUSH
70757: LD_INT 2
70759: NEG
70760: PUSH
70761: EMPTY
70762: LIST
70763: LIST
70764: PUSH
70765: LD_INT 0
70767: PUSH
70768: LD_INT 2
70770: NEG
70771: PUSH
70772: EMPTY
70773: LIST
70774: LIST
70775: PUSH
70776: LD_INT 1
70778: PUSH
70779: LD_INT 1
70781: NEG
70782: PUSH
70783: EMPTY
70784: LIST
70785: LIST
70786: PUSH
70787: LD_INT 2
70789: PUSH
70790: LD_INT 0
70792: PUSH
70793: EMPTY
70794: LIST
70795: LIST
70796: PUSH
70797: LD_INT 2
70799: PUSH
70800: LD_INT 1
70802: PUSH
70803: EMPTY
70804: LIST
70805: LIST
70806: PUSH
70807: LD_INT 2
70809: PUSH
70810: LD_INT 2
70812: PUSH
70813: EMPTY
70814: LIST
70815: LIST
70816: PUSH
70817: LD_INT 1
70819: PUSH
70820: LD_INT 2
70822: PUSH
70823: EMPTY
70824: LIST
70825: LIST
70826: PUSH
70827: LD_INT 0
70829: PUSH
70830: LD_INT 2
70832: PUSH
70833: EMPTY
70834: LIST
70835: LIST
70836: PUSH
70837: LD_INT 1
70839: NEG
70840: PUSH
70841: LD_INT 1
70843: PUSH
70844: EMPTY
70845: LIST
70846: LIST
70847: PUSH
70848: LD_INT 2
70850: NEG
70851: PUSH
70852: LD_INT 0
70854: PUSH
70855: EMPTY
70856: LIST
70857: LIST
70858: PUSH
70859: LD_INT 2
70861: NEG
70862: PUSH
70863: LD_INT 1
70865: NEG
70866: PUSH
70867: EMPTY
70868: LIST
70869: LIST
70870: PUSH
70871: LD_INT 2
70873: NEG
70874: PUSH
70875: LD_INT 2
70877: NEG
70878: PUSH
70879: EMPTY
70880: LIST
70881: LIST
70882: PUSH
70883: LD_INT 2
70885: NEG
70886: PUSH
70887: LD_INT 3
70889: NEG
70890: PUSH
70891: EMPTY
70892: LIST
70893: LIST
70894: PUSH
70895: LD_INT 1
70897: NEG
70898: PUSH
70899: LD_INT 3
70901: NEG
70902: PUSH
70903: EMPTY
70904: LIST
70905: LIST
70906: PUSH
70907: LD_INT 1
70909: PUSH
70910: LD_INT 2
70912: NEG
70913: PUSH
70914: EMPTY
70915: LIST
70916: LIST
70917: PUSH
70918: LD_INT 2
70920: PUSH
70921: LD_INT 1
70923: NEG
70924: PUSH
70925: EMPTY
70926: LIST
70927: LIST
70928: PUSH
70929: EMPTY
70930: LIST
70931: LIST
70932: LIST
70933: LIST
70934: LIST
70935: LIST
70936: LIST
70937: LIST
70938: LIST
70939: LIST
70940: LIST
70941: LIST
70942: LIST
70943: LIST
70944: LIST
70945: LIST
70946: LIST
70947: LIST
70948: LIST
70949: LIST
70950: LIST
70951: LIST
70952: LIST
70953: ST_TO_ADDR
// fDepotRu1 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ 1 , - 2 ] , [ 2 , - 1 ] , [ 3 , 1 ] , [ 3 , 2 ] ] ;
70954: LD_ADDR_VAR 0 24
70958: PUSH
70959: LD_INT 0
70961: PUSH
70962: LD_INT 0
70964: PUSH
70965: EMPTY
70966: LIST
70967: LIST
70968: PUSH
70969: LD_INT 0
70971: PUSH
70972: LD_INT 1
70974: NEG
70975: PUSH
70976: EMPTY
70977: LIST
70978: LIST
70979: PUSH
70980: LD_INT 1
70982: PUSH
70983: LD_INT 0
70985: PUSH
70986: EMPTY
70987: LIST
70988: LIST
70989: PUSH
70990: LD_INT 1
70992: PUSH
70993: LD_INT 1
70995: PUSH
70996: EMPTY
70997: LIST
70998: LIST
70999: PUSH
71000: LD_INT 0
71002: PUSH
71003: LD_INT 1
71005: PUSH
71006: EMPTY
71007: LIST
71008: LIST
71009: PUSH
71010: LD_INT 1
71012: NEG
71013: PUSH
71014: LD_INT 0
71016: PUSH
71017: EMPTY
71018: LIST
71019: LIST
71020: PUSH
71021: LD_INT 1
71023: NEG
71024: PUSH
71025: LD_INT 1
71027: NEG
71028: PUSH
71029: EMPTY
71030: LIST
71031: LIST
71032: PUSH
71033: LD_INT 1
71035: NEG
71036: PUSH
71037: LD_INT 2
71039: NEG
71040: PUSH
71041: EMPTY
71042: LIST
71043: LIST
71044: PUSH
71045: LD_INT 0
71047: PUSH
71048: LD_INT 2
71050: NEG
71051: PUSH
71052: EMPTY
71053: LIST
71054: LIST
71055: PUSH
71056: LD_INT 1
71058: PUSH
71059: LD_INT 1
71061: NEG
71062: PUSH
71063: EMPTY
71064: LIST
71065: LIST
71066: PUSH
71067: LD_INT 2
71069: PUSH
71070: LD_INT 0
71072: PUSH
71073: EMPTY
71074: LIST
71075: LIST
71076: PUSH
71077: LD_INT 2
71079: PUSH
71080: LD_INT 1
71082: PUSH
71083: EMPTY
71084: LIST
71085: LIST
71086: PUSH
71087: LD_INT 2
71089: PUSH
71090: LD_INT 2
71092: PUSH
71093: EMPTY
71094: LIST
71095: LIST
71096: PUSH
71097: LD_INT 1
71099: PUSH
71100: LD_INT 2
71102: PUSH
71103: EMPTY
71104: LIST
71105: LIST
71106: PUSH
71107: LD_INT 0
71109: PUSH
71110: LD_INT 2
71112: PUSH
71113: EMPTY
71114: LIST
71115: LIST
71116: PUSH
71117: LD_INT 1
71119: NEG
71120: PUSH
71121: LD_INT 1
71123: PUSH
71124: EMPTY
71125: LIST
71126: LIST
71127: PUSH
71128: LD_INT 2
71130: NEG
71131: PUSH
71132: LD_INT 0
71134: PUSH
71135: EMPTY
71136: LIST
71137: LIST
71138: PUSH
71139: LD_INT 2
71141: NEG
71142: PUSH
71143: LD_INT 1
71145: NEG
71146: PUSH
71147: EMPTY
71148: LIST
71149: LIST
71150: PUSH
71151: LD_INT 2
71153: NEG
71154: PUSH
71155: LD_INT 2
71157: NEG
71158: PUSH
71159: EMPTY
71160: LIST
71161: LIST
71162: PUSH
71163: LD_INT 1
71165: PUSH
71166: LD_INT 2
71168: NEG
71169: PUSH
71170: EMPTY
71171: LIST
71172: LIST
71173: PUSH
71174: LD_INT 2
71176: PUSH
71177: LD_INT 1
71179: NEG
71180: PUSH
71181: EMPTY
71182: LIST
71183: LIST
71184: PUSH
71185: LD_INT 3
71187: PUSH
71188: LD_INT 1
71190: PUSH
71191: EMPTY
71192: LIST
71193: LIST
71194: PUSH
71195: LD_INT 3
71197: PUSH
71198: LD_INT 2
71200: PUSH
71201: EMPTY
71202: LIST
71203: LIST
71204: PUSH
71205: EMPTY
71206: LIST
71207: LIST
71208: LIST
71209: LIST
71210: LIST
71211: LIST
71212: LIST
71213: LIST
71214: LIST
71215: LIST
71216: LIST
71217: LIST
71218: LIST
71219: LIST
71220: LIST
71221: LIST
71222: LIST
71223: LIST
71224: LIST
71225: LIST
71226: LIST
71227: LIST
71228: LIST
71229: ST_TO_ADDR
// fDepotRu2 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ 3 , 1 ] , [ 3 , 2 ] , [ 2 , 3 ] , [ 1 , 3 ] ] ;
71230: LD_ADDR_VAR 0 25
71234: PUSH
71235: LD_INT 0
71237: PUSH
71238: LD_INT 0
71240: PUSH
71241: EMPTY
71242: LIST
71243: LIST
71244: PUSH
71245: LD_INT 0
71247: PUSH
71248: LD_INT 1
71250: NEG
71251: PUSH
71252: EMPTY
71253: LIST
71254: LIST
71255: PUSH
71256: LD_INT 1
71258: PUSH
71259: LD_INT 0
71261: PUSH
71262: EMPTY
71263: LIST
71264: LIST
71265: PUSH
71266: LD_INT 1
71268: PUSH
71269: LD_INT 1
71271: PUSH
71272: EMPTY
71273: LIST
71274: LIST
71275: PUSH
71276: LD_INT 0
71278: PUSH
71279: LD_INT 1
71281: PUSH
71282: EMPTY
71283: LIST
71284: LIST
71285: PUSH
71286: LD_INT 1
71288: NEG
71289: PUSH
71290: LD_INT 0
71292: PUSH
71293: EMPTY
71294: LIST
71295: LIST
71296: PUSH
71297: LD_INT 1
71299: NEG
71300: PUSH
71301: LD_INT 1
71303: NEG
71304: PUSH
71305: EMPTY
71306: LIST
71307: LIST
71308: PUSH
71309: LD_INT 1
71311: NEG
71312: PUSH
71313: LD_INT 2
71315: NEG
71316: PUSH
71317: EMPTY
71318: LIST
71319: LIST
71320: PUSH
71321: LD_INT 0
71323: PUSH
71324: LD_INT 2
71326: NEG
71327: PUSH
71328: EMPTY
71329: LIST
71330: LIST
71331: PUSH
71332: LD_INT 1
71334: PUSH
71335: LD_INT 1
71337: NEG
71338: PUSH
71339: EMPTY
71340: LIST
71341: LIST
71342: PUSH
71343: LD_INT 2
71345: PUSH
71346: LD_INT 0
71348: PUSH
71349: EMPTY
71350: LIST
71351: LIST
71352: PUSH
71353: LD_INT 2
71355: PUSH
71356: LD_INT 1
71358: PUSH
71359: EMPTY
71360: LIST
71361: LIST
71362: PUSH
71363: LD_INT 2
71365: PUSH
71366: LD_INT 2
71368: PUSH
71369: EMPTY
71370: LIST
71371: LIST
71372: PUSH
71373: LD_INT 1
71375: PUSH
71376: LD_INT 2
71378: PUSH
71379: EMPTY
71380: LIST
71381: LIST
71382: PUSH
71383: LD_INT 0
71385: PUSH
71386: LD_INT 2
71388: PUSH
71389: EMPTY
71390: LIST
71391: LIST
71392: PUSH
71393: LD_INT 1
71395: NEG
71396: PUSH
71397: LD_INT 1
71399: PUSH
71400: EMPTY
71401: LIST
71402: LIST
71403: PUSH
71404: LD_INT 2
71406: NEG
71407: PUSH
71408: LD_INT 0
71410: PUSH
71411: EMPTY
71412: LIST
71413: LIST
71414: PUSH
71415: LD_INT 2
71417: NEG
71418: PUSH
71419: LD_INT 1
71421: NEG
71422: PUSH
71423: EMPTY
71424: LIST
71425: LIST
71426: PUSH
71427: LD_INT 2
71429: NEG
71430: PUSH
71431: LD_INT 2
71433: NEG
71434: PUSH
71435: EMPTY
71436: LIST
71437: LIST
71438: PUSH
71439: LD_INT 3
71441: PUSH
71442: LD_INT 1
71444: PUSH
71445: EMPTY
71446: LIST
71447: LIST
71448: PUSH
71449: LD_INT 3
71451: PUSH
71452: LD_INT 2
71454: PUSH
71455: EMPTY
71456: LIST
71457: LIST
71458: PUSH
71459: LD_INT 2
71461: PUSH
71462: LD_INT 3
71464: PUSH
71465: EMPTY
71466: LIST
71467: LIST
71468: PUSH
71469: LD_INT 1
71471: PUSH
71472: LD_INT 3
71474: PUSH
71475: EMPTY
71476: LIST
71477: LIST
71478: PUSH
71479: EMPTY
71480: LIST
71481: LIST
71482: LIST
71483: LIST
71484: LIST
71485: LIST
71486: LIST
71487: LIST
71488: LIST
71489: LIST
71490: LIST
71491: LIST
71492: LIST
71493: LIST
71494: LIST
71495: LIST
71496: LIST
71497: LIST
71498: LIST
71499: LIST
71500: LIST
71501: LIST
71502: LIST
71503: ST_TO_ADDR
// fDepotRu3 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ 2 , 3 ] , [ 1 , 3 ] , [ - 1 , 2 ] , [ - 2 , 1 ] ] ;
71504: LD_ADDR_VAR 0 26
71508: PUSH
71509: LD_INT 0
71511: PUSH
71512: LD_INT 0
71514: PUSH
71515: EMPTY
71516: LIST
71517: LIST
71518: PUSH
71519: LD_INT 0
71521: PUSH
71522: LD_INT 1
71524: NEG
71525: PUSH
71526: EMPTY
71527: LIST
71528: LIST
71529: PUSH
71530: LD_INT 1
71532: PUSH
71533: LD_INT 0
71535: PUSH
71536: EMPTY
71537: LIST
71538: LIST
71539: PUSH
71540: LD_INT 1
71542: PUSH
71543: LD_INT 1
71545: PUSH
71546: EMPTY
71547: LIST
71548: LIST
71549: PUSH
71550: LD_INT 0
71552: PUSH
71553: LD_INT 1
71555: PUSH
71556: EMPTY
71557: LIST
71558: LIST
71559: PUSH
71560: LD_INT 1
71562: NEG
71563: PUSH
71564: LD_INT 0
71566: PUSH
71567: EMPTY
71568: LIST
71569: LIST
71570: PUSH
71571: LD_INT 1
71573: NEG
71574: PUSH
71575: LD_INT 1
71577: NEG
71578: PUSH
71579: EMPTY
71580: LIST
71581: LIST
71582: PUSH
71583: LD_INT 1
71585: NEG
71586: PUSH
71587: LD_INT 2
71589: NEG
71590: PUSH
71591: EMPTY
71592: LIST
71593: LIST
71594: PUSH
71595: LD_INT 0
71597: PUSH
71598: LD_INT 2
71600: NEG
71601: PUSH
71602: EMPTY
71603: LIST
71604: LIST
71605: PUSH
71606: LD_INT 1
71608: PUSH
71609: LD_INT 1
71611: NEG
71612: PUSH
71613: EMPTY
71614: LIST
71615: LIST
71616: PUSH
71617: LD_INT 2
71619: PUSH
71620: LD_INT 0
71622: PUSH
71623: EMPTY
71624: LIST
71625: LIST
71626: PUSH
71627: LD_INT 2
71629: PUSH
71630: LD_INT 1
71632: PUSH
71633: EMPTY
71634: LIST
71635: LIST
71636: PUSH
71637: LD_INT 2
71639: PUSH
71640: LD_INT 2
71642: PUSH
71643: EMPTY
71644: LIST
71645: LIST
71646: PUSH
71647: LD_INT 1
71649: PUSH
71650: LD_INT 2
71652: PUSH
71653: EMPTY
71654: LIST
71655: LIST
71656: PUSH
71657: LD_INT 0
71659: PUSH
71660: LD_INT 2
71662: PUSH
71663: EMPTY
71664: LIST
71665: LIST
71666: PUSH
71667: LD_INT 1
71669: NEG
71670: PUSH
71671: LD_INT 1
71673: PUSH
71674: EMPTY
71675: LIST
71676: LIST
71677: PUSH
71678: LD_INT 2
71680: NEG
71681: PUSH
71682: LD_INT 0
71684: PUSH
71685: EMPTY
71686: LIST
71687: LIST
71688: PUSH
71689: LD_INT 2
71691: NEG
71692: PUSH
71693: LD_INT 1
71695: NEG
71696: PUSH
71697: EMPTY
71698: LIST
71699: LIST
71700: PUSH
71701: LD_INT 2
71703: NEG
71704: PUSH
71705: LD_INT 2
71707: NEG
71708: PUSH
71709: EMPTY
71710: LIST
71711: LIST
71712: PUSH
71713: LD_INT 2
71715: PUSH
71716: LD_INT 3
71718: PUSH
71719: EMPTY
71720: LIST
71721: LIST
71722: PUSH
71723: LD_INT 1
71725: PUSH
71726: LD_INT 3
71728: PUSH
71729: EMPTY
71730: LIST
71731: LIST
71732: PUSH
71733: LD_INT 1
71735: NEG
71736: PUSH
71737: LD_INT 2
71739: PUSH
71740: EMPTY
71741: LIST
71742: LIST
71743: PUSH
71744: LD_INT 2
71746: NEG
71747: PUSH
71748: LD_INT 1
71750: PUSH
71751: EMPTY
71752: LIST
71753: LIST
71754: PUSH
71755: EMPTY
71756: LIST
71757: LIST
71758: LIST
71759: LIST
71760: LIST
71761: LIST
71762: LIST
71763: LIST
71764: LIST
71765: LIST
71766: LIST
71767: LIST
71768: LIST
71769: LIST
71770: LIST
71771: LIST
71772: LIST
71773: LIST
71774: LIST
71775: LIST
71776: LIST
71777: LIST
71778: LIST
71779: ST_TO_ADDR
// fDepotRu4 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ - 1 , 2 ] , [ - 2 , 1 ] , [ - 3 , - 1 ] , [ - 3 , - 2 ] ] ;
71780: LD_ADDR_VAR 0 27
71784: PUSH
71785: LD_INT 0
71787: PUSH
71788: LD_INT 0
71790: PUSH
71791: EMPTY
71792: LIST
71793: LIST
71794: PUSH
71795: LD_INT 0
71797: PUSH
71798: LD_INT 1
71800: NEG
71801: PUSH
71802: EMPTY
71803: LIST
71804: LIST
71805: PUSH
71806: LD_INT 1
71808: PUSH
71809: LD_INT 0
71811: PUSH
71812: EMPTY
71813: LIST
71814: LIST
71815: PUSH
71816: LD_INT 1
71818: PUSH
71819: LD_INT 1
71821: PUSH
71822: EMPTY
71823: LIST
71824: LIST
71825: PUSH
71826: LD_INT 0
71828: PUSH
71829: LD_INT 1
71831: PUSH
71832: EMPTY
71833: LIST
71834: LIST
71835: PUSH
71836: LD_INT 1
71838: NEG
71839: PUSH
71840: LD_INT 0
71842: PUSH
71843: EMPTY
71844: LIST
71845: LIST
71846: PUSH
71847: LD_INT 1
71849: NEG
71850: PUSH
71851: LD_INT 1
71853: NEG
71854: PUSH
71855: EMPTY
71856: LIST
71857: LIST
71858: PUSH
71859: LD_INT 1
71861: NEG
71862: PUSH
71863: LD_INT 2
71865: NEG
71866: PUSH
71867: EMPTY
71868: LIST
71869: LIST
71870: PUSH
71871: LD_INT 0
71873: PUSH
71874: LD_INT 2
71876: NEG
71877: PUSH
71878: EMPTY
71879: LIST
71880: LIST
71881: PUSH
71882: LD_INT 1
71884: PUSH
71885: LD_INT 1
71887: NEG
71888: PUSH
71889: EMPTY
71890: LIST
71891: LIST
71892: PUSH
71893: LD_INT 2
71895: PUSH
71896: LD_INT 0
71898: PUSH
71899: EMPTY
71900: LIST
71901: LIST
71902: PUSH
71903: LD_INT 2
71905: PUSH
71906: LD_INT 1
71908: PUSH
71909: EMPTY
71910: LIST
71911: LIST
71912: PUSH
71913: LD_INT 2
71915: PUSH
71916: LD_INT 2
71918: PUSH
71919: EMPTY
71920: LIST
71921: LIST
71922: PUSH
71923: LD_INT 1
71925: PUSH
71926: LD_INT 2
71928: PUSH
71929: EMPTY
71930: LIST
71931: LIST
71932: PUSH
71933: LD_INT 0
71935: PUSH
71936: LD_INT 2
71938: PUSH
71939: EMPTY
71940: LIST
71941: LIST
71942: PUSH
71943: LD_INT 1
71945: NEG
71946: PUSH
71947: LD_INT 1
71949: PUSH
71950: EMPTY
71951: LIST
71952: LIST
71953: PUSH
71954: LD_INT 2
71956: NEG
71957: PUSH
71958: LD_INT 0
71960: PUSH
71961: EMPTY
71962: LIST
71963: LIST
71964: PUSH
71965: LD_INT 2
71967: NEG
71968: PUSH
71969: LD_INT 1
71971: NEG
71972: PUSH
71973: EMPTY
71974: LIST
71975: LIST
71976: PUSH
71977: LD_INT 2
71979: NEG
71980: PUSH
71981: LD_INT 2
71983: NEG
71984: PUSH
71985: EMPTY
71986: LIST
71987: LIST
71988: PUSH
71989: LD_INT 1
71991: NEG
71992: PUSH
71993: LD_INT 2
71995: PUSH
71996: EMPTY
71997: LIST
71998: LIST
71999: PUSH
72000: LD_INT 2
72002: NEG
72003: PUSH
72004: LD_INT 1
72006: PUSH
72007: EMPTY
72008: LIST
72009: LIST
72010: PUSH
72011: LD_INT 3
72013: NEG
72014: PUSH
72015: LD_INT 1
72017: NEG
72018: PUSH
72019: EMPTY
72020: LIST
72021: LIST
72022: PUSH
72023: LD_INT 3
72025: NEG
72026: PUSH
72027: LD_INT 2
72029: NEG
72030: PUSH
72031: EMPTY
72032: LIST
72033: LIST
72034: PUSH
72035: EMPTY
72036: LIST
72037: LIST
72038: LIST
72039: LIST
72040: LIST
72041: LIST
72042: LIST
72043: LIST
72044: LIST
72045: LIST
72046: LIST
72047: LIST
72048: LIST
72049: LIST
72050: LIST
72051: LIST
72052: LIST
72053: LIST
72054: LIST
72055: LIST
72056: LIST
72057: LIST
72058: LIST
72059: ST_TO_ADDR
// fDepotRu5 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ - 2 , - 3 ] , [ - 1 , - 3 ] , [ - 3 , - 1 ] , [ - 3 , - 2 ] ] ;
72060: LD_ADDR_VAR 0 28
72064: PUSH
72065: LD_INT 0
72067: PUSH
72068: LD_INT 0
72070: PUSH
72071: EMPTY
72072: LIST
72073: LIST
72074: PUSH
72075: LD_INT 0
72077: PUSH
72078: LD_INT 1
72080: NEG
72081: PUSH
72082: EMPTY
72083: LIST
72084: LIST
72085: PUSH
72086: LD_INT 1
72088: PUSH
72089: LD_INT 0
72091: PUSH
72092: EMPTY
72093: LIST
72094: LIST
72095: PUSH
72096: LD_INT 1
72098: PUSH
72099: LD_INT 1
72101: PUSH
72102: EMPTY
72103: LIST
72104: LIST
72105: PUSH
72106: LD_INT 0
72108: PUSH
72109: LD_INT 1
72111: PUSH
72112: EMPTY
72113: LIST
72114: LIST
72115: PUSH
72116: LD_INT 1
72118: NEG
72119: PUSH
72120: LD_INT 0
72122: PUSH
72123: EMPTY
72124: LIST
72125: LIST
72126: PUSH
72127: LD_INT 1
72129: NEG
72130: PUSH
72131: LD_INT 1
72133: NEG
72134: PUSH
72135: EMPTY
72136: LIST
72137: LIST
72138: PUSH
72139: LD_INT 1
72141: NEG
72142: PUSH
72143: LD_INT 2
72145: NEG
72146: PUSH
72147: EMPTY
72148: LIST
72149: LIST
72150: PUSH
72151: LD_INT 0
72153: PUSH
72154: LD_INT 2
72156: NEG
72157: PUSH
72158: EMPTY
72159: LIST
72160: LIST
72161: PUSH
72162: LD_INT 1
72164: PUSH
72165: LD_INT 1
72167: NEG
72168: PUSH
72169: EMPTY
72170: LIST
72171: LIST
72172: PUSH
72173: LD_INT 2
72175: PUSH
72176: LD_INT 0
72178: PUSH
72179: EMPTY
72180: LIST
72181: LIST
72182: PUSH
72183: LD_INT 2
72185: PUSH
72186: LD_INT 1
72188: PUSH
72189: EMPTY
72190: LIST
72191: LIST
72192: PUSH
72193: LD_INT 2
72195: PUSH
72196: LD_INT 2
72198: PUSH
72199: EMPTY
72200: LIST
72201: LIST
72202: PUSH
72203: LD_INT 1
72205: PUSH
72206: LD_INT 2
72208: PUSH
72209: EMPTY
72210: LIST
72211: LIST
72212: PUSH
72213: LD_INT 0
72215: PUSH
72216: LD_INT 2
72218: PUSH
72219: EMPTY
72220: LIST
72221: LIST
72222: PUSH
72223: LD_INT 1
72225: NEG
72226: PUSH
72227: LD_INT 1
72229: PUSH
72230: EMPTY
72231: LIST
72232: LIST
72233: PUSH
72234: LD_INT 2
72236: NEG
72237: PUSH
72238: LD_INT 0
72240: PUSH
72241: EMPTY
72242: LIST
72243: LIST
72244: PUSH
72245: LD_INT 2
72247: NEG
72248: PUSH
72249: LD_INT 1
72251: NEG
72252: PUSH
72253: EMPTY
72254: LIST
72255: LIST
72256: PUSH
72257: LD_INT 2
72259: NEG
72260: PUSH
72261: LD_INT 2
72263: NEG
72264: PUSH
72265: EMPTY
72266: LIST
72267: LIST
72268: PUSH
72269: LD_INT 2
72271: NEG
72272: PUSH
72273: LD_INT 3
72275: NEG
72276: PUSH
72277: EMPTY
72278: LIST
72279: LIST
72280: PUSH
72281: LD_INT 1
72283: NEG
72284: PUSH
72285: LD_INT 3
72287: NEG
72288: PUSH
72289: EMPTY
72290: LIST
72291: LIST
72292: PUSH
72293: LD_INT 3
72295: NEG
72296: PUSH
72297: LD_INT 1
72299: NEG
72300: PUSH
72301: EMPTY
72302: LIST
72303: LIST
72304: PUSH
72305: LD_INT 3
72307: NEG
72308: PUSH
72309: LD_INT 2
72311: NEG
72312: PUSH
72313: EMPTY
72314: LIST
72315: LIST
72316: PUSH
72317: EMPTY
72318: LIST
72319: LIST
72320: LIST
72321: LIST
72322: LIST
72323: LIST
72324: LIST
72325: LIST
72326: LIST
72327: LIST
72328: LIST
72329: LIST
72330: LIST
72331: LIST
72332: LIST
72333: LIST
72334: LIST
72335: LIST
72336: LIST
72337: LIST
72338: LIST
72339: LIST
72340: LIST
72341: ST_TO_ADDR
// fFactory0 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ - 2 , - 3 ] , [ 2 , - 1 ] , [ 3 , 1 ] , [ 1 , 3 ] , [ - 1 , 2 ] , [ - 3 , - 2 ] ] ;
72342: LD_ADDR_VAR 0 29
72346: PUSH
72347: LD_INT 0
72349: PUSH
72350: LD_INT 0
72352: PUSH
72353: EMPTY
72354: LIST
72355: LIST
72356: PUSH
72357: LD_INT 0
72359: PUSH
72360: LD_INT 1
72362: NEG
72363: PUSH
72364: EMPTY
72365: LIST
72366: LIST
72367: PUSH
72368: LD_INT 1
72370: PUSH
72371: LD_INT 0
72373: PUSH
72374: EMPTY
72375: LIST
72376: LIST
72377: PUSH
72378: LD_INT 1
72380: PUSH
72381: LD_INT 1
72383: PUSH
72384: EMPTY
72385: LIST
72386: LIST
72387: PUSH
72388: LD_INT 0
72390: PUSH
72391: LD_INT 1
72393: PUSH
72394: EMPTY
72395: LIST
72396: LIST
72397: PUSH
72398: LD_INT 1
72400: NEG
72401: PUSH
72402: LD_INT 0
72404: PUSH
72405: EMPTY
72406: LIST
72407: LIST
72408: PUSH
72409: LD_INT 1
72411: NEG
72412: PUSH
72413: LD_INT 1
72415: NEG
72416: PUSH
72417: EMPTY
72418: LIST
72419: LIST
72420: PUSH
72421: LD_INT 1
72423: NEG
72424: PUSH
72425: LD_INT 2
72427: NEG
72428: PUSH
72429: EMPTY
72430: LIST
72431: LIST
72432: PUSH
72433: LD_INT 0
72435: PUSH
72436: LD_INT 2
72438: NEG
72439: PUSH
72440: EMPTY
72441: LIST
72442: LIST
72443: PUSH
72444: LD_INT 1
72446: PUSH
72447: LD_INT 1
72449: NEG
72450: PUSH
72451: EMPTY
72452: LIST
72453: LIST
72454: PUSH
72455: LD_INT 2
72457: PUSH
72458: LD_INT 0
72460: PUSH
72461: EMPTY
72462: LIST
72463: LIST
72464: PUSH
72465: LD_INT 2
72467: PUSH
72468: LD_INT 1
72470: PUSH
72471: EMPTY
72472: LIST
72473: LIST
72474: PUSH
72475: LD_INT 1
72477: PUSH
72478: LD_INT 2
72480: PUSH
72481: EMPTY
72482: LIST
72483: LIST
72484: PUSH
72485: LD_INT 0
72487: PUSH
72488: LD_INT 2
72490: PUSH
72491: EMPTY
72492: LIST
72493: LIST
72494: PUSH
72495: LD_INT 1
72497: NEG
72498: PUSH
72499: LD_INT 1
72501: PUSH
72502: EMPTY
72503: LIST
72504: LIST
72505: PUSH
72506: LD_INT 2
72508: NEG
72509: PUSH
72510: LD_INT 1
72512: NEG
72513: PUSH
72514: EMPTY
72515: LIST
72516: LIST
72517: PUSH
72518: LD_INT 2
72520: NEG
72521: PUSH
72522: LD_INT 2
72524: NEG
72525: PUSH
72526: EMPTY
72527: LIST
72528: LIST
72529: PUSH
72530: LD_INT 2
72532: NEG
72533: PUSH
72534: LD_INT 3
72536: NEG
72537: PUSH
72538: EMPTY
72539: LIST
72540: LIST
72541: PUSH
72542: LD_INT 2
72544: PUSH
72545: LD_INT 1
72547: NEG
72548: PUSH
72549: EMPTY
72550: LIST
72551: LIST
72552: PUSH
72553: LD_INT 3
72555: PUSH
72556: LD_INT 1
72558: PUSH
72559: EMPTY
72560: LIST
72561: LIST
72562: PUSH
72563: LD_INT 1
72565: PUSH
72566: LD_INT 3
72568: PUSH
72569: EMPTY
72570: LIST
72571: LIST
72572: PUSH
72573: LD_INT 1
72575: NEG
72576: PUSH
72577: LD_INT 2
72579: PUSH
72580: EMPTY
72581: LIST
72582: LIST
72583: PUSH
72584: LD_INT 3
72586: NEG
72587: PUSH
72588: LD_INT 2
72590: NEG
72591: PUSH
72592: EMPTY
72593: LIST
72594: LIST
72595: PUSH
72596: EMPTY
72597: LIST
72598: LIST
72599: LIST
72600: LIST
72601: LIST
72602: LIST
72603: LIST
72604: LIST
72605: LIST
72606: LIST
72607: LIST
72608: LIST
72609: LIST
72610: LIST
72611: LIST
72612: LIST
72613: LIST
72614: LIST
72615: LIST
72616: LIST
72617: LIST
72618: LIST
72619: LIST
72620: ST_TO_ADDR
// fFactory1 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 1 , - 3 ] , [ 1 , - 2 ] , [ 3 , 2 ] , [ 2 , 3 ] , [ - 2 , 1 ] , [ - 3 , - 1 ] ] ;
72621: LD_ADDR_VAR 0 30
72625: PUSH
72626: LD_INT 0
72628: PUSH
72629: LD_INT 0
72631: PUSH
72632: EMPTY
72633: LIST
72634: LIST
72635: PUSH
72636: LD_INT 0
72638: PUSH
72639: LD_INT 1
72641: NEG
72642: PUSH
72643: EMPTY
72644: LIST
72645: LIST
72646: PUSH
72647: LD_INT 1
72649: PUSH
72650: LD_INT 0
72652: PUSH
72653: EMPTY
72654: LIST
72655: LIST
72656: PUSH
72657: LD_INT 1
72659: PUSH
72660: LD_INT 1
72662: PUSH
72663: EMPTY
72664: LIST
72665: LIST
72666: PUSH
72667: LD_INT 0
72669: PUSH
72670: LD_INT 1
72672: PUSH
72673: EMPTY
72674: LIST
72675: LIST
72676: PUSH
72677: LD_INT 1
72679: NEG
72680: PUSH
72681: LD_INT 0
72683: PUSH
72684: EMPTY
72685: LIST
72686: LIST
72687: PUSH
72688: LD_INT 1
72690: NEG
72691: PUSH
72692: LD_INT 1
72694: NEG
72695: PUSH
72696: EMPTY
72697: LIST
72698: LIST
72699: PUSH
72700: LD_INT 1
72702: NEG
72703: PUSH
72704: LD_INT 2
72706: NEG
72707: PUSH
72708: EMPTY
72709: LIST
72710: LIST
72711: PUSH
72712: LD_INT 0
72714: PUSH
72715: LD_INT 2
72717: NEG
72718: PUSH
72719: EMPTY
72720: LIST
72721: LIST
72722: PUSH
72723: LD_INT 1
72725: PUSH
72726: LD_INT 1
72728: NEG
72729: PUSH
72730: EMPTY
72731: LIST
72732: LIST
72733: PUSH
72734: LD_INT 2
72736: PUSH
72737: LD_INT 0
72739: PUSH
72740: EMPTY
72741: LIST
72742: LIST
72743: PUSH
72744: LD_INT 2
72746: PUSH
72747: LD_INT 1
72749: PUSH
72750: EMPTY
72751: LIST
72752: LIST
72753: PUSH
72754: LD_INT 2
72756: PUSH
72757: LD_INT 2
72759: PUSH
72760: EMPTY
72761: LIST
72762: LIST
72763: PUSH
72764: LD_INT 1
72766: PUSH
72767: LD_INT 2
72769: PUSH
72770: EMPTY
72771: LIST
72772: LIST
72773: PUSH
72774: LD_INT 1
72776: NEG
72777: PUSH
72778: LD_INT 1
72780: PUSH
72781: EMPTY
72782: LIST
72783: LIST
72784: PUSH
72785: LD_INT 2
72787: NEG
72788: PUSH
72789: LD_INT 0
72791: PUSH
72792: EMPTY
72793: LIST
72794: LIST
72795: PUSH
72796: LD_INT 2
72798: NEG
72799: PUSH
72800: LD_INT 1
72802: NEG
72803: PUSH
72804: EMPTY
72805: LIST
72806: LIST
72807: PUSH
72808: LD_INT 1
72810: NEG
72811: PUSH
72812: LD_INT 3
72814: NEG
72815: PUSH
72816: EMPTY
72817: LIST
72818: LIST
72819: PUSH
72820: LD_INT 1
72822: PUSH
72823: LD_INT 2
72825: NEG
72826: PUSH
72827: EMPTY
72828: LIST
72829: LIST
72830: PUSH
72831: LD_INT 3
72833: PUSH
72834: LD_INT 2
72836: PUSH
72837: EMPTY
72838: LIST
72839: LIST
72840: PUSH
72841: LD_INT 2
72843: PUSH
72844: LD_INT 3
72846: PUSH
72847: EMPTY
72848: LIST
72849: LIST
72850: PUSH
72851: LD_INT 2
72853: NEG
72854: PUSH
72855: LD_INT 1
72857: PUSH
72858: EMPTY
72859: LIST
72860: LIST
72861: PUSH
72862: LD_INT 3
72864: NEG
72865: PUSH
72866: LD_INT 1
72868: NEG
72869: PUSH
72870: EMPTY
72871: LIST
72872: LIST
72873: PUSH
72874: EMPTY
72875: LIST
72876: LIST
72877: LIST
72878: LIST
72879: LIST
72880: LIST
72881: LIST
72882: LIST
72883: LIST
72884: LIST
72885: LIST
72886: LIST
72887: LIST
72888: LIST
72889: LIST
72890: LIST
72891: LIST
72892: LIST
72893: LIST
72894: LIST
72895: LIST
72896: LIST
72897: LIST
72898: ST_TO_ADDR
// fFactory2 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ - 2 , - 3 ] , [ 2 , - 1 ] , [ 3 , 1 ] , [ 1 , 3 ] , [ - 1 , 2 ] , [ - 3 , - 2 ] ] ;
72899: LD_ADDR_VAR 0 31
72903: PUSH
72904: LD_INT 0
72906: PUSH
72907: LD_INT 0
72909: PUSH
72910: EMPTY
72911: LIST
72912: LIST
72913: PUSH
72914: LD_INT 0
72916: PUSH
72917: LD_INT 1
72919: NEG
72920: PUSH
72921: EMPTY
72922: LIST
72923: LIST
72924: PUSH
72925: LD_INT 1
72927: PUSH
72928: LD_INT 0
72930: PUSH
72931: EMPTY
72932: LIST
72933: LIST
72934: PUSH
72935: LD_INT 1
72937: PUSH
72938: LD_INT 1
72940: PUSH
72941: EMPTY
72942: LIST
72943: LIST
72944: PUSH
72945: LD_INT 0
72947: PUSH
72948: LD_INT 1
72950: PUSH
72951: EMPTY
72952: LIST
72953: LIST
72954: PUSH
72955: LD_INT 1
72957: NEG
72958: PUSH
72959: LD_INT 0
72961: PUSH
72962: EMPTY
72963: LIST
72964: LIST
72965: PUSH
72966: LD_INT 1
72968: NEG
72969: PUSH
72970: LD_INT 1
72972: NEG
72973: PUSH
72974: EMPTY
72975: LIST
72976: LIST
72977: PUSH
72978: LD_INT 1
72980: NEG
72981: PUSH
72982: LD_INT 2
72984: NEG
72985: PUSH
72986: EMPTY
72987: LIST
72988: LIST
72989: PUSH
72990: LD_INT 1
72992: PUSH
72993: LD_INT 1
72995: NEG
72996: PUSH
72997: EMPTY
72998: LIST
72999: LIST
73000: PUSH
73001: LD_INT 2
73003: PUSH
73004: LD_INT 0
73006: PUSH
73007: EMPTY
73008: LIST
73009: LIST
73010: PUSH
73011: LD_INT 2
73013: PUSH
73014: LD_INT 1
73016: PUSH
73017: EMPTY
73018: LIST
73019: LIST
73020: PUSH
73021: LD_INT 2
73023: PUSH
73024: LD_INT 2
73026: PUSH
73027: EMPTY
73028: LIST
73029: LIST
73030: PUSH
73031: LD_INT 1
73033: PUSH
73034: LD_INT 2
73036: PUSH
73037: EMPTY
73038: LIST
73039: LIST
73040: PUSH
73041: LD_INT 0
73043: PUSH
73044: LD_INT 2
73046: PUSH
73047: EMPTY
73048: LIST
73049: LIST
73050: PUSH
73051: LD_INT 1
73053: NEG
73054: PUSH
73055: LD_INT 1
73057: PUSH
73058: EMPTY
73059: LIST
73060: LIST
73061: PUSH
73062: LD_INT 2
73064: NEG
73065: PUSH
73066: LD_INT 1
73068: NEG
73069: PUSH
73070: EMPTY
73071: LIST
73072: LIST
73073: PUSH
73074: LD_INT 2
73076: NEG
73077: PUSH
73078: LD_INT 2
73080: NEG
73081: PUSH
73082: EMPTY
73083: LIST
73084: LIST
73085: PUSH
73086: LD_INT 2
73088: NEG
73089: PUSH
73090: LD_INT 3
73092: NEG
73093: PUSH
73094: EMPTY
73095: LIST
73096: LIST
73097: PUSH
73098: LD_INT 2
73100: PUSH
73101: LD_INT 1
73103: NEG
73104: PUSH
73105: EMPTY
73106: LIST
73107: LIST
73108: PUSH
73109: LD_INT 3
73111: PUSH
73112: LD_INT 1
73114: PUSH
73115: EMPTY
73116: LIST
73117: LIST
73118: PUSH
73119: LD_INT 1
73121: PUSH
73122: LD_INT 3
73124: PUSH
73125: EMPTY
73126: LIST
73127: LIST
73128: PUSH
73129: LD_INT 1
73131: NEG
73132: PUSH
73133: LD_INT 2
73135: PUSH
73136: EMPTY
73137: LIST
73138: LIST
73139: PUSH
73140: LD_INT 3
73142: NEG
73143: PUSH
73144: LD_INT 2
73146: NEG
73147: PUSH
73148: EMPTY
73149: LIST
73150: LIST
73151: PUSH
73152: EMPTY
73153: LIST
73154: LIST
73155: LIST
73156: LIST
73157: LIST
73158: LIST
73159: LIST
73160: LIST
73161: LIST
73162: LIST
73163: LIST
73164: LIST
73165: LIST
73166: LIST
73167: LIST
73168: LIST
73169: LIST
73170: LIST
73171: LIST
73172: LIST
73173: LIST
73174: LIST
73175: LIST
73176: ST_TO_ADDR
// fFactory3 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 1 , - 3 ] , [ 1 , - 2 ] , [ 3 , 2 ] , [ 2 , 3 ] , [ - 2 , 1 ] , [ - 3 , - 1 ] ] ;
73177: LD_ADDR_VAR 0 32
73181: PUSH
73182: LD_INT 0
73184: PUSH
73185: LD_INT 0
73187: PUSH
73188: EMPTY
73189: LIST
73190: LIST
73191: PUSH
73192: LD_INT 0
73194: PUSH
73195: LD_INT 1
73197: NEG
73198: PUSH
73199: EMPTY
73200: LIST
73201: LIST
73202: PUSH
73203: LD_INT 1
73205: PUSH
73206: LD_INT 0
73208: PUSH
73209: EMPTY
73210: LIST
73211: LIST
73212: PUSH
73213: LD_INT 1
73215: PUSH
73216: LD_INT 1
73218: PUSH
73219: EMPTY
73220: LIST
73221: LIST
73222: PUSH
73223: LD_INT 0
73225: PUSH
73226: LD_INT 1
73228: PUSH
73229: EMPTY
73230: LIST
73231: LIST
73232: PUSH
73233: LD_INT 1
73235: NEG
73236: PUSH
73237: LD_INT 0
73239: PUSH
73240: EMPTY
73241: LIST
73242: LIST
73243: PUSH
73244: LD_INT 1
73246: NEG
73247: PUSH
73248: LD_INT 1
73250: NEG
73251: PUSH
73252: EMPTY
73253: LIST
73254: LIST
73255: PUSH
73256: LD_INT 1
73258: NEG
73259: PUSH
73260: LD_INT 2
73262: NEG
73263: PUSH
73264: EMPTY
73265: LIST
73266: LIST
73267: PUSH
73268: LD_INT 0
73270: PUSH
73271: LD_INT 2
73273: NEG
73274: PUSH
73275: EMPTY
73276: LIST
73277: LIST
73278: PUSH
73279: LD_INT 1
73281: PUSH
73282: LD_INT 1
73284: NEG
73285: PUSH
73286: EMPTY
73287: LIST
73288: LIST
73289: PUSH
73290: LD_INT 2
73292: PUSH
73293: LD_INT 1
73295: PUSH
73296: EMPTY
73297: LIST
73298: LIST
73299: PUSH
73300: LD_INT 2
73302: PUSH
73303: LD_INT 2
73305: PUSH
73306: EMPTY
73307: LIST
73308: LIST
73309: PUSH
73310: LD_INT 1
73312: PUSH
73313: LD_INT 2
73315: PUSH
73316: EMPTY
73317: LIST
73318: LIST
73319: PUSH
73320: LD_INT 0
73322: PUSH
73323: LD_INT 2
73325: PUSH
73326: EMPTY
73327: LIST
73328: LIST
73329: PUSH
73330: LD_INT 1
73332: NEG
73333: PUSH
73334: LD_INT 1
73336: PUSH
73337: EMPTY
73338: LIST
73339: LIST
73340: PUSH
73341: LD_INT 2
73343: NEG
73344: PUSH
73345: LD_INT 0
73347: PUSH
73348: EMPTY
73349: LIST
73350: LIST
73351: PUSH
73352: LD_INT 2
73354: NEG
73355: PUSH
73356: LD_INT 1
73358: NEG
73359: PUSH
73360: EMPTY
73361: LIST
73362: LIST
73363: PUSH
73364: LD_INT 1
73366: NEG
73367: PUSH
73368: LD_INT 3
73370: NEG
73371: PUSH
73372: EMPTY
73373: LIST
73374: LIST
73375: PUSH
73376: LD_INT 1
73378: PUSH
73379: LD_INT 2
73381: NEG
73382: PUSH
73383: EMPTY
73384: LIST
73385: LIST
73386: PUSH
73387: LD_INT 3
73389: PUSH
73390: LD_INT 2
73392: PUSH
73393: EMPTY
73394: LIST
73395: LIST
73396: PUSH
73397: LD_INT 2
73399: PUSH
73400: LD_INT 3
73402: PUSH
73403: EMPTY
73404: LIST
73405: LIST
73406: PUSH
73407: LD_INT 2
73409: NEG
73410: PUSH
73411: LD_INT 1
73413: PUSH
73414: EMPTY
73415: LIST
73416: LIST
73417: PUSH
73418: LD_INT 3
73420: NEG
73421: PUSH
73422: LD_INT 1
73424: NEG
73425: PUSH
73426: EMPTY
73427: LIST
73428: LIST
73429: PUSH
73430: EMPTY
73431: LIST
73432: LIST
73433: LIST
73434: LIST
73435: LIST
73436: LIST
73437: LIST
73438: LIST
73439: LIST
73440: LIST
73441: LIST
73442: LIST
73443: LIST
73444: LIST
73445: LIST
73446: LIST
73447: LIST
73448: LIST
73449: LIST
73450: LIST
73451: LIST
73452: LIST
73453: LIST
73454: ST_TO_ADDR
// fFactory4 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ - 2 , - 3 ] , [ 2 , - 1 ] , [ 3 , 1 ] , [ 1 , 3 ] , [ - 1 , 2 ] , [ - 3 , - 2 ] ] ;
73455: LD_ADDR_VAR 0 33
73459: PUSH
73460: LD_INT 0
73462: PUSH
73463: LD_INT 0
73465: PUSH
73466: EMPTY
73467: LIST
73468: LIST
73469: PUSH
73470: LD_INT 0
73472: PUSH
73473: LD_INT 1
73475: NEG
73476: PUSH
73477: EMPTY
73478: LIST
73479: LIST
73480: PUSH
73481: LD_INT 1
73483: PUSH
73484: LD_INT 0
73486: PUSH
73487: EMPTY
73488: LIST
73489: LIST
73490: PUSH
73491: LD_INT 1
73493: PUSH
73494: LD_INT 1
73496: PUSH
73497: EMPTY
73498: LIST
73499: LIST
73500: PUSH
73501: LD_INT 0
73503: PUSH
73504: LD_INT 1
73506: PUSH
73507: EMPTY
73508: LIST
73509: LIST
73510: PUSH
73511: LD_INT 1
73513: NEG
73514: PUSH
73515: LD_INT 0
73517: PUSH
73518: EMPTY
73519: LIST
73520: LIST
73521: PUSH
73522: LD_INT 1
73524: NEG
73525: PUSH
73526: LD_INT 1
73528: NEG
73529: PUSH
73530: EMPTY
73531: LIST
73532: LIST
73533: PUSH
73534: LD_INT 1
73536: NEG
73537: PUSH
73538: LD_INT 2
73540: NEG
73541: PUSH
73542: EMPTY
73543: LIST
73544: LIST
73545: PUSH
73546: LD_INT 1
73548: PUSH
73549: LD_INT 1
73551: NEG
73552: PUSH
73553: EMPTY
73554: LIST
73555: LIST
73556: PUSH
73557: LD_INT 2
73559: PUSH
73560: LD_INT 0
73562: PUSH
73563: EMPTY
73564: LIST
73565: LIST
73566: PUSH
73567: LD_INT 2
73569: PUSH
73570: LD_INT 1
73572: PUSH
73573: EMPTY
73574: LIST
73575: LIST
73576: PUSH
73577: LD_INT 1
73579: PUSH
73580: LD_INT 2
73582: PUSH
73583: EMPTY
73584: LIST
73585: LIST
73586: PUSH
73587: LD_INT 0
73589: PUSH
73590: LD_INT 2
73592: PUSH
73593: EMPTY
73594: LIST
73595: LIST
73596: PUSH
73597: LD_INT 1
73599: NEG
73600: PUSH
73601: LD_INT 1
73603: PUSH
73604: EMPTY
73605: LIST
73606: LIST
73607: PUSH
73608: LD_INT 2
73610: NEG
73611: PUSH
73612: LD_INT 0
73614: PUSH
73615: EMPTY
73616: LIST
73617: LIST
73618: PUSH
73619: LD_INT 2
73621: NEG
73622: PUSH
73623: LD_INT 1
73625: NEG
73626: PUSH
73627: EMPTY
73628: LIST
73629: LIST
73630: PUSH
73631: LD_INT 2
73633: NEG
73634: PUSH
73635: LD_INT 2
73637: NEG
73638: PUSH
73639: EMPTY
73640: LIST
73641: LIST
73642: PUSH
73643: LD_INT 2
73645: NEG
73646: PUSH
73647: LD_INT 3
73649: NEG
73650: PUSH
73651: EMPTY
73652: LIST
73653: LIST
73654: PUSH
73655: LD_INT 2
73657: PUSH
73658: LD_INT 1
73660: NEG
73661: PUSH
73662: EMPTY
73663: LIST
73664: LIST
73665: PUSH
73666: LD_INT 3
73668: PUSH
73669: LD_INT 1
73671: PUSH
73672: EMPTY
73673: LIST
73674: LIST
73675: PUSH
73676: LD_INT 1
73678: PUSH
73679: LD_INT 3
73681: PUSH
73682: EMPTY
73683: LIST
73684: LIST
73685: PUSH
73686: LD_INT 1
73688: NEG
73689: PUSH
73690: LD_INT 2
73692: PUSH
73693: EMPTY
73694: LIST
73695: LIST
73696: PUSH
73697: LD_INT 3
73699: NEG
73700: PUSH
73701: LD_INT 2
73703: NEG
73704: PUSH
73705: EMPTY
73706: LIST
73707: LIST
73708: PUSH
73709: EMPTY
73710: LIST
73711: LIST
73712: LIST
73713: LIST
73714: LIST
73715: LIST
73716: LIST
73717: LIST
73718: LIST
73719: LIST
73720: LIST
73721: LIST
73722: LIST
73723: LIST
73724: LIST
73725: LIST
73726: LIST
73727: LIST
73728: LIST
73729: LIST
73730: LIST
73731: LIST
73732: LIST
73733: ST_TO_ADDR
// fFactory5 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ - 1 , - 3 ] , [ 1 , - 2 ] , [ 3 , 2 ] , [ 2 , 3 ] , [ - 2 , 1 ] , [ - 3 , - 1 ] ] ;
73734: LD_ADDR_VAR 0 34
73738: PUSH
73739: LD_INT 0
73741: PUSH
73742: LD_INT 0
73744: PUSH
73745: EMPTY
73746: LIST
73747: LIST
73748: PUSH
73749: LD_INT 0
73751: PUSH
73752: LD_INT 1
73754: NEG
73755: PUSH
73756: EMPTY
73757: LIST
73758: LIST
73759: PUSH
73760: LD_INT 1
73762: PUSH
73763: LD_INT 0
73765: PUSH
73766: EMPTY
73767: LIST
73768: LIST
73769: PUSH
73770: LD_INT 1
73772: PUSH
73773: LD_INT 1
73775: PUSH
73776: EMPTY
73777: LIST
73778: LIST
73779: PUSH
73780: LD_INT 0
73782: PUSH
73783: LD_INT 1
73785: PUSH
73786: EMPTY
73787: LIST
73788: LIST
73789: PUSH
73790: LD_INT 1
73792: NEG
73793: PUSH
73794: LD_INT 0
73796: PUSH
73797: EMPTY
73798: LIST
73799: LIST
73800: PUSH
73801: LD_INT 1
73803: NEG
73804: PUSH
73805: LD_INT 1
73807: NEG
73808: PUSH
73809: EMPTY
73810: LIST
73811: LIST
73812: PUSH
73813: LD_INT 1
73815: NEG
73816: PUSH
73817: LD_INT 2
73819: NEG
73820: PUSH
73821: EMPTY
73822: LIST
73823: LIST
73824: PUSH
73825: LD_INT 0
73827: PUSH
73828: LD_INT 2
73830: NEG
73831: PUSH
73832: EMPTY
73833: LIST
73834: LIST
73835: PUSH
73836: LD_INT 1
73838: PUSH
73839: LD_INT 1
73841: NEG
73842: PUSH
73843: EMPTY
73844: LIST
73845: LIST
73846: PUSH
73847: LD_INT 2
73849: PUSH
73850: LD_INT 1
73852: PUSH
73853: EMPTY
73854: LIST
73855: LIST
73856: PUSH
73857: LD_INT 2
73859: PUSH
73860: LD_INT 2
73862: PUSH
73863: EMPTY
73864: LIST
73865: LIST
73866: PUSH
73867: LD_INT 1
73869: PUSH
73870: LD_INT 2
73872: PUSH
73873: EMPTY
73874: LIST
73875: LIST
73876: PUSH
73877: LD_INT 1
73879: NEG
73880: PUSH
73881: LD_INT 1
73883: PUSH
73884: EMPTY
73885: LIST
73886: LIST
73887: PUSH
73888: LD_INT 2
73890: NEG
73891: PUSH
73892: LD_INT 0
73894: PUSH
73895: EMPTY
73896: LIST
73897: LIST
73898: PUSH
73899: LD_INT 2
73901: NEG
73902: PUSH
73903: LD_INT 1
73905: NEG
73906: PUSH
73907: EMPTY
73908: LIST
73909: LIST
73910: PUSH
73911: LD_INT 2
73913: NEG
73914: PUSH
73915: LD_INT 2
73917: NEG
73918: PUSH
73919: EMPTY
73920: LIST
73921: LIST
73922: PUSH
73923: LD_INT 1
73925: NEG
73926: PUSH
73927: LD_INT 3
73929: NEG
73930: PUSH
73931: EMPTY
73932: LIST
73933: LIST
73934: PUSH
73935: LD_INT 1
73937: PUSH
73938: LD_INT 2
73940: NEG
73941: PUSH
73942: EMPTY
73943: LIST
73944: LIST
73945: PUSH
73946: LD_INT 3
73948: PUSH
73949: LD_INT 2
73951: PUSH
73952: EMPTY
73953: LIST
73954: LIST
73955: PUSH
73956: LD_INT 2
73958: PUSH
73959: LD_INT 3
73961: PUSH
73962: EMPTY
73963: LIST
73964: LIST
73965: PUSH
73966: LD_INT 2
73968: NEG
73969: PUSH
73970: LD_INT 1
73972: PUSH
73973: EMPTY
73974: LIST
73975: LIST
73976: PUSH
73977: LD_INT 3
73979: NEG
73980: PUSH
73981: LD_INT 1
73983: NEG
73984: PUSH
73985: EMPTY
73986: LIST
73987: LIST
73988: PUSH
73989: EMPTY
73990: LIST
73991: LIST
73992: LIST
73993: LIST
73994: LIST
73995: LIST
73996: LIST
73997: LIST
73998: LIST
73999: LIST
74000: LIST
74001: LIST
74002: LIST
74003: LIST
74004: LIST
74005: LIST
74006: LIST
74007: LIST
74008: LIST
74009: LIST
74010: LIST
74011: LIST
74012: LIST
74013: ST_TO_ADDR
// fExt0 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ 2 , 1 ] , [ - 2 , - 1 ] ] ;
74014: LD_ADDR_VAR 0 35
74018: PUSH
74019: LD_INT 0
74021: PUSH
74022: LD_INT 0
74024: PUSH
74025: EMPTY
74026: LIST
74027: LIST
74028: PUSH
74029: LD_INT 0
74031: PUSH
74032: LD_INT 1
74034: NEG
74035: PUSH
74036: EMPTY
74037: LIST
74038: LIST
74039: PUSH
74040: LD_INT 1
74042: PUSH
74043: LD_INT 0
74045: PUSH
74046: EMPTY
74047: LIST
74048: LIST
74049: PUSH
74050: LD_INT 1
74052: PUSH
74053: LD_INT 1
74055: PUSH
74056: EMPTY
74057: LIST
74058: LIST
74059: PUSH
74060: LD_INT 0
74062: PUSH
74063: LD_INT 1
74065: PUSH
74066: EMPTY
74067: LIST
74068: LIST
74069: PUSH
74070: LD_INT 1
74072: NEG
74073: PUSH
74074: LD_INT 0
74076: PUSH
74077: EMPTY
74078: LIST
74079: LIST
74080: PUSH
74081: LD_INT 1
74083: NEG
74084: PUSH
74085: LD_INT 1
74087: NEG
74088: PUSH
74089: EMPTY
74090: LIST
74091: LIST
74092: PUSH
74093: LD_INT 2
74095: PUSH
74096: LD_INT 1
74098: PUSH
74099: EMPTY
74100: LIST
74101: LIST
74102: PUSH
74103: LD_INT 2
74105: NEG
74106: PUSH
74107: LD_INT 1
74109: NEG
74110: PUSH
74111: EMPTY
74112: LIST
74113: LIST
74114: PUSH
74115: EMPTY
74116: LIST
74117: LIST
74118: LIST
74119: LIST
74120: LIST
74121: LIST
74122: LIST
74123: LIST
74124: LIST
74125: ST_TO_ADDR
// fExt1 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 1 , 2 ] ] ;
74126: LD_ADDR_VAR 0 36
74130: PUSH
74131: LD_INT 0
74133: PUSH
74134: LD_INT 0
74136: PUSH
74137: EMPTY
74138: LIST
74139: LIST
74140: PUSH
74141: LD_INT 0
74143: PUSH
74144: LD_INT 1
74146: NEG
74147: PUSH
74148: EMPTY
74149: LIST
74150: LIST
74151: PUSH
74152: LD_INT 1
74154: PUSH
74155: LD_INT 0
74157: PUSH
74158: EMPTY
74159: LIST
74160: LIST
74161: PUSH
74162: LD_INT 1
74164: PUSH
74165: LD_INT 1
74167: PUSH
74168: EMPTY
74169: LIST
74170: LIST
74171: PUSH
74172: LD_INT 0
74174: PUSH
74175: LD_INT 1
74177: PUSH
74178: EMPTY
74179: LIST
74180: LIST
74181: PUSH
74182: LD_INT 1
74184: NEG
74185: PUSH
74186: LD_INT 0
74188: PUSH
74189: EMPTY
74190: LIST
74191: LIST
74192: PUSH
74193: LD_INT 1
74195: NEG
74196: PUSH
74197: LD_INT 1
74199: NEG
74200: PUSH
74201: EMPTY
74202: LIST
74203: LIST
74204: PUSH
74205: LD_INT 1
74207: NEG
74208: PUSH
74209: LD_INT 2
74211: NEG
74212: PUSH
74213: EMPTY
74214: LIST
74215: LIST
74216: PUSH
74217: LD_INT 1
74219: PUSH
74220: LD_INT 2
74222: PUSH
74223: EMPTY
74224: LIST
74225: LIST
74226: PUSH
74227: EMPTY
74228: LIST
74229: LIST
74230: LIST
74231: LIST
74232: LIST
74233: LIST
74234: LIST
74235: LIST
74236: LIST
74237: ST_TO_ADDR
// fExt2 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ 1 , - 1 ] , [ - 1 , 1 ] ] ;
74238: LD_ADDR_VAR 0 37
74242: PUSH
74243: LD_INT 0
74245: PUSH
74246: LD_INT 0
74248: PUSH
74249: EMPTY
74250: LIST
74251: LIST
74252: PUSH
74253: LD_INT 0
74255: PUSH
74256: LD_INT 1
74258: NEG
74259: PUSH
74260: EMPTY
74261: LIST
74262: LIST
74263: PUSH
74264: LD_INT 1
74266: PUSH
74267: LD_INT 0
74269: PUSH
74270: EMPTY
74271: LIST
74272: LIST
74273: PUSH
74274: LD_INT 1
74276: PUSH
74277: LD_INT 1
74279: PUSH
74280: EMPTY
74281: LIST
74282: LIST
74283: PUSH
74284: LD_INT 0
74286: PUSH
74287: LD_INT 1
74289: PUSH
74290: EMPTY
74291: LIST
74292: LIST
74293: PUSH
74294: LD_INT 1
74296: NEG
74297: PUSH
74298: LD_INT 0
74300: PUSH
74301: EMPTY
74302: LIST
74303: LIST
74304: PUSH
74305: LD_INT 1
74307: NEG
74308: PUSH
74309: LD_INT 1
74311: NEG
74312: PUSH
74313: EMPTY
74314: LIST
74315: LIST
74316: PUSH
74317: LD_INT 1
74319: PUSH
74320: LD_INT 1
74322: NEG
74323: PUSH
74324: EMPTY
74325: LIST
74326: LIST
74327: PUSH
74328: LD_INT 1
74330: NEG
74331: PUSH
74332: LD_INT 1
74334: PUSH
74335: EMPTY
74336: LIST
74337: LIST
74338: PUSH
74339: EMPTY
74340: LIST
74341: LIST
74342: LIST
74343: LIST
74344: LIST
74345: LIST
74346: LIST
74347: LIST
74348: LIST
74349: ST_TO_ADDR
// fExt3 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ 2 , 1 ] , [ - 2 , - 1 ] ] ;
74350: LD_ADDR_VAR 0 38
74354: PUSH
74355: LD_INT 0
74357: PUSH
74358: LD_INT 0
74360: PUSH
74361: EMPTY
74362: LIST
74363: LIST
74364: PUSH
74365: LD_INT 0
74367: PUSH
74368: LD_INT 1
74370: NEG
74371: PUSH
74372: EMPTY
74373: LIST
74374: LIST
74375: PUSH
74376: LD_INT 1
74378: PUSH
74379: LD_INT 0
74381: PUSH
74382: EMPTY
74383: LIST
74384: LIST
74385: PUSH
74386: LD_INT 1
74388: PUSH
74389: LD_INT 1
74391: PUSH
74392: EMPTY
74393: LIST
74394: LIST
74395: PUSH
74396: LD_INT 0
74398: PUSH
74399: LD_INT 1
74401: PUSH
74402: EMPTY
74403: LIST
74404: LIST
74405: PUSH
74406: LD_INT 1
74408: NEG
74409: PUSH
74410: LD_INT 0
74412: PUSH
74413: EMPTY
74414: LIST
74415: LIST
74416: PUSH
74417: LD_INT 1
74419: NEG
74420: PUSH
74421: LD_INT 1
74423: NEG
74424: PUSH
74425: EMPTY
74426: LIST
74427: LIST
74428: PUSH
74429: LD_INT 2
74431: PUSH
74432: LD_INT 1
74434: PUSH
74435: EMPTY
74436: LIST
74437: LIST
74438: PUSH
74439: LD_INT 2
74441: NEG
74442: PUSH
74443: LD_INT 1
74445: NEG
74446: PUSH
74447: EMPTY
74448: LIST
74449: LIST
74450: PUSH
74451: EMPTY
74452: LIST
74453: LIST
74454: LIST
74455: LIST
74456: LIST
74457: LIST
74458: LIST
74459: LIST
74460: LIST
74461: ST_TO_ADDR
// fExt4 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 1 , 2 ] ] ;
74462: LD_ADDR_VAR 0 39
74466: PUSH
74467: LD_INT 0
74469: PUSH
74470: LD_INT 0
74472: PUSH
74473: EMPTY
74474: LIST
74475: LIST
74476: PUSH
74477: LD_INT 0
74479: PUSH
74480: LD_INT 1
74482: NEG
74483: PUSH
74484: EMPTY
74485: LIST
74486: LIST
74487: PUSH
74488: LD_INT 1
74490: PUSH
74491: LD_INT 0
74493: PUSH
74494: EMPTY
74495: LIST
74496: LIST
74497: PUSH
74498: LD_INT 1
74500: PUSH
74501: LD_INT 1
74503: PUSH
74504: EMPTY
74505: LIST
74506: LIST
74507: PUSH
74508: LD_INT 0
74510: PUSH
74511: LD_INT 1
74513: PUSH
74514: EMPTY
74515: LIST
74516: LIST
74517: PUSH
74518: LD_INT 1
74520: NEG
74521: PUSH
74522: LD_INT 0
74524: PUSH
74525: EMPTY
74526: LIST
74527: LIST
74528: PUSH
74529: LD_INT 1
74531: NEG
74532: PUSH
74533: LD_INT 1
74535: NEG
74536: PUSH
74537: EMPTY
74538: LIST
74539: LIST
74540: PUSH
74541: LD_INT 1
74543: NEG
74544: PUSH
74545: LD_INT 2
74547: NEG
74548: PUSH
74549: EMPTY
74550: LIST
74551: LIST
74552: PUSH
74553: LD_INT 1
74555: PUSH
74556: LD_INT 2
74558: PUSH
74559: EMPTY
74560: LIST
74561: LIST
74562: PUSH
74563: EMPTY
74564: LIST
74565: LIST
74566: LIST
74567: LIST
74568: LIST
74569: LIST
74570: LIST
74571: LIST
74572: LIST
74573: ST_TO_ADDR
// fExt5 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ 1 , - 1 ] , [ - 1 , 1 ] ] ;
74574: LD_ADDR_VAR 0 40
74578: PUSH
74579: LD_INT 0
74581: PUSH
74582: LD_INT 0
74584: PUSH
74585: EMPTY
74586: LIST
74587: LIST
74588: PUSH
74589: LD_INT 0
74591: PUSH
74592: LD_INT 1
74594: NEG
74595: PUSH
74596: EMPTY
74597: LIST
74598: LIST
74599: PUSH
74600: LD_INT 1
74602: PUSH
74603: LD_INT 0
74605: PUSH
74606: EMPTY
74607: LIST
74608: LIST
74609: PUSH
74610: LD_INT 1
74612: PUSH
74613: LD_INT 1
74615: PUSH
74616: EMPTY
74617: LIST
74618: LIST
74619: PUSH
74620: LD_INT 0
74622: PUSH
74623: LD_INT 1
74625: PUSH
74626: EMPTY
74627: LIST
74628: LIST
74629: PUSH
74630: LD_INT 1
74632: NEG
74633: PUSH
74634: LD_INT 0
74636: PUSH
74637: EMPTY
74638: LIST
74639: LIST
74640: PUSH
74641: LD_INT 1
74643: NEG
74644: PUSH
74645: LD_INT 1
74647: NEG
74648: PUSH
74649: EMPTY
74650: LIST
74651: LIST
74652: PUSH
74653: LD_INT 1
74655: PUSH
74656: LD_INT 1
74658: NEG
74659: PUSH
74660: EMPTY
74661: LIST
74662: LIST
74663: PUSH
74664: LD_INT 1
74666: NEG
74667: PUSH
74668: LD_INT 1
74670: PUSH
74671: EMPTY
74672: LIST
74673: LIST
74674: PUSH
74675: EMPTY
74676: LIST
74677: LIST
74678: LIST
74679: LIST
74680: LIST
74681: LIST
74682: LIST
74683: LIST
74684: LIST
74685: ST_TO_ADDR
// fLab0 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ - 2 , - 3 ] , [ 2 , - 1 ] , [ 3 , 0 ] , [ 3 , 1 ] , [ 3 , 2 ] , [ 3 , 3 ] , [ 2 , 3 ] , [ - 2 , 1 ] , [ - 3 , 0 ] , [ - 3 , - 1 ] , [ - 3 , - 2 ] , [ - 3 , - 3 ] ] ;
74686: LD_ADDR_VAR 0 41
74690: PUSH
74691: LD_INT 0
74693: PUSH
74694: LD_INT 0
74696: PUSH
74697: EMPTY
74698: LIST
74699: LIST
74700: PUSH
74701: LD_INT 0
74703: PUSH
74704: LD_INT 1
74706: NEG
74707: PUSH
74708: EMPTY
74709: LIST
74710: LIST
74711: PUSH
74712: LD_INT 1
74714: PUSH
74715: LD_INT 0
74717: PUSH
74718: EMPTY
74719: LIST
74720: LIST
74721: PUSH
74722: LD_INT 1
74724: PUSH
74725: LD_INT 1
74727: PUSH
74728: EMPTY
74729: LIST
74730: LIST
74731: PUSH
74732: LD_INT 0
74734: PUSH
74735: LD_INT 1
74737: PUSH
74738: EMPTY
74739: LIST
74740: LIST
74741: PUSH
74742: LD_INT 1
74744: NEG
74745: PUSH
74746: LD_INT 0
74748: PUSH
74749: EMPTY
74750: LIST
74751: LIST
74752: PUSH
74753: LD_INT 1
74755: NEG
74756: PUSH
74757: LD_INT 1
74759: NEG
74760: PUSH
74761: EMPTY
74762: LIST
74763: LIST
74764: PUSH
74765: LD_INT 1
74767: NEG
74768: PUSH
74769: LD_INT 2
74771: NEG
74772: PUSH
74773: EMPTY
74774: LIST
74775: LIST
74776: PUSH
74777: LD_INT 1
74779: PUSH
74780: LD_INT 1
74782: NEG
74783: PUSH
74784: EMPTY
74785: LIST
74786: LIST
74787: PUSH
74788: LD_INT 2
74790: PUSH
74791: LD_INT 0
74793: PUSH
74794: EMPTY
74795: LIST
74796: LIST
74797: PUSH
74798: LD_INT 2
74800: PUSH
74801: LD_INT 1
74803: PUSH
74804: EMPTY
74805: LIST
74806: LIST
74807: PUSH
74808: LD_INT 2
74810: PUSH
74811: LD_INT 2
74813: PUSH
74814: EMPTY
74815: LIST
74816: LIST
74817: PUSH
74818: LD_INT 1
74820: PUSH
74821: LD_INT 2
74823: PUSH
74824: EMPTY
74825: LIST
74826: LIST
74827: PUSH
74828: LD_INT 1
74830: NEG
74831: PUSH
74832: LD_INT 1
74834: PUSH
74835: EMPTY
74836: LIST
74837: LIST
74838: PUSH
74839: LD_INT 2
74841: NEG
74842: PUSH
74843: LD_INT 0
74845: PUSH
74846: EMPTY
74847: LIST
74848: LIST
74849: PUSH
74850: LD_INT 2
74852: NEG
74853: PUSH
74854: LD_INT 1
74856: NEG
74857: PUSH
74858: EMPTY
74859: LIST
74860: LIST
74861: PUSH
74862: LD_INT 2
74864: NEG
74865: PUSH
74866: LD_INT 2
74868: NEG
74869: PUSH
74870: EMPTY
74871: LIST
74872: LIST
74873: PUSH
74874: LD_INT 2
74876: NEG
74877: PUSH
74878: LD_INT 3
74880: NEG
74881: PUSH
74882: EMPTY
74883: LIST
74884: LIST
74885: PUSH
74886: LD_INT 2
74888: PUSH
74889: LD_INT 1
74891: NEG
74892: PUSH
74893: EMPTY
74894: LIST
74895: LIST
74896: PUSH
74897: LD_INT 3
74899: PUSH
74900: LD_INT 0
74902: PUSH
74903: EMPTY
74904: LIST
74905: LIST
74906: PUSH
74907: LD_INT 3
74909: PUSH
74910: LD_INT 1
74912: PUSH
74913: EMPTY
74914: LIST
74915: LIST
74916: PUSH
74917: LD_INT 3
74919: PUSH
74920: LD_INT 2
74922: PUSH
74923: EMPTY
74924: LIST
74925: LIST
74926: PUSH
74927: LD_INT 3
74929: PUSH
74930: LD_INT 3
74932: PUSH
74933: EMPTY
74934: LIST
74935: LIST
74936: PUSH
74937: LD_INT 2
74939: PUSH
74940: LD_INT 3
74942: PUSH
74943: EMPTY
74944: LIST
74945: LIST
74946: PUSH
74947: LD_INT 2
74949: NEG
74950: PUSH
74951: LD_INT 1
74953: PUSH
74954: EMPTY
74955: LIST
74956: LIST
74957: PUSH
74958: LD_INT 3
74960: NEG
74961: PUSH
74962: LD_INT 0
74964: PUSH
74965: EMPTY
74966: LIST
74967: LIST
74968: PUSH
74969: LD_INT 3
74971: NEG
74972: PUSH
74973: LD_INT 1
74975: NEG
74976: PUSH
74977: EMPTY
74978: LIST
74979: LIST
74980: PUSH
74981: LD_INT 3
74983: NEG
74984: PUSH
74985: LD_INT 2
74987: NEG
74988: PUSH
74989: EMPTY
74990: LIST
74991: LIST
74992: PUSH
74993: LD_INT 3
74995: NEG
74996: PUSH
74997: LD_INT 3
74999: NEG
75000: PUSH
75001: EMPTY
75002: LIST
75003: LIST
75004: PUSH
75005: EMPTY
75006: LIST
75007: LIST
75008: LIST
75009: LIST
75010: LIST
75011: LIST
75012: LIST
75013: LIST
75014: LIST
75015: LIST
75016: LIST
75017: LIST
75018: LIST
75019: LIST
75020: LIST
75021: LIST
75022: LIST
75023: LIST
75024: LIST
75025: LIST
75026: LIST
75027: LIST
75028: LIST
75029: LIST
75030: LIST
75031: LIST
75032: LIST
75033: LIST
75034: LIST
75035: ST_TO_ADDR
// fLab1 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ - 2 , - 3 ] , [ - 1 , - 3 ] , [ 0 , - 3 ] , [ 1 , - 2 ] , [ 3 , 2 ] , [ 3 , 3 ] , [ 2 , 3 ] , [ 1 , 3 ] , [ 0 , 3 ] , [ - 1 , 2 ] , [ - 3 , - 2 ] , [ - 3 , - 3 ] ] ;
75036: LD_ADDR_VAR 0 42
75040: PUSH
75041: LD_INT 0
75043: PUSH
75044: LD_INT 0
75046: PUSH
75047: EMPTY
75048: LIST
75049: LIST
75050: PUSH
75051: LD_INT 0
75053: PUSH
75054: LD_INT 1
75056: NEG
75057: PUSH
75058: EMPTY
75059: LIST
75060: LIST
75061: PUSH
75062: LD_INT 1
75064: PUSH
75065: LD_INT 0
75067: PUSH
75068: EMPTY
75069: LIST
75070: LIST
75071: PUSH
75072: LD_INT 1
75074: PUSH
75075: LD_INT 1
75077: PUSH
75078: EMPTY
75079: LIST
75080: LIST
75081: PUSH
75082: LD_INT 0
75084: PUSH
75085: LD_INT 1
75087: PUSH
75088: EMPTY
75089: LIST
75090: LIST
75091: PUSH
75092: LD_INT 1
75094: NEG
75095: PUSH
75096: LD_INT 0
75098: PUSH
75099: EMPTY
75100: LIST
75101: LIST
75102: PUSH
75103: LD_INT 1
75105: NEG
75106: PUSH
75107: LD_INT 1
75109: NEG
75110: PUSH
75111: EMPTY
75112: LIST
75113: LIST
75114: PUSH
75115: LD_INT 1
75117: NEG
75118: PUSH
75119: LD_INT 2
75121: NEG
75122: PUSH
75123: EMPTY
75124: LIST
75125: LIST
75126: PUSH
75127: LD_INT 0
75129: PUSH
75130: LD_INT 2
75132: NEG
75133: PUSH
75134: EMPTY
75135: LIST
75136: LIST
75137: PUSH
75138: LD_INT 1
75140: PUSH
75141: LD_INT 1
75143: NEG
75144: PUSH
75145: EMPTY
75146: LIST
75147: LIST
75148: PUSH
75149: LD_INT 2
75151: PUSH
75152: LD_INT 1
75154: PUSH
75155: EMPTY
75156: LIST
75157: LIST
75158: PUSH
75159: LD_INT 2
75161: PUSH
75162: LD_INT 2
75164: PUSH
75165: EMPTY
75166: LIST
75167: LIST
75168: PUSH
75169: LD_INT 1
75171: PUSH
75172: LD_INT 2
75174: PUSH
75175: EMPTY
75176: LIST
75177: LIST
75178: PUSH
75179: LD_INT 0
75181: PUSH
75182: LD_INT 2
75184: PUSH
75185: EMPTY
75186: LIST
75187: LIST
75188: PUSH
75189: LD_INT 1
75191: NEG
75192: PUSH
75193: LD_INT 1
75195: PUSH
75196: EMPTY
75197: LIST
75198: LIST
75199: PUSH
75200: LD_INT 2
75202: NEG
75203: PUSH
75204: LD_INT 1
75206: NEG
75207: PUSH
75208: EMPTY
75209: LIST
75210: LIST
75211: PUSH
75212: LD_INT 2
75214: NEG
75215: PUSH
75216: LD_INT 2
75218: NEG
75219: PUSH
75220: EMPTY
75221: LIST
75222: LIST
75223: PUSH
75224: LD_INT 2
75226: NEG
75227: PUSH
75228: LD_INT 3
75230: NEG
75231: PUSH
75232: EMPTY
75233: LIST
75234: LIST
75235: PUSH
75236: LD_INT 1
75238: NEG
75239: PUSH
75240: LD_INT 3
75242: NEG
75243: PUSH
75244: EMPTY
75245: LIST
75246: LIST
75247: PUSH
75248: LD_INT 0
75250: PUSH
75251: LD_INT 3
75253: NEG
75254: PUSH
75255: EMPTY
75256: LIST
75257: LIST
75258: PUSH
75259: LD_INT 1
75261: PUSH
75262: LD_INT 2
75264: NEG
75265: PUSH
75266: EMPTY
75267: LIST
75268: LIST
75269: PUSH
75270: LD_INT 3
75272: PUSH
75273: LD_INT 2
75275: PUSH
75276: EMPTY
75277: LIST
75278: LIST
75279: PUSH
75280: LD_INT 3
75282: PUSH
75283: LD_INT 3
75285: PUSH
75286: EMPTY
75287: LIST
75288: LIST
75289: PUSH
75290: LD_INT 2
75292: PUSH
75293: LD_INT 3
75295: PUSH
75296: EMPTY
75297: LIST
75298: LIST
75299: PUSH
75300: LD_INT 1
75302: PUSH
75303: LD_INT 3
75305: PUSH
75306: EMPTY
75307: LIST
75308: LIST
75309: PUSH
75310: LD_INT 0
75312: PUSH
75313: LD_INT 3
75315: PUSH
75316: EMPTY
75317: LIST
75318: LIST
75319: PUSH
75320: LD_INT 1
75322: NEG
75323: PUSH
75324: LD_INT 2
75326: PUSH
75327: EMPTY
75328: LIST
75329: LIST
75330: PUSH
75331: LD_INT 3
75333: NEG
75334: PUSH
75335: LD_INT 2
75337: NEG
75338: PUSH
75339: EMPTY
75340: LIST
75341: LIST
75342: PUSH
75343: LD_INT 3
75345: NEG
75346: PUSH
75347: LD_INT 3
75349: NEG
75350: PUSH
75351: EMPTY
75352: LIST
75353: LIST
75354: PUSH
75355: EMPTY
75356: LIST
75357: LIST
75358: LIST
75359: LIST
75360: LIST
75361: LIST
75362: LIST
75363: LIST
75364: LIST
75365: LIST
75366: LIST
75367: LIST
75368: LIST
75369: LIST
75370: LIST
75371: LIST
75372: LIST
75373: LIST
75374: LIST
75375: LIST
75376: LIST
75377: LIST
75378: LIST
75379: LIST
75380: LIST
75381: LIST
75382: LIST
75383: LIST
75384: LIST
75385: ST_TO_ADDR
// fLab2 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 1 , - 3 ] , [ 0 , - 3 ] , [ 1 , - 2 ] , [ 2 , - 1 ] , [ 3 , 0 ] , [ 3 , 1 ] , [ 1 , 3 ] , [ 0 , 3 ] , [ - 1 , 2 ] , [ - 2 , 1 ] , [ - 3 , 0 ] , [ - 3 , - 1 ] ] ;
75386: LD_ADDR_VAR 0 43
75390: PUSH
75391: LD_INT 0
75393: PUSH
75394: LD_INT 0
75396: PUSH
75397: EMPTY
75398: LIST
75399: LIST
75400: PUSH
75401: LD_INT 0
75403: PUSH
75404: LD_INT 1
75406: NEG
75407: PUSH
75408: EMPTY
75409: LIST
75410: LIST
75411: PUSH
75412: LD_INT 1
75414: PUSH
75415: LD_INT 0
75417: PUSH
75418: EMPTY
75419: LIST
75420: LIST
75421: PUSH
75422: LD_INT 1
75424: PUSH
75425: LD_INT 1
75427: PUSH
75428: EMPTY
75429: LIST
75430: LIST
75431: PUSH
75432: LD_INT 0
75434: PUSH
75435: LD_INT 1
75437: PUSH
75438: EMPTY
75439: LIST
75440: LIST
75441: PUSH
75442: LD_INT 1
75444: NEG
75445: PUSH
75446: LD_INT 0
75448: PUSH
75449: EMPTY
75450: LIST
75451: LIST
75452: PUSH
75453: LD_INT 1
75455: NEG
75456: PUSH
75457: LD_INT 1
75459: NEG
75460: PUSH
75461: EMPTY
75462: LIST
75463: LIST
75464: PUSH
75465: LD_INT 1
75467: NEG
75468: PUSH
75469: LD_INT 2
75471: NEG
75472: PUSH
75473: EMPTY
75474: LIST
75475: LIST
75476: PUSH
75477: LD_INT 0
75479: PUSH
75480: LD_INT 2
75482: NEG
75483: PUSH
75484: EMPTY
75485: LIST
75486: LIST
75487: PUSH
75488: LD_INT 1
75490: PUSH
75491: LD_INT 1
75493: NEG
75494: PUSH
75495: EMPTY
75496: LIST
75497: LIST
75498: PUSH
75499: LD_INT 2
75501: PUSH
75502: LD_INT 0
75504: PUSH
75505: EMPTY
75506: LIST
75507: LIST
75508: PUSH
75509: LD_INT 2
75511: PUSH
75512: LD_INT 1
75514: PUSH
75515: EMPTY
75516: LIST
75517: LIST
75518: PUSH
75519: LD_INT 1
75521: PUSH
75522: LD_INT 2
75524: PUSH
75525: EMPTY
75526: LIST
75527: LIST
75528: PUSH
75529: LD_INT 0
75531: PUSH
75532: LD_INT 2
75534: PUSH
75535: EMPTY
75536: LIST
75537: LIST
75538: PUSH
75539: LD_INT 1
75541: NEG
75542: PUSH
75543: LD_INT 1
75545: PUSH
75546: EMPTY
75547: LIST
75548: LIST
75549: PUSH
75550: LD_INT 2
75552: NEG
75553: PUSH
75554: LD_INT 0
75556: PUSH
75557: EMPTY
75558: LIST
75559: LIST
75560: PUSH
75561: LD_INT 2
75563: NEG
75564: PUSH
75565: LD_INT 1
75567: NEG
75568: PUSH
75569: EMPTY
75570: LIST
75571: LIST
75572: PUSH
75573: LD_INT 1
75575: NEG
75576: PUSH
75577: LD_INT 3
75579: NEG
75580: PUSH
75581: EMPTY
75582: LIST
75583: LIST
75584: PUSH
75585: LD_INT 0
75587: PUSH
75588: LD_INT 3
75590: NEG
75591: PUSH
75592: EMPTY
75593: LIST
75594: LIST
75595: PUSH
75596: LD_INT 1
75598: PUSH
75599: LD_INT 2
75601: NEG
75602: PUSH
75603: EMPTY
75604: LIST
75605: LIST
75606: PUSH
75607: LD_INT 2
75609: PUSH
75610: LD_INT 1
75612: NEG
75613: PUSH
75614: EMPTY
75615: LIST
75616: LIST
75617: PUSH
75618: LD_INT 3
75620: PUSH
75621: LD_INT 0
75623: PUSH
75624: EMPTY
75625: LIST
75626: LIST
75627: PUSH
75628: LD_INT 3
75630: PUSH
75631: LD_INT 1
75633: PUSH
75634: EMPTY
75635: LIST
75636: LIST
75637: PUSH
75638: LD_INT 1
75640: PUSH
75641: LD_INT 3
75643: PUSH
75644: EMPTY
75645: LIST
75646: LIST
75647: PUSH
75648: LD_INT 0
75650: PUSH
75651: LD_INT 3
75653: PUSH
75654: EMPTY
75655: LIST
75656: LIST
75657: PUSH
75658: LD_INT 1
75660: NEG
75661: PUSH
75662: LD_INT 2
75664: PUSH
75665: EMPTY
75666: LIST
75667: LIST
75668: PUSH
75669: LD_INT 2
75671: NEG
75672: PUSH
75673: LD_INT 1
75675: PUSH
75676: EMPTY
75677: LIST
75678: LIST
75679: PUSH
75680: LD_INT 3
75682: NEG
75683: PUSH
75684: LD_INT 0
75686: PUSH
75687: EMPTY
75688: LIST
75689: LIST
75690: PUSH
75691: LD_INT 3
75693: NEG
75694: PUSH
75695: LD_INT 1
75697: NEG
75698: PUSH
75699: EMPTY
75700: LIST
75701: LIST
75702: PUSH
75703: EMPTY
75704: LIST
75705: LIST
75706: LIST
75707: LIST
75708: LIST
75709: LIST
75710: LIST
75711: LIST
75712: LIST
75713: LIST
75714: LIST
75715: LIST
75716: LIST
75717: LIST
75718: LIST
75719: LIST
75720: LIST
75721: LIST
75722: LIST
75723: LIST
75724: LIST
75725: LIST
75726: LIST
75727: LIST
75728: LIST
75729: LIST
75730: LIST
75731: LIST
75732: LIST
75733: ST_TO_ADDR
// fLab3 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ - 2 , - 3 ] , [ 2 , - 1 ] , [ 3 , 0 ] , [ 3 , 1 ] , [ 3 , 2 ] , [ 3 , 3 ] , [ 2 , 3 ] , [ - 2 , 1 ] , [ - 3 , 0 ] , [ - 3 , - 1 ] , [ - 3 , - 2 ] , [ - 3 , - 3 ] ] ;
75734: LD_ADDR_VAR 0 44
75738: PUSH
75739: LD_INT 0
75741: PUSH
75742: LD_INT 0
75744: PUSH
75745: EMPTY
75746: LIST
75747: LIST
75748: PUSH
75749: LD_INT 0
75751: PUSH
75752: LD_INT 1
75754: NEG
75755: PUSH
75756: EMPTY
75757: LIST
75758: LIST
75759: PUSH
75760: LD_INT 1
75762: PUSH
75763: LD_INT 0
75765: PUSH
75766: EMPTY
75767: LIST
75768: LIST
75769: PUSH
75770: LD_INT 1
75772: PUSH
75773: LD_INT 1
75775: PUSH
75776: EMPTY
75777: LIST
75778: LIST
75779: PUSH
75780: LD_INT 0
75782: PUSH
75783: LD_INT 1
75785: PUSH
75786: EMPTY
75787: LIST
75788: LIST
75789: PUSH
75790: LD_INT 1
75792: NEG
75793: PUSH
75794: LD_INT 0
75796: PUSH
75797: EMPTY
75798: LIST
75799: LIST
75800: PUSH
75801: LD_INT 1
75803: NEG
75804: PUSH
75805: LD_INT 1
75807: NEG
75808: PUSH
75809: EMPTY
75810: LIST
75811: LIST
75812: PUSH
75813: LD_INT 1
75815: NEG
75816: PUSH
75817: LD_INT 2
75819: NEG
75820: PUSH
75821: EMPTY
75822: LIST
75823: LIST
75824: PUSH
75825: LD_INT 1
75827: PUSH
75828: LD_INT 1
75830: NEG
75831: PUSH
75832: EMPTY
75833: LIST
75834: LIST
75835: PUSH
75836: LD_INT 2
75838: PUSH
75839: LD_INT 0
75841: PUSH
75842: EMPTY
75843: LIST
75844: LIST
75845: PUSH
75846: LD_INT 2
75848: PUSH
75849: LD_INT 1
75851: PUSH
75852: EMPTY
75853: LIST
75854: LIST
75855: PUSH
75856: LD_INT 2
75858: PUSH
75859: LD_INT 2
75861: PUSH
75862: EMPTY
75863: LIST
75864: LIST
75865: PUSH
75866: LD_INT 1
75868: PUSH
75869: LD_INT 2
75871: PUSH
75872: EMPTY
75873: LIST
75874: LIST
75875: PUSH
75876: LD_INT 1
75878: NEG
75879: PUSH
75880: LD_INT 1
75882: PUSH
75883: EMPTY
75884: LIST
75885: LIST
75886: PUSH
75887: LD_INT 2
75889: NEG
75890: PUSH
75891: LD_INT 0
75893: PUSH
75894: EMPTY
75895: LIST
75896: LIST
75897: PUSH
75898: LD_INT 2
75900: NEG
75901: PUSH
75902: LD_INT 1
75904: NEG
75905: PUSH
75906: EMPTY
75907: LIST
75908: LIST
75909: PUSH
75910: LD_INT 2
75912: NEG
75913: PUSH
75914: LD_INT 2
75916: NEG
75917: PUSH
75918: EMPTY
75919: LIST
75920: LIST
75921: PUSH
75922: LD_INT 2
75924: NEG
75925: PUSH
75926: LD_INT 3
75928: NEG
75929: PUSH
75930: EMPTY
75931: LIST
75932: LIST
75933: PUSH
75934: LD_INT 2
75936: PUSH
75937: LD_INT 1
75939: NEG
75940: PUSH
75941: EMPTY
75942: LIST
75943: LIST
75944: PUSH
75945: LD_INT 3
75947: PUSH
75948: LD_INT 0
75950: PUSH
75951: EMPTY
75952: LIST
75953: LIST
75954: PUSH
75955: LD_INT 3
75957: PUSH
75958: LD_INT 1
75960: PUSH
75961: EMPTY
75962: LIST
75963: LIST
75964: PUSH
75965: LD_INT 3
75967: PUSH
75968: LD_INT 2
75970: PUSH
75971: EMPTY
75972: LIST
75973: LIST
75974: PUSH
75975: LD_INT 3
75977: PUSH
75978: LD_INT 3
75980: PUSH
75981: EMPTY
75982: LIST
75983: LIST
75984: PUSH
75985: LD_INT 2
75987: PUSH
75988: LD_INT 3
75990: PUSH
75991: EMPTY
75992: LIST
75993: LIST
75994: PUSH
75995: LD_INT 2
75997: NEG
75998: PUSH
75999: LD_INT 1
76001: PUSH
76002: EMPTY
76003: LIST
76004: LIST
76005: PUSH
76006: LD_INT 3
76008: NEG
76009: PUSH
76010: LD_INT 0
76012: PUSH
76013: EMPTY
76014: LIST
76015: LIST
76016: PUSH
76017: LD_INT 3
76019: NEG
76020: PUSH
76021: LD_INT 1
76023: NEG
76024: PUSH
76025: EMPTY
76026: LIST
76027: LIST
76028: PUSH
76029: LD_INT 3
76031: NEG
76032: PUSH
76033: LD_INT 2
76035: NEG
76036: PUSH
76037: EMPTY
76038: LIST
76039: LIST
76040: PUSH
76041: LD_INT 3
76043: NEG
76044: PUSH
76045: LD_INT 3
76047: NEG
76048: PUSH
76049: EMPTY
76050: LIST
76051: LIST
76052: PUSH
76053: EMPTY
76054: LIST
76055: LIST
76056: LIST
76057: LIST
76058: LIST
76059: LIST
76060: LIST
76061: LIST
76062: LIST
76063: LIST
76064: LIST
76065: LIST
76066: LIST
76067: LIST
76068: LIST
76069: LIST
76070: LIST
76071: LIST
76072: LIST
76073: LIST
76074: LIST
76075: LIST
76076: LIST
76077: LIST
76078: LIST
76079: LIST
76080: LIST
76081: LIST
76082: LIST
76083: ST_TO_ADDR
// fLab4 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ - 2 , - 3 ] , [ - 1 , - 3 ] , [ 0 , - 3 ] , [ 1 , - 2 ] , [ 3 , 2 ] , [ 3 , 3 ] , [ 2 , 3 ] , [ 1 , 3 ] , [ 0 , 3 ] , [ - 1 , 2 ] , [ - 3 , - 2 ] , [ - 3 , - 3 ] ] ;
76084: LD_ADDR_VAR 0 45
76088: PUSH
76089: LD_INT 0
76091: PUSH
76092: LD_INT 0
76094: PUSH
76095: EMPTY
76096: LIST
76097: LIST
76098: PUSH
76099: LD_INT 0
76101: PUSH
76102: LD_INT 1
76104: NEG
76105: PUSH
76106: EMPTY
76107: LIST
76108: LIST
76109: PUSH
76110: LD_INT 1
76112: PUSH
76113: LD_INT 0
76115: PUSH
76116: EMPTY
76117: LIST
76118: LIST
76119: PUSH
76120: LD_INT 1
76122: PUSH
76123: LD_INT 1
76125: PUSH
76126: EMPTY
76127: LIST
76128: LIST
76129: PUSH
76130: LD_INT 0
76132: PUSH
76133: LD_INT 1
76135: PUSH
76136: EMPTY
76137: LIST
76138: LIST
76139: PUSH
76140: LD_INT 1
76142: NEG
76143: PUSH
76144: LD_INT 0
76146: PUSH
76147: EMPTY
76148: LIST
76149: LIST
76150: PUSH
76151: LD_INT 1
76153: NEG
76154: PUSH
76155: LD_INT 1
76157: NEG
76158: PUSH
76159: EMPTY
76160: LIST
76161: LIST
76162: PUSH
76163: LD_INT 1
76165: NEG
76166: PUSH
76167: LD_INT 2
76169: NEG
76170: PUSH
76171: EMPTY
76172: LIST
76173: LIST
76174: PUSH
76175: LD_INT 0
76177: PUSH
76178: LD_INT 2
76180: NEG
76181: PUSH
76182: EMPTY
76183: LIST
76184: LIST
76185: PUSH
76186: LD_INT 1
76188: PUSH
76189: LD_INT 1
76191: NEG
76192: PUSH
76193: EMPTY
76194: LIST
76195: LIST
76196: PUSH
76197: LD_INT 2
76199: PUSH
76200: LD_INT 1
76202: PUSH
76203: EMPTY
76204: LIST
76205: LIST
76206: PUSH
76207: LD_INT 2
76209: PUSH
76210: LD_INT 2
76212: PUSH
76213: EMPTY
76214: LIST
76215: LIST
76216: PUSH
76217: LD_INT 1
76219: PUSH
76220: LD_INT 2
76222: PUSH
76223: EMPTY
76224: LIST
76225: LIST
76226: PUSH
76227: LD_INT 0
76229: PUSH
76230: LD_INT 2
76232: PUSH
76233: EMPTY
76234: LIST
76235: LIST
76236: PUSH
76237: LD_INT 1
76239: NEG
76240: PUSH
76241: LD_INT 1
76243: PUSH
76244: EMPTY
76245: LIST
76246: LIST
76247: PUSH
76248: LD_INT 2
76250: NEG
76251: PUSH
76252: LD_INT 1
76254: NEG
76255: PUSH
76256: EMPTY
76257: LIST
76258: LIST
76259: PUSH
76260: LD_INT 2
76262: NEG
76263: PUSH
76264: LD_INT 2
76266: NEG
76267: PUSH
76268: EMPTY
76269: LIST
76270: LIST
76271: PUSH
76272: LD_INT 2
76274: NEG
76275: PUSH
76276: LD_INT 3
76278: NEG
76279: PUSH
76280: EMPTY
76281: LIST
76282: LIST
76283: PUSH
76284: LD_INT 1
76286: NEG
76287: PUSH
76288: LD_INT 3
76290: NEG
76291: PUSH
76292: EMPTY
76293: LIST
76294: LIST
76295: PUSH
76296: LD_INT 0
76298: PUSH
76299: LD_INT 3
76301: NEG
76302: PUSH
76303: EMPTY
76304: LIST
76305: LIST
76306: PUSH
76307: LD_INT 1
76309: PUSH
76310: LD_INT 2
76312: NEG
76313: PUSH
76314: EMPTY
76315: LIST
76316: LIST
76317: PUSH
76318: LD_INT 3
76320: PUSH
76321: LD_INT 2
76323: PUSH
76324: EMPTY
76325: LIST
76326: LIST
76327: PUSH
76328: LD_INT 3
76330: PUSH
76331: LD_INT 3
76333: PUSH
76334: EMPTY
76335: LIST
76336: LIST
76337: PUSH
76338: LD_INT 2
76340: PUSH
76341: LD_INT 3
76343: PUSH
76344: EMPTY
76345: LIST
76346: LIST
76347: PUSH
76348: LD_INT 1
76350: PUSH
76351: LD_INT 3
76353: PUSH
76354: EMPTY
76355: LIST
76356: LIST
76357: PUSH
76358: LD_INT 0
76360: PUSH
76361: LD_INT 3
76363: PUSH
76364: EMPTY
76365: LIST
76366: LIST
76367: PUSH
76368: LD_INT 1
76370: NEG
76371: PUSH
76372: LD_INT 2
76374: PUSH
76375: EMPTY
76376: LIST
76377: LIST
76378: PUSH
76379: LD_INT 3
76381: NEG
76382: PUSH
76383: LD_INT 2
76385: NEG
76386: PUSH
76387: EMPTY
76388: LIST
76389: LIST
76390: PUSH
76391: LD_INT 3
76393: NEG
76394: PUSH
76395: LD_INT 3
76397: NEG
76398: PUSH
76399: EMPTY
76400: LIST
76401: LIST
76402: PUSH
76403: EMPTY
76404: LIST
76405: LIST
76406: LIST
76407: LIST
76408: LIST
76409: LIST
76410: LIST
76411: LIST
76412: LIST
76413: LIST
76414: LIST
76415: LIST
76416: LIST
76417: LIST
76418: LIST
76419: LIST
76420: LIST
76421: LIST
76422: LIST
76423: LIST
76424: LIST
76425: LIST
76426: LIST
76427: LIST
76428: LIST
76429: LIST
76430: LIST
76431: LIST
76432: LIST
76433: ST_TO_ADDR
// fLab5 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 1 , - 3 ] , [ 0 , - 3 ] , [ 1 , - 2 ] , [ 2 , - 1 ] , [ 3 , 0 ] , [ 3 , 1 ] , [ 1 , 3 ] , [ 0 , 3 ] , [ - 1 , 2 ] , [ - 2 , 1 ] , [ - 3 , 0 ] , [ - 3 , - 1 ] ] ;
76434: LD_ADDR_VAR 0 46
76438: PUSH
76439: LD_INT 0
76441: PUSH
76442: LD_INT 0
76444: PUSH
76445: EMPTY
76446: LIST
76447: LIST
76448: PUSH
76449: LD_INT 0
76451: PUSH
76452: LD_INT 1
76454: NEG
76455: PUSH
76456: EMPTY
76457: LIST
76458: LIST
76459: PUSH
76460: LD_INT 1
76462: PUSH
76463: LD_INT 0
76465: PUSH
76466: EMPTY
76467: LIST
76468: LIST
76469: PUSH
76470: LD_INT 1
76472: PUSH
76473: LD_INT 1
76475: PUSH
76476: EMPTY
76477: LIST
76478: LIST
76479: PUSH
76480: LD_INT 0
76482: PUSH
76483: LD_INT 1
76485: PUSH
76486: EMPTY
76487: LIST
76488: LIST
76489: PUSH
76490: LD_INT 1
76492: NEG
76493: PUSH
76494: LD_INT 0
76496: PUSH
76497: EMPTY
76498: LIST
76499: LIST
76500: PUSH
76501: LD_INT 1
76503: NEG
76504: PUSH
76505: LD_INT 1
76507: NEG
76508: PUSH
76509: EMPTY
76510: LIST
76511: LIST
76512: PUSH
76513: LD_INT 1
76515: NEG
76516: PUSH
76517: LD_INT 2
76519: NEG
76520: PUSH
76521: EMPTY
76522: LIST
76523: LIST
76524: PUSH
76525: LD_INT 0
76527: PUSH
76528: LD_INT 2
76530: NEG
76531: PUSH
76532: EMPTY
76533: LIST
76534: LIST
76535: PUSH
76536: LD_INT 1
76538: PUSH
76539: LD_INT 1
76541: NEG
76542: PUSH
76543: EMPTY
76544: LIST
76545: LIST
76546: PUSH
76547: LD_INT 2
76549: PUSH
76550: LD_INT 0
76552: PUSH
76553: EMPTY
76554: LIST
76555: LIST
76556: PUSH
76557: LD_INT 2
76559: PUSH
76560: LD_INT 1
76562: PUSH
76563: EMPTY
76564: LIST
76565: LIST
76566: PUSH
76567: LD_INT 1
76569: PUSH
76570: LD_INT 2
76572: PUSH
76573: EMPTY
76574: LIST
76575: LIST
76576: PUSH
76577: LD_INT 0
76579: PUSH
76580: LD_INT 2
76582: PUSH
76583: EMPTY
76584: LIST
76585: LIST
76586: PUSH
76587: LD_INT 1
76589: NEG
76590: PUSH
76591: LD_INT 1
76593: PUSH
76594: EMPTY
76595: LIST
76596: LIST
76597: PUSH
76598: LD_INT 2
76600: NEG
76601: PUSH
76602: LD_INT 0
76604: PUSH
76605: EMPTY
76606: LIST
76607: LIST
76608: PUSH
76609: LD_INT 2
76611: NEG
76612: PUSH
76613: LD_INT 1
76615: NEG
76616: PUSH
76617: EMPTY
76618: LIST
76619: LIST
76620: PUSH
76621: LD_INT 1
76623: NEG
76624: PUSH
76625: LD_INT 3
76627: NEG
76628: PUSH
76629: EMPTY
76630: LIST
76631: LIST
76632: PUSH
76633: LD_INT 0
76635: PUSH
76636: LD_INT 3
76638: NEG
76639: PUSH
76640: EMPTY
76641: LIST
76642: LIST
76643: PUSH
76644: LD_INT 1
76646: PUSH
76647: LD_INT 2
76649: NEG
76650: PUSH
76651: EMPTY
76652: LIST
76653: LIST
76654: PUSH
76655: LD_INT 2
76657: PUSH
76658: LD_INT 1
76660: NEG
76661: PUSH
76662: EMPTY
76663: LIST
76664: LIST
76665: PUSH
76666: LD_INT 3
76668: PUSH
76669: LD_INT 0
76671: PUSH
76672: EMPTY
76673: LIST
76674: LIST
76675: PUSH
76676: LD_INT 3
76678: PUSH
76679: LD_INT 1
76681: PUSH
76682: EMPTY
76683: LIST
76684: LIST
76685: PUSH
76686: LD_INT 1
76688: PUSH
76689: LD_INT 3
76691: PUSH
76692: EMPTY
76693: LIST
76694: LIST
76695: PUSH
76696: LD_INT 0
76698: PUSH
76699: LD_INT 3
76701: PUSH
76702: EMPTY
76703: LIST
76704: LIST
76705: PUSH
76706: LD_INT 1
76708: NEG
76709: PUSH
76710: LD_INT 2
76712: PUSH
76713: EMPTY
76714: LIST
76715: LIST
76716: PUSH
76717: LD_INT 2
76719: NEG
76720: PUSH
76721: LD_INT 1
76723: PUSH
76724: EMPTY
76725: LIST
76726: LIST
76727: PUSH
76728: LD_INT 3
76730: NEG
76731: PUSH
76732: LD_INT 0
76734: PUSH
76735: EMPTY
76736: LIST
76737: LIST
76738: PUSH
76739: LD_INT 3
76741: NEG
76742: PUSH
76743: LD_INT 1
76745: NEG
76746: PUSH
76747: EMPTY
76748: LIST
76749: LIST
76750: PUSH
76751: EMPTY
76752: LIST
76753: LIST
76754: LIST
76755: LIST
76756: LIST
76757: LIST
76758: LIST
76759: LIST
76760: LIST
76761: LIST
76762: LIST
76763: LIST
76764: LIST
76765: LIST
76766: LIST
76767: LIST
76768: LIST
76769: LIST
76770: LIST
76771: LIST
76772: LIST
76773: LIST
76774: LIST
76775: LIST
76776: LIST
76777: LIST
76778: LIST
76779: LIST
76780: LIST
76781: ST_TO_ADDR
// fControlTower0 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
76782: LD_ADDR_VAR 0 47
76786: PUSH
76787: LD_INT 0
76789: PUSH
76790: LD_INT 0
76792: PUSH
76793: EMPTY
76794: LIST
76795: LIST
76796: PUSH
76797: LD_INT 0
76799: PUSH
76800: LD_INT 1
76802: NEG
76803: PUSH
76804: EMPTY
76805: LIST
76806: LIST
76807: PUSH
76808: LD_INT 1
76810: PUSH
76811: LD_INT 0
76813: PUSH
76814: EMPTY
76815: LIST
76816: LIST
76817: PUSH
76818: LD_INT 1
76820: PUSH
76821: LD_INT 1
76823: PUSH
76824: EMPTY
76825: LIST
76826: LIST
76827: PUSH
76828: LD_INT 0
76830: PUSH
76831: LD_INT 1
76833: PUSH
76834: EMPTY
76835: LIST
76836: LIST
76837: PUSH
76838: LD_INT 1
76840: NEG
76841: PUSH
76842: LD_INT 0
76844: PUSH
76845: EMPTY
76846: LIST
76847: LIST
76848: PUSH
76849: LD_INT 1
76851: NEG
76852: PUSH
76853: LD_INT 1
76855: NEG
76856: PUSH
76857: EMPTY
76858: LIST
76859: LIST
76860: PUSH
76861: LD_INT 1
76863: NEG
76864: PUSH
76865: LD_INT 2
76867: NEG
76868: PUSH
76869: EMPTY
76870: LIST
76871: LIST
76872: PUSH
76873: LD_INT 0
76875: PUSH
76876: LD_INT 2
76878: NEG
76879: PUSH
76880: EMPTY
76881: LIST
76882: LIST
76883: PUSH
76884: LD_INT 1
76886: PUSH
76887: LD_INT 1
76889: NEG
76890: PUSH
76891: EMPTY
76892: LIST
76893: LIST
76894: PUSH
76895: LD_INT 2
76897: NEG
76898: PUSH
76899: LD_INT 1
76901: NEG
76902: PUSH
76903: EMPTY
76904: LIST
76905: LIST
76906: PUSH
76907: LD_INT 2
76909: NEG
76910: PUSH
76911: LD_INT 2
76913: NEG
76914: PUSH
76915: EMPTY
76916: LIST
76917: LIST
76918: PUSH
76919: EMPTY
76920: LIST
76921: LIST
76922: LIST
76923: LIST
76924: LIST
76925: LIST
76926: LIST
76927: LIST
76928: LIST
76929: LIST
76930: LIST
76931: LIST
76932: ST_TO_ADDR
// fControlTower1 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] ] ;
76933: LD_ADDR_VAR 0 48
76937: PUSH
76938: LD_INT 0
76940: PUSH
76941: LD_INT 0
76943: PUSH
76944: EMPTY
76945: LIST
76946: LIST
76947: PUSH
76948: LD_INT 0
76950: PUSH
76951: LD_INT 1
76953: NEG
76954: PUSH
76955: EMPTY
76956: LIST
76957: LIST
76958: PUSH
76959: LD_INT 1
76961: PUSH
76962: LD_INT 0
76964: PUSH
76965: EMPTY
76966: LIST
76967: LIST
76968: PUSH
76969: LD_INT 1
76971: PUSH
76972: LD_INT 1
76974: PUSH
76975: EMPTY
76976: LIST
76977: LIST
76978: PUSH
76979: LD_INT 0
76981: PUSH
76982: LD_INT 1
76984: PUSH
76985: EMPTY
76986: LIST
76987: LIST
76988: PUSH
76989: LD_INT 1
76991: NEG
76992: PUSH
76993: LD_INT 0
76995: PUSH
76996: EMPTY
76997: LIST
76998: LIST
76999: PUSH
77000: LD_INT 1
77002: NEG
77003: PUSH
77004: LD_INT 1
77006: NEG
77007: PUSH
77008: EMPTY
77009: LIST
77010: LIST
77011: PUSH
77012: LD_INT 1
77014: NEG
77015: PUSH
77016: LD_INT 2
77018: NEG
77019: PUSH
77020: EMPTY
77021: LIST
77022: LIST
77023: PUSH
77024: LD_INT 0
77026: PUSH
77027: LD_INT 2
77029: NEG
77030: PUSH
77031: EMPTY
77032: LIST
77033: LIST
77034: PUSH
77035: LD_INT 1
77037: PUSH
77038: LD_INT 1
77040: NEG
77041: PUSH
77042: EMPTY
77043: LIST
77044: LIST
77045: PUSH
77046: LD_INT 2
77048: PUSH
77049: LD_INT 0
77051: PUSH
77052: EMPTY
77053: LIST
77054: LIST
77055: PUSH
77056: LD_INT 2
77058: PUSH
77059: LD_INT 1
77061: PUSH
77062: EMPTY
77063: LIST
77064: LIST
77065: PUSH
77066: EMPTY
77067: LIST
77068: LIST
77069: LIST
77070: LIST
77071: LIST
77072: LIST
77073: LIST
77074: LIST
77075: LIST
77076: LIST
77077: LIST
77078: LIST
77079: ST_TO_ADDR
// fControlTower2 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] ] ;
77080: LD_ADDR_VAR 0 49
77084: PUSH
77085: LD_INT 0
77087: PUSH
77088: LD_INT 0
77090: PUSH
77091: EMPTY
77092: LIST
77093: LIST
77094: PUSH
77095: LD_INT 0
77097: PUSH
77098: LD_INT 1
77100: NEG
77101: PUSH
77102: EMPTY
77103: LIST
77104: LIST
77105: PUSH
77106: LD_INT 1
77108: PUSH
77109: LD_INT 0
77111: PUSH
77112: EMPTY
77113: LIST
77114: LIST
77115: PUSH
77116: LD_INT 1
77118: PUSH
77119: LD_INT 1
77121: PUSH
77122: EMPTY
77123: LIST
77124: LIST
77125: PUSH
77126: LD_INT 0
77128: PUSH
77129: LD_INT 1
77131: PUSH
77132: EMPTY
77133: LIST
77134: LIST
77135: PUSH
77136: LD_INT 1
77138: NEG
77139: PUSH
77140: LD_INT 0
77142: PUSH
77143: EMPTY
77144: LIST
77145: LIST
77146: PUSH
77147: LD_INT 1
77149: NEG
77150: PUSH
77151: LD_INT 1
77153: NEG
77154: PUSH
77155: EMPTY
77156: LIST
77157: LIST
77158: PUSH
77159: LD_INT 1
77161: PUSH
77162: LD_INT 1
77164: NEG
77165: PUSH
77166: EMPTY
77167: LIST
77168: LIST
77169: PUSH
77170: LD_INT 2
77172: PUSH
77173: LD_INT 0
77175: PUSH
77176: EMPTY
77177: LIST
77178: LIST
77179: PUSH
77180: LD_INT 2
77182: PUSH
77183: LD_INT 1
77185: PUSH
77186: EMPTY
77187: LIST
77188: LIST
77189: PUSH
77190: LD_INT 2
77192: PUSH
77193: LD_INT 2
77195: PUSH
77196: EMPTY
77197: LIST
77198: LIST
77199: PUSH
77200: LD_INT 1
77202: PUSH
77203: LD_INT 2
77205: PUSH
77206: EMPTY
77207: LIST
77208: LIST
77209: PUSH
77210: EMPTY
77211: LIST
77212: LIST
77213: LIST
77214: LIST
77215: LIST
77216: LIST
77217: LIST
77218: LIST
77219: LIST
77220: LIST
77221: LIST
77222: LIST
77223: ST_TO_ADDR
// fControlTower3 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] ] ;
77224: LD_ADDR_VAR 0 50
77228: PUSH
77229: LD_INT 0
77231: PUSH
77232: LD_INT 0
77234: PUSH
77235: EMPTY
77236: LIST
77237: LIST
77238: PUSH
77239: LD_INT 0
77241: PUSH
77242: LD_INT 1
77244: NEG
77245: PUSH
77246: EMPTY
77247: LIST
77248: LIST
77249: PUSH
77250: LD_INT 1
77252: PUSH
77253: LD_INT 0
77255: PUSH
77256: EMPTY
77257: LIST
77258: LIST
77259: PUSH
77260: LD_INT 1
77262: PUSH
77263: LD_INT 1
77265: PUSH
77266: EMPTY
77267: LIST
77268: LIST
77269: PUSH
77270: LD_INT 0
77272: PUSH
77273: LD_INT 1
77275: PUSH
77276: EMPTY
77277: LIST
77278: LIST
77279: PUSH
77280: LD_INT 1
77282: NEG
77283: PUSH
77284: LD_INT 0
77286: PUSH
77287: EMPTY
77288: LIST
77289: LIST
77290: PUSH
77291: LD_INT 1
77293: NEG
77294: PUSH
77295: LD_INT 1
77297: NEG
77298: PUSH
77299: EMPTY
77300: LIST
77301: LIST
77302: PUSH
77303: LD_INT 2
77305: PUSH
77306: LD_INT 1
77308: PUSH
77309: EMPTY
77310: LIST
77311: LIST
77312: PUSH
77313: LD_INT 2
77315: PUSH
77316: LD_INT 2
77318: PUSH
77319: EMPTY
77320: LIST
77321: LIST
77322: PUSH
77323: LD_INT 1
77325: PUSH
77326: LD_INT 2
77328: PUSH
77329: EMPTY
77330: LIST
77331: LIST
77332: PUSH
77333: LD_INT 0
77335: PUSH
77336: LD_INT 2
77338: PUSH
77339: EMPTY
77340: LIST
77341: LIST
77342: PUSH
77343: LD_INT 1
77345: NEG
77346: PUSH
77347: LD_INT 1
77349: PUSH
77350: EMPTY
77351: LIST
77352: LIST
77353: PUSH
77354: EMPTY
77355: LIST
77356: LIST
77357: LIST
77358: LIST
77359: LIST
77360: LIST
77361: LIST
77362: LIST
77363: LIST
77364: LIST
77365: LIST
77366: LIST
77367: ST_TO_ADDR
// fControlTower4 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] ] ;
77368: LD_ADDR_VAR 0 51
77372: PUSH
77373: LD_INT 0
77375: PUSH
77376: LD_INT 0
77378: PUSH
77379: EMPTY
77380: LIST
77381: LIST
77382: PUSH
77383: LD_INT 0
77385: PUSH
77386: LD_INT 1
77388: NEG
77389: PUSH
77390: EMPTY
77391: LIST
77392: LIST
77393: PUSH
77394: LD_INT 1
77396: PUSH
77397: LD_INT 0
77399: PUSH
77400: EMPTY
77401: LIST
77402: LIST
77403: PUSH
77404: LD_INT 1
77406: PUSH
77407: LD_INT 1
77409: PUSH
77410: EMPTY
77411: LIST
77412: LIST
77413: PUSH
77414: LD_INT 0
77416: PUSH
77417: LD_INT 1
77419: PUSH
77420: EMPTY
77421: LIST
77422: LIST
77423: PUSH
77424: LD_INT 1
77426: NEG
77427: PUSH
77428: LD_INT 0
77430: PUSH
77431: EMPTY
77432: LIST
77433: LIST
77434: PUSH
77435: LD_INT 1
77437: NEG
77438: PUSH
77439: LD_INT 1
77441: NEG
77442: PUSH
77443: EMPTY
77444: LIST
77445: LIST
77446: PUSH
77447: LD_INT 1
77449: PUSH
77450: LD_INT 2
77452: PUSH
77453: EMPTY
77454: LIST
77455: LIST
77456: PUSH
77457: LD_INT 0
77459: PUSH
77460: LD_INT 2
77462: PUSH
77463: EMPTY
77464: LIST
77465: LIST
77466: PUSH
77467: LD_INT 1
77469: NEG
77470: PUSH
77471: LD_INT 1
77473: PUSH
77474: EMPTY
77475: LIST
77476: LIST
77477: PUSH
77478: LD_INT 2
77480: NEG
77481: PUSH
77482: LD_INT 0
77484: PUSH
77485: EMPTY
77486: LIST
77487: LIST
77488: PUSH
77489: LD_INT 2
77491: NEG
77492: PUSH
77493: LD_INT 1
77495: NEG
77496: PUSH
77497: EMPTY
77498: LIST
77499: LIST
77500: PUSH
77501: EMPTY
77502: LIST
77503: LIST
77504: LIST
77505: LIST
77506: LIST
77507: LIST
77508: LIST
77509: LIST
77510: LIST
77511: LIST
77512: LIST
77513: LIST
77514: ST_TO_ADDR
// fControlTower5 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
77515: LD_ADDR_VAR 0 52
77519: PUSH
77520: LD_INT 0
77522: PUSH
77523: LD_INT 0
77525: PUSH
77526: EMPTY
77527: LIST
77528: LIST
77529: PUSH
77530: LD_INT 0
77532: PUSH
77533: LD_INT 1
77535: NEG
77536: PUSH
77537: EMPTY
77538: LIST
77539: LIST
77540: PUSH
77541: LD_INT 1
77543: PUSH
77544: LD_INT 0
77546: PUSH
77547: EMPTY
77548: LIST
77549: LIST
77550: PUSH
77551: LD_INT 1
77553: PUSH
77554: LD_INT 1
77556: PUSH
77557: EMPTY
77558: LIST
77559: LIST
77560: PUSH
77561: LD_INT 0
77563: PUSH
77564: LD_INT 1
77566: PUSH
77567: EMPTY
77568: LIST
77569: LIST
77570: PUSH
77571: LD_INT 1
77573: NEG
77574: PUSH
77575: LD_INT 0
77577: PUSH
77578: EMPTY
77579: LIST
77580: LIST
77581: PUSH
77582: LD_INT 1
77584: NEG
77585: PUSH
77586: LD_INT 1
77588: NEG
77589: PUSH
77590: EMPTY
77591: LIST
77592: LIST
77593: PUSH
77594: LD_INT 1
77596: NEG
77597: PUSH
77598: LD_INT 2
77600: NEG
77601: PUSH
77602: EMPTY
77603: LIST
77604: LIST
77605: PUSH
77606: LD_INT 1
77608: NEG
77609: PUSH
77610: LD_INT 1
77612: PUSH
77613: EMPTY
77614: LIST
77615: LIST
77616: PUSH
77617: LD_INT 2
77619: NEG
77620: PUSH
77621: LD_INT 0
77623: PUSH
77624: EMPTY
77625: LIST
77626: LIST
77627: PUSH
77628: LD_INT 2
77630: NEG
77631: PUSH
77632: LD_INT 1
77634: NEG
77635: PUSH
77636: EMPTY
77637: LIST
77638: LIST
77639: PUSH
77640: LD_INT 2
77642: NEG
77643: PUSH
77644: LD_INT 2
77646: NEG
77647: PUSH
77648: EMPTY
77649: LIST
77650: LIST
77651: PUSH
77652: EMPTY
77653: LIST
77654: LIST
77655: LIST
77656: LIST
77657: LIST
77658: LIST
77659: LIST
77660: LIST
77661: LIST
77662: LIST
77663: LIST
77664: LIST
77665: ST_TO_ADDR
// fBarracks0 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
77666: LD_ADDR_VAR 0 53
77670: PUSH
77671: LD_INT 0
77673: PUSH
77674: LD_INT 0
77676: PUSH
77677: EMPTY
77678: LIST
77679: LIST
77680: PUSH
77681: LD_INT 0
77683: PUSH
77684: LD_INT 1
77686: NEG
77687: PUSH
77688: EMPTY
77689: LIST
77690: LIST
77691: PUSH
77692: LD_INT 1
77694: PUSH
77695: LD_INT 0
77697: PUSH
77698: EMPTY
77699: LIST
77700: LIST
77701: PUSH
77702: LD_INT 1
77704: PUSH
77705: LD_INT 1
77707: PUSH
77708: EMPTY
77709: LIST
77710: LIST
77711: PUSH
77712: LD_INT 0
77714: PUSH
77715: LD_INT 1
77717: PUSH
77718: EMPTY
77719: LIST
77720: LIST
77721: PUSH
77722: LD_INT 1
77724: NEG
77725: PUSH
77726: LD_INT 0
77728: PUSH
77729: EMPTY
77730: LIST
77731: LIST
77732: PUSH
77733: LD_INT 1
77735: NEG
77736: PUSH
77737: LD_INT 1
77739: NEG
77740: PUSH
77741: EMPTY
77742: LIST
77743: LIST
77744: PUSH
77745: LD_INT 1
77747: NEG
77748: PUSH
77749: LD_INT 2
77751: NEG
77752: PUSH
77753: EMPTY
77754: LIST
77755: LIST
77756: PUSH
77757: LD_INT 0
77759: PUSH
77760: LD_INT 2
77762: NEG
77763: PUSH
77764: EMPTY
77765: LIST
77766: LIST
77767: PUSH
77768: LD_INT 1
77770: PUSH
77771: LD_INT 1
77773: NEG
77774: PUSH
77775: EMPTY
77776: LIST
77777: LIST
77778: PUSH
77779: LD_INT 2
77781: PUSH
77782: LD_INT 0
77784: PUSH
77785: EMPTY
77786: LIST
77787: LIST
77788: PUSH
77789: LD_INT 2
77791: PUSH
77792: LD_INT 1
77794: PUSH
77795: EMPTY
77796: LIST
77797: LIST
77798: PUSH
77799: LD_INT 2
77801: PUSH
77802: LD_INT 2
77804: PUSH
77805: EMPTY
77806: LIST
77807: LIST
77808: PUSH
77809: LD_INT 1
77811: PUSH
77812: LD_INT 2
77814: PUSH
77815: EMPTY
77816: LIST
77817: LIST
77818: PUSH
77819: LD_INT 0
77821: PUSH
77822: LD_INT 2
77824: PUSH
77825: EMPTY
77826: LIST
77827: LIST
77828: PUSH
77829: LD_INT 1
77831: NEG
77832: PUSH
77833: LD_INT 1
77835: PUSH
77836: EMPTY
77837: LIST
77838: LIST
77839: PUSH
77840: LD_INT 2
77842: NEG
77843: PUSH
77844: LD_INT 0
77846: PUSH
77847: EMPTY
77848: LIST
77849: LIST
77850: PUSH
77851: LD_INT 2
77853: NEG
77854: PUSH
77855: LD_INT 1
77857: NEG
77858: PUSH
77859: EMPTY
77860: LIST
77861: LIST
77862: PUSH
77863: LD_INT 2
77865: NEG
77866: PUSH
77867: LD_INT 2
77869: NEG
77870: PUSH
77871: EMPTY
77872: LIST
77873: LIST
77874: PUSH
77875: EMPTY
77876: LIST
77877: LIST
77878: LIST
77879: LIST
77880: LIST
77881: LIST
77882: LIST
77883: LIST
77884: LIST
77885: LIST
77886: LIST
77887: LIST
77888: LIST
77889: LIST
77890: LIST
77891: LIST
77892: LIST
77893: LIST
77894: LIST
77895: ST_TO_ADDR
// fBarracks1 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
77896: LD_ADDR_VAR 0 54
77900: PUSH
77901: LD_INT 0
77903: PUSH
77904: LD_INT 0
77906: PUSH
77907: EMPTY
77908: LIST
77909: LIST
77910: PUSH
77911: LD_INT 0
77913: PUSH
77914: LD_INT 1
77916: NEG
77917: PUSH
77918: EMPTY
77919: LIST
77920: LIST
77921: PUSH
77922: LD_INT 1
77924: PUSH
77925: LD_INT 0
77927: PUSH
77928: EMPTY
77929: LIST
77930: LIST
77931: PUSH
77932: LD_INT 1
77934: PUSH
77935: LD_INT 1
77937: PUSH
77938: EMPTY
77939: LIST
77940: LIST
77941: PUSH
77942: LD_INT 0
77944: PUSH
77945: LD_INT 1
77947: PUSH
77948: EMPTY
77949: LIST
77950: LIST
77951: PUSH
77952: LD_INT 1
77954: NEG
77955: PUSH
77956: LD_INT 0
77958: PUSH
77959: EMPTY
77960: LIST
77961: LIST
77962: PUSH
77963: LD_INT 1
77965: NEG
77966: PUSH
77967: LD_INT 1
77969: NEG
77970: PUSH
77971: EMPTY
77972: LIST
77973: LIST
77974: PUSH
77975: LD_INT 1
77977: NEG
77978: PUSH
77979: LD_INT 2
77981: NEG
77982: PUSH
77983: EMPTY
77984: LIST
77985: LIST
77986: PUSH
77987: LD_INT 0
77989: PUSH
77990: LD_INT 2
77992: NEG
77993: PUSH
77994: EMPTY
77995: LIST
77996: LIST
77997: PUSH
77998: LD_INT 1
78000: PUSH
78001: LD_INT 1
78003: NEG
78004: PUSH
78005: EMPTY
78006: LIST
78007: LIST
78008: PUSH
78009: LD_INT 2
78011: PUSH
78012: LD_INT 0
78014: PUSH
78015: EMPTY
78016: LIST
78017: LIST
78018: PUSH
78019: LD_INT 2
78021: PUSH
78022: LD_INT 1
78024: PUSH
78025: EMPTY
78026: LIST
78027: LIST
78028: PUSH
78029: LD_INT 2
78031: PUSH
78032: LD_INT 2
78034: PUSH
78035: EMPTY
78036: LIST
78037: LIST
78038: PUSH
78039: LD_INT 1
78041: PUSH
78042: LD_INT 2
78044: PUSH
78045: EMPTY
78046: LIST
78047: LIST
78048: PUSH
78049: LD_INT 0
78051: PUSH
78052: LD_INT 2
78054: PUSH
78055: EMPTY
78056: LIST
78057: LIST
78058: PUSH
78059: LD_INT 1
78061: NEG
78062: PUSH
78063: LD_INT 1
78065: PUSH
78066: EMPTY
78067: LIST
78068: LIST
78069: PUSH
78070: LD_INT 2
78072: NEG
78073: PUSH
78074: LD_INT 0
78076: PUSH
78077: EMPTY
78078: LIST
78079: LIST
78080: PUSH
78081: LD_INT 2
78083: NEG
78084: PUSH
78085: LD_INT 1
78087: NEG
78088: PUSH
78089: EMPTY
78090: LIST
78091: LIST
78092: PUSH
78093: LD_INT 2
78095: NEG
78096: PUSH
78097: LD_INT 2
78099: NEG
78100: PUSH
78101: EMPTY
78102: LIST
78103: LIST
78104: PUSH
78105: EMPTY
78106: LIST
78107: LIST
78108: LIST
78109: LIST
78110: LIST
78111: LIST
78112: LIST
78113: LIST
78114: LIST
78115: LIST
78116: LIST
78117: LIST
78118: LIST
78119: LIST
78120: LIST
78121: LIST
78122: LIST
78123: LIST
78124: LIST
78125: ST_TO_ADDR
// fBarracks2 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
78126: LD_ADDR_VAR 0 55
78130: PUSH
78131: LD_INT 0
78133: PUSH
78134: LD_INT 0
78136: PUSH
78137: EMPTY
78138: LIST
78139: LIST
78140: PUSH
78141: LD_INT 0
78143: PUSH
78144: LD_INT 1
78146: NEG
78147: PUSH
78148: EMPTY
78149: LIST
78150: LIST
78151: PUSH
78152: LD_INT 1
78154: PUSH
78155: LD_INT 0
78157: PUSH
78158: EMPTY
78159: LIST
78160: LIST
78161: PUSH
78162: LD_INT 1
78164: PUSH
78165: LD_INT 1
78167: PUSH
78168: EMPTY
78169: LIST
78170: LIST
78171: PUSH
78172: LD_INT 0
78174: PUSH
78175: LD_INT 1
78177: PUSH
78178: EMPTY
78179: LIST
78180: LIST
78181: PUSH
78182: LD_INT 1
78184: NEG
78185: PUSH
78186: LD_INT 0
78188: PUSH
78189: EMPTY
78190: LIST
78191: LIST
78192: PUSH
78193: LD_INT 1
78195: NEG
78196: PUSH
78197: LD_INT 1
78199: NEG
78200: PUSH
78201: EMPTY
78202: LIST
78203: LIST
78204: PUSH
78205: LD_INT 1
78207: NEG
78208: PUSH
78209: LD_INT 2
78211: NEG
78212: PUSH
78213: EMPTY
78214: LIST
78215: LIST
78216: PUSH
78217: LD_INT 0
78219: PUSH
78220: LD_INT 2
78222: NEG
78223: PUSH
78224: EMPTY
78225: LIST
78226: LIST
78227: PUSH
78228: LD_INT 1
78230: PUSH
78231: LD_INT 1
78233: NEG
78234: PUSH
78235: EMPTY
78236: LIST
78237: LIST
78238: PUSH
78239: LD_INT 2
78241: PUSH
78242: LD_INT 0
78244: PUSH
78245: EMPTY
78246: LIST
78247: LIST
78248: PUSH
78249: LD_INT 2
78251: PUSH
78252: LD_INT 1
78254: PUSH
78255: EMPTY
78256: LIST
78257: LIST
78258: PUSH
78259: LD_INT 2
78261: PUSH
78262: LD_INT 2
78264: PUSH
78265: EMPTY
78266: LIST
78267: LIST
78268: PUSH
78269: LD_INT 1
78271: PUSH
78272: LD_INT 2
78274: PUSH
78275: EMPTY
78276: LIST
78277: LIST
78278: PUSH
78279: LD_INT 0
78281: PUSH
78282: LD_INT 2
78284: PUSH
78285: EMPTY
78286: LIST
78287: LIST
78288: PUSH
78289: LD_INT 1
78291: NEG
78292: PUSH
78293: LD_INT 1
78295: PUSH
78296: EMPTY
78297: LIST
78298: LIST
78299: PUSH
78300: LD_INT 2
78302: NEG
78303: PUSH
78304: LD_INT 0
78306: PUSH
78307: EMPTY
78308: LIST
78309: LIST
78310: PUSH
78311: LD_INT 2
78313: NEG
78314: PUSH
78315: LD_INT 1
78317: NEG
78318: PUSH
78319: EMPTY
78320: LIST
78321: LIST
78322: PUSH
78323: LD_INT 2
78325: NEG
78326: PUSH
78327: LD_INT 2
78329: NEG
78330: PUSH
78331: EMPTY
78332: LIST
78333: LIST
78334: PUSH
78335: EMPTY
78336: LIST
78337: LIST
78338: LIST
78339: LIST
78340: LIST
78341: LIST
78342: LIST
78343: LIST
78344: LIST
78345: LIST
78346: LIST
78347: LIST
78348: LIST
78349: LIST
78350: LIST
78351: LIST
78352: LIST
78353: LIST
78354: LIST
78355: ST_TO_ADDR
// fBarracks3 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
78356: LD_ADDR_VAR 0 56
78360: PUSH
78361: LD_INT 0
78363: PUSH
78364: LD_INT 0
78366: PUSH
78367: EMPTY
78368: LIST
78369: LIST
78370: PUSH
78371: LD_INT 0
78373: PUSH
78374: LD_INT 1
78376: NEG
78377: PUSH
78378: EMPTY
78379: LIST
78380: LIST
78381: PUSH
78382: LD_INT 1
78384: PUSH
78385: LD_INT 0
78387: PUSH
78388: EMPTY
78389: LIST
78390: LIST
78391: PUSH
78392: LD_INT 1
78394: PUSH
78395: LD_INT 1
78397: PUSH
78398: EMPTY
78399: LIST
78400: LIST
78401: PUSH
78402: LD_INT 0
78404: PUSH
78405: LD_INT 1
78407: PUSH
78408: EMPTY
78409: LIST
78410: LIST
78411: PUSH
78412: LD_INT 1
78414: NEG
78415: PUSH
78416: LD_INT 0
78418: PUSH
78419: EMPTY
78420: LIST
78421: LIST
78422: PUSH
78423: LD_INT 1
78425: NEG
78426: PUSH
78427: LD_INT 1
78429: NEG
78430: PUSH
78431: EMPTY
78432: LIST
78433: LIST
78434: PUSH
78435: LD_INT 1
78437: NEG
78438: PUSH
78439: LD_INT 2
78441: NEG
78442: PUSH
78443: EMPTY
78444: LIST
78445: LIST
78446: PUSH
78447: LD_INT 0
78449: PUSH
78450: LD_INT 2
78452: NEG
78453: PUSH
78454: EMPTY
78455: LIST
78456: LIST
78457: PUSH
78458: LD_INT 1
78460: PUSH
78461: LD_INT 1
78463: NEG
78464: PUSH
78465: EMPTY
78466: LIST
78467: LIST
78468: PUSH
78469: LD_INT 2
78471: PUSH
78472: LD_INT 0
78474: PUSH
78475: EMPTY
78476: LIST
78477: LIST
78478: PUSH
78479: LD_INT 2
78481: PUSH
78482: LD_INT 1
78484: PUSH
78485: EMPTY
78486: LIST
78487: LIST
78488: PUSH
78489: LD_INT 2
78491: PUSH
78492: LD_INT 2
78494: PUSH
78495: EMPTY
78496: LIST
78497: LIST
78498: PUSH
78499: LD_INT 1
78501: PUSH
78502: LD_INT 2
78504: PUSH
78505: EMPTY
78506: LIST
78507: LIST
78508: PUSH
78509: LD_INT 0
78511: PUSH
78512: LD_INT 2
78514: PUSH
78515: EMPTY
78516: LIST
78517: LIST
78518: PUSH
78519: LD_INT 1
78521: NEG
78522: PUSH
78523: LD_INT 1
78525: PUSH
78526: EMPTY
78527: LIST
78528: LIST
78529: PUSH
78530: LD_INT 2
78532: NEG
78533: PUSH
78534: LD_INT 0
78536: PUSH
78537: EMPTY
78538: LIST
78539: LIST
78540: PUSH
78541: LD_INT 2
78543: NEG
78544: PUSH
78545: LD_INT 1
78547: NEG
78548: PUSH
78549: EMPTY
78550: LIST
78551: LIST
78552: PUSH
78553: LD_INT 2
78555: NEG
78556: PUSH
78557: LD_INT 2
78559: NEG
78560: PUSH
78561: EMPTY
78562: LIST
78563: LIST
78564: PUSH
78565: EMPTY
78566: LIST
78567: LIST
78568: LIST
78569: LIST
78570: LIST
78571: LIST
78572: LIST
78573: LIST
78574: LIST
78575: LIST
78576: LIST
78577: LIST
78578: LIST
78579: LIST
78580: LIST
78581: LIST
78582: LIST
78583: LIST
78584: LIST
78585: ST_TO_ADDR
// fBarracks4 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
78586: LD_ADDR_VAR 0 57
78590: PUSH
78591: LD_INT 0
78593: PUSH
78594: LD_INT 0
78596: PUSH
78597: EMPTY
78598: LIST
78599: LIST
78600: PUSH
78601: LD_INT 0
78603: PUSH
78604: LD_INT 1
78606: NEG
78607: PUSH
78608: EMPTY
78609: LIST
78610: LIST
78611: PUSH
78612: LD_INT 1
78614: PUSH
78615: LD_INT 0
78617: PUSH
78618: EMPTY
78619: LIST
78620: LIST
78621: PUSH
78622: LD_INT 1
78624: PUSH
78625: LD_INT 1
78627: PUSH
78628: EMPTY
78629: LIST
78630: LIST
78631: PUSH
78632: LD_INT 0
78634: PUSH
78635: LD_INT 1
78637: PUSH
78638: EMPTY
78639: LIST
78640: LIST
78641: PUSH
78642: LD_INT 1
78644: NEG
78645: PUSH
78646: LD_INT 0
78648: PUSH
78649: EMPTY
78650: LIST
78651: LIST
78652: PUSH
78653: LD_INT 1
78655: NEG
78656: PUSH
78657: LD_INT 1
78659: NEG
78660: PUSH
78661: EMPTY
78662: LIST
78663: LIST
78664: PUSH
78665: LD_INT 1
78667: NEG
78668: PUSH
78669: LD_INT 2
78671: NEG
78672: PUSH
78673: EMPTY
78674: LIST
78675: LIST
78676: PUSH
78677: LD_INT 0
78679: PUSH
78680: LD_INT 2
78682: NEG
78683: PUSH
78684: EMPTY
78685: LIST
78686: LIST
78687: PUSH
78688: LD_INT 1
78690: PUSH
78691: LD_INT 1
78693: NEG
78694: PUSH
78695: EMPTY
78696: LIST
78697: LIST
78698: PUSH
78699: LD_INT 2
78701: PUSH
78702: LD_INT 0
78704: PUSH
78705: EMPTY
78706: LIST
78707: LIST
78708: PUSH
78709: LD_INT 2
78711: PUSH
78712: LD_INT 1
78714: PUSH
78715: EMPTY
78716: LIST
78717: LIST
78718: PUSH
78719: LD_INT 2
78721: PUSH
78722: LD_INT 2
78724: PUSH
78725: EMPTY
78726: LIST
78727: LIST
78728: PUSH
78729: LD_INT 1
78731: PUSH
78732: LD_INT 2
78734: PUSH
78735: EMPTY
78736: LIST
78737: LIST
78738: PUSH
78739: LD_INT 0
78741: PUSH
78742: LD_INT 2
78744: PUSH
78745: EMPTY
78746: LIST
78747: LIST
78748: PUSH
78749: LD_INT 1
78751: NEG
78752: PUSH
78753: LD_INT 1
78755: PUSH
78756: EMPTY
78757: LIST
78758: LIST
78759: PUSH
78760: LD_INT 2
78762: NEG
78763: PUSH
78764: LD_INT 0
78766: PUSH
78767: EMPTY
78768: LIST
78769: LIST
78770: PUSH
78771: LD_INT 2
78773: NEG
78774: PUSH
78775: LD_INT 1
78777: NEG
78778: PUSH
78779: EMPTY
78780: LIST
78781: LIST
78782: PUSH
78783: LD_INT 2
78785: NEG
78786: PUSH
78787: LD_INT 2
78789: NEG
78790: PUSH
78791: EMPTY
78792: LIST
78793: LIST
78794: PUSH
78795: EMPTY
78796: LIST
78797: LIST
78798: LIST
78799: LIST
78800: LIST
78801: LIST
78802: LIST
78803: LIST
78804: LIST
78805: LIST
78806: LIST
78807: LIST
78808: LIST
78809: LIST
78810: LIST
78811: LIST
78812: LIST
78813: LIST
78814: LIST
78815: ST_TO_ADDR
// fBarracks5 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
78816: LD_ADDR_VAR 0 58
78820: PUSH
78821: LD_INT 0
78823: PUSH
78824: LD_INT 0
78826: PUSH
78827: EMPTY
78828: LIST
78829: LIST
78830: PUSH
78831: LD_INT 0
78833: PUSH
78834: LD_INT 1
78836: NEG
78837: PUSH
78838: EMPTY
78839: LIST
78840: LIST
78841: PUSH
78842: LD_INT 1
78844: PUSH
78845: LD_INT 0
78847: PUSH
78848: EMPTY
78849: LIST
78850: LIST
78851: PUSH
78852: LD_INT 1
78854: PUSH
78855: LD_INT 1
78857: PUSH
78858: EMPTY
78859: LIST
78860: LIST
78861: PUSH
78862: LD_INT 0
78864: PUSH
78865: LD_INT 1
78867: PUSH
78868: EMPTY
78869: LIST
78870: LIST
78871: PUSH
78872: LD_INT 1
78874: NEG
78875: PUSH
78876: LD_INT 0
78878: PUSH
78879: EMPTY
78880: LIST
78881: LIST
78882: PUSH
78883: LD_INT 1
78885: NEG
78886: PUSH
78887: LD_INT 1
78889: NEG
78890: PUSH
78891: EMPTY
78892: LIST
78893: LIST
78894: PUSH
78895: LD_INT 1
78897: NEG
78898: PUSH
78899: LD_INT 2
78901: NEG
78902: PUSH
78903: EMPTY
78904: LIST
78905: LIST
78906: PUSH
78907: LD_INT 0
78909: PUSH
78910: LD_INT 2
78912: NEG
78913: PUSH
78914: EMPTY
78915: LIST
78916: LIST
78917: PUSH
78918: LD_INT 1
78920: PUSH
78921: LD_INT 1
78923: NEG
78924: PUSH
78925: EMPTY
78926: LIST
78927: LIST
78928: PUSH
78929: LD_INT 2
78931: PUSH
78932: LD_INT 0
78934: PUSH
78935: EMPTY
78936: LIST
78937: LIST
78938: PUSH
78939: LD_INT 2
78941: PUSH
78942: LD_INT 1
78944: PUSH
78945: EMPTY
78946: LIST
78947: LIST
78948: PUSH
78949: LD_INT 2
78951: PUSH
78952: LD_INT 2
78954: PUSH
78955: EMPTY
78956: LIST
78957: LIST
78958: PUSH
78959: LD_INT 1
78961: PUSH
78962: LD_INT 2
78964: PUSH
78965: EMPTY
78966: LIST
78967: LIST
78968: PUSH
78969: LD_INT 0
78971: PUSH
78972: LD_INT 2
78974: PUSH
78975: EMPTY
78976: LIST
78977: LIST
78978: PUSH
78979: LD_INT 1
78981: NEG
78982: PUSH
78983: LD_INT 1
78985: PUSH
78986: EMPTY
78987: LIST
78988: LIST
78989: PUSH
78990: LD_INT 2
78992: NEG
78993: PUSH
78994: LD_INT 0
78996: PUSH
78997: EMPTY
78998: LIST
78999: LIST
79000: PUSH
79001: LD_INT 2
79003: NEG
79004: PUSH
79005: LD_INT 1
79007: NEG
79008: PUSH
79009: EMPTY
79010: LIST
79011: LIST
79012: PUSH
79013: LD_INT 2
79015: NEG
79016: PUSH
79017: LD_INT 2
79019: NEG
79020: PUSH
79021: EMPTY
79022: LIST
79023: LIST
79024: PUSH
79025: EMPTY
79026: LIST
79027: LIST
79028: LIST
79029: LIST
79030: LIST
79031: LIST
79032: LIST
79033: LIST
79034: LIST
79035: LIST
79036: LIST
79037: LIST
79038: LIST
79039: LIST
79040: LIST
79041: LIST
79042: LIST
79043: LIST
79044: LIST
79045: ST_TO_ADDR
// fBunker0 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] ] ;
79046: LD_ADDR_VAR 0 59
79050: PUSH
79051: LD_INT 0
79053: PUSH
79054: LD_INT 0
79056: PUSH
79057: EMPTY
79058: LIST
79059: LIST
79060: PUSH
79061: LD_INT 0
79063: PUSH
79064: LD_INT 1
79066: NEG
79067: PUSH
79068: EMPTY
79069: LIST
79070: LIST
79071: PUSH
79072: LD_INT 1
79074: PUSH
79075: LD_INT 0
79077: PUSH
79078: EMPTY
79079: LIST
79080: LIST
79081: PUSH
79082: LD_INT 1
79084: PUSH
79085: LD_INT 1
79087: PUSH
79088: EMPTY
79089: LIST
79090: LIST
79091: PUSH
79092: LD_INT 0
79094: PUSH
79095: LD_INT 1
79097: PUSH
79098: EMPTY
79099: LIST
79100: LIST
79101: PUSH
79102: LD_INT 1
79104: NEG
79105: PUSH
79106: LD_INT 0
79108: PUSH
79109: EMPTY
79110: LIST
79111: LIST
79112: PUSH
79113: LD_INT 1
79115: NEG
79116: PUSH
79117: LD_INT 1
79119: NEG
79120: PUSH
79121: EMPTY
79122: LIST
79123: LIST
79124: PUSH
79125: EMPTY
79126: LIST
79127: LIST
79128: LIST
79129: LIST
79130: LIST
79131: LIST
79132: LIST
79133: ST_TO_ADDR
// fBunker1 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] ] ;
79134: LD_ADDR_VAR 0 60
79138: PUSH
79139: LD_INT 0
79141: PUSH
79142: LD_INT 0
79144: PUSH
79145: EMPTY
79146: LIST
79147: LIST
79148: PUSH
79149: LD_INT 0
79151: PUSH
79152: LD_INT 1
79154: NEG
79155: PUSH
79156: EMPTY
79157: LIST
79158: LIST
79159: PUSH
79160: LD_INT 1
79162: PUSH
79163: LD_INT 0
79165: PUSH
79166: EMPTY
79167: LIST
79168: LIST
79169: PUSH
79170: LD_INT 1
79172: PUSH
79173: LD_INT 1
79175: PUSH
79176: EMPTY
79177: LIST
79178: LIST
79179: PUSH
79180: LD_INT 0
79182: PUSH
79183: LD_INT 1
79185: PUSH
79186: EMPTY
79187: LIST
79188: LIST
79189: PUSH
79190: LD_INT 1
79192: NEG
79193: PUSH
79194: LD_INT 0
79196: PUSH
79197: EMPTY
79198: LIST
79199: LIST
79200: PUSH
79201: LD_INT 1
79203: NEG
79204: PUSH
79205: LD_INT 1
79207: NEG
79208: PUSH
79209: EMPTY
79210: LIST
79211: LIST
79212: PUSH
79213: EMPTY
79214: LIST
79215: LIST
79216: LIST
79217: LIST
79218: LIST
79219: LIST
79220: LIST
79221: ST_TO_ADDR
// fBunker2 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] ] ;
79222: LD_ADDR_VAR 0 61
79226: PUSH
79227: LD_INT 0
79229: PUSH
79230: LD_INT 0
79232: PUSH
79233: EMPTY
79234: LIST
79235: LIST
79236: PUSH
79237: LD_INT 0
79239: PUSH
79240: LD_INT 1
79242: NEG
79243: PUSH
79244: EMPTY
79245: LIST
79246: LIST
79247: PUSH
79248: LD_INT 1
79250: PUSH
79251: LD_INT 0
79253: PUSH
79254: EMPTY
79255: LIST
79256: LIST
79257: PUSH
79258: LD_INT 1
79260: PUSH
79261: LD_INT 1
79263: PUSH
79264: EMPTY
79265: LIST
79266: LIST
79267: PUSH
79268: LD_INT 0
79270: PUSH
79271: LD_INT 1
79273: PUSH
79274: EMPTY
79275: LIST
79276: LIST
79277: PUSH
79278: LD_INT 1
79280: NEG
79281: PUSH
79282: LD_INT 0
79284: PUSH
79285: EMPTY
79286: LIST
79287: LIST
79288: PUSH
79289: LD_INT 1
79291: NEG
79292: PUSH
79293: LD_INT 1
79295: NEG
79296: PUSH
79297: EMPTY
79298: LIST
79299: LIST
79300: PUSH
79301: EMPTY
79302: LIST
79303: LIST
79304: LIST
79305: LIST
79306: LIST
79307: LIST
79308: LIST
79309: ST_TO_ADDR
// fBunker3 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] ] ;
79310: LD_ADDR_VAR 0 62
79314: PUSH
79315: LD_INT 0
79317: PUSH
79318: LD_INT 0
79320: PUSH
79321: EMPTY
79322: LIST
79323: LIST
79324: PUSH
79325: LD_INT 0
79327: PUSH
79328: LD_INT 1
79330: NEG
79331: PUSH
79332: EMPTY
79333: LIST
79334: LIST
79335: PUSH
79336: LD_INT 1
79338: PUSH
79339: LD_INT 0
79341: PUSH
79342: EMPTY
79343: LIST
79344: LIST
79345: PUSH
79346: LD_INT 1
79348: PUSH
79349: LD_INT 1
79351: PUSH
79352: EMPTY
79353: LIST
79354: LIST
79355: PUSH
79356: LD_INT 0
79358: PUSH
79359: LD_INT 1
79361: PUSH
79362: EMPTY
79363: LIST
79364: LIST
79365: PUSH
79366: LD_INT 1
79368: NEG
79369: PUSH
79370: LD_INT 0
79372: PUSH
79373: EMPTY
79374: LIST
79375: LIST
79376: PUSH
79377: LD_INT 1
79379: NEG
79380: PUSH
79381: LD_INT 1
79383: NEG
79384: PUSH
79385: EMPTY
79386: LIST
79387: LIST
79388: PUSH
79389: EMPTY
79390: LIST
79391: LIST
79392: LIST
79393: LIST
79394: LIST
79395: LIST
79396: LIST
79397: ST_TO_ADDR
// fBunker4 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] ] ;
79398: LD_ADDR_VAR 0 63
79402: PUSH
79403: LD_INT 0
79405: PUSH
79406: LD_INT 0
79408: PUSH
79409: EMPTY
79410: LIST
79411: LIST
79412: PUSH
79413: LD_INT 0
79415: PUSH
79416: LD_INT 1
79418: NEG
79419: PUSH
79420: EMPTY
79421: LIST
79422: LIST
79423: PUSH
79424: LD_INT 1
79426: PUSH
79427: LD_INT 0
79429: PUSH
79430: EMPTY
79431: LIST
79432: LIST
79433: PUSH
79434: LD_INT 1
79436: PUSH
79437: LD_INT 1
79439: PUSH
79440: EMPTY
79441: LIST
79442: LIST
79443: PUSH
79444: LD_INT 0
79446: PUSH
79447: LD_INT 1
79449: PUSH
79450: EMPTY
79451: LIST
79452: LIST
79453: PUSH
79454: LD_INT 1
79456: NEG
79457: PUSH
79458: LD_INT 0
79460: PUSH
79461: EMPTY
79462: LIST
79463: LIST
79464: PUSH
79465: LD_INT 1
79467: NEG
79468: PUSH
79469: LD_INT 1
79471: NEG
79472: PUSH
79473: EMPTY
79474: LIST
79475: LIST
79476: PUSH
79477: EMPTY
79478: LIST
79479: LIST
79480: LIST
79481: LIST
79482: LIST
79483: LIST
79484: LIST
79485: ST_TO_ADDR
// fBunker5 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] ] ;
79486: LD_ADDR_VAR 0 64
79490: PUSH
79491: LD_INT 0
79493: PUSH
79494: LD_INT 0
79496: PUSH
79497: EMPTY
79498: LIST
79499: LIST
79500: PUSH
79501: LD_INT 0
79503: PUSH
79504: LD_INT 1
79506: NEG
79507: PUSH
79508: EMPTY
79509: LIST
79510: LIST
79511: PUSH
79512: LD_INT 1
79514: PUSH
79515: LD_INT 0
79517: PUSH
79518: EMPTY
79519: LIST
79520: LIST
79521: PUSH
79522: LD_INT 1
79524: PUSH
79525: LD_INT 1
79527: PUSH
79528: EMPTY
79529: LIST
79530: LIST
79531: PUSH
79532: LD_INT 0
79534: PUSH
79535: LD_INT 1
79537: PUSH
79538: EMPTY
79539: LIST
79540: LIST
79541: PUSH
79542: LD_INT 1
79544: NEG
79545: PUSH
79546: LD_INT 0
79548: PUSH
79549: EMPTY
79550: LIST
79551: LIST
79552: PUSH
79553: LD_INT 1
79555: NEG
79556: PUSH
79557: LD_INT 1
79559: NEG
79560: PUSH
79561: EMPTY
79562: LIST
79563: LIST
79564: PUSH
79565: EMPTY
79566: LIST
79567: LIST
79568: LIST
79569: LIST
79570: LIST
79571: LIST
79572: LIST
79573: ST_TO_ADDR
// end ; 1 :
79574: GO 85471
79576: LD_INT 1
79578: DOUBLE
79579: EQUAL
79580: IFTRUE 79584
79582: GO 82207
79584: POP
// begin fDepotAm0 = [ [ - 1 , - 3 ] , [ 0 , - 3 ] , [ 1 , - 2 ] ] ;
79585: LD_ADDR_VAR 0 11
79589: PUSH
79590: LD_INT 1
79592: NEG
79593: PUSH
79594: LD_INT 3
79596: NEG
79597: PUSH
79598: EMPTY
79599: LIST
79600: LIST
79601: PUSH
79602: LD_INT 0
79604: PUSH
79605: LD_INT 3
79607: NEG
79608: PUSH
79609: EMPTY
79610: LIST
79611: LIST
79612: PUSH
79613: LD_INT 1
79615: PUSH
79616: LD_INT 2
79618: NEG
79619: PUSH
79620: EMPTY
79621: LIST
79622: LIST
79623: PUSH
79624: EMPTY
79625: LIST
79626: LIST
79627: LIST
79628: ST_TO_ADDR
// fDepotAm1 = [ [ 2 , - 1 ] , [ 3 , 0 ] , [ 3 , 1 ] ] ;
79629: LD_ADDR_VAR 0 12
79633: PUSH
79634: LD_INT 2
79636: PUSH
79637: LD_INT 1
79639: NEG
79640: PUSH
79641: EMPTY
79642: LIST
79643: LIST
79644: PUSH
79645: LD_INT 3
79647: PUSH
79648: LD_INT 0
79650: PUSH
79651: EMPTY
79652: LIST
79653: LIST
79654: PUSH
79655: LD_INT 3
79657: PUSH
79658: LD_INT 1
79660: PUSH
79661: EMPTY
79662: LIST
79663: LIST
79664: PUSH
79665: EMPTY
79666: LIST
79667: LIST
79668: LIST
79669: ST_TO_ADDR
// fDepotAm2 = [ [ 3 , 2 ] , [ 3 , 3 ] , [ 2 , 3 ] ] ;
79670: LD_ADDR_VAR 0 13
79674: PUSH
79675: LD_INT 3
79677: PUSH
79678: LD_INT 2
79680: PUSH
79681: EMPTY
79682: LIST
79683: LIST
79684: PUSH
79685: LD_INT 3
79687: PUSH
79688: LD_INT 3
79690: PUSH
79691: EMPTY
79692: LIST
79693: LIST
79694: PUSH
79695: LD_INT 2
79697: PUSH
79698: LD_INT 3
79700: PUSH
79701: EMPTY
79702: LIST
79703: LIST
79704: PUSH
79705: EMPTY
79706: LIST
79707: LIST
79708: LIST
79709: ST_TO_ADDR
// fDepotAm3 = [ [ 1 , 3 ] , [ 0 , 3 ] , [ - 1 , 2 ] ] ;
79710: LD_ADDR_VAR 0 14
79714: PUSH
79715: LD_INT 1
79717: PUSH
79718: LD_INT 3
79720: PUSH
79721: EMPTY
79722: LIST
79723: LIST
79724: PUSH
79725: LD_INT 0
79727: PUSH
79728: LD_INT 3
79730: PUSH
79731: EMPTY
79732: LIST
79733: LIST
79734: PUSH
79735: LD_INT 1
79737: NEG
79738: PUSH
79739: LD_INT 2
79741: PUSH
79742: EMPTY
79743: LIST
79744: LIST
79745: PUSH
79746: EMPTY
79747: LIST
79748: LIST
79749: LIST
79750: ST_TO_ADDR
// fDepotAm4 = [ [ - 2 , 1 ] , [ - 3 , 0 ] , [ - 3 , - 1 ] ] ;
79751: LD_ADDR_VAR 0 15
79755: PUSH
79756: LD_INT 2
79758: NEG
79759: PUSH
79760: LD_INT 1
79762: PUSH
79763: EMPTY
79764: LIST
79765: LIST
79766: PUSH
79767: LD_INT 3
79769: NEG
79770: PUSH
79771: LD_INT 0
79773: PUSH
79774: EMPTY
79775: LIST
79776: LIST
79777: PUSH
79778: LD_INT 3
79780: NEG
79781: PUSH
79782: LD_INT 1
79784: NEG
79785: PUSH
79786: EMPTY
79787: LIST
79788: LIST
79789: PUSH
79790: EMPTY
79791: LIST
79792: LIST
79793: LIST
79794: ST_TO_ADDR
// fDepotAm5 = [ [ - 2 , - 3 ] , [ - 3 , - 2 ] , [ - 3 , - 3 ] ] ;
79795: LD_ADDR_VAR 0 16
79799: PUSH
79800: LD_INT 2
79802: NEG
79803: PUSH
79804: LD_INT 3
79806: NEG
79807: PUSH
79808: EMPTY
79809: LIST
79810: LIST
79811: PUSH
79812: LD_INT 3
79814: NEG
79815: PUSH
79816: LD_INT 2
79818: NEG
79819: PUSH
79820: EMPTY
79821: LIST
79822: LIST
79823: PUSH
79824: LD_INT 3
79826: NEG
79827: PUSH
79828: LD_INT 3
79830: NEG
79831: PUSH
79832: EMPTY
79833: LIST
79834: LIST
79835: PUSH
79836: EMPTY
79837: LIST
79838: LIST
79839: LIST
79840: ST_TO_ADDR
// fDepotAr0 = [ [ - 1 , - 3 ] , [ 0 , - 3 ] , [ 1 , - 2 ] ] ;
79841: LD_ADDR_VAR 0 17
79845: PUSH
79846: LD_INT 1
79848: NEG
79849: PUSH
79850: LD_INT 3
79852: NEG
79853: PUSH
79854: EMPTY
79855: LIST
79856: LIST
79857: PUSH
79858: LD_INT 0
79860: PUSH
79861: LD_INT 3
79863: NEG
79864: PUSH
79865: EMPTY
79866: LIST
79867: LIST
79868: PUSH
79869: LD_INT 1
79871: PUSH
79872: LD_INT 2
79874: NEG
79875: PUSH
79876: EMPTY
79877: LIST
79878: LIST
79879: PUSH
79880: EMPTY
79881: LIST
79882: LIST
79883: LIST
79884: ST_TO_ADDR
// fDepotAr1 = [ [ 2 , - 1 ] , [ 3 , 0 ] , [ 3 , 1 ] ] ;
79885: LD_ADDR_VAR 0 18
79889: PUSH
79890: LD_INT 2
79892: PUSH
79893: LD_INT 1
79895: NEG
79896: PUSH
79897: EMPTY
79898: LIST
79899: LIST
79900: PUSH
79901: LD_INT 3
79903: PUSH
79904: LD_INT 0
79906: PUSH
79907: EMPTY
79908: LIST
79909: LIST
79910: PUSH
79911: LD_INT 3
79913: PUSH
79914: LD_INT 1
79916: PUSH
79917: EMPTY
79918: LIST
79919: LIST
79920: PUSH
79921: EMPTY
79922: LIST
79923: LIST
79924: LIST
79925: ST_TO_ADDR
// fDepotAr2 = [ [ 3 , 2 ] , [ 3 , 3 ] , [ 2 , 3 ] ] ;
79926: LD_ADDR_VAR 0 19
79930: PUSH
79931: LD_INT 3
79933: PUSH
79934: LD_INT 2
79936: PUSH
79937: EMPTY
79938: LIST
79939: LIST
79940: PUSH
79941: LD_INT 3
79943: PUSH
79944: LD_INT 3
79946: PUSH
79947: EMPTY
79948: LIST
79949: LIST
79950: PUSH
79951: LD_INT 2
79953: PUSH
79954: LD_INT 3
79956: PUSH
79957: EMPTY
79958: LIST
79959: LIST
79960: PUSH
79961: EMPTY
79962: LIST
79963: LIST
79964: LIST
79965: ST_TO_ADDR
// fDepotAr3 = [ [ 1 , 3 ] , [ 0 , 3 ] , [ - 1 , 2 ] ] ;
79966: LD_ADDR_VAR 0 20
79970: PUSH
79971: LD_INT 1
79973: PUSH
79974: LD_INT 3
79976: PUSH
79977: EMPTY
79978: LIST
79979: LIST
79980: PUSH
79981: LD_INT 0
79983: PUSH
79984: LD_INT 3
79986: PUSH
79987: EMPTY
79988: LIST
79989: LIST
79990: PUSH
79991: LD_INT 1
79993: NEG
79994: PUSH
79995: LD_INT 2
79997: PUSH
79998: EMPTY
79999: LIST
80000: LIST
80001: PUSH
80002: EMPTY
80003: LIST
80004: LIST
80005: LIST
80006: ST_TO_ADDR
// fDepotAr4 = [ [ - 2 , 1 ] , [ - 3 , 0 ] , [ - 3 , - 1 ] ] ;
80007: LD_ADDR_VAR 0 21
80011: PUSH
80012: LD_INT 2
80014: NEG
80015: PUSH
80016: LD_INT 1
80018: PUSH
80019: EMPTY
80020: LIST
80021: LIST
80022: PUSH
80023: LD_INT 3
80025: NEG
80026: PUSH
80027: LD_INT 0
80029: PUSH
80030: EMPTY
80031: LIST
80032: LIST
80033: PUSH
80034: LD_INT 3
80036: NEG
80037: PUSH
80038: LD_INT 1
80040: NEG
80041: PUSH
80042: EMPTY
80043: LIST
80044: LIST
80045: PUSH
80046: EMPTY
80047: LIST
80048: LIST
80049: LIST
80050: ST_TO_ADDR
// fDepotAr5 = [ [ - 2 , - 3 ] , [ - 3 , - 2 ] , [ - 3 , - 3 ] ] ;
80051: LD_ADDR_VAR 0 22
80055: PUSH
80056: LD_INT 2
80058: NEG
80059: PUSH
80060: LD_INT 3
80062: NEG
80063: PUSH
80064: EMPTY
80065: LIST
80066: LIST
80067: PUSH
80068: LD_INT 3
80070: NEG
80071: PUSH
80072: LD_INT 2
80074: NEG
80075: PUSH
80076: EMPTY
80077: LIST
80078: LIST
80079: PUSH
80080: LD_INT 3
80082: NEG
80083: PUSH
80084: LD_INT 3
80086: NEG
80087: PUSH
80088: EMPTY
80089: LIST
80090: LIST
80091: PUSH
80092: EMPTY
80093: LIST
80094: LIST
80095: LIST
80096: ST_TO_ADDR
// fDepotRu0 = [ [ 0 , - 3 ] , [ - 1 , - 4 ] , [ 1 , - 3 ] ] ;
80097: LD_ADDR_VAR 0 23
80101: PUSH
80102: LD_INT 0
80104: PUSH
80105: LD_INT 3
80107: NEG
80108: PUSH
80109: EMPTY
80110: LIST
80111: LIST
80112: PUSH
80113: LD_INT 1
80115: NEG
80116: PUSH
80117: LD_INT 4
80119: NEG
80120: PUSH
80121: EMPTY
80122: LIST
80123: LIST
80124: PUSH
80125: LD_INT 1
80127: PUSH
80128: LD_INT 3
80130: NEG
80131: PUSH
80132: EMPTY
80133: LIST
80134: LIST
80135: PUSH
80136: EMPTY
80137: LIST
80138: LIST
80139: LIST
80140: ST_TO_ADDR
// fDepotRu1 = [ [ 3 , 0 ] , [ 3 , - 1 ] , [ 4 , 1 ] ] ;
80141: LD_ADDR_VAR 0 24
80145: PUSH
80146: LD_INT 3
80148: PUSH
80149: LD_INT 0
80151: PUSH
80152: EMPTY
80153: LIST
80154: LIST
80155: PUSH
80156: LD_INT 3
80158: PUSH
80159: LD_INT 1
80161: NEG
80162: PUSH
80163: EMPTY
80164: LIST
80165: LIST
80166: PUSH
80167: LD_INT 4
80169: PUSH
80170: LD_INT 1
80172: PUSH
80173: EMPTY
80174: LIST
80175: LIST
80176: PUSH
80177: EMPTY
80178: LIST
80179: LIST
80180: LIST
80181: ST_TO_ADDR
// fDepotRu2 = [ [ 3 , 3 ] , [ 4 , 3 ] , [ 3 , 4 ] ] ;
80182: LD_ADDR_VAR 0 25
80186: PUSH
80187: LD_INT 3
80189: PUSH
80190: LD_INT 3
80192: PUSH
80193: EMPTY
80194: LIST
80195: LIST
80196: PUSH
80197: LD_INT 4
80199: PUSH
80200: LD_INT 3
80202: PUSH
80203: EMPTY
80204: LIST
80205: LIST
80206: PUSH
80207: LD_INT 3
80209: PUSH
80210: LD_INT 4
80212: PUSH
80213: EMPTY
80214: LIST
80215: LIST
80216: PUSH
80217: EMPTY
80218: LIST
80219: LIST
80220: LIST
80221: ST_TO_ADDR
// fDepotRu3 = [ [ 0 , 3 ] , [ 1 , 4 ] , [ - 1 , 3 ] ] ;
80222: LD_ADDR_VAR 0 26
80226: PUSH
80227: LD_INT 0
80229: PUSH
80230: LD_INT 3
80232: PUSH
80233: EMPTY
80234: LIST
80235: LIST
80236: PUSH
80237: LD_INT 1
80239: PUSH
80240: LD_INT 4
80242: PUSH
80243: EMPTY
80244: LIST
80245: LIST
80246: PUSH
80247: LD_INT 1
80249: NEG
80250: PUSH
80251: LD_INT 3
80253: PUSH
80254: EMPTY
80255: LIST
80256: LIST
80257: PUSH
80258: EMPTY
80259: LIST
80260: LIST
80261: LIST
80262: ST_TO_ADDR
// fDepotRu4 = [ [ - 3 , 0 ] , [ - 3 , 1 ] , [ - 4 , - 1 ] ] ;
80263: LD_ADDR_VAR 0 27
80267: PUSH
80268: LD_INT 3
80270: NEG
80271: PUSH
80272: LD_INT 0
80274: PUSH
80275: EMPTY
80276: LIST
80277: LIST
80278: PUSH
80279: LD_INT 3
80281: NEG
80282: PUSH
80283: LD_INT 1
80285: PUSH
80286: EMPTY
80287: LIST
80288: LIST
80289: PUSH
80290: LD_INT 4
80292: NEG
80293: PUSH
80294: LD_INT 1
80296: NEG
80297: PUSH
80298: EMPTY
80299: LIST
80300: LIST
80301: PUSH
80302: EMPTY
80303: LIST
80304: LIST
80305: LIST
80306: ST_TO_ADDR
// fDepotRu5 = [ [ - 3 , - 3 ] , [ - 3 , - 4 ] , [ - 4 , - 3 ] ] ;
80307: LD_ADDR_VAR 0 28
80311: PUSH
80312: LD_INT 3
80314: NEG
80315: PUSH
80316: LD_INT 3
80318: NEG
80319: PUSH
80320: EMPTY
80321: LIST
80322: LIST
80323: PUSH
80324: LD_INT 3
80326: NEG
80327: PUSH
80328: LD_INT 4
80330: NEG
80331: PUSH
80332: EMPTY
80333: LIST
80334: LIST
80335: PUSH
80336: LD_INT 4
80338: NEG
80339: PUSH
80340: LD_INT 3
80342: NEG
80343: PUSH
80344: EMPTY
80345: LIST
80346: LIST
80347: PUSH
80348: EMPTY
80349: LIST
80350: LIST
80351: LIST
80352: ST_TO_ADDR
// fFactory0 = [ [ - 1 , - 3 ] , [ 0 , - 3 ] , [ 1 , - 2 ] , [ - 1 , - 4 ] , [ 0 , - 4 ] , [ 1 , - 3 ] , [ - 1 , - 5 ] , [ 0 , - 5 ] , [ 1 , - 4 ] , [ - 1 , - 6 ] , [ 0 , - 6 ] , [ 1 , - 5 ] ] ;
80353: LD_ADDR_VAR 0 29
80357: PUSH
80358: LD_INT 1
80360: NEG
80361: PUSH
80362: LD_INT 3
80364: NEG
80365: PUSH
80366: EMPTY
80367: LIST
80368: LIST
80369: PUSH
80370: LD_INT 0
80372: PUSH
80373: LD_INT 3
80375: NEG
80376: PUSH
80377: EMPTY
80378: LIST
80379: LIST
80380: PUSH
80381: LD_INT 1
80383: PUSH
80384: LD_INT 2
80386: NEG
80387: PUSH
80388: EMPTY
80389: LIST
80390: LIST
80391: PUSH
80392: LD_INT 1
80394: NEG
80395: PUSH
80396: LD_INT 4
80398: NEG
80399: PUSH
80400: EMPTY
80401: LIST
80402: LIST
80403: PUSH
80404: LD_INT 0
80406: PUSH
80407: LD_INT 4
80409: NEG
80410: PUSH
80411: EMPTY
80412: LIST
80413: LIST
80414: PUSH
80415: LD_INT 1
80417: PUSH
80418: LD_INT 3
80420: NEG
80421: PUSH
80422: EMPTY
80423: LIST
80424: LIST
80425: PUSH
80426: LD_INT 1
80428: NEG
80429: PUSH
80430: LD_INT 5
80432: NEG
80433: PUSH
80434: EMPTY
80435: LIST
80436: LIST
80437: PUSH
80438: LD_INT 0
80440: PUSH
80441: LD_INT 5
80443: NEG
80444: PUSH
80445: EMPTY
80446: LIST
80447: LIST
80448: PUSH
80449: LD_INT 1
80451: PUSH
80452: LD_INT 4
80454: NEG
80455: PUSH
80456: EMPTY
80457: LIST
80458: LIST
80459: PUSH
80460: LD_INT 1
80462: NEG
80463: PUSH
80464: LD_INT 6
80466: NEG
80467: PUSH
80468: EMPTY
80469: LIST
80470: LIST
80471: PUSH
80472: LD_INT 0
80474: PUSH
80475: LD_INT 6
80477: NEG
80478: PUSH
80479: EMPTY
80480: LIST
80481: LIST
80482: PUSH
80483: LD_INT 1
80485: PUSH
80486: LD_INT 5
80488: NEG
80489: PUSH
80490: EMPTY
80491: LIST
80492: LIST
80493: PUSH
80494: EMPTY
80495: LIST
80496: LIST
80497: LIST
80498: LIST
80499: LIST
80500: LIST
80501: LIST
80502: LIST
80503: LIST
80504: LIST
80505: LIST
80506: LIST
80507: ST_TO_ADDR
// fFactory1 = [ [ 2 , - 1 ] , [ 3 , 0 ] , [ 3 , 1 ] , [ 3 , - 1 ] , [ 4 , 0 ] , [ 4 , 1 ] , [ 4 , - 1 ] , [ 5 , 0 ] , [ 5 , 1 ] , [ 5 , - 1 ] , [ 6 , 0 ] , [ 6 , 1 ] ] ;
80508: LD_ADDR_VAR 0 30
80512: PUSH
80513: LD_INT 2
80515: PUSH
80516: LD_INT 1
80518: NEG
80519: PUSH
80520: EMPTY
80521: LIST
80522: LIST
80523: PUSH
80524: LD_INT 3
80526: PUSH
80527: LD_INT 0
80529: PUSH
80530: EMPTY
80531: LIST
80532: LIST
80533: PUSH
80534: LD_INT 3
80536: PUSH
80537: LD_INT 1
80539: PUSH
80540: EMPTY
80541: LIST
80542: LIST
80543: PUSH
80544: LD_INT 3
80546: PUSH
80547: LD_INT 1
80549: NEG
80550: PUSH
80551: EMPTY
80552: LIST
80553: LIST
80554: PUSH
80555: LD_INT 4
80557: PUSH
80558: LD_INT 0
80560: PUSH
80561: EMPTY
80562: LIST
80563: LIST
80564: PUSH
80565: LD_INT 4
80567: PUSH
80568: LD_INT 1
80570: PUSH
80571: EMPTY
80572: LIST
80573: LIST
80574: PUSH
80575: LD_INT 4
80577: PUSH
80578: LD_INT 1
80580: NEG
80581: PUSH
80582: EMPTY
80583: LIST
80584: LIST
80585: PUSH
80586: LD_INT 5
80588: PUSH
80589: LD_INT 0
80591: PUSH
80592: EMPTY
80593: LIST
80594: LIST
80595: PUSH
80596: LD_INT 5
80598: PUSH
80599: LD_INT 1
80601: PUSH
80602: EMPTY
80603: LIST
80604: LIST
80605: PUSH
80606: LD_INT 5
80608: PUSH
80609: LD_INT 1
80611: NEG
80612: PUSH
80613: EMPTY
80614: LIST
80615: LIST
80616: PUSH
80617: LD_INT 6
80619: PUSH
80620: LD_INT 0
80622: PUSH
80623: EMPTY
80624: LIST
80625: LIST
80626: PUSH
80627: LD_INT 6
80629: PUSH
80630: LD_INT 1
80632: PUSH
80633: EMPTY
80634: LIST
80635: LIST
80636: PUSH
80637: EMPTY
80638: LIST
80639: LIST
80640: LIST
80641: LIST
80642: LIST
80643: LIST
80644: LIST
80645: LIST
80646: LIST
80647: LIST
80648: LIST
80649: LIST
80650: ST_TO_ADDR
// fFactory2 = [ [ 3 , 2 ] , [ 3 , 3 ] , [ 2 , 3 ] , [ 4 , 3 ] , [ 4 , 4 ] , [ 3 , 4 ] , [ 5 , 4 ] , [ 5 , 5 ] , [ 4 , 5 ] , [ 6 , 5 ] , [ 6 , 6 ] , [ 5 , 6 ] ] ;
80651: LD_ADDR_VAR 0 31
80655: PUSH
80656: LD_INT 3
80658: PUSH
80659: LD_INT 2
80661: PUSH
80662: EMPTY
80663: LIST
80664: LIST
80665: PUSH
80666: LD_INT 3
80668: PUSH
80669: LD_INT 3
80671: PUSH
80672: EMPTY
80673: LIST
80674: LIST
80675: PUSH
80676: LD_INT 2
80678: PUSH
80679: LD_INT 3
80681: PUSH
80682: EMPTY
80683: LIST
80684: LIST
80685: PUSH
80686: LD_INT 4
80688: PUSH
80689: LD_INT 3
80691: PUSH
80692: EMPTY
80693: LIST
80694: LIST
80695: PUSH
80696: LD_INT 4
80698: PUSH
80699: LD_INT 4
80701: PUSH
80702: EMPTY
80703: LIST
80704: LIST
80705: PUSH
80706: LD_INT 3
80708: PUSH
80709: LD_INT 4
80711: PUSH
80712: EMPTY
80713: LIST
80714: LIST
80715: PUSH
80716: LD_INT 5
80718: PUSH
80719: LD_INT 4
80721: PUSH
80722: EMPTY
80723: LIST
80724: LIST
80725: PUSH
80726: LD_INT 5
80728: PUSH
80729: LD_INT 5
80731: PUSH
80732: EMPTY
80733: LIST
80734: LIST
80735: PUSH
80736: LD_INT 4
80738: PUSH
80739: LD_INT 5
80741: PUSH
80742: EMPTY
80743: LIST
80744: LIST
80745: PUSH
80746: LD_INT 6
80748: PUSH
80749: LD_INT 5
80751: PUSH
80752: EMPTY
80753: LIST
80754: LIST
80755: PUSH
80756: LD_INT 6
80758: PUSH
80759: LD_INT 6
80761: PUSH
80762: EMPTY
80763: LIST
80764: LIST
80765: PUSH
80766: LD_INT 5
80768: PUSH
80769: LD_INT 6
80771: PUSH
80772: EMPTY
80773: LIST
80774: LIST
80775: PUSH
80776: EMPTY
80777: LIST
80778: LIST
80779: LIST
80780: LIST
80781: LIST
80782: LIST
80783: LIST
80784: LIST
80785: LIST
80786: LIST
80787: LIST
80788: LIST
80789: ST_TO_ADDR
// fFactory3 = [ [ 1 , 3 ] , [ 0 , 3 ] , [ - 1 , 2 ] , [ 1 , 4 ] , [ 0 , 4 ] , [ - 1 , 3 ] , [ 1 , 5 ] , [ 0 , 5 ] , [ - 1 , 4 ] , [ 1 , 6 ] , [ 0 , 6 ] , [ - 1 , 5 ] ] ;
80790: LD_ADDR_VAR 0 32
80794: PUSH
80795: LD_INT 1
80797: PUSH
80798: LD_INT 3
80800: PUSH
80801: EMPTY
80802: LIST
80803: LIST
80804: PUSH
80805: LD_INT 0
80807: PUSH
80808: LD_INT 3
80810: PUSH
80811: EMPTY
80812: LIST
80813: LIST
80814: PUSH
80815: LD_INT 1
80817: NEG
80818: PUSH
80819: LD_INT 2
80821: PUSH
80822: EMPTY
80823: LIST
80824: LIST
80825: PUSH
80826: LD_INT 1
80828: PUSH
80829: LD_INT 4
80831: PUSH
80832: EMPTY
80833: LIST
80834: LIST
80835: PUSH
80836: LD_INT 0
80838: PUSH
80839: LD_INT 4
80841: PUSH
80842: EMPTY
80843: LIST
80844: LIST
80845: PUSH
80846: LD_INT 1
80848: NEG
80849: PUSH
80850: LD_INT 3
80852: PUSH
80853: EMPTY
80854: LIST
80855: LIST
80856: PUSH
80857: LD_INT 1
80859: PUSH
80860: LD_INT 5
80862: PUSH
80863: EMPTY
80864: LIST
80865: LIST
80866: PUSH
80867: LD_INT 0
80869: PUSH
80870: LD_INT 5
80872: PUSH
80873: EMPTY
80874: LIST
80875: LIST
80876: PUSH
80877: LD_INT 1
80879: NEG
80880: PUSH
80881: LD_INT 4
80883: PUSH
80884: EMPTY
80885: LIST
80886: LIST
80887: PUSH
80888: LD_INT 1
80890: PUSH
80891: LD_INT 6
80893: PUSH
80894: EMPTY
80895: LIST
80896: LIST
80897: PUSH
80898: LD_INT 0
80900: PUSH
80901: LD_INT 6
80903: PUSH
80904: EMPTY
80905: LIST
80906: LIST
80907: PUSH
80908: LD_INT 1
80910: NEG
80911: PUSH
80912: LD_INT 5
80914: PUSH
80915: EMPTY
80916: LIST
80917: LIST
80918: PUSH
80919: EMPTY
80920: LIST
80921: LIST
80922: LIST
80923: LIST
80924: LIST
80925: LIST
80926: LIST
80927: LIST
80928: LIST
80929: LIST
80930: LIST
80931: LIST
80932: ST_TO_ADDR
// fFactory4 = [ [ - 2 , 1 ] , [ - 3 , 0 ] , [ - 3 , - 1 ] , [ - 3 , 1 ] , [ - 4 , 0 ] , [ - 4 , - 1 ] , [ - 4 , 1 ] , [ - 5 , 0 ] , [ - 5 , - 1 ] , [ - 5 , 1 ] , [ - 6 , 0 ] , [ - 6 , - 1 ] ] ;
80933: LD_ADDR_VAR 0 33
80937: PUSH
80938: LD_INT 2
80940: NEG
80941: PUSH
80942: LD_INT 1
80944: PUSH
80945: EMPTY
80946: LIST
80947: LIST
80948: PUSH
80949: LD_INT 3
80951: NEG
80952: PUSH
80953: LD_INT 0
80955: PUSH
80956: EMPTY
80957: LIST
80958: LIST
80959: PUSH
80960: LD_INT 3
80962: NEG
80963: PUSH
80964: LD_INT 1
80966: NEG
80967: PUSH
80968: EMPTY
80969: LIST
80970: LIST
80971: PUSH
80972: LD_INT 3
80974: NEG
80975: PUSH
80976: LD_INT 1
80978: PUSH
80979: EMPTY
80980: LIST
80981: LIST
80982: PUSH
80983: LD_INT 4
80985: NEG
80986: PUSH
80987: LD_INT 0
80989: PUSH
80990: EMPTY
80991: LIST
80992: LIST
80993: PUSH
80994: LD_INT 4
80996: NEG
80997: PUSH
80998: LD_INT 1
81000: NEG
81001: PUSH
81002: EMPTY
81003: LIST
81004: LIST
81005: PUSH
81006: LD_INT 4
81008: NEG
81009: PUSH
81010: LD_INT 1
81012: PUSH
81013: EMPTY
81014: LIST
81015: LIST
81016: PUSH
81017: LD_INT 5
81019: NEG
81020: PUSH
81021: LD_INT 0
81023: PUSH
81024: EMPTY
81025: LIST
81026: LIST
81027: PUSH
81028: LD_INT 5
81030: NEG
81031: PUSH
81032: LD_INT 1
81034: NEG
81035: PUSH
81036: EMPTY
81037: LIST
81038: LIST
81039: PUSH
81040: LD_INT 5
81042: NEG
81043: PUSH
81044: LD_INT 1
81046: PUSH
81047: EMPTY
81048: LIST
81049: LIST
81050: PUSH
81051: LD_INT 6
81053: NEG
81054: PUSH
81055: LD_INT 0
81057: PUSH
81058: EMPTY
81059: LIST
81060: LIST
81061: PUSH
81062: LD_INT 6
81064: NEG
81065: PUSH
81066: LD_INT 1
81068: NEG
81069: PUSH
81070: EMPTY
81071: LIST
81072: LIST
81073: PUSH
81074: EMPTY
81075: LIST
81076: LIST
81077: LIST
81078: LIST
81079: LIST
81080: LIST
81081: LIST
81082: LIST
81083: LIST
81084: LIST
81085: LIST
81086: LIST
81087: ST_TO_ADDR
// fFactory5 = [ [ - 2 , - 3 ] , [ - 3 , - 2 ] , [ - 3 , - 3 ] , [ - 3 , - 4 ] , [ - 4 , - 3 ] , [ - 4 , - 4 ] , [ - 4 , - 5 ] , [ - 5 , - 4 ] , [ - 5 , - 5 ] , [ - 5 , - 6 ] , [ - 6 , - 5 ] , [ - 6 , - 6 ] ] ;
81088: LD_ADDR_VAR 0 34
81092: PUSH
81093: LD_INT 2
81095: NEG
81096: PUSH
81097: LD_INT 3
81099: NEG
81100: PUSH
81101: EMPTY
81102: LIST
81103: LIST
81104: PUSH
81105: LD_INT 3
81107: NEG
81108: PUSH
81109: LD_INT 2
81111: NEG
81112: PUSH
81113: EMPTY
81114: LIST
81115: LIST
81116: PUSH
81117: LD_INT 3
81119: NEG
81120: PUSH
81121: LD_INT 3
81123: NEG
81124: PUSH
81125: EMPTY
81126: LIST
81127: LIST
81128: PUSH
81129: LD_INT 3
81131: NEG
81132: PUSH
81133: LD_INT 4
81135: NEG
81136: PUSH
81137: EMPTY
81138: LIST
81139: LIST
81140: PUSH
81141: LD_INT 4
81143: NEG
81144: PUSH
81145: LD_INT 3
81147: NEG
81148: PUSH
81149: EMPTY
81150: LIST
81151: LIST
81152: PUSH
81153: LD_INT 4
81155: NEG
81156: PUSH
81157: LD_INT 4
81159: NEG
81160: PUSH
81161: EMPTY
81162: LIST
81163: LIST
81164: PUSH
81165: LD_INT 4
81167: NEG
81168: PUSH
81169: LD_INT 5
81171: NEG
81172: PUSH
81173: EMPTY
81174: LIST
81175: LIST
81176: PUSH
81177: LD_INT 5
81179: NEG
81180: PUSH
81181: LD_INT 4
81183: NEG
81184: PUSH
81185: EMPTY
81186: LIST
81187: LIST
81188: PUSH
81189: LD_INT 5
81191: NEG
81192: PUSH
81193: LD_INT 5
81195: NEG
81196: PUSH
81197: EMPTY
81198: LIST
81199: LIST
81200: PUSH
81201: LD_INT 5
81203: NEG
81204: PUSH
81205: LD_INT 6
81207: NEG
81208: PUSH
81209: EMPTY
81210: LIST
81211: LIST
81212: PUSH
81213: LD_INT 6
81215: NEG
81216: PUSH
81217: LD_INT 5
81219: NEG
81220: PUSH
81221: EMPTY
81222: LIST
81223: LIST
81224: PUSH
81225: LD_INT 6
81227: NEG
81228: PUSH
81229: LD_INT 6
81231: NEG
81232: PUSH
81233: EMPTY
81234: LIST
81235: LIST
81236: PUSH
81237: EMPTY
81238: LIST
81239: LIST
81240: LIST
81241: LIST
81242: LIST
81243: LIST
81244: LIST
81245: LIST
81246: LIST
81247: LIST
81248: LIST
81249: LIST
81250: ST_TO_ADDR
// fLab0 = [ [ 0 , - 2 ] , [ - 1 , - 3 ] , [ 1 , - 2 ] ] ;
81251: LD_ADDR_VAR 0 41
81255: PUSH
81256: LD_INT 0
81258: PUSH
81259: LD_INT 2
81261: NEG
81262: PUSH
81263: EMPTY
81264: LIST
81265: LIST
81266: PUSH
81267: LD_INT 1
81269: NEG
81270: PUSH
81271: LD_INT 3
81273: NEG
81274: PUSH
81275: EMPTY
81276: LIST
81277: LIST
81278: PUSH
81279: LD_INT 1
81281: PUSH
81282: LD_INT 2
81284: NEG
81285: PUSH
81286: EMPTY
81287: LIST
81288: LIST
81289: PUSH
81290: EMPTY
81291: LIST
81292: LIST
81293: LIST
81294: ST_TO_ADDR
// fLab1 = [ [ 2 , 0 ] , [ 2 , - 1 ] , [ 3 , 1 ] ] ;
81295: LD_ADDR_VAR 0 42
81299: PUSH
81300: LD_INT 2
81302: PUSH
81303: LD_INT 0
81305: PUSH
81306: EMPTY
81307: LIST
81308: LIST
81309: PUSH
81310: LD_INT 2
81312: PUSH
81313: LD_INT 1
81315: NEG
81316: PUSH
81317: EMPTY
81318: LIST
81319: LIST
81320: PUSH
81321: LD_INT 3
81323: PUSH
81324: LD_INT 1
81326: PUSH
81327: EMPTY
81328: LIST
81329: LIST
81330: PUSH
81331: EMPTY
81332: LIST
81333: LIST
81334: LIST
81335: ST_TO_ADDR
// fLab2 = [ [ 2 , 2 ] , [ 3 , 2 ] , [ 2 , 3 ] ] ;
81336: LD_ADDR_VAR 0 43
81340: PUSH
81341: LD_INT 2
81343: PUSH
81344: LD_INT 2
81346: PUSH
81347: EMPTY
81348: LIST
81349: LIST
81350: PUSH
81351: LD_INT 3
81353: PUSH
81354: LD_INT 2
81356: PUSH
81357: EMPTY
81358: LIST
81359: LIST
81360: PUSH
81361: LD_INT 2
81363: PUSH
81364: LD_INT 3
81366: PUSH
81367: EMPTY
81368: LIST
81369: LIST
81370: PUSH
81371: EMPTY
81372: LIST
81373: LIST
81374: LIST
81375: ST_TO_ADDR
// fLab3 = [ [ 0 , 2 ] , [ 1 , 3 ] , [ - 1 , 2 ] ] ;
81376: LD_ADDR_VAR 0 44
81380: PUSH
81381: LD_INT 0
81383: PUSH
81384: LD_INT 2
81386: PUSH
81387: EMPTY
81388: LIST
81389: LIST
81390: PUSH
81391: LD_INT 1
81393: PUSH
81394: LD_INT 3
81396: PUSH
81397: EMPTY
81398: LIST
81399: LIST
81400: PUSH
81401: LD_INT 1
81403: NEG
81404: PUSH
81405: LD_INT 2
81407: PUSH
81408: EMPTY
81409: LIST
81410: LIST
81411: PUSH
81412: EMPTY
81413: LIST
81414: LIST
81415: LIST
81416: ST_TO_ADDR
// fLab4 = [ [ - 2 , 0 ] , [ - 2 , 1 ] , [ - 3 , - 1 ] ] ;
81417: LD_ADDR_VAR 0 45
81421: PUSH
81422: LD_INT 2
81424: NEG
81425: PUSH
81426: LD_INT 0
81428: PUSH
81429: EMPTY
81430: LIST
81431: LIST
81432: PUSH
81433: LD_INT 2
81435: NEG
81436: PUSH
81437: LD_INT 1
81439: PUSH
81440: EMPTY
81441: LIST
81442: LIST
81443: PUSH
81444: LD_INT 3
81446: NEG
81447: PUSH
81448: LD_INT 1
81450: NEG
81451: PUSH
81452: EMPTY
81453: LIST
81454: LIST
81455: PUSH
81456: EMPTY
81457: LIST
81458: LIST
81459: LIST
81460: ST_TO_ADDR
// fLab5 = [ [ - 2 , - 2 ] , [ - 2 , - 3 ] , [ - 3 , - 2 ] ] ;
81461: LD_ADDR_VAR 0 46
81465: PUSH
81466: LD_INT 2
81468: NEG
81469: PUSH
81470: LD_INT 2
81472: NEG
81473: PUSH
81474: EMPTY
81475: LIST
81476: LIST
81477: PUSH
81478: LD_INT 2
81480: NEG
81481: PUSH
81482: LD_INT 3
81484: NEG
81485: PUSH
81486: EMPTY
81487: LIST
81488: LIST
81489: PUSH
81490: LD_INT 3
81492: NEG
81493: PUSH
81494: LD_INT 2
81496: NEG
81497: PUSH
81498: EMPTY
81499: LIST
81500: LIST
81501: PUSH
81502: EMPTY
81503: LIST
81504: LIST
81505: LIST
81506: ST_TO_ADDR
// fControlTower0 = [ [ - 2 , - 3 ] , [ - 1 , - 3 ] ] ;
81507: LD_ADDR_VAR 0 47
81511: PUSH
81512: LD_INT 2
81514: NEG
81515: PUSH
81516: LD_INT 3
81518: NEG
81519: PUSH
81520: EMPTY
81521: LIST
81522: LIST
81523: PUSH
81524: LD_INT 1
81526: NEG
81527: PUSH
81528: LD_INT 3
81530: NEG
81531: PUSH
81532: EMPTY
81533: LIST
81534: LIST
81535: PUSH
81536: EMPTY
81537: LIST
81538: LIST
81539: ST_TO_ADDR
// fControlTower1 = [ [ 1 , - 2 ] , [ 2 , - 1 ] ] ;
81540: LD_ADDR_VAR 0 48
81544: PUSH
81545: LD_INT 1
81547: PUSH
81548: LD_INT 2
81550: NEG
81551: PUSH
81552: EMPTY
81553: LIST
81554: LIST
81555: PUSH
81556: LD_INT 2
81558: PUSH
81559: LD_INT 1
81561: NEG
81562: PUSH
81563: EMPTY
81564: LIST
81565: LIST
81566: PUSH
81567: EMPTY
81568: LIST
81569: LIST
81570: ST_TO_ADDR
// fControlTower2 = [ [ 3 , 1 ] , [ 3 , 2 ] ] ;
81571: LD_ADDR_VAR 0 49
81575: PUSH
81576: LD_INT 3
81578: PUSH
81579: LD_INT 1
81581: PUSH
81582: EMPTY
81583: LIST
81584: LIST
81585: PUSH
81586: LD_INT 3
81588: PUSH
81589: LD_INT 2
81591: PUSH
81592: EMPTY
81593: LIST
81594: LIST
81595: PUSH
81596: EMPTY
81597: LIST
81598: LIST
81599: ST_TO_ADDR
// fControlTower3 = [ [ 2 , 3 ] , [ 1 , 3 ] ] ;
81600: LD_ADDR_VAR 0 50
81604: PUSH
81605: LD_INT 2
81607: PUSH
81608: LD_INT 3
81610: PUSH
81611: EMPTY
81612: LIST
81613: LIST
81614: PUSH
81615: LD_INT 1
81617: PUSH
81618: LD_INT 3
81620: PUSH
81621: EMPTY
81622: LIST
81623: LIST
81624: PUSH
81625: EMPTY
81626: LIST
81627: LIST
81628: ST_TO_ADDR
// fControlTower4 = [ [ - 1 , 2 ] , [ - 2 , 1 ] ] ;
81629: LD_ADDR_VAR 0 51
81633: PUSH
81634: LD_INT 1
81636: NEG
81637: PUSH
81638: LD_INT 2
81640: PUSH
81641: EMPTY
81642: LIST
81643: LIST
81644: PUSH
81645: LD_INT 2
81647: NEG
81648: PUSH
81649: LD_INT 1
81651: PUSH
81652: EMPTY
81653: LIST
81654: LIST
81655: PUSH
81656: EMPTY
81657: LIST
81658: LIST
81659: ST_TO_ADDR
// fControlTower5 = [ [ - 3 , - 1 ] , [ - 3 , - 2 ] ] ;
81660: LD_ADDR_VAR 0 52
81664: PUSH
81665: LD_INT 3
81667: NEG
81668: PUSH
81669: LD_INT 1
81671: NEG
81672: PUSH
81673: EMPTY
81674: LIST
81675: LIST
81676: PUSH
81677: LD_INT 3
81679: NEG
81680: PUSH
81681: LD_INT 2
81683: NEG
81684: PUSH
81685: EMPTY
81686: LIST
81687: LIST
81688: PUSH
81689: EMPTY
81690: LIST
81691: LIST
81692: ST_TO_ADDR
// fBarracks0 = [ [ - 1 , - 3 ] , [ 0 , - 3 ] , [ 1 , - 2 ] ] ;
81693: LD_ADDR_VAR 0 53
81697: PUSH
81698: LD_INT 1
81700: NEG
81701: PUSH
81702: LD_INT 3
81704: NEG
81705: PUSH
81706: EMPTY
81707: LIST
81708: LIST
81709: PUSH
81710: LD_INT 0
81712: PUSH
81713: LD_INT 3
81715: NEG
81716: PUSH
81717: EMPTY
81718: LIST
81719: LIST
81720: PUSH
81721: LD_INT 1
81723: PUSH
81724: LD_INT 2
81726: NEG
81727: PUSH
81728: EMPTY
81729: LIST
81730: LIST
81731: PUSH
81732: EMPTY
81733: LIST
81734: LIST
81735: LIST
81736: ST_TO_ADDR
// fBarracks1 = [ [ 2 , - 1 ] , [ 3 , 0 ] , [ 3 , 1 ] ] ;
81737: LD_ADDR_VAR 0 54
81741: PUSH
81742: LD_INT 2
81744: PUSH
81745: LD_INT 1
81747: NEG
81748: PUSH
81749: EMPTY
81750: LIST
81751: LIST
81752: PUSH
81753: LD_INT 3
81755: PUSH
81756: LD_INT 0
81758: PUSH
81759: EMPTY
81760: LIST
81761: LIST
81762: PUSH
81763: LD_INT 3
81765: PUSH
81766: LD_INT 1
81768: PUSH
81769: EMPTY
81770: LIST
81771: LIST
81772: PUSH
81773: EMPTY
81774: LIST
81775: LIST
81776: LIST
81777: ST_TO_ADDR
// fBarracks2 = [ [ 3 , 2 ] , [ 3 , 3 ] , [ 2 , 3 ] ] ;
81778: LD_ADDR_VAR 0 55
81782: PUSH
81783: LD_INT 3
81785: PUSH
81786: LD_INT 2
81788: PUSH
81789: EMPTY
81790: LIST
81791: LIST
81792: PUSH
81793: LD_INT 3
81795: PUSH
81796: LD_INT 3
81798: PUSH
81799: EMPTY
81800: LIST
81801: LIST
81802: PUSH
81803: LD_INT 2
81805: PUSH
81806: LD_INT 3
81808: PUSH
81809: EMPTY
81810: LIST
81811: LIST
81812: PUSH
81813: EMPTY
81814: LIST
81815: LIST
81816: LIST
81817: ST_TO_ADDR
// fBarracks3 = [ [ 1 , 3 ] , [ 0 , 3 ] , [ - 1 , 2 ] ] ;
81818: LD_ADDR_VAR 0 56
81822: PUSH
81823: LD_INT 1
81825: PUSH
81826: LD_INT 3
81828: PUSH
81829: EMPTY
81830: LIST
81831: LIST
81832: PUSH
81833: LD_INT 0
81835: PUSH
81836: LD_INT 3
81838: PUSH
81839: EMPTY
81840: LIST
81841: LIST
81842: PUSH
81843: LD_INT 1
81845: NEG
81846: PUSH
81847: LD_INT 2
81849: PUSH
81850: EMPTY
81851: LIST
81852: LIST
81853: PUSH
81854: EMPTY
81855: LIST
81856: LIST
81857: LIST
81858: ST_TO_ADDR
// fBarracks4 = [ [ - 2 , 1 ] , [ - 3 , 0 ] , [ - 3 , - 1 ] ] ;
81859: LD_ADDR_VAR 0 57
81863: PUSH
81864: LD_INT 2
81866: NEG
81867: PUSH
81868: LD_INT 1
81870: PUSH
81871: EMPTY
81872: LIST
81873: LIST
81874: PUSH
81875: LD_INT 3
81877: NEG
81878: PUSH
81879: LD_INT 0
81881: PUSH
81882: EMPTY
81883: LIST
81884: LIST
81885: PUSH
81886: LD_INT 3
81888: NEG
81889: PUSH
81890: LD_INT 1
81892: NEG
81893: PUSH
81894: EMPTY
81895: LIST
81896: LIST
81897: PUSH
81898: EMPTY
81899: LIST
81900: LIST
81901: LIST
81902: ST_TO_ADDR
// fBarracks5 = [ [ - 2 , - 3 ] , [ - 3 , - 2 ] , [ - 3 , - 3 ] ] ;
81903: LD_ADDR_VAR 0 58
81907: PUSH
81908: LD_INT 2
81910: NEG
81911: PUSH
81912: LD_INT 3
81914: NEG
81915: PUSH
81916: EMPTY
81917: LIST
81918: LIST
81919: PUSH
81920: LD_INT 3
81922: NEG
81923: PUSH
81924: LD_INT 2
81926: NEG
81927: PUSH
81928: EMPTY
81929: LIST
81930: LIST
81931: PUSH
81932: LD_INT 3
81934: NEG
81935: PUSH
81936: LD_INT 3
81938: NEG
81939: PUSH
81940: EMPTY
81941: LIST
81942: LIST
81943: PUSH
81944: EMPTY
81945: LIST
81946: LIST
81947: LIST
81948: ST_TO_ADDR
// fBunker0 = [ [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] ] ;
81949: LD_ADDR_VAR 0 59
81953: PUSH
81954: LD_INT 1
81956: NEG
81957: PUSH
81958: LD_INT 2
81960: NEG
81961: PUSH
81962: EMPTY
81963: LIST
81964: LIST
81965: PUSH
81966: LD_INT 0
81968: PUSH
81969: LD_INT 2
81971: NEG
81972: PUSH
81973: EMPTY
81974: LIST
81975: LIST
81976: PUSH
81977: LD_INT 1
81979: PUSH
81980: LD_INT 1
81982: NEG
81983: PUSH
81984: EMPTY
81985: LIST
81986: LIST
81987: PUSH
81988: EMPTY
81989: LIST
81990: LIST
81991: LIST
81992: ST_TO_ADDR
// fBunker1 = [ [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] ] ;
81993: LD_ADDR_VAR 0 60
81997: PUSH
81998: LD_INT 1
82000: PUSH
82001: LD_INT 1
82003: NEG
82004: PUSH
82005: EMPTY
82006: LIST
82007: LIST
82008: PUSH
82009: LD_INT 2
82011: PUSH
82012: LD_INT 0
82014: PUSH
82015: EMPTY
82016: LIST
82017: LIST
82018: PUSH
82019: LD_INT 2
82021: PUSH
82022: LD_INT 1
82024: PUSH
82025: EMPTY
82026: LIST
82027: LIST
82028: PUSH
82029: EMPTY
82030: LIST
82031: LIST
82032: LIST
82033: ST_TO_ADDR
// fBunker2 = [ [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] ] ;
82034: LD_ADDR_VAR 0 61
82038: PUSH
82039: LD_INT 2
82041: PUSH
82042: LD_INT 1
82044: PUSH
82045: EMPTY
82046: LIST
82047: LIST
82048: PUSH
82049: LD_INT 2
82051: PUSH
82052: LD_INT 2
82054: PUSH
82055: EMPTY
82056: LIST
82057: LIST
82058: PUSH
82059: LD_INT 1
82061: PUSH
82062: LD_INT 2
82064: PUSH
82065: EMPTY
82066: LIST
82067: LIST
82068: PUSH
82069: EMPTY
82070: LIST
82071: LIST
82072: LIST
82073: ST_TO_ADDR
// fBunker3 = [ [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] ] ;
82074: LD_ADDR_VAR 0 62
82078: PUSH
82079: LD_INT 1
82081: PUSH
82082: LD_INT 2
82084: PUSH
82085: EMPTY
82086: LIST
82087: LIST
82088: PUSH
82089: LD_INT 0
82091: PUSH
82092: LD_INT 2
82094: PUSH
82095: EMPTY
82096: LIST
82097: LIST
82098: PUSH
82099: LD_INT 1
82101: NEG
82102: PUSH
82103: LD_INT 1
82105: PUSH
82106: EMPTY
82107: LIST
82108: LIST
82109: PUSH
82110: EMPTY
82111: LIST
82112: LIST
82113: LIST
82114: ST_TO_ADDR
// fBunker4 = [ [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] ] ;
82115: LD_ADDR_VAR 0 63
82119: PUSH
82120: LD_INT 1
82122: NEG
82123: PUSH
82124: LD_INT 1
82126: PUSH
82127: EMPTY
82128: LIST
82129: LIST
82130: PUSH
82131: LD_INT 2
82133: NEG
82134: PUSH
82135: LD_INT 0
82137: PUSH
82138: EMPTY
82139: LIST
82140: LIST
82141: PUSH
82142: LD_INT 2
82144: NEG
82145: PUSH
82146: LD_INT 1
82148: NEG
82149: PUSH
82150: EMPTY
82151: LIST
82152: LIST
82153: PUSH
82154: EMPTY
82155: LIST
82156: LIST
82157: LIST
82158: ST_TO_ADDR
// fBunker5 = [ [ - 1 , - 2 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
82159: LD_ADDR_VAR 0 64
82163: PUSH
82164: LD_INT 1
82166: NEG
82167: PUSH
82168: LD_INT 2
82170: NEG
82171: PUSH
82172: EMPTY
82173: LIST
82174: LIST
82175: PUSH
82176: LD_INT 2
82178: NEG
82179: PUSH
82180: LD_INT 1
82182: NEG
82183: PUSH
82184: EMPTY
82185: LIST
82186: LIST
82187: PUSH
82188: LD_INT 2
82190: NEG
82191: PUSH
82192: LD_INT 2
82194: NEG
82195: PUSH
82196: EMPTY
82197: LIST
82198: LIST
82199: PUSH
82200: EMPTY
82201: LIST
82202: LIST
82203: LIST
82204: ST_TO_ADDR
// end ; 2 :
82205: GO 85471
82207: LD_INT 2
82209: DOUBLE
82210: EQUAL
82211: IFTRUE 82215
82213: GO 85470
82215: POP
// begin fFactory0 = [ [ 4 , 0 ] , [ 4 , - 1 ] , [ 5 , 0 ] , [ 5 , 1 ] , [ 4 , 1 ] , [ 3 , 0 ] , [ 3 , - 1 ] , [ 3 , - 2 ] , [ 5 , 2 ] , [ 3 , 3 ] , [ 3 , 2 ] , [ 4 , 3 ] , [ 4 , 4 ] , [ 3 , 4 ] , [ 2 , 3 ] , [ 2 , 2 ] , [ 4 , 2 ] , [ 2 , 4 ] , [ 0 , 4 ] , [ 0 , 3 ] , [ 1 , 4 ] , [ 1 , 5 ] , [ 0 , 5 ] , [ - 1 , 4 ] , [ - 1 , 3 ] , [ 2 , 5 ] , [ - 2 , 3 ] , [ - 3 , 0 ] , [ - 3 , - 1 ] , [ - 2 , 0 ] , [ - 2 , 1 ] , [ - 3 , 1 ] , [ - 4 , 0 ] , [ - 4 , - 1 ] , [ - 4 , - 2 ] , [ - 2 , 2 ] , [ - 4 , - 4 ] , [ - 4 , - 5 ] , [ - 3 , - 4 ] , [ - 3 , - 3 ] , [ - 4 , - 3 ] , [ - 5 , - 4 ] , [ - 5 , - 5 ] , [ - 3 , - 5 ] , [ - 5 , - 3 ] ] ;
82216: LD_ADDR_VAR 0 29
82220: PUSH
82221: LD_INT 4
82223: PUSH
82224: LD_INT 0
82226: PUSH
82227: EMPTY
82228: LIST
82229: LIST
82230: PUSH
82231: LD_INT 4
82233: PUSH
82234: LD_INT 1
82236: NEG
82237: PUSH
82238: EMPTY
82239: LIST
82240: LIST
82241: PUSH
82242: LD_INT 5
82244: PUSH
82245: LD_INT 0
82247: PUSH
82248: EMPTY
82249: LIST
82250: LIST
82251: PUSH
82252: LD_INT 5
82254: PUSH
82255: LD_INT 1
82257: PUSH
82258: EMPTY
82259: LIST
82260: LIST
82261: PUSH
82262: LD_INT 4
82264: PUSH
82265: LD_INT 1
82267: PUSH
82268: EMPTY
82269: LIST
82270: LIST
82271: PUSH
82272: LD_INT 3
82274: PUSH
82275: LD_INT 0
82277: PUSH
82278: EMPTY
82279: LIST
82280: LIST
82281: PUSH
82282: LD_INT 3
82284: PUSH
82285: LD_INT 1
82287: NEG
82288: PUSH
82289: EMPTY
82290: LIST
82291: LIST
82292: PUSH
82293: LD_INT 3
82295: PUSH
82296: LD_INT 2
82298: NEG
82299: PUSH
82300: EMPTY
82301: LIST
82302: LIST
82303: PUSH
82304: LD_INT 5
82306: PUSH
82307: LD_INT 2
82309: PUSH
82310: EMPTY
82311: LIST
82312: LIST
82313: PUSH
82314: LD_INT 3
82316: PUSH
82317: LD_INT 3
82319: PUSH
82320: EMPTY
82321: LIST
82322: LIST
82323: PUSH
82324: LD_INT 3
82326: PUSH
82327: LD_INT 2
82329: PUSH
82330: EMPTY
82331: LIST
82332: LIST
82333: PUSH
82334: LD_INT 4
82336: PUSH
82337: LD_INT 3
82339: PUSH
82340: EMPTY
82341: LIST
82342: LIST
82343: PUSH
82344: LD_INT 4
82346: PUSH
82347: LD_INT 4
82349: PUSH
82350: EMPTY
82351: LIST
82352: LIST
82353: PUSH
82354: LD_INT 3
82356: PUSH
82357: LD_INT 4
82359: PUSH
82360: EMPTY
82361: LIST
82362: LIST
82363: PUSH
82364: LD_INT 2
82366: PUSH
82367: LD_INT 3
82369: PUSH
82370: EMPTY
82371: LIST
82372: LIST
82373: PUSH
82374: LD_INT 2
82376: PUSH
82377: LD_INT 2
82379: PUSH
82380: EMPTY
82381: LIST
82382: LIST
82383: PUSH
82384: LD_INT 4
82386: PUSH
82387: LD_INT 2
82389: PUSH
82390: EMPTY
82391: LIST
82392: LIST
82393: PUSH
82394: LD_INT 2
82396: PUSH
82397: LD_INT 4
82399: PUSH
82400: EMPTY
82401: LIST
82402: LIST
82403: PUSH
82404: LD_INT 0
82406: PUSH
82407: LD_INT 4
82409: PUSH
82410: EMPTY
82411: LIST
82412: LIST
82413: PUSH
82414: LD_INT 0
82416: PUSH
82417: LD_INT 3
82419: PUSH
82420: EMPTY
82421: LIST
82422: LIST
82423: PUSH
82424: LD_INT 1
82426: PUSH
82427: LD_INT 4
82429: PUSH
82430: EMPTY
82431: LIST
82432: LIST
82433: PUSH
82434: LD_INT 1
82436: PUSH
82437: LD_INT 5
82439: PUSH
82440: EMPTY
82441: LIST
82442: LIST
82443: PUSH
82444: LD_INT 0
82446: PUSH
82447: LD_INT 5
82449: PUSH
82450: EMPTY
82451: LIST
82452: LIST
82453: PUSH
82454: LD_INT 1
82456: NEG
82457: PUSH
82458: LD_INT 4
82460: PUSH
82461: EMPTY
82462: LIST
82463: LIST
82464: PUSH
82465: LD_INT 1
82467: NEG
82468: PUSH
82469: LD_INT 3
82471: PUSH
82472: EMPTY
82473: LIST
82474: LIST
82475: PUSH
82476: LD_INT 2
82478: PUSH
82479: LD_INT 5
82481: PUSH
82482: EMPTY
82483: LIST
82484: LIST
82485: PUSH
82486: LD_INT 2
82488: NEG
82489: PUSH
82490: LD_INT 3
82492: PUSH
82493: EMPTY
82494: LIST
82495: LIST
82496: PUSH
82497: LD_INT 3
82499: NEG
82500: PUSH
82501: LD_INT 0
82503: PUSH
82504: EMPTY
82505: LIST
82506: LIST
82507: PUSH
82508: LD_INT 3
82510: NEG
82511: PUSH
82512: LD_INT 1
82514: NEG
82515: PUSH
82516: EMPTY
82517: LIST
82518: LIST
82519: PUSH
82520: LD_INT 2
82522: NEG
82523: PUSH
82524: LD_INT 0
82526: PUSH
82527: EMPTY
82528: LIST
82529: LIST
82530: PUSH
82531: LD_INT 2
82533: NEG
82534: PUSH
82535: LD_INT 1
82537: PUSH
82538: EMPTY
82539: LIST
82540: LIST
82541: PUSH
82542: LD_INT 3
82544: NEG
82545: PUSH
82546: LD_INT 1
82548: PUSH
82549: EMPTY
82550: LIST
82551: LIST
82552: PUSH
82553: LD_INT 4
82555: NEG
82556: PUSH
82557: LD_INT 0
82559: PUSH
82560: EMPTY
82561: LIST
82562: LIST
82563: PUSH
82564: LD_INT 4
82566: NEG
82567: PUSH
82568: LD_INT 1
82570: NEG
82571: PUSH
82572: EMPTY
82573: LIST
82574: LIST
82575: PUSH
82576: LD_INT 4
82578: NEG
82579: PUSH
82580: LD_INT 2
82582: NEG
82583: PUSH
82584: EMPTY
82585: LIST
82586: LIST
82587: PUSH
82588: LD_INT 2
82590: NEG
82591: PUSH
82592: LD_INT 2
82594: PUSH
82595: EMPTY
82596: LIST
82597: LIST
82598: PUSH
82599: LD_INT 4
82601: NEG
82602: PUSH
82603: LD_INT 4
82605: NEG
82606: PUSH
82607: EMPTY
82608: LIST
82609: LIST
82610: PUSH
82611: LD_INT 4
82613: NEG
82614: PUSH
82615: LD_INT 5
82617: NEG
82618: PUSH
82619: EMPTY
82620: LIST
82621: LIST
82622: PUSH
82623: LD_INT 3
82625: NEG
82626: PUSH
82627: LD_INT 4
82629: NEG
82630: PUSH
82631: EMPTY
82632: LIST
82633: LIST
82634: PUSH
82635: LD_INT 3
82637: NEG
82638: PUSH
82639: LD_INT 3
82641: NEG
82642: PUSH
82643: EMPTY
82644: LIST
82645: LIST
82646: PUSH
82647: LD_INT 4
82649: NEG
82650: PUSH
82651: LD_INT 3
82653: NEG
82654: PUSH
82655: EMPTY
82656: LIST
82657: LIST
82658: PUSH
82659: LD_INT 5
82661: NEG
82662: PUSH
82663: LD_INT 4
82665: NEG
82666: PUSH
82667: EMPTY
82668: LIST
82669: LIST
82670: PUSH
82671: LD_INT 5
82673: NEG
82674: PUSH
82675: LD_INT 5
82677: NEG
82678: PUSH
82679: EMPTY
82680: LIST
82681: LIST
82682: PUSH
82683: LD_INT 3
82685: NEG
82686: PUSH
82687: LD_INT 5
82689: NEG
82690: PUSH
82691: EMPTY
82692: LIST
82693: LIST
82694: PUSH
82695: LD_INT 5
82697: NEG
82698: PUSH
82699: LD_INT 3
82701: NEG
82702: PUSH
82703: EMPTY
82704: LIST
82705: LIST
82706: PUSH
82707: EMPTY
82708: LIST
82709: LIST
82710: LIST
82711: LIST
82712: LIST
82713: LIST
82714: LIST
82715: LIST
82716: LIST
82717: LIST
82718: LIST
82719: LIST
82720: LIST
82721: LIST
82722: LIST
82723: LIST
82724: LIST
82725: LIST
82726: LIST
82727: LIST
82728: LIST
82729: LIST
82730: LIST
82731: LIST
82732: LIST
82733: LIST
82734: LIST
82735: LIST
82736: LIST
82737: LIST
82738: LIST
82739: LIST
82740: LIST
82741: LIST
82742: LIST
82743: LIST
82744: LIST
82745: LIST
82746: LIST
82747: LIST
82748: LIST
82749: LIST
82750: LIST
82751: LIST
82752: LIST
82753: ST_TO_ADDR
// fFactory1 = [ [ 4 , 4 ] , [ 4 , 3 ] , [ 5 , 4 ] , [ 5 , 5 ] , [ 4 , 5 ] , [ 3 , 4 ] , [ 3 , 3 ] , [ 5 , 3 ] , [ 3 , 5 ] , [ 0 , 3 ] , [ 0 , 2 ] , [ 1 , 3 ] , [ 1 , 4 ] , [ 0 , 4 ] , [ - 1 , 3 ] , [ - 1 , 2 ] , [ 2 , 4 ] , [ - 2 , 2 ] , [ - 4 , 0 ] , [ - 4 , - 1 ] , [ - 3 , 0 ] , [ - 3 , 1 ] , [ - 4 , 1 ] , [ - 5 , 0 ] , [ - 5 , - 1 ] , [ - 5 , - 2 ] , [ - 3 , 2 ] , [ - 3 , - 3 ] , [ - 3 , - 4 ] , [ - 2 , - 3 ] , [ - 2 , - 2 ] , [ - 3 , - 2 ] , [ - 4 , - 3 ] , [ - 4 , - 4 ] , [ - 2 , - 4 ] , [ - 4 , - 2 ] , [ 0 , - 4 ] , [ 0 , - 5 ] , [ 1 , - 4 ] , [ 1 , - 3 ] , [ 0 , - 3 ] , [ - 1 , - 4 ] , [ - 1 , - 5 ] , [ 2 , - 3 ] , [ - 2 , - 5 ] ] ;
82754: LD_ADDR_VAR 0 30
82758: PUSH
82759: LD_INT 4
82761: PUSH
82762: LD_INT 4
82764: PUSH
82765: EMPTY
82766: LIST
82767: LIST
82768: PUSH
82769: LD_INT 4
82771: PUSH
82772: LD_INT 3
82774: PUSH
82775: EMPTY
82776: LIST
82777: LIST
82778: PUSH
82779: LD_INT 5
82781: PUSH
82782: LD_INT 4
82784: PUSH
82785: EMPTY
82786: LIST
82787: LIST
82788: PUSH
82789: LD_INT 5
82791: PUSH
82792: LD_INT 5
82794: PUSH
82795: EMPTY
82796: LIST
82797: LIST
82798: PUSH
82799: LD_INT 4
82801: PUSH
82802: LD_INT 5
82804: PUSH
82805: EMPTY
82806: LIST
82807: LIST
82808: PUSH
82809: LD_INT 3
82811: PUSH
82812: LD_INT 4
82814: PUSH
82815: EMPTY
82816: LIST
82817: LIST
82818: PUSH
82819: LD_INT 3
82821: PUSH
82822: LD_INT 3
82824: PUSH
82825: EMPTY
82826: LIST
82827: LIST
82828: PUSH
82829: LD_INT 5
82831: PUSH
82832: LD_INT 3
82834: PUSH
82835: EMPTY
82836: LIST
82837: LIST
82838: PUSH
82839: LD_INT 3
82841: PUSH
82842: LD_INT 5
82844: PUSH
82845: EMPTY
82846: LIST
82847: LIST
82848: PUSH
82849: LD_INT 0
82851: PUSH
82852: LD_INT 3
82854: PUSH
82855: EMPTY
82856: LIST
82857: LIST
82858: PUSH
82859: LD_INT 0
82861: PUSH
82862: LD_INT 2
82864: PUSH
82865: EMPTY
82866: LIST
82867: LIST
82868: PUSH
82869: LD_INT 1
82871: PUSH
82872: LD_INT 3
82874: PUSH
82875: EMPTY
82876: LIST
82877: LIST
82878: PUSH
82879: LD_INT 1
82881: PUSH
82882: LD_INT 4
82884: PUSH
82885: EMPTY
82886: LIST
82887: LIST
82888: PUSH
82889: LD_INT 0
82891: PUSH
82892: LD_INT 4
82894: PUSH
82895: EMPTY
82896: LIST
82897: LIST
82898: PUSH
82899: LD_INT 1
82901: NEG
82902: PUSH
82903: LD_INT 3
82905: PUSH
82906: EMPTY
82907: LIST
82908: LIST
82909: PUSH
82910: LD_INT 1
82912: NEG
82913: PUSH
82914: LD_INT 2
82916: PUSH
82917: EMPTY
82918: LIST
82919: LIST
82920: PUSH
82921: LD_INT 2
82923: PUSH
82924: LD_INT 4
82926: PUSH
82927: EMPTY
82928: LIST
82929: LIST
82930: PUSH
82931: LD_INT 2
82933: NEG
82934: PUSH
82935: LD_INT 2
82937: PUSH
82938: EMPTY
82939: LIST
82940: LIST
82941: PUSH
82942: LD_INT 4
82944: NEG
82945: PUSH
82946: LD_INT 0
82948: PUSH
82949: EMPTY
82950: LIST
82951: LIST
82952: PUSH
82953: LD_INT 4
82955: NEG
82956: PUSH
82957: LD_INT 1
82959: NEG
82960: PUSH
82961: EMPTY
82962: LIST
82963: LIST
82964: PUSH
82965: LD_INT 3
82967: NEG
82968: PUSH
82969: LD_INT 0
82971: PUSH
82972: EMPTY
82973: LIST
82974: LIST
82975: PUSH
82976: LD_INT 3
82978: NEG
82979: PUSH
82980: LD_INT 1
82982: PUSH
82983: EMPTY
82984: LIST
82985: LIST
82986: PUSH
82987: LD_INT 4
82989: NEG
82990: PUSH
82991: LD_INT 1
82993: PUSH
82994: EMPTY
82995: LIST
82996: LIST
82997: PUSH
82998: LD_INT 5
83000: NEG
83001: PUSH
83002: LD_INT 0
83004: PUSH
83005: EMPTY
83006: LIST
83007: LIST
83008: PUSH
83009: LD_INT 5
83011: NEG
83012: PUSH
83013: LD_INT 1
83015: NEG
83016: PUSH
83017: EMPTY
83018: LIST
83019: LIST
83020: PUSH
83021: LD_INT 5
83023: NEG
83024: PUSH
83025: LD_INT 2
83027: NEG
83028: PUSH
83029: EMPTY
83030: LIST
83031: LIST
83032: PUSH
83033: LD_INT 3
83035: NEG
83036: PUSH
83037: LD_INT 2
83039: PUSH
83040: EMPTY
83041: LIST
83042: LIST
83043: PUSH
83044: LD_INT 3
83046: NEG
83047: PUSH
83048: LD_INT 3
83050: NEG
83051: PUSH
83052: EMPTY
83053: LIST
83054: LIST
83055: PUSH
83056: LD_INT 3
83058: NEG
83059: PUSH
83060: LD_INT 4
83062: NEG
83063: PUSH
83064: EMPTY
83065: LIST
83066: LIST
83067: PUSH
83068: LD_INT 2
83070: NEG
83071: PUSH
83072: LD_INT 3
83074: NEG
83075: PUSH
83076: EMPTY
83077: LIST
83078: LIST
83079: PUSH
83080: LD_INT 2
83082: NEG
83083: PUSH
83084: LD_INT 2
83086: NEG
83087: PUSH
83088: EMPTY
83089: LIST
83090: LIST
83091: PUSH
83092: LD_INT 3
83094: NEG
83095: PUSH
83096: LD_INT 2
83098: NEG
83099: PUSH
83100: EMPTY
83101: LIST
83102: LIST
83103: PUSH
83104: LD_INT 4
83106: NEG
83107: PUSH
83108: LD_INT 3
83110: NEG
83111: PUSH
83112: EMPTY
83113: LIST
83114: LIST
83115: PUSH
83116: LD_INT 4
83118: NEG
83119: PUSH
83120: LD_INT 4
83122: NEG
83123: PUSH
83124: EMPTY
83125: LIST
83126: LIST
83127: PUSH
83128: LD_INT 2
83130: NEG
83131: PUSH
83132: LD_INT 4
83134: NEG
83135: PUSH
83136: EMPTY
83137: LIST
83138: LIST
83139: PUSH
83140: LD_INT 4
83142: NEG
83143: PUSH
83144: LD_INT 2
83146: NEG
83147: PUSH
83148: EMPTY
83149: LIST
83150: LIST
83151: PUSH
83152: LD_INT 0
83154: PUSH
83155: LD_INT 4
83157: NEG
83158: PUSH
83159: EMPTY
83160: LIST
83161: LIST
83162: PUSH
83163: LD_INT 0
83165: PUSH
83166: LD_INT 5
83168: NEG
83169: PUSH
83170: EMPTY
83171: LIST
83172: LIST
83173: PUSH
83174: LD_INT 1
83176: PUSH
83177: LD_INT 4
83179: NEG
83180: PUSH
83181: EMPTY
83182: LIST
83183: LIST
83184: PUSH
83185: LD_INT 1
83187: PUSH
83188: LD_INT 3
83190: NEG
83191: PUSH
83192: EMPTY
83193: LIST
83194: LIST
83195: PUSH
83196: LD_INT 0
83198: PUSH
83199: LD_INT 3
83201: NEG
83202: PUSH
83203: EMPTY
83204: LIST
83205: LIST
83206: PUSH
83207: LD_INT 1
83209: NEG
83210: PUSH
83211: LD_INT 4
83213: NEG
83214: PUSH
83215: EMPTY
83216: LIST
83217: LIST
83218: PUSH
83219: LD_INT 1
83221: NEG
83222: PUSH
83223: LD_INT 5
83225: NEG
83226: PUSH
83227: EMPTY
83228: LIST
83229: LIST
83230: PUSH
83231: LD_INT 2
83233: PUSH
83234: LD_INT 3
83236: NEG
83237: PUSH
83238: EMPTY
83239: LIST
83240: LIST
83241: PUSH
83242: LD_INT 2
83244: NEG
83245: PUSH
83246: LD_INT 5
83248: NEG
83249: PUSH
83250: EMPTY
83251: LIST
83252: LIST
83253: PUSH
83254: EMPTY
83255: LIST
83256: LIST
83257: LIST
83258: LIST
83259: LIST
83260: LIST
83261: LIST
83262: LIST
83263: LIST
83264: LIST
83265: LIST
83266: LIST
83267: LIST
83268: LIST
83269: LIST
83270: LIST
83271: LIST
83272: LIST
83273: LIST
83274: LIST
83275: LIST
83276: LIST
83277: LIST
83278: LIST
83279: LIST
83280: LIST
83281: LIST
83282: LIST
83283: LIST
83284: LIST
83285: LIST
83286: LIST
83287: LIST
83288: LIST
83289: LIST
83290: LIST
83291: LIST
83292: LIST
83293: LIST
83294: LIST
83295: LIST
83296: LIST
83297: LIST
83298: LIST
83299: LIST
83300: ST_TO_ADDR
// fFactory2 = [ [ 0 , 4 ] , [ 0 , 3 ] , [ 1 , 4 ] , [ 1 , 5 ] , [ 0 , 5 ] , [ - 1 , 4 ] , [ - 1 , 3 ] , [ 2 , 5 ] , [ - 2 , 3 ] , [ - 3 , 0 ] , [ - 3 , - 1 ] , [ - 2 , 0 ] , [ - 2 , 1 ] , [ - 3 , 1 ] , [ - 4 , 0 ] , [ - 4 , - 1 ] , [ - 4 , - 2 ] , [ - 2 , 2 ] , [ - 4 , - 4 ] , [ - 4 , - 5 ] , [ - 3 , - 4 ] , [ - 3 , - 3 ] , [ - 4 , - 3 ] , [ - 5 , - 4 ] , [ - 5 , - 5 ] , [ - 3 , - 5 ] , [ - 5 , - 3 ] , [ 0 , - 3 ] , [ 0 , - 4 ] , [ 1 , - 3 ] , [ 1 , - 2 ] , [ 0 , - 2 ] , [ - 1 , - 3 ] , [ - 1 , - 4 ] , [ 2 , - 2 ] , [ - 2 , - 4 ] , [ 4 , 0 ] , [ 4 , - 1 ] , [ 5 , 0 ] , [ 5 , 1 ] , [ 4 , 1 ] , [ 3 , 0 ] , [ 3 , - 1 ] , [ 3 , - 2 ] , [ 5 , 2 ] ] ;
83301: LD_ADDR_VAR 0 31
83305: PUSH
83306: LD_INT 0
83308: PUSH
83309: LD_INT 4
83311: PUSH
83312: EMPTY
83313: LIST
83314: LIST
83315: PUSH
83316: LD_INT 0
83318: PUSH
83319: LD_INT 3
83321: PUSH
83322: EMPTY
83323: LIST
83324: LIST
83325: PUSH
83326: LD_INT 1
83328: PUSH
83329: LD_INT 4
83331: PUSH
83332: EMPTY
83333: LIST
83334: LIST
83335: PUSH
83336: LD_INT 1
83338: PUSH
83339: LD_INT 5
83341: PUSH
83342: EMPTY
83343: LIST
83344: LIST
83345: PUSH
83346: LD_INT 0
83348: PUSH
83349: LD_INT 5
83351: PUSH
83352: EMPTY
83353: LIST
83354: LIST
83355: PUSH
83356: LD_INT 1
83358: NEG
83359: PUSH
83360: LD_INT 4
83362: PUSH
83363: EMPTY
83364: LIST
83365: LIST
83366: PUSH
83367: LD_INT 1
83369: NEG
83370: PUSH
83371: LD_INT 3
83373: PUSH
83374: EMPTY
83375: LIST
83376: LIST
83377: PUSH
83378: LD_INT 2
83380: PUSH
83381: LD_INT 5
83383: PUSH
83384: EMPTY
83385: LIST
83386: LIST
83387: PUSH
83388: LD_INT 2
83390: NEG
83391: PUSH
83392: LD_INT 3
83394: PUSH
83395: EMPTY
83396: LIST
83397: LIST
83398: PUSH
83399: LD_INT 3
83401: NEG
83402: PUSH
83403: LD_INT 0
83405: PUSH
83406: EMPTY
83407: LIST
83408: LIST
83409: PUSH
83410: LD_INT 3
83412: NEG
83413: PUSH
83414: LD_INT 1
83416: NEG
83417: PUSH
83418: EMPTY
83419: LIST
83420: LIST
83421: PUSH
83422: LD_INT 2
83424: NEG
83425: PUSH
83426: LD_INT 0
83428: PUSH
83429: EMPTY
83430: LIST
83431: LIST
83432: PUSH
83433: LD_INT 2
83435: NEG
83436: PUSH
83437: LD_INT 1
83439: PUSH
83440: EMPTY
83441: LIST
83442: LIST
83443: PUSH
83444: LD_INT 3
83446: NEG
83447: PUSH
83448: LD_INT 1
83450: PUSH
83451: EMPTY
83452: LIST
83453: LIST
83454: PUSH
83455: LD_INT 4
83457: NEG
83458: PUSH
83459: LD_INT 0
83461: PUSH
83462: EMPTY
83463: LIST
83464: LIST
83465: PUSH
83466: LD_INT 4
83468: NEG
83469: PUSH
83470: LD_INT 1
83472: NEG
83473: PUSH
83474: EMPTY
83475: LIST
83476: LIST
83477: PUSH
83478: LD_INT 4
83480: NEG
83481: PUSH
83482: LD_INT 2
83484: NEG
83485: PUSH
83486: EMPTY
83487: LIST
83488: LIST
83489: PUSH
83490: LD_INT 2
83492: NEG
83493: PUSH
83494: LD_INT 2
83496: PUSH
83497: EMPTY
83498: LIST
83499: LIST
83500: PUSH
83501: LD_INT 4
83503: NEG
83504: PUSH
83505: LD_INT 4
83507: NEG
83508: PUSH
83509: EMPTY
83510: LIST
83511: LIST
83512: PUSH
83513: LD_INT 4
83515: NEG
83516: PUSH
83517: LD_INT 5
83519: NEG
83520: PUSH
83521: EMPTY
83522: LIST
83523: LIST
83524: PUSH
83525: LD_INT 3
83527: NEG
83528: PUSH
83529: LD_INT 4
83531: NEG
83532: PUSH
83533: EMPTY
83534: LIST
83535: LIST
83536: PUSH
83537: LD_INT 3
83539: NEG
83540: PUSH
83541: LD_INT 3
83543: NEG
83544: PUSH
83545: EMPTY
83546: LIST
83547: LIST
83548: PUSH
83549: LD_INT 4
83551: NEG
83552: PUSH
83553: LD_INT 3
83555: NEG
83556: PUSH
83557: EMPTY
83558: LIST
83559: LIST
83560: PUSH
83561: LD_INT 5
83563: NEG
83564: PUSH
83565: LD_INT 4
83567: NEG
83568: PUSH
83569: EMPTY
83570: LIST
83571: LIST
83572: PUSH
83573: LD_INT 5
83575: NEG
83576: PUSH
83577: LD_INT 5
83579: NEG
83580: PUSH
83581: EMPTY
83582: LIST
83583: LIST
83584: PUSH
83585: LD_INT 3
83587: NEG
83588: PUSH
83589: LD_INT 5
83591: NEG
83592: PUSH
83593: EMPTY
83594: LIST
83595: LIST
83596: PUSH
83597: LD_INT 5
83599: NEG
83600: PUSH
83601: LD_INT 3
83603: NEG
83604: PUSH
83605: EMPTY
83606: LIST
83607: LIST
83608: PUSH
83609: LD_INT 0
83611: PUSH
83612: LD_INT 3
83614: NEG
83615: PUSH
83616: EMPTY
83617: LIST
83618: LIST
83619: PUSH
83620: LD_INT 0
83622: PUSH
83623: LD_INT 4
83625: NEG
83626: PUSH
83627: EMPTY
83628: LIST
83629: LIST
83630: PUSH
83631: LD_INT 1
83633: PUSH
83634: LD_INT 3
83636: NEG
83637: PUSH
83638: EMPTY
83639: LIST
83640: LIST
83641: PUSH
83642: LD_INT 1
83644: PUSH
83645: LD_INT 2
83647: NEG
83648: PUSH
83649: EMPTY
83650: LIST
83651: LIST
83652: PUSH
83653: LD_INT 0
83655: PUSH
83656: LD_INT 2
83658: NEG
83659: PUSH
83660: EMPTY
83661: LIST
83662: LIST
83663: PUSH
83664: LD_INT 1
83666: NEG
83667: PUSH
83668: LD_INT 3
83670: NEG
83671: PUSH
83672: EMPTY
83673: LIST
83674: LIST
83675: PUSH
83676: LD_INT 1
83678: NEG
83679: PUSH
83680: LD_INT 4
83682: NEG
83683: PUSH
83684: EMPTY
83685: LIST
83686: LIST
83687: PUSH
83688: LD_INT 2
83690: PUSH
83691: LD_INT 2
83693: NEG
83694: PUSH
83695: EMPTY
83696: LIST
83697: LIST
83698: PUSH
83699: LD_INT 2
83701: NEG
83702: PUSH
83703: LD_INT 4
83705: NEG
83706: PUSH
83707: EMPTY
83708: LIST
83709: LIST
83710: PUSH
83711: LD_INT 4
83713: PUSH
83714: LD_INT 0
83716: PUSH
83717: EMPTY
83718: LIST
83719: LIST
83720: PUSH
83721: LD_INT 4
83723: PUSH
83724: LD_INT 1
83726: NEG
83727: PUSH
83728: EMPTY
83729: LIST
83730: LIST
83731: PUSH
83732: LD_INT 5
83734: PUSH
83735: LD_INT 0
83737: PUSH
83738: EMPTY
83739: LIST
83740: LIST
83741: PUSH
83742: LD_INT 5
83744: PUSH
83745: LD_INT 1
83747: PUSH
83748: EMPTY
83749: LIST
83750: LIST
83751: PUSH
83752: LD_INT 4
83754: PUSH
83755: LD_INT 1
83757: PUSH
83758: EMPTY
83759: LIST
83760: LIST
83761: PUSH
83762: LD_INT 3
83764: PUSH
83765: LD_INT 0
83767: PUSH
83768: EMPTY
83769: LIST
83770: LIST
83771: PUSH
83772: LD_INT 3
83774: PUSH
83775: LD_INT 1
83777: NEG
83778: PUSH
83779: EMPTY
83780: LIST
83781: LIST
83782: PUSH
83783: LD_INT 3
83785: PUSH
83786: LD_INT 2
83788: NEG
83789: PUSH
83790: EMPTY
83791: LIST
83792: LIST
83793: PUSH
83794: LD_INT 5
83796: PUSH
83797: LD_INT 2
83799: PUSH
83800: EMPTY
83801: LIST
83802: LIST
83803: PUSH
83804: EMPTY
83805: LIST
83806: LIST
83807: LIST
83808: LIST
83809: LIST
83810: LIST
83811: LIST
83812: LIST
83813: LIST
83814: LIST
83815: LIST
83816: LIST
83817: LIST
83818: LIST
83819: LIST
83820: LIST
83821: LIST
83822: LIST
83823: LIST
83824: LIST
83825: LIST
83826: LIST
83827: LIST
83828: LIST
83829: LIST
83830: LIST
83831: LIST
83832: LIST
83833: LIST
83834: LIST
83835: LIST
83836: LIST
83837: LIST
83838: LIST
83839: LIST
83840: LIST
83841: LIST
83842: LIST
83843: LIST
83844: LIST
83845: LIST
83846: LIST
83847: LIST
83848: LIST
83849: LIST
83850: ST_TO_ADDR
// fFactory3 = [ [ - 4 , 0 ] , [ - 4 , - 1 ] , [ - 3 , 0 ] , [ - 3 , 1 ] , [ - 4 , 1 ] , [ - 5 , 0 ] , [ - 5 , - 1 ] , [ - 5 , - 2 ] , [ - 3 , 2 ] , [ - 3 , - 3 ] , [ - 3 , - 4 ] , [ - 2 , - 3 ] , [ - 2 , - 2 ] , [ - 3 , - 2 ] , [ - 4 , - 3 ] , [ - 4 , - 4 ] , [ - 2 , - 4 ] , [ - 4 , - 2 ] , [ 0 , - 4 ] , [ 0 , - 5 ] , [ 1 , - 4 ] , [ 1 , - 3 ] , [ 0 , - 3 ] , [ - 1 , - 4 ] , [ - 1 , - 5 ] , [ 2 , - 3 ] , [ - 2 , - 5 ] , [ 3 , 0 ] , [ 3 , - 1 ] , [ 4 , 0 ] , [ 4 , 1 ] , [ 3 , 1 ] , [ 2 , 0 ] , [ 2 , - 1 ] , [ 2 , - 2 ] , [ 4 , 2 ] , [ 4 , 4 ] , [ 4 , 3 ] , [ 5 , 4 ] , [ 5 , 5 ] , [ 4 , 5 ] , [ 3 , 4 ] , [ 3 , 3 ] , [ 5 , 3 ] , [ 3 , 5 ] ] ;
83851: LD_ADDR_VAR 0 32
83855: PUSH
83856: LD_INT 4
83858: NEG
83859: PUSH
83860: LD_INT 0
83862: PUSH
83863: EMPTY
83864: LIST
83865: LIST
83866: PUSH
83867: LD_INT 4
83869: NEG
83870: PUSH
83871: LD_INT 1
83873: NEG
83874: PUSH
83875: EMPTY
83876: LIST
83877: LIST
83878: PUSH
83879: LD_INT 3
83881: NEG
83882: PUSH
83883: LD_INT 0
83885: PUSH
83886: EMPTY
83887: LIST
83888: LIST
83889: PUSH
83890: LD_INT 3
83892: NEG
83893: PUSH
83894: LD_INT 1
83896: PUSH
83897: EMPTY
83898: LIST
83899: LIST
83900: PUSH
83901: LD_INT 4
83903: NEG
83904: PUSH
83905: LD_INT 1
83907: PUSH
83908: EMPTY
83909: LIST
83910: LIST
83911: PUSH
83912: LD_INT 5
83914: NEG
83915: PUSH
83916: LD_INT 0
83918: PUSH
83919: EMPTY
83920: LIST
83921: LIST
83922: PUSH
83923: LD_INT 5
83925: NEG
83926: PUSH
83927: LD_INT 1
83929: NEG
83930: PUSH
83931: EMPTY
83932: LIST
83933: LIST
83934: PUSH
83935: LD_INT 5
83937: NEG
83938: PUSH
83939: LD_INT 2
83941: NEG
83942: PUSH
83943: EMPTY
83944: LIST
83945: LIST
83946: PUSH
83947: LD_INT 3
83949: NEG
83950: PUSH
83951: LD_INT 2
83953: PUSH
83954: EMPTY
83955: LIST
83956: LIST
83957: PUSH
83958: LD_INT 3
83960: NEG
83961: PUSH
83962: LD_INT 3
83964: NEG
83965: PUSH
83966: EMPTY
83967: LIST
83968: LIST
83969: PUSH
83970: LD_INT 3
83972: NEG
83973: PUSH
83974: LD_INT 4
83976: NEG
83977: PUSH
83978: EMPTY
83979: LIST
83980: LIST
83981: PUSH
83982: LD_INT 2
83984: NEG
83985: PUSH
83986: LD_INT 3
83988: NEG
83989: PUSH
83990: EMPTY
83991: LIST
83992: LIST
83993: PUSH
83994: LD_INT 2
83996: NEG
83997: PUSH
83998: LD_INT 2
84000: NEG
84001: PUSH
84002: EMPTY
84003: LIST
84004: LIST
84005: PUSH
84006: LD_INT 3
84008: NEG
84009: PUSH
84010: LD_INT 2
84012: NEG
84013: PUSH
84014: EMPTY
84015: LIST
84016: LIST
84017: PUSH
84018: LD_INT 4
84020: NEG
84021: PUSH
84022: LD_INT 3
84024: NEG
84025: PUSH
84026: EMPTY
84027: LIST
84028: LIST
84029: PUSH
84030: LD_INT 4
84032: NEG
84033: PUSH
84034: LD_INT 4
84036: NEG
84037: PUSH
84038: EMPTY
84039: LIST
84040: LIST
84041: PUSH
84042: LD_INT 2
84044: NEG
84045: PUSH
84046: LD_INT 4
84048: NEG
84049: PUSH
84050: EMPTY
84051: LIST
84052: LIST
84053: PUSH
84054: LD_INT 4
84056: NEG
84057: PUSH
84058: LD_INT 2
84060: NEG
84061: PUSH
84062: EMPTY
84063: LIST
84064: LIST
84065: PUSH
84066: LD_INT 0
84068: PUSH
84069: LD_INT 4
84071: NEG
84072: PUSH
84073: EMPTY
84074: LIST
84075: LIST
84076: PUSH
84077: LD_INT 0
84079: PUSH
84080: LD_INT 5
84082: NEG
84083: PUSH
84084: EMPTY
84085: LIST
84086: LIST
84087: PUSH
84088: LD_INT 1
84090: PUSH
84091: LD_INT 4
84093: NEG
84094: PUSH
84095: EMPTY
84096: LIST
84097: LIST
84098: PUSH
84099: LD_INT 1
84101: PUSH
84102: LD_INT 3
84104: NEG
84105: PUSH
84106: EMPTY
84107: LIST
84108: LIST
84109: PUSH
84110: LD_INT 0
84112: PUSH
84113: LD_INT 3
84115: NEG
84116: PUSH
84117: EMPTY
84118: LIST
84119: LIST
84120: PUSH
84121: LD_INT 1
84123: NEG
84124: PUSH
84125: LD_INT 4
84127: NEG
84128: PUSH
84129: EMPTY
84130: LIST
84131: LIST
84132: PUSH
84133: LD_INT 1
84135: NEG
84136: PUSH
84137: LD_INT 5
84139: NEG
84140: PUSH
84141: EMPTY
84142: LIST
84143: LIST
84144: PUSH
84145: LD_INT 2
84147: PUSH
84148: LD_INT 3
84150: NEG
84151: PUSH
84152: EMPTY
84153: LIST
84154: LIST
84155: PUSH
84156: LD_INT 2
84158: NEG
84159: PUSH
84160: LD_INT 5
84162: NEG
84163: PUSH
84164: EMPTY
84165: LIST
84166: LIST
84167: PUSH
84168: LD_INT 3
84170: PUSH
84171: LD_INT 0
84173: PUSH
84174: EMPTY
84175: LIST
84176: LIST
84177: PUSH
84178: LD_INT 3
84180: PUSH
84181: LD_INT 1
84183: NEG
84184: PUSH
84185: EMPTY
84186: LIST
84187: LIST
84188: PUSH
84189: LD_INT 4
84191: PUSH
84192: LD_INT 0
84194: PUSH
84195: EMPTY
84196: LIST
84197: LIST
84198: PUSH
84199: LD_INT 4
84201: PUSH
84202: LD_INT 1
84204: PUSH
84205: EMPTY
84206: LIST
84207: LIST
84208: PUSH
84209: LD_INT 3
84211: PUSH
84212: LD_INT 1
84214: PUSH
84215: EMPTY
84216: LIST
84217: LIST
84218: PUSH
84219: LD_INT 2
84221: PUSH
84222: LD_INT 0
84224: PUSH
84225: EMPTY
84226: LIST
84227: LIST
84228: PUSH
84229: LD_INT 2
84231: PUSH
84232: LD_INT 1
84234: NEG
84235: PUSH
84236: EMPTY
84237: LIST
84238: LIST
84239: PUSH
84240: LD_INT 2
84242: PUSH
84243: LD_INT 2
84245: NEG
84246: PUSH
84247: EMPTY
84248: LIST
84249: LIST
84250: PUSH
84251: LD_INT 4
84253: PUSH
84254: LD_INT 2
84256: PUSH
84257: EMPTY
84258: LIST
84259: LIST
84260: PUSH
84261: LD_INT 4
84263: PUSH
84264: LD_INT 4
84266: PUSH
84267: EMPTY
84268: LIST
84269: LIST
84270: PUSH
84271: LD_INT 4
84273: PUSH
84274: LD_INT 3
84276: PUSH
84277: EMPTY
84278: LIST
84279: LIST
84280: PUSH
84281: LD_INT 5
84283: PUSH
84284: LD_INT 4
84286: PUSH
84287: EMPTY
84288: LIST
84289: LIST
84290: PUSH
84291: LD_INT 5
84293: PUSH
84294: LD_INT 5
84296: PUSH
84297: EMPTY
84298: LIST
84299: LIST
84300: PUSH
84301: LD_INT 4
84303: PUSH
84304: LD_INT 5
84306: PUSH
84307: EMPTY
84308: LIST
84309: LIST
84310: PUSH
84311: LD_INT 3
84313: PUSH
84314: LD_INT 4
84316: PUSH
84317: EMPTY
84318: LIST
84319: LIST
84320: PUSH
84321: LD_INT 3
84323: PUSH
84324: LD_INT 3
84326: PUSH
84327: EMPTY
84328: LIST
84329: LIST
84330: PUSH
84331: LD_INT 5
84333: PUSH
84334: LD_INT 3
84336: PUSH
84337: EMPTY
84338: LIST
84339: LIST
84340: PUSH
84341: LD_INT 3
84343: PUSH
84344: LD_INT 5
84346: PUSH
84347: EMPTY
84348: LIST
84349: LIST
84350: PUSH
84351: EMPTY
84352: LIST
84353: LIST
84354: LIST
84355: LIST
84356: LIST
84357: LIST
84358: LIST
84359: LIST
84360: LIST
84361: LIST
84362: LIST
84363: LIST
84364: LIST
84365: LIST
84366: LIST
84367: LIST
84368: LIST
84369: LIST
84370: LIST
84371: LIST
84372: LIST
84373: LIST
84374: LIST
84375: LIST
84376: LIST
84377: LIST
84378: LIST
84379: LIST
84380: LIST
84381: LIST
84382: LIST
84383: LIST
84384: LIST
84385: LIST
84386: LIST
84387: LIST
84388: LIST
84389: LIST
84390: LIST
84391: LIST
84392: LIST
84393: LIST
84394: LIST
84395: LIST
84396: LIST
84397: ST_TO_ADDR
// fFactory4 = [ [ - 4 , - 4 ] , [ - 4 , - 5 ] , [ - 3 , - 4 ] , [ - 3 , - 3 ] , [ - 4 , - 3 ] , [ - 5 , - 4 ] , [ - 5 , - 5 ] , [ - 3 , - 5 ] , [ - 5 , - 3 ] , [ 0 , - 3 ] , [ 0 , - 4 ] , [ 1 , - 3 ] , [ 1 , - 2 ] , [ 0 , - 2 ] , [ - 1 , - 3 ] , [ - 1 , - 4 ] , [ 2 , - 2 ] , [ - 2 , - 4 ] , [ 4 , 0 ] , [ 4 , - 1 ] , [ 5 , 0 ] , [ 5 , 1 ] , [ 4 , 1 ] , [ 3 , 0 ] , [ 3 , - 1 ] , [ 3 , - 2 ] , [ 5 , 2 ] , [ 3 , 3 ] , [ 3 , 2 ] , [ 4 , 3 ] , [ 4 , 4 ] , [ 3 , 4 ] , [ 2 , 3 ] , [ 2 , 2 ] , [ 4 , 2 ] , [ 2 , 4 ] , [ 0 , 4 ] , [ 0 , 3 ] , [ 1 , 4 ] , [ 1 , 5 ] , [ 0 , 5 ] , [ - 1 , 4 ] , [ - 1 , 3 ] , [ 2 , 5 ] , [ - 2 , 3 ] ] ;
84398: LD_ADDR_VAR 0 33
84402: PUSH
84403: LD_INT 4
84405: NEG
84406: PUSH
84407: LD_INT 4
84409: NEG
84410: PUSH
84411: EMPTY
84412: LIST
84413: LIST
84414: PUSH
84415: LD_INT 4
84417: NEG
84418: PUSH
84419: LD_INT 5
84421: NEG
84422: PUSH
84423: EMPTY
84424: LIST
84425: LIST
84426: PUSH
84427: LD_INT 3
84429: NEG
84430: PUSH
84431: LD_INT 4
84433: NEG
84434: PUSH
84435: EMPTY
84436: LIST
84437: LIST
84438: PUSH
84439: LD_INT 3
84441: NEG
84442: PUSH
84443: LD_INT 3
84445: NEG
84446: PUSH
84447: EMPTY
84448: LIST
84449: LIST
84450: PUSH
84451: LD_INT 4
84453: NEG
84454: PUSH
84455: LD_INT 3
84457: NEG
84458: PUSH
84459: EMPTY
84460: LIST
84461: LIST
84462: PUSH
84463: LD_INT 5
84465: NEG
84466: PUSH
84467: LD_INT 4
84469: NEG
84470: PUSH
84471: EMPTY
84472: LIST
84473: LIST
84474: PUSH
84475: LD_INT 5
84477: NEG
84478: PUSH
84479: LD_INT 5
84481: NEG
84482: PUSH
84483: EMPTY
84484: LIST
84485: LIST
84486: PUSH
84487: LD_INT 3
84489: NEG
84490: PUSH
84491: LD_INT 5
84493: NEG
84494: PUSH
84495: EMPTY
84496: LIST
84497: LIST
84498: PUSH
84499: LD_INT 5
84501: NEG
84502: PUSH
84503: LD_INT 3
84505: NEG
84506: PUSH
84507: EMPTY
84508: LIST
84509: LIST
84510: PUSH
84511: LD_INT 0
84513: PUSH
84514: LD_INT 3
84516: NEG
84517: PUSH
84518: EMPTY
84519: LIST
84520: LIST
84521: PUSH
84522: LD_INT 0
84524: PUSH
84525: LD_INT 4
84527: NEG
84528: PUSH
84529: EMPTY
84530: LIST
84531: LIST
84532: PUSH
84533: LD_INT 1
84535: PUSH
84536: LD_INT 3
84538: NEG
84539: PUSH
84540: EMPTY
84541: LIST
84542: LIST
84543: PUSH
84544: LD_INT 1
84546: PUSH
84547: LD_INT 2
84549: NEG
84550: PUSH
84551: EMPTY
84552: LIST
84553: LIST
84554: PUSH
84555: LD_INT 0
84557: PUSH
84558: LD_INT 2
84560: NEG
84561: PUSH
84562: EMPTY
84563: LIST
84564: LIST
84565: PUSH
84566: LD_INT 1
84568: NEG
84569: PUSH
84570: LD_INT 3
84572: NEG
84573: PUSH
84574: EMPTY
84575: LIST
84576: LIST
84577: PUSH
84578: LD_INT 1
84580: NEG
84581: PUSH
84582: LD_INT 4
84584: NEG
84585: PUSH
84586: EMPTY
84587: LIST
84588: LIST
84589: PUSH
84590: LD_INT 2
84592: PUSH
84593: LD_INT 2
84595: NEG
84596: PUSH
84597: EMPTY
84598: LIST
84599: LIST
84600: PUSH
84601: LD_INT 2
84603: NEG
84604: PUSH
84605: LD_INT 4
84607: NEG
84608: PUSH
84609: EMPTY
84610: LIST
84611: LIST
84612: PUSH
84613: LD_INT 4
84615: PUSH
84616: LD_INT 0
84618: PUSH
84619: EMPTY
84620: LIST
84621: LIST
84622: PUSH
84623: LD_INT 4
84625: PUSH
84626: LD_INT 1
84628: NEG
84629: PUSH
84630: EMPTY
84631: LIST
84632: LIST
84633: PUSH
84634: LD_INT 5
84636: PUSH
84637: LD_INT 0
84639: PUSH
84640: EMPTY
84641: LIST
84642: LIST
84643: PUSH
84644: LD_INT 5
84646: PUSH
84647: LD_INT 1
84649: PUSH
84650: EMPTY
84651: LIST
84652: LIST
84653: PUSH
84654: LD_INT 4
84656: PUSH
84657: LD_INT 1
84659: PUSH
84660: EMPTY
84661: LIST
84662: LIST
84663: PUSH
84664: LD_INT 3
84666: PUSH
84667: LD_INT 0
84669: PUSH
84670: EMPTY
84671: LIST
84672: LIST
84673: PUSH
84674: LD_INT 3
84676: PUSH
84677: LD_INT 1
84679: NEG
84680: PUSH
84681: EMPTY
84682: LIST
84683: LIST
84684: PUSH
84685: LD_INT 3
84687: PUSH
84688: LD_INT 2
84690: NEG
84691: PUSH
84692: EMPTY
84693: LIST
84694: LIST
84695: PUSH
84696: LD_INT 5
84698: PUSH
84699: LD_INT 2
84701: PUSH
84702: EMPTY
84703: LIST
84704: LIST
84705: PUSH
84706: LD_INT 3
84708: PUSH
84709: LD_INT 3
84711: PUSH
84712: EMPTY
84713: LIST
84714: LIST
84715: PUSH
84716: LD_INT 3
84718: PUSH
84719: LD_INT 2
84721: PUSH
84722: EMPTY
84723: LIST
84724: LIST
84725: PUSH
84726: LD_INT 4
84728: PUSH
84729: LD_INT 3
84731: PUSH
84732: EMPTY
84733: LIST
84734: LIST
84735: PUSH
84736: LD_INT 4
84738: PUSH
84739: LD_INT 4
84741: PUSH
84742: EMPTY
84743: LIST
84744: LIST
84745: PUSH
84746: LD_INT 3
84748: PUSH
84749: LD_INT 4
84751: PUSH
84752: EMPTY
84753: LIST
84754: LIST
84755: PUSH
84756: LD_INT 2
84758: PUSH
84759: LD_INT 3
84761: PUSH
84762: EMPTY
84763: LIST
84764: LIST
84765: PUSH
84766: LD_INT 2
84768: PUSH
84769: LD_INT 2
84771: PUSH
84772: EMPTY
84773: LIST
84774: LIST
84775: PUSH
84776: LD_INT 4
84778: PUSH
84779: LD_INT 2
84781: PUSH
84782: EMPTY
84783: LIST
84784: LIST
84785: PUSH
84786: LD_INT 2
84788: PUSH
84789: LD_INT 4
84791: PUSH
84792: EMPTY
84793: LIST
84794: LIST
84795: PUSH
84796: LD_INT 0
84798: PUSH
84799: LD_INT 4
84801: PUSH
84802: EMPTY
84803: LIST
84804: LIST
84805: PUSH
84806: LD_INT 0
84808: PUSH
84809: LD_INT 3
84811: PUSH
84812: EMPTY
84813: LIST
84814: LIST
84815: PUSH
84816: LD_INT 1
84818: PUSH
84819: LD_INT 4
84821: PUSH
84822: EMPTY
84823: LIST
84824: LIST
84825: PUSH
84826: LD_INT 1
84828: PUSH
84829: LD_INT 5
84831: PUSH
84832: EMPTY
84833: LIST
84834: LIST
84835: PUSH
84836: LD_INT 0
84838: PUSH
84839: LD_INT 5
84841: PUSH
84842: EMPTY
84843: LIST
84844: LIST
84845: PUSH
84846: LD_INT 1
84848: NEG
84849: PUSH
84850: LD_INT 4
84852: PUSH
84853: EMPTY
84854: LIST
84855: LIST
84856: PUSH
84857: LD_INT 1
84859: NEG
84860: PUSH
84861: LD_INT 3
84863: PUSH
84864: EMPTY
84865: LIST
84866: LIST
84867: PUSH
84868: LD_INT 2
84870: PUSH
84871: LD_INT 5
84873: PUSH
84874: EMPTY
84875: LIST
84876: LIST
84877: PUSH
84878: LD_INT 2
84880: NEG
84881: PUSH
84882: LD_INT 3
84884: PUSH
84885: EMPTY
84886: LIST
84887: LIST
84888: PUSH
84889: EMPTY
84890: LIST
84891: LIST
84892: LIST
84893: LIST
84894: LIST
84895: LIST
84896: LIST
84897: LIST
84898: LIST
84899: LIST
84900: LIST
84901: LIST
84902: LIST
84903: LIST
84904: LIST
84905: LIST
84906: LIST
84907: LIST
84908: LIST
84909: LIST
84910: LIST
84911: LIST
84912: LIST
84913: LIST
84914: LIST
84915: LIST
84916: LIST
84917: LIST
84918: LIST
84919: LIST
84920: LIST
84921: LIST
84922: LIST
84923: LIST
84924: LIST
84925: LIST
84926: LIST
84927: LIST
84928: LIST
84929: LIST
84930: LIST
84931: LIST
84932: LIST
84933: LIST
84934: LIST
84935: ST_TO_ADDR
// fFactory5 = [ [ 0 , - 4 ] , [ 0 , - 5 ] , [ 1 , - 4 ] , [ 1 , - 3 ] , [ 0 , - 3 ] , [ - 1 , - 4 ] , [ - 1 , - 5 ] , [ 2 , - 3 ] , [ - 2 , - 5 ] , [ 3 , 0 ] , [ 3 , - 1 ] , [ 4 , 0 ] , [ 4 , 1 ] , [ 3 , 1 ] , [ 2 , 0 ] , [ 2 , - 1 ] , [ 2 , - 2 ] , [ 4 , 2 ] , [ 4 , 4 ] , [ 4 , 3 ] , [ 5 , 4 ] , [ 5 , 5 ] , [ 4 , 5 ] , [ 3 , 4 ] , [ 3 , 3 ] , [ 5 , 3 ] , [ 3 , 5 ] , [ 0 , 3 ] , [ 0 , 2 ] , [ 1 , 3 ] , [ 1 , 4 ] , [ 0 , 4 ] , [ - 1 , 3 ] , [ - 1 , 2 ] , [ 2 , 4 ] , [ - 2 , 2 ] , [ - 4 , 0 ] , [ - 4 , - 1 ] , [ - 3 , 0 ] , [ - 3 , 1 ] , [ - 4 , 1 ] , [ - 5 , 0 ] , [ - 5 , - 1 ] , [ - 5 , - 2 ] , [ - 3 , 2 ] ] ;
84936: LD_ADDR_VAR 0 34
84940: PUSH
84941: LD_INT 0
84943: PUSH
84944: LD_INT 4
84946: NEG
84947: PUSH
84948: EMPTY
84949: LIST
84950: LIST
84951: PUSH
84952: LD_INT 0
84954: PUSH
84955: LD_INT 5
84957: NEG
84958: PUSH
84959: EMPTY
84960: LIST
84961: LIST
84962: PUSH
84963: LD_INT 1
84965: PUSH
84966: LD_INT 4
84968: NEG
84969: PUSH
84970: EMPTY
84971: LIST
84972: LIST
84973: PUSH
84974: LD_INT 1
84976: PUSH
84977: LD_INT 3
84979: NEG
84980: PUSH
84981: EMPTY
84982: LIST
84983: LIST
84984: PUSH
84985: LD_INT 0
84987: PUSH
84988: LD_INT 3
84990: NEG
84991: PUSH
84992: EMPTY
84993: LIST
84994: LIST
84995: PUSH
84996: LD_INT 1
84998: NEG
84999: PUSH
85000: LD_INT 4
85002: NEG
85003: PUSH
85004: EMPTY
85005: LIST
85006: LIST
85007: PUSH
85008: LD_INT 1
85010: NEG
85011: PUSH
85012: LD_INT 5
85014: NEG
85015: PUSH
85016: EMPTY
85017: LIST
85018: LIST
85019: PUSH
85020: LD_INT 2
85022: PUSH
85023: LD_INT 3
85025: NEG
85026: PUSH
85027: EMPTY
85028: LIST
85029: LIST
85030: PUSH
85031: LD_INT 2
85033: NEG
85034: PUSH
85035: LD_INT 5
85037: NEG
85038: PUSH
85039: EMPTY
85040: LIST
85041: LIST
85042: PUSH
85043: LD_INT 3
85045: PUSH
85046: LD_INT 0
85048: PUSH
85049: EMPTY
85050: LIST
85051: LIST
85052: PUSH
85053: LD_INT 3
85055: PUSH
85056: LD_INT 1
85058: NEG
85059: PUSH
85060: EMPTY
85061: LIST
85062: LIST
85063: PUSH
85064: LD_INT 4
85066: PUSH
85067: LD_INT 0
85069: PUSH
85070: EMPTY
85071: LIST
85072: LIST
85073: PUSH
85074: LD_INT 4
85076: PUSH
85077: LD_INT 1
85079: PUSH
85080: EMPTY
85081: LIST
85082: LIST
85083: PUSH
85084: LD_INT 3
85086: PUSH
85087: LD_INT 1
85089: PUSH
85090: EMPTY
85091: LIST
85092: LIST
85093: PUSH
85094: LD_INT 2
85096: PUSH
85097: LD_INT 0
85099: PUSH
85100: EMPTY
85101: LIST
85102: LIST
85103: PUSH
85104: LD_INT 2
85106: PUSH
85107: LD_INT 1
85109: NEG
85110: PUSH
85111: EMPTY
85112: LIST
85113: LIST
85114: PUSH
85115: LD_INT 2
85117: PUSH
85118: LD_INT 2
85120: NEG
85121: PUSH
85122: EMPTY
85123: LIST
85124: LIST
85125: PUSH
85126: LD_INT 4
85128: PUSH
85129: LD_INT 2
85131: PUSH
85132: EMPTY
85133: LIST
85134: LIST
85135: PUSH
85136: LD_INT 4
85138: PUSH
85139: LD_INT 4
85141: PUSH
85142: EMPTY
85143: LIST
85144: LIST
85145: PUSH
85146: LD_INT 4
85148: PUSH
85149: LD_INT 3
85151: PUSH
85152: EMPTY
85153: LIST
85154: LIST
85155: PUSH
85156: LD_INT 5
85158: PUSH
85159: LD_INT 4
85161: PUSH
85162: EMPTY
85163: LIST
85164: LIST
85165: PUSH
85166: LD_INT 5
85168: PUSH
85169: LD_INT 5
85171: PUSH
85172: EMPTY
85173: LIST
85174: LIST
85175: PUSH
85176: LD_INT 4
85178: PUSH
85179: LD_INT 5
85181: PUSH
85182: EMPTY
85183: LIST
85184: LIST
85185: PUSH
85186: LD_INT 3
85188: PUSH
85189: LD_INT 4
85191: PUSH
85192: EMPTY
85193: LIST
85194: LIST
85195: PUSH
85196: LD_INT 3
85198: PUSH
85199: LD_INT 3
85201: PUSH
85202: EMPTY
85203: LIST
85204: LIST
85205: PUSH
85206: LD_INT 5
85208: PUSH
85209: LD_INT 3
85211: PUSH
85212: EMPTY
85213: LIST
85214: LIST
85215: PUSH
85216: LD_INT 3
85218: PUSH
85219: LD_INT 5
85221: PUSH
85222: EMPTY
85223: LIST
85224: LIST
85225: PUSH
85226: LD_INT 0
85228: PUSH
85229: LD_INT 3
85231: PUSH
85232: EMPTY
85233: LIST
85234: LIST
85235: PUSH
85236: LD_INT 0
85238: PUSH
85239: LD_INT 2
85241: PUSH
85242: EMPTY
85243: LIST
85244: LIST
85245: PUSH
85246: LD_INT 1
85248: PUSH
85249: LD_INT 3
85251: PUSH
85252: EMPTY
85253: LIST
85254: LIST
85255: PUSH
85256: LD_INT 1
85258: PUSH
85259: LD_INT 4
85261: PUSH
85262: EMPTY
85263: LIST
85264: LIST
85265: PUSH
85266: LD_INT 0
85268: PUSH
85269: LD_INT 4
85271: PUSH
85272: EMPTY
85273: LIST
85274: LIST
85275: PUSH
85276: LD_INT 1
85278: NEG
85279: PUSH
85280: LD_INT 3
85282: PUSH
85283: EMPTY
85284: LIST
85285: LIST
85286: PUSH
85287: LD_INT 1
85289: NEG
85290: PUSH
85291: LD_INT 2
85293: PUSH
85294: EMPTY
85295: LIST
85296: LIST
85297: PUSH
85298: LD_INT 2
85300: PUSH
85301: LD_INT 4
85303: PUSH
85304: EMPTY
85305: LIST
85306: LIST
85307: PUSH
85308: LD_INT 2
85310: NEG
85311: PUSH
85312: LD_INT 2
85314: PUSH
85315: EMPTY
85316: LIST
85317: LIST
85318: PUSH
85319: LD_INT 4
85321: NEG
85322: PUSH
85323: LD_INT 0
85325: PUSH
85326: EMPTY
85327: LIST
85328: LIST
85329: PUSH
85330: LD_INT 4
85332: NEG
85333: PUSH
85334: LD_INT 1
85336: NEG
85337: PUSH
85338: EMPTY
85339: LIST
85340: LIST
85341: PUSH
85342: LD_INT 3
85344: NEG
85345: PUSH
85346: LD_INT 0
85348: PUSH
85349: EMPTY
85350: LIST
85351: LIST
85352: PUSH
85353: LD_INT 3
85355: NEG
85356: PUSH
85357: LD_INT 1
85359: PUSH
85360: EMPTY
85361: LIST
85362: LIST
85363: PUSH
85364: LD_INT 4
85366: NEG
85367: PUSH
85368: LD_INT 1
85370: PUSH
85371: EMPTY
85372: LIST
85373: LIST
85374: PUSH
85375: LD_INT 5
85377: NEG
85378: PUSH
85379: LD_INT 0
85381: PUSH
85382: EMPTY
85383: LIST
85384: LIST
85385: PUSH
85386: LD_INT 5
85388: NEG
85389: PUSH
85390: LD_INT 1
85392: NEG
85393: PUSH
85394: EMPTY
85395: LIST
85396: LIST
85397: PUSH
85398: LD_INT 5
85400: NEG
85401: PUSH
85402: LD_INT 2
85404: NEG
85405: PUSH
85406: EMPTY
85407: LIST
85408: LIST
85409: PUSH
85410: LD_INT 3
85412: NEG
85413: PUSH
85414: LD_INT 2
85416: PUSH
85417: EMPTY
85418: LIST
85419: LIST
85420: PUSH
85421: EMPTY
85422: LIST
85423: LIST
85424: LIST
85425: LIST
85426: LIST
85427: LIST
85428: LIST
85429: LIST
85430: LIST
85431: LIST
85432: LIST
85433: LIST
85434: LIST
85435: LIST
85436: LIST
85437: LIST
85438: LIST
85439: LIST
85440: LIST
85441: LIST
85442: LIST
85443: LIST
85444: LIST
85445: LIST
85446: LIST
85447: LIST
85448: LIST
85449: LIST
85450: LIST
85451: LIST
85452: LIST
85453: LIST
85454: LIST
85455: LIST
85456: LIST
85457: LIST
85458: LIST
85459: LIST
85460: LIST
85461: LIST
85462: LIST
85463: LIST
85464: LIST
85465: LIST
85466: LIST
85467: ST_TO_ADDR
// end ; end ;
85468: GO 85471
85470: POP
// case btype of b_depot , b_warehouse :
85471: LD_VAR 0 1
85475: PUSH
85476: LD_INT 0
85478: DOUBLE
85479: EQUAL
85480: IFTRUE 85490
85482: LD_INT 1
85484: DOUBLE
85485: EQUAL
85486: IFTRUE 85490
85488: GO 85691
85490: POP
// case nation of nation_american :
85491: LD_VAR 0 5
85495: PUSH
85496: LD_INT 1
85498: DOUBLE
85499: EQUAL
85500: IFTRUE 85504
85502: GO 85560
85504: POP
// temp_list = [ fDepotAm0 , fDepotAm1 , fDepotAm2 , fDepotAm3 , fDepotAm4 , fDepotAm5 ] [ dir + 1 ] ; nation_arabian :
85505: LD_ADDR_VAR 0 9
85509: PUSH
85510: LD_VAR 0 11
85514: PUSH
85515: LD_VAR 0 12
85519: PUSH
85520: LD_VAR 0 13
85524: PUSH
85525: LD_VAR 0 14
85529: PUSH
85530: LD_VAR 0 15
85534: PUSH
85535: LD_VAR 0 16
85539: PUSH
85540: EMPTY
85541: LIST
85542: LIST
85543: LIST
85544: LIST
85545: LIST
85546: LIST
85547: PUSH
85548: LD_VAR 0 4
85552: PUSH
85553: LD_INT 1
85555: PLUS
85556: ARRAY
85557: ST_TO_ADDR
85558: GO 85689
85560: LD_INT 2
85562: DOUBLE
85563: EQUAL
85564: IFTRUE 85568
85566: GO 85624
85568: POP
// temp_list = [ fDepotAr0 , fDepotAr1 , fDepotAr2 , fDepotAr3 , fDepotAr4 , fDepotAr5 ] [ dir + 1 ] ; nation_russian :
85569: LD_ADDR_VAR 0 9
85573: PUSH
85574: LD_VAR 0 17
85578: PUSH
85579: LD_VAR 0 18
85583: PUSH
85584: LD_VAR 0 19
85588: PUSH
85589: LD_VAR 0 20
85593: PUSH
85594: LD_VAR 0 21
85598: PUSH
85599: LD_VAR 0 22
85603: PUSH
85604: EMPTY
85605: LIST
85606: LIST
85607: LIST
85608: LIST
85609: LIST
85610: LIST
85611: PUSH
85612: LD_VAR 0 4
85616: PUSH
85617: LD_INT 1
85619: PLUS
85620: ARRAY
85621: ST_TO_ADDR
85622: GO 85689
85624: LD_INT 3
85626: DOUBLE
85627: EQUAL
85628: IFTRUE 85632
85630: GO 85688
85632: POP
// temp_list = [ fDepotRu0 , fDepotRu1 , fDepotRu2 , fDepotRu3 , fDepotRu4 , fDepotRu5 ] [ dir + 1 ] ; end ; b_workshop , b_factory :
85633: LD_ADDR_VAR 0 9
85637: PUSH
85638: LD_VAR 0 23
85642: PUSH
85643: LD_VAR 0 24
85647: PUSH
85648: LD_VAR 0 25
85652: PUSH
85653: LD_VAR 0 26
85657: PUSH
85658: LD_VAR 0 27
85662: PUSH
85663: LD_VAR 0 28
85667: PUSH
85668: EMPTY
85669: LIST
85670: LIST
85671: LIST
85672: LIST
85673: LIST
85674: LIST
85675: PUSH
85676: LD_VAR 0 4
85680: PUSH
85681: LD_INT 1
85683: PLUS
85684: ARRAY
85685: ST_TO_ADDR
85686: GO 85689
85688: POP
85689: GO 86244
85691: LD_INT 2
85693: DOUBLE
85694: EQUAL
85695: IFTRUE 85705
85697: LD_INT 3
85699: DOUBLE
85700: EQUAL
85701: IFTRUE 85705
85703: GO 85761
85705: POP
// temp_list = [ fFactory0 , fFactory1 , fFactory2 , fFactory3 , fFactory4 , fFactory5 ] [ dir + 1 ] ; b_ext_track , b_ext_gun , b_ext_rocket , b_ext_noncombat , b_ext_radio , b_ext_radar , b_ext_siberium , b_ext_stitch , b_ext_computer , b_ext_laser :
85706: LD_ADDR_VAR 0 9
85710: PUSH
85711: LD_VAR 0 29
85715: PUSH
85716: LD_VAR 0 30
85720: PUSH
85721: LD_VAR 0 31
85725: PUSH
85726: LD_VAR 0 32
85730: PUSH
85731: LD_VAR 0 33
85735: PUSH
85736: LD_VAR 0 34
85740: PUSH
85741: EMPTY
85742: LIST
85743: LIST
85744: LIST
85745: LIST
85746: LIST
85747: LIST
85748: PUSH
85749: LD_VAR 0 4
85753: PUSH
85754: LD_INT 1
85756: PLUS
85757: ARRAY
85758: ST_TO_ADDR
85759: GO 86244
85761: LD_INT 16
85763: DOUBLE
85764: EQUAL
85765: IFTRUE 85823
85767: LD_INT 17
85769: DOUBLE
85770: EQUAL
85771: IFTRUE 85823
85773: LD_INT 18
85775: DOUBLE
85776: EQUAL
85777: IFTRUE 85823
85779: LD_INT 19
85781: DOUBLE
85782: EQUAL
85783: IFTRUE 85823
85785: LD_INT 22
85787: DOUBLE
85788: EQUAL
85789: IFTRUE 85823
85791: LD_INT 20
85793: DOUBLE
85794: EQUAL
85795: IFTRUE 85823
85797: LD_INT 21
85799: DOUBLE
85800: EQUAL
85801: IFTRUE 85823
85803: LD_INT 23
85805: DOUBLE
85806: EQUAL
85807: IFTRUE 85823
85809: LD_INT 24
85811: DOUBLE
85812: EQUAL
85813: IFTRUE 85823
85815: LD_INT 25
85817: DOUBLE
85818: EQUAL
85819: IFTRUE 85823
85821: GO 85879
85823: POP
// temp_list = [ fExt0 , fExt1 , fExt2 , fExt3 , fExt4 , fExt5 ] [ dir + 1 ] ; b_lab , b_lab_half , b_lab_full , b_lab_biological , b_lab_computer , b_lab_opto , b_lab_siberium , b_lab_spacetime , b_lab_weapon :
85824: LD_ADDR_VAR 0 9
85828: PUSH
85829: LD_VAR 0 35
85833: PUSH
85834: LD_VAR 0 36
85838: PUSH
85839: LD_VAR 0 37
85843: PUSH
85844: LD_VAR 0 38
85848: PUSH
85849: LD_VAR 0 39
85853: PUSH
85854: LD_VAR 0 40
85858: PUSH
85859: EMPTY
85860: LIST
85861: LIST
85862: LIST
85863: LIST
85864: LIST
85865: LIST
85866: PUSH
85867: LD_VAR 0 4
85871: PUSH
85872: LD_INT 1
85874: PLUS
85875: ARRAY
85876: ST_TO_ADDR
85877: GO 86244
85879: LD_INT 6
85881: DOUBLE
85882: EQUAL
85883: IFTRUE 85935
85885: LD_INT 7
85887: DOUBLE
85888: EQUAL
85889: IFTRUE 85935
85891: LD_INT 8
85893: DOUBLE
85894: EQUAL
85895: IFTRUE 85935
85897: LD_INT 13
85899: DOUBLE
85900: EQUAL
85901: IFTRUE 85935
85903: LD_INT 12
85905: DOUBLE
85906: EQUAL
85907: IFTRUE 85935
85909: LD_INT 15
85911: DOUBLE
85912: EQUAL
85913: IFTRUE 85935
85915: LD_INT 11
85917: DOUBLE
85918: EQUAL
85919: IFTRUE 85935
85921: LD_INT 14
85923: DOUBLE
85924: EQUAL
85925: IFTRUE 85935
85927: LD_INT 10
85929: DOUBLE
85930: EQUAL
85931: IFTRUE 85935
85933: GO 85991
85935: POP
// temp_list = [ fLab0 , fLab1 , fLab2 , fLab3 , fLab4 , fLab5 ] [ dir + 1 ] ; b_control_tower :
85936: LD_ADDR_VAR 0 9
85940: PUSH
85941: LD_VAR 0 41
85945: PUSH
85946: LD_VAR 0 42
85950: PUSH
85951: LD_VAR 0 43
85955: PUSH
85956: LD_VAR 0 44
85960: PUSH
85961: LD_VAR 0 45
85965: PUSH
85966: LD_VAR 0 46
85970: PUSH
85971: EMPTY
85972: LIST
85973: LIST
85974: LIST
85975: LIST
85976: LIST
85977: LIST
85978: PUSH
85979: LD_VAR 0 4
85983: PUSH
85984: LD_INT 1
85986: PLUS
85987: ARRAY
85988: ST_TO_ADDR
85989: GO 86244
85991: LD_INT 36
85993: DOUBLE
85994: EQUAL
85995: IFTRUE 85999
85997: GO 86055
85999: POP
// temp_list = [ fControlTower0 , fControlTower1 , fControlTower2 , fControlTower3 , fControlTower4 , fControlTower5 ] [ dir + 1 ] ; b_armoury , b_barracks , b_teleport , b_behemoth :
86000: LD_ADDR_VAR 0 9
86004: PUSH
86005: LD_VAR 0 47
86009: PUSH
86010: LD_VAR 0 48
86014: PUSH
86015: LD_VAR 0 49
86019: PUSH
86020: LD_VAR 0 50
86024: PUSH
86025: LD_VAR 0 51
86029: PUSH
86030: LD_VAR 0 52
86034: PUSH
86035: EMPTY
86036: LIST
86037: LIST
86038: LIST
86039: LIST
86040: LIST
86041: LIST
86042: PUSH
86043: LD_VAR 0 4
86047: PUSH
86048: LD_INT 1
86050: PLUS
86051: ARRAY
86052: ST_TO_ADDR
86053: GO 86244
86055: LD_INT 4
86057: DOUBLE
86058: EQUAL
86059: IFTRUE 86081
86061: LD_INT 5
86063: DOUBLE
86064: EQUAL
86065: IFTRUE 86081
86067: LD_INT 34
86069: DOUBLE
86070: EQUAL
86071: IFTRUE 86081
86073: LD_INT 37
86075: DOUBLE
86076: EQUAL
86077: IFTRUE 86081
86079: GO 86137
86081: POP
// temp_list = [ fBarracks0 , fBarracks1 , fBarracks2 , fBarracks3 , fBarracks4 , fBarracks5 ] [ dir + 1 ] ; b_breastwork , b_bunker , b_turret , b_solar_power , b_oil_power , b_siberite_power , b_oil_mine , b_siberite_mine :
86082: LD_ADDR_VAR 0 9
86086: PUSH
86087: LD_VAR 0 53
86091: PUSH
86092: LD_VAR 0 54
86096: PUSH
86097: LD_VAR 0 55
86101: PUSH
86102: LD_VAR 0 56
86106: PUSH
86107: LD_VAR 0 57
86111: PUSH
86112: LD_VAR 0 58
86116: PUSH
86117: EMPTY
86118: LIST
86119: LIST
86120: LIST
86121: LIST
86122: LIST
86123: LIST
86124: PUSH
86125: LD_VAR 0 4
86129: PUSH
86130: LD_INT 1
86132: PLUS
86133: ARRAY
86134: ST_TO_ADDR
86135: GO 86244
86137: LD_INT 31
86139: DOUBLE
86140: EQUAL
86141: IFTRUE 86187
86143: LD_INT 32
86145: DOUBLE
86146: EQUAL
86147: IFTRUE 86187
86149: LD_INT 33
86151: DOUBLE
86152: EQUAL
86153: IFTRUE 86187
86155: LD_INT 27
86157: DOUBLE
86158: EQUAL
86159: IFTRUE 86187
86161: LD_INT 26
86163: DOUBLE
86164: EQUAL
86165: IFTRUE 86187
86167: LD_INT 28
86169: DOUBLE
86170: EQUAL
86171: IFTRUE 86187
86173: LD_INT 29
86175: DOUBLE
86176: EQUAL
86177: IFTRUE 86187
86179: LD_INT 30
86181: DOUBLE
86182: EQUAL
86183: IFTRUE 86187
86185: GO 86243
86187: POP
// temp_list = [ fBunker0 , fBunker1 , fBunker2 , fBunker3 , fBunker4 , fBunker5 ] [ dir + 1 ] ; end ;
86188: LD_ADDR_VAR 0 9
86192: PUSH
86193: LD_VAR 0 59
86197: PUSH
86198: LD_VAR 0 60
86202: PUSH
86203: LD_VAR 0 61
86207: PUSH
86208: LD_VAR 0 62
86212: PUSH
86213: LD_VAR 0 63
86217: PUSH
86218: LD_VAR 0 64
86222: PUSH
86223: EMPTY
86224: LIST
86225: LIST
86226: LIST
86227: LIST
86228: LIST
86229: LIST
86230: PUSH
86231: LD_VAR 0 4
86235: PUSH
86236: LD_INT 1
86238: PLUS
86239: ARRAY
86240: ST_TO_ADDR
86241: GO 86244
86243: POP
// temp_list2 = [ ] ;
86244: LD_ADDR_VAR 0 10
86248: PUSH
86249: EMPTY
86250: ST_TO_ADDR
// for i in temp_list do
86251: LD_ADDR_VAR 0 8
86255: PUSH
86256: LD_VAR 0 9
86260: PUSH
86261: FOR_IN
86262: IFFALSE 86314
// temp_list2 = temp_list2 ^ [ [ i [ 1 ] + x , i [ 2 ] + y ] ] ;
86264: LD_ADDR_VAR 0 10
86268: PUSH
86269: LD_VAR 0 10
86273: PUSH
86274: LD_VAR 0 8
86278: PUSH
86279: LD_INT 1
86281: ARRAY
86282: PUSH
86283: LD_VAR 0 2
86287: PLUS
86288: PUSH
86289: LD_VAR 0 8
86293: PUSH
86294: LD_INT 2
86296: ARRAY
86297: PUSH
86298: LD_VAR 0 3
86302: PLUS
86303: PUSH
86304: EMPTY
86305: LIST
86306: LIST
86307: PUSH
86308: EMPTY
86309: LIST
86310: ADD
86311: ST_TO_ADDR
86312: GO 86261
86314: POP
86315: POP
// result = temp_list2 ;
86316: LD_ADDR_VAR 0 7
86320: PUSH
86321: LD_VAR 0 10
86325: ST_TO_ADDR
// end ;
86326: LD_VAR 0 7
86330: RET
// export function EnemyInRange ( unit , dist ) ; begin
86331: LD_INT 0
86333: PPUSH
// result := DangerAtRangeXY ( GetSide ( unit ) , GetX ( unit ) , GetY ( unit ) , dist ) [ 4 ] ;
86334: LD_ADDR_VAR 0 3
86338: PUSH
86339: LD_VAR 0 1
86343: PPUSH
86344: CALL_OW 255
86348: PPUSH
86349: LD_VAR 0 1
86353: PPUSH
86354: CALL_OW 250
86358: PPUSH
86359: LD_VAR 0 1
86363: PPUSH
86364: CALL_OW 251
86368: PPUSH
86369: LD_VAR 0 2
86373: PPUSH
86374: CALL 59704 0 4
86378: PUSH
86379: LD_INT 4
86381: ARRAY
86382: ST_TO_ADDR
// end ;
86383: LD_VAR 0 3
86387: RET
// export function PlayerSeeMe ( unit ) ; begin
86388: LD_INT 0
86390: PPUSH
// result := See ( your_side , unit ) ;
86391: LD_ADDR_VAR 0 2
86395: PUSH
86396: LD_OWVAR 2
86400: PPUSH
86401: LD_VAR 0 1
86405: PPUSH
86406: CALL_OW 292
86410: ST_TO_ADDR
// end ;
86411: LD_VAR 0 2
86415: RET
// export function ReverseDir ( unit ) ; begin
86416: LD_INT 0
86418: PPUSH
// if not unit then
86419: LD_VAR 0 1
86423: NOT
86424: IFFALSE 86428
// exit ;
86426: GO 86451
// result := ( GetDir ( unit ) + 3 ) mod 6 ;
86428: LD_ADDR_VAR 0 2
86432: PUSH
86433: LD_VAR 0 1
86437: PPUSH
86438: CALL_OW 254
86442: PUSH
86443: LD_INT 3
86445: PLUS
86446: PUSH
86447: LD_INT 6
86449: MOD
86450: ST_TO_ADDR
// end ;
86451: LD_VAR 0 2
86455: RET
// export function ReverseArray ( array ) ; var i ; begin
86456: LD_INT 0
86458: PPUSH
86459: PPUSH
// if not array then
86460: LD_VAR 0 1
86464: NOT
86465: IFFALSE 86469
// exit ;
86467: GO 86524
// result := [ ] ;
86469: LD_ADDR_VAR 0 2
86473: PUSH
86474: EMPTY
86475: ST_TO_ADDR
// for i := array downto 1 do
86476: LD_ADDR_VAR 0 3
86480: PUSH
86481: DOUBLE
86482: LD_VAR 0 1
86486: INC
86487: ST_TO_ADDR
86488: LD_INT 1
86490: PUSH
86491: FOR_DOWNTO
86492: IFFALSE 86522
// result := Join ( result , array [ i ] ) ;
86494: LD_ADDR_VAR 0 2
86498: PUSH
86499: LD_VAR 0 2
86503: PPUSH
86504: LD_VAR 0 1
86508: PUSH
86509: LD_VAR 0 3
86513: ARRAY
86514: PPUSH
86515: CALL 91169 0 2
86519: ST_TO_ADDR
86520: GO 86491
86522: POP
86523: POP
// end ;
86524: LD_VAR 0 2
86528: RET
// export function GetClosestHex ( unit , hexes ) ; var i , dist , tdist , tmp , hex ; begin
86529: LD_INT 0
86531: PPUSH
86532: PPUSH
86533: PPUSH
86534: PPUSH
86535: PPUSH
86536: PPUSH
// if not unit or not hexes then
86537: LD_VAR 0 1
86541: NOT
86542: PUSH
86543: LD_VAR 0 2
86547: NOT
86548: OR
86549: IFFALSE 86553
// exit ;
86551: GO 86676
// dist := 9999 ;
86553: LD_ADDR_VAR 0 5
86557: PUSH
86558: LD_INT 9999
86560: ST_TO_ADDR
// for i = 1 to hexes do
86561: LD_ADDR_VAR 0 4
86565: PUSH
86566: DOUBLE
86567: LD_INT 1
86569: DEC
86570: ST_TO_ADDR
86571: LD_VAR 0 2
86575: PUSH
86576: FOR_TO
86577: IFFALSE 86664
// begin tdist := GetDistUnitXY ( unit , hexes [ i ] [ 1 ] , hexes [ i ] [ 2 ] ) ;
86579: LD_ADDR_VAR 0 6
86583: PUSH
86584: LD_VAR 0 1
86588: PPUSH
86589: LD_VAR 0 2
86593: PUSH
86594: LD_VAR 0 4
86598: ARRAY
86599: PUSH
86600: LD_INT 1
86602: ARRAY
86603: PPUSH
86604: LD_VAR 0 2
86608: PUSH
86609: LD_VAR 0 4
86613: ARRAY
86614: PUSH
86615: LD_INT 2
86617: ARRAY
86618: PPUSH
86619: CALL_OW 297
86623: ST_TO_ADDR
// if tdist < dist then
86624: LD_VAR 0 6
86628: PUSH
86629: LD_VAR 0 5
86633: LESS
86634: IFFALSE 86662
// begin hex := hexes [ i ] ;
86636: LD_ADDR_VAR 0 8
86640: PUSH
86641: LD_VAR 0 2
86645: PUSH
86646: LD_VAR 0 4
86650: ARRAY
86651: ST_TO_ADDR
// dist := tdist ;
86652: LD_ADDR_VAR 0 5
86656: PUSH
86657: LD_VAR 0 6
86661: ST_TO_ADDR
// end ; end ;
86662: GO 86576
86664: POP
86665: POP
// result := hex ;
86666: LD_ADDR_VAR 0 3
86670: PUSH
86671: LD_VAR 0 8
86675: ST_TO_ADDR
// end ;
86676: LD_VAR 0 3
86680: RET
// export function ComAutodestruct ( unit ) ; var i ; begin
86681: LD_INT 0
86683: PPUSH
86684: PPUSH
// if not unit or not unit in FilterAllUnits ( [ [ f_type , unit_vehicle ] , [ f_nation , 2 ] ] ) then
86685: LD_VAR 0 1
86689: NOT
86690: PUSH
86691: LD_VAR 0 1
86695: PUSH
86696: LD_INT 21
86698: PUSH
86699: LD_INT 2
86701: PUSH
86702: EMPTY
86703: LIST
86704: LIST
86705: PUSH
86706: LD_INT 23
86708: PUSH
86709: LD_INT 2
86711: PUSH
86712: EMPTY
86713: LIST
86714: LIST
86715: PUSH
86716: EMPTY
86717: LIST
86718: LIST
86719: PPUSH
86720: CALL_OW 69
86724: IN
86725: NOT
86726: OR
86727: IFFALSE 86731
// exit ;
86729: GO 86778
// for i = 1 to 3 do
86731: LD_ADDR_VAR 0 3
86735: PUSH
86736: DOUBLE
86737: LD_INT 1
86739: DEC
86740: ST_TO_ADDR
86741: LD_INT 3
86743: PUSH
86744: FOR_TO
86745: IFFALSE 86776
// MineExplosion ( GetX ( unit ) , GetY ( unit ) , 1 ) ;
86747: LD_VAR 0 1
86751: PPUSH
86752: CALL_OW 250
86756: PPUSH
86757: LD_VAR 0 1
86761: PPUSH
86762: CALL_OW 251
86766: PPUSH
86767: LD_INT 1
86769: PPUSH
86770: CALL_OW 453
86774: GO 86744
86776: POP
86777: POP
// end ;
86778: LD_VAR 0 2
86782: RET
// export function AttackHovercraft ( unit , enemy_unit ) ; var i , j , tmp , x , y ; begin
86783: LD_INT 0
86785: PPUSH
86786: PPUSH
86787: PPUSH
86788: PPUSH
86789: PPUSH
86790: PPUSH
// if not unit or not enemy_unit then
86791: LD_VAR 0 1
86795: NOT
86796: PUSH
86797: LD_VAR 0 2
86801: NOT
86802: OR
86803: IFFALSE 86807
// exit ;
86805: GO 87274
// if GetLives ( i ) < 250 then
86807: LD_VAR 0 4
86811: PPUSH
86812: CALL_OW 256
86816: PUSH
86817: LD_INT 250
86819: LESS
86820: IFFALSE 86833
// begin ComAutodestruct ( i ) ;
86822: LD_VAR 0 4
86826: PPUSH
86827: CALL 86681 0 1
// exit ;
86831: GO 87274
// end ; x := GetX ( enemy_unit ) ;
86833: LD_ADDR_VAR 0 7
86837: PUSH
86838: LD_VAR 0 2
86842: PPUSH
86843: CALL_OW 250
86847: ST_TO_ADDR
// y := GetY ( enemy_unit ) ;
86848: LD_ADDR_VAR 0 8
86852: PUSH
86853: LD_VAR 0 2
86857: PPUSH
86858: CALL_OW 251
86862: ST_TO_ADDR
// if not x or not y then
86863: LD_VAR 0 7
86867: NOT
86868: PUSH
86869: LD_VAR 0 8
86873: NOT
86874: OR
86875: IFFALSE 86879
// exit ;
86877: GO 87274
// tmp := [ [ ShiftX ( x , 0 , 4 ) , ShiftY ( y , 0 , 4 ) ] , [ ShiftX ( x , 1 , 4 ) , ShiftY ( y , 1 , 4 ) ] , [ ShiftX ( x , 2 , 4 ) , ShiftY ( y , 2 , 4 ) ] , [ ShiftX ( x , 3 , 4 ) , ShiftY ( y , 3 , 4 ) ] , [ ShiftX ( x , 4 , 4 ) , ShiftY ( y , 4 , 4 ) ] , [ ShiftX ( x , 5 , 4 ) , ShiftY ( y , 5 , 4 ) ] ] ;
86879: LD_ADDR_VAR 0 6
86883: PUSH
86884: LD_VAR 0 7
86888: PPUSH
86889: LD_INT 0
86891: PPUSH
86892: LD_INT 4
86894: PPUSH
86895: CALL_OW 272
86899: PUSH
86900: LD_VAR 0 8
86904: PPUSH
86905: LD_INT 0
86907: PPUSH
86908: LD_INT 4
86910: PPUSH
86911: CALL_OW 273
86915: PUSH
86916: EMPTY
86917: LIST
86918: LIST
86919: PUSH
86920: LD_VAR 0 7
86924: PPUSH
86925: LD_INT 1
86927: PPUSH
86928: LD_INT 4
86930: PPUSH
86931: CALL_OW 272
86935: PUSH
86936: LD_VAR 0 8
86940: PPUSH
86941: LD_INT 1
86943: PPUSH
86944: LD_INT 4
86946: PPUSH
86947: CALL_OW 273
86951: PUSH
86952: EMPTY
86953: LIST
86954: LIST
86955: PUSH
86956: LD_VAR 0 7
86960: PPUSH
86961: LD_INT 2
86963: PPUSH
86964: LD_INT 4
86966: PPUSH
86967: CALL_OW 272
86971: PUSH
86972: LD_VAR 0 8
86976: PPUSH
86977: LD_INT 2
86979: PPUSH
86980: LD_INT 4
86982: PPUSH
86983: CALL_OW 273
86987: PUSH
86988: EMPTY
86989: LIST
86990: LIST
86991: PUSH
86992: LD_VAR 0 7
86996: PPUSH
86997: LD_INT 3
86999: PPUSH
87000: LD_INT 4
87002: PPUSH
87003: CALL_OW 272
87007: PUSH
87008: LD_VAR 0 8
87012: PPUSH
87013: LD_INT 3
87015: PPUSH
87016: LD_INT 4
87018: PPUSH
87019: CALL_OW 273
87023: PUSH
87024: EMPTY
87025: LIST
87026: LIST
87027: PUSH
87028: LD_VAR 0 7
87032: PPUSH
87033: LD_INT 4
87035: PPUSH
87036: LD_INT 4
87038: PPUSH
87039: CALL_OW 272
87043: PUSH
87044: LD_VAR 0 8
87048: PPUSH
87049: LD_INT 4
87051: PPUSH
87052: LD_INT 4
87054: PPUSH
87055: CALL_OW 273
87059: PUSH
87060: EMPTY
87061: LIST
87062: LIST
87063: PUSH
87064: LD_VAR 0 7
87068: PPUSH
87069: LD_INT 5
87071: PPUSH
87072: LD_INT 4
87074: PPUSH
87075: CALL_OW 272
87079: PUSH
87080: LD_VAR 0 8
87084: PPUSH
87085: LD_INT 5
87087: PPUSH
87088: LD_INT 4
87090: PPUSH
87091: CALL_OW 273
87095: PUSH
87096: EMPTY
87097: LIST
87098: LIST
87099: PUSH
87100: EMPTY
87101: LIST
87102: LIST
87103: LIST
87104: LIST
87105: LIST
87106: LIST
87107: ST_TO_ADDR
// for i = tmp downto 1 do
87108: LD_ADDR_VAR 0 4
87112: PUSH
87113: DOUBLE
87114: LD_VAR 0 6
87118: INC
87119: ST_TO_ADDR
87120: LD_INT 1
87122: PUSH
87123: FOR_DOWNTO
87124: IFFALSE 87225
// if not ValidHex ( tmp [ i ] [ 1 ] , tmp [ i ] [ 2 ] ) or HexInfo ( tmp [ i ] [ 1 ] , tmp [ i ] [ 2 ] ) <> 0 then
87126: LD_VAR 0 6
87130: PUSH
87131: LD_VAR 0 4
87135: ARRAY
87136: PUSH
87137: LD_INT 1
87139: ARRAY
87140: PPUSH
87141: LD_VAR 0 6
87145: PUSH
87146: LD_VAR 0 4
87150: ARRAY
87151: PUSH
87152: LD_INT 2
87154: ARRAY
87155: PPUSH
87156: CALL_OW 488
87160: NOT
87161: PUSH
87162: LD_VAR 0 6
87166: PUSH
87167: LD_VAR 0 4
87171: ARRAY
87172: PUSH
87173: LD_INT 1
87175: ARRAY
87176: PPUSH
87177: LD_VAR 0 6
87181: PUSH
87182: LD_VAR 0 4
87186: ARRAY
87187: PUSH
87188: LD_INT 2
87190: ARRAY
87191: PPUSH
87192: CALL_OW 428
87196: PUSH
87197: LD_INT 0
87199: NONEQUAL
87200: OR
87201: IFFALSE 87223
// tmp := Delete ( tmp , i ) ;
87203: LD_ADDR_VAR 0 6
87207: PUSH
87208: LD_VAR 0 6
87212: PPUSH
87213: LD_VAR 0 4
87217: PPUSH
87218: CALL_OW 3
87222: ST_TO_ADDR
87223: GO 87123
87225: POP
87226: POP
// j := GetClosestHex ( unit , tmp ) ;
87227: LD_ADDR_VAR 0 5
87231: PUSH
87232: LD_VAR 0 1
87236: PPUSH
87237: LD_VAR 0 6
87241: PPUSH
87242: CALL 86529 0 2
87246: ST_TO_ADDR
// ComMoveXY ( unit , j [ 1 ] , j [ 2 ] ) ;
87247: LD_VAR 0 1
87251: PPUSH
87252: LD_VAR 0 5
87256: PUSH
87257: LD_INT 1
87259: ARRAY
87260: PPUSH
87261: LD_VAR 0 5
87265: PUSH
87266: LD_INT 2
87268: ARRAY
87269: PPUSH
87270: CALL_OW 111
// end ;
87274: LD_VAR 0 3
87278: RET
// export function PrepareApemanSoldier ( ) ; begin
87279: LD_INT 0
87281: PPUSH
// uc_nation := 0 ;
87282: LD_ADDR_OWVAR 21
87286: PUSH
87287: LD_INT 0
87289: ST_TO_ADDR
// hc_sex := sex_male ;
87290: LD_ADDR_OWVAR 27
87294: PUSH
87295: LD_INT 1
87297: ST_TO_ADDR
// hc_class := class_apeman_soldier ;
87298: LD_ADDR_OWVAR 28
87302: PUSH
87303: LD_INT 15
87305: ST_TO_ADDR
// hc_gallery :=  ;
87306: LD_ADDR_OWVAR 33
87310: PUSH
87311: LD_STRING 
87313: ST_TO_ADDR
// hc_skills := [ rand ( 0 , 3 ) , rand ( 0 , 3 ) , 0 , 0 ] ;
87314: LD_ADDR_OWVAR 31
87318: PUSH
87319: LD_INT 0
87321: PPUSH
87322: LD_INT 3
87324: PPUSH
87325: CALL_OW 12
87329: PUSH
87330: LD_INT 0
87332: PPUSH
87333: LD_INT 3
87335: PPUSH
87336: CALL_OW 12
87340: PUSH
87341: LD_INT 0
87343: PUSH
87344: LD_INT 0
87346: PUSH
87347: EMPTY
87348: LIST
87349: LIST
87350: LIST
87351: LIST
87352: ST_TO_ADDR
// end ;
87353: LD_VAR 0 1
87357: RET
// export function PrepareApemanEngineer ( ) ; begin
87358: LD_INT 0
87360: PPUSH
// uc_nation := 0 ;
87361: LD_ADDR_OWVAR 21
87365: PUSH
87366: LD_INT 0
87368: ST_TO_ADDR
// hc_sex := sex_male ;
87369: LD_ADDR_OWVAR 27
87373: PUSH
87374: LD_INT 1
87376: ST_TO_ADDR
// hc_class := class_apeman_engineer ;
87377: LD_ADDR_OWVAR 28
87381: PUSH
87382: LD_INT 16
87384: ST_TO_ADDR
// hc_gallery :=  ;
87385: LD_ADDR_OWVAR 33
87389: PUSH
87390: LD_STRING 
87392: ST_TO_ADDR
// hc_skills := [ rand ( 0 , 3 ) , rand ( 0 , 3 ) , 0 , 0 ] ;
87393: LD_ADDR_OWVAR 31
87397: PUSH
87398: LD_INT 0
87400: PPUSH
87401: LD_INT 3
87403: PPUSH
87404: CALL_OW 12
87408: PUSH
87409: LD_INT 0
87411: PPUSH
87412: LD_INT 3
87414: PPUSH
87415: CALL_OW 12
87419: PUSH
87420: LD_INT 0
87422: PUSH
87423: LD_INT 0
87425: PUSH
87426: EMPTY
87427: LIST
87428: LIST
87429: LIST
87430: LIST
87431: ST_TO_ADDR
// end ;
87432: LD_VAR 0 1
87436: RET
// export function PrepareApeman ( agressivity ) ; begin
87437: LD_INT 0
87439: PPUSH
// uc_side := 0 ;
87440: LD_ADDR_OWVAR 20
87444: PUSH
87445: LD_INT 0
87447: ST_TO_ADDR
// uc_nation := 0 ;
87448: LD_ADDR_OWVAR 21
87452: PUSH
87453: LD_INT 0
87455: ST_TO_ADDR
// hc_sex := sex_male ;
87456: LD_ADDR_OWVAR 27
87460: PUSH
87461: LD_INT 1
87463: ST_TO_ADDR
// hc_class := class_apeman ;
87464: LD_ADDR_OWVAR 28
87468: PUSH
87469: LD_INT 12
87471: ST_TO_ADDR
// hc_gallery :=  ;
87472: LD_ADDR_OWVAR 33
87476: PUSH
87477: LD_STRING 
87479: ST_TO_ADDR
// hc_agressivity := rand ( - agressivity , agressivity ) ;
87480: LD_ADDR_OWVAR 35
87484: PUSH
87485: LD_VAR 0 1
87489: NEG
87490: PPUSH
87491: LD_VAR 0 1
87495: PPUSH
87496: CALL_OW 12
87500: ST_TO_ADDR
// hc_skills := [ rand ( 0 , 3 ) , rand ( 0 , 3 ) , 0 , 0 ] ;
87501: LD_ADDR_OWVAR 31
87505: PUSH
87506: LD_INT 0
87508: PPUSH
87509: LD_INT 3
87511: PPUSH
87512: CALL_OW 12
87516: PUSH
87517: LD_INT 0
87519: PPUSH
87520: LD_INT 3
87522: PPUSH
87523: CALL_OW 12
87527: PUSH
87528: LD_INT 0
87530: PUSH
87531: LD_INT 0
87533: PUSH
87534: EMPTY
87535: LIST
87536: LIST
87537: LIST
87538: LIST
87539: ST_TO_ADDR
// end ;
87540: LD_VAR 0 2
87544: RET
// export function PrepareTiger ( agressivity ) ; begin
87545: LD_INT 0
87547: PPUSH
// uc_side := 0 ;
87548: LD_ADDR_OWVAR 20
87552: PUSH
87553: LD_INT 0
87555: ST_TO_ADDR
// uc_nation := 0 ;
87556: LD_ADDR_OWVAR 21
87560: PUSH
87561: LD_INT 0
87563: ST_TO_ADDR
// hc_class := class_tiger ;
87564: LD_ADDR_OWVAR 28
87568: PUSH
87569: LD_INT 14
87571: ST_TO_ADDR
// hc_gallery :=  ;
87572: LD_ADDR_OWVAR 33
87576: PUSH
87577: LD_STRING 
87579: ST_TO_ADDR
// hc_agressivity := rand ( - agressivity , agressivity ) ;
87580: LD_ADDR_OWVAR 35
87584: PUSH
87585: LD_VAR 0 1
87589: NEG
87590: PPUSH
87591: LD_VAR 0 1
87595: PPUSH
87596: CALL_OW 12
87600: ST_TO_ADDR
// end ;
87601: LD_VAR 0 2
87605: RET
// export function PrepareEnchidna ( ) ; begin
87606: LD_INT 0
87608: PPUSH
// uc_side := 0 ;
87609: LD_ADDR_OWVAR 20
87613: PUSH
87614: LD_INT 0
87616: ST_TO_ADDR
// uc_nation := 0 ;
87617: LD_ADDR_OWVAR 21
87621: PUSH
87622: LD_INT 0
87624: ST_TO_ADDR
// hc_class := class_baggie ;
87625: LD_ADDR_OWVAR 28
87629: PUSH
87630: LD_INT 13
87632: ST_TO_ADDR
// hc_gallery :=  ;
87633: LD_ADDR_OWVAR 33
87637: PUSH
87638: LD_STRING 
87640: ST_TO_ADDR
// end ;
87641: LD_VAR 0 1
87645: RET
// export function PrepareFrog ( ) ; begin
87646: LD_INT 0
87648: PPUSH
// uc_side := 0 ;
87649: LD_ADDR_OWVAR 20
87653: PUSH
87654: LD_INT 0
87656: ST_TO_ADDR
// uc_nation := 0 ;
87657: LD_ADDR_OWVAR 21
87661: PUSH
87662: LD_INT 0
87664: ST_TO_ADDR
// hc_class := class_frog ;
87665: LD_ADDR_OWVAR 28
87669: PUSH
87670: LD_INT 19
87672: ST_TO_ADDR
// hc_gallery :=  ;
87673: LD_ADDR_OWVAR 33
87677: PUSH
87678: LD_STRING 
87680: ST_TO_ADDR
// end ;
87681: LD_VAR 0 1
87685: RET
// export function PrepareFish ( ) ; begin
87686: LD_INT 0
87688: PPUSH
// uc_side := 0 ;
87689: LD_ADDR_OWVAR 20
87693: PUSH
87694: LD_INT 0
87696: ST_TO_ADDR
// uc_nation := 0 ;
87697: LD_ADDR_OWVAR 21
87701: PUSH
87702: LD_INT 0
87704: ST_TO_ADDR
// hc_class := class_fish ;
87705: LD_ADDR_OWVAR 28
87709: PUSH
87710: LD_INT 20
87712: ST_TO_ADDR
// hc_gallery :=  ;
87713: LD_ADDR_OWVAR 33
87717: PUSH
87718: LD_STRING 
87720: ST_TO_ADDR
// end ;
87721: LD_VAR 0 1
87725: RET
// export function PrepareBird ( ) ; begin
87726: LD_INT 0
87728: PPUSH
// uc_side := 0 ;
87729: LD_ADDR_OWVAR 20
87733: PUSH
87734: LD_INT 0
87736: ST_TO_ADDR
// uc_nation := 0 ;
87737: LD_ADDR_OWVAR 21
87741: PUSH
87742: LD_INT 0
87744: ST_TO_ADDR
// hc_class := class_phororhacos ;
87745: LD_ADDR_OWVAR 28
87749: PUSH
87750: LD_INT 18
87752: ST_TO_ADDR
// hc_gallery :=  ;
87753: LD_ADDR_OWVAR 33
87757: PUSH
87758: LD_STRING 
87760: ST_TO_ADDR
// end ;
87761: LD_VAR 0 1
87765: RET
// export function PrepareHorse ( ) ; begin
87766: LD_INT 0
87768: PPUSH
// uc_side := 0 ;
87769: LD_ADDR_OWVAR 20
87773: PUSH
87774: LD_INT 0
87776: ST_TO_ADDR
// uc_nation := 0 ;
87777: LD_ADDR_OWVAR 21
87781: PUSH
87782: LD_INT 0
87784: ST_TO_ADDR
// hc_class := class_horse ;
87785: LD_ADDR_OWVAR 28
87789: PUSH
87790: LD_INT 21
87792: ST_TO_ADDR
// hc_gallery :=  ;
87793: LD_ADDR_OWVAR 33
87797: PUSH
87798: LD_STRING 
87800: ST_TO_ADDR
// end ;
87801: LD_VAR 0 1
87805: RET
// export function PrepareMastodont ( ) ; begin
87806: LD_INT 0
87808: PPUSH
// uc_side := 0 ;
87809: LD_ADDR_OWVAR 20
87813: PUSH
87814: LD_INT 0
87816: ST_TO_ADDR
// uc_nation := 0 ;
87817: LD_ADDR_OWVAR 21
87821: PUSH
87822: LD_INT 0
87824: ST_TO_ADDR
// vc_chassis := class_mastodont ;
87825: LD_ADDR_OWVAR 37
87829: PUSH
87830: LD_INT 31
87832: ST_TO_ADDR
// vc_control := control_rider ;
87833: LD_ADDR_OWVAR 38
87837: PUSH
87838: LD_INT 4
87840: ST_TO_ADDR
// end ;
87841: LD_VAR 0 1
87845: RET
// export function PrepareNature ( birds , tigers , apemans , enchidnas , horses , mastodonts , fishes , nat_area , wat_area ) ; var i , animal ; begin
87846: LD_INT 0
87848: PPUSH
87849: PPUSH
87850: PPUSH
// uc_side = 0 ;
87851: LD_ADDR_OWVAR 20
87855: PUSH
87856: LD_INT 0
87858: ST_TO_ADDR
// uc_nation = 0 ;
87859: LD_ADDR_OWVAR 21
87863: PUSH
87864: LD_INT 0
87866: ST_TO_ADDR
// InitHc_All ( ) ;
87867: CALL_OW 584
// InitVc ;
87871: CALL_OW 20
// if mastodonts then
87875: LD_VAR 0 6
87879: IFFALSE 87946
// for i = 1 to mastodonts do
87881: LD_ADDR_VAR 0 11
87885: PUSH
87886: DOUBLE
87887: LD_INT 1
87889: DEC
87890: ST_TO_ADDR
87891: LD_VAR 0 6
87895: PUSH
87896: FOR_TO
87897: IFFALSE 87944
// begin vc_chassis := 31 ;
87899: LD_ADDR_OWVAR 37
87903: PUSH
87904: LD_INT 31
87906: ST_TO_ADDR
// vc_control := control_rider ;
87907: LD_ADDR_OWVAR 38
87911: PUSH
87912: LD_INT 4
87914: ST_TO_ADDR
// animal := CreateVehicle ;
87915: LD_ADDR_VAR 0 12
87919: PUSH
87920: CALL_OW 45
87924: ST_TO_ADDR
// PlaceUnitInArea ( animal , nat_area , false ) ;
87925: LD_VAR 0 12
87929: PPUSH
87930: LD_VAR 0 8
87934: PPUSH
87935: LD_INT 0
87937: PPUSH
87938: CALL 90074 0 3
// end ;
87942: GO 87896
87944: POP
87945: POP
// if horses then
87946: LD_VAR 0 5
87950: IFFALSE 88017
// for i = 1 to horses do
87952: LD_ADDR_VAR 0 11
87956: PUSH
87957: DOUBLE
87958: LD_INT 1
87960: DEC
87961: ST_TO_ADDR
87962: LD_VAR 0 5
87966: PUSH
87967: FOR_TO
87968: IFFALSE 88015
// begin hc_class := 21 ;
87970: LD_ADDR_OWVAR 28
87974: PUSH
87975: LD_INT 21
87977: ST_TO_ADDR
// hc_gallery :=  ;
87978: LD_ADDR_OWVAR 33
87982: PUSH
87983: LD_STRING 
87985: ST_TO_ADDR
// animal := CreateHuman ;
87986: LD_ADDR_VAR 0 12
87990: PUSH
87991: CALL_OW 44
87995: ST_TO_ADDR
// PlaceUnitInArea ( animal , nat_area , false ) ;
87996: LD_VAR 0 12
88000: PPUSH
88001: LD_VAR 0 8
88005: PPUSH
88006: LD_INT 0
88008: PPUSH
88009: CALL 90074 0 3
// end ;
88013: GO 87967
88015: POP
88016: POP
// if birds then
88017: LD_VAR 0 1
88021: IFFALSE 88088
// for i = 1 to birds do
88023: LD_ADDR_VAR 0 11
88027: PUSH
88028: DOUBLE
88029: LD_INT 1
88031: DEC
88032: ST_TO_ADDR
88033: LD_VAR 0 1
88037: PUSH
88038: FOR_TO
88039: IFFALSE 88086
// begin hc_class := 18 ;
88041: LD_ADDR_OWVAR 28
88045: PUSH
88046: LD_INT 18
88048: ST_TO_ADDR
// hc_gallery =  ;
88049: LD_ADDR_OWVAR 33
88053: PUSH
88054: LD_STRING 
88056: ST_TO_ADDR
// animal := CreateHuman ;
88057: LD_ADDR_VAR 0 12
88061: PUSH
88062: CALL_OW 44
88066: ST_TO_ADDR
// PlaceUnitInArea ( animal , nat_area , false ) ;
88067: LD_VAR 0 12
88071: PPUSH
88072: LD_VAR 0 8
88076: PPUSH
88077: LD_INT 0
88079: PPUSH
88080: CALL 90074 0 3
// end ;
88084: GO 88038
88086: POP
88087: POP
// if tigers then
88088: LD_VAR 0 2
88092: IFFALSE 88176
// for i = 1 to tigers do
88094: LD_ADDR_VAR 0 11
88098: PUSH
88099: DOUBLE
88100: LD_INT 1
88102: DEC
88103: ST_TO_ADDR
88104: LD_VAR 0 2
88108: PUSH
88109: FOR_TO
88110: IFFALSE 88174
// begin hc_class = class_tiger ;
88112: LD_ADDR_OWVAR 28
88116: PUSH
88117: LD_INT 14
88119: ST_TO_ADDR
// hc_gallery =  ;
88120: LD_ADDR_OWVAR 33
88124: PUSH
88125: LD_STRING 
88127: ST_TO_ADDR
// hc_agressivity = Rand ( - 7 , 7 ) ;
88128: LD_ADDR_OWVAR 35
88132: PUSH
88133: LD_INT 7
88135: NEG
88136: PPUSH
88137: LD_INT 7
88139: PPUSH
88140: CALL_OW 12
88144: ST_TO_ADDR
// animal := CreateHuman ;
88145: LD_ADDR_VAR 0 12
88149: PUSH
88150: CALL_OW 44
88154: ST_TO_ADDR
// PlaceUnitInArea ( animal , nat_area , false ) ;
88155: LD_VAR 0 12
88159: PPUSH
88160: LD_VAR 0 8
88164: PPUSH
88165: LD_INT 0
88167: PPUSH
88168: CALL 90074 0 3
// end ;
88172: GO 88109
88174: POP
88175: POP
// if apemans then
88176: LD_VAR 0 3
88180: IFFALSE 88303
// for i = 1 to apemans do
88182: LD_ADDR_VAR 0 11
88186: PUSH
88187: DOUBLE
88188: LD_INT 1
88190: DEC
88191: ST_TO_ADDR
88192: LD_VAR 0 3
88196: PUSH
88197: FOR_TO
88198: IFFALSE 88301
// begin hc_class = class_apeman ;
88200: LD_ADDR_OWVAR 28
88204: PUSH
88205: LD_INT 12
88207: ST_TO_ADDR
// hc_gallery =  ;
88208: LD_ADDR_OWVAR 33
88212: PUSH
88213: LD_STRING 
88215: ST_TO_ADDR
// hc_agressivity = rand ( - 2 , 2 ) ;
88216: LD_ADDR_OWVAR 35
88220: PUSH
88221: LD_INT 2
88223: NEG
88224: PPUSH
88225: LD_INT 2
88227: PPUSH
88228: CALL_OW 12
88232: ST_TO_ADDR
// hc_skills := [ rand ( 1 , 3 ) , rand ( 1 , 3 ) , 0 , 0 ] ;
88233: LD_ADDR_OWVAR 31
88237: PUSH
88238: LD_INT 1
88240: PPUSH
88241: LD_INT 3
88243: PPUSH
88244: CALL_OW 12
88248: PUSH
88249: LD_INT 1
88251: PPUSH
88252: LD_INT 3
88254: PPUSH
88255: CALL_OW 12
88259: PUSH
88260: LD_INT 0
88262: PUSH
88263: LD_INT 0
88265: PUSH
88266: EMPTY
88267: LIST
88268: LIST
88269: LIST
88270: LIST
88271: ST_TO_ADDR
// animal := CreateHuman ;
88272: LD_ADDR_VAR 0 12
88276: PUSH
88277: CALL_OW 44
88281: ST_TO_ADDR
// PlaceUnitInArea ( animal , nat_area , false ) ;
88282: LD_VAR 0 12
88286: PPUSH
88287: LD_VAR 0 8
88291: PPUSH
88292: LD_INT 0
88294: PPUSH
88295: CALL 90074 0 3
// end ;
88299: GO 88197
88301: POP
88302: POP
// if enchidnas then
88303: LD_VAR 0 4
88307: IFFALSE 88374
// for i = 1 to enchidnas do
88309: LD_ADDR_VAR 0 11
88313: PUSH
88314: DOUBLE
88315: LD_INT 1
88317: DEC
88318: ST_TO_ADDR
88319: LD_VAR 0 4
88323: PUSH
88324: FOR_TO
88325: IFFALSE 88372
// begin hc_class = 13 ;
88327: LD_ADDR_OWVAR 28
88331: PUSH
88332: LD_INT 13
88334: ST_TO_ADDR
// hc_gallery =  ;
88335: LD_ADDR_OWVAR 33
88339: PUSH
88340: LD_STRING 
88342: ST_TO_ADDR
// animal := CreateHuman ;
88343: LD_ADDR_VAR 0 12
88347: PUSH
88348: CALL_OW 44
88352: ST_TO_ADDR
// PlaceUnitInArea ( animal , nat_area , false ) ;
88353: LD_VAR 0 12
88357: PPUSH
88358: LD_VAR 0 8
88362: PPUSH
88363: LD_INT 0
88365: PPUSH
88366: CALL 90074 0 3
// end ;
88370: GO 88324
88372: POP
88373: POP
// if fishes then
88374: LD_VAR 0 7
88378: IFFALSE 88445
// for i = 1 to fishes do
88380: LD_ADDR_VAR 0 11
88384: PUSH
88385: DOUBLE
88386: LD_INT 1
88388: DEC
88389: ST_TO_ADDR
88390: LD_VAR 0 7
88394: PUSH
88395: FOR_TO
88396: IFFALSE 88443
// begin hc_class = 20 ;
88398: LD_ADDR_OWVAR 28
88402: PUSH
88403: LD_INT 20
88405: ST_TO_ADDR
// hc_gallery =  ;
88406: LD_ADDR_OWVAR 33
88410: PUSH
88411: LD_STRING 
88413: ST_TO_ADDR
// animal := CreateHuman ;
88414: LD_ADDR_VAR 0 12
88418: PUSH
88419: CALL_OW 44
88423: ST_TO_ADDR
// PlaceUnitInArea ( animal , wat_area , false ) ;
88424: LD_VAR 0 12
88428: PPUSH
88429: LD_VAR 0 9
88433: PPUSH
88434: LD_INT 0
88436: PPUSH
88437: CALL 90074 0 3
// end ;
88441: GO 88395
88443: POP
88444: POP
// end ;
88445: LD_VAR 0 10
88449: RET
// export function WantHeal ( sci , unit ) ; begin
88450: LD_INT 0
88452: PPUSH
// if GetTaskList ( sci ) > 0 then
88453: LD_VAR 0 1
88457: PPUSH
88458: CALL_OW 437
88462: PUSH
88463: LD_INT 0
88465: GREATER
88466: IFFALSE 88536
// begin if GetTaskList ( sci ) [ 1 ] [ 1 ] = l and GetTaskList ( sci ) [ 1 ] [ 4 ] = unit then
88468: LD_VAR 0 1
88472: PPUSH
88473: CALL_OW 437
88477: PUSH
88478: LD_INT 1
88480: ARRAY
88481: PUSH
88482: LD_INT 1
88484: ARRAY
88485: PUSH
88486: LD_STRING l
88488: EQUAL
88489: PUSH
88490: LD_VAR 0 1
88494: PPUSH
88495: CALL_OW 437
88499: PUSH
88500: LD_INT 1
88502: ARRAY
88503: PUSH
88504: LD_INT 4
88506: ARRAY
88507: PUSH
88508: LD_VAR 0 2
88512: EQUAL
88513: AND
88514: IFFALSE 88526
// result := true else
88516: LD_ADDR_VAR 0 3
88520: PUSH
88521: LD_INT 1
88523: ST_TO_ADDR
88524: GO 88534
// result := false ;
88526: LD_ADDR_VAR 0 3
88530: PUSH
88531: LD_INT 0
88533: ST_TO_ADDR
// end else
88534: GO 88544
// result := false ;
88536: LD_ADDR_VAR 0 3
88540: PUSH
88541: LD_INT 0
88543: ST_TO_ADDR
// end ;
88544: LD_VAR 0 3
88548: RET
// export function HealTarget ( sci ) ; begin
88549: LD_INT 0
88551: PPUSH
// if not sci then
88552: LD_VAR 0 1
88556: NOT
88557: IFFALSE 88561
// exit ;
88559: GO 88626
// result := 0 ;
88561: LD_ADDR_VAR 0 2
88565: PUSH
88566: LD_INT 0
88568: ST_TO_ADDR
// if GetTaskList ( sci ) then
88569: LD_VAR 0 1
88573: PPUSH
88574: CALL_OW 437
88578: IFFALSE 88626
// if GetTaskList ( sci ) [ 1 ] [ 1 ] = l then
88580: LD_VAR 0 1
88584: PPUSH
88585: CALL_OW 437
88589: PUSH
88590: LD_INT 1
88592: ARRAY
88593: PUSH
88594: LD_INT 1
88596: ARRAY
88597: PUSH
88598: LD_STRING l
88600: EQUAL
88601: IFFALSE 88626
// result := GetTaskList ( sci ) [ 1 ] [ 4 ] ;
88603: LD_ADDR_VAR 0 2
88607: PUSH
88608: LD_VAR 0 1
88612: PPUSH
88613: CALL_OW 437
88617: PUSH
88618: LD_INT 1
88620: ARRAY
88621: PUSH
88622: LD_INT 4
88624: ARRAY
88625: ST_TO_ADDR
// end ;
88626: LD_VAR 0 2
88630: RET
// export function _ScanBase ( base_units ) ; var i , t , tmp ; begin
88631: LD_INT 0
88633: PPUSH
88634: PPUSH
88635: PPUSH
88636: PPUSH
// if not base_units then
88637: LD_VAR 0 1
88641: NOT
88642: IFFALSE 88646
// exit ;
88644: GO 88733
// result := false ;
88646: LD_ADDR_VAR 0 2
88650: PUSH
88651: LD_INT 0
88653: ST_TO_ADDR
// tmp := UnitFilter ( base_units , [ f_type , unit_building ] ) ;
88654: LD_ADDR_VAR 0 5
88658: PUSH
88659: LD_VAR 0 1
88663: PPUSH
88664: LD_INT 21
88666: PUSH
88667: LD_INT 3
88669: PUSH
88670: EMPTY
88671: LIST
88672: LIST
88673: PPUSH
88674: CALL_OW 72
88678: ST_TO_ADDR
// if not tmp then
88679: LD_VAR 0 5
88683: NOT
88684: IFFALSE 88688
// exit ;
88686: GO 88733
// for i in tmp do
88688: LD_ADDR_VAR 0 3
88692: PUSH
88693: LD_VAR 0 5
88697: PUSH
88698: FOR_IN
88699: IFFALSE 88731
// begin result := EnemyInRange ( i , 22 ) ;
88701: LD_ADDR_VAR 0 2
88705: PUSH
88706: LD_VAR 0 3
88710: PPUSH
88711: LD_INT 22
88713: PPUSH
88714: CALL 86331 0 2
88718: ST_TO_ADDR
// if result then
88719: LD_VAR 0 2
88723: IFFALSE 88729
// exit ;
88725: POP
88726: POP
88727: GO 88733
// end ;
88729: GO 88698
88731: POP
88732: POP
// end ;
88733: LD_VAR 0 2
88737: RET
// export function FilterByTag ( units , tag ) ; begin
88738: LD_INT 0
88740: PPUSH
// result := UnitFilter ( units , [ f_tag , tag ] ) ;
88741: LD_ADDR_VAR 0 3
88745: PUSH
88746: LD_VAR 0 1
88750: PPUSH
88751: LD_INT 120
88753: PUSH
88754: LD_VAR 0 2
88758: PUSH
88759: EMPTY
88760: LIST
88761: LIST
88762: PPUSH
88763: CALL_OW 72
88767: ST_TO_ADDR
// end ;
88768: LD_VAR 0 3
88772: RET
// export function IsDriver ( un ) ; begin
88773: LD_INT 0
88775: PPUSH
// result := un in FilterAllUnits ( [ f_driving ] ) ;
88776: LD_ADDR_VAR 0 2
88780: PUSH
88781: LD_VAR 0 1
88785: PUSH
88786: LD_INT 55
88788: PUSH
88789: EMPTY
88790: LIST
88791: PPUSH
88792: CALL_OW 69
88796: IN
88797: ST_TO_ADDR
// end ;
88798: LD_VAR 0 2
88802: RET
// export function GetFacExtXYD ( x , y , d ) ; var list ; begin
88803: LD_INT 0
88805: PPUSH
88806: PPUSH
// list := [ ] ;
88807: LD_ADDR_VAR 0 5
88811: PUSH
88812: EMPTY
88813: ST_TO_ADDR
// case d of 0 :
88814: LD_VAR 0 3
88818: PUSH
88819: LD_INT 0
88821: DOUBLE
88822: EQUAL
88823: IFTRUE 88827
88825: GO 88960
88827: POP
// begin list := [ [ x - 4 , y - 4 , 2 ] , [ x - 3 , y , 1 ] , [ x + 4 , y , 4 ] , [ x + 3 , y + 3 , 5 ] , [ x , y + 4 , 0 ] ] ;
88828: LD_ADDR_VAR 0 5
88832: PUSH
88833: LD_VAR 0 1
88837: PUSH
88838: LD_INT 4
88840: MINUS
88841: PUSH
88842: LD_VAR 0 2
88846: PUSH
88847: LD_INT 4
88849: MINUS
88850: PUSH
88851: LD_INT 2
88853: PUSH
88854: EMPTY
88855: LIST
88856: LIST
88857: LIST
88858: PUSH
88859: LD_VAR 0 1
88863: PUSH
88864: LD_INT 3
88866: MINUS
88867: PUSH
88868: LD_VAR 0 2
88872: PUSH
88873: LD_INT 1
88875: PUSH
88876: EMPTY
88877: LIST
88878: LIST
88879: LIST
88880: PUSH
88881: LD_VAR 0 1
88885: PUSH
88886: LD_INT 4
88888: PLUS
88889: PUSH
88890: LD_VAR 0 2
88894: PUSH
88895: LD_INT 4
88897: PUSH
88898: EMPTY
88899: LIST
88900: LIST
88901: LIST
88902: PUSH
88903: LD_VAR 0 1
88907: PUSH
88908: LD_INT 3
88910: PLUS
88911: PUSH
88912: LD_VAR 0 2
88916: PUSH
88917: LD_INT 3
88919: PLUS
88920: PUSH
88921: LD_INT 5
88923: PUSH
88924: EMPTY
88925: LIST
88926: LIST
88927: LIST
88928: PUSH
88929: LD_VAR 0 1
88933: PUSH
88934: LD_VAR 0 2
88938: PUSH
88939: LD_INT 4
88941: PLUS
88942: PUSH
88943: LD_INT 0
88945: PUSH
88946: EMPTY
88947: LIST
88948: LIST
88949: LIST
88950: PUSH
88951: EMPTY
88952: LIST
88953: LIST
88954: LIST
88955: LIST
88956: LIST
88957: ST_TO_ADDR
// end ; 1 :
88958: GO 89658
88960: LD_INT 1
88962: DOUBLE
88963: EQUAL
88964: IFTRUE 88968
88966: GO 89101
88968: POP
// begin list := [ [ x , y - 4 , 3 ] , [ x - 3 , y - 3 , 2 ] , [ x - 4 , y , 1 ] , [ x , y + 3 , 0 ] , [ x + 4 , y + 4 , 5 ] ] ;
88969: LD_ADDR_VAR 0 5
88973: PUSH
88974: LD_VAR 0 1
88978: PUSH
88979: LD_VAR 0 2
88983: PUSH
88984: LD_INT 4
88986: MINUS
88987: PUSH
88988: LD_INT 3
88990: PUSH
88991: EMPTY
88992: LIST
88993: LIST
88994: LIST
88995: PUSH
88996: LD_VAR 0 1
89000: PUSH
89001: LD_INT 3
89003: MINUS
89004: PUSH
89005: LD_VAR 0 2
89009: PUSH
89010: LD_INT 3
89012: MINUS
89013: PUSH
89014: LD_INT 2
89016: PUSH
89017: EMPTY
89018: LIST
89019: LIST
89020: LIST
89021: PUSH
89022: LD_VAR 0 1
89026: PUSH
89027: LD_INT 4
89029: MINUS
89030: PUSH
89031: LD_VAR 0 2
89035: PUSH
89036: LD_INT 1
89038: PUSH
89039: EMPTY
89040: LIST
89041: LIST
89042: LIST
89043: PUSH
89044: LD_VAR 0 1
89048: PUSH
89049: LD_VAR 0 2
89053: PUSH
89054: LD_INT 3
89056: PLUS
89057: PUSH
89058: LD_INT 0
89060: PUSH
89061: EMPTY
89062: LIST
89063: LIST
89064: LIST
89065: PUSH
89066: LD_VAR 0 1
89070: PUSH
89071: LD_INT 4
89073: PLUS
89074: PUSH
89075: LD_VAR 0 2
89079: PUSH
89080: LD_INT 4
89082: PLUS
89083: PUSH
89084: LD_INT 5
89086: PUSH
89087: EMPTY
89088: LIST
89089: LIST
89090: LIST
89091: PUSH
89092: EMPTY
89093: LIST
89094: LIST
89095: LIST
89096: LIST
89097: LIST
89098: ST_TO_ADDR
// end ; 2 :
89099: GO 89658
89101: LD_INT 2
89103: DOUBLE
89104: EQUAL
89105: IFTRUE 89109
89107: GO 89238
89109: POP
// begin list := [ [ x , y - 3 , 3 ] , [ x + 4 , y , 4 ] , [ x , y + 4 , 0 ] , [ x - 3 , y , 1 ] , [ x - 4 , y - 4 , 2 ] ] ;
89110: LD_ADDR_VAR 0 5
89114: PUSH
89115: LD_VAR 0 1
89119: PUSH
89120: LD_VAR 0 2
89124: PUSH
89125: LD_INT 3
89127: MINUS
89128: PUSH
89129: LD_INT 3
89131: PUSH
89132: EMPTY
89133: LIST
89134: LIST
89135: LIST
89136: PUSH
89137: LD_VAR 0 1
89141: PUSH
89142: LD_INT 4
89144: PLUS
89145: PUSH
89146: LD_VAR 0 2
89150: PUSH
89151: LD_INT 4
89153: PUSH
89154: EMPTY
89155: LIST
89156: LIST
89157: LIST
89158: PUSH
89159: LD_VAR 0 1
89163: PUSH
89164: LD_VAR 0 2
89168: PUSH
89169: LD_INT 4
89171: PLUS
89172: PUSH
89173: LD_INT 0
89175: PUSH
89176: EMPTY
89177: LIST
89178: LIST
89179: LIST
89180: PUSH
89181: LD_VAR 0 1
89185: PUSH
89186: LD_INT 3
89188: MINUS
89189: PUSH
89190: LD_VAR 0 2
89194: PUSH
89195: LD_INT 1
89197: PUSH
89198: EMPTY
89199: LIST
89200: LIST
89201: LIST
89202: PUSH
89203: LD_VAR 0 1
89207: PUSH
89208: LD_INT 4
89210: MINUS
89211: PUSH
89212: LD_VAR 0 2
89216: PUSH
89217: LD_INT 4
89219: MINUS
89220: PUSH
89221: LD_INT 2
89223: PUSH
89224: EMPTY
89225: LIST
89226: LIST
89227: LIST
89228: PUSH
89229: EMPTY
89230: LIST
89231: LIST
89232: LIST
89233: LIST
89234: LIST
89235: ST_TO_ADDR
// end ; 3 :
89236: GO 89658
89238: LD_INT 3
89240: DOUBLE
89241: EQUAL
89242: IFTRUE 89246
89244: GO 89379
89246: POP
// begin list := [ [ x + 3 , y , 4 ] , [ x + 4 , y + 4 , 5 ] , [ x - 4 , y , 1 ] , [ x , y - 4 , 3 ] , [ x - 3 , y - 3 , 2 ] ] ;
89247: LD_ADDR_VAR 0 5
89251: PUSH
89252: LD_VAR 0 1
89256: PUSH
89257: LD_INT 3
89259: PLUS
89260: PUSH
89261: LD_VAR 0 2
89265: PUSH
89266: LD_INT 4
89268: PUSH
89269: EMPTY
89270: LIST
89271: LIST
89272: LIST
89273: PUSH
89274: LD_VAR 0 1
89278: PUSH
89279: LD_INT 4
89281: PLUS
89282: PUSH
89283: LD_VAR 0 2
89287: PUSH
89288: LD_INT 4
89290: PLUS
89291: PUSH
89292: LD_INT 5
89294: PUSH
89295: EMPTY
89296: LIST
89297: LIST
89298: LIST
89299: PUSH
89300: LD_VAR 0 1
89304: PUSH
89305: LD_INT 4
89307: MINUS
89308: PUSH
89309: LD_VAR 0 2
89313: PUSH
89314: LD_INT 1
89316: PUSH
89317: EMPTY
89318: LIST
89319: LIST
89320: LIST
89321: PUSH
89322: LD_VAR 0 1
89326: PUSH
89327: LD_VAR 0 2
89331: PUSH
89332: LD_INT 4
89334: MINUS
89335: PUSH
89336: LD_INT 3
89338: PUSH
89339: EMPTY
89340: LIST
89341: LIST
89342: LIST
89343: PUSH
89344: LD_VAR 0 1
89348: PUSH
89349: LD_INT 3
89351: MINUS
89352: PUSH
89353: LD_VAR 0 2
89357: PUSH
89358: LD_INT 3
89360: MINUS
89361: PUSH
89362: LD_INT 2
89364: PUSH
89365: EMPTY
89366: LIST
89367: LIST
89368: LIST
89369: PUSH
89370: EMPTY
89371: LIST
89372: LIST
89373: LIST
89374: LIST
89375: LIST
89376: ST_TO_ADDR
// end ; 4 :
89377: GO 89658
89379: LD_INT 4
89381: DOUBLE
89382: EQUAL
89383: IFTRUE 89387
89385: GO 89520
89387: POP
// begin list := [ [ x , y + 4 , 0 ] , [ x + 3 , y + 3 , 5 ] , [ x + 4 , y , 4 ] , [ x , y - 3 , 3 ] , [ x - 4 , y - 4 , 2 ] ] ;
89388: LD_ADDR_VAR 0 5
89392: PUSH
89393: LD_VAR 0 1
89397: PUSH
89398: LD_VAR 0 2
89402: PUSH
89403: LD_INT 4
89405: PLUS
89406: PUSH
89407: LD_INT 0
89409: PUSH
89410: EMPTY
89411: LIST
89412: LIST
89413: LIST
89414: PUSH
89415: LD_VAR 0 1
89419: PUSH
89420: LD_INT 3
89422: PLUS
89423: PUSH
89424: LD_VAR 0 2
89428: PUSH
89429: LD_INT 3
89431: PLUS
89432: PUSH
89433: LD_INT 5
89435: PUSH
89436: EMPTY
89437: LIST
89438: LIST
89439: LIST
89440: PUSH
89441: LD_VAR 0 1
89445: PUSH
89446: LD_INT 4
89448: PLUS
89449: PUSH
89450: LD_VAR 0 2
89454: PUSH
89455: LD_INT 4
89457: PUSH
89458: EMPTY
89459: LIST
89460: LIST
89461: LIST
89462: PUSH
89463: LD_VAR 0 1
89467: PUSH
89468: LD_VAR 0 2
89472: PUSH
89473: LD_INT 3
89475: MINUS
89476: PUSH
89477: LD_INT 3
89479: PUSH
89480: EMPTY
89481: LIST
89482: LIST
89483: LIST
89484: PUSH
89485: LD_VAR 0 1
89489: PUSH
89490: LD_INT 4
89492: MINUS
89493: PUSH
89494: LD_VAR 0 2
89498: PUSH
89499: LD_INT 4
89501: MINUS
89502: PUSH
89503: LD_INT 2
89505: PUSH
89506: EMPTY
89507: LIST
89508: LIST
89509: LIST
89510: PUSH
89511: EMPTY
89512: LIST
89513: LIST
89514: LIST
89515: LIST
89516: LIST
89517: ST_TO_ADDR
// end ; 5 :
89518: GO 89658
89520: LD_INT 5
89522: DOUBLE
89523: EQUAL
89524: IFTRUE 89528
89526: GO 89657
89528: POP
// begin list := [ [ x - 4 , y , 1 ] , [ x , y - 4 , 3 ] , [ x + 4 , y + 4 , 5 ] , [ x + 3 , y , 4 ] , [ x , y + 3 , 0 ] ] ;
89529: LD_ADDR_VAR 0 5
89533: PUSH
89534: LD_VAR 0 1
89538: PUSH
89539: LD_INT 4
89541: MINUS
89542: PUSH
89543: LD_VAR 0 2
89547: PUSH
89548: LD_INT 1
89550: PUSH
89551: EMPTY
89552: LIST
89553: LIST
89554: LIST
89555: PUSH
89556: LD_VAR 0 1
89560: PUSH
89561: LD_VAR 0 2
89565: PUSH
89566: LD_INT 4
89568: MINUS
89569: PUSH
89570: LD_INT 3
89572: PUSH
89573: EMPTY
89574: LIST
89575: LIST
89576: LIST
89577: PUSH
89578: LD_VAR 0 1
89582: PUSH
89583: LD_INT 4
89585: PLUS
89586: PUSH
89587: LD_VAR 0 2
89591: PUSH
89592: LD_INT 4
89594: PLUS
89595: PUSH
89596: LD_INT 5
89598: PUSH
89599: EMPTY
89600: LIST
89601: LIST
89602: LIST
89603: PUSH
89604: LD_VAR 0 1
89608: PUSH
89609: LD_INT 3
89611: PLUS
89612: PUSH
89613: LD_VAR 0 2
89617: PUSH
89618: LD_INT 4
89620: PUSH
89621: EMPTY
89622: LIST
89623: LIST
89624: LIST
89625: PUSH
89626: LD_VAR 0 1
89630: PUSH
89631: LD_VAR 0 2
89635: PUSH
89636: LD_INT 3
89638: PLUS
89639: PUSH
89640: LD_INT 0
89642: PUSH
89643: EMPTY
89644: LIST
89645: LIST
89646: LIST
89647: PUSH
89648: EMPTY
89649: LIST
89650: LIST
89651: LIST
89652: LIST
89653: LIST
89654: ST_TO_ADDR
// end ; end ;
89655: GO 89658
89657: POP
// result := list ;
89658: LD_ADDR_VAR 0 4
89662: PUSH
89663: LD_VAR 0 5
89667: ST_TO_ADDR
// end ;
89668: LD_VAR 0 4
89672: RET
// export function SortBySkill ( units , class ) ; var i , tmp ; begin
89673: LD_INT 0
89675: PPUSH
89676: PPUSH
89677: PPUSH
// if not units or not class in [ 1 , 2 , 3 , 4 ] then
89678: LD_VAR 0 1
89682: NOT
89683: PUSH
89684: LD_VAR 0 2
89688: PUSH
89689: LD_INT 1
89691: PUSH
89692: LD_INT 2
89694: PUSH
89695: LD_INT 3
89697: PUSH
89698: LD_INT 4
89700: PUSH
89701: EMPTY
89702: LIST
89703: LIST
89704: LIST
89705: LIST
89706: IN
89707: NOT
89708: OR
89709: IFFALSE 89713
// exit ;
89711: GO 89796
// tmp := [ ] ;
89713: LD_ADDR_VAR 0 5
89717: PUSH
89718: EMPTY
89719: ST_TO_ADDR
// for i in units do
89720: LD_ADDR_VAR 0 4
89724: PUSH
89725: LD_VAR 0 1
89729: PUSH
89730: FOR_IN
89731: IFFALSE 89765
// tmp := Join ( tmp , GetSkill ( i , class ) ) ;
89733: LD_ADDR_VAR 0 5
89737: PUSH
89738: LD_VAR 0 5
89742: PPUSH
89743: LD_VAR 0 4
89747: PPUSH
89748: LD_VAR 0 2
89752: PPUSH
89753: CALL_OW 259
89757: PPUSH
89758: CALL 91169 0 2
89762: ST_TO_ADDR
89763: GO 89730
89765: POP
89766: POP
// if not tmp then
89767: LD_VAR 0 5
89771: NOT
89772: IFFALSE 89776
// exit ;
89774: GO 89796
// result := SortListByListDesc ( units , tmp ) ;
89776: LD_ADDR_VAR 0 3
89780: PUSH
89781: LD_VAR 0 1
89785: PPUSH
89786: LD_VAR 0 5
89790: PPUSH
89791: CALL_OW 77
89795: ST_TO_ADDR
// end ;
89796: LD_VAR 0 3
89800: RET
// export function UnitGoingToBuilding ( unit , building ) ; var x , y ; begin
89801: LD_INT 0
89803: PPUSH
89804: PPUSH
89805: PPUSH
// result := false ;
89806: LD_ADDR_VAR 0 3
89810: PUSH
89811: LD_INT 0
89813: ST_TO_ADDR
// if not building then
89814: LD_VAR 0 2
89818: NOT
89819: IFFALSE 89823
// exit ;
89821: GO 89961
// x := GetX ( building ) ;
89823: LD_ADDR_VAR 0 4
89827: PUSH
89828: LD_VAR 0 2
89832: PPUSH
89833: CALL_OW 250
89837: ST_TO_ADDR
// y := GetY ( building ) ;
89838: LD_ADDR_VAR 0 5
89842: PUSH
89843: LD_VAR 0 2
89847: PPUSH
89848: CALL_OW 251
89852: ST_TO_ADDR
// if not x or not y then
89853: LD_VAR 0 4
89857: NOT
89858: PUSH
89859: LD_VAR 0 5
89863: NOT
89864: OR
89865: IFFALSE 89869
// exit ;
89867: GO 89961
// if GetTaskList ( unit ) then
89869: LD_VAR 0 1
89873: PPUSH
89874: CALL_OW 437
89878: IFFALSE 89961
// begin if e = GetTaskList ( unit ) [ 1 ] [ 1 ] and x = GetTaskList ( unit ) [ 1 ] [ 2 ] and y = GetTaskList ( unit ) [ 1 ] [ 3 ] then
89880: LD_STRING e
89882: PUSH
89883: LD_VAR 0 1
89887: PPUSH
89888: CALL_OW 437
89892: PUSH
89893: LD_INT 1
89895: ARRAY
89896: PUSH
89897: LD_INT 1
89899: ARRAY
89900: EQUAL
89901: PUSH
89902: LD_VAR 0 4
89906: PUSH
89907: LD_VAR 0 1
89911: PPUSH
89912: CALL_OW 437
89916: PUSH
89917: LD_INT 1
89919: ARRAY
89920: PUSH
89921: LD_INT 2
89923: ARRAY
89924: EQUAL
89925: AND
89926: PUSH
89927: LD_VAR 0 5
89931: PUSH
89932: LD_VAR 0 1
89936: PPUSH
89937: CALL_OW 437
89941: PUSH
89942: LD_INT 1
89944: ARRAY
89945: PUSH
89946: LD_INT 3
89948: ARRAY
89949: EQUAL
89950: AND
89951: IFFALSE 89961
// result := true end ;
89953: LD_ADDR_VAR 0 3
89957: PUSH
89958: LD_INT 1
89960: ST_TO_ADDR
// end ;
89961: LD_VAR 0 3
89965: RET
// export function UnitGoingToXY ( unit , x , y ) ; begin
89966: LD_INT 0
89968: PPUSH
// result := false ;
89969: LD_ADDR_VAR 0 4
89973: PUSH
89974: LD_INT 0
89976: ST_TO_ADDR
// if GetTaskList ( unit ) then
89977: LD_VAR 0 1
89981: PPUSH
89982: CALL_OW 437
89986: IFFALSE 90069
// begin if M = GetTaskList ( unit ) [ 1 ] [ 1 ] and x = GetTaskList ( unit ) [ 1 ] [ 2 ] and y = GetTaskList ( unit ) [ 1 ] [ 3 ] then
89988: LD_STRING M
89990: PUSH
89991: LD_VAR 0 1
89995: PPUSH
89996: CALL_OW 437
90000: PUSH
90001: LD_INT 1
90003: ARRAY
90004: PUSH
90005: LD_INT 1
90007: ARRAY
90008: EQUAL
90009: PUSH
90010: LD_VAR 0 2
90014: PUSH
90015: LD_VAR 0 1
90019: PPUSH
90020: CALL_OW 437
90024: PUSH
90025: LD_INT 1
90027: ARRAY
90028: PUSH
90029: LD_INT 2
90031: ARRAY
90032: EQUAL
90033: AND
90034: PUSH
90035: LD_VAR 0 3
90039: PUSH
90040: LD_VAR 0 1
90044: PPUSH
90045: CALL_OW 437
90049: PUSH
90050: LD_INT 1
90052: ARRAY
90053: PUSH
90054: LD_INT 3
90056: ARRAY
90057: EQUAL
90058: AND
90059: IFFALSE 90069
// result := true ;
90061: LD_ADDR_VAR 0 4
90065: PUSH
90066: LD_INT 1
90068: ST_TO_ADDR
// end ; end ;
90069: LD_VAR 0 4
90073: RET
// export function PlaceUnitInArea ( unit , area , mode ) ; var i , tmp , hex ; begin
90074: LD_INT 0
90076: PPUSH
90077: PPUSH
90078: PPUSH
90079: PPUSH
// if not unit or not area then
90080: LD_VAR 0 1
90084: NOT
90085: PUSH
90086: LD_VAR 0 2
90090: NOT
90091: OR
90092: IFFALSE 90096
// exit ;
90094: GO 90272
// tmp := AreaToList ( area , i ) ;
90096: LD_ADDR_VAR 0 6
90100: PUSH
90101: LD_VAR 0 2
90105: PPUSH
90106: LD_VAR 0 5
90110: PPUSH
90111: CALL_OW 517
90115: ST_TO_ADDR
// for i = 1 to tmp [ 1 ] do
90116: LD_ADDR_VAR 0 5
90120: PUSH
90121: DOUBLE
90122: LD_INT 1
90124: DEC
90125: ST_TO_ADDR
90126: LD_VAR 0 6
90130: PUSH
90131: LD_INT 1
90133: ARRAY
90134: PUSH
90135: FOR_TO
90136: IFFALSE 90270
// begin hex := [ tmp [ 1 ] [ i ] , tmp [ 2 ] [ i ] ] ;
90138: LD_ADDR_VAR 0 7
90142: PUSH
90143: LD_VAR 0 6
90147: PUSH
90148: LD_INT 1
90150: ARRAY
90151: PUSH
90152: LD_VAR 0 5
90156: ARRAY
90157: PUSH
90158: LD_VAR 0 6
90162: PUSH
90163: LD_INT 2
90165: ARRAY
90166: PUSH
90167: LD_VAR 0 5
90171: ARRAY
90172: PUSH
90173: EMPTY
90174: LIST
90175: LIST
90176: ST_TO_ADDR
// if FilterAllUnits ( [ f_distxy , hex [ 1 ] , hex [ 2 ] , 2 ] ) = 0 then
90177: LD_INT 92
90179: PUSH
90180: LD_VAR 0 7
90184: PUSH
90185: LD_INT 1
90187: ARRAY
90188: PUSH
90189: LD_VAR 0 7
90193: PUSH
90194: LD_INT 2
90196: ARRAY
90197: PUSH
90198: LD_INT 2
90200: PUSH
90201: EMPTY
90202: LIST
90203: LIST
90204: LIST
90205: LIST
90206: PPUSH
90207: CALL_OW 69
90211: PUSH
90212: LD_INT 0
90214: EQUAL
90215: IFFALSE 90268
// begin PlaceUnitXY ( unit , hex [ 1 ] , hex [ 2 ] , mode ) ;
90217: LD_VAR 0 1
90221: PPUSH
90222: LD_VAR 0 7
90226: PUSH
90227: LD_INT 1
90229: ARRAY
90230: PPUSH
90231: LD_VAR 0 7
90235: PUSH
90236: LD_INT 2
90238: ARRAY
90239: PPUSH
90240: LD_VAR 0 3
90244: PPUSH
90245: CALL_OW 48
// result := IsPlaced ( unit ) ;
90249: LD_ADDR_VAR 0 4
90253: PUSH
90254: LD_VAR 0 1
90258: PPUSH
90259: CALL_OW 305
90263: ST_TO_ADDR
// exit ;
90264: POP
90265: POP
90266: GO 90272
// end ; end ;
90268: GO 90135
90270: POP
90271: POP
// end ;
90272: LD_VAR 0 4
90276: RET
// export function BuildingsListDump ( side ) ; var i , tmp ; begin
90277: LD_INT 0
90279: PPUSH
90280: PPUSH
90281: PPUSH
// if not side or side > 8 then
90282: LD_VAR 0 1
90286: NOT
90287: PUSH
90288: LD_VAR 0 1
90292: PUSH
90293: LD_INT 8
90295: GREATER
90296: OR
90297: IFFALSE 90301
// exit ;
90299: GO 90488
// tmp := FilterAllUnits ( [ [ f_side , side ] , [ f_type , unit_building ] ] ) ;
90301: LD_ADDR_VAR 0 4
90305: PUSH
90306: LD_INT 22
90308: PUSH
90309: LD_VAR 0 1
90313: PUSH
90314: EMPTY
90315: LIST
90316: LIST
90317: PUSH
90318: LD_INT 21
90320: PUSH
90321: LD_INT 3
90323: PUSH
90324: EMPTY
90325: LIST
90326: LIST
90327: PUSH
90328: EMPTY
90329: LIST
90330: LIST
90331: PPUSH
90332: CALL_OW 69
90336: ST_TO_ADDR
// if not tmp then
90337: LD_VAR 0 4
90341: NOT
90342: IFFALSE 90346
// exit ;
90344: GO 90488
// enable_addtolog := true ;
90346: LD_ADDR_OWVAR 81
90350: PUSH
90351: LD_INT 1
90353: ST_TO_ADDR
// AddToLog ( [ ) ;
90354: LD_STRING [
90356: PPUSH
90357: CALL_OW 561
// for i in tmp do
90361: LD_ADDR_VAR 0 3
90365: PUSH
90366: LD_VAR 0 4
90370: PUSH
90371: FOR_IN
90372: IFFALSE 90479
// begin AddToLog ( [ & GetBType ( i ) & ,  & GetX ( i ) & ,  & GetY ( i ) & ,  & GetDir ( i ) & ,  & GetLabKind ( i , 1 ) & ,  & GetLabKind ( i , 2 ) & ], ) ;
90374: LD_STRING [
90376: PUSH
90377: LD_VAR 0 3
90381: PPUSH
90382: CALL_OW 266
90386: STR
90387: PUSH
90388: LD_STRING , 
90390: STR
90391: PUSH
90392: LD_VAR 0 3
90396: PPUSH
90397: CALL_OW 250
90401: STR
90402: PUSH
90403: LD_STRING , 
90405: STR
90406: PUSH
90407: LD_VAR 0 3
90411: PPUSH
90412: CALL_OW 251
90416: STR
90417: PUSH
90418: LD_STRING , 
90420: STR
90421: PUSH
90422: LD_VAR 0 3
90426: PPUSH
90427: CALL_OW 254
90431: STR
90432: PUSH
90433: LD_STRING , 
90435: STR
90436: PUSH
90437: LD_VAR 0 3
90441: PPUSH
90442: LD_INT 1
90444: PPUSH
90445: CALL_OW 268
90449: STR
90450: PUSH
90451: LD_STRING , 
90453: STR
90454: PUSH
90455: LD_VAR 0 3
90459: PPUSH
90460: LD_INT 2
90462: PPUSH
90463: CALL_OW 268
90467: STR
90468: PUSH
90469: LD_STRING ],
90471: STR
90472: PPUSH
90473: CALL_OW 561
// end ;
90477: GO 90371
90479: POP
90480: POP
// AddToLog ( ]; ) ;
90481: LD_STRING ];
90483: PPUSH
90484: CALL_OW 561
// end ;
90488: LD_VAR 0 2
90492: RET
// export function Crates ( area , rate , min , max ) ; var i , r , time , amount ; begin
90493: LD_INT 0
90495: PPUSH
90496: PPUSH
90497: PPUSH
90498: PPUSH
90499: PPUSH
// if not area or not rate or not max then
90500: LD_VAR 0 1
90504: NOT
90505: PUSH
90506: LD_VAR 0 2
90510: NOT
90511: OR
90512: PUSH
90513: LD_VAR 0 4
90517: NOT
90518: OR
90519: IFFALSE 90523
// exit ;
90521: GO 90712
// while 1 do
90523: LD_INT 1
90525: IFFALSE 90712
// begin amount := GetResourceArea ( area , mat_cans ) * 10 ;
90527: LD_ADDR_VAR 0 9
90531: PUSH
90532: LD_VAR 0 1
90536: PPUSH
90537: LD_INT 1
90539: PPUSH
90540: CALL_OW 287
90544: PUSH
90545: LD_INT 10
90547: MUL
90548: ST_TO_ADDR
// r := rate / 10 ;
90549: LD_ADDR_VAR 0 7
90553: PUSH
90554: LD_VAR 0 2
90558: PUSH
90559: LD_INT 10
90561: DIVREAL
90562: ST_TO_ADDR
// time := 1 1$00 ;
90563: LD_ADDR_VAR 0 8
90567: PUSH
90568: LD_INT 2100
90570: ST_TO_ADDR
// if amount < min then
90571: LD_VAR 0 9
90575: PUSH
90576: LD_VAR 0 3
90580: LESS
90581: IFFALSE 90599
// r := r * 2 else
90583: LD_ADDR_VAR 0 7
90587: PUSH
90588: LD_VAR 0 7
90592: PUSH
90593: LD_INT 2
90595: MUL
90596: ST_TO_ADDR
90597: GO 90625
// if amount > max then
90599: LD_VAR 0 9
90603: PUSH
90604: LD_VAR 0 4
90608: GREATER
90609: IFFALSE 90625
// r := r / 2 ;
90611: LD_ADDR_VAR 0 7
90615: PUSH
90616: LD_VAR 0 7
90620: PUSH
90621: LD_INT 2
90623: DIVREAL
90624: ST_TO_ADDR
// time := time / r ;
90625: LD_ADDR_VAR 0 8
90629: PUSH
90630: LD_VAR 0 8
90634: PUSH
90635: LD_VAR 0 7
90639: DIVREAL
90640: ST_TO_ADDR
// if time < 0 then
90641: LD_VAR 0 8
90645: PUSH
90646: LD_INT 0
90648: LESS
90649: IFFALSE 90666
// time := time * - 1 ;
90651: LD_ADDR_VAR 0 8
90655: PUSH
90656: LD_VAR 0 8
90660: PUSH
90661: LD_INT 1
90663: NEG
90664: MUL
90665: ST_TO_ADDR
// wait ( time + rand ( 0 0$01 , 0 0$25 ) ) ;
90666: LD_VAR 0 8
90670: PUSH
90671: LD_INT 35
90673: PPUSH
90674: LD_INT 875
90676: PPUSH
90677: CALL_OW 12
90681: PLUS
90682: PPUSH
90683: CALL_OW 67
// CreateCratesArea ( rand ( 1 , 5 ) , area , true ) ;
90687: LD_INT 1
90689: PPUSH
90690: LD_INT 5
90692: PPUSH
90693: CALL_OW 12
90697: PPUSH
90698: LD_VAR 0 1
90702: PPUSH
90703: LD_INT 1
90705: PPUSH
90706: CALL_OW 55
// end ;
90710: GO 90523
// end ;
90712: LD_VAR 0 5
90716: RET
// export function UpgradeTurretsWeapon ( turrets , factories ) ; var i , j , k , nat , weapon , weapons , list ; begin
90717: LD_INT 0
90719: PPUSH
90720: PPUSH
90721: PPUSH
90722: PPUSH
90723: PPUSH
90724: PPUSH
90725: PPUSH
90726: PPUSH
// if not turrets or not factories then
90727: LD_VAR 0 1
90731: NOT
90732: PUSH
90733: LD_VAR 0 2
90737: NOT
90738: OR
90739: IFFALSE 90743
// exit ;
90741: GO 91050
// list := [ [ [ us_double_gun , us_heavy_gun ] , [ us_machine_gun , us_gatling_gun ] , [ us_light_gun , us_double_gun ] ] , [ [ ar_double_machine_gun , ar_gatling_gun ] , [ ar_light_gun , ar_gun ] ] , [ [ ru_heavy_machine_gun , ru_gatling_gun ] , [ ru_gun , ru_heavy_gun ] , [ ru_rocket_launcher , ru_rocket ] ] , ] ;
90743: LD_ADDR_VAR 0 10
90747: PUSH
90748: LD_INT 5
90750: PUSH
90751: LD_INT 6
90753: PUSH
90754: EMPTY
90755: LIST
90756: LIST
90757: PUSH
90758: LD_INT 2
90760: PUSH
90761: LD_INT 4
90763: PUSH
90764: EMPTY
90765: LIST
90766: LIST
90767: PUSH
90768: LD_INT 3
90770: PUSH
90771: LD_INT 5
90773: PUSH
90774: EMPTY
90775: LIST
90776: LIST
90777: PUSH
90778: EMPTY
90779: LIST
90780: LIST
90781: LIST
90782: PUSH
90783: LD_INT 24
90785: PUSH
90786: LD_INT 25
90788: PUSH
90789: EMPTY
90790: LIST
90791: LIST
90792: PUSH
90793: LD_INT 23
90795: PUSH
90796: LD_INT 27
90798: PUSH
90799: EMPTY
90800: LIST
90801: LIST
90802: PUSH
90803: EMPTY
90804: LIST
90805: LIST
90806: PUSH
90807: LD_INT 42
90809: PUSH
90810: LD_INT 43
90812: PUSH
90813: EMPTY
90814: LIST
90815: LIST
90816: PUSH
90817: LD_INT 44
90819: PUSH
90820: LD_INT 46
90822: PUSH
90823: EMPTY
90824: LIST
90825: LIST
90826: PUSH
90827: LD_INT 45
90829: PUSH
90830: LD_INT 47
90832: PUSH
90833: EMPTY
90834: LIST
90835: LIST
90836: PUSH
90837: EMPTY
90838: LIST
90839: LIST
90840: LIST
90841: PUSH
90842: EMPTY
90843: LIST
90844: LIST
90845: LIST
90846: ST_TO_ADDR
// result := [ ] ;
90847: LD_ADDR_VAR 0 3
90851: PUSH
90852: EMPTY
90853: ST_TO_ADDR
// for i in turrets do
90854: LD_ADDR_VAR 0 4
90858: PUSH
90859: LD_VAR 0 1
90863: PUSH
90864: FOR_IN
90865: IFFALSE 91048
// begin nat := GetNation ( i ) ;
90867: LD_ADDR_VAR 0 7
90871: PUSH
90872: LD_VAR 0 4
90876: PPUSH
90877: CALL_OW 248
90881: ST_TO_ADDR
// weapon := 0 ;
90882: LD_ADDR_VAR 0 8
90886: PUSH
90887: LD_INT 0
90889: ST_TO_ADDR
// if not nat then
90890: LD_VAR 0 7
90894: NOT
90895: IFFALSE 90899
// continue ;
90897: GO 90864
// for j in list [ nat ] do
90899: LD_ADDR_VAR 0 5
90903: PUSH
90904: LD_VAR 0 10
90908: PUSH
90909: LD_VAR 0 7
90913: ARRAY
90914: PUSH
90915: FOR_IN
90916: IFFALSE 90957
// if GetBWeapon ( i ) = j [ 1 ] then
90918: LD_VAR 0 4
90922: PPUSH
90923: CALL_OW 269
90927: PUSH
90928: LD_VAR 0 5
90932: PUSH
90933: LD_INT 1
90935: ARRAY
90936: EQUAL
90937: IFFALSE 90955
// begin weapon := j [ 2 ] ;
90939: LD_ADDR_VAR 0 8
90943: PUSH
90944: LD_VAR 0 5
90948: PUSH
90949: LD_INT 2
90951: ARRAY
90952: ST_TO_ADDR
// break ;
90953: GO 90957
// end ;
90955: GO 90915
90957: POP
90958: POP
// if not weapon then
90959: LD_VAR 0 8
90963: NOT
90964: IFFALSE 90968
// continue ;
90966: GO 90864
// for k in factories do
90968: LD_ADDR_VAR 0 6
90972: PUSH
90973: LD_VAR 0 2
90977: PUSH
90978: FOR_IN
90979: IFFALSE 91044
// begin weapons := AvailableWeaponList ( k ) ;
90981: LD_ADDR_VAR 0 9
90985: PUSH
90986: LD_VAR 0 6
90990: PPUSH
90991: CALL_OW 478
90995: ST_TO_ADDR
// if not weapons then
90996: LD_VAR 0 9
91000: NOT
91001: IFFALSE 91005
// continue ;
91003: GO 90978
// if weapon in weapons then
91005: LD_VAR 0 8
91009: PUSH
91010: LD_VAR 0 9
91014: IN
91015: IFFALSE 91042
// begin result := [ i , weapon ] ;
91017: LD_ADDR_VAR 0 3
91021: PUSH
91022: LD_VAR 0 4
91026: PUSH
91027: LD_VAR 0 8
91031: PUSH
91032: EMPTY
91033: LIST
91034: LIST
91035: ST_TO_ADDR
// exit ;
91036: POP
91037: POP
91038: POP
91039: POP
91040: GO 91050
// end ; end ;
91042: GO 90978
91044: POP
91045: POP
// end ;
91046: GO 90864
91048: POP
91049: POP
// end ;
91050: LD_VAR 0 3
91054: RET
// export function RevealMapOnXY ( x , y , side , range ) ; begin
91055: LD_INT 0
91057: PPUSH
// if not side or side > 8 then
91058: LD_VAR 0 3
91062: NOT
91063: PUSH
91064: LD_VAR 0 3
91068: PUSH
91069: LD_INT 8
91071: GREATER
91072: OR
91073: IFFALSE 91077
// exit ;
91075: GO 91136
// if not range then
91077: LD_VAR 0 4
91081: NOT
91082: IFFALSE 91093
// range := - 12 ;
91084: LD_ADDR_VAR 0 4
91088: PUSH
91089: LD_INT 12
91091: NEG
91092: ST_TO_ADDR
// PlaceSeeing ( x , y , side , range ) ;
91093: LD_VAR 0 1
91097: PPUSH
91098: LD_VAR 0 2
91102: PPUSH
91103: LD_VAR 0 3
91107: PPUSH
91108: LD_VAR 0 4
91112: PPUSH
91113: CALL_OW 330
// RemoveSeeing ( x , y , side ) ;
91117: LD_VAR 0 1
91121: PPUSH
91122: LD_VAR 0 2
91126: PPUSH
91127: LD_VAR 0 3
91131: PPUSH
91132: CALL_OW 331
// end ;
91136: LD_VAR 0 5
91140: RET
// export function Video ( mode ) ; begin
91141: LD_INT 0
91143: PPUSH
// ingame_video = mode ;
91144: LD_ADDR_OWVAR 52
91148: PUSH
91149: LD_VAR 0 1
91153: ST_TO_ADDR
// interface_hidden = mode ;
91154: LD_ADDR_OWVAR 54
91158: PUSH
91159: LD_VAR 0 1
91163: ST_TO_ADDR
// end ;
91164: LD_VAR 0 2
91168: RET
// export function Join ( array , element ) ; begin
91169: LD_INT 0
91171: PPUSH
// result := Replace ( array , array + 1 , element ) ;
91172: LD_ADDR_VAR 0 3
91176: PUSH
91177: LD_VAR 0 1
91181: PPUSH
91182: LD_VAR 0 1
91186: PUSH
91187: LD_INT 1
91189: PLUS
91190: PPUSH
91191: LD_VAR 0 2
91195: PPUSH
91196: CALL_OW 1
91200: ST_TO_ADDR
// end ;
91201: LD_VAR 0 3
91205: RET
// export function JoinUnion ( array , element ) ; begin
91206: LD_INT 0
91208: PPUSH
// result := array union element ;
91209: LD_ADDR_VAR 0 3
91213: PUSH
91214: LD_VAR 0 1
91218: PUSH
91219: LD_VAR 0 2
91223: UNION
91224: ST_TO_ADDR
// end ;
91225: LD_VAR 0 3
91229: RET
// export function GetBehemoths ( side ) ; begin
91230: LD_INT 0
91232: PPUSH
// result := FilterAllUnits ( [ [ f_side , side ] , [ f_chassis , ru_behemoth ] ] ) ;
91233: LD_ADDR_VAR 0 2
91237: PUSH
91238: LD_INT 22
91240: PUSH
91241: LD_VAR 0 1
91245: PUSH
91246: EMPTY
91247: LIST
91248: LIST
91249: PUSH
91250: LD_INT 31
91252: PUSH
91253: LD_INT 25
91255: PUSH
91256: EMPTY
91257: LIST
91258: LIST
91259: PUSH
91260: EMPTY
91261: LIST
91262: LIST
91263: PPUSH
91264: CALL_OW 69
91268: ST_TO_ADDR
// end ;
91269: LD_VAR 0 2
91273: RET
// export function Shuffle ( array ) ; var i , index ; begin
91274: LD_INT 0
91276: PPUSH
91277: PPUSH
91278: PPUSH
// result := [ ] ;
91279: LD_ADDR_VAR 0 2
91283: PUSH
91284: EMPTY
91285: ST_TO_ADDR
// if not array then
91286: LD_VAR 0 1
91290: NOT
91291: IFFALSE 91295
// exit ;
91293: GO 91394
// Randomize ;
91295: CALL_OW 10
// for i = array downto 1 do
91299: LD_ADDR_VAR 0 3
91303: PUSH
91304: DOUBLE
91305: LD_VAR 0 1
91309: INC
91310: ST_TO_ADDR
91311: LD_INT 1
91313: PUSH
91314: FOR_DOWNTO
91315: IFFALSE 91392
// begin index := rand ( 1 , array ) ;
91317: LD_ADDR_VAR 0 4
91321: PUSH
91322: LD_INT 1
91324: PPUSH
91325: LD_VAR 0 1
91329: PPUSH
91330: CALL_OW 12
91334: ST_TO_ADDR
// result := Insert ( result , result + 1 , array [ index ] ) ;
91335: LD_ADDR_VAR 0 2
91339: PUSH
91340: LD_VAR 0 2
91344: PPUSH
91345: LD_VAR 0 2
91349: PUSH
91350: LD_INT 1
91352: PLUS
91353: PPUSH
91354: LD_VAR 0 1
91358: PUSH
91359: LD_VAR 0 4
91363: ARRAY
91364: PPUSH
91365: CALL_OW 2
91369: ST_TO_ADDR
// array := Delete ( array , index ) ;
91370: LD_ADDR_VAR 0 1
91374: PUSH
91375: LD_VAR 0 1
91379: PPUSH
91380: LD_VAR 0 4
91384: PPUSH
91385: CALL_OW 3
91389: ST_TO_ADDR
// end ;
91390: GO 91314
91392: POP
91393: POP
// end ;
91394: LD_VAR 0 2
91398: RET
// export function GetBaseMaterials ( base ) ; begin
91399: LD_INT 0
91401: PPUSH
// result := [ 0 , 0 , 0 ] ;
91402: LD_ADDR_VAR 0 2
91406: PUSH
91407: LD_INT 0
91409: PUSH
91410: LD_INT 0
91412: PUSH
91413: LD_INT 0
91415: PUSH
91416: EMPTY
91417: LIST
91418: LIST
91419: LIST
91420: ST_TO_ADDR
// if not base then
91421: LD_VAR 0 1
91425: NOT
91426: IFFALSE 91430
// exit ;
91428: GO 91479
// result := [ GetResourceType ( base , mat_cans ) , GetResourceType ( base , mat_oil ) , GetResourceType ( base , mat_siberit ) ] ;
91430: LD_ADDR_VAR 0 2
91434: PUSH
91435: LD_VAR 0 1
91439: PPUSH
91440: LD_INT 1
91442: PPUSH
91443: CALL_OW 275
91447: PUSH
91448: LD_VAR 0 1
91452: PPUSH
91453: LD_INT 2
91455: PPUSH
91456: CALL_OW 275
91460: PUSH
91461: LD_VAR 0 1
91465: PPUSH
91466: LD_INT 3
91468: PPUSH
91469: CALL_OW 275
91473: PUSH
91474: EMPTY
91475: LIST
91476: LIST
91477: LIST
91478: ST_TO_ADDR
// end ;
91479: LD_VAR 0 2
91483: RET
// export function ShrinkArray ( array , size ) ; var i ; begin
91484: LD_INT 0
91486: PPUSH
91487: PPUSH
// result := array ;
91488: LD_ADDR_VAR 0 3
91492: PUSH
91493: LD_VAR 0 1
91497: ST_TO_ADDR
// if size >= result then
91498: LD_VAR 0 2
91502: PUSH
91503: LD_VAR 0 3
91507: GREATEREQUAL
91508: IFFALSE 91512
// exit ;
91510: GO 91562
// if size then
91512: LD_VAR 0 2
91516: IFFALSE 91562
// for i := array downto size do
91518: LD_ADDR_VAR 0 4
91522: PUSH
91523: DOUBLE
91524: LD_VAR 0 1
91528: INC
91529: ST_TO_ADDR
91530: LD_VAR 0 2
91534: PUSH
91535: FOR_DOWNTO
91536: IFFALSE 91560
// result := Delete ( result , result ) ;
91538: LD_ADDR_VAR 0 3
91542: PUSH
91543: LD_VAR 0 3
91547: PPUSH
91548: LD_VAR 0 3
91552: PPUSH
91553: CALL_OW 3
91557: ST_TO_ADDR
91558: GO 91535
91560: POP
91561: POP
// end ;
91562: LD_VAR 0 3
91566: RET
// export function ComExit ( unit ) ; var tmp ; begin
91567: LD_INT 0
91569: PPUSH
91570: PPUSH
// if not IsInUnit ( unit ) then
91571: LD_VAR 0 1
91575: PPUSH
91576: CALL_OW 310
91580: NOT
91581: IFFALSE 91585
// exit ;
91583: GO 91645
// tmp := IsInUnit ( unit ) ;
91585: LD_ADDR_VAR 0 3
91589: PUSH
91590: LD_VAR 0 1
91594: PPUSH
91595: CALL_OW 310
91599: ST_TO_ADDR
// if GetType ( tmp ) = unit_vehicle then
91600: LD_VAR 0 3
91604: PPUSH
91605: CALL_OW 247
91609: PUSH
91610: LD_INT 2
91612: EQUAL
91613: IFFALSE 91626
// ComExitVehicle ( unit ) else
91615: LD_VAR 0 1
91619: PPUSH
91620: CALL_OW 121
91624: GO 91635
// ComExitBuilding ( unit ) ;
91626: LD_VAR 0 1
91630: PPUSH
91631: CALL_OW 122
// result := tmp ;
91635: LD_ADDR_VAR 0 2
91639: PUSH
91640: LD_VAR 0 3
91644: ST_TO_ADDR
// end ;
91645: LD_VAR 0 2
91649: RET
// export function ComExitAll ( units ) ; var i ; begin
91650: LD_INT 0
91652: PPUSH
91653: PPUSH
// if not units then
91654: LD_VAR 0 1
91658: NOT
91659: IFFALSE 91663
// exit ;
91661: GO 91689
// for i in units do
91663: LD_ADDR_VAR 0 3
91667: PUSH
91668: LD_VAR 0 1
91672: PUSH
91673: FOR_IN
91674: IFFALSE 91687
// ComExit ( i ) ;
91676: LD_VAR 0 3
91680: PPUSH
91681: CALL 91567 0 1
91685: GO 91673
91687: POP
91688: POP
// end ;
91689: LD_VAR 0 2
91693: RET
// export function ResetHc ; begin
91694: LD_INT 0
91696: PPUSH
// InitHc ;
91697: CALL_OW 19
// hc_importance := 0 ;
91701: LD_ADDR_OWVAR 32
91705: PUSH
91706: LD_INT 0
91708: ST_TO_ADDR
// end ;
91709: LD_VAR 0 1
91713: RET
// export function PointBetweenXY ( x1 , y1 , x2 , y2 ) ; var _x , _y ; begin
91714: LD_INT 0
91716: PPUSH
91717: PPUSH
91718: PPUSH
// _x := ( x1 + x2 ) div 2 ;
91719: LD_ADDR_VAR 0 6
91723: PUSH
91724: LD_VAR 0 1
91728: PUSH
91729: LD_VAR 0 3
91733: PLUS
91734: PUSH
91735: LD_INT 2
91737: DIV
91738: ST_TO_ADDR
// if _x < 0 then
91739: LD_VAR 0 6
91743: PUSH
91744: LD_INT 0
91746: LESS
91747: IFFALSE 91764
// _x := _x * - 1 ;
91749: LD_ADDR_VAR 0 6
91753: PUSH
91754: LD_VAR 0 6
91758: PUSH
91759: LD_INT 1
91761: NEG
91762: MUL
91763: ST_TO_ADDR
// _y := ( y1 + y2 ) div 2 ;
91764: LD_ADDR_VAR 0 7
91768: PUSH
91769: LD_VAR 0 2
91773: PUSH
91774: LD_VAR 0 4
91778: PLUS
91779: PUSH
91780: LD_INT 2
91782: DIV
91783: ST_TO_ADDR
// if _y < 0 then
91784: LD_VAR 0 7
91788: PUSH
91789: LD_INT 0
91791: LESS
91792: IFFALSE 91809
// _y := _y * - 1 ;
91794: LD_ADDR_VAR 0 7
91798: PUSH
91799: LD_VAR 0 7
91803: PUSH
91804: LD_INT 1
91806: NEG
91807: MUL
91808: ST_TO_ADDR
// result := [ _x , _y ] ;
91809: LD_ADDR_VAR 0 5
91813: PUSH
91814: LD_VAR 0 6
91818: PUSH
91819: LD_VAR 0 7
91823: PUSH
91824: EMPTY
91825: LIST
91826: LIST
91827: ST_TO_ADDR
// end ;
91828: LD_VAR 0 5
91832: RET
// export function NotGoToAreaUnit ( unit , area , goAway ) ; var x , y , task ; begin
91833: LD_INT 0
91835: PPUSH
91836: PPUSH
91837: PPUSH
91838: PPUSH
// task := GetTaskList ( unit ) ;
91839: LD_ADDR_VAR 0 7
91843: PUSH
91844: LD_VAR 0 1
91848: PPUSH
91849: CALL_OW 437
91853: ST_TO_ADDR
// if not task and not IsInArea ( unit , area ) then
91854: LD_VAR 0 7
91858: NOT
91859: PUSH
91860: LD_VAR 0 1
91864: PPUSH
91865: LD_VAR 0 2
91869: PPUSH
91870: CALL_OW 308
91874: NOT
91875: AND
91876: IFFALSE 91880
// exit ;
91878: GO 91998
// if IsInArea ( unit , area ) then
91880: LD_VAR 0 1
91884: PPUSH
91885: LD_VAR 0 2
91889: PPUSH
91890: CALL_OW 308
91894: IFFALSE 91912
// begin ComMoveToArea ( unit , goAway ) ;
91896: LD_VAR 0 1
91900: PPUSH
91901: LD_VAR 0 3
91905: PPUSH
91906: CALL_OW 113
// exit ;
91910: GO 91998
// end ; if task [ 1 ] [ 1 ] <> M then
91912: LD_VAR 0 7
91916: PUSH
91917: LD_INT 1
91919: ARRAY
91920: PUSH
91921: LD_INT 1
91923: ARRAY
91924: PUSH
91925: LD_STRING M
91927: NONEQUAL
91928: IFFALSE 91932
// exit ;
91930: GO 91998
// x := task [ 1 ] [ 2 ] ;
91932: LD_ADDR_VAR 0 5
91936: PUSH
91937: LD_VAR 0 7
91941: PUSH
91942: LD_INT 1
91944: ARRAY
91945: PUSH
91946: LD_INT 2
91948: ARRAY
91949: ST_TO_ADDR
// y := task [ 1 ] [ 3 ] ;
91950: LD_ADDR_VAR 0 6
91954: PUSH
91955: LD_VAR 0 7
91959: PUSH
91960: LD_INT 1
91962: ARRAY
91963: PUSH
91964: LD_INT 3
91966: ARRAY
91967: ST_TO_ADDR
// if InArea ( x , y , area ) then
91968: LD_VAR 0 5
91972: PPUSH
91973: LD_VAR 0 6
91977: PPUSH
91978: LD_VAR 0 2
91982: PPUSH
91983: CALL_OW 309
91987: IFFALSE 91998
// ComStop ( unit ) ;
91989: LD_VAR 0 1
91993: PPUSH
91994: CALL_OW 141
// end ;
91998: LD_VAR 0 4
92002: RET
// export function Abs ( value ) ; begin
92003: LD_INT 0
92005: PPUSH
// result := value ;
92006: LD_ADDR_VAR 0 2
92010: PUSH
92011: LD_VAR 0 1
92015: ST_TO_ADDR
// if value < 0 then
92016: LD_VAR 0 1
92020: PUSH
92021: LD_INT 0
92023: LESS
92024: IFFALSE 92041
// result := value * - 1 ;
92026: LD_ADDR_VAR 0 2
92030: PUSH
92031: LD_VAR 0 1
92035: PUSH
92036: LD_INT 1
92038: NEG
92039: MUL
92040: ST_TO_ADDR
// end ;
92041: LD_VAR 0 2
92045: RET
// export function ComMoveToNearbyEntrance ( unit , building ) ; var x , _x , y , _y , d , r , i ; begin
92046: LD_INT 0
92048: PPUSH
92049: PPUSH
92050: PPUSH
92051: PPUSH
92052: PPUSH
92053: PPUSH
92054: PPUSH
92055: PPUSH
// if not unit or not building then
92056: LD_VAR 0 1
92060: NOT
92061: PUSH
92062: LD_VAR 0 2
92066: NOT
92067: OR
92068: IFFALSE 92072
// exit ;
92070: GO 92298
// x := GetX ( building ) ;
92072: LD_ADDR_VAR 0 4
92076: PUSH
92077: LD_VAR 0 2
92081: PPUSH
92082: CALL_OW 250
92086: ST_TO_ADDR
// y := GetY ( building ) ;
92087: LD_ADDR_VAR 0 6
92091: PUSH
92092: LD_VAR 0 2
92096: PPUSH
92097: CALL_OW 251
92101: ST_TO_ADDR
// d := GetDir ( building ) ;
92102: LD_ADDR_VAR 0 8
92106: PUSH
92107: LD_VAR 0 2
92111: PPUSH
92112: CALL_OW 254
92116: ST_TO_ADDR
// r := 4 ;
92117: LD_ADDR_VAR 0 9
92121: PUSH
92122: LD_INT 4
92124: ST_TO_ADDR
// for i := 1 to 5 do
92125: LD_ADDR_VAR 0 10
92129: PUSH
92130: DOUBLE
92131: LD_INT 1
92133: DEC
92134: ST_TO_ADDR
92135: LD_INT 5
92137: PUSH
92138: FOR_TO
92139: IFFALSE 92296
// begin _x := ShiftX ( x , d , r + i ) ;
92141: LD_ADDR_VAR 0 5
92145: PUSH
92146: LD_VAR 0 4
92150: PPUSH
92151: LD_VAR 0 8
92155: PPUSH
92156: LD_VAR 0 9
92160: PUSH
92161: LD_VAR 0 10
92165: PLUS
92166: PPUSH
92167: CALL_OW 272
92171: ST_TO_ADDR
// _y := ShiftY ( y , d , r + i ) ;
92172: LD_ADDR_VAR 0 7
92176: PUSH
92177: LD_VAR 0 6
92181: PPUSH
92182: LD_VAR 0 8
92186: PPUSH
92187: LD_VAR 0 9
92191: PUSH
92192: LD_VAR 0 10
92196: PLUS
92197: PPUSH
92198: CALL_OW 273
92202: ST_TO_ADDR
// if ValidHex ( _x , _y ) and not GetType ( HexInfo ( _x , _y ) ) in [ unit_building , unit_vehicle ] then
92203: LD_VAR 0 5
92207: PPUSH
92208: LD_VAR 0 7
92212: PPUSH
92213: CALL_OW 488
92217: PUSH
92218: LD_VAR 0 5
92222: PPUSH
92223: LD_VAR 0 7
92227: PPUSH
92228: CALL_OW 428
92232: PPUSH
92233: CALL_OW 247
92237: PUSH
92238: LD_INT 3
92240: PUSH
92241: LD_INT 2
92243: PUSH
92244: EMPTY
92245: LIST
92246: LIST
92247: IN
92248: NOT
92249: AND
92250: IFFALSE 92294
// begin ComMoveXY ( unit , _x , _y ) ;
92252: LD_VAR 0 1
92256: PPUSH
92257: LD_VAR 0 5
92261: PPUSH
92262: LD_VAR 0 7
92266: PPUSH
92267: CALL_OW 111
// result := [ _x , _y ] ;
92271: LD_ADDR_VAR 0 3
92275: PUSH
92276: LD_VAR 0 5
92280: PUSH
92281: LD_VAR 0 7
92285: PUSH
92286: EMPTY
92287: LIST
92288: LIST
92289: ST_TO_ADDR
// exit ;
92290: POP
92291: POP
92292: GO 92298
// end ; end ;
92294: GO 92138
92296: POP
92297: POP
// end ;
92298: LD_VAR 0 3
92302: RET
// export function SideAttackedSide ( side1 , side2 ) ; var i , un ; begin
92303: LD_INT 0
92305: PPUSH
92306: PPUSH
92307: PPUSH
// result := 0 ;
92308: LD_ADDR_VAR 0 3
92312: PUSH
92313: LD_INT 0
92315: ST_TO_ADDR
// if side1 < 0 or side1 > 8 or side2 < 0 or side2 > 8 then
92316: LD_VAR 0 1
92320: PUSH
92321: LD_INT 0
92323: LESS
92324: PUSH
92325: LD_VAR 0 1
92329: PUSH
92330: LD_INT 8
92332: GREATER
92333: OR
92334: PUSH
92335: LD_VAR 0 2
92339: PUSH
92340: LD_INT 0
92342: LESS
92343: OR
92344: PUSH
92345: LD_VAR 0 2
92349: PUSH
92350: LD_INT 8
92352: GREATER
92353: OR
92354: IFFALSE 92358
// exit ;
92356: GO 92433
// for i in FilterAllUnits ( [ f_side , side2 ] ) do
92358: LD_ADDR_VAR 0 4
92362: PUSH
92363: LD_INT 22
92365: PUSH
92366: LD_VAR 0 2
92370: PUSH
92371: EMPTY
92372: LIST
92373: LIST
92374: PPUSH
92375: CALL_OW 69
92379: PUSH
92380: FOR_IN
92381: IFFALSE 92431
// begin un := UnitShoot ( i ) ;
92383: LD_ADDR_VAR 0 5
92387: PUSH
92388: LD_VAR 0 4
92392: PPUSH
92393: CALL_OW 504
92397: ST_TO_ADDR
// if GetSide ( un ) = side1 then
92398: LD_VAR 0 5
92402: PPUSH
92403: CALL_OW 255
92407: PUSH
92408: LD_VAR 0 1
92412: EQUAL
92413: IFFALSE 92429
// begin result := un ;
92415: LD_ADDR_VAR 0 3
92419: PUSH
92420: LD_VAR 0 5
92424: ST_TO_ADDR
// exit ;
92425: POP
92426: POP
92427: GO 92433
// end ; end ;
92429: GO 92380
92431: POP
92432: POP
// end ;
92433: LD_VAR 0 3
92437: RET
// export function GetCargoBay ( units ) ; begin
92438: LD_INT 0
92440: PPUSH
// result := UnitFilter ( units , [ f_or , [ f_weapon , us_cargo_bay ] , [ f_weapon , ru_cargo_bay ] , [ f_weapon , ar_cargo_bay ] , [ f_weapon , ru_big_cargo_bay ] ] ) ;
92441: LD_ADDR_VAR 0 2
92445: PUSH
92446: LD_VAR 0 1
92450: PPUSH
92451: LD_INT 2
92453: PUSH
92454: LD_INT 34
92456: PUSH
92457: LD_INT 12
92459: PUSH
92460: EMPTY
92461: LIST
92462: LIST
92463: PUSH
92464: LD_INT 34
92466: PUSH
92467: LD_INT 51
92469: PUSH
92470: EMPTY
92471: LIST
92472: LIST
92473: PUSH
92474: LD_INT 34
92476: PUSH
92477: LD_INT 32
92479: PUSH
92480: EMPTY
92481: LIST
92482: LIST
92483: PUSH
92484: LD_INT 34
92486: PUSH
92487: LD_INT 89
92489: PUSH
92490: EMPTY
92491: LIST
92492: LIST
92493: PUSH
92494: EMPTY
92495: LIST
92496: LIST
92497: LIST
92498: LIST
92499: LIST
92500: PPUSH
92501: CALL_OW 72
92505: ST_TO_ADDR
// end ;
92506: LD_VAR 0 2
92510: RET
// export function Negate ( value ) ; begin
92511: LD_INT 0
92513: PPUSH
// result := not value ;
92514: LD_ADDR_VAR 0 2
92518: PUSH
92519: LD_VAR 0 1
92523: NOT
92524: ST_TO_ADDR
// end ;
92525: LD_VAR 0 2
92529: RET
// export function Inc ( value ) ; begin
92530: LD_INT 0
92532: PPUSH
// result := value + 1 ;
92533: LD_ADDR_VAR 0 2
92537: PUSH
92538: LD_VAR 0 1
92542: PUSH
92543: LD_INT 1
92545: PLUS
92546: ST_TO_ADDR
// end ;
92547: LD_VAR 0 2
92551: RET
// export function Dec ( value ) ; begin
92552: LD_INT 0
92554: PPUSH
// result := value - 1 ;
92555: LD_ADDR_VAR 0 2
92559: PUSH
92560: LD_VAR 0 1
92564: PUSH
92565: LD_INT 1
92567: MINUS
92568: ST_TO_ADDR
// end ;
92569: LD_VAR 0 2
92573: RET
// export function GetDirFromHex ( x1 , y1 , x2 , y2 ) ; var i , _x , _y , tmp , distance , centerDist , centerPoint ; begin
92574: LD_INT 0
92576: PPUSH
92577: PPUSH
92578: PPUSH
92579: PPUSH
92580: PPUSH
92581: PPUSH
92582: PPUSH
92583: PPUSH
// if not ValidHex ( x1 , y1 ) or not ValidHex ( x2 , y2 ) then
92584: LD_VAR 0 1
92588: PPUSH
92589: LD_VAR 0 2
92593: PPUSH
92594: CALL_OW 488
92598: NOT
92599: PUSH
92600: LD_VAR 0 3
92604: PPUSH
92605: LD_VAR 0 4
92609: PPUSH
92610: CALL_OW 488
92614: NOT
92615: OR
92616: IFFALSE 92629
// begin result := - 1 ;
92618: LD_ADDR_VAR 0 5
92622: PUSH
92623: LD_INT 1
92625: NEG
92626: ST_TO_ADDR
// exit ;
92627: GO 92864
// end ; centerPoint := PointBetweenXY ( x1 , y1 , x2 , y2 ) ;
92629: LD_ADDR_VAR 0 12
92633: PUSH
92634: LD_VAR 0 1
92638: PPUSH
92639: LD_VAR 0 2
92643: PPUSH
92644: LD_VAR 0 3
92648: PPUSH
92649: LD_VAR 0 4
92653: PPUSH
92654: CALL 91714 0 4
92658: ST_TO_ADDR
// centerDist := GetDistXY ( x1 , y1 , centerPoint [ 1 ] , centerPoint [ 2 ] ) ;
92659: LD_ADDR_VAR 0 11
92663: PUSH
92664: LD_VAR 0 1
92668: PPUSH
92669: LD_VAR 0 2
92673: PPUSH
92674: LD_VAR 0 12
92678: PUSH
92679: LD_INT 1
92681: ARRAY
92682: PPUSH
92683: LD_VAR 0 12
92687: PUSH
92688: LD_INT 2
92690: ARRAY
92691: PPUSH
92692: CALL_OW 298
92696: ST_TO_ADDR
// distance := 9999 ;
92697: LD_ADDR_VAR 0 10
92701: PUSH
92702: LD_INT 9999
92704: ST_TO_ADDR
// for i := 0 to 5 do
92705: LD_ADDR_VAR 0 6
92709: PUSH
92710: DOUBLE
92711: LD_INT 0
92713: DEC
92714: ST_TO_ADDR
92715: LD_INT 5
92717: PUSH
92718: FOR_TO
92719: IFFALSE 92862
// begin _x := ShiftX ( x1 , i , centerDist ) ;
92721: LD_ADDR_VAR 0 7
92725: PUSH
92726: LD_VAR 0 1
92730: PPUSH
92731: LD_VAR 0 6
92735: PPUSH
92736: LD_VAR 0 11
92740: PPUSH
92741: CALL_OW 272
92745: ST_TO_ADDR
// _y := ShiftY ( y1 , i , centerDist ) ;
92746: LD_ADDR_VAR 0 8
92750: PUSH
92751: LD_VAR 0 2
92755: PPUSH
92756: LD_VAR 0 6
92760: PPUSH
92761: LD_VAR 0 11
92765: PPUSH
92766: CALL_OW 273
92770: ST_TO_ADDR
// if not ValidHex ( _x , _y ) then
92771: LD_VAR 0 7
92775: PPUSH
92776: LD_VAR 0 8
92780: PPUSH
92781: CALL_OW 488
92785: NOT
92786: IFFALSE 92790
// continue ;
92788: GO 92718
// tmp := GetDistXY ( centerPoint [ 1 ] , centerPoint [ 2 ] , _x , _y ) ;
92790: LD_ADDR_VAR 0 9
92794: PUSH
92795: LD_VAR 0 12
92799: PUSH
92800: LD_INT 1
92802: ARRAY
92803: PPUSH
92804: LD_VAR 0 12
92808: PUSH
92809: LD_INT 2
92811: ARRAY
92812: PPUSH
92813: LD_VAR 0 7
92817: PPUSH
92818: LD_VAR 0 8
92822: PPUSH
92823: CALL_OW 298
92827: ST_TO_ADDR
// if tmp < distance then
92828: LD_VAR 0 9
92832: PUSH
92833: LD_VAR 0 10
92837: LESS
92838: IFFALSE 92860
// begin result := i ;
92840: LD_ADDR_VAR 0 5
92844: PUSH
92845: LD_VAR 0 6
92849: ST_TO_ADDR
// distance := tmp ;
92850: LD_ADDR_VAR 0 10
92854: PUSH
92855: LD_VAR 0 9
92859: ST_TO_ADDR
// end ; end ;
92860: GO 92718
92862: POP
92863: POP
// end ;
92864: LD_VAR 0 5
92868: RET
// export function ComRepairVehicleAndReturn ( driver ) ; var vehicle ; begin
92869: LD_INT 0
92871: PPUSH
92872: PPUSH
// if not driver or not IsInUnit ( driver ) then
92873: LD_VAR 0 1
92877: NOT
92878: PUSH
92879: LD_VAR 0 1
92883: PPUSH
92884: CALL_OW 310
92888: NOT
92889: OR
92890: IFFALSE 92894
// exit ;
92892: GO 92984
// vehicle := IsInUnit ( driver ) ;
92894: LD_ADDR_VAR 0 3
92898: PUSH
92899: LD_VAR 0 1
92903: PPUSH
92904: CALL_OW 310
92908: ST_TO_ADDR
// SetTaskList ( driver , [ [ \ , 0 , 0 , 0 , 0 , 0 , 0 ] , [ E , 0 , 0 , vehicle , 0 , 0 , 0 ] ] ) ;
92909: LD_VAR 0 1
92913: PPUSH
92914: LD_STRING \
92916: PUSH
92917: LD_INT 0
92919: PUSH
92920: LD_INT 0
92922: PUSH
92923: LD_INT 0
92925: PUSH
92926: LD_INT 0
92928: PUSH
92929: LD_INT 0
92931: PUSH
92932: LD_INT 0
92934: PUSH
92935: EMPTY
92936: LIST
92937: LIST
92938: LIST
92939: LIST
92940: LIST
92941: LIST
92942: LIST
92943: PUSH
92944: LD_STRING E
92946: PUSH
92947: LD_INT 0
92949: PUSH
92950: LD_INT 0
92952: PUSH
92953: LD_VAR 0 3
92957: PUSH
92958: LD_INT 0
92960: PUSH
92961: LD_INT 0
92963: PUSH
92964: LD_INT 0
92966: PUSH
92967: EMPTY
92968: LIST
92969: LIST
92970: LIST
92971: LIST
92972: LIST
92973: LIST
92974: LIST
92975: PUSH
92976: EMPTY
92977: LIST
92978: LIST
92979: PPUSH
92980: CALL_OW 446
// end ;
92984: LD_VAR 0 2
92988: RET
// export function AddComRepairVehicleAndReturn ( driver ) ; var vehicle ; begin
92989: LD_INT 0
92991: PPUSH
92992: PPUSH
// if not driver or not IsInUnit ( driver ) then
92993: LD_VAR 0 1
92997: NOT
92998: PUSH
92999: LD_VAR 0 1
93003: PPUSH
93004: CALL_OW 310
93008: NOT
93009: OR
93010: IFFALSE 93014
// exit ;
93012: GO 93104
// vehicle := IsInUnit ( driver ) ;
93014: LD_ADDR_VAR 0 3
93018: PUSH
93019: LD_VAR 0 1
93023: PPUSH
93024: CALL_OW 310
93028: ST_TO_ADDR
// AddTaskList ( driver , [ [ \ , 0 , 0 , 0 , 0 , 0 , 0 ] , [ E , 0 , 0 , vehicle , 0 , 0 , 0 ] ] ) ;
93029: LD_VAR 0 1
93033: PPUSH
93034: LD_STRING \
93036: PUSH
93037: LD_INT 0
93039: PUSH
93040: LD_INT 0
93042: PUSH
93043: LD_INT 0
93045: PUSH
93046: LD_INT 0
93048: PUSH
93049: LD_INT 0
93051: PUSH
93052: LD_INT 0
93054: PUSH
93055: EMPTY
93056: LIST
93057: LIST
93058: LIST
93059: LIST
93060: LIST
93061: LIST
93062: LIST
93063: PUSH
93064: LD_STRING E
93066: PUSH
93067: LD_INT 0
93069: PUSH
93070: LD_INT 0
93072: PUSH
93073: LD_VAR 0 3
93077: PUSH
93078: LD_INT 0
93080: PUSH
93081: LD_INT 0
93083: PUSH
93084: LD_INT 0
93086: PUSH
93087: EMPTY
93088: LIST
93089: LIST
93090: LIST
93091: LIST
93092: LIST
93093: LIST
93094: LIST
93095: PUSH
93096: EMPTY
93097: LIST
93098: LIST
93099: PPUSH
93100: CALL_OW 447
// end ;
93104: LD_VAR 0 2
93108: RET
// export function SortByHealth ( units , asc ) ; var i , tmp ; begin
93109: LD_INT 0
93111: PPUSH
93112: PPUSH
93113: PPUSH
// tmp := [ ] ;
93114: LD_ADDR_VAR 0 5
93118: PUSH
93119: EMPTY
93120: ST_TO_ADDR
// for i in units do
93121: LD_ADDR_VAR 0 4
93125: PUSH
93126: LD_VAR 0 1
93130: PUSH
93131: FOR_IN
93132: IFFALSE 93170
// tmp := Insert ( tmp , tmp + 1 , GetLives ( i ) ) ;
93134: LD_ADDR_VAR 0 5
93138: PUSH
93139: LD_VAR 0 5
93143: PPUSH
93144: LD_VAR 0 5
93148: PUSH
93149: LD_INT 1
93151: PLUS
93152: PPUSH
93153: LD_VAR 0 4
93157: PPUSH
93158: CALL_OW 256
93162: PPUSH
93163: CALL_OW 2
93167: ST_TO_ADDR
93168: GO 93131
93170: POP
93171: POP
// if not tmp then
93172: LD_VAR 0 5
93176: NOT
93177: IFFALSE 93181
// exit ;
93179: GO 93229
// if asc then
93181: LD_VAR 0 2
93185: IFFALSE 93209
// result := SortListByListAsc ( units , tmp ) else
93187: LD_ADDR_VAR 0 3
93191: PUSH
93192: LD_VAR 0 1
93196: PPUSH
93197: LD_VAR 0 5
93201: PPUSH
93202: CALL_OW 76
93206: ST_TO_ADDR
93207: GO 93229
// result := SortListByListDesc ( units , tmp ) ;
93209: LD_ADDR_VAR 0 3
93213: PUSH
93214: LD_VAR 0 1
93218: PPUSH
93219: LD_VAR 0 5
93223: PPUSH
93224: CALL_OW 77
93228: ST_TO_ADDR
// end ;
93229: LD_VAR 0 3
93233: RET
// export function WantToRepairVehicle ( mech , vehicle ) ; var task ; begin
93234: LD_INT 0
93236: PPUSH
93237: PPUSH
// task := GetTaskList ( mech ) ;
93238: LD_ADDR_VAR 0 4
93242: PUSH
93243: LD_VAR 0 1
93247: PPUSH
93248: CALL_OW 437
93252: ST_TO_ADDR
// if not task then
93253: LD_VAR 0 4
93257: NOT
93258: IFFALSE 93262
// exit ;
93260: GO 93304
// result := task [ 1 ] [ 1 ] = r and task [ 1 ] [ 4 ] = vehicle ;
93262: LD_ADDR_VAR 0 3
93266: PUSH
93267: LD_VAR 0 4
93271: PUSH
93272: LD_INT 1
93274: ARRAY
93275: PUSH
93276: LD_INT 1
93278: ARRAY
93279: PUSH
93280: LD_STRING r
93282: EQUAL
93283: PUSH
93284: LD_VAR 0 4
93288: PUSH
93289: LD_INT 1
93291: ARRAY
93292: PUSH
93293: LD_INT 4
93295: ARRAY
93296: PUSH
93297: LD_VAR 0 2
93301: EQUAL
93302: AND
93303: ST_TO_ADDR
// end ;
93304: LD_VAR 0 3
93308: RET
// export function PlaceUnitXYD ( unit , x , y , d , mode ) ; begin
93309: LD_INT 0
93311: PPUSH
// SetDir ( unit , d ) ;
93312: LD_VAR 0 1
93316: PPUSH
93317: LD_VAR 0 4
93321: PPUSH
93322: CALL_OW 233
// PlaceUnitXY ( unit , x , y , mode ) ;
93326: LD_VAR 0 1
93330: PPUSH
93331: LD_VAR 0 2
93335: PPUSH
93336: LD_VAR 0 3
93340: PPUSH
93341: LD_VAR 0 5
93345: PPUSH
93346: CALL_OW 48
// end ;
93350: LD_VAR 0 6
93354: RET
// export function ToNaturalNumber ( number ) ; begin
93355: LD_INT 0
93357: PPUSH
// result := number div 1 ;
93358: LD_ADDR_VAR 0 2
93362: PUSH
93363: LD_VAR 0 1
93367: PUSH
93368: LD_INT 1
93370: DIV
93371: ST_TO_ADDR
// if number < 0 then
93372: LD_VAR 0 1
93376: PUSH
93377: LD_INT 0
93379: LESS
93380: IFFALSE 93390
// result := 0 ;
93382: LD_ADDR_VAR 0 2
93386: PUSH
93387: LD_INT 0
93389: ST_TO_ADDR
// end ;
93390: LD_VAR 0 2
93394: RET
// export function SortByClass ( units , class ) ; var un ; begin
93395: LD_INT 0
93397: PPUSH
93398: PPUSH
// if not units or not class then
93399: LD_VAR 0 1
93403: NOT
93404: PUSH
93405: LD_VAR 0 2
93409: NOT
93410: OR
93411: IFFALSE 93415
// exit ;
93413: GO 93510
// result := [ ] ;
93415: LD_ADDR_VAR 0 3
93419: PUSH
93420: EMPTY
93421: ST_TO_ADDR
// for un in units do
93422: LD_ADDR_VAR 0 4
93426: PUSH
93427: LD_VAR 0 1
93431: PUSH
93432: FOR_IN
93433: IFFALSE 93508
// if GetClass ( un ) = class then
93435: LD_VAR 0 4
93439: PPUSH
93440: CALL_OW 257
93444: PUSH
93445: LD_VAR 0 2
93449: EQUAL
93450: IFFALSE 93477
// result := Insert ( result , 1 , un ) else
93452: LD_ADDR_VAR 0 3
93456: PUSH
93457: LD_VAR 0 3
93461: PPUSH
93462: LD_INT 1
93464: PPUSH
93465: LD_VAR 0 4
93469: PPUSH
93470: CALL_OW 2
93474: ST_TO_ADDR
93475: GO 93506
// result := Replace ( result , result + 1 , un ) ;
93477: LD_ADDR_VAR 0 3
93481: PUSH
93482: LD_VAR 0 3
93486: PPUSH
93487: LD_VAR 0 3
93491: PUSH
93492: LD_INT 1
93494: PLUS
93495: PPUSH
93496: LD_VAR 0 4
93500: PPUSH
93501: CALL_OW 1
93505: ST_TO_ADDR
93506: GO 93432
93508: POP
93509: POP
// end ;
93510: LD_VAR 0 3
93514: RET
// export function GetCratesNearbyXY ( x , y , r ) ; var _x , _y , min_y , min_x , max_x , max_y ; begin
93515: LD_INT 0
93517: PPUSH
93518: PPUSH
93519: PPUSH
93520: PPUSH
93521: PPUSH
93522: PPUSH
93523: PPUSH
// result := [ ] ;
93524: LD_ADDR_VAR 0 4
93528: PUSH
93529: EMPTY
93530: ST_TO_ADDR
// if x - r < 0 then
93531: LD_VAR 0 1
93535: PUSH
93536: LD_VAR 0 3
93540: MINUS
93541: PUSH
93542: LD_INT 0
93544: LESS
93545: IFFALSE 93557
// min_x := 0 else
93547: LD_ADDR_VAR 0 8
93551: PUSH
93552: LD_INT 0
93554: ST_TO_ADDR
93555: GO 93573
// min_x := x - r ;
93557: LD_ADDR_VAR 0 8
93561: PUSH
93562: LD_VAR 0 1
93566: PUSH
93567: LD_VAR 0 3
93571: MINUS
93572: ST_TO_ADDR
// if y - r < 0 then
93573: LD_VAR 0 2
93577: PUSH
93578: LD_VAR 0 3
93582: MINUS
93583: PUSH
93584: LD_INT 0
93586: LESS
93587: IFFALSE 93599
// min_y := 0 else
93589: LD_ADDR_VAR 0 7
93593: PUSH
93594: LD_INT 0
93596: ST_TO_ADDR
93597: GO 93615
// min_y := y - r ;
93599: LD_ADDR_VAR 0 7
93603: PUSH
93604: LD_VAR 0 2
93608: PUSH
93609: LD_VAR 0 3
93613: MINUS
93614: ST_TO_ADDR
// max_x := x + r ;
93615: LD_ADDR_VAR 0 9
93619: PUSH
93620: LD_VAR 0 1
93624: PUSH
93625: LD_VAR 0 3
93629: PLUS
93630: ST_TO_ADDR
// max_y := y + r ;
93631: LD_ADDR_VAR 0 10
93635: PUSH
93636: LD_VAR 0 2
93640: PUSH
93641: LD_VAR 0 3
93645: PLUS
93646: ST_TO_ADDR
// for _x = min_x to max_x do
93647: LD_ADDR_VAR 0 5
93651: PUSH
93652: DOUBLE
93653: LD_VAR 0 8
93657: DEC
93658: ST_TO_ADDR
93659: LD_VAR 0 9
93663: PUSH
93664: FOR_TO
93665: IFFALSE 93766
// for _y = min_y to max_y do
93667: LD_ADDR_VAR 0 6
93671: PUSH
93672: DOUBLE
93673: LD_VAR 0 7
93677: DEC
93678: ST_TO_ADDR
93679: LD_VAR 0 10
93683: PUSH
93684: FOR_TO
93685: IFFALSE 93762
// begin if not ValidHex ( _x , _y ) then
93687: LD_VAR 0 5
93691: PPUSH
93692: LD_VAR 0 6
93696: PPUSH
93697: CALL_OW 488
93701: NOT
93702: IFFALSE 93706
// continue ;
93704: GO 93684
// if GetResourceTypeXY ( _x , _y ) then
93706: LD_VAR 0 5
93710: PPUSH
93711: LD_VAR 0 6
93715: PPUSH
93716: CALL_OW 283
93720: IFFALSE 93760
// result := Replace ( result , result + 1 , [ _x , _y ] ) ;
93722: LD_ADDR_VAR 0 4
93726: PUSH
93727: LD_VAR 0 4
93731: PPUSH
93732: LD_VAR 0 4
93736: PUSH
93737: LD_INT 1
93739: PLUS
93740: PPUSH
93741: LD_VAR 0 5
93745: PUSH
93746: LD_VAR 0 6
93750: PUSH
93751: EMPTY
93752: LIST
93753: LIST
93754: PPUSH
93755: CALL_OW 1
93759: ST_TO_ADDR
// end ;
93760: GO 93684
93762: POP
93763: POP
93764: GO 93664
93766: POP
93767: POP
// end ;
93768: LD_VAR 0 4
93772: RET
// export function AgressiveMove ( units , path ) ; var i , enemy , nearEnemy , cr , side , tag , ignoreCratesWeapon ; begin
93773: LD_INT 0
93775: PPUSH
93776: PPUSH
93777: PPUSH
93778: PPUSH
93779: PPUSH
93780: PPUSH
93781: PPUSH
93782: PPUSH
// if not units then
93783: LD_VAR 0 1
93787: NOT
93788: IFFALSE 93792
// exit ;
93790: GO 94316
// result := UnitFilter ( units , [ f_ok ] ) ;
93792: LD_ADDR_VAR 0 3
93796: PUSH
93797: LD_VAR 0 1
93801: PPUSH
93802: LD_INT 50
93804: PUSH
93805: EMPTY
93806: LIST
93807: PPUSH
93808: CALL_OW 72
93812: ST_TO_ADDR
// side := GetSide ( units [ 1 ] ) ;
93813: LD_ADDR_VAR 0 8
93817: PUSH
93818: LD_VAR 0 1
93822: PUSH
93823: LD_INT 1
93825: ARRAY
93826: PPUSH
93827: CALL_OW 255
93831: ST_TO_ADDR
// ignoreCratesWeapon := [ ar_selfpropelled_bomb , ar_bio_bomb , ru_time_lapser ] ;
93832: LD_ADDR_VAR 0 10
93836: PUSH
93837: LD_INT 29
93839: PUSH
93840: LD_INT 91
93842: PUSH
93843: LD_INT 49
93845: PUSH
93846: EMPTY
93847: LIST
93848: LIST
93849: LIST
93850: ST_TO_ADDR
// if not result then
93851: LD_VAR 0 3
93855: NOT
93856: IFFALSE 93860
// exit ;
93858: GO 94316
// enemy := FilterAllUnits ( [ f_enemy , side ] ) ;
93860: LD_ADDR_VAR 0 5
93864: PUSH
93865: LD_INT 81
93867: PUSH
93868: LD_VAR 0 8
93872: PUSH
93873: EMPTY
93874: LIST
93875: LIST
93876: PPUSH
93877: CALL_OW 69
93881: ST_TO_ADDR
// for i in result do
93882: LD_ADDR_VAR 0 4
93886: PUSH
93887: LD_VAR 0 3
93891: PUSH
93892: FOR_IN
93893: IFFALSE 94314
// begin tag := GetTag ( i ) + 1 ;
93895: LD_ADDR_VAR 0 9
93899: PUSH
93900: LD_VAR 0 4
93904: PPUSH
93905: CALL_OW 110
93909: PUSH
93910: LD_INT 1
93912: PLUS
93913: ST_TO_ADDR
// cr := GetCratesNearbyXY ( GetX ( i ) , GetY ( i ) , 6 ) ;
93914: LD_ADDR_VAR 0 7
93918: PUSH
93919: LD_VAR 0 4
93923: PPUSH
93924: CALL_OW 250
93928: PPUSH
93929: LD_VAR 0 4
93933: PPUSH
93934: CALL_OW 251
93938: PPUSH
93939: LD_INT 6
93941: PPUSH
93942: CALL 93515 0 3
93946: ST_TO_ADDR
// if GetType ( i ) = unit_vehicle and cr and not GetWeapon ( i ) in ignoreCratesWeapon then
93947: LD_VAR 0 4
93951: PPUSH
93952: CALL_OW 247
93956: PUSH
93957: LD_INT 2
93959: EQUAL
93960: PUSH
93961: LD_VAR 0 7
93965: AND
93966: PUSH
93967: LD_VAR 0 4
93971: PPUSH
93972: CALL_OW 264
93976: PUSH
93977: LD_VAR 0 10
93981: IN
93982: NOT
93983: AND
93984: IFFALSE 94023
// ComAttackPlace ( i , cr [ 1 ] [ 1 ] , cr [ 1 ] [ 2 ] ) else
93986: LD_VAR 0 4
93990: PPUSH
93991: LD_VAR 0 7
93995: PUSH
93996: LD_INT 1
93998: ARRAY
93999: PUSH
94000: LD_INT 1
94002: ARRAY
94003: PPUSH
94004: LD_VAR 0 7
94008: PUSH
94009: LD_INT 1
94011: ARRAY
94012: PUSH
94013: LD_INT 2
94015: ARRAY
94016: PPUSH
94017: CALL_OW 116
94021: GO 94312
// if path > tag then
94023: LD_VAR 0 2
94027: PUSH
94028: LD_VAR 0 9
94032: GREATER
94033: IFFALSE 94241
// begin nearEnemy := UnitFilter ( enemy , [ f_dist , i , 8 ] ) ;
94035: LD_ADDR_VAR 0 6
94039: PUSH
94040: LD_VAR 0 5
94044: PPUSH
94045: LD_INT 91
94047: PUSH
94048: LD_VAR 0 4
94052: PUSH
94053: LD_INT 8
94055: PUSH
94056: EMPTY
94057: LIST
94058: LIST
94059: LIST
94060: PPUSH
94061: CALL_OW 72
94065: ST_TO_ADDR
// if nearEnemy then
94066: LD_VAR 0 6
94070: IFFALSE 94139
// begin if GetWeapon ( i ) = ru_time_lapser then
94072: LD_VAR 0 4
94076: PPUSH
94077: CALL_OW 264
94081: PUSH
94082: LD_INT 49
94084: EQUAL
94085: IFFALSE 94113
// ComMoveUnit ( i , NearestUnitToUnit ( nearEnemy , i ) ) else
94087: LD_VAR 0 4
94091: PPUSH
94092: LD_VAR 0 6
94096: PPUSH
94097: LD_VAR 0 4
94101: PPUSH
94102: CALL_OW 74
94106: PPUSH
94107: CALL_OW 112
94111: GO 94137
// ComAgressiveMoveToUnit ( i , NearestUnitToUnit ( nearEnemy , i ) ) ;
94113: LD_VAR 0 4
94117: PPUSH
94118: LD_VAR 0 6
94122: PPUSH
94123: LD_VAR 0 4
94127: PPUSH
94128: CALL_OW 74
94132: PPUSH
94133: CALL 95387 0 2
// end else
94137: GO 94239
// if GetDistUnitXY ( i , path [ tag ] [ 1 ] , path [ tag ] [ 2 ] ) > 6 then
94139: LD_VAR 0 4
94143: PPUSH
94144: LD_VAR 0 2
94148: PUSH
94149: LD_VAR 0 9
94153: ARRAY
94154: PUSH
94155: LD_INT 1
94157: ARRAY
94158: PPUSH
94159: LD_VAR 0 2
94163: PUSH
94164: LD_VAR 0 9
94168: ARRAY
94169: PUSH
94170: LD_INT 2
94172: ARRAY
94173: PPUSH
94174: CALL_OW 297
94178: PUSH
94179: LD_INT 6
94181: GREATER
94182: IFFALSE 94225
// ComAgressiveMove ( i , path [ tag ] [ 1 ] , path [ tag ] [ 2 ] ) else
94184: LD_VAR 0 4
94188: PPUSH
94189: LD_VAR 0 2
94193: PUSH
94194: LD_VAR 0 9
94198: ARRAY
94199: PUSH
94200: LD_INT 1
94202: ARRAY
94203: PPUSH
94204: LD_VAR 0 2
94208: PUSH
94209: LD_VAR 0 9
94213: ARRAY
94214: PUSH
94215: LD_INT 2
94217: ARRAY
94218: PPUSH
94219: CALL_OW 114
94223: GO 94239
// SetTag ( i , tag ) ;
94225: LD_VAR 0 4
94229: PPUSH
94230: LD_VAR 0 9
94234: PPUSH
94235: CALL_OW 109
// end else
94239: GO 94312
// if enemy then
94241: LD_VAR 0 5
94245: IFFALSE 94312
// begin if GetWeapon ( i ) = ru_time_lapser then
94247: LD_VAR 0 4
94251: PPUSH
94252: CALL_OW 264
94256: PUSH
94257: LD_INT 49
94259: EQUAL
94260: IFFALSE 94288
// ComMoveUnit ( i , NearestUnitToUnit ( enemy , i ) ) else
94262: LD_VAR 0 4
94266: PPUSH
94267: LD_VAR 0 5
94271: PPUSH
94272: LD_VAR 0 4
94276: PPUSH
94277: CALL_OW 74
94281: PPUSH
94282: CALL_OW 112
94286: GO 94312
// ComAgressiveMoveToUnit ( i , NearestUnitToUnit ( enemy , i ) ) ;
94288: LD_VAR 0 4
94292: PPUSH
94293: LD_VAR 0 5
94297: PPUSH
94298: LD_VAR 0 4
94302: PPUSH
94303: CALL_OW 74
94307: PPUSH
94308: CALL 95387 0 2
// end ; end ;
94312: GO 93892
94314: POP
94315: POP
// end ;
94316: LD_VAR 0 3
94320: RET
// export function ComLookAtDir ( unit , direction ) ; var x , y ; begin
94321: LD_INT 0
94323: PPUSH
94324: PPUSH
94325: PPUSH
// if not unit or IsInUnit ( unit ) then
94326: LD_VAR 0 1
94330: NOT
94331: PUSH
94332: LD_VAR 0 1
94336: PPUSH
94337: CALL_OW 310
94341: OR
94342: IFFALSE 94346
// exit ;
94344: GO 94437
// x := ShiftX ( GetX ( unit ) , direction , 1 ) ;
94346: LD_ADDR_VAR 0 4
94350: PUSH
94351: LD_VAR 0 1
94355: PPUSH
94356: CALL_OW 250
94360: PPUSH
94361: LD_VAR 0 2
94365: PPUSH
94366: LD_INT 1
94368: PPUSH
94369: CALL_OW 272
94373: ST_TO_ADDR
// y := ShiftY ( GetY ( unit ) , direction , 1 ) ;
94374: LD_ADDR_VAR 0 5
94378: PUSH
94379: LD_VAR 0 1
94383: PPUSH
94384: CALL_OW 251
94388: PPUSH
94389: LD_VAR 0 2
94393: PPUSH
94394: LD_INT 1
94396: PPUSH
94397: CALL_OW 273
94401: ST_TO_ADDR
// if ValidHex ( x , y ) then
94402: LD_VAR 0 4
94406: PPUSH
94407: LD_VAR 0 5
94411: PPUSH
94412: CALL_OW 488
94416: IFFALSE 94437
// ComTurnXY ( unit , x , y ) ;
94418: LD_VAR 0 1
94422: PPUSH
94423: LD_VAR 0 4
94427: PPUSH
94428: LD_VAR 0 5
94432: PPUSH
94433: CALL_OW 118
// end ;
94437: LD_VAR 0 3
94441: RET
// export function SeeUnits ( side , units ) ; var i ; begin
94442: LD_INT 0
94444: PPUSH
94445: PPUSH
// result := false ;
94446: LD_ADDR_VAR 0 3
94450: PUSH
94451: LD_INT 0
94453: ST_TO_ADDR
// if not units then
94454: LD_VAR 0 2
94458: NOT
94459: IFFALSE 94463
// exit ;
94461: GO 94508
// for i in units do
94463: LD_ADDR_VAR 0 4
94467: PUSH
94468: LD_VAR 0 2
94472: PUSH
94473: FOR_IN
94474: IFFALSE 94506
// if See ( side , i ) then
94476: LD_VAR 0 1
94480: PPUSH
94481: LD_VAR 0 4
94485: PPUSH
94486: CALL_OW 292
94490: IFFALSE 94504
// begin result := true ;
94492: LD_ADDR_VAR 0 3
94496: PUSH
94497: LD_INT 1
94499: ST_TO_ADDR
// exit ;
94500: POP
94501: POP
94502: GO 94508
// end ;
94504: GO 94473
94506: POP
94507: POP
// end ;
94508: LD_VAR 0 3
94512: RET
// export function GetNearestPoint ( unit , points ) ; var i , dist , tmpDist ; begin
94513: LD_INT 0
94515: PPUSH
94516: PPUSH
94517: PPUSH
94518: PPUSH
// if not unit or not points then
94519: LD_VAR 0 1
94523: NOT
94524: PUSH
94525: LD_VAR 0 2
94529: NOT
94530: OR
94531: IFFALSE 94535
// exit ;
94533: GO 94625
// dist := 99999 ;
94535: LD_ADDR_VAR 0 5
94539: PUSH
94540: LD_INT 99999
94542: ST_TO_ADDR
// for i in points do
94543: LD_ADDR_VAR 0 4
94547: PUSH
94548: LD_VAR 0 2
94552: PUSH
94553: FOR_IN
94554: IFFALSE 94623
// begin tmpDist := GetDistUnitXY ( unit , i [ 1 ] , i [ 2 ] ) ;
94556: LD_ADDR_VAR 0 6
94560: PUSH
94561: LD_VAR 0 1
94565: PPUSH
94566: LD_VAR 0 4
94570: PUSH
94571: LD_INT 1
94573: ARRAY
94574: PPUSH
94575: LD_VAR 0 4
94579: PUSH
94580: LD_INT 2
94582: ARRAY
94583: PPUSH
94584: CALL_OW 297
94588: ST_TO_ADDR
// if tmpDist < dist then
94589: LD_VAR 0 6
94593: PUSH
94594: LD_VAR 0 5
94598: LESS
94599: IFFALSE 94621
// begin result := i ;
94601: LD_ADDR_VAR 0 3
94605: PUSH
94606: LD_VAR 0 4
94610: ST_TO_ADDR
// dist := tmpDist ;
94611: LD_ADDR_VAR 0 5
94615: PUSH
94616: LD_VAR 0 6
94620: ST_TO_ADDR
// end ; end ;
94621: GO 94553
94623: POP
94624: POP
// end ;
94625: LD_VAR 0 3
94629: RET
// export function CreateBehemoth ( side , x , y , d ) ; begin
94630: LD_INT 0
94632: PPUSH
// uc_side := side ;
94633: LD_ADDR_OWVAR 20
94637: PUSH
94638: LD_VAR 0 1
94642: ST_TO_ADDR
// uc_nation := 3 ;
94643: LD_ADDR_OWVAR 21
94647: PUSH
94648: LD_INT 3
94650: ST_TO_ADDR
// vc_chassis := 25 ;
94651: LD_ADDR_OWVAR 37
94655: PUSH
94656: LD_INT 25
94658: ST_TO_ADDR
// vc_engine := engine_siberite ;
94659: LD_ADDR_OWVAR 39
94663: PUSH
94664: LD_INT 3
94666: ST_TO_ADDR
// vc_control := control_computer ;
94667: LD_ADDR_OWVAR 38
94671: PUSH
94672: LD_INT 3
94674: ST_TO_ADDR
// vc_weapon := 59 ;
94675: LD_ADDR_OWVAR 40
94679: PUSH
94680: LD_INT 59
94682: ST_TO_ADDR
// result := CreateVehicle ;
94683: LD_ADDR_VAR 0 5
94687: PUSH
94688: CALL_OW 45
94692: ST_TO_ADDR
// SetDir ( result , d ) ;
94693: LD_VAR 0 5
94697: PPUSH
94698: LD_VAR 0 4
94702: PPUSH
94703: CALL_OW 233
// PlaceUnitXY ( result , x , y , false ) ;
94707: LD_VAR 0 5
94711: PPUSH
94712: LD_VAR 0 2
94716: PPUSH
94717: LD_VAR 0 3
94721: PPUSH
94722: LD_INT 0
94724: PPUSH
94725: CALL_OW 48
// end ;
94729: LD_VAR 0 5
94733: RET
// export function GetMultiCargo ( cargo ) ; var i , tmp ; begin
94734: LD_INT 0
94736: PPUSH
94737: PPUSH
94738: PPUSH
// result := [ 0 , 0 , 0 , 0 ] ;
94739: LD_ADDR_VAR 0 2
94743: PUSH
94744: LD_INT 0
94746: PUSH
94747: LD_INT 0
94749: PUSH
94750: LD_INT 0
94752: PUSH
94753: LD_INT 0
94755: PUSH
94756: EMPTY
94757: LIST
94758: LIST
94759: LIST
94760: LIST
94761: ST_TO_ADDR
// if not cargo or not GetWeapon ( cargo ) in [ us_cargo_bay , ru_cargo_bay , ar_cargo_bay , ru_big_cargo_bay ] then
94762: LD_VAR 0 1
94766: NOT
94767: PUSH
94768: LD_VAR 0 1
94772: PPUSH
94773: CALL_OW 264
94777: PUSH
94778: LD_INT 12
94780: PUSH
94781: LD_INT 51
94783: PUSH
94784: LD_INT 32
94786: PUSH
94787: LD_INT 89
94789: PUSH
94790: EMPTY
94791: LIST
94792: LIST
94793: LIST
94794: LIST
94795: IN
94796: NOT
94797: OR
94798: IFFALSE 94802
// exit ;
94800: GO 94900
// for i := 1 to 3 do
94802: LD_ADDR_VAR 0 3
94806: PUSH
94807: DOUBLE
94808: LD_INT 1
94810: DEC
94811: ST_TO_ADDR
94812: LD_INT 3
94814: PUSH
94815: FOR_TO
94816: IFFALSE 94898
// begin tmp := GetCargo ( cargo , i ) ;
94818: LD_ADDR_VAR 0 4
94822: PUSH
94823: LD_VAR 0 1
94827: PPUSH
94828: LD_VAR 0 3
94832: PPUSH
94833: CALL_OW 289
94837: ST_TO_ADDR
// result := Replace ( result , i , tmp ) ;
94838: LD_ADDR_VAR 0 2
94842: PUSH
94843: LD_VAR 0 2
94847: PPUSH
94848: LD_VAR 0 3
94852: PPUSH
94853: LD_VAR 0 4
94857: PPUSH
94858: CALL_OW 1
94862: ST_TO_ADDR
// result := Replace ( result , 4 , result [ 4 ] + tmp ) ;
94863: LD_ADDR_VAR 0 2
94867: PUSH
94868: LD_VAR 0 2
94872: PPUSH
94873: LD_INT 4
94875: PPUSH
94876: LD_VAR 0 2
94880: PUSH
94881: LD_INT 4
94883: ARRAY
94884: PUSH
94885: LD_VAR 0 4
94889: PLUS
94890: PPUSH
94891: CALL_OW 1
94895: ST_TO_ADDR
// end ;
94896: GO 94815
94898: POP
94899: POP
// end ;
94900: LD_VAR 0 2
94904: RET
// export function Length ( array ) ; begin
94905: LD_INT 0
94907: PPUSH
// result := array + 0 ;
94908: LD_ADDR_VAR 0 2
94912: PUSH
94913: LD_VAR 0 1
94917: PUSH
94918: LD_INT 0
94920: PLUS
94921: ST_TO_ADDR
// end ;
94922: LD_VAR 0 2
94926: RET
// export function PrepareArray ( array ) ; begin
94927: LD_INT 0
94929: PPUSH
// result := array diff 0 ;
94930: LD_ADDR_VAR 0 2
94934: PUSH
94935: LD_VAR 0 1
94939: PUSH
94940: LD_INT 0
94942: DIFF
94943: ST_TO_ADDR
// if not result [ 1 ] then
94944: LD_VAR 0 2
94948: PUSH
94949: LD_INT 1
94951: ARRAY
94952: NOT
94953: IFFALSE 94973
// result := Delete ( result , 1 ) ;
94955: LD_ADDR_VAR 0 2
94959: PUSH
94960: LD_VAR 0 2
94964: PPUSH
94965: LD_INT 1
94967: PPUSH
94968: CALL_OW 3
94972: ST_TO_ADDR
// end ;
94973: LD_VAR 0 2
94977: RET
// export function IsInSibRocketRange ( x , y , area ) ; var i , sibRocketRange , tmp ; begin
94978: LD_INT 0
94980: PPUSH
94981: PPUSH
94982: PPUSH
94983: PPUSH
// sibRocketRange := 25 ;
94984: LD_ADDR_VAR 0 6
94988: PUSH
94989: LD_INT 25
94991: ST_TO_ADDR
// result := false ;
94992: LD_ADDR_VAR 0 4
94996: PUSH
94997: LD_INT 0
94999: ST_TO_ADDR
// for i := 0 to 5 do
95000: LD_ADDR_VAR 0 5
95004: PUSH
95005: DOUBLE
95006: LD_INT 0
95008: DEC
95009: ST_TO_ADDR
95010: LD_INT 5
95012: PUSH
95013: FOR_TO
95014: IFFALSE 95081
// if InArea ( ShiftX ( x , i , sibRocketRange ) , ShiftY ( y , i , sibRocketRange ) , area ) then
95016: LD_VAR 0 1
95020: PPUSH
95021: LD_VAR 0 5
95025: PPUSH
95026: LD_VAR 0 6
95030: PPUSH
95031: CALL_OW 272
95035: PPUSH
95036: LD_VAR 0 2
95040: PPUSH
95041: LD_VAR 0 5
95045: PPUSH
95046: LD_VAR 0 6
95050: PPUSH
95051: CALL_OW 273
95055: PPUSH
95056: LD_VAR 0 3
95060: PPUSH
95061: CALL_OW 309
95065: IFFALSE 95079
// begin result := true ;
95067: LD_ADDR_VAR 0 4
95071: PUSH
95072: LD_INT 1
95074: ST_TO_ADDR
// exit ;
95075: POP
95076: POP
95077: GO 95083
// end ;
95079: GO 95013
95081: POP
95082: POP
// end ;
95083: LD_VAR 0 4
95087: RET
// export function CanBeBuiltOnlyResources ( depot , btype ) ; var pom , cost ; begin
95088: LD_INT 0
95090: PPUSH
95091: PPUSH
95092: PPUSH
// if btype = b_depot then
95093: LD_VAR 0 2
95097: PUSH
95098: LD_INT 0
95100: EQUAL
95101: IFFALSE 95113
// begin result := true ;
95103: LD_ADDR_VAR 0 3
95107: PUSH
95108: LD_INT 1
95110: ST_TO_ADDR
// exit ;
95111: GO 95229
// end ; pom := GetBase ( depot ) ;
95113: LD_ADDR_VAR 0 4
95117: PUSH
95118: LD_VAR 0 1
95122: PPUSH
95123: CALL_OW 274
95127: ST_TO_ADDR
// cost := CostOfBuilding ( btype , GetNation ( depot ) ) ;
95128: LD_ADDR_VAR 0 5
95132: PUSH
95133: LD_VAR 0 2
95137: PPUSH
95138: LD_VAR 0 1
95142: PPUSH
95143: CALL_OW 248
95147: PPUSH
95148: CALL_OW 450
95152: ST_TO_ADDR
// result := ( GetResourceType ( pom , mat_cans ) >= cost [ 1 ] and GetResourceType ( pom , mat_oil ) >= cost [ 2 ] and GetResourceType ( pom , mat_siberit ) >= cost [ 3 ] ) ;
95153: LD_ADDR_VAR 0 3
95157: PUSH
95158: LD_VAR 0 4
95162: PPUSH
95163: LD_INT 1
95165: PPUSH
95166: CALL_OW 275
95170: PUSH
95171: LD_VAR 0 5
95175: PUSH
95176: LD_INT 1
95178: ARRAY
95179: GREATEREQUAL
95180: PUSH
95181: LD_VAR 0 4
95185: PPUSH
95186: LD_INT 2
95188: PPUSH
95189: CALL_OW 275
95193: PUSH
95194: LD_VAR 0 5
95198: PUSH
95199: LD_INT 2
95201: ARRAY
95202: GREATEREQUAL
95203: AND
95204: PUSH
95205: LD_VAR 0 4
95209: PPUSH
95210: LD_INT 3
95212: PPUSH
95213: CALL_OW 275
95217: PUSH
95218: LD_VAR 0 5
95222: PUSH
95223: LD_INT 3
95225: ARRAY
95226: GREATEREQUAL
95227: AND
95228: ST_TO_ADDR
// end ;
95229: LD_VAR 0 3
95233: RET
// export function SayRadioNoFaceNoName ( unit , dialog ) ; begin
95234: LD_INT 0
95236: PPUSH
// SayEX ( unit , dialog , false , false , true , false ) ;
95237: LD_VAR 0 1
95241: PPUSH
95242: LD_VAR 0 2
95246: PPUSH
95247: LD_INT 0
95249: PPUSH
95250: LD_INT 0
95252: PPUSH
95253: LD_INT 1
95255: PPUSH
95256: LD_INT 0
95258: PPUSH
95259: CALL_OW 587
// end ;
95263: LD_VAR 0 3
95267: RET
// export function CenterOnNow ( unit ) ; begin
95268: LD_INT 0
95270: PPUSH
// result := IsInUnit ( unit ) ;
95271: LD_ADDR_VAR 0 2
95275: PUSH
95276: LD_VAR 0 1
95280: PPUSH
95281: CALL_OW 310
95285: ST_TO_ADDR
// if not result then
95286: LD_VAR 0 2
95290: NOT
95291: IFFALSE 95303
// result := unit ;
95293: LD_ADDR_VAR 0 2
95297: PUSH
95298: LD_VAR 0 1
95302: ST_TO_ADDR
// CenterNowOnUnits ( unit ) ;
95303: LD_VAR 0 1
95307: PPUSH
95308: CALL_OW 87
// end ;
95312: LD_VAR 0 2
95316: RET
// export function ComMoveHex ( unit , hex ) ; begin
95317: LD_INT 0
95319: PPUSH
// if not hex then
95320: LD_VAR 0 2
95324: NOT
95325: IFFALSE 95329
// exit ;
95327: GO 95382
// if HexInfo ( hex [ 1 ] , hex [ 2 ] ) then
95329: LD_VAR 0 2
95333: PUSH
95334: LD_INT 1
95336: ARRAY
95337: PPUSH
95338: LD_VAR 0 2
95342: PUSH
95343: LD_INT 2
95345: ARRAY
95346: PPUSH
95347: CALL_OW 428
95351: IFFALSE 95355
// exit ;
95353: GO 95382
// ComMoveXY ( unit , hex [ 1 ] , hex [ 2 ] ) ;
95355: LD_VAR 0 1
95359: PPUSH
95360: LD_VAR 0 2
95364: PUSH
95365: LD_INT 1
95367: ARRAY
95368: PPUSH
95369: LD_VAR 0 2
95373: PUSH
95374: LD_INT 2
95376: ARRAY
95377: PPUSH
95378: CALL_OW 111
// end ;
95382: LD_VAR 0 3
95386: RET
// export function ComAgressiveMoveToUnit ( unit , enemy ) ; var x , y ; begin
95387: LD_INT 0
95389: PPUSH
95390: PPUSH
95391: PPUSH
// if not unit or not enemy then
95392: LD_VAR 0 1
95396: NOT
95397: PUSH
95398: LD_VAR 0 2
95402: NOT
95403: OR
95404: IFFALSE 95408
// exit ;
95406: GO 95532
// x := GetX ( enemy ) ;
95408: LD_ADDR_VAR 0 4
95412: PUSH
95413: LD_VAR 0 2
95417: PPUSH
95418: CALL_OW 250
95422: ST_TO_ADDR
// y := GetY ( enemy ) ;
95423: LD_ADDR_VAR 0 5
95427: PUSH
95428: LD_VAR 0 2
95432: PPUSH
95433: CALL_OW 251
95437: ST_TO_ADDR
// if ValidHex ( x , y ) then
95438: LD_VAR 0 4
95442: PPUSH
95443: LD_VAR 0 5
95447: PPUSH
95448: CALL_OW 488
95452: IFFALSE 95532
// if GetType ( enemy ) in [ unit_building , unit_vehicle ] or See ( GetSide ( unit ) , enemy ) then
95454: LD_VAR 0 2
95458: PPUSH
95459: CALL_OW 247
95463: PUSH
95464: LD_INT 3
95466: PUSH
95467: LD_INT 2
95469: PUSH
95470: EMPTY
95471: LIST
95472: LIST
95473: IN
95474: PUSH
95475: LD_VAR 0 1
95479: PPUSH
95480: CALL_OW 255
95484: PPUSH
95485: LD_VAR 0 2
95489: PPUSH
95490: CALL_OW 292
95494: OR
95495: IFFALSE 95513
// ComAttackUnit ( unit , enemy ) else
95497: LD_VAR 0 1
95501: PPUSH
95502: LD_VAR 0 2
95506: PPUSH
95507: CALL_OW 115
95511: GO 95532
// ComAgressiveMove ( unit , x , y ) ;
95513: LD_VAR 0 1
95517: PPUSH
95518: LD_VAR 0 4
95522: PPUSH
95523: LD_VAR 0 5
95527: PPUSH
95528: CALL_OW 114
// end ;
95532: LD_VAR 0 3
95536: RET
// export function GetSourcesFromArea ( area , all ) ; var i , list ; begin
95537: LD_INT 0
95539: PPUSH
95540: PPUSH
95541: PPUSH
// list := AreaToList ( area , 0 ) ;
95542: LD_ADDR_VAR 0 5
95546: PUSH
95547: LD_VAR 0 1
95551: PPUSH
95552: LD_INT 0
95554: PPUSH
95555: CALL_OW 517
95559: ST_TO_ADDR
// if not list then
95560: LD_VAR 0 5
95564: NOT
95565: IFFALSE 95569
// exit ;
95567: GO 95699
// if all then
95569: LD_VAR 0 2
95573: IFFALSE 95661
// begin for i := 1 to list [ 1 ] do
95575: LD_ADDR_VAR 0 4
95579: PUSH
95580: DOUBLE
95581: LD_INT 1
95583: DEC
95584: ST_TO_ADDR
95585: LD_VAR 0 5
95589: PUSH
95590: LD_INT 1
95592: ARRAY
95593: PUSH
95594: FOR_TO
95595: IFFALSE 95657
// result := Replace ( result , result + 1 , [ list [ 1 ] [ i ] , list [ 2 ] [ i ] ] ) ;
95597: LD_ADDR_VAR 0 3
95601: PUSH
95602: LD_VAR 0 3
95606: PPUSH
95607: LD_VAR 0 3
95611: PUSH
95612: LD_INT 1
95614: PLUS
95615: PPUSH
95616: LD_VAR 0 5
95620: PUSH
95621: LD_INT 1
95623: ARRAY
95624: PUSH
95625: LD_VAR 0 4
95629: ARRAY
95630: PUSH
95631: LD_VAR 0 5
95635: PUSH
95636: LD_INT 2
95638: ARRAY
95639: PUSH
95640: LD_VAR 0 4
95644: ARRAY
95645: PUSH
95646: EMPTY
95647: LIST
95648: LIST
95649: PPUSH
95650: CALL_OW 1
95654: ST_TO_ADDR
95655: GO 95594
95657: POP
95658: POP
// exit ;
95659: GO 95699
// end ; result := [ [ list [ 1 ] [ 1 ] , list [ 2 ] [ 1 ] ] ] ;
95661: LD_ADDR_VAR 0 3
95665: PUSH
95666: LD_VAR 0 5
95670: PUSH
95671: LD_INT 1
95673: ARRAY
95674: PUSH
95675: LD_INT 1
95677: ARRAY
95678: PUSH
95679: LD_VAR 0 5
95683: PUSH
95684: LD_INT 2
95686: ARRAY
95687: PUSH
95688: LD_INT 1
95690: ARRAY
95691: PUSH
95692: EMPTY
95693: LIST
95694: LIST
95695: PUSH
95696: EMPTY
95697: LIST
95698: ST_TO_ADDR
// end ;
95699: LD_VAR 0 3
95703: RET
// export function GetBuildingFromArea ( area , direction ) ; var list ; begin
95704: LD_INT 0
95706: PPUSH
95707: PPUSH
// list := AreaToList ( area , 0 ) ;
95708: LD_ADDR_VAR 0 4
95712: PUSH
95713: LD_VAR 0 1
95717: PPUSH
95718: LD_INT 0
95720: PPUSH
95721: CALL_OW 517
95725: ST_TO_ADDR
// if not list then
95726: LD_VAR 0 4
95730: NOT
95731: IFFALSE 95735
// exit ;
95733: GO 95776
// result := [ list [ 1 ] [ 1 ] , list [ 2 ] [ 1 ] , direction ] ;
95735: LD_ADDR_VAR 0 3
95739: PUSH
95740: LD_VAR 0 4
95744: PUSH
95745: LD_INT 1
95747: ARRAY
95748: PUSH
95749: LD_INT 1
95751: ARRAY
95752: PUSH
95753: LD_VAR 0 4
95757: PUSH
95758: LD_INT 2
95760: ARRAY
95761: PUSH
95762: LD_INT 1
95764: ARRAY
95765: PUSH
95766: LD_VAR 0 2
95770: PUSH
95771: EMPTY
95772: LIST
95773: LIST
95774: LIST
95775: ST_TO_ADDR
// end ;
95776: LD_VAR 0 3
95780: RET
// export function First ( array ) ; begin
95781: LD_INT 0
95783: PPUSH
// if not array then
95784: LD_VAR 0 1
95788: NOT
95789: IFFALSE 95793
// exit ;
95791: GO 95807
// result := array [ 1 ] ;
95793: LD_ADDR_VAR 0 2
95797: PUSH
95798: LD_VAR 0 1
95802: PUSH
95803: LD_INT 1
95805: ARRAY
95806: ST_TO_ADDR
// end ;
95807: LD_VAR 0 2
95811: RET
// export function Last ( array ) ; begin
95812: LD_INT 0
95814: PPUSH
// if not array then
95815: LD_VAR 0 1
95819: NOT
95820: IFFALSE 95824
// exit ;
95822: GO 95840
// result := array [ array ] ;
95824: LD_ADDR_VAR 0 2
95828: PUSH
95829: LD_VAR 0 1
95833: PUSH
95834: LD_VAR 0 1
95838: ARRAY
95839: ST_TO_ADDR
// end ;
95840: LD_VAR 0 2
95844: RET
// export function CheckByIndex ( array , index , value , indexColumn ) ; var i ; begin
95845: LD_INT 0
95847: PPUSH
95848: PPUSH
// result := [ ] ;
95849: LD_ADDR_VAR 0 5
95853: PUSH
95854: EMPTY
95855: ST_TO_ADDR
// if not array then
95856: LD_VAR 0 1
95860: NOT
95861: IFFALSE 95865
// exit ;
95863: GO 95977
// for i := 1 to array do
95865: LD_ADDR_VAR 0 6
95869: PUSH
95870: DOUBLE
95871: LD_INT 1
95873: DEC
95874: ST_TO_ADDR
95875: LD_VAR 0 1
95879: PUSH
95880: FOR_TO
95881: IFFALSE 95975
// if array [ i ] [ index ] = value then
95883: LD_VAR 0 1
95887: PUSH
95888: LD_VAR 0 6
95892: ARRAY
95893: PUSH
95894: LD_VAR 0 2
95898: ARRAY
95899: PUSH
95900: LD_VAR 0 3
95904: EQUAL
95905: IFFALSE 95973
// begin if indexColumn then
95907: LD_VAR 0 4
95911: IFFALSE 95947
// result := Join ( result , array [ i ] [ indexColumn ] ) else
95913: LD_ADDR_VAR 0 5
95917: PUSH
95918: LD_VAR 0 5
95922: PPUSH
95923: LD_VAR 0 1
95927: PUSH
95928: LD_VAR 0 6
95932: ARRAY
95933: PUSH
95934: LD_VAR 0 4
95938: ARRAY
95939: PPUSH
95940: CALL 91169 0 2
95944: ST_TO_ADDR
95945: GO 95973
// result := Join ( result , array [ i ] ) ;
95947: LD_ADDR_VAR 0 5
95951: PUSH
95952: LD_VAR 0 5
95956: PPUSH
95957: LD_VAR 0 1
95961: PUSH
95962: LD_VAR 0 6
95966: ARRAY
95967: PPUSH
95968: CALL 91169 0 2
95972: ST_TO_ADDR
// end ;
95973: GO 95880
95975: POP
95976: POP
// end ;
95977: LD_VAR 0 5
95981: RET
// export function ComBackOnParking ( vehicles , parkingPoint ) ; begin
95982: LD_INT 0
95984: PPUSH
// if not vehicles or not parkingPoint then
95985: LD_VAR 0 1
95989: NOT
95990: PUSH
95991: LD_VAR 0 2
95995: NOT
95996: OR
95997: IFFALSE 96001
// exit ;
95999: GO 96099
// vehicles := UnitFilter ( vehicles , [ [ f_ok ] , [ f_not , [ f_distxy , parkingPoint [ 1 ] , parkingPoint [ 2 ] , 8 ] ] ] ) ;
96001: LD_ADDR_VAR 0 1
96005: PUSH
96006: LD_VAR 0 1
96010: PPUSH
96011: LD_INT 50
96013: PUSH
96014: EMPTY
96015: LIST
96016: PUSH
96017: LD_INT 3
96019: PUSH
96020: LD_INT 92
96022: PUSH
96023: LD_VAR 0 2
96027: PUSH
96028: LD_INT 1
96030: ARRAY
96031: PUSH
96032: LD_VAR 0 2
96036: PUSH
96037: LD_INT 2
96039: ARRAY
96040: PUSH
96041: LD_INT 8
96043: PUSH
96044: EMPTY
96045: LIST
96046: LIST
96047: LIST
96048: LIST
96049: PUSH
96050: EMPTY
96051: LIST
96052: LIST
96053: PUSH
96054: EMPTY
96055: LIST
96056: LIST
96057: PPUSH
96058: CALL_OW 72
96062: ST_TO_ADDR
// if not vehicles then
96063: LD_VAR 0 1
96067: NOT
96068: IFFALSE 96072
// exit ;
96070: GO 96099
// ComMoveXY ( vehicles , parkingPoint [ 1 ] , parkingPoint [ 2 ] ) ;
96072: LD_VAR 0 1
96076: PPUSH
96077: LD_VAR 0 2
96081: PUSH
96082: LD_INT 1
96084: ARRAY
96085: PPUSH
96086: LD_VAR 0 2
96090: PUSH
96091: LD_INT 2
96093: ARRAY
96094: PPUSH
96095: CALL_OW 111
// end ;
96099: LD_VAR 0 3
96103: RET
// export function PlaceHiddenCamerasInArea ( side , area ) ; var i , tmp ; begin
96104: LD_INT 0
96106: PPUSH
96107: PPUSH
96108: PPUSH
// if not side or not area then
96109: LD_VAR 0 1
96113: NOT
96114: PUSH
96115: LD_VAR 0 2
96119: NOT
96120: OR
96121: IFFALSE 96125
// exit ;
96123: GO 96244
// tmp := AreaToList ( area , 0 ) ;
96125: LD_ADDR_VAR 0 5
96129: PUSH
96130: LD_VAR 0 2
96134: PPUSH
96135: LD_INT 0
96137: PPUSH
96138: CALL_OW 517
96142: ST_TO_ADDR
// for i := 1 to tmp [ 1 ] do
96143: LD_ADDR_VAR 0 4
96147: PUSH
96148: DOUBLE
96149: LD_INT 1
96151: DEC
96152: ST_TO_ADDR
96153: LD_VAR 0 5
96157: PUSH
96158: LD_INT 1
96160: ARRAY
96161: PUSH
96162: FOR_TO
96163: IFFALSE 96242
// begin if IsEnvironment ( tmp [ 1 ] [ i ] , tmp [ 2 ] [ i ] ) then
96165: LD_VAR 0 5
96169: PUSH
96170: LD_INT 1
96172: ARRAY
96173: PUSH
96174: LD_VAR 0 4
96178: ARRAY
96179: PPUSH
96180: LD_VAR 0 5
96184: PUSH
96185: LD_INT 2
96187: ARRAY
96188: PUSH
96189: LD_VAR 0 4
96193: ARRAY
96194: PPUSH
96195: CALL_OW 351
96199: IFFALSE 96240
// HiddenCamera ( tmp [ 1 ] [ i ] , tmp [ 2 ] [ i ] , side ) ;
96201: LD_VAR 0 5
96205: PUSH
96206: LD_INT 1
96208: ARRAY
96209: PUSH
96210: LD_VAR 0 4
96214: ARRAY
96215: PPUSH
96216: LD_VAR 0 5
96220: PUSH
96221: LD_INT 2
96223: ARRAY
96224: PUSH
96225: LD_VAR 0 4
96229: ARRAY
96230: PPUSH
96231: LD_VAR 0 1
96235: PPUSH
96236: CALL_OW 244
// end ;
96240: GO 96162
96242: POP
96243: POP
// end ; end_of_file end_of_file
96244: LD_VAR 0 3
96248: RET
// export globalGameSaveCounter ; every 0 0$1 do
96249: GO 96251
96251: DISABLE
// begin enable ;
96252: ENABLE
// ToLua ( updateTimer( & tick & ); ) ;
96253: LD_STRING updateTimer(
96255: PUSH
96256: LD_OWVAR 1
96260: STR
96261: PUSH
96262: LD_STRING );
96264: STR
96265: PPUSH
96266: CALL_OW 559
// end ;
96270: END
// every 0 0$1 do
96271: GO 96273
96273: DISABLE
// begin globalGameSaveCounter := 0 ;
96274: LD_ADDR_EXP 125
96278: PUSH
96279: LD_INT 0
96281: ST_TO_ADDR
// ToLua ( setGameSaveCounter(0) ) ;
96282: LD_STRING setGameSaveCounter(0)
96284: PPUSH
96285: CALL_OW 559
// ToLua ( initStreamRollete(); ) ;
96289: LD_STRING initStreamRollete();
96291: PPUSH
96292: CALL_OW 559
// InitStreamMode ;
96296: CALL 97639 0 0
// DefineStreamItems ( false ) ;
96300: LD_INT 0
96302: PPUSH
96303: CALL 98103 0 1
// end ;
96307: END
// export function SOS_MapStart ( ) ; begin
96308: LD_INT 0
96310: PPUSH
// if streamModeActive then
96311: LD_EXP 126
96315: IFFALSE 96324
// DefineStreamItems ( true ) ;
96317: LD_INT 1
96319: PPUSH
96320: CALL 98103 0 1
// UpdateLuaVariables ( ) ;
96324: CALL 96341 0 0
// UpdateFactoryWaypoints ( ) ;
96328: CALL 110972 0 0
// UpdateWarehouseGatheringPoints ( ) ;
96332: CALL 111229 0 0
// end ;
96336: LD_VAR 0 1
96340: RET
// function UpdateLuaVariables ( ) ; begin
96341: LD_INT 0
96343: PPUSH
// if globalGameSaveCounter then
96344: LD_EXP 125
96348: IFFALSE 96382
// begin globalGameSaveCounter := Inc ( globalGameSaveCounter ) ;
96350: LD_ADDR_EXP 125
96354: PUSH
96355: LD_EXP 125
96359: PPUSH
96360: CALL 92530 0 1
96364: ST_TO_ADDR
// ToLua ( setGameSaveCounter( & globalGameSaveCounter & ) ) ;
96365: LD_STRING setGameSaveCounter(
96367: PUSH
96368: LD_EXP 125
96372: STR
96373: PUSH
96374: LD_STRING )
96376: STR
96377: PPUSH
96378: CALL_OW 559
// end ; ToLua ( setGameDifficulty( & Difficulty & ) ) ;
96382: LD_STRING setGameDifficulty(
96384: PUSH
96385: LD_OWVAR 67
96389: STR
96390: PUSH
96391: LD_STRING )
96393: STR
96394: PPUSH
96395: CALL_OW 559
// ToLua ( displayDifficulty( & Difficulty & ) ) ;
96399: LD_STRING displayDifficulty(
96401: PUSH
96402: LD_OWVAR 67
96406: STR
96407: PUSH
96408: LD_STRING )
96410: STR
96411: PPUSH
96412: CALL_OW 559
// end ;
96416: LD_VAR 0 1
96420: RET
// export function SOS_CustomCommand ( p1 , p2 , p3 , p4 , p5 , p6 ) ; begin
96421: LD_INT 0
96423: PPUSH
// if p2 = stream_mode then
96424: LD_VAR 0 2
96428: PUSH
96429: LD_INT 100
96431: EQUAL
96432: IFFALSE 97435
// begin if not StreamModeActive then
96434: LD_EXP 126
96438: NOT
96439: IFFALSE 96449
// StreamModeActive := true ;
96441: LD_ADDR_EXP 126
96445: PUSH
96446: LD_INT 1
96448: ST_TO_ADDR
// if p3 = 0 then
96449: LD_VAR 0 3
96453: PUSH
96454: LD_INT 0
96456: EQUAL
96457: IFFALSE 96463
// InitStreamMode ;
96459: CALL 97639 0 0
// if p3 = 1 then
96463: LD_VAR 0 3
96467: PUSH
96468: LD_INT 1
96470: EQUAL
96471: IFFALSE 96481
// sRocket := true ;
96473: LD_ADDR_EXP 131
96477: PUSH
96478: LD_INT 1
96480: ST_TO_ADDR
// if p3 = 2 then
96481: LD_VAR 0 3
96485: PUSH
96486: LD_INT 2
96488: EQUAL
96489: IFFALSE 96499
// sSpeed := true ;
96491: LD_ADDR_EXP 130
96495: PUSH
96496: LD_INT 1
96498: ST_TO_ADDR
// if p3 = 3 then
96499: LD_VAR 0 3
96503: PUSH
96504: LD_INT 3
96506: EQUAL
96507: IFFALSE 96517
// sEngine := true ;
96509: LD_ADDR_EXP 132
96513: PUSH
96514: LD_INT 1
96516: ST_TO_ADDR
// if p3 = 4 then
96517: LD_VAR 0 3
96521: PUSH
96522: LD_INT 4
96524: EQUAL
96525: IFFALSE 96535
// sSpec := true ;
96527: LD_ADDR_EXP 129
96531: PUSH
96532: LD_INT 1
96534: ST_TO_ADDR
// if p3 = 5 then
96535: LD_VAR 0 3
96539: PUSH
96540: LD_INT 5
96542: EQUAL
96543: IFFALSE 96553
// sLevel := true ;
96545: LD_ADDR_EXP 133
96549: PUSH
96550: LD_INT 1
96552: ST_TO_ADDR
// if p3 = 6 then
96553: LD_VAR 0 3
96557: PUSH
96558: LD_INT 6
96560: EQUAL
96561: IFFALSE 96571
// sArmoury := true ;
96563: LD_ADDR_EXP 134
96567: PUSH
96568: LD_INT 1
96570: ST_TO_ADDR
// if p3 = 7 then
96571: LD_VAR 0 3
96575: PUSH
96576: LD_INT 7
96578: EQUAL
96579: IFFALSE 96589
// sRadar := true ;
96581: LD_ADDR_EXP 135
96585: PUSH
96586: LD_INT 1
96588: ST_TO_ADDR
// if p3 = 8 then
96589: LD_VAR 0 3
96593: PUSH
96594: LD_INT 8
96596: EQUAL
96597: IFFALSE 96607
// sBunker := true ;
96599: LD_ADDR_EXP 136
96603: PUSH
96604: LD_INT 1
96606: ST_TO_ADDR
// if p3 = 9 then
96607: LD_VAR 0 3
96611: PUSH
96612: LD_INT 9
96614: EQUAL
96615: IFFALSE 96625
// sHack := true ;
96617: LD_ADDR_EXP 137
96621: PUSH
96622: LD_INT 1
96624: ST_TO_ADDR
// if p3 = 10 then
96625: LD_VAR 0 3
96629: PUSH
96630: LD_INT 10
96632: EQUAL
96633: IFFALSE 96643
// sFire := true ;
96635: LD_ADDR_EXP 138
96639: PUSH
96640: LD_INT 1
96642: ST_TO_ADDR
// if p3 = 11 then
96643: LD_VAR 0 3
96647: PUSH
96648: LD_INT 11
96650: EQUAL
96651: IFFALSE 96661
// sRefresh := true ;
96653: LD_ADDR_EXP 139
96657: PUSH
96658: LD_INT 1
96660: ST_TO_ADDR
// if p3 = 12 then
96661: LD_VAR 0 3
96665: PUSH
96666: LD_INT 12
96668: EQUAL
96669: IFFALSE 96679
// sExp := true ;
96671: LD_ADDR_EXP 140
96675: PUSH
96676: LD_INT 1
96678: ST_TO_ADDR
// if p3 = 13 then
96679: LD_VAR 0 3
96683: PUSH
96684: LD_INT 13
96686: EQUAL
96687: IFFALSE 96697
// sDepot := true ;
96689: LD_ADDR_EXP 141
96693: PUSH
96694: LD_INT 1
96696: ST_TO_ADDR
// if p3 = 14 then
96697: LD_VAR 0 3
96701: PUSH
96702: LD_INT 14
96704: EQUAL
96705: IFFALSE 96715
// sFlag := true ;
96707: LD_ADDR_EXP 142
96711: PUSH
96712: LD_INT 1
96714: ST_TO_ADDR
// if p3 = 15 then
96715: LD_VAR 0 3
96719: PUSH
96720: LD_INT 15
96722: EQUAL
96723: IFFALSE 96733
// sKamikadze := true ;
96725: LD_ADDR_EXP 150
96729: PUSH
96730: LD_INT 1
96732: ST_TO_ADDR
// if p3 = 16 then
96733: LD_VAR 0 3
96737: PUSH
96738: LD_INT 16
96740: EQUAL
96741: IFFALSE 96751
// sTroll := true ;
96743: LD_ADDR_EXP 151
96747: PUSH
96748: LD_INT 1
96750: ST_TO_ADDR
// if p3 = 17 then
96751: LD_VAR 0 3
96755: PUSH
96756: LD_INT 17
96758: EQUAL
96759: IFFALSE 96769
// sSlow := true ;
96761: LD_ADDR_EXP 152
96765: PUSH
96766: LD_INT 1
96768: ST_TO_ADDR
// if p3 = 18 then
96769: LD_VAR 0 3
96773: PUSH
96774: LD_INT 18
96776: EQUAL
96777: IFFALSE 96787
// sLack := true ;
96779: LD_ADDR_EXP 153
96783: PUSH
96784: LD_INT 1
96786: ST_TO_ADDR
// if p3 = 19 then
96787: LD_VAR 0 3
96791: PUSH
96792: LD_INT 19
96794: EQUAL
96795: IFFALSE 96805
// sTank := true ;
96797: LD_ADDR_EXP 155
96801: PUSH
96802: LD_INT 1
96804: ST_TO_ADDR
// if p3 = 20 then
96805: LD_VAR 0 3
96809: PUSH
96810: LD_INT 20
96812: EQUAL
96813: IFFALSE 96823
// sRemote := true ;
96815: LD_ADDR_EXP 156
96819: PUSH
96820: LD_INT 1
96822: ST_TO_ADDR
// if p3 = 21 then
96823: LD_VAR 0 3
96827: PUSH
96828: LD_INT 21
96830: EQUAL
96831: IFFALSE 96841
// sPowell := true ;
96833: LD_ADDR_EXP 157
96837: PUSH
96838: LD_INT 1
96840: ST_TO_ADDR
// if p3 = 22 then
96841: LD_VAR 0 3
96845: PUSH
96846: LD_INT 22
96848: EQUAL
96849: IFFALSE 96859
// sTeleport := true ;
96851: LD_ADDR_EXP 160
96855: PUSH
96856: LD_INT 1
96858: ST_TO_ADDR
// if p3 = 23 then
96859: LD_VAR 0 3
96863: PUSH
96864: LD_INT 23
96866: EQUAL
96867: IFFALSE 96877
// sOilTower := true ;
96869: LD_ADDR_EXP 162
96873: PUSH
96874: LD_INT 1
96876: ST_TO_ADDR
// if p3 = 24 then
96877: LD_VAR 0 3
96881: PUSH
96882: LD_INT 24
96884: EQUAL
96885: IFFALSE 96895
// sShovel := true ;
96887: LD_ADDR_EXP 163
96891: PUSH
96892: LD_INT 1
96894: ST_TO_ADDR
// if p3 = 25 then
96895: LD_VAR 0 3
96899: PUSH
96900: LD_INT 25
96902: EQUAL
96903: IFFALSE 96913
// sSheik := true ;
96905: LD_ADDR_EXP 164
96909: PUSH
96910: LD_INT 1
96912: ST_TO_ADDR
// if p3 = 26 then
96913: LD_VAR 0 3
96917: PUSH
96918: LD_INT 26
96920: EQUAL
96921: IFFALSE 96931
// sEarthquake := true ;
96923: LD_ADDR_EXP 166
96927: PUSH
96928: LD_INT 1
96930: ST_TO_ADDR
// if p3 = 27 then
96931: LD_VAR 0 3
96935: PUSH
96936: LD_INT 27
96938: EQUAL
96939: IFFALSE 96949
// sAI := true ;
96941: LD_ADDR_EXP 167
96945: PUSH
96946: LD_INT 1
96948: ST_TO_ADDR
// if p3 = 28 then
96949: LD_VAR 0 3
96953: PUSH
96954: LD_INT 28
96956: EQUAL
96957: IFFALSE 96967
// sCargo := true ;
96959: LD_ADDR_EXP 170
96963: PUSH
96964: LD_INT 1
96966: ST_TO_ADDR
// if p3 = 29 then
96967: LD_VAR 0 3
96971: PUSH
96972: LD_INT 29
96974: EQUAL
96975: IFFALSE 96985
// sDLaser := true ;
96977: LD_ADDR_EXP 171
96981: PUSH
96982: LD_INT 1
96984: ST_TO_ADDR
// if p3 = 30 then
96985: LD_VAR 0 3
96989: PUSH
96990: LD_INT 30
96992: EQUAL
96993: IFFALSE 97003
// sExchange := true ;
96995: LD_ADDR_EXP 172
96999: PUSH
97000: LD_INT 1
97002: ST_TO_ADDR
// if p3 = 31 then
97003: LD_VAR 0 3
97007: PUSH
97008: LD_INT 31
97010: EQUAL
97011: IFFALSE 97021
// sFac := true ;
97013: LD_ADDR_EXP 173
97017: PUSH
97018: LD_INT 1
97020: ST_TO_ADDR
// if p3 = 32 then
97021: LD_VAR 0 3
97025: PUSH
97026: LD_INT 32
97028: EQUAL
97029: IFFALSE 97039
// sPower := true ;
97031: LD_ADDR_EXP 174
97035: PUSH
97036: LD_INT 1
97038: ST_TO_ADDR
// if p3 = 33 then
97039: LD_VAR 0 3
97043: PUSH
97044: LD_INT 33
97046: EQUAL
97047: IFFALSE 97057
// sRandom := true ;
97049: LD_ADDR_EXP 175
97053: PUSH
97054: LD_INT 1
97056: ST_TO_ADDR
// if p3 = 34 then
97057: LD_VAR 0 3
97061: PUSH
97062: LD_INT 34
97064: EQUAL
97065: IFFALSE 97075
// sShield := true ;
97067: LD_ADDR_EXP 176
97071: PUSH
97072: LD_INT 1
97074: ST_TO_ADDR
// if p3 = 35 then
97075: LD_VAR 0 3
97079: PUSH
97080: LD_INT 35
97082: EQUAL
97083: IFFALSE 97093
// sTime := true ;
97085: LD_ADDR_EXP 177
97089: PUSH
97090: LD_INT 1
97092: ST_TO_ADDR
// if p3 = 36 then
97093: LD_VAR 0 3
97097: PUSH
97098: LD_INT 36
97100: EQUAL
97101: IFFALSE 97111
// sTools := true ;
97103: LD_ADDR_EXP 178
97107: PUSH
97108: LD_INT 1
97110: ST_TO_ADDR
// if p3 = 101 then
97111: LD_VAR 0 3
97115: PUSH
97116: LD_INT 101
97118: EQUAL
97119: IFFALSE 97129
// sSold := true ;
97121: LD_ADDR_EXP 143
97125: PUSH
97126: LD_INT 1
97128: ST_TO_ADDR
// if p3 = 102 then
97129: LD_VAR 0 3
97133: PUSH
97134: LD_INT 102
97136: EQUAL
97137: IFFALSE 97147
// sDiff := true ;
97139: LD_ADDR_EXP 144
97143: PUSH
97144: LD_INT 1
97146: ST_TO_ADDR
// if p3 = 103 then
97147: LD_VAR 0 3
97151: PUSH
97152: LD_INT 103
97154: EQUAL
97155: IFFALSE 97165
// sFog := true ;
97157: LD_ADDR_EXP 147
97161: PUSH
97162: LD_INT 1
97164: ST_TO_ADDR
// if p3 = 104 then
97165: LD_VAR 0 3
97169: PUSH
97170: LD_INT 104
97172: EQUAL
97173: IFFALSE 97183
// sReset := true ;
97175: LD_ADDR_EXP 148
97179: PUSH
97180: LD_INT 1
97182: ST_TO_ADDR
// if p3 = 105 then
97183: LD_VAR 0 3
97187: PUSH
97188: LD_INT 105
97190: EQUAL
97191: IFFALSE 97201
// sSun := true ;
97193: LD_ADDR_EXP 149
97197: PUSH
97198: LD_INT 1
97200: ST_TO_ADDR
// if p3 = 106 then
97201: LD_VAR 0 3
97205: PUSH
97206: LD_INT 106
97208: EQUAL
97209: IFFALSE 97219
// sTiger := true ;
97211: LD_ADDR_EXP 145
97215: PUSH
97216: LD_INT 1
97218: ST_TO_ADDR
// if p3 = 107 then
97219: LD_VAR 0 3
97223: PUSH
97224: LD_INT 107
97226: EQUAL
97227: IFFALSE 97237
// sBomb := true ;
97229: LD_ADDR_EXP 146
97233: PUSH
97234: LD_INT 1
97236: ST_TO_ADDR
// if p3 = 108 then
97237: LD_VAR 0 3
97241: PUSH
97242: LD_INT 108
97244: EQUAL
97245: IFFALSE 97255
// sWound := true ;
97247: LD_ADDR_EXP 154
97251: PUSH
97252: LD_INT 1
97254: ST_TO_ADDR
// if p3 = 109 then
97255: LD_VAR 0 3
97259: PUSH
97260: LD_INT 109
97262: EQUAL
97263: IFFALSE 97273
// sBetray := true ;
97265: LD_ADDR_EXP 158
97269: PUSH
97270: LD_INT 1
97272: ST_TO_ADDR
// if p3 = 110 then
97273: LD_VAR 0 3
97277: PUSH
97278: LD_INT 110
97280: EQUAL
97281: IFFALSE 97291
// sContamin := true ;
97283: LD_ADDR_EXP 159
97287: PUSH
97288: LD_INT 1
97290: ST_TO_ADDR
// if p3 = 111 then
97291: LD_VAR 0 3
97295: PUSH
97296: LD_INT 111
97298: EQUAL
97299: IFFALSE 97309
// sOil := true ;
97301: LD_ADDR_EXP 161
97305: PUSH
97306: LD_INT 1
97308: ST_TO_ADDR
// if p3 = 112 then
97309: LD_VAR 0 3
97313: PUSH
97314: LD_INT 112
97316: EQUAL
97317: IFFALSE 97327
// sStu := true ;
97319: LD_ADDR_EXP 165
97323: PUSH
97324: LD_INT 1
97326: ST_TO_ADDR
// if p3 = 113 then
97327: LD_VAR 0 3
97331: PUSH
97332: LD_INT 113
97334: EQUAL
97335: IFFALSE 97345
// sBazooka := true ;
97337: LD_ADDR_EXP 168
97341: PUSH
97342: LD_INT 1
97344: ST_TO_ADDR
// if p3 = 114 then
97345: LD_VAR 0 3
97349: PUSH
97350: LD_INT 114
97352: EQUAL
97353: IFFALSE 97363
// sMortar := true ;
97355: LD_ADDR_EXP 169
97359: PUSH
97360: LD_INT 1
97362: ST_TO_ADDR
// if p3 = 115 then
97363: LD_VAR 0 3
97367: PUSH
97368: LD_INT 115
97370: EQUAL
97371: IFFALSE 97381
// sRanger := true ;
97373: LD_ADDR_EXP 179
97377: PUSH
97378: LD_INT 1
97380: ST_TO_ADDR
// if p3 = 116 then
97381: LD_VAR 0 3
97385: PUSH
97386: LD_INT 116
97388: EQUAL
97389: IFFALSE 97399
// sComputer := true ;
97391: LD_ADDR_EXP 180
97395: PUSH
97396: LD_INT 1
97398: ST_TO_ADDR
// if p3 = 117 then
97399: LD_VAR 0 3
97403: PUSH
97404: LD_INT 117
97406: EQUAL
97407: IFFALSE 97417
// s30 := true ;
97409: LD_ADDR_EXP 181
97413: PUSH
97414: LD_INT 1
97416: ST_TO_ADDR
// if p3 = 118 then
97417: LD_VAR 0 3
97421: PUSH
97422: LD_INT 118
97424: EQUAL
97425: IFFALSE 97435
// s60 := true ;
97427: LD_ADDR_EXP 182
97431: PUSH
97432: LD_INT 1
97434: ST_TO_ADDR
// end ; if p2 = hack_mode then
97435: LD_VAR 0 2
97439: PUSH
97440: LD_INT 101
97442: EQUAL
97443: IFFALSE 97571
// begin case p3 of 1 :
97445: LD_VAR 0 3
97449: PUSH
97450: LD_INT 1
97452: DOUBLE
97453: EQUAL
97454: IFTRUE 97458
97456: GO 97465
97458: POP
// hHackUnlimitedResources ; 2 :
97459: CALL 109718 0 0
97463: GO 97571
97465: LD_INT 2
97467: DOUBLE
97468: EQUAL
97469: IFTRUE 97473
97471: GO 97480
97473: POP
// hHackSetLevel10 ; 3 :
97474: CALL 109851 0 0
97478: GO 97571
97480: LD_INT 3
97482: DOUBLE
97483: EQUAL
97484: IFTRUE 97488
97486: GO 97495
97488: POP
// hHackSetLevel10YourUnits ; 4 :
97489: CALL 109936 0 0
97493: GO 97571
97495: LD_INT 4
97497: DOUBLE
97498: EQUAL
97499: IFTRUE 97503
97501: GO 97510
97503: POP
// hHackInvincible ; 5 :
97504: CALL 110384 0 0
97508: GO 97571
97510: LD_INT 5
97512: DOUBLE
97513: EQUAL
97514: IFTRUE 97518
97516: GO 97525
97518: POP
// hHackInvisible ; 6 :
97519: CALL 110495 0 0
97523: GO 97571
97525: LD_INT 6
97527: DOUBLE
97528: EQUAL
97529: IFTRUE 97533
97531: GO 97540
97533: POP
// hHackChangeYourSide ; 7 :
97534: CALL 110552 0 0
97538: GO 97571
97540: LD_INT 7
97542: DOUBLE
97543: EQUAL
97544: IFTRUE 97548
97546: GO 97555
97548: POP
// hHackChangeUnitSide ; 8 :
97549: CALL 110594 0 0
97553: GO 97571
97555: LD_INT 8
97557: DOUBLE
97558: EQUAL
97559: IFTRUE 97563
97561: GO 97570
97563: POP
// hHackFog ; end ;
97564: CALL 110695 0 0
97568: GO 97571
97570: POP
// end ; if p2 = game_save_mode then
97571: LD_VAR 0 2
97575: PUSH
97576: LD_INT 102
97578: EQUAL
97579: IFFALSE 97634
// begin if p3 = 1 then
97581: LD_VAR 0 3
97585: PUSH
97586: LD_INT 1
97588: EQUAL
97589: IFFALSE 97601
// globalGameSaveCounter := p4 ;
97591: LD_ADDR_EXP 125
97595: PUSH
97596: LD_VAR 0 4
97600: ST_TO_ADDR
// if p3 = 2 and globalGameSaveCounter then
97601: LD_VAR 0 3
97605: PUSH
97606: LD_INT 2
97608: EQUAL
97609: PUSH
97610: LD_EXP 125
97614: AND
97615: IFFALSE 97634
// ToLua ( setGameSaveCounter( & globalGameSaveCounter & ) ) ;
97617: LD_STRING setGameSaveCounter(
97619: PUSH
97620: LD_EXP 125
97624: STR
97625: PUSH
97626: LD_STRING )
97628: STR
97629: PPUSH
97630: CALL_OW 559
// end ; end ;
97634: LD_VAR 0 7
97638: RET
// export StreamModeActive , normalCounter , hardcoreCounter , sSpec , sSpeed , sRocket , sEngine , sLevel , sArmoury , sRadar , sBunker , sHack , sFire , sRefresh , sExp , sDepot , sFlag , sSold , sDiff , sTiger , sBomb , sFog , sReset , sSun , sKamikadze , sTroll , sSlow , sLack , sWound , sTank , sRemote , sPowell , sBetray , sContamin , sTeleport , sOil , sOilTower , sShovel , sSheik , sStu , sEarthquake , sAI , sBazooka , sMortar , sCargo , sDLaser , sExchange , sFac , sPower , sRandom , sShield , sTime , sTools , sRanger , sComputer , s30 , s60 ; function InitStreamMode ; begin
97639: LD_INT 0
97641: PPUSH
// streamModeActive := false ;
97642: LD_ADDR_EXP 126
97646: PUSH
97647: LD_INT 0
97649: ST_TO_ADDR
// normalCounter := 36 ;
97650: LD_ADDR_EXP 127
97654: PUSH
97655: LD_INT 36
97657: ST_TO_ADDR
// hardcoreCounter := 18 ;
97658: LD_ADDR_EXP 128
97662: PUSH
97663: LD_INT 18
97665: ST_TO_ADDR
// sRocket := false ;
97666: LD_ADDR_EXP 131
97670: PUSH
97671: LD_INT 0
97673: ST_TO_ADDR
// sSpeed := false ;
97674: LD_ADDR_EXP 130
97678: PUSH
97679: LD_INT 0
97681: ST_TO_ADDR
// sEngine := false ;
97682: LD_ADDR_EXP 132
97686: PUSH
97687: LD_INT 0
97689: ST_TO_ADDR
// sSpec := false ;
97690: LD_ADDR_EXP 129
97694: PUSH
97695: LD_INT 0
97697: ST_TO_ADDR
// sLevel := false ;
97698: LD_ADDR_EXP 133
97702: PUSH
97703: LD_INT 0
97705: ST_TO_ADDR
// sArmoury := false ;
97706: LD_ADDR_EXP 134
97710: PUSH
97711: LD_INT 0
97713: ST_TO_ADDR
// sRadar := false ;
97714: LD_ADDR_EXP 135
97718: PUSH
97719: LD_INT 0
97721: ST_TO_ADDR
// sBunker := false ;
97722: LD_ADDR_EXP 136
97726: PUSH
97727: LD_INT 0
97729: ST_TO_ADDR
// sHack := false ;
97730: LD_ADDR_EXP 137
97734: PUSH
97735: LD_INT 0
97737: ST_TO_ADDR
// sFire := false ;
97738: LD_ADDR_EXP 138
97742: PUSH
97743: LD_INT 0
97745: ST_TO_ADDR
// sRefresh := false ;
97746: LD_ADDR_EXP 139
97750: PUSH
97751: LD_INT 0
97753: ST_TO_ADDR
// sExp := false ;
97754: LD_ADDR_EXP 140
97758: PUSH
97759: LD_INT 0
97761: ST_TO_ADDR
// sDepot := false ;
97762: LD_ADDR_EXP 141
97766: PUSH
97767: LD_INT 0
97769: ST_TO_ADDR
// sFlag := false ;
97770: LD_ADDR_EXP 142
97774: PUSH
97775: LD_INT 0
97777: ST_TO_ADDR
// sKamikadze := false ;
97778: LD_ADDR_EXP 150
97782: PUSH
97783: LD_INT 0
97785: ST_TO_ADDR
// sTroll := false ;
97786: LD_ADDR_EXP 151
97790: PUSH
97791: LD_INT 0
97793: ST_TO_ADDR
// sSlow := false ;
97794: LD_ADDR_EXP 152
97798: PUSH
97799: LD_INT 0
97801: ST_TO_ADDR
// sLack := false ;
97802: LD_ADDR_EXP 153
97806: PUSH
97807: LD_INT 0
97809: ST_TO_ADDR
// sTank := false ;
97810: LD_ADDR_EXP 155
97814: PUSH
97815: LD_INT 0
97817: ST_TO_ADDR
// sRemote := false ;
97818: LD_ADDR_EXP 156
97822: PUSH
97823: LD_INT 0
97825: ST_TO_ADDR
// sPowell := false ;
97826: LD_ADDR_EXP 157
97830: PUSH
97831: LD_INT 0
97833: ST_TO_ADDR
// sTeleport := false ;
97834: LD_ADDR_EXP 160
97838: PUSH
97839: LD_INT 0
97841: ST_TO_ADDR
// sOilTower := false ;
97842: LD_ADDR_EXP 162
97846: PUSH
97847: LD_INT 0
97849: ST_TO_ADDR
// sShovel := false ;
97850: LD_ADDR_EXP 163
97854: PUSH
97855: LD_INT 0
97857: ST_TO_ADDR
// sSheik := false ;
97858: LD_ADDR_EXP 164
97862: PUSH
97863: LD_INT 0
97865: ST_TO_ADDR
// sEarthquake := false ;
97866: LD_ADDR_EXP 166
97870: PUSH
97871: LD_INT 0
97873: ST_TO_ADDR
// sAI := false ;
97874: LD_ADDR_EXP 167
97878: PUSH
97879: LD_INT 0
97881: ST_TO_ADDR
// sCargo := false ;
97882: LD_ADDR_EXP 170
97886: PUSH
97887: LD_INT 0
97889: ST_TO_ADDR
// sDLaser := false ;
97890: LD_ADDR_EXP 171
97894: PUSH
97895: LD_INT 0
97897: ST_TO_ADDR
// sExchange := false ;
97898: LD_ADDR_EXP 172
97902: PUSH
97903: LD_INT 0
97905: ST_TO_ADDR
// sFac := false ;
97906: LD_ADDR_EXP 173
97910: PUSH
97911: LD_INT 0
97913: ST_TO_ADDR
// sPower := false ;
97914: LD_ADDR_EXP 174
97918: PUSH
97919: LD_INT 0
97921: ST_TO_ADDR
// sRandom := false ;
97922: LD_ADDR_EXP 175
97926: PUSH
97927: LD_INT 0
97929: ST_TO_ADDR
// sShield := false ;
97930: LD_ADDR_EXP 176
97934: PUSH
97935: LD_INT 0
97937: ST_TO_ADDR
// sTime := false ;
97938: LD_ADDR_EXP 177
97942: PUSH
97943: LD_INT 0
97945: ST_TO_ADDR
// sTools := false ;
97946: LD_ADDR_EXP 178
97950: PUSH
97951: LD_INT 0
97953: ST_TO_ADDR
// sSold := false ;
97954: LD_ADDR_EXP 143
97958: PUSH
97959: LD_INT 0
97961: ST_TO_ADDR
// sDiff := false ;
97962: LD_ADDR_EXP 144
97966: PUSH
97967: LD_INT 0
97969: ST_TO_ADDR
// sFog := false ;
97970: LD_ADDR_EXP 147
97974: PUSH
97975: LD_INT 0
97977: ST_TO_ADDR
// sReset := false ;
97978: LD_ADDR_EXP 148
97982: PUSH
97983: LD_INT 0
97985: ST_TO_ADDR
// sSun := false ;
97986: LD_ADDR_EXP 149
97990: PUSH
97991: LD_INT 0
97993: ST_TO_ADDR
// sTiger := false ;
97994: LD_ADDR_EXP 145
97998: PUSH
97999: LD_INT 0
98001: ST_TO_ADDR
// sBomb := false ;
98002: LD_ADDR_EXP 146
98006: PUSH
98007: LD_INT 0
98009: ST_TO_ADDR
// sWound := false ;
98010: LD_ADDR_EXP 154
98014: PUSH
98015: LD_INT 0
98017: ST_TO_ADDR
// sBetray := false ;
98018: LD_ADDR_EXP 158
98022: PUSH
98023: LD_INT 0
98025: ST_TO_ADDR
// sContamin := false ;
98026: LD_ADDR_EXP 159
98030: PUSH
98031: LD_INT 0
98033: ST_TO_ADDR
// sOil := false ;
98034: LD_ADDR_EXP 161
98038: PUSH
98039: LD_INT 0
98041: ST_TO_ADDR
// sStu := false ;
98042: LD_ADDR_EXP 165
98046: PUSH
98047: LD_INT 0
98049: ST_TO_ADDR
// sBazooka := false ;
98050: LD_ADDR_EXP 168
98054: PUSH
98055: LD_INT 0
98057: ST_TO_ADDR
// sMortar := false ;
98058: LD_ADDR_EXP 169
98062: PUSH
98063: LD_INT 0
98065: ST_TO_ADDR
// sRanger := false ;
98066: LD_ADDR_EXP 179
98070: PUSH
98071: LD_INT 0
98073: ST_TO_ADDR
// sComputer := false ;
98074: LD_ADDR_EXP 180
98078: PUSH
98079: LD_INT 0
98081: ST_TO_ADDR
// s30 := false ;
98082: LD_ADDR_EXP 181
98086: PUSH
98087: LD_INT 0
98089: ST_TO_ADDR
// s60 := false ;
98090: LD_ADDR_EXP 182
98094: PUSH
98095: LD_INT 0
98097: ST_TO_ADDR
// end ;
98098: LD_VAR 0 1
98102: RET
// function DefineStreamItems ( isGameLoad ) ; var tmp , flags , normal , hardcore , active , i ; begin
98103: LD_INT 0
98105: PPUSH
98106: PPUSH
98107: PPUSH
98108: PPUSH
98109: PPUSH
98110: PPUSH
98111: PPUSH
// result := [ ] ;
98112: LD_ADDR_VAR 0 2
98116: PUSH
98117: EMPTY
98118: ST_TO_ADDR
// if campaign_id = 1 then
98119: LD_OWVAR 69
98123: PUSH
98124: LD_INT 1
98126: EQUAL
98127: IFFALSE 101293
// begin case mission_number of 1 :
98129: LD_OWVAR 70
98133: PUSH
98134: LD_INT 1
98136: DOUBLE
98137: EQUAL
98138: IFTRUE 98142
98140: GO 98218
98142: POP
// result := [ [ 2 , 4 , 11 , 12 , 15 , 16 , 22 , 23 , 26 ] , [ 101 , 102 , 106 , 116 , 117 , 118 ] ] ; 2 :
98143: LD_ADDR_VAR 0 2
98147: PUSH
98148: LD_INT 2
98150: PUSH
98151: LD_INT 4
98153: PUSH
98154: LD_INT 11
98156: PUSH
98157: LD_INT 12
98159: PUSH
98160: LD_INT 15
98162: PUSH
98163: LD_INT 16
98165: PUSH
98166: LD_INT 22
98168: PUSH
98169: LD_INT 23
98171: PUSH
98172: LD_INT 26
98174: PUSH
98175: EMPTY
98176: LIST
98177: LIST
98178: LIST
98179: LIST
98180: LIST
98181: LIST
98182: LIST
98183: LIST
98184: LIST
98185: PUSH
98186: LD_INT 101
98188: PUSH
98189: LD_INT 102
98191: PUSH
98192: LD_INT 106
98194: PUSH
98195: LD_INT 116
98197: PUSH
98198: LD_INT 117
98200: PUSH
98201: LD_INT 118
98203: PUSH
98204: EMPTY
98205: LIST
98206: LIST
98207: LIST
98208: LIST
98209: LIST
98210: LIST
98211: PUSH
98212: EMPTY
98213: LIST
98214: LIST
98215: ST_TO_ADDR
98216: GO 101291
98218: LD_INT 2
98220: DOUBLE
98221: EQUAL
98222: IFTRUE 98226
98224: GO 98310
98226: POP
// result := [ [ 2 , 4 , 11 , 12 , 15 , 16 , 22 , 23 , 26 ] , [ 101 , 102 , 105 , 106 , 108 , 116 , 117 , 118 ] ] ; 3 :
98227: LD_ADDR_VAR 0 2
98231: PUSH
98232: LD_INT 2
98234: PUSH
98235: LD_INT 4
98237: PUSH
98238: LD_INT 11
98240: PUSH
98241: LD_INT 12
98243: PUSH
98244: LD_INT 15
98246: PUSH
98247: LD_INT 16
98249: PUSH
98250: LD_INT 22
98252: PUSH
98253: LD_INT 23
98255: PUSH
98256: LD_INT 26
98258: PUSH
98259: EMPTY
98260: LIST
98261: LIST
98262: LIST
98263: LIST
98264: LIST
98265: LIST
98266: LIST
98267: LIST
98268: LIST
98269: PUSH
98270: LD_INT 101
98272: PUSH
98273: LD_INT 102
98275: PUSH
98276: LD_INT 105
98278: PUSH
98279: LD_INT 106
98281: PUSH
98282: LD_INT 108
98284: PUSH
98285: LD_INT 116
98287: PUSH
98288: LD_INT 117
98290: PUSH
98291: LD_INT 118
98293: PUSH
98294: EMPTY
98295: LIST
98296: LIST
98297: LIST
98298: LIST
98299: LIST
98300: LIST
98301: LIST
98302: LIST
98303: PUSH
98304: EMPTY
98305: LIST
98306: LIST
98307: ST_TO_ADDR
98308: GO 101291
98310: LD_INT 3
98312: DOUBLE
98313: EQUAL
98314: IFTRUE 98318
98316: GO 98406
98318: POP
// result := [ [ 2 , 4 , 5 , 11 , 12 , 15 , 16 , 22 , 26 , 36 ] , [ 101 , 102 , 105 , 106 , 108 , 116 , 117 , 118 ] ] ; 4 :
98319: LD_ADDR_VAR 0 2
98323: PUSH
98324: LD_INT 2
98326: PUSH
98327: LD_INT 4
98329: PUSH
98330: LD_INT 5
98332: PUSH
98333: LD_INT 11
98335: PUSH
98336: LD_INT 12
98338: PUSH
98339: LD_INT 15
98341: PUSH
98342: LD_INT 16
98344: PUSH
98345: LD_INT 22
98347: PUSH
98348: LD_INT 26
98350: PUSH
98351: LD_INT 36
98353: PUSH
98354: EMPTY
98355: LIST
98356: LIST
98357: LIST
98358: LIST
98359: LIST
98360: LIST
98361: LIST
98362: LIST
98363: LIST
98364: LIST
98365: PUSH
98366: LD_INT 101
98368: PUSH
98369: LD_INT 102
98371: PUSH
98372: LD_INT 105
98374: PUSH
98375: LD_INT 106
98377: PUSH
98378: LD_INT 108
98380: PUSH
98381: LD_INT 116
98383: PUSH
98384: LD_INT 117
98386: PUSH
98387: LD_INT 118
98389: PUSH
98390: EMPTY
98391: LIST
98392: LIST
98393: LIST
98394: LIST
98395: LIST
98396: LIST
98397: LIST
98398: LIST
98399: PUSH
98400: EMPTY
98401: LIST
98402: LIST
98403: ST_TO_ADDR
98404: GO 101291
98406: LD_INT 4
98408: DOUBLE
98409: EQUAL
98410: IFTRUE 98414
98412: GO 98510
98414: POP
// result := [ [ 2 , 4 , 5 , 8 , 11 , 12 , 15 , 16 , 22 , 23 , 26 , 36 ] , [ 101 , 102 , 105 , 106 , 108 , 116 , 117 , 118 ] ] ; 5 :
98415: LD_ADDR_VAR 0 2
98419: PUSH
98420: LD_INT 2
98422: PUSH
98423: LD_INT 4
98425: PUSH
98426: LD_INT 5
98428: PUSH
98429: LD_INT 8
98431: PUSH
98432: LD_INT 11
98434: PUSH
98435: LD_INT 12
98437: PUSH
98438: LD_INT 15
98440: PUSH
98441: LD_INT 16
98443: PUSH
98444: LD_INT 22
98446: PUSH
98447: LD_INT 23
98449: PUSH
98450: LD_INT 26
98452: PUSH
98453: LD_INT 36
98455: PUSH
98456: EMPTY
98457: LIST
98458: LIST
98459: LIST
98460: LIST
98461: LIST
98462: LIST
98463: LIST
98464: LIST
98465: LIST
98466: LIST
98467: LIST
98468: LIST
98469: PUSH
98470: LD_INT 101
98472: PUSH
98473: LD_INT 102
98475: PUSH
98476: LD_INT 105
98478: PUSH
98479: LD_INT 106
98481: PUSH
98482: LD_INT 108
98484: PUSH
98485: LD_INT 116
98487: PUSH
98488: LD_INT 117
98490: PUSH
98491: LD_INT 118
98493: PUSH
98494: EMPTY
98495: LIST
98496: LIST
98497: LIST
98498: LIST
98499: LIST
98500: LIST
98501: LIST
98502: LIST
98503: PUSH
98504: EMPTY
98505: LIST
98506: LIST
98507: ST_TO_ADDR
98508: GO 101291
98510: LD_INT 5
98512: DOUBLE
98513: EQUAL
98514: IFTRUE 98518
98516: GO 98630
98518: POP
// result := [ [ 2 , 4 , 5 , 6 , 8 , 11 , 12 , 15 , 16 , 22 , 23 , 25 , 26 , 36 ] , [ 101 , 102 , 105 , 106 , 108 , 109 , 112 , 116 , 117 , 118 ] ] ; 6 :
98519: LD_ADDR_VAR 0 2
98523: PUSH
98524: LD_INT 2
98526: PUSH
98527: LD_INT 4
98529: PUSH
98530: LD_INT 5
98532: PUSH
98533: LD_INT 6
98535: PUSH
98536: LD_INT 8
98538: PUSH
98539: LD_INT 11
98541: PUSH
98542: LD_INT 12
98544: PUSH
98545: LD_INT 15
98547: PUSH
98548: LD_INT 16
98550: PUSH
98551: LD_INT 22
98553: PUSH
98554: LD_INT 23
98556: PUSH
98557: LD_INT 25
98559: PUSH
98560: LD_INT 26
98562: PUSH
98563: LD_INT 36
98565: PUSH
98566: EMPTY
98567: LIST
98568: LIST
98569: LIST
98570: LIST
98571: LIST
98572: LIST
98573: LIST
98574: LIST
98575: LIST
98576: LIST
98577: LIST
98578: LIST
98579: LIST
98580: LIST
98581: PUSH
98582: LD_INT 101
98584: PUSH
98585: LD_INT 102
98587: PUSH
98588: LD_INT 105
98590: PUSH
98591: LD_INT 106
98593: PUSH
98594: LD_INT 108
98596: PUSH
98597: LD_INT 109
98599: PUSH
98600: LD_INT 112
98602: PUSH
98603: LD_INT 116
98605: PUSH
98606: LD_INT 117
98608: PUSH
98609: LD_INT 118
98611: PUSH
98612: EMPTY
98613: LIST
98614: LIST
98615: LIST
98616: LIST
98617: LIST
98618: LIST
98619: LIST
98620: LIST
98621: LIST
98622: LIST
98623: PUSH
98624: EMPTY
98625: LIST
98626: LIST
98627: ST_TO_ADDR
98628: GO 101291
98630: LD_INT 6
98632: DOUBLE
98633: EQUAL
98634: IFTRUE 98638
98636: GO 98770
98638: POP
// result := [ [ 2 , 4 , 5 , 6 , 8 , 11 , 12 , 15 , 16 , 20 , 21 , 22 , 23 , 25 , 26 , 30 , 31 , 32 , 36 ] , [ 101 , 102 , 105 , 106 , 108 , 109 , 112 , 116 , 117 , 118 ] ] ; 7 :
98639: LD_ADDR_VAR 0 2
98643: PUSH
98644: LD_INT 2
98646: PUSH
98647: LD_INT 4
98649: PUSH
98650: LD_INT 5
98652: PUSH
98653: LD_INT 6
98655: PUSH
98656: LD_INT 8
98658: PUSH
98659: LD_INT 11
98661: PUSH
98662: LD_INT 12
98664: PUSH
98665: LD_INT 15
98667: PUSH
98668: LD_INT 16
98670: PUSH
98671: LD_INT 20
98673: PUSH
98674: LD_INT 21
98676: PUSH
98677: LD_INT 22
98679: PUSH
98680: LD_INT 23
98682: PUSH
98683: LD_INT 25
98685: PUSH
98686: LD_INT 26
98688: PUSH
98689: LD_INT 30
98691: PUSH
98692: LD_INT 31
98694: PUSH
98695: LD_INT 32
98697: PUSH
98698: LD_INT 36
98700: PUSH
98701: EMPTY
98702: LIST
98703: LIST
98704: LIST
98705: LIST
98706: LIST
98707: LIST
98708: LIST
98709: LIST
98710: LIST
98711: LIST
98712: LIST
98713: LIST
98714: LIST
98715: LIST
98716: LIST
98717: LIST
98718: LIST
98719: LIST
98720: LIST
98721: PUSH
98722: LD_INT 101
98724: PUSH
98725: LD_INT 102
98727: PUSH
98728: LD_INT 105
98730: PUSH
98731: LD_INT 106
98733: PUSH
98734: LD_INT 108
98736: PUSH
98737: LD_INT 109
98739: PUSH
98740: LD_INT 112
98742: PUSH
98743: LD_INT 116
98745: PUSH
98746: LD_INT 117
98748: PUSH
98749: LD_INT 118
98751: PUSH
98752: EMPTY
98753: LIST
98754: LIST
98755: LIST
98756: LIST
98757: LIST
98758: LIST
98759: LIST
98760: LIST
98761: LIST
98762: LIST
98763: PUSH
98764: EMPTY
98765: LIST
98766: LIST
98767: ST_TO_ADDR
98768: GO 101291
98770: LD_INT 7
98772: DOUBLE
98773: EQUAL
98774: IFTRUE 98778
98776: GO 98890
98778: POP
// result := [ [ 2 , 4 , 5 , 7 , 11 , 12 , 15 , 16 , 20 , 21 , 22 , 23 , 25 , 26 ] , [ 101 , 102 , 103 , 105 , 106 , 108 , 112 , 116 , 117 , 118 ] ] ; 8 :
98779: LD_ADDR_VAR 0 2
98783: PUSH
98784: LD_INT 2
98786: PUSH
98787: LD_INT 4
98789: PUSH
98790: LD_INT 5
98792: PUSH
98793: LD_INT 7
98795: PUSH
98796: LD_INT 11
98798: PUSH
98799: LD_INT 12
98801: PUSH
98802: LD_INT 15
98804: PUSH
98805: LD_INT 16
98807: PUSH
98808: LD_INT 20
98810: PUSH
98811: LD_INT 21
98813: PUSH
98814: LD_INT 22
98816: PUSH
98817: LD_INT 23
98819: PUSH
98820: LD_INT 25
98822: PUSH
98823: LD_INT 26
98825: PUSH
98826: EMPTY
98827: LIST
98828: LIST
98829: LIST
98830: LIST
98831: LIST
98832: LIST
98833: LIST
98834: LIST
98835: LIST
98836: LIST
98837: LIST
98838: LIST
98839: LIST
98840: LIST
98841: PUSH
98842: LD_INT 101
98844: PUSH
98845: LD_INT 102
98847: PUSH
98848: LD_INT 103
98850: PUSH
98851: LD_INT 105
98853: PUSH
98854: LD_INT 106
98856: PUSH
98857: LD_INT 108
98859: PUSH
98860: LD_INT 112
98862: PUSH
98863: LD_INT 116
98865: PUSH
98866: LD_INT 117
98868: PUSH
98869: LD_INT 118
98871: PUSH
98872: EMPTY
98873: LIST
98874: LIST
98875: LIST
98876: LIST
98877: LIST
98878: LIST
98879: LIST
98880: LIST
98881: LIST
98882: LIST
98883: PUSH
98884: EMPTY
98885: LIST
98886: LIST
98887: ST_TO_ADDR
98888: GO 101291
98890: LD_INT 8
98892: DOUBLE
98893: EQUAL
98894: IFTRUE 98898
98896: GO 99038
98898: POP
// result := [ [ 2 , 4 , 5 , 6 , 7 , 8 , 11 , 12 , 15 , 16 , 20 , 21 , 22 , 23 , 25 , 26 , 30 , 31 , 32 , 36 ] , [ 101 , 102 , 103 , 105 , 106 , 108 , 109 , 112 , 116 , 117 , 118 ] ] ; 9 :
98899: LD_ADDR_VAR 0 2
98903: PUSH
98904: LD_INT 2
98906: PUSH
98907: LD_INT 4
98909: PUSH
98910: LD_INT 5
98912: PUSH
98913: LD_INT 6
98915: PUSH
98916: LD_INT 7
98918: PUSH
98919: LD_INT 8
98921: PUSH
98922: LD_INT 11
98924: PUSH
98925: LD_INT 12
98927: PUSH
98928: LD_INT 15
98930: PUSH
98931: LD_INT 16
98933: PUSH
98934: LD_INT 20
98936: PUSH
98937: LD_INT 21
98939: PUSH
98940: LD_INT 22
98942: PUSH
98943: LD_INT 23
98945: PUSH
98946: LD_INT 25
98948: PUSH
98949: LD_INT 26
98951: PUSH
98952: LD_INT 30
98954: PUSH
98955: LD_INT 31
98957: PUSH
98958: LD_INT 32
98960: PUSH
98961: LD_INT 36
98963: PUSH
98964: EMPTY
98965: LIST
98966: LIST
98967: LIST
98968: LIST
98969: LIST
98970: LIST
98971: LIST
98972: LIST
98973: LIST
98974: LIST
98975: LIST
98976: LIST
98977: LIST
98978: LIST
98979: LIST
98980: LIST
98981: LIST
98982: LIST
98983: LIST
98984: LIST
98985: PUSH
98986: LD_INT 101
98988: PUSH
98989: LD_INT 102
98991: PUSH
98992: LD_INT 103
98994: PUSH
98995: LD_INT 105
98997: PUSH
98998: LD_INT 106
99000: PUSH
99001: LD_INT 108
99003: PUSH
99004: LD_INT 109
99006: PUSH
99007: LD_INT 112
99009: PUSH
99010: LD_INT 116
99012: PUSH
99013: LD_INT 117
99015: PUSH
99016: LD_INT 118
99018: PUSH
99019: EMPTY
99020: LIST
99021: LIST
99022: LIST
99023: LIST
99024: LIST
99025: LIST
99026: LIST
99027: LIST
99028: LIST
99029: LIST
99030: LIST
99031: PUSH
99032: EMPTY
99033: LIST
99034: LIST
99035: ST_TO_ADDR
99036: GO 101291
99038: LD_INT 9
99040: DOUBLE
99041: EQUAL
99042: IFTRUE 99046
99044: GO 99194
99046: POP
// result := [ [ 2 , 4 , 5 , 6 , 7 , 8 , 11 , 12 , 15 , 16 , 20 , 21 , 22 , 23 , 25 , 26 , 28 , 30 , 31 , 32 , 36 ] , [ 101 , 102 , 103 , 105 , 106 , 108 , 109 , 112 , 114 , 116 , 117 , 118 ] ] ; 10 :
99047: LD_ADDR_VAR 0 2
99051: PUSH
99052: LD_INT 2
99054: PUSH
99055: LD_INT 4
99057: PUSH
99058: LD_INT 5
99060: PUSH
99061: LD_INT 6
99063: PUSH
99064: LD_INT 7
99066: PUSH
99067: LD_INT 8
99069: PUSH
99070: LD_INT 11
99072: PUSH
99073: LD_INT 12
99075: PUSH
99076: LD_INT 15
99078: PUSH
99079: LD_INT 16
99081: PUSH
99082: LD_INT 20
99084: PUSH
99085: LD_INT 21
99087: PUSH
99088: LD_INT 22
99090: PUSH
99091: LD_INT 23
99093: PUSH
99094: LD_INT 25
99096: PUSH
99097: LD_INT 26
99099: PUSH
99100: LD_INT 28
99102: PUSH
99103: LD_INT 30
99105: PUSH
99106: LD_INT 31
99108: PUSH
99109: LD_INT 32
99111: PUSH
99112: LD_INT 36
99114: PUSH
99115: EMPTY
99116: LIST
99117: LIST
99118: LIST
99119: LIST
99120: LIST
99121: LIST
99122: LIST
99123: LIST
99124: LIST
99125: LIST
99126: LIST
99127: LIST
99128: LIST
99129: LIST
99130: LIST
99131: LIST
99132: LIST
99133: LIST
99134: LIST
99135: LIST
99136: LIST
99137: PUSH
99138: LD_INT 101
99140: PUSH
99141: LD_INT 102
99143: PUSH
99144: LD_INT 103
99146: PUSH
99147: LD_INT 105
99149: PUSH
99150: LD_INT 106
99152: PUSH
99153: LD_INT 108
99155: PUSH
99156: LD_INT 109
99158: PUSH
99159: LD_INT 112
99161: PUSH
99162: LD_INT 114
99164: PUSH
99165: LD_INT 116
99167: PUSH
99168: LD_INT 117
99170: PUSH
99171: LD_INT 118
99173: PUSH
99174: EMPTY
99175: LIST
99176: LIST
99177: LIST
99178: LIST
99179: LIST
99180: LIST
99181: LIST
99182: LIST
99183: LIST
99184: LIST
99185: LIST
99186: LIST
99187: PUSH
99188: EMPTY
99189: LIST
99190: LIST
99191: ST_TO_ADDR
99192: GO 101291
99194: LD_INT 10
99196: DOUBLE
99197: EQUAL
99198: IFTRUE 99202
99200: GO 99398
99202: POP
// result := [ [ 2 , 4 , 5 , 6 , 7 , 8 , 9 , 10 , 11 , 12 , 13 , 14 , 15 , 16 , 17 , 18 , 19 , 20 , 21 , 22 , 23 , 24 , 25 , 26 , 28 , 30 , 31 , 32 , 36 ] , [ 101 , 102 , 103 , 104 , 105 , 106 , 107 , 108 , 109 , 110 , 111 , 112 , 114 , 116 , 117 , 118 ] ] ; 11 :
99203: LD_ADDR_VAR 0 2
99207: PUSH
99208: LD_INT 2
99210: PUSH
99211: LD_INT 4
99213: PUSH
99214: LD_INT 5
99216: PUSH
99217: LD_INT 6
99219: PUSH
99220: LD_INT 7
99222: PUSH
99223: LD_INT 8
99225: PUSH
99226: LD_INT 9
99228: PUSH
99229: LD_INT 10
99231: PUSH
99232: LD_INT 11
99234: PUSH
99235: LD_INT 12
99237: PUSH
99238: LD_INT 13
99240: PUSH
99241: LD_INT 14
99243: PUSH
99244: LD_INT 15
99246: PUSH
99247: LD_INT 16
99249: PUSH
99250: LD_INT 17
99252: PUSH
99253: LD_INT 18
99255: PUSH
99256: LD_INT 19
99258: PUSH
99259: LD_INT 20
99261: PUSH
99262: LD_INT 21
99264: PUSH
99265: LD_INT 22
99267: PUSH
99268: LD_INT 23
99270: PUSH
99271: LD_INT 24
99273: PUSH
99274: LD_INT 25
99276: PUSH
99277: LD_INT 26
99279: PUSH
99280: LD_INT 28
99282: PUSH
99283: LD_INT 30
99285: PUSH
99286: LD_INT 31
99288: PUSH
99289: LD_INT 32
99291: PUSH
99292: LD_INT 36
99294: PUSH
99295: EMPTY
99296: LIST
99297: LIST
99298: LIST
99299: LIST
99300: LIST
99301: LIST
99302: LIST
99303: LIST
99304: LIST
99305: LIST
99306: LIST
99307: LIST
99308: LIST
99309: LIST
99310: LIST
99311: LIST
99312: LIST
99313: LIST
99314: LIST
99315: LIST
99316: LIST
99317: LIST
99318: LIST
99319: LIST
99320: LIST
99321: LIST
99322: LIST
99323: LIST
99324: LIST
99325: PUSH
99326: LD_INT 101
99328: PUSH
99329: LD_INT 102
99331: PUSH
99332: LD_INT 103
99334: PUSH
99335: LD_INT 104
99337: PUSH
99338: LD_INT 105
99340: PUSH
99341: LD_INT 106
99343: PUSH
99344: LD_INT 107
99346: PUSH
99347: LD_INT 108
99349: PUSH
99350: LD_INT 109
99352: PUSH
99353: LD_INT 110
99355: PUSH
99356: LD_INT 111
99358: PUSH
99359: LD_INT 112
99361: PUSH
99362: LD_INT 114
99364: PUSH
99365: LD_INT 116
99367: PUSH
99368: LD_INT 117
99370: PUSH
99371: LD_INT 118
99373: PUSH
99374: EMPTY
99375: LIST
99376: LIST
99377: LIST
99378: LIST
99379: LIST
99380: LIST
99381: LIST
99382: LIST
99383: LIST
99384: LIST
99385: LIST
99386: LIST
99387: LIST
99388: LIST
99389: LIST
99390: LIST
99391: PUSH
99392: EMPTY
99393: LIST
99394: LIST
99395: ST_TO_ADDR
99396: GO 101291
99398: LD_INT 11
99400: DOUBLE
99401: EQUAL
99402: IFTRUE 99406
99404: GO 99610
99406: POP
// result := [ [ 2 , 3 , 4 , 5 , 6 , 7 , 8 , 9 , 10 , 11 , 12 , 13 , 14 , 15 , 16 , 17 , 18 , 19 , 20 , 21 , 22 , 23 , 24 , 25 , 26 , 28 , 30 , 31 , 32 , 34 , 36 ] , [ 101 , 102 , 103 , 104 , 105 , 106 , 107 , 108 , 109 , 110 , 111 , 112 , 114 , 116 , 117 , 118 ] ] ; 12 :
99407: LD_ADDR_VAR 0 2
99411: PUSH
99412: LD_INT 2
99414: PUSH
99415: LD_INT 3
99417: PUSH
99418: LD_INT 4
99420: PUSH
99421: LD_INT 5
99423: PUSH
99424: LD_INT 6
99426: PUSH
99427: LD_INT 7
99429: PUSH
99430: LD_INT 8
99432: PUSH
99433: LD_INT 9
99435: PUSH
99436: LD_INT 10
99438: PUSH
99439: LD_INT 11
99441: PUSH
99442: LD_INT 12
99444: PUSH
99445: LD_INT 13
99447: PUSH
99448: LD_INT 14
99450: PUSH
99451: LD_INT 15
99453: PUSH
99454: LD_INT 16
99456: PUSH
99457: LD_INT 17
99459: PUSH
99460: LD_INT 18
99462: PUSH
99463: LD_INT 19
99465: PUSH
99466: LD_INT 20
99468: PUSH
99469: LD_INT 21
99471: PUSH
99472: LD_INT 22
99474: PUSH
99475: LD_INT 23
99477: PUSH
99478: LD_INT 24
99480: PUSH
99481: LD_INT 25
99483: PUSH
99484: LD_INT 26
99486: PUSH
99487: LD_INT 28
99489: PUSH
99490: LD_INT 30
99492: PUSH
99493: LD_INT 31
99495: PUSH
99496: LD_INT 32
99498: PUSH
99499: LD_INT 34
99501: PUSH
99502: LD_INT 36
99504: PUSH
99505: EMPTY
99506: LIST
99507: LIST
99508: LIST
99509: LIST
99510: LIST
99511: LIST
99512: LIST
99513: LIST
99514: LIST
99515: LIST
99516: LIST
99517: LIST
99518: LIST
99519: LIST
99520: LIST
99521: LIST
99522: LIST
99523: LIST
99524: LIST
99525: LIST
99526: LIST
99527: LIST
99528: LIST
99529: LIST
99530: LIST
99531: LIST
99532: LIST
99533: LIST
99534: LIST
99535: LIST
99536: LIST
99537: PUSH
99538: LD_INT 101
99540: PUSH
99541: LD_INT 102
99543: PUSH
99544: LD_INT 103
99546: PUSH
99547: LD_INT 104
99549: PUSH
99550: LD_INT 105
99552: PUSH
99553: LD_INT 106
99555: PUSH
99556: LD_INT 107
99558: PUSH
99559: LD_INT 108
99561: PUSH
99562: LD_INT 109
99564: PUSH
99565: LD_INT 110
99567: PUSH
99568: LD_INT 111
99570: PUSH
99571: LD_INT 112
99573: PUSH
99574: LD_INT 114
99576: PUSH
99577: LD_INT 116
99579: PUSH
99580: LD_INT 117
99582: PUSH
99583: LD_INT 118
99585: PUSH
99586: EMPTY
99587: LIST
99588: LIST
99589: LIST
99590: LIST
99591: LIST
99592: LIST
99593: LIST
99594: LIST
99595: LIST
99596: LIST
99597: LIST
99598: LIST
99599: LIST
99600: LIST
99601: LIST
99602: LIST
99603: PUSH
99604: EMPTY
99605: LIST
99606: LIST
99607: ST_TO_ADDR
99608: GO 101291
99610: LD_INT 12
99612: DOUBLE
99613: EQUAL
99614: IFTRUE 99618
99616: GO 99838
99618: POP
// result := [ [ 1 , 2 , 3 , 4 , 5 , 6 , 7 , 8 , 9 , 10 , 11 , 12 , 13 , 14 , 15 , 16 , 17 , 18 , 19 , 20 , 21 , 22 , 23 , 24 , 25 , 26 , 27 , 28 , 30 , 31 , 32 , 33 , 34 , 36 ] , [ 101 , 102 , 103 , 104 , 105 , 106 , 107 , 108 , 109 , 110 , 111 , 112 , 113 , 114 , 116 , 117 , 118 ] ] ; 13 :
99619: LD_ADDR_VAR 0 2
99623: PUSH
99624: LD_INT 1
99626: PUSH
99627: LD_INT 2
99629: PUSH
99630: LD_INT 3
99632: PUSH
99633: LD_INT 4
99635: PUSH
99636: LD_INT 5
99638: PUSH
99639: LD_INT 6
99641: PUSH
99642: LD_INT 7
99644: PUSH
99645: LD_INT 8
99647: PUSH
99648: LD_INT 9
99650: PUSH
99651: LD_INT 10
99653: PUSH
99654: LD_INT 11
99656: PUSH
99657: LD_INT 12
99659: PUSH
99660: LD_INT 13
99662: PUSH
99663: LD_INT 14
99665: PUSH
99666: LD_INT 15
99668: PUSH
99669: LD_INT 16
99671: PUSH
99672: LD_INT 17
99674: PUSH
99675: LD_INT 18
99677: PUSH
99678: LD_INT 19
99680: PUSH
99681: LD_INT 20
99683: PUSH
99684: LD_INT 21
99686: PUSH
99687: LD_INT 22
99689: PUSH
99690: LD_INT 23
99692: PUSH
99693: LD_INT 24
99695: PUSH
99696: LD_INT 25
99698: PUSH
99699: LD_INT 26
99701: PUSH
99702: LD_INT 27
99704: PUSH
99705: LD_INT 28
99707: PUSH
99708: LD_INT 30
99710: PUSH
99711: LD_INT 31
99713: PUSH
99714: LD_INT 32
99716: PUSH
99717: LD_INT 33
99719: PUSH
99720: LD_INT 34
99722: PUSH
99723: LD_INT 36
99725: PUSH
99726: EMPTY
99727: LIST
99728: LIST
99729: LIST
99730: LIST
99731: LIST
99732: LIST
99733: LIST
99734: LIST
99735: LIST
99736: LIST
99737: LIST
99738: LIST
99739: LIST
99740: LIST
99741: LIST
99742: LIST
99743: LIST
99744: LIST
99745: LIST
99746: LIST
99747: LIST
99748: LIST
99749: LIST
99750: LIST
99751: LIST
99752: LIST
99753: LIST
99754: LIST
99755: LIST
99756: LIST
99757: LIST
99758: LIST
99759: LIST
99760: LIST
99761: PUSH
99762: LD_INT 101
99764: PUSH
99765: LD_INT 102
99767: PUSH
99768: LD_INT 103
99770: PUSH
99771: LD_INT 104
99773: PUSH
99774: LD_INT 105
99776: PUSH
99777: LD_INT 106
99779: PUSH
99780: LD_INT 107
99782: PUSH
99783: LD_INT 108
99785: PUSH
99786: LD_INT 109
99788: PUSH
99789: LD_INT 110
99791: PUSH
99792: LD_INT 111
99794: PUSH
99795: LD_INT 112
99797: PUSH
99798: LD_INT 113
99800: PUSH
99801: LD_INT 114
99803: PUSH
99804: LD_INT 116
99806: PUSH
99807: LD_INT 117
99809: PUSH
99810: LD_INT 118
99812: PUSH
99813: EMPTY
99814: LIST
99815: LIST
99816: LIST
99817: LIST
99818: LIST
99819: LIST
99820: LIST
99821: LIST
99822: LIST
99823: LIST
99824: LIST
99825: LIST
99826: LIST
99827: LIST
99828: LIST
99829: LIST
99830: LIST
99831: PUSH
99832: EMPTY
99833: LIST
99834: LIST
99835: ST_TO_ADDR
99836: GO 101291
99838: LD_INT 13
99840: DOUBLE
99841: EQUAL
99842: IFTRUE 99846
99844: GO 100054
99846: POP
// result := [ [ 1 , 2 , 3 , 4 , 5 , 8 , 9 , 10 , 11 , 12 , 14 , 15 , 16 , 17 , 18 , 19 , 20 , 21 , 22 , 23 , 24 , 25 , 26 , 27 , 28 , 30 , 31 , 32 , 33 , 34 , 36 ] , [ 101 , 102 , 103 , 104 , 105 , 106 , 107 , 108 , 109 , 110 , 111 , 112 , 113 , 114 , 116 , 117 , 118 ] ] ; 14 :
99847: LD_ADDR_VAR 0 2
99851: PUSH
99852: LD_INT 1
99854: PUSH
99855: LD_INT 2
99857: PUSH
99858: LD_INT 3
99860: PUSH
99861: LD_INT 4
99863: PUSH
99864: LD_INT 5
99866: PUSH
99867: LD_INT 8
99869: PUSH
99870: LD_INT 9
99872: PUSH
99873: LD_INT 10
99875: PUSH
99876: LD_INT 11
99878: PUSH
99879: LD_INT 12
99881: PUSH
99882: LD_INT 14
99884: PUSH
99885: LD_INT 15
99887: PUSH
99888: LD_INT 16
99890: PUSH
99891: LD_INT 17
99893: PUSH
99894: LD_INT 18
99896: PUSH
99897: LD_INT 19
99899: PUSH
99900: LD_INT 20
99902: PUSH
99903: LD_INT 21
99905: PUSH
99906: LD_INT 22
99908: PUSH
99909: LD_INT 23
99911: PUSH
99912: LD_INT 24
99914: PUSH
99915: LD_INT 25
99917: PUSH
99918: LD_INT 26
99920: PUSH
99921: LD_INT 27
99923: PUSH
99924: LD_INT 28
99926: PUSH
99927: LD_INT 30
99929: PUSH
99930: LD_INT 31
99932: PUSH
99933: LD_INT 32
99935: PUSH
99936: LD_INT 33
99938: PUSH
99939: LD_INT 34
99941: PUSH
99942: LD_INT 36
99944: PUSH
99945: EMPTY
99946: LIST
99947: LIST
99948: LIST
99949: LIST
99950: LIST
99951: LIST
99952: LIST
99953: LIST
99954: LIST
99955: LIST
99956: LIST
99957: LIST
99958: LIST
99959: LIST
99960: LIST
99961: LIST
99962: LIST
99963: LIST
99964: LIST
99965: LIST
99966: LIST
99967: LIST
99968: LIST
99969: LIST
99970: LIST
99971: LIST
99972: LIST
99973: LIST
99974: LIST
99975: LIST
99976: LIST
99977: PUSH
99978: LD_INT 101
99980: PUSH
99981: LD_INT 102
99983: PUSH
99984: LD_INT 103
99986: PUSH
99987: LD_INT 104
99989: PUSH
99990: LD_INT 105
99992: PUSH
99993: LD_INT 106
99995: PUSH
99996: LD_INT 107
99998: PUSH
99999: LD_INT 108
100001: PUSH
100002: LD_INT 109
100004: PUSH
100005: LD_INT 110
100007: PUSH
100008: LD_INT 111
100010: PUSH
100011: LD_INT 112
100013: PUSH
100014: LD_INT 113
100016: PUSH
100017: LD_INT 114
100019: PUSH
100020: LD_INT 116
100022: PUSH
100023: LD_INT 117
100025: PUSH
100026: LD_INT 118
100028: PUSH
100029: EMPTY
100030: LIST
100031: LIST
100032: LIST
100033: LIST
100034: LIST
100035: LIST
100036: LIST
100037: LIST
100038: LIST
100039: LIST
100040: LIST
100041: LIST
100042: LIST
100043: LIST
100044: LIST
100045: LIST
100046: LIST
100047: PUSH
100048: EMPTY
100049: LIST
100050: LIST
100051: ST_TO_ADDR
100052: GO 101291
100054: LD_INT 14
100056: DOUBLE
100057: EQUAL
100058: IFTRUE 100062
100060: GO 100286
100062: POP
// result := [ [ 1 , 2 , 3 , 4 , 5 , 6 , 7 , 8 , 9 , 10 , 11 , 12 , 13 , 14 , 15 , 16 , 17 , 18 , 19 , 20 , 21 , 22 , 23 , 24 , 25 , 26 , 27 , 28 , 29 , 30 , 31 , 32 , 33 , 34 , 36 ] , [ 101 , 102 , 103 , 104 , 105 , 106 , 107 , 108 , 109 , 110 , 111 , 112 , 113 , 114 , 116 , 117 , 118 ] ] ; 15 :
100063: LD_ADDR_VAR 0 2
100067: PUSH
100068: LD_INT 1
100070: PUSH
100071: LD_INT 2
100073: PUSH
100074: LD_INT 3
100076: PUSH
100077: LD_INT 4
100079: PUSH
100080: LD_INT 5
100082: PUSH
100083: LD_INT 6
100085: PUSH
100086: LD_INT 7
100088: PUSH
100089: LD_INT 8
100091: PUSH
100092: LD_INT 9
100094: PUSH
100095: LD_INT 10
100097: PUSH
100098: LD_INT 11
100100: PUSH
100101: LD_INT 12
100103: PUSH
100104: LD_INT 13
100106: PUSH
100107: LD_INT 14
100109: PUSH
100110: LD_INT 15
100112: PUSH
100113: LD_INT 16
100115: PUSH
100116: LD_INT 17
100118: PUSH
100119: LD_INT 18
100121: PUSH
100122: LD_INT 19
100124: PUSH
100125: LD_INT 20
100127: PUSH
100128: LD_INT 21
100130: PUSH
100131: LD_INT 22
100133: PUSH
100134: LD_INT 23
100136: PUSH
100137: LD_INT 24
100139: PUSH
100140: LD_INT 25
100142: PUSH
100143: LD_INT 26
100145: PUSH
100146: LD_INT 27
100148: PUSH
100149: LD_INT 28
100151: PUSH
100152: LD_INT 29
100154: PUSH
100155: LD_INT 30
100157: PUSH
100158: LD_INT 31
100160: PUSH
100161: LD_INT 32
100163: PUSH
100164: LD_INT 33
100166: PUSH
100167: LD_INT 34
100169: PUSH
100170: LD_INT 36
100172: PUSH
100173: EMPTY
100174: LIST
100175: LIST
100176: LIST
100177: LIST
100178: LIST
100179: LIST
100180: LIST
100181: LIST
100182: LIST
100183: LIST
100184: LIST
100185: LIST
100186: LIST
100187: LIST
100188: LIST
100189: LIST
100190: LIST
100191: LIST
100192: LIST
100193: LIST
100194: LIST
100195: LIST
100196: LIST
100197: LIST
100198: LIST
100199: LIST
100200: LIST
100201: LIST
100202: LIST
100203: LIST
100204: LIST
100205: LIST
100206: LIST
100207: LIST
100208: LIST
100209: PUSH
100210: LD_INT 101
100212: PUSH
100213: LD_INT 102
100215: PUSH
100216: LD_INT 103
100218: PUSH
100219: LD_INT 104
100221: PUSH
100222: LD_INT 105
100224: PUSH
100225: LD_INT 106
100227: PUSH
100228: LD_INT 107
100230: PUSH
100231: LD_INT 108
100233: PUSH
100234: LD_INT 109
100236: PUSH
100237: LD_INT 110
100239: PUSH
100240: LD_INT 111
100242: PUSH
100243: LD_INT 112
100245: PUSH
100246: LD_INT 113
100248: PUSH
100249: LD_INT 114
100251: PUSH
100252: LD_INT 116
100254: PUSH
100255: LD_INT 117
100257: PUSH
100258: LD_INT 118
100260: PUSH
100261: EMPTY
100262: LIST
100263: LIST
100264: LIST
100265: LIST
100266: LIST
100267: LIST
100268: LIST
100269: LIST
100270: LIST
100271: LIST
100272: LIST
100273: LIST
100274: LIST
100275: LIST
100276: LIST
100277: LIST
100278: LIST
100279: PUSH
100280: EMPTY
100281: LIST
100282: LIST
100283: ST_TO_ADDR
100284: GO 101291
100286: LD_INT 15
100288: DOUBLE
100289: EQUAL
100290: IFTRUE 100294
100292: GO 100518
100294: POP
// result := [ [ 1 , 2 , 3 , 4 , 5 , 6 , 7 , 8 , 9 , 10 , 11 , 12 , 13 , 14 , 15 , 16 , 17 , 18 , 19 , 20 , 21 , 22 , 23 , 24 , 25 , 26 , 27 , 28 , 29 , 30 , 31 , 32 , 33 , 34 , 36 ] , [ 101 , 102 , 103 , 104 , 105 , 106 , 107 , 108 , 109 , 110 , 111 , 112 , 113 , 114 , 116 , 117 , 118 ] ] ; 16 :
100295: LD_ADDR_VAR 0 2
100299: PUSH
100300: LD_INT 1
100302: PUSH
100303: LD_INT 2
100305: PUSH
100306: LD_INT 3
100308: PUSH
100309: LD_INT 4
100311: PUSH
100312: LD_INT 5
100314: PUSH
100315: LD_INT 6
100317: PUSH
100318: LD_INT 7
100320: PUSH
100321: LD_INT 8
100323: PUSH
100324: LD_INT 9
100326: PUSH
100327: LD_INT 10
100329: PUSH
100330: LD_INT 11
100332: PUSH
100333: LD_INT 12
100335: PUSH
100336: LD_INT 13
100338: PUSH
100339: LD_INT 14
100341: PUSH
100342: LD_INT 15
100344: PUSH
100345: LD_INT 16
100347: PUSH
100348: LD_INT 17
100350: PUSH
100351: LD_INT 18
100353: PUSH
100354: LD_INT 19
100356: PUSH
100357: LD_INT 20
100359: PUSH
100360: LD_INT 21
100362: PUSH
100363: LD_INT 22
100365: PUSH
100366: LD_INT 23
100368: PUSH
100369: LD_INT 24
100371: PUSH
100372: LD_INT 25
100374: PUSH
100375: LD_INT 26
100377: PUSH
100378: LD_INT 27
100380: PUSH
100381: LD_INT 28
100383: PUSH
100384: LD_INT 29
100386: PUSH
100387: LD_INT 30
100389: PUSH
100390: LD_INT 31
100392: PUSH
100393: LD_INT 32
100395: PUSH
100396: LD_INT 33
100398: PUSH
100399: LD_INT 34
100401: PUSH
100402: LD_INT 36
100404: PUSH
100405: EMPTY
100406: LIST
100407: LIST
100408: LIST
100409: LIST
100410: LIST
100411: LIST
100412: LIST
100413: LIST
100414: LIST
100415: LIST
100416: LIST
100417: LIST
100418: LIST
100419: LIST
100420: LIST
100421: LIST
100422: LIST
100423: LIST
100424: LIST
100425: LIST
100426: LIST
100427: LIST
100428: LIST
100429: LIST
100430: LIST
100431: LIST
100432: LIST
100433: LIST
100434: LIST
100435: LIST
100436: LIST
100437: LIST
100438: LIST
100439: LIST
100440: LIST
100441: PUSH
100442: LD_INT 101
100444: PUSH
100445: LD_INT 102
100447: PUSH
100448: LD_INT 103
100450: PUSH
100451: LD_INT 104
100453: PUSH
100454: LD_INT 105
100456: PUSH
100457: LD_INT 106
100459: PUSH
100460: LD_INT 107
100462: PUSH
100463: LD_INT 108
100465: PUSH
100466: LD_INT 109
100468: PUSH
100469: LD_INT 110
100471: PUSH
100472: LD_INT 111
100474: PUSH
100475: LD_INT 112
100477: PUSH
100478: LD_INT 113
100480: PUSH
100481: LD_INT 114
100483: PUSH
100484: LD_INT 116
100486: PUSH
100487: LD_INT 117
100489: PUSH
100490: LD_INT 118
100492: PUSH
100493: EMPTY
100494: LIST
100495: LIST
100496: LIST
100497: LIST
100498: LIST
100499: LIST
100500: LIST
100501: LIST
100502: LIST
100503: LIST
100504: LIST
100505: LIST
100506: LIST
100507: LIST
100508: LIST
100509: LIST
100510: LIST
100511: PUSH
100512: EMPTY
100513: LIST
100514: LIST
100515: ST_TO_ADDR
100516: GO 101291
100518: LD_INT 16
100520: DOUBLE
100521: EQUAL
100522: IFTRUE 100526
100524: GO 100662
100526: POP
// result := [ [ 2 , 4 , 5 , 7 , 11 , 12 , 15 , 16 , 20 , 21 , 22 , 23 , 25 , 26 , 30 , 31 , 32 , 33 , 34 ] , [ 101 , 102 , 103 , 106 , 108 , 112 , 113 , 114 , 116 , 117 , 118 ] ] ; 17 :
100527: LD_ADDR_VAR 0 2
100531: PUSH
100532: LD_INT 2
100534: PUSH
100535: LD_INT 4
100537: PUSH
100538: LD_INT 5
100540: PUSH
100541: LD_INT 7
100543: PUSH
100544: LD_INT 11
100546: PUSH
100547: LD_INT 12
100549: PUSH
100550: LD_INT 15
100552: PUSH
100553: LD_INT 16
100555: PUSH
100556: LD_INT 20
100558: PUSH
100559: LD_INT 21
100561: PUSH
100562: LD_INT 22
100564: PUSH
100565: LD_INT 23
100567: PUSH
100568: LD_INT 25
100570: PUSH
100571: LD_INT 26
100573: PUSH
100574: LD_INT 30
100576: PUSH
100577: LD_INT 31
100579: PUSH
100580: LD_INT 32
100582: PUSH
100583: LD_INT 33
100585: PUSH
100586: LD_INT 34
100588: PUSH
100589: EMPTY
100590: LIST
100591: LIST
100592: LIST
100593: LIST
100594: LIST
100595: LIST
100596: LIST
100597: LIST
100598: LIST
100599: LIST
100600: LIST
100601: LIST
100602: LIST
100603: LIST
100604: LIST
100605: LIST
100606: LIST
100607: LIST
100608: LIST
100609: PUSH
100610: LD_INT 101
100612: PUSH
100613: LD_INT 102
100615: PUSH
100616: LD_INT 103
100618: PUSH
100619: LD_INT 106
100621: PUSH
100622: LD_INT 108
100624: PUSH
100625: LD_INT 112
100627: PUSH
100628: LD_INT 113
100630: PUSH
100631: LD_INT 114
100633: PUSH
100634: LD_INT 116
100636: PUSH
100637: LD_INT 117
100639: PUSH
100640: LD_INT 118
100642: PUSH
100643: EMPTY
100644: LIST
100645: LIST
100646: LIST
100647: LIST
100648: LIST
100649: LIST
100650: LIST
100651: LIST
100652: LIST
100653: LIST
100654: LIST
100655: PUSH
100656: EMPTY
100657: LIST
100658: LIST
100659: ST_TO_ADDR
100660: GO 101291
100662: LD_INT 17
100664: DOUBLE
100665: EQUAL
100666: IFTRUE 100670
100668: GO 100894
100670: POP
// result := [ [ 1 , 2 , 3 , 4 , 5 , 6 , 7 , 8 , 9 , 10 , 11 , 12 , 13 , 14 , 15 , 16 , 17 , 18 , 19 , 20 , 21 , 22 , 23 , 24 , 25 , 26 , 27 , 28 , 29 , 30 , 31 , 32 , 33 , 34 , 36 ] , [ 101 , 102 , 103 , 104 , 105 , 106 , 107 , 108 , 109 , 110 , 111 , 112 , 113 , 114 , 116 , 117 , 118 ] ] ; 18 :
100671: LD_ADDR_VAR 0 2
100675: PUSH
100676: LD_INT 1
100678: PUSH
100679: LD_INT 2
100681: PUSH
100682: LD_INT 3
100684: PUSH
100685: LD_INT 4
100687: PUSH
100688: LD_INT 5
100690: PUSH
100691: LD_INT 6
100693: PUSH
100694: LD_INT 7
100696: PUSH
100697: LD_INT 8
100699: PUSH
100700: LD_INT 9
100702: PUSH
100703: LD_INT 10
100705: PUSH
100706: LD_INT 11
100708: PUSH
100709: LD_INT 12
100711: PUSH
100712: LD_INT 13
100714: PUSH
100715: LD_INT 14
100717: PUSH
100718: LD_INT 15
100720: PUSH
100721: LD_INT 16
100723: PUSH
100724: LD_INT 17
100726: PUSH
100727: LD_INT 18
100729: PUSH
100730: LD_INT 19
100732: PUSH
100733: LD_INT 20
100735: PUSH
100736: LD_INT 21
100738: PUSH
100739: LD_INT 22
100741: PUSH
100742: LD_INT 23
100744: PUSH
100745: LD_INT 24
100747: PUSH
100748: LD_INT 25
100750: PUSH
100751: LD_INT 26
100753: PUSH
100754: LD_INT 27
100756: PUSH
100757: LD_INT 28
100759: PUSH
100760: LD_INT 29
100762: PUSH
100763: LD_INT 30
100765: PUSH
100766: LD_INT 31
100768: PUSH
100769: LD_INT 32
100771: PUSH
100772: LD_INT 33
100774: PUSH
100775: LD_INT 34
100777: PUSH
100778: LD_INT 36
100780: PUSH
100781: EMPTY
100782: LIST
100783: LIST
100784: LIST
100785: LIST
100786: LIST
100787: LIST
100788: LIST
100789: LIST
100790: LIST
100791: LIST
100792: LIST
100793: LIST
100794: LIST
100795: LIST
100796: LIST
100797: LIST
100798: LIST
100799: LIST
100800: LIST
100801: LIST
100802: LIST
100803: LIST
100804: LIST
100805: LIST
100806: LIST
100807: LIST
100808: LIST
100809: LIST
100810: LIST
100811: LIST
100812: LIST
100813: LIST
100814: LIST
100815: LIST
100816: LIST
100817: PUSH
100818: LD_INT 101
100820: PUSH
100821: LD_INT 102
100823: PUSH
100824: LD_INT 103
100826: PUSH
100827: LD_INT 104
100829: PUSH
100830: LD_INT 105
100832: PUSH
100833: LD_INT 106
100835: PUSH
100836: LD_INT 107
100838: PUSH
100839: LD_INT 108
100841: PUSH
100842: LD_INT 109
100844: PUSH
100845: LD_INT 110
100847: PUSH
100848: LD_INT 111
100850: PUSH
100851: LD_INT 112
100853: PUSH
100854: LD_INT 113
100856: PUSH
100857: LD_INT 114
100859: PUSH
100860: LD_INT 116
100862: PUSH
100863: LD_INT 117
100865: PUSH
100866: LD_INT 118
100868: PUSH
100869: EMPTY
100870: LIST
100871: LIST
100872: LIST
100873: LIST
100874: LIST
100875: LIST
100876: LIST
100877: LIST
100878: LIST
100879: LIST
100880: LIST
100881: LIST
100882: LIST
100883: LIST
100884: LIST
100885: LIST
100886: LIST
100887: PUSH
100888: EMPTY
100889: LIST
100890: LIST
100891: ST_TO_ADDR
100892: GO 101291
100894: LD_INT 18
100896: DOUBLE
100897: EQUAL
100898: IFTRUE 100902
100900: GO 101050
100902: POP
// result := [ [ 2 , 4 , 5 , 7 , 11 , 12 , 15 , 16 , 20 , 21 , 22 , 23 , 25 , 26 , 30 , 31 , 32 , 33 , 34 , 35 , 36 ] , [ 101 , 102 , 103 , 106 , 108 , 112 , 113 , 114 , 115 , 116 , 117 , 118 ] ] ; 19 :
100903: LD_ADDR_VAR 0 2
100907: PUSH
100908: LD_INT 2
100910: PUSH
100911: LD_INT 4
100913: PUSH
100914: LD_INT 5
100916: PUSH
100917: LD_INT 7
100919: PUSH
100920: LD_INT 11
100922: PUSH
100923: LD_INT 12
100925: PUSH
100926: LD_INT 15
100928: PUSH
100929: LD_INT 16
100931: PUSH
100932: LD_INT 20
100934: PUSH
100935: LD_INT 21
100937: PUSH
100938: LD_INT 22
100940: PUSH
100941: LD_INT 23
100943: PUSH
100944: LD_INT 25
100946: PUSH
100947: LD_INT 26
100949: PUSH
100950: LD_INT 30
100952: PUSH
100953: LD_INT 31
100955: PUSH
100956: LD_INT 32
100958: PUSH
100959: LD_INT 33
100961: PUSH
100962: LD_INT 34
100964: PUSH
100965: LD_INT 35
100967: PUSH
100968: LD_INT 36
100970: PUSH
100971: EMPTY
100972: LIST
100973: LIST
100974: LIST
100975: LIST
100976: LIST
100977: LIST
100978: LIST
100979: LIST
100980: LIST
100981: LIST
100982: LIST
100983: LIST
100984: LIST
100985: LIST
100986: LIST
100987: LIST
100988: LIST
100989: LIST
100990: LIST
100991: LIST
100992: LIST
100993: PUSH
100994: LD_INT 101
100996: PUSH
100997: LD_INT 102
100999: PUSH
101000: LD_INT 103
101002: PUSH
101003: LD_INT 106
101005: PUSH
101006: LD_INT 108
101008: PUSH
101009: LD_INT 112
101011: PUSH
101012: LD_INT 113
101014: PUSH
101015: LD_INT 114
101017: PUSH
101018: LD_INT 115
101020: PUSH
101021: LD_INT 116
101023: PUSH
101024: LD_INT 117
101026: PUSH
101027: LD_INT 118
101029: PUSH
101030: EMPTY
101031: LIST
101032: LIST
101033: LIST
101034: LIST
101035: LIST
101036: LIST
101037: LIST
101038: LIST
101039: LIST
101040: LIST
101041: LIST
101042: LIST
101043: PUSH
101044: EMPTY
101045: LIST
101046: LIST
101047: ST_TO_ADDR
101048: GO 101291
101050: LD_INT 19
101052: DOUBLE
101053: EQUAL
101054: IFTRUE 101058
101056: GO 101290
101058: POP
// result := [ [ 1 , 2 , 3 , 4 , 5 , 6 , 7 , 8 , 9 , 10 , 11 , 12 , 13 , 14 , 15 , 16 , 17 , 18 , 19 , 20 , 21 , 22 , 23 , 24 , 25 , 26 , 27 , 28 , 29 , 30 , 31 , 32 , 33 , 34 , 35 , 36 ] , [ 101 , 102 , 103 , 104 , 105 , 106 , 107 , 108 , 109 , 110 , 111 , 112 , 113 , 114 , 115 , 116 , 117 , 118 ] ] ; end ;
101059: LD_ADDR_VAR 0 2
101063: PUSH
101064: LD_INT 1
101066: PUSH
101067: LD_INT 2
101069: PUSH
101070: LD_INT 3
101072: PUSH
101073: LD_INT 4
101075: PUSH
101076: LD_INT 5
101078: PUSH
101079: LD_INT 6
101081: PUSH
101082: LD_INT 7
101084: PUSH
101085: LD_INT 8
101087: PUSH
101088: LD_INT 9
101090: PUSH
101091: LD_INT 10
101093: PUSH
101094: LD_INT 11
101096: PUSH
101097: LD_INT 12
101099: PUSH
101100: LD_INT 13
101102: PUSH
101103: LD_INT 14
101105: PUSH
101106: LD_INT 15
101108: PUSH
101109: LD_INT 16
101111: PUSH
101112: LD_INT 17
101114: PUSH
101115: LD_INT 18
101117: PUSH
101118: LD_INT 19
101120: PUSH
101121: LD_INT 20
101123: PUSH
101124: LD_INT 21
101126: PUSH
101127: LD_INT 22
101129: PUSH
101130: LD_INT 23
101132: PUSH
101133: LD_INT 24
101135: PUSH
101136: LD_INT 25
101138: PUSH
101139: LD_INT 26
101141: PUSH
101142: LD_INT 27
101144: PUSH
101145: LD_INT 28
101147: PUSH
101148: LD_INT 29
101150: PUSH
101151: LD_INT 30
101153: PUSH
101154: LD_INT 31
101156: PUSH
101157: LD_INT 32
101159: PUSH
101160: LD_INT 33
101162: PUSH
101163: LD_INT 34
101165: PUSH
101166: LD_INT 35
101168: PUSH
101169: LD_INT 36
101171: PUSH
101172: EMPTY
101173: LIST
101174: LIST
101175: LIST
101176: LIST
101177: LIST
101178: LIST
101179: LIST
101180: LIST
101181: LIST
101182: LIST
101183: LIST
101184: LIST
101185: LIST
101186: LIST
101187: LIST
101188: LIST
101189: LIST
101190: LIST
101191: LIST
101192: LIST
101193: LIST
101194: LIST
101195: LIST
101196: LIST
101197: LIST
101198: LIST
101199: LIST
101200: LIST
101201: LIST
101202: LIST
101203: LIST
101204: LIST
101205: LIST
101206: LIST
101207: LIST
101208: LIST
101209: PUSH
101210: LD_INT 101
101212: PUSH
101213: LD_INT 102
101215: PUSH
101216: LD_INT 103
101218: PUSH
101219: LD_INT 104
101221: PUSH
101222: LD_INT 105
101224: PUSH
101225: LD_INT 106
101227: PUSH
101228: LD_INT 107
101230: PUSH
101231: LD_INT 108
101233: PUSH
101234: LD_INT 109
101236: PUSH
101237: LD_INT 110
101239: PUSH
101240: LD_INT 111
101242: PUSH
101243: LD_INT 112
101245: PUSH
101246: LD_INT 113
101248: PUSH
101249: LD_INT 114
101251: PUSH
101252: LD_INT 115
101254: PUSH
101255: LD_INT 116
101257: PUSH
101258: LD_INT 117
101260: PUSH
101261: LD_INT 118
101263: PUSH
101264: EMPTY
101265: LIST
101266: LIST
101267: LIST
101268: LIST
101269: LIST
101270: LIST
101271: LIST
101272: LIST
101273: LIST
101274: LIST
101275: LIST
101276: LIST
101277: LIST
101278: LIST
101279: LIST
101280: LIST
101281: LIST
101282: LIST
101283: PUSH
101284: EMPTY
101285: LIST
101286: LIST
101287: ST_TO_ADDR
101288: GO 101291
101290: POP
// end else
101291: GO 101522
// result := [ [ 1 , 2 , 3 , 4 , 5 , 6 , 7 , 8 , 9 , 10 , 11 , 12 , 13 , 14 , 15 , 16 , 17 , 18 , 19 , 20 , 21 , 22 , 23 , 24 , 25 , 26 , 27 , 28 , 29 , 30 , 31 , 32 , 33 , 34 , 35 , 36 ] , [ 101 , 102 , 103 , 104 , 105 , 106 , 107 , 108 , 109 , 110 , 111 , 112 , 113 , 114 , 115 , 116 , 117 , 118 ] ] ;
101293: LD_ADDR_VAR 0 2
101297: PUSH
101298: LD_INT 1
101300: PUSH
101301: LD_INT 2
101303: PUSH
101304: LD_INT 3
101306: PUSH
101307: LD_INT 4
101309: PUSH
101310: LD_INT 5
101312: PUSH
101313: LD_INT 6
101315: PUSH
101316: LD_INT 7
101318: PUSH
101319: LD_INT 8
101321: PUSH
101322: LD_INT 9
101324: PUSH
101325: LD_INT 10
101327: PUSH
101328: LD_INT 11
101330: PUSH
101331: LD_INT 12
101333: PUSH
101334: LD_INT 13
101336: PUSH
101337: LD_INT 14
101339: PUSH
101340: LD_INT 15
101342: PUSH
101343: LD_INT 16
101345: PUSH
101346: LD_INT 17
101348: PUSH
101349: LD_INT 18
101351: PUSH
101352: LD_INT 19
101354: PUSH
101355: LD_INT 20
101357: PUSH
101358: LD_INT 21
101360: PUSH
101361: LD_INT 22
101363: PUSH
101364: LD_INT 23
101366: PUSH
101367: LD_INT 24
101369: PUSH
101370: LD_INT 25
101372: PUSH
101373: LD_INT 26
101375: PUSH
101376: LD_INT 27
101378: PUSH
101379: LD_INT 28
101381: PUSH
101382: LD_INT 29
101384: PUSH
101385: LD_INT 30
101387: PUSH
101388: LD_INT 31
101390: PUSH
101391: LD_INT 32
101393: PUSH
101394: LD_INT 33
101396: PUSH
101397: LD_INT 34
101399: PUSH
101400: LD_INT 35
101402: PUSH
101403: LD_INT 36
101405: PUSH
101406: EMPTY
101407: LIST
101408: LIST
101409: LIST
101410: LIST
101411: LIST
101412: LIST
101413: LIST
101414: LIST
101415: LIST
101416: LIST
101417: LIST
101418: LIST
101419: LIST
101420: LIST
101421: LIST
101422: LIST
101423: LIST
101424: LIST
101425: LIST
101426: LIST
101427: LIST
101428: LIST
101429: LIST
101430: LIST
101431: LIST
101432: LIST
101433: LIST
101434: LIST
101435: LIST
101436: LIST
101437: LIST
101438: LIST
101439: LIST
101440: LIST
101441: LIST
101442: LIST
101443: PUSH
101444: LD_INT 101
101446: PUSH
101447: LD_INT 102
101449: PUSH
101450: LD_INT 103
101452: PUSH
101453: LD_INT 104
101455: PUSH
101456: LD_INT 105
101458: PUSH
101459: LD_INT 106
101461: PUSH
101462: LD_INT 107
101464: PUSH
101465: LD_INT 108
101467: PUSH
101468: LD_INT 109
101470: PUSH
101471: LD_INT 110
101473: PUSH
101474: LD_INT 111
101476: PUSH
101477: LD_INT 112
101479: PUSH
101480: LD_INT 113
101482: PUSH
101483: LD_INT 114
101485: PUSH
101486: LD_INT 115
101488: PUSH
101489: LD_INT 116
101491: PUSH
101492: LD_INT 117
101494: PUSH
101495: LD_INT 118
101497: PUSH
101498: EMPTY
101499: LIST
101500: LIST
101501: LIST
101502: LIST
101503: LIST
101504: LIST
101505: LIST
101506: LIST
101507: LIST
101508: LIST
101509: LIST
101510: LIST
101511: LIST
101512: LIST
101513: LIST
101514: LIST
101515: LIST
101516: LIST
101517: PUSH
101518: EMPTY
101519: LIST
101520: LIST
101521: ST_TO_ADDR
// if result then
101522: LD_VAR 0 2
101526: IFFALSE 102312
// begin normal :=  ;
101528: LD_ADDR_VAR 0 5
101532: PUSH
101533: LD_STRING 
101535: ST_TO_ADDR
// hardcore :=  ;
101536: LD_ADDR_VAR 0 6
101540: PUSH
101541: LD_STRING 
101543: ST_TO_ADDR
// active :=  ;
101544: LD_ADDR_VAR 0 7
101548: PUSH
101549: LD_STRING 
101551: ST_TO_ADDR
// for i = 1 to normalCounter do
101552: LD_ADDR_VAR 0 8
101556: PUSH
101557: DOUBLE
101558: LD_INT 1
101560: DEC
101561: ST_TO_ADDR
101562: LD_EXP 127
101566: PUSH
101567: FOR_TO
101568: IFFALSE 101669
// begin tmp := 0 ;
101570: LD_ADDR_VAR 0 3
101574: PUSH
101575: LD_STRING 0
101577: ST_TO_ADDR
// if result [ 1 ] then
101578: LD_VAR 0 2
101582: PUSH
101583: LD_INT 1
101585: ARRAY
101586: IFFALSE 101651
// if result [ 1 ] [ 1 ] = i then
101588: LD_VAR 0 2
101592: PUSH
101593: LD_INT 1
101595: ARRAY
101596: PUSH
101597: LD_INT 1
101599: ARRAY
101600: PUSH
101601: LD_VAR 0 8
101605: EQUAL
101606: IFFALSE 101651
// begin result := Replace ( result , 1 , Delete ( result [ 1 ] , 1 ) ) ;
101608: LD_ADDR_VAR 0 2
101612: PUSH
101613: LD_VAR 0 2
101617: PPUSH
101618: LD_INT 1
101620: PPUSH
101621: LD_VAR 0 2
101625: PUSH
101626: LD_INT 1
101628: ARRAY
101629: PPUSH
101630: LD_INT 1
101632: PPUSH
101633: CALL_OW 3
101637: PPUSH
101638: CALL_OW 1
101642: ST_TO_ADDR
// tmp := 1 ;
101643: LD_ADDR_VAR 0 3
101647: PUSH
101648: LD_STRING 1
101650: ST_TO_ADDR
// end ; normal := normal & tmp ;
101651: LD_ADDR_VAR 0 5
101655: PUSH
101656: LD_VAR 0 5
101660: PUSH
101661: LD_VAR 0 3
101665: STR
101666: ST_TO_ADDR
// end ;
101667: GO 101567
101669: POP
101670: POP
// for i = 1 to hardcoreCounter do
101671: LD_ADDR_VAR 0 8
101675: PUSH
101676: DOUBLE
101677: LD_INT 1
101679: DEC
101680: ST_TO_ADDR
101681: LD_EXP 128
101685: PUSH
101686: FOR_TO
101687: IFFALSE 101792
// begin tmp := 0 ;
101689: LD_ADDR_VAR 0 3
101693: PUSH
101694: LD_STRING 0
101696: ST_TO_ADDR
// if result [ 2 ] then
101697: LD_VAR 0 2
101701: PUSH
101702: LD_INT 2
101704: ARRAY
101705: IFFALSE 101774
// if result [ 2 ] [ 1 ] = 100 + i then
101707: LD_VAR 0 2
101711: PUSH
101712: LD_INT 2
101714: ARRAY
101715: PUSH
101716: LD_INT 1
101718: ARRAY
101719: PUSH
101720: LD_INT 100
101722: PUSH
101723: LD_VAR 0 8
101727: PLUS
101728: EQUAL
101729: IFFALSE 101774
// begin result := Replace ( result , 2 , Delete ( result [ 2 ] , 1 ) ) ;
101731: LD_ADDR_VAR 0 2
101735: PUSH
101736: LD_VAR 0 2
101740: PPUSH
101741: LD_INT 2
101743: PPUSH
101744: LD_VAR 0 2
101748: PUSH
101749: LD_INT 2
101751: ARRAY
101752: PPUSH
101753: LD_INT 1
101755: PPUSH
101756: CALL_OW 3
101760: PPUSH
101761: CALL_OW 1
101765: ST_TO_ADDR
// tmp := 1 ;
101766: LD_ADDR_VAR 0 3
101770: PUSH
101771: LD_STRING 1
101773: ST_TO_ADDR
// end ; hardcore := hardcore & tmp ;
101774: LD_ADDR_VAR 0 6
101778: PUSH
101779: LD_VAR 0 6
101783: PUSH
101784: LD_VAR 0 3
101788: STR
101789: ST_TO_ADDR
// end ;
101790: GO 101686
101792: POP
101793: POP
// if isGameLoad then
101794: LD_VAR 0 1
101798: IFFALSE 102273
// begin flags := [ sRocket , sSpeed , sEngine , sSpec , sLevel , sArmoury , sRadar , sBunker , sHack , sFire , sRefresh , sExp , sDepot , sFlag , sKamikadze , sTroll , sSlow , sLack , sTank , sRemote , sPowell , sTeleport , sOilTower , sShovel , sSheik , sEarthquake , sAI , sCargo , sDLaser , sExchange , sFac , sPower , sRandom , sShield , sTime , sTools , sSold , sDiff , sFog , sReset , sSun , sTiger , sBomb , sWound , sBetray , sContamin , sOil , sStu , sBazooka , sMortar , sRanger , sComputer , s30 , s60 ] ;
101800: LD_ADDR_VAR 0 4
101804: PUSH
101805: LD_EXP 131
101809: PUSH
101810: LD_EXP 130
101814: PUSH
101815: LD_EXP 132
101819: PUSH
101820: LD_EXP 129
101824: PUSH
101825: LD_EXP 133
101829: PUSH
101830: LD_EXP 134
101834: PUSH
101835: LD_EXP 135
101839: PUSH
101840: LD_EXP 136
101844: PUSH
101845: LD_EXP 137
101849: PUSH
101850: LD_EXP 138
101854: PUSH
101855: LD_EXP 139
101859: PUSH
101860: LD_EXP 140
101864: PUSH
101865: LD_EXP 141
101869: PUSH
101870: LD_EXP 142
101874: PUSH
101875: LD_EXP 150
101879: PUSH
101880: LD_EXP 151
101884: PUSH
101885: LD_EXP 152
101889: PUSH
101890: LD_EXP 153
101894: PUSH
101895: LD_EXP 155
101899: PUSH
101900: LD_EXP 156
101904: PUSH
101905: LD_EXP 157
101909: PUSH
101910: LD_EXP 160
101914: PUSH
101915: LD_EXP 162
101919: PUSH
101920: LD_EXP 163
101924: PUSH
101925: LD_EXP 164
101929: PUSH
101930: LD_EXP 166
101934: PUSH
101935: LD_EXP 167
101939: PUSH
101940: LD_EXP 170
101944: PUSH
101945: LD_EXP 171
101949: PUSH
101950: LD_EXP 172
101954: PUSH
101955: LD_EXP 173
101959: PUSH
101960: LD_EXP 174
101964: PUSH
101965: LD_EXP 175
101969: PUSH
101970: LD_EXP 176
101974: PUSH
101975: LD_EXP 177
101979: PUSH
101980: LD_EXP 178
101984: PUSH
101985: LD_EXP 143
101989: PUSH
101990: LD_EXP 144
101994: PUSH
101995: LD_EXP 147
101999: PUSH
102000: LD_EXP 148
102004: PUSH
102005: LD_EXP 149
102009: PUSH
102010: LD_EXP 145
102014: PUSH
102015: LD_EXP 146
102019: PUSH
102020: LD_EXP 154
102024: PUSH
102025: LD_EXP 158
102029: PUSH
102030: LD_EXP 159
102034: PUSH
102035: LD_EXP 161
102039: PUSH
102040: LD_EXP 165
102044: PUSH
102045: LD_EXP 168
102049: PUSH
102050: LD_EXP 169
102054: PUSH
102055: LD_EXP 179
102059: PUSH
102060: LD_EXP 180
102064: PUSH
102065: LD_EXP 181
102069: PUSH
102070: LD_EXP 182
102074: PUSH
102075: EMPTY
102076: LIST
102077: LIST
102078: LIST
102079: LIST
102080: LIST
102081: LIST
102082: LIST
102083: LIST
102084: LIST
102085: LIST
102086: LIST
102087: LIST
102088: LIST
102089: LIST
102090: LIST
102091: LIST
102092: LIST
102093: LIST
102094: LIST
102095: LIST
102096: LIST
102097: LIST
102098: LIST
102099: LIST
102100: LIST
102101: LIST
102102: LIST
102103: LIST
102104: LIST
102105: LIST
102106: LIST
102107: LIST
102108: LIST
102109: LIST
102110: LIST
102111: LIST
102112: LIST
102113: LIST
102114: LIST
102115: LIST
102116: LIST
102117: LIST
102118: LIST
102119: LIST
102120: LIST
102121: LIST
102122: LIST
102123: LIST
102124: LIST
102125: LIST
102126: LIST
102127: LIST
102128: LIST
102129: LIST
102130: ST_TO_ADDR
// tmp :=  ;
102131: LD_ADDR_VAR 0 3
102135: PUSH
102136: LD_STRING 
102138: ST_TO_ADDR
// for i = 1 to normalCounter do
102139: LD_ADDR_VAR 0 8
102143: PUSH
102144: DOUBLE
102145: LD_INT 1
102147: DEC
102148: ST_TO_ADDR
102149: LD_EXP 127
102153: PUSH
102154: FOR_TO
102155: IFFALSE 102191
// begin if flags [ i ] then
102157: LD_VAR 0 4
102161: PUSH
102162: LD_VAR 0 8
102166: ARRAY
102167: IFFALSE 102189
// tmp := tmp & i & ; ;
102169: LD_ADDR_VAR 0 3
102173: PUSH
102174: LD_VAR 0 3
102178: PUSH
102179: LD_VAR 0 8
102183: STR
102184: PUSH
102185: LD_STRING ;
102187: STR
102188: ST_TO_ADDR
// end ;
102189: GO 102154
102191: POP
102192: POP
// for i = 1 to hardcoreCounter do
102193: LD_ADDR_VAR 0 8
102197: PUSH
102198: DOUBLE
102199: LD_INT 1
102201: DEC
102202: ST_TO_ADDR
102203: LD_EXP 128
102207: PUSH
102208: FOR_TO
102209: IFFALSE 102255
// begin if flags [ normalCounter + i ] then
102211: LD_VAR 0 4
102215: PUSH
102216: LD_EXP 127
102220: PUSH
102221: LD_VAR 0 8
102225: PLUS
102226: ARRAY
102227: IFFALSE 102253
// tmp := tmp & ( 100 + i ) & ; ;
102229: LD_ADDR_VAR 0 3
102233: PUSH
102234: LD_VAR 0 3
102238: PUSH
102239: LD_INT 100
102241: PUSH
102242: LD_VAR 0 8
102246: PLUS
102247: STR
102248: PUSH
102249: LD_STRING ;
102251: STR
102252: ST_TO_ADDR
// end ;
102253: GO 102208
102255: POP
102256: POP
// if tmp then
102257: LD_VAR 0 3
102261: IFFALSE 102273
// active := tmp ;
102263: LD_ADDR_VAR 0 7
102267: PUSH
102268: LD_VAR 0 3
102272: ST_TO_ADDR
// end ; ToLua ( getStreamItemsFromMission(" & normal & "," & hardcore & "," & active & ") ) ;
102273: LD_STRING getStreamItemsFromMission("
102275: PUSH
102276: LD_VAR 0 5
102280: STR
102281: PUSH
102282: LD_STRING ","
102284: STR
102285: PUSH
102286: LD_VAR 0 6
102290: STR
102291: PUSH
102292: LD_STRING ","
102294: STR
102295: PUSH
102296: LD_VAR 0 7
102300: STR
102301: PUSH
102302: LD_STRING ")
102304: STR
102305: PPUSH
102306: CALL_OW 559
// end else
102310: GO 102319
// ToLua ( getStreamItemsFromMission("","","") ) ;
102312: LD_STRING getStreamItemsFromMission("","","")
102314: PPUSH
102315: CALL_OW 559
// end ;
102319: LD_VAR 0 2
102323: RET
// every 0 0$2 trigger StreamModeActive and sRocket do var i , tmp ;
102324: LD_EXP 126
102328: PUSH
102329: LD_EXP 131
102333: AND
102334: IFFALSE 102458
102336: GO 102338
102338: DISABLE
102339: LD_INT 0
102341: PPUSH
102342: PPUSH
// begin enable ;
102343: ENABLE
// tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_or , [ f_weapon , us_rocket_launcher ] , [ f_weapon , ru_rocket_launcher ] , [ f_weapon , ar_rocket_launcher ] , [ f_weapon , ru_rocket ] ] ] ) ;
102344: LD_ADDR_VAR 0 2
102348: PUSH
102349: LD_INT 22
102351: PUSH
102352: LD_OWVAR 2
102356: PUSH
102357: EMPTY
102358: LIST
102359: LIST
102360: PUSH
102361: LD_INT 2
102363: PUSH
102364: LD_INT 34
102366: PUSH
102367: LD_INT 7
102369: PUSH
102370: EMPTY
102371: LIST
102372: LIST
102373: PUSH
102374: LD_INT 34
102376: PUSH
102377: LD_INT 45
102379: PUSH
102380: EMPTY
102381: LIST
102382: LIST
102383: PUSH
102384: LD_INT 34
102386: PUSH
102387: LD_INT 28
102389: PUSH
102390: EMPTY
102391: LIST
102392: LIST
102393: PUSH
102394: LD_INT 34
102396: PUSH
102397: LD_INT 47
102399: PUSH
102400: EMPTY
102401: LIST
102402: LIST
102403: PUSH
102404: EMPTY
102405: LIST
102406: LIST
102407: LIST
102408: LIST
102409: LIST
102410: PUSH
102411: EMPTY
102412: LIST
102413: LIST
102414: PPUSH
102415: CALL_OW 69
102419: ST_TO_ADDR
// if not tmp then
102420: LD_VAR 0 2
102424: NOT
102425: IFFALSE 102429
// exit ;
102427: GO 102458
// for i in tmp do
102429: LD_ADDR_VAR 0 1
102433: PUSH
102434: LD_VAR 0 2
102438: PUSH
102439: FOR_IN
102440: IFFALSE 102456
// begin SetLives ( i , 0 ) ;
102442: LD_VAR 0 1
102446: PPUSH
102447: LD_INT 0
102449: PPUSH
102450: CALL_OW 234
// end ;
102454: GO 102439
102456: POP
102457: POP
// end ;
102458: PPOPN 2
102460: END
// every 0 0$2 trigger StreamModeActive and sEngine do var i , tmp ;
102461: LD_EXP 126
102465: PUSH
102466: LD_EXP 132
102470: AND
102471: IFFALSE 102555
102473: GO 102475
102475: DISABLE
102476: LD_INT 0
102478: PPUSH
102479: PPUSH
// begin enable ;
102480: ENABLE
// tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_engine , engine_siberite ] ] ) ;
102481: LD_ADDR_VAR 0 2
102485: PUSH
102486: LD_INT 22
102488: PUSH
102489: LD_OWVAR 2
102493: PUSH
102494: EMPTY
102495: LIST
102496: LIST
102497: PUSH
102498: LD_INT 32
102500: PUSH
102501: LD_INT 3
102503: PUSH
102504: EMPTY
102505: LIST
102506: LIST
102507: PUSH
102508: EMPTY
102509: LIST
102510: LIST
102511: PPUSH
102512: CALL_OW 69
102516: ST_TO_ADDR
// if not tmp then
102517: LD_VAR 0 2
102521: NOT
102522: IFFALSE 102526
// exit ;
102524: GO 102555
// for i in tmp do
102526: LD_ADDR_VAR 0 1
102530: PUSH
102531: LD_VAR 0 2
102535: PUSH
102536: FOR_IN
102537: IFFALSE 102553
// begin SetLives ( i , 0 ) ;
102539: LD_VAR 0 1
102543: PPUSH
102544: LD_INT 0
102546: PPUSH
102547: CALL_OW 234
// end ;
102551: GO 102536
102553: POP
102554: POP
// end ;
102555: PPOPN 2
102557: END
// every 0 0$1 trigger StreamModeActive and sSpec do var i ;
102558: LD_EXP 126
102562: PUSH
102563: LD_EXP 129
102567: AND
102568: IFFALSE 102661
102570: GO 102572
102572: DISABLE
102573: LD_INT 0
102575: PPUSH
// begin enable ;
102576: ENABLE
// for i in FilterAllUnits ( [ [ f_side , your_side ] , [ f_or , [ f_class , class_sniper ] , [ f_class , class_bazooker ] , [ f_class , class_mortar ] ] ] ) do
102577: LD_ADDR_VAR 0 1
102581: PUSH
102582: LD_INT 22
102584: PUSH
102585: LD_OWVAR 2
102589: PUSH
102590: EMPTY
102591: LIST
102592: LIST
102593: PUSH
102594: LD_INT 2
102596: PUSH
102597: LD_INT 25
102599: PUSH
102600: LD_INT 5
102602: PUSH
102603: EMPTY
102604: LIST
102605: LIST
102606: PUSH
102607: LD_INT 25
102609: PUSH
102610: LD_INT 9
102612: PUSH
102613: EMPTY
102614: LIST
102615: LIST
102616: PUSH
102617: LD_INT 25
102619: PUSH
102620: LD_INT 8
102622: PUSH
102623: EMPTY
102624: LIST
102625: LIST
102626: PUSH
102627: EMPTY
102628: LIST
102629: LIST
102630: LIST
102631: LIST
102632: PUSH
102633: EMPTY
102634: LIST
102635: LIST
102636: PPUSH
102637: CALL_OW 69
102641: PUSH
102642: FOR_IN
102643: IFFALSE 102659
// begin SetClass ( i , 1 ) ;
102645: LD_VAR 0 1
102649: PPUSH
102650: LD_INT 1
102652: PPUSH
102653: CALL_OW 336
// end ;
102657: GO 102642
102659: POP
102660: POP
// end ;
102661: PPOPN 1
102663: END
// every 0 0$1 trigger StreamModeActive and sSpeed and game_speed < 7 do
102664: LD_EXP 126
102668: PUSH
102669: LD_EXP 130
102673: AND
102674: PUSH
102675: LD_OWVAR 65
102679: PUSH
102680: LD_INT 7
102682: LESS
102683: AND
102684: IFFALSE 102698
102686: GO 102688
102688: DISABLE
// begin enable ;
102689: ENABLE
// game_speed := 7 ;
102690: LD_ADDR_OWVAR 65
102694: PUSH
102695: LD_INT 7
102697: ST_TO_ADDR
// end ;
102698: END
// every 0 0$1 trigger StreamModeActive and sLevel do var i , k , tmp ;
102699: LD_EXP 126
102703: PUSH
102704: LD_EXP 133
102708: AND
102709: IFFALSE 102911
102711: GO 102713
102713: DISABLE
102714: LD_INT 0
102716: PPUSH
102717: PPUSH
102718: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_enemy , your_side ] , [ f_type , unit_human ] ] ) ;
102719: LD_ADDR_VAR 0 3
102723: PUSH
102724: LD_INT 81
102726: PUSH
102727: LD_OWVAR 2
102731: PUSH
102732: EMPTY
102733: LIST
102734: LIST
102735: PUSH
102736: LD_INT 21
102738: PUSH
102739: LD_INT 1
102741: PUSH
102742: EMPTY
102743: LIST
102744: LIST
102745: PUSH
102746: EMPTY
102747: LIST
102748: LIST
102749: PPUSH
102750: CALL_OW 69
102754: ST_TO_ADDR
// if not tmp then
102755: LD_VAR 0 3
102759: NOT
102760: IFFALSE 102764
// exit ;
102762: GO 102911
// if tmp > 5 then
102764: LD_VAR 0 3
102768: PUSH
102769: LD_INT 5
102771: GREATER
102772: IFFALSE 102784
// k := 5 else
102774: LD_ADDR_VAR 0 2
102778: PUSH
102779: LD_INT 5
102781: ST_TO_ADDR
102782: GO 102794
// k := tmp ;
102784: LD_ADDR_VAR 0 2
102788: PUSH
102789: LD_VAR 0 3
102793: ST_TO_ADDR
// for i := 1 to k do
102794: LD_ADDR_VAR 0 1
102798: PUSH
102799: DOUBLE
102800: LD_INT 1
102802: DEC
102803: ST_TO_ADDR
102804: LD_VAR 0 2
102808: PUSH
102809: FOR_TO
102810: IFFALSE 102909
// if GetSkill ( tmp [ i ] , i mod 4 + 1 ) < 10 then
102812: LD_VAR 0 3
102816: PUSH
102817: LD_VAR 0 1
102821: ARRAY
102822: PPUSH
102823: LD_VAR 0 1
102827: PUSH
102828: LD_INT 4
102830: MOD
102831: PUSH
102832: LD_INT 1
102834: PLUS
102835: PPUSH
102836: CALL_OW 259
102840: PUSH
102841: LD_INT 10
102843: LESS
102844: IFFALSE 102907
// SetSkill ( tmp [ i ] , i mod 4 + 1 , GetSkill ( tmp [ i ] , i mod 4 + 1 ) + 1 ) ;
102846: LD_VAR 0 3
102850: PUSH
102851: LD_VAR 0 1
102855: ARRAY
102856: PPUSH
102857: LD_VAR 0 1
102861: PUSH
102862: LD_INT 4
102864: MOD
102865: PUSH
102866: LD_INT 1
102868: PLUS
102869: PPUSH
102870: LD_VAR 0 3
102874: PUSH
102875: LD_VAR 0 1
102879: ARRAY
102880: PPUSH
102881: LD_VAR 0 1
102885: PUSH
102886: LD_INT 4
102888: MOD
102889: PUSH
102890: LD_INT 1
102892: PLUS
102893: PPUSH
102894: CALL_OW 259
102898: PUSH
102899: LD_INT 1
102901: PLUS
102902: PPUSH
102903: CALL_OW 237
102907: GO 102809
102909: POP
102910: POP
// end ;
102911: PPOPN 3
102913: END
// every 0 0$1 trigger StreamModeActive and sArmoury do
102914: LD_EXP 126
102918: PUSH
102919: LD_EXP 134
102923: AND
102924: IFFALSE 102944
102926: GO 102928
102928: DISABLE
// SetRestrict ( b_armoury , your_side , false ) ;
102929: LD_INT 4
102931: PPUSH
102932: LD_OWVAR 2
102936: PPUSH
102937: LD_INT 0
102939: PPUSH
102940: CALL_OW 324
102944: END
// every 0 0$1 trigger StreamModeActive and sShovel do
102945: LD_EXP 126
102949: PUSH
102950: LD_EXP 163
102954: AND
102955: IFFALSE 102975
102957: GO 102959
102959: DISABLE
// SetRestrict ( b_ext_noncombat , your_side , false ) ;
102960: LD_INT 19
102962: PPUSH
102963: LD_OWVAR 2
102967: PPUSH
102968: LD_INT 0
102970: PPUSH
102971: CALL_OW 324
102975: END
// every 0 0$1 trigger StreamModeActive and sRadar do var i , tmp ;
102976: LD_EXP 126
102980: PUSH
102981: LD_EXP 135
102985: AND
102986: IFFALSE 103088
102988: GO 102990
102990: DISABLE
102991: LD_INT 0
102993: PPUSH
102994: PPUSH
// begin enable ;
102995: ENABLE
// tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_or , [ f_weapon , us_radar ] , [ f_weapon , ar_radar ] ] ] ) ;
102996: LD_ADDR_VAR 0 2
103000: PUSH
103001: LD_INT 22
103003: PUSH
103004: LD_OWVAR 2
103008: PUSH
103009: EMPTY
103010: LIST
103011: LIST
103012: PUSH
103013: LD_INT 2
103015: PUSH
103016: LD_INT 34
103018: PUSH
103019: LD_INT 11
103021: PUSH
103022: EMPTY
103023: LIST
103024: LIST
103025: PUSH
103026: LD_INT 34
103028: PUSH
103029: LD_INT 30
103031: PUSH
103032: EMPTY
103033: LIST
103034: LIST
103035: PUSH
103036: EMPTY
103037: LIST
103038: LIST
103039: LIST
103040: PUSH
103041: EMPTY
103042: LIST
103043: LIST
103044: PPUSH
103045: CALL_OW 69
103049: ST_TO_ADDR
// if not tmp then
103050: LD_VAR 0 2
103054: NOT
103055: IFFALSE 103059
// exit ;
103057: GO 103088
// for i in tmp do
103059: LD_ADDR_VAR 0 1
103063: PUSH
103064: LD_VAR 0 2
103068: PUSH
103069: FOR_IN
103070: IFFALSE 103086
// begin SetLives ( i , 0 ) ;
103072: LD_VAR 0 1
103076: PPUSH
103077: LD_INT 0
103079: PPUSH
103080: CALL_OW 234
// end ;
103084: GO 103069
103086: POP
103087: POP
// end ;
103088: PPOPN 2
103090: END
// every 0 0$1 trigger StreamModeActive and sBunker do
103091: LD_EXP 126
103095: PUSH
103096: LD_EXP 136
103100: AND
103101: IFFALSE 103121
103103: GO 103105
103105: DISABLE
// SetRestrict ( b_bunker , your_side , false ) ;
103106: LD_INT 32
103108: PPUSH
103109: LD_OWVAR 2
103113: PPUSH
103114: LD_INT 0
103116: PPUSH
103117: CALL_OW 324
103121: END
// every 0 0$1 trigger StreamModeActive and sHack do var i , tmp , side ;
103122: LD_EXP 126
103126: PUSH
103127: LD_EXP 137
103131: AND
103132: IFFALSE 103313
103134: GO 103136
103136: DISABLE
103137: LD_INT 0
103139: PPUSH
103140: PPUSH
103141: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_control , control_computer ] ] ) ;
103142: LD_ADDR_VAR 0 2
103146: PUSH
103147: LD_INT 22
103149: PUSH
103150: LD_OWVAR 2
103154: PUSH
103155: EMPTY
103156: LIST
103157: LIST
103158: PUSH
103159: LD_INT 33
103161: PUSH
103162: LD_INT 3
103164: PUSH
103165: EMPTY
103166: LIST
103167: LIST
103168: PUSH
103169: EMPTY
103170: LIST
103171: LIST
103172: PPUSH
103173: CALL_OW 69
103177: ST_TO_ADDR
// if not tmp then
103178: LD_VAR 0 2
103182: NOT
103183: IFFALSE 103187
// exit ;
103185: GO 103313
// side := 0 ;
103187: LD_ADDR_VAR 0 3
103191: PUSH
103192: LD_INT 0
103194: ST_TO_ADDR
// for i := 1 to 8 do
103195: LD_ADDR_VAR 0 1
103199: PUSH
103200: DOUBLE
103201: LD_INT 1
103203: DEC
103204: ST_TO_ADDR
103205: LD_INT 8
103207: PUSH
103208: FOR_TO
103209: IFFALSE 103257
// if your_side <> i and GetAttitude ( your_side , i ) = att_enemy then
103211: LD_OWVAR 2
103215: PUSH
103216: LD_VAR 0 1
103220: NONEQUAL
103221: PUSH
103222: LD_OWVAR 2
103226: PPUSH
103227: LD_VAR 0 1
103231: PPUSH
103232: CALL_OW 81
103236: PUSH
103237: LD_INT 2
103239: EQUAL
103240: AND
103241: IFFALSE 103255
// begin side := i ;
103243: LD_ADDR_VAR 0 3
103247: PUSH
103248: LD_VAR 0 1
103252: ST_TO_ADDR
// break ;
103253: GO 103257
// end ;
103255: GO 103208
103257: POP
103258: POP
// if not side then
103259: LD_VAR 0 3
103263: NOT
103264: IFFALSE 103268
// exit ;
103266: GO 103313
// for i := 1 to tmp do
103268: LD_ADDR_VAR 0 1
103272: PUSH
103273: DOUBLE
103274: LD_INT 1
103276: DEC
103277: ST_TO_ADDR
103278: LD_VAR 0 2
103282: PUSH
103283: FOR_TO
103284: IFFALSE 103311
// if Prob ( 60 ) then
103286: LD_INT 60
103288: PPUSH
103289: CALL_OW 13
103293: IFFALSE 103309
// SetSide ( i , side ) ;
103295: LD_VAR 0 1
103299: PPUSH
103300: LD_VAR 0 3
103304: PPUSH
103305: CALL_OW 235
103309: GO 103283
103311: POP
103312: POP
// end ;
103313: PPOPN 3
103315: END
// every 0 0$1 trigger StreamModeActive and sRefresh do var un ;
103316: LD_EXP 126
103320: PUSH
103321: LD_EXP 139
103325: AND
103326: IFFALSE 103445
103328: GO 103330
103330: DISABLE
103331: LD_INT 0
103333: PPUSH
// begin for un in FilterAllUnits ( [ [ f_side , your_side ] , [ f_type , unit_human ] , [ f_not , [ f_nation , 0 ] ] ] ) do
103334: LD_ADDR_VAR 0 1
103338: PUSH
103339: LD_INT 22
103341: PUSH
103342: LD_OWVAR 2
103346: PUSH
103347: EMPTY
103348: LIST
103349: LIST
103350: PUSH
103351: LD_INT 21
103353: PUSH
103354: LD_INT 1
103356: PUSH
103357: EMPTY
103358: LIST
103359: LIST
103360: PUSH
103361: LD_INT 3
103363: PUSH
103364: LD_INT 23
103366: PUSH
103367: LD_INT 0
103369: PUSH
103370: EMPTY
103371: LIST
103372: LIST
103373: PUSH
103374: EMPTY
103375: LIST
103376: LIST
103377: PUSH
103378: EMPTY
103379: LIST
103380: LIST
103381: LIST
103382: PPUSH
103383: CALL_OW 69
103387: PUSH
103388: FOR_IN
103389: IFFALSE 103443
// if GetClass ( un ) in [ 1 , 2 , 3 , 4 ] then
103391: LD_VAR 0 1
103395: PPUSH
103396: CALL_OW 257
103400: PUSH
103401: LD_INT 1
103403: PUSH
103404: LD_INT 2
103406: PUSH
103407: LD_INT 3
103409: PUSH
103410: LD_INT 4
103412: PUSH
103413: EMPTY
103414: LIST
103415: LIST
103416: LIST
103417: LIST
103418: IN
103419: IFFALSE 103441
// SetClass ( un , rand ( 1 , 4 ) ) ;
103421: LD_VAR 0 1
103425: PPUSH
103426: LD_INT 1
103428: PPUSH
103429: LD_INT 4
103431: PPUSH
103432: CALL_OW 12
103436: PPUSH
103437: CALL_OW 336
103441: GO 103388
103443: POP
103444: POP
// end ;
103445: PPOPN 1
103447: END
// every 0 0$1 trigger StreamModeActive and sFire do var tmp ;
103448: LD_EXP 126
103452: PUSH
103453: LD_EXP 138
103457: AND
103458: IFFALSE 103537
103460: GO 103462
103462: DISABLE
103463: LD_INT 0
103465: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_type , unit_building ] ] ) ;
103466: LD_ADDR_VAR 0 1
103470: PUSH
103471: LD_INT 22
103473: PUSH
103474: LD_OWVAR 2
103478: PUSH
103479: EMPTY
103480: LIST
103481: LIST
103482: PUSH
103483: LD_INT 21
103485: PUSH
103486: LD_INT 3
103488: PUSH
103489: EMPTY
103490: LIST
103491: LIST
103492: PUSH
103493: EMPTY
103494: LIST
103495: LIST
103496: PPUSH
103497: CALL_OW 69
103501: ST_TO_ADDR
// if not tmp then
103502: LD_VAR 0 1
103506: NOT
103507: IFFALSE 103511
// exit ;
103509: GO 103537
// SetLives ( tmp [ rand ( 1 , tmp ) ] , 100 ) ;
103511: LD_VAR 0 1
103515: PUSH
103516: LD_INT 1
103518: PPUSH
103519: LD_VAR 0 1
103523: PPUSH
103524: CALL_OW 12
103528: ARRAY
103529: PPUSH
103530: LD_INT 100
103532: PPUSH
103533: CALL_OW 234
// end ;
103537: PPOPN 1
103539: END
// every 0 0$1 trigger StreamModeActive and sExp do var tmp ;
103540: LD_EXP 126
103544: PUSH
103545: LD_EXP 140
103549: AND
103550: IFFALSE 103648
103552: GO 103554
103554: DISABLE
103555: LD_INT 0
103557: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_type , unit_human ] ] ) ;
103558: LD_ADDR_VAR 0 1
103562: PUSH
103563: LD_INT 22
103565: PUSH
103566: LD_OWVAR 2
103570: PUSH
103571: EMPTY
103572: LIST
103573: LIST
103574: PUSH
103575: LD_INT 21
103577: PUSH
103578: LD_INT 1
103580: PUSH
103581: EMPTY
103582: LIST
103583: LIST
103584: PUSH
103585: EMPTY
103586: LIST
103587: LIST
103588: PPUSH
103589: CALL_OW 69
103593: ST_TO_ADDR
// if not tmp then
103594: LD_VAR 0 1
103598: NOT
103599: IFFALSE 103603
// exit ;
103601: GO 103648
// AddExperience ( tmp [ rand ( 1 , tmp ) ] , rand ( 1 , 4 ) , rand ( 3000 , 9000 ) ) ;
103603: LD_VAR 0 1
103607: PUSH
103608: LD_INT 1
103610: PPUSH
103611: LD_VAR 0 1
103615: PPUSH
103616: CALL_OW 12
103620: ARRAY
103621: PPUSH
103622: LD_INT 1
103624: PPUSH
103625: LD_INT 4
103627: PPUSH
103628: CALL_OW 12
103632: PPUSH
103633: LD_INT 3000
103635: PPUSH
103636: LD_INT 9000
103638: PPUSH
103639: CALL_OW 12
103643: PPUSH
103644: CALL_OW 492
// end ;
103648: PPOPN 1
103650: END
// every 0 0$1 trigger StreamModeActive and sDepot do
103651: LD_EXP 126
103655: PUSH
103656: LD_EXP 141
103660: AND
103661: IFFALSE 103681
103663: GO 103665
103665: DISABLE
// SetRestrict ( b_warehouse , your_side , false ) ;
103666: LD_INT 1
103668: PPUSH
103669: LD_OWVAR 2
103673: PPUSH
103674: LD_INT 0
103676: PPUSH
103677: CALL_OW 324
103681: END
// every 0 0$1 trigger StreamModeActive and sFlag do var i , tmp ;
103682: LD_EXP 126
103686: PUSH
103687: LD_EXP 142
103691: AND
103692: IFFALSE 103775
103694: GO 103696
103696: DISABLE
103697: LD_INT 0
103699: PPUSH
103700: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_type , unit_building ] ] ) ;
103701: LD_ADDR_VAR 0 2
103705: PUSH
103706: LD_INT 22
103708: PUSH
103709: LD_OWVAR 2
103713: PUSH
103714: EMPTY
103715: LIST
103716: LIST
103717: PUSH
103718: LD_INT 21
103720: PUSH
103721: LD_INT 3
103723: PUSH
103724: EMPTY
103725: LIST
103726: LIST
103727: PUSH
103728: EMPTY
103729: LIST
103730: LIST
103731: PPUSH
103732: CALL_OW 69
103736: ST_TO_ADDR
// if not tmp then
103737: LD_VAR 0 2
103741: NOT
103742: IFFALSE 103746
// exit ;
103744: GO 103775
// for i in tmp do
103746: LD_ADDR_VAR 0 1
103750: PUSH
103751: LD_VAR 0 2
103755: PUSH
103756: FOR_IN
103757: IFFALSE 103773
// SetBLevel ( i , 10 ) ;
103759: LD_VAR 0 1
103763: PPUSH
103764: LD_INT 10
103766: PPUSH
103767: CALL_OW 241
103771: GO 103756
103773: POP
103774: POP
// end ;
103775: PPOPN 2
103777: END
// every 0 0$1 trigger StreamModeActive and sSold do var i , un , tmp ;
103778: LD_EXP 126
103782: PUSH
103783: LD_EXP 143
103787: AND
103788: IFFALSE 103899
103790: GO 103792
103792: DISABLE
103793: LD_INT 0
103795: PPUSH
103796: PPUSH
103797: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_class , 1 ] ] ) ;
103798: LD_ADDR_VAR 0 3
103802: PUSH
103803: LD_INT 22
103805: PUSH
103806: LD_OWVAR 2
103810: PUSH
103811: EMPTY
103812: LIST
103813: LIST
103814: PUSH
103815: LD_INT 25
103817: PUSH
103818: LD_INT 1
103820: PUSH
103821: EMPTY
103822: LIST
103823: LIST
103824: PUSH
103825: EMPTY
103826: LIST
103827: LIST
103828: PPUSH
103829: CALL_OW 69
103833: ST_TO_ADDR
// if not tmp then
103834: LD_VAR 0 3
103838: NOT
103839: IFFALSE 103843
// exit ;
103841: GO 103899
// un := tmp [ rand ( 1 , tmp ) ] ;
103843: LD_ADDR_VAR 0 2
103847: PUSH
103848: LD_VAR 0 3
103852: PUSH
103853: LD_INT 1
103855: PPUSH
103856: LD_VAR 0 3
103860: PPUSH
103861: CALL_OW 12
103865: ARRAY
103866: ST_TO_ADDR
// if Crawls ( un ) then
103867: LD_VAR 0 2
103871: PPUSH
103872: CALL_OW 318
103876: IFFALSE 103887
// ComWalk ( un ) ;
103878: LD_VAR 0 2
103882: PPUSH
103883: CALL_OW 138
// SetClass ( un , class_sniper ) ;
103887: LD_VAR 0 2
103891: PPUSH
103892: LD_INT 5
103894: PPUSH
103895: CALL_OW 336
// end ;
103899: PPOPN 3
103901: END
// every 0 0$1 trigger StreamModeActive and sDiff and Difficulty < 4 do
103902: LD_EXP 126
103906: PUSH
103907: LD_EXP 144
103911: AND
103912: PUSH
103913: LD_OWVAR 67
103917: PUSH
103918: LD_INT 4
103920: LESS
103921: AND
103922: IFFALSE 103941
103924: GO 103926
103926: DISABLE
// begin Difficulty := Difficulty + 1 ;
103927: LD_ADDR_OWVAR 67
103931: PUSH
103932: LD_OWVAR 67
103936: PUSH
103937: LD_INT 1
103939: PLUS
103940: ST_TO_ADDR
// end ;
103941: END
// every 0 0$1 trigger StreamModeActive and sTiger do var i ;
103942: LD_EXP 126
103946: PUSH
103947: LD_EXP 145
103951: AND
103952: IFFALSE 104055
103954: GO 103956
103956: DISABLE
103957: LD_INT 0
103959: PPUSH
// begin for i := 1 to 5 do
103960: LD_ADDR_VAR 0 1
103964: PUSH
103965: DOUBLE
103966: LD_INT 1
103968: DEC
103969: ST_TO_ADDR
103970: LD_INT 5
103972: PUSH
103973: FOR_TO
103974: IFFALSE 104053
// begin uc_nation := nation_nature ;
103976: LD_ADDR_OWVAR 21
103980: PUSH
103981: LD_INT 0
103983: ST_TO_ADDR
// uc_side := 0 ;
103984: LD_ADDR_OWVAR 20
103988: PUSH
103989: LD_INT 0
103991: ST_TO_ADDR
// hc_attr := [ 12 , 12 ] ;
103992: LD_ADDR_OWVAR 29
103996: PUSH
103997: LD_INT 12
103999: PUSH
104000: LD_INT 12
104002: PUSH
104003: EMPTY
104004: LIST
104005: LIST
104006: ST_TO_ADDR
// hc_agressivity := 20 ;
104007: LD_ADDR_OWVAR 35
104011: PUSH
104012: LD_INT 20
104014: ST_TO_ADDR
// hc_class := class_tiger ;
104015: LD_ADDR_OWVAR 28
104019: PUSH
104020: LD_INT 14
104022: ST_TO_ADDR
// hc_gallery :=  ;
104023: LD_ADDR_OWVAR 33
104027: PUSH
104028: LD_STRING 
104030: ST_TO_ADDR
// hc_name :=  ;
104031: LD_ADDR_OWVAR 26
104035: PUSH
104036: LD_STRING 
104038: ST_TO_ADDR
// PlaceUnitAnyWhere ( CreateHuman , false ) ;
104039: CALL_OW 44
104043: PPUSH
104044: LD_INT 0
104046: PPUSH
104047: CALL_OW 51
// end ;
104051: GO 103973
104053: POP
104054: POP
// end ;
104055: PPOPN 1
104057: END
// every 0 0$1 trigger StreamModeActive and sBomb do
104058: LD_EXP 126
104062: PUSH
104063: LD_EXP 146
104067: AND
104068: IFFALSE 104077
104070: GO 104072
104072: DISABLE
// StreamSibBomb ;
104073: CALL 104078 0 0
104077: END
// export function StreamSibBomb ; var i , x , y ; begin
104078: LD_INT 0
104080: PPUSH
104081: PPUSH
104082: PPUSH
104083: PPUSH
// result := false ;
104084: LD_ADDR_VAR 0 1
104088: PUSH
104089: LD_INT 0
104091: ST_TO_ADDR
// for i := 1 to 16 do
104092: LD_ADDR_VAR 0 2
104096: PUSH
104097: DOUBLE
104098: LD_INT 1
104100: DEC
104101: ST_TO_ADDR
104102: LD_INT 16
104104: PUSH
104105: FOR_TO
104106: IFFALSE 104305
// begin x := [ 10 , 20 , 30 , 40 , 50 , 60 , 70 , 80 , 90 , 100 , 110 , 120 , 130 , 140 , 150 ] [ rand ( 1 , 15 ) ] ;
104108: LD_ADDR_VAR 0 3
104112: PUSH
104113: LD_INT 10
104115: PUSH
104116: LD_INT 20
104118: PUSH
104119: LD_INT 30
104121: PUSH
104122: LD_INT 40
104124: PUSH
104125: LD_INT 50
104127: PUSH
104128: LD_INT 60
104130: PUSH
104131: LD_INT 70
104133: PUSH
104134: LD_INT 80
104136: PUSH
104137: LD_INT 90
104139: PUSH
104140: LD_INT 100
104142: PUSH
104143: LD_INT 110
104145: PUSH
104146: LD_INT 120
104148: PUSH
104149: LD_INT 130
104151: PUSH
104152: LD_INT 140
104154: PUSH
104155: LD_INT 150
104157: PUSH
104158: EMPTY
104159: LIST
104160: LIST
104161: LIST
104162: LIST
104163: LIST
104164: LIST
104165: LIST
104166: LIST
104167: LIST
104168: LIST
104169: LIST
104170: LIST
104171: LIST
104172: LIST
104173: LIST
104174: PUSH
104175: LD_INT 1
104177: PPUSH
104178: LD_INT 15
104180: PPUSH
104181: CALL_OW 12
104185: ARRAY
104186: ST_TO_ADDR
// y := [ 10 , 20 , 30 , 40 , 50 , 60 , 70 , 80 , 90 , 100 , 110 , 120 , 130 , 140 , 150 ] [ rand ( 1 , 15 ) ] ;
104187: LD_ADDR_VAR 0 4
104191: PUSH
104192: LD_INT 10
104194: PUSH
104195: LD_INT 20
104197: PUSH
104198: LD_INT 30
104200: PUSH
104201: LD_INT 40
104203: PUSH
104204: LD_INT 50
104206: PUSH
104207: LD_INT 60
104209: PUSH
104210: LD_INT 70
104212: PUSH
104213: LD_INT 80
104215: PUSH
104216: LD_INT 90
104218: PUSH
104219: LD_INT 100
104221: PUSH
104222: LD_INT 110
104224: PUSH
104225: LD_INT 120
104227: PUSH
104228: LD_INT 130
104230: PUSH
104231: LD_INT 140
104233: PUSH
104234: LD_INT 150
104236: PUSH
104237: EMPTY
104238: LIST
104239: LIST
104240: LIST
104241: LIST
104242: LIST
104243: LIST
104244: LIST
104245: LIST
104246: LIST
104247: LIST
104248: LIST
104249: LIST
104250: LIST
104251: LIST
104252: LIST
104253: PUSH
104254: LD_INT 1
104256: PPUSH
104257: LD_INT 15
104259: PPUSH
104260: CALL_OW 12
104264: ARRAY
104265: ST_TO_ADDR
// if ValidHex ( x , y ) then
104266: LD_VAR 0 3
104270: PPUSH
104271: LD_VAR 0 4
104275: PPUSH
104276: CALL_OW 488
104280: IFFALSE 104303
// begin result := [ x , y ] ;
104282: LD_ADDR_VAR 0 1
104286: PUSH
104287: LD_VAR 0 3
104291: PUSH
104292: LD_VAR 0 4
104296: PUSH
104297: EMPTY
104298: LIST
104299: LIST
104300: ST_TO_ADDR
// break ;
104301: GO 104305
// end ; end ;
104303: GO 104105
104305: POP
104306: POP
// if result then
104307: LD_VAR 0 1
104311: IFFALSE 104371
// begin ToLua ( playSibBomb() ) ;
104313: LD_STRING playSibBomb()
104315: PPUSH
104316: CALL_OW 559
// wait ( 0 0$14 ) ;
104320: LD_INT 490
104322: PPUSH
104323: CALL_OW 67
// CenterNowOnXY ( result [ 1 ] , result [ 2 ] ) ;
104327: LD_VAR 0 1
104331: PUSH
104332: LD_INT 1
104334: ARRAY
104335: PPUSH
104336: LD_VAR 0 1
104340: PUSH
104341: LD_INT 2
104343: ARRAY
104344: PPUSH
104345: CALL_OW 86
// SendSiberiteRocket ( result [ 1 ] , result [ 2 ] ) ;
104349: LD_VAR 0 1
104353: PUSH
104354: LD_INT 1
104356: ARRAY
104357: PPUSH
104358: LD_VAR 0 1
104362: PUSH
104363: LD_INT 2
104365: ARRAY
104366: PPUSH
104367: CALL_OW 429
// end ; end ;
104371: LD_VAR 0 1
104375: RET
// every 0 0$1 trigger StreamModeActive and sReset do
104376: LD_EXP 126
104380: PUSH
104381: LD_EXP 148
104385: AND
104386: IFFALSE 104398
104388: GO 104390
104390: DISABLE
// YouLost (  ) ;
104391: LD_STRING 
104393: PPUSH
104394: CALL_OW 104
104398: END
// every 0 0$1 trigger StreamModeActive and sFog do
104399: LD_EXP 126
104403: PUSH
104404: LD_EXP 147
104408: AND
104409: IFFALSE 104423
104411: GO 104413
104413: DISABLE
// FogOff ( your_side ) ;
104414: LD_OWVAR 2
104418: PPUSH
104419: CALL_OW 344
104423: END
// every 0 0$1 trigger StreamModeActive and sSun do
104424: LD_EXP 126
104428: PUSH
104429: LD_EXP 149
104433: AND
104434: IFFALSE 104462
104436: GO 104438
104438: DISABLE
// begin solar_recharge_percent := 0 ;
104439: LD_ADDR_OWVAR 79
104443: PUSH
104444: LD_INT 0
104446: ST_TO_ADDR
// wait ( 5 5$00 ) ;
104447: LD_INT 10500
104449: PPUSH
104450: CALL_OW 67
// solar_recharge_percent := 100 ;
104454: LD_ADDR_OWVAR 79
104458: PUSH
104459: LD_INT 100
104461: ST_TO_ADDR
// end ;
104462: END
// every 0 0$1 trigger StreamModeActive and sKamikadze do var i , un , tmp ;
104463: LD_EXP 126
104467: PUSH
104468: LD_EXP 150
104472: AND
104473: IFFALSE 104712
104475: GO 104477
104477: DISABLE
104478: LD_INT 0
104480: PPUSH
104481: PPUSH
104482: PPUSH
// begin tmp := [ ] ;
104483: LD_ADDR_VAR 0 3
104487: PUSH
104488: EMPTY
104489: ST_TO_ADDR
// for i := 1 to 6 do
104490: LD_ADDR_VAR 0 1
104494: PUSH
104495: DOUBLE
104496: LD_INT 1
104498: DEC
104499: ST_TO_ADDR
104500: LD_INT 6
104502: PUSH
104503: FOR_TO
104504: IFFALSE 104609
// begin uc_nation := nation_nature ;
104506: LD_ADDR_OWVAR 21
104510: PUSH
104511: LD_INT 0
104513: ST_TO_ADDR
// uc_side := 0 ;
104514: LD_ADDR_OWVAR 20
104518: PUSH
104519: LD_INT 0
104521: ST_TO_ADDR
// hc_attr := [ 12 , 12 ] ;
104522: LD_ADDR_OWVAR 29
104526: PUSH
104527: LD_INT 12
104529: PUSH
104530: LD_INT 12
104532: PUSH
104533: EMPTY
104534: LIST
104535: LIST
104536: ST_TO_ADDR
// hc_agressivity := 20 ;
104537: LD_ADDR_OWVAR 35
104541: PUSH
104542: LD_INT 20
104544: ST_TO_ADDR
// hc_class := class_apeman_kamikaze ;
104545: LD_ADDR_OWVAR 28
104549: PUSH
104550: LD_INT 17
104552: ST_TO_ADDR
// hc_gallery :=  ;
104553: LD_ADDR_OWVAR 33
104557: PUSH
104558: LD_STRING 
104560: ST_TO_ADDR
// hc_name :=  ;
104561: LD_ADDR_OWVAR 26
104565: PUSH
104566: LD_STRING 
104568: ST_TO_ADDR
// un := CreateHuman ;
104569: LD_ADDR_VAR 0 2
104573: PUSH
104574: CALL_OW 44
104578: ST_TO_ADDR
// PlaceUnitAnyWhere ( un , true ) ;
104579: LD_VAR 0 2
104583: PPUSH
104584: LD_INT 1
104586: PPUSH
104587: CALL_OW 51
// tmp := tmp ^ un ;
104591: LD_ADDR_VAR 0 3
104595: PUSH
104596: LD_VAR 0 3
104600: PUSH
104601: LD_VAR 0 2
104605: ADD
104606: ST_TO_ADDR
// end ;
104607: GO 104503
104609: POP
104610: POP
// repeat wait ( 0 0$1 ) ;
104611: LD_INT 35
104613: PPUSH
104614: CALL_OW 67
// for un in tmp do
104618: LD_ADDR_VAR 0 2
104622: PUSH
104623: LD_VAR 0 3
104627: PUSH
104628: FOR_IN
104629: IFFALSE 104703
// begin if IsDead ( un ) then
104631: LD_VAR 0 2
104635: PPUSH
104636: CALL_OW 301
104640: IFFALSE 104660
// begin tmp := tmp diff un ;
104642: LD_ADDR_VAR 0 3
104646: PUSH
104647: LD_VAR 0 3
104651: PUSH
104652: LD_VAR 0 2
104656: DIFF
104657: ST_TO_ADDR
// continue ;
104658: GO 104628
// end ; ComAttackUnit ( un , NearestUnitToUnit ( FilterAllUnits ( [ f_not , [ f_side , 0 ] ] ) , un ) ) ;
104660: LD_VAR 0 2
104664: PPUSH
104665: LD_INT 3
104667: PUSH
104668: LD_INT 22
104670: PUSH
104671: LD_INT 0
104673: PUSH
104674: EMPTY
104675: LIST
104676: LIST
104677: PUSH
104678: EMPTY
104679: LIST
104680: LIST
104681: PPUSH
104682: CALL_OW 69
104686: PPUSH
104687: LD_VAR 0 2
104691: PPUSH
104692: CALL_OW 74
104696: PPUSH
104697: CALL_OW 115
// end ;
104701: GO 104628
104703: POP
104704: POP
// until not tmp ;
104705: LD_VAR 0 3
104709: NOT
104710: IFFALSE 104611
// end ;
104712: PPOPN 3
104714: END
// every 0 0$1 trigger StreamModeActive and sTroll do
104715: LD_EXP 126
104719: PUSH
104720: LD_EXP 151
104724: AND
104725: IFFALSE 104779
104727: GO 104729
104729: DISABLE
// begin ToLua ( displayTroll(); ) ;
104730: LD_STRING displayTroll();
104732: PPUSH
104733: CALL_OW 559
// wait ( 3 3$00 ) ;
104737: LD_INT 6300
104739: PPUSH
104740: CALL_OW 67
// ToLua ( hideTroll(); ) ;
104744: LD_STRING hideTroll();
104746: PPUSH
104747: CALL_OW 559
// wait ( 1 1$00 ) ;
104751: LD_INT 2100
104753: PPUSH
104754: CALL_OW 67
// ToLua ( displayTroll(); ) ;
104758: LD_STRING displayTroll();
104760: PPUSH
104761: CALL_OW 559
// wait ( 1 1$00 ) ;
104765: LD_INT 2100
104767: PPUSH
104768: CALL_OW 67
// ToLua ( hideTroll(); ) ;
104772: LD_STRING hideTroll();
104774: PPUSH
104775: CALL_OW 559
// end ;
104779: END
// every 0 0$1 trigger StreamModeActive and sSlow do var p ;
104780: LD_EXP 126
104784: PUSH
104785: LD_EXP 152
104789: AND
104790: IFFALSE 104853
104792: GO 104794
104794: DISABLE
104795: LD_INT 0
104797: PPUSH
// begin p := 0 ;
104798: LD_ADDR_VAR 0 1
104802: PUSH
104803: LD_INT 0
104805: ST_TO_ADDR
// repeat game_speed := 1 ;
104806: LD_ADDR_OWVAR 65
104810: PUSH
104811: LD_INT 1
104813: ST_TO_ADDR
// wait ( 0 0$1 ) ;
104814: LD_INT 35
104816: PPUSH
104817: CALL_OW 67
// p := p + 1 ;
104821: LD_ADDR_VAR 0 1
104825: PUSH
104826: LD_VAR 0 1
104830: PUSH
104831: LD_INT 1
104833: PLUS
104834: ST_TO_ADDR
// until p >= 60 ;
104835: LD_VAR 0 1
104839: PUSH
104840: LD_INT 60
104842: GREATEREQUAL
104843: IFFALSE 104806
// game_speed := 4 ;
104845: LD_ADDR_OWVAR 65
104849: PUSH
104850: LD_INT 4
104852: ST_TO_ADDR
// end ;
104853: PPOPN 1
104855: END
// every 0 0$1 trigger StreamModeActive and sLack do var depot , base ;
104856: LD_EXP 126
104860: PUSH
104861: LD_EXP 153
104865: AND
104866: IFFALSE 105012
104868: GO 104870
104870: DISABLE
104871: LD_INT 0
104873: PPUSH
104874: PPUSH
// begin depot := FilterAllUnits ( [ [ f_side , your_side ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ] ) ;
104875: LD_ADDR_VAR 0 1
104879: PUSH
104880: LD_INT 22
104882: PUSH
104883: LD_OWVAR 2
104887: PUSH
104888: EMPTY
104889: LIST
104890: LIST
104891: PUSH
104892: LD_INT 2
104894: PUSH
104895: LD_INT 30
104897: PUSH
104898: LD_INT 0
104900: PUSH
104901: EMPTY
104902: LIST
104903: LIST
104904: PUSH
104905: LD_INT 30
104907: PUSH
104908: LD_INT 1
104910: PUSH
104911: EMPTY
104912: LIST
104913: LIST
104914: PUSH
104915: EMPTY
104916: LIST
104917: LIST
104918: LIST
104919: PUSH
104920: EMPTY
104921: LIST
104922: LIST
104923: PPUSH
104924: CALL_OW 69
104928: ST_TO_ADDR
// if not depot then
104929: LD_VAR 0 1
104933: NOT
104934: IFFALSE 104938
// exit ;
104936: GO 105012
// base := GetBase ( depot [ rand ( 1 , depot ) ] ) ;
104938: LD_ADDR_VAR 0 2
104942: PUSH
104943: LD_VAR 0 1
104947: PUSH
104948: LD_INT 1
104950: PPUSH
104951: LD_VAR 0 1
104955: PPUSH
104956: CALL_OW 12
104960: ARRAY
104961: PPUSH
104962: CALL_OW 274
104966: ST_TO_ADDR
// SetResourceType ( base , mat_cans , 0 ) ;
104967: LD_VAR 0 2
104971: PPUSH
104972: LD_INT 1
104974: PPUSH
104975: LD_INT 0
104977: PPUSH
104978: CALL_OW 277
// SetResourceType ( base , mat_oil , 0 ) ;
104982: LD_VAR 0 2
104986: PPUSH
104987: LD_INT 2
104989: PPUSH
104990: LD_INT 0
104992: PPUSH
104993: CALL_OW 277
// SetResourceType ( base , mat_siberit , 0 ) ;
104997: LD_VAR 0 2
105001: PPUSH
105002: LD_INT 3
105004: PPUSH
105005: LD_INT 0
105007: PPUSH
105008: CALL_OW 277
// end ;
105012: PPOPN 2
105014: END
// every 0 0$1 trigger StreamModeActive and sWound do var tmp ;
105015: LD_EXP 126
105019: PUSH
105020: LD_EXP 154
105024: AND
105025: IFFALSE 105122
105027: GO 105029
105029: DISABLE
105030: LD_INT 0
105032: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_type , unit_human ] , [ f_not , [ f_nation , 0 ] ] ] ) ;
105033: LD_ADDR_VAR 0 1
105037: PUSH
105038: LD_INT 22
105040: PUSH
105041: LD_OWVAR 2
105045: PUSH
105046: EMPTY
105047: LIST
105048: LIST
105049: PUSH
105050: LD_INT 21
105052: PUSH
105053: LD_INT 1
105055: PUSH
105056: EMPTY
105057: LIST
105058: LIST
105059: PUSH
105060: LD_INT 3
105062: PUSH
105063: LD_INT 23
105065: PUSH
105066: LD_INT 0
105068: PUSH
105069: EMPTY
105070: LIST
105071: LIST
105072: PUSH
105073: EMPTY
105074: LIST
105075: LIST
105076: PUSH
105077: EMPTY
105078: LIST
105079: LIST
105080: LIST
105081: PPUSH
105082: CALL_OW 69
105086: ST_TO_ADDR
// if not tmp then
105087: LD_VAR 0 1
105091: NOT
105092: IFFALSE 105096
// exit ;
105094: GO 105122
// SetLives ( tmp [ rand ( 1 , tmp ) ] , 200 ) ;
105096: LD_VAR 0 1
105100: PUSH
105101: LD_INT 1
105103: PPUSH
105104: LD_VAR 0 1
105108: PPUSH
105109: CALL_OW 12
105113: ARRAY
105114: PPUSH
105115: LD_INT 200
105117: PPUSH
105118: CALL_OW 234
// end ;
105122: PPOPN 1
105124: END
// every 0 0$1 trigger StreamModeActive and sTank do var tmp ;
105125: LD_EXP 126
105129: PUSH
105130: LD_EXP 155
105134: AND
105135: IFFALSE 105214
105137: GO 105139
105139: DISABLE
105140: LD_INT 0
105142: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_type , unit_vehicle ] ] ) ;
105143: LD_ADDR_VAR 0 1
105147: PUSH
105148: LD_INT 22
105150: PUSH
105151: LD_OWVAR 2
105155: PUSH
105156: EMPTY
105157: LIST
105158: LIST
105159: PUSH
105160: LD_INT 21
105162: PUSH
105163: LD_INT 2
105165: PUSH
105166: EMPTY
105167: LIST
105168: LIST
105169: PUSH
105170: EMPTY
105171: LIST
105172: LIST
105173: PPUSH
105174: CALL_OW 69
105178: ST_TO_ADDR
// if not tmp then
105179: LD_VAR 0 1
105183: NOT
105184: IFFALSE 105188
// exit ;
105186: GO 105214
// SetLives ( tmp [ rand ( 1 , tmp ) ] , 60 ) ;
105188: LD_VAR 0 1
105192: PUSH
105193: LD_INT 1
105195: PPUSH
105196: LD_VAR 0 1
105200: PPUSH
105201: CALL_OW 12
105205: ARRAY
105206: PPUSH
105207: LD_INT 60
105209: PPUSH
105210: CALL_OW 234
// end ;
105214: PPOPN 1
105216: END
// every 0 0$1 trigger StreamModeActive and sRemote do var tmp , i ;
105217: LD_EXP 126
105221: PUSH
105222: LD_EXP 156
105226: AND
105227: IFFALSE 105326
105229: GO 105231
105231: DISABLE
105232: LD_INT 0
105234: PPUSH
105235: PPUSH
// begin enable ;
105236: ENABLE
// tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_linked ] , [ f_control , control_remote ] ] ) ;
105237: LD_ADDR_VAR 0 1
105241: PUSH
105242: LD_INT 22
105244: PUSH
105245: LD_OWVAR 2
105249: PUSH
105250: EMPTY
105251: LIST
105252: LIST
105253: PUSH
105254: LD_INT 61
105256: PUSH
105257: EMPTY
105258: LIST
105259: PUSH
105260: LD_INT 33
105262: PUSH
105263: LD_INT 2
105265: PUSH
105266: EMPTY
105267: LIST
105268: LIST
105269: PUSH
105270: EMPTY
105271: LIST
105272: LIST
105273: LIST
105274: PPUSH
105275: CALL_OW 69
105279: ST_TO_ADDR
// if not tmp then
105280: LD_VAR 0 1
105284: NOT
105285: IFFALSE 105289
// exit ;
105287: GO 105326
// for i in tmp do
105289: LD_ADDR_VAR 0 2
105293: PUSH
105294: LD_VAR 0 1
105298: PUSH
105299: FOR_IN
105300: IFFALSE 105324
// if IsControledBy ( i ) then
105302: LD_VAR 0 2
105306: PPUSH
105307: CALL_OW 312
105311: IFFALSE 105322
// ComUnlink ( i ) ;
105313: LD_VAR 0 2
105317: PPUSH
105318: CALL_OW 136
105322: GO 105299
105324: POP
105325: POP
// end ;
105326: PPOPN 2
105328: END
// every 0 0$1 trigger StreamModeActive and sPowell do var i , un ;
105329: LD_EXP 126
105333: PUSH
105334: LD_EXP 157
105338: AND
105339: IFFALSE 105479
105341: GO 105343
105343: DISABLE
105344: LD_INT 0
105346: PPUSH
105347: PPUSH
// begin ToLua ( displayPowell(); ) ;
105348: LD_STRING displayPowell();
105350: PPUSH
105351: CALL_OW 559
// uc_side := 0 ;
105355: LD_ADDR_OWVAR 20
105359: PUSH
105360: LD_INT 0
105362: ST_TO_ADDR
// uc_nation := 2 ;
105363: LD_ADDR_OWVAR 21
105367: PUSH
105368: LD_INT 2
105370: ST_TO_ADDR
// vc_chassis := ar_half_tracked ;
105371: LD_ADDR_OWVAR 37
105375: PUSH
105376: LD_INT 14
105378: ST_TO_ADDR
// vc_engine := engine_siberite ;
105379: LD_ADDR_OWVAR 39
105383: PUSH
105384: LD_INT 3
105386: ST_TO_ADDR
// vc_control := control_apeman ;
105387: LD_ADDR_OWVAR 38
105391: PUSH
105392: LD_INT 5
105394: ST_TO_ADDR
// vc_weapon := ar_selfpropelled_bomb ;
105395: LD_ADDR_OWVAR 40
105399: PUSH
105400: LD_INT 29
105402: ST_TO_ADDR
// un := CreateVehicle ;
105403: LD_ADDR_VAR 0 2
105407: PUSH
105408: CALL_OW 45
105412: ST_TO_ADDR
// PlaceUnitAnywhere ( un , true ) ;
105413: LD_VAR 0 2
105417: PPUSH
105418: LD_INT 1
105420: PPUSH
105421: CALL_OW 51
// repeat wait ( 0 0$1 ) ;
105425: LD_INT 35
105427: PPUSH
105428: CALL_OW 67
// ComAttackUnit ( un , NearestUnitToUnit ( FilterAllUnits ( [ f_side , your_side ] ) , un ) ) ;
105432: LD_VAR 0 2
105436: PPUSH
105437: LD_INT 22
105439: PUSH
105440: LD_OWVAR 2
105444: PUSH
105445: EMPTY
105446: LIST
105447: LIST
105448: PPUSH
105449: CALL_OW 69
105453: PPUSH
105454: LD_VAR 0 2
105458: PPUSH
105459: CALL_OW 74
105463: PPUSH
105464: CALL_OW 115
// until IsDead ( un ) ;
105468: LD_VAR 0 2
105472: PPUSH
105473: CALL_OW 301
105477: IFFALSE 105425
// end ;
105479: PPOPN 2
105481: END
// every 0 0$1 trigger StreamModeActive and sStu do
105482: LD_EXP 126
105486: PUSH
105487: LD_EXP 165
105491: AND
105492: IFFALSE 105508
105494: GO 105496
105496: DISABLE
// begin ToLua ( displayStucuk(); ) ;
105497: LD_STRING displayStucuk();
105499: PPUSH
105500: CALL_OW 559
// ResetFog ;
105504: CALL_OW 335
// end ;
105508: END
// every 0 0$1 trigger StreamModeActive and sBetray do var un , tmp ;
105509: LD_EXP 126
105513: PUSH
105514: LD_EXP 158
105518: AND
105519: IFFALSE 105660
105521: GO 105523
105523: DISABLE
105524: LD_INT 0
105526: PPUSH
105527: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_type , unit_human ] ] ) ;
105528: LD_ADDR_VAR 0 2
105532: PUSH
105533: LD_INT 22
105535: PUSH
105536: LD_OWVAR 2
105540: PUSH
105541: EMPTY
105542: LIST
105543: LIST
105544: PUSH
105545: LD_INT 21
105547: PUSH
105548: LD_INT 1
105550: PUSH
105551: EMPTY
105552: LIST
105553: LIST
105554: PUSH
105555: EMPTY
105556: LIST
105557: LIST
105558: PPUSH
105559: CALL_OW 69
105563: ST_TO_ADDR
// if not tmp then
105564: LD_VAR 0 2
105568: NOT
105569: IFFALSE 105573
// exit ;
105571: GO 105660
// un := tmp [ rand ( 1 , tmp ) ] ;
105573: LD_ADDR_VAR 0 1
105577: PUSH
105578: LD_VAR 0 2
105582: PUSH
105583: LD_INT 1
105585: PPUSH
105586: LD_VAR 0 2
105590: PPUSH
105591: CALL_OW 12
105595: ARRAY
105596: ST_TO_ADDR
// SetSide ( un , 0 ) ;
105597: LD_VAR 0 1
105601: PPUSH
105602: LD_INT 0
105604: PPUSH
105605: CALL_OW 235
// ComAttackUnit ( un , NearestUnitToUnit ( all_units diff un , un ) ) ;
105609: LD_VAR 0 1
105613: PPUSH
105614: LD_OWVAR 3
105618: PUSH
105619: LD_VAR 0 1
105623: DIFF
105624: PPUSH
105625: LD_VAR 0 1
105629: PPUSH
105630: CALL_OW 74
105634: PPUSH
105635: CALL_OW 115
// wait ( 0 0$20 ) ;
105639: LD_INT 700
105641: PPUSH
105642: CALL_OW 67
// SetSide ( un , your_side ) ;
105646: LD_VAR 0 1
105650: PPUSH
105651: LD_OWVAR 2
105655: PPUSH
105656: CALL_OW 235
// end ;
105660: PPOPN 2
105662: END
// every 0 0$1 trigger StreamModeActive and sContamin do var depot ;
105663: LD_EXP 126
105667: PUSH
105668: LD_EXP 159
105672: AND
105673: IFFALSE 105779
105675: GO 105677
105677: DISABLE
105678: LD_INT 0
105680: PPUSH
// begin depot := FilterAllUnits ( [ [ f_side , your_side ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ] ) ;
105681: LD_ADDR_VAR 0 1
105685: PUSH
105686: LD_INT 22
105688: PUSH
105689: LD_OWVAR 2
105693: PUSH
105694: EMPTY
105695: LIST
105696: LIST
105697: PUSH
105698: LD_INT 2
105700: PUSH
105701: LD_INT 30
105703: PUSH
105704: LD_INT 0
105706: PUSH
105707: EMPTY
105708: LIST
105709: LIST
105710: PUSH
105711: LD_INT 30
105713: PUSH
105714: LD_INT 1
105716: PUSH
105717: EMPTY
105718: LIST
105719: LIST
105720: PUSH
105721: EMPTY
105722: LIST
105723: LIST
105724: LIST
105725: PUSH
105726: EMPTY
105727: LIST
105728: LIST
105729: PPUSH
105730: CALL_OW 69
105734: ST_TO_ADDR
// if not depot then
105735: LD_VAR 0 1
105739: NOT
105740: IFFALSE 105744
// exit ;
105742: GO 105779
// ArtContamination ( GetX ( depot [ 1 ] ) , GetY ( depot [ 1 ] ) , 70 ) ;
105744: LD_VAR 0 1
105748: PUSH
105749: LD_INT 1
105751: ARRAY
105752: PPUSH
105753: CALL_OW 250
105757: PPUSH
105758: LD_VAR 0 1
105762: PUSH
105763: LD_INT 1
105765: ARRAY
105766: PPUSH
105767: CALL_OW 251
105771: PPUSH
105772: LD_INT 70
105774: PPUSH
105775: CALL_OW 495
// end ;
105779: PPOPN 1
105781: END
// every 0 0$1 trigger StreamModeActive and sTeleport do var i , x , y , d , tmp ;
105782: LD_EXP 126
105786: PUSH
105787: LD_EXP 160
105791: AND
105792: IFFALSE 106003
105794: GO 105796
105796: DISABLE
105797: LD_INT 0
105799: PPUSH
105800: PPUSH
105801: PPUSH
105802: PPUSH
105803: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_type , unit_human ] ] ) ;
105804: LD_ADDR_VAR 0 5
105808: PUSH
105809: LD_INT 22
105811: PUSH
105812: LD_OWVAR 2
105816: PUSH
105817: EMPTY
105818: LIST
105819: LIST
105820: PUSH
105821: LD_INT 21
105823: PUSH
105824: LD_INT 1
105826: PUSH
105827: EMPTY
105828: LIST
105829: LIST
105830: PUSH
105831: EMPTY
105832: LIST
105833: LIST
105834: PPUSH
105835: CALL_OW 69
105839: ST_TO_ADDR
// if not tmp then
105840: LD_VAR 0 5
105844: NOT
105845: IFFALSE 105849
// exit ;
105847: GO 106003
// for i in tmp do
105849: LD_ADDR_VAR 0 1
105853: PUSH
105854: LD_VAR 0 5
105858: PUSH
105859: FOR_IN
105860: IFFALSE 106001
// begin d := rand ( 0 , 5 ) ;
105862: LD_ADDR_VAR 0 4
105866: PUSH
105867: LD_INT 0
105869: PPUSH
105870: LD_INT 5
105872: PPUSH
105873: CALL_OW 12
105877: ST_TO_ADDR
// x := ShiftX ( GetX ( i ) , d , rand ( 3 , 12 ) ) ;
105878: LD_ADDR_VAR 0 2
105882: PUSH
105883: LD_VAR 0 1
105887: PPUSH
105888: CALL_OW 250
105892: PPUSH
105893: LD_VAR 0 4
105897: PPUSH
105898: LD_INT 3
105900: PPUSH
105901: LD_INT 12
105903: PPUSH
105904: CALL_OW 12
105908: PPUSH
105909: CALL_OW 272
105913: ST_TO_ADDR
// y := ShiftY ( GetY ( i ) , d , rand ( 3 , 12 ) ) ;
105914: LD_ADDR_VAR 0 3
105918: PUSH
105919: LD_VAR 0 1
105923: PPUSH
105924: CALL_OW 251
105928: PPUSH
105929: LD_VAR 0 4
105933: PPUSH
105934: LD_INT 3
105936: PPUSH
105937: LD_INT 12
105939: PPUSH
105940: CALL_OW 12
105944: PPUSH
105945: CALL_OW 273
105949: ST_TO_ADDR
// if ValidHex ( x , y ) then
105950: LD_VAR 0 2
105954: PPUSH
105955: LD_VAR 0 3
105959: PPUSH
105960: CALL_OW 488
105964: IFFALSE 105999
// TeleportUnit ( i , x , y , rand ( 3 , 6 ) , true ) ;
105966: LD_VAR 0 1
105970: PPUSH
105971: LD_VAR 0 2
105975: PPUSH
105976: LD_VAR 0 3
105980: PPUSH
105981: LD_INT 3
105983: PPUSH
105984: LD_INT 6
105986: PPUSH
105987: CALL_OW 12
105991: PPUSH
105992: LD_INT 1
105994: PPUSH
105995: CALL_OW 483
// end ;
105999: GO 105859
106001: POP
106002: POP
// end ;
106003: PPOPN 5
106005: END
// every 0 0$1 trigger StreamModeActive and sOil do var i , tmp ;
106006: LD_EXP 126
106010: PUSH
106011: LD_EXP 161
106015: AND
106016: IFFALSE 106110
106018: GO 106020
106020: DISABLE
106021: LD_INT 0
106023: PPUSH
106024: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_engine , engine_combustion ] , [ f_type , unit_vehicle ] ] ) ;
106025: LD_ADDR_VAR 0 2
106029: PUSH
106030: LD_INT 22
106032: PUSH
106033: LD_OWVAR 2
106037: PUSH
106038: EMPTY
106039: LIST
106040: LIST
106041: PUSH
106042: LD_INT 32
106044: PUSH
106045: LD_INT 1
106047: PUSH
106048: EMPTY
106049: LIST
106050: LIST
106051: PUSH
106052: LD_INT 21
106054: PUSH
106055: LD_INT 2
106057: PUSH
106058: EMPTY
106059: LIST
106060: LIST
106061: PUSH
106062: EMPTY
106063: LIST
106064: LIST
106065: LIST
106066: PPUSH
106067: CALL_OW 69
106071: ST_TO_ADDR
// if not tmp then
106072: LD_VAR 0 2
106076: NOT
106077: IFFALSE 106081
// exit ;
106079: GO 106110
// for i in tmp do
106081: LD_ADDR_VAR 0 1
106085: PUSH
106086: LD_VAR 0 2
106090: PUSH
106091: FOR_IN
106092: IFFALSE 106108
// SetFuel ( i , 0 ) ;
106094: LD_VAR 0 1
106098: PPUSH
106099: LD_INT 0
106101: PPUSH
106102: CALL_OW 240
106106: GO 106091
106108: POP
106109: POP
// end ;
106110: PPOPN 2
106112: END
// every 0 0$1 trigger StreamModeActive and sOilTower do var tmp ;
106113: LD_EXP 126
106117: PUSH
106118: LD_EXP 162
106122: AND
106123: IFFALSE 106189
106125: GO 106127
106127: DISABLE
106128: LD_INT 0
106130: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_btype , b_oil_mine ] ] ) ;
106131: LD_ADDR_VAR 0 1
106135: PUSH
106136: LD_INT 22
106138: PUSH
106139: LD_OWVAR 2
106143: PUSH
106144: EMPTY
106145: LIST
106146: LIST
106147: PUSH
106148: LD_INT 30
106150: PUSH
106151: LD_INT 29
106153: PUSH
106154: EMPTY
106155: LIST
106156: LIST
106157: PUSH
106158: EMPTY
106159: LIST
106160: LIST
106161: PPUSH
106162: CALL_OW 69
106166: ST_TO_ADDR
// if not tmp then
106167: LD_VAR 0 1
106171: NOT
106172: IFFALSE 106176
// exit ;
106174: GO 106189
// DestroyUnit ( tmp [ 1 ] ) ;
106176: LD_VAR 0 1
106180: PUSH
106181: LD_INT 1
106183: ARRAY
106184: PPUSH
106185: CALL_OW 65
// end ;
106189: PPOPN 1
106191: END
// every 0 0$1 trigger StreamModeActive and sSheik do var un ;
106192: LD_EXP 126
106196: PUSH
106197: LD_EXP 164
106201: AND
106202: IFFALSE 106331
106204: GO 106206
106206: DISABLE
106207: LD_INT 0
106209: PPUSH
// begin uc_side := 0 ;
106210: LD_ADDR_OWVAR 20
106214: PUSH
106215: LD_INT 0
106217: ST_TO_ADDR
// uc_nation := nation_arabian ;
106218: LD_ADDR_OWVAR 21
106222: PUSH
106223: LD_INT 2
106225: ST_TO_ADDR
// hc_gallery :=  ;
106226: LD_ADDR_OWVAR 33
106230: PUSH
106231: LD_STRING 
106233: ST_TO_ADDR
// hc_name :=  ;
106234: LD_ADDR_OWVAR 26
106238: PUSH
106239: LD_STRING 
106241: ST_TO_ADDR
// PrepareHuman ( sex_male , class_desert_warior , 10 ) ;
106242: LD_INT 1
106244: PPUSH
106245: LD_INT 11
106247: PPUSH
106248: LD_INT 10
106250: PPUSH
106251: CALL_OW 380
// un := CreateHuman ;
106255: LD_ADDR_VAR 0 1
106259: PUSH
106260: CALL_OW 44
106264: ST_TO_ADDR
// PlaceUnitAnywhere ( un , true ) ;
106265: LD_VAR 0 1
106269: PPUSH
106270: LD_INT 1
106272: PPUSH
106273: CALL_OW 51
// repeat wait ( 0 0$1 ) ;
106277: LD_INT 35
106279: PPUSH
106280: CALL_OW 67
// ComAttackUnit ( un , NearestUnitToUnit ( FilterAllUnits ( [ f_side , your_side ] ) , un ) ) ;
106284: LD_VAR 0 1
106288: PPUSH
106289: LD_INT 22
106291: PUSH
106292: LD_OWVAR 2
106296: PUSH
106297: EMPTY
106298: LIST
106299: LIST
106300: PPUSH
106301: CALL_OW 69
106305: PPUSH
106306: LD_VAR 0 1
106310: PPUSH
106311: CALL_OW 74
106315: PPUSH
106316: CALL_OW 115
// until IsDead ( un ) ;
106320: LD_VAR 0 1
106324: PPUSH
106325: CALL_OW 301
106329: IFFALSE 106277
// end ;
106331: PPOPN 1
106333: END
// every 0 0$1 trigger StreamModeActive and sEarthquake do
106334: LD_EXP 126
106338: PUSH
106339: LD_EXP 166
106343: AND
106344: IFFALSE 106356
106346: GO 106348
106348: DISABLE
// ToLua ( earthquake(getX(game), 0, 32) ) ;
106349: LD_STRING earthquake(getX(game), 0, 32)
106351: PPUSH
106352: CALL_OW 559
106356: END
// every 0 0$1 trigger StreamModeActive and sAI do var tmp ;
106357: LD_EXP 126
106361: PUSH
106362: LD_EXP 167
106366: AND
106367: IFFALSE 106458
106369: GO 106371
106371: DISABLE
106372: LD_INT 0
106374: PPUSH
// begin enable ;
106375: ENABLE
// tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_type , unit_vehicle ] , [ f_control , control_computer ] ] ) ;
106376: LD_ADDR_VAR 0 1
106380: PUSH
106381: LD_INT 22
106383: PUSH
106384: LD_OWVAR 2
106388: PUSH
106389: EMPTY
106390: LIST
106391: LIST
106392: PUSH
106393: LD_INT 21
106395: PUSH
106396: LD_INT 2
106398: PUSH
106399: EMPTY
106400: LIST
106401: LIST
106402: PUSH
106403: LD_INT 33
106405: PUSH
106406: LD_INT 3
106408: PUSH
106409: EMPTY
106410: LIST
106411: LIST
106412: PUSH
106413: EMPTY
106414: LIST
106415: LIST
106416: LIST
106417: PPUSH
106418: CALL_OW 69
106422: ST_TO_ADDR
// if not tmp then
106423: LD_VAR 0 1
106427: NOT
106428: IFFALSE 106432
// exit ;
106430: GO 106458
// SetLives ( tmp [ rand ( 1 , tmp ) ] , 1 ) ;
106432: LD_VAR 0 1
106436: PUSH
106437: LD_INT 1
106439: PPUSH
106440: LD_VAR 0 1
106444: PPUSH
106445: CALL_OW 12
106449: ARRAY
106450: PPUSH
106451: LD_INT 1
106453: PPUSH
106454: CALL_OW 234
// end ;
106458: PPOPN 1
106460: END
// every 0 0$1 trigger StreamModeActive and sBazooka do var i , un , tmp ;
106461: LD_EXP 126
106465: PUSH
106466: LD_EXP 168
106470: AND
106471: IFFALSE 106612
106473: GO 106475
106475: DISABLE
106476: LD_INT 0
106478: PPUSH
106479: PPUSH
106480: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_class , 1 ] ] ) ;
106481: LD_ADDR_VAR 0 3
106485: PUSH
106486: LD_INT 22
106488: PUSH
106489: LD_OWVAR 2
106493: PUSH
106494: EMPTY
106495: LIST
106496: LIST
106497: PUSH
106498: LD_INT 25
106500: PUSH
106501: LD_INT 1
106503: PUSH
106504: EMPTY
106505: LIST
106506: LIST
106507: PUSH
106508: EMPTY
106509: LIST
106510: LIST
106511: PPUSH
106512: CALL_OW 69
106516: ST_TO_ADDR
// if not tmp then
106517: LD_VAR 0 3
106521: NOT
106522: IFFALSE 106526
// exit ;
106524: GO 106612
// un := tmp [ rand ( 1 , tmp ) ] ;
106526: LD_ADDR_VAR 0 2
106530: PUSH
106531: LD_VAR 0 3
106535: PUSH
106536: LD_INT 1
106538: PPUSH
106539: LD_VAR 0 3
106543: PPUSH
106544: CALL_OW 12
106548: ARRAY
106549: ST_TO_ADDR
// if Crawls ( un ) then
106550: LD_VAR 0 2
106554: PPUSH
106555: CALL_OW 318
106559: IFFALSE 106570
// ComWalk ( un ) ;
106561: LD_VAR 0 2
106565: PPUSH
106566: CALL_OW 138
// SetClass ( un , class_bazooker ) ;
106570: LD_VAR 0 2
106574: PPUSH
106575: LD_INT 9
106577: PPUSH
106578: CALL_OW 336
// SetTech ( tech_tauRad , your_side , state_researched ) ;
106582: LD_INT 28
106584: PPUSH
106585: LD_OWVAR 2
106589: PPUSH
106590: LD_INT 2
106592: PPUSH
106593: CALL_OW 322
// SetTech ( tech_spacAnom , your_side , state_researched ) ;
106597: LD_INT 29
106599: PPUSH
106600: LD_OWVAR 2
106604: PPUSH
106605: LD_INT 2
106607: PPUSH
106608: CALL_OW 322
// end ;
106612: PPOPN 3
106614: END
// every 0 0$1 trigger StreamModeActive and sMortar do var i , un , tmp ;
106615: LD_EXP 126
106619: PUSH
106620: LD_EXP 169
106624: AND
106625: IFFALSE 106736
106627: GO 106629
106629: DISABLE
106630: LD_INT 0
106632: PPUSH
106633: PPUSH
106634: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_class , 1 ] ] ) ;
106635: LD_ADDR_VAR 0 3
106639: PUSH
106640: LD_INT 22
106642: PUSH
106643: LD_OWVAR 2
106647: PUSH
106648: EMPTY
106649: LIST
106650: LIST
106651: PUSH
106652: LD_INT 25
106654: PUSH
106655: LD_INT 1
106657: PUSH
106658: EMPTY
106659: LIST
106660: LIST
106661: PUSH
106662: EMPTY
106663: LIST
106664: LIST
106665: PPUSH
106666: CALL_OW 69
106670: ST_TO_ADDR
// if not tmp then
106671: LD_VAR 0 3
106675: NOT
106676: IFFALSE 106680
// exit ;
106678: GO 106736
// un := tmp [ rand ( 1 , tmp ) ] ;
106680: LD_ADDR_VAR 0 2
106684: PUSH
106685: LD_VAR 0 3
106689: PUSH
106690: LD_INT 1
106692: PPUSH
106693: LD_VAR 0 3
106697: PPUSH
106698: CALL_OW 12
106702: ARRAY
106703: ST_TO_ADDR
// if Crawls ( un ) then
106704: LD_VAR 0 2
106708: PPUSH
106709: CALL_OW 318
106713: IFFALSE 106724
// ComWalk ( un ) ;
106715: LD_VAR 0 2
106719: PPUSH
106720: CALL_OW 138
// SetClass ( un , class_mortar ) ;
106724: LD_VAR 0 2
106728: PPUSH
106729: LD_INT 8
106731: PPUSH
106732: CALL_OW 336
// end ;
106736: PPOPN 3
106738: END
// every 0 0$1 trigger StreamModeActive and sCargo do var i , tmp ;
106739: LD_EXP 126
106743: PUSH
106744: LD_EXP 170
106748: AND
106749: IFFALSE 106893
106751: GO 106753
106753: DISABLE
106754: LD_INT 0
106756: PPUSH
106757: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_type , unit_vehicle ] , [ f_or , [ f_weapon , us_cargo_bay ] , [ f_weapon , ru_cargo_bay ] , [ f_weapon , ar_cargo_bay ] ] ] ) ;
106758: LD_ADDR_VAR 0 2
106762: PUSH
106763: LD_INT 22
106765: PUSH
106766: LD_OWVAR 2
106770: PUSH
106771: EMPTY
106772: LIST
106773: LIST
106774: PUSH
106775: LD_INT 21
106777: PUSH
106778: LD_INT 2
106780: PUSH
106781: EMPTY
106782: LIST
106783: LIST
106784: PUSH
106785: LD_INT 2
106787: PUSH
106788: LD_INT 34
106790: PUSH
106791: LD_INT 12
106793: PUSH
106794: EMPTY
106795: LIST
106796: LIST
106797: PUSH
106798: LD_INT 34
106800: PUSH
106801: LD_INT 51
106803: PUSH
106804: EMPTY
106805: LIST
106806: LIST
106807: PUSH
106808: LD_INT 34
106810: PUSH
106811: LD_INT 32
106813: PUSH
106814: EMPTY
106815: LIST
106816: LIST
106817: PUSH
106818: EMPTY
106819: LIST
106820: LIST
106821: LIST
106822: LIST
106823: PUSH
106824: EMPTY
106825: LIST
106826: LIST
106827: LIST
106828: PPUSH
106829: CALL_OW 69
106833: ST_TO_ADDR
// if not tmp then
106834: LD_VAR 0 2
106838: NOT
106839: IFFALSE 106843
// exit ;
106841: GO 106893
// for i in tmp do
106843: LD_ADDR_VAR 0 1
106847: PUSH
106848: LD_VAR 0 2
106852: PUSH
106853: FOR_IN
106854: IFFALSE 106891
// if GetCargo ( i , mat_artifact ) = 0 then
106856: LD_VAR 0 1
106860: PPUSH
106861: LD_INT 4
106863: PPUSH
106864: CALL_OW 289
106868: PUSH
106869: LD_INT 0
106871: EQUAL
106872: IFFALSE 106889
// SetCargo ( i , mat_siberit , 100 ) ;
106874: LD_VAR 0 1
106878: PPUSH
106879: LD_INT 3
106881: PPUSH
106882: LD_INT 100
106884: PPUSH
106885: CALL_OW 290
106889: GO 106853
106891: POP
106892: POP
// end ;
106893: PPOPN 2
106895: END
// every 0 0$1 trigger StreamModeActive and sDLaser do var i , tmp ;
106896: LD_EXP 126
106900: PUSH
106901: LD_EXP 171
106905: AND
106906: IFFALSE 107089
106908: GO 106910
106910: DISABLE
106911: LD_INT 0
106913: PPUSH
106914: PPUSH
// begin tmp := FilterAllUnits ( [ f_side , your_side ] ) ;
106915: LD_ADDR_VAR 0 2
106919: PUSH
106920: LD_INT 22
106922: PUSH
106923: LD_OWVAR 2
106927: PUSH
106928: EMPTY
106929: LIST
106930: LIST
106931: PPUSH
106932: CALL_OW 69
106936: ST_TO_ADDR
// if not tmp then
106937: LD_VAR 0 2
106941: NOT
106942: IFFALSE 106946
// exit ;
106944: GO 107089
// for i := 1 to 2 do
106946: LD_ADDR_VAR 0 1
106950: PUSH
106951: DOUBLE
106952: LD_INT 1
106954: DEC
106955: ST_TO_ADDR
106956: LD_INT 2
106958: PUSH
106959: FOR_TO
106960: IFFALSE 107087
// begin uc_side := your_side ;
106962: LD_ADDR_OWVAR 20
106966: PUSH
106967: LD_OWVAR 2
106971: ST_TO_ADDR
// uc_nation := nation_american ;
106972: LD_ADDR_OWVAR 21
106976: PUSH
106977: LD_INT 1
106979: ST_TO_ADDR
// vc_chassis := us_morphling ;
106980: LD_ADDR_OWVAR 37
106984: PUSH
106985: LD_INT 5
106987: ST_TO_ADDR
// vc_engine := engine_siberite ;
106988: LD_ADDR_OWVAR 39
106992: PUSH
106993: LD_INT 3
106995: ST_TO_ADDR
// vc_control := control_computer ;
106996: LD_ADDR_OWVAR 38
107000: PUSH
107001: LD_INT 3
107003: ST_TO_ADDR
// vc_weapon := us_double_laser ;
107004: LD_ADDR_OWVAR 40
107008: PUSH
107009: LD_INT 10
107011: ST_TO_ADDR
// if not IsInUnit ( tmp [ 1 ] ) then
107012: LD_VAR 0 2
107016: PUSH
107017: LD_INT 1
107019: ARRAY
107020: PPUSH
107021: CALL_OW 310
107025: NOT
107026: IFFALSE 107073
// PlaceUnitXYR ( CreateVehicle , GetX ( tmp [ 1 ] ) , GetY ( tmp [ 1 ] ) , 12 , true ) else
107028: CALL_OW 45
107032: PPUSH
107033: LD_VAR 0 2
107037: PUSH
107038: LD_INT 1
107040: ARRAY
107041: PPUSH
107042: CALL_OW 250
107046: PPUSH
107047: LD_VAR 0 2
107051: PUSH
107052: LD_INT 1
107054: ARRAY
107055: PPUSH
107056: CALL_OW 251
107060: PPUSH
107061: LD_INT 12
107063: PPUSH
107064: LD_INT 1
107066: PPUSH
107067: CALL_OW 50
107071: GO 107085
// PlaceUnitAnywhere ( CreateVehicle , true ) ;
107073: CALL_OW 45
107077: PPUSH
107078: LD_INT 1
107080: PPUSH
107081: CALL_OW 51
// end ;
107085: GO 106959
107087: POP
107088: POP
// end ;
107089: PPOPN 2
107091: END
// every 0 0$1 trigger StreamModeActive and sExchange do var i , s1 , s2 , sk1 , sk2 , tmp ;
107092: LD_EXP 126
107096: PUSH
107097: LD_EXP 172
107101: AND
107102: IFFALSE 107324
107104: GO 107106
107106: DISABLE
107107: LD_INT 0
107109: PPUSH
107110: PPUSH
107111: PPUSH
107112: PPUSH
107113: PPUSH
107114: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_type , unit_human ] , [ f_not , [ f_nation , 0 ] ] ] ) ;
107115: LD_ADDR_VAR 0 6
107119: PUSH
107120: LD_INT 22
107122: PUSH
107123: LD_OWVAR 2
107127: PUSH
107128: EMPTY
107129: LIST
107130: LIST
107131: PUSH
107132: LD_INT 21
107134: PUSH
107135: LD_INT 1
107137: PUSH
107138: EMPTY
107139: LIST
107140: LIST
107141: PUSH
107142: LD_INT 3
107144: PUSH
107145: LD_INT 23
107147: PUSH
107148: LD_INT 0
107150: PUSH
107151: EMPTY
107152: LIST
107153: LIST
107154: PUSH
107155: EMPTY
107156: LIST
107157: LIST
107158: PUSH
107159: EMPTY
107160: LIST
107161: LIST
107162: LIST
107163: PPUSH
107164: CALL_OW 69
107168: ST_TO_ADDR
// if not tmp then
107169: LD_VAR 0 6
107173: NOT
107174: IFFALSE 107178
// exit ;
107176: GO 107324
// s1 := rand ( 1 , 4 ) ;
107178: LD_ADDR_VAR 0 2
107182: PUSH
107183: LD_INT 1
107185: PPUSH
107186: LD_INT 4
107188: PPUSH
107189: CALL_OW 12
107193: ST_TO_ADDR
// sk1 := GetSkill ( tmp [ 1 ] , s1 ) ;
107194: LD_ADDR_VAR 0 4
107198: PUSH
107199: LD_VAR 0 6
107203: PUSH
107204: LD_INT 1
107206: ARRAY
107207: PPUSH
107208: LD_VAR 0 2
107212: PPUSH
107213: CALL_OW 259
107217: ST_TO_ADDR
// if s1 = 1 then
107218: LD_VAR 0 2
107222: PUSH
107223: LD_INT 1
107225: EQUAL
107226: IFFALSE 107246
// s2 := rand ( 2 , 4 ) else
107228: LD_ADDR_VAR 0 3
107232: PUSH
107233: LD_INT 2
107235: PPUSH
107236: LD_INT 4
107238: PPUSH
107239: CALL_OW 12
107243: ST_TO_ADDR
107244: GO 107254
// s2 := 1 ;
107246: LD_ADDR_VAR 0 3
107250: PUSH
107251: LD_INT 1
107253: ST_TO_ADDR
// sk2 := GetSkill ( tmp [ 1 ] , s2 ) ;
107254: LD_ADDR_VAR 0 5
107258: PUSH
107259: LD_VAR 0 6
107263: PUSH
107264: LD_INT 1
107266: ARRAY
107267: PPUSH
107268: LD_VAR 0 3
107272: PPUSH
107273: CALL_OW 259
107277: ST_TO_ADDR
// SetSkill ( tmp [ 1 ] , s1 , sk2 ) ;
107278: LD_VAR 0 6
107282: PUSH
107283: LD_INT 1
107285: ARRAY
107286: PPUSH
107287: LD_VAR 0 2
107291: PPUSH
107292: LD_VAR 0 5
107296: PPUSH
107297: CALL_OW 237
// SetSkill ( tmp [ 1 ] , s2 , sk1 ) ;
107301: LD_VAR 0 6
107305: PUSH
107306: LD_INT 1
107308: ARRAY
107309: PPUSH
107310: LD_VAR 0 3
107314: PPUSH
107315: LD_VAR 0 4
107319: PPUSH
107320: CALL_OW 237
// end ;
107324: PPOPN 6
107326: END
// every 0 0$1 trigger StreamModeActive and sFac do var tmp ;
107327: LD_EXP 126
107331: PUSH
107332: LD_EXP 173
107336: AND
107337: IFFALSE 107416
107339: GO 107341
107341: DISABLE
107342: LD_INT 0
107344: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_btype , b_factory ] ] ) ;
107345: LD_ADDR_VAR 0 1
107349: PUSH
107350: LD_INT 22
107352: PUSH
107353: LD_OWVAR 2
107357: PUSH
107358: EMPTY
107359: LIST
107360: LIST
107361: PUSH
107362: LD_INT 30
107364: PUSH
107365: LD_INT 3
107367: PUSH
107368: EMPTY
107369: LIST
107370: LIST
107371: PUSH
107372: EMPTY
107373: LIST
107374: LIST
107375: PPUSH
107376: CALL_OW 69
107380: ST_TO_ADDR
// if not tmp then
107381: LD_VAR 0 1
107385: NOT
107386: IFFALSE 107390
// exit ;
107388: GO 107416
// SetLives ( tmp [ rand ( 1 , tmp ) ] , 1 ) ;
107390: LD_VAR 0 1
107394: PUSH
107395: LD_INT 1
107397: PPUSH
107398: LD_VAR 0 1
107402: PPUSH
107403: CALL_OW 12
107407: ARRAY
107408: PPUSH
107409: LD_INT 1
107411: PPUSH
107412: CALL_OW 234
// end ;
107416: PPOPN 1
107418: END
// every 0 0$1 trigger StreamModeActive and sPower do var i , tmp ;
107419: LD_EXP 126
107423: PUSH
107424: LD_EXP 174
107428: AND
107429: IFFALSE 107541
107431: GO 107433
107433: DISABLE
107434: LD_INT 0
107436: PPUSH
107437: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_or , [ f_btype , b_solar_power ] , [ f_btype , b_oil_power ] , [ f_btype , b_siberite_power ] ] ] ) ;
107438: LD_ADDR_VAR 0 2
107442: PUSH
107443: LD_INT 22
107445: PUSH
107446: LD_OWVAR 2
107450: PUSH
107451: EMPTY
107452: LIST
107453: LIST
107454: PUSH
107455: LD_INT 2
107457: PUSH
107458: LD_INT 30
107460: PUSH
107461: LD_INT 27
107463: PUSH
107464: EMPTY
107465: LIST
107466: LIST
107467: PUSH
107468: LD_INT 30
107470: PUSH
107471: LD_INT 26
107473: PUSH
107474: EMPTY
107475: LIST
107476: LIST
107477: PUSH
107478: LD_INT 30
107480: PUSH
107481: LD_INT 28
107483: PUSH
107484: EMPTY
107485: LIST
107486: LIST
107487: PUSH
107488: EMPTY
107489: LIST
107490: LIST
107491: LIST
107492: LIST
107493: PUSH
107494: EMPTY
107495: LIST
107496: LIST
107497: PPUSH
107498: CALL_OW 69
107502: ST_TO_ADDR
// if not tmp then
107503: LD_VAR 0 2
107507: NOT
107508: IFFALSE 107512
// exit ;
107510: GO 107541
// for i in tmp do
107512: LD_ADDR_VAR 0 1
107516: PUSH
107517: LD_VAR 0 2
107521: PUSH
107522: FOR_IN
107523: IFFALSE 107539
// SetLives ( i , 1 ) ;
107525: LD_VAR 0 1
107529: PPUSH
107530: LD_INT 1
107532: PPUSH
107533: CALL_OW 234
107537: GO 107522
107539: POP
107540: POP
// end ;
107541: PPOPN 2
107543: END
// every 0 0$1 trigger StreamModeActive and sRandom do var i , tmp , un ;
107544: LD_EXP 126
107548: PUSH
107549: LD_EXP 175
107553: AND
107554: IFFALSE 107841
107556: GO 107558
107558: DISABLE
107559: LD_INT 0
107561: PPUSH
107562: PPUSH
107563: PPUSH
// begin i := rand ( 1 , 7 ) ;
107564: LD_ADDR_VAR 0 1
107568: PUSH
107569: LD_INT 1
107571: PPUSH
107572: LD_INT 7
107574: PPUSH
107575: CALL_OW 12
107579: ST_TO_ADDR
// case i of 1 :
107580: LD_VAR 0 1
107584: PUSH
107585: LD_INT 1
107587: DOUBLE
107588: EQUAL
107589: IFTRUE 107593
107591: GO 107603
107593: POP
// ToLua ( earthquake(getX(game), 0, 32) ) ; 2 :
107594: LD_STRING earthquake(getX(game), 0, 32)
107596: PPUSH
107597: CALL_OW 559
107601: GO 107841
107603: LD_INT 2
107605: DOUBLE
107606: EQUAL
107607: IFTRUE 107611
107609: GO 107625
107611: POP
// begin ToLua ( displayStucuk(); ) ;
107612: LD_STRING displayStucuk();
107614: PPUSH
107615: CALL_OW 559
// ResetFog ;
107619: CALL_OW 335
// end ; 3 :
107623: GO 107841
107625: LD_INT 3
107627: DOUBLE
107628: EQUAL
107629: IFTRUE 107633
107631: GO 107737
107633: POP
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_class , 1 ] ] ) ;
107634: LD_ADDR_VAR 0 2
107638: PUSH
107639: LD_INT 22
107641: PUSH
107642: LD_OWVAR 2
107646: PUSH
107647: EMPTY
107648: LIST
107649: LIST
107650: PUSH
107651: LD_INT 25
107653: PUSH
107654: LD_INT 1
107656: PUSH
107657: EMPTY
107658: LIST
107659: LIST
107660: PUSH
107661: EMPTY
107662: LIST
107663: LIST
107664: PPUSH
107665: CALL_OW 69
107669: ST_TO_ADDR
// if not tmp then
107670: LD_VAR 0 2
107674: NOT
107675: IFFALSE 107679
// exit ;
107677: GO 107841
// un := tmp [ rand ( 1 , tmp ) ] ;
107679: LD_ADDR_VAR 0 3
107683: PUSH
107684: LD_VAR 0 2
107688: PUSH
107689: LD_INT 1
107691: PPUSH
107692: LD_VAR 0 2
107696: PPUSH
107697: CALL_OW 12
107701: ARRAY
107702: ST_TO_ADDR
// if Crawls ( un ) then
107703: LD_VAR 0 3
107707: PPUSH
107708: CALL_OW 318
107712: IFFALSE 107723
// ComWalk ( un ) ;
107714: LD_VAR 0 3
107718: PPUSH
107719: CALL_OW 138
// SetClass ( un , class_mortar ) ;
107723: LD_VAR 0 3
107727: PPUSH
107728: LD_INT 8
107730: PPUSH
107731: CALL_OW 336
// end ; 4 :
107735: GO 107841
107737: LD_INT 4
107739: DOUBLE
107740: EQUAL
107741: IFTRUE 107745
107743: GO 107819
107745: POP
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_btype , b_oil_mine ] ] ) ;
107746: LD_ADDR_VAR 0 2
107750: PUSH
107751: LD_INT 22
107753: PUSH
107754: LD_OWVAR 2
107758: PUSH
107759: EMPTY
107760: LIST
107761: LIST
107762: PUSH
107763: LD_INT 30
107765: PUSH
107766: LD_INT 29
107768: PUSH
107769: EMPTY
107770: LIST
107771: LIST
107772: PUSH
107773: EMPTY
107774: LIST
107775: LIST
107776: PPUSH
107777: CALL_OW 69
107781: ST_TO_ADDR
// if not tmp then
107782: LD_VAR 0 2
107786: NOT
107787: IFFALSE 107791
// exit ;
107789: GO 107841
// CenterNowOnUnits ( tmp [ 1 ] ) ;
107791: LD_VAR 0 2
107795: PUSH
107796: LD_INT 1
107798: ARRAY
107799: PPUSH
107800: CALL_OW 87
// DestroyUnit ( tmp [ 1 ] ) ;
107804: LD_VAR 0 2
107808: PUSH
107809: LD_INT 1
107811: ARRAY
107812: PPUSH
107813: CALL_OW 65
// end ; 5 .. 7 :
107817: GO 107841
107819: LD_INT 5
107821: DOUBLE
107822: GREATEREQUAL
107823: IFFALSE 107831
107825: LD_INT 7
107827: DOUBLE
107828: LESSEQUAL
107829: IFTRUE 107833
107831: GO 107840
107833: POP
// StreamSibBomb ; end ;
107834: CALL 104078 0 0
107838: GO 107841
107840: POP
// end ;
107841: PPOPN 3
107843: END
// every 0 0$1 trigger StreamModeActive and sShield do var i , tmp , p ;
107844: LD_EXP 126
107848: PUSH
107849: LD_EXP 176
107853: AND
107854: IFFALSE 108010
107856: GO 107858
107858: DISABLE
107859: LD_INT 0
107861: PPUSH
107862: PPUSH
107863: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_enemy , your_side ] , [ f_or , [ f_type , unit_human ] , [ f_type , unit_vehicle ] ] ] ) ;
107864: LD_ADDR_VAR 0 2
107868: PUSH
107869: LD_INT 81
107871: PUSH
107872: LD_OWVAR 2
107876: PUSH
107877: EMPTY
107878: LIST
107879: LIST
107880: PUSH
107881: LD_INT 2
107883: PUSH
107884: LD_INT 21
107886: PUSH
107887: LD_INT 1
107889: PUSH
107890: EMPTY
107891: LIST
107892: LIST
107893: PUSH
107894: LD_INT 21
107896: PUSH
107897: LD_INT 2
107899: PUSH
107900: EMPTY
107901: LIST
107902: LIST
107903: PUSH
107904: EMPTY
107905: LIST
107906: LIST
107907: LIST
107908: PUSH
107909: EMPTY
107910: LIST
107911: LIST
107912: PPUSH
107913: CALL_OW 69
107917: ST_TO_ADDR
// if not tmp then
107918: LD_VAR 0 2
107922: NOT
107923: IFFALSE 107927
// exit ;
107925: GO 108010
// p := 0 ;
107927: LD_ADDR_VAR 0 3
107931: PUSH
107932: LD_INT 0
107934: ST_TO_ADDR
// repeat wait ( 0 0$1 ) ;
107935: LD_INT 35
107937: PPUSH
107938: CALL_OW 67
// p := p + 1 ;
107942: LD_ADDR_VAR 0 3
107946: PUSH
107947: LD_VAR 0 3
107951: PUSH
107952: LD_INT 1
107954: PLUS
107955: ST_TO_ADDR
// for i in tmp do
107956: LD_ADDR_VAR 0 1
107960: PUSH
107961: LD_VAR 0 2
107965: PUSH
107966: FOR_IN
107967: IFFALSE 107998
// if GetLives ( i ) < 1000 then
107969: LD_VAR 0 1
107973: PPUSH
107974: CALL_OW 256
107978: PUSH
107979: LD_INT 1000
107981: LESS
107982: IFFALSE 107996
// SetLives ( i , 1000 ) ;
107984: LD_VAR 0 1
107988: PPUSH
107989: LD_INT 1000
107991: PPUSH
107992: CALL_OW 234
107996: GO 107966
107998: POP
107999: POP
// until p > 20 ;
108000: LD_VAR 0 3
108004: PUSH
108005: LD_INT 20
108007: GREATER
108008: IFFALSE 107935
// end ;
108010: PPOPN 3
108012: END
// every 0 0$1 trigger StreamModeActive and sTime do
108013: LD_EXP 126
108017: PUSH
108018: LD_EXP 177
108022: AND
108023: IFFALSE 108058
108025: GO 108027
108027: DISABLE
// begin SetTech ( tech_tauRad , your_side , state_researched ) ;
108028: LD_INT 28
108030: PPUSH
108031: LD_OWVAR 2
108035: PPUSH
108036: LD_INT 2
108038: PPUSH
108039: CALL_OW 322
// SetTech ( tech_tauField , your_side , state_researched ) ;
108043: LD_INT 30
108045: PPUSH
108046: LD_OWVAR 2
108050: PPUSH
108051: LD_INT 2
108053: PPUSH
108054: CALL_OW 322
// end ;
108058: END
// every 0 0$1 trigger StreamModeActive and sTools do var i , tmp ;
108059: LD_EXP 126
108063: PUSH
108064: LD_EXP 178
108068: AND
108069: IFFALSE 108190
108071: GO 108073
108073: DISABLE
108074: LD_INT 0
108076: PPUSH
108077: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_type , unit_human ] , [ f_not , [ f_nation , 0 ] ] ] ) ;
108078: LD_ADDR_VAR 0 2
108082: PUSH
108083: LD_INT 22
108085: PUSH
108086: LD_OWVAR 2
108090: PUSH
108091: EMPTY
108092: LIST
108093: LIST
108094: PUSH
108095: LD_INT 21
108097: PUSH
108098: LD_INT 1
108100: PUSH
108101: EMPTY
108102: LIST
108103: LIST
108104: PUSH
108105: LD_INT 3
108107: PUSH
108108: LD_INT 23
108110: PUSH
108111: LD_INT 0
108113: PUSH
108114: EMPTY
108115: LIST
108116: LIST
108117: PUSH
108118: EMPTY
108119: LIST
108120: LIST
108121: PUSH
108122: EMPTY
108123: LIST
108124: LIST
108125: LIST
108126: PPUSH
108127: CALL_OW 69
108131: ST_TO_ADDR
// if not tmp then
108132: LD_VAR 0 2
108136: NOT
108137: IFFALSE 108141
// exit ;
108139: GO 108190
// for i in tmp do
108141: LD_ADDR_VAR 0 1
108145: PUSH
108146: LD_VAR 0 2
108150: PUSH
108151: FOR_IN
108152: IFFALSE 108188
// begin if Crawls ( i ) then
108154: LD_VAR 0 1
108158: PPUSH
108159: CALL_OW 318
108163: IFFALSE 108174
// ComWalk ( i ) ;
108165: LD_VAR 0 1
108169: PPUSH
108170: CALL_OW 138
// SetClass ( i , 2 ) ;
108174: LD_VAR 0 1
108178: PPUSH
108179: LD_INT 2
108181: PPUSH
108182: CALL_OW 336
// end ;
108186: GO 108151
108188: POP
108189: POP
// end ;
108190: PPOPN 2
108192: END
// every 0 0$1 trigger StreamModeActive and sRanger do var i , p , un ;
108193: LD_EXP 126
108197: PUSH
108198: LD_EXP 179
108202: AND
108203: IFFALSE 108491
108205: GO 108207
108207: DISABLE
108208: LD_INT 0
108210: PPUSH
108211: PPUSH
108212: PPUSH
// begin SetAttitude ( your_side , 9 , att_friend , true ) ;
108213: LD_OWVAR 2
108217: PPUSH
108218: LD_INT 9
108220: PPUSH
108221: LD_INT 1
108223: PPUSH
108224: LD_INT 1
108226: PPUSH
108227: CALL_OW 80
// ChangeSideFog ( 9 , your_side ) ;
108231: LD_INT 9
108233: PPUSH
108234: LD_OWVAR 2
108238: PPUSH
108239: CALL_OW 343
// uc_side := 9 ;
108243: LD_ADDR_OWVAR 20
108247: PUSH
108248: LD_INT 9
108250: ST_TO_ADDR
// uc_nation := 2 ;
108251: LD_ADDR_OWVAR 21
108255: PUSH
108256: LD_INT 2
108258: ST_TO_ADDR
// hc_name := Dark Warrior ;
108259: LD_ADDR_OWVAR 26
108263: PUSH
108264: LD_STRING Dark Warrior
108266: ST_TO_ADDR
// hc_gallery :=  ;
108267: LD_ADDR_OWVAR 33
108271: PUSH
108272: LD_STRING 
108274: ST_TO_ADDR
// hc_noskilllimit := true ;
108275: LD_ADDR_OWVAR 76
108279: PUSH
108280: LD_INT 1
108282: ST_TO_ADDR
// hc_skills := [ 30 , 30 , 30 , 30 ] ;
108283: LD_ADDR_OWVAR 31
108287: PUSH
108288: LD_INT 30
108290: PUSH
108291: LD_INT 30
108293: PUSH
108294: LD_INT 30
108296: PUSH
108297: LD_INT 30
108299: PUSH
108300: EMPTY
108301: LIST
108302: LIST
108303: LIST
108304: LIST
108305: ST_TO_ADDR
// un := CreateHuman ;
108306: LD_ADDR_VAR 0 3
108310: PUSH
108311: CALL_OW 44
108315: ST_TO_ADDR
// hc_noskilllimit := false ;
108316: LD_ADDR_OWVAR 76
108320: PUSH
108321: LD_INT 0
108323: ST_TO_ADDR
// PlaceUnitAnywhere ( un , true ) ;
108324: LD_VAR 0 3
108328: PPUSH
108329: LD_INT 1
108331: PPUSH
108332: CALL_OW 51
// ToLua ( playRanger() ) ;
108336: LD_STRING playRanger()
108338: PPUSH
108339: CALL_OW 559
// p := 0 ;
108343: LD_ADDR_VAR 0 2
108347: PUSH
108348: LD_INT 0
108350: ST_TO_ADDR
// repeat wait ( 0 0$1 ) ;
108351: LD_INT 35
108353: PPUSH
108354: CALL_OW 67
// p := p + 1 ;
108358: LD_ADDR_VAR 0 2
108362: PUSH
108363: LD_VAR 0 2
108367: PUSH
108368: LD_INT 1
108370: PLUS
108371: ST_TO_ADDR
// if GetLives ( un ) < 1000 then
108372: LD_VAR 0 3
108376: PPUSH
108377: CALL_OW 256
108381: PUSH
108382: LD_INT 1000
108384: LESS
108385: IFFALSE 108399
// SetLives ( un , 1000 ) ;
108387: LD_VAR 0 3
108391: PPUSH
108392: LD_INT 1000
108394: PPUSH
108395: CALL_OW 234
// ComAttackUnit ( un , NearestUnitToUnit ( FilterAllUnits ( [ [ f_enemy , your_side ] , [ f_dist , un , 30 ] ] ) , un ) ) ;
108399: LD_VAR 0 3
108403: PPUSH
108404: LD_INT 81
108406: PUSH
108407: LD_OWVAR 2
108411: PUSH
108412: EMPTY
108413: LIST
108414: LIST
108415: PUSH
108416: LD_INT 91
108418: PUSH
108419: LD_VAR 0 3
108423: PUSH
108424: LD_INT 30
108426: PUSH
108427: EMPTY
108428: LIST
108429: LIST
108430: LIST
108431: PUSH
108432: EMPTY
108433: LIST
108434: LIST
108435: PPUSH
108436: CALL_OW 69
108440: PPUSH
108441: LD_VAR 0 3
108445: PPUSH
108446: CALL_OW 74
108450: PPUSH
108451: CALL_OW 115
// until p > 80 or IsDead ( un ) ;
108455: LD_VAR 0 2
108459: PUSH
108460: LD_INT 80
108462: GREATER
108463: PUSH
108464: LD_VAR 0 3
108468: PPUSH
108469: CALL_OW 301
108473: OR
108474: IFFALSE 108351
// if un then
108476: LD_VAR 0 3
108480: IFFALSE 108491
// RemoveUnit ( un ) ;
108482: LD_VAR 0 3
108486: PPUSH
108487: CALL_OW 64
// end ;
108491: PPOPN 3
108493: END
// every 0 0$1 trigger sComputer do var i , tmp , j ;
108494: LD_EXP 180
108498: IFFALSE 108614
108500: GO 108502
108502: DISABLE
108503: LD_INT 0
108505: PPUSH
108506: PPUSH
108507: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_enemy , your_side ] , [ f_type , unit_human ] ] ) ;
108508: LD_ADDR_VAR 0 2
108512: PUSH
108513: LD_INT 81
108515: PUSH
108516: LD_OWVAR 2
108520: PUSH
108521: EMPTY
108522: LIST
108523: LIST
108524: PUSH
108525: LD_INT 21
108527: PUSH
108528: LD_INT 1
108530: PUSH
108531: EMPTY
108532: LIST
108533: LIST
108534: PUSH
108535: EMPTY
108536: LIST
108537: LIST
108538: PPUSH
108539: CALL_OW 69
108543: ST_TO_ADDR
// ToLua ( playComputer() ) ;
108544: LD_STRING playComputer()
108546: PPUSH
108547: CALL_OW 559
// if not tmp then
108551: LD_VAR 0 2
108555: NOT
108556: IFFALSE 108560
// exit ;
108558: GO 108614
// for i in tmp do
108560: LD_ADDR_VAR 0 1
108564: PUSH
108565: LD_VAR 0 2
108569: PUSH
108570: FOR_IN
108571: IFFALSE 108612
// for j := 1 to 4 do
108573: LD_ADDR_VAR 0 3
108577: PUSH
108578: DOUBLE
108579: LD_INT 1
108581: DEC
108582: ST_TO_ADDR
108583: LD_INT 4
108585: PUSH
108586: FOR_TO
108587: IFFALSE 108608
// SetSkill ( i , j , 10 ) ;
108589: LD_VAR 0 1
108593: PPUSH
108594: LD_VAR 0 3
108598: PPUSH
108599: LD_INT 10
108601: PPUSH
108602: CALL_OW 237
108606: GO 108586
108608: POP
108609: POP
108610: GO 108570
108612: POP
108613: POP
// end ;
108614: PPOPN 3
108616: END
// every 0 0$1 trigger s30 do var i , tmp ;
108617: LD_EXP 181
108621: IFFALSE 108690
108623: GO 108625
108625: DISABLE
108626: LD_INT 0
108628: PPUSH
108629: PPUSH
// begin tmp := FilterAllUnits ( [ f_side , your_side ] ) ;
108630: LD_ADDR_VAR 0 2
108634: PUSH
108635: LD_INT 22
108637: PUSH
108638: LD_OWVAR 2
108642: PUSH
108643: EMPTY
108644: LIST
108645: LIST
108646: PPUSH
108647: CALL_OW 69
108651: ST_TO_ADDR
// if not tmp then
108652: LD_VAR 0 2
108656: NOT
108657: IFFALSE 108661
// exit ;
108659: GO 108690
// for i in tmp do
108661: LD_ADDR_VAR 0 1
108665: PUSH
108666: LD_VAR 0 2
108670: PUSH
108671: FOR_IN
108672: IFFALSE 108688
// SetLives ( i , 300 ) ;
108674: LD_VAR 0 1
108678: PPUSH
108679: LD_INT 300
108681: PPUSH
108682: CALL_OW 234
108686: GO 108671
108688: POP
108689: POP
// end ;
108690: PPOPN 2
108692: END
// every 0 0$1 trigger s60 do var i , tmp ;
108693: LD_EXP 182
108697: IFFALSE 108766
108699: GO 108701
108701: DISABLE
108702: LD_INT 0
108704: PPUSH
108705: PPUSH
// begin tmp := FilterAllUnits ( [ f_side , your_side ] ) ;
108706: LD_ADDR_VAR 0 2
108710: PUSH
108711: LD_INT 22
108713: PUSH
108714: LD_OWVAR 2
108718: PUSH
108719: EMPTY
108720: LIST
108721: LIST
108722: PPUSH
108723: CALL_OW 69
108727: ST_TO_ADDR
// if not tmp then
108728: LD_VAR 0 2
108732: NOT
108733: IFFALSE 108737
// exit ;
108735: GO 108766
// for i in tmp do
108737: LD_ADDR_VAR 0 1
108741: PUSH
108742: LD_VAR 0 2
108746: PUSH
108747: FOR_IN
108748: IFFALSE 108764
// SetLives ( i , 600 ) ;
108750: LD_VAR 0 1
108754: PPUSH
108755: LD_INT 600
108757: PPUSH
108758: CALL_OW 234
108762: GO 108747
108764: POP
108765: POP
// end ;
108766: PPOPN 2
108768: END
// export function SOS_TargetableHack ( cmd , unit , selectedUnit , x , y , p1 , p2 , p3 , p4 , p5 , p6 ) ; begin
108769: LD_INT 0
108771: PPUSH
// case cmd of 301 :
108772: LD_VAR 0 1
108776: PUSH
108777: LD_INT 301
108779: DOUBLE
108780: EQUAL
108781: IFTRUE 108785
108783: GO 108817
108785: POP
// hHackSpawnHuman ( p1 , p2 , p3 , x , y ) ; 302 :
108786: LD_VAR 0 6
108790: PPUSH
108791: LD_VAR 0 7
108795: PPUSH
108796: LD_VAR 0 8
108800: PPUSH
108801: LD_VAR 0 4
108805: PPUSH
108806: LD_VAR 0 5
108810: PPUSH
108811: CALL 110026 0 5
108815: GO 108938
108817: LD_INT 302
108819: DOUBLE
108820: EQUAL
108821: IFTRUE 108825
108823: GO 108862
108825: POP
// hHackSpawnVehicle ( p1 , p2 , p3 , p4 , x , y ) ; 303 :
108826: LD_VAR 0 6
108830: PPUSH
108831: LD_VAR 0 7
108835: PPUSH
108836: LD_VAR 0 8
108840: PPUSH
108841: LD_VAR 0 9
108845: PPUSH
108846: LD_VAR 0 4
108850: PPUSH
108851: LD_VAR 0 5
108855: PPUSH
108856: CALL 110117 0 6
108860: GO 108938
108862: LD_INT 303
108864: DOUBLE
108865: EQUAL
108866: IFTRUE 108870
108868: GO 108907
108870: POP
// hHackSpawnBuilding ( p1 , p2 , p3 , p4 , x , y ) ; 304 :
108871: LD_VAR 0 6
108875: PPUSH
108876: LD_VAR 0 7
108880: PPUSH
108881: LD_VAR 0 8
108885: PPUSH
108886: LD_VAR 0 9
108890: PPUSH
108891: LD_VAR 0 4
108895: PPUSH
108896: LD_VAR 0 5
108900: PPUSH
108901: CALL 108943 0 6
108905: GO 108938
108907: LD_INT 304
108909: DOUBLE
108910: EQUAL
108911: IFTRUE 108915
108913: GO 108937
108915: POP
// hHackTeleport ( unit , x , y ) ; end ;
108916: LD_VAR 0 2
108920: PPUSH
108921: LD_VAR 0 4
108925: PPUSH
108926: LD_VAR 0 5
108930: PPUSH
108931: CALL 110710 0 3
108935: GO 108938
108937: POP
// end ;
108938: LD_VAR 0 12
108942: RET
// export function hHackSpawnBuilding ( nation , btype , dir , weapon , x , y ) ; var b ; begin
108943: LD_INT 0
108945: PPUSH
108946: PPUSH
// if nation < 1 or nation > 3 or HexInfo ( x , y ) then
108947: LD_VAR 0 1
108951: PUSH
108952: LD_INT 1
108954: LESS
108955: PUSH
108956: LD_VAR 0 1
108960: PUSH
108961: LD_INT 3
108963: GREATER
108964: OR
108965: PUSH
108966: LD_VAR 0 5
108970: PPUSH
108971: LD_VAR 0 6
108975: PPUSH
108976: CALL_OW 428
108980: OR
108981: IFFALSE 108985
// exit ;
108983: GO 109713
// uc_side := your_side ;
108985: LD_ADDR_OWVAR 20
108989: PUSH
108990: LD_OWVAR 2
108994: ST_TO_ADDR
// uc_nation := nation ;
108995: LD_ADDR_OWVAR 21
108999: PUSH
109000: LD_VAR 0 1
109004: ST_TO_ADDR
// bc_level = 1 ;
109005: LD_ADDR_OWVAR 43
109009: PUSH
109010: LD_INT 1
109012: ST_TO_ADDR
// case btype of 1 :
109013: LD_VAR 0 2
109017: PUSH
109018: LD_INT 1
109020: DOUBLE
109021: EQUAL
109022: IFTRUE 109026
109024: GO 109037
109026: POP
// bc_type := b_depot ; 2 :
109027: LD_ADDR_OWVAR 42
109031: PUSH
109032: LD_INT 0
109034: ST_TO_ADDR
109035: GO 109657
109037: LD_INT 2
109039: DOUBLE
109040: EQUAL
109041: IFTRUE 109045
109043: GO 109056
109045: POP
// bc_type := b_warehouse ; 3 :
109046: LD_ADDR_OWVAR 42
109050: PUSH
109051: LD_INT 1
109053: ST_TO_ADDR
109054: GO 109657
109056: LD_INT 3
109058: DOUBLE
109059: EQUAL
109060: IFTRUE 109064
109062: GO 109075
109064: POP
// bc_type := b_lab ; 4 .. 9 :
109065: LD_ADDR_OWVAR 42
109069: PUSH
109070: LD_INT 6
109072: ST_TO_ADDR
109073: GO 109657
109075: LD_INT 4
109077: DOUBLE
109078: GREATEREQUAL
109079: IFFALSE 109087
109081: LD_INT 9
109083: DOUBLE
109084: LESSEQUAL
109085: IFTRUE 109089
109087: GO 109149
109089: POP
// begin bc_type := b_lab_half ;
109090: LD_ADDR_OWVAR 42
109094: PUSH
109095: LD_INT 7
109097: ST_TO_ADDR
// bc_kind1 := [ b_lab_weapon , b_lab_siberium , b_lab_computer , b_lab_opto , b_lab_spacetime , b_lab_biological ] [ btype - 3 ] ;
109098: LD_ADDR_OWVAR 44
109102: PUSH
109103: LD_INT 10
109105: PUSH
109106: LD_INT 11
109108: PUSH
109109: LD_INT 12
109111: PUSH
109112: LD_INT 15
109114: PUSH
109115: LD_INT 14
109117: PUSH
109118: LD_INT 13
109120: PUSH
109121: EMPTY
109122: LIST
109123: LIST
109124: LIST
109125: LIST
109126: LIST
109127: LIST
109128: PUSH
109129: LD_VAR 0 2
109133: PUSH
109134: LD_INT 3
109136: MINUS
109137: ARRAY
109138: ST_TO_ADDR
// bc_kind2 := b_lab_basic ;
109139: LD_ADDR_OWVAR 45
109143: PUSH
109144: LD_INT 9
109146: ST_TO_ADDR
// end ; 10 .. 13 :
109147: GO 109657
109149: LD_INT 10
109151: DOUBLE
109152: GREATEREQUAL
109153: IFFALSE 109161
109155: LD_INT 13
109157: DOUBLE
109158: LESSEQUAL
109159: IFTRUE 109163
109161: GO 109240
109163: POP
// begin bc_type := b_lab_full ;
109164: LD_ADDR_OWVAR 42
109168: PUSH
109169: LD_INT 8
109171: ST_TO_ADDR
// bc_kind1 := [ b_lab_weapon , b_lab_computer , b_lab_spacetime , b_lab_biological ] [ btype - 9 ] ;
109172: LD_ADDR_OWVAR 44
109176: PUSH
109177: LD_INT 10
109179: PUSH
109180: LD_INT 12
109182: PUSH
109183: LD_INT 14
109185: PUSH
109186: LD_INT 13
109188: PUSH
109189: EMPTY
109190: LIST
109191: LIST
109192: LIST
109193: LIST
109194: PUSH
109195: LD_VAR 0 2
109199: PUSH
109200: LD_INT 9
109202: MINUS
109203: ARRAY
109204: ST_TO_ADDR
// bc_kind2 := [ b_lab_siberium , b_lab_opto , b_lab_computer , b_lab_opto ] [ btype - 9 ] ;
109205: LD_ADDR_OWVAR 45
109209: PUSH
109210: LD_INT 11
109212: PUSH
109213: LD_INT 15
109215: PUSH
109216: LD_INT 12
109218: PUSH
109219: LD_INT 15
109221: PUSH
109222: EMPTY
109223: LIST
109224: LIST
109225: LIST
109226: LIST
109227: PUSH
109228: LD_VAR 0 2
109232: PUSH
109233: LD_INT 9
109235: MINUS
109236: ARRAY
109237: ST_TO_ADDR
// end ; 14 :
109238: GO 109657
109240: LD_INT 14
109242: DOUBLE
109243: EQUAL
109244: IFTRUE 109248
109246: GO 109259
109248: POP
// bc_type := b_workshop ; 15 :
109249: LD_ADDR_OWVAR 42
109253: PUSH
109254: LD_INT 2
109256: ST_TO_ADDR
109257: GO 109657
109259: LD_INT 15
109261: DOUBLE
109262: EQUAL
109263: IFTRUE 109267
109265: GO 109278
109267: POP
// bc_type := b_factory ; 16 :
109268: LD_ADDR_OWVAR 42
109272: PUSH
109273: LD_INT 3
109275: ST_TO_ADDR
109276: GO 109657
109278: LD_INT 16
109280: DOUBLE
109281: EQUAL
109282: IFTRUE 109286
109284: GO 109297
109286: POP
// bc_type := b_ext_gun ; 17 :
109287: LD_ADDR_OWVAR 42
109291: PUSH
109292: LD_INT 17
109294: ST_TO_ADDR
109295: GO 109657
109297: LD_INT 17
109299: DOUBLE
109300: EQUAL
109301: IFTRUE 109305
109303: GO 109333
109305: POP
// bc_type := [ b_ext_noncombat , b_ext_stitch , b_ext_noncombat ] [ nation ] ; 18 :
109306: LD_ADDR_OWVAR 42
109310: PUSH
109311: LD_INT 19
109313: PUSH
109314: LD_INT 23
109316: PUSH
109317: LD_INT 19
109319: PUSH
109320: EMPTY
109321: LIST
109322: LIST
109323: LIST
109324: PUSH
109325: LD_VAR 0 1
109329: ARRAY
109330: ST_TO_ADDR
109331: GO 109657
109333: LD_INT 18
109335: DOUBLE
109336: EQUAL
109337: IFTRUE 109341
109339: GO 109352
109341: POP
// bc_type := b_ext_radar ; 19 :
109342: LD_ADDR_OWVAR 42
109346: PUSH
109347: LD_INT 20
109349: ST_TO_ADDR
109350: GO 109657
109352: LD_INT 19
109354: DOUBLE
109355: EQUAL
109356: IFTRUE 109360
109358: GO 109371
109360: POP
// bc_type := b_ext_radio ; 20 :
109361: LD_ADDR_OWVAR 42
109365: PUSH
109366: LD_INT 22
109368: ST_TO_ADDR
109369: GO 109657
109371: LD_INT 20
109373: DOUBLE
109374: EQUAL
109375: IFTRUE 109379
109377: GO 109390
109379: POP
// bc_type := b_ext_siberium ; 21 :
109380: LD_ADDR_OWVAR 42
109384: PUSH
109385: LD_INT 21
109387: ST_TO_ADDR
109388: GO 109657
109390: LD_INT 21
109392: DOUBLE
109393: EQUAL
109394: IFTRUE 109398
109396: GO 109409
109398: POP
// bc_type := b_ext_computer ; 22 :
109399: LD_ADDR_OWVAR 42
109403: PUSH
109404: LD_INT 24
109406: ST_TO_ADDR
109407: GO 109657
109409: LD_INT 22
109411: DOUBLE
109412: EQUAL
109413: IFTRUE 109417
109415: GO 109428
109417: POP
// bc_type := b_ext_track ; 23 :
109418: LD_ADDR_OWVAR 42
109422: PUSH
109423: LD_INT 16
109425: ST_TO_ADDR
109426: GO 109657
109428: LD_INT 23
109430: DOUBLE
109431: EQUAL
109432: IFTRUE 109436
109434: GO 109447
109436: POP
// bc_type := b_ext_laser ; 24 :
109437: LD_ADDR_OWVAR 42
109441: PUSH
109442: LD_INT 25
109444: ST_TO_ADDR
109445: GO 109657
109447: LD_INT 24
109449: DOUBLE
109450: EQUAL
109451: IFTRUE 109455
109453: GO 109466
109455: POP
// bc_type := b_control_tower ; 25 :
109456: LD_ADDR_OWVAR 42
109460: PUSH
109461: LD_INT 36
109463: ST_TO_ADDR
109464: GO 109657
109466: LD_INT 25
109468: DOUBLE
109469: EQUAL
109470: IFTRUE 109474
109472: GO 109485
109474: POP
// bc_type := b_breastwork ; 26 :
109475: LD_ADDR_OWVAR 42
109479: PUSH
109480: LD_INT 31
109482: ST_TO_ADDR
109483: GO 109657
109485: LD_INT 26
109487: DOUBLE
109488: EQUAL
109489: IFTRUE 109493
109491: GO 109504
109493: POP
// bc_type := b_bunker ; 27 :
109494: LD_ADDR_OWVAR 42
109498: PUSH
109499: LD_INT 32
109501: ST_TO_ADDR
109502: GO 109657
109504: LD_INT 27
109506: DOUBLE
109507: EQUAL
109508: IFTRUE 109512
109510: GO 109523
109512: POP
// bc_type := b_turret ; 28 :
109513: LD_ADDR_OWVAR 42
109517: PUSH
109518: LD_INT 33
109520: ST_TO_ADDR
109521: GO 109657
109523: LD_INT 28
109525: DOUBLE
109526: EQUAL
109527: IFTRUE 109531
109529: GO 109542
109531: POP
// bc_type := b_armoury ; 29 :
109532: LD_ADDR_OWVAR 42
109536: PUSH
109537: LD_INT 4
109539: ST_TO_ADDR
109540: GO 109657
109542: LD_INT 29
109544: DOUBLE
109545: EQUAL
109546: IFTRUE 109550
109548: GO 109561
109550: POP
// bc_type := b_barracks ; 30 :
109551: LD_ADDR_OWVAR 42
109555: PUSH
109556: LD_INT 5
109558: ST_TO_ADDR
109559: GO 109657
109561: LD_INT 30
109563: DOUBLE
109564: EQUAL
109565: IFTRUE 109569
109567: GO 109580
109569: POP
// bc_type := b_solar_power ; 31 :
109570: LD_ADDR_OWVAR 42
109574: PUSH
109575: LD_INT 27
109577: ST_TO_ADDR
109578: GO 109657
109580: LD_INT 31
109582: DOUBLE
109583: EQUAL
109584: IFTRUE 109588
109586: GO 109599
109588: POP
// bc_type := b_oil_power ; 32 :
109589: LD_ADDR_OWVAR 42
109593: PUSH
109594: LD_INT 26
109596: ST_TO_ADDR
109597: GO 109657
109599: LD_INT 32
109601: DOUBLE
109602: EQUAL
109603: IFTRUE 109607
109605: GO 109618
109607: POP
// bc_type := b_siberite_power ; 33 :
109608: LD_ADDR_OWVAR 42
109612: PUSH
109613: LD_INT 28
109615: ST_TO_ADDR
109616: GO 109657
109618: LD_INT 33
109620: DOUBLE
109621: EQUAL
109622: IFTRUE 109626
109624: GO 109637
109626: POP
// bc_type := b_oil_mine ; 34 :
109627: LD_ADDR_OWVAR 42
109631: PUSH
109632: LD_INT 29
109634: ST_TO_ADDR
109635: GO 109657
109637: LD_INT 34
109639: DOUBLE
109640: EQUAL
109641: IFTRUE 109645
109643: GO 109656
109645: POP
// bc_type := b_siberite_mine ; end ;
109646: LD_ADDR_OWVAR 42
109650: PUSH
109651: LD_INT 30
109653: ST_TO_ADDR
109654: GO 109657
109656: POP
// b := CreateAndPlaceBuildingXYD ( x , y , dir ) ;
109657: LD_ADDR_VAR 0 8
109661: PUSH
109662: LD_VAR 0 5
109666: PPUSH
109667: LD_VAR 0 6
109671: PPUSH
109672: LD_VAR 0 3
109676: PPUSH
109677: CALL_OW 47
109681: ST_TO_ADDR
// if bc_type in [ b_bunker , b_turret ] then
109682: LD_OWVAR 42
109686: PUSH
109687: LD_INT 32
109689: PUSH
109690: LD_INT 33
109692: PUSH
109693: EMPTY
109694: LIST
109695: LIST
109696: IN
109697: IFFALSE 109713
// PlaceWeaponTurret ( b , weapon ) ;
109699: LD_VAR 0 8
109703: PPUSH
109704: LD_VAR 0 4
109708: PPUSH
109709: CALL_OW 431
// end ;
109713: LD_VAR 0 7
109717: RET
// export function hHackUnlimitedResources ; var i , j , tmp ; begin
109718: LD_INT 0
109720: PPUSH
109721: PPUSH
109722: PPUSH
109723: PPUSH
// tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ] ) ;
109724: LD_ADDR_VAR 0 4
109728: PUSH
109729: LD_INT 22
109731: PUSH
109732: LD_OWVAR 2
109736: PUSH
109737: EMPTY
109738: LIST
109739: LIST
109740: PUSH
109741: LD_INT 2
109743: PUSH
109744: LD_INT 30
109746: PUSH
109747: LD_INT 0
109749: PUSH
109750: EMPTY
109751: LIST
109752: LIST
109753: PUSH
109754: LD_INT 30
109756: PUSH
109757: LD_INT 1
109759: PUSH
109760: EMPTY
109761: LIST
109762: LIST
109763: PUSH
109764: EMPTY
109765: LIST
109766: LIST
109767: LIST
109768: PUSH
109769: EMPTY
109770: LIST
109771: LIST
109772: PPUSH
109773: CALL_OW 69
109777: ST_TO_ADDR
// if not tmp then
109778: LD_VAR 0 4
109782: NOT
109783: IFFALSE 109787
// exit ;
109785: GO 109846
// for i in tmp do
109787: LD_ADDR_VAR 0 2
109791: PUSH
109792: LD_VAR 0 4
109796: PUSH
109797: FOR_IN
109798: IFFALSE 109844
// for j = 1 to 3 do
109800: LD_ADDR_VAR 0 3
109804: PUSH
109805: DOUBLE
109806: LD_INT 1
109808: DEC
109809: ST_TO_ADDR
109810: LD_INT 3
109812: PUSH
109813: FOR_TO
109814: IFFALSE 109840
// SetResourceType ( GetBase ( i ) , j , 99999 ) ;
109816: LD_VAR 0 2
109820: PPUSH
109821: CALL_OW 274
109825: PPUSH
109826: LD_VAR 0 3
109830: PPUSH
109831: LD_INT 99999
109833: PPUSH
109834: CALL_OW 277
109838: GO 109813
109840: POP
109841: POP
109842: GO 109797
109844: POP
109845: POP
// end ;
109846: LD_VAR 0 1
109850: RET
// export function hHackSetLevel10 ; var i , j ; begin
109851: LD_INT 0
109853: PPUSH
109854: PPUSH
109855: PPUSH
// for i in FilterAllUnits ( [ f_type , unit_human ] ) do
109856: LD_ADDR_VAR 0 2
109860: PUSH
109861: LD_INT 21
109863: PUSH
109864: LD_INT 1
109866: PUSH
109867: EMPTY
109868: LIST
109869: LIST
109870: PPUSH
109871: CALL_OW 69
109875: PUSH
109876: FOR_IN
109877: IFFALSE 109929
// if IsSelected ( i ) then
109879: LD_VAR 0 2
109883: PPUSH
109884: CALL_OW 306
109888: IFFALSE 109927
// begin for j := 1 to 4 do
109890: LD_ADDR_VAR 0 3
109894: PUSH
109895: DOUBLE
109896: LD_INT 1
109898: DEC
109899: ST_TO_ADDR
109900: LD_INT 4
109902: PUSH
109903: FOR_TO
109904: IFFALSE 109925
// SetSkill ( i , j , 10 ) ;
109906: LD_VAR 0 2
109910: PPUSH
109911: LD_VAR 0 3
109915: PPUSH
109916: LD_INT 10
109918: PPUSH
109919: CALL_OW 237
109923: GO 109903
109925: POP
109926: POP
// end ;
109927: GO 109876
109929: POP
109930: POP
// end ;
109931: LD_VAR 0 1
109935: RET
// export function hHackSetLevel10YourUnits ; var i , j ; begin
109936: LD_INT 0
109938: PPUSH
109939: PPUSH
109940: PPUSH
// for i in FilterAllUnits ( [ [ f_side , your_side ] , [ f_type , unit_human ] ] ) do
109941: LD_ADDR_VAR 0 2
109945: PUSH
109946: LD_INT 22
109948: PUSH
109949: LD_OWVAR 2
109953: PUSH
109954: EMPTY
109955: LIST
109956: LIST
109957: PUSH
109958: LD_INT 21
109960: PUSH
109961: LD_INT 1
109963: PUSH
109964: EMPTY
109965: LIST
109966: LIST
109967: PUSH
109968: EMPTY
109969: LIST
109970: LIST
109971: PPUSH
109972: CALL_OW 69
109976: PUSH
109977: FOR_IN
109978: IFFALSE 110019
// begin for j := 1 to 4 do
109980: LD_ADDR_VAR 0 3
109984: PUSH
109985: DOUBLE
109986: LD_INT 1
109988: DEC
109989: ST_TO_ADDR
109990: LD_INT 4
109992: PUSH
109993: FOR_TO
109994: IFFALSE 110015
// SetSkill ( i , j , 10 ) ;
109996: LD_VAR 0 2
110000: PPUSH
110001: LD_VAR 0 3
110005: PPUSH
110006: LD_INT 10
110008: PPUSH
110009: CALL_OW 237
110013: GO 109993
110015: POP
110016: POP
// end ;
110017: GO 109977
110019: POP
110020: POP
// end ;
110021: LD_VAR 0 1
110025: RET
// export function hHackSpawnHuman ( nation , class , skill , x , y ) ; begin
110026: LD_INT 0
110028: PPUSH
// uc_side := your_side ;
110029: LD_ADDR_OWVAR 20
110033: PUSH
110034: LD_OWVAR 2
110038: ST_TO_ADDR
// uc_nation := nation ;
110039: LD_ADDR_OWVAR 21
110043: PUSH
110044: LD_VAR 0 1
110048: ST_TO_ADDR
// InitHc ;
110049: CALL_OW 19
// PrepareHuman ( false , class , skill ) ;
110053: LD_INT 0
110055: PPUSH
110056: LD_VAR 0 2
110060: PPUSH
110061: LD_VAR 0 3
110065: PPUSH
110066: CALL_OW 380
// if HexInfo ( x , y ) = 0 then
110070: LD_VAR 0 4
110074: PPUSH
110075: LD_VAR 0 5
110079: PPUSH
110080: CALL_OW 428
110084: PUSH
110085: LD_INT 0
110087: EQUAL
110088: IFFALSE 110112
// PlaceUnitXY ( CreateHuman , x , y , true ) ;
110090: CALL_OW 44
110094: PPUSH
110095: LD_VAR 0 4
110099: PPUSH
110100: LD_VAR 0 5
110104: PPUSH
110105: LD_INT 1
110107: PPUSH
110108: CALL_OW 48
// end ;
110112: LD_VAR 0 6
110116: RET
// export function hHackSpawnVehicle ( chassis , engine , control , weapon , x , y ) ; var un ; begin
110117: LD_INT 0
110119: PPUSH
110120: PPUSH
// uc_side := your_side ;
110121: LD_ADDR_OWVAR 20
110125: PUSH
110126: LD_OWVAR 2
110130: ST_TO_ADDR
// if chassis in [ 1 , 2 , 3 , 4 , 5 ] then
110131: LD_VAR 0 1
110135: PUSH
110136: LD_INT 1
110138: PUSH
110139: LD_INT 2
110141: PUSH
110142: LD_INT 3
110144: PUSH
110145: LD_INT 4
110147: PUSH
110148: LD_INT 5
110150: PUSH
110151: EMPTY
110152: LIST
110153: LIST
110154: LIST
110155: LIST
110156: LIST
110157: IN
110158: IFFALSE 110170
// uc_nation := nation_american else
110160: LD_ADDR_OWVAR 21
110164: PUSH
110165: LD_INT 1
110167: ST_TO_ADDR
110168: GO 110213
// if chassis in [ 11 , 12 , 13 , 14 ] then
110170: LD_VAR 0 1
110174: PUSH
110175: LD_INT 11
110177: PUSH
110178: LD_INT 12
110180: PUSH
110181: LD_INT 13
110183: PUSH
110184: LD_INT 14
110186: PUSH
110187: EMPTY
110188: LIST
110189: LIST
110190: LIST
110191: LIST
110192: IN
110193: IFFALSE 110205
// uc_nation := nation_arabian else
110195: LD_ADDR_OWVAR 21
110199: PUSH
110200: LD_INT 2
110202: ST_TO_ADDR
110203: GO 110213
// uc_nation := nation_russian ;
110205: LD_ADDR_OWVAR 21
110209: PUSH
110210: LD_INT 3
110212: ST_TO_ADDR
// vc_chassis := chassis ;
110213: LD_ADDR_OWVAR 37
110217: PUSH
110218: LD_VAR 0 1
110222: ST_TO_ADDR
// vc_engine := engine ;
110223: LD_ADDR_OWVAR 39
110227: PUSH
110228: LD_VAR 0 2
110232: ST_TO_ADDR
// vc_control := control ;
110233: LD_ADDR_OWVAR 38
110237: PUSH
110238: LD_VAR 0 3
110242: ST_TO_ADDR
// vc_weapon := weapon ;
110243: LD_ADDR_OWVAR 40
110247: PUSH
110248: LD_VAR 0 4
110252: ST_TO_ADDR
// un := CreateVehicle ;
110253: LD_ADDR_VAR 0 8
110257: PUSH
110258: CALL_OW 45
110262: ST_TO_ADDR
// SetDir ( un , rand ( 0 , 5 ) ) ;
110263: LD_VAR 0 8
110267: PPUSH
110268: LD_INT 0
110270: PPUSH
110271: LD_INT 5
110273: PPUSH
110274: CALL_OW 12
110278: PPUSH
110279: CALL_OW 233
// PlaceUnitXY ( un , x , y , true ) ;
110283: LD_VAR 0 8
110287: PPUSH
110288: LD_VAR 0 5
110292: PPUSH
110293: LD_VAR 0 6
110297: PPUSH
110298: LD_INT 1
110300: PPUSH
110301: CALL_OW 48
// end ;
110305: LD_VAR 0 7
110309: RET
// export hInvincible ; every 1 do
110310: GO 110312
110312: DISABLE
// hInvincible := [ ] ;
110313: LD_ADDR_EXP 183
110317: PUSH
110318: EMPTY
110319: ST_TO_ADDR
110320: END
// every 10 do var i ;
110321: GO 110323
110323: DISABLE
110324: LD_INT 0
110326: PPUSH
// begin enable ;
110327: ENABLE
// if not hInvincible then
110328: LD_EXP 183
110332: NOT
110333: IFFALSE 110337
// exit ;
110335: GO 110381
// for i in hInvincible do
110337: LD_ADDR_VAR 0 1
110341: PUSH
110342: LD_EXP 183
110346: PUSH
110347: FOR_IN
110348: IFFALSE 110379
// if GetLives ( i ) < 1000 then
110350: LD_VAR 0 1
110354: PPUSH
110355: CALL_OW 256
110359: PUSH
110360: LD_INT 1000
110362: LESS
110363: IFFALSE 110377
// SetLives ( i , 1000 ) ;
110365: LD_VAR 0 1
110369: PPUSH
110370: LD_INT 1000
110372: PPUSH
110373: CALL_OW 234
110377: GO 110347
110379: POP
110380: POP
// end ;
110381: PPOPN 1
110383: END
// export function hHackInvincible ; var i ; begin
110384: LD_INT 0
110386: PPUSH
110387: PPUSH
// for i in FilterAllUnits ( [ f_or , [ f_type , unit_human ] , [ f_type , unit_vehicle ] ] ) do
110388: LD_ADDR_VAR 0 2
110392: PUSH
110393: LD_INT 2
110395: PUSH
110396: LD_INT 21
110398: PUSH
110399: LD_INT 1
110401: PUSH
110402: EMPTY
110403: LIST
110404: LIST
110405: PUSH
110406: LD_INT 21
110408: PUSH
110409: LD_INT 2
110411: PUSH
110412: EMPTY
110413: LIST
110414: LIST
110415: PUSH
110416: EMPTY
110417: LIST
110418: LIST
110419: LIST
110420: PPUSH
110421: CALL_OW 69
110425: PUSH
110426: FOR_IN
110427: IFFALSE 110488
// if IsSelected ( i ) then
110429: LD_VAR 0 2
110433: PPUSH
110434: CALL_OW 306
110438: IFFALSE 110486
// begin if i in hInvincible then
110440: LD_VAR 0 2
110444: PUSH
110445: LD_EXP 183
110449: IN
110450: IFFALSE 110470
// hInvincible := hInvincible diff i else
110452: LD_ADDR_EXP 183
110456: PUSH
110457: LD_EXP 183
110461: PUSH
110462: LD_VAR 0 2
110466: DIFF
110467: ST_TO_ADDR
110468: GO 110486
// hInvincible := hInvincible union i ;
110470: LD_ADDR_EXP 183
110474: PUSH
110475: LD_EXP 183
110479: PUSH
110480: LD_VAR 0 2
110484: UNION
110485: ST_TO_ADDR
// end ;
110486: GO 110426
110488: POP
110489: POP
// end ;
110490: LD_VAR 0 1
110494: RET
// export function hHackInvisible ; var i , j ; begin
110495: LD_INT 0
110497: PPUSH
110498: PPUSH
110499: PPUSH
// for i in FilterAllUnits ( [ f_type , unit_human ] ) do
110500: LD_ADDR_VAR 0 2
110504: PUSH
110505: LD_INT 21
110507: PUSH
110508: LD_INT 1
110510: PUSH
110511: EMPTY
110512: LIST
110513: LIST
110514: PPUSH
110515: CALL_OW 69
110519: PUSH
110520: FOR_IN
110521: IFFALSE 110545
// if IsSelected ( i ) then
110523: LD_VAR 0 2
110527: PPUSH
110528: CALL_OW 306
110532: IFFALSE 110543
// ComForceInvisible ( i ) ;
110534: LD_VAR 0 2
110538: PPUSH
110539: CALL_OW 496
110543: GO 110520
110545: POP
110546: POP
// end ;
110547: LD_VAR 0 1
110551: RET
// export function hHackChangeYourSide ; begin
110552: LD_INT 0
110554: PPUSH
// if your_side = 8 then
110555: LD_OWVAR 2
110559: PUSH
110560: LD_INT 8
110562: EQUAL
110563: IFFALSE 110575
// your_side := 0 else
110565: LD_ADDR_OWVAR 2
110569: PUSH
110570: LD_INT 0
110572: ST_TO_ADDR
110573: GO 110589
// your_side := your_side + 1 ;
110575: LD_ADDR_OWVAR 2
110579: PUSH
110580: LD_OWVAR 2
110584: PUSH
110585: LD_INT 1
110587: PLUS
110588: ST_TO_ADDR
// end ;
110589: LD_VAR 0 1
110593: RET
// export function hHackChangeUnitSide ; var i , j ; begin
110594: LD_INT 0
110596: PPUSH
110597: PPUSH
110598: PPUSH
// for i in all_units do
110599: LD_ADDR_VAR 0 2
110603: PUSH
110604: LD_OWVAR 3
110608: PUSH
110609: FOR_IN
110610: IFFALSE 110688
// if IsSelected ( i ) then
110612: LD_VAR 0 2
110616: PPUSH
110617: CALL_OW 306
110621: IFFALSE 110686
// begin j := GetSide ( i ) ;
110623: LD_ADDR_VAR 0 3
110627: PUSH
110628: LD_VAR 0 2
110632: PPUSH
110633: CALL_OW 255
110637: ST_TO_ADDR
// if j = 8 then
110638: LD_VAR 0 3
110642: PUSH
110643: LD_INT 8
110645: EQUAL
110646: IFFALSE 110658
// j := 0 else
110648: LD_ADDR_VAR 0 3
110652: PUSH
110653: LD_INT 0
110655: ST_TO_ADDR
110656: GO 110672
// j := j + 1 ;
110658: LD_ADDR_VAR 0 3
110662: PUSH
110663: LD_VAR 0 3
110667: PUSH
110668: LD_INT 1
110670: PLUS
110671: ST_TO_ADDR
// SetSide ( i , j ) ;
110672: LD_VAR 0 2
110676: PPUSH
110677: LD_VAR 0 3
110681: PPUSH
110682: CALL_OW 235
// end ;
110686: GO 110609
110688: POP
110689: POP
// end ;
110690: LD_VAR 0 1
110694: RET
// export function hHackFog ; begin
110695: LD_INT 0
110697: PPUSH
// FogOff ( true ) ;
110698: LD_INT 1
110700: PPUSH
110701: CALL_OW 344
// end ;
110705: LD_VAR 0 1
110709: RET
// export function hHackTeleport ( unit , x , y ) ; begin
110710: LD_INT 0
110712: PPUSH
// TeleportUnit ( unit , x , y , 1 , true ) ;
110713: LD_VAR 0 1
110717: PPUSH
110718: LD_VAR 0 2
110722: PPUSH
110723: LD_VAR 0 3
110727: PPUSH
110728: LD_INT 1
110730: PPUSH
110731: LD_INT 1
110733: PPUSH
110734: CALL_OW 483
// CenterOnXY ( x , y ) ;
110738: LD_VAR 0 2
110742: PPUSH
110743: LD_VAR 0 3
110747: PPUSH
110748: CALL_OW 84
// end ;
110752: LD_VAR 0 4
110756: RET
// export factoryWaypoints ; export function SetFactoryWaypoint ( factory , x , y ) ; var i ; begin
110757: LD_INT 0
110759: PPUSH
110760: PPUSH
// if not factory or not ValidHex ( x , y ) or ( GetBType ( factory ) <> b_factory and not GetType ( factory ) = unit_human ) then
110761: LD_VAR 0 1
110765: NOT
110766: PUSH
110767: LD_VAR 0 2
110771: PPUSH
110772: LD_VAR 0 3
110776: PPUSH
110777: CALL_OW 488
110781: NOT
110782: OR
110783: PUSH
110784: LD_VAR 0 1
110788: PPUSH
110789: CALL_OW 266
110793: PUSH
110794: LD_INT 3
110796: NONEQUAL
110797: PUSH
110798: LD_VAR 0 1
110802: PPUSH
110803: CALL_OW 247
110807: PUSH
110808: LD_INT 1
110810: EQUAL
110811: NOT
110812: AND
110813: OR
110814: IFFALSE 110818
// exit ;
110816: GO 110967
// if GetType ( factory ) = unit_human then
110818: LD_VAR 0 1
110822: PPUSH
110823: CALL_OW 247
110827: PUSH
110828: LD_INT 1
110830: EQUAL
110831: IFFALSE 110848
// factory := IsInUnit ( factory ) ;
110833: LD_ADDR_VAR 0 1
110837: PUSH
110838: LD_VAR 0 1
110842: PPUSH
110843: CALL_OW 310
110847: ST_TO_ADDR
// if GetBType ( factory ) <> b_factory then
110848: LD_VAR 0 1
110852: PPUSH
110853: CALL_OW 266
110857: PUSH
110858: LD_INT 3
110860: NONEQUAL
110861: IFFALSE 110865
// exit ;
110863: GO 110967
// if HexInfo ( x , y ) = factory then
110865: LD_VAR 0 2
110869: PPUSH
110870: LD_VAR 0 3
110874: PPUSH
110875: CALL_OW 428
110879: PUSH
110880: LD_VAR 0 1
110884: EQUAL
110885: IFFALSE 110912
// factoryWaypoints := Replace ( factoryWaypoints , factory , 0 ) else
110887: LD_ADDR_EXP 184
110891: PUSH
110892: LD_EXP 184
110896: PPUSH
110897: LD_VAR 0 1
110901: PPUSH
110902: LD_INT 0
110904: PPUSH
110905: CALL_OW 1
110909: ST_TO_ADDR
110910: GO 110963
// factoryWaypoints := Replace ( factoryWaypoints , factory , [ GetSide ( factory ) , factory , x , y ] ) ;
110912: LD_ADDR_EXP 184
110916: PUSH
110917: LD_EXP 184
110921: PPUSH
110922: LD_VAR 0 1
110926: PPUSH
110927: LD_VAR 0 1
110931: PPUSH
110932: CALL_OW 255
110936: PUSH
110937: LD_VAR 0 1
110941: PUSH
110942: LD_VAR 0 2
110946: PUSH
110947: LD_VAR 0 3
110951: PUSH
110952: EMPTY
110953: LIST
110954: LIST
110955: LIST
110956: LIST
110957: PPUSH
110958: CALL_OW 1
110962: ST_TO_ADDR
// UpdateFactoryWaypoints ;
110963: CALL 110972 0 0
// end ;
110967: LD_VAR 0 4
110971: RET
// export function UpdateFactoryWaypoints ( ) ; var i , list ; begin
110972: LD_INT 0
110974: PPUSH
110975: PPUSH
110976: PPUSH
// ToLua ( resetFactoryWaypoint(); ) ;
110977: LD_STRING resetFactoryWaypoint();
110979: PPUSH
110980: CALL_OW 559
// if factoryWaypoints then
110984: LD_EXP 184
110988: IFFALSE 111114
// begin list := PrepareArray ( factoryWaypoints ) ;
110990: LD_ADDR_VAR 0 3
110994: PUSH
110995: LD_EXP 184
110999: PPUSH
111000: CALL 94927 0 1
111004: ST_TO_ADDR
// for i := 1 to list do
111005: LD_ADDR_VAR 0 2
111009: PUSH
111010: DOUBLE
111011: LD_INT 1
111013: DEC
111014: ST_TO_ADDR
111015: LD_VAR 0 3
111019: PUSH
111020: FOR_TO
111021: IFFALSE 111112
// ToLua ( setFactoryWaypointXY( & list [ i ] [ 1 ] & , & list [ i ] [ 2 ] & , & list [ i ] [ 3 ] & , & list [ i ] [ 4 ] & ) ) ;
111023: LD_STRING setFactoryWaypointXY(
111025: PUSH
111026: LD_VAR 0 3
111030: PUSH
111031: LD_VAR 0 2
111035: ARRAY
111036: PUSH
111037: LD_INT 1
111039: ARRAY
111040: STR
111041: PUSH
111042: LD_STRING ,
111044: STR
111045: PUSH
111046: LD_VAR 0 3
111050: PUSH
111051: LD_VAR 0 2
111055: ARRAY
111056: PUSH
111057: LD_INT 2
111059: ARRAY
111060: STR
111061: PUSH
111062: LD_STRING ,
111064: STR
111065: PUSH
111066: LD_VAR 0 3
111070: PUSH
111071: LD_VAR 0 2
111075: ARRAY
111076: PUSH
111077: LD_INT 3
111079: ARRAY
111080: STR
111081: PUSH
111082: LD_STRING ,
111084: STR
111085: PUSH
111086: LD_VAR 0 3
111090: PUSH
111091: LD_VAR 0 2
111095: ARRAY
111096: PUSH
111097: LD_INT 4
111099: ARRAY
111100: STR
111101: PUSH
111102: LD_STRING )
111104: STR
111105: PPUSH
111106: CALL_OW 559
111110: GO 111020
111112: POP
111113: POP
// end ; end ;
111114: LD_VAR 0 1
111118: RET
// export warehouseGatheringPoints , warehouseCratesCollectors ; export function SetWarehouseGatheringPoint ( warehouse , x , y ) ; begin
111119: LD_INT 0
111121: PPUSH
// if HexInfo ( x , y ) = warehouse then
111122: LD_VAR 0 2
111126: PPUSH
111127: LD_VAR 0 3
111131: PPUSH
111132: CALL_OW 428
111136: PUSH
111137: LD_VAR 0 1
111141: EQUAL
111142: IFFALSE 111169
// warehouseGatheringPoints := Replace ( warehouseGatheringPoints , warehouse , 0 ) else
111144: LD_ADDR_EXP 185
111148: PUSH
111149: LD_EXP 185
111153: PPUSH
111154: LD_VAR 0 1
111158: PPUSH
111159: LD_INT 0
111161: PPUSH
111162: CALL_OW 1
111166: ST_TO_ADDR
111167: GO 111220
// warehouseGatheringPoints := Replace ( warehouseGatheringPoints , warehouse , [ GetSide ( warehouse ) , warehouse , x , y ] ) ;
111169: LD_ADDR_EXP 185
111173: PUSH
111174: LD_EXP 185
111178: PPUSH
111179: LD_VAR 0 1
111183: PPUSH
111184: LD_VAR 0 1
111188: PPUSH
111189: CALL_OW 255
111193: PUSH
111194: LD_VAR 0 1
111198: PUSH
111199: LD_VAR 0 2
111203: PUSH
111204: LD_VAR 0 3
111208: PUSH
111209: EMPTY
111210: LIST
111211: LIST
111212: LIST
111213: LIST
111214: PPUSH
111215: CALL_OW 1
111219: ST_TO_ADDR
// UpdateWarehouseGatheringPoints ;
111220: CALL 111229 0 0
// end ;
111224: LD_VAR 0 4
111228: RET
// export function UpdateWarehouseGatheringPoints ( ) ; var i , list ; begin
111229: LD_INT 0
111231: PPUSH
111232: PPUSH
111233: PPUSH
// ToLua ( resetWarehouseGatheringPoints(); ) ;
111234: LD_STRING resetWarehouseGatheringPoints();
111236: PPUSH
111237: CALL_OW 559
// if warehouseGatheringPoints then
111241: LD_EXP 185
111245: IFFALSE 111371
// begin list := PrepareArray ( warehouseGatheringPoints ) ;
111247: LD_ADDR_VAR 0 3
111251: PUSH
111252: LD_EXP 185
111256: PPUSH
111257: CALL 94927 0 1
111261: ST_TO_ADDR
// for i := 1 to list do
111262: LD_ADDR_VAR 0 2
111266: PUSH
111267: DOUBLE
111268: LD_INT 1
111270: DEC
111271: ST_TO_ADDR
111272: LD_VAR 0 3
111276: PUSH
111277: FOR_TO
111278: IFFALSE 111369
// ToLua ( setWarehouseGatheringPointXY( & list [ i ] [ 1 ] & , & list [ i ] [ 2 ] & , & list [ i ] [ 3 ] & , & list [ i ] [ 4 ] & ) ) ;
111280: LD_STRING setWarehouseGatheringPointXY(
111282: PUSH
111283: LD_VAR 0 3
111287: PUSH
111288: LD_VAR 0 2
111292: ARRAY
111293: PUSH
111294: LD_INT 1
111296: ARRAY
111297: STR
111298: PUSH
111299: LD_STRING ,
111301: STR
111302: PUSH
111303: LD_VAR 0 3
111307: PUSH
111308: LD_VAR 0 2
111312: ARRAY
111313: PUSH
111314: LD_INT 2
111316: ARRAY
111317: STR
111318: PUSH
111319: LD_STRING ,
111321: STR
111322: PUSH
111323: LD_VAR 0 3
111327: PUSH
111328: LD_VAR 0 2
111332: ARRAY
111333: PUSH
111334: LD_INT 3
111336: ARRAY
111337: STR
111338: PUSH
111339: LD_STRING ,
111341: STR
111342: PUSH
111343: LD_VAR 0 3
111347: PUSH
111348: LD_VAR 0 2
111352: ARRAY
111353: PUSH
111354: LD_INT 4
111356: ARRAY
111357: STR
111358: PUSH
111359: LD_STRING )
111361: STR
111362: PPUSH
111363: CALL_OW 559
111367: GO 111277
111369: POP
111370: POP
// end ; end ;
111371: LD_VAR 0 1
111375: RET
// every 0 0$20 trigger warehouseGatheringPoints do var i , j , list , tmp , side , x , y , depot , cratesNearbyPoint ;
111376: LD_EXP 185
111380: IFFALSE 112065
111382: GO 111384
111384: DISABLE
111385: LD_INT 0
111387: PPUSH
111388: PPUSH
111389: PPUSH
111390: PPUSH
111391: PPUSH
111392: PPUSH
111393: PPUSH
111394: PPUSH
111395: PPUSH
// begin enable ;
111396: ENABLE
// list := PrepareArray ( warehouseGatheringPoints ) ;
111397: LD_ADDR_VAR 0 3
111401: PUSH
111402: LD_EXP 185
111406: PPUSH
111407: CALL 94927 0 1
111411: ST_TO_ADDR
// if not list then
111412: LD_VAR 0 3
111416: NOT
111417: IFFALSE 111421
// exit ;
111419: GO 112065
// for i := 1 to list do
111421: LD_ADDR_VAR 0 1
111425: PUSH
111426: DOUBLE
111427: LD_INT 1
111429: DEC
111430: ST_TO_ADDR
111431: LD_VAR 0 3
111435: PUSH
111436: FOR_TO
111437: IFFALSE 112063
// begin depot := list [ i ] [ 2 ] ;
111439: LD_ADDR_VAR 0 8
111443: PUSH
111444: LD_VAR 0 3
111448: PUSH
111449: LD_VAR 0 1
111453: ARRAY
111454: PUSH
111455: LD_INT 2
111457: ARRAY
111458: ST_TO_ADDR
// side := list [ i ] [ 1 ] ;
111459: LD_ADDR_VAR 0 5
111463: PUSH
111464: LD_VAR 0 3
111468: PUSH
111469: LD_VAR 0 1
111473: ARRAY
111474: PUSH
111475: LD_INT 1
111477: ARRAY
111478: ST_TO_ADDR
// if IsDead ( depot ) or side <> GetSide ( depot ) then
111479: LD_VAR 0 8
111483: PPUSH
111484: CALL_OW 301
111488: PUSH
111489: LD_VAR 0 5
111493: PUSH
111494: LD_VAR 0 8
111498: PPUSH
111499: CALL_OW 255
111503: NONEQUAL
111504: OR
111505: IFFALSE 111534
// begin warehouseGatheringPoints := Replace ( warehouseGatheringPoints , depot , 0 ) ;
111507: LD_ADDR_EXP 185
111511: PUSH
111512: LD_EXP 185
111516: PPUSH
111517: LD_VAR 0 8
111521: PPUSH
111522: LD_INT 0
111524: PPUSH
111525: CALL_OW 1
111529: ST_TO_ADDR
// exit ;
111530: POP
111531: POP
111532: GO 112065
// end ; x := list [ i ] [ 3 ] ;
111534: LD_ADDR_VAR 0 6
111538: PUSH
111539: LD_VAR 0 3
111543: PUSH
111544: LD_VAR 0 1
111548: ARRAY
111549: PUSH
111550: LD_INT 3
111552: ARRAY
111553: ST_TO_ADDR
// y := list [ i ] [ 4 ] ;
111554: LD_ADDR_VAR 0 7
111558: PUSH
111559: LD_VAR 0 3
111563: PUSH
111564: LD_VAR 0 1
111568: ARRAY
111569: PUSH
111570: LD_INT 4
111572: ARRAY
111573: ST_TO_ADDR
// cratesNearbyPoint := GetCratesNearbyXY ( x , y , 16 ) ;
111574: LD_ADDR_VAR 0 9
111578: PUSH
111579: LD_VAR 0 6
111583: PPUSH
111584: LD_VAR 0 7
111588: PPUSH
111589: LD_INT 16
111591: PPUSH
111592: CALL 93515 0 3
111596: ST_TO_ADDR
// if not cratesNearbyPoint then
111597: LD_VAR 0 9
111601: NOT
111602: IFFALSE 111608
// exit ;
111604: POP
111605: POP
111606: GO 112065
// tmp := FilterAllUnits ( [ [ f_side , side ] , [ f_not , [ f_hastask ] ] , [ f_dist , depot , 6 ] , [ f_or , [ f_class , class_engineer ] , [ f_class , class_apeman_engineer ] ] ] ) union UnitFilter ( UnitsInside ( depot ) , [ [ f_not , [ f_hastask ] ] , [ f_or , [ f_class , class_engineer ] , [ f_class , class_apeman_engineer ] ] ] ) ;
111608: LD_ADDR_VAR 0 4
111612: PUSH
111613: LD_INT 22
111615: PUSH
111616: LD_VAR 0 5
111620: PUSH
111621: EMPTY
111622: LIST
111623: LIST
111624: PUSH
111625: LD_INT 3
111627: PUSH
111628: LD_INT 60
111630: PUSH
111631: EMPTY
111632: LIST
111633: PUSH
111634: EMPTY
111635: LIST
111636: LIST
111637: PUSH
111638: LD_INT 91
111640: PUSH
111641: LD_VAR 0 8
111645: PUSH
111646: LD_INT 6
111648: PUSH
111649: EMPTY
111650: LIST
111651: LIST
111652: LIST
111653: PUSH
111654: LD_INT 2
111656: PUSH
111657: LD_INT 25
111659: PUSH
111660: LD_INT 2
111662: PUSH
111663: EMPTY
111664: LIST
111665: LIST
111666: PUSH
111667: LD_INT 25
111669: PUSH
111670: LD_INT 16
111672: PUSH
111673: EMPTY
111674: LIST
111675: LIST
111676: PUSH
111677: EMPTY
111678: LIST
111679: LIST
111680: LIST
111681: PUSH
111682: EMPTY
111683: LIST
111684: LIST
111685: LIST
111686: LIST
111687: PPUSH
111688: CALL_OW 69
111692: PUSH
111693: LD_VAR 0 8
111697: PPUSH
111698: CALL_OW 313
111702: PPUSH
111703: LD_INT 3
111705: PUSH
111706: LD_INT 60
111708: PUSH
111709: EMPTY
111710: LIST
111711: PUSH
111712: EMPTY
111713: LIST
111714: LIST
111715: PUSH
111716: LD_INT 2
111718: PUSH
111719: LD_INT 25
111721: PUSH
111722: LD_INT 2
111724: PUSH
111725: EMPTY
111726: LIST
111727: LIST
111728: PUSH
111729: LD_INT 25
111731: PUSH
111732: LD_INT 16
111734: PUSH
111735: EMPTY
111736: LIST
111737: LIST
111738: PUSH
111739: EMPTY
111740: LIST
111741: LIST
111742: LIST
111743: PUSH
111744: EMPTY
111745: LIST
111746: LIST
111747: PPUSH
111748: CALL_OW 72
111752: UNION
111753: ST_TO_ADDR
// if tmp then
111754: LD_VAR 0 4
111758: IFFALSE 111838
// begin tmp := ShrinkArray ( tmp , 3 ) ;
111760: LD_ADDR_VAR 0 4
111764: PUSH
111765: LD_VAR 0 4
111769: PPUSH
111770: LD_INT 3
111772: PPUSH
111773: CALL 91484 0 2
111777: ST_TO_ADDR
// for j in tmp do
111778: LD_ADDR_VAR 0 2
111782: PUSH
111783: LD_VAR 0 4
111787: PUSH
111788: FOR_IN
111789: IFFALSE 111832
// begin if IsInUnit ( j ) then
111791: LD_VAR 0 2
111795: PPUSH
111796: CALL_OW 310
111800: IFFALSE 111811
// ComExit ( j ) ;
111802: LD_VAR 0 2
111806: PPUSH
111807: CALL 91567 0 1
// AddComCollect ( j , x , y ) ;
111811: LD_VAR 0 2
111815: PPUSH
111816: LD_VAR 0 6
111820: PPUSH
111821: LD_VAR 0 7
111825: PPUSH
111826: CALL_OW 177
// end ;
111830: GO 111788
111832: POP
111833: POP
// exit ;
111834: POP
111835: POP
111836: GO 112065
// end ; tmp := FilterAllUnits ( [ [ f_side , side ] , [ f_dist , depot , 8 ] , [ f_or , [ f_weapon , us_cargo_bay ] , [ f_weapon , ru_cargo_bay ] , [ f_weapon , ar_cargo_bay ] , [ f_weapon , ru_big_cargo_bay ] ] ] ) ;
111838: LD_ADDR_VAR 0 4
111842: PUSH
111843: LD_INT 22
111845: PUSH
111846: LD_VAR 0 5
111850: PUSH
111851: EMPTY
111852: LIST
111853: LIST
111854: PUSH
111855: LD_INT 91
111857: PUSH
111858: LD_VAR 0 8
111862: PUSH
111863: LD_INT 8
111865: PUSH
111866: EMPTY
111867: LIST
111868: LIST
111869: LIST
111870: PUSH
111871: LD_INT 2
111873: PUSH
111874: LD_INT 34
111876: PUSH
111877: LD_INT 12
111879: PUSH
111880: EMPTY
111881: LIST
111882: LIST
111883: PUSH
111884: LD_INT 34
111886: PUSH
111887: LD_INT 51
111889: PUSH
111890: EMPTY
111891: LIST
111892: LIST
111893: PUSH
111894: LD_INT 34
111896: PUSH
111897: LD_INT 32
111899: PUSH
111900: EMPTY
111901: LIST
111902: LIST
111903: PUSH
111904: LD_INT 34
111906: PUSH
111907: LD_INT 89
111909: PUSH
111910: EMPTY
111911: LIST
111912: LIST
111913: PUSH
111914: EMPTY
111915: LIST
111916: LIST
111917: LIST
111918: LIST
111919: LIST
111920: PUSH
111921: EMPTY
111922: LIST
111923: LIST
111924: LIST
111925: PPUSH
111926: CALL_OW 69
111930: ST_TO_ADDR
// if tmp then
111931: LD_VAR 0 4
111935: IFFALSE 112061
// begin for j in tmp do
111937: LD_ADDR_VAR 0 2
111941: PUSH
111942: LD_VAR 0 4
111946: PUSH
111947: FOR_IN
111948: IFFALSE 112059
// if ( GetEngine ( j ) = engine_siberite or GetFuel ( j ) > 20 ) and not HasTask ( j ) and ( GetControl ( j ) <> control_manual or IsDrivenBy ( j ) ) then
111950: LD_VAR 0 2
111954: PPUSH
111955: CALL_OW 262
111959: PUSH
111960: LD_INT 3
111962: EQUAL
111963: PUSH
111964: LD_VAR 0 2
111968: PPUSH
111969: CALL_OW 261
111973: PUSH
111974: LD_INT 20
111976: GREATER
111977: OR
111978: PUSH
111979: LD_VAR 0 2
111983: PPUSH
111984: CALL_OW 314
111988: NOT
111989: AND
111990: PUSH
111991: LD_VAR 0 2
111995: PPUSH
111996: CALL_OW 263
112000: PUSH
112001: LD_INT 1
112003: NONEQUAL
112004: PUSH
112005: LD_VAR 0 2
112009: PPUSH
112010: CALL_OW 311
112014: OR
112015: AND
112016: IFFALSE 112057
// begin ComCollect ( j , x , y ) ;
112018: LD_VAR 0 2
112022: PPUSH
112023: LD_VAR 0 6
112027: PPUSH
112028: LD_VAR 0 7
112032: PPUSH
112033: CALL_OW 117
// AddComMoveUnit ( j , depot ) ;
112037: LD_VAR 0 2
112041: PPUSH
112042: LD_VAR 0 8
112046: PPUSH
112047: CALL_OW 172
// exit ;
112051: POP
112052: POP
112053: POP
112054: POP
112055: GO 112065
// end ;
112057: GO 111947
112059: POP
112060: POP
// end ; end ;
112061: GO 111436
112063: POP
112064: POP
// end ; end_of_file
112065: PPOPN 9
112067: END
// export function SOS_UnitDestroyed ( un ) ; var i , eff , side ; begin
112068: LD_INT 0
112070: PPUSH
112071: PPUSH
112072: PPUSH
112073: PPUSH
// if GetWeapon ( un ) = ar_bio_bomb then
112074: LD_VAR 0 1
112078: PPUSH
112079: CALL_OW 264
112083: PUSH
112084: LD_INT 91
112086: EQUAL
112087: IFFALSE 112159
// begin if GetTech ( tech_bio3 , GetSide ( un ) ) = state_researched then
112089: LD_INT 68
112091: PPUSH
112092: LD_VAR 0 1
112096: PPUSH
112097: CALL_OW 255
112101: PPUSH
112102: CALL_OW 321
112106: PUSH
112107: LD_INT 2
112109: EQUAL
112110: IFFALSE 112122
// eff := 70 else
112112: LD_ADDR_VAR 0 4
112116: PUSH
112117: LD_INT 70
112119: ST_TO_ADDR
112120: GO 112130
// eff := 30 ;
112122: LD_ADDR_VAR 0 4
112126: PUSH
112127: LD_INT 30
112129: ST_TO_ADDR
// ArtContamination ( GetX ( un ) , GetY ( un ) , eff ) ;
112130: LD_VAR 0 1
112134: PPUSH
112135: CALL_OW 250
112139: PPUSH
112140: LD_VAR 0 1
112144: PPUSH
112145: CALL_OW 251
112149: PPUSH
112150: LD_VAR 0 4
112154: PPUSH
112155: CALL_OW 495
// end ; end ;
112159: LD_VAR 0 2
112163: RET
// export function SOS_UnitExtraDestroyed ( un , killerSide , killerUnit ) ; begin
112164: LD_INT 0
112166: PPUSH
// end ;
112167: LD_VAR 0 4
112171: RET
// export function SOS_Command ( cmd ) ; begin
112172: LD_INT 0
112174: PPUSH
// end ;
112175: LD_VAR 0 2
112179: RET
// export function SOS_CommandUnitXY ( cmd , un , target , x , y ) ; begin
112180: LD_INT 0
112182: PPUSH
// end ;
112183: LD_VAR 0 6
112187: RET
// export function SOS_VehicleConstructed ( vehicle , factory ) ; var driver ; begin
112188: LD_INT 0
112190: PPUSH
112191: PPUSH
// if not vehicle or not factory then
112192: LD_VAR 0 1
112196: NOT
112197: PUSH
112198: LD_VAR 0 2
112202: NOT
112203: OR
112204: IFFALSE 112208
// exit ;
112206: GO 112439
// if factoryWaypoints >= factory then
112208: LD_EXP 184
112212: PUSH
112213: LD_VAR 0 2
112217: GREATEREQUAL
112218: IFFALSE 112439
// if factoryWaypoints [ factory ] then
112220: LD_EXP 184
112224: PUSH
112225: LD_VAR 0 2
112229: ARRAY
112230: IFFALSE 112439
// begin if GetControl ( vehicle ) = control_manual then
112232: LD_VAR 0 1
112236: PPUSH
112237: CALL_OW 263
112241: PUSH
112242: LD_INT 1
112244: EQUAL
112245: IFFALSE 112326
// begin driver := IsDrivenBy ( vehicle ) ;
112247: LD_ADDR_VAR 0 4
112251: PUSH
112252: LD_VAR 0 1
112256: PPUSH
112257: CALL_OW 311
112261: ST_TO_ADDR
// AddComMoveXY ( driver , factoryWaypoints [ factory ] [ 3 ] , factoryWaypoints [ factory ] [ 4 ] ) ;
112262: LD_VAR 0 4
112266: PPUSH
112267: LD_EXP 184
112271: PUSH
112272: LD_VAR 0 2
112276: ARRAY
112277: PUSH
112278: LD_INT 3
112280: ARRAY
112281: PPUSH
112282: LD_EXP 184
112286: PUSH
112287: LD_VAR 0 2
112291: ARRAY
112292: PUSH
112293: LD_INT 4
112295: ARRAY
112296: PPUSH
112297: CALL_OW 171
// AddComExitVehicle ( driver ) ;
112301: LD_VAR 0 4
112305: PPUSH
112306: CALL_OW 181
// AddComEnterUnit ( driver , factory ) ;
112310: LD_VAR 0 4
112314: PPUSH
112315: LD_VAR 0 2
112319: PPUSH
112320: CALL_OW 180
// end else
112324: GO 112439
// if GetControl ( vehicle ) = control_remote then
112326: LD_VAR 0 1
112330: PPUSH
112331: CALL_OW 263
112335: PUSH
112336: LD_INT 2
112338: EQUAL
112339: IFFALSE 112400
// begin wait ( 0 0$2 ) ;
112341: LD_INT 70
112343: PPUSH
112344: CALL_OW 67
// if Connect ( vehicle ) then
112348: LD_VAR 0 1
112352: PPUSH
112353: CALL 61786 0 1
112357: IFFALSE 112398
// AddComMoveXY ( vehicle , factoryWaypoints [ factory ] [ 3 ] , factoryWaypoints [ factory ] [ 4 ] ) ;
112359: LD_VAR 0 1
112363: PPUSH
112364: LD_EXP 184
112368: PUSH
112369: LD_VAR 0 2
112373: ARRAY
112374: PUSH
112375: LD_INT 3
112377: ARRAY
112378: PPUSH
112379: LD_EXP 184
112383: PUSH
112384: LD_VAR 0 2
112388: ARRAY
112389: PUSH
112390: LD_INT 4
112392: ARRAY
112393: PPUSH
112394: CALL_OW 171
// end else
112398: GO 112439
// AddComMoveXY ( vehicle , factoryWaypoints [ factory ] [ 3 ] , factoryWaypoints [ factory ] [ 4 ] ) ;
112400: LD_VAR 0 1
112404: PPUSH
112405: LD_EXP 184
112409: PUSH
112410: LD_VAR 0 2
112414: ARRAY
112415: PUSH
112416: LD_INT 3
112418: ARRAY
112419: PPUSH
112420: LD_EXP 184
112424: PUSH
112425: LD_VAR 0 2
112429: ARRAY
112430: PUSH
112431: LD_INT 4
112433: ARRAY
112434: PPUSH
112435: CALL_OW 171
// end ; end ;
112439: LD_VAR 0 3
112443: RET
// export function SOS_TargetableSAIL ( cmd , unit , selectedUnit , x , y ) ; begin
112444: LD_INT 0
112446: PPUSH
// if cmd = 250 and GetWeapon ( unit ) = ar_miner then
112447: LD_VAR 0 1
112451: PUSH
112452: LD_INT 250
112454: EQUAL
112455: PUSH
112456: LD_VAR 0 2
112460: PPUSH
112461: CALL_OW 264
112465: PUSH
112466: LD_INT 81
112468: EQUAL
112469: AND
112470: IFFALSE 112491
// MinerPlaceMine ( unit , x , y ) ;
112472: LD_VAR 0 2
112476: PPUSH
112477: LD_VAR 0 4
112481: PPUSH
112482: LD_VAR 0 5
112486: PPUSH
112487: CALL 115481 0 3
// if cmd = 251 and GetWeapon ( unit ) = ar_miner then
112491: LD_VAR 0 1
112495: PUSH
112496: LD_INT 251
112498: EQUAL
112499: PUSH
112500: LD_VAR 0 2
112504: PPUSH
112505: CALL_OW 264
112509: PUSH
112510: LD_INT 81
112512: EQUAL
112513: AND
112514: IFFALSE 112535
// MinerDetonateMine ( unit , x , y ) ;
112516: LD_VAR 0 2
112520: PPUSH
112521: LD_VAR 0 4
112525: PPUSH
112526: LD_VAR 0 5
112530: PPUSH
112531: CALL 115756 0 3
// if cmd = 252 and GetWeapon ( unit ) = ar_miner then
112535: LD_VAR 0 1
112539: PUSH
112540: LD_INT 252
112542: EQUAL
112543: PUSH
112544: LD_VAR 0 2
112548: PPUSH
112549: CALL_OW 264
112553: PUSH
112554: LD_INT 81
112556: EQUAL
112557: AND
112558: IFFALSE 112579
// MinerCreateMinefield ( unit , x , y ) ;
112560: LD_VAR 0 2
112564: PPUSH
112565: LD_VAR 0 4
112569: PPUSH
112570: LD_VAR 0 5
112574: PPUSH
112575: CALL 116173 0 3
// if cmd = 253 and GetClass ( unit ) = class_sniper then
112579: LD_VAR 0 1
112583: PUSH
112584: LD_INT 253
112586: EQUAL
112587: PUSH
112588: LD_VAR 0 2
112592: PPUSH
112593: CALL_OW 257
112597: PUSH
112598: LD_INT 5
112600: EQUAL
112601: AND
112602: IFFALSE 112623
// ComBinocular ( unit , x , y ) ;
112604: LD_VAR 0 2
112608: PPUSH
112609: LD_VAR 0 4
112613: PPUSH
112614: LD_VAR 0 5
112618: PPUSH
112619: CALL 116542 0 3
// if cmd = 254 and GetWeapon ( unit ) = us_hack and GetControl ( selectedUnit ) = control_computer then
112623: LD_VAR 0 1
112627: PUSH
112628: LD_INT 254
112630: EQUAL
112631: PUSH
112632: LD_VAR 0 2
112636: PPUSH
112637: CALL_OW 264
112641: PUSH
112642: LD_INT 99
112644: EQUAL
112645: AND
112646: PUSH
112647: LD_VAR 0 3
112651: PPUSH
112652: CALL_OW 263
112656: PUSH
112657: LD_INT 3
112659: EQUAL
112660: AND
112661: IFFALSE 112677
// HackDestroyVehicle ( unit , selectedUnit ) ;
112663: LD_VAR 0 2
112667: PPUSH
112668: LD_VAR 0 3
112672: PPUSH
112673: CALL 114845 0 2
// if cmd = 255 and GetWeapon ( unit ) in [ us_bulldozer , ru_bulldozer ] and ValidHex ( x , y ) then
112677: LD_VAR 0 1
112681: PUSH
112682: LD_INT 255
112684: EQUAL
112685: PUSH
112686: LD_VAR 0 2
112690: PPUSH
112691: CALL_OW 264
112695: PUSH
112696: LD_INT 14
112698: PUSH
112699: LD_INT 53
112701: PUSH
112702: EMPTY
112703: LIST
112704: LIST
112705: IN
112706: AND
112707: PUSH
112708: LD_VAR 0 4
112712: PPUSH
112713: LD_VAR 0 5
112717: PPUSH
112718: CALL_OW 488
112722: AND
112723: IFFALSE 112747
// CutTreeXYR ( unit , x , y , 12 ) ;
112725: LD_VAR 0 2
112729: PPUSH
112730: LD_VAR 0 4
112734: PPUSH
112735: LD_VAR 0 5
112739: PPUSH
112740: LD_INT 12
112742: PPUSH
112743: CALL 112842 0 4
// if cmd = 256 then
112747: LD_VAR 0 1
112751: PUSH
112752: LD_INT 256
112754: EQUAL
112755: IFFALSE 112776
// SetFactoryWaypoint ( unit , x , y ) ;
112757: LD_VAR 0 2
112761: PPUSH
112762: LD_VAR 0 4
112766: PPUSH
112767: LD_VAR 0 5
112771: PPUSH
112772: CALL 110757 0 3
// if cmd = 257 then
112776: LD_VAR 0 1
112780: PUSH
112781: LD_INT 257
112783: EQUAL
112784: IFFALSE 112805
// SetWarehouseGatheringPoint ( unit , x , y ) ;
112786: LD_VAR 0 2
112790: PPUSH
112791: LD_VAR 0 4
112795: PPUSH
112796: LD_VAR 0 5
112800: PPUSH
112801: CALL 111119 0 3
// if cmd = 258 then
112805: LD_VAR 0 1
112809: PUSH
112810: LD_INT 258
112812: EQUAL
112813: IFFALSE 112837
// BurnTreeXYR ( unit , x , y , 8 ) ;
112815: LD_VAR 0 2
112819: PPUSH
112820: LD_VAR 0 4
112824: PPUSH
112825: LD_VAR 0 5
112829: PPUSH
112830: LD_INT 8
112832: PPUSH
112833: CALL 113236 0 4
// end ;
112837: LD_VAR 0 6
112841: RET
// function CutTreeXYR ( bulldozer , x , y , r ) ; var i , min_x , min_y , max_x , max_y , _x , _y , list ; begin
112842: LD_INT 0
112844: PPUSH
112845: PPUSH
112846: PPUSH
112847: PPUSH
112848: PPUSH
112849: PPUSH
112850: PPUSH
112851: PPUSH
112852: PPUSH
// if not IsOk ( bulldozer ) or not ValidHex ( x , y ) or not r then
112853: LD_VAR 0 1
112857: PPUSH
112858: CALL_OW 302
112862: NOT
112863: PUSH
112864: LD_VAR 0 2
112868: PPUSH
112869: LD_VAR 0 3
112873: PPUSH
112874: CALL_OW 488
112878: NOT
112879: OR
112880: PUSH
112881: LD_VAR 0 4
112885: NOT
112886: OR
112887: IFFALSE 112891
// exit ;
112889: GO 113231
// list := [ ] ;
112891: LD_ADDR_VAR 0 13
112895: PUSH
112896: EMPTY
112897: ST_TO_ADDR
// if x - r < 0 then
112898: LD_VAR 0 2
112902: PUSH
112903: LD_VAR 0 4
112907: MINUS
112908: PUSH
112909: LD_INT 0
112911: LESS
112912: IFFALSE 112924
// min_x := 0 else
112914: LD_ADDR_VAR 0 7
112918: PUSH
112919: LD_INT 0
112921: ST_TO_ADDR
112922: GO 112940
// min_x := x - r ;
112924: LD_ADDR_VAR 0 7
112928: PUSH
112929: LD_VAR 0 2
112933: PUSH
112934: LD_VAR 0 4
112938: MINUS
112939: ST_TO_ADDR
// if y - r < 0 then
112940: LD_VAR 0 3
112944: PUSH
112945: LD_VAR 0 4
112949: MINUS
112950: PUSH
112951: LD_INT 0
112953: LESS
112954: IFFALSE 112966
// min_y := 0 else
112956: LD_ADDR_VAR 0 8
112960: PUSH
112961: LD_INT 0
112963: ST_TO_ADDR
112964: GO 112982
// min_y := y - r ;
112966: LD_ADDR_VAR 0 8
112970: PUSH
112971: LD_VAR 0 3
112975: PUSH
112976: LD_VAR 0 4
112980: MINUS
112981: ST_TO_ADDR
// max_x := x + r ;
112982: LD_ADDR_VAR 0 9
112986: PUSH
112987: LD_VAR 0 2
112991: PUSH
112992: LD_VAR 0 4
112996: PLUS
112997: ST_TO_ADDR
// max_y := y + r ;
112998: LD_ADDR_VAR 0 10
113002: PUSH
113003: LD_VAR 0 3
113007: PUSH
113008: LD_VAR 0 4
113012: PLUS
113013: ST_TO_ADDR
// for _x = min_x to max_x do
113014: LD_ADDR_VAR 0 11
113018: PUSH
113019: DOUBLE
113020: LD_VAR 0 7
113024: DEC
113025: ST_TO_ADDR
113026: LD_VAR 0 9
113030: PUSH
113031: FOR_TO
113032: IFFALSE 113149
// for _y = min_y to max_y do
113034: LD_ADDR_VAR 0 12
113038: PUSH
113039: DOUBLE
113040: LD_VAR 0 8
113044: DEC
113045: ST_TO_ADDR
113046: LD_VAR 0 10
113050: PUSH
113051: FOR_TO
113052: IFFALSE 113145
// begin if not ValidHex ( _x , _y ) then
113054: LD_VAR 0 11
113058: PPUSH
113059: LD_VAR 0 12
113063: PPUSH
113064: CALL_OW 488
113068: NOT
113069: IFFALSE 113073
// continue ;
113071: GO 113051
// if IsEnvironment ( _x , _y ) and IsEnvironmentDestroyable ( _x , _y ) then
113073: LD_VAR 0 11
113077: PPUSH
113078: LD_VAR 0 12
113082: PPUSH
113083: CALL_OW 351
113087: PUSH
113088: LD_VAR 0 11
113092: PPUSH
113093: LD_VAR 0 12
113097: PPUSH
113098: CALL_OW 554
113102: AND
113103: IFFALSE 113143
// list := Insert ( list , list + 1 , [ _x , _y ] ) ;
113105: LD_ADDR_VAR 0 13
113109: PUSH
113110: LD_VAR 0 13
113114: PPUSH
113115: LD_VAR 0 13
113119: PUSH
113120: LD_INT 1
113122: PLUS
113123: PPUSH
113124: LD_VAR 0 11
113128: PUSH
113129: LD_VAR 0 12
113133: PUSH
113134: EMPTY
113135: LIST
113136: LIST
113137: PPUSH
113138: CALL_OW 2
113142: ST_TO_ADDR
// end ;
113143: GO 113051
113145: POP
113146: POP
113147: GO 113031
113149: POP
113150: POP
// if not list then
113151: LD_VAR 0 13
113155: NOT
113156: IFFALSE 113160
// exit ;
113158: GO 113231
// for i in list do
113160: LD_ADDR_VAR 0 6
113164: PUSH
113165: LD_VAR 0 13
113169: PUSH
113170: FOR_IN
113171: IFFALSE 113229
// AddTaskList ( bulldozer , [ [ M , i [ 1 ] , i [ 2 ] , 0 , 0 , 0 , 0 ] ] ) ;
113173: LD_VAR 0 1
113177: PPUSH
113178: LD_STRING M
113180: PUSH
113181: LD_VAR 0 6
113185: PUSH
113186: LD_INT 1
113188: ARRAY
113189: PUSH
113190: LD_VAR 0 6
113194: PUSH
113195: LD_INT 2
113197: ARRAY
113198: PUSH
113199: LD_INT 0
113201: PUSH
113202: LD_INT 0
113204: PUSH
113205: LD_INT 0
113207: PUSH
113208: LD_INT 0
113210: PUSH
113211: EMPTY
113212: LIST
113213: LIST
113214: LIST
113215: LIST
113216: LIST
113217: LIST
113218: LIST
113219: PUSH
113220: EMPTY
113221: LIST
113222: PPUSH
113223: CALL_OW 447
113227: GO 113170
113229: POP
113230: POP
// end ;
113231: LD_VAR 0 5
113235: RET
// function BurnTreeXYR ( flame , x , y , r ) ; var i , min_x , min_y , max_x , max_y , _x , _y , list , task ; begin
113236: LD_INT 0
113238: PPUSH
113239: PPUSH
113240: PPUSH
113241: PPUSH
113242: PPUSH
113243: PPUSH
113244: PPUSH
113245: PPUSH
113246: PPUSH
113247: PPUSH
// if not IsOk ( flame ) or not ValidHex ( x , y ) or not r then
113248: LD_VAR 0 1
113252: PPUSH
113253: CALL_OW 302
113257: NOT
113258: PUSH
113259: LD_VAR 0 2
113263: PPUSH
113264: LD_VAR 0 3
113268: PPUSH
113269: CALL_OW 488
113273: NOT
113274: OR
113275: PUSH
113276: LD_VAR 0 4
113280: NOT
113281: OR
113282: IFFALSE 113286
// exit ;
113284: GO 113799
// list := [ ] ;
113286: LD_ADDR_VAR 0 13
113290: PUSH
113291: EMPTY
113292: ST_TO_ADDR
// if x - r < 0 then
113293: LD_VAR 0 2
113297: PUSH
113298: LD_VAR 0 4
113302: MINUS
113303: PUSH
113304: LD_INT 0
113306: LESS
113307: IFFALSE 113319
// min_x := 0 else
113309: LD_ADDR_VAR 0 7
113313: PUSH
113314: LD_INT 0
113316: ST_TO_ADDR
113317: GO 113335
// min_x := x - r ;
113319: LD_ADDR_VAR 0 7
113323: PUSH
113324: LD_VAR 0 2
113328: PUSH
113329: LD_VAR 0 4
113333: MINUS
113334: ST_TO_ADDR
// if y - r < 0 then
113335: LD_VAR 0 3
113339: PUSH
113340: LD_VAR 0 4
113344: MINUS
113345: PUSH
113346: LD_INT 0
113348: LESS
113349: IFFALSE 113361
// min_y := 0 else
113351: LD_ADDR_VAR 0 8
113355: PUSH
113356: LD_INT 0
113358: ST_TO_ADDR
113359: GO 113377
// min_y := y - r ;
113361: LD_ADDR_VAR 0 8
113365: PUSH
113366: LD_VAR 0 3
113370: PUSH
113371: LD_VAR 0 4
113375: MINUS
113376: ST_TO_ADDR
// max_x := x + r ;
113377: LD_ADDR_VAR 0 9
113381: PUSH
113382: LD_VAR 0 2
113386: PUSH
113387: LD_VAR 0 4
113391: PLUS
113392: ST_TO_ADDR
// max_y := y + r ;
113393: LD_ADDR_VAR 0 10
113397: PUSH
113398: LD_VAR 0 3
113402: PUSH
113403: LD_VAR 0 4
113407: PLUS
113408: ST_TO_ADDR
// for _x = min_x to max_x do
113409: LD_ADDR_VAR 0 11
113413: PUSH
113414: DOUBLE
113415: LD_VAR 0 7
113419: DEC
113420: ST_TO_ADDR
113421: LD_VAR 0 9
113425: PUSH
113426: FOR_TO
113427: IFFALSE 113544
// for _y = min_y to max_y do
113429: LD_ADDR_VAR 0 12
113433: PUSH
113434: DOUBLE
113435: LD_VAR 0 8
113439: DEC
113440: ST_TO_ADDR
113441: LD_VAR 0 10
113445: PUSH
113446: FOR_TO
113447: IFFALSE 113540
// begin if not ValidHex ( _x , _y ) then
113449: LD_VAR 0 11
113453: PPUSH
113454: LD_VAR 0 12
113458: PPUSH
113459: CALL_OW 488
113463: NOT
113464: IFFALSE 113468
// continue ;
113466: GO 113446
// if IsEnvironment ( _x , _y ) and IsEnvironmentDestroyable ( _x , _y ) then
113468: LD_VAR 0 11
113472: PPUSH
113473: LD_VAR 0 12
113477: PPUSH
113478: CALL_OW 351
113482: PUSH
113483: LD_VAR 0 11
113487: PPUSH
113488: LD_VAR 0 12
113492: PPUSH
113493: CALL_OW 554
113497: AND
113498: IFFALSE 113538
// list := Insert ( list , list + 1 , [ _x , _y ] ) ;
113500: LD_ADDR_VAR 0 13
113504: PUSH
113505: LD_VAR 0 13
113509: PPUSH
113510: LD_VAR 0 13
113514: PUSH
113515: LD_INT 1
113517: PLUS
113518: PPUSH
113519: LD_VAR 0 11
113523: PUSH
113524: LD_VAR 0 12
113528: PUSH
113529: EMPTY
113530: LIST
113531: LIST
113532: PPUSH
113533: CALL_OW 2
113537: ST_TO_ADDR
// end ;
113538: GO 113446
113540: POP
113541: POP
113542: GO 113426
113544: POP
113545: POP
// if not list then
113546: LD_VAR 0 13
113550: NOT
113551: IFFALSE 113555
// exit ;
113553: GO 113799
// list := SortHexesByDistanceFromUnit ( flame , list , true , true ) ;
113555: LD_ADDR_VAR 0 13
113559: PUSH
113560: LD_VAR 0 1
113564: PPUSH
113565: LD_VAR 0 13
113569: PPUSH
113570: LD_INT 1
113572: PPUSH
113573: LD_INT 1
113575: PPUSH
113576: CALL 58928 0 4
113580: ST_TO_ADDR
// ComStop ( flame ) ;
113581: LD_VAR 0 1
113585: PPUSH
113586: CALL_OW 141
// for i in list do
113590: LD_ADDR_VAR 0 6
113594: PUSH
113595: LD_VAR 0 13
113599: PUSH
113600: FOR_IN
113601: IFFALSE 113632
// AddComAttackPlace ( flame , i [ 1 ] , i [ 2 ] ) ;
113603: LD_VAR 0 1
113607: PPUSH
113608: LD_VAR 0 6
113612: PUSH
113613: LD_INT 1
113615: ARRAY
113616: PPUSH
113617: LD_VAR 0 6
113621: PUSH
113622: LD_INT 2
113624: ARRAY
113625: PPUSH
113626: CALL_OW 176
113630: GO 113600
113632: POP
113633: POP
// repeat wait ( 0 0$1 ) ;
113634: LD_INT 35
113636: PPUSH
113637: CALL_OW 67
// task := GetTaskList ( flame ) ;
113641: LD_ADDR_VAR 0 14
113645: PUSH
113646: LD_VAR 0 1
113650: PPUSH
113651: CALL_OW 437
113655: ST_TO_ADDR
// if not task then
113656: LD_VAR 0 14
113660: NOT
113661: IFFALSE 113665
// exit ;
113663: GO 113799
// if task [ 1 ] [ 1 ] <> | then
113665: LD_VAR 0 14
113669: PUSH
113670: LD_INT 1
113672: ARRAY
113673: PUSH
113674: LD_INT 1
113676: ARRAY
113677: PUSH
113678: LD_STRING |
113680: NONEQUAL
113681: IFFALSE 113685
// exit ;
113683: GO 113799
// _x := task [ 1 ] [ 2 ] ;
113685: LD_ADDR_VAR 0 11
113689: PUSH
113690: LD_VAR 0 14
113694: PUSH
113695: LD_INT 1
113697: ARRAY
113698: PUSH
113699: LD_INT 2
113701: ARRAY
113702: ST_TO_ADDR
// _y := task [ 1 ] [ 3 ] ;
113703: LD_ADDR_VAR 0 12
113707: PUSH
113708: LD_VAR 0 14
113712: PUSH
113713: LD_INT 1
113715: ARRAY
113716: PUSH
113717: LD_INT 3
113719: ARRAY
113720: ST_TO_ADDR
// if not IsEnvironment ( _x , _y ) or not IsEnvironmentDestroyable ( _x , _y ) then
113721: LD_VAR 0 11
113725: PPUSH
113726: LD_VAR 0 12
113730: PPUSH
113731: CALL_OW 351
113735: NOT
113736: PUSH
113737: LD_VAR 0 11
113741: PPUSH
113742: LD_VAR 0 12
113746: PPUSH
113747: CALL_OW 554
113751: NOT
113752: OR
113753: IFFALSE 113787
// begin task := Delete ( task , 1 ) ;
113755: LD_ADDR_VAR 0 14
113759: PUSH
113760: LD_VAR 0 14
113764: PPUSH
113765: LD_INT 1
113767: PPUSH
113768: CALL_OW 3
113772: ST_TO_ADDR
// SetTaskList ( flame , task ) ;
113773: LD_VAR 0 1
113777: PPUSH
113778: LD_VAR 0 14
113782: PPUSH
113783: CALL_OW 446
// end ; until not HasTask ( flame ) ;
113787: LD_VAR 0 1
113791: PPUSH
113792: CALL_OW 314
113796: NOT
113797: IFFALSE 113634
// end ;
113799: LD_VAR 0 5
113803: RET
// export initHack , hackTanks , hackTanksCaptured , hackLimit , hackDist , hackCounter ; every 0 0$1 trigger not initHack do
113804: LD_EXP 187
113808: NOT
113809: IFFALSE 113859
113811: GO 113813
113813: DISABLE
// begin initHack := true ;
113814: LD_ADDR_EXP 187
113818: PUSH
113819: LD_INT 1
113821: ST_TO_ADDR
// hackTanks := [ ] ;
113822: LD_ADDR_EXP 188
113826: PUSH
113827: EMPTY
113828: ST_TO_ADDR
// hackTanksCaptured := [ ] ;
113829: LD_ADDR_EXP 189
113833: PUSH
113834: EMPTY
113835: ST_TO_ADDR
// hackLimit := 3 ;
113836: LD_ADDR_EXP 190
113840: PUSH
113841: LD_INT 3
113843: ST_TO_ADDR
// hackDist := 12 ;
113844: LD_ADDR_EXP 191
113848: PUSH
113849: LD_INT 12
113851: ST_TO_ADDR
// hackCounter := [ ] ;
113852: LD_ADDR_EXP 192
113856: PUSH
113857: EMPTY
113858: ST_TO_ADDR
// end ;
113859: END
// every 0 0$1 trigger initHack and FilterAllUnits ( [ f_weapon , us_hack ] ) do var i , tmp ;
113860: LD_EXP 187
113864: PUSH
113865: LD_INT 34
113867: PUSH
113868: LD_INT 99
113870: PUSH
113871: EMPTY
113872: LIST
113873: LIST
113874: PPUSH
113875: CALL_OW 69
113879: AND
113880: IFFALSE 114133
113882: GO 113884
113884: DISABLE
113885: LD_INT 0
113887: PPUSH
113888: PPUSH
// begin enable ;
113889: ENABLE
// for i in FilterAllUnits ( [ f_weapon , us_hack ] ) do
113890: LD_ADDR_VAR 0 1
113894: PUSH
113895: LD_INT 34
113897: PUSH
113898: LD_INT 99
113900: PUSH
113901: EMPTY
113902: LIST
113903: LIST
113904: PPUSH
113905: CALL_OW 69
113909: PUSH
113910: FOR_IN
113911: IFFALSE 114131
// begin if not i in hackTanks then
113913: LD_VAR 0 1
113917: PUSH
113918: LD_EXP 188
113922: IN
113923: NOT
113924: IFFALSE 114007
// begin hackTanks := Replace ( hackTanks , hackTanks + 1 , i ) ;
113926: LD_ADDR_EXP 188
113930: PUSH
113931: LD_EXP 188
113935: PPUSH
113936: LD_EXP 188
113940: PUSH
113941: LD_INT 1
113943: PLUS
113944: PPUSH
113945: LD_VAR 0 1
113949: PPUSH
113950: CALL_OW 1
113954: ST_TO_ADDR
// hackTanksCaptured := Replace ( hackTanksCaptured , hackTanksCaptured + 1 , [ ] ) ;
113955: LD_ADDR_EXP 189
113959: PUSH
113960: LD_EXP 189
113964: PPUSH
113965: LD_EXP 189
113969: PUSH
113970: LD_INT 1
113972: PLUS
113973: PPUSH
113974: EMPTY
113975: PPUSH
113976: CALL_OW 1
113980: ST_TO_ADDR
// hackCounter := Replace ( hackCounter , hackCounter + 1 , [ ] ) ;
113981: LD_ADDR_EXP 192
113985: PUSH
113986: LD_EXP 192
113990: PPUSH
113991: LD_EXP 192
113995: PUSH
113996: LD_INT 1
113998: PLUS
113999: PPUSH
114000: EMPTY
114001: PPUSH
114002: CALL_OW 1
114006: ST_TO_ADDR
// end ; if not IsOk ( i ) then
114007: LD_VAR 0 1
114011: PPUSH
114012: CALL_OW 302
114016: NOT
114017: IFFALSE 114030
// begin HackUnlinkAll ( i ) ;
114019: LD_VAR 0 1
114023: PPUSH
114024: CALL 114136 0 1
// continue ;
114028: GO 113910
// end ; HackCheckCapturedStatus ( i ) ;
114030: LD_VAR 0 1
114034: PPUSH
114035: CALL 114579 0 1
// tmp := FilterAllUnits ( [ [ f_enemy , GetSide ( i ) ] , [ f_control , control_computer ] , [ f_dist , i , hackDist ] , [ f_ok ] ] ) ;
114039: LD_ADDR_VAR 0 2
114043: PUSH
114044: LD_INT 81
114046: PUSH
114047: LD_VAR 0 1
114051: PPUSH
114052: CALL_OW 255
114056: PUSH
114057: EMPTY
114058: LIST
114059: LIST
114060: PUSH
114061: LD_INT 33
114063: PUSH
114064: LD_INT 3
114066: PUSH
114067: EMPTY
114068: LIST
114069: LIST
114070: PUSH
114071: LD_INT 91
114073: PUSH
114074: LD_VAR 0 1
114078: PUSH
114079: LD_EXP 191
114083: PUSH
114084: EMPTY
114085: LIST
114086: LIST
114087: LIST
114088: PUSH
114089: LD_INT 50
114091: PUSH
114092: EMPTY
114093: LIST
114094: PUSH
114095: EMPTY
114096: LIST
114097: LIST
114098: LIST
114099: LIST
114100: PPUSH
114101: CALL_OW 69
114105: ST_TO_ADDR
// if not tmp then
114106: LD_VAR 0 2
114110: NOT
114111: IFFALSE 114115
// continue ;
114113: GO 113910
// HackLink ( i , tmp ) ;
114115: LD_VAR 0 1
114119: PPUSH
114120: LD_VAR 0 2
114124: PPUSH
114125: CALL 114272 0 2
// end ;
114129: GO 113910
114131: POP
114132: POP
// end ;
114133: PPOPN 2
114135: END
// function HackUnlinkAll ( hack ) ; var i , index ; begin
114136: LD_INT 0
114138: PPUSH
114139: PPUSH
114140: PPUSH
// if not hack in hackTanks then
114141: LD_VAR 0 1
114145: PUSH
114146: LD_EXP 188
114150: IN
114151: NOT
114152: IFFALSE 114156
// exit ;
114154: GO 114267
// index := GetElementIndex ( hackTanks , hack ) ;
114156: LD_ADDR_VAR 0 4
114160: PUSH
114161: LD_EXP 188
114165: PPUSH
114166: LD_VAR 0 1
114170: PPUSH
114171: CALL 58225 0 2
114175: ST_TO_ADDR
// if hackTanksCaptured [ index ] then
114176: LD_EXP 189
114180: PUSH
114181: LD_VAR 0 4
114185: ARRAY
114186: IFFALSE 114267
// begin for i in hackTanksCaptured [ index ] do
114188: LD_ADDR_VAR 0 3
114192: PUSH
114193: LD_EXP 189
114197: PUSH
114198: LD_VAR 0 4
114202: ARRAY
114203: PUSH
114204: FOR_IN
114205: IFFALSE 114231
// SetSide ( i [ 1 ] , i [ 2 ] ) ;
114207: LD_VAR 0 3
114211: PUSH
114212: LD_INT 1
114214: ARRAY
114215: PPUSH
114216: LD_VAR 0 3
114220: PUSH
114221: LD_INT 2
114223: ARRAY
114224: PPUSH
114225: CALL_OW 235
114229: GO 114204
114231: POP
114232: POP
// hackTanksCaptured := Replace ( hackTanksCaptured , index , [ ] ) ;
114233: LD_ADDR_EXP 189
114237: PUSH
114238: LD_EXP 189
114242: PPUSH
114243: LD_VAR 0 4
114247: PPUSH
114248: EMPTY
114249: PPUSH
114250: CALL_OW 1
114254: ST_TO_ADDR
// SetUnitDisplayNumber ( hack , 0 ) ;
114255: LD_VAR 0 1
114259: PPUSH
114260: LD_INT 0
114262: PPUSH
114263: CALL_OW 505
// end ; end ;
114267: LD_VAR 0 2
114271: RET
// function HackLink ( hack , vehicles ) ; var i , index ; begin
114272: LD_INT 0
114274: PPUSH
114275: PPUSH
114276: PPUSH
// if not hack in hackTanks or not vehicles then
114277: LD_VAR 0 1
114281: PUSH
114282: LD_EXP 188
114286: IN
114287: NOT
114288: PUSH
114289: LD_VAR 0 2
114293: NOT
114294: OR
114295: IFFALSE 114299
// exit ;
114297: GO 114574
// vehicles := SortByDistanceUnit ( hack , vehicles , true , true ) ;
114299: LD_ADDR_VAR 0 2
114303: PUSH
114304: LD_VAR 0 1
114308: PPUSH
114309: LD_VAR 0 2
114313: PPUSH
114314: LD_INT 1
114316: PPUSH
114317: LD_INT 1
114319: PPUSH
114320: CALL 58875 0 4
114324: ST_TO_ADDR
// index := GetElementIndex ( hackTanks , hack ) ;
114325: LD_ADDR_VAR 0 5
114329: PUSH
114330: LD_EXP 188
114334: PPUSH
114335: LD_VAR 0 1
114339: PPUSH
114340: CALL 58225 0 2
114344: ST_TO_ADDR
// if hackTanksCaptured [ index ] < hackLimit then
114345: LD_EXP 189
114349: PUSH
114350: LD_VAR 0 5
114354: ARRAY
114355: PUSH
114356: LD_EXP 190
114360: LESS
114361: IFFALSE 114550
// begin for i := 1 to vehicles do
114363: LD_ADDR_VAR 0 4
114367: PUSH
114368: DOUBLE
114369: LD_INT 1
114371: DEC
114372: ST_TO_ADDR
114373: LD_VAR 0 2
114377: PUSH
114378: FOR_TO
114379: IFFALSE 114548
// begin if hackTanksCaptured [ index ] = hackLimit then
114381: LD_EXP 189
114385: PUSH
114386: LD_VAR 0 5
114390: ARRAY
114391: PUSH
114392: LD_EXP 190
114396: EQUAL
114397: IFFALSE 114401
// break ;
114399: GO 114548
// hackCounter := Replace ( hackCounter , index , hackCounter [ index ] + 1 ) ;
114401: LD_ADDR_EXP 192
114405: PUSH
114406: LD_EXP 192
114410: PPUSH
114411: LD_VAR 0 5
114415: PPUSH
114416: LD_EXP 192
114420: PUSH
114421: LD_VAR 0 5
114425: ARRAY
114426: PUSH
114427: LD_INT 1
114429: PLUS
114430: PPUSH
114431: CALL_OW 1
114435: ST_TO_ADDR
// hackTanksCaptured := ReplaceIn ( hackTanksCaptured , [ index , hackTanksCaptured [ index ] + 1 ] , [ vehicles [ i ] , GetSide ( vehicles [ i ] ) ] ) ;
114436: LD_ADDR_EXP 189
114440: PUSH
114441: LD_EXP 189
114445: PPUSH
114446: LD_VAR 0 5
114450: PUSH
114451: LD_EXP 189
114455: PUSH
114456: LD_VAR 0 5
114460: ARRAY
114461: PUSH
114462: LD_INT 1
114464: PLUS
114465: PUSH
114466: EMPTY
114467: LIST
114468: LIST
114469: PPUSH
114470: LD_VAR 0 2
114474: PUSH
114475: LD_VAR 0 4
114479: ARRAY
114480: PUSH
114481: LD_VAR 0 2
114485: PUSH
114486: LD_VAR 0 4
114490: ARRAY
114491: PPUSH
114492: CALL_OW 255
114496: PUSH
114497: EMPTY
114498: LIST
114499: LIST
114500: PPUSH
114501: CALL 58440 0 3
114505: ST_TO_ADDR
// SetSide ( vehicles [ i ] , GetSide ( hack ) ) ;
114506: LD_VAR 0 2
114510: PUSH
114511: LD_VAR 0 4
114515: ARRAY
114516: PPUSH
114517: LD_VAR 0 1
114521: PPUSH
114522: CALL_OW 255
114526: PPUSH
114527: CALL_OW 235
// ComStop ( vehicles [ i ] ) ;
114531: LD_VAR 0 2
114535: PUSH
114536: LD_VAR 0 4
114540: ARRAY
114541: PPUSH
114542: CALL_OW 141
// end ;
114546: GO 114378
114548: POP
114549: POP
// end ; SetUnitDisplayNumber ( hack , hackTanksCaptured [ index ] + 0 ) ;
114550: LD_VAR 0 1
114554: PPUSH
114555: LD_EXP 189
114559: PUSH
114560: LD_VAR 0 5
114564: ARRAY
114565: PUSH
114566: LD_INT 0
114568: PLUS
114569: PPUSH
114570: CALL_OW 505
// end ;
114574: LD_VAR 0 3
114578: RET
// function HackCheckCapturedStatus ( hack ) ; var i , index , tmp ; begin
114579: LD_INT 0
114581: PPUSH
114582: PPUSH
114583: PPUSH
114584: PPUSH
// if not hack in hackTanks then
114585: LD_VAR 0 1
114589: PUSH
114590: LD_EXP 188
114594: IN
114595: NOT
114596: IFFALSE 114600
// exit ;
114598: GO 114840
// index := GetElementIndex ( hackTanks , hack ) ;
114600: LD_ADDR_VAR 0 4
114604: PUSH
114605: LD_EXP 188
114609: PPUSH
114610: LD_VAR 0 1
114614: PPUSH
114615: CALL 58225 0 2
114619: ST_TO_ADDR
// for i := hackTanksCaptured [ index ] downto 1 do
114620: LD_ADDR_VAR 0 3
114624: PUSH
114625: DOUBLE
114626: LD_EXP 189
114630: PUSH
114631: LD_VAR 0 4
114635: ARRAY
114636: INC
114637: ST_TO_ADDR
114638: LD_INT 1
114640: PUSH
114641: FOR_DOWNTO
114642: IFFALSE 114814
// begin tmp := hackTanksCaptured [ index ] [ i ] ;
114644: LD_ADDR_VAR 0 5
114648: PUSH
114649: LD_EXP 189
114653: PUSH
114654: LD_VAR 0 4
114658: ARRAY
114659: PUSH
114660: LD_VAR 0 3
114664: ARRAY
114665: ST_TO_ADDR
// if not IsOk ( tmp [ 1 ] ) or GetSide ( tmp [ 1 ] ) <> GetSide ( hack ) then
114666: LD_VAR 0 5
114670: PUSH
114671: LD_INT 1
114673: ARRAY
114674: PPUSH
114675: CALL_OW 302
114679: NOT
114680: PUSH
114681: LD_VAR 0 5
114685: PUSH
114686: LD_INT 1
114688: ARRAY
114689: PPUSH
114690: CALL_OW 255
114694: PUSH
114695: LD_VAR 0 1
114699: PPUSH
114700: CALL_OW 255
114704: NONEQUAL
114705: OR
114706: IFFALSE 114812
// begin if IsPlaced ( tmp [ 1 ] ) and GetSide ( tmp [ 1 ] ) = GetSide ( hack ) then
114708: LD_VAR 0 5
114712: PUSH
114713: LD_INT 1
114715: ARRAY
114716: PPUSH
114717: CALL_OW 305
114721: PUSH
114722: LD_VAR 0 5
114726: PUSH
114727: LD_INT 1
114729: ARRAY
114730: PPUSH
114731: CALL_OW 255
114735: PUSH
114736: LD_VAR 0 1
114740: PPUSH
114741: CALL_OW 255
114745: EQUAL
114746: AND
114747: IFFALSE 114771
// SetSide ( tmp [ 1 ] , tmp [ 2 ] ) ;
114749: LD_VAR 0 5
114753: PUSH
114754: LD_INT 1
114756: ARRAY
114757: PPUSH
114758: LD_VAR 0 5
114762: PUSH
114763: LD_INT 2
114765: ARRAY
114766: PPUSH
114767: CALL_OW 235
// hackTanksCaptured := Replace ( hackTanksCaptured , index , Delete ( hackTanksCaptured [ index ] , i ) ) ;
114771: LD_ADDR_EXP 189
114775: PUSH
114776: LD_EXP 189
114780: PPUSH
114781: LD_VAR 0 4
114785: PPUSH
114786: LD_EXP 189
114790: PUSH
114791: LD_VAR 0 4
114795: ARRAY
114796: PPUSH
114797: LD_VAR 0 3
114801: PPUSH
114802: CALL_OW 3
114806: PPUSH
114807: CALL_OW 1
114811: ST_TO_ADDR
// end ; end ;
114812: GO 114641
114814: POP
114815: POP
// SetUnitDisplayNumber ( hack , hackTanksCaptured [ index ] + 0 ) ;
114816: LD_VAR 0 1
114820: PPUSH
114821: LD_EXP 189
114825: PUSH
114826: LD_VAR 0 4
114830: ARRAY
114831: PUSH
114832: LD_INT 0
114834: PLUS
114835: PPUSH
114836: CALL_OW 505
// end ;
114840: LD_VAR 0 2
114844: RET
// export function HackDestroyVehicle ( hack , vehicle ) ; var i , index , tmp ; begin
114845: LD_INT 0
114847: PPUSH
114848: PPUSH
114849: PPUSH
114850: PPUSH
// if not hack in hackTanks then
114851: LD_VAR 0 1
114855: PUSH
114856: LD_EXP 188
114860: IN
114861: NOT
114862: IFFALSE 114866
// exit ;
114864: GO 114951
// index := GetElementIndex ( hackTanks , hack ) ;
114866: LD_ADDR_VAR 0 5
114870: PUSH
114871: LD_EXP 188
114875: PPUSH
114876: LD_VAR 0 1
114880: PPUSH
114881: CALL 58225 0 2
114885: ST_TO_ADDR
// for i := 1 to hackTanksCaptured [ index ] do
114886: LD_ADDR_VAR 0 4
114890: PUSH
114891: DOUBLE
114892: LD_INT 1
114894: DEC
114895: ST_TO_ADDR
114896: LD_EXP 189
114900: PUSH
114901: LD_VAR 0 5
114905: ARRAY
114906: PUSH
114907: FOR_TO
114908: IFFALSE 114949
// if hackTanksCaptured [ index ] [ i ] [ 1 ] = vehicle then
114910: LD_EXP 189
114914: PUSH
114915: LD_VAR 0 5
114919: ARRAY
114920: PUSH
114921: LD_VAR 0 4
114925: ARRAY
114926: PUSH
114927: LD_INT 1
114929: ARRAY
114930: PUSH
114931: LD_VAR 0 2
114935: EQUAL
114936: IFFALSE 114947
// KillUnit ( vehicle ) ;
114938: LD_VAR 0 2
114942: PPUSH
114943: CALL_OW 66
114947: GO 114907
114949: POP
114950: POP
// end ;
114951: LD_VAR 0 3
114955: RET
// export initMiner , minersList , minerMinesList , minesLimitPerVehicle ; every 0 0$1 trigger not initMiner do
114956: LD_EXP 193
114960: NOT
114961: IFFALSE 114996
114963: GO 114965
114965: DISABLE
// begin initMiner := true ;
114966: LD_ADDR_EXP 193
114970: PUSH
114971: LD_INT 1
114973: ST_TO_ADDR
// minersList := [ ] ;
114974: LD_ADDR_EXP 194
114978: PUSH
114979: EMPTY
114980: ST_TO_ADDR
// minerMinesList := [ ] ;
114981: LD_ADDR_EXP 195
114985: PUSH
114986: EMPTY
114987: ST_TO_ADDR
// minesLimitPerVehicle := 5 ;
114988: LD_ADDR_EXP 196
114992: PUSH
114993: LD_INT 5
114995: ST_TO_ADDR
// end ;
114996: END
// every 0 0$1 trigger initMiner and FilterAllUnits ( [ f_weapon , ar_miner ] ) do var i , j , side , tmp ;
114997: LD_EXP 193
115001: PUSH
115002: LD_INT 34
115004: PUSH
115005: LD_INT 81
115007: PUSH
115008: EMPTY
115009: LIST
115010: LIST
115011: PPUSH
115012: CALL_OW 69
115016: AND
115017: IFFALSE 115478
115019: GO 115021
115021: DISABLE
115022: LD_INT 0
115024: PPUSH
115025: PPUSH
115026: PPUSH
115027: PPUSH
// begin enable ;
115028: ENABLE
// for i in FilterAllUnits ( [ f_weapon , ar_miner ] ) do
115029: LD_ADDR_VAR 0 1
115033: PUSH
115034: LD_INT 34
115036: PUSH
115037: LD_INT 81
115039: PUSH
115040: EMPTY
115041: LIST
115042: LIST
115043: PPUSH
115044: CALL_OW 69
115048: PUSH
115049: FOR_IN
115050: IFFALSE 115122
// begin if not i in minersList then
115052: LD_VAR 0 1
115056: PUSH
115057: LD_EXP 194
115061: IN
115062: NOT
115063: IFFALSE 115120
// begin minersList := Replace ( minersList , minersList + 1 , i ) ;
115065: LD_ADDR_EXP 194
115069: PUSH
115070: LD_EXP 194
115074: PPUSH
115075: LD_EXP 194
115079: PUSH
115080: LD_INT 1
115082: PLUS
115083: PPUSH
115084: LD_VAR 0 1
115088: PPUSH
115089: CALL_OW 1
115093: ST_TO_ADDR
// minerMinesList := Replace ( minerMinesList , minerMinesList + 1 , [ ] ) ;
115094: LD_ADDR_EXP 195
115098: PUSH
115099: LD_EXP 195
115103: PPUSH
115104: LD_EXP 195
115108: PUSH
115109: LD_INT 1
115111: PLUS
115112: PPUSH
115113: EMPTY
115114: PPUSH
115115: CALL_OW 1
115119: ST_TO_ADDR
// end end ;
115120: GO 115049
115122: POP
115123: POP
// for i := minerMinesList downto 1 do
115124: LD_ADDR_VAR 0 1
115128: PUSH
115129: DOUBLE
115130: LD_EXP 195
115134: INC
115135: ST_TO_ADDR
115136: LD_INT 1
115138: PUSH
115139: FOR_DOWNTO
115140: IFFALSE 115476
// begin if IsLive ( minersList [ i ] ) then
115142: LD_EXP 194
115146: PUSH
115147: LD_VAR 0 1
115151: ARRAY
115152: PPUSH
115153: CALL_OW 300
115157: IFFALSE 115185
// SetUnitDisplayNumber ( minersList [ i ] , minerMinesList [ i ] ) ;
115159: LD_EXP 194
115163: PUSH
115164: LD_VAR 0 1
115168: ARRAY
115169: PPUSH
115170: LD_EXP 195
115174: PUSH
115175: LD_VAR 0 1
115179: ARRAY
115180: PPUSH
115181: CALL_OW 505
// if not minerMinesList [ i ] then
115185: LD_EXP 195
115189: PUSH
115190: LD_VAR 0 1
115194: ARRAY
115195: NOT
115196: IFFALSE 115200
// continue ;
115198: GO 115139
// for j := minerMinesList [ i ] downto 1 do
115200: LD_ADDR_VAR 0 2
115204: PUSH
115205: DOUBLE
115206: LD_EXP 195
115210: PUSH
115211: LD_VAR 0 1
115215: ARRAY
115216: INC
115217: ST_TO_ADDR
115218: LD_INT 1
115220: PUSH
115221: FOR_DOWNTO
115222: IFFALSE 115472
// begin side := GetSide ( minersList [ i ] ) ;
115224: LD_ADDR_VAR 0 3
115228: PUSH
115229: LD_EXP 194
115233: PUSH
115234: LD_VAR 0 1
115238: ARRAY
115239: PPUSH
115240: CALL_OW 255
115244: ST_TO_ADDR
// tmp := HexInfo ( minerMinesList [ i ] [ j ] [ 1 ] , minerMinesList [ i ] [ j ] [ 2 ] ) ;
115245: LD_ADDR_VAR 0 4
115249: PUSH
115250: LD_EXP 195
115254: PUSH
115255: LD_VAR 0 1
115259: ARRAY
115260: PUSH
115261: LD_VAR 0 2
115265: ARRAY
115266: PUSH
115267: LD_INT 1
115269: ARRAY
115270: PPUSH
115271: LD_EXP 195
115275: PUSH
115276: LD_VAR 0 1
115280: ARRAY
115281: PUSH
115282: LD_VAR 0 2
115286: ARRAY
115287: PUSH
115288: LD_INT 2
115290: ARRAY
115291: PPUSH
115292: CALL_OW 428
115296: ST_TO_ADDR
// if not tmp then
115297: LD_VAR 0 4
115301: NOT
115302: IFFALSE 115306
// continue ;
115304: GO 115221
// if tmp in FilterAllUnits ( [ f_enemy , side ] ) and MineAtPos ( minerMinesList [ i ] [ j ] [ 1 ] , minerMinesList [ i ] [ j ] [ 2 ] ) then
115306: LD_VAR 0 4
115310: PUSH
115311: LD_INT 81
115313: PUSH
115314: LD_VAR 0 3
115318: PUSH
115319: EMPTY
115320: LIST
115321: LIST
115322: PPUSH
115323: CALL_OW 69
115327: IN
115328: PUSH
115329: LD_EXP 195
115333: PUSH
115334: LD_VAR 0 1
115338: ARRAY
115339: PUSH
115340: LD_VAR 0 2
115344: ARRAY
115345: PUSH
115346: LD_INT 1
115348: ARRAY
115349: PPUSH
115350: LD_EXP 195
115354: PUSH
115355: LD_VAR 0 1
115359: ARRAY
115360: PUSH
115361: LD_VAR 0 2
115365: ARRAY
115366: PUSH
115367: LD_INT 2
115369: ARRAY
115370: PPUSH
115371: CALL_OW 458
115375: AND
115376: IFFALSE 115470
// begin LaunchMineAtPos ( minerMinesList [ i ] [ j ] [ 1 ] , minerMinesList [ i ] [ j ] [ 2 ] , side ) ;
115378: LD_EXP 195
115382: PUSH
115383: LD_VAR 0 1
115387: ARRAY
115388: PUSH
115389: LD_VAR 0 2
115393: ARRAY
115394: PUSH
115395: LD_INT 1
115397: ARRAY
115398: PPUSH
115399: LD_EXP 195
115403: PUSH
115404: LD_VAR 0 1
115408: ARRAY
115409: PUSH
115410: LD_VAR 0 2
115414: ARRAY
115415: PUSH
115416: LD_INT 2
115418: ARRAY
115419: PPUSH
115420: LD_VAR 0 3
115424: PPUSH
115425: CALL_OW 456
// minerMinesList := Replace ( minerMinesList , i , Delete ( minerMinesList [ i ] , j ) ) ;
115429: LD_ADDR_EXP 195
115433: PUSH
115434: LD_EXP 195
115438: PPUSH
115439: LD_VAR 0 1
115443: PPUSH
115444: LD_EXP 195
115448: PUSH
115449: LD_VAR 0 1
115453: ARRAY
115454: PPUSH
115455: LD_VAR 0 2
115459: PPUSH
115460: CALL_OW 3
115464: PPUSH
115465: CALL_OW 1
115469: ST_TO_ADDR
// end ; end ;
115470: GO 115221
115472: POP
115473: POP
// end ;
115474: GO 115139
115476: POP
115477: POP
// end ;
115478: PPOPN 4
115480: END
// export function MinerPlaceMine ( unit , x , y ) ; var index ; begin
115481: LD_INT 0
115483: PPUSH
115484: PPUSH
// result := false ;
115485: LD_ADDR_VAR 0 4
115489: PUSH
115490: LD_INT 0
115492: ST_TO_ADDR
// if not GetWeapon ( unit ) = ar_miner then
115493: LD_VAR 0 1
115497: PPUSH
115498: CALL_OW 264
115502: PUSH
115503: LD_INT 81
115505: EQUAL
115506: NOT
115507: IFFALSE 115511
// exit ;
115509: GO 115751
// index := GetElementIndex ( minersList , unit ) ;
115511: LD_ADDR_VAR 0 5
115515: PUSH
115516: LD_EXP 194
115520: PPUSH
115521: LD_VAR 0 1
115525: PPUSH
115526: CALL 58225 0 2
115530: ST_TO_ADDR
// if minerMinesList [ index ] >= minesLimitPerVehicle then
115531: LD_EXP 195
115535: PUSH
115536: LD_VAR 0 5
115540: ARRAY
115541: PUSH
115542: LD_EXP 196
115546: GREATEREQUAL
115547: IFFALSE 115551
// exit ;
115549: GO 115751
// ComMoveXY ( unit , x , y ) ;
115551: LD_VAR 0 1
115555: PPUSH
115556: LD_VAR 0 2
115560: PPUSH
115561: LD_VAR 0 3
115565: PPUSH
115566: CALL_OW 111
// repeat wait ( 0 0$1 ) ;
115570: LD_INT 35
115572: PPUSH
115573: CALL_OW 67
// if not UnitGoingToXY ( unit , x , y ) and HasTask ( unit ) then
115577: LD_VAR 0 1
115581: PPUSH
115582: LD_VAR 0 2
115586: PPUSH
115587: LD_VAR 0 3
115591: PPUSH
115592: CALL 89966 0 3
115596: NOT
115597: PUSH
115598: LD_VAR 0 1
115602: PPUSH
115603: CALL_OW 314
115607: AND
115608: IFFALSE 115612
// exit ;
115610: GO 115751
// until HexInfo ( x , y ) = unit and not HasTask ( unit ) ;
115612: LD_VAR 0 2
115616: PPUSH
115617: LD_VAR 0 3
115621: PPUSH
115622: CALL_OW 428
115626: PUSH
115627: LD_VAR 0 1
115631: EQUAL
115632: PUSH
115633: LD_VAR 0 1
115637: PPUSH
115638: CALL_OW 314
115642: NOT
115643: AND
115644: IFFALSE 115570
// PlaySoundXY ( x , y , PlantMine ) ;
115646: LD_VAR 0 2
115650: PPUSH
115651: LD_VAR 0 3
115655: PPUSH
115656: LD_STRING PlantMine
115658: PPUSH
115659: CALL_OW 366
// PlaceMine ( x , y , GetSide ( unit ) , 0 ) ;
115663: LD_VAR 0 2
115667: PPUSH
115668: LD_VAR 0 3
115672: PPUSH
115673: LD_VAR 0 1
115677: PPUSH
115678: CALL_OW 255
115682: PPUSH
115683: LD_INT 0
115685: PPUSH
115686: CALL_OW 454
// minerMinesList := ReplaceIn ( minerMinesList , [ index , minerMinesList [ index ] + 1 ] , [ x , y ] ) ;
115690: LD_ADDR_EXP 195
115694: PUSH
115695: LD_EXP 195
115699: PPUSH
115700: LD_VAR 0 5
115704: PUSH
115705: LD_EXP 195
115709: PUSH
115710: LD_VAR 0 5
115714: ARRAY
115715: PUSH
115716: LD_INT 1
115718: PLUS
115719: PUSH
115720: EMPTY
115721: LIST
115722: LIST
115723: PPUSH
115724: LD_VAR 0 2
115728: PUSH
115729: LD_VAR 0 3
115733: PUSH
115734: EMPTY
115735: LIST
115736: LIST
115737: PPUSH
115738: CALL 58440 0 3
115742: ST_TO_ADDR
// result := true ;
115743: LD_ADDR_VAR 0 4
115747: PUSH
115748: LD_INT 1
115750: ST_TO_ADDR
// end ;
115751: LD_VAR 0 4
115755: RET
// export function MinerDetonateMine ( unit , x , y ) ; var i , index ; begin
115756: LD_INT 0
115758: PPUSH
115759: PPUSH
115760: PPUSH
// if not unit in minersList then
115761: LD_VAR 0 1
115765: PUSH
115766: LD_EXP 194
115770: IN
115771: NOT
115772: IFFALSE 115776
// exit ;
115774: GO 116168
// index := GetElementIndex ( minersList , unit ) ;
115776: LD_ADDR_VAR 0 6
115780: PUSH
115781: LD_EXP 194
115785: PPUSH
115786: LD_VAR 0 1
115790: PPUSH
115791: CALL 58225 0 2
115795: ST_TO_ADDR
// for i := minerMinesList [ index ] downto 1 do
115796: LD_ADDR_VAR 0 5
115800: PUSH
115801: DOUBLE
115802: LD_EXP 195
115806: PUSH
115807: LD_VAR 0 6
115811: ARRAY
115812: INC
115813: ST_TO_ADDR
115814: LD_INT 1
115816: PUSH
115817: FOR_DOWNTO
115818: IFFALSE 115979
// begin if minerMinesList [ index ] [ i ] [ 1 ] = x and minerMinesList [ index ] [ i ] [ 2 ] = y then
115820: LD_EXP 195
115824: PUSH
115825: LD_VAR 0 6
115829: ARRAY
115830: PUSH
115831: LD_VAR 0 5
115835: ARRAY
115836: PUSH
115837: LD_INT 1
115839: ARRAY
115840: PUSH
115841: LD_VAR 0 2
115845: EQUAL
115846: PUSH
115847: LD_EXP 195
115851: PUSH
115852: LD_VAR 0 6
115856: ARRAY
115857: PUSH
115858: LD_VAR 0 5
115862: ARRAY
115863: PUSH
115864: LD_INT 2
115866: ARRAY
115867: PUSH
115868: LD_VAR 0 3
115872: EQUAL
115873: AND
115874: IFFALSE 115977
// begin LaunchMineAtPos ( minerMinesList [ index ] [ i ] [ 1 ] , minerMinesList [ index ] [ i ] [ 2 ] , GetSide ( unit ) ) ;
115876: LD_EXP 195
115880: PUSH
115881: LD_VAR 0 6
115885: ARRAY
115886: PUSH
115887: LD_VAR 0 5
115891: ARRAY
115892: PUSH
115893: LD_INT 1
115895: ARRAY
115896: PPUSH
115897: LD_EXP 195
115901: PUSH
115902: LD_VAR 0 6
115906: ARRAY
115907: PUSH
115908: LD_VAR 0 5
115912: ARRAY
115913: PUSH
115914: LD_INT 2
115916: ARRAY
115917: PPUSH
115918: LD_VAR 0 1
115922: PPUSH
115923: CALL_OW 255
115927: PPUSH
115928: CALL_OW 456
// minerMinesList := Replace ( minerMinesList , index , Delete ( minerMinesList [ index ] , i ) ) ;
115932: LD_ADDR_EXP 195
115936: PUSH
115937: LD_EXP 195
115941: PPUSH
115942: LD_VAR 0 6
115946: PPUSH
115947: LD_EXP 195
115951: PUSH
115952: LD_VAR 0 6
115956: ARRAY
115957: PPUSH
115958: LD_VAR 0 5
115962: PPUSH
115963: CALL_OW 3
115967: PPUSH
115968: CALL_OW 1
115972: ST_TO_ADDR
// exit ;
115973: POP
115974: POP
115975: GO 116168
// end ; end ;
115977: GO 115817
115979: POP
115980: POP
// for i := minerMinesList [ index ] downto 1 do
115981: LD_ADDR_VAR 0 5
115985: PUSH
115986: DOUBLE
115987: LD_EXP 195
115991: PUSH
115992: LD_VAR 0 6
115996: ARRAY
115997: INC
115998: ST_TO_ADDR
115999: LD_INT 1
116001: PUSH
116002: FOR_DOWNTO
116003: IFFALSE 116166
// begin if GetDistXY ( minerMinesList [ index ] [ i ] [ 1 ] , minerMinesList [ index ] [ i ] [ 2 ] , x , y ) < 6 then
116005: LD_EXP 195
116009: PUSH
116010: LD_VAR 0 6
116014: ARRAY
116015: PUSH
116016: LD_VAR 0 5
116020: ARRAY
116021: PUSH
116022: LD_INT 1
116024: ARRAY
116025: PPUSH
116026: LD_EXP 195
116030: PUSH
116031: LD_VAR 0 6
116035: ARRAY
116036: PUSH
116037: LD_VAR 0 5
116041: ARRAY
116042: PUSH
116043: LD_INT 2
116045: ARRAY
116046: PPUSH
116047: LD_VAR 0 2
116051: PPUSH
116052: LD_VAR 0 3
116056: PPUSH
116057: CALL_OW 298
116061: PUSH
116062: LD_INT 6
116064: LESS
116065: IFFALSE 116164
// begin LaunchMineAtPos ( minerMinesList [ index ] [ i ] [ 1 ] , minerMinesList [ index ] [ i ] [ 2 ] , GetSide ( unit ) ) ;
116067: LD_EXP 195
116071: PUSH
116072: LD_VAR 0 6
116076: ARRAY
116077: PUSH
116078: LD_VAR 0 5
116082: ARRAY
116083: PUSH
116084: LD_INT 1
116086: ARRAY
116087: PPUSH
116088: LD_EXP 195
116092: PUSH
116093: LD_VAR 0 6
116097: ARRAY
116098: PUSH
116099: LD_VAR 0 5
116103: ARRAY
116104: PUSH
116105: LD_INT 2
116107: ARRAY
116108: PPUSH
116109: LD_VAR 0 1
116113: PPUSH
116114: CALL_OW 255
116118: PPUSH
116119: CALL_OW 456
// minerMinesList := Replace ( minerMinesList , index , Delete ( minerMinesList [ index ] , i ) ) ;
116123: LD_ADDR_EXP 195
116127: PUSH
116128: LD_EXP 195
116132: PPUSH
116133: LD_VAR 0 6
116137: PPUSH
116138: LD_EXP 195
116142: PUSH
116143: LD_VAR 0 6
116147: ARRAY
116148: PPUSH
116149: LD_VAR 0 5
116153: PPUSH
116154: CALL_OW 3
116158: PPUSH
116159: CALL_OW 1
116163: ST_TO_ADDR
// end ; end ;
116164: GO 116002
116166: POP
116167: POP
// end ;
116168: LD_VAR 0 4
116172: RET
// export function MinerCreateMinefield ( unit , x , y ) ; var i , index , tmp , minesFreeAmount , _x , _y , _d , _r ; begin
116173: LD_INT 0
116175: PPUSH
116176: PPUSH
116177: PPUSH
116178: PPUSH
116179: PPUSH
116180: PPUSH
116181: PPUSH
116182: PPUSH
116183: PPUSH
// if not GetWeapon ( unit ) = ar_miner or not unit in minersList then
116184: LD_VAR 0 1
116188: PPUSH
116189: CALL_OW 264
116193: PUSH
116194: LD_INT 81
116196: EQUAL
116197: NOT
116198: PUSH
116199: LD_VAR 0 1
116203: PUSH
116204: LD_EXP 194
116208: IN
116209: NOT
116210: OR
116211: IFFALSE 116215
// exit ;
116213: GO 116537
// index := GetElementIndex ( minersList , unit ) ;
116215: LD_ADDR_VAR 0 6
116219: PUSH
116220: LD_EXP 194
116224: PPUSH
116225: LD_VAR 0 1
116229: PPUSH
116230: CALL 58225 0 2
116234: ST_TO_ADDR
// minesFreeAmount := minesLimitPerVehicle - minerMinesList [ index ] ;
116235: LD_ADDR_VAR 0 8
116239: PUSH
116240: LD_EXP 196
116244: PUSH
116245: LD_EXP 195
116249: PUSH
116250: LD_VAR 0 6
116254: ARRAY
116255: MINUS
116256: ST_TO_ADDR
// if not minesFreeAmount then
116257: LD_VAR 0 8
116261: NOT
116262: IFFALSE 116266
// exit ;
116264: GO 116537
// tmp := [ ] ;
116266: LD_ADDR_VAR 0 7
116270: PUSH
116271: EMPTY
116272: ST_TO_ADDR
// for i := 1 to minesFreeAmount do
116273: LD_ADDR_VAR 0 5
116277: PUSH
116278: DOUBLE
116279: LD_INT 1
116281: DEC
116282: ST_TO_ADDR
116283: LD_VAR 0 8
116287: PUSH
116288: FOR_TO
116289: IFFALSE 116484
// begin _d := rand ( 0 , 5 ) ;
116291: LD_ADDR_VAR 0 11
116295: PUSH
116296: LD_INT 0
116298: PPUSH
116299: LD_INT 5
116301: PPUSH
116302: CALL_OW 12
116306: ST_TO_ADDR
// _r := rand ( 2 , 6 ) ;
116307: LD_ADDR_VAR 0 12
116311: PUSH
116312: LD_INT 2
116314: PPUSH
116315: LD_INT 6
116317: PPUSH
116318: CALL_OW 12
116322: ST_TO_ADDR
// _x := ShiftX ( x , _d , _r ) ;
116323: LD_ADDR_VAR 0 9
116327: PUSH
116328: LD_VAR 0 2
116332: PPUSH
116333: LD_VAR 0 11
116337: PPUSH
116338: LD_VAR 0 12
116342: PPUSH
116343: CALL_OW 272
116347: ST_TO_ADDR
// _y := ShiftY ( y , _d , _r ) ;
116348: LD_ADDR_VAR 0 10
116352: PUSH
116353: LD_VAR 0 3
116357: PPUSH
116358: LD_VAR 0 11
116362: PPUSH
116363: LD_VAR 0 12
116367: PPUSH
116368: CALL_OW 273
116372: ST_TO_ADDR
// if ValidHex ( _x , _y ) and not [ _x , _y ] in tmp and not MineAtPos ( _x , _y ) then
116373: LD_VAR 0 9
116377: PPUSH
116378: LD_VAR 0 10
116382: PPUSH
116383: CALL_OW 488
116387: PUSH
116388: LD_VAR 0 9
116392: PUSH
116393: LD_VAR 0 10
116397: PUSH
116398: EMPTY
116399: LIST
116400: LIST
116401: PUSH
116402: LD_VAR 0 7
116406: IN
116407: NOT
116408: AND
116409: PUSH
116410: LD_VAR 0 9
116414: PPUSH
116415: LD_VAR 0 10
116419: PPUSH
116420: CALL_OW 458
116424: NOT
116425: AND
116426: IFFALSE 116468
// tmp := Replace ( tmp , tmp + 1 , [ _x , _y ] ) else
116428: LD_ADDR_VAR 0 7
116432: PUSH
116433: LD_VAR 0 7
116437: PPUSH
116438: LD_VAR 0 7
116442: PUSH
116443: LD_INT 1
116445: PLUS
116446: PPUSH
116447: LD_VAR 0 9
116451: PUSH
116452: LD_VAR 0 10
116456: PUSH
116457: EMPTY
116458: LIST
116459: LIST
116460: PPUSH
116461: CALL_OW 1
116465: ST_TO_ADDR
116466: GO 116482
// i := i - 1 ;
116468: LD_ADDR_VAR 0 5
116472: PUSH
116473: LD_VAR 0 5
116477: PUSH
116478: LD_INT 1
116480: MINUS
116481: ST_TO_ADDR
// end ;
116482: GO 116288
116484: POP
116485: POP
// for i in tmp do
116486: LD_ADDR_VAR 0 5
116490: PUSH
116491: LD_VAR 0 7
116495: PUSH
116496: FOR_IN
116497: IFFALSE 116535
// if not MinerPlaceMine ( unit , i [ 1 ] , i [ 2 ] ) then
116499: LD_VAR 0 1
116503: PPUSH
116504: LD_VAR 0 5
116508: PUSH
116509: LD_INT 1
116511: ARRAY
116512: PPUSH
116513: LD_VAR 0 5
116517: PUSH
116518: LD_INT 2
116520: ARRAY
116521: PPUSH
116522: CALL 115481 0 3
116526: NOT
116527: IFFALSE 116533
// exit ;
116529: POP
116530: POP
116531: GO 116537
116533: GO 116496
116535: POP
116536: POP
// end ;
116537: LD_VAR 0 4
116541: RET
// export function ComBinocular ( unit , x , y ) ; var dist , side , viewRange , _x , _y , _d ; begin
116542: LD_INT 0
116544: PPUSH
116545: PPUSH
116546: PPUSH
116547: PPUSH
116548: PPUSH
116549: PPUSH
116550: PPUSH
// if not GetClass ( unit ) = class_sniper then
116551: LD_VAR 0 1
116555: PPUSH
116556: CALL_OW 257
116560: PUSH
116561: LD_INT 5
116563: EQUAL
116564: NOT
116565: IFFALSE 116569
// exit ;
116567: GO 116957
// dist := 8 ;
116569: LD_ADDR_VAR 0 5
116573: PUSH
116574: LD_INT 8
116576: ST_TO_ADDR
// viewRange := 12 ;
116577: LD_ADDR_VAR 0 7
116581: PUSH
116582: LD_INT 12
116584: ST_TO_ADDR
// side := GetSide ( unit ) ;
116585: LD_ADDR_VAR 0 6
116589: PUSH
116590: LD_VAR 0 1
116594: PPUSH
116595: CALL_OW 255
116599: ST_TO_ADDR
// if GetTech ( tech_opto2 , side ) = state_researched then
116600: LD_INT 61
116602: PPUSH
116603: LD_VAR 0 6
116607: PPUSH
116608: CALL_OW 321
116612: PUSH
116613: LD_INT 2
116615: EQUAL
116616: IFFALSE 116626
// viewRange := 16 ;
116618: LD_ADDR_VAR 0 7
116622: PUSH
116623: LD_INT 16
116625: ST_TO_ADDR
// if GetDistUnitXY ( unit , x , y ) > dist then
116626: LD_VAR 0 1
116630: PPUSH
116631: LD_VAR 0 2
116635: PPUSH
116636: LD_VAR 0 3
116640: PPUSH
116641: CALL_OW 297
116645: PUSH
116646: LD_VAR 0 5
116650: GREATER
116651: IFFALSE 116730
// begin ComMoveXY ( unit , x , y ) ;
116653: LD_VAR 0 1
116657: PPUSH
116658: LD_VAR 0 2
116662: PPUSH
116663: LD_VAR 0 3
116667: PPUSH
116668: CALL_OW 111
// repeat wait ( 0 0$1 ) ;
116672: LD_INT 35
116674: PPUSH
116675: CALL_OW 67
// if not UnitGoingToXY ( unit , x , y ) then
116679: LD_VAR 0 1
116683: PPUSH
116684: LD_VAR 0 2
116688: PPUSH
116689: LD_VAR 0 3
116693: PPUSH
116694: CALL 89966 0 3
116698: NOT
116699: IFFALSE 116703
// exit ;
116701: GO 116957
// until GetDistUnitXY ( unit , x , y ) < dist ;
116703: LD_VAR 0 1
116707: PPUSH
116708: LD_VAR 0 2
116712: PPUSH
116713: LD_VAR 0 3
116717: PPUSH
116718: CALL_OW 297
116722: PUSH
116723: LD_VAR 0 5
116727: LESS
116728: IFFALSE 116672
// end ; ComTurnXY ( unit , x , y ) ;
116730: LD_VAR 0 1
116734: PPUSH
116735: LD_VAR 0 2
116739: PPUSH
116740: LD_VAR 0 3
116744: PPUSH
116745: CALL_OW 118
// wait ( 5 ) ;
116749: LD_INT 5
116751: PPUSH
116752: CALL_OW 67
// _d := GetDir ( unit ) ;
116756: LD_ADDR_VAR 0 10
116760: PUSH
116761: LD_VAR 0 1
116765: PPUSH
116766: CALL_OW 254
116770: ST_TO_ADDR
// _x := ShiftX ( GetX ( unit ) , _d , dist ) ;
116771: LD_ADDR_VAR 0 8
116775: PUSH
116776: LD_VAR 0 1
116780: PPUSH
116781: CALL_OW 250
116785: PPUSH
116786: LD_VAR 0 10
116790: PPUSH
116791: LD_VAR 0 5
116795: PPUSH
116796: CALL_OW 272
116800: ST_TO_ADDR
// _y := ShiftY ( GetY ( unit ) , _d , dist ) ;
116801: LD_ADDR_VAR 0 9
116805: PUSH
116806: LD_VAR 0 1
116810: PPUSH
116811: CALL_OW 251
116815: PPUSH
116816: LD_VAR 0 10
116820: PPUSH
116821: LD_VAR 0 5
116825: PPUSH
116826: CALL_OW 273
116830: ST_TO_ADDR
// if not ValidHex ( _x , _y ) then
116831: LD_VAR 0 8
116835: PPUSH
116836: LD_VAR 0 9
116840: PPUSH
116841: CALL_OW 488
116845: NOT
116846: IFFALSE 116850
// exit ;
116848: GO 116957
// ComAnimCustom ( unit , 1 ) ;
116850: LD_VAR 0 1
116854: PPUSH
116855: LD_INT 1
116857: PPUSH
116858: CALL_OW 592
// PlaceSeeing ( _x , _y , side , viewRange ) ;
116862: LD_VAR 0 8
116866: PPUSH
116867: LD_VAR 0 9
116871: PPUSH
116872: LD_VAR 0 6
116876: PPUSH
116877: LD_VAR 0 7
116881: PPUSH
116882: CALL_OW 330
// repeat wait ( 1 ) ;
116886: LD_INT 1
116888: PPUSH
116889: CALL_OW 67
// until IsIdle ( unit ) or HasTask ( unit ) or not IsOk ( unit ) or IsDead ( unit ) ;
116893: LD_VAR 0 1
116897: PPUSH
116898: CALL_OW 316
116902: PUSH
116903: LD_VAR 0 1
116907: PPUSH
116908: CALL_OW 314
116912: OR
116913: PUSH
116914: LD_VAR 0 1
116918: PPUSH
116919: CALL_OW 302
116923: NOT
116924: OR
116925: PUSH
116926: LD_VAR 0 1
116930: PPUSH
116931: CALL_OW 301
116935: OR
116936: IFFALSE 116886
// RemoveSeeing ( _x , _y , side ) ;
116938: LD_VAR 0 8
116942: PPUSH
116943: LD_VAR 0 9
116947: PPUSH
116948: LD_VAR 0 6
116952: PPUSH
116953: CALL_OW 331
// end ; end_of_file
116957: LD_VAR 0 4
116961: RET
// export function Attack ( list ) ; var base , group , path , flags , i , j , k , x , y , d , z , tmp , tmp2 , units_path , f_ignore_area , f_capture , f_ignore_civ , f_murder , f_mines , f_repair , f_heal , f_spacetime , f_attack_depot , f_crawl , mined , bombed , attacking , to_heal , healers , to_repair , repairs , empty_vehs , side ; begin
116962: LD_INT 0
116964: PPUSH
116965: PPUSH
116966: PPUSH
116967: PPUSH
116968: PPUSH
116969: PPUSH
116970: PPUSH
116971: PPUSH
116972: PPUSH
116973: PPUSH
116974: PPUSH
116975: PPUSH
116976: PPUSH
116977: PPUSH
116978: PPUSH
116979: PPUSH
116980: PPUSH
116981: PPUSH
116982: PPUSH
116983: PPUSH
116984: PPUSH
116985: PPUSH
116986: PPUSH
116987: PPUSH
116988: PPUSH
116989: PPUSH
116990: PPUSH
116991: PPUSH
116992: PPUSH
116993: PPUSH
116994: PPUSH
116995: PPUSH
116996: PPUSH
116997: PPUSH
// if not list then
116998: LD_VAR 0 1
117002: NOT
117003: IFFALSE 117007
// exit ;
117005: GO 121666
// base := list [ 1 ] ;
117007: LD_ADDR_VAR 0 3
117011: PUSH
117012: LD_VAR 0 1
117016: PUSH
117017: LD_INT 1
117019: ARRAY
117020: ST_TO_ADDR
// group := list [ 2 ] ;
117021: LD_ADDR_VAR 0 4
117025: PUSH
117026: LD_VAR 0 1
117030: PUSH
117031: LD_INT 2
117033: ARRAY
117034: ST_TO_ADDR
// path := list [ 3 ] ;
117035: LD_ADDR_VAR 0 5
117039: PUSH
117040: LD_VAR 0 1
117044: PUSH
117045: LD_INT 3
117047: ARRAY
117048: ST_TO_ADDR
// flags := list [ 4 ] ;
117049: LD_ADDR_VAR 0 6
117053: PUSH
117054: LD_VAR 0 1
117058: PUSH
117059: LD_INT 4
117061: ARRAY
117062: ST_TO_ADDR
// mined := [ ] ;
117063: LD_ADDR_VAR 0 27
117067: PUSH
117068: EMPTY
117069: ST_TO_ADDR
// bombed := [ ] ;
117070: LD_ADDR_VAR 0 28
117074: PUSH
117075: EMPTY
117076: ST_TO_ADDR
// healers := [ ] ;
117077: LD_ADDR_VAR 0 31
117081: PUSH
117082: EMPTY
117083: ST_TO_ADDR
// to_heal := [ ] ;
117084: LD_ADDR_VAR 0 30
117088: PUSH
117089: EMPTY
117090: ST_TO_ADDR
// repairs := [ ] ;
117091: LD_ADDR_VAR 0 33
117095: PUSH
117096: EMPTY
117097: ST_TO_ADDR
// to_repair := [ ] ;
117098: LD_ADDR_VAR 0 32
117102: PUSH
117103: EMPTY
117104: ST_TO_ADDR
// if not group or not path then
117105: LD_VAR 0 4
117109: NOT
117110: PUSH
117111: LD_VAR 0 5
117115: NOT
117116: OR
117117: IFFALSE 117121
// exit ;
117119: GO 121666
// side := GetSide ( group [ 1 ] ) ;
117121: LD_ADDR_VAR 0 35
117125: PUSH
117126: LD_VAR 0 4
117130: PUSH
117131: LD_INT 1
117133: ARRAY
117134: PPUSH
117135: CALL_OW 255
117139: ST_TO_ADDR
// if flags then
117140: LD_VAR 0 6
117144: IFFALSE 117288
// begin f_ignore_area := flags [ 1 ] ;
117146: LD_ADDR_VAR 0 17
117150: PUSH
117151: LD_VAR 0 6
117155: PUSH
117156: LD_INT 1
117158: ARRAY
117159: ST_TO_ADDR
// f_capture := flags [ 2 ] ;
117160: LD_ADDR_VAR 0 18
117164: PUSH
117165: LD_VAR 0 6
117169: PUSH
117170: LD_INT 2
117172: ARRAY
117173: ST_TO_ADDR
// f_ignore_civ := flags [ 3 ] ;
117174: LD_ADDR_VAR 0 19
117178: PUSH
117179: LD_VAR 0 6
117183: PUSH
117184: LD_INT 3
117186: ARRAY
117187: ST_TO_ADDR
// f_murder := flags [ 4 ] ;
117188: LD_ADDR_VAR 0 20
117192: PUSH
117193: LD_VAR 0 6
117197: PUSH
117198: LD_INT 4
117200: ARRAY
117201: ST_TO_ADDR
// f_mines := flags [ 5 ] ;
117202: LD_ADDR_VAR 0 21
117206: PUSH
117207: LD_VAR 0 6
117211: PUSH
117212: LD_INT 5
117214: ARRAY
117215: ST_TO_ADDR
// f_repair := flags [ 6 ] ;
117216: LD_ADDR_VAR 0 22
117220: PUSH
117221: LD_VAR 0 6
117225: PUSH
117226: LD_INT 6
117228: ARRAY
117229: ST_TO_ADDR
// f_heal := flags [ 7 ] ;
117230: LD_ADDR_VAR 0 23
117234: PUSH
117235: LD_VAR 0 6
117239: PUSH
117240: LD_INT 7
117242: ARRAY
117243: ST_TO_ADDR
// f_spacetime := flags [ 8 ] ;
117244: LD_ADDR_VAR 0 24
117248: PUSH
117249: LD_VAR 0 6
117253: PUSH
117254: LD_INT 8
117256: ARRAY
117257: ST_TO_ADDR
// f_attack_depot := flags [ 9 ] ;
117258: LD_ADDR_VAR 0 25
117262: PUSH
117263: LD_VAR 0 6
117267: PUSH
117268: LD_INT 9
117270: ARRAY
117271: ST_TO_ADDR
// f_crawl := flags [ 10 ] ;
117272: LD_ADDR_VAR 0 26
117276: PUSH
117277: LD_VAR 0 6
117281: PUSH
117282: LD_INT 10
117284: ARRAY
117285: ST_TO_ADDR
// end else
117286: GO 117368
// begin f_ignore_area := false ;
117288: LD_ADDR_VAR 0 17
117292: PUSH
117293: LD_INT 0
117295: ST_TO_ADDR
// f_capture := false ;
117296: LD_ADDR_VAR 0 18
117300: PUSH
117301: LD_INT 0
117303: ST_TO_ADDR
// f_ignore_civ := false ;
117304: LD_ADDR_VAR 0 19
117308: PUSH
117309: LD_INT 0
117311: ST_TO_ADDR
// f_murder := false ;
117312: LD_ADDR_VAR 0 20
117316: PUSH
117317: LD_INT 0
117319: ST_TO_ADDR
// f_mines := false ;
117320: LD_ADDR_VAR 0 21
117324: PUSH
117325: LD_INT 0
117327: ST_TO_ADDR
// f_repair := false ;
117328: LD_ADDR_VAR 0 22
117332: PUSH
117333: LD_INT 0
117335: ST_TO_ADDR
// f_heal := false ;
117336: LD_ADDR_VAR 0 23
117340: PUSH
117341: LD_INT 0
117343: ST_TO_ADDR
// f_spacetime := false ;
117344: LD_ADDR_VAR 0 24
117348: PUSH
117349: LD_INT 0
117351: ST_TO_ADDR
// f_attack_depot := false ;
117352: LD_ADDR_VAR 0 25
117356: PUSH
117357: LD_INT 0
117359: ST_TO_ADDR
// f_crawl := false ;
117360: LD_ADDR_VAR 0 26
117364: PUSH
117365: LD_INT 0
117367: ST_TO_ADDR
// end ; if f_heal then
117368: LD_VAR 0 23
117372: IFFALSE 117399
// healers := UnitFilter ( group , [ f_class , 4 ] ) ;
117374: LD_ADDR_VAR 0 31
117378: PUSH
117379: LD_VAR 0 4
117383: PPUSH
117384: LD_INT 25
117386: PUSH
117387: LD_INT 4
117389: PUSH
117390: EMPTY
117391: LIST
117392: LIST
117393: PPUSH
117394: CALL_OW 72
117398: ST_TO_ADDR
// if f_repair then
117399: LD_VAR 0 22
117403: IFFALSE 117430
// repairs := UnitFilter ( group , [ f_class , 3 ] ) ;
117405: LD_ADDR_VAR 0 33
117409: PUSH
117410: LD_VAR 0 4
117414: PPUSH
117415: LD_INT 25
117417: PUSH
117418: LD_INT 3
117420: PUSH
117421: EMPTY
117422: LIST
117423: LIST
117424: PPUSH
117425: CALL_OW 72
117429: ST_TO_ADDR
// units_path := [ ] ;
117430: LD_ADDR_VAR 0 16
117434: PUSH
117435: EMPTY
117436: ST_TO_ADDR
// for i = 1 to group do
117437: LD_ADDR_VAR 0 7
117441: PUSH
117442: DOUBLE
117443: LD_INT 1
117445: DEC
117446: ST_TO_ADDR
117447: LD_VAR 0 4
117451: PUSH
117452: FOR_TO
117453: IFFALSE 117482
// units_path := Replace ( units_path , i , path ) ;
117455: LD_ADDR_VAR 0 16
117459: PUSH
117460: LD_VAR 0 16
117464: PPUSH
117465: LD_VAR 0 7
117469: PPUSH
117470: LD_VAR 0 5
117474: PPUSH
117475: CALL_OW 1
117479: ST_TO_ADDR
117480: GO 117452
117482: POP
117483: POP
// repeat for i = group downto 1 do
117484: LD_ADDR_VAR 0 7
117488: PUSH
117489: DOUBLE
117490: LD_VAR 0 4
117494: INC
117495: ST_TO_ADDR
117496: LD_INT 1
117498: PUSH
117499: FOR_DOWNTO
117500: IFFALSE 121622
// begin wait ( 5 ) ;
117502: LD_INT 5
117504: PPUSH
117505: CALL_OW 67
// tmp := [ ] ;
117509: LD_ADDR_VAR 0 14
117513: PUSH
117514: EMPTY
117515: ST_TO_ADDR
// attacking := false ;
117516: LD_ADDR_VAR 0 29
117520: PUSH
117521: LD_INT 0
117523: ST_TO_ADDR
// if IsDead ( group [ i ] ) or not group [ i ] then
117524: LD_VAR 0 4
117528: PUSH
117529: LD_VAR 0 7
117533: ARRAY
117534: PPUSH
117535: CALL_OW 301
117539: PUSH
117540: LD_VAR 0 4
117544: PUSH
117545: LD_VAR 0 7
117549: ARRAY
117550: NOT
117551: OR
117552: IFFALSE 117661
// begin if GetType ( group [ i ] ) = unit_human then
117554: LD_VAR 0 4
117558: PUSH
117559: LD_VAR 0 7
117563: ARRAY
117564: PPUSH
117565: CALL_OW 247
117569: PUSH
117570: LD_INT 1
117572: EQUAL
117573: IFFALSE 117619
// begin to_heal := to_heal diff group [ i ] ;
117575: LD_ADDR_VAR 0 30
117579: PUSH
117580: LD_VAR 0 30
117584: PUSH
117585: LD_VAR 0 4
117589: PUSH
117590: LD_VAR 0 7
117594: ARRAY
117595: DIFF
117596: ST_TO_ADDR
// healers := healers diff group [ i ] ;
117597: LD_ADDR_VAR 0 31
117601: PUSH
117602: LD_VAR 0 31
117606: PUSH
117607: LD_VAR 0 4
117611: PUSH
117612: LD_VAR 0 7
117616: ARRAY
117617: DIFF
117618: ST_TO_ADDR
// end ; group := Delete ( group , i ) ;
117619: LD_ADDR_VAR 0 4
117623: PUSH
117624: LD_VAR 0 4
117628: PPUSH
117629: LD_VAR 0 7
117633: PPUSH
117634: CALL_OW 3
117638: ST_TO_ADDR
// units_path := Delete ( units_path , i ) ;
117639: LD_ADDR_VAR 0 16
117643: PUSH
117644: LD_VAR 0 16
117648: PPUSH
117649: LD_VAR 0 7
117653: PPUSH
117654: CALL_OW 3
117658: ST_TO_ADDR
// continue ;
117659: GO 117499
// end ; if f_repair then
117661: LD_VAR 0 22
117665: IFFALSE 118154
// begin if GetType ( group [ i ] ) = unit_vehicle then
117667: LD_VAR 0 4
117671: PUSH
117672: LD_VAR 0 7
117676: ARRAY
117677: PPUSH
117678: CALL_OW 247
117682: PUSH
117683: LD_INT 2
117685: EQUAL
117686: IFFALSE 117876
// begin if GetLives ( group [ i ] ) < 700 and not group [ i ] in to_repair then
117688: LD_VAR 0 4
117692: PUSH
117693: LD_VAR 0 7
117697: ARRAY
117698: PPUSH
117699: CALL_OW 256
117703: PUSH
117704: LD_INT 700
117706: LESS
117707: PUSH
117708: LD_VAR 0 4
117712: PUSH
117713: LD_VAR 0 7
117717: ARRAY
117718: PUSH
117719: LD_VAR 0 32
117723: IN
117724: NOT
117725: AND
117726: IFFALSE 117750
// to_repair := to_repair union group [ i ] ;
117728: LD_ADDR_VAR 0 32
117732: PUSH
117733: LD_VAR 0 32
117737: PUSH
117738: LD_VAR 0 4
117742: PUSH
117743: LD_VAR 0 7
117747: ARRAY
117748: UNION
117749: ST_TO_ADDR
// if GetLives ( group [ i ] ) = 1000 and group [ i ] in to_repair then
117750: LD_VAR 0 4
117754: PUSH
117755: LD_VAR 0 7
117759: ARRAY
117760: PPUSH
117761: CALL_OW 256
117765: PUSH
117766: LD_INT 1000
117768: EQUAL
117769: PUSH
117770: LD_VAR 0 4
117774: PUSH
117775: LD_VAR 0 7
117779: ARRAY
117780: PUSH
117781: LD_VAR 0 32
117785: IN
117786: AND
117787: IFFALSE 117811
// to_repair := to_repair diff group [ i ] ;
117789: LD_ADDR_VAR 0 32
117793: PUSH
117794: LD_VAR 0 32
117798: PUSH
117799: LD_VAR 0 4
117803: PUSH
117804: LD_VAR 0 7
117808: ARRAY
117809: DIFF
117810: ST_TO_ADDR
// if group [ i ] in to_repair then
117811: LD_VAR 0 4
117815: PUSH
117816: LD_VAR 0 7
117820: ARRAY
117821: PUSH
117822: LD_VAR 0 32
117826: IN
117827: IFFALSE 117874
// begin if not IsInArea ( group [ i ] , f_repair ) then
117829: LD_VAR 0 4
117833: PUSH
117834: LD_VAR 0 7
117838: ARRAY
117839: PPUSH
117840: LD_VAR 0 22
117844: PPUSH
117845: CALL_OW 308
117849: NOT
117850: IFFALSE 117872
// ComMoveToArea ( group [ i ] , f_repair ) ;
117852: LD_VAR 0 4
117856: PUSH
117857: LD_VAR 0 7
117861: ARRAY
117862: PPUSH
117863: LD_VAR 0 22
117867: PPUSH
117868: CALL_OW 113
// continue ;
117872: GO 117499
// end ; end else
117874: GO 118154
// if group [ i ] in repairs then
117876: LD_VAR 0 4
117880: PUSH
117881: LD_VAR 0 7
117885: ARRAY
117886: PUSH
117887: LD_VAR 0 33
117891: IN
117892: IFFALSE 118154
// begin if IsInUnit ( group [ i ] ) then
117894: LD_VAR 0 4
117898: PUSH
117899: LD_VAR 0 7
117903: ARRAY
117904: PPUSH
117905: CALL_OW 310
117909: IFFALSE 117977
// begin z := IsInUnit ( group [ i ] ) ;
117911: LD_ADDR_VAR 0 13
117915: PUSH
117916: LD_VAR 0 4
117920: PUSH
117921: LD_VAR 0 7
117925: ARRAY
117926: PPUSH
117927: CALL_OW 310
117931: ST_TO_ADDR
// if z in to_repair and IsInArea ( z , f_repair ) then
117932: LD_VAR 0 13
117936: PUSH
117937: LD_VAR 0 32
117941: IN
117942: PUSH
117943: LD_VAR 0 13
117947: PPUSH
117948: LD_VAR 0 22
117952: PPUSH
117953: CALL_OW 308
117957: AND
117958: IFFALSE 117975
// ComExitVehicle ( group [ i ] ) ;
117960: LD_VAR 0 4
117964: PUSH
117965: LD_VAR 0 7
117969: ARRAY
117970: PPUSH
117971: CALL_OW 121
// end else
117975: GO 118154
// begin z := UnitFilter ( group , [ [ f_inarea , f_repair ] , [ f_empty ] ] ) ;
117977: LD_ADDR_VAR 0 13
117981: PUSH
117982: LD_VAR 0 4
117986: PPUSH
117987: LD_INT 95
117989: PUSH
117990: LD_VAR 0 22
117994: PUSH
117995: EMPTY
117996: LIST
117997: LIST
117998: PUSH
117999: LD_INT 58
118001: PUSH
118002: EMPTY
118003: LIST
118004: PUSH
118005: EMPTY
118006: LIST
118007: LIST
118008: PPUSH
118009: CALL_OW 72
118013: ST_TO_ADDR
// if not HasTask ( group [ i ] ) then
118014: LD_VAR 0 4
118018: PUSH
118019: LD_VAR 0 7
118023: ARRAY
118024: PPUSH
118025: CALL_OW 314
118029: NOT
118030: IFFALSE 118152
// begin x := NearestUnitToUnit ( z , group [ i ] ) ;
118032: LD_ADDR_VAR 0 10
118036: PUSH
118037: LD_VAR 0 13
118041: PPUSH
118042: LD_VAR 0 4
118046: PUSH
118047: LD_VAR 0 7
118051: ARRAY
118052: PPUSH
118053: CALL_OW 74
118057: ST_TO_ADDR
// if not x then
118058: LD_VAR 0 10
118062: NOT
118063: IFFALSE 118067
// continue ;
118065: GO 117499
// if GetLives ( x ) < 1000 then
118067: LD_VAR 0 10
118071: PPUSH
118072: CALL_OW 256
118076: PUSH
118077: LD_INT 1000
118079: LESS
118080: IFFALSE 118104
// ComRepairVehicle ( group [ i ] , x ) else
118082: LD_VAR 0 4
118086: PUSH
118087: LD_VAR 0 7
118091: ARRAY
118092: PPUSH
118093: LD_VAR 0 10
118097: PPUSH
118098: CALL_OW 129
118102: GO 118152
// if not ( f_heal and GetLives ( group [ i ] ) < 1000 ) then
118104: LD_VAR 0 23
118108: PUSH
118109: LD_VAR 0 4
118113: PUSH
118114: LD_VAR 0 7
118118: ARRAY
118119: PPUSH
118120: CALL_OW 256
118124: PUSH
118125: LD_INT 1000
118127: LESS
118128: AND
118129: NOT
118130: IFFALSE 118152
// ComEnterUnit ( group [ i ] , x ) ;
118132: LD_VAR 0 4
118136: PUSH
118137: LD_VAR 0 7
118141: ARRAY
118142: PPUSH
118143: LD_VAR 0 10
118147: PPUSH
118148: CALL_OW 120
// end ; continue ;
118152: GO 117499
// end ; end ; end ; if f_heal and GetType ( group [ i ] ) = unit_human then
118154: LD_VAR 0 23
118158: PUSH
118159: LD_VAR 0 4
118163: PUSH
118164: LD_VAR 0 7
118168: ARRAY
118169: PPUSH
118170: CALL_OW 247
118174: PUSH
118175: LD_INT 1
118177: EQUAL
118178: AND
118179: IFFALSE 118657
// begin if group [ i ] in healers then
118181: LD_VAR 0 4
118185: PUSH
118186: LD_VAR 0 7
118190: ARRAY
118191: PUSH
118192: LD_VAR 0 31
118196: IN
118197: IFFALSE 118470
// begin if not IsInArea ( group [ i ] , f_heal ) and not HasTask ( group [ i ] ) then
118199: LD_VAR 0 4
118203: PUSH
118204: LD_VAR 0 7
118208: ARRAY
118209: PPUSH
118210: LD_VAR 0 23
118214: PPUSH
118215: CALL_OW 308
118219: NOT
118220: PUSH
118221: LD_VAR 0 4
118225: PUSH
118226: LD_VAR 0 7
118230: ARRAY
118231: PPUSH
118232: CALL_OW 314
118236: NOT
118237: AND
118238: IFFALSE 118262
// ComMoveToArea ( group [ i ] , f_heal ) else
118240: LD_VAR 0 4
118244: PUSH
118245: LD_VAR 0 7
118249: ARRAY
118250: PPUSH
118251: LD_VAR 0 23
118255: PPUSH
118256: CALL_OW 113
118260: GO 118468
// if GetLives ( HealTarget ( group [ i ] ) ) = 1000 then
118262: LD_VAR 0 4
118266: PUSH
118267: LD_VAR 0 7
118271: ARRAY
118272: PPUSH
118273: CALL 88549 0 1
118277: PPUSH
118278: CALL_OW 256
118282: PUSH
118283: LD_INT 1000
118285: EQUAL
118286: IFFALSE 118305
// ComStop ( group [ i ] ) else
118288: LD_VAR 0 4
118292: PUSH
118293: LD_VAR 0 7
118297: ARRAY
118298: PPUSH
118299: CALL_OW 141
118303: GO 118468
// if not HasTask ( group [ i ] ) and to_heal then
118305: LD_VAR 0 4
118309: PUSH
118310: LD_VAR 0 7
118314: ARRAY
118315: PPUSH
118316: CALL_OW 314
118320: NOT
118321: PUSH
118322: LD_VAR 0 30
118326: AND
118327: IFFALSE 118468
// begin z := NearestUnitToUnit ( UnitFilter ( to_heal , [ f_not , [ f_inside ] ] ) , group [ i ] ) ;
118329: LD_ADDR_VAR 0 13
118333: PUSH
118334: LD_VAR 0 30
118338: PPUSH
118339: LD_INT 3
118341: PUSH
118342: LD_INT 54
118344: PUSH
118345: EMPTY
118346: LIST
118347: PUSH
118348: EMPTY
118349: LIST
118350: LIST
118351: PPUSH
118352: CALL_OW 72
118356: PPUSH
118357: LD_VAR 0 4
118361: PUSH
118362: LD_VAR 0 7
118366: ARRAY
118367: PPUSH
118368: CALL_OW 74
118372: ST_TO_ADDR
// if z then
118373: LD_VAR 0 13
118377: IFFALSE 118468
// if FilterAllUnits ( [ [ f_dist , z , 10 ] , [ f_enemy , GetSide ( z ) ] ] ) = 0 then
118379: LD_INT 91
118381: PUSH
118382: LD_VAR 0 13
118386: PUSH
118387: LD_INT 10
118389: PUSH
118390: EMPTY
118391: LIST
118392: LIST
118393: LIST
118394: PUSH
118395: LD_INT 81
118397: PUSH
118398: LD_VAR 0 13
118402: PPUSH
118403: CALL_OW 255
118407: PUSH
118408: EMPTY
118409: LIST
118410: LIST
118411: PUSH
118412: EMPTY
118413: LIST
118414: LIST
118415: PPUSH
118416: CALL_OW 69
118420: PUSH
118421: LD_INT 0
118423: EQUAL
118424: IFFALSE 118448
// ComHeal ( group [ i ] , z ) else
118426: LD_VAR 0 4
118430: PUSH
118431: LD_VAR 0 7
118435: ARRAY
118436: PPUSH
118437: LD_VAR 0 13
118441: PPUSH
118442: CALL_OW 128
118446: GO 118468
// ComMoveToArea ( group [ i ] , f_heal ) ;
118448: LD_VAR 0 4
118452: PUSH
118453: LD_VAR 0 7
118457: ARRAY
118458: PPUSH
118459: LD_VAR 0 23
118463: PPUSH
118464: CALL_OW 113
// end ; continue ;
118468: GO 117499
// end ; if GetLives ( group [ i ] ) < 700 and not group [ i ] in to_heal then
118470: LD_VAR 0 4
118474: PUSH
118475: LD_VAR 0 7
118479: ARRAY
118480: PPUSH
118481: CALL_OW 256
118485: PUSH
118486: LD_INT 700
118488: LESS
118489: PUSH
118490: LD_VAR 0 4
118494: PUSH
118495: LD_VAR 0 7
118499: ARRAY
118500: PUSH
118501: LD_VAR 0 30
118505: IN
118506: NOT
118507: AND
118508: IFFALSE 118532
// to_heal := to_heal union group [ i ] ;
118510: LD_ADDR_VAR 0 30
118514: PUSH
118515: LD_VAR 0 30
118519: PUSH
118520: LD_VAR 0 4
118524: PUSH
118525: LD_VAR 0 7
118529: ARRAY
118530: UNION
118531: ST_TO_ADDR
// if group [ i ] in to_heal then
118532: LD_VAR 0 4
118536: PUSH
118537: LD_VAR 0 7
118541: ARRAY
118542: PUSH
118543: LD_VAR 0 30
118547: IN
118548: IFFALSE 118657
// begin if GetLives ( group [ i ] ) = 1000 then
118550: LD_VAR 0 4
118554: PUSH
118555: LD_VAR 0 7
118559: ARRAY
118560: PPUSH
118561: CALL_OW 256
118565: PUSH
118566: LD_INT 1000
118568: EQUAL
118569: IFFALSE 118595
// to_heal := to_heal diff group [ i ] else
118571: LD_ADDR_VAR 0 30
118575: PUSH
118576: LD_VAR 0 30
118580: PUSH
118581: LD_VAR 0 4
118585: PUSH
118586: LD_VAR 0 7
118590: ARRAY
118591: DIFF
118592: ST_TO_ADDR
118593: GO 118657
// begin if not IsInArea ( group [ i ] , to_heal ) then
118595: LD_VAR 0 4
118599: PUSH
118600: LD_VAR 0 7
118604: ARRAY
118605: PPUSH
118606: LD_VAR 0 30
118610: PPUSH
118611: CALL_OW 308
118615: NOT
118616: IFFALSE 118640
// ComMoveToArea ( group [ i ] , f_heal ) else
118618: LD_VAR 0 4
118622: PUSH
118623: LD_VAR 0 7
118627: ARRAY
118628: PPUSH
118629: LD_VAR 0 23
118633: PPUSH
118634: CALL_OW 113
118638: GO 118655
// ComHold ( group [ i ] ) ;
118640: LD_VAR 0 4
118644: PUSH
118645: LD_VAR 0 7
118649: ARRAY
118650: PPUSH
118651: CALL_OW 140
// continue ;
118655: GO 117499
// end ; end ; end ; if not EnemyInRange ( group [ i ] , 10 ) and not units_path [ i ] = [ ] then
118657: LD_VAR 0 4
118661: PUSH
118662: LD_VAR 0 7
118666: ARRAY
118667: PPUSH
118668: LD_INT 10
118670: PPUSH
118671: CALL 86331 0 2
118675: NOT
118676: PUSH
118677: LD_VAR 0 16
118681: PUSH
118682: LD_VAR 0 7
118686: ARRAY
118687: PUSH
118688: EMPTY
118689: EQUAL
118690: NOT
118691: AND
118692: IFFALSE 118958
// begin if GetEngine ( group [ i ] ) in [ engine_combustion , engine_solar ] then
118694: LD_VAR 0 4
118698: PUSH
118699: LD_VAR 0 7
118703: ARRAY
118704: PPUSH
118705: CALL_OW 262
118709: PUSH
118710: LD_INT 1
118712: PUSH
118713: LD_INT 2
118715: PUSH
118716: EMPTY
118717: LIST
118718: LIST
118719: IN
118720: IFFALSE 118761
// if GetFuel ( group [ i ] ) < 10 then
118722: LD_VAR 0 4
118726: PUSH
118727: LD_VAR 0 7
118731: ARRAY
118732: PPUSH
118733: CALL_OW 261
118737: PUSH
118738: LD_INT 10
118740: LESS
118741: IFFALSE 118761
// SetFuel ( group [ i ] , 12 ) ;
118743: LD_VAR 0 4
118747: PUSH
118748: LD_VAR 0 7
118752: ARRAY
118753: PPUSH
118754: LD_INT 12
118756: PPUSH
118757: CALL_OW 240
// if units_path [ i ] then
118761: LD_VAR 0 16
118765: PUSH
118766: LD_VAR 0 7
118770: ARRAY
118771: IFFALSE 118956
// begin if GetDistUnitXY ( group [ i ] , units_path [ i ] [ 1 ] [ 1 ] , units_path [ i ] [ 1 ] [ 2 ] ) > 6 then
118773: LD_VAR 0 4
118777: PUSH
118778: LD_VAR 0 7
118782: ARRAY
118783: PPUSH
118784: LD_VAR 0 16
118788: PUSH
118789: LD_VAR 0 7
118793: ARRAY
118794: PUSH
118795: LD_INT 1
118797: ARRAY
118798: PUSH
118799: LD_INT 1
118801: ARRAY
118802: PPUSH
118803: LD_VAR 0 16
118807: PUSH
118808: LD_VAR 0 7
118812: ARRAY
118813: PUSH
118814: LD_INT 1
118816: ARRAY
118817: PUSH
118818: LD_INT 2
118820: ARRAY
118821: PPUSH
118822: CALL_OW 297
118826: PUSH
118827: LD_INT 6
118829: GREATER
118830: IFFALSE 118905
// begin if not HasTask ( group [ i ] ) then
118832: LD_VAR 0 4
118836: PUSH
118837: LD_VAR 0 7
118841: ARRAY
118842: PPUSH
118843: CALL_OW 314
118847: NOT
118848: IFFALSE 118903
// ComAgressiveMove ( group [ i ] , units_path [ i ] [ 1 ] [ 1 ] , units_path [ i ] [ 1 ] [ 2 ] ) ;
118850: LD_VAR 0 4
118854: PUSH
118855: LD_VAR 0 7
118859: ARRAY
118860: PPUSH
118861: LD_VAR 0 16
118865: PUSH
118866: LD_VAR 0 7
118870: ARRAY
118871: PUSH
118872: LD_INT 1
118874: ARRAY
118875: PUSH
118876: LD_INT 1
118878: ARRAY
118879: PPUSH
118880: LD_VAR 0 16
118884: PUSH
118885: LD_VAR 0 7
118889: ARRAY
118890: PUSH
118891: LD_INT 1
118893: ARRAY
118894: PUSH
118895: LD_INT 2
118897: ARRAY
118898: PPUSH
118899: CALL_OW 114
// end else
118903: GO 118956
// begin tmp2 := Delete ( units_path [ i ] , 1 ) ;
118905: LD_ADDR_VAR 0 15
118909: PUSH
118910: LD_VAR 0 16
118914: PUSH
118915: LD_VAR 0 7
118919: ARRAY
118920: PPUSH
118921: LD_INT 1
118923: PPUSH
118924: CALL_OW 3
118928: ST_TO_ADDR
// units_path := Replace ( units_path , i , tmp2 ) ;
118929: LD_ADDR_VAR 0 16
118933: PUSH
118934: LD_VAR 0 16
118938: PPUSH
118939: LD_VAR 0 7
118943: PPUSH
118944: LD_VAR 0 15
118948: PPUSH
118949: CALL_OW 1
118953: ST_TO_ADDR
// continue ;
118954: GO 117499
// end ; end ; end else
118956: GO 121620
// begin tmp := FilterAllUnits ( [ f_enemy , GetSide ( group [ i ] ) ] ) ;
118958: LD_ADDR_VAR 0 14
118962: PUSH
118963: LD_INT 81
118965: PUSH
118966: LD_VAR 0 4
118970: PUSH
118971: LD_VAR 0 7
118975: ARRAY
118976: PPUSH
118977: CALL_OW 255
118981: PUSH
118982: EMPTY
118983: LIST
118984: LIST
118985: PPUSH
118986: CALL_OW 69
118990: ST_TO_ADDR
// if not tmp then
118991: LD_VAR 0 14
118995: NOT
118996: IFFALSE 119000
// continue ;
118998: GO 117499
// if f_ignore_area then
119000: LD_VAR 0 17
119004: IFFALSE 119092
// begin tmp2 := UnitFilter ( tmp , [ f_not , [ f_distxy , f_ignore_area [ 1 ] , f_ignore_area [ 2 ] , f_ignore_area [ 3 ] ] ] ) ;
119006: LD_ADDR_VAR 0 15
119010: PUSH
119011: LD_VAR 0 14
119015: PPUSH
119016: LD_INT 3
119018: PUSH
119019: LD_INT 92
119021: PUSH
119022: LD_VAR 0 17
119026: PUSH
119027: LD_INT 1
119029: ARRAY
119030: PUSH
119031: LD_VAR 0 17
119035: PUSH
119036: LD_INT 2
119038: ARRAY
119039: PUSH
119040: LD_VAR 0 17
119044: PUSH
119045: LD_INT 3
119047: ARRAY
119048: PUSH
119049: EMPTY
119050: LIST
119051: LIST
119052: LIST
119053: LIST
119054: PUSH
119055: EMPTY
119056: LIST
119057: LIST
119058: PPUSH
119059: CALL_OW 72
119063: ST_TO_ADDR
// if ( tmp diff tmp2 ) then
119064: LD_VAR 0 14
119068: PUSH
119069: LD_VAR 0 15
119073: DIFF
119074: IFFALSE 119092
// tmp := tmp diff tmp2 ;
119076: LD_ADDR_VAR 0 14
119080: PUSH
119081: LD_VAR 0 14
119085: PUSH
119086: LD_VAR 0 15
119090: DIFF
119091: ST_TO_ADDR
// end ; if not f_murder then
119092: LD_VAR 0 20
119096: NOT
119097: IFFALSE 119155
// begin tmp2 := UnitFilter ( tmp , [ f_not , [ f_ok ] ] ) ;
119099: LD_ADDR_VAR 0 15
119103: PUSH
119104: LD_VAR 0 14
119108: PPUSH
119109: LD_INT 3
119111: PUSH
119112: LD_INT 50
119114: PUSH
119115: EMPTY
119116: LIST
119117: PUSH
119118: EMPTY
119119: LIST
119120: LIST
119121: PPUSH
119122: CALL_OW 72
119126: ST_TO_ADDR
// if ( tmp diff tmp2 ) then
119127: LD_VAR 0 14
119131: PUSH
119132: LD_VAR 0 15
119136: DIFF
119137: IFFALSE 119155
// tmp := tmp diff tmp2 ;
119139: LD_ADDR_VAR 0 14
119143: PUSH
119144: LD_VAR 0 14
119148: PUSH
119149: LD_VAR 0 15
119153: DIFF
119154: ST_TO_ADDR
// end ; tmp := SortByDistanceUnit ( group [ i ] , tmp , true , true ) ;
119155: LD_ADDR_VAR 0 14
119159: PUSH
119160: LD_VAR 0 4
119164: PUSH
119165: LD_VAR 0 7
119169: ARRAY
119170: PPUSH
119171: LD_VAR 0 14
119175: PPUSH
119176: LD_INT 1
119178: PPUSH
119179: LD_INT 1
119181: PPUSH
119182: CALL 58875 0 4
119186: ST_TO_ADDR
// if GetClass ( group [ i ] ) = 1 then
119187: LD_VAR 0 4
119191: PUSH
119192: LD_VAR 0 7
119196: ARRAY
119197: PPUSH
119198: CALL_OW 257
119202: PUSH
119203: LD_INT 1
119205: EQUAL
119206: IFFALSE 119654
// begin if WantPlant ( group [ i ] ) then
119208: LD_VAR 0 4
119212: PUSH
119213: LD_VAR 0 7
119217: ARRAY
119218: PPUSH
119219: CALL 58376 0 1
119223: IFFALSE 119227
// continue ;
119225: GO 117499
// if f_capture and not IsInUnit ( group [ i ] ) and tmp [ 1 ] in UnitFilter ( tmp , [ [ f_type , unit_vehicle ] , [ f_empty ] ] ) then
119227: LD_VAR 0 18
119231: PUSH
119232: LD_VAR 0 4
119236: PUSH
119237: LD_VAR 0 7
119241: ARRAY
119242: PPUSH
119243: CALL_OW 310
119247: NOT
119248: AND
119249: PUSH
119250: LD_VAR 0 14
119254: PUSH
119255: LD_INT 1
119257: ARRAY
119258: PUSH
119259: LD_VAR 0 14
119263: PPUSH
119264: LD_INT 21
119266: PUSH
119267: LD_INT 2
119269: PUSH
119270: EMPTY
119271: LIST
119272: LIST
119273: PUSH
119274: LD_INT 58
119276: PUSH
119277: EMPTY
119278: LIST
119279: PUSH
119280: EMPTY
119281: LIST
119282: LIST
119283: PPUSH
119284: CALL_OW 72
119288: IN
119289: AND
119290: IFFALSE 119326
// begin ComEnterUnit ( group [ i ] , tmp [ 1 ] ) ;
119292: LD_VAR 0 4
119296: PUSH
119297: LD_VAR 0 7
119301: ARRAY
119302: PPUSH
119303: LD_VAR 0 14
119307: PUSH
119308: LD_INT 1
119310: ARRAY
119311: PPUSH
119312: CALL_OW 120
// attacking := true ;
119316: LD_ADDR_VAR 0 29
119320: PUSH
119321: LD_INT 1
119323: ST_TO_ADDR
// continue ;
119324: GO 117499
// end ; if f_crawl and GetClass ( group [ i ] ) = 1 and GetLives ( group [ i ] ) < 800 and not Crawls ( group [ i ] ) then
119326: LD_VAR 0 26
119330: PUSH
119331: LD_VAR 0 4
119335: PUSH
119336: LD_VAR 0 7
119340: ARRAY
119341: PPUSH
119342: CALL_OW 257
119346: PUSH
119347: LD_INT 1
119349: EQUAL
119350: AND
119351: PUSH
119352: LD_VAR 0 4
119356: PUSH
119357: LD_VAR 0 7
119361: ARRAY
119362: PPUSH
119363: CALL_OW 256
119367: PUSH
119368: LD_INT 800
119370: LESS
119371: AND
119372: PUSH
119373: LD_VAR 0 4
119377: PUSH
119378: LD_VAR 0 7
119382: ARRAY
119383: PPUSH
119384: CALL_OW 318
119388: NOT
119389: AND
119390: IFFALSE 119407
// ComCrawl ( group [ i ] ) ;
119392: LD_VAR 0 4
119396: PUSH
119397: LD_VAR 0 7
119401: ARRAY
119402: PPUSH
119403: CALL_OW 137
// if f_mines then
119407: LD_VAR 0 21
119411: IFFALSE 119654
// begin if GetType ( tmp [ 1 ] ) = unit_building and not tmp [ 1 ] in mined then
119413: LD_VAR 0 14
119417: PUSH
119418: LD_INT 1
119420: ARRAY
119421: PPUSH
119422: CALL_OW 247
119426: PUSH
119427: LD_INT 3
119429: EQUAL
119430: PUSH
119431: LD_VAR 0 14
119435: PUSH
119436: LD_INT 1
119438: ARRAY
119439: PUSH
119440: LD_VAR 0 27
119444: IN
119445: NOT
119446: AND
119447: IFFALSE 119654
// begin x := GetX ( tmp [ 1 ] ) ;
119449: LD_ADDR_VAR 0 10
119453: PUSH
119454: LD_VAR 0 14
119458: PUSH
119459: LD_INT 1
119461: ARRAY
119462: PPUSH
119463: CALL_OW 250
119467: ST_TO_ADDR
// y := GetY ( tmp [ 1 ] ) ;
119468: LD_ADDR_VAR 0 11
119472: PUSH
119473: LD_VAR 0 14
119477: PUSH
119478: LD_INT 1
119480: ARRAY
119481: PPUSH
119482: CALL_OW 251
119486: ST_TO_ADDR
// d := ReverseDir ( group [ i ] ) ;
119487: LD_ADDR_VAR 0 12
119491: PUSH
119492: LD_VAR 0 4
119496: PUSH
119497: LD_VAR 0 7
119501: ARRAY
119502: PPUSH
119503: CALL 86416 0 1
119507: ST_TO_ADDR
// ComPlaceDelayedCharge ( group [ i ] , x , y , tmp [ 1 ] ) ;
119508: LD_VAR 0 4
119512: PUSH
119513: LD_VAR 0 7
119517: ARRAY
119518: PPUSH
119519: LD_VAR 0 10
119523: PPUSH
119524: LD_VAR 0 11
119528: PPUSH
119529: LD_VAR 0 14
119533: PUSH
119534: LD_INT 1
119536: ARRAY
119537: PPUSH
119538: CALL_OW 132
// AddComMoveXY ( group [ i ] , ShiftX ( x , d , 7 ) , ShiftY ( y , d , 7 ) ) ;
119542: LD_VAR 0 4
119546: PUSH
119547: LD_VAR 0 7
119551: ARRAY
119552: PPUSH
119553: LD_VAR 0 10
119557: PPUSH
119558: LD_VAR 0 12
119562: PPUSH
119563: LD_INT 7
119565: PPUSH
119566: CALL_OW 272
119570: PPUSH
119571: LD_VAR 0 11
119575: PPUSH
119576: LD_VAR 0 12
119580: PPUSH
119581: LD_INT 7
119583: PPUSH
119584: CALL_OW 273
119588: PPUSH
119589: CALL_OW 171
// SetTag ( group [ i ] , 71 ) ;
119593: LD_VAR 0 4
119597: PUSH
119598: LD_VAR 0 7
119602: ARRAY
119603: PPUSH
119604: LD_INT 71
119606: PPUSH
119607: CALL_OW 109
// mined := Replace ( mined , mined + 1 , tmp [ 1 ] ) ;
119611: LD_ADDR_VAR 0 27
119615: PUSH
119616: LD_VAR 0 27
119620: PPUSH
119621: LD_VAR 0 27
119625: PUSH
119626: LD_INT 1
119628: PLUS
119629: PPUSH
119630: LD_VAR 0 14
119634: PUSH
119635: LD_INT 1
119637: ARRAY
119638: PPUSH
119639: CALL_OW 1
119643: ST_TO_ADDR
// attacking := true ;
119644: LD_ADDR_VAR 0 29
119648: PUSH
119649: LD_INT 1
119651: ST_TO_ADDR
// continue ;
119652: GO 117499
// end ; end ; end ; if GetClass ( group [ i ] ) = 17 and not GetTag ( group [ i ] ) = 71 then
119654: LD_VAR 0 4
119658: PUSH
119659: LD_VAR 0 7
119663: ARRAY
119664: PPUSH
119665: CALL_OW 257
119669: PUSH
119670: LD_INT 17
119672: EQUAL
119673: PUSH
119674: LD_VAR 0 4
119678: PUSH
119679: LD_VAR 0 7
119683: ARRAY
119684: PPUSH
119685: CALL_OW 110
119689: PUSH
119690: LD_INT 71
119692: EQUAL
119693: NOT
119694: AND
119695: IFFALSE 119841
// begin attacking := false ;
119697: LD_ADDR_VAR 0 29
119701: PUSH
119702: LD_INT 0
119704: ST_TO_ADDR
// k := 5 ;
119705: LD_ADDR_VAR 0 9
119709: PUSH
119710: LD_INT 5
119712: ST_TO_ADDR
// if tmp < k then
119713: LD_VAR 0 14
119717: PUSH
119718: LD_VAR 0 9
119722: LESS
119723: IFFALSE 119735
// k := tmp ;
119725: LD_ADDR_VAR 0 9
119729: PUSH
119730: LD_VAR 0 14
119734: ST_TO_ADDR
// for j = 1 to k do
119735: LD_ADDR_VAR 0 8
119739: PUSH
119740: DOUBLE
119741: LD_INT 1
119743: DEC
119744: ST_TO_ADDR
119745: LD_VAR 0 9
119749: PUSH
119750: FOR_TO
119751: IFFALSE 119839
// begin if not tmp [ j ] in UnitFilter ( tmp , [ f_empty ] ) then
119753: LD_VAR 0 14
119757: PUSH
119758: LD_VAR 0 8
119762: ARRAY
119763: PUSH
119764: LD_VAR 0 14
119768: PPUSH
119769: LD_INT 58
119771: PUSH
119772: EMPTY
119773: LIST
119774: PPUSH
119775: CALL_OW 72
119779: IN
119780: NOT
119781: IFFALSE 119837
// begin ComAttackUnit ( group [ i ] , tmp [ j ] ) ;
119783: LD_VAR 0 4
119787: PUSH
119788: LD_VAR 0 7
119792: ARRAY
119793: PPUSH
119794: LD_VAR 0 14
119798: PUSH
119799: LD_VAR 0 8
119803: ARRAY
119804: PPUSH
119805: CALL_OW 115
// attacking := true ;
119809: LD_ADDR_VAR 0 29
119813: PUSH
119814: LD_INT 1
119816: ST_TO_ADDR
// SetTag ( group [ i ] , 71 ) ;
119817: LD_VAR 0 4
119821: PUSH
119822: LD_VAR 0 7
119826: ARRAY
119827: PPUSH
119828: LD_INT 71
119830: PPUSH
119831: CALL_OW 109
// continue ;
119835: GO 119750
// end ; end ;
119837: GO 119750
119839: POP
119840: POP
// end ; if GetClass ( group [ i ] ) = 8 or GetWeapon ( group [ i ] ) in [ ar_rocket_launcher , ru_rocket_launcher , us_rocket_launcher , ru_rocket ] then
119841: LD_VAR 0 4
119845: PUSH
119846: LD_VAR 0 7
119850: ARRAY
119851: PPUSH
119852: CALL_OW 257
119856: PUSH
119857: LD_INT 8
119859: EQUAL
119860: PUSH
119861: LD_VAR 0 4
119865: PUSH
119866: LD_VAR 0 7
119870: ARRAY
119871: PPUSH
119872: CALL_OW 264
119876: PUSH
119877: LD_INT 28
119879: PUSH
119880: LD_INT 45
119882: PUSH
119883: LD_INT 7
119885: PUSH
119886: LD_INT 47
119888: PUSH
119889: EMPTY
119890: LIST
119891: LIST
119892: LIST
119893: LIST
119894: IN
119895: OR
119896: IFFALSE 120152
// begin attacking := false ;
119898: LD_ADDR_VAR 0 29
119902: PUSH
119903: LD_INT 0
119905: ST_TO_ADDR
// if GetBType ( tmp [ 1 ] ) in [ b_bunker , b_breastwork , b_turret , b_armoury , b_barracks ] then
119906: LD_VAR 0 14
119910: PUSH
119911: LD_INT 1
119913: ARRAY
119914: PPUSH
119915: CALL_OW 266
119919: PUSH
119920: LD_INT 32
119922: PUSH
119923: LD_INT 31
119925: PUSH
119926: LD_INT 33
119928: PUSH
119929: LD_INT 4
119931: PUSH
119932: LD_INT 5
119934: PUSH
119935: EMPTY
119936: LIST
119937: LIST
119938: LIST
119939: LIST
119940: LIST
119941: IN
119942: IFFALSE 120128
// begin k := GetBuildingHexes ( GetBType ( tmp [ 1 ] ) , GetX ( tmp [ 1 ] ) , GetY ( tmp [ 1 ] ) , GetDir ( tmp [ 1 ] ) , GetNation ( tmp [ 1 ] ) , 0 ) ;
119944: LD_ADDR_VAR 0 9
119948: PUSH
119949: LD_VAR 0 14
119953: PUSH
119954: LD_INT 1
119956: ARRAY
119957: PPUSH
119958: CALL_OW 266
119962: PPUSH
119963: LD_VAR 0 14
119967: PUSH
119968: LD_INT 1
119970: ARRAY
119971: PPUSH
119972: CALL_OW 250
119976: PPUSH
119977: LD_VAR 0 14
119981: PUSH
119982: LD_INT 1
119984: ARRAY
119985: PPUSH
119986: CALL_OW 251
119990: PPUSH
119991: LD_VAR 0 14
119995: PUSH
119996: LD_INT 1
119998: ARRAY
119999: PPUSH
120000: CALL_OW 254
120004: PPUSH
120005: LD_VAR 0 14
120009: PUSH
120010: LD_INT 1
120012: ARRAY
120013: PPUSH
120014: CALL_OW 248
120018: PPUSH
120019: LD_INT 0
120021: PPUSH
120022: CALL 67786 0 6
120026: ST_TO_ADDR
// j := GetClosestHex ( group [ i ] , k ) ;
120027: LD_ADDR_VAR 0 8
120031: PUSH
120032: LD_VAR 0 4
120036: PUSH
120037: LD_VAR 0 7
120041: ARRAY
120042: PPUSH
120043: LD_VAR 0 9
120047: PPUSH
120048: CALL 86529 0 2
120052: ST_TO_ADDR
// if j then
120053: LD_VAR 0 8
120057: IFFALSE 120126
// if ValidHex ( j [ 1 ] , j [ 2 ] ) then
120059: LD_VAR 0 8
120063: PUSH
120064: LD_INT 1
120066: ARRAY
120067: PPUSH
120068: LD_VAR 0 8
120072: PUSH
120073: LD_INT 2
120075: ARRAY
120076: PPUSH
120077: CALL_OW 488
120081: IFFALSE 120126
// begin ComAttackPlace ( group [ i ] , j [ 1 ] , j [ 2 ] ) ;
120083: LD_VAR 0 4
120087: PUSH
120088: LD_VAR 0 7
120092: ARRAY
120093: PPUSH
120094: LD_VAR 0 8
120098: PUSH
120099: LD_INT 1
120101: ARRAY
120102: PPUSH
120103: LD_VAR 0 8
120107: PUSH
120108: LD_INT 2
120110: ARRAY
120111: PPUSH
120112: CALL_OW 116
// attacking := true ;
120116: LD_ADDR_VAR 0 29
120120: PUSH
120121: LD_INT 1
120123: ST_TO_ADDR
// continue ;
120124: GO 117499
// end ; end else
120126: GO 120152
// ComAttackUnit ( group [ i ] , tmp [ 1 ] ) ;
120128: LD_VAR 0 4
120132: PUSH
120133: LD_VAR 0 7
120137: ARRAY
120138: PPUSH
120139: LD_VAR 0 14
120143: PUSH
120144: LD_INT 1
120146: ARRAY
120147: PPUSH
120148: CALL_OW 115
// end ; if GetChassis ( group [ i ] ) = ar_hovercraft then
120152: LD_VAR 0 4
120156: PUSH
120157: LD_VAR 0 7
120161: ARRAY
120162: PPUSH
120163: CALL_OW 265
120167: PUSH
120168: LD_INT 11
120170: EQUAL
120171: IFFALSE 120449
// begin k := 10 ;
120173: LD_ADDR_VAR 0 9
120177: PUSH
120178: LD_INT 10
120180: ST_TO_ADDR
// x := 0 ;
120181: LD_ADDR_VAR 0 10
120185: PUSH
120186: LD_INT 0
120188: ST_TO_ADDR
// if tmp < k then
120189: LD_VAR 0 14
120193: PUSH
120194: LD_VAR 0 9
120198: LESS
120199: IFFALSE 120211
// k := tmp ;
120201: LD_ADDR_VAR 0 9
120205: PUSH
120206: LD_VAR 0 14
120210: ST_TO_ADDR
// for j = k downto 1 do
120211: LD_ADDR_VAR 0 8
120215: PUSH
120216: DOUBLE
120217: LD_VAR 0 9
120221: INC
120222: ST_TO_ADDR
120223: LD_INT 1
120225: PUSH
120226: FOR_DOWNTO
120227: IFFALSE 120302
// begin if GetType ( tmp [ j ] ) = unit_human then
120229: LD_VAR 0 14
120233: PUSH
120234: LD_VAR 0 8
120238: ARRAY
120239: PPUSH
120240: CALL_OW 247
120244: PUSH
120245: LD_INT 1
120247: EQUAL
120248: IFFALSE 120300
// begin AttackHovercraft ( group [ i ] , tmp [ j ] ) ;
120250: LD_VAR 0 4
120254: PUSH
120255: LD_VAR 0 7
120259: ARRAY
120260: PPUSH
120261: LD_VAR 0 14
120265: PUSH
120266: LD_VAR 0 8
120270: ARRAY
120271: PPUSH
120272: CALL 86783 0 2
// x := tmp [ j ] ;
120276: LD_ADDR_VAR 0 10
120280: PUSH
120281: LD_VAR 0 14
120285: PUSH
120286: LD_VAR 0 8
120290: ARRAY
120291: ST_TO_ADDR
// attacking := true ;
120292: LD_ADDR_VAR 0 29
120296: PUSH
120297: LD_INT 1
120299: ST_TO_ADDR
// end ; end ;
120300: GO 120226
120302: POP
120303: POP
// if not x then
120304: LD_VAR 0 10
120308: NOT
120309: IFFALSE 120449
// begin attacking := true ;
120311: LD_ADDR_VAR 0 29
120315: PUSH
120316: LD_INT 1
120318: ST_TO_ADDR
// if GetHexInfo ( GetX ( group [ i ] ) , GetY ( group [ i ] ) ) [ 2 ] = GetHexInfo ( GetX ( tmp [ 1 ] ) , GetY ( tmp [ 1 ] ) ) [ 2 ] then
120319: LD_VAR 0 4
120323: PUSH
120324: LD_VAR 0 7
120328: ARRAY
120329: PPUSH
120330: CALL_OW 250
120334: PPUSH
120335: LD_VAR 0 4
120339: PUSH
120340: LD_VAR 0 7
120344: ARRAY
120345: PPUSH
120346: CALL_OW 251
120350: PPUSH
120351: CALL_OW 546
120355: PUSH
120356: LD_INT 2
120358: ARRAY
120359: PUSH
120360: LD_VAR 0 14
120364: PUSH
120365: LD_INT 1
120367: ARRAY
120368: PPUSH
120369: CALL_OW 250
120373: PPUSH
120374: LD_VAR 0 14
120378: PUSH
120379: LD_INT 1
120381: ARRAY
120382: PPUSH
120383: CALL_OW 251
120387: PPUSH
120388: CALL_OW 546
120392: PUSH
120393: LD_INT 2
120395: ARRAY
120396: EQUAL
120397: IFFALSE 120425
// AttackHovercraft ( group [ i ] , tmp [ 1 ] ) else
120399: LD_VAR 0 4
120403: PUSH
120404: LD_VAR 0 7
120408: ARRAY
120409: PPUSH
120410: LD_VAR 0 14
120414: PUSH
120415: LD_INT 1
120417: ARRAY
120418: PPUSH
120419: CALL 86783 0 2
120423: GO 120449
// ComAttackUnit ( group [ i ] , tmp [ 1 ] ) ;
120425: LD_VAR 0 4
120429: PUSH
120430: LD_VAR 0 7
120434: ARRAY
120435: PPUSH
120436: LD_VAR 0 14
120440: PUSH
120441: LD_INT 1
120443: ARRAY
120444: PPUSH
120445: CALL_OW 115
// end ; end ; if GetWeapon ( group [ i ] ) = ar_selfpropelled_bomb then
120449: LD_VAR 0 4
120453: PUSH
120454: LD_VAR 0 7
120458: ARRAY
120459: PPUSH
120460: CALL_OW 264
120464: PUSH
120465: LD_INT 29
120467: EQUAL
120468: IFFALSE 120834
// begin if WantsToAttack ( group [ i ] ) in bombed then
120470: LD_VAR 0 4
120474: PUSH
120475: LD_VAR 0 7
120479: ARRAY
120480: PPUSH
120481: CALL_OW 319
120485: PUSH
120486: LD_VAR 0 28
120490: IN
120491: IFFALSE 120495
// continue ;
120493: GO 117499
// k := 8 ;
120495: LD_ADDR_VAR 0 9
120499: PUSH
120500: LD_INT 8
120502: ST_TO_ADDR
// x := 0 ;
120503: LD_ADDR_VAR 0 10
120507: PUSH
120508: LD_INT 0
120510: ST_TO_ADDR
// if tmp < k then
120511: LD_VAR 0 14
120515: PUSH
120516: LD_VAR 0 9
120520: LESS
120521: IFFALSE 120533
// k := tmp ;
120523: LD_ADDR_VAR 0 9
120527: PUSH
120528: LD_VAR 0 14
120532: ST_TO_ADDR
// for j = 1 to k do
120533: LD_ADDR_VAR 0 8
120537: PUSH
120538: DOUBLE
120539: LD_INT 1
120541: DEC
120542: ST_TO_ADDR
120543: LD_VAR 0 9
120547: PUSH
120548: FOR_TO
120549: IFFALSE 120681
// begin if GetType ( tmp [ j ] ) = unit_building then
120551: LD_VAR 0 14
120555: PUSH
120556: LD_VAR 0 8
120560: ARRAY
120561: PPUSH
120562: CALL_OW 247
120566: PUSH
120567: LD_INT 3
120569: EQUAL
120570: IFFALSE 120679
// if not tmp [ j ] in bombed and UnitsInside ( tmp [ j ] ) then
120572: LD_VAR 0 14
120576: PUSH
120577: LD_VAR 0 8
120581: ARRAY
120582: PUSH
120583: LD_VAR 0 28
120587: IN
120588: NOT
120589: PUSH
120590: LD_VAR 0 14
120594: PUSH
120595: LD_VAR 0 8
120599: ARRAY
120600: PPUSH
120601: CALL_OW 313
120605: AND
120606: IFFALSE 120679
// begin ComAttackUnit ( group [ i ] , tmp [ j ] ) ;
120608: LD_VAR 0 4
120612: PUSH
120613: LD_VAR 0 7
120617: ARRAY
120618: PPUSH
120619: LD_VAR 0 14
120623: PUSH
120624: LD_VAR 0 8
120628: ARRAY
120629: PPUSH
120630: CALL_OW 115
// bombed := Replace ( bombed , bombed + 1 , tmp [ j ] ) ;
120634: LD_ADDR_VAR 0 28
120638: PUSH
120639: LD_VAR 0 28
120643: PPUSH
120644: LD_VAR 0 28
120648: PUSH
120649: LD_INT 1
120651: PLUS
120652: PPUSH
120653: LD_VAR 0 14
120657: PUSH
120658: LD_VAR 0 8
120662: ARRAY
120663: PPUSH
120664: CALL_OW 1
120668: ST_TO_ADDR
// attacking := true ;
120669: LD_ADDR_VAR 0 29
120673: PUSH
120674: LD_INT 1
120676: ST_TO_ADDR
// break ;
120677: GO 120681
// end ; end ;
120679: GO 120548
120681: POP
120682: POP
// if not attacking and f_attack_depot then
120683: LD_VAR 0 29
120687: NOT
120688: PUSH
120689: LD_VAR 0 25
120693: AND
120694: IFFALSE 120789
// begin z := UnitFilter ( tmp , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) ;
120696: LD_ADDR_VAR 0 13
120700: PUSH
120701: LD_VAR 0 14
120705: PPUSH
120706: LD_INT 2
120708: PUSH
120709: LD_INT 30
120711: PUSH
120712: LD_INT 0
120714: PUSH
120715: EMPTY
120716: LIST
120717: LIST
120718: PUSH
120719: LD_INT 30
120721: PUSH
120722: LD_INT 1
120724: PUSH
120725: EMPTY
120726: LIST
120727: LIST
120728: PUSH
120729: EMPTY
120730: LIST
120731: LIST
120732: LIST
120733: PPUSH
120734: CALL_OW 72
120738: ST_TO_ADDR
// if z then
120739: LD_VAR 0 13
120743: IFFALSE 120789
// begin ComAttackUnit ( group [ i ] , NearestUnitToUnit ( z , group [ i ] ) ) ;
120745: LD_VAR 0 4
120749: PUSH
120750: LD_VAR 0 7
120754: ARRAY
120755: PPUSH
120756: LD_VAR 0 13
120760: PPUSH
120761: LD_VAR 0 4
120765: PUSH
120766: LD_VAR 0 7
120770: ARRAY
120771: PPUSH
120772: CALL_OW 74
120776: PPUSH
120777: CALL_OW 115
// attacking := true ;
120781: LD_ADDR_VAR 0 29
120785: PUSH
120786: LD_INT 1
120788: ST_TO_ADDR
// end ; end ; if GetLives ( group [ i ] ) < 500 then
120789: LD_VAR 0 4
120793: PUSH
120794: LD_VAR 0 7
120798: ARRAY
120799: PPUSH
120800: CALL_OW 256
120804: PUSH
120805: LD_INT 500
120807: LESS
120808: IFFALSE 120834
// ComAttackUnit ( group [ i ] , tmp [ 1 ] ) ;
120810: LD_VAR 0 4
120814: PUSH
120815: LD_VAR 0 7
120819: ARRAY
120820: PPUSH
120821: LD_VAR 0 14
120825: PUSH
120826: LD_INT 1
120828: ARRAY
120829: PPUSH
120830: CALL_OW 115
// end ; if GetWeapon ( group [ i ] ) = ru_time_lapser then
120834: LD_VAR 0 4
120838: PUSH
120839: LD_VAR 0 7
120843: ARRAY
120844: PPUSH
120845: CALL_OW 264
120849: PUSH
120850: LD_INT 49
120852: EQUAL
120853: IFFALSE 120974
// begin if not HasTask ( group [ i ] ) then
120855: LD_VAR 0 4
120859: PUSH
120860: LD_VAR 0 7
120864: ARRAY
120865: PPUSH
120866: CALL_OW 314
120870: NOT
120871: IFFALSE 120974
// begin k := NearestUnitToUnit ( FilterAllUnits ( [ f_enemy , GetSide ( group [ i ] ) ] ) , group [ i ] ) ;
120873: LD_ADDR_VAR 0 9
120877: PUSH
120878: LD_INT 81
120880: PUSH
120881: LD_VAR 0 4
120885: PUSH
120886: LD_VAR 0 7
120890: ARRAY
120891: PPUSH
120892: CALL_OW 255
120896: PUSH
120897: EMPTY
120898: LIST
120899: LIST
120900: PPUSH
120901: CALL_OW 69
120905: PPUSH
120906: LD_VAR 0 4
120910: PUSH
120911: LD_VAR 0 7
120915: ARRAY
120916: PPUSH
120917: CALL_OW 74
120921: ST_TO_ADDR
// if k then
120922: LD_VAR 0 9
120926: IFFALSE 120974
// if GetDistUnits ( group [ i ] , k ) > 10 then
120928: LD_VAR 0 4
120932: PUSH
120933: LD_VAR 0 7
120937: ARRAY
120938: PPUSH
120939: LD_VAR 0 9
120943: PPUSH
120944: CALL_OW 296
120948: PUSH
120949: LD_INT 10
120951: GREATER
120952: IFFALSE 120974
// ComMoveUnit ( group [ i ] , k ) ;
120954: LD_VAR 0 4
120958: PUSH
120959: LD_VAR 0 7
120963: ARRAY
120964: PPUSH
120965: LD_VAR 0 9
120969: PPUSH
120970: CALL_OW 112
// end ; end ; if GetLives ( group [ i ] ) < 250 and group [ i ] in FilterAllUnits ( [ [ f_type , unit_vehicle ] , [ f_nation , 2 ] ] ) then
120974: LD_VAR 0 4
120978: PUSH
120979: LD_VAR 0 7
120983: ARRAY
120984: PPUSH
120985: CALL_OW 256
120989: PUSH
120990: LD_INT 250
120992: LESS
120993: PUSH
120994: LD_VAR 0 4
120998: PUSH
120999: LD_VAR 0 7
121003: ARRAY
121004: PUSH
121005: LD_INT 21
121007: PUSH
121008: LD_INT 2
121010: PUSH
121011: EMPTY
121012: LIST
121013: LIST
121014: PUSH
121015: LD_INT 23
121017: PUSH
121018: LD_INT 2
121020: PUSH
121021: EMPTY
121022: LIST
121023: LIST
121024: PUSH
121025: EMPTY
121026: LIST
121027: LIST
121028: PPUSH
121029: CALL_OW 69
121033: IN
121034: AND
121035: IFFALSE 121160
// begin k := NearestUnitToUnit ( all_units diff group [ i ] , group [ i ] ) ;
121037: LD_ADDR_VAR 0 9
121041: PUSH
121042: LD_OWVAR 3
121046: PUSH
121047: LD_VAR 0 4
121051: PUSH
121052: LD_VAR 0 7
121056: ARRAY
121057: DIFF
121058: PPUSH
121059: LD_VAR 0 4
121063: PUSH
121064: LD_VAR 0 7
121068: ARRAY
121069: PPUSH
121070: CALL_OW 74
121074: ST_TO_ADDR
// if not k then
121075: LD_VAR 0 9
121079: NOT
121080: IFFALSE 121084
// continue ;
121082: GO 117499
// if k in FilterAllUnits ( [ f_enemy , GetSide ( group [ i ] ) ] ) and GetDistUnits ( k , group [ i ] ) < 5 then
121084: LD_VAR 0 9
121088: PUSH
121089: LD_INT 81
121091: PUSH
121092: LD_VAR 0 4
121096: PUSH
121097: LD_VAR 0 7
121101: ARRAY
121102: PPUSH
121103: CALL_OW 255
121107: PUSH
121108: EMPTY
121109: LIST
121110: LIST
121111: PPUSH
121112: CALL_OW 69
121116: IN
121117: PUSH
121118: LD_VAR 0 9
121122: PPUSH
121123: LD_VAR 0 4
121127: PUSH
121128: LD_VAR 0 7
121132: ARRAY
121133: PPUSH
121134: CALL_OW 296
121138: PUSH
121139: LD_INT 5
121141: LESS
121142: AND
121143: IFFALSE 121160
// ComAutodestruct ( group [ i ] ) ;
121145: LD_VAR 0 4
121149: PUSH
121150: LD_VAR 0 7
121154: ARRAY
121155: PPUSH
121156: CALL 86681 0 1
// end ; if f_attack_depot then
121160: LD_VAR 0 25
121164: IFFALSE 121276
// begin k := 6 ;
121166: LD_ADDR_VAR 0 9
121170: PUSH
121171: LD_INT 6
121173: ST_TO_ADDR
// if tmp < k then
121174: LD_VAR 0 14
121178: PUSH
121179: LD_VAR 0 9
121183: LESS
121184: IFFALSE 121196
// k := tmp ;
121186: LD_ADDR_VAR 0 9
121190: PUSH
121191: LD_VAR 0 14
121195: ST_TO_ADDR
// for j = 1 to k do
121196: LD_ADDR_VAR 0 8
121200: PUSH
121201: DOUBLE
121202: LD_INT 1
121204: DEC
121205: ST_TO_ADDR
121206: LD_VAR 0 9
121210: PUSH
121211: FOR_TO
121212: IFFALSE 121274
// if GetBType ( j ) in [ b_depot , b_warehouse ] then
121214: LD_VAR 0 8
121218: PPUSH
121219: CALL_OW 266
121223: PUSH
121224: LD_INT 0
121226: PUSH
121227: LD_INT 1
121229: PUSH
121230: EMPTY
121231: LIST
121232: LIST
121233: IN
121234: IFFALSE 121272
// begin ComAttackUnit ( group [ i ] , tmp [ j ] ) ;
121236: LD_VAR 0 4
121240: PUSH
121241: LD_VAR 0 7
121245: ARRAY
121246: PPUSH
121247: LD_VAR 0 14
121251: PUSH
121252: LD_VAR 0 8
121256: ARRAY
121257: PPUSH
121258: CALL_OW 115
// attacking := true ;
121262: LD_ADDR_VAR 0 29
121266: PUSH
121267: LD_INT 1
121269: ST_TO_ADDR
// break ;
121270: GO 121274
// end ;
121272: GO 121211
121274: POP
121275: POP
// end ; if IsOk ( group [ i ] ) and not attacking then
121276: LD_VAR 0 4
121280: PUSH
121281: LD_VAR 0 7
121285: ARRAY
121286: PPUSH
121287: CALL_OW 302
121291: PUSH
121292: LD_VAR 0 29
121296: NOT
121297: AND
121298: IFFALSE 121620
// begin if GetTag ( group [ i ] ) = 71 then
121300: LD_VAR 0 4
121304: PUSH
121305: LD_VAR 0 7
121309: ARRAY
121310: PPUSH
121311: CALL_OW 110
121315: PUSH
121316: LD_INT 71
121318: EQUAL
121319: IFFALSE 121360
// begin if HasTask ( group [ i ] ) then
121321: LD_VAR 0 4
121325: PUSH
121326: LD_VAR 0 7
121330: ARRAY
121331: PPUSH
121332: CALL_OW 314
121336: IFFALSE 121342
// continue else
121338: GO 117499
121340: GO 121360
// SetTag ( group [ i ] , 0 ) ;
121342: LD_VAR 0 4
121346: PUSH
121347: LD_VAR 0 7
121351: ARRAY
121352: PPUSH
121353: LD_INT 0
121355: PPUSH
121356: CALL_OW 109
// end ; k := 8 ;
121360: LD_ADDR_VAR 0 9
121364: PUSH
121365: LD_INT 8
121367: ST_TO_ADDR
// x := 0 ;
121368: LD_ADDR_VAR 0 10
121372: PUSH
121373: LD_INT 0
121375: ST_TO_ADDR
// if tmp < k then
121376: LD_VAR 0 14
121380: PUSH
121381: LD_VAR 0 9
121385: LESS
121386: IFFALSE 121398
// k := tmp ;
121388: LD_ADDR_VAR 0 9
121392: PUSH
121393: LD_VAR 0 14
121397: ST_TO_ADDR
// for j = 1 to k do
121398: LD_ADDR_VAR 0 8
121402: PUSH
121403: DOUBLE
121404: LD_INT 1
121406: DEC
121407: ST_TO_ADDR
121408: LD_VAR 0 9
121412: PUSH
121413: FOR_TO
121414: IFFALSE 121512
// if GetType ( tmp [ j ] ) = unit_human and ( ( GetLives ( tmp [ j ] ) < 250 and f_murder ) or ( not f_murder and GetLives ( tmp [ j ] ) >= 250 ) ) then
121416: LD_VAR 0 14
121420: PUSH
121421: LD_VAR 0 8
121425: ARRAY
121426: PPUSH
121427: CALL_OW 247
121431: PUSH
121432: LD_INT 1
121434: EQUAL
121435: PUSH
121436: LD_VAR 0 14
121440: PUSH
121441: LD_VAR 0 8
121445: ARRAY
121446: PPUSH
121447: CALL_OW 256
121451: PUSH
121452: LD_INT 250
121454: LESS
121455: PUSH
121456: LD_VAR 0 20
121460: AND
121461: PUSH
121462: LD_VAR 0 20
121466: NOT
121467: PUSH
121468: LD_VAR 0 14
121472: PUSH
121473: LD_VAR 0 8
121477: ARRAY
121478: PPUSH
121479: CALL_OW 256
121483: PUSH
121484: LD_INT 250
121486: GREATEREQUAL
121487: AND
121488: OR
121489: AND
121490: IFFALSE 121510
// begin x := tmp [ j ] ;
121492: LD_ADDR_VAR 0 10
121496: PUSH
121497: LD_VAR 0 14
121501: PUSH
121502: LD_VAR 0 8
121506: ARRAY
121507: ST_TO_ADDR
// break ;
121508: GO 121512
// end ;
121510: GO 121413
121512: POP
121513: POP
// if x then
121514: LD_VAR 0 10
121518: IFFALSE 121542
// ComAttackUnit ( group [ i ] , x ) else
121520: LD_VAR 0 4
121524: PUSH
121525: LD_VAR 0 7
121529: ARRAY
121530: PPUSH
121531: LD_VAR 0 10
121535: PPUSH
121536: CALL_OW 115
121540: GO 121566
// ComAttackUnit ( group [ i ] , tmp [ 1 ] ) ;
121542: LD_VAR 0 4
121546: PUSH
121547: LD_VAR 0 7
121551: ARRAY
121552: PPUSH
121553: LD_VAR 0 14
121557: PUSH
121558: LD_INT 1
121560: ARRAY
121561: PPUSH
121562: CALL_OW 115
// if not HasTask ( group [ i ] ) then
121566: LD_VAR 0 4
121570: PUSH
121571: LD_VAR 0 7
121575: ARRAY
121576: PPUSH
121577: CALL_OW 314
121581: NOT
121582: IFFALSE 121620
// ComAttackUnit ( group [ i ] , NearestUnitToUnit ( tmp , group [ i ] ) ) ;
121584: LD_VAR 0 4
121588: PUSH
121589: LD_VAR 0 7
121593: ARRAY
121594: PPUSH
121595: LD_VAR 0 14
121599: PPUSH
121600: LD_VAR 0 4
121604: PUSH
121605: LD_VAR 0 7
121609: ARRAY
121610: PPUSH
121611: CALL_OW 74
121615: PPUSH
121616: CALL_OW 115
// end ; end ; end ;
121620: GO 117499
121622: POP
121623: POP
// wait ( 0 0$2 ) ;
121624: LD_INT 70
121626: PPUSH
121627: CALL_OW 67
// until not group or group = [ ] or not FilterAllUnits ( [ f_enemy , side ] ) ;
121631: LD_VAR 0 4
121635: NOT
121636: PUSH
121637: LD_VAR 0 4
121641: PUSH
121642: EMPTY
121643: EQUAL
121644: OR
121645: PUSH
121646: LD_INT 81
121648: PUSH
121649: LD_VAR 0 35
121653: PUSH
121654: EMPTY
121655: LIST
121656: LIST
121657: PPUSH
121658: CALL_OW 69
121662: NOT
121663: OR
121664: IFFALSE 117484
// end ;
121666: LD_VAR 0 2
121670: RET
// export function BasicDefend ( base , solds ) ; var enemy , e , side , i , hex ; begin
121671: LD_INT 0
121673: PPUSH
121674: PPUSH
121675: PPUSH
121676: PPUSH
121677: PPUSH
121678: PPUSH
// if not base or not mc_bases [ base ] or not solds then
121679: LD_VAR 0 1
121683: NOT
121684: PUSH
121685: LD_EXP 80
121689: PUSH
121690: LD_VAR 0 1
121694: ARRAY
121695: NOT
121696: OR
121697: PUSH
121698: LD_VAR 0 2
121702: NOT
121703: OR
121704: IFFALSE 121708
// exit ;
121706: GO 122262
// side := mc_sides [ base ] ;
121708: LD_ADDR_VAR 0 6
121712: PUSH
121713: LD_EXP 106
121717: PUSH
121718: LD_VAR 0 1
121722: ARRAY
121723: ST_TO_ADDR
// if not side then
121724: LD_VAR 0 6
121728: NOT
121729: IFFALSE 121733
// exit ;
121731: GO 122262
// for i in solds do
121733: LD_ADDR_VAR 0 7
121737: PUSH
121738: LD_VAR 0 2
121742: PUSH
121743: FOR_IN
121744: IFFALSE 121805
// if GetBType ( IsInUnit ( i ) ) in [ b_bunker , b_breastwork ] then
121746: LD_VAR 0 7
121750: PPUSH
121751: CALL_OW 310
121755: PPUSH
121756: CALL_OW 266
121760: PUSH
121761: LD_INT 32
121763: PUSH
121764: LD_INT 31
121766: PUSH
121767: EMPTY
121768: LIST
121769: LIST
121770: IN
121771: IFFALSE 121791
// solds := solds diff i else
121773: LD_ADDR_VAR 0 2
121777: PUSH
121778: LD_VAR 0 2
121782: PUSH
121783: LD_VAR 0 7
121787: DIFF
121788: ST_TO_ADDR
121789: GO 121803
// SetTag ( i , 18 ) ;
121791: LD_VAR 0 7
121795: PPUSH
121796: LD_INT 18
121798: PPUSH
121799: CALL_OW 109
121803: GO 121743
121805: POP
121806: POP
// if not solds then
121807: LD_VAR 0 2
121811: NOT
121812: IFFALSE 121816
// exit ;
121814: GO 122262
// repeat wait ( 0 0$2 ) ;
121816: LD_INT 70
121818: PPUSH
121819: CALL_OW 67
// enemy := mc_scan [ base ] ;
121823: LD_ADDR_VAR 0 4
121827: PUSH
121828: LD_EXP 103
121832: PUSH
121833: LD_VAR 0 1
121837: ARRAY
121838: ST_TO_ADDR
// if not mc_bases [ base ] or mc_bases [ base ] = [ ] then
121839: LD_EXP 80
121843: PUSH
121844: LD_VAR 0 1
121848: ARRAY
121849: NOT
121850: PUSH
121851: LD_EXP 80
121855: PUSH
121856: LD_VAR 0 1
121860: ARRAY
121861: PUSH
121862: EMPTY
121863: EQUAL
121864: OR
121865: IFFALSE 121902
// begin for i in solds do
121867: LD_ADDR_VAR 0 7
121871: PUSH
121872: LD_VAR 0 2
121876: PUSH
121877: FOR_IN
121878: IFFALSE 121891
// ComStop ( i ) ;
121880: LD_VAR 0 7
121884: PPUSH
121885: CALL_OW 141
121889: GO 121877
121891: POP
121892: POP
// solds := [ ] ;
121893: LD_ADDR_VAR 0 2
121897: PUSH
121898: EMPTY
121899: ST_TO_ADDR
// exit ;
121900: GO 122262
// end ; for i in solds do
121902: LD_ADDR_VAR 0 7
121906: PUSH
121907: LD_VAR 0 2
121911: PUSH
121912: FOR_IN
121913: IFFALSE 122234
// begin if IsInUnit ( i ) then
121915: LD_VAR 0 7
121919: PPUSH
121920: CALL_OW 310
121924: IFFALSE 121935
// ComExitBuilding ( i ) ;
121926: LD_VAR 0 7
121930: PPUSH
121931: CALL_OW 122
// if GetLives ( i ) > 500 then
121935: LD_VAR 0 7
121939: PPUSH
121940: CALL_OW 256
121944: PUSH
121945: LD_INT 500
121947: GREATER
121948: IFFALSE 122001
// begin e := NearestUnitToUnit ( enemy , i ) ;
121950: LD_ADDR_VAR 0 5
121954: PUSH
121955: LD_VAR 0 4
121959: PPUSH
121960: LD_VAR 0 7
121964: PPUSH
121965: CALL_OW 74
121969: ST_TO_ADDR
// ComAgressiveMove ( i , GetX ( e ) , GetY ( e ) ) ;
121970: LD_VAR 0 7
121974: PPUSH
121975: LD_VAR 0 5
121979: PPUSH
121980: CALL_OW 250
121984: PPUSH
121985: LD_VAR 0 5
121989: PPUSH
121990: CALL_OW 251
121994: PPUSH
121995: CALL_OW 114
// end else
121999: GO 122232
// if GetDistUnits ( i , NearestUnitToUnit ( UnitFilter ( mc_bases [ base ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] , [ f_btype , b_lab ] ] ) , i ) ) > 10 then
122001: LD_VAR 0 7
122005: PPUSH
122006: LD_EXP 80
122010: PUSH
122011: LD_VAR 0 1
122015: ARRAY
122016: PPUSH
122017: LD_INT 2
122019: PUSH
122020: LD_INT 30
122022: PUSH
122023: LD_INT 0
122025: PUSH
122026: EMPTY
122027: LIST
122028: LIST
122029: PUSH
122030: LD_INT 30
122032: PUSH
122033: LD_INT 1
122035: PUSH
122036: EMPTY
122037: LIST
122038: LIST
122039: PUSH
122040: LD_INT 30
122042: PUSH
122043: LD_INT 6
122045: PUSH
122046: EMPTY
122047: LIST
122048: LIST
122049: PUSH
122050: EMPTY
122051: LIST
122052: LIST
122053: LIST
122054: LIST
122055: PPUSH
122056: CALL_OW 72
122060: PPUSH
122061: LD_VAR 0 7
122065: PPUSH
122066: CALL_OW 74
122070: PPUSH
122071: CALL_OW 296
122075: PUSH
122076: LD_INT 10
122078: GREATER
122079: IFFALSE 122232
// begin hex := NearestUnitToUnit ( UnitFilter ( mc_bases [ base ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] , [ f_btype , b_lab ] ] ) , i ) ;
122081: LD_ADDR_VAR 0 8
122085: PUSH
122086: LD_EXP 80
122090: PUSH
122091: LD_VAR 0 1
122095: ARRAY
122096: PPUSH
122097: LD_INT 2
122099: PUSH
122100: LD_INT 30
122102: PUSH
122103: LD_INT 0
122105: PUSH
122106: EMPTY
122107: LIST
122108: LIST
122109: PUSH
122110: LD_INT 30
122112: PUSH
122113: LD_INT 1
122115: PUSH
122116: EMPTY
122117: LIST
122118: LIST
122119: PUSH
122120: LD_INT 30
122122: PUSH
122123: LD_INT 6
122125: PUSH
122126: EMPTY
122127: LIST
122128: LIST
122129: PUSH
122130: EMPTY
122131: LIST
122132: LIST
122133: LIST
122134: LIST
122135: PPUSH
122136: CALL_OW 72
122140: PPUSH
122141: LD_VAR 0 7
122145: PPUSH
122146: CALL_OW 74
122150: ST_TO_ADDR
// ComMoveXY ( i , ShiftX ( GetX ( hex ) , 3 , 5 ) , ShiftY ( GetY ( hex ) , 3 , 5 ) ) ;
122151: LD_VAR 0 7
122155: PPUSH
122156: LD_VAR 0 8
122160: PPUSH
122161: CALL_OW 250
122165: PPUSH
122166: LD_INT 3
122168: PPUSH
122169: LD_INT 5
122171: PPUSH
122172: CALL_OW 272
122176: PPUSH
122177: LD_VAR 0 8
122181: PPUSH
122182: CALL_OW 251
122186: PPUSH
122187: LD_INT 3
122189: PPUSH
122190: LD_INT 5
122192: PPUSH
122193: CALL_OW 273
122197: PPUSH
122198: CALL_OW 111
// SetTag ( i , 0 ) ;
122202: LD_VAR 0 7
122206: PPUSH
122207: LD_INT 0
122209: PPUSH
122210: CALL_OW 109
// solds := solds diff i ;
122214: LD_ADDR_VAR 0 2
122218: PUSH
122219: LD_VAR 0 2
122223: PUSH
122224: LD_VAR 0 7
122228: DIFF
122229: ST_TO_ADDR
// continue ;
122230: GO 121912
// end ; end ;
122232: GO 121912
122234: POP
122235: POP
// until not solds or not enemy ;
122236: LD_VAR 0 2
122240: NOT
122241: PUSH
122242: LD_VAR 0 4
122246: NOT
122247: OR
122248: IFFALSE 121816
// MC_Reset ( base , 18 ) ;
122250: LD_VAR 0 1
122254: PPUSH
122255: LD_INT 18
122257: PPUSH
122258: CALL 26939 0 2
// end ;
122262: LD_VAR 0 3
122266: RET
// export function Defend ( base , defenders ) ; var i , j , x , depot , solds , mech , un , tmp , mechs , e , fac , components , depot_under_attack , sold_defenders , b , can_defend , class , enemy ; begin
122267: LD_INT 0
122269: PPUSH
122270: PPUSH
122271: PPUSH
122272: PPUSH
122273: PPUSH
122274: PPUSH
122275: PPUSH
122276: PPUSH
122277: PPUSH
122278: PPUSH
122279: PPUSH
122280: PPUSH
122281: PPUSH
122282: PPUSH
122283: PPUSH
122284: PPUSH
122285: PPUSH
122286: PPUSH
122287: PPUSH
// mechs := UnitFilter ( mc_bases [ base ] , [ f_class , 3 ] ) ;
122288: LD_ADDR_VAR 0 12
122292: PUSH
122293: LD_EXP 80
122297: PUSH
122298: LD_VAR 0 1
122302: ARRAY
122303: PPUSH
122304: LD_INT 25
122306: PUSH
122307: LD_INT 3
122309: PUSH
122310: EMPTY
122311: LIST
122312: LIST
122313: PPUSH
122314: CALL_OW 72
122318: ST_TO_ADDR
// if mc_remote_driver [ base ] then
122319: LD_EXP 120
122323: PUSH
122324: LD_VAR 0 1
122328: ARRAY
122329: IFFALSE 122353
// mechs := mechs diff mc_remote_driver [ base ] ;
122331: LD_ADDR_VAR 0 12
122335: PUSH
122336: LD_VAR 0 12
122340: PUSH
122341: LD_EXP 120
122345: PUSH
122346: LD_VAR 0 1
122350: ARRAY
122351: DIFF
122352: ST_TO_ADDR
// for i in mechs do
122353: LD_ADDR_VAR 0 4
122357: PUSH
122358: LD_VAR 0 12
122362: PUSH
122363: FOR_IN
122364: IFFALSE 122399
// if GetTag ( i ) > 0 then
122366: LD_VAR 0 4
122370: PPUSH
122371: CALL_OW 110
122375: PUSH
122376: LD_INT 0
122378: GREATER
122379: IFFALSE 122397
// mechs := mechs diff i ;
122381: LD_ADDR_VAR 0 12
122385: PUSH
122386: LD_VAR 0 12
122390: PUSH
122391: LD_VAR 0 4
122395: DIFF
122396: ST_TO_ADDR
122397: GO 122363
122399: POP
122400: POP
// solds := UnitFilter ( mc_bases [ base ] , [ f_or , [ f_class , 1 ] , [ f_class , 5 ] , [ f_class , 8 ] , [ f_class , 9 ] ] ) ;
122401: LD_ADDR_VAR 0 8
122405: PUSH
122406: LD_EXP 80
122410: PUSH
122411: LD_VAR 0 1
122415: ARRAY
122416: PPUSH
122417: LD_INT 2
122419: PUSH
122420: LD_INT 25
122422: PUSH
122423: LD_INT 1
122425: PUSH
122426: EMPTY
122427: LIST
122428: LIST
122429: PUSH
122430: LD_INT 25
122432: PUSH
122433: LD_INT 5
122435: PUSH
122436: EMPTY
122437: LIST
122438: LIST
122439: PUSH
122440: LD_INT 25
122442: PUSH
122443: LD_INT 8
122445: PUSH
122446: EMPTY
122447: LIST
122448: LIST
122449: PUSH
122450: LD_INT 25
122452: PUSH
122453: LD_INT 9
122455: PUSH
122456: EMPTY
122457: LIST
122458: LIST
122459: PUSH
122460: EMPTY
122461: LIST
122462: LIST
122463: LIST
122464: LIST
122465: LIST
122466: PPUSH
122467: CALL_OW 72
122471: ST_TO_ADDR
// if not defenders and not solds then
122472: LD_VAR 0 2
122476: NOT
122477: PUSH
122478: LD_VAR 0 8
122482: NOT
122483: AND
122484: IFFALSE 122488
// exit ;
122486: GO 124258
// depot_under_attack := false ;
122488: LD_ADDR_VAR 0 16
122492: PUSH
122493: LD_INT 0
122495: ST_TO_ADDR
// sold_defenders := [ ] ;
122496: LD_ADDR_VAR 0 17
122500: PUSH
122501: EMPTY
122502: ST_TO_ADDR
// if mechs then
122503: LD_VAR 0 12
122507: IFFALSE 122660
// for i in UnitFilter ( defenders , [ f_type , unit_vehicle ] ) do
122509: LD_ADDR_VAR 0 4
122513: PUSH
122514: LD_VAR 0 2
122518: PPUSH
122519: LD_INT 21
122521: PUSH
122522: LD_INT 2
122524: PUSH
122525: EMPTY
122526: LIST
122527: LIST
122528: PPUSH
122529: CALL_OW 72
122533: PUSH
122534: FOR_IN
122535: IFFALSE 122658
// begin if GetTag ( i ) <> 20 then
122537: LD_VAR 0 4
122541: PPUSH
122542: CALL_OW 110
122546: PUSH
122547: LD_INT 20
122549: NONEQUAL
122550: IFFALSE 122564
// SetTag ( i , 20 ) ;
122552: LD_VAR 0 4
122556: PPUSH
122557: LD_INT 20
122559: PPUSH
122560: CALL_OW 109
// if GetControl ( i ) = control_manual and not IsDrivenBy ( i ) then
122564: LD_VAR 0 4
122568: PPUSH
122569: CALL_OW 263
122573: PUSH
122574: LD_INT 1
122576: EQUAL
122577: PUSH
122578: LD_VAR 0 4
122582: PPUSH
122583: CALL_OW 311
122587: NOT
122588: AND
122589: IFFALSE 122656
// begin un := mechs [ 1 ] ;
122591: LD_ADDR_VAR 0 10
122595: PUSH
122596: LD_VAR 0 12
122600: PUSH
122601: LD_INT 1
122603: ARRAY
122604: ST_TO_ADDR
// ComExit ( un ) ;
122605: LD_VAR 0 10
122609: PPUSH
122610: CALL 91567 0 1
// AddComEnterUnit ( un , i ) ;
122614: LD_VAR 0 10
122618: PPUSH
122619: LD_VAR 0 4
122623: PPUSH
122624: CALL_OW 180
// SetTag ( un , 19 ) ;
122628: LD_VAR 0 10
122632: PPUSH
122633: LD_INT 19
122635: PPUSH
122636: CALL_OW 109
// mechs := mechs diff un ;
122640: LD_ADDR_VAR 0 12
122644: PUSH
122645: LD_VAR 0 12
122649: PUSH
122650: LD_VAR 0 10
122654: DIFF
122655: ST_TO_ADDR
// end ; end ;
122656: GO 122534
122658: POP
122659: POP
// if solds then
122660: LD_VAR 0 8
122664: IFFALSE 122723
// for i in solds do
122666: LD_ADDR_VAR 0 4
122670: PUSH
122671: LD_VAR 0 8
122675: PUSH
122676: FOR_IN
122677: IFFALSE 122721
// if not GetTag ( i ) then
122679: LD_VAR 0 4
122683: PPUSH
122684: CALL_OW 110
122688: NOT
122689: IFFALSE 122719
// begin defenders := defenders union i ;
122691: LD_ADDR_VAR 0 2
122695: PUSH
122696: LD_VAR 0 2
122700: PUSH
122701: LD_VAR 0 4
122705: UNION
122706: ST_TO_ADDR
// SetTag ( i , 18 ) ;
122707: LD_VAR 0 4
122711: PPUSH
122712: LD_INT 18
122714: PPUSH
122715: CALL_OW 109
// end ;
122719: GO 122676
122721: POP
122722: POP
// repeat wait ( 0 0$2 ) ;
122723: LD_INT 70
122725: PPUSH
122726: CALL_OW 67
// enemy := mc_scan [ base ] ;
122730: LD_ADDR_VAR 0 21
122734: PUSH
122735: LD_EXP 103
122739: PUSH
122740: LD_VAR 0 1
122744: ARRAY
122745: ST_TO_ADDR
// if not mc_bases [ base ] or mc_bases [ base ] = [ ] then
122746: LD_EXP 80
122750: PUSH
122751: LD_VAR 0 1
122755: ARRAY
122756: NOT
122757: PUSH
122758: LD_EXP 80
122762: PUSH
122763: LD_VAR 0 1
122767: ARRAY
122768: PUSH
122769: EMPTY
122770: EQUAL
122771: OR
122772: IFFALSE 122809
// begin for i in defenders do
122774: LD_ADDR_VAR 0 4
122778: PUSH
122779: LD_VAR 0 2
122783: PUSH
122784: FOR_IN
122785: IFFALSE 122798
// ComStop ( i ) ;
122787: LD_VAR 0 4
122791: PPUSH
122792: CALL_OW 141
122796: GO 122784
122798: POP
122799: POP
// defenders := [ ] ;
122800: LD_ADDR_VAR 0 2
122804: PUSH
122805: EMPTY
122806: ST_TO_ADDR
// exit ;
122807: GO 124258
// end ; for i in defenders do
122809: LD_ADDR_VAR 0 4
122813: PUSH
122814: LD_VAR 0 2
122818: PUSH
122819: FOR_IN
122820: IFFALSE 123718
// begin e := NearestUnitToUnit ( enemy , i ) ;
122822: LD_ADDR_VAR 0 13
122826: PUSH
122827: LD_VAR 0 21
122831: PPUSH
122832: LD_VAR 0 4
122836: PPUSH
122837: CALL_OW 74
122841: ST_TO_ADDR
// depot := UnitFilter ( mc_bases [ base ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) ;
122842: LD_ADDR_VAR 0 7
122846: PUSH
122847: LD_EXP 80
122851: PUSH
122852: LD_VAR 0 1
122856: ARRAY
122857: PPUSH
122858: LD_INT 2
122860: PUSH
122861: LD_INT 30
122863: PUSH
122864: LD_INT 0
122866: PUSH
122867: EMPTY
122868: LIST
122869: LIST
122870: PUSH
122871: LD_INT 30
122873: PUSH
122874: LD_INT 1
122876: PUSH
122877: EMPTY
122878: LIST
122879: LIST
122880: PUSH
122881: EMPTY
122882: LIST
122883: LIST
122884: LIST
122885: PPUSH
122886: CALL_OW 72
122890: ST_TO_ADDR
// depot_under_attack := ( not depot or UnitFilter ( depot , [ f_not , [ f_lives , 600 ] ] ) ) ;
122891: LD_ADDR_VAR 0 16
122895: PUSH
122896: LD_VAR 0 7
122900: NOT
122901: PUSH
122902: LD_VAR 0 7
122906: PPUSH
122907: LD_INT 3
122909: PUSH
122910: LD_INT 24
122912: PUSH
122913: LD_INT 600
122915: PUSH
122916: EMPTY
122917: LIST
122918: LIST
122919: PUSH
122920: EMPTY
122921: LIST
122922: LIST
122923: PPUSH
122924: CALL_OW 72
122928: OR
122929: ST_TO_ADDR
// case GetType ( i ) of unit_vehicle :
122930: LD_VAR 0 4
122934: PPUSH
122935: CALL_OW 247
122939: PUSH
122940: LD_INT 2
122942: DOUBLE
122943: EQUAL
122944: IFTRUE 122948
122946: GO 123344
122948: POP
// begin if GetLives ( i ) = 1000 and ( GetDistUnits ( i , e ) < 40 or IsInArea ( e , mc_scan_area [ base ] ) ) then
122949: LD_VAR 0 4
122953: PPUSH
122954: CALL_OW 256
122958: PUSH
122959: LD_INT 1000
122961: EQUAL
122962: PUSH
122963: LD_VAR 0 4
122967: PPUSH
122968: LD_VAR 0 13
122972: PPUSH
122973: CALL_OW 296
122977: PUSH
122978: LD_INT 40
122980: LESS
122981: PUSH
122982: LD_VAR 0 13
122986: PPUSH
122987: LD_EXP 105
122991: PUSH
122992: LD_VAR 0 1
122996: ARRAY
122997: PPUSH
122998: CALL_OW 308
123002: OR
123003: AND
123004: IFFALSE 123126
// begin if GetEngine ( i ) = engine_combustion and GetFuel ( i ) < 30 and depot then
123006: LD_VAR 0 4
123010: PPUSH
123011: CALL_OW 262
123015: PUSH
123016: LD_INT 1
123018: EQUAL
123019: PUSH
123020: LD_VAR 0 4
123024: PPUSH
123025: CALL_OW 261
123029: PUSH
123030: LD_INT 30
123032: LESS
123033: AND
123034: PUSH
123035: LD_VAR 0 7
123039: AND
123040: IFFALSE 123110
// begin ComMoveUnit ( i , NearestUnitToUnit ( depot , i ) ) ;
123042: LD_VAR 0 4
123046: PPUSH
123047: LD_VAR 0 7
123051: PPUSH
123052: LD_VAR 0 4
123056: PPUSH
123057: CALL_OW 74
123061: PPUSH
123062: CALL_OW 112
// if GetDistUnits ( i , NearestUnitToUnit ( depot , i ) ) < 6 then
123066: LD_VAR 0 4
123070: PPUSH
123071: LD_VAR 0 7
123075: PPUSH
123076: LD_VAR 0 4
123080: PPUSH
123081: CALL_OW 74
123085: PPUSH
123086: CALL_OW 296
123090: PUSH
123091: LD_INT 6
123093: LESS
123094: IFFALSE 123108
// SetFuel ( i , 100 ) ;
123096: LD_VAR 0 4
123100: PPUSH
123101: LD_INT 100
123103: PPUSH
123104: CALL_OW 240
// end else
123108: GO 123124
// ComAttackUnit ( i , e ) ;
123110: LD_VAR 0 4
123114: PPUSH
123115: LD_VAR 0 13
123119: PPUSH
123120: CALL_OW 115
// end else
123124: GO 123227
// if ( ( not IsInArea ( e , mc_scan_area [ base ] ) and GetDistUnits ( i , e ) >= 40 ) or GetLives ( i ) <= 650 ) and not IsInArea ( i , mc_parking [ base ] ) then
123126: LD_VAR 0 13
123130: PPUSH
123131: LD_EXP 105
123135: PUSH
123136: LD_VAR 0 1
123140: ARRAY
123141: PPUSH
123142: CALL_OW 308
123146: NOT
123147: PUSH
123148: LD_VAR 0 4
123152: PPUSH
123153: LD_VAR 0 13
123157: PPUSH
123158: CALL_OW 296
123162: PUSH
123163: LD_INT 40
123165: GREATEREQUAL
123166: AND
123167: PUSH
123168: LD_VAR 0 4
123172: PPUSH
123173: CALL_OW 256
123177: PUSH
123178: LD_INT 650
123180: LESSEQUAL
123181: OR
123182: PUSH
123183: LD_VAR 0 4
123187: PPUSH
123188: LD_EXP 104
123192: PUSH
123193: LD_VAR 0 1
123197: ARRAY
123198: PPUSH
123199: CALL_OW 308
123203: NOT
123204: AND
123205: IFFALSE 123227
// ComMoveToArea ( i , mc_parking [ base ] ) ;
123207: LD_VAR 0 4
123211: PPUSH
123212: LD_EXP 104
123216: PUSH
123217: LD_VAR 0 1
123221: ARRAY
123222: PPUSH
123223: CALL_OW 113
// if GetLives ( i ) < 1000 and GetControl ( i ) = control_manual and IsDrivenBy ( i ) and IsInArea ( i , mc_parking [ base ] ) then
123227: LD_VAR 0 4
123231: PPUSH
123232: CALL_OW 256
123236: PUSH
123237: LD_INT 1000
123239: LESS
123240: PUSH
123241: LD_VAR 0 4
123245: PPUSH
123246: CALL_OW 263
123250: PUSH
123251: LD_INT 1
123253: EQUAL
123254: AND
123255: PUSH
123256: LD_VAR 0 4
123260: PPUSH
123261: CALL_OW 311
123265: AND
123266: PUSH
123267: LD_VAR 0 4
123271: PPUSH
123272: LD_EXP 104
123276: PUSH
123277: LD_VAR 0 1
123281: ARRAY
123282: PPUSH
123283: CALL_OW 308
123287: AND
123288: IFFALSE 123342
// begin mech := IsDrivenBy ( i ) ;
123290: LD_ADDR_VAR 0 9
123294: PUSH
123295: LD_VAR 0 4
123299: PPUSH
123300: CALL_OW 311
123304: ST_TO_ADDR
// ComExitVehicle ( mech ) ;
123305: LD_VAR 0 9
123309: PPUSH
123310: CALL_OW 121
// AddComRepairVehicle ( mech , i ) ;
123314: LD_VAR 0 9
123318: PPUSH
123319: LD_VAR 0 4
123323: PPUSH
123324: CALL_OW 189
// AddComEnterUnit ( mech , i ) ;
123328: LD_VAR 0 9
123332: PPUSH
123333: LD_VAR 0 4
123337: PPUSH
123338: CALL_OW 180
// end ; end ; unit_human :
123342: GO 123689
123344: LD_INT 1
123346: DOUBLE
123347: EQUAL
123348: IFTRUE 123352
123350: GO 123688
123352: POP
// begin b := IsInUnit ( i ) ;
123353: LD_ADDR_VAR 0 18
123357: PUSH
123358: LD_VAR 0 4
123362: PPUSH
123363: CALL_OW 310
123367: ST_TO_ADDR
// can_defend := ( not b or GetBType ( b ) in [ b_bunker , b_breastwork ] ) ;
123368: LD_ADDR_VAR 0 19
123372: PUSH
123373: LD_VAR 0 18
123377: NOT
123378: PUSH
123379: LD_VAR 0 18
123383: PPUSH
123384: CALL_OW 266
123388: PUSH
123389: LD_INT 32
123391: PUSH
123392: LD_INT 31
123394: PUSH
123395: EMPTY
123396: LIST
123397: LIST
123398: IN
123399: OR
123400: ST_TO_ADDR
// if GetBType ( b ) = b_barracks and GetClass ( i ) in [ 1 , 2 , 3 , 4 ] then
123401: LD_VAR 0 18
123405: PPUSH
123406: CALL_OW 266
123410: PUSH
123411: LD_INT 5
123413: EQUAL
123414: PUSH
123415: LD_VAR 0 4
123419: PPUSH
123420: CALL_OW 257
123424: PUSH
123425: LD_INT 1
123427: PUSH
123428: LD_INT 2
123430: PUSH
123431: LD_INT 3
123433: PUSH
123434: LD_INT 4
123436: PUSH
123437: EMPTY
123438: LIST
123439: LIST
123440: LIST
123441: LIST
123442: IN
123443: AND
123444: IFFALSE 123481
// begin class := AllowSpecClass ( i ) ;
123446: LD_ADDR_VAR 0 20
123450: PUSH
123451: LD_VAR 0 4
123455: PPUSH
123456: CALL 55264 0 1
123460: ST_TO_ADDR
// if class then
123461: LD_VAR 0 20
123465: IFFALSE 123481
// ComChangeProfession ( i , class ) ;
123467: LD_VAR 0 4
123471: PPUSH
123472: LD_VAR 0 20
123476: PPUSH
123477: CALL_OW 123
// end ; if ( depot_under_attack or UnitFilter ( defenders , [ f_type , unit_vehicle ] ) <= 1 ) and can_defend and not i in sold_defenders then
123481: LD_VAR 0 16
123485: PUSH
123486: LD_VAR 0 2
123490: PPUSH
123491: LD_INT 21
123493: PUSH
123494: LD_INT 2
123496: PUSH
123497: EMPTY
123498: LIST
123499: LIST
123500: PPUSH
123501: CALL_OW 72
123505: PUSH
123506: LD_INT 1
123508: LESSEQUAL
123509: OR
123510: PUSH
123511: LD_VAR 0 19
123515: AND
123516: PUSH
123517: LD_VAR 0 4
123521: PUSH
123522: LD_VAR 0 17
123526: IN
123527: NOT
123528: AND
123529: IFFALSE 123622
// begin if b then
123531: LD_VAR 0 18
123535: IFFALSE 123584
// if GetDistUnits ( b , NearestUnitToUnit ( enemy , b ) ) < 10 and BuildingStatus ( b ) <> bs_need_power then
123537: LD_VAR 0 18
123541: PPUSH
123542: LD_VAR 0 21
123546: PPUSH
123547: LD_VAR 0 18
123551: PPUSH
123552: CALL_OW 74
123556: PPUSH
123557: CALL_OW 296
123561: PUSH
123562: LD_INT 10
123564: LESS
123565: PUSH
123566: LD_VAR 0 18
123570: PPUSH
123571: CALL_OW 461
123575: PUSH
123576: LD_INT 7
123578: NONEQUAL
123579: AND
123580: IFFALSE 123584
// continue ;
123582: GO 122819
// sold_defenders := Replace ( sold_defenders , sold_defenders + 1 , i ) ;
123584: LD_ADDR_VAR 0 17
123588: PUSH
123589: LD_VAR 0 17
123593: PPUSH
123594: LD_VAR 0 17
123598: PUSH
123599: LD_INT 1
123601: PLUS
123602: PPUSH
123603: LD_VAR 0 4
123607: PPUSH
123608: CALL_OW 1
123612: ST_TO_ADDR
// ComExitBuilding ( i ) ;
123613: LD_VAR 0 4
123617: PPUSH
123618: CALL_OW 122
// end ; if sold_defenders then
123622: LD_VAR 0 17
123626: IFFALSE 123686
// if i in sold_defenders then
123628: LD_VAR 0 4
123632: PUSH
123633: LD_VAR 0 17
123637: IN
123638: IFFALSE 123686
// begin if not HasTask ( i ) and GetDistUnits ( i , e ) < 30 then
123640: LD_VAR 0 4
123644: PPUSH
123645: CALL_OW 314
123649: NOT
123650: PUSH
123651: LD_VAR 0 4
123655: PPUSH
123656: LD_VAR 0 13
123660: PPUSH
123661: CALL_OW 296
123665: PUSH
123666: LD_INT 30
123668: LESS
123669: AND
123670: IFFALSE 123686
// ComAttackUnit ( i , e ) ;
123672: LD_VAR 0 4
123676: PPUSH
123677: LD_VAR 0 13
123681: PPUSH
123682: CALL_OW 115
// end ; end ; end ;
123686: GO 123689
123688: POP
// if IsDead ( i ) then
123689: LD_VAR 0 4
123693: PPUSH
123694: CALL_OW 301
123698: IFFALSE 123716
// defenders := defenders diff i ;
123700: LD_ADDR_VAR 0 2
123704: PUSH
123705: LD_VAR 0 2
123709: PUSH
123710: LD_VAR 0 4
123714: DIFF
123715: ST_TO_ADDR
// end ;
123716: GO 122819
123718: POP
123719: POP
// until not enemy or not defenders or not mc_bases [ base ] ;
123720: LD_VAR 0 21
123724: NOT
123725: PUSH
123726: LD_VAR 0 2
123730: NOT
123731: OR
123732: PUSH
123733: LD_EXP 80
123737: PUSH
123738: LD_VAR 0 1
123742: ARRAY
123743: NOT
123744: OR
123745: IFFALSE 122723
// MC_Reset ( base , 18 ) ;
123747: LD_VAR 0 1
123751: PPUSH
123752: LD_INT 18
123754: PPUSH
123755: CALL 26939 0 2
// defenders := defenders diff UnitFilter ( defenders , [ f_or , [ f_class , 1 ] , [ f_class , 5 ] , [ f_class , 8 ] , [ f_class , 9 ] ] ) ;
123759: LD_ADDR_VAR 0 2
123763: PUSH
123764: LD_VAR 0 2
123768: PUSH
123769: LD_VAR 0 2
123773: PPUSH
123774: LD_INT 2
123776: PUSH
123777: LD_INT 25
123779: PUSH
123780: LD_INT 1
123782: PUSH
123783: EMPTY
123784: LIST
123785: LIST
123786: PUSH
123787: LD_INT 25
123789: PUSH
123790: LD_INT 5
123792: PUSH
123793: EMPTY
123794: LIST
123795: LIST
123796: PUSH
123797: LD_INT 25
123799: PUSH
123800: LD_INT 8
123802: PUSH
123803: EMPTY
123804: LIST
123805: LIST
123806: PUSH
123807: LD_INT 25
123809: PUSH
123810: LD_INT 9
123812: PUSH
123813: EMPTY
123814: LIST
123815: LIST
123816: PUSH
123817: EMPTY
123818: LIST
123819: LIST
123820: LIST
123821: LIST
123822: LIST
123823: PPUSH
123824: CALL_OW 72
123828: DIFF
123829: ST_TO_ADDR
// if not enemy and UnitFilter ( defenders , [ f_type , unit_vehicle ] ) then
123830: LD_VAR 0 21
123834: NOT
123835: PUSH
123836: LD_VAR 0 2
123840: PPUSH
123841: LD_INT 21
123843: PUSH
123844: LD_INT 2
123846: PUSH
123847: EMPTY
123848: LIST
123849: LIST
123850: PPUSH
123851: CALL_OW 72
123855: AND
123856: IFFALSE 124194
// begin tmp := FilterByTag ( defenders , 19 ) ;
123858: LD_ADDR_VAR 0 11
123862: PUSH
123863: LD_VAR 0 2
123867: PPUSH
123868: LD_INT 19
123870: PPUSH
123871: CALL 88738 0 2
123875: ST_TO_ADDR
// if tmp then
123876: LD_VAR 0 11
123880: IFFALSE 123950
// begin tmp := UnitFilter ( tmp , [ f_class , 3 ] ) ;
123882: LD_ADDR_VAR 0 11
123886: PUSH
123887: LD_VAR 0 11
123891: PPUSH
123892: LD_INT 25
123894: PUSH
123895: LD_INT 3
123897: PUSH
123898: EMPTY
123899: LIST
123900: LIST
123901: PPUSH
123902: CALL_OW 72
123906: ST_TO_ADDR
// if tmp then
123907: LD_VAR 0 11
123911: IFFALSE 123950
// mc_repair_vehicle := Replace ( mc_repair_vehicle , base , mc_repair_vehicle [ base ] union tmp ) ;
123913: LD_ADDR_EXP 92
123917: PUSH
123918: LD_EXP 92
123922: PPUSH
123923: LD_VAR 0 1
123927: PPUSH
123928: LD_EXP 92
123932: PUSH
123933: LD_VAR 0 1
123937: ARRAY
123938: PUSH
123939: LD_VAR 0 11
123943: UNION
123944: PPUSH
123945: CALL_OW 1
123949: ST_TO_ADDR
// end ; MC_Reset ( base , 19 ) ;
123950: LD_VAR 0 1
123954: PPUSH
123955: LD_INT 19
123957: PPUSH
123958: CALL 26939 0 2
// repeat wait ( 0 0$1 ) ;
123962: LD_INT 35
123964: PPUSH
123965: CALL_OW 67
// if not mc_bases [ base ] or mc_bases [ base ] = [ ] then
123969: LD_EXP 80
123973: PUSH
123974: LD_VAR 0 1
123978: ARRAY
123979: NOT
123980: PUSH
123981: LD_EXP 80
123985: PUSH
123986: LD_VAR 0 1
123990: ARRAY
123991: PUSH
123992: EMPTY
123993: EQUAL
123994: OR
123995: IFFALSE 124032
// begin for i in defenders do
123997: LD_ADDR_VAR 0 4
124001: PUSH
124002: LD_VAR 0 2
124006: PUSH
124007: FOR_IN
124008: IFFALSE 124021
// ComStop ( i ) ;
124010: LD_VAR 0 4
124014: PPUSH
124015: CALL_OW 141
124019: GO 124007
124021: POP
124022: POP
// defenders := [ ] ;
124023: LD_ADDR_VAR 0 2
124027: PUSH
124028: EMPTY
124029: ST_TO_ADDR
// exit ;
124030: GO 124258
// end ; for i in defenders do
124032: LD_ADDR_VAR 0 4
124036: PUSH
124037: LD_VAR 0 2
124041: PUSH
124042: FOR_IN
124043: IFFALSE 124132
// begin if not IsInArea ( i , mc_parking [ base ] ) then
124045: LD_VAR 0 4
124049: PPUSH
124050: LD_EXP 104
124054: PUSH
124055: LD_VAR 0 1
124059: ARRAY
124060: PPUSH
124061: CALL_OW 308
124065: NOT
124066: IFFALSE 124090
// ComMoveToArea ( i , mc_parking [ base ] ) else
124068: LD_VAR 0 4
124072: PPUSH
124073: LD_EXP 104
124077: PUSH
124078: LD_VAR 0 1
124082: ARRAY
124083: PPUSH
124084: CALL_OW 113
124088: GO 124130
// if GetControl ( i ) = control_manual then
124090: LD_VAR 0 4
124094: PPUSH
124095: CALL_OW 263
124099: PUSH
124100: LD_INT 1
124102: EQUAL
124103: IFFALSE 124130
// if IsDrivenBy ( i ) then
124105: LD_VAR 0 4
124109: PPUSH
124110: CALL_OW 311
124114: IFFALSE 124130
// ComExitVehicle ( IsDrivenBy ( i ) ) ;
124116: LD_VAR 0 4
124120: PPUSH
124121: CALL_OW 311
124125: PPUSH
124126: CALL_OW 121
// end ;
124130: GO 124042
124132: POP
124133: POP
// until UnitFilter ( defenders , [ f_inarea , mc_parking [ base ] ] ) = defenders or mc_scan [ base ] or not mc_bases [ base ] ;
124134: LD_VAR 0 2
124138: PPUSH
124139: LD_INT 95
124141: PUSH
124142: LD_EXP 104
124146: PUSH
124147: LD_VAR 0 1
124151: ARRAY
124152: PUSH
124153: EMPTY
124154: LIST
124155: LIST
124156: PPUSH
124157: CALL_OW 72
124161: PUSH
124162: LD_VAR 0 2
124166: EQUAL
124167: PUSH
124168: LD_EXP 103
124172: PUSH
124173: LD_VAR 0 1
124177: ARRAY
124178: OR
124179: PUSH
124180: LD_EXP 80
124184: PUSH
124185: LD_VAR 0 1
124189: ARRAY
124190: NOT
124191: OR
124192: IFFALSE 123962
// end ; mc_defender := Replace ( mc_defender , base , UnitFilter ( defenders , [ f_type , unit_vehicle ] ) ) ;
124194: LD_ADDR_EXP 102
124198: PUSH
124199: LD_EXP 102
124203: PPUSH
124204: LD_VAR 0 1
124208: PPUSH
124209: LD_VAR 0 2
124213: PPUSH
124214: LD_INT 21
124216: PUSH
124217: LD_INT 2
124219: PUSH
124220: EMPTY
124221: LIST
124222: LIST
124223: PPUSH
124224: CALL_OW 72
124228: PPUSH
124229: CALL_OW 1
124233: ST_TO_ADDR
// MC_Reset ( base , 19 ) ;
124234: LD_VAR 0 1
124238: PPUSH
124239: LD_INT 19
124241: PPUSH
124242: CALL 26939 0 2
// MC_Reset ( base , 20 ) ;
124246: LD_VAR 0 1
124250: PPUSH
124251: LD_INT 20
124253: PPUSH
124254: CALL 26939 0 2
// end ; end_of_file
124258: LD_VAR 0 3
124262: RET
// on TargetableSAIL ( cmd , unit , selectedUnit , x , y , p1 , p2 , p3 , p4 , p5 , p6 ) do begin case cmd of 200 .. 299 :
124263: LD_VAR 0 1
124267: PUSH
124268: LD_INT 200
124270: DOUBLE
124271: GREATEREQUAL
124272: IFFALSE 124280
124274: LD_INT 299
124276: DOUBLE
124277: LESSEQUAL
124278: IFTRUE 124282
124280: GO 124314
124282: POP
// SOS_TargetableSAIL ( cmd , unit , selectedUnit , x , y ) ; 300 .. 399 :
124283: LD_VAR 0 1
124287: PPUSH
124288: LD_VAR 0 2
124292: PPUSH
124293: LD_VAR 0 3
124297: PPUSH
124298: LD_VAR 0 4
124302: PPUSH
124303: LD_VAR 0 5
124307: PPUSH
124308: CALL 112444 0 5
124312: GO 124391
124314: LD_INT 300
124316: DOUBLE
124317: GREATEREQUAL
124318: IFFALSE 124326
124320: LD_INT 399
124322: DOUBLE
124323: LESSEQUAL
124324: IFTRUE 124328
124326: GO 124390
124328: POP
// SOS_TargetableHack ( cmd , unit , selectedUnit , x , y , p1 , p2 , p3 , p4 , p5 , p6 ) ; end ;
124329: LD_VAR 0 1
124333: PPUSH
124334: LD_VAR 0 2
124338: PPUSH
124339: LD_VAR 0 3
124343: PPUSH
124344: LD_VAR 0 4
124348: PPUSH
124349: LD_VAR 0 5
124353: PPUSH
124354: LD_VAR 0 6
124358: PPUSH
124359: LD_VAR 0 7
124363: PPUSH
124364: LD_VAR 0 8
124368: PPUSH
124369: LD_VAR 0 9
124373: PPUSH
124374: LD_VAR 0 10
124378: PPUSH
124379: LD_VAR 0 11
124383: PPUSH
124384: CALL 108769 0 11
124388: GO 124391
124390: POP
// end ;
124391: PPOPN 11
124393: END
// on CommandUnitXY ( cmd , un , target , x , y ) do begin SOS_CommandUnitXY ( cmd , un , target , x , y ) ;
124394: LD_VAR 0 1
124398: PPUSH
124399: LD_VAR 0 2
124403: PPUSH
124404: LD_VAR 0 3
124408: PPUSH
124409: LD_VAR 0 4
124413: PPUSH
124414: LD_VAR 0 5
124418: PPUSH
124419: CALL 112180 0 5
// end ; end_of_file
124423: PPOPN 5
124425: END
// on CustomCommand ( p1 , p2 , p3 , p4 , p5 , p6 ) do begin SOS_CustomCommand ( p1 , p2 , p3 , p4 , p5 , p6 ) ;
124426: LD_VAR 0 1
124430: PPUSH
124431: LD_VAR 0 2
124435: PPUSH
124436: LD_VAR 0 3
124440: PPUSH
124441: LD_VAR 0 4
124445: PPUSH
124446: LD_VAR 0 5
124450: PPUSH
124451: LD_VAR 0 6
124455: PPUSH
124456: CALL 96421 0 6
// end ;
124460: PPOPN 6
124462: END
// on CommPanelCommand ( units , p1 , p2 , p3 , p4 , p5 ) do var i ;
124463: LD_INT 0
124465: PPUSH
// begin if not units then
124466: LD_VAR 0 1
124470: NOT
124471: IFFALSE 124475
// exit ;
124473: GO 124475
// end ;
124475: PPOPN 7
124477: END
// on MapStart ( p ) do begin SOS_MapStart ( ) ;
124478: CALL 96308 0 0
// end ;
124482: PPOPN 1
124484: END
