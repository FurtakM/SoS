// starting begin ResetFog ;
   0: CALL_OW 335
// AnimateTrees ( true ) ;
   4: LD_INT 1
   6: PPUSH
   7: CALL_OW 573
// InitVariables ;
  11: CALL 69 0 0
// InitMacro ;
  15: CALL 20507 0 0
// InitNature ;
  19: CALL 17133 0 0
// InitArtifact ;
  23: CALL 17746 0 0
// if debug then
  27: LD_EXP 1
  31: IFFALSE 40
// FogOff ( 1 ) ;
  33: LD_INT 1
  35: PPUSH
  36: CALL_OW 344
// PrepareAmerican ;
  40: CALL 4579 0 0
// PrepareAlliance ;
  44: CALL 1375 0 0
// PrepareArabian ;
  48: CALL 6347 0 0
// PrepareRussian ;
  52: CALL 8332 0 0
// PrepareLegion ;
  56: CALL 6775 0 0
// Action ;
  60: CALL 10885 0 0
// MC_Start ( ) ;
  64: CALL 22619 0 0
// end ;
  68: END
// export debug ; export russianDestroyed , legionDestroyed , americanDestroyed , arabianDestroyed ; export americanCapitulated , russianCapitulated , legionCapitulated ; export artifactArCaptured , alienSpotted , spawnOmar ; export artifactIResearched , artifactIIResearched , artifactIIIResearched ; export vehicleLostCounter , artifactDestroyCounter ; export function InitVariables ; begin
  69: LD_INT 0
  71: PPUSH
// debug := false ;
  72: LD_ADDR_EXP 1
  76: PUSH
  77: LD_INT 0
  79: ST_TO_ADDR
// artifactArCaptured := LoadVariable ( 11_artifact_captured , 0 ) ;
  80: LD_ADDR_EXP 9
  84: PUSH
  85: LD_STRING 11_artifact_captured
  87: PPUSH
  88: LD_INT 0
  90: PPUSH
  91: CALL_OW 30
  95: ST_TO_ADDR
// russianDestroyed := false ;
  96: LD_ADDR_EXP 2
 100: PUSH
 101: LD_INT 0
 103: ST_TO_ADDR
// legionDestroyed := false ;
 104: LD_ADDR_EXP 3
 108: PUSH
 109: LD_INT 0
 111: ST_TO_ADDR
// americanDestroyed := false ;
 112: LD_ADDR_EXP 4
 116: PUSH
 117: LD_INT 0
 119: ST_TO_ADDR
// arabianDestroyed := false ;
 120: LD_ADDR_EXP 5
 124: PUSH
 125: LD_INT 0
 127: ST_TO_ADDR
// americanCapitulated := false ;
 128: LD_ADDR_EXP 6
 132: PUSH
 133: LD_INT 0
 135: ST_TO_ADDR
// russianCapitulated := false ;
 136: LD_ADDR_EXP 7
 140: PUSH
 141: LD_INT 0
 143: ST_TO_ADDR
// legionCapitulated := false ;
 144: LD_ADDR_EXP 8
 148: PUSH
 149: LD_INT 0
 151: ST_TO_ADDR
// artifactIResearched := false ;
 152: LD_ADDR_EXP 12
 156: PUSH
 157: LD_INT 0
 159: ST_TO_ADDR
// artifactIIResearched := false ;
 160: LD_ADDR_EXP 13
 164: PUSH
 165: LD_INT 0
 167: ST_TO_ADDR
// artifactIIIResearched := false ;
 168: LD_ADDR_EXP 14
 172: PUSH
 173: LD_INT 0
 175: ST_TO_ADDR
// alienSpotted := false ;
 176: LD_ADDR_EXP 10
 180: PUSH
 181: LD_INT 0
 183: ST_TO_ADDR
// spawnOmar := false ;
 184: LD_ADDR_EXP 11
 188: PUSH
 189: LD_INT 0
 191: ST_TO_ADDR
// vehicleLostCounter := 0 ;
 192: LD_ADDR_EXP 15
 196: PUSH
 197: LD_INT 0
 199: ST_TO_ADDR
// artifactDestroyCounter := 0 ;
 200: LD_ADDR_EXP 16
 204: PUSH
 205: LD_INT 0
 207: ST_TO_ADDR
// end ;
 208: LD_VAR 0 1
 212: RET
// export function CustomInitMacro ( ) ; begin
 213: LD_INT 0
 215: PPUSH
// mc_parking := [ arabianParkingArea , russianParkingArea , legionParkingArea , powellParking ] ;
 216: LD_ADDR_EXP 103
 220: PUSH
 221: LD_INT 26
 223: PUSH
 224: LD_INT 1
 226: PUSH
 227: LD_INT 4
 229: PUSH
 230: LD_INT 8
 232: PUSH
 233: EMPTY
 234: LIST
 235: LIST
 236: LIST
 237: LIST
 238: ST_TO_ADDR
// mc_scan_area := [ arabianBaseArea , russianBaseArea , legionBaseArea , powellBase ] ;
 239: LD_ADDR_EXP 104
 243: PUSH
 244: LD_INT 27
 246: PUSH
 247: LD_INT 2
 249: PUSH
 250: LD_INT 3
 252: PUSH
 253: LD_INT 7
 255: PUSH
 256: EMPTY
 257: LIST
 258: LIST
 259: LIST
 260: LIST
 261: ST_TO_ADDR
// MC_SetMinesField ( 1 , [ 6 , 7 , 9 ] [ Difficulty ] , arabianMinefield ) ;
 262: LD_INT 1
 264: PPUSH
 265: LD_INT 6
 267: PUSH
 268: LD_INT 7
 270: PUSH
 271: LD_INT 9
 273: PUSH
 274: EMPTY
 275: LIST
 276: LIST
 277: LIST
 278: PUSH
 279: LD_OWVAR 67
 283: ARRAY
 284: PPUSH
 285: LD_INT 28
 287: PPUSH
 288: CALL 43836 0 3
// MC_SetLabKind ( 1 , [ b_lab_weapon , b_lab_siberium , b_lab_biological , b_lab_opto ] ) ;
 292: LD_INT 1
 294: PPUSH
 295: LD_INT 10
 297: PUSH
 298: LD_INT 11
 300: PUSH
 301: LD_INT 13
 303: PUSH
 304: LD_INT 15
 306: PUSH
 307: EMPTY
 308: LIST
 309: LIST
 310: LIST
 311: LIST
 312: PPUSH
 313: CALL 44896 0 2
// MC_SetCratesArea ( 1 , [ arabianCratesArea ] ) ;
 317: LD_INT 1
 319: PPUSH
 320: LD_INT 29
 322: PUSH
 323: EMPTY
 324: LIST
 325: PPUSH
 326: CALL 44989 0 2
// mc_ape := Replace ( mc_ape , 1 , FilterAllUnits ( [ [ f_side , 2 ] , [ f_class , class_apeman_soldier ] ] ) ) ;
 330: LD_ADDR_EXP 108
 334: PUSH
 335: LD_EXP 108
 339: PPUSH
 340: LD_INT 1
 342: PPUSH
 343: LD_INT 22
 345: PUSH
 346: LD_INT 2
 348: PUSH
 349: EMPTY
 350: LIST
 351: LIST
 352: PUSH
 353: LD_INT 25
 355: PUSH
 356: LD_INT 15
 358: PUSH
 359: EMPTY
 360: LIST
 361: LIST
 362: PUSH
 363: EMPTY
 364: LIST
 365: LIST
 366: PPUSH
 367: CALL_OW 69
 371: PPUSH
 372: CALL_OW 1
 376: ST_TO_ADDR
// MC_SetProduceList ( 1 , [ [ ar_medium_trike , engine_solar , control_manual , ar_control_tower ] , [ ar_medium_trike , engine_solar , control_manual , ar_control_tower ] , [ ar_medium_trike , engine_combustion , control_manual , ar_rocket_launcher ] , [ ar_medium_trike , engine_combustion , control_manual , ar_rocket_launcher ] , [ ar_medium_trike , engine_combustion , control_manual , ar_rocket_launcher ] , [ ar_medium_trike , engine_combustion , control_manual , ar_rocket_launcher ] ] ) ;
 377: LD_INT 1
 379: PPUSH
 380: LD_INT 13
 382: PUSH
 383: LD_INT 2
 385: PUSH
 386: LD_INT 1
 388: PUSH
 389: LD_INT 31
 391: PUSH
 392: EMPTY
 393: LIST
 394: LIST
 395: LIST
 396: LIST
 397: PUSH
 398: LD_INT 13
 400: PUSH
 401: LD_INT 2
 403: PUSH
 404: LD_INT 1
 406: PUSH
 407: LD_INT 31
 409: PUSH
 410: EMPTY
 411: LIST
 412: LIST
 413: LIST
 414: LIST
 415: PUSH
 416: LD_INT 13
 418: PUSH
 419: LD_INT 1
 421: PUSH
 422: LD_INT 1
 424: PUSH
 425: LD_INT 28
 427: PUSH
 428: EMPTY
 429: LIST
 430: LIST
 431: LIST
 432: LIST
 433: PUSH
 434: LD_INT 13
 436: PUSH
 437: LD_INT 1
 439: PUSH
 440: LD_INT 1
 442: PUSH
 443: LD_INT 28
 445: PUSH
 446: EMPTY
 447: LIST
 448: LIST
 449: LIST
 450: LIST
 451: PUSH
 452: LD_INT 13
 454: PUSH
 455: LD_INT 1
 457: PUSH
 458: LD_INT 1
 460: PUSH
 461: LD_INT 28
 463: PUSH
 464: EMPTY
 465: LIST
 466: LIST
 467: LIST
 468: LIST
 469: PUSH
 470: LD_INT 13
 472: PUSH
 473: LD_INT 1
 475: PUSH
 476: LD_INT 1
 478: PUSH
 479: LD_INT 28
 481: PUSH
 482: EMPTY
 483: LIST
 484: LIST
 485: LIST
 486: LIST
 487: PUSH
 488: EMPTY
 489: LIST
 490: LIST
 491: LIST
 492: LIST
 493: LIST
 494: LIST
 495: PPUSH
 496: CALL 44154 0 2
// MC_SetDefenderLimit ( 1 , 4 ) ;
 500: LD_INT 1
 502: PPUSH
 503: LD_INT 4
 505: PPUSH
 506: CALL 44339 0 2
// MC_SetLabKind ( 2 , [ b_lab_weapon , b_lab_siberium , b_lab_computer , b_lab_spacetime ] ) ;
 510: LD_INT 2
 512: PPUSH
 513: LD_INT 10
 515: PUSH
 516: LD_INT 11
 518: PUSH
 519: LD_INT 12
 521: PUSH
 522: LD_INT 14
 524: PUSH
 525: EMPTY
 526: LIST
 527: LIST
 528: LIST
 529: LIST
 530: PPUSH
 531: CALL 44896 0 2
// MC_SetCratesArea ( 2 , [ russianCratesArea ] ) ;
 535: LD_INT 2
 537: PPUSH
 538: LD_INT 14
 540: PUSH
 541: EMPTY
 542: LIST
 543: PPUSH
 544: CALL 44989 0 2
// MC_SetProduceList ( 2 , [ [ ru_medium_wheeled , engine_siberite , control_computer , ru_cargo_bay ] , [ ru_medium_tracked , engine_siberite , control_computer , ru_crane ] , [ ru_medium_tracked , engine_siberite , control_computer , ru_crane ] , [ ru_heavy_tracked , engine_siberite , control_computer , ru_rocket ] , [ ru_heavy_tracked , engine_siberite , control_computer , ru_rocket ] , [ ru_heavy_tracked , engine_siberite , control_computer , ru_rocket ] , [ ru_heavy_tracked , engine_siberite , control_computer , ru_rocket ] , [ ru_heavy_tracked , engine_siberite , control_computer , ru_rocket ] ] ) ;
 548: LD_INT 2
 550: PPUSH
 551: LD_INT 21
 553: PUSH
 554: LD_INT 3
 556: PUSH
 557: LD_INT 3
 559: PUSH
 560: LD_INT 51
 562: PUSH
 563: EMPTY
 564: LIST
 565: LIST
 566: LIST
 567: LIST
 568: PUSH
 569: LD_INT 22
 571: PUSH
 572: LD_INT 3
 574: PUSH
 575: LD_INT 3
 577: PUSH
 578: LD_INT 52
 580: PUSH
 581: EMPTY
 582: LIST
 583: LIST
 584: LIST
 585: LIST
 586: PUSH
 587: LD_INT 22
 589: PUSH
 590: LD_INT 3
 592: PUSH
 593: LD_INT 3
 595: PUSH
 596: LD_INT 52
 598: PUSH
 599: EMPTY
 600: LIST
 601: LIST
 602: LIST
 603: LIST
 604: PUSH
 605: LD_INT 24
 607: PUSH
 608: LD_INT 3
 610: PUSH
 611: LD_INT 3
 613: PUSH
 614: LD_INT 47
 616: PUSH
 617: EMPTY
 618: LIST
 619: LIST
 620: LIST
 621: LIST
 622: PUSH
 623: LD_INT 24
 625: PUSH
 626: LD_INT 3
 628: PUSH
 629: LD_INT 3
 631: PUSH
 632: LD_INT 47
 634: PUSH
 635: EMPTY
 636: LIST
 637: LIST
 638: LIST
 639: LIST
 640: PUSH
 641: LD_INT 24
 643: PUSH
 644: LD_INT 3
 646: PUSH
 647: LD_INT 3
 649: PUSH
 650: LD_INT 47
 652: PUSH
 653: EMPTY
 654: LIST
 655: LIST
 656: LIST
 657: LIST
 658: PUSH
 659: LD_INT 24
 661: PUSH
 662: LD_INT 3
 664: PUSH
 665: LD_INT 3
 667: PUSH
 668: LD_INT 47
 670: PUSH
 671: EMPTY
 672: LIST
 673: LIST
 674: LIST
 675: LIST
 676: PUSH
 677: LD_INT 24
 679: PUSH
 680: LD_INT 3
 682: PUSH
 683: LD_INT 3
 685: PUSH
 686: LD_INT 47
 688: PUSH
 689: EMPTY
 690: LIST
 691: LIST
 692: LIST
 693: LIST
 694: PUSH
 695: EMPTY
 696: LIST
 697: LIST
 698: LIST
 699: LIST
 700: LIST
 701: LIST
 702: LIST
 703: LIST
 704: PPUSH
 705: CALL 44154 0 2
// MC_SetDefenderLimit ( 2 , 5 ) ;
 709: LD_INT 2
 711: PPUSH
 712: LD_INT 5
 714: PPUSH
 715: CALL 44339 0 2
// MC_SetUpgradeBuilding ( 2 , b_depot ) ;
 719: LD_INT 2
 721: PPUSH
 722: LD_INT 0
 724: PPUSH
 725: CALL 44769 0 2
// MC_SetMinesField ( 3 , [ 10 , 12 , 15 ] [ Difficulty ] , legionMinefield ) ;
 729: LD_INT 3
 731: PPUSH
 732: LD_INT 10
 734: PUSH
 735: LD_INT 12
 737: PUSH
 738: LD_INT 15
 740: PUSH
 741: EMPTY
 742: LIST
 743: LIST
 744: LIST
 745: PUSH
 746: LD_OWVAR 67
 750: ARRAY
 751: PPUSH
 752: LD_INT 24
 754: PPUSH
 755: CALL 43836 0 3
// MC_SetLabKind ( 3 , [ b_lab_weapon , b_lab_siberium , b_lab_biological , b_lab_opto ] ) ;
 759: LD_INT 3
 761: PPUSH
 762: LD_INT 10
 764: PUSH
 765: LD_INT 11
 767: PUSH
 768: LD_INT 13
 770: PUSH
 771: LD_INT 15
 773: PUSH
 774: EMPTY
 775: LIST
 776: LIST
 777: LIST
 778: LIST
 779: PPUSH
 780: CALL 44896 0 2
// MC_SetCratesArea ( 3 , [ legionCratesArea ] ) ;
 784: LD_INT 3
 786: PPUSH
 787: LD_INT 13
 789: PUSH
 790: EMPTY
 791: LIST
 792: PPUSH
 793: CALL 44989 0 2
// mc_ape := Replace ( mc_ape , 3 , FilterAllUnits ( [ [ f_side , 8 ] , [ f_class , class_apeman_soldier ] ] ) ) ;
 797: LD_ADDR_EXP 108
 801: PUSH
 802: LD_EXP 108
 806: PPUSH
 807: LD_INT 3
 809: PPUSH
 810: LD_INT 22
 812: PUSH
 813: LD_INT 8
 815: PUSH
 816: EMPTY
 817: LIST
 818: LIST
 819: PUSH
 820: LD_INT 25
 822: PUSH
 823: LD_INT 15
 825: PUSH
 826: EMPTY
 827: LIST
 828: LIST
 829: PUSH
 830: EMPTY
 831: LIST
 832: LIST
 833: PPUSH
 834: CALL_OW 69
 838: PPUSH
 839: CALL_OW 1
 843: ST_TO_ADDR
// MC_SetProduceList ( 3 , [ [ ar_medium_trike , engine_solar , control_manual , ar_control_tower ] , [ ar_medium_trike , engine_solar , control_manual , ar_control_tower ] , [ ar_medium_trike , engine_siberite , control_remote , ar_cargo_bay ] , [ ar_half_tracked , engine_combustion , control_manual , ar_rocket_launcher ] , [ ar_half_tracked , engine_combustion , control_manual , ar_rocket_launcher ] , [ ar_half_tracked , engine_combustion , control_manual , ar_rocket_launcher ] , [ ar_half_tracked , engine_combustion , control_manual , ar_rocket_launcher ] ] ) ;
 844: LD_INT 3
 846: PPUSH
 847: LD_INT 13
 849: PUSH
 850: LD_INT 2
 852: PUSH
 853: LD_INT 1
 855: PUSH
 856: LD_INT 31
 858: PUSH
 859: EMPTY
 860: LIST
 861: LIST
 862: LIST
 863: LIST
 864: PUSH
 865: LD_INT 13
 867: PUSH
 868: LD_INT 2
 870: PUSH
 871: LD_INT 1
 873: PUSH
 874: LD_INT 31
 876: PUSH
 877: EMPTY
 878: LIST
 879: LIST
 880: LIST
 881: LIST
 882: PUSH
 883: LD_INT 13
 885: PUSH
 886: LD_INT 3
 888: PUSH
 889: LD_INT 2
 891: PUSH
 892: LD_INT 32
 894: PUSH
 895: EMPTY
 896: LIST
 897: LIST
 898: LIST
 899: LIST
 900: PUSH
 901: LD_INT 14
 903: PUSH
 904: LD_INT 1
 906: PUSH
 907: LD_INT 1
 909: PUSH
 910: LD_INT 28
 912: PUSH
 913: EMPTY
 914: LIST
 915: LIST
 916: LIST
 917: LIST
 918: PUSH
 919: LD_INT 14
 921: PUSH
 922: LD_INT 1
 924: PUSH
 925: LD_INT 1
 927: PUSH
 928: LD_INT 28
 930: PUSH
 931: EMPTY
 932: LIST
 933: LIST
 934: LIST
 935: LIST
 936: PUSH
 937: LD_INT 14
 939: PUSH
 940: LD_INT 1
 942: PUSH
 943: LD_INT 1
 945: PUSH
 946: LD_INT 28
 948: PUSH
 949: EMPTY
 950: LIST
 951: LIST
 952: LIST
 953: LIST
 954: PUSH
 955: LD_INT 14
 957: PUSH
 958: LD_INT 1
 960: PUSH
 961: LD_INT 1
 963: PUSH
 964: LD_INT 28
 966: PUSH
 967: EMPTY
 968: LIST
 969: LIST
 970: LIST
 971: LIST
 972: PUSH
 973: EMPTY
 974: LIST
 975: LIST
 976: LIST
 977: LIST
 978: LIST
 979: LIST
 980: LIST
 981: PPUSH
 982: CALL 44154 0 2
// MC_SetDefenderLimit ( 3 , 4 ) ;
 986: LD_INT 3
 988: PPUSH
 989: LD_INT 4
 991: PPUSH
 992: CALL 44339 0 2
// MC_SetLabKind ( 4 , [ b_lab_weapon , b_lab_computer , b_lab_siberium , b_lab_opto ] ) ;
 996: LD_INT 4
 998: PPUSH
 999: LD_INT 10
1001: PUSH
1002: LD_INT 12
1004: PUSH
1005: LD_INT 11
1007: PUSH
1008: LD_INT 15
1010: PUSH
1011: EMPTY
1012: LIST
1013: LIST
1014: LIST
1015: LIST
1016: PPUSH
1017: CALL 44896 0 2
// MC_SetCratesArea ( 4 , [ americanCratesArea ] ) ;
1021: LD_INT 4
1023: PPUSH
1024: LD_INT 33
1026: PUSH
1027: EMPTY
1028: LIST
1029: PPUSH
1030: CALL 44989 0 2
// MC_SetAllowedTurretWeapons ( 4 , [ us_double_gun , us_heavy_gun , us_rocket_launcher , us_laser , us_double_laser ] ) ;
1034: LD_INT 4
1036: PPUSH
1037: LD_INT 5
1039: PUSH
1040: LD_INT 6
1042: PUSH
1043: LD_INT 7
1045: PUSH
1046: LD_INT 9
1048: PUSH
1049: LD_INT 10
1051: PUSH
1052: EMPTY
1053: LIST
1054: LIST
1055: LIST
1056: LIST
1057: LIST
1058: PPUSH
1059: CALL 45307 0 2
// MC_SetFactoryExtension ( 4 , 54 , 85 , 2 , [ b_ext_laser , b_ext_track , b_ext_gun , b_ext_rocket , b_ext_radio ] ) ;
1063: LD_INT 4
1065: PPUSH
1066: LD_INT 54
1068: PPUSH
1069: LD_INT 85
1071: PPUSH
1072: LD_INT 2
1074: PPUSH
1075: LD_INT 25
1077: PUSH
1078: LD_INT 16
1080: PUSH
1081: LD_INT 17
1083: PUSH
1084: LD_INT 18
1086: PUSH
1087: LD_INT 22
1089: PUSH
1090: EMPTY
1091: LIST
1092: LIST
1093: LIST
1094: LIST
1095: LIST
1096: PPUSH
1097: CALL 45101 0 5
// MC_SetProduceList ( 4 , [ [ us_morphling , engine_combustion , control_manual , us_rocket_launcher ] , [ us_morphling , engine_combustion , control_manual , us_heavy_gun ] , [ us_morphling , engine_combustion , control_manual , us_rocket_launcher ] , [ us_morphling , engine_combustion , control_manual , us_heavy_gun ] , [ us_morphling , engine_combustion , control_computer , us_cargo_bay ] , [ us_medium_tracked , engine_combustion , control_computer , us_crane ] ] ) ;
1101: LD_INT 4
1103: PPUSH
1104: LD_INT 5
1106: PUSH
1107: LD_INT 1
1109: PUSH
1110: LD_INT 1
1112: PUSH
1113: LD_INT 7
1115: PUSH
1116: EMPTY
1117: LIST
1118: LIST
1119: LIST
1120: LIST
1121: PUSH
1122: LD_INT 5
1124: PUSH
1125: LD_INT 1
1127: PUSH
1128: LD_INT 1
1130: PUSH
1131: LD_INT 6
1133: PUSH
1134: EMPTY
1135: LIST
1136: LIST
1137: LIST
1138: LIST
1139: PUSH
1140: LD_INT 5
1142: PUSH
1143: LD_INT 1
1145: PUSH
1146: LD_INT 1
1148: PUSH
1149: LD_INT 7
1151: PUSH
1152: EMPTY
1153: LIST
1154: LIST
1155: LIST
1156: LIST
1157: PUSH
1158: LD_INT 5
1160: PUSH
1161: LD_INT 1
1163: PUSH
1164: LD_INT 1
1166: PUSH
1167: LD_INT 6
1169: PUSH
1170: EMPTY
1171: LIST
1172: LIST
1173: LIST
1174: LIST
1175: PUSH
1176: LD_INT 5
1178: PUSH
1179: LD_INT 1
1181: PUSH
1182: LD_INT 3
1184: PUSH
1185: LD_INT 12
1187: PUSH
1188: EMPTY
1189: LIST
1190: LIST
1191: LIST
1192: LIST
1193: PUSH
1194: LD_INT 3
1196: PUSH
1197: LD_INT 1
1199: PUSH
1200: LD_INT 3
1202: PUSH
1203: LD_INT 13
1205: PUSH
1206: EMPTY
1207: LIST
1208: LIST
1209: LIST
1210: LIST
1211: PUSH
1212: EMPTY
1213: LIST
1214: LIST
1215: LIST
1216: LIST
1217: LIST
1218: LIST
1219: PPUSH
1220: CALL 44154 0 2
// MC_SetDefenderLimit ( 4 , 4 ) ;
1224: LD_INT 4
1226: PPUSH
1227: LD_INT 4
1229: PPUSH
1230: CALL 44339 0 2
// MC_SetTame ( 4 , powellApe ) ;
1234: LD_INT 4
1236: PPUSH
1237: LD_INT 11
1239: PPUSH
1240: CALL 44720 0 2
// end ;
1244: LD_VAR 0 1
1248: RET
// every 0 0$1 trigger debug do var i ;
1249: LD_EXP 1
1253: IFFALSE 1351
1255: GO 1257
1257: DISABLE
1258: LD_INT 0
1260: PPUSH
// begin enable ;
1261: ENABLE
// for i in FilterAllUnits ( [ [ f_side , 7 ] , [ f_or , [ f_type , unit_human ] , [ f_type , unit_vehicle ] ] , [ f_not , [ f_lives , 1000 ] ] ] ) do
1262: LD_ADDR_VAR 0 1
1266: PUSH
1267: LD_INT 22
1269: PUSH
1270: LD_INT 7
1272: PUSH
1273: EMPTY
1274: LIST
1275: LIST
1276: PUSH
1277: LD_INT 2
1279: PUSH
1280: LD_INT 21
1282: PUSH
1283: LD_INT 1
1285: PUSH
1286: EMPTY
1287: LIST
1288: LIST
1289: PUSH
1290: LD_INT 21
1292: PUSH
1293: LD_INT 2
1295: PUSH
1296: EMPTY
1297: LIST
1298: LIST
1299: PUSH
1300: EMPTY
1301: LIST
1302: LIST
1303: LIST
1304: PUSH
1305: LD_INT 3
1307: PUSH
1308: LD_INT 24
1310: PUSH
1311: LD_INT 1000
1313: PUSH
1314: EMPTY
1315: LIST
1316: LIST
1317: PUSH
1318: EMPTY
1319: LIST
1320: LIST
1321: PUSH
1322: EMPTY
1323: LIST
1324: LIST
1325: LIST
1326: PPUSH
1327: CALL_OW 69
1331: PUSH
1332: FOR_IN
1333: IFFALSE 1349
// SetLives ( i , 1000 ) ;
1335: LD_VAR 0 1
1339: PPUSH
1340: LD_INT 1000
1342: PPUSH
1343: CALL_OW 234
1347: GO 1332
1349: POP
1350: POP
// end ;
1351: PPOPN 1
1353: END
// every 0 0$1 trigger artifactDestroyCounter >= 5 do
1354: LD_EXP 16
1358: PUSH
1359: LD_INT 5
1361: GREATEREQUAL
1362: IFFALSE 1374
1364: GO 1366
1366: DISABLE
// SetAchievement ( ACH_ARTIFACT ) ; end_of_file
1367: LD_STRING ACH_ARTIFACT
1369: PPUSH
1370: CALL_OW 543
1374: END
// export JMM , Roth , Lisa , Donaldson , Bobby , Cyrus , Denis , Brown , Gladstone , Houten , Cornel , Gary , Frank , Kikuchi , Simms , Joan , DeltaDoctor , Connie ; export Gossudarov , Kirilenkova , Titov , Fadeev , Dolgov , Petrosyan , Scholtze , Oblukov , Kapitsova , Lipshchin , Petrovova , Kovalyuk , Kuzmov , Karamazov ; export Burlak , Belkov , Gnyevko ; export function PrepareAlliance ; var i , veh , selected , tmp ; begin
1375: LD_INT 0
1377: PPUSH
1378: PPUSH
1379: PPUSH
1380: PPUSH
1381: PPUSH
// uc_side := 7 ;
1382: LD_ADDR_OWVAR 20
1386: PUSH
1387: LD_INT 7
1389: ST_TO_ADDR
// tmp := [ ] ;
1390: LD_ADDR_VAR 0 5
1394: PUSH
1395: EMPTY
1396: ST_TO_ADDR
// JMM := PrepareUnit ( JMM , ( not debug ) , 14a_ ) ;
1397: LD_ADDR_EXP 17
1401: PUSH
1402: LD_STRING JMM
1404: PPUSH
1405: LD_EXP 1
1409: NOT
1410: PPUSH
1411: LD_STRING 14a_
1413: PPUSH
1414: CALL 50546 0 3
1418: ST_TO_ADDR
// Burlak := PrepareUnit ( Burlak , ( not debug ) , 14a_ ) ;
1419: LD_ADDR_EXP 49
1423: PUSH
1424: LD_STRING Burlak
1426: PPUSH
1427: LD_EXP 1
1431: NOT
1432: PPUSH
1433: LD_STRING 14a_
1435: PPUSH
1436: CALL 50546 0 3
1440: ST_TO_ADDR
// Joan := PrepareUnit ( Joan , ( not debug ) , 13a_ ) ;
1441: LD_ADDR_EXP 32
1445: PUSH
1446: LD_STRING Joan
1448: PPUSH
1449: LD_EXP 1
1453: NOT
1454: PPUSH
1455: LD_STRING 13a_
1457: PPUSH
1458: CALL 50546 0 3
1462: ST_TO_ADDR
// Roth := PrepareUnit ( Roth , ( not debug ) , 13a_ ) ;
1463: LD_ADDR_EXP 18
1467: PUSH
1468: LD_STRING Roth
1470: PPUSH
1471: LD_EXP 1
1475: NOT
1476: PPUSH
1477: LD_STRING 13a_
1479: PPUSH
1480: CALL 50546 0 3
1484: ST_TO_ADDR
// Gossudarov := PrepareUnit ( Gossudarov , ( not debug ) , 13a_ ) ;
1485: LD_ADDR_EXP 35
1489: PUSH
1490: LD_STRING Gossudarov
1492: PPUSH
1493: LD_EXP 1
1497: NOT
1498: PPUSH
1499: LD_STRING 13a_
1501: PPUSH
1502: CALL 50546 0 3
1506: ST_TO_ADDR
// Denis := PrepareUnit ( Denis , ( not debug ) , 13a_ ) ;
1507: LD_ADDR_EXP 23
1511: PUSH
1512: LD_STRING Denis
1514: PPUSH
1515: LD_EXP 1
1519: NOT
1520: PPUSH
1521: LD_STRING 13a_
1523: PPUSH
1524: CALL 50546 0 3
1528: ST_TO_ADDR
// DeltaDoctor := PrepareUnit ( DeltaDoctor , ( not debug ) , 13a_ ) ;
1529: LD_ADDR_EXP 33
1533: PUSH
1534: LD_STRING DeltaDoctor
1536: PPUSH
1537: LD_EXP 1
1541: NOT
1542: PPUSH
1543: LD_STRING 13a_
1545: PPUSH
1546: CALL 50546 0 3
1550: ST_TO_ADDR
// if DeltaDoctor then
1551: LD_EXP 33
1555: IFFALSE 1573
// tmp := tmp ^ DeltaDoctor ;
1557: LD_ADDR_VAR 0 5
1561: PUSH
1562: LD_VAR 0 5
1566: PUSH
1567: LD_EXP 33
1571: ADD
1572: ST_TO_ADDR
// Simms := PrepareUnit ( Simms , ( not debug ) , 13a_ ) ;
1573: LD_ADDR_EXP 31
1577: PUSH
1578: LD_STRING Simms
1580: PPUSH
1581: LD_EXP 1
1585: NOT
1586: PPUSH
1587: LD_STRING 13a_
1589: PPUSH
1590: CALL 50546 0 3
1594: ST_TO_ADDR
// if Simms then
1595: LD_EXP 31
1599: IFFALSE 1617
// tmp := tmp ^ Simms ;
1601: LD_ADDR_VAR 0 5
1605: PUSH
1606: LD_VAR 0 5
1610: PUSH
1611: LD_EXP 31
1615: ADD
1616: ST_TO_ADDR
// Frank := PrepareUnit ( Frank , ( not debug ) , 13a_ ) ;
1617: LD_ADDR_EXP 29
1621: PUSH
1622: LD_STRING Frank
1624: PPUSH
1625: LD_EXP 1
1629: NOT
1630: PPUSH
1631: LD_STRING 13a_
1633: PPUSH
1634: CALL 50546 0 3
1638: ST_TO_ADDR
// if Frank then
1639: LD_EXP 29
1643: IFFALSE 1661
// tmp := tmp ^ Frank ;
1645: LD_ADDR_VAR 0 5
1649: PUSH
1650: LD_VAR 0 5
1654: PUSH
1655: LD_EXP 29
1659: ADD
1660: ST_TO_ADDR
// Kirilenkova := PrepareUnit ( Kirilenkova , ( not debug ) , 13a_ ) ;
1661: LD_ADDR_EXP 36
1665: PUSH
1666: LD_STRING Kirilenkova
1668: PPUSH
1669: LD_EXP 1
1673: NOT
1674: PPUSH
1675: LD_STRING 13a_
1677: PPUSH
1678: CALL 50546 0 3
1682: ST_TO_ADDR
// if Kirilenkova then
1683: LD_EXP 36
1687: IFFALSE 1705
// tmp := tmp ^ Kirilenkova ;
1689: LD_ADDR_VAR 0 5
1693: PUSH
1694: LD_VAR 0 5
1698: PUSH
1699: LD_EXP 36
1703: ADD
1704: ST_TO_ADDR
// Titov := PrepareUnit ( Titov , ( not debug ) , 13a_ ) ;
1705: LD_ADDR_EXP 37
1709: PUSH
1710: LD_STRING Titov
1712: PPUSH
1713: LD_EXP 1
1717: NOT
1718: PPUSH
1719: LD_STRING 13a_
1721: PPUSH
1722: CALL 50546 0 3
1726: ST_TO_ADDR
// if Titov then
1727: LD_EXP 37
1731: IFFALSE 1749
// tmp := tmp ^ Titov ;
1733: LD_ADDR_VAR 0 5
1737: PUSH
1738: LD_VAR 0 5
1742: PUSH
1743: LD_EXP 37
1747: ADD
1748: ST_TO_ADDR
// Fadeev := PrepareUnit ( Fadeev , ( not debug ) , 13a_ ) ;
1749: LD_ADDR_EXP 38
1753: PUSH
1754: LD_STRING Fadeev
1756: PPUSH
1757: LD_EXP 1
1761: NOT
1762: PPUSH
1763: LD_STRING 13a_
1765: PPUSH
1766: CALL 50546 0 3
1770: ST_TO_ADDR
// if Fadeev then
1771: LD_EXP 38
1775: IFFALSE 1793
// tmp := tmp ^ Fadeev ;
1777: LD_ADDR_VAR 0 5
1781: PUSH
1782: LD_VAR 0 5
1786: PUSH
1787: LD_EXP 38
1791: ADD
1792: ST_TO_ADDR
// Dolgov := PrepareUnit ( Dolgov , ( not debug ) , 13a_ ) ;
1793: LD_ADDR_EXP 39
1797: PUSH
1798: LD_STRING Dolgov
1800: PPUSH
1801: LD_EXP 1
1805: NOT
1806: PPUSH
1807: LD_STRING 13a_
1809: PPUSH
1810: CALL 50546 0 3
1814: ST_TO_ADDR
// if Dolgov then
1815: LD_EXP 39
1819: IFFALSE 1837
// tmp := tmp ^ Dolgov ;
1821: LD_ADDR_VAR 0 5
1825: PUSH
1826: LD_VAR 0 5
1830: PUSH
1831: LD_EXP 39
1835: ADD
1836: ST_TO_ADDR
// Petrosyan := PrepareUnit ( Petrosyan , ( not debug ) , 13a_ ) ;
1837: LD_ADDR_EXP 40
1841: PUSH
1842: LD_STRING Petrosyan
1844: PPUSH
1845: LD_EXP 1
1849: NOT
1850: PPUSH
1851: LD_STRING 13a_
1853: PPUSH
1854: CALL 50546 0 3
1858: ST_TO_ADDR
// if Petrosyan then
1859: LD_EXP 40
1863: IFFALSE 1881
// tmp := tmp ^ Petrosyan ;
1865: LD_ADDR_VAR 0 5
1869: PUSH
1870: LD_VAR 0 5
1874: PUSH
1875: LD_EXP 40
1879: ADD
1880: ST_TO_ADDR
// Scholtze := PrepareUnit ( Scholtze , ( not debug ) , 13a_ ) ;
1881: LD_ADDR_EXP 41
1885: PUSH
1886: LD_STRING Scholtze
1888: PPUSH
1889: LD_EXP 1
1893: NOT
1894: PPUSH
1895: LD_STRING 13a_
1897: PPUSH
1898: CALL 50546 0 3
1902: ST_TO_ADDR
// if Scholtze then
1903: LD_EXP 41
1907: IFFALSE 1925
// tmp := tmp ^ Scholtze ;
1909: LD_ADDR_VAR 0 5
1913: PUSH
1914: LD_VAR 0 5
1918: PUSH
1919: LD_EXP 41
1923: ADD
1924: ST_TO_ADDR
// Oblukov := PrepareUnit ( Oblukov , ( not debug ) , 13a_ ) ;
1925: LD_ADDR_EXP 42
1929: PUSH
1930: LD_STRING Oblukov
1932: PPUSH
1933: LD_EXP 1
1937: NOT
1938: PPUSH
1939: LD_STRING 13a_
1941: PPUSH
1942: CALL 50546 0 3
1946: ST_TO_ADDR
// if Oblukov then
1947: LD_EXP 42
1951: IFFALSE 1969
// tmp := tmp ^ Oblukov ;
1953: LD_ADDR_VAR 0 5
1957: PUSH
1958: LD_VAR 0 5
1962: PUSH
1963: LD_EXP 42
1967: ADD
1968: ST_TO_ADDR
// Kapitsova := PrepareUnit ( Kapitsova , ( not debug ) , 13a_ ) ;
1969: LD_ADDR_EXP 43
1973: PUSH
1974: LD_STRING Kapitsova
1976: PPUSH
1977: LD_EXP 1
1981: NOT
1982: PPUSH
1983: LD_STRING 13a_
1985: PPUSH
1986: CALL 50546 0 3
1990: ST_TO_ADDR
// if Kapitsova then
1991: LD_EXP 43
1995: IFFALSE 2013
// tmp := tmp ^ Kapitsova ;
1997: LD_ADDR_VAR 0 5
2001: PUSH
2002: LD_VAR 0 5
2006: PUSH
2007: LD_EXP 43
2011: ADD
2012: ST_TO_ADDR
// Lipshchin := PrepareUnit ( Lipshchin , ( not debug ) , 13a_ ) ;
2013: LD_ADDR_EXP 44
2017: PUSH
2018: LD_STRING Lipshchin
2020: PPUSH
2021: LD_EXP 1
2025: NOT
2026: PPUSH
2027: LD_STRING 13a_
2029: PPUSH
2030: CALL 50546 0 3
2034: ST_TO_ADDR
// if Lipshchin then
2035: LD_EXP 44
2039: IFFALSE 2057
// tmp := tmp ^ Lipshchin ;
2041: LD_ADDR_VAR 0 5
2045: PUSH
2046: LD_VAR 0 5
2050: PUSH
2051: LD_EXP 44
2055: ADD
2056: ST_TO_ADDR
// Petrovova := PrepareUnit ( Petrovova , ( not debug ) , 13a_ ) ;
2057: LD_ADDR_EXP 45
2061: PUSH
2062: LD_STRING Petrovova
2064: PPUSH
2065: LD_EXP 1
2069: NOT
2070: PPUSH
2071: LD_STRING 13a_
2073: PPUSH
2074: CALL 50546 0 3
2078: ST_TO_ADDR
// if Petrovova then
2079: LD_EXP 45
2083: IFFALSE 2101
// tmp := tmp ^ Petrovova ;
2085: LD_ADDR_VAR 0 5
2089: PUSH
2090: LD_VAR 0 5
2094: PUSH
2095: LD_EXP 45
2099: ADD
2100: ST_TO_ADDR
// Kovalyuk := PrepareUnit ( Kovalyuk , ( not debug ) , 13a_ ) ;
2101: LD_ADDR_EXP 46
2105: PUSH
2106: LD_STRING Kovalyuk
2108: PPUSH
2109: LD_EXP 1
2113: NOT
2114: PPUSH
2115: LD_STRING 13a_
2117: PPUSH
2118: CALL 50546 0 3
2122: ST_TO_ADDR
// if Kovalyuk then
2123: LD_EXP 46
2127: IFFALSE 2145
// tmp := tmp ^ Kovalyuk ;
2129: LD_ADDR_VAR 0 5
2133: PUSH
2134: LD_VAR 0 5
2138: PUSH
2139: LD_EXP 46
2143: ADD
2144: ST_TO_ADDR
// Kuzmov := PrepareUnit ( Kuzmov , ( not debug ) , 13a_ ) ;
2145: LD_ADDR_EXP 47
2149: PUSH
2150: LD_STRING Kuzmov
2152: PPUSH
2153: LD_EXP 1
2157: NOT
2158: PPUSH
2159: LD_STRING 13a_
2161: PPUSH
2162: CALL 50546 0 3
2166: ST_TO_ADDR
// if Kuzmov then
2167: LD_EXP 47
2171: IFFALSE 2189
// tmp := tmp ^ Kuzmov ;
2173: LD_ADDR_VAR 0 5
2177: PUSH
2178: LD_VAR 0 5
2182: PUSH
2183: LD_EXP 47
2187: ADD
2188: ST_TO_ADDR
// Karamazov := PrepareUnit ( Karamazov , ( not debug ) , 13a_ ) ;
2189: LD_ADDR_EXP 48
2193: PUSH
2194: LD_STRING Karamazov
2196: PPUSH
2197: LD_EXP 1
2201: NOT
2202: PPUSH
2203: LD_STRING 13a_
2205: PPUSH
2206: CALL 50546 0 3
2210: ST_TO_ADDR
// if Karamazov then
2211: LD_EXP 48
2215: IFFALSE 2233
// tmp := tmp ^ Karamazov ;
2217: LD_ADDR_VAR 0 5
2221: PUSH
2222: LD_VAR 0 5
2226: PUSH
2227: LD_EXP 48
2231: ADD
2232: ST_TO_ADDR
// Belkov := PrepareUnit ( Belkov , ( not debug ) , 13a_ ) ;
2233: LD_ADDR_EXP 50
2237: PUSH
2238: LD_STRING Belkov
2240: PPUSH
2241: LD_EXP 1
2245: NOT
2246: PPUSH
2247: LD_STRING 13a_
2249: PPUSH
2250: CALL 50546 0 3
2254: ST_TO_ADDR
// if Belkov then
2255: LD_EXP 50
2259: IFFALSE 2277
// tmp := tmp ^ Belkov ;
2261: LD_ADDR_VAR 0 5
2265: PUSH
2266: LD_VAR 0 5
2270: PUSH
2271: LD_EXP 50
2275: ADD
2276: ST_TO_ADDR
// Gnyevko := PrepareUnit ( Gnyevko , ( not debug ) , 13a_ ) ;
2277: LD_ADDR_EXP 51
2281: PUSH
2282: LD_STRING Gnyevko
2284: PPUSH
2285: LD_EXP 1
2289: NOT
2290: PPUSH
2291: LD_STRING 13a_
2293: PPUSH
2294: CALL 50546 0 3
2298: ST_TO_ADDR
// if Gnyevko then
2299: LD_EXP 51
2303: IFFALSE 2321
// tmp := tmp ^ Gnyevko ;
2305: LD_ADDR_VAR 0 5
2309: PUSH
2310: LD_VAR 0 5
2314: PUSH
2315: LD_EXP 51
2319: ADD
2320: ST_TO_ADDR
// Connie = NewCharacter ( Coonie ) ;
2321: LD_ADDR_EXP 34
2325: PUSH
2326: LD_STRING Coonie
2328: PPUSH
2329: CALL_OW 25
2333: ST_TO_ADDR
// if not Lisa then
2334: LD_EXP 19
2338: NOT
2339: IFFALSE 2385
// begin Lisa := PrepareUnit ( Lisa , ( not debug ) , 13a_ ) ;
2341: LD_ADDR_EXP 19
2345: PUSH
2346: LD_STRING Lisa
2348: PPUSH
2349: LD_EXP 1
2353: NOT
2354: PPUSH
2355: LD_STRING 13a_
2357: PPUSH
2358: CALL 50546 0 3
2362: ST_TO_ADDR
// if Lisa then
2363: LD_EXP 19
2367: IFFALSE 2385
// tmp := tmp ^ Lisa ;
2369: LD_ADDR_VAR 0 5
2373: PUSH
2374: LD_VAR 0 5
2378: PUSH
2379: LD_EXP 19
2383: ADD
2384: ST_TO_ADDR
// end ; if not Donaldson then
2385: LD_EXP 20
2389: NOT
2390: IFFALSE 2436
// begin Donaldson := PrepareUnit ( Donaldson , ( not debug ) , 13a_ ) ;
2392: LD_ADDR_EXP 20
2396: PUSH
2397: LD_STRING Donaldson
2399: PPUSH
2400: LD_EXP 1
2404: NOT
2405: PPUSH
2406: LD_STRING 13a_
2408: PPUSH
2409: CALL 50546 0 3
2413: ST_TO_ADDR
// if Donaldson then
2414: LD_EXP 20
2418: IFFALSE 2436
// tmp := tmp ^ Donaldson ;
2420: LD_ADDR_VAR 0 5
2424: PUSH
2425: LD_VAR 0 5
2429: PUSH
2430: LD_EXP 20
2434: ADD
2435: ST_TO_ADDR
// end ; if not Bobby then
2436: LD_EXP 21
2440: NOT
2441: IFFALSE 2487
// begin Bobby := PrepareUnit ( Bobby , ( not debug ) , 13a_ ) ;
2443: LD_ADDR_EXP 21
2447: PUSH
2448: LD_STRING Bobby
2450: PPUSH
2451: LD_EXP 1
2455: NOT
2456: PPUSH
2457: LD_STRING 13a_
2459: PPUSH
2460: CALL 50546 0 3
2464: ST_TO_ADDR
// if Bobby then
2465: LD_EXP 21
2469: IFFALSE 2487
// tmp := tmp ^ Bobby ;
2471: LD_ADDR_VAR 0 5
2475: PUSH
2476: LD_VAR 0 5
2480: PUSH
2481: LD_EXP 21
2485: ADD
2486: ST_TO_ADDR
// end ; if not Cyrus then
2487: LD_EXP 22
2491: NOT
2492: IFFALSE 2538
// begin Cyrus := PrepareUnit ( Cyrus , ( not debug ) , 13a_ ) ;
2494: LD_ADDR_EXP 22
2498: PUSH
2499: LD_STRING Cyrus
2501: PPUSH
2502: LD_EXP 1
2506: NOT
2507: PPUSH
2508: LD_STRING 13a_
2510: PPUSH
2511: CALL 50546 0 3
2515: ST_TO_ADDR
// if Cyrus then
2516: LD_EXP 22
2520: IFFALSE 2538
// tmp := tmp ^ Cyrus ;
2522: LD_ADDR_VAR 0 5
2526: PUSH
2527: LD_VAR 0 5
2531: PUSH
2532: LD_EXP 22
2536: ADD
2537: ST_TO_ADDR
// end ; if not Brown then
2538: LD_EXP 24
2542: NOT
2543: IFFALSE 2589
// begin Brown := PrepareUnit ( Brown , ( not debug ) , 13a_ ) ;
2545: LD_ADDR_EXP 24
2549: PUSH
2550: LD_STRING Brown
2552: PPUSH
2553: LD_EXP 1
2557: NOT
2558: PPUSH
2559: LD_STRING 13a_
2561: PPUSH
2562: CALL 50546 0 3
2566: ST_TO_ADDR
// if Brown then
2567: LD_EXP 24
2571: IFFALSE 2589
// tmp := tmp ^ Brown ;
2573: LD_ADDR_VAR 0 5
2577: PUSH
2578: LD_VAR 0 5
2582: PUSH
2583: LD_EXP 24
2587: ADD
2588: ST_TO_ADDR
// end ; if not Gladstone then
2589: LD_EXP 25
2593: NOT
2594: IFFALSE 2640
// begin Gladstone := PrepareUnit ( Gladstone , ( not debug ) , 13a_ ) ;
2596: LD_ADDR_EXP 25
2600: PUSH
2601: LD_STRING Gladstone
2603: PPUSH
2604: LD_EXP 1
2608: NOT
2609: PPUSH
2610: LD_STRING 13a_
2612: PPUSH
2613: CALL 50546 0 3
2617: ST_TO_ADDR
// if Gladstone then
2618: LD_EXP 25
2622: IFFALSE 2640
// tmp := tmp ^ Gladstone ;
2624: LD_ADDR_VAR 0 5
2628: PUSH
2629: LD_VAR 0 5
2633: PUSH
2634: LD_EXP 25
2638: ADD
2639: ST_TO_ADDR
// end ; if not Cornel then
2640: LD_EXP 27
2644: NOT
2645: IFFALSE 2691
// begin Cornel := PrepareUnit ( Cornel , ( not debug ) , 13a_ ) ;
2647: LD_ADDR_EXP 27
2651: PUSH
2652: LD_STRING Cornel
2654: PPUSH
2655: LD_EXP 1
2659: NOT
2660: PPUSH
2661: LD_STRING 13a_
2663: PPUSH
2664: CALL 50546 0 3
2668: ST_TO_ADDR
// if Cornel then
2669: LD_EXP 27
2673: IFFALSE 2691
// tmp := tmp ^ Cornel ;
2675: LD_ADDR_VAR 0 5
2679: PUSH
2680: LD_VAR 0 5
2684: PUSH
2685: LD_EXP 27
2689: ADD
2690: ST_TO_ADDR
// end ; if not Houten then
2691: LD_EXP 26
2695: NOT
2696: IFFALSE 2742
// begin Houten := PrepareUnit ( Houten , ( not debug ) , 13a_ ) ;
2698: LD_ADDR_EXP 26
2702: PUSH
2703: LD_STRING Houten
2705: PPUSH
2706: LD_EXP 1
2710: NOT
2711: PPUSH
2712: LD_STRING 13a_
2714: PPUSH
2715: CALL 50546 0 3
2719: ST_TO_ADDR
// if Houten then
2720: LD_EXP 26
2724: IFFALSE 2742
// tmp := tmp ^ Houten ;
2726: LD_ADDR_VAR 0 5
2730: PUSH
2731: LD_VAR 0 5
2735: PUSH
2736: LD_EXP 26
2740: ADD
2741: ST_TO_ADDR
// end ; if not Gary then
2742: LD_EXP 28
2746: NOT
2747: IFFALSE 2793
// begin Gary := PrepareUnit ( Gary , ( not debug ) , 13a_ ) ;
2749: LD_ADDR_EXP 28
2753: PUSH
2754: LD_STRING Gary
2756: PPUSH
2757: LD_EXP 1
2761: NOT
2762: PPUSH
2763: LD_STRING 13a_
2765: PPUSH
2766: CALL 50546 0 3
2770: ST_TO_ADDR
// if Gary then
2771: LD_EXP 28
2775: IFFALSE 2793
// tmp := tmp ^ Gary ;
2777: LD_ADDR_VAR 0 5
2781: PUSH
2782: LD_VAR 0 5
2786: PUSH
2787: LD_EXP 28
2791: ADD
2792: ST_TO_ADDR
// end ; if not Kikuchi then
2793: LD_EXP 30
2797: NOT
2798: IFFALSE 2844
// begin Kikuchi := PrepareUnit ( Kikuchi , ( not debug ) , 13a_ ) ;
2800: LD_ADDR_EXP 30
2804: PUSH
2805: LD_STRING Kikuchi
2807: PPUSH
2808: LD_EXP 1
2812: NOT
2813: PPUSH
2814: LD_STRING 13a_
2816: PPUSH
2817: CALL 50546 0 3
2821: ST_TO_ADDR
// if Kikuchi then
2822: LD_EXP 30
2826: IFFALSE 2844
// tmp := tmp ^ Kikuchi ;
2828: LD_ADDR_VAR 0 5
2832: PUSH
2833: LD_VAR 0 5
2837: PUSH
2838: LD_EXP 30
2842: ADD
2843: ST_TO_ADDR
// end ; tmp := tmp union CreateCharacterSet ( 13a_others ) ;
2844: LD_ADDR_VAR 0 5
2848: PUSH
2849: LD_VAR 0 5
2853: PUSH
2854: LD_STRING 13a_others
2856: PPUSH
2857: CALL_OW 31
2861: UNION
2862: ST_TO_ADDR
// tmp := tmp diff 0 ;
2863: LD_ADDR_VAR 0 5
2867: PUSH
2868: LD_VAR 0 5
2872: PUSH
2873: LD_INT 0
2875: DIFF
2876: ST_TO_ADDR
// if tmp < 15 then
2877: LD_VAR 0 5
2881: PUSH
2882: LD_INT 15
2884: LESS
2885: IFFALSE 2973
// for i = 15 downto tmp do
2887: LD_ADDR_VAR 0 2
2891: PUSH
2892: DOUBLE
2893: LD_INT 15
2895: INC
2896: ST_TO_ADDR
2897: LD_VAR 0 5
2901: PUSH
2902: FOR_DOWNTO
2903: IFFALSE 2971
// begin uc_nation := [ 1 , 3 ] [ rand ( 1 , 2 ) ] ;
2905: LD_ADDR_OWVAR 21
2909: PUSH
2910: LD_INT 1
2912: PUSH
2913: LD_INT 3
2915: PUSH
2916: EMPTY
2917: LIST
2918: LIST
2919: PUSH
2920: LD_INT 1
2922: PPUSH
2923: LD_INT 2
2925: PPUSH
2926: CALL_OW 12
2930: ARRAY
2931: ST_TO_ADDR
// PrepareHuman ( false , rand ( 1 , 4 ) , 8 ) ;
2932: LD_INT 0
2934: PPUSH
2935: LD_INT 1
2937: PPUSH
2938: LD_INT 4
2940: PPUSH
2941: CALL_OW 12
2945: PPUSH
2946: LD_INT 8
2948: PPUSH
2949: CALL_OW 380
// tmp := tmp ^ CreateHuman ;
2953: LD_ADDR_VAR 0 5
2957: PUSH
2958: LD_VAR 0 5
2962: PUSH
2963: CALL_OW 44
2967: ADD
2968: ST_TO_ADDR
// end ;
2969: GO 2902
2971: POP
2972: POP
// if not debug then
2973: LD_EXP 1
2977: NOT
2978: IFFALSE 3150
// selected = CharacterSelection (  , [ 15 , 14 , 13 ] [ Difficulty ] , [ 15 , 14 , 13 ] [ Difficulty ] , [ sel_dont_change_class , JMM , Burlak , Roth , Joan , Denis , Gossudarov , sel_not_hired , sel_changeable , sel_change_class ] ^ tmp , [ class_soldier , class_scientistic , [ class_engineer , 1 ] , class_mechanic , [ class_sniper , 0 , 3 ] , [ class_bazooker , 0 , 3 ] ] ) else
2980: LD_ADDR_VAR 0 4
2984: PUSH
2985: LD_STRING 
2987: PPUSH
2988: LD_INT 15
2990: PUSH
2991: LD_INT 14
2993: PUSH
2994: LD_INT 13
2996: PUSH
2997: EMPTY
2998: LIST
2999: LIST
3000: LIST
3001: PUSH
3002: LD_OWVAR 67
3006: ARRAY
3007: PPUSH
3008: LD_INT 15
3010: PUSH
3011: LD_INT 14
3013: PUSH
3014: LD_INT 13
3016: PUSH
3017: EMPTY
3018: LIST
3019: LIST
3020: LIST
3021: PUSH
3022: LD_OWVAR 67
3026: ARRAY
3027: PPUSH
3028: LD_INT -6
3030: PUSH
3031: LD_EXP 17
3035: PUSH
3036: LD_EXP 49
3040: PUSH
3041: LD_EXP 18
3045: PUSH
3046: LD_EXP 32
3050: PUSH
3051: LD_EXP 23
3055: PUSH
3056: LD_EXP 35
3060: PUSH
3061: LD_INT -2
3063: PUSH
3064: LD_INT -3
3066: PUSH
3067: LD_INT -5
3069: PUSH
3070: EMPTY
3071: LIST
3072: LIST
3073: LIST
3074: LIST
3075: LIST
3076: LIST
3077: LIST
3078: LIST
3079: LIST
3080: LIST
3081: PUSH
3082: LD_VAR 0 5
3086: ADD
3087: PPUSH
3088: LD_INT 1
3090: PUSH
3091: LD_INT 4
3093: PUSH
3094: LD_INT 2
3096: PUSH
3097: LD_INT 1
3099: PUSH
3100: EMPTY
3101: LIST
3102: LIST
3103: PUSH
3104: LD_INT 3
3106: PUSH
3107: LD_INT 5
3109: PUSH
3110: LD_INT 0
3112: PUSH
3113: LD_INT 3
3115: PUSH
3116: EMPTY
3117: LIST
3118: LIST
3119: LIST
3120: PUSH
3121: LD_INT 9
3123: PUSH
3124: LD_INT 0
3126: PUSH
3127: LD_INT 3
3129: PUSH
3130: EMPTY
3131: LIST
3132: LIST
3133: LIST
3134: PUSH
3135: EMPTY
3136: LIST
3137: LIST
3138: LIST
3139: LIST
3140: LIST
3141: LIST
3142: PPUSH
3143: CALL_OW 42
3147: ST_TO_ADDR
3148: GO 3229
// selected := [ Titov , Fadeev , Dolgov , Petrosyan , Scholtze , Oblukov , Kapitsova , Lipshchin , Petrovova , Kovalyuk , Kuzmov , Karamazov ] ;
3150: LD_ADDR_VAR 0 4
3154: PUSH
3155: LD_EXP 37
3159: PUSH
3160: LD_EXP 38
3164: PUSH
3165: LD_EXP 39
3169: PUSH
3170: LD_EXP 40
3174: PUSH
3175: LD_EXP 41
3179: PUSH
3180: LD_EXP 42
3184: PUSH
3185: LD_EXP 43
3189: PUSH
3190: LD_EXP 44
3194: PUSH
3195: LD_EXP 45
3199: PUSH
3200: LD_EXP 46
3204: PUSH
3205: LD_EXP 47
3209: PUSH
3210: LD_EXP 48
3214: PUSH
3215: EMPTY
3216: LIST
3217: LIST
3218: LIST
3219: LIST
3220: LIST
3221: LIST
3222: LIST
3223: LIST
3224: LIST
3225: LIST
3226: LIST
3227: LIST
3228: ST_TO_ADDR
// uc_nation := 1 ;
3229: LD_ADDR_OWVAR 21
3233: PUSH
3234: LD_INT 1
3236: ST_TO_ADDR
// PrepareVehicle ( us_morphling , engine_siberite , control_manual , us_heavy_gun , 100 ) ;
3237: LD_INT 5
3239: PPUSH
3240: LD_INT 3
3242: PPUSH
3243: LD_INT 1
3245: PPUSH
3246: LD_INT 6
3248: PPUSH
3249: LD_INT 100
3251: PPUSH
3252: CALL 57661 0 5
// veh := CreateVehicle ;
3256: LD_ADDR_VAR 0 3
3260: PUSH
3261: CALL_OW 45
3265: ST_TO_ADDR
// SetMark ( veh , - 7 ) ;
3266: LD_VAR 0 3
3270: PPUSH
3271: LD_INT 7
3273: NEG
3274: PPUSH
3275: CALL_OW 242
// SetDir ( veh , 3 ) ;
3279: LD_VAR 0 3
3283: PPUSH
3284: LD_INT 3
3286: PPUSH
3287: CALL_OW 233
// PlaceUnitArea ( veh , allianceJMMSpawnArea , false ) ;
3291: LD_VAR 0 3
3295: PPUSH
3296: LD_INT 31
3298: PPUSH
3299: LD_INT 0
3301: PPUSH
3302: CALL_OW 49
// PlaceHumanInUnit ( JMM , veh ) ;
3306: LD_EXP 17
3310: PPUSH
3311: LD_VAR 0 3
3315: PPUSH
3316: CALL_OW 52
// if Joan then
3320: LD_EXP 32
3324: IFFALSE 3396
// begin PrepareVehicle ( us_medium_tracked , engine_siberite , control_manual , us_radar , 100 ) ;
3326: LD_INT 3
3328: PPUSH
3329: LD_INT 3
3331: PPUSH
3332: LD_INT 1
3334: PPUSH
3335: LD_INT 11
3337: PPUSH
3338: LD_INT 100
3340: PPUSH
3341: CALL 57661 0 5
// veh := CreateVehicle ;
3345: LD_ADDR_VAR 0 3
3349: PUSH
3350: CALL_OW 45
3354: ST_TO_ADDR
// SetDir ( veh , 3 ) ;
3355: LD_VAR 0 3
3359: PPUSH
3360: LD_INT 3
3362: PPUSH
3363: CALL_OW 233
// PlaceUnitArea ( veh , allianceSpawnArea , false ) ;
3367: LD_VAR 0 3
3371: PPUSH
3372: LD_INT 30
3374: PPUSH
3375: LD_INT 0
3377: PPUSH
3378: CALL_OW 49
// PlaceHumanInUnit ( Joan , veh ) ;
3382: LD_EXP 32
3386: PPUSH
3387: LD_VAR 0 3
3391: PPUSH
3392: CALL_OW 52
// end ; if Roth then
3396: LD_EXP 18
3400: IFFALSE 3472
// begin PrepareVehicle ( us_medium_tracked , engine_siberite , control_manual , us_radar , 100 ) ;
3402: LD_INT 3
3404: PPUSH
3405: LD_INT 3
3407: PPUSH
3408: LD_INT 1
3410: PPUSH
3411: LD_INT 11
3413: PPUSH
3414: LD_INT 100
3416: PPUSH
3417: CALL 57661 0 5
// veh := CreateVehicle ;
3421: LD_ADDR_VAR 0 3
3425: PUSH
3426: CALL_OW 45
3430: ST_TO_ADDR
// SetDir ( veh , 3 ) ;
3431: LD_VAR 0 3
3435: PPUSH
3436: LD_INT 3
3438: PPUSH
3439: CALL_OW 233
// PlaceUnitArea ( veh , allianceSpawnArea , false ) ;
3443: LD_VAR 0 3
3447: PPUSH
3448: LD_INT 30
3450: PPUSH
3451: LD_INT 0
3453: PPUSH
3454: CALL_OW 49
// PlaceHumanInUnit ( Roth , veh ) ;
3458: LD_EXP 18
3462: PPUSH
3463: LD_VAR 0 3
3467: PPUSH
3468: CALL_OW 52
// end ; if Denis then
3472: LD_EXP 23
3476: IFFALSE 3548
// begin PrepareVehicle ( us_morphling , engine_siberite , control_manual , us_laser , 100 ) ;
3478: LD_INT 5
3480: PPUSH
3481: LD_INT 3
3483: PPUSH
3484: LD_INT 1
3486: PPUSH
3487: LD_INT 9
3489: PPUSH
3490: LD_INT 100
3492: PPUSH
3493: CALL 57661 0 5
// veh := CreateVehicle ;
3497: LD_ADDR_VAR 0 3
3501: PUSH
3502: CALL_OW 45
3506: ST_TO_ADDR
// SetDir ( veh , 3 ) ;
3507: LD_VAR 0 3
3511: PPUSH
3512: LD_INT 3
3514: PPUSH
3515: CALL_OW 233
// PlaceUnitArea ( veh , allianceSpawnArea , false ) ;
3519: LD_VAR 0 3
3523: PPUSH
3524: LD_INT 30
3526: PPUSH
3527: LD_INT 0
3529: PPUSH
3530: CALL_OW 49
// PlaceHumanInUnit ( Denis , veh ) ;
3534: LD_EXP 23
3538: PPUSH
3539: LD_VAR 0 3
3543: PPUSH
3544: CALL_OW 52
// end ; uc_nation := 3 ;
3548: LD_ADDR_OWVAR 21
3552: PUSH
3553: LD_INT 3
3555: ST_TO_ADDR
// PrepareVehicle ( ru_medium_tracked , engine_siberite , control_manual , ru_rocket_launcher , 100 ) ;
3556: LD_INT 22
3558: PPUSH
3559: LD_INT 3
3561: PPUSH
3562: LD_INT 1
3564: PPUSH
3565: LD_INT 45
3567: PPUSH
3568: LD_INT 100
3570: PPUSH
3571: CALL 57661 0 5
// veh := CreateVehicle ;
3575: LD_ADDR_VAR 0 3
3579: PUSH
3580: CALL_OW 45
3584: ST_TO_ADDR
// SetMark ( veh , - 7 ) ;
3585: LD_VAR 0 3
3589: PPUSH
3590: LD_INT 7
3592: NEG
3593: PPUSH
3594: CALL_OW 242
// SetDir ( veh , 3 ) ;
3598: LD_VAR 0 3
3602: PPUSH
3603: LD_INT 3
3605: PPUSH
3606: CALL_OW 233
// PlaceUnitArea ( veh , allianceJMMSpawnArea , false ) ;
3610: LD_VAR 0 3
3614: PPUSH
3615: LD_INT 31
3617: PPUSH
3618: LD_INT 0
3620: PPUSH
3621: CALL_OW 49
// PlaceHumanInUnit ( Burlak , veh ) ;
3625: LD_EXP 49
3629: PPUSH
3630: LD_VAR 0 3
3634: PPUSH
3635: CALL_OW 52
// if Gossudarov then
3639: LD_EXP 35
3643: IFFALSE 3730
// begin PrepareVehicle ( ru_medium_tracked , engine_siberite , control_manual , ru_cargo_bay , 100 ) ;
3645: LD_INT 22
3647: PPUSH
3648: LD_INT 3
3650: PPUSH
3651: LD_INT 1
3653: PPUSH
3654: LD_INT 51
3656: PPUSH
3657: LD_INT 100
3659: PPUSH
3660: CALL 57661 0 5
// veh := CreateVehicle ;
3664: LD_ADDR_VAR 0 3
3668: PUSH
3669: CALL_OW 45
3673: ST_TO_ADDR
// SetDir ( veh , 3 ) ;
3674: LD_VAR 0 3
3678: PPUSH
3679: LD_INT 3
3681: PPUSH
3682: CALL_OW 233
// PlaceUnitArea ( veh , allianceSpawnArea , false ) ;
3686: LD_VAR 0 3
3690: PPUSH
3691: LD_INT 30
3693: PPUSH
3694: LD_INT 0
3696: PPUSH
3697: CALL_OW 49
// PlaceHumanInUnit ( Gossudarov , veh ) ;
3701: LD_EXP 35
3705: PPUSH
3706: LD_VAR 0 3
3710: PPUSH
3711: CALL_OW 52
// SetCargo ( veh , mat_cans , 100 ) ;
3715: LD_VAR 0 3
3719: PPUSH
3720: LD_INT 1
3722: PPUSH
3723: LD_INT 100
3725: PPUSH
3726: CALL_OW 290
// end ; for i in selected do
3730: LD_ADDR_VAR 0 2
3734: PUSH
3735: LD_VAR 0 4
3739: PUSH
3740: FOR_IN
3741: IFFALSE 4299
// begin uc_nation := GetNation ( i ) ;
3743: LD_ADDR_OWVAR 21
3747: PUSH
3748: LD_VAR 0 2
3752: PPUSH
3753: CALL_OW 248
3757: ST_TO_ADDR
// if i in [ Lisa , Donaldson , Cyrus , Bobby ] then
3758: LD_VAR 0 2
3762: PUSH
3763: LD_EXP 19
3767: PUSH
3768: LD_EXP 20
3772: PUSH
3773: LD_EXP 22
3777: PUSH
3778: LD_EXP 21
3782: PUSH
3783: EMPTY
3784: LIST
3785: LIST
3786: LIST
3787: LIST
3788: IN
3789: IFFALSE 3812
// PrepareVehicle ( us_morphling , engine_siberite , control_manual , us_heavy_gun , 100 ) else
3791: LD_INT 5
3793: PPUSH
3794: LD_INT 3
3796: PPUSH
3797: LD_INT 1
3799: PPUSH
3800: LD_INT 6
3802: PPUSH
3803: LD_INT 100
3805: PPUSH
3806: CALL 57661 0 5
3810: GO 4246
// if i in [ Oblukov , Kuzmov , Petrovova , Titov ] then
3812: LD_VAR 0 2
3816: PUSH
3817: LD_EXP 42
3821: PUSH
3822: LD_EXP 47
3826: PUSH
3827: LD_EXP 45
3831: PUSH
3832: LD_EXP 37
3836: PUSH
3837: EMPTY
3838: LIST
3839: LIST
3840: LIST
3841: LIST
3842: IN
3843: IFFALSE 3874
// PrepareVehicle ( ru_heavy_tracked , engine_combustion , control_manual , ru_heavy_gun , rand ( 65 , 75 ) ) else
3845: LD_INT 24
3847: PPUSH
3848: LD_INT 1
3850: PPUSH
3851: LD_INT 1
3853: PPUSH
3854: LD_INT 46
3856: PPUSH
3857: LD_INT 65
3859: PPUSH
3860: LD_INT 75
3862: PPUSH
3863: CALL_OW 12
3867: PPUSH
3868: CALL 57661 0 5
3872: GO 4246
// if i = Karamazov then
3874: LD_VAR 0 2
3878: PUSH
3879: LD_EXP 48
3883: EQUAL
3884: IFFALSE 3907
// PrepareVehicle ( ru_medium_tracked , engine_siberite , control_manual , ru_crane , 100 ) else
3886: LD_INT 22
3888: PPUSH
3889: LD_INT 3
3891: PPUSH
3892: LD_INT 1
3894: PPUSH
3895: LD_INT 52
3897: PPUSH
3898: LD_INT 100
3900: PPUSH
3901: CALL 57661 0 5
3905: GO 4246
// if i = Brown then
3907: LD_VAR 0 2
3911: PUSH
3912: LD_EXP 24
3916: EQUAL
3917: IFFALSE 3940
// PrepareVehicle ( us_medium_tracked , engine_siberite , control_manual , us_crane , 100 ) else
3919: LD_INT 3
3921: PPUSH
3922: LD_INT 3
3924: PPUSH
3925: LD_INT 1
3927: PPUSH
3928: LD_INT 13
3930: PPUSH
3931: LD_INT 100
3933: PPUSH
3934: CALL 57661 0 5
3938: GO 4246
// if uc_nation = nation_american then
3940: LD_OWVAR 21
3944: PUSH
3945: LD_INT 1
3947: EQUAL
3948: IFFALSE 4099
// begin PrepareVehicle ( [ us_medium_tracked , us_morphling , us_morphling ] [ uc_nation mod 3 + 1 ] , [ engine_combustion , engine_siberite , engine_combustion ] [ uc_nation mod 3 + 1 ] , control_manual , [ [ us_radar , us_gatling_gun , us_double_gun ] , [ us_heavy_gun , us_rocket_launcher , us_laser ] , [ us_heavy_gun , us_laser , us_cargo_bay ] ] [ uc_nation mod 3 + 1 ] [ rand ( 1 , 3 ) ] , rand ( 65 , 75 ) ) ;
3950: LD_INT 3
3952: PUSH
3953: LD_INT 5
3955: PUSH
3956: LD_INT 5
3958: PUSH
3959: EMPTY
3960: LIST
3961: LIST
3962: LIST
3963: PUSH
3964: LD_OWVAR 21
3968: PUSH
3969: LD_INT 3
3971: MOD
3972: PUSH
3973: LD_INT 1
3975: PLUS
3976: ARRAY
3977: PPUSH
3978: LD_INT 1
3980: PUSH
3981: LD_INT 3
3983: PUSH
3984: LD_INT 1
3986: PUSH
3987: EMPTY
3988: LIST
3989: LIST
3990: LIST
3991: PUSH
3992: LD_OWVAR 21
3996: PUSH
3997: LD_INT 3
3999: MOD
4000: PUSH
4001: LD_INT 1
4003: PLUS
4004: ARRAY
4005: PPUSH
4006: LD_INT 1
4008: PPUSH
4009: LD_INT 11
4011: PUSH
4012: LD_INT 4
4014: PUSH
4015: LD_INT 5
4017: PUSH
4018: EMPTY
4019: LIST
4020: LIST
4021: LIST
4022: PUSH
4023: LD_INT 6
4025: PUSH
4026: LD_INT 7
4028: PUSH
4029: LD_INT 9
4031: PUSH
4032: EMPTY
4033: LIST
4034: LIST
4035: LIST
4036: PUSH
4037: LD_INT 6
4039: PUSH
4040: LD_INT 9
4042: PUSH
4043: LD_INT 12
4045: PUSH
4046: EMPTY
4047: LIST
4048: LIST
4049: LIST
4050: PUSH
4051: EMPTY
4052: LIST
4053: LIST
4054: LIST
4055: PUSH
4056: LD_OWVAR 21
4060: PUSH
4061: LD_INT 3
4063: MOD
4064: PUSH
4065: LD_INT 1
4067: PLUS
4068: ARRAY
4069: PUSH
4070: LD_INT 1
4072: PPUSH
4073: LD_INT 3
4075: PPUSH
4076: CALL_OW 12
4080: ARRAY
4081: PPUSH
4082: LD_INT 65
4084: PPUSH
4085: LD_INT 75
4087: PPUSH
4088: CALL_OW 12
4092: PPUSH
4093: CALL 57661 0 5
// end else
4097: GO 4246
// begin PrepareVehicle ( [ ru_medium_tracked , ru_heavy_wheeled , ru_heavy_wheeled ] [ uc_nation mod 3 + 1 ] , [ engine_combustion , engine_siberite , engine_combustion ] [ uc_nation mod 3 + 1 ] , control_manual , [ [ ru_rocket_launcher , ru_gatling_gun , ru_gun ] , [ ru_heavy_gun , ru_rocket_launcher , ru_gun ] , [ ru_heavy_gun , ru_gatling_gun , ru_rocket_launcher ] ] [ uc_nation mod 3 + 1 ] [ rand ( 1 , 3 ) ] , rand ( 65 , 75 ) ) ;
4099: LD_INT 22
4101: PUSH
4102: LD_INT 23
4104: PUSH
4105: LD_INT 23
4107: PUSH
4108: EMPTY
4109: LIST
4110: LIST
4111: LIST
4112: PUSH
4113: LD_OWVAR 21
4117: PUSH
4118: LD_INT 3
4120: MOD
4121: PUSH
4122: LD_INT 1
4124: PLUS
4125: ARRAY
4126: PPUSH
4127: LD_INT 1
4129: PUSH
4130: LD_INT 3
4132: PUSH
4133: LD_INT 1
4135: PUSH
4136: EMPTY
4137: LIST
4138: LIST
4139: LIST
4140: PUSH
4141: LD_OWVAR 21
4145: PUSH
4146: LD_INT 3
4148: MOD
4149: PUSH
4150: LD_INT 1
4152: PLUS
4153: ARRAY
4154: PPUSH
4155: LD_INT 1
4157: PPUSH
4158: LD_INT 45
4160: PUSH
4161: LD_INT 43
4163: PUSH
4164: LD_INT 44
4166: PUSH
4167: EMPTY
4168: LIST
4169: LIST
4170: LIST
4171: PUSH
4172: LD_INT 46
4174: PUSH
4175: LD_INT 45
4177: PUSH
4178: LD_INT 44
4180: PUSH
4181: EMPTY
4182: LIST
4183: LIST
4184: LIST
4185: PUSH
4186: LD_INT 46
4188: PUSH
4189: LD_INT 43
4191: PUSH
4192: LD_INT 45
4194: PUSH
4195: EMPTY
4196: LIST
4197: LIST
4198: LIST
4199: PUSH
4200: EMPTY
4201: LIST
4202: LIST
4203: LIST
4204: PUSH
4205: LD_OWVAR 21
4209: PUSH
4210: LD_INT 3
4212: MOD
4213: PUSH
4214: LD_INT 1
4216: PLUS
4217: ARRAY
4218: PUSH
4219: LD_INT 1
4221: PPUSH
4222: LD_INT 3
4224: PPUSH
4225: CALL_OW 12
4229: ARRAY
4230: PPUSH
4231: LD_INT 65
4233: PPUSH
4234: LD_INT 75
4236: PPUSH
4237: CALL_OW 12
4241: PPUSH
4242: CALL 57661 0 5
// end ; veh := CreateVehicle ;
4246: LD_ADDR_VAR 0 3
4250: PUSH
4251: CALL_OW 45
4255: ST_TO_ADDR
// SetDir ( veh , 3 ) ;
4256: LD_VAR 0 3
4260: PPUSH
4261: LD_INT 3
4263: PPUSH
4264: CALL_OW 233
// PlaceUnitArea ( veh , allianceSpawnArea , false ) ;
4268: LD_VAR 0 3
4272: PPUSH
4273: LD_INT 30
4275: PPUSH
4276: LD_INT 0
4278: PPUSH
4279: CALL_OW 49
// PlaceHumanInUnit ( i , veh ) ;
4283: LD_VAR 0 2
4287: PPUSH
4288: LD_VAR 0 3
4292: PPUSH
4293: CALL_OW 52
// end ;
4297: GO 3740
4299: POP
4300: POP
// if artifactArCaptured then
4301: LD_EXP 9
4305: IFFALSE 4391
// begin uc_nation := nation_american ;
4307: LD_ADDR_OWVAR 21
4311: PUSH
4312: LD_INT 1
4314: ST_TO_ADDR
// PrepareVehicle ( us_medium_tracked , engine_siberite , control_computer , us_cargo_bay , 100 ) ;
4315: LD_INT 3
4317: PPUSH
4318: LD_INT 3
4320: PPUSH
4321: LD_INT 3
4323: PPUSH
4324: LD_INT 12
4326: PPUSH
4327: LD_INT 100
4329: PPUSH
4330: CALL 57661 0 5
// veh := CreateVehicle ;
4334: LD_ADDR_VAR 0 3
4338: PUSH
4339: CALL_OW 45
4343: ST_TO_ADDR
// SetDir ( veh , 3 ) ;
4344: LD_VAR 0 3
4348: PPUSH
4349: LD_INT 3
4351: PPUSH
4352: CALL_OW 233
// PlaceUnitXY ( veh , 198 , 22 , false ) ;
4356: LD_VAR 0 3
4360: PPUSH
4361: LD_INT 198
4363: PPUSH
4364: LD_INT 22
4366: PPUSH
4367: LD_INT 0
4369: PPUSH
4370: CALL_OW 48
// SetCargo ( veh , mat_artifact , 50 ) ;
4374: LD_VAR 0 3
4378: PPUSH
4379: LD_INT 4
4381: PPUSH
4382: LD_INT 50
4384: PPUSH
4385: CALL_OW 290
// end else
4389: GO 4410
// begin CreateResourcesXY ( mat_artifact , 267 , 226 , 5 , false ) ;
4391: LD_INT 4
4393: PPUSH
4394: LD_INT 267
4396: PPUSH
4397: LD_INT 226
4399: PPUSH
4400: LD_INT 5
4402: PPUSH
4403: LD_INT 0
4405: PPUSH
4406: CALL_OW 58
// end ; uc_nation := nation_american ;
4410: LD_ADDR_OWVAR 21
4414: PUSH
4415: LD_INT 1
4417: ST_TO_ADDR
// PrepareVehicle ( us_medium_tracked , engine_siberite , control_computer , us_cargo_bay , 100 ) ;
4418: LD_INT 3
4420: PPUSH
4421: LD_INT 3
4423: PPUSH
4424: LD_INT 3
4426: PPUSH
4427: LD_INT 12
4429: PPUSH
4430: LD_INT 100
4432: PPUSH
4433: CALL 57661 0 5
// veh := CreateVehicle ;
4437: LD_ADDR_VAR 0 3
4441: PUSH
4442: CALL_OW 45
4446: ST_TO_ADDR
// SetDir ( veh , 3 ) ;
4447: LD_VAR 0 3
4451: PPUSH
4452: LD_INT 3
4454: PPUSH
4455: CALL_OW 233
// PlaceUnitXY ( veh , 218 , 23 , false ) ;
4459: LD_VAR 0 3
4463: PPUSH
4464: LD_INT 218
4466: PPUSH
4467: LD_INT 23
4469: PPUSH
4470: LD_INT 0
4472: PPUSH
4473: CALL_OW 48
// SetCargo ( veh , mat_artifact , 30 ) ;
4477: LD_VAR 0 3
4481: PPUSH
4482: LD_INT 4
4484: PPUSH
4485: LD_INT 30
4487: PPUSH
4488: CALL_OW 290
// uc_nation := nation_russian ;
4492: LD_ADDR_OWVAR 21
4496: PUSH
4497: LD_INT 3
4499: ST_TO_ADDR
// PrepareVehicle ( ru_medium_tracked , engine_siberite , control_computer , ru_cargo_bay , 100 ) ;
4500: LD_INT 22
4502: PPUSH
4503: LD_INT 3
4505: PPUSH
4506: LD_INT 3
4508: PPUSH
4509: LD_INT 51
4511: PPUSH
4512: LD_INT 100
4514: PPUSH
4515: CALL 57661 0 5
// veh := CreateVehicle ;
4519: LD_ADDR_VAR 0 3
4523: PUSH
4524: CALL_OW 45
4528: ST_TO_ADDR
// SetDir ( veh , 3 ) ;
4529: LD_VAR 0 3
4533: PPUSH
4534: LD_INT 3
4536: PPUSH
4537: CALL_OW 233
// PlaceUnitXY ( veh , 214 , 20 , false ) ;
4541: LD_VAR 0 3
4545: PPUSH
4546: LD_INT 214
4548: PPUSH
4549: LD_INT 20
4551: PPUSH
4552: LD_INT 0
4554: PPUSH
4555: CALL_OW 48
// SetCargo ( veh , mat_artifact , 40 ) ;
4559: LD_VAR 0 3
4563: PPUSH
4564: LD_INT 4
4566: PPUSH
4567: LD_INT 40
4569: PPUSH
4570: CALL_OW 290
// end ; end_of_file
4574: LD_VAR 0 1
4578: RET
// export Powell ; export function PrepareAmerican ; var i , b , veh , cl , tmp , depot , lab , armoury , workshop ; begin
4579: LD_INT 0
4581: PPUSH
4582: PPUSH
4583: PPUSH
4584: PPUSH
4585: PPUSH
4586: PPUSH
4587: PPUSH
4588: PPUSH
4589: PPUSH
4590: PPUSH
// InitHc ;
4591: CALL_OW 19
// uc_side := 1 ;
4595: LD_ADDR_OWVAR 20
4599: PUSH
4600: LD_INT 1
4602: ST_TO_ADDR
// uc_nation := 1 ;
4603: LD_ADDR_OWVAR 21
4607: PUSH
4608: LD_INT 1
4610: ST_TO_ADDR
// for i in FilterAllUnits ( [ [ f_side , 1 ] , [ f_type , unit_building ] ] ) do
4611: LD_ADDR_VAR 0 2
4615: PUSH
4616: LD_INT 22
4618: PUSH
4619: LD_INT 1
4621: PUSH
4622: EMPTY
4623: LIST
4624: LIST
4625: PUSH
4626: LD_INT 21
4628: PUSH
4629: LD_INT 3
4631: PUSH
4632: EMPTY
4633: LIST
4634: LIST
4635: PUSH
4636: EMPTY
4637: LIST
4638: LIST
4639: PPUSH
4640: CALL_OW 69
4644: PUSH
4645: FOR_IN
4646: IFFALSE 4662
// SetBLevel ( i , 10 ) ;
4648: LD_VAR 0 2
4652: PPUSH
4653: LD_INT 10
4655: PPUSH
4656: CALL_OW 241
4660: GO 4645
4662: POP
4663: POP
// SetResourceType ( GetBase ( am_depot ) , mat_cans , 7500 ) ;
4664: LD_INT 387
4666: PPUSH
4667: CALL_OW 274
4671: PPUSH
4672: LD_INT 1
4674: PPUSH
4675: LD_INT 7500
4677: PPUSH
4678: CALL_OW 277
// SetResourceType ( GetBase ( am_depot ) , mat_oil , 4000 ) ;
4682: LD_INT 387
4684: PPUSH
4685: CALL_OW 274
4689: PPUSH
4690: LD_INT 2
4692: PPUSH
4693: LD_INT 4000
4695: PPUSH
4696: CALL_OW 277
// SetResourceType ( GetBase ( am_depot ) , mat_siberit , 50 ) ;
4700: LD_INT 387
4702: PPUSH
4703: CALL_OW 274
4707: PPUSH
4708: LD_INT 3
4710: PPUSH
4711: LD_INT 50
4713: PPUSH
4714: CALL_OW 277
// SetResourceType ( GetBase ( am_depot2 ) , mat_cans , 5500 ) ;
4718: LD_INT 476
4720: PPUSH
4721: CALL_OW 274
4725: PPUSH
4726: LD_INT 1
4728: PPUSH
4729: LD_INT 5500
4731: PPUSH
4732: CALL_OW 277
// SetResourceType ( GetBase ( am_depot2 ) , mat_oil , 4000 ) ;
4736: LD_INT 476
4738: PPUSH
4739: CALL_OW 274
4743: PPUSH
4744: LD_INT 2
4746: PPUSH
4747: LD_INT 4000
4749: PPUSH
4750: CALL_OW 277
// SetResourceType ( GetBase ( am_depot2 ) , mat_siberit , 10 ) ;
4754: LD_INT 476
4756: PPUSH
4757: CALL_OW 274
4761: PPUSH
4762: LD_INT 3
4764: PPUSH
4765: LD_INT 10
4767: PPUSH
4768: CALL_OW 277
// Powell := NewCharacter ( Powell ) ;
4772: LD_ADDR_EXP 52
4776: PUSH
4777: LD_STRING Powell
4779: PPUSH
4780: CALL_OW 25
4784: ST_TO_ADDR
// PlaceHumanInUnit ( Powell , am_depot ) ;
4785: LD_EXP 52
4789: PPUSH
4790: LD_INT 387
4792: PPUSH
4793: CALL_OW 52
// tmp := [ ] ;
4797: LD_ADDR_VAR 0 6
4801: PUSH
4802: EMPTY
4803: ST_TO_ADDR
// Lisa := PrepareUnit ( Lisa , ( not debug ) , 12p_ ) ;
4804: LD_ADDR_EXP 19
4808: PUSH
4809: LD_STRING Lisa
4811: PPUSH
4812: LD_EXP 1
4816: NOT
4817: PPUSH
4818: LD_STRING 12p_
4820: PPUSH
4821: CALL 50546 0 3
4825: ST_TO_ADDR
// if Lisa then
4826: LD_EXP 19
4830: IFFALSE 4848
// tmp := tmp ^ Lisa ;
4832: LD_ADDR_VAR 0 6
4836: PUSH
4837: LD_VAR 0 6
4841: PUSH
4842: LD_EXP 19
4846: ADD
4847: ST_TO_ADDR
// Donaldson := PrepareUnit ( Donaldson , ( not debug ) , 12p_ ) ;
4848: LD_ADDR_EXP 20
4852: PUSH
4853: LD_STRING Donaldson
4855: PPUSH
4856: LD_EXP 1
4860: NOT
4861: PPUSH
4862: LD_STRING 12p_
4864: PPUSH
4865: CALL 50546 0 3
4869: ST_TO_ADDR
// if Donaldson then
4870: LD_EXP 20
4874: IFFALSE 4892
// tmp := tmp ^ Donaldson ;
4876: LD_ADDR_VAR 0 6
4880: PUSH
4881: LD_VAR 0 6
4885: PUSH
4886: LD_EXP 20
4890: ADD
4891: ST_TO_ADDR
// Bobby := PrepareUnit ( Bobby , ( not debug ) , 12p_ ) ;
4892: LD_ADDR_EXP 21
4896: PUSH
4897: LD_STRING Bobby
4899: PPUSH
4900: LD_EXP 1
4904: NOT
4905: PPUSH
4906: LD_STRING 12p_
4908: PPUSH
4909: CALL 50546 0 3
4913: ST_TO_ADDR
// if Bobby then
4914: LD_EXP 21
4918: IFFALSE 4936
// tmp := tmp ^ Bobby ;
4920: LD_ADDR_VAR 0 6
4924: PUSH
4925: LD_VAR 0 6
4929: PUSH
4930: LD_EXP 21
4934: ADD
4935: ST_TO_ADDR
// Cyrus := PrepareUnit ( Cyrus , ( not debug ) , 12p_ ) ;
4936: LD_ADDR_EXP 22
4940: PUSH
4941: LD_STRING Cyrus
4943: PPUSH
4944: LD_EXP 1
4948: NOT
4949: PPUSH
4950: LD_STRING 12p_
4952: PPUSH
4953: CALL 50546 0 3
4957: ST_TO_ADDR
// if Cyrus then
4958: LD_EXP 22
4962: IFFALSE 4980
// tmp := tmp ^ Cyrus ;
4964: LD_ADDR_VAR 0 6
4968: PUSH
4969: LD_VAR 0 6
4973: PUSH
4974: LD_EXP 22
4978: ADD
4979: ST_TO_ADDR
// Brown := PrepareUnit ( Brown , ( not debug ) , 12p_ ) ;
4980: LD_ADDR_EXP 24
4984: PUSH
4985: LD_STRING Brown
4987: PPUSH
4988: LD_EXP 1
4992: NOT
4993: PPUSH
4994: LD_STRING 12p_
4996: PPUSH
4997: CALL 50546 0 3
5001: ST_TO_ADDR
// if Brown then
5002: LD_EXP 24
5006: IFFALSE 5024
// tmp := tmp ^ Brown ;
5008: LD_ADDR_VAR 0 6
5012: PUSH
5013: LD_VAR 0 6
5017: PUSH
5018: LD_EXP 24
5022: ADD
5023: ST_TO_ADDR
// Gladstone := PrepareUnit ( Gladstone , ( not debug ) , 12p_ ) ;
5024: LD_ADDR_EXP 25
5028: PUSH
5029: LD_STRING Gladstone
5031: PPUSH
5032: LD_EXP 1
5036: NOT
5037: PPUSH
5038: LD_STRING 12p_
5040: PPUSH
5041: CALL 50546 0 3
5045: ST_TO_ADDR
// if Gladstone then
5046: LD_EXP 25
5050: IFFALSE 5068
// tmp := tmp ^ Gladstone ;
5052: LD_ADDR_VAR 0 6
5056: PUSH
5057: LD_VAR 0 6
5061: PUSH
5062: LD_EXP 25
5066: ADD
5067: ST_TO_ADDR
// Houten := PrepareUnit ( Houten , ( not debug ) , 12p_ ) ;
5068: LD_ADDR_EXP 26
5072: PUSH
5073: LD_STRING Houten
5075: PPUSH
5076: LD_EXP 1
5080: NOT
5081: PPUSH
5082: LD_STRING 12p_
5084: PPUSH
5085: CALL 50546 0 3
5089: ST_TO_ADDR
// if Houten then
5090: LD_EXP 26
5094: IFFALSE 5112
// tmp := tmp ^ Houten ;
5096: LD_ADDR_VAR 0 6
5100: PUSH
5101: LD_VAR 0 6
5105: PUSH
5106: LD_EXP 26
5110: ADD
5111: ST_TO_ADDR
// Cornel := PrepareUnit ( Cornel , ( not debug ) , 12p_ ) ;
5112: LD_ADDR_EXP 27
5116: PUSH
5117: LD_STRING Cornel
5119: PPUSH
5120: LD_EXP 1
5124: NOT
5125: PPUSH
5126: LD_STRING 12p_
5128: PPUSH
5129: CALL 50546 0 3
5133: ST_TO_ADDR
// if Cornel then
5134: LD_EXP 27
5138: IFFALSE 5156
// tmp := tmp ^ Cornel ;
5140: LD_ADDR_VAR 0 6
5144: PUSH
5145: LD_VAR 0 6
5149: PUSH
5150: LD_EXP 27
5154: ADD
5155: ST_TO_ADDR
// Gary := PrepareUnit ( Gary , ( not debug ) , 12p_ ) ;
5156: LD_ADDR_EXP 28
5160: PUSH
5161: LD_STRING Gary
5163: PPUSH
5164: LD_EXP 1
5168: NOT
5169: PPUSH
5170: LD_STRING 12p_
5172: PPUSH
5173: CALL 50546 0 3
5177: ST_TO_ADDR
// if Gary then
5178: LD_EXP 28
5182: IFFALSE 5200
// tmp := tmp ^ Gary ;
5184: LD_ADDR_VAR 0 6
5188: PUSH
5189: LD_VAR 0 6
5193: PUSH
5194: LD_EXP 28
5198: ADD
5199: ST_TO_ADDR
// Kikuchi := PrepareUnit ( Kikuchi , ( not debug ) , 12p_ ) ;
5200: LD_ADDR_EXP 30
5204: PUSH
5205: LD_STRING Kikuchi
5207: PPUSH
5208: LD_EXP 1
5212: NOT
5213: PPUSH
5214: LD_STRING 12p_
5216: PPUSH
5217: CALL 50546 0 3
5221: ST_TO_ADDR
// if Kikuchi then
5222: LD_EXP 30
5226: IFFALSE 5244
// tmp := tmp ^ Kikuchi ;
5228: LD_ADDR_VAR 0 6
5232: PUSH
5233: LD_VAR 0 6
5237: PUSH
5238: LD_EXP 30
5242: ADD
5243: ST_TO_ADDR
// tmp := tmp union CreateCharacterSet ( 12p_others ) ;
5244: LD_ADDR_VAR 0 6
5248: PUSH
5249: LD_VAR 0 6
5253: PUSH
5254: LD_STRING 12p_others
5256: PPUSH
5257: CALL_OW 31
5261: UNION
5262: ST_TO_ADDR
// if tmp < 36 then
5263: LD_VAR 0 6
5267: PUSH
5268: LD_INT 36
5270: LESS
5271: IFFALSE 5338
// for i = 1 to 36 - tmp do
5273: LD_ADDR_VAR 0 2
5277: PUSH
5278: DOUBLE
5279: LD_INT 1
5281: DEC
5282: ST_TO_ADDR
5283: LD_INT 36
5285: PUSH
5286: LD_VAR 0 6
5290: MINUS
5291: PUSH
5292: FOR_TO
5293: IFFALSE 5336
// begin PrepareHuman ( sex_male , i mod 4 + 1 , 10 ) ;
5295: LD_INT 1
5297: PPUSH
5298: LD_VAR 0 2
5302: PUSH
5303: LD_INT 4
5305: MOD
5306: PUSH
5307: LD_INT 1
5309: PLUS
5310: PPUSH
5311: LD_INT 10
5313: PPUSH
5314: CALL_OW 380
// tmp := tmp ^ CreateHuman ;
5318: LD_ADDR_VAR 0 6
5322: PUSH
5323: LD_VAR 0 6
5327: PUSH
5328: CALL_OW 44
5332: ADD
5333: ST_TO_ADDR
// end ;
5334: GO 5292
5336: POP
5337: POP
// for i in tmp do
5338: LD_ADDR_VAR 0 2
5342: PUSH
5343: LD_VAR 0 6
5347: PUSH
5348: FOR_IN
5349: IFFALSE 5374
// PlaceUnitXYR ( i , 62 , 93 , 9 , false ) ;
5351: LD_VAR 0 2
5355: PPUSH
5356: LD_INT 62
5358: PPUSH
5359: LD_INT 93
5361: PPUSH
5362: LD_INT 9
5364: PPUSH
5365: LD_INT 0
5367: PPUSH
5368: CALL_OW 50
5372: GO 5348
5374: POP
5375: POP
// mc_bases := Replace ( mc_bases , 4 , FilterAllUnits ( [ f_side , 1 ] ) diff Powell ) ;
5376: LD_ADDR_EXP 79
5380: PUSH
5381: LD_EXP 79
5385: PPUSH
5386: LD_INT 4
5388: PPUSH
5389: LD_INT 22
5391: PUSH
5392: LD_INT 1
5394: PUSH
5395: EMPTY
5396: LIST
5397: LIST
5398: PPUSH
5399: CALL_OW 69
5403: PUSH
5404: LD_EXP 52
5408: DIFF
5409: PPUSH
5410: CALL_OW 1
5414: ST_TO_ADDR
// uc_side := 0 ;
5415: LD_ADDR_OWVAR 20
5419: PUSH
5420: LD_INT 0
5422: ST_TO_ADDR
// uc_nation := 0 ;
5423: LD_ADDR_OWVAR 21
5427: PUSH
5428: LD_INT 0
5430: ST_TO_ADDR
// for i = 1 to 4 do
5431: LD_ADDR_VAR 0 2
5435: PUSH
5436: DOUBLE
5437: LD_INT 1
5439: DEC
5440: ST_TO_ADDR
5441: LD_INT 4
5443: PUSH
5444: FOR_TO
5445: IFFALSE 5476
// begin InitHc ;
5447: CALL_OW 19
// hc_class := class_apeman ;
5451: LD_ADDR_OWVAR 28
5455: PUSH
5456: LD_INT 12
5458: ST_TO_ADDR
// PlaceUnitArea ( CreateHuman , powellApe , false ) ;
5459: CALL_OW 44
5463: PPUSH
5464: LD_INT 11
5466: PPUSH
5467: LD_INT 0
5469: PPUSH
5470: CALL_OW 49
// end ;
5474: GO 5444
5476: POP
5477: POP
// end ;
5478: LD_VAR 0 1
5482: RET
// every 11 11$30 trigger not americanDestroyed and not MC_GetVehicles ( 4 , true ) do var i , tmp , target ;
5483: LD_EXP 4
5487: NOT
5488: PUSH
5489: LD_INT 4
5491: PPUSH
5492: LD_INT 1
5494: PPUSH
5495: CALL 45620 0 2
5499: NOT
5500: AND
5501: IFFALSE 6273
5503: GO 5505
5505: DISABLE
5506: LD_INT 0
5508: PPUSH
5509: PPUSH
5510: PPUSH
// begin enable ;
5511: ENABLE
// if not FilterAllUnits ( [ [ f_side , 1 ] , [ f_nation , 1 ] , [ f_btype , b_factory ] ] ) then
5512: LD_INT 22
5514: PUSH
5515: LD_INT 1
5517: PUSH
5518: EMPTY
5519: LIST
5520: LIST
5521: PUSH
5522: LD_INT 23
5524: PUSH
5525: LD_INT 1
5527: PUSH
5528: EMPTY
5529: LIST
5530: LIST
5531: PUSH
5532: LD_INT 30
5534: PUSH
5535: LD_INT 3
5537: PUSH
5538: EMPTY
5539: LIST
5540: LIST
5541: PUSH
5542: EMPTY
5543: LIST
5544: LIST
5545: LIST
5546: PPUSH
5547: CALL_OW 69
5551: NOT
5552: IFFALSE 5556
// exit ;
5554: GO 6273
// if Prob ( 40 ) then
5556: LD_INT 40
5558: PPUSH
5559: CALL_OW 13
5563: IFFALSE 5690
// begin MC_InsertProduceList ( 4 , [ [ us_morphling , engine_combustion , control_remote , us_rocket_launcher ] , [ us_morphling , engine_combustion , control_remote , us_rocket_launcher ] , [ us_morphling , engine_combustion , control_remote , us_rocket_launcher ] , [ us_morphling , engine_combustion , control_remote , us_heavy_gun ] , [ us_morphling , engine_combustion , control_remote , us_heavy_gun ] , [ us_morphling , engine_combustion , control_remote , us_heavy_gun ] , ] ) ;
5565: LD_INT 4
5567: PPUSH
5568: LD_INT 5
5570: PUSH
5571: LD_INT 1
5573: PUSH
5574: LD_INT 2
5576: PUSH
5577: LD_INT 7
5579: PUSH
5580: EMPTY
5581: LIST
5582: LIST
5583: LIST
5584: LIST
5585: PUSH
5586: LD_INT 5
5588: PUSH
5589: LD_INT 1
5591: PUSH
5592: LD_INT 2
5594: PUSH
5595: LD_INT 7
5597: PUSH
5598: EMPTY
5599: LIST
5600: LIST
5601: LIST
5602: LIST
5603: PUSH
5604: LD_INT 5
5606: PUSH
5607: LD_INT 1
5609: PUSH
5610: LD_INT 2
5612: PUSH
5613: LD_INT 7
5615: PUSH
5616: EMPTY
5617: LIST
5618: LIST
5619: LIST
5620: LIST
5621: PUSH
5622: LD_INT 5
5624: PUSH
5625: LD_INT 1
5627: PUSH
5628: LD_INT 2
5630: PUSH
5631: LD_INT 6
5633: PUSH
5634: EMPTY
5635: LIST
5636: LIST
5637: LIST
5638: LIST
5639: PUSH
5640: LD_INT 5
5642: PUSH
5643: LD_INT 1
5645: PUSH
5646: LD_INT 2
5648: PUSH
5649: LD_INT 6
5651: PUSH
5652: EMPTY
5653: LIST
5654: LIST
5655: LIST
5656: LIST
5657: PUSH
5658: LD_INT 5
5660: PUSH
5661: LD_INT 1
5663: PUSH
5664: LD_INT 2
5666: PUSH
5667: LD_INT 6
5669: PUSH
5670: EMPTY
5671: LIST
5672: LIST
5673: LIST
5674: LIST
5675: PUSH
5676: EMPTY
5677: LIST
5678: LIST
5679: LIST
5680: LIST
5681: LIST
5682: LIST
5683: PPUSH
5684: CALL 44202 0 2
// end else
5688: GO 5813
// begin MC_InsertProduceList ( 4 , [ [ us_morphling , engine_combustion , control_remote , us_rocket_launcher ] , [ us_morphling , engine_combustion , control_remote , us_laser ] , [ us_morphling , engine_combustion , control_remote , us_laser ] , [ us_morphling , engine_combustion , control_remote , us_heavy_gun ] , [ us_morphling , engine_combustion , control_remote , us_heavy_gun ] , [ us_morphling , engine_combustion , control_remote , us_heavy_gun ] , ] ) ;
5690: LD_INT 4
5692: PPUSH
5693: LD_INT 5
5695: PUSH
5696: LD_INT 1
5698: PUSH
5699: LD_INT 2
5701: PUSH
5702: LD_INT 7
5704: PUSH
5705: EMPTY
5706: LIST
5707: LIST
5708: LIST
5709: LIST
5710: PUSH
5711: LD_INT 5
5713: PUSH
5714: LD_INT 1
5716: PUSH
5717: LD_INT 2
5719: PUSH
5720: LD_INT 9
5722: PUSH
5723: EMPTY
5724: LIST
5725: LIST
5726: LIST
5727: LIST
5728: PUSH
5729: LD_INT 5
5731: PUSH
5732: LD_INT 1
5734: PUSH
5735: LD_INT 2
5737: PUSH
5738: LD_INT 9
5740: PUSH
5741: EMPTY
5742: LIST
5743: LIST
5744: LIST
5745: LIST
5746: PUSH
5747: LD_INT 5
5749: PUSH
5750: LD_INT 1
5752: PUSH
5753: LD_INT 2
5755: PUSH
5756: LD_INT 6
5758: PUSH
5759: EMPTY
5760: LIST
5761: LIST
5762: LIST
5763: LIST
5764: PUSH
5765: LD_INT 5
5767: PUSH
5768: LD_INT 1
5770: PUSH
5771: LD_INT 2
5773: PUSH
5774: LD_INT 6
5776: PUSH
5777: EMPTY
5778: LIST
5779: LIST
5780: LIST
5781: LIST
5782: PUSH
5783: LD_INT 5
5785: PUSH
5786: LD_INT 1
5788: PUSH
5789: LD_INT 2
5791: PUSH
5792: LD_INT 6
5794: PUSH
5795: EMPTY
5796: LIST
5797: LIST
5798: LIST
5799: LIST
5800: PUSH
5801: EMPTY
5802: LIST
5803: LIST
5804: LIST
5805: LIST
5806: LIST
5807: LIST
5808: PPUSH
5809: CALL 44202 0 2
// end ; repeat wait ( 0 0$1 ) ;
5813: LD_INT 35
5815: PPUSH
5816: CALL_OW 67
// until MC_GetVehicles ( 4 , true ) >= 6 ;
5820: LD_INT 4
5822: PPUSH
5823: LD_INT 1
5825: PPUSH
5826: CALL 45620 0 2
5830: PUSH
5831: LD_INT 6
5833: GREATEREQUAL
5834: IFFALSE 5813
// wait ( 0 0$30 ) ;
5836: LD_INT 1050
5838: PPUSH
5839: CALL_OW 67
// tmp := MC_GetVehicles ( 4 , true ) ;
5843: LD_ADDR_VAR 0 2
5847: PUSH
5848: LD_INT 4
5850: PPUSH
5851: LD_INT 1
5853: PPUSH
5854: CALL 45620 0 2
5858: ST_TO_ADDR
// mc_vehicles := Replace ( mc_vehicles , 4 , mc_vehicles [ 4 ] diff tmp ) ;
5859: LD_ADDR_EXP 98
5863: PUSH
5864: LD_EXP 98
5868: PPUSH
5869: LD_INT 4
5871: PPUSH
5872: LD_EXP 98
5876: PUSH
5877: LD_INT 4
5879: ARRAY
5880: PUSH
5881: LD_VAR 0 2
5885: DIFF
5886: PPUSH
5887: CALL_OW 1
5891: ST_TO_ADDR
// target := rand ( 0 , 2 ) ;
5892: LD_ADDR_VAR 0 3
5896: PUSH
5897: LD_INT 0
5899: PPUSH
5900: LD_INT 2
5902: PPUSH
5903: CALL_OW 12
5907: ST_TO_ADDR
// if target then
5908: LD_VAR 0 3
5912: IFFALSE 6040
// begin repeat tmp := UnitFilter ( tmp , [ f_lives , 250 ] ) ;
5914: LD_ADDR_VAR 0 2
5918: PUSH
5919: LD_VAR 0 2
5923: PPUSH
5924: LD_INT 24
5926: PUSH
5927: LD_INT 250
5929: PUSH
5930: EMPTY
5931: LIST
5932: LIST
5933: PPUSH
5934: CALL_OW 72
5938: ST_TO_ADDR
// for i in tmp do
5939: LD_ADDR_VAR 0 1
5943: PUSH
5944: LD_VAR 0 2
5948: PUSH
5949: FOR_IN
5950: IFFALSE 5990
// if GetDistUnitXY ( i , 114 , 108 ) > 9 then
5952: LD_VAR 0 1
5956: PPUSH
5957: LD_INT 114
5959: PPUSH
5960: LD_INT 108
5962: PPUSH
5963: CALL_OW 297
5967: PUSH
5968: LD_INT 9
5970: GREATER
5971: IFFALSE 5988
// ComMoveXY ( i , 114 , 108 ) ;
5973: LD_VAR 0 1
5977: PPUSH
5978: LD_INT 114
5980: PPUSH
5981: LD_INT 108
5983: PPUSH
5984: CALL_OW 111
5988: GO 5949
5990: POP
5991: POP
// wait ( 0 0$1 ) ;
5992: LD_INT 35
5994: PPUSH
5995: CALL_OW 67
// until UnitFilter ( tmp , [ f_distxy , 114 , 108 , 9 ] ) >= ( tmp - 1 ) ;
5999: LD_VAR 0 2
6003: PPUSH
6004: LD_INT 92
6006: PUSH
6007: LD_INT 114
6009: PUSH
6010: LD_INT 108
6012: PUSH
6013: LD_INT 9
6015: PUSH
6016: EMPTY
6017: LIST
6018: LIST
6019: LIST
6020: LIST
6021: PPUSH
6022: CALL_OW 72
6026: PUSH
6027: LD_VAR 0 2
6031: PUSH
6032: LD_INT 1
6034: MINUS
6035: GREATEREQUAL
6036: IFFALSE 5914
// end else
6038: GO 6164
// begin repeat tmp := UnitFilter ( tmp , [ f_lives , 250 ] ) ;
6040: LD_ADDR_VAR 0 2
6044: PUSH
6045: LD_VAR 0 2
6049: PPUSH
6050: LD_INT 24
6052: PUSH
6053: LD_INT 250
6055: PUSH
6056: EMPTY
6057: LIST
6058: LIST
6059: PPUSH
6060: CALL_OW 72
6064: ST_TO_ADDR
// for i in tmp do
6065: LD_ADDR_VAR 0 1
6069: PUSH
6070: LD_VAR 0 2
6074: PUSH
6075: FOR_IN
6076: IFFALSE 6116
// if GetDistUnitXY ( i , 129 , 139 ) > 9 then
6078: LD_VAR 0 1
6082: PPUSH
6083: LD_INT 129
6085: PPUSH
6086: LD_INT 139
6088: PPUSH
6089: CALL_OW 297
6093: PUSH
6094: LD_INT 9
6096: GREATER
6097: IFFALSE 6114
// ComMoveXY ( i , 129 , 139 ) ;
6099: LD_VAR 0 1
6103: PPUSH
6104: LD_INT 129
6106: PPUSH
6107: LD_INT 139
6109: PPUSH
6110: CALL_OW 111
6114: GO 6075
6116: POP
6117: POP
// wait ( 0 0$1 ) ;
6118: LD_INT 35
6120: PPUSH
6121: CALL_OW 67
// until UnitFilter ( tmp , [ f_distxy , 129 , 139 , 9 ] ) >= ( tmp - 1 ) ;
6125: LD_VAR 0 2
6129: PPUSH
6130: LD_INT 92
6132: PUSH
6133: LD_INT 129
6135: PUSH
6136: LD_INT 139
6138: PUSH
6139: LD_INT 9
6141: PUSH
6142: EMPTY
6143: LIST
6144: LIST
6145: LIST
6146: LIST
6147: PPUSH
6148: CALL_OW 72
6152: PUSH
6153: LD_VAR 0 2
6157: PUSH
6158: LD_INT 1
6160: MINUS
6161: GREATEREQUAL
6162: IFFALSE 6040
// end ; repeat wait ( 0 0$1 ) ;
6164: LD_INT 35
6166: PPUSH
6167: CALL_OW 67
// for i in tmp do
6171: LD_ADDR_VAR 0 1
6175: PUSH
6176: LD_VAR 0 2
6180: PUSH
6181: FOR_IN
6182: IFFALSE 6264
// begin if GetLives ( i ) > 251 then
6184: LD_VAR 0 1
6188: PPUSH
6189: CALL_OW 256
6193: PUSH
6194: LD_INT 251
6196: GREATER
6197: IFFALSE 6235
// ComAttackUnit ( i , NearestUnitToUnit ( FilterAllUnits ( [ f_enemy , 1 ] ) , i ) ) else
6199: LD_VAR 0 1
6203: PPUSH
6204: LD_INT 81
6206: PUSH
6207: LD_INT 1
6209: PUSH
6210: EMPTY
6211: LIST
6212: LIST
6213: PPUSH
6214: CALL_OW 69
6218: PPUSH
6219: LD_VAR 0 1
6223: PPUSH
6224: CALL_OW 74
6228: PPUSH
6229: CALL_OW 115
6233: GO 6262
// if IsDead ( i ) then
6235: LD_VAR 0 1
6239: PPUSH
6240: CALL_OW 301
6244: IFFALSE 6262
// tmp := tmp diff i ;
6246: LD_ADDR_VAR 0 2
6250: PUSH
6251: LD_VAR 0 2
6255: PUSH
6256: LD_VAR 0 1
6260: DIFF
6261: ST_TO_ADDR
// end ;
6262: GO 6181
6264: POP
6265: POP
// until not tmp ;
6266: LD_VAR 0 2
6270: NOT
6271: IFFALSE 6164
// end ;
6273: PPOPN 3
6275: END
// every 30 30$00 trigger not americanDestroyed do
6276: LD_EXP 4
6280: NOT
6281: IFFALSE 6346
6283: GO 6285
6285: DISABLE
// begin wait ( [ 30 30$00 , 20 20$00 , 10 10$00 ] [ Difficulty ] ) ;
6286: LD_INT 63000
6288: PUSH
6289: LD_INT 42000
6291: PUSH
6292: LD_INT 21000
6294: PUSH
6295: EMPTY
6296: LIST
6297: LIST
6298: LIST
6299: PUSH
6300: LD_OWVAR 67
6304: ARRAY
6305: PPUSH
6306: CALL_OW 67
// if americanDestroyed then
6310: LD_EXP 4
6314: IFFALSE 6318
// exit ;
6316: GO 6346
// MC_InsertProduceList ( 4 , [ [ us_morphling , engine_siberite , control_manual , us_siberium_rocket ] ] ) ;
6318: LD_INT 4
6320: PPUSH
6321: LD_INT 5
6323: PUSH
6324: LD_INT 3
6326: PUSH
6327: LD_INT 1
6329: PUSH
6330: LD_INT 8
6332: PUSH
6333: EMPTY
6334: LIST
6335: LIST
6336: LIST
6337: LIST
6338: PUSH
6339: EMPTY
6340: LIST
6341: PPUSH
6342: CALL 44202 0 2
// end ; end_of_file
6346: END
// export function PrepareArabian ; var i , un , tmp , side ; begin
6347: LD_INT 0
6349: PPUSH
6350: PPUSH
6351: PPUSH
6352: PPUSH
6353: PPUSH
// side := 2 ;
6354: LD_ADDR_VAR 0 5
6358: PUSH
6359: LD_INT 2
6361: ST_TO_ADDR
// InitHc ;
6362: CALL_OW 19
// uc_side := side ;
6366: LD_ADDR_OWVAR 20
6370: PUSH
6371: LD_VAR 0 5
6375: ST_TO_ADDR
// uc_nation := 2 ;
6376: LD_ADDR_OWVAR 21
6380: PUSH
6381: LD_INT 2
6383: ST_TO_ADDR
// for i in FilterAllUnits ( [ [ f_side , 2 ] , [ f_type , unit_building ] ] ) do
6384: LD_ADDR_VAR 0 2
6388: PUSH
6389: LD_INT 22
6391: PUSH
6392: LD_INT 2
6394: PUSH
6395: EMPTY
6396: LIST
6397: LIST
6398: PUSH
6399: LD_INT 21
6401: PUSH
6402: LD_INT 3
6404: PUSH
6405: EMPTY
6406: LIST
6407: LIST
6408: PUSH
6409: EMPTY
6410: LIST
6411: LIST
6412: PPUSH
6413: CALL_OW 69
6417: PUSH
6418: FOR_IN
6419: IFFALSE 6435
// SetBLevel ( i , 10 ) ;
6421: LD_VAR 0 2
6425: PPUSH
6426: LD_INT 10
6428: PPUSH
6429: CALL_OW 241
6433: GO 6418
6435: POP
6436: POP
// tmp := FilterAllUnits ( [ [ f_side , side ] , [ f_btype , b_bunker ] , [ f_empty ] ] ) ;
6437: LD_ADDR_VAR 0 4
6441: PUSH
6442: LD_INT 22
6444: PUSH
6445: LD_VAR 0 5
6449: PUSH
6450: EMPTY
6451: LIST
6452: LIST
6453: PUSH
6454: LD_INT 30
6456: PUSH
6457: LD_INT 32
6459: PUSH
6460: EMPTY
6461: LIST
6462: LIST
6463: PUSH
6464: LD_INT 58
6466: PUSH
6467: EMPTY
6468: LIST
6469: PUSH
6470: EMPTY
6471: LIST
6472: LIST
6473: LIST
6474: PPUSH
6475: CALL_OW 69
6479: ST_TO_ADDR
// for i = 1 to 10 do
6480: LD_ADDR_VAR 0 2
6484: PUSH
6485: DOUBLE
6486: LD_INT 1
6488: DEC
6489: ST_TO_ADDR
6490: LD_INT 10
6492: PUSH
6493: FOR_TO
6494: IFFALSE 6566
// begin uc_nation := nation_nature ;
6496: LD_ADDR_OWVAR 21
6500: PUSH
6501: LD_INT 0
6503: ST_TO_ADDR
// hc_class := class_apeman_soldier ;
6504: LD_ADDR_OWVAR 28
6508: PUSH
6509: LD_INT 15
6511: ST_TO_ADDR
// hc_gallery :=  ;
6512: LD_ADDR_OWVAR 33
6516: PUSH
6517: LD_STRING 
6519: ST_TO_ADDR
// hc_name :=  ;
6520: LD_ADDR_OWVAR 26
6524: PUSH
6525: LD_STRING 
6527: ST_TO_ADDR
// un := CreateHuman ;
6528: LD_ADDR_VAR 0 3
6532: PUSH
6533: CALL_OW 44
6537: ST_TO_ADDR
// PlaceHumanInUnit ( un , tmp [ tmp - i ] ) ;
6538: LD_VAR 0 3
6542: PPUSH
6543: LD_VAR 0 4
6547: PUSH
6548: LD_VAR 0 4
6552: PUSH
6553: LD_VAR 0 2
6557: MINUS
6558: ARRAY
6559: PPUSH
6560: CALL_OW 52
// end ;
6564: GO 6493
6566: POP
6567: POP
// PrepareBase ( ar_depot , arabianBaseArea ,  , [ 8 , 9 , 10 ] [ Difficulty ] , [ 3000 , 500 , 150 ] , [ 16 , 6 , 6 , 6 ] ) ;
6568: LD_INT 503
6570: PPUSH
6571: LD_INT 27
6573: PPUSH
6574: LD_STRING 
6576: PPUSH
6577: LD_INT 8
6579: PUSH
6580: LD_INT 9
6582: PUSH
6583: LD_INT 10
6585: PUSH
6586: EMPTY
6587: LIST
6588: LIST
6589: LIST
6590: PUSH
6591: LD_OWVAR 67
6595: ARRAY
6596: PPUSH
6597: LD_INT 3000
6599: PUSH
6600: LD_INT 500
6602: PUSH
6603: LD_INT 150
6605: PUSH
6606: EMPTY
6607: LIST
6608: LIST
6609: LIST
6610: PPUSH
6611: LD_INT 16
6613: PUSH
6614: LD_INT 6
6616: PUSH
6617: LD_INT 6
6619: PUSH
6620: LD_INT 6
6622: PUSH
6623: EMPTY
6624: LIST
6625: LIST
6626: LIST
6627: LIST
6628: PPUSH
6629: CALL 61070 0 6
// mc_bases := Replace ( mc_bases , 1 , FilterAllUnits ( [ [ f_side , side ] , [ f_nation , 2 ] , [ f_not , [ f_type , unit_vehicle ] ] ] ) ) ;
6633: LD_ADDR_EXP 79
6637: PUSH
6638: LD_EXP 79
6642: PPUSH
6643: LD_INT 1
6645: PPUSH
6646: LD_INT 22
6648: PUSH
6649: LD_VAR 0 5
6653: PUSH
6654: EMPTY
6655: LIST
6656: LIST
6657: PUSH
6658: LD_INT 23
6660: PUSH
6661: LD_INT 2
6663: PUSH
6664: EMPTY
6665: LIST
6666: LIST
6667: PUSH
6668: LD_INT 3
6670: PUSH
6671: LD_INT 21
6673: PUSH
6674: LD_INT 2
6676: PUSH
6677: EMPTY
6678: LIST
6679: LIST
6680: PUSH
6681: EMPTY
6682: LIST
6683: LIST
6684: PUSH
6685: EMPTY
6686: LIST
6687: LIST
6688: LIST
6689: PPUSH
6690: CALL_OW 69
6694: PPUSH
6695: CALL_OW 1
6699: ST_TO_ADDR
// end ;
6700: LD_VAR 0 1
6704: RET
// export Omar ; export function PrepareOmarAli ; begin
6705: LD_INT 0
6707: PPUSH
// uc_side := 5 ;
6708: LD_ADDR_OWVAR 20
6712: PUSH
6713: LD_INT 5
6715: ST_TO_ADDR
// uc_nation := 2 ;
6716: LD_ADDR_OWVAR 21
6720: PUSH
6721: LD_INT 2
6723: ST_TO_ADDR
// Omar := NewCharacter ( Omar ) ;
6724: LD_ADDR_EXP 53
6728: PUSH
6729: LD_STRING Omar
6731: PPUSH
6732: CALL_OW 25
6736: ST_TO_ADDR
// PlaceUnitXY ( Omar , 330 , 244 , false ) ;
6737: LD_EXP 53
6741: PPUSH
6742: LD_INT 330
6744: PPUSH
6745: LD_INT 244
6747: PPUSH
6748: LD_INT 0
6750: PPUSH
6751: CALL_OW 48
// ComMoveXY ( Omar , 252 , 220 ) ;
6755: LD_EXP 53
6759: PPUSH
6760: LD_INT 252
6762: PPUSH
6763: LD_INT 220
6765: PPUSH
6766: CALL_OW 111
// end ; end_of_file
6770: LD_VAR 0 1
6774: RET
// export Schulz , Kozlov ; export function PrepareLegion ; var i , side , un , tmp ; begin
6775: LD_INT 0
6777: PPUSH
6778: PPUSH
6779: PPUSH
6780: PPUSH
6781: PPUSH
// side := 8 ;
6782: LD_ADDR_VAR 0 3
6786: PUSH
6787: LD_INT 8
6789: ST_TO_ADDR
// InitHc ;
6790: CALL_OW 19
// uc_side := side ;
6794: LD_ADDR_OWVAR 20
6798: PUSH
6799: LD_VAR 0 3
6803: ST_TO_ADDR
// uc_nation := 2 ;
6804: LD_ADDR_OWVAR 21
6808: PUSH
6809: LD_INT 2
6811: ST_TO_ADDR
// for i in FilterAllUnits ( [ [ f_side , side ] , [ f_type , unit_building ] ] ) do
6812: LD_ADDR_VAR 0 2
6816: PUSH
6817: LD_INT 22
6819: PUSH
6820: LD_VAR 0 3
6824: PUSH
6825: EMPTY
6826: LIST
6827: LIST
6828: PUSH
6829: LD_INT 21
6831: PUSH
6832: LD_INT 3
6834: PUSH
6835: EMPTY
6836: LIST
6837: LIST
6838: PUSH
6839: EMPTY
6840: LIST
6841: LIST
6842: PPUSH
6843: CALL_OW 69
6847: PUSH
6848: FOR_IN
6849: IFFALSE 6865
// SetBLevel ( i , 10 ) ;
6851: LD_VAR 0 2
6855: PPUSH
6856: LD_INT 10
6858: PPUSH
6859: CALL_OW 241
6863: GO 6848
6865: POP
6866: POP
// Schulz := NewCharacter ( Schulz ) ;
6867: LD_ADDR_EXP 54
6871: PUSH
6872: LD_STRING Schulz
6874: PPUSH
6875: CALL_OW 25
6879: ST_TO_ADDR
// Kozlov := PrepareUnit ( Kozlov , false ,  ) ;
6880: LD_ADDR_EXP 55
6884: PUSH
6885: LD_STRING Kozlov
6887: PPUSH
6888: LD_INT 0
6890: PPUSH
6891: LD_STRING 
6893: PPUSH
6894: CALL 50546 0 3
6898: ST_TO_ADDR
// PlaceHumanInUnit ( Kozlov , FilterAllUnits ( [ [ f_side , 8 ] , [ f_nation , 3 ] , [ f_btype , b_lab_full ] ] ) [ 1 ] ) ;
6899: LD_EXP 55
6903: PPUSH
6904: LD_INT 22
6906: PUSH
6907: LD_INT 8
6909: PUSH
6910: EMPTY
6911: LIST
6912: LIST
6913: PUSH
6914: LD_INT 23
6916: PUSH
6917: LD_INT 3
6919: PUSH
6920: EMPTY
6921: LIST
6922: LIST
6923: PUSH
6924: LD_INT 30
6926: PUSH
6927: LD_INT 8
6929: PUSH
6930: EMPTY
6931: LIST
6932: LIST
6933: PUSH
6934: EMPTY
6935: LIST
6936: LIST
6937: LIST
6938: PPUSH
6939: CALL_OW 69
6943: PUSH
6944: LD_INT 1
6946: ARRAY
6947: PPUSH
6948: CALL_OW 52
// SetSkill ( Kozlov , class_mechanic , 10 ) ;
6952: LD_EXP 55
6956: PPUSH
6957: LD_INT 3
6959: PPUSH
6960: LD_INT 10
6962: PPUSH
6963: CALL_OW 237
// tmp := FilterAllUnits ( [ [ f_side , side ] , [ f_btype , b_bunker ] , [ f_empty ] ] ) ;
6967: LD_ADDR_VAR 0 5
6971: PUSH
6972: LD_INT 22
6974: PUSH
6975: LD_VAR 0 3
6979: PUSH
6980: EMPTY
6981: LIST
6982: LIST
6983: PUSH
6984: LD_INT 30
6986: PUSH
6987: LD_INT 32
6989: PUSH
6990: EMPTY
6991: LIST
6992: LIST
6993: PUSH
6994: LD_INT 58
6996: PUSH
6997: EMPTY
6998: LIST
6999: PUSH
7000: EMPTY
7001: LIST
7002: LIST
7003: LIST
7004: PPUSH
7005: CALL_OW 69
7009: ST_TO_ADDR
// for i = 1 to 10 do
7010: LD_ADDR_VAR 0 2
7014: PUSH
7015: DOUBLE
7016: LD_INT 1
7018: DEC
7019: ST_TO_ADDR
7020: LD_INT 10
7022: PUSH
7023: FOR_TO
7024: IFFALSE 7096
// begin uc_nation := nation_nature ;
7026: LD_ADDR_OWVAR 21
7030: PUSH
7031: LD_INT 0
7033: ST_TO_ADDR
// hc_class := class_apeman_soldier ;
7034: LD_ADDR_OWVAR 28
7038: PUSH
7039: LD_INT 15
7041: ST_TO_ADDR
// hc_gallery :=  ;
7042: LD_ADDR_OWVAR 33
7046: PUSH
7047: LD_STRING 
7049: ST_TO_ADDR
// hc_name :=  ;
7050: LD_ADDR_OWVAR 26
7054: PUSH
7055: LD_STRING 
7057: ST_TO_ADDR
// un := CreateHuman ;
7058: LD_ADDR_VAR 0 4
7062: PUSH
7063: CALL_OW 44
7067: ST_TO_ADDR
// PlaceHumanInUnit ( un , tmp [ tmp - i ] ) ;
7068: LD_VAR 0 4
7072: PPUSH
7073: LD_VAR 0 5
7077: PUSH
7078: LD_VAR 0 5
7082: PUSH
7083: LD_VAR 0 2
7087: MINUS
7088: ARRAY
7089: PPUSH
7090: CALL_OW 52
// end ;
7094: GO 7023
7096: POP
7097: POP
// PrepareBase ( ar_depot1 , legionBaseArea ,  , [ 8 , 9 , 10 ] [ Difficulty ] , [ 3000 , 500 , 150 ] , [ 16 , 6 , 6 , 8 ] ) ;
7098: LD_INT 324
7100: PPUSH
7101: LD_INT 3
7103: PPUSH
7104: LD_STRING 
7106: PPUSH
7107: LD_INT 8
7109: PUSH
7110: LD_INT 9
7112: PUSH
7113: LD_INT 10
7115: PUSH
7116: EMPTY
7117: LIST
7118: LIST
7119: LIST
7120: PUSH
7121: LD_OWVAR 67
7125: ARRAY
7126: PPUSH
7127: LD_INT 3000
7129: PUSH
7130: LD_INT 500
7132: PUSH
7133: LD_INT 150
7135: PUSH
7136: EMPTY
7137: LIST
7138: LIST
7139: LIST
7140: PPUSH
7141: LD_INT 16
7143: PUSH
7144: LD_INT 6
7146: PUSH
7147: LD_INT 6
7149: PUSH
7150: LD_INT 8
7152: PUSH
7153: EMPTY
7154: LIST
7155: LIST
7156: LIST
7157: LIST
7158: PPUSH
7159: CALL 61070 0 6
// mc_bases := Replace ( mc_bases , 3 , FilterAllUnits ( [ [ f_side , side ] , [ f_nation , 2 ] , [ f_not , [ f_type , unit_vehicle ] ] ] ) diff Schulz ) ;
7163: LD_ADDR_EXP 79
7167: PUSH
7168: LD_EXP 79
7172: PPUSH
7173: LD_INT 3
7175: PPUSH
7176: LD_INT 22
7178: PUSH
7179: LD_VAR 0 3
7183: PUSH
7184: EMPTY
7185: LIST
7186: LIST
7187: PUSH
7188: LD_INT 23
7190: PUSH
7191: LD_INT 2
7193: PUSH
7194: EMPTY
7195: LIST
7196: LIST
7197: PUSH
7198: LD_INT 3
7200: PUSH
7201: LD_INT 21
7203: PUSH
7204: LD_INT 2
7206: PUSH
7207: EMPTY
7208: LIST
7209: LIST
7210: PUSH
7211: EMPTY
7212: LIST
7213: LIST
7214: PUSH
7215: EMPTY
7216: LIST
7217: LIST
7218: LIST
7219: PPUSH
7220: CALL_OW 69
7224: PUSH
7225: LD_EXP 54
7229: DIFF
7230: PPUSH
7231: CALL_OW 1
7235: ST_TO_ADDR
// end ;
7236: LD_VAR 0 1
7240: RET
// export function BuildKozlovBomb ; begin
7241: LD_INT 0
7243: PPUSH
// if not IsOk ( kozlov_fac ) or not IsOk ( kozlov_lab ) then
7244: LD_INT 332
7246: PPUSH
7247: CALL_OW 302
7251: NOT
7252: PUSH
7253: LD_INT 336
7255: PPUSH
7256: CALL_OW 302
7260: NOT
7261: OR
7262: IFFALSE 7266
// exit ;
7264: GO 7363
// ComChangeProfession ( Kozlov , 4 ) ;
7266: LD_EXP 55
7270: PPUSH
7271: LD_INT 4
7273: PPUSH
7274: CALL_OW 123
// ComResearch ( kozlov_lab , tech_sibFiss ) ;
7278: LD_INT 336
7280: PPUSH
7281: LD_INT 25
7283: PPUSH
7284: CALL_OW 124
// repeat wait ( 0 0$1 ) ;
7288: LD_INT 35
7290: PPUSH
7291: CALL_OW 67
// until GetTech ( tech_sibFiss , 8 ) = state_researched ;
7295: LD_INT 25
7297: PPUSH
7298: LD_INT 8
7300: PPUSH
7301: CALL_OW 321
7305: PUSH
7306: LD_INT 2
7308: EQUAL
7309: IFFALSE 7288
// ComExitBuilding ( Kozlov ) ;
7311: LD_EXP 55
7315: PPUSH
7316: CALL_OW 122
// AddComEnterUnit ( Kozlov , kozlov_fac ) ;
7320: LD_EXP 55
7324: PPUSH
7325: LD_INT 332
7327: PPUSH
7328: CALL_OW 180
// AddComChangeProfession ( Kozlov , 3 ) ;
7332: LD_EXP 55
7336: PPUSH
7337: LD_INT 3
7339: PPUSH
7340: CALL_OW 183
// ComConstruct ( kozlov_fac , ru_heavy_wheeled , engine_siberite , control_manual , ru_siberium_rocket ) ;
7344: LD_INT 332
7346: PPUSH
7347: LD_INT 23
7349: PPUSH
7350: LD_INT 3
7352: PPUSH
7353: LD_INT 1
7355: PPUSH
7356: LD_INT 48
7358: PPUSH
7359: CALL_OW 125
// end ;
7363: LD_VAR 0 1
7367: RET
// every 11 11$30 trigger not legionDestroyed and not MC_GetVehicles ( 3 , true ) do var i , tmp , target ;
7368: LD_EXP 3
7372: NOT
7373: PUSH
7374: LD_INT 3
7376: PPUSH
7377: LD_INT 1
7379: PPUSH
7380: CALL 45620 0 2
7384: NOT
7385: AND
7386: IFFALSE 8226
7388: GO 7390
7390: DISABLE
7391: LD_INT 0
7393: PPUSH
7394: PPUSH
7395: PPUSH
// begin enable ;
7396: ENABLE
// if not FilterAllUnits ( [ [ f_side , 8 ] , [ f_nation , 2 ] , [ f_btype , b_factory ] ] ) then
7397: LD_INT 22
7399: PUSH
7400: LD_INT 8
7402: PUSH
7403: EMPTY
7404: LIST
7405: LIST
7406: PUSH
7407: LD_INT 23
7409: PUSH
7410: LD_INT 2
7412: PUSH
7413: EMPTY
7414: LIST
7415: LIST
7416: PUSH
7417: LD_INT 30
7419: PUSH
7420: LD_INT 3
7422: PUSH
7423: EMPTY
7424: LIST
7425: LIST
7426: PUSH
7427: EMPTY
7428: LIST
7429: LIST
7430: LIST
7431: PPUSH
7432: CALL_OW 69
7436: NOT
7437: IFFALSE 7441
// exit ;
7439: GO 8226
// if Prob ( 40 ) then
7441: LD_INT 40
7443: PPUSH
7444: CALL_OW 13
7448: IFFALSE 7575
// begin MC_InsertProduceList ( 3 , [ [ ar_half_tracked , engine_combustion , control_remote , ar_rocket_launcher ] , [ ar_half_tracked , engine_combustion , control_remote , ar_rocket_launcher ] , [ ar_half_tracked , engine_combustion , control_remote , ar_rocket_launcher ] , [ ar_half_tracked , engine_combustion , control_remote , ar_rocket_launcher ] , [ ar_half_tracked , engine_combustion , control_remote , ar_rocket_launcher ] , [ ar_half_tracked , engine_combustion , control_remote , ar_flame_thrower ] , ] ) ;
7450: LD_INT 3
7452: PPUSH
7453: LD_INT 14
7455: PUSH
7456: LD_INT 1
7458: PUSH
7459: LD_INT 2
7461: PUSH
7462: LD_INT 28
7464: PUSH
7465: EMPTY
7466: LIST
7467: LIST
7468: LIST
7469: LIST
7470: PUSH
7471: LD_INT 14
7473: PUSH
7474: LD_INT 1
7476: PUSH
7477: LD_INT 2
7479: PUSH
7480: LD_INT 28
7482: PUSH
7483: EMPTY
7484: LIST
7485: LIST
7486: LIST
7487: LIST
7488: PUSH
7489: LD_INT 14
7491: PUSH
7492: LD_INT 1
7494: PUSH
7495: LD_INT 2
7497: PUSH
7498: LD_INT 28
7500: PUSH
7501: EMPTY
7502: LIST
7503: LIST
7504: LIST
7505: LIST
7506: PUSH
7507: LD_INT 14
7509: PUSH
7510: LD_INT 1
7512: PUSH
7513: LD_INT 2
7515: PUSH
7516: LD_INT 28
7518: PUSH
7519: EMPTY
7520: LIST
7521: LIST
7522: LIST
7523: LIST
7524: PUSH
7525: LD_INT 14
7527: PUSH
7528: LD_INT 1
7530: PUSH
7531: LD_INT 2
7533: PUSH
7534: LD_INT 28
7536: PUSH
7537: EMPTY
7538: LIST
7539: LIST
7540: LIST
7541: LIST
7542: PUSH
7543: LD_INT 14
7545: PUSH
7546: LD_INT 1
7548: PUSH
7549: LD_INT 2
7551: PUSH
7552: LD_INT 26
7554: PUSH
7555: EMPTY
7556: LIST
7557: LIST
7558: LIST
7559: LIST
7560: PUSH
7561: EMPTY
7562: LIST
7563: LIST
7564: LIST
7565: LIST
7566: LIST
7567: LIST
7568: PPUSH
7569: CALL 44202 0 2
// end else
7573: GO 7766
// begin MC_InsertProduceList ( 3 , [ [ ar_half_tracked , engine_combustion , control_remote , [ ar_gun , ar_flame_thrower , ar_flame_thrower ] [ Difficulty ] ] , [ ar_half_tracked , engine_combustion , control_remote , [ ar_gun , ar_flame_thrower , ar_flame_thrower ] [ Difficulty ] ] , [ ar_half_tracked , engine_combustion , control_remote , [ ar_flame_thrower , ar_flame_thrower , ar_selfpropelled_bomb ] [ Difficulty ] ] , [ ar_medium_trike , engine_combustion , control_remote , [ ar_flame_thrower , ar_selfpropelled_bomb , ar_selfpropelled_bomb ] [ Difficulty ] ] , [ ar_medium_trike , engine_combustion , control_remote , ar_selfpropelled_bomb ] , [ ar_half_tracked , engine_combustion , control_remote , ar_flame_thrower ] , ] ) ;
7575: LD_INT 3
7577: PPUSH
7578: LD_INT 14
7580: PUSH
7581: LD_INT 1
7583: PUSH
7584: LD_INT 2
7586: PUSH
7587: LD_INT 27
7589: PUSH
7590: LD_INT 26
7592: PUSH
7593: LD_INT 26
7595: PUSH
7596: EMPTY
7597: LIST
7598: LIST
7599: LIST
7600: PUSH
7601: LD_OWVAR 67
7605: ARRAY
7606: PUSH
7607: EMPTY
7608: LIST
7609: LIST
7610: LIST
7611: LIST
7612: PUSH
7613: LD_INT 14
7615: PUSH
7616: LD_INT 1
7618: PUSH
7619: LD_INT 2
7621: PUSH
7622: LD_INT 27
7624: PUSH
7625: LD_INT 26
7627: PUSH
7628: LD_INT 26
7630: PUSH
7631: EMPTY
7632: LIST
7633: LIST
7634: LIST
7635: PUSH
7636: LD_OWVAR 67
7640: ARRAY
7641: PUSH
7642: EMPTY
7643: LIST
7644: LIST
7645: LIST
7646: LIST
7647: PUSH
7648: LD_INT 14
7650: PUSH
7651: LD_INT 1
7653: PUSH
7654: LD_INT 2
7656: PUSH
7657: LD_INT 26
7659: PUSH
7660: LD_INT 26
7662: PUSH
7663: LD_INT 29
7665: PUSH
7666: EMPTY
7667: LIST
7668: LIST
7669: LIST
7670: PUSH
7671: LD_OWVAR 67
7675: ARRAY
7676: PUSH
7677: EMPTY
7678: LIST
7679: LIST
7680: LIST
7681: LIST
7682: PUSH
7683: LD_INT 13
7685: PUSH
7686: LD_INT 1
7688: PUSH
7689: LD_INT 2
7691: PUSH
7692: LD_INT 26
7694: PUSH
7695: LD_INT 29
7697: PUSH
7698: LD_INT 29
7700: PUSH
7701: EMPTY
7702: LIST
7703: LIST
7704: LIST
7705: PUSH
7706: LD_OWVAR 67
7710: ARRAY
7711: PUSH
7712: EMPTY
7713: LIST
7714: LIST
7715: LIST
7716: LIST
7717: PUSH
7718: LD_INT 13
7720: PUSH
7721: LD_INT 1
7723: PUSH
7724: LD_INT 2
7726: PUSH
7727: LD_INT 29
7729: PUSH
7730: EMPTY
7731: LIST
7732: LIST
7733: LIST
7734: LIST
7735: PUSH
7736: LD_INT 14
7738: PUSH
7739: LD_INT 1
7741: PUSH
7742: LD_INT 2
7744: PUSH
7745: LD_INT 26
7747: PUSH
7748: EMPTY
7749: LIST
7750: LIST
7751: LIST
7752: LIST
7753: PUSH
7754: EMPTY
7755: LIST
7756: LIST
7757: LIST
7758: LIST
7759: LIST
7760: LIST
7761: PPUSH
7762: CALL 44202 0 2
// end ; repeat wait ( 0 0$1 ) ;
7766: LD_INT 35
7768: PPUSH
7769: CALL_OW 67
// until MC_GetVehicles ( 3 , true ) >= 6 ;
7773: LD_INT 3
7775: PPUSH
7776: LD_INT 1
7778: PPUSH
7779: CALL 45620 0 2
7783: PUSH
7784: LD_INT 6
7786: GREATEREQUAL
7787: IFFALSE 7766
// wait ( 0 0$30 ) ;
7789: LD_INT 1050
7791: PPUSH
7792: CALL_OW 67
// tmp := MC_GetVehicles ( 3 , true ) ;
7796: LD_ADDR_VAR 0 2
7800: PUSH
7801: LD_INT 3
7803: PPUSH
7804: LD_INT 1
7806: PPUSH
7807: CALL 45620 0 2
7811: ST_TO_ADDR
// mc_vehicles := Replace ( mc_vehicles , 3 , mc_vehicles [ 3 ] diff tmp ) ;
7812: LD_ADDR_EXP 98
7816: PUSH
7817: LD_EXP 98
7821: PPUSH
7822: LD_INT 3
7824: PPUSH
7825: LD_EXP 98
7829: PUSH
7830: LD_INT 3
7832: ARRAY
7833: PUSH
7834: LD_VAR 0 2
7838: DIFF
7839: PPUSH
7840: CALL_OW 1
7844: ST_TO_ADDR
// target := rand ( 0 , 2 ) ;
7845: LD_ADDR_VAR 0 3
7849: PUSH
7850: LD_INT 0
7852: PPUSH
7853: LD_INT 2
7855: PPUSH
7856: CALL_OW 12
7860: ST_TO_ADDR
// if target then
7861: LD_VAR 0 3
7865: IFFALSE 7993
// begin repeat tmp := UnitFilter ( tmp , [ f_lives , 250 ] ) ;
7867: LD_ADDR_VAR 0 2
7871: PUSH
7872: LD_VAR 0 2
7876: PPUSH
7877: LD_INT 24
7879: PUSH
7880: LD_INT 250
7882: PUSH
7883: EMPTY
7884: LIST
7885: LIST
7886: PPUSH
7887: CALL_OW 72
7891: ST_TO_ADDR
// for i in tmp do
7892: LD_ADDR_VAR 0 1
7896: PUSH
7897: LD_VAR 0 2
7901: PUSH
7902: FOR_IN
7903: IFFALSE 7943
// if GetDistUnitXY ( i , 89 , 71 ) > 9 then
7905: LD_VAR 0 1
7909: PPUSH
7910: LD_INT 89
7912: PPUSH
7913: LD_INT 71
7915: PPUSH
7916: CALL_OW 297
7920: PUSH
7921: LD_INT 9
7923: GREATER
7924: IFFALSE 7941
// ComMoveXY ( i , 89 , 71 ) ;
7926: LD_VAR 0 1
7930: PPUSH
7931: LD_INT 89
7933: PPUSH
7934: LD_INT 71
7936: PPUSH
7937: CALL_OW 111
7941: GO 7902
7943: POP
7944: POP
// wait ( 0 0$1 ) ;
7945: LD_INT 35
7947: PPUSH
7948: CALL_OW 67
// until UnitFilter ( tmp , [ f_distxy , 89 , 71 , 9 ] ) >= ( tmp - 1 ) ;
7952: LD_VAR 0 2
7956: PPUSH
7957: LD_INT 92
7959: PUSH
7960: LD_INT 89
7962: PUSH
7963: LD_INT 71
7965: PUSH
7966: LD_INT 9
7968: PUSH
7969: EMPTY
7970: LIST
7971: LIST
7972: LIST
7973: LIST
7974: PPUSH
7975: CALL_OW 72
7979: PUSH
7980: LD_VAR 0 2
7984: PUSH
7985: LD_INT 1
7987: MINUS
7988: GREATEREQUAL
7989: IFFALSE 7867
// end else
7991: GO 8117
// begin repeat tmp := UnitFilter ( tmp , [ f_lives , 250 ] ) ;
7993: LD_ADDR_VAR 0 2
7997: PUSH
7998: LD_VAR 0 2
8002: PPUSH
8003: LD_INT 24
8005: PUSH
8006: LD_INT 250
8008: PUSH
8009: EMPTY
8010: LIST
8011: LIST
8012: PPUSH
8013: CALL_OW 72
8017: ST_TO_ADDR
// for i in tmp do
8018: LD_ADDR_VAR 0 1
8022: PUSH
8023: LD_VAR 0 2
8027: PUSH
8028: FOR_IN
8029: IFFALSE 8069
// if GetDistUnitXY ( i , 147 , 4 ) > 9 then
8031: LD_VAR 0 1
8035: PPUSH
8036: LD_INT 147
8038: PPUSH
8039: LD_INT 4
8041: PPUSH
8042: CALL_OW 297
8046: PUSH
8047: LD_INT 9
8049: GREATER
8050: IFFALSE 8067
// ComMoveXY ( i , 147 , 4 ) ;
8052: LD_VAR 0 1
8056: PPUSH
8057: LD_INT 147
8059: PPUSH
8060: LD_INT 4
8062: PPUSH
8063: CALL_OW 111
8067: GO 8028
8069: POP
8070: POP
// wait ( 0 0$1 ) ;
8071: LD_INT 35
8073: PPUSH
8074: CALL_OW 67
// until UnitFilter ( tmp , [ f_distxy , 147 , 4 , 9 ] ) >= ( tmp - 1 ) ;
8078: LD_VAR 0 2
8082: PPUSH
8083: LD_INT 92
8085: PUSH
8086: LD_INT 147
8088: PUSH
8089: LD_INT 4
8091: PUSH
8092: LD_INT 9
8094: PUSH
8095: EMPTY
8096: LIST
8097: LIST
8098: LIST
8099: LIST
8100: PPUSH
8101: CALL_OW 72
8105: PUSH
8106: LD_VAR 0 2
8110: PUSH
8111: LD_INT 1
8113: MINUS
8114: GREATEREQUAL
8115: IFFALSE 7993
// end ; repeat wait ( 0 0$1 ) ;
8117: LD_INT 35
8119: PPUSH
8120: CALL_OW 67
// for i in tmp do
8124: LD_ADDR_VAR 0 1
8128: PUSH
8129: LD_VAR 0 2
8133: PUSH
8134: FOR_IN
8135: IFFALSE 8217
// begin if GetLives ( i ) > 251 then
8137: LD_VAR 0 1
8141: PPUSH
8142: CALL_OW 256
8146: PUSH
8147: LD_INT 251
8149: GREATER
8150: IFFALSE 8188
// ComAttackUnit ( i , NearestUnitToUnit ( FilterAllUnits ( [ f_enemy , 8 ] ) , i ) ) else
8152: LD_VAR 0 1
8156: PPUSH
8157: LD_INT 81
8159: PUSH
8160: LD_INT 8
8162: PUSH
8163: EMPTY
8164: LIST
8165: LIST
8166: PPUSH
8167: CALL_OW 69
8171: PPUSH
8172: LD_VAR 0 1
8176: PPUSH
8177: CALL_OW 74
8181: PPUSH
8182: CALL_OW 115
8186: GO 8215
// if IsDead ( i ) then
8188: LD_VAR 0 1
8192: PPUSH
8193: CALL_OW 301
8197: IFFALSE 8215
// tmp := tmp diff i ;
8199: LD_ADDR_VAR 0 2
8203: PUSH
8204: LD_VAR 0 2
8208: PUSH
8209: LD_VAR 0 1
8213: DIFF
8214: ST_TO_ADDR
// end ;
8215: GO 8134
8217: POP
8218: POP
// until not tmp ;
8219: LD_VAR 0 2
8223: NOT
8224: IFFALSE 8117
// end ;
8226: PPOPN 3
8228: END
// every 0 0$1 trigger IsOk ( Kozlov ) and not legionDestroyed do
8229: LD_EXP 55
8233: PPUSH
8234: CALL_OW 302
8238: PUSH
8239: LD_EXP 3
8243: NOT
8244: AND
8245: IFFALSE 8254
8247: GO 8249
8249: DISABLE
// BuildKozlovBomb ;
8250: CALL 7241 0 0
8254: END
// every 0 0$3 trigger FilterAllUnits ( [ [ f_side , 8 ] , [ f_weapon , ru_siberium_rocket ] ] ) do
8255: LD_INT 22
8257: PUSH
8258: LD_INT 8
8260: PUSH
8261: EMPTY
8262: LIST
8263: LIST
8264: PUSH
8265: LD_INT 34
8267: PUSH
8268: LD_INT 48
8270: PUSH
8271: EMPTY
8272: LIST
8273: LIST
8274: PUSH
8275: EMPTY
8276: LIST
8277: LIST
8278: PPUSH
8279: CALL_OW 69
8283: IFFALSE 8331
8285: GO 8287
8287: DISABLE
// begin ComAttackPlace ( FilterAllUnits ( [ [ f_side , 8 ] , [ f_weapon , ru_siberium_rocket ] ] ) [ 1 ] , 173 , 96 ) ;
8288: LD_INT 22
8290: PUSH
8291: LD_INT 8
8293: PUSH
8294: EMPTY
8295: LIST
8296: LIST
8297: PUSH
8298: LD_INT 34
8300: PUSH
8301: LD_INT 48
8303: PUSH
8304: EMPTY
8305: LIST
8306: LIST
8307: PUSH
8308: EMPTY
8309: LIST
8310: LIST
8311: PPUSH
8312: CALL_OW 69
8316: PUSH
8317: LD_INT 1
8319: ARRAY
8320: PPUSH
8321: LD_INT 173
8323: PPUSH
8324: LD_INT 96
8326: PPUSH
8327: CALL_OW 116
// end ; end_of_file
8331: END
// export Platonov , Yakotich , Gleb , Bierezov ; export behemoths , behemothBuilders ; export function PrepareRussian ; var i , j , base , tmp , side , xy , b , teleport ; begin
8332: LD_INT 0
8334: PPUSH
8335: PPUSH
8336: PPUSH
8337: PPUSH
8338: PPUSH
8339: PPUSH
8340: PPUSH
8341: PPUSH
8342: PPUSH
// side := 3 ;
8343: LD_ADDR_VAR 0 6
8347: PUSH
8348: LD_INT 3
8350: ST_TO_ADDR
// InitHc ;
8351: CALL_OW 19
// uc_side := side ;
8355: LD_ADDR_OWVAR 20
8359: PUSH
8360: LD_VAR 0 6
8364: ST_TO_ADDR
// uc_nation := 3 ;
8365: LD_ADDR_OWVAR 21
8369: PUSH
8370: LD_INT 3
8372: ST_TO_ADDR
// for i in FilterAllUnits ( [ [ f_side , side ] , [ f_type , unit_building ] ] ) do
8373: LD_ADDR_VAR 0 2
8377: PUSH
8378: LD_INT 22
8380: PUSH
8381: LD_VAR 0 6
8385: PUSH
8386: EMPTY
8387: LIST
8388: LIST
8389: PUSH
8390: LD_INT 21
8392: PUSH
8393: LD_INT 3
8395: PUSH
8396: EMPTY
8397: LIST
8398: LIST
8399: PUSH
8400: EMPTY
8401: LIST
8402: LIST
8403: PPUSH
8404: CALL_OW 69
8408: PUSH
8409: FOR_IN
8410: IFFALSE 8426
// SetBLevel ( i , 10 ) ;
8412: LD_VAR 0 2
8416: PPUSH
8417: LD_INT 10
8419: PPUSH
8420: CALL_OW 241
8424: GO 8409
8426: POP
8427: POP
// teleport := FilterAllUnits ( [ [ f_side , side ] , [ f_btype , b_teleport ] ] ) ;
8428: LD_ADDR_VAR 0 9
8432: PUSH
8433: LD_INT 22
8435: PUSH
8436: LD_VAR 0 6
8440: PUSH
8441: EMPTY
8442: LIST
8443: LIST
8444: PUSH
8445: LD_INT 30
8447: PUSH
8448: LD_INT 34
8450: PUSH
8451: EMPTY
8452: LIST
8453: LIST
8454: PUSH
8455: EMPTY
8456: LIST
8457: LIST
8458: PPUSH
8459: CALL_OW 69
8463: ST_TO_ADDR
// if teleport then
8464: LD_VAR 0 9
8468: IFFALSE 8489
// TeleportExit ( teleport [ 1 ] , 123 , 122 ) ;
8470: LD_VAR 0 9
8474: PUSH
8475: LD_INT 1
8477: ARRAY
8478: PPUSH
8479: LD_INT 123
8481: PPUSH
8482: LD_INT 122
8484: PPUSH
8485: CALL_OW 243
// hc_importance := 0 ;
8489: LD_ADDR_OWVAR 32
8493: PUSH
8494: LD_INT 0
8496: ST_TO_ADDR
// Platonov := NewCharacter ( Platonov ) ;
8497: LD_ADDR_EXP 56
8501: PUSH
8502: LD_STRING Platonov
8504: PPUSH
8505: CALL_OW 25
8509: ST_TO_ADDR
// Yakotich := NewCharacter ( Yakotich ) ;
8510: LD_ADDR_EXP 57
8514: PUSH
8515: LD_STRING Yakotich
8517: PPUSH
8518: CALL_OW 25
8522: ST_TO_ADDR
// Gleb := NewCharacter ( Gleb ) ;
8523: LD_ADDR_EXP 58
8527: PUSH
8528: LD_STRING Gleb
8530: PPUSH
8531: CALL_OW 25
8535: ST_TO_ADDR
// if TestCharacters ( 03_Cornel ) then
8536: LD_STRING 03_Cornel
8538: PPUSH
8539: CALL_OW 28
8543: IFFALSE 8591
// begin Bierezov := NewCharacter ( Mikhail ) ;
8545: LD_ADDR_EXP 59
8549: PUSH
8550: LD_STRING Mikhail
8552: PPUSH
8553: CALL_OW 25
8557: ST_TO_ADDR
// PlaceUnitXYR ( Bierezov , 197 , 111 , 9 , false ) ;
8558: LD_EXP 59
8562: PPUSH
8563: LD_INT 197
8565: PPUSH
8566: LD_INT 111
8568: PPUSH
8569: LD_INT 9
8571: PPUSH
8572: LD_INT 0
8574: PPUSH
8575: CALL_OW 50
// SetClass ( Bierezov , 3 ) ;
8579: LD_EXP 59
8583: PPUSH
8584: LD_INT 3
8586: PPUSH
8587: CALL_OW 336
// end ; PlaceHumanInUnit ( Platonov , ru_depot ) ;
8591: LD_EXP 56
8595: PPUSH
8596: LD_INT 126
8598: PPUSH
8599: CALL_OW 52
// PlaceUnitXYR ( Yakotich , 197 , 111 , 9 , false ) ;
8603: LD_EXP 57
8607: PPUSH
8608: LD_INT 197
8610: PPUSH
8611: LD_INT 111
8613: PPUSH
8614: LD_INT 9
8616: PPUSH
8617: LD_INT 0
8619: PPUSH
8620: CALL_OW 50
// PlaceUnitXYR ( Gleb , 197 , 111 , 9 , false ) ;
8624: LD_EXP 58
8628: PPUSH
8629: LD_INT 197
8631: PPUSH
8632: LD_INT 111
8634: PPUSH
8635: LD_INT 9
8637: PPUSH
8638: LD_INT 0
8640: PPUSH
8641: CALL_OW 50
// tmp := PrepareBase ( ru_depot , russianBaseArea , zhukov , [ 9 , 10 , 10 ] [ Difficulty ] , [ 9000 , 1000 , 300 ] , [ 21 , 8 , 13 , 8 ] ) ;
8645: LD_ADDR_VAR 0 5
8649: PUSH
8650: LD_INT 126
8652: PPUSH
8653: LD_INT 2
8655: PPUSH
8656: LD_STRING zhukov
8658: PPUSH
8659: LD_INT 9
8661: PUSH
8662: LD_INT 10
8664: PUSH
8665: LD_INT 10
8667: PUSH
8668: EMPTY
8669: LIST
8670: LIST
8671: LIST
8672: PUSH
8673: LD_OWVAR 67
8677: ARRAY
8678: PPUSH
8679: LD_INT 9000
8681: PUSH
8682: LD_INT 1000
8684: PUSH
8685: LD_INT 300
8687: PUSH
8688: EMPTY
8689: LIST
8690: LIST
8691: LIST
8692: PPUSH
8693: LD_INT 21
8695: PUSH
8696: LD_INT 8
8698: PUSH
8699: LD_INT 13
8701: PUSH
8702: LD_INT 8
8704: PUSH
8705: EMPTY
8706: LIST
8707: LIST
8708: LIST
8709: LIST
8710: PPUSH
8711: CALL 61070 0 6
8715: ST_TO_ADDR
// base := GetBase ( ru_depot2 ) ;
8716: LD_ADDR_VAR 0 4
8720: PUSH
8721: LD_INT 267
8723: PPUSH
8724: CALL_OW 274
8728: ST_TO_ADDR
// SetResourceType ( base , mat_cans , 5000 ) ;
8729: LD_VAR 0 4
8733: PPUSH
8734: LD_INT 1
8736: PPUSH
8737: LD_INT 5000
8739: PPUSH
8740: CALL_OW 277
// SetResourceType ( base , mat_oil , 200 ) ;
8744: LD_VAR 0 4
8748: PPUSH
8749: LD_INT 2
8751: PPUSH
8752: LD_INT 200
8754: PPUSH
8755: CALL_OW 277
// SetResourceType ( base , mat_siberit , 200 ) ;
8759: LD_VAR 0 4
8763: PPUSH
8764: LD_INT 3
8766: PPUSH
8767: LD_INT 200
8769: PPUSH
8770: CALL_OW 277
// mc_bases := Replace ( mc_bases , 2 , tmp union FilterAllUnits ( [ [ f_side , side ] , [ f_not , [ f_type , unit_vehicle ] ] ] ) diff Platonov ) ;
8774: LD_ADDR_EXP 79
8778: PUSH
8779: LD_EXP 79
8783: PPUSH
8784: LD_INT 2
8786: PPUSH
8787: LD_VAR 0 5
8791: PUSH
8792: LD_INT 22
8794: PUSH
8795: LD_VAR 0 6
8799: PUSH
8800: EMPTY
8801: LIST
8802: LIST
8803: PUSH
8804: LD_INT 3
8806: PUSH
8807: LD_INT 21
8809: PUSH
8810: LD_INT 2
8812: PUSH
8813: EMPTY
8814: LIST
8815: LIST
8816: PUSH
8817: EMPTY
8818: LIST
8819: LIST
8820: PUSH
8821: EMPTY
8822: LIST
8823: LIST
8824: PPUSH
8825: CALL_OW 69
8829: UNION
8830: PUSH
8831: LD_EXP 56
8835: DIFF
8836: PPUSH
8837: CALL_OW 1
8841: ST_TO_ADDR
// behemoths := [ ] ;
8842: LD_ADDR_EXP 60
8846: PUSH
8847: EMPTY
8848: ST_TO_ADDR
// behemothBuilders := [ ] ;
8849: LD_ADDR_EXP 61
8853: PUSH
8854: EMPTY
8855: ST_TO_ADDR
// j := 3 ;
8856: LD_ADDR_VAR 0 3
8860: PUSH
8861: LD_INT 3
8863: ST_TO_ADDR
// for i in FilterAllUnits ( [ [ f_side , 3 ] , [ f_class , 3 ] ] ) do
8864: LD_ADDR_VAR 0 2
8868: PUSH
8869: LD_INT 22
8871: PUSH
8872: LD_INT 3
8874: PUSH
8875: EMPTY
8876: LIST
8877: LIST
8878: PUSH
8879: LD_INT 25
8881: PUSH
8882: LD_INT 3
8884: PUSH
8885: EMPTY
8886: LIST
8887: LIST
8888: PUSH
8889: EMPTY
8890: LIST
8891: LIST
8892: PPUSH
8893: CALL_OW 69
8897: PUSH
8898: FOR_IN
8899: IFFALSE 8949
// begin behemothBuilders := Join ( behemothBuilders , i ) ;
8901: LD_ADDR_EXP 61
8905: PUSH
8906: LD_EXP 61
8910: PPUSH
8911: LD_VAR 0 2
8915: PPUSH
8916: CALL 93416 0 2
8920: ST_TO_ADDR
// j := j - 1 ;
8921: LD_ADDR_VAR 0 3
8925: PUSH
8926: LD_VAR 0 3
8930: PUSH
8931: LD_INT 1
8933: MINUS
8934: ST_TO_ADDR
// if j = 0 then
8935: LD_VAR 0 3
8939: PUSH
8940: LD_INT 0
8942: EQUAL
8943: IFFALSE 8947
// break ;
8945: GO 8949
// end ;
8947: GO 8898
8949: POP
8950: POP
// end ;
8951: LD_VAR 0 1
8955: RET
// export function BuildBehemoths ; var i , j , xy , tmp ; begin
8956: LD_INT 0
8958: PPUSH
8959: PPUSH
8960: PPUSH
8961: PPUSH
8962: PPUSH
// xy := [ [ 209 , 149 ] , [ 219 , 154 ] , [ 223 , 149 ] , [ 232 , 155 ] ] ;
8963: LD_ADDR_VAR 0 4
8967: PUSH
8968: LD_INT 209
8970: PUSH
8971: LD_INT 149
8973: PUSH
8974: EMPTY
8975: LIST
8976: LIST
8977: PUSH
8978: LD_INT 219
8980: PUSH
8981: LD_INT 154
8983: PUSH
8984: EMPTY
8985: LIST
8986: LIST
8987: PUSH
8988: LD_INT 223
8990: PUSH
8991: LD_INT 149
8993: PUSH
8994: EMPTY
8995: LIST
8996: LIST
8997: PUSH
8998: LD_INT 232
9000: PUSH
9001: LD_INT 155
9003: PUSH
9004: EMPTY
9005: LIST
9006: LIST
9007: PUSH
9008: EMPTY
9009: LIST
9010: LIST
9011: LIST
9012: LIST
9013: ST_TO_ADDR
// if not behemothBuilders then
9014: LD_EXP 61
9018: NOT
9019: IFFALSE 9023
// exit ;
9021: GO 9127
// j := 1 ;
9023: LD_ADDR_VAR 0 3
9027: PUSH
9028: LD_INT 1
9030: ST_TO_ADDR
// for i in behemothBuilders do
9031: LD_ADDR_VAR 0 2
9035: PUSH
9036: LD_EXP 61
9040: PUSH
9041: FOR_IN
9042: IFFALSE 9125
// begin if IsInUnit ( i ) then
9044: LD_VAR 0 2
9048: PPUSH
9049: CALL_OW 310
9053: IFFALSE 9064
// ComExitBuilding ( i ) ;
9055: LD_VAR 0 2
9059: PPUSH
9060: CALL_OW 122
// AddComBuildBehemoth ( i , b_behemoth , xy [ j ] [ 1 ] , xy [ j ] [ 2 ] , 0 ) ;
9064: LD_VAR 0 2
9068: PPUSH
9069: LD_INT 37
9071: PPUSH
9072: LD_VAR 0 4
9076: PUSH
9077: LD_VAR 0 3
9081: ARRAY
9082: PUSH
9083: LD_INT 1
9085: ARRAY
9086: PPUSH
9087: LD_VAR 0 4
9091: PUSH
9092: LD_VAR 0 3
9096: ARRAY
9097: PUSH
9098: LD_INT 2
9100: ARRAY
9101: PPUSH
9102: LD_INT 0
9104: PPUSH
9105: CALL_OW 230
// j := j + 1 ;
9109: LD_ADDR_VAR 0 3
9113: PUSH
9114: LD_VAR 0 3
9118: PUSH
9119: LD_INT 1
9121: PLUS
9122: ST_TO_ADDR
// end ;
9123: GO 9041
9125: POP
9126: POP
// end ;
9127: LD_VAR 0 1
9131: RET
// every 0 0$3 trigger GetBehemoths ( 3 ) and not FilterAllUnits ( [ [ f_side , 3 ] , [ f_btype , b_behemoth ] ] ) do var i , tmp ;
9132: LD_INT 3
9134: PPUSH
9135: CALL 93464 0 1
9139: PUSH
9140: LD_INT 22
9142: PUSH
9143: LD_INT 3
9145: PUSH
9146: EMPTY
9147: LIST
9148: LIST
9149: PUSH
9150: LD_INT 30
9152: PUSH
9153: LD_INT 37
9155: PUSH
9156: EMPTY
9157: LIST
9158: LIST
9159: PUSH
9160: EMPTY
9161: LIST
9162: LIST
9163: PPUSH
9164: CALL_OW 69
9168: NOT
9169: AND
9170: IFFALSE 9356
9172: GO 9174
9174: DISABLE
9175: LD_INT 0
9177: PPUSH
9178: PPUSH
// begin enable ;
9179: ENABLE
// tmp := GetBehemoths ( 3 ) ;
9180: LD_ADDR_VAR 0 2
9184: PUSH
9185: LD_INT 3
9187: PPUSH
9188: CALL 93464 0 1
9192: ST_TO_ADDR
// for i in tmp do
9193: LD_ADDR_VAR 0 1
9197: PUSH
9198: LD_VAR 0 2
9202: PUSH
9203: FOR_IN
9204: IFFALSE 9354
// begin if IsInArea ( i , powellBase ) and not GetTag ( i ) = 2 then
9206: LD_VAR 0 1
9210: PPUSH
9211: LD_INT 7
9213: PPUSH
9214: CALL_OW 308
9218: PUSH
9219: LD_VAR 0 1
9223: PPUSH
9224: CALL_OW 110
9228: PUSH
9229: LD_INT 2
9231: EQUAL
9232: NOT
9233: AND
9234: IFFALSE 9248
// SetTag ( i , 2 ) ;
9236: LD_VAR 0 1
9240: PPUSH
9241: LD_INT 2
9243: PPUSH
9244: CALL_OW 109
// if not FilterAllUnits ( [ [ f_enemy , 3 ] , [ f_dist , i , 12 ] ] ) and not GetTag ( i ) = 2 then
9248: LD_INT 81
9250: PUSH
9251: LD_INT 3
9253: PUSH
9254: EMPTY
9255: LIST
9256: LIST
9257: PUSH
9258: LD_INT 91
9260: PUSH
9261: LD_VAR 0 1
9265: PUSH
9266: LD_INT 12
9268: PUSH
9269: EMPTY
9270: LIST
9271: LIST
9272: LIST
9273: PUSH
9274: EMPTY
9275: LIST
9276: LIST
9277: PPUSH
9278: CALL_OW 69
9282: NOT
9283: PUSH
9284: LD_VAR 0 1
9288: PPUSH
9289: CALL_OW 110
9293: PUSH
9294: LD_INT 2
9296: EQUAL
9297: NOT
9298: AND
9299: IFFALSE 9318
// ComAgressiveMove ( i , 64 , 93 ) else
9301: LD_VAR 0 1
9305: PPUSH
9306: LD_INT 64
9308: PPUSH
9309: LD_INT 93
9311: PPUSH
9312: CALL_OW 114
9316: GO 9352
// ComAttackUnit ( i , NearestUnitToUnit ( FilterAllUnits ( [ f_enemy , 3 ] ) , i ) ) ;
9318: LD_VAR 0 1
9322: PPUSH
9323: LD_INT 81
9325: PUSH
9326: LD_INT 3
9328: PUSH
9329: EMPTY
9330: LIST
9331: LIST
9332: PPUSH
9333: CALL_OW 69
9337: PPUSH
9338: LD_VAR 0 1
9342: PPUSH
9343: CALL_OW 74
9347: PPUSH
9348: CALL_OW 115
// end ;
9352: GO 9203
9354: POP
9355: POP
// end ;
9356: PPOPN 2
9358: END
// every 11 11$30 trigger not russianDestroyed and not MC_GetVehicles ( 2 , true ) do var i , tmp , target , teleport ;
9359: LD_EXP 2
9363: NOT
9364: PUSH
9365: LD_INT 2
9367: PPUSH
9368: LD_INT 1
9370: PPUSH
9371: CALL 45620 0 2
9375: NOT
9376: AND
9377: IFFALSE 10297
9379: GO 9381
9381: DISABLE
9382: LD_INT 0
9384: PPUSH
9385: PPUSH
9386: PPUSH
9387: PPUSH
// begin enable ;
9388: ENABLE
// if not FilterAllUnits ( [ [ f_side , 3 ] , [ f_btype , b_factory ] ] ) then
9389: LD_INT 22
9391: PUSH
9392: LD_INT 3
9394: PUSH
9395: EMPTY
9396: LIST
9397: LIST
9398: PUSH
9399: LD_INT 30
9401: PUSH
9402: LD_INT 3
9404: PUSH
9405: EMPTY
9406: LIST
9407: LIST
9408: PUSH
9409: EMPTY
9410: LIST
9411: LIST
9412: PPUSH
9413: CALL_OW 69
9417: NOT
9418: IFFALSE 9422
// exit ;
9420: GO 10297
// teleport := FilterAllUnits ( [ [ f_side , 3 ] , [ f_btype , b_teleport ] ] ) ;
9422: LD_ADDR_VAR 0 4
9426: PUSH
9427: LD_INT 22
9429: PUSH
9430: LD_INT 3
9432: PUSH
9433: EMPTY
9434: LIST
9435: LIST
9436: PUSH
9437: LD_INT 30
9439: PUSH
9440: LD_INT 34
9442: PUSH
9443: EMPTY
9444: LIST
9445: LIST
9446: PUSH
9447: EMPTY
9448: LIST
9449: LIST
9450: PPUSH
9451: CALL_OW 69
9455: ST_TO_ADDR
// if Prob ( 40 ) then
9456: LD_INT 40
9458: PPUSH
9459: CALL_OW 13
9463: IFFALSE 9590
// begin MC_InsertProduceList ( 2 , [ [ ru_medium_tracked , engine_siberite , control_computer , ru_time_lapser ] , [ ru_medium_tracked , engine_siberite , control_computer , ru_time_lapser ] , [ ru_medium_tracked , engine_siberite , control_computer , ru_time_lapser ] , [ ru_heavy_tracked , engine_siberite , control_computer , ru_heavy_gun ] , [ ru_heavy_tracked , engine_siberite , control_computer , ru_heavy_gun ] , [ ru_heavy_tracked , engine_siberite , control_computer , ru_heavy_gun ] ] ) ;
9465: LD_INT 2
9467: PPUSH
9468: LD_INT 22
9470: PUSH
9471: LD_INT 3
9473: PUSH
9474: LD_INT 3
9476: PUSH
9477: LD_INT 49
9479: PUSH
9480: EMPTY
9481: LIST
9482: LIST
9483: LIST
9484: LIST
9485: PUSH
9486: LD_INT 22
9488: PUSH
9489: LD_INT 3
9491: PUSH
9492: LD_INT 3
9494: PUSH
9495: LD_INT 49
9497: PUSH
9498: EMPTY
9499: LIST
9500: LIST
9501: LIST
9502: LIST
9503: PUSH
9504: LD_INT 22
9506: PUSH
9507: LD_INT 3
9509: PUSH
9510: LD_INT 3
9512: PUSH
9513: LD_INT 49
9515: PUSH
9516: EMPTY
9517: LIST
9518: LIST
9519: LIST
9520: LIST
9521: PUSH
9522: LD_INT 24
9524: PUSH
9525: LD_INT 3
9527: PUSH
9528: LD_INT 3
9530: PUSH
9531: LD_INT 46
9533: PUSH
9534: EMPTY
9535: LIST
9536: LIST
9537: LIST
9538: LIST
9539: PUSH
9540: LD_INT 24
9542: PUSH
9543: LD_INT 3
9545: PUSH
9546: LD_INT 3
9548: PUSH
9549: LD_INT 46
9551: PUSH
9552: EMPTY
9553: LIST
9554: LIST
9555: LIST
9556: LIST
9557: PUSH
9558: LD_INT 24
9560: PUSH
9561: LD_INT 3
9563: PUSH
9564: LD_INT 3
9566: PUSH
9567: LD_INT 46
9569: PUSH
9570: EMPTY
9571: LIST
9572: LIST
9573: LIST
9574: LIST
9575: PUSH
9576: EMPTY
9577: LIST
9578: LIST
9579: LIST
9580: LIST
9581: LIST
9582: LIST
9583: PPUSH
9584: CALL 44202 0 2
// end else
9588: GO 9713
// begin MC_InsertProduceList ( 2 , [ [ ru_heavy_tracked , engine_siberite , control_computer , ru_rocket ] , [ ru_heavy_tracked , engine_siberite , control_computer , ru_rocket ] , [ ru_heavy_tracked , engine_siberite , control_computer , ru_rocket ] , [ ru_heavy_tracked , engine_siberite , control_computer , ru_heavy_gun ] , [ ru_heavy_tracked , engine_siberite , control_computer , ru_heavy_gun ] , [ ru_heavy_tracked , engine_siberite , control_computer , ru_heavy_gun ] ] ) ;
9590: LD_INT 2
9592: PPUSH
9593: LD_INT 24
9595: PUSH
9596: LD_INT 3
9598: PUSH
9599: LD_INT 3
9601: PUSH
9602: LD_INT 47
9604: PUSH
9605: EMPTY
9606: LIST
9607: LIST
9608: LIST
9609: LIST
9610: PUSH
9611: LD_INT 24
9613: PUSH
9614: LD_INT 3
9616: PUSH
9617: LD_INT 3
9619: PUSH
9620: LD_INT 47
9622: PUSH
9623: EMPTY
9624: LIST
9625: LIST
9626: LIST
9627: LIST
9628: PUSH
9629: LD_INT 24
9631: PUSH
9632: LD_INT 3
9634: PUSH
9635: LD_INT 3
9637: PUSH
9638: LD_INT 47
9640: PUSH
9641: EMPTY
9642: LIST
9643: LIST
9644: LIST
9645: LIST
9646: PUSH
9647: LD_INT 24
9649: PUSH
9650: LD_INT 3
9652: PUSH
9653: LD_INT 3
9655: PUSH
9656: LD_INT 46
9658: PUSH
9659: EMPTY
9660: LIST
9661: LIST
9662: LIST
9663: LIST
9664: PUSH
9665: LD_INT 24
9667: PUSH
9668: LD_INT 3
9670: PUSH
9671: LD_INT 3
9673: PUSH
9674: LD_INT 46
9676: PUSH
9677: EMPTY
9678: LIST
9679: LIST
9680: LIST
9681: LIST
9682: PUSH
9683: LD_INT 24
9685: PUSH
9686: LD_INT 3
9688: PUSH
9689: LD_INT 3
9691: PUSH
9692: LD_INT 46
9694: PUSH
9695: EMPTY
9696: LIST
9697: LIST
9698: LIST
9699: LIST
9700: PUSH
9701: EMPTY
9702: LIST
9703: LIST
9704: LIST
9705: LIST
9706: LIST
9707: LIST
9708: PPUSH
9709: CALL 44202 0 2
// end ; if Difficulty > 1 then
9713: LD_OWVAR 67
9717: PUSH
9718: LD_INT 1
9720: GREATER
9721: IFFALSE 9751
// MC_InsertProduceList ( 2 , [ [ ru_heavy_tracked , engine_siberite , control_computer , ru_rocket ] ] ) ;
9723: LD_INT 2
9725: PPUSH
9726: LD_INT 24
9728: PUSH
9729: LD_INT 3
9731: PUSH
9732: LD_INT 3
9734: PUSH
9735: LD_INT 47
9737: PUSH
9738: EMPTY
9739: LIST
9740: LIST
9741: LIST
9742: LIST
9743: PUSH
9744: EMPTY
9745: LIST
9746: PPUSH
9747: CALL 44202 0 2
// repeat wait ( 0 0$1 ) ;
9751: LD_INT 35
9753: PPUSH
9754: CALL_OW 67
// until MC_GetVehicles ( 2 , true ) >= [ 6 , 7 , 7 ] [ Difficulty ] ;
9758: LD_INT 2
9760: PPUSH
9761: LD_INT 1
9763: PPUSH
9764: CALL 45620 0 2
9768: PUSH
9769: LD_INT 6
9771: PUSH
9772: LD_INT 7
9774: PUSH
9775: LD_INT 7
9777: PUSH
9778: EMPTY
9779: LIST
9780: LIST
9781: LIST
9782: PUSH
9783: LD_OWVAR 67
9787: ARRAY
9788: GREATEREQUAL
9789: IFFALSE 9751
// wait ( 0 0$30 ) ;
9791: LD_INT 1050
9793: PPUSH
9794: CALL_OW 67
// tmp := MC_GetVehicles ( 2 , true ) ;
9798: LD_ADDR_VAR 0 2
9802: PUSH
9803: LD_INT 2
9805: PPUSH
9806: LD_INT 1
9808: PPUSH
9809: CALL 45620 0 2
9813: ST_TO_ADDR
// mc_vehicles := Replace ( mc_vehicles , 2 , mc_vehicles [ 2 ] diff tmp ) ;
9814: LD_ADDR_EXP 98
9818: PUSH
9819: LD_EXP 98
9823: PPUSH
9824: LD_INT 2
9826: PPUSH
9827: LD_EXP 98
9831: PUSH
9832: LD_INT 2
9834: ARRAY
9835: PUSH
9836: LD_VAR 0 2
9840: DIFF
9841: PPUSH
9842: CALL_OW 1
9846: ST_TO_ADDR
// target := rand ( 0 , 1 ) ;
9847: LD_ADDR_VAR 0 3
9851: PUSH
9852: LD_INT 0
9854: PPUSH
9855: LD_INT 1
9857: PPUSH
9858: CALL_OW 12
9862: ST_TO_ADDR
// if target then
9863: LD_VAR 0 3
9867: IFFALSE 9995
// begin repeat tmp := UnitFilter ( tmp , [ f_lives , 250 ] ) ;
9869: LD_ADDR_VAR 0 2
9873: PUSH
9874: LD_VAR 0 2
9878: PPUSH
9879: LD_INT 24
9881: PUSH
9882: LD_INT 250
9884: PUSH
9885: EMPTY
9886: LIST
9887: LIST
9888: PPUSH
9889: CALL_OW 72
9893: ST_TO_ADDR
// for i in tmp do
9894: LD_ADDR_VAR 0 1
9898: PUSH
9899: LD_VAR 0 2
9903: PUSH
9904: FOR_IN
9905: IFFALSE 9945
// if GetDistUnitXY ( i , 139 , 89 ) > 9 then
9907: LD_VAR 0 1
9911: PPUSH
9912: LD_INT 139
9914: PPUSH
9915: LD_INT 89
9917: PPUSH
9918: CALL_OW 297
9922: PUSH
9923: LD_INT 9
9925: GREATER
9926: IFFALSE 9943
// ComMoveXY ( i , 139 , 89 ) ;
9928: LD_VAR 0 1
9932: PPUSH
9933: LD_INT 139
9935: PPUSH
9936: LD_INT 89
9938: PPUSH
9939: CALL_OW 111
9943: GO 9904
9945: POP
9946: POP
// wait ( 0 0$1 ) ;
9947: LD_INT 35
9949: PPUSH
9950: CALL_OW 67
// until UnitFilter ( tmp , [ f_distxy , 139 , 89 , 9 ] ) >= ( tmp - 1 ) ;
9954: LD_VAR 0 2
9958: PPUSH
9959: LD_INT 92
9961: PUSH
9962: LD_INT 139
9964: PUSH
9965: LD_INT 89
9967: PUSH
9968: LD_INT 9
9970: PUSH
9971: EMPTY
9972: LIST
9973: LIST
9974: LIST
9975: LIST
9976: PPUSH
9977: CALL_OW 72
9981: PUSH
9982: LD_VAR 0 2
9986: PUSH
9987: LD_INT 1
9989: MINUS
9990: GREATEREQUAL
9991: IFFALSE 9869
// end else
9993: GO 10137
// begin ComEnterUnit ( tmp , teleport [ 1 ] ) ;
9995: LD_VAR 0 2
9999: PPUSH
10000: LD_VAR 0 4
10004: PUSH
10005: LD_INT 1
10007: ARRAY
10008: PPUSH
10009: CALL_OW 120
// repeat tmp := UnitFilter ( tmp , [ f_lives , 250 ] ) ;
10013: LD_ADDR_VAR 0 2
10017: PUSH
10018: LD_VAR 0 2
10022: PPUSH
10023: LD_INT 24
10025: PUSH
10026: LD_INT 250
10028: PUSH
10029: EMPTY
10030: LIST
10031: LIST
10032: PPUSH
10033: CALL_OW 72
10037: ST_TO_ADDR
// for i in tmp do
10038: LD_ADDR_VAR 0 1
10042: PUSH
10043: LD_VAR 0 2
10047: PUSH
10048: FOR_IN
10049: IFFALSE 10089
// if GetDistUnitXY ( i , 124 , 139 ) > 9 then
10051: LD_VAR 0 1
10055: PPUSH
10056: LD_INT 124
10058: PPUSH
10059: LD_INT 139
10061: PPUSH
10062: CALL_OW 297
10066: PUSH
10067: LD_INT 9
10069: GREATER
10070: IFFALSE 10087
// ComMoveXY ( i , 124 , 139 ) ;
10072: LD_VAR 0 1
10076: PPUSH
10077: LD_INT 124
10079: PPUSH
10080: LD_INT 139
10082: PPUSH
10083: CALL_OW 111
10087: GO 10048
10089: POP
10090: POP
// wait ( 0 0$1 ) ;
10091: LD_INT 35
10093: PPUSH
10094: CALL_OW 67
// until UnitFilter ( tmp , [ f_distxy , 124 , 139 , 9 ] ) >= ( tmp - 1 ) ;
10098: LD_VAR 0 2
10102: PPUSH
10103: LD_INT 92
10105: PUSH
10106: LD_INT 124
10108: PUSH
10109: LD_INT 139
10111: PUSH
10112: LD_INT 9
10114: PUSH
10115: EMPTY
10116: LIST
10117: LIST
10118: LIST
10119: LIST
10120: PPUSH
10121: CALL_OW 72
10125: PUSH
10126: LD_VAR 0 2
10130: PUSH
10131: LD_INT 1
10133: MINUS
10134: GREATEREQUAL
10135: IFFALSE 10013
// end ; repeat wait ( 0 0$1 ) ;
10137: LD_INT 35
10139: PPUSH
10140: CALL_OW 67
// for i in tmp do
10144: LD_ADDR_VAR 0 1
10148: PUSH
10149: LD_VAR 0 2
10153: PUSH
10154: FOR_IN
10155: IFFALSE 10288
// begin if GetLives ( i ) > 251 then
10157: LD_VAR 0 1
10161: PPUSH
10162: CALL_OW 256
10166: PUSH
10167: LD_INT 251
10169: GREATER
10170: IFFALSE 10259
// begin if GetWeapon ( i ) = ru_time_lapser then
10172: LD_VAR 0 1
10176: PPUSH
10177: CALL_OW 264
10181: PUSH
10182: LD_INT 49
10184: EQUAL
10185: IFFALSE 10223
// ComMoveUnit ( i , NearestUnitToUnit ( FilterAllUnits ( [ f_enemy , 3 ] ) , i ) ) else
10187: LD_VAR 0 1
10191: PPUSH
10192: LD_INT 81
10194: PUSH
10195: LD_INT 3
10197: PUSH
10198: EMPTY
10199: LIST
10200: LIST
10201: PPUSH
10202: CALL_OW 69
10206: PPUSH
10207: LD_VAR 0 1
10211: PPUSH
10212: CALL_OW 74
10216: PPUSH
10217: CALL_OW 112
10221: GO 10257
// ComAttackUnit ( i , NearestUnitToUnit ( FilterAllUnits ( [ f_enemy , 3 ] ) , i ) ) ;
10223: LD_VAR 0 1
10227: PPUSH
10228: LD_INT 81
10230: PUSH
10231: LD_INT 3
10233: PUSH
10234: EMPTY
10235: LIST
10236: LIST
10237: PPUSH
10238: CALL_OW 69
10242: PPUSH
10243: LD_VAR 0 1
10247: PPUSH
10248: CALL_OW 74
10252: PPUSH
10253: CALL_OW 115
// end else
10257: GO 10286
// if IsDead ( i ) then
10259: LD_VAR 0 1
10263: PPUSH
10264: CALL_OW 301
10268: IFFALSE 10286
// tmp := tmp diff i ;
10270: LD_ADDR_VAR 0 2
10274: PUSH
10275: LD_VAR 0 2
10279: PUSH
10280: LD_VAR 0 1
10284: DIFF
10285: ST_TO_ADDR
// end ;
10286: GO 10154
10288: POP
10289: POP
// until not tmp ;
10290: LD_VAR 0 2
10294: NOT
10295: IFFALSE 10137
// end ;
10297: PPOPN 4
10299: END
// every 30 30$00 trigger not russianDestroyed do
10300: LD_EXP 2
10304: NOT
10305: IFFALSE 10370
10307: GO 10309
10309: DISABLE
// begin wait ( [ 50 50$00 , 40 40$00 , 30 30$00 ] [ Difficulty ] ) ;
10310: LD_INT 105000
10312: PUSH
10313: LD_INT 84000
10315: PUSH
10316: LD_INT 63000
10318: PUSH
10319: EMPTY
10320: LIST
10321: LIST
10322: LIST
10323: PUSH
10324: LD_OWVAR 67
10328: ARRAY
10329: PPUSH
10330: CALL_OW 67
// if russianDestroyed then
10334: LD_EXP 2
10338: IFFALSE 10342
// exit ;
10340: GO 10370
// MC_InsertProduceList ( 2 , [ [ ru_heavy_wheeled , engine_siberite , control_manual , ru_siberium_rocket ] ] ) ;
10342: LD_INT 2
10344: PPUSH
10345: LD_INT 23
10347: PUSH
10348: LD_INT 3
10350: PUSH
10351: LD_INT 1
10353: PUSH
10354: LD_INT 48
10356: PUSH
10357: EMPTY
10358: LIST
10359: LIST
10360: LIST
10361: LIST
10362: PUSH
10363: EMPTY
10364: LIST
10365: PPUSH
10366: CALL 44202 0 2
// end ; end_of_file
10370: END
// export function CustomEvent ( event ) ; begin
10371: LD_INT 0
10373: PPUSH
// end ;
10374: LD_VAR 0 2
10378: RET
// on SibDepositContaminated ( unit , x , y ) do begin if InArea ( x , y , motherLodeArea ) then
10379: LD_VAR 0 2
10383: PPUSH
10384: LD_VAR 0 3
10388: PPUSH
10389: LD_INT 15
10391: PPUSH
10392: CALL_OW 309
10396: IFFALSE 10405
// YouLost ( MothContaminate ) ;
10398: LD_STRING MothContaminate
10400: PPUSH
10401: CALL_OW 104
// end ;
10405: PPOPN 3
10407: END
// on SiberiteRocketExploded ( unit , x , y ) do begin if InArea ( x , y , motherLodeArea ) then
10408: LD_VAR 0 2
10412: PPUSH
10413: LD_VAR 0 3
10417: PPUSH
10418: LD_INT 15
10420: PPUSH
10421: CALL_OW 309
10425: IFFALSE 10441
// begin wait ( 0 0$6 ) ;
10427: LD_INT 210
10429: PPUSH
10430: CALL_OW 67
// YouLost ( MothContaminateBomb ) ;
10434: LD_STRING MothContaminateBomb
10436: PPUSH
10437: CALL_OW 104
// end ; end ;
10441: PPOPN 3
10443: END
// on UnitDestroyed ( un ) do begin if un = JMM then
10444: LD_VAR 0 1
10448: PUSH
10449: LD_EXP 17
10453: EQUAL
10454: IFFALSE 10465
// begin YouLost ( JMM ) ;
10456: LD_STRING JMM
10458: PPUSH
10459: CALL_OW 104
// exit ;
10463: GO 10564
// end ; if un = Powell then
10465: LD_VAR 0 1
10469: PUSH
10470: LD_EXP 52
10474: EQUAL
10475: IFFALSE 10485
// americanDestroyed := true ;
10477: LD_ADDR_EXP 4
10481: PUSH
10482: LD_INT 1
10484: ST_TO_ADDR
// if un = Platonov then
10485: LD_VAR 0 1
10489: PUSH
10490: LD_EXP 56
10494: EQUAL
10495: IFFALSE 10505
// russianDestroyed := true ;
10497: LD_ADDR_EXP 2
10501: PUSH
10502: LD_INT 1
10504: ST_TO_ADDR
// if un in FilterAllUnits ( [ [ f_side , 7 ] , [ f_type , unit_vehicle ] ] ) then
10505: LD_VAR 0 1
10509: PUSH
10510: LD_INT 22
10512: PUSH
10513: LD_INT 7
10515: PUSH
10516: EMPTY
10517: LIST
10518: LIST
10519: PUSH
10520: LD_INT 21
10522: PUSH
10523: LD_INT 2
10525: PUSH
10526: EMPTY
10527: LIST
10528: LIST
10529: PUSH
10530: EMPTY
10531: LIST
10532: LIST
10533: PPUSH
10534: CALL_OW 69
10538: IN
10539: IFFALSE 10555
// vehicleLostCounter := vehicleLostCounter + 1 ;
10541: LD_ADDR_EXP 15
10545: PUSH
10546: LD_EXP 15
10550: PUSH
10551: LD_INT 1
10553: PLUS
10554: ST_TO_ADDR
// MCE_UnitDestroyed ( un ) ;
10555: LD_VAR 0 1
10559: PPUSH
10560: CALL 47594 0 1
// end ;
10564: PPOPN 1
10566: END
// on BuildingStarted ( building , builder ) do begin MCE_BuildingStarted ( building , builder ) ;
10567: LD_VAR 0 1
10571: PPUSH
10572: LD_VAR 0 2
10576: PPUSH
10577: CALL 49928 0 2
// end ;
10581: PPOPN 2
10583: END
// on UpgradeComplete ( building ) do begin MCE_UpgradeComplete ( building ) ;
10584: LD_VAR 0 1
10588: PPUSH
10589: CALL 48996 0 1
// end ;
10593: PPOPN 1
10595: END
// on BuildingComplete ( building ) do begin if building in FilterAllUnits ( [ [ f_side , 8 ] , [ f_btype , b_workshop ] , [ f_nation , 3 ] ] ) then
10596: LD_VAR 0 1
10600: PUSH
10601: LD_INT 22
10603: PUSH
10604: LD_INT 8
10606: PUSH
10607: EMPTY
10608: LIST
10609: LIST
10610: PUSH
10611: LD_INT 30
10613: PUSH
10614: LD_INT 2
10616: PUSH
10617: EMPTY
10618: LIST
10619: LIST
10620: PUSH
10621: LD_INT 23
10623: PUSH
10624: LD_INT 3
10626: PUSH
10627: EMPTY
10628: LIST
10629: LIST
10630: PUSH
10631: EMPTY
10632: LIST
10633: LIST
10634: LIST
10635: PPUSH
10636: CALL_OW 69
10640: IN
10641: IFFALSE 10668
// begin ComUpgrade ( building ) ;
10643: LD_VAR 0 1
10647: PPUSH
10648: CALL_OW 146
// ComComplete ( Kozlov , building ) ;
10652: LD_EXP 55
10656: PPUSH
10657: LD_VAR 0 1
10661: PPUSH
10662: CALL 60634 0 2
// exit ;
10666: GO 10677
// end ; MCE_BuildingComplete ( building ) ;
10668: LD_VAR 0 1
10672: PPUSH
10673: CALL 49237 0 1
// end ;
10677: PPOPN 1
10679: END
// on ResearchComplete ( tech , lab ) do begin MCE_ResearchComplete ( tech , lab ) ;
10680: LD_VAR 0 1
10684: PPUSH
10685: LD_VAR 0 2
10689: PPUSH
10690: CALL 47290 0 2
// end ;
10694: PPOPN 2
10696: END
// on CrateSpawn ( id , x , y , amount , mode ) do begin MCE_CrateSpawn ( id , x , y , amount , mode ) ;
10697: LD_VAR 0 1
10701: PPUSH
10702: LD_VAR 0 2
10706: PPUSH
10707: LD_VAR 0 3
10711: PPUSH
10712: LD_VAR 0 4
10716: PPUSH
10717: LD_VAR 0 5
10721: PPUSH
10722: CALL 46910 0 5
// end ;
10726: PPOPN 5
10728: END
// on VehicleConstructed ( vehicle , factory ) do begin MCE_VehicleConstructed ( vehicle , factory ) ;
10729: LD_VAR 0 1
10733: PPUSH
10734: LD_VAR 0 2
10738: PPUSH
10739: CALL 46506 0 2
// end ;
10743: PPOPN 2
10745: END
// on VehicleCaptured ( new , old , side , capturing_unit ) do begin MCE_VehicleCaptured ( new , old , side , capturing_unit ) ;
10746: LD_VAR 0 1
10750: PPUSH
10751: LD_VAR 0 2
10755: PPUSH
10756: LD_VAR 0 3
10760: PPUSH
10761: LD_VAR 0 4
10765: PPUSH
10766: CALL 46344 0 4
// end ;
10770: PPOPN 4
10772: END
// on BuildingCaptured ( building , side , capturning_unit ) do begin MCE_BuildingCaptured ( building , side , capturning_unit ) ;
10773: LD_VAR 0 1
10777: PPUSH
10778: LD_VAR 0 2
10782: PPUSH
10783: LD_VAR 0 3
10787: PPUSH
10788: CALL 46119 0 3
// end ;
10792: PPOPN 3
10794: END
// on EnterBuilding ( building , unit ) do begin MCE_EnterBuilding ( building , unit ) ;
10795: LD_VAR 0 1
10799: PPUSH
10800: LD_VAR 0 2
10804: PPUSH
10805: CALL 46004 0 2
// end ;
10809: PPOPN 2
10811: END
// on LeaveBuilding ( building , unit ) do begin MCE_LeaveBuilding ( building , unit ) ;
10812: LD_VAR 0 1
10816: PPUSH
10817: LD_VAR 0 2
10821: PPUSH
10822: CALL 50189 0 2
// end ;
10826: PPOPN 2
10828: END
// on EvacuateVehicle ( driver , abandoned_vehicle , unknown1 , unknown2 ) do begin MCE_EvacuateVehicle ( driver , abandoned_vehicle , unknown1 , unknown2 ) ;
10829: LD_VAR 0 1
10833: PPUSH
10834: LD_VAR 0 2
10838: PPUSH
10839: LD_VAR 0 3
10843: PPUSH
10844: LD_VAR 0 4
10848: PPUSH
10849: CALL 50405 0 4
// end ;
10853: PPOPN 4
10855: END
// on ApemanTamed ( ape , sci ) do begin MCE_ApemanTamed ( ape , sci ) ;
10856: LD_VAR 0 1
10860: PPUSH
10861: LD_VAR 0 2
10865: PPUSH
10866: CALL 45813 0 2
// end ;
10870: PPOPN 2
10872: END
// on Command ( cmd ) do begin SOS_Command ( cmd ) ;
10873: LD_VAR 0 1
10877: PPUSH
10878: CALL 104655 0 1
// end ; end_of_file
10882: PPOPN 1
10884: END
// export function Action ; begin
10885: LD_INT 0
10887: PPUSH
// InGameOn ;
10888: CALL_OW 8
// CenterNowOnXY ( 206 , 11 ) ;
10892: LD_INT 206
10894: PPUSH
10895: LD_INT 11
10897: PPUSH
10898: CALL_OW 86
// wait ( 0 0$1 ) ;
10902: LD_INT 35
10904: PPUSH
10905: CALL_OW 67
// Say ( JMM , DStart-JMM-JMM-1 ) ;
10909: LD_EXP 17
10913: PPUSH
10914: LD_STRING DStart-JMM-JMM-1
10916: PPUSH
10917: CALL_OW 88
// Say ( Burlak , DStart-JMM-Bur-1 ) ;
10921: LD_EXP 49
10925: PPUSH
10926: LD_STRING DStart-JMM-Bur-1
10928: PPUSH
10929: CALL_OW 88
// Say ( JMM , DStart-JMM-JMM-2 ) ;
10933: LD_EXP 17
10937: PPUSH
10938: LD_STRING DStart-JMM-JMM-2
10940: PPUSH
10941: CALL_OW 88
// Say ( Burlak , DStart-JMM-Bur-2 ) ;
10945: LD_EXP 49
10949: PPUSH
10950: LD_STRING DStart-JMM-Bur-2
10952: PPUSH
10953: CALL_OW 88
// InGameOff ;
10957: CALL_OW 9
// ChangeMissionObjectives ( MStart ) ;
10961: LD_STRING MStart
10963: PPUSH
10964: CALL_OW 337
// end ;
10968: LD_VAR 0 1
10972: RET
// every 0 0$2 trigger SeeXY ( 7 , 255 , 219 ) do var speaker ;
10973: LD_INT 7
10975: PPUSH
10976: LD_INT 255
10978: PPUSH
10979: LD_INT 219
10981: PPUSH
10982: CALL_OW 293
10986: IFFALSE 11595
10988: GO 10990
10990: DISABLE
10991: LD_INT 0
10993: PPUSH
// begin wait ( 0 0$3 ) ;
10994: LD_INT 105
10996: PPUSH
10997: CALL_OW 67
// alienSpotted := true ;
11001: LD_ADDR_EXP 10
11005: PUSH
11006: LD_INT 1
11008: ST_TO_ADDR
// speaker := FilterAllUnits ( [ [ f_side , 7 ] , [ f_nation , 3 ] , [ f_type , unit_human ] , [ f_sex , sex_male ] ] ) diff [ Burlak , Titov , Dolgov , Petrosyan , Kuzmov , Kovalyuk , Scholtze ] ;
11009: LD_ADDR_VAR 0 1
11013: PUSH
11014: LD_INT 22
11016: PUSH
11017: LD_INT 7
11019: PUSH
11020: EMPTY
11021: LIST
11022: LIST
11023: PUSH
11024: LD_INT 23
11026: PUSH
11027: LD_INT 3
11029: PUSH
11030: EMPTY
11031: LIST
11032: LIST
11033: PUSH
11034: LD_INT 21
11036: PUSH
11037: LD_INT 1
11039: PUSH
11040: EMPTY
11041: LIST
11042: LIST
11043: PUSH
11044: LD_INT 26
11046: PUSH
11047: LD_INT 1
11049: PUSH
11050: EMPTY
11051: LIST
11052: LIST
11053: PUSH
11054: EMPTY
11055: LIST
11056: LIST
11057: LIST
11058: LIST
11059: PPUSH
11060: CALL_OW 69
11064: PUSH
11065: LD_EXP 49
11069: PUSH
11070: LD_EXP 37
11074: PUSH
11075: LD_EXP 39
11079: PUSH
11080: LD_EXP 40
11084: PUSH
11085: LD_EXP 47
11089: PUSH
11090: LD_EXP 46
11094: PUSH
11095: LD_EXP 41
11099: PUSH
11100: EMPTY
11101: LIST
11102: LIST
11103: LIST
11104: LIST
11105: LIST
11106: LIST
11107: LIST
11108: DIFF
11109: ST_TO_ADDR
// DialogueOn ;
11110: CALL_OW 6
// PlaceSeeing ( 255 , 219 , 7 , - 20 ) ;
11114: LD_INT 255
11116: PPUSH
11117: LD_INT 219
11119: PPUSH
11120: LD_INT 7
11122: PPUSH
11123: LD_INT 20
11125: NEG
11126: PPUSH
11127: CALL_OW 330
// CenterNowOnXY ( 255 , 219 ) ;
11131: LD_INT 255
11133: PPUSH
11134: LD_INT 219
11136: PPUSH
11137: CALL_OW 86
// if speaker then
11141: LD_VAR 0 1
11145: IFFALSE 11163
// Say ( speaker [ 1 ] , DAlienBase-RSol1-1 ) ;
11147: LD_VAR 0 1
11151: PUSH
11152: LD_INT 1
11154: ARRAY
11155: PPUSH
11156: LD_STRING DAlienBase-RSol1-1
11158: PPUSH
11159: CALL_OW 88
// Say ( JMM , DAlienBase-JMM-1 ) ;
11163: LD_EXP 17
11167: PPUSH
11168: LD_STRING DAlienBase-JMM-1
11170: PPUSH
11171: CALL_OW 88
// if IsOk ( Burlak ) then
11175: LD_EXP 49
11179: PPUSH
11180: CALL_OW 302
11184: IFFALSE 11205
// begin dwait ( 0 0$1 ) ;
11186: LD_INT 35
11188: PPUSH
11189: CALL_OW 68
// Say ( Burlak , DAlienBase-Bur-1 ) ;
11193: LD_EXP 49
11197: PPUSH
11198: LD_STRING DAlienBase-Bur-1
11200: PPUSH
11201: CALL_OW 88
// end ; if IsOk ( Roth ) then
11205: LD_EXP 18
11209: PPUSH
11210: CALL_OW 302
11214: IFFALSE 11228
// Say ( Roth , DAlienBase-Roth-1 ) ;
11216: LD_EXP 18
11220: PPUSH
11221: LD_STRING DAlienBase-Roth-1
11223: PPUSH
11224: CALL_OW 88
// if IsOk ( Gossudarov ) then
11228: LD_EXP 35
11232: PPUSH
11233: CALL_OW 302
11237: IFFALSE 11253
// Say ( Gossudarov , DAlienBase-Gos-1 ) else
11239: LD_EXP 35
11243: PPUSH
11244: LD_STRING DAlienBase-Gos-1
11246: PPUSH
11247: CALL_OW 88
11251: GO 11370
// begin speaker := FilterAllUnits ( [ [ f_side , 7 ] , [ f_class , 4 ] , [ f_type , unit_human ] , [ f_sex , sex_male ] ] ) diff [ Roth , JMM , Burlak , Titov , Kuzmov , Kovalyuk ] ;
11253: LD_ADDR_VAR 0 1
11257: PUSH
11258: LD_INT 22
11260: PUSH
11261: LD_INT 7
11263: PUSH
11264: EMPTY
11265: LIST
11266: LIST
11267: PUSH
11268: LD_INT 25
11270: PUSH
11271: LD_INT 4
11273: PUSH
11274: EMPTY
11275: LIST
11276: LIST
11277: PUSH
11278: LD_INT 21
11280: PUSH
11281: LD_INT 1
11283: PUSH
11284: EMPTY
11285: LIST
11286: LIST
11287: PUSH
11288: LD_INT 26
11290: PUSH
11291: LD_INT 1
11293: PUSH
11294: EMPTY
11295: LIST
11296: LIST
11297: PUSH
11298: EMPTY
11299: LIST
11300: LIST
11301: LIST
11302: LIST
11303: PPUSH
11304: CALL_OW 69
11308: PUSH
11309: LD_EXP 18
11313: PUSH
11314: LD_EXP 17
11318: PUSH
11319: LD_EXP 49
11323: PUSH
11324: LD_EXP 37
11328: PUSH
11329: LD_EXP 47
11333: PUSH
11334: LD_EXP 46
11338: PUSH
11339: EMPTY
11340: LIST
11341: LIST
11342: LIST
11343: LIST
11344: LIST
11345: LIST
11346: DIFF
11347: ST_TO_ADDR
// if speaker then
11348: LD_VAR 0 1
11352: IFFALSE 11370
// Say ( speaker [ 1 ] , DAlienBase-Sci1-1 ) ;
11354: LD_VAR 0 1
11358: PUSH
11359: LD_INT 1
11361: ARRAY
11362: PPUSH
11363: LD_STRING DAlienBase-Sci1-1
11365: PPUSH
11366: CALL_OW 88
// end ; RemoveSeeing ( 255 , 219 , 7 ) ;
11370: LD_INT 255
11372: PPUSH
11373: LD_INT 219
11375: PPUSH
11376: LD_INT 7
11378: PPUSH
11379: CALL_OW 331
// DialogueOff ;
11383: CALL_OW 7
// repeat wait ( 0 0$1 ) ;
11387: LD_INT 35
11389: PPUSH
11390: CALL_OW 67
// until IsSelected ( alien ) ;
11394: LD_INT 1
11396: PPUSH
11397: CALL_OW 306
11401: IFFALSE 11387
// if not artifactIResearched or not artifactIIResearched then
11403: LD_EXP 12
11407: NOT
11408: PUSH
11409: LD_EXP 13
11413: NOT
11414: OR
11415: IFFALSE 11595
// begin if IsOk ( Roth ) then
11417: LD_EXP 18
11421: PPUSH
11422: CALL_OW 302
11426: IFFALSE 11442
// Say ( Roth , DAlieBaseNotReady-Roth-1 ) else
11428: LD_EXP 18
11432: PPUSH
11433: LD_STRING DAlieBaseNotReady-Roth-1
11435: PPUSH
11436: CALL_OW 88
11440: GO 11595
// if IsOk ( Gossudarov ) then
11442: LD_EXP 35
11446: PPUSH
11447: CALL_OW 302
11451: IFFALSE 11467
// Say ( Gossudarov , DAlieBaseNotReady-Gos-1 ) else
11453: LD_EXP 35
11457: PPUSH
11458: LD_STRING DAlieBaseNotReady-Gos-1
11460: PPUSH
11461: CALL_OW 88
11465: GO 11595
// begin speaker := FilterAllUnits ( [ [ f_side , 7 ] , [ f_nation , 3 ] , [ f_class , 4 ] , [ f_type , unit_human ] , [ f_sex , sex_male ] ] ) diff [ Roth , JMM , Burlak , Titov , Kuzmov , Kovalyuk ] ;
11467: LD_ADDR_VAR 0 1
11471: PUSH
11472: LD_INT 22
11474: PUSH
11475: LD_INT 7
11477: PUSH
11478: EMPTY
11479: LIST
11480: LIST
11481: PUSH
11482: LD_INT 23
11484: PUSH
11485: LD_INT 3
11487: PUSH
11488: EMPTY
11489: LIST
11490: LIST
11491: PUSH
11492: LD_INT 25
11494: PUSH
11495: LD_INT 4
11497: PUSH
11498: EMPTY
11499: LIST
11500: LIST
11501: PUSH
11502: LD_INT 21
11504: PUSH
11505: LD_INT 1
11507: PUSH
11508: EMPTY
11509: LIST
11510: LIST
11511: PUSH
11512: LD_INT 26
11514: PUSH
11515: LD_INT 1
11517: PUSH
11518: EMPTY
11519: LIST
11520: LIST
11521: PUSH
11522: EMPTY
11523: LIST
11524: LIST
11525: LIST
11526: LIST
11527: LIST
11528: PPUSH
11529: CALL_OW 69
11533: PUSH
11534: LD_EXP 18
11538: PUSH
11539: LD_EXP 17
11543: PUSH
11544: LD_EXP 49
11548: PUSH
11549: LD_EXP 37
11553: PUSH
11554: LD_EXP 47
11558: PUSH
11559: LD_EXP 46
11563: PUSH
11564: EMPTY
11565: LIST
11566: LIST
11567: LIST
11568: LIST
11569: LIST
11570: LIST
11571: DIFF
11572: ST_TO_ADDR
// if speaker then
11573: LD_VAR 0 1
11577: IFFALSE 11595
// Say ( speaker [ 1 ] , DAlieBaseNotReady-RSci1-1 ) ;
11579: LD_VAR 0 1
11583: PUSH
11584: LD_INT 1
11586: ARRAY
11587: PPUSH
11588: LD_STRING DAlieBaseNotReady-RSci1-1
11590: PPUSH
11591: CALL_OW 88
// end ; end ; end ;
11595: PPOPN 1
11597: END
// every 0 0$1 trigger GetTech ( tech_Artifact , 7 ) = state_researched do var speaker ;
11598: LD_INT 24
11600: PPUSH
11601: LD_INT 7
11603: PPUSH
11604: CALL_OW 321
11608: PUSH
11609: LD_INT 2
11611: EQUAL
11612: IFFALSE 12303
11614: GO 11616
11616: DISABLE
11617: LD_INT 0
11619: PPUSH
// begin speaker := FilterAllUnits ( [ [ f_side , 7 ] , [ f_nation , 3 ] , [ f_class , 4 ] , [ f_type , unit_human ] , [ f_sex , sex_male ] ] ) diff [ Roth , JMM , Burlak , Titov , Kuzmov , Kovalyuk ] ;
11620: LD_ADDR_VAR 0 1
11624: PUSH
11625: LD_INT 22
11627: PUSH
11628: LD_INT 7
11630: PUSH
11631: EMPTY
11632: LIST
11633: LIST
11634: PUSH
11635: LD_INT 23
11637: PUSH
11638: LD_INT 3
11640: PUSH
11641: EMPTY
11642: LIST
11643: LIST
11644: PUSH
11645: LD_INT 25
11647: PUSH
11648: LD_INT 4
11650: PUSH
11651: EMPTY
11652: LIST
11653: LIST
11654: PUSH
11655: LD_INT 21
11657: PUSH
11658: LD_INT 1
11660: PUSH
11661: EMPTY
11662: LIST
11663: LIST
11664: PUSH
11665: LD_INT 26
11667: PUSH
11668: LD_INT 1
11670: PUSH
11671: EMPTY
11672: LIST
11673: LIST
11674: PUSH
11675: EMPTY
11676: LIST
11677: LIST
11678: LIST
11679: LIST
11680: LIST
11681: PPUSH
11682: CALL_OW 69
11686: PUSH
11687: LD_EXP 18
11691: PUSH
11692: LD_EXP 17
11696: PUSH
11697: LD_EXP 49
11701: PUSH
11702: LD_EXP 37
11706: PUSH
11707: LD_EXP 47
11711: PUSH
11712: LD_EXP 46
11716: PUSH
11717: EMPTY
11718: LIST
11719: LIST
11720: LIST
11721: LIST
11722: LIST
11723: LIST
11724: DIFF
11725: ST_TO_ADDR
// if not speaker then
11726: LD_VAR 0 1
11730: NOT
11731: IFFALSE 11735
// exit ;
11733: GO 12303
// DialogueOn ;
11735: CALL_OW 6
// Say ( speaker [ 1 ] , DArtefTechnology-RSci1-1 ) ;
11739: LD_VAR 0 1
11743: PUSH
11744: LD_INT 1
11746: ARRAY
11747: PPUSH
11748: LD_STRING DArtefTechnology-RSci1-1
11750: PPUSH
11751: CALL_OW 88
// if IsOk ( Burlak ) then
11755: LD_EXP 49
11759: PPUSH
11760: CALL_OW 302
11764: IFFALSE 11778
// Say ( Burlak , DArtefTechnology-Bur-1 ) ;
11766: LD_EXP 49
11770: PPUSH
11771: LD_STRING DArtefTechnology-Bur-1
11773: PPUSH
11774: CALL_OW 88
// Say ( speaker [ 1 ] , DArtefTechnology-RSci1-2 ) ;
11778: LD_VAR 0 1
11782: PUSH
11783: LD_INT 1
11785: ARRAY
11786: PPUSH
11787: LD_STRING DArtefTechnology-RSci1-2
11789: PPUSH
11790: CALL_OW 88
// if Denis then
11794: LD_EXP 23
11798: IFFALSE 11815
// speaker := [ Denis ] else
11800: LD_ADDR_VAR 0 1
11804: PUSH
11805: LD_EXP 23
11809: PUSH
11810: EMPTY
11811: LIST
11812: ST_TO_ADDR
11813: GO 11921
// speaker := FilterAllUnits ( [ [ f_side , 7 ] , [ f_nation , 1 ] , [ f_class , 4 ] , [ f_type , unit_human ] , [ f_sex , sex_male ] ] ) diff [ Roth , JMM , Burlak , Titov , Kuzmov , Kovalyuk ] ;
11815: LD_ADDR_VAR 0 1
11819: PUSH
11820: LD_INT 22
11822: PUSH
11823: LD_INT 7
11825: PUSH
11826: EMPTY
11827: LIST
11828: LIST
11829: PUSH
11830: LD_INT 23
11832: PUSH
11833: LD_INT 1
11835: PUSH
11836: EMPTY
11837: LIST
11838: LIST
11839: PUSH
11840: LD_INT 25
11842: PUSH
11843: LD_INT 4
11845: PUSH
11846: EMPTY
11847: LIST
11848: LIST
11849: PUSH
11850: LD_INT 21
11852: PUSH
11853: LD_INT 1
11855: PUSH
11856: EMPTY
11857: LIST
11858: LIST
11859: PUSH
11860: LD_INT 26
11862: PUSH
11863: LD_INT 1
11865: PUSH
11866: EMPTY
11867: LIST
11868: LIST
11869: PUSH
11870: EMPTY
11871: LIST
11872: LIST
11873: LIST
11874: LIST
11875: LIST
11876: PPUSH
11877: CALL_OW 69
11881: PUSH
11882: LD_EXP 18
11886: PUSH
11887: LD_EXP 17
11891: PUSH
11892: LD_EXP 49
11896: PUSH
11897: LD_EXP 37
11901: PUSH
11902: LD_EXP 47
11906: PUSH
11907: LD_EXP 46
11911: PUSH
11912: EMPTY
11913: LIST
11914: LIST
11915: LIST
11916: LIST
11917: LIST
11918: LIST
11919: DIFF
11920: ST_TO_ADDR
// if speaker then
11921: LD_VAR 0 1
11925: IFFALSE 11943
// Say ( speaker [ 1 ] , DArtefTechnology-Sci1-2 ) ;
11927: LD_VAR 0 1
11931: PUSH
11932: LD_INT 1
11934: ARRAY
11935: PPUSH
11936: LD_STRING DArtefTechnology-Sci1-2
11938: PPUSH
11939: CALL_OW 88
// speaker := FilterAllUnits ( [ [ f_side , 7 ] , [ f_nation , 3 ] , [ f_class , 4 ] , [ f_type , unit_human ] , [ f_sex , sex_male ] ] ) diff [ Roth , JMM , Burlak , Titov , Kuzmov , Kovalyuk ] ;
11943: LD_ADDR_VAR 0 1
11947: PUSH
11948: LD_INT 22
11950: PUSH
11951: LD_INT 7
11953: PUSH
11954: EMPTY
11955: LIST
11956: LIST
11957: PUSH
11958: LD_INT 23
11960: PUSH
11961: LD_INT 3
11963: PUSH
11964: EMPTY
11965: LIST
11966: LIST
11967: PUSH
11968: LD_INT 25
11970: PUSH
11971: LD_INT 4
11973: PUSH
11974: EMPTY
11975: LIST
11976: LIST
11977: PUSH
11978: LD_INT 21
11980: PUSH
11981: LD_INT 1
11983: PUSH
11984: EMPTY
11985: LIST
11986: LIST
11987: PUSH
11988: LD_INT 26
11990: PUSH
11991: LD_INT 1
11993: PUSH
11994: EMPTY
11995: LIST
11996: LIST
11997: PUSH
11998: EMPTY
11999: LIST
12000: LIST
12001: LIST
12002: LIST
12003: LIST
12004: PPUSH
12005: CALL_OW 69
12009: PUSH
12010: LD_EXP 18
12014: PUSH
12015: LD_EXP 17
12019: PUSH
12020: LD_EXP 49
12024: PUSH
12025: LD_EXP 37
12029: PUSH
12030: LD_EXP 47
12034: PUSH
12035: LD_EXP 46
12039: PUSH
12040: EMPTY
12041: LIST
12042: LIST
12043: LIST
12044: LIST
12045: LIST
12046: LIST
12047: DIFF
12048: ST_TO_ADDR
// if speaker and ( artifactArCaptured or arabianDestroyed ) then
12049: LD_VAR 0 1
12053: PUSH
12054: LD_EXP 9
12058: PUSH
12059: LD_EXP 5
12063: OR
12064: AND
12065: IFFALSE 12299
// begin if arabianDestroyed and IsOk ( Burlak ) then
12067: LD_EXP 5
12071: PUSH
12072: LD_EXP 49
12076: PPUSH
12077: CALL_OW 302
12081: AND
12082: IFFALSE 12098
// Say ( Burlak , DArtefTechnology-Bur-2 ) else
12084: LD_EXP 49
12088: PPUSH
12089: LD_STRING DArtefTechnology-Bur-2
12091: PPUSH
12092: CALL_OW 88
12096: GO 12110
// Say ( JMM , DArtefTechnology-JMM-2 ) ;
12098: LD_EXP 17
12102: PPUSH
12103: LD_STRING DArtefTechnology-JMM-2
12105: PPUSH
12106: CALL_OW 88
// Say ( speaker [ 1 ] , DArtefTechnology-RSci1-3 ) ;
12110: LD_VAR 0 1
12114: PUSH
12115: LD_INT 1
12117: ARRAY
12118: PPUSH
12119: LD_STRING DArtefTechnology-RSci1-3
12121: PPUSH
12122: CALL_OW 88
// if Denis then
12126: LD_EXP 23
12130: IFFALSE 12147
// speaker := [ Denis ] else
12132: LD_ADDR_VAR 0 1
12136: PUSH
12137: LD_EXP 23
12141: PUSH
12142: EMPTY
12143: LIST
12144: ST_TO_ADDR
12145: GO 12253
// speaker := FilterAllUnits ( [ [ f_side , 7 ] , [ f_nation , 1 ] , [ f_class , 4 ] , [ f_type , unit_human ] , [ f_sex , sex_male ] ] ) diff [ Roth , JMM , Burlak , Titov , Kuzmov , Kovalyuk ] ;
12147: LD_ADDR_VAR 0 1
12151: PUSH
12152: LD_INT 22
12154: PUSH
12155: LD_INT 7
12157: PUSH
12158: EMPTY
12159: LIST
12160: LIST
12161: PUSH
12162: LD_INT 23
12164: PUSH
12165: LD_INT 1
12167: PUSH
12168: EMPTY
12169: LIST
12170: LIST
12171: PUSH
12172: LD_INT 25
12174: PUSH
12175: LD_INT 4
12177: PUSH
12178: EMPTY
12179: LIST
12180: LIST
12181: PUSH
12182: LD_INT 21
12184: PUSH
12185: LD_INT 1
12187: PUSH
12188: EMPTY
12189: LIST
12190: LIST
12191: PUSH
12192: LD_INT 26
12194: PUSH
12195: LD_INT 1
12197: PUSH
12198: EMPTY
12199: LIST
12200: LIST
12201: PUSH
12202: EMPTY
12203: LIST
12204: LIST
12205: LIST
12206: LIST
12207: LIST
12208: PPUSH
12209: CALL_OW 69
12213: PUSH
12214: LD_EXP 18
12218: PUSH
12219: LD_EXP 17
12223: PUSH
12224: LD_EXP 49
12228: PUSH
12229: LD_EXP 37
12233: PUSH
12234: LD_EXP 47
12238: PUSH
12239: LD_EXP 46
12243: PUSH
12244: EMPTY
12245: LIST
12246: LIST
12247: LIST
12248: LIST
12249: LIST
12250: LIST
12251: DIFF
12252: ST_TO_ADDR
// if speaker then
12253: LD_VAR 0 1
12257: IFFALSE 12299
// if alienSpotted then
12259: LD_EXP 10
12263: IFFALSE 12283
// Say ( speaker [ 1 ] , DArtefTechnology-Sci1-3 ) else
12265: LD_VAR 0 1
12269: PUSH
12270: LD_INT 1
12272: ARRAY
12273: PPUSH
12274: LD_STRING DArtefTechnology-Sci1-3
12276: PPUSH
12277: CALL_OW 88
12281: GO 12299
// Say ( speaker [ 1 ] , DArtefTechnology-Sci1-3a ) ;
12283: LD_VAR 0 1
12287: PUSH
12288: LD_INT 1
12290: ARRAY
12291: PPUSH
12292: LD_STRING DArtefTechnology-Sci1-3a
12294: PPUSH
12295: CALL_OW 88
// end ; DialogueOff ;
12299: CALL_OW 7
// end ;
12303: PPOPN 1
12305: END
// every 0 0$1 trigger artifactIResearched do var speaker ;
12306: LD_EXP 12
12310: IFFALSE 12505
12312: GO 12314
12314: DISABLE
12315: LD_INT 0
12317: PPUSH
// begin if Denis then
12318: LD_EXP 23
12322: IFFALSE 12339
// speaker := [ Denis ] else
12324: LD_ADDR_VAR 0 1
12328: PUSH
12329: LD_EXP 23
12333: PUSH
12334: EMPTY
12335: LIST
12336: ST_TO_ADDR
12337: GO 12445
// speaker := FilterAllUnits ( [ [ f_side , 7 ] , [ f_nation , 1 ] , [ f_class , 4 ] , [ f_type , unit_human ] , [ f_sex , sex_male ] ] ) diff [ Roth , JMM , Burlak , Titov , Kuzmov , Kovalyuk ] ;
12339: LD_ADDR_VAR 0 1
12343: PUSH
12344: LD_INT 22
12346: PUSH
12347: LD_INT 7
12349: PUSH
12350: EMPTY
12351: LIST
12352: LIST
12353: PUSH
12354: LD_INT 23
12356: PUSH
12357: LD_INT 1
12359: PUSH
12360: EMPTY
12361: LIST
12362: LIST
12363: PUSH
12364: LD_INT 25
12366: PUSH
12367: LD_INT 4
12369: PUSH
12370: EMPTY
12371: LIST
12372: LIST
12373: PUSH
12374: LD_INT 21
12376: PUSH
12377: LD_INT 1
12379: PUSH
12380: EMPTY
12381: LIST
12382: LIST
12383: PUSH
12384: LD_INT 26
12386: PUSH
12387: LD_INT 1
12389: PUSH
12390: EMPTY
12391: LIST
12392: LIST
12393: PUSH
12394: EMPTY
12395: LIST
12396: LIST
12397: LIST
12398: LIST
12399: LIST
12400: PPUSH
12401: CALL_OW 69
12405: PUSH
12406: LD_EXP 18
12410: PUSH
12411: LD_EXP 17
12415: PUSH
12416: LD_EXP 49
12420: PUSH
12421: LD_EXP 37
12425: PUSH
12426: LD_EXP 47
12430: PUSH
12431: LD_EXP 46
12435: PUSH
12436: EMPTY
12437: LIST
12438: LIST
12439: LIST
12440: LIST
12441: LIST
12442: LIST
12443: DIFF
12444: ST_TO_ADDR
// if not speaker then
12445: LD_VAR 0 1
12449: NOT
12450: IFFALSE 12454
// exit ;
12452: GO 12505
// Say ( speaker [ 1 ] , DArtefTechnologyAm-Sci1-1 ) ;
12454: LD_VAR 0 1
12458: PUSH
12459: LD_INT 1
12461: ARRAY
12462: PPUSH
12463: LD_STRING DArtefTechnologyAm-Sci1-1
12465: PPUSH
12466: CALL_OW 88
// if IsOk ( Burlak ) then
12470: LD_EXP 49
12474: PPUSH
12475: CALL_OW 302
12479: IFFALSE 12493
// Say ( Burlak , DArtefTechnologyAm-Bur-1 ) ;
12481: LD_EXP 49
12485: PPUSH
12486: LD_STRING DArtefTechnologyAm-Bur-1
12488: PPUSH
12489: CALL_OW 88
// Say ( JMM , DArtefTechnologyAm-JMM-1 ) ;
12493: LD_EXP 17
12497: PPUSH
12498: LD_STRING DArtefTechnologyAm-JMM-1
12500: PPUSH
12501: CALL_OW 88
// end ;
12505: PPOPN 1
12507: END
// every 0 0$1 trigger artifactIIResearched do var speaker ;
12508: LD_EXP 13
12512: IFFALSE 12702
12514: GO 12516
12516: DISABLE
12517: LD_INT 0
12519: PPUSH
// begin speaker := FilterAllUnits ( [ [ f_side , 7 ] , [ f_nation , 3 ] , [ f_class , 4 ] , [ f_type , unit_human ] , [ f_sex , sex_male ] ] ) diff [ Roth , JMM , Burlak , Titov , Kuzmov , Kovalyuk ] ;
12520: LD_ADDR_VAR 0 1
12524: PUSH
12525: LD_INT 22
12527: PUSH
12528: LD_INT 7
12530: PUSH
12531: EMPTY
12532: LIST
12533: LIST
12534: PUSH
12535: LD_INT 23
12537: PUSH
12538: LD_INT 3
12540: PUSH
12541: EMPTY
12542: LIST
12543: LIST
12544: PUSH
12545: LD_INT 25
12547: PUSH
12548: LD_INT 4
12550: PUSH
12551: EMPTY
12552: LIST
12553: LIST
12554: PUSH
12555: LD_INT 21
12557: PUSH
12558: LD_INT 1
12560: PUSH
12561: EMPTY
12562: LIST
12563: LIST
12564: PUSH
12565: LD_INT 26
12567: PUSH
12568: LD_INT 1
12570: PUSH
12571: EMPTY
12572: LIST
12573: LIST
12574: PUSH
12575: EMPTY
12576: LIST
12577: LIST
12578: LIST
12579: LIST
12580: LIST
12581: PPUSH
12582: CALL_OW 69
12586: PUSH
12587: LD_EXP 18
12591: PUSH
12592: LD_EXP 17
12596: PUSH
12597: LD_EXP 49
12601: PUSH
12602: LD_EXP 37
12606: PUSH
12607: LD_EXP 47
12611: PUSH
12612: LD_EXP 46
12616: PUSH
12617: EMPTY
12618: LIST
12619: LIST
12620: LIST
12621: LIST
12622: LIST
12623: LIST
12624: DIFF
12625: ST_TO_ADDR
// if not speaker then
12626: LD_VAR 0 1
12630: NOT
12631: IFFALSE 12635
// exit ;
12633: GO 12702
// Say ( speaker [ 1 ] , DArtefTechnologyRu-RSci1-1 ) ;
12635: LD_VAR 0 1
12639: PUSH
12640: LD_INT 1
12642: ARRAY
12643: PPUSH
12644: LD_STRING DArtefTechnologyRu-RSci1-1
12646: PPUSH
12647: CALL_OW 88
// if IsOk ( Burlak ) then
12651: LD_EXP 49
12655: PPUSH
12656: CALL_OW 302
12660: IFFALSE 12674
// Say ( Burlak , DArtefTechnologyRu-Bur-1 ) ;
12662: LD_EXP 49
12666: PPUSH
12667: LD_STRING DArtefTechnologyRu-Bur-1
12669: PPUSH
12670: CALL_OW 88
// Say ( speaker [ 1 ] , DArtefTechnologyRu-RSci1-2 ) ;
12674: LD_VAR 0 1
12678: PUSH
12679: LD_INT 1
12681: ARRAY
12682: PPUSH
12683: LD_STRING DArtefTechnologyRu-RSci1-2
12685: PPUSH
12686: CALL_OW 88
// Say ( JMM , DArtefTechnologyRu-JMM-1 ) ;
12690: LD_EXP 17
12694: PPUSH
12695: LD_STRING DArtefTechnologyRu-JMM-1
12697: PPUSH
12698: CALL_OW 88
// end ;
12702: PPOPN 1
12704: END
// every 0 0$1 trigger GetTech ( tech_Artifact , 7 ) = state_researched and GetSide ( alien ) = 7 do var speaker ;
12705: LD_INT 24
12707: PPUSH
12708: LD_INT 7
12710: PPUSH
12711: CALL_OW 321
12715: PUSH
12716: LD_INT 2
12718: EQUAL
12719: PUSH
12720: LD_INT 1
12722: PPUSH
12723: CALL_OW 255
12727: PUSH
12728: LD_INT 7
12730: EQUAL
12731: AND
12732: IFFALSE 12892
12734: GO 12736
12736: DISABLE
12737: LD_INT 0
12739: PPUSH
// begin if Denis then
12740: LD_EXP 23
12744: IFFALSE 12761
// speaker := [ Denis ] else
12746: LD_ADDR_VAR 0 1
12750: PUSH
12751: LD_EXP 23
12755: PUSH
12756: EMPTY
12757: LIST
12758: ST_TO_ADDR
12759: GO 12867
// speaker := FilterAllUnits ( [ [ f_side , 7 ] , [ f_nation , 1 ] , [ f_class , 4 ] , [ f_type , unit_human ] , [ f_sex , sex_male ] ] ) diff [ Roth , JMM , Burlak , Titov , Kuzmov , Kovalyuk ] ;
12761: LD_ADDR_VAR 0 1
12765: PUSH
12766: LD_INT 22
12768: PUSH
12769: LD_INT 7
12771: PUSH
12772: EMPTY
12773: LIST
12774: LIST
12775: PUSH
12776: LD_INT 23
12778: PUSH
12779: LD_INT 1
12781: PUSH
12782: EMPTY
12783: LIST
12784: LIST
12785: PUSH
12786: LD_INT 25
12788: PUSH
12789: LD_INT 4
12791: PUSH
12792: EMPTY
12793: LIST
12794: LIST
12795: PUSH
12796: LD_INT 21
12798: PUSH
12799: LD_INT 1
12801: PUSH
12802: EMPTY
12803: LIST
12804: LIST
12805: PUSH
12806: LD_INT 26
12808: PUSH
12809: LD_INT 1
12811: PUSH
12812: EMPTY
12813: LIST
12814: LIST
12815: PUSH
12816: EMPTY
12817: LIST
12818: LIST
12819: LIST
12820: LIST
12821: LIST
12822: PPUSH
12823: CALL_OW 69
12827: PUSH
12828: LD_EXP 18
12832: PUSH
12833: LD_EXP 17
12837: PUSH
12838: LD_EXP 49
12842: PUSH
12843: LD_EXP 37
12847: PUSH
12848: LD_EXP 47
12852: PUSH
12853: LD_EXP 46
12857: PUSH
12858: EMPTY
12859: LIST
12860: LIST
12861: LIST
12862: LIST
12863: LIST
12864: LIST
12865: DIFF
12866: ST_TO_ADDR
// if not speaker then
12867: LD_VAR 0 1
12871: NOT
12872: IFFALSE 12876
// exit ;
12874: GO 12892
// Say ( speaker [ 1 ] , DArtefTechnologyArStart-Sci1-1 ) ;
12876: LD_VAR 0 1
12880: PUSH
12881: LD_INT 1
12883: ARRAY
12884: PPUSH
12885: LD_STRING DArtefTechnologyArStart-Sci1-1
12887: PPUSH
12888: CALL_OW 88
// end ;
12892: PPOPN 1
12894: END
// every 0 0$1 trigger artifactIIIResearched do var speaker ;
12895: LD_EXP 14
12899: IFFALSE 13180
12901: GO 12903
12903: DISABLE
12904: LD_INT 0
12906: PPUSH
// begin speaker := FilterAllUnits ( [ [ f_side , 7 ] , [ f_nation , 3 ] , [ f_class , 4 ] , [ f_type , unit_human ] , [ f_sex , sex_male ] ] ) diff [ Roth , JMM , Burlak , Titov , Kuzmov , Kovalyuk ] ;
12907: LD_ADDR_VAR 0 1
12911: PUSH
12912: LD_INT 22
12914: PUSH
12915: LD_INT 7
12917: PUSH
12918: EMPTY
12919: LIST
12920: LIST
12921: PUSH
12922: LD_INT 23
12924: PUSH
12925: LD_INT 3
12927: PUSH
12928: EMPTY
12929: LIST
12930: LIST
12931: PUSH
12932: LD_INT 25
12934: PUSH
12935: LD_INT 4
12937: PUSH
12938: EMPTY
12939: LIST
12940: LIST
12941: PUSH
12942: LD_INT 21
12944: PUSH
12945: LD_INT 1
12947: PUSH
12948: EMPTY
12949: LIST
12950: LIST
12951: PUSH
12952: LD_INT 26
12954: PUSH
12955: LD_INT 1
12957: PUSH
12958: EMPTY
12959: LIST
12960: LIST
12961: PUSH
12962: EMPTY
12963: LIST
12964: LIST
12965: LIST
12966: LIST
12967: LIST
12968: PPUSH
12969: CALL_OW 69
12973: PUSH
12974: LD_EXP 18
12978: PUSH
12979: LD_EXP 17
12983: PUSH
12984: LD_EXP 49
12988: PUSH
12989: LD_EXP 37
12993: PUSH
12994: LD_EXP 47
12998: PUSH
12999: LD_EXP 46
13003: PUSH
13004: EMPTY
13005: LIST
13006: LIST
13007: LIST
13008: LIST
13009: LIST
13010: LIST
13011: DIFF
13012: ST_TO_ADDR
// if not speaker then
13013: LD_VAR 0 1
13017: NOT
13018: IFFALSE 13022
// exit ;
13020: GO 13180
// DialogueOn ;
13022: CALL_OW 6
// Say ( speaker [ 1 ] , DArtefTechnologyAr-RSci1-1 ) ;
13026: LD_VAR 0 1
13030: PUSH
13031: LD_INT 1
13033: ARRAY
13034: PPUSH
13035: LD_STRING DArtefTechnologyAr-RSci1-1
13037: PPUSH
13038: CALL_OW 88
// Say ( JMM , DArtefTechnologyAr-JMM-1 ) ;
13042: LD_EXP 17
13046: PPUSH
13047: LD_STRING DArtefTechnologyAr-JMM-1
13049: PPUSH
13050: CALL_OW 88
// Say ( speaker [ 1 ] , DArtefTechnologyAr-RSci1-2 ) ;
13054: LD_VAR 0 1
13058: PUSH
13059: LD_INT 1
13061: ARRAY
13062: PPUSH
13063: LD_STRING DArtefTechnologyAr-RSci1-2
13065: PPUSH
13066: CALL_OW 88
// Say ( JMM , DArtefTechnologyAr-JMM-2 ) ;
13070: LD_EXP 17
13074: PPUSH
13075: LD_STRING DArtefTechnologyAr-JMM-2
13077: PPUSH
13078: CALL_OW 88
// Say ( speaker [ 1 ] , DArtefTechnologyAr-RSci1-3 ) ;
13082: LD_VAR 0 1
13086: PUSH
13087: LD_INT 1
13089: ARRAY
13090: PPUSH
13091: LD_STRING DArtefTechnologyAr-RSci1-3
13093: PPUSH
13094: CALL_OW 88
// Say ( JMM , DArtefTechnologyAr-JMM-3 ) ;
13098: LD_EXP 17
13102: PPUSH
13103: LD_STRING DArtefTechnologyAr-JMM-3
13105: PPUSH
13106: CALL_OW 88
// Say ( speaker [ 1 ] , DArtefTechnologyAr-RSci1-4 ) ;
13110: LD_VAR 0 1
13114: PUSH
13115: LD_INT 1
13117: ARRAY
13118: PPUSH
13119: LD_STRING DArtefTechnologyAr-RSci1-4
13121: PPUSH
13122: CALL_OW 88
// if IsOk ( Burlak ) then
13126: LD_EXP 49
13130: PPUSH
13131: CALL_OW 302
13135: IFFALSE 13149
// Say ( Burlak , DArtefTechnologyAr-Bur-4 ) ;
13137: LD_EXP 49
13141: PPUSH
13142: LD_STRING DArtefTechnologyAr-Bur-4
13144: PPUSH
13145: CALL_OW 88
// Say ( JMM , DArtefTechnologyAr-JMM-4 ) ;
13149: LD_EXP 17
13153: PPUSH
13154: LD_STRING DArtefTechnologyAr-JMM-4
13156: PPUSH
13157: CALL_OW 88
// DialogueOff ;
13161: CALL_OW 7
// wait ( 0 0$45 ) ;
13165: LD_INT 1575
13167: PPUSH
13168: CALL_OW 67
// spawnOmar := true ;
13172: LD_ADDR_EXP 11
13176: PUSH
13177: LD_INT 1
13179: ST_TO_ADDR
// end ;
13180: PPOPN 1
13182: END
// every 0 0$1 trigger spawnOmar do
13183: LD_EXP 11
13187: IFFALSE 13567
13189: GO 13191
13191: DISABLE
// begin PrepareOmarAli ;
13192: CALL 6705 0 0
// if not HasTask ( Omar ) then
13196: LD_EXP 53
13200: PPUSH
13201: CALL_OW 314
13205: NOT
13206: IFFALSE 13223
// ComMoveXY ( Omar , 252 , 220 ) ;
13208: LD_EXP 53
13212: PPUSH
13213: LD_INT 252
13215: PPUSH
13216: LD_INT 220
13218: PPUSH
13219: CALL_OW 111
// if not Omar then
13223: LD_EXP 53
13227: NOT
13228: IFFALSE 13232
// exit ;
13230: GO 13567
// repeat wait ( 0 0$1 ) ;
13232: LD_INT 35
13234: PPUSH
13235: CALL_OW 67
// if not HasTask ( Omar ) and GetDistUnitXY ( Omar , 252 , 220 ) > 6 then
13239: LD_EXP 53
13243: PPUSH
13244: CALL_OW 314
13248: NOT
13249: PUSH
13250: LD_EXP 53
13254: PPUSH
13255: LD_INT 252
13257: PPUSH
13258: LD_INT 220
13260: PPUSH
13261: CALL_OW 297
13265: PUSH
13266: LD_INT 6
13268: GREATER
13269: AND
13270: IFFALSE 13287
// ComMoveXY ( Omar , 252 , 220 ) ;
13272: LD_EXP 53
13276: PPUSH
13277: LD_INT 252
13279: PPUSH
13280: LD_INT 220
13282: PPUSH
13283: CALL_OW 111
// until See ( 7 , Omar ) ;
13287: LD_INT 7
13289: PPUSH
13290: LD_EXP 53
13294: PPUSH
13295: CALL_OW 292
13299: IFFALSE 13232
// CenterNowOnUnits ( Omar ) ;
13301: LD_EXP 53
13305: PPUSH
13306: CALL_OW 87
// DialogueOn ;
13310: CALL_OW 6
// Say ( Omar , DOmar-Omar-1 ) ;
13314: LD_EXP 53
13318: PPUSH
13319: LD_STRING DOmar-Omar-1
13321: PPUSH
13322: CALL_OW 88
// Say ( JMM , DOmar-JMM-1 ) ;
13326: LD_EXP 17
13330: PPUSH
13331: LD_STRING DOmar-JMM-1
13333: PPUSH
13334: CALL_OW 88
// Say ( Omar , DOmar-Omar-2 ) ;
13338: LD_EXP 53
13342: PPUSH
13343: LD_STRING DOmar-Omar-2
13345: PPUSH
13346: CALL_OW 88
// Say ( JMM , DOmar-JMM-2 ) ;
13350: LD_EXP 17
13354: PPUSH
13355: LD_STRING DOmar-JMM-2
13357: PPUSH
13358: CALL_OW 88
// Say ( Omar , DOmar-Omar-3 ) ;
13362: LD_EXP 53
13366: PPUSH
13367: LD_STRING DOmar-Omar-3
13369: PPUSH
13370: CALL_OW 88
// if IsOk ( Burlak ) then
13374: LD_EXP 49
13378: PPUSH
13379: CALL_OW 302
13383: IFFALSE 13399
// Say ( Burlak , DOmar-Bur-3 ) else
13385: LD_EXP 49
13389: PPUSH
13390: LD_STRING DOmar-Bur-3
13392: PPUSH
13393: CALL_OW 88
13397: GO 13411
// Say ( JMM , DOmar-JMM-3 ) ;
13399: LD_EXP 17
13403: PPUSH
13404: LD_STRING DOmar-JMM-3
13406: PPUSH
13407: CALL_OW 88
// Say ( Omar , DOmar-Omar-4 ) ;
13411: LD_EXP 53
13415: PPUSH
13416: LD_STRING DOmar-Omar-4
13418: PPUSH
13419: CALL_OW 88
// case Query ( QAccept ) of 1 :
13423: LD_STRING QAccept
13425: PPUSH
13426: CALL_OW 97
13430: PUSH
13431: LD_INT 1
13433: DOUBLE
13434: EQUAL
13435: IFTRUE 13439
13437: GO 13475
13439: POP
// begin Say ( JMM , DQrAccept#1-JMM-1 ) ;
13440: LD_EXP 17
13444: PPUSH
13445: LD_STRING DQrAccept#1-JMM-1
13447: PPUSH
13448: CALL_OW 88
// SetSide ( Omar , 7 ) ;
13452: LD_EXP 53
13456: PPUSH
13457: LD_INT 7
13459: PPUSH
13460: CALL_OW 235
// ComStop ( Omar ) ;
13464: LD_EXP 53
13468: PPUSH
13469: CALL_OW 141
// end ; 2 :
13473: GO 13524
13475: LD_INT 2
13477: DOUBLE
13478: EQUAL
13479: IFTRUE 13483
13481: GO 13523
13483: POP
// begin if IsOk ( Burlak ) then
13484: LD_EXP 49
13488: PPUSH
13489: CALL_OW 302
13493: IFFALSE 13509
// Say ( Burlak , DQrAccept#2-Bur-1 ) else
13495: LD_EXP 49
13499: PPUSH
13500: LD_STRING DQrAccept#2-Bur-1
13502: PPUSH
13503: CALL_OW 88
13507: GO 13521
// Say ( JMM , DQrAccept#2-JMM-1 ) ;
13509: LD_EXP 17
13513: PPUSH
13514: LD_STRING DQrAccept#2-JMM-1
13516: PPUSH
13517: CALL_OW 88
// end ; end ;
13521: GO 13524
13523: POP
// DialogueOff ;
13524: CALL_OW 7
// if GetSide ( Omar ) = 7 then
13528: LD_EXP 53
13532: PPUSH
13533: CALL_OW 255
13537: PUSH
13538: LD_INT 7
13540: EQUAL
13541: IFFALSE 13552
// begin SetAchievement ( ACH_OMAR ) ;
13543: LD_STRING ACH_OMAR
13545: PPUSH
13546: CALL_OW 543
// exit ;
13550: GO 13567
// end ; ComMoveXY ( Omar , 202 , 115 ) ;
13552: LD_EXP 53
13556: PPUSH
13557: LD_INT 202
13559: PPUSH
13560: LD_INT 115
13562: PPUSH
13563: CALL_OW 111
// end ;
13567: END
// every 0 0$1 trigger GetDistUnitXY ( Omar , 200 , 98 ) < 40 and russianDestroyed do
13568: LD_EXP 53
13572: PPUSH
13573: LD_INT 200
13575: PPUSH
13576: LD_INT 98
13578: PPUSH
13579: CALL_OW 297
13583: PUSH
13584: LD_INT 40
13586: LESS
13587: PUSH
13588: LD_EXP 2
13592: AND
13593: IFFALSE 13811
13595: GO 13597
13597: DISABLE
// begin SetSide ( Omar , 5 ) ;
13598: LD_EXP 53
13602: PPUSH
13603: LD_INT 5
13605: PPUSH
13606: CALL_OW 235
// if IsInUnit ( Omar ) then
13610: LD_EXP 53
13614: PPUSH
13615: CALL_OW 310
13619: IFFALSE 13630
// ComExitVehicle ( Omar ) ;
13621: LD_EXP 53
13625: PPUSH
13626: CALL_OW 121
// if IsInUnit ( Omar ) then
13630: LD_EXP 53
13634: PPUSH
13635: CALL_OW 310
13639: IFFALSE 13650
// ComExitBuilding ( Omar ) ;
13641: LD_EXP 53
13645: PPUSH
13646: CALL_OW 122
// wait ( 0 0$1 ) ;
13650: LD_INT 35
13652: PPUSH
13653: CALL_OW 67
// ComMoveXY ( Omar , 203 , 120 ) ;
13657: LD_EXP 53
13661: PPUSH
13662: LD_INT 203
13664: PPUSH
13665: LD_INT 120
13667: PPUSH
13668: CALL_OW 111
// repeat wait ( 0 0$1 ) ;
13672: LD_INT 35
13674: PPUSH
13675: CALL_OW 67
// until IsSelected ( Omar ) or GetDistUnitXY ( Omar , 203 , 120 ) < 6 ;
13679: LD_EXP 53
13683: PPUSH
13684: CALL_OW 306
13688: PUSH
13689: LD_EXP 53
13693: PPUSH
13694: LD_INT 203
13696: PPUSH
13697: LD_INT 120
13699: PPUSH
13700: CALL_OW 297
13704: PUSH
13705: LD_INT 6
13707: LESS
13708: OR
13709: IFFALSE 13672
// CenterNowOnUnits ( Omar ) ;
13711: LD_EXP 53
13715: PPUSH
13716: CALL_OW 87
// DialogueOn ;
13720: CALL_OW 6
// Say ( JMM , DOmarContam-JMM-1 ) ;
13724: LD_EXP 17
13728: PPUSH
13729: LD_STRING DOmarContam-JMM-1
13731: PPUSH
13732: CALL_OW 88
// Say ( Omar , DOmarContam-Omar-1 ) ;
13736: LD_EXP 53
13740: PPUSH
13741: LD_STRING DOmarContam-Omar-1
13743: PPUSH
13744: CALL_OW 88
// Say ( JMM , DOmarContam-JMM-2 ) ;
13748: LD_EXP 17
13752: PPUSH
13753: LD_STRING DOmarContam-JMM-2
13755: PPUSH
13756: CALL_OW 88
// DialogueOff ;
13760: CALL_OW 7
// SetAttitude ( 5 , 7 , att_enemy , true ) ;
13764: LD_INT 5
13766: PPUSH
13767: LD_INT 7
13769: PPUSH
13770: LD_INT 2
13772: PPUSH
13773: LD_INT 1
13775: PPUSH
13776: CALL_OW 80
// repeat wait ( 0 0$3 ) ;
13780: LD_INT 105
13782: PPUSH
13783: CALL_OW 67
// until IsAt ( Omar , 203 , 120 ) ;
13787: LD_EXP 53
13791: PPUSH
13792: LD_INT 203
13794: PPUSH
13795: LD_INT 120
13797: PPUSH
13798: CALL_OW 307
13802: IFFALSE 13780
// YouLost ( MothContaminate ) ;
13804: LD_STRING MothContaminate
13806: PPUSH
13807: CALL_OW 104
// end ;
13811: END
// every 0 0$2 trigger not americanDestroyed and FilterAllUnits ( [ [ f_side , 1 ] , [ f_weapon , us_siberium_rocket ] ] ) do
13812: LD_EXP 4
13816: NOT
13817: PUSH
13818: LD_INT 22
13820: PUSH
13821: LD_INT 1
13823: PUSH
13824: EMPTY
13825: LIST
13826: LIST
13827: PUSH
13828: LD_INT 34
13830: PUSH
13831: LD_INT 8
13833: PUSH
13834: EMPTY
13835: LIST
13836: LIST
13837: PUSH
13838: EMPTY
13839: LIST
13840: LIST
13841: PPUSH
13842: CALL_OW 69
13846: AND
13847: IFFALSE 13928
13849: GO 13851
13851: DISABLE
// begin if not IsOk ( Powell ) then
13852: LD_EXP 52
13856: PPUSH
13857: CALL_OW 302
13861: NOT
13862: IFFALSE 13866
// exit ;
13864: GO 13928
// DialogueOn ;
13866: CALL_OW 6
// SayRadio ( Powell , DWinAmericans-Pow-1 ) ;
13870: LD_EXP 52
13874: PPUSH
13875: LD_STRING DWinAmericans-Pow-1
13877: PPUSH
13878: CALL_OW 94
// if IsOk ( Burlak ) then
13882: LD_EXP 49
13886: PPUSH
13887: CALL_OW 302
13891: IFFALSE 13905
// Say ( Burlak , DWinAmericans-Bur-1 ) ;
13893: LD_EXP 49
13897: PPUSH
13898: LD_STRING DWinAmericans-Bur-1
13900: PPUSH
13901: CALL_OW 88
// Say ( JMM , DWinAmericans-JMM-1 ) ;
13905: LD_EXP 17
13909: PPUSH
13910: LD_STRING DWinAmericans-JMM-1
13912: PPUSH
13913: CALL_OW 88
// DialogueOff ;
13917: CALL_OW 7
// YouLost ( AmBomb ) ;
13921: LD_STRING AmBomb
13923: PPUSH
13924: CALL_OW 104
// end ;
13928: END
// every 0 0$2 trigger not russianDestroyed and FilterAllUnits ( [ [ f_side , 3 ] , [ f_weapon , ru_siberium_rocket ] ] ) do
13929: LD_EXP 2
13933: NOT
13934: PUSH
13935: LD_INT 22
13937: PUSH
13938: LD_INT 3
13940: PUSH
13941: EMPTY
13942: LIST
13943: LIST
13944: PUSH
13945: LD_INT 34
13947: PUSH
13948: LD_INT 48
13950: PUSH
13951: EMPTY
13952: LIST
13953: LIST
13954: PUSH
13955: EMPTY
13956: LIST
13957: LIST
13958: PPUSH
13959: CALL_OW 69
13963: AND
13964: IFFALSE 14045
13966: GO 13968
13968: DISABLE
// begin if not IsOk ( Platonov ) then
13969: LD_EXP 56
13973: PPUSH
13974: CALL_OW 302
13978: NOT
13979: IFFALSE 13983
// exit ;
13981: GO 14045
// DialogueOn ;
13983: CALL_OW 6
// SayRadio ( Platonov , DWinRussians-Pla-1 ) ;
13987: LD_EXP 56
13991: PPUSH
13992: LD_STRING DWinRussians-Pla-1
13994: PPUSH
13995: CALL_OW 94
// if IsOk ( Burlak ) then
13999: LD_EXP 49
14003: PPUSH
14004: CALL_OW 302
14008: IFFALSE 14022
// Say ( Burlak , DWinRussians-Bur-1 ) ;
14010: LD_EXP 49
14014: PPUSH
14015: LD_STRING DWinRussians-Bur-1
14017: PPUSH
14018: CALL_OW 88
// Say ( JMM , DWinRussians-JMM-1 ) ;
14022: LD_EXP 17
14026: PPUSH
14027: LD_STRING DWinRussians-JMM-1
14029: PPUSH
14030: CALL_OW 88
// DialogueOff ;
14034: CALL_OW 7
// YouLost ( RuBomb ) ;
14038: LD_STRING RuBomb
14040: PPUSH
14041: CALL_OW 104
// end ;
14045: END
// every 0 0$20 trigger FilterUnitsInArea ( powellBase , [ f_side , 7 ] ) and not americanDestroyed do
14046: LD_INT 7
14048: PPUSH
14049: LD_INT 22
14051: PUSH
14052: LD_INT 7
14054: PUSH
14055: EMPTY
14056: LIST
14057: LIST
14058: PPUSH
14059: CALL_OW 70
14063: PUSH
14064: LD_EXP 4
14068: NOT
14069: AND
14070: IFFALSE 14099
14072: GO 14074
14074: DISABLE
// begin SayRadio ( Powell , DSurrenderAmericans-Pow-1 ) ;
14075: LD_EXP 52
14079: PPUSH
14080: LD_STRING DSurrenderAmericans-Pow-1
14082: PPUSH
14083: CALL_OW 94
// Say ( JMM , DSurrenderAmericans-JMM-1 ) ;
14087: LD_EXP 17
14091: PPUSH
14092: LD_STRING DSurrenderAmericans-JMM-1
14094: PPUSH
14095: CALL_OW 88
// end ;
14099: END
// every 0 0$20 trigger FilterUnitsInArea ( russianBaseArea , [ f_side , 7 ] ) and not russianDestroyed and Burlak do
14100: LD_INT 2
14102: PPUSH
14103: LD_INT 22
14105: PUSH
14106: LD_INT 7
14108: PUSH
14109: EMPTY
14110: LIST
14111: LIST
14112: PPUSH
14113: CALL_OW 70
14117: PUSH
14118: LD_EXP 2
14122: NOT
14123: AND
14124: PUSH
14125: LD_EXP 49
14129: AND
14130: IFFALSE 14159
14132: GO 14134
14134: DISABLE
// begin SayRadio ( Platonov , DSurrenderRussians-Pla-1 ) ;
14135: LD_EXP 56
14139: PPUSH
14140: LD_STRING DSurrenderRussians-Pla-1
14142: PPUSH
14143: CALL_OW 94
// Say ( Burlak , DSurrenderRussians-Bur-1 ) ;
14147: LD_EXP 49
14151: PPUSH
14152: LD_STRING DSurrenderRussians-Bur-1
14154: PPUSH
14155: CALL_OW 88
// end ;
14159: END
// every 0 0$2 + 0 0$5 trigger americanDestroyed do var i , tmp , speaker ;
14160: LD_EXP 4
14164: IFFALSE 14547
14166: GO 14168
14168: DISABLE
14169: LD_INT 0
14171: PPUSH
14172: PPUSH
14173: PPUSH
// begin MC_Kill ( 4 ) ;
14174: LD_INT 4
14176: PPUSH
14177: CALL 20742 0 1
// SetAttitude ( 1 , 7 , att_friend , true ) ;
14181: LD_INT 1
14183: PPUSH
14184: LD_INT 7
14186: PPUSH
14187: LD_INT 1
14189: PPUSH
14190: LD_INT 1
14192: PPUSH
14193: CALL_OW 80
// speaker := FilterAllUnits ( [ [ f_side , 1 ] , [ f_sex , sex_male ] , [ f_nation , 1 ] ] ) diff [ Powell , Gladstone , Cyrus , Bobby , Gary , Houten ] ;
14197: LD_ADDR_VAR 0 3
14201: PUSH
14202: LD_INT 22
14204: PUSH
14205: LD_INT 1
14207: PUSH
14208: EMPTY
14209: LIST
14210: LIST
14211: PUSH
14212: LD_INT 26
14214: PUSH
14215: LD_INT 1
14217: PUSH
14218: EMPTY
14219: LIST
14220: LIST
14221: PUSH
14222: LD_INT 23
14224: PUSH
14225: LD_INT 1
14227: PUSH
14228: EMPTY
14229: LIST
14230: LIST
14231: PUSH
14232: EMPTY
14233: LIST
14234: LIST
14235: LIST
14236: PPUSH
14237: CALL_OW 69
14241: PUSH
14242: LD_EXP 52
14246: PUSH
14247: LD_EXP 25
14251: PUSH
14252: LD_EXP 22
14256: PUSH
14257: LD_EXP 21
14261: PUSH
14262: LD_EXP 28
14266: PUSH
14267: LD_EXP 26
14271: PUSH
14272: EMPTY
14273: LIST
14274: LIST
14275: LIST
14276: LIST
14277: LIST
14278: LIST
14279: DIFF
14280: ST_TO_ADDR
// if speaker then
14281: LD_VAR 0 3
14285: IFFALSE 14311
// begin DialogueOn ;
14287: CALL_OW 6
// SayRadio ( speaker [ 1 ] , DSurrenderAmericans-Sol1-1a ) ;
14291: LD_VAR 0 3
14295: PUSH
14296: LD_INT 1
14298: ARRAY
14299: PPUSH
14300: LD_STRING DSurrenderAmericans-Sol1-1a
14302: PPUSH
14303: CALL_OW 94
// DialogueOff ;
14307: CALL_OW 7
// end ; americanCapitulated := true ;
14311: LD_ADDR_EXP 6
14315: PUSH
14316: LD_INT 1
14318: ST_TO_ADDR
// tmp := FilterAllUnits ( [ [ f_side , 1 ] , [ f_type , unit_human ] ] ) ^ FilterAllUnits ( [ [ f_side , 1 ] , [ f_type , unit_vehicle ] , [ control_manual ] ] ) ;
14319: LD_ADDR_VAR 0 2
14323: PUSH
14324: LD_INT 22
14326: PUSH
14327: LD_INT 1
14329: PUSH
14330: EMPTY
14331: LIST
14332: LIST
14333: PUSH
14334: LD_INT 21
14336: PUSH
14337: LD_INT 1
14339: PUSH
14340: EMPTY
14341: LIST
14342: LIST
14343: PUSH
14344: EMPTY
14345: LIST
14346: LIST
14347: PPUSH
14348: CALL_OW 69
14352: PUSH
14353: LD_INT 22
14355: PUSH
14356: LD_INT 1
14358: PUSH
14359: EMPTY
14360: LIST
14361: LIST
14362: PUSH
14363: LD_INT 21
14365: PUSH
14366: LD_INT 2
14368: PUSH
14369: EMPTY
14370: LIST
14371: LIST
14372: PUSH
14373: LD_INT 1
14375: PUSH
14376: EMPTY
14377: LIST
14378: PUSH
14379: EMPTY
14380: LIST
14381: LIST
14382: LIST
14383: PPUSH
14384: CALL_OW 69
14388: ADD
14389: ST_TO_ADDR
// if tmp then
14390: LD_VAR 0 2
14394: IFFALSE 14547
// repeat wait ( 0 0$1 ) ;
14396: LD_INT 35
14398: PPUSH
14399: CALL_OW 67
// for i in tmp do
14403: LD_ADDR_VAR 0 1
14407: PUSH
14408: LD_VAR 0 2
14412: PUSH
14413: FOR_IN
14414: IFFALSE 14496
// begin if IsInUnit ( i ) and GetType ( IsInUnit ( i ) ) = unit_building then
14416: LD_VAR 0 1
14420: PPUSH
14421: CALL_OW 310
14425: PUSH
14426: LD_VAR 0 1
14430: PPUSH
14431: CALL_OW 310
14435: PPUSH
14436: CALL_OW 247
14440: PUSH
14441: LD_INT 3
14443: EQUAL
14444: AND
14445: IFFALSE 14456
// ComExitBuilding ( i ) ;
14447: LD_VAR 0 1
14451: PPUSH
14452: CALL_OW 122
// AddComMoveXY ( i , 122 , 242 ) ;
14456: LD_VAR 0 1
14460: PPUSH
14461: LD_INT 122
14463: PPUSH
14464: LD_INT 242
14466: PPUSH
14467: CALL_OW 171
// if IsInArea ( i , americanEscape ) then
14471: LD_VAR 0 1
14475: PPUSH
14476: LD_INT 35
14478: PPUSH
14479: CALL_OW 308
14483: IFFALSE 14494
// RemoveUnit ( i ) ;
14485: LD_VAR 0 1
14489: PPUSH
14490: CALL_OW 64
// end ;
14494: GO 14413
14496: POP
14497: POP
// until not FilterAllUnits ( [ [ f_side , 1 ] , [ f_or , [ f_type , unit_human ] , [ f_control , control_manual ] ] ] ) ;
14498: LD_INT 22
14500: PUSH
14501: LD_INT 1
14503: PUSH
14504: EMPTY
14505: LIST
14506: LIST
14507: PUSH
14508: LD_INT 2
14510: PUSH
14511: LD_INT 21
14513: PUSH
14514: LD_INT 1
14516: PUSH
14517: EMPTY
14518: LIST
14519: LIST
14520: PUSH
14521: LD_INT 33
14523: PUSH
14524: LD_INT 1
14526: PUSH
14527: EMPTY
14528: LIST
14529: LIST
14530: PUSH
14531: EMPTY
14532: LIST
14533: LIST
14534: LIST
14535: PUSH
14536: EMPTY
14537: LIST
14538: LIST
14539: PPUSH
14540: CALL_OW 69
14544: NOT
14545: IFFALSE 14396
// end ;
14547: PPOPN 3
14549: END
// every 0 0$2 + 0 0$5 trigger russianDestroyed do var i , tmp , speaker ;
14550: LD_EXP 2
14554: IFFALSE 14955
14556: GO 14558
14558: DISABLE
14559: LD_INT 0
14561: PPUSH
14562: PPUSH
14563: PPUSH
// begin repeat wait ( 0 0$1 ) ;
14564: LD_INT 35
14566: PPUSH
14567: CALL_OW 67
// until IsDead ( Yakotich ) ;
14571: LD_EXP 57
14575: PPUSH
14576: CALL_OW 301
14580: IFFALSE 14564
// MC_Kill ( 2 ) ;
14582: LD_INT 2
14584: PPUSH
14585: CALL 20742 0 1
// SetAttitude ( 3 , 7 , att_friend , true ) ;
14589: LD_INT 3
14591: PPUSH
14592: LD_INT 7
14594: PPUSH
14595: LD_INT 1
14597: PPUSH
14598: LD_INT 1
14600: PPUSH
14601: CALL_OW 80
// speaker := FilterAllUnits ( [ [ f_side , 3 ] , [ f_sex , sex_male ] , [ f_nation , 3 ] ] ) diff [ Platonov , Yakotich ] ;
14605: LD_ADDR_VAR 0 3
14609: PUSH
14610: LD_INT 22
14612: PUSH
14613: LD_INT 3
14615: PUSH
14616: EMPTY
14617: LIST
14618: LIST
14619: PUSH
14620: LD_INT 26
14622: PUSH
14623: LD_INT 1
14625: PUSH
14626: EMPTY
14627: LIST
14628: LIST
14629: PUSH
14630: LD_INT 23
14632: PUSH
14633: LD_INT 3
14635: PUSH
14636: EMPTY
14637: LIST
14638: LIST
14639: PUSH
14640: EMPTY
14641: LIST
14642: LIST
14643: LIST
14644: PPUSH
14645: CALL_OW 69
14649: PUSH
14650: LD_EXP 56
14654: PUSH
14655: LD_EXP 57
14659: PUSH
14660: EMPTY
14661: LIST
14662: LIST
14663: DIFF
14664: ST_TO_ADDR
// if speaker then
14665: LD_VAR 0 3
14669: IFFALSE 14719
// begin DialogueOn ;
14671: CALL_OW 6
// if Burlak then
14675: LD_EXP 49
14679: IFFALSE 14699
// SayRadio ( speaker [ 1 ] , DSurrenderRussians-RSol1-1 ) else
14681: LD_VAR 0 3
14685: PUSH
14686: LD_INT 1
14688: ARRAY
14689: PPUSH
14690: LD_STRING DSurrenderRussians-RSol1-1
14692: PPUSH
14693: CALL_OW 94
14697: GO 14715
// SayRadio ( speaker [ 1 ] , DSurrenderRussians-RSol1-1a ) ;
14699: LD_VAR 0 3
14703: PUSH
14704: LD_INT 1
14706: ARRAY
14707: PPUSH
14708: LD_STRING DSurrenderRussians-RSol1-1a
14710: PPUSH
14711: CALL_OW 94
// DialogueOff ;
14715: CALL_OW 7
// end ; russianCapitulated := true ;
14719: LD_ADDR_EXP 7
14723: PUSH
14724: LD_INT 1
14726: ST_TO_ADDR
// tmp := FilterAllUnits ( [ [ f_side , 3 ] , [ f_type , unit_human ] ] ) ^ FilterAllUnits ( [ [ f_side , 3 ] , [ f_type , unit_vehicle ] , [ control_manual ] ] ) ;
14727: LD_ADDR_VAR 0 2
14731: PUSH
14732: LD_INT 22
14734: PUSH
14735: LD_INT 3
14737: PUSH
14738: EMPTY
14739: LIST
14740: LIST
14741: PUSH
14742: LD_INT 21
14744: PUSH
14745: LD_INT 1
14747: PUSH
14748: EMPTY
14749: LIST
14750: LIST
14751: PUSH
14752: EMPTY
14753: LIST
14754: LIST
14755: PPUSH
14756: CALL_OW 69
14760: PUSH
14761: LD_INT 22
14763: PUSH
14764: LD_INT 3
14766: PUSH
14767: EMPTY
14768: LIST
14769: LIST
14770: PUSH
14771: LD_INT 21
14773: PUSH
14774: LD_INT 2
14776: PUSH
14777: EMPTY
14778: LIST
14779: LIST
14780: PUSH
14781: LD_INT 1
14783: PUSH
14784: EMPTY
14785: LIST
14786: PUSH
14787: EMPTY
14788: LIST
14789: LIST
14790: LIST
14791: PPUSH
14792: CALL_OW 69
14796: ADD
14797: ST_TO_ADDR
// if tmp then
14798: LD_VAR 0 2
14802: IFFALSE 14955
// repeat wait ( 0 0$1 ) ;
14804: LD_INT 35
14806: PPUSH
14807: CALL_OW 67
// for i in tmp do
14811: LD_ADDR_VAR 0 1
14815: PUSH
14816: LD_VAR 0 2
14820: PUSH
14821: FOR_IN
14822: IFFALSE 14904
// begin if IsInUnit ( i ) and GetType ( IsInUnit ( i ) ) = unit_building then
14824: LD_VAR 0 1
14828: PPUSH
14829: CALL_OW 310
14833: PUSH
14834: LD_VAR 0 1
14838: PPUSH
14839: CALL_OW 310
14843: PPUSH
14844: CALL_OW 247
14848: PUSH
14849: LD_INT 3
14851: EQUAL
14852: AND
14853: IFFALSE 14864
// ComExitBuilding ( i ) ;
14855: LD_VAR 0 1
14859: PPUSH
14860: CALL_OW 122
// AddComMoveXY ( i , 154 , 1 ) ;
14864: LD_VAR 0 1
14868: PPUSH
14869: LD_INT 154
14871: PPUSH
14872: LD_INT 1
14874: PPUSH
14875: CALL_OW 171
// if IsInArea ( i , russianEscape ) then
14879: LD_VAR 0 1
14883: PPUSH
14884: LD_INT 36
14886: PPUSH
14887: CALL_OW 308
14891: IFFALSE 14902
// RemoveUnit ( i ) ;
14893: LD_VAR 0 1
14897: PPUSH
14898: CALL_OW 64
// end ;
14902: GO 14821
14904: POP
14905: POP
// until not FilterAllUnits ( [ [ f_side , 3 ] , [ f_or , [ f_type , unit_human ] , [ f_control , control_manual ] ] ] ) ;
14906: LD_INT 22
14908: PUSH
14909: LD_INT 3
14911: PUSH
14912: EMPTY
14913: LIST
14914: LIST
14915: PUSH
14916: LD_INT 2
14918: PUSH
14919: LD_INT 21
14921: PUSH
14922: LD_INT 1
14924: PUSH
14925: EMPTY
14926: LIST
14927: LIST
14928: PUSH
14929: LD_INT 33
14931: PUSH
14932: LD_INT 1
14934: PUSH
14935: EMPTY
14936: LIST
14937: LIST
14938: PUSH
14939: EMPTY
14940: LIST
14941: LIST
14942: LIST
14943: PUSH
14944: EMPTY
14945: LIST
14946: LIST
14947: PPUSH
14948: CALL_OW 69
14952: NOT
14953: IFFALSE 14804
// end ;
14955: PPOPN 3
14957: END
// every 0 0$3 trigger FilterAllUnits ( [ [ f_side , 8 ] , [ f_type , unit_human ] , [ f_nation , 2 ] ] ) < 18 or IsDead ( Kozlov ) or GetSide ( ar_depot1 ) = 7 do
14958: LD_INT 22
14960: PUSH
14961: LD_INT 8
14963: PUSH
14964: EMPTY
14965: LIST
14966: LIST
14967: PUSH
14968: LD_INT 21
14970: PUSH
14971: LD_INT 1
14973: PUSH
14974: EMPTY
14975: LIST
14976: LIST
14977: PUSH
14978: LD_INT 23
14980: PUSH
14981: LD_INT 2
14983: PUSH
14984: EMPTY
14985: LIST
14986: LIST
14987: PUSH
14988: EMPTY
14989: LIST
14990: LIST
14991: LIST
14992: PPUSH
14993: CALL_OW 69
14997: PUSH
14998: LD_INT 18
15000: LESS
15001: PUSH
15002: LD_EXP 55
15006: PPUSH
15007: CALL_OW 301
15011: OR
15012: PUSH
15013: LD_INT 324
15015: PPUSH
15016: CALL_OW 255
15020: PUSH
15021: LD_INT 7
15023: EQUAL
15024: OR
15025: IFFALSE 15038
15027: GO 15029
15029: DISABLE
// legionDestroyed := true ;
15030: LD_ADDR_EXP 3
15034: PUSH
15035: LD_INT 1
15037: ST_TO_ADDR
15038: END
// every 0 0$3 trigger FilterAllUnits ( [ [ f_side , 2 ] , [ f_type , unit_human ] , [ f_nation , 2 ] ] ) < 9 do
15039: LD_INT 22
15041: PUSH
15042: LD_INT 2
15044: PUSH
15045: EMPTY
15046: LIST
15047: LIST
15048: PUSH
15049: LD_INT 21
15051: PUSH
15052: LD_INT 1
15054: PUSH
15055: EMPTY
15056: LIST
15057: LIST
15058: PUSH
15059: LD_INT 23
15061: PUSH
15062: LD_INT 2
15064: PUSH
15065: EMPTY
15066: LIST
15067: LIST
15068: PUSH
15069: EMPTY
15070: LIST
15071: LIST
15072: LIST
15073: PPUSH
15074: CALL_OW 69
15078: PUSH
15079: LD_INT 9
15081: LESS
15082: IFFALSE 15095
15084: GO 15086
15086: DISABLE
// arabianDestroyed := true ;
15087: LD_ADDR_EXP 5
15091: PUSH
15092: LD_INT 1
15094: ST_TO_ADDR
15095: END
// every 0 0$1 trigger arabianDestroyed do var i , tmp ;
15096: LD_EXP 5
15100: IFFALSE 15344
15102: GO 15104
15104: DISABLE
15105: LD_INT 0
15107: PPUSH
15108: PPUSH
// begin MC_Kill ( 1 ) ;
15109: LD_INT 1
15111: PPUSH
15112: CALL 20742 0 1
// tmp := FilterAllUnits ( [ [ f_side , 2 ] , [ f_type , unit_human ] ] ) ^ FilterAllUnits ( [ [ f_side , 8 ] , [ f_type , unit_vehicle ] , [ control_manual ] ] ) ;
15116: LD_ADDR_VAR 0 2
15120: PUSH
15121: LD_INT 22
15123: PUSH
15124: LD_INT 2
15126: PUSH
15127: EMPTY
15128: LIST
15129: LIST
15130: PUSH
15131: LD_INT 21
15133: PUSH
15134: LD_INT 1
15136: PUSH
15137: EMPTY
15138: LIST
15139: LIST
15140: PUSH
15141: EMPTY
15142: LIST
15143: LIST
15144: PPUSH
15145: CALL_OW 69
15149: PUSH
15150: LD_INT 22
15152: PUSH
15153: LD_INT 8
15155: PUSH
15156: EMPTY
15157: LIST
15158: LIST
15159: PUSH
15160: LD_INT 21
15162: PUSH
15163: LD_INT 2
15165: PUSH
15166: EMPTY
15167: LIST
15168: LIST
15169: PUSH
15170: LD_INT 1
15172: PUSH
15173: EMPTY
15174: LIST
15175: PUSH
15176: EMPTY
15177: LIST
15178: LIST
15179: LIST
15180: PPUSH
15181: CALL_OW 69
15185: ADD
15186: ST_TO_ADDR
// if tmp then
15187: LD_VAR 0 2
15191: IFFALSE 15344
// repeat wait ( 0 0$1 ) ;
15193: LD_INT 35
15195: PPUSH
15196: CALL_OW 67
// for i in tmp do
15200: LD_ADDR_VAR 0 1
15204: PUSH
15205: LD_VAR 0 2
15209: PUSH
15210: FOR_IN
15211: IFFALSE 15293
// begin if IsInUnit ( i ) and GetType ( IsInUnit ( i ) ) = unit_building then
15213: LD_VAR 0 1
15217: PPUSH
15218: CALL_OW 310
15222: PUSH
15223: LD_VAR 0 1
15227: PPUSH
15228: CALL_OW 310
15232: PPUSH
15233: CALL_OW 247
15237: PUSH
15238: LD_INT 3
15240: EQUAL
15241: AND
15242: IFFALSE 15253
// ComExitBuilding ( i ) ;
15244: LD_VAR 0 1
15248: PPUSH
15249: CALL_OW 122
// AddComMoveXY ( i , 254 , 268 ) ;
15253: LD_VAR 0 1
15257: PPUSH
15258: LD_INT 254
15260: PPUSH
15261: LD_INT 268
15263: PPUSH
15264: CALL_OW 171
// if IsInArea ( i , arabEscape ) then
15268: LD_VAR 0 1
15272: PPUSH
15273: LD_INT 34
15275: PPUSH
15276: CALL_OW 308
15280: IFFALSE 15291
// RemoveUnit ( i ) ;
15282: LD_VAR 0 1
15286: PPUSH
15287: CALL_OW 64
// end ;
15291: GO 15210
15293: POP
15294: POP
// until not FilterAllUnits ( [ [ f_side , 2 ] , [ f_or , [ f_type , unit_human ] , [ f_control , control_manual ] ] ] ) ;
15295: LD_INT 22
15297: PUSH
15298: LD_INT 2
15300: PUSH
15301: EMPTY
15302: LIST
15303: LIST
15304: PUSH
15305: LD_INT 2
15307: PUSH
15308: LD_INT 21
15310: PUSH
15311: LD_INT 1
15313: PUSH
15314: EMPTY
15315: LIST
15316: LIST
15317: PUSH
15318: LD_INT 33
15320: PUSH
15321: LD_INT 1
15323: PUSH
15324: EMPTY
15325: LIST
15326: LIST
15327: PUSH
15328: EMPTY
15329: LIST
15330: LIST
15331: LIST
15332: PUSH
15333: EMPTY
15334: LIST
15335: LIST
15336: PPUSH
15337: CALL_OW 69
15341: NOT
15342: IFFALSE 15193
// end ;
15344: PPOPN 2
15346: END
// every 0 0$1 trigger legionDestroyed do var i , tmp ;
15347: LD_EXP 3
15351: IFFALSE 15703
15353: GO 15355
15355: DISABLE
15356: LD_INT 0
15358: PPUSH
15359: PPUSH
// begin MC_Kill ( 3 ) ;
15360: LD_INT 3
15362: PPUSH
15363: CALL 20742 0 1
// SetAttitude ( 8 , 7 , att_friend , true ) ;
15367: LD_INT 8
15369: PPUSH
15370: LD_INT 7
15372: PPUSH
15373: LD_INT 1
15375: PPUSH
15376: LD_INT 1
15378: PPUSH
15379: CALL_OW 80
// DialogueOn ;
15383: CALL_OW 6
// SayRadio ( Schulz , D15-Szulc-1 ) ;
15387: LD_EXP 54
15391: PPUSH
15392: LD_STRING D15-Szulc-1
15394: PPUSH
15395: CALL_OW 94
// DialogueOff ;
15399: CALL_OW 7
// legionCapitulated := true ;
15403: LD_ADDR_EXP 8
15407: PUSH
15408: LD_INT 1
15410: ST_TO_ADDR
// for i in FilterAllUnits ( [ [ f_side , 8 ] , [ f_type , unit_building ] , [ f_nation , 3 ] ] ) do
15411: LD_ADDR_VAR 0 1
15415: PUSH
15416: LD_INT 22
15418: PUSH
15419: LD_INT 8
15421: PUSH
15422: EMPTY
15423: LIST
15424: LIST
15425: PUSH
15426: LD_INT 21
15428: PUSH
15429: LD_INT 3
15431: PUSH
15432: EMPTY
15433: LIST
15434: LIST
15435: PUSH
15436: LD_INT 23
15438: PUSH
15439: LD_INT 3
15441: PUSH
15442: EMPTY
15443: LIST
15444: LIST
15445: PUSH
15446: EMPTY
15447: LIST
15448: LIST
15449: LIST
15450: PPUSH
15451: CALL_OW 69
15455: PUSH
15456: FOR_IN
15457: IFFALSE 15473
// SetLives ( i , 3 ) ;
15459: LD_VAR 0 1
15463: PPUSH
15464: LD_INT 3
15466: PPUSH
15467: CALL_OW 234
15471: GO 15456
15473: POP
15474: POP
// tmp := FilterAllUnits ( [ [ f_side , 8 ] , [ f_type , unit_human ] ] ) ^ FilterAllUnits ( [ [ f_side , 8 ] , [ f_type , unit_vehicle ] , [ control_manual ] ] ) ;
15475: LD_ADDR_VAR 0 2
15479: PUSH
15480: LD_INT 22
15482: PUSH
15483: LD_INT 8
15485: PUSH
15486: EMPTY
15487: LIST
15488: LIST
15489: PUSH
15490: LD_INT 21
15492: PUSH
15493: LD_INT 1
15495: PUSH
15496: EMPTY
15497: LIST
15498: LIST
15499: PUSH
15500: EMPTY
15501: LIST
15502: LIST
15503: PPUSH
15504: CALL_OW 69
15508: PUSH
15509: LD_INT 22
15511: PUSH
15512: LD_INT 8
15514: PUSH
15515: EMPTY
15516: LIST
15517: LIST
15518: PUSH
15519: LD_INT 21
15521: PUSH
15522: LD_INT 2
15524: PUSH
15525: EMPTY
15526: LIST
15527: LIST
15528: PUSH
15529: LD_INT 1
15531: PUSH
15532: EMPTY
15533: LIST
15534: PUSH
15535: EMPTY
15536: LIST
15537: LIST
15538: LIST
15539: PPUSH
15540: CALL_OW 69
15544: ADD
15545: ST_TO_ADDR
// if tmp then
15546: LD_VAR 0 2
15550: IFFALSE 15703
// repeat wait ( 0 0$1 ) ;
15552: LD_INT 35
15554: PPUSH
15555: CALL_OW 67
// for i in tmp do
15559: LD_ADDR_VAR 0 1
15563: PUSH
15564: LD_VAR 0 2
15568: PUSH
15569: FOR_IN
15570: IFFALSE 15652
// begin if IsInUnit ( i ) and GetType ( IsInUnit ( i ) ) = unit_building then
15572: LD_VAR 0 1
15576: PPUSH
15577: CALL_OW 310
15581: PUSH
15582: LD_VAR 0 1
15586: PPUSH
15587: CALL_OW 310
15591: PPUSH
15592: CALL_OW 247
15596: PUSH
15597: LD_INT 3
15599: EQUAL
15600: AND
15601: IFFALSE 15612
// ComExitBuilding ( i ) ;
15603: LD_VAR 0 1
15607: PPUSH
15608: CALL_OW 122
// AddComMoveXY ( i , 10 , 1 ) ;
15612: LD_VAR 0 1
15616: PPUSH
15617: LD_INT 10
15619: PPUSH
15620: LD_INT 1
15622: PPUSH
15623: CALL_OW 171
// if IsInArea ( i , legionEscape ) then
15627: LD_VAR 0 1
15631: PPUSH
15632: LD_INT 32
15634: PPUSH
15635: CALL_OW 308
15639: IFFALSE 15650
// RemoveUnit ( i ) ;
15641: LD_VAR 0 1
15645: PPUSH
15646: CALL_OW 64
// end ;
15650: GO 15569
15652: POP
15653: POP
// until not FilterAllUnits ( [ [ f_side , 8 ] , [ f_or , [ f_type , unit_human ] , [ f_control , control_manual ] ] ] ) ;
15654: LD_INT 22
15656: PUSH
15657: LD_INT 8
15659: PUSH
15660: EMPTY
15661: LIST
15662: LIST
15663: PUSH
15664: LD_INT 2
15666: PUSH
15667: LD_INT 21
15669: PUSH
15670: LD_INT 1
15672: PUSH
15673: EMPTY
15674: LIST
15675: LIST
15676: PUSH
15677: LD_INT 33
15679: PUSH
15680: LD_INT 1
15682: PUSH
15683: EMPTY
15684: LIST
15685: LIST
15686: PUSH
15687: EMPTY
15688: LIST
15689: LIST
15690: LIST
15691: PUSH
15692: EMPTY
15693: LIST
15694: LIST
15695: PPUSH
15696: CALL_OW 69
15700: NOT
15701: IFFALSE 15552
// end ;
15703: PPOPN 2
15705: END
// every 0 0$10 trigger americanDestroyed and russianDestroyed and legionDestroyed and arabianDestroyed and americanCapitulated and russianCapitulated and legionCapitulated do var med1 , med2 ;
15706: LD_EXP 4
15710: PUSH
15711: LD_EXP 2
15715: AND
15716: PUSH
15717: LD_EXP 3
15721: AND
15722: PUSH
15723: LD_EXP 5
15727: AND
15728: PUSH
15729: LD_EXP 6
15733: AND
15734: PUSH
15735: LD_EXP 7
15739: AND
15740: PUSH
15741: LD_EXP 8
15745: AND
15746: IFFALSE 17130
15748: GO 15750
15750: DISABLE
15751: LD_INT 0
15753: PPUSH
15754: PPUSH
// begin music_class := 5 ;
15755: LD_ADDR_OWVAR 72
15759: PUSH
15760: LD_INT 5
15762: ST_TO_ADDR
// music_nat := 5 ;
15763: LD_ADDR_OWVAR 71
15767: PUSH
15768: LD_INT 5
15770: ST_TO_ADDR
// if vehicleLostCounter < 3 then
15771: LD_EXP 15
15775: PUSH
15776: LD_INT 3
15778: LESS
15779: IFFALSE 15788
// SetAchievement ( ACH_ECONOMY ) ;
15781: LD_STRING ACH_ECONOMY
15783: PPUSH
15784: CALL_OW 543
// if tick < 60 60$00 then
15788: LD_OWVAR 1
15792: PUSH
15793: LD_INT 126000
15795: LESS
15796: IFFALSE 15812
// begin wait ( 3 ) ;
15798: LD_INT 3
15800: PPUSH
15801: CALL_OW 67
// SetAchievement ( ACH_ASPEED_19 ) ;
15805: LD_STRING ACH_ASPEED_19
15807: PPUSH
15808: CALL_OW 543
// end ; CenterNowOnUnits ( JMM ) ;
15812: LD_EXP 17
15816: PPUSH
15817: CALL_OW 87
// InGameOn ;
15821: CALL_OW 8
// DialogueOn ;
15825: CALL_OW 6
// Say ( JMM , DEnd-JMM-JMM-1 ) ;
15829: LD_EXP 17
15833: PPUSH
15834: LD_STRING DEnd-JMM-JMM-1
15836: PPUSH
15837: CALL_OW 88
// if Joan then
15841: LD_EXP 32
15845: IFFALSE 15861
// Say ( Joan , DEnd-JMM-Joan-1 ) else
15847: LD_EXP 32
15851: PPUSH
15852: LD_STRING DEnd-JMM-Joan-1
15854: PPUSH
15855: CALL_OW 88
15859: GO 15905
// if Lisa and GetSide ( Lisa ) = 7 and IsPlaced ( Lisa ) then
15861: LD_EXP 19
15865: PUSH
15866: LD_EXP 19
15870: PPUSH
15871: CALL_OW 255
15875: PUSH
15876: LD_INT 7
15878: EQUAL
15879: AND
15880: PUSH
15881: LD_EXP 19
15885: PPUSH
15886: CALL_OW 305
15890: AND
15891: IFFALSE 15905
// Say ( Lisa , DEnd-JMM-Lisa-1 ) ;
15893: LD_EXP 19
15897: PPUSH
15898: LD_STRING DEnd-JMM-Lisa-1
15900: PPUSH
15901: CALL_OW 88
// if Frank and IsPlaced ( Frank ) then
15905: LD_EXP 29
15909: PUSH
15910: LD_EXP 29
15914: PPUSH
15915: CALL_OW 305
15919: AND
15920: IFFALSE 15934
// Say ( Frank , DEnd-JMM-Frank-1 ) ;
15922: LD_EXP 29
15926: PPUSH
15927: LD_STRING DEnd-JMM-Frank-1
15929: PPUSH
15930: CALL_OW 88
// if Cyrus and GetSide ( Cyrus ) = 7 and IsPlaced ( Cyrus ) then
15934: LD_EXP 22
15938: PUSH
15939: LD_EXP 22
15943: PPUSH
15944: CALL_OW 255
15948: PUSH
15949: LD_INT 7
15951: EQUAL
15952: AND
15953: PUSH
15954: LD_EXP 22
15958: PPUSH
15959: CALL_OW 305
15963: AND
15964: IFFALSE 15978
// Say ( Cyrus , DEnd-JMM-Cyrus-1 ) ;
15966: LD_EXP 22
15970: PPUSH
15971: LD_STRING DEnd-JMM-Cyrus-1
15973: PPUSH
15974: CALL_OW 88
// if Burlak then
15978: LD_EXP 49
15982: IFFALSE 15996
// Say ( Burlak , DEnd-JMM-Bur-1 ) ;
15984: LD_EXP 49
15988: PPUSH
15989: LD_STRING DEnd-JMM-Bur-1
15991: PPUSH
15992: CALL_OW 88
// if Joan and Lisa and GetSide ( Lisa ) = 7 and IsPlaced ( Lisa ) then
15996: LD_EXP 32
16000: PUSH
16001: LD_EXP 19
16005: AND
16006: PUSH
16007: LD_EXP 19
16011: PPUSH
16012: CALL_OW 255
16016: PUSH
16017: LD_INT 7
16019: EQUAL
16020: AND
16021: PUSH
16022: LD_EXP 19
16026: PPUSH
16027: CALL_OW 305
16031: AND
16032: IFFALSE 16046
// Say ( Lisa , DEnd-Burlak-Lisa-1 ) ;
16034: LD_EXP 19
16038: PPUSH
16039: LD_STRING DEnd-Burlak-Lisa-1
16041: PPUSH
16042: CALL_OW 88
// if Belkov and IsPlaced ( Belkov ) then
16046: LD_EXP 50
16050: PUSH
16051: LD_EXP 50
16055: PPUSH
16056: CALL_OW 305
16060: AND
16061: IFFALSE 16075
// Say ( Belkov , DEnd-JMM-Bel-1 ) ;
16063: LD_EXP 50
16067: PPUSH
16068: LD_STRING DEnd-JMM-Bel-1
16070: PPUSH
16071: CALL_OW 88
// if Gnyevko and IsPlaced ( Gnyevko ) then
16075: LD_EXP 51
16079: PUSH
16080: LD_EXP 51
16084: PPUSH
16085: CALL_OW 305
16089: AND
16090: IFFALSE 16104
// Say ( Gnyevko , DEnd-JMM-Gny-1 ) ;
16092: LD_EXP 51
16096: PPUSH
16097: LD_STRING DEnd-JMM-Gny-1
16099: PPUSH
16100: CALL_OW 88
// if Cornel and GetSide ( Cornel ) = 7 and IsPlaced ( Cornel ) then
16104: LD_EXP 27
16108: PUSH
16109: LD_EXP 27
16113: PPUSH
16114: CALL_OW 255
16118: PUSH
16119: LD_INT 7
16121: EQUAL
16122: AND
16123: PUSH
16124: LD_EXP 27
16128: PPUSH
16129: CALL_OW 305
16133: AND
16134: IFFALSE 16148
// Say ( Cornel , DEnd-JMM-Corn-1 ) ;
16136: LD_EXP 27
16140: PPUSH
16141: LD_STRING DEnd-JMM-Corn-1
16143: PPUSH
16144: CALL_OW 88
// if Donaldson and GetSide ( Donaldson ) = 7 and IsPlaced ( Donaldson ) then
16148: LD_EXP 20
16152: PUSH
16153: LD_EXP 20
16157: PPUSH
16158: CALL_OW 255
16162: PUSH
16163: LD_INT 7
16165: EQUAL
16166: AND
16167: PUSH
16168: LD_EXP 20
16172: PPUSH
16173: CALL_OW 305
16177: AND
16178: IFFALSE 16192
// Say ( Donaldson , DEnd-JMM-Don-1 ) ;
16180: LD_EXP 20
16184: PPUSH
16185: LD_STRING DEnd-JMM-Don-1
16187: PPUSH
16188: CALL_OW 88
// if Bobby and GetSide ( Bobby ) = 7 and IsPlaced ( Bobby ) then
16192: LD_EXP 21
16196: PUSH
16197: LD_EXP 21
16201: PPUSH
16202: CALL_OW 255
16206: PUSH
16207: LD_INT 7
16209: EQUAL
16210: AND
16211: PUSH
16212: LD_EXP 21
16216: PPUSH
16217: CALL_OW 305
16221: AND
16222: IFFALSE 16236
// Say ( Bobby , DEnd-JMM-Bobby-1 ) ;
16224: LD_EXP 21
16228: PPUSH
16229: LD_STRING DEnd-JMM-Bobby-1
16231: PPUSH
16232: CALL_OW 88
// if Denis and GetSide ( Denis ) = 7 and IsPlaced ( Denis ) then
16236: LD_EXP 23
16240: PUSH
16241: LD_EXP 23
16245: PPUSH
16246: CALL_OW 255
16250: PUSH
16251: LD_INT 7
16253: EQUAL
16254: AND
16255: PUSH
16256: LD_EXP 23
16260: PPUSH
16261: CALL_OW 305
16265: AND
16266: IFFALSE 16280
// Say ( Denis , DEnd-JMM-Den-1 ) ;
16268: LD_EXP 23
16272: PPUSH
16273: LD_STRING DEnd-JMM-Den-1
16275: PPUSH
16276: CALL_OW 88
// if Gladstone and GetSide ( Gladstone ) = 7 and IsPlaced ( Gladstone ) then
16280: LD_EXP 25
16284: PUSH
16285: LD_EXP 25
16289: PPUSH
16290: CALL_OW 255
16294: PUSH
16295: LD_INT 7
16297: EQUAL
16298: AND
16299: PUSH
16300: LD_EXP 25
16304: PPUSH
16305: CALL_OW 305
16309: AND
16310: IFFALSE 16324
// Say ( Gladstone , DEnd-JMM-Glad-1 ) ;
16312: LD_EXP 25
16316: PPUSH
16317: LD_STRING DEnd-JMM-Glad-1
16319: PPUSH
16320: CALL_OW 88
// if Kikuchi and GetSide ( Kikuchi ) = 7 and IsPlaced ( Kikuchi ) then
16324: LD_EXP 30
16328: PUSH
16329: LD_EXP 30
16333: PPUSH
16334: CALL_OW 255
16338: PUSH
16339: LD_INT 7
16341: EQUAL
16342: AND
16343: PUSH
16344: LD_EXP 30
16348: PPUSH
16349: CALL_OW 305
16353: AND
16354: IFFALSE 16368
// Say ( Kikuchi , DEnd-JMM-Yam-1 ) ;
16356: LD_EXP 30
16360: PPUSH
16361: LD_STRING DEnd-JMM-Yam-1
16363: PPUSH
16364: CALL_OW 88
// if Brown and GetSide ( Brown ) = 7 and IsPlaced ( Brown ) then
16368: LD_EXP 24
16372: PUSH
16373: LD_EXP 24
16377: PPUSH
16378: CALL_OW 255
16382: PUSH
16383: LD_INT 7
16385: EQUAL
16386: AND
16387: PUSH
16388: LD_EXP 24
16392: PPUSH
16393: CALL_OW 305
16397: AND
16398: IFFALSE 16412
// Say ( Brown , DEnd-JMM-Brown-1 ) ;
16400: LD_EXP 24
16404: PPUSH
16405: LD_STRING DEnd-JMM-Brown-1
16407: PPUSH
16408: CALL_OW 88
// if Connie and GetSide ( Connie ) = 7 and IsPlaced ( Connie ) then
16412: LD_EXP 34
16416: PUSH
16417: LD_EXP 34
16421: PPUSH
16422: CALL_OW 255
16426: PUSH
16427: LD_INT 7
16429: EQUAL
16430: AND
16431: PUSH
16432: LD_EXP 34
16436: PPUSH
16437: CALL_OW 305
16441: AND
16442: IFFALSE 16456
// Say ( Connie , DEnd-JMM-Con-1 ) ;
16444: LD_EXP 34
16448: PPUSH
16449: LD_STRING DEnd-JMM-Con-1
16451: PPUSH
16452: CALL_OW 88
// if Gary and GetSide ( Gary ) = 7 and IsPlaced ( Gary ) then
16456: LD_EXP 28
16460: PUSH
16461: LD_EXP 28
16465: PPUSH
16466: CALL_OW 255
16470: PUSH
16471: LD_INT 7
16473: EQUAL
16474: AND
16475: PUSH
16476: LD_EXP 28
16480: PPUSH
16481: CALL_OW 305
16485: AND
16486: IFFALSE 16500
// Say ( Gary , DEnd-JMM-Gary-1 ) ;
16488: LD_EXP 28
16492: PPUSH
16493: LD_STRING DEnd-JMM-Gary-1
16495: PPUSH
16496: CALL_OW 88
// if Simms and Roth and IsPlaced ( Simms ) then
16500: LD_EXP 31
16504: PUSH
16505: LD_EXP 18
16509: AND
16510: PUSH
16511: LD_EXP 31
16515: PPUSH
16516: CALL_OW 305
16520: AND
16521: IFFALSE 16535
// Say ( Simms , DEnd-JMM-Sim-1 ) ;
16523: LD_EXP 31
16527: PPUSH
16528: LD_STRING DEnd-JMM-Sim-1
16530: PPUSH
16531: CALL_OW 88
// if Houten and GetSide ( Houten ) = 7 and IsPlaced ( Houten ) then
16535: LD_EXP 26
16539: PUSH
16540: LD_EXP 26
16544: PPUSH
16545: CALL_OW 255
16549: PUSH
16550: LD_INT 7
16552: EQUAL
16553: AND
16554: PUSH
16555: LD_EXP 26
16559: PPUSH
16560: CALL_OW 305
16564: AND
16565: IFFALSE 16579
// Say ( Houten , DEnd-JMM-VanH-1 ) ;
16567: LD_EXP 26
16571: PPUSH
16572: LD_STRING DEnd-JMM-VanH-1
16574: PPUSH
16575: CALL_OW 88
// if Dolgov and IsPlaced ( Dolgov ) then
16579: LD_EXP 39
16583: PUSH
16584: LD_EXP 39
16588: PPUSH
16589: CALL_OW 305
16593: AND
16594: IFFALSE 16608
// Say ( Dolgov , DEnd-JMM-Dol-1 ) ;
16596: LD_EXP 39
16600: PPUSH
16601: LD_STRING DEnd-JMM-Dol-1
16603: PPUSH
16604: CALL_OW 88
// if Kapitsova and IsPlaced ( Kapitsova ) then
16608: LD_EXP 43
16612: PUSH
16613: LD_EXP 43
16617: PPUSH
16618: CALL_OW 305
16622: AND
16623: IFFALSE 16637
// Say ( Kapitsova , DEnd-JMM-Kap-1 ) ;
16625: LD_EXP 43
16629: PPUSH
16630: LD_STRING DEnd-JMM-Kap-1
16632: PPUSH
16633: CALL_OW 88
// if Kovalyuk and IsPlaced ( Kovalyuk ) then
16637: LD_EXP 46
16641: PUSH
16642: LD_EXP 46
16646: PPUSH
16647: CALL_OW 305
16651: AND
16652: IFFALSE 16666
// Say ( Kovalyuk , DEnd-JMM-Kov-1 ) ;
16654: LD_EXP 46
16658: PPUSH
16659: LD_STRING DEnd-JMM-Kov-1
16661: PPUSH
16662: CALL_OW 88
// if Scholtze and IsPlaced ( Scholtze ) then
16666: LD_EXP 41
16670: PUSH
16671: LD_EXP 41
16675: PPUSH
16676: CALL_OW 305
16680: AND
16681: IFFALSE 16695
// Say ( Scholtze , DEnd-JMM-Sch-1 ) ;
16683: LD_EXP 41
16687: PPUSH
16688: LD_STRING DEnd-JMM-Sch-1
16690: PPUSH
16691: CALL_OW 88
// if Titov and IsPlaced ( Titov ) then
16695: LD_EXP 37
16699: PUSH
16700: LD_EXP 37
16704: PPUSH
16705: CALL_OW 305
16709: AND
16710: IFFALSE 16724
// Say ( Titov , DEnd-JMM-Tit-1 ) ;
16712: LD_EXP 37
16716: PPUSH
16717: LD_STRING DEnd-JMM-Tit-1
16719: PPUSH
16720: CALL_OW 88
// if Oblukov and IsPlaced ( Oblukov ) then
16724: LD_EXP 42
16728: PUSH
16729: LD_EXP 42
16733: PPUSH
16734: CALL_OW 305
16738: AND
16739: IFFALSE 16753
// Say ( Oblukov , DEnd-JMM-Obl-1 ) ;
16741: LD_EXP 42
16745: PPUSH
16746: LD_STRING DEnd-JMM-Obl-1
16748: PPUSH
16749: CALL_OW 88
// if Lipshchin and IsPlaced ( Lipshchin ) then
16753: LD_EXP 44
16757: PUSH
16758: LD_EXP 44
16762: PPUSH
16763: CALL_OW 305
16767: AND
16768: IFFALSE 16782
// Say ( Lipshchin , DEnd-JMM-Lip-1 ) ;
16770: LD_EXP 44
16774: PPUSH
16775: LD_STRING DEnd-JMM-Lip-1
16777: PPUSH
16778: CALL_OW 88
// if Fadeev and IsPlaced ( Fadeev ) and Burlak then
16782: LD_EXP 38
16786: PUSH
16787: LD_EXP 38
16791: PPUSH
16792: CALL_OW 305
16796: AND
16797: PUSH
16798: LD_EXP 49
16802: AND
16803: IFFALSE 16817
// Say ( Fadeev , DEnd-Burlak-Fad-1 ) ;
16805: LD_EXP 38
16809: PPUSH
16810: LD_STRING DEnd-Burlak-Fad-1
16812: PPUSH
16813: CALL_OW 88
// if Petrovova and IsPlaced ( Petrovova ) then
16817: LD_EXP 45
16821: PUSH
16822: LD_EXP 45
16826: PPUSH
16827: CALL_OW 305
16831: AND
16832: IFFALSE 16846
// Say ( Petrovova , DEnd-Burlak-Ptr-1 ) ;
16834: LD_EXP 45
16838: PPUSH
16839: LD_STRING DEnd-Burlak-Ptr-1
16841: PPUSH
16842: CALL_OW 88
// if Kuzmov and IsPlaced ( Kuzmov ) then
16846: LD_EXP 47
16850: PUSH
16851: LD_EXP 47
16855: PPUSH
16856: CALL_OW 305
16860: AND
16861: IFFALSE 16875
// Say ( Kuzmov , DEnd-Burlak-Kuz-1 ) ;
16863: LD_EXP 47
16867: PPUSH
16868: LD_STRING DEnd-Burlak-Kuz-1
16870: PPUSH
16871: CALL_OW 88
// if Kirilenkova and IsPlaced ( Kirilenkova ) and Burlak then
16875: LD_EXP 36
16879: PUSH
16880: LD_EXP 36
16884: PPUSH
16885: CALL_OW 305
16889: AND
16890: PUSH
16891: LD_EXP 49
16895: AND
16896: IFFALSE 16910
// Say ( Kirilenkova , DEnd-Burlak-Kir-1 ) ;
16898: LD_EXP 36
16902: PPUSH
16903: LD_STRING DEnd-Burlak-Kir-1
16905: PPUSH
16906: CALL_OW 88
// if Burlak then
16910: LD_EXP 49
16914: IFFALSE 16928
// Say ( JMM , DEnd-Burlak-JMM-1 ) ;
16916: LD_EXP 17
16920: PPUSH
16921: LD_STRING DEnd-Burlak-JMM-1
16923: PPUSH
16924: CALL_OW 88
// dwait ( 0 0$2 ) ;
16928: LD_INT 70
16930: PPUSH
16931: CALL_OW 68
// SayRadio ( Schulz , DEnd-Szulc ) ;
16935: LD_EXP 54
16939: PPUSH
16940: LD_STRING DEnd-Szulc
16942: PPUSH
16943: CALL_OW 94
// dwait ( 0 0$1 ) ;
16947: LD_INT 35
16949: PPUSH
16950: CALL_OW 68
// if IsLive ( Burlak ) then
16954: LD_EXP 49
16958: PPUSH
16959: CALL_OW 300
16963: IFFALSE 16975
// med1 := 1 else
16965: LD_ADDR_VAR 0 1
16969: PUSH
16970: LD_INT 1
16972: ST_TO_ADDR
16973: GO 16984
// med1 := - 1 ;
16975: LD_ADDR_VAR 0 1
16979: PUSH
16980: LD_INT 1
16982: NEG
16983: ST_TO_ADDR
// if artifactIResearched and artifactIIResearched and artifactIIIResearched then
16984: LD_EXP 12
16988: PUSH
16989: LD_EXP 13
16993: AND
16994: PUSH
16995: LD_EXP 14
16999: AND
17000: IFFALSE 17012
// med2 := 1 else
17002: LD_ADDR_VAR 0 2
17006: PUSH
17007: LD_INT 1
17009: ST_TO_ADDR
17010: GO 17021
// med2 := - 1 ;
17012: LD_ADDR_VAR 0 2
17016: PUSH
17017: LD_INT 1
17019: NEG
17020: ST_TO_ADDR
// AddMedal ( Hero , 1 ) ;
17021: LD_STRING Hero
17023: PPUSH
17024: LD_INT 1
17026: PPUSH
17027: CALL_OW 101
// AddMedal ( Artefact , med2 ) ;
17031: LD_STRING Artefact
17033: PPUSH
17034: LD_VAR 0 2
17038: PPUSH
17039: CALL_OW 101
// AddMedal ( ReconcileBurlak , med1 ) ;
17043: LD_STRING ReconcileBurlak
17045: PPUSH
17046: LD_VAR 0 1
17050: PPUSH
17051: CALL_OW 101
// if Difficulty = 3 and med1 = 1 and med2 = 1 then
17055: LD_OWVAR 67
17059: PUSH
17060: LD_INT 3
17062: EQUAL
17063: PUSH
17064: LD_VAR 0 1
17068: PUSH
17069: LD_INT 1
17071: EQUAL
17072: AND
17073: PUSH
17074: LD_VAR 0 2
17078: PUSH
17079: LD_INT 1
17081: EQUAL
17082: AND
17083: IFFALSE 17095
// SetAchievementEX ( ACH_AMER , 19 ) ;
17085: LD_STRING ACH_AMER
17087: PPUSH
17088: LD_INT 19
17090: PPUSH
17091: CALL_OW 564
// GiveMedals ( MAIN ) ;
17095: LD_STRING MAIN
17097: PPUSH
17098: CALL_OW 102
// InGameOff ;
17102: CALL_OW 9
// DialogueOff ;
17106: CALL_OW 7
// music_nat := 1 ;
17110: LD_ADDR_OWVAR 71
17114: PUSH
17115: LD_INT 1
17117: ST_TO_ADDR
// music_class := 4 ;
17118: LD_ADDR_OWVAR 72
17122: PUSH
17123: LD_INT 4
17125: ST_TO_ADDR
// YouWin ;
17126: CALL_OW 103
// end ; end_of_file
17130: PPOPN 2
17132: END
// export function InitNature ; begin
17133: LD_INT 0
17135: PPUSH
// PrepareNature ( 3 , 3 , 2 , 1 , 1 , 0 , 0 , natureArea1 , 0 ) ;
17136: LD_INT 3
17138: PPUSH
17139: LD_INT 3
17141: PPUSH
17142: LD_INT 2
17144: PPUSH
17145: LD_INT 1
17147: PPUSH
17148: LD_INT 1
17150: PPUSH
17151: LD_INT 0
17153: PPUSH
17154: LD_INT 0
17156: PPUSH
17157: LD_INT 17
17159: PPUSH
17160: LD_INT 0
17162: PPUSH
17163: CALL 85452 0 9
// PrepareNature ( 2 , 1 , 1 , 1 , 1 , 0 , 0 , natureArea2 , 0 ) ;
17167: LD_INT 2
17169: PPUSH
17170: LD_INT 1
17172: PPUSH
17173: LD_INT 1
17175: PPUSH
17176: LD_INT 1
17178: PPUSH
17179: LD_INT 1
17181: PPUSH
17182: LD_INT 0
17184: PPUSH
17185: LD_INT 0
17187: PPUSH
17188: LD_INT 18
17190: PPUSH
17191: LD_INT 0
17193: PPUSH
17194: CALL 85452 0 9
// PrepareNature ( 4 , 1 , 2 , 4 , 2 , 1 , 0 , natureArea3 , 0 ) ;
17198: LD_INT 4
17200: PPUSH
17201: LD_INT 1
17203: PPUSH
17204: LD_INT 2
17206: PPUSH
17207: LD_INT 4
17209: PPUSH
17210: LD_INT 2
17212: PPUSH
17213: LD_INT 1
17215: PPUSH
17216: LD_INT 0
17218: PPUSH
17219: LD_INT 19
17221: PPUSH
17222: LD_INT 0
17224: PPUSH
17225: CALL 85452 0 9
// PrepareNature ( 0 , 0 , 0 , 0 , 0 , 0 , 9 , 0 , natureWaterArea ) ;
17229: LD_INT 0
17231: PPUSH
17232: LD_INT 0
17234: PPUSH
17235: LD_INT 0
17237: PPUSH
17238: LD_INT 0
17240: PPUSH
17241: LD_INT 0
17243: PPUSH
17244: LD_INT 0
17246: PPUSH
17247: LD_INT 9
17249: PPUSH
17250: LD_INT 0
17252: PPUSH
17253: LD_INT 20
17255: PPUSH
17256: CALL 85452 0 9
// end ; end_of_file
17260: LD_VAR 0 1
17264: RET
// every 0 0$30 do var time ;
17265: GO 17267
17267: DISABLE
17268: LD_INT 0
17270: PPUSH
// begin time := 0 0$50 ;
17271: LD_ADDR_VAR 0 1
17275: PUSH
17276: LD_INT 1750
17278: ST_TO_ADDR
// repeat wait ( time ) ;
17279: LD_VAR 0 1
17283: PPUSH
17284: CALL_OW 67
// if Prob ( 50 ) then
17288: LD_INT 50
17290: PPUSH
17291: CALL_OW 13
17295: IFFALSE 17324
// CreateCratesXYR ( rand ( 1 , 5 ) , 106 , 89 , 45 , true ) ;
17297: LD_INT 1
17299: PPUSH
17300: LD_INT 5
17302: PPUSH
17303: CALL_OW 12
17307: PPUSH
17308: LD_INT 106
17310: PPUSH
17311: LD_INT 89
17313: PPUSH
17314: LD_INT 45
17316: PPUSH
17317: LD_INT 1
17319: PPUSH
17320: CALL_OW 56
// time := time + 0 0$3 ;
17324: LD_ADDR_VAR 0 1
17328: PUSH
17329: LD_VAR 0 1
17333: PUSH
17334: LD_INT 105
17336: PLUS
17337: ST_TO_ADDR
// if Prob ( 30 ) then
17338: LD_INT 30
17340: PPUSH
17341: CALL_OW 13
17345: IFFALSE 17391
// begin wait ( rand ( 0 0$15 , 0 0$21 ) ) ;
17347: LD_INT 525
17349: PPUSH
17350: LD_INT 735
17352: PPUSH
17353: CALL_OW 12
17357: PPUSH
17358: CALL_OW 67
// CreateCratesXYR ( rand ( 1 , 5 ) , 21 , 26 , 12 , true ) ;
17362: LD_INT 1
17364: PPUSH
17365: LD_INT 5
17367: PPUSH
17368: CALL_OW 12
17372: PPUSH
17373: LD_INT 21
17375: PPUSH
17376: LD_INT 26
17378: PPUSH
17379: LD_INT 12
17381: PPUSH
17382: LD_INT 1
17384: PPUSH
17385: CALL_OW 56
// end else
17389: GO 17427
// begin wait ( rand ( 0 0$20 , 0 0$35 ) ) ;
17391: LD_INT 700
17393: PPUSH
17394: LD_INT 1225
17396: PPUSH
17397: CALL_OW 12
17401: PPUSH
17402: CALL_OW 67
// CreateCratesArea ( rand ( 1 , 5 ) , russianCratesArea , true ) ;
17406: LD_INT 1
17408: PPUSH
17409: LD_INT 5
17411: PPUSH
17412: CALL_OW 12
17416: PPUSH
17417: LD_INT 14
17419: PPUSH
17420: LD_INT 1
17422: PPUSH
17423: CALL_OW 55
// end ; if Prob ( 50 ) then
17427: LD_INT 50
17429: PPUSH
17430: CALL_OW 13
17434: IFFALSE 17480
// begin wait ( rand ( 0 0$20 , 0 0$30 ) ) ;
17436: LD_INT 700
17438: PPUSH
17439: LD_INT 1050
17441: PPUSH
17442: CALL_OW 12
17446: PPUSH
17447: CALL_OW 67
// CreateCratesXYR ( rand ( 1 , 5 ) , 181 , 218 , 16 , true ) ;
17451: LD_INT 1
17453: PPUSH
17454: LD_INT 5
17456: PPUSH
17457: CALL_OW 12
17461: PPUSH
17462: LD_INT 181
17464: PPUSH
17465: LD_INT 218
17467: PPUSH
17468: LD_INT 16
17470: PPUSH
17471: LD_INT 1
17473: PPUSH
17474: CALL_OW 56
// end else
17478: GO 17552
// begin wait ( rand ( 0 0$10 , 0 0$15 ) ) ;
17480: LD_INT 350
17482: PPUSH
17483: LD_INT 525
17485: PPUSH
17486: CALL_OW 12
17490: PPUSH
17491: CALL_OW 67
// CreateCratesArea ( rand ( 1 , 5 ) , legionCratesArea , true ) ;
17495: LD_INT 1
17497: PPUSH
17498: LD_INT 5
17500: PPUSH
17501: CALL_OW 12
17505: PPUSH
17506: LD_INT 13
17508: PPUSH
17509: LD_INT 1
17511: PPUSH
17512: CALL_OW 55
// wait ( rand ( 0 0$10 , 0 0$20 ) ) ;
17516: LD_INT 350
17518: PPUSH
17519: LD_INT 700
17521: PPUSH
17522: CALL_OW 12
17526: PPUSH
17527: CALL_OW 67
// CreateCratesArea ( rand ( 1 , 5 ) , americanCratesArea , true ) ;
17531: LD_INT 1
17533: PPUSH
17534: LD_INT 5
17536: PPUSH
17537: CALL_OW 12
17541: PPUSH
17542: LD_INT 33
17544: PPUSH
17545: LD_INT 1
17547: PPUSH
17548: CALL_OW 55
// end ; if Prob ( [ 65 , 62 , 55 ] [ Difficulty ] ) then
17552: LD_INT 65
17554: PUSH
17555: LD_INT 62
17557: PUSH
17558: LD_INT 55
17560: PUSH
17561: EMPTY
17562: LIST
17563: LIST
17564: LIST
17565: PUSH
17566: LD_OWVAR 67
17570: ARRAY
17571: PPUSH
17572: CALL_OW 13
17576: IFFALSE 17622
// begin wait ( rand ( 0 0$15 , 0 0$25 ) ) ;
17578: LD_INT 525
17580: PPUSH
17581: LD_INT 875
17583: PPUSH
17584: CALL_OW 12
17588: PPUSH
17589: CALL_OW 67
// CreateCratesXYR ( rand ( 1 , 5 ) , 294 , 211 , 30 , true ) ;
17593: LD_INT 1
17595: PPUSH
17596: LD_INT 5
17598: PPUSH
17599: CALL_OW 12
17603: PPUSH
17604: LD_INT 294
17606: PPUSH
17607: LD_INT 211
17609: PPUSH
17610: LD_INT 30
17612: PPUSH
17613: LD_INT 1
17615: PPUSH
17616: CALL_OW 56
// end else
17620: GO 17664
// begin wait ( rand ( 0 0$12 , 0 0$22 ) ) ;
17622: LD_INT 420
17624: PPUSH
17625: LD_INT 770
17627: PPUSH
17628: CALL_OW 12
17632: PPUSH
17633: CALL_OW 67
// CreateCratesXYR ( rand ( 1 , 5 ) , 294 , 211 , 30 , true ) ;
17637: LD_INT 1
17639: PPUSH
17640: LD_INT 5
17642: PPUSH
17643: CALL_OW 12
17647: PPUSH
17648: LD_INT 294
17650: PPUSH
17651: LD_INT 211
17653: PPUSH
17654: LD_INT 30
17656: PPUSH
17657: LD_INT 1
17659: PPUSH
17660: CALL_OW 56
// end ; if time > 2 2$20 then
17664: LD_VAR 0 1
17668: PUSH
17669: LD_INT 4900
17671: GREATER
17672: IFFALSE 17682
// time := 0 0$50 ;
17674: LD_ADDR_VAR 0 1
17678: PUSH
17679: LD_INT 1750
17681: ST_TO_ADDR
// until false ;
17682: LD_INT 0
17684: IFFALSE 17279
// end ;
17686: PPOPN 1
17688: END
// every 0 0$45 trigger tick < 10 10$00 do
17689: LD_OWVAR 1
17693: PUSH
17694: LD_INT 21000
17696: LESS
17697: IFFALSE 17745
17699: GO 17701
17701: DISABLE
// begin enable ;
17702: ENABLE
// wait ( rand ( 0 0$10 , 0 0$20 ) ) ;
17703: LD_INT 350
17705: PPUSH
17706: LD_INT 700
17708: PPUSH
17709: CALL_OW 12
17713: PPUSH
17714: CALL_OW 67
// CreateCratesXYR ( rand ( 3 , 5 ) , 181 , 13 , 20 , true ) ;
17718: LD_INT 3
17720: PPUSH
17721: LD_INT 5
17723: PPUSH
17724: CALL_OW 12
17728: PPUSH
17729: LD_INT 181
17731: PPUSH
17732: LD_INT 13
17734: PPUSH
17735: LD_INT 20
17737: PPUSH
17738: LD_INT 1
17740: PPUSH
17741: CALL_OW 56
// end ; end_of_file
17745: END
// export artifactsPos , artifactsRecharge , artifactsSibCost , artifactsResearched , artifactsLabsWorking ; export artifactsResDifficulty , artifactsResProgress , artifactsLabs , artifactsButtons , artifactsReady ; export function InitArtifact ; begin
17746: LD_INT 0
17748: PPUSH
// SetArtifactRes ( 7 , true ) ;
17749: LD_INT 7
17751: PPUSH
17752: LD_INT 1
17754: PPUSH
17755: CALL_OW 467
// artifactsPos := [ [ ] , [ ] , [ ] ] ;
17759: LD_ADDR_EXP 62
17763: PUSH
17764: EMPTY
17765: PUSH
17766: EMPTY
17767: PUSH
17768: EMPTY
17769: PUSH
17770: EMPTY
17771: LIST
17772: LIST
17773: LIST
17774: ST_TO_ADDR
// artifactsRecharge := [ 0 0$30 * Difficulty , 1 1$20 * Difficulty , - 1 ] ;
17775: LD_ADDR_EXP 63
17779: PUSH
17780: LD_INT 1050
17782: PUSH
17783: LD_OWVAR 67
17787: MUL
17788: PUSH
17789: LD_INT 2800
17791: PUSH
17792: LD_OWVAR 67
17796: MUL
17797: PUSH
17798: LD_INT 1
17800: NEG
17801: PUSH
17802: EMPTY
17803: LIST
17804: LIST
17805: LIST
17806: ST_TO_ADDR
// artifactsSibCost := [ 10 , 35 , 100 ] ;
17807: LD_ADDR_EXP 64
17811: PUSH
17812: LD_INT 10
17814: PUSH
17815: LD_INT 35
17817: PUSH
17818: LD_INT 100
17820: PUSH
17821: EMPTY
17822: LIST
17823: LIST
17824: LIST
17825: ST_TO_ADDR
// artifactsResearched := [ 0 , 0 , 0 ] ;
17826: LD_ADDR_EXP 65
17830: PUSH
17831: LD_INT 0
17833: PUSH
17834: LD_INT 0
17836: PUSH
17837: LD_INT 0
17839: PUSH
17840: EMPTY
17841: LIST
17842: LIST
17843: LIST
17844: ST_TO_ADDR
// artifactsResDifficulty := [ 300 , 500 , 800 ] ;
17845: LD_ADDR_EXP 67
17849: PUSH
17850: LD_INT 300
17852: PUSH
17853: LD_INT 500
17855: PUSH
17856: LD_INT 800
17858: PUSH
17859: EMPTY
17860: LIST
17861: LIST
17862: LIST
17863: ST_TO_ADDR
// artifactsResProgress := [ 0 , 0 , 0 ] ;
17864: LD_ADDR_EXP 68
17868: PUSH
17869: LD_INT 0
17871: PUSH
17872: LD_INT 0
17874: PUSH
17875: LD_INT 0
17877: PUSH
17878: EMPTY
17879: LIST
17880: LIST
17881: LIST
17882: ST_TO_ADDR
// artifactsLabs := [ 0 , 0 , 0 ] ;
17883: LD_ADDR_EXP 69
17887: PUSH
17888: LD_INT 0
17890: PUSH
17891: LD_INT 0
17893: PUSH
17894: LD_INT 0
17896: PUSH
17897: EMPTY
17898: LIST
17899: LIST
17900: LIST
17901: ST_TO_ADDR
// artifactsLabsWorking := [ 0 , 0 , 0 ] ;
17902: LD_ADDR_EXP 66
17906: PUSH
17907: LD_INT 0
17909: PUSH
17910: LD_INT 0
17912: PUSH
17913: LD_INT 0
17915: PUSH
17916: EMPTY
17917: LIST
17918: LIST
17919: LIST
17920: ST_TO_ADDR
// artifactsButtons := [ [ art_use_eye , art_place , art_exp_left ] , [ art_use_sibexplosion , art_unit , art_exp_mid ] , [ art_use_teleport , art_place , art_exp_right ] ] ;
17921: LD_ADDR_EXP 70
17925: PUSH
17926: LD_INT 4
17928: PUSH
17929: LD_INT 3
17931: PUSH
17932: LD_INT 1
17934: PUSH
17935: EMPTY
17936: LIST
17937: LIST
17938: LIST
17939: PUSH
17940: LD_INT 5
17942: PUSH
17943: LD_INT 4
17945: PUSH
17946: LD_INT 2
17948: PUSH
17949: EMPTY
17950: LIST
17951: LIST
17952: LIST
17953: PUSH
17954: LD_INT 6
17956: PUSH
17957: LD_INT 3
17959: PUSH
17960: LD_INT 3
17962: PUSH
17963: EMPTY
17964: LIST
17965: LIST
17966: LIST
17967: PUSH
17968: EMPTY
17969: LIST
17970: LIST
17971: LIST
17972: ST_TO_ADDR
// artifactsReady := [ 0 , 0 , 0 ] ;
17973: LD_ADDR_EXP 71
17977: PUSH
17978: LD_INT 0
17980: PUSH
17981: LD_INT 0
17983: PUSH
17984: LD_INT 0
17986: PUSH
17987: EMPTY
17988: LIST
17989: LIST
17990: LIST
17991: ST_TO_ADDR
// end ;
17992: LD_VAR 0 1
17996: RET
// every 0 0$1 trigger GetTech ( tech_artifact , 7 ) = state_researched do var i , pos , j , labs , nearestLab ;
17997: LD_INT 24
17999: PPUSH
18000: LD_INT 7
18002: PPUSH
18003: CALL_OW 321
18007: PUSH
18008: LD_INT 2
18010: EQUAL
18011: IFFALSE 18937
18013: GO 18015
18015: DISABLE
18016: LD_INT 0
18018: PPUSH
18019: PPUSH
18020: PPUSH
18021: PPUSH
18022: PPUSH
// begin enable ;
18023: ENABLE
// for i = 1 to 3 do
18024: LD_ADDR_VAR 0 1
18028: PUSH
18029: DOUBLE
18030: LD_INT 1
18032: DEC
18033: ST_TO_ADDR
18034: LD_INT 3
18036: PUSH
18037: FOR_TO
18038: IFFALSE 18935
// begin pos := FindArtifact ( i + 2 ) ;
18040: LD_ADDR_VAR 0 2
18044: PUSH
18045: LD_VAR 0 1
18049: PUSH
18050: LD_INT 2
18052: PLUS
18053: PPUSH
18054: CALL_OW 469
18058: ST_TO_ADDR
// artifactsPos := Replace ( artifactsPos , i , pos ) ;
18059: LD_ADDR_EXP 62
18063: PUSH
18064: LD_EXP 62
18068: PPUSH
18069: LD_VAR 0 1
18073: PPUSH
18074: LD_VAR 0 2
18078: PPUSH
18079: CALL_OW 1
18083: ST_TO_ADDR
// if pos then
18084: LD_VAR 0 2
18088: IFFALSE 18796
// begin case i of 1 :
18090: LD_VAR 0 1
18094: PUSH
18095: LD_INT 1
18097: DOUBLE
18098: EQUAL
18099: IFTRUE 18103
18101: GO 18180
18103: POP
// labs := FilterAllUnits ( [ [ f_side , 7 ] , [ f_nation , 1 ] , [ f_or , [ f_btype , b_lab_full ] , [ f_btype , b_lab_half ] , [ f_btype , b_lab_siberium ] ] ] ) ; 2 :
18104: LD_ADDR_VAR 0 4
18108: PUSH
18109: LD_INT 22
18111: PUSH
18112: LD_INT 7
18114: PUSH
18115: EMPTY
18116: LIST
18117: LIST
18118: PUSH
18119: LD_INT 23
18121: PUSH
18122: LD_INT 1
18124: PUSH
18125: EMPTY
18126: LIST
18127: LIST
18128: PUSH
18129: LD_INT 2
18131: PUSH
18132: LD_INT 30
18134: PUSH
18135: LD_INT 8
18137: PUSH
18138: EMPTY
18139: LIST
18140: LIST
18141: PUSH
18142: LD_INT 30
18144: PUSH
18145: LD_INT 7
18147: PUSH
18148: EMPTY
18149: LIST
18150: LIST
18151: PUSH
18152: LD_INT 30
18154: PUSH
18155: LD_INT 11
18157: PUSH
18158: EMPTY
18159: LIST
18160: LIST
18161: PUSH
18162: EMPTY
18163: LIST
18164: LIST
18165: LIST
18166: LIST
18167: PUSH
18168: EMPTY
18169: LIST
18170: LIST
18171: LIST
18172: PPUSH
18173: CALL_OW 69
18177: ST_TO_ADDR
18178: GO 18288
18180: LD_INT 2
18182: DOUBLE
18183: EQUAL
18184: IFTRUE 18188
18186: GO 18265
18188: POP
// labs := FilterAllUnits ( [ [ f_side , 7 ] , [ f_nation , 3 ] , [ f_or , [ f_btype , b_lab_full ] , [ f_btype , b_lab_half ] , [ f_btype , b_lab_siberium ] ] ] ) ; 3 :
18189: LD_ADDR_VAR 0 4
18193: PUSH
18194: LD_INT 22
18196: PUSH
18197: LD_INT 7
18199: PUSH
18200: EMPTY
18201: LIST
18202: LIST
18203: PUSH
18204: LD_INT 23
18206: PUSH
18207: LD_INT 3
18209: PUSH
18210: EMPTY
18211: LIST
18212: LIST
18213: PUSH
18214: LD_INT 2
18216: PUSH
18217: LD_INT 30
18219: PUSH
18220: LD_INT 8
18222: PUSH
18223: EMPTY
18224: LIST
18225: LIST
18226: PUSH
18227: LD_INT 30
18229: PUSH
18230: LD_INT 7
18232: PUSH
18233: EMPTY
18234: LIST
18235: LIST
18236: PUSH
18237: LD_INT 30
18239: PUSH
18240: LD_INT 11
18242: PUSH
18243: EMPTY
18244: LIST
18245: LIST
18246: PUSH
18247: EMPTY
18248: LIST
18249: LIST
18250: LIST
18251: LIST
18252: PUSH
18253: EMPTY
18254: LIST
18255: LIST
18256: LIST
18257: PPUSH
18258: CALL_OW 69
18262: ST_TO_ADDR
18263: GO 18288
18265: LD_INT 3
18267: DOUBLE
18268: EQUAL
18269: IFTRUE 18273
18271: GO 18287
18273: POP
// labs := [ alien ] ; end ;
18274: LD_ADDR_VAR 0 4
18278: PUSH
18279: LD_INT 1
18281: PUSH
18282: EMPTY
18283: LIST
18284: ST_TO_ADDR
18285: GO 18288
18287: POP
// if not labs then
18288: LD_VAR 0 4
18292: NOT
18293: IFFALSE 18297
// continue ;
18295: GO 18037
// nearestLab := NearestUnitToXY ( labs , artifactsPos [ i ] [ 1 ] , artifactsPos [ i ] [ 2 ] ) ;
18297: LD_ADDR_VAR 0 5
18301: PUSH
18302: LD_VAR 0 4
18306: PPUSH
18307: LD_EXP 62
18311: PUSH
18312: LD_VAR 0 1
18316: ARRAY
18317: PUSH
18318: LD_INT 1
18320: ARRAY
18321: PPUSH
18322: LD_EXP 62
18326: PUSH
18327: LD_VAR 0 1
18331: ARRAY
18332: PUSH
18333: LD_INT 2
18335: ARRAY
18336: PPUSH
18337: CALL_OW 73
18341: ST_TO_ADDR
// if not nearestLab or nearestLab <> artifactsLabs [ i ] then
18342: LD_VAR 0 5
18346: NOT
18347: PUSH
18348: LD_VAR 0 5
18352: PUSH
18353: LD_EXP 69
18357: PUSH
18358: LD_VAR 0 1
18362: ARRAY
18363: NONEQUAL
18364: OR
18365: IFFALSE 18470
// begin SetArtifactUse ( 7 , artifactsButtons [ i ] [ 3 ] , art_no , artifactsLabs [ i ] ) ;
18367: LD_INT 7
18369: PPUSH
18370: LD_EXP 70
18374: PUSH
18375: LD_VAR 0 1
18379: ARRAY
18380: PUSH
18381: LD_INT 3
18383: ARRAY
18384: PPUSH
18385: LD_INT 0
18387: PPUSH
18388: LD_EXP 69
18392: PUSH
18393: LD_VAR 0 1
18397: ARRAY
18398: PPUSH
18399: CALL_OW 468
// SetArtifactUse ( 7 , artifactsButtons [ i ] [ 1 ] , art_no , artifactsLabs [ i ] ) ;
18403: LD_INT 7
18405: PPUSH
18406: LD_EXP 70
18410: PUSH
18411: LD_VAR 0 1
18415: ARRAY
18416: PUSH
18417: LD_INT 1
18419: ARRAY
18420: PPUSH
18421: LD_INT 0
18423: PPUSH
18424: LD_EXP 69
18428: PUSH
18429: LD_VAR 0 1
18433: ARRAY
18434: PPUSH
18435: CALL_OW 468
// if nearestLab then
18439: LD_VAR 0 5
18443: IFFALSE 18470
// artifactsLabs := Replace ( artifactsLabs , i , nearestLab ) ;
18445: LD_ADDR_EXP 69
18449: PUSH
18450: LD_EXP 69
18454: PPUSH
18455: LD_VAR 0 1
18459: PPUSH
18460: LD_VAR 0 5
18464: PPUSH
18465: CALL_OW 1
18469: ST_TO_ADDR
// end ; if not nearestLab then
18470: LD_VAR 0 5
18474: NOT
18475: IFFALSE 18479
// continue ;
18477: GO 18037
// if GetDistUnitXY ( nearestLab , artifactsPos [ i ] [ 1 ] , artifactsPos [ i ] [ 2 ] ) < 8 then
18479: LD_VAR 0 5
18483: PPUSH
18484: LD_EXP 62
18488: PUSH
18489: LD_VAR 0 1
18493: ARRAY
18494: PUSH
18495: LD_INT 1
18497: ARRAY
18498: PPUSH
18499: LD_EXP 62
18503: PUSH
18504: LD_VAR 0 1
18508: ARRAY
18509: PUSH
18510: LD_INT 2
18512: ARRAY
18513: PPUSH
18514: CALL_OW 297
18518: PUSH
18519: LD_INT 8
18521: LESS
18522: IFFALSE 18719
// begin if not artifactsResearched [ i ] then
18524: LD_EXP 65
18528: PUSH
18529: LD_VAR 0 1
18533: ARRAY
18534: NOT
18535: IFFALSE 18616
// begin if BuildingStatus ( nearestLab ) = bs_idle then
18537: LD_VAR 0 5
18541: PPUSH
18542: CALL_OW 461
18546: PUSH
18547: LD_INT 2
18549: EQUAL
18550: IFFALSE 18584
// SetArtifactUse ( 7 , artifactsButtons [ i ] [ 3 ] , art_instant , nearestLab ) else
18552: LD_INT 7
18554: PPUSH
18555: LD_EXP 70
18559: PUSH
18560: LD_VAR 0 1
18564: ARRAY
18565: PUSH
18566: LD_INT 3
18568: ARRAY
18569: PPUSH
18570: LD_INT 2
18572: PPUSH
18573: LD_VAR 0 5
18577: PPUSH
18578: CALL_OW 468
18582: GO 18614
// SetArtifactUse ( 7 , artifactsButtons [ i ] [ 3 ] , art_gray , nearestLab ) ;
18584: LD_INT 7
18586: PPUSH
18587: LD_EXP 70
18591: PUSH
18592: LD_VAR 0 1
18596: ARRAY
18597: PUSH
18598: LD_INT 3
18600: ARRAY
18601: PPUSH
18602: LD_INT 1
18604: PPUSH
18605: LD_VAR 0 5
18609: PPUSH
18610: CALL_OW 468
// end else
18614: GO 18717
// begin if BuildingStatus ( nearestLab ) = bs_idle and artifactsReady [ i ] then
18616: LD_VAR 0 5
18620: PPUSH
18621: CALL_OW 461
18625: PUSH
18626: LD_INT 2
18628: EQUAL
18629: PUSH
18630: LD_EXP 71
18634: PUSH
18635: LD_VAR 0 1
18639: ARRAY
18640: AND
18641: IFFALSE 18687
// SetArtifactUse ( 7 , artifactsButtons [ i ] [ 1 ] , artifactsButtons [ i ] [ 2 ] , nearestLab ) else
18643: LD_INT 7
18645: PPUSH
18646: LD_EXP 70
18650: PUSH
18651: LD_VAR 0 1
18655: ARRAY
18656: PUSH
18657: LD_INT 1
18659: ARRAY
18660: PPUSH
18661: LD_EXP 70
18665: PUSH
18666: LD_VAR 0 1
18670: ARRAY
18671: PUSH
18672: LD_INT 2
18674: ARRAY
18675: PPUSH
18676: LD_VAR 0 5
18680: PPUSH
18681: CALL_OW 468
18685: GO 18717
// SetArtifactUse ( 7 , artifactsButtons [ i ] [ 1 ] , art_gray , nearestLab ) end ;
18687: LD_INT 7
18689: PPUSH
18690: LD_EXP 70
18694: PUSH
18695: LD_VAR 0 1
18699: ARRAY
18700: PUSH
18701: LD_INT 1
18703: ARRAY
18704: PPUSH
18705: LD_INT 1
18707: PPUSH
18708: LD_VAR 0 5
18712: PPUSH
18713: CALL_OW 468
// end else
18717: GO 18794
// begin if not artifactsResearched [ i ] then
18719: LD_EXP 65
18723: PUSH
18724: LD_VAR 0 1
18728: ARRAY
18729: NOT
18730: IFFALSE 18764
// SetArtifactUse ( 7 , artifactsButtons [ i ] [ 3 ] , art_no , nearestLab ) else
18732: LD_INT 7
18734: PPUSH
18735: LD_EXP 70
18739: PUSH
18740: LD_VAR 0 1
18744: ARRAY
18745: PUSH
18746: LD_INT 3
18748: ARRAY
18749: PPUSH
18750: LD_INT 0
18752: PPUSH
18753: LD_VAR 0 5
18757: PPUSH
18758: CALL_OW 468
18762: GO 18794
// SetArtifactUse ( 7 , artifactsButtons [ i ] [ 1 ] , art_no , nearestLab ) ;
18764: LD_INT 7
18766: PPUSH
18767: LD_EXP 70
18771: PUSH
18772: LD_VAR 0 1
18776: ARRAY
18777: PUSH
18778: LD_INT 1
18780: ARRAY
18781: PPUSH
18782: LD_INT 0
18784: PPUSH
18785: LD_VAR 0 5
18789: PPUSH
18790: CALL_OW 468
// end ; end else
18794: GO 18933
// begin if not artifactsLabs [ i ] then
18796: LD_EXP 69
18800: PUSH
18801: LD_VAR 0 1
18805: ARRAY
18806: NOT
18807: IFFALSE 18811
// continue ;
18809: GO 18037
// SetArtifactUse ( 7 , artifactsButtons [ i ] [ 3 ] , art_no , artifactsLabs [ i ] ) ;
18811: LD_INT 7
18813: PPUSH
18814: LD_EXP 70
18818: PUSH
18819: LD_VAR 0 1
18823: ARRAY
18824: PUSH
18825: LD_INT 3
18827: ARRAY
18828: PPUSH
18829: LD_INT 0
18831: PPUSH
18832: LD_EXP 69
18836: PUSH
18837: LD_VAR 0 1
18841: ARRAY
18842: PPUSH
18843: CALL_OW 468
// SetArtifactUse ( 7 , artifactsButtons [ i ] [ 1 ] , art_no , artifactsLabs [ i ] ) ;
18847: LD_INT 7
18849: PPUSH
18850: LD_EXP 70
18854: PUSH
18855: LD_VAR 0 1
18859: ARRAY
18860: PUSH
18861: LD_INT 1
18863: ARRAY
18864: PPUSH
18865: LD_INT 0
18867: PPUSH
18868: LD_EXP 69
18872: PUSH
18873: LD_VAR 0 1
18877: ARRAY
18878: PPUSH
18879: CALL_OW 468
// if artifactsLabsWorking [ i ] then
18883: LD_EXP 66
18887: PUSH
18888: LD_VAR 0 1
18892: ARRAY
18893: IFFALSE 18933
// begin artifactsLabsWorking := Replace ( artifactsLabsWorking , i , false ) ;
18895: LD_ADDR_EXP 66
18899: PUSH
18900: LD_EXP 66
18904: PPUSH
18905: LD_VAR 0 1
18909: PPUSH
18910: LD_INT 0
18912: PPUSH
18913: CALL_OW 1
18917: ST_TO_ADDR
// ComCancel ( artifactsLabs [ i ] ) ;
18918: LD_EXP 69
18922: PUSH
18923: LD_VAR 0 1
18927: ARRAY
18928: PPUSH
18929: CALL_OW 127
// end ; end ; end ;
18933: GO 18037
18935: POP
18936: POP
// end ;
18937: PPOPN 5
18939: END
// on ArtifactUsed ( side , icon , x , y ) do var i , lab , time , list , un ;
18940: LD_INT 0
18942: PPUSH
18943: PPUSH
18944: PPUSH
18945: PPUSH
18946: PPUSH
// begin if icon = artifactsButtons [ 1 ] [ 3 ] then
18947: LD_VAR 0 2
18951: PUSH
18952: LD_EXP 70
18956: PUSH
18957: LD_INT 1
18959: ARRAY
18960: PUSH
18961: LD_INT 3
18963: ARRAY
18964: EQUAL
18965: IFFALSE 19088
// begin lab := artifactsLabs [ 1 ] ;
18967: LD_ADDR_VAR 0 6
18971: PUSH
18972: LD_EXP 69
18976: PUSH
18977: LD_INT 1
18979: ARRAY
18980: ST_TO_ADDR
// if not lab then
18981: LD_VAR 0 6
18985: NOT
18986: IFFALSE 18990
// exit ;
18988: GO 20068
// SetSpecResearch ( lab , artifactsResDifficulty [ 1 ] , true ) ;
18990: LD_VAR 0 6
18994: PPUSH
18995: LD_EXP 67
18999: PUSH
19000: LD_INT 1
19002: ARRAY
19003: PPUSH
19004: LD_INT 1
19006: PPUSH
19007: CALL_OW 486
// if artifactsResProgress [ 1 ] then
19011: LD_EXP 68
19015: PUSH
19016: LD_INT 1
19018: ARRAY
19019: IFFALSE 19039
// SetWorkingProgress ( lab , artifactsResProgress [ 1 ] ) ;
19021: LD_VAR 0 6
19025: PPUSH
19026: LD_EXP 68
19030: PUSH
19031: LD_INT 1
19033: ARRAY
19034: PPUSH
19035: CALL_OW 329
// artifactsLabsWorking := Replace ( artifactsLabsWorking , 1 , 1 ) ;
19039: LD_ADDR_EXP 66
19043: PUSH
19044: LD_EXP 66
19048: PPUSH
19049: LD_INT 1
19051: PPUSH
19052: LD_INT 1
19054: PPUSH
19055: CALL_OW 1
19059: ST_TO_ADDR
// SetArtifactUse ( 7 , artifactsButtons [ 1 ] [ 3 ] , art_no , lab ) ;
19060: LD_INT 7
19062: PPUSH
19063: LD_EXP 70
19067: PUSH
19068: LD_INT 1
19070: ARRAY
19071: PUSH
19072: LD_INT 3
19074: ARRAY
19075: PPUSH
19076: LD_INT 0
19078: PPUSH
19079: LD_VAR 0 6
19083: PPUSH
19084: CALL_OW 468
// end ; if icon = artifactsButtons [ 2 ] [ 3 ] then
19088: LD_VAR 0 2
19092: PUSH
19093: LD_EXP 70
19097: PUSH
19098: LD_INT 2
19100: ARRAY
19101: PUSH
19102: LD_INT 3
19104: ARRAY
19105: EQUAL
19106: IFFALSE 19229
// begin lab := artifactsLabs [ 2 ] ;
19108: LD_ADDR_VAR 0 6
19112: PUSH
19113: LD_EXP 69
19117: PUSH
19118: LD_INT 2
19120: ARRAY
19121: ST_TO_ADDR
// if not lab then
19122: LD_VAR 0 6
19126: NOT
19127: IFFALSE 19131
// exit ;
19129: GO 20068
// SetSpecResearch ( lab , artifactsResDifficulty [ 2 ] , true ) ;
19131: LD_VAR 0 6
19135: PPUSH
19136: LD_EXP 67
19140: PUSH
19141: LD_INT 2
19143: ARRAY
19144: PPUSH
19145: LD_INT 1
19147: PPUSH
19148: CALL_OW 486
// if artifactsResProgress [ 2 ] then
19152: LD_EXP 68
19156: PUSH
19157: LD_INT 2
19159: ARRAY
19160: IFFALSE 19180
// SetWorkingProgress ( lab , artifactsResProgress [ 2 ] ) ;
19162: LD_VAR 0 6
19166: PPUSH
19167: LD_EXP 68
19171: PUSH
19172: LD_INT 2
19174: ARRAY
19175: PPUSH
19176: CALL_OW 329
// artifactsLabsWorking := Replace ( artifactsLabsWorking , 2 , 1 ) ;
19180: LD_ADDR_EXP 66
19184: PUSH
19185: LD_EXP 66
19189: PPUSH
19190: LD_INT 2
19192: PPUSH
19193: LD_INT 1
19195: PPUSH
19196: CALL_OW 1
19200: ST_TO_ADDR
// SetArtifactUse ( 7 , artifactsButtons [ 2 ] [ 3 ] , art_no , lab ) ;
19201: LD_INT 7
19203: PPUSH
19204: LD_EXP 70
19208: PUSH
19209: LD_INT 2
19211: ARRAY
19212: PUSH
19213: LD_INT 3
19215: ARRAY
19216: PPUSH
19217: LD_INT 0
19219: PPUSH
19220: LD_VAR 0 6
19224: PPUSH
19225: CALL_OW 468
// end ; if icon = artifactsButtons [ 3 ] [ 3 ] then
19229: LD_VAR 0 2
19233: PUSH
19234: LD_EXP 70
19238: PUSH
19239: LD_INT 3
19241: ARRAY
19242: PUSH
19243: LD_INT 3
19245: ARRAY
19246: EQUAL
19247: IFFALSE 19370
// begin lab := artifactsLabs [ 3 ] ;
19249: LD_ADDR_VAR 0 6
19253: PUSH
19254: LD_EXP 69
19258: PUSH
19259: LD_INT 3
19261: ARRAY
19262: ST_TO_ADDR
// if not lab then
19263: LD_VAR 0 6
19267: NOT
19268: IFFALSE 19272
// exit ;
19270: GO 20068
// SetSpecResearch ( lab , artifactsResDifficulty [ 3 ] , true ) ;
19272: LD_VAR 0 6
19276: PPUSH
19277: LD_EXP 67
19281: PUSH
19282: LD_INT 3
19284: ARRAY
19285: PPUSH
19286: LD_INT 1
19288: PPUSH
19289: CALL_OW 486
// if artifactsResProgress [ 3 ] then
19293: LD_EXP 68
19297: PUSH
19298: LD_INT 3
19300: ARRAY
19301: IFFALSE 19321
// SetWorkingProgress ( lab , artifactsResProgress [ 3 ] ) ;
19303: LD_VAR 0 6
19307: PPUSH
19308: LD_EXP 68
19312: PUSH
19313: LD_INT 3
19315: ARRAY
19316: PPUSH
19317: CALL_OW 329
// artifactsLabsWorking := Replace ( artifactsLabsWorking , 3 , 1 ) ;
19321: LD_ADDR_EXP 66
19325: PUSH
19326: LD_EXP 66
19330: PPUSH
19331: LD_INT 3
19333: PPUSH
19334: LD_INT 1
19336: PPUSH
19337: CALL_OW 1
19341: ST_TO_ADDR
// SetArtifactUse ( 7 , artifactsButtons [ 3 ] [ 3 ] , art_no , lab ) ;
19342: LD_INT 7
19344: PPUSH
19345: LD_EXP 70
19349: PUSH
19350: LD_INT 3
19352: ARRAY
19353: PUSH
19354: LD_INT 3
19356: ARRAY
19357: PPUSH
19358: LD_INT 0
19360: PPUSH
19361: LD_VAR 0 6
19365: PPUSH
19366: CALL_OW 468
// end ; if icon = artifactsButtons [ 1 ] [ 1 ] then
19370: LD_VAR 0 2
19374: PUSH
19375: LD_EXP 70
19379: PUSH
19380: LD_INT 1
19382: ARRAY
19383: PUSH
19384: LD_INT 1
19386: ARRAY
19387: EQUAL
19388: IFFALSE 19546
// begin lab := artifactsLabs [ 1 ] ;
19390: LD_ADDR_VAR 0 6
19394: PUSH
19395: LD_EXP 69
19399: PUSH
19400: LD_INT 1
19402: ARRAY
19403: ST_TO_ADDR
// if GetBaseMaterials ( GetBase ( lab ) ) [ 3 ] < artifactsSibCost [ 1 ] then
19404: LD_VAR 0 6
19408: PPUSH
19409: CALL_OW 274
19413: PPUSH
19414: CALL 93633 0 1
19418: PUSH
19419: LD_INT 3
19421: ARRAY
19422: PUSH
19423: LD_EXP 64
19427: PUSH
19428: LD_INT 1
19430: ARRAY
19431: LESS
19432: IFFALSE 19446
// begin HintSpec ( ArtifactCost , 2 ) ;
19434: LD_STRING ArtifactCost
19436: PPUSH
19437: LD_INT 2
19439: PPUSH
19440: CALL_OW 338
// exit ;
19444: GO 20068
// end ; artifactsReady := Replace ( artifactsReady , 1 , false ) ;
19446: LD_ADDR_EXP 71
19450: PUSH
19451: LD_EXP 71
19455: PPUSH
19456: LD_INT 1
19458: PPUSH
19459: LD_INT 0
19461: PPUSH
19462: CALL_OW 1
19466: ST_TO_ADDR
// PlaceSeeing ( x , y , 7 , - 12 ) ;
19467: LD_VAR 0 3
19471: PPUSH
19472: LD_VAR 0 4
19476: PPUSH
19477: LD_INT 7
19479: PPUSH
19480: LD_INT 12
19482: NEG
19483: PPUSH
19484: CALL_OW 330
// wait ( 0 0$30 ) ;
19488: LD_INT 1050
19490: PPUSH
19491: CALL_OW 67
// RemoveSeeing ( x , y , 7 ) ;
19495: LD_VAR 0 3
19499: PPUSH
19500: LD_VAR 0 4
19504: PPUSH
19505: LD_INT 7
19507: PPUSH
19508: CALL_OW 331
// wait ( artifactsRecharge [ 1 ] ) ;
19512: LD_EXP 63
19516: PUSH
19517: LD_INT 1
19519: ARRAY
19520: PPUSH
19521: CALL_OW 67
// artifactsReady := Replace ( artifactsReady , 1 , true ) ;
19525: LD_ADDR_EXP 71
19529: PUSH
19530: LD_EXP 71
19534: PPUSH
19535: LD_INT 1
19537: PPUSH
19538: LD_INT 1
19540: PPUSH
19541: CALL_OW 1
19545: ST_TO_ADDR
// end ; if icon = artifactsButtons [ 2 ] [ 1 ] then
19546: LD_VAR 0 2
19550: PUSH
19551: LD_EXP 70
19555: PUSH
19556: LD_INT 2
19558: ARRAY
19559: PUSH
19560: LD_INT 1
19562: ARRAY
19563: EQUAL
19564: IFFALSE 19801
// begin lab := artifactsLabs [ 2 ] ;
19566: LD_ADDR_VAR 0 6
19570: PUSH
19571: LD_EXP 69
19575: PUSH
19576: LD_INT 2
19578: ARRAY
19579: ST_TO_ADDR
// if not x in FilterAllUnits ( [ [ f_enemy , 7 ] , [ f_or , [ f_engine , engine_siberite ] , [ f_btype , b_siberite_power ] , [ f_btype , b_siberite_mine ] , [ f_bweapon , ru_time_lapser ] , [ f_weapon , ru_time_lapser ] , [ f_btype , b_ext_siberium ] ] ] ) then
19580: LD_VAR 0 3
19584: PUSH
19585: LD_INT 81
19587: PUSH
19588: LD_INT 7
19590: PUSH
19591: EMPTY
19592: LIST
19593: LIST
19594: PUSH
19595: LD_INT 2
19597: PUSH
19598: LD_INT 32
19600: PUSH
19601: LD_INT 3
19603: PUSH
19604: EMPTY
19605: LIST
19606: LIST
19607: PUSH
19608: LD_INT 30
19610: PUSH
19611: LD_INT 28
19613: PUSH
19614: EMPTY
19615: LIST
19616: LIST
19617: PUSH
19618: LD_INT 30
19620: PUSH
19621: LD_INT 30
19623: PUSH
19624: EMPTY
19625: LIST
19626: LIST
19627: PUSH
19628: LD_INT 35
19630: PUSH
19631: LD_INT 49
19633: PUSH
19634: EMPTY
19635: LIST
19636: LIST
19637: PUSH
19638: LD_INT 34
19640: PUSH
19641: LD_INT 49
19643: PUSH
19644: EMPTY
19645: LIST
19646: LIST
19647: PUSH
19648: LD_INT 30
19650: PUSH
19651: LD_INT 21
19653: PUSH
19654: EMPTY
19655: LIST
19656: LIST
19657: PUSH
19658: EMPTY
19659: LIST
19660: LIST
19661: LIST
19662: LIST
19663: LIST
19664: LIST
19665: LIST
19666: PUSH
19667: EMPTY
19668: LIST
19669: LIST
19670: PPUSH
19671: CALL_OW 69
19675: IN
19676: NOT
19677: IFFALSE 19681
// exit ;
19679: GO 20068
// if GetBaseMaterials ( GetBase ( lab ) ) [ 3 ] < artifactsSibCost [ 2 ] then
19681: LD_VAR 0 6
19685: PPUSH
19686: CALL_OW 274
19690: PPUSH
19691: CALL 93633 0 1
19695: PUSH
19696: LD_INT 3
19698: ARRAY
19699: PUSH
19700: LD_EXP 64
19704: PUSH
19705: LD_INT 2
19707: ARRAY
19708: LESS
19709: IFFALSE 19723
// begin HintSpec ( ArtifactCost , 2 ) ;
19711: LD_STRING ArtifactCost
19713: PPUSH
19714: LD_INT 2
19716: PPUSH
19717: CALL_OW 338
// exit ;
19721: GO 20068
// end ; artifactsReady := Replace ( artifactsReady , 2 , false ) ;
19723: LD_ADDR_EXP 71
19727: PUSH
19728: LD_EXP 71
19732: PPUSH
19733: LD_INT 2
19735: PPUSH
19736: LD_INT 0
19738: PPUSH
19739: CALL_OW 1
19743: ST_TO_ADDR
// KillUnit ( x ) ;
19744: LD_VAR 0 3
19748: PPUSH
19749: CALL_OW 66
// artifactDestroyCounter := artifactDestroyCounter + 1 ;
19753: LD_ADDR_EXP 16
19757: PUSH
19758: LD_EXP 16
19762: PUSH
19763: LD_INT 1
19765: PLUS
19766: ST_TO_ADDR
// wait ( artifactsRecharge [ 2 ] ) ;
19767: LD_EXP 63
19771: PUSH
19772: LD_INT 2
19774: ARRAY
19775: PPUSH
19776: CALL_OW 67
// artifactsReady := Replace ( artifactsReady , 2 , true ) ;
19780: LD_ADDR_EXP 71
19784: PUSH
19785: LD_EXP 71
19789: PPUSH
19790: LD_INT 2
19792: PPUSH
19793: LD_INT 1
19795: PPUSH
19796: CALL_OW 1
19800: ST_TO_ADDR
// end ; if icon = artifactsButtons [ 3 ] [ 1 ] then
19801: LD_VAR 0 2
19805: PUSH
19806: LD_EXP 70
19810: PUSH
19811: LD_INT 3
19813: ARRAY
19814: PUSH
19815: LD_INT 1
19817: ARRAY
19818: EQUAL
19819: IFFALSE 20068
// begin lab := artifactsLabs [ 3 ] ;
19821: LD_ADDR_VAR 0 6
19825: PUSH
19826: LD_EXP 69
19830: PUSH
19831: LD_INT 3
19833: ARRAY
19834: ST_TO_ADDR
// if GetBaseMaterials ( GetBase ( lab ) ) [ 3 ] < artifactsSibCost [ 3 ] then
19835: LD_VAR 0 6
19839: PPUSH
19840: CALL_OW 274
19844: PPUSH
19845: CALL 93633 0 1
19849: PUSH
19850: LD_INT 3
19852: ARRAY
19853: PUSH
19854: LD_EXP 64
19858: PUSH
19859: LD_INT 3
19861: ARRAY
19862: LESS
19863: IFFALSE 19877
// begin HintSpec ( ArtifactCost , 2 ) ;
19865: LD_STRING ArtifactCost
19867: PPUSH
19868: LD_INT 2
19870: PPUSH
19871: CALL_OW 338
// exit ;
19875: GO 20068
// end ; SetAreaMapShow ( teleportArea , 1 ) ;
19877: LD_INT 37
19879: PPUSH
19880: LD_INT 1
19882: PPUSH
19883: CALL_OW 424
// time := 0 0$30 ;
19887: LD_ADDR_VAR 0 7
19891: PUSH
19892: LD_INT 1050
19894: ST_TO_ADDR
// artifactsReady := Replace ( artifactsReady , 3 , false ) ;
19895: LD_ADDR_EXP 71
19899: PUSH
19900: LD_EXP 71
19904: PPUSH
19905: LD_INT 3
19907: PPUSH
19908: LD_INT 0
19910: PPUSH
19911: CALL_OW 1
19915: ST_TO_ADDR
// repeat display_strings := [ #Am15a-1 , time ] ;
19916: LD_ADDR_OWVAR 47
19920: PUSH
19921: LD_STRING #Am15a-1
19923: PUSH
19924: LD_VAR 0 7
19928: PUSH
19929: EMPTY
19930: LIST
19931: LIST
19932: ST_TO_ADDR
// wait ( 0 0$1 ) ;
19933: LD_INT 35
19935: PPUSH
19936: CALL_OW 67
// time := time - 0 0$1 ;
19940: LD_ADDR_VAR 0 7
19944: PUSH
19945: LD_VAR 0 7
19949: PUSH
19950: LD_INT 35
19952: MINUS
19953: ST_TO_ADDR
// until time = 0 0$00 ;
19954: LD_VAR 0 7
19958: PUSH
19959: LD_INT 0
19961: EQUAL
19962: IFFALSE 19916
// display_strings :=  ;
19964: LD_ADDR_OWVAR 47
19968: PUSH
19969: LD_STRING 
19971: ST_TO_ADDR
// SetAreaMapShow ( teleportArea , 0 ) ;
19972: LD_INT 37
19974: PPUSH
19975: LD_INT 0
19977: PPUSH
19978: CALL_OW 424
// list := FilterUnitsInArea ( teleportArea , [ f_not , [ f_type , unit_building ] ] ) ;
19982: LD_ADDR_VAR 0 8
19986: PUSH
19987: LD_INT 37
19989: PPUSH
19990: LD_INT 3
19992: PUSH
19993: LD_INT 21
19995: PUSH
19996: LD_INT 3
19998: PUSH
19999: EMPTY
20000: LIST
20001: LIST
20002: PUSH
20003: EMPTY
20004: LIST
20005: LIST
20006: PPUSH
20007: CALL_OW 70
20011: ST_TO_ADDR
// CenterOnXY ( x , y ) ;
20012: LD_VAR 0 3
20016: PPUSH
20017: LD_VAR 0 4
20021: PPUSH
20022: CALL_OW 84
// for un in list do
20026: LD_ADDR_VAR 0 9
20030: PUSH
20031: LD_VAR 0 8
20035: PUSH
20036: FOR_IN
20037: IFFALSE 20066
// TeleportUnit ( un , x , y , 12 , true ) ;
20039: LD_VAR 0 9
20043: PPUSH
20044: LD_VAR 0 3
20048: PPUSH
20049: LD_VAR 0 4
20053: PPUSH
20054: LD_INT 12
20056: PPUSH
20057: LD_INT 1
20059: PPUSH
20060: CALL_OW 483
20064: GO 20036
20066: POP
20067: POP
// end ; end ;
20068: PPOPN 9
20070: END
// on SpecResearchCancel ( lab , progress ) do var i , labNum ;
20071: LD_INT 0
20073: PPUSH
20074: PPUSH
// begin labNum := 0 ;
20075: LD_ADDR_VAR 0 4
20079: PUSH
20080: LD_INT 0
20082: ST_TO_ADDR
// for i = 1 to artifactsLabs do
20083: LD_ADDR_VAR 0 3
20087: PUSH
20088: DOUBLE
20089: LD_INT 1
20091: DEC
20092: ST_TO_ADDR
20093: LD_EXP 69
20097: PUSH
20098: FOR_TO
20099: IFFALSE 20133
// if artifactsLabs [ i ] = lab then
20101: LD_EXP 69
20105: PUSH
20106: LD_VAR 0 3
20110: ARRAY
20111: PUSH
20112: LD_VAR 0 1
20116: EQUAL
20117: IFFALSE 20131
// begin labNum := i ;
20119: LD_ADDR_VAR 0 4
20123: PUSH
20124: LD_VAR 0 3
20128: ST_TO_ADDR
// break ;
20129: GO 20133
// end ;
20131: GO 20098
20133: POP
20134: POP
// if not labNum then
20135: LD_VAR 0 4
20139: NOT
20140: IFFALSE 20144
// exit ;
20142: GO 20222
// SetArtifactUse ( 7 , artifactsButtons [ labNum ] [ 3 ] , art_instant , lab ) ;
20144: LD_INT 7
20146: PPUSH
20147: LD_EXP 70
20151: PUSH
20152: LD_VAR 0 4
20156: ARRAY
20157: PUSH
20158: LD_INT 3
20160: ARRAY
20161: PPUSH
20162: LD_INT 2
20164: PPUSH
20165: LD_VAR 0 1
20169: PPUSH
20170: CALL_OW 468
// artifactsResProgress := Replace ( artifactsResProgress , labNum , progress ) ;
20174: LD_ADDR_EXP 68
20178: PUSH
20179: LD_EXP 68
20183: PPUSH
20184: LD_VAR 0 4
20188: PPUSH
20189: LD_VAR 0 2
20193: PPUSH
20194: CALL_OW 1
20198: ST_TO_ADDR
// artifactsLabsWorking := Replace ( artifactsLabsWorking , labNum , 0 ) ;
20199: LD_ADDR_EXP 66
20203: PUSH
20204: LD_EXP 66
20208: PPUSH
20209: LD_VAR 0 4
20213: PPUSH
20214: LD_INT 0
20216: PPUSH
20217: CALL_OW 1
20221: ST_TO_ADDR
// end ;
20222: PPOPN 4
20224: END
// on SpecResearchComplete ( lab ) do var i , labNum ;
20225: LD_INT 0
20227: PPUSH
20228: PPUSH
// begin labNum := 0 ;
20229: LD_ADDR_VAR 0 3
20233: PUSH
20234: LD_INT 0
20236: ST_TO_ADDR
// for i = 1 to artifactsLabs do
20237: LD_ADDR_VAR 0 2
20241: PUSH
20242: DOUBLE
20243: LD_INT 1
20245: DEC
20246: ST_TO_ADDR
20247: LD_EXP 69
20251: PUSH
20252: FOR_TO
20253: IFFALSE 20287
// if artifactsLabs [ i ] = lab then
20255: LD_EXP 69
20259: PUSH
20260: LD_VAR 0 2
20264: ARRAY
20265: PUSH
20266: LD_VAR 0 1
20270: EQUAL
20271: IFFALSE 20285
// begin labNum := i ;
20273: LD_ADDR_VAR 0 3
20277: PUSH
20278: LD_VAR 0 2
20282: ST_TO_ADDR
// break ;
20283: GO 20287
// end ;
20285: GO 20252
20287: POP
20288: POP
// if not labNum then
20289: LD_VAR 0 3
20293: NOT
20294: IFFALSE 20298
// exit ;
20296: GO 20460
// SetArtifactUse ( 7 , artifactsButtons [ labNum ] [ 3 ] , art_no , lab ) ;
20298: LD_INT 7
20300: PPUSH
20301: LD_EXP 70
20305: PUSH
20306: LD_VAR 0 3
20310: ARRAY
20311: PUSH
20312: LD_INT 3
20314: ARRAY
20315: PPUSH
20316: LD_INT 0
20318: PPUSH
20319: LD_VAR 0 1
20323: PPUSH
20324: CALL_OW 468
// artifactsResearched := Replace ( artifactsResearched , labNum , true ) ;
20328: LD_ADDR_EXP 65
20332: PUSH
20333: LD_EXP 65
20337: PPUSH
20338: LD_VAR 0 3
20342: PPUSH
20343: LD_INT 1
20345: PPUSH
20346: CALL_OW 1
20350: ST_TO_ADDR
// artifactsReady := Replace ( artifactsReady , labNum , true ) ;
20351: LD_ADDR_EXP 71
20355: PUSH
20356: LD_EXP 71
20360: PPUSH
20361: LD_VAR 0 3
20365: PPUSH
20366: LD_INT 1
20368: PPUSH
20369: CALL_OW 1
20373: ST_TO_ADDR
// artifactsLabsWorking := Replace ( artifactsLabsWorking , labNum , false ) ;
20374: LD_ADDR_EXP 66
20378: PUSH
20379: LD_EXP 66
20383: PPUSH
20384: LD_VAR 0 3
20388: PPUSH
20389: LD_INT 0
20391: PPUSH
20392: CALL_OW 1
20396: ST_TO_ADDR
// case labNum of 1 :
20397: LD_VAR 0 3
20401: PUSH
20402: LD_INT 1
20404: DOUBLE
20405: EQUAL
20406: IFTRUE 20410
20408: GO 20421
20410: POP
// artifactIResearched := true ; 2 :
20411: LD_ADDR_EXP 12
20415: PUSH
20416: LD_INT 1
20418: ST_TO_ADDR
20419: GO 20460
20421: LD_INT 2
20423: DOUBLE
20424: EQUAL
20425: IFTRUE 20429
20427: GO 20440
20429: POP
// artifactIIResearched := true ; 3 :
20430: LD_ADDR_EXP 13
20434: PUSH
20435: LD_INT 1
20437: ST_TO_ADDR
20438: GO 20460
20440: LD_INT 3
20442: DOUBLE
20443: EQUAL
20444: IFTRUE 20448
20446: GO 20459
20448: POP
// artifactIIIResearched := true ; end ;
20449: LD_ADDR_EXP 14
20453: PUSH
20454: LD_INT 1
20456: ST_TO_ADDR
20457: GO 20460
20459: POP
// end ; end_of_file
20460: PPOPN 3
20462: END
// export ru_radar , ru_big_cargo_bay , us_hack , us_artillery , ar_bio_bomb ; every 1 do
20463: GO 20465
20465: DISABLE
// begin ru_radar := 98 ;
20466: LD_ADDR_EXP 72
20470: PUSH
20471: LD_INT 98
20473: ST_TO_ADDR
// ru_big_cargo_bay := 89 ;
20474: LD_ADDR_EXP 73
20478: PUSH
20479: LD_INT 89
20481: ST_TO_ADDR
// us_hack := 99 ;
20482: LD_ADDR_EXP 74
20486: PUSH
20487: LD_INT 99
20489: ST_TO_ADDR
// us_artillery := 97 ;
20490: LD_ADDR_EXP 75
20494: PUSH
20495: LD_INT 97
20497: ST_TO_ADDR
// ar_bio_bomb := 91 ;
20498: LD_ADDR_EXP 76
20502: PUSH
20503: LD_INT 91
20505: ST_TO_ADDR
// end ; end_of_file
20506: END
// export skirmish , debug_mc ; export mc_bases , mc_building_need_repair , mc_building_repairs , mc_need_heal , mc_healers , mc_build_list , mc_builders , mc_construct_list , mc_turret_list , mc_empty_turret_list , mc_busy_turret_list , mc_defender_limit , mc_repair_vehicle , mc_mines , mc_miners , mc_minefields , mc_crates , mc_crates_collector , mc_crates_area , mc_vehicles , mc_attack , mc_produce , mc_defender , mc_scan , mc_parking , mc_scan_area , mc_sides , mc_tech , mc_can_tame , mc_ape , mc_ape_in_lab , mc_taming , mc_build_upgrade , mc_lab , mc_lab_upgrade , mc_teleport_exit , mc_teleport_exit_set , mc_deposits_xy , mc_deposits_finder , mc_allowed_tower_weapons , mc_remote_driver , mc_class , mc_class_case_use ; export function InitMacro ; var i ; begin
20507: LD_INT 0
20509: PPUSH
20510: PPUSH
// skirmish := false ;
20511: LD_ADDR_EXP 77
20515: PUSH
20516: LD_INT 0
20518: ST_TO_ADDR
// debug_mc := false ;
20519: LD_ADDR_EXP 78
20523: PUSH
20524: LD_INT 0
20526: ST_TO_ADDR
// mc_bases := [ ] ;
20527: LD_ADDR_EXP 79
20531: PUSH
20532: EMPTY
20533: ST_TO_ADDR
// mc_sides := [ ] ;
20534: LD_ADDR_EXP 105
20538: PUSH
20539: EMPTY
20540: ST_TO_ADDR
// mc_building_need_repair := [ ] ;
20541: LD_ADDR_EXP 80
20545: PUSH
20546: EMPTY
20547: ST_TO_ADDR
// mc_building_repairs := [ ] ;
20548: LD_ADDR_EXP 81
20552: PUSH
20553: EMPTY
20554: ST_TO_ADDR
// mc_need_heal := [ ] ;
20555: LD_ADDR_EXP 82
20559: PUSH
20560: EMPTY
20561: ST_TO_ADDR
// mc_healers := [ ] ;
20562: LD_ADDR_EXP 83
20566: PUSH
20567: EMPTY
20568: ST_TO_ADDR
// mc_build_list := [ ] ;
20569: LD_ADDR_EXP 84
20573: PUSH
20574: EMPTY
20575: ST_TO_ADDR
// mc_build_upgrade := [ ] ;
20576: LD_ADDR_EXP 111
20580: PUSH
20581: EMPTY
20582: ST_TO_ADDR
// mc_builders := [ ] ;
20583: LD_ADDR_EXP 85
20587: PUSH
20588: EMPTY
20589: ST_TO_ADDR
// mc_construct_list := [ ] ;
20590: LD_ADDR_EXP 86
20594: PUSH
20595: EMPTY
20596: ST_TO_ADDR
// mc_turret_list := [ ] ;
20597: LD_ADDR_EXP 87
20601: PUSH
20602: EMPTY
20603: ST_TO_ADDR
// mc_empty_turret_list := [ ] ;
20604: LD_ADDR_EXP 88
20608: PUSH
20609: EMPTY
20610: ST_TO_ADDR
// mc_miners := [ ] ;
20611: LD_ADDR_EXP 93
20615: PUSH
20616: EMPTY
20617: ST_TO_ADDR
// mc_mines := [ ] ;
20618: LD_ADDR_EXP 92
20622: PUSH
20623: EMPTY
20624: ST_TO_ADDR
// mc_minefields := [ ] ;
20625: LD_ADDR_EXP 94
20629: PUSH
20630: EMPTY
20631: ST_TO_ADDR
// mc_crates := [ ] ;
20632: LD_ADDR_EXP 95
20636: PUSH
20637: EMPTY
20638: ST_TO_ADDR
// mc_crates_collector := [ ] ;
20639: LD_ADDR_EXP 96
20643: PUSH
20644: EMPTY
20645: ST_TO_ADDR
// mc_crates_area := [ ] ;
20646: LD_ADDR_EXP 97
20650: PUSH
20651: EMPTY
20652: ST_TO_ADDR
// mc_vehicles := [ ] ;
20653: LD_ADDR_EXP 98
20657: PUSH
20658: EMPTY
20659: ST_TO_ADDR
// mc_attack := [ ] ;
20660: LD_ADDR_EXP 99
20664: PUSH
20665: EMPTY
20666: ST_TO_ADDR
// mc_produce := [ ] ;
20667: LD_ADDR_EXP 100
20671: PUSH
20672: EMPTY
20673: ST_TO_ADDR
// mc_defender := [ ] ;
20674: LD_ADDR_EXP 101
20678: PUSH
20679: EMPTY
20680: ST_TO_ADDR
// mc_parking := [ ] ;
20681: LD_ADDR_EXP 103
20685: PUSH
20686: EMPTY
20687: ST_TO_ADDR
// mc_busy_turret_list := [ ] ;
20688: LD_ADDR_EXP 89
20692: PUSH
20693: EMPTY
20694: ST_TO_ADDR
// mc_repair_vehicle := [ ] ;
20695: LD_ADDR_EXP 91
20699: PUSH
20700: EMPTY
20701: ST_TO_ADDR
// mc_scan := [ ] ;
20702: LD_ADDR_EXP 102
20706: PUSH
20707: EMPTY
20708: ST_TO_ADDR
// mc_scan_area := [ ] ;
20709: LD_ADDR_EXP 104
20713: PUSH
20714: EMPTY
20715: ST_TO_ADDR
// mc_tech := [ ] ;
20716: LD_ADDR_EXP 106
20720: PUSH
20721: EMPTY
20722: ST_TO_ADDR
// mc_class := [ ] ;
20723: LD_ADDR_EXP 120
20727: PUSH
20728: EMPTY
20729: ST_TO_ADDR
// mc_class_case_use := [ ] ;
20730: LD_ADDR_EXP 121
20734: PUSH
20735: EMPTY
20736: ST_TO_ADDR
// end ;
20737: LD_VAR 0 1
20741: RET
// export function MC_Kill ( base ) ; begin
20742: LD_INT 0
20744: PPUSH
// mc_bases := Replace ( mc_bases , base , [ ] ) ;
20745: LD_ADDR_EXP 79
20749: PUSH
20750: LD_EXP 79
20754: PPUSH
20755: LD_VAR 0 1
20759: PPUSH
20760: EMPTY
20761: PPUSH
20762: CALL_OW 1
20766: ST_TO_ADDR
// mc_building_need_repair := Replace ( mc_building_need_repair , base , [ ] ) ;
20767: LD_ADDR_EXP 80
20771: PUSH
20772: LD_EXP 80
20776: PPUSH
20777: LD_VAR 0 1
20781: PPUSH
20782: EMPTY
20783: PPUSH
20784: CALL_OW 1
20788: ST_TO_ADDR
// mc_building_repairs := Replace ( mc_building_repairs , base , [ ] ) ;
20789: LD_ADDR_EXP 81
20793: PUSH
20794: LD_EXP 81
20798: PPUSH
20799: LD_VAR 0 1
20803: PPUSH
20804: EMPTY
20805: PPUSH
20806: CALL_OW 1
20810: ST_TO_ADDR
// mc_need_heal := Replace ( mc_need_heal , base , [ ] ) ;
20811: LD_ADDR_EXP 82
20815: PUSH
20816: LD_EXP 82
20820: PPUSH
20821: LD_VAR 0 1
20825: PPUSH
20826: EMPTY
20827: PPUSH
20828: CALL_OW 1
20832: ST_TO_ADDR
// mc_healers := Replace ( mc_healers , base , [ ] ) ;
20833: LD_ADDR_EXP 83
20837: PUSH
20838: LD_EXP 83
20842: PPUSH
20843: LD_VAR 0 1
20847: PPUSH
20848: EMPTY
20849: PPUSH
20850: CALL_OW 1
20854: ST_TO_ADDR
// mc_build_list := Replace ( mc_build_list , base , [ ] ) ;
20855: LD_ADDR_EXP 84
20859: PUSH
20860: LD_EXP 84
20864: PPUSH
20865: LD_VAR 0 1
20869: PPUSH
20870: EMPTY
20871: PPUSH
20872: CALL_OW 1
20876: ST_TO_ADDR
// mc_builders := Replace ( mc_builders , base , [ ] ) ;
20877: LD_ADDR_EXP 85
20881: PUSH
20882: LD_EXP 85
20886: PPUSH
20887: LD_VAR 0 1
20891: PPUSH
20892: EMPTY
20893: PPUSH
20894: CALL_OW 1
20898: ST_TO_ADDR
// mc_construct_list := Replace ( mc_construct_list , base , [ ] ) ;
20899: LD_ADDR_EXP 86
20903: PUSH
20904: LD_EXP 86
20908: PPUSH
20909: LD_VAR 0 1
20913: PPUSH
20914: EMPTY
20915: PPUSH
20916: CALL_OW 1
20920: ST_TO_ADDR
// mc_turret_list := Replace ( mc_turret_list , base , [ ] ) ;
20921: LD_ADDR_EXP 87
20925: PUSH
20926: LD_EXP 87
20930: PPUSH
20931: LD_VAR 0 1
20935: PPUSH
20936: EMPTY
20937: PPUSH
20938: CALL_OW 1
20942: ST_TO_ADDR
// mc_empty_turret_list := Replace ( mc_empty_turret_list , base , [ ] ) ;
20943: LD_ADDR_EXP 88
20947: PUSH
20948: LD_EXP 88
20952: PPUSH
20953: LD_VAR 0 1
20957: PPUSH
20958: EMPTY
20959: PPUSH
20960: CALL_OW 1
20964: ST_TO_ADDR
// mc_busy_turret_list := Replace ( mc_busy_turret_list , base , [ ] ) ;
20965: LD_ADDR_EXP 89
20969: PUSH
20970: LD_EXP 89
20974: PPUSH
20975: LD_VAR 0 1
20979: PPUSH
20980: EMPTY
20981: PPUSH
20982: CALL_OW 1
20986: ST_TO_ADDR
// mc_defender_limit := Replace ( mc_defender_limit , base , 0 ) ;
20987: LD_ADDR_EXP 90
20991: PUSH
20992: LD_EXP 90
20996: PPUSH
20997: LD_VAR 0 1
21001: PPUSH
21002: LD_INT 0
21004: PPUSH
21005: CALL_OW 1
21009: ST_TO_ADDR
// mc_repair_vehicle := Replace ( mc_repair_vehicle , base , [ ] ) ;
21010: LD_ADDR_EXP 91
21014: PUSH
21015: LD_EXP 91
21019: PPUSH
21020: LD_VAR 0 1
21024: PPUSH
21025: EMPTY
21026: PPUSH
21027: CALL_OW 1
21031: ST_TO_ADDR
// mc_mines := Replace ( mc_mines , base , [ ] ) ;
21032: LD_ADDR_EXP 92
21036: PUSH
21037: LD_EXP 92
21041: PPUSH
21042: LD_VAR 0 1
21046: PPUSH
21047: EMPTY
21048: PPUSH
21049: CALL_OW 1
21053: ST_TO_ADDR
// mc_miners := Replace ( mc_miners , base , [ ] ) ;
21054: LD_ADDR_EXP 93
21058: PUSH
21059: LD_EXP 93
21063: PPUSH
21064: LD_VAR 0 1
21068: PPUSH
21069: EMPTY
21070: PPUSH
21071: CALL_OW 1
21075: ST_TO_ADDR
// mc_minefields := Replace ( mc_minefields , base , [ ] ) ;
21076: LD_ADDR_EXP 94
21080: PUSH
21081: LD_EXP 94
21085: PPUSH
21086: LD_VAR 0 1
21090: PPUSH
21091: EMPTY
21092: PPUSH
21093: CALL_OW 1
21097: ST_TO_ADDR
// mc_crates := Replace ( mc_crates , base , [ ] ) ;
21098: LD_ADDR_EXP 95
21102: PUSH
21103: LD_EXP 95
21107: PPUSH
21108: LD_VAR 0 1
21112: PPUSH
21113: EMPTY
21114: PPUSH
21115: CALL_OW 1
21119: ST_TO_ADDR
// mc_crates_collector := Replace ( mc_crates_collector , base , [ ] ) ;
21120: LD_ADDR_EXP 96
21124: PUSH
21125: LD_EXP 96
21129: PPUSH
21130: LD_VAR 0 1
21134: PPUSH
21135: EMPTY
21136: PPUSH
21137: CALL_OW 1
21141: ST_TO_ADDR
// mc_crates_area := Replace ( mc_crates_area , base , [ ] ) ;
21142: LD_ADDR_EXP 97
21146: PUSH
21147: LD_EXP 97
21151: PPUSH
21152: LD_VAR 0 1
21156: PPUSH
21157: EMPTY
21158: PPUSH
21159: CALL_OW 1
21163: ST_TO_ADDR
// mc_vehicles := Replace ( mc_vehicles , base , [ ] ) ;
21164: LD_ADDR_EXP 98
21168: PUSH
21169: LD_EXP 98
21173: PPUSH
21174: LD_VAR 0 1
21178: PPUSH
21179: EMPTY
21180: PPUSH
21181: CALL_OW 1
21185: ST_TO_ADDR
// mc_attack := Replace ( mc_attack , base , [ ] ) ;
21186: LD_ADDR_EXP 99
21190: PUSH
21191: LD_EXP 99
21195: PPUSH
21196: LD_VAR 0 1
21200: PPUSH
21201: EMPTY
21202: PPUSH
21203: CALL_OW 1
21207: ST_TO_ADDR
// mc_produce := Replace ( mc_produce , base , [ ] ) ;
21208: LD_ADDR_EXP 100
21212: PUSH
21213: LD_EXP 100
21217: PPUSH
21218: LD_VAR 0 1
21222: PPUSH
21223: EMPTY
21224: PPUSH
21225: CALL_OW 1
21229: ST_TO_ADDR
// mc_defender := Replace ( mc_defender , base , [ ] ) ;
21230: LD_ADDR_EXP 101
21234: PUSH
21235: LD_EXP 101
21239: PPUSH
21240: LD_VAR 0 1
21244: PPUSH
21245: EMPTY
21246: PPUSH
21247: CALL_OW 1
21251: ST_TO_ADDR
// mc_scan := Replace ( mc_scan , base , [ ] ) ;
21252: LD_ADDR_EXP 102
21256: PUSH
21257: LD_EXP 102
21261: PPUSH
21262: LD_VAR 0 1
21266: PPUSH
21267: EMPTY
21268: PPUSH
21269: CALL_OW 1
21273: ST_TO_ADDR
// mc_parking := Replace ( mc_parking , base , [ ] ) ;
21274: LD_ADDR_EXP 103
21278: PUSH
21279: LD_EXP 103
21283: PPUSH
21284: LD_VAR 0 1
21288: PPUSH
21289: EMPTY
21290: PPUSH
21291: CALL_OW 1
21295: ST_TO_ADDR
// mc_scan_area := Replace ( mc_scan_area , base , [ ] ) ;
21296: LD_ADDR_EXP 104
21300: PUSH
21301: LD_EXP 104
21305: PPUSH
21306: LD_VAR 0 1
21310: PPUSH
21311: EMPTY
21312: PPUSH
21313: CALL_OW 1
21317: ST_TO_ADDR
// mc_tech := Replace ( mc_tech , base , [ ] ) ;
21318: LD_ADDR_EXP 106
21322: PUSH
21323: LD_EXP 106
21327: PPUSH
21328: LD_VAR 0 1
21332: PPUSH
21333: EMPTY
21334: PPUSH
21335: CALL_OW 1
21339: ST_TO_ADDR
// mc_ape := Replace ( mc_ape , base , [ ] ) ;
21340: LD_ADDR_EXP 108
21344: PUSH
21345: LD_EXP 108
21349: PPUSH
21350: LD_VAR 0 1
21354: PPUSH
21355: EMPTY
21356: PPUSH
21357: CALL_OW 1
21361: ST_TO_ADDR
// mc_ape_in_lab := Replace ( mc_ape_in_lab , base , [ ] ) ;
21362: LD_ADDR_EXP 109
21366: PUSH
21367: LD_EXP 109
21371: PPUSH
21372: LD_VAR 0 1
21376: PPUSH
21377: EMPTY
21378: PPUSH
21379: CALL_OW 1
21383: ST_TO_ADDR
// mc_taming := Replace ( mc_taming , base , [ ] ) ;
21384: LD_ADDR_EXP 110
21388: PUSH
21389: LD_EXP 110
21393: PPUSH
21394: LD_VAR 0 1
21398: PPUSH
21399: EMPTY
21400: PPUSH
21401: CALL_OW 1
21405: ST_TO_ADDR
// mc_build_upgrade := Replace ( mc_build_upgrade , base , [ ] ) ;
21406: LD_ADDR_EXP 111
21410: PUSH
21411: LD_EXP 111
21415: PPUSH
21416: LD_VAR 0 1
21420: PPUSH
21421: EMPTY
21422: PPUSH
21423: CALL_OW 1
21427: ST_TO_ADDR
// mc_lab := Replace ( mc_lab , base , [ ] ) ;
21428: LD_ADDR_EXP 112
21432: PUSH
21433: LD_EXP 112
21437: PPUSH
21438: LD_VAR 0 1
21442: PPUSH
21443: EMPTY
21444: PPUSH
21445: CALL_OW 1
21449: ST_TO_ADDR
// mc_lab_upgrade := Replace ( mc_lab_upgrade , base , [ ] ) ;
21450: LD_ADDR_EXP 113
21454: PUSH
21455: LD_EXP 113
21459: PPUSH
21460: LD_VAR 0 1
21464: PPUSH
21465: EMPTY
21466: PPUSH
21467: CALL_OW 1
21471: ST_TO_ADDR
// mc_teleport_exit := Replace ( mc_teleport_exit , base , [ ] ) ;
21472: LD_ADDR_EXP 114
21476: PUSH
21477: LD_EXP 114
21481: PPUSH
21482: LD_VAR 0 1
21486: PPUSH
21487: EMPTY
21488: PPUSH
21489: CALL_OW 1
21493: ST_TO_ADDR
// mc_teleport_exit_set := Replace ( mc_teleport_exit_set , base , [ ] ) ;
21494: LD_ADDR_EXP 115
21498: PUSH
21499: LD_EXP 115
21503: PPUSH
21504: LD_VAR 0 1
21508: PPUSH
21509: EMPTY
21510: PPUSH
21511: CALL_OW 1
21515: ST_TO_ADDR
// mc_deposits_xy := Replace ( mc_deposits_xy , base , [ ] ) ;
21516: LD_ADDR_EXP 116
21520: PUSH
21521: LD_EXP 116
21525: PPUSH
21526: LD_VAR 0 1
21530: PPUSH
21531: EMPTY
21532: PPUSH
21533: CALL_OW 1
21537: ST_TO_ADDR
// mc_deposits_finder := Replace ( mc_deposits_finder , base , [ ] ) ;
21538: LD_ADDR_EXP 117
21542: PUSH
21543: LD_EXP 117
21547: PPUSH
21548: LD_VAR 0 1
21552: PPUSH
21553: EMPTY
21554: PPUSH
21555: CALL_OW 1
21559: ST_TO_ADDR
// mc_allowed_tower_weapons := Replace ( mc_allowed_tower_weapons , base , [ ] ) ;
21560: LD_ADDR_EXP 118
21564: PUSH
21565: LD_EXP 118
21569: PPUSH
21570: LD_VAR 0 1
21574: PPUSH
21575: EMPTY
21576: PPUSH
21577: CALL_OW 1
21581: ST_TO_ADDR
// mc_remote_driver := Replace ( mc_remote_driver , base , [ ] ) ;
21582: LD_ADDR_EXP 119
21586: PUSH
21587: LD_EXP 119
21591: PPUSH
21592: LD_VAR 0 1
21596: PPUSH
21597: EMPTY
21598: PPUSH
21599: CALL_OW 1
21603: ST_TO_ADDR
// mc_class := Replace ( mc_class , base , [ ] ) ;
21604: LD_ADDR_EXP 120
21608: PUSH
21609: LD_EXP 120
21613: PPUSH
21614: LD_VAR 0 1
21618: PPUSH
21619: EMPTY
21620: PPUSH
21621: CALL_OW 1
21625: ST_TO_ADDR
// mc_class_case_use := Replace ( mc_class_case_use , base , 0 ) ;
21626: LD_ADDR_EXP 121
21630: PUSH
21631: LD_EXP 121
21635: PPUSH
21636: LD_VAR 0 1
21640: PPUSH
21641: LD_INT 0
21643: PPUSH
21644: CALL_OW 1
21648: ST_TO_ADDR
// end ;
21649: LD_VAR 0 2
21653: RET
// export function MC_Add ( side , units ) ; var base ; begin
21654: LD_INT 0
21656: PPUSH
21657: PPUSH
// base := mc_bases + 1 ;
21658: LD_ADDR_VAR 0 4
21662: PUSH
21663: LD_EXP 79
21667: PUSH
21668: LD_INT 1
21670: PLUS
21671: ST_TO_ADDR
// mc_sides := Replace ( mc_sides , base , side ) ;
21672: LD_ADDR_EXP 105
21676: PUSH
21677: LD_EXP 105
21681: PPUSH
21682: LD_VAR 0 4
21686: PPUSH
21687: LD_VAR 0 1
21691: PPUSH
21692: CALL_OW 1
21696: ST_TO_ADDR
// mc_bases := Replace ( mc_bases , base , units ) ;
21697: LD_ADDR_EXP 79
21701: PUSH
21702: LD_EXP 79
21706: PPUSH
21707: LD_VAR 0 4
21711: PPUSH
21712: LD_VAR 0 2
21716: PPUSH
21717: CALL_OW 1
21721: ST_TO_ADDR
// mc_building_need_repair := Replace ( mc_building_need_repair , base , [ ] ) ;
21722: LD_ADDR_EXP 80
21726: PUSH
21727: LD_EXP 80
21731: PPUSH
21732: LD_VAR 0 4
21736: PPUSH
21737: EMPTY
21738: PPUSH
21739: CALL_OW 1
21743: ST_TO_ADDR
// mc_building_repairs := Replace ( mc_building_repairs , base , [ ] ) ;
21744: LD_ADDR_EXP 81
21748: PUSH
21749: LD_EXP 81
21753: PPUSH
21754: LD_VAR 0 4
21758: PPUSH
21759: EMPTY
21760: PPUSH
21761: CALL_OW 1
21765: ST_TO_ADDR
// mc_need_heal := Replace ( mc_need_heal , base , [ ] ) ;
21766: LD_ADDR_EXP 82
21770: PUSH
21771: LD_EXP 82
21775: PPUSH
21776: LD_VAR 0 4
21780: PPUSH
21781: EMPTY
21782: PPUSH
21783: CALL_OW 1
21787: ST_TO_ADDR
// mc_healers := Replace ( mc_healers , base , [ ] ) ;
21788: LD_ADDR_EXP 83
21792: PUSH
21793: LD_EXP 83
21797: PPUSH
21798: LD_VAR 0 4
21802: PPUSH
21803: EMPTY
21804: PPUSH
21805: CALL_OW 1
21809: ST_TO_ADDR
// mc_build_list := Replace ( mc_build_list , base , [ ] ) ;
21810: LD_ADDR_EXP 84
21814: PUSH
21815: LD_EXP 84
21819: PPUSH
21820: LD_VAR 0 4
21824: PPUSH
21825: EMPTY
21826: PPUSH
21827: CALL_OW 1
21831: ST_TO_ADDR
// mc_builders := Replace ( mc_builders , base , [ ] ) ;
21832: LD_ADDR_EXP 85
21836: PUSH
21837: LD_EXP 85
21841: PPUSH
21842: LD_VAR 0 4
21846: PPUSH
21847: EMPTY
21848: PPUSH
21849: CALL_OW 1
21853: ST_TO_ADDR
// mc_construct_list := Replace ( mc_construct_list , base , [ ] ) ;
21854: LD_ADDR_EXP 86
21858: PUSH
21859: LD_EXP 86
21863: PPUSH
21864: LD_VAR 0 4
21868: PPUSH
21869: EMPTY
21870: PPUSH
21871: CALL_OW 1
21875: ST_TO_ADDR
// mc_turret_list := Replace ( mc_turret_list , base , [ ] ) ;
21876: LD_ADDR_EXP 87
21880: PUSH
21881: LD_EXP 87
21885: PPUSH
21886: LD_VAR 0 4
21890: PPUSH
21891: EMPTY
21892: PPUSH
21893: CALL_OW 1
21897: ST_TO_ADDR
// mc_empty_turret_list := Replace ( mc_empty_turret_list , base , [ ] ) ;
21898: LD_ADDR_EXP 88
21902: PUSH
21903: LD_EXP 88
21907: PPUSH
21908: LD_VAR 0 4
21912: PPUSH
21913: EMPTY
21914: PPUSH
21915: CALL_OW 1
21919: ST_TO_ADDR
// mc_busy_turret_list := Replace ( mc_busy_turret_list , base , [ ] ) ;
21920: LD_ADDR_EXP 89
21924: PUSH
21925: LD_EXP 89
21929: PPUSH
21930: LD_VAR 0 4
21934: PPUSH
21935: EMPTY
21936: PPUSH
21937: CALL_OW 1
21941: ST_TO_ADDR
// mc_defender_limit := Replace ( mc_defender_limit , base , 0 ) ;
21942: LD_ADDR_EXP 90
21946: PUSH
21947: LD_EXP 90
21951: PPUSH
21952: LD_VAR 0 4
21956: PPUSH
21957: LD_INT 0
21959: PPUSH
21960: CALL_OW 1
21964: ST_TO_ADDR
// mc_repair_vehicle := Replace ( mc_repair_vehicle , base , [ ] ) ;
21965: LD_ADDR_EXP 91
21969: PUSH
21970: LD_EXP 91
21974: PPUSH
21975: LD_VAR 0 4
21979: PPUSH
21980: EMPTY
21981: PPUSH
21982: CALL_OW 1
21986: ST_TO_ADDR
// mc_mines := Replace ( mc_mines , base , [ ] ) ;
21987: LD_ADDR_EXP 92
21991: PUSH
21992: LD_EXP 92
21996: PPUSH
21997: LD_VAR 0 4
22001: PPUSH
22002: EMPTY
22003: PPUSH
22004: CALL_OW 1
22008: ST_TO_ADDR
// mc_miners := Replace ( mc_miners , base , [ ] ) ;
22009: LD_ADDR_EXP 93
22013: PUSH
22014: LD_EXP 93
22018: PPUSH
22019: LD_VAR 0 4
22023: PPUSH
22024: EMPTY
22025: PPUSH
22026: CALL_OW 1
22030: ST_TO_ADDR
// mc_minefields := Replace ( mc_minefields , base , [ ] ) ;
22031: LD_ADDR_EXP 94
22035: PUSH
22036: LD_EXP 94
22040: PPUSH
22041: LD_VAR 0 4
22045: PPUSH
22046: EMPTY
22047: PPUSH
22048: CALL_OW 1
22052: ST_TO_ADDR
// mc_crates := Replace ( mc_crates , base , [ ] ) ;
22053: LD_ADDR_EXP 95
22057: PUSH
22058: LD_EXP 95
22062: PPUSH
22063: LD_VAR 0 4
22067: PPUSH
22068: EMPTY
22069: PPUSH
22070: CALL_OW 1
22074: ST_TO_ADDR
// mc_crates_collector := Replace ( mc_crates_collector , base , [ ] ) ;
22075: LD_ADDR_EXP 96
22079: PUSH
22080: LD_EXP 96
22084: PPUSH
22085: LD_VAR 0 4
22089: PPUSH
22090: EMPTY
22091: PPUSH
22092: CALL_OW 1
22096: ST_TO_ADDR
// mc_crates_area := Replace ( mc_crates_area , base , [ ] ) ;
22097: LD_ADDR_EXP 97
22101: PUSH
22102: LD_EXP 97
22106: PPUSH
22107: LD_VAR 0 4
22111: PPUSH
22112: EMPTY
22113: PPUSH
22114: CALL_OW 1
22118: ST_TO_ADDR
// mc_vehicles := Replace ( mc_vehicles , base , [ ] ) ;
22119: LD_ADDR_EXP 98
22123: PUSH
22124: LD_EXP 98
22128: PPUSH
22129: LD_VAR 0 4
22133: PPUSH
22134: EMPTY
22135: PPUSH
22136: CALL_OW 1
22140: ST_TO_ADDR
// mc_attack := Replace ( mc_attack , base , [ ] ) ;
22141: LD_ADDR_EXP 99
22145: PUSH
22146: LD_EXP 99
22150: PPUSH
22151: LD_VAR 0 4
22155: PPUSH
22156: EMPTY
22157: PPUSH
22158: CALL_OW 1
22162: ST_TO_ADDR
// mc_produce := Replace ( mc_produce , base , [ ] ) ;
22163: LD_ADDR_EXP 100
22167: PUSH
22168: LD_EXP 100
22172: PPUSH
22173: LD_VAR 0 4
22177: PPUSH
22178: EMPTY
22179: PPUSH
22180: CALL_OW 1
22184: ST_TO_ADDR
// mc_defender := Replace ( mc_defender , base , [ ] ) ;
22185: LD_ADDR_EXP 101
22189: PUSH
22190: LD_EXP 101
22194: PPUSH
22195: LD_VAR 0 4
22199: PPUSH
22200: EMPTY
22201: PPUSH
22202: CALL_OW 1
22206: ST_TO_ADDR
// mc_scan := Replace ( mc_scan , base , [ ] ) ;
22207: LD_ADDR_EXP 102
22211: PUSH
22212: LD_EXP 102
22216: PPUSH
22217: LD_VAR 0 4
22221: PPUSH
22222: EMPTY
22223: PPUSH
22224: CALL_OW 1
22228: ST_TO_ADDR
// mc_parking := Replace ( mc_parking , base , [ ] ) ;
22229: LD_ADDR_EXP 103
22233: PUSH
22234: LD_EXP 103
22238: PPUSH
22239: LD_VAR 0 4
22243: PPUSH
22244: EMPTY
22245: PPUSH
22246: CALL_OW 1
22250: ST_TO_ADDR
// mc_scan_area := Replace ( mc_scan_area , base , [ ] ) ;
22251: LD_ADDR_EXP 104
22255: PUSH
22256: LD_EXP 104
22260: PPUSH
22261: LD_VAR 0 4
22265: PPUSH
22266: EMPTY
22267: PPUSH
22268: CALL_OW 1
22272: ST_TO_ADDR
// mc_tech := Replace ( mc_tech , base , [ ] ) ;
22273: LD_ADDR_EXP 106
22277: PUSH
22278: LD_EXP 106
22282: PPUSH
22283: LD_VAR 0 4
22287: PPUSH
22288: EMPTY
22289: PPUSH
22290: CALL_OW 1
22294: ST_TO_ADDR
// mc_ape := Replace ( mc_ape , base , [ ] ) ;
22295: LD_ADDR_EXP 108
22299: PUSH
22300: LD_EXP 108
22304: PPUSH
22305: LD_VAR 0 4
22309: PPUSH
22310: EMPTY
22311: PPUSH
22312: CALL_OW 1
22316: ST_TO_ADDR
// mc_ape_in_lab := Replace ( mc_ape_in_lab , base , [ ] ) ;
22317: LD_ADDR_EXP 109
22321: PUSH
22322: LD_EXP 109
22326: PPUSH
22327: LD_VAR 0 4
22331: PPUSH
22332: EMPTY
22333: PPUSH
22334: CALL_OW 1
22338: ST_TO_ADDR
// mc_taming := Replace ( mc_taming , base , [ ] ) ;
22339: LD_ADDR_EXP 110
22343: PUSH
22344: LD_EXP 110
22348: PPUSH
22349: LD_VAR 0 4
22353: PPUSH
22354: EMPTY
22355: PPUSH
22356: CALL_OW 1
22360: ST_TO_ADDR
// mc_build_upgrade := Replace ( mc_build_upgrade , base , [ ] ) ;
22361: LD_ADDR_EXP 111
22365: PUSH
22366: LD_EXP 111
22370: PPUSH
22371: LD_VAR 0 4
22375: PPUSH
22376: EMPTY
22377: PPUSH
22378: CALL_OW 1
22382: ST_TO_ADDR
// mc_lab := Replace ( mc_lab , base , [ ] ) ;
22383: LD_ADDR_EXP 112
22387: PUSH
22388: LD_EXP 112
22392: PPUSH
22393: LD_VAR 0 4
22397: PPUSH
22398: EMPTY
22399: PPUSH
22400: CALL_OW 1
22404: ST_TO_ADDR
// mc_lab_upgrade := Replace ( mc_lab_upgrade , base , [ ] ) ;
22405: LD_ADDR_EXP 113
22409: PUSH
22410: LD_EXP 113
22414: PPUSH
22415: LD_VAR 0 4
22419: PPUSH
22420: EMPTY
22421: PPUSH
22422: CALL_OW 1
22426: ST_TO_ADDR
// mc_teleport_exit := Replace ( mc_teleport_exit , base , [ ] ) ;
22427: LD_ADDR_EXP 114
22431: PUSH
22432: LD_EXP 114
22436: PPUSH
22437: LD_VAR 0 4
22441: PPUSH
22442: EMPTY
22443: PPUSH
22444: CALL_OW 1
22448: ST_TO_ADDR
// mc_teleport_exit_set := Replace ( mc_teleport_exit_set , base , [ ] ) ;
22449: LD_ADDR_EXP 115
22453: PUSH
22454: LD_EXP 115
22458: PPUSH
22459: LD_VAR 0 4
22463: PPUSH
22464: EMPTY
22465: PPUSH
22466: CALL_OW 1
22470: ST_TO_ADDR
// mc_deposits_xy := Replace ( mc_deposits_xy , base , [ ] ) ;
22471: LD_ADDR_EXP 116
22475: PUSH
22476: LD_EXP 116
22480: PPUSH
22481: LD_VAR 0 4
22485: PPUSH
22486: EMPTY
22487: PPUSH
22488: CALL_OW 1
22492: ST_TO_ADDR
// mc_deposits_finder := Replace ( mc_deposits_finder , base , [ ] ) ;
22493: LD_ADDR_EXP 117
22497: PUSH
22498: LD_EXP 117
22502: PPUSH
22503: LD_VAR 0 4
22507: PPUSH
22508: EMPTY
22509: PPUSH
22510: CALL_OW 1
22514: ST_TO_ADDR
// mc_allowed_tower_weapons := Replace ( mc_allowed_tower_weapons , base , [ ] ) ;
22515: LD_ADDR_EXP 118
22519: PUSH
22520: LD_EXP 118
22524: PPUSH
22525: LD_VAR 0 4
22529: PPUSH
22530: EMPTY
22531: PPUSH
22532: CALL_OW 1
22536: ST_TO_ADDR
// mc_remote_driver := Replace ( mc_remote_driver , base , [ ] ) ;
22537: LD_ADDR_EXP 119
22541: PUSH
22542: LD_EXP 119
22546: PPUSH
22547: LD_VAR 0 4
22551: PPUSH
22552: EMPTY
22553: PPUSH
22554: CALL_OW 1
22558: ST_TO_ADDR
// mc_class := Replace ( mc_class , base , [ ] ) ;
22559: LD_ADDR_EXP 120
22563: PUSH
22564: LD_EXP 120
22568: PPUSH
22569: LD_VAR 0 4
22573: PPUSH
22574: EMPTY
22575: PPUSH
22576: CALL_OW 1
22580: ST_TO_ADDR
// mc_class_case_use := Replace ( mc_class_case_use , base , 0 ) ;
22581: LD_ADDR_EXP 121
22585: PUSH
22586: LD_EXP 121
22590: PPUSH
22591: LD_VAR 0 4
22595: PPUSH
22596: LD_INT 0
22598: PPUSH
22599: CALL_OW 1
22603: ST_TO_ADDR
// result := base ;
22604: LD_ADDR_VAR 0 3
22608: PUSH
22609: LD_VAR 0 4
22613: ST_TO_ADDR
// end ;
22614: LD_VAR 0 3
22618: RET
// export function MC_Start ( ) ; var i ; begin
22619: LD_INT 0
22621: PPUSH
22622: PPUSH
// for i = 1 to mc_bases do
22623: LD_ADDR_VAR 0 2
22627: PUSH
22628: DOUBLE
22629: LD_INT 1
22631: DEC
22632: ST_TO_ADDR
22633: LD_EXP 79
22637: PUSH
22638: FOR_TO
22639: IFFALSE 23716
// begin mc_bases := Replace ( mc_bases , i , mc_bases [ i ] diff 0 ) ;
22641: LD_ADDR_EXP 79
22645: PUSH
22646: LD_EXP 79
22650: PPUSH
22651: LD_VAR 0 2
22655: PPUSH
22656: LD_EXP 79
22660: PUSH
22661: LD_VAR 0 2
22665: ARRAY
22666: PUSH
22667: LD_INT 0
22669: DIFF
22670: PPUSH
22671: CALL_OW 1
22675: ST_TO_ADDR
// mc_building_need_repair := Replace ( mc_building_need_repair , i , [ ] ) ;
22676: LD_ADDR_EXP 80
22680: PUSH
22681: LD_EXP 80
22685: PPUSH
22686: LD_VAR 0 2
22690: PPUSH
22691: EMPTY
22692: PPUSH
22693: CALL_OW 1
22697: ST_TO_ADDR
// mc_building_repairs := Replace ( mc_building_repairs , i , [ ] ) ;
22698: LD_ADDR_EXP 81
22702: PUSH
22703: LD_EXP 81
22707: PPUSH
22708: LD_VAR 0 2
22712: PPUSH
22713: EMPTY
22714: PPUSH
22715: CALL_OW 1
22719: ST_TO_ADDR
// mc_need_heal := Replace ( mc_need_heal , i , [ ] ) ;
22720: LD_ADDR_EXP 82
22724: PUSH
22725: LD_EXP 82
22729: PPUSH
22730: LD_VAR 0 2
22734: PPUSH
22735: EMPTY
22736: PPUSH
22737: CALL_OW 1
22741: ST_TO_ADDR
// mc_healers := Replace ( mc_healers , i , [ [ ] , [ ] ] ) ;
22742: LD_ADDR_EXP 83
22746: PUSH
22747: LD_EXP 83
22751: PPUSH
22752: LD_VAR 0 2
22756: PPUSH
22757: EMPTY
22758: PUSH
22759: EMPTY
22760: PUSH
22761: EMPTY
22762: LIST
22763: LIST
22764: PPUSH
22765: CALL_OW 1
22769: ST_TO_ADDR
// mc_build_list := Replace ( mc_build_list , i , [ ] ) ;
22770: LD_ADDR_EXP 84
22774: PUSH
22775: LD_EXP 84
22779: PPUSH
22780: LD_VAR 0 2
22784: PPUSH
22785: EMPTY
22786: PPUSH
22787: CALL_OW 1
22791: ST_TO_ADDR
// mc_build_upgrade := Replace ( mc_build_upgrade , i , [ ] ) ;
22792: LD_ADDR_EXP 111
22796: PUSH
22797: LD_EXP 111
22801: PPUSH
22802: LD_VAR 0 2
22806: PPUSH
22807: EMPTY
22808: PPUSH
22809: CALL_OW 1
22813: ST_TO_ADDR
// mc_builders := Replace ( mc_builders , i , [ ] ) ;
22814: LD_ADDR_EXP 85
22818: PUSH
22819: LD_EXP 85
22823: PPUSH
22824: LD_VAR 0 2
22828: PPUSH
22829: EMPTY
22830: PPUSH
22831: CALL_OW 1
22835: ST_TO_ADDR
// mc_construct_list := Replace ( mc_construct_list , i , [ ] ) ;
22836: LD_ADDR_EXP 86
22840: PUSH
22841: LD_EXP 86
22845: PPUSH
22846: LD_VAR 0 2
22850: PPUSH
22851: EMPTY
22852: PPUSH
22853: CALL_OW 1
22857: ST_TO_ADDR
// mc_turret_list := Replace ( mc_turret_list , i , UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_bunker ] , [ f_btype , b_turret ] ] ) ) ;
22858: LD_ADDR_EXP 87
22862: PUSH
22863: LD_EXP 87
22867: PPUSH
22868: LD_VAR 0 2
22872: PPUSH
22873: LD_EXP 79
22877: PUSH
22878: LD_VAR 0 2
22882: ARRAY
22883: PPUSH
22884: LD_INT 2
22886: PUSH
22887: LD_INT 30
22889: PUSH
22890: LD_INT 32
22892: PUSH
22893: EMPTY
22894: LIST
22895: LIST
22896: PUSH
22897: LD_INT 30
22899: PUSH
22900: LD_INT 33
22902: PUSH
22903: EMPTY
22904: LIST
22905: LIST
22906: PUSH
22907: EMPTY
22908: LIST
22909: LIST
22910: LIST
22911: PPUSH
22912: CALL_OW 72
22916: PPUSH
22917: CALL_OW 1
22921: ST_TO_ADDR
// mc_empty_turret_list := Replace ( mc_empty_turret_list , i , UnitFilter ( mc_bases [ i ] , [ [ f_or , [ f_btype , b_bunker ] , [ f_btype , b_breastwork ] ] , [ f_empty ] ] ) ) ;
22922: LD_ADDR_EXP 88
22926: PUSH
22927: LD_EXP 88
22931: PPUSH
22932: LD_VAR 0 2
22936: PPUSH
22937: LD_EXP 79
22941: PUSH
22942: LD_VAR 0 2
22946: ARRAY
22947: PPUSH
22948: LD_INT 2
22950: PUSH
22951: LD_INT 30
22953: PUSH
22954: LD_INT 32
22956: PUSH
22957: EMPTY
22958: LIST
22959: LIST
22960: PUSH
22961: LD_INT 30
22963: PUSH
22964: LD_INT 31
22966: PUSH
22967: EMPTY
22968: LIST
22969: LIST
22970: PUSH
22971: EMPTY
22972: LIST
22973: LIST
22974: LIST
22975: PUSH
22976: LD_INT 58
22978: PUSH
22979: EMPTY
22980: LIST
22981: PUSH
22982: EMPTY
22983: LIST
22984: LIST
22985: PPUSH
22986: CALL_OW 72
22990: PPUSH
22991: CALL_OW 1
22995: ST_TO_ADDR
// mc_busy_turret_list := Replace ( mc_busy_turret_list , i , [ ] ) ;
22996: LD_ADDR_EXP 89
23000: PUSH
23001: LD_EXP 89
23005: PPUSH
23006: LD_VAR 0 2
23010: PPUSH
23011: EMPTY
23012: PPUSH
23013: CALL_OW 1
23017: ST_TO_ADDR
// mc_miners := Replace ( mc_miners , i , [ ] ) ;
23018: LD_ADDR_EXP 93
23022: PUSH
23023: LD_EXP 93
23027: PPUSH
23028: LD_VAR 0 2
23032: PPUSH
23033: EMPTY
23034: PPUSH
23035: CALL_OW 1
23039: ST_TO_ADDR
// mc_mines := Replace ( mc_mines , i , [ ] ) ;
23040: LD_ADDR_EXP 92
23044: PUSH
23045: LD_EXP 92
23049: PPUSH
23050: LD_VAR 0 2
23054: PPUSH
23055: EMPTY
23056: PPUSH
23057: CALL_OW 1
23061: ST_TO_ADDR
// mc_minefields := Replace ( mc_minefields , i , [ ] ) ;
23062: LD_ADDR_EXP 94
23066: PUSH
23067: LD_EXP 94
23071: PPUSH
23072: LD_VAR 0 2
23076: PPUSH
23077: EMPTY
23078: PPUSH
23079: CALL_OW 1
23083: ST_TO_ADDR
// mc_crates := Replace ( mc_crates , i , [ ] ) ;
23084: LD_ADDR_EXP 95
23088: PUSH
23089: LD_EXP 95
23093: PPUSH
23094: LD_VAR 0 2
23098: PPUSH
23099: EMPTY
23100: PPUSH
23101: CALL_OW 1
23105: ST_TO_ADDR
// mc_crates_collector := Replace ( mc_crates_collector , i , [ ] ) ;
23106: LD_ADDR_EXP 96
23110: PUSH
23111: LD_EXP 96
23115: PPUSH
23116: LD_VAR 0 2
23120: PPUSH
23121: EMPTY
23122: PPUSH
23123: CALL_OW 1
23127: ST_TO_ADDR
// mc_crates_area := Replace ( mc_crates_area , i , [ ] ) ;
23128: LD_ADDR_EXP 97
23132: PUSH
23133: LD_EXP 97
23137: PPUSH
23138: LD_VAR 0 2
23142: PPUSH
23143: EMPTY
23144: PPUSH
23145: CALL_OW 1
23149: ST_TO_ADDR
// mc_vehicles := Replace ( mc_vehicles , i , [ ] ) ;
23150: LD_ADDR_EXP 98
23154: PUSH
23155: LD_EXP 98
23159: PPUSH
23160: LD_VAR 0 2
23164: PPUSH
23165: EMPTY
23166: PPUSH
23167: CALL_OW 1
23171: ST_TO_ADDR
// mc_attack := Replace ( mc_attack , i , [ ] ) ;
23172: LD_ADDR_EXP 99
23176: PUSH
23177: LD_EXP 99
23181: PPUSH
23182: LD_VAR 0 2
23186: PPUSH
23187: EMPTY
23188: PPUSH
23189: CALL_OW 1
23193: ST_TO_ADDR
// mc_produce := Replace ( mc_produce , i , [ ] ) ;
23194: LD_ADDR_EXP 100
23198: PUSH
23199: LD_EXP 100
23203: PPUSH
23204: LD_VAR 0 2
23208: PPUSH
23209: EMPTY
23210: PPUSH
23211: CALL_OW 1
23215: ST_TO_ADDR
// mc_defender := Replace ( mc_defender , i , [ ] ) ;
23216: LD_ADDR_EXP 101
23220: PUSH
23221: LD_EXP 101
23225: PPUSH
23226: LD_VAR 0 2
23230: PPUSH
23231: EMPTY
23232: PPUSH
23233: CALL_OW 1
23237: ST_TO_ADDR
// mc_defender_limit := Replace ( mc_defender_limit , i , 0 ) ;
23238: LD_ADDR_EXP 90
23242: PUSH
23243: LD_EXP 90
23247: PPUSH
23248: LD_VAR 0 2
23252: PPUSH
23253: LD_INT 0
23255: PPUSH
23256: CALL_OW 1
23260: ST_TO_ADDR
// mc_parking := Replace ( mc_parking , i , 0 ) ;
23261: LD_ADDR_EXP 103
23265: PUSH
23266: LD_EXP 103
23270: PPUSH
23271: LD_VAR 0 2
23275: PPUSH
23276: LD_INT 0
23278: PPUSH
23279: CALL_OW 1
23283: ST_TO_ADDR
// mc_repair_vehicle := Replace ( mc_repair_vehicle , i , [ ] ) ;
23284: LD_ADDR_EXP 91
23288: PUSH
23289: LD_EXP 91
23293: PPUSH
23294: LD_VAR 0 2
23298: PPUSH
23299: EMPTY
23300: PPUSH
23301: CALL_OW 1
23305: ST_TO_ADDR
// mc_scan := Replace ( mc_scan , i , 0 ) ;
23306: LD_ADDR_EXP 102
23310: PUSH
23311: LD_EXP 102
23315: PPUSH
23316: LD_VAR 0 2
23320: PPUSH
23321: LD_INT 0
23323: PPUSH
23324: CALL_OW 1
23328: ST_TO_ADDR
// mc_scan_area := Replace ( mc_scan_area , i , [ ] ) ;
23329: LD_ADDR_EXP 104
23333: PUSH
23334: LD_EXP 104
23338: PPUSH
23339: LD_VAR 0 2
23343: PPUSH
23344: EMPTY
23345: PPUSH
23346: CALL_OW 1
23350: ST_TO_ADDR
// mc_can_tame := Replace ( mc_can_tame , i , 0 ) ;
23351: LD_ADDR_EXP 107
23355: PUSH
23356: LD_EXP 107
23360: PPUSH
23361: LD_VAR 0 2
23365: PPUSH
23366: LD_INT 0
23368: PPUSH
23369: CALL_OW 1
23373: ST_TO_ADDR
// mc_ape := Replace ( mc_ape , i , [ ] ) ;
23374: LD_ADDR_EXP 108
23378: PUSH
23379: LD_EXP 108
23383: PPUSH
23384: LD_VAR 0 2
23388: PPUSH
23389: EMPTY
23390: PPUSH
23391: CALL_OW 1
23395: ST_TO_ADDR
// mc_ape_in_lab := Replace ( mc_ape_in_lab , i , [ ] ) ;
23396: LD_ADDR_EXP 109
23400: PUSH
23401: LD_EXP 109
23405: PPUSH
23406: LD_VAR 0 2
23410: PPUSH
23411: EMPTY
23412: PPUSH
23413: CALL_OW 1
23417: ST_TO_ADDR
// mc_taming := Replace ( mc_taming , i , [ ] ) ;
23418: LD_ADDR_EXP 110
23422: PUSH
23423: LD_EXP 110
23427: PPUSH
23428: LD_VAR 0 2
23432: PPUSH
23433: EMPTY
23434: PPUSH
23435: CALL_OW 1
23439: ST_TO_ADDR
// mc_lab := Replace ( mc_lab , i , UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_lab ] , [ f_btype , b_lab_half ] , [ f_btype , b_lab_full ] ] ) ) ;
23440: LD_ADDR_EXP 112
23444: PUSH
23445: LD_EXP 112
23449: PPUSH
23450: LD_VAR 0 2
23454: PPUSH
23455: LD_EXP 79
23459: PUSH
23460: LD_VAR 0 2
23464: ARRAY
23465: PPUSH
23466: LD_INT 2
23468: PUSH
23469: LD_INT 30
23471: PUSH
23472: LD_INT 6
23474: PUSH
23475: EMPTY
23476: LIST
23477: LIST
23478: PUSH
23479: LD_INT 30
23481: PUSH
23482: LD_INT 7
23484: PUSH
23485: EMPTY
23486: LIST
23487: LIST
23488: PUSH
23489: LD_INT 30
23491: PUSH
23492: LD_INT 8
23494: PUSH
23495: EMPTY
23496: LIST
23497: LIST
23498: PUSH
23499: EMPTY
23500: LIST
23501: LIST
23502: LIST
23503: LIST
23504: PPUSH
23505: CALL_OW 72
23509: PPUSH
23510: CALL_OW 1
23514: ST_TO_ADDR
// mc_lab_upgrade := Replace ( mc_lab_upgrade , i , [ ] ) ;
23515: LD_ADDR_EXP 113
23519: PUSH
23520: LD_EXP 113
23524: PPUSH
23525: LD_VAR 0 2
23529: PPUSH
23530: EMPTY
23531: PPUSH
23532: CALL_OW 1
23536: ST_TO_ADDR
// mc_teleport_exit := Replace ( mc_teleport_exit , i , [ ] ) ;
23537: LD_ADDR_EXP 114
23541: PUSH
23542: LD_EXP 114
23546: PPUSH
23547: LD_VAR 0 2
23551: PPUSH
23552: EMPTY
23553: PPUSH
23554: CALL_OW 1
23558: ST_TO_ADDR
// mc_teleport_exit_set := Replace ( mc_teleport_exit_set , i , [ ] ) ;
23559: LD_ADDR_EXP 115
23563: PUSH
23564: LD_EXP 115
23568: PPUSH
23569: LD_VAR 0 2
23573: PPUSH
23574: EMPTY
23575: PPUSH
23576: CALL_OW 1
23580: ST_TO_ADDR
// mc_deposits_xy := Replace ( mc_deposits_xy , i , [ ] ) ;
23581: LD_ADDR_EXP 116
23585: PUSH
23586: LD_EXP 116
23590: PPUSH
23591: LD_VAR 0 2
23595: PPUSH
23596: EMPTY
23597: PPUSH
23598: CALL_OW 1
23602: ST_TO_ADDR
// mc_deposits_finder := Replace ( mc_deposits_finder , i , [ ] ) ;
23603: LD_ADDR_EXP 117
23607: PUSH
23608: LD_EXP 117
23612: PPUSH
23613: LD_VAR 0 2
23617: PPUSH
23618: EMPTY
23619: PPUSH
23620: CALL_OW 1
23624: ST_TO_ADDR
// mc_allowed_tower_weapons := Replace ( mc_allowed_tower_weapons , i , [ ] ) ;
23625: LD_ADDR_EXP 118
23629: PUSH
23630: LD_EXP 118
23634: PPUSH
23635: LD_VAR 0 2
23639: PPUSH
23640: EMPTY
23641: PPUSH
23642: CALL_OW 1
23646: ST_TO_ADDR
// mc_remote_driver := Replace ( mc_remote_driver , i , [ ] ) ;
23647: LD_ADDR_EXP 119
23651: PUSH
23652: LD_EXP 119
23656: PPUSH
23657: LD_VAR 0 2
23661: PPUSH
23662: EMPTY
23663: PPUSH
23664: CALL_OW 1
23668: ST_TO_ADDR
// mc_class := Replace ( mc_class , i , [ ] ) ;
23669: LD_ADDR_EXP 120
23673: PUSH
23674: LD_EXP 120
23678: PPUSH
23679: LD_VAR 0 2
23683: PPUSH
23684: EMPTY
23685: PPUSH
23686: CALL_OW 1
23690: ST_TO_ADDR
// mc_class_case_use := Replace ( mc_class_case_use , i , 0 ) ;
23691: LD_ADDR_EXP 121
23695: PUSH
23696: LD_EXP 121
23700: PPUSH
23701: LD_VAR 0 2
23705: PPUSH
23706: LD_INT 0
23708: PPUSH
23709: CALL_OW 1
23713: ST_TO_ADDR
// end ;
23714: GO 22638
23716: POP
23717: POP
// MC_InitSides ( ) ;
23718: CALL 24004 0 0
// MC_InitResearch ( ) ;
23722: CALL 23743 0 0
// CustomInitMacro ( ) ;
23726: CALL 213 0 0
// skirmish := true ;
23730: LD_ADDR_EXP 77
23734: PUSH
23735: LD_INT 1
23737: ST_TO_ADDR
// end ;
23738: LD_VAR 0 1
23742: RET
// export function MC_InitResearch ( ) ; var i , j , nation , tmp , un ; begin
23743: LD_INT 0
23745: PPUSH
23746: PPUSH
23747: PPUSH
23748: PPUSH
23749: PPUSH
23750: PPUSH
// if not mc_bases then
23751: LD_EXP 79
23755: NOT
23756: IFFALSE 23760
// exit ;
23758: GO 23999
// for i = 1 to 8 do
23760: LD_ADDR_VAR 0 2
23764: PUSH
23765: DOUBLE
23766: LD_INT 1
23768: DEC
23769: ST_TO_ADDR
23770: LD_INT 8
23772: PUSH
23773: FOR_TO
23774: IFFALSE 23800
// mc_tech := Replace ( mc_tech , i , [ ] ) ;
23776: LD_ADDR_EXP 106
23780: PUSH
23781: LD_EXP 106
23785: PPUSH
23786: LD_VAR 0 2
23790: PPUSH
23791: EMPTY
23792: PPUSH
23793: CALL_OW 1
23797: ST_TO_ADDR
23798: GO 23773
23800: POP
23801: POP
// tmp := [ ] ;
23802: LD_ADDR_VAR 0 5
23806: PUSH
23807: EMPTY
23808: ST_TO_ADDR
// for i = 1 to mc_sides do
23809: LD_ADDR_VAR 0 2
23813: PUSH
23814: DOUBLE
23815: LD_INT 1
23817: DEC
23818: ST_TO_ADDR
23819: LD_EXP 105
23823: PUSH
23824: FOR_TO
23825: IFFALSE 23883
// if not mc_sides [ i ] in tmp then
23827: LD_EXP 105
23831: PUSH
23832: LD_VAR 0 2
23836: ARRAY
23837: PUSH
23838: LD_VAR 0 5
23842: IN
23843: NOT
23844: IFFALSE 23881
// tmp := Insert ( tmp , tmp + 1 , mc_sides [ i ] ) ;
23846: LD_ADDR_VAR 0 5
23850: PUSH
23851: LD_VAR 0 5
23855: PPUSH
23856: LD_VAR 0 5
23860: PUSH
23861: LD_INT 1
23863: PLUS
23864: PPUSH
23865: LD_EXP 105
23869: PUSH
23870: LD_VAR 0 2
23874: ARRAY
23875: PPUSH
23876: CALL_OW 2
23880: ST_TO_ADDR
23881: GO 23824
23883: POP
23884: POP
// if not tmp then
23885: LD_VAR 0 5
23889: NOT
23890: IFFALSE 23894
// exit ;
23892: GO 23999
// for j in tmp do
23894: LD_ADDR_VAR 0 3
23898: PUSH
23899: LD_VAR 0 5
23903: PUSH
23904: FOR_IN
23905: IFFALSE 23997
// begin un := FilterAllUnits ( [ f_side , j ] ) ;
23907: LD_ADDR_VAR 0 6
23911: PUSH
23912: LD_INT 22
23914: PUSH
23915: LD_VAR 0 3
23919: PUSH
23920: EMPTY
23921: LIST
23922: LIST
23923: PPUSH
23924: CALL_OW 69
23928: ST_TO_ADDR
// if not un then
23929: LD_VAR 0 6
23933: NOT
23934: IFFALSE 23938
// continue ;
23936: GO 23904
// nation := GetNation ( un [ 1 ] ) ;
23938: LD_ADDR_VAR 0 4
23942: PUSH
23943: LD_VAR 0 6
23947: PUSH
23948: LD_INT 1
23950: ARRAY
23951: PPUSH
23952: CALL_OW 248
23956: ST_TO_ADDR
// mc_tech := Replace ( mc_tech , j , GetTechNation ( j , nation , state_enabled ) ) ;
23957: LD_ADDR_EXP 106
23961: PUSH
23962: LD_EXP 106
23966: PPUSH
23967: LD_VAR 0 3
23971: PPUSH
23972: LD_VAR 0 3
23976: PPUSH
23977: LD_VAR 0 4
23981: PPUSH
23982: LD_INT 1
23984: PPUSH
23985: CALL 50609 0 3
23989: PPUSH
23990: CALL_OW 1
23994: ST_TO_ADDR
// end ;
23995: GO 23904
23997: POP
23998: POP
// end ;
23999: LD_VAR 0 1
24003: RET
// export function MC_InitSides ( ) ; var i ; begin
24004: LD_INT 0
24006: PPUSH
24007: PPUSH
// if not mc_bases then
24008: LD_EXP 79
24012: NOT
24013: IFFALSE 24017
// exit ;
24015: GO 24091
// for i = 1 to mc_bases do
24017: LD_ADDR_VAR 0 2
24021: PUSH
24022: DOUBLE
24023: LD_INT 1
24025: DEC
24026: ST_TO_ADDR
24027: LD_EXP 79
24031: PUSH
24032: FOR_TO
24033: IFFALSE 24089
// if mc_bases [ i ] then
24035: LD_EXP 79
24039: PUSH
24040: LD_VAR 0 2
24044: ARRAY
24045: IFFALSE 24087
// mc_sides := Replace ( mc_sides , i , GetSide ( mc_bases [ i ] [ 1 ] ) ) ;
24047: LD_ADDR_EXP 105
24051: PUSH
24052: LD_EXP 105
24056: PPUSH
24057: LD_VAR 0 2
24061: PPUSH
24062: LD_EXP 79
24066: PUSH
24067: LD_VAR 0 2
24071: ARRAY
24072: PUSH
24073: LD_INT 1
24075: ARRAY
24076: PPUSH
24077: CALL_OW 255
24081: PPUSH
24082: CALL_OW 1
24086: ST_TO_ADDR
24087: GO 24032
24089: POP
24090: POP
// end ;
24091: LD_VAR 0 1
24095: RET
// every 0 0$01 trigger skirmish do
24096: LD_EXP 77
24100: IFFALSE 24254
24102: GO 24104
24104: DISABLE
// begin enable ;
24105: ENABLE
// MC_CheckBuildings ( ) ;
24106: CALL 28752 0 0
// MC_CheckPeopleLife ( ) ;
24110: CALL 28877 0 0
// RaiseSailEvent ( 100 ) ;
24114: LD_INT 100
24116: PPUSH
24117: CALL_OW 427
// RaiseSailEvent ( 103 ) ;
24121: LD_INT 103
24123: PPUSH
24124: CALL_OW 427
// RaiseSailEvent ( 104 ) ;
24128: LD_INT 104
24130: PPUSH
24131: CALL_OW 427
// RaiseSailEvent ( 105 ) ;
24135: LD_INT 105
24137: PPUSH
24138: CALL_OW 427
// RaiseSailEvent ( 106 ) ;
24142: LD_INT 106
24144: PPUSH
24145: CALL_OW 427
// RaiseSailEvent ( 107 ) ;
24149: LD_INT 107
24151: PPUSH
24152: CALL_OW 427
// RaiseSailEvent ( 108 ) ;
24156: LD_INT 108
24158: PPUSH
24159: CALL_OW 427
// RaiseSailEvent ( 109 ) ;
24163: LD_INT 109
24165: PPUSH
24166: CALL_OW 427
// RaiseSailEvent ( 110 ) ;
24170: LD_INT 110
24172: PPUSH
24173: CALL_OW 427
// RaiseSailEvent ( 111 ) ;
24177: LD_INT 111
24179: PPUSH
24180: CALL_OW 427
// RaiseSailEvent ( 112 ) ;
24184: LD_INT 112
24186: PPUSH
24187: CALL_OW 427
// RaiseSailEvent ( 113 ) ;
24191: LD_INT 113
24193: PPUSH
24194: CALL_OW 427
// RaiseSailEvent ( 120 ) ;
24198: LD_INT 120
24200: PPUSH
24201: CALL_OW 427
// RaiseSailEvent ( 121 ) ;
24205: LD_INT 121
24207: PPUSH
24208: CALL_OW 427
// RaiseSailEvent ( 122 ) ;
24212: LD_INT 122
24214: PPUSH
24215: CALL_OW 427
// RaiseSailEvent ( 123 ) ;
24219: LD_INT 123
24221: PPUSH
24222: CALL_OW 427
// RaiseSailEvent ( 124 ) ;
24226: LD_INT 124
24228: PPUSH
24229: CALL_OW 427
// RaiseSailEvent ( 125 ) ;
24233: LD_INT 125
24235: PPUSH
24236: CALL_OW 427
// RaiseSailEvent ( 126 ) ;
24240: LD_INT 126
24242: PPUSH
24243: CALL_OW 427
// RaiseSailEvent ( 200 ) ;
24247: LD_INT 200
24249: PPUSH
24250: CALL_OW 427
// end ;
24254: END
// on SailEvent ( event ) do begin if event < 100 then
24255: LD_VAR 0 1
24259: PUSH
24260: LD_INT 100
24262: LESS
24263: IFFALSE 24274
// CustomEvent ( event ) ;
24265: LD_VAR 0 1
24269: PPUSH
24270: CALL 10371 0 1
// if event = 100 then
24274: LD_VAR 0 1
24278: PUSH
24279: LD_INT 100
24281: EQUAL
24282: IFFALSE 24288
// MC_ClassManager ( ) ;
24284: CALL 24680 0 0
// if event = 101 then
24288: LD_VAR 0 1
24292: PUSH
24293: LD_INT 101
24295: EQUAL
24296: IFFALSE 24302
// MC_RepairBuildings ( ) ;
24298: CALL 29473 0 0
// if event = 102 then
24302: LD_VAR 0 1
24306: PUSH
24307: LD_INT 102
24309: EQUAL
24310: IFFALSE 24316
// MC_Heal ( ) ;
24312: CALL 30337 0 0
// if event = 103 then
24316: LD_VAR 0 1
24320: PUSH
24321: LD_INT 103
24323: EQUAL
24324: IFFALSE 24330
// MC_Build ( ) ;
24326: CALL 30759 0 0
// if event = 104 then
24330: LD_VAR 0 1
24334: PUSH
24335: LD_INT 104
24337: EQUAL
24338: IFFALSE 24344
// MC_TurretWeapon ( ) ;
24340: CALL 32372 0 0
// if event = 105 then
24344: LD_VAR 0 1
24348: PUSH
24349: LD_INT 105
24351: EQUAL
24352: IFFALSE 24358
// MC_BuildUpgrade ( ) ;
24354: CALL 31923 0 0
// if event = 106 then
24358: LD_VAR 0 1
24362: PUSH
24363: LD_INT 106
24365: EQUAL
24366: IFFALSE 24372
// MC_PlantMines ( ) ;
24368: CALL 32802 0 0
// if event = 107 then
24372: LD_VAR 0 1
24376: PUSH
24377: LD_INT 107
24379: EQUAL
24380: IFFALSE 24386
// MC_CollectCrates ( ) ;
24382: CALL 33600 0 0
// if event = 108 then
24386: LD_VAR 0 1
24390: PUSH
24391: LD_INT 108
24393: EQUAL
24394: IFFALSE 24400
// MC_LinkRemoteControl ( ) ;
24396: CALL 35376 0 0
// if event = 109 then
24400: LD_VAR 0 1
24404: PUSH
24405: LD_INT 109
24407: EQUAL
24408: IFFALSE 24414
// MC_ProduceVehicle ( ) ;
24410: CALL 35557 0 0
// if event = 110 then
24414: LD_VAR 0 1
24418: PUSH
24419: LD_INT 110
24421: EQUAL
24422: IFFALSE 24428
// MC_SendAttack ( ) ;
24424: CALL 36023 0 0
// if event = 111 then
24428: LD_VAR 0 1
24432: PUSH
24433: LD_INT 111
24435: EQUAL
24436: IFFALSE 24442
// MC_Defend ( ) ;
24438: CALL 36131 0 0
// if event = 112 then
24442: LD_VAR 0 1
24446: PUSH
24447: LD_INT 112
24449: EQUAL
24450: IFFALSE 24456
// MC_Research ( ) ;
24452: CALL 36736 0 0
// if event = 113 then
24456: LD_VAR 0 1
24460: PUSH
24461: LD_INT 113
24463: EQUAL
24464: IFFALSE 24470
// MC_MinesTrigger ( ) ;
24466: CALL 37850 0 0
// if event = 120 then
24470: LD_VAR 0 1
24474: PUSH
24475: LD_INT 120
24477: EQUAL
24478: IFFALSE 24484
// MC_RepairVehicle ( ) ;
24480: CALL 37949 0 0
// if event = 121 then
24484: LD_VAR 0 1
24488: PUSH
24489: LD_INT 121
24491: EQUAL
24492: IFFALSE 24498
// MC_TameApe ( ) ;
24494: CALL 38679 0 0
// if event = 122 then
24498: LD_VAR 0 1
24502: PUSH
24503: LD_INT 122
24505: EQUAL
24506: IFFALSE 24512
// MC_ChangeApeClass ( ) ;
24508: CALL 39508 0 0
// if event = 123 then
24512: LD_VAR 0 1
24516: PUSH
24517: LD_INT 123
24519: EQUAL
24520: IFFALSE 24526
// MC_Bazooka ( ) ;
24522: CALL 40158 0 0
// if event = 124 then
24526: LD_VAR 0 1
24530: PUSH
24531: LD_INT 124
24533: EQUAL
24534: IFFALSE 24540
// MC_TeleportExit ( ) ;
24536: CALL 40356 0 0
// if event = 125 then
24540: LD_VAR 0 1
24544: PUSH
24545: LD_INT 125
24547: EQUAL
24548: IFFALSE 24554
// MC_Deposits ( ) ;
24550: CALL 41003 0 0
// if event = 126 then
24554: LD_VAR 0 1
24558: PUSH
24559: LD_INT 126
24561: EQUAL
24562: IFFALSE 24568
// MC_RemoteDriver ( ) ;
24564: CALL 41628 0 0
// if event = 200 then
24568: LD_VAR 0 1
24572: PUSH
24573: LD_INT 200
24575: EQUAL
24576: IFFALSE 24582
// MC_Idle ( ) ;
24578: CALL 43577 0 0
// end ;
24582: PPOPN 1
24584: END
// export function MC_Reset ( base , tag ) ; var i ; begin
24585: LD_INT 0
24587: PPUSH
24588: PPUSH
// if not mc_bases [ base ] or not tag then
24589: LD_EXP 79
24593: PUSH
24594: LD_VAR 0 1
24598: ARRAY
24599: NOT
24600: PUSH
24601: LD_VAR 0 2
24605: NOT
24606: OR
24607: IFFALSE 24611
// exit ;
24609: GO 24675
// for i in mc_bases [ base ] union mc_ape [ base ] do
24611: LD_ADDR_VAR 0 4
24615: PUSH
24616: LD_EXP 79
24620: PUSH
24621: LD_VAR 0 1
24625: ARRAY
24626: PUSH
24627: LD_EXP 108
24631: PUSH
24632: LD_VAR 0 1
24636: ARRAY
24637: UNION
24638: PUSH
24639: FOR_IN
24640: IFFALSE 24673
// if GetTag ( i ) = tag then
24642: LD_VAR 0 4
24646: PPUSH
24647: CALL_OW 110
24651: PUSH
24652: LD_VAR 0 2
24656: EQUAL
24657: IFFALSE 24671
// SetTag ( i , 0 ) ;
24659: LD_VAR 0 4
24663: PPUSH
24664: LD_INT 0
24666: PPUSH
24667: CALL_OW 109
24671: GO 24639
24673: POP
24674: POP
// end ;
24675: LD_VAR 0 3
24679: RET
// export function MC_ClassManager ( ) ; var i , j , tmp , p , b , e , k ; begin
24680: LD_INT 0
24682: PPUSH
24683: PPUSH
24684: PPUSH
24685: PPUSH
24686: PPUSH
24687: PPUSH
24688: PPUSH
24689: PPUSH
// if not mc_bases then
24690: LD_EXP 79
24694: NOT
24695: IFFALSE 24699
// exit ;
24697: GO 25157
// for i = 1 to mc_bases do
24699: LD_ADDR_VAR 0 2
24703: PUSH
24704: DOUBLE
24705: LD_INT 1
24707: DEC
24708: ST_TO_ADDR
24709: LD_EXP 79
24713: PUSH
24714: FOR_TO
24715: IFFALSE 25155
// begin tmp := MC_ClassCheckReq ( i ) ;
24717: LD_ADDR_VAR 0 4
24721: PUSH
24722: LD_VAR 0 2
24726: PPUSH
24727: CALL 25162 0 1
24731: ST_TO_ADDR
// mc_class := Replace ( mc_class , i , tmp ) ;
24732: LD_ADDR_EXP 120
24736: PUSH
24737: LD_EXP 120
24741: PPUSH
24742: LD_VAR 0 2
24746: PPUSH
24747: LD_VAR 0 4
24751: PPUSH
24752: CALL_OW 1
24756: ST_TO_ADDR
// if not tmp then
24757: LD_VAR 0 4
24761: NOT
24762: IFFALSE 24766
// continue ;
24764: GO 24714
// b := [ UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_armoury ] , [ f_btype , b_barracks ] ] ) , UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) , UnitFilter ( mc_bases [ i ] , [ f_btype , b_factory ] ) , UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_lab ] , [ f_btype , b_lab_half ] , [ f_btype , b_lab_full ] ] ) ] ;
24766: LD_ADDR_VAR 0 6
24770: PUSH
24771: LD_EXP 79
24775: PUSH
24776: LD_VAR 0 2
24780: ARRAY
24781: PPUSH
24782: LD_INT 2
24784: PUSH
24785: LD_INT 30
24787: PUSH
24788: LD_INT 4
24790: PUSH
24791: EMPTY
24792: LIST
24793: LIST
24794: PUSH
24795: LD_INT 30
24797: PUSH
24798: LD_INT 5
24800: PUSH
24801: EMPTY
24802: LIST
24803: LIST
24804: PUSH
24805: EMPTY
24806: LIST
24807: LIST
24808: LIST
24809: PPUSH
24810: CALL_OW 72
24814: PUSH
24815: LD_EXP 79
24819: PUSH
24820: LD_VAR 0 2
24824: ARRAY
24825: PPUSH
24826: LD_INT 2
24828: PUSH
24829: LD_INT 30
24831: PUSH
24832: LD_INT 0
24834: PUSH
24835: EMPTY
24836: LIST
24837: LIST
24838: PUSH
24839: LD_INT 30
24841: PUSH
24842: LD_INT 1
24844: PUSH
24845: EMPTY
24846: LIST
24847: LIST
24848: PUSH
24849: EMPTY
24850: LIST
24851: LIST
24852: LIST
24853: PPUSH
24854: CALL_OW 72
24858: PUSH
24859: LD_EXP 79
24863: PUSH
24864: LD_VAR 0 2
24868: ARRAY
24869: PPUSH
24870: LD_INT 30
24872: PUSH
24873: LD_INT 3
24875: PUSH
24876: EMPTY
24877: LIST
24878: LIST
24879: PPUSH
24880: CALL_OW 72
24884: PUSH
24885: LD_EXP 79
24889: PUSH
24890: LD_VAR 0 2
24894: ARRAY
24895: PPUSH
24896: LD_INT 2
24898: PUSH
24899: LD_INT 30
24901: PUSH
24902: LD_INT 6
24904: PUSH
24905: EMPTY
24906: LIST
24907: LIST
24908: PUSH
24909: LD_INT 30
24911: PUSH
24912: LD_INT 7
24914: PUSH
24915: EMPTY
24916: LIST
24917: LIST
24918: PUSH
24919: LD_INT 30
24921: PUSH
24922: LD_INT 8
24924: PUSH
24925: EMPTY
24926: LIST
24927: LIST
24928: PUSH
24929: EMPTY
24930: LIST
24931: LIST
24932: LIST
24933: LIST
24934: PPUSH
24935: CALL_OW 72
24939: PUSH
24940: EMPTY
24941: LIST
24942: LIST
24943: LIST
24944: LIST
24945: ST_TO_ADDR
// for j = 1 to 4 do
24946: LD_ADDR_VAR 0 3
24950: PUSH
24951: DOUBLE
24952: LD_INT 1
24954: DEC
24955: ST_TO_ADDR
24956: LD_INT 4
24958: PUSH
24959: FOR_TO
24960: IFFALSE 25151
// begin if not tmp [ j ] then
24962: LD_VAR 0 4
24966: PUSH
24967: LD_VAR 0 3
24971: ARRAY
24972: NOT
24973: IFFALSE 24977
// continue ;
24975: GO 24959
// for p in tmp [ j ] do
24977: LD_ADDR_VAR 0 5
24981: PUSH
24982: LD_VAR 0 4
24986: PUSH
24987: LD_VAR 0 3
24991: ARRAY
24992: PUSH
24993: FOR_IN
24994: IFFALSE 25147
// begin if not b [ j ] then
24996: LD_VAR 0 6
25000: PUSH
25001: LD_VAR 0 3
25005: ARRAY
25006: NOT
25007: IFFALSE 25011
// break ;
25009: GO 25147
// e := 0 ;
25011: LD_ADDR_VAR 0 7
25015: PUSH
25016: LD_INT 0
25018: ST_TO_ADDR
// for k in b [ j ] do
25019: LD_ADDR_VAR 0 8
25023: PUSH
25024: LD_VAR 0 6
25028: PUSH
25029: LD_VAR 0 3
25033: ARRAY
25034: PUSH
25035: FOR_IN
25036: IFFALSE 25063
// if IsNotFull ( k ) then
25038: LD_VAR 0 8
25042: PPUSH
25043: CALL 55049 0 1
25047: IFFALSE 25061
// begin e := k ;
25049: LD_ADDR_VAR 0 7
25053: PUSH
25054: LD_VAR 0 8
25058: ST_TO_ADDR
// break ;
25059: GO 25063
// end ;
25061: GO 25035
25063: POP
25064: POP
// if e and not UnitGoingToBuilding ( p , e ) then
25065: LD_VAR 0 7
25069: PUSH
25070: LD_VAR 0 5
25074: PPUSH
25075: LD_VAR 0 7
25079: PPUSH
25080: CALL 92178 0 2
25084: NOT
25085: AND
25086: IFFALSE 25145
// begin if IsInUnit ( p ) then
25088: LD_VAR 0 5
25092: PPUSH
25093: CALL_OW 310
25097: IFFALSE 25108
// ComExitBuilding ( p ) ;
25099: LD_VAR 0 5
25103: PPUSH
25104: CALL_OW 122
// ComEnterUnit ( p , e ) ;
25108: LD_VAR 0 5
25112: PPUSH
25113: LD_VAR 0 7
25117: PPUSH
25118: CALL_OW 120
// AddComChangeProfession ( p , j ) ;
25122: LD_VAR 0 5
25126: PPUSH
25127: LD_VAR 0 3
25131: PPUSH
25132: CALL_OW 183
// AddComExitBuilding ( p ) ;
25136: LD_VAR 0 5
25140: PPUSH
25141: CALL_OW 182
// end ; end ;
25145: GO 24993
25147: POP
25148: POP
// end ;
25149: GO 24959
25151: POP
25152: POP
// end ;
25153: GO 24714
25155: POP
25156: POP
// end ;
25157: LD_VAR 0 1
25161: RET
// export function MC_ClassCheckReq ( base ) ; var i , tmp , sol , eng , mech , sci , sort , j , p , b , bcount ; begin
25162: LD_INT 0
25164: PPUSH
25165: PPUSH
25166: PPUSH
25167: PPUSH
25168: PPUSH
25169: PPUSH
25170: PPUSH
25171: PPUSH
25172: PPUSH
25173: PPUSH
25174: PPUSH
25175: PPUSH
// if not base or not mc_bases [ base ] or not UnitFilter ( mc_bases [ base ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) then
25176: LD_VAR 0 1
25180: NOT
25181: PUSH
25182: LD_EXP 79
25186: PUSH
25187: LD_VAR 0 1
25191: ARRAY
25192: NOT
25193: OR
25194: PUSH
25195: LD_EXP 79
25199: PUSH
25200: LD_VAR 0 1
25204: ARRAY
25205: PPUSH
25206: LD_INT 2
25208: PUSH
25209: LD_INT 30
25211: PUSH
25212: LD_INT 0
25214: PUSH
25215: EMPTY
25216: LIST
25217: LIST
25218: PUSH
25219: LD_INT 30
25221: PUSH
25222: LD_INT 1
25224: PUSH
25225: EMPTY
25226: LIST
25227: LIST
25228: PUSH
25229: EMPTY
25230: LIST
25231: LIST
25232: LIST
25233: PPUSH
25234: CALL_OW 72
25238: NOT
25239: OR
25240: IFFALSE 25244
// exit ;
25242: GO 28747
// tmp := UnitFilter ( mc_bases [ base ] , [ f_or , [ f_class , 1 ] , [ f_class , 2 ] , [ f_class , 3 ] , [ f_class , 4 ] , [ f_class , 5 ] , [ f_class , 8 ] , [ f_class , 9 ] ] ) ;
25244: LD_ADDR_VAR 0 4
25248: PUSH
25249: LD_EXP 79
25253: PUSH
25254: LD_VAR 0 1
25258: ARRAY
25259: PPUSH
25260: LD_INT 2
25262: PUSH
25263: LD_INT 25
25265: PUSH
25266: LD_INT 1
25268: PUSH
25269: EMPTY
25270: LIST
25271: LIST
25272: PUSH
25273: LD_INT 25
25275: PUSH
25276: LD_INT 2
25278: PUSH
25279: EMPTY
25280: LIST
25281: LIST
25282: PUSH
25283: LD_INT 25
25285: PUSH
25286: LD_INT 3
25288: PUSH
25289: EMPTY
25290: LIST
25291: LIST
25292: PUSH
25293: LD_INT 25
25295: PUSH
25296: LD_INT 4
25298: PUSH
25299: EMPTY
25300: LIST
25301: LIST
25302: PUSH
25303: LD_INT 25
25305: PUSH
25306: LD_INT 5
25308: PUSH
25309: EMPTY
25310: LIST
25311: LIST
25312: PUSH
25313: LD_INT 25
25315: PUSH
25316: LD_INT 8
25318: PUSH
25319: EMPTY
25320: LIST
25321: LIST
25322: PUSH
25323: LD_INT 25
25325: PUSH
25326: LD_INT 9
25328: PUSH
25329: EMPTY
25330: LIST
25331: LIST
25332: PUSH
25333: EMPTY
25334: LIST
25335: LIST
25336: LIST
25337: LIST
25338: LIST
25339: LIST
25340: LIST
25341: LIST
25342: PPUSH
25343: CALL_OW 72
25347: ST_TO_ADDR
// if not tmp then
25348: LD_VAR 0 4
25352: NOT
25353: IFFALSE 25357
// exit ;
25355: GO 28747
// for i in tmp do
25357: LD_ADDR_VAR 0 3
25361: PUSH
25362: LD_VAR 0 4
25366: PUSH
25367: FOR_IN
25368: IFFALSE 25399
// if GetTag ( i ) then
25370: LD_VAR 0 3
25374: PPUSH
25375: CALL_OW 110
25379: IFFALSE 25397
// tmp := tmp diff i ;
25381: LD_ADDR_VAR 0 4
25385: PUSH
25386: LD_VAR 0 4
25390: PUSH
25391: LD_VAR 0 3
25395: DIFF
25396: ST_TO_ADDR
25397: GO 25367
25399: POP
25400: POP
// if not tmp then
25401: LD_VAR 0 4
25405: NOT
25406: IFFALSE 25410
// exit ;
25408: GO 28747
// sol := UnitFilter ( mc_bases [ base ] , [ f_or , [ f_class , 1 ] , [ f_class , 5 ] , [ f_class , 8 ] , [ f_class , 9 ] ] ) ;
25410: LD_ADDR_VAR 0 5
25414: PUSH
25415: LD_EXP 79
25419: PUSH
25420: LD_VAR 0 1
25424: ARRAY
25425: PPUSH
25426: LD_INT 2
25428: PUSH
25429: LD_INT 25
25431: PUSH
25432: LD_INT 1
25434: PUSH
25435: EMPTY
25436: LIST
25437: LIST
25438: PUSH
25439: LD_INT 25
25441: PUSH
25442: LD_INT 5
25444: PUSH
25445: EMPTY
25446: LIST
25447: LIST
25448: PUSH
25449: LD_INT 25
25451: PUSH
25452: LD_INT 8
25454: PUSH
25455: EMPTY
25456: LIST
25457: LIST
25458: PUSH
25459: LD_INT 25
25461: PUSH
25462: LD_INT 9
25464: PUSH
25465: EMPTY
25466: LIST
25467: LIST
25468: PUSH
25469: EMPTY
25470: LIST
25471: LIST
25472: LIST
25473: LIST
25474: LIST
25475: PPUSH
25476: CALL_OW 72
25480: ST_TO_ADDR
// eng := UnitFilter ( mc_bases [ base ] , [ f_class , 2 ] ) ;
25481: LD_ADDR_VAR 0 6
25485: PUSH
25486: LD_EXP 79
25490: PUSH
25491: LD_VAR 0 1
25495: ARRAY
25496: PPUSH
25497: LD_INT 25
25499: PUSH
25500: LD_INT 2
25502: PUSH
25503: EMPTY
25504: LIST
25505: LIST
25506: PPUSH
25507: CALL_OW 72
25511: ST_TO_ADDR
// mech := UnitFilter ( mc_bases [ base ] , [ f_class , 3 ] ) ;
25512: LD_ADDR_VAR 0 7
25516: PUSH
25517: LD_EXP 79
25521: PUSH
25522: LD_VAR 0 1
25526: ARRAY
25527: PPUSH
25528: LD_INT 25
25530: PUSH
25531: LD_INT 3
25533: PUSH
25534: EMPTY
25535: LIST
25536: LIST
25537: PPUSH
25538: CALL_OW 72
25542: ST_TO_ADDR
// sci := UnitFilter ( mc_bases [ base ] , [ [ f_class , 4 ] , [ f_lives , 251 ] ] ) ;
25543: LD_ADDR_VAR 0 8
25547: PUSH
25548: LD_EXP 79
25552: PUSH
25553: LD_VAR 0 1
25557: ARRAY
25558: PPUSH
25559: LD_INT 25
25561: PUSH
25562: LD_INT 4
25564: PUSH
25565: EMPTY
25566: LIST
25567: LIST
25568: PUSH
25569: LD_INT 24
25571: PUSH
25572: LD_INT 251
25574: PUSH
25575: EMPTY
25576: LIST
25577: LIST
25578: PUSH
25579: EMPTY
25580: LIST
25581: LIST
25582: PPUSH
25583: CALL_OW 72
25587: ST_TO_ADDR
// if mc_scan [ base ] then
25588: LD_EXP 102
25592: PUSH
25593: LD_VAR 0 1
25597: ARRAY
25598: IFFALSE 26059
// begin mc_class_case_use := Replace ( mc_class_case_use , base , 4 ) ;
25600: LD_ADDR_EXP 121
25604: PUSH
25605: LD_EXP 121
25609: PPUSH
25610: LD_VAR 0 1
25614: PPUSH
25615: LD_INT 4
25617: PPUSH
25618: CALL_OW 1
25622: ST_TO_ADDR
// b := UnitFilter ( mc_bases [ base ] , [ f_or , [ f_btype , b_armoury ] , [ f_btype , b_barracks ] ] ) ;
25623: LD_ADDR_VAR 0 12
25627: PUSH
25628: LD_EXP 79
25632: PUSH
25633: LD_VAR 0 1
25637: ARRAY
25638: PPUSH
25639: LD_INT 2
25641: PUSH
25642: LD_INT 30
25644: PUSH
25645: LD_INT 4
25647: PUSH
25648: EMPTY
25649: LIST
25650: LIST
25651: PUSH
25652: LD_INT 30
25654: PUSH
25655: LD_INT 5
25657: PUSH
25658: EMPTY
25659: LIST
25660: LIST
25661: PUSH
25662: EMPTY
25663: LIST
25664: LIST
25665: LIST
25666: PPUSH
25667: CALL_OW 72
25671: ST_TO_ADDR
// if not b then
25672: LD_VAR 0 12
25676: NOT
25677: IFFALSE 25681
// exit ;
25679: GO 28747
// p := [ ] ;
25681: LD_ADDR_VAR 0 11
25685: PUSH
25686: EMPTY
25687: ST_TO_ADDR
// if sci >= 2 then
25688: LD_VAR 0 8
25692: PUSH
25693: LD_INT 2
25695: GREATEREQUAL
25696: IFFALSE 25727
// sci := [ sci [ 1 ] , sci [ 2 ] ] else
25698: LD_ADDR_VAR 0 8
25702: PUSH
25703: LD_VAR 0 8
25707: PUSH
25708: LD_INT 1
25710: ARRAY
25711: PUSH
25712: LD_VAR 0 8
25716: PUSH
25717: LD_INT 2
25719: ARRAY
25720: PUSH
25721: EMPTY
25722: LIST
25723: LIST
25724: ST_TO_ADDR
25725: GO 25788
// if sci = 1 then
25727: LD_VAR 0 8
25731: PUSH
25732: LD_INT 1
25734: EQUAL
25735: IFFALSE 25756
// sci := [ sci [ 1 ] ] else
25737: LD_ADDR_VAR 0 8
25741: PUSH
25742: LD_VAR 0 8
25746: PUSH
25747: LD_INT 1
25749: ARRAY
25750: PUSH
25751: EMPTY
25752: LIST
25753: ST_TO_ADDR
25754: GO 25788
// if sci = 0 then
25756: LD_VAR 0 8
25760: PUSH
25761: LD_INT 0
25763: EQUAL
25764: IFFALSE 25788
// p := SortBySkill ( tmp , 4 ) [ 1 ] ;
25766: LD_ADDR_VAR 0 11
25770: PUSH
25771: LD_VAR 0 4
25775: PPUSH
25776: LD_INT 4
25778: PPUSH
25779: CALL 92041 0 2
25783: PUSH
25784: LD_INT 1
25786: ARRAY
25787: ST_TO_ADDR
// if eng > 4 then
25788: LD_VAR 0 6
25792: PUSH
25793: LD_INT 4
25795: GREATER
25796: IFFALSE 25842
// for i = eng downto 4 do
25798: LD_ADDR_VAR 0 3
25802: PUSH
25803: DOUBLE
25804: LD_VAR 0 6
25808: INC
25809: ST_TO_ADDR
25810: LD_INT 4
25812: PUSH
25813: FOR_DOWNTO
25814: IFFALSE 25840
// eng := eng diff eng [ i ] ;
25816: LD_ADDR_VAR 0 6
25820: PUSH
25821: LD_VAR 0 6
25825: PUSH
25826: LD_VAR 0 6
25830: PUSH
25831: LD_VAR 0 3
25835: ARRAY
25836: DIFF
25837: ST_TO_ADDR
25838: GO 25813
25840: POP
25841: POP
// tmp := tmp diff ( sol union eng union mech union sci ) ;
25842: LD_ADDR_VAR 0 4
25846: PUSH
25847: LD_VAR 0 4
25851: PUSH
25852: LD_VAR 0 5
25856: PUSH
25857: LD_VAR 0 6
25861: UNION
25862: PUSH
25863: LD_VAR 0 7
25867: UNION
25868: PUSH
25869: LD_VAR 0 8
25873: UNION
25874: DIFF
25875: ST_TO_ADDR
// bcount := UnitFilter ( mc_bases [ base ] , [ f_or , [ f_btype , b_bunker ] , [ f_btype , b_breastwork ] ] ) + UnitFilter ( mc_bases [ base ] , [ f_or , [ f_btype , b_armoury ] , [ f_btype , b_barracks ] ] ) * 6 ;
25876: LD_ADDR_VAR 0 13
25880: PUSH
25881: LD_EXP 79
25885: PUSH
25886: LD_VAR 0 1
25890: ARRAY
25891: PPUSH
25892: LD_INT 2
25894: PUSH
25895: LD_INT 30
25897: PUSH
25898: LD_INT 32
25900: PUSH
25901: EMPTY
25902: LIST
25903: LIST
25904: PUSH
25905: LD_INT 30
25907: PUSH
25908: LD_INT 31
25910: PUSH
25911: EMPTY
25912: LIST
25913: LIST
25914: PUSH
25915: EMPTY
25916: LIST
25917: LIST
25918: LIST
25919: PPUSH
25920: CALL_OW 72
25924: PUSH
25925: LD_EXP 79
25929: PUSH
25930: LD_VAR 0 1
25934: ARRAY
25935: PPUSH
25936: LD_INT 2
25938: PUSH
25939: LD_INT 30
25941: PUSH
25942: LD_INT 4
25944: PUSH
25945: EMPTY
25946: LIST
25947: LIST
25948: PUSH
25949: LD_INT 30
25951: PUSH
25952: LD_INT 5
25954: PUSH
25955: EMPTY
25956: LIST
25957: LIST
25958: PUSH
25959: EMPTY
25960: LIST
25961: LIST
25962: LIST
25963: PPUSH
25964: CALL_OW 72
25968: PUSH
25969: LD_INT 6
25971: MUL
25972: PLUS
25973: ST_TO_ADDR
// if bcount < tmp then
25974: LD_VAR 0 13
25978: PUSH
25979: LD_VAR 0 4
25983: LESS
25984: IFFALSE 26030
// for i = tmp downto bcount do
25986: LD_ADDR_VAR 0 3
25990: PUSH
25991: DOUBLE
25992: LD_VAR 0 4
25996: INC
25997: ST_TO_ADDR
25998: LD_VAR 0 13
26002: PUSH
26003: FOR_DOWNTO
26004: IFFALSE 26028
// tmp := Delete ( tmp , tmp ) ;
26006: LD_ADDR_VAR 0 4
26010: PUSH
26011: LD_VAR 0 4
26015: PPUSH
26016: LD_VAR 0 4
26020: PPUSH
26021: CALL_OW 3
26025: ST_TO_ADDR
26026: GO 26003
26028: POP
26029: POP
// result := [ tmp , 0 , 0 , p ] ;
26030: LD_ADDR_VAR 0 2
26034: PUSH
26035: LD_VAR 0 4
26039: PUSH
26040: LD_INT 0
26042: PUSH
26043: LD_INT 0
26045: PUSH
26046: LD_VAR 0 11
26050: PUSH
26051: EMPTY
26052: LIST
26053: LIST
26054: LIST
26055: LIST
26056: ST_TO_ADDR
// exit ;
26057: GO 28747
// end ; if not UnitFilter ( mc_bases [ base ] , [ f_or , [ f_btype , b_lab ] , [ f_btype , b_lab_half ] , [ f_btype , b_lab_full ] ] ) and not UnitFilter ( mc_bases [ base ] , [ f_btype , b_factory ] ) then
26059: LD_EXP 79
26063: PUSH
26064: LD_VAR 0 1
26068: ARRAY
26069: PPUSH
26070: LD_INT 2
26072: PUSH
26073: LD_INT 30
26075: PUSH
26076: LD_INT 6
26078: PUSH
26079: EMPTY
26080: LIST
26081: LIST
26082: PUSH
26083: LD_INT 30
26085: PUSH
26086: LD_INT 7
26088: PUSH
26089: EMPTY
26090: LIST
26091: LIST
26092: PUSH
26093: LD_INT 30
26095: PUSH
26096: LD_INT 8
26098: PUSH
26099: EMPTY
26100: LIST
26101: LIST
26102: PUSH
26103: EMPTY
26104: LIST
26105: LIST
26106: LIST
26107: LIST
26108: PPUSH
26109: CALL_OW 72
26113: NOT
26114: PUSH
26115: LD_EXP 79
26119: PUSH
26120: LD_VAR 0 1
26124: ARRAY
26125: PPUSH
26126: LD_INT 30
26128: PUSH
26129: LD_INT 3
26131: PUSH
26132: EMPTY
26133: LIST
26134: LIST
26135: PPUSH
26136: CALL_OW 72
26140: NOT
26141: AND
26142: IFFALSE 26214
// begin if eng = tmp then
26144: LD_VAR 0 6
26148: PUSH
26149: LD_VAR 0 4
26153: EQUAL
26154: IFFALSE 26158
// exit ;
26156: GO 28747
// mc_class_case_use := Replace ( mc_class_case_use , base , 1 ) ;
26158: LD_ADDR_EXP 121
26162: PUSH
26163: LD_EXP 121
26167: PPUSH
26168: LD_VAR 0 1
26172: PPUSH
26173: LD_INT 1
26175: PPUSH
26176: CALL_OW 1
26180: ST_TO_ADDR
// result := [ 0 , tmp diff eng , 0 , 0 ] ;
26181: LD_ADDR_VAR 0 2
26185: PUSH
26186: LD_INT 0
26188: PUSH
26189: LD_VAR 0 4
26193: PUSH
26194: LD_VAR 0 6
26198: DIFF
26199: PUSH
26200: LD_INT 0
26202: PUSH
26203: LD_INT 0
26205: PUSH
26206: EMPTY
26207: LIST
26208: LIST
26209: LIST
26210: LIST
26211: ST_TO_ADDR
// exit ;
26212: GO 28747
// end ; if mc_tech [ mc_sides [ base ] ] and UnitFilter ( mc_bases [ base ] , [ f_or , [ f_btype , b_lab ] , [ f_btype , b_lab_half ] , [ f_btype , b_lab_full ] ] ) and not UnitFilter ( mc_bases [ base ] , [ f_btype , b_factory ] ) then
26214: LD_EXP 106
26218: PUSH
26219: LD_EXP 105
26223: PUSH
26224: LD_VAR 0 1
26228: ARRAY
26229: ARRAY
26230: PUSH
26231: LD_EXP 79
26235: PUSH
26236: LD_VAR 0 1
26240: ARRAY
26241: PPUSH
26242: LD_INT 2
26244: PUSH
26245: LD_INT 30
26247: PUSH
26248: LD_INT 6
26250: PUSH
26251: EMPTY
26252: LIST
26253: LIST
26254: PUSH
26255: LD_INT 30
26257: PUSH
26258: LD_INT 7
26260: PUSH
26261: EMPTY
26262: LIST
26263: LIST
26264: PUSH
26265: LD_INT 30
26267: PUSH
26268: LD_INT 8
26270: PUSH
26271: EMPTY
26272: LIST
26273: LIST
26274: PUSH
26275: EMPTY
26276: LIST
26277: LIST
26278: LIST
26279: LIST
26280: PPUSH
26281: CALL_OW 72
26285: AND
26286: PUSH
26287: LD_EXP 79
26291: PUSH
26292: LD_VAR 0 1
26296: ARRAY
26297: PPUSH
26298: LD_INT 30
26300: PUSH
26301: LD_INT 3
26303: PUSH
26304: EMPTY
26305: LIST
26306: LIST
26307: PPUSH
26308: CALL_OW 72
26312: NOT
26313: AND
26314: IFFALSE 26528
// begin if sci >= 6 then
26316: LD_VAR 0 8
26320: PUSH
26321: LD_INT 6
26323: GREATEREQUAL
26324: IFFALSE 26328
// exit ;
26326: GO 28747
// mc_class_case_use := Replace ( mc_class_case_use , base , 2 ) ;
26328: LD_ADDR_EXP 121
26332: PUSH
26333: LD_EXP 121
26337: PPUSH
26338: LD_VAR 0 1
26342: PPUSH
26343: LD_INT 2
26345: PPUSH
26346: CALL_OW 1
26350: ST_TO_ADDR
// sort := SortBySkill ( tmp diff sci , 4 ) ;
26351: LD_ADDR_VAR 0 9
26355: PUSH
26356: LD_VAR 0 4
26360: PUSH
26361: LD_VAR 0 8
26365: DIFF
26366: PPUSH
26367: LD_INT 4
26369: PPUSH
26370: CALL 92041 0 2
26374: ST_TO_ADDR
// p := [ ] ;
26375: LD_ADDR_VAR 0 11
26379: PUSH
26380: EMPTY
26381: ST_TO_ADDR
// if sci < 6 and sort > 6 then
26382: LD_VAR 0 8
26386: PUSH
26387: LD_INT 6
26389: LESS
26390: PUSH
26391: LD_VAR 0 9
26395: PUSH
26396: LD_INT 6
26398: GREATER
26399: AND
26400: IFFALSE 26481
// begin for i = 1 to 6 - sci do
26402: LD_ADDR_VAR 0 3
26406: PUSH
26407: DOUBLE
26408: LD_INT 1
26410: DEC
26411: ST_TO_ADDR
26412: LD_INT 6
26414: PUSH
26415: LD_VAR 0 8
26419: MINUS
26420: PUSH
26421: FOR_TO
26422: IFFALSE 26477
// begin p := Insert ( p , p + 1 , sort [ 1 ] ) ;
26424: LD_ADDR_VAR 0 11
26428: PUSH
26429: LD_VAR 0 11
26433: PPUSH
26434: LD_VAR 0 11
26438: PUSH
26439: LD_INT 1
26441: PLUS
26442: PPUSH
26443: LD_VAR 0 9
26447: PUSH
26448: LD_INT 1
26450: ARRAY
26451: PPUSH
26452: CALL_OW 2
26456: ST_TO_ADDR
// sort := Delete ( sort , 1 ) ;
26457: LD_ADDR_VAR 0 9
26461: PUSH
26462: LD_VAR 0 9
26466: PPUSH
26467: LD_INT 1
26469: PPUSH
26470: CALL_OW 3
26474: ST_TO_ADDR
// end ;
26475: GO 26421
26477: POP
26478: POP
// end else
26479: GO 26501
// if sort then
26481: LD_VAR 0 9
26485: IFFALSE 26501
// p := sort [ 1 ] ;
26487: LD_ADDR_VAR 0 11
26491: PUSH
26492: LD_VAR 0 9
26496: PUSH
26497: LD_INT 1
26499: ARRAY
26500: ST_TO_ADDR
// result := [ 0 , 0 , 0 , p ] ;
26501: LD_ADDR_VAR 0 2
26505: PUSH
26506: LD_INT 0
26508: PUSH
26509: LD_INT 0
26511: PUSH
26512: LD_INT 0
26514: PUSH
26515: LD_VAR 0 11
26519: PUSH
26520: EMPTY
26521: LIST
26522: LIST
26523: LIST
26524: LIST
26525: ST_TO_ADDR
// exit ;
26526: GO 28747
// end ; if mc_tech [ mc_sides [ base ] ] and UnitFilter ( mc_bases [ base ] , [ f_or , [ f_btype , b_lab ] , [ f_btype , b_lab_half ] , [ f_btype , b_lab_full ] ] ) and UnitFilter ( mc_bases [ base ] , [ f_btype , b_factory ] ) then
26528: LD_EXP 106
26532: PUSH
26533: LD_EXP 105
26537: PUSH
26538: LD_VAR 0 1
26542: ARRAY
26543: ARRAY
26544: PUSH
26545: LD_EXP 79
26549: PUSH
26550: LD_VAR 0 1
26554: ARRAY
26555: PPUSH
26556: LD_INT 2
26558: PUSH
26559: LD_INT 30
26561: PUSH
26562: LD_INT 6
26564: PUSH
26565: EMPTY
26566: LIST
26567: LIST
26568: PUSH
26569: LD_INT 30
26571: PUSH
26572: LD_INT 7
26574: PUSH
26575: EMPTY
26576: LIST
26577: LIST
26578: PUSH
26579: LD_INT 30
26581: PUSH
26582: LD_INT 8
26584: PUSH
26585: EMPTY
26586: LIST
26587: LIST
26588: PUSH
26589: EMPTY
26590: LIST
26591: LIST
26592: LIST
26593: LIST
26594: PPUSH
26595: CALL_OW 72
26599: AND
26600: PUSH
26601: LD_EXP 79
26605: PUSH
26606: LD_VAR 0 1
26610: ARRAY
26611: PPUSH
26612: LD_INT 30
26614: PUSH
26615: LD_INT 3
26617: PUSH
26618: EMPTY
26619: LIST
26620: LIST
26621: PPUSH
26622: CALL_OW 72
26626: AND
26627: IFFALSE 27361
// begin mc_class_case_use := Replace ( mc_class_case_use , base , 3 ) ;
26629: LD_ADDR_EXP 121
26633: PUSH
26634: LD_EXP 121
26638: PPUSH
26639: LD_VAR 0 1
26643: PPUSH
26644: LD_INT 3
26646: PPUSH
26647: CALL_OW 1
26651: ST_TO_ADDR
// result := [ 0 , 0 , 0 , 0 ] ;
26652: LD_ADDR_VAR 0 2
26656: PUSH
26657: LD_INT 0
26659: PUSH
26660: LD_INT 0
26662: PUSH
26663: LD_INT 0
26665: PUSH
26666: LD_INT 0
26668: PUSH
26669: EMPTY
26670: LIST
26671: LIST
26672: LIST
26673: LIST
26674: ST_TO_ADDR
// if not eng then
26675: LD_VAR 0 6
26679: NOT
26680: IFFALSE 26743
// begin p := SortBySkill ( tmp , 2 ) [ 1 ] ;
26682: LD_ADDR_VAR 0 11
26686: PUSH
26687: LD_VAR 0 4
26691: PPUSH
26692: LD_INT 2
26694: PPUSH
26695: CALL 92041 0 2
26699: PUSH
26700: LD_INT 1
26702: ARRAY
26703: ST_TO_ADDR
// result := Replace ( result , 2 , p ) ;
26704: LD_ADDR_VAR 0 2
26708: PUSH
26709: LD_VAR 0 2
26713: PPUSH
26714: LD_INT 2
26716: PPUSH
26717: LD_VAR 0 11
26721: PPUSH
26722: CALL_OW 1
26726: ST_TO_ADDR
// tmp := tmp diff p ;
26727: LD_ADDR_VAR 0 4
26731: PUSH
26732: LD_VAR 0 4
26736: PUSH
26737: LD_VAR 0 11
26741: DIFF
26742: ST_TO_ADDR
// end ; if tmp and sci < 6 then
26743: LD_VAR 0 4
26747: PUSH
26748: LD_VAR 0 8
26752: PUSH
26753: LD_INT 6
26755: LESS
26756: AND
26757: IFFALSE 26945
// begin sort := SortBySkill ( tmp diff ( sci union mech ) , 4 ) ;
26759: LD_ADDR_VAR 0 9
26763: PUSH
26764: LD_VAR 0 4
26768: PUSH
26769: LD_VAR 0 8
26773: PUSH
26774: LD_VAR 0 7
26778: UNION
26779: DIFF
26780: PPUSH
26781: LD_INT 4
26783: PPUSH
26784: CALL 92041 0 2
26788: ST_TO_ADDR
// p := [ ] ;
26789: LD_ADDR_VAR 0 11
26793: PUSH
26794: EMPTY
26795: ST_TO_ADDR
// if sort then
26796: LD_VAR 0 9
26800: IFFALSE 26916
// for i = 1 to 6 - sci do
26802: LD_ADDR_VAR 0 3
26806: PUSH
26807: DOUBLE
26808: LD_INT 1
26810: DEC
26811: ST_TO_ADDR
26812: LD_INT 6
26814: PUSH
26815: LD_VAR 0 8
26819: MINUS
26820: PUSH
26821: FOR_TO
26822: IFFALSE 26914
// begin if i = sort then
26824: LD_VAR 0 3
26828: PUSH
26829: LD_VAR 0 9
26833: EQUAL
26834: IFFALSE 26838
// break ;
26836: GO 26914
// if GetClass ( i ) = 4 then
26838: LD_VAR 0 3
26842: PPUSH
26843: CALL_OW 257
26847: PUSH
26848: LD_INT 4
26850: EQUAL
26851: IFFALSE 26855
// continue ;
26853: GO 26821
// p := Insert ( p , p + 1 , sort [ i ] ) ;
26855: LD_ADDR_VAR 0 11
26859: PUSH
26860: LD_VAR 0 11
26864: PPUSH
26865: LD_VAR 0 11
26869: PUSH
26870: LD_INT 1
26872: PLUS
26873: PPUSH
26874: LD_VAR 0 9
26878: PUSH
26879: LD_VAR 0 3
26883: ARRAY
26884: PPUSH
26885: CALL_OW 2
26889: ST_TO_ADDR
// tmp := tmp diff sort [ i ] ;
26890: LD_ADDR_VAR 0 4
26894: PUSH
26895: LD_VAR 0 4
26899: PUSH
26900: LD_VAR 0 9
26904: PUSH
26905: LD_VAR 0 3
26909: ARRAY
26910: DIFF
26911: ST_TO_ADDR
// end ;
26912: GO 26821
26914: POP
26915: POP
// if p then
26916: LD_VAR 0 11
26920: IFFALSE 26945
// result := Replace ( result , 4 , p ) ;
26922: LD_ADDR_VAR 0 2
26926: PUSH
26927: LD_VAR 0 2
26931: PPUSH
26932: LD_INT 4
26934: PPUSH
26935: LD_VAR 0 11
26939: PPUSH
26940: CALL_OW 1
26944: ST_TO_ADDR
// end ; if tmp and mech < 6 then
26945: LD_VAR 0 4
26949: PUSH
26950: LD_VAR 0 7
26954: PUSH
26955: LD_INT 6
26957: LESS
26958: AND
26959: IFFALSE 27147
// begin sort := SortBySkill ( tmp diff ( sci union mech ) , 3 ) ;
26961: LD_ADDR_VAR 0 9
26965: PUSH
26966: LD_VAR 0 4
26970: PUSH
26971: LD_VAR 0 8
26975: PUSH
26976: LD_VAR 0 7
26980: UNION
26981: DIFF
26982: PPUSH
26983: LD_INT 3
26985: PPUSH
26986: CALL 92041 0 2
26990: ST_TO_ADDR
// p := [ ] ;
26991: LD_ADDR_VAR 0 11
26995: PUSH
26996: EMPTY
26997: ST_TO_ADDR
// if sort then
26998: LD_VAR 0 9
27002: IFFALSE 27118
// for i = 1 to 6 - mech do
27004: LD_ADDR_VAR 0 3
27008: PUSH
27009: DOUBLE
27010: LD_INT 1
27012: DEC
27013: ST_TO_ADDR
27014: LD_INT 6
27016: PUSH
27017: LD_VAR 0 7
27021: MINUS
27022: PUSH
27023: FOR_TO
27024: IFFALSE 27116
// begin if i = sort then
27026: LD_VAR 0 3
27030: PUSH
27031: LD_VAR 0 9
27035: EQUAL
27036: IFFALSE 27040
// break ;
27038: GO 27116
// if GetClass ( i ) = 3 then
27040: LD_VAR 0 3
27044: PPUSH
27045: CALL_OW 257
27049: PUSH
27050: LD_INT 3
27052: EQUAL
27053: IFFALSE 27057
// continue ;
27055: GO 27023
// p := Insert ( p , p + 1 , sort [ i ] ) ;
27057: LD_ADDR_VAR 0 11
27061: PUSH
27062: LD_VAR 0 11
27066: PPUSH
27067: LD_VAR 0 11
27071: PUSH
27072: LD_INT 1
27074: PLUS
27075: PPUSH
27076: LD_VAR 0 9
27080: PUSH
27081: LD_VAR 0 3
27085: ARRAY
27086: PPUSH
27087: CALL_OW 2
27091: ST_TO_ADDR
// tmp := tmp diff sort [ i ] ;
27092: LD_ADDR_VAR 0 4
27096: PUSH
27097: LD_VAR 0 4
27101: PUSH
27102: LD_VAR 0 9
27106: PUSH
27107: LD_VAR 0 3
27111: ARRAY
27112: DIFF
27113: ST_TO_ADDR
// end ;
27114: GO 27023
27116: POP
27117: POP
// if p then
27118: LD_VAR 0 11
27122: IFFALSE 27147
// result := Replace ( result , 3 , p ) ;
27124: LD_ADDR_VAR 0 2
27128: PUSH
27129: LD_VAR 0 2
27133: PPUSH
27134: LD_INT 3
27136: PPUSH
27137: LD_VAR 0 11
27141: PPUSH
27142: CALL_OW 1
27146: ST_TO_ADDR
// end ; if tmp > 6 and eng < 6 then
27147: LD_VAR 0 4
27151: PUSH
27152: LD_INT 6
27154: GREATER
27155: PUSH
27156: LD_VAR 0 6
27160: PUSH
27161: LD_INT 6
27163: LESS
27164: AND
27165: IFFALSE 27359
// begin sort := SortBySkill ( tmp diff ( sci union mech union eng ) , 2 ) ;
27167: LD_ADDR_VAR 0 9
27171: PUSH
27172: LD_VAR 0 4
27176: PUSH
27177: LD_VAR 0 8
27181: PUSH
27182: LD_VAR 0 7
27186: UNION
27187: PUSH
27188: LD_VAR 0 6
27192: UNION
27193: DIFF
27194: PPUSH
27195: LD_INT 2
27197: PPUSH
27198: CALL 92041 0 2
27202: ST_TO_ADDR
// p := [ ] ;
27203: LD_ADDR_VAR 0 11
27207: PUSH
27208: EMPTY
27209: ST_TO_ADDR
// if sort then
27210: LD_VAR 0 9
27214: IFFALSE 27330
// for i = 1 to 6 - eng do
27216: LD_ADDR_VAR 0 3
27220: PUSH
27221: DOUBLE
27222: LD_INT 1
27224: DEC
27225: ST_TO_ADDR
27226: LD_INT 6
27228: PUSH
27229: LD_VAR 0 6
27233: MINUS
27234: PUSH
27235: FOR_TO
27236: IFFALSE 27328
// begin if i = sort then
27238: LD_VAR 0 3
27242: PUSH
27243: LD_VAR 0 9
27247: EQUAL
27248: IFFALSE 27252
// break ;
27250: GO 27328
// if GetClass ( i ) = 2 then
27252: LD_VAR 0 3
27256: PPUSH
27257: CALL_OW 257
27261: PUSH
27262: LD_INT 2
27264: EQUAL
27265: IFFALSE 27269
// continue ;
27267: GO 27235
// p := Insert ( p , p + 1 , sort [ i ] ) ;
27269: LD_ADDR_VAR 0 11
27273: PUSH
27274: LD_VAR 0 11
27278: PPUSH
27279: LD_VAR 0 11
27283: PUSH
27284: LD_INT 1
27286: PLUS
27287: PPUSH
27288: LD_VAR 0 9
27292: PUSH
27293: LD_VAR 0 3
27297: ARRAY
27298: PPUSH
27299: CALL_OW 2
27303: ST_TO_ADDR
// tmp := tmp diff sort [ i ] ;
27304: LD_ADDR_VAR 0 4
27308: PUSH
27309: LD_VAR 0 4
27313: PUSH
27314: LD_VAR 0 9
27318: PUSH
27319: LD_VAR 0 3
27323: ARRAY
27324: DIFF
27325: ST_TO_ADDR
// end ;
27326: GO 27235
27328: POP
27329: POP
// if p then
27330: LD_VAR 0 11
27334: IFFALSE 27359
// result := Replace ( result , 2 , p ) ;
27336: LD_ADDR_VAR 0 2
27340: PUSH
27341: LD_VAR 0 2
27345: PPUSH
27346: LD_INT 2
27348: PPUSH
27349: LD_VAR 0 11
27353: PPUSH
27354: CALL_OW 1
27358: ST_TO_ADDR
// end ; exit ;
27359: GO 28747
// end ; if not mc_tech [ mc_sides [ base ] ] and UnitFilter ( mc_bases [ base ] , [ f_btype , b_factory ] ) and mc_build_list [ base ] then
27361: LD_EXP 106
27365: PUSH
27366: LD_EXP 105
27370: PUSH
27371: LD_VAR 0 1
27375: ARRAY
27376: ARRAY
27377: NOT
27378: PUSH
27379: LD_EXP 79
27383: PUSH
27384: LD_VAR 0 1
27388: ARRAY
27389: PPUSH
27390: LD_INT 30
27392: PUSH
27393: LD_INT 3
27395: PUSH
27396: EMPTY
27397: LIST
27398: LIST
27399: PPUSH
27400: CALL_OW 72
27404: AND
27405: PUSH
27406: LD_EXP 84
27410: PUSH
27411: LD_VAR 0 1
27415: ARRAY
27416: AND
27417: IFFALSE 28025
// begin mc_class_case_use := Replace ( mc_class_case_use , base , 5 ) ;
27419: LD_ADDR_EXP 121
27423: PUSH
27424: LD_EXP 121
27428: PPUSH
27429: LD_VAR 0 1
27433: PPUSH
27434: LD_INT 5
27436: PPUSH
27437: CALL_OW 1
27441: ST_TO_ADDR
// result := [ 0 , 0 , 0 , 0 ] ;
27442: LD_ADDR_VAR 0 2
27446: PUSH
27447: LD_INT 0
27449: PUSH
27450: LD_INT 0
27452: PUSH
27453: LD_INT 0
27455: PUSH
27456: LD_INT 0
27458: PUSH
27459: EMPTY
27460: LIST
27461: LIST
27462: LIST
27463: LIST
27464: ST_TO_ADDR
// if sci > 1 then
27465: LD_VAR 0 8
27469: PUSH
27470: LD_INT 1
27472: GREATER
27473: IFFALSE 27501
// tmp := tmp diff ( sci diff sci [ 1 ] ) ;
27475: LD_ADDR_VAR 0 4
27479: PUSH
27480: LD_VAR 0 4
27484: PUSH
27485: LD_VAR 0 8
27489: PUSH
27490: LD_VAR 0 8
27494: PUSH
27495: LD_INT 1
27497: ARRAY
27498: DIFF
27499: DIFF
27500: ST_TO_ADDR
// if tmp and not sci then
27501: LD_VAR 0 4
27505: PUSH
27506: LD_VAR 0 8
27510: NOT
27511: AND
27512: IFFALSE 27581
// begin sort := SortBySkill ( tmp , 4 ) ;
27514: LD_ADDR_VAR 0 9
27518: PUSH
27519: LD_VAR 0 4
27523: PPUSH
27524: LD_INT 4
27526: PPUSH
27527: CALL 92041 0 2
27531: ST_TO_ADDR
// if sort then
27532: LD_VAR 0 9
27536: IFFALSE 27552
// p := sort [ 1 ] ;
27538: LD_ADDR_VAR 0 11
27542: PUSH
27543: LD_VAR 0 9
27547: PUSH
27548: LD_INT 1
27550: ARRAY
27551: ST_TO_ADDR
// if p then
27552: LD_VAR 0 11
27556: IFFALSE 27581
// result := Replace ( result , 4 , p ) ;
27558: LD_ADDR_VAR 0 2
27562: PUSH
27563: LD_VAR 0 2
27567: PPUSH
27568: LD_INT 4
27570: PPUSH
27571: LD_VAR 0 11
27575: PPUSH
27576: CALL_OW 1
27580: ST_TO_ADDR
// end ; tmp := tmp diff mech ;
27581: LD_ADDR_VAR 0 4
27585: PUSH
27586: LD_VAR 0 4
27590: PUSH
27591: LD_VAR 0 7
27595: DIFF
27596: ST_TO_ADDR
// if tmp and mech < 6 then
27597: LD_VAR 0 4
27601: PUSH
27602: LD_VAR 0 7
27606: PUSH
27607: LD_INT 6
27609: LESS
27610: AND
27611: IFFALSE 27799
// begin sort := SortBySkill ( tmp diff ( sci union mech ) , 3 ) ;
27613: LD_ADDR_VAR 0 9
27617: PUSH
27618: LD_VAR 0 4
27622: PUSH
27623: LD_VAR 0 8
27627: PUSH
27628: LD_VAR 0 7
27632: UNION
27633: DIFF
27634: PPUSH
27635: LD_INT 3
27637: PPUSH
27638: CALL 92041 0 2
27642: ST_TO_ADDR
// p := [ ] ;
27643: LD_ADDR_VAR 0 11
27647: PUSH
27648: EMPTY
27649: ST_TO_ADDR
// if sort then
27650: LD_VAR 0 9
27654: IFFALSE 27770
// for i = 1 to 6 - mech do
27656: LD_ADDR_VAR 0 3
27660: PUSH
27661: DOUBLE
27662: LD_INT 1
27664: DEC
27665: ST_TO_ADDR
27666: LD_INT 6
27668: PUSH
27669: LD_VAR 0 7
27673: MINUS
27674: PUSH
27675: FOR_TO
27676: IFFALSE 27768
// begin if i = sort then
27678: LD_VAR 0 3
27682: PUSH
27683: LD_VAR 0 9
27687: EQUAL
27688: IFFALSE 27692
// break ;
27690: GO 27768
// if GetClass ( i ) = 3 then
27692: LD_VAR 0 3
27696: PPUSH
27697: CALL_OW 257
27701: PUSH
27702: LD_INT 3
27704: EQUAL
27705: IFFALSE 27709
// continue ;
27707: GO 27675
// p := Insert ( p , p + 1 , sort [ i ] ) ;
27709: LD_ADDR_VAR 0 11
27713: PUSH
27714: LD_VAR 0 11
27718: PPUSH
27719: LD_VAR 0 11
27723: PUSH
27724: LD_INT 1
27726: PLUS
27727: PPUSH
27728: LD_VAR 0 9
27732: PUSH
27733: LD_VAR 0 3
27737: ARRAY
27738: PPUSH
27739: CALL_OW 2
27743: ST_TO_ADDR
// tmp := tmp diff sort [ i ] ;
27744: LD_ADDR_VAR 0 4
27748: PUSH
27749: LD_VAR 0 4
27753: PUSH
27754: LD_VAR 0 9
27758: PUSH
27759: LD_VAR 0 3
27763: ARRAY
27764: DIFF
27765: ST_TO_ADDR
// end ;
27766: GO 27675
27768: POP
27769: POP
// if p then
27770: LD_VAR 0 11
27774: IFFALSE 27799
// result := Replace ( result , 3 , p ) ;
27776: LD_ADDR_VAR 0 2
27780: PUSH
27781: LD_VAR 0 2
27785: PPUSH
27786: LD_INT 3
27788: PPUSH
27789: LD_VAR 0 11
27793: PPUSH
27794: CALL_OW 1
27798: ST_TO_ADDR
// end ; tmp := tmp diff eng ;
27799: LD_ADDR_VAR 0 4
27803: PUSH
27804: LD_VAR 0 4
27808: PUSH
27809: LD_VAR 0 6
27813: DIFF
27814: ST_TO_ADDR
// if tmp and eng < 6 then
27815: LD_VAR 0 4
27819: PUSH
27820: LD_VAR 0 6
27824: PUSH
27825: LD_INT 6
27827: LESS
27828: AND
27829: IFFALSE 28023
// begin sort := SortBySkill ( tmp diff ( sci union mech union eng ) , 2 ) ;
27831: LD_ADDR_VAR 0 9
27835: PUSH
27836: LD_VAR 0 4
27840: PUSH
27841: LD_VAR 0 8
27845: PUSH
27846: LD_VAR 0 7
27850: UNION
27851: PUSH
27852: LD_VAR 0 6
27856: UNION
27857: DIFF
27858: PPUSH
27859: LD_INT 2
27861: PPUSH
27862: CALL 92041 0 2
27866: ST_TO_ADDR
// p := [ ] ;
27867: LD_ADDR_VAR 0 11
27871: PUSH
27872: EMPTY
27873: ST_TO_ADDR
// if sort then
27874: LD_VAR 0 9
27878: IFFALSE 27994
// for i = 1 to 6 - eng do
27880: LD_ADDR_VAR 0 3
27884: PUSH
27885: DOUBLE
27886: LD_INT 1
27888: DEC
27889: ST_TO_ADDR
27890: LD_INT 6
27892: PUSH
27893: LD_VAR 0 6
27897: MINUS
27898: PUSH
27899: FOR_TO
27900: IFFALSE 27992
// begin if i = sort then
27902: LD_VAR 0 3
27906: PUSH
27907: LD_VAR 0 9
27911: EQUAL
27912: IFFALSE 27916
// break ;
27914: GO 27992
// if GetClass ( i ) = 2 then
27916: LD_VAR 0 3
27920: PPUSH
27921: CALL_OW 257
27925: PUSH
27926: LD_INT 2
27928: EQUAL
27929: IFFALSE 27933
// continue ;
27931: GO 27899
// p := Insert ( p , p + 1 , sort [ i ] ) ;
27933: LD_ADDR_VAR 0 11
27937: PUSH
27938: LD_VAR 0 11
27942: PPUSH
27943: LD_VAR 0 11
27947: PUSH
27948: LD_INT 1
27950: PLUS
27951: PPUSH
27952: LD_VAR 0 9
27956: PUSH
27957: LD_VAR 0 3
27961: ARRAY
27962: PPUSH
27963: CALL_OW 2
27967: ST_TO_ADDR
// tmp := tmp diff sort [ i ] ;
27968: LD_ADDR_VAR 0 4
27972: PUSH
27973: LD_VAR 0 4
27977: PUSH
27978: LD_VAR 0 9
27982: PUSH
27983: LD_VAR 0 3
27987: ARRAY
27988: DIFF
27989: ST_TO_ADDR
// end ;
27990: GO 27899
27992: POP
27993: POP
// if p then
27994: LD_VAR 0 11
27998: IFFALSE 28023
// result := Replace ( result , 2 , p ) ;
28000: LD_ADDR_VAR 0 2
28004: PUSH
28005: LD_VAR 0 2
28009: PPUSH
28010: LD_INT 2
28012: PPUSH
28013: LD_VAR 0 11
28017: PPUSH
28018: CALL_OW 1
28022: ST_TO_ADDR
// end ; exit ;
28023: GO 28747
// end ; if not mc_tech [ mc_sides [ base ] ] and UnitFilter ( mc_bases [ base ] , [ f_btype , b_factory ] ) and not mc_build_list [ base ] then
28025: LD_EXP 106
28029: PUSH
28030: LD_EXP 105
28034: PUSH
28035: LD_VAR 0 1
28039: ARRAY
28040: ARRAY
28041: NOT
28042: PUSH
28043: LD_EXP 79
28047: PUSH
28048: LD_VAR 0 1
28052: ARRAY
28053: PPUSH
28054: LD_INT 30
28056: PUSH
28057: LD_INT 3
28059: PUSH
28060: EMPTY
28061: LIST
28062: LIST
28063: PPUSH
28064: CALL_OW 72
28068: AND
28069: PUSH
28070: LD_EXP 84
28074: PUSH
28075: LD_VAR 0 1
28079: ARRAY
28080: NOT
28081: AND
28082: IFFALSE 28747
// begin mc_class_case_use := Replace ( mc_class_case_use , base , 6 ) ;
28084: LD_ADDR_EXP 121
28088: PUSH
28089: LD_EXP 121
28093: PPUSH
28094: LD_VAR 0 1
28098: PPUSH
28099: LD_INT 6
28101: PPUSH
28102: CALL_OW 1
28106: ST_TO_ADDR
// result := [ 0 , 0 , 0 , 0 ] ;
28107: LD_ADDR_VAR 0 2
28111: PUSH
28112: LD_INT 0
28114: PUSH
28115: LD_INT 0
28117: PUSH
28118: LD_INT 0
28120: PUSH
28121: LD_INT 0
28123: PUSH
28124: EMPTY
28125: LIST
28126: LIST
28127: LIST
28128: LIST
28129: ST_TO_ADDR
// if sci >= 1 then
28130: LD_VAR 0 8
28134: PUSH
28135: LD_INT 1
28137: GREATEREQUAL
28138: IFFALSE 28160
// tmp := tmp diff sci [ 1 ] ;
28140: LD_ADDR_VAR 0 4
28144: PUSH
28145: LD_VAR 0 4
28149: PUSH
28150: LD_VAR 0 8
28154: PUSH
28155: LD_INT 1
28157: ARRAY
28158: DIFF
28159: ST_TO_ADDR
// if tmp and not sci then
28160: LD_VAR 0 4
28164: PUSH
28165: LD_VAR 0 8
28169: NOT
28170: AND
28171: IFFALSE 28240
// begin sort := SortBySkill ( tmp , 4 ) ;
28173: LD_ADDR_VAR 0 9
28177: PUSH
28178: LD_VAR 0 4
28182: PPUSH
28183: LD_INT 4
28185: PPUSH
28186: CALL 92041 0 2
28190: ST_TO_ADDR
// if sort then
28191: LD_VAR 0 9
28195: IFFALSE 28211
// p := sort [ 1 ] ;
28197: LD_ADDR_VAR 0 11
28201: PUSH
28202: LD_VAR 0 9
28206: PUSH
28207: LD_INT 1
28209: ARRAY
28210: ST_TO_ADDR
// if p then
28211: LD_VAR 0 11
28215: IFFALSE 28240
// result := Replace ( result , 4 , p ) ;
28217: LD_ADDR_VAR 0 2
28221: PUSH
28222: LD_VAR 0 2
28226: PPUSH
28227: LD_INT 4
28229: PPUSH
28230: LD_VAR 0 11
28234: PPUSH
28235: CALL_OW 1
28239: ST_TO_ADDR
// end ; tmp := tmp diff mech ;
28240: LD_ADDR_VAR 0 4
28244: PUSH
28245: LD_VAR 0 4
28249: PUSH
28250: LD_VAR 0 7
28254: DIFF
28255: ST_TO_ADDR
// if tmp and mech < 6 then
28256: LD_VAR 0 4
28260: PUSH
28261: LD_VAR 0 7
28265: PUSH
28266: LD_INT 6
28268: LESS
28269: AND
28270: IFFALSE 28452
// begin sort := SortBySkill ( tmp diff mech , 3 ) ;
28272: LD_ADDR_VAR 0 9
28276: PUSH
28277: LD_VAR 0 4
28281: PUSH
28282: LD_VAR 0 7
28286: DIFF
28287: PPUSH
28288: LD_INT 3
28290: PPUSH
28291: CALL 92041 0 2
28295: ST_TO_ADDR
// p := [ ] ;
28296: LD_ADDR_VAR 0 11
28300: PUSH
28301: EMPTY
28302: ST_TO_ADDR
// if sort then
28303: LD_VAR 0 9
28307: IFFALSE 28423
// for i = 1 to 6 - mech do
28309: LD_ADDR_VAR 0 3
28313: PUSH
28314: DOUBLE
28315: LD_INT 1
28317: DEC
28318: ST_TO_ADDR
28319: LD_INT 6
28321: PUSH
28322: LD_VAR 0 7
28326: MINUS
28327: PUSH
28328: FOR_TO
28329: IFFALSE 28421
// begin if i = sort then
28331: LD_VAR 0 3
28335: PUSH
28336: LD_VAR 0 9
28340: EQUAL
28341: IFFALSE 28345
// break ;
28343: GO 28421
// if GetClass ( i ) = 3 then
28345: LD_VAR 0 3
28349: PPUSH
28350: CALL_OW 257
28354: PUSH
28355: LD_INT 3
28357: EQUAL
28358: IFFALSE 28362
// continue ;
28360: GO 28328
// p := Insert ( p , p + 1 , sort [ i ] ) ;
28362: LD_ADDR_VAR 0 11
28366: PUSH
28367: LD_VAR 0 11
28371: PPUSH
28372: LD_VAR 0 11
28376: PUSH
28377: LD_INT 1
28379: PLUS
28380: PPUSH
28381: LD_VAR 0 9
28385: PUSH
28386: LD_VAR 0 3
28390: ARRAY
28391: PPUSH
28392: CALL_OW 2
28396: ST_TO_ADDR
// tmp := tmp diff sort [ i ] ;
28397: LD_ADDR_VAR 0 4
28401: PUSH
28402: LD_VAR 0 4
28406: PUSH
28407: LD_VAR 0 9
28411: PUSH
28412: LD_VAR 0 3
28416: ARRAY
28417: DIFF
28418: ST_TO_ADDR
// end ;
28419: GO 28328
28421: POP
28422: POP
// if p then
28423: LD_VAR 0 11
28427: IFFALSE 28452
// result := Replace ( result , 3 , p ) ;
28429: LD_ADDR_VAR 0 2
28433: PUSH
28434: LD_VAR 0 2
28438: PPUSH
28439: LD_INT 3
28441: PPUSH
28442: LD_VAR 0 11
28446: PPUSH
28447: CALL_OW 1
28451: ST_TO_ADDR
// end ; tmp := tmp diff eng ;
28452: LD_ADDR_VAR 0 4
28456: PUSH
28457: LD_VAR 0 4
28461: PUSH
28462: LD_VAR 0 6
28466: DIFF
28467: ST_TO_ADDR
// if tmp and eng < 4 then
28468: LD_VAR 0 4
28472: PUSH
28473: LD_VAR 0 6
28477: PUSH
28478: LD_INT 4
28480: LESS
28481: AND
28482: IFFALSE 28672
// begin sort := SortBySkill ( tmp diff ( mech union eng ) , 2 ) ;
28484: LD_ADDR_VAR 0 9
28488: PUSH
28489: LD_VAR 0 4
28493: PUSH
28494: LD_VAR 0 7
28498: PUSH
28499: LD_VAR 0 6
28503: UNION
28504: DIFF
28505: PPUSH
28506: LD_INT 2
28508: PPUSH
28509: CALL 92041 0 2
28513: ST_TO_ADDR
// p := [ ] ;
28514: LD_ADDR_VAR 0 11
28518: PUSH
28519: EMPTY
28520: ST_TO_ADDR
// if sort then
28521: LD_VAR 0 9
28525: IFFALSE 28641
// for i = 1 to 4 - eng do
28527: LD_ADDR_VAR 0 3
28531: PUSH
28532: DOUBLE
28533: LD_INT 1
28535: DEC
28536: ST_TO_ADDR
28537: LD_INT 4
28539: PUSH
28540: LD_VAR 0 6
28544: MINUS
28545: PUSH
28546: FOR_TO
28547: IFFALSE 28639
// begin if i = sort then
28549: LD_VAR 0 3
28553: PUSH
28554: LD_VAR 0 9
28558: EQUAL
28559: IFFALSE 28563
// break ;
28561: GO 28639
// if GetClass ( i ) = 2 then
28563: LD_VAR 0 3
28567: PPUSH
28568: CALL_OW 257
28572: PUSH
28573: LD_INT 2
28575: EQUAL
28576: IFFALSE 28580
// continue ;
28578: GO 28546
// p := Insert ( p , p + 1 , sort [ i ] ) ;
28580: LD_ADDR_VAR 0 11
28584: PUSH
28585: LD_VAR 0 11
28589: PPUSH
28590: LD_VAR 0 11
28594: PUSH
28595: LD_INT 1
28597: PLUS
28598: PPUSH
28599: LD_VAR 0 9
28603: PUSH
28604: LD_VAR 0 3
28608: ARRAY
28609: PPUSH
28610: CALL_OW 2
28614: ST_TO_ADDR
// tmp := tmp diff sort [ i ] ;
28615: LD_ADDR_VAR 0 4
28619: PUSH
28620: LD_VAR 0 4
28624: PUSH
28625: LD_VAR 0 9
28629: PUSH
28630: LD_VAR 0 3
28634: ARRAY
28635: DIFF
28636: ST_TO_ADDR
// end ;
28637: GO 28546
28639: POP
28640: POP
// if p then
28641: LD_VAR 0 11
28645: IFFALSE 28670
// result := Replace ( result , 2 , p ) ;
28647: LD_ADDR_VAR 0 2
28651: PUSH
28652: LD_VAR 0 2
28656: PPUSH
28657: LD_INT 2
28659: PPUSH
28660: LD_VAR 0 11
28664: PPUSH
28665: CALL_OW 1
28669: ST_TO_ADDR
// end else
28670: GO 28716
// for i = eng downto 5 do
28672: LD_ADDR_VAR 0 3
28676: PUSH
28677: DOUBLE
28678: LD_VAR 0 6
28682: INC
28683: ST_TO_ADDR
28684: LD_INT 5
28686: PUSH
28687: FOR_DOWNTO
28688: IFFALSE 28714
// tmp := tmp union eng [ i ] ;
28690: LD_ADDR_VAR 0 4
28694: PUSH
28695: LD_VAR 0 4
28699: PUSH
28700: LD_VAR 0 6
28704: PUSH
28705: LD_VAR 0 3
28709: ARRAY
28710: UNION
28711: ST_TO_ADDR
28712: GO 28687
28714: POP
28715: POP
// result := Replace ( result , 1 , tmp diff sol ) ;
28716: LD_ADDR_VAR 0 2
28720: PUSH
28721: LD_VAR 0 2
28725: PPUSH
28726: LD_INT 1
28728: PPUSH
28729: LD_VAR 0 4
28733: PUSH
28734: LD_VAR 0 5
28738: DIFF
28739: PPUSH
28740: CALL_OW 1
28744: ST_TO_ADDR
// exit ;
28745: GO 28747
// end ; end ;
28747: LD_VAR 0 2
28751: RET
// export function MC_CheckBuildings ( ) ; var i , tmp ; begin
28752: LD_INT 0
28754: PPUSH
28755: PPUSH
28756: PPUSH
// if not mc_bases then
28757: LD_EXP 79
28761: NOT
28762: IFFALSE 28766
// exit ;
28764: GO 28872
// for i = 1 to mc_bases do
28766: LD_ADDR_VAR 0 2
28770: PUSH
28771: DOUBLE
28772: LD_INT 1
28774: DEC
28775: ST_TO_ADDR
28776: LD_EXP 79
28780: PUSH
28781: FOR_TO
28782: IFFALSE 28863
// begin tmp := UnitFilter ( mc_bases [ i ] , [ [ f_type , unit_building ] , [ f_not , [ f_lives , 1000 ] ] ] ) ;
28784: LD_ADDR_VAR 0 3
28788: PUSH
28789: LD_EXP 79
28793: PUSH
28794: LD_VAR 0 2
28798: ARRAY
28799: PPUSH
28800: LD_INT 21
28802: PUSH
28803: LD_INT 3
28805: PUSH
28806: EMPTY
28807: LIST
28808: LIST
28809: PUSH
28810: LD_INT 3
28812: PUSH
28813: LD_INT 24
28815: PUSH
28816: LD_INT 1000
28818: PUSH
28819: EMPTY
28820: LIST
28821: LIST
28822: PUSH
28823: EMPTY
28824: LIST
28825: LIST
28826: PUSH
28827: EMPTY
28828: LIST
28829: LIST
28830: PPUSH
28831: CALL_OW 72
28835: ST_TO_ADDR
// mc_building_need_repair := Replace ( mc_building_need_repair , i , tmp ) ;
28836: LD_ADDR_EXP 80
28840: PUSH
28841: LD_EXP 80
28845: PPUSH
28846: LD_VAR 0 2
28850: PPUSH
28851: LD_VAR 0 3
28855: PPUSH
28856: CALL_OW 1
28860: ST_TO_ADDR
// end ;
28861: GO 28781
28863: POP
28864: POP
// RaiseSailEvent ( 101 ) ;
28865: LD_INT 101
28867: PPUSH
28868: CALL_OW 427
// end ;
28872: LD_VAR 0 1
28876: RET
// export function MC_CheckPeopleLife ( ) ; var i , j , k , tmp , need_heal_1 , need_heal_2 ; begin
28877: LD_INT 0
28879: PPUSH
28880: PPUSH
28881: PPUSH
28882: PPUSH
28883: PPUSH
28884: PPUSH
28885: PPUSH
// if not mc_bases then
28886: LD_EXP 79
28890: NOT
28891: IFFALSE 28895
// exit ;
28893: GO 29468
// for i = 1 to mc_bases do
28895: LD_ADDR_VAR 0 2
28899: PUSH
28900: DOUBLE
28901: LD_INT 1
28903: DEC
28904: ST_TO_ADDR
28905: LD_EXP 79
28909: PUSH
28910: FOR_TO
28911: IFFALSE 29459
// begin tmp := UnitFilter ( mc_bases [ i ] union mc_ape [ i ] , [ [ f_type , unit_human ] , [ f_and , [ f_not , [ f_inside ] ] , [ f_not , [ f_lives , 800 ] ] ] ] ) ;
28913: LD_ADDR_VAR 0 5
28917: PUSH
28918: LD_EXP 79
28922: PUSH
28923: LD_VAR 0 2
28927: ARRAY
28928: PUSH
28929: LD_EXP 108
28933: PUSH
28934: LD_VAR 0 2
28938: ARRAY
28939: UNION
28940: PPUSH
28941: LD_INT 21
28943: PUSH
28944: LD_INT 1
28946: PUSH
28947: EMPTY
28948: LIST
28949: LIST
28950: PUSH
28951: LD_INT 1
28953: PUSH
28954: LD_INT 3
28956: PUSH
28957: LD_INT 54
28959: PUSH
28960: EMPTY
28961: LIST
28962: PUSH
28963: EMPTY
28964: LIST
28965: LIST
28966: PUSH
28967: LD_INT 3
28969: PUSH
28970: LD_INT 24
28972: PUSH
28973: LD_INT 800
28975: PUSH
28976: EMPTY
28977: LIST
28978: LIST
28979: PUSH
28980: EMPTY
28981: LIST
28982: LIST
28983: PUSH
28984: EMPTY
28985: LIST
28986: LIST
28987: LIST
28988: PUSH
28989: EMPTY
28990: LIST
28991: LIST
28992: PPUSH
28993: CALL_OW 72
28997: ST_TO_ADDR
// need_heal_1 := UnitFilter ( mc_bases [ i ] , [ [ f_type , unit_human ] , [ f_and , [ f_not , [ f_inside ] ] , [ f_not , [ f_lives , 250 ] ] ] ] ) ;
28998: LD_ADDR_VAR 0 6
29002: PUSH
29003: LD_EXP 79
29007: PUSH
29008: LD_VAR 0 2
29012: ARRAY
29013: PPUSH
29014: LD_INT 21
29016: PUSH
29017: LD_INT 1
29019: PUSH
29020: EMPTY
29021: LIST
29022: LIST
29023: PUSH
29024: LD_INT 1
29026: PUSH
29027: LD_INT 3
29029: PUSH
29030: LD_INT 54
29032: PUSH
29033: EMPTY
29034: LIST
29035: PUSH
29036: EMPTY
29037: LIST
29038: LIST
29039: PUSH
29040: LD_INT 3
29042: PUSH
29043: LD_INT 24
29045: PUSH
29046: LD_INT 250
29048: PUSH
29049: EMPTY
29050: LIST
29051: LIST
29052: PUSH
29053: EMPTY
29054: LIST
29055: LIST
29056: PUSH
29057: EMPTY
29058: LIST
29059: LIST
29060: LIST
29061: PUSH
29062: EMPTY
29063: LIST
29064: LIST
29065: PPUSH
29066: CALL_OW 72
29070: ST_TO_ADDR
// need_heal_2 := tmp diff need_heal_1 ;
29071: LD_ADDR_VAR 0 7
29075: PUSH
29076: LD_VAR 0 5
29080: PUSH
29081: LD_VAR 0 6
29085: DIFF
29086: ST_TO_ADDR
// if not need_heal_1 then
29087: LD_VAR 0 6
29091: NOT
29092: IFFALSE 29125
// mc_need_heal := ReplaceIn ( mc_need_heal , [ i , 1 ] , [ ] ) else
29094: LD_ADDR_EXP 82
29098: PUSH
29099: LD_EXP 82
29103: PPUSH
29104: LD_VAR 0 2
29108: PUSH
29109: LD_INT 1
29111: PUSH
29112: EMPTY
29113: LIST
29114: LIST
29115: PPUSH
29116: EMPTY
29117: PPUSH
29118: CALL 57783 0 3
29122: ST_TO_ADDR
29123: GO 29195
// mc_need_heal := ReplaceIn ( mc_need_heal , [ i , 1 ] , UnitFilter ( mc_need_heal [ i ] [ 1 ] , [ f_not , [ f_lives , 1000 ] ] ) union need_heal_1 ) ;
29125: LD_ADDR_EXP 82
29129: PUSH
29130: LD_EXP 82
29134: PPUSH
29135: LD_VAR 0 2
29139: PUSH
29140: LD_INT 1
29142: PUSH
29143: EMPTY
29144: LIST
29145: LIST
29146: PPUSH
29147: LD_EXP 82
29151: PUSH
29152: LD_VAR 0 2
29156: ARRAY
29157: PUSH
29158: LD_INT 1
29160: ARRAY
29161: PPUSH
29162: LD_INT 3
29164: PUSH
29165: LD_INT 24
29167: PUSH
29168: LD_INT 1000
29170: PUSH
29171: EMPTY
29172: LIST
29173: LIST
29174: PUSH
29175: EMPTY
29176: LIST
29177: LIST
29178: PPUSH
29179: CALL_OW 72
29183: PUSH
29184: LD_VAR 0 6
29188: UNION
29189: PPUSH
29190: CALL 57783 0 3
29194: ST_TO_ADDR
// if not need_heal_2 then
29195: LD_VAR 0 7
29199: NOT
29200: IFFALSE 29233
// mc_need_heal := ReplaceIn ( mc_need_heal , [ i , 2 ] , [ ] ) else
29202: LD_ADDR_EXP 82
29206: PUSH
29207: LD_EXP 82
29211: PPUSH
29212: LD_VAR 0 2
29216: PUSH
29217: LD_INT 2
29219: PUSH
29220: EMPTY
29221: LIST
29222: LIST
29223: PPUSH
29224: EMPTY
29225: PPUSH
29226: CALL 57783 0 3
29230: ST_TO_ADDR
29231: GO 29265
// mc_need_heal := ReplaceIn ( mc_need_heal , [ i , 2 ] , need_heal_2 ) ;
29233: LD_ADDR_EXP 82
29237: PUSH
29238: LD_EXP 82
29242: PPUSH
29243: LD_VAR 0 2
29247: PUSH
29248: LD_INT 2
29250: PUSH
29251: EMPTY
29252: LIST
29253: LIST
29254: PPUSH
29255: LD_VAR 0 7
29259: PPUSH
29260: CALL 57783 0 3
29264: ST_TO_ADDR
// if need_heal_2 then
29265: LD_VAR 0 7
29269: IFFALSE 29441
// for j in need_heal_2 do
29271: LD_ADDR_VAR 0 3
29275: PUSH
29276: LD_VAR 0 7
29280: PUSH
29281: FOR_IN
29282: IFFALSE 29439
// begin tmp := UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_lab ] , [ f_btype , b_lab_half ] , [ f_btype , b_lab_full ] , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] , [ f_class , 4 ] ] ) ;
29284: LD_ADDR_VAR 0 5
29288: PUSH
29289: LD_EXP 79
29293: PUSH
29294: LD_VAR 0 2
29298: ARRAY
29299: PPUSH
29300: LD_INT 2
29302: PUSH
29303: LD_INT 30
29305: PUSH
29306: LD_INT 6
29308: PUSH
29309: EMPTY
29310: LIST
29311: LIST
29312: PUSH
29313: LD_INT 30
29315: PUSH
29316: LD_INT 7
29318: PUSH
29319: EMPTY
29320: LIST
29321: LIST
29322: PUSH
29323: LD_INT 30
29325: PUSH
29326: LD_INT 8
29328: PUSH
29329: EMPTY
29330: LIST
29331: LIST
29332: PUSH
29333: LD_INT 30
29335: PUSH
29336: LD_INT 0
29338: PUSH
29339: EMPTY
29340: LIST
29341: LIST
29342: PUSH
29343: LD_INT 30
29345: PUSH
29346: LD_INT 1
29348: PUSH
29349: EMPTY
29350: LIST
29351: LIST
29352: PUSH
29353: LD_INT 25
29355: PUSH
29356: LD_INT 4
29358: PUSH
29359: EMPTY
29360: LIST
29361: LIST
29362: PUSH
29363: EMPTY
29364: LIST
29365: LIST
29366: LIST
29367: LIST
29368: LIST
29369: LIST
29370: LIST
29371: PPUSH
29372: CALL_OW 72
29376: ST_TO_ADDR
// if tmp then
29377: LD_VAR 0 5
29381: IFFALSE 29437
// begin k := NearestUnitToUnit ( tmp , j ) ;
29383: LD_ADDR_VAR 0 4
29387: PUSH
29388: LD_VAR 0 5
29392: PPUSH
29393: LD_VAR 0 3
29397: PPUSH
29398: CALL_OW 74
29402: ST_TO_ADDR
// if GetDistUnits ( j , k ) > 7 then
29403: LD_VAR 0 3
29407: PPUSH
29408: LD_VAR 0 4
29412: PPUSH
29413: CALL_OW 296
29417: PUSH
29418: LD_INT 7
29420: GREATER
29421: IFFALSE 29437
// ComMoveUnit ( j , k ) ;
29423: LD_VAR 0 3
29427: PPUSH
29428: LD_VAR 0 4
29432: PPUSH
29433: CALL_OW 112
// end ; end ;
29437: GO 29281
29439: POP
29440: POP
// if not need_heal_1 and not need_heal_2 then
29441: LD_VAR 0 6
29445: NOT
29446: PUSH
29447: LD_VAR 0 7
29451: NOT
29452: AND
29453: IFFALSE 29457
// continue ;
29455: GO 28910
// end ;
29457: GO 28910
29459: POP
29460: POP
// RaiseSailEvent ( 102 ) ;
29461: LD_INT 102
29463: PPUSH
29464: CALL_OW 427
// end ;
29468: LD_VAR 0 1
29472: RET
// export function MC_RepairBuildings ( ) ; var i , j , un , tmp , cranes , to_repair_tmp , to_repair ; begin
29473: LD_INT 0
29475: PPUSH
29476: PPUSH
29477: PPUSH
29478: PPUSH
29479: PPUSH
29480: PPUSH
29481: PPUSH
29482: PPUSH
// if not mc_bases then
29483: LD_EXP 79
29487: NOT
29488: IFFALSE 29492
// exit ;
29490: GO 30332
// for i = 1 to mc_bases do
29492: LD_ADDR_VAR 0 2
29496: PUSH
29497: DOUBLE
29498: LD_INT 1
29500: DEC
29501: ST_TO_ADDR
29502: LD_EXP 79
29506: PUSH
29507: FOR_TO
29508: IFFALSE 30330
// begin if not mc_building_need_repair [ i ] then
29510: LD_EXP 80
29514: PUSH
29515: LD_VAR 0 2
29519: ARRAY
29520: NOT
29521: IFFALSE 29695
// begin cranes := UnitFilter ( mc_vehicles [ i ] , [ [ f_not , [ f_lives , 1000 ] ] , [ f_or , [ f_weapon , us_crane ] , [ f_weapon , ru_crane ] ] ] ) ;
29523: LD_ADDR_VAR 0 6
29527: PUSH
29528: LD_EXP 98
29532: PUSH
29533: LD_VAR 0 2
29537: ARRAY
29538: PPUSH
29539: LD_INT 3
29541: PUSH
29542: LD_INT 24
29544: PUSH
29545: LD_INT 1000
29547: PUSH
29548: EMPTY
29549: LIST
29550: LIST
29551: PUSH
29552: EMPTY
29553: LIST
29554: LIST
29555: PUSH
29556: LD_INT 2
29558: PUSH
29559: LD_INT 34
29561: PUSH
29562: LD_INT 13
29564: PUSH
29565: EMPTY
29566: LIST
29567: LIST
29568: PUSH
29569: LD_INT 34
29571: PUSH
29572: LD_INT 52
29574: PUSH
29575: EMPTY
29576: LIST
29577: LIST
29578: PUSH
29579: EMPTY
29580: LIST
29581: LIST
29582: LIST
29583: PUSH
29584: EMPTY
29585: LIST
29586: LIST
29587: PPUSH
29588: CALL_OW 72
29592: ST_TO_ADDR
// if cranes then
29593: LD_VAR 0 6
29597: IFFALSE 29659
// for j in cranes do
29599: LD_ADDR_VAR 0 3
29603: PUSH
29604: LD_VAR 0 6
29608: PUSH
29609: FOR_IN
29610: IFFALSE 29657
// if not IsInArea ( j , mc_parking [ i ] ) then
29612: LD_VAR 0 3
29616: PPUSH
29617: LD_EXP 103
29621: PUSH
29622: LD_VAR 0 2
29626: ARRAY
29627: PPUSH
29628: CALL_OW 308
29632: NOT
29633: IFFALSE 29655
// ComMoveToArea ( j , mc_parking [ i ] ) ;
29635: LD_VAR 0 3
29639: PPUSH
29640: LD_EXP 103
29644: PUSH
29645: LD_VAR 0 2
29649: ARRAY
29650: PPUSH
29651: CALL_OW 113
29655: GO 29609
29657: POP
29658: POP
// mc_building_repairs := Replace ( mc_building_repairs , i , [ ] ) ;
29659: LD_ADDR_EXP 81
29663: PUSH
29664: LD_EXP 81
29668: PPUSH
29669: LD_VAR 0 2
29673: PPUSH
29674: EMPTY
29675: PPUSH
29676: CALL_OW 1
29680: ST_TO_ADDR
// MC_Reset ( i , 101 ) ;
29681: LD_VAR 0 2
29685: PPUSH
29686: LD_INT 101
29688: PPUSH
29689: CALL 24585 0 2
// continue ;
29693: GO 29507
// end ; mc_builders := Replace ( mc_builders , i , [ ] ) ;
29695: LD_ADDR_EXP 85
29699: PUSH
29700: LD_EXP 85
29704: PPUSH
29705: LD_VAR 0 2
29709: PPUSH
29710: EMPTY
29711: PPUSH
29712: CALL_OW 1
29716: ST_TO_ADDR
// MC_Reset ( i , 103 ) ;
29717: LD_VAR 0 2
29721: PPUSH
29722: LD_INT 103
29724: PPUSH
29725: CALL 24585 0 2
// tmp := UnitFilter ( mc_bases [ i ] union mc_ape [ i ] , [ [ f_or , [ f_class , 2 ] , [ f_class , 16 ] ] ] ) ;
29729: LD_ADDR_VAR 0 5
29733: PUSH
29734: LD_EXP 79
29738: PUSH
29739: LD_VAR 0 2
29743: ARRAY
29744: PUSH
29745: LD_EXP 108
29749: PUSH
29750: LD_VAR 0 2
29754: ARRAY
29755: UNION
29756: PPUSH
29757: LD_INT 2
29759: PUSH
29760: LD_INT 25
29762: PUSH
29763: LD_INT 2
29765: PUSH
29766: EMPTY
29767: LIST
29768: LIST
29769: PUSH
29770: LD_INT 25
29772: PUSH
29773: LD_INT 16
29775: PUSH
29776: EMPTY
29777: LIST
29778: LIST
29779: PUSH
29780: EMPTY
29781: LIST
29782: LIST
29783: LIST
29784: PUSH
29785: EMPTY
29786: LIST
29787: PPUSH
29788: CALL_OW 72
29792: ST_TO_ADDR
// cranes := UnitFilter ( mc_vehicles [ i ] , [ f_or , [ f_weapon , us_crane ] , [ f_weapon , ru_crane ] ] ) ;
29793: LD_ADDR_VAR 0 6
29797: PUSH
29798: LD_EXP 98
29802: PUSH
29803: LD_VAR 0 2
29807: ARRAY
29808: PPUSH
29809: LD_INT 2
29811: PUSH
29812: LD_INT 34
29814: PUSH
29815: LD_INT 13
29817: PUSH
29818: EMPTY
29819: LIST
29820: LIST
29821: PUSH
29822: LD_INT 34
29824: PUSH
29825: LD_INT 52
29827: PUSH
29828: EMPTY
29829: LIST
29830: LIST
29831: PUSH
29832: EMPTY
29833: LIST
29834: LIST
29835: LIST
29836: PPUSH
29837: CALL_OW 72
29841: ST_TO_ADDR
// if cranes then
29842: LD_VAR 0 6
29846: IFFALSE 29982
// begin for j in cranes do
29848: LD_ADDR_VAR 0 3
29852: PUSH
29853: LD_VAR 0 6
29857: PUSH
29858: FOR_IN
29859: IFFALSE 29980
// if GetLives ( j ) >= 500 and not HasTask ( j ) then
29861: LD_VAR 0 3
29865: PPUSH
29866: CALL_OW 256
29870: PUSH
29871: LD_INT 500
29873: GREATEREQUAL
29874: PUSH
29875: LD_VAR 0 3
29879: PPUSH
29880: CALL_OW 314
29884: NOT
29885: AND
29886: IFFALSE 29920
// ComRepairBuilding ( j , NearestUnitToUnit ( mc_building_need_repair [ i ] , j ) ) else
29888: LD_VAR 0 3
29892: PPUSH
29893: LD_EXP 80
29897: PUSH
29898: LD_VAR 0 2
29902: ARRAY
29903: PPUSH
29904: LD_VAR 0 3
29908: PPUSH
29909: CALL_OW 74
29913: PPUSH
29914: CALL_OW 130
29918: GO 29978
// if GetLives ( j ) < 500 and not IsInArea ( j , mc_parking [ i ] ) then
29920: LD_VAR 0 3
29924: PPUSH
29925: CALL_OW 256
29929: PUSH
29930: LD_INT 500
29932: LESS
29933: PUSH
29934: LD_VAR 0 3
29938: PPUSH
29939: LD_EXP 103
29943: PUSH
29944: LD_VAR 0 2
29948: ARRAY
29949: PPUSH
29950: CALL_OW 308
29954: NOT
29955: AND
29956: IFFALSE 29978
// ComMoveToArea ( j , mc_parking [ i ] ) ;
29958: LD_VAR 0 3
29962: PPUSH
29963: LD_EXP 103
29967: PUSH
29968: LD_VAR 0 2
29972: ARRAY
29973: PPUSH
29974: CALL_OW 113
29978: GO 29858
29980: POP
29981: POP
// end ; if not tmp then
29982: LD_VAR 0 5
29986: NOT
29987: IFFALSE 29991
// continue ;
29989: GO 29507
// for j in tmp do
29991: LD_ADDR_VAR 0 3
29995: PUSH
29996: LD_VAR 0 5
30000: PUSH
30001: FOR_IN
30002: IFFALSE 30326
// begin if mc_need_heal [ i ] then
30004: LD_EXP 82
30008: PUSH
30009: LD_VAR 0 2
30013: ARRAY
30014: IFFALSE 30062
// if j in mc_need_heal [ i ] [ 1 ] or j in mc_need_heal [ i ] [ 2 ] then
30016: LD_VAR 0 3
30020: PUSH
30021: LD_EXP 82
30025: PUSH
30026: LD_VAR 0 2
30030: ARRAY
30031: PUSH
30032: LD_INT 1
30034: ARRAY
30035: IN
30036: PUSH
30037: LD_VAR 0 3
30041: PUSH
30042: LD_EXP 82
30046: PUSH
30047: LD_VAR 0 2
30051: ARRAY
30052: PUSH
30053: LD_INT 2
30055: ARRAY
30056: IN
30057: OR
30058: IFFALSE 30062
// continue ;
30060: GO 30001
// if IsInUnit ( j ) then
30062: LD_VAR 0 3
30066: PPUSH
30067: CALL_OW 310
30071: IFFALSE 30082
// ComExitBuilding ( j ) ;
30073: LD_VAR 0 3
30077: PPUSH
30078: CALL_OW 122
// if not j in mc_building_repairs [ i ] then
30082: LD_VAR 0 3
30086: PUSH
30087: LD_EXP 81
30091: PUSH
30092: LD_VAR 0 2
30096: ARRAY
30097: IN
30098: NOT
30099: IFFALSE 30157
// begin SetTag ( j , 101 ) ;
30101: LD_VAR 0 3
30105: PPUSH
30106: LD_INT 101
30108: PPUSH
30109: CALL_OW 109
// mc_building_repairs := ReplaceIn ( mc_building_repairs , [ i , mc_building_repairs [ i ] + 1 ] , j ) ;
30113: LD_ADDR_EXP 81
30117: PUSH
30118: LD_EXP 81
30122: PPUSH
30123: LD_VAR 0 2
30127: PUSH
30128: LD_EXP 81
30132: PUSH
30133: LD_VAR 0 2
30137: ARRAY
30138: PUSH
30139: LD_INT 1
30141: PLUS
30142: PUSH
30143: EMPTY
30144: LIST
30145: LIST
30146: PPUSH
30147: LD_VAR 0 3
30151: PPUSH
30152: CALL 57783 0 3
30156: ST_TO_ADDR
// end ; wait ( 1 ) ;
30157: LD_INT 1
30159: PPUSH
30160: CALL_OW 67
// to_repair_tmp := mc_building_need_repair [ i ] ;
30164: LD_ADDR_VAR 0 7
30168: PUSH
30169: LD_EXP 80
30173: PUSH
30174: LD_VAR 0 2
30178: ARRAY
30179: ST_TO_ADDR
// if mc_scan [ i ] then
30180: LD_EXP 102
30184: PUSH
30185: LD_VAR 0 2
30189: ARRAY
30190: IFFALSE 30259
// to_repair_tmp := UnitFilter ( mc_building_need_repair [ i ] , [ f_not , [ f_or , [ f_btype , b_bunker ] , [ f_btype , b_turret ] , [ f_btype , b_breastwork ] ] ] ) ;
30192: LD_ADDR_VAR 0 7
30196: PUSH
30197: LD_EXP 80
30201: PUSH
30202: LD_VAR 0 2
30206: ARRAY
30207: PPUSH
30208: LD_INT 3
30210: PUSH
30211: LD_INT 2
30213: PUSH
30214: LD_INT 30
30216: PUSH
30217: LD_INT 32
30219: PUSH
30220: EMPTY
30221: LIST
30222: LIST
30223: PUSH
30224: LD_INT 30
30226: PUSH
30227: LD_INT 33
30229: PUSH
30230: EMPTY
30231: LIST
30232: LIST
30233: PUSH
30234: LD_INT 30
30236: PUSH
30237: LD_INT 31
30239: PUSH
30240: EMPTY
30241: LIST
30242: LIST
30243: PUSH
30244: EMPTY
30245: LIST
30246: LIST
30247: LIST
30248: LIST
30249: PUSH
30250: EMPTY
30251: LIST
30252: LIST
30253: PPUSH
30254: CALL_OW 72
30258: ST_TO_ADDR
// if not to_repair_tmp then
30259: LD_VAR 0 7
30263: NOT
30264: IFFALSE 30268
// continue ;
30266: GO 30001
// to_repair := NearestUnitToUnit ( to_repair_tmp , j ) ;
30268: LD_ADDR_VAR 0 8
30272: PUSH
30273: LD_VAR 0 7
30277: PPUSH
30278: LD_VAR 0 3
30282: PPUSH
30283: CALL_OW 74
30287: ST_TO_ADDR
// if DangerAtRange ( to_repair , 14 ) [ 4 ] < 5 then
30288: LD_VAR 0 8
30292: PPUSH
30293: LD_INT 14
30295: PPUSH
30296: CALL 60376 0 2
30300: PUSH
30301: LD_INT 4
30303: ARRAY
30304: PUSH
30305: LD_INT 5
30307: LESS
30308: IFFALSE 30324
// ComRepairBuilding ( j , to_repair ) ;
30310: LD_VAR 0 3
30314: PPUSH
30315: LD_VAR 0 8
30319: PPUSH
30320: CALL_OW 130
// end ;
30324: GO 30001
30326: POP
30327: POP
// end ;
30328: GO 29507
30330: POP
30331: POP
// end ;
30332: LD_VAR 0 1
30336: RET
// export function MC_Heal ; var i , j , tmp ; begin
30337: LD_INT 0
30339: PPUSH
30340: PPUSH
30341: PPUSH
30342: PPUSH
// if not mc_bases then
30343: LD_EXP 79
30347: NOT
30348: IFFALSE 30352
// exit ;
30350: GO 30754
// for i = 1 to mc_bases do
30352: LD_ADDR_VAR 0 2
30356: PUSH
30357: DOUBLE
30358: LD_INT 1
30360: DEC
30361: ST_TO_ADDR
30362: LD_EXP 79
30366: PUSH
30367: FOR_TO
30368: IFFALSE 30752
// begin if not mc_need_heal [ i ] [ 1 ] and not mc_need_heal [ i ] [ 2 ] then
30370: LD_EXP 82
30374: PUSH
30375: LD_VAR 0 2
30379: ARRAY
30380: PUSH
30381: LD_INT 1
30383: ARRAY
30384: NOT
30385: PUSH
30386: LD_EXP 82
30390: PUSH
30391: LD_VAR 0 2
30395: ARRAY
30396: PUSH
30397: LD_INT 2
30399: ARRAY
30400: NOT
30401: AND
30402: IFFALSE 30440
// begin mc_healers := Replace ( mc_healers , i , [ ] ) ;
30404: LD_ADDR_EXP 83
30408: PUSH
30409: LD_EXP 83
30413: PPUSH
30414: LD_VAR 0 2
30418: PPUSH
30419: EMPTY
30420: PPUSH
30421: CALL_OW 1
30425: ST_TO_ADDR
// MC_Reset ( i , 102 ) ;
30426: LD_VAR 0 2
30430: PPUSH
30431: LD_INT 102
30433: PPUSH
30434: CALL 24585 0 2
// continue ;
30438: GO 30367
// end ; tmp := UnitFilter ( mc_bases [ i ] , [ f_class , 4 ] ) ;
30440: LD_ADDR_VAR 0 4
30444: PUSH
30445: LD_EXP 79
30449: PUSH
30450: LD_VAR 0 2
30454: ARRAY
30455: PPUSH
30456: LD_INT 25
30458: PUSH
30459: LD_INT 4
30461: PUSH
30462: EMPTY
30463: LIST
30464: LIST
30465: PPUSH
30466: CALL_OW 72
30470: ST_TO_ADDR
// if not tmp then
30471: LD_VAR 0 4
30475: NOT
30476: IFFALSE 30480
// continue ;
30478: GO 30367
// if mc_taming [ i ] then
30480: LD_EXP 110
30484: PUSH
30485: LD_VAR 0 2
30489: ARRAY
30490: IFFALSE 30514
// mc_taming := Replace ( mc_taming , i , [ ] ) ;
30492: LD_ADDR_EXP 110
30496: PUSH
30497: LD_EXP 110
30501: PPUSH
30502: LD_VAR 0 2
30506: PPUSH
30507: EMPTY
30508: PPUSH
30509: CALL_OW 1
30513: ST_TO_ADDR
// for j in tmp do
30514: LD_ADDR_VAR 0 3
30518: PUSH
30519: LD_VAR 0 4
30523: PUSH
30524: FOR_IN
30525: IFFALSE 30748
// begin if IsInUnit ( j ) then
30527: LD_VAR 0 3
30531: PPUSH
30532: CALL_OW 310
30536: IFFALSE 30547
// ComExitBuilding ( j ) ;
30538: LD_VAR 0 3
30542: PPUSH
30543: CALL_OW 122
// if not j in mc_healers [ i ] then
30547: LD_VAR 0 3
30551: PUSH
30552: LD_EXP 83
30556: PUSH
30557: LD_VAR 0 2
30561: ARRAY
30562: IN
30563: NOT
30564: IFFALSE 30610
// mc_healers := ReplaceIn ( mc_healers , [ i , mc_healers [ i ] + 1 ] , j ) ;
30566: LD_ADDR_EXP 83
30570: PUSH
30571: LD_EXP 83
30575: PPUSH
30576: LD_VAR 0 2
30580: PUSH
30581: LD_EXP 83
30585: PUSH
30586: LD_VAR 0 2
30590: ARRAY
30591: PUSH
30592: LD_INT 1
30594: PLUS
30595: PUSH
30596: EMPTY
30597: LIST
30598: LIST
30599: PPUSH
30600: LD_VAR 0 3
30604: PPUSH
30605: CALL 57783 0 3
30609: ST_TO_ADDR
// if GetTag ( j ) <> 102 then
30610: LD_VAR 0 3
30614: PPUSH
30615: CALL_OW 110
30619: PUSH
30620: LD_INT 102
30622: NONEQUAL
30623: IFFALSE 30637
// SetTag ( j , 102 ) ;
30625: LD_VAR 0 3
30629: PPUSH
30630: LD_INT 102
30632: PPUSH
30633: CALL_OW 109
// Wait ( 3 ) ;
30637: LD_INT 3
30639: PPUSH
30640: CALL_OW 67
// if mc_need_heal [ i ] [ 1 ] then
30644: LD_EXP 82
30648: PUSH
30649: LD_VAR 0 2
30653: ARRAY
30654: PUSH
30655: LD_INT 1
30657: ARRAY
30658: IFFALSE 30690
// ComHeal ( j , mc_need_heal [ i ] [ 1 ] [ 1 ] ) else
30660: LD_VAR 0 3
30664: PPUSH
30665: LD_EXP 82
30669: PUSH
30670: LD_VAR 0 2
30674: ARRAY
30675: PUSH
30676: LD_INT 1
30678: ARRAY
30679: PUSH
30680: LD_INT 1
30682: ARRAY
30683: PPUSH
30684: CALL_OW 128
30688: GO 30746
// if not HasTask ( j ) and mc_need_heal [ i ] [ 2 ] then
30690: LD_VAR 0 3
30694: PPUSH
30695: CALL_OW 314
30699: NOT
30700: PUSH
30701: LD_EXP 82
30705: PUSH
30706: LD_VAR 0 2
30710: ARRAY
30711: PUSH
30712: LD_INT 2
30714: ARRAY
30715: AND
30716: IFFALSE 30746
// ComHeal ( j , mc_need_heal [ i ] [ 2 ] [ 1 ] ) ;
30718: LD_VAR 0 3
30722: PPUSH
30723: LD_EXP 82
30727: PUSH
30728: LD_VAR 0 2
30732: ARRAY
30733: PUSH
30734: LD_INT 2
30736: ARRAY
30737: PUSH
30738: LD_INT 1
30740: ARRAY
30741: PPUSH
30742: CALL_OW 128
// end ;
30746: GO 30524
30748: POP
30749: POP
// end ;
30750: GO 30367
30752: POP
30753: POP
// end ;
30754: LD_VAR 0 1
30758: RET
// export function MC_Build ( ) ; var i , j , tmp , depot ; begin
30759: LD_INT 0
30761: PPUSH
30762: PPUSH
30763: PPUSH
30764: PPUSH
30765: PPUSH
// if not mc_bases then
30766: LD_EXP 79
30770: NOT
30771: IFFALSE 30775
// exit ;
30773: GO 31918
// for i = 1 to mc_bases do
30775: LD_ADDR_VAR 0 2
30779: PUSH
30780: DOUBLE
30781: LD_INT 1
30783: DEC
30784: ST_TO_ADDR
30785: LD_EXP 79
30789: PUSH
30790: FOR_TO
30791: IFFALSE 31916
// begin if mc_scan [ i ] then
30793: LD_EXP 102
30797: PUSH
30798: LD_VAR 0 2
30802: ARRAY
30803: IFFALSE 30807
// continue ;
30805: GO 30790
// if not mc_build_list [ i ] and not mc_construct_list [ i ] and mc_builders [ i ] then
30807: LD_EXP 84
30811: PUSH
30812: LD_VAR 0 2
30816: ARRAY
30817: NOT
30818: PUSH
30819: LD_EXP 86
30823: PUSH
30824: LD_VAR 0 2
30828: ARRAY
30829: NOT
30830: AND
30831: PUSH
30832: LD_EXP 85
30836: PUSH
30837: LD_VAR 0 2
30841: ARRAY
30842: AND
30843: IFFALSE 30881
// begin mc_builders := Replace ( mc_builders , i , [ ] ) ;
30845: LD_ADDR_EXP 85
30849: PUSH
30850: LD_EXP 85
30854: PPUSH
30855: LD_VAR 0 2
30859: PPUSH
30860: EMPTY
30861: PPUSH
30862: CALL_OW 1
30866: ST_TO_ADDR
// MC_Reset ( i , 103 ) ;
30867: LD_VAR 0 2
30871: PPUSH
30872: LD_INT 103
30874: PPUSH
30875: CALL 24585 0 2
// continue ;
30879: GO 30790
// end ; if mc_construct_list [ i ] then
30881: LD_EXP 86
30885: PUSH
30886: LD_VAR 0 2
30890: ARRAY
30891: IFFALSE 31111
// begin tmp := UnitFilter ( mc_bases [ i ] , [ f_class , 2 ] ) diff mc_building_repairs [ i ] ;
30893: LD_ADDR_VAR 0 4
30897: PUSH
30898: LD_EXP 79
30902: PUSH
30903: LD_VAR 0 2
30907: ARRAY
30908: PPUSH
30909: LD_INT 25
30911: PUSH
30912: LD_INT 2
30914: PUSH
30915: EMPTY
30916: LIST
30917: LIST
30918: PPUSH
30919: CALL_OW 72
30923: PUSH
30924: LD_EXP 81
30928: PUSH
30929: LD_VAR 0 2
30933: ARRAY
30934: DIFF
30935: ST_TO_ADDR
// if not tmp then
30936: LD_VAR 0 4
30940: NOT
30941: IFFALSE 30945
// continue ;
30943: GO 30790
// for j in tmp do
30945: LD_ADDR_VAR 0 3
30949: PUSH
30950: LD_VAR 0 4
30954: PUSH
30955: FOR_IN
30956: IFFALSE 31107
// begin if not mc_builders [ i ] then
30958: LD_EXP 85
30962: PUSH
30963: LD_VAR 0 2
30967: ARRAY
30968: NOT
30969: IFFALSE 31027
// begin SetTag ( j , 103 ) ;
30971: LD_VAR 0 3
30975: PPUSH
30976: LD_INT 103
30978: PPUSH
30979: CALL_OW 109
// mc_builders := ReplaceIn ( mc_builders , [ i , mc_builders [ i ] + 1 ] , j ) ;
30983: LD_ADDR_EXP 85
30987: PUSH
30988: LD_EXP 85
30992: PPUSH
30993: LD_VAR 0 2
30997: PUSH
30998: LD_EXP 85
31002: PUSH
31003: LD_VAR 0 2
31007: ARRAY
31008: PUSH
31009: LD_INT 1
31011: PLUS
31012: PUSH
31013: EMPTY
31014: LIST
31015: LIST
31016: PPUSH
31017: LD_VAR 0 3
31021: PPUSH
31022: CALL 57783 0 3
31026: ST_TO_ADDR
// end ; if IsInUnit ( j ) then
31027: LD_VAR 0 3
31031: PPUSH
31032: CALL_OW 310
31036: IFFALSE 31047
// ComExitBuilding ( j ) ;
31038: LD_VAR 0 3
31042: PPUSH
31043: CALL_OW 122
// wait ( 3 ) ;
31047: LD_INT 3
31049: PPUSH
31050: CALL_OW 67
// if not mc_construct_list [ i ] then
31054: LD_EXP 86
31058: PUSH
31059: LD_VAR 0 2
31063: ARRAY
31064: NOT
31065: IFFALSE 31069
// break ;
31067: GO 31107
// if not HasTask ( j ) then
31069: LD_VAR 0 3
31073: PPUSH
31074: CALL_OW 314
31078: NOT
31079: IFFALSE 31105
// ComComplete ( j , mc_construct_list [ i ] [ 1 ] ) ;
31081: LD_VAR 0 3
31085: PPUSH
31086: LD_EXP 86
31090: PUSH
31091: LD_VAR 0 2
31095: ARRAY
31096: PUSH
31097: LD_INT 1
31099: ARRAY
31100: PPUSH
31101: CALL 60634 0 2
// end ;
31105: GO 30955
31107: POP
31108: POP
// end else
31109: GO 31914
// if mc_build_list [ i ] then
31111: LD_EXP 84
31115: PUSH
31116: LD_VAR 0 2
31120: ARRAY
31121: IFFALSE 31914
// begin depot := UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) ;
31123: LD_ADDR_VAR 0 5
31127: PUSH
31128: LD_EXP 79
31132: PUSH
31133: LD_VAR 0 2
31137: ARRAY
31138: PPUSH
31139: LD_INT 2
31141: PUSH
31142: LD_INT 30
31144: PUSH
31145: LD_INT 0
31147: PUSH
31148: EMPTY
31149: LIST
31150: LIST
31151: PUSH
31152: LD_INT 30
31154: PUSH
31155: LD_INT 1
31157: PUSH
31158: EMPTY
31159: LIST
31160: LIST
31161: PUSH
31162: EMPTY
31163: LIST
31164: LIST
31165: LIST
31166: PPUSH
31167: CALL_OW 72
31171: ST_TO_ADDR
// if depot then
31172: LD_VAR 0 5
31176: IFFALSE 31194
// depot := depot [ 1 ] else
31178: LD_ADDR_VAR 0 5
31182: PUSH
31183: LD_VAR 0 5
31187: PUSH
31188: LD_INT 1
31190: ARRAY
31191: ST_TO_ADDR
31192: GO 31202
// depot := 0 ;
31194: LD_ADDR_VAR 0 5
31198: PUSH
31199: LD_INT 0
31201: ST_TO_ADDR
// if IsExtension ( mc_build_list [ i ] [ 1 ] [ 1 ] ) and not UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_workshop ] , [ f_btype , b_factory ] ] ) then
31202: LD_EXP 84
31206: PUSH
31207: LD_VAR 0 2
31211: ARRAY
31212: PUSH
31213: LD_INT 1
31215: ARRAY
31216: PUSH
31217: LD_INT 1
31219: ARRAY
31220: PPUSH
31221: CALL 60464 0 1
31225: PUSH
31226: LD_EXP 79
31230: PUSH
31231: LD_VAR 0 2
31235: ARRAY
31236: PPUSH
31237: LD_INT 2
31239: PUSH
31240: LD_INT 30
31242: PUSH
31243: LD_INT 2
31245: PUSH
31246: EMPTY
31247: LIST
31248: LIST
31249: PUSH
31250: LD_INT 30
31252: PUSH
31253: LD_INT 3
31255: PUSH
31256: EMPTY
31257: LIST
31258: LIST
31259: PUSH
31260: EMPTY
31261: LIST
31262: LIST
31263: LIST
31264: PPUSH
31265: CALL_OW 72
31269: NOT
31270: AND
31271: IFFALSE 31376
// begin for j = 1 to mc_build_list [ i ] do
31273: LD_ADDR_VAR 0 3
31277: PUSH
31278: DOUBLE
31279: LD_INT 1
31281: DEC
31282: ST_TO_ADDR
31283: LD_EXP 84
31287: PUSH
31288: LD_VAR 0 2
31292: ARRAY
31293: PUSH
31294: FOR_TO
31295: IFFALSE 31374
// if mc_build_list [ i ] [ j ] [ 1 ] = b_workshop then
31297: LD_EXP 84
31301: PUSH
31302: LD_VAR 0 2
31306: ARRAY
31307: PUSH
31308: LD_VAR 0 3
31312: ARRAY
31313: PUSH
31314: LD_INT 1
31316: ARRAY
31317: PUSH
31318: LD_INT 2
31320: EQUAL
31321: IFFALSE 31372
// begin mc_build_list := Replace ( mc_build_list , i , Reindex ( mc_build_list [ i ] , j , 1 , false ) ) ;
31323: LD_ADDR_EXP 84
31327: PUSH
31328: LD_EXP 84
31332: PPUSH
31333: LD_VAR 0 2
31337: PPUSH
31338: LD_EXP 84
31342: PUSH
31343: LD_VAR 0 2
31347: ARRAY
31348: PPUSH
31349: LD_VAR 0 3
31353: PPUSH
31354: LD_INT 1
31356: PPUSH
31357: LD_INT 0
31359: PPUSH
31360: CALL 57201 0 4
31364: PPUSH
31365: CALL_OW 1
31369: ST_TO_ADDR
// break ;
31370: GO 31374
// end ;
31372: GO 31294
31374: POP
31375: POP
// end ; if mc_build_list [ i ] [ 1 ] [ 1 ] = b_depot or ( depot and CanBeBuilt ( depot , mc_build_list [ i ] [ 1 ] [ 1 ] , mc_build_list [ i ] [ 1 ] [ 2 ] , mc_build_list [ i ] [ 1 ] [ 3 ] , mc_build_list [ i ] [ 1 ] [ 4 ] ) ) then
31376: LD_EXP 84
31380: PUSH
31381: LD_VAR 0 2
31385: ARRAY
31386: PUSH
31387: LD_INT 1
31389: ARRAY
31390: PUSH
31391: LD_INT 1
31393: ARRAY
31394: PUSH
31395: LD_INT 0
31397: EQUAL
31398: PUSH
31399: LD_VAR 0 5
31403: PUSH
31404: LD_VAR 0 5
31408: PPUSH
31409: LD_EXP 84
31413: PUSH
31414: LD_VAR 0 2
31418: ARRAY
31419: PUSH
31420: LD_INT 1
31422: ARRAY
31423: PUSH
31424: LD_INT 1
31426: ARRAY
31427: PPUSH
31428: LD_EXP 84
31432: PUSH
31433: LD_VAR 0 2
31437: ARRAY
31438: PUSH
31439: LD_INT 1
31441: ARRAY
31442: PUSH
31443: LD_INT 2
31445: ARRAY
31446: PPUSH
31447: LD_EXP 84
31451: PUSH
31452: LD_VAR 0 2
31456: ARRAY
31457: PUSH
31458: LD_INT 1
31460: ARRAY
31461: PUSH
31462: LD_INT 3
31464: ARRAY
31465: PPUSH
31466: LD_EXP 84
31470: PUSH
31471: LD_VAR 0 2
31475: ARRAY
31476: PUSH
31477: LD_INT 1
31479: ARRAY
31480: PUSH
31481: LD_INT 4
31483: ARRAY
31484: PPUSH
31485: CALL 65198 0 5
31489: AND
31490: OR
31491: IFFALSE 31772
// begin tmp := UnitFilter ( mc_bases [ i ] , [ f_class , 2 ] ) diff mc_building_repairs [ i ] ;
31493: LD_ADDR_VAR 0 4
31497: PUSH
31498: LD_EXP 79
31502: PUSH
31503: LD_VAR 0 2
31507: ARRAY
31508: PPUSH
31509: LD_INT 25
31511: PUSH
31512: LD_INT 2
31514: PUSH
31515: EMPTY
31516: LIST
31517: LIST
31518: PPUSH
31519: CALL_OW 72
31523: PUSH
31524: LD_EXP 81
31528: PUSH
31529: LD_VAR 0 2
31533: ARRAY
31534: DIFF
31535: ST_TO_ADDR
// if not tmp then
31536: LD_VAR 0 4
31540: NOT
31541: IFFALSE 31545
// continue ;
31543: GO 30790
// for j in tmp do
31545: LD_ADDR_VAR 0 3
31549: PUSH
31550: LD_VAR 0 4
31554: PUSH
31555: FOR_IN
31556: IFFALSE 31768
// begin if not mc_builders [ i ] then
31558: LD_EXP 85
31562: PUSH
31563: LD_VAR 0 2
31567: ARRAY
31568: NOT
31569: IFFALSE 31627
// begin SetTag ( j , 103 ) ;
31571: LD_VAR 0 3
31575: PPUSH
31576: LD_INT 103
31578: PPUSH
31579: CALL_OW 109
// mc_builders := ReplaceIn ( mc_builders , [ i , mc_builders [ i ] + 1 ] , j ) ;
31583: LD_ADDR_EXP 85
31587: PUSH
31588: LD_EXP 85
31592: PPUSH
31593: LD_VAR 0 2
31597: PUSH
31598: LD_EXP 85
31602: PUSH
31603: LD_VAR 0 2
31607: ARRAY
31608: PUSH
31609: LD_INT 1
31611: PLUS
31612: PUSH
31613: EMPTY
31614: LIST
31615: LIST
31616: PPUSH
31617: LD_VAR 0 3
31621: PPUSH
31622: CALL 57783 0 3
31626: ST_TO_ADDR
// end ; if IsInUnit ( j ) then
31627: LD_VAR 0 3
31631: PPUSH
31632: CALL_OW 310
31636: IFFALSE 31647
// ComExitBuilding ( j ) ;
31638: LD_VAR 0 3
31642: PPUSH
31643: CALL_OW 122
// wait ( 3 ) ;
31647: LD_INT 3
31649: PPUSH
31650: CALL_OW 67
// if not mc_build_list [ i ] then
31654: LD_EXP 84
31658: PUSH
31659: LD_VAR 0 2
31663: ARRAY
31664: NOT
31665: IFFALSE 31669
// break ;
31667: GO 31768
// if not HasTask ( j ) then
31669: LD_VAR 0 3
31673: PPUSH
31674: CALL_OW 314
31678: NOT
31679: IFFALSE 31766
// ComBuild ( j , mc_build_list [ i ] [ 1 ] [ 1 ] , mc_build_list [ i ] [ 1 ] [ 2 ] , mc_build_list [ i ] [ 1 ] [ 3 ] , mc_build_list [ i ] [ 1 ] [ 4 ] ) ;
31681: LD_VAR 0 3
31685: PPUSH
31686: LD_EXP 84
31690: PUSH
31691: LD_VAR 0 2
31695: ARRAY
31696: PUSH
31697: LD_INT 1
31699: ARRAY
31700: PUSH
31701: LD_INT 1
31703: ARRAY
31704: PPUSH
31705: LD_EXP 84
31709: PUSH
31710: LD_VAR 0 2
31714: ARRAY
31715: PUSH
31716: LD_INT 1
31718: ARRAY
31719: PUSH
31720: LD_INT 2
31722: ARRAY
31723: PPUSH
31724: LD_EXP 84
31728: PUSH
31729: LD_VAR 0 2
31733: ARRAY
31734: PUSH
31735: LD_INT 1
31737: ARRAY
31738: PUSH
31739: LD_INT 3
31741: ARRAY
31742: PPUSH
31743: LD_EXP 84
31747: PUSH
31748: LD_VAR 0 2
31752: ARRAY
31753: PUSH
31754: LD_INT 1
31756: ARRAY
31757: PUSH
31758: LD_INT 4
31760: ARRAY
31761: PPUSH
31762: CALL_OW 145
// end ;
31766: GO 31555
31768: POP
31769: POP
// end else
31770: GO 31914
// if not TryClearPlaceForBuilding ( mc_bases [ i ] , mc_build_list [ i ] [ 1 ] [ 1 ] , mc_build_list [ i ] [ 1 ] [ 2 ] , mc_build_list [ i ] [ 1 ] [ 3 ] , mc_build_list [ i ] [ 1 ] [ 4 ] ) then
31772: LD_EXP 79
31776: PUSH
31777: LD_VAR 0 2
31781: ARRAY
31782: PPUSH
31783: LD_EXP 84
31787: PUSH
31788: LD_VAR 0 2
31792: ARRAY
31793: PUSH
31794: LD_INT 1
31796: ARRAY
31797: PUSH
31798: LD_INT 1
31800: ARRAY
31801: PPUSH
31802: LD_EXP 84
31806: PUSH
31807: LD_VAR 0 2
31811: ARRAY
31812: PUSH
31813: LD_INT 1
31815: ARRAY
31816: PUSH
31817: LD_INT 2
31819: ARRAY
31820: PPUSH
31821: LD_EXP 84
31825: PUSH
31826: LD_VAR 0 2
31830: ARRAY
31831: PUSH
31832: LD_INT 1
31834: ARRAY
31835: PUSH
31836: LD_INT 3
31838: ARRAY
31839: PPUSH
31840: LD_EXP 84
31844: PUSH
31845: LD_VAR 0 2
31849: ARRAY
31850: PUSH
31851: LD_INT 1
31853: ARRAY
31854: PUSH
31855: LD_INT 4
31857: ARRAY
31858: PPUSH
31859: CALL 64534 0 5
31863: NOT
31864: IFFALSE 31914
// begin mc_build_list := Replace ( mc_build_list , i , Reindex ( mc_build_list [ i ] , 1 , - 1 , false ) ) ;
31866: LD_ADDR_EXP 84
31870: PUSH
31871: LD_EXP 84
31875: PPUSH
31876: LD_VAR 0 2
31880: PPUSH
31881: LD_EXP 84
31885: PUSH
31886: LD_VAR 0 2
31890: ARRAY
31891: PPUSH
31892: LD_INT 1
31894: PPUSH
31895: LD_INT 1
31897: NEG
31898: PPUSH
31899: LD_INT 0
31901: PPUSH
31902: CALL 57201 0 4
31906: PPUSH
31907: CALL_OW 1
31911: ST_TO_ADDR
// continue ;
31912: GO 30790
// end ; end ; end ;
31914: GO 30790
31916: POP
31917: POP
// end ;
31918: LD_VAR 0 1
31922: RET
// export function MC_BuildUpgrade ( ) ; var i , j , tmp , depot , lab ; begin
31923: LD_INT 0
31925: PPUSH
31926: PPUSH
31927: PPUSH
31928: PPUSH
31929: PPUSH
31930: PPUSH
// if not mc_bases then
31931: LD_EXP 79
31935: NOT
31936: IFFALSE 31940
// exit ;
31938: GO 32367
// for i = 1 to mc_bases do
31940: LD_ADDR_VAR 0 2
31944: PUSH
31945: DOUBLE
31946: LD_INT 1
31948: DEC
31949: ST_TO_ADDR
31950: LD_EXP 79
31954: PUSH
31955: FOR_TO
31956: IFFALSE 32365
// begin tmp := mc_build_upgrade [ i ] ;
31958: LD_ADDR_VAR 0 4
31962: PUSH
31963: LD_EXP 111
31967: PUSH
31968: LD_VAR 0 2
31972: ARRAY
31973: ST_TO_ADDR
// lab := UnitFilter ( mc_lab [ i ] , [ f_or , [ f_btype , b_lab ] , [ f_btype , b_lab_half ] ] ) ;
31974: LD_ADDR_VAR 0 6
31978: PUSH
31979: LD_EXP 112
31983: PUSH
31984: LD_VAR 0 2
31988: ARRAY
31989: PPUSH
31990: LD_INT 2
31992: PUSH
31993: LD_INT 30
31995: PUSH
31996: LD_INT 6
31998: PUSH
31999: EMPTY
32000: LIST
32001: LIST
32002: PUSH
32003: LD_INT 30
32005: PUSH
32006: LD_INT 7
32008: PUSH
32009: EMPTY
32010: LIST
32011: LIST
32012: PUSH
32013: EMPTY
32014: LIST
32015: LIST
32016: LIST
32017: PPUSH
32018: CALL_OW 72
32022: ST_TO_ADDR
// if not tmp and not lab then
32023: LD_VAR 0 4
32027: NOT
32028: PUSH
32029: LD_VAR 0 6
32033: NOT
32034: AND
32035: IFFALSE 32039
// continue ;
32037: GO 31955
// if tmp then
32039: LD_VAR 0 4
32043: IFFALSE 32163
// for j in tmp do
32045: LD_ADDR_VAR 0 3
32049: PUSH
32050: LD_VAR 0 4
32054: PUSH
32055: FOR_IN
32056: IFFALSE 32161
// begin if UpgradeCost ( j ) then
32058: LD_VAR 0 3
32062: PPUSH
32063: CALL 64194 0 1
32067: IFFALSE 32159
// begin ComUpgrade ( j ) ;
32069: LD_VAR 0 3
32073: PPUSH
32074: CALL_OW 146
// mc_build_upgrade := Replace ( mc_build_upgrade , i , mc_build_upgrade [ i ] diff j ) ;
32078: LD_ADDR_EXP 111
32082: PUSH
32083: LD_EXP 111
32087: PPUSH
32088: LD_VAR 0 2
32092: PPUSH
32093: LD_EXP 111
32097: PUSH
32098: LD_VAR 0 2
32102: ARRAY
32103: PUSH
32104: LD_VAR 0 3
32108: DIFF
32109: PPUSH
32110: CALL_OW 1
32114: ST_TO_ADDR
// mc_construct_list := ReplaceIn ( mc_construct_list , [ i , mc_construct_list [ i ] + 1 ] , j ) ;
32115: LD_ADDR_EXP 86
32119: PUSH
32120: LD_EXP 86
32124: PPUSH
32125: LD_VAR 0 2
32129: PUSH
32130: LD_EXP 86
32134: PUSH
32135: LD_VAR 0 2
32139: ARRAY
32140: PUSH
32141: LD_INT 1
32143: PLUS
32144: PUSH
32145: EMPTY
32146: LIST
32147: LIST
32148: PPUSH
32149: LD_VAR 0 3
32153: PPUSH
32154: CALL 57783 0 3
32158: ST_TO_ADDR
// end ; end ;
32159: GO 32055
32161: POP
32162: POP
// if not lab or not mc_lab_upgrade [ i ] then
32163: LD_VAR 0 6
32167: NOT
32168: PUSH
32169: LD_EXP 113
32173: PUSH
32174: LD_VAR 0 2
32178: ARRAY
32179: NOT
32180: OR
32181: IFFALSE 32185
// continue ;
32183: GO 31955
// for j in lab do
32185: LD_ADDR_VAR 0 3
32189: PUSH
32190: LD_VAR 0 6
32194: PUSH
32195: FOR_IN
32196: IFFALSE 32361
// begin if GetBType ( j ) in [ b_lab , b_lab_half ] and BuildingStatus ( j ) <> bs_build then
32198: LD_VAR 0 3
32202: PPUSH
32203: CALL_OW 266
32207: PUSH
32208: LD_INT 6
32210: PUSH
32211: LD_INT 7
32213: PUSH
32214: EMPTY
32215: LIST
32216: LIST
32217: IN
32218: PUSH
32219: LD_VAR 0 3
32223: PPUSH
32224: CALL_OW 461
32228: PUSH
32229: LD_INT 1
32231: NONEQUAL
32232: AND
32233: IFFALSE 32359
// begin if UpgradeLabCost ( j , mc_lab_upgrade [ i ] [ 1 ] ) then
32235: LD_VAR 0 3
32239: PPUSH
32240: LD_EXP 113
32244: PUSH
32245: LD_VAR 0 2
32249: ARRAY
32250: PUSH
32251: LD_INT 1
32253: ARRAY
32254: PPUSH
32255: CALL 64399 0 2
32259: IFFALSE 32359
// begin ComCancel ( j ) ;
32261: LD_VAR 0 3
32265: PPUSH
32266: CALL_OW 127
// AddComUpgradeLab ( j , mc_lab_upgrade [ i ] [ 1 ] ) ;
32270: LD_VAR 0 3
32274: PPUSH
32275: LD_EXP 113
32279: PUSH
32280: LD_VAR 0 2
32284: ARRAY
32285: PUSH
32286: LD_INT 1
32288: ARRAY
32289: PPUSH
32290: CALL_OW 207
// if not j in mc_construct_list [ i ] then
32294: LD_VAR 0 3
32298: PUSH
32299: LD_EXP 86
32303: PUSH
32304: LD_VAR 0 2
32308: ARRAY
32309: IN
32310: NOT
32311: IFFALSE 32357
// mc_construct_list := ReplaceIn ( mc_construct_list , [ i , mc_construct_list [ i ] + 1 ] , j ) ;
32313: LD_ADDR_EXP 86
32317: PUSH
32318: LD_EXP 86
32322: PPUSH
32323: LD_VAR 0 2
32327: PUSH
32328: LD_EXP 86
32332: PUSH
32333: LD_VAR 0 2
32337: ARRAY
32338: PUSH
32339: LD_INT 1
32341: PLUS
32342: PUSH
32343: EMPTY
32344: LIST
32345: LIST
32346: PPUSH
32347: LD_VAR 0 3
32351: PPUSH
32352: CALL 57783 0 3
32356: ST_TO_ADDR
// break ;
32357: GO 32361
// end ; end ; end ;
32359: GO 32195
32361: POP
32362: POP
// end ;
32363: GO 31955
32365: POP
32366: POP
// end ;
32367: LD_VAR 0 1
32371: RET
// export function MC_TurretWeapon ( ) ; var i , j , tmp , tmp2 , t , tw , busy , weapon ; begin
32372: LD_INT 0
32374: PPUSH
32375: PPUSH
32376: PPUSH
32377: PPUSH
32378: PPUSH
32379: PPUSH
32380: PPUSH
32381: PPUSH
32382: PPUSH
// if not mc_bases then
32383: LD_EXP 79
32387: NOT
32388: IFFALSE 32392
// exit ;
32390: GO 32797
// for i = 1 to mc_bases do
32392: LD_ADDR_VAR 0 2
32396: PUSH
32397: DOUBLE
32398: LD_INT 1
32400: DEC
32401: ST_TO_ADDR
32402: LD_EXP 79
32406: PUSH
32407: FOR_TO
32408: IFFALSE 32795
// begin if not mc_turret_list [ i ] or not UnitFilter ( mc_bases [ i ] , [ f_btype , b_factory ] ) then
32410: LD_EXP 87
32414: PUSH
32415: LD_VAR 0 2
32419: ARRAY
32420: NOT
32421: PUSH
32422: LD_EXP 79
32426: PUSH
32427: LD_VAR 0 2
32431: ARRAY
32432: PPUSH
32433: LD_INT 30
32435: PUSH
32436: LD_INT 3
32438: PUSH
32439: EMPTY
32440: LIST
32441: LIST
32442: PPUSH
32443: CALL_OW 72
32447: NOT
32448: OR
32449: IFFALSE 32453
// continue ;
32451: GO 32407
// busy := false ;
32453: LD_ADDR_VAR 0 8
32457: PUSH
32458: LD_INT 0
32460: ST_TO_ADDR
// tmp := UnitFilter ( mc_bases [ i ] , [ f_btype , b_factory ] ) ;
32461: LD_ADDR_VAR 0 4
32465: PUSH
32466: LD_EXP 79
32470: PUSH
32471: LD_VAR 0 2
32475: ARRAY
32476: PPUSH
32477: LD_INT 30
32479: PUSH
32480: LD_INT 3
32482: PUSH
32483: EMPTY
32484: LIST
32485: LIST
32486: PPUSH
32487: CALL_OW 72
32491: ST_TO_ADDR
// t := UnitFilter ( mc_turret_list [ i ] , [ f_or , [ f_btype , b_bunker ] , [ f_btype , b_turret ] ] ) ;
32492: LD_ADDR_VAR 0 6
32496: PUSH
32497: LD_EXP 87
32501: PUSH
32502: LD_VAR 0 2
32506: ARRAY
32507: PPUSH
32508: LD_INT 2
32510: PUSH
32511: LD_INT 30
32513: PUSH
32514: LD_INT 32
32516: PUSH
32517: EMPTY
32518: LIST
32519: LIST
32520: PUSH
32521: LD_INT 30
32523: PUSH
32524: LD_INT 33
32526: PUSH
32527: EMPTY
32528: LIST
32529: LIST
32530: PUSH
32531: EMPTY
32532: LIST
32533: LIST
32534: LIST
32535: PPUSH
32536: CALL_OW 72
32540: ST_TO_ADDR
// if not t then
32541: LD_VAR 0 6
32545: NOT
32546: IFFALSE 32550
// continue ;
32548: GO 32407
// for j in tmp do
32550: LD_ADDR_VAR 0 3
32554: PUSH
32555: LD_VAR 0 4
32559: PUSH
32560: FOR_IN
32561: IFFALSE 32591
// if not BuildingStatus ( j ) = bs_idle then
32563: LD_VAR 0 3
32567: PPUSH
32568: CALL_OW 461
32572: PUSH
32573: LD_INT 2
32575: EQUAL
32576: NOT
32577: IFFALSE 32589
// begin busy := true ;
32579: LD_ADDR_VAR 0 8
32583: PUSH
32584: LD_INT 1
32586: ST_TO_ADDR
// break ;
32587: GO 32591
// end ;
32589: GO 32560
32591: POP
32592: POP
// if busy then
32593: LD_VAR 0 8
32597: IFFALSE 32601
// continue ;
32599: GO 32407
// tw := UnitFilter ( t , [ f_bweapon , 0 ] ) ;
32601: LD_ADDR_VAR 0 7
32605: PUSH
32606: LD_VAR 0 6
32610: PPUSH
32611: LD_INT 35
32613: PUSH
32614: LD_INT 0
32616: PUSH
32617: EMPTY
32618: LIST
32619: LIST
32620: PPUSH
32621: CALL_OW 72
32625: ST_TO_ADDR
// if tw then
32626: LD_VAR 0 7
32630: IFFALSE 32707
// begin tw := tw [ 1 ] ;
32632: LD_ADDR_VAR 0 7
32636: PUSH
32637: LD_VAR 0 7
32641: PUSH
32642: LD_INT 1
32644: ARRAY
32645: ST_TO_ADDR
// weapon := GetTurretWeapon ( tw , mc_scan_area [ i ] ) ;
32646: LD_ADDR_VAR 0 9
32650: PUSH
32651: LD_VAR 0 7
32655: PPUSH
32656: LD_EXP 104
32660: PUSH
32661: LD_VAR 0 2
32665: ARRAY
32666: PPUSH
32667: CALL 62753 0 2
32671: ST_TO_ADDR
// if mc_allowed_tower_weapons [ i ] then
32672: LD_EXP 118
32676: PUSH
32677: LD_VAR 0 2
32681: ARRAY
32682: IFFALSE 32705
// if not weapon in mc_allowed_tower_weapons [ i ] then
32684: LD_VAR 0 9
32688: PUSH
32689: LD_EXP 118
32693: PUSH
32694: LD_VAR 0 2
32698: ARRAY
32699: IN
32700: NOT
32701: IFFALSE 32705
// continue ;
32703: GO 32407
// end else
32705: GO 32770
// begin tmp2 := UpgradeTurretsWeapon ( mc_turret_list [ i ] , tmp ) ;
32707: LD_ADDR_VAR 0 5
32711: PUSH
32712: LD_EXP 87
32716: PUSH
32717: LD_VAR 0 2
32721: ARRAY
32722: PPUSH
32723: LD_VAR 0 4
32727: PPUSH
32728: CALL 92964 0 2
32732: ST_TO_ADDR
// if not tmp2 then
32733: LD_VAR 0 5
32737: NOT
32738: IFFALSE 32742
// continue ;
32740: GO 32407
// tw := tmp2 [ 1 ] ;
32742: LD_ADDR_VAR 0 7
32746: PUSH
32747: LD_VAR 0 5
32751: PUSH
32752: LD_INT 1
32754: ARRAY
32755: ST_TO_ADDR
// weapon := tmp2 [ 2 ] ;
32756: LD_ADDR_VAR 0 9
32760: PUSH
32761: LD_VAR 0 5
32765: PUSH
32766: LD_INT 2
32768: ARRAY
32769: ST_TO_ADDR
// end ; if not weapon then
32770: LD_VAR 0 9
32774: NOT
32775: IFFALSE 32779
// continue ;
32777: GO 32407
// ComPlaceWeapon ( tw , weapon ) ;
32779: LD_VAR 0 7
32783: PPUSH
32784: LD_VAR 0 9
32788: PPUSH
32789: CALL_OW 148
// end ;
32793: GO 32407
32795: POP
32796: POP
// end ;
32797: LD_VAR 0 1
32801: RET
// export function MC_PlantMines ( ) ; var i , j , k , tmp , list ; begin
32802: LD_INT 0
32804: PPUSH
32805: PPUSH
32806: PPUSH
32807: PPUSH
32808: PPUSH
32809: PPUSH
// if not mc_bases then
32810: LD_EXP 79
32814: NOT
32815: IFFALSE 32819
// exit ;
32817: GO 33595
// for i = 1 to mc_bases do
32819: LD_ADDR_VAR 0 2
32823: PUSH
32824: DOUBLE
32825: LD_INT 1
32827: DEC
32828: ST_TO_ADDR
32829: LD_EXP 79
32833: PUSH
32834: FOR_TO
32835: IFFALSE 33593
// begin if not mc_mines [ i ] or mc_mines [ i ] = mc_miners [ i ] or mc_scan [ i ] then
32837: LD_EXP 92
32841: PUSH
32842: LD_VAR 0 2
32846: ARRAY
32847: NOT
32848: PUSH
32849: LD_EXP 92
32853: PUSH
32854: LD_VAR 0 2
32858: ARRAY
32859: PUSH
32860: LD_EXP 93
32864: PUSH
32865: LD_VAR 0 2
32869: ARRAY
32870: EQUAL
32871: OR
32872: PUSH
32873: LD_EXP 102
32877: PUSH
32878: LD_VAR 0 2
32882: ARRAY
32883: OR
32884: IFFALSE 32888
// continue ;
32886: GO 32834
// if mc_miners [ i ] then
32888: LD_EXP 93
32892: PUSH
32893: LD_VAR 0 2
32897: ARRAY
32898: IFFALSE 33280
// begin for j = mc_miners [ i ] downto 1 do
32900: LD_ADDR_VAR 0 3
32904: PUSH
32905: DOUBLE
32906: LD_EXP 93
32910: PUSH
32911: LD_VAR 0 2
32915: ARRAY
32916: INC
32917: ST_TO_ADDR
32918: LD_INT 1
32920: PUSH
32921: FOR_DOWNTO
32922: IFFALSE 33278
// begin if IsDead ( mc_miners [ i ] [ j ] ) or GetClass ( mc_miners [ i ] [ j ] ) <> 1 then
32924: LD_EXP 93
32928: PUSH
32929: LD_VAR 0 2
32933: ARRAY
32934: PUSH
32935: LD_VAR 0 3
32939: ARRAY
32940: PPUSH
32941: CALL_OW 301
32945: PUSH
32946: LD_EXP 93
32950: PUSH
32951: LD_VAR 0 2
32955: ARRAY
32956: PUSH
32957: LD_VAR 0 3
32961: ARRAY
32962: PPUSH
32963: CALL_OW 257
32967: PUSH
32968: LD_INT 1
32970: NONEQUAL
32971: OR
32972: IFFALSE 33035
// begin tmp := mc_miners [ i ] diff mc_miners [ i ] [ j ] ;
32974: LD_ADDR_VAR 0 5
32978: PUSH
32979: LD_EXP 93
32983: PUSH
32984: LD_VAR 0 2
32988: ARRAY
32989: PUSH
32990: LD_EXP 93
32994: PUSH
32995: LD_VAR 0 2
32999: ARRAY
33000: PUSH
33001: LD_VAR 0 3
33005: ARRAY
33006: DIFF
33007: ST_TO_ADDR
// mc_miners := Replace ( mc_miners , i , tmp ) ;
33008: LD_ADDR_EXP 93
33012: PUSH
33013: LD_EXP 93
33017: PPUSH
33018: LD_VAR 0 2
33022: PPUSH
33023: LD_VAR 0 5
33027: PPUSH
33028: CALL_OW 1
33032: ST_TO_ADDR
// continue ;
33033: GO 32921
// end ; if GetClass ( mc_miners [ i ] [ j ] ) = 1 and not MineOfUnit ( mc_miners [ i ] [ j ] ) and not HasTask ( mc_miners [ i ] [ j ] ) then
33035: LD_EXP 93
33039: PUSH
33040: LD_VAR 0 2
33044: ARRAY
33045: PUSH
33046: LD_VAR 0 3
33050: ARRAY
33051: PPUSH
33052: CALL_OW 257
33056: PUSH
33057: LD_INT 1
33059: EQUAL
33060: PUSH
33061: LD_EXP 93
33065: PUSH
33066: LD_VAR 0 2
33070: ARRAY
33071: PUSH
33072: LD_VAR 0 3
33076: ARRAY
33077: PPUSH
33078: CALL_OW 459
33082: NOT
33083: AND
33084: PUSH
33085: LD_EXP 93
33089: PUSH
33090: LD_VAR 0 2
33094: ARRAY
33095: PUSH
33096: LD_VAR 0 3
33100: ARRAY
33101: PPUSH
33102: CALL_OW 314
33106: NOT
33107: AND
33108: IFFALSE 33276
// begin if IsInUnit ( mc_miners [ i ] [ j ] ) then
33110: LD_EXP 93
33114: PUSH
33115: LD_VAR 0 2
33119: ARRAY
33120: PUSH
33121: LD_VAR 0 3
33125: ARRAY
33126: PPUSH
33127: CALL_OW 310
33131: IFFALSE 33154
// ComExitBuilding ( mc_miners [ i ] [ j ] ) ;
33133: LD_EXP 93
33137: PUSH
33138: LD_VAR 0 2
33142: ARRAY
33143: PUSH
33144: LD_VAR 0 3
33148: ARRAY
33149: PPUSH
33150: CALL_OW 122
// if not HasTask ( mc_miners [ i ] [ j ] ) then
33154: LD_EXP 93
33158: PUSH
33159: LD_VAR 0 2
33163: ARRAY
33164: PUSH
33165: LD_VAR 0 3
33169: ARRAY
33170: PPUSH
33171: CALL_OW 314
33175: NOT
33176: IFFALSE 33276
// AddComPlaceRemoteCharge ( mc_miners [ i ] [ j ] , mc_mines [ i ] [ j mod mc_mines [ i ] + 1 ] [ 1 ] , mc_mines [ i ] [ j mod mc_mines [ i ] + 1 ] [ 2 ] , 0 ) ;
33178: LD_EXP 93
33182: PUSH
33183: LD_VAR 0 2
33187: ARRAY
33188: PUSH
33189: LD_VAR 0 3
33193: ARRAY
33194: PPUSH
33195: LD_EXP 92
33199: PUSH
33200: LD_VAR 0 2
33204: ARRAY
33205: PUSH
33206: LD_VAR 0 3
33210: PUSH
33211: LD_EXP 92
33215: PUSH
33216: LD_VAR 0 2
33220: ARRAY
33221: MOD
33222: PUSH
33223: LD_INT 1
33225: PLUS
33226: ARRAY
33227: PUSH
33228: LD_INT 1
33230: ARRAY
33231: PPUSH
33232: LD_EXP 92
33236: PUSH
33237: LD_VAR 0 2
33241: ARRAY
33242: PUSH
33243: LD_VAR 0 3
33247: PUSH
33248: LD_EXP 92
33252: PUSH
33253: LD_VAR 0 2
33257: ARRAY
33258: MOD
33259: PUSH
33260: LD_INT 1
33262: PLUS
33263: ARRAY
33264: PUSH
33265: LD_INT 2
33267: ARRAY
33268: PPUSH
33269: LD_INT 0
33271: PPUSH
33272: CALL_OW 193
// end ; end ;
33276: GO 32921
33278: POP
33279: POP
// end ; tmp := UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_armoury ] , [ f_btype , b_barracks ] , [ f_btype , b_bunker ] ] ) ;
33280: LD_ADDR_VAR 0 5
33284: PUSH
33285: LD_EXP 79
33289: PUSH
33290: LD_VAR 0 2
33294: ARRAY
33295: PPUSH
33296: LD_INT 2
33298: PUSH
33299: LD_INT 30
33301: PUSH
33302: LD_INT 4
33304: PUSH
33305: EMPTY
33306: LIST
33307: LIST
33308: PUSH
33309: LD_INT 30
33311: PUSH
33312: LD_INT 5
33314: PUSH
33315: EMPTY
33316: LIST
33317: LIST
33318: PUSH
33319: LD_INT 30
33321: PUSH
33322: LD_INT 32
33324: PUSH
33325: EMPTY
33326: LIST
33327: LIST
33328: PUSH
33329: EMPTY
33330: LIST
33331: LIST
33332: LIST
33333: LIST
33334: PPUSH
33335: CALL_OW 72
33339: ST_TO_ADDR
// if not tmp then
33340: LD_VAR 0 5
33344: NOT
33345: IFFALSE 33349
// continue ;
33347: GO 32834
// list := [ ] ;
33349: LD_ADDR_VAR 0 6
33353: PUSH
33354: EMPTY
33355: ST_TO_ADDR
// for j in tmp do
33356: LD_ADDR_VAR 0 3
33360: PUSH
33361: LD_VAR 0 5
33365: PUSH
33366: FOR_IN
33367: IFFALSE 33436
// begin for k in UnitsInside ( j ) do
33369: LD_ADDR_VAR 0 4
33373: PUSH
33374: LD_VAR 0 3
33378: PPUSH
33379: CALL_OW 313
33383: PUSH
33384: FOR_IN
33385: IFFALSE 33432
// if GetClass ( k ) = 1 and not MineOfUnit ( k ) then
33387: LD_VAR 0 4
33391: PPUSH
33392: CALL_OW 257
33396: PUSH
33397: LD_INT 1
33399: EQUAL
33400: PUSH
33401: LD_VAR 0 4
33405: PPUSH
33406: CALL_OW 459
33410: NOT
33411: AND
33412: IFFALSE 33430
// list := list ^ k ;
33414: LD_ADDR_VAR 0 6
33418: PUSH
33419: LD_VAR 0 6
33423: PUSH
33424: LD_VAR 0 4
33428: ADD
33429: ST_TO_ADDR
33430: GO 33384
33432: POP
33433: POP
// end ;
33434: GO 33366
33436: POP
33437: POP
// list := list diff mc_miners [ i ] ;
33438: LD_ADDR_VAR 0 6
33442: PUSH
33443: LD_VAR 0 6
33447: PUSH
33448: LD_EXP 93
33452: PUSH
33453: LD_VAR 0 2
33457: ARRAY
33458: DIFF
33459: ST_TO_ADDR
// if not list then
33460: LD_VAR 0 6
33464: NOT
33465: IFFALSE 33469
// continue ;
33467: GO 32834
// k := mc_mines [ i ] - mc_miners [ i ] ;
33469: LD_ADDR_VAR 0 4
33473: PUSH
33474: LD_EXP 92
33478: PUSH
33479: LD_VAR 0 2
33483: ARRAY
33484: PUSH
33485: LD_EXP 93
33489: PUSH
33490: LD_VAR 0 2
33494: ARRAY
33495: MINUS
33496: ST_TO_ADDR
// if k > list then
33497: LD_VAR 0 4
33501: PUSH
33502: LD_VAR 0 6
33506: GREATER
33507: IFFALSE 33519
// k := list ;
33509: LD_ADDR_VAR 0 4
33513: PUSH
33514: LD_VAR 0 6
33518: ST_TO_ADDR
// for j = 1 to k do
33519: LD_ADDR_VAR 0 3
33523: PUSH
33524: DOUBLE
33525: LD_INT 1
33527: DEC
33528: ST_TO_ADDR
33529: LD_VAR 0 4
33533: PUSH
33534: FOR_TO
33535: IFFALSE 33589
// mc_miners := ReplaceIn ( mc_miners , [ i , mc_miners [ i ] + 1 ] , list [ j ] ) ;
33537: LD_ADDR_EXP 93
33541: PUSH
33542: LD_EXP 93
33546: PPUSH
33547: LD_VAR 0 2
33551: PUSH
33552: LD_EXP 93
33556: PUSH
33557: LD_VAR 0 2
33561: ARRAY
33562: PUSH
33563: LD_INT 1
33565: PLUS
33566: PUSH
33567: EMPTY
33568: LIST
33569: LIST
33570: PPUSH
33571: LD_VAR 0 6
33575: PUSH
33576: LD_VAR 0 3
33580: ARRAY
33581: PPUSH
33582: CALL 57783 0 3
33586: ST_TO_ADDR
33587: GO 33534
33589: POP
33590: POP
// end ;
33591: GO 32834
33593: POP
33594: POP
// end ;
33595: LD_VAR 0 1
33599: RET
// export function MC_CollectCrates ( ) ; var i , j , k , tmp , target , cargo , depot , fac , components ; begin
33600: LD_INT 0
33602: PPUSH
33603: PPUSH
33604: PPUSH
33605: PPUSH
33606: PPUSH
33607: PPUSH
33608: PPUSH
33609: PPUSH
33610: PPUSH
33611: PPUSH
// if not mc_bases then
33612: LD_EXP 79
33616: NOT
33617: IFFALSE 33621
// exit ;
33619: GO 35371
// for i = 1 to mc_bases do
33621: LD_ADDR_VAR 0 2
33625: PUSH
33626: DOUBLE
33627: LD_INT 1
33629: DEC
33630: ST_TO_ADDR
33631: LD_EXP 79
33635: PUSH
33636: FOR_TO
33637: IFFALSE 35369
// begin if not mc_bases [ i ] or mc_construct_list [ i ] then
33639: LD_EXP 79
33643: PUSH
33644: LD_VAR 0 2
33648: ARRAY
33649: NOT
33650: PUSH
33651: LD_EXP 86
33655: PUSH
33656: LD_VAR 0 2
33660: ARRAY
33661: OR
33662: IFFALSE 33666
// continue ;
33664: GO 33636
// if not mc_crates [ i ] and mc_crates_collector [ i ] then
33666: LD_EXP 95
33670: PUSH
33671: LD_VAR 0 2
33675: ARRAY
33676: NOT
33677: PUSH
33678: LD_EXP 96
33682: PUSH
33683: LD_VAR 0 2
33687: ARRAY
33688: AND
33689: IFFALSE 33727
// begin mc_crates_collector := Replace ( mc_crates_collector , i , [ ] ) ;
33691: LD_ADDR_EXP 96
33695: PUSH
33696: LD_EXP 96
33700: PPUSH
33701: LD_VAR 0 2
33705: PPUSH
33706: EMPTY
33707: PPUSH
33708: CALL_OW 1
33712: ST_TO_ADDR
// MC_Reset ( i , 107 ) ;
33713: LD_VAR 0 2
33717: PPUSH
33718: LD_INT 107
33720: PPUSH
33721: CALL 24585 0 2
// continue ;
33725: GO 33636
// end ; target := [ ] ;
33727: LD_ADDR_VAR 0 6
33731: PUSH
33732: EMPTY
33733: ST_TO_ADDR
// for j = mc_crates [ i ] downto 1 do
33734: LD_ADDR_VAR 0 3
33738: PUSH
33739: DOUBLE
33740: LD_EXP 95
33744: PUSH
33745: LD_VAR 0 2
33749: ARRAY
33750: INC
33751: ST_TO_ADDR
33752: LD_INT 1
33754: PUSH
33755: FOR_DOWNTO
33756: IFFALSE 34016
// begin if ValidHex ( mc_crates [ i ] [ j ] [ 2 ] , mc_crates [ i ] [ j ] [ 3 ] ) and GetResourceAmountXY ( mc_crates [ i ] [ j ] [ 2 ] , mc_crates [ i ] [ j ] [ 3 ] ) = 0 then
33758: LD_EXP 95
33762: PUSH
33763: LD_VAR 0 2
33767: ARRAY
33768: PUSH
33769: LD_VAR 0 3
33773: ARRAY
33774: PUSH
33775: LD_INT 2
33777: ARRAY
33778: PPUSH
33779: LD_EXP 95
33783: PUSH
33784: LD_VAR 0 2
33788: ARRAY
33789: PUSH
33790: LD_VAR 0 3
33794: ARRAY
33795: PUSH
33796: LD_INT 3
33798: ARRAY
33799: PPUSH
33800: CALL_OW 488
33804: PUSH
33805: LD_EXP 95
33809: PUSH
33810: LD_VAR 0 2
33814: ARRAY
33815: PUSH
33816: LD_VAR 0 3
33820: ARRAY
33821: PUSH
33822: LD_INT 2
33824: ARRAY
33825: PPUSH
33826: LD_EXP 95
33830: PUSH
33831: LD_VAR 0 2
33835: ARRAY
33836: PUSH
33837: LD_VAR 0 3
33841: ARRAY
33842: PUSH
33843: LD_INT 3
33845: ARRAY
33846: PPUSH
33847: CALL_OW 284
33851: PUSH
33852: LD_INT 0
33854: EQUAL
33855: AND
33856: IFFALSE 33911
// begin tmp := Delete ( mc_crates [ i ] , j ) ;
33858: LD_ADDR_VAR 0 5
33862: PUSH
33863: LD_EXP 95
33867: PUSH
33868: LD_VAR 0 2
33872: ARRAY
33873: PPUSH
33874: LD_VAR 0 3
33878: PPUSH
33879: CALL_OW 3
33883: ST_TO_ADDR
// mc_crates := Replace ( mc_crates , i , tmp ) ;
33884: LD_ADDR_EXP 95
33888: PUSH
33889: LD_EXP 95
33893: PPUSH
33894: LD_VAR 0 2
33898: PPUSH
33899: LD_VAR 0 5
33903: PPUSH
33904: CALL_OW 1
33908: ST_TO_ADDR
// continue ;
33909: GO 33755
// end ; if DangerAtRangeXY ( GetSide ( mc_bases [ i ] [ 1 ] ) , mc_crates [ i ] [ j ] [ 2 ] , mc_crates [ i ] [ j ] [ 3 ] , 30 ) [ 4 ] = 0 then
33911: LD_EXP 79
33915: PUSH
33916: LD_VAR 0 2
33920: ARRAY
33921: PUSH
33922: LD_INT 1
33924: ARRAY
33925: PPUSH
33926: CALL_OW 255
33930: PPUSH
33931: LD_EXP 95
33935: PUSH
33936: LD_VAR 0 2
33940: ARRAY
33941: PUSH
33942: LD_VAR 0 3
33946: ARRAY
33947: PUSH
33948: LD_INT 2
33950: ARRAY
33951: PPUSH
33952: LD_EXP 95
33956: PUSH
33957: LD_VAR 0 2
33961: ARRAY
33962: PUSH
33963: LD_VAR 0 3
33967: ARRAY
33968: PUSH
33969: LD_INT 3
33971: ARRAY
33972: PPUSH
33973: LD_INT 30
33975: PPUSH
33976: CALL 58679 0 4
33980: PUSH
33981: LD_INT 4
33983: ARRAY
33984: PUSH
33985: LD_INT 0
33987: EQUAL
33988: IFFALSE 34014
// begin target := mc_crates [ i ] [ j ] ;
33990: LD_ADDR_VAR 0 6
33994: PUSH
33995: LD_EXP 95
33999: PUSH
34000: LD_VAR 0 2
34004: ARRAY
34005: PUSH
34006: LD_VAR 0 3
34010: ARRAY
34011: ST_TO_ADDR
// break ;
34012: GO 34016
// end ; end ;
34014: GO 33755
34016: POP
34017: POP
// if not target then
34018: LD_VAR 0 6
34022: NOT
34023: IFFALSE 34027
// continue ;
34025: GO 33636
// cargo := UnitFilter ( mc_vehicles [ i ] , [ [ f_or , [ f_not , [ f_empty ] ] , [ f_linked ] , [ f_control , control_apeman ] , [ f_control , control_computer ] ] , [ f_or , [ f_weapon , ar_cargo_bay ] , [ f_weapon , ru_cargo_bay ] , [ f_weapon , us_cargo_bay ] ] ] ) ;
34027: LD_ADDR_VAR 0 7
34031: PUSH
34032: LD_EXP 98
34036: PUSH
34037: LD_VAR 0 2
34041: ARRAY
34042: PPUSH
34043: LD_INT 2
34045: PUSH
34046: LD_INT 3
34048: PUSH
34049: LD_INT 58
34051: PUSH
34052: EMPTY
34053: LIST
34054: PUSH
34055: EMPTY
34056: LIST
34057: LIST
34058: PUSH
34059: LD_INT 61
34061: PUSH
34062: EMPTY
34063: LIST
34064: PUSH
34065: LD_INT 33
34067: PUSH
34068: LD_INT 5
34070: PUSH
34071: EMPTY
34072: LIST
34073: LIST
34074: PUSH
34075: LD_INT 33
34077: PUSH
34078: LD_INT 3
34080: PUSH
34081: EMPTY
34082: LIST
34083: LIST
34084: PUSH
34085: EMPTY
34086: LIST
34087: LIST
34088: LIST
34089: LIST
34090: LIST
34091: PUSH
34092: LD_INT 2
34094: PUSH
34095: LD_INT 34
34097: PUSH
34098: LD_INT 32
34100: PUSH
34101: EMPTY
34102: LIST
34103: LIST
34104: PUSH
34105: LD_INT 34
34107: PUSH
34108: LD_INT 51
34110: PUSH
34111: EMPTY
34112: LIST
34113: LIST
34114: PUSH
34115: LD_INT 34
34117: PUSH
34118: LD_INT 12
34120: PUSH
34121: EMPTY
34122: LIST
34123: LIST
34124: PUSH
34125: EMPTY
34126: LIST
34127: LIST
34128: LIST
34129: LIST
34130: PUSH
34131: EMPTY
34132: LIST
34133: LIST
34134: PPUSH
34135: CALL_OW 72
34139: ST_TO_ADDR
// if not cargo then
34140: LD_VAR 0 7
34144: NOT
34145: IFFALSE 34788
// begin if mc_crates_collector [ i ] < 5 then
34147: LD_EXP 96
34151: PUSH
34152: LD_VAR 0 2
34156: ARRAY
34157: PUSH
34158: LD_INT 5
34160: LESS
34161: IFFALSE 34527
// begin if mc_ape [ i ] then
34163: LD_EXP 108
34167: PUSH
34168: LD_VAR 0 2
34172: ARRAY
34173: IFFALSE 34220
// tmp := UnitFilter ( mc_ape [ i ] , [ [ f_class , 16 ] , [ f_lives , 750 ] ] ) ;
34175: LD_ADDR_VAR 0 5
34179: PUSH
34180: LD_EXP 108
34184: PUSH
34185: LD_VAR 0 2
34189: ARRAY
34190: PPUSH
34191: LD_INT 25
34193: PUSH
34194: LD_INT 16
34196: PUSH
34197: EMPTY
34198: LIST
34199: LIST
34200: PUSH
34201: LD_INT 24
34203: PUSH
34204: LD_INT 750
34206: PUSH
34207: EMPTY
34208: LIST
34209: LIST
34210: PUSH
34211: EMPTY
34212: LIST
34213: LIST
34214: PPUSH
34215: CALL_OW 72
34219: ST_TO_ADDR
// if not tmp then
34220: LD_VAR 0 5
34224: NOT
34225: IFFALSE 34272
// tmp := UnitFilter ( mc_bases [ i ] , [ [ f_class , 2 ] , [ f_lives , 750 ] ] ) ;
34227: LD_ADDR_VAR 0 5
34231: PUSH
34232: LD_EXP 79
34236: PUSH
34237: LD_VAR 0 2
34241: ARRAY
34242: PPUSH
34243: LD_INT 25
34245: PUSH
34246: LD_INT 2
34248: PUSH
34249: EMPTY
34250: LIST
34251: LIST
34252: PUSH
34253: LD_INT 24
34255: PUSH
34256: LD_INT 750
34258: PUSH
34259: EMPTY
34260: LIST
34261: LIST
34262: PUSH
34263: EMPTY
34264: LIST
34265: LIST
34266: PPUSH
34267: CALL_OW 72
34271: ST_TO_ADDR
// if mc_ape [ i ] and UnitFilter ( mc_bases [ i ] , [ [ f_class , 2 ] , [ f_lives , 750 ] ] ) and tmp < 5 then
34272: LD_EXP 108
34276: PUSH
34277: LD_VAR 0 2
34281: ARRAY
34282: PUSH
34283: LD_EXP 79
34287: PUSH
34288: LD_VAR 0 2
34292: ARRAY
34293: PPUSH
34294: LD_INT 25
34296: PUSH
34297: LD_INT 2
34299: PUSH
34300: EMPTY
34301: LIST
34302: LIST
34303: PUSH
34304: LD_INT 24
34306: PUSH
34307: LD_INT 750
34309: PUSH
34310: EMPTY
34311: LIST
34312: LIST
34313: PUSH
34314: EMPTY
34315: LIST
34316: LIST
34317: PPUSH
34318: CALL_OW 72
34322: AND
34323: PUSH
34324: LD_VAR 0 5
34328: PUSH
34329: LD_INT 5
34331: LESS
34332: AND
34333: IFFALSE 34415
// begin for j in UnitFilter ( mc_bases [ i ] , [ [ f_class , 2 ] , [ f_lives , 750 ] ] ) do
34335: LD_ADDR_VAR 0 3
34339: PUSH
34340: LD_EXP 79
34344: PUSH
34345: LD_VAR 0 2
34349: ARRAY
34350: PPUSH
34351: LD_INT 25
34353: PUSH
34354: LD_INT 2
34356: PUSH
34357: EMPTY
34358: LIST
34359: LIST
34360: PUSH
34361: LD_INT 24
34363: PUSH
34364: LD_INT 750
34366: PUSH
34367: EMPTY
34368: LIST
34369: LIST
34370: PUSH
34371: EMPTY
34372: LIST
34373: LIST
34374: PPUSH
34375: CALL_OW 72
34379: PUSH
34380: FOR_IN
34381: IFFALSE 34413
// begin tmp := tmp union j ;
34383: LD_ADDR_VAR 0 5
34387: PUSH
34388: LD_VAR 0 5
34392: PUSH
34393: LD_VAR 0 3
34397: UNION
34398: ST_TO_ADDR
// if tmp >= 5 then
34399: LD_VAR 0 5
34403: PUSH
34404: LD_INT 5
34406: GREATEREQUAL
34407: IFFALSE 34411
// break ;
34409: GO 34413
// end ;
34411: GO 34380
34413: POP
34414: POP
// end ; if not tmp then
34415: LD_VAR 0 5
34419: NOT
34420: IFFALSE 34424
// continue ;
34422: GO 33636
// for j in tmp do
34424: LD_ADDR_VAR 0 3
34428: PUSH
34429: LD_VAR 0 5
34433: PUSH
34434: FOR_IN
34435: IFFALSE 34525
// if not GetTag ( j ) then
34437: LD_VAR 0 3
34441: PPUSH
34442: CALL_OW 110
34446: NOT
34447: IFFALSE 34523
// begin mc_crates_collector := ReplaceIn ( mc_crates_collector , [ i , mc_crates_collector [ i ] + 1 ] , j ) ;
34449: LD_ADDR_EXP 96
34453: PUSH
34454: LD_EXP 96
34458: PPUSH
34459: LD_VAR 0 2
34463: PUSH
34464: LD_EXP 96
34468: PUSH
34469: LD_VAR 0 2
34473: ARRAY
34474: PUSH
34475: LD_INT 1
34477: PLUS
34478: PUSH
34479: EMPTY
34480: LIST
34481: LIST
34482: PPUSH
34483: LD_VAR 0 3
34487: PPUSH
34488: CALL 57783 0 3
34492: ST_TO_ADDR
// SetTag ( j , 107 ) ;
34493: LD_VAR 0 3
34497: PPUSH
34498: LD_INT 107
34500: PPUSH
34501: CALL_OW 109
// if mc_crates_collector [ i ] >= 5 then
34505: LD_EXP 96
34509: PUSH
34510: LD_VAR 0 2
34514: ARRAY
34515: PUSH
34516: LD_INT 5
34518: GREATEREQUAL
34519: IFFALSE 34523
// break ;
34521: GO 34525
// end ;
34523: GO 34434
34525: POP
34526: POP
// end ; if mc_crates_collector [ i ] and target then
34527: LD_EXP 96
34531: PUSH
34532: LD_VAR 0 2
34536: ARRAY
34537: PUSH
34538: LD_VAR 0 6
34542: AND
34543: IFFALSE 34786
// begin if mc_crates_collector [ i ] < target [ 1 ] then
34545: LD_EXP 96
34549: PUSH
34550: LD_VAR 0 2
34554: ARRAY
34555: PUSH
34556: LD_VAR 0 6
34560: PUSH
34561: LD_INT 1
34563: ARRAY
34564: LESS
34565: IFFALSE 34585
// tmp := mc_crates_collector [ i ] else
34567: LD_ADDR_VAR 0 5
34571: PUSH
34572: LD_EXP 96
34576: PUSH
34577: LD_VAR 0 2
34581: ARRAY
34582: ST_TO_ADDR
34583: GO 34599
// tmp := target [ 1 ] ;
34585: LD_ADDR_VAR 0 5
34589: PUSH
34590: LD_VAR 0 6
34594: PUSH
34595: LD_INT 1
34597: ARRAY
34598: ST_TO_ADDR
// k := 0 ;
34599: LD_ADDR_VAR 0 4
34603: PUSH
34604: LD_INT 0
34606: ST_TO_ADDR
// for j in mc_crates_collector [ i ] do
34607: LD_ADDR_VAR 0 3
34611: PUSH
34612: LD_EXP 96
34616: PUSH
34617: LD_VAR 0 2
34621: ARRAY
34622: PUSH
34623: FOR_IN
34624: IFFALSE 34784
// begin k := k + 1 ;
34626: LD_ADDR_VAR 0 4
34630: PUSH
34631: LD_VAR 0 4
34635: PUSH
34636: LD_INT 1
34638: PLUS
34639: ST_TO_ADDR
// if k > tmp then
34640: LD_VAR 0 4
34644: PUSH
34645: LD_VAR 0 5
34649: GREATER
34650: IFFALSE 34654
// break ;
34652: GO 34784
// if not GetClass ( j ) in [ 2 , 16 ] then
34654: LD_VAR 0 3
34658: PPUSH
34659: CALL_OW 257
34663: PUSH
34664: LD_INT 2
34666: PUSH
34667: LD_INT 16
34669: PUSH
34670: EMPTY
34671: LIST
34672: LIST
34673: IN
34674: NOT
34675: IFFALSE 34728
// begin mc_crates_collector := Replace ( mc_crates_collector , i , mc_crates_collector [ i ] diff j ) ;
34677: LD_ADDR_EXP 96
34681: PUSH
34682: LD_EXP 96
34686: PPUSH
34687: LD_VAR 0 2
34691: PPUSH
34692: LD_EXP 96
34696: PUSH
34697: LD_VAR 0 2
34701: ARRAY
34702: PUSH
34703: LD_VAR 0 3
34707: DIFF
34708: PPUSH
34709: CALL_OW 1
34713: ST_TO_ADDR
// SetTag ( j , 0 ) ;
34714: LD_VAR 0 3
34718: PPUSH
34719: LD_INT 0
34721: PPUSH
34722: CALL_OW 109
// continue ;
34726: GO 34623
// end ; if IsInUnit ( j ) then
34728: LD_VAR 0 3
34732: PPUSH
34733: CALL_OW 310
34737: IFFALSE 34748
// ComExitBuilding ( j ) ;
34739: LD_VAR 0 3
34743: PPUSH
34744: CALL_OW 122
// wait ( 3 ) ;
34748: LD_INT 3
34750: PPUSH
34751: CALL_OW 67
// ComCollect ( j , target [ 2 ] , target [ 3 ] ) ;
34755: LD_VAR 0 3
34759: PPUSH
34760: LD_VAR 0 6
34764: PUSH
34765: LD_INT 2
34767: ARRAY
34768: PPUSH
34769: LD_VAR 0 6
34773: PUSH
34774: LD_INT 3
34776: ARRAY
34777: PPUSH
34778: CALL_OW 117
// end ;
34782: GO 34623
34784: POP
34785: POP
// end ; end else
34786: GO 35367
// begin for j in cargo do
34788: LD_ADDR_VAR 0 3
34792: PUSH
34793: LD_VAR 0 7
34797: PUSH
34798: FOR_IN
34799: IFFALSE 35365
// begin if GetTag ( j ) <> 0 then
34801: LD_VAR 0 3
34805: PPUSH
34806: CALL_OW 110
34810: PUSH
34811: LD_INT 0
34813: NONEQUAL
34814: IFFALSE 34818
// continue ;
34816: GO 34798
// if GetLives ( j ) < 1000 and not IsInArea ( j , mc_parking [ i ] ) then
34818: LD_VAR 0 3
34822: PPUSH
34823: CALL_OW 256
34827: PUSH
34828: LD_INT 1000
34830: LESS
34831: PUSH
34832: LD_VAR 0 3
34836: PPUSH
34837: LD_EXP 103
34841: PUSH
34842: LD_VAR 0 2
34846: ARRAY
34847: PPUSH
34848: CALL_OW 308
34852: NOT
34853: AND
34854: IFFALSE 34876
// ComMoveToArea ( j , mc_parking [ i ] ) ;
34856: LD_VAR 0 3
34860: PPUSH
34861: LD_EXP 103
34865: PUSH
34866: LD_VAR 0 2
34870: ARRAY
34871: PPUSH
34872: CALL_OW 113
// if GetLives ( j ) < 1000 and IsInArea ( j , mc_parking [ i ] ) then
34876: LD_VAR 0 3
34880: PPUSH
34881: CALL_OW 256
34885: PUSH
34886: LD_INT 1000
34888: LESS
34889: PUSH
34890: LD_VAR 0 3
34894: PPUSH
34895: LD_EXP 103
34899: PUSH
34900: LD_VAR 0 2
34904: ARRAY
34905: PPUSH
34906: CALL_OW 308
34910: AND
34911: IFFALSE 34915
// continue ;
34913: GO 34798
// if GetEngine ( j ) = engine_solar and GetFuel ( j ) < 15 then
34915: LD_VAR 0 3
34919: PPUSH
34920: CALL_OW 262
34924: PUSH
34925: LD_INT 2
34927: EQUAL
34928: PUSH
34929: LD_VAR 0 3
34933: PPUSH
34934: CALL_OW 261
34938: PUSH
34939: LD_INT 15
34941: LESS
34942: AND
34943: IFFALSE 34947
// continue ;
34945: GO 34798
// if GetEngine ( j ) = engine_combustion and GetFuel ( j ) < 10 then
34947: LD_VAR 0 3
34951: PPUSH
34952: CALL_OW 262
34956: PUSH
34957: LD_INT 1
34959: EQUAL
34960: PUSH
34961: LD_VAR 0 3
34965: PPUSH
34966: CALL_OW 261
34970: PUSH
34971: LD_INT 10
34973: LESS
34974: AND
34975: IFFALSE 35304
// begin depot := UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) ;
34977: LD_ADDR_VAR 0 8
34981: PUSH
34982: LD_EXP 79
34986: PUSH
34987: LD_VAR 0 2
34991: ARRAY
34992: PPUSH
34993: LD_INT 2
34995: PUSH
34996: LD_INT 30
34998: PUSH
34999: LD_INT 0
35001: PUSH
35002: EMPTY
35003: LIST
35004: LIST
35005: PUSH
35006: LD_INT 30
35008: PUSH
35009: LD_INT 1
35011: PUSH
35012: EMPTY
35013: LIST
35014: LIST
35015: PUSH
35016: EMPTY
35017: LIST
35018: LIST
35019: LIST
35020: PPUSH
35021: CALL_OW 72
35025: ST_TO_ADDR
// if not depot then
35026: LD_VAR 0 8
35030: NOT
35031: IFFALSE 35035
// continue ;
35033: GO 34798
// if GetDistUnits ( j , NearestUnitToUnit ( depot , j ) ) < 6 then
35035: LD_VAR 0 3
35039: PPUSH
35040: LD_VAR 0 8
35044: PPUSH
35045: LD_VAR 0 3
35049: PPUSH
35050: CALL_OW 74
35054: PPUSH
35055: CALL_OW 296
35059: PUSH
35060: LD_INT 6
35062: LESS
35063: IFFALSE 35079
// SetFuel ( j , 100 ) else
35065: LD_VAR 0 3
35069: PPUSH
35070: LD_INT 100
35072: PPUSH
35073: CALL_OW 240
35077: GO 35304
// if GetFuel ( j ) = 0 then
35079: LD_VAR 0 3
35083: PPUSH
35084: CALL_OW 261
35088: PUSH
35089: LD_INT 0
35091: EQUAL
35092: IFFALSE 35304
// begin mc_vehicles := Replace ( mc_vehicles , i , mc_vehicles [ i ] diff j ) ;
35094: LD_ADDR_EXP 98
35098: PUSH
35099: LD_EXP 98
35103: PPUSH
35104: LD_VAR 0 2
35108: PPUSH
35109: LD_EXP 98
35113: PUSH
35114: LD_VAR 0 2
35118: ARRAY
35119: PUSH
35120: LD_VAR 0 3
35124: DIFF
35125: PPUSH
35126: CALL_OW 1
35130: ST_TO_ADDR
// if GetControl ( j ) = control_manual then
35131: LD_VAR 0 3
35135: PPUSH
35136: CALL_OW 263
35140: PUSH
35141: LD_INT 1
35143: EQUAL
35144: IFFALSE 35160
// ComExitVehicle ( IsInUnit ( j ) ) ;
35146: LD_VAR 0 3
35150: PPUSH
35151: CALL_OW 310
35155: PPUSH
35156: CALL_OW 121
// if GetControl ( j ) = control_remote then
35160: LD_VAR 0 3
35164: PPUSH
35165: CALL_OW 263
35169: PUSH
35170: LD_INT 2
35172: EQUAL
35173: IFFALSE 35184
// ComUnlink ( j ) ;
35175: LD_VAR 0 3
35179: PPUSH
35180: CALL_OW 136
// fac := MC_GetBuildings ( i , b_factory ) ;
35184: LD_ADDR_VAR 0 9
35188: PUSH
35189: LD_VAR 0 2
35193: PPUSH
35194: LD_INT 3
35196: PPUSH
35197: CALL 44657 0 2
35201: ST_TO_ADDR
// if fac then
35202: LD_VAR 0 9
35206: IFFALSE 35302
// begin for k in fac do
35208: LD_ADDR_VAR 0 4
35212: PUSH
35213: LD_VAR 0 9
35217: PUSH
35218: FOR_IN
35219: IFFALSE 35300
// begin components := Produce ( fac , GetChassis ( j ) , GetEngine ( j ) , GetControl ( j ) , GetWeapon ( j ) ) ;
35221: LD_ADDR_VAR 0 10
35225: PUSH
35226: LD_VAR 0 9
35230: PPUSH
35231: LD_VAR 0 3
35235: PPUSH
35236: CALL_OW 265
35240: PPUSH
35241: LD_VAR 0 3
35245: PPUSH
35246: CALL_OW 262
35250: PPUSH
35251: LD_VAR 0 3
35255: PPUSH
35256: CALL_OW 263
35260: PPUSH
35261: LD_VAR 0 3
35265: PPUSH
35266: CALL_OW 264
35270: PPUSH
35271: CALL 55315 0 5
35275: ST_TO_ADDR
// if components then
35276: LD_VAR 0 10
35280: IFFALSE 35298
// begin MC_InsertProduceList ( i , components ) ;
35282: LD_VAR 0 2
35286: PPUSH
35287: LD_VAR 0 10
35291: PPUSH
35292: CALL 44202 0 2
// break ;
35296: GO 35300
// end ; end ;
35298: GO 35218
35300: POP
35301: POP
// end ; continue ;
35302: GO 34798
// end ; end ; if GetCargo ( j , mat_cans ) < 100 and not HasTask ( j ) then
35304: LD_VAR 0 3
35308: PPUSH
35309: LD_INT 1
35311: PPUSH
35312: CALL_OW 289
35316: PUSH
35317: LD_INT 100
35319: LESS
35320: PUSH
35321: LD_VAR 0 3
35325: PPUSH
35326: CALL_OW 314
35330: NOT
35331: AND
35332: IFFALSE 35361
// ComCollect ( j , target [ 2 ] , target [ 3 ] ) ;
35334: LD_VAR 0 3
35338: PPUSH
35339: LD_VAR 0 6
35343: PUSH
35344: LD_INT 2
35346: ARRAY
35347: PPUSH
35348: LD_VAR 0 6
35352: PUSH
35353: LD_INT 3
35355: ARRAY
35356: PPUSH
35357: CALL_OW 117
// break ;
35361: GO 35365
// end ;
35363: GO 34798
35365: POP
35366: POP
// end ; end ;
35367: GO 33636
35369: POP
35370: POP
// end ;
35371: LD_VAR 0 1
35375: RET
// export function MC_LinkRemoteControl ( ) ; var i , j , tmp ; begin
35376: LD_INT 0
35378: PPUSH
35379: PPUSH
35380: PPUSH
35381: PPUSH
// if not mc_bases then
35382: LD_EXP 79
35386: NOT
35387: IFFALSE 35391
// exit ;
35389: GO 35552
// for i = 1 to mc_bases do
35391: LD_ADDR_VAR 0 2
35395: PUSH
35396: DOUBLE
35397: LD_INT 1
35399: DEC
35400: ST_TO_ADDR
35401: LD_EXP 79
35405: PUSH
35406: FOR_TO
35407: IFFALSE 35550
// begin tmp := UnitFilter ( mc_vehicles [ i ] union mc_defender [ i ] , [ f_control , control_remote ] ) ;
35409: LD_ADDR_VAR 0 4
35413: PUSH
35414: LD_EXP 98
35418: PUSH
35419: LD_VAR 0 2
35423: ARRAY
35424: PUSH
35425: LD_EXP 101
35429: PUSH
35430: LD_VAR 0 2
35434: ARRAY
35435: UNION
35436: PPUSH
35437: LD_INT 33
35439: PUSH
35440: LD_INT 2
35442: PUSH
35443: EMPTY
35444: LIST
35445: LIST
35446: PPUSH
35447: CALL_OW 72
35451: ST_TO_ADDR
// if tmp then
35452: LD_VAR 0 4
35456: IFFALSE 35548
// for j in tmp do
35458: LD_ADDR_VAR 0 3
35462: PUSH
35463: LD_VAR 0 4
35467: PUSH
35468: FOR_IN
35469: IFFALSE 35546
// if not IsControledBy ( j ) and GetLives ( j ) >= 250 then
35471: LD_VAR 0 3
35475: PPUSH
35476: CALL_OW 312
35480: NOT
35481: PUSH
35482: LD_VAR 0 3
35486: PPUSH
35487: CALL_OW 256
35491: PUSH
35492: LD_INT 250
35494: GREATEREQUAL
35495: AND
35496: IFFALSE 35509
// Connect ( j ) else
35498: LD_VAR 0 3
35502: PPUSH
35503: CALL 60716 0 1
35507: GO 35544
// if GetLives ( j ) < 250 and IsControledBy ( j ) then
35509: LD_VAR 0 3
35513: PPUSH
35514: CALL_OW 256
35518: PUSH
35519: LD_INT 250
35521: LESS
35522: PUSH
35523: LD_VAR 0 3
35527: PPUSH
35528: CALL_OW 312
35532: AND
35533: IFFALSE 35544
// ComUnlink ( j ) ;
35535: LD_VAR 0 3
35539: PPUSH
35540: CALL_OW 136
35544: GO 35468
35546: POP
35547: POP
// end ;
35548: GO 35406
35550: POP
35551: POP
// end ;
35552: LD_VAR 0 1
35556: RET
// export function MC_ProduceVehicle ( ) ; var i , j , tmp , fac ; begin
35557: LD_INT 0
35559: PPUSH
35560: PPUSH
35561: PPUSH
35562: PPUSH
35563: PPUSH
// if not mc_bases then
35564: LD_EXP 79
35568: NOT
35569: IFFALSE 35573
// exit ;
35571: GO 36018
// for i = 1 to mc_bases do
35573: LD_ADDR_VAR 0 2
35577: PUSH
35578: DOUBLE
35579: LD_INT 1
35581: DEC
35582: ST_TO_ADDR
35583: LD_EXP 79
35587: PUSH
35588: FOR_TO
35589: IFFALSE 36016
// begin if not mc_produce [ i ] then
35591: LD_EXP 100
35595: PUSH
35596: LD_VAR 0 2
35600: ARRAY
35601: NOT
35602: IFFALSE 35606
// continue ;
35604: GO 35588
// fac := UnitFilter ( mc_bases [ i ] , [ f_btype , b_factory ] ) ;
35606: LD_ADDR_VAR 0 5
35610: PUSH
35611: LD_EXP 79
35615: PUSH
35616: LD_VAR 0 2
35620: ARRAY
35621: PPUSH
35622: LD_INT 30
35624: PUSH
35625: LD_INT 3
35627: PUSH
35628: EMPTY
35629: LIST
35630: LIST
35631: PPUSH
35632: CALL_OW 72
35636: ST_TO_ADDR
// if not fac then
35637: LD_VAR 0 5
35641: NOT
35642: IFFALSE 35646
// continue ;
35644: GO 35588
// for j in fac do
35646: LD_ADDR_VAR 0 3
35650: PUSH
35651: LD_VAR 0 5
35655: PUSH
35656: FOR_IN
35657: IFFALSE 36012
// begin if BuildingStatus ( j ) <> bs_idle or DangerAtRange ( j , 15 ) [ 4 ] then
35659: LD_VAR 0 3
35663: PPUSH
35664: CALL_OW 461
35668: PUSH
35669: LD_INT 2
35671: NONEQUAL
35672: PUSH
35673: LD_VAR 0 3
35677: PPUSH
35678: LD_INT 15
35680: PPUSH
35681: CALL 60376 0 2
35685: PUSH
35686: LD_INT 4
35688: ARRAY
35689: OR
35690: IFFALSE 35694
// continue ;
35692: GO 35656
// if CanBeConstructed ( j , mc_produce [ i ] [ 1 ] [ 1 ] , mc_produce [ i ] [ 1 ] [ 2 ] , mc_produce [ i ] [ 1 ] [ 3 ] , mc_produce [ i ] [ 1 ] [ 4 ] ) and VehicleCost ( j , [ mc_produce [ i ] [ 1 ] [ 1 ] , mc_produce [ i ] [ 1 ] [ 2 ] , mc_produce [ i ] [ 1 ] [ 3 ] , mc_produce [ i ] [ 1 ] [ 4 ] ] ) then
35694: LD_VAR 0 3
35698: PPUSH
35699: LD_EXP 100
35703: PUSH
35704: LD_VAR 0 2
35708: ARRAY
35709: PUSH
35710: LD_INT 1
35712: ARRAY
35713: PUSH
35714: LD_INT 1
35716: ARRAY
35717: PPUSH
35718: LD_EXP 100
35722: PUSH
35723: LD_VAR 0 2
35727: ARRAY
35728: PUSH
35729: LD_INT 1
35731: ARRAY
35732: PUSH
35733: LD_INT 2
35735: ARRAY
35736: PPUSH
35737: LD_EXP 100
35741: PUSH
35742: LD_VAR 0 2
35746: ARRAY
35747: PUSH
35748: LD_INT 1
35750: ARRAY
35751: PUSH
35752: LD_INT 3
35754: ARRAY
35755: PPUSH
35756: LD_EXP 100
35760: PUSH
35761: LD_VAR 0 2
35765: ARRAY
35766: PUSH
35767: LD_INT 1
35769: ARRAY
35770: PUSH
35771: LD_INT 4
35773: ARRAY
35774: PPUSH
35775: CALL_OW 448
35779: PUSH
35780: LD_VAR 0 3
35784: PPUSH
35785: LD_EXP 100
35789: PUSH
35790: LD_VAR 0 2
35794: ARRAY
35795: PUSH
35796: LD_INT 1
35798: ARRAY
35799: PUSH
35800: LD_INT 1
35802: ARRAY
35803: PUSH
35804: LD_EXP 100
35808: PUSH
35809: LD_VAR 0 2
35813: ARRAY
35814: PUSH
35815: LD_INT 1
35817: ARRAY
35818: PUSH
35819: LD_INT 2
35821: ARRAY
35822: PUSH
35823: LD_EXP 100
35827: PUSH
35828: LD_VAR 0 2
35832: ARRAY
35833: PUSH
35834: LD_INT 1
35836: ARRAY
35837: PUSH
35838: LD_INT 3
35840: ARRAY
35841: PUSH
35842: LD_EXP 100
35846: PUSH
35847: LD_VAR 0 2
35851: ARRAY
35852: PUSH
35853: LD_INT 1
35855: ARRAY
35856: PUSH
35857: LD_INT 4
35859: ARRAY
35860: PUSH
35861: EMPTY
35862: LIST
35863: LIST
35864: LIST
35865: LIST
35866: PPUSH
35867: CALL 64047 0 2
35871: AND
35872: IFFALSE 36010
// begin AddComConstruct ( j , mc_produce [ i ] [ 1 ] [ 1 ] , mc_produce [ i ] [ 1 ] [ 2 ] , mc_produce [ i ] [ 1 ] [ 3 ] , mc_produce [ i ] [ 1 ] [ 4 ] ) ;
35874: LD_VAR 0 3
35878: PPUSH
35879: LD_EXP 100
35883: PUSH
35884: LD_VAR 0 2
35888: ARRAY
35889: PUSH
35890: LD_INT 1
35892: ARRAY
35893: PUSH
35894: LD_INT 1
35896: ARRAY
35897: PPUSH
35898: LD_EXP 100
35902: PUSH
35903: LD_VAR 0 2
35907: ARRAY
35908: PUSH
35909: LD_INT 1
35911: ARRAY
35912: PUSH
35913: LD_INT 2
35915: ARRAY
35916: PPUSH
35917: LD_EXP 100
35921: PUSH
35922: LD_VAR 0 2
35926: ARRAY
35927: PUSH
35928: LD_INT 1
35930: ARRAY
35931: PUSH
35932: LD_INT 3
35934: ARRAY
35935: PPUSH
35936: LD_EXP 100
35940: PUSH
35941: LD_VAR 0 2
35945: ARRAY
35946: PUSH
35947: LD_INT 1
35949: ARRAY
35950: PUSH
35951: LD_INT 4
35953: ARRAY
35954: PPUSH
35955: CALL_OW 185
// tmp := Delete ( mc_produce [ i ] , 1 ) ;
35959: LD_ADDR_VAR 0 4
35963: PUSH
35964: LD_EXP 100
35968: PUSH
35969: LD_VAR 0 2
35973: ARRAY
35974: PPUSH
35975: LD_INT 1
35977: PPUSH
35978: CALL_OW 3
35982: ST_TO_ADDR
// mc_produce := Replace ( mc_produce , i , tmp ) ;
35983: LD_ADDR_EXP 100
35987: PUSH
35988: LD_EXP 100
35992: PPUSH
35993: LD_VAR 0 2
35997: PPUSH
35998: LD_VAR 0 4
36002: PPUSH
36003: CALL_OW 1
36007: ST_TO_ADDR
// break ;
36008: GO 36012
// end ; end ;
36010: GO 35656
36012: POP
36013: POP
// end ;
36014: GO 35588
36016: POP
36017: POP
// end ;
36018: LD_VAR 0 1
36022: RET
// export function MC_SendAttack ( ) ; var i , tmp ; begin
36023: LD_INT 0
36025: PPUSH
36026: PPUSH
36027: PPUSH
// if not mc_bases then
36028: LD_EXP 79
36032: NOT
36033: IFFALSE 36037
// exit ;
36035: GO 36126
// for i = 1 to mc_bases do
36037: LD_ADDR_VAR 0 2
36041: PUSH
36042: DOUBLE
36043: LD_INT 1
36045: DEC
36046: ST_TO_ADDR
36047: LD_EXP 79
36051: PUSH
36052: FOR_TO
36053: IFFALSE 36124
// begin if mc_attack [ i ] then
36055: LD_EXP 99
36059: PUSH
36060: LD_VAR 0 2
36064: ARRAY
36065: IFFALSE 36122
// begin tmp := mc_attack [ i ] [ 1 ] ;
36067: LD_ADDR_VAR 0 3
36071: PUSH
36072: LD_EXP 99
36076: PUSH
36077: LD_VAR 0 2
36081: ARRAY
36082: PUSH
36083: LD_INT 1
36085: ARRAY
36086: ST_TO_ADDR
// mc_attack := Replace ( mc_attack , i , [ ] ) ;
36087: LD_ADDR_EXP 99
36091: PUSH
36092: LD_EXP 99
36096: PPUSH
36097: LD_VAR 0 2
36101: PPUSH
36102: EMPTY
36103: PPUSH
36104: CALL_OW 1
36108: ST_TO_ADDR
// Attack ( tmp ) ;
36109: LD_VAR 0 3
36113: PPUSH
36114: CALL 86237 0 1
// exit ;
36118: POP
36119: POP
36120: GO 36126
// end ; end ;
36122: GO 36052
36124: POP
36125: POP
// end ;
36126: LD_VAR 0 1
36130: RET
// export function MC_Defend ( ) ; var i , j , tmp , t , x , class ; begin
36131: LD_INT 0
36133: PPUSH
36134: PPUSH
36135: PPUSH
36136: PPUSH
36137: PPUSH
36138: PPUSH
36139: PPUSH
// if not mc_bases then
36140: LD_EXP 79
36144: NOT
36145: IFFALSE 36149
// exit ;
36147: GO 36731
// for i = 1 to mc_bases do
36149: LD_ADDR_VAR 0 2
36153: PUSH
36154: DOUBLE
36155: LD_INT 1
36157: DEC
36158: ST_TO_ADDR
36159: LD_EXP 79
36163: PUSH
36164: FOR_TO
36165: IFFALSE 36729
// begin if not mc_bases [ i ] then
36167: LD_EXP 79
36171: PUSH
36172: LD_VAR 0 2
36176: ARRAY
36177: NOT
36178: IFFALSE 36182
// continue ;
36180: GO 36164
// class := AllowSpecClass ( mc_bases [ i ] [ 1 ] ) ;
36182: LD_ADDR_VAR 0 7
36186: PUSH
36187: LD_EXP 79
36191: PUSH
36192: LD_VAR 0 2
36196: ARRAY
36197: PUSH
36198: LD_INT 1
36200: ARRAY
36201: PPUSH
36202: CALL 54619 0 1
36206: ST_TO_ADDR
// mc_scan := Replace ( mc_scan , i , ScanBase ( GetSide ( mc_bases [ i ] [ 1 ] ) , mc_scan_area [ i ] ) ) ;
36207: LD_ADDR_EXP 102
36211: PUSH
36212: LD_EXP 102
36216: PPUSH
36217: LD_VAR 0 2
36221: PPUSH
36222: LD_EXP 79
36226: PUSH
36227: LD_VAR 0 2
36231: ARRAY
36232: PUSH
36233: LD_INT 1
36235: ARRAY
36236: PPUSH
36237: CALL_OW 255
36241: PPUSH
36242: LD_EXP 104
36246: PUSH
36247: LD_VAR 0 2
36251: ARRAY
36252: PPUSH
36253: CALL 52173 0 2
36257: PPUSH
36258: CALL_OW 1
36262: ST_TO_ADDR
// if not mc_scan [ i ] then
36263: LD_EXP 102
36267: PUSH
36268: LD_VAR 0 2
36272: ARRAY
36273: NOT
36274: IFFALSE 36429
// begin tmp := UnitFilter ( mc_bases [ i ] , [ f_or , [ f_class , 5 ] , [ f_class , 8 ] , [ f_class , 9 ] ] ) ;
36276: LD_ADDR_VAR 0 4
36280: PUSH
36281: LD_EXP 79
36285: PUSH
36286: LD_VAR 0 2
36290: ARRAY
36291: PPUSH
36292: LD_INT 2
36294: PUSH
36295: LD_INT 25
36297: PUSH
36298: LD_INT 5
36300: PUSH
36301: EMPTY
36302: LIST
36303: LIST
36304: PUSH
36305: LD_INT 25
36307: PUSH
36308: LD_INT 8
36310: PUSH
36311: EMPTY
36312: LIST
36313: LIST
36314: PUSH
36315: LD_INT 25
36317: PUSH
36318: LD_INT 9
36320: PUSH
36321: EMPTY
36322: LIST
36323: LIST
36324: PUSH
36325: EMPTY
36326: LIST
36327: LIST
36328: LIST
36329: LIST
36330: PPUSH
36331: CALL_OW 72
36335: ST_TO_ADDR
// if not tmp then
36336: LD_VAR 0 4
36340: NOT
36341: IFFALSE 36345
// continue ;
36343: GO 36164
// for j in tmp do
36345: LD_ADDR_VAR 0 3
36349: PUSH
36350: LD_VAR 0 4
36354: PUSH
36355: FOR_IN
36356: IFFALSE 36427
// if GetBType ( IsInUnit ( j ) ) = b_barracks and GetClass ( j ) = 1 and not MineOfUnit ( j ) and class then
36358: LD_VAR 0 3
36362: PPUSH
36363: CALL_OW 310
36367: PPUSH
36368: CALL_OW 266
36372: PUSH
36373: LD_INT 5
36375: EQUAL
36376: PUSH
36377: LD_VAR 0 3
36381: PPUSH
36382: CALL_OW 257
36386: PUSH
36387: LD_INT 1
36389: EQUAL
36390: AND
36391: PUSH
36392: LD_VAR 0 3
36396: PPUSH
36397: CALL_OW 459
36401: NOT
36402: AND
36403: PUSH
36404: LD_VAR 0 7
36408: AND
36409: IFFALSE 36425
// ComChangeProfession ( j , class ) ;
36411: LD_VAR 0 3
36415: PPUSH
36416: LD_VAR 0 7
36420: PPUSH
36421: CALL_OW 123
36425: GO 36355
36427: POP
36428: POP
// end ; if mc_scan [ i ] and not mc_defender [ i ] and not UnitFilter ( mc_bases [ i ] , [ f_btype , b_bunker ] ) and not UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_armoury ] , [ f_btype , b_barracks ] ] ) then
36429: LD_EXP 102
36433: PUSH
36434: LD_VAR 0 2
36438: ARRAY
36439: PUSH
36440: LD_EXP 101
36444: PUSH
36445: LD_VAR 0 2
36449: ARRAY
36450: NOT
36451: AND
36452: PUSH
36453: LD_EXP 79
36457: PUSH
36458: LD_VAR 0 2
36462: ARRAY
36463: PPUSH
36464: LD_INT 30
36466: PUSH
36467: LD_INT 32
36469: PUSH
36470: EMPTY
36471: LIST
36472: LIST
36473: PPUSH
36474: CALL_OW 72
36478: NOT
36479: AND
36480: PUSH
36481: LD_EXP 79
36485: PUSH
36486: LD_VAR 0 2
36490: ARRAY
36491: PPUSH
36492: LD_INT 2
36494: PUSH
36495: LD_INT 30
36497: PUSH
36498: LD_INT 4
36500: PUSH
36501: EMPTY
36502: LIST
36503: LIST
36504: PUSH
36505: LD_INT 30
36507: PUSH
36508: LD_INT 5
36510: PUSH
36511: EMPTY
36512: LIST
36513: LIST
36514: PUSH
36515: EMPTY
36516: LIST
36517: LIST
36518: LIST
36519: PPUSH
36520: CALL_OW 72
36524: NOT
36525: AND
36526: IFFALSE 36658
// begin tmp := UnitFilter ( mc_bases [ i ] , [ f_or , [ f_class , 1 ] , [ f_class , 5 ] , [ f_class , 8 ] , [ f_class , 9 ] ] ) ;
36528: LD_ADDR_VAR 0 4
36532: PUSH
36533: LD_EXP 79
36537: PUSH
36538: LD_VAR 0 2
36542: ARRAY
36543: PPUSH
36544: LD_INT 2
36546: PUSH
36547: LD_INT 25
36549: PUSH
36550: LD_INT 1
36552: PUSH
36553: EMPTY
36554: LIST
36555: LIST
36556: PUSH
36557: LD_INT 25
36559: PUSH
36560: LD_INT 5
36562: PUSH
36563: EMPTY
36564: LIST
36565: LIST
36566: PUSH
36567: LD_INT 25
36569: PUSH
36570: LD_INT 8
36572: PUSH
36573: EMPTY
36574: LIST
36575: LIST
36576: PUSH
36577: LD_INT 25
36579: PUSH
36580: LD_INT 9
36582: PUSH
36583: EMPTY
36584: LIST
36585: LIST
36586: PUSH
36587: EMPTY
36588: LIST
36589: LIST
36590: LIST
36591: LIST
36592: LIST
36593: PPUSH
36594: CALL_OW 72
36598: ST_TO_ADDR
// tmp := tmp diff FilterByTag ( tmp , 18 ) ;
36599: LD_ADDR_VAR 0 4
36603: PUSH
36604: LD_VAR 0 4
36608: PUSH
36609: LD_VAR 0 4
36613: PPUSH
36614: LD_INT 18
36616: PPUSH
36617: CALL 91053 0 2
36621: DIFF
36622: ST_TO_ADDR
// if tmp then
36623: LD_VAR 0 4
36627: IFFALSE 36658
// begin BasicDefend ( i , tmp , mc_scan_area [ i ] ) ;
36629: LD_VAR 0 2
36633: PPUSH
36634: LD_VAR 0 4
36638: PPUSH
36639: LD_EXP 104
36643: PUSH
36644: LD_VAR 0 2
36648: ARRAY
36649: PPUSH
36650: CALL 52208 0 3
// exit ;
36654: POP
36655: POP
36656: GO 36731
// end ; end ; if mc_scan [ i ] and mc_defender [ i ] then
36658: LD_EXP 102
36662: PUSH
36663: LD_VAR 0 2
36667: ARRAY
36668: PUSH
36669: LD_EXP 101
36673: PUSH
36674: LD_VAR 0 2
36678: ARRAY
36679: AND
36680: IFFALSE 36727
// begin tmp := mc_defender [ i ] ;
36682: LD_ADDR_VAR 0 4
36686: PUSH
36687: LD_EXP 101
36691: PUSH
36692: LD_VAR 0 2
36696: ARRAY
36697: ST_TO_ADDR
// Defend ( i , tmp , mc_scan [ i ] ) ;
36698: LD_VAR 0 2
36702: PPUSH
36703: LD_VAR 0 4
36707: PPUSH
36708: LD_EXP 102
36712: PUSH
36713: LD_VAR 0 2
36717: ARRAY
36718: PPUSH
36719: CALL 52769 0 3
// exit ;
36723: POP
36724: POP
36725: GO 36731
// end ; end ;
36727: GO 36164
36729: POP
36730: POP
// end ;
36731: LD_VAR 0 1
36735: RET
// export function MC_Research ( ) ; var i , j , side , t , tmp , x , sci , tmp2 , researching , idle_lab ; begin
36736: LD_INT 0
36738: PPUSH
36739: PPUSH
36740: PPUSH
36741: PPUSH
36742: PPUSH
36743: PPUSH
36744: PPUSH
36745: PPUSH
36746: PPUSH
36747: PPUSH
36748: PPUSH
// if not mc_bases then
36749: LD_EXP 79
36753: NOT
36754: IFFALSE 36758
// exit ;
36756: GO 37845
// for i = 1 to mc_bases do
36758: LD_ADDR_VAR 0 2
36762: PUSH
36763: DOUBLE
36764: LD_INT 1
36766: DEC
36767: ST_TO_ADDR
36768: LD_EXP 79
36772: PUSH
36773: FOR_TO
36774: IFFALSE 37843
// begin tmp := mc_lab [ i ] ;
36776: LD_ADDR_VAR 0 6
36780: PUSH
36781: LD_EXP 112
36785: PUSH
36786: LD_VAR 0 2
36790: ARRAY
36791: ST_TO_ADDR
// if not tmp then
36792: LD_VAR 0 6
36796: NOT
36797: IFFALSE 36801
// continue ;
36799: GO 36773
// idle_lab := 0 ;
36801: LD_ADDR_VAR 0 11
36805: PUSH
36806: LD_INT 0
36808: ST_TO_ADDR
// for j in tmp do
36809: LD_ADDR_VAR 0 3
36813: PUSH
36814: LD_VAR 0 6
36818: PUSH
36819: FOR_IN
36820: IFFALSE 37839
// begin researching := false ;
36822: LD_ADDR_VAR 0 10
36826: PUSH
36827: LD_INT 0
36829: ST_TO_ADDR
// side := GetSide ( j ) ;
36830: LD_ADDR_VAR 0 4
36834: PUSH
36835: LD_VAR 0 3
36839: PPUSH
36840: CALL_OW 255
36844: ST_TO_ADDR
// if not mc_tech [ side ] then
36845: LD_EXP 106
36849: PUSH
36850: LD_VAR 0 4
36854: ARRAY
36855: NOT
36856: IFFALSE 36860
// continue ;
36858: GO 36819
// if BuildingStatus ( j ) = bs_idle then
36860: LD_VAR 0 3
36864: PPUSH
36865: CALL_OW 461
36869: PUSH
36870: LD_INT 2
36872: EQUAL
36873: IFFALSE 37061
// begin if idle_lab and UnitsInside ( j ) < 6 then
36875: LD_VAR 0 11
36879: PUSH
36880: LD_VAR 0 3
36884: PPUSH
36885: CALL_OW 313
36889: PUSH
36890: LD_INT 6
36892: LESS
36893: AND
36894: IFFALSE 36965
// begin tmp2 := UnitsInside ( idle_lab ) ;
36896: LD_ADDR_VAR 0 9
36900: PUSH
36901: LD_VAR 0 11
36905: PPUSH
36906: CALL_OW 313
36910: ST_TO_ADDR
// if tmp2 then
36911: LD_VAR 0 9
36915: IFFALSE 36957
// for x in tmp2 do
36917: LD_ADDR_VAR 0 7
36921: PUSH
36922: LD_VAR 0 9
36926: PUSH
36927: FOR_IN
36928: IFFALSE 36955
// begin ComExitBuilding ( x ) ;
36930: LD_VAR 0 7
36934: PPUSH
36935: CALL_OW 122
// AddComEnterUnit ( x , j ) ;
36939: LD_VAR 0 7
36943: PPUSH
36944: LD_VAR 0 3
36948: PPUSH
36949: CALL_OW 180
// end ;
36953: GO 36927
36955: POP
36956: POP
// idle_lab := 0 ;
36957: LD_ADDR_VAR 0 11
36961: PUSH
36962: LD_INT 0
36964: ST_TO_ADDR
// end ; for t in mc_tech [ side ] do
36965: LD_ADDR_VAR 0 5
36969: PUSH
36970: LD_EXP 106
36974: PUSH
36975: LD_VAR 0 4
36979: ARRAY
36980: PUSH
36981: FOR_IN
36982: IFFALSE 37042
// if CanBeResearched ( j , t ) and TechCanBeResearch ( side , t ) then
36984: LD_VAR 0 3
36988: PPUSH
36989: LD_VAR 0 5
36993: PPUSH
36994: CALL_OW 430
36998: PUSH
36999: LD_VAR 0 4
37003: PPUSH
37004: LD_VAR 0 5
37008: PPUSH
37009: CALL 51278 0 2
37013: AND
37014: IFFALSE 37040
// begin researching := true ;
37016: LD_ADDR_VAR 0 10
37020: PUSH
37021: LD_INT 1
37023: ST_TO_ADDR
// ComResearch ( j , t ) ;
37024: LD_VAR 0 3
37028: PPUSH
37029: LD_VAR 0 5
37033: PPUSH
37034: CALL_OW 124
// break ;
37038: GO 37042
// end ;
37040: GO 36981
37042: POP
37043: POP
// if not researching then
37044: LD_VAR 0 10
37048: NOT
37049: IFFALSE 37061
// idle_lab := j ;
37051: LD_ADDR_VAR 0 11
37055: PUSH
37056: LD_VAR 0 3
37060: ST_TO_ADDR
// end ; if BuildingStatus ( j ) = bs_need_ape then
37061: LD_VAR 0 3
37065: PPUSH
37066: CALL_OW 461
37070: PUSH
37071: LD_INT 10
37073: EQUAL
37074: IFFALSE 37662
// begin if not mc_ape [ i ] and not mc_ape_in_lab [ i ] and mc_tech [ side ] > 1 then
37076: LD_EXP 108
37080: PUSH
37081: LD_VAR 0 2
37085: ARRAY
37086: NOT
37087: PUSH
37088: LD_EXP 109
37092: PUSH
37093: LD_VAR 0 2
37097: ARRAY
37098: NOT
37099: AND
37100: PUSH
37101: LD_EXP 106
37105: PUSH
37106: LD_VAR 0 4
37110: ARRAY
37111: PUSH
37112: LD_INT 1
37114: GREATER
37115: AND
37116: IFFALSE 37247
// begin ComCancel ( j ) ;
37118: LD_VAR 0 3
37122: PPUSH
37123: CALL_OW 127
// mc_tech := Replace ( mc_tech , side , Reindex ( mc_tech [ side ] , mc_tech [ side ] - 1 , mc_tech [ side ] , false ) ) ;
37127: LD_ADDR_EXP 106
37131: PUSH
37132: LD_EXP 106
37136: PPUSH
37137: LD_VAR 0 4
37141: PPUSH
37142: LD_EXP 106
37146: PUSH
37147: LD_VAR 0 4
37151: ARRAY
37152: PPUSH
37153: LD_EXP 106
37157: PUSH
37158: LD_VAR 0 4
37162: ARRAY
37163: PUSH
37164: LD_INT 1
37166: MINUS
37167: PPUSH
37168: LD_EXP 106
37172: PUSH
37173: LD_VAR 0 4
37177: ARRAY
37178: PPUSH
37179: LD_INT 0
37181: PPUSH
37182: CALL 57201 0 4
37186: PPUSH
37187: CALL_OW 1
37191: ST_TO_ADDR
// mc_tech := Replace ( mc_tech , side , Reindex ( mc_tech [ side ] , mc_tech [ side ] , 1 , false ) ) ;
37192: LD_ADDR_EXP 106
37196: PUSH
37197: LD_EXP 106
37201: PPUSH
37202: LD_VAR 0 4
37206: PPUSH
37207: LD_EXP 106
37211: PUSH
37212: LD_VAR 0 4
37216: ARRAY
37217: PPUSH
37218: LD_EXP 106
37222: PUSH
37223: LD_VAR 0 4
37227: ARRAY
37228: PPUSH
37229: LD_INT 1
37231: PPUSH
37232: LD_INT 0
37234: PPUSH
37235: CALL 57201 0 4
37239: PPUSH
37240: CALL_OW 1
37244: ST_TO_ADDR
// continue ;
37245: GO 36819
// end ; if mc_ape [ i ] and not mc_ape_in_lab [ i ] then
37247: LD_EXP 108
37251: PUSH
37252: LD_VAR 0 2
37256: ARRAY
37257: PUSH
37258: LD_EXP 109
37262: PUSH
37263: LD_VAR 0 2
37267: ARRAY
37268: NOT
37269: AND
37270: IFFALSE 37397
// begin mc_ape_in_lab := ReplaceIn ( mc_ape_in_lab , [ i , mc_ape_in_lab [ i ] + 1 ] , mc_ape [ i ] [ 1 ] ) ;
37272: LD_ADDR_EXP 109
37276: PUSH
37277: LD_EXP 109
37281: PPUSH
37282: LD_VAR 0 2
37286: PUSH
37287: LD_EXP 109
37291: PUSH
37292: LD_VAR 0 2
37296: ARRAY
37297: PUSH
37298: LD_INT 1
37300: PLUS
37301: PUSH
37302: EMPTY
37303: LIST
37304: LIST
37305: PPUSH
37306: LD_EXP 108
37310: PUSH
37311: LD_VAR 0 2
37315: ARRAY
37316: PUSH
37317: LD_INT 1
37319: ARRAY
37320: PPUSH
37321: CALL 57783 0 3
37325: ST_TO_ADDR
// SetTag ( mc_ape [ i ] [ 1 ] , 112 ) ;
37326: LD_EXP 108
37330: PUSH
37331: LD_VAR 0 2
37335: ARRAY
37336: PUSH
37337: LD_INT 1
37339: ARRAY
37340: PPUSH
37341: LD_INT 112
37343: PPUSH
37344: CALL_OW 109
// tmp2 := Delete ( mc_ape [ i ] , 1 ) ;
37348: LD_ADDR_VAR 0 9
37352: PUSH
37353: LD_EXP 108
37357: PUSH
37358: LD_VAR 0 2
37362: ARRAY
37363: PPUSH
37364: LD_INT 1
37366: PPUSH
37367: CALL_OW 3
37371: ST_TO_ADDR
// mc_ape := Replace ( mc_ape , i , tmp2 ) ;
37372: LD_ADDR_EXP 108
37376: PUSH
37377: LD_EXP 108
37381: PPUSH
37382: LD_VAR 0 2
37386: PPUSH
37387: LD_VAR 0 9
37391: PPUSH
37392: CALL_OW 1
37396: ST_TO_ADDR
// end ; if mc_ape [ i ] and mc_ape_in_lab [ i ] and not IsInUnit ( mc_ape_in_lab [ i ] [ 1 ] ) and UnitsInside ( j ) = 6 then
37397: LD_EXP 108
37401: PUSH
37402: LD_VAR 0 2
37406: ARRAY
37407: PUSH
37408: LD_EXP 109
37412: PUSH
37413: LD_VAR 0 2
37417: ARRAY
37418: AND
37419: PUSH
37420: LD_EXP 109
37424: PUSH
37425: LD_VAR 0 2
37429: ARRAY
37430: PUSH
37431: LD_INT 1
37433: ARRAY
37434: PPUSH
37435: CALL_OW 310
37439: NOT
37440: AND
37441: PUSH
37442: LD_VAR 0 3
37446: PPUSH
37447: CALL_OW 313
37451: PUSH
37452: LD_INT 6
37454: EQUAL
37455: AND
37456: IFFALSE 37512
// begin tmp2 := UnitsInside ( j ) ;
37458: LD_ADDR_VAR 0 9
37462: PUSH
37463: LD_VAR 0 3
37467: PPUSH
37468: CALL_OW 313
37472: ST_TO_ADDR
// if tmp2 = 6 then
37473: LD_VAR 0 9
37477: PUSH
37478: LD_INT 6
37480: EQUAL
37481: IFFALSE 37512
// begin SetTag ( tmp2 [ 1 ] , 112 ) ;
37483: LD_VAR 0 9
37487: PUSH
37488: LD_INT 1
37490: ARRAY
37491: PPUSH
37492: LD_INT 112
37494: PPUSH
37495: CALL_OW 109
// ComExitBuilding ( tmp2 [ 1 ] ) ;
37499: LD_VAR 0 9
37503: PUSH
37504: LD_INT 1
37506: ARRAY
37507: PPUSH
37508: CALL_OW 122
// end ; end ; if mc_ape_in_lab [ i ] and not HasTask ( mc_ape_in_lab [ i ] [ 1 ] ) and not IsInUnit ( mc_ape_in_lab [ i ] [ 1 ] ) then
37512: LD_EXP 109
37516: PUSH
37517: LD_VAR 0 2
37521: ARRAY
37522: PUSH
37523: LD_EXP 109
37527: PUSH
37528: LD_VAR 0 2
37532: ARRAY
37533: PUSH
37534: LD_INT 1
37536: ARRAY
37537: PPUSH
37538: CALL_OW 314
37542: NOT
37543: AND
37544: PUSH
37545: LD_EXP 109
37549: PUSH
37550: LD_VAR 0 2
37554: ARRAY
37555: PUSH
37556: LD_INT 1
37558: ARRAY
37559: PPUSH
37560: CALL_OW 310
37564: NOT
37565: AND
37566: IFFALSE 37592
// ComEnterUnit ( mc_ape_in_lab [ i ] [ 1 ] , j ) ;
37568: LD_EXP 109
37572: PUSH
37573: LD_VAR 0 2
37577: ARRAY
37578: PUSH
37579: LD_INT 1
37581: ARRAY
37582: PPUSH
37583: LD_VAR 0 3
37587: PPUSH
37588: CALL_OW 120
// if IsInUnit ( mc_ape_in_lab [ i ] [ 1 ] ) and BuildingStatus ( IsInUnit ( mc_ape_in_lab [ i ] [ 1 ] ) ) <> bs_working then
37592: LD_EXP 109
37596: PUSH
37597: LD_VAR 0 2
37601: ARRAY
37602: PUSH
37603: LD_INT 1
37605: ARRAY
37606: PPUSH
37607: CALL_OW 310
37611: PUSH
37612: LD_EXP 109
37616: PUSH
37617: LD_VAR 0 2
37621: ARRAY
37622: PUSH
37623: LD_INT 1
37625: ARRAY
37626: PPUSH
37627: CALL_OW 310
37631: PPUSH
37632: CALL_OW 461
37636: PUSH
37637: LD_INT 3
37639: NONEQUAL
37640: AND
37641: IFFALSE 37662
// ComExitBuilding ( mc_ape_in_lab [ i ] [ 1 ] ) ;
37643: LD_EXP 109
37647: PUSH
37648: LD_VAR 0 2
37652: ARRAY
37653: PUSH
37654: LD_INT 1
37656: ARRAY
37657: PPUSH
37658: CALL_OW 122
// end ; if BuildingStatus ( j ) = bs_need_people and tmp > 1 then
37662: LD_VAR 0 3
37666: PPUSH
37667: CALL_OW 461
37671: PUSH
37672: LD_INT 6
37674: EQUAL
37675: PUSH
37676: LD_VAR 0 6
37680: PUSH
37681: LD_INT 1
37683: GREATER
37684: AND
37685: IFFALSE 37837
// begin sci := [ ] ;
37687: LD_ADDR_VAR 0 8
37691: PUSH
37692: EMPTY
37693: ST_TO_ADDR
// for x in ( tmp diff j ) do
37694: LD_ADDR_VAR 0 7
37698: PUSH
37699: LD_VAR 0 6
37703: PUSH
37704: LD_VAR 0 3
37708: DIFF
37709: PUSH
37710: FOR_IN
37711: IFFALSE 37763
// begin if sci = 6 then
37713: LD_VAR 0 8
37717: PUSH
37718: LD_INT 6
37720: EQUAL
37721: IFFALSE 37725
// break ;
37723: GO 37763
// if BuildingStatus ( x ) = bs_idle then
37725: LD_VAR 0 7
37729: PPUSH
37730: CALL_OW 461
37734: PUSH
37735: LD_INT 2
37737: EQUAL
37738: IFFALSE 37761
// sci := sci ^ UnitsInside ( x ) ;
37740: LD_ADDR_VAR 0 8
37744: PUSH
37745: LD_VAR 0 8
37749: PUSH
37750: LD_VAR 0 7
37754: PPUSH
37755: CALL_OW 313
37759: ADD
37760: ST_TO_ADDR
// end ;
37761: GO 37710
37763: POP
37764: POP
// if not sci then
37765: LD_VAR 0 8
37769: NOT
37770: IFFALSE 37774
// continue ;
37772: GO 36819
// for x in sci do
37774: LD_ADDR_VAR 0 7
37778: PUSH
37779: LD_VAR 0 8
37783: PUSH
37784: FOR_IN
37785: IFFALSE 37835
// if IsInUnit ( x ) and not HasTask ( x ) then
37787: LD_VAR 0 7
37791: PPUSH
37792: CALL_OW 310
37796: PUSH
37797: LD_VAR 0 7
37801: PPUSH
37802: CALL_OW 314
37806: NOT
37807: AND
37808: IFFALSE 37833
// begin ComExitBuilding ( x ) ;
37810: LD_VAR 0 7
37814: PPUSH
37815: CALL_OW 122
// AddComEnterUnit ( x , j ) ;
37819: LD_VAR 0 7
37823: PPUSH
37824: LD_VAR 0 3
37828: PPUSH
37829: CALL_OW 180
// end ;
37833: GO 37784
37835: POP
37836: POP
// end ; end ;
37837: GO 36819
37839: POP
37840: POP
// end ;
37841: GO 36773
37843: POP
37844: POP
// end ;
37845: LD_VAR 0 1
37849: RET
// export function MC_MinesTrigger ( ) ; var i ; begin
37850: LD_INT 0
37852: PPUSH
37853: PPUSH
// if not mc_bases then
37854: LD_EXP 79
37858: NOT
37859: IFFALSE 37863
// exit ;
37861: GO 37944
// for i = 1 to mc_bases do
37863: LD_ADDR_VAR 0 2
37867: PUSH
37868: DOUBLE
37869: LD_INT 1
37871: DEC
37872: ST_TO_ADDR
37873: LD_EXP 79
37877: PUSH
37878: FOR_TO
37879: IFFALSE 37942
// if mc_mines [ i ] and mc_miners [ i ] then
37881: LD_EXP 92
37885: PUSH
37886: LD_VAR 0 2
37890: ARRAY
37891: PUSH
37892: LD_EXP 93
37896: PUSH
37897: LD_VAR 0 2
37901: ARRAY
37902: AND
37903: IFFALSE 37940
// DetonateMines ( GetSide ( mc_miners [ i ] [ 1 ] ) , mc_mines [ i ] ) ;
37905: LD_EXP 93
37909: PUSH
37910: LD_VAR 0 2
37914: ARRAY
37915: PUSH
37916: LD_INT 1
37918: ARRAY
37919: PPUSH
37920: CALL_OW 255
37924: PPUSH
37925: LD_EXP 92
37929: PUSH
37930: LD_VAR 0 2
37934: ARRAY
37935: PPUSH
37936: CALL 54772 0 2
37940: GO 37878
37942: POP
37943: POP
// end ;
37944: LD_VAR 0 1
37948: RET
// export function MC_RepairVehicle ( ) ; var i , j , k , side , fac , vehs , tmp ; begin
37949: LD_INT 0
37951: PPUSH
37952: PPUSH
37953: PPUSH
37954: PPUSH
37955: PPUSH
37956: PPUSH
37957: PPUSH
37958: PPUSH
// if not mc_bases or not mc_parking then
37959: LD_EXP 79
37963: NOT
37964: PUSH
37965: LD_EXP 103
37969: NOT
37970: OR
37971: IFFALSE 37975
// exit ;
37973: GO 38674
// for i = 1 to mc_bases do
37975: LD_ADDR_VAR 0 2
37979: PUSH
37980: DOUBLE
37981: LD_INT 1
37983: DEC
37984: ST_TO_ADDR
37985: LD_EXP 79
37989: PUSH
37990: FOR_TO
37991: IFFALSE 38672
// begin if not mc_bases [ i ] or not mc_parking [ i ] then
37993: LD_EXP 79
37997: PUSH
37998: LD_VAR 0 2
38002: ARRAY
38003: NOT
38004: PUSH
38005: LD_EXP 103
38009: PUSH
38010: LD_VAR 0 2
38014: ARRAY
38015: NOT
38016: OR
38017: IFFALSE 38021
// continue ;
38019: GO 37990
// side := GetSide ( mc_bases [ i ] [ 1 ] ) ;
38021: LD_ADDR_VAR 0 5
38025: PUSH
38026: LD_EXP 79
38030: PUSH
38031: LD_VAR 0 2
38035: ARRAY
38036: PUSH
38037: LD_INT 1
38039: ARRAY
38040: PPUSH
38041: CALL_OW 255
38045: ST_TO_ADDR
// fac := UnitFilter ( mc_bases [ i ] , [ f_btype , b_factory ] ) ;
38046: LD_ADDR_VAR 0 6
38050: PUSH
38051: LD_EXP 79
38055: PUSH
38056: LD_VAR 0 2
38060: ARRAY
38061: PPUSH
38062: LD_INT 30
38064: PUSH
38065: LD_INT 3
38067: PUSH
38068: EMPTY
38069: LIST
38070: LIST
38071: PPUSH
38072: CALL_OW 72
38076: ST_TO_ADDR
// if not fac then
38077: LD_VAR 0 6
38081: NOT
38082: IFFALSE 38133
// fac := UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) ;
38084: LD_ADDR_VAR 0 6
38088: PUSH
38089: LD_EXP 79
38093: PUSH
38094: LD_VAR 0 2
38098: ARRAY
38099: PPUSH
38100: LD_INT 2
38102: PUSH
38103: LD_INT 30
38105: PUSH
38106: LD_INT 0
38108: PUSH
38109: EMPTY
38110: LIST
38111: LIST
38112: PUSH
38113: LD_INT 30
38115: PUSH
38116: LD_INT 1
38118: PUSH
38119: EMPTY
38120: LIST
38121: LIST
38122: PUSH
38123: EMPTY
38124: LIST
38125: LIST
38126: LIST
38127: PPUSH
38128: CALL_OW 72
38132: ST_TO_ADDR
// if not fac then
38133: LD_VAR 0 6
38137: NOT
38138: IFFALSE 38142
// continue ;
38140: GO 37990
// vehs := FilterUnitsInArea ( mc_parking [ i ] , [ [ f_side , side ] , [ f_type , unit_vehicle ] , [ f_not , [ f_lives , 1000 ] ] ] ) ;
38142: LD_ADDR_VAR 0 7
38146: PUSH
38147: LD_EXP 103
38151: PUSH
38152: LD_VAR 0 2
38156: ARRAY
38157: PPUSH
38158: LD_INT 22
38160: PUSH
38161: LD_VAR 0 5
38165: PUSH
38166: EMPTY
38167: LIST
38168: LIST
38169: PUSH
38170: LD_INT 21
38172: PUSH
38173: LD_INT 2
38175: PUSH
38176: EMPTY
38177: LIST
38178: LIST
38179: PUSH
38180: LD_INT 3
38182: PUSH
38183: LD_INT 24
38185: PUSH
38186: LD_INT 1000
38188: PUSH
38189: EMPTY
38190: LIST
38191: LIST
38192: PUSH
38193: EMPTY
38194: LIST
38195: LIST
38196: PUSH
38197: EMPTY
38198: LIST
38199: LIST
38200: LIST
38201: PPUSH
38202: CALL_OW 70
38206: ST_TO_ADDR
// for j in fac do
38207: LD_ADDR_VAR 0 3
38211: PUSH
38212: LD_VAR 0 6
38216: PUSH
38217: FOR_IN
38218: IFFALSE 38299
// vehs := vehs union FilterAllUnits ( [ [ f_side , side ] , [ f_dist , j , 15 ] , [ f_type , unit_vehicle ] , [ f_not , [ f_lives , 1000 ] ] ] ) ;
38220: LD_ADDR_VAR 0 7
38224: PUSH
38225: LD_VAR 0 7
38229: PUSH
38230: LD_INT 22
38232: PUSH
38233: LD_VAR 0 5
38237: PUSH
38238: EMPTY
38239: LIST
38240: LIST
38241: PUSH
38242: LD_INT 91
38244: PUSH
38245: LD_VAR 0 3
38249: PUSH
38250: LD_INT 15
38252: PUSH
38253: EMPTY
38254: LIST
38255: LIST
38256: LIST
38257: PUSH
38258: LD_INT 21
38260: PUSH
38261: LD_INT 2
38263: PUSH
38264: EMPTY
38265: LIST
38266: LIST
38267: PUSH
38268: LD_INT 3
38270: PUSH
38271: LD_INT 24
38273: PUSH
38274: LD_INT 1000
38276: PUSH
38277: EMPTY
38278: LIST
38279: LIST
38280: PUSH
38281: EMPTY
38282: LIST
38283: LIST
38284: PUSH
38285: EMPTY
38286: LIST
38287: LIST
38288: LIST
38289: LIST
38290: PPUSH
38291: CALL_OW 69
38295: UNION
38296: ST_TO_ADDR
38297: GO 38217
38299: POP
38300: POP
// if not vehs then
38301: LD_VAR 0 7
38305: NOT
38306: IFFALSE 38332
// begin mc_repair_vehicle := Replace ( mc_repair_vehicle , i , [ ] ) ;
38308: LD_ADDR_EXP 91
38312: PUSH
38313: LD_EXP 91
38317: PPUSH
38318: LD_VAR 0 2
38322: PPUSH
38323: EMPTY
38324: PPUSH
38325: CALL_OW 1
38329: ST_TO_ADDR
// continue ;
38330: GO 37990
// end ; tmp := UnitFilter ( mc_bases [ i ] , [ f_btype , b_factory ] ) ;
38332: LD_ADDR_VAR 0 8
38336: PUSH
38337: LD_EXP 79
38341: PUSH
38342: LD_VAR 0 2
38346: ARRAY
38347: PPUSH
38348: LD_INT 30
38350: PUSH
38351: LD_INT 3
38353: PUSH
38354: EMPTY
38355: LIST
38356: LIST
38357: PPUSH
38358: CALL_OW 72
38362: ST_TO_ADDR
// if tmp then
38363: LD_VAR 0 8
38367: IFFALSE 38470
// begin for j in tmp do
38369: LD_ADDR_VAR 0 3
38373: PUSH
38374: LD_VAR 0 8
38378: PUSH
38379: FOR_IN
38380: IFFALSE 38468
// for k in UnitsInside ( j ) do
38382: LD_ADDR_VAR 0 4
38386: PUSH
38387: LD_VAR 0 3
38391: PPUSH
38392: CALL_OW 313
38396: PUSH
38397: FOR_IN
38398: IFFALSE 38464
// if k then
38400: LD_VAR 0 4
38404: IFFALSE 38462
// if not k in mc_repair_vehicle [ i ] then
38406: LD_VAR 0 4
38410: PUSH
38411: LD_EXP 91
38415: PUSH
38416: LD_VAR 0 2
38420: ARRAY
38421: IN
38422: NOT
38423: IFFALSE 38462
// mc_repair_vehicle := Replace ( mc_repair_vehicle , i , mc_repair_vehicle [ i ] union k ) ;
38425: LD_ADDR_EXP 91
38429: PUSH
38430: LD_EXP 91
38434: PPUSH
38435: LD_VAR 0 2
38439: PPUSH
38440: LD_EXP 91
38444: PUSH
38445: LD_VAR 0 2
38449: ARRAY
38450: PUSH
38451: LD_VAR 0 4
38455: UNION
38456: PPUSH
38457: CALL_OW 1
38461: ST_TO_ADDR
38462: GO 38397
38464: POP
38465: POP
38466: GO 38379
38468: POP
38469: POP
// end ; if not mc_repair_vehicle [ i ] then
38470: LD_EXP 91
38474: PUSH
38475: LD_VAR 0 2
38479: ARRAY
38480: NOT
38481: IFFALSE 38485
// continue ;
38483: GO 37990
// for j in mc_repair_vehicle [ i ] do
38485: LD_ADDR_VAR 0 3
38489: PUSH
38490: LD_EXP 91
38494: PUSH
38495: LD_VAR 0 2
38499: ARRAY
38500: PUSH
38501: FOR_IN
38502: IFFALSE 38668
// begin if GetClass ( j ) <> 3 then
38504: LD_VAR 0 3
38508: PPUSH
38509: CALL_OW 257
38513: PUSH
38514: LD_INT 3
38516: NONEQUAL
38517: IFFALSE 38558
// begin mc_repair_vehicle := Replace ( mc_repair_vehicle , i , mc_repair_vehicle [ i ] diff j ) ;
38519: LD_ADDR_EXP 91
38523: PUSH
38524: LD_EXP 91
38528: PPUSH
38529: LD_VAR 0 2
38533: PPUSH
38534: LD_EXP 91
38538: PUSH
38539: LD_VAR 0 2
38543: ARRAY
38544: PUSH
38545: LD_VAR 0 3
38549: DIFF
38550: PPUSH
38551: CALL_OW 1
38555: ST_TO_ADDR
// continue ;
38556: GO 38501
// end ; if not IsDrivenBy ( j ) and not j in mc_need_heal [ i ] [ 1 ] and not j in mc_need_heal [ i ] [ 2 ] then
38558: LD_VAR 0 3
38562: PPUSH
38563: CALL_OW 311
38567: NOT
38568: PUSH
38569: LD_VAR 0 3
38573: PUSH
38574: LD_EXP 82
38578: PUSH
38579: LD_VAR 0 2
38583: ARRAY
38584: PUSH
38585: LD_INT 1
38587: ARRAY
38588: IN
38589: NOT
38590: AND
38591: PUSH
38592: LD_VAR 0 3
38596: PUSH
38597: LD_EXP 82
38601: PUSH
38602: LD_VAR 0 2
38606: ARRAY
38607: PUSH
38608: LD_INT 2
38610: ARRAY
38611: IN
38612: NOT
38613: AND
38614: IFFALSE 38666
// begin if IsInUnit ( j ) then
38616: LD_VAR 0 3
38620: PPUSH
38621: CALL_OW 310
38625: IFFALSE 38636
// ComExitBuilding ( j ) ;
38627: LD_VAR 0 3
38631: PPUSH
38632: CALL_OW 122
// if not HasTask ( j ) then
38636: LD_VAR 0 3
38640: PPUSH
38641: CALL_OW 314
38645: NOT
38646: IFFALSE 38666
// AddComRepairVehicle ( j , vehs [ 1 ] ) ;
38648: LD_VAR 0 3
38652: PPUSH
38653: LD_VAR 0 7
38657: PUSH
38658: LD_INT 1
38660: ARRAY
38661: PPUSH
38662: CALL_OW 189
// end ; end ;
38666: GO 38501
38668: POP
38669: POP
// end ;
38670: GO 37990
38672: POP
38673: POP
// end ;
38674: LD_VAR 0 1
38678: RET
// export function MC_TameApe ( ) ; var i , j , x , y , ape , apes , tmp , dep , danger_at_area , side ; begin
38679: LD_INT 0
38681: PPUSH
38682: PPUSH
38683: PPUSH
38684: PPUSH
38685: PPUSH
38686: PPUSH
38687: PPUSH
38688: PPUSH
38689: PPUSH
38690: PPUSH
38691: PPUSH
// if not mc_bases then
38692: LD_EXP 79
38696: NOT
38697: IFFALSE 38701
// exit ;
38699: GO 39503
// for i = 1 to mc_bases do
38701: LD_ADDR_VAR 0 2
38705: PUSH
38706: DOUBLE
38707: LD_INT 1
38709: DEC
38710: ST_TO_ADDR
38711: LD_EXP 79
38715: PUSH
38716: FOR_TO
38717: IFFALSE 39501
// begin if not mc_can_tame [ i ] or mc_need_heal [ i ] [ 1 ] or mc_need_heal [ i ] [ 2 ] or not Researched ( mc_sides [ i ] , tech_apelang ) or mc_scan [ i ] then
38719: LD_EXP 107
38723: PUSH
38724: LD_VAR 0 2
38728: ARRAY
38729: NOT
38730: PUSH
38731: LD_EXP 82
38735: PUSH
38736: LD_VAR 0 2
38740: ARRAY
38741: PUSH
38742: LD_INT 1
38744: ARRAY
38745: OR
38746: PUSH
38747: LD_EXP 82
38751: PUSH
38752: LD_VAR 0 2
38756: ARRAY
38757: PUSH
38758: LD_INT 2
38760: ARRAY
38761: OR
38762: PUSH
38763: LD_EXP 105
38767: PUSH
38768: LD_VAR 0 2
38772: ARRAY
38773: PPUSH
38774: LD_INT 1
38776: PPUSH
38777: CALL_OW 325
38781: NOT
38782: OR
38783: PUSH
38784: LD_EXP 102
38788: PUSH
38789: LD_VAR 0 2
38793: ARRAY
38794: OR
38795: IFFALSE 38799
// continue ;
38797: GO 38716
// tmp := UnitFilter ( mc_bases [ i ] , [ [ f_class , 4 ] , [ f_ok ] , [ f_not , [ f_hastask ] ] ] ) diff mc_healers [ i ] ;
38799: LD_ADDR_VAR 0 8
38803: PUSH
38804: LD_EXP 79
38808: PUSH
38809: LD_VAR 0 2
38813: ARRAY
38814: PPUSH
38815: LD_INT 25
38817: PUSH
38818: LD_INT 4
38820: PUSH
38821: EMPTY
38822: LIST
38823: LIST
38824: PUSH
38825: LD_INT 50
38827: PUSH
38828: EMPTY
38829: LIST
38830: PUSH
38831: LD_INT 3
38833: PUSH
38834: LD_INT 60
38836: PUSH
38837: EMPTY
38838: LIST
38839: PUSH
38840: EMPTY
38841: LIST
38842: LIST
38843: PUSH
38844: EMPTY
38845: LIST
38846: LIST
38847: LIST
38848: PPUSH
38849: CALL_OW 72
38853: PUSH
38854: LD_EXP 83
38858: PUSH
38859: LD_VAR 0 2
38863: ARRAY
38864: DIFF
38865: ST_TO_ADDR
// dep := UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) ;
38866: LD_ADDR_VAR 0 9
38870: PUSH
38871: LD_EXP 79
38875: PUSH
38876: LD_VAR 0 2
38880: ARRAY
38881: PPUSH
38882: LD_INT 2
38884: PUSH
38885: LD_INT 30
38887: PUSH
38888: LD_INT 0
38890: PUSH
38891: EMPTY
38892: LIST
38893: LIST
38894: PUSH
38895: LD_INT 30
38897: PUSH
38898: LD_INT 1
38900: PUSH
38901: EMPTY
38902: LIST
38903: LIST
38904: PUSH
38905: EMPTY
38906: LIST
38907: LIST
38908: LIST
38909: PPUSH
38910: CALL_OW 72
38914: ST_TO_ADDR
// if not tmp or not dep then
38915: LD_VAR 0 8
38919: NOT
38920: PUSH
38921: LD_VAR 0 9
38925: NOT
38926: OR
38927: IFFALSE 38931
// continue ;
38929: GO 38716
// side := GetSide ( tmp [ 1 ] ) ;
38931: LD_ADDR_VAR 0 11
38935: PUSH
38936: LD_VAR 0 8
38940: PUSH
38941: LD_INT 1
38943: ARRAY
38944: PPUSH
38945: CALL_OW 255
38949: ST_TO_ADDR
// dep := dep [ 1 ] ;
38950: LD_ADDR_VAR 0 9
38954: PUSH
38955: LD_VAR 0 9
38959: PUSH
38960: LD_INT 1
38962: ARRAY
38963: ST_TO_ADDR
// apes := FilterUnitsInArea ( mc_can_tame [ i ] , [ [ f_side , 0 ] , [ f_class , class_apeman ] ] ) union FilterAllUnits ( [ [ f_side , 0 ] , [ f_class , class_apeman ] , [ f_dist , dep , 20 ] ] ) ;
38964: LD_ADDR_VAR 0 7
38968: PUSH
38969: LD_EXP 107
38973: PUSH
38974: LD_VAR 0 2
38978: ARRAY
38979: PPUSH
38980: LD_INT 22
38982: PUSH
38983: LD_INT 0
38985: PUSH
38986: EMPTY
38987: LIST
38988: LIST
38989: PUSH
38990: LD_INT 25
38992: PUSH
38993: LD_INT 12
38995: PUSH
38996: EMPTY
38997: LIST
38998: LIST
38999: PUSH
39000: EMPTY
39001: LIST
39002: LIST
39003: PPUSH
39004: CALL_OW 70
39008: PUSH
39009: LD_INT 22
39011: PUSH
39012: LD_INT 0
39014: PUSH
39015: EMPTY
39016: LIST
39017: LIST
39018: PUSH
39019: LD_INT 25
39021: PUSH
39022: LD_INT 12
39024: PUSH
39025: EMPTY
39026: LIST
39027: LIST
39028: PUSH
39029: LD_INT 91
39031: PUSH
39032: LD_VAR 0 9
39036: PUSH
39037: LD_INT 20
39039: PUSH
39040: EMPTY
39041: LIST
39042: LIST
39043: LIST
39044: PUSH
39045: EMPTY
39046: LIST
39047: LIST
39048: LIST
39049: PPUSH
39050: CALL_OW 69
39054: UNION
39055: ST_TO_ADDR
// danger_at_area := FilterUnitsInArea ( mc_can_tame [ i ] , [ f_enemy , side ] ) ;
39056: LD_ADDR_VAR 0 10
39060: PUSH
39061: LD_EXP 107
39065: PUSH
39066: LD_VAR 0 2
39070: ARRAY
39071: PPUSH
39072: LD_INT 81
39074: PUSH
39075: LD_VAR 0 11
39079: PUSH
39080: EMPTY
39081: LIST
39082: LIST
39083: PPUSH
39084: CALL_OW 70
39088: ST_TO_ADDR
// if not apes or danger_at_area then
39089: LD_VAR 0 7
39093: NOT
39094: PUSH
39095: LD_VAR 0 10
39099: OR
39100: IFFALSE 39150
// begin if mc_taming [ i ] then
39102: LD_EXP 110
39106: PUSH
39107: LD_VAR 0 2
39111: ARRAY
39112: IFFALSE 39148
// begin MC_Reset ( i , 121 ) ;
39114: LD_VAR 0 2
39118: PPUSH
39119: LD_INT 121
39121: PPUSH
39122: CALL 24585 0 2
// mc_taming := Replace ( mc_taming , i , [ ] ) ;
39126: LD_ADDR_EXP 110
39130: PUSH
39131: LD_EXP 110
39135: PPUSH
39136: LD_VAR 0 2
39140: PPUSH
39141: EMPTY
39142: PPUSH
39143: CALL_OW 1
39147: ST_TO_ADDR
// end ; continue ;
39148: GO 38716
// end ; for j in tmp do
39150: LD_ADDR_VAR 0 3
39154: PUSH
39155: LD_VAR 0 8
39159: PUSH
39160: FOR_IN
39161: IFFALSE 39497
// begin if not j in mc_taming [ i ] and mc_taming [ i ] < 3 then
39163: LD_VAR 0 3
39167: PUSH
39168: LD_EXP 110
39172: PUSH
39173: LD_VAR 0 2
39177: ARRAY
39178: IN
39179: NOT
39180: PUSH
39181: LD_EXP 110
39185: PUSH
39186: LD_VAR 0 2
39190: ARRAY
39191: PUSH
39192: LD_INT 3
39194: LESS
39195: AND
39196: IFFALSE 39254
// begin SetTag ( j , 121 ) ;
39198: LD_VAR 0 3
39202: PPUSH
39203: LD_INT 121
39205: PPUSH
39206: CALL_OW 109
// mc_taming := ReplaceIn ( mc_taming , [ i , mc_taming [ i ] + 1 ] , j ) ;
39210: LD_ADDR_EXP 110
39214: PUSH
39215: LD_EXP 110
39219: PPUSH
39220: LD_VAR 0 2
39224: PUSH
39225: LD_EXP 110
39229: PUSH
39230: LD_VAR 0 2
39234: ARRAY
39235: PUSH
39236: LD_INT 1
39238: PLUS
39239: PUSH
39240: EMPTY
39241: LIST
39242: LIST
39243: PPUSH
39244: LD_VAR 0 3
39248: PPUSH
39249: CALL 57783 0 3
39253: ST_TO_ADDR
// end ; if j in mc_taming [ i ] then
39254: LD_VAR 0 3
39258: PUSH
39259: LD_EXP 110
39263: PUSH
39264: LD_VAR 0 2
39268: ARRAY
39269: IN
39270: IFFALSE 39495
// begin if GetClass ( j ) <> 4 then
39272: LD_VAR 0 3
39276: PPUSH
39277: CALL_OW 257
39281: PUSH
39282: LD_INT 4
39284: NONEQUAL
39285: IFFALSE 39338
// begin mc_taming := Replace ( mc_taming , i , mc_taming [ i ] diff j ) ;
39287: LD_ADDR_EXP 110
39291: PUSH
39292: LD_EXP 110
39296: PPUSH
39297: LD_VAR 0 2
39301: PPUSH
39302: LD_EXP 110
39306: PUSH
39307: LD_VAR 0 2
39311: ARRAY
39312: PUSH
39313: LD_VAR 0 3
39317: DIFF
39318: PPUSH
39319: CALL_OW 1
39323: ST_TO_ADDR
// SetTag ( j , 0 ) ;
39324: LD_VAR 0 3
39328: PPUSH
39329: LD_INT 0
39331: PPUSH
39332: CALL_OW 109
// continue ;
39336: GO 39160
// end ; if IsInUnit ( j ) then
39338: LD_VAR 0 3
39342: PPUSH
39343: CALL_OW 310
39347: IFFALSE 39358
// ComExitBuilding ( j ) ;
39349: LD_VAR 0 3
39353: PPUSH
39354: CALL_OW 122
// ape := NearestUnitToUnit ( apes , j ) ;
39358: LD_ADDR_VAR 0 6
39362: PUSH
39363: LD_VAR 0 7
39367: PPUSH
39368: LD_VAR 0 3
39372: PPUSH
39373: CALL_OW 74
39377: ST_TO_ADDR
// if not ape then
39378: LD_VAR 0 6
39382: NOT
39383: IFFALSE 39387
// break ;
39385: GO 39497
// x := GetX ( ape ) ;
39387: LD_ADDR_VAR 0 4
39391: PUSH
39392: LD_VAR 0 6
39396: PPUSH
39397: CALL_OW 250
39401: ST_TO_ADDR
// y := GetY ( ape ) ;
39402: LD_ADDR_VAR 0 5
39406: PUSH
39407: LD_VAR 0 6
39411: PPUSH
39412: CALL_OW 251
39416: ST_TO_ADDR
// if not ValidHex ( x , y ) or DangerAtRangeXY ( side , x , y , 20 ) [ 4 ] then
39417: LD_VAR 0 4
39421: PPUSH
39422: LD_VAR 0 5
39426: PPUSH
39427: CALL_OW 488
39431: NOT
39432: PUSH
39433: LD_VAR 0 11
39437: PPUSH
39438: LD_VAR 0 4
39442: PPUSH
39443: LD_VAR 0 5
39447: PPUSH
39448: LD_INT 20
39450: PPUSH
39451: CALL 58679 0 4
39455: PUSH
39456: LD_INT 4
39458: ARRAY
39459: OR
39460: IFFALSE 39464
// break ;
39462: GO 39497
// if not HasTask ( j ) then
39464: LD_VAR 0 3
39468: PPUSH
39469: CALL_OW 314
39473: NOT
39474: IFFALSE 39495
// ComTameXY ( j , x , y ) ;
39476: LD_VAR 0 3
39480: PPUSH
39481: LD_VAR 0 4
39485: PPUSH
39486: LD_VAR 0 5
39490: PPUSH
39491: CALL_OW 131
// end ; end ;
39495: GO 39160
39497: POP
39498: POP
// end ;
39499: GO 38716
39501: POP
39502: POP
// end ;
39503: LD_VAR 0 1
39507: RET
// export function MC_ChangeApeClass ( ) ; var i , j , tmp , side , depot , selected , barracks ; begin
39508: LD_INT 0
39510: PPUSH
39511: PPUSH
39512: PPUSH
39513: PPUSH
39514: PPUSH
39515: PPUSH
39516: PPUSH
39517: PPUSH
// if not mc_bases then
39518: LD_EXP 79
39522: NOT
39523: IFFALSE 39527
// exit ;
39525: GO 40153
// for i = 1 to mc_bases do
39527: LD_ADDR_VAR 0 2
39531: PUSH
39532: DOUBLE
39533: LD_INT 1
39535: DEC
39536: ST_TO_ADDR
39537: LD_EXP 79
39541: PUSH
39542: FOR_TO
39543: IFFALSE 40151
// begin if not mc_ape [ i ] or not UnitFilter ( mc_ape [ i ] , [ f_class , 12 ] ) then
39545: LD_EXP 108
39549: PUSH
39550: LD_VAR 0 2
39554: ARRAY
39555: NOT
39556: PUSH
39557: LD_EXP 108
39561: PUSH
39562: LD_VAR 0 2
39566: ARRAY
39567: PPUSH
39568: LD_INT 25
39570: PUSH
39571: LD_INT 12
39573: PUSH
39574: EMPTY
39575: LIST
39576: LIST
39577: PPUSH
39578: CALL_OW 72
39582: NOT
39583: OR
39584: IFFALSE 39588
// continue ;
39586: GO 39542
// side := GetSide ( mc_ape [ i ] [ 1 ] ) ;
39588: LD_ADDR_VAR 0 5
39592: PUSH
39593: LD_EXP 108
39597: PUSH
39598: LD_VAR 0 2
39602: ARRAY
39603: PUSH
39604: LD_INT 1
39606: ARRAY
39607: PPUSH
39608: CALL_OW 255
39612: ST_TO_ADDR
// if Researched ( side , tech_apepsych ) then
39613: LD_VAR 0 5
39617: PPUSH
39618: LD_INT 2
39620: PPUSH
39621: CALL_OW 325
39625: IFFALSE 39878
// begin tmp := UnitFilter ( mc_ape [ i ] , [ f_class , 16 ] ) ;
39627: LD_ADDR_VAR 0 4
39631: PUSH
39632: LD_EXP 108
39636: PUSH
39637: LD_VAR 0 2
39641: ARRAY
39642: PPUSH
39643: LD_INT 25
39645: PUSH
39646: LD_INT 16
39648: PUSH
39649: EMPTY
39650: LIST
39651: LIST
39652: PPUSH
39653: CALL_OW 72
39657: ST_TO_ADDR
// if tmp < 6 then
39658: LD_VAR 0 4
39662: PUSH
39663: LD_INT 6
39665: LESS
39666: IFFALSE 39878
// begin depot := UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) ;
39668: LD_ADDR_VAR 0 6
39672: PUSH
39673: LD_EXP 79
39677: PUSH
39678: LD_VAR 0 2
39682: ARRAY
39683: PPUSH
39684: LD_INT 2
39686: PUSH
39687: LD_INT 30
39689: PUSH
39690: LD_INT 0
39692: PUSH
39693: EMPTY
39694: LIST
39695: LIST
39696: PUSH
39697: LD_INT 30
39699: PUSH
39700: LD_INT 1
39702: PUSH
39703: EMPTY
39704: LIST
39705: LIST
39706: PUSH
39707: EMPTY
39708: LIST
39709: LIST
39710: LIST
39711: PPUSH
39712: CALL_OW 72
39716: ST_TO_ADDR
// if depot then
39717: LD_VAR 0 6
39721: IFFALSE 39878
// begin selected := 0 ;
39723: LD_ADDR_VAR 0 7
39727: PUSH
39728: LD_INT 0
39730: ST_TO_ADDR
// for j in depot do
39731: LD_ADDR_VAR 0 3
39735: PUSH
39736: LD_VAR 0 6
39740: PUSH
39741: FOR_IN
39742: IFFALSE 39773
// begin if UnitsInside ( j ) < 6 then
39744: LD_VAR 0 3
39748: PPUSH
39749: CALL_OW 313
39753: PUSH
39754: LD_INT 6
39756: LESS
39757: IFFALSE 39771
// begin selected := j ;
39759: LD_ADDR_VAR 0 7
39763: PUSH
39764: LD_VAR 0 3
39768: ST_TO_ADDR
// break ;
39769: GO 39773
// end ; end ;
39771: GO 39741
39773: POP
39774: POP
// if selected then
39775: LD_VAR 0 7
39779: IFFALSE 39878
// begin for j in UnitFilter ( mc_ape [ i ] , [ f_class , 12 ] ) do
39781: LD_ADDR_VAR 0 3
39785: PUSH
39786: LD_EXP 108
39790: PUSH
39791: LD_VAR 0 2
39795: ARRAY
39796: PPUSH
39797: LD_INT 25
39799: PUSH
39800: LD_INT 12
39802: PUSH
39803: EMPTY
39804: LIST
39805: LIST
39806: PPUSH
39807: CALL_OW 72
39811: PUSH
39812: FOR_IN
39813: IFFALSE 39876
// if not HasTask ( j ) then
39815: LD_VAR 0 3
39819: PPUSH
39820: CALL_OW 314
39824: NOT
39825: IFFALSE 39874
// begin if not IsInUnit ( j ) then
39827: LD_VAR 0 3
39831: PPUSH
39832: CALL_OW 310
39836: NOT
39837: IFFALSE 39853
// ComEnterUnit ( j , selected ) ;
39839: LD_VAR 0 3
39843: PPUSH
39844: LD_VAR 0 7
39848: PPUSH
39849: CALL_OW 120
// AddComChangeProfession ( j , 16 ) ;
39853: LD_VAR 0 3
39857: PPUSH
39858: LD_INT 16
39860: PPUSH
39861: CALL_OW 183
// AddComExitBuilding ( j ) ;
39865: LD_VAR 0 3
39869: PPUSH
39870: CALL_OW 182
// end ;
39874: GO 39812
39876: POP
39877: POP
// end ; end ; end ; end ; if Researched ( side , tech_apeagres ) then
39878: LD_VAR 0 5
39882: PPUSH
39883: LD_INT 11
39885: PPUSH
39886: CALL_OW 325
39890: IFFALSE 40149
// begin tmp := UnitFilter ( mc_ape [ i ] , [ f_class , 16 ] ) ;
39892: LD_ADDR_VAR 0 4
39896: PUSH
39897: LD_EXP 108
39901: PUSH
39902: LD_VAR 0 2
39906: ARRAY
39907: PPUSH
39908: LD_INT 25
39910: PUSH
39911: LD_INT 16
39913: PUSH
39914: EMPTY
39915: LIST
39916: LIST
39917: PPUSH
39918: CALL_OW 72
39922: ST_TO_ADDR
// if tmp >= 6 or not Researched ( side , tech_apepsych ) then
39923: LD_VAR 0 4
39927: PUSH
39928: LD_INT 6
39930: GREATEREQUAL
39931: PUSH
39932: LD_VAR 0 5
39936: PPUSH
39937: LD_INT 2
39939: PPUSH
39940: CALL_OW 325
39944: NOT
39945: OR
39946: IFFALSE 40149
// begin barracks := UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_armoury ] , [ f_btype , b_barracks ] ] ) ;
39948: LD_ADDR_VAR 0 8
39952: PUSH
39953: LD_EXP 79
39957: PUSH
39958: LD_VAR 0 2
39962: ARRAY
39963: PPUSH
39964: LD_INT 2
39966: PUSH
39967: LD_INT 30
39969: PUSH
39970: LD_INT 4
39972: PUSH
39973: EMPTY
39974: LIST
39975: LIST
39976: PUSH
39977: LD_INT 30
39979: PUSH
39980: LD_INT 5
39982: PUSH
39983: EMPTY
39984: LIST
39985: LIST
39986: PUSH
39987: EMPTY
39988: LIST
39989: LIST
39990: LIST
39991: PPUSH
39992: CALL_OW 72
39996: ST_TO_ADDR
// if barracks then
39997: LD_VAR 0 8
40001: IFFALSE 40149
// begin selected := 0 ;
40003: LD_ADDR_VAR 0 7
40007: PUSH
40008: LD_INT 0
40010: ST_TO_ADDR
// for j in barracks do
40011: LD_ADDR_VAR 0 3
40015: PUSH
40016: LD_VAR 0 8
40020: PUSH
40021: FOR_IN
40022: IFFALSE 40053
// begin if UnitsInside ( j ) < 6 then
40024: LD_VAR 0 3
40028: PPUSH
40029: CALL_OW 313
40033: PUSH
40034: LD_INT 6
40036: LESS
40037: IFFALSE 40051
// begin selected := j ;
40039: LD_ADDR_VAR 0 7
40043: PUSH
40044: LD_VAR 0 3
40048: ST_TO_ADDR
// break ;
40049: GO 40053
// end ; end ;
40051: GO 40021
40053: POP
40054: POP
// if selected then
40055: LD_VAR 0 7
40059: IFFALSE 40149
// begin for j in UnitFilter ( mc_ape [ i ] , [ f_class , 12 ] ) do
40061: LD_ADDR_VAR 0 3
40065: PUSH
40066: LD_EXP 108
40070: PUSH
40071: LD_VAR 0 2
40075: ARRAY
40076: PPUSH
40077: LD_INT 25
40079: PUSH
40080: LD_INT 12
40082: PUSH
40083: EMPTY
40084: LIST
40085: LIST
40086: PPUSH
40087: CALL_OW 72
40091: PUSH
40092: FOR_IN
40093: IFFALSE 40147
// if not IsInUnit ( j ) and not HasTask ( j ) then
40095: LD_VAR 0 3
40099: PPUSH
40100: CALL_OW 310
40104: NOT
40105: PUSH
40106: LD_VAR 0 3
40110: PPUSH
40111: CALL_OW 314
40115: NOT
40116: AND
40117: IFFALSE 40145
// begin ComEnterUnit ( j , selected ) ;
40119: LD_VAR 0 3
40123: PPUSH
40124: LD_VAR 0 7
40128: PPUSH
40129: CALL_OW 120
// AddComChangeProfession ( j , 15 ) ;
40133: LD_VAR 0 3
40137: PPUSH
40138: LD_INT 15
40140: PPUSH
40141: CALL_OW 183
// end ;
40145: GO 40092
40147: POP
40148: POP
// end ; end ; end ; end ; end ;
40149: GO 39542
40151: POP
40152: POP
// end ;
40153: LD_VAR 0 1
40157: RET
// export function MC_Bazooka ( ) ; var i , j , tmp ; begin
40158: LD_INT 0
40160: PPUSH
40161: PPUSH
40162: PPUSH
40163: PPUSH
// if not mc_bases then
40164: LD_EXP 79
40168: NOT
40169: IFFALSE 40173
// exit ;
40171: GO 40351
// for i = 1 to mc_bases do
40173: LD_ADDR_VAR 0 2
40177: PUSH
40178: DOUBLE
40179: LD_INT 1
40181: DEC
40182: ST_TO_ADDR
40183: LD_EXP 79
40187: PUSH
40188: FOR_TO
40189: IFFALSE 40349
// begin tmp := UnitFilter ( mc_bases [ i ] , [ f_class , class_bazooker ] ) ;
40191: LD_ADDR_VAR 0 4
40195: PUSH
40196: LD_EXP 79
40200: PUSH
40201: LD_VAR 0 2
40205: ARRAY
40206: PPUSH
40207: LD_INT 25
40209: PUSH
40210: LD_INT 9
40212: PUSH
40213: EMPTY
40214: LIST
40215: LIST
40216: PPUSH
40217: CALL_OW 72
40221: ST_TO_ADDR
// if not tmp then
40222: LD_VAR 0 4
40226: NOT
40227: IFFALSE 40231
// continue ;
40229: GO 40188
// if not Researched ( mc_sides [ i ] , tech_spacanom ) and not Researched ( mc_sides [ i ] , tech_taurad ) then
40231: LD_EXP 105
40235: PUSH
40236: LD_VAR 0 2
40240: ARRAY
40241: PPUSH
40242: LD_INT 29
40244: PPUSH
40245: CALL_OW 325
40249: NOT
40250: PUSH
40251: LD_EXP 105
40255: PUSH
40256: LD_VAR 0 2
40260: ARRAY
40261: PPUSH
40262: LD_INT 28
40264: PPUSH
40265: CALL_OW 325
40269: NOT
40270: AND
40271: IFFALSE 40275
// continue ;
40273: GO 40188
// for j in tmp do
40275: LD_ADDR_VAR 0 3
40279: PUSH
40280: LD_VAR 0 4
40284: PUSH
40285: FOR_IN
40286: IFFALSE 40345
// if not j in mc_need_heal [ i ] [ 1 ] and not j in mc_need_heal [ i ] [ 2 ] then
40288: LD_VAR 0 3
40292: PUSH
40293: LD_EXP 82
40297: PUSH
40298: LD_VAR 0 2
40302: ARRAY
40303: PUSH
40304: LD_INT 1
40306: ARRAY
40307: IN
40308: NOT
40309: PUSH
40310: LD_VAR 0 3
40314: PUSH
40315: LD_EXP 82
40319: PUSH
40320: LD_VAR 0 2
40324: ARRAY
40325: PUSH
40326: LD_INT 2
40328: ARRAY
40329: IN
40330: NOT
40331: AND
40332: IFFALSE 40343
// ComSpaceTimeShoot ( j ) ;
40334: LD_VAR 0 3
40338: PPUSH
40339: CALL 51369 0 1
40343: GO 40285
40345: POP
40346: POP
// end ;
40347: GO 40188
40349: POP
40350: POP
// end ;
40351: LD_VAR 0 1
40355: RET
// export function MC_TeleportExit ( ) ; var i , j , x , y , save_point , tmp , teleports , sci ; begin
40356: LD_INT 0
40358: PPUSH
40359: PPUSH
40360: PPUSH
40361: PPUSH
40362: PPUSH
40363: PPUSH
40364: PPUSH
40365: PPUSH
40366: PPUSH
// if not mc_bases then
40367: LD_EXP 79
40371: NOT
40372: IFFALSE 40376
// exit ;
40374: GO 40998
// for i = 1 to mc_bases do
40376: LD_ADDR_VAR 0 2
40380: PUSH
40381: DOUBLE
40382: LD_INT 1
40384: DEC
40385: ST_TO_ADDR
40386: LD_EXP 79
40390: PUSH
40391: FOR_TO
40392: IFFALSE 40996
// begin if not mc_teleport_exit [ i ] or GetTech ( tech_targTeleport , mc_sides [ i ] ) <> state_researched then
40394: LD_EXP 114
40398: PUSH
40399: LD_VAR 0 2
40403: ARRAY
40404: NOT
40405: PUSH
40406: LD_INT 38
40408: PPUSH
40409: LD_EXP 105
40413: PUSH
40414: LD_VAR 0 2
40418: ARRAY
40419: PPUSH
40420: CALL_OW 321
40424: PUSH
40425: LD_INT 2
40427: NONEQUAL
40428: OR
40429: IFFALSE 40433
// continue ;
40431: GO 40391
// teleports := UnitFilter ( mc_bases [ i ] , [ f_btype , b_teleport ] ) ;
40433: LD_ADDR_VAR 0 8
40437: PUSH
40438: LD_EXP 79
40442: PUSH
40443: LD_VAR 0 2
40447: ARRAY
40448: PPUSH
40449: LD_INT 30
40451: PUSH
40452: LD_INT 34
40454: PUSH
40455: EMPTY
40456: LIST
40457: LIST
40458: PPUSH
40459: CALL_OW 72
40463: ST_TO_ADDR
// sci := FilterByTag ( UnitFilter ( mc_bases [ i ] , [ f_class , 4 ] ) , 0 ) ;
40464: LD_ADDR_VAR 0 9
40468: PUSH
40469: LD_EXP 79
40473: PUSH
40474: LD_VAR 0 2
40478: ARRAY
40479: PPUSH
40480: LD_INT 25
40482: PUSH
40483: LD_INT 4
40485: PUSH
40486: EMPTY
40487: LIST
40488: LIST
40489: PPUSH
40490: CALL_OW 72
40494: PPUSH
40495: LD_INT 0
40497: PPUSH
40498: CALL 91053 0 2
40502: ST_TO_ADDR
// if not sci or not teleports or FilterByTag ( mc_bases [ i ] , 124 ) then
40503: LD_VAR 0 9
40507: NOT
40508: PUSH
40509: LD_VAR 0 8
40513: NOT
40514: OR
40515: PUSH
40516: LD_EXP 79
40520: PUSH
40521: LD_VAR 0 2
40525: ARRAY
40526: PPUSH
40527: LD_INT 124
40529: PPUSH
40530: CALL 91053 0 2
40534: OR
40535: IFFALSE 40539
// continue ;
40537: GO 40391
// if mc_teleport_exit_set [ i ] < mc_teleport_exit [ i ] and mc_teleport_exit_set [ i ] < teleports then
40539: LD_EXP 115
40543: PUSH
40544: LD_VAR 0 2
40548: ARRAY
40549: PUSH
40550: LD_EXP 114
40554: PUSH
40555: LD_VAR 0 2
40559: ARRAY
40560: LESS
40561: PUSH
40562: LD_EXP 115
40566: PUSH
40567: LD_VAR 0 2
40571: ARRAY
40572: PUSH
40573: LD_VAR 0 8
40577: LESS
40578: AND
40579: IFFALSE 40994
// begin tmp := sci [ 1 ] ;
40581: LD_ADDR_VAR 0 7
40585: PUSH
40586: LD_VAR 0 9
40590: PUSH
40591: LD_INT 1
40593: ARRAY
40594: ST_TO_ADDR
// SetTag ( tmp , 124 ) ;
40595: LD_VAR 0 7
40599: PPUSH
40600: LD_INT 124
40602: PPUSH
40603: CALL_OW 109
// for j = mc_teleport_exit [ i ] downto mc_teleport_exit [ i ] do
40607: LD_ADDR_VAR 0 3
40611: PUSH
40612: DOUBLE
40613: LD_EXP 114
40617: PUSH
40618: LD_VAR 0 2
40622: ARRAY
40623: INC
40624: ST_TO_ADDR
40625: LD_EXP 114
40629: PUSH
40630: LD_VAR 0 2
40634: ARRAY
40635: PUSH
40636: FOR_DOWNTO
40637: IFFALSE 40980
// begin if IsInUnit ( tmp ) then
40639: LD_VAR 0 7
40643: PPUSH
40644: CALL_OW 310
40648: IFFALSE 40659
// ComExitBuilding ( tmp ) ;
40650: LD_VAR 0 7
40654: PPUSH
40655: CALL_OW 122
// repeat wait ( 0 0$1 ) ;
40659: LD_INT 35
40661: PPUSH
40662: CALL_OW 67
// until not IsInUnit ( tmp ) and not HasTask ( tmp ) ;
40666: LD_VAR 0 7
40670: PPUSH
40671: CALL_OW 310
40675: NOT
40676: PUSH
40677: LD_VAR 0 7
40681: PPUSH
40682: CALL_OW 314
40686: NOT
40687: AND
40688: IFFALSE 40659
// save_point := [ GetX ( tmp ) , GetY ( tmp ) ] ;
40690: LD_ADDR_VAR 0 6
40694: PUSH
40695: LD_VAR 0 7
40699: PPUSH
40700: CALL_OW 250
40704: PUSH
40705: LD_VAR 0 7
40709: PPUSH
40710: CALL_OW 251
40714: PUSH
40715: EMPTY
40716: LIST
40717: LIST
40718: ST_TO_ADDR
// repeat wait ( 0 0$1 ) ;
40719: LD_INT 35
40721: PPUSH
40722: CALL_OW 67
// x := mc_teleport_exit [ i ] [ j ] [ 1 ] ;
40726: LD_ADDR_VAR 0 4
40730: PUSH
40731: LD_EXP 114
40735: PUSH
40736: LD_VAR 0 2
40740: ARRAY
40741: PUSH
40742: LD_VAR 0 3
40746: ARRAY
40747: PUSH
40748: LD_INT 1
40750: ARRAY
40751: ST_TO_ADDR
// y := mc_teleport_exit [ i ] [ j ] [ 2 ] ;
40752: LD_ADDR_VAR 0 5
40756: PUSH
40757: LD_EXP 114
40761: PUSH
40762: LD_VAR 0 2
40766: ARRAY
40767: PUSH
40768: LD_VAR 0 3
40772: ARRAY
40773: PUSH
40774: LD_INT 2
40776: ARRAY
40777: ST_TO_ADDR
// if DangerAtRange ( tmp , 10 ) [ 4 ] then
40778: LD_VAR 0 7
40782: PPUSH
40783: LD_INT 10
40785: PPUSH
40786: CALL 60376 0 2
40790: PUSH
40791: LD_INT 4
40793: ARRAY
40794: IFFALSE 40832
// begin ComMoveXY ( tmp , save_point [ 1 ] , save_point [ 2 ] ) ;
40796: LD_VAR 0 7
40800: PPUSH
40801: LD_VAR 0 6
40805: PUSH
40806: LD_INT 1
40808: ARRAY
40809: PPUSH
40810: LD_VAR 0 6
40814: PUSH
40815: LD_INT 2
40817: ARRAY
40818: PPUSH
40819: CALL_OW 111
// wait ( 0 0$10 ) ;
40823: LD_INT 350
40825: PPUSH
40826: CALL_OW 67
// end else
40830: GO 40858
// begin ComMoveXY ( tmp , x , y ) ;
40832: LD_VAR 0 7
40836: PPUSH
40837: LD_VAR 0 4
40841: PPUSH
40842: LD_VAR 0 5
40846: PPUSH
40847: CALL_OW 111
// wait ( 0 0$3 ) ;
40851: LD_INT 105
40853: PPUSH
40854: CALL_OW 67
// end ; until IsAt ( tmp , x , y ) ;
40858: LD_VAR 0 7
40862: PPUSH
40863: LD_VAR 0 4
40867: PPUSH
40868: LD_VAR 0 5
40872: PPUSH
40873: CALL_OW 307
40877: IFFALSE 40719
// ComTeleportExit ( tmp , x , y , teleports [ j ] ) ;
40879: LD_VAR 0 7
40883: PPUSH
40884: LD_VAR 0 4
40888: PPUSH
40889: LD_VAR 0 5
40893: PPUSH
40894: LD_VAR 0 8
40898: PUSH
40899: LD_VAR 0 3
40903: ARRAY
40904: PPUSH
40905: CALL_OW 156
// repeat wait ( 0 0$1 ) ;
40909: LD_INT 35
40911: PPUSH
40912: CALL_OW 67
// until not HasTask ( tmp ) ;
40916: LD_VAR 0 7
40920: PPUSH
40921: CALL_OW 314
40925: NOT
40926: IFFALSE 40909
// mc_teleport_exit_set := ReplaceIn ( mc_teleport_exit_set , [ i , mc_teleport_exit_set [ i ] + 1 ] , teleports [ j ] ) ;
40928: LD_ADDR_EXP 115
40932: PUSH
40933: LD_EXP 115
40937: PPUSH
40938: LD_VAR 0 2
40942: PUSH
40943: LD_EXP 115
40947: PUSH
40948: LD_VAR 0 2
40952: ARRAY
40953: PUSH
40954: LD_INT 1
40956: PLUS
40957: PUSH
40958: EMPTY
40959: LIST
40960: LIST
40961: PPUSH
40962: LD_VAR 0 8
40966: PUSH
40967: LD_VAR 0 3
40971: ARRAY
40972: PPUSH
40973: CALL 57783 0 3
40977: ST_TO_ADDR
// end ;
40978: GO 40636
40980: POP
40981: POP
// MC_Reset ( i , 124 ) ;
40982: LD_VAR 0 2
40986: PPUSH
40987: LD_INT 124
40989: PPUSH
40990: CALL 24585 0 2
// end ; end ;
40994: GO 40391
40996: POP
40997: POP
// end ;
40998: LD_VAR 0 1
41002: RET
// export function MC_Deposits ( ) ; var i , tmp ; begin
41003: LD_INT 0
41005: PPUSH
41006: PPUSH
41007: PPUSH
// if not mc_bases then
41008: LD_EXP 79
41012: NOT
41013: IFFALSE 41017
// exit ;
41015: GO 41623
// for i = 1 to mc_bases do
41017: LD_ADDR_VAR 0 2
41021: PUSH
41022: DOUBLE
41023: LD_INT 1
41025: DEC
41026: ST_TO_ADDR
41027: LD_EXP 79
41031: PUSH
41032: FOR_TO
41033: IFFALSE 41621
// begin tmp := UnitFilter ( mc_bases [ i ] , [ f_class , 4 ] ) ;
41035: LD_ADDR_VAR 0 3
41039: PUSH
41040: LD_EXP 79
41044: PUSH
41045: LD_VAR 0 2
41049: ARRAY
41050: PPUSH
41051: LD_INT 25
41053: PUSH
41054: LD_INT 4
41056: PUSH
41057: EMPTY
41058: LIST
41059: LIST
41060: PPUSH
41061: CALL_OW 72
41065: ST_TO_ADDR
// if not tmp or not mc_deposits_xy [ i ] or not UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) then
41066: LD_VAR 0 3
41070: NOT
41071: PUSH
41072: LD_EXP 116
41076: PUSH
41077: LD_VAR 0 2
41081: ARRAY
41082: NOT
41083: OR
41084: PUSH
41085: LD_EXP 79
41089: PUSH
41090: LD_VAR 0 2
41094: ARRAY
41095: PPUSH
41096: LD_INT 2
41098: PUSH
41099: LD_INT 30
41101: PUSH
41102: LD_INT 0
41104: PUSH
41105: EMPTY
41106: LIST
41107: LIST
41108: PUSH
41109: LD_INT 30
41111: PUSH
41112: LD_INT 1
41114: PUSH
41115: EMPTY
41116: LIST
41117: LIST
41118: PUSH
41119: EMPTY
41120: LIST
41121: LIST
41122: LIST
41123: PPUSH
41124: CALL_OW 72
41128: NOT
41129: OR
41130: IFFALSE 41180
// begin if mc_deposits_finder [ i ] then
41132: LD_EXP 117
41136: PUSH
41137: LD_VAR 0 2
41141: ARRAY
41142: IFFALSE 41178
// begin MC_Reset ( i , 125 ) ;
41144: LD_VAR 0 2
41148: PPUSH
41149: LD_INT 125
41151: PPUSH
41152: CALL 24585 0 2
// mc_deposits_finder := Replace ( mc_deposits_finder , i , [ ] ) ;
41156: LD_ADDR_EXP 117
41160: PUSH
41161: LD_EXP 117
41165: PPUSH
41166: LD_VAR 0 2
41170: PPUSH
41171: EMPTY
41172: PPUSH
41173: CALL_OW 1
41177: ST_TO_ADDR
// end ; continue ;
41178: GO 41032
// end ; if mc_deposits_xy [ i ] [ 1 ] [ 3 ] = 1 and GetTech ( tech_sibdet , mc_sides [ i ] ) <> state_researched then
41180: LD_EXP 116
41184: PUSH
41185: LD_VAR 0 2
41189: ARRAY
41190: PUSH
41191: LD_INT 1
41193: ARRAY
41194: PUSH
41195: LD_INT 3
41197: ARRAY
41198: PUSH
41199: LD_INT 1
41201: EQUAL
41202: PUSH
41203: LD_INT 20
41205: PPUSH
41206: LD_EXP 105
41210: PUSH
41211: LD_VAR 0 2
41215: ARRAY
41216: PPUSH
41217: CALL_OW 321
41221: PUSH
41222: LD_INT 2
41224: NONEQUAL
41225: AND
41226: IFFALSE 41276
// begin if mc_deposits_finder [ i ] then
41228: LD_EXP 117
41232: PUSH
41233: LD_VAR 0 2
41237: ARRAY
41238: IFFALSE 41274
// begin MC_Reset ( i , 125 ) ;
41240: LD_VAR 0 2
41244: PPUSH
41245: LD_INT 125
41247: PPUSH
41248: CALL 24585 0 2
// mc_deposits_finder := Replace ( mc_deposits_finder , i , [ ] ) ;
41252: LD_ADDR_EXP 117
41256: PUSH
41257: LD_EXP 117
41261: PPUSH
41262: LD_VAR 0 2
41266: PPUSH
41267: EMPTY
41268: PPUSH
41269: CALL_OW 1
41273: ST_TO_ADDR
// end ; continue ;
41274: GO 41032
// end ; if GetResourceVisibility ( mc_deposits_xy [ i ] [ 1 ] [ 1 ] , mc_deposits_xy [ i ] [ 1 ] [ 2 ] , mc_sides [ i ] ) then
41276: LD_EXP 116
41280: PUSH
41281: LD_VAR 0 2
41285: ARRAY
41286: PUSH
41287: LD_INT 1
41289: ARRAY
41290: PUSH
41291: LD_INT 1
41293: ARRAY
41294: PPUSH
41295: LD_EXP 116
41299: PUSH
41300: LD_VAR 0 2
41304: ARRAY
41305: PUSH
41306: LD_INT 1
41308: ARRAY
41309: PUSH
41310: LD_INT 2
41312: ARRAY
41313: PPUSH
41314: LD_EXP 105
41318: PUSH
41319: LD_VAR 0 2
41323: ARRAY
41324: PPUSH
41325: CALL_OW 440
41329: IFFALSE 41372
// mc_deposits_xy := Replace ( mc_deposits_xy , i , Delete ( mc_deposits_xy [ i ] , 1 ) ) else
41331: LD_ADDR_EXP 116
41335: PUSH
41336: LD_EXP 116
41340: PPUSH
41341: LD_VAR 0 2
41345: PPUSH
41346: LD_EXP 116
41350: PUSH
41351: LD_VAR 0 2
41355: ARRAY
41356: PPUSH
41357: LD_INT 1
41359: PPUSH
41360: CALL_OW 3
41364: PPUSH
41365: CALL_OW 1
41369: ST_TO_ADDR
41370: GO 41619
// begin if not mc_deposits_finder [ i ] then
41372: LD_EXP 117
41376: PUSH
41377: LD_VAR 0 2
41381: ARRAY
41382: NOT
41383: IFFALSE 41435
// begin mc_deposits_finder := Replace ( mc_deposits_finder , i , [ tmp [ 1 ] ] ) ;
41385: LD_ADDR_EXP 117
41389: PUSH
41390: LD_EXP 117
41394: PPUSH
41395: LD_VAR 0 2
41399: PPUSH
41400: LD_VAR 0 3
41404: PUSH
41405: LD_INT 1
41407: ARRAY
41408: PUSH
41409: EMPTY
41410: LIST
41411: PPUSH
41412: CALL_OW 1
41416: ST_TO_ADDR
// SetTag ( tmp [ 1 ] , 125 ) ;
41417: LD_VAR 0 3
41421: PUSH
41422: LD_INT 1
41424: ARRAY
41425: PPUSH
41426: LD_INT 125
41428: PPUSH
41429: CALL_OW 109
// end else
41433: GO 41619
// begin if IsInUnit ( mc_deposits_finder [ i ] [ 1 ] ) then
41435: LD_EXP 117
41439: PUSH
41440: LD_VAR 0 2
41444: ARRAY
41445: PUSH
41446: LD_INT 1
41448: ARRAY
41449: PPUSH
41450: CALL_OW 310
41454: IFFALSE 41477
// ComExitBuilding ( mc_deposits_finder [ i ] [ 1 ] ) else
41456: LD_EXP 117
41460: PUSH
41461: LD_VAR 0 2
41465: ARRAY
41466: PUSH
41467: LD_INT 1
41469: ARRAY
41470: PPUSH
41471: CALL_OW 122
41475: GO 41619
// if not HasTask ( mc_deposits_finder [ i ] [ 1 ] ) and GetDistUnitXY ( mc_deposits_finder [ i ] [ 1 ] , mc_deposits_xy [ i ] [ 1 ] [ 1 ] , mc_deposits_xy [ i ] [ 1 ] [ 2 ] ) > 6 then
41477: LD_EXP 117
41481: PUSH
41482: LD_VAR 0 2
41486: ARRAY
41487: PUSH
41488: LD_INT 1
41490: ARRAY
41491: PPUSH
41492: CALL_OW 314
41496: NOT
41497: PUSH
41498: LD_EXP 117
41502: PUSH
41503: LD_VAR 0 2
41507: ARRAY
41508: PUSH
41509: LD_INT 1
41511: ARRAY
41512: PPUSH
41513: LD_EXP 116
41517: PUSH
41518: LD_VAR 0 2
41522: ARRAY
41523: PUSH
41524: LD_INT 1
41526: ARRAY
41527: PUSH
41528: LD_INT 1
41530: ARRAY
41531: PPUSH
41532: LD_EXP 116
41536: PUSH
41537: LD_VAR 0 2
41541: ARRAY
41542: PUSH
41543: LD_INT 1
41545: ARRAY
41546: PUSH
41547: LD_INT 2
41549: ARRAY
41550: PPUSH
41551: CALL_OW 297
41555: PUSH
41556: LD_INT 6
41558: GREATER
41559: AND
41560: IFFALSE 41619
// ComMoveXY ( mc_deposits_finder [ i ] [ 1 ] , mc_deposits_xy [ i ] [ 1 ] [ 1 ] , mc_deposits_xy [ i ] [ 1 ] [ 2 ] ) ;
41562: LD_EXP 117
41566: PUSH
41567: LD_VAR 0 2
41571: ARRAY
41572: PUSH
41573: LD_INT 1
41575: ARRAY
41576: PPUSH
41577: LD_EXP 116
41581: PUSH
41582: LD_VAR 0 2
41586: ARRAY
41587: PUSH
41588: LD_INT 1
41590: ARRAY
41591: PUSH
41592: LD_INT 1
41594: ARRAY
41595: PPUSH
41596: LD_EXP 116
41600: PUSH
41601: LD_VAR 0 2
41605: ARRAY
41606: PUSH
41607: LD_INT 1
41609: ARRAY
41610: PUSH
41611: LD_INT 2
41613: ARRAY
41614: PPUSH
41615: CALL_OW 111
// end ; end ; end ;
41619: GO 41032
41621: POP
41622: POP
// end ;
41623: LD_VAR 0 1
41627: RET
// export function MC_RemoteDriver ( ) ; var i , j , k , places , tmp , nation , ct , cts , mcts , x ; begin
41628: LD_INT 0
41630: PPUSH
41631: PPUSH
41632: PPUSH
41633: PPUSH
41634: PPUSH
41635: PPUSH
41636: PPUSH
41637: PPUSH
41638: PPUSH
41639: PPUSH
41640: PPUSH
// if not mc_bases then
41641: LD_EXP 79
41645: NOT
41646: IFFALSE 41650
// exit ;
41648: GO 42590
// for i = 1 to mc_bases do
41650: LD_ADDR_VAR 0 2
41654: PUSH
41655: DOUBLE
41656: LD_INT 1
41658: DEC
41659: ST_TO_ADDR
41660: LD_EXP 79
41664: PUSH
41665: FOR_TO
41666: IFFALSE 42588
// begin if not mc_bases [ i ] or mc_scan [ i ] then
41668: LD_EXP 79
41672: PUSH
41673: LD_VAR 0 2
41677: ARRAY
41678: NOT
41679: PUSH
41680: LD_EXP 102
41684: PUSH
41685: LD_VAR 0 2
41689: ARRAY
41690: OR
41691: IFFALSE 41695
// continue ;
41693: GO 41665
// nation := GetNation ( mc_bases [ i ] [ 1 ] ) ;
41695: LD_ADDR_VAR 0 7
41699: PUSH
41700: LD_EXP 79
41704: PUSH
41705: LD_VAR 0 2
41709: ARRAY
41710: PUSH
41711: LD_INT 1
41713: ARRAY
41714: PPUSH
41715: CALL_OW 248
41719: ST_TO_ADDR
// if nation = 3 or not UnitFilter ( mc_vehicles [ i ] union mc_defender [ i ] , [ f_control , control_remote ] ) then
41720: LD_VAR 0 7
41724: PUSH
41725: LD_INT 3
41727: EQUAL
41728: PUSH
41729: LD_EXP 98
41733: PUSH
41734: LD_VAR 0 2
41738: ARRAY
41739: PUSH
41740: LD_EXP 101
41744: PUSH
41745: LD_VAR 0 2
41749: ARRAY
41750: UNION
41751: PPUSH
41752: LD_INT 33
41754: PUSH
41755: LD_INT 2
41757: PUSH
41758: EMPTY
41759: LIST
41760: LIST
41761: PPUSH
41762: CALL_OW 72
41766: NOT
41767: OR
41768: IFFALSE 41772
// continue ;
41770: GO 41665
// cts := UnitFilter ( mc_bases [ i ] , [ f_btype , b_control_tower ] ) ;
41772: LD_ADDR_VAR 0 9
41776: PUSH
41777: LD_EXP 79
41781: PUSH
41782: LD_VAR 0 2
41786: ARRAY
41787: PPUSH
41788: LD_INT 30
41790: PUSH
41791: LD_INT 36
41793: PUSH
41794: EMPTY
41795: LIST
41796: LIST
41797: PPUSH
41798: CALL_OW 72
41802: ST_TO_ADDR
// mcts := UnitFilter ( mc_vehicles [ i ] , [ f_weapon , ar_control_tower ] ) ;
41803: LD_ADDR_VAR 0 10
41807: PUSH
41808: LD_EXP 98
41812: PUSH
41813: LD_VAR 0 2
41817: ARRAY
41818: PPUSH
41819: LD_INT 34
41821: PUSH
41822: LD_INT 31
41824: PUSH
41825: EMPTY
41826: LIST
41827: LIST
41828: PPUSH
41829: CALL_OW 72
41833: ST_TO_ADDR
// if not cts and not mcts then
41834: LD_VAR 0 9
41838: NOT
41839: PUSH
41840: LD_VAR 0 10
41844: NOT
41845: AND
41846: IFFALSE 41850
// continue ;
41848: GO 41665
// x := cts ;
41850: LD_ADDR_VAR 0 11
41854: PUSH
41855: LD_VAR 0 9
41859: ST_TO_ADDR
// if not x then
41860: LD_VAR 0 11
41864: NOT
41865: IFFALSE 41877
// x := mcts ;
41867: LD_ADDR_VAR 0 11
41871: PUSH
41872: LD_VAR 0 10
41876: ST_TO_ADDR
// if not x then
41877: LD_VAR 0 11
41881: NOT
41882: IFFALSE 41886
// continue ;
41884: GO 41665
// if mc_remote_driver [ i ] then
41886: LD_EXP 119
41890: PUSH
41891: LD_VAR 0 2
41895: ARRAY
41896: IFFALSE 42283
// for j in mc_remote_driver [ i ] do
41898: LD_ADDR_VAR 0 3
41902: PUSH
41903: LD_EXP 119
41907: PUSH
41908: LD_VAR 0 2
41912: ARRAY
41913: PUSH
41914: FOR_IN
41915: IFFALSE 42281
// begin if GetClass ( j ) <> 3 then
41917: LD_VAR 0 3
41921: PPUSH
41922: CALL_OW 257
41926: PUSH
41927: LD_INT 3
41929: NONEQUAL
41930: IFFALSE 41983
// begin mc_remote_driver := Replace ( mc_remote_driver , i , mc_remote_driver [ i ] diff j ) ;
41932: LD_ADDR_EXP 119
41936: PUSH
41937: LD_EXP 119
41941: PPUSH
41942: LD_VAR 0 2
41946: PPUSH
41947: LD_EXP 119
41951: PUSH
41952: LD_VAR 0 2
41956: ARRAY
41957: PUSH
41958: LD_VAR 0 3
41962: DIFF
41963: PPUSH
41964: CALL_OW 1
41968: ST_TO_ADDR
// SetTag ( j , 0 ) ;
41969: LD_VAR 0 3
41973: PPUSH
41974: LD_INT 0
41976: PPUSH
41977: CALL_OW 109
// continue ;
41981: GO 41914
// end ; if UnitFilter ( mc_vehicles [ i ] , [ [ f_weapon , ar_control_tower ] , [ f_empty ] ] ) and not IsDriver ( j ) then
41983: LD_EXP 98
41987: PUSH
41988: LD_VAR 0 2
41992: ARRAY
41993: PPUSH
41994: LD_INT 34
41996: PUSH
41997: LD_INT 31
41999: PUSH
42000: EMPTY
42001: LIST
42002: LIST
42003: PUSH
42004: LD_INT 58
42006: PUSH
42007: EMPTY
42008: LIST
42009: PUSH
42010: EMPTY
42011: LIST
42012: LIST
42013: PPUSH
42014: CALL_OW 72
42018: PUSH
42019: LD_VAR 0 3
42023: PPUSH
42024: CALL 91141 0 1
42028: NOT
42029: AND
42030: IFFALSE 42101
// begin if IsInUnit ( j ) then
42032: LD_VAR 0 3
42036: PPUSH
42037: CALL_OW 310
42041: IFFALSE 42052
// ComExitBuilding ( j ) ;
42043: LD_VAR 0 3
42047: PPUSH
42048: CALL_OW 122
// AddComEnterUnit ( j , UnitFilter ( mc_vehicles [ i ] , [ [ f_weapon , ar_control_tower ] , [ f_empty ] ] ) [ 1 ] ) ;
42052: LD_VAR 0 3
42056: PPUSH
42057: LD_EXP 98
42061: PUSH
42062: LD_VAR 0 2
42066: ARRAY
42067: PPUSH
42068: LD_INT 34
42070: PUSH
42071: LD_INT 31
42073: PUSH
42074: EMPTY
42075: LIST
42076: LIST
42077: PUSH
42078: LD_INT 58
42080: PUSH
42081: EMPTY
42082: LIST
42083: PUSH
42084: EMPTY
42085: LIST
42086: LIST
42087: PPUSH
42088: CALL_OW 72
42092: PUSH
42093: LD_INT 1
42095: ARRAY
42096: PPUSH
42097: CALL_OW 180
// end ; if not IsInUnit ( j ) or ( GetBType ( IsInUnit ( j ) ) <> b_control_tower and not IsDriver ( j ) ) then
42101: LD_VAR 0 3
42105: PPUSH
42106: CALL_OW 310
42110: NOT
42111: PUSH
42112: LD_VAR 0 3
42116: PPUSH
42117: CALL_OW 310
42121: PPUSH
42122: CALL_OW 266
42126: PUSH
42127: LD_INT 36
42129: NONEQUAL
42130: PUSH
42131: LD_VAR 0 3
42135: PPUSH
42136: CALL 91141 0 1
42140: NOT
42141: AND
42142: OR
42143: IFFALSE 42279
// begin if IsInUnit ( j ) then
42145: LD_VAR 0 3
42149: PPUSH
42150: CALL_OW 310
42154: IFFALSE 42165
// ComExitBuilding ( j ) ;
42156: LD_VAR 0 3
42160: PPUSH
42161: CALL_OW 122
// ct := 0 ;
42165: LD_ADDR_VAR 0 8
42169: PUSH
42170: LD_INT 0
42172: ST_TO_ADDR
// for k in x do
42173: LD_ADDR_VAR 0 4
42177: PUSH
42178: LD_VAR 0 11
42182: PUSH
42183: FOR_IN
42184: IFFALSE 42257
// if ( GetWeapon ( k ) = ar_control_tower and not IsDrivenBy ( k ) ) or ( GetBType ( k ) = b_control_tower and UnitsInside ( k ) < 3 ) then
42186: LD_VAR 0 4
42190: PPUSH
42191: CALL_OW 264
42195: PUSH
42196: LD_INT 31
42198: EQUAL
42199: PUSH
42200: LD_VAR 0 4
42204: PPUSH
42205: CALL_OW 311
42209: NOT
42210: AND
42211: PUSH
42212: LD_VAR 0 4
42216: PPUSH
42217: CALL_OW 266
42221: PUSH
42222: LD_INT 36
42224: EQUAL
42225: PUSH
42226: LD_VAR 0 4
42230: PPUSH
42231: CALL_OW 313
42235: PUSH
42236: LD_INT 3
42238: LESS
42239: AND
42240: OR
42241: IFFALSE 42255
// begin ct := k ;
42243: LD_ADDR_VAR 0 8
42247: PUSH
42248: LD_VAR 0 4
42252: ST_TO_ADDR
// break ;
42253: GO 42257
// end ;
42255: GO 42183
42257: POP
42258: POP
// if ct then
42259: LD_VAR 0 8
42263: IFFALSE 42279
// ComEnterUnit ( j , ct ) ;
42265: LD_VAR 0 3
42269: PPUSH
42270: LD_VAR 0 8
42274: PPUSH
42275: CALL_OW 120
// end ; end ;
42279: GO 41914
42281: POP
42282: POP
// places := 0 ;
42283: LD_ADDR_VAR 0 5
42287: PUSH
42288: LD_INT 0
42290: ST_TO_ADDR
// for j = 1 to x do
42291: LD_ADDR_VAR 0 3
42295: PUSH
42296: DOUBLE
42297: LD_INT 1
42299: DEC
42300: ST_TO_ADDR
42301: LD_VAR 0 11
42305: PUSH
42306: FOR_TO
42307: IFFALSE 42383
// if GetWeapon ( x [ j ] ) = ar_control_tower then
42309: LD_VAR 0 11
42313: PUSH
42314: LD_VAR 0 3
42318: ARRAY
42319: PPUSH
42320: CALL_OW 264
42324: PUSH
42325: LD_INT 31
42327: EQUAL
42328: IFFALSE 42346
// places := places + 1 else
42330: LD_ADDR_VAR 0 5
42334: PUSH
42335: LD_VAR 0 5
42339: PUSH
42340: LD_INT 1
42342: PLUS
42343: ST_TO_ADDR
42344: GO 42381
// if GetBType ( x [ j ] ) = b_control_tower then
42346: LD_VAR 0 11
42350: PUSH
42351: LD_VAR 0 3
42355: ARRAY
42356: PPUSH
42357: CALL_OW 266
42361: PUSH
42362: LD_INT 36
42364: EQUAL
42365: IFFALSE 42381
// places := places + 3 ;
42367: LD_ADDR_VAR 0 5
42371: PUSH
42372: LD_VAR 0 5
42376: PUSH
42377: LD_INT 3
42379: PLUS
42380: ST_TO_ADDR
42381: GO 42306
42383: POP
42384: POP
// if places = 0 or places <= mc_remote_driver [ i ] then
42385: LD_VAR 0 5
42389: PUSH
42390: LD_INT 0
42392: EQUAL
42393: PUSH
42394: LD_VAR 0 5
42398: PUSH
42399: LD_EXP 119
42403: PUSH
42404: LD_VAR 0 2
42408: ARRAY
42409: LESSEQUAL
42410: OR
42411: IFFALSE 42415
// continue ;
42413: GO 41665
// tmp := SortBySkill ( UnitFilter ( mc_bases [ i ] , [ f_class , 3 ] ) diff mc_remote_driver [ i ] , 3 ) ;
42415: LD_ADDR_VAR 0 6
42419: PUSH
42420: LD_EXP 79
42424: PUSH
42425: LD_VAR 0 2
42429: ARRAY
42430: PPUSH
42431: LD_INT 25
42433: PUSH
42434: LD_INT 3
42436: PUSH
42437: EMPTY
42438: LIST
42439: LIST
42440: PPUSH
42441: CALL_OW 72
42445: PUSH
42446: LD_EXP 119
42450: PUSH
42451: LD_VAR 0 2
42455: ARRAY
42456: DIFF
42457: PPUSH
42458: LD_INT 3
42460: PPUSH
42461: CALL 92041 0 2
42465: ST_TO_ADDR
// for j in tmp do
42466: LD_ADDR_VAR 0 3
42470: PUSH
42471: LD_VAR 0 6
42475: PUSH
42476: FOR_IN
42477: IFFALSE 42512
// if GetTag ( j ) > 0 then
42479: LD_VAR 0 3
42483: PPUSH
42484: CALL_OW 110
42488: PUSH
42489: LD_INT 0
42491: GREATER
42492: IFFALSE 42510
// tmp := tmp diff j ;
42494: LD_ADDR_VAR 0 6
42498: PUSH
42499: LD_VAR 0 6
42503: PUSH
42504: LD_VAR 0 3
42508: DIFF
42509: ST_TO_ADDR
42510: GO 42476
42512: POP
42513: POP
// if not tmp then
42514: LD_VAR 0 6
42518: NOT
42519: IFFALSE 42523
// continue ;
42521: GO 41665
// if places then
42523: LD_VAR 0 5
42527: IFFALSE 42586
// begin mc_remote_driver := Replace ( mc_remote_driver , i , mc_remote_driver [ i ] union tmp [ 1 ] ) ;
42529: LD_ADDR_EXP 119
42533: PUSH
42534: LD_EXP 119
42538: PPUSH
42539: LD_VAR 0 2
42543: PPUSH
42544: LD_EXP 119
42548: PUSH
42549: LD_VAR 0 2
42553: ARRAY
42554: PUSH
42555: LD_VAR 0 6
42559: PUSH
42560: LD_INT 1
42562: ARRAY
42563: UNION
42564: PPUSH
42565: CALL_OW 1
42569: ST_TO_ADDR
// SetTag ( tmp [ 1 ] , 126 ) ;
42570: LD_VAR 0 6
42574: PUSH
42575: LD_INT 1
42577: ARRAY
42578: PPUSH
42579: LD_INT 126
42581: PPUSH
42582: CALL_OW 109
// end ; end ;
42586: GO 41665
42588: POP
42589: POP
// end ;
42590: LD_VAR 0 1
42594: RET
// export function MC_Back ( base , base_unit_list , unit , class ) ; var i , j , tmp , x , depot ; begin
42595: LD_INT 0
42597: PPUSH
42598: PPUSH
42599: PPUSH
42600: PPUSH
42601: PPUSH
42602: PPUSH
// if not base or not base_unit_list or not unit or not class in [ 1 , 2 , 3 , 4 , 5 , 8 , 9 , 15 , 16 ] then
42603: LD_VAR 0 1
42607: NOT
42608: PUSH
42609: LD_VAR 0 2
42613: NOT
42614: OR
42615: PUSH
42616: LD_VAR 0 3
42620: NOT
42621: OR
42622: PUSH
42623: LD_VAR 0 4
42627: PUSH
42628: LD_INT 1
42630: PUSH
42631: LD_INT 2
42633: PUSH
42634: LD_INT 3
42636: PUSH
42637: LD_INT 4
42639: PUSH
42640: LD_INT 5
42642: PUSH
42643: LD_INT 8
42645: PUSH
42646: LD_INT 9
42648: PUSH
42649: LD_INT 15
42651: PUSH
42652: LD_INT 16
42654: PUSH
42655: EMPTY
42656: LIST
42657: LIST
42658: LIST
42659: LIST
42660: LIST
42661: LIST
42662: LIST
42663: LIST
42664: LIST
42665: IN
42666: NOT
42667: OR
42668: IFFALSE 42672
// exit ;
42670: GO 43572
// base_unit_list := UnitFilter ( base_unit_list , [ [ f_type , unit_building ] , [ f_lives , 250 ] ] ) ;
42672: LD_ADDR_VAR 0 2
42676: PUSH
42677: LD_VAR 0 2
42681: PPUSH
42682: LD_INT 21
42684: PUSH
42685: LD_INT 3
42687: PUSH
42688: EMPTY
42689: LIST
42690: LIST
42691: PUSH
42692: LD_INT 24
42694: PUSH
42695: LD_INT 250
42697: PUSH
42698: EMPTY
42699: LIST
42700: LIST
42701: PUSH
42702: EMPTY
42703: LIST
42704: LIST
42705: PPUSH
42706: CALL_OW 72
42710: ST_TO_ADDR
// case class of 1 , 15 :
42711: LD_VAR 0 4
42715: PUSH
42716: LD_INT 1
42718: DOUBLE
42719: EQUAL
42720: IFTRUE 42730
42722: LD_INT 15
42724: DOUBLE
42725: EQUAL
42726: IFTRUE 42730
42728: GO 42815
42730: POP
// tmp := UnitFilter ( base_unit_list , [ f_or , [ f_btype , b_bunker ] , [ f_btype , b_breastwork ] ] ) ^ UnitFilter ( base_unit_list , [ f_or , [ f_btype , b_armoury ] , [ f_btype , b_barracks ] ] ) ; 2 , 16 :
42731: LD_ADDR_VAR 0 8
42735: PUSH
42736: LD_VAR 0 2
42740: PPUSH
42741: LD_INT 2
42743: PUSH
42744: LD_INT 30
42746: PUSH
42747: LD_INT 32
42749: PUSH
42750: EMPTY
42751: LIST
42752: LIST
42753: PUSH
42754: LD_INT 30
42756: PUSH
42757: LD_INT 31
42759: PUSH
42760: EMPTY
42761: LIST
42762: LIST
42763: PUSH
42764: EMPTY
42765: LIST
42766: LIST
42767: LIST
42768: PPUSH
42769: CALL_OW 72
42773: PUSH
42774: LD_VAR 0 2
42778: PPUSH
42779: LD_INT 2
42781: PUSH
42782: LD_INT 30
42784: PUSH
42785: LD_INT 4
42787: PUSH
42788: EMPTY
42789: LIST
42790: LIST
42791: PUSH
42792: LD_INT 30
42794: PUSH
42795: LD_INT 5
42797: PUSH
42798: EMPTY
42799: LIST
42800: LIST
42801: PUSH
42802: EMPTY
42803: LIST
42804: LIST
42805: LIST
42806: PPUSH
42807: CALL_OW 72
42811: ADD
42812: ST_TO_ADDR
42813: GO 43061
42815: LD_INT 2
42817: DOUBLE
42818: EQUAL
42819: IFTRUE 42829
42821: LD_INT 16
42823: DOUBLE
42824: EQUAL
42825: IFTRUE 42829
42827: GO 42875
42829: POP
// tmp := UnitFilter ( base_unit_list , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) ; 3 :
42830: LD_ADDR_VAR 0 8
42834: PUSH
42835: LD_VAR 0 2
42839: PPUSH
42840: LD_INT 2
42842: PUSH
42843: LD_INT 30
42845: PUSH
42846: LD_INT 0
42848: PUSH
42849: EMPTY
42850: LIST
42851: LIST
42852: PUSH
42853: LD_INT 30
42855: PUSH
42856: LD_INT 1
42858: PUSH
42859: EMPTY
42860: LIST
42861: LIST
42862: PUSH
42863: EMPTY
42864: LIST
42865: LIST
42866: LIST
42867: PPUSH
42868: CALL_OW 72
42872: ST_TO_ADDR
42873: GO 43061
42875: LD_INT 3
42877: DOUBLE
42878: EQUAL
42879: IFTRUE 42883
42881: GO 42929
42883: POP
// tmp := UnitFilter ( base_unit_list , [ f_or , [ f_btype , b_workshop ] , [ f_btype , b_factory ] ] ) ; 4 :
42884: LD_ADDR_VAR 0 8
42888: PUSH
42889: LD_VAR 0 2
42893: PPUSH
42894: LD_INT 2
42896: PUSH
42897: LD_INT 30
42899: PUSH
42900: LD_INT 2
42902: PUSH
42903: EMPTY
42904: LIST
42905: LIST
42906: PUSH
42907: LD_INT 30
42909: PUSH
42910: LD_INT 3
42912: PUSH
42913: EMPTY
42914: LIST
42915: LIST
42916: PUSH
42917: EMPTY
42918: LIST
42919: LIST
42920: LIST
42921: PPUSH
42922: CALL_OW 72
42926: ST_TO_ADDR
42927: GO 43061
42929: LD_INT 4
42931: DOUBLE
42932: EQUAL
42933: IFTRUE 42937
42935: GO 42994
42937: POP
// tmp := UnitFilter ( base_unit_list , [ f_or , [ f_btype , b_lab ] , [ f_btype , b_lab_half ] , [ f_btype , b_lab_full ] ] ) ; 5 , 8 , 9 :
42938: LD_ADDR_VAR 0 8
42942: PUSH
42943: LD_VAR 0 2
42947: PPUSH
42948: LD_INT 2
42950: PUSH
42951: LD_INT 30
42953: PUSH
42954: LD_INT 6
42956: PUSH
42957: EMPTY
42958: LIST
42959: LIST
42960: PUSH
42961: LD_INT 30
42963: PUSH
42964: LD_INT 7
42966: PUSH
42967: EMPTY
42968: LIST
42969: LIST
42970: PUSH
42971: LD_INT 30
42973: PUSH
42974: LD_INT 8
42976: PUSH
42977: EMPTY
42978: LIST
42979: LIST
42980: PUSH
42981: EMPTY
42982: LIST
42983: LIST
42984: LIST
42985: LIST
42986: PPUSH
42987: CALL_OW 72
42991: ST_TO_ADDR
42992: GO 43061
42994: LD_INT 5
42996: DOUBLE
42997: EQUAL
42998: IFTRUE 43014
43000: LD_INT 8
43002: DOUBLE
43003: EQUAL
43004: IFTRUE 43014
43006: LD_INT 9
43008: DOUBLE
43009: EQUAL
43010: IFTRUE 43014
43012: GO 43060
43014: POP
// tmp := UnitFilter ( base_unit_list , [ f_or , [ f_btype , b_armoury ] , [ f_btype , b_barracks ] ] ) ; end ;
43015: LD_ADDR_VAR 0 8
43019: PUSH
43020: LD_VAR 0 2
43024: PPUSH
43025: LD_INT 2
43027: PUSH
43028: LD_INT 30
43030: PUSH
43031: LD_INT 4
43033: PUSH
43034: EMPTY
43035: LIST
43036: LIST
43037: PUSH
43038: LD_INT 30
43040: PUSH
43041: LD_INT 5
43043: PUSH
43044: EMPTY
43045: LIST
43046: LIST
43047: PUSH
43048: EMPTY
43049: LIST
43050: LIST
43051: LIST
43052: PPUSH
43053: CALL_OW 72
43057: ST_TO_ADDR
43058: GO 43061
43060: POP
// if not tmp then
43061: LD_VAR 0 8
43065: NOT
43066: IFFALSE 43070
// exit ;
43068: GO 43572
// if class in [ 1 , 15 ] and mc_empty_turret_list [ base ] then
43070: LD_VAR 0 4
43074: PUSH
43075: LD_INT 1
43077: PUSH
43078: LD_INT 15
43080: PUSH
43081: EMPTY
43082: LIST
43083: LIST
43084: IN
43085: PUSH
43086: LD_EXP 88
43090: PUSH
43091: LD_VAR 0 1
43095: ARRAY
43096: AND
43097: IFFALSE 43253
// begin x := mc_empty_turret_list [ base ] [ 1 ] ;
43099: LD_ADDR_VAR 0 9
43103: PUSH
43104: LD_EXP 88
43108: PUSH
43109: LD_VAR 0 1
43113: ARRAY
43114: PUSH
43115: LD_INT 1
43117: ARRAY
43118: ST_TO_ADDR
// if not x in mc_busy_turret_list [ base ] then
43119: LD_VAR 0 9
43123: PUSH
43124: LD_EXP 89
43128: PUSH
43129: LD_VAR 0 1
43133: ARRAY
43134: IN
43135: NOT
43136: IFFALSE 43251
// begin mc_busy_turret_list := ReplaceIn ( mc_busy_turret_list , [ base , mc_busy_turret_list [ base ] + 1 ] , x ) ;
43138: LD_ADDR_EXP 89
43142: PUSH
43143: LD_EXP 89
43147: PPUSH
43148: LD_VAR 0 1
43152: PUSH
43153: LD_EXP 89
43157: PUSH
43158: LD_VAR 0 1
43162: ARRAY
43163: PUSH
43164: LD_INT 1
43166: PLUS
43167: PUSH
43168: EMPTY
43169: LIST
43170: LIST
43171: PPUSH
43172: LD_VAR 0 9
43176: PPUSH
43177: CALL 57783 0 3
43181: ST_TO_ADDR
// mc_empty_turret_list := Replace ( mc_empty_turret_list , base , mc_empty_turret_list [ base ] diff x ) ;
43182: LD_ADDR_EXP 88
43186: PUSH
43187: LD_EXP 88
43191: PPUSH
43192: LD_VAR 0 1
43196: PPUSH
43197: LD_EXP 88
43201: PUSH
43202: LD_VAR 0 1
43206: ARRAY
43207: PUSH
43208: LD_VAR 0 9
43212: DIFF
43213: PPUSH
43214: CALL_OW 1
43218: ST_TO_ADDR
// ComEnterUnit ( unit , mc_busy_turret_list [ base ] [ mc_busy_turret_list [ base ] ] ) ;
43219: LD_VAR 0 3
43223: PPUSH
43224: LD_EXP 89
43228: PUSH
43229: LD_VAR 0 1
43233: ARRAY
43234: PUSH
43235: LD_EXP 89
43239: PUSH
43240: LD_VAR 0 1
43244: ARRAY
43245: ARRAY
43246: PPUSH
43247: CALL_OW 120
// end ; exit ;
43251: GO 43572
// end ; if tmp > 1 then
43253: LD_VAR 0 8
43257: PUSH
43258: LD_INT 1
43260: GREATER
43261: IFFALSE 43365
// for i = 2 to tmp do
43263: LD_ADDR_VAR 0 6
43267: PUSH
43268: DOUBLE
43269: LD_INT 2
43271: DEC
43272: ST_TO_ADDR
43273: LD_VAR 0 8
43277: PUSH
43278: FOR_TO
43279: IFFALSE 43363
// if BuildingStatus ( tmp [ i ] ) = bs_need_people then
43281: LD_VAR 0 8
43285: PUSH
43286: LD_VAR 0 6
43290: ARRAY
43291: PPUSH
43292: CALL_OW 461
43296: PUSH
43297: LD_INT 6
43299: EQUAL
43300: IFFALSE 43361
// begin x := tmp [ i ] ;
43302: LD_ADDR_VAR 0 9
43306: PUSH
43307: LD_VAR 0 8
43311: PUSH
43312: LD_VAR 0 6
43316: ARRAY
43317: ST_TO_ADDR
// tmp := Delete ( tmp , i ) ;
43318: LD_ADDR_VAR 0 8
43322: PUSH
43323: LD_VAR 0 8
43327: PPUSH
43328: LD_VAR 0 6
43332: PPUSH
43333: CALL_OW 3
43337: ST_TO_ADDR
// tmp := Insert ( tmp , 1 , x ) ;
43338: LD_ADDR_VAR 0 8
43342: PUSH
43343: LD_VAR 0 8
43347: PPUSH
43348: LD_INT 1
43350: PPUSH
43351: LD_VAR 0 9
43355: PPUSH
43356: CALL_OW 2
43360: ST_TO_ADDR
// end ;
43361: GO 43278
43363: POP
43364: POP
// for i in tmp do
43365: LD_ADDR_VAR 0 6
43369: PUSH
43370: LD_VAR 0 8
43374: PUSH
43375: FOR_IN
43376: IFFALSE 43445
// begin if ( UnitsInside ( i ) < 6 and not GetBType ( i ) in [ b_breastwork , b_bunker ] ) or UnitsInside ( i ) = 0 then
43378: LD_VAR 0 6
43382: PPUSH
43383: CALL_OW 313
43387: PUSH
43388: LD_INT 6
43390: LESS
43391: PUSH
43392: LD_VAR 0 6
43396: PPUSH
43397: CALL_OW 266
43401: PUSH
43402: LD_INT 31
43404: PUSH
43405: LD_INT 32
43407: PUSH
43408: EMPTY
43409: LIST
43410: LIST
43411: IN
43412: NOT
43413: AND
43414: PUSH
43415: LD_VAR 0 6
43419: PPUSH
43420: CALL_OW 313
43424: PUSH
43425: LD_INT 0
43427: EQUAL
43428: OR
43429: IFFALSE 43443
// begin j := i ;
43431: LD_ADDR_VAR 0 7
43435: PUSH
43436: LD_VAR 0 6
43440: ST_TO_ADDR
// break ;
43441: GO 43445
// end ; end ;
43443: GO 43375
43445: POP
43446: POP
// if j then
43447: LD_VAR 0 7
43451: IFFALSE 43469
// ComEnterUnit ( unit , j ) else
43453: LD_VAR 0 3
43457: PPUSH
43458: LD_VAR 0 7
43462: PPUSH
43463: CALL_OW 120
43467: GO 43572
// begin depot := UnitFilter ( base_unit_list , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) ;
43469: LD_ADDR_VAR 0 10
43473: PUSH
43474: LD_VAR 0 2
43478: PPUSH
43479: LD_INT 2
43481: PUSH
43482: LD_INT 30
43484: PUSH
43485: LD_INT 0
43487: PUSH
43488: EMPTY
43489: LIST
43490: LIST
43491: PUSH
43492: LD_INT 30
43494: PUSH
43495: LD_INT 1
43497: PUSH
43498: EMPTY
43499: LIST
43500: LIST
43501: PUSH
43502: EMPTY
43503: LIST
43504: LIST
43505: LIST
43506: PPUSH
43507: CALL_OW 72
43511: ST_TO_ADDR
// if depot then
43512: LD_VAR 0 10
43516: IFFALSE 43572
// begin depot := NearestUnitToUnit ( depot , unit ) ;
43518: LD_ADDR_VAR 0 10
43522: PUSH
43523: LD_VAR 0 10
43527: PPUSH
43528: LD_VAR 0 3
43532: PPUSH
43533: CALL_OW 74
43537: ST_TO_ADDR
// if GetDistUnits ( unit , depot ) > 10 then
43538: LD_VAR 0 3
43542: PPUSH
43543: LD_VAR 0 10
43547: PPUSH
43548: CALL_OW 296
43552: PUSH
43553: LD_INT 10
43555: GREATER
43556: IFFALSE 43572
// ComStandNearbyBuilding ( unit , depot ) ;
43558: LD_VAR 0 3
43562: PPUSH
43563: LD_VAR 0 10
43567: PPUSH
43568: CALL 51986 0 2
// end ; end ; end ;
43572: LD_VAR 0 5
43576: RET
// export function MC_Idle ( ) ; var i , j , tmp ; begin
43577: LD_INT 0
43579: PPUSH
43580: PPUSH
43581: PPUSH
43582: PPUSH
// if not mc_bases then
43583: LD_EXP 79
43587: NOT
43588: IFFALSE 43592
// exit ;
43590: GO 43831
// for i = 1 to mc_bases do
43592: LD_ADDR_VAR 0 2
43596: PUSH
43597: DOUBLE
43598: LD_INT 1
43600: DEC
43601: ST_TO_ADDR
43602: LD_EXP 79
43606: PUSH
43607: FOR_TO
43608: IFFALSE 43829
// begin tmp := UnitFilter ( mc_bases [ i ] , [ f_type , unit_human ] ) union mc_ape [ i ] ;
43610: LD_ADDR_VAR 0 4
43614: PUSH
43615: LD_EXP 79
43619: PUSH
43620: LD_VAR 0 2
43624: ARRAY
43625: PPUSH
43626: LD_INT 21
43628: PUSH
43629: LD_INT 1
43631: PUSH
43632: EMPTY
43633: LIST
43634: LIST
43635: PPUSH
43636: CALL_OW 72
43640: PUSH
43641: LD_EXP 108
43645: PUSH
43646: LD_VAR 0 2
43650: ARRAY
43651: UNION
43652: ST_TO_ADDR
// if not tmp then
43653: LD_VAR 0 4
43657: NOT
43658: IFFALSE 43662
// continue ;
43660: GO 43607
// for j in tmp do
43662: LD_ADDR_VAR 0 3
43666: PUSH
43667: LD_VAR 0 4
43671: PUSH
43672: FOR_IN
43673: IFFALSE 43825
// begin if not GetTag ( j ) and not HasTask ( j ) and not IsDrivenBy ( j ) and not IsInUnit ( j ) and not j in mc_need_heal [ i ] [ 1 ] and not j in mc_need_heal [ i ] [ 2 ] and not j in mc_repair_vehicle [ i ] then
43675: LD_VAR 0 3
43679: PPUSH
43680: CALL_OW 110
43684: NOT
43685: PUSH
43686: LD_VAR 0 3
43690: PPUSH
43691: CALL_OW 314
43695: NOT
43696: AND
43697: PUSH
43698: LD_VAR 0 3
43702: PPUSH
43703: CALL_OW 311
43707: NOT
43708: AND
43709: PUSH
43710: LD_VAR 0 3
43714: PPUSH
43715: CALL_OW 310
43719: NOT
43720: AND
43721: PUSH
43722: LD_VAR 0 3
43726: PUSH
43727: LD_EXP 82
43731: PUSH
43732: LD_VAR 0 2
43736: ARRAY
43737: PUSH
43738: LD_INT 1
43740: ARRAY
43741: IN
43742: NOT
43743: AND
43744: PUSH
43745: LD_VAR 0 3
43749: PUSH
43750: LD_EXP 82
43754: PUSH
43755: LD_VAR 0 2
43759: ARRAY
43760: PUSH
43761: LD_INT 2
43763: ARRAY
43764: IN
43765: NOT
43766: AND
43767: PUSH
43768: LD_VAR 0 3
43772: PUSH
43773: LD_EXP 91
43777: PUSH
43778: LD_VAR 0 2
43782: ARRAY
43783: IN
43784: NOT
43785: AND
43786: IFFALSE 43823
// MC_Back ( i , mc_bases [ i ] , j , GetClass ( j ) ) ;
43788: LD_VAR 0 2
43792: PPUSH
43793: LD_EXP 79
43797: PUSH
43798: LD_VAR 0 2
43802: ARRAY
43803: PPUSH
43804: LD_VAR 0 3
43808: PPUSH
43809: LD_VAR 0 3
43813: PPUSH
43814: CALL_OW 257
43818: PPUSH
43819: CALL 42595 0 4
// end ;
43823: GO 43672
43825: POP
43826: POP
// end ;
43827: GO 43607
43829: POP
43830: POP
// end ;
43831: LD_VAR 0 1
43835: RET
// export function MC_SetMinesField ( base , amount , area ) ; var i , tmp , list , x , j ; begin
43836: LD_INT 0
43838: PPUSH
43839: PPUSH
43840: PPUSH
43841: PPUSH
43842: PPUSH
43843: PPUSH
// if not mc_bases [ base ] then
43844: LD_EXP 79
43848: PUSH
43849: LD_VAR 0 1
43853: ARRAY
43854: NOT
43855: IFFALSE 43859
// exit ;
43857: GO 44041
// tmp := [ ] ;
43859: LD_ADDR_VAR 0 6
43863: PUSH
43864: EMPTY
43865: ST_TO_ADDR
// list := AreaToList ( area , 0 ) ;
43866: LD_ADDR_VAR 0 7
43870: PUSH
43871: LD_VAR 0 3
43875: PPUSH
43876: LD_INT 0
43878: PPUSH
43879: CALL_OW 517
43883: ST_TO_ADDR
// if not list then
43884: LD_VAR 0 7
43888: NOT
43889: IFFALSE 43893
// exit ;
43891: GO 44041
// for i = 1 to amount do
43893: LD_ADDR_VAR 0 5
43897: PUSH
43898: DOUBLE
43899: LD_INT 1
43901: DEC
43902: ST_TO_ADDR
43903: LD_VAR 0 2
43907: PUSH
43908: FOR_TO
43909: IFFALSE 43989
// begin x := rand ( 1 , list [ 1 ] ) ;
43911: LD_ADDR_VAR 0 8
43915: PUSH
43916: LD_INT 1
43918: PPUSH
43919: LD_VAR 0 7
43923: PUSH
43924: LD_INT 1
43926: ARRAY
43927: PPUSH
43928: CALL_OW 12
43932: ST_TO_ADDR
// tmp := Replace ( tmp , i , [ list [ 1 ] [ x ] , list [ 2 ] [ x ] ] ) ;
43933: LD_ADDR_VAR 0 6
43937: PUSH
43938: LD_VAR 0 6
43942: PPUSH
43943: LD_VAR 0 5
43947: PPUSH
43948: LD_VAR 0 7
43952: PUSH
43953: LD_INT 1
43955: ARRAY
43956: PUSH
43957: LD_VAR 0 8
43961: ARRAY
43962: PUSH
43963: LD_VAR 0 7
43967: PUSH
43968: LD_INT 2
43970: ARRAY
43971: PUSH
43972: LD_VAR 0 8
43976: ARRAY
43977: PUSH
43978: EMPTY
43979: LIST
43980: LIST
43981: PPUSH
43982: CALL_OW 1
43986: ST_TO_ADDR
// end ;
43987: GO 43908
43989: POP
43990: POP
// mc_mines := Replace ( mc_mines , base , tmp ) ;
43991: LD_ADDR_EXP 92
43995: PUSH
43996: LD_EXP 92
44000: PPUSH
44001: LD_VAR 0 1
44005: PPUSH
44006: LD_VAR 0 6
44010: PPUSH
44011: CALL_OW 1
44015: ST_TO_ADDR
// mc_minefields := Replace ( mc_minefields , base , area ) ;
44016: LD_ADDR_EXP 94
44020: PUSH
44021: LD_EXP 94
44025: PPUSH
44026: LD_VAR 0 1
44030: PPUSH
44031: LD_VAR 0 3
44035: PPUSH
44036: CALL_OW 1
44040: ST_TO_ADDR
// end ;
44041: LD_VAR 0 4
44045: RET
// export function MC_SetBuildingList ( base , construct_list ) ; begin
44046: LD_INT 0
44048: PPUSH
// if not mc_bases [ base ] then
44049: LD_EXP 79
44053: PUSH
44054: LD_VAR 0 1
44058: ARRAY
44059: NOT
44060: IFFALSE 44064
// exit ;
44062: GO 44089
// mc_build_list := Replace ( mc_build_list , base , construct_list ) ;
44064: LD_ADDR_EXP 84
44068: PUSH
44069: LD_EXP 84
44073: PPUSH
44074: LD_VAR 0 1
44078: PPUSH
44079: LD_VAR 0 2
44083: PPUSH
44084: CALL_OW 1
44088: ST_TO_ADDR
// end ;
44089: LD_VAR 0 3
44093: RET
// export function MC_InsertBuildingList ( base , list ) ; begin
44094: LD_INT 0
44096: PPUSH
// if not mc_bases [ base ] then
44097: LD_EXP 79
44101: PUSH
44102: LD_VAR 0 1
44106: ARRAY
44107: NOT
44108: IFFALSE 44112
// exit ;
44110: GO 44149
// mc_build_list := Replace ( mc_build_list , base , mc_build_list [ base ] union list ) ;
44112: LD_ADDR_EXP 84
44116: PUSH
44117: LD_EXP 84
44121: PPUSH
44122: LD_VAR 0 1
44126: PPUSH
44127: LD_EXP 84
44131: PUSH
44132: LD_VAR 0 1
44136: ARRAY
44137: PUSH
44138: LD_VAR 0 2
44142: UNION
44143: PPUSH
44144: CALL_OW 1
44148: ST_TO_ADDR
// end ;
44149: LD_VAR 0 3
44153: RET
// export function MC_SetProduceList ( base , produce_list ) ; begin
44154: LD_INT 0
44156: PPUSH
// if not mc_bases [ base ] then
44157: LD_EXP 79
44161: PUSH
44162: LD_VAR 0 1
44166: ARRAY
44167: NOT
44168: IFFALSE 44172
// exit ;
44170: GO 44197
// mc_produce := Replace ( mc_produce , base , produce_list ) ;
44172: LD_ADDR_EXP 100
44176: PUSH
44177: LD_EXP 100
44181: PPUSH
44182: LD_VAR 0 1
44186: PPUSH
44187: LD_VAR 0 2
44191: PPUSH
44192: CALL_OW 1
44196: ST_TO_ADDR
// end ;
44197: LD_VAR 0 3
44201: RET
// export function MC_InsertProduceList ( base , components ) ; begin
44202: LD_INT 0
44204: PPUSH
// if not mc_bases [ base ] then
44205: LD_EXP 79
44209: PUSH
44210: LD_VAR 0 1
44214: ARRAY
44215: NOT
44216: IFFALSE 44220
// exit ;
44218: GO 44257
// mc_produce := Replace ( mc_produce , base , mc_produce [ base ] ^ components ) ;
44220: LD_ADDR_EXP 100
44224: PUSH
44225: LD_EXP 100
44229: PPUSH
44230: LD_VAR 0 1
44234: PPUSH
44235: LD_EXP 100
44239: PUSH
44240: LD_VAR 0 1
44244: ARRAY
44245: PUSH
44246: LD_VAR 0 2
44250: ADD
44251: PPUSH
44252: CALL_OW 1
44256: ST_TO_ADDR
// end ;
44257: LD_VAR 0 3
44261: RET
// export function MC_SetDefenderList ( base , deflist ) ; begin
44262: LD_INT 0
44264: PPUSH
// if not mc_bases [ base ] then
44265: LD_EXP 79
44269: PUSH
44270: LD_VAR 0 1
44274: ARRAY
44275: NOT
44276: IFFALSE 44280
// exit ;
44278: GO 44334
// mc_defender := Replace ( mc_defender , base , deflist ) ;
44280: LD_ADDR_EXP 101
44284: PUSH
44285: LD_EXP 101
44289: PPUSH
44290: LD_VAR 0 1
44294: PPUSH
44295: LD_VAR 0 2
44299: PPUSH
44300: CALL_OW 1
44304: ST_TO_ADDR
// mc_defender_limit := Replace ( mc_defender_limit , base , deflist + 0 ) ;
44305: LD_ADDR_EXP 90
44309: PUSH
44310: LD_EXP 90
44314: PPUSH
44315: LD_VAR 0 1
44319: PPUSH
44320: LD_VAR 0 2
44324: PUSH
44325: LD_INT 0
44327: PLUS
44328: PPUSH
44329: CALL_OW 1
44333: ST_TO_ADDR
// end ;
44334: LD_VAR 0 3
44338: RET
// export function MC_SetDefenderLimit ( base , limit ) ; begin
44339: LD_INT 0
44341: PPUSH
// if not mc_bases [ base ] then
44342: LD_EXP 79
44346: PUSH
44347: LD_VAR 0 1
44351: ARRAY
44352: NOT
44353: IFFALSE 44357
// exit ;
44355: GO 44382
// mc_defender_limit := Replace ( mc_defender_limit , base , limit ) ;
44357: LD_ADDR_EXP 90
44361: PUSH
44362: LD_EXP 90
44366: PPUSH
44367: LD_VAR 0 1
44371: PPUSH
44372: LD_VAR 0 2
44376: PPUSH
44377: CALL_OW 1
44381: ST_TO_ADDR
// end ;
44382: LD_VAR 0 3
44386: RET
// export function MC_PrepareAttack ( base , group , path , flags ) ; var i , j , tmp ; begin
44387: LD_INT 0
44389: PPUSH
44390: PPUSH
44391: PPUSH
44392: PPUSH
// if not mc_bases [ base ] then
44393: LD_EXP 79
44397: PUSH
44398: LD_VAR 0 1
44402: ARRAY
44403: NOT
44404: IFFALSE 44408
// exit ;
44406: GO 44473
// mc_attack := ReplaceIn ( mc_attack , [ base , mc_attack [ base ] + 1 ] , [ base , group , path , flags ] ) ;
44408: LD_ADDR_EXP 99
44412: PUSH
44413: LD_EXP 99
44417: PPUSH
44418: LD_VAR 0 1
44422: PUSH
44423: LD_EXP 99
44427: PUSH
44428: LD_VAR 0 1
44432: ARRAY
44433: PUSH
44434: LD_INT 1
44436: PLUS
44437: PUSH
44438: EMPTY
44439: LIST
44440: LIST
44441: PPUSH
44442: LD_VAR 0 1
44446: PUSH
44447: LD_VAR 0 2
44451: PUSH
44452: LD_VAR 0 3
44456: PUSH
44457: LD_VAR 0 4
44461: PUSH
44462: EMPTY
44463: LIST
44464: LIST
44465: LIST
44466: LIST
44467: PPUSH
44468: CALL 57783 0 3
44472: ST_TO_ADDR
// end ;
44473: LD_VAR 0 5
44477: RET
// export function MC_SetDepositsXY ( base , deposits_list ) ; begin
44478: LD_INT 0
44480: PPUSH
// if not mc_bases [ base ] then
44481: LD_EXP 79
44485: PUSH
44486: LD_VAR 0 1
44490: ARRAY
44491: NOT
44492: IFFALSE 44496
// exit ;
44494: GO 44521
// mc_deposits_xy := Replace ( mc_deposits_xy , base , deposits_list ) ;
44496: LD_ADDR_EXP 116
44500: PUSH
44501: LD_EXP 116
44505: PPUSH
44506: LD_VAR 0 1
44510: PPUSH
44511: LD_VAR 0 2
44515: PPUSH
44516: CALL_OW 1
44520: ST_TO_ADDR
// end ;
44521: LD_VAR 0 3
44525: RET
// export function MC_GetMinesField ( base ) ; begin
44526: LD_INT 0
44528: PPUSH
// result := mc_mines [ base ] ;
44529: LD_ADDR_VAR 0 2
44533: PUSH
44534: LD_EXP 92
44538: PUSH
44539: LD_VAR 0 1
44543: ARRAY
44544: ST_TO_ADDR
// end ;
44545: LD_VAR 0 2
44549: RET
// export function MC_GetProduceList ( base ) ; begin
44550: LD_INT 0
44552: PPUSH
// result := mc_produce [ base ] ;
44553: LD_ADDR_VAR 0 2
44557: PUSH
44558: LD_EXP 100
44562: PUSH
44563: LD_VAR 0 1
44567: ARRAY
44568: ST_TO_ADDR
// end ;
44569: LD_VAR 0 2
44573: RET
// export function MC_GetBuilding ( base , btype ) ; var i ; begin
44574: LD_INT 0
44576: PPUSH
44577: PPUSH
// if not mc_bases then
44578: LD_EXP 79
44582: NOT
44583: IFFALSE 44587
// exit ;
44585: GO 44652
// if mc_bases [ base ] then
44587: LD_EXP 79
44591: PUSH
44592: LD_VAR 0 1
44596: ARRAY
44597: IFFALSE 44652
// begin result := UnitFilter ( mc_bases [ base ] , [ f_btype , btype ] ) ;
44599: LD_ADDR_VAR 0 3
44603: PUSH
44604: LD_EXP 79
44608: PUSH
44609: LD_VAR 0 1
44613: ARRAY
44614: PPUSH
44615: LD_INT 30
44617: PUSH
44618: LD_VAR 0 2
44622: PUSH
44623: EMPTY
44624: LIST
44625: LIST
44626: PPUSH
44627: CALL_OW 72
44631: ST_TO_ADDR
// if result then
44632: LD_VAR 0 3
44636: IFFALSE 44652
// result := result [ 1 ] ;
44638: LD_ADDR_VAR 0 3
44642: PUSH
44643: LD_VAR 0 3
44647: PUSH
44648: LD_INT 1
44650: ARRAY
44651: ST_TO_ADDR
// end ; end ;
44652: LD_VAR 0 3
44656: RET
// export function MC_GetBuildings ( base , btype ) ; var i ; begin
44657: LD_INT 0
44659: PPUSH
44660: PPUSH
// if not mc_bases then
44661: LD_EXP 79
44665: NOT
44666: IFFALSE 44670
// exit ;
44668: GO 44715
// if mc_bases [ base ] then
44670: LD_EXP 79
44674: PUSH
44675: LD_VAR 0 1
44679: ARRAY
44680: IFFALSE 44715
// result := UnitFilter ( mc_bases [ base ] , [ f_btype , btype ] ) ;
44682: LD_ADDR_VAR 0 3
44686: PUSH
44687: LD_EXP 79
44691: PUSH
44692: LD_VAR 0 1
44696: ARRAY
44697: PPUSH
44698: LD_INT 30
44700: PUSH
44701: LD_VAR 0 2
44705: PUSH
44706: EMPTY
44707: LIST
44708: LIST
44709: PPUSH
44710: CALL_OW 72
44714: ST_TO_ADDR
// end ;
44715: LD_VAR 0 3
44719: RET
// export function MC_SetTame ( base , area ) ; begin
44720: LD_INT 0
44722: PPUSH
// if not mc_bases or not base then
44723: LD_EXP 79
44727: NOT
44728: PUSH
44729: LD_VAR 0 1
44733: NOT
44734: OR
44735: IFFALSE 44739
// exit ;
44737: GO 44764
// mc_can_tame := Replace ( mc_can_tame , base , area ) ;
44739: LD_ADDR_EXP 107
44743: PUSH
44744: LD_EXP 107
44748: PPUSH
44749: LD_VAR 0 1
44753: PPUSH
44754: LD_VAR 0 2
44758: PPUSH
44759: CALL_OW 1
44763: ST_TO_ADDR
// end ;
44764: LD_VAR 0 3
44768: RET
// export function MC_SetUpgradeBuilding ( base , btype ) ; var tmp ; begin
44769: LD_INT 0
44771: PPUSH
44772: PPUSH
// if not mc_bases or not base then
44773: LD_EXP 79
44777: NOT
44778: PUSH
44779: LD_VAR 0 1
44783: NOT
44784: OR
44785: IFFALSE 44789
// exit ;
44787: GO 44891
// tmp := UnitFilter ( mc_bases [ base ] , [ f_btype , btype ] ) ;
44789: LD_ADDR_VAR 0 4
44793: PUSH
44794: LD_EXP 79
44798: PUSH
44799: LD_VAR 0 1
44803: ARRAY
44804: PPUSH
44805: LD_INT 30
44807: PUSH
44808: LD_VAR 0 2
44812: PUSH
44813: EMPTY
44814: LIST
44815: LIST
44816: PPUSH
44817: CALL_OW 72
44821: ST_TO_ADDR
// if not tmp then
44822: LD_VAR 0 4
44826: NOT
44827: IFFALSE 44831
// exit ;
44829: GO 44891
// mc_build_upgrade := Replace ( mc_build_upgrade , base , Insert ( mc_build_upgrade [ base ] , mc_build_upgrade [ base ] + 1 , tmp [ 1 ] ) ) ;
44831: LD_ADDR_EXP 111
44835: PUSH
44836: LD_EXP 111
44840: PPUSH
44841: LD_VAR 0 1
44845: PPUSH
44846: LD_EXP 111
44850: PUSH
44851: LD_VAR 0 1
44855: ARRAY
44856: PPUSH
44857: LD_EXP 111
44861: PUSH
44862: LD_VAR 0 1
44866: ARRAY
44867: PUSH
44868: LD_INT 1
44870: PLUS
44871: PPUSH
44872: LD_VAR 0 4
44876: PUSH
44877: LD_INT 1
44879: ARRAY
44880: PPUSH
44881: CALL_OW 2
44885: PPUSH
44886: CALL_OW 1
44890: ST_TO_ADDR
// end ;
44891: LD_VAR 0 3
44895: RET
// export function MC_SetLabKind ( base , kinds ) ; var i ; begin
44896: LD_INT 0
44898: PPUSH
44899: PPUSH
// if not mc_bases or not base or not kinds then
44900: LD_EXP 79
44904: NOT
44905: PUSH
44906: LD_VAR 0 1
44910: NOT
44911: OR
44912: PUSH
44913: LD_VAR 0 2
44917: NOT
44918: OR
44919: IFFALSE 44923
// exit ;
44921: GO 44984
// for i in kinds do
44923: LD_ADDR_VAR 0 4
44927: PUSH
44928: LD_VAR 0 2
44932: PUSH
44933: FOR_IN
44934: IFFALSE 44982
// mc_lab_upgrade := ReplaceIn ( mc_lab_upgrade , [ base , mc_lab_upgrade [ base ] + 1 ] , i ) ;
44936: LD_ADDR_EXP 113
44940: PUSH
44941: LD_EXP 113
44945: PPUSH
44946: LD_VAR 0 1
44950: PUSH
44951: LD_EXP 113
44955: PUSH
44956: LD_VAR 0 1
44960: ARRAY
44961: PUSH
44962: LD_INT 1
44964: PLUS
44965: PUSH
44966: EMPTY
44967: LIST
44968: LIST
44969: PPUSH
44970: LD_VAR 0 4
44974: PPUSH
44975: CALL 57783 0 3
44979: ST_TO_ADDR
44980: GO 44933
44982: POP
44983: POP
// end ;
44984: LD_VAR 0 3
44988: RET
// export function MC_SetCratesArea ( base , areas ) ; begin
44989: LD_INT 0
44991: PPUSH
// if not mc_bases or not base or not areas then
44992: LD_EXP 79
44996: NOT
44997: PUSH
44998: LD_VAR 0 1
45002: NOT
45003: OR
45004: PUSH
45005: LD_VAR 0 2
45009: NOT
45010: OR
45011: IFFALSE 45015
// exit ;
45013: GO 45040
// mc_crates_area := Replace ( mc_crates_area , base , areas ) ;
45015: LD_ADDR_EXP 97
45019: PUSH
45020: LD_EXP 97
45024: PPUSH
45025: LD_VAR 0 1
45029: PPUSH
45030: LD_VAR 0 2
45034: PPUSH
45035: CALL_OW 1
45039: ST_TO_ADDR
// end ;
45040: LD_VAR 0 3
45044: RET
// export function MC_SetTeleportExit ( base , teleports_exit ) ; begin
45045: LD_INT 0
45047: PPUSH
// if not mc_bases or not base or not teleports_exit then
45048: LD_EXP 79
45052: NOT
45053: PUSH
45054: LD_VAR 0 1
45058: NOT
45059: OR
45060: PUSH
45061: LD_VAR 0 2
45065: NOT
45066: OR
45067: IFFALSE 45071
// exit ;
45069: GO 45096
// mc_teleport_exit := Replace ( mc_teleport_exit , base , teleports_exit ) ;
45071: LD_ADDR_EXP 114
45075: PUSH
45076: LD_EXP 114
45080: PPUSH
45081: LD_VAR 0 1
45085: PPUSH
45086: LD_VAR 0 2
45090: PPUSH
45091: CALL_OW 1
45095: ST_TO_ADDR
// end ;
45096: LD_VAR 0 3
45100: RET
// export function MC_SetFactoryExtension ( base , x , y , d , ext_list ) ; var i , tmp ; begin
45101: LD_INT 0
45103: PPUSH
45104: PPUSH
45105: PPUSH
// if not mc_bases or not base or not ext_list then
45106: LD_EXP 79
45110: NOT
45111: PUSH
45112: LD_VAR 0 1
45116: NOT
45117: OR
45118: PUSH
45119: LD_VAR 0 5
45123: NOT
45124: OR
45125: IFFALSE 45129
// exit ;
45127: GO 45302
// tmp := GetFacExtXYD ( x , y , d ) ;
45129: LD_ADDR_VAR 0 8
45133: PUSH
45134: LD_VAR 0 2
45138: PPUSH
45139: LD_VAR 0 3
45143: PPUSH
45144: LD_VAR 0 4
45148: PPUSH
45149: CALL 91171 0 3
45153: ST_TO_ADDR
// if not tmp then
45154: LD_VAR 0 8
45158: NOT
45159: IFFALSE 45163
// exit ;
45161: GO 45302
// for i in tmp do
45163: LD_ADDR_VAR 0 7
45167: PUSH
45168: LD_VAR 0 8
45172: PUSH
45173: FOR_IN
45174: IFFALSE 45300
// begin mc_build_list := Replace ( mc_build_list , base , Insert ( mc_build_list [ base ] , mc_build_list [ base ] + 1 , [ ext_list [ 1 ] , i [ 1 ] , i [ 2 ] , i [ 3 ] ] ) ) ;
45176: LD_ADDR_EXP 84
45180: PUSH
45181: LD_EXP 84
45185: PPUSH
45186: LD_VAR 0 1
45190: PPUSH
45191: LD_EXP 84
45195: PUSH
45196: LD_VAR 0 1
45200: ARRAY
45201: PPUSH
45202: LD_EXP 84
45206: PUSH
45207: LD_VAR 0 1
45211: ARRAY
45212: PUSH
45213: LD_INT 1
45215: PLUS
45216: PPUSH
45217: LD_VAR 0 5
45221: PUSH
45222: LD_INT 1
45224: ARRAY
45225: PUSH
45226: LD_VAR 0 7
45230: PUSH
45231: LD_INT 1
45233: ARRAY
45234: PUSH
45235: LD_VAR 0 7
45239: PUSH
45240: LD_INT 2
45242: ARRAY
45243: PUSH
45244: LD_VAR 0 7
45248: PUSH
45249: LD_INT 3
45251: ARRAY
45252: PUSH
45253: EMPTY
45254: LIST
45255: LIST
45256: LIST
45257: LIST
45258: PPUSH
45259: CALL_OW 2
45263: PPUSH
45264: CALL_OW 1
45268: ST_TO_ADDR
// ext_list := Delete ( ext_list , 1 ) ;
45269: LD_ADDR_VAR 0 5
45273: PUSH
45274: LD_VAR 0 5
45278: PPUSH
45279: LD_INT 1
45281: PPUSH
45282: CALL_OW 3
45286: ST_TO_ADDR
// if not ext_list then
45287: LD_VAR 0 5
45291: NOT
45292: IFFALSE 45298
// exit ;
45294: POP
45295: POP
45296: GO 45302
// end ;
45298: GO 45173
45300: POP
45301: POP
// end ;
45302: LD_VAR 0 6
45306: RET
// export function MC_SetAllowedTurretWeapons ( base , weapon_list ) ; begin
45307: LD_INT 0
45309: PPUSH
// if not mc_bases or not base or not weapon_list then
45310: LD_EXP 79
45314: NOT
45315: PUSH
45316: LD_VAR 0 1
45320: NOT
45321: OR
45322: PUSH
45323: LD_VAR 0 2
45327: NOT
45328: OR
45329: IFFALSE 45333
// exit ;
45331: GO 45358
// mc_allowed_tower_weapons := Replace ( mc_allowed_tower_weapons , base , weapon_list ) ;
45333: LD_ADDR_EXP 118
45337: PUSH
45338: LD_EXP 118
45342: PPUSH
45343: LD_VAR 0 1
45347: PPUSH
45348: LD_VAR 0 2
45352: PPUSH
45353: CALL_OW 1
45357: ST_TO_ADDR
// end ;
45358: LD_VAR 0 3
45362: RET
// export function MC_SetTechList ( base , tech_list ) ; begin
45363: LD_INT 0
45365: PPUSH
// if not mc_bases or not base or not tech_list then
45366: LD_EXP 79
45370: NOT
45371: PUSH
45372: LD_VAR 0 1
45376: NOT
45377: OR
45378: PUSH
45379: LD_VAR 0 2
45383: NOT
45384: OR
45385: IFFALSE 45389
// exit ;
45387: GO 45414
// mc_tech := Replace ( mc_tech , base , tech_list ) ;
45389: LD_ADDR_EXP 106
45393: PUSH
45394: LD_EXP 106
45398: PPUSH
45399: LD_VAR 0 1
45403: PPUSH
45404: LD_VAR 0 2
45408: PPUSH
45409: CALL_OW 1
45413: ST_TO_ADDR
// end ;
45414: LD_VAR 0 3
45418: RET
// export function MC_SetParkingArea ( base , parking_area ) ; begin
45419: LD_INT 0
45421: PPUSH
// if not mc_bases or not parking_area or not base then
45422: LD_EXP 79
45426: NOT
45427: PUSH
45428: LD_VAR 0 2
45432: NOT
45433: OR
45434: PUSH
45435: LD_VAR 0 1
45439: NOT
45440: OR
45441: IFFALSE 45445
// exit ;
45443: GO 45470
// mc_parking := Replace ( mc_parking , base , parking_area ) ;
45445: LD_ADDR_EXP 103
45449: PUSH
45450: LD_EXP 103
45454: PPUSH
45455: LD_VAR 0 1
45459: PPUSH
45460: LD_VAR 0 2
45464: PPUSH
45465: CALL_OW 1
45469: ST_TO_ADDR
// end ;
45470: LD_VAR 0 3
45474: RET
// export function MC_SetScanArea ( base , scan_area ) ; begin
45475: LD_INT 0
45477: PPUSH
// if not mc_bases or not base or not scan_area then
45478: LD_EXP 79
45482: NOT
45483: PUSH
45484: LD_VAR 0 1
45488: NOT
45489: OR
45490: PUSH
45491: LD_VAR 0 2
45495: NOT
45496: OR
45497: IFFALSE 45501
// exit ;
45499: GO 45526
// mc_scan_area := Replace ( mc_scan_area , base , scan_area ) ;
45501: LD_ADDR_EXP 104
45505: PUSH
45506: LD_EXP 104
45510: PPUSH
45511: LD_VAR 0 1
45515: PPUSH
45516: LD_VAR 0 2
45520: PPUSH
45521: CALL_OW 1
45525: ST_TO_ADDR
// end ;
45526: LD_VAR 0 3
45530: RET
// export function MC_NotTameApeman ( base ) ; var ape_techs ; begin
45531: LD_INT 0
45533: PPUSH
45534: PPUSH
// if not mc_bases or not base then
45535: LD_EXP 79
45539: NOT
45540: PUSH
45541: LD_VAR 0 1
45545: NOT
45546: OR
45547: IFFALSE 45551
// exit ;
45549: GO 45615
// ape_techs := [ 1 , 2 , 3 , 4 , 11 ] ;
45551: LD_ADDR_VAR 0 3
45555: PUSH
45556: LD_INT 1
45558: PUSH
45559: LD_INT 2
45561: PUSH
45562: LD_INT 3
45564: PUSH
45565: LD_INT 4
45567: PUSH
45568: LD_INT 11
45570: PUSH
45571: EMPTY
45572: LIST
45573: LIST
45574: LIST
45575: LIST
45576: LIST
45577: ST_TO_ADDR
// mc_tech := Replace ( mc_tech , base , mc_tech [ base ] diff ape_techs ) ;
45578: LD_ADDR_EXP 106
45582: PUSH
45583: LD_EXP 106
45587: PPUSH
45588: LD_VAR 0 1
45592: PPUSH
45593: LD_EXP 106
45597: PUSH
45598: LD_VAR 0 1
45602: ARRAY
45603: PUSH
45604: LD_VAR 0 3
45608: DIFF
45609: PPUSH
45610: CALL_OW 1
45614: ST_TO_ADDR
// end ;
45615: LD_VAR 0 2
45619: RET
// export function MC_GetVehicles ( base , onlyCombat ) ; begin
45620: LD_INT 0
45622: PPUSH
// result := mc_vehicles [ base ] ;
45623: LD_ADDR_VAR 0 3
45627: PUSH
45628: LD_EXP 98
45632: PUSH
45633: LD_VAR 0 1
45637: ARRAY
45638: ST_TO_ADDR
// if onlyCombat then
45639: LD_VAR 0 2
45643: IFFALSE 45808
// result := result diff UnitFilter ( result , [ f_or , [ f_weapon , us_cargo_bay ] , [ f_weapon , ru_cargo_bay ] , [ f_weapon , ru_big_cargo_bay ] , [ f_weapon , ar_cargo_bay ] , [ f_weapon , us_crane ] , [ f_weapon , ru_crane ] , [ f_weapon , us_bulldozer ] , [ f_weapon , ru_bulldozer ] , [ f_weapon , ru_radar ] , [ f_weapon , ar_control_tower ] , [ f_weapon , ru_siberium_rocket ] , [ f_weapon , us_siberium_rocket ] ] ) ;
45645: LD_ADDR_VAR 0 3
45649: PUSH
45650: LD_VAR 0 3
45654: PUSH
45655: LD_VAR 0 3
45659: PPUSH
45660: LD_INT 2
45662: PUSH
45663: LD_INT 34
45665: PUSH
45666: LD_INT 12
45668: PUSH
45669: EMPTY
45670: LIST
45671: LIST
45672: PUSH
45673: LD_INT 34
45675: PUSH
45676: LD_INT 51
45678: PUSH
45679: EMPTY
45680: LIST
45681: LIST
45682: PUSH
45683: LD_INT 34
45685: PUSH
45686: LD_EXP 73
45690: PUSH
45691: EMPTY
45692: LIST
45693: LIST
45694: PUSH
45695: LD_INT 34
45697: PUSH
45698: LD_INT 32
45700: PUSH
45701: EMPTY
45702: LIST
45703: LIST
45704: PUSH
45705: LD_INT 34
45707: PUSH
45708: LD_INT 13
45710: PUSH
45711: EMPTY
45712: LIST
45713: LIST
45714: PUSH
45715: LD_INT 34
45717: PUSH
45718: LD_INT 52
45720: PUSH
45721: EMPTY
45722: LIST
45723: LIST
45724: PUSH
45725: LD_INT 34
45727: PUSH
45728: LD_INT 14
45730: PUSH
45731: EMPTY
45732: LIST
45733: LIST
45734: PUSH
45735: LD_INT 34
45737: PUSH
45738: LD_INT 53
45740: PUSH
45741: EMPTY
45742: LIST
45743: LIST
45744: PUSH
45745: LD_INT 34
45747: PUSH
45748: LD_EXP 72
45752: PUSH
45753: EMPTY
45754: LIST
45755: LIST
45756: PUSH
45757: LD_INT 34
45759: PUSH
45760: LD_INT 31
45762: PUSH
45763: EMPTY
45764: LIST
45765: LIST
45766: PUSH
45767: LD_INT 34
45769: PUSH
45770: LD_INT 48
45772: PUSH
45773: EMPTY
45774: LIST
45775: LIST
45776: PUSH
45777: LD_INT 34
45779: PUSH
45780: LD_INT 8
45782: PUSH
45783: EMPTY
45784: LIST
45785: LIST
45786: PUSH
45787: EMPTY
45788: LIST
45789: LIST
45790: LIST
45791: LIST
45792: LIST
45793: LIST
45794: LIST
45795: LIST
45796: LIST
45797: LIST
45798: LIST
45799: LIST
45800: LIST
45801: PPUSH
45802: CALL_OW 72
45806: DIFF
45807: ST_TO_ADDR
// end ; end_of_file
45808: LD_VAR 0 3
45812: RET
// export function MCE_ApemanTamed ( ape , sci ) ; var i , tmp ; begin
45813: LD_INT 0
45815: PPUSH
45816: PPUSH
45817: PPUSH
// if not mc_bases or not skirmish then
45818: LD_EXP 79
45822: NOT
45823: PUSH
45824: LD_EXP 77
45828: NOT
45829: OR
45830: IFFALSE 45834
// exit ;
45832: GO 45999
// for i = 1 to mc_bases do
45834: LD_ADDR_VAR 0 4
45838: PUSH
45839: DOUBLE
45840: LD_INT 1
45842: DEC
45843: ST_TO_ADDR
45844: LD_EXP 79
45848: PUSH
45849: FOR_TO
45850: IFFALSE 45997
// begin if sci in mc_bases [ i ] then
45852: LD_VAR 0 2
45856: PUSH
45857: LD_EXP 79
45861: PUSH
45862: LD_VAR 0 4
45866: ARRAY
45867: IN
45868: IFFALSE 45995
// begin mc_ape := ReplaceIn ( mc_ape , [ i , mc_ape [ i ] + 1 ] , ape ) ;
45870: LD_ADDR_EXP 108
45874: PUSH
45875: LD_EXP 108
45879: PPUSH
45880: LD_VAR 0 4
45884: PUSH
45885: LD_EXP 108
45889: PUSH
45890: LD_VAR 0 4
45894: ARRAY
45895: PUSH
45896: LD_INT 1
45898: PLUS
45899: PUSH
45900: EMPTY
45901: LIST
45902: LIST
45903: PPUSH
45904: LD_VAR 0 1
45908: PPUSH
45909: CALL 57783 0 3
45913: ST_TO_ADDR
// tmp := NearestUnitToUnit ( UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) , ape ) ;
45914: LD_ADDR_VAR 0 5
45918: PUSH
45919: LD_EXP 79
45923: PUSH
45924: LD_VAR 0 4
45928: ARRAY
45929: PPUSH
45930: LD_INT 2
45932: PUSH
45933: LD_INT 30
45935: PUSH
45936: LD_INT 0
45938: PUSH
45939: EMPTY
45940: LIST
45941: LIST
45942: PUSH
45943: LD_INT 30
45945: PUSH
45946: LD_INT 1
45948: PUSH
45949: EMPTY
45950: LIST
45951: LIST
45952: PUSH
45953: EMPTY
45954: LIST
45955: LIST
45956: LIST
45957: PPUSH
45958: CALL_OW 72
45962: PPUSH
45963: LD_VAR 0 1
45967: PPUSH
45968: CALL_OW 74
45972: ST_TO_ADDR
// if tmp then
45973: LD_VAR 0 5
45977: IFFALSE 45993
// ComStandNearbyBuilding ( ape , tmp ) ;
45979: LD_VAR 0 1
45983: PPUSH
45984: LD_VAR 0 5
45988: PPUSH
45989: CALL 51986 0 2
// break ;
45993: GO 45997
// end ; end ;
45995: GO 45849
45997: POP
45998: POP
// end ;
45999: LD_VAR 0 3
46003: RET
// export function MCE_EnterBuilding ( building , unit ) ; var i , tmp ; begin
46004: LD_INT 0
46006: PPUSH
46007: PPUSH
46008: PPUSH
// if not mc_bases or not skirmish then
46009: LD_EXP 79
46013: NOT
46014: PUSH
46015: LD_EXP 77
46019: NOT
46020: OR
46021: IFFALSE 46025
// exit ;
46023: GO 46114
// for i = 1 to mc_bases do
46025: LD_ADDR_VAR 0 4
46029: PUSH
46030: DOUBLE
46031: LD_INT 1
46033: DEC
46034: ST_TO_ADDR
46035: LD_EXP 79
46039: PUSH
46040: FOR_TO
46041: IFFALSE 46112
// begin if building in mc_busy_turret_list [ i ] then
46043: LD_VAR 0 1
46047: PUSH
46048: LD_EXP 89
46052: PUSH
46053: LD_VAR 0 4
46057: ARRAY
46058: IN
46059: IFFALSE 46110
// begin tmp := mc_busy_turret_list [ i ] diff building ;
46061: LD_ADDR_VAR 0 5
46065: PUSH
46066: LD_EXP 89
46070: PUSH
46071: LD_VAR 0 4
46075: ARRAY
46076: PUSH
46077: LD_VAR 0 1
46081: DIFF
46082: ST_TO_ADDR
// mc_busy_turret_list := Replace ( mc_busy_turret_list , i , tmp ) ;
46083: LD_ADDR_EXP 89
46087: PUSH
46088: LD_EXP 89
46092: PPUSH
46093: LD_VAR 0 4
46097: PPUSH
46098: LD_VAR 0 5
46102: PPUSH
46103: CALL_OW 1
46107: ST_TO_ADDR
// break ;
46108: GO 46112
// end ; end ;
46110: GO 46040
46112: POP
46113: POP
// end ;
46114: LD_VAR 0 3
46118: RET
// export function MCE_BuildingCaptured ( building , side , capturning_unit ) ; var i , tmp ; begin
46119: LD_INT 0
46121: PPUSH
46122: PPUSH
46123: PPUSH
// if not mc_bases or not skirmish then
46124: LD_EXP 79
46128: NOT
46129: PUSH
46130: LD_EXP 77
46134: NOT
46135: OR
46136: IFFALSE 46140
// exit ;
46138: GO 46339
// for i = 1 to mc_bases do
46140: LD_ADDR_VAR 0 5
46144: PUSH
46145: DOUBLE
46146: LD_INT 1
46148: DEC
46149: ST_TO_ADDR
46150: LD_EXP 79
46154: PUSH
46155: FOR_TO
46156: IFFALSE 46337
// if building in mc_bases [ i ] then
46158: LD_VAR 0 1
46162: PUSH
46163: LD_EXP 79
46167: PUSH
46168: LD_VAR 0 5
46172: ARRAY
46173: IN
46174: IFFALSE 46335
// begin tmp := mc_bases [ i ] diff building ;
46176: LD_ADDR_VAR 0 6
46180: PUSH
46181: LD_EXP 79
46185: PUSH
46186: LD_VAR 0 5
46190: ARRAY
46191: PUSH
46192: LD_VAR 0 1
46196: DIFF
46197: ST_TO_ADDR
// mc_bases := Replace ( mc_bases , i , tmp ) ;
46198: LD_ADDR_EXP 79
46202: PUSH
46203: LD_EXP 79
46207: PPUSH
46208: LD_VAR 0 5
46212: PPUSH
46213: LD_VAR 0 6
46217: PPUSH
46218: CALL_OW 1
46222: ST_TO_ADDR
// if building in mc_turret_list [ i ] then
46223: LD_VAR 0 1
46227: PUSH
46228: LD_EXP 87
46232: PUSH
46233: LD_VAR 0 5
46237: ARRAY
46238: IN
46239: IFFALSE 46278
// mc_turret_list := Replace ( mc_turret_list , i , mc_turret_list [ i ] diff building ) ;
46241: LD_ADDR_EXP 87
46245: PUSH
46246: LD_EXP 87
46250: PPUSH
46251: LD_VAR 0 5
46255: PPUSH
46256: LD_EXP 87
46260: PUSH
46261: LD_VAR 0 5
46265: ARRAY
46266: PUSH
46267: LD_VAR 0 1
46271: DIFF
46272: PPUSH
46273: CALL_OW 1
46277: ST_TO_ADDR
// if building in mc_empty_turret_list [ i ] then
46278: LD_VAR 0 1
46282: PUSH
46283: LD_EXP 88
46287: PUSH
46288: LD_VAR 0 5
46292: ARRAY
46293: IN
46294: IFFALSE 46333
// mc_empty_turret_list := Replace ( mc_empty_turret_list , i , mc_empty_turret_list [ i ] diff building ) ;
46296: LD_ADDR_EXP 88
46300: PUSH
46301: LD_EXP 88
46305: PPUSH
46306: LD_VAR 0 5
46310: PPUSH
46311: LD_EXP 88
46315: PUSH
46316: LD_VAR 0 5
46320: ARRAY
46321: PUSH
46322: LD_VAR 0 1
46326: DIFF
46327: PPUSH
46328: CALL_OW 1
46332: ST_TO_ADDR
// break ;
46333: GO 46337
// end ;
46335: GO 46155
46337: POP
46338: POP
// end ;
46339: LD_VAR 0 4
46343: RET
// export function MCE_VehicleCaptured ( new , old , side , capturing_unit ) ; var i , tmp ; begin
46344: LD_INT 0
46346: PPUSH
46347: PPUSH
46348: PPUSH
// if not mc_bases or not skirmish or not side in mc_sides then
46349: LD_EXP 79
46353: NOT
46354: PUSH
46355: LD_EXP 77
46359: NOT
46360: OR
46361: PUSH
46362: LD_VAR 0 3
46366: PUSH
46367: LD_EXP 105
46371: IN
46372: NOT
46373: OR
46374: IFFALSE 46378
// exit ;
46376: GO 46501
// for i = 1 to mc_vehicles do
46378: LD_ADDR_VAR 0 6
46382: PUSH
46383: DOUBLE
46384: LD_INT 1
46386: DEC
46387: ST_TO_ADDR
46388: LD_EXP 98
46392: PUSH
46393: FOR_TO
46394: IFFALSE 46499
// if old in mc_vehicles [ i ] or new in mc_vehicles [ i ] then
46396: LD_VAR 0 2
46400: PUSH
46401: LD_EXP 98
46405: PUSH
46406: LD_VAR 0 6
46410: ARRAY
46411: IN
46412: PUSH
46413: LD_VAR 0 1
46417: PUSH
46418: LD_EXP 98
46422: PUSH
46423: LD_VAR 0 6
46427: ARRAY
46428: IN
46429: OR
46430: IFFALSE 46497
// begin tmp := mc_vehicles [ i ] diff old ;
46432: LD_ADDR_VAR 0 7
46436: PUSH
46437: LD_EXP 98
46441: PUSH
46442: LD_VAR 0 6
46446: ARRAY
46447: PUSH
46448: LD_VAR 0 2
46452: DIFF
46453: ST_TO_ADDR
// tmp := tmp diff new ;
46454: LD_ADDR_VAR 0 7
46458: PUSH
46459: LD_VAR 0 7
46463: PUSH
46464: LD_VAR 0 1
46468: DIFF
46469: ST_TO_ADDR
// mc_vehicles := Replace ( mc_vehicles , i , tmp ) ;
46470: LD_ADDR_EXP 98
46474: PUSH
46475: LD_EXP 98
46479: PPUSH
46480: LD_VAR 0 6
46484: PPUSH
46485: LD_VAR 0 7
46489: PPUSH
46490: CALL_OW 1
46494: ST_TO_ADDR
// break ;
46495: GO 46499
// end ;
46497: GO 46393
46499: POP
46500: POP
// end ;
46501: LD_VAR 0 5
46505: RET
// export function MCE_VehicleConstructed ( vehicle , factory ) ; var i , side , tmp ; begin
46506: LD_INT 0
46508: PPUSH
46509: PPUSH
46510: PPUSH
46511: PPUSH
// if not mc_bases or not skirmish then
46512: LD_EXP 79
46516: NOT
46517: PUSH
46518: LD_EXP 77
46522: NOT
46523: OR
46524: IFFALSE 46528
// exit ;
46526: GO 46905
// side := GetSide ( vehicle ) ;
46528: LD_ADDR_VAR 0 5
46532: PUSH
46533: LD_VAR 0 1
46537: PPUSH
46538: CALL_OW 255
46542: ST_TO_ADDR
// for i = 1 to mc_bases do
46543: LD_ADDR_VAR 0 4
46547: PUSH
46548: DOUBLE
46549: LD_INT 1
46551: DEC
46552: ST_TO_ADDR
46553: LD_EXP 79
46557: PUSH
46558: FOR_TO
46559: IFFALSE 46903
// begin if factory in mc_bases [ i ] then
46561: LD_VAR 0 2
46565: PUSH
46566: LD_EXP 79
46570: PUSH
46571: LD_VAR 0 4
46575: ARRAY
46576: IN
46577: IFFALSE 46901
// begin if mc_defender [ i ] < mc_defender_limit [ i ] and not GetWeapon ( vehicle ) in [ ar_control_tower , ar_cargo_bay , ru_cargo_bay , ru_big_cargo_bay , us_cargo_bay , ar_radar , ru_radar , us_radar , ru_bulldozer , us_bulldozer , ar_bio_bomb , ar_selfpropelled_bomb , us_hack , us_crane , ru_crane , ru_siberium_rocket , us_siberium_rocket ] then
46579: LD_EXP 101
46583: PUSH
46584: LD_VAR 0 4
46588: ARRAY
46589: PUSH
46590: LD_EXP 90
46594: PUSH
46595: LD_VAR 0 4
46599: ARRAY
46600: LESS
46601: PUSH
46602: LD_VAR 0 1
46606: PPUSH
46607: CALL_OW 264
46611: PUSH
46612: LD_INT 31
46614: PUSH
46615: LD_INT 32
46617: PUSH
46618: LD_INT 51
46620: PUSH
46621: LD_EXP 73
46625: PUSH
46626: LD_INT 12
46628: PUSH
46629: LD_INT 30
46631: PUSH
46632: LD_EXP 72
46636: PUSH
46637: LD_INT 11
46639: PUSH
46640: LD_INT 53
46642: PUSH
46643: LD_INT 14
46645: PUSH
46646: LD_EXP 76
46650: PUSH
46651: LD_INT 29
46653: PUSH
46654: LD_EXP 74
46658: PUSH
46659: LD_INT 13
46661: PUSH
46662: LD_INT 52
46664: PUSH
46665: LD_INT 48
46667: PUSH
46668: LD_INT 8
46670: PUSH
46671: EMPTY
46672: LIST
46673: LIST
46674: LIST
46675: LIST
46676: LIST
46677: LIST
46678: LIST
46679: LIST
46680: LIST
46681: LIST
46682: LIST
46683: LIST
46684: LIST
46685: LIST
46686: LIST
46687: LIST
46688: LIST
46689: IN
46690: NOT
46691: AND
46692: IFFALSE 46740
// mc_defender := ReplaceIn ( mc_defender , [ i , mc_defender [ i ] + 1 ] , vehicle ) else
46694: LD_ADDR_EXP 101
46698: PUSH
46699: LD_EXP 101
46703: PPUSH
46704: LD_VAR 0 4
46708: PUSH
46709: LD_EXP 101
46713: PUSH
46714: LD_VAR 0 4
46718: ARRAY
46719: PUSH
46720: LD_INT 1
46722: PLUS
46723: PUSH
46724: EMPTY
46725: LIST
46726: LIST
46727: PPUSH
46728: LD_VAR 0 1
46732: PPUSH
46733: CALL 57783 0 3
46737: ST_TO_ADDR
46738: GO 46784
// mc_vehicles := ReplaceIn ( mc_vehicles , [ i , mc_vehicles [ i ] + 1 ] , vehicle ) ;
46740: LD_ADDR_EXP 98
46744: PUSH
46745: LD_EXP 98
46749: PPUSH
46750: LD_VAR 0 4
46754: PUSH
46755: LD_EXP 98
46759: PUSH
46760: LD_VAR 0 4
46764: ARRAY
46765: PUSH
46766: LD_INT 1
46768: PLUS
46769: PUSH
46770: EMPTY
46771: LIST
46772: LIST
46773: PPUSH
46774: LD_VAR 0 1
46778: PPUSH
46779: CALL 57783 0 3
46783: ST_TO_ADDR
// if GetControl ( vehicle ) = control_remote then
46784: LD_VAR 0 1
46788: PPUSH
46789: CALL_OW 263
46793: PUSH
46794: LD_INT 2
46796: EQUAL
46797: IFFALSE 46817
// begin repeat wait ( 0 0$1 ) ;
46799: LD_INT 35
46801: PPUSH
46802: CALL_OW 67
// until IsControledBy ( vehicle ) ;
46806: LD_VAR 0 1
46810: PPUSH
46811: CALL_OW 312
46815: IFFALSE 46799
// end ; ComMoveToArea ( vehicle , mc_parking [ i ] ) ;
46817: LD_VAR 0 1
46821: PPUSH
46822: LD_EXP 103
46826: PUSH
46827: LD_VAR 0 4
46831: ARRAY
46832: PPUSH
46833: CALL_OW 113
// if GetControl ( vehicle ) <> control_manual then
46837: LD_VAR 0 1
46841: PPUSH
46842: CALL_OW 263
46846: PUSH
46847: LD_INT 1
46849: NONEQUAL
46850: IFFALSE 46854
// break ;
46852: GO 46903
// repeat wait ( 0 0$1 ) ;
46854: LD_INT 35
46856: PPUSH
46857: CALL_OW 67
// until IsInArea ( vehicle , mc_parking [ i ] ) ;
46861: LD_VAR 0 1
46865: PPUSH
46866: LD_EXP 103
46870: PUSH
46871: LD_VAR 0 4
46875: ARRAY
46876: PPUSH
46877: CALL_OW 308
46881: IFFALSE 46854
// ComExitVehicle ( IsDrivenBy ( vehicle ) ) ;
46883: LD_VAR 0 1
46887: PPUSH
46888: CALL_OW 311
46892: PPUSH
46893: CALL_OW 121
// exit ;
46897: POP
46898: POP
46899: GO 46905
// end ; end ;
46901: GO 46558
46903: POP
46904: POP
// end ;
46905: LD_VAR 0 3
46909: RET
// export function MCE_CrateSpawn ( id , x , y , amount , mode ) ; var i , j , depot ; begin
46910: LD_INT 0
46912: PPUSH
46913: PPUSH
46914: PPUSH
46915: PPUSH
// if not mc_bases or not skirmish then
46916: LD_EXP 79
46920: NOT
46921: PUSH
46922: LD_EXP 77
46926: NOT
46927: OR
46928: IFFALSE 46932
// exit ;
46930: GO 47285
// repeat wait ( 0 0$1 ) ;
46932: LD_INT 35
46934: PPUSH
46935: CALL_OW 67
// until GetResourceAmountXY ( x , y ) ;
46939: LD_VAR 0 2
46943: PPUSH
46944: LD_VAR 0 3
46948: PPUSH
46949: CALL_OW 284
46953: IFFALSE 46932
// if GetResourceTypeXY ( x , y ) = mat_artefact then
46955: LD_VAR 0 2
46959: PPUSH
46960: LD_VAR 0 3
46964: PPUSH
46965: CALL_OW 283
46969: PUSH
46970: LD_INT 4
46972: EQUAL
46973: IFFALSE 46977
// exit ;
46975: GO 47285
// for i = 1 to mc_bases do
46977: LD_ADDR_VAR 0 7
46981: PUSH
46982: DOUBLE
46983: LD_INT 1
46985: DEC
46986: ST_TO_ADDR
46987: LD_EXP 79
46991: PUSH
46992: FOR_TO
46993: IFFALSE 47283
// begin if mc_crates_area [ i ] then
46995: LD_EXP 97
46999: PUSH
47000: LD_VAR 0 7
47004: ARRAY
47005: IFFALSE 47116
// for j in mc_crates_area [ i ] do
47007: LD_ADDR_VAR 0 8
47011: PUSH
47012: LD_EXP 97
47016: PUSH
47017: LD_VAR 0 7
47021: ARRAY
47022: PUSH
47023: FOR_IN
47024: IFFALSE 47114
// if InArea ( x , y , j ) then
47026: LD_VAR 0 2
47030: PPUSH
47031: LD_VAR 0 3
47035: PPUSH
47036: LD_VAR 0 8
47040: PPUSH
47041: CALL_OW 309
47045: IFFALSE 47112
// begin mc_crates := ReplaceIn ( mc_crates , [ i , mc_crates [ i ] + 1 ] , [ amount , x , y ] ) ;
47047: LD_ADDR_EXP 95
47051: PUSH
47052: LD_EXP 95
47056: PPUSH
47057: LD_VAR 0 7
47061: PUSH
47062: LD_EXP 95
47066: PUSH
47067: LD_VAR 0 7
47071: ARRAY
47072: PUSH
47073: LD_INT 1
47075: PLUS
47076: PUSH
47077: EMPTY
47078: LIST
47079: LIST
47080: PPUSH
47081: LD_VAR 0 4
47085: PUSH
47086: LD_VAR 0 2
47090: PUSH
47091: LD_VAR 0 3
47095: PUSH
47096: EMPTY
47097: LIST
47098: LIST
47099: LIST
47100: PPUSH
47101: CALL 57783 0 3
47105: ST_TO_ADDR
// exit ;
47106: POP
47107: POP
47108: POP
47109: POP
47110: GO 47285
// end ;
47112: GO 47023
47114: POP
47115: POP
// depot := UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) ;
47116: LD_ADDR_VAR 0 9
47120: PUSH
47121: LD_EXP 79
47125: PUSH
47126: LD_VAR 0 7
47130: ARRAY
47131: PPUSH
47132: LD_INT 2
47134: PUSH
47135: LD_INT 30
47137: PUSH
47138: LD_INT 0
47140: PUSH
47141: EMPTY
47142: LIST
47143: LIST
47144: PUSH
47145: LD_INT 30
47147: PUSH
47148: LD_INT 1
47150: PUSH
47151: EMPTY
47152: LIST
47153: LIST
47154: PUSH
47155: EMPTY
47156: LIST
47157: LIST
47158: LIST
47159: PPUSH
47160: CALL_OW 72
47164: ST_TO_ADDR
// if not depot then
47165: LD_VAR 0 9
47169: NOT
47170: IFFALSE 47174
// continue ;
47172: GO 46992
// for j in depot do
47174: LD_ADDR_VAR 0 8
47178: PUSH
47179: LD_VAR 0 9
47183: PUSH
47184: FOR_IN
47185: IFFALSE 47279
// if GetDistUnitXY ( j , x , y ) < 30 then
47187: LD_VAR 0 8
47191: PPUSH
47192: LD_VAR 0 2
47196: PPUSH
47197: LD_VAR 0 3
47201: PPUSH
47202: CALL_OW 297
47206: PUSH
47207: LD_INT 30
47209: LESS
47210: IFFALSE 47277
// begin mc_crates := ReplaceIn ( mc_crates , [ i , mc_crates [ i ] + 1 ] , [ amount , x , y ] ) ;
47212: LD_ADDR_EXP 95
47216: PUSH
47217: LD_EXP 95
47221: PPUSH
47222: LD_VAR 0 7
47226: PUSH
47227: LD_EXP 95
47231: PUSH
47232: LD_VAR 0 7
47236: ARRAY
47237: PUSH
47238: LD_INT 1
47240: PLUS
47241: PUSH
47242: EMPTY
47243: LIST
47244: LIST
47245: PPUSH
47246: LD_VAR 0 4
47250: PUSH
47251: LD_VAR 0 2
47255: PUSH
47256: LD_VAR 0 3
47260: PUSH
47261: EMPTY
47262: LIST
47263: LIST
47264: LIST
47265: PPUSH
47266: CALL 57783 0 3
47270: ST_TO_ADDR
// exit ;
47271: POP
47272: POP
47273: POP
47274: POP
47275: GO 47285
// end ;
47277: GO 47184
47279: POP
47280: POP
// end ;
47281: GO 46992
47283: POP
47284: POP
// end ;
47285: LD_VAR 0 6
47289: RET
// export function MCE_ResearchComplete ( tech , lab ) ; var side , i , tmp ; begin
47290: LD_INT 0
47292: PPUSH
47293: PPUSH
47294: PPUSH
47295: PPUSH
// if not mc_bases or not skirmish then
47296: LD_EXP 79
47300: NOT
47301: PUSH
47302: LD_EXP 77
47306: NOT
47307: OR
47308: IFFALSE 47312
// exit ;
47310: GO 47589
// side := GetSide ( lab ) ;
47312: LD_ADDR_VAR 0 4
47316: PUSH
47317: LD_VAR 0 2
47321: PPUSH
47322: CALL_OW 255
47326: ST_TO_ADDR
// if not side in mc_sides or not mc_tech or not mc_bases then
47327: LD_VAR 0 4
47331: PUSH
47332: LD_EXP 105
47336: IN
47337: NOT
47338: PUSH
47339: LD_EXP 106
47343: NOT
47344: OR
47345: PUSH
47346: LD_EXP 79
47350: NOT
47351: OR
47352: IFFALSE 47356
// exit ;
47354: GO 47589
// mc_tech := Replace ( mc_tech , side , mc_tech [ side ] diff tech ) ;
47356: LD_ADDR_EXP 106
47360: PUSH
47361: LD_EXP 106
47365: PPUSH
47366: LD_VAR 0 4
47370: PPUSH
47371: LD_EXP 106
47375: PUSH
47376: LD_VAR 0 4
47380: ARRAY
47381: PUSH
47382: LD_VAR 0 1
47386: DIFF
47387: PPUSH
47388: CALL_OW 1
47392: ST_TO_ADDR
// for i = 1 to mc_bases do
47393: LD_ADDR_VAR 0 5
47397: PUSH
47398: DOUBLE
47399: LD_INT 1
47401: DEC
47402: ST_TO_ADDR
47403: LD_EXP 79
47407: PUSH
47408: FOR_TO
47409: IFFALSE 47587
// begin if lab in mc_bases [ i ] then
47411: LD_VAR 0 2
47415: PUSH
47416: LD_EXP 79
47420: PUSH
47421: LD_VAR 0 5
47425: ARRAY
47426: IN
47427: IFFALSE 47585
// begin if tech in [ tech_apeagres , tech_apebrain , tech_apeneural , tech_apepsych ] and mc_ape_in_lab [ i ] then
47429: LD_VAR 0 1
47433: PUSH
47434: LD_INT 11
47436: PUSH
47437: LD_INT 4
47439: PUSH
47440: LD_INT 3
47442: PUSH
47443: LD_INT 2
47445: PUSH
47446: EMPTY
47447: LIST
47448: LIST
47449: LIST
47450: LIST
47451: IN
47452: PUSH
47453: LD_EXP 109
47457: PUSH
47458: LD_VAR 0 5
47462: ARRAY
47463: AND
47464: IFFALSE 47585
// begin tmp := mc_ape_in_lab [ i ] [ 1 ] ;
47466: LD_ADDR_VAR 0 6
47470: PUSH
47471: LD_EXP 109
47475: PUSH
47476: LD_VAR 0 5
47480: ARRAY
47481: PUSH
47482: LD_INT 1
47484: ARRAY
47485: ST_TO_ADDR
// mc_ape_in_lab := Replace ( mc_ape_in_lab , i , [ ] ) ;
47486: LD_ADDR_EXP 109
47490: PUSH
47491: LD_EXP 109
47495: PPUSH
47496: LD_VAR 0 5
47500: PPUSH
47501: EMPTY
47502: PPUSH
47503: CALL_OW 1
47507: ST_TO_ADDR
// SetTag ( tmp , 0 ) ;
47508: LD_VAR 0 6
47512: PPUSH
47513: LD_INT 0
47515: PPUSH
47516: CALL_OW 109
// ComExitBuilding ( tmp ) ;
47520: LD_VAR 0 6
47524: PPUSH
47525: CALL_OW 122
// mc_ape := Replace ( mc_ape , i , Insert ( mc_ape [ i ] , 1 , tmp ) ) ;
47529: LD_ADDR_EXP 108
47533: PUSH
47534: LD_EXP 108
47538: PPUSH
47539: LD_VAR 0 5
47543: PPUSH
47544: LD_EXP 108
47548: PUSH
47549: LD_VAR 0 5
47553: ARRAY
47554: PPUSH
47555: LD_INT 1
47557: PPUSH
47558: LD_VAR 0 6
47562: PPUSH
47563: CALL_OW 2
47567: PPUSH
47568: CALL_OW 1
47572: ST_TO_ADDR
// MC_Reset ( i , 112 ) ;
47573: LD_VAR 0 5
47577: PPUSH
47578: LD_INT 112
47580: PPUSH
47581: CALL 24585 0 2
// end ; end ; end ;
47585: GO 47408
47587: POP
47588: POP
// end ;
47589: LD_VAR 0 3
47593: RET
// export function MCE_UnitDestroyed ( un ) ; var i , j , btype , pos , tmp , fac , components ; begin
47594: LD_INT 0
47596: PPUSH
47597: PPUSH
47598: PPUSH
47599: PPUSH
47600: PPUSH
47601: PPUSH
47602: PPUSH
47603: PPUSH
// if not mc_bases or not skirmish then
47604: LD_EXP 79
47608: NOT
47609: PUSH
47610: LD_EXP 77
47614: NOT
47615: OR
47616: IFFALSE 47620
// exit ;
47618: GO 48991
// for i = 1 to mc_bases do
47620: LD_ADDR_VAR 0 3
47624: PUSH
47625: DOUBLE
47626: LD_INT 1
47628: DEC
47629: ST_TO_ADDR
47630: LD_EXP 79
47634: PUSH
47635: FOR_TO
47636: IFFALSE 48989
// if un in mc_bases [ i ] or un in mc_construct_list [ i ] or un in mc_defender [ i ] or un in mc_vehicles [ i ] or un in mc_ape [ i ] or un in mc_ape_in_lab [ i ] then
47638: LD_VAR 0 1
47642: PUSH
47643: LD_EXP 79
47647: PUSH
47648: LD_VAR 0 3
47652: ARRAY
47653: IN
47654: PUSH
47655: LD_VAR 0 1
47659: PUSH
47660: LD_EXP 86
47664: PUSH
47665: LD_VAR 0 3
47669: ARRAY
47670: IN
47671: OR
47672: PUSH
47673: LD_VAR 0 1
47677: PUSH
47678: LD_EXP 101
47682: PUSH
47683: LD_VAR 0 3
47687: ARRAY
47688: IN
47689: OR
47690: PUSH
47691: LD_VAR 0 1
47695: PUSH
47696: LD_EXP 98
47700: PUSH
47701: LD_VAR 0 3
47705: ARRAY
47706: IN
47707: OR
47708: PUSH
47709: LD_VAR 0 1
47713: PUSH
47714: LD_EXP 108
47718: PUSH
47719: LD_VAR 0 3
47723: ARRAY
47724: IN
47725: OR
47726: PUSH
47727: LD_VAR 0 1
47731: PUSH
47732: LD_EXP 109
47736: PUSH
47737: LD_VAR 0 3
47741: ARRAY
47742: IN
47743: OR
47744: IFFALSE 48987
// begin if un in mc_ape [ i ] then
47746: LD_VAR 0 1
47750: PUSH
47751: LD_EXP 108
47755: PUSH
47756: LD_VAR 0 3
47760: ARRAY
47761: IN
47762: IFFALSE 47801
// begin mc_ape := Replace ( mc_ape , i , mc_ape [ i ] diff un ) ;
47764: LD_ADDR_EXP 108
47768: PUSH
47769: LD_EXP 108
47773: PPUSH
47774: LD_VAR 0 3
47778: PPUSH
47779: LD_EXP 108
47783: PUSH
47784: LD_VAR 0 3
47788: ARRAY
47789: PUSH
47790: LD_VAR 0 1
47794: DIFF
47795: PPUSH
47796: CALL_OW 1
47800: ST_TO_ADDR
// end ; if un in mc_ape_in_lab [ i ] then
47801: LD_VAR 0 1
47805: PUSH
47806: LD_EXP 109
47810: PUSH
47811: LD_VAR 0 3
47815: ARRAY
47816: IN
47817: IFFALSE 47841
// begin mc_ape_in_lab := Replace ( mc_ape_in_lab , i , [ ] ) ;
47819: LD_ADDR_EXP 109
47823: PUSH
47824: LD_EXP 109
47828: PPUSH
47829: LD_VAR 0 3
47833: PPUSH
47834: EMPTY
47835: PPUSH
47836: CALL_OW 1
47840: ST_TO_ADDR
// end ; if GetType ( un ) = unit_vehicle and ( GetTag ( un ) = 20 or un in mc_defender [ i ] or GetWeapon ( un ) in [ us_cargo_bay , ru_cargo_bay , ru_big_cargo_bay , ar_cargo_bay , us_crane , ru_crane , ar_control_tower ] ) then
47841: LD_VAR 0 1
47845: PPUSH
47846: CALL_OW 247
47850: PUSH
47851: LD_INT 2
47853: EQUAL
47854: PUSH
47855: LD_VAR 0 1
47859: PPUSH
47860: CALL_OW 110
47864: PUSH
47865: LD_INT 20
47867: EQUAL
47868: PUSH
47869: LD_VAR 0 1
47873: PUSH
47874: LD_EXP 101
47878: PUSH
47879: LD_VAR 0 3
47883: ARRAY
47884: IN
47885: OR
47886: PUSH
47887: LD_VAR 0 1
47891: PPUSH
47892: CALL_OW 264
47896: PUSH
47897: LD_INT 12
47899: PUSH
47900: LD_INT 51
47902: PUSH
47903: LD_EXP 73
47907: PUSH
47908: LD_INT 32
47910: PUSH
47911: LD_INT 13
47913: PUSH
47914: LD_INT 52
47916: PUSH
47917: LD_INT 31
47919: PUSH
47920: EMPTY
47921: LIST
47922: LIST
47923: LIST
47924: LIST
47925: LIST
47926: LIST
47927: LIST
47928: IN
47929: OR
47930: AND
47931: IFFALSE 48239
// begin if un in mc_defender [ i ] then
47933: LD_VAR 0 1
47937: PUSH
47938: LD_EXP 101
47942: PUSH
47943: LD_VAR 0 3
47947: ARRAY
47948: IN
47949: IFFALSE 47988
// mc_defender := Replace ( mc_defender , i , mc_defender [ i ] diff un ) ;
47951: LD_ADDR_EXP 101
47955: PUSH
47956: LD_EXP 101
47960: PPUSH
47961: LD_VAR 0 3
47965: PPUSH
47966: LD_EXP 101
47970: PUSH
47971: LD_VAR 0 3
47975: ARRAY
47976: PUSH
47977: LD_VAR 0 1
47981: DIFF
47982: PPUSH
47983: CALL_OW 1
47987: ST_TO_ADDR
// fac := MC_GetBuildings ( i , b_factory ) ;
47988: LD_ADDR_VAR 0 8
47992: PUSH
47993: LD_VAR 0 3
47997: PPUSH
47998: LD_INT 3
48000: PPUSH
48001: CALL 44657 0 2
48005: ST_TO_ADDR
// if fac then
48006: LD_VAR 0 8
48010: IFFALSE 48239
// begin for j in fac do
48012: LD_ADDR_VAR 0 4
48016: PUSH
48017: LD_VAR 0 8
48021: PUSH
48022: FOR_IN
48023: IFFALSE 48237
// begin components := Produce ( fac , GetChassis ( un ) , GetEngine ( un ) , GetControl ( un ) , GetWeapon ( un ) ) ;
48025: LD_ADDR_VAR 0 9
48029: PUSH
48030: LD_VAR 0 8
48034: PPUSH
48035: LD_VAR 0 1
48039: PPUSH
48040: CALL_OW 265
48044: PPUSH
48045: LD_VAR 0 1
48049: PPUSH
48050: CALL_OW 262
48054: PPUSH
48055: LD_VAR 0 1
48059: PPUSH
48060: CALL_OW 263
48064: PPUSH
48065: LD_VAR 0 1
48069: PPUSH
48070: CALL_OW 264
48074: PPUSH
48075: CALL 55315 0 5
48079: ST_TO_ADDR
// if components then
48080: LD_VAR 0 9
48084: IFFALSE 48235
// begin if GetWeapon ( un ) = ar_control_tower then
48086: LD_VAR 0 1
48090: PPUSH
48091: CALL_OW 264
48095: PUSH
48096: LD_INT 31
48098: EQUAL
48099: IFFALSE 48216
// begin SetTag ( IsDrivenBy ( un ) , 0 ) ;
48101: LD_VAR 0 1
48105: PPUSH
48106: CALL_OW 311
48110: PPUSH
48111: LD_INT 0
48113: PPUSH
48114: CALL_OW 109
// mc_remote_driver := Replace ( mc_remote_driver , i , mc_remote_driver [ i ] diff IsDrivenBy ( un ) ) ;
48118: LD_ADDR_EXP 119
48122: PUSH
48123: LD_EXP 119
48127: PPUSH
48128: LD_VAR 0 3
48132: PPUSH
48133: LD_EXP 119
48137: PUSH
48138: LD_VAR 0 3
48142: ARRAY
48143: PUSH
48144: LD_VAR 0 1
48148: PPUSH
48149: CALL_OW 311
48153: DIFF
48154: PPUSH
48155: CALL_OW 1
48159: ST_TO_ADDR
// tmp := Insert ( mc_produce [ i ] , 1 , components ) ;
48160: LD_ADDR_VAR 0 7
48164: PUSH
48165: LD_EXP 100
48169: PUSH
48170: LD_VAR 0 3
48174: ARRAY
48175: PPUSH
48176: LD_INT 1
48178: PPUSH
48179: LD_VAR 0 9
48183: PPUSH
48184: CALL_OW 2
48188: ST_TO_ADDR
// mc_produce := Replace ( mc_produce , i , tmp ) ;
48189: LD_ADDR_EXP 100
48193: PUSH
48194: LD_EXP 100
48198: PPUSH
48199: LD_VAR 0 3
48203: PPUSH
48204: LD_VAR 0 7
48208: PPUSH
48209: CALL_OW 1
48213: ST_TO_ADDR
// end else
48214: GO 48233
// MC_InsertProduceList ( i , [ components ] ) ;
48216: LD_VAR 0 3
48220: PPUSH
48221: LD_VAR 0 9
48225: PUSH
48226: EMPTY
48227: LIST
48228: PPUSH
48229: CALL 44202 0 2
// break ;
48233: GO 48237
// end ; end ;
48235: GO 48022
48237: POP
48238: POP
// end ; end ; if GetType ( un ) = unit_building then
48239: LD_VAR 0 1
48243: PPUSH
48244: CALL_OW 247
48248: PUSH
48249: LD_INT 3
48251: EQUAL
48252: IFFALSE 48655
// begin btype := GetBType ( un ) ;
48254: LD_ADDR_VAR 0 5
48258: PUSH
48259: LD_VAR 0 1
48263: PPUSH
48264: CALL_OW 266
48268: ST_TO_ADDR
// if btype in [ b_oil_mine , b_siberite_mine ] then
48269: LD_VAR 0 5
48273: PUSH
48274: LD_INT 29
48276: PUSH
48277: LD_INT 30
48279: PUSH
48280: EMPTY
48281: LIST
48282: LIST
48283: IN
48284: IFFALSE 48357
// begin if not GetResourceVisibility ( GetX ( un ) , GetY ( un ) , GetSide ( un ) ) then
48286: LD_VAR 0 1
48290: PPUSH
48291: CALL_OW 250
48295: PPUSH
48296: LD_VAR 0 1
48300: PPUSH
48301: CALL_OW 251
48305: PPUSH
48306: LD_VAR 0 1
48310: PPUSH
48311: CALL_OW 255
48315: PPUSH
48316: CALL_OW 440
48320: NOT
48321: IFFALSE 48357
// SetResourceVisibility ( GetX ( un ) , GetY ( un ) , GetSide ( un ) ) ;
48323: LD_VAR 0 1
48327: PPUSH
48328: CALL_OW 250
48332: PPUSH
48333: LD_VAR 0 1
48337: PPUSH
48338: CALL_OW 251
48342: PPUSH
48343: LD_VAR 0 1
48347: PPUSH
48348: CALL_OW 255
48352: PPUSH
48353: CALL_OW 441
// end ; if btype = b_warehouse then
48357: LD_VAR 0 5
48361: PUSH
48362: LD_INT 1
48364: EQUAL
48365: IFFALSE 48383
// begin btype := b_depot ;
48367: LD_ADDR_VAR 0 5
48371: PUSH
48372: LD_INT 0
48374: ST_TO_ADDR
// pos := 1 ;
48375: LD_ADDR_VAR 0 6
48379: PUSH
48380: LD_INT 1
48382: ST_TO_ADDR
// end ; if btype = b_factory then
48383: LD_VAR 0 5
48387: PUSH
48388: LD_INT 3
48390: EQUAL
48391: IFFALSE 48409
// begin btype := b_workshop ;
48393: LD_ADDR_VAR 0 5
48397: PUSH
48398: LD_INT 2
48400: ST_TO_ADDR
// pos := 1 ;
48401: LD_ADDR_VAR 0 6
48405: PUSH
48406: LD_INT 1
48408: ST_TO_ADDR
// end ; if btype = b_barracks then
48409: LD_VAR 0 5
48413: PUSH
48414: LD_INT 5
48416: EQUAL
48417: IFFALSE 48427
// btype := b_armoury ;
48419: LD_ADDR_VAR 0 5
48423: PUSH
48424: LD_INT 4
48426: ST_TO_ADDR
// if btype in [ b_lab_half , b_lab_full ] then
48427: LD_VAR 0 5
48431: PUSH
48432: LD_INT 7
48434: PUSH
48435: LD_INT 8
48437: PUSH
48438: EMPTY
48439: LIST
48440: LIST
48441: IN
48442: IFFALSE 48452
// btype := b_lab ;
48444: LD_ADDR_VAR 0 5
48448: PUSH
48449: LD_INT 6
48451: ST_TO_ADDR
// mc_build_list := ReplaceIn ( mc_build_list , [ i , mc_build_list [ i ] + 1 ] , [ btype , GetX ( un ) , GetY ( un ) , GetDir ( un ) ] ) ;
48452: LD_ADDR_EXP 84
48456: PUSH
48457: LD_EXP 84
48461: PPUSH
48462: LD_VAR 0 3
48466: PUSH
48467: LD_EXP 84
48471: PUSH
48472: LD_VAR 0 3
48476: ARRAY
48477: PUSH
48478: LD_INT 1
48480: PLUS
48481: PUSH
48482: EMPTY
48483: LIST
48484: LIST
48485: PPUSH
48486: LD_VAR 0 5
48490: PUSH
48491: LD_VAR 0 1
48495: PPUSH
48496: CALL_OW 250
48500: PUSH
48501: LD_VAR 0 1
48505: PPUSH
48506: CALL_OW 251
48510: PUSH
48511: LD_VAR 0 1
48515: PPUSH
48516: CALL_OW 254
48520: PUSH
48521: EMPTY
48522: LIST
48523: LIST
48524: LIST
48525: LIST
48526: PPUSH
48527: CALL 57783 0 3
48531: ST_TO_ADDR
// if pos = 1 then
48532: LD_VAR 0 6
48536: PUSH
48537: LD_INT 1
48539: EQUAL
48540: IFFALSE 48655
// begin tmp := mc_build_list [ i ] ;
48542: LD_ADDR_VAR 0 7
48546: PUSH
48547: LD_EXP 84
48551: PUSH
48552: LD_VAR 0 3
48556: ARRAY
48557: ST_TO_ADDR
// if UnitFilter ( tmp , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) then
48558: LD_VAR 0 7
48562: PPUSH
48563: LD_INT 2
48565: PUSH
48566: LD_INT 30
48568: PUSH
48569: LD_INT 0
48571: PUSH
48572: EMPTY
48573: LIST
48574: LIST
48575: PUSH
48576: LD_INT 30
48578: PUSH
48579: LD_INT 1
48581: PUSH
48582: EMPTY
48583: LIST
48584: LIST
48585: PUSH
48586: EMPTY
48587: LIST
48588: LIST
48589: LIST
48590: PPUSH
48591: CALL_OW 72
48595: IFFALSE 48605
// pos := 2 ;
48597: LD_ADDR_VAR 0 6
48601: PUSH
48602: LD_INT 2
48604: ST_TO_ADDR
// tmp := ReplaceWith ( tmp , pos , tmp ) ;
48605: LD_ADDR_VAR 0 7
48609: PUSH
48610: LD_VAR 0 7
48614: PPUSH
48615: LD_VAR 0 6
48619: PPUSH
48620: LD_VAR 0 7
48624: PPUSH
48625: CALL 58109 0 3
48629: ST_TO_ADDR
// mc_build_list := Replace ( mc_build_list , i , tmp ) ;
48630: LD_ADDR_EXP 84
48634: PUSH
48635: LD_EXP 84
48639: PPUSH
48640: LD_VAR 0 3
48644: PPUSH
48645: LD_VAR 0 7
48649: PPUSH
48650: CALL_OW 1
48654: ST_TO_ADDR
// end ; end ; if un in mc_bases [ i ] then
48655: LD_VAR 0 1
48659: PUSH
48660: LD_EXP 79
48664: PUSH
48665: LD_VAR 0 3
48669: ARRAY
48670: IN
48671: IFFALSE 48710
// begin mc_bases := Replace ( mc_bases , i , mc_bases [ i ] diff un ) ;
48673: LD_ADDR_EXP 79
48677: PUSH
48678: LD_EXP 79
48682: PPUSH
48683: LD_VAR 0 3
48687: PPUSH
48688: LD_EXP 79
48692: PUSH
48693: LD_VAR 0 3
48697: ARRAY
48698: PUSH
48699: LD_VAR 0 1
48703: DIFF
48704: PPUSH
48705: CALL_OW 1
48709: ST_TO_ADDR
// end ; if un in mc_construct_list [ i ] then
48710: LD_VAR 0 1
48714: PUSH
48715: LD_EXP 86
48719: PUSH
48720: LD_VAR 0 3
48724: ARRAY
48725: IN
48726: IFFALSE 48765
// begin mc_construct_list := Replace ( mc_construct_list , i , mc_construct_list [ i ] diff un ) ;
48728: LD_ADDR_EXP 86
48732: PUSH
48733: LD_EXP 86
48737: PPUSH
48738: LD_VAR 0 3
48742: PPUSH
48743: LD_EXP 86
48747: PUSH
48748: LD_VAR 0 3
48752: ARRAY
48753: PUSH
48754: LD_VAR 0 1
48758: DIFF
48759: PPUSH
48760: CALL_OW 1
48764: ST_TO_ADDR
// end ; if un in mc_vehicles [ i ] then
48765: LD_VAR 0 1
48769: PUSH
48770: LD_EXP 98
48774: PUSH
48775: LD_VAR 0 3
48779: ARRAY
48780: IN
48781: IFFALSE 48820
// begin mc_vehicles := Replace ( mc_vehicles , i , mc_vehicles [ i ] diff un ) ;
48783: LD_ADDR_EXP 98
48787: PUSH
48788: LD_EXP 98
48792: PPUSH
48793: LD_VAR 0 3
48797: PPUSH
48798: LD_EXP 98
48802: PUSH
48803: LD_VAR 0 3
48807: ARRAY
48808: PUSH
48809: LD_VAR 0 1
48813: DIFF
48814: PPUSH
48815: CALL_OW 1
48819: ST_TO_ADDR
// end ; if un in mc_defender [ i ] then
48820: LD_VAR 0 1
48824: PUSH
48825: LD_EXP 101
48829: PUSH
48830: LD_VAR 0 3
48834: ARRAY
48835: IN
48836: IFFALSE 48875
// begin mc_defender := Replace ( mc_defender , i , mc_defender [ i ] diff un ) ;
48838: LD_ADDR_EXP 101
48842: PUSH
48843: LD_EXP 101
48847: PPUSH
48848: LD_VAR 0 3
48852: PPUSH
48853: LD_EXP 101
48857: PUSH
48858: LD_VAR 0 3
48862: ARRAY
48863: PUSH
48864: LD_VAR 0 1
48868: DIFF
48869: PPUSH
48870: CALL_OW 1
48874: ST_TO_ADDR
// end ; if un in mc_empty_turret_list [ i ] then
48875: LD_VAR 0 1
48879: PUSH
48880: LD_EXP 88
48884: PUSH
48885: LD_VAR 0 3
48889: ARRAY
48890: IN
48891: IFFALSE 48930
// begin mc_empty_turret_list := Replace ( mc_empty_turret_list , i , mc_empty_turret_list [ i ] diff un ) ;
48893: LD_ADDR_EXP 88
48897: PUSH
48898: LD_EXP 88
48902: PPUSH
48903: LD_VAR 0 3
48907: PPUSH
48908: LD_EXP 88
48912: PUSH
48913: LD_VAR 0 3
48917: ARRAY
48918: PUSH
48919: LD_VAR 0 1
48923: DIFF
48924: PPUSH
48925: CALL_OW 1
48929: ST_TO_ADDR
// end ; if un in mc_turret_list [ i ] then
48930: LD_VAR 0 1
48934: PUSH
48935: LD_EXP 87
48939: PUSH
48940: LD_VAR 0 3
48944: ARRAY
48945: IN
48946: IFFALSE 48985
// begin mc_turret_list := Replace ( mc_turret_list , i , mc_turret_list [ i ] diff un ) ;
48948: LD_ADDR_EXP 87
48952: PUSH
48953: LD_EXP 87
48957: PPUSH
48958: LD_VAR 0 3
48962: PPUSH
48963: LD_EXP 87
48967: PUSH
48968: LD_VAR 0 3
48972: ARRAY
48973: PUSH
48974: LD_VAR 0 1
48978: DIFF
48979: PPUSH
48980: CALL_OW 1
48984: ST_TO_ADDR
// end ; break ;
48985: GO 48989
// end ;
48987: GO 47635
48989: POP
48990: POP
// end ;
48991: LD_VAR 0 2
48995: RET
// export function MCE_UpgradeComplete ( building ) ; var i , j ; begin
48996: LD_INT 0
48998: PPUSH
48999: PPUSH
49000: PPUSH
// if not mc_bases or not skirmish then
49001: LD_EXP 79
49005: NOT
49006: PUSH
49007: LD_EXP 77
49011: NOT
49012: OR
49013: IFFALSE 49017
// exit ;
49015: GO 49232
// for i = 1 to mc_bases do
49017: LD_ADDR_VAR 0 3
49021: PUSH
49022: DOUBLE
49023: LD_INT 1
49025: DEC
49026: ST_TO_ADDR
49027: LD_EXP 79
49031: PUSH
49032: FOR_TO
49033: IFFALSE 49230
// begin if building in mc_construct_list [ i ] then
49035: LD_VAR 0 1
49039: PUSH
49040: LD_EXP 86
49044: PUSH
49045: LD_VAR 0 3
49049: ARRAY
49050: IN
49051: IFFALSE 49228
// begin mc_construct_list := Replace ( mc_construct_list , i , mc_construct_list [ i ] diff building ) ;
49053: LD_ADDR_EXP 86
49057: PUSH
49058: LD_EXP 86
49062: PPUSH
49063: LD_VAR 0 3
49067: PPUSH
49068: LD_EXP 86
49072: PUSH
49073: LD_VAR 0 3
49077: ARRAY
49078: PUSH
49079: LD_VAR 0 1
49083: DIFF
49084: PPUSH
49085: CALL_OW 1
49089: ST_TO_ADDR
// if building in mc_lab [ i ] then
49090: LD_VAR 0 1
49094: PUSH
49095: LD_EXP 112
49099: PUSH
49100: LD_VAR 0 3
49104: ARRAY
49105: IN
49106: IFFALSE 49161
// mc_lab_upgrade := Replace ( mc_lab_upgrade , i , Reindex ( mc_lab_upgrade [ i ] , 1 , mc_lab_upgrade [ i ] , false ) ) ;
49108: LD_ADDR_EXP 113
49112: PUSH
49113: LD_EXP 113
49117: PPUSH
49118: LD_VAR 0 3
49122: PPUSH
49123: LD_EXP 113
49127: PUSH
49128: LD_VAR 0 3
49132: ARRAY
49133: PPUSH
49134: LD_INT 1
49136: PPUSH
49137: LD_EXP 113
49141: PUSH
49142: LD_VAR 0 3
49146: ARRAY
49147: PPUSH
49148: LD_INT 0
49150: PPUSH
49151: CALL 57201 0 4
49155: PPUSH
49156: CALL_OW 1
49160: ST_TO_ADDR
// if not building in mc_bases [ i ] then
49161: LD_VAR 0 1
49165: PUSH
49166: LD_EXP 79
49170: PUSH
49171: LD_VAR 0 3
49175: ARRAY
49176: IN
49177: NOT
49178: IFFALSE 49224
// mc_bases := ReplaceIn ( mc_bases , [ i , mc_bases [ i ] + 1 ] , building ) ;
49180: LD_ADDR_EXP 79
49184: PUSH
49185: LD_EXP 79
49189: PPUSH
49190: LD_VAR 0 3
49194: PUSH
49195: LD_EXP 79
49199: PUSH
49200: LD_VAR 0 3
49204: ARRAY
49205: PUSH
49206: LD_INT 1
49208: PLUS
49209: PUSH
49210: EMPTY
49211: LIST
49212: LIST
49213: PPUSH
49214: LD_VAR 0 1
49218: PPUSH
49219: CALL 57783 0 3
49223: ST_TO_ADDR
// exit ;
49224: POP
49225: POP
49226: GO 49232
// end ; end ;
49228: GO 49032
49230: POP
49231: POP
// end ;
49232: LD_VAR 0 2
49236: RET
// export function MCE_BuildingComplete ( building ) ; var i , j , btype , tmp , units , side ; begin
49237: LD_INT 0
49239: PPUSH
49240: PPUSH
49241: PPUSH
49242: PPUSH
49243: PPUSH
49244: PPUSH
49245: PPUSH
// if not mc_bases or not skirmish then
49246: LD_EXP 79
49250: NOT
49251: PUSH
49252: LD_EXP 77
49256: NOT
49257: OR
49258: IFFALSE 49262
// exit ;
49260: GO 49923
// for i = 1 to mc_bases do
49262: LD_ADDR_VAR 0 3
49266: PUSH
49267: DOUBLE
49268: LD_INT 1
49270: DEC
49271: ST_TO_ADDR
49272: LD_EXP 79
49276: PUSH
49277: FOR_TO
49278: IFFALSE 49921
// begin if building in mc_construct_list [ i ] then
49280: LD_VAR 0 1
49284: PUSH
49285: LD_EXP 86
49289: PUSH
49290: LD_VAR 0 3
49294: ARRAY
49295: IN
49296: IFFALSE 49919
// begin mc_construct_list := Replace ( mc_construct_list , i , mc_construct_list [ i ] diff building ) ;
49298: LD_ADDR_EXP 86
49302: PUSH
49303: LD_EXP 86
49307: PPUSH
49308: LD_VAR 0 3
49312: PPUSH
49313: LD_EXP 86
49317: PUSH
49318: LD_VAR 0 3
49322: ARRAY
49323: PUSH
49324: LD_VAR 0 1
49328: DIFF
49329: PPUSH
49330: CALL_OW 1
49334: ST_TO_ADDR
// mc_bases := ReplaceIn ( mc_bases , [ i , mc_bases [ i ] + 1 ] , building ) ;
49335: LD_ADDR_EXP 79
49339: PUSH
49340: LD_EXP 79
49344: PPUSH
49345: LD_VAR 0 3
49349: PUSH
49350: LD_EXP 79
49354: PUSH
49355: LD_VAR 0 3
49359: ARRAY
49360: PUSH
49361: LD_INT 1
49363: PLUS
49364: PUSH
49365: EMPTY
49366: LIST
49367: LIST
49368: PPUSH
49369: LD_VAR 0 1
49373: PPUSH
49374: CALL 57783 0 3
49378: ST_TO_ADDR
// btype := GetBType ( building ) ;
49379: LD_ADDR_VAR 0 5
49383: PUSH
49384: LD_VAR 0 1
49388: PPUSH
49389: CALL_OW 266
49393: ST_TO_ADDR
// side := GetSide ( building ) ;
49394: LD_ADDR_VAR 0 8
49398: PUSH
49399: LD_VAR 0 1
49403: PPUSH
49404: CALL_OW 255
49408: ST_TO_ADDR
// if btype = b_lab then
49409: LD_VAR 0 5
49413: PUSH
49414: LD_INT 6
49416: EQUAL
49417: IFFALSE 49467
// begin mc_lab := ReplaceIn ( mc_lab , [ i , mc_lab [ i ] + 1 ] , building ) ;
49419: LD_ADDR_EXP 112
49423: PUSH
49424: LD_EXP 112
49428: PPUSH
49429: LD_VAR 0 3
49433: PUSH
49434: LD_EXP 112
49438: PUSH
49439: LD_VAR 0 3
49443: ARRAY
49444: PUSH
49445: LD_INT 1
49447: PLUS
49448: PUSH
49449: EMPTY
49450: LIST
49451: LIST
49452: PPUSH
49453: LD_VAR 0 1
49457: PPUSH
49458: CALL 57783 0 3
49462: ST_TO_ADDR
// exit ;
49463: POP
49464: POP
49465: GO 49923
// end ; if btype in [ b_depot , b_workshop , b_armoury ] then
49467: LD_VAR 0 5
49471: PUSH
49472: LD_INT 0
49474: PUSH
49475: LD_INT 2
49477: PUSH
49478: LD_INT 4
49480: PUSH
49481: EMPTY
49482: LIST
49483: LIST
49484: LIST
49485: IN
49486: IFFALSE 49610
// begin if btype = b_armoury then
49488: LD_VAR 0 5
49492: PUSH
49493: LD_INT 4
49495: EQUAL
49496: IFFALSE 49506
// btype := b_barracks ;
49498: LD_ADDR_VAR 0 5
49502: PUSH
49503: LD_INT 5
49505: ST_TO_ADDR
// if btype = b_depot then
49506: LD_VAR 0 5
49510: PUSH
49511: LD_INT 0
49513: EQUAL
49514: IFFALSE 49524
// btype := b_warehouse ;
49516: LD_ADDR_VAR 0 5
49520: PUSH
49521: LD_INT 1
49523: ST_TO_ADDR
// if btype = b_workshop then
49524: LD_VAR 0 5
49528: PUSH
49529: LD_INT 2
49531: EQUAL
49532: IFFALSE 49542
// btype := b_factory ;
49534: LD_ADDR_VAR 0 5
49538: PUSH
49539: LD_INT 3
49541: ST_TO_ADDR
// if GetRestrict ( btype , side ) = state_enabled then
49542: LD_VAR 0 5
49546: PPUSH
49547: LD_VAR 0 8
49551: PPUSH
49552: CALL_OW 323
49556: PUSH
49557: LD_INT 1
49559: EQUAL
49560: IFFALSE 49606
// mc_build_upgrade := ReplaceIn ( mc_build_upgrade , [ i , mc_build_upgrade [ i ] + 1 ] , building ) ;
49562: LD_ADDR_EXP 111
49566: PUSH
49567: LD_EXP 111
49571: PPUSH
49572: LD_VAR 0 3
49576: PUSH
49577: LD_EXP 111
49581: PUSH
49582: LD_VAR 0 3
49586: ARRAY
49587: PUSH
49588: LD_INT 1
49590: PLUS
49591: PUSH
49592: EMPTY
49593: LIST
49594: LIST
49595: PPUSH
49596: LD_VAR 0 1
49600: PPUSH
49601: CALL 57783 0 3
49605: ST_TO_ADDR
// exit ;
49606: POP
49607: POP
49608: GO 49923
// end ; if btype in [ b_bunker , b_turret ] then
49610: LD_VAR 0 5
49614: PUSH
49615: LD_INT 32
49617: PUSH
49618: LD_INT 33
49620: PUSH
49621: EMPTY
49622: LIST
49623: LIST
49624: IN
49625: IFFALSE 49915
// begin mc_turret_list := ReplaceIn ( mc_turret_list , [ i , mc_turret_list [ i ] + 1 ] , building ) ;
49627: LD_ADDR_EXP 87
49631: PUSH
49632: LD_EXP 87
49636: PPUSH
49637: LD_VAR 0 3
49641: PUSH
49642: LD_EXP 87
49646: PUSH
49647: LD_VAR 0 3
49651: ARRAY
49652: PUSH
49653: LD_INT 1
49655: PLUS
49656: PUSH
49657: EMPTY
49658: LIST
49659: LIST
49660: PPUSH
49661: LD_VAR 0 1
49665: PPUSH
49666: CALL 57783 0 3
49670: ST_TO_ADDR
// if btype = b_bunker then
49671: LD_VAR 0 5
49675: PUSH
49676: LD_INT 32
49678: EQUAL
49679: IFFALSE 49915
// begin mc_empty_turret_list := ReplaceIn ( mc_empty_turret_list , [ i , mc_empty_turret_list [ i ] + 1 ] , building ) ;
49681: LD_ADDR_EXP 88
49685: PUSH
49686: LD_EXP 88
49690: PPUSH
49691: LD_VAR 0 3
49695: PUSH
49696: LD_EXP 88
49700: PUSH
49701: LD_VAR 0 3
49705: ARRAY
49706: PUSH
49707: LD_INT 1
49709: PLUS
49710: PUSH
49711: EMPTY
49712: LIST
49713: LIST
49714: PPUSH
49715: LD_VAR 0 1
49719: PPUSH
49720: CALL 57783 0 3
49724: ST_TO_ADDR
// tmp := UnitFilter ( mc_bases [ i ] , [ [ f_class , 1 ] , [ f_not , [ f_inside ] ] ] ) ;
49725: LD_ADDR_VAR 0 6
49729: PUSH
49730: LD_EXP 79
49734: PUSH
49735: LD_VAR 0 3
49739: ARRAY
49740: PPUSH
49741: LD_INT 25
49743: PUSH
49744: LD_INT 1
49746: PUSH
49747: EMPTY
49748: LIST
49749: LIST
49750: PUSH
49751: LD_INT 3
49753: PUSH
49754: LD_INT 54
49756: PUSH
49757: EMPTY
49758: LIST
49759: PUSH
49760: EMPTY
49761: LIST
49762: LIST
49763: PUSH
49764: EMPTY
49765: LIST
49766: LIST
49767: PPUSH
49768: CALL_OW 72
49772: ST_TO_ADDR
// if tmp then
49773: LD_VAR 0 6
49777: IFFALSE 49783
// exit ;
49779: POP
49780: POP
49781: GO 49923
// tmp := UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_armoury ] , [ f_btype , b_barracks ] ] ) ;
49783: LD_ADDR_VAR 0 6
49787: PUSH
49788: LD_EXP 79
49792: PUSH
49793: LD_VAR 0 3
49797: ARRAY
49798: PPUSH
49799: LD_INT 2
49801: PUSH
49802: LD_INT 30
49804: PUSH
49805: LD_INT 4
49807: PUSH
49808: EMPTY
49809: LIST
49810: LIST
49811: PUSH
49812: LD_INT 30
49814: PUSH
49815: LD_INT 5
49817: PUSH
49818: EMPTY
49819: LIST
49820: LIST
49821: PUSH
49822: EMPTY
49823: LIST
49824: LIST
49825: LIST
49826: PPUSH
49827: CALL_OW 72
49831: ST_TO_ADDR
// if not tmp then
49832: LD_VAR 0 6
49836: NOT
49837: IFFALSE 49843
// exit ;
49839: POP
49840: POP
49841: GO 49923
// for j in tmp do
49843: LD_ADDR_VAR 0 4
49847: PUSH
49848: LD_VAR 0 6
49852: PUSH
49853: FOR_IN
49854: IFFALSE 49913
// begin units := UnitFilter ( UnitsInside ( j ) , [ f_class , 1 ] ) ;
49856: LD_ADDR_VAR 0 7
49860: PUSH
49861: LD_VAR 0 4
49865: PPUSH
49866: CALL_OW 313
49870: PPUSH
49871: LD_INT 25
49873: PUSH
49874: LD_INT 1
49876: PUSH
49877: EMPTY
49878: LIST
49879: LIST
49880: PPUSH
49881: CALL_OW 72
49885: ST_TO_ADDR
// if units then
49886: LD_VAR 0 7
49890: IFFALSE 49911
// begin ComExitBuilding ( units [ 1 ] ) ;
49892: LD_VAR 0 7
49896: PUSH
49897: LD_INT 1
49899: ARRAY
49900: PPUSH
49901: CALL_OW 122
// exit ;
49905: POP
49906: POP
49907: POP
49908: POP
49909: GO 49923
// end ; end ;
49911: GO 49853
49913: POP
49914: POP
// end ; end ; exit ;
49915: POP
49916: POP
49917: GO 49923
// end ; end ;
49919: GO 49277
49921: POP
49922: POP
// end ;
49923: LD_VAR 0 2
49927: RET
// export function MCE_BuildingStarted ( building , builder ) ; var i , j , btype , x , y , d ; begin
49928: LD_INT 0
49930: PPUSH
49931: PPUSH
49932: PPUSH
49933: PPUSH
49934: PPUSH
49935: PPUSH
49936: PPUSH
// if not mc_bases or not skirmish then
49937: LD_EXP 79
49941: NOT
49942: PUSH
49943: LD_EXP 77
49947: NOT
49948: OR
49949: IFFALSE 49953
// exit ;
49951: GO 50184
// btype := GetBType ( building ) ;
49953: LD_ADDR_VAR 0 6
49957: PUSH
49958: LD_VAR 0 1
49962: PPUSH
49963: CALL_OW 266
49967: ST_TO_ADDR
// x := GetX ( building ) ;
49968: LD_ADDR_VAR 0 7
49972: PUSH
49973: LD_VAR 0 1
49977: PPUSH
49978: CALL_OW 250
49982: ST_TO_ADDR
// y := GetY ( building ) ;
49983: LD_ADDR_VAR 0 8
49987: PUSH
49988: LD_VAR 0 1
49992: PPUSH
49993: CALL_OW 251
49997: ST_TO_ADDR
// d := GetDir ( building ) ;
49998: LD_ADDR_VAR 0 9
50002: PUSH
50003: LD_VAR 0 1
50007: PPUSH
50008: CALL_OW 254
50012: ST_TO_ADDR
// for i = 1 to mc_bases do
50013: LD_ADDR_VAR 0 4
50017: PUSH
50018: DOUBLE
50019: LD_INT 1
50021: DEC
50022: ST_TO_ADDR
50023: LD_EXP 79
50027: PUSH
50028: FOR_TO
50029: IFFALSE 50182
// begin if not mc_build_list [ i ] then
50031: LD_EXP 84
50035: PUSH
50036: LD_VAR 0 4
50040: ARRAY
50041: NOT
50042: IFFALSE 50046
// continue ;
50044: GO 50028
// if CompareArray ( [ btype , x , y , d ] , mc_build_list [ i ] [ 1 ] ) then
50046: LD_VAR 0 6
50050: PUSH
50051: LD_VAR 0 7
50055: PUSH
50056: LD_VAR 0 8
50060: PUSH
50061: LD_VAR 0 9
50065: PUSH
50066: EMPTY
50067: LIST
50068: LIST
50069: LIST
50070: LIST
50071: PPUSH
50072: LD_EXP 84
50076: PUSH
50077: LD_VAR 0 4
50081: ARRAY
50082: PUSH
50083: LD_INT 1
50085: ARRAY
50086: PPUSH
50087: CALL 63952 0 2
50091: IFFALSE 50180
// begin mc_build_list := Replace ( mc_build_list , i , Delete ( mc_build_list [ i ] , 1 ) ) ;
50093: LD_ADDR_EXP 84
50097: PUSH
50098: LD_EXP 84
50102: PPUSH
50103: LD_VAR 0 4
50107: PPUSH
50108: LD_EXP 84
50112: PUSH
50113: LD_VAR 0 4
50117: ARRAY
50118: PPUSH
50119: LD_INT 1
50121: PPUSH
50122: CALL_OW 3
50126: PPUSH
50127: CALL_OW 1
50131: ST_TO_ADDR
// mc_construct_list := ReplaceIn ( mc_construct_list , [ i , mc_construct_list [ i ] + 1 ] , building ) ;
50132: LD_ADDR_EXP 86
50136: PUSH
50137: LD_EXP 86
50141: PPUSH
50142: LD_VAR 0 4
50146: PUSH
50147: LD_EXP 86
50151: PUSH
50152: LD_VAR 0 4
50156: ARRAY
50157: PUSH
50158: LD_INT 1
50160: PLUS
50161: PUSH
50162: EMPTY
50163: LIST
50164: LIST
50165: PPUSH
50166: LD_VAR 0 1
50170: PPUSH
50171: CALL 57783 0 3
50175: ST_TO_ADDR
// exit ;
50176: POP
50177: POP
50178: GO 50184
// end ; end ;
50180: GO 50028
50182: POP
50183: POP
// end ;
50184: LD_VAR 0 3
50188: RET
// export function MCE_LeaveBuilding ( building , unit ) ; var i , tmp ; begin
50189: LD_INT 0
50191: PPUSH
50192: PPUSH
50193: PPUSH
// if not mc_bases or not skirmish then
50194: LD_EXP 79
50198: NOT
50199: PUSH
50200: LD_EXP 77
50204: NOT
50205: OR
50206: IFFALSE 50210
// exit ;
50208: GO 50400
// for i = 1 to mc_bases do
50210: LD_ADDR_VAR 0 4
50214: PUSH
50215: DOUBLE
50216: LD_INT 1
50218: DEC
50219: ST_TO_ADDR
50220: LD_EXP 79
50224: PUSH
50225: FOR_TO
50226: IFFALSE 50313
// begin if building in mc_turret_list [ i ] and not building in mc_empty_turret_list [ i ] then
50228: LD_VAR 0 1
50232: PUSH
50233: LD_EXP 87
50237: PUSH
50238: LD_VAR 0 4
50242: ARRAY
50243: IN
50244: PUSH
50245: LD_VAR 0 1
50249: PUSH
50250: LD_EXP 88
50254: PUSH
50255: LD_VAR 0 4
50259: ARRAY
50260: IN
50261: NOT
50262: AND
50263: IFFALSE 50311
// begin mc_empty_turret_list := ReplaceIn ( mc_empty_turret_list , [ i , mc_empty_turret_list [ i ] + 1 ] , building ) ;
50265: LD_ADDR_EXP 88
50269: PUSH
50270: LD_EXP 88
50274: PPUSH
50275: LD_VAR 0 4
50279: PUSH
50280: LD_EXP 88
50284: PUSH
50285: LD_VAR 0 4
50289: ARRAY
50290: PUSH
50291: LD_INT 1
50293: PLUS
50294: PUSH
50295: EMPTY
50296: LIST
50297: LIST
50298: PPUSH
50299: LD_VAR 0 1
50303: PPUSH
50304: CALL 57783 0 3
50308: ST_TO_ADDR
// break ;
50309: GO 50313
// end ; end ;
50311: GO 50225
50313: POP
50314: POP
// if GetClass ( building ) in mc_sides and GetBType ( building ) = b_barracks and GetTag ( unit ) <> 18 then
50315: LD_VAR 0 1
50319: PPUSH
50320: CALL_OW 257
50324: PUSH
50325: LD_EXP 105
50329: IN
50330: PUSH
50331: LD_VAR 0 1
50335: PPUSH
50336: CALL_OW 266
50340: PUSH
50341: LD_INT 5
50343: EQUAL
50344: AND
50345: PUSH
50346: LD_VAR 0 2
50350: PPUSH
50351: CALL_OW 110
50355: PUSH
50356: LD_INT 18
50358: NONEQUAL
50359: AND
50360: IFFALSE 50400
// if GetClass ( unit ) in [ 5 , 8 , 9 ] then
50362: LD_VAR 0 2
50366: PPUSH
50367: CALL_OW 257
50371: PUSH
50372: LD_INT 5
50374: PUSH
50375: LD_INT 8
50377: PUSH
50378: LD_INT 9
50380: PUSH
50381: EMPTY
50382: LIST
50383: LIST
50384: LIST
50385: IN
50386: IFFALSE 50400
// SetClass ( unit , 1 ) ;
50388: LD_VAR 0 2
50392: PPUSH
50393: LD_INT 1
50395: PPUSH
50396: CALL_OW 336
// end ;
50400: LD_VAR 0 3
50404: RET
// export function MCE_EvacuateVehicle ( driver , abandoned_vehicle , unknown1 , unknown2 ) ; var i ; begin
50405: LD_INT 0
50407: PPUSH
50408: PPUSH
// if not mc_bases or not skirmish then
50409: LD_EXP 79
50413: NOT
50414: PUSH
50415: LD_EXP 77
50419: NOT
50420: OR
50421: IFFALSE 50425
// exit ;
50423: GO 50541
// if GetLives ( abandoned_vehicle ) > 250 then
50425: LD_VAR 0 2
50429: PPUSH
50430: CALL_OW 256
50434: PUSH
50435: LD_INT 250
50437: GREATER
50438: IFFALSE 50442
// exit ;
50440: GO 50541
// for i = 1 to mc_bases do
50442: LD_ADDR_VAR 0 6
50446: PUSH
50447: DOUBLE
50448: LD_INT 1
50450: DEC
50451: ST_TO_ADDR
50452: LD_EXP 79
50456: PUSH
50457: FOR_TO
50458: IFFALSE 50539
// begin if driver in mc_bases [ i ] then
50460: LD_VAR 0 1
50464: PUSH
50465: LD_EXP 79
50469: PUSH
50470: LD_VAR 0 6
50474: ARRAY
50475: IN
50476: IFFALSE 50537
// begin ComMoveUnit ( driver , UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) [ 1 ] ) ;
50478: LD_VAR 0 1
50482: PPUSH
50483: LD_EXP 79
50487: PUSH
50488: LD_VAR 0 6
50492: ARRAY
50493: PPUSH
50494: LD_INT 2
50496: PUSH
50497: LD_INT 30
50499: PUSH
50500: LD_INT 0
50502: PUSH
50503: EMPTY
50504: LIST
50505: LIST
50506: PUSH
50507: LD_INT 30
50509: PUSH
50510: LD_INT 1
50512: PUSH
50513: EMPTY
50514: LIST
50515: LIST
50516: PUSH
50517: EMPTY
50518: LIST
50519: LIST
50520: LIST
50521: PPUSH
50522: CALL_OW 72
50526: PUSH
50527: LD_INT 1
50529: ARRAY
50530: PPUSH
50531: CALL_OW 112
// break ;
50535: GO 50539
// end ; end ;
50537: GO 50457
50539: POP
50540: POP
// end ; end_of_file
50541: LD_VAR 0 5
50545: RET
// export function PrepareUnit ( ident , exist_mode , prefix ) ; var unit ; begin
50546: LD_INT 0
50548: PPUSH
50549: PPUSH
// if exist_mode then
50550: LD_VAR 0 2
50554: IFFALSE 50579
// unit := CreateCharacter ( prefix & ident ) else
50556: LD_ADDR_VAR 0 5
50560: PUSH
50561: LD_VAR 0 3
50565: PUSH
50566: LD_VAR 0 1
50570: STR
50571: PPUSH
50572: CALL_OW 34
50576: ST_TO_ADDR
50577: GO 50594
// unit := NewCharacter ( ident ) ;
50579: LD_ADDR_VAR 0 5
50583: PUSH
50584: LD_VAR 0 1
50588: PPUSH
50589: CALL_OW 25
50593: ST_TO_ADDR
// result := unit ;
50594: LD_ADDR_VAR 0 4
50598: PUSH
50599: LD_VAR 0 5
50603: ST_TO_ADDR
// end ;
50604: LD_VAR 0 4
50608: RET
// export function GetTechNation ( side , nation , state ) ; var i ; begin
50609: LD_INT 0
50611: PPUSH
50612: PPUSH
// if not side or not nation then
50613: LD_VAR 0 1
50617: NOT
50618: PUSH
50619: LD_VAR 0 2
50623: NOT
50624: OR
50625: IFFALSE 50629
// exit ;
50627: GO 51273
// case nation of nation_american :
50629: LD_VAR 0 2
50633: PUSH
50634: LD_INT 1
50636: DOUBLE
50637: EQUAL
50638: IFTRUE 50642
50640: GO 50816
50642: POP
// result := [ 35 , 45 , 46 , 47 , 1 , 2 , 6 , 15 , 16 , 7 , 12 , 13 , 10 , 14 , 20 , 21 , 22 , 25 , 32 , 27 , 36 , 69 , 39 , 34 , 40 , 48 , 49 , 50 , 51 , 52 , 53 , 54 , 55 , 56 , 57 , 58 , 59 , 60 , 61 , 62 , 80 ] ; nation_arabian :
50643: LD_ADDR_VAR 0 4
50647: PUSH
50648: LD_INT 35
50650: PUSH
50651: LD_INT 45
50653: PUSH
50654: LD_INT 46
50656: PUSH
50657: LD_INT 47
50659: PUSH
50660: LD_INT 1
50662: PUSH
50663: LD_INT 2
50665: PUSH
50666: LD_INT 6
50668: PUSH
50669: LD_INT 15
50671: PUSH
50672: LD_INT 16
50674: PUSH
50675: LD_INT 7
50677: PUSH
50678: LD_INT 12
50680: PUSH
50681: LD_INT 13
50683: PUSH
50684: LD_INT 10
50686: PUSH
50687: LD_INT 14
50689: PUSH
50690: LD_INT 20
50692: PUSH
50693: LD_INT 21
50695: PUSH
50696: LD_INT 22
50698: PUSH
50699: LD_INT 25
50701: PUSH
50702: LD_INT 32
50704: PUSH
50705: LD_INT 27
50707: PUSH
50708: LD_INT 36
50710: PUSH
50711: LD_INT 69
50713: PUSH
50714: LD_INT 39
50716: PUSH
50717: LD_INT 34
50719: PUSH
50720: LD_INT 40
50722: PUSH
50723: LD_INT 48
50725: PUSH
50726: LD_INT 49
50728: PUSH
50729: LD_INT 50
50731: PUSH
50732: LD_INT 51
50734: PUSH
50735: LD_INT 52
50737: PUSH
50738: LD_INT 53
50740: PUSH
50741: LD_INT 54
50743: PUSH
50744: LD_INT 55
50746: PUSH
50747: LD_INT 56
50749: PUSH
50750: LD_INT 57
50752: PUSH
50753: LD_INT 58
50755: PUSH
50756: LD_INT 59
50758: PUSH
50759: LD_INT 60
50761: PUSH
50762: LD_INT 61
50764: PUSH
50765: LD_INT 62
50767: PUSH
50768: LD_INT 80
50770: PUSH
50771: EMPTY
50772: LIST
50773: LIST
50774: LIST
50775: LIST
50776: LIST
50777: LIST
50778: LIST
50779: LIST
50780: LIST
50781: LIST
50782: LIST
50783: LIST
50784: LIST
50785: LIST
50786: LIST
50787: LIST
50788: LIST
50789: LIST
50790: LIST
50791: LIST
50792: LIST
50793: LIST
50794: LIST
50795: LIST
50796: LIST
50797: LIST
50798: LIST
50799: LIST
50800: LIST
50801: LIST
50802: LIST
50803: LIST
50804: LIST
50805: LIST
50806: LIST
50807: LIST
50808: LIST
50809: LIST
50810: LIST
50811: LIST
50812: LIST
50813: ST_TO_ADDR
50814: GO 51197
50816: LD_INT 2
50818: DOUBLE
50819: EQUAL
50820: IFTRUE 50824
50822: GO 51006
50824: POP
// result := [ 35 , 45 , 46 , 47 , 70 , 1 , 11 , 3 , 4 , 5 , 6 , 15 , 18 , 7 , 17 , 8 , 20 , 21 , 22 , 72 , 26 , 69 , 39 , 40 , 41 , 42 , 43 , 48 , 49 , 50 , 51 , 52 , 53 , 54 , 55 , 56 , 60 , 61 , 62 , 66 , 67 , 68 , 81 ] ; nation_russian :
50825: LD_ADDR_VAR 0 4
50829: PUSH
50830: LD_INT 35
50832: PUSH
50833: LD_INT 45
50835: PUSH
50836: LD_INT 46
50838: PUSH
50839: LD_INT 47
50841: PUSH
50842: LD_INT 70
50844: PUSH
50845: LD_INT 1
50847: PUSH
50848: LD_INT 11
50850: PUSH
50851: LD_INT 3
50853: PUSH
50854: LD_INT 4
50856: PUSH
50857: LD_INT 5
50859: PUSH
50860: LD_INT 6
50862: PUSH
50863: LD_INT 15
50865: PUSH
50866: LD_INT 18
50868: PUSH
50869: LD_INT 7
50871: PUSH
50872: LD_INT 17
50874: PUSH
50875: LD_INT 8
50877: PUSH
50878: LD_INT 20
50880: PUSH
50881: LD_INT 21
50883: PUSH
50884: LD_INT 22
50886: PUSH
50887: LD_INT 72
50889: PUSH
50890: LD_INT 26
50892: PUSH
50893: LD_INT 69
50895: PUSH
50896: LD_INT 39
50898: PUSH
50899: LD_INT 40
50901: PUSH
50902: LD_INT 41
50904: PUSH
50905: LD_INT 42
50907: PUSH
50908: LD_INT 43
50910: PUSH
50911: LD_INT 48
50913: PUSH
50914: LD_INT 49
50916: PUSH
50917: LD_INT 50
50919: PUSH
50920: LD_INT 51
50922: PUSH
50923: LD_INT 52
50925: PUSH
50926: LD_INT 53
50928: PUSH
50929: LD_INT 54
50931: PUSH
50932: LD_INT 55
50934: PUSH
50935: LD_INT 56
50937: PUSH
50938: LD_INT 60
50940: PUSH
50941: LD_INT 61
50943: PUSH
50944: LD_INT 62
50946: PUSH
50947: LD_INT 66
50949: PUSH
50950: LD_INT 67
50952: PUSH
50953: LD_INT 68
50955: PUSH
50956: LD_INT 81
50958: PUSH
50959: EMPTY
50960: LIST
50961: LIST
50962: LIST
50963: LIST
50964: LIST
50965: LIST
50966: LIST
50967: LIST
50968: LIST
50969: LIST
50970: LIST
50971: LIST
50972: LIST
50973: LIST
50974: LIST
50975: LIST
50976: LIST
50977: LIST
50978: LIST
50979: LIST
50980: LIST
50981: LIST
50982: LIST
50983: LIST
50984: LIST
50985: LIST
50986: LIST
50987: LIST
50988: LIST
50989: LIST
50990: LIST
50991: LIST
50992: LIST
50993: LIST
50994: LIST
50995: LIST
50996: LIST
50997: LIST
50998: LIST
50999: LIST
51000: LIST
51001: LIST
51002: LIST
51003: ST_TO_ADDR
51004: GO 51197
51006: LD_INT 3
51008: DOUBLE
51009: EQUAL
51010: IFTRUE 51014
51012: GO 51196
51014: POP
// result := [ 46 , 47 , 1 , 2 , 11 , 9 , 20 , 19 , 21 , 24 , 22 , 25 , 28 , 29 , 30 , 31 , 37 , 38 , 32 , 27 , 33 , 69 , 39 , 34 , 40 , 71 , 23 , 44 , 48 , 49 , 50 , 51 , 52 , 53 , 54 , 55 , 56 , 57 , 58 , 59 , 63 , 64 , 65 ] ; end ;
51015: LD_ADDR_VAR 0 4
51019: PUSH
51020: LD_INT 46
51022: PUSH
51023: LD_INT 47
51025: PUSH
51026: LD_INT 1
51028: PUSH
51029: LD_INT 2
51031: PUSH
51032: LD_INT 11
51034: PUSH
51035: LD_INT 9
51037: PUSH
51038: LD_INT 20
51040: PUSH
51041: LD_INT 19
51043: PUSH
51044: LD_INT 21
51046: PUSH
51047: LD_INT 24
51049: PUSH
51050: LD_INT 22
51052: PUSH
51053: LD_INT 25
51055: PUSH
51056: LD_INT 28
51058: PUSH
51059: LD_INT 29
51061: PUSH
51062: LD_INT 30
51064: PUSH
51065: LD_INT 31
51067: PUSH
51068: LD_INT 37
51070: PUSH
51071: LD_INT 38
51073: PUSH
51074: LD_INT 32
51076: PUSH
51077: LD_INT 27
51079: PUSH
51080: LD_INT 33
51082: PUSH
51083: LD_INT 69
51085: PUSH
51086: LD_INT 39
51088: PUSH
51089: LD_INT 34
51091: PUSH
51092: LD_INT 40
51094: PUSH
51095: LD_INT 71
51097: PUSH
51098: LD_INT 23
51100: PUSH
51101: LD_INT 44
51103: PUSH
51104: LD_INT 48
51106: PUSH
51107: LD_INT 49
51109: PUSH
51110: LD_INT 50
51112: PUSH
51113: LD_INT 51
51115: PUSH
51116: LD_INT 52
51118: PUSH
51119: LD_INT 53
51121: PUSH
51122: LD_INT 54
51124: PUSH
51125: LD_INT 55
51127: PUSH
51128: LD_INT 56
51130: PUSH
51131: LD_INT 57
51133: PUSH
51134: LD_INT 58
51136: PUSH
51137: LD_INT 59
51139: PUSH
51140: LD_INT 63
51142: PUSH
51143: LD_INT 64
51145: PUSH
51146: LD_INT 65
51148: PUSH
51149: EMPTY
51150: LIST
51151: LIST
51152: LIST
51153: LIST
51154: LIST
51155: LIST
51156: LIST
51157: LIST
51158: LIST
51159: LIST
51160: LIST
51161: LIST
51162: LIST
51163: LIST
51164: LIST
51165: LIST
51166: LIST
51167: LIST
51168: LIST
51169: LIST
51170: LIST
51171: LIST
51172: LIST
51173: LIST
51174: LIST
51175: LIST
51176: LIST
51177: LIST
51178: LIST
51179: LIST
51180: LIST
51181: LIST
51182: LIST
51183: LIST
51184: LIST
51185: LIST
51186: LIST
51187: LIST
51188: LIST
51189: LIST
51190: LIST
51191: LIST
51192: LIST
51193: ST_TO_ADDR
51194: GO 51197
51196: POP
// if state > - 1 and state < 3 then
51197: LD_VAR 0 3
51201: PUSH
51202: LD_INT 1
51204: NEG
51205: GREATER
51206: PUSH
51207: LD_VAR 0 3
51211: PUSH
51212: LD_INT 3
51214: LESS
51215: AND
51216: IFFALSE 51273
// for i in result do
51218: LD_ADDR_VAR 0 5
51222: PUSH
51223: LD_VAR 0 4
51227: PUSH
51228: FOR_IN
51229: IFFALSE 51271
// if GetTech ( i , side ) <> state then
51231: LD_VAR 0 5
51235: PPUSH
51236: LD_VAR 0 1
51240: PPUSH
51241: CALL_OW 321
51245: PUSH
51246: LD_VAR 0 3
51250: NONEQUAL
51251: IFFALSE 51269
// result := result diff i ;
51253: LD_ADDR_VAR 0 4
51257: PUSH
51258: LD_VAR 0 4
51262: PUSH
51263: LD_VAR 0 5
51267: DIFF
51268: ST_TO_ADDR
51269: GO 51228
51271: POP
51272: POP
// end ;
51273: LD_VAR 0 4
51277: RET
// export function TechCanBeResearch ( side , tech ) ; var i , tmp ; begin
51278: LD_INT 0
51280: PPUSH
51281: PPUSH
51282: PPUSH
// result := true ;
51283: LD_ADDR_VAR 0 3
51287: PUSH
51288: LD_INT 1
51290: ST_TO_ADDR
// tmp := GetTechTechsReq ( tech ) ;
51291: LD_ADDR_VAR 0 5
51295: PUSH
51296: LD_VAR 0 2
51300: PPUSH
51301: CALL_OW 480
51305: ST_TO_ADDR
// if not tmp then
51306: LD_VAR 0 5
51310: NOT
51311: IFFALSE 51315
// exit ;
51313: GO 51364
// for i in tmp do
51315: LD_ADDR_VAR 0 4
51319: PUSH
51320: LD_VAR 0 5
51324: PUSH
51325: FOR_IN
51326: IFFALSE 51362
// if GetTech ( i , side ) <> state_researched then
51328: LD_VAR 0 4
51332: PPUSH
51333: LD_VAR 0 1
51337: PPUSH
51338: CALL_OW 321
51342: PUSH
51343: LD_INT 2
51345: NONEQUAL
51346: IFFALSE 51360
// begin result := false ;
51348: LD_ADDR_VAR 0 3
51352: PUSH
51353: LD_INT 0
51355: ST_TO_ADDR
// exit ;
51356: POP
51357: POP
51358: GO 51364
// end ;
51360: GO 51325
51362: POP
51363: POP
// end ;
51364: LD_VAR 0 3
51368: RET
// export function ComSpaceTimeShoot ( unit ) ; var i , x , y , _x , _y , tmp , side , enemy , in_unit , tech_space , tech_time , missile ; begin
51369: LD_INT 0
51371: PPUSH
51372: PPUSH
51373: PPUSH
51374: PPUSH
51375: PPUSH
51376: PPUSH
51377: PPUSH
51378: PPUSH
51379: PPUSH
51380: PPUSH
51381: PPUSH
51382: PPUSH
51383: PPUSH
// if not unit or GetClass ( unit ) <> class_bazooker then
51384: LD_VAR 0 1
51388: NOT
51389: PUSH
51390: LD_VAR 0 1
51394: PPUSH
51395: CALL_OW 257
51399: PUSH
51400: LD_INT 9
51402: NONEQUAL
51403: OR
51404: IFFALSE 51408
// exit ;
51406: GO 51981
// side := GetSide ( unit ) ;
51408: LD_ADDR_VAR 0 9
51412: PUSH
51413: LD_VAR 0 1
51417: PPUSH
51418: CALL_OW 255
51422: ST_TO_ADDR
// tech_space := tech_spacanom ;
51423: LD_ADDR_VAR 0 12
51427: PUSH
51428: LD_INT 29
51430: ST_TO_ADDR
// tech_time := tech_taurad ;
51431: LD_ADDR_VAR 0 13
51435: PUSH
51436: LD_INT 28
51438: ST_TO_ADDR
// in_unit := IsInUnit ( unit ) ;
51439: LD_ADDR_VAR 0 11
51443: PUSH
51444: LD_VAR 0 1
51448: PPUSH
51449: CALL_OW 310
51453: ST_TO_ADDR
// if GetType ( in_unit ) = unit_vehicle then
51454: LD_VAR 0 11
51458: PPUSH
51459: CALL_OW 247
51463: PUSH
51464: LD_INT 2
51466: EQUAL
51467: IFFALSE 51471
// exit ;
51469: GO 51981
// tmp := FilterAllUnits ( [ [ f_enemy , side ] , [ f_not , [ f_type , unit_building ] ] ] ) ;
51471: LD_ADDR_VAR 0 8
51475: PUSH
51476: LD_INT 81
51478: PUSH
51479: LD_VAR 0 9
51483: PUSH
51484: EMPTY
51485: LIST
51486: LIST
51487: PUSH
51488: LD_INT 3
51490: PUSH
51491: LD_INT 21
51493: PUSH
51494: LD_INT 3
51496: PUSH
51497: EMPTY
51498: LIST
51499: LIST
51500: PUSH
51501: EMPTY
51502: LIST
51503: LIST
51504: PUSH
51505: EMPTY
51506: LIST
51507: LIST
51508: PPUSH
51509: CALL_OW 69
51513: ST_TO_ADDR
// if not tmp then
51514: LD_VAR 0 8
51518: NOT
51519: IFFALSE 51523
// exit ;
51521: GO 51981
// if in_unit then
51523: LD_VAR 0 11
51527: IFFALSE 51551
// enemy := NearestUnitToUnit ( tmp , in_unit ) else
51529: LD_ADDR_VAR 0 10
51533: PUSH
51534: LD_VAR 0 8
51538: PPUSH
51539: LD_VAR 0 11
51543: PPUSH
51544: CALL_OW 74
51548: ST_TO_ADDR
51549: GO 51571
// enemy := NearestUnitToUnit ( tmp , unit ) ;
51551: LD_ADDR_VAR 0 10
51555: PUSH
51556: LD_VAR 0 8
51560: PPUSH
51561: LD_VAR 0 1
51565: PPUSH
51566: CALL_OW 74
51570: ST_TO_ADDR
// if not enemy then
51571: LD_VAR 0 10
51575: NOT
51576: IFFALSE 51580
// exit ;
51578: GO 51981
// if ( in_unit and GetDistUnits ( in_unit , enemy ) > 13 ) or GetDistUnits ( unit , enemy ) > 12 then
51580: LD_VAR 0 11
51584: PUSH
51585: LD_VAR 0 11
51589: PPUSH
51590: LD_VAR 0 10
51594: PPUSH
51595: CALL_OW 296
51599: PUSH
51600: LD_INT 13
51602: GREATER
51603: AND
51604: PUSH
51605: LD_VAR 0 1
51609: PPUSH
51610: LD_VAR 0 10
51614: PPUSH
51615: CALL_OW 296
51619: PUSH
51620: LD_INT 12
51622: GREATER
51623: OR
51624: IFFALSE 51628
// exit ;
51626: GO 51981
// missile := [ 1 ] ;
51628: LD_ADDR_VAR 0 14
51632: PUSH
51633: LD_INT 1
51635: PUSH
51636: EMPTY
51637: LIST
51638: ST_TO_ADDR
// if Researched ( side , tech_space ) then
51639: LD_VAR 0 9
51643: PPUSH
51644: LD_VAR 0 12
51648: PPUSH
51649: CALL_OW 325
51653: IFFALSE 51682
// missile := Insert ( missile , missile + 1 , 2 ) ;
51655: LD_ADDR_VAR 0 14
51659: PUSH
51660: LD_VAR 0 14
51664: PPUSH
51665: LD_VAR 0 14
51669: PUSH
51670: LD_INT 1
51672: PLUS
51673: PPUSH
51674: LD_INT 2
51676: PPUSH
51677: CALL_OW 2
51681: ST_TO_ADDR
// if Researched ( side , tech_time ) and not Researched ( GetSide ( enemy ) , tech_time ) then
51682: LD_VAR 0 9
51686: PPUSH
51687: LD_VAR 0 13
51691: PPUSH
51692: CALL_OW 325
51696: PUSH
51697: LD_VAR 0 10
51701: PPUSH
51702: CALL_OW 255
51706: PPUSH
51707: LD_VAR 0 13
51711: PPUSH
51712: CALL_OW 325
51716: NOT
51717: AND
51718: IFFALSE 51747
// missile := Insert ( missile , missile + 1 , 3 ) ;
51720: LD_ADDR_VAR 0 14
51724: PUSH
51725: LD_VAR 0 14
51729: PPUSH
51730: LD_VAR 0 14
51734: PUSH
51735: LD_INT 1
51737: PLUS
51738: PPUSH
51739: LD_INT 3
51741: PPUSH
51742: CALL_OW 2
51746: ST_TO_ADDR
// if missile < 2 then
51747: LD_VAR 0 14
51751: PUSH
51752: LD_INT 2
51754: LESS
51755: IFFALSE 51759
// exit ;
51757: GO 51981
// x := GetX ( enemy ) ;
51759: LD_ADDR_VAR 0 4
51763: PUSH
51764: LD_VAR 0 10
51768: PPUSH
51769: CALL_OW 250
51773: ST_TO_ADDR
// y := GetY ( enemy ) ;
51774: LD_ADDR_VAR 0 5
51778: PUSH
51779: LD_VAR 0 10
51783: PPUSH
51784: CALL_OW 251
51788: ST_TO_ADDR
// _x := x + rand ( - 1 , 1 ) ;
51789: LD_ADDR_VAR 0 6
51793: PUSH
51794: LD_VAR 0 4
51798: PUSH
51799: LD_INT 1
51801: NEG
51802: PPUSH
51803: LD_INT 1
51805: PPUSH
51806: CALL_OW 12
51810: PLUS
51811: ST_TO_ADDR
// _y := y + rand ( - 1 , 1 ) ;
51812: LD_ADDR_VAR 0 7
51816: PUSH
51817: LD_VAR 0 5
51821: PUSH
51822: LD_INT 1
51824: NEG
51825: PPUSH
51826: LD_INT 1
51828: PPUSH
51829: CALL_OW 12
51833: PLUS
51834: ST_TO_ADDR
// if not ValidHex ( _x , _y ) then
51835: LD_VAR 0 6
51839: PPUSH
51840: LD_VAR 0 7
51844: PPUSH
51845: CALL_OW 488
51849: NOT
51850: IFFALSE 51872
// begin _x := x ;
51852: LD_ADDR_VAR 0 6
51856: PUSH
51857: LD_VAR 0 4
51861: ST_TO_ADDR
// _y := y ;
51862: LD_ADDR_VAR 0 7
51866: PUSH
51867: LD_VAR 0 5
51871: ST_TO_ADDR
// end ; i := rand ( 1 , missile ) ;
51872: LD_ADDR_VAR 0 3
51876: PUSH
51877: LD_INT 1
51879: PPUSH
51880: LD_VAR 0 14
51884: PPUSH
51885: CALL_OW 12
51889: ST_TO_ADDR
// case i of 1 :
51890: LD_VAR 0 3
51894: PUSH
51895: LD_INT 1
51897: DOUBLE
51898: EQUAL
51899: IFTRUE 51903
51901: GO 51920
51903: POP
// ComAttackUnit ( unit , enemy ) ; 2 :
51904: LD_VAR 0 1
51908: PPUSH
51909: LD_VAR 0 10
51913: PPUSH
51914: CALL_OW 115
51918: GO 51981
51920: LD_INT 2
51922: DOUBLE
51923: EQUAL
51924: IFTRUE 51928
51926: GO 51950
51928: POP
// ComSpaceShift ( unit , _x , _y ) ; 3 :
51929: LD_VAR 0 1
51933: PPUSH
51934: LD_VAR 0 6
51938: PPUSH
51939: LD_VAR 0 7
51943: PPUSH
51944: CALL_OW 153
51948: GO 51981
51950: LD_INT 3
51952: DOUBLE
51953: EQUAL
51954: IFTRUE 51958
51956: GO 51980
51958: POP
// ComTimeShift ( unit , _x , _y ) ; end ;
51959: LD_VAR 0 1
51963: PPUSH
51964: LD_VAR 0 6
51968: PPUSH
51969: LD_VAR 0 7
51973: PPUSH
51974: CALL_OW 154
51978: GO 51981
51980: POP
// end ;
51981: LD_VAR 0 2
51985: RET
// export function ComStandNearbyBuilding ( unit , building ) ; var i , x , y , _x , _y ; begin
51986: LD_INT 0
51988: PPUSH
51989: PPUSH
51990: PPUSH
51991: PPUSH
51992: PPUSH
51993: PPUSH
// if not unit or not building then
51994: LD_VAR 0 1
51998: NOT
51999: PUSH
52000: LD_VAR 0 2
52004: NOT
52005: OR
52006: IFFALSE 52010
// exit ;
52008: GO 52168
// x := GetX ( building ) ;
52010: LD_ADDR_VAR 0 5
52014: PUSH
52015: LD_VAR 0 2
52019: PPUSH
52020: CALL_OW 250
52024: ST_TO_ADDR
// y := GetY ( building ) ;
52025: LD_ADDR_VAR 0 6
52029: PUSH
52030: LD_VAR 0 2
52034: PPUSH
52035: CALL_OW 251
52039: ST_TO_ADDR
// for i = 0 to 5 do
52040: LD_ADDR_VAR 0 4
52044: PUSH
52045: DOUBLE
52046: LD_INT 0
52048: DEC
52049: ST_TO_ADDR
52050: LD_INT 5
52052: PUSH
52053: FOR_TO
52054: IFFALSE 52166
// begin _x := ShiftX ( x , i , 3 ) ;
52056: LD_ADDR_VAR 0 7
52060: PUSH
52061: LD_VAR 0 5
52065: PPUSH
52066: LD_VAR 0 4
52070: PPUSH
52071: LD_INT 3
52073: PPUSH
52074: CALL_OW 272
52078: ST_TO_ADDR
// _y := ShiftY ( y , i , 3 ) ;
52079: LD_ADDR_VAR 0 8
52083: PUSH
52084: LD_VAR 0 6
52088: PPUSH
52089: LD_VAR 0 4
52093: PPUSH
52094: LD_INT 3
52096: PPUSH
52097: CALL_OW 273
52101: ST_TO_ADDR
// if not ValidHex ( _x , _y ) then
52102: LD_VAR 0 7
52106: PPUSH
52107: LD_VAR 0 8
52111: PPUSH
52112: CALL_OW 488
52116: NOT
52117: IFFALSE 52121
// continue ;
52119: GO 52053
// if HexInfo ( _x , _y ) = 0 then
52121: LD_VAR 0 7
52125: PPUSH
52126: LD_VAR 0 8
52130: PPUSH
52131: CALL_OW 428
52135: PUSH
52136: LD_INT 0
52138: EQUAL
52139: IFFALSE 52164
// begin ComMoveXY ( unit , _x , _y ) ;
52141: LD_VAR 0 1
52145: PPUSH
52146: LD_VAR 0 7
52150: PPUSH
52151: LD_VAR 0 8
52155: PPUSH
52156: CALL_OW 111
// exit ;
52160: POP
52161: POP
52162: GO 52168
// end ; end ;
52164: GO 52053
52166: POP
52167: POP
// end ;
52168: LD_VAR 0 3
52172: RET
// export function ScanBase ( side , base_area ) ; begin
52173: LD_INT 0
52175: PPUSH
// result := FilterUnitsInArea ( base_area , [ f_enemy , side ] ) ;
52176: LD_ADDR_VAR 0 3
52180: PUSH
52181: LD_VAR 0 2
52185: PPUSH
52186: LD_INT 81
52188: PUSH
52189: LD_VAR 0 1
52193: PUSH
52194: EMPTY
52195: LIST
52196: LIST
52197: PPUSH
52198: CALL_OW 70
52202: ST_TO_ADDR
// end ;
52203: LD_VAR 0 3
52207: RET
// export function BasicDefend ( base , solds , area ) ; var enemy , side , i , hex ; begin
52208: LD_INT 0
52210: PPUSH
52211: PPUSH
52212: PPUSH
52213: PPUSH
52214: PPUSH
// if not base or not mc_bases [ base ] or not solds or not area then
52215: LD_VAR 0 1
52219: NOT
52220: PUSH
52221: LD_EXP 79
52225: PUSH
52226: LD_VAR 0 1
52230: ARRAY
52231: NOT
52232: OR
52233: PUSH
52234: LD_VAR 0 2
52238: NOT
52239: OR
52240: PUSH
52241: LD_VAR 0 3
52245: NOT
52246: OR
52247: IFFALSE 52251
// exit ;
52249: GO 52764
// side := mc_sides [ base ] ;
52251: LD_ADDR_VAR 0 6
52255: PUSH
52256: LD_EXP 105
52260: PUSH
52261: LD_VAR 0 1
52265: ARRAY
52266: ST_TO_ADDR
// if not side then
52267: LD_VAR 0 6
52271: NOT
52272: IFFALSE 52276
// exit ;
52274: GO 52764
// for i in solds do
52276: LD_ADDR_VAR 0 7
52280: PUSH
52281: LD_VAR 0 2
52285: PUSH
52286: FOR_IN
52287: IFFALSE 52348
// if GetBType ( IsInUnit ( i ) ) in [ b_bunker , b_breastwork ] then
52289: LD_VAR 0 7
52293: PPUSH
52294: CALL_OW 310
52298: PPUSH
52299: CALL_OW 266
52303: PUSH
52304: LD_INT 32
52306: PUSH
52307: LD_INT 31
52309: PUSH
52310: EMPTY
52311: LIST
52312: LIST
52313: IN
52314: IFFALSE 52334
// solds := solds diff i else
52316: LD_ADDR_VAR 0 2
52320: PUSH
52321: LD_VAR 0 2
52325: PUSH
52326: LD_VAR 0 7
52330: DIFF
52331: ST_TO_ADDR
52332: GO 52346
// SetTag ( i , 18 ) ;
52334: LD_VAR 0 7
52338: PPUSH
52339: LD_INT 18
52341: PPUSH
52342: CALL_OW 109
52346: GO 52286
52348: POP
52349: POP
// if not solds then
52350: LD_VAR 0 2
52354: NOT
52355: IFFALSE 52359
// exit ;
52357: GO 52764
// repeat wait ( 0 0$1 ) ;
52359: LD_INT 35
52361: PPUSH
52362: CALL_OW 67
// enemy := ScanBase ( side , area ) ;
52366: LD_ADDR_VAR 0 5
52370: PUSH
52371: LD_VAR 0 6
52375: PPUSH
52376: LD_VAR 0 3
52380: PPUSH
52381: CALL 52173 0 2
52385: ST_TO_ADDR
// if not mc_bases [ base ] or mc_bases [ base ] = [ ] then
52386: LD_EXP 79
52390: PUSH
52391: LD_VAR 0 1
52395: ARRAY
52396: NOT
52397: PUSH
52398: LD_EXP 79
52402: PUSH
52403: LD_VAR 0 1
52407: ARRAY
52408: PUSH
52409: EMPTY
52410: EQUAL
52411: OR
52412: IFFALSE 52449
// begin for i in solds do
52414: LD_ADDR_VAR 0 7
52418: PUSH
52419: LD_VAR 0 2
52423: PUSH
52424: FOR_IN
52425: IFFALSE 52438
// ComStop ( i ) ;
52427: LD_VAR 0 7
52431: PPUSH
52432: CALL_OW 141
52436: GO 52424
52438: POP
52439: POP
// solds := [ ] ;
52440: LD_ADDR_VAR 0 2
52444: PUSH
52445: EMPTY
52446: ST_TO_ADDR
// exit ;
52447: GO 52764
// end ; if not enemy or enemy > 3 or mc_defender [ base ] then
52449: LD_VAR 0 5
52453: NOT
52454: PUSH
52455: LD_VAR 0 5
52459: PUSH
52460: LD_INT 3
52462: GREATER
52463: OR
52464: PUSH
52465: LD_EXP 101
52469: PUSH
52470: LD_VAR 0 1
52474: ARRAY
52475: OR
52476: IFFALSE 52517
// begin for i in solds do
52478: LD_ADDR_VAR 0 7
52482: PUSH
52483: LD_VAR 0 2
52487: PUSH
52488: FOR_IN
52489: IFFALSE 52513
// if HasTask ( i ) then
52491: LD_VAR 0 7
52495: PPUSH
52496: CALL_OW 314
52500: IFFALSE 52511
// ComStop ( i ) ;
52502: LD_VAR 0 7
52506: PPUSH
52507: CALL_OW 141
52511: GO 52488
52513: POP
52514: POP
// break ;
52515: GO 52752
// end ; for i in solds do
52517: LD_ADDR_VAR 0 7
52521: PUSH
52522: LD_VAR 0 2
52526: PUSH
52527: FOR_IN
52528: IFFALSE 52744
// begin if IsInUnit ( i ) then
52530: LD_VAR 0 7
52534: PPUSH
52535: CALL_OW 310
52539: IFFALSE 52550
// ComExitBuilding ( i ) ;
52541: LD_VAR 0 7
52545: PPUSH
52546: CALL_OW 122
// if GetLives ( i ) > 333 then
52550: LD_VAR 0 7
52554: PPUSH
52555: CALL_OW 256
52559: PUSH
52560: LD_INT 333
52562: GREATER
52563: IFFALSE 52591
// ComAttackUnit ( i , NearestUnitToUnit ( enemy , i ) ) else
52565: LD_VAR 0 7
52569: PPUSH
52570: LD_VAR 0 5
52574: PPUSH
52575: LD_VAR 0 7
52579: PPUSH
52580: CALL_OW 74
52584: PPUSH
52585: CALL_OW 115
52589: GO 52742
// begin hex := NearestUnitToUnit ( UnitFilter ( mc_bases [ base ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] , [ f_btype , b_lab ] ] ) , i ) ;
52591: LD_ADDR_VAR 0 8
52595: PUSH
52596: LD_EXP 79
52600: PUSH
52601: LD_VAR 0 1
52605: ARRAY
52606: PPUSH
52607: LD_INT 2
52609: PUSH
52610: LD_INT 30
52612: PUSH
52613: LD_INT 0
52615: PUSH
52616: EMPTY
52617: LIST
52618: LIST
52619: PUSH
52620: LD_INT 30
52622: PUSH
52623: LD_INT 1
52625: PUSH
52626: EMPTY
52627: LIST
52628: LIST
52629: PUSH
52630: LD_INT 30
52632: PUSH
52633: LD_INT 6
52635: PUSH
52636: EMPTY
52637: LIST
52638: LIST
52639: PUSH
52640: EMPTY
52641: LIST
52642: LIST
52643: LIST
52644: LIST
52645: PPUSH
52646: CALL_OW 72
52650: PPUSH
52651: LD_VAR 0 7
52655: PPUSH
52656: CALL_OW 74
52660: ST_TO_ADDR
// ComMoveXY ( i , ShiftX ( GetX ( hex ) , 3 , 5 ) , ShiftY ( GetY ( hex ) , 3 , 5 ) ) ;
52661: LD_VAR 0 7
52665: PPUSH
52666: LD_VAR 0 8
52670: PPUSH
52671: CALL_OW 250
52675: PPUSH
52676: LD_INT 3
52678: PPUSH
52679: LD_INT 5
52681: PPUSH
52682: CALL_OW 272
52686: PPUSH
52687: LD_VAR 0 8
52691: PPUSH
52692: CALL_OW 251
52696: PPUSH
52697: LD_INT 3
52699: PPUSH
52700: LD_INT 5
52702: PPUSH
52703: CALL_OW 273
52707: PPUSH
52708: CALL_OW 111
// SetTag ( i , 0 ) ;
52712: LD_VAR 0 7
52716: PPUSH
52717: LD_INT 0
52719: PPUSH
52720: CALL_OW 109
// solds := solds diff i ;
52724: LD_ADDR_VAR 0 2
52728: PUSH
52729: LD_VAR 0 2
52733: PUSH
52734: LD_VAR 0 7
52738: DIFF
52739: ST_TO_ADDR
// continue ;
52740: GO 52527
// end ; end ;
52742: GO 52527
52744: POP
52745: POP
// until solds ;
52746: LD_VAR 0 2
52750: IFFALSE 52359
// MC_Reset ( base , 18 ) ;
52752: LD_VAR 0 1
52756: PPUSH
52757: LD_INT 18
52759: PPUSH
52760: CALL 24585 0 2
// end ;
52764: LD_VAR 0 4
52768: RET
// export function Defend ( base , defenders , enemy ) ; var i , j , x , depot , solds , mech , un , tmp , mechs , e , fac , components , depot_under_attack , sold_defenders , b , can_defend ; begin
52769: LD_INT 0
52771: PPUSH
52772: PPUSH
52773: PPUSH
52774: PPUSH
52775: PPUSH
52776: PPUSH
52777: PPUSH
52778: PPUSH
52779: PPUSH
52780: PPUSH
52781: PPUSH
52782: PPUSH
52783: PPUSH
52784: PPUSH
52785: PPUSH
52786: PPUSH
52787: PPUSH
// mechs := UnitFilter ( mc_bases [ base ] , [ f_class , 3 ] ) ;
52788: LD_ADDR_VAR 0 13
52792: PUSH
52793: LD_EXP 79
52797: PUSH
52798: LD_VAR 0 1
52802: ARRAY
52803: PPUSH
52804: LD_INT 25
52806: PUSH
52807: LD_INT 3
52809: PUSH
52810: EMPTY
52811: LIST
52812: LIST
52813: PPUSH
52814: CALL_OW 72
52818: ST_TO_ADDR
// if mc_remote_driver [ base ] then
52819: LD_EXP 119
52823: PUSH
52824: LD_VAR 0 1
52828: ARRAY
52829: IFFALSE 52853
// mechs := mechs diff mc_remote_driver [ base ] ;
52831: LD_ADDR_VAR 0 13
52835: PUSH
52836: LD_VAR 0 13
52840: PUSH
52841: LD_EXP 119
52845: PUSH
52846: LD_VAR 0 1
52850: ARRAY
52851: DIFF
52852: ST_TO_ADDR
// for i in mechs do
52853: LD_ADDR_VAR 0 5
52857: PUSH
52858: LD_VAR 0 13
52862: PUSH
52863: FOR_IN
52864: IFFALSE 52899
// if GetTag ( i ) > 0 then
52866: LD_VAR 0 5
52870: PPUSH
52871: CALL_OW 110
52875: PUSH
52876: LD_INT 0
52878: GREATER
52879: IFFALSE 52897
// mechs := mechs diff i ;
52881: LD_ADDR_VAR 0 13
52885: PUSH
52886: LD_VAR 0 13
52890: PUSH
52891: LD_VAR 0 5
52895: DIFF
52896: ST_TO_ADDR
52897: GO 52863
52899: POP
52900: POP
// solds := UnitFilter ( mc_bases [ base ] , [ f_or , [ f_class , 1 ] , [ f_class , 5 ] , [ f_class , 8 ] , [ f_class , 9 ] ] ) ;
52901: LD_ADDR_VAR 0 9
52905: PUSH
52906: LD_EXP 79
52910: PUSH
52911: LD_VAR 0 1
52915: ARRAY
52916: PPUSH
52917: LD_INT 2
52919: PUSH
52920: LD_INT 25
52922: PUSH
52923: LD_INT 1
52925: PUSH
52926: EMPTY
52927: LIST
52928: LIST
52929: PUSH
52930: LD_INT 25
52932: PUSH
52933: LD_INT 5
52935: PUSH
52936: EMPTY
52937: LIST
52938: LIST
52939: PUSH
52940: LD_INT 25
52942: PUSH
52943: LD_INT 8
52945: PUSH
52946: EMPTY
52947: LIST
52948: LIST
52949: PUSH
52950: LD_INT 25
52952: PUSH
52953: LD_INT 9
52955: PUSH
52956: EMPTY
52957: LIST
52958: LIST
52959: PUSH
52960: EMPTY
52961: LIST
52962: LIST
52963: LIST
52964: LIST
52965: LIST
52966: PPUSH
52967: CALL_OW 72
52971: ST_TO_ADDR
// if not defenders and not solds then
52972: LD_VAR 0 2
52976: NOT
52977: PUSH
52978: LD_VAR 0 9
52982: NOT
52983: AND
52984: IFFALSE 52988
// exit ;
52986: GO 54614
// depot_under_attack := false ;
52988: LD_ADDR_VAR 0 17
52992: PUSH
52993: LD_INT 0
52995: ST_TO_ADDR
// sold_defenders := [ ] ;
52996: LD_ADDR_VAR 0 18
53000: PUSH
53001: EMPTY
53002: ST_TO_ADDR
// if mechs then
53003: LD_VAR 0 13
53007: IFFALSE 53136
// for i in defenders do
53009: LD_ADDR_VAR 0 5
53013: PUSH
53014: LD_VAR 0 2
53018: PUSH
53019: FOR_IN
53020: IFFALSE 53134
// begin SetTag ( i , 20 ) ;
53022: LD_VAR 0 5
53026: PPUSH
53027: LD_INT 20
53029: PPUSH
53030: CALL_OW 109
// if GetControl ( i ) = control_manual and not IsDrivenBy ( i ) and mechs then
53034: LD_VAR 0 5
53038: PPUSH
53039: CALL_OW 263
53043: PUSH
53044: LD_INT 1
53046: EQUAL
53047: PUSH
53048: LD_VAR 0 5
53052: PPUSH
53053: CALL_OW 311
53057: NOT
53058: AND
53059: PUSH
53060: LD_VAR 0 13
53064: AND
53065: IFFALSE 53132
// begin un := mechs [ 1 ] ;
53067: LD_ADDR_VAR 0 11
53071: PUSH
53072: LD_VAR 0 13
53076: PUSH
53077: LD_INT 1
53079: ARRAY
53080: ST_TO_ADDR
// ComExitBuilding ( un ) ;
53081: LD_VAR 0 11
53085: PPUSH
53086: CALL_OW 122
// AddComEnterUnit ( un , i ) ;
53090: LD_VAR 0 11
53094: PPUSH
53095: LD_VAR 0 5
53099: PPUSH
53100: CALL_OW 180
// SetTag ( un , 19 ) ;
53104: LD_VAR 0 11
53108: PPUSH
53109: LD_INT 19
53111: PPUSH
53112: CALL_OW 109
// mechs := mechs diff un ;
53116: LD_ADDR_VAR 0 13
53120: PUSH
53121: LD_VAR 0 13
53125: PUSH
53126: LD_VAR 0 11
53130: DIFF
53131: ST_TO_ADDR
// end ; end ;
53132: GO 53019
53134: POP
53135: POP
// if solds then
53136: LD_VAR 0 9
53140: IFFALSE 53199
// for i in solds do
53142: LD_ADDR_VAR 0 5
53146: PUSH
53147: LD_VAR 0 9
53151: PUSH
53152: FOR_IN
53153: IFFALSE 53197
// if not GetTag ( i ) then
53155: LD_VAR 0 5
53159: PPUSH
53160: CALL_OW 110
53164: NOT
53165: IFFALSE 53195
// begin defenders := defenders union i ;
53167: LD_ADDR_VAR 0 2
53171: PUSH
53172: LD_VAR 0 2
53176: PUSH
53177: LD_VAR 0 5
53181: UNION
53182: ST_TO_ADDR
// SetTag ( i , 18 ) ;
53183: LD_VAR 0 5
53187: PPUSH
53188: LD_INT 18
53190: PPUSH
53191: CALL_OW 109
// end ;
53195: GO 53152
53197: POP
53198: POP
// repeat wait ( 0 0$1 ) ;
53199: LD_INT 35
53201: PPUSH
53202: CALL_OW 67
// enemy := mc_scan [ base ] ;
53206: LD_ADDR_VAR 0 3
53210: PUSH
53211: LD_EXP 102
53215: PUSH
53216: LD_VAR 0 1
53220: ARRAY
53221: ST_TO_ADDR
// if not mc_bases [ base ] or mc_bases [ base ] = [ ] then
53222: LD_EXP 79
53226: PUSH
53227: LD_VAR 0 1
53231: ARRAY
53232: NOT
53233: PUSH
53234: LD_EXP 79
53238: PUSH
53239: LD_VAR 0 1
53243: ARRAY
53244: PUSH
53245: EMPTY
53246: EQUAL
53247: OR
53248: IFFALSE 53285
// begin for i in defenders do
53250: LD_ADDR_VAR 0 5
53254: PUSH
53255: LD_VAR 0 2
53259: PUSH
53260: FOR_IN
53261: IFFALSE 53274
// ComStop ( i ) ;
53263: LD_VAR 0 5
53267: PPUSH
53268: CALL_OW 141
53272: GO 53260
53274: POP
53275: POP
// defenders := [ ] ;
53276: LD_ADDR_VAR 0 2
53280: PUSH
53281: EMPTY
53282: ST_TO_ADDR
// exit ;
53283: GO 54614
// end ; for i in defenders do
53285: LD_ADDR_VAR 0 5
53289: PUSH
53290: LD_VAR 0 2
53294: PUSH
53295: FOR_IN
53296: IFFALSE 54114
// begin e := NearestUnitToUnit ( enemy , i ) ;
53298: LD_ADDR_VAR 0 14
53302: PUSH
53303: LD_VAR 0 3
53307: PPUSH
53308: LD_VAR 0 5
53312: PPUSH
53313: CALL_OW 74
53317: ST_TO_ADDR
// depot := UnitFilter ( mc_bases [ base ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) ;
53318: LD_ADDR_VAR 0 8
53322: PUSH
53323: LD_EXP 79
53327: PUSH
53328: LD_VAR 0 1
53332: ARRAY
53333: PPUSH
53334: LD_INT 2
53336: PUSH
53337: LD_INT 30
53339: PUSH
53340: LD_INT 0
53342: PUSH
53343: EMPTY
53344: LIST
53345: LIST
53346: PUSH
53347: LD_INT 30
53349: PUSH
53350: LD_INT 1
53352: PUSH
53353: EMPTY
53354: LIST
53355: LIST
53356: PUSH
53357: EMPTY
53358: LIST
53359: LIST
53360: LIST
53361: PPUSH
53362: CALL_OW 72
53366: ST_TO_ADDR
// depot_under_attack := ( not depot or UnitFilter ( depot , [ f_not , [ f_lives , 600 ] ] ) ) ;
53367: LD_ADDR_VAR 0 17
53371: PUSH
53372: LD_VAR 0 8
53376: NOT
53377: PUSH
53378: LD_VAR 0 8
53382: PPUSH
53383: LD_INT 3
53385: PUSH
53386: LD_INT 24
53388: PUSH
53389: LD_INT 600
53391: PUSH
53392: EMPTY
53393: LIST
53394: LIST
53395: PUSH
53396: EMPTY
53397: LIST
53398: LIST
53399: PPUSH
53400: CALL_OW 72
53404: OR
53405: ST_TO_ADDR
// case GetType ( i ) of unit_vehicle :
53406: LD_VAR 0 5
53410: PPUSH
53411: CALL_OW 247
53415: PUSH
53416: LD_INT 2
53418: DOUBLE
53419: EQUAL
53420: IFTRUE 53424
53422: GO 53820
53424: POP
// begin if GetLives ( i ) > 650 and ( GetDistUnits ( i , e ) < 40 or IsInArea ( e , mc_scan_area [ base ] ) ) then
53425: LD_VAR 0 5
53429: PPUSH
53430: CALL_OW 256
53434: PUSH
53435: LD_INT 650
53437: GREATER
53438: PUSH
53439: LD_VAR 0 5
53443: PPUSH
53444: LD_VAR 0 14
53448: PPUSH
53449: CALL_OW 296
53453: PUSH
53454: LD_INT 40
53456: LESS
53457: PUSH
53458: LD_VAR 0 14
53462: PPUSH
53463: LD_EXP 104
53467: PUSH
53468: LD_VAR 0 1
53472: ARRAY
53473: PPUSH
53474: CALL_OW 308
53478: OR
53479: AND
53480: IFFALSE 53602
// begin if GetEngine ( i ) = engine_combustion and GetFuel ( i ) < 30 and depot then
53482: LD_VAR 0 5
53486: PPUSH
53487: CALL_OW 262
53491: PUSH
53492: LD_INT 1
53494: EQUAL
53495: PUSH
53496: LD_VAR 0 5
53500: PPUSH
53501: CALL_OW 261
53505: PUSH
53506: LD_INT 30
53508: LESS
53509: AND
53510: PUSH
53511: LD_VAR 0 8
53515: AND
53516: IFFALSE 53586
// begin ComMoveUnit ( i , NearestUnitToUnit ( depot , i ) ) ;
53518: LD_VAR 0 5
53522: PPUSH
53523: LD_VAR 0 8
53527: PPUSH
53528: LD_VAR 0 5
53532: PPUSH
53533: CALL_OW 74
53537: PPUSH
53538: CALL_OW 112
// if GetDistUnits ( i , NearestUnitToUnit ( depot , i ) ) < 6 then
53542: LD_VAR 0 5
53546: PPUSH
53547: LD_VAR 0 8
53551: PPUSH
53552: LD_VAR 0 5
53556: PPUSH
53557: CALL_OW 74
53561: PPUSH
53562: CALL_OW 296
53566: PUSH
53567: LD_INT 6
53569: LESS
53570: IFFALSE 53584
// SetFuel ( i , 100 ) ;
53572: LD_VAR 0 5
53576: PPUSH
53577: LD_INT 100
53579: PPUSH
53580: CALL_OW 240
// end else
53584: GO 53600
// ComAttackUnit ( i , e ) ;
53586: LD_VAR 0 5
53590: PPUSH
53591: LD_VAR 0 14
53595: PPUSH
53596: CALL_OW 115
// end else
53600: GO 53703
// if ( ( not IsInArea ( e , mc_scan_area [ base ] ) and GetDistUnits ( i , e ) >= 40 ) or GetLives ( i ) <= 650 ) and not IsInArea ( i , mc_parking [ base ] ) then
53602: LD_VAR 0 14
53606: PPUSH
53607: LD_EXP 104
53611: PUSH
53612: LD_VAR 0 1
53616: ARRAY
53617: PPUSH
53618: CALL_OW 308
53622: NOT
53623: PUSH
53624: LD_VAR 0 5
53628: PPUSH
53629: LD_VAR 0 14
53633: PPUSH
53634: CALL_OW 296
53638: PUSH
53639: LD_INT 40
53641: GREATEREQUAL
53642: AND
53643: PUSH
53644: LD_VAR 0 5
53648: PPUSH
53649: CALL_OW 256
53653: PUSH
53654: LD_INT 650
53656: LESSEQUAL
53657: OR
53658: PUSH
53659: LD_VAR 0 5
53663: PPUSH
53664: LD_EXP 103
53668: PUSH
53669: LD_VAR 0 1
53673: ARRAY
53674: PPUSH
53675: CALL_OW 308
53679: NOT
53680: AND
53681: IFFALSE 53703
// ComMoveToArea ( i , mc_parking [ base ] ) ;
53683: LD_VAR 0 5
53687: PPUSH
53688: LD_EXP 103
53692: PUSH
53693: LD_VAR 0 1
53697: ARRAY
53698: PPUSH
53699: CALL_OW 113
// if GetLives ( i ) < 998 and GetControl ( i ) = control_manual and IsDrivenBy ( i ) and IsInArea ( i , mc_parking [ base ] ) then
53703: LD_VAR 0 5
53707: PPUSH
53708: CALL_OW 256
53712: PUSH
53713: LD_INT 998
53715: LESS
53716: PUSH
53717: LD_VAR 0 5
53721: PPUSH
53722: CALL_OW 263
53726: PUSH
53727: LD_INT 1
53729: EQUAL
53730: AND
53731: PUSH
53732: LD_VAR 0 5
53736: PPUSH
53737: CALL_OW 311
53741: AND
53742: PUSH
53743: LD_VAR 0 5
53747: PPUSH
53748: LD_EXP 103
53752: PUSH
53753: LD_VAR 0 1
53757: ARRAY
53758: PPUSH
53759: CALL_OW 308
53763: AND
53764: IFFALSE 53818
// begin mech := IsDrivenBy ( i ) ;
53766: LD_ADDR_VAR 0 10
53770: PUSH
53771: LD_VAR 0 5
53775: PPUSH
53776: CALL_OW 311
53780: ST_TO_ADDR
// ComExitVehicle ( mech ) ;
53781: LD_VAR 0 10
53785: PPUSH
53786: CALL_OW 121
// AddComRepairVehicle ( mech , i ) ;
53790: LD_VAR 0 10
53794: PPUSH
53795: LD_VAR 0 5
53799: PPUSH
53800: CALL_OW 189
// AddComEnterUnit ( mech , i ) ;
53804: LD_VAR 0 10
53808: PPUSH
53809: LD_VAR 0 5
53813: PPUSH
53814: CALL_OW 180
// end ; end ; unit_human :
53818: GO 54085
53820: LD_INT 1
53822: DOUBLE
53823: EQUAL
53824: IFTRUE 53828
53826: GO 54084
53828: POP
// begin b := IsInUnit ( i ) ;
53829: LD_ADDR_VAR 0 19
53833: PUSH
53834: LD_VAR 0 5
53838: PPUSH
53839: CALL_OW 310
53843: ST_TO_ADDR
// can_defend := ( not b or GetBType ( b ) in [ b_bunker , b_breastwork ] ) ;
53844: LD_ADDR_VAR 0 20
53848: PUSH
53849: LD_VAR 0 19
53853: NOT
53854: PUSH
53855: LD_VAR 0 19
53859: PPUSH
53860: CALL_OW 266
53864: PUSH
53865: LD_INT 32
53867: PUSH
53868: LD_INT 31
53870: PUSH
53871: EMPTY
53872: LIST
53873: LIST
53874: IN
53875: OR
53876: ST_TO_ADDR
// if ( depot_under_attack or UnitFilter ( defenders , [ f_type , unit_vehicle ] ) <= 1 ) and can_defend and not i in sold_defenders then
53877: LD_VAR 0 17
53881: PUSH
53882: LD_VAR 0 2
53886: PPUSH
53887: LD_INT 21
53889: PUSH
53890: LD_INT 2
53892: PUSH
53893: EMPTY
53894: LIST
53895: LIST
53896: PPUSH
53897: CALL_OW 72
53901: PUSH
53902: LD_INT 1
53904: LESSEQUAL
53905: OR
53906: PUSH
53907: LD_VAR 0 20
53911: AND
53912: PUSH
53913: LD_VAR 0 5
53917: PUSH
53918: LD_VAR 0 18
53922: IN
53923: NOT
53924: AND
53925: IFFALSE 54018
// begin if b then
53927: LD_VAR 0 19
53931: IFFALSE 53980
// if GetDistUnits ( b , NearestUnitToUnit ( enemy , b ) ) < 10 and BuildingStatus ( b ) <> bs_need_power then
53933: LD_VAR 0 19
53937: PPUSH
53938: LD_VAR 0 3
53942: PPUSH
53943: LD_VAR 0 19
53947: PPUSH
53948: CALL_OW 74
53952: PPUSH
53953: CALL_OW 296
53957: PUSH
53958: LD_INT 10
53960: LESS
53961: PUSH
53962: LD_VAR 0 19
53966: PPUSH
53967: CALL_OW 461
53971: PUSH
53972: LD_INT 7
53974: NONEQUAL
53975: AND
53976: IFFALSE 53980
// continue ;
53978: GO 53295
// sold_defenders := Replace ( sold_defenders , sold_defenders + 1 , i ) ;
53980: LD_ADDR_VAR 0 18
53984: PUSH
53985: LD_VAR 0 18
53989: PPUSH
53990: LD_VAR 0 18
53994: PUSH
53995: LD_INT 1
53997: PLUS
53998: PPUSH
53999: LD_VAR 0 5
54003: PPUSH
54004: CALL_OW 1
54008: ST_TO_ADDR
// ComExitBuilding ( i ) ;
54009: LD_VAR 0 5
54013: PPUSH
54014: CALL_OW 122
// end ; if sold_defenders then
54018: LD_VAR 0 18
54022: IFFALSE 54082
// if i in sold_defenders then
54024: LD_VAR 0 5
54028: PUSH
54029: LD_VAR 0 18
54033: IN
54034: IFFALSE 54082
// begin if not HasTask ( i ) and GetDistUnits ( i , e ) < 30 then
54036: LD_VAR 0 5
54040: PPUSH
54041: CALL_OW 314
54045: NOT
54046: PUSH
54047: LD_VAR 0 5
54051: PPUSH
54052: LD_VAR 0 14
54056: PPUSH
54057: CALL_OW 296
54061: PUSH
54062: LD_INT 30
54064: LESS
54065: AND
54066: IFFALSE 54082
// ComAttackUnit ( i , e ) ;
54068: LD_VAR 0 5
54072: PPUSH
54073: LD_VAR 0 14
54077: PPUSH
54078: CALL_OW 115
// end ; end ; end ;
54082: GO 54085
54084: POP
// if IsDead ( i ) then
54085: LD_VAR 0 5
54089: PPUSH
54090: CALL_OW 301
54094: IFFALSE 54112
// defenders := defenders diff i ;
54096: LD_ADDR_VAR 0 2
54100: PUSH
54101: LD_VAR 0 2
54105: PUSH
54106: LD_VAR 0 5
54110: DIFF
54111: ST_TO_ADDR
// end ;
54112: GO 53295
54114: POP
54115: POP
// until not enemy or not defenders or not mc_bases [ base ] ;
54116: LD_VAR 0 3
54120: NOT
54121: PUSH
54122: LD_VAR 0 2
54126: NOT
54127: OR
54128: PUSH
54129: LD_EXP 79
54133: PUSH
54134: LD_VAR 0 1
54138: ARRAY
54139: NOT
54140: OR
54141: IFFALSE 53199
// MC_Reset ( base , 18 ) ;
54143: LD_VAR 0 1
54147: PPUSH
54148: LD_INT 18
54150: PPUSH
54151: CALL 24585 0 2
// defenders := defenders diff UnitFilter ( defenders , [ f_or , [ f_class , 1 ] , [ f_class , 5 ] , [ f_class , 8 ] , [ f_class , 9 ] ] ) ;
54155: LD_ADDR_VAR 0 2
54159: PUSH
54160: LD_VAR 0 2
54164: PUSH
54165: LD_VAR 0 2
54169: PPUSH
54170: LD_INT 2
54172: PUSH
54173: LD_INT 25
54175: PUSH
54176: LD_INT 1
54178: PUSH
54179: EMPTY
54180: LIST
54181: LIST
54182: PUSH
54183: LD_INT 25
54185: PUSH
54186: LD_INT 5
54188: PUSH
54189: EMPTY
54190: LIST
54191: LIST
54192: PUSH
54193: LD_INT 25
54195: PUSH
54196: LD_INT 8
54198: PUSH
54199: EMPTY
54200: LIST
54201: LIST
54202: PUSH
54203: LD_INT 25
54205: PUSH
54206: LD_INT 9
54208: PUSH
54209: EMPTY
54210: LIST
54211: LIST
54212: PUSH
54213: EMPTY
54214: LIST
54215: LIST
54216: LIST
54217: LIST
54218: LIST
54219: PPUSH
54220: CALL_OW 72
54224: DIFF
54225: ST_TO_ADDR
// if not enemy and UnitFilter ( defenders , [ f_type , unit_vehicle ] ) then
54226: LD_VAR 0 3
54230: NOT
54231: PUSH
54232: LD_VAR 0 2
54236: PPUSH
54237: LD_INT 21
54239: PUSH
54240: LD_INT 2
54242: PUSH
54243: EMPTY
54244: LIST
54245: LIST
54246: PPUSH
54247: CALL_OW 72
54251: AND
54252: IFFALSE 54590
// begin tmp := FilterByTag ( defenders , 19 ) ;
54254: LD_ADDR_VAR 0 12
54258: PUSH
54259: LD_VAR 0 2
54263: PPUSH
54264: LD_INT 19
54266: PPUSH
54267: CALL 91053 0 2
54271: ST_TO_ADDR
// if tmp then
54272: LD_VAR 0 12
54276: IFFALSE 54346
// begin tmp := UnitFilter ( tmp , [ f_class , 3 ] ) ;
54278: LD_ADDR_VAR 0 12
54282: PUSH
54283: LD_VAR 0 12
54287: PPUSH
54288: LD_INT 25
54290: PUSH
54291: LD_INT 3
54293: PUSH
54294: EMPTY
54295: LIST
54296: LIST
54297: PPUSH
54298: CALL_OW 72
54302: ST_TO_ADDR
// if tmp then
54303: LD_VAR 0 12
54307: IFFALSE 54346
// mc_repair_vehicle := Replace ( mc_repair_vehicle , base , mc_repair_vehicle [ base ] union tmp ) ;
54309: LD_ADDR_EXP 91
54313: PUSH
54314: LD_EXP 91
54318: PPUSH
54319: LD_VAR 0 1
54323: PPUSH
54324: LD_EXP 91
54328: PUSH
54329: LD_VAR 0 1
54333: ARRAY
54334: PUSH
54335: LD_VAR 0 12
54339: UNION
54340: PPUSH
54341: CALL_OW 1
54345: ST_TO_ADDR
// end ; MC_Reset ( base , 19 ) ;
54346: LD_VAR 0 1
54350: PPUSH
54351: LD_INT 19
54353: PPUSH
54354: CALL 24585 0 2
// repeat wait ( 0 0$1 ) ;
54358: LD_INT 35
54360: PPUSH
54361: CALL_OW 67
// if not mc_bases [ base ] or mc_bases [ base ] = [ ] then
54365: LD_EXP 79
54369: PUSH
54370: LD_VAR 0 1
54374: ARRAY
54375: NOT
54376: PUSH
54377: LD_EXP 79
54381: PUSH
54382: LD_VAR 0 1
54386: ARRAY
54387: PUSH
54388: EMPTY
54389: EQUAL
54390: OR
54391: IFFALSE 54428
// begin for i in defenders do
54393: LD_ADDR_VAR 0 5
54397: PUSH
54398: LD_VAR 0 2
54402: PUSH
54403: FOR_IN
54404: IFFALSE 54417
// ComStop ( i ) ;
54406: LD_VAR 0 5
54410: PPUSH
54411: CALL_OW 141
54415: GO 54403
54417: POP
54418: POP
// defenders := [ ] ;
54419: LD_ADDR_VAR 0 2
54423: PUSH
54424: EMPTY
54425: ST_TO_ADDR
// exit ;
54426: GO 54614
// end ; for i in defenders do
54428: LD_ADDR_VAR 0 5
54432: PUSH
54433: LD_VAR 0 2
54437: PUSH
54438: FOR_IN
54439: IFFALSE 54528
// begin if not IsInArea ( i , mc_parking [ base ] ) then
54441: LD_VAR 0 5
54445: PPUSH
54446: LD_EXP 103
54450: PUSH
54451: LD_VAR 0 1
54455: ARRAY
54456: PPUSH
54457: CALL_OW 308
54461: NOT
54462: IFFALSE 54486
// ComMoveToArea ( i , mc_parking [ base ] ) else
54464: LD_VAR 0 5
54468: PPUSH
54469: LD_EXP 103
54473: PUSH
54474: LD_VAR 0 1
54478: ARRAY
54479: PPUSH
54480: CALL_OW 113
54484: GO 54526
// if GetControl ( i ) = control_manual then
54486: LD_VAR 0 5
54490: PPUSH
54491: CALL_OW 263
54495: PUSH
54496: LD_INT 1
54498: EQUAL
54499: IFFALSE 54526
// if IsDrivenBy ( i ) then
54501: LD_VAR 0 5
54505: PPUSH
54506: CALL_OW 311
54510: IFFALSE 54526
// ComExitVehicle ( IsDrivenBy ( i ) ) ;
54512: LD_VAR 0 5
54516: PPUSH
54517: CALL_OW 311
54521: PPUSH
54522: CALL_OW 121
// end ;
54526: GO 54438
54528: POP
54529: POP
// until UnitFilter ( defenders , [ f_inarea , mc_parking [ base ] ] ) = defenders or mc_scan [ base ] or not mc_bases [ base ] ;
54530: LD_VAR 0 2
54534: PPUSH
54535: LD_INT 95
54537: PUSH
54538: LD_EXP 103
54542: PUSH
54543: LD_VAR 0 1
54547: ARRAY
54548: PUSH
54549: EMPTY
54550: LIST
54551: LIST
54552: PPUSH
54553: CALL_OW 72
54557: PUSH
54558: LD_VAR 0 2
54562: EQUAL
54563: PUSH
54564: LD_EXP 102
54568: PUSH
54569: LD_VAR 0 1
54573: ARRAY
54574: OR
54575: PUSH
54576: LD_EXP 79
54580: PUSH
54581: LD_VAR 0 1
54585: ARRAY
54586: NOT
54587: OR
54588: IFFALSE 54358
// end ; MC_Reset ( base , 19 ) ;
54590: LD_VAR 0 1
54594: PPUSH
54595: LD_INT 19
54597: PPUSH
54598: CALL 24585 0 2
// MC_Reset ( base , 20 ) ;
54602: LD_VAR 0 1
54606: PPUSH
54607: LD_INT 20
54609: PPUSH
54610: CALL 24585 0 2
// end ;
54614: LD_VAR 0 4
54618: RET
// export function AllowSpecClass ( unit ) ; var side , nat , tech ; begin
54619: LD_INT 0
54621: PPUSH
54622: PPUSH
54623: PPUSH
54624: PPUSH
// result := false ;
54625: LD_ADDR_VAR 0 2
54629: PUSH
54630: LD_INT 0
54632: ST_TO_ADDR
// side := GetSide ( unit ) ;
54633: LD_ADDR_VAR 0 3
54637: PUSH
54638: LD_VAR 0 1
54642: PPUSH
54643: CALL_OW 255
54647: ST_TO_ADDR
// nat := GetNation ( unit ) ;
54648: LD_ADDR_VAR 0 4
54652: PUSH
54653: LD_VAR 0 1
54657: PPUSH
54658: CALL_OW 248
54662: ST_TO_ADDR
// case nat of 1 :
54663: LD_VAR 0 4
54667: PUSH
54668: LD_INT 1
54670: DOUBLE
54671: EQUAL
54672: IFTRUE 54676
54674: GO 54687
54676: POP
// tech := tech_lassight ; 2 :
54677: LD_ADDR_VAR 0 5
54681: PUSH
54682: LD_INT 12
54684: ST_TO_ADDR
54685: GO 54726
54687: LD_INT 2
54689: DOUBLE
54690: EQUAL
54691: IFTRUE 54695
54693: GO 54706
54695: POP
// tech := tech_mortar ; 3 :
54696: LD_ADDR_VAR 0 5
54700: PUSH
54701: LD_INT 41
54703: ST_TO_ADDR
54704: GO 54726
54706: LD_INT 3
54708: DOUBLE
54709: EQUAL
54710: IFTRUE 54714
54712: GO 54725
54714: POP
// tech := tech_bazooka ; end ;
54715: LD_ADDR_VAR 0 5
54719: PUSH
54720: LD_INT 44
54722: ST_TO_ADDR
54723: GO 54726
54725: POP
// if Researched ( side , tech ) then
54726: LD_VAR 0 3
54730: PPUSH
54731: LD_VAR 0 5
54735: PPUSH
54736: CALL_OW 325
54740: IFFALSE 54767
// result := [ class_sniper , class_mortar , class_bazooker ] [ nat ] ;
54742: LD_ADDR_VAR 0 2
54746: PUSH
54747: LD_INT 5
54749: PUSH
54750: LD_INT 8
54752: PUSH
54753: LD_INT 9
54755: PUSH
54756: EMPTY
54757: LIST
54758: LIST
54759: LIST
54760: PUSH
54761: LD_VAR 0 4
54765: ARRAY
54766: ST_TO_ADDR
// end ;
54767: LD_VAR 0 2
54771: RET
// export function DetonateMines ( side , mines ) ; var i , tmp ; begin
54772: LD_INT 0
54774: PPUSH
54775: PPUSH
54776: PPUSH
// if not mines then
54777: LD_VAR 0 2
54781: NOT
54782: IFFALSE 54786
// exit ;
54784: GO 54930
// tmp := FilterAllUnits ( [ [ f_enemy , side ] , [ f_not , [ f_type , unit_building ] ] ] ) ;
54786: LD_ADDR_VAR 0 5
54790: PUSH
54791: LD_INT 81
54793: PUSH
54794: LD_VAR 0 1
54798: PUSH
54799: EMPTY
54800: LIST
54801: LIST
54802: PUSH
54803: LD_INT 3
54805: PUSH
54806: LD_INT 21
54808: PUSH
54809: LD_INT 3
54811: PUSH
54812: EMPTY
54813: LIST
54814: LIST
54815: PUSH
54816: EMPTY
54817: LIST
54818: LIST
54819: PUSH
54820: EMPTY
54821: LIST
54822: LIST
54823: PPUSH
54824: CALL_OW 69
54828: ST_TO_ADDR
// for i in mines do
54829: LD_ADDR_VAR 0 4
54833: PUSH
54834: LD_VAR 0 2
54838: PUSH
54839: FOR_IN
54840: IFFALSE 54928
// begin if not MineAtPos ( i [ 1 ] , i [ 2 ] ) then
54842: LD_VAR 0 4
54846: PUSH
54847: LD_INT 1
54849: ARRAY
54850: PPUSH
54851: LD_VAR 0 4
54855: PUSH
54856: LD_INT 2
54858: ARRAY
54859: PPUSH
54860: CALL_OW 458
54864: NOT
54865: IFFALSE 54869
// continue ;
54867: GO 54839
// if HexInfo ( i [ 1 ] , i [ 2 ] ) in tmp then
54869: LD_VAR 0 4
54873: PUSH
54874: LD_INT 1
54876: ARRAY
54877: PPUSH
54878: LD_VAR 0 4
54882: PUSH
54883: LD_INT 2
54885: ARRAY
54886: PPUSH
54887: CALL_OW 428
54891: PUSH
54892: LD_VAR 0 5
54896: IN
54897: IFFALSE 54926
// LaunchMineAtPos ( i [ 1 ] , i [ 2 ] , side ) ;
54899: LD_VAR 0 4
54903: PUSH
54904: LD_INT 1
54906: ARRAY
54907: PPUSH
54908: LD_VAR 0 4
54912: PUSH
54913: LD_INT 2
54915: ARRAY
54916: PPUSH
54917: LD_VAR 0 1
54921: PPUSH
54922: CALL_OW 456
// end ;
54926: GO 54839
54928: POP
54929: POP
// end ;
54930: LD_VAR 0 3
54934: RET
// export function Count ( array ) ; var i ; begin
54935: LD_INT 0
54937: PPUSH
54938: PPUSH
// result := 0 ;
54939: LD_ADDR_VAR 0 2
54943: PUSH
54944: LD_INT 0
54946: ST_TO_ADDR
// for i in array do
54947: LD_ADDR_VAR 0 3
54951: PUSH
54952: LD_VAR 0 1
54956: PUSH
54957: FOR_IN
54958: IFFALSE 54982
// if i then
54960: LD_VAR 0 3
54964: IFFALSE 54980
// result := result + 1 ;
54966: LD_ADDR_VAR 0 2
54970: PUSH
54971: LD_VAR 0 2
54975: PUSH
54976: LD_INT 1
54978: PLUS
54979: ST_TO_ADDR
54980: GO 54957
54982: POP
54983: POP
// end ;
54984: LD_VAR 0 2
54988: RET
// export function IsEmpty ( building ) ; begin
54989: LD_INT 0
54991: PPUSH
// if not building then
54992: LD_VAR 0 1
54996: NOT
54997: IFFALSE 55001
// exit ;
54999: GO 55044
// result := building in FilterAllUnits ( [ [ f_side , GetSide ( building ) ] , [ f_empty ] ] ) ;
55001: LD_ADDR_VAR 0 2
55005: PUSH
55006: LD_VAR 0 1
55010: PUSH
55011: LD_INT 22
55013: PUSH
55014: LD_VAR 0 1
55018: PPUSH
55019: CALL_OW 255
55023: PUSH
55024: EMPTY
55025: LIST
55026: LIST
55027: PUSH
55028: LD_INT 58
55030: PUSH
55031: EMPTY
55032: LIST
55033: PUSH
55034: EMPTY
55035: LIST
55036: LIST
55037: PPUSH
55038: CALL_OW 69
55042: IN
55043: ST_TO_ADDR
// end ;
55044: LD_VAR 0 2
55048: RET
// export function IsNotFull ( building ) ; begin
55049: LD_INT 0
55051: PPUSH
// if not building then
55052: LD_VAR 0 1
55056: NOT
55057: IFFALSE 55061
// exit ;
55059: GO 55080
// result := UnitsInside ( building ) < 6 ;
55061: LD_ADDR_VAR 0 2
55065: PUSH
55066: LD_VAR 0 1
55070: PPUSH
55071: CALL_OW 313
55075: PUSH
55076: LD_INT 6
55078: LESS
55079: ST_TO_ADDR
// end ;
55080: LD_VAR 0 2
55084: RET
// export function GetFacExt ( factory ) ; var tmp , i , list ; begin
55085: LD_INT 0
55087: PPUSH
55088: PPUSH
55089: PPUSH
55090: PPUSH
// tmp := [ ] ;
55091: LD_ADDR_VAR 0 3
55095: PUSH
55096: EMPTY
55097: ST_TO_ADDR
// list := [ ] ;
55098: LD_ADDR_VAR 0 5
55102: PUSH
55103: EMPTY
55104: ST_TO_ADDR
// for i = 16 to 25 do
55105: LD_ADDR_VAR 0 4
55109: PUSH
55110: DOUBLE
55111: LD_INT 16
55113: DEC
55114: ST_TO_ADDR
55115: LD_INT 25
55117: PUSH
55118: FOR_TO
55119: IFFALSE 55192
// tmp := tmp ^ FilterAllUnits ( [ [ [ f_side , GetSide ( factory ) ] , [ f_dist , factory , 6 ] , [ f_btype , i ] ] ] ) ;
55121: LD_ADDR_VAR 0 3
55125: PUSH
55126: LD_VAR 0 3
55130: PUSH
55131: LD_INT 22
55133: PUSH
55134: LD_VAR 0 1
55138: PPUSH
55139: CALL_OW 255
55143: PUSH
55144: EMPTY
55145: LIST
55146: LIST
55147: PUSH
55148: LD_INT 91
55150: PUSH
55151: LD_VAR 0 1
55155: PUSH
55156: LD_INT 6
55158: PUSH
55159: EMPTY
55160: LIST
55161: LIST
55162: LIST
55163: PUSH
55164: LD_INT 30
55166: PUSH
55167: LD_VAR 0 4
55171: PUSH
55172: EMPTY
55173: LIST
55174: LIST
55175: PUSH
55176: EMPTY
55177: LIST
55178: LIST
55179: LIST
55180: PUSH
55181: EMPTY
55182: LIST
55183: PPUSH
55184: CALL_OW 69
55188: ADD
55189: ST_TO_ADDR
55190: GO 55118
55192: POP
55193: POP
// for i = 1 to tmp do
55194: LD_ADDR_VAR 0 4
55198: PUSH
55199: DOUBLE
55200: LD_INT 1
55202: DEC
55203: ST_TO_ADDR
55204: LD_VAR 0 3
55208: PUSH
55209: FOR_TO
55210: IFFALSE 55298
// list := list ^ [ [ GetBType ( tmp [ i ] ) , GetX ( tmp [ i ] ) , GetY ( tmp [ i ] ) , GetDir ( tmp [ i ] ) ] ] ;
55212: LD_ADDR_VAR 0 5
55216: PUSH
55217: LD_VAR 0 5
55221: PUSH
55222: LD_VAR 0 3
55226: PUSH
55227: LD_VAR 0 4
55231: ARRAY
55232: PPUSH
55233: CALL_OW 266
55237: PUSH
55238: LD_VAR 0 3
55242: PUSH
55243: LD_VAR 0 4
55247: ARRAY
55248: PPUSH
55249: CALL_OW 250
55253: PUSH
55254: LD_VAR 0 3
55258: PUSH
55259: LD_VAR 0 4
55263: ARRAY
55264: PPUSH
55265: CALL_OW 251
55269: PUSH
55270: LD_VAR 0 3
55274: PUSH
55275: LD_VAR 0 4
55279: ARRAY
55280: PPUSH
55281: CALL_OW 254
55285: PUSH
55286: EMPTY
55287: LIST
55288: LIST
55289: LIST
55290: LIST
55291: PUSH
55292: EMPTY
55293: LIST
55294: ADD
55295: ST_TO_ADDR
55296: GO 55209
55298: POP
55299: POP
// result := list ;
55300: LD_ADDR_VAR 0 2
55304: PUSH
55305: LD_VAR 0 5
55309: ST_TO_ADDR
// end ;
55310: LD_VAR 0 2
55314: RET
// export function Produce ( factory , chassis , engine , control , weapon ) ; var i , tmp , _chassis , _weapon , _engine , _control ; begin
55315: LD_INT 0
55317: PPUSH
55318: PPUSH
55319: PPUSH
55320: PPUSH
55321: PPUSH
55322: PPUSH
55323: PPUSH
// if not factory then
55324: LD_VAR 0 1
55328: NOT
55329: IFFALSE 55333
// exit ;
55331: GO 55926
// if control = control_apeman then
55333: LD_VAR 0 4
55337: PUSH
55338: LD_INT 5
55340: EQUAL
55341: IFFALSE 55450
// begin tmp := UnitsInside ( factory ) ;
55343: LD_ADDR_VAR 0 8
55347: PUSH
55348: LD_VAR 0 1
55352: PPUSH
55353: CALL_OW 313
55357: ST_TO_ADDR
// if not UnitFilter ( tmp , [ f_class , class_apeman ] ) then
55358: LD_VAR 0 8
55362: PPUSH
55363: LD_INT 25
55365: PUSH
55366: LD_INT 12
55368: PUSH
55369: EMPTY
55370: LIST
55371: LIST
55372: PPUSH
55373: CALL_OW 72
55377: NOT
55378: IFFALSE 55388
// control := control_manual ;
55380: LD_ADDR_VAR 0 4
55384: PUSH
55385: LD_INT 1
55387: ST_TO_ADDR
// tmp := GetFacExt ( factory ) ;
55388: LD_ADDR_VAR 0 8
55392: PUSH
55393: LD_VAR 0 1
55397: PPUSH
55398: CALL 55085 0 1
55402: ST_TO_ADDR
// if tmp then
55403: LD_VAR 0 8
55407: IFFALSE 55450
// begin for i in tmp do
55409: LD_ADDR_VAR 0 7
55413: PUSH
55414: LD_VAR 0 8
55418: PUSH
55419: FOR_IN
55420: IFFALSE 55448
// if i [ 1 ] = b_ext_radio then
55422: LD_VAR 0 7
55426: PUSH
55427: LD_INT 1
55429: ARRAY
55430: PUSH
55431: LD_INT 22
55433: EQUAL
55434: IFFALSE 55446
// begin control := control_remote ;
55436: LD_ADDR_VAR 0 4
55440: PUSH
55441: LD_INT 2
55443: ST_TO_ADDR
// break ;
55444: GO 55448
// end ;
55446: GO 55419
55448: POP
55449: POP
// end ; end ; if CanBeConstructed ( factory , chassis , engine , control , weapon ) then
55450: LD_VAR 0 1
55454: PPUSH
55455: LD_VAR 0 2
55459: PPUSH
55460: LD_VAR 0 3
55464: PPUSH
55465: LD_VAR 0 4
55469: PPUSH
55470: LD_VAR 0 5
55474: PPUSH
55475: CALL_OW 448
55479: IFFALSE 55514
// begin result := [ chassis , engine , control , weapon ] ;
55481: LD_ADDR_VAR 0 6
55485: PUSH
55486: LD_VAR 0 2
55490: PUSH
55491: LD_VAR 0 3
55495: PUSH
55496: LD_VAR 0 4
55500: PUSH
55501: LD_VAR 0 5
55505: PUSH
55506: EMPTY
55507: LIST
55508: LIST
55509: LIST
55510: LIST
55511: ST_TO_ADDR
// exit ;
55512: GO 55926
// end ; _chassis := AvailableChassisList ( factory ) ;
55514: LD_ADDR_VAR 0 9
55518: PUSH
55519: LD_VAR 0 1
55523: PPUSH
55524: CALL_OW 475
55528: ST_TO_ADDR
// _engine := AvailableEngineList ( factory ) ;
55529: LD_ADDR_VAR 0 11
55533: PUSH
55534: LD_VAR 0 1
55538: PPUSH
55539: CALL_OW 476
55543: ST_TO_ADDR
// _control := AvailableControlList ( factory ) ;
55544: LD_ADDR_VAR 0 12
55548: PUSH
55549: LD_VAR 0 1
55553: PPUSH
55554: CALL_OW 477
55558: ST_TO_ADDR
// _weapon := AvailableWeaponList ( factory ) ;
55559: LD_ADDR_VAR 0 10
55563: PUSH
55564: LD_VAR 0 1
55568: PPUSH
55569: CALL_OW 478
55573: ST_TO_ADDR
// if not _chassis or not _engine or not _control or not _weapon then
55574: LD_VAR 0 9
55578: NOT
55579: PUSH
55580: LD_VAR 0 11
55584: NOT
55585: OR
55586: PUSH
55587: LD_VAR 0 12
55591: NOT
55592: OR
55593: PUSH
55594: LD_VAR 0 10
55598: NOT
55599: OR
55600: IFFALSE 55635
// begin result := [ chassis , engine , control , weapon ] ;
55602: LD_ADDR_VAR 0 6
55606: PUSH
55607: LD_VAR 0 2
55611: PUSH
55612: LD_VAR 0 3
55616: PUSH
55617: LD_VAR 0 4
55621: PUSH
55622: LD_VAR 0 5
55626: PUSH
55627: EMPTY
55628: LIST
55629: LIST
55630: LIST
55631: LIST
55632: ST_TO_ADDR
// exit ;
55633: GO 55926
// end ; if not chassis in _chassis then
55635: LD_VAR 0 2
55639: PUSH
55640: LD_VAR 0 9
55644: IN
55645: NOT
55646: IFFALSE 55672
// chassis := _chassis [ rand ( 1 , _chassis ) ] ;
55648: LD_ADDR_VAR 0 2
55652: PUSH
55653: LD_VAR 0 9
55657: PUSH
55658: LD_INT 1
55660: PPUSH
55661: LD_VAR 0 9
55665: PPUSH
55666: CALL_OW 12
55670: ARRAY
55671: ST_TO_ADDR
// if not EngineCanBeMount ( chassis , engine ) then
55672: LD_VAR 0 2
55676: PPUSH
55677: LD_VAR 0 3
55681: PPUSH
55682: CALL 55931 0 2
55686: NOT
55687: IFFALSE 55746
// repeat engine := _engine [ 1 ] ;
55689: LD_ADDR_VAR 0 3
55693: PUSH
55694: LD_VAR 0 11
55698: PUSH
55699: LD_INT 1
55701: ARRAY
55702: ST_TO_ADDR
// _engine := Delete ( _engine , 1 ) ;
55703: LD_ADDR_VAR 0 11
55707: PUSH
55708: LD_VAR 0 11
55712: PPUSH
55713: LD_INT 1
55715: PPUSH
55716: CALL_OW 3
55720: ST_TO_ADDR
// until EngineCanBeMount ( chassis , engine ) or _engine = [ ] ;
55721: LD_VAR 0 2
55725: PPUSH
55726: LD_VAR 0 3
55730: PPUSH
55731: CALL 55931 0 2
55735: PUSH
55736: LD_VAR 0 11
55740: PUSH
55741: EMPTY
55742: EQUAL
55743: OR
55744: IFFALSE 55689
// if not control in _control then
55746: LD_VAR 0 4
55750: PUSH
55751: LD_VAR 0 12
55755: IN
55756: NOT
55757: IFFALSE 55783
// control := _control [ rand ( 1 , _control ) ] ;
55759: LD_ADDR_VAR 0 4
55763: PUSH
55764: LD_VAR 0 12
55768: PUSH
55769: LD_INT 1
55771: PPUSH
55772: LD_VAR 0 12
55776: PPUSH
55777: CALL_OW 12
55781: ARRAY
55782: ST_TO_ADDR
// if not WeaponCanBeMount ( chassis , weapon ) then
55783: LD_VAR 0 2
55787: PPUSH
55788: LD_VAR 0 5
55792: PPUSH
55793: CALL 56151 0 2
55797: NOT
55798: IFFALSE 55857
// repeat weapon := _weapon [ 1 ] ;
55800: LD_ADDR_VAR 0 5
55804: PUSH
55805: LD_VAR 0 10
55809: PUSH
55810: LD_INT 1
55812: ARRAY
55813: ST_TO_ADDR
// _weapon := Delete ( _weapon , 1 ) ;
55814: LD_ADDR_VAR 0 10
55818: PUSH
55819: LD_VAR 0 10
55823: PPUSH
55824: LD_INT 1
55826: PPUSH
55827: CALL_OW 3
55831: ST_TO_ADDR
// until WeaponCanBeMount ( chassis , weapon ) or _weapon = [ ] ;
55832: LD_VAR 0 2
55836: PPUSH
55837: LD_VAR 0 5
55841: PPUSH
55842: CALL 56151 0 2
55846: PUSH
55847: LD_VAR 0 10
55851: PUSH
55852: EMPTY
55853: EQUAL
55854: OR
55855: IFFALSE 55800
// result := [ ] ;
55857: LD_ADDR_VAR 0 6
55861: PUSH
55862: EMPTY
55863: ST_TO_ADDR
// if CanBeConstructed ( factory , chassis , engine , control , weapon ) then
55864: LD_VAR 0 1
55868: PPUSH
55869: LD_VAR 0 2
55873: PPUSH
55874: LD_VAR 0 3
55878: PPUSH
55879: LD_VAR 0 4
55883: PPUSH
55884: LD_VAR 0 5
55888: PPUSH
55889: CALL_OW 448
55893: IFFALSE 55926
// result := [ chassis , engine , control , weapon ] ;
55895: LD_ADDR_VAR 0 6
55899: PUSH
55900: LD_VAR 0 2
55904: PUSH
55905: LD_VAR 0 3
55909: PUSH
55910: LD_VAR 0 4
55914: PUSH
55915: LD_VAR 0 5
55919: PUSH
55920: EMPTY
55921: LIST
55922: LIST
55923: LIST
55924: LIST
55925: ST_TO_ADDR
// end ;
55926: LD_VAR 0 6
55930: RET
// export function EngineCanBeMount ( chassis , engine ) ; begin
55931: LD_INT 0
55933: PPUSH
// if not chassis or not engine then
55934: LD_VAR 0 1
55938: NOT
55939: PUSH
55940: LD_VAR 0 2
55944: NOT
55945: OR
55946: IFFALSE 55950
// exit ;
55948: GO 56146
// case engine of engine_solar :
55950: LD_VAR 0 2
55954: PUSH
55955: LD_INT 2
55957: DOUBLE
55958: EQUAL
55959: IFTRUE 55963
55961: GO 56001
55963: POP
// result := [ ar_hovercraft , ar_light_trike , ar_medium_trike , ar_half_tracked , us_light_wheeled , us_medium_wheeled , us_medium_tracked ] ; engine_combustion :
55964: LD_ADDR_VAR 0 3
55968: PUSH
55969: LD_INT 11
55971: PUSH
55972: LD_INT 12
55974: PUSH
55975: LD_INT 13
55977: PUSH
55978: LD_INT 14
55980: PUSH
55981: LD_INT 1
55983: PUSH
55984: LD_INT 2
55986: PUSH
55987: LD_INT 3
55989: PUSH
55990: EMPTY
55991: LIST
55992: LIST
55993: LIST
55994: LIST
55995: LIST
55996: LIST
55997: LIST
55998: ST_TO_ADDR
55999: GO 56130
56001: LD_INT 1
56003: DOUBLE
56004: EQUAL
56005: IFTRUE 56009
56007: GO 56071
56009: POP
// result := [ ar_hovercraft , ar_light_trike , ar_medium_trike , ar_half_tracked , us_light_wheeled , us_medium_wheeled , us_medium_tracked , us_heavy_tracked , us_morphling , ru_medium_wheeled , ru_heavy_wheeled , ru_medium_tracked , ru_heavy_tracked ] ; engine_siberite :
56010: LD_ADDR_VAR 0 3
56014: PUSH
56015: LD_INT 11
56017: PUSH
56018: LD_INT 12
56020: PUSH
56021: LD_INT 13
56023: PUSH
56024: LD_INT 14
56026: PUSH
56027: LD_INT 1
56029: PUSH
56030: LD_INT 2
56032: PUSH
56033: LD_INT 3
56035: PUSH
56036: LD_INT 4
56038: PUSH
56039: LD_INT 5
56041: PUSH
56042: LD_INT 21
56044: PUSH
56045: LD_INT 23
56047: PUSH
56048: LD_INT 22
56050: PUSH
56051: LD_INT 24
56053: PUSH
56054: EMPTY
56055: LIST
56056: LIST
56057: LIST
56058: LIST
56059: LIST
56060: LIST
56061: LIST
56062: LIST
56063: LIST
56064: LIST
56065: LIST
56066: LIST
56067: LIST
56068: ST_TO_ADDR
56069: GO 56130
56071: LD_INT 3
56073: DOUBLE
56074: EQUAL
56075: IFTRUE 56079
56077: GO 56129
56079: POP
// result := [ ar_medium_trike , ar_half_tracked , us_medium_wheeled , us_medium_tracked , us_heavy_tracked , us_morphling , ru_medium_wheeled , ru_medium_tracked , ru_heavy_wheeled , ru_heavy_tracked ] ; end ;
56080: LD_ADDR_VAR 0 3
56084: PUSH
56085: LD_INT 13
56087: PUSH
56088: LD_INT 14
56090: PUSH
56091: LD_INT 2
56093: PUSH
56094: LD_INT 3
56096: PUSH
56097: LD_INT 4
56099: PUSH
56100: LD_INT 5
56102: PUSH
56103: LD_INT 21
56105: PUSH
56106: LD_INT 22
56108: PUSH
56109: LD_INT 23
56111: PUSH
56112: LD_INT 24
56114: PUSH
56115: EMPTY
56116: LIST
56117: LIST
56118: LIST
56119: LIST
56120: LIST
56121: LIST
56122: LIST
56123: LIST
56124: LIST
56125: LIST
56126: ST_TO_ADDR
56127: GO 56130
56129: POP
// result := ( chassis in result ) ;
56130: LD_ADDR_VAR 0 3
56134: PUSH
56135: LD_VAR 0 1
56139: PUSH
56140: LD_VAR 0 3
56144: IN
56145: ST_TO_ADDR
// end ;
56146: LD_VAR 0 3
56150: RET
// export function WeaponCanBeMount ( chassis , weapon ) ; begin
56151: LD_INT 0
56153: PPUSH
// if not chassis or not weapon then
56154: LD_VAR 0 1
56158: NOT
56159: PUSH
56160: LD_VAR 0 2
56164: NOT
56165: OR
56166: IFFALSE 56170
// exit ;
56168: GO 57196
// case weapon of us_machine_gun :
56170: LD_VAR 0 2
56174: PUSH
56175: LD_INT 2
56177: DOUBLE
56178: EQUAL
56179: IFTRUE 56183
56181: GO 56213
56183: POP
// result := [ us_light_wheeled , us_medium_wheeled , us_medium_tracked , us_heavy_tracked , us_morphling ] ; us_light_gun :
56184: LD_ADDR_VAR 0 3
56188: PUSH
56189: LD_INT 1
56191: PUSH
56192: LD_INT 2
56194: PUSH
56195: LD_INT 3
56197: PUSH
56198: LD_INT 4
56200: PUSH
56201: LD_INT 5
56203: PUSH
56204: EMPTY
56205: LIST
56206: LIST
56207: LIST
56208: LIST
56209: LIST
56210: ST_TO_ADDR
56211: GO 57180
56213: LD_INT 3
56215: DOUBLE
56216: EQUAL
56217: IFTRUE 56221
56219: GO 56251
56221: POP
// result := [ us_light_wheeled , us_medium_wheeled , us_medium_tracked , us_heavy_tracked , us_morphling ] ; us_radar :
56222: LD_ADDR_VAR 0 3
56226: PUSH
56227: LD_INT 1
56229: PUSH
56230: LD_INT 2
56232: PUSH
56233: LD_INT 3
56235: PUSH
56236: LD_INT 4
56238: PUSH
56239: LD_INT 5
56241: PUSH
56242: EMPTY
56243: LIST
56244: LIST
56245: LIST
56246: LIST
56247: LIST
56248: ST_TO_ADDR
56249: GO 57180
56251: LD_INT 11
56253: DOUBLE
56254: EQUAL
56255: IFTRUE 56259
56257: GO 56289
56259: POP
// result := [ us_light_wheeled , us_medium_wheeled , us_medium_tracked , us_heavy_tracked , us_morphling ] ; us_gatling_gun :
56260: LD_ADDR_VAR 0 3
56264: PUSH
56265: LD_INT 1
56267: PUSH
56268: LD_INT 2
56270: PUSH
56271: LD_INT 3
56273: PUSH
56274: LD_INT 4
56276: PUSH
56277: LD_INT 5
56279: PUSH
56280: EMPTY
56281: LIST
56282: LIST
56283: LIST
56284: LIST
56285: LIST
56286: ST_TO_ADDR
56287: GO 57180
56289: LD_INT 4
56291: DOUBLE
56292: EQUAL
56293: IFTRUE 56297
56295: GO 56323
56297: POP
// result := [ us_medium_wheeled , us_medium_tracked , us_heavy_tracked , us_morphling ] ; us_double_gun :
56298: LD_ADDR_VAR 0 3
56302: PUSH
56303: LD_INT 2
56305: PUSH
56306: LD_INT 3
56308: PUSH
56309: LD_INT 4
56311: PUSH
56312: LD_INT 5
56314: PUSH
56315: EMPTY
56316: LIST
56317: LIST
56318: LIST
56319: LIST
56320: ST_TO_ADDR
56321: GO 57180
56323: LD_INT 5
56325: DOUBLE
56326: EQUAL
56327: IFTRUE 56331
56329: GO 56357
56331: POP
// result := [ us_medium_wheeled , us_medium_tracked , us_heavy_tracked , us_morphling ] ; us_laser :
56332: LD_ADDR_VAR 0 3
56336: PUSH
56337: LD_INT 2
56339: PUSH
56340: LD_INT 3
56342: PUSH
56343: LD_INT 4
56345: PUSH
56346: LD_INT 5
56348: PUSH
56349: EMPTY
56350: LIST
56351: LIST
56352: LIST
56353: LIST
56354: ST_TO_ADDR
56355: GO 57180
56357: LD_INT 9
56359: DOUBLE
56360: EQUAL
56361: IFTRUE 56365
56363: GO 56391
56365: POP
// result := [ us_medium_wheeled , us_medium_tracked , us_heavy_tracked , us_morphling ] ; us_rocket_launcher :
56366: LD_ADDR_VAR 0 3
56370: PUSH
56371: LD_INT 2
56373: PUSH
56374: LD_INT 3
56376: PUSH
56377: LD_INT 4
56379: PUSH
56380: LD_INT 5
56382: PUSH
56383: EMPTY
56384: LIST
56385: LIST
56386: LIST
56387: LIST
56388: ST_TO_ADDR
56389: GO 57180
56391: LD_INT 7
56393: DOUBLE
56394: EQUAL
56395: IFTRUE 56399
56397: GO 56425
56399: POP
// result := [ us_medium_wheeled , us_medium_tracked , us_heavy_tracked , us_morphling ] ; us_cargo_bay :
56400: LD_ADDR_VAR 0 3
56404: PUSH
56405: LD_INT 2
56407: PUSH
56408: LD_INT 3
56410: PUSH
56411: LD_INT 4
56413: PUSH
56414: LD_INT 5
56416: PUSH
56417: EMPTY
56418: LIST
56419: LIST
56420: LIST
56421: LIST
56422: ST_TO_ADDR
56423: GO 57180
56425: LD_INT 12
56427: DOUBLE
56428: EQUAL
56429: IFTRUE 56433
56431: GO 56459
56433: POP
// result := [ us_medium_wheeled , us_medium_tracked , us_heavy_tracked , us_morphling ] ; us_crane :
56434: LD_ADDR_VAR 0 3
56438: PUSH
56439: LD_INT 2
56441: PUSH
56442: LD_INT 3
56444: PUSH
56445: LD_INT 4
56447: PUSH
56448: LD_INT 5
56450: PUSH
56451: EMPTY
56452: LIST
56453: LIST
56454: LIST
56455: LIST
56456: ST_TO_ADDR
56457: GO 57180
56459: LD_INT 13
56461: DOUBLE
56462: EQUAL
56463: IFTRUE 56467
56465: GO 56493
56467: POP
// result := [ us_medium_wheeled , us_medium_tracked , us_heavy_tracked , us_morphling ] ; us_bulldozer :
56468: LD_ADDR_VAR 0 3
56472: PUSH
56473: LD_INT 2
56475: PUSH
56476: LD_INT 3
56478: PUSH
56479: LD_INT 4
56481: PUSH
56482: LD_INT 5
56484: PUSH
56485: EMPTY
56486: LIST
56487: LIST
56488: LIST
56489: LIST
56490: ST_TO_ADDR
56491: GO 57180
56493: LD_INT 14
56495: DOUBLE
56496: EQUAL
56497: IFTRUE 56501
56499: GO 56519
56501: POP
// result := [ us_heavy_tracked , us_morphling ] ; us_heavy_gun :
56502: LD_ADDR_VAR 0 3
56506: PUSH
56507: LD_INT 4
56509: PUSH
56510: LD_INT 5
56512: PUSH
56513: EMPTY
56514: LIST
56515: LIST
56516: ST_TO_ADDR
56517: GO 57180
56519: LD_INT 6
56521: DOUBLE
56522: EQUAL
56523: IFTRUE 56527
56525: GO 56545
56527: POP
// result := [ us_heavy_tracked , us_morphling ] ; us_double_laser :
56528: LD_ADDR_VAR 0 3
56532: PUSH
56533: LD_INT 4
56535: PUSH
56536: LD_INT 5
56538: PUSH
56539: EMPTY
56540: LIST
56541: LIST
56542: ST_TO_ADDR
56543: GO 57180
56545: LD_INT 10
56547: DOUBLE
56548: EQUAL
56549: IFTRUE 56553
56551: GO 56571
56553: POP
// result := [ us_heavy_tracked , us_morphling ] ; ar_multimissile_ballista :
56554: LD_ADDR_VAR 0 3
56558: PUSH
56559: LD_INT 4
56561: PUSH
56562: LD_INT 5
56564: PUSH
56565: EMPTY
56566: LIST
56567: LIST
56568: ST_TO_ADDR
56569: GO 57180
56571: LD_INT 22
56573: DOUBLE
56574: EQUAL
56575: IFTRUE 56579
56577: GO 56605
56579: POP
// result := [ ar_hovercraft , ar_light_trike , ar_medium_trike , ar_half_tracked ] ; ar_light_gun :
56580: LD_ADDR_VAR 0 3
56584: PUSH
56585: LD_INT 11
56587: PUSH
56588: LD_INT 12
56590: PUSH
56591: LD_INT 13
56593: PUSH
56594: LD_INT 14
56596: PUSH
56597: EMPTY
56598: LIST
56599: LIST
56600: LIST
56601: LIST
56602: ST_TO_ADDR
56603: GO 57180
56605: LD_INT 23
56607: DOUBLE
56608: EQUAL
56609: IFTRUE 56613
56611: GO 56639
56613: POP
// result := [ ar_hovercraft , ar_light_trike , ar_medium_trike , ar_half_tracked ] ; ar_double_machine_gun :
56614: LD_ADDR_VAR 0 3
56618: PUSH
56619: LD_INT 11
56621: PUSH
56622: LD_INT 12
56624: PUSH
56625: LD_INT 13
56627: PUSH
56628: LD_INT 14
56630: PUSH
56631: EMPTY
56632: LIST
56633: LIST
56634: LIST
56635: LIST
56636: ST_TO_ADDR
56637: GO 57180
56639: LD_INT 24
56641: DOUBLE
56642: EQUAL
56643: IFTRUE 56647
56645: GO 56673
56647: POP
// result := [ ar_hovercraft , ar_light_trike , ar_medium_trike , ar_half_tracked ] ; ar_radar :
56648: LD_ADDR_VAR 0 3
56652: PUSH
56653: LD_INT 11
56655: PUSH
56656: LD_INT 12
56658: PUSH
56659: LD_INT 13
56661: PUSH
56662: LD_INT 14
56664: PUSH
56665: EMPTY
56666: LIST
56667: LIST
56668: LIST
56669: LIST
56670: ST_TO_ADDR
56671: GO 57180
56673: LD_INT 30
56675: DOUBLE
56676: EQUAL
56677: IFTRUE 56681
56679: GO 56707
56681: POP
// result := [ ar_hovercraft , ar_light_trike , ar_medium_trike , ar_half_tracked ] ; ar_gatling_gun :
56682: LD_ADDR_VAR 0 3
56686: PUSH
56687: LD_INT 11
56689: PUSH
56690: LD_INT 12
56692: PUSH
56693: LD_INT 13
56695: PUSH
56696: LD_INT 14
56698: PUSH
56699: EMPTY
56700: LIST
56701: LIST
56702: LIST
56703: LIST
56704: ST_TO_ADDR
56705: GO 57180
56707: LD_INT 25
56709: DOUBLE
56710: EQUAL
56711: IFTRUE 56715
56713: GO 56733
56715: POP
// result := [ ar_medium_trike , ar_half_tracked ] ; ar_gun :
56716: LD_ADDR_VAR 0 3
56720: PUSH
56721: LD_INT 13
56723: PUSH
56724: LD_INT 14
56726: PUSH
56727: EMPTY
56728: LIST
56729: LIST
56730: ST_TO_ADDR
56731: GO 57180
56733: LD_INT 27
56735: DOUBLE
56736: EQUAL
56737: IFTRUE 56741
56739: GO 56759
56741: POP
// result := [ ar_medium_trike , ar_half_tracked ] ; ar_rocket_launcher :
56742: LD_ADDR_VAR 0 3
56746: PUSH
56747: LD_INT 13
56749: PUSH
56750: LD_INT 14
56752: PUSH
56753: EMPTY
56754: LIST
56755: LIST
56756: ST_TO_ADDR
56757: GO 57180
56759: LD_INT 28
56761: DOUBLE
56762: EQUAL
56763: IFTRUE 56767
56765: GO 56785
56767: POP
// result := [ ar_medium_trike , ar_half_tracked ] ; ar_selfpropelled_bomb :
56768: LD_ADDR_VAR 0 3
56772: PUSH
56773: LD_INT 13
56775: PUSH
56776: LD_INT 14
56778: PUSH
56779: EMPTY
56780: LIST
56781: LIST
56782: ST_TO_ADDR
56783: GO 57180
56785: LD_INT 29
56787: DOUBLE
56788: EQUAL
56789: IFTRUE 56793
56791: GO 56811
56793: POP
// result := [ ar_medium_trike , ar_half_tracked ] ; ar_control_tower :
56794: LD_ADDR_VAR 0 3
56798: PUSH
56799: LD_INT 13
56801: PUSH
56802: LD_INT 14
56804: PUSH
56805: EMPTY
56806: LIST
56807: LIST
56808: ST_TO_ADDR
56809: GO 57180
56811: LD_INT 31
56813: DOUBLE
56814: EQUAL
56815: IFTRUE 56819
56817: GO 56837
56819: POP
// result := [ ar_medium_trike , ar_half_tracked ] ; ar_flame_thrower :
56820: LD_ADDR_VAR 0 3
56824: PUSH
56825: LD_INT 13
56827: PUSH
56828: LD_INT 14
56830: PUSH
56831: EMPTY
56832: LIST
56833: LIST
56834: ST_TO_ADDR
56835: GO 57180
56837: LD_INT 26
56839: DOUBLE
56840: EQUAL
56841: IFTRUE 56845
56843: GO 56863
56845: POP
// result := [ ar_medium_trike , ar_half_tracked ] ; ru_heavy_machine_gun :
56846: LD_ADDR_VAR 0 3
56850: PUSH
56851: LD_INT 13
56853: PUSH
56854: LD_INT 14
56856: PUSH
56857: EMPTY
56858: LIST
56859: LIST
56860: ST_TO_ADDR
56861: GO 57180
56863: LD_INT 42
56865: DOUBLE
56866: EQUAL
56867: IFTRUE 56871
56869: GO 56897
56871: POP
// result := [ ru_medium_wheeled , ru_medium_tracked , ru_heavy_wheeled , ru_heavy_tracked ] ; ru_gatling_gun :
56872: LD_ADDR_VAR 0 3
56876: PUSH
56877: LD_INT 21
56879: PUSH
56880: LD_INT 22
56882: PUSH
56883: LD_INT 23
56885: PUSH
56886: LD_INT 24
56888: PUSH
56889: EMPTY
56890: LIST
56891: LIST
56892: LIST
56893: LIST
56894: ST_TO_ADDR
56895: GO 57180
56897: LD_INT 43
56899: DOUBLE
56900: EQUAL
56901: IFTRUE 56905
56903: GO 56931
56905: POP
// result := [ ru_medium_wheeled , ru_medium_tracked , ru_heavy_wheeled , ru_heavy_tracked ] ; ru_gun :
56906: LD_ADDR_VAR 0 3
56910: PUSH
56911: LD_INT 21
56913: PUSH
56914: LD_INT 22
56916: PUSH
56917: LD_INT 23
56919: PUSH
56920: LD_INT 24
56922: PUSH
56923: EMPTY
56924: LIST
56925: LIST
56926: LIST
56927: LIST
56928: ST_TO_ADDR
56929: GO 57180
56931: LD_INT 44
56933: DOUBLE
56934: EQUAL
56935: IFTRUE 56939
56937: GO 56965
56939: POP
// result := [ ru_medium_wheeled , ru_medium_tracked , ru_heavy_wheeled , ru_heavy_tracked ] ; ru_rocket_launcher :
56940: LD_ADDR_VAR 0 3
56944: PUSH
56945: LD_INT 21
56947: PUSH
56948: LD_INT 22
56950: PUSH
56951: LD_INT 23
56953: PUSH
56954: LD_INT 24
56956: PUSH
56957: EMPTY
56958: LIST
56959: LIST
56960: LIST
56961: LIST
56962: ST_TO_ADDR
56963: GO 57180
56965: LD_INT 45
56967: DOUBLE
56968: EQUAL
56969: IFTRUE 56973
56971: GO 56999
56973: POP
// result := [ ru_medium_wheeled , ru_medium_tracked , ru_heavy_wheeled , ru_heavy_tracked ] ; ru_time_lapser :
56974: LD_ADDR_VAR 0 3
56978: PUSH
56979: LD_INT 21
56981: PUSH
56982: LD_INT 22
56984: PUSH
56985: LD_INT 23
56987: PUSH
56988: LD_INT 24
56990: PUSH
56991: EMPTY
56992: LIST
56993: LIST
56994: LIST
56995: LIST
56996: ST_TO_ADDR
56997: GO 57180
56999: LD_INT 49
57001: DOUBLE
57002: EQUAL
57003: IFTRUE 57007
57005: GO 57033
57007: POP
// result := [ ru_medium_wheeled , ru_medium_tracked , ru_heavy_wheeled , ru_heavy_tracked ] ; ru_cargo_bay :
57008: LD_ADDR_VAR 0 3
57012: PUSH
57013: LD_INT 21
57015: PUSH
57016: LD_INT 22
57018: PUSH
57019: LD_INT 23
57021: PUSH
57022: LD_INT 24
57024: PUSH
57025: EMPTY
57026: LIST
57027: LIST
57028: LIST
57029: LIST
57030: ST_TO_ADDR
57031: GO 57180
57033: LD_INT 51
57035: DOUBLE
57036: EQUAL
57037: IFTRUE 57041
57039: GO 57067
57041: POP
// result := [ ru_medium_wheeled , ru_medium_tracked , ru_heavy_wheeled , ru_heavy_tracked ] ; ru_crane :
57042: LD_ADDR_VAR 0 3
57046: PUSH
57047: LD_INT 21
57049: PUSH
57050: LD_INT 22
57052: PUSH
57053: LD_INT 23
57055: PUSH
57056: LD_INT 24
57058: PUSH
57059: EMPTY
57060: LIST
57061: LIST
57062: LIST
57063: LIST
57064: ST_TO_ADDR
57065: GO 57180
57067: LD_INT 52
57069: DOUBLE
57070: EQUAL
57071: IFTRUE 57075
57073: GO 57101
57075: POP
// result := [ ru_medium_wheeled , ru_medium_tracked , ru_heavy_wheeled , ru_heavy_tracked ] ; ru_bulldozer :
57076: LD_ADDR_VAR 0 3
57080: PUSH
57081: LD_INT 21
57083: PUSH
57084: LD_INT 22
57086: PUSH
57087: LD_INT 23
57089: PUSH
57090: LD_INT 24
57092: PUSH
57093: EMPTY
57094: LIST
57095: LIST
57096: LIST
57097: LIST
57098: ST_TO_ADDR
57099: GO 57180
57101: LD_INT 53
57103: DOUBLE
57104: EQUAL
57105: IFTRUE 57109
57107: GO 57127
57109: POP
// result := [ ru_heavy_wheeled , ru_heavy_tracked ] ; ru_heavy_gun :
57110: LD_ADDR_VAR 0 3
57114: PUSH
57115: LD_INT 23
57117: PUSH
57118: LD_INT 24
57120: PUSH
57121: EMPTY
57122: LIST
57123: LIST
57124: ST_TO_ADDR
57125: GO 57180
57127: LD_INT 46
57129: DOUBLE
57130: EQUAL
57131: IFTRUE 57135
57133: GO 57153
57135: POP
// result := [ ru_heavy_wheeled , ru_heavy_tracked ] ; ru_rocket :
57136: LD_ADDR_VAR 0 3
57140: PUSH
57141: LD_INT 23
57143: PUSH
57144: LD_INT 24
57146: PUSH
57147: EMPTY
57148: LIST
57149: LIST
57150: ST_TO_ADDR
57151: GO 57180
57153: LD_INT 47
57155: DOUBLE
57156: EQUAL
57157: IFTRUE 57161
57159: GO 57179
57161: POP
// result := [ ru_heavy_wheeled , ru_heavy_tracked ] ; end ;
57162: LD_ADDR_VAR 0 3
57166: PUSH
57167: LD_INT 23
57169: PUSH
57170: LD_INT 24
57172: PUSH
57173: EMPTY
57174: LIST
57175: LIST
57176: ST_TO_ADDR
57177: GO 57180
57179: POP
// result := ( chassis in result ) ;
57180: LD_ADDR_VAR 0 3
57184: PUSH
57185: LD_VAR 0 1
57189: PUSH
57190: LD_VAR 0 3
57194: IN
57195: ST_TO_ADDR
// end ;
57196: LD_VAR 0 3
57200: RET
// export function Reindex ( array , i_from , i_to , direction ) ; var i , j , k , d , tmp , length ; begin
57201: LD_INT 0
57203: PPUSH
57204: PPUSH
57205: PPUSH
57206: PPUSH
57207: PPUSH
57208: PPUSH
57209: PPUSH
// result := array ;
57210: LD_ADDR_VAR 0 5
57214: PUSH
57215: LD_VAR 0 1
57219: ST_TO_ADDR
// if not array or not i_from or not i_to or i_from > array or i_to > array then
57220: LD_VAR 0 1
57224: NOT
57225: PUSH
57226: LD_VAR 0 2
57230: NOT
57231: OR
57232: PUSH
57233: LD_VAR 0 3
57237: NOT
57238: OR
57239: PUSH
57240: LD_VAR 0 2
57244: PUSH
57245: LD_VAR 0 1
57249: GREATER
57250: OR
57251: PUSH
57252: LD_VAR 0 3
57256: PUSH
57257: LD_VAR 0 1
57261: GREATER
57262: OR
57263: IFFALSE 57267
// exit ;
57265: GO 57563
// if direction then
57267: LD_VAR 0 4
57271: IFFALSE 57335
// begin d := 1 ;
57273: LD_ADDR_VAR 0 9
57277: PUSH
57278: LD_INT 1
57280: ST_TO_ADDR
// if i_from > i_to then
57281: LD_VAR 0 2
57285: PUSH
57286: LD_VAR 0 3
57290: GREATER
57291: IFFALSE 57317
// length := ( array - i_from ) + i_to else
57293: LD_ADDR_VAR 0 11
57297: PUSH
57298: LD_VAR 0 1
57302: PUSH
57303: LD_VAR 0 2
57307: MINUS
57308: PUSH
57309: LD_VAR 0 3
57313: PLUS
57314: ST_TO_ADDR
57315: GO 57333
// length := i_to - i_from ;
57317: LD_ADDR_VAR 0 11
57321: PUSH
57322: LD_VAR 0 3
57326: PUSH
57327: LD_VAR 0 2
57331: MINUS
57332: ST_TO_ADDR
// end else
57333: GO 57396
// begin d := - 1 ;
57335: LD_ADDR_VAR 0 9
57339: PUSH
57340: LD_INT 1
57342: NEG
57343: ST_TO_ADDR
// if i_from > i_to then
57344: LD_VAR 0 2
57348: PUSH
57349: LD_VAR 0 3
57353: GREATER
57354: IFFALSE 57374
// length := i_from - i_to else
57356: LD_ADDR_VAR 0 11
57360: PUSH
57361: LD_VAR 0 2
57365: PUSH
57366: LD_VAR 0 3
57370: MINUS
57371: ST_TO_ADDR
57372: GO 57396
// length := ( array - i_to ) + i_from ;
57374: LD_ADDR_VAR 0 11
57378: PUSH
57379: LD_VAR 0 1
57383: PUSH
57384: LD_VAR 0 3
57388: MINUS
57389: PUSH
57390: LD_VAR 0 2
57394: PLUS
57395: ST_TO_ADDR
// end ; if not length then
57396: LD_VAR 0 11
57400: NOT
57401: IFFALSE 57405
// exit ;
57403: GO 57563
// tmp := array ;
57405: LD_ADDR_VAR 0 10
57409: PUSH
57410: LD_VAR 0 1
57414: ST_TO_ADDR
// for i = 1 to length do
57415: LD_ADDR_VAR 0 6
57419: PUSH
57420: DOUBLE
57421: LD_INT 1
57423: DEC
57424: ST_TO_ADDR
57425: LD_VAR 0 11
57429: PUSH
57430: FOR_TO
57431: IFFALSE 57551
// begin for j = 1 to array do
57433: LD_ADDR_VAR 0 7
57437: PUSH
57438: DOUBLE
57439: LD_INT 1
57441: DEC
57442: ST_TO_ADDR
57443: LD_VAR 0 1
57447: PUSH
57448: FOR_TO
57449: IFFALSE 57537
// begin k := j + d ;
57451: LD_ADDR_VAR 0 8
57455: PUSH
57456: LD_VAR 0 7
57460: PUSH
57461: LD_VAR 0 9
57465: PLUS
57466: ST_TO_ADDR
// if k > array then
57467: LD_VAR 0 8
57471: PUSH
57472: LD_VAR 0 1
57476: GREATER
57477: IFFALSE 57487
// k := 1 ;
57479: LD_ADDR_VAR 0 8
57483: PUSH
57484: LD_INT 1
57486: ST_TO_ADDR
// if not k then
57487: LD_VAR 0 8
57491: NOT
57492: IFFALSE 57504
// k := array ;
57494: LD_ADDR_VAR 0 8
57498: PUSH
57499: LD_VAR 0 1
57503: ST_TO_ADDR
// tmp := Replace ( tmp , k , array [ j ] ) ;
57504: LD_ADDR_VAR 0 10
57508: PUSH
57509: LD_VAR 0 10
57513: PPUSH
57514: LD_VAR 0 8
57518: PPUSH
57519: LD_VAR 0 1
57523: PUSH
57524: LD_VAR 0 7
57528: ARRAY
57529: PPUSH
57530: CALL_OW 1
57534: ST_TO_ADDR
// end ;
57535: GO 57448
57537: POP
57538: POP
// array := tmp ;
57539: LD_ADDR_VAR 0 1
57543: PUSH
57544: LD_VAR 0 10
57548: ST_TO_ADDR
// end ;
57549: GO 57430
57551: POP
57552: POP
// result := array ;
57553: LD_ADDR_VAR 0 5
57557: PUSH
57558: LD_VAR 0 1
57562: ST_TO_ADDR
// end ;
57563: LD_VAR 0 5
57567: RET
// export function GetElementIndex ( array , value ) ; var i ; begin
57568: LD_INT 0
57570: PPUSH
57571: PPUSH
// result := 0 ;
57572: LD_ADDR_VAR 0 3
57576: PUSH
57577: LD_INT 0
57579: ST_TO_ADDR
// if not array or not value in array then
57580: LD_VAR 0 1
57584: NOT
57585: PUSH
57586: LD_VAR 0 2
57590: PUSH
57591: LD_VAR 0 1
57595: IN
57596: NOT
57597: OR
57598: IFFALSE 57602
// exit ;
57600: GO 57656
// for i = 1 to array do
57602: LD_ADDR_VAR 0 4
57606: PUSH
57607: DOUBLE
57608: LD_INT 1
57610: DEC
57611: ST_TO_ADDR
57612: LD_VAR 0 1
57616: PUSH
57617: FOR_TO
57618: IFFALSE 57654
// if value = array [ i ] then
57620: LD_VAR 0 2
57624: PUSH
57625: LD_VAR 0 1
57629: PUSH
57630: LD_VAR 0 4
57634: ARRAY
57635: EQUAL
57636: IFFALSE 57652
// begin result := i ;
57638: LD_ADDR_VAR 0 3
57642: PUSH
57643: LD_VAR 0 4
57647: ST_TO_ADDR
// exit ;
57648: POP
57649: POP
57650: GO 57656
// end ;
57652: GO 57617
57654: POP
57655: POP
// end ;
57656: LD_VAR 0 3
57660: RET
// export function PrepareVehicle ( chassis , engine , control , weapon , fuel ) ; begin
57661: LD_INT 0
57663: PPUSH
// vc_chassis := chassis ;
57664: LD_ADDR_OWVAR 37
57668: PUSH
57669: LD_VAR 0 1
57673: ST_TO_ADDR
// vc_engine := engine ;
57674: LD_ADDR_OWVAR 39
57678: PUSH
57679: LD_VAR 0 2
57683: ST_TO_ADDR
// vc_control := control ;
57684: LD_ADDR_OWVAR 38
57688: PUSH
57689: LD_VAR 0 3
57693: ST_TO_ADDR
// vc_weapon := weapon ;
57694: LD_ADDR_OWVAR 40
57698: PUSH
57699: LD_VAR 0 4
57703: ST_TO_ADDR
// vc_fuel_battery := fuel ;
57704: LD_ADDR_OWVAR 41
57708: PUSH
57709: LD_VAR 0 5
57713: ST_TO_ADDR
// end ;
57714: LD_VAR 0 6
57718: RET
// export function WantPlant ( unit ) ; var task ; begin
57719: LD_INT 0
57721: PPUSH
57722: PPUSH
// result := false ;
57723: LD_ADDR_VAR 0 2
57727: PUSH
57728: LD_INT 0
57730: ST_TO_ADDR
// task := GetTaskList ( unit ) ;
57731: LD_ADDR_VAR 0 3
57735: PUSH
57736: LD_VAR 0 1
57740: PPUSH
57741: CALL_OW 437
57745: ST_TO_ADDR
// if task then
57746: LD_VAR 0 3
57750: IFFALSE 57778
// if task [ 1 ] [ 1 ] = p then
57752: LD_VAR 0 3
57756: PUSH
57757: LD_INT 1
57759: ARRAY
57760: PUSH
57761: LD_INT 1
57763: ARRAY
57764: PUSH
57765: LD_STRING p
57767: EQUAL
57768: IFFALSE 57778
// result := true ;
57770: LD_ADDR_VAR 0 2
57774: PUSH
57775: LD_INT 1
57777: ST_TO_ADDR
// end ;
57778: LD_VAR 0 2
57782: RET
// export function ReplaceIn ( arr , pos , value ) ; var i , tmp , s_arr ; begin
57783: LD_INT 0
57785: PPUSH
57786: PPUSH
57787: PPUSH
57788: PPUSH
// if pos < 1 then
57789: LD_VAR 0 2
57793: PUSH
57794: LD_INT 1
57796: LESS
57797: IFFALSE 57801
// exit ;
57799: GO 58104
// if pos = 1 then
57801: LD_VAR 0 2
57805: PUSH
57806: LD_INT 1
57808: EQUAL
57809: IFFALSE 57842
// result := Replace ( arr , pos [ 1 ] , value ) else
57811: LD_ADDR_VAR 0 4
57815: PUSH
57816: LD_VAR 0 1
57820: PPUSH
57821: LD_VAR 0 2
57825: PUSH
57826: LD_INT 1
57828: ARRAY
57829: PPUSH
57830: LD_VAR 0 3
57834: PPUSH
57835: CALL_OW 1
57839: ST_TO_ADDR
57840: GO 58104
// begin tmp := arr ;
57842: LD_ADDR_VAR 0 6
57846: PUSH
57847: LD_VAR 0 1
57851: ST_TO_ADDR
// s_arr := [ tmp ] ;
57852: LD_ADDR_VAR 0 7
57856: PUSH
57857: LD_VAR 0 6
57861: PUSH
57862: EMPTY
57863: LIST
57864: ST_TO_ADDR
// for i = 1 to pos - 1 do
57865: LD_ADDR_VAR 0 5
57869: PUSH
57870: DOUBLE
57871: LD_INT 1
57873: DEC
57874: ST_TO_ADDR
57875: LD_VAR 0 2
57879: PUSH
57880: LD_INT 1
57882: MINUS
57883: PUSH
57884: FOR_TO
57885: IFFALSE 57930
// begin tmp := tmp [ pos [ i ] ] ;
57887: LD_ADDR_VAR 0 6
57891: PUSH
57892: LD_VAR 0 6
57896: PUSH
57897: LD_VAR 0 2
57901: PUSH
57902: LD_VAR 0 5
57906: ARRAY
57907: ARRAY
57908: ST_TO_ADDR
// s_arr := s_arr ^ [ tmp ] ;
57909: LD_ADDR_VAR 0 7
57913: PUSH
57914: LD_VAR 0 7
57918: PUSH
57919: LD_VAR 0 6
57923: PUSH
57924: EMPTY
57925: LIST
57926: ADD
57927: ST_TO_ADDR
// end ;
57928: GO 57884
57930: POP
57931: POP
// tmp := Replace ( tmp , pos [ pos ] , value ) ;
57932: LD_ADDR_VAR 0 6
57936: PUSH
57937: LD_VAR 0 6
57941: PPUSH
57942: LD_VAR 0 2
57946: PUSH
57947: LD_VAR 0 2
57951: ARRAY
57952: PPUSH
57953: LD_VAR 0 3
57957: PPUSH
57958: CALL_OW 1
57962: ST_TO_ADDR
// s_arr := Replace ( s_arr , s_arr , tmp ) ;
57963: LD_ADDR_VAR 0 7
57967: PUSH
57968: LD_VAR 0 7
57972: PPUSH
57973: LD_VAR 0 7
57977: PPUSH
57978: LD_VAR 0 6
57982: PPUSH
57983: CALL_OW 1
57987: ST_TO_ADDR
// for i = s_arr downto 2 do
57988: LD_ADDR_VAR 0 5
57992: PUSH
57993: DOUBLE
57994: LD_VAR 0 7
57998: INC
57999: ST_TO_ADDR
58000: LD_INT 2
58002: PUSH
58003: FOR_DOWNTO
58004: IFFALSE 58088
// begin tmp := Replace ( s_arr [ i - 1 ] , pos [ i - 1 ] , s_arr [ i ] ) ;
58006: LD_ADDR_VAR 0 6
58010: PUSH
58011: LD_VAR 0 7
58015: PUSH
58016: LD_VAR 0 5
58020: PUSH
58021: LD_INT 1
58023: MINUS
58024: ARRAY
58025: PPUSH
58026: LD_VAR 0 2
58030: PUSH
58031: LD_VAR 0 5
58035: PUSH
58036: LD_INT 1
58038: MINUS
58039: ARRAY
58040: PPUSH
58041: LD_VAR 0 7
58045: PUSH
58046: LD_VAR 0 5
58050: ARRAY
58051: PPUSH
58052: CALL_OW 1
58056: ST_TO_ADDR
// s_arr := Replace ( s_arr , i - 1 , tmp ) ;
58057: LD_ADDR_VAR 0 7
58061: PUSH
58062: LD_VAR 0 7
58066: PPUSH
58067: LD_VAR 0 5
58071: PUSH
58072: LD_INT 1
58074: MINUS
58075: PPUSH
58076: LD_VAR 0 6
58080: PPUSH
58081: CALL_OW 1
58085: ST_TO_ADDR
// end ;
58086: GO 58003
58088: POP
58089: POP
// result := s_arr [ 1 ] ;
58090: LD_ADDR_VAR 0 4
58094: PUSH
58095: LD_VAR 0 7
58099: PUSH
58100: LD_INT 1
58102: ARRAY
58103: ST_TO_ADDR
// end ; end ;
58104: LD_VAR 0 4
58108: RET
// export function ReplaceWith ( list , pos1 , pos2 ) ; var i ; begin
58109: LD_INT 0
58111: PPUSH
58112: PPUSH
// if not list then
58113: LD_VAR 0 1
58117: NOT
58118: IFFALSE 58122
// exit ;
58120: GO 58213
// i := list [ pos1 ] ;
58122: LD_ADDR_VAR 0 5
58126: PUSH
58127: LD_VAR 0 1
58131: PUSH
58132: LD_VAR 0 2
58136: ARRAY
58137: ST_TO_ADDR
// if not i then
58138: LD_VAR 0 5
58142: NOT
58143: IFFALSE 58147
// exit ;
58145: GO 58213
// list := Replace ( list , pos1 , list [ pos2 ] ) ;
58147: LD_ADDR_VAR 0 1
58151: PUSH
58152: LD_VAR 0 1
58156: PPUSH
58157: LD_VAR 0 2
58161: PPUSH
58162: LD_VAR 0 1
58166: PUSH
58167: LD_VAR 0 3
58171: ARRAY
58172: PPUSH
58173: CALL_OW 1
58177: ST_TO_ADDR
// list := Replace ( list , pos2 , i ) ;
58178: LD_ADDR_VAR 0 1
58182: PUSH
58183: LD_VAR 0 1
58187: PPUSH
58188: LD_VAR 0 3
58192: PPUSH
58193: LD_VAR 0 5
58197: PPUSH
58198: CALL_OW 1
58202: ST_TO_ADDR
// result := list ;
58203: LD_ADDR_VAR 0 4
58207: PUSH
58208: LD_VAR 0 1
58212: ST_TO_ADDR
// end ;
58213: LD_VAR 0 4
58217: RET
// export function SortByDistanceUnit ( unit , list , asc , mode ) ; begin
58218: LD_INT 0
58220: PPUSH
// result := SortByDistanceXY ( GetX ( unit ) , GetY ( unit ) , list , asc , mode ) ;
58221: LD_ADDR_VAR 0 5
58225: PUSH
58226: LD_VAR 0 1
58230: PPUSH
58231: CALL_OW 250
58235: PPUSH
58236: LD_VAR 0 1
58240: PPUSH
58241: CALL_OW 251
58245: PPUSH
58246: LD_VAR 0 2
58250: PPUSH
58251: LD_VAR 0 3
58255: PPUSH
58256: LD_VAR 0 4
58260: PPUSH
58261: CALL 58271 0 5
58265: ST_TO_ADDR
// end ;
58266: LD_VAR 0 5
58270: RET
// export function SortByDistanceXY ( x , y , list , asc , mode ) ; var i , j , tmp ; begin
58271: LD_INT 0
58273: PPUSH
58274: PPUSH
58275: PPUSH
58276: PPUSH
// if not list then
58277: LD_VAR 0 3
58281: NOT
58282: IFFALSE 58286
// exit ;
58284: GO 58674
// result := [ ] ;
58286: LD_ADDR_VAR 0 6
58290: PUSH
58291: EMPTY
58292: ST_TO_ADDR
// for i in list do
58293: LD_ADDR_VAR 0 7
58297: PUSH
58298: LD_VAR 0 3
58302: PUSH
58303: FOR_IN
58304: IFFALSE 58506
// begin tmp := GetDistUnitXY ( i , x , y ) ;
58306: LD_ADDR_VAR 0 9
58310: PUSH
58311: LD_VAR 0 7
58315: PPUSH
58316: LD_VAR 0 1
58320: PPUSH
58321: LD_VAR 0 2
58325: PPUSH
58326: CALL_OW 297
58330: ST_TO_ADDR
// if not result then
58331: LD_VAR 0 6
58335: NOT
58336: IFFALSE 58362
// result := [ [ i , tmp ] ] else
58338: LD_ADDR_VAR 0 6
58342: PUSH
58343: LD_VAR 0 7
58347: PUSH
58348: LD_VAR 0 9
58352: PUSH
58353: EMPTY
58354: LIST
58355: LIST
58356: PUSH
58357: EMPTY
58358: LIST
58359: ST_TO_ADDR
58360: GO 58504
// begin if result [ result ] [ 2 ] < tmp then
58362: LD_VAR 0 6
58366: PUSH
58367: LD_VAR 0 6
58371: ARRAY
58372: PUSH
58373: LD_INT 2
58375: ARRAY
58376: PUSH
58377: LD_VAR 0 9
58381: LESS
58382: IFFALSE 58424
// result := Insert ( result , result + 1 , [ i , tmp ] ) else
58384: LD_ADDR_VAR 0 6
58388: PUSH
58389: LD_VAR 0 6
58393: PPUSH
58394: LD_VAR 0 6
58398: PUSH
58399: LD_INT 1
58401: PLUS
58402: PPUSH
58403: LD_VAR 0 7
58407: PUSH
58408: LD_VAR 0 9
58412: PUSH
58413: EMPTY
58414: LIST
58415: LIST
58416: PPUSH
58417: CALL_OW 2
58421: ST_TO_ADDR
58422: GO 58504
// for j = 1 to result do
58424: LD_ADDR_VAR 0 8
58428: PUSH
58429: DOUBLE
58430: LD_INT 1
58432: DEC
58433: ST_TO_ADDR
58434: LD_VAR 0 6
58438: PUSH
58439: FOR_TO
58440: IFFALSE 58502
// begin if tmp < result [ j ] [ 2 ] then
58442: LD_VAR 0 9
58446: PUSH
58447: LD_VAR 0 6
58451: PUSH
58452: LD_VAR 0 8
58456: ARRAY
58457: PUSH
58458: LD_INT 2
58460: ARRAY
58461: LESS
58462: IFFALSE 58500
// begin result := Insert ( result , j , [ i , tmp ] ) ;
58464: LD_ADDR_VAR 0 6
58468: PUSH
58469: LD_VAR 0 6
58473: PPUSH
58474: LD_VAR 0 8
58478: PPUSH
58479: LD_VAR 0 7
58483: PUSH
58484: LD_VAR 0 9
58488: PUSH
58489: EMPTY
58490: LIST
58491: LIST
58492: PPUSH
58493: CALL_OW 2
58497: ST_TO_ADDR
// break ;
58498: GO 58502
// end ; end ;
58500: GO 58439
58502: POP
58503: POP
// end ; end ;
58504: GO 58303
58506: POP
58507: POP
// if result and not asc then
58508: LD_VAR 0 6
58512: PUSH
58513: LD_VAR 0 4
58517: NOT
58518: AND
58519: IFFALSE 58594
// begin tmp := result ;
58521: LD_ADDR_VAR 0 9
58525: PUSH
58526: LD_VAR 0 6
58530: ST_TO_ADDR
// for i = tmp downto 1 do
58531: LD_ADDR_VAR 0 7
58535: PUSH
58536: DOUBLE
58537: LD_VAR 0 9
58541: INC
58542: ST_TO_ADDR
58543: LD_INT 1
58545: PUSH
58546: FOR_DOWNTO
58547: IFFALSE 58592
// result := Replace ( result , tmp - i + 1 , tmp [ i ] ) ;
58549: LD_ADDR_VAR 0 6
58553: PUSH
58554: LD_VAR 0 6
58558: PPUSH
58559: LD_VAR 0 9
58563: PUSH
58564: LD_VAR 0 7
58568: MINUS
58569: PUSH
58570: LD_INT 1
58572: PLUS
58573: PPUSH
58574: LD_VAR 0 9
58578: PUSH
58579: LD_VAR 0 7
58583: ARRAY
58584: PPUSH
58585: CALL_OW 1
58589: ST_TO_ADDR
58590: GO 58546
58592: POP
58593: POP
// end ; tmp := [ ] ;
58594: LD_ADDR_VAR 0 9
58598: PUSH
58599: EMPTY
58600: ST_TO_ADDR
// if mode then
58601: LD_VAR 0 5
58605: IFFALSE 58674
// begin for i = 1 to result do
58607: LD_ADDR_VAR 0 7
58611: PUSH
58612: DOUBLE
58613: LD_INT 1
58615: DEC
58616: ST_TO_ADDR
58617: LD_VAR 0 6
58621: PUSH
58622: FOR_TO
58623: IFFALSE 58662
// tmp := Replace ( tmp , i , result [ i ] [ 1 ] ) ;
58625: LD_ADDR_VAR 0 9
58629: PUSH
58630: LD_VAR 0 9
58634: PPUSH
58635: LD_VAR 0 7
58639: PPUSH
58640: LD_VAR 0 6
58644: PUSH
58645: LD_VAR 0 7
58649: ARRAY
58650: PUSH
58651: LD_INT 1
58653: ARRAY
58654: PPUSH
58655: CALL_OW 1
58659: ST_TO_ADDR
58660: GO 58622
58662: POP
58663: POP
// result := tmp ;
58664: LD_ADDR_VAR 0 6
58668: PUSH
58669: LD_VAR 0 9
58673: ST_TO_ADDR
// end ; end ;
58674: LD_VAR 0 6
58678: RET
// export function DangerAtRangeXY ( side , x , y , range ) ; var i , j , tmp , points , bpoints ; begin
58679: LD_INT 0
58681: PPUSH
58682: PPUSH
58683: PPUSH
58684: PPUSH
58685: PPUSH
58686: PPUSH
// result := [ 0 , 0 , 0 , [ ] ] ;
58687: LD_ADDR_VAR 0 5
58691: PUSH
58692: LD_INT 0
58694: PUSH
58695: LD_INT 0
58697: PUSH
58698: LD_INT 0
58700: PUSH
58701: EMPTY
58702: PUSH
58703: EMPTY
58704: LIST
58705: LIST
58706: LIST
58707: LIST
58708: ST_TO_ADDR
// if not x or not y then
58709: LD_VAR 0 2
58713: NOT
58714: PUSH
58715: LD_VAR 0 3
58719: NOT
58720: OR
58721: IFFALSE 58725
// exit ;
58723: GO 60371
// if not range then
58725: LD_VAR 0 4
58729: NOT
58730: IFFALSE 58740
// range := 10 ;
58732: LD_ADDR_VAR 0 4
58736: PUSH
58737: LD_INT 10
58739: ST_TO_ADDR
// tmp := FilterAllUnits ( [ [ f_enemy , side ] , [ f_distxy , x , y , range ] , [ f_not , [ f_type , unit_building ] ] ] ) ;
58740: LD_ADDR_VAR 0 8
58744: PUSH
58745: LD_INT 81
58747: PUSH
58748: LD_VAR 0 1
58752: PUSH
58753: EMPTY
58754: LIST
58755: LIST
58756: PUSH
58757: LD_INT 92
58759: PUSH
58760: LD_VAR 0 2
58764: PUSH
58765: LD_VAR 0 3
58769: PUSH
58770: LD_VAR 0 4
58774: PUSH
58775: EMPTY
58776: LIST
58777: LIST
58778: LIST
58779: LIST
58780: PUSH
58781: LD_INT 3
58783: PUSH
58784: LD_INT 21
58786: PUSH
58787: LD_INT 3
58789: PUSH
58790: EMPTY
58791: LIST
58792: LIST
58793: PUSH
58794: EMPTY
58795: LIST
58796: LIST
58797: PUSH
58798: EMPTY
58799: LIST
58800: LIST
58801: LIST
58802: PPUSH
58803: CALL_OW 69
58807: ST_TO_ADDR
// if not tmp then
58808: LD_VAR 0 8
58812: NOT
58813: IFFALSE 58817
// exit ;
58815: GO 60371
// for i in tmp do
58817: LD_ADDR_VAR 0 6
58821: PUSH
58822: LD_VAR 0 8
58826: PUSH
58827: FOR_IN
58828: IFFALSE 60346
// begin points := [ 0 , 0 , 0 ] ;
58830: LD_ADDR_VAR 0 9
58834: PUSH
58835: LD_INT 0
58837: PUSH
58838: LD_INT 0
58840: PUSH
58841: LD_INT 0
58843: PUSH
58844: EMPTY
58845: LIST
58846: LIST
58847: LIST
58848: ST_TO_ADDR
// bpoints := 1 ;
58849: LD_ADDR_VAR 0 10
58853: PUSH
58854: LD_INT 1
58856: ST_TO_ADDR
// case GetType ( i ) of unit_human :
58857: LD_VAR 0 6
58861: PPUSH
58862: CALL_OW 247
58866: PUSH
58867: LD_INT 1
58869: DOUBLE
58870: EQUAL
58871: IFTRUE 58875
58873: GO 59453
58875: POP
// begin if GetClass ( i ) = 1 then
58876: LD_VAR 0 6
58880: PPUSH
58881: CALL_OW 257
58885: PUSH
58886: LD_INT 1
58888: EQUAL
58889: IFFALSE 58910
// points := [ 10 , 5 , 3 ] ;
58891: LD_ADDR_VAR 0 9
58895: PUSH
58896: LD_INT 10
58898: PUSH
58899: LD_INT 5
58901: PUSH
58902: LD_INT 3
58904: PUSH
58905: EMPTY
58906: LIST
58907: LIST
58908: LIST
58909: ST_TO_ADDR
// if GetClass ( i ) in [ 2 , 3 , 4 ] then
58910: LD_VAR 0 6
58914: PPUSH
58915: CALL_OW 257
58919: PUSH
58920: LD_INT 2
58922: PUSH
58923: LD_INT 3
58925: PUSH
58926: LD_INT 4
58928: PUSH
58929: EMPTY
58930: LIST
58931: LIST
58932: LIST
58933: IN
58934: IFFALSE 58955
// points := [ 3 , 2 , 1 ] ;
58936: LD_ADDR_VAR 0 9
58940: PUSH
58941: LD_INT 3
58943: PUSH
58944: LD_INT 2
58946: PUSH
58947: LD_INT 1
58949: PUSH
58950: EMPTY
58951: LIST
58952: LIST
58953: LIST
58954: ST_TO_ADDR
// if GetClass ( i ) = 5 then
58955: LD_VAR 0 6
58959: PPUSH
58960: CALL_OW 257
58964: PUSH
58965: LD_INT 5
58967: EQUAL
58968: IFFALSE 58989
// points := [ 130 , 5 , 2 ] ;
58970: LD_ADDR_VAR 0 9
58974: PUSH
58975: LD_INT 130
58977: PUSH
58978: LD_INT 5
58980: PUSH
58981: LD_INT 2
58983: PUSH
58984: EMPTY
58985: LIST
58986: LIST
58987: LIST
58988: ST_TO_ADDR
// if GetClass ( i ) = 8 then
58989: LD_VAR 0 6
58993: PPUSH
58994: CALL_OW 257
58998: PUSH
58999: LD_INT 8
59001: EQUAL
59002: IFFALSE 59023
// points := [ 35 , 35 , 30 ] ;
59004: LD_ADDR_VAR 0 9
59008: PUSH
59009: LD_INT 35
59011: PUSH
59012: LD_INT 35
59014: PUSH
59015: LD_INT 30
59017: PUSH
59018: EMPTY
59019: LIST
59020: LIST
59021: LIST
59022: ST_TO_ADDR
// if GetClass ( i ) = 9 then
59023: LD_VAR 0 6
59027: PPUSH
59028: CALL_OW 257
59032: PUSH
59033: LD_INT 9
59035: EQUAL
59036: IFFALSE 59057
// points := [ 20 , 55 , 40 ] ;
59038: LD_ADDR_VAR 0 9
59042: PUSH
59043: LD_INT 20
59045: PUSH
59046: LD_INT 55
59048: PUSH
59049: LD_INT 40
59051: PUSH
59052: EMPTY
59053: LIST
59054: LIST
59055: LIST
59056: ST_TO_ADDR
// if GetClass ( i ) in [ 12 , 16 ] then
59057: LD_VAR 0 6
59061: PPUSH
59062: CALL_OW 257
59066: PUSH
59067: LD_INT 12
59069: PUSH
59070: LD_INT 16
59072: PUSH
59073: EMPTY
59074: LIST
59075: LIST
59076: IN
59077: IFFALSE 59098
// points := [ 5 , 3 , 2 ] ;
59079: LD_ADDR_VAR 0 9
59083: PUSH
59084: LD_INT 5
59086: PUSH
59087: LD_INT 3
59089: PUSH
59090: LD_INT 2
59092: PUSH
59093: EMPTY
59094: LIST
59095: LIST
59096: LIST
59097: ST_TO_ADDR
// if GetClass ( i ) = 17 then
59098: LD_VAR 0 6
59102: PPUSH
59103: CALL_OW 257
59107: PUSH
59108: LD_INT 17
59110: EQUAL
59111: IFFALSE 59132
// points := [ 100 , 50 , 75 ] ;
59113: LD_ADDR_VAR 0 9
59117: PUSH
59118: LD_INT 100
59120: PUSH
59121: LD_INT 50
59123: PUSH
59124: LD_INT 75
59126: PUSH
59127: EMPTY
59128: LIST
59129: LIST
59130: LIST
59131: ST_TO_ADDR
// if GetClass ( i ) = 15 then
59132: LD_VAR 0 6
59136: PPUSH
59137: CALL_OW 257
59141: PUSH
59142: LD_INT 15
59144: EQUAL
59145: IFFALSE 59166
// points := [ 10 , 5 , 3 ] ;
59147: LD_ADDR_VAR 0 9
59151: PUSH
59152: LD_INT 10
59154: PUSH
59155: LD_INT 5
59157: PUSH
59158: LD_INT 3
59160: PUSH
59161: EMPTY
59162: LIST
59163: LIST
59164: LIST
59165: ST_TO_ADDR
// if GetClass ( i ) = 14 then
59166: LD_VAR 0 6
59170: PPUSH
59171: CALL_OW 257
59175: PUSH
59176: LD_INT 14
59178: EQUAL
59179: IFFALSE 59200
// points := [ 10 , 0 , 0 ] ;
59181: LD_ADDR_VAR 0 9
59185: PUSH
59186: LD_INT 10
59188: PUSH
59189: LD_INT 0
59191: PUSH
59192: LD_INT 0
59194: PUSH
59195: EMPTY
59196: LIST
59197: LIST
59198: LIST
59199: ST_TO_ADDR
// if GetClass ( i ) = 11 then
59200: LD_VAR 0 6
59204: PPUSH
59205: CALL_OW 257
59209: PUSH
59210: LD_INT 11
59212: EQUAL
59213: IFFALSE 59234
// points := [ 30 , 10 , 5 ] ;
59215: LD_ADDR_VAR 0 9
59219: PUSH
59220: LD_INT 30
59222: PUSH
59223: LD_INT 10
59225: PUSH
59226: LD_INT 5
59228: PUSH
59229: EMPTY
59230: LIST
59231: LIST
59232: LIST
59233: ST_TO_ADDR
// if GetTech ( side , tech_stimdrugs ) = state_researched then
59234: LD_VAR 0 1
59238: PPUSH
59239: LD_INT 5
59241: PPUSH
59242: CALL_OW 321
59246: PUSH
59247: LD_INT 2
59249: EQUAL
59250: IFFALSE 59267
// bpoints := bpoints * 1.8 ;
59252: LD_ADDR_VAR 0 10
59256: PUSH
59257: LD_VAR 0 10
59261: PUSH
59262: LD_REAL  1.80000000000000E+0000
59265: MUL
59266: ST_TO_ADDR
// if GetClass ( i ) in [ 1 , 2 , 3 , 4 ] and GetTech ( side , tech_weap1 ) = state_researched then
59267: LD_VAR 0 6
59271: PPUSH
59272: CALL_OW 257
59276: PUSH
59277: LD_INT 1
59279: PUSH
59280: LD_INT 2
59282: PUSH
59283: LD_INT 3
59285: PUSH
59286: LD_INT 4
59288: PUSH
59289: EMPTY
59290: LIST
59291: LIST
59292: LIST
59293: LIST
59294: IN
59295: PUSH
59296: LD_VAR 0 1
59300: PPUSH
59301: LD_INT 51
59303: PPUSH
59304: CALL_OW 321
59308: PUSH
59309: LD_INT 2
59311: EQUAL
59312: AND
59313: IFFALSE 59330
// bpoints := bpoints * 1.2 ;
59315: LD_ADDR_VAR 0 10
59319: PUSH
59320: LD_VAR 0 10
59324: PUSH
59325: LD_REAL  1.20000000000000E+0000
59328: MUL
59329: ST_TO_ADDR
// if GetClass ( i ) in [ 5 , 7 , 9 ] and GetTech ( side , tech_weap2 ) = state_researched then
59330: LD_VAR 0 6
59334: PPUSH
59335: CALL_OW 257
59339: PUSH
59340: LD_INT 5
59342: PUSH
59343: LD_INT 7
59345: PUSH
59346: LD_INT 9
59348: PUSH
59349: EMPTY
59350: LIST
59351: LIST
59352: LIST
59353: IN
59354: PUSH
59355: LD_VAR 0 1
59359: PPUSH
59360: LD_INT 52
59362: PPUSH
59363: CALL_OW 321
59367: PUSH
59368: LD_INT 2
59370: EQUAL
59371: AND
59372: IFFALSE 59389
// bpoints := bpoints * 1.5 ;
59374: LD_ADDR_VAR 0 10
59378: PUSH
59379: LD_VAR 0 10
59383: PUSH
59384: LD_REAL  1.50000000000000E+0000
59387: MUL
59388: ST_TO_ADDR
// if GetTech ( side , tech_bio1 ) = state_researched then
59389: LD_VAR 0 1
59393: PPUSH
59394: LD_INT 66
59396: PPUSH
59397: CALL_OW 321
59401: PUSH
59402: LD_INT 2
59404: EQUAL
59405: IFFALSE 59422
// bpoints := bpoints * 1.1 ;
59407: LD_ADDR_VAR 0 10
59411: PUSH
59412: LD_VAR 0 10
59416: PUSH
59417: LD_REAL  1.10000000000000E+0000
59420: MUL
59421: ST_TO_ADDR
// bpoints := bpoints * ( GetSkill ( i , 1 ) * 1.15 ) ;
59422: LD_ADDR_VAR 0 10
59426: PUSH
59427: LD_VAR 0 10
59431: PUSH
59432: LD_VAR 0 6
59436: PPUSH
59437: LD_INT 1
59439: PPUSH
59440: CALL_OW 259
59444: PUSH
59445: LD_REAL  1.15000000000000E+0000
59448: MUL
59449: MUL
59450: ST_TO_ADDR
// end ; unit_vehicle :
59451: GO 60275
59453: LD_INT 2
59455: DOUBLE
59456: EQUAL
59457: IFTRUE 59461
59459: GO 60263
59461: POP
// begin if GetWeapon ( i ) in [ us_machine_gun , ru_heavy_machine_gun , ar_double_machine_gun ] then
59462: LD_VAR 0 6
59466: PPUSH
59467: CALL_OW 264
59471: PUSH
59472: LD_INT 2
59474: PUSH
59475: LD_INT 42
59477: PUSH
59478: LD_INT 24
59480: PUSH
59481: EMPTY
59482: LIST
59483: LIST
59484: LIST
59485: IN
59486: IFFALSE 59507
// points := [ 25 , 5 , 3 ] ;
59488: LD_ADDR_VAR 0 9
59492: PUSH
59493: LD_INT 25
59495: PUSH
59496: LD_INT 5
59498: PUSH
59499: LD_INT 3
59501: PUSH
59502: EMPTY
59503: LIST
59504: LIST
59505: LIST
59506: ST_TO_ADDR
// if GetWeapon ( i ) in [ us_gatling_gun , ru_gatling_gun , ar_gatling_gun ] then
59507: LD_VAR 0 6
59511: PPUSH
59512: CALL_OW 264
59516: PUSH
59517: LD_INT 4
59519: PUSH
59520: LD_INT 43
59522: PUSH
59523: LD_INT 25
59525: PUSH
59526: EMPTY
59527: LIST
59528: LIST
59529: LIST
59530: IN
59531: IFFALSE 59552
// points := [ 40 , 15 , 5 ] ;
59533: LD_ADDR_VAR 0 9
59537: PUSH
59538: LD_INT 40
59540: PUSH
59541: LD_INT 15
59543: PUSH
59544: LD_INT 5
59546: PUSH
59547: EMPTY
59548: LIST
59549: LIST
59550: LIST
59551: ST_TO_ADDR
// if GetWeapon ( i ) in [ us_light_gun , ar_light_gun ] then
59552: LD_VAR 0 6
59556: PPUSH
59557: CALL_OW 264
59561: PUSH
59562: LD_INT 3
59564: PUSH
59565: LD_INT 23
59567: PUSH
59568: EMPTY
59569: LIST
59570: LIST
59571: IN
59572: IFFALSE 59593
// points := [ 7 , 25 , 8 ] ;
59574: LD_ADDR_VAR 0 9
59578: PUSH
59579: LD_INT 7
59581: PUSH
59582: LD_INT 25
59584: PUSH
59585: LD_INT 8
59587: PUSH
59588: EMPTY
59589: LIST
59590: LIST
59591: LIST
59592: ST_TO_ADDR
// if GetWeapon ( i ) in [ us_double_gun , ar_gun , ru_gun ] then
59593: LD_VAR 0 6
59597: PPUSH
59598: CALL_OW 264
59602: PUSH
59603: LD_INT 5
59605: PUSH
59606: LD_INT 27
59608: PUSH
59609: LD_INT 44
59611: PUSH
59612: EMPTY
59613: LIST
59614: LIST
59615: LIST
59616: IN
59617: IFFALSE 59638
// points := [ 14 , 50 , 16 ] ;
59619: LD_ADDR_VAR 0 9
59623: PUSH
59624: LD_INT 14
59626: PUSH
59627: LD_INT 50
59629: PUSH
59630: LD_INT 16
59632: PUSH
59633: EMPTY
59634: LIST
59635: LIST
59636: LIST
59637: ST_TO_ADDR
// if GetWeapon ( i ) in [ us_heavy_gun , ru_heavy_gun ] then
59638: LD_VAR 0 6
59642: PPUSH
59643: CALL_OW 264
59647: PUSH
59648: LD_INT 6
59650: PUSH
59651: LD_INT 46
59653: PUSH
59654: EMPTY
59655: LIST
59656: LIST
59657: IN
59658: IFFALSE 59679
// points := [ 32 , 120 , 70 ] ;
59660: LD_ADDR_VAR 0 9
59664: PUSH
59665: LD_INT 32
59667: PUSH
59668: LD_INT 120
59670: PUSH
59671: LD_INT 70
59673: PUSH
59674: EMPTY
59675: LIST
59676: LIST
59677: LIST
59678: ST_TO_ADDR
// if GetWeapon ( i ) in [ us_rocket_launcher , ar_rocket_launcher , ru_rocket_launcher ] then
59679: LD_VAR 0 6
59683: PPUSH
59684: CALL_OW 264
59688: PUSH
59689: LD_INT 7
59691: PUSH
59692: LD_INT 28
59694: PUSH
59695: LD_INT 45
59697: PUSH
59698: EMPTY
59699: LIST
59700: LIST
59701: LIST
59702: IN
59703: IFFALSE 59724
// points := [ 35 , 20 , 45 ] ;
59705: LD_ADDR_VAR 0 9
59709: PUSH
59710: LD_INT 35
59712: PUSH
59713: LD_INT 20
59715: PUSH
59716: LD_INT 45
59718: PUSH
59719: EMPTY
59720: LIST
59721: LIST
59722: LIST
59723: ST_TO_ADDR
// if GetWeapon ( i ) in [ ru_rocket ] then
59724: LD_VAR 0 6
59728: PPUSH
59729: CALL_OW 264
59733: PUSH
59734: LD_INT 47
59736: PUSH
59737: EMPTY
59738: LIST
59739: IN
59740: IFFALSE 59761
// points := [ 67 , 45 , 75 ] ;
59742: LD_ADDR_VAR 0 9
59746: PUSH
59747: LD_INT 67
59749: PUSH
59750: LD_INT 45
59752: PUSH
59753: LD_INT 75
59755: PUSH
59756: EMPTY
59757: LIST
59758: LIST
59759: LIST
59760: ST_TO_ADDR
// if GetWeapon ( i ) in [ ar_flame_thrower ] then
59761: LD_VAR 0 6
59765: PPUSH
59766: CALL_OW 264
59770: PUSH
59771: LD_INT 26
59773: PUSH
59774: EMPTY
59775: LIST
59776: IN
59777: IFFALSE 59798
// points := [ 120 , 30 , 80 ] ;
59779: LD_ADDR_VAR 0 9
59783: PUSH
59784: LD_INT 120
59786: PUSH
59787: LD_INT 30
59789: PUSH
59790: LD_INT 80
59792: PUSH
59793: EMPTY
59794: LIST
59795: LIST
59796: LIST
59797: ST_TO_ADDR
// if GetWeapon ( i ) in [ ar_multimissile_ballista ] then
59798: LD_VAR 0 6
59802: PPUSH
59803: CALL_OW 264
59807: PUSH
59808: LD_INT 22
59810: PUSH
59811: EMPTY
59812: LIST
59813: IN
59814: IFFALSE 59835
// points := [ 40 , 1 , 1 ] ;
59816: LD_ADDR_VAR 0 9
59820: PUSH
59821: LD_INT 40
59823: PUSH
59824: LD_INT 1
59826: PUSH
59827: LD_INT 1
59829: PUSH
59830: EMPTY
59831: LIST
59832: LIST
59833: LIST
59834: ST_TO_ADDR
// if GetWeapon ( i ) in [ ar_selfpropelled_bomb ] then
59835: LD_VAR 0 6
59839: PPUSH
59840: CALL_OW 264
59844: PUSH
59845: LD_INT 29
59847: PUSH
59848: EMPTY
59849: LIST
59850: IN
59851: IFFALSE 59872
// points := [ 70 , 200 , 400 ] ;
59853: LD_ADDR_VAR 0 9
59857: PUSH
59858: LD_INT 70
59860: PUSH
59861: LD_INT 200
59863: PUSH
59864: LD_INT 400
59866: PUSH
59867: EMPTY
59868: LIST
59869: LIST
59870: LIST
59871: ST_TO_ADDR
// if GetWeapon ( i ) in [ us_bulldozer , ru_bulldozer ] then
59872: LD_VAR 0 6
59876: PPUSH
59877: CALL_OW 264
59881: PUSH
59882: LD_INT 14
59884: PUSH
59885: LD_INT 53
59887: PUSH
59888: EMPTY
59889: LIST
59890: LIST
59891: IN
59892: IFFALSE 59913
// points := [ 40 , 10 , 20 ] ;
59894: LD_ADDR_VAR 0 9
59898: PUSH
59899: LD_INT 40
59901: PUSH
59902: LD_INT 10
59904: PUSH
59905: LD_INT 20
59907: PUSH
59908: EMPTY
59909: LIST
59910: LIST
59911: LIST
59912: ST_TO_ADDR
// if GetWeapon ( i ) in [ us_laser ] then
59913: LD_VAR 0 6
59917: PPUSH
59918: CALL_OW 264
59922: PUSH
59923: LD_INT 9
59925: PUSH
59926: EMPTY
59927: LIST
59928: IN
59929: IFFALSE 59950
// points := [ 5 , 70 , 20 ] ;
59931: LD_ADDR_VAR 0 9
59935: PUSH
59936: LD_INT 5
59938: PUSH
59939: LD_INT 70
59941: PUSH
59942: LD_INT 20
59944: PUSH
59945: EMPTY
59946: LIST
59947: LIST
59948: LIST
59949: ST_TO_ADDR
// if GetWeapon ( i ) in [ us_double_laser ] then
59950: LD_VAR 0 6
59954: PPUSH
59955: CALL_OW 264
59959: PUSH
59960: LD_INT 10
59962: PUSH
59963: EMPTY
59964: LIST
59965: IN
59966: IFFALSE 59987
// points := [ 35 , 110 , 70 ] ;
59968: LD_ADDR_VAR 0 9
59972: PUSH
59973: LD_INT 35
59975: PUSH
59976: LD_INT 110
59978: PUSH
59979: LD_INT 70
59981: PUSH
59982: EMPTY
59983: LIST
59984: LIST
59985: LIST
59986: ST_TO_ADDR
// if GetChassis ( i ) = 25 then
59987: LD_VAR 0 6
59991: PPUSH
59992: CALL_OW 265
59996: PUSH
59997: LD_INT 25
59999: EQUAL
60000: IFFALSE 60021
// points := [ 80 , 65 , 100 ] ;
60002: LD_ADDR_VAR 0 9
60006: PUSH
60007: LD_INT 80
60009: PUSH
60010: LD_INT 65
60012: PUSH
60013: LD_INT 100
60015: PUSH
60016: EMPTY
60017: LIST
60018: LIST
60019: LIST
60020: ST_TO_ADDR
// if GetControl ( i ) = control_manual then
60021: LD_VAR 0 6
60025: PPUSH
60026: CALL_OW 263
60030: PUSH
60031: LD_INT 1
60033: EQUAL
60034: IFFALSE 60069
// bpoints := bpoints * ( GetSkill ( IsDrivenBy ( i ) , 3 ) * 4 ) ;
60036: LD_ADDR_VAR 0 10
60040: PUSH
60041: LD_VAR 0 10
60045: PUSH
60046: LD_VAR 0 6
60050: PPUSH
60051: CALL_OW 311
60055: PPUSH
60056: LD_INT 3
60058: PPUSH
60059: CALL_OW 259
60063: PUSH
60064: LD_INT 4
60066: MUL
60067: MUL
60068: ST_TO_ADDR
// if GetControl ( i ) = control_remote then
60069: LD_VAR 0 6
60073: PPUSH
60074: CALL_OW 263
60078: PUSH
60079: LD_INT 2
60081: EQUAL
60082: IFFALSE 60133
// begin j := IsControledBy ( i ) ;
60084: LD_ADDR_VAR 0 7
60088: PUSH
60089: LD_VAR 0 6
60093: PPUSH
60094: CALL_OW 312
60098: ST_TO_ADDR
// if j then
60099: LD_VAR 0 7
60103: IFFALSE 60133
// bpoints := bpoints * ( GetSkill ( j , 3 ) * 3 ) ;
60105: LD_ADDR_VAR 0 10
60109: PUSH
60110: LD_VAR 0 10
60114: PUSH
60115: LD_VAR 0 7
60119: PPUSH
60120: LD_INT 3
60122: PPUSH
60123: CALL_OW 259
60127: PUSH
60128: LD_INT 3
60130: MUL
60131: MUL
60132: ST_TO_ADDR
// end ; if GetWeapon ( i ) in [ us_double_gun , us_heavy_gun , ru_heavy_gun , ru_gun , ru_rocket , ru_rocket_launcher , ar_rocket_launcher , us_rocket_launcher , ar_gun , ar_selfpropelled_bomb ] and GetTech ( side , tech_weap2 ) = state_researched then
60133: LD_VAR 0 6
60137: PPUSH
60138: CALL_OW 264
60142: PUSH
60143: LD_INT 5
60145: PUSH
60146: LD_INT 6
60148: PUSH
60149: LD_INT 46
60151: PUSH
60152: LD_INT 44
60154: PUSH
60155: LD_INT 47
60157: PUSH
60158: LD_INT 45
60160: PUSH
60161: LD_INT 28
60163: PUSH
60164: LD_INT 7
60166: PUSH
60167: LD_INT 27
60169: PUSH
60170: LD_INT 29
60172: PUSH
60173: EMPTY
60174: LIST
60175: LIST
60176: LIST
60177: LIST
60178: LIST
60179: LIST
60180: LIST
60181: LIST
60182: LIST
60183: LIST
60184: IN
60185: PUSH
60186: LD_VAR 0 1
60190: PPUSH
60191: LD_INT 52
60193: PPUSH
60194: CALL_OW 321
60198: PUSH
60199: LD_INT 2
60201: EQUAL
60202: AND
60203: IFFALSE 60220
// bpoints := bpoints * 1.2 ;
60205: LD_ADDR_VAR 0 10
60209: PUSH
60210: LD_VAR 0 10
60214: PUSH
60215: LD_REAL  1.20000000000000E+0000
60218: MUL
60219: ST_TO_ADDR
// if GetWeapon ( i ) in [ us_heavy_gun , ru_heavy_gun , ru_rocket ] then
60220: LD_VAR 0 6
60224: PPUSH
60225: CALL_OW 264
60229: PUSH
60230: LD_INT 6
60232: PUSH
60233: LD_INT 46
60235: PUSH
60236: LD_INT 47
60238: PUSH
60239: EMPTY
60240: LIST
60241: LIST
60242: LIST
60243: IN
60244: IFFALSE 60261
// bpoints := bpoints * 1.2 ;
60246: LD_ADDR_VAR 0 10
60250: PUSH
60251: LD_VAR 0 10
60255: PUSH
60256: LD_REAL  1.20000000000000E+0000
60259: MUL
60260: ST_TO_ADDR
// end ; unit_building :
60261: GO 60275
60263: LD_INT 3
60265: DOUBLE
60266: EQUAL
60267: IFTRUE 60271
60269: GO 60274
60271: POP
// ; end ;
60272: GO 60275
60274: POP
// for j = 1 to 3 do
60275: LD_ADDR_VAR 0 7
60279: PUSH
60280: DOUBLE
60281: LD_INT 1
60283: DEC
60284: ST_TO_ADDR
60285: LD_INT 3
60287: PUSH
60288: FOR_TO
60289: IFFALSE 60342
// result := Replace ( result , j , result [ j ] + ( points [ j ] * bpoints ) ) ;
60291: LD_ADDR_VAR 0 5
60295: PUSH
60296: LD_VAR 0 5
60300: PPUSH
60301: LD_VAR 0 7
60305: PPUSH
60306: LD_VAR 0 5
60310: PUSH
60311: LD_VAR 0 7
60315: ARRAY
60316: PUSH
60317: LD_VAR 0 9
60321: PUSH
60322: LD_VAR 0 7
60326: ARRAY
60327: PUSH
60328: LD_VAR 0 10
60332: MUL
60333: PLUS
60334: PPUSH
60335: CALL_OW 1
60339: ST_TO_ADDR
60340: GO 60288
60342: POP
60343: POP
// end ;
60344: GO 58827
60346: POP
60347: POP
// result := Replace ( result , 4 , tmp ) ;
60348: LD_ADDR_VAR 0 5
60352: PUSH
60353: LD_VAR 0 5
60357: PPUSH
60358: LD_INT 4
60360: PPUSH
60361: LD_VAR 0 8
60365: PPUSH
60366: CALL_OW 1
60370: ST_TO_ADDR
// end ;
60371: LD_VAR 0 5
60375: RET
// export function DangerAtRange ( unit , range ) ; begin
60376: LD_INT 0
60378: PPUSH
// result := DangerAtRangeXY ( GetSide ( unit ) , GetX ( unit ) , GetY ( unit ) , range ) ;
60379: LD_ADDR_VAR 0 3
60383: PUSH
60384: LD_VAR 0 1
60388: PPUSH
60389: CALL_OW 255
60393: PPUSH
60394: LD_VAR 0 1
60398: PPUSH
60399: CALL_OW 250
60403: PPUSH
60404: LD_VAR 0 1
60408: PPUSH
60409: CALL_OW 251
60413: PPUSH
60414: LD_VAR 0 2
60418: PPUSH
60419: CALL 58679 0 4
60423: ST_TO_ADDR
// end ;
60424: LD_VAR 0 3
60428: RET
// export function DangerInArea ( side , area ) ; begin
60429: LD_INT 0
60431: PPUSH
// result := FilterUnitsInArea ( area , [ f_enemy , side ] ) ;
60432: LD_ADDR_VAR 0 3
60436: PUSH
60437: LD_VAR 0 2
60441: PPUSH
60442: LD_INT 81
60444: PUSH
60445: LD_VAR 0 1
60449: PUSH
60450: EMPTY
60451: LIST
60452: LIST
60453: PPUSH
60454: CALL_OW 70
60458: ST_TO_ADDR
// end ;
60459: LD_VAR 0 3
60463: RET
// export function IsExtension ( b ) ; begin
60464: LD_INT 0
60466: PPUSH
// result := b in [ b_ext_stitch , b_ext_radar , b_ext_radio , b_ext_gun , b_ext_computer , b_ext_siberium , b_ext_noncombat , b_ext_track , b_ext_laser , b_ext_rocket ] ;
60467: LD_ADDR_VAR 0 2
60471: PUSH
60472: LD_VAR 0 1
60476: PUSH
60477: LD_INT 23
60479: PUSH
60480: LD_INT 20
60482: PUSH
60483: LD_INT 22
60485: PUSH
60486: LD_INT 17
60488: PUSH
60489: LD_INT 24
60491: PUSH
60492: LD_INT 21
60494: PUSH
60495: LD_INT 19
60497: PUSH
60498: LD_INT 16
60500: PUSH
60501: LD_INT 25
60503: PUSH
60504: LD_INT 18
60506: PUSH
60507: EMPTY
60508: LIST
60509: LIST
60510: LIST
60511: LIST
60512: LIST
60513: LIST
60514: LIST
60515: LIST
60516: LIST
60517: LIST
60518: IN
60519: ST_TO_ADDR
// end ;
60520: LD_VAR 0 2
60524: RET
// export function GetBaseBuildings ( base , area ) ; var tmp , i ; begin
60525: LD_INT 0
60527: PPUSH
60528: PPUSH
60529: PPUSH
// result := [ ] ;
60530: LD_ADDR_VAR 0 3
60534: PUSH
60535: EMPTY
60536: ST_TO_ADDR
// tmp := FilterUnitsInArea ( area , [ f_type , unit_building ] ) ;
60537: LD_ADDR_VAR 0 4
60541: PUSH
60542: LD_VAR 0 2
60546: PPUSH
60547: LD_INT 21
60549: PUSH
60550: LD_INT 3
60552: PUSH
60553: EMPTY
60554: LIST
60555: LIST
60556: PPUSH
60557: CALL_OW 70
60561: ST_TO_ADDR
// if not tmp then
60562: LD_VAR 0 4
60566: NOT
60567: IFFALSE 60571
// exit ;
60569: GO 60629
// for i in tmp do
60571: LD_ADDR_VAR 0 5
60575: PUSH
60576: LD_VAR 0 4
60580: PUSH
60581: FOR_IN
60582: IFFALSE 60617
// if GetBase ( i ) <> base then
60584: LD_VAR 0 5
60588: PPUSH
60589: CALL_OW 274
60593: PUSH
60594: LD_VAR 0 1
60598: NONEQUAL
60599: IFFALSE 60615
// ComLinkToBase ( base , i ) ;
60601: LD_VAR 0 1
60605: PPUSH
60606: LD_VAR 0 5
60610: PPUSH
60611: CALL_OW 169
60615: GO 60581
60617: POP
60618: POP
// result := tmp ;
60619: LD_ADDR_VAR 0 3
60623: PUSH
60624: LD_VAR 0 4
60628: ST_TO_ADDR
// end ;
60629: LD_VAR 0 3
60633: RET
// export function ComComplete ( unit , b ) ; var i ; begin
60634: LD_INT 0
60636: PPUSH
60637: PPUSH
// if BuildingStatus ( b ) = bs_build then
60638: LD_VAR 0 2
60642: PPUSH
60643: CALL_OW 461
60647: PUSH
60648: LD_INT 1
60650: EQUAL
60651: IFFALSE 60711
// SetTaskList ( unit , [ [ h , GetX ( b ) , GetY ( b ) , b , 0 , 0 , 0 ] ] ) ;
60653: LD_VAR 0 1
60657: PPUSH
60658: LD_STRING h
60660: PUSH
60661: LD_VAR 0 2
60665: PPUSH
60666: CALL_OW 250
60670: PUSH
60671: LD_VAR 0 2
60675: PPUSH
60676: CALL_OW 251
60680: PUSH
60681: LD_VAR 0 2
60685: PUSH
60686: LD_INT 0
60688: PUSH
60689: LD_INT 0
60691: PUSH
60692: LD_INT 0
60694: PUSH
60695: EMPTY
60696: LIST
60697: LIST
60698: LIST
60699: LIST
60700: LIST
60701: LIST
60702: LIST
60703: PUSH
60704: EMPTY
60705: LIST
60706: PPUSH
60707: CALL_OW 446
// end ;
60711: LD_VAR 0 3
60715: RET
// export function Connect ( vehicle ) ; var i , t , mech , tmp , j ; begin
60716: LD_INT 0
60718: PPUSH
60719: PPUSH
60720: PPUSH
60721: PPUSH
60722: PPUSH
60723: PPUSH
// if not vehicle or not GetControl ( vehicle ) = control_remote then
60724: LD_VAR 0 1
60728: NOT
60729: PUSH
60730: LD_VAR 0 1
60734: PPUSH
60735: CALL_OW 263
60739: PUSH
60740: LD_INT 2
60742: EQUAL
60743: NOT
60744: OR
60745: IFFALSE 60749
// exit ;
60747: GO 61065
// tmp := FilterAllUnits ( [ [ f_side , GetSide ( vehicle ) ] , [ f_or , [ f_btype , b_control_tower ] , [ f_weapon , ar_control_tower ] ] ] ) ;
60749: LD_ADDR_VAR 0 6
60753: PUSH
60754: LD_INT 22
60756: PUSH
60757: LD_VAR 0 1
60761: PPUSH
60762: CALL_OW 255
60766: PUSH
60767: EMPTY
60768: LIST
60769: LIST
60770: PUSH
60771: LD_INT 2
60773: PUSH
60774: LD_INT 30
60776: PUSH
60777: LD_INT 36
60779: PUSH
60780: EMPTY
60781: LIST
60782: LIST
60783: PUSH
60784: LD_INT 34
60786: PUSH
60787: LD_INT 31
60789: PUSH
60790: EMPTY
60791: LIST
60792: LIST
60793: PUSH
60794: EMPTY
60795: LIST
60796: LIST
60797: LIST
60798: PUSH
60799: EMPTY
60800: LIST
60801: LIST
60802: PPUSH
60803: CALL_OW 69
60807: ST_TO_ADDR
// if not tmp then
60808: LD_VAR 0 6
60812: NOT
60813: IFFALSE 60817
// exit ;
60815: GO 61065
// result := [ ] ;
60817: LD_ADDR_VAR 0 2
60821: PUSH
60822: EMPTY
60823: ST_TO_ADDR
// for i in tmp do
60824: LD_ADDR_VAR 0 3
60828: PUSH
60829: LD_VAR 0 6
60833: PUSH
60834: FOR_IN
60835: IFFALSE 60906
// begin t := UnitsInside ( i ) ;
60837: LD_ADDR_VAR 0 4
60841: PUSH
60842: LD_VAR 0 3
60846: PPUSH
60847: CALL_OW 313
60851: ST_TO_ADDR
// if t then
60852: LD_VAR 0 4
60856: IFFALSE 60904
// for j in t do
60858: LD_ADDR_VAR 0 7
60862: PUSH
60863: LD_VAR 0 4
60867: PUSH
60868: FOR_IN
60869: IFFALSE 60902
// result := Insert ( result , result + 1 , j ) ;
60871: LD_ADDR_VAR 0 2
60875: PUSH
60876: LD_VAR 0 2
60880: PPUSH
60881: LD_VAR 0 2
60885: PUSH
60886: LD_INT 1
60888: PLUS
60889: PPUSH
60890: LD_VAR 0 7
60894: PPUSH
60895: CALL_OW 2
60899: ST_TO_ADDR
60900: GO 60868
60902: POP
60903: POP
// end ;
60904: GO 60834
60906: POP
60907: POP
// if not result then
60908: LD_VAR 0 2
60912: NOT
60913: IFFALSE 60917
// exit ;
60915: GO 61065
// mech := result [ 1 ] ;
60917: LD_ADDR_VAR 0 5
60921: PUSH
60922: LD_VAR 0 2
60926: PUSH
60927: LD_INT 1
60929: ARRAY
60930: ST_TO_ADDR
// if result > 1 then
60931: LD_VAR 0 2
60935: PUSH
60936: LD_INT 1
60938: GREATER
60939: IFFALSE 61051
// for i = 2 to result do
60941: LD_ADDR_VAR 0 3
60945: PUSH
60946: DOUBLE
60947: LD_INT 2
60949: DEC
60950: ST_TO_ADDR
60951: LD_VAR 0 2
60955: PUSH
60956: FOR_TO
60957: IFFALSE 61049
// begin t := GetSkill ( result [ i ] , 3 ) - UnitsLinked ( result [ i ] ) ;
60959: LD_ADDR_VAR 0 4
60963: PUSH
60964: LD_VAR 0 2
60968: PUSH
60969: LD_VAR 0 3
60973: ARRAY
60974: PPUSH
60975: LD_INT 3
60977: PPUSH
60978: CALL_OW 259
60982: PUSH
60983: LD_VAR 0 2
60987: PUSH
60988: LD_VAR 0 3
60992: ARRAY
60993: PPUSH
60994: CALL_OW 432
60998: MINUS
60999: ST_TO_ADDR
// if t >= ( GetSkill ( mech , 3 ) - UnitsLinked ( mech ) ) then
61000: LD_VAR 0 4
61004: PUSH
61005: LD_VAR 0 5
61009: PPUSH
61010: LD_INT 3
61012: PPUSH
61013: CALL_OW 259
61017: PUSH
61018: LD_VAR 0 5
61022: PPUSH
61023: CALL_OW 432
61027: MINUS
61028: GREATEREQUAL
61029: IFFALSE 61047
// mech := result [ i ] ;
61031: LD_ADDR_VAR 0 5
61035: PUSH
61036: LD_VAR 0 2
61040: PUSH
61041: LD_VAR 0 3
61045: ARRAY
61046: ST_TO_ADDR
// end ;
61047: GO 60956
61049: POP
61050: POP
// ComLinkTo ( vehicle , mech ) ;
61051: LD_VAR 0 1
61055: PPUSH
61056: LD_VAR 0 5
61060: PPUSH
61061: CALL_OW 135
// end ;
61065: LD_VAR 0 2
61069: RET
// export function PrepareBase ( base_dep , area , name , skill , sources , personel ) ; var i , j , d , b , f , x , un , base , side , nation , buildings , tmp ; begin
61070: LD_INT 0
61072: PPUSH
61073: PPUSH
61074: PPUSH
61075: PPUSH
61076: PPUSH
61077: PPUSH
61078: PPUSH
61079: PPUSH
61080: PPUSH
61081: PPUSH
61082: PPUSH
61083: PPUSH
61084: PPUSH
// result := [ ] ;
61085: LD_ADDR_VAR 0 7
61089: PUSH
61090: EMPTY
61091: ST_TO_ADDR
// if not GetBType ( base_dep ) in [ b_depot , b_warehouse ] then
61092: LD_VAR 0 1
61096: PPUSH
61097: CALL_OW 266
61101: PUSH
61102: LD_INT 0
61104: PUSH
61105: LD_INT 1
61107: PUSH
61108: EMPTY
61109: LIST
61110: LIST
61111: IN
61112: NOT
61113: IFFALSE 61117
// exit ;
61115: GO 62748
// if name then
61117: LD_VAR 0 3
61121: IFFALSE 61137
// SetBName ( base_dep , name ) ;
61123: LD_VAR 0 1
61127: PPUSH
61128: LD_VAR 0 3
61132: PPUSH
61133: CALL_OW 500
// base := GetBase ( base_dep ) ;
61137: LD_ADDR_VAR 0 15
61141: PUSH
61142: LD_VAR 0 1
61146: PPUSH
61147: CALL_OW 274
61151: ST_TO_ADDR
// side := GetSide ( base_dep ) ;
61152: LD_ADDR_VAR 0 16
61156: PUSH
61157: LD_VAR 0 1
61161: PPUSH
61162: CALL_OW 255
61166: ST_TO_ADDR
// nation := GetNation ( base_dep ) ;
61167: LD_ADDR_VAR 0 17
61171: PUSH
61172: LD_VAR 0 1
61176: PPUSH
61177: CALL_OW 248
61181: ST_TO_ADDR
// if sources then
61182: LD_VAR 0 5
61186: IFFALSE 61233
// for i = 1 to 3 do
61188: LD_ADDR_VAR 0 8
61192: PUSH
61193: DOUBLE
61194: LD_INT 1
61196: DEC
61197: ST_TO_ADDR
61198: LD_INT 3
61200: PUSH
61201: FOR_TO
61202: IFFALSE 61231
// AddResourceType ( base , i , sources [ i ] ) ;
61204: LD_VAR 0 15
61208: PPUSH
61209: LD_VAR 0 8
61213: PPUSH
61214: LD_VAR 0 5
61218: PUSH
61219: LD_VAR 0 8
61223: ARRAY
61224: PPUSH
61225: CALL_OW 276
61229: GO 61201
61231: POP
61232: POP
// buildings := GetBaseBuildings ( base , area ) ;
61233: LD_ADDR_VAR 0 18
61237: PUSH
61238: LD_VAR 0 15
61242: PPUSH
61243: LD_VAR 0 2
61247: PPUSH
61248: CALL 60525 0 2
61252: ST_TO_ADDR
// InitHc ;
61253: CALL_OW 19
// InitUc ;
61257: CALL_OW 18
// uc_side := side ;
61261: LD_ADDR_OWVAR 20
61265: PUSH
61266: LD_VAR 0 16
61270: ST_TO_ADDR
// uc_nation := nation ;
61271: LD_ADDR_OWVAR 21
61275: PUSH
61276: LD_VAR 0 17
61280: ST_TO_ADDR
// if buildings then
61281: LD_VAR 0 18
61285: IFFALSE 62607
// begin tmp := UnitFilter ( buildings , [ f_or , [ f_btype , b_oil_mine ] , [ f_btype , b_siberite_mine ] ] ) ;
61287: LD_ADDR_VAR 0 19
61291: PUSH
61292: LD_VAR 0 18
61296: PPUSH
61297: LD_INT 2
61299: PUSH
61300: LD_INT 30
61302: PUSH
61303: LD_INT 29
61305: PUSH
61306: EMPTY
61307: LIST
61308: LIST
61309: PUSH
61310: LD_INT 30
61312: PUSH
61313: LD_INT 30
61315: PUSH
61316: EMPTY
61317: LIST
61318: LIST
61319: PUSH
61320: EMPTY
61321: LIST
61322: LIST
61323: LIST
61324: PPUSH
61325: CALL_OW 72
61329: ST_TO_ADDR
// if tmp then
61330: LD_VAR 0 19
61334: IFFALSE 61382
// for i in tmp do
61336: LD_ADDR_VAR 0 8
61340: PUSH
61341: LD_VAR 0 19
61345: PUSH
61346: FOR_IN
61347: IFFALSE 61380
// SetResourceVisibility ( GetX ( i ) , GetY ( i ) , side ) ;
61349: LD_VAR 0 8
61353: PPUSH
61354: CALL_OW 250
61358: PPUSH
61359: LD_VAR 0 8
61363: PPUSH
61364: CALL_OW 251
61368: PPUSH
61369: LD_VAR 0 16
61373: PPUSH
61374: CALL_OW 441
61378: GO 61346
61380: POP
61381: POP
// if UnitFilter ( buildings , [ f_or , [ f_btype , b_bunker ] , [ f_btype , b_turret ] ] ) then
61382: LD_VAR 0 18
61386: PPUSH
61387: LD_INT 2
61389: PUSH
61390: LD_INT 30
61392: PUSH
61393: LD_INT 32
61395: PUSH
61396: EMPTY
61397: LIST
61398: LIST
61399: PUSH
61400: LD_INT 30
61402: PUSH
61403: LD_INT 33
61405: PUSH
61406: EMPTY
61407: LIST
61408: LIST
61409: PUSH
61410: EMPTY
61411: LIST
61412: LIST
61413: LIST
61414: PPUSH
61415: CALL_OW 72
61419: IFFALSE 61507
// begin for i in UnitFilter ( buildings , [ f_or , [ f_btype , b_bunker ] , [ f_btype , b_turret ] ] ) do
61421: LD_ADDR_VAR 0 8
61425: PUSH
61426: LD_VAR 0 18
61430: PPUSH
61431: LD_INT 2
61433: PUSH
61434: LD_INT 30
61436: PUSH
61437: LD_INT 32
61439: PUSH
61440: EMPTY
61441: LIST
61442: LIST
61443: PUSH
61444: LD_INT 30
61446: PUSH
61447: LD_INT 33
61449: PUSH
61450: EMPTY
61451: LIST
61452: LIST
61453: PUSH
61454: EMPTY
61455: LIST
61456: LIST
61457: LIST
61458: PPUSH
61459: CALL_OW 72
61463: PUSH
61464: FOR_IN
61465: IFFALSE 61505
// begin if not GetBWeapon ( i ) then
61467: LD_VAR 0 8
61471: PPUSH
61472: CALL_OW 269
61476: NOT
61477: IFFALSE 61503
// PlaceWeaponTurret ( i , GetTurretWeapon ( i , area ) ) ;
61479: LD_VAR 0 8
61483: PPUSH
61484: LD_VAR 0 8
61488: PPUSH
61489: LD_VAR 0 2
61493: PPUSH
61494: CALL 62753 0 2
61498: PPUSH
61499: CALL_OW 431
// end ;
61503: GO 61464
61505: POP
61506: POP
// end ; for i = 1 to personel do
61507: LD_ADDR_VAR 0 8
61511: PUSH
61512: DOUBLE
61513: LD_INT 1
61515: DEC
61516: ST_TO_ADDR
61517: LD_VAR 0 6
61521: PUSH
61522: FOR_TO
61523: IFFALSE 62587
// begin if i > 4 then
61525: LD_VAR 0 8
61529: PUSH
61530: LD_INT 4
61532: GREATER
61533: IFFALSE 61537
// break ;
61535: GO 62587
// case i of 1 :
61537: LD_VAR 0 8
61541: PUSH
61542: LD_INT 1
61544: DOUBLE
61545: EQUAL
61546: IFTRUE 61550
61548: GO 61630
61550: POP
// f := UnitFilter ( buildings , [ [ f_side , side ] , [ f_empty ] , [ f_or , [ f_btype , b_bunker ] , [ f_btype , b_armoury ] , [ f_btype , b_barracks ] ] ] ) ; 2 :
61551: LD_ADDR_VAR 0 12
61555: PUSH
61556: LD_VAR 0 18
61560: PPUSH
61561: LD_INT 22
61563: PUSH
61564: LD_VAR 0 16
61568: PUSH
61569: EMPTY
61570: LIST
61571: LIST
61572: PUSH
61573: LD_INT 58
61575: PUSH
61576: EMPTY
61577: LIST
61578: PUSH
61579: LD_INT 2
61581: PUSH
61582: LD_INT 30
61584: PUSH
61585: LD_INT 32
61587: PUSH
61588: EMPTY
61589: LIST
61590: LIST
61591: PUSH
61592: LD_INT 30
61594: PUSH
61595: LD_INT 4
61597: PUSH
61598: EMPTY
61599: LIST
61600: LIST
61601: PUSH
61602: LD_INT 30
61604: PUSH
61605: LD_INT 5
61607: PUSH
61608: EMPTY
61609: LIST
61610: LIST
61611: PUSH
61612: EMPTY
61613: LIST
61614: LIST
61615: LIST
61616: LIST
61617: PUSH
61618: EMPTY
61619: LIST
61620: LIST
61621: LIST
61622: PPUSH
61623: CALL_OW 72
61627: ST_TO_ADDR
61628: GO 61852
61630: LD_INT 2
61632: DOUBLE
61633: EQUAL
61634: IFTRUE 61638
61636: GO 61700
61638: POP
// f := UnitFilter ( buildings , [ [ f_side , side ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ] ) ; 3 :
61639: LD_ADDR_VAR 0 12
61643: PUSH
61644: LD_VAR 0 18
61648: PPUSH
61649: LD_INT 22
61651: PUSH
61652: LD_VAR 0 16
61656: PUSH
61657: EMPTY
61658: LIST
61659: LIST
61660: PUSH
61661: LD_INT 2
61663: PUSH
61664: LD_INT 30
61666: PUSH
61667: LD_INT 0
61669: PUSH
61670: EMPTY
61671: LIST
61672: LIST
61673: PUSH
61674: LD_INT 30
61676: PUSH
61677: LD_INT 1
61679: PUSH
61680: EMPTY
61681: LIST
61682: LIST
61683: PUSH
61684: EMPTY
61685: LIST
61686: LIST
61687: LIST
61688: PUSH
61689: EMPTY
61690: LIST
61691: LIST
61692: PPUSH
61693: CALL_OW 72
61697: ST_TO_ADDR
61698: GO 61852
61700: LD_INT 3
61702: DOUBLE
61703: EQUAL
61704: IFTRUE 61708
61706: GO 61770
61708: POP
// f := UnitFilter ( buildings , [ [ f_side , side ] , [ f_or , [ f_btype , b_workshop ] , [ f_btype , b_factory ] ] ] ) ; 4 :
61709: LD_ADDR_VAR 0 12
61713: PUSH
61714: LD_VAR 0 18
61718: PPUSH
61719: LD_INT 22
61721: PUSH
61722: LD_VAR 0 16
61726: PUSH
61727: EMPTY
61728: LIST
61729: LIST
61730: PUSH
61731: LD_INT 2
61733: PUSH
61734: LD_INT 30
61736: PUSH
61737: LD_INT 2
61739: PUSH
61740: EMPTY
61741: LIST
61742: LIST
61743: PUSH
61744: LD_INT 30
61746: PUSH
61747: LD_INT 3
61749: PUSH
61750: EMPTY
61751: LIST
61752: LIST
61753: PUSH
61754: EMPTY
61755: LIST
61756: LIST
61757: LIST
61758: PUSH
61759: EMPTY
61760: LIST
61761: LIST
61762: PPUSH
61763: CALL_OW 72
61767: ST_TO_ADDR
61768: GO 61852
61770: LD_INT 4
61772: DOUBLE
61773: EQUAL
61774: IFTRUE 61778
61776: GO 61851
61778: POP
// f := UnitFilter ( buildings , [ [ f_side , side ] , [ f_or , [ f_btype , b_lab ] , [ f_btype , b_lab_half ] , [ f_btype , b_lab_full ] ] ] ) ; end ;
61779: LD_ADDR_VAR 0 12
61783: PUSH
61784: LD_VAR 0 18
61788: PPUSH
61789: LD_INT 22
61791: PUSH
61792: LD_VAR 0 16
61796: PUSH
61797: EMPTY
61798: LIST
61799: LIST
61800: PUSH
61801: LD_INT 2
61803: PUSH
61804: LD_INT 30
61806: PUSH
61807: LD_INT 6
61809: PUSH
61810: EMPTY
61811: LIST
61812: LIST
61813: PUSH
61814: LD_INT 30
61816: PUSH
61817: LD_INT 7
61819: PUSH
61820: EMPTY
61821: LIST
61822: LIST
61823: PUSH
61824: LD_INT 30
61826: PUSH
61827: LD_INT 8
61829: PUSH
61830: EMPTY
61831: LIST
61832: LIST
61833: PUSH
61834: EMPTY
61835: LIST
61836: LIST
61837: LIST
61838: LIST
61839: PUSH
61840: EMPTY
61841: LIST
61842: LIST
61843: PPUSH
61844: CALL_OW 72
61848: ST_TO_ADDR
61849: GO 61852
61851: POP
// if i = 1 then
61852: LD_VAR 0 8
61856: PUSH
61857: LD_INT 1
61859: EQUAL
61860: IFFALSE 61971
// begin tmp := [ ] ;
61862: LD_ADDR_VAR 0 19
61866: PUSH
61867: EMPTY
61868: ST_TO_ADDR
// for j in f do
61869: LD_ADDR_VAR 0 9
61873: PUSH
61874: LD_VAR 0 12
61878: PUSH
61879: FOR_IN
61880: IFFALSE 61953
// if GetBType ( j ) = b_bunker then
61882: LD_VAR 0 9
61886: PPUSH
61887: CALL_OW 266
61891: PUSH
61892: LD_INT 32
61894: EQUAL
61895: IFFALSE 61922
// tmp := Insert ( tmp , 1 , j ) else
61897: LD_ADDR_VAR 0 19
61901: PUSH
61902: LD_VAR 0 19
61906: PPUSH
61907: LD_INT 1
61909: PPUSH
61910: LD_VAR 0 9
61914: PPUSH
61915: CALL_OW 2
61919: ST_TO_ADDR
61920: GO 61951
// tmp := Insert ( tmp , tmp + 1 , j ) ;
61922: LD_ADDR_VAR 0 19
61926: PUSH
61927: LD_VAR 0 19
61931: PPUSH
61932: LD_VAR 0 19
61936: PUSH
61937: LD_INT 1
61939: PLUS
61940: PPUSH
61941: LD_VAR 0 9
61945: PPUSH
61946: CALL_OW 2
61950: ST_TO_ADDR
61951: GO 61879
61953: POP
61954: POP
// if tmp then
61955: LD_VAR 0 19
61959: IFFALSE 61971
// f := tmp ;
61961: LD_ADDR_VAR 0 12
61965: PUSH
61966: LD_VAR 0 19
61970: ST_TO_ADDR
// end ; x := personel [ i ] ;
61971: LD_ADDR_VAR 0 13
61975: PUSH
61976: LD_VAR 0 6
61980: PUSH
61981: LD_VAR 0 8
61985: ARRAY
61986: ST_TO_ADDR
// if x = - 1 then
61987: LD_VAR 0 13
61991: PUSH
61992: LD_INT 1
61994: NEG
61995: EQUAL
61996: IFFALSE 62205
// begin for j in f do
61998: LD_ADDR_VAR 0 9
62002: PUSH
62003: LD_VAR 0 12
62007: PUSH
62008: FOR_IN
62009: IFFALSE 62201
// repeat InitHc ;
62011: CALL_OW 19
// if GetBType ( j ) = b_barracks then
62015: LD_VAR 0 9
62019: PPUSH
62020: CALL_OW 266
62024: PUSH
62025: LD_INT 5
62027: EQUAL
62028: IFFALSE 62098
// begin if UnitsInside ( j ) < 3 then
62030: LD_VAR 0 9
62034: PPUSH
62035: CALL_OW 313
62039: PUSH
62040: LD_INT 3
62042: LESS
62043: IFFALSE 62079
// PrepareHuman ( false , [ class_sniper , class_mortar , class_bazooker ] [ nation ] , skill ) else
62045: LD_INT 0
62047: PPUSH
62048: LD_INT 5
62050: PUSH
62051: LD_INT 8
62053: PUSH
62054: LD_INT 9
62056: PUSH
62057: EMPTY
62058: LIST
62059: LIST
62060: LIST
62061: PUSH
62062: LD_VAR 0 17
62066: ARRAY
62067: PPUSH
62068: LD_VAR 0 4
62072: PPUSH
62073: CALL_OW 380
62077: GO 62096
// PrepareHuman ( false , i , skill ) ;
62079: LD_INT 0
62081: PPUSH
62082: LD_VAR 0 8
62086: PPUSH
62087: LD_VAR 0 4
62091: PPUSH
62092: CALL_OW 380
// end else
62096: GO 62115
// PrepareHuman ( false , i , skill ) ;
62098: LD_INT 0
62100: PPUSH
62101: LD_VAR 0 8
62105: PPUSH
62106: LD_VAR 0 4
62110: PPUSH
62111: CALL_OW 380
// un := CreateHuman ;
62115: LD_ADDR_VAR 0 14
62119: PUSH
62120: CALL_OW 44
62124: ST_TO_ADDR
// result := Insert ( result , 1 , un ) ;
62125: LD_ADDR_VAR 0 7
62129: PUSH
62130: LD_VAR 0 7
62134: PPUSH
62135: LD_INT 1
62137: PPUSH
62138: LD_VAR 0 14
62142: PPUSH
62143: CALL_OW 2
62147: ST_TO_ADDR
// PlaceHumanInUnit ( un , j ) ;
62148: LD_VAR 0 14
62152: PPUSH
62153: LD_VAR 0 9
62157: PPUSH
62158: CALL_OW 52
// until UnitsInside ( j ) = 6 or GetBType ( j ) in [ b_bunker , b_breastwork ] ;
62162: LD_VAR 0 9
62166: PPUSH
62167: CALL_OW 313
62171: PUSH
62172: LD_INT 6
62174: EQUAL
62175: PUSH
62176: LD_VAR 0 9
62180: PPUSH
62181: CALL_OW 266
62185: PUSH
62186: LD_INT 32
62188: PUSH
62189: LD_INT 31
62191: PUSH
62192: EMPTY
62193: LIST
62194: LIST
62195: IN
62196: OR
62197: IFFALSE 62011
62199: GO 62008
62201: POP
62202: POP
// end else
62203: GO 62585
// for j = 1 to x do
62205: LD_ADDR_VAR 0 9
62209: PUSH
62210: DOUBLE
62211: LD_INT 1
62213: DEC
62214: ST_TO_ADDR
62215: LD_VAR 0 13
62219: PUSH
62220: FOR_TO
62221: IFFALSE 62583
// begin InitHc ;
62223: CALL_OW 19
// if not f then
62227: LD_VAR 0 12
62231: NOT
62232: IFFALSE 62321
// begin PrepareHuman ( false , i , skill ) ;
62234: LD_INT 0
62236: PPUSH
62237: LD_VAR 0 8
62241: PPUSH
62242: LD_VAR 0 4
62246: PPUSH
62247: CALL_OW 380
// un := CreateHuman ;
62251: LD_ADDR_VAR 0 14
62255: PUSH
62256: CALL_OW 44
62260: ST_TO_ADDR
// result := Insert ( result , 1 , un ) ;
62261: LD_ADDR_VAR 0 7
62265: PUSH
62266: LD_VAR 0 7
62270: PPUSH
62271: LD_INT 1
62273: PPUSH
62274: LD_VAR 0 14
62278: PPUSH
62279: CALL_OW 2
62283: ST_TO_ADDR
// PlaceUnitXYR ( un , GetX ( base_dep ) , GetY ( base_dep ) , 10 , false ) ;
62284: LD_VAR 0 14
62288: PPUSH
62289: LD_VAR 0 1
62293: PPUSH
62294: CALL_OW 250
62298: PPUSH
62299: LD_VAR 0 1
62303: PPUSH
62304: CALL_OW 251
62308: PPUSH
62309: LD_INT 10
62311: PPUSH
62312: LD_INT 0
62314: PPUSH
62315: CALL_OW 50
// continue ;
62319: GO 62220
// end ; if ( UnitsInside ( f [ 1 ] ) and GetBType ( f [ 1 ] ) in [ b_bunker , b_breastwork ] ) or ( UnitsInside ( f [ 1 ] ) = 6 ) then
62321: LD_VAR 0 12
62325: PUSH
62326: LD_INT 1
62328: ARRAY
62329: PPUSH
62330: CALL_OW 313
62334: PUSH
62335: LD_VAR 0 12
62339: PUSH
62340: LD_INT 1
62342: ARRAY
62343: PPUSH
62344: CALL_OW 266
62348: PUSH
62349: LD_INT 32
62351: PUSH
62352: LD_INT 31
62354: PUSH
62355: EMPTY
62356: LIST
62357: LIST
62358: IN
62359: AND
62360: PUSH
62361: LD_VAR 0 12
62365: PUSH
62366: LD_INT 1
62368: ARRAY
62369: PPUSH
62370: CALL_OW 313
62374: PUSH
62375: LD_INT 6
62377: EQUAL
62378: OR
62379: IFFALSE 62399
// f := Delete ( f , 1 ) ;
62381: LD_ADDR_VAR 0 12
62385: PUSH
62386: LD_VAR 0 12
62390: PPUSH
62391: LD_INT 1
62393: PPUSH
62394: CALL_OW 3
62398: ST_TO_ADDR
// if not f then
62399: LD_VAR 0 12
62403: NOT
62404: IFFALSE 62422
// begin x := x + 2 ;
62406: LD_ADDR_VAR 0 13
62410: PUSH
62411: LD_VAR 0 13
62415: PUSH
62416: LD_INT 2
62418: PLUS
62419: ST_TO_ADDR
// continue ;
62420: GO 62220
// end ; if GetBType ( f [ 1 ] ) = b_barracks then
62422: LD_VAR 0 12
62426: PUSH
62427: LD_INT 1
62429: ARRAY
62430: PPUSH
62431: CALL_OW 266
62435: PUSH
62436: LD_INT 5
62438: EQUAL
62439: IFFALSE 62513
// begin if UnitsInside ( f [ 1 ] ) < 3 then
62441: LD_VAR 0 12
62445: PUSH
62446: LD_INT 1
62448: ARRAY
62449: PPUSH
62450: CALL_OW 313
62454: PUSH
62455: LD_INT 3
62457: LESS
62458: IFFALSE 62494
// PrepareHuman ( false , [ class_sniper , class_mortar , class_bazooker ] [ nation ] , skill ) else
62460: LD_INT 0
62462: PPUSH
62463: LD_INT 5
62465: PUSH
62466: LD_INT 8
62468: PUSH
62469: LD_INT 9
62471: PUSH
62472: EMPTY
62473: LIST
62474: LIST
62475: LIST
62476: PUSH
62477: LD_VAR 0 17
62481: ARRAY
62482: PPUSH
62483: LD_VAR 0 4
62487: PPUSH
62488: CALL_OW 380
62492: GO 62511
// PrepareHuman ( false , i , skill ) ;
62494: LD_INT 0
62496: PPUSH
62497: LD_VAR 0 8
62501: PPUSH
62502: LD_VAR 0 4
62506: PPUSH
62507: CALL_OW 380
// end else
62511: GO 62530
// PrepareHuman ( false , i , skill ) ;
62513: LD_INT 0
62515: PPUSH
62516: LD_VAR 0 8
62520: PPUSH
62521: LD_VAR 0 4
62525: PPUSH
62526: CALL_OW 380
// un := CreateHuman ;
62530: LD_ADDR_VAR 0 14
62534: PUSH
62535: CALL_OW 44
62539: ST_TO_ADDR
// result := Insert ( result , 1 , un ) ;
62540: LD_ADDR_VAR 0 7
62544: PUSH
62545: LD_VAR 0 7
62549: PPUSH
62550: LD_INT 1
62552: PPUSH
62553: LD_VAR 0 14
62557: PPUSH
62558: CALL_OW 2
62562: ST_TO_ADDR
// PlaceHumanInUnit ( un , f [ 1 ] ) ;
62563: LD_VAR 0 14
62567: PPUSH
62568: LD_VAR 0 12
62572: PUSH
62573: LD_INT 1
62575: ARRAY
62576: PPUSH
62577: CALL_OW 52
// end ;
62581: GO 62220
62583: POP
62584: POP
// end ;
62585: GO 61522
62587: POP
62588: POP
// result := result ^ buildings ;
62589: LD_ADDR_VAR 0 7
62593: PUSH
62594: LD_VAR 0 7
62598: PUSH
62599: LD_VAR 0 18
62603: ADD
62604: ST_TO_ADDR
// end else
62605: GO 62748
// begin for i = 1 to personel do
62607: LD_ADDR_VAR 0 8
62611: PUSH
62612: DOUBLE
62613: LD_INT 1
62615: DEC
62616: ST_TO_ADDR
62617: LD_VAR 0 6
62621: PUSH
62622: FOR_TO
62623: IFFALSE 62746
// begin if i > 4 then
62625: LD_VAR 0 8
62629: PUSH
62630: LD_INT 4
62632: GREATER
62633: IFFALSE 62637
// break ;
62635: GO 62746
// x := personel [ i ] ;
62637: LD_ADDR_VAR 0 13
62641: PUSH
62642: LD_VAR 0 6
62646: PUSH
62647: LD_VAR 0 8
62651: ARRAY
62652: ST_TO_ADDR
// if x = - 1 then
62653: LD_VAR 0 13
62657: PUSH
62658: LD_INT 1
62660: NEG
62661: EQUAL
62662: IFFALSE 62666
// continue ;
62664: GO 62622
// PrepareHuman ( false , i , skill ) ;
62666: LD_INT 0
62668: PPUSH
62669: LD_VAR 0 8
62673: PPUSH
62674: LD_VAR 0 4
62678: PPUSH
62679: CALL_OW 380
// un := CreateHuman ;
62683: LD_ADDR_VAR 0 14
62687: PUSH
62688: CALL_OW 44
62692: ST_TO_ADDR
// PlaceUnitXYR ( un , GetX ( base_dep ) , GetY ( base_dep ) , 10 , false ) ;
62693: LD_VAR 0 14
62697: PPUSH
62698: LD_VAR 0 1
62702: PPUSH
62703: CALL_OW 250
62707: PPUSH
62708: LD_VAR 0 1
62712: PPUSH
62713: CALL_OW 251
62717: PPUSH
62718: LD_INT 10
62720: PPUSH
62721: LD_INT 0
62723: PPUSH
62724: CALL_OW 50
// result := result ^ un ;
62728: LD_ADDR_VAR 0 7
62732: PUSH
62733: LD_VAR 0 7
62737: PUSH
62738: LD_VAR 0 14
62742: ADD
62743: ST_TO_ADDR
// end ;
62744: GO 62622
62746: POP
62747: POP
// end ; end ;
62748: LD_VAR 0 7
62752: RET
// export function GetTurretWeapon ( tower , area ) ; var hex , list , factories , base , i , j , x , y , nat , h , tmp , height , side , fac_list , weapon ; begin
62753: LD_INT 0
62755: PPUSH
62756: PPUSH
62757: PPUSH
62758: PPUSH
62759: PPUSH
62760: PPUSH
62761: PPUSH
62762: PPUSH
62763: PPUSH
62764: PPUSH
62765: PPUSH
62766: PPUSH
62767: PPUSH
62768: PPUSH
62769: PPUSH
62770: PPUSH
// result := false ;
62771: LD_ADDR_VAR 0 3
62775: PUSH
62776: LD_INT 0
62778: ST_TO_ADDR
// if not tower or not GetBType ( tower ) in [ b_bunker , b_turret ] then
62779: LD_VAR 0 1
62783: NOT
62784: PUSH
62785: LD_VAR 0 1
62789: PPUSH
62790: CALL_OW 266
62794: PUSH
62795: LD_INT 32
62797: PUSH
62798: LD_INT 33
62800: PUSH
62801: EMPTY
62802: LIST
62803: LIST
62804: IN
62805: NOT
62806: OR
62807: IFFALSE 62811
// exit ;
62809: GO 63947
// nat := GetNation ( tower ) ;
62811: LD_ADDR_VAR 0 12
62815: PUSH
62816: LD_VAR 0 1
62820: PPUSH
62821: CALL_OW 248
62825: ST_TO_ADDR
// side := GetSide ( tower ) ;
62826: LD_ADDR_VAR 0 16
62830: PUSH
62831: LD_VAR 0 1
62835: PPUSH
62836: CALL_OW 255
62840: ST_TO_ADDR
// x := GetX ( tower ) ;
62841: LD_ADDR_VAR 0 10
62845: PUSH
62846: LD_VAR 0 1
62850: PPUSH
62851: CALL_OW 250
62855: ST_TO_ADDR
// y := GetY ( tower ) ;
62856: LD_ADDR_VAR 0 11
62860: PUSH
62861: LD_VAR 0 1
62865: PPUSH
62866: CALL_OW 251
62870: ST_TO_ADDR
// if not x or not y then
62871: LD_VAR 0 10
62875: NOT
62876: PUSH
62877: LD_VAR 0 11
62881: NOT
62882: OR
62883: IFFALSE 62887
// exit ;
62885: GO 63947
// weapon := 0 ;
62887: LD_ADDR_VAR 0 18
62891: PUSH
62892: LD_INT 0
62894: ST_TO_ADDR
// fac_list := [ ] ;
62895: LD_ADDR_VAR 0 17
62899: PUSH
62900: EMPTY
62901: ST_TO_ADDR
// factories := UnitFilter ( GetBaseBuildings ( GetBase ( tower ) , area ) , [ f_btype , b_factory ] ) ;
62902: LD_ADDR_VAR 0 6
62906: PUSH
62907: LD_VAR 0 1
62911: PPUSH
62912: CALL_OW 274
62916: PPUSH
62917: LD_VAR 0 2
62921: PPUSH
62922: CALL 60525 0 2
62926: PPUSH
62927: LD_INT 30
62929: PUSH
62930: LD_INT 3
62932: PUSH
62933: EMPTY
62934: LIST
62935: LIST
62936: PPUSH
62937: CALL_OW 72
62941: ST_TO_ADDR
// if not factories then
62942: LD_VAR 0 6
62946: NOT
62947: IFFALSE 62951
// exit ;
62949: GO 63947
// for i in factories do
62951: LD_ADDR_VAR 0 8
62955: PUSH
62956: LD_VAR 0 6
62960: PUSH
62961: FOR_IN
62962: IFFALSE 62987
// fac_list := fac_list union AvailableWeaponList ( i ) ;
62964: LD_ADDR_VAR 0 17
62968: PUSH
62969: LD_VAR 0 17
62973: PUSH
62974: LD_VAR 0 8
62978: PPUSH
62979: CALL_OW 478
62983: UNION
62984: ST_TO_ADDR
62985: GO 62961
62987: POP
62988: POP
// if not fac_list then
62989: LD_VAR 0 17
62993: NOT
62994: IFFALSE 62998
// exit ;
62996: GO 63947
// list := [ [ us_gatling_gun , us_double_gun , us_laser , us_double_laser , us_heavy_gun , us_rocket_launcher , us_radar ] , [ ar_gun , ar_rocket_launcher , ar_flame_thrower , ar_radar ] , [ ru_gatling_gun , ru_gun , ru_heavy_gun , ru_rocket_launcher , ru_rocket , ru_time_lapser ] ] [ nat ] ;
62998: LD_ADDR_VAR 0 5
63002: PUSH
63003: LD_INT 4
63005: PUSH
63006: LD_INT 5
63008: PUSH
63009: LD_INT 9
63011: PUSH
63012: LD_INT 10
63014: PUSH
63015: LD_INT 6
63017: PUSH
63018: LD_INT 7
63020: PUSH
63021: LD_INT 11
63023: PUSH
63024: EMPTY
63025: LIST
63026: LIST
63027: LIST
63028: LIST
63029: LIST
63030: LIST
63031: LIST
63032: PUSH
63033: LD_INT 27
63035: PUSH
63036: LD_INT 28
63038: PUSH
63039: LD_INT 26
63041: PUSH
63042: LD_INT 30
63044: PUSH
63045: EMPTY
63046: LIST
63047: LIST
63048: LIST
63049: LIST
63050: PUSH
63051: LD_INT 43
63053: PUSH
63054: LD_INT 44
63056: PUSH
63057: LD_INT 46
63059: PUSH
63060: LD_INT 45
63062: PUSH
63063: LD_INT 47
63065: PUSH
63066: LD_INT 49
63068: PUSH
63069: EMPTY
63070: LIST
63071: LIST
63072: LIST
63073: LIST
63074: LIST
63075: LIST
63076: PUSH
63077: EMPTY
63078: LIST
63079: LIST
63080: LIST
63081: PUSH
63082: LD_VAR 0 12
63086: ARRAY
63087: ST_TO_ADDR
// for i in list do
63088: LD_ADDR_VAR 0 8
63092: PUSH
63093: LD_VAR 0 5
63097: PUSH
63098: FOR_IN
63099: IFFALSE 63132
// if not i in fac_list then
63101: LD_VAR 0 8
63105: PUSH
63106: LD_VAR 0 17
63110: IN
63111: NOT
63112: IFFALSE 63130
// list := list diff i ;
63114: LD_ADDR_VAR 0 5
63118: PUSH
63119: LD_VAR 0 5
63123: PUSH
63124: LD_VAR 0 8
63128: DIFF
63129: ST_TO_ADDR
63130: GO 63098
63132: POP
63133: POP
// if not list then
63134: LD_VAR 0 5
63138: NOT
63139: IFFALSE 63143
// exit ;
63141: GO 63947
// if nat = nation_russian and ru_time_lapser in list and GetTech ( tech_lapser , side ) = state_researched then
63143: LD_VAR 0 12
63147: PUSH
63148: LD_INT 3
63150: EQUAL
63151: PUSH
63152: LD_INT 49
63154: PUSH
63155: LD_VAR 0 5
63159: IN
63160: AND
63161: PUSH
63162: LD_INT 31
63164: PPUSH
63165: LD_VAR 0 16
63169: PPUSH
63170: CALL_OW 321
63174: PUSH
63175: LD_INT 2
63177: EQUAL
63178: AND
63179: IFFALSE 63239
// begin if not FilterAllUnits ( [ [ f_side , side ] , [ f_bweapon , ru_time_lapser ] , [ f_dist , tower , 10 ] ] ) then
63181: LD_INT 22
63183: PUSH
63184: LD_VAR 0 16
63188: PUSH
63189: EMPTY
63190: LIST
63191: LIST
63192: PUSH
63193: LD_INT 35
63195: PUSH
63196: LD_INT 49
63198: PUSH
63199: EMPTY
63200: LIST
63201: LIST
63202: PUSH
63203: LD_INT 91
63205: PUSH
63206: LD_VAR 0 1
63210: PUSH
63211: LD_INT 10
63213: PUSH
63214: EMPTY
63215: LIST
63216: LIST
63217: LIST
63218: PUSH
63219: EMPTY
63220: LIST
63221: LIST
63222: LIST
63223: PPUSH
63224: CALL_OW 69
63228: NOT
63229: IFFALSE 63239
// weapon := ru_time_lapser ;
63231: LD_ADDR_VAR 0 18
63235: PUSH
63236: LD_INT 49
63238: ST_TO_ADDR
// end ; if nat in [ 1 , 2 ] and ( us_radar in list or ar_radar in list ) and GetTech ( tech_radar , side ) = state_researched then
63239: LD_VAR 0 12
63243: PUSH
63244: LD_INT 1
63246: PUSH
63247: LD_INT 2
63249: PUSH
63250: EMPTY
63251: LIST
63252: LIST
63253: IN
63254: PUSH
63255: LD_INT 11
63257: PUSH
63258: LD_VAR 0 5
63262: IN
63263: PUSH
63264: LD_INT 30
63266: PUSH
63267: LD_VAR 0 5
63271: IN
63272: OR
63273: AND
63274: PUSH
63275: LD_INT 6
63277: PPUSH
63278: LD_VAR 0 16
63282: PPUSH
63283: CALL_OW 321
63287: PUSH
63288: LD_INT 2
63290: EQUAL
63291: AND
63292: IFFALSE 63457
// begin if not FilterAllUnits ( [ [ f_side , side ] , [ f_or , [ f_bweapon , us_radar ] , [ f_bweapon , ar_radar ] ] , [ f_dist , tower , 18 ] ] ) and FilterAllUnits ( [ [ [ f_side , side ] , [ f_or , [ f_btype , b_bunker ] , [ f_btype , b_turret ] ] , [ f_dist , tower , 12 ] ] ] ) > 2 then
63294: LD_INT 22
63296: PUSH
63297: LD_VAR 0 16
63301: PUSH
63302: EMPTY
63303: LIST
63304: LIST
63305: PUSH
63306: LD_INT 2
63308: PUSH
63309: LD_INT 35
63311: PUSH
63312: LD_INT 11
63314: PUSH
63315: EMPTY
63316: LIST
63317: LIST
63318: PUSH
63319: LD_INT 35
63321: PUSH
63322: LD_INT 30
63324: PUSH
63325: EMPTY
63326: LIST
63327: LIST
63328: PUSH
63329: EMPTY
63330: LIST
63331: LIST
63332: LIST
63333: PUSH
63334: LD_INT 91
63336: PUSH
63337: LD_VAR 0 1
63341: PUSH
63342: LD_INT 18
63344: PUSH
63345: EMPTY
63346: LIST
63347: LIST
63348: LIST
63349: PUSH
63350: EMPTY
63351: LIST
63352: LIST
63353: LIST
63354: PPUSH
63355: CALL_OW 69
63359: NOT
63360: PUSH
63361: LD_INT 22
63363: PUSH
63364: LD_VAR 0 16
63368: PUSH
63369: EMPTY
63370: LIST
63371: LIST
63372: PUSH
63373: LD_INT 2
63375: PUSH
63376: LD_INT 30
63378: PUSH
63379: LD_INT 32
63381: PUSH
63382: EMPTY
63383: LIST
63384: LIST
63385: PUSH
63386: LD_INT 30
63388: PUSH
63389: LD_INT 33
63391: PUSH
63392: EMPTY
63393: LIST
63394: LIST
63395: PUSH
63396: EMPTY
63397: LIST
63398: LIST
63399: LIST
63400: PUSH
63401: LD_INT 91
63403: PUSH
63404: LD_VAR 0 1
63408: PUSH
63409: LD_INT 12
63411: PUSH
63412: EMPTY
63413: LIST
63414: LIST
63415: LIST
63416: PUSH
63417: EMPTY
63418: LIST
63419: LIST
63420: LIST
63421: PUSH
63422: EMPTY
63423: LIST
63424: PPUSH
63425: CALL_OW 69
63429: PUSH
63430: LD_INT 2
63432: GREATER
63433: AND
63434: IFFALSE 63457
// weapon := [ us_radar , ar_radar ] [ nat ] ;
63436: LD_ADDR_VAR 0 18
63440: PUSH
63441: LD_INT 11
63443: PUSH
63444: LD_INT 30
63446: PUSH
63447: EMPTY
63448: LIST
63449: LIST
63450: PUSH
63451: LD_VAR 0 12
63455: ARRAY
63456: ST_TO_ADDR
// end ; if not weapon and GetTech ( tech_rocket , side ) = state_researched and ( us_rocket_launcher in list or ar_rocket_launcher in list or ru_rocket_launcher in list ) then
63457: LD_VAR 0 18
63461: NOT
63462: PUSH
63463: LD_INT 40
63465: PPUSH
63466: LD_VAR 0 16
63470: PPUSH
63471: CALL_OW 321
63475: PUSH
63476: LD_INT 2
63478: EQUAL
63479: AND
63480: PUSH
63481: LD_INT 7
63483: PUSH
63484: LD_VAR 0 5
63488: IN
63489: PUSH
63490: LD_INT 28
63492: PUSH
63493: LD_VAR 0 5
63497: IN
63498: OR
63499: PUSH
63500: LD_INT 45
63502: PUSH
63503: LD_VAR 0 5
63507: IN
63508: OR
63509: AND
63510: IFFALSE 63764
// begin hex := GetHexInfo ( x , y ) ;
63512: LD_ADDR_VAR 0 4
63516: PUSH
63517: LD_VAR 0 10
63521: PPUSH
63522: LD_VAR 0 11
63526: PPUSH
63527: CALL_OW 546
63531: ST_TO_ADDR
// if hex [ 1 ] then
63532: LD_VAR 0 4
63536: PUSH
63537: LD_INT 1
63539: ARRAY
63540: IFFALSE 63544
// exit ;
63542: GO 63947
// height := hex [ 2 ] ;
63544: LD_ADDR_VAR 0 15
63548: PUSH
63549: LD_VAR 0 4
63553: PUSH
63554: LD_INT 2
63556: ARRAY
63557: ST_TO_ADDR
// tmp := [ 0 , 2 , 3 , 5 ] ;
63558: LD_ADDR_VAR 0 14
63562: PUSH
63563: LD_INT 0
63565: PUSH
63566: LD_INT 2
63568: PUSH
63569: LD_INT 3
63571: PUSH
63572: LD_INT 5
63574: PUSH
63575: EMPTY
63576: LIST
63577: LIST
63578: LIST
63579: LIST
63580: ST_TO_ADDR
// for i in tmp do
63581: LD_ADDR_VAR 0 8
63585: PUSH
63586: LD_VAR 0 14
63590: PUSH
63591: FOR_IN
63592: IFFALSE 63762
// begin j := [ ShiftX ( x , i , 5 ) , ShiftY ( y , i , 5 ) ] ;
63594: LD_ADDR_VAR 0 9
63598: PUSH
63599: LD_VAR 0 10
63603: PPUSH
63604: LD_VAR 0 8
63608: PPUSH
63609: LD_INT 5
63611: PPUSH
63612: CALL_OW 272
63616: PUSH
63617: LD_VAR 0 11
63621: PPUSH
63622: LD_VAR 0 8
63626: PPUSH
63627: LD_INT 5
63629: PPUSH
63630: CALL_OW 273
63634: PUSH
63635: EMPTY
63636: LIST
63637: LIST
63638: ST_TO_ADDR
// if ValidHex ( j [ 1 ] , j [ 2 ] ) then
63639: LD_VAR 0 9
63643: PUSH
63644: LD_INT 1
63646: ARRAY
63647: PPUSH
63648: LD_VAR 0 9
63652: PUSH
63653: LD_INT 2
63655: ARRAY
63656: PPUSH
63657: CALL_OW 488
63661: IFFALSE 63760
// begin hex := GetHexInfo ( j [ 1 ] , j [ 2 ] ) ;
63663: LD_ADDR_VAR 0 4
63667: PUSH
63668: LD_VAR 0 9
63672: PUSH
63673: LD_INT 1
63675: ARRAY
63676: PPUSH
63677: LD_VAR 0 9
63681: PUSH
63682: LD_INT 2
63684: ARRAY
63685: PPUSH
63686: CALL_OW 546
63690: ST_TO_ADDR
// if hex [ 1 ] then
63691: LD_VAR 0 4
63695: PUSH
63696: LD_INT 1
63698: ARRAY
63699: IFFALSE 63703
// continue ;
63701: GO 63591
// h := hex [ 2 ] ;
63703: LD_ADDR_VAR 0 13
63707: PUSH
63708: LD_VAR 0 4
63712: PUSH
63713: LD_INT 2
63715: ARRAY
63716: ST_TO_ADDR
// if h + 7 < height then
63717: LD_VAR 0 13
63721: PUSH
63722: LD_INT 7
63724: PLUS
63725: PUSH
63726: LD_VAR 0 15
63730: LESS
63731: IFFALSE 63760
// begin weapon := [ us_rocket_launcher , ar_rocket_launcher , ru_rocket_launcher ] [ nat ] ;
63733: LD_ADDR_VAR 0 18
63737: PUSH
63738: LD_INT 7
63740: PUSH
63741: LD_INT 28
63743: PUSH
63744: LD_INT 45
63746: PUSH
63747: EMPTY
63748: LIST
63749: LIST
63750: LIST
63751: PUSH
63752: LD_VAR 0 12
63756: ARRAY
63757: ST_TO_ADDR
// break ;
63758: GO 63762
// end ; end ; end ;
63760: GO 63591
63762: POP
63763: POP
// end ; if not weapon then
63764: LD_VAR 0 18
63768: NOT
63769: IFFALSE 63829
// begin list := list diff [ us_radar , ar_radar , ru_time_lapser ] ;
63771: LD_ADDR_VAR 0 5
63775: PUSH
63776: LD_VAR 0 5
63780: PUSH
63781: LD_INT 11
63783: PUSH
63784: LD_INT 30
63786: PUSH
63787: LD_INT 49
63789: PUSH
63790: EMPTY
63791: LIST
63792: LIST
63793: LIST
63794: DIFF
63795: ST_TO_ADDR
// if not list then
63796: LD_VAR 0 5
63800: NOT
63801: IFFALSE 63805
// exit ;
63803: GO 63947
// weapon := list [ rand ( 1 , list ) ] ;
63805: LD_ADDR_VAR 0 18
63809: PUSH
63810: LD_VAR 0 5
63814: PUSH
63815: LD_INT 1
63817: PPUSH
63818: LD_VAR 0 5
63822: PPUSH
63823: CALL_OW 12
63827: ARRAY
63828: ST_TO_ADDR
// end ; if weapon then
63829: LD_VAR 0 18
63833: IFFALSE 63947
// begin tmp := CostOfWeapon ( weapon ) ;
63835: LD_ADDR_VAR 0 14
63839: PUSH
63840: LD_VAR 0 18
63844: PPUSH
63845: CALL_OW 451
63849: ST_TO_ADDR
// j := GetBase ( tower ) ;
63850: LD_ADDR_VAR 0 9
63854: PUSH
63855: LD_VAR 0 1
63859: PPUSH
63860: CALL_OW 274
63864: ST_TO_ADDR
// if GetResourceType ( j , mat_cans ) >= tmp [ 1 ] and GetResourceType ( j , mat_oil ) >= tmp [ 2 ] and GetResourceType ( j , mat_siberit ) >= tmp [ 3 ] then
63865: LD_VAR 0 9
63869: PPUSH
63870: LD_INT 1
63872: PPUSH
63873: CALL_OW 275
63877: PUSH
63878: LD_VAR 0 14
63882: PUSH
63883: LD_INT 1
63885: ARRAY
63886: GREATEREQUAL
63887: PUSH
63888: LD_VAR 0 9
63892: PPUSH
63893: LD_INT 2
63895: PPUSH
63896: CALL_OW 275
63900: PUSH
63901: LD_VAR 0 14
63905: PUSH
63906: LD_INT 2
63908: ARRAY
63909: GREATEREQUAL
63910: AND
63911: PUSH
63912: LD_VAR 0 9
63916: PPUSH
63917: LD_INT 3
63919: PPUSH
63920: CALL_OW 275
63924: PUSH
63925: LD_VAR 0 14
63929: PUSH
63930: LD_INT 3
63932: ARRAY
63933: GREATEREQUAL
63934: AND
63935: IFFALSE 63947
// result := weapon ;
63937: LD_ADDR_VAR 0 3
63941: PUSH
63942: LD_VAR 0 18
63946: ST_TO_ADDR
// end ; end ;
63947: LD_VAR 0 3
63951: RET
// export function CompareArray ( array1 , array2 ) ; var i ; begin
63952: LD_INT 0
63954: PPUSH
63955: PPUSH
// result := true ;
63956: LD_ADDR_VAR 0 3
63960: PUSH
63961: LD_INT 1
63963: ST_TO_ADDR
// if array1 = array2 then
63964: LD_VAR 0 1
63968: PUSH
63969: LD_VAR 0 2
63973: EQUAL
63974: IFFALSE 64034
// begin for i = 1 to array1 do
63976: LD_ADDR_VAR 0 4
63980: PUSH
63981: DOUBLE
63982: LD_INT 1
63984: DEC
63985: ST_TO_ADDR
63986: LD_VAR 0 1
63990: PUSH
63991: FOR_TO
63992: IFFALSE 64030
// if array1 [ i ] <> array2 [ i ] then
63994: LD_VAR 0 1
63998: PUSH
63999: LD_VAR 0 4
64003: ARRAY
64004: PUSH
64005: LD_VAR 0 2
64009: PUSH
64010: LD_VAR 0 4
64014: ARRAY
64015: NONEQUAL
64016: IFFALSE 64028
// begin result := false ;
64018: LD_ADDR_VAR 0 3
64022: PUSH
64023: LD_INT 0
64025: ST_TO_ADDR
// break ;
64026: GO 64030
// end ;
64028: GO 63991
64030: POP
64031: POP
// end else
64032: GO 64042
// result := false ;
64034: LD_ADDR_VAR 0 3
64038: PUSH
64039: LD_INT 0
64041: ST_TO_ADDR
// end ;
64042: LD_VAR 0 3
64046: RET
// export function VehicleCost ( fac , list ) ; var cost , pom ; begin
64047: LD_INT 0
64049: PPUSH
64050: PPUSH
64051: PPUSH
// pom := GetBase ( fac ) ;
64052: LD_ADDR_VAR 0 5
64056: PUSH
64057: LD_VAR 0 1
64061: PPUSH
64062: CALL_OW 274
64066: ST_TO_ADDR
// cost := CostOfVehicle ( list [ 1 ] , list [ 2 ] , list [ 3 ] , list [ 4 ] ) ;
64067: LD_ADDR_VAR 0 4
64071: PUSH
64072: LD_VAR 0 2
64076: PUSH
64077: LD_INT 1
64079: ARRAY
64080: PPUSH
64081: LD_VAR 0 2
64085: PUSH
64086: LD_INT 2
64088: ARRAY
64089: PPUSH
64090: LD_VAR 0 2
64094: PUSH
64095: LD_INT 3
64097: ARRAY
64098: PPUSH
64099: LD_VAR 0 2
64103: PUSH
64104: LD_INT 4
64106: ARRAY
64107: PPUSH
64108: CALL_OW 449
64112: ST_TO_ADDR
// result := GetResourceType ( pom , mat_cans ) >= cost [ 1 ] and GetResourceType ( pom , mat_oil ) >= cost [ 2 ] and GetResourceType ( pom , mat_siberit ) >= cost [ 3 ] ;
64113: LD_ADDR_VAR 0 3
64117: PUSH
64118: LD_VAR 0 5
64122: PPUSH
64123: LD_INT 1
64125: PPUSH
64126: CALL_OW 275
64130: PUSH
64131: LD_VAR 0 4
64135: PUSH
64136: LD_INT 1
64138: ARRAY
64139: GREATEREQUAL
64140: PUSH
64141: LD_VAR 0 5
64145: PPUSH
64146: LD_INT 2
64148: PPUSH
64149: CALL_OW 275
64153: PUSH
64154: LD_VAR 0 4
64158: PUSH
64159: LD_INT 2
64161: ARRAY
64162: GREATEREQUAL
64163: AND
64164: PUSH
64165: LD_VAR 0 5
64169: PPUSH
64170: LD_INT 3
64172: PPUSH
64173: CALL_OW 275
64177: PUSH
64178: LD_VAR 0 4
64182: PUSH
64183: LD_INT 3
64185: ARRAY
64186: GREATEREQUAL
64187: AND
64188: ST_TO_ADDR
// end ;
64189: LD_VAR 0 3
64193: RET
// export function UpgradeCost ( building ) ; var pom , cost , btype ; begin
64194: LD_INT 0
64196: PPUSH
64197: PPUSH
64198: PPUSH
64199: PPUSH
// pom := GetBase ( building ) ;
64200: LD_ADDR_VAR 0 3
64204: PUSH
64205: LD_VAR 0 1
64209: PPUSH
64210: CALL_OW 274
64214: ST_TO_ADDR
// if not pom then
64215: LD_VAR 0 3
64219: NOT
64220: IFFALSE 64224
// exit ;
64222: GO 64394
// btype := GetBType ( building ) ;
64224: LD_ADDR_VAR 0 5
64228: PUSH
64229: LD_VAR 0 1
64233: PPUSH
64234: CALL_OW 266
64238: ST_TO_ADDR
// if btype = b_armoury then
64239: LD_VAR 0 5
64243: PUSH
64244: LD_INT 4
64246: EQUAL
64247: IFFALSE 64257
// btype := b_barracks ;
64249: LD_ADDR_VAR 0 5
64253: PUSH
64254: LD_INT 5
64256: ST_TO_ADDR
// if btype = b_depot then
64257: LD_VAR 0 5
64261: PUSH
64262: LD_INT 0
64264: EQUAL
64265: IFFALSE 64275
// btype := b_warehouse ;
64267: LD_ADDR_VAR 0 5
64271: PUSH
64272: LD_INT 1
64274: ST_TO_ADDR
// if btype = b_workshop then
64275: LD_VAR 0 5
64279: PUSH
64280: LD_INT 2
64282: EQUAL
64283: IFFALSE 64293
// btype := b_factory ;
64285: LD_ADDR_VAR 0 5
64289: PUSH
64290: LD_INT 3
64292: ST_TO_ADDR
// cost := CostOfBuilding ( btype , GetNation ( building ) ) ;
64293: LD_ADDR_VAR 0 4
64297: PUSH
64298: LD_VAR 0 5
64302: PPUSH
64303: LD_VAR 0 1
64307: PPUSH
64308: CALL_OW 248
64312: PPUSH
64313: CALL_OW 450
64317: ST_TO_ADDR
// result := GetResourceType ( pom , mat_cans ) >= cost [ 1 ] and GetResourceType ( pom , mat_oil ) >= cost [ 2 ] and GetResourceType ( pom , mat_siberit ) >= cost [ 3 ] ;
64318: LD_ADDR_VAR 0 2
64322: PUSH
64323: LD_VAR 0 3
64327: PPUSH
64328: LD_INT 1
64330: PPUSH
64331: CALL_OW 275
64335: PUSH
64336: LD_VAR 0 4
64340: PUSH
64341: LD_INT 1
64343: ARRAY
64344: GREATEREQUAL
64345: PUSH
64346: LD_VAR 0 3
64350: PPUSH
64351: LD_INT 2
64353: PPUSH
64354: CALL_OW 275
64358: PUSH
64359: LD_VAR 0 4
64363: PUSH
64364: LD_INT 2
64366: ARRAY
64367: GREATEREQUAL
64368: AND
64369: PUSH
64370: LD_VAR 0 3
64374: PPUSH
64375: LD_INT 3
64377: PPUSH
64378: CALL_OW 275
64382: PUSH
64383: LD_VAR 0 4
64387: PUSH
64388: LD_INT 3
64390: ARRAY
64391: GREATEREQUAL
64392: AND
64393: ST_TO_ADDR
// end ;
64394: LD_VAR 0 2
64398: RET
// export function UpgradeLabCost ( building , btype ) ; var pom , cost ; begin
64399: LD_INT 0
64401: PPUSH
64402: PPUSH
64403: PPUSH
// pom := GetBase ( building ) ;
64404: LD_ADDR_VAR 0 4
64408: PUSH
64409: LD_VAR 0 1
64413: PPUSH
64414: CALL_OW 274
64418: ST_TO_ADDR
// if not pom then
64419: LD_VAR 0 4
64423: NOT
64424: IFFALSE 64428
// exit ;
64426: GO 64529
// cost := CostOfBuilding ( btype , GetNation ( building ) ) ;
64428: LD_ADDR_VAR 0 5
64432: PUSH
64433: LD_VAR 0 2
64437: PPUSH
64438: LD_VAR 0 1
64442: PPUSH
64443: CALL_OW 248
64447: PPUSH
64448: CALL_OW 450
64452: ST_TO_ADDR
// result := GetResourceType ( pom , mat_cans ) >= cost [ 1 ] and GetResourceType ( pom , mat_oil ) >= cost [ 2 ] and GetResourceType ( pom , mat_siberit ) >= cost [ 3 ] ;
64453: LD_ADDR_VAR 0 3
64457: PUSH
64458: LD_VAR 0 4
64462: PPUSH
64463: LD_INT 1
64465: PPUSH
64466: CALL_OW 275
64470: PUSH
64471: LD_VAR 0 5
64475: PUSH
64476: LD_INT 1
64478: ARRAY
64479: GREATEREQUAL
64480: PUSH
64481: LD_VAR 0 4
64485: PPUSH
64486: LD_INT 2
64488: PPUSH
64489: CALL_OW 275
64493: PUSH
64494: LD_VAR 0 5
64498: PUSH
64499: LD_INT 2
64501: ARRAY
64502: GREATEREQUAL
64503: AND
64504: PUSH
64505: LD_VAR 0 4
64509: PPUSH
64510: LD_INT 3
64512: PPUSH
64513: CALL_OW 275
64517: PUSH
64518: LD_VAR 0 5
64522: PUSH
64523: LD_INT 3
64525: ARRAY
64526: GREATEREQUAL
64527: AND
64528: ST_TO_ADDR
// end ;
64529: LD_VAR 0 3
64533: RET
// export function TryClearPlaceForBuilding ( base , btype , x , y , d ) ; var i , j , _x , _y , tmp , hexes , r , xy , dep ; begin
64534: LD_INT 0
64536: PPUSH
64537: PPUSH
64538: PPUSH
64539: PPUSH
64540: PPUSH
64541: PPUSH
64542: PPUSH
64543: PPUSH
64544: PPUSH
64545: PPUSH
// result := false ;
64546: LD_ADDR_VAR 0 6
64550: PUSH
64551: LD_INT 0
64553: ST_TO_ADDR
// if not base or not btype or not x or not y then
64554: LD_VAR 0 1
64558: NOT
64559: PUSH
64560: LD_VAR 0 2
64564: NOT
64565: OR
64566: PUSH
64567: LD_VAR 0 3
64571: NOT
64572: OR
64573: PUSH
64574: LD_VAR 0 4
64578: NOT
64579: OR
64580: IFFALSE 64584
// exit ;
64582: GO 65193
// hexes := GetBuildingHexes ( btype , x , y , d , GetNation ( base [ 1 ] ) , 0 ) ;
64584: LD_ADDR_VAR 0 12
64588: PUSH
64589: LD_VAR 0 2
64593: PPUSH
64594: LD_VAR 0 3
64598: PPUSH
64599: LD_VAR 0 4
64603: PPUSH
64604: LD_VAR 0 5
64608: PPUSH
64609: LD_VAR 0 1
64613: PUSH
64614: LD_INT 1
64616: ARRAY
64617: PPUSH
64618: CALL_OW 248
64622: PPUSH
64623: LD_INT 0
64625: PPUSH
64626: CALL 66030 0 6
64630: ST_TO_ADDR
// if not hexes then
64631: LD_VAR 0 12
64635: NOT
64636: IFFALSE 64640
// exit ;
64638: GO 65193
// for i = 1 to hexes do
64640: LD_ADDR_VAR 0 7
64644: PUSH
64645: DOUBLE
64646: LD_INT 1
64648: DEC
64649: ST_TO_ADDR
64650: LD_VAR 0 12
64654: PUSH
64655: FOR_TO
64656: IFFALSE 65191
// begin tmp := HexInfo ( hexes [ i ] [ 1 ] , hexes [ i ] [ 2 ] ) ;
64658: LD_ADDR_VAR 0 11
64662: PUSH
64663: LD_VAR 0 12
64667: PUSH
64668: LD_VAR 0 7
64672: ARRAY
64673: PUSH
64674: LD_INT 1
64676: ARRAY
64677: PPUSH
64678: LD_VAR 0 12
64682: PUSH
64683: LD_VAR 0 7
64687: ARRAY
64688: PUSH
64689: LD_INT 2
64691: ARRAY
64692: PPUSH
64693: CALL_OW 428
64697: ST_TO_ADDR
// if IsEnvironment ( hexes [ i ] [ 1 ] , hexes [ i ] [ 2 ] ) or not ValidHex ( hexes [ i ] [ 1 ] , hexes [ i ] [ 2 ] ) or GetType ( tmp ) = unit_building then
64698: LD_VAR 0 12
64702: PUSH
64703: LD_VAR 0 7
64707: ARRAY
64708: PUSH
64709: LD_INT 1
64711: ARRAY
64712: PPUSH
64713: LD_VAR 0 12
64717: PUSH
64718: LD_VAR 0 7
64722: ARRAY
64723: PUSH
64724: LD_INT 2
64726: ARRAY
64727: PPUSH
64728: CALL_OW 351
64732: PUSH
64733: LD_VAR 0 12
64737: PUSH
64738: LD_VAR 0 7
64742: ARRAY
64743: PUSH
64744: LD_INT 1
64746: ARRAY
64747: PPUSH
64748: LD_VAR 0 12
64752: PUSH
64753: LD_VAR 0 7
64757: ARRAY
64758: PUSH
64759: LD_INT 2
64761: ARRAY
64762: PPUSH
64763: CALL_OW 488
64767: NOT
64768: OR
64769: PUSH
64770: LD_VAR 0 11
64774: PPUSH
64775: CALL_OW 247
64779: PUSH
64780: LD_INT 3
64782: EQUAL
64783: OR
64784: IFFALSE 64790
// exit ;
64786: POP
64787: POP
64788: GO 65193
// if not tmp or not tmp in base then
64790: LD_VAR 0 11
64794: NOT
64795: PUSH
64796: LD_VAR 0 11
64800: PUSH
64801: LD_VAR 0 1
64805: IN
64806: NOT
64807: OR
64808: IFFALSE 64812
// continue ;
64810: GO 64655
// result := true ;
64812: LD_ADDR_VAR 0 6
64816: PUSH
64817: LD_INT 1
64819: ST_TO_ADDR
// dep := UnitFilter ( base , [ [ f_side , GetSide ( tmp ) ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ] ) ;
64820: LD_ADDR_VAR 0 15
64824: PUSH
64825: LD_VAR 0 1
64829: PPUSH
64830: LD_INT 22
64832: PUSH
64833: LD_VAR 0 11
64837: PPUSH
64838: CALL_OW 255
64842: PUSH
64843: EMPTY
64844: LIST
64845: LIST
64846: PUSH
64847: LD_INT 2
64849: PUSH
64850: LD_INT 30
64852: PUSH
64853: LD_INT 0
64855: PUSH
64856: EMPTY
64857: LIST
64858: LIST
64859: PUSH
64860: LD_INT 30
64862: PUSH
64863: LD_INT 1
64865: PUSH
64866: EMPTY
64867: LIST
64868: LIST
64869: PUSH
64870: EMPTY
64871: LIST
64872: LIST
64873: LIST
64874: PUSH
64875: EMPTY
64876: LIST
64877: LIST
64878: PPUSH
64879: CALL_OW 72
64883: ST_TO_ADDR
// if dep then
64884: LD_VAR 0 15
64888: IFFALSE 65024
// begin xy := [ ShiftX ( GetX ( dep [ 1 ] ) , GetDir ( dep [ 1 ] ) , 5 ) , ShiftY ( GetY ( dep [ 1 ] ) , GetDir ( dep [ 1 ] ) , 5 ) ] ;
64890: LD_ADDR_VAR 0 14
64894: PUSH
64895: LD_VAR 0 15
64899: PUSH
64900: LD_INT 1
64902: ARRAY
64903: PPUSH
64904: CALL_OW 250
64908: PPUSH
64909: LD_VAR 0 15
64913: PUSH
64914: LD_INT 1
64916: ARRAY
64917: PPUSH
64918: CALL_OW 254
64922: PPUSH
64923: LD_INT 5
64925: PPUSH
64926: CALL_OW 272
64930: PUSH
64931: LD_VAR 0 15
64935: PUSH
64936: LD_INT 1
64938: ARRAY
64939: PPUSH
64940: CALL_OW 251
64944: PPUSH
64945: LD_VAR 0 15
64949: PUSH
64950: LD_INT 1
64952: ARRAY
64953: PPUSH
64954: CALL_OW 254
64958: PPUSH
64959: LD_INT 5
64961: PPUSH
64962: CALL_OW 273
64966: PUSH
64967: EMPTY
64968: LIST
64969: LIST
64970: ST_TO_ADDR
// if ValidHex ( xy [ 1 ] , xy [ 2 ] ) then
64971: LD_VAR 0 14
64975: PUSH
64976: LD_INT 1
64978: ARRAY
64979: PPUSH
64980: LD_VAR 0 14
64984: PUSH
64985: LD_INT 2
64987: ARRAY
64988: PPUSH
64989: CALL_OW 488
64993: IFFALSE 65024
// begin ComMoveXY ( tmp , xy [ 1 ] , xy [ 2 ] ) ;
64995: LD_VAR 0 11
64999: PPUSH
65000: LD_VAR 0 14
65004: PUSH
65005: LD_INT 1
65007: ARRAY
65008: PPUSH
65009: LD_VAR 0 14
65013: PUSH
65014: LD_INT 2
65016: ARRAY
65017: PPUSH
65018: CALL_OW 111
// continue ;
65022: GO 64655
// end ; end ; r := GetDir ( tmp ) ;
65024: LD_ADDR_VAR 0 13
65028: PUSH
65029: LD_VAR 0 11
65033: PPUSH
65034: CALL_OW 254
65038: ST_TO_ADDR
// if r = 5 then
65039: LD_VAR 0 13
65043: PUSH
65044: LD_INT 5
65046: EQUAL
65047: IFFALSE 65057
// r := 0 ;
65049: LD_ADDR_VAR 0 13
65053: PUSH
65054: LD_INT 0
65056: ST_TO_ADDR
// for j = r to 5 do
65057: LD_ADDR_VAR 0 8
65061: PUSH
65062: DOUBLE
65063: LD_VAR 0 13
65067: DEC
65068: ST_TO_ADDR
65069: LD_INT 5
65071: PUSH
65072: FOR_TO
65073: IFFALSE 65187
// begin _x := ShiftX ( GetX ( tmp ) , j , 2 ) ;
65075: LD_ADDR_VAR 0 9
65079: PUSH
65080: LD_VAR 0 11
65084: PPUSH
65085: CALL_OW 250
65089: PPUSH
65090: LD_VAR 0 8
65094: PPUSH
65095: LD_INT 2
65097: PPUSH
65098: CALL_OW 272
65102: ST_TO_ADDR
// _y := ShiftY ( GetY ( tmp ) , j , 2 ) ;
65103: LD_ADDR_VAR 0 10
65107: PUSH
65108: LD_VAR 0 11
65112: PPUSH
65113: CALL_OW 251
65117: PPUSH
65118: LD_VAR 0 8
65122: PPUSH
65123: LD_INT 2
65125: PPUSH
65126: CALL_OW 273
65130: ST_TO_ADDR
// if ValidHex ( _x , _y ) and not HexInfo ( _x , _y ) then
65131: LD_VAR 0 9
65135: PPUSH
65136: LD_VAR 0 10
65140: PPUSH
65141: CALL_OW 488
65145: PUSH
65146: LD_VAR 0 9
65150: PPUSH
65151: LD_VAR 0 10
65155: PPUSH
65156: CALL_OW 428
65160: NOT
65161: AND
65162: IFFALSE 65185
// begin ComMoveXY ( tmp , _x , _y ) ;
65164: LD_VAR 0 11
65168: PPUSH
65169: LD_VAR 0 9
65173: PPUSH
65174: LD_VAR 0 10
65178: PPUSH
65179: CALL_OW 111
// break ;
65183: GO 65187
// end ; end ;
65185: GO 65072
65187: POP
65188: POP
// end ;
65189: GO 64655
65191: POP
65192: POP
// end ;
65193: LD_VAR 0 6
65197: RET
// export function CanBeBuilt ( depot , btype , x , y , d ) ; var i , j , side , pom , cost , hexes , height , dist , hex ; begin
65198: LD_INT 0
65200: PPUSH
65201: PPUSH
65202: PPUSH
65203: PPUSH
65204: PPUSH
65205: PPUSH
65206: PPUSH
65207: PPUSH
65208: PPUSH
65209: PPUSH
// result := false ;
65210: LD_ADDR_VAR 0 6
65214: PUSH
65215: LD_INT 0
65217: ST_TO_ADDR
// if not depot or not GetBType ( depot ) in [ b_depot , b_warehouse ] or not btype or not d in [ 0 , 1 , 2 , 3 , 4 , 5 ] or not ValidHex ( x , y ) then
65218: LD_VAR 0 1
65222: NOT
65223: PUSH
65224: LD_VAR 0 1
65228: PPUSH
65229: CALL_OW 266
65233: PUSH
65234: LD_INT 0
65236: PUSH
65237: LD_INT 1
65239: PUSH
65240: EMPTY
65241: LIST
65242: LIST
65243: IN
65244: NOT
65245: OR
65246: PUSH
65247: LD_VAR 0 2
65251: NOT
65252: OR
65253: PUSH
65254: LD_VAR 0 5
65258: PUSH
65259: LD_INT 0
65261: PUSH
65262: LD_INT 1
65264: PUSH
65265: LD_INT 2
65267: PUSH
65268: LD_INT 3
65270: PUSH
65271: LD_INT 4
65273: PUSH
65274: LD_INT 5
65276: PUSH
65277: EMPTY
65278: LIST
65279: LIST
65280: LIST
65281: LIST
65282: LIST
65283: LIST
65284: IN
65285: NOT
65286: OR
65287: PUSH
65288: LD_VAR 0 3
65292: PPUSH
65293: LD_VAR 0 4
65297: PPUSH
65298: CALL_OW 488
65302: NOT
65303: OR
65304: IFFALSE 65308
// exit ;
65306: GO 66025
// pom := GetBase ( depot ) ;
65308: LD_ADDR_VAR 0 10
65312: PUSH
65313: LD_VAR 0 1
65317: PPUSH
65318: CALL_OW 274
65322: ST_TO_ADDR
// cost := CostOfBuilding ( btype , GetNation ( depot ) ) ;
65323: LD_ADDR_VAR 0 11
65327: PUSH
65328: LD_VAR 0 2
65332: PPUSH
65333: LD_VAR 0 1
65337: PPUSH
65338: CALL_OW 248
65342: PPUSH
65343: CALL_OW 450
65347: ST_TO_ADDR
// if not ( GetResourceType ( pom , mat_cans ) >= cost [ 1 ] and GetResourceType ( pom , mat_oil ) >= cost [ 2 ] and GetResourceType ( pom , mat_siberit ) >= cost [ 3 ] ) then
65348: LD_VAR 0 10
65352: PPUSH
65353: LD_INT 1
65355: PPUSH
65356: CALL_OW 275
65360: PUSH
65361: LD_VAR 0 11
65365: PUSH
65366: LD_INT 1
65368: ARRAY
65369: GREATEREQUAL
65370: PUSH
65371: LD_VAR 0 10
65375: PPUSH
65376: LD_INT 2
65378: PPUSH
65379: CALL_OW 275
65383: PUSH
65384: LD_VAR 0 11
65388: PUSH
65389: LD_INT 2
65391: ARRAY
65392: GREATEREQUAL
65393: AND
65394: PUSH
65395: LD_VAR 0 10
65399: PPUSH
65400: LD_INT 3
65402: PPUSH
65403: CALL_OW 275
65407: PUSH
65408: LD_VAR 0 11
65412: PUSH
65413: LD_INT 3
65415: ARRAY
65416: GREATEREQUAL
65417: AND
65418: NOT
65419: IFFALSE 65423
// exit ;
65421: GO 66025
// if GetBType ( depot ) = b_depot then
65423: LD_VAR 0 1
65427: PPUSH
65428: CALL_OW 266
65432: PUSH
65433: LD_INT 0
65435: EQUAL
65436: IFFALSE 65448
// dist := 28 else
65438: LD_ADDR_VAR 0 14
65442: PUSH
65443: LD_INT 28
65445: ST_TO_ADDR
65446: GO 65456
// dist := 36 ;
65448: LD_ADDR_VAR 0 14
65452: PUSH
65453: LD_INT 36
65455: ST_TO_ADDR
// if GetDistUnitXY ( depot , x , y ) > dist then
65456: LD_VAR 0 1
65460: PPUSH
65461: LD_VAR 0 3
65465: PPUSH
65466: LD_VAR 0 4
65470: PPUSH
65471: CALL_OW 297
65475: PUSH
65476: LD_VAR 0 14
65480: GREATER
65481: IFFALSE 65485
// exit ;
65483: GO 66025
// hexes := GetBuildingHexes ( btype , x , y , d , GetNation ( depot ) , 0 ) ;
65485: LD_ADDR_VAR 0 12
65489: PUSH
65490: LD_VAR 0 2
65494: PPUSH
65495: LD_VAR 0 3
65499: PPUSH
65500: LD_VAR 0 4
65504: PPUSH
65505: LD_VAR 0 5
65509: PPUSH
65510: LD_VAR 0 1
65514: PPUSH
65515: CALL_OW 248
65519: PPUSH
65520: LD_INT 0
65522: PPUSH
65523: CALL 66030 0 6
65527: ST_TO_ADDR
// if not hexes then
65528: LD_VAR 0 12
65532: NOT
65533: IFFALSE 65537
// exit ;
65535: GO 66025
// hex := GetHexInfo ( x , y ) ;
65537: LD_ADDR_VAR 0 15
65541: PUSH
65542: LD_VAR 0 3
65546: PPUSH
65547: LD_VAR 0 4
65551: PPUSH
65552: CALL_OW 546
65556: ST_TO_ADDR
// if hex [ 1 ] then
65557: LD_VAR 0 15
65561: PUSH
65562: LD_INT 1
65564: ARRAY
65565: IFFALSE 65569
// exit ;
65567: GO 66025
// height := hex [ 2 ] ;
65569: LD_ADDR_VAR 0 13
65573: PUSH
65574: LD_VAR 0 15
65578: PUSH
65579: LD_INT 2
65581: ARRAY
65582: ST_TO_ADDR
// for i = 1 to hexes do
65583: LD_ADDR_VAR 0 7
65587: PUSH
65588: DOUBLE
65589: LD_INT 1
65591: DEC
65592: ST_TO_ADDR
65593: LD_VAR 0 12
65597: PUSH
65598: FOR_TO
65599: IFFALSE 65929
// begin if not ValidHex ( hexes [ i ] [ 1 ] , hexes [ i ] [ 2 ] ) or HexInfo ( hexes [ i ] [ 1 ] , hexes [ i ] [ 2 ] ) > 0 or IsEnvironment ( hexes [ i ] [ 1 ] , hexes [ i ] [ 2 ] ) then
65601: LD_VAR 0 12
65605: PUSH
65606: LD_VAR 0 7
65610: ARRAY
65611: PUSH
65612: LD_INT 1
65614: ARRAY
65615: PPUSH
65616: LD_VAR 0 12
65620: PUSH
65621: LD_VAR 0 7
65625: ARRAY
65626: PUSH
65627: LD_INT 2
65629: ARRAY
65630: PPUSH
65631: CALL_OW 488
65635: NOT
65636: PUSH
65637: LD_VAR 0 12
65641: PUSH
65642: LD_VAR 0 7
65646: ARRAY
65647: PUSH
65648: LD_INT 1
65650: ARRAY
65651: PPUSH
65652: LD_VAR 0 12
65656: PUSH
65657: LD_VAR 0 7
65661: ARRAY
65662: PUSH
65663: LD_INT 2
65665: ARRAY
65666: PPUSH
65667: CALL_OW 428
65671: PUSH
65672: LD_INT 0
65674: GREATER
65675: OR
65676: PUSH
65677: LD_VAR 0 12
65681: PUSH
65682: LD_VAR 0 7
65686: ARRAY
65687: PUSH
65688: LD_INT 1
65690: ARRAY
65691: PPUSH
65692: LD_VAR 0 12
65696: PUSH
65697: LD_VAR 0 7
65701: ARRAY
65702: PUSH
65703: LD_INT 2
65705: ARRAY
65706: PPUSH
65707: CALL_OW 351
65711: OR
65712: IFFALSE 65718
// exit ;
65714: POP
65715: POP
65716: GO 66025
// j := GetHexInfo ( hexes [ i ] [ 1 ] , hexes [ i ] [ 2 ] ) ;
65718: LD_ADDR_VAR 0 8
65722: PUSH
65723: LD_VAR 0 12
65727: PUSH
65728: LD_VAR 0 7
65732: ARRAY
65733: PUSH
65734: LD_INT 1
65736: ARRAY
65737: PPUSH
65738: LD_VAR 0 12
65742: PUSH
65743: LD_VAR 0 7
65747: ARRAY
65748: PUSH
65749: LD_INT 2
65751: ARRAY
65752: PPUSH
65753: CALL_OW 546
65757: ST_TO_ADDR
// if j [ 1 ] or j [ 2 ] > height + 2 or j [ 2 ] < height - 2 or not j [ 3 ] in [ 0 , 8 , 9 , 10 , 11 , 12 , 13 , 16 , 17 , 18 , 19 , 20 , 21 ] or not j [ 5 ] or not j [ 6 ] in [ 1 , 2 , 7 , 9 , 10 , 11 ] then
65758: LD_VAR 0 8
65762: PUSH
65763: LD_INT 1
65765: ARRAY
65766: PUSH
65767: LD_VAR 0 8
65771: PUSH
65772: LD_INT 2
65774: ARRAY
65775: PUSH
65776: LD_VAR 0 13
65780: PUSH
65781: LD_INT 2
65783: PLUS
65784: GREATER
65785: OR
65786: PUSH
65787: LD_VAR 0 8
65791: PUSH
65792: LD_INT 2
65794: ARRAY
65795: PUSH
65796: LD_VAR 0 13
65800: PUSH
65801: LD_INT 2
65803: MINUS
65804: LESS
65805: OR
65806: PUSH
65807: LD_VAR 0 8
65811: PUSH
65812: LD_INT 3
65814: ARRAY
65815: PUSH
65816: LD_INT 0
65818: PUSH
65819: LD_INT 8
65821: PUSH
65822: LD_INT 9
65824: PUSH
65825: LD_INT 10
65827: PUSH
65828: LD_INT 11
65830: PUSH
65831: LD_INT 12
65833: PUSH
65834: LD_INT 13
65836: PUSH
65837: LD_INT 16
65839: PUSH
65840: LD_INT 17
65842: PUSH
65843: LD_INT 18
65845: PUSH
65846: LD_INT 19
65848: PUSH
65849: LD_INT 20
65851: PUSH
65852: LD_INT 21
65854: PUSH
65855: EMPTY
65856: LIST
65857: LIST
65858: LIST
65859: LIST
65860: LIST
65861: LIST
65862: LIST
65863: LIST
65864: LIST
65865: LIST
65866: LIST
65867: LIST
65868: LIST
65869: IN
65870: NOT
65871: OR
65872: PUSH
65873: LD_VAR 0 8
65877: PUSH
65878: LD_INT 5
65880: ARRAY
65881: NOT
65882: OR
65883: PUSH
65884: LD_VAR 0 8
65888: PUSH
65889: LD_INT 6
65891: ARRAY
65892: PUSH
65893: LD_INT 1
65895: PUSH
65896: LD_INT 2
65898: PUSH
65899: LD_INT 7
65901: PUSH
65902: LD_INT 9
65904: PUSH
65905: LD_INT 10
65907: PUSH
65908: LD_INT 11
65910: PUSH
65911: EMPTY
65912: LIST
65913: LIST
65914: LIST
65915: LIST
65916: LIST
65917: LIST
65918: IN
65919: NOT
65920: OR
65921: IFFALSE 65927
// exit ;
65923: POP
65924: POP
65925: GO 66025
// end ;
65927: GO 65598
65929: POP
65930: POP
// side := GetSide ( depot ) ;
65931: LD_ADDR_VAR 0 9
65935: PUSH
65936: LD_VAR 0 1
65940: PPUSH
65941: CALL_OW 255
65945: ST_TO_ADDR
// if DangerAtRangeXY ( side , x , y , 20 ) [ 4 ] then
65946: LD_VAR 0 9
65950: PPUSH
65951: LD_VAR 0 3
65955: PPUSH
65956: LD_VAR 0 4
65960: PPUSH
65961: LD_INT 20
65963: PPUSH
65964: CALL 58679 0 4
65968: PUSH
65969: LD_INT 4
65971: ARRAY
65972: IFFALSE 65976
// exit ;
65974: GO 66025
// if btype in [ b_oil_mine , b_siberite_mine ] and not GetResourceVisibility ( x , y , side ) then
65976: LD_VAR 0 2
65980: PUSH
65981: LD_INT 29
65983: PUSH
65984: LD_INT 30
65986: PUSH
65987: EMPTY
65988: LIST
65989: LIST
65990: IN
65991: PUSH
65992: LD_VAR 0 3
65996: PPUSH
65997: LD_VAR 0 4
66001: PPUSH
66002: LD_VAR 0 9
66006: PPUSH
66007: CALL_OW 440
66011: NOT
66012: AND
66013: IFFALSE 66017
// exit ;
66015: GO 66025
// result := true ;
66017: LD_ADDR_VAR 0 6
66021: PUSH
66022: LD_INT 1
66024: ST_TO_ADDR
// end ;
66025: LD_VAR 0 6
66029: RET
// export function GetBuildingHexes ( btype , x , y , dir , nation , mode ) ; var i , temp_list , temp_list2 ; var DepotAm0 , DepotAm1 , DepotAm2 , DepotAm3 , DepotAm4 , DepotAm5 , DepotAr0 , DepotAr1 , DepotAr2 , DepotAr3 , DepotAr4 , DepotAr5 , DepotRu0 , DepotRu1 , DepotRu2 , DepotRu3 , DepotRu4 , DepotRu5 ; var Factory0 , Factory1 , Factory2 , Factory3 , Factory4 , Factory5 , Ext0 , Ext1 , Ext2 , Ext3 , Ext4 , Ext5 ; var Lab0 , Lab1 , Lab2 , Lab3 , Lab4 , Lab5 , ControlTower0 , ControlTower1 , ControlTower2 , ControlTower3 , ControlTower4 , ControlTower5 ; var Barracks0 , Barracks1 , Barracks2 , Barracks3 , Barracks4 , Barracks5 , Bunker0 , Bunker1 , Bunker2 , Bunker3 , Bunker4 , Bunker5 ; begin
66030: LD_INT 0
66032: PPUSH
66033: PPUSH
66034: PPUSH
66035: PPUSH
66036: PPUSH
66037: PPUSH
66038: PPUSH
66039: PPUSH
66040: PPUSH
66041: PPUSH
66042: PPUSH
66043: PPUSH
66044: PPUSH
66045: PPUSH
66046: PPUSH
66047: PPUSH
66048: PPUSH
66049: PPUSH
66050: PPUSH
66051: PPUSH
66052: PPUSH
66053: PPUSH
66054: PPUSH
66055: PPUSH
66056: PPUSH
66057: PPUSH
66058: PPUSH
66059: PPUSH
66060: PPUSH
66061: PPUSH
66062: PPUSH
66063: PPUSH
66064: PPUSH
66065: PPUSH
66066: PPUSH
66067: PPUSH
66068: PPUSH
66069: PPUSH
66070: PPUSH
66071: PPUSH
66072: PPUSH
66073: PPUSH
66074: PPUSH
66075: PPUSH
66076: PPUSH
66077: PPUSH
66078: PPUSH
66079: PPUSH
66080: PPUSH
66081: PPUSH
66082: PPUSH
66083: PPUSH
66084: PPUSH
66085: PPUSH
66086: PPUSH
66087: PPUSH
66088: PPUSH
66089: PPUSH
// result = [ ] ;
66090: LD_ADDR_VAR 0 7
66094: PUSH
66095: EMPTY
66096: ST_TO_ADDR
// temp_list = [ ] ;
66097: LD_ADDR_VAR 0 9
66101: PUSH
66102: EMPTY
66103: ST_TO_ADDR
// if not dir in [ 0 , 1 , 2 , 3 , 4 , 5 ] or ( btype in [ b_depot , b_warehouse ] and not nation in [ nation_american , nation_arabian , nation_russian ] ) then
66104: LD_VAR 0 4
66108: PUSH
66109: LD_INT 0
66111: PUSH
66112: LD_INT 1
66114: PUSH
66115: LD_INT 2
66117: PUSH
66118: LD_INT 3
66120: PUSH
66121: LD_INT 4
66123: PUSH
66124: LD_INT 5
66126: PUSH
66127: EMPTY
66128: LIST
66129: LIST
66130: LIST
66131: LIST
66132: LIST
66133: LIST
66134: IN
66135: NOT
66136: PUSH
66137: LD_VAR 0 1
66141: PUSH
66142: LD_INT 0
66144: PUSH
66145: LD_INT 1
66147: PUSH
66148: EMPTY
66149: LIST
66150: LIST
66151: IN
66152: PUSH
66153: LD_VAR 0 5
66157: PUSH
66158: LD_INT 1
66160: PUSH
66161: LD_INT 2
66163: PUSH
66164: LD_INT 3
66166: PUSH
66167: EMPTY
66168: LIST
66169: LIST
66170: LIST
66171: IN
66172: NOT
66173: AND
66174: OR
66175: IFFALSE 66179
// exit ;
66177: GO 84570
// if btype in [ b_lab , b_lab_half , b_lab_full , b_lab_biological , b_lab_computer , b_lab_opto , b_lab_siberium , b_lab_spacetime , b_lab_weapon ] then
66179: LD_VAR 0 1
66183: PUSH
66184: LD_INT 6
66186: PUSH
66187: LD_INT 7
66189: PUSH
66190: LD_INT 8
66192: PUSH
66193: LD_INT 13
66195: PUSH
66196: LD_INT 12
66198: PUSH
66199: LD_INT 15
66201: PUSH
66202: LD_INT 11
66204: PUSH
66205: LD_INT 14
66207: PUSH
66208: LD_INT 10
66210: PUSH
66211: EMPTY
66212: LIST
66213: LIST
66214: LIST
66215: LIST
66216: LIST
66217: LIST
66218: LIST
66219: LIST
66220: LIST
66221: IN
66222: IFFALSE 66232
// btype = b_lab ;
66224: LD_ADDR_VAR 0 1
66228: PUSH
66229: LD_INT 6
66231: ST_TO_ADDR
// if not mode in [ 0 , 1 , 2 ] or ( not btype in [ b_depot , b_warehouse , b_workshop , b_factory , b_lab , b_control_tower , b_armoury , b_barracks , b_breastwork , b_bunker , b_turret ] and mode = 1 ) or ( not btype in [ b_workshop , b_factory ] and mode = 2 ) then
66232: LD_VAR 0 6
66236: PUSH
66237: LD_INT 0
66239: PUSH
66240: LD_INT 1
66242: PUSH
66243: LD_INT 2
66245: PUSH
66246: EMPTY
66247: LIST
66248: LIST
66249: LIST
66250: IN
66251: NOT
66252: PUSH
66253: LD_VAR 0 1
66257: PUSH
66258: LD_INT 0
66260: PUSH
66261: LD_INT 1
66263: PUSH
66264: LD_INT 2
66266: PUSH
66267: LD_INT 3
66269: PUSH
66270: LD_INT 6
66272: PUSH
66273: LD_INT 36
66275: PUSH
66276: LD_INT 4
66278: PUSH
66279: LD_INT 5
66281: PUSH
66282: LD_INT 31
66284: PUSH
66285: LD_INT 32
66287: PUSH
66288: LD_INT 33
66290: PUSH
66291: EMPTY
66292: LIST
66293: LIST
66294: LIST
66295: LIST
66296: LIST
66297: LIST
66298: LIST
66299: LIST
66300: LIST
66301: LIST
66302: LIST
66303: IN
66304: NOT
66305: PUSH
66306: LD_VAR 0 6
66310: PUSH
66311: LD_INT 1
66313: EQUAL
66314: AND
66315: OR
66316: PUSH
66317: LD_VAR 0 1
66321: PUSH
66322: LD_INT 2
66324: PUSH
66325: LD_INT 3
66327: PUSH
66328: EMPTY
66329: LIST
66330: LIST
66331: IN
66332: NOT
66333: PUSH
66334: LD_VAR 0 6
66338: PUSH
66339: LD_INT 2
66341: EQUAL
66342: AND
66343: OR
66344: IFFALSE 66354
// mode = 0 ;
66346: LD_ADDR_VAR 0 6
66350: PUSH
66351: LD_INT 0
66353: ST_TO_ADDR
// case mode of 0 :
66354: LD_VAR 0 6
66358: PUSH
66359: LD_INT 0
66361: DOUBLE
66362: EQUAL
66363: IFTRUE 66367
66365: GO 77820
66367: POP
// begin DepotAm0 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ 1 , 3 ] , [ 0 , 3 ] , [ - 1 , 2 ] ] ;
66368: LD_ADDR_VAR 0 11
66372: PUSH
66373: LD_INT 0
66375: PUSH
66376: LD_INT 0
66378: PUSH
66379: EMPTY
66380: LIST
66381: LIST
66382: PUSH
66383: LD_INT 0
66385: PUSH
66386: LD_INT 1
66388: NEG
66389: PUSH
66390: EMPTY
66391: LIST
66392: LIST
66393: PUSH
66394: LD_INT 1
66396: PUSH
66397: LD_INT 0
66399: PUSH
66400: EMPTY
66401: LIST
66402: LIST
66403: PUSH
66404: LD_INT 1
66406: PUSH
66407: LD_INT 1
66409: PUSH
66410: EMPTY
66411: LIST
66412: LIST
66413: PUSH
66414: LD_INT 0
66416: PUSH
66417: LD_INT 1
66419: PUSH
66420: EMPTY
66421: LIST
66422: LIST
66423: PUSH
66424: LD_INT 1
66426: NEG
66427: PUSH
66428: LD_INT 0
66430: PUSH
66431: EMPTY
66432: LIST
66433: LIST
66434: PUSH
66435: LD_INT 1
66437: NEG
66438: PUSH
66439: LD_INT 1
66441: NEG
66442: PUSH
66443: EMPTY
66444: LIST
66445: LIST
66446: PUSH
66447: LD_INT 1
66449: NEG
66450: PUSH
66451: LD_INT 2
66453: NEG
66454: PUSH
66455: EMPTY
66456: LIST
66457: LIST
66458: PUSH
66459: LD_INT 0
66461: PUSH
66462: LD_INT 2
66464: NEG
66465: PUSH
66466: EMPTY
66467: LIST
66468: LIST
66469: PUSH
66470: LD_INT 1
66472: PUSH
66473: LD_INT 1
66475: NEG
66476: PUSH
66477: EMPTY
66478: LIST
66479: LIST
66480: PUSH
66481: LD_INT 1
66483: PUSH
66484: LD_INT 2
66486: PUSH
66487: EMPTY
66488: LIST
66489: LIST
66490: PUSH
66491: LD_INT 0
66493: PUSH
66494: LD_INT 2
66496: PUSH
66497: EMPTY
66498: LIST
66499: LIST
66500: PUSH
66501: LD_INT 1
66503: NEG
66504: PUSH
66505: LD_INT 1
66507: PUSH
66508: EMPTY
66509: LIST
66510: LIST
66511: PUSH
66512: LD_INT 1
66514: PUSH
66515: LD_INT 3
66517: PUSH
66518: EMPTY
66519: LIST
66520: LIST
66521: PUSH
66522: LD_INT 0
66524: PUSH
66525: LD_INT 3
66527: PUSH
66528: EMPTY
66529: LIST
66530: LIST
66531: PUSH
66532: LD_INT 1
66534: NEG
66535: PUSH
66536: LD_INT 2
66538: PUSH
66539: EMPTY
66540: LIST
66541: LIST
66542: PUSH
66543: EMPTY
66544: LIST
66545: LIST
66546: LIST
66547: LIST
66548: LIST
66549: LIST
66550: LIST
66551: LIST
66552: LIST
66553: LIST
66554: LIST
66555: LIST
66556: LIST
66557: LIST
66558: LIST
66559: LIST
66560: ST_TO_ADDR
// DepotAm1 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , 1 ] , [ - 3 , 0 ] , [ - 3 , - 1 ] ] ;
66561: LD_ADDR_VAR 0 12
66565: PUSH
66566: LD_INT 0
66568: PUSH
66569: LD_INT 0
66571: PUSH
66572: EMPTY
66573: LIST
66574: LIST
66575: PUSH
66576: LD_INT 0
66578: PUSH
66579: LD_INT 1
66581: NEG
66582: PUSH
66583: EMPTY
66584: LIST
66585: LIST
66586: PUSH
66587: LD_INT 1
66589: PUSH
66590: LD_INT 0
66592: PUSH
66593: EMPTY
66594: LIST
66595: LIST
66596: PUSH
66597: LD_INT 1
66599: PUSH
66600: LD_INT 1
66602: PUSH
66603: EMPTY
66604: LIST
66605: LIST
66606: PUSH
66607: LD_INT 0
66609: PUSH
66610: LD_INT 1
66612: PUSH
66613: EMPTY
66614: LIST
66615: LIST
66616: PUSH
66617: LD_INT 1
66619: NEG
66620: PUSH
66621: LD_INT 0
66623: PUSH
66624: EMPTY
66625: LIST
66626: LIST
66627: PUSH
66628: LD_INT 1
66630: NEG
66631: PUSH
66632: LD_INT 1
66634: NEG
66635: PUSH
66636: EMPTY
66637: LIST
66638: LIST
66639: PUSH
66640: LD_INT 1
66642: PUSH
66643: LD_INT 1
66645: NEG
66646: PUSH
66647: EMPTY
66648: LIST
66649: LIST
66650: PUSH
66651: LD_INT 2
66653: PUSH
66654: LD_INT 0
66656: PUSH
66657: EMPTY
66658: LIST
66659: LIST
66660: PUSH
66661: LD_INT 2
66663: PUSH
66664: LD_INT 1
66666: PUSH
66667: EMPTY
66668: LIST
66669: LIST
66670: PUSH
66671: LD_INT 1
66673: NEG
66674: PUSH
66675: LD_INT 1
66677: PUSH
66678: EMPTY
66679: LIST
66680: LIST
66681: PUSH
66682: LD_INT 2
66684: NEG
66685: PUSH
66686: LD_INT 0
66688: PUSH
66689: EMPTY
66690: LIST
66691: LIST
66692: PUSH
66693: LD_INT 2
66695: NEG
66696: PUSH
66697: LD_INT 1
66699: NEG
66700: PUSH
66701: EMPTY
66702: LIST
66703: LIST
66704: PUSH
66705: LD_INT 2
66707: NEG
66708: PUSH
66709: LD_INT 1
66711: PUSH
66712: EMPTY
66713: LIST
66714: LIST
66715: PUSH
66716: LD_INT 3
66718: NEG
66719: PUSH
66720: LD_INT 0
66722: PUSH
66723: EMPTY
66724: LIST
66725: LIST
66726: PUSH
66727: LD_INT 3
66729: NEG
66730: PUSH
66731: LD_INT 1
66733: NEG
66734: PUSH
66735: EMPTY
66736: LIST
66737: LIST
66738: PUSH
66739: EMPTY
66740: LIST
66741: LIST
66742: LIST
66743: LIST
66744: LIST
66745: LIST
66746: LIST
66747: LIST
66748: LIST
66749: LIST
66750: LIST
66751: LIST
66752: LIST
66753: LIST
66754: LIST
66755: LIST
66756: ST_TO_ADDR
// DepotAm2 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ - 2 , - 3 ] , [ - 3 , - 2 ] , [ - 3 , - 3 ] ] ;
66757: LD_ADDR_VAR 0 13
66761: PUSH
66762: LD_INT 0
66764: PUSH
66765: LD_INT 0
66767: PUSH
66768: EMPTY
66769: LIST
66770: LIST
66771: PUSH
66772: LD_INT 0
66774: PUSH
66775: LD_INT 1
66777: NEG
66778: PUSH
66779: EMPTY
66780: LIST
66781: LIST
66782: PUSH
66783: LD_INT 1
66785: PUSH
66786: LD_INT 0
66788: PUSH
66789: EMPTY
66790: LIST
66791: LIST
66792: PUSH
66793: LD_INT 1
66795: PUSH
66796: LD_INT 1
66798: PUSH
66799: EMPTY
66800: LIST
66801: LIST
66802: PUSH
66803: LD_INT 0
66805: PUSH
66806: LD_INT 1
66808: PUSH
66809: EMPTY
66810: LIST
66811: LIST
66812: PUSH
66813: LD_INT 1
66815: NEG
66816: PUSH
66817: LD_INT 0
66819: PUSH
66820: EMPTY
66821: LIST
66822: LIST
66823: PUSH
66824: LD_INT 1
66826: NEG
66827: PUSH
66828: LD_INT 1
66830: NEG
66831: PUSH
66832: EMPTY
66833: LIST
66834: LIST
66835: PUSH
66836: LD_INT 1
66838: NEG
66839: PUSH
66840: LD_INT 2
66842: NEG
66843: PUSH
66844: EMPTY
66845: LIST
66846: LIST
66847: PUSH
66848: LD_INT 2
66850: PUSH
66851: LD_INT 1
66853: PUSH
66854: EMPTY
66855: LIST
66856: LIST
66857: PUSH
66858: LD_INT 2
66860: PUSH
66861: LD_INT 2
66863: PUSH
66864: EMPTY
66865: LIST
66866: LIST
66867: PUSH
66868: LD_INT 1
66870: PUSH
66871: LD_INT 2
66873: PUSH
66874: EMPTY
66875: LIST
66876: LIST
66877: PUSH
66878: LD_INT 2
66880: NEG
66881: PUSH
66882: LD_INT 1
66884: NEG
66885: PUSH
66886: EMPTY
66887: LIST
66888: LIST
66889: PUSH
66890: LD_INT 2
66892: NEG
66893: PUSH
66894: LD_INT 2
66896: NEG
66897: PUSH
66898: EMPTY
66899: LIST
66900: LIST
66901: PUSH
66902: LD_INT 2
66904: NEG
66905: PUSH
66906: LD_INT 3
66908: NEG
66909: PUSH
66910: EMPTY
66911: LIST
66912: LIST
66913: PUSH
66914: LD_INT 3
66916: NEG
66917: PUSH
66918: LD_INT 2
66920: NEG
66921: PUSH
66922: EMPTY
66923: LIST
66924: LIST
66925: PUSH
66926: LD_INT 3
66928: NEG
66929: PUSH
66930: LD_INT 3
66932: NEG
66933: PUSH
66934: EMPTY
66935: LIST
66936: LIST
66937: PUSH
66938: EMPTY
66939: LIST
66940: LIST
66941: LIST
66942: LIST
66943: LIST
66944: LIST
66945: LIST
66946: LIST
66947: LIST
66948: LIST
66949: LIST
66950: LIST
66951: LIST
66952: LIST
66953: LIST
66954: LIST
66955: ST_TO_ADDR
// DepotAm3 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 1 , - 3 ] , [ 0 , - 3 ] , [ 1 , - 2 ] ] ;
66956: LD_ADDR_VAR 0 14
66960: PUSH
66961: LD_INT 0
66963: PUSH
66964: LD_INT 0
66966: PUSH
66967: EMPTY
66968: LIST
66969: LIST
66970: PUSH
66971: LD_INT 0
66973: PUSH
66974: LD_INT 1
66976: NEG
66977: PUSH
66978: EMPTY
66979: LIST
66980: LIST
66981: PUSH
66982: LD_INT 1
66984: PUSH
66985: LD_INT 0
66987: PUSH
66988: EMPTY
66989: LIST
66990: LIST
66991: PUSH
66992: LD_INT 1
66994: PUSH
66995: LD_INT 1
66997: PUSH
66998: EMPTY
66999: LIST
67000: LIST
67001: PUSH
67002: LD_INT 0
67004: PUSH
67005: LD_INT 1
67007: PUSH
67008: EMPTY
67009: LIST
67010: LIST
67011: PUSH
67012: LD_INT 1
67014: NEG
67015: PUSH
67016: LD_INT 0
67018: PUSH
67019: EMPTY
67020: LIST
67021: LIST
67022: PUSH
67023: LD_INT 1
67025: NEG
67026: PUSH
67027: LD_INT 1
67029: NEG
67030: PUSH
67031: EMPTY
67032: LIST
67033: LIST
67034: PUSH
67035: LD_INT 1
67037: NEG
67038: PUSH
67039: LD_INT 2
67041: NEG
67042: PUSH
67043: EMPTY
67044: LIST
67045: LIST
67046: PUSH
67047: LD_INT 0
67049: PUSH
67050: LD_INT 2
67052: NEG
67053: PUSH
67054: EMPTY
67055: LIST
67056: LIST
67057: PUSH
67058: LD_INT 1
67060: PUSH
67061: LD_INT 1
67063: NEG
67064: PUSH
67065: EMPTY
67066: LIST
67067: LIST
67068: PUSH
67069: LD_INT 1
67071: PUSH
67072: LD_INT 2
67074: PUSH
67075: EMPTY
67076: LIST
67077: LIST
67078: PUSH
67079: LD_INT 0
67081: PUSH
67082: LD_INT 2
67084: PUSH
67085: EMPTY
67086: LIST
67087: LIST
67088: PUSH
67089: LD_INT 1
67091: NEG
67092: PUSH
67093: LD_INT 1
67095: PUSH
67096: EMPTY
67097: LIST
67098: LIST
67099: PUSH
67100: LD_INT 1
67102: NEG
67103: PUSH
67104: LD_INT 3
67106: NEG
67107: PUSH
67108: EMPTY
67109: LIST
67110: LIST
67111: PUSH
67112: LD_INT 0
67114: PUSH
67115: LD_INT 3
67117: NEG
67118: PUSH
67119: EMPTY
67120: LIST
67121: LIST
67122: PUSH
67123: LD_INT 1
67125: PUSH
67126: LD_INT 2
67128: NEG
67129: PUSH
67130: EMPTY
67131: LIST
67132: LIST
67133: PUSH
67134: EMPTY
67135: LIST
67136: LIST
67137: LIST
67138: LIST
67139: LIST
67140: LIST
67141: LIST
67142: LIST
67143: LIST
67144: LIST
67145: LIST
67146: LIST
67147: LIST
67148: LIST
67149: LIST
67150: LIST
67151: ST_TO_ADDR
// DepotAm4 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ 2 , - 1 ] , [ 3 , 0 ] , [ 3 , 1 ] ] ;
67152: LD_ADDR_VAR 0 15
67156: PUSH
67157: LD_INT 0
67159: PUSH
67160: LD_INT 0
67162: PUSH
67163: EMPTY
67164: LIST
67165: LIST
67166: PUSH
67167: LD_INT 0
67169: PUSH
67170: LD_INT 1
67172: NEG
67173: PUSH
67174: EMPTY
67175: LIST
67176: LIST
67177: PUSH
67178: LD_INT 1
67180: PUSH
67181: LD_INT 0
67183: PUSH
67184: EMPTY
67185: LIST
67186: LIST
67187: PUSH
67188: LD_INT 1
67190: PUSH
67191: LD_INT 1
67193: PUSH
67194: EMPTY
67195: LIST
67196: LIST
67197: PUSH
67198: LD_INT 0
67200: PUSH
67201: LD_INT 1
67203: PUSH
67204: EMPTY
67205: LIST
67206: LIST
67207: PUSH
67208: LD_INT 1
67210: NEG
67211: PUSH
67212: LD_INT 0
67214: PUSH
67215: EMPTY
67216: LIST
67217: LIST
67218: PUSH
67219: LD_INT 1
67221: NEG
67222: PUSH
67223: LD_INT 1
67225: NEG
67226: PUSH
67227: EMPTY
67228: LIST
67229: LIST
67230: PUSH
67231: LD_INT 1
67233: PUSH
67234: LD_INT 1
67236: NEG
67237: PUSH
67238: EMPTY
67239: LIST
67240: LIST
67241: PUSH
67242: LD_INT 2
67244: PUSH
67245: LD_INT 0
67247: PUSH
67248: EMPTY
67249: LIST
67250: LIST
67251: PUSH
67252: LD_INT 2
67254: PUSH
67255: LD_INT 1
67257: PUSH
67258: EMPTY
67259: LIST
67260: LIST
67261: PUSH
67262: LD_INT 1
67264: NEG
67265: PUSH
67266: LD_INT 1
67268: PUSH
67269: EMPTY
67270: LIST
67271: LIST
67272: PUSH
67273: LD_INT 2
67275: NEG
67276: PUSH
67277: LD_INT 0
67279: PUSH
67280: EMPTY
67281: LIST
67282: LIST
67283: PUSH
67284: LD_INT 2
67286: NEG
67287: PUSH
67288: LD_INT 1
67290: NEG
67291: PUSH
67292: EMPTY
67293: LIST
67294: LIST
67295: PUSH
67296: LD_INT 2
67298: PUSH
67299: LD_INT 1
67301: NEG
67302: PUSH
67303: EMPTY
67304: LIST
67305: LIST
67306: PUSH
67307: LD_INT 3
67309: PUSH
67310: LD_INT 0
67312: PUSH
67313: EMPTY
67314: LIST
67315: LIST
67316: PUSH
67317: LD_INT 3
67319: PUSH
67320: LD_INT 1
67322: PUSH
67323: EMPTY
67324: LIST
67325: LIST
67326: PUSH
67327: EMPTY
67328: LIST
67329: LIST
67330: LIST
67331: LIST
67332: LIST
67333: LIST
67334: LIST
67335: LIST
67336: LIST
67337: LIST
67338: LIST
67339: LIST
67340: LIST
67341: LIST
67342: LIST
67343: LIST
67344: ST_TO_ADDR
// DepotAm5 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ 3 , 2 ] , [ 3 , 3 ] , [ 2 , 3 ] ] ;
67345: LD_ADDR_VAR 0 16
67349: PUSH
67350: LD_INT 0
67352: PUSH
67353: LD_INT 0
67355: PUSH
67356: EMPTY
67357: LIST
67358: LIST
67359: PUSH
67360: LD_INT 0
67362: PUSH
67363: LD_INT 1
67365: NEG
67366: PUSH
67367: EMPTY
67368: LIST
67369: LIST
67370: PUSH
67371: LD_INT 1
67373: PUSH
67374: LD_INT 0
67376: PUSH
67377: EMPTY
67378: LIST
67379: LIST
67380: PUSH
67381: LD_INT 1
67383: PUSH
67384: LD_INT 1
67386: PUSH
67387: EMPTY
67388: LIST
67389: LIST
67390: PUSH
67391: LD_INT 0
67393: PUSH
67394: LD_INT 1
67396: PUSH
67397: EMPTY
67398: LIST
67399: LIST
67400: PUSH
67401: LD_INT 1
67403: NEG
67404: PUSH
67405: LD_INT 0
67407: PUSH
67408: EMPTY
67409: LIST
67410: LIST
67411: PUSH
67412: LD_INT 1
67414: NEG
67415: PUSH
67416: LD_INT 1
67418: NEG
67419: PUSH
67420: EMPTY
67421: LIST
67422: LIST
67423: PUSH
67424: LD_INT 1
67426: NEG
67427: PUSH
67428: LD_INT 2
67430: NEG
67431: PUSH
67432: EMPTY
67433: LIST
67434: LIST
67435: PUSH
67436: LD_INT 2
67438: PUSH
67439: LD_INT 1
67441: PUSH
67442: EMPTY
67443: LIST
67444: LIST
67445: PUSH
67446: LD_INT 2
67448: PUSH
67449: LD_INT 2
67451: PUSH
67452: EMPTY
67453: LIST
67454: LIST
67455: PUSH
67456: LD_INT 1
67458: PUSH
67459: LD_INT 2
67461: PUSH
67462: EMPTY
67463: LIST
67464: LIST
67465: PUSH
67466: LD_INT 2
67468: NEG
67469: PUSH
67470: LD_INT 1
67472: NEG
67473: PUSH
67474: EMPTY
67475: LIST
67476: LIST
67477: PUSH
67478: LD_INT 2
67480: NEG
67481: PUSH
67482: LD_INT 2
67484: NEG
67485: PUSH
67486: EMPTY
67487: LIST
67488: LIST
67489: PUSH
67490: LD_INT 3
67492: PUSH
67493: LD_INT 2
67495: PUSH
67496: EMPTY
67497: LIST
67498: LIST
67499: PUSH
67500: LD_INT 3
67502: PUSH
67503: LD_INT 3
67505: PUSH
67506: EMPTY
67507: LIST
67508: LIST
67509: PUSH
67510: LD_INT 2
67512: PUSH
67513: LD_INT 3
67515: PUSH
67516: EMPTY
67517: LIST
67518: LIST
67519: PUSH
67520: EMPTY
67521: LIST
67522: LIST
67523: LIST
67524: LIST
67525: LIST
67526: LIST
67527: LIST
67528: LIST
67529: LIST
67530: LIST
67531: LIST
67532: LIST
67533: LIST
67534: LIST
67535: LIST
67536: LIST
67537: ST_TO_ADDR
// DepotAr0 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
67538: LD_ADDR_VAR 0 17
67542: PUSH
67543: LD_INT 0
67545: PUSH
67546: LD_INT 0
67548: PUSH
67549: EMPTY
67550: LIST
67551: LIST
67552: PUSH
67553: LD_INT 0
67555: PUSH
67556: LD_INT 1
67558: NEG
67559: PUSH
67560: EMPTY
67561: LIST
67562: LIST
67563: PUSH
67564: LD_INT 1
67566: PUSH
67567: LD_INT 0
67569: PUSH
67570: EMPTY
67571: LIST
67572: LIST
67573: PUSH
67574: LD_INT 1
67576: PUSH
67577: LD_INT 1
67579: PUSH
67580: EMPTY
67581: LIST
67582: LIST
67583: PUSH
67584: LD_INT 0
67586: PUSH
67587: LD_INT 1
67589: PUSH
67590: EMPTY
67591: LIST
67592: LIST
67593: PUSH
67594: LD_INT 1
67596: NEG
67597: PUSH
67598: LD_INT 0
67600: PUSH
67601: EMPTY
67602: LIST
67603: LIST
67604: PUSH
67605: LD_INT 1
67607: NEG
67608: PUSH
67609: LD_INT 1
67611: NEG
67612: PUSH
67613: EMPTY
67614: LIST
67615: LIST
67616: PUSH
67617: LD_INT 1
67619: NEG
67620: PUSH
67621: LD_INT 2
67623: NEG
67624: PUSH
67625: EMPTY
67626: LIST
67627: LIST
67628: PUSH
67629: LD_INT 0
67631: PUSH
67632: LD_INT 2
67634: NEG
67635: PUSH
67636: EMPTY
67637: LIST
67638: LIST
67639: PUSH
67640: LD_INT 1
67642: PUSH
67643: LD_INT 1
67645: NEG
67646: PUSH
67647: EMPTY
67648: LIST
67649: LIST
67650: PUSH
67651: LD_INT 2
67653: PUSH
67654: LD_INT 0
67656: PUSH
67657: EMPTY
67658: LIST
67659: LIST
67660: PUSH
67661: LD_INT 2
67663: PUSH
67664: LD_INT 1
67666: PUSH
67667: EMPTY
67668: LIST
67669: LIST
67670: PUSH
67671: LD_INT 2
67673: PUSH
67674: LD_INT 2
67676: PUSH
67677: EMPTY
67678: LIST
67679: LIST
67680: PUSH
67681: LD_INT 1
67683: PUSH
67684: LD_INT 2
67686: PUSH
67687: EMPTY
67688: LIST
67689: LIST
67690: PUSH
67691: LD_INT 0
67693: PUSH
67694: LD_INT 2
67696: PUSH
67697: EMPTY
67698: LIST
67699: LIST
67700: PUSH
67701: LD_INT 1
67703: NEG
67704: PUSH
67705: LD_INT 1
67707: PUSH
67708: EMPTY
67709: LIST
67710: LIST
67711: PUSH
67712: LD_INT 2
67714: NEG
67715: PUSH
67716: LD_INT 0
67718: PUSH
67719: EMPTY
67720: LIST
67721: LIST
67722: PUSH
67723: LD_INT 2
67725: NEG
67726: PUSH
67727: LD_INT 1
67729: NEG
67730: PUSH
67731: EMPTY
67732: LIST
67733: LIST
67734: PUSH
67735: LD_INT 2
67737: NEG
67738: PUSH
67739: LD_INT 2
67741: NEG
67742: PUSH
67743: EMPTY
67744: LIST
67745: LIST
67746: PUSH
67747: EMPTY
67748: LIST
67749: LIST
67750: LIST
67751: LIST
67752: LIST
67753: LIST
67754: LIST
67755: LIST
67756: LIST
67757: LIST
67758: LIST
67759: LIST
67760: LIST
67761: LIST
67762: LIST
67763: LIST
67764: LIST
67765: LIST
67766: LIST
67767: ST_TO_ADDR
// DepotAr1 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
67768: LD_ADDR_VAR 0 18
67772: PUSH
67773: LD_INT 0
67775: PUSH
67776: LD_INT 0
67778: PUSH
67779: EMPTY
67780: LIST
67781: LIST
67782: PUSH
67783: LD_INT 0
67785: PUSH
67786: LD_INT 1
67788: NEG
67789: PUSH
67790: EMPTY
67791: LIST
67792: LIST
67793: PUSH
67794: LD_INT 1
67796: PUSH
67797: LD_INT 0
67799: PUSH
67800: EMPTY
67801: LIST
67802: LIST
67803: PUSH
67804: LD_INT 1
67806: PUSH
67807: LD_INT 1
67809: PUSH
67810: EMPTY
67811: LIST
67812: LIST
67813: PUSH
67814: LD_INT 0
67816: PUSH
67817: LD_INT 1
67819: PUSH
67820: EMPTY
67821: LIST
67822: LIST
67823: PUSH
67824: LD_INT 1
67826: NEG
67827: PUSH
67828: LD_INT 0
67830: PUSH
67831: EMPTY
67832: LIST
67833: LIST
67834: PUSH
67835: LD_INT 1
67837: NEG
67838: PUSH
67839: LD_INT 1
67841: NEG
67842: PUSH
67843: EMPTY
67844: LIST
67845: LIST
67846: PUSH
67847: LD_INT 1
67849: NEG
67850: PUSH
67851: LD_INT 2
67853: NEG
67854: PUSH
67855: EMPTY
67856: LIST
67857: LIST
67858: PUSH
67859: LD_INT 0
67861: PUSH
67862: LD_INT 2
67864: NEG
67865: PUSH
67866: EMPTY
67867: LIST
67868: LIST
67869: PUSH
67870: LD_INT 1
67872: PUSH
67873: LD_INT 1
67875: NEG
67876: PUSH
67877: EMPTY
67878: LIST
67879: LIST
67880: PUSH
67881: LD_INT 2
67883: PUSH
67884: LD_INT 0
67886: PUSH
67887: EMPTY
67888: LIST
67889: LIST
67890: PUSH
67891: LD_INT 2
67893: PUSH
67894: LD_INT 1
67896: PUSH
67897: EMPTY
67898: LIST
67899: LIST
67900: PUSH
67901: LD_INT 2
67903: PUSH
67904: LD_INT 2
67906: PUSH
67907: EMPTY
67908: LIST
67909: LIST
67910: PUSH
67911: LD_INT 1
67913: PUSH
67914: LD_INT 2
67916: PUSH
67917: EMPTY
67918: LIST
67919: LIST
67920: PUSH
67921: LD_INT 0
67923: PUSH
67924: LD_INT 2
67926: PUSH
67927: EMPTY
67928: LIST
67929: LIST
67930: PUSH
67931: LD_INT 1
67933: NEG
67934: PUSH
67935: LD_INT 1
67937: PUSH
67938: EMPTY
67939: LIST
67940: LIST
67941: PUSH
67942: LD_INT 2
67944: NEG
67945: PUSH
67946: LD_INT 0
67948: PUSH
67949: EMPTY
67950: LIST
67951: LIST
67952: PUSH
67953: LD_INT 2
67955: NEG
67956: PUSH
67957: LD_INT 1
67959: NEG
67960: PUSH
67961: EMPTY
67962: LIST
67963: LIST
67964: PUSH
67965: LD_INT 2
67967: NEG
67968: PUSH
67969: LD_INT 2
67971: NEG
67972: PUSH
67973: EMPTY
67974: LIST
67975: LIST
67976: PUSH
67977: EMPTY
67978: LIST
67979: LIST
67980: LIST
67981: LIST
67982: LIST
67983: LIST
67984: LIST
67985: LIST
67986: LIST
67987: LIST
67988: LIST
67989: LIST
67990: LIST
67991: LIST
67992: LIST
67993: LIST
67994: LIST
67995: LIST
67996: LIST
67997: ST_TO_ADDR
// DepotAr2 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
67998: LD_ADDR_VAR 0 19
68002: PUSH
68003: LD_INT 0
68005: PUSH
68006: LD_INT 0
68008: PUSH
68009: EMPTY
68010: LIST
68011: LIST
68012: PUSH
68013: LD_INT 0
68015: PUSH
68016: LD_INT 1
68018: NEG
68019: PUSH
68020: EMPTY
68021: LIST
68022: LIST
68023: PUSH
68024: LD_INT 1
68026: PUSH
68027: LD_INT 0
68029: PUSH
68030: EMPTY
68031: LIST
68032: LIST
68033: PUSH
68034: LD_INT 1
68036: PUSH
68037: LD_INT 1
68039: PUSH
68040: EMPTY
68041: LIST
68042: LIST
68043: PUSH
68044: LD_INT 0
68046: PUSH
68047: LD_INT 1
68049: PUSH
68050: EMPTY
68051: LIST
68052: LIST
68053: PUSH
68054: LD_INT 1
68056: NEG
68057: PUSH
68058: LD_INT 0
68060: PUSH
68061: EMPTY
68062: LIST
68063: LIST
68064: PUSH
68065: LD_INT 1
68067: NEG
68068: PUSH
68069: LD_INT 1
68071: NEG
68072: PUSH
68073: EMPTY
68074: LIST
68075: LIST
68076: PUSH
68077: LD_INT 1
68079: NEG
68080: PUSH
68081: LD_INT 2
68083: NEG
68084: PUSH
68085: EMPTY
68086: LIST
68087: LIST
68088: PUSH
68089: LD_INT 0
68091: PUSH
68092: LD_INT 2
68094: NEG
68095: PUSH
68096: EMPTY
68097: LIST
68098: LIST
68099: PUSH
68100: LD_INT 1
68102: PUSH
68103: LD_INT 1
68105: NEG
68106: PUSH
68107: EMPTY
68108: LIST
68109: LIST
68110: PUSH
68111: LD_INT 2
68113: PUSH
68114: LD_INT 0
68116: PUSH
68117: EMPTY
68118: LIST
68119: LIST
68120: PUSH
68121: LD_INT 2
68123: PUSH
68124: LD_INT 1
68126: PUSH
68127: EMPTY
68128: LIST
68129: LIST
68130: PUSH
68131: LD_INT 2
68133: PUSH
68134: LD_INT 2
68136: PUSH
68137: EMPTY
68138: LIST
68139: LIST
68140: PUSH
68141: LD_INT 1
68143: PUSH
68144: LD_INT 2
68146: PUSH
68147: EMPTY
68148: LIST
68149: LIST
68150: PUSH
68151: LD_INT 0
68153: PUSH
68154: LD_INT 2
68156: PUSH
68157: EMPTY
68158: LIST
68159: LIST
68160: PUSH
68161: LD_INT 1
68163: NEG
68164: PUSH
68165: LD_INT 1
68167: PUSH
68168: EMPTY
68169: LIST
68170: LIST
68171: PUSH
68172: LD_INT 2
68174: NEG
68175: PUSH
68176: LD_INT 0
68178: PUSH
68179: EMPTY
68180: LIST
68181: LIST
68182: PUSH
68183: LD_INT 2
68185: NEG
68186: PUSH
68187: LD_INT 1
68189: NEG
68190: PUSH
68191: EMPTY
68192: LIST
68193: LIST
68194: PUSH
68195: LD_INT 2
68197: NEG
68198: PUSH
68199: LD_INT 2
68201: NEG
68202: PUSH
68203: EMPTY
68204: LIST
68205: LIST
68206: PUSH
68207: EMPTY
68208: LIST
68209: LIST
68210: LIST
68211: LIST
68212: LIST
68213: LIST
68214: LIST
68215: LIST
68216: LIST
68217: LIST
68218: LIST
68219: LIST
68220: LIST
68221: LIST
68222: LIST
68223: LIST
68224: LIST
68225: LIST
68226: LIST
68227: ST_TO_ADDR
// DepotAr3 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
68228: LD_ADDR_VAR 0 20
68232: PUSH
68233: LD_INT 0
68235: PUSH
68236: LD_INT 0
68238: PUSH
68239: EMPTY
68240: LIST
68241: LIST
68242: PUSH
68243: LD_INT 0
68245: PUSH
68246: LD_INT 1
68248: NEG
68249: PUSH
68250: EMPTY
68251: LIST
68252: LIST
68253: PUSH
68254: LD_INT 1
68256: PUSH
68257: LD_INT 0
68259: PUSH
68260: EMPTY
68261: LIST
68262: LIST
68263: PUSH
68264: LD_INT 1
68266: PUSH
68267: LD_INT 1
68269: PUSH
68270: EMPTY
68271: LIST
68272: LIST
68273: PUSH
68274: LD_INT 0
68276: PUSH
68277: LD_INT 1
68279: PUSH
68280: EMPTY
68281: LIST
68282: LIST
68283: PUSH
68284: LD_INT 1
68286: NEG
68287: PUSH
68288: LD_INT 0
68290: PUSH
68291: EMPTY
68292: LIST
68293: LIST
68294: PUSH
68295: LD_INT 1
68297: NEG
68298: PUSH
68299: LD_INT 1
68301: NEG
68302: PUSH
68303: EMPTY
68304: LIST
68305: LIST
68306: PUSH
68307: LD_INT 1
68309: NEG
68310: PUSH
68311: LD_INT 2
68313: NEG
68314: PUSH
68315: EMPTY
68316: LIST
68317: LIST
68318: PUSH
68319: LD_INT 0
68321: PUSH
68322: LD_INT 2
68324: NEG
68325: PUSH
68326: EMPTY
68327: LIST
68328: LIST
68329: PUSH
68330: LD_INT 1
68332: PUSH
68333: LD_INT 1
68335: NEG
68336: PUSH
68337: EMPTY
68338: LIST
68339: LIST
68340: PUSH
68341: LD_INT 2
68343: PUSH
68344: LD_INT 0
68346: PUSH
68347: EMPTY
68348: LIST
68349: LIST
68350: PUSH
68351: LD_INT 2
68353: PUSH
68354: LD_INT 1
68356: PUSH
68357: EMPTY
68358: LIST
68359: LIST
68360: PUSH
68361: LD_INT 2
68363: PUSH
68364: LD_INT 2
68366: PUSH
68367: EMPTY
68368: LIST
68369: LIST
68370: PUSH
68371: LD_INT 1
68373: PUSH
68374: LD_INT 2
68376: PUSH
68377: EMPTY
68378: LIST
68379: LIST
68380: PUSH
68381: LD_INT 0
68383: PUSH
68384: LD_INT 2
68386: PUSH
68387: EMPTY
68388: LIST
68389: LIST
68390: PUSH
68391: LD_INT 1
68393: NEG
68394: PUSH
68395: LD_INT 1
68397: PUSH
68398: EMPTY
68399: LIST
68400: LIST
68401: PUSH
68402: LD_INT 2
68404: NEG
68405: PUSH
68406: LD_INT 0
68408: PUSH
68409: EMPTY
68410: LIST
68411: LIST
68412: PUSH
68413: LD_INT 2
68415: NEG
68416: PUSH
68417: LD_INT 1
68419: NEG
68420: PUSH
68421: EMPTY
68422: LIST
68423: LIST
68424: PUSH
68425: LD_INT 2
68427: NEG
68428: PUSH
68429: LD_INT 2
68431: NEG
68432: PUSH
68433: EMPTY
68434: LIST
68435: LIST
68436: PUSH
68437: EMPTY
68438: LIST
68439: LIST
68440: LIST
68441: LIST
68442: LIST
68443: LIST
68444: LIST
68445: LIST
68446: LIST
68447: LIST
68448: LIST
68449: LIST
68450: LIST
68451: LIST
68452: LIST
68453: LIST
68454: LIST
68455: LIST
68456: LIST
68457: ST_TO_ADDR
// DepotAr4 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
68458: LD_ADDR_VAR 0 21
68462: PUSH
68463: LD_INT 0
68465: PUSH
68466: LD_INT 0
68468: PUSH
68469: EMPTY
68470: LIST
68471: LIST
68472: PUSH
68473: LD_INT 0
68475: PUSH
68476: LD_INT 1
68478: NEG
68479: PUSH
68480: EMPTY
68481: LIST
68482: LIST
68483: PUSH
68484: LD_INT 1
68486: PUSH
68487: LD_INT 0
68489: PUSH
68490: EMPTY
68491: LIST
68492: LIST
68493: PUSH
68494: LD_INT 1
68496: PUSH
68497: LD_INT 1
68499: PUSH
68500: EMPTY
68501: LIST
68502: LIST
68503: PUSH
68504: LD_INT 0
68506: PUSH
68507: LD_INT 1
68509: PUSH
68510: EMPTY
68511: LIST
68512: LIST
68513: PUSH
68514: LD_INT 1
68516: NEG
68517: PUSH
68518: LD_INT 0
68520: PUSH
68521: EMPTY
68522: LIST
68523: LIST
68524: PUSH
68525: LD_INT 1
68527: NEG
68528: PUSH
68529: LD_INT 1
68531: NEG
68532: PUSH
68533: EMPTY
68534: LIST
68535: LIST
68536: PUSH
68537: LD_INT 1
68539: NEG
68540: PUSH
68541: LD_INT 2
68543: NEG
68544: PUSH
68545: EMPTY
68546: LIST
68547: LIST
68548: PUSH
68549: LD_INT 0
68551: PUSH
68552: LD_INT 2
68554: NEG
68555: PUSH
68556: EMPTY
68557: LIST
68558: LIST
68559: PUSH
68560: LD_INT 1
68562: PUSH
68563: LD_INT 1
68565: NEG
68566: PUSH
68567: EMPTY
68568: LIST
68569: LIST
68570: PUSH
68571: LD_INT 2
68573: PUSH
68574: LD_INT 0
68576: PUSH
68577: EMPTY
68578: LIST
68579: LIST
68580: PUSH
68581: LD_INT 2
68583: PUSH
68584: LD_INT 1
68586: PUSH
68587: EMPTY
68588: LIST
68589: LIST
68590: PUSH
68591: LD_INT 2
68593: PUSH
68594: LD_INT 2
68596: PUSH
68597: EMPTY
68598: LIST
68599: LIST
68600: PUSH
68601: LD_INT 1
68603: PUSH
68604: LD_INT 2
68606: PUSH
68607: EMPTY
68608: LIST
68609: LIST
68610: PUSH
68611: LD_INT 0
68613: PUSH
68614: LD_INT 2
68616: PUSH
68617: EMPTY
68618: LIST
68619: LIST
68620: PUSH
68621: LD_INT 1
68623: NEG
68624: PUSH
68625: LD_INT 1
68627: PUSH
68628: EMPTY
68629: LIST
68630: LIST
68631: PUSH
68632: LD_INT 2
68634: NEG
68635: PUSH
68636: LD_INT 0
68638: PUSH
68639: EMPTY
68640: LIST
68641: LIST
68642: PUSH
68643: LD_INT 2
68645: NEG
68646: PUSH
68647: LD_INT 1
68649: NEG
68650: PUSH
68651: EMPTY
68652: LIST
68653: LIST
68654: PUSH
68655: LD_INT 2
68657: NEG
68658: PUSH
68659: LD_INT 2
68661: NEG
68662: PUSH
68663: EMPTY
68664: LIST
68665: LIST
68666: PUSH
68667: EMPTY
68668: LIST
68669: LIST
68670: LIST
68671: LIST
68672: LIST
68673: LIST
68674: LIST
68675: LIST
68676: LIST
68677: LIST
68678: LIST
68679: LIST
68680: LIST
68681: LIST
68682: LIST
68683: LIST
68684: LIST
68685: LIST
68686: LIST
68687: ST_TO_ADDR
// DepotAr5 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
68688: LD_ADDR_VAR 0 22
68692: PUSH
68693: LD_INT 0
68695: PUSH
68696: LD_INT 0
68698: PUSH
68699: EMPTY
68700: LIST
68701: LIST
68702: PUSH
68703: LD_INT 0
68705: PUSH
68706: LD_INT 1
68708: NEG
68709: PUSH
68710: EMPTY
68711: LIST
68712: LIST
68713: PUSH
68714: LD_INT 1
68716: PUSH
68717: LD_INT 0
68719: PUSH
68720: EMPTY
68721: LIST
68722: LIST
68723: PUSH
68724: LD_INT 1
68726: PUSH
68727: LD_INT 1
68729: PUSH
68730: EMPTY
68731: LIST
68732: LIST
68733: PUSH
68734: LD_INT 0
68736: PUSH
68737: LD_INT 1
68739: PUSH
68740: EMPTY
68741: LIST
68742: LIST
68743: PUSH
68744: LD_INT 1
68746: NEG
68747: PUSH
68748: LD_INT 0
68750: PUSH
68751: EMPTY
68752: LIST
68753: LIST
68754: PUSH
68755: LD_INT 1
68757: NEG
68758: PUSH
68759: LD_INT 1
68761: NEG
68762: PUSH
68763: EMPTY
68764: LIST
68765: LIST
68766: PUSH
68767: LD_INT 1
68769: NEG
68770: PUSH
68771: LD_INT 2
68773: NEG
68774: PUSH
68775: EMPTY
68776: LIST
68777: LIST
68778: PUSH
68779: LD_INT 0
68781: PUSH
68782: LD_INT 2
68784: NEG
68785: PUSH
68786: EMPTY
68787: LIST
68788: LIST
68789: PUSH
68790: LD_INT 1
68792: PUSH
68793: LD_INT 1
68795: NEG
68796: PUSH
68797: EMPTY
68798: LIST
68799: LIST
68800: PUSH
68801: LD_INT 2
68803: PUSH
68804: LD_INT 0
68806: PUSH
68807: EMPTY
68808: LIST
68809: LIST
68810: PUSH
68811: LD_INT 2
68813: PUSH
68814: LD_INT 1
68816: PUSH
68817: EMPTY
68818: LIST
68819: LIST
68820: PUSH
68821: LD_INT 2
68823: PUSH
68824: LD_INT 2
68826: PUSH
68827: EMPTY
68828: LIST
68829: LIST
68830: PUSH
68831: LD_INT 1
68833: PUSH
68834: LD_INT 2
68836: PUSH
68837: EMPTY
68838: LIST
68839: LIST
68840: PUSH
68841: LD_INT 0
68843: PUSH
68844: LD_INT 2
68846: PUSH
68847: EMPTY
68848: LIST
68849: LIST
68850: PUSH
68851: LD_INT 1
68853: NEG
68854: PUSH
68855: LD_INT 1
68857: PUSH
68858: EMPTY
68859: LIST
68860: LIST
68861: PUSH
68862: LD_INT 2
68864: NEG
68865: PUSH
68866: LD_INT 0
68868: PUSH
68869: EMPTY
68870: LIST
68871: LIST
68872: PUSH
68873: LD_INT 2
68875: NEG
68876: PUSH
68877: LD_INT 1
68879: NEG
68880: PUSH
68881: EMPTY
68882: LIST
68883: LIST
68884: PUSH
68885: LD_INT 2
68887: NEG
68888: PUSH
68889: LD_INT 2
68891: NEG
68892: PUSH
68893: EMPTY
68894: LIST
68895: LIST
68896: PUSH
68897: EMPTY
68898: LIST
68899: LIST
68900: LIST
68901: LIST
68902: LIST
68903: LIST
68904: LIST
68905: LIST
68906: LIST
68907: LIST
68908: LIST
68909: LIST
68910: LIST
68911: LIST
68912: LIST
68913: LIST
68914: LIST
68915: LIST
68916: LIST
68917: ST_TO_ADDR
// DepotRu0 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ - 2 , - 3 ] , [ - 1 , - 3 ] , [ 1 , - 2 ] , [ 2 , - 1 ] ] ;
68918: LD_ADDR_VAR 0 23
68922: PUSH
68923: LD_INT 0
68925: PUSH
68926: LD_INT 0
68928: PUSH
68929: EMPTY
68930: LIST
68931: LIST
68932: PUSH
68933: LD_INT 0
68935: PUSH
68936: LD_INT 1
68938: NEG
68939: PUSH
68940: EMPTY
68941: LIST
68942: LIST
68943: PUSH
68944: LD_INT 1
68946: PUSH
68947: LD_INT 0
68949: PUSH
68950: EMPTY
68951: LIST
68952: LIST
68953: PUSH
68954: LD_INT 1
68956: PUSH
68957: LD_INT 1
68959: PUSH
68960: EMPTY
68961: LIST
68962: LIST
68963: PUSH
68964: LD_INT 0
68966: PUSH
68967: LD_INT 1
68969: PUSH
68970: EMPTY
68971: LIST
68972: LIST
68973: PUSH
68974: LD_INT 1
68976: NEG
68977: PUSH
68978: LD_INT 0
68980: PUSH
68981: EMPTY
68982: LIST
68983: LIST
68984: PUSH
68985: LD_INT 1
68987: NEG
68988: PUSH
68989: LD_INT 1
68991: NEG
68992: PUSH
68993: EMPTY
68994: LIST
68995: LIST
68996: PUSH
68997: LD_INT 1
68999: NEG
69000: PUSH
69001: LD_INT 2
69003: NEG
69004: PUSH
69005: EMPTY
69006: LIST
69007: LIST
69008: PUSH
69009: LD_INT 0
69011: PUSH
69012: LD_INT 2
69014: NEG
69015: PUSH
69016: EMPTY
69017: LIST
69018: LIST
69019: PUSH
69020: LD_INT 1
69022: PUSH
69023: LD_INT 1
69025: NEG
69026: PUSH
69027: EMPTY
69028: LIST
69029: LIST
69030: PUSH
69031: LD_INT 2
69033: PUSH
69034: LD_INT 0
69036: PUSH
69037: EMPTY
69038: LIST
69039: LIST
69040: PUSH
69041: LD_INT 2
69043: PUSH
69044: LD_INT 1
69046: PUSH
69047: EMPTY
69048: LIST
69049: LIST
69050: PUSH
69051: LD_INT 2
69053: PUSH
69054: LD_INT 2
69056: PUSH
69057: EMPTY
69058: LIST
69059: LIST
69060: PUSH
69061: LD_INT 1
69063: PUSH
69064: LD_INT 2
69066: PUSH
69067: EMPTY
69068: LIST
69069: LIST
69070: PUSH
69071: LD_INT 0
69073: PUSH
69074: LD_INT 2
69076: PUSH
69077: EMPTY
69078: LIST
69079: LIST
69080: PUSH
69081: LD_INT 1
69083: NEG
69084: PUSH
69085: LD_INT 1
69087: PUSH
69088: EMPTY
69089: LIST
69090: LIST
69091: PUSH
69092: LD_INT 2
69094: NEG
69095: PUSH
69096: LD_INT 0
69098: PUSH
69099: EMPTY
69100: LIST
69101: LIST
69102: PUSH
69103: LD_INT 2
69105: NEG
69106: PUSH
69107: LD_INT 1
69109: NEG
69110: PUSH
69111: EMPTY
69112: LIST
69113: LIST
69114: PUSH
69115: LD_INT 2
69117: NEG
69118: PUSH
69119: LD_INT 2
69121: NEG
69122: PUSH
69123: EMPTY
69124: LIST
69125: LIST
69126: PUSH
69127: LD_INT 2
69129: NEG
69130: PUSH
69131: LD_INT 3
69133: NEG
69134: PUSH
69135: EMPTY
69136: LIST
69137: LIST
69138: PUSH
69139: LD_INT 1
69141: NEG
69142: PUSH
69143: LD_INT 3
69145: NEG
69146: PUSH
69147: EMPTY
69148: LIST
69149: LIST
69150: PUSH
69151: LD_INT 1
69153: PUSH
69154: LD_INT 2
69156: NEG
69157: PUSH
69158: EMPTY
69159: LIST
69160: LIST
69161: PUSH
69162: LD_INT 2
69164: PUSH
69165: LD_INT 1
69167: NEG
69168: PUSH
69169: EMPTY
69170: LIST
69171: LIST
69172: PUSH
69173: EMPTY
69174: LIST
69175: LIST
69176: LIST
69177: LIST
69178: LIST
69179: LIST
69180: LIST
69181: LIST
69182: LIST
69183: LIST
69184: LIST
69185: LIST
69186: LIST
69187: LIST
69188: LIST
69189: LIST
69190: LIST
69191: LIST
69192: LIST
69193: LIST
69194: LIST
69195: LIST
69196: LIST
69197: ST_TO_ADDR
// DepotRu1 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ 1 , - 2 ] , [ 2 , - 1 ] , [ 3 , 1 ] , [ 3 , 2 ] ] ;
69198: LD_ADDR_VAR 0 24
69202: PUSH
69203: LD_INT 0
69205: PUSH
69206: LD_INT 0
69208: PUSH
69209: EMPTY
69210: LIST
69211: LIST
69212: PUSH
69213: LD_INT 0
69215: PUSH
69216: LD_INT 1
69218: NEG
69219: PUSH
69220: EMPTY
69221: LIST
69222: LIST
69223: PUSH
69224: LD_INT 1
69226: PUSH
69227: LD_INT 0
69229: PUSH
69230: EMPTY
69231: LIST
69232: LIST
69233: PUSH
69234: LD_INT 1
69236: PUSH
69237: LD_INT 1
69239: PUSH
69240: EMPTY
69241: LIST
69242: LIST
69243: PUSH
69244: LD_INT 0
69246: PUSH
69247: LD_INT 1
69249: PUSH
69250: EMPTY
69251: LIST
69252: LIST
69253: PUSH
69254: LD_INT 1
69256: NEG
69257: PUSH
69258: LD_INT 0
69260: PUSH
69261: EMPTY
69262: LIST
69263: LIST
69264: PUSH
69265: LD_INT 1
69267: NEG
69268: PUSH
69269: LD_INT 1
69271: NEG
69272: PUSH
69273: EMPTY
69274: LIST
69275: LIST
69276: PUSH
69277: LD_INT 1
69279: NEG
69280: PUSH
69281: LD_INT 2
69283: NEG
69284: PUSH
69285: EMPTY
69286: LIST
69287: LIST
69288: PUSH
69289: LD_INT 0
69291: PUSH
69292: LD_INT 2
69294: NEG
69295: PUSH
69296: EMPTY
69297: LIST
69298: LIST
69299: PUSH
69300: LD_INT 1
69302: PUSH
69303: LD_INT 1
69305: NEG
69306: PUSH
69307: EMPTY
69308: LIST
69309: LIST
69310: PUSH
69311: LD_INT 2
69313: PUSH
69314: LD_INT 0
69316: PUSH
69317: EMPTY
69318: LIST
69319: LIST
69320: PUSH
69321: LD_INT 2
69323: PUSH
69324: LD_INT 1
69326: PUSH
69327: EMPTY
69328: LIST
69329: LIST
69330: PUSH
69331: LD_INT 2
69333: PUSH
69334: LD_INT 2
69336: PUSH
69337: EMPTY
69338: LIST
69339: LIST
69340: PUSH
69341: LD_INT 1
69343: PUSH
69344: LD_INT 2
69346: PUSH
69347: EMPTY
69348: LIST
69349: LIST
69350: PUSH
69351: LD_INT 0
69353: PUSH
69354: LD_INT 2
69356: PUSH
69357: EMPTY
69358: LIST
69359: LIST
69360: PUSH
69361: LD_INT 1
69363: NEG
69364: PUSH
69365: LD_INT 1
69367: PUSH
69368: EMPTY
69369: LIST
69370: LIST
69371: PUSH
69372: LD_INT 2
69374: NEG
69375: PUSH
69376: LD_INT 0
69378: PUSH
69379: EMPTY
69380: LIST
69381: LIST
69382: PUSH
69383: LD_INT 2
69385: NEG
69386: PUSH
69387: LD_INT 1
69389: NEG
69390: PUSH
69391: EMPTY
69392: LIST
69393: LIST
69394: PUSH
69395: LD_INT 2
69397: NEG
69398: PUSH
69399: LD_INT 2
69401: NEG
69402: PUSH
69403: EMPTY
69404: LIST
69405: LIST
69406: PUSH
69407: LD_INT 1
69409: PUSH
69410: LD_INT 2
69412: NEG
69413: PUSH
69414: EMPTY
69415: LIST
69416: LIST
69417: PUSH
69418: LD_INT 2
69420: PUSH
69421: LD_INT 1
69423: NEG
69424: PUSH
69425: EMPTY
69426: LIST
69427: LIST
69428: PUSH
69429: LD_INT 3
69431: PUSH
69432: LD_INT 1
69434: PUSH
69435: EMPTY
69436: LIST
69437: LIST
69438: PUSH
69439: LD_INT 3
69441: PUSH
69442: LD_INT 2
69444: PUSH
69445: EMPTY
69446: LIST
69447: LIST
69448: PUSH
69449: EMPTY
69450: LIST
69451: LIST
69452: LIST
69453: LIST
69454: LIST
69455: LIST
69456: LIST
69457: LIST
69458: LIST
69459: LIST
69460: LIST
69461: LIST
69462: LIST
69463: LIST
69464: LIST
69465: LIST
69466: LIST
69467: LIST
69468: LIST
69469: LIST
69470: LIST
69471: LIST
69472: LIST
69473: ST_TO_ADDR
// DepotRu2 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ 3 , 1 ] , [ 3 , 2 ] , [ 2 , 3 ] , [ 1 , 3 ] ] ;
69474: LD_ADDR_VAR 0 25
69478: PUSH
69479: LD_INT 0
69481: PUSH
69482: LD_INT 0
69484: PUSH
69485: EMPTY
69486: LIST
69487: LIST
69488: PUSH
69489: LD_INT 0
69491: PUSH
69492: LD_INT 1
69494: NEG
69495: PUSH
69496: EMPTY
69497: LIST
69498: LIST
69499: PUSH
69500: LD_INT 1
69502: PUSH
69503: LD_INT 0
69505: PUSH
69506: EMPTY
69507: LIST
69508: LIST
69509: PUSH
69510: LD_INT 1
69512: PUSH
69513: LD_INT 1
69515: PUSH
69516: EMPTY
69517: LIST
69518: LIST
69519: PUSH
69520: LD_INT 0
69522: PUSH
69523: LD_INT 1
69525: PUSH
69526: EMPTY
69527: LIST
69528: LIST
69529: PUSH
69530: LD_INT 1
69532: NEG
69533: PUSH
69534: LD_INT 0
69536: PUSH
69537: EMPTY
69538: LIST
69539: LIST
69540: PUSH
69541: LD_INT 1
69543: NEG
69544: PUSH
69545: LD_INT 1
69547: NEG
69548: PUSH
69549: EMPTY
69550: LIST
69551: LIST
69552: PUSH
69553: LD_INT 1
69555: NEG
69556: PUSH
69557: LD_INT 2
69559: NEG
69560: PUSH
69561: EMPTY
69562: LIST
69563: LIST
69564: PUSH
69565: LD_INT 0
69567: PUSH
69568: LD_INT 2
69570: NEG
69571: PUSH
69572: EMPTY
69573: LIST
69574: LIST
69575: PUSH
69576: LD_INT 1
69578: PUSH
69579: LD_INT 1
69581: NEG
69582: PUSH
69583: EMPTY
69584: LIST
69585: LIST
69586: PUSH
69587: LD_INT 2
69589: PUSH
69590: LD_INT 0
69592: PUSH
69593: EMPTY
69594: LIST
69595: LIST
69596: PUSH
69597: LD_INT 2
69599: PUSH
69600: LD_INT 1
69602: PUSH
69603: EMPTY
69604: LIST
69605: LIST
69606: PUSH
69607: LD_INT 2
69609: PUSH
69610: LD_INT 2
69612: PUSH
69613: EMPTY
69614: LIST
69615: LIST
69616: PUSH
69617: LD_INT 1
69619: PUSH
69620: LD_INT 2
69622: PUSH
69623: EMPTY
69624: LIST
69625: LIST
69626: PUSH
69627: LD_INT 0
69629: PUSH
69630: LD_INT 2
69632: PUSH
69633: EMPTY
69634: LIST
69635: LIST
69636: PUSH
69637: LD_INT 1
69639: NEG
69640: PUSH
69641: LD_INT 1
69643: PUSH
69644: EMPTY
69645: LIST
69646: LIST
69647: PUSH
69648: LD_INT 2
69650: NEG
69651: PUSH
69652: LD_INT 0
69654: PUSH
69655: EMPTY
69656: LIST
69657: LIST
69658: PUSH
69659: LD_INT 2
69661: NEG
69662: PUSH
69663: LD_INT 1
69665: NEG
69666: PUSH
69667: EMPTY
69668: LIST
69669: LIST
69670: PUSH
69671: LD_INT 2
69673: NEG
69674: PUSH
69675: LD_INT 2
69677: NEG
69678: PUSH
69679: EMPTY
69680: LIST
69681: LIST
69682: PUSH
69683: LD_INT 3
69685: PUSH
69686: LD_INT 1
69688: PUSH
69689: EMPTY
69690: LIST
69691: LIST
69692: PUSH
69693: LD_INT 3
69695: PUSH
69696: LD_INT 2
69698: PUSH
69699: EMPTY
69700: LIST
69701: LIST
69702: PUSH
69703: LD_INT 2
69705: PUSH
69706: LD_INT 3
69708: PUSH
69709: EMPTY
69710: LIST
69711: LIST
69712: PUSH
69713: LD_INT 1
69715: PUSH
69716: LD_INT 3
69718: PUSH
69719: EMPTY
69720: LIST
69721: LIST
69722: PUSH
69723: EMPTY
69724: LIST
69725: LIST
69726: LIST
69727: LIST
69728: LIST
69729: LIST
69730: LIST
69731: LIST
69732: LIST
69733: LIST
69734: LIST
69735: LIST
69736: LIST
69737: LIST
69738: LIST
69739: LIST
69740: LIST
69741: LIST
69742: LIST
69743: LIST
69744: LIST
69745: LIST
69746: LIST
69747: ST_TO_ADDR
// DepotRu3 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ 2 , 3 ] , [ 1 , 3 ] , [ - 1 , 2 ] , [ - 2 , 1 ] ] ;
69748: LD_ADDR_VAR 0 26
69752: PUSH
69753: LD_INT 0
69755: PUSH
69756: LD_INT 0
69758: PUSH
69759: EMPTY
69760: LIST
69761: LIST
69762: PUSH
69763: LD_INT 0
69765: PUSH
69766: LD_INT 1
69768: NEG
69769: PUSH
69770: EMPTY
69771: LIST
69772: LIST
69773: PUSH
69774: LD_INT 1
69776: PUSH
69777: LD_INT 0
69779: PUSH
69780: EMPTY
69781: LIST
69782: LIST
69783: PUSH
69784: LD_INT 1
69786: PUSH
69787: LD_INT 1
69789: PUSH
69790: EMPTY
69791: LIST
69792: LIST
69793: PUSH
69794: LD_INT 0
69796: PUSH
69797: LD_INT 1
69799: PUSH
69800: EMPTY
69801: LIST
69802: LIST
69803: PUSH
69804: LD_INT 1
69806: NEG
69807: PUSH
69808: LD_INT 0
69810: PUSH
69811: EMPTY
69812: LIST
69813: LIST
69814: PUSH
69815: LD_INT 1
69817: NEG
69818: PUSH
69819: LD_INT 1
69821: NEG
69822: PUSH
69823: EMPTY
69824: LIST
69825: LIST
69826: PUSH
69827: LD_INT 1
69829: NEG
69830: PUSH
69831: LD_INT 2
69833: NEG
69834: PUSH
69835: EMPTY
69836: LIST
69837: LIST
69838: PUSH
69839: LD_INT 0
69841: PUSH
69842: LD_INT 2
69844: NEG
69845: PUSH
69846: EMPTY
69847: LIST
69848: LIST
69849: PUSH
69850: LD_INT 1
69852: PUSH
69853: LD_INT 1
69855: NEG
69856: PUSH
69857: EMPTY
69858: LIST
69859: LIST
69860: PUSH
69861: LD_INT 2
69863: PUSH
69864: LD_INT 0
69866: PUSH
69867: EMPTY
69868: LIST
69869: LIST
69870: PUSH
69871: LD_INT 2
69873: PUSH
69874: LD_INT 1
69876: PUSH
69877: EMPTY
69878: LIST
69879: LIST
69880: PUSH
69881: LD_INT 2
69883: PUSH
69884: LD_INT 2
69886: PUSH
69887: EMPTY
69888: LIST
69889: LIST
69890: PUSH
69891: LD_INT 1
69893: PUSH
69894: LD_INT 2
69896: PUSH
69897: EMPTY
69898: LIST
69899: LIST
69900: PUSH
69901: LD_INT 0
69903: PUSH
69904: LD_INT 2
69906: PUSH
69907: EMPTY
69908: LIST
69909: LIST
69910: PUSH
69911: LD_INT 1
69913: NEG
69914: PUSH
69915: LD_INT 1
69917: PUSH
69918: EMPTY
69919: LIST
69920: LIST
69921: PUSH
69922: LD_INT 2
69924: NEG
69925: PUSH
69926: LD_INT 0
69928: PUSH
69929: EMPTY
69930: LIST
69931: LIST
69932: PUSH
69933: LD_INT 2
69935: NEG
69936: PUSH
69937: LD_INT 1
69939: NEG
69940: PUSH
69941: EMPTY
69942: LIST
69943: LIST
69944: PUSH
69945: LD_INT 2
69947: NEG
69948: PUSH
69949: LD_INT 2
69951: NEG
69952: PUSH
69953: EMPTY
69954: LIST
69955: LIST
69956: PUSH
69957: LD_INT 2
69959: PUSH
69960: LD_INT 3
69962: PUSH
69963: EMPTY
69964: LIST
69965: LIST
69966: PUSH
69967: LD_INT 1
69969: PUSH
69970: LD_INT 3
69972: PUSH
69973: EMPTY
69974: LIST
69975: LIST
69976: PUSH
69977: LD_INT 1
69979: NEG
69980: PUSH
69981: LD_INT 2
69983: PUSH
69984: EMPTY
69985: LIST
69986: LIST
69987: PUSH
69988: LD_INT 2
69990: NEG
69991: PUSH
69992: LD_INT 1
69994: PUSH
69995: EMPTY
69996: LIST
69997: LIST
69998: PUSH
69999: EMPTY
70000: LIST
70001: LIST
70002: LIST
70003: LIST
70004: LIST
70005: LIST
70006: LIST
70007: LIST
70008: LIST
70009: LIST
70010: LIST
70011: LIST
70012: LIST
70013: LIST
70014: LIST
70015: LIST
70016: LIST
70017: LIST
70018: LIST
70019: LIST
70020: LIST
70021: LIST
70022: LIST
70023: ST_TO_ADDR
// DepotRu4 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ - 1 , 2 ] , [ - 2 , 1 ] , [ - 3 , - 1 ] , [ - 3 , - 2 ] ] ;
70024: LD_ADDR_VAR 0 27
70028: PUSH
70029: LD_INT 0
70031: PUSH
70032: LD_INT 0
70034: PUSH
70035: EMPTY
70036: LIST
70037: LIST
70038: PUSH
70039: LD_INT 0
70041: PUSH
70042: LD_INT 1
70044: NEG
70045: PUSH
70046: EMPTY
70047: LIST
70048: LIST
70049: PUSH
70050: LD_INT 1
70052: PUSH
70053: LD_INT 0
70055: PUSH
70056: EMPTY
70057: LIST
70058: LIST
70059: PUSH
70060: LD_INT 1
70062: PUSH
70063: LD_INT 1
70065: PUSH
70066: EMPTY
70067: LIST
70068: LIST
70069: PUSH
70070: LD_INT 0
70072: PUSH
70073: LD_INT 1
70075: PUSH
70076: EMPTY
70077: LIST
70078: LIST
70079: PUSH
70080: LD_INT 1
70082: NEG
70083: PUSH
70084: LD_INT 0
70086: PUSH
70087: EMPTY
70088: LIST
70089: LIST
70090: PUSH
70091: LD_INT 1
70093: NEG
70094: PUSH
70095: LD_INT 1
70097: NEG
70098: PUSH
70099: EMPTY
70100: LIST
70101: LIST
70102: PUSH
70103: LD_INT 1
70105: NEG
70106: PUSH
70107: LD_INT 2
70109: NEG
70110: PUSH
70111: EMPTY
70112: LIST
70113: LIST
70114: PUSH
70115: LD_INT 0
70117: PUSH
70118: LD_INT 2
70120: NEG
70121: PUSH
70122: EMPTY
70123: LIST
70124: LIST
70125: PUSH
70126: LD_INT 1
70128: PUSH
70129: LD_INT 1
70131: NEG
70132: PUSH
70133: EMPTY
70134: LIST
70135: LIST
70136: PUSH
70137: LD_INT 2
70139: PUSH
70140: LD_INT 0
70142: PUSH
70143: EMPTY
70144: LIST
70145: LIST
70146: PUSH
70147: LD_INT 2
70149: PUSH
70150: LD_INT 1
70152: PUSH
70153: EMPTY
70154: LIST
70155: LIST
70156: PUSH
70157: LD_INT 2
70159: PUSH
70160: LD_INT 2
70162: PUSH
70163: EMPTY
70164: LIST
70165: LIST
70166: PUSH
70167: LD_INT 1
70169: PUSH
70170: LD_INT 2
70172: PUSH
70173: EMPTY
70174: LIST
70175: LIST
70176: PUSH
70177: LD_INT 0
70179: PUSH
70180: LD_INT 2
70182: PUSH
70183: EMPTY
70184: LIST
70185: LIST
70186: PUSH
70187: LD_INT 1
70189: NEG
70190: PUSH
70191: LD_INT 1
70193: PUSH
70194: EMPTY
70195: LIST
70196: LIST
70197: PUSH
70198: LD_INT 2
70200: NEG
70201: PUSH
70202: LD_INT 0
70204: PUSH
70205: EMPTY
70206: LIST
70207: LIST
70208: PUSH
70209: LD_INT 2
70211: NEG
70212: PUSH
70213: LD_INT 1
70215: NEG
70216: PUSH
70217: EMPTY
70218: LIST
70219: LIST
70220: PUSH
70221: LD_INT 2
70223: NEG
70224: PUSH
70225: LD_INT 2
70227: NEG
70228: PUSH
70229: EMPTY
70230: LIST
70231: LIST
70232: PUSH
70233: LD_INT 1
70235: NEG
70236: PUSH
70237: LD_INT 2
70239: PUSH
70240: EMPTY
70241: LIST
70242: LIST
70243: PUSH
70244: LD_INT 2
70246: NEG
70247: PUSH
70248: LD_INT 1
70250: PUSH
70251: EMPTY
70252: LIST
70253: LIST
70254: PUSH
70255: LD_INT 3
70257: NEG
70258: PUSH
70259: LD_INT 1
70261: NEG
70262: PUSH
70263: EMPTY
70264: LIST
70265: LIST
70266: PUSH
70267: LD_INT 3
70269: NEG
70270: PUSH
70271: LD_INT 2
70273: NEG
70274: PUSH
70275: EMPTY
70276: LIST
70277: LIST
70278: PUSH
70279: EMPTY
70280: LIST
70281: LIST
70282: LIST
70283: LIST
70284: LIST
70285: LIST
70286: LIST
70287: LIST
70288: LIST
70289: LIST
70290: LIST
70291: LIST
70292: LIST
70293: LIST
70294: LIST
70295: LIST
70296: LIST
70297: LIST
70298: LIST
70299: LIST
70300: LIST
70301: LIST
70302: LIST
70303: ST_TO_ADDR
// DepotRu5 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ - 2 , - 3 ] , [ - 1 , - 3 ] , [ - 3 , - 1 ] , [ - 3 , - 2 ] ] ;
70304: LD_ADDR_VAR 0 28
70308: PUSH
70309: LD_INT 0
70311: PUSH
70312: LD_INT 0
70314: PUSH
70315: EMPTY
70316: LIST
70317: LIST
70318: PUSH
70319: LD_INT 0
70321: PUSH
70322: LD_INT 1
70324: NEG
70325: PUSH
70326: EMPTY
70327: LIST
70328: LIST
70329: PUSH
70330: LD_INT 1
70332: PUSH
70333: LD_INT 0
70335: PUSH
70336: EMPTY
70337: LIST
70338: LIST
70339: PUSH
70340: LD_INT 1
70342: PUSH
70343: LD_INT 1
70345: PUSH
70346: EMPTY
70347: LIST
70348: LIST
70349: PUSH
70350: LD_INT 0
70352: PUSH
70353: LD_INT 1
70355: PUSH
70356: EMPTY
70357: LIST
70358: LIST
70359: PUSH
70360: LD_INT 1
70362: NEG
70363: PUSH
70364: LD_INT 0
70366: PUSH
70367: EMPTY
70368: LIST
70369: LIST
70370: PUSH
70371: LD_INT 1
70373: NEG
70374: PUSH
70375: LD_INT 1
70377: NEG
70378: PUSH
70379: EMPTY
70380: LIST
70381: LIST
70382: PUSH
70383: LD_INT 1
70385: NEG
70386: PUSH
70387: LD_INT 2
70389: NEG
70390: PUSH
70391: EMPTY
70392: LIST
70393: LIST
70394: PUSH
70395: LD_INT 0
70397: PUSH
70398: LD_INT 2
70400: NEG
70401: PUSH
70402: EMPTY
70403: LIST
70404: LIST
70405: PUSH
70406: LD_INT 1
70408: PUSH
70409: LD_INT 1
70411: NEG
70412: PUSH
70413: EMPTY
70414: LIST
70415: LIST
70416: PUSH
70417: LD_INT 2
70419: PUSH
70420: LD_INT 0
70422: PUSH
70423: EMPTY
70424: LIST
70425: LIST
70426: PUSH
70427: LD_INT 2
70429: PUSH
70430: LD_INT 1
70432: PUSH
70433: EMPTY
70434: LIST
70435: LIST
70436: PUSH
70437: LD_INT 2
70439: PUSH
70440: LD_INT 2
70442: PUSH
70443: EMPTY
70444: LIST
70445: LIST
70446: PUSH
70447: LD_INT 1
70449: PUSH
70450: LD_INT 2
70452: PUSH
70453: EMPTY
70454: LIST
70455: LIST
70456: PUSH
70457: LD_INT 0
70459: PUSH
70460: LD_INT 2
70462: PUSH
70463: EMPTY
70464: LIST
70465: LIST
70466: PUSH
70467: LD_INT 1
70469: NEG
70470: PUSH
70471: LD_INT 1
70473: PUSH
70474: EMPTY
70475: LIST
70476: LIST
70477: PUSH
70478: LD_INT 2
70480: NEG
70481: PUSH
70482: LD_INT 0
70484: PUSH
70485: EMPTY
70486: LIST
70487: LIST
70488: PUSH
70489: LD_INT 2
70491: NEG
70492: PUSH
70493: LD_INT 1
70495: NEG
70496: PUSH
70497: EMPTY
70498: LIST
70499: LIST
70500: PUSH
70501: LD_INT 2
70503: NEG
70504: PUSH
70505: LD_INT 2
70507: NEG
70508: PUSH
70509: EMPTY
70510: LIST
70511: LIST
70512: PUSH
70513: LD_INT 2
70515: NEG
70516: PUSH
70517: LD_INT 3
70519: NEG
70520: PUSH
70521: EMPTY
70522: LIST
70523: LIST
70524: PUSH
70525: LD_INT 1
70527: NEG
70528: PUSH
70529: LD_INT 3
70531: NEG
70532: PUSH
70533: EMPTY
70534: LIST
70535: LIST
70536: PUSH
70537: LD_INT 3
70539: NEG
70540: PUSH
70541: LD_INT 1
70543: NEG
70544: PUSH
70545: EMPTY
70546: LIST
70547: LIST
70548: PUSH
70549: LD_INT 3
70551: NEG
70552: PUSH
70553: LD_INT 2
70555: NEG
70556: PUSH
70557: EMPTY
70558: LIST
70559: LIST
70560: PUSH
70561: EMPTY
70562: LIST
70563: LIST
70564: LIST
70565: LIST
70566: LIST
70567: LIST
70568: LIST
70569: LIST
70570: LIST
70571: LIST
70572: LIST
70573: LIST
70574: LIST
70575: LIST
70576: LIST
70577: LIST
70578: LIST
70579: LIST
70580: LIST
70581: LIST
70582: LIST
70583: LIST
70584: LIST
70585: ST_TO_ADDR
// Factory0 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ - 2 , - 3 ] , [ 2 , - 1 ] , [ 3 , 1 ] , [ 1 , 3 ] , [ - 1 , 2 ] , [ - 3 , - 2 ] ] ;
70586: LD_ADDR_VAR 0 29
70590: PUSH
70591: LD_INT 0
70593: PUSH
70594: LD_INT 0
70596: PUSH
70597: EMPTY
70598: LIST
70599: LIST
70600: PUSH
70601: LD_INT 0
70603: PUSH
70604: LD_INT 1
70606: NEG
70607: PUSH
70608: EMPTY
70609: LIST
70610: LIST
70611: PUSH
70612: LD_INT 1
70614: PUSH
70615: LD_INT 0
70617: PUSH
70618: EMPTY
70619: LIST
70620: LIST
70621: PUSH
70622: LD_INT 1
70624: PUSH
70625: LD_INT 1
70627: PUSH
70628: EMPTY
70629: LIST
70630: LIST
70631: PUSH
70632: LD_INT 0
70634: PUSH
70635: LD_INT 1
70637: PUSH
70638: EMPTY
70639: LIST
70640: LIST
70641: PUSH
70642: LD_INT 1
70644: NEG
70645: PUSH
70646: LD_INT 0
70648: PUSH
70649: EMPTY
70650: LIST
70651: LIST
70652: PUSH
70653: LD_INT 1
70655: NEG
70656: PUSH
70657: LD_INT 1
70659: NEG
70660: PUSH
70661: EMPTY
70662: LIST
70663: LIST
70664: PUSH
70665: LD_INT 1
70667: NEG
70668: PUSH
70669: LD_INT 2
70671: NEG
70672: PUSH
70673: EMPTY
70674: LIST
70675: LIST
70676: PUSH
70677: LD_INT 0
70679: PUSH
70680: LD_INT 2
70682: NEG
70683: PUSH
70684: EMPTY
70685: LIST
70686: LIST
70687: PUSH
70688: LD_INT 1
70690: PUSH
70691: LD_INT 1
70693: NEG
70694: PUSH
70695: EMPTY
70696: LIST
70697: LIST
70698: PUSH
70699: LD_INT 2
70701: PUSH
70702: LD_INT 0
70704: PUSH
70705: EMPTY
70706: LIST
70707: LIST
70708: PUSH
70709: LD_INT 2
70711: PUSH
70712: LD_INT 1
70714: PUSH
70715: EMPTY
70716: LIST
70717: LIST
70718: PUSH
70719: LD_INT 1
70721: PUSH
70722: LD_INT 2
70724: PUSH
70725: EMPTY
70726: LIST
70727: LIST
70728: PUSH
70729: LD_INT 0
70731: PUSH
70732: LD_INT 2
70734: PUSH
70735: EMPTY
70736: LIST
70737: LIST
70738: PUSH
70739: LD_INT 1
70741: NEG
70742: PUSH
70743: LD_INT 1
70745: PUSH
70746: EMPTY
70747: LIST
70748: LIST
70749: PUSH
70750: LD_INT 2
70752: NEG
70753: PUSH
70754: LD_INT 1
70756: NEG
70757: PUSH
70758: EMPTY
70759: LIST
70760: LIST
70761: PUSH
70762: LD_INT 2
70764: NEG
70765: PUSH
70766: LD_INT 2
70768: NEG
70769: PUSH
70770: EMPTY
70771: LIST
70772: LIST
70773: PUSH
70774: LD_INT 2
70776: NEG
70777: PUSH
70778: LD_INT 3
70780: NEG
70781: PUSH
70782: EMPTY
70783: LIST
70784: LIST
70785: PUSH
70786: LD_INT 2
70788: PUSH
70789: LD_INT 1
70791: NEG
70792: PUSH
70793: EMPTY
70794: LIST
70795: LIST
70796: PUSH
70797: LD_INT 3
70799: PUSH
70800: LD_INT 1
70802: PUSH
70803: EMPTY
70804: LIST
70805: LIST
70806: PUSH
70807: LD_INT 1
70809: PUSH
70810: LD_INT 3
70812: PUSH
70813: EMPTY
70814: LIST
70815: LIST
70816: PUSH
70817: LD_INT 1
70819: NEG
70820: PUSH
70821: LD_INT 2
70823: PUSH
70824: EMPTY
70825: LIST
70826: LIST
70827: PUSH
70828: LD_INT 3
70830: NEG
70831: PUSH
70832: LD_INT 2
70834: NEG
70835: PUSH
70836: EMPTY
70837: LIST
70838: LIST
70839: PUSH
70840: EMPTY
70841: LIST
70842: LIST
70843: LIST
70844: LIST
70845: LIST
70846: LIST
70847: LIST
70848: LIST
70849: LIST
70850: LIST
70851: LIST
70852: LIST
70853: LIST
70854: LIST
70855: LIST
70856: LIST
70857: LIST
70858: LIST
70859: LIST
70860: LIST
70861: LIST
70862: LIST
70863: LIST
70864: ST_TO_ADDR
// Factory1 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 1 , - 3 ] , [ 1 , - 2 ] , [ 3 , 2 ] , [ 2 , 3 ] , [ - 2 , 1 ] , [ - 3 , - 1 ] ] ;
70865: LD_ADDR_VAR 0 30
70869: PUSH
70870: LD_INT 0
70872: PUSH
70873: LD_INT 0
70875: PUSH
70876: EMPTY
70877: LIST
70878: LIST
70879: PUSH
70880: LD_INT 0
70882: PUSH
70883: LD_INT 1
70885: NEG
70886: PUSH
70887: EMPTY
70888: LIST
70889: LIST
70890: PUSH
70891: LD_INT 1
70893: PUSH
70894: LD_INT 0
70896: PUSH
70897: EMPTY
70898: LIST
70899: LIST
70900: PUSH
70901: LD_INT 1
70903: PUSH
70904: LD_INT 1
70906: PUSH
70907: EMPTY
70908: LIST
70909: LIST
70910: PUSH
70911: LD_INT 0
70913: PUSH
70914: LD_INT 1
70916: PUSH
70917: EMPTY
70918: LIST
70919: LIST
70920: PUSH
70921: LD_INT 1
70923: NEG
70924: PUSH
70925: LD_INT 0
70927: PUSH
70928: EMPTY
70929: LIST
70930: LIST
70931: PUSH
70932: LD_INT 1
70934: NEG
70935: PUSH
70936: LD_INT 1
70938: NEG
70939: PUSH
70940: EMPTY
70941: LIST
70942: LIST
70943: PUSH
70944: LD_INT 1
70946: NEG
70947: PUSH
70948: LD_INT 2
70950: NEG
70951: PUSH
70952: EMPTY
70953: LIST
70954: LIST
70955: PUSH
70956: LD_INT 0
70958: PUSH
70959: LD_INT 2
70961: NEG
70962: PUSH
70963: EMPTY
70964: LIST
70965: LIST
70966: PUSH
70967: LD_INT 1
70969: PUSH
70970: LD_INT 1
70972: NEG
70973: PUSH
70974: EMPTY
70975: LIST
70976: LIST
70977: PUSH
70978: LD_INT 2
70980: PUSH
70981: LD_INT 0
70983: PUSH
70984: EMPTY
70985: LIST
70986: LIST
70987: PUSH
70988: LD_INT 2
70990: PUSH
70991: LD_INT 1
70993: PUSH
70994: EMPTY
70995: LIST
70996: LIST
70997: PUSH
70998: LD_INT 2
71000: PUSH
71001: LD_INT 2
71003: PUSH
71004: EMPTY
71005: LIST
71006: LIST
71007: PUSH
71008: LD_INT 1
71010: PUSH
71011: LD_INT 2
71013: PUSH
71014: EMPTY
71015: LIST
71016: LIST
71017: PUSH
71018: LD_INT 1
71020: NEG
71021: PUSH
71022: LD_INT 1
71024: PUSH
71025: EMPTY
71026: LIST
71027: LIST
71028: PUSH
71029: LD_INT 2
71031: NEG
71032: PUSH
71033: LD_INT 0
71035: PUSH
71036: EMPTY
71037: LIST
71038: LIST
71039: PUSH
71040: LD_INT 2
71042: NEG
71043: PUSH
71044: LD_INT 1
71046: NEG
71047: PUSH
71048: EMPTY
71049: LIST
71050: LIST
71051: PUSH
71052: LD_INT 1
71054: NEG
71055: PUSH
71056: LD_INT 3
71058: NEG
71059: PUSH
71060: EMPTY
71061: LIST
71062: LIST
71063: PUSH
71064: LD_INT 1
71066: PUSH
71067: LD_INT 2
71069: NEG
71070: PUSH
71071: EMPTY
71072: LIST
71073: LIST
71074: PUSH
71075: LD_INT 3
71077: PUSH
71078: LD_INT 2
71080: PUSH
71081: EMPTY
71082: LIST
71083: LIST
71084: PUSH
71085: LD_INT 2
71087: PUSH
71088: LD_INT 3
71090: PUSH
71091: EMPTY
71092: LIST
71093: LIST
71094: PUSH
71095: LD_INT 2
71097: NEG
71098: PUSH
71099: LD_INT 1
71101: PUSH
71102: EMPTY
71103: LIST
71104: LIST
71105: PUSH
71106: LD_INT 3
71108: NEG
71109: PUSH
71110: LD_INT 1
71112: NEG
71113: PUSH
71114: EMPTY
71115: LIST
71116: LIST
71117: PUSH
71118: EMPTY
71119: LIST
71120: LIST
71121: LIST
71122: LIST
71123: LIST
71124: LIST
71125: LIST
71126: LIST
71127: LIST
71128: LIST
71129: LIST
71130: LIST
71131: LIST
71132: LIST
71133: LIST
71134: LIST
71135: LIST
71136: LIST
71137: LIST
71138: LIST
71139: LIST
71140: LIST
71141: LIST
71142: ST_TO_ADDR
// Factory2 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ - 2 , - 3 ] , [ 2 , - 1 ] , [ 3 , 1 ] , [ 1 , 3 ] , [ - 1 , 2 ] , [ - 3 , - 2 ] ] ;
71143: LD_ADDR_VAR 0 31
71147: PUSH
71148: LD_INT 0
71150: PUSH
71151: LD_INT 0
71153: PUSH
71154: EMPTY
71155: LIST
71156: LIST
71157: PUSH
71158: LD_INT 0
71160: PUSH
71161: LD_INT 1
71163: NEG
71164: PUSH
71165: EMPTY
71166: LIST
71167: LIST
71168: PUSH
71169: LD_INT 1
71171: PUSH
71172: LD_INT 0
71174: PUSH
71175: EMPTY
71176: LIST
71177: LIST
71178: PUSH
71179: LD_INT 1
71181: PUSH
71182: LD_INT 1
71184: PUSH
71185: EMPTY
71186: LIST
71187: LIST
71188: PUSH
71189: LD_INT 0
71191: PUSH
71192: LD_INT 1
71194: PUSH
71195: EMPTY
71196: LIST
71197: LIST
71198: PUSH
71199: LD_INT 1
71201: NEG
71202: PUSH
71203: LD_INT 0
71205: PUSH
71206: EMPTY
71207: LIST
71208: LIST
71209: PUSH
71210: LD_INT 1
71212: NEG
71213: PUSH
71214: LD_INT 1
71216: NEG
71217: PUSH
71218: EMPTY
71219: LIST
71220: LIST
71221: PUSH
71222: LD_INT 1
71224: NEG
71225: PUSH
71226: LD_INT 2
71228: NEG
71229: PUSH
71230: EMPTY
71231: LIST
71232: LIST
71233: PUSH
71234: LD_INT 1
71236: PUSH
71237: LD_INT 1
71239: NEG
71240: PUSH
71241: EMPTY
71242: LIST
71243: LIST
71244: PUSH
71245: LD_INT 2
71247: PUSH
71248: LD_INT 0
71250: PUSH
71251: EMPTY
71252: LIST
71253: LIST
71254: PUSH
71255: LD_INT 2
71257: PUSH
71258: LD_INT 1
71260: PUSH
71261: EMPTY
71262: LIST
71263: LIST
71264: PUSH
71265: LD_INT 2
71267: PUSH
71268: LD_INT 2
71270: PUSH
71271: EMPTY
71272: LIST
71273: LIST
71274: PUSH
71275: LD_INT 1
71277: PUSH
71278: LD_INT 2
71280: PUSH
71281: EMPTY
71282: LIST
71283: LIST
71284: PUSH
71285: LD_INT 0
71287: PUSH
71288: LD_INT 2
71290: PUSH
71291: EMPTY
71292: LIST
71293: LIST
71294: PUSH
71295: LD_INT 1
71297: NEG
71298: PUSH
71299: LD_INT 1
71301: PUSH
71302: EMPTY
71303: LIST
71304: LIST
71305: PUSH
71306: LD_INT 2
71308: NEG
71309: PUSH
71310: LD_INT 1
71312: NEG
71313: PUSH
71314: EMPTY
71315: LIST
71316: LIST
71317: PUSH
71318: LD_INT 2
71320: NEG
71321: PUSH
71322: LD_INT 2
71324: NEG
71325: PUSH
71326: EMPTY
71327: LIST
71328: LIST
71329: PUSH
71330: LD_INT 2
71332: NEG
71333: PUSH
71334: LD_INT 3
71336: NEG
71337: PUSH
71338: EMPTY
71339: LIST
71340: LIST
71341: PUSH
71342: LD_INT 2
71344: PUSH
71345: LD_INT 1
71347: NEG
71348: PUSH
71349: EMPTY
71350: LIST
71351: LIST
71352: PUSH
71353: LD_INT 3
71355: PUSH
71356: LD_INT 1
71358: PUSH
71359: EMPTY
71360: LIST
71361: LIST
71362: PUSH
71363: LD_INT 1
71365: PUSH
71366: LD_INT 3
71368: PUSH
71369: EMPTY
71370: LIST
71371: LIST
71372: PUSH
71373: LD_INT 1
71375: NEG
71376: PUSH
71377: LD_INT 2
71379: PUSH
71380: EMPTY
71381: LIST
71382: LIST
71383: PUSH
71384: LD_INT 3
71386: NEG
71387: PUSH
71388: LD_INT 2
71390: NEG
71391: PUSH
71392: EMPTY
71393: LIST
71394: LIST
71395: PUSH
71396: EMPTY
71397: LIST
71398: LIST
71399: LIST
71400: LIST
71401: LIST
71402: LIST
71403: LIST
71404: LIST
71405: LIST
71406: LIST
71407: LIST
71408: LIST
71409: LIST
71410: LIST
71411: LIST
71412: LIST
71413: LIST
71414: LIST
71415: LIST
71416: LIST
71417: LIST
71418: LIST
71419: LIST
71420: ST_TO_ADDR
// Factory3 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 1 , - 3 ] , [ 1 , - 2 ] , [ 3 , 2 ] , [ 2 , 3 ] , [ - 2 , 1 ] , [ - 3 , - 1 ] ] ;
71421: LD_ADDR_VAR 0 32
71425: PUSH
71426: LD_INT 0
71428: PUSH
71429: LD_INT 0
71431: PUSH
71432: EMPTY
71433: LIST
71434: LIST
71435: PUSH
71436: LD_INT 0
71438: PUSH
71439: LD_INT 1
71441: NEG
71442: PUSH
71443: EMPTY
71444: LIST
71445: LIST
71446: PUSH
71447: LD_INT 1
71449: PUSH
71450: LD_INT 0
71452: PUSH
71453: EMPTY
71454: LIST
71455: LIST
71456: PUSH
71457: LD_INT 1
71459: PUSH
71460: LD_INT 1
71462: PUSH
71463: EMPTY
71464: LIST
71465: LIST
71466: PUSH
71467: LD_INT 0
71469: PUSH
71470: LD_INT 1
71472: PUSH
71473: EMPTY
71474: LIST
71475: LIST
71476: PUSH
71477: LD_INT 1
71479: NEG
71480: PUSH
71481: LD_INT 0
71483: PUSH
71484: EMPTY
71485: LIST
71486: LIST
71487: PUSH
71488: LD_INT 1
71490: NEG
71491: PUSH
71492: LD_INT 1
71494: NEG
71495: PUSH
71496: EMPTY
71497: LIST
71498: LIST
71499: PUSH
71500: LD_INT 1
71502: NEG
71503: PUSH
71504: LD_INT 2
71506: NEG
71507: PUSH
71508: EMPTY
71509: LIST
71510: LIST
71511: PUSH
71512: LD_INT 0
71514: PUSH
71515: LD_INT 2
71517: NEG
71518: PUSH
71519: EMPTY
71520: LIST
71521: LIST
71522: PUSH
71523: LD_INT 1
71525: PUSH
71526: LD_INT 1
71528: NEG
71529: PUSH
71530: EMPTY
71531: LIST
71532: LIST
71533: PUSH
71534: LD_INT 2
71536: PUSH
71537: LD_INT 1
71539: PUSH
71540: EMPTY
71541: LIST
71542: LIST
71543: PUSH
71544: LD_INT 2
71546: PUSH
71547: LD_INT 2
71549: PUSH
71550: EMPTY
71551: LIST
71552: LIST
71553: PUSH
71554: LD_INT 1
71556: PUSH
71557: LD_INT 2
71559: PUSH
71560: EMPTY
71561: LIST
71562: LIST
71563: PUSH
71564: LD_INT 0
71566: PUSH
71567: LD_INT 2
71569: PUSH
71570: EMPTY
71571: LIST
71572: LIST
71573: PUSH
71574: LD_INT 1
71576: NEG
71577: PUSH
71578: LD_INT 1
71580: PUSH
71581: EMPTY
71582: LIST
71583: LIST
71584: PUSH
71585: LD_INT 2
71587: NEG
71588: PUSH
71589: LD_INT 0
71591: PUSH
71592: EMPTY
71593: LIST
71594: LIST
71595: PUSH
71596: LD_INT 2
71598: NEG
71599: PUSH
71600: LD_INT 1
71602: NEG
71603: PUSH
71604: EMPTY
71605: LIST
71606: LIST
71607: PUSH
71608: LD_INT 1
71610: NEG
71611: PUSH
71612: LD_INT 3
71614: NEG
71615: PUSH
71616: EMPTY
71617: LIST
71618: LIST
71619: PUSH
71620: LD_INT 1
71622: PUSH
71623: LD_INT 2
71625: NEG
71626: PUSH
71627: EMPTY
71628: LIST
71629: LIST
71630: PUSH
71631: LD_INT 3
71633: PUSH
71634: LD_INT 2
71636: PUSH
71637: EMPTY
71638: LIST
71639: LIST
71640: PUSH
71641: LD_INT 2
71643: PUSH
71644: LD_INT 3
71646: PUSH
71647: EMPTY
71648: LIST
71649: LIST
71650: PUSH
71651: LD_INT 2
71653: NEG
71654: PUSH
71655: LD_INT 1
71657: PUSH
71658: EMPTY
71659: LIST
71660: LIST
71661: PUSH
71662: LD_INT 3
71664: NEG
71665: PUSH
71666: LD_INT 1
71668: NEG
71669: PUSH
71670: EMPTY
71671: LIST
71672: LIST
71673: PUSH
71674: EMPTY
71675: LIST
71676: LIST
71677: LIST
71678: LIST
71679: LIST
71680: LIST
71681: LIST
71682: LIST
71683: LIST
71684: LIST
71685: LIST
71686: LIST
71687: LIST
71688: LIST
71689: LIST
71690: LIST
71691: LIST
71692: LIST
71693: LIST
71694: LIST
71695: LIST
71696: LIST
71697: LIST
71698: ST_TO_ADDR
// Factory4 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ - 2 , - 3 ] , [ 2 , - 1 ] , [ 3 , 1 ] , [ 1 , 3 ] , [ - 1 , 2 ] , [ - 3 , - 2 ] ] ;
71699: LD_ADDR_VAR 0 33
71703: PUSH
71704: LD_INT 0
71706: PUSH
71707: LD_INT 0
71709: PUSH
71710: EMPTY
71711: LIST
71712: LIST
71713: PUSH
71714: LD_INT 0
71716: PUSH
71717: LD_INT 1
71719: NEG
71720: PUSH
71721: EMPTY
71722: LIST
71723: LIST
71724: PUSH
71725: LD_INT 1
71727: PUSH
71728: LD_INT 0
71730: PUSH
71731: EMPTY
71732: LIST
71733: LIST
71734: PUSH
71735: LD_INT 1
71737: PUSH
71738: LD_INT 1
71740: PUSH
71741: EMPTY
71742: LIST
71743: LIST
71744: PUSH
71745: LD_INT 0
71747: PUSH
71748: LD_INT 1
71750: PUSH
71751: EMPTY
71752: LIST
71753: LIST
71754: PUSH
71755: LD_INT 1
71757: NEG
71758: PUSH
71759: LD_INT 0
71761: PUSH
71762: EMPTY
71763: LIST
71764: LIST
71765: PUSH
71766: LD_INT 1
71768: NEG
71769: PUSH
71770: LD_INT 1
71772: NEG
71773: PUSH
71774: EMPTY
71775: LIST
71776: LIST
71777: PUSH
71778: LD_INT 1
71780: NEG
71781: PUSH
71782: LD_INT 2
71784: NEG
71785: PUSH
71786: EMPTY
71787: LIST
71788: LIST
71789: PUSH
71790: LD_INT 1
71792: PUSH
71793: LD_INT 1
71795: NEG
71796: PUSH
71797: EMPTY
71798: LIST
71799: LIST
71800: PUSH
71801: LD_INT 2
71803: PUSH
71804: LD_INT 0
71806: PUSH
71807: EMPTY
71808: LIST
71809: LIST
71810: PUSH
71811: LD_INT 2
71813: PUSH
71814: LD_INT 1
71816: PUSH
71817: EMPTY
71818: LIST
71819: LIST
71820: PUSH
71821: LD_INT 1
71823: PUSH
71824: LD_INT 2
71826: PUSH
71827: EMPTY
71828: LIST
71829: LIST
71830: PUSH
71831: LD_INT 0
71833: PUSH
71834: LD_INT 2
71836: PUSH
71837: EMPTY
71838: LIST
71839: LIST
71840: PUSH
71841: LD_INT 1
71843: NEG
71844: PUSH
71845: LD_INT 1
71847: PUSH
71848: EMPTY
71849: LIST
71850: LIST
71851: PUSH
71852: LD_INT 2
71854: NEG
71855: PUSH
71856: LD_INT 0
71858: PUSH
71859: EMPTY
71860: LIST
71861: LIST
71862: PUSH
71863: LD_INT 2
71865: NEG
71866: PUSH
71867: LD_INT 1
71869: NEG
71870: PUSH
71871: EMPTY
71872: LIST
71873: LIST
71874: PUSH
71875: LD_INT 2
71877: NEG
71878: PUSH
71879: LD_INT 2
71881: NEG
71882: PUSH
71883: EMPTY
71884: LIST
71885: LIST
71886: PUSH
71887: LD_INT 2
71889: NEG
71890: PUSH
71891: LD_INT 3
71893: NEG
71894: PUSH
71895: EMPTY
71896: LIST
71897: LIST
71898: PUSH
71899: LD_INT 2
71901: PUSH
71902: LD_INT 1
71904: NEG
71905: PUSH
71906: EMPTY
71907: LIST
71908: LIST
71909: PUSH
71910: LD_INT 3
71912: PUSH
71913: LD_INT 1
71915: PUSH
71916: EMPTY
71917: LIST
71918: LIST
71919: PUSH
71920: LD_INT 1
71922: PUSH
71923: LD_INT 3
71925: PUSH
71926: EMPTY
71927: LIST
71928: LIST
71929: PUSH
71930: LD_INT 1
71932: NEG
71933: PUSH
71934: LD_INT 2
71936: PUSH
71937: EMPTY
71938: LIST
71939: LIST
71940: PUSH
71941: LD_INT 3
71943: NEG
71944: PUSH
71945: LD_INT 2
71947: NEG
71948: PUSH
71949: EMPTY
71950: LIST
71951: LIST
71952: PUSH
71953: EMPTY
71954: LIST
71955: LIST
71956: LIST
71957: LIST
71958: LIST
71959: LIST
71960: LIST
71961: LIST
71962: LIST
71963: LIST
71964: LIST
71965: LIST
71966: LIST
71967: LIST
71968: LIST
71969: LIST
71970: LIST
71971: LIST
71972: LIST
71973: LIST
71974: LIST
71975: LIST
71976: LIST
71977: ST_TO_ADDR
// Factory5 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ - 1 , - 3 ] , [ 1 , - 2 ] , [ 3 , 2 ] , [ 2 , 3 ] , [ - 2 , 1 ] , [ - 3 , - 1 ] ] ;
71978: LD_ADDR_VAR 0 34
71982: PUSH
71983: LD_INT 0
71985: PUSH
71986: LD_INT 0
71988: PUSH
71989: EMPTY
71990: LIST
71991: LIST
71992: PUSH
71993: LD_INT 0
71995: PUSH
71996: LD_INT 1
71998: NEG
71999: PUSH
72000: EMPTY
72001: LIST
72002: LIST
72003: PUSH
72004: LD_INT 1
72006: PUSH
72007: LD_INT 0
72009: PUSH
72010: EMPTY
72011: LIST
72012: LIST
72013: PUSH
72014: LD_INT 1
72016: PUSH
72017: LD_INT 1
72019: PUSH
72020: EMPTY
72021: LIST
72022: LIST
72023: PUSH
72024: LD_INT 0
72026: PUSH
72027: LD_INT 1
72029: PUSH
72030: EMPTY
72031: LIST
72032: LIST
72033: PUSH
72034: LD_INT 1
72036: NEG
72037: PUSH
72038: LD_INT 0
72040: PUSH
72041: EMPTY
72042: LIST
72043: LIST
72044: PUSH
72045: LD_INT 1
72047: NEG
72048: PUSH
72049: LD_INT 1
72051: NEG
72052: PUSH
72053: EMPTY
72054: LIST
72055: LIST
72056: PUSH
72057: LD_INT 1
72059: NEG
72060: PUSH
72061: LD_INT 2
72063: NEG
72064: PUSH
72065: EMPTY
72066: LIST
72067: LIST
72068: PUSH
72069: LD_INT 0
72071: PUSH
72072: LD_INT 2
72074: NEG
72075: PUSH
72076: EMPTY
72077: LIST
72078: LIST
72079: PUSH
72080: LD_INT 1
72082: PUSH
72083: LD_INT 1
72085: NEG
72086: PUSH
72087: EMPTY
72088: LIST
72089: LIST
72090: PUSH
72091: LD_INT 2
72093: PUSH
72094: LD_INT 1
72096: PUSH
72097: EMPTY
72098: LIST
72099: LIST
72100: PUSH
72101: LD_INT 2
72103: PUSH
72104: LD_INT 2
72106: PUSH
72107: EMPTY
72108: LIST
72109: LIST
72110: PUSH
72111: LD_INT 1
72113: PUSH
72114: LD_INT 2
72116: PUSH
72117: EMPTY
72118: LIST
72119: LIST
72120: PUSH
72121: LD_INT 1
72123: NEG
72124: PUSH
72125: LD_INT 1
72127: PUSH
72128: EMPTY
72129: LIST
72130: LIST
72131: PUSH
72132: LD_INT 2
72134: NEG
72135: PUSH
72136: LD_INT 0
72138: PUSH
72139: EMPTY
72140: LIST
72141: LIST
72142: PUSH
72143: LD_INT 2
72145: NEG
72146: PUSH
72147: LD_INT 1
72149: NEG
72150: PUSH
72151: EMPTY
72152: LIST
72153: LIST
72154: PUSH
72155: LD_INT 2
72157: NEG
72158: PUSH
72159: LD_INT 2
72161: NEG
72162: PUSH
72163: EMPTY
72164: LIST
72165: LIST
72166: PUSH
72167: LD_INT 1
72169: NEG
72170: PUSH
72171: LD_INT 3
72173: NEG
72174: PUSH
72175: EMPTY
72176: LIST
72177: LIST
72178: PUSH
72179: LD_INT 1
72181: PUSH
72182: LD_INT 2
72184: NEG
72185: PUSH
72186: EMPTY
72187: LIST
72188: LIST
72189: PUSH
72190: LD_INT 3
72192: PUSH
72193: LD_INT 2
72195: PUSH
72196: EMPTY
72197: LIST
72198: LIST
72199: PUSH
72200: LD_INT 2
72202: PUSH
72203: LD_INT 3
72205: PUSH
72206: EMPTY
72207: LIST
72208: LIST
72209: PUSH
72210: LD_INT 2
72212: NEG
72213: PUSH
72214: LD_INT 1
72216: PUSH
72217: EMPTY
72218: LIST
72219: LIST
72220: PUSH
72221: LD_INT 3
72223: NEG
72224: PUSH
72225: LD_INT 1
72227: NEG
72228: PUSH
72229: EMPTY
72230: LIST
72231: LIST
72232: PUSH
72233: EMPTY
72234: LIST
72235: LIST
72236: LIST
72237: LIST
72238: LIST
72239: LIST
72240: LIST
72241: LIST
72242: LIST
72243: LIST
72244: LIST
72245: LIST
72246: LIST
72247: LIST
72248: LIST
72249: LIST
72250: LIST
72251: LIST
72252: LIST
72253: LIST
72254: LIST
72255: LIST
72256: LIST
72257: ST_TO_ADDR
// Ext0 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ 2 , 1 ] , [ - 2 , - 1 ] ] ;
72258: LD_ADDR_VAR 0 35
72262: PUSH
72263: LD_INT 0
72265: PUSH
72266: LD_INT 0
72268: PUSH
72269: EMPTY
72270: LIST
72271: LIST
72272: PUSH
72273: LD_INT 0
72275: PUSH
72276: LD_INT 1
72278: NEG
72279: PUSH
72280: EMPTY
72281: LIST
72282: LIST
72283: PUSH
72284: LD_INT 1
72286: PUSH
72287: LD_INT 0
72289: PUSH
72290: EMPTY
72291: LIST
72292: LIST
72293: PUSH
72294: LD_INT 1
72296: PUSH
72297: LD_INT 1
72299: PUSH
72300: EMPTY
72301: LIST
72302: LIST
72303: PUSH
72304: LD_INT 0
72306: PUSH
72307: LD_INT 1
72309: PUSH
72310: EMPTY
72311: LIST
72312: LIST
72313: PUSH
72314: LD_INT 1
72316: NEG
72317: PUSH
72318: LD_INT 0
72320: PUSH
72321: EMPTY
72322: LIST
72323: LIST
72324: PUSH
72325: LD_INT 1
72327: NEG
72328: PUSH
72329: LD_INT 1
72331: NEG
72332: PUSH
72333: EMPTY
72334: LIST
72335: LIST
72336: PUSH
72337: LD_INT 2
72339: PUSH
72340: LD_INT 1
72342: PUSH
72343: EMPTY
72344: LIST
72345: LIST
72346: PUSH
72347: LD_INT 2
72349: NEG
72350: PUSH
72351: LD_INT 1
72353: NEG
72354: PUSH
72355: EMPTY
72356: LIST
72357: LIST
72358: PUSH
72359: EMPTY
72360: LIST
72361: LIST
72362: LIST
72363: LIST
72364: LIST
72365: LIST
72366: LIST
72367: LIST
72368: LIST
72369: ST_TO_ADDR
// Ext1 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 1 , 2 ] ] ;
72370: LD_ADDR_VAR 0 36
72374: PUSH
72375: LD_INT 0
72377: PUSH
72378: LD_INT 0
72380: PUSH
72381: EMPTY
72382: LIST
72383: LIST
72384: PUSH
72385: LD_INT 0
72387: PUSH
72388: LD_INT 1
72390: NEG
72391: PUSH
72392: EMPTY
72393: LIST
72394: LIST
72395: PUSH
72396: LD_INT 1
72398: PUSH
72399: LD_INT 0
72401: PUSH
72402: EMPTY
72403: LIST
72404: LIST
72405: PUSH
72406: LD_INT 1
72408: PUSH
72409: LD_INT 1
72411: PUSH
72412: EMPTY
72413: LIST
72414: LIST
72415: PUSH
72416: LD_INT 0
72418: PUSH
72419: LD_INT 1
72421: PUSH
72422: EMPTY
72423: LIST
72424: LIST
72425: PUSH
72426: LD_INT 1
72428: NEG
72429: PUSH
72430: LD_INT 0
72432: PUSH
72433: EMPTY
72434: LIST
72435: LIST
72436: PUSH
72437: LD_INT 1
72439: NEG
72440: PUSH
72441: LD_INT 1
72443: NEG
72444: PUSH
72445: EMPTY
72446: LIST
72447: LIST
72448: PUSH
72449: LD_INT 1
72451: NEG
72452: PUSH
72453: LD_INT 2
72455: NEG
72456: PUSH
72457: EMPTY
72458: LIST
72459: LIST
72460: PUSH
72461: LD_INT 1
72463: PUSH
72464: LD_INT 2
72466: PUSH
72467: EMPTY
72468: LIST
72469: LIST
72470: PUSH
72471: EMPTY
72472: LIST
72473: LIST
72474: LIST
72475: LIST
72476: LIST
72477: LIST
72478: LIST
72479: LIST
72480: LIST
72481: ST_TO_ADDR
// Ext2 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ 1 , - 1 ] , [ - 1 , 1 ] ] ;
72482: LD_ADDR_VAR 0 37
72486: PUSH
72487: LD_INT 0
72489: PUSH
72490: LD_INT 0
72492: PUSH
72493: EMPTY
72494: LIST
72495: LIST
72496: PUSH
72497: LD_INT 0
72499: PUSH
72500: LD_INT 1
72502: NEG
72503: PUSH
72504: EMPTY
72505: LIST
72506: LIST
72507: PUSH
72508: LD_INT 1
72510: PUSH
72511: LD_INT 0
72513: PUSH
72514: EMPTY
72515: LIST
72516: LIST
72517: PUSH
72518: LD_INT 1
72520: PUSH
72521: LD_INT 1
72523: PUSH
72524: EMPTY
72525: LIST
72526: LIST
72527: PUSH
72528: LD_INT 0
72530: PUSH
72531: LD_INT 1
72533: PUSH
72534: EMPTY
72535: LIST
72536: LIST
72537: PUSH
72538: LD_INT 1
72540: NEG
72541: PUSH
72542: LD_INT 0
72544: PUSH
72545: EMPTY
72546: LIST
72547: LIST
72548: PUSH
72549: LD_INT 1
72551: NEG
72552: PUSH
72553: LD_INT 1
72555: NEG
72556: PUSH
72557: EMPTY
72558: LIST
72559: LIST
72560: PUSH
72561: LD_INT 1
72563: PUSH
72564: LD_INT 1
72566: NEG
72567: PUSH
72568: EMPTY
72569: LIST
72570: LIST
72571: PUSH
72572: LD_INT 1
72574: NEG
72575: PUSH
72576: LD_INT 1
72578: PUSH
72579: EMPTY
72580: LIST
72581: LIST
72582: PUSH
72583: EMPTY
72584: LIST
72585: LIST
72586: LIST
72587: LIST
72588: LIST
72589: LIST
72590: LIST
72591: LIST
72592: LIST
72593: ST_TO_ADDR
// Ext3 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ 2 , 1 ] , [ - 2 , - 1 ] ] ;
72594: LD_ADDR_VAR 0 38
72598: PUSH
72599: LD_INT 0
72601: PUSH
72602: LD_INT 0
72604: PUSH
72605: EMPTY
72606: LIST
72607: LIST
72608: PUSH
72609: LD_INT 0
72611: PUSH
72612: LD_INT 1
72614: NEG
72615: PUSH
72616: EMPTY
72617: LIST
72618: LIST
72619: PUSH
72620: LD_INT 1
72622: PUSH
72623: LD_INT 0
72625: PUSH
72626: EMPTY
72627: LIST
72628: LIST
72629: PUSH
72630: LD_INT 1
72632: PUSH
72633: LD_INT 1
72635: PUSH
72636: EMPTY
72637: LIST
72638: LIST
72639: PUSH
72640: LD_INT 0
72642: PUSH
72643: LD_INT 1
72645: PUSH
72646: EMPTY
72647: LIST
72648: LIST
72649: PUSH
72650: LD_INT 1
72652: NEG
72653: PUSH
72654: LD_INT 0
72656: PUSH
72657: EMPTY
72658: LIST
72659: LIST
72660: PUSH
72661: LD_INT 1
72663: NEG
72664: PUSH
72665: LD_INT 1
72667: NEG
72668: PUSH
72669: EMPTY
72670: LIST
72671: LIST
72672: PUSH
72673: LD_INT 2
72675: PUSH
72676: LD_INT 1
72678: PUSH
72679: EMPTY
72680: LIST
72681: LIST
72682: PUSH
72683: LD_INT 2
72685: NEG
72686: PUSH
72687: LD_INT 1
72689: NEG
72690: PUSH
72691: EMPTY
72692: LIST
72693: LIST
72694: PUSH
72695: EMPTY
72696: LIST
72697: LIST
72698: LIST
72699: LIST
72700: LIST
72701: LIST
72702: LIST
72703: LIST
72704: LIST
72705: ST_TO_ADDR
// Ext4 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 1 , 2 ] ] ;
72706: LD_ADDR_VAR 0 39
72710: PUSH
72711: LD_INT 0
72713: PUSH
72714: LD_INT 0
72716: PUSH
72717: EMPTY
72718: LIST
72719: LIST
72720: PUSH
72721: LD_INT 0
72723: PUSH
72724: LD_INT 1
72726: NEG
72727: PUSH
72728: EMPTY
72729: LIST
72730: LIST
72731: PUSH
72732: LD_INT 1
72734: PUSH
72735: LD_INT 0
72737: PUSH
72738: EMPTY
72739: LIST
72740: LIST
72741: PUSH
72742: LD_INT 1
72744: PUSH
72745: LD_INT 1
72747: PUSH
72748: EMPTY
72749: LIST
72750: LIST
72751: PUSH
72752: LD_INT 0
72754: PUSH
72755: LD_INT 1
72757: PUSH
72758: EMPTY
72759: LIST
72760: LIST
72761: PUSH
72762: LD_INT 1
72764: NEG
72765: PUSH
72766: LD_INT 0
72768: PUSH
72769: EMPTY
72770: LIST
72771: LIST
72772: PUSH
72773: LD_INT 1
72775: NEG
72776: PUSH
72777: LD_INT 1
72779: NEG
72780: PUSH
72781: EMPTY
72782: LIST
72783: LIST
72784: PUSH
72785: LD_INT 1
72787: NEG
72788: PUSH
72789: LD_INT 2
72791: NEG
72792: PUSH
72793: EMPTY
72794: LIST
72795: LIST
72796: PUSH
72797: LD_INT 1
72799: PUSH
72800: LD_INT 2
72802: PUSH
72803: EMPTY
72804: LIST
72805: LIST
72806: PUSH
72807: EMPTY
72808: LIST
72809: LIST
72810: LIST
72811: LIST
72812: LIST
72813: LIST
72814: LIST
72815: LIST
72816: LIST
72817: ST_TO_ADDR
// Ext5 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ 1 , - 1 ] , [ - 1 , 1 ] ] ;
72818: LD_ADDR_VAR 0 40
72822: PUSH
72823: LD_INT 0
72825: PUSH
72826: LD_INT 0
72828: PUSH
72829: EMPTY
72830: LIST
72831: LIST
72832: PUSH
72833: LD_INT 0
72835: PUSH
72836: LD_INT 1
72838: NEG
72839: PUSH
72840: EMPTY
72841: LIST
72842: LIST
72843: PUSH
72844: LD_INT 1
72846: PUSH
72847: LD_INT 0
72849: PUSH
72850: EMPTY
72851: LIST
72852: LIST
72853: PUSH
72854: LD_INT 1
72856: PUSH
72857: LD_INT 1
72859: PUSH
72860: EMPTY
72861: LIST
72862: LIST
72863: PUSH
72864: LD_INT 0
72866: PUSH
72867: LD_INT 1
72869: PUSH
72870: EMPTY
72871: LIST
72872: LIST
72873: PUSH
72874: LD_INT 1
72876: NEG
72877: PUSH
72878: LD_INT 0
72880: PUSH
72881: EMPTY
72882: LIST
72883: LIST
72884: PUSH
72885: LD_INT 1
72887: NEG
72888: PUSH
72889: LD_INT 1
72891: NEG
72892: PUSH
72893: EMPTY
72894: LIST
72895: LIST
72896: PUSH
72897: LD_INT 1
72899: PUSH
72900: LD_INT 1
72902: NEG
72903: PUSH
72904: EMPTY
72905: LIST
72906: LIST
72907: PUSH
72908: LD_INT 1
72910: NEG
72911: PUSH
72912: LD_INT 1
72914: PUSH
72915: EMPTY
72916: LIST
72917: LIST
72918: PUSH
72919: EMPTY
72920: LIST
72921: LIST
72922: LIST
72923: LIST
72924: LIST
72925: LIST
72926: LIST
72927: LIST
72928: LIST
72929: ST_TO_ADDR
// Lab0 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ - 2 , - 3 ] , [ 2 , - 1 ] , [ 3 , 0 ] , [ 3 , 1 ] , [ 3 , 2 ] , [ 3 , 3 ] , [ 2 , 3 ] , [ - 2 , 1 ] , [ - 3 , 0 ] , [ - 3 , - 1 ] , [ - 3 , - 2 ] , [ - 3 , - 3 ] ] ;
72930: LD_ADDR_VAR 0 41
72934: PUSH
72935: LD_INT 0
72937: PUSH
72938: LD_INT 0
72940: PUSH
72941: EMPTY
72942: LIST
72943: LIST
72944: PUSH
72945: LD_INT 0
72947: PUSH
72948: LD_INT 1
72950: NEG
72951: PUSH
72952: EMPTY
72953: LIST
72954: LIST
72955: PUSH
72956: LD_INT 1
72958: PUSH
72959: LD_INT 0
72961: PUSH
72962: EMPTY
72963: LIST
72964: LIST
72965: PUSH
72966: LD_INT 1
72968: PUSH
72969: LD_INT 1
72971: PUSH
72972: EMPTY
72973: LIST
72974: LIST
72975: PUSH
72976: LD_INT 0
72978: PUSH
72979: LD_INT 1
72981: PUSH
72982: EMPTY
72983: LIST
72984: LIST
72985: PUSH
72986: LD_INT 1
72988: NEG
72989: PUSH
72990: LD_INT 0
72992: PUSH
72993: EMPTY
72994: LIST
72995: LIST
72996: PUSH
72997: LD_INT 1
72999: NEG
73000: PUSH
73001: LD_INT 1
73003: NEG
73004: PUSH
73005: EMPTY
73006: LIST
73007: LIST
73008: PUSH
73009: LD_INT 1
73011: NEG
73012: PUSH
73013: LD_INT 2
73015: NEG
73016: PUSH
73017: EMPTY
73018: LIST
73019: LIST
73020: PUSH
73021: LD_INT 1
73023: PUSH
73024: LD_INT 1
73026: NEG
73027: PUSH
73028: EMPTY
73029: LIST
73030: LIST
73031: PUSH
73032: LD_INT 2
73034: PUSH
73035: LD_INT 0
73037: PUSH
73038: EMPTY
73039: LIST
73040: LIST
73041: PUSH
73042: LD_INT 2
73044: PUSH
73045: LD_INT 1
73047: PUSH
73048: EMPTY
73049: LIST
73050: LIST
73051: PUSH
73052: LD_INT 2
73054: PUSH
73055: LD_INT 2
73057: PUSH
73058: EMPTY
73059: LIST
73060: LIST
73061: PUSH
73062: LD_INT 1
73064: PUSH
73065: LD_INT 2
73067: PUSH
73068: EMPTY
73069: LIST
73070: LIST
73071: PUSH
73072: LD_INT 1
73074: NEG
73075: PUSH
73076: LD_INT 1
73078: PUSH
73079: EMPTY
73080: LIST
73081: LIST
73082: PUSH
73083: LD_INT 2
73085: NEG
73086: PUSH
73087: LD_INT 0
73089: PUSH
73090: EMPTY
73091: LIST
73092: LIST
73093: PUSH
73094: LD_INT 2
73096: NEG
73097: PUSH
73098: LD_INT 1
73100: NEG
73101: PUSH
73102: EMPTY
73103: LIST
73104: LIST
73105: PUSH
73106: LD_INT 2
73108: NEG
73109: PUSH
73110: LD_INT 2
73112: NEG
73113: PUSH
73114: EMPTY
73115: LIST
73116: LIST
73117: PUSH
73118: LD_INT 2
73120: NEG
73121: PUSH
73122: LD_INT 3
73124: NEG
73125: PUSH
73126: EMPTY
73127: LIST
73128: LIST
73129: PUSH
73130: LD_INT 2
73132: PUSH
73133: LD_INT 1
73135: NEG
73136: PUSH
73137: EMPTY
73138: LIST
73139: LIST
73140: PUSH
73141: LD_INT 3
73143: PUSH
73144: LD_INT 0
73146: PUSH
73147: EMPTY
73148: LIST
73149: LIST
73150: PUSH
73151: LD_INT 3
73153: PUSH
73154: LD_INT 1
73156: PUSH
73157: EMPTY
73158: LIST
73159: LIST
73160: PUSH
73161: LD_INT 3
73163: PUSH
73164: LD_INT 2
73166: PUSH
73167: EMPTY
73168: LIST
73169: LIST
73170: PUSH
73171: LD_INT 3
73173: PUSH
73174: LD_INT 3
73176: PUSH
73177: EMPTY
73178: LIST
73179: LIST
73180: PUSH
73181: LD_INT 2
73183: PUSH
73184: LD_INT 3
73186: PUSH
73187: EMPTY
73188: LIST
73189: LIST
73190: PUSH
73191: LD_INT 2
73193: NEG
73194: PUSH
73195: LD_INT 1
73197: PUSH
73198: EMPTY
73199: LIST
73200: LIST
73201: PUSH
73202: LD_INT 3
73204: NEG
73205: PUSH
73206: LD_INT 0
73208: PUSH
73209: EMPTY
73210: LIST
73211: LIST
73212: PUSH
73213: LD_INT 3
73215: NEG
73216: PUSH
73217: LD_INT 1
73219: NEG
73220: PUSH
73221: EMPTY
73222: LIST
73223: LIST
73224: PUSH
73225: LD_INT 3
73227: NEG
73228: PUSH
73229: LD_INT 2
73231: NEG
73232: PUSH
73233: EMPTY
73234: LIST
73235: LIST
73236: PUSH
73237: LD_INT 3
73239: NEG
73240: PUSH
73241: LD_INT 3
73243: NEG
73244: PUSH
73245: EMPTY
73246: LIST
73247: LIST
73248: PUSH
73249: EMPTY
73250: LIST
73251: LIST
73252: LIST
73253: LIST
73254: LIST
73255: LIST
73256: LIST
73257: LIST
73258: LIST
73259: LIST
73260: LIST
73261: LIST
73262: LIST
73263: LIST
73264: LIST
73265: LIST
73266: LIST
73267: LIST
73268: LIST
73269: LIST
73270: LIST
73271: LIST
73272: LIST
73273: LIST
73274: LIST
73275: LIST
73276: LIST
73277: LIST
73278: LIST
73279: ST_TO_ADDR
// Lab1 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ - 2 , - 3 ] , [ - 1 , - 3 ] , [ 0 , - 3 ] , [ 1 , - 2 ] , [ 3 , 2 ] , [ 3 , 3 ] , [ 2 , 3 ] , [ 1 , 3 ] , [ 0 , 3 ] , [ - 1 , 2 ] , [ - 3 , - 2 ] , [ - 3 , - 3 ] ] ;
73280: LD_ADDR_VAR 0 42
73284: PUSH
73285: LD_INT 0
73287: PUSH
73288: LD_INT 0
73290: PUSH
73291: EMPTY
73292: LIST
73293: LIST
73294: PUSH
73295: LD_INT 0
73297: PUSH
73298: LD_INT 1
73300: NEG
73301: PUSH
73302: EMPTY
73303: LIST
73304: LIST
73305: PUSH
73306: LD_INT 1
73308: PUSH
73309: LD_INT 0
73311: PUSH
73312: EMPTY
73313: LIST
73314: LIST
73315: PUSH
73316: LD_INT 1
73318: PUSH
73319: LD_INT 1
73321: PUSH
73322: EMPTY
73323: LIST
73324: LIST
73325: PUSH
73326: LD_INT 0
73328: PUSH
73329: LD_INT 1
73331: PUSH
73332: EMPTY
73333: LIST
73334: LIST
73335: PUSH
73336: LD_INT 1
73338: NEG
73339: PUSH
73340: LD_INT 0
73342: PUSH
73343: EMPTY
73344: LIST
73345: LIST
73346: PUSH
73347: LD_INT 1
73349: NEG
73350: PUSH
73351: LD_INT 1
73353: NEG
73354: PUSH
73355: EMPTY
73356: LIST
73357: LIST
73358: PUSH
73359: LD_INT 1
73361: NEG
73362: PUSH
73363: LD_INT 2
73365: NEG
73366: PUSH
73367: EMPTY
73368: LIST
73369: LIST
73370: PUSH
73371: LD_INT 0
73373: PUSH
73374: LD_INT 2
73376: NEG
73377: PUSH
73378: EMPTY
73379: LIST
73380: LIST
73381: PUSH
73382: LD_INT 1
73384: PUSH
73385: LD_INT 1
73387: NEG
73388: PUSH
73389: EMPTY
73390: LIST
73391: LIST
73392: PUSH
73393: LD_INT 2
73395: PUSH
73396: LD_INT 1
73398: PUSH
73399: EMPTY
73400: LIST
73401: LIST
73402: PUSH
73403: LD_INT 2
73405: PUSH
73406: LD_INT 2
73408: PUSH
73409: EMPTY
73410: LIST
73411: LIST
73412: PUSH
73413: LD_INT 1
73415: PUSH
73416: LD_INT 2
73418: PUSH
73419: EMPTY
73420: LIST
73421: LIST
73422: PUSH
73423: LD_INT 0
73425: PUSH
73426: LD_INT 2
73428: PUSH
73429: EMPTY
73430: LIST
73431: LIST
73432: PUSH
73433: LD_INT 1
73435: NEG
73436: PUSH
73437: LD_INT 1
73439: PUSH
73440: EMPTY
73441: LIST
73442: LIST
73443: PUSH
73444: LD_INT 2
73446: NEG
73447: PUSH
73448: LD_INT 1
73450: NEG
73451: PUSH
73452: EMPTY
73453: LIST
73454: LIST
73455: PUSH
73456: LD_INT 2
73458: NEG
73459: PUSH
73460: LD_INT 2
73462: NEG
73463: PUSH
73464: EMPTY
73465: LIST
73466: LIST
73467: PUSH
73468: LD_INT 2
73470: NEG
73471: PUSH
73472: LD_INT 3
73474: NEG
73475: PUSH
73476: EMPTY
73477: LIST
73478: LIST
73479: PUSH
73480: LD_INT 1
73482: NEG
73483: PUSH
73484: LD_INT 3
73486: NEG
73487: PUSH
73488: EMPTY
73489: LIST
73490: LIST
73491: PUSH
73492: LD_INT 0
73494: PUSH
73495: LD_INT 3
73497: NEG
73498: PUSH
73499: EMPTY
73500: LIST
73501: LIST
73502: PUSH
73503: LD_INT 1
73505: PUSH
73506: LD_INT 2
73508: NEG
73509: PUSH
73510: EMPTY
73511: LIST
73512: LIST
73513: PUSH
73514: LD_INT 3
73516: PUSH
73517: LD_INT 2
73519: PUSH
73520: EMPTY
73521: LIST
73522: LIST
73523: PUSH
73524: LD_INT 3
73526: PUSH
73527: LD_INT 3
73529: PUSH
73530: EMPTY
73531: LIST
73532: LIST
73533: PUSH
73534: LD_INT 2
73536: PUSH
73537: LD_INT 3
73539: PUSH
73540: EMPTY
73541: LIST
73542: LIST
73543: PUSH
73544: LD_INT 1
73546: PUSH
73547: LD_INT 3
73549: PUSH
73550: EMPTY
73551: LIST
73552: LIST
73553: PUSH
73554: LD_INT 0
73556: PUSH
73557: LD_INT 3
73559: PUSH
73560: EMPTY
73561: LIST
73562: LIST
73563: PUSH
73564: LD_INT 1
73566: NEG
73567: PUSH
73568: LD_INT 2
73570: PUSH
73571: EMPTY
73572: LIST
73573: LIST
73574: PUSH
73575: LD_INT 3
73577: NEG
73578: PUSH
73579: LD_INT 2
73581: NEG
73582: PUSH
73583: EMPTY
73584: LIST
73585: LIST
73586: PUSH
73587: LD_INT 3
73589: NEG
73590: PUSH
73591: LD_INT 3
73593: NEG
73594: PUSH
73595: EMPTY
73596: LIST
73597: LIST
73598: PUSH
73599: EMPTY
73600: LIST
73601: LIST
73602: LIST
73603: LIST
73604: LIST
73605: LIST
73606: LIST
73607: LIST
73608: LIST
73609: LIST
73610: LIST
73611: LIST
73612: LIST
73613: LIST
73614: LIST
73615: LIST
73616: LIST
73617: LIST
73618: LIST
73619: LIST
73620: LIST
73621: LIST
73622: LIST
73623: LIST
73624: LIST
73625: LIST
73626: LIST
73627: LIST
73628: LIST
73629: ST_TO_ADDR
// Lab2 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 1 , - 3 ] , [ 0 , - 3 ] , [ 1 , - 2 ] , [ 2 , - 1 ] , [ 3 , 0 ] , [ 3 , 1 ] , [ 1 , 3 ] , [ 0 , 3 ] , [ - 1 , 2 ] , [ - 2 , 1 ] , [ - 3 , 0 ] , [ - 3 , - 1 ] ] ;
73630: LD_ADDR_VAR 0 43
73634: PUSH
73635: LD_INT 0
73637: PUSH
73638: LD_INT 0
73640: PUSH
73641: EMPTY
73642: LIST
73643: LIST
73644: PUSH
73645: LD_INT 0
73647: PUSH
73648: LD_INT 1
73650: NEG
73651: PUSH
73652: EMPTY
73653: LIST
73654: LIST
73655: PUSH
73656: LD_INT 1
73658: PUSH
73659: LD_INT 0
73661: PUSH
73662: EMPTY
73663: LIST
73664: LIST
73665: PUSH
73666: LD_INT 1
73668: PUSH
73669: LD_INT 1
73671: PUSH
73672: EMPTY
73673: LIST
73674: LIST
73675: PUSH
73676: LD_INT 0
73678: PUSH
73679: LD_INT 1
73681: PUSH
73682: EMPTY
73683: LIST
73684: LIST
73685: PUSH
73686: LD_INT 1
73688: NEG
73689: PUSH
73690: LD_INT 0
73692: PUSH
73693: EMPTY
73694: LIST
73695: LIST
73696: PUSH
73697: LD_INT 1
73699: NEG
73700: PUSH
73701: LD_INT 1
73703: NEG
73704: PUSH
73705: EMPTY
73706: LIST
73707: LIST
73708: PUSH
73709: LD_INT 1
73711: NEG
73712: PUSH
73713: LD_INT 2
73715: NEG
73716: PUSH
73717: EMPTY
73718: LIST
73719: LIST
73720: PUSH
73721: LD_INT 0
73723: PUSH
73724: LD_INT 2
73726: NEG
73727: PUSH
73728: EMPTY
73729: LIST
73730: LIST
73731: PUSH
73732: LD_INT 1
73734: PUSH
73735: LD_INT 1
73737: NEG
73738: PUSH
73739: EMPTY
73740: LIST
73741: LIST
73742: PUSH
73743: LD_INT 2
73745: PUSH
73746: LD_INT 0
73748: PUSH
73749: EMPTY
73750: LIST
73751: LIST
73752: PUSH
73753: LD_INT 2
73755: PUSH
73756: LD_INT 1
73758: PUSH
73759: EMPTY
73760: LIST
73761: LIST
73762: PUSH
73763: LD_INT 1
73765: PUSH
73766: LD_INT 2
73768: PUSH
73769: EMPTY
73770: LIST
73771: LIST
73772: PUSH
73773: LD_INT 0
73775: PUSH
73776: LD_INT 2
73778: PUSH
73779: EMPTY
73780: LIST
73781: LIST
73782: PUSH
73783: LD_INT 1
73785: NEG
73786: PUSH
73787: LD_INT 1
73789: PUSH
73790: EMPTY
73791: LIST
73792: LIST
73793: PUSH
73794: LD_INT 2
73796: NEG
73797: PUSH
73798: LD_INT 0
73800: PUSH
73801: EMPTY
73802: LIST
73803: LIST
73804: PUSH
73805: LD_INT 2
73807: NEG
73808: PUSH
73809: LD_INT 1
73811: NEG
73812: PUSH
73813: EMPTY
73814: LIST
73815: LIST
73816: PUSH
73817: LD_INT 1
73819: NEG
73820: PUSH
73821: LD_INT 3
73823: NEG
73824: PUSH
73825: EMPTY
73826: LIST
73827: LIST
73828: PUSH
73829: LD_INT 0
73831: PUSH
73832: LD_INT 3
73834: NEG
73835: PUSH
73836: EMPTY
73837: LIST
73838: LIST
73839: PUSH
73840: LD_INT 1
73842: PUSH
73843: LD_INT 2
73845: NEG
73846: PUSH
73847: EMPTY
73848: LIST
73849: LIST
73850: PUSH
73851: LD_INT 2
73853: PUSH
73854: LD_INT 1
73856: NEG
73857: PUSH
73858: EMPTY
73859: LIST
73860: LIST
73861: PUSH
73862: LD_INT 3
73864: PUSH
73865: LD_INT 0
73867: PUSH
73868: EMPTY
73869: LIST
73870: LIST
73871: PUSH
73872: LD_INT 3
73874: PUSH
73875: LD_INT 1
73877: PUSH
73878: EMPTY
73879: LIST
73880: LIST
73881: PUSH
73882: LD_INT 1
73884: PUSH
73885: LD_INT 3
73887: PUSH
73888: EMPTY
73889: LIST
73890: LIST
73891: PUSH
73892: LD_INT 0
73894: PUSH
73895: LD_INT 3
73897: PUSH
73898: EMPTY
73899: LIST
73900: LIST
73901: PUSH
73902: LD_INT 1
73904: NEG
73905: PUSH
73906: LD_INT 2
73908: PUSH
73909: EMPTY
73910: LIST
73911: LIST
73912: PUSH
73913: LD_INT 2
73915: NEG
73916: PUSH
73917: LD_INT 1
73919: PUSH
73920: EMPTY
73921: LIST
73922: LIST
73923: PUSH
73924: LD_INT 3
73926: NEG
73927: PUSH
73928: LD_INT 0
73930: PUSH
73931: EMPTY
73932: LIST
73933: LIST
73934: PUSH
73935: LD_INT 3
73937: NEG
73938: PUSH
73939: LD_INT 1
73941: NEG
73942: PUSH
73943: EMPTY
73944: LIST
73945: LIST
73946: PUSH
73947: EMPTY
73948: LIST
73949: LIST
73950: LIST
73951: LIST
73952: LIST
73953: LIST
73954: LIST
73955: LIST
73956: LIST
73957: LIST
73958: LIST
73959: LIST
73960: LIST
73961: LIST
73962: LIST
73963: LIST
73964: LIST
73965: LIST
73966: LIST
73967: LIST
73968: LIST
73969: LIST
73970: LIST
73971: LIST
73972: LIST
73973: LIST
73974: LIST
73975: LIST
73976: LIST
73977: ST_TO_ADDR
// Lab3 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ - 2 , - 3 ] , [ 2 , - 1 ] , [ 3 , 0 ] , [ 3 , 1 ] , [ 3 , 2 ] , [ 3 , 3 ] , [ 2 , 3 ] , [ - 2 , 1 ] , [ - 3 , 0 ] , [ - 3 , - 1 ] , [ - 3 , - 2 ] , [ - 3 , - 3 ] ] ;
73978: LD_ADDR_VAR 0 44
73982: PUSH
73983: LD_INT 0
73985: PUSH
73986: LD_INT 0
73988: PUSH
73989: EMPTY
73990: LIST
73991: LIST
73992: PUSH
73993: LD_INT 0
73995: PUSH
73996: LD_INT 1
73998: NEG
73999: PUSH
74000: EMPTY
74001: LIST
74002: LIST
74003: PUSH
74004: LD_INT 1
74006: PUSH
74007: LD_INT 0
74009: PUSH
74010: EMPTY
74011: LIST
74012: LIST
74013: PUSH
74014: LD_INT 1
74016: PUSH
74017: LD_INT 1
74019: PUSH
74020: EMPTY
74021: LIST
74022: LIST
74023: PUSH
74024: LD_INT 0
74026: PUSH
74027: LD_INT 1
74029: PUSH
74030: EMPTY
74031: LIST
74032: LIST
74033: PUSH
74034: LD_INT 1
74036: NEG
74037: PUSH
74038: LD_INT 0
74040: PUSH
74041: EMPTY
74042: LIST
74043: LIST
74044: PUSH
74045: LD_INT 1
74047: NEG
74048: PUSH
74049: LD_INT 1
74051: NEG
74052: PUSH
74053: EMPTY
74054: LIST
74055: LIST
74056: PUSH
74057: LD_INT 1
74059: NEG
74060: PUSH
74061: LD_INT 2
74063: NEG
74064: PUSH
74065: EMPTY
74066: LIST
74067: LIST
74068: PUSH
74069: LD_INT 1
74071: PUSH
74072: LD_INT 1
74074: NEG
74075: PUSH
74076: EMPTY
74077: LIST
74078: LIST
74079: PUSH
74080: LD_INT 2
74082: PUSH
74083: LD_INT 0
74085: PUSH
74086: EMPTY
74087: LIST
74088: LIST
74089: PUSH
74090: LD_INT 2
74092: PUSH
74093: LD_INT 1
74095: PUSH
74096: EMPTY
74097: LIST
74098: LIST
74099: PUSH
74100: LD_INT 2
74102: PUSH
74103: LD_INT 2
74105: PUSH
74106: EMPTY
74107: LIST
74108: LIST
74109: PUSH
74110: LD_INT 1
74112: PUSH
74113: LD_INT 2
74115: PUSH
74116: EMPTY
74117: LIST
74118: LIST
74119: PUSH
74120: LD_INT 1
74122: NEG
74123: PUSH
74124: LD_INT 1
74126: PUSH
74127: EMPTY
74128: LIST
74129: LIST
74130: PUSH
74131: LD_INT 2
74133: NEG
74134: PUSH
74135: LD_INT 0
74137: PUSH
74138: EMPTY
74139: LIST
74140: LIST
74141: PUSH
74142: LD_INT 2
74144: NEG
74145: PUSH
74146: LD_INT 1
74148: NEG
74149: PUSH
74150: EMPTY
74151: LIST
74152: LIST
74153: PUSH
74154: LD_INT 2
74156: NEG
74157: PUSH
74158: LD_INT 2
74160: NEG
74161: PUSH
74162: EMPTY
74163: LIST
74164: LIST
74165: PUSH
74166: LD_INT 2
74168: NEG
74169: PUSH
74170: LD_INT 3
74172: NEG
74173: PUSH
74174: EMPTY
74175: LIST
74176: LIST
74177: PUSH
74178: LD_INT 2
74180: PUSH
74181: LD_INT 1
74183: NEG
74184: PUSH
74185: EMPTY
74186: LIST
74187: LIST
74188: PUSH
74189: LD_INT 3
74191: PUSH
74192: LD_INT 0
74194: PUSH
74195: EMPTY
74196: LIST
74197: LIST
74198: PUSH
74199: LD_INT 3
74201: PUSH
74202: LD_INT 1
74204: PUSH
74205: EMPTY
74206: LIST
74207: LIST
74208: PUSH
74209: LD_INT 3
74211: PUSH
74212: LD_INT 2
74214: PUSH
74215: EMPTY
74216: LIST
74217: LIST
74218: PUSH
74219: LD_INT 3
74221: PUSH
74222: LD_INT 3
74224: PUSH
74225: EMPTY
74226: LIST
74227: LIST
74228: PUSH
74229: LD_INT 2
74231: PUSH
74232: LD_INT 3
74234: PUSH
74235: EMPTY
74236: LIST
74237: LIST
74238: PUSH
74239: LD_INT 2
74241: NEG
74242: PUSH
74243: LD_INT 1
74245: PUSH
74246: EMPTY
74247: LIST
74248: LIST
74249: PUSH
74250: LD_INT 3
74252: NEG
74253: PUSH
74254: LD_INT 0
74256: PUSH
74257: EMPTY
74258: LIST
74259: LIST
74260: PUSH
74261: LD_INT 3
74263: NEG
74264: PUSH
74265: LD_INT 1
74267: NEG
74268: PUSH
74269: EMPTY
74270: LIST
74271: LIST
74272: PUSH
74273: LD_INT 3
74275: NEG
74276: PUSH
74277: LD_INT 2
74279: NEG
74280: PUSH
74281: EMPTY
74282: LIST
74283: LIST
74284: PUSH
74285: LD_INT 3
74287: NEG
74288: PUSH
74289: LD_INT 3
74291: NEG
74292: PUSH
74293: EMPTY
74294: LIST
74295: LIST
74296: PUSH
74297: EMPTY
74298: LIST
74299: LIST
74300: LIST
74301: LIST
74302: LIST
74303: LIST
74304: LIST
74305: LIST
74306: LIST
74307: LIST
74308: LIST
74309: LIST
74310: LIST
74311: LIST
74312: LIST
74313: LIST
74314: LIST
74315: LIST
74316: LIST
74317: LIST
74318: LIST
74319: LIST
74320: LIST
74321: LIST
74322: LIST
74323: LIST
74324: LIST
74325: LIST
74326: LIST
74327: ST_TO_ADDR
// Lab4 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ - 2 , - 3 ] , [ - 1 , - 3 ] , [ 0 , - 3 ] , [ 1 , - 2 ] , [ 3 , 2 ] , [ 3 , 3 ] , [ 2 , 3 ] , [ 1 , 3 ] , [ 0 , 3 ] , [ - 1 , 2 ] , [ - 3 , - 2 ] , [ - 3 , - 3 ] ] ;
74328: LD_ADDR_VAR 0 45
74332: PUSH
74333: LD_INT 0
74335: PUSH
74336: LD_INT 0
74338: PUSH
74339: EMPTY
74340: LIST
74341: LIST
74342: PUSH
74343: LD_INT 0
74345: PUSH
74346: LD_INT 1
74348: NEG
74349: PUSH
74350: EMPTY
74351: LIST
74352: LIST
74353: PUSH
74354: LD_INT 1
74356: PUSH
74357: LD_INT 0
74359: PUSH
74360: EMPTY
74361: LIST
74362: LIST
74363: PUSH
74364: LD_INT 1
74366: PUSH
74367: LD_INT 1
74369: PUSH
74370: EMPTY
74371: LIST
74372: LIST
74373: PUSH
74374: LD_INT 0
74376: PUSH
74377: LD_INT 1
74379: PUSH
74380: EMPTY
74381: LIST
74382: LIST
74383: PUSH
74384: LD_INT 1
74386: NEG
74387: PUSH
74388: LD_INT 0
74390: PUSH
74391: EMPTY
74392: LIST
74393: LIST
74394: PUSH
74395: LD_INT 1
74397: NEG
74398: PUSH
74399: LD_INT 1
74401: NEG
74402: PUSH
74403: EMPTY
74404: LIST
74405: LIST
74406: PUSH
74407: LD_INT 1
74409: NEG
74410: PUSH
74411: LD_INT 2
74413: NEG
74414: PUSH
74415: EMPTY
74416: LIST
74417: LIST
74418: PUSH
74419: LD_INT 0
74421: PUSH
74422: LD_INT 2
74424: NEG
74425: PUSH
74426: EMPTY
74427: LIST
74428: LIST
74429: PUSH
74430: LD_INT 1
74432: PUSH
74433: LD_INT 1
74435: NEG
74436: PUSH
74437: EMPTY
74438: LIST
74439: LIST
74440: PUSH
74441: LD_INT 2
74443: PUSH
74444: LD_INT 1
74446: PUSH
74447: EMPTY
74448: LIST
74449: LIST
74450: PUSH
74451: LD_INT 2
74453: PUSH
74454: LD_INT 2
74456: PUSH
74457: EMPTY
74458: LIST
74459: LIST
74460: PUSH
74461: LD_INT 1
74463: PUSH
74464: LD_INT 2
74466: PUSH
74467: EMPTY
74468: LIST
74469: LIST
74470: PUSH
74471: LD_INT 0
74473: PUSH
74474: LD_INT 2
74476: PUSH
74477: EMPTY
74478: LIST
74479: LIST
74480: PUSH
74481: LD_INT 1
74483: NEG
74484: PUSH
74485: LD_INT 1
74487: PUSH
74488: EMPTY
74489: LIST
74490: LIST
74491: PUSH
74492: LD_INT 2
74494: NEG
74495: PUSH
74496: LD_INT 1
74498: NEG
74499: PUSH
74500: EMPTY
74501: LIST
74502: LIST
74503: PUSH
74504: LD_INT 2
74506: NEG
74507: PUSH
74508: LD_INT 2
74510: NEG
74511: PUSH
74512: EMPTY
74513: LIST
74514: LIST
74515: PUSH
74516: LD_INT 2
74518: NEG
74519: PUSH
74520: LD_INT 3
74522: NEG
74523: PUSH
74524: EMPTY
74525: LIST
74526: LIST
74527: PUSH
74528: LD_INT 1
74530: NEG
74531: PUSH
74532: LD_INT 3
74534: NEG
74535: PUSH
74536: EMPTY
74537: LIST
74538: LIST
74539: PUSH
74540: LD_INT 0
74542: PUSH
74543: LD_INT 3
74545: NEG
74546: PUSH
74547: EMPTY
74548: LIST
74549: LIST
74550: PUSH
74551: LD_INT 1
74553: PUSH
74554: LD_INT 2
74556: NEG
74557: PUSH
74558: EMPTY
74559: LIST
74560: LIST
74561: PUSH
74562: LD_INT 3
74564: PUSH
74565: LD_INT 2
74567: PUSH
74568: EMPTY
74569: LIST
74570: LIST
74571: PUSH
74572: LD_INT 3
74574: PUSH
74575: LD_INT 3
74577: PUSH
74578: EMPTY
74579: LIST
74580: LIST
74581: PUSH
74582: LD_INT 2
74584: PUSH
74585: LD_INT 3
74587: PUSH
74588: EMPTY
74589: LIST
74590: LIST
74591: PUSH
74592: LD_INT 1
74594: PUSH
74595: LD_INT 3
74597: PUSH
74598: EMPTY
74599: LIST
74600: LIST
74601: PUSH
74602: LD_INT 0
74604: PUSH
74605: LD_INT 3
74607: PUSH
74608: EMPTY
74609: LIST
74610: LIST
74611: PUSH
74612: LD_INT 1
74614: NEG
74615: PUSH
74616: LD_INT 2
74618: PUSH
74619: EMPTY
74620: LIST
74621: LIST
74622: PUSH
74623: LD_INT 3
74625: NEG
74626: PUSH
74627: LD_INT 2
74629: NEG
74630: PUSH
74631: EMPTY
74632: LIST
74633: LIST
74634: PUSH
74635: LD_INT 3
74637: NEG
74638: PUSH
74639: LD_INT 3
74641: NEG
74642: PUSH
74643: EMPTY
74644: LIST
74645: LIST
74646: PUSH
74647: EMPTY
74648: LIST
74649: LIST
74650: LIST
74651: LIST
74652: LIST
74653: LIST
74654: LIST
74655: LIST
74656: LIST
74657: LIST
74658: LIST
74659: LIST
74660: LIST
74661: LIST
74662: LIST
74663: LIST
74664: LIST
74665: LIST
74666: LIST
74667: LIST
74668: LIST
74669: LIST
74670: LIST
74671: LIST
74672: LIST
74673: LIST
74674: LIST
74675: LIST
74676: LIST
74677: ST_TO_ADDR
// Lab5 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 1 , - 3 ] , [ 0 , - 3 ] , [ 1 , - 2 ] , [ 2 , - 1 ] , [ 3 , 0 ] , [ 3 , 1 ] , [ 1 , 3 ] , [ 0 , 3 ] , [ - 1 , 2 ] , [ - 2 , 1 ] , [ - 3 , 0 ] , [ - 3 , - 1 ] ] ;
74678: LD_ADDR_VAR 0 46
74682: PUSH
74683: LD_INT 0
74685: PUSH
74686: LD_INT 0
74688: PUSH
74689: EMPTY
74690: LIST
74691: LIST
74692: PUSH
74693: LD_INT 0
74695: PUSH
74696: LD_INT 1
74698: NEG
74699: PUSH
74700: EMPTY
74701: LIST
74702: LIST
74703: PUSH
74704: LD_INT 1
74706: PUSH
74707: LD_INT 0
74709: PUSH
74710: EMPTY
74711: LIST
74712: LIST
74713: PUSH
74714: LD_INT 1
74716: PUSH
74717: LD_INT 1
74719: PUSH
74720: EMPTY
74721: LIST
74722: LIST
74723: PUSH
74724: LD_INT 0
74726: PUSH
74727: LD_INT 1
74729: PUSH
74730: EMPTY
74731: LIST
74732: LIST
74733: PUSH
74734: LD_INT 1
74736: NEG
74737: PUSH
74738: LD_INT 0
74740: PUSH
74741: EMPTY
74742: LIST
74743: LIST
74744: PUSH
74745: LD_INT 1
74747: NEG
74748: PUSH
74749: LD_INT 1
74751: NEG
74752: PUSH
74753: EMPTY
74754: LIST
74755: LIST
74756: PUSH
74757: LD_INT 1
74759: NEG
74760: PUSH
74761: LD_INT 2
74763: NEG
74764: PUSH
74765: EMPTY
74766: LIST
74767: LIST
74768: PUSH
74769: LD_INT 0
74771: PUSH
74772: LD_INT 2
74774: NEG
74775: PUSH
74776: EMPTY
74777: LIST
74778: LIST
74779: PUSH
74780: LD_INT 1
74782: PUSH
74783: LD_INT 1
74785: NEG
74786: PUSH
74787: EMPTY
74788: LIST
74789: LIST
74790: PUSH
74791: LD_INT 2
74793: PUSH
74794: LD_INT 0
74796: PUSH
74797: EMPTY
74798: LIST
74799: LIST
74800: PUSH
74801: LD_INT 2
74803: PUSH
74804: LD_INT 1
74806: PUSH
74807: EMPTY
74808: LIST
74809: LIST
74810: PUSH
74811: LD_INT 1
74813: PUSH
74814: LD_INT 2
74816: PUSH
74817: EMPTY
74818: LIST
74819: LIST
74820: PUSH
74821: LD_INT 0
74823: PUSH
74824: LD_INT 2
74826: PUSH
74827: EMPTY
74828: LIST
74829: LIST
74830: PUSH
74831: LD_INT 1
74833: NEG
74834: PUSH
74835: LD_INT 1
74837: PUSH
74838: EMPTY
74839: LIST
74840: LIST
74841: PUSH
74842: LD_INT 2
74844: NEG
74845: PUSH
74846: LD_INT 0
74848: PUSH
74849: EMPTY
74850: LIST
74851: LIST
74852: PUSH
74853: LD_INT 2
74855: NEG
74856: PUSH
74857: LD_INT 1
74859: NEG
74860: PUSH
74861: EMPTY
74862: LIST
74863: LIST
74864: PUSH
74865: LD_INT 1
74867: NEG
74868: PUSH
74869: LD_INT 3
74871: NEG
74872: PUSH
74873: EMPTY
74874: LIST
74875: LIST
74876: PUSH
74877: LD_INT 0
74879: PUSH
74880: LD_INT 3
74882: NEG
74883: PUSH
74884: EMPTY
74885: LIST
74886: LIST
74887: PUSH
74888: LD_INT 1
74890: PUSH
74891: LD_INT 2
74893: NEG
74894: PUSH
74895: EMPTY
74896: LIST
74897: LIST
74898: PUSH
74899: LD_INT 2
74901: PUSH
74902: LD_INT 1
74904: NEG
74905: PUSH
74906: EMPTY
74907: LIST
74908: LIST
74909: PUSH
74910: LD_INT 3
74912: PUSH
74913: LD_INT 0
74915: PUSH
74916: EMPTY
74917: LIST
74918: LIST
74919: PUSH
74920: LD_INT 3
74922: PUSH
74923: LD_INT 1
74925: PUSH
74926: EMPTY
74927: LIST
74928: LIST
74929: PUSH
74930: LD_INT 1
74932: PUSH
74933: LD_INT 3
74935: PUSH
74936: EMPTY
74937: LIST
74938: LIST
74939: PUSH
74940: LD_INT 0
74942: PUSH
74943: LD_INT 3
74945: PUSH
74946: EMPTY
74947: LIST
74948: LIST
74949: PUSH
74950: LD_INT 1
74952: NEG
74953: PUSH
74954: LD_INT 2
74956: PUSH
74957: EMPTY
74958: LIST
74959: LIST
74960: PUSH
74961: LD_INT 2
74963: NEG
74964: PUSH
74965: LD_INT 1
74967: PUSH
74968: EMPTY
74969: LIST
74970: LIST
74971: PUSH
74972: LD_INT 3
74974: NEG
74975: PUSH
74976: LD_INT 0
74978: PUSH
74979: EMPTY
74980: LIST
74981: LIST
74982: PUSH
74983: LD_INT 3
74985: NEG
74986: PUSH
74987: LD_INT 1
74989: NEG
74990: PUSH
74991: EMPTY
74992: LIST
74993: LIST
74994: PUSH
74995: EMPTY
74996: LIST
74997: LIST
74998: LIST
74999: LIST
75000: LIST
75001: LIST
75002: LIST
75003: LIST
75004: LIST
75005: LIST
75006: LIST
75007: LIST
75008: LIST
75009: LIST
75010: LIST
75011: LIST
75012: LIST
75013: LIST
75014: LIST
75015: LIST
75016: LIST
75017: LIST
75018: LIST
75019: LIST
75020: LIST
75021: LIST
75022: LIST
75023: LIST
75024: LIST
75025: ST_TO_ADDR
// ControlTower0 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
75026: LD_ADDR_VAR 0 47
75030: PUSH
75031: LD_INT 0
75033: PUSH
75034: LD_INT 0
75036: PUSH
75037: EMPTY
75038: LIST
75039: LIST
75040: PUSH
75041: LD_INT 0
75043: PUSH
75044: LD_INT 1
75046: NEG
75047: PUSH
75048: EMPTY
75049: LIST
75050: LIST
75051: PUSH
75052: LD_INT 1
75054: PUSH
75055: LD_INT 0
75057: PUSH
75058: EMPTY
75059: LIST
75060: LIST
75061: PUSH
75062: LD_INT 1
75064: PUSH
75065: LD_INT 1
75067: PUSH
75068: EMPTY
75069: LIST
75070: LIST
75071: PUSH
75072: LD_INT 0
75074: PUSH
75075: LD_INT 1
75077: PUSH
75078: EMPTY
75079: LIST
75080: LIST
75081: PUSH
75082: LD_INT 1
75084: NEG
75085: PUSH
75086: LD_INT 0
75088: PUSH
75089: EMPTY
75090: LIST
75091: LIST
75092: PUSH
75093: LD_INT 1
75095: NEG
75096: PUSH
75097: LD_INT 1
75099: NEG
75100: PUSH
75101: EMPTY
75102: LIST
75103: LIST
75104: PUSH
75105: LD_INT 1
75107: NEG
75108: PUSH
75109: LD_INT 2
75111: NEG
75112: PUSH
75113: EMPTY
75114: LIST
75115: LIST
75116: PUSH
75117: LD_INT 0
75119: PUSH
75120: LD_INT 2
75122: NEG
75123: PUSH
75124: EMPTY
75125: LIST
75126: LIST
75127: PUSH
75128: LD_INT 1
75130: PUSH
75131: LD_INT 1
75133: NEG
75134: PUSH
75135: EMPTY
75136: LIST
75137: LIST
75138: PUSH
75139: LD_INT 2
75141: NEG
75142: PUSH
75143: LD_INT 1
75145: NEG
75146: PUSH
75147: EMPTY
75148: LIST
75149: LIST
75150: PUSH
75151: LD_INT 2
75153: NEG
75154: PUSH
75155: LD_INT 2
75157: NEG
75158: PUSH
75159: EMPTY
75160: LIST
75161: LIST
75162: PUSH
75163: EMPTY
75164: LIST
75165: LIST
75166: LIST
75167: LIST
75168: LIST
75169: LIST
75170: LIST
75171: LIST
75172: LIST
75173: LIST
75174: LIST
75175: LIST
75176: ST_TO_ADDR
// ControlTower1 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] ] ;
75177: LD_ADDR_VAR 0 48
75181: PUSH
75182: LD_INT 0
75184: PUSH
75185: LD_INT 0
75187: PUSH
75188: EMPTY
75189: LIST
75190: LIST
75191: PUSH
75192: LD_INT 0
75194: PUSH
75195: LD_INT 1
75197: NEG
75198: PUSH
75199: EMPTY
75200: LIST
75201: LIST
75202: PUSH
75203: LD_INT 1
75205: PUSH
75206: LD_INT 0
75208: PUSH
75209: EMPTY
75210: LIST
75211: LIST
75212: PUSH
75213: LD_INT 1
75215: PUSH
75216: LD_INT 1
75218: PUSH
75219: EMPTY
75220: LIST
75221: LIST
75222: PUSH
75223: LD_INT 0
75225: PUSH
75226: LD_INT 1
75228: PUSH
75229: EMPTY
75230: LIST
75231: LIST
75232: PUSH
75233: LD_INT 1
75235: NEG
75236: PUSH
75237: LD_INT 0
75239: PUSH
75240: EMPTY
75241: LIST
75242: LIST
75243: PUSH
75244: LD_INT 1
75246: NEG
75247: PUSH
75248: LD_INT 1
75250: NEG
75251: PUSH
75252: EMPTY
75253: LIST
75254: LIST
75255: PUSH
75256: LD_INT 1
75258: NEG
75259: PUSH
75260: LD_INT 2
75262: NEG
75263: PUSH
75264: EMPTY
75265: LIST
75266: LIST
75267: PUSH
75268: LD_INT 0
75270: PUSH
75271: LD_INT 2
75273: NEG
75274: PUSH
75275: EMPTY
75276: LIST
75277: LIST
75278: PUSH
75279: LD_INT 1
75281: PUSH
75282: LD_INT 1
75284: NEG
75285: PUSH
75286: EMPTY
75287: LIST
75288: LIST
75289: PUSH
75290: LD_INT 2
75292: PUSH
75293: LD_INT 0
75295: PUSH
75296: EMPTY
75297: LIST
75298: LIST
75299: PUSH
75300: LD_INT 2
75302: PUSH
75303: LD_INT 1
75305: PUSH
75306: EMPTY
75307: LIST
75308: LIST
75309: PUSH
75310: EMPTY
75311: LIST
75312: LIST
75313: LIST
75314: LIST
75315: LIST
75316: LIST
75317: LIST
75318: LIST
75319: LIST
75320: LIST
75321: LIST
75322: LIST
75323: ST_TO_ADDR
// ControlTower2 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] ] ;
75324: LD_ADDR_VAR 0 49
75328: PUSH
75329: LD_INT 0
75331: PUSH
75332: LD_INT 0
75334: PUSH
75335: EMPTY
75336: LIST
75337: LIST
75338: PUSH
75339: LD_INT 0
75341: PUSH
75342: LD_INT 1
75344: NEG
75345: PUSH
75346: EMPTY
75347: LIST
75348: LIST
75349: PUSH
75350: LD_INT 1
75352: PUSH
75353: LD_INT 0
75355: PUSH
75356: EMPTY
75357: LIST
75358: LIST
75359: PUSH
75360: LD_INT 1
75362: PUSH
75363: LD_INT 1
75365: PUSH
75366: EMPTY
75367: LIST
75368: LIST
75369: PUSH
75370: LD_INT 0
75372: PUSH
75373: LD_INT 1
75375: PUSH
75376: EMPTY
75377: LIST
75378: LIST
75379: PUSH
75380: LD_INT 1
75382: NEG
75383: PUSH
75384: LD_INT 0
75386: PUSH
75387: EMPTY
75388: LIST
75389: LIST
75390: PUSH
75391: LD_INT 1
75393: NEG
75394: PUSH
75395: LD_INT 1
75397: NEG
75398: PUSH
75399: EMPTY
75400: LIST
75401: LIST
75402: PUSH
75403: LD_INT 1
75405: PUSH
75406: LD_INT 1
75408: NEG
75409: PUSH
75410: EMPTY
75411: LIST
75412: LIST
75413: PUSH
75414: LD_INT 2
75416: PUSH
75417: LD_INT 0
75419: PUSH
75420: EMPTY
75421: LIST
75422: LIST
75423: PUSH
75424: LD_INT 2
75426: PUSH
75427: LD_INT 1
75429: PUSH
75430: EMPTY
75431: LIST
75432: LIST
75433: PUSH
75434: LD_INT 2
75436: PUSH
75437: LD_INT 2
75439: PUSH
75440: EMPTY
75441: LIST
75442: LIST
75443: PUSH
75444: LD_INT 1
75446: PUSH
75447: LD_INT 2
75449: PUSH
75450: EMPTY
75451: LIST
75452: LIST
75453: PUSH
75454: EMPTY
75455: LIST
75456: LIST
75457: LIST
75458: LIST
75459: LIST
75460: LIST
75461: LIST
75462: LIST
75463: LIST
75464: LIST
75465: LIST
75466: LIST
75467: ST_TO_ADDR
// ControlTower3 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] ] ;
75468: LD_ADDR_VAR 0 50
75472: PUSH
75473: LD_INT 0
75475: PUSH
75476: LD_INT 0
75478: PUSH
75479: EMPTY
75480: LIST
75481: LIST
75482: PUSH
75483: LD_INT 0
75485: PUSH
75486: LD_INT 1
75488: NEG
75489: PUSH
75490: EMPTY
75491: LIST
75492: LIST
75493: PUSH
75494: LD_INT 1
75496: PUSH
75497: LD_INT 0
75499: PUSH
75500: EMPTY
75501: LIST
75502: LIST
75503: PUSH
75504: LD_INT 1
75506: PUSH
75507: LD_INT 1
75509: PUSH
75510: EMPTY
75511: LIST
75512: LIST
75513: PUSH
75514: LD_INT 0
75516: PUSH
75517: LD_INT 1
75519: PUSH
75520: EMPTY
75521: LIST
75522: LIST
75523: PUSH
75524: LD_INT 1
75526: NEG
75527: PUSH
75528: LD_INT 0
75530: PUSH
75531: EMPTY
75532: LIST
75533: LIST
75534: PUSH
75535: LD_INT 1
75537: NEG
75538: PUSH
75539: LD_INT 1
75541: NEG
75542: PUSH
75543: EMPTY
75544: LIST
75545: LIST
75546: PUSH
75547: LD_INT 2
75549: PUSH
75550: LD_INT 1
75552: PUSH
75553: EMPTY
75554: LIST
75555: LIST
75556: PUSH
75557: LD_INT 2
75559: PUSH
75560: LD_INT 2
75562: PUSH
75563: EMPTY
75564: LIST
75565: LIST
75566: PUSH
75567: LD_INT 1
75569: PUSH
75570: LD_INT 2
75572: PUSH
75573: EMPTY
75574: LIST
75575: LIST
75576: PUSH
75577: LD_INT 0
75579: PUSH
75580: LD_INT 2
75582: PUSH
75583: EMPTY
75584: LIST
75585: LIST
75586: PUSH
75587: LD_INT 1
75589: NEG
75590: PUSH
75591: LD_INT 1
75593: PUSH
75594: EMPTY
75595: LIST
75596: LIST
75597: PUSH
75598: EMPTY
75599: LIST
75600: LIST
75601: LIST
75602: LIST
75603: LIST
75604: LIST
75605: LIST
75606: LIST
75607: LIST
75608: LIST
75609: LIST
75610: LIST
75611: ST_TO_ADDR
// ControlTower4 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] ] ;
75612: LD_ADDR_VAR 0 51
75616: PUSH
75617: LD_INT 0
75619: PUSH
75620: LD_INT 0
75622: PUSH
75623: EMPTY
75624: LIST
75625: LIST
75626: PUSH
75627: LD_INT 0
75629: PUSH
75630: LD_INT 1
75632: NEG
75633: PUSH
75634: EMPTY
75635: LIST
75636: LIST
75637: PUSH
75638: LD_INT 1
75640: PUSH
75641: LD_INT 0
75643: PUSH
75644: EMPTY
75645: LIST
75646: LIST
75647: PUSH
75648: LD_INT 1
75650: PUSH
75651: LD_INT 1
75653: PUSH
75654: EMPTY
75655: LIST
75656: LIST
75657: PUSH
75658: LD_INT 0
75660: PUSH
75661: LD_INT 1
75663: PUSH
75664: EMPTY
75665: LIST
75666: LIST
75667: PUSH
75668: LD_INT 1
75670: NEG
75671: PUSH
75672: LD_INT 0
75674: PUSH
75675: EMPTY
75676: LIST
75677: LIST
75678: PUSH
75679: LD_INT 1
75681: NEG
75682: PUSH
75683: LD_INT 1
75685: NEG
75686: PUSH
75687: EMPTY
75688: LIST
75689: LIST
75690: PUSH
75691: LD_INT 1
75693: PUSH
75694: LD_INT 2
75696: PUSH
75697: EMPTY
75698: LIST
75699: LIST
75700: PUSH
75701: LD_INT 0
75703: PUSH
75704: LD_INT 2
75706: PUSH
75707: EMPTY
75708: LIST
75709: LIST
75710: PUSH
75711: LD_INT 1
75713: NEG
75714: PUSH
75715: LD_INT 1
75717: PUSH
75718: EMPTY
75719: LIST
75720: LIST
75721: PUSH
75722: LD_INT 2
75724: NEG
75725: PUSH
75726: LD_INT 0
75728: PUSH
75729: EMPTY
75730: LIST
75731: LIST
75732: PUSH
75733: LD_INT 2
75735: NEG
75736: PUSH
75737: LD_INT 1
75739: NEG
75740: PUSH
75741: EMPTY
75742: LIST
75743: LIST
75744: PUSH
75745: EMPTY
75746: LIST
75747: LIST
75748: LIST
75749: LIST
75750: LIST
75751: LIST
75752: LIST
75753: LIST
75754: LIST
75755: LIST
75756: LIST
75757: LIST
75758: ST_TO_ADDR
// ControlTower5 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
75759: LD_ADDR_VAR 0 52
75763: PUSH
75764: LD_INT 0
75766: PUSH
75767: LD_INT 0
75769: PUSH
75770: EMPTY
75771: LIST
75772: LIST
75773: PUSH
75774: LD_INT 0
75776: PUSH
75777: LD_INT 1
75779: NEG
75780: PUSH
75781: EMPTY
75782: LIST
75783: LIST
75784: PUSH
75785: LD_INT 1
75787: PUSH
75788: LD_INT 0
75790: PUSH
75791: EMPTY
75792: LIST
75793: LIST
75794: PUSH
75795: LD_INT 1
75797: PUSH
75798: LD_INT 1
75800: PUSH
75801: EMPTY
75802: LIST
75803: LIST
75804: PUSH
75805: LD_INT 0
75807: PUSH
75808: LD_INT 1
75810: PUSH
75811: EMPTY
75812: LIST
75813: LIST
75814: PUSH
75815: LD_INT 1
75817: NEG
75818: PUSH
75819: LD_INT 0
75821: PUSH
75822: EMPTY
75823: LIST
75824: LIST
75825: PUSH
75826: LD_INT 1
75828: NEG
75829: PUSH
75830: LD_INT 1
75832: NEG
75833: PUSH
75834: EMPTY
75835: LIST
75836: LIST
75837: PUSH
75838: LD_INT 1
75840: NEG
75841: PUSH
75842: LD_INT 2
75844: NEG
75845: PUSH
75846: EMPTY
75847: LIST
75848: LIST
75849: PUSH
75850: LD_INT 1
75852: NEG
75853: PUSH
75854: LD_INT 1
75856: PUSH
75857: EMPTY
75858: LIST
75859: LIST
75860: PUSH
75861: LD_INT 2
75863: NEG
75864: PUSH
75865: LD_INT 0
75867: PUSH
75868: EMPTY
75869: LIST
75870: LIST
75871: PUSH
75872: LD_INT 2
75874: NEG
75875: PUSH
75876: LD_INT 1
75878: NEG
75879: PUSH
75880: EMPTY
75881: LIST
75882: LIST
75883: PUSH
75884: LD_INT 2
75886: NEG
75887: PUSH
75888: LD_INT 2
75890: NEG
75891: PUSH
75892: EMPTY
75893: LIST
75894: LIST
75895: PUSH
75896: EMPTY
75897: LIST
75898: LIST
75899: LIST
75900: LIST
75901: LIST
75902: LIST
75903: LIST
75904: LIST
75905: LIST
75906: LIST
75907: LIST
75908: LIST
75909: ST_TO_ADDR
// Barracks0 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
75910: LD_ADDR_VAR 0 53
75914: PUSH
75915: LD_INT 0
75917: PUSH
75918: LD_INT 0
75920: PUSH
75921: EMPTY
75922: LIST
75923: LIST
75924: PUSH
75925: LD_INT 0
75927: PUSH
75928: LD_INT 1
75930: NEG
75931: PUSH
75932: EMPTY
75933: LIST
75934: LIST
75935: PUSH
75936: LD_INT 1
75938: PUSH
75939: LD_INT 0
75941: PUSH
75942: EMPTY
75943: LIST
75944: LIST
75945: PUSH
75946: LD_INT 1
75948: PUSH
75949: LD_INT 1
75951: PUSH
75952: EMPTY
75953: LIST
75954: LIST
75955: PUSH
75956: LD_INT 0
75958: PUSH
75959: LD_INT 1
75961: PUSH
75962: EMPTY
75963: LIST
75964: LIST
75965: PUSH
75966: LD_INT 1
75968: NEG
75969: PUSH
75970: LD_INT 0
75972: PUSH
75973: EMPTY
75974: LIST
75975: LIST
75976: PUSH
75977: LD_INT 1
75979: NEG
75980: PUSH
75981: LD_INT 1
75983: NEG
75984: PUSH
75985: EMPTY
75986: LIST
75987: LIST
75988: PUSH
75989: LD_INT 1
75991: NEG
75992: PUSH
75993: LD_INT 2
75995: NEG
75996: PUSH
75997: EMPTY
75998: LIST
75999: LIST
76000: PUSH
76001: LD_INT 0
76003: PUSH
76004: LD_INT 2
76006: NEG
76007: PUSH
76008: EMPTY
76009: LIST
76010: LIST
76011: PUSH
76012: LD_INT 1
76014: PUSH
76015: LD_INT 1
76017: NEG
76018: PUSH
76019: EMPTY
76020: LIST
76021: LIST
76022: PUSH
76023: LD_INT 2
76025: PUSH
76026: LD_INT 0
76028: PUSH
76029: EMPTY
76030: LIST
76031: LIST
76032: PUSH
76033: LD_INT 2
76035: PUSH
76036: LD_INT 1
76038: PUSH
76039: EMPTY
76040: LIST
76041: LIST
76042: PUSH
76043: LD_INT 2
76045: PUSH
76046: LD_INT 2
76048: PUSH
76049: EMPTY
76050: LIST
76051: LIST
76052: PUSH
76053: LD_INT 1
76055: PUSH
76056: LD_INT 2
76058: PUSH
76059: EMPTY
76060: LIST
76061: LIST
76062: PUSH
76063: LD_INT 0
76065: PUSH
76066: LD_INT 2
76068: PUSH
76069: EMPTY
76070: LIST
76071: LIST
76072: PUSH
76073: LD_INT 1
76075: NEG
76076: PUSH
76077: LD_INT 1
76079: PUSH
76080: EMPTY
76081: LIST
76082: LIST
76083: PUSH
76084: LD_INT 2
76086: NEG
76087: PUSH
76088: LD_INT 0
76090: PUSH
76091: EMPTY
76092: LIST
76093: LIST
76094: PUSH
76095: LD_INT 2
76097: NEG
76098: PUSH
76099: LD_INT 1
76101: NEG
76102: PUSH
76103: EMPTY
76104: LIST
76105: LIST
76106: PUSH
76107: LD_INT 2
76109: NEG
76110: PUSH
76111: LD_INT 2
76113: NEG
76114: PUSH
76115: EMPTY
76116: LIST
76117: LIST
76118: PUSH
76119: EMPTY
76120: LIST
76121: LIST
76122: LIST
76123: LIST
76124: LIST
76125: LIST
76126: LIST
76127: LIST
76128: LIST
76129: LIST
76130: LIST
76131: LIST
76132: LIST
76133: LIST
76134: LIST
76135: LIST
76136: LIST
76137: LIST
76138: LIST
76139: ST_TO_ADDR
// Barracks1 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
76140: LD_ADDR_VAR 0 54
76144: PUSH
76145: LD_INT 0
76147: PUSH
76148: LD_INT 0
76150: PUSH
76151: EMPTY
76152: LIST
76153: LIST
76154: PUSH
76155: LD_INT 0
76157: PUSH
76158: LD_INT 1
76160: NEG
76161: PUSH
76162: EMPTY
76163: LIST
76164: LIST
76165: PUSH
76166: LD_INT 1
76168: PUSH
76169: LD_INT 0
76171: PUSH
76172: EMPTY
76173: LIST
76174: LIST
76175: PUSH
76176: LD_INT 1
76178: PUSH
76179: LD_INT 1
76181: PUSH
76182: EMPTY
76183: LIST
76184: LIST
76185: PUSH
76186: LD_INT 0
76188: PUSH
76189: LD_INT 1
76191: PUSH
76192: EMPTY
76193: LIST
76194: LIST
76195: PUSH
76196: LD_INT 1
76198: NEG
76199: PUSH
76200: LD_INT 0
76202: PUSH
76203: EMPTY
76204: LIST
76205: LIST
76206: PUSH
76207: LD_INT 1
76209: NEG
76210: PUSH
76211: LD_INT 1
76213: NEG
76214: PUSH
76215: EMPTY
76216: LIST
76217: LIST
76218: PUSH
76219: LD_INT 1
76221: NEG
76222: PUSH
76223: LD_INT 2
76225: NEG
76226: PUSH
76227: EMPTY
76228: LIST
76229: LIST
76230: PUSH
76231: LD_INT 0
76233: PUSH
76234: LD_INT 2
76236: NEG
76237: PUSH
76238: EMPTY
76239: LIST
76240: LIST
76241: PUSH
76242: LD_INT 1
76244: PUSH
76245: LD_INT 1
76247: NEG
76248: PUSH
76249: EMPTY
76250: LIST
76251: LIST
76252: PUSH
76253: LD_INT 2
76255: PUSH
76256: LD_INT 0
76258: PUSH
76259: EMPTY
76260: LIST
76261: LIST
76262: PUSH
76263: LD_INT 2
76265: PUSH
76266: LD_INT 1
76268: PUSH
76269: EMPTY
76270: LIST
76271: LIST
76272: PUSH
76273: LD_INT 2
76275: PUSH
76276: LD_INT 2
76278: PUSH
76279: EMPTY
76280: LIST
76281: LIST
76282: PUSH
76283: LD_INT 1
76285: PUSH
76286: LD_INT 2
76288: PUSH
76289: EMPTY
76290: LIST
76291: LIST
76292: PUSH
76293: LD_INT 0
76295: PUSH
76296: LD_INT 2
76298: PUSH
76299: EMPTY
76300: LIST
76301: LIST
76302: PUSH
76303: LD_INT 1
76305: NEG
76306: PUSH
76307: LD_INT 1
76309: PUSH
76310: EMPTY
76311: LIST
76312: LIST
76313: PUSH
76314: LD_INT 2
76316: NEG
76317: PUSH
76318: LD_INT 0
76320: PUSH
76321: EMPTY
76322: LIST
76323: LIST
76324: PUSH
76325: LD_INT 2
76327: NEG
76328: PUSH
76329: LD_INT 1
76331: NEG
76332: PUSH
76333: EMPTY
76334: LIST
76335: LIST
76336: PUSH
76337: LD_INT 2
76339: NEG
76340: PUSH
76341: LD_INT 2
76343: NEG
76344: PUSH
76345: EMPTY
76346: LIST
76347: LIST
76348: PUSH
76349: EMPTY
76350: LIST
76351: LIST
76352: LIST
76353: LIST
76354: LIST
76355: LIST
76356: LIST
76357: LIST
76358: LIST
76359: LIST
76360: LIST
76361: LIST
76362: LIST
76363: LIST
76364: LIST
76365: LIST
76366: LIST
76367: LIST
76368: LIST
76369: ST_TO_ADDR
// Barracks2 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
76370: LD_ADDR_VAR 0 55
76374: PUSH
76375: LD_INT 0
76377: PUSH
76378: LD_INT 0
76380: PUSH
76381: EMPTY
76382: LIST
76383: LIST
76384: PUSH
76385: LD_INT 0
76387: PUSH
76388: LD_INT 1
76390: NEG
76391: PUSH
76392: EMPTY
76393: LIST
76394: LIST
76395: PUSH
76396: LD_INT 1
76398: PUSH
76399: LD_INT 0
76401: PUSH
76402: EMPTY
76403: LIST
76404: LIST
76405: PUSH
76406: LD_INT 1
76408: PUSH
76409: LD_INT 1
76411: PUSH
76412: EMPTY
76413: LIST
76414: LIST
76415: PUSH
76416: LD_INT 0
76418: PUSH
76419: LD_INT 1
76421: PUSH
76422: EMPTY
76423: LIST
76424: LIST
76425: PUSH
76426: LD_INT 1
76428: NEG
76429: PUSH
76430: LD_INT 0
76432: PUSH
76433: EMPTY
76434: LIST
76435: LIST
76436: PUSH
76437: LD_INT 1
76439: NEG
76440: PUSH
76441: LD_INT 1
76443: NEG
76444: PUSH
76445: EMPTY
76446: LIST
76447: LIST
76448: PUSH
76449: LD_INT 1
76451: NEG
76452: PUSH
76453: LD_INT 2
76455: NEG
76456: PUSH
76457: EMPTY
76458: LIST
76459: LIST
76460: PUSH
76461: LD_INT 0
76463: PUSH
76464: LD_INT 2
76466: NEG
76467: PUSH
76468: EMPTY
76469: LIST
76470: LIST
76471: PUSH
76472: LD_INT 1
76474: PUSH
76475: LD_INT 1
76477: NEG
76478: PUSH
76479: EMPTY
76480: LIST
76481: LIST
76482: PUSH
76483: LD_INT 2
76485: PUSH
76486: LD_INT 0
76488: PUSH
76489: EMPTY
76490: LIST
76491: LIST
76492: PUSH
76493: LD_INT 2
76495: PUSH
76496: LD_INT 1
76498: PUSH
76499: EMPTY
76500: LIST
76501: LIST
76502: PUSH
76503: LD_INT 2
76505: PUSH
76506: LD_INT 2
76508: PUSH
76509: EMPTY
76510: LIST
76511: LIST
76512: PUSH
76513: LD_INT 1
76515: PUSH
76516: LD_INT 2
76518: PUSH
76519: EMPTY
76520: LIST
76521: LIST
76522: PUSH
76523: LD_INT 0
76525: PUSH
76526: LD_INT 2
76528: PUSH
76529: EMPTY
76530: LIST
76531: LIST
76532: PUSH
76533: LD_INT 1
76535: NEG
76536: PUSH
76537: LD_INT 1
76539: PUSH
76540: EMPTY
76541: LIST
76542: LIST
76543: PUSH
76544: LD_INT 2
76546: NEG
76547: PUSH
76548: LD_INT 0
76550: PUSH
76551: EMPTY
76552: LIST
76553: LIST
76554: PUSH
76555: LD_INT 2
76557: NEG
76558: PUSH
76559: LD_INT 1
76561: NEG
76562: PUSH
76563: EMPTY
76564: LIST
76565: LIST
76566: PUSH
76567: LD_INT 2
76569: NEG
76570: PUSH
76571: LD_INT 2
76573: NEG
76574: PUSH
76575: EMPTY
76576: LIST
76577: LIST
76578: PUSH
76579: EMPTY
76580: LIST
76581: LIST
76582: LIST
76583: LIST
76584: LIST
76585: LIST
76586: LIST
76587: LIST
76588: LIST
76589: LIST
76590: LIST
76591: LIST
76592: LIST
76593: LIST
76594: LIST
76595: LIST
76596: LIST
76597: LIST
76598: LIST
76599: ST_TO_ADDR
// Barracks3 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
76600: LD_ADDR_VAR 0 56
76604: PUSH
76605: LD_INT 0
76607: PUSH
76608: LD_INT 0
76610: PUSH
76611: EMPTY
76612: LIST
76613: LIST
76614: PUSH
76615: LD_INT 0
76617: PUSH
76618: LD_INT 1
76620: NEG
76621: PUSH
76622: EMPTY
76623: LIST
76624: LIST
76625: PUSH
76626: LD_INT 1
76628: PUSH
76629: LD_INT 0
76631: PUSH
76632: EMPTY
76633: LIST
76634: LIST
76635: PUSH
76636: LD_INT 1
76638: PUSH
76639: LD_INT 1
76641: PUSH
76642: EMPTY
76643: LIST
76644: LIST
76645: PUSH
76646: LD_INT 0
76648: PUSH
76649: LD_INT 1
76651: PUSH
76652: EMPTY
76653: LIST
76654: LIST
76655: PUSH
76656: LD_INT 1
76658: NEG
76659: PUSH
76660: LD_INT 0
76662: PUSH
76663: EMPTY
76664: LIST
76665: LIST
76666: PUSH
76667: LD_INT 1
76669: NEG
76670: PUSH
76671: LD_INT 1
76673: NEG
76674: PUSH
76675: EMPTY
76676: LIST
76677: LIST
76678: PUSH
76679: LD_INT 1
76681: NEG
76682: PUSH
76683: LD_INT 2
76685: NEG
76686: PUSH
76687: EMPTY
76688: LIST
76689: LIST
76690: PUSH
76691: LD_INT 0
76693: PUSH
76694: LD_INT 2
76696: NEG
76697: PUSH
76698: EMPTY
76699: LIST
76700: LIST
76701: PUSH
76702: LD_INT 1
76704: PUSH
76705: LD_INT 1
76707: NEG
76708: PUSH
76709: EMPTY
76710: LIST
76711: LIST
76712: PUSH
76713: LD_INT 2
76715: PUSH
76716: LD_INT 0
76718: PUSH
76719: EMPTY
76720: LIST
76721: LIST
76722: PUSH
76723: LD_INT 2
76725: PUSH
76726: LD_INT 1
76728: PUSH
76729: EMPTY
76730: LIST
76731: LIST
76732: PUSH
76733: LD_INT 2
76735: PUSH
76736: LD_INT 2
76738: PUSH
76739: EMPTY
76740: LIST
76741: LIST
76742: PUSH
76743: LD_INT 1
76745: PUSH
76746: LD_INT 2
76748: PUSH
76749: EMPTY
76750: LIST
76751: LIST
76752: PUSH
76753: LD_INT 0
76755: PUSH
76756: LD_INT 2
76758: PUSH
76759: EMPTY
76760: LIST
76761: LIST
76762: PUSH
76763: LD_INT 1
76765: NEG
76766: PUSH
76767: LD_INT 1
76769: PUSH
76770: EMPTY
76771: LIST
76772: LIST
76773: PUSH
76774: LD_INT 2
76776: NEG
76777: PUSH
76778: LD_INT 0
76780: PUSH
76781: EMPTY
76782: LIST
76783: LIST
76784: PUSH
76785: LD_INT 2
76787: NEG
76788: PUSH
76789: LD_INT 1
76791: NEG
76792: PUSH
76793: EMPTY
76794: LIST
76795: LIST
76796: PUSH
76797: LD_INT 2
76799: NEG
76800: PUSH
76801: LD_INT 2
76803: NEG
76804: PUSH
76805: EMPTY
76806: LIST
76807: LIST
76808: PUSH
76809: EMPTY
76810: LIST
76811: LIST
76812: LIST
76813: LIST
76814: LIST
76815: LIST
76816: LIST
76817: LIST
76818: LIST
76819: LIST
76820: LIST
76821: LIST
76822: LIST
76823: LIST
76824: LIST
76825: LIST
76826: LIST
76827: LIST
76828: LIST
76829: ST_TO_ADDR
// Barracks4 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
76830: LD_ADDR_VAR 0 57
76834: PUSH
76835: LD_INT 0
76837: PUSH
76838: LD_INT 0
76840: PUSH
76841: EMPTY
76842: LIST
76843: LIST
76844: PUSH
76845: LD_INT 0
76847: PUSH
76848: LD_INT 1
76850: NEG
76851: PUSH
76852: EMPTY
76853: LIST
76854: LIST
76855: PUSH
76856: LD_INT 1
76858: PUSH
76859: LD_INT 0
76861: PUSH
76862: EMPTY
76863: LIST
76864: LIST
76865: PUSH
76866: LD_INT 1
76868: PUSH
76869: LD_INT 1
76871: PUSH
76872: EMPTY
76873: LIST
76874: LIST
76875: PUSH
76876: LD_INT 0
76878: PUSH
76879: LD_INT 1
76881: PUSH
76882: EMPTY
76883: LIST
76884: LIST
76885: PUSH
76886: LD_INT 1
76888: NEG
76889: PUSH
76890: LD_INT 0
76892: PUSH
76893: EMPTY
76894: LIST
76895: LIST
76896: PUSH
76897: LD_INT 1
76899: NEG
76900: PUSH
76901: LD_INT 1
76903: NEG
76904: PUSH
76905: EMPTY
76906: LIST
76907: LIST
76908: PUSH
76909: LD_INT 1
76911: NEG
76912: PUSH
76913: LD_INT 2
76915: NEG
76916: PUSH
76917: EMPTY
76918: LIST
76919: LIST
76920: PUSH
76921: LD_INT 0
76923: PUSH
76924: LD_INT 2
76926: NEG
76927: PUSH
76928: EMPTY
76929: LIST
76930: LIST
76931: PUSH
76932: LD_INT 1
76934: PUSH
76935: LD_INT 1
76937: NEG
76938: PUSH
76939: EMPTY
76940: LIST
76941: LIST
76942: PUSH
76943: LD_INT 2
76945: PUSH
76946: LD_INT 0
76948: PUSH
76949: EMPTY
76950: LIST
76951: LIST
76952: PUSH
76953: LD_INT 2
76955: PUSH
76956: LD_INT 1
76958: PUSH
76959: EMPTY
76960: LIST
76961: LIST
76962: PUSH
76963: LD_INT 2
76965: PUSH
76966: LD_INT 2
76968: PUSH
76969: EMPTY
76970: LIST
76971: LIST
76972: PUSH
76973: LD_INT 1
76975: PUSH
76976: LD_INT 2
76978: PUSH
76979: EMPTY
76980: LIST
76981: LIST
76982: PUSH
76983: LD_INT 0
76985: PUSH
76986: LD_INT 2
76988: PUSH
76989: EMPTY
76990: LIST
76991: LIST
76992: PUSH
76993: LD_INT 1
76995: NEG
76996: PUSH
76997: LD_INT 1
76999: PUSH
77000: EMPTY
77001: LIST
77002: LIST
77003: PUSH
77004: LD_INT 2
77006: NEG
77007: PUSH
77008: LD_INT 0
77010: PUSH
77011: EMPTY
77012: LIST
77013: LIST
77014: PUSH
77015: LD_INT 2
77017: NEG
77018: PUSH
77019: LD_INT 1
77021: NEG
77022: PUSH
77023: EMPTY
77024: LIST
77025: LIST
77026: PUSH
77027: LD_INT 2
77029: NEG
77030: PUSH
77031: LD_INT 2
77033: NEG
77034: PUSH
77035: EMPTY
77036: LIST
77037: LIST
77038: PUSH
77039: EMPTY
77040: LIST
77041: LIST
77042: LIST
77043: LIST
77044: LIST
77045: LIST
77046: LIST
77047: LIST
77048: LIST
77049: LIST
77050: LIST
77051: LIST
77052: LIST
77053: LIST
77054: LIST
77055: LIST
77056: LIST
77057: LIST
77058: LIST
77059: ST_TO_ADDR
// Barracks5 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
77060: LD_ADDR_VAR 0 58
77064: PUSH
77065: LD_INT 0
77067: PUSH
77068: LD_INT 0
77070: PUSH
77071: EMPTY
77072: LIST
77073: LIST
77074: PUSH
77075: LD_INT 0
77077: PUSH
77078: LD_INT 1
77080: NEG
77081: PUSH
77082: EMPTY
77083: LIST
77084: LIST
77085: PUSH
77086: LD_INT 1
77088: PUSH
77089: LD_INT 0
77091: PUSH
77092: EMPTY
77093: LIST
77094: LIST
77095: PUSH
77096: LD_INT 1
77098: PUSH
77099: LD_INT 1
77101: PUSH
77102: EMPTY
77103: LIST
77104: LIST
77105: PUSH
77106: LD_INT 0
77108: PUSH
77109: LD_INT 1
77111: PUSH
77112: EMPTY
77113: LIST
77114: LIST
77115: PUSH
77116: LD_INT 1
77118: NEG
77119: PUSH
77120: LD_INT 0
77122: PUSH
77123: EMPTY
77124: LIST
77125: LIST
77126: PUSH
77127: LD_INT 1
77129: NEG
77130: PUSH
77131: LD_INT 1
77133: NEG
77134: PUSH
77135: EMPTY
77136: LIST
77137: LIST
77138: PUSH
77139: LD_INT 1
77141: NEG
77142: PUSH
77143: LD_INT 2
77145: NEG
77146: PUSH
77147: EMPTY
77148: LIST
77149: LIST
77150: PUSH
77151: LD_INT 0
77153: PUSH
77154: LD_INT 2
77156: NEG
77157: PUSH
77158: EMPTY
77159: LIST
77160: LIST
77161: PUSH
77162: LD_INT 1
77164: PUSH
77165: LD_INT 1
77167: NEG
77168: PUSH
77169: EMPTY
77170: LIST
77171: LIST
77172: PUSH
77173: LD_INT 2
77175: PUSH
77176: LD_INT 0
77178: PUSH
77179: EMPTY
77180: LIST
77181: LIST
77182: PUSH
77183: LD_INT 2
77185: PUSH
77186: LD_INT 1
77188: PUSH
77189: EMPTY
77190: LIST
77191: LIST
77192: PUSH
77193: LD_INT 2
77195: PUSH
77196: LD_INT 2
77198: PUSH
77199: EMPTY
77200: LIST
77201: LIST
77202: PUSH
77203: LD_INT 1
77205: PUSH
77206: LD_INT 2
77208: PUSH
77209: EMPTY
77210: LIST
77211: LIST
77212: PUSH
77213: LD_INT 0
77215: PUSH
77216: LD_INT 2
77218: PUSH
77219: EMPTY
77220: LIST
77221: LIST
77222: PUSH
77223: LD_INT 1
77225: NEG
77226: PUSH
77227: LD_INT 1
77229: PUSH
77230: EMPTY
77231: LIST
77232: LIST
77233: PUSH
77234: LD_INT 2
77236: NEG
77237: PUSH
77238: LD_INT 0
77240: PUSH
77241: EMPTY
77242: LIST
77243: LIST
77244: PUSH
77245: LD_INT 2
77247: NEG
77248: PUSH
77249: LD_INT 1
77251: NEG
77252: PUSH
77253: EMPTY
77254: LIST
77255: LIST
77256: PUSH
77257: LD_INT 2
77259: NEG
77260: PUSH
77261: LD_INT 2
77263: NEG
77264: PUSH
77265: EMPTY
77266: LIST
77267: LIST
77268: PUSH
77269: EMPTY
77270: LIST
77271: LIST
77272: LIST
77273: LIST
77274: LIST
77275: LIST
77276: LIST
77277: LIST
77278: LIST
77279: LIST
77280: LIST
77281: LIST
77282: LIST
77283: LIST
77284: LIST
77285: LIST
77286: LIST
77287: LIST
77288: LIST
77289: ST_TO_ADDR
// Bunker0 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] ] ;
77290: LD_ADDR_VAR 0 59
77294: PUSH
77295: LD_INT 0
77297: PUSH
77298: LD_INT 0
77300: PUSH
77301: EMPTY
77302: LIST
77303: LIST
77304: PUSH
77305: LD_INT 0
77307: PUSH
77308: LD_INT 1
77310: NEG
77311: PUSH
77312: EMPTY
77313: LIST
77314: LIST
77315: PUSH
77316: LD_INT 1
77318: PUSH
77319: LD_INT 0
77321: PUSH
77322: EMPTY
77323: LIST
77324: LIST
77325: PUSH
77326: LD_INT 1
77328: PUSH
77329: LD_INT 1
77331: PUSH
77332: EMPTY
77333: LIST
77334: LIST
77335: PUSH
77336: LD_INT 0
77338: PUSH
77339: LD_INT 1
77341: PUSH
77342: EMPTY
77343: LIST
77344: LIST
77345: PUSH
77346: LD_INT 1
77348: NEG
77349: PUSH
77350: LD_INT 0
77352: PUSH
77353: EMPTY
77354: LIST
77355: LIST
77356: PUSH
77357: LD_INT 1
77359: NEG
77360: PUSH
77361: LD_INT 1
77363: NEG
77364: PUSH
77365: EMPTY
77366: LIST
77367: LIST
77368: PUSH
77369: EMPTY
77370: LIST
77371: LIST
77372: LIST
77373: LIST
77374: LIST
77375: LIST
77376: LIST
77377: ST_TO_ADDR
// Bunker1 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] ] ;
77378: LD_ADDR_VAR 0 60
77382: PUSH
77383: LD_INT 0
77385: PUSH
77386: LD_INT 0
77388: PUSH
77389: EMPTY
77390: LIST
77391: LIST
77392: PUSH
77393: LD_INT 0
77395: PUSH
77396: LD_INT 1
77398: NEG
77399: PUSH
77400: EMPTY
77401: LIST
77402: LIST
77403: PUSH
77404: LD_INT 1
77406: PUSH
77407: LD_INT 0
77409: PUSH
77410: EMPTY
77411: LIST
77412: LIST
77413: PUSH
77414: LD_INT 1
77416: PUSH
77417: LD_INT 1
77419: PUSH
77420: EMPTY
77421: LIST
77422: LIST
77423: PUSH
77424: LD_INT 0
77426: PUSH
77427: LD_INT 1
77429: PUSH
77430: EMPTY
77431: LIST
77432: LIST
77433: PUSH
77434: LD_INT 1
77436: NEG
77437: PUSH
77438: LD_INT 0
77440: PUSH
77441: EMPTY
77442: LIST
77443: LIST
77444: PUSH
77445: LD_INT 1
77447: NEG
77448: PUSH
77449: LD_INT 1
77451: NEG
77452: PUSH
77453: EMPTY
77454: LIST
77455: LIST
77456: PUSH
77457: EMPTY
77458: LIST
77459: LIST
77460: LIST
77461: LIST
77462: LIST
77463: LIST
77464: LIST
77465: ST_TO_ADDR
// Bunker2 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] ] ;
77466: LD_ADDR_VAR 0 61
77470: PUSH
77471: LD_INT 0
77473: PUSH
77474: LD_INT 0
77476: PUSH
77477: EMPTY
77478: LIST
77479: LIST
77480: PUSH
77481: LD_INT 0
77483: PUSH
77484: LD_INT 1
77486: NEG
77487: PUSH
77488: EMPTY
77489: LIST
77490: LIST
77491: PUSH
77492: LD_INT 1
77494: PUSH
77495: LD_INT 0
77497: PUSH
77498: EMPTY
77499: LIST
77500: LIST
77501: PUSH
77502: LD_INT 1
77504: PUSH
77505: LD_INT 1
77507: PUSH
77508: EMPTY
77509: LIST
77510: LIST
77511: PUSH
77512: LD_INT 0
77514: PUSH
77515: LD_INT 1
77517: PUSH
77518: EMPTY
77519: LIST
77520: LIST
77521: PUSH
77522: LD_INT 1
77524: NEG
77525: PUSH
77526: LD_INT 0
77528: PUSH
77529: EMPTY
77530: LIST
77531: LIST
77532: PUSH
77533: LD_INT 1
77535: NEG
77536: PUSH
77537: LD_INT 1
77539: NEG
77540: PUSH
77541: EMPTY
77542: LIST
77543: LIST
77544: PUSH
77545: EMPTY
77546: LIST
77547: LIST
77548: LIST
77549: LIST
77550: LIST
77551: LIST
77552: LIST
77553: ST_TO_ADDR
// Bunker3 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] ] ;
77554: LD_ADDR_VAR 0 62
77558: PUSH
77559: LD_INT 0
77561: PUSH
77562: LD_INT 0
77564: PUSH
77565: EMPTY
77566: LIST
77567: LIST
77568: PUSH
77569: LD_INT 0
77571: PUSH
77572: LD_INT 1
77574: NEG
77575: PUSH
77576: EMPTY
77577: LIST
77578: LIST
77579: PUSH
77580: LD_INT 1
77582: PUSH
77583: LD_INT 0
77585: PUSH
77586: EMPTY
77587: LIST
77588: LIST
77589: PUSH
77590: LD_INT 1
77592: PUSH
77593: LD_INT 1
77595: PUSH
77596: EMPTY
77597: LIST
77598: LIST
77599: PUSH
77600: LD_INT 0
77602: PUSH
77603: LD_INT 1
77605: PUSH
77606: EMPTY
77607: LIST
77608: LIST
77609: PUSH
77610: LD_INT 1
77612: NEG
77613: PUSH
77614: LD_INT 0
77616: PUSH
77617: EMPTY
77618: LIST
77619: LIST
77620: PUSH
77621: LD_INT 1
77623: NEG
77624: PUSH
77625: LD_INT 1
77627: NEG
77628: PUSH
77629: EMPTY
77630: LIST
77631: LIST
77632: PUSH
77633: EMPTY
77634: LIST
77635: LIST
77636: LIST
77637: LIST
77638: LIST
77639: LIST
77640: LIST
77641: ST_TO_ADDR
// Bunker4 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] ] ;
77642: LD_ADDR_VAR 0 63
77646: PUSH
77647: LD_INT 0
77649: PUSH
77650: LD_INT 0
77652: PUSH
77653: EMPTY
77654: LIST
77655: LIST
77656: PUSH
77657: LD_INT 0
77659: PUSH
77660: LD_INT 1
77662: NEG
77663: PUSH
77664: EMPTY
77665: LIST
77666: LIST
77667: PUSH
77668: LD_INT 1
77670: PUSH
77671: LD_INT 0
77673: PUSH
77674: EMPTY
77675: LIST
77676: LIST
77677: PUSH
77678: LD_INT 1
77680: PUSH
77681: LD_INT 1
77683: PUSH
77684: EMPTY
77685: LIST
77686: LIST
77687: PUSH
77688: LD_INT 0
77690: PUSH
77691: LD_INT 1
77693: PUSH
77694: EMPTY
77695: LIST
77696: LIST
77697: PUSH
77698: LD_INT 1
77700: NEG
77701: PUSH
77702: LD_INT 0
77704: PUSH
77705: EMPTY
77706: LIST
77707: LIST
77708: PUSH
77709: LD_INT 1
77711: NEG
77712: PUSH
77713: LD_INT 1
77715: NEG
77716: PUSH
77717: EMPTY
77718: LIST
77719: LIST
77720: PUSH
77721: EMPTY
77722: LIST
77723: LIST
77724: LIST
77725: LIST
77726: LIST
77727: LIST
77728: LIST
77729: ST_TO_ADDR
// Bunker5 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] ] ;
77730: LD_ADDR_VAR 0 64
77734: PUSH
77735: LD_INT 0
77737: PUSH
77738: LD_INT 0
77740: PUSH
77741: EMPTY
77742: LIST
77743: LIST
77744: PUSH
77745: LD_INT 0
77747: PUSH
77748: LD_INT 1
77750: NEG
77751: PUSH
77752: EMPTY
77753: LIST
77754: LIST
77755: PUSH
77756: LD_INT 1
77758: PUSH
77759: LD_INT 0
77761: PUSH
77762: EMPTY
77763: LIST
77764: LIST
77765: PUSH
77766: LD_INT 1
77768: PUSH
77769: LD_INT 1
77771: PUSH
77772: EMPTY
77773: LIST
77774: LIST
77775: PUSH
77776: LD_INT 0
77778: PUSH
77779: LD_INT 1
77781: PUSH
77782: EMPTY
77783: LIST
77784: LIST
77785: PUSH
77786: LD_INT 1
77788: NEG
77789: PUSH
77790: LD_INT 0
77792: PUSH
77793: EMPTY
77794: LIST
77795: LIST
77796: PUSH
77797: LD_INT 1
77799: NEG
77800: PUSH
77801: LD_INT 1
77803: NEG
77804: PUSH
77805: EMPTY
77806: LIST
77807: LIST
77808: PUSH
77809: EMPTY
77810: LIST
77811: LIST
77812: LIST
77813: LIST
77814: LIST
77815: LIST
77816: LIST
77817: ST_TO_ADDR
// end ; 1 :
77818: GO 83715
77820: LD_INT 1
77822: DOUBLE
77823: EQUAL
77824: IFTRUE 77828
77826: GO 80451
77828: POP
// begin DepotAm0 = [ [ - 1 , - 3 ] , [ 0 , - 3 ] , [ 1 , - 2 ] ] ;
77829: LD_ADDR_VAR 0 11
77833: PUSH
77834: LD_INT 1
77836: NEG
77837: PUSH
77838: LD_INT 3
77840: NEG
77841: PUSH
77842: EMPTY
77843: LIST
77844: LIST
77845: PUSH
77846: LD_INT 0
77848: PUSH
77849: LD_INT 3
77851: NEG
77852: PUSH
77853: EMPTY
77854: LIST
77855: LIST
77856: PUSH
77857: LD_INT 1
77859: PUSH
77860: LD_INT 2
77862: NEG
77863: PUSH
77864: EMPTY
77865: LIST
77866: LIST
77867: PUSH
77868: EMPTY
77869: LIST
77870: LIST
77871: LIST
77872: ST_TO_ADDR
// DepotAm1 = [ [ 2 , - 1 ] , [ 3 , 0 ] , [ 3 , 1 ] ] ;
77873: LD_ADDR_VAR 0 12
77877: PUSH
77878: LD_INT 2
77880: PUSH
77881: LD_INT 1
77883: NEG
77884: PUSH
77885: EMPTY
77886: LIST
77887: LIST
77888: PUSH
77889: LD_INT 3
77891: PUSH
77892: LD_INT 0
77894: PUSH
77895: EMPTY
77896: LIST
77897: LIST
77898: PUSH
77899: LD_INT 3
77901: PUSH
77902: LD_INT 1
77904: PUSH
77905: EMPTY
77906: LIST
77907: LIST
77908: PUSH
77909: EMPTY
77910: LIST
77911: LIST
77912: LIST
77913: ST_TO_ADDR
// DepotAm2 = [ [ 3 , 2 ] , [ 3 , 3 ] , [ 2 , 3 ] ] ;
77914: LD_ADDR_VAR 0 13
77918: PUSH
77919: LD_INT 3
77921: PUSH
77922: LD_INT 2
77924: PUSH
77925: EMPTY
77926: LIST
77927: LIST
77928: PUSH
77929: LD_INT 3
77931: PUSH
77932: LD_INT 3
77934: PUSH
77935: EMPTY
77936: LIST
77937: LIST
77938: PUSH
77939: LD_INT 2
77941: PUSH
77942: LD_INT 3
77944: PUSH
77945: EMPTY
77946: LIST
77947: LIST
77948: PUSH
77949: EMPTY
77950: LIST
77951: LIST
77952: LIST
77953: ST_TO_ADDR
// DepotAm3 = [ [ 1 , 3 ] , [ 0 , 3 ] , [ - 1 , 2 ] ] ;
77954: LD_ADDR_VAR 0 14
77958: PUSH
77959: LD_INT 1
77961: PUSH
77962: LD_INT 3
77964: PUSH
77965: EMPTY
77966: LIST
77967: LIST
77968: PUSH
77969: LD_INT 0
77971: PUSH
77972: LD_INT 3
77974: PUSH
77975: EMPTY
77976: LIST
77977: LIST
77978: PUSH
77979: LD_INT 1
77981: NEG
77982: PUSH
77983: LD_INT 2
77985: PUSH
77986: EMPTY
77987: LIST
77988: LIST
77989: PUSH
77990: EMPTY
77991: LIST
77992: LIST
77993: LIST
77994: ST_TO_ADDR
// DepotAm4 = [ [ - 2 , 1 ] , [ - 3 , 0 ] , [ - 3 , - 1 ] ] ;
77995: LD_ADDR_VAR 0 15
77999: PUSH
78000: LD_INT 2
78002: NEG
78003: PUSH
78004: LD_INT 1
78006: PUSH
78007: EMPTY
78008: LIST
78009: LIST
78010: PUSH
78011: LD_INT 3
78013: NEG
78014: PUSH
78015: LD_INT 0
78017: PUSH
78018: EMPTY
78019: LIST
78020: LIST
78021: PUSH
78022: LD_INT 3
78024: NEG
78025: PUSH
78026: LD_INT 1
78028: NEG
78029: PUSH
78030: EMPTY
78031: LIST
78032: LIST
78033: PUSH
78034: EMPTY
78035: LIST
78036: LIST
78037: LIST
78038: ST_TO_ADDR
// DepotAm5 = [ [ - 2 , - 3 ] , [ - 3 , - 2 ] , [ - 3 , - 3 ] ] ;
78039: LD_ADDR_VAR 0 16
78043: PUSH
78044: LD_INT 2
78046: NEG
78047: PUSH
78048: LD_INT 3
78050: NEG
78051: PUSH
78052: EMPTY
78053: LIST
78054: LIST
78055: PUSH
78056: LD_INT 3
78058: NEG
78059: PUSH
78060: LD_INT 2
78062: NEG
78063: PUSH
78064: EMPTY
78065: LIST
78066: LIST
78067: PUSH
78068: LD_INT 3
78070: NEG
78071: PUSH
78072: LD_INT 3
78074: NEG
78075: PUSH
78076: EMPTY
78077: LIST
78078: LIST
78079: PUSH
78080: EMPTY
78081: LIST
78082: LIST
78083: LIST
78084: ST_TO_ADDR
// DepotAr0 = [ [ - 1 , - 3 ] , [ 0 , - 3 ] , [ 1 , - 2 ] ] ;
78085: LD_ADDR_VAR 0 17
78089: PUSH
78090: LD_INT 1
78092: NEG
78093: PUSH
78094: LD_INT 3
78096: NEG
78097: PUSH
78098: EMPTY
78099: LIST
78100: LIST
78101: PUSH
78102: LD_INT 0
78104: PUSH
78105: LD_INT 3
78107: NEG
78108: PUSH
78109: EMPTY
78110: LIST
78111: LIST
78112: PUSH
78113: LD_INT 1
78115: PUSH
78116: LD_INT 2
78118: NEG
78119: PUSH
78120: EMPTY
78121: LIST
78122: LIST
78123: PUSH
78124: EMPTY
78125: LIST
78126: LIST
78127: LIST
78128: ST_TO_ADDR
// DepotAr1 = [ [ 2 , - 1 ] , [ 3 , 0 ] , [ 3 , 1 ] ] ;
78129: LD_ADDR_VAR 0 18
78133: PUSH
78134: LD_INT 2
78136: PUSH
78137: LD_INT 1
78139: NEG
78140: PUSH
78141: EMPTY
78142: LIST
78143: LIST
78144: PUSH
78145: LD_INT 3
78147: PUSH
78148: LD_INT 0
78150: PUSH
78151: EMPTY
78152: LIST
78153: LIST
78154: PUSH
78155: LD_INT 3
78157: PUSH
78158: LD_INT 1
78160: PUSH
78161: EMPTY
78162: LIST
78163: LIST
78164: PUSH
78165: EMPTY
78166: LIST
78167: LIST
78168: LIST
78169: ST_TO_ADDR
// DepotAr2 = [ [ 3 , 2 ] , [ 3 , 3 ] , [ 2 , 3 ] ] ;
78170: LD_ADDR_VAR 0 19
78174: PUSH
78175: LD_INT 3
78177: PUSH
78178: LD_INT 2
78180: PUSH
78181: EMPTY
78182: LIST
78183: LIST
78184: PUSH
78185: LD_INT 3
78187: PUSH
78188: LD_INT 3
78190: PUSH
78191: EMPTY
78192: LIST
78193: LIST
78194: PUSH
78195: LD_INT 2
78197: PUSH
78198: LD_INT 3
78200: PUSH
78201: EMPTY
78202: LIST
78203: LIST
78204: PUSH
78205: EMPTY
78206: LIST
78207: LIST
78208: LIST
78209: ST_TO_ADDR
// DepotAr3 = [ [ 1 , 3 ] , [ 0 , 3 ] , [ - 1 , 2 ] ] ;
78210: LD_ADDR_VAR 0 20
78214: PUSH
78215: LD_INT 1
78217: PUSH
78218: LD_INT 3
78220: PUSH
78221: EMPTY
78222: LIST
78223: LIST
78224: PUSH
78225: LD_INT 0
78227: PUSH
78228: LD_INT 3
78230: PUSH
78231: EMPTY
78232: LIST
78233: LIST
78234: PUSH
78235: LD_INT 1
78237: NEG
78238: PUSH
78239: LD_INT 2
78241: PUSH
78242: EMPTY
78243: LIST
78244: LIST
78245: PUSH
78246: EMPTY
78247: LIST
78248: LIST
78249: LIST
78250: ST_TO_ADDR
// DepotAr4 = [ [ - 2 , 1 ] , [ - 3 , 0 ] , [ - 3 , - 1 ] ] ;
78251: LD_ADDR_VAR 0 21
78255: PUSH
78256: LD_INT 2
78258: NEG
78259: PUSH
78260: LD_INT 1
78262: PUSH
78263: EMPTY
78264: LIST
78265: LIST
78266: PUSH
78267: LD_INT 3
78269: NEG
78270: PUSH
78271: LD_INT 0
78273: PUSH
78274: EMPTY
78275: LIST
78276: LIST
78277: PUSH
78278: LD_INT 3
78280: NEG
78281: PUSH
78282: LD_INT 1
78284: NEG
78285: PUSH
78286: EMPTY
78287: LIST
78288: LIST
78289: PUSH
78290: EMPTY
78291: LIST
78292: LIST
78293: LIST
78294: ST_TO_ADDR
// DepotAr5 = [ [ - 2 , - 3 ] , [ - 3 , - 2 ] , [ - 3 , - 3 ] ] ;
78295: LD_ADDR_VAR 0 22
78299: PUSH
78300: LD_INT 2
78302: NEG
78303: PUSH
78304: LD_INT 3
78306: NEG
78307: PUSH
78308: EMPTY
78309: LIST
78310: LIST
78311: PUSH
78312: LD_INT 3
78314: NEG
78315: PUSH
78316: LD_INT 2
78318: NEG
78319: PUSH
78320: EMPTY
78321: LIST
78322: LIST
78323: PUSH
78324: LD_INT 3
78326: NEG
78327: PUSH
78328: LD_INT 3
78330: NEG
78331: PUSH
78332: EMPTY
78333: LIST
78334: LIST
78335: PUSH
78336: EMPTY
78337: LIST
78338: LIST
78339: LIST
78340: ST_TO_ADDR
// DepotRu0 = [ [ 0 , - 3 ] , [ - 1 , - 4 ] , [ 1 , - 3 ] ] ;
78341: LD_ADDR_VAR 0 23
78345: PUSH
78346: LD_INT 0
78348: PUSH
78349: LD_INT 3
78351: NEG
78352: PUSH
78353: EMPTY
78354: LIST
78355: LIST
78356: PUSH
78357: LD_INT 1
78359: NEG
78360: PUSH
78361: LD_INT 4
78363: NEG
78364: PUSH
78365: EMPTY
78366: LIST
78367: LIST
78368: PUSH
78369: LD_INT 1
78371: PUSH
78372: LD_INT 3
78374: NEG
78375: PUSH
78376: EMPTY
78377: LIST
78378: LIST
78379: PUSH
78380: EMPTY
78381: LIST
78382: LIST
78383: LIST
78384: ST_TO_ADDR
// DepotRu1 = [ [ 3 , 0 ] , [ 3 , - 1 ] , [ 4 , 1 ] ] ;
78385: LD_ADDR_VAR 0 24
78389: PUSH
78390: LD_INT 3
78392: PUSH
78393: LD_INT 0
78395: PUSH
78396: EMPTY
78397: LIST
78398: LIST
78399: PUSH
78400: LD_INT 3
78402: PUSH
78403: LD_INT 1
78405: NEG
78406: PUSH
78407: EMPTY
78408: LIST
78409: LIST
78410: PUSH
78411: LD_INT 4
78413: PUSH
78414: LD_INT 1
78416: PUSH
78417: EMPTY
78418: LIST
78419: LIST
78420: PUSH
78421: EMPTY
78422: LIST
78423: LIST
78424: LIST
78425: ST_TO_ADDR
// DepotRu2 = [ [ 3 , 3 ] , [ 4 , 3 ] , [ 3 , 4 ] ] ;
78426: LD_ADDR_VAR 0 25
78430: PUSH
78431: LD_INT 3
78433: PUSH
78434: LD_INT 3
78436: PUSH
78437: EMPTY
78438: LIST
78439: LIST
78440: PUSH
78441: LD_INT 4
78443: PUSH
78444: LD_INT 3
78446: PUSH
78447: EMPTY
78448: LIST
78449: LIST
78450: PUSH
78451: LD_INT 3
78453: PUSH
78454: LD_INT 4
78456: PUSH
78457: EMPTY
78458: LIST
78459: LIST
78460: PUSH
78461: EMPTY
78462: LIST
78463: LIST
78464: LIST
78465: ST_TO_ADDR
// DepotRu3 = [ [ 0 , 3 ] , [ 1 , 4 ] , [ - 1 , 3 ] ] ;
78466: LD_ADDR_VAR 0 26
78470: PUSH
78471: LD_INT 0
78473: PUSH
78474: LD_INT 3
78476: PUSH
78477: EMPTY
78478: LIST
78479: LIST
78480: PUSH
78481: LD_INT 1
78483: PUSH
78484: LD_INT 4
78486: PUSH
78487: EMPTY
78488: LIST
78489: LIST
78490: PUSH
78491: LD_INT 1
78493: NEG
78494: PUSH
78495: LD_INT 3
78497: PUSH
78498: EMPTY
78499: LIST
78500: LIST
78501: PUSH
78502: EMPTY
78503: LIST
78504: LIST
78505: LIST
78506: ST_TO_ADDR
// DepotRu4 = [ [ - 3 , 0 ] , [ - 3 , 1 ] , [ - 4 , - 1 ] ] ;
78507: LD_ADDR_VAR 0 27
78511: PUSH
78512: LD_INT 3
78514: NEG
78515: PUSH
78516: LD_INT 0
78518: PUSH
78519: EMPTY
78520: LIST
78521: LIST
78522: PUSH
78523: LD_INT 3
78525: NEG
78526: PUSH
78527: LD_INT 1
78529: PUSH
78530: EMPTY
78531: LIST
78532: LIST
78533: PUSH
78534: LD_INT 4
78536: NEG
78537: PUSH
78538: LD_INT 1
78540: NEG
78541: PUSH
78542: EMPTY
78543: LIST
78544: LIST
78545: PUSH
78546: EMPTY
78547: LIST
78548: LIST
78549: LIST
78550: ST_TO_ADDR
// DepotRu5 = [ [ - 3 , - 3 ] , [ - 3 , - 4 ] , [ - 4 , - 3 ] ] ;
78551: LD_ADDR_VAR 0 28
78555: PUSH
78556: LD_INT 3
78558: NEG
78559: PUSH
78560: LD_INT 3
78562: NEG
78563: PUSH
78564: EMPTY
78565: LIST
78566: LIST
78567: PUSH
78568: LD_INT 3
78570: NEG
78571: PUSH
78572: LD_INT 4
78574: NEG
78575: PUSH
78576: EMPTY
78577: LIST
78578: LIST
78579: PUSH
78580: LD_INT 4
78582: NEG
78583: PUSH
78584: LD_INT 3
78586: NEG
78587: PUSH
78588: EMPTY
78589: LIST
78590: LIST
78591: PUSH
78592: EMPTY
78593: LIST
78594: LIST
78595: LIST
78596: ST_TO_ADDR
// Factory0 = [ [ - 1 , - 3 ] , [ 0 , - 3 ] , [ 1 , - 2 ] , [ - 1 , - 4 ] , [ 0 , - 4 ] , [ 1 , - 3 ] , [ - 1 , - 5 ] , [ 0 , - 5 ] , [ 1 , - 4 ] , [ - 1 , - 6 ] , [ 0 , - 6 ] , [ 1 , - 5 ] ] ;
78597: LD_ADDR_VAR 0 29
78601: PUSH
78602: LD_INT 1
78604: NEG
78605: PUSH
78606: LD_INT 3
78608: NEG
78609: PUSH
78610: EMPTY
78611: LIST
78612: LIST
78613: PUSH
78614: LD_INT 0
78616: PUSH
78617: LD_INT 3
78619: NEG
78620: PUSH
78621: EMPTY
78622: LIST
78623: LIST
78624: PUSH
78625: LD_INT 1
78627: PUSH
78628: LD_INT 2
78630: NEG
78631: PUSH
78632: EMPTY
78633: LIST
78634: LIST
78635: PUSH
78636: LD_INT 1
78638: NEG
78639: PUSH
78640: LD_INT 4
78642: NEG
78643: PUSH
78644: EMPTY
78645: LIST
78646: LIST
78647: PUSH
78648: LD_INT 0
78650: PUSH
78651: LD_INT 4
78653: NEG
78654: PUSH
78655: EMPTY
78656: LIST
78657: LIST
78658: PUSH
78659: LD_INT 1
78661: PUSH
78662: LD_INT 3
78664: NEG
78665: PUSH
78666: EMPTY
78667: LIST
78668: LIST
78669: PUSH
78670: LD_INT 1
78672: NEG
78673: PUSH
78674: LD_INT 5
78676: NEG
78677: PUSH
78678: EMPTY
78679: LIST
78680: LIST
78681: PUSH
78682: LD_INT 0
78684: PUSH
78685: LD_INT 5
78687: NEG
78688: PUSH
78689: EMPTY
78690: LIST
78691: LIST
78692: PUSH
78693: LD_INT 1
78695: PUSH
78696: LD_INT 4
78698: NEG
78699: PUSH
78700: EMPTY
78701: LIST
78702: LIST
78703: PUSH
78704: LD_INT 1
78706: NEG
78707: PUSH
78708: LD_INT 6
78710: NEG
78711: PUSH
78712: EMPTY
78713: LIST
78714: LIST
78715: PUSH
78716: LD_INT 0
78718: PUSH
78719: LD_INT 6
78721: NEG
78722: PUSH
78723: EMPTY
78724: LIST
78725: LIST
78726: PUSH
78727: LD_INT 1
78729: PUSH
78730: LD_INT 5
78732: NEG
78733: PUSH
78734: EMPTY
78735: LIST
78736: LIST
78737: PUSH
78738: EMPTY
78739: LIST
78740: LIST
78741: LIST
78742: LIST
78743: LIST
78744: LIST
78745: LIST
78746: LIST
78747: LIST
78748: LIST
78749: LIST
78750: LIST
78751: ST_TO_ADDR
// Factory1 = [ [ 2 , - 1 ] , [ 3 , 0 ] , [ 3 , 1 ] , [ 3 , - 1 ] , [ 4 , 0 ] , [ 4 , 1 ] , [ 4 , - 1 ] , [ 5 , 0 ] , [ 5 , 1 ] , [ 5 , - 1 ] , [ 6 , 0 ] , [ 6 , 1 ] ] ;
78752: LD_ADDR_VAR 0 30
78756: PUSH
78757: LD_INT 2
78759: PUSH
78760: LD_INT 1
78762: NEG
78763: PUSH
78764: EMPTY
78765: LIST
78766: LIST
78767: PUSH
78768: LD_INT 3
78770: PUSH
78771: LD_INT 0
78773: PUSH
78774: EMPTY
78775: LIST
78776: LIST
78777: PUSH
78778: LD_INT 3
78780: PUSH
78781: LD_INT 1
78783: PUSH
78784: EMPTY
78785: LIST
78786: LIST
78787: PUSH
78788: LD_INT 3
78790: PUSH
78791: LD_INT 1
78793: NEG
78794: PUSH
78795: EMPTY
78796: LIST
78797: LIST
78798: PUSH
78799: LD_INT 4
78801: PUSH
78802: LD_INT 0
78804: PUSH
78805: EMPTY
78806: LIST
78807: LIST
78808: PUSH
78809: LD_INT 4
78811: PUSH
78812: LD_INT 1
78814: PUSH
78815: EMPTY
78816: LIST
78817: LIST
78818: PUSH
78819: LD_INT 4
78821: PUSH
78822: LD_INT 1
78824: NEG
78825: PUSH
78826: EMPTY
78827: LIST
78828: LIST
78829: PUSH
78830: LD_INT 5
78832: PUSH
78833: LD_INT 0
78835: PUSH
78836: EMPTY
78837: LIST
78838: LIST
78839: PUSH
78840: LD_INT 5
78842: PUSH
78843: LD_INT 1
78845: PUSH
78846: EMPTY
78847: LIST
78848: LIST
78849: PUSH
78850: LD_INT 5
78852: PUSH
78853: LD_INT 1
78855: NEG
78856: PUSH
78857: EMPTY
78858: LIST
78859: LIST
78860: PUSH
78861: LD_INT 6
78863: PUSH
78864: LD_INT 0
78866: PUSH
78867: EMPTY
78868: LIST
78869: LIST
78870: PUSH
78871: LD_INT 6
78873: PUSH
78874: LD_INT 1
78876: PUSH
78877: EMPTY
78878: LIST
78879: LIST
78880: PUSH
78881: EMPTY
78882: LIST
78883: LIST
78884: LIST
78885: LIST
78886: LIST
78887: LIST
78888: LIST
78889: LIST
78890: LIST
78891: LIST
78892: LIST
78893: LIST
78894: ST_TO_ADDR
// Factory2 = [ [ 3 , 2 ] , [ 3 , 3 ] , [ 2 , 3 ] , [ 4 , 3 ] , [ 4 , 4 ] , [ 3 , 4 ] , [ 5 , 4 ] , [ 5 , 5 ] , [ 4 , 5 ] , [ 6 , 5 ] , [ 6 , 6 ] , [ 5 , 6 ] ] ;
78895: LD_ADDR_VAR 0 31
78899: PUSH
78900: LD_INT 3
78902: PUSH
78903: LD_INT 2
78905: PUSH
78906: EMPTY
78907: LIST
78908: LIST
78909: PUSH
78910: LD_INT 3
78912: PUSH
78913: LD_INT 3
78915: PUSH
78916: EMPTY
78917: LIST
78918: LIST
78919: PUSH
78920: LD_INT 2
78922: PUSH
78923: LD_INT 3
78925: PUSH
78926: EMPTY
78927: LIST
78928: LIST
78929: PUSH
78930: LD_INT 4
78932: PUSH
78933: LD_INT 3
78935: PUSH
78936: EMPTY
78937: LIST
78938: LIST
78939: PUSH
78940: LD_INT 4
78942: PUSH
78943: LD_INT 4
78945: PUSH
78946: EMPTY
78947: LIST
78948: LIST
78949: PUSH
78950: LD_INT 3
78952: PUSH
78953: LD_INT 4
78955: PUSH
78956: EMPTY
78957: LIST
78958: LIST
78959: PUSH
78960: LD_INT 5
78962: PUSH
78963: LD_INT 4
78965: PUSH
78966: EMPTY
78967: LIST
78968: LIST
78969: PUSH
78970: LD_INT 5
78972: PUSH
78973: LD_INT 5
78975: PUSH
78976: EMPTY
78977: LIST
78978: LIST
78979: PUSH
78980: LD_INT 4
78982: PUSH
78983: LD_INT 5
78985: PUSH
78986: EMPTY
78987: LIST
78988: LIST
78989: PUSH
78990: LD_INT 6
78992: PUSH
78993: LD_INT 5
78995: PUSH
78996: EMPTY
78997: LIST
78998: LIST
78999: PUSH
79000: LD_INT 6
79002: PUSH
79003: LD_INT 6
79005: PUSH
79006: EMPTY
79007: LIST
79008: LIST
79009: PUSH
79010: LD_INT 5
79012: PUSH
79013: LD_INT 6
79015: PUSH
79016: EMPTY
79017: LIST
79018: LIST
79019: PUSH
79020: EMPTY
79021: LIST
79022: LIST
79023: LIST
79024: LIST
79025: LIST
79026: LIST
79027: LIST
79028: LIST
79029: LIST
79030: LIST
79031: LIST
79032: LIST
79033: ST_TO_ADDR
// Factory3 = [ [ 1 , 3 ] , [ 0 , 3 ] , [ - 1 , 2 ] , [ 1 , 4 ] , [ 0 , 4 ] , [ - 1 , 3 ] , [ 1 , 5 ] , [ 0 , 5 ] , [ - 1 , 4 ] , [ 1 , 6 ] , [ 0 , 6 ] , [ - 1 , 5 ] ] ;
79034: LD_ADDR_VAR 0 32
79038: PUSH
79039: LD_INT 1
79041: PUSH
79042: LD_INT 3
79044: PUSH
79045: EMPTY
79046: LIST
79047: LIST
79048: PUSH
79049: LD_INT 0
79051: PUSH
79052: LD_INT 3
79054: PUSH
79055: EMPTY
79056: LIST
79057: LIST
79058: PUSH
79059: LD_INT 1
79061: NEG
79062: PUSH
79063: LD_INT 2
79065: PUSH
79066: EMPTY
79067: LIST
79068: LIST
79069: PUSH
79070: LD_INT 1
79072: PUSH
79073: LD_INT 4
79075: PUSH
79076: EMPTY
79077: LIST
79078: LIST
79079: PUSH
79080: LD_INT 0
79082: PUSH
79083: LD_INT 4
79085: PUSH
79086: EMPTY
79087: LIST
79088: LIST
79089: PUSH
79090: LD_INT 1
79092: NEG
79093: PUSH
79094: LD_INT 3
79096: PUSH
79097: EMPTY
79098: LIST
79099: LIST
79100: PUSH
79101: LD_INT 1
79103: PUSH
79104: LD_INT 5
79106: PUSH
79107: EMPTY
79108: LIST
79109: LIST
79110: PUSH
79111: LD_INT 0
79113: PUSH
79114: LD_INT 5
79116: PUSH
79117: EMPTY
79118: LIST
79119: LIST
79120: PUSH
79121: LD_INT 1
79123: NEG
79124: PUSH
79125: LD_INT 4
79127: PUSH
79128: EMPTY
79129: LIST
79130: LIST
79131: PUSH
79132: LD_INT 1
79134: PUSH
79135: LD_INT 6
79137: PUSH
79138: EMPTY
79139: LIST
79140: LIST
79141: PUSH
79142: LD_INT 0
79144: PUSH
79145: LD_INT 6
79147: PUSH
79148: EMPTY
79149: LIST
79150: LIST
79151: PUSH
79152: LD_INT 1
79154: NEG
79155: PUSH
79156: LD_INT 5
79158: PUSH
79159: EMPTY
79160: LIST
79161: LIST
79162: PUSH
79163: EMPTY
79164: LIST
79165: LIST
79166: LIST
79167: LIST
79168: LIST
79169: LIST
79170: LIST
79171: LIST
79172: LIST
79173: LIST
79174: LIST
79175: LIST
79176: ST_TO_ADDR
// Factory4 = [ [ - 2 , 1 ] , [ - 3 , 0 ] , [ - 3 , - 1 ] , [ - 3 , 1 ] , [ - 4 , 0 ] , [ - 4 , - 1 ] , [ - 4 , 1 ] , [ - 5 , 0 ] , [ - 5 , - 1 ] , [ - 5 , 1 ] , [ - 6 , 0 ] , [ - 6 , - 1 ] ] ;
79177: LD_ADDR_VAR 0 33
79181: PUSH
79182: LD_INT 2
79184: NEG
79185: PUSH
79186: LD_INT 1
79188: PUSH
79189: EMPTY
79190: LIST
79191: LIST
79192: PUSH
79193: LD_INT 3
79195: NEG
79196: PUSH
79197: LD_INT 0
79199: PUSH
79200: EMPTY
79201: LIST
79202: LIST
79203: PUSH
79204: LD_INT 3
79206: NEG
79207: PUSH
79208: LD_INT 1
79210: NEG
79211: PUSH
79212: EMPTY
79213: LIST
79214: LIST
79215: PUSH
79216: LD_INT 3
79218: NEG
79219: PUSH
79220: LD_INT 1
79222: PUSH
79223: EMPTY
79224: LIST
79225: LIST
79226: PUSH
79227: LD_INT 4
79229: NEG
79230: PUSH
79231: LD_INT 0
79233: PUSH
79234: EMPTY
79235: LIST
79236: LIST
79237: PUSH
79238: LD_INT 4
79240: NEG
79241: PUSH
79242: LD_INT 1
79244: NEG
79245: PUSH
79246: EMPTY
79247: LIST
79248: LIST
79249: PUSH
79250: LD_INT 4
79252: NEG
79253: PUSH
79254: LD_INT 1
79256: PUSH
79257: EMPTY
79258: LIST
79259: LIST
79260: PUSH
79261: LD_INT 5
79263: NEG
79264: PUSH
79265: LD_INT 0
79267: PUSH
79268: EMPTY
79269: LIST
79270: LIST
79271: PUSH
79272: LD_INT 5
79274: NEG
79275: PUSH
79276: LD_INT 1
79278: NEG
79279: PUSH
79280: EMPTY
79281: LIST
79282: LIST
79283: PUSH
79284: LD_INT 5
79286: NEG
79287: PUSH
79288: LD_INT 1
79290: PUSH
79291: EMPTY
79292: LIST
79293: LIST
79294: PUSH
79295: LD_INT 6
79297: NEG
79298: PUSH
79299: LD_INT 0
79301: PUSH
79302: EMPTY
79303: LIST
79304: LIST
79305: PUSH
79306: LD_INT 6
79308: NEG
79309: PUSH
79310: LD_INT 1
79312: NEG
79313: PUSH
79314: EMPTY
79315: LIST
79316: LIST
79317: PUSH
79318: EMPTY
79319: LIST
79320: LIST
79321: LIST
79322: LIST
79323: LIST
79324: LIST
79325: LIST
79326: LIST
79327: LIST
79328: LIST
79329: LIST
79330: LIST
79331: ST_TO_ADDR
// Factory5 = [ [ - 2 , - 3 ] , [ - 3 , - 2 ] , [ - 3 , - 3 ] , [ - 3 , - 4 ] , [ - 4 , - 3 ] , [ - 4 , - 4 ] , [ - 4 , - 5 ] , [ - 5 , - 4 ] , [ - 5 , - 5 ] , [ - 5 , - 6 ] , [ - 6 , - 5 ] , [ - 6 , - 6 ] ] ;
79332: LD_ADDR_VAR 0 34
79336: PUSH
79337: LD_INT 2
79339: NEG
79340: PUSH
79341: LD_INT 3
79343: NEG
79344: PUSH
79345: EMPTY
79346: LIST
79347: LIST
79348: PUSH
79349: LD_INT 3
79351: NEG
79352: PUSH
79353: LD_INT 2
79355: NEG
79356: PUSH
79357: EMPTY
79358: LIST
79359: LIST
79360: PUSH
79361: LD_INT 3
79363: NEG
79364: PUSH
79365: LD_INT 3
79367: NEG
79368: PUSH
79369: EMPTY
79370: LIST
79371: LIST
79372: PUSH
79373: LD_INT 3
79375: NEG
79376: PUSH
79377: LD_INT 4
79379: NEG
79380: PUSH
79381: EMPTY
79382: LIST
79383: LIST
79384: PUSH
79385: LD_INT 4
79387: NEG
79388: PUSH
79389: LD_INT 3
79391: NEG
79392: PUSH
79393: EMPTY
79394: LIST
79395: LIST
79396: PUSH
79397: LD_INT 4
79399: NEG
79400: PUSH
79401: LD_INT 4
79403: NEG
79404: PUSH
79405: EMPTY
79406: LIST
79407: LIST
79408: PUSH
79409: LD_INT 4
79411: NEG
79412: PUSH
79413: LD_INT 5
79415: NEG
79416: PUSH
79417: EMPTY
79418: LIST
79419: LIST
79420: PUSH
79421: LD_INT 5
79423: NEG
79424: PUSH
79425: LD_INT 4
79427: NEG
79428: PUSH
79429: EMPTY
79430: LIST
79431: LIST
79432: PUSH
79433: LD_INT 5
79435: NEG
79436: PUSH
79437: LD_INT 5
79439: NEG
79440: PUSH
79441: EMPTY
79442: LIST
79443: LIST
79444: PUSH
79445: LD_INT 5
79447: NEG
79448: PUSH
79449: LD_INT 6
79451: NEG
79452: PUSH
79453: EMPTY
79454: LIST
79455: LIST
79456: PUSH
79457: LD_INT 6
79459: NEG
79460: PUSH
79461: LD_INT 5
79463: NEG
79464: PUSH
79465: EMPTY
79466: LIST
79467: LIST
79468: PUSH
79469: LD_INT 6
79471: NEG
79472: PUSH
79473: LD_INT 6
79475: NEG
79476: PUSH
79477: EMPTY
79478: LIST
79479: LIST
79480: PUSH
79481: EMPTY
79482: LIST
79483: LIST
79484: LIST
79485: LIST
79486: LIST
79487: LIST
79488: LIST
79489: LIST
79490: LIST
79491: LIST
79492: LIST
79493: LIST
79494: ST_TO_ADDR
// Lab0 = [ [ 0 , - 2 ] , [ - 1 , - 3 ] , [ 1 , - 2 ] ] ;
79495: LD_ADDR_VAR 0 41
79499: PUSH
79500: LD_INT 0
79502: PUSH
79503: LD_INT 2
79505: NEG
79506: PUSH
79507: EMPTY
79508: LIST
79509: LIST
79510: PUSH
79511: LD_INT 1
79513: NEG
79514: PUSH
79515: LD_INT 3
79517: NEG
79518: PUSH
79519: EMPTY
79520: LIST
79521: LIST
79522: PUSH
79523: LD_INT 1
79525: PUSH
79526: LD_INT 2
79528: NEG
79529: PUSH
79530: EMPTY
79531: LIST
79532: LIST
79533: PUSH
79534: EMPTY
79535: LIST
79536: LIST
79537: LIST
79538: ST_TO_ADDR
// Lab1 = [ [ 2 , 0 ] , [ 2 , - 1 ] , [ 3 , 1 ] ] ;
79539: LD_ADDR_VAR 0 42
79543: PUSH
79544: LD_INT 2
79546: PUSH
79547: LD_INT 0
79549: PUSH
79550: EMPTY
79551: LIST
79552: LIST
79553: PUSH
79554: LD_INT 2
79556: PUSH
79557: LD_INT 1
79559: NEG
79560: PUSH
79561: EMPTY
79562: LIST
79563: LIST
79564: PUSH
79565: LD_INT 3
79567: PUSH
79568: LD_INT 1
79570: PUSH
79571: EMPTY
79572: LIST
79573: LIST
79574: PUSH
79575: EMPTY
79576: LIST
79577: LIST
79578: LIST
79579: ST_TO_ADDR
// Lab2 = [ [ 2 , 2 ] , [ 3 , 2 ] , [ 2 , 3 ] ] ;
79580: LD_ADDR_VAR 0 43
79584: PUSH
79585: LD_INT 2
79587: PUSH
79588: LD_INT 2
79590: PUSH
79591: EMPTY
79592: LIST
79593: LIST
79594: PUSH
79595: LD_INT 3
79597: PUSH
79598: LD_INT 2
79600: PUSH
79601: EMPTY
79602: LIST
79603: LIST
79604: PUSH
79605: LD_INT 2
79607: PUSH
79608: LD_INT 3
79610: PUSH
79611: EMPTY
79612: LIST
79613: LIST
79614: PUSH
79615: EMPTY
79616: LIST
79617: LIST
79618: LIST
79619: ST_TO_ADDR
// Lab3 = [ [ 0 , 2 ] , [ 1 , 3 ] , [ - 1 , 2 ] ] ;
79620: LD_ADDR_VAR 0 44
79624: PUSH
79625: LD_INT 0
79627: PUSH
79628: LD_INT 2
79630: PUSH
79631: EMPTY
79632: LIST
79633: LIST
79634: PUSH
79635: LD_INT 1
79637: PUSH
79638: LD_INT 3
79640: PUSH
79641: EMPTY
79642: LIST
79643: LIST
79644: PUSH
79645: LD_INT 1
79647: NEG
79648: PUSH
79649: LD_INT 2
79651: PUSH
79652: EMPTY
79653: LIST
79654: LIST
79655: PUSH
79656: EMPTY
79657: LIST
79658: LIST
79659: LIST
79660: ST_TO_ADDR
// Lab4 = [ [ - 2 , 0 ] , [ - 2 , 1 ] , [ - 3 , - 1 ] ] ;
79661: LD_ADDR_VAR 0 45
79665: PUSH
79666: LD_INT 2
79668: NEG
79669: PUSH
79670: LD_INT 0
79672: PUSH
79673: EMPTY
79674: LIST
79675: LIST
79676: PUSH
79677: LD_INT 2
79679: NEG
79680: PUSH
79681: LD_INT 1
79683: PUSH
79684: EMPTY
79685: LIST
79686: LIST
79687: PUSH
79688: LD_INT 3
79690: NEG
79691: PUSH
79692: LD_INT 1
79694: NEG
79695: PUSH
79696: EMPTY
79697: LIST
79698: LIST
79699: PUSH
79700: EMPTY
79701: LIST
79702: LIST
79703: LIST
79704: ST_TO_ADDR
// Lab5 = [ [ - 2 , - 2 ] , [ - 2 , - 3 ] , [ - 3 , - 2 ] ] ;
79705: LD_ADDR_VAR 0 46
79709: PUSH
79710: LD_INT 2
79712: NEG
79713: PUSH
79714: LD_INT 2
79716: NEG
79717: PUSH
79718: EMPTY
79719: LIST
79720: LIST
79721: PUSH
79722: LD_INT 2
79724: NEG
79725: PUSH
79726: LD_INT 3
79728: NEG
79729: PUSH
79730: EMPTY
79731: LIST
79732: LIST
79733: PUSH
79734: LD_INT 3
79736: NEG
79737: PUSH
79738: LD_INT 2
79740: NEG
79741: PUSH
79742: EMPTY
79743: LIST
79744: LIST
79745: PUSH
79746: EMPTY
79747: LIST
79748: LIST
79749: LIST
79750: ST_TO_ADDR
// ControlTower0 = [ [ - 2 , - 3 ] , [ - 1 , - 3 ] ] ;
79751: LD_ADDR_VAR 0 47
79755: PUSH
79756: LD_INT 2
79758: NEG
79759: PUSH
79760: LD_INT 3
79762: NEG
79763: PUSH
79764: EMPTY
79765: LIST
79766: LIST
79767: PUSH
79768: LD_INT 1
79770: NEG
79771: PUSH
79772: LD_INT 3
79774: NEG
79775: PUSH
79776: EMPTY
79777: LIST
79778: LIST
79779: PUSH
79780: EMPTY
79781: LIST
79782: LIST
79783: ST_TO_ADDR
// ControlTower1 = [ [ 1 , - 2 ] , [ 2 , - 1 ] ] ;
79784: LD_ADDR_VAR 0 48
79788: PUSH
79789: LD_INT 1
79791: PUSH
79792: LD_INT 2
79794: NEG
79795: PUSH
79796: EMPTY
79797: LIST
79798: LIST
79799: PUSH
79800: LD_INT 2
79802: PUSH
79803: LD_INT 1
79805: NEG
79806: PUSH
79807: EMPTY
79808: LIST
79809: LIST
79810: PUSH
79811: EMPTY
79812: LIST
79813: LIST
79814: ST_TO_ADDR
// ControlTower2 = [ [ 3 , 1 ] , [ 3 , 2 ] ] ;
79815: LD_ADDR_VAR 0 49
79819: PUSH
79820: LD_INT 3
79822: PUSH
79823: LD_INT 1
79825: PUSH
79826: EMPTY
79827: LIST
79828: LIST
79829: PUSH
79830: LD_INT 3
79832: PUSH
79833: LD_INT 2
79835: PUSH
79836: EMPTY
79837: LIST
79838: LIST
79839: PUSH
79840: EMPTY
79841: LIST
79842: LIST
79843: ST_TO_ADDR
// ControlTower3 = [ [ 2 , 3 ] , [ 1 , 3 ] ] ;
79844: LD_ADDR_VAR 0 50
79848: PUSH
79849: LD_INT 2
79851: PUSH
79852: LD_INT 3
79854: PUSH
79855: EMPTY
79856: LIST
79857: LIST
79858: PUSH
79859: LD_INT 1
79861: PUSH
79862: LD_INT 3
79864: PUSH
79865: EMPTY
79866: LIST
79867: LIST
79868: PUSH
79869: EMPTY
79870: LIST
79871: LIST
79872: ST_TO_ADDR
// ControlTower4 = [ [ - 1 , 2 ] , [ - 2 , 1 ] ] ;
79873: LD_ADDR_VAR 0 51
79877: PUSH
79878: LD_INT 1
79880: NEG
79881: PUSH
79882: LD_INT 2
79884: PUSH
79885: EMPTY
79886: LIST
79887: LIST
79888: PUSH
79889: LD_INT 2
79891: NEG
79892: PUSH
79893: LD_INT 1
79895: PUSH
79896: EMPTY
79897: LIST
79898: LIST
79899: PUSH
79900: EMPTY
79901: LIST
79902: LIST
79903: ST_TO_ADDR
// ControlTower5 = [ [ - 3 , - 1 ] , [ - 3 , - 2 ] ] ;
79904: LD_ADDR_VAR 0 52
79908: PUSH
79909: LD_INT 3
79911: NEG
79912: PUSH
79913: LD_INT 1
79915: NEG
79916: PUSH
79917: EMPTY
79918: LIST
79919: LIST
79920: PUSH
79921: LD_INT 3
79923: NEG
79924: PUSH
79925: LD_INT 2
79927: NEG
79928: PUSH
79929: EMPTY
79930: LIST
79931: LIST
79932: PUSH
79933: EMPTY
79934: LIST
79935: LIST
79936: ST_TO_ADDR
// Barracks0 = [ [ - 1 , - 3 ] , [ 0 , - 3 ] , [ 1 , - 2 ] ] ;
79937: LD_ADDR_VAR 0 53
79941: PUSH
79942: LD_INT 1
79944: NEG
79945: PUSH
79946: LD_INT 3
79948: NEG
79949: PUSH
79950: EMPTY
79951: LIST
79952: LIST
79953: PUSH
79954: LD_INT 0
79956: PUSH
79957: LD_INT 3
79959: NEG
79960: PUSH
79961: EMPTY
79962: LIST
79963: LIST
79964: PUSH
79965: LD_INT 1
79967: PUSH
79968: LD_INT 2
79970: NEG
79971: PUSH
79972: EMPTY
79973: LIST
79974: LIST
79975: PUSH
79976: EMPTY
79977: LIST
79978: LIST
79979: LIST
79980: ST_TO_ADDR
// Barracks1 = [ [ 2 , - 1 ] , [ 3 , 0 ] , [ 3 , 1 ] ] ;
79981: LD_ADDR_VAR 0 54
79985: PUSH
79986: LD_INT 2
79988: PUSH
79989: LD_INT 1
79991: NEG
79992: PUSH
79993: EMPTY
79994: LIST
79995: LIST
79996: PUSH
79997: LD_INT 3
79999: PUSH
80000: LD_INT 0
80002: PUSH
80003: EMPTY
80004: LIST
80005: LIST
80006: PUSH
80007: LD_INT 3
80009: PUSH
80010: LD_INT 1
80012: PUSH
80013: EMPTY
80014: LIST
80015: LIST
80016: PUSH
80017: EMPTY
80018: LIST
80019: LIST
80020: LIST
80021: ST_TO_ADDR
// Barracks2 = [ [ 3 , 2 ] , [ 3 , 3 ] , [ 2 , 3 ] ] ;
80022: LD_ADDR_VAR 0 55
80026: PUSH
80027: LD_INT 3
80029: PUSH
80030: LD_INT 2
80032: PUSH
80033: EMPTY
80034: LIST
80035: LIST
80036: PUSH
80037: LD_INT 3
80039: PUSH
80040: LD_INT 3
80042: PUSH
80043: EMPTY
80044: LIST
80045: LIST
80046: PUSH
80047: LD_INT 2
80049: PUSH
80050: LD_INT 3
80052: PUSH
80053: EMPTY
80054: LIST
80055: LIST
80056: PUSH
80057: EMPTY
80058: LIST
80059: LIST
80060: LIST
80061: ST_TO_ADDR
// Barracks3 = [ [ 1 , 3 ] , [ 0 , 3 ] , [ - 1 , 2 ] ] ;
80062: LD_ADDR_VAR 0 56
80066: PUSH
80067: LD_INT 1
80069: PUSH
80070: LD_INT 3
80072: PUSH
80073: EMPTY
80074: LIST
80075: LIST
80076: PUSH
80077: LD_INT 0
80079: PUSH
80080: LD_INT 3
80082: PUSH
80083: EMPTY
80084: LIST
80085: LIST
80086: PUSH
80087: LD_INT 1
80089: NEG
80090: PUSH
80091: LD_INT 2
80093: PUSH
80094: EMPTY
80095: LIST
80096: LIST
80097: PUSH
80098: EMPTY
80099: LIST
80100: LIST
80101: LIST
80102: ST_TO_ADDR
// Barracks4 = [ [ - 2 , 1 ] , [ - 3 , 0 ] , [ - 3 , - 1 ] ] ;
80103: LD_ADDR_VAR 0 57
80107: PUSH
80108: LD_INT 2
80110: NEG
80111: PUSH
80112: LD_INT 1
80114: PUSH
80115: EMPTY
80116: LIST
80117: LIST
80118: PUSH
80119: LD_INT 3
80121: NEG
80122: PUSH
80123: LD_INT 0
80125: PUSH
80126: EMPTY
80127: LIST
80128: LIST
80129: PUSH
80130: LD_INT 3
80132: NEG
80133: PUSH
80134: LD_INT 1
80136: NEG
80137: PUSH
80138: EMPTY
80139: LIST
80140: LIST
80141: PUSH
80142: EMPTY
80143: LIST
80144: LIST
80145: LIST
80146: ST_TO_ADDR
// Barracks5 = [ [ - 2 , - 3 ] , [ - 3 , - 2 ] , [ - 3 , - 3 ] ] ;
80147: LD_ADDR_VAR 0 58
80151: PUSH
80152: LD_INT 2
80154: NEG
80155: PUSH
80156: LD_INT 3
80158: NEG
80159: PUSH
80160: EMPTY
80161: LIST
80162: LIST
80163: PUSH
80164: LD_INT 3
80166: NEG
80167: PUSH
80168: LD_INT 2
80170: NEG
80171: PUSH
80172: EMPTY
80173: LIST
80174: LIST
80175: PUSH
80176: LD_INT 3
80178: NEG
80179: PUSH
80180: LD_INT 3
80182: NEG
80183: PUSH
80184: EMPTY
80185: LIST
80186: LIST
80187: PUSH
80188: EMPTY
80189: LIST
80190: LIST
80191: LIST
80192: ST_TO_ADDR
// Bunker0 = [ [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] ] ;
80193: LD_ADDR_VAR 0 59
80197: PUSH
80198: LD_INT 1
80200: NEG
80201: PUSH
80202: LD_INT 2
80204: NEG
80205: PUSH
80206: EMPTY
80207: LIST
80208: LIST
80209: PUSH
80210: LD_INT 0
80212: PUSH
80213: LD_INT 2
80215: NEG
80216: PUSH
80217: EMPTY
80218: LIST
80219: LIST
80220: PUSH
80221: LD_INT 1
80223: PUSH
80224: LD_INT 1
80226: NEG
80227: PUSH
80228: EMPTY
80229: LIST
80230: LIST
80231: PUSH
80232: EMPTY
80233: LIST
80234: LIST
80235: LIST
80236: ST_TO_ADDR
// Bunker1 = [ [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] ] ;
80237: LD_ADDR_VAR 0 60
80241: PUSH
80242: LD_INT 1
80244: PUSH
80245: LD_INT 1
80247: NEG
80248: PUSH
80249: EMPTY
80250: LIST
80251: LIST
80252: PUSH
80253: LD_INT 2
80255: PUSH
80256: LD_INT 0
80258: PUSH
80259: EMPTY
80260: LIST
80261: LIST
80262: PUSH
80263: LD_INT 2
80265: PUSH
80266: LD_INT 1
80268: PUSH
80269: EMPTY
80270: LIST
80271: LIST
80272: PUSH
80273: EMPTY
80274: LIST
80275: LIST
80276: LIST
80277: ST_TO_ADDR
// Bunker2 = [ [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] ] ;
80278: LD_ADDR_VAR 0 61
80282: PUSH
80283: LD_INT 2
80285: PUSH
80286: LD_INT 1
80288: PUSH
80289: EMPTY
80290: LIST
80291: LIST
80292: PUSH
80293: LD_INT 2
80295: PUSH
80296: LD_INT 2
80298: PUSH
80299: EMPTY
80300: LIST
80301: LIST
80302: PUSH
80303: LD_INT 1
80305: PUSH
80306: LD_INT 2
80308: PUSH
80309: EMPTY
80310: LIST
80311: LIST
80312: PUSH
80313: EMPTY
80314: LIST
80315: LIST
80316: LIST
80317: ST_TO_ADDR
// Bunker3 = [ [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] ] ;
80318: LD_ADDR_VAR 0 62
80322: PUSH
80323: LD_INT 1
80325: PUSH
80326: LD_INT 2
80328: PUSH
80329: EMPTY
80330: LIST
80331: LIST
80332: PUSH
80333: LD_INT 0
80335: PUSH
80336: LD_INT 2
80338: PUSH
80339: EMPTY
80340: LIST
80341: LIST
80342: PUSH
80343: LD_INT 1
80345: NEG
80346: PUSH
80347: LD_INT 1
80349: PUSH
80350: EMPTY
80351: LIST
80352: LIST
80353: PUSH
80354: EMPTY
80355: LIST
80356: LIST
80357: LIST
80358: ST_TO_ADDR
// Bunker4 = [ [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] ] ;
80359: LD_ADDR_VAR 0 63
80363: PUSH
80364: LD_INT 1
80366: NEG
80367: PUSH
80368: LD_INT 1
80370: PUSH
80371: EMPTY
80372: LIST
80373: LIST
80374: PUSH
80375: LD_INT 2
80377: NEG
80378: PUSH
80379: LD_INT 0
80381: PUSH
80382: EMPTY
80383: LIST
80384: LIST
80385: PUSH
80386: LD_INT 2
80388: NEG
80389: PUSH
80390: LD_INT 1
80392: NEG
80393: PUSH
80394: EMPTY
80395: LIST
80396: LIST
80397: PUSH
80398: EMPTY
80399: LIST
80400: LIST
80401: LIST
80402: ST_TO_ADDR
// Bunker5 = [ [ - 1 , - 2 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
80403: LD_ADDR_VAR 0 64
80407: PUSH
80408: LD_INT 1
80410: NEG
80411: PUSH
80412: LD_INT 2
80414: NEG
80415: PUSH
80416: EMPTY
80417: LIST
80418: LIST
80419: PUSH
80420: LD_INT 2
80422: NEG
80423: PUSH
80424: LD_INT 1
80426: NEG
80427: PUSH
80428: EMPTY
80429: LIST
80430: LIST
80431: PUSH
80432: LD_INT 2
80434: NEG
80435: PUSH
80436: LD_INT 2
80438: NEG
80439: PUSH
80440: EMPTY
80441: LIST
80442: LIST
80443: PUSH
80444: EMPTY
80445: LIST
80446: LIST
80447: LIST
80448: ST_TO_ADDR
// end ; 2 :
80449: GO 83715
80451: LD_INT 2
80453: DOUBLE
80454: EQUAL
80455: IFTRUE 80459
80457: GO 83714
80459: POP
// begin Factory0 = [ [ 4 , 0 ] , [ 4 , - 1 ] , [ 5 , 0 ] , [ 5 , 1 ] , [ 4 , 1 ] , [ 3 , 0 ] , [ 3 , - 1 ] , [ 3 , - 2 ] , [ 5 , 2 ] , [ 3 , 3 ] , [ 3 , 2 ] , [ 4 , 3 ] , [ 4 , 4 ] , [ 3 , 4 ] , [ 2 , 3 ] , [ 2 , 2 ] , [ 4 , 2 ] , [ 2 , 4 ] , [ 0 , 4 ] , [ 0 , 3 ] , [ 1 , 4 ] , [ 1 , 5 ] , [ 0 , 5 ] , [ - 1 , 4 ] , [ - 1 , 3 ] , [ 2 , 5 ] , [ - 2 , 3 ] , [ - 3 , 0 ] , [ - 3 , - 1 ] , [ - 2 , 0 ] , [ - 2 , 1 ] , [ - 3 , 1 ] , [ - 4 , 0 ] , [ - 4 , - 1 ] , [ - 4 , - 2 ] , [ - 2 , 2 ] , [ - 4 , - 4 ] , [ - 4 , - 5 ] , [ - 3 , - 4 ] , [ - 3 , - 3 ] , [ - 4 , - 3 ] , [ - 5 , - 4 ] , [ - 5 , - 5 ] , [ - 3 , - 5 ] , [ - 5 , - 3 ] ] ;
80460: LD_ADDR_VAR 0 29
80464: PUSH
80465: LD_INT 4
80467: PUSH
80468: LD_INT 0
80470: PUSH
80471: EMPTY
80472: LIST
80473: LIST
80474: PUSH
80475: LD_INT 4
80477: PUSH
80478: LD_INT 1
80480: NEG
80481: PUSH
80482: EMPTY
80483: LIST
80484: LIST
80485: PUSH
80486: LD_INT 5
80488: PUSH
80489: LD_INT 0
80491: PUSH
80492: EMPTY
80493: LIST
80494: LIST
80495: PUSH
80496: LD_INT 5
80498: PUSH
80499: LD_INT 1
80501: PUSH
80502: EMPTY
80503: LIST
80504: LIST
80505: PUSH
80506: LD_INT 4
80508: PUSH
80509: LD_INT 1
80511: PUSH
80512: EMPTY
80513: LIST
80514: LIST
80515: PUSH
80516: LD_INT 3
80518: PUSH
80519: LD_INT 0
80521: PUSH
80522: EMPTY
80523: LIST
80524: LIST
80525: PUSH
80526: LD_INT 3
80528: PUSH
80529: LD_INT 1
80531: NEG
80532: PUSH
80533: EMPTY
80534: LIST
80535: LIST
80536: PUSH
80537: LD_INT 3
80539: PUSH
80540: LD_INT 2
80542: NEG
80543: PUSH
80544: EMPTY
80545: LIST
80546: LIST
80547: PUSH
80548: LD_INT 5
80550: PUSH
80551: LD_INT 2
80553: PUSH
80554: EMPTY
80555: LIST
80556: LIST
80557: PUSH
80558: LD_INT 3
80560: PUSH
80561: LD_INT 3
80563: PUSH
80564: EMPTY
80565: LIST
80566: LIST
80567: PUSH
80568: LD_INT 3
80570: PUSH
80571: LD_INT 2
80573: PUSH
80574: EMPTY
80575: LIST
80576: LIST
80577: PUSH
80578: LD_INT 4
80580: PUSH
80581: LD_INT 3
80583: PUSH
80584: EMPTY
80585: LIST
80586: LIST
80587: PUSH
80588: LD_INT 4
80590: PUSH
80591: LD_INT 4
80593: PUSH
80594: EMPTY
80595: LIST
80596: LIST
80597: PUSH
80598: LD_INT 3
80600: PUSH
80601: LD_INT 4
80603: PUSH
80604: EMPTY
80605: LIST
80606: LIST
80607: PUSH
80608: LD_INT 2
80610: PUSH
80611: LD_INT 3
80613: PUSH
80614: EMPTY
80615: LIST
80616: LIST
80617: PUSH
80618: LD_INT 2
80620: PUSH
80621: LD_INT 2
80623: PUSH
80624: EMPTY
80625: LIST
80626: LIST
80627: PUSH
80628: LD_INT 4
80630: PUSH
80631: LD_INT 2
80633: PUSH
80634: EMPTY
80635: LIST
80636: LIST
80637: PUSH
80638: LD_INT 2
80640: PUSH
80641: LD_INT 4
80643: PUSH
80644: EMPTY
80645: LIST
80646: LIST
80647: PUSH
80648: LD_INT 0
80650: PUSH
80651: LD_INT 4
80653: PUSH
80654: EMPTY
80655: LIST
80656: LIST
80657: PUSH
80658: LD_INT 0
80660: PUSH
80661: LD_INT 3
80663: PUSH
80664: EMPTY
80665: LIST
80666: LIST
80667: PUSH
80668: LD_INT 1
80670: PUSH
80671: LD_INT 4
80673: PUSH
80674: EMPTY
80675: LIST
80676: LIST
80677: PUSH
80678: LD_INT 1
80680: PUSH
80681: LD_INT 5
80683: PUSH
80684: EMPTY
80685: LIST
80686: LIST
80687: PUSH
80688: LD_INT 0
80690: PUSH
80691: LD_INT 5
80693: PUSH
80694: EMPTY
80695: LIST
80696: LIST
80697: PUSH
80698: LD_INT 1
80700: NEG
80701: PUSH
80702: LD_INT 4
80704: PUSH
80705: EMPTY
80706: LIST
80707: LIST
80708: PUSH
80709: LD_INT 1
80711: NEG
80712: PUSH
80713: LD_INT 3
80715: PUSH
80716: EMPTY
80717: LIST
80718: LIST
80719: PUSH
80720: LD_INT 2
80722: PUSH
80723: LD_INT 5
80725: PUSH
80726: EMPTY
80727: LIST
80728: LIST
80729: PUSH
80730: LD_INT 2
80732: NEG
80733: PUSH
80734: LD_INT 3
80736: PUSH
80737: EMPTY
80738: LIST
80739: LIST
80740: PUSH
80741: LD_INT 3
80743: NEG
80744: PUSH
80745: LD_INT 0
80747: PUSH
80748: EMPTY
80749: LIST
80750: LIST
80751: PUSH
80752: LD_INT 3
80754: NEG
80755: PUSH
80756: LD_INT 1
80758: NEG
80759: PUSH
80760: EMPTY
80761: LIST
80762: LIST
80763: PUSH
80764: LD_INT 2
80766: NEG
80767: PUSH
80768: LD_INT 0
80770: PUSH
80771: EMPTY
80772: LIST
80773: LIST
80774: PUSH
80775: LD_INT 2
80777: NEG
80778: PUSH
80779: LD_INT 1
80781: PUSH
80782: EMPTY
80783: LIST
80784: LIST
80785: PUSH
80786: LD_INT 3
80788: NEG
80789: PUSH
80790: LD_INT 1
80792: PUSH
80793: EMPTY
80794: LIST
80795: LIST
80796: PUSH
80797: LD_INT 4
80799: NEG
80800: PUSH
80801: LD_INT 0
80803: PUSH
80804: EMPTY
80805: LIST
80806: LIST
80807: PUSH
80808: LD_INT 4
80810: NEG
80811: PUSH
80812: LD_INT 1
80814: NEG
80815: PUSH
80816: EMPTY
80817: LIST
80818: LIST
80819: PUSH
80820: LD_INT 4
80822: NEG
80823: PUSH
80824: LD_INT 2
80826: NEG
80827: PUSH
80828: EMPTY
80829: LIST
80830: LIST
80831: PUSH
80832: LD_INT 2
80834: NEG
80835: PUSH
80836: LD_INT 2
80838: PUSH
80839: EMPTY
80840: LIST
80841: LIST
80842: PUSH
80843: LD_INT 4
80845: NEG
80846: PUSH
80847: LD_INT 4
80849: NEG
80850: PUSH
80851: EMPTY
80852: LIST
80853: LIST
80854: PUSH
80855: LD_INT 4
80857: NEG
80858: PUSH
80859: LD_INT 5
80861: NEG
80862: PUSH
80863: EMPTY
80864: LIST
80865: LIST
80866: PUSH
80867: LD_INT 3
80869: NEG
80870: PUSH
80871: LD_INT 4
80873: NEG
80874: PUSH
80875: EMPTY
80876: LIST
80877: LIST
80878: PUSH
80879: LD_INT 3
80881: NEG
80882: PUSH
80883: LD_INT 3
80885: NEG
80886: PUSH
80887: EMPTY
80888: LIST
80889: LIST
80890: PUSH
80891: LD_INT 4
80893: NEG
80894: PUSH
80895: LD_INT 3
80897: NEG
80898: PUSH
80899: EMPTY
80900: LIST
80901: LIST
80902: PUSH
80903: LD_INT 5
80905: NEG
80906: PUSH
80907: LD_INT 4
80909: NEG
80910: PUSH
80911: EMPTY
80912: LIST
80913: LIST
80914: PUSH
80915: LD_INT 5
80917: NEG
80918: PUSH
80919: LD_INT 5
80921: NEG
80922: PUSH
80923: EMPTY
80924: LIST
80925: LIST
80926: PUSH
80927: LD_INT 3
80929: NEG
80930: PUSH
80931: LD_INT 5
80933: NEG
80934: PUSH
80935: EMPTY
80936: LIST
80937: LIST
80938: PUSH
80939: LD_INT 5
80941: NEG
80942: PUSH
80943: LD_INT 3
80945: NEG
80946: PUSH
80947: EMPTY
80948: LIST
80949: LIST
80950: PUSH
80951: EMPTY
80952: LIST
80953: LIST
80954: LIST
80955: LIST
80956: LIST
80957: LIST
80958: LIST
80959: LIST
80960: LIST
80961: LIST
80962: LIST
80963: LIST
80964: LIST
80965: LIST
80966: LIST
80967: LIST
80968: LIST
80969: LIST
80970: LIST
80971: LIST
80972: LIST
80973: LIST
80974: LIST
80975: LIST
80976: LIST
80977: LIST
80978: LIST
80979: LIST
80980: LIST
80981: LIST
80982: LIST
80983: LIST
80984: LIST
80985: LIST
80986: LIST
80987: LIST
80988: LIST
80989: LIST
80990: LIST
80991: LIST
80992: LIST
80993: LIST
80994: LIST
80995: LIST
80996: LIST
80997: ST_TO_ADDR
// Factory1 = [ [ 4 , 4 ] , [ 4 , 3 ] , [ 5 , 4 ] , [ 5 , 5 ] , [ 4 , 5 ] , [ 3 , 4 ] , [ 3 , 3 ] , [ 5 , 3 ] , [ 3 , 5 ] , [ 0 , 3 ] , [ 0 , 2 ] , [ 1 , 3 ] , [ 1 , 4 ] , [ 0 , 4 ] , [ - 1 , 3 ] , [ - 1 , 2 ] , [ 2 , 4 ] , [ - 2 , 2 ] , [ - 4 , 0 ] , [ - 4 , - 1 ] , [ - 3 , 0 ] , [ - 3 , 1 ] , [ - 4 , 1 ] , [ - 5 , 0 ] , [ - 5 , - 1 ] , [ - 5 , - 2 ] , [ - 3 , 2 ] , [ - 3 , - 3 ] , [ - 3 , - 4 ] , [ - 2 , - 3 ] , [ - 2 , - 2 ] , [ - 3 , - 2 ] , [ - 4 , - 3 ] , [ - 4 , - 4 ] , [ - 2 , - 4 ] , [ - 4 , - 2 ] , [ 0 , - 4 ] , [ 0 , - 5 ] , [ 1 , - 4 ] , [ 1 , - 3 ] , [ 0 , - 3 ] , [ - 1 , - 4 ] , [ - 1 , - 5 ] , [ 2 , - 3 ] , [ - 2 , - 5 ] ] ;
80998: LD_ADDR_VAR 0 30
81002: PUSH
81003: LD_INT 4
81005: PUSH
81006: LD_INT 4
81008: PUSH
81009: EMPTY
81010: LIST
81011: LIST
81012: PUSH
81013: LD_INT 4
81015: PUSH
81016: LD_INT 3
81018: PUSH
81019: EMPTY
81020: LIST
81021: LIST
81022: PUSH
81023: LD_INT 5
81025: PUSH
81026: LD_INT 4
81028: PUSH
81029: EMPTY
81030: LIST
81031: LIST
81032: PUSH
81033: LD_INT 5
81035: PUSH
81036: LD_INT 5
81038: PUSH
81039: EMPTY
81040: LIST
81041: LIST
81042: PUSH
81043: LD_INT 4
81045: PUSH
81046: LD_INT 5
81048: PUSH
81049: EMPTY
81050: LIST
81051: LIST
81052: PUSH
81053: LD_INT 3
81055: PUSH
81056: LD_INT 4
81058: PUSH
81059: EMPTY
81060: LIST
81061: LIST
81062: PUSH
81063: LD_INT 3
81065: PUSH
81066: LD_INT 3
81068: PUSH
81069: EMPTY
81070: LIST
81071: LIST
81072: PUSH
81073: LD_INT 5
81075: PUSH
81076: LD_INT 3
81078: PUSH
81079: EMPTY
81080: LIST
81081: LIST
81082: PUSH
81083: LD_INT 3
81085: PUSH
81086: LD_INT 5
81088: PUSH
81089: EMPTY
81090: LIST
81091: LIST
81092: PUSH
81093: LD_INT 0
81095: PUSH
81096: LD_INT 3
81098: PUSH
81099: EMPTY
81100: LIST
81101: LIST
81102: PUSH
81103: LD_INT 0
81105: PUSH
81106: LD_INT 2
81108: PUSH
81109: EMPTY
81110: LIST
81111: LIST
81112: PUSH
81113: LD_INT 1
81115: PUSH
81116: LD_INT 3
81118: PUSH
81119: EMPTY
81120: LIST
81121: LIST
81122: PUSH
81123: LD_INT 1
81125: PUSH
81126: LD_INT 4
81128: PUSH
81129: EMPTY
81130: LIST
81131: LIST
81132: PUSH
81133: LD_INT 0
81135: PUSH
81136: LD_INT 4
81138: PUSH
81139: EMPTY
81140: LIST
81141: LIST
81142: PUSH
81143: LD_INT 1
81145: NEG
81146: PUSH
81147: LD_INT 3
81149: PUSH
81150: EMPTY
81151: LIST
81152: LIST
81153: PUSH
81154: LD_INT 1
81156: NEG
81157: PUSH
81158: LD_INT 2
81160: PUSH
81161: EMPTY
81162: LIST
81163: LIST
81164: PUSH
81165: LD_INT 2
81167: PUSH
81168: LD_INT 4
81170: PUSH
81171: EMPTY
81172: LIST
81173: LIST
81174: PUSH
81175: LD_INT 2
81177: NEG
81178: PUSH
81179: LD_INT 2
81181: PUSH
81182: EMPTY
81183: LIST
81184: LIST
81185: PUSH
81186: LD_INT 4
81188: NEG
81189: PUSH
81190: LD_INT 0
81192: PUSH
81193: EMPTY
81194: LIST
81195: LIST
81196: PUSH
81197: LD_INT 4
81199: NEG
81200: PUSH
81201: LD_INT 1
81203: NEG
81204: PUSH
81205: EMPTY
81206: LIST
81207: LIST
81208: PUSH
81209: LD_INT 3
81211: NEG
81212: PUSH
81213: LD_INT 0
81215: PUSH
81216: EMPTY
81217: LIST
81218: LIST
81219: PUSH
81220: LD_INT 3
81222: NEG
81223: PUSH
81224: LD_INT 1
81226: PUSH
81227: EMPTY
81228: LIST
81229: LIST
81230: PUSH
81231: LD_INT 4
81233: NEG
81234: PUSH
81235: LD_INT 1
81237: PUSH
81238: EMPTY
81239: LIST
81240: LIST
81241: PUSH
81242: LD_INT 5
81244: NEG
81245: PUSH
81246: LD_INT 0
81248: PUSH
81249: EMPTY
81250: LIST
81251: LIST
81252: PUSH
81253: LD_INT 5
81255: NEG
81256: PUSH
81257: LD_INT 1
81259: NEG
81260: PUSH
81261: EMPTY
81262: LIST
81263: LIST
81264: PUSH
81265: LD_INT 5
81267: NEG
81268: PUSH
81269: LD_INT 2
81271: NEG
81272: PUSH
81273: EMPTY
81274: LIST
81275: LIST
81276: PUSH
81277: LD_INT 3
81279: NEG
81280: PUSH
81281: LD_INT 2
81283: PUSH
81284: EMPTY
81285: LIST
81286: LIST
81287: PUSH
81288: LD_INT 3
81290: NEG
81291: PUSH
81292: LD_INT 3
81294: NEG
81295: PUSH
81296: EMPTY
81297: LIST
81298: LIST
81299: PUSH
81300: LD_INT 3
81302: NEG
81303: PUSH
81304: LD_INT 4
81306: NEG
81307: PUSH
81308: EMPTY
81309: LIST
81310: LIST
81311: PUSH
81312: LD_INT 2
81314: NEG
81315: PUSH
81316: LD_INT 3
81318: NEG
81319: PUSH
81320: EMPTY
81321: LIST
81322: LIST
81323: PUSH
81324: LD_INT 2
81326: NEG
81327: PUSH
81328: LD_INT 2
81330: NEG
81331: PUSH
81332: EMPTY
81333: LIST
81334: LIST
81335: PUSH
81336: LD_INT 3
81338: NEG
81339: PUSH
81340: LD_INT 2
81342: NEG
81343: PUSH
81344: EMPTY
81345: LIST
81346: LIST
81347: PUSH
81348: LD_INT 4
81350: NEG
81351: PUSH
81352: LD_INT 3
81354: NEG
81355: PUSH
81356: EMPTY
81357: LIST
81358: LIST
81359: PUSH
81360: LD_INT 4
81362: NEG
81363: PUSH
81364: LD_INT 4
81366: NEG
81367: PUSH
81368: EMPTY
81369: LIST
81370: LIST
81371: PUSH
81372: LD_INT 2
81374: NEG
81375: PUSH
81376: LD_INT 4
81378: NEG
81379: PUSH
81380: EMPTY
81381: LIST
81382: LIST
81383: PUSH
81384: LD_INT 4
81386: NEG
81387: PUSH
81388: LD_INT 2
81390: NEG
81391: PUSH
81392: EMPTY
81393: LIST
81394: LIST
81395: PUSH
81396: LD_INT 0
81398: PUSH
81399: LD_INT 4
81401: NEG
81402: PUSH
81403: EMPTY
81404: LIST
81405: LIST
81406: PUSH
81407: LD_INT 0
81409: PUSH
81410: LD_INT 5
81412: NEG
81413: PUSH
81414: EMPTY
81415: LIST
81416: LIST
81417: PUSH
81418: LD_INT 1
81420: PUSH
81421: LD_INT 4
81423: NEG
81424: PUSH
81425: EMPTY
81426: LIST
81427: LIST
81428: PUSH
81429: LD_INT 1
81431: PUSH
81432: LD_INT 3
81434: NEG
81435: PUSH
81436: EMPTY
81437: LIST
81438: LIST
81439: PUSH
81440: LD_INT 0
81442: PUSH
81443: LD_INT 3
81445: NEG
81446: PUSH
81447: EMPTY
81448: LIST
81449: LIST
81450: PUSH
81451: LD_INT 1
81453: NEG
81454: PUSH
81455: LD_INT 4
81457: NEG
81458: PUSH
81459: EMPTY
81460: LIST
81461: LIST
81462: PUSH
81463: LD_INT 1
81465: NEG
81466: PUSH
81467: LD_INT 5
81469: NEG
81470: PUSH
81471: EMPTY
81472: LIST
81473: LIST
81474: PUSH
81475: LD_INT 2
81477: PUSH
81478: LD_INT 3
81480: NEG
81481: PUSH
81482: EMPTY
81483: LIST
81484: LIST
81485: PUSH
81486: LD_INT 2
81488: NEG
81489: PUSH
81490: LD_INT 5
81492: NEG
81493: PUSH
81494: EMPTY
81495: LIST
81496: LIST
81497: PUSH
81498: EMPTY
81499: LIST
81500: LIST
81501: LIST
81502: LIST
81503: LIST
81504: LIST
81505: LIST
81506: LIST
81507: LIST
81508: LIST
81509: LIST
81510: LIST
81511: LIST
81512: LIST
81513: LIST
81514: LIST
81515: LIST
81516: LIST
81517: LIST
81518: LIST
81519: LIST
81520: LIST
81521: LIST
81522: LIST
81523: LIST
81524: LIST
81525: LIST
81526: LIST
81527: LIST
81528: LIST
81529: LIST
81530: LIST
81531: LIST
81532: LIST
81533: LIST
81534: LIST
81535: LIST
81536: LIST
81537: LIST
81538: LIST
81539: LIST
81540: LIST
81541: LIST
81542: LIST
81543: LIST
81544: ST_TO_ADDR
// Factory2 = [ [ 0 , 4 ] , [ 0 , 3 ] , [ 1 , 4 ] , [ 1 , 5 ] , [ 0 , 5 ] , [ - 1 , 4 ] , [ - 1 , 3 ] , [ 2 , 5 ] , [ - 2 , 3 ] , [ - 3 , 0 ] , [ - 3 , - 1 ] , [ - 2 , 0 ] , [ - 2 , 1 ] , [ - 3 , 1 ] , [ - 4 , 0 ] , [ - 4 , - 1 ] , [ - 4 , - 2 ] , [ - 2 , 2 ] , [ - 4 , - 4 ] , [ - 4 , - 5 ] , [ - 3 , - 4 ] , [ - 3 , - 3 ] , [ - 4 , - 3 ] , [ - 5 , - 4 ] , [ - 5 , - 5 ] , [ - 3 , - 5 ] , [ - 5 , - 3 ] , [ 0 , - 3 ] , [ 0 , - 4 ] , [ 1 , - 3 ] , [ 1 , - 2 ] , [ 0 , - 2 ] , [ - 1 , - 3 ] , [ - 1 , - 4 ] , [ 2 , - 2 ] , [ - 2 , - 4 ] , [ 4 , 0 ] , [ 4 , - 1 ] , [ 5 , 0 ] , [ 5 , 1 ] , [ 4 , 1 ] , [ 3 , 0 ] , [ 3 , - 1 ] , [ 3 , - 2 ] , [ 5 , 2 ] ] ;
81545: LD_ADDR_VAR 0 31
81549: PUSH
81550: LD_INT 0
81552: PUSH
81553: LD_INT 4
81555: PUSH
81556: EMPTY
81557: LIST
81558: LIST
81559: PUSH
81560: LD_INT 0
81562: PUSH
81563: LD_INT 3
81565: PUSH
81566: EMPTY
81567: LIST
81568: LIST
81569: PUSH
81570: LD_INT 1
81572: PUSH
81573: LD_INT 4
81575: PUSH
81576: EMPTY
81577: LIST
81578: LIST
81579: PUSH
81580: LD_INT 1
81582: PUSH
81583: LD_INT 5
81585: PUSH
81586: EMPTY
81587: LIST
81588: LIST
81589: PUSH
81590: LD_INT 0
81592: PUSH
81593: LD_INT 5
81595: PUSH
81596: EMPTY
81597: LIST
81598: LIST
81599: PUSH
81600: LD_INT 1
81602: NEG
81603: PUSH
81604: LD_INT 4
81606: PUSH
81607: EMPTY
81608: LIST
81609: LIST
81610: PUSH
81611: LD_INT 1
81613: NEG
81614: PUSH
81615: LD_INT 3
81617: PUSH
81618: EMPTY
81619: LIST
81620: LIST
81621: PUSH
81622: LD_INT 2
81624: PUSH
81625: LD_INT 5
81627: PUSH
81628: EMPTY
81629: LIST
81630: LIST
81631: PUSH
81632: LD_INT 2
81634: NEG
81635: PUSH
81636: LD_INT 3
81638: PUSH
81639: EMPTY
81640: LIST
81641: LIST
81642: PUSH
81643: LD_INT 3
81645: NEG
81646: PUSH
81647: LD_INT 0
81649: PUSH
81650: EMPTY
81651: LIST
81652: LIST
81653: PUSH
81654: LD_INT 3
81656: NEG
81657: PUSH
81658: LD_INT 1
81660: NEG
81661: PUSH
81662: EMPTY
81663: LIST
81664: LIST
81665: PUSH
81666: LD_INT 2
81668: NEG
81669: PUSH
81670: LD_INT 0
81672: PUSH
81673: EMPTY
81674: LIST
81675: LIST
81676: PUSH
81677: LD_INT 2
81679: NEG
81680: PUSH
81681: LD_INT 1
81683: PUSH
81684: EMPTY
81685: LIST
81686: LIST
81687: PUSH
81688: LD_INT 3
81690: NEG
81691: PUSH
81692: LD_INT 1
81694: PUSH
81695: EMPTY
81696: LIST
81697: LIST
81698: PUSH
81699: LD_INT 4
81701: NEG
81702: PUSH
81703: LD_INT 0
81705: PUSH
81706: EMPTY
81707: LIST
81708: LIST
81709: PUSH
81710: LD_INT 4
81712: NEG
81713: PUSH
81714: LD_INT 1
81716: NEG
81717: PUSH
81718: EMPTY
81719: LIST
81720: LIST
81721: PUSH
81722: LD_INT 4
81724: NEG
81725: PUSH
81726: LD_INT 2
81728: NEG
81729: PUSH
81730: EMPTY
81731: LIST
81732: LIST
81733: PUSH
81734: LD_INT 2
81736: NEG
81737: PUSH
81738: LD_INT 2
81740: PUSH
81741: EMPTY
81742: LIST
81743: LIST
81744: PUSH
81745: LD_INT 4
81747: NEG
81748: PUSH
81749: LD_INT 4
81751: NEG
81752: PUSH
81753: EMPTY
81754: LIST
81755: LIST
81756: PUSH
81757: LD_INT 4
81759: NEG
81760: PUSH
81761: LD_INT 5
81763: NEG
81764: PUSH
81765: EMPTY
81766: LIST
81767: LIST
81768: PUSH
81769: LD_INT 3
81771: NEG
81772: PUSH
81773: LD_INT 4
81775: NEG
81776: PUSH
81777: EMPTY
81778: LIST
81779: LIST
81780: PUSH
81781: LD_INT 3
81783: NEG
81784: PUSH
81785: LD_INT 3
81787: NEG
81788: PUSH
81789: EMPTY
81790: LIST
81791: LIST
81792: PUSH
81793: LD_INT 4
81795: NEG
81796: PUSH
81797: LD_INT 3
81799: NEG
81800: PUSH
81801: EMPTY
81802: LIST
81803: LIST
81804: PUSH
81805: LD_INT 5
81807: NEG
81808: PUSH
81809: LD_INT 4
81811: NEG
81812: PUSH
81813: EMPTY
81814: LIST
81815: LIST
81816: PUSH
81817: LD_INT 5
81819: NEG
81820: PUSH
81821: LD_INT 5
81823: NEG
81824: PUSH
81825: EMPTY
81826: LIST
81827: LIST
81828: PUSH
81829: LD_INT 3
81831: NEG
81832: PUSH
81833: LD_INT 5
81835: NEG
81836: PUSH
81837: EMPTY
81838: LIST
81839: LIST
81840: PUSH
81841: LD_INT 5
81843: NEG
81844: PUSH
81845: LD_INT 3
81847: NEG
81848: PUSH
81849: EMPTY
81850: LIST
81851: LIST
81852: PUSH
81853: LD_INT 0
81855: PUSH
81856: LD_INT 3
81858: NEG
81859: PUSH
81860: EMPTY
81861: LIST
81862: LIST
81863: PUSH
81864: LD_INT 0
81866: PUSH
81867: LD_INT 4
81869: NEG
81870: PUSH
81871: EMPTY
81872: LIST
81873: LIST
81874: PUSH
81875: LD_INT 1
81877: PUSH
81878: LD_INT 3
81880: NEG
81881: PUSH
81882: EMPTY
81883: LIST
81884: LIST
81885: PUSH
81886: LD_INT 1
81888: PUSH
81889: LD_INT 2
81891: NEG
81892: PUSH
81893: EMPTY
81894: LIST
81895: LIST
81896: PUSH
81897: LD_INT 0
81899: PUSH
81900: LD_INT 2
81902: NEG
81903: PUSH
81904: EMPTY
81905: LIST
81906: LIST
81907: PUSH
81908: LD_INT 1
81910: NEG
81911: PUSH
81912: LD_INT 3
81914: NEG
81915: PUSH
81916: EMPTY
81917: LIST
81918: LIST
81919: PUSH
81920: LD_INT 1
81922: NEG
81923: PUSH
81924: LD_INT 4
81926: NEG
81927: PUSH
81928: EMPTY
81929: LIST
81930: LIST
81931: PUSH
81932: LD_INT 2
81934: PUSH
81935: LD_INT 2
81937: NEG
81938: PUSH
81939: EMPTY
81940: LIST
81941: LIST
81942: PUSH
81943: LD_INT 2
81945: NEG
81946: PUSH
81947: LD_INT 4
81949: NEG
81950: PUSH
81951: EMPTY
81952: LIST
81953: LIST
81954: PUSH
81955: LD_INT 4
81957: PUSH
81958: LD_INT 0
81960: PUSH
81961: EMPTY
81962: LIST
81963: LIST
81964: PUSH
81965: LD_INT 4
81967: PUSH
81968: LD_INT 1
81970: NEG
81971: PUSH
81972: EMPTY
81973: LIST
81974: LIST
81975: PUSH
81976: LD_INT 5
81978: PUSH
81979: LD_INT 0
81981: PUSH
81982: EMPTY
81983: LIST
81984: LIST
81985: PUSH
81986: LD_INT 5
81988: PUSH
81989: LD_INT 1
81991: PUSH
81992: EMPTY
81993: LIST
81994: LIST
81995: PUSH
81996: LD_INT 4
81998: PUSH
81999: LD_INT 1
82001: PUSH
82002: EMPTY
82003: LIST
82004: LIST
82005: PUSH
82006: LD_INT 3
82008: PUSH
82009: LD_INT 0
82011: PUSH
82012: EMPTY
82013: LIST
82014: LIST
82015: PUSH
82016: LD_INT 3
82018: PUSH
82019: LD_INT 1
82021: NEG
82022: PUSH
82023: EMPTY
82024: LIST
82025: LIST
82026: PUSH
82027: LD_INT 3
82029: PUSH
82030: LD_INT 2
82032: NEG
82033: PUSH
82034: EMPTY
82035: LIST
82036: LIST
82037: PUSH
82038: LD_INT 5
82040: PUSH
82041: LD_INT 2
82043: PUSH
82044: EMPTY
82045: LIST
82046: LIST
82047: PUSH
82048: EMPTY
82049: LIST
82050: LIST
82051: LIST
82052: LIST
82053: LIST
82054: LIST
82055: LIST
82056: LIST
82057: LIST
82058: LIST
82059: LIST
82060: LIST
82061: LIST
82062: LIST
82063: LIST
82064: LIST
82065: LIST
82066: LIST
82067: LIST
82068: LIST
82069: LIST
82070: LIST
82071: LIST
82072: LIST
82073: LIST
82074: LIST
82075: LIST
82076: LIST
82077: LIST
82078: LIST
82079: LIST
82080: LIST
82081: LIST
82082: LIST
82083: LIST
82084: LIST
82085: LIST
82086: LIST
82087: LIST
82088: LIST
82089: LIST
82090: LIST
82091: LIST
82092: LIST
82093: LIST
82094: ST_TO_ADDR
// Factory3 = [ [ - 4 , 0 ] , [ - 4 , - 1 ] , [ - 3 , 0 ] , [ - 3 , 1 ] , [ - 4 , 1 ] , [ - 5 , 0 ] , [ - 5 , - 1 ] , [ - 5 , - 2 ] , [ - 3 , 2 ] , [ - 3 , - 3 ] , [ - 3 , - 4 ] , [ - 2 , - 3 ] , [ - 2 , - 2 ] , [ - 3 , - 2 ] , [ - 4 , - 3 ] , [ - 4 , - 4 ] , [ - 2 , - 4 ] , [ - 4 , - 2 ] , [ 0 , - 4 ] , [ 0 , - 5 ] , [ 1 , - 4 ] , [ 1 , - 3 ] , [ 0 , - 3 ] , [ - 1 , - 4 ] , [ - 1 , - 5 ] , [ 2 , - 3 ] , [ - 2 , - 5 ] , [ 3 , 0 ] , [ 3 , - 1 ] , [ 4 , 0 ] , [ 4 , 1 ] , [ 3 , 1 ] , [ 2 , 0 ] , [ 2 , - 1 ] , [ 2 , - 2 ] , [ 4 , 2 ] , [ 4 , 4 ] , [ 4 , 3 ] , [ 5 , 4 ] , [ 5 , 5 ] , [ 4 , 5 ] , [ 3 , 4 ] , [ 3 , 3 ] , [ 5 , 3 ] , [ 3 , 5 ] ] ;
82095: LD_ADDR_VAR 0 32
82099: PUSH
82100: LD_INT 4
82102: NEG
82103: PUSH
82104: LD_INT 0
82106: PUSH
82107: EMPTY
82108: LIST
82109: LIST
82110: PUSH
82111: LD_INT 4
82113: NEG
82114: PUSH
82115: LD_INT 1
82117: NEG
82118: PUSH
82119: EMPTY
82120: LIST
82121: LIST
82122: PUSH
82123: LD_INT 3
82125: NEG
82126: PUSH
82127: LD_INT 0
82129: PUSH
82130: EMPTY
82131: LIST
82132: LIST
82133: PUSH
82134: LD_INT 3
82136: NEG
82137: PUSH
82138: LD_INT 1
82140: PUSH
82141: EMPTY
82142: LIST
82143: LIST
82144: PUSH
82145: LD_INT 4
82147: NEG
82148: PUSH
82149: LD_INT 1
82151: PUSH
82152: EMPTY
82153: LIST
82154: LIST
82155: PUSH
82156: LD_INT 5
82158: NEG
82159: PUSH
82160: LD_INT 0
82162: PUSH
82163: EMPTY
82164: LIST
82165: LIST
82166: PUSH
82167: LD_INT 5
82169: NEG
82170: PUSH
82171: LD_INT 1
82173: NEG
82174: PUSH
82175: EMPTY
82176: LIST
82177: LIST
82178: PUSH
82179: LD_INT 5
82181: NEG
82182: PUSH
82183: LD_INT 2
82185: NEG
82186: PUSH
82187: EMPTY
82188: LIST
82189: LIST
82190: PUSH
82191: LD_INT 3
82193: NEG
82194: PUSH
82195: LD_INT 2
82197: PUSH
82198: EMPTY
82199: LIST
82200: LIST
82201: PUSH
82202: LD_INT 3
82204: NEG
82205: PUSH
82206: LD_INT 3
82208: NEG
82209: PUSH
82210: EMPTY
82211: LIST
82212: LIST
82213: PUSH
82214: LD_INT 3
82216: NEG
82217: PUSH
82218: LD_INT 4
82220: NEG
82221: PUSH
82222: EMPTY
82223: LIST
82224: LIST
82225: PUSH
82226: LD_INT 2
82228: NEG
82229: PUSH
82230: LD_INT 3
82232: NEG
82233: PUSH
82234: EMPTY
82235: LIST
82236: LIST
82237: PUSH
82238: LD_INT 2
82240: NEG
82241: PUSH
82242: LD_INT 2
82244: NEG
82245: PUSH
82246: EMPTY
82247: LIST
82248: LIST
82249: PUSH
82250: LD_INT 3
82252: NEG
82253: PUSH
82254: LD_INT 2
82256: NEG
82257: PUSH
82258: EMPTY
82259: LIST
82260: LIST
82261: PUSH
82262: LD_INT 4
82264: NEG
82265: PUSH
82266: LD_INT 3
82268: NEG
82269: PUSH
82270: EMPTY
82271: LIST
82272: LIST
82273: PUSH
82274: LD_INT 4
82276: NEG
82277: PUSH
82278: LD_INT 4
82280: NEG
82281: PUSH
82282: EMPTY
82283: LIST
82284: LIST
82285: PUSH
82286: LD_INT 2
82288: NEG
82289: PUSH
82290: LD_INT 4
82292: NEG
82293: PUSH
82294: EMPTY
82295: LIST
82296: LIST
82297: PUSH
82298: LD_INT 4
82300: NEG
82301: PUSH
82302: LD_INT 2
82304: NEG
82305: PUSH
82306: EMPTY
82307: LIST
82308: LIST
82309: PUSH
82310: LD_INT 0
82312: PUSH
82313: LD_INT 4
82315: NEG
82316: PUSH
82317: EMPTY
82318: LIST
82319: LIST
82320: PUSH
82321: LD_INT 0
82323: PUSH
82324: LD_INT 5
82326: NEG
82327: PUSH
82328: EMPTY
82329: LIST
82330: LIST
82331: PUSH
82332: LD_INT 1
82334: PUSH
82335: LD_INT 4
82337: NEG
82338: PUSH
82339: EMPTY
82340: LIST
82341: LIST
82342: PUSH
82343: LD_INT 1
82345: PUSH
82346: LD_INT 3
82348: NEG
82349: PUSH
82350: EMPTY
82351: LIST
82352: LIST
82353: PUSH
82354: LD_INT 0
82356: PUSH
82357: LD_INT 3
82359: NEG
82360: PUSH
82361: EMPTY
82362: LIST
82363: LIST
82364: PUSH
82365: LD_INT 1
82367: NEG
82368: PUSH
82369: LD_INT 4
82371: NEG
82372: PUSH
82373: EMPTY
82374: LIST
82375: LIST
82376: PUSH
82377: LD_INT 1
82379: NEG
82380: PUSH
82381: LD_INT 5
82383: NEG
82384: PUSH
82385: EMPTY
82386: LIST
82387: LIST
82388: PUSH
82389: LD_INT 2
82391: PUSH
82392: LD_INT 3
82394: NEG
82395: PUSH
82396: EMPTY
82397: LIST
82398: LIST
82399: PUSH
82400: LD_INT 2
82402: NEG
82403: PUSH
82404: LD_INT 5
82406: NEG
82407: PUSH
82408: EMPTY
82409: LIST
82410: LIST
82411: PUSH
82412: LD_INT 3
82414: PUSH
82415: LD_INT 0
82417: PUSH
82418: EMPTY
82419: LIST
82420: LIST
82421: PUSH
82422: LD_INT 3
82424: PUSH
82425: LD_INT 1
82427: NEG
82428: PUSH
82429: EMPTY
82430: LIST
82431: LIST
82432: PUSH
82433: LD_INT 4
82435: PUSH
82436: LD_INT 0
82438: PUSH
82439: EMPTY
82440: LIST
82441: LIST
82442: PUSH
82443: LD_INT 4
82445: PUSH
82446: LD_INT 1
82448: PUSH
82449: EMPTY
82450: LIST
82451: LIST
82452: PUSH
82453: LD_INT 3
82455: PUSH
82456: LD_INT 1
82458: PUSH
82459: EMPTY
82460: LIST
82461: LIST
82462: PUSH
82463: LD_INT 2
82465: PUSH
82466: LD_INT 0
82468: PUSH
82469: EMPTY
82470: LIST
82471: LIST
82472: PUSH
82473: LD_INT 2
82475: PUSH
82476: LD_INT 1
82478: NEG
82479: PUSH
82480: EMPTY
82481: LIST
82482: LIST
82483: PUSH
82484: LD_INT 2
82486: PUSH
82487: LD_INT 2
82489: NEG
82490: PUSH
82491: EMPTY
82492: LIST
82493: LIST
82494: PUSH
82495: LD_INT 4
82497: PUSH
82498: LD_INT 2
82500: PUSH
82501: EMPTY
82502: LIST
82503: LIST
82504: PUSH
82505: LD_INT 4
82507: PUSH
82508: LD_INT 4
82510: PUSH
82511: EMPTY
82512: LIST
82513: LIST
82514: PUSH
82515: LD_INT 4
82517: PUSH
82518: LD_INT 3
82520: PUSH
82521: EMPTY
82522: LIST
82523: LIST
82524: PUSH
82525: LD_INT 5
82527: PUSH
82528: LD_INT 4
82530: PUSH
82531: EMPTY
82532: LIST
82533: LIST
82534: PUSH
82535: LD_INT 5
82537: PUSH
82538: LD_INT 5
82540: PUSH
82541: EMPTY
82542: LIST
82543: LIST
82544: PUSH
82545: LD_INT 4
82547: PUSH
82548: LD_INT 5
82550: PUSH
82551: EMPTY
82552: LIST
82553: LIST
82554: PUSH
82555: LD_INT 3
82557: PUSH
82558: LD_INT 4
82560: PUSH
82561: EMPTY
82562: LIST
82563: LIST
82564: PUSH
82565: LD_INT 3
82567: PUSH
82568: LD_INT 3
82570: PUSH
82571: EMPTY
82572: LIST
82573: LIST
82574: PUSH
82575: LD_INT 5
82577: PUSH
82578: LD_INT 3
82580: PUSH
82581: EMPTY
82582: LIST
82583: LIST
82584: PUSH
82585: LD_INT 3
82587: PUSH
82588: LD_INT 5
82590: PUSH
82591: EMPTY
82592: LIST
82593: LIST
82594: PUSH
82595: EMPTY
82596: LIST
82597: LIST
82598: LIST
82599: LIST
82600: LIST
82601: LIST
82602: LIST
82603: LIST
82604: LIST
82605: LIST
82606: LIST
82607: LIST
82608: LIST
82609: LIST
82610: LIST
82611: LIST
82612: LIST
82613: LIST
82614: LIST
82615: LIST
82616: LIST
82617: LIST
82618: LIST
82619: LIST
82620: LIST
82621: LIST
82622: LIST
82623: LIST
82624: LIST
82625: LIST
82626: LIST
82627: LIST
82628: LIST
82629: LIST
82630: LIST
82631: LIST
82632: LIST
82633: LIST
82634: LIST
82635: LIST
82636: LIST
82637: LIST
82638: LIST
82639: LIST
82640: LIST
82641: ST_TO_ADDR
// Factory4 = [ [ - 4 , - 4 ] , [ - 4 , - 5 ] , [ - 3 , - 4 ] , [ - 3 , - 3 ] , [ - 4 , - 3 ] , [ - 5 , - 4 ] , [ - 5 , - 5 ] , [ - 3 , - 5 ] , [ - 5 , - 3 ] , [ 0 , - 3 ] , [ 0 , - 4 ] , [ 1 , - 3 ] , [ 1 , - 2 ] , [ 0 , - 2 ] , [ - 1 , - 3 ] , [ - 1 , - 4 ] , [ 2 , - 2 ] , [ - 2 , - 4 ] , [ 4 , 0 ] , [ 4 , - 1 ] , [ 5 , 0 ] , [ 5 , 1 ] , [ 4 , 1 ] , [ 3 , 0 ] , [ 3 , - 1 ] , [ 3 , - 2 ] , [ 5 , 2 ] , [ 3 , 3 ] , [ 3 , 2 ] , [ 4 , 3 ] , [ 4 , 4 ] , [ 3 , 4 ] , [ 2 , 3 ] , [ 2 , 2 ] , [ 4 , 2 ] , [ 2 , 4 ] , [ 0 , 4 ] , [ 0 , 3 ] , [ 1 , 4 ] , [ 1 , 5 ] , [ 0 , 5 ] , [ - 1 , 4 ] , [ - 1 , 3 ] , [ 2 , 5 ] , [ - 2 , 3 ] ] ;
82642: LD_ADDR_VAR 0 33
82646: PUSH
82647: LD_INT 4
82649: NEG
82650: PUSH
82651: LD_INT 4
82653: NEG
82654: PUSH
82655: EMPTY
82656: LIST
82657: LIST
82658: PUSH
82659: LD_INT 4
82661: NEG
82662: PUSH
82663: LD_INT 5
82665: NEG
82666: PUSH
82667: EMPTY
82668: LIST
82669: LIST
82670: PUSH
82671: LD_INT 3
82673: NEG
82674: PUSH
82675: LD_INT 4
82677: NEG
82678: PUSH
82679: EMPTY
82680: LIST
82681: LIST
82682: PUSH
82683: LD_INT 3
82685: NEG
82686: PUSH
82687: LD_INT 3
82689: NEG
82690: PUSH
82691: EMPTY
82692: LIST
82693: LIST
82694: PUSH
82695: LD_INT 4
82697: NEG
82698: PUSH
82699: LD_INT 3
82701: NEG
82702: PUSH
82703: EMPTY
82704: LIST
82705: LIST
82706: PUSH
82707: LD_INT 5
82709: NEG
82710: PUSH
82711: LD_INT 4
82713: NEG
82714: PUSH
82715: EMPTY
82716: LIST
82717: LIST
82718: PUSH
82719: LD_INT 5
82721: NEG
82722: PUSH
82723: LD_INT 5
82725: NEG
82726: PUSH
82727: EMPTY
82728: LIST
82729: LIST
82730: PUSH
82731: LD_INT 3
82733: NEG
82734: PUSH
82735: LD_INT 5
82737: NEG
82738: PUSH
82739: EMPTY
82740: LIST
82741: LIST
82742: PUSH
82743: LD_INT 5
82745: NEG
82746: PUSH
82747: LD_INT 3
82749: NEG
82750: PUSH
82751: EMPTY
82752: LIST
82753: LIST
82754: PUSH
82755: LD_INT 0
82757: PUSH
82758: LD_INT 3
82760: NEG
82761: PUSH
82762: EMPTY
82763: LIST
82764: LIST
82765: PUSH
82766: LD_INT 0
82768: PUSH
82769: LD_INT 4
82771: NEG
82772: PUSH
82773: EMPTY
82774: LIST
82775: LIST
82776: PUSH
82777: LD_INT 1
82779: PUSH
82780: LD_INT 3
82782: NEG
82783: PUSH
82784: EMPTY
82785: LIST
82786: LIST
82787: PUSH
82788: LD_INT 1
82790: PUSH
82791: LD_INT 2
82793: NEG
82794: PUSH
82795: EMPTY
82796: LIST
82797: LIST
82798: PUSH
82799: LD_INT 0
82801: PUSH
82802: LD_INT 2
82804: NEG
82805: PUSH
82806: EMPTY
82807: LIST
82808: LIST
82809: PUSH
82810: LD_INT 1
82812: NEG
82813: PUSH
82814: LD_INT 3
82816: NEG
82817: PUSH
82818: EMPTY
82819: LIST
82820: LIST
82821: PUSH
82822: LD_INT 1
82824: NEG
82825: PUSH
82826: LD_INT 4
82828: NEG
82829: PUSH
82830: EMPTY
82831: LIST
82832: LIST
82833: PUSH
82834: LD_INT 2
82836: PUSH
82837: LD_INT 2
82839: NEG
82840: PUSH
82841: EMPTY
82842: LIST
82843: LIST
82844: PUSH
82845: LD_INT 2
82847: NEG
82848: PUSH
82849: LD_INT 4
82851: NEG
82852: PUSH
82853: EMPTY
82854: LIST
82855: LIST
82856: PUSH
82857: LD_INT 4
82859: PUSH
82860: LD_INT 0
82862: PUSH
82863: EMPTY
82864: LIST
82865: LIST
82866: PUSH
82867: LD_INT 4
82869: PUSH
82870: LD_INT 1
82872: NEG
82873: PUSH
82874: EMPTY
82875: LIST
82876: LIST
82877: PUSH
82878: LD_INT 5
82880: PUSH
82881: LD_INT 0
82883: PUSH
82884: EMPTY
82885: LIST
82886: LIST
82887: PUSH
82888: LD_INT 5
82890: PUSH
82891: LD_INT 1
82893: PUSH
82894: EMPTY
82895: LIST
82896: LIST
82897: PUSH
82898: LD_INT 4
82900: PUSH
82901: LD_INT 1
82903: PUSH
82904: EMPTY
82905: LIST
82906: LIST
82907: PUSH
82908: LD_INT 3
82910: PUSH
82911: LD_INT 0
82913: PUSH
82914: EMPTY
82915: LIST
82916: LIST
82917: PUSH
82918: LD_INT 3
82920: PUSH
82921: LD_INT 1
82923: NEG
82924: PUSH
82925: EMPTY
82926: LIST
82927: LIST
82928: PUSH
82929: LD_INT 3
82931: PUSH
82932: LD_INT 2
82934: NEG
82935: PUSH
82936: EMPTY
82937: LIST
82938: LIST
82939: PUSH
82940: LD_INT 5
82942: PUSH
82943: LD_INT 2
82945: PUSH
82946: EMPTY
82947: LIST
82948: LIST
82949: PUSH
82950: LD_INT 3
82952: PUSH
82953: LD_INT 3
82955: PUSH
82956: EMPTY
82957: LIST
82958: LIST
82959: PUSH
82960: LD_INT 3
82962: PUSH
82963: LD_INT 2
82965: PUSH
82966: EMPTY
82967: LIST
82968: LIST
82969: PUSH
82970: LD_INT 4
82972: PUSH
82973: LD_INT 3
82975: PUSH
82976: EMPTY
82977: LIST
82978: LIST
82979: PUSH
82980: LD_INT 4
82982: PUSH
82983: LD_INT 4
82985: PUSH
82986: EMPTY
82987: LIST
82988: LIST
82989: PUSH
82990: LD_INT 3
82992: PUSH
82993: LD_INT 4
82995: PUSH
82996: EMPTY
82997: LIST
82998: LIST
82999: PUSH
83000: LD_INT 2
83002: PUSH
83003: LD_INT 3
83005: PUSH
83006: EMPTY
83007: LIST
83008: LIST
83009: PUSH
83010: LD_INT 2
83012: PUSH
83013: LD_INT 2
83015: PUSH
83016: EMPTY
83017: LIST
83018: LIST
83019: PUSH
83020: LD_INT 4
83022: PUSH
83023: LD_INT 2
83025: PUSH
83026: EMPTY
83027: LIST
83028: LIST
83029: PUSH
83030: LD_INT 2
83032: PUSH
83033: LD_INT 4
83035: PUSH
83036: EMPTY
83037: LIST
83038: LIST
83039: PUSH
83040: LD_INT 0
83042: PUSH
83043: LD_INT 4
83045: PUSH
83046: EMPTY
83047: LIST
83048: LIST
83049: PUSH
83050: LD_INT 0
83052: PUSH
83053: LD_INT 3
83055: PUSH
83056: EMPTY
83057: LIST
83058: LIST
83059: PUSH
83060: LD_INT 1
83062: PUSH
83063: LD_INT 4
83065: PUSH
83066: EMPTY
83067: LIST
83068: LIST
83069: PUSH
83070: LD_INT 1
83072: PUSH
83073: LD_INT 5
83075: PUSH
83076: EMPTY
83077: LIST
83078: LIST
83079: PUSH
83080: LD_INT 0
83082: PUSH
83083: LD_INT 5
83085: PUSH
83086: EMPTY
83087: LIST
83088: LIST
83089: PUSH
83090: LD_INT 1
83092: NEG
83093: PUSH
83094: LD_INT 4
83096: PUSH
83097: EMPTY
83098: LIST
83099: LIST
83100: PUSH
83101: LD_INT 1
83103: NEG
83104: PUSH
83105: LD_INT 3
83107: PUSH
83108: EMPTY
83109: LIST
83110: LIST
83111: PUSH
83112: LD_INT 2
83114: PUSH
83115: LD_INT 5
83117: PUSH
83118: EMPTY
83119: LIST
83120: LIST
83121: PUSH
83122: LD_INT 2
83124: NEG
83125: PUSH
83126: LD_INT 3
83128: PUSH
83129: EMPTY
83130: LIST
83131: LIST
83132: PUSH
83133: EMPTY
83134: LIST
83135: LIST
83136: LIST
83137: LIST
83138: LIST
83139: LIST
83140: LIST
83141: LIST
83142: LIST
83143: LIST
83144: LIST
83145: LIST
83146: LIST
83147: LIST
83148: LIST
83149: LIST
83150: LIST
83151: LIST
83152: LIST
83153: LIST
83154: LIST
83155: LIST
83156: LIST
83157: LIST
83158: LIST
83159: LIST
83160: LIST
83161: LIST
83162: LIST
83163: LIST
83164: LIST
83165: LIST
83166: LIST
83167: LIST
83168: LIST
83169: LIST
83170: LIST
83171: LIST
83172: LIST
83173: LIST
83174: LIST
83175: LIST
83176: LIST
83177: LIST
83178: LIST
83179: ST_TO_ADDR
// Factory5 = [ [ 0 , - 4 ] , [ 0 , - 5 ] , [ 1 , - 4 ] , [ 1 , - 3 ] , [ 0 , - 3 ] , [ - 1 , - 4 ] , [ - 1 , - 5 ] , [ 2 , - 3 ] , [ - 2 , - 5 ] , [ 3 , 0 ] , [ 3 , - 1 ] , [ 4 , 0 ] , [ 4 , 1 ] , [ 3 , 1 ] , [ 2 , 0 ] , [ 2 , - 1 ] , [ 2 , - 2 ] , [ 4 , 2 ] , [ 4 , 4 ] , [ 4 , 3 ] , [ 5 , 4 ] , [ 5 , 5 ] , [ 4 , 5 ] , [ 3 , 4 ] , [ 3 , 3 ] , [ 5 , 3 ] , [ 3 , 5 ] , [ 0 , 3 ] , [ 0 , 2 ] , [ 1 , 3 ] , [ 1 , 4 ] , [ 0 , 4 ] , [ - 1 , 3 ] , [ - 1 , 2 ] , [ 2 , 4 ] , [ - 2 , 2 ] , [ - 4 , 0 ] , [ - 4 , - 1 ] , [ - 3 , 0 ] , [ - 3 , 1 ] , [ - 4 , 1 ] , [ - 5 , 0 ] , [ - 5 , - 1 ] , [ - 5 , - 2 ] , [ - 3 , 2 ] ] ;
83180: LD_ADDR_VAR 0 34
83184: PUSH
83185: LD_INT 0
83187: PUSH
83188: LD_INT 4
83190: NEG
83191: PUSH
83192: EMPTY
83193: LIST
83194: LIST
83195: PUSH
83196: LD_INT 0
83198: PUSH
83199: LD_INT 5
83201: NEG
83202: PUSH
83203: EMPTY
83204: LIST
83205: LIST
83206: PUSH
83207: LD_INT 1
83209: PUSH
83210: LD_INT 4
83212: NEG
83213: PUSH
83214: EMPTY
83215: LIST
83216: LIST
83217: PUSH
83218: LD_INT 1
83220: PUSH
83221: LD_INT 3
83223: NEG
83224: PUSH
83225: EMPTY
83226: LIST
83227: LIST
83228: PUSH
83229: LD_INT 0
83231: PUSH
83232: LD_INT 3
83234: NEG
83235: PUSH
83236: EMPTY
83237: LIST
83238: LIST
83239: PUSH
83240: LD_INT 1
83242: NEG
83243: PUSH
83244: LD_INT 4
83246: NEG
83247: PUSH
83248: EMPTY
83249: LIST
83250: LIST
83251: PUSH
83252: LD_INT 1
83254: NEG
83255: PUSH
83256: LD_INT 5
83258: NEG
83259: PUSH
83260: EMPTY
83261: LIST
83262: LIST
83263: PUSH
83264: LD_INT 2
83266: PUSH
83267: LD_INT 3
83269: NEG
83270: PUSH
83271: EMPTY
83272: LIST
83273: LIST
83274: PUSH
83275: LD_INT 2
83277: NEG
83278: PUSH
83279: LD_INT 5
83281: NEG
83282: PUSH
83283: EMPTY
83284: LIST
83285: LIST
83286: PUSH
83287: LD_INT 3
83289: PUSH
83290: LD_INT 0
83292: PUSH
83293: EMPTY
83294: LIST
83295: LIST
83296: PUSH
83297: LD_INT 3
83299: PUSH
83300: LD_INT 1
83302: NEG
83303: PUSH
83304: EMPTY
83305: LIST
83306: LIST
83307: PUSH
83308: LD_INT 4
83310: PUSH
83311: LD_INT 0
83313: PUSH
83314: EMPTY
83315: LIST
83316: LIST
83317: PUSH
83318: LD_INT 4
83320: PUSH
83321: LD_INT 1
83323: PUSH
83324: EMPTY
83325: LIST
83326: LIST
83327: PUSH
83328: LD_INT 3
83330: PUSH
83331: LD_INT 1
83333: PUSH
83334: EMPTY
83335: LIST
83336: LIST
83337: PUSH
83338: LD_INT 2
83340: PUSH
83341: LD_INT 0
83343: PUSH
83344: EMPTY
83345: LIST
83346: LIST
83347: PUSH
83348: LD_INT 2
83350: PUSH
83351: LD_INT 1
83353: NEG
83354: PUSH
83355: EMPTY
83356: LIST
83357: LIST
83358: PUSH
83359: LD_INT 2
83361: PUSH
83362: LD_INT 2
83364: NEG
83365: PUSH
83366: EMPTY
83367: LIST
83368: LIST
83369: PUSH
83370: LD_INT 4
83372: PUSH
83373: LD_INT 2
83375: PUSH
83376: EMPTY
83377: LIST
83378: LIST
83379: PUSH
83380: LD_INT 4
83382: PUSH
83383: LD_INT 4
83385: PUSH
83386: EMPTY
83387: LIST
83388: LIST
83389: PUSH
83390: LD_INT 4
83392: PUSH
83393: LD_INT 3
83395: PUSH
83396: EMPTY
83397: LIST
83398: LIST
83399: PUSH
83400: LD_INT 5
83402: PUSH
83403: LD_INT 4
83405: PUSH
83406: EMPTY
83407: LIST
83408: LIST
83409: PUSH
83410: LD_INT 5
83412: PUSH
83413: LD_INT 5
83415: PUSH
83416: EMPTY
83417: LIST
83418: LIST
83419: PUSH
83420: LD_INT 4
83422: PUSH
83423: LD_INT 5
83425: PUSH
83426: EMPTY
83427: LIST
83428: LIST
83429: PUSH
83430: LD_INT 3
83432: PUSH
83433: LD_INT 4
83435: PUSH
83436: EMPTY
83437: LIST
83438: LIST
83439: PUSH
83440: LD_INT 3
83442: PUSH
83443: LD_INT 3
83445: PUSH
83446: EMPTY
83447: LIST
83448: LIST
83449: PUSH
83450: LD_INT 5
83452: PUSH
83453: LD_INT 3
83455: PUSH
83456: EMPTY
83457: LIST
83458: LIST
83459: PUSH
83460: LD_INT 3
83462: PUSH
83463: LD_INT 5
83465: PUSH
83466: EMPTY
83467: LIST
83468: LIST
83469: PUSH
83470: LD_INT 0
83472: PUSH
83473: LD_INT 3
83475: PUSH
83476: EMPTY
83477: LIST
83478: LIST
83479: PUSH
83480: LD_INT 0
83482: PUSH
83483: LD_INT 2
83485: PUSH
83486: EMPTY
83487: LIST
83488: LIST
83489: PUSH
83490: LD_INT 1
83492: PUSH
83493: LD_INT 3
83495: PUSH
83496: EMPTY
83497: LIST
83498: LIST
83499: PUSH
83500: LD_INT 1
83502: PUSH
83503: LD_INT 4
83505: PUSH
83506: EMPTY
83507: LIST
83508: LIST
83509: PUSH
83510: LD_INT 0
83512: PUSH
83513: LD_INT 4
83515: PUSH
83516: EMPTY
83517: LIST
83518: LIST
83519: PUSH
83520: LD_INT 1
83522: NEG
83523: PUSH
83524: LD_INT 3
83526: PUSH
83527: EMPTY
83528: LIST
83529: LIST
83530: PUSH
83531: LD_INT 1
83533: NEG
83534: PUSH
83535: LD_INT 2
83537: PUSH
83538: EMPTY
83539: LIST
83540: LIST
83541: PUSH
83542: LD_INT 2
83544: PUSH
83545: LD_INT 4
83547: PUSH
83548: EMPTY
83549: LIST
83550: LIST
83551: PUSH
83552: LD_INT 2
83554: NEG
83555: PUSH
83556: LD_INT 2
83558: PUSH
83559: EMPTY
83560: LIST
83561: LIST
83562: PUSH
83563: LD_INT 4
83565: NEG
83566: PUSH
83567: LD_INT 0
83569: PUSH
83570: EMPTY
83571: LIST
83572: LIST
83573: PUSH
83574: LD_INT 4
83576: NEG
83577: PUSH
83578: LD_INT 1
83580: NEG
83581: PUSH
83582: EMPTY
83583: LIST
83584: LIST
83585: PUSH
83586: LD_INT 3
83588: NEG
83589: PUSH
83590: LD_INT 0
83592: PUSH
83593: EMPTY
83594: LIST
83595: LIST
83596: PUSH
83597: LD_INT 3
83599: NEG
83600: PUSH
83601: LD_INT 1
83603: PUSH
83604: EMPTY
83605: LIST
83606: LIST
83607: PUSH
83608: LD_INT 4
83610: NEG
83611: PUSH
83612: LD_INT 1
83614: PUSH
83615: EMPTY
83616: LIST
83617: LIST
83618: PUSH
83619: LD_INT 5
83621: NEG
83622: PUSH
83623: LD_INT 0
83625: PUSH
83626: EMPTY
83627: LIST
83628: LIST
83629: PUSH
83630: LD_INT 5
83632: NEG
83633: PUSH
83634: LD_INT 1
83636: NEG
83637: PUSH
83638: EMPTY
83639: LIST
83640: LIST
83641: PUSH
83642: LD_INT 5
83644: NEG
83645: PUSH
83646: LD_INT 2
83648: NEG
83649: PUSH
83650: EMPTY
83651: LIST
83652: LIST
83653: PUSH
83654: LD_INT 3
83656: NEG
83657: PUSH
83658: LD_INT 2
83660: PUSH
83661: EMPTY
83662: LIST
83663: LIST
83664: PUSH
83665: EMPTY
83666: LIST
83667: LIST
83668: LIST
83669: LIST
83670: LIST
83671: LIST
83672: LIST
83673: LIST
83674: LIST
83675: LIST
83676: LIST
83677: LIST
83678: LIST
83679: LIST
83680: LIST
83681: LIST
83682: LIST
83683: LIST
83684: LIST
83685: LIST
83686: LIST
83687: LIST
83688: LIST
83689: LIST
83690: LIST
83691: LIST
83692: LIST
83693: LIST
83694: LIST
83695: LIST
83696: LIST
83697: LIST
83698: LIST
83699: LIST
83700: LIST
83701: LIST
83702: LIST
83703: LIST
83704: LIST
83705: LIST
83706: LIST
83707: LIST
83708: LIST
83709: LIST
83710: LIST
83711: ST_TO_ADDR
// end ; end ;
83712: GO 83715
83714: POP
// case btype of b_depot , b_warehouse :
83715: LD_VAR 0 1
83719: PUSH
83720: LD_INT 0
83722: DOUBLE
83723: EQUAL
83724: IFTRUE 83734
83726: LD_INT 1
83728: DOUBLE
83729: EQUAL
83730: IFTRUE 83734
83732: GO 83935
83734: POP
// case nation of nation_american :
83735: LD_VAR 0 5
83739: PUSH
83740: LD_INT 1
83742: DOUBLE
83743: EQUAL
83744: IFTRUE 83748
83746: GO 83804
83748: POP
// temp_list = [ DepotAm0 , DepotAm1 , DepotAm2 , DepotAm3 , DepotAm4 , DepotAm5 ] [ dir + 1 ] ; nation_arabian :
83749: LD_ADDR_VAR 0 9
83753: PUSH
83754: LD_VAR 0 11
83758: PUSH
83759: LD_VAR 0 12
83763: PUSH
83764: LD_VAR 0 13
83768: PUSH
83769: LD_VAR 0 14
83773: PUSH
83774: LD_VAR 0 15
83778: PUSH
83779: LD_VAR 0 16
83783: PUSH
83784: EMPTY
83785: LIST
83786: LIST
83787: LIST
83788: LIST
83789: LIST
83790: LIST
83791: PUSH
83792: LD_VAR 0 4
83796: PUSH
83797: LD_INT 1
83799: PLUS
83800: ARRAY
83801: ST_TO_ADDR
83802: GO 83933
83804: LD_INT 2
83806: DOUBLE
83807: EQUAL
83808: IFTRUE 83812
83810: GO 83868
83812: POP
// temp_list = [ DepotAr0 , DepotAr1 , DepotAr2 , DepotAr3 , DepotAr4 , DepotAr5 ] [ dir + 1 ] ; nation_russian :
83813: LD_ADDR_VAR 0 9
83817: PUSH
83818: LD_VAR 0 17
83822: PUSH
83823: LD_VAR 0 18
83827: PUSH
83828: LD_VAR 0 19
83832: PUSH
83833: LD_VAR 0 20
83837: PUSH
83838: LD_VAR 0 21
83842: PUSH
83843: LD_VAR 0 22
83847: PUSH
83848: EMPTY
83849: LIST
83850: LIST
83851: LIST
83852: LIST
83853: LIST
83854: LIST
83855: PUSH
83856: LD_VAR 0 4
83860: PUSH
83861: LD_INT 1
83863: PLUS
83864: ARRAY
83865: ST_TO_ADDR
83866: GO 83933
83868: LD_INT 3
83870: DOUBLE
83871: EQUAL
83872: IFTRUE 83876
83874: GO 83932
83876: POP
// temp_list = [ DepotRu0 , DepotRu1 , DepotRu2 , DepotRu3 , DepotRu4 , DepotRu5 ] [ dir + 1 ] ; end ; b_workshop , b_factory :
83877: LD_ADDR_VAR 0 9
83881: PUSH
83882: LD_VAR 0 23
83886: PUSH
83887: LD_VAR 0 24
83891: PUSH
83892: LD_VAR 0 25
83896: PUSH
83897: LD_VAR 0 26
83901: PUSH
83902: LD_VAR 0 27
83906: PUSH
83907: LD_VAR 0 28
83911: PUSH
83912: EMPTY
83913: LIST
83914: LIST
83915: LIST
83916: LIST
83917: LIST
83918: LIST
83919: PUSH
83920: LD_VAR 0 4
83924: PUSH
83925: LD_INT 1
83927: PLUS
83928: ARRAY
83929: ST_TO_ADDR
83930: GO 83933
83932: POP
83933: GO 84488
83935: LD_INT 2
83937: DOUBLE
83938: EQUAL
83939: IFTRUE 83949
83941: LD_INT 3
83943: DOUBLE
83944: EQUAL
83945: IFTRUE 83949
83947: GO 84005
83949: POP
// temp_list = [ Factory0 , Factory1 , Factory2 , Factory3 , Factory4 , Factory5 ] [ dir + 1 ] ; b_ext_track , b_ext_gun , b_ext_rocket , b_ext_noncombat , b_ext_radio , b_ext_radar , b_ext_siberium , b_ext_stitch , b_ext_computer , b_ext_laser :
83950: LD_ADDR_VAR 0 9
83954: PUSH
83955: LD_VAR 0 29
83959: PUSH
83960: LD_VAR 0 30
83964: PUSH
83965: LD_VAR 0 31
83969: PUSH
83970: LD_VAR 0 32
83974: PUSH
83975: LD_VAR 0 33
83979: PUSH
83980: LD_VAR 0 34
83984: PUSH
83985: EMPTY
83986: LIST
83987: LIST
83988: LIST
83989: LIST
83990: LIST
83991: LIST
83992: PUSH
83993: LD_VAR 0 4
83997: PUSH
83998: LD_INT 1
84000: PLUS
84001: ARRAY
84002: ST_TO_ADDR
84003: GO 84488
84005: LD_INT 16
84007: DOUBLE
84008: EQUAL
84009: IFTRUE 84067
84011: LD_INT 17
84013: DOUBLE
84014: EQUAL
84015: IFTRUE 84067
84017: LD_INT 18
84019: DOUBLE
84020: EQUAL
84021: IFTRUE 84067
84023: LD_INT 19
84025: DOUBLE
84026: EQUAL
84027: IFTRUE 84067
84029: LD_INT 22
84031: DOUBLE
84032: EQUAL
84033: IFTRUE 84067
84035: LD_INT 20
84037: DOUBLE
84038: EQUAL
84039: IFTRUE 84067
84041: LD_INT 21
84043: DOUBLE
84044: EQUAL
84045: IFTRUE 84067
84047: LD_INT 23
84049: DOUBLE
84050: EQUAL
84051: IFTRUE 84067
84053: LD_INT 24
84055: DOUBLE
84056: EQUAL
84057: IFTRUE 84067
84059: LD_INT 25
84061: DOUBLE
84062: EQUAL
84063: IFTRUE 84067
84065: GO 84123
84067: POP
// temp_list = [ Ext0 , Ext1 , Ext2 , Ext3 , Ext4 , Ext5 ] [ dir + 1 ] ; b_lab , b_lab_half , b_lab_full , b_lab_biological , b_lab_computer , b_lab_opto , b_lab_siberium , b_lab_spacetime , b_lab_weapon :
84068: LD_ADDR_VAR 0 9
84072: PUSH
84073: LD_VAR 0 35
84077: PUSH
84078: LD_VAR 0 36
84082: PUSH
84083: LD_VAR 0 37
84087: PUSH
84088: LD_VAR 0 38
84092: PUSH
84093: LD_VAR 0 39
84097: PUSH
84098: LD_VAR 0 40
84102: PUSH
84103: EMPTY
84104: LIST
84105: LIST
84106: LIST
84107: LIST
84108: LIST
84109: LIST
84110: PUSH
84111: LD_VAR 0 4
84115: PUSH
84116: LD_INT 1
84118: PLUS
84119: ARRAY
84120: ST_TO_ADDR
84121: GO 84488
84123: LD_INT 6
84125: DOUBLE
84126: EQUAL
84127: IFTRUE 84179
84129: LD_INT 7
84131: DOUBLE
84132: EQUAL
84133: IFTRUE 84179
84135: LD_INT 8
84137: DOUBLE
84138: EQUAL
84139: IFTRUE 84179
84141: LD_INT 13
84143: DOUBLE
84144: EQUAL
84145: IFTRUE 84179
84147: LD_INT 12
84149: DOUBLE
84150: EQUAL
84151: IFTRUE 84179
84153: LD_INT 15
84155: DOUBLE
84156: EQUAL
84157: IFTRUE 84179
84159: LD_INT 11
84161: DOUBLE
84162: EQUAL
84163: IFTRUE 84179
84165: LD_INT 14
84167: DOUBLE
84168: EQUAL
84169: IFTRUE 84179
84171: LD_INT 10
84173: DOUBLE
84174: EQUAL
84175: IFTRUE 84179
84177: GO 84235
84179: POP
// temp_list = [ Lab0 , Lab1 , Lab2 , Lab3 , Lab4 , Lab5 ] [ dir + 1 ] ; b_control_tower :
84180: LD_ADDR_VAR 0 9
84184: PUSH
84185: LD_VAR 0 41
84189: PUSH
84190: LD_VAR 0 42
84194: PUSH
84195: LD_VAR 0 43
84199: PUSH
84200: LD_VAR 0 44
84204: PUSH
84205: LD_VAR 0 45
84209: PUSH
84210: LD_VAR 0 46
84214: PUSH
84215: EMPTY
84216: LIST
84217: LIST
84218: LIST
84219: LIST
84220: LIST
84221: LIST
84222: PUSH
84223: LD_VAR 0 4
84227: PUSH
84228: LD_INT 1
84230: PLUS
84231: ARRAY
84232: ST_TO_ADDR
84233: GO 84488
84235: LD_INT 36
84237: DOUBLE
84238: EQUAL
84239: IFTRUE 84243
84241: GO 84299
84243: POP
// temp_list = [ ControlTower0 , ControlTower1 , ControlTower2 , ControlTower3 , ControlTower4 , ControlTower5 ] [ dir + 1 ] ; b_armoury , b_barracks , b_teleport , b_behemoth :
84244: LD_ADDR_VAR 0 9
84248: PUSH
84249: LD_VAR 0 47
84253: PUSH
84254: LD_VAR 0 48
84258: PUSH
84259: LD_VAR 0 49
84263: PUSH
84264: LD_VAR 0 50
84268: PUSH
84269: LD_VAR 0 51
84273: PUSH
84274: LD_VAR 0 52
84278: PUSH
84279: EMPTY
84280: LIST
84281: LIST
84282: LIST
84283: LIST
84284: LIST
84285: LIST
84286: PUSH
84287: LD_VAR 0 4
84291: PUSH
84292: LD_INT 1
84294: PLUS
84295: ARRAY
84296: ST_TO_ADDR
84297: GO 84488
84299: LD_INT 4
84301: DOUBLE
84302: EQUAL
84303: IFTRUE 84325
84305: LD_INT 5
84307: DOUBLE
84308: EQUAL
84309: IFTRUE 84325
84311: LD_INT 34
84313: DOUBLE
84314: EQUAL
84315: IFTRUE 84325
84317: LD_INT 37
84319: DOUBLE
84320: EQUAL
84321: IFTRUE 84325
84323: GO 84381
84325: POP
// temp_list = [ Barracks0 , Barracks1 , Barracks2 , Barracks3 , Barracks4 , Barracks5 ] [ dir + 1 ] ; b_breastwork , b_bunker , b_turret , b_solar_power , b_oil_power , b_siberite_power , b_oil_mine , b_siberite_mine :
84326: LD_ADDR_VAR 0 9
84330: PUSH
84331: LD_VAR 0 53
84335: PUSH
84336: LD_VAR 0 54
84340: PUSH
84341: LD_VAR 0 55
84345: PUSH
84346: LD_VAR 0 56
84350: PUSH
84351: LD_VAR 0 57
84355: PUSH
84356: LD_VAR 0 58
84360: PUSH
84361: EMPTY
84362: LIST
84363: LIST
84364: LIST
84365: LIST
84366: LIST
84367: LIST
84368: PUSH
84369: LD_VAR 0 4
84373: PUSH
84374: LD_INT 1
84376: PLUS
84377: ARRAY
84378: ST_TO_ADDR
84379: GO 84488
84381: LD_INT 31
84383: DOUBLE
84384: EQUAL
84385: IFTRUE 84431
84387: LD_INT 32
84389: DOUBLE
84390: EQUAL
84391: IFTRUE 84431
84393: LD_INT 33
84395: DOUBLE
84396: EQUAL
84397: IFTRUE 84431
84399: LD_INT 27
84401: DOUBLE
84402: EQUAL
84403: IFTRUE 84431
84405: LD_INT 26
84407: DOUBLE
84408: EQUAL
84409: IFTRUE 84431
84411: LD_INT 28
84413: DOUBLE
84414: EQUAL
84415: IFTRUE 84431
84417: LD_INT 29
84419: DOUBLE
84420: EQUAL
84421: IFTRUE 84431
84423: LD_INT 30
84425: DOUBLE
84426: EQUAL
84427: IFTRUE 84431
84429: GO 84487
84431: POP
// temp_list = [ Bunker0 , Bunker1 , Bunker2 , Bunker3 , Bunker4 , Bunker5 ] [ dir + 1 ] ; end ;
84432: LD_ADDR_VAR 0 9
84436: PUSH
84437: LD_VAR 0 59
84441: PUSH
84442: LD_VAR 0 60
84446: PUSH
84447: LD_VAR 0 61
84451: PUSH
84452: LD_VAR 0 62
84456: PUSH
84457: LD_VAR 0 63
84461: PUSH
84462: LD_VAR 0 64
84466: PUSH
84467: EMPTY
84468: LIST
84469: LIST
84470: LIST
84471: LIST
84472: LIST
84473: LIST
84474: PUSH
84475: LD_VAR 0 4
84479: PUSH
84480: LD_INT 1
84482: PLUS
84483: ARRAY
84484: ST_TO_ADDR
84485: GO 84488
84487: POP
// temp_list2 = [ ] ;
84488: LD_ADDR_VAR 0 10
84492: PUSH
84493: EMPTY
84494: ST_TO_ADDR
// for i in temp_list do
84495: LD_ADDR_VAR 0 8
84499: PUSH
84500: LD_VAR 0 9
84504: PUSH
84505: FOR_IN
84506: IFFALSE 84558
// temp_list2 = temp_list2 ^ [ [ i [ 1 ] + x , i [ 2 ] + y ] ] ;
84508: LD_ADDR_VAR 0 10
84512: PUSH
84513: LD_VAR 0 10
84517: PUSH
84518: LD_VAR 0 8
84522: PUSH
84523: LD_INT 1
84525: ARRAY
84526: PUSH
84527: LD_VAR 0 2
84531: PLUS
84532: PUSH
84533: LD_VAR 0 8
84537: PUSH
84538: LD_INT 2
84540: ARRAY
84541: PUSH
84542: LD_VAR 0 3
84546: PLUS
84547: PUSH
84548: EMPTY
84549: LIST
84550: LIST
84551: PUSH
84552: EMPTY
84553: LIST
84554: ADD
84555: ST_TO_ADDR
84556: GO 84505
84558: POP
84559: POP
// result = temp_list2 ;
84560: LD_ADDR_VAR 0 7
84564: PUSH
84565: LD_VAR 0 10
84569: ST_TO_ADDR
// end ;
84570: LD_VAR 0 7
84574: RET
// export function EnemyInRange ( unit , dist ) ; begin
84575: LD_INT 0
84577: PPUSH
// result := DangerAtRangeXY ( GetSide ( unit ) , GetX ( unit ) , GetY ( unit ) , dist ) [ 4 ] ;
84578: LD_ADDR_VAR 0 3
84582: PUSH
84583: LD_VAR 0 1
84587: PPUSH
84588: CALL_OW 255
84592: PPUSH
84593: LD_VAR 0 1
84597: PPUSH
84598: CALL_OW 250
84602: PPUSH
84603: LD_VAR 0 1
84607: PPUSH
84608: CALL_OW 251
84612: PPUSH
84613: LD_VAR 0 2
84617: PPUSH
84618: CALL 58679 0 4
84622: PUSH
84623: LD_INT 4
84625: ARRAY
84626: ST_TO_ADDR
// end ;
84627: LD_VAR 0 3
84631: RET
// export function PlayerSeeMe ( unit ) ; begin
84632: LD_INT 0
84634: PPUSH
// result := See ( your_side , unit ) ;
84635: LD_ADDR_VAR 0 2
84639: PUSH
84640: LD_OWVAR 2
84644: PPUSH
84645: LD_VAR 0 1
84649: PPUSH
84650: CALL_OW 292
84654: ST_TO_ADDR
// end ;
84655: LD_VAR 0 2
84659: RET
// export function ReverseDir ( unit ) ; begin
84660: LD_INT 0
84662: PPUSH
// if not unit then
84663: LD_VAR 0 1
84667: NOT
84668: IFFALSE 84672
// exit ;
84670: GO 84695
// result := ( GetDir ( unit ) + 3 ) mod 6 ;
84672: LD_ADDR_VAR 0 2
84676: PUSH
84677: LD_VAR 0 1
84681: PPUSH
84682: CALL_OW 254
84686: PUSH
84687: LD_INT 3
84689: PLUS
84690: PUSH
84691: LD_INT 6
84693: MOD
84694: ST_TO_ADDR
// end ;
84695: LD_VAR 0 2
84699: RET
// export function GetClosestHex ( unit , hexes ) ; var i , dist , tmp , hex ; begin
84700: LD_INT 0
84702: PPUSH
84703: PPUSH
84704: PPUSH
84705: PPUSH
84706: PPUSH
// if not hexes then
84707: LD_VAR 0 2
84711: NOT
84712: IFFALSE 84716
// exit ;
84714: GO 84864
// dist := 9999 ;
84716: LD_ADDR_VAR 0 5
84720: PUSH
84721: LD_INT 9999
84723: ST_TO_ADDR
// for i = 1 to hexes do
84724: LD_ADDR_VAR 0 4
84728: PUSH
84729: DOUBLE
84730: LD_INT 1
84732: DEC
84733: ST_TO_ADDR
84734: LD_VAR 0 2
84738: PUSH
84739: FOR_TO
84740: IFFALSE 84852
// begin if GetDistUnitXY ( unit , hexes [ i ] [ 1 ] , hexes [ i ] [ 2 ] ) < dist then
84742: LD_VAR 0 1
84746: PPUSH
84747: LD_VAR 0 2
84751: PUSH
84752: LD_VAR 0 4
84756: ARRAY
84757: PUSH
84758: LD_INT 1
84760: ARRAY
84761: PPUSH
84762: LD_VAR 0 2
84766: PUSH
84767: LD_VAR 0 4
84771: ARRAY
84772: PUSH
84773: LD_INT 2
84775: ARRAY
84776: PPUSH
84777: CALL_OW 297
84781: PUSH
84782: LD_VAR 0 5
84786: LESS
84787: IFFALSE 84850
// begin hex := hexes [ i ] ;
84789: LD_ADDR_VAR 0 7
84793: PUSH
84794: LD_VAR 0 2
84798: PUSH
84799: LD_VAR 0 4
84803: ARRAY
84804: ST_TO_ADDR
// dist := GetDistUnitXY ( unit , hexes [ i ] [ 1 ] , hexes [ i ] [ 2 ] ) ;
84805: LD_ADDR_VAR 0 5
84809: PUSH
84810: LD_VAR 0 1
84814: PPUSH
84815: LD_VAR 0 2
84819: PUSH
84820: LD_VAR 0 4
84824: ARRAY
84825: PUSH
84826: LD_INT 1
84828: ARRAY
84829: PPUSH
84830: LD_VAR 0 2
84834: PUSH
84835: LD_VAR 0 4
84839: ARRAY
84840: PUSH
84841: LD_INT 2
84843: ARRAY
84844: PPUSH
84845: CALL_OW 297
84849: ST_TO_ADDR
// end ; end ;
84850: GO 84739
84852: POP
84853: POP
// result := hex ;
84854: LD_ADDR_VAR 0 3
84858: PUSH
84859: LD_VAR 0 7
84863: ST_TO_ADDR
// end ;
84864: LD_VAR 0 3
84868: RET
// export function ComAutodestruct ( unit ) ; var i ; begin
84869: LD_INT 0
84871: PPUSH
84872: PPUSH
// if not unit or not unit in FilterAllUnits ( [ [ f_type , unit_vehicle ] , [ f_nation , 2 ] ] ) then
84873: LD_VAR 0 1
84877: NOT
84878: PUSH
84879: LD_VAR 0 1
84883: PUSH
84884: LD_INT 21
84886: PUSH
84887: LD_INT 2
84889: PUSH
84890: EMPTY
84891: LIST
84892: LIST
84893: PUSH
84894: LD_INT 23
84896: PUSH
84897: LD_INT 2
84899: PUSH
84900: EMPTY
84901: LIST
84902: LIST
84903: PUSH
84904: EMPTY
84905: LIST
84906: LIST
84907: PPUSH
84908: CALL_OW 69
84912: IN
84913: NOT
84914: OR
84915: IFFALSE 84919
// exit ;
84917: GO 84966
// for i = 1 to 3 do
84919: LD_ADDR_VAR 0 3
84923: PUSH
84924: DOUBLE
84925: LD_INT 1
84927: DEC
84928: ST_TO_ADDR
84929: LD_INT 3
84931: PUSH
84932: FOR_TO
84933: IFFALSE 84964
// MineExplosion ( GetX ( unit ) , GetY ( unit ) , 1 ) ;
84935: LD_VAR 0 1
84939: PPUSH
84940: CALL_OW 250
84944: PPUSH
84945: LD_VAR 0 1
84949: PPUSH
84950: CALL_OW 251
84954: PPUSH
84955: LD_INT 1
84957: PPUSH
84958: CALL_OW 453
84962: GO 84932
84964: POP
84965: POP
// end ;
84966: LD_VAR 0 2
84970: RET
// export function AttackHovercraft ( unit , enemy_unit ) ; var i , j , tmp , x , y ; begin
84971: LD_INT 0
84973: PPUSH
84974: PPUSH
84975: PPUSH
84976: PPUSH
84977: PPUSH
84978: PPUSH
// if not unit or not enemy_unit or HasTask ( unit ) then
84979: LD_VAR 0 1
84983: NOT
84984: PUSH
84985: LD_VAR 0 2
84989: NOT
84990: OR
84991: PUSH
84992: LD_VAR 0 1
84996: PPUSH
84997: CALL_OW 314
85001: OR
85002: IFFALSE 85006
// exit ;
85004: GO 85447
// x := GetX ( enemy_unit ) ;
85006: LD_ADDR_VAR 0 7
85010: PUSH
85011: LD_VAR 0 2
85015: PPUSH
85016: CALL_OW 250
85020: ST_TO_ADDR
// y := GetY ( enemy_unit ) ;
85021: LD_ADDR_VAR 0 8
85025: PUSH
85026: LD_VAR 0 2
85030: PPUSH
85031: CALL_OW 251
85035: ST_TO_ADDR
// if not x or not y then
85036: LD_VAR 0 7
85040: NOT
85041: PUSH
85042: LD_VAR 0 8
85046: NOT
85047: OR
85048: IFFALSE 85052
// exit ;
85050: GO 85447
// tmp := [ [ ShiftX ( x , 0 , 4 ) , ShiftY ( y , 0 , 4 ) ] , [ ShiftX ( x , 1 , 4 ) , ShiftY ( y , 1 , 4 ) ] , [ ShiftX ( x , 2 , 4 ) , ShiftY ( y , 2 , 4 ) ] , [ ShiftX ( x , 3 , 4 ) , ShiftY ( y , 3 , 4 ) ] , [ ShiftX ( x , 4 , 4 ) , ShiftY ( y , 4 , 4 ) ] , [ ShiftX ( x , 5 , 4 ) , ShiftY ( y , 5 , 4 ) ] ] ;
85052: LD_ADDR_VAR 0 6
85056: PUSH
85057: LD_VAR 0 7
85061: PPUSH
85062: LD_INT 0
85064: PPUSH
85065: LD_INT 4
85067: PPUSH
85068: CALL_OW 272
85072: PUSH
85073: LD_VAR 0 8
85077: PPUSH
85078: LD_INT 0
85080: PPUSH
85081: LD_INT 4
85083: PPUSH
85084: CALL_OW 273
85088: PUSH
85089: EMPTY
85090: LIST
85091: LIST
85092: PUSH
85093: LD_VAR 0 7
85097: PPUSH
85098: LD_INT 1
85100: PPUSH
85101: LD_INT 4
85103: PPUSH
85104: CALL_OW 272
85108: PUSH
85109: LD_VAR 0 8
85113: PPUSH
85114: LD_INT 1
85116: PPUSH
85117: LD_INT 4
85119: PPUSH
85120: CALL_OW 273
85124: PUSH
85125: EMPTY
85126: LIST
85127: LIST
85128: PUSH
85129: LD_VAR 0 7
85133: PPUSH
85134: LD_INT 2
85136: PPUSH
85137: LD_INT 4
85139: PPUSH
85140: CALL_OW 272
85144: PUSH
85145: LD_VAR 0 8
85149: PPUSH
85150: LD_INT 2
85152: PPUSH
85153: LD_INT 4
85155: PPUSH
85156: CALL_OW 273
85160: PUSH
85161: EMPTY
85162: LIST
85163: LIST
85164: PUSH
85165: LD_VAR 0 7
85169: PPUSH
85170: LD_INT 3
85172: PPUSH
85173: LD_INT 4
85175: PPUSH
85176: CALL_OW 272
85180: PUSH
85181: LD_VAR 0 8
85185: PPUSH
85186: LD_INT 3
85188: PPUSH
85189: LD_INT 4
85191: PPUSH
85192: CALL_OW 273
85196: PUSH
85197: EMPTY
85198: LIST
85199: LIST
85200: PUSH
85201: LD_VAR 0 7
85205: PPUSH
85206: LD_INT 4
85208: PPUSH
85209: LD_INT 4
85211: PPUSH
85212: CALL_OW 272
85216: PUSH
85217: LD_VAR 0 8
85221: PPUSH
85222: LD_INT 4
85224: PPUSH
85225: LD_INT 4
85227: PPUSH
85228: CALL_OW 273
85232: PUSH
85233: EMPTY
85234: LIST
85235: LIST
85236: PUSH
85237: LD_VAR 0 7
85241: PPUSH
85242: LD_INT 5
85244: PPUSH
85245: LD_INT 4
85247: PPUSH
85248: CALL_OW 272
85252: PUSH
85253: LD_VAR 0 8
85257: PPUSH
85258: LD_INT 5
85260: PPUSH
85261: LD_INT 4
85263: PPUSH
85264: CALL_OW 273
85268: PUSH
85269: EMPTY
85270: LIST
85271: LIST
85272: PUSH
85273: EMPTY
85274: LIST
85275: LIST
85276: LIST
85277: LIST
85278: LIST
85279: LIST
85280: ST_TO_ADDR
// for i = tmp downto 1 do
85281: LD_ADDR_VAR 0 4
85285: PUSH
85286: DOUBLE
85287: LD_VAR 0 6
85291: INC
85292: ST_TO_ADDR
85293: LD_INT 1
85295: PUSH
85296: FOR_DOWNTO
85297: IFFALSE 85398
// if not ValidHex ( tmp [ i ] [ 1 ] , tmp [ i ] [ 2 ] ) or HexInfo ( tmp [ i ] [ 1 ] , tmp [ i ] [ 2 ] ) <> 0 then
85299: LD_VAR 0 6
85303: PUSH
85304: LD_VAR 0 4
85308: ARRAY
85309: PUSH
85310: LD_INT 1
85312: ARRAY
85313: PPUSH
85314: LD_VAR 0 6
85318: PUSH
85319: LD_VAR 0 4
85323: ARRAY
85324: PUSH
85325: LD_INT 2
85327: ARRAY
85328: PPUSH
85329: CALL_OW 488
85333: NOT
85334: PUSH
85335: LD_VAR 0 6
85339: PUSH
85340: LD_VAR 0 4
85344: ARRAY
85345: PUSH
85346: LD_INT 1
85348: ARRAY
85349: PPUSH
85350: LD_VAR 0 6
85354: PUSH
85355: LD_VAR 0 4
85359: ARRAY
85360: PUSH
85361: LD_INT 2
85363: ARRAY
85364: PPUSH
85365: CALL_OW 428
85369: PUSH
85370: LD_INT 0
85372: NONEQUAL
85373: OR
85374: IFFALSE 85396
// tmp := Delete ( tmp , i ) ;
85376: LD_ADDR_VAR 0 6
85380: PUSH
85381: LD_VAR 0 6
85385: PPUSH
85386: LD_VAR 0 4
85390: PPUSH
85391: CALL_OW 3
85395: ST_TO_ADDR
85396: GO 85296
85398: POP
85399: POP
// j := GetClosestHex ( unit , tmp ) ;
85400: LD_ADDR_VAR 0 5
85404: PUSH
85405: LD_VAR 0 1
85409: PPUSH
85410: LD_VAR 0 6
85414: PPUSH
85415: CALL 84700 0 2
85419: ST_TO_ADDR
// ComMoveXY ( unit , j [ 1 ] , j [ 2 ] ) ;
85420: LD_VAR 0 1
85424: PPUSH
85425: LD_VAR 0 5
85429: PUSH
85430: LD_INT 1
85432: ARRAY
85433: PPUSH
85434: LD_VAR 0 5
85438: PUSH
85439: LD_INT 2
85441: ARRAY
85442: PPUSH
85443: CALL_OW 111
// end ;
85447: LD_VAR 0 3
85451: RET
// export function PrepareNature ( birds , tigers , apemans , enchidnas , horses , mastodonts , fishes , nat_area , wat_area ) ; var i , animal ; begin
85452: LD_INT 0
85454: PPUSH
85455: PPUSH
85456: PPUSH
// uc_side = 0 ;
85457: LD_ADDR_OWVAR 20
85461: PUSH
85462: LD_INT 0
85464: ST_TO_ADDR
// uc_nation = 0 ;
85465: LD_ADDR_OWVAR 21
85469: PUSH
85470: LD_INT 0
85472: ST_TO_ADDR
// InitHc ;
85473: CALL_OW 19
// InitVc ;
85477: CALL_OW 20
// if mastodonts then
85481: LD_VAR 0 6
85485: IFFALSE 85552
// for i = 1 to mastodonts do
85487: LD_ADDR_VAR 0 11
85491: PUSH
85492: DOUBLE
85493: LD_INT 1
85495: DEC
85496: ST_TO_ADDR
85497: LD_VAR 0 6
85501: PUSH
85502: FOR_TO
85503: IFFALSE 85550
// begin vc_chassis := 31 ;
85505: LD_ADDR_OWVAR 37
85509: PUSH
85510: LD_INT 31
85512: ST_TO_ADDR
// vc_control := control_rider ;
85513: LD_ADDR_OWVAR 38
85517: PUSH
85518: LD_INT 4
85520: ST_TO_ADDR
// animal := CreateVehicle ;
85521: LD_ADDR_VAR 0 12
85525: PUSH
85526: CALL_OW 45
85530: ST_TO_ADDR
// PlaceUnitInArea ( animal , nat_area , false ) ;
85531: LD_VAR 0 12
85535: PPUSH
85536: LD_VAR 0 8
85540: PPUSH
85541: LD_INT 0
85543: PPUSH
85544: CALL 92330 0 3
// end ;
85548: GO 85502
85550: POP
85551: POP
// if horses then
85552: LD_VAR 0 5
85556: IFFALSE 85623
// for i = 1 to horses do
85558: LD_ADDR_VAR 0 11
85562: PUSH
85563: DOUBLE
85564: LD_INT 1
85566: DEC
85567: ST_TO_ADDR
85568: LD_VAR 0 5
85572: PUSH
85573: FOR_TO
85574: IFFALSE 85621
// begin hc_class := 21 ;
85576: LD_ADDR_OWVAR 28
85580: PUSH
85581: LD_INT 21
85583: ST_TO_ADDR
// hc_gallery :=  ;
85584: LD_ADDR_OWVAR 33
85588: PUSH
85589: LD_STRING 
85591: ST_TO_ADDR
// animal := CreateHuman ;
85592: LD_ADDR_VAR 0 12
85596: PUSH
85597: CALL_OW 44
85601: ST_TO_ADDR
// PlaceUnitInArea ( animal , nat_area , false ) ;
85602: LD_VAR 0 12
85606: PPUSH
85607: LD_VAR 0 8
85611: PPUSH
85612: LD_INT 0
85614: PPUSH
85615: CALL 92330 0 3
// end ;
85619: GO 85573
85621: POP
85622: POP
// if birds then
85623: LD_VAR 0 1
85627: IFFALSE 85694
// for i = 1 to birds do
85629: LD_ADDR_VAR 0 11
85633: PUSH
85634: DOUBLE
85635: LD_INT 1
85637: DEC
85638: ST_TO_ADDR
85639: LD_VAR 0 1
85643: PUSH
85644: FOR_TO
85645: IFFALSE 85692
// begin hc_class = 18 ;
85647: LD_ADDR_OWVAR 28
85651: PUSH
85652: LD_INT 18
85654: ST_TO_ADDR
// hc_gallery =  ;
85655: LD_ADDR_OWVAR 33
85659: PUSH
85660: LD_STRING 
85662: ST_TO_ADDR
// animal := CreateHuman ;
85663: LD_ADDR_VAR 0 12
85667: PUSH
85668: CALL_OW 44
85672: ST_TO_ADDR
// PlaceUnitInArea ( animal , nat_area , false ) ;
85673: LD_VAR 0 12
85677: PPUSH
85678: LD_VAR 0 8
85682: PPUSH
85683: LD_INT 0
85685: PPUSH
85686: CALL 92330 0 3
// end ;
85690: GO 85644
85692: POP
85693: POP
// if tigers then
85694: LD_VAR 0 2
85698: IFFALSE 85782
// for i = 1 to tigers do
85700: LD_ADDR_VAR 0 11
85704: PUSH
85705: DOUBLE
85706: LD_INT 1
85708: DEC
85709: ST_TO_ADDR
85710: LD_VAR 0 2
85714: PUSH
85715: FOR_TO
85716: IFFALSE 85780
// begin hc_class = class_tiger ;
85718: LD_ADDR_OWVAR 28
85722: PUSH
85723: LD_INT 14
85725: ST_TO_ADDR
// hc_gallery =  ;
85726: LD_ADDR_OWVAR 33
85730: PUSH
85731: LD_STRING 
85733: ST_TO_ADDR
// hc_agressivity = Rand ( - 7 , 7 ) ;
85734: LD_ADDR_OWVAR 35
85738: PUSH
85739: LD_INT 7
85741: NEG
85742: PPUSH
85743: LD_INT 7
85745: PPUSH
85746: CALL_OW 12
85750: ST_TO_ADDR
// animal := CreateHuman ;
85751: LD_ADDR_VAR 0 12
85755: PUSH
85756: CALL_OW 44
85760: ST_TO_ADDR
// PlaceUnitInArea ( animal , nat_area , false ) ;
85761: LD_VAR 0 12
85765: PPUSH
85766: LD_VAR 0 8
85770: PPUSH
85771: LD_INT 0
85773: PPUSH
85774: CALL 92330 0 3
// end ;
85778: GO 85715
85780: POP
85781: POP
// if apemans then
85782: LD_VAR 0 3
85786: IFFALSE 85909
// for i = 1 to apemans do
85788: LD_ADDR_VAR 0 11
85792: PUSH
85793: DOUBLE
85794: LD_INT 1
85796: DEC
85797: ST_TO_ADDR
85798: LD_VAR 0 3
85802: PUSH
85803: FOR_TO
85804: IFFALSE 85907
// begin hc_class = class_apeman ;
85806: LD_ADDR_OWVAR 28
85810: PUSH
85811: LD_INT 12
85813: ST_TO_ADDR
// hc_gallery =  ;
85814: LD_ADDR_OWVAR 33
85818: PUSH
85819: LD_STRING 
85821: ST_TO_ADDR
// hc_agressivity = rand ( - 5 , 5 ) ;
85822: LD_ADDR_OWVAR 35
85826: PUSH
85827: LD_INT 5
85829: NEG
85830: PPUSH
85831: LD_INT 5
85833: PPUSH
85834: CALL_OW 12
85838: ST_TO_ADDR
// hc_skills := [ rand ( 1 , 3 ) , rand ( 1 , 3 ) , 0 , 0 ] ;
85839: LD_ADDR_OWVAR 31
85843: PUSH
85844: LD_INT 1
85846: PPUSH
85847: LD_INT 3
85849: PPUSH
85850: CALL_OW 12
85854: PUSH
85855: LD_INT 1
85857: PPUSH
85858: LD_INT 3
85860: PPUSH
85861: CALL_OW 12
85865: PUSH
85866: LD_INT 0
85868: PUSH
85869: LD_INT 0
85871: PUSH
85872: EMPTY
85873: LIST
85874: LIST
85875: LIST
85876: LIST
85877: ST_TO_ADDR
// animal := CreateHuman ;
85878: LD_ADDR_VAR 0 12
85882: PUSH
85883: CALL_OW 44
85887: ST_TO_ADDR
// PlaceUnitInArea ( animal , nat_area , false ) ;
85888: LD_VAR 0 12
85892: PPUSH
85893: LD_VAR 0 8
85897: PPUSH
85898: LD_INT 0
85900: PPUSH
85901: CALL 92330 0 3
// end ;
85905: GO 85803
85907: POP
85908: POP
// if enchidnas then
85909: LD_VAR 0 4
85913: IFFALSE 85980
// for i = 1 to enchidnas do
85915: LD_ADDR_VAR 0 11
85919: PUSH
85920: DOUBLE
85921: LD_INT 1
85923: DEC
85924: ST_TO_ADDR
85925: LD_VAR 0 4
85929: PUSH
85930: FOR_TO
85931: IFFALSE 85978
// begin hc_class = 13 ;
85933: LD_ADDR_OWVAR 28
85937: PUSH
85938: LD_INT 13
85940: ST_TO_ADDR
// hc_gallery =  ;
85941: LD_ADDR_OWVAR 33
85945: PUSH
85946: LD_STRING 
85948: ST_TO_ADDR
// animal := CreateHuman ;
85949: LD_ADDR_VAR 0 12
85953: PUSH
85954: CALL_OW 44
85958: ST_TO_ADDR
// PlaceUnitInArea ( animal , nat_area , false ) ;
85959: LD_VAR 0 12
85963: PPUSH
85964: LD_VAR 0 8
85968: PPUSH
85969: LD_INT 0
85971: PPUSH
85972: CALL 92330 0 3
// end ;
85976: GO 85930
85978: POP
85979: POP
// if fishes then
85980: LD_VAR 0 7
85984: IFFALSE 86051
// for i = 1 to fishes do
85986: LD_ADDR_VAR 0 11
85990: PUSH
85991: DOUBLE
85992: LD_INT 1
85994: DEC
85995: ST_TO_ADDR
85996: LD_VAR 0 7
86000: PUSH
86001: FOR_TO
86002: IFFALSE 86049
// begin hc_class = 20 ;
86004: LD_ADDR_OWVAR 28
86008: PUSH
86009: LD_INT 20
86011: ST_TO_ADDR
// hc_gallery =  ;
86012: LD_ADDR_OWVAR 33
86016: PUSH
86017: LD_STRING 
86019: ST_TO_ADDR
// animal := CreateHuman ;
86020: LD_ADDR_VAR 0 12
86024: PUSH
86025: CALL_OW 44
86029: ST_TO_ADDR
// PlaceUnitInArea ( animal , wat_area , false ) ;
86030: LD_VAR 0 12
86034: PPUSH
86035: LD_VAR 0 9
86039: PPUSH
86040: LD_INT 0
86042: PPUSH
86043: CALL 92330 0 3
// end ;
86047: GO 86001
86049: POP
86050: POP
// end ;
86051: LD_VAR 0 10
86055: RET
// export function WantHeal ( sci , unit ) ; begin
86056: LD_INT 0
86058: PPUSH
// if GetTaskList ( sci ) > 0 then
86059: LD_VAR 0 1
86063: PPUSH
86064: CALL_OW 437
86068: PUSH
86069: LD_INT 0
86071: GREATER
86072: IFFALSE 86142
// begin if GetTaskList ( sci ) [ 1 ] [ 1 ] = l and GetTaskList ( sci ) [ 1 ] [ 4 ] = unit then
86074: LD_VAR 0 1
86078: PPUSH
86079: CALL_OW 437
86083: PUSH
86084: LD_INT 1
86086: ARRAY
86087: PUSH
86088: LD_INT 1
86090: ARRAY
86091: PUSH
86092: LD_STRING l
86094: EQUAL
86095: PUSH
86096: LD_VAR 0 1
86100: PPUSH
86101: CALL_OW 437
86105: PUSH
86106: LD_INT 1
86108: ARRAY
86109: PUSH
86110: LD_INT 4
86112: ARRAY
86113: PUSH
86114: LD_VAR 0 2
86118: EQUAL
86119: AND
86120: IFFALSE 86132
// result := true else
86122: LD_ADDR_VAR 0 3
86126: PUSH
86127: LD_INT 1
86129: ST_TO_ADDR
86130: GO 86140
// result := false ;
86132: LD_ADDR_VAR 0 3
86136: PUSH
86137: LD_INT 0
86139: ST_TO_ADDR
// end else
86140: GO 86150
// result := false ;
86142: LD_ADDR_VAR 0 3
86146: PUSH
86147: LD_INT 0
86149: ST_TO_ADDR
// end ;
86150: LD_VAR 0 3
86154: RET
// export function HealTarget ( sci ) ; begin
86155: LD_INT 0
86157: PPUSH
// if not sci then
86158: LD_VAR 0 1
86162: NOT
86163: IFFALSE 86167
// exit ;
86165: GO 86232
// result := 0 ;
86167: LD_ADDR_VAR 0 2
86171: PUSH
86172: LD_INT 0
86174: ST_TO_ADDR
// if GetTaskList ( sci ) then
86175: LD_VAR 0 1
86179: PPUSH
86180: CALL_OW 437
86184: IFFALSE 86232
// if GetTaskList ( sci ) [ 1 ] [ 1 ] = l then
86186: LD_VAR 0 1
86190: PPUSH
86191: CALL_OW 437
86195: PUSH
86196: LD_INT 1
86198: ARRAY
86199: PUSH
86200: LD_INT 1
86202: ARRAY
86203: PUSH
86204: LD_STRING l
86206: EQUAL
86207: IFFALSE 86232
// result := GetTaskList ( sci ) [ 1 ] [ 4 ] ;
86209: LD_ADDR_VAR 0 2
86213: PUSH
86214: LD_VAR 0 1
86218: PPUSH
86219: CALL_OW 437
86223: PUSH
86224: LD_INT 1
86226: ARRAY
86227: PUSH
86228: LD_INT 4
86230: ARRAY
86231: ST_TO_ADDR
// end ;
86232: LD_VAR 0 2
86236: RET
// export function Attack ( list ) ; var base , group , path , flags , i , j , k , x , y , d , z , tmp , tmp2 , units_path , f_ignore_area , f_capture , f_ignore_civ , f_murder , f_mines , f_repair , f_heal , f_spacetime , f_attack_depot , f_crawl , mined , bombed , attacking , to_heal , healers , to_repair , repairs , empty_vehs , side ; begin
86237: LD_INT 0
86239: PPUSH
86240: PPUSH
86241: PPUSH
86242: PPUSH
86243: PPUSH
86244: PPUSH
86245: PPUSH
86246: PPUSH
86247: PPUSH
86248: PPUSH
86249: PPUSH
86250: PPUSH
86251: PPUSH
86252: PPUSH
86253: PPUSH
86254: PPUSH
86255: PPUSH
86256: PPUSH
86257: PPUSH
86258: PPUSH
86259: PPUSH
86260: PPUSH
86261: PPUSH
86262: PPUSH
86263: PPUSH
86264: PPUSH
86265: PPUSH
86266: PPUSH
86267: PPUSH
86268: PPUSH
86269: PPUSH
86270: PPUSH
86271: PPUSH
86272: PPUSH
// if not list then
86273: LD_VAR 0 1
86277: NOT
86278: IFFALSE 86282
// exit ;
86280: GO 90941
// base := list [ 1 ] ;
86282: LD_ADDR_VAR 0 3
86286: PUSH
86287: LD_VAR 0 1
86291: PUSH
86292: LD_INT 1
86294: ARRAY
86295: ST_TO_ADDR
// group := list [ 2 ] ;
86296: LD_ADDR_VAR 0 4
86300: PUSH
86301: LD_VAR 0 1
86305: PUSH
86306: LD_INT 2
86308: ARRAY
86309: ST_TO_ADDR
// path := list [ 3 ] ;
86310: LD_ADDR_VAR 0 5
86314: PUSH
86315: LD_VAR 0 1
86319: PUSH
86320: LD_INT 3
86322: ARRAY
86323: ST_TO_ADDR
// flags := list [ 4 ] ;
86324: LD_ADDR_VAR 0 6
86328: PUSH
86329: LD_VAR 0 1
86333: PUSH
86334: LD_INT 4
86336: ARRAY
86337: ST_TO_ADDR
// mined := [ ] ;
86338: LD_ADDR_VAR 0 27
86342: PUSH
86343: EMPTY
86344: ST_TO_ADDR
// bombed := [ ] ;
86345: LD_ADDR_VAR 0 28
86349: PUSH
86350: EMPTY
86351: ST_TO_ADDR
// healers := [ ] ;
86352: LD_ADDR_VAR 0 31
86356: PUSH
86357: EMPTY
86358: ST_TO_ADDR
// to_heal := [ ] ;
86359: LD_ADDR_VAR 0 30
86363: PUSH
86364: EMPTY
86365: ST_TO_ADDR
// repairs := [ ] ;
86366: LD_ADDR_VAR 0 33
86370: PUSH
86371: EMPTY
86372: ST_TO_ADDR
// to_repair := [ ] ;
86373: LD_ADDR_VAR 0 32
86377: PUSH
86378: EMPTY
86379: ST_TO_ADDR
// if not group or not path then
86380: LD_VAR 0 4
86384: NOT
86385: PUSH
86386: LD_VAR 0 5
86390: NOT
86391: OR
86392: IFFALSE 86396
// exit ;
86394: GO 90941
// side := GetSide ( group [ 1 ] ) ;
86396: LD_ADDR_VAR 0 35
86400: PUSH
86401: LD_VAR 0 4
86405: PUSH
86406: LD_INT 1
86408: ARRAY
86409: PPUSH
86410: CALL_OW 255
86414: ST_TO_ADDR
// if flags then
86415: LD_VAR 0 6
86419: IFFALSE 86563
// begin f_ignore_area := flags [ 1 ] ;
86421: LD_ADDR_VAR 0 17
86425: PUSH
86426: LD_VAR 0 6
86430: PUSH
86431: LD_INT 1
86433: ARRAY
86434: ST_TO_ADDR
// f_capture := flags [ 2 ] ;
86435: LD_ADDR_VAR 0 18
86439: PUSH
86440: LD_VAR 0 6
86444: PUSH
86445: LD_INT 2
86447: ARRAY
86448: ST_TO_ADDR
// f_ignore_civ := flags [ 3 ] ;
86449: LD_ADDR_VAR 0 19
86453: PUSH
86454: LD_VAR 0 6
86458: PUSH
86459: LD_INT 3
86461: ARRAY
86462: ST_TO_ADDR
// f_murder := flags [ 4 ] ;
86463: LD_ADDR_VAR 0 20
86467: PUSH
86468: LD_VAR 0 6
86472: PUSH
86473: LD_INT 4
86475: ARRAY
86476: ST_TO_ADDR
// f_mines := flags [ 5 ] ;
86477: LD_ADDR_VAR 0 21
86481: PUSH
86482: LD_VAR 0 6
86486: PUSH
86487: LD_INT 5
86489: ARRAY
86490: ST_TO_ADDR
// f_repair := flags [ 6 ] ;
86491: LD_ADDR_VAR 0 22
86495: PUSH
86496: LD_VAR 0 6
86500: PUSH
86501: LD_INT 6
86503: ARRAY
86504: ST_TO_ADDR
// f_heal := flags [ 7 ] ;
86505: LD_ADDR_VAR 0 23
86509: PUSH
86510: LD_VAR 0 6
86514: PUSH
86515: LD_INT 7
86517: ARRAY
86518: ST_TO_ADDR
// f_spacetime := flags [ 8 ] ;
86519: LD_ADDR_VAR 0 24
86523: PUSH
86524: LD_VAR 0 6
86528: PUSH
86529: LD_INT 8
86531: ARRAY
86532: ST_TO_ADDR
// f_attack_depot := flags [ 9 ] ;
86533: LD_ADDR_VAR 0 25
86537: PUSH
86538: LD_VAR 0 6
86542: PUSH
86543: LD_INT 9
86545: ARRAY
86546: ST_TO_ADDR
// f_crawl := flags [ 10 ] ;
86547: LD_ADDR_VAR 0 26
86551: PUSH
86552: LD_VAR 0 6
86556: PUSH
86557: LD_INT 10
86559: ARRAY
86560: ST_TO_ADDR
// end else
86561: GO 86643
// begin f_ignore_area := false ;
86563: LD_ADDR_VAR 0 17
86567: PUSH
86568: LD_INT 0
86570: ST_TO_ADDR
// f_capture := false ;
86571: LD_ADDR_VAR 0 18
86575: PUSH
86576: LD_INT 0
86578: ST_TO_ADDR
// f_ignore_civ := false ;
86579: LD_ADDR_VAR 0 19
86583: PUSH
86584: LD_INT 0
86586: ST_TO_ADDR
// f_murder := false ;
86587: LD_ADDR_VAR 0 20
86591: PUSH
86592: LD_INT 0
86594: ST_TO_ADDR
// f_mines := false ;
86595: LD_ADDR_VAR 0 21
86599: PUSH
86600: LD_INT 0
86602: ST_TO_ADDR
// f_repair := false ;
86603: LD_ADDR_VAR 0 22
86607: PUSH
86608: LD_INT 0
86610: ST_TO_ADDR
// f_heal := false ;
86611: LD_ADDR_VAR 0 23
86615: PUSH
86616: LD_INT 0
86618: ST_TO_ADDR
// f_spacetime := false ;
86619: LD_ADDR_VAR 0 24
86623: PUSH
86624: LD_INT 0
86626: ST_TO_ADDR
// f_attack_depot := false ;
86627: LD_ADDR_VAR 0 25
86631: PUSH
86632: LD_INT 0
86634: ST_TO_ADDR
// f_crawl := false ;
86635: LD_ADDR_VAR 0 26
86639: PUSH
86640: LD_INT 0
86642: ST_TO_ADDR
// end ; if f_heal then
86643: LD_VAR 0 23
86647: IFFALSE 86674
// healers := UnitFilter ( group , [ f_class , 4 ] ) ;
86649: LD_ADDR_VAR 0 31
86653: PUSH
86654: LD_VAR 0 4
86658: PPUSH
86659: LD_INT 25
86661: PUSH
86662: LD_INT 4
86664: PUSH
86665: EMPTY
86666: LIST
86667: LIST
86668: PPUSH
86669: CALL_OW 72
86673: ST_TO_ADDR
// if f_repair then
86674: LD_VAR 0 22
86678: IFFALSE 86705
// repairs := UnitFilter ( group , [ f_class , 3 ] ) ;
86680: LD_ADDR_VAR 0 33
86684: PUSH
86685: LD_VAR 0 4
86689: PPUSH
86690: LD_INT 25
86692: PUSH
86693: LD_INT 3
86695: PUSH
86696: EMPTY
86697: LIST
86698: LIST
86699: PPUSH
86700: CALL_OW 72
86704: ST_TO_ADDR
// units_path := [ ] ;
86705: LD_ADDR_VAR 0 16
86709: PUSH
86710: EMPTY
86711: ST_TO_ADDR
// for i = 1 to group do
86712: LD_ADDR_VAR 0 7
86716: PUSH
86717: DOUBLE
86718: LD_INT 1
86720: DEC
86721: ST_TO_ADDR
86722: LD_VAR 0 4
86726: PUSH
86727: FOR_TO
86728: IFFALSE 86757
// units_path := Replace ( units_path , i , path ) ;
86730: LD_ADDR_VAR 0 16
86734: PUSH
86735: LD_VAR 0 16
86739: PPUSH
86740: LD_VAR 0 7
86744: PPUSH
86745: LD_VAR 0 5
86749: PPUSH
86750: CALL_OW 1
86754: ST_TO_ADDR
86755: GO 86727
86757: POP
86758: POP
// repeat for i = group downto 1 do
86759: LD_ADDR_VAR 0 7
86763: PUSH
86764: DOUBLE
86765: LD_VAR 0 4
86769: INC
86770: ST_TO_ADDR
86771: LD_INT 1
86773: PUSH
86774: FOR_DOWNTO
86775: IFFALSE 90897
// begin wait ( 5 ) ;
86777: LD_INT 5
86779: PPUSH
86780: CALL_OW 67
// tmp := [ ] ;
86784: LD_ADDR_VAR 0 14
86788: PUSH
86789: EMPTY
86790: ST_TO_ADDR
// attacking := false ;
86791: LD_ADDR_VAR 0 29
86795: PUSH
86796: LD_INT 0
86798: ST_TO_ADDR
// if IsDead ( group [ i ] ) or not group [ i ] then
86799: LD_VAR 0 4
86803: PUSH
86804: LD_VAR 0 7
86808: ARRAY
86809: PPUSH
86810: CALL_OW 301
86814: PUSH
86815: LD_VAR 0 4
86819: PUSH
86820: LD_VAR 0 7
86824: ARRAY
86825: NOT
86826: OR
86827: IFFALSE 86936
// begin if GetType ( group [ i ] ) = unit_human then
86829: LD_VAR 0 4
86833: PUSH
86834: LD_VAR 0 7
86838: ARRAY
86839: PPUSH
86840: CALL_OW 247
86844: PUSH
86845: LD_INT 1
86847: EQUAL
86848: IFFALSE 86894
// begin to_heal := to_heal diff group [ i ] ;
86850: LD_ADDR_VAR 0 30
86854: PUSH
86855: LD_VAR 0 30
86859: PUSH
86860: LD_VAR 0 4
86864: PUSH
86865: LD_VAR 0 7
86869: ARRAY
86870: DIFF
86871: ST_TO_ADDR
// healers := healers diff group [ i ] ;
86872: LD_ADDR_VAR 0 31
86876: PUSH
86877: LD_VAR 0 31
86881: PUSH
86882: LD_VAR 0 4
86886: PUSH
86887: LD_VAR 0 7
86891: ARRAY
86892: DIFF
86893: ST_TO_ADDR
// end ; group := Delete ( group , i ) ;
86894: LD_ADDR_VAR 0 4
86898: PUSH
86899: LD_VAR 0 4
86903: PPUSH
86904: LD_VAR 0 7
86908: PPUSH
86909: CALL_OW 3
86913: ST_TO_ADDR
// units_path := Delete ( units_path , i ) ;
86914: LD_ADDR_VAR 0 16
86918: PUSH
86919: LD_VAR 0 16
86923: PPUSH
86924: LD_VAR 0 7
86928: PPUSH
86929: CALL_OW 3
86933: ST_TO_ADDR
// continue ;
86934: GO 86774
// end ; if f_repair then
86936: LD_VAR 0 22
86940: IFFALSE 87429
// begin if GetType ( group [ i ] ) = unit_vehicle then
86942: LD_VAR 0 4
86946: PUSH
86947: LD_VAR 0 7
86951: ARRAY
86952: PPUSH
86953: CALL_OW 247
86957: PUSH
86958: LD_INT 2
86960: EQUAL
86961: IFFALSE 87151
// begin if GetLives ( group [ i ] ) < 700 and not group [ i ] in to_repair then
86963: LD_VAR 0 4
86967: PUSH
86968: LD_VAR 0 7
86972: ARRAY
86973: PPUSH
86974: CALL_OW 256
86978: PUSH
86979: LD_INT 700
86981: LESS
86982: PUSH
86983: LD_VAR 0 4
86987: PUSH
86988: LD_VAR 0 7
86992: ARRAY
86993: PUSH
86994: LD_VAR 0 32
86998: IN
86999: NOT
87000: AND
87001: IFFALSE 87025
// to_repair := to_repair union group [ i ] ;
87003: LD_ADDR_VAR 0 32
87007: PUSH
87008: LD_VAR 0 32
87012: PUSH
87013: LD_VAR 0 4
87017: PUSH
87018: LD_VAR 0 7
87022: ARRAY
87023: UNION
87024: ST_TO_ADDR
// if GetLives ( group [ i ] ) = 1000 and group [ i ] in to_repair then
87025: LD_VAR 0 4
87029: PUSH
87030: LD_VAR 0 7
87034: ARRAY
87035: PPUSH
87036: CALL_OW 256
87040: PUSH
87041: LD_INT 1000
87043: EQUAL
87044: PUSH
87045: LD_VAR 0 4
87049: PUSH
87050: LD_VAR 0 7
87054: ARRAY
87055: PUSH
87056: LD_VAR 0 32
87060: IN
87061: AND
87062: IFFALSE 87086
// to_repair := to_repair diff group [ i ] ;
87064: LD_ADDR_VAR 0 32
87068: PUSH
87069: LD_VAR 0 32
87073: PUSH
87074: LD_VAR 0 4
87078: PUSH
87079: LD_VAR 0 7
87083: ARRAY
87084: DIFF
87085: ST_TO_ADDR
// if group [ i ] in to_repair then
87086: LD_VAR 0 4
87090: PUSH
87091: LD_VAR 0 7
87095: ARRAY
87096: PUSH
87097: LD_VAR 0 32
87101: IN
87102: IFFALSE 87149
// begin if not IsInArea ( group [ i ] , f_repair ) then
87104: LD_VAR 0 4
87108: PUSH
87109: LD_VAR 0 7
87113: ARRAY
87114: PPUSH
87115: LD_VAR 0 22
87119: PPUSH
87120: CALL_OW 308
87124: NOT
87125: IFFALSE 87147
// ComMoveToArea ( group [ i ] , f_repair ) ;
87127: LD_VAR 0 4
87131: PUSH
87132: LD_VAR 0 7
87136: ARRAY
87137: PPUSH
87138: LD_VAR 0 22
87142: PPUSH
87143: CALL_OW 113
// continue ;
87147: GO 86774
// end ; end else
87149: GO 87429
// if group [ i ] in repairs then
87151: LD_VAR 0 4
87155: PUSH
87156: LD_VAR 0 7
87160: ARRAY
87161: PUSH
87162: LD_VAR 0 33
87166: IN
87167: IFFALSE 87429
// begin if IsInUnit ( group [ i ] ) then
87169: LD_VAR 0 4
87173: PUSH
87174: LD_VAR 0 7
87178: ARRAY
87179: PPUSH
87180: CALL_OW 310
87184: IFFALSE 87252
// begin z := IsInUnit ( group [ i ] ) ;
87186: LD_ADDR_VAR 0 13
87190: PUSH
87191: LD_VAR 0 4
87195: PUSH
87196: LD_VAR 0 7
87200: ARRAY
87201: PPUSH
87202: CALL_OW 310
87206: ST_TO_ADDR
// if z in to_repair and IsInArea ( z , f_repair ) then
87207: LD_VAR 0 13
87211: PUSH
87212: LD_VAR 0 32
87216: IN
87217: PUSH
87218: LD_VAR 0 13
87222: PPUSH
87223: LD_VAR 0 22
87227: PPUSH
87228: CALL_OW 308
87232: AND
87233: IFFALSE 87250
// ComExitVehicle ( group [ i ] ) ;
87235: LD_VAR 0 4
87239: PUSH
87240: LD_VAR 0 7
87244: ARRAY
87245: PPUSH
87246: CALL_OW 121
// end else
87250: GO 87429
// begin z := UnitFilter ( group , [ [ f_inarea , f_repair ] , [ f_empty ] ] ) ;
87252: LD_ADDR_VAR 0 13
87256: PUSH
87257: LD_VAR 0 4
87261: PPUSH
87262: LD_INT 95
87264: PUSH
87265: LD_VAR 0 22
87269: PUSH
87270: EMPTY
87271: LIST
87272: LIST
87273: PUSH
87274: LD_INT 58
87276: PUSH
87277: EMPTY
87278: LIST
87279: PUSH
87280: EMPTY
87281: LIST
87282: LIST
87283: PPUSH
87284: CALL_OW 72
87288: ST_TO_ADDR
// if not HasTask ( group [ i ] ) then
87289: LD_VAR 0 4
87293: PUSH
87294: LD_VAR 0 7
87298: ARRAY
87299: PPUSH
87300: CALL_OW 314
87304: NOT
87305: IFFALSE 87427
// begin x := NearestUnitToUnit ( z , group [ i ] ) ;
87307: LD_ADDR_VAR 0 10
87311: PUSH
87312: LD_VAR 0 13
87316: PPUSH
87317: LD_VAR 0 4
87321: PUSH
87322: LD_VAR 0 7
87326: ARRAY
87327: PPUSH
87328: CALL_OW 74
87332: ST_TO_ADDR
// if not x then
87333: LD_VAR 0 10
87337: NOT
87338: IFFALSE 87342
// continue ;
87340: GO 86774
// if GetLives ( x ) < 1000 then
87342: LD_VAR 0 10
87346: PPUSH
87347: CALL_OW 256
87351: PUSH
87352: LD_INT 1000
87354: LESS
87355: IFFALSE 87379
// ComRepairVehicle ( group [ i ] , x ) else
87357: LD_VAR 0 4
87361: PUSH
87362: LD_VAR 0 7
87366: ARRAY
87367: PPUSH
87368: LD_VAR 0 10
87372: PPUSH
87373: CALL_OW 129
87377: GO 87427
// if not ( f_heal and GetLives ( group [ i ] ) < 1000 ) then
87379: LD_VAR 0 23
87383: PUSH
87384: LD_VAR 0 4
87388: PUSH
87389: LD_VAR 0 7
87393: ARRAY
87394: PPUSH
87395: CALL_OW 256
87399: PUSH
87400: LD_INT 1000
87402: LESS
87403: AND
87404: NOT
87405: IFFALSE 87427
// ComEnterUnit ( group [ i ] , x ) ;
87407: LD_VAR 0 4
87411: PUSH
87412: LD_VAR 0 7
87416: ARRAY
87417: PPUSH
87418: LD_VAR 0 10
87422: PPUSH
87423: CALL_OW 120
// end ; continue ;
87427: GO 86774
// end ; end ; end ; if f_heal and GetType ( group [ i ] ) = unit_human then
87429: LD_VAR 0 23
87433: PUSH
87434: LD_VAR 0 4
87438: PUSH
87439: LD_VAR 0 7
87443: ARRAY
87444: PPUSH
87445: CALL_OW 247
87449: PUSH
87450: LD_INT 1
87452: EQUAL
87453: AND
87454: IFFALSE 87932
// begin if group [ i ] in healers then
87456: LD_VAR 0 4
87460: PUSH
87461: LD_VAR 0 7
87465: ARRAY
87466: PUSH
87467: LD_VAR 0 31
87471: IN
87472: IFFALSE 87745
// begin if not IsInArea ( group [ i ] , f_heal ) and not HasTask ( group [ i ] ) then
87474: LD_VAR 0 4
87478: PUSH
87479: LD_VAR 0 7
87483: ARRAY
87484: PPUSH
87485: LD_VAR 0 23
87489: PPUSH
87490: CALL_OW 308
87494: NOT
87495: PUSH
87496: LD_VAR 0 4
87500: PUSH
87501: LD_VAR 0 7
87505: ARRAY
87506: PPUSH
87507: CALL_OW 314
87511: NOT
87512: AND
87513: IFFALSE 87537
// ComMoveToArea ( group [ i ] , f_heal ) else
87515: LD_VAR 0 4
87519: PUSH
87520: LD_VAR 0 7
87524: ARRAY
87525: PPUSH
87526: LD_VAR 0 23
87530: PPUSH
87531: CALL_OW 113
87535: GO 87743
// if GetLives ( HealTarget ( group [ i ] ) ) = 1000 then
87537: LD_VAR 0 4
87541: PUSH
87542: LD_VAR 0 7
87546: ARRAY
87547: PPUSH
87548: CALL 86155 0 1
87552: PPUSH
87553: CALL_OW 256
87557: PUSH
87558: LD_INT 1000
87560: EQUAL
87561: IFFALSE 87580
// ComStop ( group [ i ] ) else
87563: LD_VAR 0 4
87567: PUSH
87568: LD_VAR 0 7
87572: ARRAY
87573: PPUSH
87574: CALL_OW 141
87578: GO 87743
// if not HasTask ( group [ i ] ) and to_heal then
87580: LD_VAR 0 4
87584: PUSH
87585: LD_VAR 0 7
87589: ARRAY
87590: PPUSH
87591: CALL_OW 314
87595: NOT
87596: PUSH
87597: LD_VAR 0 30
87601: AND
87602: IFFALSE 87743
// begin z := NearestUnitToUnit ( UnitFilter ( to_heal , [ f_not , [ f_inside ] ] ) , group [ i ] ) ;
87604: LD_ADDR_VAR 0 13
87608: PUSH
87609: LD_VAR 0 30
87613: PPUSH
87614: LD_INT 3
87616: PUSH
87617: LD_INT 54
87619: PUSH
87620: EMPTY
87621: LIST
87622: PUSH
87623: EMPTY
87624: LIST
87625: LIST
87626: PPUSH
87627: CALL_OW 72
87631: PPUSH
87632: LD_VAR 0 4
87636: PUSH
87637: LD_VAR 0 7
87641: ARRAY
87642: PPUSH
87643: CALL_OW 74
87647: ST_TO_ADDR
// if z then
87648: LD_VAR 0 13
87652: IFFALSE 87743
// if FilterAllUnits ( [ [ f_dist , z , 10 ] , [ f_enemy , GetSide ( z ) ] ] ) = 0 then
87654: LD_INT 91
87656: PUSH
87657: LD_VAR 0 13
87661: PUSH
87662: LD_INT 10
87664: PUSH
87665: EMPTY
87666: LIST
87667: LIST
87668: LIST
87669: PUSH
87670: LD_INT 81
87672: PUSH
87673: LD_VAR 0 13
87677: PPUSH
87678: CALL_OW 255
87682: PUSH
87683: EMPTY
87684: LIST
87685: LIST
87686: PUSH
87687: EMPTY
87688: LIST
87689: LIST
87690: PPUSH
87691: CALL_OW 69
87695: PUSH
87696: LD_INT 0
87698: EQUAL
87699: IFFALSE 87723
// ComHeal ( group [ i ] , z ) else
87701: LD_VAR 0 4
87705: PUSH
87706: LD_VAR 0 7
87710: ARRAY
87711: PPUSH
87712: LD_VAR 0 13
87716: PPUSH
87717: CALL_OW 128
87721: GO 87743
// ComMoveToArea ( group [ i ] , f_heal ) ;
87723: LD_VAR 0 4
87727: PUSH
87728: LD_VAR 0 7
87732: ARRAY
87733: PPUSH
87734: LD_VAR 0 23
87738: PPUSH
87739: CALL_OW 113
// end ; continue ;
87743: GO 86774
// end ; if GetLives ( group [ i ] ) < 700 and not group [ i ] in to_heal then
87745: LD_VAR 0 4
87749: PUSH
87750: LD_VAR 0 7
87754: ARRAY
87755: PPUSH
87756: CALL_OW 256
87760: PUSH
87761: LD_INT 700
87763: LESS
87764: PUSH
87765: LD_VAR 0 4
87769: PUSH
87770: LD_VAR 0 7
87774: ARRAY
87775: PUSH
87776: LD_VAR 0 30
87780: IN
87781: NOT
87782: AND
87783: IFFALSE 87807
// to_heal := to_heal union group [ i ] ;
87785: LD_ADDR_VAR 0 30
87789: PUSH
87790: LD_VAR 0 30
87794: PUSH
87795: LD_VAR 0 4
87799: PUSH
87800: LD_VAR 0 7
87804: ARRAY
87805: UNION
87806: ST_TO_ADDR
// if group [ i ] in to_heal then
87807: LD_VAR 0 4
87811: PUSH
87812: LD_VAR 0 7
87816: ARRAY
87817: PUSH
87818: LD_VAR 0 30
87822: IN
87823: IFFALSE 87932
// begin if GetLives ( group [ i ] ) = 1000 then
87825: LD_VAR 0 4
87829: PUSH
87830: LD_VAR 0 7
87834: ARRAY
87835: PPUSH
87836: CALL_OW 256
87840: PUSH
87841: LD_INT 1000
87843: EQUAL
87844: IFFALSE 87870
// to_heal := to_heal diff group [ i ] else
87846: LD_ADDR_VAR 0 30
87850: PUSH
87851: LD_VAR 0 30
87855: PUSH
87856: LD_VAR 0 4
87860: PUSH
87861: LD_VAR 0 7
87865: ARRAY
87866: DIFF
87867: ST_TO_ADDR
87868: GO 87932
// begin if not IsInArea ( group [ i ] , to_heal ) then
87870: LD_VAR 0 4
87874: PUSH
87875: LD_VAR 0 7
87879: ARRAY
87880: PPUSH
87881: LD_VAR 0 30
87885: PPUSH
87886: CALL_OW 308
87890: NOT
87891: IFFALSE 87915
// ComMoveToArea ( group [ i ] , f_heal ) else
87893: LD_VAR 0 4
87897: PUSH
87898: LD_VAR 0 7
87902: ARRAY
87903: PPUSH
87904: LD_VAR 0 23
87908: PPUSH
87909: CALL_OW 113
87913: GO 87930
// ComHold ( group [ i ] ) ;
87915: LD_VAR 0 4
87919: PUSH
87920: LD_VAR 0 7
87924: ARRAY
87925: PPUSH
87926: CALL_OW 140
// continue ;
87930: GO 86774
// end ; end ; end ; if not EnemyInRange ( group [ i ] , 10 ) and not units_path [ i ] = [ ] then
87932: LD_VAR 0 4
87936: PUSH
87937: LD_VAR 0 7
87941: ARRAY
87942: PPUSH
87943: LD_INT 10
87945: PPUSH
87946: CALL 84575 0 2
87950: NOT
87951: PUSH
87952: LD_VAR 0 16
87956: PUSH
87957: LD_VAR 0 7
87961: ARRAY
87962: PUSH
87963: EMPTY
87964: EQUAL
87965: NOT
87966: AND
87967: IFFALSE 88233
// begin if GetEngine ( group [ i ] ) in [ engine_combustion , engine_solar ] then
87969: LD_VAR 0 4
87973: PUSH
87974: LD_VAR 0 7
87978: ARRAY
87979: PPUSH
87980: CALL_OW 262
87984: PUSH
87985: LD_INT 1
87987: PUSH
87988: LD_INT 2
87990: PUSH
87991: EMPTY
87992: LIST
87993: LIST
87994: IN
87995: IFFALSE 88036
// if GetFuel ( group [ i ] ) < 10 then
87997: LD_VAR 0 4
88001: PUSH
88002: LD_VAR 0 7
88006: ARRAY
88007: PPUSH
88008: CALL_OW 261
88012: PUSH
88013: LD_INT 10
88015: LESS
88016: IFFALSE 88036
// SetFuel ( group [ i ] , 12 ) ;
88018: LD_VAR 0 4
88022: PUSH
88023: LD_VAR 0 7
88027: ARRAY
88028: PPUSH
88029: LD_INT 12
88031: PPUSH
88032: CALL_OW 240
// if units_path [ i ] then
88036: LD_VAR 0 16
88040: PUSH
88041: LD_VAR 0 7
88045: ARRAY
88046: IFFALSE 88231
// begin if GetDistUnitXY ( group [ i ] , units_path [ i ] [ 1 ] [ 1 ] , units_path [ i ] [ 1 ] [ 2 ] ) > 6 then
88048: LD_VAR 0 4
88052: PUSH
88053: LD_VAR 0 7
88057: ARRAY
88058: PPUSH
88059: LD_VAR 0 16
88063: PUSH
88064: LD_VAR 0 7
88068: ARRAY
88069: PUSH
88070: LD_INT 1
88072: ARRAY
88073: PUSH
88074: LD_INT 1
88076: ARRAY
88077: PPUSH
88078: LD_VAR 0 16
88082: PUSH
88083: LD_VAR 0 7
88087: ARRAY
88088: PUSH
88089: LD_INT 1
88091: ARRAY
88092: PUSH
88093: LD_INT 2
88095: ARRAY
88096: PPUSH
88097: CALL_OW 297
88101: PUSH
88102: LD_INT 6
88104: GREATER
88105: IFFALSE 88180
// begin if not HasTask ( group [ i ] ) then
88107: LD_VAR 0 4
88111: PUSH
88112: LD_VAR 0 7
88116: ARRAY
88117: PPUSH
88118: CALL_OW 314
88122: NOT
88123: IFFALSE 88178
// ComAgressiveMove ( group [ i ] , units_path [ i ] [ 1 ] [ 1 ] , units_path [ i ] [ 1 ] [ 2 ] ) ;
88125: LD_VAR 0 4
88129: PUSH
88130: LD_VAR 0 7
88134: ARRAY
88135: PPUSH
88136: LD_VAR 0 16
88140: PUSH
88141: LD_VAR 0 7
88145: ARRAY
88146: PUSH
88147: LD_INT 1
88149: ARRAY
88150: PUSH
88151: LD_INT 1
88153: ARRAY
88154: PPUSH
88155: LD_VAR 0 16
88159: PUSH
88160: LD_VAR 0 7
88164: ARRAY
88165: PUSH
88166: LD_INT 1
88168: ARRAY
88169: PUSH
88170: LD_INT 2
88172: ARRAY
88173: PPUSH
88174: CALL_OW 114
// end else
88178: GO 88231
// begin tmp2 := Delete ( units_path [ i ] , 1 ) ;
88180: LD_ADDR_VAR 0 15
88184: PUSH
88185: LD_VAR 0 16
88189: PUSH
88190: LD_VAR 0 7
88194: ARRAY
88195: PPUSH
88196: LD_INT 1
88198: PPUSH
88199: CALL_OW 3
88203: ST_TO_ADDR
// units_path := Replace ( units_path , i , tmp2 ) ;
88204: LD_ADDR_VAR 0 16
88208: PUSH
88209: LD_VAR 0 16
88213: PPUSH
88214: LD_VAR 0 7
88218: PPUSH
88219: LD_VAR 0 15
88223: PPUSH
88224: CALL_OW 1
88228: ST_TO_ADDR
// continue ;
88229: GO 86774
// end ; end ; end else
88231: GO 90895
// begin tmp := FilterAllUnits ( [ f_enemy , GetSide ( group [ i ] ) ] ) ;
88233: LD_ADDR_VAR 0 14
88237: PUSH
88238: LD_INT 81
88240: PUSH
88241: LD_VAR 0 4
88245: PUSH
88246: LD_VAR 0 7
88250: ARRAY
88251: PPUSH
88252: CALL_OW 255
88256: PUSH
88257: EMPTY
88258: LIST
88259: LIST
88260: PPUSH
88261: CALL_OW 69
88265: ST_TO_ADDR
// if not tmp then
88266: LD_VAR 0 14
88270: NOT
88271: IFFALSE 88275
// continue ;
88273: GO 86774
// if f_ignore_area then
88275: LD_VAR 0 17
88279: IFFALSE 88367
// begin tmp2 := UnitFilter ( tmp , [ f_not , [ f_distxy , f_ignore_area [ 1 ] , f_ignore_area [ 2 ] , f_ignore_area [ 3 ] ] ] ) ;
88281: LD_ADDR_VAR 0 15
88285: PUSH
88286: LD_VAR 0 14
88290: PPUSH
88291: LD_INT 3
88293: PUSH
88294: LD_INT 92
88296: PUSH
88297: LD_VAR 0 17
88301: PUSH
88302: LD_INT 1
88304: ARRAY
88305: PUSH
88306: LD_VAR 0 17
88310: PUSH
88311: LD_INT 2
88313: ARRAY
88314: PUSH
88315: LD_VAR 0 17
88319: PUSH
88320: LD_INT 3
88322: ARRAY
88323: PUSH
88324: EMPTY
88325: LIST
88326: LIST
88327: LIST
88328: LIST
88329: PUSH
88330: EMPTY
88331: LIST
88332: LIST
88333: PPUSH
88334: CALL_OW 72
88338: ST_TO_ADDR
// if ( tmp diff tmp2 ) then
88339: LD_VAR 0 14
88343: PUSH
88344: LD_VAR 0 15
88348: DIFF
88349: IFFALSE 88367
// tmp := tmp diff tmp2 ;
88351: LD_ADDR_VAR 0 14
88355: PUSH
88356: LD_VAR 0 14
88360: PUSH
88361: LD_VAR 0 15
88365: DIFF
88366: ST_TO_ADDR
// end ; if not f_murder then
88367: LD_VAR 0 20
88371: NOT
88372: IFFALSE 88430
// begin tmp2 := UnitFilter ( tmp , [ f_not , [ f_ok ] ] ) ;
88374: LD_ADDR_VAR 0 15
88378: PUSH
88379: LD_VAR 0 14
88383: PPUSH
88384: LD_INT 3
88386: PUSH
88387: LD_INT 50
88389: PUSH
88390: EMPTY
88391: LIST
88392: PUSH
88393: EMPTY
88394: LIST
88395: LIST
88396: PPUSH
88397: CALL_OW 72
88401: ST_TO_ADDR
// if ( tmp diff tmp2 ) then
88402: LD_VAR 0 14
88406: PUSH
88407: LD_VAR 0 15
88411: DIFF
88412: IFFALSE 88430
// tmp := tmp diff tmp2 ;
88414: LD_ADDR_VAR 0 14
88418: PUSH
88419: LD_VAR 0 14
88423: PUSH
88424: LD_VAR 0 15
88428: DIFF
88429: ST_TO_ADDR
// end ; tmp := SortByDistanceUnit ( group [ i ] , tmp , true , true ) ;
88430: LD_ADDR_VAR 0 14
88434: PUSH
88435: LD_VAR 0 4
88439: PUSH
88440: LD_VAR 0 7
88444: ARRAY
88445: PPUSH
88446: LD_VAR 0 14
88450: PPUSH
88451: LD_INT 1
88453: PPUSH
88454: LD_INT 1
88456: PPUSH
88457: CALL 58218 0 4
88461: ST_TO_ADDR
// if GetClass ( group [ i ] ) = 1 then
88462: LD_VAR 0 4
88466: PUSH
88467: LD_VAR 0 7
88471: ARRAY
88472: PPUSH
88473: CALL_OW 257
88477: PUSH
88478: LD_INT 1
88480: EQUAL
88481: IFFALSE 88929
// begin if WantPlant ( group [ i ] ) then
88483: LD_VAR 0 4
88487: PUSH
88488: LD_VAR 0 7
88492: ARRAY
88493: PPUSH
88494: CALL 57719 0 1
88498: IFFALSE 88502
// continue ;
88500: GO 86774
// if f_capture and not IsInUnit ( group [ i ] ) and tmp [ 1 ] in UnitFilter ( tmp , [ [ f_type , unit_vehicle ] , [ f_empty ] ] ) then
88502: LD_VAR 0 18
88506: PUSH
88507: LD_VAR 0 4
88511: PUSH
88512: LD_VAR 0 7
88516: ARRAY
88517: PPUSH
88518: CALL_OW 310
88522: NOT
88523: AND
88524: PUSH
88525: LD_VAR 0 14
88529: PUSH
88530: LD_INT 1
88532: ARRAY
88533: PUSH
88534: LD_VAR 0 14
88538: PPUSH
88539: LD_INT 21
88541: PUSH
88542: LD_INT 2
88544: PUSH
88545: EMPTY
88546: LIST
88547: LIST
88548: PUSH
88549: LD_INT 58
88551: PUSH
88552: EMPTY
88553: LIST
88554: PUSH
88555: EMPTY
88556: LIST
88557: LIST
88558: PPUSH
88559: CALL_OW 72
88563: IN
88564: AND
88565: IFFALSE 88601
// begin ComEnterUnit ( group [ i ] , tmp [ 1 ] ) ;
88567: LD_VAR 0 4
88571: PUSH
88572: LD_VAR 0 7
88576: ARRAY
88577: PPUSH
88578: LD_VAR 0 14
88582: PUSH
88583: LD_INT 1
88585: ARRAY
88586: PPUSH
88587: CALL_OW 120
// attacking := true ;
88591: LD_ADDR_VAR 0 29
88595: PUSH
88596: LD_INT 1
88598: ST_TO_ADDR
// continue ;
88599: GO 86774
// end ; if f_crawl and GetClass ( group [ i ] ) = 1 and GetLives ( group [ i ] ) < 800 and not Crawls ( group [ i ] ) then
88601: LD_VAR 0 26
88605: PUSH
88606: LD_VAR 0 4
88610: PUSH
88611: LD_VAR 0 7
88615: ARRAY
88616: PPUSH
88617: CALL_OW 257
88621: PUSH
88622: LD_INT 1
88624: EQUAL
88625: AND
88626: PUSH
88627: LD_VAR 0 4
88631: PUSH
88632: LD_VAR 0 7
88636: ARRAY
88637: PPUSH
88638: CALL_OW 256
88642: PUSH
88643: LD_INT 800
88645: LESS
88646: AND
88647: PUSH
88648: LD_VAR 0 4
88652: PUSH
88653: LD_VAR 0 7
88657: ARRAY
88658: PPUSH
88659: CALL_OW 318
88663: NOT
88664: AND
88665: IFFALSE 88682
// ComCrawl ( group [ i ] ) ;
88667: LD_VAR 0 4
88671: PUSH
88672: LD_VAR 0 7
88676: ARRAY
88677: PPUSH
88678: CALL_OW 137
// if f_mines then
88682: LD_VAR 0 21
88686: IFFALSE 88929
// begin if GetType ( tmp [ 1 ] ) = unit_building and not tmp [ 1 ] in mined then
88688: LD_VAR 0 14
88692: PUSH
88693: LD_INT 1
88695: ARRAY
88696: PPUSH
88697: CALL_OW 247
88701: PUSH
88702: LD_INT 3
88704: EQUAL
88705: PUSH
88706: LD_VAR 0 14
88710: PUSH
88711: LD_INT 1
88713: ARRAY
88714: PUSH
88715: LD_VAR 0 27
88719: IN
88720: NOT
88721: AND
88722: IFFALSE 88929
// begin x := GetX ( tmp [ 1 ] ) ;
88724: LD_ADDR_VAR 0 10
88728: PUSH
88729: LD_VAR 0 14
88733: PUSH
88734: LD_INT 1
88736: ARRAY
88737: PPUSH
88738: CALL_OW 250
88742: ST_TO_ADDR
// y := GetY ( tmp [ 1 ] ) ;
88743: LD_ADDR_VAR 0 11
88747: PUSH
88748: LD_VAR 0 14
88752: PUSH
88753: LD_INT 1
88755: ARRAY
88756: PPUSH
88757: CALL_OW 251
88761: ST_TO_ADDR
// d := ReverseDir ( group [ i ] ) ;
88762: LD_ADDR_VAR 0 12
88766: PUSH
88767: LD_VAR 0 4
88771: PUSH
88772: LD_VAR 0 7
88776: ARRAY
88777: PPUSH
88778: CALL 84660 0 1
88782: ST_TO_ADDR
// ComPlaceDelayedCharge ( group [ i ] , x , y , tmp [ 1 ] ) ;
88783: LD_VAR 0 4
88787: PUSH
88788: LD_VAR 0 7
88792: ARRAY
88793: PPUSH
88794: LD_VAR 0 10
88798: PPUSH
88799: LD_VAR 0 11
88803: PPUSH
88804: LD_VAR 0 14
88808: PUSH
88809: LD_INT 1
88811: ARRAY
88812: PPUSH
88813: CALL_OW 132
// AddComMoveXY ( group [ i ] , ShiftX ( x , d , 7 ) , ShiftY ( y , d , 7 ) ) ;
88817: LD_VAR 0 4
88821: PUSH
88822: LD_VAR 0 7
88826: ARRAY
88827: PPUSH
88828: LD_VAR 0 10
88832: PPUSH
88833: LD_VAR 0 12
88837: PPUSH
88838: LD_INT 7
88840: PPUSH
88841: CALL_OW 272
88845: PPUSH
88846: LD_VAR 0 11
88850: PPUSH
88851: LD_VAR 0 12
88855: PPUSH
88856: LD_INT 7
88858: PPUSH
88859: CALL_OW 273
88863: PPUSH
88864: CALL_OW 171
// SetTag ( group [ i ] , 71 ) ;
88868: LD_VAR 0 4
88872: PUSH
88873: LD_VAR 0 7
88877: ARRAY
88878: PPUSH
88879: LD_INT 71
88881: PPUSH
88882: CALL_OW 109
// mined := Replace ( mined , mined + 1 , tmp [ 1 ] ) ;
88886: LD_ADDR_VAR 0 27
88890: PUSH
88891: LD_VAR 0 27
88895: PPUSH
88896: LD_VAR 0 27
88900: PUSH
88901: LD_INT 1
88903: PLUS
88904: PPUSH
88905: LD_VAR 0 14
88909: PUSH
88910: LD_INT 1
88912: ARRAY
88913: PPUSH
88914: CALL_OW 1
88918: ST_TO_ADDR
// attacking := true ;
88919: LD_ADDR_VAR 0 29
88923: PUSH
88924: LD_INT 1
88926: ST_TO_ADDR
// continue ;
88927: GO 86774
// end ; end ; end ; if GetClass ( group [ i ] ) = 17 and not GetTag ( group [ i ] ) = 71 then
88929: LD_VAR 0 4
88933: PUSH
88934: LD_VAR 0 7
88938: ARRAY
88939: PPUSH
88940: CALL_OW 257
88944: PUSH
88945: LD_INT 17
88947: EQUAL
88948: PUSH
88949: LD_VAR 0 4
88953: PUSH
88954: LD_VAR 0 7
88958: ARRAY
88959: PPUSH
88960: CALL_OW 110
88964: PUSH
88965: LD_INT 71
88967: EQUAL
88968: NOT
88969: AND
88970: IFFALSE 89116
// begin attacking := false ;
88972: LD_ADDR_VAR 0 29
88976: PUSH
88977: LD_INT 0
88979: ST_TO_ADDR
// k := 5 ;
88980: LD_ADDR_VAR 0 9
88984: PUSH
88985: LD_INT 5
88987: ST_TO_ADDR
// if tmp < k then
88988: LD_VAR 0 14
88992: PUSH
88993: LD_VAR 0 9
88997: LESS
88998: IFFALSE 89010
// k := tmp ;
89000: LD_ADDR_VAR 0 9
89004: PUSH
89005: LD_VAR 0 14
89009: ST_TO_ADDR
// for j = 1 to k do
89010: LD_ADDR_VAR 0 8
89014: PUSH
89015: DOUBLE
89016: LD_INT 1
89018: DEC
89019: ST_TO_ADDR
89020: LD_VAR 0 9
89024: PUSH
89025: FOR_TO
89026: IFFALSE 89114
// begin if not tmp [ j ] in UnitFilter ( tmp , [ f_empty ] ) then
89028: LD_VAR 0 14
89032: PUSH
89033: LD_VAR 0 8
89037: ARRAY
89038: PUSH
89039: LD_VAR 0 14
89043: PPUSH
89044: LD_INT 58
89046: PUSH
89047: EMPTY
89048: LIST
89049: PPUSH
89050: CALL_OW 72
89054: IN
89055: NOT
89056: IFFALSE 89112
// begin ComAttackUnit ( group [ i ] , tmp [ j ] ) ;
89058: LD_VAR 0 4
89062: PUSH
89063: LD_VAR 0 7
89067: ARRAY
89068: PPUSH
89069: LD_VAR 0 14
89073: PUSH
89074: LD_VAR 0 8
89078: ARRAY
89079: PPUSH
89080: CALL_OW 115
// attacking := true ;
89084: LD_ADDR_VAR 0 29
89088: PUSH
89089: LD_INT 1
89091: ST_TO_ADDR
// SetTag ( group [ i ] , 71 ) ;
89092: LD_VAR 0 4
89096: PUSH
89097: LD_VAR 0 7
89101: ARRAY
89102: PPUSH
89103: LD_INT 71
89105: PPUSH
89106: CALL_OW 109
// continue ;
89110: GO 89025
// end ; end ;
89112: GO 89025
89114: POP
89115: POP
// end ; if GetClass ( group [ i ] ) = 8 or GetWeapon ( group [ i ] ) in [ ar_rocket_launcher , ru_rocket_launcher , us_rocket_launcher , ru_rocket ] then
89116: LD_VAR 0 4
89120: PUSH
89121: LD_VAR 0 7
89125: ARRAY
89126: PPUSH
89127: CALL_OW 257
89131: PUSH
89132: LD_INT 8
89134: EQUAL
89135: PUSH
89136: LD_VAR 0 4
89140: PUSH
89141: LD_VAR 0 7
89145: ARRAY
89146: PPUSH
89147: CALL_OW 264
89151: PUSH
89152: LD_INT 28
89154: PUSH
89155: LD_INT 45
89157: PUSH
89158: LD_INT 7
89160: PUSH
89161: LD_INT 47
89163: PUSH
89164: EMPTY
89165: LIST
89166: LIST
89167: LIST
89168: LIST
89169: IN
89170: OR
89171: IFFALSE 89427
// begin attacking := false ;
89173: LD_ADDR_VAR 0 29
89177: PUSH
89178: LD_INT 0
89180: ST_TO_ADDR
// if GetBType ( tmp [ 1 ] ) in [ b_bunker , b_breastwork , b_turret , b_armoury , b_barracks ] then
89181: LD_VAR 0 14
89185: PUSH
89186: LD_INT 1
89188: ARRAY
89189: PPUSH
89190: CALL_OW 266
89194: PUSH
89195: LD_INT 32
89197: PUSH
89198: LD_INT 31
89200: PUSH
89201: LD_INT 33
89203: PUSH
89204: LD_INT 4
89206: PUSH
89207: LD_INT 5
89209: PUSH
89210: EMPTY
89211: LIST
89212: LIST
89213: LIST
89214: LIST
89215: LIST
89216: IN
89217: IFFALSE 89403
// begin k := GetBuildingHexes ( GetBType ( tmp [ 1 ] ) , GetX ( tmp [ 1 ] ) , GetY ( tmp [ 1 ] ) , GetDir ( tmp [ 1 ] ) , GetNation ( tmp [ 1 ] ) , 0 ) ;
89219: LD_ADDR_VAR 0 9
89223: PUSH
89224: LD_VAR 0 14
89228: PUSH
89229: LD_INT 1
89231: ARRAY
89232: PPUSH
89233: CALL_OW 266
89237: PPUSH
89238: LD_VAR 0 14
89242: PUSH
89243: LD_INT 1
89245: ARRAY
89246: PPUSH
89247: CALL_OW 250
89251: PPUSH
89252: LD_VAR 0 14
89256: PUSH
89257: LD_INT 1
89259: ARRAY
89260: PPUSH
89261: CALL_OW 251
89265: PPUSH
89266: LD_VAR 0 14
89270: PUSH
89271: LD_INT 1
89273: ARRAY
89274: PPUSH
89275: CALL_OW 254
89279: PPUSH
89280: LD_VAR 0 14
89284: PUSH
89285: LD_INT 1
89287: ARRAY
89288: PPUSH
89289: CALL_OW 248
89293: PPUSH
89294: LD_INT 0
89296: PPUSH
89297: CALL 66030 0 6
89301: ST_TO_ADDR
// j := GetClosestHex ( group [ i ] , k ) ;
89302: LD_ADDR_VAR 0 8
89306: PUSH
89307: LD_VAR 0 4
89311: PUSH
89312: LD_VAR 0 7
89316: ARRAY
89317: PPUSH
89318: LD_VAR 0 9
89322: PPUSH
89323: CALL 84700 0 2
89327: ST_TO_ADDR
// if j then
89328: LD_VAR 0 8
89332: IFFALSE 89401
// if ValidHex ( j [ 1 ] , j [ 2 ] ) then
89334: LD_VAR 0 8
89338: PUSH
89339: LD_INT 1
89341: ARRAY
89342: PPUSH
89343: LD_VAR 0 8
89347: PUSH
89348: LD_INT 2
89350: ARRAY
89351: PPUSH
89352: CALL_OW 488
89356: IFFALSE 89401
// begin ComAttackPlace ( group [ i ] , j [ 1 ] , j [ 2 ] ) ;
89358: LD_VAR 0 4
89362: PUSH
89363: LD_VAR 0 7
89367: ARRAY
89368: PPUSH
89369: LD_VAR 0 8
89373: PUSH
89374: LD_INT 1
89376: ARRAY
89377: PPUSH
89378: LD_VAR 0 8
89382: PUSH
89383: LD_INT 2
89385: ARRAY
89386: PPUSH
89387: CALL_OW 116
// attacking := true ;
89391: LD_ADDR_VAR 0 29
89395: PUSH
89396: LD_INT 1
89398: ST_TO_ADDR
// continue ;
89399: GO 86774
// end ; end else
89401: GO 89427
// ComAttackUnit ( group [ i ] , tmp [ 1 ] ) ;
89403: LD_VAR 0 4
89407: PUSH
89408: LD_VAR 0 7
89412: ARRAY
89413: PPUSH
89414: LD_VAR 0 14
89418: PUSH
89419: LD_INT 1
89421: ARRAY
89422: PPUSH
89423: CALL_OW 115
// end ; if GetChassis ( group [ i ] ) = ar_hovercraft then
89427: LD_VAR 0 4
89431: PUSH
89432: LD_VAR 0 7
89436: ARRAY
89437: PPUSH
89438: CALL_OW 265
89442: PUSH
89443: LD_INT 11
89445: EQUAL
89446: IFFALSE 89724
// begin k := 10 ;
89448: LD_ADDR_VAR 0 9
89452: PUSH
89453: LD_INT 10
89455: ST_TO_ADDR
// x := 0 ;
89456: LD_ADDR_VAR 0 10
89460: PUSH
89461: LD_INT 0
89463: ST_TO_ADDR
// if tmp < k then
89464: LD_VAR 0 14
89468: PUSH
89469: LD_VAR 0 9
89473: LESS
89474: IFFALSE 89486
// k := tmp ;
89476: LD_ADDR_VAR 0 9
89480: PUSH
89481: LD_VAR 0 14
89485: ST_TO_ADDR
// for j = k downto 1 do
89486: LD_ADDR_VAR 0 8
89490: PUSH
89491: DOUBLE
89492: LD_VAR 0 9
89496: INC
89497: ST_TO_ADDR
89498: LD_INT 1
89500: PUSH
89501: FOR_DOWNTO
89502: IFFALSE 89577
// begin if GetType ( tmp [ j ] ) = unit_human then
89504: LD_VAR 0 14
89508: PUSH
89509: LD_VAR 0 8
89513: ARRAY
89514: PPUSH
89515: CALL_OW 247
89519: PUSH
89520: LD_INT 1
89522: EQUAL
89523: IFFALSE 89575
// begin AttackHovercraft ( group [ i ] , tmp [ j ] ) ;
89525: LD_VAR 0 4
89529: PUSH
89530: LD_VAR 0 7
89534: ARRAY
89535: PPUSH
89536: LD_VAR 0 14
89540: PUSH
89541: LD_VAR 0 8
89545: ARRAY
89546: PPUSH
89547: CALL 84971 0 2
// x := tmp [ j ] ;
89551: LD_ADDR_VAR 0 10
89555: PUSH
89556: LD_VAR 0 14
89560: PUSH
89561: LD_VAR 0 8
89565: ARRAY
89566: ST_TO_ADDR
// attacking := true ;
89567: LD_ADDR_VAR 0 29
89571: PUSH
89572: LD_INT 1
89574: ST_TO_ADDR
// end ; end ;
89575: GO 89501
89577: POP
89578: POP
// if not x then
89579: LD_VAR 0 10
89583: NOT
89584: IFFALSE 89724
// begin attacking := true ;
89586: LD_ADDR_VAR 0 29
89590: PUSH
89591: LD_INT 1
89593: ST_TO_ADDR
// if GetHexInfo ( GetX ( group [ i ] ) , GetY ( group [ i ] ) ) [ 2 ] = GetHexInfo ( GetX ( tmp [ 1 ] ) , GetY ( tmp [ 1 ] ) ) [ 2 ] then
89594: LD_VAR 0 4
89598: PUSH
89599: LD_VAR 0 7
89603: ARRAY
89604: PPUSH
89605: CALL_OW 250
89609: PPUSH
89610: LD_VAR 0 4
89614: PUSH
89615: LD_VAR 0 7
89619: ARRAY
89620: PPUSH
89621: CALL_OW 251
89625: PPUSH
89626: CALL_OW 546
89630: PUSH
89631: LD_INT 2
89633: ARRAY
89634: PUSH
89635: LD_VAR 0 14
89639: PUSH
89640: LD_INT 1
89642: ARRAY
89643: PPUSH
89644: CALL_OW 250
89648: PPUSH
89649: LD_VAR 0 14
89653: PUSH
89654: LD_INT 1
89656: ARRAY
89657: PPUSH
89658: CALL_OW 251
89662: PPUSH
89663: CALL_OW 546
89667: PUSH
89668: LD_INT 2
89670: ARRAY
89671: EQUAL
89672: IFFALSE 89700
// AttackHovercraft ( group [ i ] , tmp [ 1 ] ) else
89674: LD_VAR 0 4
89678: PUSH
89679: LD_VAR 0 7
89683: ARRAY
89684: PPUSH
89685: LD_VAR 0 14
89689: PUSH
89690: LD_INT 1
89692: ARRAY
89693: PPUSH
89694: CALL 84971 0 2
89698: GO 89724
// ComAttackUnit ( group [ i ] , tmp [ 1 ] ) ;
89700: LD_VAR 0 4
89704: PUSH
89705: LD_VAR 0 7
89709: ARRAY
89710: PPUSH
89711: LD_VAR 0 14
89715: PUSH
89716: LD_INT 1
89718: ARRAY
89719: PPUSH
89720: CALL_OW 115
// end ; end ; if GetWeapon ( group [ i ] ) = ar_selfpropelled_bomb then
89724: LD_VAR 0 4
89728: PUSH
89729: LD_VAR 0 7
89733: ARRAY
89734: PPUSH
89735: CALL_OW 264
89739: PUSH
89740: LD_INT 29
89742: EQUAL
89743: IFFALSE 90109
// begin if WantsToAttack ( group [ i ] ) in bombed then
89745: LD_VAR 0 4
89749: PUSH
89750: LD_VAR 0 7
89754: ARRAY
89755: PPUSH
89756: CALL_OW 319
89760: PUSH
89761: LD_VAR 0 28
89765: IN
89766: IFFALSE 89770
// continue ;
89768: GO 86774
// k := 8 ;
89770: LD_ADDR_VAR 0 9
89774: PUSH
89775: LD_INT 8
89777: ST_TO_ADDR
// x := 0 ;
89778: LD_ADDR_VAR 0 10
89782: PUSH
89783: LD_INT 0
89785: ST_TO_ADDR
// if tmp < k then
89786: LD_VAR 0 14
89790: PUSH
89791: LD_VAR 0 9
89795: LESS
89796: IFFALSE 89808
// k := tmp ;
89798: LD_ADDR_VAR 0 9
89802: PUSH
89803: LD_VAR 0 14
89807: ST_TO_ADDR
// for j = 1 to k do
89808: LD_ADDR_VAR 0 8
89812: PUSH
89813: DOUBLE
89814: LD_INT 1
89816: DEC
89817: ST_TO_ADDR
89818: LD_VAR 0 9
89822: PUSH
89823: FOR_TO
89824: IFFALSE 89956
// begin if GetType ( tmp [ j ] ) = unit_building then
89826: LD_VAR 0 14
89830: PUSH
89831: LD_VAR 0 8
89835: ARRAY
89836: PPUSH
89837: CALL_OW 247
89841: PUSH
89842: LD_INT 3
89844: EQUAL
89845: IFFALSE 89954
// if not tmp [ j ] in bombed and UnitsInside ( tmp [ j ] ) then
89847: LD_VAR 0 14
89851: PUSH
89852: LD_VAR 0 8
89856: ARRAY
89857: PUSH
89858: LD_VAR 0 28
89862: IN
89863: NOT
89864: PUSH
89865: LD_VAR 0 14
89869: PUSH
89870: LD_VAR 0 8
89874: ARRAY
89875: PPUSH
89876: CALL_OW 313
89880: AND
89881: IFFALSE 89954
// begin ComAttackUnit ( group [ i ] , tmp [ j ] ) ;
89883: LD_VAR 0 4
89887: PUSH
89888: LD_VAR 0 7
89892: ARRAY
89893: PPUSH
89894: LD_VAR 0 14
89898: PUSH
89899: LD_VAR 0 8
89903: ARRAY
89904: PPUSH
89905: CALL_OW 115
// bombed := Replace ( bombed , bombed + 1 , tmp [ j ] ) ;
89909: LD_ADDR_VAR 0 28
89913: PUSH
89914: LD_VAR 0 28
89918: PPUSH
89919: LD_VAR 0 28
89923: PUSH
89924: LD_INT 1
89926: PLUS
89927: PPUSH
89928: LD_VAR 0 14
89932: PUSH
89933: LD_VAR 0 8
89937: ARRAY
89938: PPUSH
89939: CALL_OW 1
89943: ST_TO_ADDR
// attacking := true ;
89944: LD_ADDR_VAR 0 29
89948: PUSH
89949: LD_INT 1
89951: ST_TO_ADDR
// break ;
89952: GO 89956
// end ; end ;
89954: GO 89823
89956: POP
89957: POP
// if not attacking and f_attack_depot then
89958: LD_VAR 0 29
89962: NOT
89963: PUSH
89964: LD_VAR 0 25
89968: AND
89969: IFFALSE 90064
// begin z := UnitFilter ( tmp , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) ;
89971: LD_ADDR_VAR 0 13
89975: PUSH
89976: LD_VAR 0 14
89980: PPUSH
89981: LD_INT 2
89983: PUSH
89984: LD_INT 30
89986: PUSH
89987: LD_INT 0
89989: PUSH
89990: EMPTY
89991: LIST
89992: LIST
89993: PUSH
89994: LD_INT 30
89996: PUSH
89997: LD_INT 1
89999: PUSH
90000: EMPTY
90001: LIST
90002: LIST
90003: PUSH
90004: EMPTY
90005: LIST
90006: LIST
90007: LIST
90008: PPUSH
90009: CALL_OW 72
90013: ST_TO_ADDR
// if z then
90014: LD_VAR 0 13
90018: IFFALSE 90064
// begin ComAttackUnit ( group [ i ] , NearestUnitToUnit ( z , group [ i ] ) ) ;
90020: LD_VAR 0 4
90024: PUSH
90025: LD_VAR 0 7
90029: ARRAY
90030: PPUSH
90031: LD_VAR 0 13
90035: PPUSH
90036: LD_VAR 0 4
90040: PUSH
90041: LD_VAR 0 7
90045: ARRAY
90046: PPUSH
90047: CALL_OW 74
90051: PPUSH
90052: CALL_OW 115
// attacking := true ;
90056: LD_ADDR_VAR 0 29
90060: PUSH
90061: LD_INT 1
90063: ST_TO_ADDR
// end ; end ; if GetLives ( group [ i ] ) < 500 then
90064: LD_VAR 0 4
90068: PUSH
90069: LD_VAR 0 7
90073: ARRAY
90074: PPUSH
90075: CALL_OW 256
90079: PUSH
90080: LD_INT 500
90082: LESS
90083: IFFALSE 90109
// ComAttackUnit ( group [ i ] , tmp [ 1 ] ) ;
90085: LD_VAR 0 4
90089: PUSH
90090: LD_VAR 0 7
90094: ARRAY
90095: PPUSH
90096: LD_VAR 0 14
90100: PUSH
90101: LD_INT 1
90103: ARRAY
90104: PPUSH
90105: CALL_OW 115
// end ; if GetWeapon ( group [ i ] ) = ru_time_lapser then
90109: LD_VAR 0 4
90113: PUSH
90114: LD_VAR 0 7
90118: ARRAY
90119: PPUSH
90120: CALL_OW 264
90124: PUSH
90125: LD_INT 49
90127: EQUAL
90128: IFFALSE 90249
// begin if not HasTask ( group [ i ] ) then
90130: LD_VAR 0 4
90134: PUSH
90135: LD_VAR 0 7
90139: ARRAY
90140: PPUSH
90141: CALL_OW 314
90145: NOT
90146: IFFALSE 90249
// begin k := NearestUnitToUnit ( FilterAllUnits ( [ f_enemy , GetSide ( group [ i ] ) ] ) , group [ i ] ) ;
90148: LD_ADDR_VAR 0 9
90152: PUSH
90153: LD_INT 81
90155: PUSH
90156: LD_VAR 0 4
90160: PUSH
90161: LD_VAR 0 7
90165: ARRAY
90166: PPUSH
90167: CALL_OW 255
90171: PUSH
90172: EMPTY
90173: LIST
90174: LIST
90175: PPUSH
90176: CALL_OW 69
90180: PPUSH
90181: LD_VAR 0 4
90185: PUSH
90186: LD_VAR 0 7
90190: ARRAY
90191: PPUSH
90192: CALL_OW 74
90196: ST_TO_ADDR
// if k then
90197: LD_VAR 0 9
90201: IFFALSE 90249
// if GetDistUnits ( group [ i ] , k ) > 10 then
90203: LD_VAR 0 4
90207: PUSH
90208: LD_VAR 0 7
90212: ARRAY
90213: PPUSH
90214: LD_VAR 0 9
90218: PPUSH
90219: CALL_OW 296
90223: PUSH
90224: LD_INT 10
90226: GREATER
90227: IFFALSE 90249
// ComMoveUnit ( group [ i ] , k ) ;
90229: LD_VAR 0 4
90233: PUSH
90234: LD_VAR 0 7
90238: ARRAY
90239: PPUSH
90240: LD_VAR 0 9
90244: PPUSH
90245: CALL_OW 112
// end ; end ; if GetLives ( group [ i ] ) < 250 and group [ i ] in FilterAllUnits ( [ [ f_type , unit_vehicle ] , [ f_nation , 2 ] ] ) then
90249: LD_VAR 0 4
90253: PUSH
90254: LD_VAR 0 7
90258: ARRAY
90259: PPUSH
90260: CALL_OW 256
90264: PUSH
90265: LD_INT 250
90267: LESS
90268: PUSH
90269: LD_VAR 0 4
90273: PUSH
90274: LD_VAR 0 7
90278: ARRAY
90279: PUSH
90280: LD_INT 21
90282: PUSH
90283: LD_INT 2
90285: PUSH
90286: EMPTY
90287: LIST
90288: LIST
90289: PUSH
90290: LD_INT 23
90292: PUSH
90293: LD_INT 2
90295: PUSH
90296: EMPTY
90297: LIST
90298: LIST
90299: PUSH
90300: EMPTY
90301: LIST
90302: LIST
90303: PPUSH
90304: CALL_OW 69
90308: IN
90309: AND
90310: IFFALSE 90435
// begin k := NearestUnitToUnit ( all_units diff group [ i ] , group [ i ] ) ;
90312: LD_ADDR_VAR 0 9
90316: PUSH
90317: LD_OWVAR 3
90321: PUSH
90322: LD_VAR 0 4
90326: PUSH
90327: LD_VAR 0 7
90331: ARRAY
90332: DIFF
90333: PPUSH
90334: LD_VAR 0 4
90338: PUSH
90339: LD_VAR 0 7
90343: ARRAY
90344: PPUSH
90345: CALL_OW 74
90349: ST_TO_ADDR
// if not k then
90350: LD_VAR 0 9
90354: NOT
90355: IFFALSE 90359
// continue ;
90357: GO 86774
// if k in FilterAllUnits ( [ f_enemy , GetSide ( group [ i ] ) ] ) and GetDistUnits ( k , group [ i ] ) < 5 then
90359: LD_VAR 0 9
90363: PUSH
90364: LD_INT 81
90366: PUSH
90367: LD_VAR 0 4
90371: PUSH
90372: LD_VAR 0 7
90376: ARRAY
90377: PPUSH
90378: CALL_OW 255
90382: PUSH
90383: EMPTY
90384: LIST
90385: LIST
90386: PPUSH
90387: CALL_OW 69
90391: IN
90392: PUSH
90393: LD_VAR 0 9
90397: PPUSH
90398: LD_VAR 0 4
90402: PUSH
90403: LD_VAR 0 7
90407: ARRAY
90408: PPUSH
90409: CALL_OW 296
90413: PUSH
90414: LD_INT 5
90416: LESS
90417: AND
90418: IFFALSE 90435
// ComAutodestruct ( group [ i ] ) ;
90420: LD_VAR 0 4
90424: PUSH
90425: LD_VAR 0 7
90429: ARRAY
90430: PPUSH
90431: CALL 84869 0 1
// end ; if f_attack_depot then
90435: LD_VAR 0 25
90439: IFFALSE 90551
// begin k := 6 ;
90441: LD_ADDR_VAR 0 9
90445: PUSH
90446: LD_INT 6
90448: ST_TO_ADDR
// if tmp < k then
90449: LD_VAR 0 14
90453: PUSH
90454: LD_VAR 0 9
90458: LESS
90459: IFFALSE 90471
// k := tmp ;
90461: LD_ADDR_VAR 0 9
90465: PUSH
90466: LD_VAR 0 14
90470: ST_TO_ADDR
// for j = 1 to k do
90471: LD_ADDR_VAR 0 8
90475: PUSH
90476: DOUBLE
90477: LD_INT 1
90479: DEC
90480: ST_TO_ADDR
90481: LD_VAR 0 9
90485: PUSH
90486: FOR_TO
90487: IFFALSE 90549
// if GetBType ( j ) in [ b_depot , b_warehouse ] then
90489: LD_VAR 0 8
90493: PPUSH
90494: CALL_OW 266
90498: PUSH
90499: LD_INT 0
90501: PUSH
90502: LD_INT 1
90504: PUSH
90505: EMPTY
90506: LIST
90507: LIST
90508: IN
90509: IFFALSE 90547
// begin ComAttackUnit ( group [ i ] , tmp [ j ] ) ;
90511: LD_VAR 0 4
90515: PUSH
90516: LD_VAR 0 7
90520: ARRAY
90521: PPUSH
90522: LD_VAR 0 14
90526: PUSH
90527: LD_VAR 0 8
90531: ARRAY
90532: PPUSH
90533: CALL_OW 115
// attacking := true ;
90537: LD_ADDR_VAR 0 29
90541: PUSH
90542: LD_INT 1
90544: ST_TO_ADDR
// break ;
90545: GO 90549
// end ;
90547: GO 90486
90549: POP
90550: POP
// end ; if IsOk ( group [ i ] ) and not attacking then
90551: LD_VAR 0 4
90555: PUSH
90556: LD_VAR 0 7
90560: ARRAY
90561: PPUSH
90562: CALL_OW 302
90566: PUSH
90567: LD_VAR 0 29
90571: NOT
90572: AND
90573: IFFALSE 90895
// begin if GetTag ( group [ i ] ) = 71 then
90575: LD_VAR 0 4
90579: PUSH
90580: LD_VAR 0 7
90584: ARRAY
90585: PPUSH
90586: CALL_OW 110
90590: PUSH
90591: LD_INT 71
90593: EQUAL
90594: IFFALSE 90635
// begin if HasTask ( group [ i ] ) then
90596: LD_VAR 0 4
90600: PUSH
90601: LD_VAR 0 7
90605: ARRAY
90606: PPUSH
90607: CALL_OW 314
90611: IFFALSE 90617
// continue else
90613: GO 86774
90615: GO 90635
// SetTag ( group [ i ] , 0 ) ;
90617: LD_VAR 0 4
90621: PUSH
90622: LD_VAR 0 7
90626: ARRAY
90627: PPUSH
90628: LD_INT 0
90630: PPUSH
90631: CALL_OW 109
// end ; k := 8 ;
90635: LD_ADDR_VAR 0 9
90639: PUSH
90640: LD_INT 8
90642: ST_TO_ADDR
// x := 0 ;
90643: LD_ADDR_VAR 0 10
90647: PUSH
90648: LD_INT 0
90650: ST_TO_ADDR
// if tmp < k then
90651: LD_VAR 0 14
90655: PUSH
90656: LD_VAR 0 9
90660: LESS
90661: IFFALSE 90673
// k := tmp ;
90663: LD_ADDR_VAR 0 9
90667: PUSH
90668: LD_VAR 0 14
90672: ST_TO_ADDR
// for j = 1 to k do
90673: LD_ADDR_VAR 0 8
90677: PUSH
90678: DOUBLE
90679: LD_INT 1
90681: DEC
90682: ST_TO_ADDR
90683: LD_VAR 0 9
90687: PUSH
90688: FOR_TO
90689: IFFALSE 90787
// if GetType ( tmp [ j ] ) = unit_human and ( ( GetLives ( tmp [ j ] ) < 250 and f_murder ) or ( not f_murder and GetLives ( tmp [ j ] ) >= 250 ) ) then
90691: LD_VAR 0 14
90695: PUSH
90696: LD_VAR 0 8
90700: ARRAY
90701: PPUSH
90702: CALL_OW 247
90706: PUSH
90707: LD_INT 1
90709: EQUAL
90710: PUSH
90711: LD_VAR 0 14
90715: PUSH
90716: LD_VAR 0 8
90720: ARRAY
90721: PPUSH
90722: CALL_OW 256
90726: PUSH
90727: LD_INT 250
90729: LESS
90730: PUSH
90731: LD_VAR 0 20
90735: AND
90736: PUSH
90737: LD_VAR 0 20
90741: NOT
90742: PUSH
90743: LD_VAR 0 14
90747: PUSH
90748: LD_VAR 0 8
90752: ARRAY
90753: PPUSH
90754: CALL_OW 256
90758: PUSH
90759: LD_INT 250
90761: GREATEREQUAL
90762: AND
90763: OR
90764: AND
90765: IFFALSE 90785
// begin x := tmp [ j ] ;
90767: LD_ADDR_VAR 0 10
90771: PUSH
90772: LD_VAR 0 14
90776: PUSH
90777: LD_VAR 0 8
90781: ARRAY
90782: ST_TO_ADDR
// break ;
90783: GO 90787
// end ;
90785: GO 90688
90787: POP
90788: POP
// if x then
90789: LD_VAR 0 10
90793: IFFALSE 90817
// ComAttackUnit ( group [ i ] , x ) else
90795: LD_VAR 0 4
90799: PUSH
90800: LD_VAR 0 7
90804: ARRAY
90805: PPUSH
90806: LD_VAR 0 10
90810: PPUSH
90811: CALL_OW 115
90815: GO 90841
// ComAttackUnit ( group [ i ] , tmp [ 1 ] ) ;
90817: LD_VAR 0 4
90821: PUSH
90822: LD_VAR 0 7
90826: ARRAY
90827: PPUSH
90828: LD_VAR 0 14
90832: PUSH
90833: LD_INT 1
90835: ARRAY
90836: PPUSH
90837: CALL_OW 115
// if not HasTask ( group [ i ] ) then
90841: LD_VAR 0 4
90845: PUSH
90846: LD_VAR 0 7
90850: ARRAY
90851: PPUSH
90852: CALL_OW 314
90856: NOT
90857: IFFALSE 90895
// ComAttackUnit ( group [ i ] , NearestUnitToUnit ( tmp , group [ i ] ) ) ;
90859: LD_VAR 0 4
90863: PUSH
90864: LD_VAR 0 7
90868: ARRAY
90869: PPUSH
90870: LD_VAR 0 14
90874: PPUSH
90875: LD_VAR 0 4
90879: PUSH
90880: LD_VAR 0 7
90884: ARRAY
90885: PPUSH
90886: CALL_OW 74
90890: PPUSH
90891: CALL_OW 115
// end ; end ; end ;
90895: GO 86774
90897: POP
90898: POP
// wait ( 0 0$2 ) ;
90899: LD_INT 70
90901: PPUSH
90902: CALL_OW 67
// until not group or group = [ ] or not FilterAllUnits ( [ f_enemy , side ] ) ;
90906: LD_VAR 0 4
90910: NOT
90911: PUSH
90912: LD_VAR 0 4
90916: PUSH
90917: EMPTY
90918: EQUAL
90919: OR
90920: PUSH
90921: LD_INT 81
90923: PUSH
90924: LD_VAR 0 35
90928: PUSH
90929: EMPTY
90930: LIST
90931: LIST
90932: PPUSH
90933: CALL_OW 69
90937: NOT
90938: OR
90939: IFFALSE 86759
// end ;
90941: LD_VAR 0 2
90945: RET
// export function _ScanBase ( base_units ) ; var i , t , tmp ; begin
90946: LD_INT 0
90948: PPUSH
90949: PPUSH
90950: PPUSH
90951: PPUSH
// if not base_units then
90952: LD_VAR 0 1
90956: NOT
90957: IFFALSE 90961
// exit ;
90959: GO 91048
// result := false ;
90961: LD_ADDR_VAR 0 2
90965: PUSH
90966: LD_INT 0
90968: ST_TO_ADDR
// tmp := UnitFilter ( base_units , [ f_type , unit_building ] ) ;
90969: LD_ADDR_VAR 0 5
90973: PUSH
90974: LD_VAR 0 1
90978: PPUSH
90979: LD_INT 21
90981: PUSH
90982: LD_INT 3
90984: PUSH
90985: EMPTY
90986: LIST
90987: LIST
90988: PPUSH
90989: CALL_OW 72
90993: ST_TO_ADDR
// if not tmp then
90994: LD_VAR 0 5
90998: NOT
90999: IFFALSE 91003
// exit ;
91001: GO 91048
// for i in tmp do
91003: LD_ADDR_VAR 0 3
91007: PUSH
91008: LD_VAR 0 5
91012: PUSH
91013: FOR_IN
91014: IFFALSE 91046
// begin result := EnemyInRange ( i , 22 ) ;
91016: LD_ADDR_VAR 0 2
91020: PUSH
91021: LD_VAR 0 3
91025: PPUSH
91026: LD_INT 22
91028: PPUSH
91029: CALL 84575 0 2
91033: ST_TO_ADDR
// if result then
91034: LD_VAR 0 2
91038: IFFALSE 91044
// exit ;
91040: POP
91041: POP
91042: GO 91048
// end ;
91044: GO 91013
91046: POP
91047: POP
// end ;
91048: LD_VAR 0 2
91052: RET
// export function FilterByTag ( units , tag ) ; var i ; begin
91053: LD_INT 0
91055: PPUSH
91056: PPUSH
// if not units then
91057: LD_VAR 0 1
91061: NOT
91062: IFFALSE 91066
// exit ;
91064: GO 91136
// result := [ ] ;
91066: LD_ADDR_VAR 0 3
91070: PUSH
91071: EMPTY
91072: ST_TO_ADDR
// for i in units do
91073: LD_ADDR_VAR 0 4
91077: PUSH
91078: LD_VAR 0 1
91082: PUSH
91083: FOR_IN
91084: IFFALSE 91134
// if GetTag ( i ) = tag then
91086: LD_VAR 0 4
91090: PPUSH
91091: CALL_OW 110
91095: PUSH
91096: LD_VAR 0 2
91100: EQUAL
91101: IFFALSE 91132
// result := Insert ( result , result + 1 , i ) ;
91103: LD_ADDR_VAR 0 3
91107: PUSH
91108: LD_VAR 0 3
91112: PPUSH
91113: LD_VAR 0 3
91117: PUSH
91118: LD_INT 1
91120: PLUS
91121: PPUSH
91122: LD_VAR 0 4
91126: PPUSH
91127: CALL_OW 2
91131: ST_TO_ADDR
91132: GO 91083
91134: POP
91135: POP
// end ;
91136: LD_VAR 0 3
91140: RET
// export function IsDriver ( un ) ; begin
91141: LD_INT 0
91143: PPUSH
// result := un in FilterAllUnits ( [ f_driving ] ) ;
91144: LD_ADDR_VAR 0 2
91148: PUSH
91149: LD_VAR 0 1
91153: PUSH
91154: LD_INT 55
91156: PUSH
91157: EMPTY
91158: LIST
91159: PPUSH
91160: CALL_OW 69
91164: IN
91165: ST_TO_ADDR
// end ;
91166: LD_VAR 0 2
91170: RET
// export function GetFacExtXYD ( x , y , d ) ; var list ; begin
91171: LD_INT 0
91173: PPUSH
91174: PPUSH
// list := [ ] ;
91175: LD_ADDR_VAR 0 5
91179: PUSH
91180: EMPTY
91181: ST_TO_ADDR
// case d of 0 :
91182: LD_VAR 0 3
91186: PUSH
91187: LD_INT 0
91189: DOUBLE
91190: EQUAL
91191: IFTRUE 91195
91193: GO 91328
91195: POP
// begin list := [ [ x - 4 , y - 4 , 2 ] , [ x - 3 , y , 1 ] , [ x + 4 , y , 4 ] , [ x + 3 , y + 3 , 5 ] , [ x , y + 4 , 0 ] ] ;
91196: LD_ADDR_VAR 0 5
91200: PUSH
91201: LD_VAR 0 1
91205: PUSH
91206: LD_INT 4
91208: MINUS
91209: PUSH
91210: LD_VAR 0 2
91214: PUSH
91215: LD_INT 4
91217: MINUS
91218: PUSH
91219: LD_INT 2
91221: PUSH
91222: EMPTY
91223: LIST
91224: LIST
91225: LIST
91226: PUSH
91227: LD_VAR 0 1
91231: PUSH
91232: LD_INT 3
91234: MINUS
91235: PUSH
91236: LD_VAR 0 2
91240: PUSH
91241: LD_INT 1
91243: PUSH
91244: EMPTY
91245: LIST
91246: LIST
91247: LIST
91248: PUSH
91249: LD_VAR 0 1
91253: PUSH
91254: LD_INT 4
91256: PLUS
91257: PUSH
91258: LD_VAR 0 2
91262: PUSH
91263: LD_INT 4
91265: PUSH
91266: EMPTY
91267: LIST
91268: LIST
91269: LIST
91270: PUSH
91271: LD_VAR 0 1
91275: PUSH
91276: LD_INT 3
91278: PLUS
91279: PUSH
91280: LD_VAR 0 2
91284: PUSH
91285: LD_INT 3
91287: PLUS
91288: PUSH
91289: LD_INT 5
91291: PUSH
91292: EMPTY
91293: LIST
91294: LIST
91295: LIST
91296: PUSH
91297: LD_VAR 0 1
91301: PUSH
91302: LD_VAR 0 2
91306: PUSH
91307: LD_INT 4
91309: PLUS
91310: PUSH
91311: LD_INT 0
91313: PUSH
91314: EMPTY
91315: LIST
91316: LIST
91317: LIST
91318: PUSH
91319: EMPTY
91320: LIST
91321: LIST
91322: LIST
91323: LIST
91324: LIST
91325: ST_TO_ADDR
// end ; 1 :
91326: GO 92026
91328: LD_INT 1
91330: DOUBLE
91331: EQUAL
91332: IFTRUE 91336
91334: GO 91469
91336: POP
// begin list := [ [ x , y - 4 , 3 ] , [ x - 3 , y - 3 , 2 ] , [ x - 4 , y , 1 ] , [ x , y + 3 , 0 ] , [ x + 4 , y + 4 , 5 ] ] ;
91337: LD_ADDR_VAR 0 5
91341: PUSH
91342: LD_VAR 0 1
91346: PUSH
91347: LD_VAR 0 2
91351: PUSH
91352: LD_INT 4
91354: MINUS
91355: PUSH
91356: LD_INT 3
91358: PUSH
91359: EMPTY
91360: LIST
91361: LIST
91362: LIST
91363: PUSH
91364: LD_VAR 0 1
91368: PUSH
91369: LD_INT 3
91371: MINUS
91372: PUSH
91373: LD_VAR 0 2
91377: PUSH
91378: LD_INT 3
91380: MINUS
91381: PUSH
91382: LD_INT 2
91384: PUSH
91385: EMPTY
91386: LIST
91387: LIST
91388: LIST
91389: PUSH
91390: LD_VAR 0 1
91394: PUSH
91395: LD_INT 4
91397: MINUS
91398: PUSH
91399: LD_VAR 0 2
91403: PUSH
91404: LD_INT 1
91406: PUSH
91407: EMPTY
91408: LIST
91409: LIST
91410: LIST
91411: PUSH
91412: LD_VAR 0 1
91416: PUSH
91417: LD_VAR 0 2
91421: PUSH
91422: LD_INT 3
91424: PLUS
91425: PUSH
91426: LD_INT 0
91428: PUSH
91429: EMPTY
91430: LIST
91431: LIST
91432: LIST
91433: PUSH
91434: LD_VAR 0 1
91438: PUSH
91439: LD_INT 4
91441: PLUS
91442: PUSH
91443: LD_VAR 0 2
91447: PUSH
91448: LD_INT 4
91450: PLUS
91451: PUSH
91452: LD_INT 5
91454: PUSH
91455: EMPTY
91456: LIST
91457: LIST
91458: LIST
91459: PUSH
91460: EMPTY
91461: LIST
91462: LIST
91463: LIST
91464: LIST
91465: LIST
91466: ST_TO_ADDR
// end ; 2 :
91467: GO 92026
91469: LD_INT 2
91471: DOUBLE
91472: EQUAL
91473: IFTRUE 91477
91475: GO 91606
91477: POP
// begin list := [ [ x , y - 3 , 3 ] , [ x + 4 , y , 4 ] , [ x , y + 4 , 0 ] , [ x - 3 , y , 1 ] , [ x - 4 , y - 4 , 2 ] ] ;
91478: LD_ADDR_VAR 0 5
91482: PUSH
91483: LD_VAR 0 1
91487: PUSH
91488: LD_VAR 0 2
91492: PUSH
91493: LD_INT 3
91495: MINUS
91496: PUSH
91497: LD_INT 3
91499: PUSH
91500: EMPTY
91501: LIST
91502: LIST
91503: LIST
91504: PUSH
91505: LD_VAR 0 1
91509: PUSH
91510: LD_INT 4
91512: PLUS
91513: PUSH
91514: LD_VAR 0 2
91518: PUSH
91519: LD_INT 4
91521: PUSH
91522: EMPTY
91523: LIST
91524: LIST
91525: LIST
91526: PUSH
91527: LD_VAR 0 1
91531: PUSH
91532: LD_VAR 0 2
91536: PUSH
91537: LD_INT 4
91539: PLUS
91540: PUSH
91541: LD_INT 0
91543: PUSH
91544: EMPTY
91545: LIST
91546: LIST
91547: LIST
91548: PUSH
91549: LD_VAR 0 1
91553: PUSH
91554: LD_INT 3
91556: MINUS
91557: PUSH
91558: LD_VAR 0 2
91562: PUSH
91563: LD_INT 1
91565: PUSH
91566: EMPTY
91567: LIST
91568: LIST
91569: LIST
91570: PUSH
91571: LD_VAR 0 1
91575: PUSH
91576: LD_INT 4
91578: MINUS
91579: PUSH
91580: LD_VAR 0 2
91584: PUSH
91585: LD_INT 4
91587: MINUS
91588: PUSH
91589: LD_INT 2
91591: PUSH
91592: EMPTY
91593: LIST
91594: LIST
91595: LIST
91596: PUSH
91597: EMPTY
91598: LIST
91599: LIST
91600: LIST
91601: LIST
91602: LIST
91603: ST_TO_ADDR
// end ; 3 :
91604: GO 92026
91606: LD_INT 3
91608: DOUBLE
91609: EQUAL
91610: IFTRUE 91614
91612: GO 91747
91614: POP
// begin list := [ [ x + 3 , y , 4 ] , [ x + 4 , y + 4 , 5 ] , [ x - 4 , y , 1 ] , [ x , y - 4 , 3 ] , [ x - 3 , y - 3 , 2 ] ] ;
91615: LD_ADDR_VAR 0 5
91619: PUSH
91620: LD_VAR 0 1
91624: PUSH
91625: LD_INT 3
91627: PLUS
91628: PUSH
91629: LD_VAR 0 2
91633: PUSH
91634: LD_INT 4
91636: PUSH
91637: EMPTY
91638: LIST
91639: LIST
91640: LIST
91641: PUSH
91642: LD_VAR 0 1
91646: PUSH
91647: LD_INT 4
91649: PLUS
91650: PUSH
91651: LD_VAR 0 2
91655: PUSH
91656: LD_INT 4
91658: PLUS
91659: PUSH
91660: LD_INT 5
91662: PUSH
91663: EMPTY
91664: LIST
91665: LIST
91666: LIST
91667: PUSH
91668: LD_VAR 0 1
91672: PUSH
91673: LD_INT 4
91675: MINUS
91676: PUSH
91677: LD_VAR 0 2
91681: PUSH
91682: LD_INT 1
91684: PUSH
91685: EMPTY
91686: LIST
91687: LIST
91688: LIST
91689: PUSH
91690: LD_VAR 0 1
91694: PUSH
91695: LD_VAR 0 2
91699: PUSH
91700: LD_INT 4
91702: MINUS
91703: PUSH
91704: LD_INT 3
91706: PUSH
91707: EMPTY
91708: LIST
91709: LIST
91710: LIST
91711: PUSH
91712: LD_VAR 0 1
91716: PUSH
91717: LD_INT 3
91719: MINUS
91720: PUSH
91721: LD_VAR 0 2
91725: PUSH
91726: LD_INT 3
91728: MINUS
91729: PUSH
91730: LD_INT 2
91732: PUSH
91733: EMPTY
91734: LIST
91735: LIST
91736: LIST
91737: PUSH
91738: EMPTY
91739: LIST
91740: LIST
91741: LIST
91742: LIST
91743: LIST
91744: ST_TO_ADDR
// end ; 4 :
91745: GO 92026
91747: LD_INT 4
91749: DOUBLE
91750: EQUAL
91751: IFTRUE 91755
91753: GO 91888
91755: POP
// begin list := [ [ x , y + 4 , 0 ] , [ x + 3 , y + 3 , 5 ] , [ x + 4 , y , 4 ] , [ x , y - 3 , 3 ] , [ x - 4 , y - 4 , 2 ] ] ;
91756: LD_ADDR_VAR 0 5
91760: PUSH
91761: LD_VAR 0 1
91765: PUSH
91766: LD_VAR 0 2
91770: PUSH
91771: LD_INT 4
91773: PLUS
91774: PUSH
91775: LD_INT 0
91777: PUSH
91778: EMPTY
91779: LIST
91780: LIST
91781: LIST
91782: PUSH
91783: LD_VAR 0 1
91787: PUSH
91788: LD_INT 3
91790: PLUS
91791: PUSH
91792: LD_VAR 0 2
91796: PUSH
91797: LD_INT 3
91799: PLUS
91800: PUSH
91801: LD_INT 5
91803: PUSH
91804: EMPTY
91805: LIST
91806: LIST
91807: LIST
91808: PUSH
91809: LD_VAR 0 1
91813: PUSH
91814: LD_INT 4
91816: PLUS
91817: PUSH
91818: LD_VAR 0 2
91822: PUSH
91823: LD_INT 4
91825: PUSH
91826: EMPTY
91827: LIST
91828: LIST
91829: LIST
91830: PUSH
91831: LD_VAR 0 1
91835: PUSH
91836: LD_VAR 0 2
91840: PUSH
91841: LD_INT 3
91843: MINUS
91844: PUSH
91845: LD_INT 3
91847: PUSH
91848: EMPTY
91849: LIST
91850: LIST
91851: LIST
91852: PUSH
91853: LD_VAR 0 1
91857: PUSH
91858: LD_INT 4
91860: MINUS
91861: PUSH
91862: LD_VAR 0 2
91866: PUSH
91867: LD_INT 4
91869: MINUS
91870: PUSH
91871: LD_INT 2
91873: PUSH
91874: EMPTY
91875: LIST
91876: LIST
91877: LIST
91878: PUSH
91879: EMPTY
91880: LIST
91881: LIST
91882: LIST
91883: LIST
91884: LIST
91885: ST_TO_ADDR
// end ; 5 :
91886: GO 92026
91888: LD_INT 5
91890: DOUBLE
91891: EQUAL
91892: IFTRUE 91896
91894: GO 92025
91896: POP
// begin list := [ [ x - 4 , y , 1 ] , [ x , y - 4 , 3 ] , [ x + 4 , y + 4 , 5 ] , [ x + 3 , y , 4 ] , [ x , y + 3 , 0 ] ] ;
91897: LD_ADDR_VAR 0 5
91901: PUSH
91902: LD_VAR 0 1
91906: PUSH
91907: LD_INT 4
91909: MINUS
91910: PUSH
91911: LD_VAR 0 2
91915: PUSH
91916: LD_INT 1
91918: PUSH
91919: EMPTY
91920: LIST
91921: LIST
91922: LIST
91923: PUSH
91924: LD_VAR 0 1
91928: PUSH
91929: LD_VAR 0 2
91933: PUSH
91934: LD_INT 4
91936: MINUS
91937: PUSH
91938: LD_INT 3
91940: PUSH
91941: EMPTY
91942: LIST
91943: LIST
91944: LIST
91945: PUSH
91946: LD_VAR 0 1
91950: PUSH
91951: LD_INT 4
91953: PLUS
91954: PUSH
91955: LD_VAR 0 2
91959: PUSH
91960: LD_INT 4
91962: PLUS
91963: PUSH
91964: LD_INT 5
91966: PUSH
91967: EMPTY
91968: LIST
91969: LIST
91970: LIST
91971: PUSH
91972: LD_VAR 0 1
91976: PUSH
91977: LD_INT 3
91979: PLUS
91980: PUSH
91981: LD_VAR 0 2
91985: PUSH
91986: LD_INT 4
91988: PUSH
91989: EMPTY
91990: LIST
91991: LIST
91992: LIST
91993: PUSH
91994: LD_VAR 0 1
91998: PUSH
91999: LD_VAR 0 2
92003: PUSH
92004: LD_INT 3
92006: PLUS
92007: PUSH
92008: LD_INT 0
92010: PUSH
92011: EMPTY
92012: LIST
92013: LIST
92014: LIST
92015: PUSH
92016: EMPTY
92017: LIST
92018: LIST
92019: LIST
92020: LIST
92021: LIST
92022: ST_TO_ADDR
// end ; end ;
92023: GO 92026
92025: POP
// result := list ;
92026: LD_ADDR_VAR 0 4
92030: PUSH
92031: LD_VAR 0 5
92035: ST_TO_ADDR
// end ;
92036: LD_VAR 0 4
92040: RET
// export function SortBySkill ( units , class ) ; var i , tmp ; begin
92041: LD_INT 0
92043: PPUSH
92044: PPUSH
92045: PPUSH
// if not units or not class in [ 1 , 2 , 3 , 4 ] then
92046: LD_VAR 0 1
92050: NOT
92051: PUSH
92052: LD_VAR 0 2
92056: PUSH
92057: LD_INT 1
92059: PUSH
92060: LD_INT 2
92062: PUSH
92063: LD_INT 3
92065: PUSH
92066: LD_INT 4
92068: PUSH
92069: EMPTY
92070: LIST
92071: LIST
92072: LIST
92073: LIST
92074: IN
92075: NOT
92076: OR
92077: IFFALSE 92081
// exit ;
92079: GO 92173
// tmp := [ ] ;
92081: LD_ADDR_VAR 0 5
92085: PUSH
92086: EMPTY
92087: ST_TO_ADDR
// for i in units do
92088: LD_ADDR_VAR 0 4
92092: PUSH
92093: LD_VAR 0 1
92097: PUSH
92098: FOR_IN
92099: IFFALSE 92142
// tmp := Insert ( tmp , tmp + 1 , GetSkill ( i , class ) ) ;
92101: LD_ADDR_VAR 0 5
92105: PUSH
92106: LD_VAR 0 5
92110: PPUSH
92111: LD_VAR 0 5
92115: PUSH
92116: LD_INT 1
92118: PLUS
92119: PPUSH
92120: LD_VAR 0 4
92124: PPUSH
92125: LD_VAR 0 2
92129: PPUSH
92130: CALL_OW 259
92134: PPUSH
92135: CALL_OW 2
92139: ST_TO_ADDR
92140: GO 92098
92142: POP
92143: POP
// if not tmp then
92144: LD_VAR 0 5
92148: NOT
92149: IFFALSE 92153
// exit ;
92151: GO 92173
// result := SortListByListDesc ( units , tmp ) ;
92153: LD_ADDR_VAR 0 3
92157: PUSH
92158: LD_VAR 0 1
92162: PPUSH
92163: LD_VAR 0 5
92167: PPUSH
92168: CALL_OW 77
92172: ST_TO_ADDR
// end ;
92173: LD_VAR 0 3
92177: RET
// export function UnitGoingToBuilding ( unit , building ) ; var x , y ; begin
92178: LD_INT 0
92180: PPUSH
92181: PPUSH
92182: PPUSH
// x := GetX ( building ) ;
92183: LD_ADDR_VAR 0 4
92187: PUSH
92188: LD_VAR 0 2
92192: PPUSH
92193: CALL_OW 250
92197: ST_TO_ADDR
// y := GetY ( building ) ;
92198: LD_ADDR_VAR 0 5
92202: PUSH
92203: LD_VAR 0 2
92207: PPUSH
92208: CALL_OW 251
92212: ST_TO_ADDR
// if GetTaskList ( unit ) then
92213: LD_VAR 0 1
92217: PPUSH
92218: CALL_OW 437
92222: IFFALSE 92317
// begin if e = GetTaskList ( unit ) [ 1 ] [ 1 ] and x = GetTaskList ( unit ) [ 1 ] [ 2 ] and y = GetTaskList ( unit ) [ 1 ] [ 3 ] then
92224: LD_STRING e
92226: PUSH
92227: LD_VAR 0 1
92231: PPUSH
92232: CALL_OW 437
92236: PUSH
92237: LD_INT 1
92239: ARRAY
92240: PUSH
92241: LD_INT 1
92243: ARRAY
92244: EQUAL
92245: PUSH
92246: LD_VAR 0 4
92250: PUSH
92251: LD_VAR 0 1
92255: PPUSH
92256: CALL_OW 437
92260: PUSH
92261: LD_INT 1
92263: ARRAY
92264: PUSH
92265: LD_INT 2
92267: ARRAY
92268: EQUAL
92269: AND
92270: PUSH
92271: LD_VAR 0 5
92275: PUSH
92276: LD_VAR 0 1
92280: PPUSH
92281: CALL_OW 437
92285: PUSH
92286: LD_INT 1
92288: ARRAY
92289: PUSH
92290: LD_INT 3
92292: ARRAY
92293: EQUAL
92294: AND
92295: IFFALSE 92307
// result := true else
92297: LD_ADDR_VAR 0 3
92301: PUSH
92302: LD_INT 1
92304: ST_TO_ADDR
92305: GO 92315
// result := false ;
92307: LD_ADDR_VAR 0 3
92311: PUSH
92312: LD_INT 0
92314: ST_TO_ADDR
// end else
92315: GO 92325
// result := false ;
92317: LD_ADDR_VAR 0 3
92321: PUSH
92322: LD_INT 0
92324: ST_TO_ADDR
// end ;
92325: LD_VAR 0 3
92329: RET
// export function PlaceUnitInArea ( unit , area , mode ) ; var i , tmp , hex ; begin
92330: LD_INT 0
92332: PPUSH
92333: PPUSH
92334: PPUSH
92335: PPUSH
// if not unit or not area then
92336: LD_VAR 0 1
92340: NOT
92341: PUSH
92342: LD_VAR 0 2
92346: NOT
92347: OR
92348: IFFALSE 92352
// exit ;
92350: GO 92516
// tmp := AreaToList ( area , i ) ;
92352: LD_ADDR_VAR 0 6
92356: PUSH
92357: LD_VAR 0 2
92361: PPUSH
92362: LD_VAR 0 5
92366: PPUSH
92367: CALL_OW 517
92371: ST_TO_ADDR
// for i = 1 to tmp [ 1 ] do
92372: LD_ADDR_VAR 0 5
92376: PUSH
92377: DOUBLE
92378: LD_INT 1
92380: DEC
92381: ST_TO_ADDR
92382: LD_VAR 0 6
92386: PUSH
92387: LD_INT 1
92389: ARRAY
92390: PUSH
92391: FOR_TO
92392: IFFALSE 92514
// begin hex := [ tmp [ 1 ] [ i ] , tmp [ 2 ] [ i ] ] ;
92394: LD_ADDR_VAR 0 7
92398: PUSH
92399: LD_VAR 0 6
92403: PUSH
92404: LD_INT 1
92406: ARRAY
92407: PUSH
92408: LD_VAR 0 5
92412: ARRAY
92413: PUSH
92414: LD_VAR 0 6
92418: PUSH
92419: LD_INT 2
92421: ARRAY
92422: PUSH
92423: LD_VAR 0 5
92427: ARRAY
92428: PUSH
92429: EMPTY
92430: LIST
92431: LIST
92432: ST_TO_ADDR
// if HexInfo ( hex [ 1 ] , hex [ 2 ] ) = 0 then
92433: LD_VAR 0 7
92437: PUSH
92438: LD_INT 1
92440: ARRAY
92441: PPUSH
92442: LD_VAR 0 7
92446: PUSH
92447: LD_INT 2
92449: ARRAY
92450: PPUSH
92451: CALL_OW 428
92455: PUSH
92456: LD_INT 0
92458: EQUAL
92459: IFFALSE 92512
// begin PlaceUnitXY ( unit , hex [ 1 ] , hex [ 2 ] , mode ) ;
92461: LD_VAR 0 1
92465: PPUSH
92466: LD_VAR 0 7
92470: PUSH
92471: LD_INT 1
92473: ARRAY
92474: PPUSH
92475: LD_VAR 0 7
92479: PUSH
92480: LD_INT 2
92482: ARRAY
92483: PPUSH
92484: LD_VAR 0 3
92488: PPUSH
92489: CALL_OW 48
// result := IsPlaced ( unit ) ;
92493: LD_ADDR_VAR 0 4
92497: PUSH
92498: LD_VAR 0 1
92502: PPUSH
92503: CALL_OW 305
92507: ST_TO_ADDR
// exit ;
92508: POP
92509: POP
92510: GO 92516
// end ; end ;
92512: GO 92391
92514: POP
92515: POP
// end ;
92516: LD_VAR 0 4
92520: RET
// export function BuildingsListDump ( side ) ; var i , tmp ; begin
92521: LD_INT 0
92523: PPUSH
92524: PPUSH
92525: PPUSH
// if not side or side > 8 then
92526: LD_VAR 0 1
92530: NOT
92531: PUSH
92532: LD_VAR 0 1
92536: PUSH
92537: LD_INT 8
92539: GREATER
92540: OR
92541: IFFALSE 92545
// exit ;
92543: GO 92732
// tmp := FilterAllUnits ( [ [ f_side , side ] , [ f_type , unit_building ] ] ) ;
92545: LD_ADDR_VAR 0 4
92549: PUSH
92550: LD_INT 22
92552: PUSH
92553: LD_VAR 0 1
92557: PUSH
92558: EMPTY
92559: LIST
92560: LIST
92561: PUSH
92562: LD_INT 21
92564: PUSH
92565: LD_INT 3
92567: PUSH
92568: EMPTY
92569: LIST
92570: LIST
92571: PUSH
92572: EMPTY
92573: LIST
92574: LIST
92575: PPUSH
92576: CALL_OW 69
92580: ST_TO_ADDR
// if not tmp then
92581: LD_VAR 0 4
92585: NOT
92586: IFFALSE 92590
// exit ;
92588: GO 92732
// enable_addtolog := true ;
92590: LD_ADDR_OWVAR 81
92594: PUSH
92595: LD_INT 1
92597: ST_TO_ADDR
// AddToLog ( [ ) ;
92598: LD_STRING [
92600: PPUSH
92601: CALL_OW 561
// for i in tmp do
92605: LD_ADDR_VAR 0 3
92609: PUSH
92610: LD_VAR 0 4
92614: PUSH
92615: FOR_IN
92616: IFFALSE 92723
// begin AddToLog ( [ & GetBType ( i ) & ,  & GetX ( i ) & ,  & GetY ( i ) & ,  & GetDir ( i ) & ,  & GetLabKind ( i , 1 ) & ,  & GetLabKind ( i , 2 ) & ], ) ;
92618: LD_STRING [
92620: PUSH
92621: LD_VAR 0 3
92625: PPUSH
92626: CALL_OW 266
92630: STR
92631: PUSH
92632: LD_STRING , 
92634: STR
92635: PUSH
92636: LD_VAR 0 3
92640: PPUSH
92641: CALL_OW 250
92645: STR
92646: PUSH
92647: LD_STRING , 
92649: STR
92650: PUSH
92651: LD_VAR 0 3
92655: PPUSH
92656: CALL_OW 251
92660: STR
92661: PUSH
92662: LD_STRING , 
92664: STR
92665: PUSH
92666: LD_VAR 0 3
92670: PPUSH
92671: CALL_OW 254
92675: STR
92676: PUSH
92677: LD_STRING , 
92679: STR
92680: PUSH
92681: LD_VAR 0 3
92685: PPUSH
92686: LD_INT 1
92688: PPUSH
92689: CALL_OW 268
92693: STR
92694: PUSH
92695: LD_STRING , 
92697: STR
92698: PUSH
92699: LD_VAR 0 3
92703: PPUSH
92704: LD_INT 2
92706: PPUSH
92707: CALL_OW 268
92711: STR
92712: PUSH
92713: LD_STRING ],
92715: STR
92716: PPUSH
92717: CALL_OW 561
// end ;
92721: GO 92615
92723: POP
92724: POP
// AddToLog ( ]; ) ;
92725: LD_STRING ];
92727: PPUSH
92728: CALL_OW 561
// end ;
92732: LD_VAR 0 2
92736: RET
// export function Crates ( area , rate , min , max ) ; var i , r , time , amount ; begin
92737: LD_INT 0
92739: PPUSH
92740: PPUSH
92741: PPUSH
92742: PPUSH
92743: PPUSH
// if not area or not rate or not max then
92744: LD_VAR 0 1
92748: NOT
92749: PUSH
92750: LD_VAR 0 2
92754: NOT
92755: OR
92756: PUSH
92757: LD_VAR 0 4
92761: NOT
92762: OR
92763: IFFALSE 92767
// exit ;
92765: GO 92959
// while 1 do
92767: LD_INT 1
92769: IFFALSE 92959
// begin amount := GetResourceArea ( area , mat_cans ) * 10 ;
92771: LD_ADDR_VAR 0 9
92775: PUSH
92776: LD_VAR 0 1
92780: PPUSH
92781: LD_INT 1
92783: PPUSH
92784: CALL_OW 287
92788: PUSH
92789: LD_INT 10
92791: MUL
92792: ST_TO_ADDR
// r := rate / 10 ;
92793: LD_ADDR_VAR 0 7
92797: PUSH
92798: LD_VAR 0 2
92802: PUSH
92803: LD_INT 10
92805: DIVREAL
92806: ST_TO_ADDR
// time := 1 1$00 ;
92807: LD_ADDR_VAR 0 8
92811: PUSH
92812: LD_INT 2100
92814: ST_TO_ADDR
// if amount < min then
92815: LD_VAR 0 9
92819: PUSH
92820: LD_VAR 0 3
92824: LESS
92825: IFFALSE 92843
// r := r * 2 else
92827: LD_ADDR_VAR 0 7
92831: PUSH
92832: LD_VAR 0 7
92836: PUSH
92837: LD_INT 2
92839: MUL
92840: ST_TO_ADDR
92841: GO 92869
// if amount > max then
92843: LD_VAR 0 9
92847: PUSH
92848: LD_VAR 0 4
92852: GREATER
92853: IFFALSE 92869
// r := r / 2 ;
92855: LD_ADDR_VAR 0 7
92859: PUSH
92860: LD_VAR 0 7
92864: PUSH
92865: LD_INT 2
92867: DIVREAL
92868: ST_TO_ADDR
// time := time / r ;
92869: LD_ADDR_VAR 0 8
92873: PUSH
92874: LD_VAR 0 8
92878: PUSH
92879: LD_VAR 0 7
92883: DIVREAL
92884: ST_TO_ADDR
// if time < 0 then
92885: LD_VAR 0 8
92889: PUSH
92890: LD_INT 0
92892: LESS
92893: IFFALSE 92910
// time := time * - 1 ;
92895: LD_ADDR_VAR 0 8
92899: PUSH
92900: LD_VAR 0 8
92904: PUSH
92905: LD_INT 1
92907: NEG
92908: MUL
92909: ST_TO_ADDR
// wait ( time ) ;
92910: LD_VAR 0 8
92914: PPUSH
92915: CALL_OW 67
// wait ( rand ( 0 0$01 , 0 0$25 ) ) ;
92919: LD_INT 35
92921: PPUSH
92922: LD_INT 875
92924: PPUSH
92925: CALL_OW 12
92929: PPUSH
92930: CALL_OW 67
// CreateCratesArea ( rand ( 1 , 5 ) , area , true ) ;
92934: LD_INT 1
92936: PPUSH
92937: LD_INT 5
92939: PPUSH
92940: CALL_OW 12
92944: PPUSH
92945: LD_VAR 0 1
92949: PPUSH
92950: LD_INT 1
92952: PPUSH
92953: CALL_OW 55
// end ;
92957: GO 92767
// end ;
92959: LD_VAR 0 5
92963: RET
// export function UpgradeTurretsWeapon ( turrets , factories ) ; var i , j , k , nat , weapon , weapons , list ; begin
92964: LD_INT 0
92966: PPUSH
92967: PPUSH
92968: PPUSH
92969: PPUSH
92970: PPUSH
92971: PPUSH
92972: PPUSH
92973: PPUSH
// if not turrets or not factories then
92974: LD_VAR 0 1
92978: NOT
92979: PUSH
92980: LD_VAR 0 2
92984: NOT
92985: OR
92986: IFFALSE 92990
// exit ;
92988: GO 93297
// list := [ [ [ us_double_gun , us_heavy_gun ] , [ us_machine_gun , us_gatling_gun ] , [ us_light_gun , us_double_gun ] ] , [ [ ar_double_machine_gun , ar_gatling_gun ] , [ ar_light_gun , ar_gun ] ] , [ [ ru_heavy_machine_gun , ru_gatling_gun ] , [ ru_gun , ru_heavy_gun ] , [ ru_rocket_launcher , ru_rocket ] ] , ] ;
92990: LD_ADDR_VAR 0 10
92994: PUSH
92995: LD_INT 5
92997: PUSH
92998: LD_INT 6
93000: PUSH
93001: EMPTY
93002: LIST
93003: LIST
93004: PUSH
93005: LD_INT 2
93007: PUSH
93008: LD_INT 4
93010: PUSH
93011: EMPTY
93012: LIST
93013: LIST
93014: PUSH
93015: LD_INT 3
93017: PUSH
93018: LD_INT 5
93020: PUSH
93021: EMPTY
93022: LIST
93023: LIST
93024: PUSH
93025: EMPTY
93026: LIST
93027: LIST
93028: LIST
93029: PUSH
93030: LD_INT 24
93032: PUSH
93033: LD_INT 25
93035: PUSH
93036: EMPTY
93037: LIST
93038: LIST
93039: PUSH
93040: LD_INT 23
93042: PUSH
93043: LD_INT 27
93045: PUSH
93046: EMPTY
93047: LIST
93048: LIST
93049: PUSH
93050: EMPTY
93051: LIST
93052: LIST
93053: PUSH
93054: LD_INT 42
93056: PUSH
93057: LD_INT 43
93059: PUSH
93060: EMPTY
93061: LIST
93062: LIST
93063: PUSH
93064: LD_INT 44
93066: PUSH
93067: LD_INT 46
93069: PUSH
93070: EMPTY
93071: LIST
93072: LIST
93073: PUSH
93074: LD_INT 45
93076: PUSH
93077: LD_INT 47
93079: PUSH
93080: EMPTY
93081: LIST
93082: LIST
93083: PUSH
93084: EMPTY
93085: LIST
93086: LIST
93087: LIST
93088: PUSH
93089: EMPTY
93090: LIST
93091: LIST
93092: LIST
93093: ST_TO_ADDR
// result := [ ] ;
93094: LD_ADDR_VAR 0 3
93098: PUSH
93099: EMPTY
93100: ST_TO_ADDR
// for i in turrets do
93101: LD_ADDR_VAR 0 4
93105: PUSH
93106: LD_VAR 0 1
93110: PUSH
93111: FOR_IN
93112: IFFALSE 93295
// begin nat := GetNation ( i ) ;
93114: LD_ADDR_VAR 0 7
93118: PUSH
93119: LD_VAR 0 4
93123: PPUSH
93124: CALL_OW 248
93128: ST_TO_ADDR
// weapon := 0 ;
93129: LD_ADDR_VAR 0 8
93133: PUSH
93134: LD_INT 0
93136: ST_TO_ADDR
// if not nat then
93137: LD_VAR 0 7
93141: NOT
93142: IFFALSE 93146
// continue ;
93144: GO 93111
// for j in list [ nat ] do
93146: LD_ADDR_VAR 0 5
93150: PUSH
93151: LD_VAR 0 10
93155: PUSH
93156: LD_VAR 0 7
93160: ARRAY
93161: PUSH
93162: FOR_IN
93163: IFFALSE 93204
// if GetBWeapon ( i ) = j [ 1 ] then
93165: LD_VAR 0 4
93169: PPUSH
93170: CALL_OW 269
93174: PUSH
93175: LD_VAR 0 5
93179: PUSH
93180: LD_INT 1
93182: ARRAY
93183: EQUAL
93184: IFFALSE 93202
// begin weapon := j [ 2 ] ;
93186: LD_ADDR_VAR 0 8
93190: PUSH
93191: LD_VAR 0 5
93195: PUSH
93196: LD_INT 2
93198: ARRAY
93199: ST_TO_ADDR
// break ;
93200: GO 93204
// end ;
93202: GO 93162
93204: POP
93205: POP
// if not weapon then
93206: LD_VAR 0 8
93210: NOT
93211: IFFALSE 93215
// continue ;
93213: GO 93111
// for k in factories do
93215: LD_ADDR_VAR 0 6
93219: PUSH
93220: LD_VAR 0 2
93224: PUSH
93225: FOR_IN
93226: IFFALSE 93291
// begin weapons := AvailableWeaponList ( k ) ;
93228: LD_ADDR_VAR 0 9
93232: PUSH
93233: LD_VAR 0 6
93237: PPUSH
93238: CALL_OW 478
93242: ST_TO_ADDR
// if not weapons then
93243: LD_VAR 0 9
93247: NOT
93248: IFFALSE 93252
// continue ;
93250: GO 93225
// if weapon in weapons then
93252: LD_VAR 0 8
93256: PUSH
93257: LD_VAR 0 9
93261: IN
93262: IFFALSE 93289
// begin result := [ i , weapon ] ;
93264: LD_ADDR_VAR 0 3
93268: PUSH
93269: LD_VAR 0 4
93273: PUSH
93274: LD_VAR 0 8
93278: PUSH
93279: EMPTY
93280: LIST
93281: LIST
93282: ST_TO_ADDR
// exit ;
93283: POP
93284: POP
93285: POP
93286: POP
93287: GO 93297
// end ; end ;
93289: GO 93225
93291: POP
93292: POP
// end ;
93293: GO 93111
93295: POP
93296: POP
// end ;
93297: LD_VAR 0 3
93301: RET
// export function RevealMapOnXY ( x , y , side , range ) ; begin
93302: LD_INT 0
93304: PPUSH
// if not side or side > 8 then
93305: LD_VAR 0 3
93309: NOT
93310: PUSH
93311: LD_VAR 0 3
93315: PUSH
93316: LD_INT 8
93318: GREATER
93319: OR
93320: IFFALSE 93324
// exit ;
93322: GO 93383
// if not range then
93324: LD_VAR 0 4
93328: NOT
93329: IFFALSE 93340
// range := - 12 ;
93331: LD_ADDR_VAR 0 4
93335: PUSH
93336: LD_INT 12
93338: NEG
93339: ST_TO_ADDR
// PlaceSeeing ( x , y , side , range ) ;
93340: LD_VAR 0 1
93344: PPUSH
93345: LD_VAR 0 2
93349: PPUSH
93350: LD_VAR 0 3
93354: PPUSH
93355: LD_VAR 0 4
93359: PPUSH
93360: CALL_OW 330
// RemoveSeeing ( x , y , side ) ;
93364: LD_VAR 0 1
93368: PPUSH
93369: LD_VAR 0 2
93373: PPUSH
93374: LD_VAR 0 3
93378: PPUSH
93379: CALL_OW 331
// end ;
93383: LD_VAR 0 5
93387: RET
// export function Video ( mode ) ; begin
93388: LD_INT 0
93390: PPUSH
// ingame_video = mode ;
93391: LD_ADDR_OWVAR 52
93395: PUSH
93396: LD_VAR 0 1
93400: ST_TO_ADDR
// interface_hidden = mode ;
93401: LD_ADDR_OWVAR 54
93405: PUSH
93406: LD_VAR 0 1
93410: ST_TO_ADDR
// end ;
93411: LD_VAR 0 2
93415: RET
// export function Join ( array , element ) ; begin
93416: LD_INT 0
93418: PPUSH
// result := array ^ element ;
93419: LD_ADDR_VAR 0 3
93423: PUSH
93424: LD_VAR 0 1
93428: PUSH
93429: LD_VAR 0 2
93433: ADD
93434: ST_TO_ADDR
// end ;
93435: LD_VAR 0 3
93439: RET
// export function JoinUnion ( array , element ) ; begin
93440: LD_INT 0
93442: PPUSH
// result := array union element ;
93443: LD_ADDR_VAR 0 3
93447: PUSH
93448: LD_VAR 0 1
93452: PUSH
93453: LD_VAR 0 2
93457: UNION
93458: ST_TO_ADDR
// end ;
93459: LD_VAR 0 3
93463: RET
// export function GetBehemoths ( side ) ; begin
93464: LD_INT 0
93466: PPUSH
// result := FilterAllUnits ( [ [ f_side , side ] , [ f_chassis , 25 ] ] ) ;
93467: LD_ADDR_VAR 0 2
93471: PUSH
93472: LD_INT 22
93474: PUSH
93475: LD_VAR 0 1
93479: PUSH
93480: EMPTY
93481: LIST
93482: LIST
93483: PUSH
93484: LD_INT 31
93486: PUSH
93487: LD_INT 25
93489: PUSH
93490: EMPTY
93491: LIST
93492: LIST
93493: PUSH
93494: EMPTY
93495: LIST
93496: LIST
93497: PPUSH
93498: CALL_OW 69
93502: ST_TO_ADDR
// end ;
93503: LD_VAR 0 2
93507: RET
// export function Shuffle ( array ) ; var i , index ; begin
93508: LD_INT 0
93510: PPUSH
93511: PPUSH
93512: PPUSH
// result := [ ] ;
93513: LD_ADDR_VAR 0 2
93517: PUSH
93518: EMPTY
93519: ST_TO_ADDR
// if not array then
93520: LD_VAR 0 1
93524: NOT
93525: IFFALSE 93529
// exit ;
93527: GO 93628
// Randomize ;
93529: CALL_OW 10
// for i = array downto 1 do
93533: LD_ADDR_VAR 0 3
93537: PUSH
93538: DOUBLE
93539: LD_VAR 0 1
93543: INC
93544: ST_TO_ADDR
93545: LD_INT 1
93547: PUSH
93548: FOR_DOWNTO
93549: IFFALSE 93626
// begin index := rand ( 1 , array ) ;
93551: LD_ADDR_VAR 0 4
93555: PUSH
93556: LD_INT 1
93558: PPUSH
93559: LD_VAR 0 1
93563: PPUSH
93564: CALL_OW 12
93568: ST_TO_ADDR
// result := Insert ( result , result + 1 , array [ index ] ) ;
93569: LD_ADDR_VAR 0 2
93573: PUSH
93574: LD_VAR 0 2
93578: PPUSH
93579: LD_VAR 0 2
93583: PUSH
93584: LD_INT 1
93586: PLUS
93587: PPUSH
93588: LD_VAR 0 1
93592: PUSH
93593: LD_VAR 0 4
93597: ARRAY
93598: PPUSH
93599: CALL_OW 2
93603: ST_TO_ADDR
// array := Delete ( array , index ) ;
93604: LD_ADDR_VAR 0 1
93608: PUSH
93609: LD_VAR 0 1
93613: PPUSH
93614: LD_VAR 0 4
93618: PPUSH
93619: CALL_OW 3
93623: ST_TO_ADDR
// end ;
93624: GO 93548
93626: POP
93627: POP
// end ;
93628: LD_VAR 0 2
93632: RET
// export function GetBaseMaterials ( base ) ; begin
93633: LD_INT 0
93635: PPUSH
// result := [ 0 , 0 , 0 ] ;
93636: LD_ADDR_VAR 0 2
93640: PUSH
93641: LD_INT 0
93643: PUSH
93644: LD_INT 0
93646: PUSH
93647: LD_INT 0
93649: PUSH
93650: EMPTY
93651: LIST
93652: LIST
93653: LIST
93654: ST_TO_ADDR
// if not base then
93655: LD_VAR 0 1
93659: NOT
93660: IFFALSE 93664
// exit ;
93662: GO 93713
// result := [ GetResourceType ( base , mat_cans ) , GetResourceType ( base , mat_oil ) , GetResourceType ( base , mat_siberit ) ] ;
93664: LD_ADDR_VAR 0 2
93668: PUSH
93669: LD_VAR 0 1
93673: PPUSH
93674: LD_INT 1
93676: PPUSH
93677: CALL_OW 275
93681: PUSH
93682: LD_VAR 0 1
93686: PPUSH
93687: LD_INT 2
93689: PPUSH
93690: CALL_OW 275
93694: PUSH
93695: LD_VAR 0 1
93699: PPUSH
93700: LD_INT 3
93702: PPUSH
93703: CALL_OW 275
93707: PUSH
93708: EMPTY
93709: LIST
93710: LIST
93711: LIST
93712: ST_TO_ADDR
// end ; end_of_file end_of_file
93713: LD_VAR 0 2
93717: RET
// export StreamModeActive , normalCounter , hardcoreCounter , sSpec , sSpeed , sRocket , sEngine , sLevel , sArmoury , sRadar , sBunker , sHack , sFire , sRefresh , sExp , sDepot , sFlag , sSold , sDiff , sTiger , sBomb , sFog , sReset , sSun , sKamikadze , sTroll , sSlow , sLack , sWound , sTank , sRemote , sPowell , sBetray , sContamin , sTeleport , sOil , sOilTower , sShovel , sSheik , sStu , sEarthquake , sAI , sBazooka , sMortar , sCargo , sDLaser , sExchange , sFac , sPower , sRandom , sShield , sTime , sTools , sRanger ; every 0 0$1 do
93718: GO 93720
93720: DISABLE
// begin ToLua ( initStreamRollete(); ) ;
93721: LD_STRING initStreamRollete();
93723: PPUSH
93724: CALL_OW 559
// InitStreamMode ;
93728: CALL 93737 0 0
// DefineStreamItems ( ) ;
93732: CALL 94177 0 0
// end ;
93736: END
// function InitStreamMode ; begin
93737: LD_INT 0
93739: PPUSH
// streamModeActive := false ;
93740: LD_ADDR_EXP 122
93744: PUSH
93745: LD_INT 0
93747: ST_TO_ADDR
// normalCounter := 36 ;
93748: LD_ADDR_EXP 123
93752: PUSH
93753: LD_INT 36
93755: ST_TO_ADDR
// hardcoreCounter := 16 ;
93756: LD_ADDR_EXP 124
93760: PUSH
93761: LD_INT 16
93763: ST_TO_ADDR
// sRocket := false ;
93764: LD_ADDR_EXP 127
93768: PUSH
93769: LD_INT 0
93771: ST_TO_ADDR
// sSpeed := false ;
93772: LD_ADDR_EXP 126
93776: PUSH
93777: LD_INT 0
93779: ST_TO_ADDR
// sEngine := false ;
93780: LD_ADDR_EXP 128
93784: PUSH
93785: LD_INT 0
93787: ST_TO_ADDR
// sSpec := false ;
93788: LD_ADDR_EXP 125
93792: PUSH
93793: LD_INT 0
93795: ST_TO_ADDR
// sLevel := false ;
93796: LD_ADDR_EXP 129
93800: PUSH
93801: LD_INT 0
93803: ST_TO_ADDR
// sArmoury := false ;
93804: LD_ADDR_EXP 130
93808: PUSH
93809: LD_INT 0
93811: ST_TO_ADDR
// sRadar := false ;
93812: LD_ADDR_EXP 131
93816: PUSH
93817: LD_INT 0
93819: ST_TO_ADDR
// sBunker := false ;
93820: LD_ADDR_EXP 132
93824: PUSH
93825: LD_INT 0
93827: ST_TO_ADDR
// sHack := false ;
93828: LD_ADDR_EXP 133
93832: PUSH
93833: LD_INT 0
93835: ST_TO_ADDR
// sFire := false ;
93836: LD_ADDR_EXP 134
93840: PUSH
93841: LD_INT 0
93843: ST_TO_ADDR
// sRefresh := false ;
93844: LD_ADDR_EXP 135
93848: PUSH
93849: LD_INT 0
93851: ST_TO_ADDR
// sExp := false ;
93852: LD_ADDR_EXP 136
93856: PUSH
93857: LD_INT 0
93859: ST_TO_ADDR
// sDepot := false ;
93860: LD_ADDR_EXP 137
93864: PUSH
93865: LD_INT 0
93867: ST_TO_ADDR
// sFlag := false ;
93868: LD_ADDR_EXP 138
93872: PUSH
93873: LD_INT 0
93875: ST_TO_ADDR
// sKamikadze := false ;
93876: LD_ADDR_EXP 146
93880: PUSH
93881: LD_INT 0
93883: ST_TO_ADDR
// sTroll := false ;
93884: LD_ADDR_EXP 147
93888: PUSH
93889: LD_INT 0
93891: ST_TO_ADDR
// sSlow := false ;
93892: LD_ADDR_EXP 148
93896: PUSH
93897: LD_INT 0
93899: ST_TO_ADDR
// sLack := false ;
93900: LD_ADDR_EXP 149
93904: PUSH
93905: LD_INT 0
93907: ST_TO_ADDR
// sTank := false ;
93908: LD_ADDR_EXP 151
93912: PUSH
93913: LD_INT 0
93915: ST_TO_ADDR
// sRemote := false ;
93916: LD_ADDR_EXP 152
93920: PUSH
93921: LD_INT 0
93923: ST_TO_ADDR
// sPowell := false ;
93924: LD_ADDR_EXP 153
93928: PUSH
93929: LD_INT 0
93931: ST_TO_ADDR
// sTeleport := false ;
93932: LD_ADDR_EXP 156
93936: PUSH
93937: LD_INT 0
93939: ST_TO_ADDR
// sOilTower := false ;
93940: LD_ADDR_EXP 158
93944: PUSH
93945: LD_INT 0
93947: ST_TO_ADDR
// sShovel := false ;
93948: LD_ADDR_EXP 159
93952: PUSH
93953: LD_INT 0
93955: ST_TO_ADDR
// sSheik := false ;
93956: LD_ADDR_EXP 160
93960: PUSH
93961: LD_INT 0
93963: ST_TO_ADDR
// sEarthquake := false ;
93964: LD_ADDR_EXP 162
93968: PUSH
93969: LD_INT 0
93971: ST_TO_ADDR
// sAI := false ;
93972: LD_ADDR_EXP 163
93976: PUSH
93977: LD_INT 0
93979: ST_TO_ADDR
// sCargo := false ;
93980: LD_ADDR_EXP 166
93984: PUSH
93985: LD_INT 0
93987: ST_TO_ADDR
// sDLaser := false ;
93988: LD_ADDR_EXP 167
93992: PUSH
93993: LD_INT 0
93995: ST_TO_ADDR
// sExchange := false ;
93996: LD_ADDR_EXP 168
94000: PUSH
94001: LD_INT 0
94003: ST_TO_ADDR
// sFac := false ;
94004: LD_ADDR_EXP 169
94008: PUSH
94009: LD_INT 0
94011: ST_TO_ADDR
// sPower := false ;
94012: LD_ADDR_EXP 170
94016: PUSH
94017: LD_INT 0
94019: ST_TO_ADDR
// sRandom := false ;
94020: LD_ADDR_EXP 171
94024: PUSH
94025: LD_INT 0
94027: ST_TO_ADDR
// sShield := false ;
94028: LD_ADDR_EXP 172
94032: PUSH
94033: LD_INT 0
94035: ST_TO_ADDR
// sTime := false ;
94036: LD_ADDR_EXP 173
94040: PUSH
94041: LD_INT 0
94043: ST_TO_ADDR
// sTools := false ;
94044: LD_ADDR_EXP 174
94048: PUSH
94049: LD_INT 0
94051: ST_TO_ADDR
// sSold := false ;
94052: LD_ADDR_EXP 139
94056: PUSH
94057: LD_INT 0
94059: ST_TO_ADDR
// sDiff := false ;
94060: LD_ADDR_EXP 140
94064: PUSH
94065: LD_INT 0
94067: ST_TO_ADDR
// sFog := false ;
94068: LD_ADDR_EXP 143
94072: PUSH
94073: LD_INT 0
94075: ST_TO_ADDR
// sReset := false ;
94076: LD_ADDR_EXP 144
94080: PUSH
94081: LD_INT 0
94083: ST_TO_ADDR
// sSun := false ;
94084: LD_ADDR_EXP 145
94088: PUSH
94089: LD_INT 0
94091: ST_TO_ADDR
// sTiger := false ;
94092: LD_ADDR_EXP 141
94096: PUSH
94097: LD_INT 0
94099: ST_TO_ADDR
// sBomb := false ;
94100: LD_ADDR_EXP 142
94104: PUSH
94105: LD_INT 0
94107: ST_TO_ADDR
// sWound := false ;
94108: LD_ADDR_EXP 150
94112: PUSH
94113: LD_INT 0
94115: ST_TO_ADDR
// sBetray := false ;
94116: LD_ADDR_EXP 154
94120: PUSH
94121: LD_INT 0
94123: ST_TO_ADDR
// sContamin := false ;
94124: LD_ADDR_EXP 155
94128: PUSH
94129: LD_INT 0
94131: ST_TO_ADDR
// sOil := false ;
94132: LD_ADDR_EXP 157
94136: PUSH
94137: LD_INT 0
94139: ST_TO_ADDR
// sStu := false ;
94140: LD_ADDR_EXP 161
94144: PUSH
94145: LD_INT 0
94147: ST_TO_ADDR
// sBazooka := false ;
94148: LD_ADDR_EXP 164
94152: PUSH
94153: LD_INT 0
94155: ST_TO_ADDR
// sMortar := false ;
94156: LD_ADDR_EXP 165
94160: PUSH
94161: LD_INT 0
94163: ST_TO_ADDR
// sRanger := false ;
94164: LD_ADDR_EXP 175
94168: PUSH
94169: LD_INT 0
94171: ST_TO_ADDR
// end ;
94172: LD_VAR 0 1
94176: RET
// function DefineStreamItems ( ) ; var tmp , normal , hardcore , i ; begin
94177: LD_INT 0
94179: PPUSH
94180: PPUSH
94181: PPUSH
94182: PPUSH
94183: PPUSH
// result := [ ] ;
94184: LD_ADDR_VAR 0 1
94188: PUSH
94189: EMPTY
94190: ST_TO_ADDR
// if campaign_id = 1 then
94191: LD_OWVAR 69
94195: PUSH
94196: LD_INT 1
94198: EQUAL
94199: IFFALSE 97137
// begin case mission_number of 1 :
94201: LD_OWVAR 70
94205: PUSH
94206: LD_INT 1
94208: DOUBLE
94209: EQUAL
94210: IFTRUE 94214
94212: GO 94278
94214: POP
// result := [ [ 2 , 4 , 11 , 12 , 15 , 16 , 22 , 23 , 26 ] , [ 101 , 102 , 106 ] ] ; 2 :
94215: LD_ADDR_VAR 0 1
94219: PUSH
94220: LD_INT 2
94222: PUSH
94223: LD_INT 4
94225: PUSH
94226: LD_INT 11
94228: PUSH
94229: LD_INT 12
94231: PUSH
94232: LD_INT 15
94234: PUSH
94235: LD_INT 16
94237: PUSH
94238: LD_INT 22
94240: PUSH
94241: LD_INT 23
94243: PUSH
94244: LD_INT 26
94246: PUSH
94247: EMPTY
94248: LIST
94249: LIST
94250: LIST
94251: LIST
94252: LIST
94253: LIST
94254: LIST
94255: LIST
94256: LIST
94257: PUSH
94258: LD_INT 101
94260: PUSH
94261: LD_INT 102
94263: PUSH
94264: LD_INT 106
94266: PUSH
94267: EMPTY
94268: LIST
94269: LIST
94270: LIST
94271: PUSH
94272: EMPTY
94273: LIST
94274: LIST
94275: ST_TO_ADDR
94276: GO 97135
94278: LD_INT 2
94280: DOUBLE
94281: EQUAL
94282: IFTRUE 94286
94284: GO 94358
94286: POP
// result := [ [ 2 , 4 , 11 , 12 , 15 , 16 , 22 , 23 , 26 ] , [ 101 , 102 , 105 , 106 , 108 ] ] ; 3 :
94287: LD_ADDR_VAR 0 1
94291: PUSH
94292: LD_INT 2
94294: PUSH
94295: LD_INT 4
94297: PUSH
94298: LD_INT 11
94300: PUSH
94301: LD_INT 12
94303: PUSH
94304: LD_INT 15
94306: PUSH
94307: LD_INT 16
94309: PUSH
94310: LD_INT 22
94312: PUSH
94313: LD_INT 23
94315: PUSH
94316: LD_INT 26
94318: PUSH
94319: EMPTY
94320: LIST
94321: LIST
94322: LIST
94323: LIST
94324: LIST
94325: LIST
94326: LIST
94327: LIST
94328: LIST
94329: PUSH
94330: LD_INT 101
94332: PUSH
94333: LD_INT 102
94335: PUSH
94336: LD_INT 105
94338: PUSH
94339: LD_INT 106
94341: PUSH
94342: LD_INT 108
94344: PUSH
94345: EMPTY
94346: LIST
94347: LIST
94348: LIST
94349: LIST
94350: LIST
94351: PUSH
94352: EMPTY
94353: LIST
94354: LIST
94355: ST_TO_ADDR
94356: GO 97135
94358: LD_INT 3
94360: DOUBLE
94361: EQUAL
94362: IFTRUE 94366
94364: GO 94442
94366: POP
// result := [ [ 2 , 4 , 5 , 11 , 12 , 15 , 16 , 22 , 26 , 36 ] , [ 101 , 102 , 105 , 106 , 108 ] ] ; 4 :
94367: LD_ADDR_VAR 0 1
94371: PUSH
94372: LD_INT 2
94374: PUSH
94375: LD_INT 4
94377: PUSH
94378: LD_INT 5
94380: PUSH
94381: LD_INT 11
94383: PUSH
94384: LD_INT 12
94386: PUSH
94387: LD_INT 15
94389: PUSH
94390: LD_INT 16
94392: PUSH
94393: LD_INT 22
94395: PUSH
94396: LD_INT 26
94398: PUSH
94399: LD_INT 36
94401: PUSH
94402: EMPTY
94403: LIST
94404: LIST
94405: LIST
94406: LIST
94407: LIST
94408: LIST
94409: LIST
94410: LIST
94411: LIST
94412: LIST
94413: PUSH
94414: LD_INT 101
94416: PUSH
94417: LD_INT 102
94419: PUSH
94420: LD_INT 105
94422: PUSH
94423: LD_INT 106
94425: PUSH
94426: LD_INT 108
94428: PUSH
94429: EMPTY
94430: LIST
94431: LIST
94432: LIST
94433: LIST
94434: LIST
94435: PUSH
94436: EMPTY
94437: LIST
94438: LIST
94439: ST_TO_ADDR
94440: GO 97135
94442: LD_INT 4
94444: DOUBLE
94445: EQUAL
94446: IFTRUE 94450
94448: GO 94534
94450: POP
// result := [ [ 2 , 4 , 5 , 8 , 11 , 12 , 15 , 16 , 22 , 23 , 26 , 36 ] , [ 101 , 102 , 105 , 106 , 108 ] ] ; 5 :
94451: LD_ADDR_VAR 0 1
94455: PUSH
94456: LD_INT 2
94458: PUSH
94459: LD_INT 4
94461: PUSH
94462: LD_INT 5
94464: PUSH
94465: LD_INT 8
94467: PUSH
94468: LD_INT 11
94470: PUSH
94471: LD_INT 12
94473: PUSH
94474: LD_INT 15
94476: PUSH
94477: LD_INT 16
94479: PUSH
94480: LD_INT 22
94482: PUSH
94483: LD_INT 23
94485: PUSH
94486: LD_INT 26
94488: PUSH
94489: LD_INT 36
94491: PUSH
94492: EMPTY
94493: LIST
94494: LIST
94495: LIST
94496: LIST
94497: LIST
94498: LIST
94499: LIST
94500: LIST
94501: LIST
94502: LIST
94503: LIST
94504: LIST
94505: PUSH
94506: LD_INT 101
94508: PUSH
94509: LD_INT 102
94511: PUSH
94512: LD_INT 105
94514: PUSH
94515: LD_INT 106
94517: PUSH
94518: LD_INT 108
94520: PUSH
94521: EMPTY
94522: LIST
94523: LIST
94524: LIST
94525: LIST
94526: LIST
94527: PUSH
94528: EMPTY
94529: LIST
94530: LIST
94531: ST_TO_ADDR
94532: GO 97135
94534: LD_INT 5
94536: DOUBLE
94537: EQUAL
94538: IFTRUE 94542
94540: GO 94642
94542: POP
// result := [ [ 2 , 4 , 5 , 6 , 8 , 11 , 12 , 15 , 16 , 22 , 23 , 25 , 26 , 36 ] , [ 101 , 102 , 105 , 106 , 108 , 109 , 112 ] ] ; 6 :
94543: LD_ADDR_VAR 0 1
94547: PUSH
94548: LD_INT 2
94550: PUSH
94551: LD_INT 4
94553: PUSH
94554: LD_INT 5
94556: PUSH
94557: LD_INT 6
94559: PUSH
94560: LD_INT 8
94562: PUSH
94563: LD_INT 11
94565: PUSH
94566: LD_INT 12
94568: PUSH
94569: LD_INT 15
94571: PUSH
94572: LD_INT 16
94574: PUSH
94575: LD_INT 22
94577: PUSH
94578: LD_INT 23
94580: PUSH
94581: LD_INT 25
94583: PUSH
94584: LD_INT 26
94586: PUSH
94587: LD_INT 36
94589: PUSH
94590: EMPTY
94591: LIST
94592: LIST
94593: LIST
94594: LIST
94595: LIST
94596: LIST
94597: LIST
94598: LIST
94599: LIST
94600: LIST
94601: LIST
94602: LIST
94603: LIST
94604: LIST
94605: PUSH
94606: LD_INT 101
94608: PUSH
94609: LD_INT 102
94611: PUSH
94612: LD_INT 105
94614: PUSH
94615: LD_INT 106
94617: PUSH
94618: LD_INT 108
94620: PUSH
94621: LD_INT 109
94623: PUSH
94624: LD_INT 112
94626: PUSH
94627: EMPTY
94628: LIST
94629: LIST
94630: LIST
94631: LIST
94632: LIST
94633: LIST
94634: LIST
94635: PUSH
94636: EMPTY
94637: LIST
94638: LIST
94639: ST_TO_ADDR
94640: GO 97135
94642: LD_INT 6
94644: DOUBLE
94645: EQUAL
94646: IFTRUE 94650
94648: GO 94770
94650: POP
// result := [ [ 2 , 4 , 5 , 6 , 8 , 11 , 12 , 15 , 16 , 20 , 21 , 22 , 23 , 25 , 26 , 30 , 31 , 32 , 36 ] , [ 101 , 102 , 105 , 106 , 108 , 109 , 112 ] ] ; 7 :
94651: LD_ADDR_VAR 0 1
94655: PUSH
94656: LD_INT 2
94658: PUSH
94659: LD_INT 4
94661: PUSH
94662: LD_INT 5
94664: PUSH
94665: LD_INT 6
94667: PUSH
94668: LD_INT 8
94670: PUSH
94671: LD_INT 11
94673: PUSH
94674: LD_INT 12
94676: PUSH
94677: LD_INT 15
94679: PUSH
94680: LD_INT 16
94682: PUSH
94683: LD_INT 20
94685: PUSH
94686: LD_INT 21
94688: PUSH
94689: LD_INT 22
94691: PUSH
94692: LD_INT 23
94694: PUSH
94695: LD_INT 25
94697: PUSH
94698: LD_INT 26
94700: PUSH
94701: LD_INT 30
94703: PUSH
94704: LD_INT 31
94706: PUSH
94707: LD_INT 32
94709: PUSH
94710: LD_INT 36
94712: PUSH
94713: EMPTY
94714: LIST
94715: LIST
94716: LIST
94717: LIST
94718: LIST
94719: LIST
94720: LIST
94721: LIST
94722: LIST
94723: LIST
94724: LIST
94725: LIST
94726: LIST
94727: LIST
94728: LIST
94729: LIST
94730: LIST
94731: LIST
94732: LIST
94733: PUSH
94734: LD_INT 101
94736: PUSH
94737: LD_INT 102
94739: PUSH
94740: LD_INT 105
94742: PUSH
94743: LD_INT 106
94745: PUSH
94746: LD_INT 108
94748: PUSH
94749: LD_INT 109
94751: PUSH
94752: LD_INT 112
94754: PUSH
94755: EMPTY
94756: LIST
94757: LIST
94758: LIST
94759: LIST
94760: LIST
94761: LIST
94762: LIST
94763: PUSH
94764: EMPTY
94765: LIST
94766: LIST
94767: ST_TO_ADDR
94768: GO 97135
94770: LD_INT 7
94772: DOUBLE
94773: EQUAL
94774: IFTRUE 94778
94776: GO 94878
94778: POP
// result := [ [ 2 , 4 , 5 , 7 , 11 , 12 , 15 , 16 , 20 , 21 , 22 , 23 , 25 , 26 ] , [ 101 , 102 , 103 , 105 , 106 , 108 , 112 ] ] ; 8 :
94779: LD_ADDR_VAR 0 1
94783: PUSH
94784: LD_INT 2
94786: PUSH
94787: LD_INT 4
94789: PUSH
94790: LD_INT 5
94792: PUSH
94793: LD_INT 7
94795: PUSH
94796: LD_INT 11
94798: PUSH
94799: LD_INT 12
94801: PUSH
94802: LD_INT 15
94804: PUSH
94805: LD_INT 16
94807: PUSH
94808: LD_INT 20
94810: PUSH
94811: LD_INT 21
94813: PUSH
94814: LD_INT 22
94816: PUSH
94817: LD_INT 23
94819: PUSH
94820: LD_INT 25
94822: PUSH
94823: LD_INT 26
94825: PUSH
94826: EMPTY
94827: LIST
94828: LIST
94829: LIST
94830: LIST
94831: LIST
94832: LIST
94833: LIST
94834: LIST
94835: LIST
94836: LIST
94837: LIST
94838: LIST
94839: LIST
94840: LIST
94841: PUSH
94842: LD_INT 101
94844: PUSH
94845: LD_INT 102
94847: PUSH
94848: LD_INT 103
94850: PUSH
94851: LD_INT 105
94853: PUSH
94854: LD_INT 106
94856: PUSH
94857: LD_INT 108
94859: PUSH
94860: LD_INT 112
94862: PUSH
94863: EMPTY
94864: LIST
94865: LIST
94866: LIST
94867: LIST
94868: LIST
94869: LIST
94870: LIST
94871: PUSH
94872: EMPTY
94873: LIST
94874: LIST
94875: ST_TO_ADDR
94876: GO 97135
94878: LD_INT 8
94880: DOUBLE
94881: EQUAL
94882: IFTRUE 94886
94884: GO 95014
94886: POP
// result := [ [ 2 , 4 , 5 , 6 , 7 , 8 , 11 , 12 , 15 , 16 , 20 , 21 , 22 , 23 , 25 , 26 , 30 , 31 , 32 , 36 ] , [ 101 , 102 , 103 , 105 , 106 , 108 , 109 , 112 ] ] ; 9 :
94887: LD_ADDR_VAR 0 1
94891: PUSH
94892: LD_INT 2
94894: PUSH
94895: LD_INT 4
94897: PUSH
94898: LD_INT 5
94900: PUSH
94901: LD_INT 6
94903: PUSH
94904: LD_INT 7
94906: PUSH
94907: LD_INT 8
94909: PUSH
94910: LD_INT 11
94912: PUSH
94913: LD_INT 12
94915: PUSH
94916: LD_INT 15
94918: PUSH
94919: LD_INT 16
94921: PUSH
94922: LD_INT 20
94924: PUSH
94925: LD_INT 21
94927: PUSH
94928: LD_INT 22
94930: PUSH
94931: LD_INT 23
94933: PUSH
94934: LD_INT 25
94936: PUSH
94937: LD_INT 26
94939: PUSH
94940: LD_INT 30
94942: PUSH
94943: LD_INT 31
94945: PUSH
94946: LD_INT 32
94948: PUSH
94949: LD_INT 36
94951: PUSH
94952: EMPTY
94953: LIST
94954: LIST
94955: LIST
94956: LIST
94957: LIST
94958: LIST
94959: LIST
94960: LIST
94961: LIST
94962: LIST
94963: LIST
94964: LIST
94965: LIST
94966: LIST
94967: LIST
94968: LIST
94969: LIST
94970: LIST
94971: LIST
94972: LIST
94973: PUSH
94974: LD_INT 101
94976: PUSH
94977: LD_INT 102
94979: PUSH
94980: LD_INT 103
94982: PUSH
94983: LD_INT 105
94985: PUSH
94986: LD_INT 106
94988: PUSH
94989: LD_INT 108
94991: PUSH
94992: LD_INT 109
94994: PUSH
94995: LD_INT 112
94997: PUSH
94998: EMPTY
94999: LIST
95000: LIST
95001: LIST
95002: LIST
95003: LIST
95004: LIST
95005: LIST
95006: LIST
95007: PUSH
95008: EMPTY
95009: LIST
95010: LIST
95011: ST_TO_ADDR
95012: GO 97135
95014: LD_INT 9
95016: DOUBLE
95017: EQUAL
95018: IFTRUE 95022
95020: GO 95158
95022: POP
// result := [ [ 2 , 4 , 5 , 6 , 7 , 8 , 11 , 12 , 15 , 16 , 20 , 21 , 22 , 23 , 25 , 26 , 28 , 30 , 31 , 32 , 36 ] , [ 101 , 102 , 103 , 105 , 106 , 108 , 109 , 112 , 114 ] ] ; 10 :
95023: LD_ADDR_VAR 0 1
95027: PUSH
95028: LD_INT 2
95030: PUSH
95031: LD_INT 4
95033: PUSH
95034: LD_INT 5
95036: PUSH
95037: LD_INT 6
95039: PUSH
95040: LD_INT 7
95042: PUSH
95043: LD_INT 8
95045: PUSH
95046: LD_INT 11
95048: PUSH
95049: LD_INT 12
95051: PUSH
95052: LD_INT 15
95054: PUSH
95055: LD_INT 16
95057: PUSH
95058: LD_INT 20
95060: PUSH
95061: LD_INT 21
95063: PUSH
95064: LD_INT 22
95066: PUSH
95067: LD_INT 23
95069: PUSH
95070: LD_INT 25
95072: PUSH
95073: LD_INT 26
95075: PUSH
95076: LD_INT 28
95078: PUSH
95079: LD_INT 30
95081: PUSH
95082: LD_INT 31
95084: PUSH
95085: LD_INT 32
95087: PUSH
95088: LD_INT 36
95090: PUSH
95091: EMPTY
95092: LIST
95093: LIST
95094: LIST
95095: LIST
95096: LIST
95097: LIST
95098: LIST
95099: LIST
95100: LIST
95101: LIST
95102: LIST
95103: LIST
95104: LIST
95105: LIST
95106: LIST
95107: LIST
95108: LIST
95109: LIST
95110: LIST
95111: LIST
95112: LIST
95113: PUSH
95114: LD_INT 101
95116: PUSH
95117: LD_INT 102
95119: PUSH
95120: LD_INT 103
95122: PUSH
95123: LD_INT 105
95125: PUSH
95126: LD_INT 106
95128: PUSH
95129: LD_INT 108
95131: PUSH
95132: LD_INT 109
95134: PUSH
95135: LD_INT 112
95137: PUSH
95138: LD_INT 114
95140: PUSH
95141: EMPTY
95142: LIST
95143: LIST
95144: LIST
95145: LIST
95146: LIST
95147: LIST
95148: LIST
95149: LIST
95150: LIST
95151: PUSH
95152: EMPTY
95153: LIST
95154: LIST
95155: ST_TO_ADDR
95156: GO 97135
95158: LD_INT 10
95160: DOUBLE
95161: EQUAL
95162: IFTRUE 95166
95164: GO 95350
95166: POP
// result := [ [ 2 , 4 , 5 , 6 , 7 , 8 , 9 , 10 , 11 , 12 , 13 , 14 , 15 , 16 , 17 , 18 , 19 , 20 , 21 , 22 , 23 , 24 , 25 , 26 , 28 , 30 , 31 , 32 , 36 ] , [ 101 , 102 , 103 , 104 , 105 , 106 , 107 , 108 , 109 , 110 , 111 , 112 , 114 ] ] ; 11 :
95167: LD_ADDR_VAR 0 1
95171: PUSH
95172: LD_INT 2
95174: PUSH
95175: LD_INT 4
95177: PUSH
95178: LD_INT 5
95180: PUSH
95181: LD_INT 6
95183: PUSH
95184: LD_INT 7
95186: PUSH
95187: LD_INT 8
95189: PUSH
95190: LD_INT 9
95192: PUSH
95193: LD_INT 10
95195: PUSH
95196: LD_INT 11
95198: PUSH
95199: LD_INT 12
95201: PUSH
95202: LD_INT 13
95204: PUSH
95205: LD_INT 14
95207: PUSH
95208: LD_INT 15
95210: PUSH
95211: LD_INT 16
95213: PUSH
95214: LD_INT 17
95216: PUSH
95217: LD_INT 18
95219: PUSH
95220: LD_INT 19
95222: PUSH
95223: LD_INT 20
95225: PUSH
95226: LD_INT 21
95228: PUSH
95229: LD_INT 22
95231: PUSH
95232: LD_INT 23
95234: PUSH
95235: LD_INT 24
95237: PUSH
95238: LD_INT 25
95240: PUSH
95241: LD_INT 26
95243: PUSH
95244: LD_INT 28
95246: PUSH
95247: LD_INT 30
95249: PUSH
95250: LD_INT 31
95252: PUSH
95253: LD_INT 32
95255: PUSH
95256: LD_INT 36
95258: PUSH
95259: EMPTY
95260: LIST
95261: LIST
95262: LIST
95263: LIST
95264: LIST
95265: LIST
95266: LIST
95267: LIST
95268: LIST
95269: LIST
95270: LIST
95271: LIST
95272: LIST
95273: LIST
95274: LIST
95275: LIST
95276: LIST
95277: LIST
95278: LIST
95279: LIST
95280: LIST
95281: LIST
95282: LIST
95283: LIST
95284: LIST
95285: LIST
95286: LIST
95287: LIST
95288: LIST
95289: PUSH
95290: LD_INT 101
95292: PUSH
95293: LD_INT 102
95295: PUSH
95296: LD_INT 103
95298: PUSH
95299: LD_INT 104
95301: PUSH
95302: LD_INT 105
95304: PUSH
95305: LD_INT 106
95307: PUSH
95308: LD_INT 107
95310: PUSH
95311: LD_INT 108
95313: PUSH
95314: LD_INT 109
95316: PUSH
95317: LD_INT 110
95319: PUSH
95320: LD_INT 111
95322: PUSH
95323: LD_INT 112
95325: PUSH
95326: LD_INT 114
95328: PUSH
95329: EMPTY
95330: LIST
95331: LIST
95332: LIST
95333: LIST
95334: LIST
95335: LIST
95336: LIST
95337: LIST
95338: LIST
95339: LIST
95340: LIST
95341: LIST
95342: LIST
95343: PUSH
95344: EMPTY
95345: LIST
95346: LIST
95347: ST_TO_ADDR
95348: GO 97135
95350: LD_INT 11
95352: DOUBLE
95353: EQUAL
95354: IFTRUE 95358
95356: GO 95550
95358: POP
// result := [ [ 2 , 3 , 4 , 5 , 6 , 7 , 8 , 9 , 10 , 11 , 12 , 13 , 14 , 15 , 16 , 17 , 18 , 19 , 20 , 21 , 22 , 23 , 24 , 25 , 26 , 28 , 30 , 31 , 32 , 34 , 36 ] , [ 101 , 102 , 103 , 104 , 105 , 106 , 107 , 108 , 109 , 110 , 111 , 112 , 114 ] ] ; 12 :
95359: LD_ADDR_VAR 0 1
95363: PUSH
95364: LD_INT 2
95366: PUSH
95367: LD_INT 3
95369: PUSH
95370: LD_INT 4
95372: PUSH
95373: LD_INT 5
95375: PUSH
95376: LD_INT 6
95378: PUSH
95379: LD_INT 7
95381: PUSH
95382: LD_INT 8
95384: PUSH
95385: LD_INT 9
95387: PUSH
95388: LD_INT 10
95390: PUSH
95391: LD_INT 11
95393: PUSH
95394: LD_INT 12
95396: PUSH
95397: LD_INT 13
95399: PUSH
95400: LD_INT 14
95402: PUSH
95403: LD_INT 15
95405: PUSH
95406: LD_INT 16
95408: PUSH
95409: LD_INT 17
95411: PUSH
95412: LD_INT 18
95414: PUSH
95415: LD_INT 19
95417: PUSH
95418: LD_INT 20
95420: PUSH
95421: LD_INT 21
95423: PUSH
95424: LD_INT 22
95426: PUSH
95427: LD_INT 23
95429: PUSH
95430: LD_INT 24
95432: PUSH
95433: LD_INT 25
95435: PUSH
95436: LD_INT 26
95438: PUSH
95439: LD_INT 28
95441: PUSH
95442: LD_INT 30
95444: PUSH
95445: LD_INT 31
95447: PUSH
95448: LD_INT 32
95450: PUSH
95451: LD_INT 34
95453: PUSH
95454: LD_INT 36
95456: PUSH
95457: EMPTY
95458: LIST
95459: LIST
95460: LIST
95461: LIST
95462: LIST
95463: LIST
95464: LIST
95465: LIST
95466: LIST
95467: LIST
95468: LIST
95469: LIST
95470: LIST
95471: LIST
95472: LIST
95473: LIST
95474: LIST
95475: LIST
95476: LIST
95477: LIST
95478: LIST
95479: LIST
95480: LIST
95481: LIST
95482: LIST
95483: LIST
95484: LIST
95485: LIST
95486: LIST
95487: LIST
95488: LIST
95489: PUSH
95490: LD_INT 101
95492: PUSH
95493: LD_INT 102
95495: PUSH
95496: LD_INT 103
95498: PUSH
95499: LD_INT 104
95501: PUSH
95502: LD_INT 105
95504: PUSH
95505: LD_INT 106
95507: PUSH
95508: LD_INT 107
95510: PUSH
95511: LD_INT 108
95513: PUSH
95514: LD_INT 109
95516: PUSH
95517: LD_INT 110
95519: PUSH
95520: LD_INT 111
95522: PUSH
95523: LD_INT 112
95525: PUSH
95526: LD_INT 114
95528: PUSH
95529: EMPTY
95530: LIST
95531: LIST
95532: LIST
95533: LIST
95534: LIST
95535: LIST
95536: LIST
95537: LIST
95538: LIST
95539: LIST
95540: LIST
95541: LIST
95542: LIST
95543: PUSH
95544: EMPTY
95545: LIST
95546: LIST
95547: ST_TO_ADDR
95548: GO 97135
95550: LD_INT 12
95552: DOUBLE
95553: EQUAL
95554: IFTRUE 95558
95556: GO 95766
95558: POP
// result := [ [ 1 , 2 , 3 , 4 , 5 , 6 , 7 , 8 , 9 , 10 , 11 , 12 , 13 , 14 , 15 , 16 , 17 , 18 , 19 , 20 , 21 , 22 , 23 , 24 , 25 , 26 , 27 , 28 , 30 , 31 , 32 , 33 , 34 , 36 ] , [ 101 , 102 , 103 , 104 , 105 , 106 , 107 , 108 , 109 , 110 , 111 , 112 , 113 , 114 ] ] ; 13 :
95559: LD_ADDR_VAR 0 1
95563: PUSH
95564: LD_INT 1
95566: PUSH
95567: LD_INT 2
95569: PUSH
95570: LD_INT 3
95572: PUSH
95573: LD_INT 4
95575: PUSH
95576: LD_INT 5
95578: PUSH
95579: LD_INT 6
95581: PUSH
95582: LD_INT 7
95584: PUSH
95585: LD_INT 8
95587: PUSH
95588: LD_INT 9
95590: PUSH
95591: LD_INT 10
95593: PUSH
95594: LD_INT 11
95596: PUSH
95597: LD_INT 12
95599: PUSH
95600: LD_INT 13
95602: PUSH
95603: LD_INT 14
95605: PUSH
95606: LD_INT 15
95608: PUSH
95609: LD_INT 16
95611: PUSH
95612: LD_INT 17
95614: PUSH
95615: LD_INT 18
95617: PUSH
95618: LD_INT 19
95620: PUSH
95621: LD_INT 20
95623: PUSH
95624: LD_INT 21
95626: PUSH
95627: LD_INT 22
95629: PUSH
95630: LD_INT 23
95632: PUSH
95633: LD_INT 24
95635: PUSH
95636: LD_INT 25
95638: PUSH
95639: LD_INT 26
95641: PUSH
95642: LD_INT 27
95644: PUSH
95645: LD_INT 28
95647: PUSH
95648: LD_INT 30
95650: PUSH
95651: LD_INT 31
95653: PUSH
95654: LD_INT 32
95656: PUSH
95657: LD_INT 33
95659: PUSH
95660: LD_INT 34
95662: PUSH
95663: LD_INT 36
95665: PUSH
95666: EMPTY
95667: LIST
95668: LIST
95669: LIST
95670: LIST
95671: LIST
95672: LIST
95673: LIST
95674: LIST
95675: LIST
95676: LIST
95677: LIST
95678: LIST
95679: LIST
95680: LIST
95681: LIST
95682: LIST
95683: LIST
95684: LIST
95685: LIST
95686: LIST
95687: LIST
95688: LIST
95689: LIST
95690: LIST
95691: LIST
95692: LIST
95693: LIST
95694: LIST
95695: LIST
95696: LIST
95697: LIST
95698: LIST
95699: LIST
95700: LIST
95701: PUSH
95702: LD_INT 101
95704: PUSH
95705: LD_INT 102
95707: PUSH
95708: LD_INT 103
95710: PUSH
95711: LD_INT 104
95713: PUSH
95714: LD_INT 105
95716: PUSH
95717: LD_INT 106
95719: PUSH
95720: LD_INT 107
95722: PUSH
95723: LD_INT 108
95725: PUSH
95726: LD_INT 109
95728: PUSH
95729: LD_INT 110
95731: PUSH
95732: LD_INT 111
95734: PUSH
95735: LD_INT 112
95737: PUSH
95738: LD_INT 113
95740: PUSH
95741: LD_INT 114
95743: PUSH
95744: EMPTY
95745: LIST
95746: LIST
95747: LIST
95748: LIST
95749: LIST
95750: LIST
95751: LIST
95752: LIST
95753: LIST
95754: LIST
95755: LIST
95756: LIST
95757: LIST
95758: LIST
95759: PUSH
95760: EMPTY
95761: LIST
95762: LIST
95763: ST_TO_ADDR
95764: GO 97135
95766: LD_INT 13
95768: DOUBLE
95769: EQUAL
95770: IFTRUE 95774
95772: GO 95970
95774: POP
// result := [ [ 1 , 2 , 3 , 4 , 5 , 8 , 9 , 10 , 11 , 12 , 14 , 15 , 16 , 17 , 18 , 19 , 20 , 21 , 22 , 23 , 24 , 25 , 26 , 27 , 28 , 30 , 31 , 32 , 33 , 34 , 36 ] , [ 101 , 102 , 103 , 104 , 105 , 106 , 107 , 108 , 109 , 110 , 111 , 112 , 113 , 114 ] ] ; 14 :
95775: LD_ADDR_VAR 0 1
95779: PUSH
95780: LD_INT 1
95782: PUSH
95783: LD_INT 2
95785: PUSH
95786: LD_INT 3
95788: PUSH
95789: LD_INT 4
95791: PUSH
95792: LD_INT 5
95794: PUSH
95795: LD_INT 8
95797: PUSH
95798: LD_INT 9
95800: PUSH
95801: LD_INT 10
95803: PUSH
95804: LD_INT 11
95806: PUSH
95807: LD_INT 12
95809: PUSH
95810: LD_INT 14
95812: PUSH
95813: LD_INT 15
95815: PUSH
95816: LD_INT 16
95818: PUSH
95819: LD_INT 17
95821: PUSH
95822: LD_INT 18
95824: PUSH
95825: LD_INT 19
95827: PUSH
95828: LD_INT 20
95830: PUSH
95831: LD_INT 21
95833: PUSH
95834: LD_INT 22
95836: PUSH
95837: LD_INT 23
95839: PUSH
95840: LD_INT 24
95842: PUSH
95843: LD_INT 25
95845: PUSH
95846: LD_INT 26
95848: PUSH
95849: LD_INT 27
95851: PUSH
95852: LD_INT 28
95854: PUSH
95855: LD_INT 30
95857: PUSH
95858: LD_INT 31
95860: PUSH
95861: LD_INT 32
95863: PUSH
95864: LD_INT 33
95866: PUSH
95867: LD_INT 34
95869: PUSH
95870: LD_INT 36
95872: PUSH
95873: EMPTY
95874: LIST
95875: LIST
95876: LIST
95877: LIST
95878: LIST
95879: LIST
95880: LIST
95881: LIST
95882: LIST
95883: LIST
95884: LIST
95885: LIST
95886: LIST
95887: LIST
95888: LIST
95889: LIST
95890: LIST
95891: LIST
95892: LIST
95893: LIST
95894: LIST
95895: LIST
95896: LIST
95897: LIST
95898: LIST
95899: LIST
95900: LIST
95901: LIST
95902: LIST
95903: LIST
95904: LIST
95905: PUSH
95906: LD_INT 101
95908: PUSH
95909: LD_INT 102
95911: PUSH
95912: LD_INT 103
95914: PUSH
95915: LD_INT 104
95917: PUSH
95918: LD_INT 105
95920: PUSH
95921: LD_INT 106
95923: PUSH
95924: LD_INT 107
95926: PUSH
95927: LD_INT 108
95929: PUSH
95930: LD_INT 109
95932: PUSH
95933: LD_INT 110
95935: PUSH
95936: LD_INT 111
95938: PUSH
95939: LD_INT 112
95941: PUSH
95942: LD_INT 113
95944: PUSH
95945: LD_INT 114
95947: PUSH
95948: EMPTY
95949: LIST
95950: LIST
95951: LIST
95952: LIST
95953: LIST
95954: LIST
95955: LIST
95956: LIST
95957: LIST
95958: LIST
95959: LIST
95960: LIST
95961: LIST
95962: LIST
95963: PUSH
95964: EMPTY
95965: LIST
95966: LIST
95967: ST_TO_ADDR
95968: GO 97135
95970: LD_INT 14
95972: DOUBLE
95973: EQUAL
95974: IFTRUE 95978
95976: GO 96190
95978: POP
// result := [ [ 1 , 2 , 3 , 4 , 5 , 6 , 7 , 8 , 9 , 10 , 11 , 12 , 13 , 14 , 15 , 16 , 17 , 18 , 19 , 20 , 21 , 22 , 23 , 24 , 25 , 26 , 27 , 28 , 29 , 30 , 31 , 32 , 33 , 34 , 36 ] , [ 101 , 102 , 103 , 104 , 105 , 106 , 107 , 108 , 109 , 110 , 111 , 112 , 113 , 114 ] ] ; 15 :
95979: LD_ADDR_VAR 0 1
95983: PUSH
95984: LD_INT 1
95986: PUSH
95987: LD_INT 2
95989: PUSH
95990: LD_INT 3
95992: PUSH
95993: LD_INT 4
95995: PUSH
95996: LD_INT 5
95998: PUSH
95999: LD_INT 6
96001: PUSH
96002: LD_INT 7
96004: PUSH
96005: LD_INT 8
96007: PUSH
96008: LD_INT 9
96010: PUSH
96011: LD_INT 10
96013: PUSH
96014: LD_INT 11
96016: PUSH
96017: LD_INT 12
96019: PUSH
96020: LD_INT 13
96022: PUSH
96023: LD_INT 14
96025: PUSH
96026: LD_INT 15
96028: PUSH
96029: LD_INT 16
96031: PUSH
96032: LD_INT 17
96034: PUSH
96035: LD_INT 18
96037: PUSH
96038: LD_INT 19
96040: PUSH
96041: LD_INT 20
96043: PUSH
96044: LD_INT 21
96046: PUSH
96047: LD_INT 22
96049: PUSH
96050: LD_INT 23
96052: PUSH
96053: LD_INT 24
96055: PUSH
96056: LD_INT 25
96058: PUSH
96059: LD_INT 26
96061: PUSH
96062: LD_INT 27
96064: PUSH
96065: LD_INT 28
96067: PUSH
96068: LD_INT 29
96070: PUSH
96071: LD_INT 30
96073: PUSH
96074: LD_INT 31
96076: PUSH
96077: LD_INT 32
96079: PUSH
96080: LD_INT 33
96082: PUSH
96083: LD_INT 34
96085: PUSH
96086: LD_INT 36
96088: PUSH
96089: EMPTY
96090: LIST
96091: LIST
96092: LIST
96093: LIST
96094: LIST
96095: LIST
96096: LIST
96097: LIST
96098: LIST
96099: LIST
96100: LIST
96101: LIST
96102: LIST
96103: LIST
96104: LIST
96105: LIST
96106: LIST
96107: LIST
96108: LIST
96109: LIST
96110: LIST
96111: LIST
96112: LIST
96113: LIST
96114: LIST
96115: LIST
96116: LIST
96117: LIST
96118: LIST
96119: LIST
96120: LIST
96121: LIST
96122: LIST
96123: LIST
96124: LIST
96125: PUSH
96126: LD_INT 101
96128: PUSH
96129: LD_INT 102
96131: PUSH
96132: LD_INT 103
96134: PUSH
96135: LD_INT 104
96137: PUSH
96138: LD_INT 105
96140: PUSH
96141: LD_INT 106
96143: PUSH
96144: LD_INT 107
96146: PUSH
96147: LD_INT 108
96149: PUSH
96150: LD_INT 109
96152: PUSH
96153: LD_INT 110
96155: PUSH
96156: LD_INT 111
96158: PUSH
96159: LD_INT 112
96161: PUSH
96162: LD_INT 113
96164: PUSH
96165: LD_INT 114
96167: PUSH
96168: EMPTY
96169: LIST
96170: LIST
96171: LIST
96172: LIST
96173: LIST
96174: LIST
96175: LIST
96176: LIST
96177: LIST
96178: LIST
96179: LIST
96180: LIST
96181: LIST
96182: LIST
96183: PUSH
96184: EMPTY
96185: LIST
96186: LIST
96187: ST_TO_ADDR
96188: GO 97135
96190: LD_INT 15
96192: DOUBLE
96193: EQUAL
96194: IFTRUE 96198
96196: GO 96410
96198: POP
// result := [ [ 1 , 2 , 3 , 4 , 5 , 6 , 7 , 8 , 9 , 10 , 11 , 12 , 13 , 14 , 15 , 16 , 17 , 18 , 19 , 20 , 21 , 22 , 23 , 24 , 25 , 26 , 27 , 28 , 29 , 30 , 31 , 32 , 33 , 34 , 36 ] , [ 101 , 102 , 103 , 104 , 105 , 106 , 107 , 108 , 109 , 110 , 111 , 112 , 113 , 114 ] ] ; 16 :
96199: LD_ADDR_VAR 0 1
96203: PUSH
96204: LD_INT 1
96206: PUSH
96207: LD_INT 2
96209: PUSH
96210: LD_INT 3
96212: PUSH
96213: LD_INT 4
96215: PUSH
96216: LD_INT 5
96218: PUSH
96219: LD_INT 6
96221: PUSH
96222: LD_INT 7
96224: PUSH
96225: LD_INT 8
96227: PUSH
96228: LD_INT 9
96230: PUSH
96231: LD_INT 10
96233: PUSH
96234: LD_INT 11
96236: PUSH
96237: LD_INT 12
96239: PUSH
96240: LD_INT 13
96242: PUSH
96243: LD_INT 14
96245: PUSH
96246: LD_INT 15
96248: PUSH
96249: LD_INT 16
96251: PUSH
96252: LD_INT 17
96254: PUSH
96255: LD_INT 18
96257: PUSH
96258: LD_INT 19
96260: PUSH
96261: LD_INT 20
96263: PUSH
96264: LD_INT 21
96266: PUSH
96267: LD_INT 22
96269: PUSH
96270: LD_INT 23
96272: PUSH
96273: LD_INT 24
96275: PUSH
96276: LD_INT 25
96278: PUSH
96279: LD_INT 26
96281: PUSH
96282: LD_INT 27
96284: PUSH
96285: LD_INT 28
96287: PUSH
96288: LD_INT 29
96290: PUSH
96291: LD_INT 30
96293: PUSH
96294: LD_INT 31
96296: PUSH
96297: LD_INT 32
96299: PUSH
96300: LD_INT 33
96302: PUSH
96303: LD_INT 34
96305: PUSH
96306: LD_INT 36
96308: PUSH
96309: EMPTY
96310: LIST
96311: LIST
96312: LIST
96313: LIST
96314: LIST
96315: LIST
96316: LIST
96317: LIST
96318: LIST
96319: LIST
96320: LIST
96321: LIST
96322: LIST
96323: LIST
96324: LIST
96325: LIST
96326: LIST
96327: LIST
96328: LIST
96329: LIST
96330: LIST
96331: LIST
96332: LIST
96333: LIST
96334: LIST
96335: LIST
96336: LIST
96337: LIST
96338: LIST
96339: LIST
96340: LIST
96341: LIST
96342: LIST
96343: LIST
96344: LIST
96345: PUSH
96346: LD_INT 101
96348: PUSH
96349: LD_INT 102
96351: PUSH
96352: LD_INT 103
96354: PUSH
96355: LD_INT 104
96357: PUSH
96358: LD_INT 105
96360: PUSH
96361: LD_INT 106
96363: PUSH
96364: LD_INT 107
96366: PUSH
96367: LD_INT 108
96369: PUSH
96370: LD_INT 109
96372: PUSH
96373: LD_INT 110
96375: PUSH
96376: LD_INT 111
96378: PUSH
96379: LD_INT 112
96381: PUSH
96382: LD_INT 113
96384: PUSH
96385: LD_INT 114
96387: PUSH
96388: EMPTY
96389: LIST
96390: LIST
96391: LIST
96392: LIST
96393: LIST
96394: LIST
96395: LIST
96396: LIST
96397: LIST
96398: LIST
96399: LIST
96400: LIST
96401: LIST
96402: LIST
96403: PUSH
96404: EMPTY
96405: LIST
96406: LIST
96407: ST_TO_ADDR
96408: GO 97135
96410: LD_INT 16
96412: DOUBLE
96413: EQUAL
96414: IFTRUE 96418
96416: GO 96542
96418: POP
// result := [ [ 2 , 4 , 5 , 7 , 11 , 12 , 15 , 16 , 20 , 21 , 22 , 23 , 25 , 26 , 30 , 31 , 32 , 33 , 34 ] , [ 101 , 102 , 103 , 106 , 108 , 112 , 113 , 114 ] ] ; 17 :
96419: LD_ADDR_VAR 0 1
96423: PUSH
96424: LD_INT 2
96426: PUSH
96427: LD_INT 4
96429: PUSH
96430: LD_INT 5
96432: PUSH
96433: LD_INT 7
96435: PUSH
96436: LD_INT 11
96438: PUSH
96439: LD_INT 12
96441: PUSH
96442: LD_INT 15
96444: PUSH
96445: LD_INT 16
96447: PUSH
96448: LD_INT 20
96450: PUSH
96451: LD_INT 21
96453: PUSH
96454: LD_INT 22
96456: PUSH
96457: LD_INT 23
96459: PUSH
96460: LD_INT 25
96462: PUSH
96463: LD_INT 26
96465: PUSH
96466: LD_INT 30
96468: PUSH
96469: LD_INT 31
96471: PUSH
96472: LD_INT 32
96474: PUSH
96475: LD_INT 33
96477: PUSH
96478: LD_INT 34
96480: PUSH
96481: EMPTY
96482: LIST
96483: LIST
96484: LIST
96485: LIST
96486: LIST
96487: LIST
96488: LIST
96489: LIST
96490: LIST
96491: LIST
96492: LIST
96493: LIST
96494: LIST
96495: LIST
96496: LIST
96497: LIST
96498: LIST
96499: LIST
96500: LIST
96501: PUSH
96502: LD_INT 101
96504: PUSH
96505: LD_INT 102
96507: PUSH
96508: LD_INT 103
96510: PUSH
96511: LD_INT 106
96513: PUSH
96514: LD_INT 108
96516: PUSH
96517: LD_INT 112
96519: PUSH
96520: LD_INT 113
96522: PUSH
96523: LD_INT 114
96525: PUSH
96526: EMPTY
96527: LIST
96528: LIST
96529: LIST
96530: LIST
96531: LIST
96532: LIST
96533: LIST
96534: LIST
96535: PUSH
96536: EMPTY
96537: LIST
96538: LIST
96539: ST_TO_ADDR
96540: GO 97135
96542: LD_INT 17
96544: DOUBLE
96545: EQUAL
96546: IFTRUE 96550
96548: GO 96762
96550: POP
// result := [ [ 1 , 2 , 3 , 4 , 5 , 6 , 7 , 8 , 9 , 10 , 11 , 12 , 13 , 14 , 15 , 16 , 17 , 18 , 19 , 20 , 21 , 22 , 23 , 24 , 25 , 26 , 27 , 28 , 29 , 30 , 31 , 32 , 33 , 34 , 36 ] , [ 101 , 102 , 103 , 104 , 105 , 106 , 107 , 108 , 109 , 110 , 111 , 112 , 113 , 114 ] ] ; 18 :
96551: LD_ADDR_VAR 0 1
96555: PUSH
96556: LD_INT 1
96558: PUSH
96559: LD_INT 2
96561: PUSH
96562: LD_INT 3
96564: PUSH
96565: LD_INT 4
96567: PUSH
96568: LD_INT 5
96570: PUSH
96571: LD_INT 6
96573: PUSH
96574: LD_INT 7
96576: PUSH
96577: LD_INT 8
96579: PUSH
96580: LD_INT 9
96582: PUSH
96583: LD_INT 10
96585: PUSH
96586: LD_INT 11
96588: PUSH
96589: LD_INT 12
96591: PUSH
96592: LD_INT 13
96594: PUSH
96595: LD_INT 14
96597: PUSH
96598: LD_INT 15
96600: PUSH
96601: LD_INT 16
96603: PUSH
96604: LD_INT 17
96606: PUSH
96607: LD_INT 18
96609: PUSH
96610: LD_INT 19
96612: PUSH
96613: LD_INT 20
96615: PUSH
96616: LD_INT 21
96618: PUSH
96619: LD_INT 22
96621: PUSH
96622: LD_INT 23
96624: PUSH
96625: LD_INT 24
96627: PUSH
96628: LD_INT 25
96630: PUSH
96631: LD_INT 26
96633: PUSH
96634: LD_INT 27
96636: PUSH
96637: LD_INT 28
96639: PUSH
96640: LD_INT 29
96642: PUSH
96643: LD_INT 30
96645: PUSH
96646: LD_INT 31
96648: PUSH
96649: LD_INT 32
96651: PUSH
96652: LD_INT 33
96654: PUSH
96655: LD_INT 34
96657: PUSH
96658: LD_INT 36
96660: PUSH
96661: EMPTY
96662: LIST
96663: LIST
96664: LIST
96665: LIST
96666: LIST
96667: LIST
96668: LIST
96669: LIST
96670: LIST
96671: LIST
96672: LIST
96673: LIST
96674: LIST
96675: LIST
96676: LIST
96677: LIST
96678: LIST
96679: LIST
96680: LIST
96681: LIST
96682: LIST
96683: LIST
96684: LIST
96685: LIST
96686: LIST
96687: LIST
96688: LIST
96689: LIST
96690: LIST
96691: LIST
96692: LIST
96693: LIST
96694: LIST
96695: LIST
96696: LIST
96697: PUSH
96698: LD_INT 101
96700: PUSH
96701: LD_INT 102
96703: PUSH
96704: LD_INT 103
96706: PUSH
96707: LD_INT 104
96709: PUSH
96710: LD_INT 105
96712: PUSH
96713: LD_INT 106
96715: PUSH
96716: LD_INT 107
96718: PUSH
96719: LD_INT 108
96721: PUSH
96722: LD_INT 109
96724: PUSH
96725: LD_INT 110
96727: PUSH
96728: LD_INT 111
96730: PUSH
96731: LD_INT 112
96733: PUSH
96734: LD_INT 113
96736: PUSH
96737: LD_INT 114
96739: PUSH
96740: EMPTY
96741: LIST
96742: LIST
96743: LIST
96744: LIST
96745: LIST
96746: LIST
96747: LIST
96748: LIST
96749: LIST
96750: LIST
96751: LIST
96752: LIST
96753: LIST
96754: LIST
96755: PUSH
96756: EMPTY
96757: LIST
96758: LIST
96759: ST_TO_ADDR
96760: GO 97135
96762: LD_INT 18
96764: DOUBLE
96765: EQUAL
96766: IFTRUE 96770
96768: GO 96906
96770: POP
// result := [ [ 2 , 4 , 5 , 7 , 11 , 12 , 15 , 16 , 20 , 21 , 22 , 23 , 25 , 26 , 30 , 31 , 32 , 33 , 34 , 35 , 36 ] , [ 101 , 102 , 103 , 106 , 108 , 112 , 113 , 114 , 115 ] ] ; 19 :
96771: LD_ADDR_VAR 0 1
96775: PUSH
96776: LD_INT 2
96778: PUSH
96779: LD_INT 4
96781: PUSH
96782: LD_INT 5
96784: PUSH
96785: LD_INT 7
96787: PUSH
96788: LD_INT 11
96790: PUSH
96791: LD_INT 12
96793: PUSH
96794: LD_INT 15
96796: PUSH
96797: LD_INT 16
96799: PUSH
96800: LD_INT 20
96802: PUSH
96803: LD_INT 21
96805: PUSH
96806: LD_INT 22
96808: PUSH
96809: LD_INT 23
96811: PUSH
96812: LD_INT 25
96814: PUSH
96815: LD_INT 26
96817: PUSH
96818: LD_INT 30
96820: PUSH
96821: LD_INT 31
96823: PUSH
96824: LD_INT 32
96826: PUSH
96827: LD_INT 33
96829: PUSH
96830: LD_INT 34
96832: PUSH
96833: LD_INT 35
96835: PUSH
96836: LD_INT 36
96838: PUSH
96839: EMPTY
96840: LIST
96841: LIST
96842: LIST
96843: LIST
96844: LIST
96845: LIST
96846: LIST
96847: LIST
96848: LIST
96849: LIST
96850: LIST
96851: LIST
96852: LIST
96853: LIST
96854: LIST
96855: LIST
96856: LIST
96857: LIST
96858: LIST
96859: LIST
96860: LIST
96861: PUSH
96862: LD_INT 101
96864: PUSH
96865: LD_INT 102
96867: PUSH
96868: LD_INT 103
96870: PUSH
96871: LD_INT 106
96873: PUSH
96874: LD_INT 108
96876: PUSH
96877: LD_INT 112
96879: PUSH
96880: LD_INT 113
96882: PUSH
96883: LD_INT 114
96885: PUSH
96886: LD_INT 115
96888: PUSH
96889: EMPTY
96890: LIST
96891: LIST
96892: LIST
96893: LIST
96894: LIST
96895: LIST
96896: LIST
96897: LIST
96898: LIST
96899: PUSH
96900: EMPTY
96901: LIST
96902: LIST
96903: ST_TO_ADDR
96904: GO 97135
96906: LD_INT 19
96908: DOUBLE
96909: EQUAL
96910: IFTRUE 96914
96912: GO 97134
96914: POP
// result := [ [ 1 , 2 , 3 , 4 , 5 , 6 , 7 , 8 , 9 , 10 , 11 , 12 , 13 , 14 , 15 , 16 , 17 , 18 , 19 , 20 , 21 , 22 , 23 , 24 , 25 , 26 , 27 , 28 , 29 , 30 , 31 , 32 , 33 , 34 , 35 , 36 ] , [ 101 , 102 , 103 , 104 , 105 , 106 , 107 , 108 , 109 , 110 , 111 , 112 , 113 , 114 , 115 ] ] ; end ;
96915: LD_ADDR_VAR 0 1
96919: PUSH
96920: LD_INT 1
96922: PUSH
96923: LD_INT 2
96925: PUSH
96926: LD_INT 3
96928: PUSH
96929: LD_INT 4
96931: PUSH
96932: LD_INT 5
96934: PUSH
96935: LD_INT 6
96937: PUSH
96938: LD_INT 7
96940: PUSH
96941: LD_INT 8
96943: PUSH
96944: LD_INT 9
96946: PUSH
96947: LD_INT 10
96949: PUSH
96950: LD_INT 11
96952: PUSH
96953: LD_INT 12
96955: PUSH
96956: LD_INT 13
96958: PUSH
96959: LD_INT 14
96961: PUSH
96962: LD_INT 15
96964: PUSH
96965: LD_INT 16
96967: PUSH
96968: LD_INT 17
96970: PUSH
96971: LD_INT 18
96973: PUSH
96974: LD_INT 19
96976: PUSH
96977: LD_INT 20
96979: PUSH
96980: LD_INT 21
96982: PUSH
96983: LD_INT 22
96985: PUSH
96986: LD_INT 23
96988: PUSH
96989: LD_INT 24
96991: PUSH
96992: LD_INT 25
96994: PUSH
96995: LD_INT 26
96997: PUSH
96998: LD_INT 27
97000: PUSH
97001: LD_INT 28
97003: PUSH
97004: LD_INT 29
97006: PUSH
97007: LD_INT 30
97009: PUSH
97010: LD_INT 31
97012: PUSH
97013: LD_INT 32
97015: PUSH
97016: LD_INT 33
97018: PUSH
97019: LD_INT 34
97021: PUSH
97022: LD_INT 35
97024: PUSH
97025: LD_INT 36
97027: PUSH
97028: EMPTY
97029: LIST
97030: LIST
97031: LIST
97032: LIST
97033: LIST
97034: LIST
97035: LIST
97036: LIST
97037: LIST
97038: LIST
97039: LIST
97040: LIST
97041: LIST
97042: LIST
97043: LIST
97044: LIST
97045: LIST
97046: LIST
97047: LIST
97048: LIST
97049: LIST
97050: LIST
97051: LIST
97052: LIST
97053: LIST
97054: LIST
97055: LIST
97056: LIST
97057: LIST
97058: LIST
97059: LIST
97060: LIST
97061: LIST
97062: LIST
97063: LIST
97064: LIST
97065: PUSH
97066: LD_INT 101
97068: PUSH
97069: LD_INT 102
97071: PUSH
97072: LD_INT 103
97074: PUSH
97075: LD_INT 104
97077: PUSH
97078: LD_INT 105
97080: PUSH
97081: LD_INT 106
97083: PUSH
97084: LD_INT 107
97086: PUSH
97087: LD_INT 108
97089: PUSH
97090: LD_INT 109
97092: PUSH
97093: LD_INT 110
97095: PUSH
97096: LD_INT 111
97098: PUSH
97099: LD_INT 112
97101: PUSH
97102: LD_INT 113
97104: PUSH
97105: LD_INT 114
97107: PUSH
97108: LD_INT 115
97110: PUSH
97111: EMPTY
97112: LIST
97113: LIST
97114: LIST
97115: LIST
97116: LIST
97117: LIST
97118: LIST
97119: LIST
97120: LIST
97121: LIST
97122: LIST
97123: LIST
97124: LIST
97125: LIST
97126: LIST
97127: PUSH
97128: EMPTY
97129: LIST
97130: LIST
97131: ST_TO_ADDR
97132: GO 97135
97134: POP
// end else
97135: GO 97172
// if campaign_id = 5 then
97137: LD_OWVAR 69
97141: PUSH
97142: LD_INT 5
97144: EQUAL
97145: IFFALSE 97172
// begin result := [ [ 1 , 2 ] , [ 100 ] ] ;
97147: LD_ADDR_VAR 0 1
97151: PUSH
97152: LD_INT 1
97154: PUSH
97155: LD_INT 2
97157: PUSH
97158: EMPTY
97159: LIST
97160: LIST
97161: PUSH
97162: LD_INT 100
97164: PUSH
97165: EMPTY
97166: LIST
97167: PUSH
97168: EMPTY
97169: LIST
97170: LIST
97171: ST_TO_ADDR
// end ; if result then
97172: LD_VAR 0 1
97176: IFFALSE 97465
// begin normal :=  ;
97178: LD_ADDR_VAR 0 3
97182: PUSH
97183: LD_STRING 
97185: ST_TO_ADDR
// hardcore :=  ;
97186: LD_ADDR_VAR 0 4
97190: PUSH
97191: LD_STRING 
97193: ST_TO_ADDR
// for i = 1 to normalCounter do
97194: LD_ADDR_VAR 0 5
97198: PUSH
97199: DOUBLE
97200: LD_INT 1
97202: DEC
97203: ST_TO_ADDR
97204: LD_EXP 123
97208: PUSH
97209: FOR_TO
97210: IFFALSE 97311
// begin tmp := 0 ;
97212: LD_ADDR_VAR 0 2
97216: PUSH
97217: LD_STRING 0
97219: ST_TO_ADDR
// if result [ 1 ] then
97220: LD_VAR 0 1
97224: PUSH
97225: LD_INT 1
97227: ARRAY
97228: IFFALSE 97293
// if result [ 1 ] [ 1 ] = i then
97230: LD_VAR 0 1
97234: PUSH
97235: LD_INT 1
97237: ARRAY
97238: PUSH
97239: LD_INT 1
97241: ARRAY
97242: PUSH
97243: LD_VAR 0 5
97247: EQUAL
97248: IFFALSE 97293
// begin result := Replace ( result , 1 , Delete ( result [ 1 ] , 1 ) ) ;
97250: LD_ADDR_VAR 0 1
97254: PUSH
97255: LD_VAR 0 1
97259: PPUSH
97260: LD_INT 1
97262: PPUSH
97263: LD_VAR 0 1
97267: PUSH
97268: LD_INT 1
97270: ARRAY
97271: PPUSH
97272: LD_INT 1
97274: PPUSH
97275: CALL_OW 3
97279: PPUSH
97280: CALL_OW 1
97284: ST_TO_ADDR
// tmp := 1 ;
97285: LD_ADDR_VAR 0 2
97289: PUSH
97290: LD_STRING 1
97292: ST_TO_ADDR
// end ; normal := normal & tmp ;
97293: LD_ADDR_VAR 0 3
97297: PUSH
97298: LD_VAR 0 3
97302: PUSH
97303: LD_VAR 0 2
97307: STR
97308: ST_TO_ADDR
// end ;
97309: GO 97209
97311: POP
97312: POP
// for i = 1 to hardcoreCounter do
97313: LD_ADDR_VAR 0 5
97317: PUSH
97318: DOUBLE
97319: LD_INT 1
97321: DEC
97322: ST_TO_ADDR
97323: LD_EXP 124
97327: PUSH
97328: FOR_TO
97329: IFFALSE 97434
// begin tmp := 0 ;
97331: LD_ADDR_VAR 0 2
97335: PUSH
97336: LD_STRING 0
97338: ST_TO_ADDR
// if result [ 2 ] then
97339: LD_VAR 0 1
97343: PUSH
97344: LD_INT 2
97346: ARRAY
97347: IFFALSE 97416
// if result [ 2 ] [ 1 ] = 100 + i then
97349: LD_VAR 0 1
97353: PUSH
97354: LD_INT 2
97356: ARRAY
97357: PUSH
97358: LD_INT 1
97360: ARRAY
97361: PUSH
97362: LD_INT 100
97364: PUSH
97365: LD_VAR 0 5
97369: PLUS
97370: EQUAL
97371: IFFALSE 97416
// begin result := Replace ( result , 2 , Delete ( result [ 2 ] , 1 ) ) ;
97373: LD_ADDR_VAR 0 1
97377: PUSH
97378: LD_VAR 0 1
97382: PPUSH
97383: LD_INT 2
97385: PPUSH
97386: LD_VAR 0 1
97390: PUSH
97391: LD_INT 2
97393: ARRAY
97394: PPUSH
97395: LD_INT 1
97397: PPUSH
97398: CALL_OW 3
97402: PPUSH
97403: CALL_OW 1
97407: ST_TO_ADDR
// tmp := 1 ;
97408: LD_ADDR_VAR 0 2
97412: PUSH
97413: LD_STRING 1
97415: ST_TO_ADDR
// end ; hardcore := hardcore & tmp ;
97416: LD_ADDR_VAR 0 4
97420: PUSH
97421: LD_VAR 0 4
97425: PUSH
97426: LD_VAR 0 2
97430: STR
97431: ST_TO_ADDR
// end ;
97432: GO 97328
97434: POP
97435: POP
// ToLua ( getStreamItemsFromMission(" & normal & "," & hardcore & ") ) ;
97436: LD_STRING getStreamItemsFromMission("
97438: PUSH
97439: LD_VAR 0 3
97443: STR
97444: PUSH
97445: LD_STRING ","
97447: STR
97448: PUSH
97449: LD_VAR 0 4
97453: STR
97454: PUSH
97455: LD_STRING ")
97457: STR
97458: PPUSH
97459: CALL_OW 559
// end else
97463: GO 97472
// ToLua ( getStreamItemsFromMission("","") ) ;
97465: LD_STRING getStreamItemsFromMission("","")
97467: PPUSH
97468: CALL_OW 559
// end ;
97472: LD_VAR 0 1
97476: RET
// on CustomCommand ( p1 , p2 , p3 , p4 , p5 , p6 ) do begin if p2 = 100 then
97477: LD_VAR 0 2
97481: PUSH
97482: LD_INT 100
97484: EQUAL
97485: IFFALSE 98434
// begin if not StreamModeActive then
97487: LD_EXP 122
97491: NOT
97492: IFFALSE 97502
// StreamModeActive := true ;
97494: LD_ADDR_EXP 122
97498: PUSH
97499: LD_INT 1
97501: ST_TO_ADDR
// if p3 = 0 then
97502: LD_VAR 0 3
97506: PUSH
97507: LD_INT 0
97509: EQUAL
97510: IFFALSE 97516
// InitStreamMode ;
97512: CALL 93737 0 0
// if p3 = 1 then
97516: LD_VAR 0 3
97520: PUSH
97521: LD_INT 1
97523: EQUAL
97524: IFFALSE 97534
// sRocket := true ;
97526: LD_ADDR_EXP 127
97530: PUSH
97531: LD_INT 1
97533: ST_TO_ADDR
// if p3 = 2 then
97534: LD_VAR 0 3
97538: PUSH
97539: LD_INT 2
97541: EQUAL
97542: IFFALSE 97552
// sSpeed := true ;
97544: LD_ADDR_EXP 126
97548: PUSH
97549: LD_INT 1
97551: ST_TO_ADDR
// if p3 = 3 then
97552: LD_VAR 0 3
97556: PUSH
97557: LD_INT 3
97559: EQUAL
97560: IFFALSE 97570
// sEngine := true ;
97562: LD_ADDR_EXP 128
97566: PUSH
97567: LD_INT 1
97569: ST_TO_ADDR
// if p3 = 4 then
97570: LD_VAR 0 3
97574: PUSH
97575: LD_INT 4
97577: EQUAL
97578: IFFALSE 97588
// sSpec := true ;
97580: LD_ADDR_EXP 125
97584: PUSH
97585: LD_INT 1
97587: ST_TO_ADDR
// if p3 = 5 then
97588: LD_VAR 0 3
97592: PUSH
97593: LD_INT 5
97595: EQUAL
97596: IFFALSE 97606
// sLevel := true ;
97598: LD_ADDR_EXP 129
97602: PUSH
97603: LD_INT 1
97605: ST_TO_ADDR
// if p3 = 6 then
97606: LD_VAR 0 3
97610: PUSH
97611: LD_INT 6
97613: EQUAL
97614: IFFALSE 97624
// sArmoury := true ;
97616: LD_ADDR_EXP 130
97620: PUSH
97621: LD_INT 1
97623: ST_TO_ADDR
// if p3 = 7 then
97624: LD_VAR 0 3
97628: PUSH
97629: LD_INT 7
97631: EQUAL
97632: IFFALSE 97642
// sRadar := true ;
97634: LD_ADDR_EXP 131
97638: PUSH
97639: LD_INT 1
97641: ST_TO_ADDR
// if p3 = 8 then
97642: LD_VAR 0 3
97646: PUSH
97647: LD_INT 8
97649: EQUAL
97650: IFFALSE 97660
// sBunker := true ;
97652: LD_ADDR_EXP 132
97656: PUSH
97657: LD_INT 1
97659: ST_TO_ADDR
// if p3 = 9 then
97660: LD_VAR 0 3
97664: PUSH
97665: LD_INT 9
97667: EQUAL
97668: IFFALSE 97678
// sHack := true ;
97670: LD_ADDR_EXP 133
97674: PUSH
97675: LD_INT 1
97677: ST_TO_ADDR
// if p3 = 10 then
97678: LD_VAR 0 3
97682: PUSH
97683: LD_INT 10
97685: EQUAL
97686: IFFALSE 97696
// sFire := true ;
97688: LD_ADDR_EXP 134
97692: PUSH
97693: LD_INT 1
97695: ST_TO_ADDR
// if p3 = 11 then
97696: LD_VAR 0 3
97700: PUSH
97701: LD_INT 11
97703: EQUAL
97704: IFFALSE 97714
// sRefresh := true ;
97706: LD_ADDR_EXP 135
97710: PUSH
97711: LD_INT 1
97713: ST_TO_ADDR
// if p3 = 12 then
97714: LD_VAR 0 3
97718: PUSH
97719: LD_INT 12
97721: EQUAL
97722: IFFALSE 97732
// sExp := true ;
97724: LD_ADDR_EXP 136
97728: PUSH
97729: LD_INT 1
97731: ST_TO_ADDR
// if p3 = 13 then
97732: LD_VAR 0 3
97736: PUSH
97737: LD_INT 13
97739: EQUAL
97740: IFFALSE 97750
// sDepot := true ;
97742: LD_ADDR_EXP 137
97746: PUSH
97747: LD_INT 1
97749: ST_TO_ADDR
// if p3 = 14 then
97750: LD_VAR 0 3
97754: PUSH
97755: LD_INT 14
97757: EQUAL
97758: IFFALSE 97768
// sFlag := true ;
97760: LD_ADDR_EXP 138
97764: PUSH
97765: LD_INT 1
97767: ST_TO_ADDR
// if p3 = 15 then
97768: LD_VAR 0 3
97772: PUSH
97773: LD_INT 15
97775: EQUAL
97776: IFFALSE 97786
// sKamikadze := true ;
97778: LD_ADDR_EXP 146
97782: PUSH
97783: LD_INT 1
97785: ST_TO_ADDR
// if p3 = 16 then
97786: LD_VAR 0 3
97790: PUSH
97791: LD_INT 16
97793: EQUAL
97794: IFFALSE 97804
// sTroll := true ;
97796: LD_ADDR_EXP 147
97800: PUSH
97801: LD_INT 1
97803: ST_TO_ADDR
// if p3 = 17 then
97804: LD_VAR 0 3
97808: PUSH
97809: LD_INT 17
97811: EQUAL
97812: IFFALSE 97822
// sSlow := true ;
97814: LD_ADDR_EXP 148
97818: PUSH
97819: LD_INT 1
97821: ST_TO_ADDR
// if p3 = 18 then
97822: LD_VAR 0 3
97826: PUSH
97827: LD_INT 18
97829: EQUAL
97830: IFFALSE 97840
// sLack := true ;
97832: LD_ADDR_EXP 149
97836: PUSH
97837: LD_INT 1
97839: ST_TO_ADDR
// if p3 = 19 then
97840: LD_VAR 0 3
97844: PUSH
97845: LD_INT 19
97847: EQUAL
97848: IFFALSE 97858
// sTank := true ;
97850: LD_ADDR_EXP 151
97854: PUSH
97855: LD_INT 1
97857: ST_TO_ADDR
// if p3 = 20 then
97858: LD_VAR 0 3
97862: PUSH
97863: LD_INT 20
97865: EQUAL
97866: IFFALSE 97876
// sRemote := true ;
97868: LD_ADDR_EXP 152
97872: PUSH
97873: LD_INT 1
97875: ST_TO_ADDR
// if p3 = 21 then
97876: LD_VAR 0 3
97880: PUSH
97881: LD_INT 21
97883: EQUAL
97884: IFFALSE 97894
// sPowell := true ;
97886: LD_ADDR_EXP 153
97890: PUSH
97891: LD_INT 1
97893: ST_TO_ADDR
// if p3 = 22 then
97894: LD_VAR 0 3
97898: PUSH
97899: LD_INT 22
97901: EQUAL
97902: IFFALSE 97912
// sTeleport := true ;
97904: LD_ADDR_EXP 156
97908: PUSH
97909: LD_INT 1
97911: ST_TO_ADDR
// if p3 = 23 then
97912: LD_VAR 0 3
97916: PUSH
97917: LD_INT 23
97919: EQUAL
97920: IFFALSE 97930
// sOilTower := true ;
97922: LD_ADDR_EXP 158
97926: PUSH
97927: LD_INT 1
97929: ST_TO_ADDR
// if p3 = 24 then
97930: LD_VAR 0 3
97934: PUSH
97935: LD_INT 24
97937: EQUAL
97938: IFFALSE 97948
// sShovel := true ;
97940: LD_ADDR_EXP 159
97944: PUSH
97945: LD_INT 1
97947: ST_TO_ADDR
// if p3 = 25 then
97948: LD_VAR 0 3
97952: PUSH
97953: LD_INT 25
97955: EQUAL
97956: IFFALSE 97966
// sSheik := true ;
97958: LD_ADDR_EXP 160
97962: PUSH
97963: LD_INT 1
97965: ST_TO_ADDR
// if p3 = 26 then
97966: LD_VAR 0 3
97970: PUSH
97971: LD_INT 26
97973: EQUAL
97974: IFFALSE 97984
// sEarthquake := true ;
97976: LD_ADDR_EXP 162
97980: PUSH
97981: LD_INT 1
97983: ST_TO_ADDR
// if p3 = 27 then
97984: LD_VAR 0 3
97988: PUSH
97989: LD_INT 27
97991: EQUAL
97992: IFFALSE 98002
// sAI := true ;
97994: LD_ADDR_EXP 163
97998: PUSH
97999: LD_INT 1
98001: ST_TO_ADDR
// if p3 = 28 then
98002: LD_VAR 0 3
98006: PUSH
98007: LD_INT 28
98009: EQUAL
98010: IFFALSE 98020
// sCargo := true ;
98012: LD_ADDR_EXP 166
98016: PUSH
98017: LD_INT 1
98019: ST_TO_ADDR
// if p3 = 29 then
98020: LD_VAR 0 3
98024: PUSH
98025: LD_INT 29
98027: EQUAL
98028: IFFALSE 98038
// sDLaser := true ;
98030: LD_ADDR_EXP 167
98034: PUSH
98035: LD_INT 1
98037: ST_TO_ADDR
// if p3 = 30 then
98038: LD_VAR 0 3
98042: PUSH
98043: LD_INT 30
98045: EQUAL
98046: IFFALSE 98056
// sExchange := true ;
98048: LD_ADDR_EXP 168
98052: PUSH
98053: LD_INT 1
98055: ST_TO_ADDR
// if p3 = 31 then
98056: LD_VAR 0 3
98060: PUSH
98061: LD_INT 31
98063: EQUAL
98064: IFFALSE 98074
// sFac := true ;
98066: LD_ADDR_EXP 169
98070: PUSH
98071: LD_INT 1
98073: ST_TO_ADDR
// if p3 = 32 then
98074: LD_VAR 0 3
98078: PUSH
98079: LD_INT 32
98081: EQUAL
98082: IFFALSE 98092
// sPower := true ;
98084: LD_ADDR_EXP 170
98088: PUSH
98089: LD_INT 1
98091: ST_TO_ADDR
// if p3 = 33 then
98092: LD_VAR 0 3
98096: PUSH
98097: LD_INT 33
98099: EQUAL
98100: IFFALSE 98110
// sRandom := true ;
98102: LD_ADDR_EXP 171
98106: PUSH
98107: LD_INT 1
98109: ST_TO_ADDR
// if p3 = 34 then
98110: LD_VAR 0 3
98114: PUSH
98115: LD_INT 34
98117: EQUAL
98118: IFFALSE 98128
// sShield := true ;
98120: LD_ADDR_EXP 172
98124: PUSH
98125: LD_INT 1
98127: ST_TO_ADDR
// if p3 = 35 then
98128: LD_VAR 0 3
98132: PUSH
98133: LD_INT 35
98135: EQUAL
98136: IFFALSE 98146
// sTime := true ;
98138: LD_ADDR_EXP 173
98142: PUSH
98143: LD_INT 1
98145: ST_TO_ADDR
// if p3 = 36 then
98146: LD_VAR 0 3
98150: PUSH
98151: LD_INT 36
98153: EQUAL
98154: IFFALSE 98164
// sTools := true ;
98156: LD_ADDR_EXP 174
98160: PUSH
98161: LD_INT 1
98163: ST_TO_ADDR
// if p3 = 101 then
98164: LD_VAR 0 3
98168: PUSH
98169: LD_INT 101
98171: EQUAL
98172: IFFALSE 98182
// sSold := true ;
98174: LD_ADDR_EXP 139
98178: PUSH
98179: LD_INT 1
98181: ST_TO_ADDR
// if p3 = 102 then
98182: LD_VAR 0 3
98186: PUSH
98187: LD_INT 102
98189: EQUAL
98190: IFFALSE 98200
// sDiff := true ;
98192: LD_ADDR_EXP 140
98196: PUSH
98197: LD_INT 1
98199: ST_TO_ADDR
// if p3 = 103 then
98200: LD_VAR 0 3
98204: PUSH
98205: LD_INT 103
98207: EQUAL
98208: IFFALSE 98218
// sFog := true ;
98210: LD_ADDR_EXP 143
98214: PUSH
98215: LD_INT 1
98217: ST_TO_ADDR
// if p3 = 104 then
98218: LD_VAR 0 3
98222: PUSH
98223: LD_INT 104
98225: EQUAL
98226: IFFALSE 98236
// sReset := true ;
98228: LD_ADDR_EXP 144
98232: PUSH
98233: LD_INT 1
98235: ST_TO_ADDR
// if p3 = 105 then
98236: LD_VAR 0 3
98240: PUSH
98241: LD_INT 105
98243: EQUAL
98244: IFFALSE 98254
// sSun := true ;
98246: LD_ADDR_EXP 145
98250: PUSH
98251: LD_INT 1
98253: ST_TO_ADDR
// if p3 = 106 then
98254: LD_VAR 0 3
98258: PUSH
98259: LD_INT 106
98261: EQUAL
98262: IFFALSE 98272
// sTiger := true ;
98264: LD_ADDR_EXP 141
98268: PUSH
98269: LD_INT 1
98271: ST_TO_ADDR
// if p3 = 107 then
98272: LD_VAR 0 3
98276: PUSH
98277: LD_INT 107
98279: EQUAL
98280: IFFALSE 98290
// sBomb := true ;
98282: LD_ADDR_EXP 142
98286: PUSH
98287: LD_INT 1
98289: ST_TO_ADDR
// if p3 = 108 then
98290: LD_VAR 0 3
98294: PUSH
98295: LD_INT 108
98297: EQUAL
98298: IFFALSE 98308
// sWound := true ;
98300: LD_ADDR_EXP 150
98304: PUSH
98305: LD_INT 1
98307: ST_TO_ADDR
// if p3 = 109 then
98308: LD_VAR 0 3
98312: PUSH
98313: LD_INT 109
98315: EQUAL
98316: IFFALSE 98326
// sBetray := true ;
98318: LD_ADDR_EXP 154
98322: PUSH
98323: LD_INT 1
98325: ST_TO_ADDR
// if p3 = 110 then
98326: LD_VAR 0 3
98330: PUSH
98331: LD_INT 110
98333: EQUAL
98334: IFFALSE 98344
// sContamin := true ;
98336: LD_ADDR_EXP 155
98340: PUSH
98341: LD_INT 1
98343: ST_TO_ADDR
// if p3 = 111 then
98344: LD_VAR 0 3
98348: PUSH
98349: LD_INT 111
98351: EQUAL
98352: IFFALSE 98362
// sOil := true ;
98354: LD_ADDR_EXP 157
98358: PUSH
98359: LD_INT 1
98361: ST_TO_ADDR
// if p3 = 112 then
98362: LD_VAR 0 3
98366: PUSH
98367: LD_INT 112
98369: EQUAL
98370: IFFALSE 98380
// sStu := true ;
98372: LD_ADDR_EXP 161
98376: PUSH
98377: LD_INT 1
98379: ST_TO_ADDR
// if p3 = 113 then
98380: LD_VAR 0 3
98384: PUSH
98385: LD_INT 113
98387: EQUAL
98388: IFFALSE 98398
// sBazooka := true ;
98390: LD_ADDR_EXP 164
98394: PUSH
98395: LD_INT 1
98397: ST_TO_ADDR
// if p3 = 114 then
98398: LD_VAR 0 3
98402: PUSH
98403: LD_INT 114
98405: EQUAL
98406: IFFALSE 98416
// sMortar := true ;
98408: LD_ADDR_EXP 165
98412: PUSH
98413: LD_INT 1
98415: ST_TO_ADDR
// if p3 = 115 then
98416: LD_VAR 0 3
98420: PUSH
98421: LD_INT 115
98423: EQUAL
98424: IFFALSE 98434
// sRanger := true ;
98426: LD_ADDR_EXP 175
98430: PUSH
98431: LD_INT 1
98433: ST_TO_ADDR
// end ; end ;
98434: PPOPN 6
98436: END
// every 0 0$2 trigger StreamModeActive and sRocket do var i , tmp ;
98437: LD_EXP 122
98441: PUSH
98442: LD_EXP 127
98446: AND
98447: IFFALSE 98571
98449: GO 98451
98451: DISABLE
98452: LD_INT 0
98454: PPUSH
98455: PPUSH
// begin enable ;
98456: ENABLE
// tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_or , [ f_weapon , us_rocket_launcher ] , [ f_weapon , ru_rocket_launcher ] , [ f_weapon , ar_rocket_launcher ] , [ f_weapon , ru_rocket ] ] ] ) ;
98457: LD_ADDR_VAR 0 2
98461: PUSH
98462: LD_INT 22
98464: PUSH
98465: LD_OWVAR 2
98469: PUSH
98470: EMPTY
98471: LIST
98472: LIST
98473: PUSH
98474: LD_INT 2
98476: PUSH
98477: LD_INT 34
98479: PUSH
98480: LD_INT 7
98482: PUSH
98483: EMPTY
98484: LIST
98485: LIST
98486: PUSH
98487: LD_INT 34
98489: PUSH
98490: LD_INT 45
98492: PUSH
98493: EMPTY
98494: LIST
98495: LIST
98496: PUSH
98497: LD_INT 34
98499: PUSH
98500: LD_INT 28
98502: PUSH
98503: EMPTY
98504: LIST
98505: LIST
98506: PUSH
98507: LD_INT 34
98509: PUSH
98510: LD_INT 47
98512: PUSH
98513: EMPTY
98514: LIST
98515: LIST
98516: PUSH
98517: EMPTY
98518: LIST
98519: LIST
98520: LIST
98521: LIST
98522: LIST
98523: PUSH
98524: EMPTY
98525: LIST
98526: LIST
98527: PPUSH
98528: CALL_OW 69
98532: ST_TO_ADDR
// if not tmp then
98533: LD_VAR 0 2
98537: NOT
98538: IFFALSE 98542
// exit ;
98540: GO 98571
// for i in tmp do
98542: LD_ADDR_VAR 0 1
98546: PUSH
98547: LD_VAR 0 2
98551: PUSH
98552: FOR_IN
98553: IFFALSE 98569
// begin SetLives ( i , 0 ) ;
98555: LD_VAR 0 1
98559: PPUSH
98560: LD_INT 0
98562: PPUSH
98563: CALL_OW 234
// end ;
98567: GO 98552
98569: POP
98570: POP
// end ;
98571: PPOPN 2
98573: END
// every 0 0$2 trigger StreamModeActive and sEngine do var i , tmp ;
98574: LD_EXP 122
98578: PUSH
98579: LD_EXP 128
98583: AND
98584: IFFALSE 98668
98586: GO 98588
98588: DISABLE
98589: LD_INT 0
98591: PPUSH
98592: PPUSH
// begin enable ;
98593: ENABLE
// tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_engine , engine_siberite ] ] ) ;
98594: LD_ADDR_VAR 0 2
98598: PUSH
98599: LD_INT 22
98601: PUSH
98602: LD_OWVAR 2
98606: PUSH
98607: EMPTY
98608: LIST
98609: LIST
98610: PUSH
98611: LD_INT 32
98613: PUSH
98614: LD_INT 3
98616: PUSH
98617: EMPTY
98618: LIST
98619: LIST
98620: PUSH
98621: EMPTY
98622: LIST
98623: LIST
98624: PPUSH
98625: CALL_OW 69
98629: ST_TO_ADDR
// if not tmp then
98630: LD_VAR 0 2
98634: NOT
98635: IFFALSE 98639
// exit ;
98637: GO 98668
// for i in tmp do
98639: LD_ADDR_VAR 0 1
98643: PUSH
98644: LD_VAR 0 2
98648: PUSH
98649: FOR_IN
98650: IFFALSE 98666
// begin SetLives ( i , 0 ) ;
98652: LD_VAR 0 1
98656: PPUSH
98657: LD_INT 0
98659: PPUSH
98660: CALL_OW 234
// end ;
98664: GO 98649
98666: POP
98667: POP
// end ;
98668: PPOPN 2
98670: END
// every 0 0$1 trigger StreamModeActive and sSpec do var i ;
98671: LD_EXP 122
98675: PUSH
98676: LD_EXP 125
98680: AND
98681: IFFALSE 98774
98683: GO 98685
98685: DISABLE
98686: LD_INT 0
98688: PPUSH
// begin enable ;
98689: ENABLE
// for i in FilterAllUnits ( [ [ f_side , your_side ] , [ f_or , [ f_class , class_sniper ] , [ f_class , class_bazooker ] , [ f_class , class_mortar ] ] ] ) do
98690: LD_ADDR_VAR 0 1
98694: PUSH
98695: LD_INT 22
98697: PUSH
98698: LD_OWVAR 2
98702: PUSH
98703: EMPTY
98704: LIST
98705: LIST
98706: PUSH
98707: LD_INT 2
98709: PUSH
98710: LD_INT 25
98712: PUSH
98713: LD_INT 5
98715: PUSH
98716: EMPTY
98717: LIST
98718: LIST
98719: PUSH
98720: LD_INT 25
98722: PUSH
98723: LD_INT 9
98725: PUSH
98726: EMPTY
98727: LIST
98728: LIST
98729: PUSH
98730: LD_INT 25
98732: PUSH
98733: LD_INT 8
98735: PUSH
98736: EMPTY
98737: LIST
98738: LIST
98739: PUSH
98740: EMPTY
98741: LIST
98742: LIST
98743: LIST
98744: LIST
98745: PUSH
98746: EMPTY
98747: LIST
98748: LIST
98749: PPUSH
98750: CALL_OW 69
98754: PUSH
98755: FOR_IN
98756: IFFALSE 98772
// begin SetClass ( i , 1 ) ;
98758: LD_VAR 0 1
98762: PPUSH
98763: LD_INT 1
98765: PPUSH
98766: CALL_OW 336
// end ;
98770: GO 98755
98772: POP
98773: POP
// end ;
98774: PPOPN 1
98776: END
// every 0 0$1 trigger StreamModeActive and sSpeed and game_speed < 7 do
98777: LD_EXP 122
98781: PUSH
98782: LD_EXP 126
98786: AND
98787: PUSH
98788: LD_OWVAR 65
98792: PUSH
98793: LD_INT 7
98795: LESS
98796: AND
98797: IFFALSE 98811
98799: GO 98801
98801: DISABLE
// begin enable ;
98802: ENABLE
// game_speed := 7 ;
98803: LD_ADDR_OWVAR 65
98807: PUSH
98808: LD_INT 7
98810: ST_TO_ADDR
// end ;
98811: END
// every 0 0$1 trigger StreamModeActive and sLevel do var i , k , tmp ;
98812: LD_EXP 122
98816: PUSH
98817: LD_EXP 129
98821: AND
98822: IFFALSE 99024
98824: GO 98826
98826: DISABLE
98827: LD_INT 0
98829: PPUSH
98830: PPUSH
98831: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_enemy , your_side ] , [ f_type , unit_human ] ] ) ;
98832: LD_ADDR_VAR 0 3
98836: PUSH
98837: LD_INT 81
98839: PUSH
98840: LD_OWVAR 2
98844: PUSH
98845: EMPTY
98846: LIST
98847: LIST
98848: PUSH
98849: LD_INT 21
98851: PUSH
98852: LD_INT 1
98854: PUSH
98855: EMPTY
98856: LIST
98857: LIST
98858: PUSH
98859: EMPTY
98860: LIST
98861: LIST
98862: PPUSH
98863: CALL_OW 69
98867: ST_TO_ADDR
// if not tmp then
98868: LD_VAR 0 3
98872: NOT
98873: IFFALSE 98877
// exit ;
98875: GO 99024
// if tmp > 5 then
98877: LD_VAR 0 3
98881: PUSH
98882: LD_INT 5
98884: GREATER
98885: IFFALSE 98897
// k := 5 else
98887: LD_ADDR_VAR 0 2
98891: PUSH
98892: LD_INT 5
98894: ST_TO_ADDR
98895: GO 98907
// k := tmp ;
98897: LD_ADDR_VAR 0 2
98901: PUSH
98902: LD_VAR 0 3
98906: ST_TO_ADDR
// for i := 1 to k do
98907: LD_ADDR_VAR 0 1
98911: PUSH
98912: DOUBLE
98913: LD_INT 1
98915: DEC
98916: ST_TO_ADDR
98917: LD_VAR 0 2
98921: PUSH
98922: FOR_TO
98923: IFFALSE 99022
// if GetSkill ( tmp [ i ] , i mod 4 + 1 ) < 10 then
98925: LD_VAR 0 3
98929: PUSH
98930: LD_VAR 0 1
98934: ARRAY
98935: PPUSH
98936: LD_VAR 0 1
98940: PUSH
98941: LD_INT 4
98943: MOD
98944: PUSH
98945: LD_INT 1
98947: PLUS
98948: PPUSH
98949: CALL_OW 259
98953: PUSH
98954: LD_INT 10
98956: LESS
98957: IFFALSE 99020
// SetSkill ( tmp [ i ] , i mod 4 + 1 , GetSkill ( tmp [ i ] , i mod 4 + 1 ) + 1 ) ;
98959: LD_VAR 0 3
98963: PUSH
98964: LD_VAR 0 1
98968: ARRAY
98969: PPUSH
98970: LD_VAR 0 1
98974: PUSH
98975: LD_INT 4
98977: MOD
98978: PUSH
98979: LD_INT 1
98981: PLUS
98982: PPUSH
98983: LD_VAR 0 3
98987: PUSH
98988: LD_VAR 0 1
98992: ARRAY
98993: PPUSH
98994: LD_VAR 0 1
98998: PUSH
98999: LD_INT 4
99001: MOD
99002: PUSH
99003: LD_INT 1
99005: PLUS
99006: PPUSH
99007: CALL_OW 259
99011: PUSH
99012: LD_INT 1
99014: PLUS
99015: PPUSH
99016: CALL_OW 237
99020: GO 98922
99022: POP
99023: POP
// end ;
99024: PPOPN 3
99026: END
// every 0 0$1 trigger StreamModeActive and sArmoury do
99027: LD_EXP 122
99031: PUSH
99032: LD_EXP 130
99036: AND
99037: IFFALSE 99057
99039: GO 99041
99041: DISABLE
// SetRestrict ( b_armoury , your_side , false ) ;
99042: LD_INT 4
99044: PPUSH
99045: LD_OWVAR 2
99049: PPUSH
99050: LD_INT 0
99052: PPUSH
99053: CALL_OW 324
99057: END
// every 0 0$1 trigger StreamModeActive and sShovel do
99058: LD_EXP 122
99062: PUSH
99063: LD_EXP 159
99067: AND
99068: IFFALSE 99088
99070: GO 99072
99072: DISABLE
// SetRestrict ( b_ext_noncombat , your_side , false ) ;
99073: LD_INT 19
99075: PPUSH
99076: LD_OWVAR 2
99080: PPUSH
99081: LD_INT 0
99083: PPUSH
99084: CALL_OW 324
99088: END
// every 0 0$1 trigger StreamModeActive and sRadar do var i , tmp ;
99089: LD_EXP 122
99093: PUSH
99094: LD_EXP 131
99098: AND
99099: IFFALSE 99201
99101: GO 99103
99103: DISABLE
99104: LD_INT 0
99106: PPUSH
99107: PPUSH
// begin enable ;
99108: ENABLE
// tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_or , [ f_weapon , us_radar ] , [ f_weapon , ar_radar ] ] ] ) ;
99109: LD_ADDR_VAR 0 2
99113: PUSH
99114: LD_INT 22
99116: PUSH
99117: LD_OWVAR 2
99121: PUSH
99122: EMPTY
99123: LIST
99124: LIST
99125: PUSH
99126: LD_INT 2
99128: PUSH
99129: LD_INT 34
99131: PUSH
99132: LD_INT 11
99134: PUSH
99135: EMPTY
99136: LIST
99137: LIST
99138: PUSH
99139: LD_INT 34
99141: PUSH
99142: LD_INT 30
99144: PUSH
99145: EMPTY
99146: LIST
99147: LIST
99148: PUSH
99149: EMPTY
99150: LIST
99151: LIST
99152: LIST
99153: PUSH
99154: EMPTY
99155: LIST
99156: LIST
99157: PPUSH
99158: CALL_OW 69
99162: ST_TO_ADDR
// if not tmp then
99163: LD_VAR 0 2
99167: NOT
99168: IFFALSE 99172
// exit ;
99170: GO 99201
// for i in tmp do
99172: LD_ADDR_VAR 0 1
99176: PUSH
99177: LD_VAR 0 2
99181: PUSH
99182: FOR_IN
99183: IFFALSE 99199
// begin SetLives ( i , 0 ) ;
99185: LD_VAR 0 1
99189: PPUSH
99190: LD_INT 0
99192: PPUSH
99193: CALL_OW 234
// end ;
99197: GO 99182
99199: POP
99200: POP
// end ;
99201: PPOPN 2
99203: END
// every 0 0$1 trigger StreamModeActive and sBunker do
99204: LD_EXP 122
99208: PUSH
99209: LD_EXP 132
99213: AND
99214: IFFALSE 99234
99216: GO 99218
99218: DISABLE
// SetRestrict ( b_bunker , your_side , false ) ;
99219: LD_INT 32
99221: PPUSH
99222: LD_OWVAR 2
99226: PPUSH
99227: LD_INT 0
99229: PPUSH
99230: CALL_OW 324
99234: END
// every 0 0$1 trigger StreamModeActive and sHack do var i , tmp , side ;
99235: LD_EXP 122
99239: PUSH
99240: LD_EXP 133
99244: AND
99245: IFFALSE 99426
99247: GO 99249
99249: DISABLE
99250: LD_INT 0
99252: PPUSH
99253: PPUSH
99254: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_control , control_computer ] ] ) ;
99255: LD_ADDR_VAR 0 2
99259: PUSH
99260: LD_INT 22
99262: PUSH
99263: LD_OWVAR 2
99267: PUSH
99268: EMPTY
99269: LIST
99270: LIST
99271: PUSH
99272: LD_INT 33
99274: PUSH
99275: LD_INT 3
99277: PUSH
99278: EMPTY
99279: LIST
99280: LIST
99281: PUSH
99282: EMPTY
99283: LIST
99284: LIST
99285: PPUSH
99286: CALL_OW 69
99290: ST_TO_ADDR
// if not tmp then
99291: LD_VAR 0 2
99295: NOT
99296: IFFALSE 99300
// exit ;
99298: GO 99426
// side := 0 ;
99300: LD_ADDR_VAR 0 3
99304: PUSH
99305: LD_INT 0
99307: ST_TO_ADDR
// for i := 1 to 8 do
99308: LD_ADDR_VAR 0 1
99312: PUSH
99313: DOUBLE
99314: LD_INT 1
99316: DEC
99317: ST_TO_ADDR
99318: LD_INT 8
99320: PUSH
99321: FOR_TO
99322: IFFALSE 99370
// if your_side <> i and GetAttitude ( your_side , i ) = att_enemy then
99324: LD_OWVAR 2
99328: PUSH
99329: LD_VAR 0 1
99333: NONEQUAL
99334: PUSH
99335: LD_OWVAR 2
99339: PPUSH
99340: LD_VAR 0 1
99344: PPUSH
99345: CALL_OW 81
99349: PUSH
99350: LD_INT 2
99352: EQUAL
99353: AND
99354: IFFALSE 99368
// begin side := i ;
99356: LD_ADDR_VAR 0 3
99360: PUSH
99361: LD_VAR 0 1
99365: ST_TO_ADDR
// break ;
99366: GO 99370
// end ;
99368: GO 99321
99370: POP
99371: POP
// if not side then
99372: LD_VAR 0 3
99376: NOT
99377: IFFALSE 99381
// exit ;
99379: GO 99426
// for i := 1 to tmp do
99381: LD_ADDR_VAR 0 1
99385: PUSH
99386: DOUBLE
99387: LD_INT 1
99389: DEC
99390: ST_TO_ADDR
99391: LD_VAR 0 2
99395: PUSH
99396: FOR_TO
99397: IFFALSE 99424
// if Prob ( 60 ) then
99399: LD_INT 60
99401: PPUSH
99402: CALL_OW 13
99406: IFFALSE 99422
// SetSide ( i , side ) ;
99408: LD_VAR 0 1
99412: PPUSH
99413: LD_VAR 0 3
99417: PPUSH
99418: CALL_OW 235
99422: GO 99396
99424: POP
99425: POP
// end ;
99426: PPOPN 3
99428: END
// every 0 0$1 trigger StreamModeActive and sRefresh do var un ;
99429: LD_EXP 122
99433: PUSH
99434: LD_EXP 135
99438: AND
99439: IFFALSE 99558
99441: GO 99443
99443: DISABLE
99444: LD_INT 0
99446: PPUSH
// begin for un in FilterAllUnits ( [ [ f_side , your_side ] , [ f_type , unit_human ] , [ f_not , [ f_nation , 0 ] ] ] ) do
99447: LD_ADDR_VAR 0 1
99451: PUSH
99452: LD_INT 22
99454: PUSH
99455: LD_OWVAR 2
99459: PUSH
99460: EMPTY
99461: LIST
99462: LIST
99463: PUSH
99464: LD_INT 21
99466: PUSH
99467: LD_INT 1
99469: PUSH
99470: EMPTY
99471: LIST
99472: LIST
99473: PUSH
99474: LD_INT 3
99476: PUSH
99477: LD_INT 23
99479: PUSH
99480: LD_INT 0
99482: PUSH
99483: EMPTY
99484: LIST
99485: LIST
99486: PUSH
99487: EMPTY
99488: LIST
99489: LIST
99490: PUSH
99491: EMPTY
99492: LIST
99493: LIST
99494: LIST
99495: PPUSH
99496: CALL_OW 69
99500: PUSH
99501: FOR_IN
99502: IFFALSE 99556
// if GetClass ( un ) in [ 1 , 2 , 3 , 4 ] then
99504: LD_VAR 0 1
99508: PPUSH
99509: CALL_OW 257
99513: PUSH
99514: LD_INT 1
99516: PUSH
99517: LD_INT 2
99519: PUSH
99520: LD_INT 3
99522: PUSH
99523: LD_INT 4
99525: PUSH
99526: EMPTY
99527: LIST
99528: LIST
99529: LIST
99530: LIST
99531: IN
99532: IFFALSE 99554
// SetClass ( un , rand ( 1 , 4 ) ) ;
99534: LD_VAR 0 1
99538: PPUSH
99539: LD_INT 1
99541: PPUSH
99542: LD_INT 4
99544: PPUSH
99545: CALL_OW 12
99549: PPUSH
99550: CALL_OW 336
99554: GO 99501
99556: POP
99557: POP
// end ;
99558: PPOPN 1
99560: END
// every 0 0$1 trigger StreamModeActive and sFire do var tmp ;
99561: LD_EXP 122
99565: PUSH
99566: LD_EXP 134
99570: AND
99571: IFFALSE 99650
99573: GO 99575
99575: DISABLE
99576: LD_INT 0
99578: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_type , unit_building ] ] ) ;
99579: LD_ADDR_VAR 0 1
99583: PUSH
99584: LD_INT 22
99586: PUSH
99587: LD_OWVAR 2
99591: PUSH
99592: EMPTY
99593: LIST
99594: LIST
99595: PUSH
99596: LD_INT 21
99598: PUSH
99599: LD_INT 3
99601: PUSH
99602: EMPTY
99603: LIST
99604: LIST
99605: PUSH
99606: EMPTY
99607: LIST
99608: LIST
99609: PPUSH
99610: CALL_OW 69
99614: ST_TO_ADDR
// if not tmp then
99615: LD_VAR 0 1
99619: NOT
99620: IFFALSE 99624
// exit ;
99622: GO 99650
// SetLives ( tmp [ rand ( 1 , tmp ) ] , 100 ) ;
99624: LD_VAR 0 1
99628: PUSH
99629: LD_INT 1
99631: PPUSH
99632: LD_VAR 0 1
99636: PPUSH
99637: CALL_OW 12
99641: ARRAY
99642: PPUSH
99643: LD_INT 100
99645: PPUSH
99646: CALL_OW 234
// end ;
99650: PPOPN 1
99652: END
// every 0 0$1 trigger StreamModeActive and sExp do var tmp ;
99653: LD_EXP 122
99657: PUSH
99658: LD_EXP 136
99662: AND
99663: IFFALSE 99761
99665: GO 99667
99667: DISABLE
99668: LD_INT 0
99670: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_type , unit_human ] ] ) ;
99671: LD_ADDR_VAR 0 1
99675: PUSH
99676: LD_INT 22
99678: PUSH
99679: LD_OWVAR 2
99683: PUSH
99684: EMPTY
99685: LIST
99686: LIST
99687: PUSH
99688: LD_INT 21
99690: PUSH
99691: LD_INT 1
99693: PUSH
99694: EMPTY
99695: LIST
99696: LIST
99697: PUSH
99698: EMPTY
99699: LIST
99700: LIST
99701: PPUSH
99702: CALL_OW 69
99706: ST_TO_ADDR
// if not tmp then
99707: LD_VAR 0 1
99711: NOT
99712: IFFALSE 99716
// exit ;
99714: GO 99761
// AddExperience ( tmp [ rand ( 1 , tmp ) ] , rand ( 1 , 4 ) , rand ( 3000 , 9000 ) ) ;
99716: LD_VAR 0 1
99720: PUSH
99721: LD_INT 1
99723: PPUSH
99724: LD_VAR 0 1
99728: PPUSH
99729: CALL_OW 12
99733: ARRAY
99734: PPUSH
99735: LD_INT 1
99737: PPUSH
99738: LD_INT 4
99740: PPUSH
99741: CALL_OW 12
99745: PPUSH
99746: LD_INT 3000
99748: PPUSH
99749: LD_INT 9000
99751: PPUSH
99752: CALL_OW 12
99756: PPUSH
99757: CALL_OW 492
// end ;
99761: PPOPN 1
99763: END
// every 0 0$1 trigger StreamModeActive and sDepot do
99764: LD_EXP 122
99768: PUSH
99769: LD_EXP 137
99773: AND
99774: IFFALSE 99794
99776: GO 99778
99778: DISABLE
// SetRestrict ( b_warehouse , your_side , false ) ;
99779: LD_INT 1
99781: PPUSH
99782: LD_OWVAR 2
99786: PPUSH
99787: LD_INT 0
99789: PPUSH
99790: CALL_OW 324
99794: END
// every 0 0$1 trigger StreamModeActive and sFlag do var i , tmp ;
99795: LD_EXP 122
99799: PUSH
99800: LD_EXP 138
99804: AND
99805: IFFALSE 99888
99807: GO 99809
99809: DISABLE
99810: LD_INT 0
99812: PPUSH
99813: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_type , unit_building ] ] ) ;
99814: LD_ADDR_VAR 0 2
99818: PUSH
99819: LD_INT 22
99821: PUSH
99822: LD_OWVAR 2
99826: PUSH
99827: EMPTY
99828: LIST
99829: LIST
99830: PUSH
99831: LD_INT 21
99833: PUSH
99834: LD_INT 3
99836: PUSH
99837: EMPTY
99838: LIST
99839: LIST
99840: PUSH
99841: EMPTY
99842: LIST
99843: LIST
99844: PPUSH
99845: CALL_OW 69
99849: ST_TO_ADDR
// if not tmp then
99850: LD_VAR 0 2
99854: NOT
99855: IFFALSE 99859
// exit ;
99857: GO 99888
// for i in tmp do
99859: LD_ADDR_VAR 0 1
99863: PUSH
99864: LD_VAR 0 2
99868: PUSH
99869: FOR_IN
99870: IFFALSE 99886
// SetBLevel ( i , 10 ) ;
99872: LD_VAR 0 1
99876: PPUSH
99877: LD_INT 10
99879: PPUSH
99880: CALL_OW 241
99884: GO 99869
99886: POP
99887: POP
// end ;
99888: PPOPN 2
99890: END
// every 0 0$1 trigger StreamModeActive and sSold do var i , un , tmp ;
99891: LD_EXP 122
99895: PUSH
99896: LD_EXP 139
99900: AND
99901: IFFALSE 100012
99903: GO 99905
99905: DISABLE
99906: LD_INT 0
99908: PPUSH
99909: PPUSH
99910: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_class , 1 ] ] ) ;
99911: LD_ADDR_VAR 0 3
99915: PUSH
99916: LD_INT 22
99918: PUSH
99919: LD_OWVAR 2
99923: PUSH
99924: EMPTY
99925: LIST
99926: LIST
99927: PUSH
99928: LD_INT 25
99930: PUSH
99931: LD_INT 1
99933: PUSH
99934: EMPTY
99935: LIST
99936: LIST
99937: PUSH
99938: EMPTY
99939: LIST
99940: LIST
99941: PPUSH
99942: CALL_OW 69
99946: ST_TO_ADDR
// if not tmp then
99947: LD_VAR 0 3
99951: NOT
99952: IFFALSE 99956
// exit ;
99954: GO 100012
// un := tmp [ rand ( 1 , tmp ) ] ;
99956: LD_ADDR_VAR 0 2
99960: PUSH
99961: LD_VAR 0 3
99965: PUSH
99966: LD_INT 1
99968: PPUSH
99969: LD_VAR 0 3
99973: PPUSH
99974: CALL_OW 12
99978: ARRAY
99979: ST_TO_ADDR
// if Crawls ( un ) then
99980: LD_VAR 0 2
99984: PPUSH
99985: CALL_OW 318
99989: IFFALSE 100000
// ComWalk ( un ) ;
99991: LD_VAR 0 2
99995: PPUSH
99996: CALL_OW 138
// SetClass ( un , class_sniper ) ;
100000: LD_VAR 0 2
100004: PPUSH
100005: LD_INT 5
100007: PPUSH
100008: CALL_OW 336
// end ;
100012: PPOPN 3
100014: END
// every 0 0$1 trigger StreamModeActive and sDiff and Difficulty < 3 do
100015: LD_EXP 122
100019: PUSH
100020: LD_EXP 140
100024: AND
100025: PUSH
100026: LD_OWVAR 67
100030: PUSH
100031: LD_INT 3
100033: LESS
100034: AND
100035: IFFALSE 100054
100037: GO 100039
100039: DISABLE
// Difficulty := Difficulty + 1 ;
100040: LD_ADDR_OWVAR 67
100044: PUSH
100045: LD_OWVAR 67
100049: PUSH
100050: LD_INT 1
100052: PLUS
100053: ST_TO_ADDR
100054: END
// every 0 0$1 trigger StreamModeActive and sTiger do var i ;
100055: LD_EXP 122
100059: PUSH
100060: LD_EXP 141
100064: AND
100065: IFFALSE 100168
100067: GO 100069
100069: DISABLE
100070: LD_INT 0
100072: PPUSH
// begin for i := 1 to 5 do
100073: LD_ADDR_VAR 0 1
100077: PUSH
100078: DOUBLE
100079: LD_INT 1
100081: DEC
100082: ST_TO_ADDR
100083: LD_INT 5
100085: PUSH
100086: FOR_TO
100087: IFFALSE 100166
// begin uc_nation := nation_nature ;
100089: LD_ADDR_OWVAR 21
100093: PUSH
100094: LD_INT 0
100096: ST_TO_ADDR
// uc_side := 0 ;
100097: LD_ADDR_OWVAR 20
100101: PUSH
100102: LD_INT 0
100104: ST_TO_ADDR
// hc_attr := [ 12 , 12 ] ;
100105: LD_ADDR_OWVAR 29
100109: PUSH
100110: LD_INT 12
100112: PUSH
100113: LD_INT 12
100115: PUSH
100116: EMPTY
100117: LIST
100118: LIST
100119: ST_TO_ADDR
// hc_agressivity := 20 ;
100120: LD_ADDR_OWVAR 35
100124: PUSH
100125: LD_INT 20
100127: ST_TO_ADDR
// hc_class := class_tiger ;
100128: LD_ADDR_OWVAR 28
100132: PUSH
100133: LD_INT 14
100135: ST_TO_ADDR
// hc_gallery :=  ;
100136: LD_ADDR_OWVAR 33
100140: PUSH
100141: LD_STRING 
100143: ST_TO_ADDR
// hc_name :=  ;
100144: LD_ADDR_OWVAR 26
100148: PUSH
100149: LD_STRING 
100151: ST_TO_ADDR
// PlaceUnitAnyWhere ( CreateHuman , false ) ;
100152: CALL_OW 44
100156: PPUSH
100157: LD_INT 0
100159: PPUSH
100160: CALL_OW 51
// end ;
100164: GO 100086
100166: POP
100167: POP
// end ;
100168: PPOPN 1
100170: END
// every 0 0$1 trigger StreamModeActive and sBomb do
100171: LD_EXP 122
100175: PUSH
100176: LD_EXP 142
100180: AND
100181: IFFALSE 100190
100183: GO 100185
100185: DISABLE
// StreamSibBomb ;
100186: CALL 100191 0 0
100190: END
// export function StreamSibBomb ; var i , x , y ; begin
100191: LD_INT 0
100193: PPUSH
100194: PPUSH
100195: PPUSH
100196: PPUSH
// result := false ;
100197: LD_ADDR_VAR 0 1
100201: PUSH
100202: LD_INT 0
100204: ST_TO_ADDR
// for i := 1 to 16 do
100205: LD_ADDR_VAR 0 2
100209: PUSH
100210: DOUBLE
100211: LD_INT 1
100213: DEC
100214: ST_TO_ADDR
100215: LD_INT 16
100217: PUSH
100218: FOR_TO
100219: IFFALSE 100418
// begin x := [ 10 , 20 , 30 , 40 , 50 , 60 , 70 , 80 , 90 , 100 , 110 , 120 , 130 , 140 , 150 ] [ rand ( 1 , 15 ) ] ;
100221: LD_ADDR_VAR 0 3
100225: PUSH
100226: LD_INT 10
100228: PUSH
100229: LD_INT 20
100231: PUSH
100232: LD_INT 30
100234: PUSH
100235: LD_INT 40
100237: PUSH
100238: LD_INT 50
100240: PUSH
100241: LD_INT 60
100243: PUSH
100244: LD_INT 70
100246: PUSH
100247: LD_INT 80
100249: PUSH
100250: LD_INT 90
100252: PUSH
100253: LD_INT 100
100255: PUSH
100256: LD_INT 110
100258: PUSH
100259: LD_INT 120
100261: PUSH
100262: LD_INT 130
100264: PUSH
100265: LD_INT 140
100267: PUSH
100268: LD_INT 150
100270: PUSH
100271: EMPTY
100272: LIST
100273: LIST
100274: LIST
100275: LIST
100276: LIST
100277: LIST
100278: LIST
100279: LIST
100280: LIST
100281: LIST
100282: LIST
100283: LIST
100284: LIST
100285: LIST
100286: LIST
100287: PUSH
100288: LD_INT 1
100290: PPUSH
100291: LD_INT 15
100293: PPUSH
100294: CALL_OW 12
100298: ARRAY
100299: ST_TO_ADDR
// y := [ 10 , 20 , 30 , 40 , 50 , 60 , 70 , 80 , 90 , 100 , 110 , 120 , 130 , 140 , 150 ] [ rand ( 1 , 15 ) ] ;
100300: LD_ADDR_VAR 0 4
100304: PUSH
100305: LD_INT 10
100307: PUSH
100308: LD_INT 20
100310: PUSH
100311: LD_INT 30
100313: PUSH
100314: LD_INT 40
100316: PUSH
100317: LD_INT 50
100319: PUSH
100320: LD_INT 60
100322: PUSH
100323: LD_INT 70
100325: PUSH
100326: LD_INT 80
100328: PUSH
100329: LD_INT 90
100331: PUSH
100332: LD_INT 100
100334: PUSH
100335: LD_INT 110
100337: PUSH
100338: LD_INT 120
100340: PUSH
100341: LD_INT 130
100343: PUSH
100344: LD_INT 140
100346: PUSH
100347: LD_INT 150
100349: PUSH
100350: EMPTY
100351: LIST
100352: LIST
100353: LIST
100354: LIST
100355: LIST
100356: LIST
100357: LIST
100358: LIST
100359: LIST
100360: LIST
100361: LIST
100362: LIST
100363: LIST
100364: LIST
100365: LIST
100366: PUSH
100367: LD_INT 1
100369: PPUSH
100370: LD_INT 15
100372: PPUSH
100373: CALL_OW 12
100377: ARRAY
100378: ST_TO_ADDR
// if ValidHex ( x , y ) then
100379: LD_VAR 0 3
100383: PPUSH
100384: LD_VAR 0 4
100388: PPUSH
100389: CALL_OW 488
100393: IFFALSE 100416
// begin result := [ x , y ] ;
100395: LD_ADDR_VAR 0 1
100399: PUSH
100400: LD_VAR 0 3
100404: PUSH
100405: LD_VAR 0 4
100409: PUSH
100410: EMPTY
100411: LIST
100412: LIST
100413: ST_TO_ADDR
// break ;
100414: GO 100418
// end ; end ;
100416: GO 100218
100418: POP
100419: POP
// if result then
100420: LD_VAR 0 1
100424: IFFALSE 100484
// begin ToLua ( playSibBomb() ) ;
100426: LD_STRING playSibBomb()
100428: PPUSH
100429: CALL_OW 559
// wait ( 0 0$14 ) ;
100433: LD_INT 490
100435: PPUSH
100436: CALL_OW 67
// CenterNowOnXY ( result [ 1 ] , result [ 2 ] ) ;
100440: LD_VAR 0 1
100444: PUSH
100445: LD_INT 1
100447: ARRAY
100448: PPUSH
100449: LD_VAR 0 1
100453: PUSH
100454: LD_INT 2
100456: ARRAY
100457: PPUSH
100458: CALL_OW 86
// SendSiberiteRocket ( result [ 1 ] , result [ 2 ] ) ;
100462: LD_VAR 0 1
100466: PUSH
100467: LD_INT 1
100469: ARRAY
100470: PPUSH
100471: LD_VAR 0 1
100475: PUSH
100476: LD_INT 2
100478: ARRAY
100479: PPUSH
100480: CALL_OW 429
// end ; end ;
100484: LD_VAR 0 1
100488: RET
// every 0 0$1 trigger StreamModeActive and sReset do
100489: LD_EXP 122
100493: PUSH
100494: LD_EXP 144
100498: AND
100499: IFFALSE 100511
100501: GO 100503
100503: DISABLE
// YouLost (  ) ;
100504: LD_STRING 
100506: PPUSH
100507: CALL_OW 104
100511: END
// every 0 0$1 trigger StreamModeActive and sFog do
100512: LD_EXP 122
100516: PUSH
100517: LD_EXP 143
100521: AND
100522: IFFALSE 100536
100524: GO 100526
100526: DISABLE
// FogOff ( your_side ) ;
100527: LD_OWVAR 2
100531: PPUSH
100532: CALL_OW 344
100536: END
// every 0 0$1 trigger StreamModeActive and sSun do
100537: LD_EXP 122
100541: PUSH
100542: LD_EXP 145
100546: AND
100547: IFFALSE 100575
100549: GO 100551
100551: DISABLE
// begin solar_recharge_percent := 0 ;
100552: LD_ADDR_OWVAR 79
100556: PUSH
100557: LD_INT 0
100559: ST_TO_ADDR
// wait ( 5 5$00 ) ;
100560: LD_INT 10500
100562: PPUSH
100563: CALL_OW 67
// solar_recharge_percent := 100 ;
100567: LD_ADDR_OWVAR 79
100571: PUSH
100572: LD_INT 100
100574: ST_TO_ADDR
// end ;
100575: END
// every 0 0$1 trigger StreamModeActive and sKamikadze do var i , un , tmp ;
100576: LD_EXP 122
100580: PUSH
100581: LD_EXP 146
100585: AND
100586: IFFALSE 100825
100588: GO 100590
100590: DISABLE
100591: LD_INT 0
100593: PPUSH
100594: PPUSH
100595: PPUSH
// begin tmp := [ ] ;
100596: LD_ADDR_VAR 0 3
100600: PUSH
100601: EMPTY
100602: ST_TO_ADDR
// for i := 1 to 6 do
100603: LD_ADDR_VAR 0 1
100607: PUSH
100608: DOUBLE
100609: LD_INT 1
100611: DEC
100612: ST_TO_ADDR
100613: LD_INT 6
100615: PUSH
100616: FOR_TO
100617: IFFALSE 100722
// begin uc_nation := nation_nature ;
100619: LD_ADDR_OWVAR 21
100623: PUSH
100624: LD_INT 0
100626: ST_TO_ADDR
// uc_side := 0 ;
100627: LD_ADDR_OWVAR 20
100631: PUSH
100632: LD_INT 0
100634: ST_TO_ADDR
// hc_attr := [ 12 , 12 ] ;
100635: LD_ADDR_OWVAR 29
100639: PUSH
100640: LD_INT 12
100642: PUSH
100643: LD_INT 12
100645: PUSH
100646: EMPTY
100647: LIST
100648: LIST
100649: ST_TO_ADDR
// hc_agressivity := 20 ;
100650: LD_ADDR_OWVAR 35
100654: PUSH
100655: LD_INT 20
100657: ST_TO_ADDR
// hc_class := class_apeman_kamikaze ;
100658: LD_ADDR_OWVAR 28
100662: PUSH
100663: LD_INT 17
100665: ST_TO_ADDR
// hc_gallery :=  ;
100666: LD_ADDR_OWVAR 33
100670: PUSH
100671: LD_STRING 
100673: ST_TO_ADDR
// hc_name :=  ;
100674: LD_ADDR_OWVAR 26
100678: PUSH
100679: LD_STRING 
100681: ST_TO_ADDR
// un := CreateHuman ;
100682: LD_ADDR_VAR 0 2
100686: PUSH
100687: CALL_OW 44
100691: ST_TO_ADDR
// PlaceUnitAnyWhere ( un , true ) ;
100692: LD_VAR 0 2
100696: PPUSH
100697: LD_INT 1
100699: PPUSH
100700: CALL_OW 51
// tmp := tmp ^ un ;
100704: LD_ADDR_VAR 0 3
100708: PUSH
100709: LD_VAR 0 3
100713: PUSH
100714: LD_VAR 0 2
100718: ADD
100719: ST_TO_ADDR
// end ;
100720: GO 100616
100722: POP
100723: POP
// repeat wait ( 0 0$1 ) ;
100724: LD_INT 35
100726: PPUSH
100727: CALL_OW 67
// for un in tmp do
100731: LD_ADDR_VAR 0 2
100735: PUSH
100736: LD_VAR 0 3
100740: PUSH
100741: FOR_IN
100742: IFFALSE 100816
// begin if IsDead ( un ) then
100744: LD_VAR 0 2
100748: PPUSH
100749: CALL_OW 301
100753: IFFALSE 100773
// begin tmp := tmp diff un ;
100755: LD_ADDR_VAR 0 3
100759: PUSH
100760: LD_VAR 0 3
100764: PUSH
100765: LD_VAR 0 2
100769: DIFF
100770: ST_TO_ADDR
// continue ;
100771: GO 100741
// end ; ComAttackUnit ( un , NearestUnitToUnit ( FilterAllUnits ( [ f_not , [ f_side , 0 ] ] ) , un ) ) ;
100773: LD_VAR 0 2
100777: PPUSH
100778: LD_INT 3
100780: PUSH
100781: LD_INT 22
100783: PUSH
100784: LD_INT 0
100786: PUSH
100787: EMPTY
100788: LIST
100789: LIST
100790: PUSH
100791: EMPTY
100792: LIST
100793: LIST
100794: PPUSH
100795: CALL_OW 69
100799: PPUSH
100800: LD_VAR 0 2
100804: PPUSH
100805: CALL_OW 74
100809: PPUSH
100810: CALL_OW 115
// end ;
100814: GO 100741
100816: POP
100817: POP
// until not tmp ;
100818: LD_VAR 0 3
100822: NOT
100823: IFFALSE 100724
// end ;
100825: PPOPN 3
100827: END
// every 0 0$1 trigger StreamModeActive and sTroll do
100828: LD_EXP 122
100832: PUSH
100833: LD_EXP 147
100837: AND
100838: IFFALSE 100892
100840: GO 100842
100842: DISABLE
// begin ToLua ( displayTroll(); ) ;
100843: LD_STRING displayTroll();
100845: PPUSH
100846: CALL_OW 559
// wait ( 3 3$00 ) ;
100850: LD_INT 6300
100852: PPUSH
100853: CALL_OW 67
// ToLua ( hideTroll(); ) ;
100857: LD_STRING hideTroll();
100859: PPUSH
100860: CALL_OW 559
// wait ( 1 1$00 ) ;
100864: LD_INT 2100
100866: PPUSH
100867: CALL_OW 67
// ToLua ( displayTroll(); ) ;
100871: LD_STRING displayTroll();
100873: PPUSH
100874: CALL_OW 559
// wait ( 1 1$00 ) ;
100878: LD_INT 2100
100880: PPUSH
100881: CALL_OW 67
// ToLua ( hideTroll(); ) ;
100885: LD_STRING hideTroll();
100887: PPUSH
100888: CALL_OW 559
// end ;
100892: END
// every 0 0$1 trigger StreamModeActive and sSlow do var p ;
100893: LD_EXP 122
100897: PUSH
100898: LD_EXP 148
100902: AND
100903: IFFALSE 100966
100905: GO 100907
100907: DISABLE
100908: LD_INT 0
100910: PPUSH
// begin p := 0 ;
100911: LD_ADDR_VAR 0 1
100915: PUSH
100916: LD_INT 0
100918: ST_TO_ADDR
// repeat game_speed := 1 ;
100919: LD_ADDR_OWVAR 65
100923: PUSH
100924: LD_INT 1
100926: ST_TO_ADDR
// wait ( 0 0$1 ) ;
100927: LD_INT 35
100929: PPUSH
100930: CALL_OW 67
// p := p + 1 ;
100934: LD_ADDR_VAR 0 1
100938: PUSH
100939: LD_VAR 0 1
100943: PUSH
100944: LD_INT 1
100946: PLUS
100947: ST_TO_ADDR
// until p >= 60 ;
100948: LD_VAR 0 1
100952: PUSH
100953: LD_INT 60
100955: GREATEREQUAL
100956: IFFALSE 100919
// game_speed := 4 ;
100958: LD_ADDR_OWVAR 65
100962: PUSH
100963: LD_INT 4
100965: ST_TO_ADDR
// end ;
100966: PPOPN 1
100968: END
// every 0 0$1 trigger StreamModeActive and sLack do var depot , base ;
100969: LD_EXP 122
100973: PUSH
100974: LD_EXP 149
100978: AND
100979: IFFALSE 101125
100981: GO 100983
100983: DISABLE
100984: LD_INT 0
100986: PPUSH
100987: PPUSH
// begin depot := FilterAllUnits ( [ [ f_side , your_side ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ] ) ;
100988: LD_ADDR_VAR 0 1
100992: PUSH
100993: LD_INT 22
100995: PUSH
100996: LD_OWVAR 2
101000: PUSH
101001: EMPTY
101002: LIST
101003: LIST
101004: PUSH
101005: LD_INT 2
101007: PUSH
101008: LD_INT 30
101010: PUSH
101011: LD_INT 0
101013: PUSH
101014: EMPTY
101015: LIST
101016: LIST
101017: PUSH
101018: LD_INT 30
101020: PUSH
101021: LD_INT 1
101023: PUSH
101024: EMPTY
101025: LIST
101026: LIST
101027: PUSH
101028: EMPTY
101029: LIST
101030: LIST
101031: LIST
101032: PUSH
101033: EMPTY
101034: LIST
101035: LIST
101036: PPUSH
101037: CALL_OW 69
101041: ST_TO_ADDR
// if not depot then
101042: LD_VAR 0 1
101046: NOT
101047: IFFALSE 101051
// exit ;
101049: GO 101125
// base := GetBase ( depot [ rand ( 1 , depot ) ] ) ;
101051: LD_ADDR_VAR 0 2
101055: PUSH
101056: LD_VAR 0 1
101060: PUSH
101061: LD_INT 1
101063: PPUSH
101064: LD_VAR 0 1
101068: PPUSH
101069: CALL_OW 12
101073: ARRAY
101074: PPUSH
101075: CALL_OW 274
101079: ST_TO_ADDR
// SetResourceType ( base , mat_cans , 0 ) ;
101080: LD_VAR 0 2
101084: PPUSH
101085: LD_INT 1
101087: PPUSH
101088: LD_INT 0
101090: PPUSH
101091: CALL_OW 277
// SetResourceType ( base , mat_oil , 0 ) ;
101095: LD_VAR 0 2
101099: PPUSH
101100: LD_INT 2
101102: PPUSH
101103: LD_INT 0
101105: PPUSH
101106: CALL_OW 277
// SetResourceType ( base , mat_siberit , 0 ) ;
101110: LD_VAR 0 2
101114: PPUSH
101115: LD_INT 3
101117: PPUSH
101118: LD_INT 0
101120: PPUSH
101121: CALL_OW 277
// end ;
101125: PPOPN 2
101127: END
// every 0 0$1 trigger StreamModeActive and sWound do var tmp ;
101128: LD_EXP 122
101132: PUSH
101133: LD_EXP 150
101137: AND
101138: IFFALSE 101235
101140: GO 101142
101142: DISABLE
101143: LD_INT 0
101145: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_type , unit_human ] , [ f_not , [ f_nation , 0 ] ] ] ) ;
101146: LD_ADDR_VAR 0 1
101150: PUSH
101151: LD_INT 22
101153: PUSH
101154: LD_OWVAR 2
101158: PUSH
101159: EMPTY
101160: LIST
101161: LIST
101162: PUSH
101163: LD_INT 21
101165: PUSH
101166: LD_INT 1
101168: PUSH
101169: EMPTY
101170: LIST
101171: LIST
101172: PUSH
101173: LD_INT 3
101175: PUSH
101176: LD_INT 23
101178: PUSH
101179: LD_INT 0
101181: PUSH
101182: EMPTY
101183: LIST
101184: LIST
101185: PUSH
101186: EMPTY
101187: LIST
101188: LIST
101189: PUSH
101190: EMPTY
101191: LIST
101192: LIST
101193: LIST
101194: PPUSH
101195: CALL_OW 69
101199: ST_TO_ADDR
// if not tmp then
101200: LD_VAR 0 1
101204: NOT
101205: IFFALSE 101209
// exit ;
101207: GO 101235
// SetLives ( tmp [ rand ( 1 , tmp ) ] , 200 ) ;
101209: LD_VAR 0 1
101213: PUSH
101214: LD_INT 1
101216: PPUSH
101217: LD_VAR 0 1
101221: PPUSH
101222: CALL_OW 12
101226: ARRAY
101227: PPUSH
101228: LD_INT 200
101230: PPUSH
101231: CALL_OW 234
// end ;
101235: PPOPN 1
101237: END
// every 0 0$1 trigger StreamModeActive and sTank do var tmp ;
101238: LD_EXP 122
101242: PUSH
101243: LD_EXP 151
101247: AND
101248: IFFALSE 101327
101250: GO 101252
101252: DISABLE
101253: LD_INT 0
101255: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_type , unit_vehicle ] ] ) ;
101256: LD_ADDR_VAR 0 1
101260: PUSH
101261: LD_INT 22
101263: PUSH
101264: LD_OWVAR 2
101268: PUSH
101269: EMPTY
101270: LIST
101271: LIST
101272: PUSH
101273: LD_INT 21
101275: PUSH
101276: LD_INT 2
101278: PUSH
101279: EMPTY
101280: LIST
101281: LIST
101282: PUSH
101283: EMPTY
101284: LIST
101285: LIST
101286: PPUSH
101287: CALL_OW 69
101291: ST_TO_ADDR
// if not tmp then
101292: LD_VAR 0 1
101296: NOT
101297: IFFALSE 101301
// exit ;
101299: GO 101327
// SetLives ( tmp [ rand ( 1 , tmp ) ] , 60 ) ;
101301: LD_VAR 0 1
101305: PUSH
101306: LD_INT 1
101308: PPUSH
101309: LD_VAR 0 1
101313: PPUSH
101314: CALL_OW 12
101318: ARRAY
101319: PPUSH
101320: LD_INT 60
101322: PPUSH
101323: CALL_OW 234
// end ;
101327: PPOPN 1
101329: END
// every 0 0$1 trigger StreamModeActive and sRemote do var tmp , i ;
101330: LD_EXP 122
101334: PUSH
101335: LD_EXP 152
101339: AND
101340: IFFALSE 101439
101342: GO 101344
101344: DISABLE
101345: LD_INT 0
101347: PPUSH
101348: PPUSH
// begin enable ;
101349: ENABLE
// tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_linked ] , [ f_control , control_remote ] ] ) ;
101350: LD_ADDR_VAR 0 1
101354: PUSH
101355: LD_INT 22
101357: PUSH
101358: LD_OWVAR 2
101362: PUSH
101363: EMPTY
101364: LIST
101365: LIST
101366: PUSH
101367: LD_INT 61
101369: PUSH
101370: EMPTY
101371: LIST
101372: PUSH
101373: LD_INT 33
101375: PUSH
101376: LD_INT 2
101378: PUSH
101379: EMPTY
101380: LIST
101381: LIST
101382: PUSH
101383: EMPTY
101384: LIST
101385: LIST
101386: LIST
101387: PPUSH
101388: CALL_OW 69
101392: ST_TO_ADDR
// if not tmp then
101393: LD_VAR 0 1
101397: NOT
101398: IFFALSE 101402
// exit ;
101400: GO 101439
// for i in tmp do
101402: LD_ADDR_VAR 0 2
101406: PUSH
101407: LD_VAR 0 1
101411: PUSH
101412: FOR_IN
101413: IFFALSE 101437
// if IsControledBy ( i ) then
101415: LD_VAR 0 2
101419: PPUSH
101420: CALL_OW 312
101424: IFFALSE 101435
// ComUnlink ( i ) ;
101426: LD_VAR 0 2
101430: PPUSH
101431: CALL_OW 136
101435: GO 101412
101437: POP
101438: POP
// end ;
101439: PPOPN 2
101441: END
// every 0 0$1 trigger StreamModeActive and sPowell do var i , un ;
101442: LD_EXP 122
101446: PUSH
101447: LD_EXP 153
101451: AND
101452: IFFALSE 101592
101454: GO 101456
101456: DISABLE
101457: LD_INT 0
101459: PPUSH
101460: PPUSH
// begin ToLua ( displayPowell(); ) ;
101461: LD_STRING displayPowell();
101463: PPUSH
101464: CALL_OW 559
// uc_side := 0 ;
101468: LD_ADDR_OWVAR 20
101472: PUSH
101473: LD_INT 0
101475: ST_TO_ADDR
// uc_nation := 2 ;
101476: LD_ADDR_OWVAR 21
101480: PUSH
101481: LD_INT 2
101483: ST_TO_ADDR
// vc_chassis := ar_half_tracked ;
101484: LD_ADDR_OWVAR 37
101488: PUSH
101489: LD_INT 14
101491: ST_TO_ADDR
// vc_engine := engine_siberite ;
101492: LD_ADDR_OWVAR 39
101496: PUSH
101497: LD_INT 3
101499: ST_TO_ADDR
// vc_control := control_apeman ;
101500: LD_ADDR_OWVAR 38
101504: PUSH
101505: LD_INT 5
101507: ST_TO_ADDR
// vc_weapon := ar_selfpropelled_bomb ;
101508: LD_ADDR_OWVAR 40
101512: PUSH
101513: LD_INT 29
101515: ST_TO_ADDR
// un := CreateVehicle ;
101516: LD_ADDR_VAR 0 2
101520: PUSH
101521: CALL_OW 45
101525: ST_TO_ADDR
// PlaceUnitAnywhere ( un , true ) ;
101526: LD_VAR 0 2
101530: PPUSH
101531: LD_INT 1
101533: PPUSH
101534: CALL_OW 51
// repeat wait ( 0 0$1 ) ;
101538: LD_INT 35
101540: PPUSH
101541: CALL_OW 67
// ComAttackUnit ( un , NearestUnitToUnit ( FilterAllUnits ( [ f_side , your_side ] ) , un ) ) ;
101545: LD_VAR 0 2
101549: PPUSH
101550: LD_INT 22
101552: PUSH
101553: LD_OWVAR 2
101557: PUSH
101558: EMPTY
101559: LIST
101560: LIST
101561: PPUSH
101562: CALL_OW 69
101566: PPUSH
101567: LD_VAR 0 2
101571: PPUSH
101572: CALL_OW 74
101576: PPUSH
101577: CALL_OW 115
// until IsDead ( un ) ;
101581: LD_VAR 0 2
101585: PPUSH
101586: CALL_OW 301
101590: IFFALSE 101538
// end ;
101592: PPOPN 2
101594: END
// every 0 0$1 trigger StreamModeActive and sStu do
101595: LD_EXP 122
101599: PUSH
101600: LD_EXP 161
101604: AND
101605: IFFALSE 101621
101607: GO 101609
101609: DISABLE
// begin ToLua ( displayStucuk(); ) ;
101610: LD_STRING displayStucuk();
101612: PPUSH
101613: CALL_OW 559
// ResetFog ;
101617: CALL_OW 335
// end ;
101621: END
// every 0 0$1 trigger StreamModeActive and sBetray do var un , tmp ;
101622: LD_EXP 122
101626: PUSH
101627: LD_EXP 154
101631: AND
101632: IFFALSE 101773
101634: GO 101636
101636: DISABLE
101637: LD_INT 0
101639: PPUSH
101640: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_type , unit_human ] ] ) ;
101641: LD_ADDR_VAR 0 2
101645: PUSH
101646: LD_INT 22
101648: PUSH
101649: LD_OWVAR 2
101653: PUSH
101654: EMPTY
101655: LIST
101656: LIST
101657: PUSH
101658: LD_INT 21
101660: PUSH
101661: LD_INT 1
101663: PUSH
101664: EMPTY
101665: LIST
101666: LIST
101667: PUSH
101668: EMPTY
101669: LIST
101670: LIST
101671: PPUSH
101672: CALL_OW 69
101676: ST_TO_ADDR
// if not tmp then
101677: LD_VAR 0 2
101681: NOT
101682: IFFALSE 101686
// exit ;
101684: GO 101773
// un := tmp [ rand ( 1 , tmp ) ] ;
101686: LD_ADDR_VAR 0 1
101690: PUSH
101691: LD_VAR 0 2
101695: PUSH
101696: LD_INT 1
101698: PPUSH
101699: LD_VAR 0 2
101703: PPUSH
101704: CALL_OW 12
101708: ARRAY
101709: ST_TO_ADDR
// SetSide ( un , 0 ) ;
101710: LD_VAR 0 1
101714: PPUSH
101715: LD_INT 0
101717: PPUSH
101718: CALL_OW 235
// ComAttackUnit ( un , NearestUnitToUnit ( all_units diff un , un ) ) ;
101722: LD_VAR 0 1
101726: PPUSH
101727: LD_OWVAR 3
101731: PUSH
101732: LD_VAR 0 1
101736: DIFF
101737: PPUSH
101738: LD_VAR 0 1
101742: PPUSH
101743: CALL_OW 74
101747: PPUSH
101748: CALL_OW 115
// wait ( 0 0$20 ) ;
101752: LD_INT 700
101754: PPUSH
101755: CALL_OW 67
// SetSide ( un , your_side ) ;
101759: LD_VAR 0 1
101763: PPUSH
101764: LD_OWVAR 2
101768: PPUSH
101769: CALL_OW 235
// end ;
101773: PPOPN 2
101775: END
// every 0 0$1 trigger StreamModeActive and sContamin do var depot ;
101776: LD_EXP 122
101780: PUSH
101781: LD_EXP 155
101785: AND
101786: IFFALSE 101892
101788: GO 101790
101790: DISABLE
101791: LD_INT 0
101793: PPUSH
// begin depot := FilterAllUnits ( [ [ f_side , your_side ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ] ) ;
101794: LD_ADDR_VAR 0 1
101798: PUSH
101799: LD_INT 22
101801: PUSH
101802: LD_OWVAR 2
101806: PUSH
101807: EMPTY
101808: LIST
101809: LIST
101810: PUSH
101811: LD_INT 2
101813: PUSH
101814: LD_INT 30
101816: PUSH
101817: LD_INT 0
101819: PUSH
101820: EMPTY
101821: LIST
101822: LIST
101823: PUSH
101824: LD_INT 30
101826: PUSH
101827: LD_INT 1
101829: PUSH
101830: EMPTY
101831: LIST
101832: LIST
101833: PUSH
101834: EMPTY
101835: LIST
101836: LIST
101837: LIST
101838: PUSH
101839: EMPTY
101840: LIST
101841: LIST
101842: PPUSH
101843: CALL_OW 69
101847: ST_TO_ADDR
// if not depot then
101848: LD_VAR 0 1
101852: NOT
101853: IFFALSE 101857
// exit ;
101855: GO 101892
// ArtContamination ( GetX ( depot [ 1 ] ) , GetY ( depot [ 1 ] ) , 70 ) ;
101857: LD_VAR 0 1
101861: PUSH
101862: LD_INT 1
101864: ARRAY
101865: PPUSH
101866: CALL_OW 250
101870: PPUSH
101871: LD_VAR 0 1
101875: PUSH
101876: LD_INT 1
101878: ARRAY
101879: PPUSH
101880: CALL_OW 251
101884: PPUSH
101885: LD_INT 70
101887: PPUSH
101888: CALL_OW 495
// end ;
101892: PPOPN 1
101894: END
// every 0 0$1 trigger StreamModeActive and sTeleport do var i , x , y , d , tmp ;
101895: LD_EXP 122
101899: PUSH
101900: LD_EXP 156
101904: AND
101905: IFFALSE 102116
101907: GO 101909
101909: DISABLE
101910: LD_INT 0
101912: PPUSH
101913: PPUSH
101914: PPUSH
101915: PPUSH
101916: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_type , unit_human ] ] ) ;
101917: LD_ADDR_VAR 0 5
101921: PUSH
101922: LD_INT 22
101924: PUSH
101925: LD_OWVAR 2
101929: PUSH
101930: EMPTY
101931: LIST
101932: LIST
101933: PUSH
101934: LD_INT 21
101936: PUSH
101937: LD_INT 1
101939: PUSH
101940: EMPTY
101941: LIST
101942: LIST
101943: PUSH
101944: EMPTY
101945: LIST
101946: LIST
101947: PPUSH
101948: CALL_OW 69
101952: ST_TO_ADDR
// if not tmp then
101953: LD_VAR 0 5
101957: NOT
101958: IFFALSE 101962
// exit ;
101960: GO 102116
// for i in tmp do
101962: LD_ADDR_VAR 0 1
101966: PUSH
101967: LD_VAR 0 5
101971: PUSH
101972: FOR_IN
101973: IFFALSE 102114
// begin d := rand ( 0 , 5 ) ;
101975: LD_ADDR_VAR 0 4
101979: PUSH
101980: LD_INT 0
101982: PPUSH
101983: LD_INT 5
101985: PPUSH
101986: CALL_OW 12
101990: ST_TO_ADDR
// x := ShiftX ( GetX ( i ) , d , rand ( 3 , 12 ) ) ;
101991: LD_ADDR_VAR 0 2
101995: PUSH
101996: LD_VAR 0 1
102000: PPUSH
102001: CALL_OW 250
102005: PPUSH
102006: LD_VAR 0 4
102010: PPUSH
102011: LD_INT 3
102013: PPUSH
102014: LD_INT 12
102016: PPUSH
102017: CALL_OW 12
102021: PPUSH
102022: CALL_OW 272
102026: ST_TO_ADDR
// y := ShiftY ( GetY ( i ) , d , rand ( 3 , 12 ) ) ;
102027: LD_ADDR_VAR 0 3
102031: PUSH
102032: LD_VAR 0 1
102036: PPUSH
102037: CALL_OW 251
102041: PPUSH
102042: LD_VAR 0 4
102046: PPUSH
102047: LD_INT 3
102049: PPUSH
102050: LD_INT 12
102052: PPUSH
102053: CALL_OW 12
102057: PPUSH
102058: CALL_OW 273
102062: ST_TO_ADDR
// if ValidHex ( x , y ) then
102063: LD_VAR 0 2
102067: PPUSH
102068: LD_VAR 0 3
102072: PPUSH
102073: CALL_OW 488
102077: IFFALSE 102112
// TeleportUnit ( i , x , y , rand ( 3 , 6 ) , true ) ;
102079: LD_VAR 0 1
102083: PPUSH
102084: LD_VAR 0 2
102088: PPUSH
102089: LD_VAR 0 3
102093: PPUSH
102094: LD_INT 3
102096: PPUSH
102097: LD_INT 6
102099: PPUSH
102100: CALL_OW 12
102104: PPUSH
102105: LD_INT 1
102107: PPUSH
102108: CALL_OW 483
// end ;
102112: GO 101972
102114: POP
102115: POP
// end ;
102116: PPOPN 5
102118: END
// every 0 0$1 trigger StreamModeActive and sOil do var i , tmp ;
102119: LD_EXP 122
102123: PUSH
102124: LD_EXP 157
102128: AND
102129: IFFALSE 102223
102131: GO 102133
102133: DISABLE
102134: LD_INT 0
102136: PPUSH
102137: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_engine , engine_combustion ] , [ f_type , unit_vehicle ] ] ) ;
102138: LD_ADDR_VAR 0 2
102142: PUSH
102143: LD_INT 22
102145: PUSH
102146: LD_OWVAR 2
102150: PUSH
102151: EMPTY
102152: LIST
102153: LIST
102154: PUSH
102155: LD_INT 32
102157: PUSH
102158: LD_INT 1
102160: PUSH
102161: EMPTY
102162: LIST
102163: LIST
102164: PUSH
102165: LD_INT 21
102167: PUSH
102168: LD_INT 2
102170: PUSH
102171: EMPTY
102172: LIST
102173: LIST
102174: PUSH
102175: EMPTY
102176: LIST
102177: LIST
102178: LIST
102179: PPUSH
102180: CALL_OW 69
102184: ST_TO_ADDR
// if not tmp then
102185: LD_VAR 0 2
102189: NOT
102190: IFFALSE 102194
// exit ;
102192: GO 102223
// for i in tmp do
102194: LD_ADDR_VAR 0 1
102198: PUSH
102199: LD_VAR 0 2
102203: PUSH
102204: FOR_IN
102205: IFFALSE 102221
// SetFuel ( i , 0 ) ;
102207: LD_VAR 0 1
102211: PPUSH
102212: LD_INT 0
102214: PPUSH
102215: CALL_OW 240
102219: GO 102204
102221: POP
102222: POP
// end ;
102223: PPOPN 2
102225: END
// every 0 0$1 trigger StreamModeActive and sOilTower do var tmp ;
102226: LD_EXP 122
102230: PUSH
102231: LD_EXP 158
102235: AND
102236: IFFALSE 102302
102238: GO 102240
102240: DISABLE
102241: LD_INT 0
102243: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_btype , b_oil_mine ] ] ) ;
102244: LD_ADDR_VAR 0 1
102248: PUSH
102249: LD_INT 22
102251: PUSH
102252: LD_OWVAR 2
102256: PUSH
102257: EMPTY
102258: LIST
102259: LIST
102260: PUSH
102261: LD_INT 30
102263: PUSH
102264: LD_INT 29
102266: PUSH
102267: EMPTY
102268: LIST
102269: LIST
102270: PUSH
102271: EMPTY
102272: LIST
102273: LIST
102274: PPUSH
102275: CALL_OW 69
102279: ST_TO_ADDR
// if not tmp then
102280: LD_VAR 0 1
102284: NOT
102285: IFFALSE 102289
// exit ;
102287: GO 102302
// DestroyUnit ( tmp [ 1 ] ) ;
102289: LD_VAR 0 1
102293: PUSH
102294: LD_INT 1
102296: ARRAY
102297: PPUSH
102298: CALL_OW 65
// end ;
102302: PPOPN 1
102304: END
// every 0 0$1 trigger StreamModeActive and sSheik do var un ;
102305: LD_EXP 122
102309: PUSH
102310: LD_EXP 160
102314: AND
102315: IFFALSE 102444
102317: GO 102319
102319: DISABLE
102320: LD_INT 0
102322: PPUSH
// begin uc_side := 0 ;
102323: LD_ADDR_OWVAR 20
102327: PUSH
102328: LD_INT 0
102330: ST_TO_ADDR
// uc_nation := nation_arabian ;
102331: LD_ADDR_OWVAR 21
102335: PUSH
102336: LD_INT 2
102338: ST_TO_ADDR
// hc_gallery :=  ;
102339: LD_ADDR_OWVAR 33
102343: PUSH
102344: LD_STRING 
102346: ST_TO_ADDR
// hc_name :=  ;
102347: LD_ADDR_OWVAR 26
102351: PUSH
102352: LD_STRING 
102354: ST_TO_ADDR
// PrepareHuman ( sex_male , class_desert_warior , 10 ) ;
102355: LD_INT 1
102357: PPUSH
102358: LD_INT 11
102360: PPUSH
102361: LD_INT 10
102363: PPUSH
102364: CALL_OW 380
// un := CreateHuman ;
102368: LD_ADDR_VAR 0 1
102372: PUSH
102373: CALL_OW 44
102377: ST_TO_ADDR
// PlaceUnitAnywhere ( un , true ) ;
102378: LD_VAR 0 1
102382: PPUSH
102383: LD_INT 1
102385: PPUSH
102386: CALL_OW 51
// repeat wait ( 0 0$1 ) ;
102390: LD_INT 35
102392: PPUSH
102393: CALL_OW 67
// ComAttackUnit ( un , NearestUnitToUnit ( FilterAllUnits ( [ f_side , your_side ] ) , un ) ) ;
102397: LD_VAR 0 1
102401: PPUSH
102402: LD_INT 22
102404: PUSH
102405: LD_OWVAR 2
102409: PUSH
102410: EMPTY
102411: LIST
102412: LIST
102413: PPUSH
102414: CALL_OW 69
102418: PPUSH
102419: LD_VAR 0 1
102423: PPUSH
102424: CALL_OW 74
102428: PPUSH
102429: CALL_OW 115
// until IsDead ( un ) ;
102433: LD_VAR 0 1
102437: PPUSH
102438: CALL_OW 301
102442: IFFALSE 102390
// end ;
102444: PPOPN 1
102446: END
// every 0 0$1 trigger StreamModeActive and sEarthquake do
102447: LD_EXP 122
102451: PUSH
102452: LD_EXP 162
102456: AND
102457: IFFALSE 102469
102459: GO 102461
102461: DISABLE
// ToLua ( earthquake(getX(game), 0, 32) ) ;
102462: LD_STRING earthquake(getX(game), 0, 32)
102464: PPUSH
102465: CALL_OW 559
102469: END
// every 0 0$1 trigger StreamModeActive and sAI do var tmp ;
102470: LD_EXP 122
102474: PUSH
102475: LD_EXP 163
102479: AND
102480: IFFALSE 102571
102482: GO 102484
102484: DISABLE
102485: LD_INT 0
102487: PPUSH
// begin enable ;
102488: ENABLE
// tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_type , unit_vehicle ] , [ f_control , control_computer ] ] ) ;
102489: LD_ADDR_VAR 0 1
102493: PUSH
102494: LD_INT 22
102496: PUSH
102497: LD_OWVAR 2
102501: PUSH
102502: EMPTY
102503: LIST
102504: LIST
102505: PUSH
102506: LD_INT 21
102508: PUSH
102509: LD_INT 2
102511: PUSH
102512: EMPTY
102513: LIST
102514: LIST
102515: PUSH
102516: LD_INT 33
102518: PUSH
102519: LD_INT 3
102521: PUSH
102522: EMPTY
102523: LIST
102524: LIST
102525: PUSH
102526: EMPTY
102527: LIST
102528: LIST
102529: LIST
102530: PPUSH
102531: CALL_OW 69
102535: ST_TO_ADDR
// if not tmp then
102536: LD_VAR 0 1
102540: NOT
102541: IFFALSE 102545
// exit ;
102543: GO 102571
// SetLives ( tmp [ rand ( 1 , tmp ) ] , 1 ) ;
102545: LD_VAR 0 1
102549: PUSH
102550: LD_INT 1
102552: PPUSH
102553: LD_VAR 0 1
102557: PPUSH
102558: CALL_OW 12
102562: ARRAY
102563: PPUSH
102564: LD_INT 1
102566: PPUSH
102567: CALL_OW 234
// end ;
102571: PPOPN 1
102573: END
// every 0 0$1 trigger StreamModeActive and sBazooka do var i , un , tmp ;
102574: LD_EXP 122
102578: PUSH
102579: LD_EXP 164
102583: AND
102584: IFFALSE 102725
102586: GO 102588
102588: DISABLE
102589: LD_INT 0
102591: PPUSH
102592: PPUSH
102593: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_class , 1 ] ] ) ;
102594: LD_ADDR_VAR 0 3
102598: PUSH
102599: LD_INT 22
102601: PUSH
102602: LD_OWVAR 2
102606: PUSH
102607: EMPTY
102608: LIST
102609: LIST
102610: PUSH
102611: LD_INT 25
102613: PUSH
102614: LD_INT 1
102616: PUSH
102617: EMPTY
102618: LIST
102619: LIST
102620: PUSH
102621: EMPTY
102622: LIST
102623: LIST
102624: PPUSH
102625: CALL_OW 69
102629: ST_TO_ADDR
// if not tmp then
102630: LD_VAR 0 3
102634: NOT
102635: IFFALSE 102639
// exit ;
102637: GO 102725
// un := tmp [ rand ( 1 , tmp ) ] ;
102639: LD_ADDR_VAR 0 2
102643: PUSH
102644: LD_VAR 0 3
102648: PUSH
102649: LD_INT 1
102651: PPUSH
102652: LD_VAR 0 3
102656: PPUSH
102657: CALL_OW 12
102661: ARRAY
102662: ST_TO_ADDR
// if Crawls ( un ) then
102663: LD_VAR 0 2
102667: PPUSH
102668: CALL_OW 318
102672: IFFALSE 102683
// ComWalk ( un ) ;
102674: LD_VAR 0 2
102678: PPUSH
102679: CALL_OW 138
// SetClass ( un , class_bazooker ) ;
102683: LD_VAR 0 2
102687: PPUSH
102688: LD_INT 9
102690: PPUSH
102691: CALL_OW 336
// SetTech ( tech_tauRad , your_side , state_researched ) ;
102695: LD_INT 28
102697: PPUSH
102698: LD_OWVAR 2
102702: PPUSH
102703: LD_INT 2
102705: PPUSH
102706: CALL_OW 322
// SetTech ( tech_spacAnom , your_side , state_researched ) ;
102710: LD_INT 29
102712: PPUSH
102713: LD_OWVAR 2
102717: PPUSH
102718: LD_INT 2
102720: PPUSH
102721: CALL_OW 322
// end ;
102725: PPOPN 3
102727: END
// every 0 0$1 trigger StreamModeActive and sMortar do var i , un , tmp ;
102728: LD_EXP 122
102732: PUSH
102733: LD_EXP 165
102737: AND
102738: IFFALSE 102849
102740: GO 102742
102742: DISABLE
102743: LD_INT 0
102745: PPUSH
102746: PPUSH
102747: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_class , 1 ] ] ) ;
102748: LD_ADDR_VAR 0 3
102752: PUSH
102753: LD_INT 22
102755: PUSH
102756: LD_OWVAR 2
102760: PUSH
102761: EMPTY
102762: LIST
102763: LIST
102764: PUSH
102765: LD_INT 25
102767: PUSH
102768: LD_INT 1
102770: PUSH
102771: EMPTY
102772: LIST
102773: LIST
102774: PUSH
102775: EMPTY
102776: LIST
102777: LIST
102778: PPUSH
102779: CALL_OW 69
102783: ST_TO_ADDR
// if not tmp then
102784: LD_VAR 0 3
102788: NOT
102789: IFFALSE 102793
// exit ;
102791: GO 102849
// un := tmp [ rand ( 1 , tmp ) ] ;
102793: LD_ADDR_VAR 0 2
102797: PUSH
102798: LD_VAR 0 3
102802: PUSH
102803: LD_INT 1
102805: PPUSH
102806: LD_VAR 0 3
102810: PPUSH
102811: CALL_OW 12
102815: ARRAY
102816: ST_TO_ADDR
// if Crawls ( un ) then
102817: LD_VAR 0 2
102821: PPUSH
102822: CALL_OW 318
102826: IFFALSE 102837
// ComWalk ( un ) ;
102828: LD_VAR 0 2
102832: PPUSH
102833: CALL_OW 138
// SetClass ( un , class_mortar ) ;
102837: LD_VAR 0 2
102841: PPUSH
102842: LD_INT 8
102844: PPUSH
102845: CALL_OW 336
// end ;
102849: PPOPN 3
102851: END
// every 0 0$1 trigger StreamModeActive and sCargo do var i , tmp ;
102852: LD_EXP 122
102856: PUSH
102857: LD_EXP 166
102861: AND
102862: IFFALSE 103006
102864: GO 102866
102866: DISABLE
102867: LD_INT 0
102869: PPUSH
102870: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_type , unit_vehicle ] , [ f_or , [ f_weapon , us_cargo_bay ] , [ f_weapon , ru_cargo_bay ] , [ f_weapon , ar_cargo_bay ] ] ] ) ;
102871: LD_ADDR_VAR 0 2
102875: PUSH
102876: LD_INT 22
102878: PUSH
102879: LD_OWVAR 2
102883: PUSH
102884: EMPTY
102885: LIST
102886: LIST
102887: PUSH
102888: LD_INT 21
102890: PUSH
102891: LD_INT 2
102893: PUSH
102894: EMPTY
102895: LIST
102896: LIST
102897: PUSH
102898: LD_INT 2
102900: PUSH
102901: LD_INT 34
102903: PUSH
102904: LD_INT 12
102906: PUSH
102907: EMPTY
102908: LIST
102909: LIST
102910: PUSH
102911: LD_INT 34
102913: PUSH
102914: LD_INT 51
102916: PUSH
102917: EMPTY
102918: LIST
102919: LIST
102920: PUSH
102921: LD_INT 34
102923: PUSH
102924: LD_INT 32
102926: PUSH
102927: EMPTY
102928: LIST
102929: LIST
102930: PUSH
102931: EMPTY
102932: LIST
102933: LIST
102934: LIST
102935: LIST
102936: PUSH
102937: EMPTY
102938: LIST
102939: LIST
102940: LIST
102941: PPUSH
102942: CALL_OW 69
102946: ST_TO_ADDR
// if not tmp then
102947: LD_VAR 0 2
102951: NOT
102952: IFFALSE 102956
// exit ;
102954: GO 103006
// for i in tmp do
102956: LD_ADDR_VAR 0 1
102960: PUSH
102961: LD_VAR 0 2
102965: PUSH
102966: FOR_IN
102967: IFFALSE 103004
// if GetCargo ( i , mat_artifact ) = 0 then
102969: LD_VAR 0 1
102973: PPUSH
102974: LD_INT 4
102976: PPUSH
102977: CALL_OW 289
102981: PUSH
102982: LD_INT 0
102984: EQUAL
102985: IFFALSE 103002
// SetCargo ( i , mat_siberit , 100 ) ;
102987: LD_VAR 0 1
102991: PPUSH
102992: LD_INT 3
102994: PPUSH
102995: LD_INT 100
102997: PPUSH
102998: CALL_OW 290
103002: GO 102966
103004: POP
103005: POP
// end ;
103006: PPOPN 2
103008: END
// every 0 0$1 trigger StreamModeActive and sDLaser do var i , tmp ;
103009: LD_EXP 122
103013: PUSH
103014: LD_EXP 167
103018: AND
103019: IFFALSE 103172
103021: GO 103023
103023: DISABLE
103024: LD_INT 0
103026: PPUSH
103027: PPUSH
// begin tmp := FilterAllUnits ( [ f_side , your_side ] ) ;
103028: LD_ADDR_VAR 0 2
103032: PUSH
103033: LD_INT 22
103035: PUSH
103036: LD_OWVAR 2
103040: PUSH
103041: EMPTY
103042: LIST
103043: LIST
103044: PPUSH
103045: CALL_OW 69
103049: ST_TO_ADDR
// if not tmp then
103050: LD_VAR 0 2
103054: NOT
103055: IFFALSE 103059
// exit ;
103057: GO 103172
// for i := 1 to 2 do
103059: LD_ADDR_VAR 0 1
103063: PUSH
103064: DOUBLE
103065: LD_INT 1
103067: DEC
103068: ST_TO_ADDR
103069: LD_INT 2
103071: PUSH
103072: FOR_TO
103073: IFFALSE 103170
// begin uc_side := your_side ;
103075: LD_ADDR_OWVAR 20
103079: PUSH
103080: LD_OWVAR 2
103084: ST_TO_ADDR
// uc_nation := nation_american ;
103085: LD_ADDR_OWVAR 21
103089: PUSH
103090: LD_INT 1
103092: ST_TO_ADDR
// vc_chassis := us_morphling ;
103093: LD_ADDR_OWVAR 37
103097: PUSH
103098: LD_INT 5
103100: ST_TO_ADDR
// vc_engine := engine_siberite ;
103101: LD_ADDR_OWVAR 39
103105: PUSH
103106: LD_INT 3
103108: ST_TO_ADDR
// vc_control := control_computer ;
103109: LD_ADDR_OWVAR 38
103113: PUSH
103114: LD_INT 3
103116: ST_TO_ADDR
// vc_weapon := us_double_laser ;
103117: LD_ADDR_OWVAR 40
103121: PUSH
103122: LD_INT 10
103124: ST_TO_ADDR
// PlaceUnitXYR ( CreateVehicle , GetX ( tmp [ 1 ] ) , GetY ( tmp [ 1 ] ) , 12 , true ) ;
103125: CALL_OW 45
103129: PPUSH
103130: LD_VAR 0 2
103134: PUSH
103135: LD_INT 1
103137: ARRAY
103138: PPUSH
103139: CALL_OW 250
103143: PPUSH
103144: LD_VAR 0 2
103148: PUSH
103149: LD_INT 1
103151: ARRAY
103152: PPUSH
103153: CALL_OW 251
103157: PPUSH
103158: LD_INT 12
103160: PPUSH
103161: LD_INT 1
103163: PPUSH
103164: CALL_OW 50
// end ;
103168: GO 103072
103170: POP
103171: POP
// end ;
103172: PPOPN 2
103174: END
// every 0 0$1 trigger StreamModeActive and sExchange do var i , s1 , s2 , sk1 , sk2 , tmp ;
103175: LD_EXP 122
103179: PUSH
103180: LD_EXP 168
103184: AND
103185: IFFALSE 103407
103187: GO 103189
103189: DISABLE
103190: LD_INT 0
103192: PPUSH
103193: PPUSH
103194: PPUSH
103195: PPUSH
103196: PPUSH
103197: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_type , unit_human ] , [ f_not , [ f_nation , 0 ] ] ] ) ;
103198: LD_ADDR_VAR 0 6
103202: PUSH
103203: LD_INT 22
103205: PUSH
103206: LD_OWVAR 2
103210: PUSH
103211: EMPTY
103212: LIST
103213: LIST
103214: PUSH
103215: LD_INT 21
103217: PUSH
103218: LD_INT 1
103220: PUSH
103221: EMPTY
103222: LIST
103223: LIST
103224: PUSH
103225: LD_INT 3
103227: PUSH
103228: LD_INT 23
103230: PUSH
103231: LD_INT 0
103233: PUSH
103234: EMPTY
103235: LIST
103236: LIST
103237: PUSH
103238: EMPTY
103239: LIST
103240: LIST
103241: PUSH
103242: EMPTY
103243: LIST
103244: LIST
103245: LIST
103246: PPUSH
103247: CALL_OW 69
103251: ST_TO_ADDR
// if not tmp then
103252: LD_VAR 0 6
103256: NOT
103257: IFFALSE 103261
// exit ;
103259: GO 103407
// s1 := rand ( 1 , 4 ) ;
103261: LD_ADDR_VAR 0 2
103265: PUSH
103266: LD_INT 1
103268: PPUSH
103269: LD_INT 4
103271: PPUSH
103272: CALL_OW 12
103276: ST_TO_ADDR
// sk1 := GetSkill ( tmp [ 1 ] , s1 ) ;
103277: LD_ADDR_VAR 0 4
103281: PUSH
103282: LD_VAR 0 6
103286: PUSH
103287: LD_INT 1
103289: ARRAY
103290: PPUSH
103291: LD_VAR 0 2
103295: PPUSH
103296: CALL_OW 259
103300: ST_TO_ADDR
// if s1 = 1 then
103301: LD_VAR 0 2
103305: PUSH
103306: LD_INT 1
103308: EQUAL
103309: IFFALSE 103329
// s2 := rand ( 2 , 4 ) else
103311: LD_ADDR_VAR 0 3
103315: PUSH
103316: LD_INT 2
103318: PPUSH
103319: LD_INT 4
103321: PPUSH
103322: CALL_OW 12
103326: ST_TO_ADDR
103327: GO 103337
// s2 := 1 ;
103329: LD_ADDR_VAR 0 3
103333: PUSH
103334: LD_INT 1
103336: ST_TO_ADDR
// sk2 := GetSkill ( tmp [ 1 ] , s2 ) ;
103337: LD_ADDR_VAR 0 5
103341: PUSH
103342: LD_VAR 0 6
103346: PUSH
103347: LD_INT 1
103349: ARRAY
103350: PPUSH
103351: LD_VAR 0 3
103355: PPUSH
103356: CALL_OW 259
103360: ST_TO_ADDR
// SetSkill ( tmp [ 1 ] , s1 , sk2 ) ;
103361: LD_VAR 0 6
103365: PUSH
103366: LD_INT 1
103368: ARRAY
103369: PPUSH
103370: LD_VAR 0 2
103374: PPUSH
103375: LD_VAR 0 5
103379: PPUSH
103380: CALL_OW 237
// SetSkill ( tmp [ 1 ] , s2 , sk1 ) ;
103384: LD_VAR 0 6
103388: PUSH
103389: LD_INT 1
103391: ARRAY
103392: PPUSH
103393: LD_VAR 0 3
103397: PPUSH
103398: LD_VAR 0 4
103402: PPUSH
103403: CALL_OW 237
// end ;
103407: PPOPN 6
103409: END
// every 0 0$1 trigger StreamModeActive and sFac do var tmp ;
103410: LD_EXP 122
103414: PUSH
103415: LD_EXP 169
103419: AND
103420: IFFALSE 103499
103422: GO 103424
103424: DISABLE
103425: LD_INT 0
103427: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_btype , b_factory ] ] ) ;
103428: LD_ADDR_VAR 0 1
103432: PUSH
103433: LD_INT 22
103435: PUSH
103436: LD_OWVAR 2
103440: PUSH
103441: EMPTY
103442: LIST
103443: LIST
103444: PUSH
103445: LD_INT 30
103447: PUSH
103448: LD_INT 3
103450: PUSH
103451: EMPTY
103452: LIST
103453: LIST
103454: PUSH
103455: EMPTY
103456: LIST
103457: LIST
103458: PPUSH
103459: CALL_OW 69
103463: ST_TO_ADDR
// if not tmp then
103464: LD_VAR 0 1
103468: NOT
103469: IFFALSE 103473
// exit ;
103471: GO 103499
// SetLives ( tmp [ rand ( 1 , tmp ) ] , 1 ) ;
103473: LD_VAR 0 1
103477: PUSH
103478: LD_INT 1
103480: PPUSH
103481: LD_VAR 0 1
103485: PPUSH
103486: CALL_OW 12
103490: ARRAY
103491: PPUSH
103492: LD_INT 1
103494: PPUSH
103495: CALL_OW 234
// end ;
103499: PPOPN 1
103501: END
// every 0 0$1 trigger StreamModeActive and sPower do var i , tmp ;
103502: LD_EXP 122
103506: PUSH
103507: LD_EXP 170
103511: AND
103512: IFFALSE 103624
103514: GO 103516
103516: DISABLE
103517: LD_INT 0
103519: PPUSH
103520: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_or , [ f_btype , b_solar_power ] , [ f_btype , b_oil_power ] , [ f_btype , b_siberite_power ] ] ] ) ;
103521: LD_ADDR_VAR 0 2
103525: PUSH
103526: LD_INT 22
103528: PUSH
103529: LD_OWVAR 2
103533: PUSH
103534: EMPTY
103535: LIST
103536: LIST
103537: PUSH
103538: LD_INT 2
103540: PUSH
103541: LD_INT 30
103543: PUSH
103544: LD_INT 27
103546: PUSH
103547: EMPTY
103548: LIST
103549: LIST
103550: PUSH
103551: LD_INT 30
103553: PUSH
103554: LD_INT 26
103556: PUSH
103557: EMPTY
103558: LIST
103559: LIST
103560: PUSH
103561: LD_INT 30
103563: PUSH
103564: LD_INT 28
103566: PUSH
103567: EMPTY
103568: LIST
103569: LIST
103570: PUSH
103571: EMPTY
103572: LIST
103573: LIST
103574: LIST
103575: LIST
103576: PUSH
103577: EMPTY
103578: LIST
103579: LIST
103580: PPUSH
103581: CALL_OW 69
103585: ST_TO_ADDR
// if not tmp then
103586: LD_VAR 0 2
103590: NOT
103591: IFFALSE 103595
// exit ;
103593: GO 103624
// for i in tmp do
103595: LD_ADDR_VAR 0 1
103599: PUSH
103600: LD_VAR 0 2
103604: PUSH
103605: FOR_IN
103606: IFFALSE 103622
// SetLives ( i , 1 ) ;
103608: LD_VAR 0 1
103612: PPUSH
103613: LD_INT 1
103615: PPUSH
103616: CALL_OW 234
103620: GO 103605
103622: POP
103623: POP
// end ;
103624: PPOPN 2
103626: END
// every 0 0$1 trigger StreamModeActive and sRandom do var i , tmp , un ;
103627: LD_EXP 122
103631: PUSH
103632: LD_EXP 171
103636: AND
103637: IFFALSE 103911
103639: GO 103641
103641: DISABLE
103642: LD_INT 0
103644: PPUSH
103645: PPUSH
103646: PPUSH
// begin i := rand ( 1 , 7 ) ;
103647: LD_ADDR_VAR 0 1
103651: PUSH
103652: LD_INT 1
103654: PPUSH
103655: LD_INT 7
103657: PPUSH
103658: CALL_OW 12
103662: ST_TO_ADDR
// case i of 1 :
103663: LD_VAR 0 1
103667: PUSH
103668: LD_INT 1
103670: DOUBLE
103671: EQUAL
103672: IFTRUE 103676
103674: GO 103686
103676: POP
// ToLua ( earthquake(getX(game), 0, 32) ) ; 2 :
103677: LD_STRING earthquake(getX(game), 0, 32)
103679: PPUSH
103680: CALL_OW 559
103684: GO 103911
103686: LD_INT 2
103688: DOUBLE
103689: EQUAL
103690: IFTRUE 103694
103692: GO 103708
103694: POP
// begin ToLua ( displayStucuk(); ) ;
103695: LD_STRING displayStucuk();
103697: PPUSH
103698: CALL_OW 559
// ResetFog ;
103702: CALL_OW 335
// end ; 3 :
103706: GO 103911
103708: LD_INT 3
103710: DOUBLE
103711: EQUAL
103712: IFTRUE 103716
103714: GO 103820
103716: POP
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_class , 1 ] ] ) ;
103717: LD_ADDR_VAR 0 2
103721: PUSH
103722: LD_INT 22
103724: PUSH
103725: LD_OWVAR 2
103729: PUSH
103730: EMPTY
103731: LIST
103732: LIST
103733: PUSH
103734: LD_INT 25
103736: PUSH
103737: LD_INT 1
103739: PUSH
103740: EMPTY
103741: LIST
103742: LIST
103743: PUSH
103744: EMPTY
103745: LIST
103746: LIST
103747: PPUSH
103748: CALL_OW 69
103752: ST_TO_ADDR
// if not tmp then
103753: LD_VAR 0 2
103757: NOT
103758: IFFALSE 103762
// exit ;
103760: GO 103911
// un := tmp [ rand ( 1 , tmp ) ] ;
103762: LD_ADDR_VAR 0 3
103766: PUSH
103767: LD_VAR 0 2
103771: PUSH
103772: LD_INT 1
103774: PPUSH
103775: LD_VAR 0 2
103779: PPUSH
103780: CALL_OW 12
103784: ARRAY
103785: ST_TO_ADDR
// if Crawls ( un ) then
103786: LD_VAR 0 3
103790: PPUSH
103791: CALL_OW 318
103795: IFFALSE 103806
// ComWalk ( un ) ;
103797: LD_VAR 0 3
103801: PPUSH
103802: CALL_OW 138
// SetClass ( un , class_mortar ) ;
103806: LD_VAR 0 3
103810: PPUSH
103811: LD_INT 8
103813: PPUSH
103814: CALL_OW 336
// end ; 4 :
103818: GO 103911
103820: LD_INT 4
103822: DOUBLE
103823: EQUAL
103824: IFTRUE 103828
103826: GO 103889
103828: POP
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_btype , b_oil_mine ] ] ) ;
103829: LD_ADDR_VAR 0 2
103833: PUSH
103834: LD_INT 22
103836: PUSH
103837: LD_OWVAR 2
103841: PUSH
103842: EMPTY
103843: LIST
103844: LIST
103845: PUSH
103846: LD_INT 30
103848: PUSH
103849: LD_INT 29
103851: PUSH
103852: EMPTY
103853: LIST
103854: LIST
103855: PUSH
103856: EMPTY
103857: LIST
103858: LIST
103859: PPUSH
103860: CALL_OW 69
103864: ST_TO_ADDR
// if not tmp then
103865: LD_VAR 0 2
103869: NOT
103870: IFFALSE 103874
// exit ;
103872: GO 103911
// DestroyUnit ( tmp [ 1 ] ) ;
103874: LD_VAR 0 2
103878: PUSH
103879: LD_INT 1
103881: ARRAY
103882: PPUSH
103883: CALL_OW 65
// end ; 5 .. 7 :
103887: GO 103911
103889: LD_INT 5
103891: DOUBLE
103892: GREATEREQUAL
103893: IFFALSE 103901
103895: LD_INT 7
103897: DOUBLE
103898: LESSEQUAL
103899: IFTRUE 103903
103901: GO 103910
103903: POP
// StreamSibBomb ; end ;
103904: CALL 100191 0 0
103908: GO 103911
103910: POP
// end ;
103911: PPOPN 3
103913: END
// every 0 0$1 trigger StreamModeActive and sShield do var i , tmp , p ;
103914: LD_EXP 122
103918: PUSH
103919: LD_EXP 172
103923: AND
103924: IFFALSE 104080
103926: GO 103928
103928: DISABLE
103929: LD_INT 0
103931: PPUSH
103932: PPUSH
103933: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_enemy , your_side ] , [ f_or , [ f_type , unit_human ] , [ f_type , unit_vehicle ] ] ] ) ;
103934: LD_ADDR_VAR 0 2
103938: PUSH
103939: LD_INT 81
103941: PUSH
103942: LD_OWVAR 2
103946: PUSH
103947: EMPTY
103948: LIST
103949: LIST
103950: PUSH
103951: LD_INT 2
103953: PUSH
103954: LD_INT 21
103956: PUSH
103957: LD_INT 1
103959: PUSH
103960: EMPTY
103961: LIST
103962: LIST
103963: PUSH
103964: LD_INT 21
103966: PUSH
103967: LD_INT 2
103969: PUSH
103970: EMPTY
103971: LIST
103972: LIST
103973: PUSH
103974: EMPTY
103975: LIST
103976: LIST
103977: LIST
103978: PUSH
103979: EMPTY
103980: LIST
103981: LIST
103982: PPUSH
103983: CALL_OW 69
103987: ST_TO_ADDR
// if not tmp then
103988: LD_VAR 0 2
103992: NOT
103993: IFFALSE 103997
// exit ;
103995: GO 104080
// p := 0 ;
103997: LD_ADDR_VAR 0 3
104001: PUSH
104002: LD_INT 0
104004: ST_TO_ADDR
// repeat wait ( 0 0$1 ) ;
104005: LD_INT 35
104007: PPUSH
104008: CALL_OW 67
// p := p + 1 ;
104012: LD_ADDR_VAR 0 3
104016: PUSH
104017: LD_VAR 0 3
104021: PUSH
104022: LD_INT 1
104024: PLUS
104025: ST_TO_ADDR
// for i in tmp do
104026: LD_ADDR_VAR 0 1
104030: PUSH
104031: LD_VAR 0 2
104035: PUSH
104036: FOR_IN
104037: IFFALSE 104068
// if GetLives ( i ) < 1000 then
104039: LD_VAR 0 1
104043: PPUSH
104044: CALL_OW 256
104048: PUSH
104049: LD_INT 1000
104051: LESS
104052: IFFALSE 104066
// SetLives ( i , 1000 ) ;
104054: LD_VAR 0 1
104058: PPUSH
104059: LD_INT 1000
104061: PPUSH
104062: CALL_OW 234
104066: GO 104036
104068: POP
104069: POP
// until p > 20 ;
104070: LD_VAR 0 3
104074: PUSH
104075: LD_INT 20
104077: GREATER
104078: IFFALSE 104005
// end ;
104080: PPOPN 3
104082: END
// every 0 0$1 trigger StreamModeActive and sTime do
104083: LD_EXP 122
104087: PUSH
104088: LD_EXP 173
104092: AND
104093: IFFALSE 104128
104095: GO 104097
104097: DISABLE
// begin SetTech ( tech_tauRad , your_side , state_researched ) ;
104098: LD_INT 28
104100: PPUSH
104101: LD_OWVAR 2
104105: PPUSH
104106: LD_INT 2
104108: PPUSH
104109: CALL_OW 322
// SetTech ( tech_tauField , your_side , state_researched ) ;
104113: LD_INT 30
104115: PPUSH
104116: LD_OWVAR 2
104120: PPUSH
104121: LD_INT 2
104123: PPUSH
104124: CALL_OW 322
// end ;
104128: END
// every 0 0$1 trigger StreamModeActive and sTools do var i , tmp ;
104129: LD_EXP 122
104133: PUSH
104134: LD_EXP 174
104138: AND
104139: IFFALSE 104260
104141: GO 104143
104143: DISABLE
104144: LD_INT 0
104146: PPUSH
104147: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_type , unit_human ] , [ f_not , [ f_nation , 0 ] ] ] ) ;
104148: LD_ADDR_VAR 0 2
104152: PUSH
104153: LD_INT 22
104155: PUSH
104156: LD_OWVAR 2
104160: PUSH
104161: EMPTY
104162: LIST
104163: LIST
104164: PUSH
104165: LD_INT 21
104167: PUSH
104168: LD_INT 1
104170: PUSH
104171: EMPTY
104172: LIST
104173: LIST
104174: PUSH
104175: LD_INT 3
104177: PUSH
104178: LD_INT 23
104180: PUSH
104181: LD_INT 0
104183: PUSH
104184: EMPTY
104185: LIST
104186: LIST
104187: PUSH
104188: EMPTY
104189: LIST
104190: LIST
104191: PUSH
104192: EMPTY
104193: LIST
104194: LIST
104195: LIST
104196: PPUSH
104197: CALL_OW 69
104201: ST_TO_ADDR
// if not tmp then
104202: LD_VAR 0 2
104206: NOT
104207: IFFALSE 104211
// exit ;
104209: GO 104260
// for i in tmp do
104211: LD_ADDR_VAR 0 1
104215: PUSH
104216: LD_VAR 0 2
104220: PUSH
104221: FOR_IN
104222: IFFALSE 104258
// begin if Crawls ( i ) then
104224: LD_VAR 0 1
104228: PPUSH
104229: CALL_OW 318
104233: IFFALSE 104244
// ComWalk ( i ) ;
104235: LD_VAR 0 1
104239: PPUSH
104240: CALL_OW 138
// SetClass ( i , 2 ) ;
104244: LD_VAR 0 1
104248: PPUSH
104249: LD_INT 2
104251: PPUSH
104252: CALL_OW 336
// end ;
104256: GO 104221
104258: POP
104259: POP
// end ;
104260: PPOPN 2
104262: END
// every 0 0$1 trigger StreamModeActive and sRanger do var i , p , un ;
104263: LD_EXP 122
104267: PUSH
104268: LD_EXP 175
104272: AND
104273: IFFALSE 104554
104275: GO 104277
104277: DISABLE
104278: LD_INT 0
104280: PPUSH
104281: PPUSH
104282: PPUSH
// begin SetAttitude ( your_side , 9 , att_friend , true ) ;
104283: LD_OWVAR 2
104287: PPUSH
104288: LD_INT 9
104290: PPUSH
104291: LD_INT 1
104293: PPUSH
104294: LD_INT 1
104296: PPUSH
104297: CALL_OW 80
// ChangeSideFog ( 9 , your_side ) ;
104301: LD_INT 9
104303: PPUSH
104304: LD_OWVAR 2
104308: PPUSH
104309: CALL_OW 343
// uc_side := 9 ;
104313: LD_ADDR_OWVAR 20
104317: PUSH
104318: LD_INT 9
104320: ST_TO_ADDR
// uc_nation := 2 ;
104321: LD_ADDR_OWVAR 21
104325: PUSH
104326: LD_INT 2
104328: ST_TO_ADDR
// hc_name := Dark Warrior ;
104329: LD_ADDR_OWVAR 26
104333: PUSH
104334: LD_STRING Dark Warrior
104336: ST_TO_ADDR
// hc_gallery :=  ;
104337: LD_ADDR_OWVAR 33
104341: PUSH
104342: LD_STRING 
104344: ST_TO_ADDR
// hc_noskilllimit := true ;
104345: LD_ADDR_OWVAR 76
104349: PUSH
104350: LD_INT 1
104352: ST_TO_ADDR
// hc_skills := [ 30 , 30 , 30 , 30 ] ;
104353: LD_ADDR_OWVAR 31
104357: PUSH
104358: LD_INT 30
104360: PUSH
104361: LD_INT 30
104363: PUSH
104364: LD_INT 30
104366: PUSH
104367: LD_INT 30
104369: PUSH
104370: EMPTY
104371: LIST
104372: LIST
104373: LIST
104374: LIST
104375: ST_TO_ADDR
// un := CreateHuman ;
104376: LD_ADDR_VAR 0 3
104380: PUSH
104381: CALL_OW 44
104385: ST_TO_ADDR
// hc_noskilllimit := false ;
104386: LD_ADDR_OWVAR 76
104390: PUSH
104391: LD_INT 0
104393: ST_TO_ADDR
// PlaceUnitAnywhere ( un , true ) ;
104394: LD_VAR 0 3
104398: PPUSH
104399: LD_INT 1
104401: PPUSH
104402: CALL_OW 51
// p := 0 ;
104406: LD_ADDR_VAR 0 2
104410: PUSH
104411: LD_INT 0
104413: ST_TO_ADDR
// repeat wait ( 0 0$1 ) ;
104414: LD_INT 35
104416: PPUSH
104417: CALL_OW 67
// p := p + 1 ;
104421: LD_ADDR_VAR 0 2
104425: PUSH
104426: LD_VAR 0 2
104430: PUSH
104431: LD_INT 1
104433: PLUS
104434: ST_TO_ADDR
// if GetLives ( un ) < 1000 then
104435: LD_VAR 0 3
104439: PPUSH
104440: CALL_OW 256
104444: PUSH
104445: LD_INT 1000
104447: LESS
104448: IFFALSE 104462
// SetLives ( un , 1000 ) ;
104450: LD_VAR 0 3
104454: PPUSH
104455: LD_INT 1000
104457: PPUSH
104458: CALL_OW 234
// ComAttackUnit ( un , NearestUnitToUnit ( FilterAllUnits ( [ [ f_enemy , your_side ] , [ f_dist , un , 30 ] ] ) , un ) ) ;
104462: LD_VAR 0 3
104466: PPUSH
104467: LD_INT 81
104469: PUSH
104470: LD_OWVAR 2
104474: PUSH
104475: EMPTY
104476: LIST
104477: LIST
104478: PUSH
104479: LD_INT 91
104481: PUSH
104482: LD_VAR 0 3
104486: PUSH
104487: LD_INT 30
104489: PUSH
104490: EMPTY
104491: LIST
104492: LIST
104493: LIST
104494: PUSH
104495: EMPTY
104496: LIST
104497: LIST
104498: PPUSH
104499: CALL_OW 69
104503: PPUSH
104504: LD_VAR 0 3
104508: PPUSH
104509: CALL_OW 74
104513: PPUSH
104514: CALL_OW 115
// until p > 60 or IsDead ( un ) ;
104518: LD_VAR 0 2
104522: PUSH
104523: LD_INT 60
104525: GREATER
104526: PUSH
104527: LD_VAR 0 3
104531: PPUSH
104532: CALL_OW 301
104536: OR
104537: IFFALSE 104414
// if un then
104539: LD_VAR 0 3
104543: IFFALSE 104554
// RemoveUnit ( un ) ;
104545: LD_VAR 0 3
104549: PPUSH
104550: CALL_OW 64
// end ; end_of_file
104554: PPOPN 3
104556: END
// export function SOS_UnitExtraDestroyed ( un , killerSide , killerUnit ) ; var i , eff , side ; begin
104557: LD_INT 0
104559: PPUSH
104560: PPUSH
104561: PPUSH
104562: PPUSH
// if GetWeapon ( un ) = ar_bio_bomb then
104563: LD_VAR 0 1
104567: PPUSH
104568: CALL_OW 264
104572: PUSH
104573: LD_EXP 76
104577: EQUAL
104578: IFFALSE 104650
// begin if GetTech ( tech_bio3 , GetSide ( un ) ) = state_researched then
104580: LD_INT 68
104582: PPUSH
104583: LD_VAR 0 1
104587: PPUSH
104588: CALL_OW 255
104592: PPUSH
104593: CALL_OW 321
104597: PUSH
104598: LD_INT 2
104600: EQUAL
104601: IFFALSE 104613
// eff := 70 else
104603: LD_ADDR_VAR 0 6
104607: PUSH
104608: LD_INT 70
104610: ST_TO_ADDR
104611: GO 104621
// eff := 30 ;
104613: LD_ADDR_VAR 0 6
104617: PUSH
104618: LD_INT 30
104620: ST_TO_ADDR
// ArtContamination ( GetX ( un ) , GetY ( un ) , eff ) ;
104621: LD_VAR 0 1
104625: PPUSH
104626: CALL_OW 250
104630: PPUSH
104631: LD_VAR 0 1
104635: PPUSH
104636: CALL_OW 251
104640: PPUSH
104641: LD_VAR 0 6
104645: PPUSH
104646: CALL_OW 495
// end ; end ;
104650: LD_VAR 0 4
104654: RET
// export function SOS_Command ( cmd ) ; var i , j , tmp , taskList , _taskList ; begin
104655: LD_INT 0
104657: PPUSH
104658: PPUSH
104659: PPUSH
104660: PPUSH
104661: PPUSH
104662: PPUSH
// if cmd = 124 then
104663: LD_VAR 0 1
104667: PUSH
104668: LD_INT 124
104670: EQUAL
104671: IFFALSE 104877
// begin tmp := FilterAllUnits ( [ f_or , [ f_weapon , ru_bulldozer ] , [ f_weapon , us_bulldozer ] ] ) ;
104673: LD_ADDR_VAR 0 5
104677: PUSH
104678: LD_INT 2
104680: PUSH
104681: LD_INT 34
104683: PUSH
104684: LD_INT 53
104686: PUSH
104687: EMPTY
104688: LIST
104689: LIST
104690: PUSH
104691: LD_INT 34
104693: PUSH
104694: LD_INT 14
104696: PUSH
104697: EMPTY
104698: LIST
104699: LIST
104700: PUSH
104701: EMPTY
104702: LIST
104703: LIST
104704: LIST
104705: PPUSH
104706: CALL_OW 69
104710: ST_TO_ADDR
// if not tmp then
104711: LD_VAR 0 5
104715: NOT
104716: IFFALSE 104720
// exit ;
104718: GO 104877
// for i in tmp do
104720: LD_ADDR_VAR 0 3
104724: PUSH
104725: LD_VAR 0 5
104729: PUSH
104730: FOR_IN
104731: IFFALSE 104875
// begin taskList := GetTaskList ( i ) ;
104733: LD_ADDR_VAR 0 6
104737: PUSH
104738: LD_VAR 0 3
104742: PPUSH
104743: CALL_OW 437
104747: ST_TO_ADDR
// if not taskList then
104748: LD_VAR 0 6
104752: NOT
104753: IFFALSE 104757
// continue ;
104755: GO 104730
// for j = 1 to taskList do
104757: LD_ADDR_VAR 0 4
104761: PUSH
104762: DOUBLE
104763: LD_INT 1
104765: DEC
104766: ST_TO_ADDR
104767: LD_VAR 0 6
104771: PUSH
104772: FOR_TO
104773: IFFALSE 104871
// if taskList [ j ] [ 1 ] = | then
104775: LD_VAR 0 6
104779: PUSH
104780: LD_VAR 0 4
104784: ARRAY
104785: PUSH
104786: LD_INT 1
104788: ARRAY
104789: PUSH
104790: LD_STRING |
104792: EQUAL
104793: IFFALSE 104869
// begin _taskList := Delete ( taskList , 1 ) ;
104795: LD_ADDR_VAR 0 7
104799: PUSH
104800: LD_VAR 0 6
104804: PPUSH
104805: LD_INT 1
104807: PPUSH
104808: CALL_OW 3
104812: ST_TO_ADDR
// SetTaskList ( i , _taskList ) ;
104813: LD_VAR 0 3
104817: PPUSH
104818: LD_VAR 0 7
104822: PPUSH
104823: CALL_OW 446
// CutTreeXYR ( i , taskList [ j ] [ 2 ] , taskList [ j ] [ 3 ] , 8 ) ;
104827: LD_VAR 0 3
104831: PPUSH
104832: LD_VAR 0 6
104836: PUSH
104837: LD_VAR 0 4
104841: ARRAY
104842: PUSH
104843: LD_INT 2
104845: ARRAY
104846: PPUSH
104847: LD_VAR 0 6
104851: PUSH
104852: LD_VAR 0 4
104856: ARRAY
104857: PUSH
104858: LD_INT 3
104860: ARRAY
104861: PPUSH
104862: LD_INT 8
104864: PPUSH
104865: CALL 104882 0 4
// end ;
104869: GO 104772
104871: POP
104872: POP
// end ;
104873: GO 104730
104875: POP
104876: POP
// end ; end ;
104877: LD_VAR 0 2
104881: RET
// function CutTreeXYR ( bulldozer , x , y , r ) ; var i , min_x , min_y , max_x , max_y , _x , _y , list ; begin
104882: LD_INT 0
104884: PPUSH
104885: PPUSH
104886: PPUSH
104887: PPUSH
104888: PPUSH
104889: PPUSH
104890: PPUSH
104891: PPUSH
104892: PPUSH
// if not bulldozer or not ValidHex ( x , y ) or not r then
104893: LD_VAR 0 1
104897: NOT
104898: PUSH
104899: LD_VAR 0 2
104903: PPUSH
104904: LD_VAR 0 3
104908: PPUSH
104909: CALL_OW 488
104913: NOT
104914: OR
104915: PUSH
104916: LD_VAR 0 4
104920: NOT
104921: OR
104922: IFFALSE 104926
// exit ;
104924: GO 105266
// list := [ ] ;
104926: LD_ADDR_VAR 0 13
104930: PUSH
104931: EMPTY
104932: ST_TO_ADDR
// if x - r < 0 then
104933: LD_VAR 0 2
104937: PUSH
104938: LD_VAR 0 4
104942: MINUS
104943: PUSH
104944: LD_INT 0
104946: LESS
104947: IFFALSE 104959
// min_x := 0 else
104949: LD_ADDR_VAR 0 7
104953: PUSH
104954: LD_INT 0
104956: ST_TO_ADDR
104957: GO 104975
// min_x := x - r ;
104959: LD_ADDR_VAR 0 7
104963: PUSH
104964: LD_VAR 0 2
104968: PUSH
104969: LD_VAR 0 4
104973: MINUS
104974: ST_TO_ADDR
// if y - r < 0 then
104975: LD_VAR 0 3
104979: PUSH
104980: LD_VAR 0 4
104984: MINUS
104985: PUSH
104986: LD_INT 0
104988: LESS
104989: IFFALSE 105001
// min_y := 0 else
104991: LD_ADDR_VAR 0 8
104995: PUSH
104996: LD_INT 0
104998: ST_TO_ADDR
104999: GO 105017
// min_y := y - r ;
105001: LD_ADDR_VAR 0 8
105005: PUSH
105006: LD_VAR 0 3
105010: PUSH
105011: LD_VAR 0 4
105015: MINUS
105016: ST_TO_ADDR
// max_x := x + r ;
105017: LD_ADDR_VAR 0 9
105021: PUSH
105022: LD_VAR 0 2
105026: PUSH
105027: LD_VAR 0 4
105031: PLUS
105032: ST_TO_ADDR
// max_y := y + r ;
105033: LD_ADDR_VAR 0 10
105037: PUSH
105038: LD_VAR 0 3
105042: PUSH
105043: LD_VAR 0 4
105047: PLUS
105048: ST_TO_ADDR
// for _x = min_x to max_x do
105049: LD_ADDR_VAR 0 11
105053: PUSH
105054: DOUBLE
105055: LD_VAR 0 7
105059: DEC
105060: ST_TO_ADDR
105061: LD_VAR 0 9
105065: PUSH
105066: FOR_TO
105067: IFFALSE 105184
// for _y = min_y to max_y do
105069: LD_ADDR_VAR 0 12
105073: PUSH
105074: DOUBLE
105075: LD_VAR 0 8
105079: DEC
105080: ST_TO_ADDR
105081: LD_VAR 0 10
105085: PUSH
105086: FOR_TO
105087: IFFALSE 105180
// begin if not ValidHex ( _x , _y ) then
105089: LD_VAR 0 11
105093: PPUSH
105094: LD_VAR 0 12
105098: PPUSH
105099: CALL_OW 488
105103: NOT
105104: IFFALSE 105108
// continue ;
105106: GO 105086
// if IsEnvironment ( _x , _y ) and IsEnvironmentDestroyable ( _x , _y ) then
105108: LD_VAR 0 11
105112: PPUSH
105113: LD_VAR 0 12
105117: PPUSH
105118: CALL_OW 351
105122: PUSH
105123: LD_VAR 0 11
105127: PPUSH
105128: LD_VAR 0 12
105132: PPUSH
105133: CALL_OW 554
105137: AND
105138: IFFALSE 105178
// list := Insert ( list , list + 1 , [ _x , _y ] ) ;
105140: LD_ADDR_VAR 0 13
105144: PUSH
105145: LD_VAR 0 13
105149: PPUSH
105150: LD_VAR 0 13
105154: PUSH
105155: LD_INT 1
105157: PLUS
105158: PPUSH
105159: LD_VAR 0 11
105163: PUSH
105164: LD_VAR 0 12
105168: PUSH
105169: EMPTY
105170: LIST
105171: LIST
105172: PPUSH
105173: CALL_OW 2
105177: ST_TO_ADDR
// end ;
105178: GO 105086
105180: POP
105181: POP
105182: GO 105066
105184: POP
105185: POP
// if not list then
105186: LD_VAR 0 13
105190: NOT
105191: IFFALSE 105195
// exit ;
105193: GO 105266
// for i in list do
105195: LD_ADDR_VAR 0 6
105199: PUSH
105200: LD_VAR 0 13
105204: PUSH
105205: FOR_IN
105206: IFFALSE 105264
// AddTaskList ( bulldozer , [ [ M , i [ 1 ] , i [ 2 ] , 0 , 0 , 0 , 0 ] ] ) ;
105208: LD_VAR 0 1
105212: PPUSH
105213: LD_STRING M
105215: PUSH
105216: LD_VAR 0 6
105220: PUSH
105221: LD_INT 1
105223: ARRAY
105224: PUSH
105225: LD_VAR 0 6
105229: PUSH
105230: LD_INT 2
105232: ARRAY
105233: PUSH
105234: LD_INT 0
105236: PUSH
105237: LD_INT 0
105239: PUSH
105240: LD_INT 0
105242: PUSH
105243: LD_INT 0
105245: PUSH
105246: EMPTY
105247: LIST
105248: LIST
105249: LIST
105250: LIST
105251: LIST
105252: LIST
105253: LIST
105254: PUSH
105255: EMPTY
105256: LIST
105257: PPUSH
105258: CALL_OW 447
105262: GO 105205
105264: POP
105265: POP
// end ;
105266: LD_VAR 0 5
105270: RET
