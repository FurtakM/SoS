// starting begin ResetFog ;
   0: CALL_OW 335
// AnimateTrees ( true ) ;
   4: LD_INT 1
   6: PPUSH
   7: CALL_OW 573
// InitVariables ;
  11: CALL 69 0 0
// InitMacro ;
  15: CALL 20467 0 0
// InitNature ;
  19: CALL 17104 0 0
// InitArtifact ;
  23: CALL 17717 0 0
// if debug then
  27: LD_EXP 1
  31: IFFALSE 40
// FogOff ( 1 ) ;
  33: LD_INT 1
  35: PPUSH
  36: CALL_OW 344
// PrepareAmerican ;
  40: CALL 4555 0 0
// PrepareAlliance ;
  44: CALL 1351 0 0
// PrepareArabian ;
  48: CALL 6323 0 0
// PrepareRussian ;
  52: CALL 8308 0 0
// PrepareLegion ;
  56: CALL 6751 0 0
// Action ;
  60: CALL 10861 0 0
// MC_Start ( ) ;
  64: CALL 22579 0 0
// end ;
  68: END
// export debug ; export russianDestroyed , legionDestroyed , americanDestroyed , arabianDestroyed ; export artifactArCaptured , alienSpotted , spawnOmar ; export artifactIResearched , artifactIIResearched , artifactIIIResearched ; export vehicleLostCounter , artifactDestroyCounter ; export function InitVariables ; begin
  69: LD_INT 0
  71: PPUSH
// debug := false ;
  72: LD_ADDR_EXP 1
  76: PUSH
  77: LD_INT 0
  79: ST_TO_ADDR
// artifactArCaptured := LoadVariable ( 11_artifact_captured , 0 ) ;
  80: LD_ADDR_EXP 6
  84: PUSH
  85: LD_STRING 11_artifact_captured
  87: PPUSH
  88: LD_INT 0
  90: PPUSH
  91: CALL_OW 30
  95: ST_TO_ADDR
// russianDestroyed := false ;
  96: LD_ADDR_EXP 2
 100: PUSH
 101: LD_INT 0
 103: ST_TO_ADDR
// legionDestroyed := false ;
 104: LD_ADDR_EXP 3
 108: PUSH
 109: LD_INT 0
 111: ST_TO_ADDR
// americanDestroyed := false ;
 112: LD_ADDR_EXP 4
 116: PUSH
 117: LD_INT 0
 119: ST_TO_ADDR
// arabianDestroyed := false ;
 120: LD_ADDR_EXP 5
 124: PUSH
 125: LD_INT 0
 127: ST_TO_ADDR
// artifactIResearched := false ;
 128: LD_ADDR_EXP 9
 132: PUSH
 133: LD_INT 0
 135: ST_TO_ADDR
// artifactIIResearched := false ;
 136: LD_ADDR_EXP 10
 140: PUSH
 141: LD_INT 0
 143: ST_TO_ADDR
// artifactIIIResearched := false ;
 144: LD_ADDR_EXP 11
 148: PUSH
 149: LD_INT 0
 151: ST_TO_ADDR
// alienSpotted := false ;
 152: LD_ADDR_EXP 7
 156: PUSH
 157: LD_INT 0
 159: ST_TO_ADDR
// spawnOmar := false ;
 160: LD_ADDR_EXP 8
 164: PUSH
 165: LD_INT 0
 167: ST_TO_ADDR
// vehicleLostCounter := 0 ;
 168: LD_ADDR_EXP 12
 172: PUSH
 173: LD_INT 0
 175: ST_TO_ADDR
// artifactDestroyCounter := 0 ;
 176: LD_ADDR_EXP 13
 180: PUSH
 181: LD_INT 0
 183: ST_TO_ADDR
// end ;
 184: LD_VAR 0 1
 188: RET
// export function CustomInitMacro ( ) ; begin
 189: LD_INT 0
 191: PPUSH
// mc_parking := [ arabianParkingArea , russianParkingArea , legionParkingArea , powellParking ] ;
 192: LD_ADDR_EXP 100
 196: PUSH
 197: LD_INT 26
 199: PUSH
 200: LD_INT 1
 202: PUSH
 203: LD_INT 4
 205: PUSH
 206: LD_INT 8
 208: PUSH
 209: EMPTY
 210: LIST
 211: LIST
 212: LIST
 213: LIST
 214: ST_TO_ADDR
// mc_scan_area := [ arabianBaseArea , russianBaseArea , legionBaseArea , powellBase ] ;
 215: LD_ADDR_EXP 101
 219: PUSH
 220: LD_INT 27
 222: PUSH
 223: LD_INT 2
 225: PUSH
 226: LD_INT 3
 228: PUSH
 229: LD_INT 7
 231: PUSH
 232: EMPTY
 233: LIST
 234: LIST
 235: LIST
 236: LIST
 237: ST_TO_ADDR
// MC_SetMinesField ( 1 , [ 6 , 7 , 9 ] [ Difficulty ] , arabianMinefield ) ;
 238: LD_INT 1
 240: PPUSH
 241: LD_INT 6
 243: PUSH
 244: LD_INT 7
 246: PUSH
 247: LD_INT 9
 249: PUSH
 250: EMPTY
 251: LIST
 252: LIST
 253: LIST
 254: PUSH
 255: LD_OWVAR 67
 259: ARRAY
 260: PPUSH
 261: LD_INT 28
 263: PPUSH
 264: CALL 43796 0 3
// MC_SetLabKind ( 1 , [ b_lab_weapon , b_lab_siberium , b_lab_biological , b_lab_opto ] ) ;
 268: LD_INT 1
 270: PPUSH
 271: LD_INT 10
 273: PUSH
 274: LD_INT 11
 276: PUSH
 277: LD_INT 13
 279: PUSH
 280: LD_INT 15
 282: PUSH
 283: EMPTY
 284: LIST
 285: LIST
 286: LIST
 287: LIST
 288: PPUSH
 289: CALL 44856 0 2
// MC_SetCratesArea ( 1 , [ arabianCratesArea ] ) ;
 293: LD_INT 1
 295: PPUSH
 296: LD_INT 29
 298: PUSH
 299: EMPTY
 300: LIST
 301: PPUSH
 302: CALL 44949 0 2
// mc_ape := Replace ( mc_ape , 1 , FilterAllUnits ( [ [ f_side , 2 ] , [ f_class , class_apeman_soldier ] ] ) ) ;
 306: LD_ADDR_EXP 105
 310: PUSH
 311: LD_EXP 105
 315: PPUSH
 316: LD_INT 1
 318: PPUSH
 319: LD_INT 22
 321: PUSH
 322: LD_INT 2
 324: PUSH
 325: EMPTY
 326: LIST
 327: LIST
 328: PUSH
 329: LD_INT 25
 331: PUSH
 332: LD_INT 15
 334: PUSH
 335: EMPTY
 336: LIST
 337: LIST
 338: PUSH
 339: EMPTY
 340: LIST
 341: LIST
 342: PPUSH
 343: CALL_OW 69
 347: PPUSH
 348: CALL_OW 1
 352: ST_TO_ADDR
// MC_SetProduceList ( 1 , [ [ ar_medium_trike , engine_solar , control_manual , ar_control_tower ] , [ ar_medium_trike , engine_solar , control_manual , ar_control_tower ] , [ ar_medium_trike , engine_combustion , control_manual , ar_rocket_launcher ] , [ ar_medium_trike , engine_combustion , control_manual , ar_rocket_launcher ] , [ ar_medium_trike , engine_combustion , control_manual , ar_rocket_launcher ] , [ ar_medium_trike , engine_combustion , control_manual , ar_rocket_launcher ] ] ) ;
 353: LD_INT 1
 355: PPUSH
 356: LD_INT 13
 358: PUSH
 359: LD_INT 2
 361: PUSH
 362: LD_INT 1
 364: PUSH
 365: LD_INT 31
 367: PUSH
 368: EMPTY
 369: LIST
 370: LIST
 371: LIST
 372: LIST
 373: PUSH
 374: LD_INT 13
 376: PUSH
 377: LD_INT 2
 379: PUSH
 380: LD_INT 1
 382: PUSH
 383: LD_INT 31
 385: PUSH
 386: EMPTY
 387: LIST
 388: LIST
 389: LIST
 390: LIST
 391: PUSH
 392: LD_INT 13
 394: PUSH
 395: LD_INT 1
 397: PUSH
 398: LD_INT 1
 400: PUSH
 401: LD_INT 28
 403: PUSH
 404: EMPTY
 405: LIST
 406: LIST
 407: LIST
 408: LIST
 409: PUSH
 410: LD_INT 13
 412: PUSH
 413: LD_INT 1
 415: PUSH
 416: LD_INT 1
 418: PUSH
 419: LD_INT 28
 421: PUSH
 422: EMPTY
 423: LIST
 424: LIST
 425: LIST
 426: LIST
 427: PUSH
 428: LD_INT 13
 430: PUSH
 431: LD_INT 1
 433: PUSH
 434: LD_INT 1
 436: PUSH
 437: LD_INT 28
 439: PUSH
 440: EMPTY
 441: LIST
 442: LIST
 443: LIST
 444: LIST
 445: PUSH
 446: LD_INT 13
 448: PUSH
 449: LD_INT 1
 451: PUSH
 452: LD_INT 1
 454: PUSH
 455: LD_INT 28
 457: PUSH
 458: EMPTY
 459: LIST
 460: LIST
 461: LIST
 462: LIST
 463: PUSH
 464: EMPTY
 465: LIST
 466: LIST
 467: LIST
 468: LIST
 469: LIST
 470: LIST
 471: PPUSH
 472: CALL 44114 0 2
// MC_SetDefenderLimit ( 1 , 4 ) ;
 476: LD_INT 1
 478: PPUSH
 479: LD_INT 4
 481: PPUSH
 482: CALL 44299 0 2
// MC_SetLabKind ( 2 , [ b_lab_weapon , b_lab_siberium , b_lab_computer , b_lab_spacetime ] ) ;
 486: LD_INT 2
 488: PPUSH
 489: LD_INT 10
 491: PUSH
 492: LD_INT 11
 494: PUSH
 495: LD_INT 12
 497: PUSH
 498: LD_INT 14
 500: PUSH
 501: EMPTY
 502: LIST
 503: LIST
 504: LIST
 505: LIST
 506: PPUSH
 507: CALL 44856 0 2
// MC_SetCratesArea ( 2 , [ russianCratesArea ] ) ;
 511: LD_INT 2
 513: PPUSH
 514: LD_INT 14
 516: PUSH
 517: EMPTY
 518: LIST
 519: PPUSH
 520: CALL 44949 0 2
// MC_SetProduceList ( 2 , [ [ ru_medium_wheeled , engine_siberite , control_computer , ru_cargo_bay ] , [ ru_medium_tracked , engine_siberite , control_computer , ru_crane ] , [ ru_medium_tracked , engine_siberite , control_computer , ru_crane ] , [ ru_heavy_tracked , engine_siberite , control_computer , ru_rocket ] , [ ru_heavy_tracked , engine_siberite , control_computer , ru_rocket ] , [ ru_heavy_tracked , engine_siberite , control_computer , ru_rocket ] , [ ru_heavy_tracked , engine_siberite , control_computer , ru_rocket ] , [ ru_heavy_tracked , engine_siberite , control_computer , ru_rocket ] ] ) ;
 524: LD_INT 2
 526: PPUSH
 527: LD_INT 21
 529: PUSH
 530: LD_INT 3
 532: PUSH
 533: LD_INT 3
 535: PUSH
 536: LD_INT 51
 538: PUSH
 539: EMPTY
 540: LIST
 541: LIST
 542: LIST
 543: LIST
 544: PUSH
 545: LD_INT 22
 547: PUSH
 548: LD_INT 3
 550: PUSH
 551: LD_INT 3
 553: PUSH
 554: LD_INT 52
 556: PUSH
 557: EMPTY
 558: LIST
 559: LIST
 560: LIST
 561: LIST
 562: PUSH
 563: LD_INT 22
 565: PUSH
 566: LD_INT 3
 568: PUSH
 569: LD_INT 3
 571: PUSH
 572: LD_INT 52
 574: PUSH
 575: EMPTY
 576: LIST
 577: LIST
 578: LIST
 579: LIST
 580: PUSH
 581: LD_INT 24
 583: PUSH
 584: LD_INT 3
 586: PUSH
 587: LD_INT 3
 589: PUSH
 590: LD_INT 47
 592: PUSH
 593: EMPTY
 594: LIST
 595: LIST
 596: LIST
 597: LIST
 598: PUSH
 599: LD_INT 24
 601: PUSH
 602: LD_INT 3
 604: PUSH
 605: LD_INT 3
 607: PUSH
 608: LD_INT 47
 610: PUSH
 611: EMPTY
 612: LIST
 613: LIST
 614: LIST
 615: LIST
 616: PUSH
 617: LD_INT 24
 619: PUSH
 620: LD_INT 3
 622: PUSH
 623: LD_INT 3
 625: PUSH
 626: LD_INT 47
 628: PUSH
 629: EMPTY
 630: LIST
 631: LIST
 632: LIST
 633: LIST
 634: PUSH
 635: LD_INT 24
 637: PUSH
 638: LD_INT 3
 640: PUSH
 641: LD_INT 3
 643: PUSH
 644: LD_INT 47
 646: PUSH
 647: EMPTY
 648: LIST
 649: LIST
 650: LIST
 651: LIST
 652: PUSH
 653: LD_INT 24
 655: PUSH
 656: LD_INT 3
 658: PUSH
 659: LD_INT 3
 661: PUSH
 662: LD_INT 47
 664: PUSH
 665: EMPTY
 666: LIST
 667: LIST
 668: LIST
 669: LIST
 670: PUSH
 671: EMPTY
 672: LIST
 673: LIST
 674: LIST
 675: LIST
 676: LIST
 677: LIST
 678: LIST
 679: LIST
 680: PPUSH
 681: CALL 44114 0 2
// MC_SetDefenderLimit ( 2 , 5 ) ;
 685: LD_INT 2
 687: PPUSH
 688: LD_INT 5
 690: PPUSH
 691: CALL 44299 0 2
// MC_SetUpgradeBuilding ( 2 , b_depot ) ;
 695: LD_INT 2
 697: PPUSH
 698: LD_INT 0
 700: PPUSH
 701: CALL 44729 0 2
// MC_SetMinesField ( 3 , [ 10 , 12 , 15 ] [ Difficulty ] , legionMinefield ) ;
 705: LD_INT 3
 707: PPUSH
 708: LD_INT 10
 710: PUSH
 711: LD_INT 12
 713: PUSH
 714: LD_INT 15
 716: PUSH
 717: EMPTY
 718: LIST
 719: LIST
 720: LIST
 721: PUSH
 722: LD_OWVAR 67
 726: ARRAY
 727: PPUSH
 728: LD_INT 24
 730: PPUSH
 731: CALL 43796 0 3
// MC_SetLabKind ( 3 , [ b_lab_weapon , b_lab_siberium , b_lab_biological , b_lab_opto ] ) ;
 735: LD_INT 3
 737: PPUSH
 738: LD_INT 10
 740: PUSH
 741: LD_INT 11
 743: PUSH
 744: LD_INT 13
 746: PUSH
 747: LD_INT 15
 749: PUSH
 750: EMPTY
 751: LIST
 752: LIST
 753: LIST
 754: LIST
 755: PPUSH
 756: CALL 44856 0 2
// MC_SetCratesArea ( 3 , [ legionCratesArea ] ) ;
 760: LD_INT 3
 762: PPUSH
 763: LD_INT 13
 765: PUSH
 766: EMPTY
 767: LIST
 768: PPUSH
 769: CALL 44949 0 2
// mc_ape := Replace ( mc_ape , 3 , FilterAllUnits ( [ [ f_side , 8 ] , [ f_class , class_apeman_soldier ] ] ) ) ;
 773: LD_ADDR_EXP 105
 777: PUSH
 778: LD_EXP 105
 782: PPUSH
 783: LD_INT 3
 785: PPUSH
 786: LD_INT 22
 788: PUSH
 789: LD_INT 8
 791: PUSH
 792: EMPTY
 793: LIST
 794: LIST
 795: PUSH
 796: LD_INT 25
 798: PUSH
 799: LD_INT 15
 801: PUSH
 802: EMPTY
 803: LIST
 804: LIST
 805: PUSH
 806: EMPTY
 807: LIST
 808: LIST
 809: PPUSH
 810: CALL_OW 69
 814: PPUSH
 815: CALL_OW 1
 819: ST_TO_ADDR
// MC_SetProduceList ( 3 , [ [ ar_medium_trike , engine_solar , control_manual , ar_control_tower ] , [ ar_medium_trike , engine_solar , control_manual , ar_control_tower ] , [ ar_medium_trike , engine_siberite , control_remote , ar_cargo_bay ] , [ ar_half_tracked , engine_combustion , control_manual , ar_rocket_launcher ] , [ ar_half_tracked , engine_combustion , control_manual , ar_rocket_launcher ] , [ ar_half_tracked , engine_combustion , control_manual , ar_rocket_launcher ] , [ ar_half_tracked , engine_combustion , control_manual , ar_rocket_launcher ] ] ) ;
 820: LD_INT 3
 822: PPUSH
 823: LD_INT 13
 825: PUSH
 826: LD_INT 2
 828: PUSH
 829: LD_INT 1
 831: PUSH
 832: LD_INT 31
 834: PUSH
 835: EMPTY
 836: LIST
 837: LIST
 838: LIST
 839: LIST
 840: PUSH
 841: LD_INT 13
 843: PUSH
 844: LD_INT 2
 846: PUSH
 847: LD_INT 1
 849: PUSH
 850: LD_INT 31
 852: PUSH
 853: EMPTY
 854: LIST
 855: LIST
 856: LIST
 857: LIST
 858: PUSH
 859: LD_INT 13
 861: PUSH
 862: LD_INT 3
 864: PUSH
 865: LD_INT 2
 867: PUSH
 868: LD_INT 32
 870: PUSH
 871: EMPTY
 872: LIST
 873: LIST
 874: LIST
 875: LIST
 876: PUSH
 877: LD_INT 14
 879: PUSH
 880: LD_INT 1
 882: PUSH
 883: LD_INT 1
 885: PUSH
 886: LD_INT 28
 888: PUSH
 889: EMPTY
 890: LIST
 891: LIST
 892: LIST
 893: LIST
 894: PUSH
 895: LD_INT 14
 897: PUSH
 898: LD_INT 1
 900: PUSH
 901: LD_INT 1
 903: PUSH
 904: LD_INT 28
 906: PUSH
 907: EMPTY
 908: LIST
 909: LIST
 910: LIST
 911: LIST
 912: PUSH
 913: LD_INT 14
 915: PUSH
 916: LD_INT 1
 918: PUSH
 919: LD_INT 1
 921: PUSH
 922: LD_INT 28
 924: PUSH
 925: EMPTY
 926: LIST
 927: LIST
 928: LIST
 929: LIST
 930: PUSH
 931: LD_INT 14
 933: PUSH
 934: LD_INT 1
 936: PUSH
 937: LD_INT 1
 939: PUSH
 940: LD_INT 28
 942: PUSH
 943: EMPTY
 944: LIST
 945: LIST
 946: LIST
 947: LIST
 948: PUSH
 949: EMPTY
 950: LIST
 951: LIST
 952: LIST
 953: LIST
 954: LIST
 955: LIST
 956: LIST
 957: PPUSH
 958: CALL 44114 0 2
// MC_SetDefenderLimit ( 3 , 4 ) ;
 962: LD_INT 3
 964: PPUSH
 965: LD_INT 4
 967: PPUSH
 968: CALL 44299 0 2
// MC_SetLabKind ( 4 , [ b_lab_weapon , b_lab_computer , b_lab_siberium , b_lab_opto ] ) ;
 972: LD_INT 4
 974: PPUSH
 975: LD_INT 10
 977: PUSH
 978: LD_INT 12
 980: PUSH
 981: LD_INT 11
 983: PUSH
 984: LD_INT 15
 986: PUSH
 987: EMPTY
 988: LIST
 989: LIST
 990: LIST
 991: LIST
 992: PPUSH
 993: CALL 44856 0 2
// MC_SetCratesArea ( 4 , [ americanCratesArea ] ) ;
 997: LD_INT 4
 999: PPUSH
1000: LD_INT 33
1002: PUSH
1003: EMPTY
1004: LIST
1005: PPUSH
1006: CALL 44949 0 2
// MC_SetAllowedTurretWeapons ( 4 , [ us_double_gun , us_heavy_gun , us_rocket_launcher , us_laser , us_double_laser ] ) ;
1010: LD_INT 4
1012: PPUSH
1013: LD_INT 5
1015: PUSH
1016: LD_INT 6
1018: PUSH
1019: LD_INT 7
1021: PUSH
1022: LD_INT 9
1024: PUSH
1025: LD_INT 10
1027: PUSH
1028: EMPTY
1029: LIST
1030: LIST
1031: LIST
1032: LIST
1033: LIST
1034: PPUSH
1035: CALL 45267 0 2
// MC_SetFactoryExtension ( 4 , 54 , 85 , 2 , [ b_ext_laser , b_ext_track , b_ext_gun , b_ext_rocket , b_ext_radio ] ) ;
1039: LD_INT 4
1041: PPUSH
1042: LD_INT 54
1044: PPUSH
1045: LD_INT 85
1047: PPUSH
1048: LD_INT 2
1050: PPUSH
1051: LD_INT 25
1053: PUSH
1054: LD_INT 16
1056: PUSH
1057: LD_INT 17
1059: PUSH
1060: LD_INT 18
1062: PUSH
1063: LD_INT 22
1065: PUSH
1066: EMPTY
1067: LIST
1068: LIST
1069: LIST
1070: LIST
1071: LIST
1072: PPUSH
1073: CALL 45061 0 5
// MC_SetProduceList ( 4 , [ [ us_morphling , engine_combustion , control_manual , us_rocket_launcher ] , [ us_morphling , engine_combustion , control_manual , us_heavy_gun ] , [ us_morphling , engine_combustion , control_manual , us_rocket_launcher ] , [ us_morphling , engine_combustion , control_manual , us_heavy_gun ] , [ us_morphling , engine_combustion , control_computer , us_cargo_bay ] , [ us_medium_tracked , engine_combustion , control_computer , us_crane ] ] ) ;
1077: LD_INT 4
1079: PPUSH
1080: LD_INT 5
1082: PUSH
1083: LD_INT 1
1085: PUSH
1086: LD_INT 1
1088: PUSH
1089: LD_INT 7
1091: PUSH
1092: EMPTY
1093: LIST
1094: LIST
1095: LIST
1096: LIST
1097: PUSH
1098: LD_INT 5
1100: PUSH
1101: LD_INT 1
1103: PUSH
1104: LD_INT 1
1106: PUSH
1107: LD_INT 6
1109: PUSH
1110: EMPTY
1111: LIST
1112: LIST
1113: LIST
1114: LIST
1115: PUSH
1116: LD_INT 5
1118: PUSH
1119: LD_INT 1
1121: PUSH
1122: LD_INT 1
1124: PUSH
1125: LD_INT 7
1127: PUSH
1128: EMPTY
1129: LIST
1130: LIST
1131: LIST
1132: LIST
1133: PUSH
1134: LD_INT 5
1136: PUSH
1137: LD_INT 1
1139: PUSH
1140: LD_INT 1
1142: PUSH
1143: LD_INT 6
1145: PUSH
1146: EMPTY
1147: LIST
1148: LIST
1149: LIST
1150: LIST
1151: PUSH
1152: LD_INT 5
1154: PUSH
1155: LD_INT 1
1157: PUSH
1158: LD_INT 3
1160: PUSH
1161: LD_INT 12
1163: PUSH
1164: EMPTY
1165: LIST
1166: LIST
1167: LIST
1168: LIST
1169: PUSH
1170: LD_INT 3
1172: PUSH
1173: LD_INT 1
1175: PUSH
1176: LD_INT 3
1178: PUSH
1179: LD_INT 13
1181: PUSH
1182: EMPTY
1183: LIST
1184: LIST
1185: LIST
1186: LIST
1187: PUSH
1188: EMPTY
1189: LIST
1190: LIST
1191: LIST
1192: LIST
1193: LIST
1194: LIST
1195: PPUSH
1196: CALL 44114 0 2
// MC_SetDefenderLimit ( 4 , 4 ) ;
1200: LD_INT 4
1202: PPUSH
1203: LD_INT 4
1205: PPUSH
1206: CALL 44299 0 2
// MC_SetTame ( 4 , powellApe ) ;
1210: LD_INT 4
1212: PPUSH
1213: LD_INT 11
1215: PPUSH
1216: CALL 44680 0 2
// end ;
1220: LD_VAR 0 1
1224: RET
// every 0 0$1 trigger debug do var i ;
1225: LD_EXP 1
1229: IFFALSE 1327
1231: GO 1233
1233: DISABLE
1234: LD_INT 0
1236: PPUSH
// begin enable ;
1237: ENABLE
// for i in FilterAllUnits ( [ [ f_side , 7 ] , [ f_or , [ f_type , unit_human ] , [ f_type , unit_vehicle ] ] , [ f_not , [ f_lives , 1000 ] ] ] ) do
1238: LD_ADDR_VAR 0 1
1242: PUSH
1243: LD_INT 22
1245: PUSH
1246: LD_INT 7
1248: PUSH
1249: EMPTY
1250: LIST
1251: LIST
1252: PUSH
1253: LD_INT 2
1255: PUSH
1256: LD_INT 21
1258: PUSH
1259: LD_INT 1
1261: PUSH
1262: EMPTY
1263: LIST
1264: LIST
1265: PUSH
1266: LD_INT 21
1268: PUSH
1269: LD_INT 2
1271: PUSH
1272: EMPTY
1273: LIST
1274: LIST
1275: PUSH
1276: EMPTY
1277: LIST
1278: LIST
1279: LIST
1280: PUSH
1281: LD_INT 3
1283: PUSH
1284: LD_INT 24
1286: PUSH
1287: LD_INT 1000
1289: PUSH
1290: EMPTY
1291: LIST
1292: LIST
1293: PUSH
1294: EMPTY
1295: LIST
1296: LIST
1297: PUSH
1298: EMPTY
1299: LIST
1300: LIST
1301: LIST
1302: PPUSH
1303: CALL_OW 69
1307: PUSH
1308: FOR_IN
1309: IFFALSE 1325
// SetLives ( i , 1000 ) ;
1311: LD_VAR 0 1
1315: PPUSH
1316: LD_INT 1000
1318: PPUSH
1319: CALL_OW 234
1323: GO 1308
1325: POP
1326: POP
// end ;
1327: PPOPN 1
1329: END
// every 0 0$1 trigger artifactDestroyCounter >= 5 do
1330: LD_EXP 13
1334: PUSH
1335: LD_INT 5
1337: GREATEREQUAL
1338: IFFALSE 1350
1340: GO 1342
1342: DISABLE
// SetAchievement ( ACH_ARTIFACT ) ; end_of_file
1343: LD_STRING ACH_ARTIFACT
1345: PPUSH
1346: CALL_OW 543
1350: END
// export JMM , Roth , Lisa , Donaldson , Bobby , Cyrus , Denis , Brown , Gladstone , Houten , Cornel , Gary , Frank , Kikuchi , Simms , Joan , DeltaDoctor , Connie ; export Gossudarov , Kirilenkova , Titov , Fadeev , Dolgov , Petrosyan , Scholtze , Oblukov , Kapitsova , Lipshchin , Petrovova , Kovalyuk , Kuzmov , Karamazov ; export Burlak , Belkov , Gnyevko ; export function PrepareAlliance ; var i , veh , selected , tmp ; begin
1351: LD_INT 0
1353: PPUSH
1354: PPUSH
1355: PPUSH
1356: PPUSH
1357: PPUSH
// uc_side := 7 ;
1358: LD_ADDR_OWVAR 20
1362: PUSH
1363: LD_INT 7
1365: ST_TO_ADDR
// tmp := [ ] ;
1366: LD_ADDR_VAR 0 5
1370: PUSH
1371: EMPTY
1372: ST_TO_ADDR
// JMM := PrepareUnit ( JMM , ( not debug ) , 14a_ ) ;
1373: LD_ADDR_EXP 14
1377: PUSH
1378: LD_STRING JMM
1380: PPUSH
1381: LD_EXP 1
1385: NOT
1386: PPUSH
1387: LD_STRING 14a_
1389: PPUSH
1390: CALL 50506 0 3
1394: ST_TO_ADDR
// Burlak := PrepareUnit ( Burlak , ( not debug ) , 14a_ ) ;
1395: LD_ADDR_EXP 46
1399: PUSH
1400: LD_STRING Burlak
1402: PPUSH
1403: LD_EXP 1
1407: NOT
1408: PPUSH
1409: LD_STRING 14a_
1411: PPUSH
1412: CALL 50506 0 3
1416: ST_TO_ADDR
// Joan := PrepareUnit ( Joan , ( not debug ) , 13a_ ) ;
1417: LD_ADDR_EXP 29
1421: PUSH
1422: LD_STRING Joan
1424: PPUSH
1425: LD_EXP 1
1429: NOT
1430: PPUSH
1431: LD_STRING 13a_
1433: PPUSH
1434: CALL 50506 0 3
1438: ST_TO_ADDR
// Roth := PrepareUnit ( Roth , ( not debug ) , 13a_ ) ;
1439: LD_ADDR_EXP 15
1443: PUSH
1444: LD_STRING Roth
1446: PPUSH
1447: LD_EXP 1
1451: NOT
1452: PPUSH
1453: LD_STRING 13a_
1455: PPUSH
1456: CALL 50506 0 3
1460: ST_TO_ADDR
// Gossudarov := PrepareUnit ( Gossudarov , ( not debug ) , 13a_ ) ;
1461: LD_ADDR_EXP 32
1465: PUSH
1466: LD_STRING Gossudarov
1468: PPUSH
1469: LD_EXP 1
1473: NOT
1474: PPUSH
1475: LD_STRING 13a_
1477: PPUSH
1478: CALL 50506 0 3
1482: ST_TO_ADDR
// Denis := PrepareUnit ( Denis , ( not debug ) , 13a_ ) ;
1483: LD_ADDR_EXP 20
1487: PUSH
1488: LD_STRING Denis
1490: PPUSH
1491: LD_EXP 1
1495: NOT
1496: PPUSH
1497: LD_STRING 13a_
1499: PPUSH
1500: CALL 50506 0 3
1504: ST_TO_ADDR
// DeltaDoctor := PrepareUnit ( DeltaDoctor , ( not debug ) , 13a_ ) ;
1505: LD_ADDR_EXP 30
1509: PUSH
1510: LD_STRING DeltaDoctor
1512: PPUSH
1513: LD_EXP 1
1517: NOT
1518: PPUSH
1519: LD_STRING 13a_
1521: PPUSH
1522: CALL 50506 0 3
1526: ST_TO_ADDR
// if DeltaDoctor then
1527: LD_EXP 30
1531: IFFALSE 1549
// tmp := tmp ^ DeltaDoctor ;
1533: LD_ADDR_VAR 0 5
1537: PUSH
1538: LD_VAR 0 5
1542: PUSH
1543: LD_EXP 30
1547: ADD
1548: ST_TO_ADDR
// Simms := PrepareUnit ( Simms , ( not debug ) , 13a_ ) ;
1549: LD_ADDR_EXP 28
1553: PUSH
1554: LD_STRING Simms
1556: PPUSH
1557: LD_EXP 1
1561: NOT
1562: PPUSH
1563: LD_STRING 13a_
1565: PPUSH
1566: CALL 50506 0 3
1570: ST_TO_ADDR
// if Simms then
1571: LD_EXP 28
1575: IFFALSE 1593
// tmp := tmp ^ Simms ;
1577: LD_ADDR_VAR 0 5
1581: PUSH
1582: LD_VAR 0 5
1586: PUSH
1587: LD_EXP 28
1591: ADD
1592: ST_TO_ADDR
// Frank := PrepareUnit ( Frank , ( not debug ) , 13a_ ) ;
1593: LD_ADDR_EXP 26
1597: PUSH
1598: LD_STRING Frank
1600: PPUSH
1601: LD_EXP 1
1605: NOT
1606: PPUSH
1607: LD_STRING 13a_
1609: PPUSH
1610: CALL 50506 0 3
1614: ST_TO_ADDR
// if Frank then
1615: LD_EXP 26
1619: IFFALSE 1637
// tmp := tmp ^ Frank ;
1621: LD_ADDR_VAR 0 5
1625: PUSH
1626: LD_VAR 0 5
1630: PUSH
1631: LD_EXP 26
1635: ADD
1636: ST_TO_ADDR
// Kirilenkova := PrepareUnit ( Kirilenkova , ( not debug ) , 13a_ ) ;
1637: LD_ADDR_EXP 33
1641: PUSH
1642: LD_STRING Kirilenkova
1644: PPUSH
1645: LD_EXP 1
1649: NOT
1650: PPUSH
1651: LD_STRING 13a_
1653: PPUSH
1654: CALL 50506 0 3
1658: ST_TO_ADDR
// if Kirilenkova then
1659: LD_EXP 33
1663: IFFALSE 1681
// tmp := tmp ^ Kirilenkova ;
1665: LD_ADDR_VAR 0 5
1669: PUSH
1670: LD_VAR 0 5
1674: PUSH
1675: LD_EXP 33
1679: ADD
1680: ST_TO_ADDR
// Titov := PrepareUnit ( Titov , ( not debug ) , 13a_ ) ;
1681: LD_ADDR_EXP 34
1685: PUSH
1686: LD_STRING Titov
1688: PPUSH
1689: LD_EXP 1
1693: NOT
1694: PPUSH
1695: LD_STRING 13a_
1697: PPUSH
1698: CALL 50506 0 3
1702: ST_TO_ADDR
// if Titov then
1703: LD_EXP 34
1707: IFFALSE 1725
// tmp := tmp ^ Titov ;
1709: LD_ADDR_VAR 0 5
1713: PUSH
1714: LD_VAR 0 5
1718: PUSH
1719: LD_EXP 34
1723: ADD
1724: ST_TO_ADDR
// Fadeev := PrepareUnit ( Fadeev , ( not debug ) , 13a_ ) ;
1725: LD_ADDR_EXP 35
1729: PUSH
1730: LD_STRING Fadeev
1732: PPUSH
1733: LD_EXP 1
1737: NOT
1738: PPUSH
1739: LD_STRING 13a_
1741: PPUSH
1742: CALL 50506 0 3
1746: ST_TO_ADDR
// if Fadeev then
1747: LD_EXP 35
1751: IFFALSE 1769
// tmp := tmp ^ Fadeev ;
1753: LD_ADDR_VAR 0 5
1757: PUSH
1758: LD_VAR 0 5
1762: PUSH
1763: LD_EXP 35
1767: ADD
1768: ST_TO_ADDR
// Dolgov := PrepareUnit ( Dolgov , ( not debug ) , 13a_ ) ;
1769: LD_ADDR_EXP 36
1773: PUSH
1774: LD_STRING Dolgov
1776: PPUSH
1777: LD_EXP 1
1781: NOT
1782: PPUSH
1783: LD_STRING 13a_
1785: PPUSH
1786: CALL 50506 0 3
1790: ST_TO_ADDR
// if Dolgov then
1791: LD_EXP 36
1795: IFFALSE 1813
// tmp := tmp ^ Dolgov ;
1797: LD_ADDR_VAR 0 5
1801: PUSH
1802: LD_VAR 0 5
1806: PUSH
1807: LD_EXP 36
1811: ADD
1812: ST_TO_ADDR
// Petrosyan := PrepareUnit ( Petrosyan , ( not debug ) , 13a_ ) ;
1813: LD_ADDR_EXP 37
1817: PUSH
1818: LD_STRING Petrosyan
1820: PPUSH
1821: LD_EXP 1
1825: NOT
1826: PPUSH
1827: LD_STRING 13a_
1829: PPUSH
1830: CALL 50506 0 3
1834: ST_TO_ADDR
// if Petrosyan then
1835: LD_EXP 37
1839: IFFALSE 1857
// tmp := tmp ^ Petrosyan ;
1841: LD_ADDR_VAR 0 5
1845: PUSH
1846: LD_VAR 0 5
1850: PUSH
1851: LD_EXP 37
1855: ADD
1856: ST_TO_ADDR
// Scholtze := PrepareUnit ( Scholtze , ( not debug ) , 13a_ ) ;
1857: LD_ADDR_EXP 38
1861: PUSH
1862: LD_STRING Scholtze
1864: PPUSH
1865: LD_EXP 1
1869: NOT
1870: PPUSH
1871: LD_STRING 13a_
1873: PPUSH
1874: CALL 50506 0 3
1878: ST_TO_ADDR
// if Scholtze then
1879: LD_EXP 38
1883: IFFALSE 1901
// tmp := tmp ^ Scholtze ;
1885: LD_ADDR_VAR 0 5
1889: PUSH
1890: LD_VAR 0 5
1894: PUSH
1895: LD_EXP 38
1899: ADD
1900: ST_TO_ADDR
// Oblukov := PrepareUnit ( Oblukov , ( not debug ) , 13a_ ) ;
1901: LD_ADDR_EXP 39
1905: PUSH
1906: LD_STRING Oblukov
1908: PPUSH
1909: LD_EXP 1
1913: NOT
1914: PPUSH
1915: LD_STRING 13a_
1917: PPUSH
1918: CALL 50506 0 3
1922: ST_TO_ADDR
// if Oblukov then
1923: LD_EXP 39
1927: IFFALSE 1945
// tmp := tmp ^ Oblukov ;
1929: LD_ADDR_VAR 0 5
1933: PUSH
1934: LD_VAR 0 5
1938: PUSH
1939: LD_EXP 39
1943: ADD
1944: ST_TO_ADDR
// Kapitsova := PrepareUnit ( Kapitsova , ( not debug ) , 13a_ ) ;
1945: LD_ADDR_EXP 40
1949: PUSH
1950: LD_STRING Kapitsova
1952: PPUSH
1953: LD_EXP 1
1957: NOT
1958: PPUSH
1959: LD_STRING 13a_
1961: PPUSH
1962: CALL 50506 0 3
1966: ST_TO_ADDR
// if Kapitsova then
1967: LD_EXP 40
1971: IFFALSE 1989
// tmp := tmp ^ Kapitsova ;
1973: LD_ADDR_VAR 0 5
1977: PUSH
1978: LD_VAR 0 5
1982: PUSH
1983: LD_EXP 40
1987: ADD
1988: ST_TO_ADDR
// Lipshchin := PrepareUnit ( Lipshchin , ( not debug ) , 13a_ ) ;
1989: LD_ADDR_EXP 41
1993: PUSH
1994: LD_STRING Lipshchin
1996: PPUSH
1997: LD_EXP 1
2001: NOT
2002: PPUSH
2003: LD_STRING 13a_
2005: PPUSH
2006: CALL 50506 0 3
2010: ST_TO_ADDR
// if Lipshchin then
2011: LD_EXP 41
2015: IFFALSE 2033
// tmp := tmp ^ Lipshchin ;
2017: LD_ADDR_VAR 0 5
2021: PUSH
2022: LD_VAR 0 5
2026: PUSH
2027: LD_EXP 41
2031: ADD
2032: ST_TO_ADDR
// Petrovova := PrepareUnit ( Petrovova , ( not debug ) , 13a_ ) ;
2033: LD_ADDR_EXP 42
2037: PUSH
2038: LD_STRING Petrovova
2040: PPUSH
2041: LD_EXP 1
2045: NOT
2046: PPUSH
2047: LD_STRING 13a_
2049: PPUSH
2050: CALL 50506 0 3
2054: ST_TO_ADDR
// if Petrovova then
2055: LD_EXP 42
2059: IFFALSE 2077
// tmp := tmp ^ Petrovova ;
2061: LD_ADDR_VAR 0 5
2065: PUSH
2066: LD_VAR 0 5
2070: PUSH
2071: LD_EXP 42
2075: ADD
2076: ST_TO_ADDR
// Kovalyuk := PrepareUnit ( Kovalyuk , ( not debug ) , 13a_ ) ;
2077: LD_ADDR_EXP 43
2081: PUSH
2082: LD_STRING Kovalyuk
2084: PPUSH
2085: LD_EXP 1
2089: NOT
2090: PPUSH
2091: LD_STRING 13a_
2093: PPUSH
2094: CALL 50506 0 3
2098: ST_TO_ADDR
// if Kovalyuk then
2099: LD_EXP 43
2103: IFFALSE 2121
// tmp := tmp ^ Kovalyuk ;
2105: LD_ADDR_VAR 0 5
2109: PUSH
2110: LD_VAR 0 5
2114: PUSH
2115: LD_EXP 43
2119: ADD
2120: ST_TO_ADDR
// Kuzmov := PrepareUnit ( Kuzmov , ( not debug ) , 13a_ ) ;
2121: LD_ADDR_EXP 44
2125: PUSH
2126: LD_STRING Kuzmov
2128: PPUSH
2129: LD_EXP 1
2133: NOT
2134: PPUSH
2135: LD_STRING 13a_
2137: PPUSH
2138: CALL 50506 0 3
2142: ST_TO_ADDR
// if Kuzmov then
2143: LD_EXP 44
2147: IFFALSE 2165
// tmp := tmp ^ Kuzmov ;
2149: LD_ADDR_VAR 0 5
2153: PUSH
2154: LD_VAR 0 5
2158: PUSH
2159: LD_EXP 44
2163: ADD
2164: ST_TO_ADDR
// Karamazov := PrepareUnit ( Karamazov , ( not debug ) , 13a_ ) ;
2165: LD_ADDR_EXP 45
2169: PUSH
2170: LD_STRING Karamazov
2172: PPUSH
2173: LD_EXP 1
2177: NOT
2178: PPUSH
2179: LD_STRING 13a_
2181: PPUSH
2182: CALL 50506 0 3
2186: ST_TO_ADDR
// if Karamazov then
2187: LD_EXP 45
2191: IFFALSE 2209
// tmp := tmp ^ Karamazov ;
2193: LD_ADDR_VAR 0 5
2197: PUSH
2198: LD_VAR 0 5
2202: PUSH
2203: LD_EXP 45
2207: ADD
2208: ST_TO_ADDR
// Belkov := PrepareUnit ( Belkov , ( not debug ) , 13a_ ) ;
2209: LD_ADDR_EXP 47
2213: PUSH
2214: LD_STRING Belkov
2216: PPUSH
2217: LD_EXP 1
2221: NOT
2222: PPUSH
2223: LD_STRING 13a_
2225: PPUSH
2226: CALL 50506 0 3
2230: ST_TO_ADDR
// if Belkov then
2231: LD_EXP 47
2235: IFFALSE 2253
// tmp := tmp ^ Belkov ;
2237: LD_ADDR_VAR 0 5
2241: PUSH
2242: LD_VAR 0 5
2246: PUSH
2247: LD_EXP 47
2251: ADD
2252: ST_TO_ADDR
// Gnyevko := PrepareUnit ( Gnyevko , ( not debug ) , 13a_ ) ;
2253: LD_ADDR_EXP 48
2257: PUSH
2258: LD_STRING Gnyevko
2260: PPUSH
2261: LD_EXP 1
2265: NOT
2266: PPUSH
2267: LD_STRING 13a_
2269: PPUSH
2270: CALL 50506 0 3
2274: ST_TO_ADDR
// if Gnyevko then
2275: LD_EXP 48
2279: IFFALSE 2297
// tmp := tmp ^ Gnyevko ;
2281: LD_ADDR_VAR 0 5
2285: PUSH
2286: LD_VAR 0 5
2290: PUSH
2291: LD_EXP 48
2295: ADD
2296: ST_TO_ADDR
// Connie = NewCharacter ( Coonie ) ;
2297: LD_ADDR_EXP 31
2301: PUSH
2302: LD_STRING Coonie
2304: PPUSH
2305: CALL_OW 25
2309: ST_TO_ADDR
// if not Lisa then
2310: LD_EXP 16
2314: NOT
2315: IFFALSE 2361
// begin Lisa := PrepareUnit ( Lisa , ( not debug ) , 13a_ ) ;
2317: LD_ADDR_EXP 16
2321: PUSH
2322: LD_STRING Lisa
2324: PPUSH
2325: LD_EXP 1
2329: NOT
2330: PPUSH
2331: LD_STRING 13a_
2333: PPUSH
2334: CALL 50506 0 3
2338: ST_TO_ADDR
// if Lisa then
2339: LD_EXP 16
2343: IFFALSE 2361
// tmp := tmp ^ Lisa ;
2345: LD_ADDR_VAR 0 5
2349: PUSH
2350: LD_VAR 0 5
2354: PUSH
2355: LD_EXP 16
2359: ADD
2360: ST_TO_ADDR
// end ; if not Donaldson then
2361: LD_EXP 17
2365: NOT
2366: IFFALSE 2412
// begin Donaldson := PrepareUnit ( Donaldson , ( not debug ) , 13a_ ) ;
2368: LD_ADDR_EXP 17
2372: PUSH
2373: LD_STRING Donaldson
2375: PPUSH
2376: LD_EXP 1
2380: NOT
2381: PPUSH
2382: LD_STRING 13a_
2384: PPUSH
2385: CALL 50506 0 3
2389: ST_TO_ADDR
// if Donaldson then
2390: LD_EXP 17
2394: IFFALSE 2412
// tmp := tmp ^ Donaldson ;
2396: LD_ADDR_VAR 0 5
2400: PUSH
2401: LD_VAR 0 5
2405: PUSH
2406: LD_EXP 17
2410: ADD
2411: ST_TO_ADDR
// end ; if not Bobby then
2412: LD_EXP 18
2416: NOT
2417: IFFALSE 2463
// begin Bobby := PrepareUnit ( Bobby , ( not debug ) , 13a_ ) ;
2419: LD_ADDR_EXP 18
2423: PUSH
2424: LD_STRING Bobby
2426: PPUSH
2427: LD_EXP 1
2431: NOT
2432: PPUSH
2433: LD_STRING 13a_
2435: PPUSH
2436: CALL 50506 0 3
2440: ST_TO_ADDR
// if Bobby then
2441: LD_EXP 18
2445: IFFALSE 2463
// tmp := tmp ^ Bobby ;
2447: LD_ADDR_VAR 0 5
2451: PUSH
2452: LD_VAR 0 5
2456: PUSH
2457: LD_EXP 18
2461: ADD
2462: ST_TO_ADDR
// end ; if not Cyrus then
2463: LD_EXP 19
2467: NOT
2468: IFFALSE 2514
// begin Cyrus := PrepareUnit ( Cyrus , ( not debug ) , 13a_ ) ;
2470: LD_ADDR_EXP 19
2474: PUSH
2475: LD_STRING Cyrus
2477: PPUSH
2478: LD_EXP 1
2482: NOT
2483: PPUSH
2484: LD_STRING 13a_
2486: PPUSH
2487: CALL 50506 0 3
2491: ST_TO_ADDR
// if Cyrus then
2492: LD_EXP 19
2496: IFFALSE 2514
// tmp := tmp ^ Cyrus ;
2498: LD_ADDR_VAR 0 5
2502: PUSH
2503: LD_VAR 0 5
2507: PUSH
2508: LD_EXP 19
2512: ADD
2513: ST_TO_ADDR
// end ; if not Brown then
2514: LD_EXP 21
2518: NOT
2519: IFFALSE 2565
// begin Brown := PrepareUnit ( Brown , ( not debug ) , 13a_ ) ;
2521: LD_ADDR_EXP 21
2525: PUSH
2526: LD_STRING Brown
2528: PPUSH
2529: LD_EXP 1
2533: NOT
2534: PPUSH
2535: LD_STRING 13a_
2537: PPUSH
2538: CALL 50506 0 3
2542: ST_TO_ADDR
// if Brown then
2543: LD_EXP 21
2547: IFFALSE 2565
// tmp := tmp ^ Brown ;
2549: LD_ADDR_VAR 0 5
2553: PUSH
2554: LD_VAR 0 5
2558: PUSH
2559: LD_EXP 21
2563: ADD
2564: ST_TO_ADDR
// end ; if not Gladstone then
2565: LD_EXP 22
2569: NOT
2570: IFFALSE 2616
// begin Gladstone := PrepareUnit ( Gladstone , ( not debug ) , 13a_ ) ;
2572: LD_ADDR_EXP 22
2576: PUSH
2577: LD_STRING Gladstone
2579: PPUSH
2580: LD_EXP 1
2584: NOT
2585: PPUSH
2586: LD_STRING 13a_
2588: PPUSH
2589: CALL 50506 0 3
2593: ST_TO_ADDR
// if Gladstone then
2594: LD_EXP 22
2598: IFFALSE 2616
// tmp := tmp ^ Gladstone ;
2600: LD_ADDR_VAR 0 5
2604: PUSH
2605: LD_VAR 0 5
2609: PUSH
2610: LD_EXP 22
2614: ADD
2615: ST_TO_ADDR
// end ; if not Cornel then
2616: LD_EXP 24
2620: NOT
2621: IFFALSE 2667
// begin Cornel := PrepareUnit ( Cornel , ( not debug ) , 13a_ ) ;
2623: LD_ADDR_EXP 24
2627: PUSH
2628: LD_STRING Cornel
2630: PPUSH
2631: LD_EXP 1
2635: NOT
2636: PPUSH
2637: LD_STRING 13a_
2639: PPUSH
2640: CALL 50506 0 3
2644: ST_TO_ADDR
// if Cornel then
2645: LD_EXP 24
2649: IFFALSE 2667
// tmp := tmp ^ Cornel ;
2651: LD_ADDR_VAR 0 5
2655: PUSH
2656: LD_VAR 0 5
2660: PUSH
2661: LD_EXP 24
2665: ADD
2666: ST_TO_ADDR
// end ; if not Houten then
2667: LD_EXP 23
2671: NOT
2672: IFFALSE 2718
// begin Houten := PrepareUnit ( Houten , ( not debug ) , 13a_ ) ;
2674: LD_ADDR_EXP 23
2678: PUSH
2679: LD_STRING Houten
2681: PPUSH
2682: LD_EXP 1
2686: NOT
2687: PPUSH
2688: LD_STRING 13a_
2690: PPUSH
2691: CALL 50506 0 3
2695: ST_TO_ADDR
// if Houten then
2696: LD_EXP 23
2700: IFFALSE 2718
// tmp := tmp ^ Houten ;
2702: LD_ADDR_VAR 0 5
2706: PUSH
2707: LD_VAR 0 5
2711: PUSH
2712: LD_EXP 23
2716: ADD
2717: ST_TO_ADDR
// end ; if not Gary then
2718: LD_EXP 25
2722: NOT
2723: IFFALSE 2769
// begin Gary := PrepareUnit ( Gary , ( not debug ) , 13a_ ) ;
2725: LD_ADDR_EXP 25
2729: PUSH
2730: LD_STRING Gary
2732: PPUSH
2733: LD_EXP 1
2737: NOT
2738: PPUSH
2739: LD_STRING 13a_
2741: PPUSH
2742: CALL 50506 0 3
2746: ST_TO_ADDR
// if Gary then
2747: LD_EXP 25
2751: IFFALSE 2769
// tmp := tmp ^ Gary ;
2753: LD_ADDR_VAR 0 5
2757: PUSH
2758: LD_VAR 0 5
2762: PUSH
2763: LD_EXP 25
2767: ADD
2768: ST_TO_ADDR
// end ; if not Kikuchi then
2769: LD_EXP 27
2773: NOT
2774: IFFALSE 2820
// begin Kikuchi := PrepareUnit ( Kikuchi , ( not debug ) , 13a_ ) ;
2776: LD_ADDR_EXP 27
2780: PUSH
2781: LD_STRING Kikuchi
2783: PPUSH
2784: LD_EXP 1
2788: NOT
2789: PPUSH
2790: LD_STRING 13a_
2792: PPUSH
2793: CALL 50506 0 3
2797: ST_TO_ADDR
// if Kikuchi then
2798: LD_EXP 27
2802: IFFALSE 2820
// tmp := tmp ^ Kikuchi ;
2804: LD_ADDR_VAR 0 5
2808: PUSH
2809: LD_VAR 0 5
2813: PUSH
2814: LD_EXP 27
2818: ADD
2819: ST_TO_ADDR
// end ; tmp := tmp union CreateCharacterSet ( 13a_others ) ;
2820: LD_ADDR_VAR 0 5
2824: PUSH
2825: LD_VAR 0 5
2829: PUSH
2830: LD_STRING 13a_others
2832: PPUSH
2833: CALL_OW 31
2837: UNION
2838: ST_TO_ADDR
// tmp := tmp diff 0 ;
2839: LD_ADDR_VAR 0 5
2843: PUSH
2844: LD_VAR 0 5
2848: PUSH
2849: LD_INT 0
2851: DIFF
2852: ST_TO_ADDR
// if tmp < 15 then
2853: LD_VAR 0 5
2857: PUSH
2858: LD_INT 15
2860: LESS
2861: IFFALSE 2949
// for i = 15 downto tmp do
2863: LD_ADDR_VAR 0 2
2867: PUSH
2868: DOUBLE
2869: LD_INT 15
2871: INC
2872: ST_TO_ADDR
2873: LD_VAR 0 5
2877: PUSH
2878: FOR_DOWNTO
2879: IFFALSE 2947
// begin uc_nation := [ 1 , 3 ] [ rand ( 1 , 2 ) ] ;
2881: LD_ADDR_OWVAR 21
2885: PUSH
2886: LD_INT 1
2888: PUSH
2889: LD_INT 3
2891: PUSH
2892: EMPTY
2893: LIST
2894: LIST
2895: PUSH
2896: LD_INT 1
2898: PPUSH
2899: LD_INT 2
2901: PPUSH
2902: CALL_OW 12
2906: ARRAY
2907: ST_TO_ADDR
// PrepareHuman ( false , rand ( 1 , 4 ) , 8 ) ;
2908: LD_INT 0
2910: PPUSH
2911: LD_INT 1
2913: PPUSH
2914: LD_INT 4
2916: PPUSH
2917: CALL_OW 12
2921: PPUSH
2922: LD_INT 8
2924: PPUSH
2925: CALL_OW 380
// tmp := tmp ^ CreateHuman ;
2929: LD_ADDR_VAR 0 5
2933: PUSH
2934: LD_VAR 0 5
2938: PUSH
2939: CALL_OW 44
2943: ADD
2944: ST_TO_ADDR
// end ;
2945: GO 2878
2947: POP
2948: POP
// if not debug then
2949: LD_EXP 1
2953: NOT
2954: IFFALSE 3126
// selected = CharacterSelection (  , [ 15 , 14 , 13 ] [ Difficulty ] , [ 15 , 14 , 13 ] [ Difficulty ] , [ sel_dont_change_class , JMM , Burlak , Roth , Joan , Denis , Gossudarov , sel_not_hired , sel_changeable , sel_change_class ] ^ tmp , [ class_soldier , class_scientistic , [ class_engineer , 1 ] , class_mechanic , [ class_sniper , 0 , 3 ] , [ class_bazooker , 0 , 3 ] ] ) else
2956: LD_ADDR_VAR 0 4
2960: PUSH
2961: LD_STRING 
2963: PPUSH
2964: LD_INT 15
2966: PUSH
2967: LD_INT 14
2969: PUSH
2970: LD_INT 13
2972: PUSH
2973: EMPTY
2974: LIST
2975: LIST
2976: LIST
2977: PUSH
2978: LD_OWVAR 67
2982: ARRAY
2983: PPUSH
2984: LD_INT 15
2986: PUSH
2987: LD_INT 14
2989: PUSH
2990: LD_INT 13
2992: PUSH
2993: EMPTY
2994: LIST
2995: LIST
2996: LIST
2997: PUSH
2998: LD_OWVAR 67
3002: ARRAY
3003: PPUSH
3004: LD_INT -6
3006: PUSH
3007: LD_EXP 14
3011: PUSH
3012: LD_EXP 46
3016: PUSH
3017: LD_EXP 15
3021: PUSH
3022: LD_EXP 29
3026: PUSH
3027: LD_EXP 20
3031: PUSH
3032: LD_EXP 32
3036: PUSH
3037: LD_INT -2
3039: PUSH
3040: LD_INT -3
3042: PUSH
3043: LD_INT -5
3045: PUSH
3046: EMPTY
3047: LIST
3048: LIST
3049: LIST
3050: LIST
3051: LIST
3052: LIST
3053: LIST
3054: LIST
3055: LIST
3056: LIST
3057: PUSH
3058: LD_VAR 0 5
3062: ADD
3063: PPUSH
3064: LD_INT 1
3066: PUSH
3067: LD_INT 4
3069: PUSH
3070: LD_INT 2
3072: PUSH
3073: LD_INT 1
3075: PUSH
3076: EMPTY
3077: LIST
3078: LIST
3079: PUSH
3080: LD_INT 3
3082: PUSH
3083: LD_INT 5
3085: PUSH
3086: LD_INT 0
3088: PUSH
3089: LD_INT 3
3091: PUSH
3092: EMPTY
3093: LIST
3094: LIST
3095: LIST
3096: PUSH
3097: LD_INT 9
3099: PUSH
3100: LD_INT 0
3102: PUSH
3103: LD_INT 3
3105: PUSH
3106: EMPTY
3107: LIST
3108: LIST
3109: LIST
3110: PUSH
3111: EMPTY
3112: LIST
3113: LIST
3114: LIST
3115: LIST
3116: LIST
3117: LIST
3118: PPUSH
3119: CALL_OW 42
3123: ST_TO_ADDR
3124: GO 3205
// selected := [ Titov , Fadeev , Dolgov , Petrosyan , Scholtze , Oblukov , Kapitsova , Lipshchin , Petrovova , Kovalyuk , Kuzmov , Karamazov ] ;
3126: LD_ADDR_VAR 0 4
3130: PUSH
3131: LD_EXP 34
3135: PUSH
3136: LD_EXP 35
3140: PUSH
3141: LD_EXP 36
3145: PUSH
3146: LD_EXP 37
3150: PUSH
3151: LD_EXP 38
3155: PUSH
3156: LD_EXP 39
3160: PUSH
3161: LD_EXP 40
3165: PUSH
3166: LD_EXP 41
3170: PUSH
3171: LD_EXP 42
3175: PUSH
3176: LD_EXP 43
3180: PUSH
3181: LD_EXP 44
3185: PUSH
3186: LD_EXP 45
3190: PUSH
3191: EMPTY
3192: LIST
3193: LIST
3194: LIST
3195: LIST
3196: LIST
3197: LIST
3198: LIST
3199: LIST
3200: LIST
3201: LIST
3202: LIST
3203: LIST
3204: ST_TO_ADDR
// uc_nation := 1 ;
3205: LD_ADDR_OWVAR 21
3209: PUSH
3210: LD_INT 1
3212: ST_TO_ADDR
// PrepareVehicle ( us_morphling , engine_siberite , control_manual , us_heavy_gun , 100 ) ;
3213: LD_INT 5
3215: PPUSH
3216: LD_INT 3
3218: PPUSH
3219: LD_INT 1
3221: PPUSH
3222: LD_INT 6
3224: PPUSH
3225: LD_INT 100
3227: PPUSH
3228: CALL 57621 0 5
// veh := CreateVehicle ;
3232: LD_ADDR_VAR 0 3
3236: PUSH
3237: CALL_OW 45
3241: ST_TO_ADDR
// SetMark ( veh , - 7 ) ;
3242: LD_VAR 0 3
3246: PPUSH
3247: LD_INT 7
3249: NEG
3250: PPUSH
3251: CALL_OW 242
// SetDir ( veh , 3 ) ;
3255: LD_VAR 0 3
3259: PPUSH
3260: LD_INT 3
3262: PPUSH
3263: CALL_OW 233
// PlaceUnitArea ( veh , allianceJMMSpawnArea , false ) ;
3267: LD_VAR 0 3
3271: PPUSH
3272: LD_INT 31
3274: PPUSH
3275: LD_INT 0
3277: PPUSH
3278: CALL_OW 49
// PlaceHumanInUnit ( JMM , veh ) ;
3282: LD_EXP 14
3286: PPUSH
3287: LD_VAR 0 3
3291: PPUSH
3292: CALL_OW 52
// if Joan then
3296: LD_EXP 29
3300: IFFALSE 3372
// begin PrepareVehicle ( us_medium_tracked , engine_siberite , control_manual , us_radar , 100 ) ;
3302: LD_INT 3
3304: PPUSH
3305: LD_INT 3
3307: PPUSH
3308: LD_INT 1
3310: PPUSH
3311: LD_INT 11
3313: PPUSH
3314: LD_INT 100
3316: PPUSH
3317: CALL 57621 0 5
// veh := CreateVehicle ;
3321: LD_ADDR_VAR 0 3
3325: PUSH
3326: CALL_OW 45
3330: ST_TO_ADDR
// SetDir ( veh , 3 ) ;
3331: LD_VAR 0 3
3335: PPUSH
3336: LD_INT 3
3338: PPUSH
3339: CALL_OW 233
// PlaceUnitArea ( veh , allianceSpawnArea , false ) ;
3343: LD_VAR 0 3
3347: PPUSH
3348: LD_INT 30
3350: PPUSH
3351: LD_INT 0
3353: PPUSH
3354: CALL_OW 49
// PlaceHumanInUnit ( Joan , veh ) ;
3358: LD_EXP 29
3362: PPUSH
3363: LD_VAR 0 3
3367: PPUSH
3368: CALL_OW 52
// end ; if Roth then
3372: LD_EXP 15
3376: IFFALSE 3448
// begin PrepareVehicle ( us_medium_tracked , engine_siberite , control_manual , us_radar , 100 ) ;
3378: LD_INT 3
3380: PPUSH
3381: LD_INT 3
3383: PPUSH
3384: LD_INT 1
3386: PPUSH
3387: LD_INT 11
3389: PPUSH
3390: LD_INT 100
3392: PPUSH
3393: CALL 57621 0 5
// veh := CreateVehicle ;
3397: LD_ADDR_VAR 0 3
3401: PUSH
3402: CALL_OW 45
3406: ST_TO_ADDR
// SetDir ( veh , 3 ) ;
3407: LD_VAR 0 3
3411: PPUSH
3412: LD_INT 3
3414: PPUSH
3415: CALL_OW 233
// PlaceUnitArea ( veh , allianceSpawnArea , false ) ;
3419: LD_VAR 0 3
3423: PPUSH
3424: LD_INT 30
3426: PPUSH
3427: LD_INT 0
3429: PPUSH
3430: CALL_OW 49
// PlaceHumanInUnit ( Roth , veh ) ;
3434: LD_EXP 15
3438: PPUSH
3439: LD_VAR 0 3
3443: PPUSH
3444: CALL_OW 52
// end ; if Denis then
3448: LD_EXP 20
3452: IFFALSE 3524
// begin PrepareVehicle ( us_morphling , engine_siberite , control_manual , us_laser , 100 ) ;
3454: LD_INT 5
3456: PPUSH
3457: LD_INT 3
3459: PPUSH
3460: LD_INT 1
3462: PPUSH
3463: LD_INT 9
3465: PPUSH
3466: LD_INT 100
3468: PPUSH
3469: CALL 57621 0 5
// veh := CreateVehicle ;
3473: LD_ADDR_VAR 0 3
3477: PUSH
3478: CALL_OW 45
3482: ST_TO_ADDR
// SetDir ( veh , 3 ) ;
3483: LD_VAR 0 3
3487: PPUSH
3488: LD_INT 3
3490: PPUSH
3491: CALL_OW 233
// PlaceUnitArea ( veh , allianceSpawnArea , false ) ;
3495: LD_VAR 0 3
3499: PPUSH
3500: LD_INT 30
3502: PPUSH
3503: LD_INT 0
3505: PPUSH
3506: CALL_OW 49
// PlaceHumanInUnit ( Denis , veh ) ;
3510: LD_EXP 20
3514: PPUSH
3515: LD_VAR 0 3
3519: PPUSH
3520: CALL_OW 52
// end ; uc_nation := 3 ;
3524: LD_ADDR_OWVAR 21
3528: PUSH
3529: LD_INT 3
3531: ST_TO_ADDR
// PrepareVehicle ( ru_medium_tracked , engine_siberite , control_manual , ru_rocket_launcher , 100 ) ;
3532: LD_INT 22
3534: PPUSH
3535: LD_INT 3
3537: PPUSH
3538: LD_INT 1
3540: PPUSH
3541: LD_INT 45
3543: PPUSH
3544: LD_INT 100
3546: PPUSH
3547: CALL 57621 0 5
// veh := CreateVehicle ;
3551: LD_ADDR_VAR 0 3
3555: PUSH
3556: CALL_OW 45
3560: ST_TO_ADDR
// SetMark ( veh , - 7 ) ;
3561: LD_VAR 0 3
3565: PPUSH
3566: LD_INT 7
3568: NEG
3569: PPUSH
3570: CALL_OW 242
// SetDir ( veh , 3 ) ;
3574: LD_VAR 0 3
3578: PPUSH
3579: LD_INT 3
3581: PPUSH
3582: CALL_OW 233
// PlaceUnitArea ( veh , allianceJMMSpawnArea , false ) ;
3586: LD_VAR 0 3
3590: PPUSH
3591: LD_INT 31
3593: PPUSH
3594: LD_INT 0
3596: PPUSH
3597: CALL_OW 49
// PlaceHumanInUnit ( Burlak , veh ) ;
3601: LD_EXP 46
3605: PPUSH
3606: LD_VAR 0 3
3610: PPUSH
3611: CALL_OW 52
// if Gossudarov then
3615: LD_EXP 32
3619: IFFALSE 3706
// begin PrepareVehicle ( ru_medium_tracked , engine_siberite , control_manual , ru_cargo_bay , 100 ) ;
3621: LD_INT 22
3623: PPUSH
3624: LD_INT 3
3626: PPUSH
3627: LD_INT 1
3629: PPUSH
3630: LD_INT 51
3632: PPUSH
3633: LD_INT 100
3635: PPUSH
3636: CALL 57621 0 5
// veh := CreateVehicle ;
3640: LD_ADDR_VAR 0 3
3644: PUSH
3645: CALL_OW 45
3649: ST_TO_ADDR
// SetDir ( veh , 3 ) ;
3650: LD_VAR 0 3
3654: PPUSH
3655: LD_INT 3
3657: PPUSH
3658: CALL_OW 233
// PlaceUnitArea ( veh , allianceSpawnArea , false ) ;
3662: LD_VAR 0 3
3666: PPUSH
3667: LD_INT 30
3669: PPUSH
3670: LD_INT 0
3672: PPUSH
3673: CALL_OW 49
// PlaceHumanInUnit ( Gossudarov , veh ) ;
3677: LD_EXP 32
3681: PPUSH
3682: LD_VAR 0 3
3686: PPUSH
3687: CALL_OW 52
// SetCargo ( veh , mat_cans , 100 ) ;
3691: LD_VAR 0 3
3695: PPUSH
3696: LD_INT 1
3698: PPUSH
3699: LD_INT 100
3701: PPUSH
3702: CALL_OW 290
// end ; for i in selected do
3706: LD_ADDR_VAR 0 2
3710: PUSH
3711: LD_VAR 0 4
3715: PUSH
3716: FOR_IN
3717: IFFALSE 4275
// begin uc_nation := GetNation ( i ) ;
3719: LD_ADDR_OWVAR 21
3723: PUSH
3724: LD_VAR 0 2
3728: PPUSH
3729: CALL_OW 248
3733: ST_TO_ADDR
// if i in [ Lisa , Donaldson , Cyrus , Bobby ] then
3734: LD_VAR 0 2
3738: PUSH
3739: LD_EXP 16
3743: PUSH
3744: LD_EXP 17
3748: PUSH
3749: LD_EXP 19
3753: PUSH
3754: LD_EXP 18
3758: PUSH
3759: EMPTY
3760: LIST
3761: LIST
3762: LIST
3763: LIST
3764: IN
3765: IFFALSE 3788
// PrepareVehicle ( us_morphling , engine_siberite , control_manual , us_heavy_gun , 100 ) else
3767: LD_INT 5
3769: PPUSH
3770: LD_INT 3
3772: PPUSH
3773: LD_INT 1
3775: PPUSH
3776: LD_INT 6
3778: PPUSH
3779: LD_INT 100
3781: PPUSH
3782: CALL 57621 0 5
3786: GO 4222
// if i in [ Oblukov , Kuzmov , Petrovova , Titov ] then
3788: LD_VAR 0 2
3792: PUSH
3793: LD_EXP 39
3797: PUSH
3798: LD_EXP 44
3802: PUSH
3803: LD_EXP 42
3807: PUSH
3808: LD_EXP 34
3812: PUSH
3813: EMPTY
3814: LIST
3815: LIST
3816: LIST
3817: LIST
3818: IN
3819: IFFALSE 3850
// PrepareVehicle ( ru_heavy_tracked , engine_combustion , control_manual , ru_heavy_gun , rand ( 65 , 75 ) ) else
3821: LD_INT 24
3823: PPUSH
3824: LD_INT 1
3826: PPUSH
3827: LD_INT 1
3829: PPUSH
3830: LD_INT 46
3832: PPUSH
3833: LD_INT 65
3835: PPUSH
3836: LD_INT 75
3838: PPUSH
3839: CALL_OW 12
3843: PPUSH
3844: CALL 57621 0 5
3848: GO 4222
// if i = Karamazov then
3850: LD_VAR 0 2
3854: PUSH
3855: LD_EXP 45
3859: EQUAL
3860: IFFALSE 3883
// PrepareVehicle ( ru_medium_tracked , engine_siberite , control_manual , ru_crane , 100 ) else
3862: LD_INT 22
3864: PPUSH
3865: LD_INT 3
3867: PPUSH
3868: LD_INT 1
3870: PPUSH
3871: LD_INT 52
3873: PPUSH
3874: LD_INT 100
3876: PPUSH
3877: CALL 57621 0 5
3881: GO 4222
// if i = Brown then
3883: LD_VAR 0 2
3887: PUSH
3888: LD_EXP 21
3892: EQUAL
3893: IFFALSE 3916
// PrepareVehicle ( us_medium_tracked , engine_siberite , control_manual , us_crane , 100 ) else
3895: LD_INT 3
3897: PPUSH
3898: LD_INT 3
3900: PPUSH
3901: LD_INT 1
3903: PPUSH
3904: LD_INT 13
3906: PPUSH
3907: LD_INT 100
3909: PPUSH
3910: CALL 57621 0 5
3914: GO 4222
// if uc_nation = nation_american then
3916: LD_OWVAR 21
3920: PUSH
3921: LD_INT 1
3923: EQUAL
3924: IFFALSE 4075
// begin PrepareVehicle ( [ us_medium_tracked , us_morphling , us_morphling ] [ uc_nation mod 3 + 1 ] , [ engine_combustion , engine_siberite , engine_combustion ] [ uc_nation mod 3 + 1 ] , control_manual , [ [ us_radar , us_gatling_gun , us_double_gun ] , [ us_heavy_gun , us_rocket_launcher , us_laser ] , [ us_heavy_gun , us_laser , us_cargo_bay ] ] [ uc_nation mod 3 + 1 ] [ rand ( 1 , 3 ) ] , rand ( 65 , 75 ) ) ;
3926: LD_INT 3
3928: PUSH
3929: LD_INT 5
3931: PUSH
3932: LD_INT 5
3934: PUSH
3935: EMPTY
3936: LIST
3937: LIST
3938: LIST
3939: PUSH
3940: LD_OWVAR 21
3944: PUSH
3945: LD_INT 3
3947: MOD
3948: PUSH
3949: LD_INT 1
3951: PLUS
3952: ARRAY
3953: PPUSH
3954: LD_INT 1
3956: PUSH
3957: LD_INT 3
3959: PUSH
3960: LD_INT 1
3962: PUSH
3963: EMPTY
3964: LIST
3965: LIST
3966: LIST
3967: PUSH
3968: LD_OWVAR 21
3972: PUSH
3973: LD_INT 3
3975: MOD
3976: PUSH
3977: LD_INT 1
3979: PLUS
3980: ARRAY
3981: PPUSH
3982: LD_INT 1
3984: PPUSH
3985: LD_INT 11
3987: PUSH
3988: LD_INT 4
3990: PUSH
3991: LD_INT 5
3993: PUSH
3994: EMPTY
3995: LIST
3996: LIST
3997: LIST
3998: PUSH
3999: LD_INT 6
4001: PUSH
4002: LD_INT 7
4004: PUSH
4005: LD_INT 9
4007: PUSH
4008: EMPTY
4009: LIST
4010: LIST
4011: LIST
4012: PUSH
4013: LD_INT 6
4015: PUSH
4016: LD_INT 9
4018: PUSH
4019: LD_INT 12
4021: PUSH
4022: EMPTY
4023: LIST
4024: LIST
4025: LIST
4026: PUSH
4027: EMPTY
4028: LIST
4029: LIST
4030: LIST
4031: PUSH
4032: LD_OWVAR 21
4036: PUSH
4037: LD_INT 3
4039: MOD
4040: PUSH
4041: LD_INT 1
4043: PLUS
4044: ARRAY
4045: PUSH
4046: LD_INT 1
4048: PPUSH
4049: LD_INT 3
4051: PPUSH
4052: CALL_OW 12
4056: ARRAY
4057: PPUSH
4058: LD_INT 65
4060: PPUSH
4061: LD_INT 75
4063: PPUSH
4064: CALL_OW 12
4068: PPUSH
4069: CALL 57621 0 5
// end else
4073: GO 4222
// begin PrepareVehicle ( [ ru_medium_tracked , ru_heavy_wheeled , ru_heavy_wheeled ] [ uc_nation mod 3 + 1 ] , [ engine_combustion , engine_siberite , engine_combustion ] [ uc_nation mod 3 + 1 ] , control_manual , [ [ ru_rocket_launcher , ru_gatling_gun , ru_gun ] , [ ru_heavy_gun , ru_rocket_launcher , ru_gun ] , [ ru_heavy_gun , ru_gatling_gun , ru_rocket_launcher ] ] [ uc_nation mod 3 + 1 ] [ rand ( 1 , 3 ) ] , rand ( 65 , 75 ) ) ;
4075: LD_INT 22
4077: PUSH
4078: LD_INT 23
4080: PUSH
4081: LD_INT 23
4083: PUSH
4084: EMPTY
4085: LIST
4086: LIST
4087: LIST
4088: PUSH
4089: LD_OWVAR 21
4093: PUSH
4094: LD_INT 3
4096: MOD
4097: PUSH
4098: LD_INT 1
4100: PLUS
4101: ARRAY
4102: PPUSH
4103: LD_INT 1
4105: PUSH
4106: LD_INT 3
4108: PUSH
4109: LD_INT 1
4111: PUSH
4112: EMPTY
4113: LIST
4114: LIST
4115: LIST
4116: PUSH
4117: LD_OWVAR 21
4121: PUSH
4122: LD_INT 3
4124: MOD
4125: PUSH
4126: LD_INT 1
4128: PLUS
4129: ARRAY
4130: PPUSH
4131: LD_INT 1
4133: PPUSH
4134: LD_INT 45
4136: PUSH
4137: LD_INT 43
4139: PUSH
4140: LD_INT 44
4142: PUSH
4143: EMPTY
4144: LIST
4145: LIST
4146: LIST
4147: PUSH
4148: LD_INT 46
4150: PUSH
4151: LD_INT 45
4153: PUSH
4154: LD_INT 44
4156: PUSH
4157: EMPTY
4158: LIST
4159: LIST
4160: LIST
4161: PUSH
4162: LD_INT 46
4164: PUSH
4165: LD_INT 43
4167: PUSH
4168: LD_INT 45
4170: PUSH
4171: EMPTY
4172: LIST
4173: LIST
4174: LIST
4175: PUSH
4176: EMPTY
4177: LIST
4178: LIST
4179: LIST
4180: PUSH
4181: LD_OWVAR 21
4185: PUSH
4186: LD_INT 3
4188: MOD
4189: PUSH
4190: LD_INT 1
4192: PLUS
4193: ARRAY
4194: PUSH
4195: LD_INT 1
4197: PPUSH
4198: LD_INT 3
4200: PPUSH
4201: CALL_OW 12
4205: ARRAY
4206: PPUSH
4207: LD_INT 65
4209: PPUSH
4210: LD_INT 75
4212: PPUSH
4213: CALL_OW 12
4217: PPUSH
4218: CALL 57621 0 5
// end ; veh := CreateVehicle ;
4222: LD_ADDR_VAR 0 3
4226: PUSH
4227: CALL_OW 45
4231: ST_TO_ADDR
// SetDir ( veh , 3 ) ;
4232: LD_VAR 0 3
4236: PPUSH
4237: LD_INT 3
4239: PPUSH
4240: CALL_OW 233
// PlaceUnitArea ( veh , allianceSpawnArea , false ) ;
4244: LD_VAR 0 3
4248: PPUSH
4249: LD_INT 30
4251: PPUSH
4252: LD_INT 0
4254: PPUSH
4255: CALL_OW 49
// PlaceHumanInUnit ( i , veh ) ;
4259: LD_VAR 0 2
4263: PPUSH
4264: LD_VAR 0 3
4268: PPUSH
4269: CALL_OW 52
// end ;
4273: GO 3716
4275: POP
4276: POP
// if artifactArCaptured then
4277: LD_EXP 6
4281: IFFALSE 4367
// begin uc_nation := nation_american ;
4283: LD_ADDR_OWVAR 21
4287: PUSH
4288: LD_INT 1
4290: ST_TO_ADDR
// PrepareVehicle ( us_medium_tracked , engine_siberite , control_computer , us_cargo_bay , 100 ) ;
4291: LD_INT 3
4293: PPUSH
4294: LD_INT 3
4296: PPUSH
4297: LD_INT 3
4299: PPUSH
4300: LD_INT 12
4302: PPUSH
4303: LD_INT 100
4305: PPUSH
4306: CALL 57621 0 5
// veh := CreateVehicle ;
4310: LD_ADDR_VAR 0 3
4314: PUSH
4315: CALL_OW 45
4319: ST_TO_ADDR
// SetDir ( veh , 3 ) ;
4320: LD_VAR 0 3
4324: PPUSH
4325: LD_INT 3
4327: PPUSH
4328: CALL_OW 233
// PlaceUnitXY ( veh , 198 , 22 , false ) ;
4332: LD_VAR 0 3
4336: PPUSH
4337: LD_INT 198
4339: PPUSH
4340: LD_INT 22
4342: PPUSH
4343: LD_INT 0
4345: PPUSH
4346: CALL_OW 48
// SetCargo ( veh , mat_artifact , 50 ) ;
4350: LD_VAR 0 3
4354: PPUSH
4355: LD_INT 4
4357: PPUSH
4358: LD_INT 50
4360: PPUSH
4361: CALL_OW 290
// end else
4365: GO 4386
// begin CreateResourcesXY ( mat_artifact , 267 , 226 , 5 , false ) ;
4367: LD_INT 4
4369: PPUSH
4370: LD_INT 267
4372: PPUSH
4373: LD_INT 226
4375: PPUSH
4376: LD_INT 5
4378: PPUSH
4379: LD_INT 0
4381: PPUSH
4382: CALL_OW 58
// end ; uc_nation := nation_american ;
4386: LD_ADDR_OWVAR 21
4390: PUSH
4391: LD_INT 1
4393: ST_TO_ADDR
// PrepareVehicle ( us_medium_tracked , engine_siberite , control_computer , us_cargo_bay , 100 ) ;
4394: LD_INT 3
4396: PPUSH
4397: LD_INT 3
4399: PPUSH
4400: LD_INT 3
4402: PPUSH
4403: LD_INT 12
4405: PPUSH
4406: LD_INT 100
4408: PPUSH
4409: CALL 57621 0 5
// veh := CreateVehicle ;
4413: LD_ADDR_VAR 0 3
4417: PUSH
4418: CALL_OW 45
4422: ST_TO_ADDR
// SetDir ( veh , 3 ) ;
4423: LD_VAR 0 3
4427: PPUSH
4428: LD_INT 3
4430: PPUSH
4431: CALL_OW 233
// PlaceUnitXY ( veh , 218 , 23 , false ) ;
4435: LD_VAR 0 3
4439: PPUSH
4440: LD_INT 218
4442: PPUSH
4443: LD_INT 23
4445: PPUSH
4446: LD_INT 0
4448: PPUSH
4449: CALL_OW 48
// SetCargo ( veh , mat_artifact , 30 ) ;
4453: LD_VAR 0 3
4457: PPUSH
4458: LD_INT 4
4460: PPUSH
4461: LD_INT 30
4463: PPUSH
4464: CALL_OW 290
// uc_nation := nation_russian ;
4468: LD_ADDR_OWVAR 21
4472: PUSH
4473: LD_INT 3
4475: ST_TO_ADDR
// PrepareVehicle ( ru_medium_tracked , engine_siberite , control_computer , ru_cargo_bay , 100 ) ;
4476: LD_INT 22
4478: PPUSH
4479: LD_INT 3
4481: PPUSH
4482: LD_INT 3
4484: PPUSH
4485: LD_INT 51
4487: PPUSH
4488: LD_INT 100
4490: PPUSH
4491: CALL 57621 0 5
// veh := CreateVehicle ;
4495: LD_ADDR_VAR 0 3
4499: PUSH
4500: CALL_OW 45
4504: ST_TO_ADDR
// SetDir ( veh , 3 ) ;
4505: LD_VAR 0 3
4509: PPUSH
4510: LD_INT 3
4512: PPUSH
4513: CALL_OW 233
// PlaceUnitXY ( veh , 214 , 20 , false ) ;
4517: LD_VAR 0 3
4521: PPUSH
4522: LD_INT 214
4524: PPUSH
4525: LD_INT 20
4527: PPUSH
4528: LD_INT 0
4530: PPUSH
4531: CALL_OW 48
// SetCargo ( veh , mat_artifact , 40 ) ;
4535: LD_VAR 0 3
4539: PPUSH
4540: LD_INT 4
4542: PPUSH
4543: LD_INT 40
4545: PPUSH
4546: CALL_OW 290
// end ; end_of_file
4550: LD_VAR 0 1
4554: RET
// export Powell ; export function PrepareAmerican ; var i , b , veh , cl , tmp , depot , lab , armoury , workshop ; begin
4555: LD_INT 0
4557: PPUSH
4558: PPUSH
4559: PPUSH
4560: PPUSH
4561: PPUSH
4562: PPUSH
4563: PPUSH
4564: PPUSH
4565: PPUSH
4566: PPUSH
// InitHc ;
4567: CALL_OW 19
// uc_side := 1 ;
4571: LD_ADDR_OWVAR 20
4575: PUSH
4576: LD_INT 1
4578: ST_TO_ADDR
// uc_nation := 1 ;
4579: LD_ADDR_OWVAR 21
4583: PUSH
4584: LD_INT 1
4586: ST_TO_ADDR
// for i in FilterAllUnits ( [ [ f_side , 1 ] , [ f_type , unit_building ] ] ) do
4587: LD_ADDR_VAR 0 2
4591: PUSH
4592: LD_INT 22
4594: PUSH
4595: LD_INT 1
4597: PUSH
4598: EMPTY
4599: LIST
4600: LIST
4601: PUSH
4602: LD_INT 21
4604: PUSH
4605: LD_INT 3
4607: PUSH
4608: EMPTY
4609: LIST
4610: LIST
4611: PUSH
4612: EMPTY
4613: LIST
4614: LIST
4615: PPUSH
4616: CALL_OW 69
4620: PUSH
4621: FOR_IN
4622: IFFALSE 4638
// SetBLevel ( i , 10 ) ;
4624: LD_VAR 0 2
4628: PPUSH
4629: LD_INT 10
4631: PPUSH
4632: CALL_OW 241
4636: GO 4621
4638: POP
4639: POP
// SetResourceType ( GetBase ( am_depot ) , mat_cans , 25500 ) ;
4640: LD_INT 387
4642: PPUSH
4643: CALL_OW 274
4647: PPUSH
4648: LD_INT 1
4650: PPUSH
4651: LD_INT 25500
4653: PPUSH
4654: CALL_OW 277
// SetResourceType ( GetBase ( am_depot ) , mat_oil , 4000 ) ;
4658: LD_INT 387
4660: PPUSH
4661: CALL_OW 274
4665: PPUSH
4666: LD_INT 2
4668: PPUSH
4669: LD_INT 4000
4671: PPUSH
4672: CALL_OW 277
// SetResourceType ( GetBase ( am_depot ) , mat_siberit , 50 ) ;
4676: LD_INT 387
4678: PPUSH
4679: CALL_OW 274
4683: PPUSH
4684: LD_INT 3
4686: PPUSH
4687: LD_INT 50
4689: PPUSH
4690: CALL_OW 277
// SetResourceType ( GetBase ( am_depot2 ) , mat_cans , 7500 ) ;
4694: LD_INT 476
4696: PPUSH
4697: CALL_OW 274
4701: PPUSH
4702: LD_INT 1
4704: PPUSH
4705: LD_INT 7500
4707: PPUSH
4708: CALL_OW 277
// SetResourceType ( GetBase ( am_depot2 ) , mat_oil , 4000 ) ;
4712: LD_INT 476
4714: PPUSH
4715: CALL_OW 274
4719: PPUSH
4720: LD_INT 2
4722: PPUSH
4723: LD_INT 4000
4725: PPUSH
4726: CALL_OW 277
// SetResourceType ( GetBase ( am_depot2 ) , mat_siberit , 10 ) ;
4730: LD_INT 476
4732: PPUSH
4733: CALL_OW 274
4737: PPUSH
4738: LD_INT 3
4740: PPUSH
4741: LD_INT 10
4743: PPUSH
4744: CALL_OW 277
// Powell := NewCharacter ( Powell ) ;
4748: LD_ADDR_EXP 49
4752: PUSH
4753: LD_STRING Powell
4755: PPUSH
4756: CALL_OW 25
4760: ST_TO_ADDR
// PlaceHumanInUnit ( Powell , am_depot ) ;
4761: LD_EXP 49
4765: PPUSH
4766: LD_INT 387
4768: PPUSH
4769: CALL_OW 52
// tmp := [ ] ;
4773: LD_ADDR_VAR 0 6
4777: PUSH
4778: EMPTY
4779: ST_TO_ADDR
// Lisa := PrepareUnit ( Lisa , ( not debug ) , 12p_ ) ;
4780: LD_ADDR_EXP 16
4784: PUSH
4785: LD_STRING Lisa
4787: PPUSH
4788: LD_EXP 1
4792: NOT
4793: PPUSH
4794: LD_STRING 12p_
4796: PPUSH
4797: CALL 50506 0 3
4801: ST_TO_ADDR
// if Lisa then
4802: LD_EXP 16
4806: IFFALSE 4824
// tmp := tmp ^ Lisa ;
4808: LD_ADDR_VAR 0 6
4812: PUSH
4813: LD_VAR 0 6
4817: PUSH
4818: LD_EXP 16
4822: ADD
4823: ST_TO_ADDR
// Donaldson := PrepareUnit ( Donaldson , ( not debug ) , 12p_ ) ;
4824: LD_ADDR_EXP 17
4828: PUSH
4829: LD_STRING Donaldson
4831: PPUSH
4832: LD_EXP 1
4836: NOT
4837: PPUSH
4838: LD_STRING 12p_
4840: PPUSH
4841: CALL 50506 0 3
4845: ST_TO_ADDR
// if Donaldson then
4846: LD_EXP 17
4850: IFFALSE 4868
// tmp := tmp ^ Donaldson ;
4852: LD_ADDR_VAR 0 6
4856: PUSH
4857: LD_VAR 0 6
4861: PUSH
4862: LD_EXP 17
4866: ADD
4867: ST_TO_ADDR
// Bobby := PrepareUnit ( Bobby , ( not debug ) , 12p_ ) ;
4868: LD_ADDR_EXP 18
4872: PUSH
4873: LD_STRING Bobby
4875: PPUSH
4876: LD_EXP 1
4880: NOT
4881: PPUSH
4882: LD_STRING 12p_
4884: PPUSH
4885: CALL 50506 0 3
4889: ST_TO_ADDR
// if Bobby then
4890: LD_EXP 18
4894: IFFALSE 4912
// tmp := tmp ^ Bobby ;
4896: LD_ADDR_VAR 0 6
4900: PUSH
4901: LD_VAR 0 6
4905: PUSH
4906: LD_EXP 18
4910: ADD
4911: ST_TO_ADDR
// Cyrus := PrepareUnit ( Cyrus , ( not debug ) , 12p_ ) ;
4912: LD_ADDR_EXP 19
4916: PUSH
4917: LD_STRING Cyrus
4919: PPUSH
4920: LD_EXP 1
4924: NOT
4925: PPUSH
4926: LD_STRING 12p_
4928: PPUSH
4929: CALL 50506 0 3
4933: ST_TO_ADDR
// if Cyrus then
4934: LD_EXP 19
4938: IFFALSE 4956
// tmp := tmp ^ Cyrus ;
4940: LD_ADDR_VAR 0 6
4944: PUSH
4945: LD_VAR 0 6
4949: PUSH
4950: LD_EXP 19
4954: ADD
4955: ST_TO_ADDR
// Brown := PrepareUnit ( Brown , ( not debug ) , 12p_ ) ;
4956: LD_ADDR_EXP 21
4960: PUSH
4961: LD_STRING Brown
4963: PPUSH
4964: LD_EXP 1
4968: NOT
4969: PPUSH
4970: LD_STRING 12p_
4972: PPUSH
4973: CALL 50506 0 3
4977: ST_TO_ADDR
// if Brown then
4978: LD_EXP 21
4982: IFFALSE 5000
// tmp := tmp ^ Brown ;
4984: LD_ADDR_VAR 0 6
4988: PUSH
4989: LD_VAR 0 6
4993: PUSH
4994: LD_EXP 21
4998: ADD
4999: ST_TO_ADDR
// Gladstone := PrepareUnit ( Gladstone , ( not debug ) , 12p_ ) ;
5000: LD_ADDR_EXP 22
5004: PUSH
5005: LD_STRING Gladstone
5007: PPUSH
5008: LD_EXP 1
5012: NOT
5013: PPUSH
5014: LD_STRING 12p_
5016: PPUSH
5017: CALL 50506 0 3
5021: ST_TO_ADDR
// if Gladstone then
5022: LD_EXP 22
5026: IFFALSE 5044
// tmp := tmp ^ Gladstone ;
5028: LD_ADDR_VAR 0 6
5032: PUSH
5033: LD_VAR 0 6
5037: PUSH
5038: LD_EXP 22
5042: ADD
5043: ST_TO_ADDR
// Houten := PrepareUnit ( Houten , ( not debug ) , 12p_ ) ;
5044: LD_ADDR_EXP 23
5048: PUSH
5049: LD_STRING Houten
5051: PPUSH
5052: LD_EXP 1
5056: NOT
5057: PPUSH
5058: LD_STRING 12p_
5060: PPUSH
5061: CALL 50506 0 3
5065: ST_TO_ADDR
// if Houten then
5066: LD_EXP 23
5070: IFFALSE 5088
// tmp := tmp ^ Houten ;
5072: LD_ADDR_VAR 0 6
5076: PUSH
5077: LD_VAR 0 6
5081: PUSH
5082: LD_EXP 23
5086: ADD
5087: ST_TO_ADDR
// Cornel := PrepareUnit ( Cornel , ( not debug ) , 12p_ ) ;
5088: LD_ADDR_EXP 24
5092: PUSH
5093: LD_STRING Cornel
5095: PPUSH
5096: LD_EXP 1
5100: NOT
5101: PPUSH
5102: LD_STRING 12p_
5104: PPUSH
5105: CALL 50506 0 3
5109: ST_TO_ADDR
// if Cornel then
5110: LD_EXP 24
5114: IFFALSE 5132
// tmp := tmp ^ Cornel ;
5116: LD_ADDR_VAR 0 6
5120: PUSH
5121: LD_VAR 0 6
5125: PUSH
5126: LD_EXP 24
5130: ADD
5131: ST_TO_ADDR
// Gary := PrepareUnit ( Gary , ( not debug ) , 12p_ ) ;
5132: LD_ADDR_EXP 25
5136: PUSH
5137: LD_STRING Gary
5139: PPUSH
5140: LD_EXP 1
5144: NOT
5145: PPUSH
5146: LD_STRING 12p_
5148: PPUSH
5149: CALL 50506 0 3
5153: ST_TO_ADDR
// if Gary then
5154: LD_EXP 25
5158: IFFALSE 5176
// tmp := tmp ^ Gary ;
5160: LD_ADDR_VAR 0 6
5164: PUSH
5165: LD_VAR 0 6
5169: PUSH
5170: LD_EXP 25
5174: ADD
5175: ST_TO_ADDR
// Kikuchi := PrepareUnit ( Kikuchi , ( not debug ) , 12p_ ) ;
5176: LD_ADDR_EXP 27
5180: PUSH
5181: LD_STRING Kikuchi
5183: PPUSH
5184: LD_EXP 1
5188: NOT
5189: PPUSH
5190: LD_STRING 12p_
5192: PPUSH
5193: CALL 50506 0 3
5197: ST_TO_ADDR
// if Kikuchi then
5198: LD_EXP 27
5202: IFFALSE 5220
// tmp := tmp ^ Kikuchi ;
5204: LD_ADDR_VAR 0 6
5208: PUSH
5209: LD_VAR 0 6
5213: PUSH
5214: LD_EXP 27
5218: ADD
5219: ST_TO_ADDR
// tmp := tmp union CreateCharacterSet ( 12p_others ) ;
5220: LD_ADDR_VAR 0 6
5224: PUSH
5225: LD_VAR 0 6
5229: PUSH
5230: LD_STRING 12p_others
5232: PPUSH
5233: CALL_OW 31
5237: UNION
5238: ST_TO_ADDR
// if tmp < 36 then
5239: LD_VAR 0 6
5243: PUSH
5244: LD_INT 36
5246: LESS
5247: IFFALSE 5314
// for i = 1 to 36 - tmp do
5249: LD_ADDR_VAR 0 2
5253: PUSH
5254: DOUBLE
5255: LD_INT 1
5257: DEC
5258: ST_TO_ADDR
5259: LD_INT 36
5261: PUSH
5262: LD_VAR 0 6
5266: MINUS
5267: PUSH
5268: FOR_TO
5269: IFFALSE 5312
// begin PrepareHuman ( sex_male , i mod 4 + 1 , 10 ) ;
5271: LD_INT 1
5273: PPUSH
5274: LD_VAR 0 2
5278: PUSH
5279: LD_INT 4
5281: MOD
5282: PUSH
5283: LD_INT 1
5285: PLUS
5286: PPUSH
5287: LD_INT 10
5289: PPUSH
5290: CALL_OW 380
// tmp := tmp ^ CreateHuman ;
5294: LD_ADDR_VAR 0 6
5298: PUSH
5299: LD_VAR 0 6
5303: PUSH
5304: CALL_OW 44
5308: ADD
5309: ST_TO_ADDR
// end ;
5310: GO 5268
5312: POP
5313: POP
// for i in tmp do
5314: LD_ADDR_VAR 0 2
5318: PUSH
5319: LD_VAR 0 6
5323: PUSH
5324: FOR_IN
5325: IFFALSE 5350
// PlaceUnitXYR ( i , 62 , 93 , 9 , false ) ;
5327: LD_VAR 0 2
5331: PPUSH
5332: LD_INT 62
5334: PPUSH
5335: LD_INT 93
5337: PPUSH
5338: LD_INT 9
5340: PPUSH
5341: LD_INT 0
5343: PPUSH
5344: CALL_OW 50
5348: GO 5324
5350: POP
5351: POP
// mc_bases := Replace ( mc_bases , 4 , FilterAllUnits ( [ f_side , 1 ] ) diff Powell ) ;
5352: LD_ADDR_EXP 76
5356: PUSH
5357: LD_EXP 76
5361: PPUSH
5362: LD_INT 4
5364: PPUSH
5365: LD_INT 22
5367: PUSH
5368: LD_INT 1
5370: PUSH
5371: EMPTY
5372: LIST
5373: LIST
5374: PPUSH
5375: CALL_OW 69
5379: PUSH
5380: LD_EXP 49
5384: DIFF
5385: PPUSH
5386: CALL_OW 1
5390: ST_TO_ADDR
// uc_side := 0 ;
5391: LD_ADDR_OWVAR 20
5395: PUSH
5396: LD_INT 0
5398: ST_TO_ADDR
// uc_nation := 0 ;
5399: LD_ADDR_OWVAR 21
5403: PUSH
5404: LD_INT 0
5406: ST_TO_ADDR
// for i = 1 to 4 do
5407: LD_ADDR_VAR 0 2
5411: PUSH
5412: DOUBLE
5413: LD_INT 1
5415: DEC
5416: ST_TO_ADDR
5417: LD_INT 4
5419: PUSH
5420: FOR_TO
5421: IFFALSE 5452
// begin InitHc ;
5423: CALL_OW 19
// hc_class := class_apeman ;
5427: LD_ADDR_OWVAR 28
5431: PUSH
5432: LD_INT 12
5434: ST_TO_ADDR
// PlaceUnitArea ( CreateHuman , powellApe , false ) ;
5435: CALL_OW 44
5439: PPUSH
5440: LD_INT 11
5442: PPUSH
5443: LD_INT 0
5445: PPUSH
5446: CALL_OW 49
// end ;
5450: GO 5420
5452: POP
5453: POP
// end ;
5454: LD_VAR 0 1
5458: RET
// every 11 11$30 trigger not americanDestroyed and not MC_GetVehicles ( 4 , true ) do var i , tmp , target ;
5459: LD_EXP 4
5463: NOT
5464: PUSH
5465: LD_INT 4
5467: PPUSH
5468: LD_INT 1
5470: PPUSH
5471: CALL 45580 0 2
5475: NOT
5476: AND
5477: IFFALSE 6249
5479: GO 5481
5481: DISABLE
5482: LD_INT 0
5484: PPUSH
5485: PPUSH
5486: PPUSH
// begin enable ;
5487: ENABLE
// if not FilterAllUnits ( [ [ f_side , 1 ] , [ f_nation , 1 ] , [ f_btype , b_factory ] ] ) then
5488: LD_INT 22
5490: PUSH
5491: LD_INT 1
5493: PUSH
5494: EMPTY
5495: LIST
5496: LIST
5497: PUSH
5498: LD_INT 23
5500: PUSH
5501: LD_INT 1
5503: PUSH
5504: EMPTY
5505: LIST
5506: LIST
5507: PUSH
5508: LD_INT 30
5510: PUSH
5511: LD_INT 3
5513: PUSH
5514: EMPTY
5515: LIST
5516: LIST
5517: PUSH
5518: EMPTY
5519: LIST
5520: LIST
5521: LIST
5522: PPUSH
5523: CALL_OW 69
5527: NOT
5528: IFFALSE 5532
// exit ;
5530: GO 6249
// if Prob ( 40 ) then
5532: LD_INT 40
5534: PPUSH
5535: CALL_OW 13
5539: IFFALSE 5666
// begin MC_InsertProduceList ( 4 , [ [ us_morphling , engine_combustion , control_remote , us_rocket_launcher ] , [ us_morphling , engine_combustion , control_remote , us_rocket_launcher ] , [ us_morphling , engine_combustion , control_remote , us_rocket_launcher ] , [ us_morphling , engine_combustion , control_remote , us_heavy_gun ] , [ us_morphling , engine_combustion , control_remote , us_heavy_gun ] , [ us_morphling , engine_combustion , control_remote , us_heavy_gun ] , ] ) ;
5541: LD_INT 4
5543: PPUSH
5544: LD_INT 5
5546: PUSH
5547: LD_INT 1
5549: PUSH
5550: LD_INT 2
5552: PUSH
5553: LD_INT 7
5555: PUSH
5556: EMPTY
5557: LIST
5558: LIST
5559: LIST
5560: LIST
5561: PUSH
5562: LD_INT 5
5564: PUSH
5565: LD_INT 1
5567: PUSH
5568: LD_INT 2
5570: PUSH
5571: LD_INT 7
5573: PUSH
5574: EMPTY
5575: LIST
5576: LIST
5577: LIST
5578: LIST
5579: PUSH
5580: LD_INT 5
5582: PUSH
5583: LD_INT 1
5585: PUSH
5586: LD_INT 2
5588: PUSH
5589: LD_INT 7
5591: PUSH
5592: EMPTY
5593: LIST
5594: LIST
5595: LIST
5596: LIST
5597: PUSH
5598: LD_INT 5
5600: PUSH
5601: LD_INT 1
5603: PUSH
5604: LD_INT 2
5606: PUSH
5607: LD_INT 6
5609: PUSH
5610: EMPTY
5611: LIST
5612: LIST
5613: LIST
5614: LIST
5615: PUSH
5616: LD_INT 5
5618: PUSH
5619: LD_INT 1
5621: PUSH
5622: LD_INT 2
5624: PUSH
5625: LD_INT 6
5627: PUSH
5628: EMPTY
5629: LIST
5630: LIST
5631: LIST
5632: LIST
5633: PUSH
5634: LD_INT 5
5636: PUSH
5637: LD_INT 1
5639: PUSH
5640: LD_INT 2
5642: PUSH
5643: LD_INT 6
5645: PUSH
5646: EMPTY
5647: LIST
5648: LIST
5649: LIST
5650: LIST
5651: PUSH
5652: EMPTY
5653: LIST
5654: LIST
5655: LIST
5656: LIST
5657: LIST
5658: LIST
5659: PPUSH
5660: CALL 44162 0 2
// end else
5664: GO 5789
// begin MC_InsertProduceList ( 4 , [ [ us_morphling , engine_combustion , control_remote , us_rocket_launcher ] , [ us_morphling , engine_combustion , control_remote , us_laser ] , [ us_morphling , engine_combustion , control_remote , us_laser ] , [ us_morphling , engine_combustion , control_remote , us_heavy_gun ] , [ us_morphling , engine_combustion , control_remote , us_heavy_gun ] , [ us_morphling , engine_combustion , control_remote , us_heavy_gun ] , ] ) ;
5666: LD_INT 4
5668: PPUSH
5669: LD_INT 5
5671: PUSH
5672: LD_INT 1
5674: PUSH
5675: LD_INT 2
5677: PUSH
5678: LD_INT 7
5680: PUSH
5681: EMPTY
5682: LIST
5683: LIST
5684: LIST
5685: LIST
5686: PUSH
5687: LD_INT 5
5689: PUSH
5690: LD_INT 1
5692: PUSH
5693: LD_INT 2
5695: PUSH
5696: LD_INT 9
5698: PUSH
5699: EMPTY
5700: LIST
5701: LIST
5702: LIST
5703: LIST
5704: PUSH
5705: LD_INT 5
5707: PUSH
5708: LD_INT 1
5710: PUSH
5711: LD_INT 2
5713: PUSH
5714: LD_INT 9
5716: PUSH
5717: EMPTY
5718: LIST
5719: LIST
5720: LIST
5721: LIST
5722: PUSH
5723: LD_INT 5
5725: PUSH
5726: LD_INT 1
5728: PUSH
5729: LD_INT 2
5731: PUSH
5732: LD_INT 6
5734: PUSH
5735: EMPTY
5736: LIST
5737: LIST
5738: LIST
5739: LIST
5740: PUSH
5741: LD_INT 5
5743: PUSH
5744: LD_INT 1
5746: PUSH
5747: LD_INT 2
5749: PUSH
5750: LD_INT 6
5752: PUSH
5753: EMPTY
5754: LIST
5755: LIST
5756: LIST
5757: LIST
5758: PUSH
5759: LD_INT 5
5761: PUSH
5762: LD_INT 1
5764: PUSH
5765: LD_INT 2
5767: PUSH
5768: LD_INT 6
5770: PUSH
5771: EMPTY
5772: LIST
5773: LIST
5774: LIST
5775: LIST
5776: PUSH
5777: EMPTY
5778: LIST
5779: LIST
5780: LIST
5781: LIST
5782: LIST
5783: LIST
5784: PPUSH
5785: CALL 44162 0 2
// end ; repeat wait ( 0 0$1 ) ;
5789: LD_INT 35
5791: PPUSH
5792: CALL_OW 67
// until MC_GetVehicles ( 4 , true ) >= 6 ;
5796: LD_INT 4
5798: PPUSH
5799: LD_INT 1
5801: PPUSH
5802: CALL 45580 0 2
5806: PUSH
5807: LD_INT 6
5809: GREATEREQUAL
5810: IFFALSE 5789
// wait ( 0 0$30 ) ;
5812: LD_INT 1050
5814: PPUSH
5815: CALL_OW 67
// tmp := MC_GetVehicles ( 4 , true ) ;
5819: LD_ADDR_VAR 0 2
5823: PUSH
5824: LD_INT 4
5826: PPUSH
5827: LD_INT 1
5829: PPUSH
5830: CALL 45580 0 2
5834: ST_TO_ADDR
// mc_vehicles := Replace ( mc_vehicles , 4 , mc_vehicles [ 4 ] diff tmp ) ;
5835: LD_ADDR_EXP 95
5839: PUSH
5840: LD_EXP 95
5844: PPUSH
5845: LD_INT 4
5847: PPUSH
5848: LD_EXP 95
5852: PUSH
5853: LD_INT 4
5855: ARRAY
5856: PUSH
5857: LD_VAR 0 2
5861: DIFF
5862: PPUSH
5863: CALL_OW 1
5867: ST_TO_ADDR
// target := rand ( 0 , 2 ) ;
5868: LD_ADDR_VAR 0 3
5872: PUSH
5873: LD_INT 0
5875: PPUSH
5876: LD_INT 2
5878: PPUSH
5879: CALL_OW 12
5883: ST_TO_ADDR
// if target then
5884: LD_VAR 0 3
5888: IFFALSE 6016
// begin repeat tmp := UnitFilter ( tmp , [ f_lives , 250 ] ) ;
5890: LD_ADDR_VAR 0 2
5894: PUSH
5895: LD_VAR 0 2
5899: PPUSH
5900: LD_INT 24
5902: PUSH
5903: LD_INT 250
5905: PUSH
5906: EMPTY
5907: LIST
5908: LIST
5909: PPUSH
5910: CALL_OW 72
5914: ST_TO_ADDR
// for i in tmp do
5915: LD_ADDR_VAR 0 1
5919: PUSH
5920: LD_VAR 0 2
5924: PUSH
5925: FOR_IN
5926: IFFALSE 5966
// if GetDistUnitXY ( i , 114 , 108 ) > 9 then
5928: LD_VAR 0 1
5932: PPUSH
5933: LD_INT 114
5935: PPUSH
5936: LD_INT 108
5938: PPUSH
5939: CALL_OW 297
5943: PUSH
5944: LD_INT 9
5946: GREATER
5947: IFFALSE 5964
// ComMoveXY ( i , 114 , 108 ) ;
5949: LD_VAR 0 1
5953: PPUSH
5954: LD_INT 114
5956: PPUSH
5957: LD_INT 108
5959: PPUSH
5960: CALL_OW 111
5964: GO 5925
5966: POP
5967: POP
// wait ( 0 0$1 ) ;
5968: LD_INT 35
5970: PPUSH
5971: CALL_OW 67
// until UnitFilter ( tmp , [ f_distxy , 114 , 108 , 9 ] ) >= ( tmp - 1 ) ;
5975: LD_VAR 0 2
5979: PPUSH
5980: LD_INT 92
5982: PUSH
5983: LD_INT 114
5985: PUSH
5986: LD_INT 108
5988: PUSH
5989: LD_INT 9
5991: PUSH
5992: EMPTY
5993: LIST
5994: LIST
5995: LIST
5996: LIST
5997: PPUSH
5998: CALL_OW 72
6002: PUSH
6003: LD_VAR 0 2
6007: PUSH
6008: LD_INT 1
6010: MINUS
6011: GREATEREQUAL
6012: IFFALSE 5890
// end else
6014: GO 6140
// begin repeat tmp := UnitFilter ( tmp , [ f_lives , 250 ] ) ;
6016: LD_ADDR_VAR 0 2
6020: PUSH
6021: LD_VAR 0 2
6025: PPUSH
6026: LD_INT 24
6028: PUSH
6029: LD_INT 250
6031: PUSH
6032: EMPTY
6033: LIST
6034: LIST
6035: PPUSH
6036: CALL_OW 72
6040: ST_TO_ADDR
// for i in tmp do
6041: LD_ADDR_VAR 0 1
6045: PUSH
6046: LD_VAR 0 2
6050: PUSH
6051: FOR_IN
6052: IFFALSE 6092
// if GetDistUnitXY ( i , 129 , 139 ) > 9 then
6054: LD_VAR 0 1
6058: PPUSH
6059: LD_INT 129
6061: PPUSH
6062: LD_INT 139
6064: PPUSH
6065: CALL_OW 297
6069: PUSH
6070: LD_INT 9
6072: GREATER
6073: IFFALSE 6090
// ComMoveXY ( i , 129 , 139 ) ;
6075: LD_VAR 0 1
6079: PPUSH
6080: LD_INT 129
6082: PPUSH
6083: LD_INT 139
6085: PPUSH
6086: CALL_OW 111
6090: GO 6051
6092: POP
6093: POP
// wait ( 0 0$1 ) ;
6094: LD_INT 35
6096: PPUSH
6097: CALL_OW 67
// until UnitFilter ( tmp , [ f_distxy , 129 , 139 , 9 ] ) >= ( tmp - 1 ) ;
6101: LD_VAR 0 2
6105: PPUSH
6106: LD_INT 92
6108: PUSH
6109: LD_INT 129
6111: PUSH
6112: LD_INT 139
6114: PUSH
6115: LD_INT 9
6117: PUSH
6118: EMPTY
6119: LIST
6120: LIST
6121: LIST
6122: LIST
6123: PPUSH
6124: CALL_OW 72
6128: PUSH
6129: LD_VAR 0 2
6133: PUSH
6134: LD_INT 1
6136: MINUS
6137: GREATEREQUAL
6138: IFFALSE 6016
// end ; repeat wait ( 0 0$1 ) ;
6140: LD_INT 35
6142: PPUSH
6143: CALL_OW 67
// for i in tmp do
6147: LD_ADDR_VAR 0 1
6151: PUSH
6152: LD_VAR 0 2
6156: PUSH
6157: FOR_IN
6158: IFFALSE 6240
// begin if GetLives ( i ) > 251 then
6160: LD_VAR 0 1
6164: PPUSH
6165: CALL_OW 256
6169: PUSH
6170: LD_INT 251
6172: GREATER
6173: IFFALSE 6211
// ComAttackUnit ( i , NearestUnitToUnit ( FilterAllUnits ( [ f_enemy , 1 ] ) , i ) ) else
6175: LD_VAR 0 1
6179: PPUSH
6180: LD_INT 81
6182: PUSH
6183: LD_INT 1
6185: PUSH
6186: EMPTY
6187: LIST
6188: LIST
6189: PPUSH
6190: CALL_OW 69
6194: PPUSH
6195: LD_VAR 0 1
6199: PPUSH
6200: CALL_OW 74
6204: PPUSH
6205: CALL_OW 115
6209: GO 6238
// if IsDead ( i ) then
6211: LD_VAR 0 1
6215: PPUSH
6216: CALL_OW 301
6220: IFFALSE 6238
// tmp := tmp diff i ;
6222: LD_ADDR_VAR 0 2
6226: PUSH
6227: LD_VAR 0 2
6231: PUSH
6232: LD_VAR 0 1
6236: DIFF
6237: ST_TO_ADDR
// end ;
6238: GO 6157
6240: POP
6241: POP
// until not tmp ;
6242: LD_VAR 0 2
6246: NOT
6247: IFFALSE 6140
// end ;
6249: PPOPN 3
6251: END
// every 30 30$00 trigger not americanDestroyed do
6252: LD_EXP 4
6256: NOT
6257: IFFALSE 6322
6259: GO 6261
6261: DISABLE
// begin wait ( [ 30 30$00 , 20 20$00 , 10 10$00 ] [ Difficulty ] ) ;
6262: LD_INT 63000
6264: PUSH
6265: LD_INT 42000
6267: PUSH
6268: LD_INT 21000
6270: PUSH
6271: EMPTY
6272: LIST
6273: LIST
6274: LIST
6275: PUSH
6276: LD_OWVAR 67
6280: ARRAY
6281: PPUSH
6282: CALL_OW 67
// if americanDestroyed then
6286: LD_EXP 4
6290: IFFALSE 6294
// exit ;
6292: GO 6322
// MC_InsertProduceList ( 4 , [ [ us_morphling , engine_siberite , control_manual , us_siberium_rocket ] ] ) ;
6294: LD_INT 4
6296: PPUSH
6297: LD_INT 5
6299: PUSH
6300: LD_INT 3
6302: PUSH
6303: LD_INT 1
6305: PUSH
6306: LD_INT 8
6308: PUSH
6309: EMPTY
6310: LIST
6311: LIST
6312: LIST
6313: LIST
6314: PUSH
6315: EMPTY
6316: LIST
6317: PPUSH
6318: CALL 44162 0 2
// end ; end_of_file
6322: END
// export function PrepareArabian ; var i , un , tmp , side ; begin
6323: LD_INT 0
6325: PPUSH
6326: PPUSH
6327: PPUSH
6328: PPUSH
6329: PPUSH
// side := 2 ;
6330: LD_ADDR_VAR 0 5
6334: PUSH
6335: LD_INT 2
6337: ST_TO_ADDR
// InitHc ;
6338: CALL_OW 19
// uc_side := side ;
6342: LD_ADDR_OWVAR 20
6346: PUSH
6347: LD_VAR 0 5
6351: ST_TO_ADDR
// uc_nation := 2 ;
6352: LD_ADDR_OWVAR 21
6356: PUSH
6357: LD_INT 2
6359: ST_TO_ADDR
// for i in FilterAllUnits ( [ [ f_side , 2 ] , [ f_type , unit_building ] ] ) do
6360: LD_ADDR_VAR 0 2
6364: PUSH
6365: LD_INT 22
6367: PUSH
6368: LD_INT 2
6370: PUSH
6371: EMPTY
6372: LIST
6373: LIST
6374: PUSH
6375: LD_INT 21
6377: PUSH
6378: LD_INT 3
6380: PUSH
6381: EMPTY
6382: LIST
6383: LIST
6384: PUSH
6385: EMPTY
6386: LIST
6387: LIST
6388: PPUSH
6389: CALL_OW 69
6393: PUSH
6394: FOR_IN
6395: IFFALSE 6411
// SetBLevel ( i , 10 ) ;
6397: LD_VAR 0 2
6401: PPUSH
6402: LD_INT 10
6404: PPUSH
6405: CALL_OW 241
6409: GO 6394
6411: POP
6412: POP
// tmp := FilterAllUnits ( [ [ f_side , side ] , [ f_btype , b_bunker ] , [ f_empty ] ] ) ;
6413: LD_ADDR_VAR 0 4
6417: PUSH
6418: LD_INT 22
6420: PUSH
6421: LD_VAR 0 5
6425: PUSH
6426: EMPTY
6427: LIST
6428: LIST
6429: PUSH
6430: LD_INT 30
6432: PUSH
6433: LD_INT 32
6435: PUSH
6436: EMPTY
6437: LIST
6438: LIST
6439: PUSH
6440: LD_INT 58
6442: PUSH
6443: EMPTY
6444: LIST
6445: PUSH
6446: EMPTY
6447: LIST
6448: LIST
6449: LIST
6450: PPUSH
6451: CALL_OW 69
6455: ST_TO_ADDR
// for i = 1 to 10 do
6456: LD_ADDR_VAR 0 2
6460: PUSH
6461: DOUBLE
6462: LD_INT 1
6464: DEC
6465: ST_TO_ADDR
6466: LD_INT 10
6468: PUSH
6469: FOR_TO
6470: IFFALSE 6542
// begin uc_nation := nation_nature ;
6472: LD_ADDR_OWVAR 21
6476: PUSH
6477: LD_INT 0
6479: ST_TO_ADDR
// hc_class := class_apeman_soldier ;
6480: LD_ADDR_OWVAR 28
6484: PUSH
6485: LD_INT 15
6487: ST_TO_ADDR
// hc_gallery :=  ;
6488: LD_ADDR_OWVAR 33
6492: PUSH
6493: LD_STRING 
6495: ST_TO_ADDR
// hc_name :=  ;
6496: LD_ADDR_OWVAR 26
6500: PUSH
6501: LD_STRING 
6503: ST_TO_ADDR
// un := CreateHuman ;
6504: LD_ADDR_VAR 0 3
6508: PUSH
6509: CALL_OW 44
6513: ST_TO_ADDR
// PlaceHumanInUnit ( un , tmp [ tmp - i ] ) ;
6514: LD_VAR 0 3
6518: PPUSH
6519: LD_VAR 0 4
6523: PUSH
6524: LD_VAR 0 4
6528: PUSH
6529: LD_VAR 0 2
6533: MINUS
6534: ARRAY
6535: PPUSH
6536: CALL_OW 52
// end ;
6540: GO 6469
6542: POP
6543: POP
// PrepareBase ( ar_depot , arabianBaseArea ,  , [ 8 , 9 , 10 ] [ Difficulty ] , [ 3000 , 500 , 150 ] , [ 16 , 6 , 6 , 6 ] ) ;
6544: LD_INT 503
6546: PPUSH
6547: LD_INT 27
6549: PPUSH
6550: LD_STRING 
6552: PPUSH
6553: LD_INT 8
6555: PUSH
6556: LD_INT 9
6558: PUSH
6559: LD_INT 10
6561: PUSH
6562: EMPTY
6563: LIST
6564: LIST
6565: LIST
6566: PUSH
6567: LD_OWVAR 67
6571: ARRAY
6572: PPUSH
6573: LD_INT 3000
6575: PUSH
6576: LD_INT 500
6578: PUSH
6579: LD_INT 150
6581: PUSH
6582: EMPTY
6583: LIST
6584: LIST
6585: LIST
6586: PPUSH
6587: LD_INT 16
6589: PUSH
6590: LD_INT 6
6592: PUSH
6593: LD_INT 6
6595: PUSH
6596: LD_INT 6
6598: PUSH
6599: EMPTY
6600: LIST
6601: LIST
6602: LIST
6603: LIST
6604: PPUSH
6605: CALL 61030 0 6
// mc_bases := Replace ( mc_bases , 1 , FilterAllUnits ( [ [ f_side , side ] , [ f_nation , 2 ] , [ f_not , [ f_type , unit_vehicle ] ] ] ) ) ;
6609: LD_ADDR_EXP 76
6613: PUSH
6614: LD_EXP 76
6618: PPUSH
6619: LD_INT 1
6621: PPUSH
6622: LD_INT 22
6624: PUSH
6625: LD_VAR 0 5
6629: PUSH
6630: EMPTY
6631: LIST
6632: LIST
6633: PUSH
6634: LD_INT 23
6636: PUSH
6637: LD_INT 2
6639: PUSH
6640: EMPTY
6641: LIST
6642: LIST
6643: PUSH
6644: LD_INT 3
6646: PUSH
6647: LD_INT 21
6649: PUSH
6650: LD_INT 2
6652: PUSH
6653: EMPTY
6654: LIST
6655: LIST
6656: PUSH
6657: EMPTY
6658: LIST
6659: LIST
6660: PUSH
6661: EMPTY
6662: LIST
6663: LIST
6664: LIST
6665: PPUSH
6666: CALL_OW 69
6670: PPUSH
6671: CALL_OW 1
6675: ST_TO_ADDR
// end ;
6676: LD_VAR 0 1
6680: RET
// export Omar ; export function PrepareOmarAli ; begin
6681: LD_INT 0
6683: PPUSH
// uc_side := 5 ;
6684: LD_ADDR_OWVAR 20
6688: PUSH
6689: LD_INT 5
6691: ST_TO_ADDR
// uc_nation := 2 ;
6692: LD_ADDR_OWVAR 21
6696: PUSH
6697: LD_INT 2
6699: ST_TO_ADDR
// Omar := NewCharacter ( Omar ) ;
6700: LD_ADDR_EXP 50
6704: PUSH
6705: LD_STRING Omar
6707: PPUSH
6708: CALL_OW 25
6712: ST_TO_ADDR
// PlaceUnitXY ( Omar , 330 , 244 , false ) ;
6713: LD_EXP 50
6717: PPUSH
6718: LD_INT 330
6720: PPUSH
6721: LD_INT 244
6723: PPUSH
6724: LD_INT 0
6726: PPUSH
6727: CALL_OW 48
// ComMoveXY ( Omar , 252 , 220 ) ;
6731: LD_EXP 50
6735: PPUSH
6736: LD_INT 252
6738: PPUSH
6739: LD_INT 220
6741: PPUSH
6742: CALL_OW 111
// end ; end_of_file
6746: LD_VAR 0 1
6750: RET
// export Schulz , Kozlov ; export function PrepareLegion ; var i , side , un , tmp ; begin
6751: LD_INT 0
6753: PPUSH
6754: PPUSH
6755: PPUSH
6756: PPUSH
6757: PPUSH
// side := 8 ;
6758: LD_ADDR_VAR 0 3
6762: PUSH
6763: LD_INT 8
6765: ST_TO_ADDR
// InitHc ;
6766: CALL_OW 19
// uc_side := side ;
6770: LD_ADDR_OWVAR 20
6774: PUSH
6775: LD_VAR 0 3
6779: ST_TO_ADDR
// uc_nation := 2 ;
6780: LD_ADDR_OWVAR 21
6784: PUSH
6785: LD_INT 2
6787: ST_TO_ADDR
// for i in FilterAllUnits ( [ [ f_side , side ] , [ f_type , unit_building ] ] ) do
6788: LD_ADDR_VAR 0 2
6792: PUSH
6793: LD_INT 22
6795: PUSH
6796: LD_VAR 0 3
6800: PUSH
6801: EMPTY
6802: LIST
6803: LIST
6804: PUSH
6805: LD_INT 21
6807: PUSH
6808: LD_INT 3
6810: PUSH
6811: EMPTY
6812: LIST
6813: LIST
6814: PUSH
6815: EMPTY
6816: LIST
6817: LIST
6818: PPUSH
6819: CALL_OW 69
6823: PUSH
6824: FOR_IN
6825: IFFALSE 6841
// SetBLevel ( i , 10 ) ;
6827: LD_VAR 0 2
6831: PPUSH
6832: LD_INT 10
6834: PPUSH
6835: CALL_OW 241
6839: GO 6824
6841: POP
6842: POP
// Schulz := NewCharacter ( Schulz ) ;
6843: LD_ADDR_EXP 51
6847: PUSH
6848: LD_STRING Schulz
6850: PPUSH
6851: CALL_OW 25
6855: ST_TO_ADDR
// Kozlov := PrepareUnit ( Kozlov , false ,  ) ;
6856: LD_ADDR_EXP 52
6860: PUSH
6861: LD_STRING Kozlov
6863: PPUSH
6864: LD_INT 0
6866: PPUSH
6867: LD_STRING 
6869: PPUSH
6870: CALL 50506 0 3
6874: ST_TO_ADDR
// PlaceHumanInUnit ( Kozlov , FilterAllUnits ( [ [ f_side , 8 ] , [ f_nation , 3 ] , [ f_btype , b_lab_full ] ] ) [ 1 ] ) ;
6875: LD_EXP 52
6879: PPUSH
6880: LD_INT 22
6882: PUSH
6883: LD_INT 8
6885: PUSH
6886: EMPTY
6887: LIST
6888: LIST
6889: PUSH
6890: LD_INT 23
6892: PUSH
6893: LD_INT 3
6895: PUSH
6896: EMPTY
6897: LIST
6898: LIST
6899: PUSH
6900: LD_INT 30
6902: PUSH
6903: LD_INT 8
6905: PUSH
6906: EMPTY
6907: LIST
6908: LIST
6909: PUSH
6910: EMPTY
6911: LIST
6912: LIST
6913: LIST
6914: PPUSH
6915: CALL_OW 69
6919: PUSH
6920: LD_INT 1
6922: ARRAY
6923: PPUSH
6924: CALL_OW 52
// SetSkill ( Kozlov , class_mechanic , 10 ) ;
6928: LD_EXP 52
6932: PPUSH
6933: LD_INT 3
6935: PPUSH
6936: LD_INT 10
6938: PPUSH
6939: CALL_OW 237
// tmp := FilterAllUnits ( [ [ f_side , side ] , [ f_btype , b_bunker ] , [ f_empty ] ] ) ;
6943: LD_ADDR_VAR 0 5
6947: PUSH
6948: LD_INT 22
6950: PUSH
6951: LD_VAR 0 3
6955: PUSH
6956: EMPTY
6957: LIST
6958: LIST
6959: PUSH
6960: LD_INT 30
6962: PUSH
6963: LD_INT 32
6965: PUSH
6966: EMPTY
6967: LIST
6968: LIST
6969: PUSH
6970: LD_INT 58
6972: PUSH
6973: EMPTY
6974: LIST
6975: PUSH
6976: EMPTY
6977: LIST
6978: LIST
6979: LIST
6980: PPUSH
6981: CALL_OW 69
6985: ST_TO_ADDR
// for i = 1 to 10 do
6986: LD_ADDR_VAR 0 2
6990: PUSH
6991: DOUBLE
6992: LD_INT 1
6994: DEC
6995: ST_TO_ADDR
6996: LD_INT 10
6998: PUSH
6999: FOR_TO
7000: IFFALSE 7072
// begin uc_nation := nation_nature ;
7002: LD_ADDR_OWVAR 21
7006: PUSH
7007: LD_INT 0
7009: ST_TO_ADDR
// hc_class := class_apeman_soldier ;
7010: LD_ADDR_OWVAR 28
7014: PUSH
7015: LD_INT 15
7017: ST_TO_ADDR
// hc_gallery :=  ;
7018: LD_ADDR_OWVAR 33
7022: PUSH
7023: LD_STRING 
7025: ST_TO_ADDR
// hc_name :=  ;
7026: LD_ADDR_OWVAR 26
7030: PUSH
7031: LD_STRING 
7033: ST_TO_ADDR
// un := CreateHuman ;
7034: LD_ADDR_VAR 0 4
7038: PUSH
7039: CALL_OW 44
7043: ST_TO_ADDR
// PlaceHumanInUnit ( un , tmp [ tmp - i ] ) ;
7044: LD_VAR 0 4
7048: PPUSH
7049: LD_VAR 0 5
7053: PUSH
7054: LD_VAR 0 5
7058: PUSH
7059: LD_VAR 0 2
7063: MINUS
7064: ARRAY
7065: PPUSH
7066: CALL_OW 52
// end ;
7070: GO 6999
7072: POP
7073: POP
// PrepareBase ( ar_depot1 , legionBaseArea ,  , [ 8 , 9 , 10 ] [ Difficulty ] , [ 3000 , 500 , 150 ] , [ 16 , 6 , 6 , 8 ] ) ;
7074: LD_INT 324
7076: PPUSH
7077: LD_INT 3
7079: PPUSH
7080: LD_STRING 
7082: PPUSH
7083: LD_INT 8
7085: PUSH
7086: LD_INT 9
7088: PUSH
7089: LD_INT 10
7091: PUSH
7092: EMPTY
7093: LIST
7094: LIST
7095: LIST
7096: PUSH
7097: LD_OWVAR 67
7101: ARRAY
7102: PPUSH
7103: LD_INT 3000
7105: PUSH
7106: LD_INT 500
7108: PUSH
7109: LD_INT 150
7111: PUSH
7112: EMPTY
7113: LIST
7114: LIST
7115: LIST
7116: PPUSH
7117: LD_INT 16
7119: PUSH
7120: LD_INT 6
7122: PUSH
7123: LD_INT 6
7125: PUSH
7126: LD_INT 8
7128: PUSH
7129: EMPTY
7130: LIST
7131: LIST
7132: LIST
7133: LIST
7134: PPUSH
7135: CALL 61030 0 6
// mc_bases := Replace ( mc_bases , 3 , FilterAllUnits ( [ [ f_side , side ] , [ f_nation , 2 ] , [ f_not , [ f_type , unit_vehicle ] ] ] ) diff Schulz ) ;
7139: LD_ADDR_EXP 76
7143: PUSH
7144: LD_EXP 76
7148: PPUSH
7149: LD_INT 3
7151: PPUSH
7152: LD_INT 22
7154: PUSH
7155: LD_VAR 0 3
7159: PUSH
7160: EMPTY
7161: LIST
7162: LIST
7163: PUSH
7164: LD_INT 23
7166: PUSH
7167: LD_INT 2
7169: PUSH
7170: EMPTY
7171: LIST
7172: LIST
7173: PUSH
7174: LD_INT 3
7176: PUSH
7177: LD_INT 21
7179: PUSH
7180: LD_INT 2
7182: PUSH
7183: EMPTY
7184: LIST
7185: LIST
7186: PUSH
7187: EMPTY
7188: LIST
7189: LIST
7190: PUSH
7191: EMPTY
7192: LIST
7193: LIST
7194: LIST
7195: PPUSH
7196: CALL_OW 69
7200: PUSH
7201: LD_EXP 51
7205: DIFF
7206: PPUSH
7207: CALL_OW 1
7211: ST_TO_ADDR
// end ;
7212: LD_VAR 0 1
7216: RET
// export function BuildKozlovBomb ; begin
7217: LD_INT 0
7219: PPUSH
// if not IsOk ( kozlov_fac ) or not IsOk ( kozlov_lab ) then
7220: LD_INT 332
7222: PPUSH
7223: CALL_OW 302
7227: NOT
7228: PUSH
7229: LD_INT 336
7231: PPUSH
7232: CALL_OW 302
7236: NOT
7237: OR
7238: IFFALSE 7242
// exit ;
7240: GO 7339
// ComChangeProfession ( Kozlov , 4 ) ;
7242: LD_EXP 52
7246: PPUSH
7247: LD_INT 4
7249: PPUSH
7250: CALL_OW 123
// ComResearch ( kozlov_lab , tech_sibFiss ) ;
7254: LD_INT 336
7256: PPUSH
7257: LD_INT 25
7259: PPUSH
7260: CALL_OW 124
// repeat wait ( 0 0$1 ) ;
7264: LD_INT 35
7266: PPUSH
7267: CALL_OW 67
// until GetTech ( tech_sibFiss , 8 ) = state_researched ;
7271: LD_INT 25
7273: PPUSH
7274: LD_INT 8
7276: PPUSH
7277: CALL_OW 321
7281: PUSH
7282: LD_INT 2
7284: EQUAL
7285: IFFALSE 7264
// ComExitBuilding ( Kozlov ) ;
7287: LD_EXP 52
7291: PPUSH
7292: CALL_OW 122
// AddComEnterUnit ( Kozlov , kozlov_fac ) ;
7296: LD_EXP 52
7300: PPUSH
7301: LD_INT 332
7303: PPUSH
7304: CALL_OW 180
// AddComChangeProfession ( Kozlov , 3 ) ;
7308: LD_EXP 52
7312: PPUSH
7313: LD_INT 3
7315: PPUSH
7316: CALL_OW 183
// ComConstruct ( kozlov_fac , ru_heavy_wheeled , engine_siberite , control_manual , ru_siberium_rocket ) ;
7320: LD_INT 332
7322: PPUSH
7323: LD_INT 23
7325: PPUSH
7326: LD_INT 3
7328: PPUSH
7329: LD_INT 1
7331: PPUSH
7332: LD_INT 48
7334: PPUSH
7335: CALL_OW 125
// end ;
7339: LD_VAR 0 1
7343: RET
// every 11 11$30 trigger not legionDestroyed and not MC_GetVehicles ( 3 , true ) do var i , tmp , target ;
7344: LD_EXP 3
7348: NOT
7349: PUSH
7350: LD_INT 3
7352: PPUSH
7353: LD_INT 1
7355: PPUSH
7356: CALL 45580 0 2
7360: NOT
7361: AND
7362: IFFALSE 8202
7364: GO 7366
7366: DISABLE
7367: LD_INT 0
7369: PPUSH
7370: PPUSH
7371: PPUSH
// begin enable ;
7372: ENABLE
// if not FilterAllUnits ( [ [ f_side , 8 ] , [ f_nation , 2 ] , [ f_btype , b_factory ] ] ) then
7373: LD_INT 22
7375: PUSH
7376: LD_INT 8
7378: PUSH
7379: EMPTY
7380: LIST
7381: LIST
7382: PUSH
7383: LD_INT 23
7385: PUSH
7386: LD_INT 2
7388: PUSH
7389: EMPTY
7390: LIST
7391: LIST
7392: PUSH
7393: LD_INT 30
7395: PUSH
7396: LD_INT 3
7398: PUSH
7399: EMPTY
7400: LIST
7401: LIST
7402: PUSH
7403: EMPTY
7404: LIST
7405: LIST
7406: LIST
7407: PPUSH
7408: CALL_OW 69
7412: NOT
7413: IFFALSE 7417
// exit ;
7415: GO 8202
// if Prob ( 40 ) then
7417: LD_INT 40
7419: PPUSH
7420: CALL_OW 13
7424: IFFALSE 7551
// begin MC_InsertProduceList ( 3 , [ [ ar_half_tracked , engine_combustion , control_remote , ar_rocket_launcher ] , [ ar_half_tracked , engine_combustion , control_remote , ar_rocket_launcher ] , [ ar_half_tracked , engine_combustion , control_remote , ar_rocket_launcher ] , [ ar_half_tracked , engine_combustion , control_remote , ar_rocket_launcher ] , [ ar_half_tracked , engine_combustion , control_remote , ar_rocket_launcher ] , [ ar_half_tracked , engine_combustion , control_remote , ar_flame_thrower ] , ] ) ;
7426: LD_INT 3
7428: PPUSH
7429: LD_INT 14
7431: PUSH
7432: LD_INT 1
7434: PUSH
7435: LD_INT 2
7437: PUSH
7438: LD_INT 28
7440: PUSH
7441: EMPTY
7442: LIST
7443: LIST
7444: LIST
7445: LIST
7446: PUSH
7447: LD_INT 14
7449: PUSH
7450: LD_INT 1
7452: PUSH
7453: LD_INT 2
7455: PUSH
7456: LD_INT 28
7458: PUSH
7459: EMPTY
7460: LIST
7461: LIST
7462: LIST
7463: LIST
7464: PUSH
7465: LD_INT 14
7467: PUSH
7468: LD_INT 1
7470: PUSH
7471: LD_INT 2
7473: PUSH
7474: LD_INT 28
7476: PUSH
7477: EMPTY
7478: LIST
7479: LIST
7480: LIST
7481: LIST
7482: PUSH
7483: LD_INT 14
7485: PUSH
7486: LD_INT 1
7488: PUSH
7489: LD_INT 2
7491: PUSH
7492: LD_INT 28
7494: PUSH
7495: EMPTY
7496: LIST
7497: LIST
7498: LIST
7499: LIST
7500: PUSH
7501: LD_INT 14
7503: PUSH
7504: LD_INT 1
7506: PUSH
7507: LD_INT 2
7509: PUSH
7510: LD_INT 28
7512: PUSH
7513: EMPTY
7514: LIST
7515: LIST
7516: LIST
7517: LIST
7518: PUSH
7519: LD_INT 14
7521: PUSH
7522: LD_INT 1
7524: PUSH
7525: LD_INT 2
7527: PUSH
7528: LD_INT 26
7530: PUSH
7531: EMPTY
7532: LIST
7533: LIST
7534: LIST
7535: LIST
7536: PUSH
7537: EMPTY
7538: LIST
7539: LIST
7540: LIST
7541: LIST
7542: LIST
7543: LIST
7544: PPUSH
7545: CALL 44162 0 2
// end else
7549: GO 7742
// begin MC_InsertProduceList ( 3 , [ [ ar_half_tracked , engine_combustion , control_remote , [ ar_gun , ar_flame_thrower , ar_flame_thrower ] [ Difficulty ] ] , [ ar_half_tracked , engine_combustion , control_remote , [ ar_gun , ar_flame_thrower , ar_flame_thrower ] [ Difficulty ] ] , [ ar_half_tracked , engine_combustion , control_remote , [ ar_flame_thrower , ar_flame_thrower , ar_selfpropelled_bomb ] [ Difficulty ] ] , [ ar_medium_trike , engine_combustion , control_remote , [ ar_flame_thrower , ar_selfpropelled_bomb , ar_selfpropelled_bomb ] [ Difficulty ] ] , [ ar_medium_trike , engine_combustion , control_remote , ar_selfpropelled_bomb ] , [ ar_half_tracked , engine_combustion , control_remote , ar_flame_thrower ] , ] ) ;
7551: LD_INT 3
7553: PPUSH
7554: LD_INT 14
7556: PUSH
7557: LD_INT 1
7559: PUSH
7560: LD_INT 2
7562: PUSH
7563: LD_INT 27
7565: PUSH
7566: LD_INT 26
7568: PUSH
7569: LD_INT 26
7571: PUSH
7572: EMPTY
7573: LIST
7574: LIST
7575: LIST
7576: PUSH
7577: LD_OWVAR 67
7581: ARRAY
7582: PUSH
7583: EMPTY
7584: LIST
7585: LIST
7586: LIST
7587: LIST
7588: PUSH
7589: LD_INT 14
7591: PUSH
7592: LD_INT 1
7594: PUSH
7595: LD_INT 2
7597: PUSH
7598: LD_INT 27
7600: PUSH
7601: LD_INT 26
7603: PUSH
7604: LD_INT 26
7606: PUSH
7607: EMPTY
7608: LIST
7609: LIST
7610: LIST
7611: PUSH
7612: LD_OWVAR 67
7616: ARRAY
7617: PUSH
7618: EMPTY
7619: LIST
7620: LIST
7621: LIST
7622: LIST
7623: PUSH
7624: LD_INT 14
7626: PUSH
7627: LD_INT 1
7629: PUSH
7630: LD_INT 2
7632: PUSH
7633: LD_INT 26
7635: PUSH
7636: LD_INT 26
7638: PUSH
7639: LD_INT 29
7641: PUSH
7642: EMPTY
7643: LIST
7644: LIST
7645: LIST
7646: PUSH
7647: LD_OWVAR 67
7651: ARRAY
7652: PUSH
7653: EMPTY
7654: LIST
7655: LIST
7656: LIST
7657: LIST
7658: PUSH
7659: LD_INT 13
7661: PUSH
7662: LD_INT 1
7664: PUSH
7665: LD_INT 2
7667: PUSH
7668: LD_INT 26
7670: PUSH
7671: LD_INT 29
7673: PUSH
7674: LD_INT 29
7676: PUSH
7677: EMPTY
7678: LIST
7679: LIST
7680: LIST
7681: PUSH
7682: LD_OWVAR 67
7686: ARRAY
7687: PUSH
7688: EMPTY
7689: LIST
7690: LIST
7691: LIST
7692: LIST
7693: PUSH
7694: LD_INT 13
7696: PUSH
7697: LD_INT 1
7699: PUSH
7700: LD_INT 2
7702: PUSH
7703: LD_INT 29
7705: PUSH
7706: EMPTY
7707: LIST
7708: LIST
7709: LIST
7710: LIST
7711: PUSH
7712: LD_INT 14
7714: PUSH
7715: LD_INT 1
7717: PUSH
7718: LD_INT 2
7720: PUSH
7721: LD_INT 26
7723: PUSH
7724: EMPTY
7725: LIST
7726: LIST
7727: LIST
7728: LIST
7729: PUSH
7730: EMPTY
7731: LIST
7732: LIST
7733: LIST
7734: LIST
7735: LIST
7736: LIST
7737: PPUSH
7738: CALL 44162 0 2
// end ; repeat wait ( 0 0$1 ) ;
7742: LD_INT 35
7744: PPUSH
7745: CALL_OW 67
// until MC_GetVehicles ( 3 , true ) >= 6 ;
7749: LD_INT 3
7751: PPUSH
7752: LD_INT 1
7754: PPUSH
7755: CALL 45580 0 2
7759: PUSH
7760: LD_INT 6
7762: GREATEREQUAL
7763: IFFALSE 7742
// wait ( 0 0$30 ) ;
7765: LD_INT 1050
7767: PPUSH
7768: CALL_OW 67
// tmp := MC_GetVehicles ( 3 , true ) ;
7772: LD_ADDR_VAR 0 2
7776: PUSH
7777: LD_INT 3
7779: PPUSH
7780: LD_INT 1
7782: PPUSH
7783: CALL 45580 0 2
7787: ST_TO_ADDR
// mc_vehicles := Replace ( mc_vehicles , 3 , mc_vehicles [ 3 ] diff tmp ) ;
7788: LD_ADDR_EXP 95
7792: PUSH
7793: LD_EXP 95
7797: PPUSH
7798: LD_INT 3
7800: PPUSH
7801: LD_EXP 95
7805: PUSH
7806: LD_INT 3
7808: ARRAY
7809: PUSH
7810: LD_VAR 0 2
7814: DIFF
7815: PPUSH
7816: CALL_OW 1
7820: ST_TO_ADDR
// target := rand ( 0 , 2 ) ;
7821: LD_ADDR_VAR 0 3
7825: PUSH
7826: LD_INT 0
7828: PPUSH
7829: LD_INT 2
7831: PPUSH
7832: CALL_OW 12
7836: ST_TO_ADDR
// if target then
7837: LD_VAR 0 3
7841: IFFALSE 7969
// begin repeat tmp := UnitFilter ( tmp , [ f_lives , 250 ] ) ;
7843: LD_ADDR_VAR 0 2
7847: PUSH
7848: LD_VAR 0 2
7852: PPUSH
7853: LD_INT 24
7855: PUSH
7856: LD_INT 250
7858: PUSH
7859: EMPTY
7860: LIST
7861: LIST
7862: PPUSH
7863: CALL_OW 72
7867: ST_TO_ADDR
// for i in tmp do
7868: LD_ADDR_VAR 0 1
7872: PUSH
7873: LD_VAR 0 2
7877: PUSH
7878: FOR_IN
7879: IFFALSE 7919
// if GetDistUnitXY ( i , 89 , 71 ) > 9 then
7881: LD_VAR 0 1
7885: PPUSH
7886: LD_INT 89
7888: PPUSH
7889: LD_INT 71
7891: PPUSH
7892: CALL_OW 297
7896: PUSH
7897: LD_INT 9
7899: GREATER
7900: IFFALSE 7917
// ComMoveXY ( i , 89 , 71 ) ;
7902: LD_VAR 0 1
7906: PPUSH
7907: LD_INT 89
7909: PPUSH
7910: LD_INT 71
7912: PPUSH
7913: CALL_OW 111
7917: GO 7878
7919: POP
7920: POP
// wait ( 0 0$1 ) ;
7921: LD_INT 35
7923: PPUSH
7924: CALL_OW 67
// until UnitFilter ( tmp , [ f_distxy , 89 , 71 , 9 ] ) >= ( tmp - 1 ) ;
7928: LD_VAR 0 2
7932: PPUSH
7933: LD_INT 92
7935: PUSH
7936: LD_INT 89
7938: PUSH
7939: LD_INT 71
7941: PUSH
7942: LD_INT 9
7944: PUSH
7945: EMPTY
7946: LIST
7947: LIST
7948: LIST
7949: LIST
7950: PPUSH
7951: CALL_OW 72
7955: PUSH
7956: LD_VAR 0 2
7960: PUSH
7961: LD_INT 1
7963: MINUS
7964: GREATEREQUAL
7965: IFFALSE 7843
// end else
7967: GO 8093
// begin repeat tmp := UnitFilter ( tmp , [ f_lives , 250 ] ) ;
7969: LD_ADDR_VAR 0 2
7973: PUSH
7974: LD_VAR 0 2
7978: PPUSH
7979: LD_INT 24
7981: PUSH
7982: LD_INT 250
7984: PUSH
7985: EMPTY
7986: LIST
7987: LIST
7988: PPUSH
7989: CALL_OW 72
7993: ST_TO_ADDR
// for i in tmp do
7994: LD_ADDR_VAR 0 1
7998: PUSH
7999: LD_VAR 0 2
8003: PUSH
8004: FOR_IN
8005: IFFALSE 8045
// if GetDistUnitXY ( i , 147 , 4 ) > 9 then
8007: LD_VAR 0 1
8011: PPUSH
8012: LD_INT 147
8014: PPUSH
8015: LD_INT 4
8017: PPUSH
8018: CALL_OW 297
8022: PUSH
8023: LD_INT 9
8025: GREATER
8026: IFFALSE 8043
// ComMoveXY ( i , 147 , 4 ) ;
8028: LD_VAR 0 1
8032: PPUSH
8033: LD_INT 147
8035: PPUSH
8036: LD_INT 4
8038: PPUSH
8039: CALL_OW 111
8043: GO 8004
8045: POP
8046: POP
// wait ( 0 0$1 ) ;
8047: LD_INT 35
8049: PPUSH
8050: CALL_OW 67
// until UnitFilter ( tmp , [ f_distxy , 147 , 4 , 9 ] ) >= ( tmp - 1 ) ;
8054: LD_VAR 0 2
8058: PPUSH
8059: LD_INT 92
8061: PUSH
8062: LD_INT 147
8064: PUSH
8065: LD_INT 4
8067: PUSH
8068: LD_INT 9
8070: PUSH
8071: EMPTY
8072: LIST
8073: LIST
8074: LIST
8075: LIST
8076: PPUSH
8077: CALL_OW 72
8081: PUSH
8082: LD_VAR 0 2
8086: PUSH
8087: LD_INT 1
8089: MINUS
8090: GREATEREQUAL
8091: IFFALSE 7969
// end ; repeat wait ( 0 0$1 ) ;
8093: LD_INT 35
8095: PPUSH
8096: CALL_OW 67
// for i in tmp do
8100: LD_ADDR_VAR 0 1
8104: PUSH
8105: LD_VAR 0 2
8109: PUSH
8110: FOR_IN
8111: IFFALSE 8193
// begin if GetLives ( i ) > 251 then
8113: LD_VAR 0 1
8117: PPUSH
8118: CALL_OW 256
8122: PUSH
8123: LD_INT 251
8125: GREATER
8126: IFFALSE 8164
// ComAttackUnit ( i , NearestUnitToUnit ( FilterAllUnits ( [ f_enemy , 8 ] ) , i ) ) else
8128: LD_VAR 0 1
8132: PPUSH
8133: LD_INT 81
8135: PUSH
8136: LD_INT 8
8138: PUSH
8139: EMPTY
8140: LIST
8141: LIST
8142: PPUSH
8143: CALL_OW 69
8147: PPUSH
8148: LD_VAR 0 1
8152: PPUSH
8153: CALL_OW 74
8157: PPUSH
8158: CALL_OW 115
8162: GO 8191
// if IsDead ( i ) then
8164: LD_VAR 0 1
8168: PPUSH
8169: CALL_OW 301
8173: IFFALSE 8191
// tmp := tmp diff i ;
8175: LD_ADDR_VAR 0 2
8179: PUSH
8180: LD_VAR 0 2
8184: PUSH
8185: LD_VAR 0 1
8189: DIFF
8190: ST_TO_ADDR
// end ;
8191: GO 8110
8193: POP
8194: POP
// until not tmp ;
8195: LD_VAR 0 2
8199: NOT
8200: IFFALSE 8093
// end ;
8202: PPOPN 3
8204: END
// every 0 0$1 trigger IsOk ( Kozlov ) and not legionDestroyed do
8205: LD_EXP 52
8209: PPUSH
8210: CALL_OW 302
8214: PUSH
8215: LD_EXP 3
8219: NOT
8220: AND
8221: IFFALSE 8230
8223: GO 8225
8225: DISABLE
// BuildKozlovBomb ;
8226: CALL 7217 0 0
8230: END
// every 0 0$3 trigger FilterAllUnits ( [ [ f_side , 8 ] , [ f_weapon , ru_siberium_rocket ] ] ) do
8231: LD_INT 22
8233: PUSH
8234: LD_INT 8
8236: PUSH
8237: EMPTY
8238: LIST
8239: LIST
8240: PUSH
8241: LD_INT 34
8243: PUSH
8244: LD_INT 48
8246: PUSH
8247: EMPTY
8248: LIST
8249: LIST
8250: PUSH
8251: EMPTY
8252: LIST
8253: LIST
8254: PPUSH
8255: CALL_OW 69
8259: IFFALSE 8307
8261: GO 8263
8263: DISABLE
// begin ComAttackPlace ( FilterAllUnits ( [ [ f_side , 8 ] , [ f_weapon , ru_siberium_rocket ] ] ) [ 1 ] , 173 , 96 ) ;
8264: LD_INT 22
8266: PUSH
8267: LD_INT 8
8269: PUSH
8270: EMPTY
8271: LIST
8272: LIST
8273: PUSH
8274: LD_INT 34
8276: PUSH
8277: LD_INT 48
8279: PUSH
8280: EMPTY
8281: LIST
8282: LIST
8283: PUSH
8284: EMPTY
8285: LIST
8286: LIST
8287: PPUSH
8288: CALL_OW 69
8292: PUSH
8293: LD_INT 1
8295: ARRAY
8296: PPUSH
8297: LD_INT 173
8299: PPUSH
8300: LD_INT 96
8302: PPUSH
8303: CALL_OW 116
// end ; end_of_file
8307: END
// export Platonov , Yakotich , Gleb , Bierezov ; export behemoths , behemothBuilders ; export function PrepareRussian ; var i , j , base , tmp , side , xy , b , teleport ; begin
8308: LD_INT 0
8310: PPUSH
8311: PPUSH
8312: PPUSH
8313: PPUSH
8314: PPUSH
8315: PPUSH
8316: PPUSH
8317: PPUSH
8318: PPUSH
// side := 3 ;
8319: LD_ADDR_VAR 0 6
8323: PUSH
8324: LD_INT 3
8326: ST_TO_ADDR
// InitHc ;
8327: CALL_OW 19
// uc_side := side ;
8331: LD_ADDR_OWVAR 20
8335: PUSH
8336: LD_VAR 0 6
8340: ST_TO_ADDR
// uc_nation := 3 ;
8341: LD_ADDR_OWVAR 21
8345: PUSH
8346: LD_INT 3
8348: ST_TO_ADDR
// for i in FilterAllUnits ( [ [ f_side , side ] , [ f_type , unit_building ] ] ) do
8349: LD_ADDR_VAR 0 2
8353: PUSH
8354: LD_INT 22
8356: PUSH
8357: LD_VAR 0 6
8361: PUSH
8362: EMPTY
8363: LIST
8364: LIST
8365: PUSH
8366: LD_INT 21
8368: PUSH
8369: LD_INT 3
8371: PUSH
8372: EMPTY
8373: LIST
8374: LIST
8375: PUSH
8376: EMPTY
8377: LIST
8378: LIST
8379: PPUSH
8380: CALL_OW 69
8384: PUSH
8385: FOR_IN
8386: IFFALSE 8402
// SetBLevel ( i , 10 ) ;
8388: LD_VAR 0 2
8392: PPUSH
8393: LD_INT 10
8395: PPUSH
8396: CALL_OW 241
8400: GO 8385
8402: POP
8403: POP
// teleport := FilterAllUnits ( [ [ f_side , side ] , [ f_btype , b_teleport ] ] ) ;
8404: LD_ADDR_VAR 0 9
8408: PUSH
8409: LD_INT 22
8411: PUSH
8412: LD_VAR 0 6
8416: PUSH
8417: EMPTY
8418: LIST
8419: LIST
8420: PUSH
8421: LD_INT 30
8423: PUSH
8424: LD_INT 34
8426: PUSH
8427: EMPTY
8428: LIST
8429: LIST
8430: PUSH
8431: EMPTY
8432: LIST
8433: LIST
8434: PPUSH
8435: CALL_OW 69
8439: ST_TO_ADDR
// if teleport then
8440: LD_VAR 0 9
8444: IFFALSE 8465
// TeleportExit ( teleport [ 1 ] , 123 , 122 ) ;
8446: LD_VAR 0 9
8450: PUSH
8451: LD_INT 1
8453: ARRAY
8454: PPUSH
8455: LD_INT 123
8457: PPUSH
8458: LD_INT 122
8460: PPUSH
8461: CALL_OW 243
// hc_importance := 0 ;
8465: LD_ADDR_OWVAR 32
8469: PUSH
8470: LD_INT 0
8472: ST_TO_ADDR
// Platonov := NewCharacter ( Platonov ) ;
8473: LD_ADDR_EXP 53
8477: PUSH
8478: LD_STRING Platonov
8480: PPUSH
8481: CALL_OW 25
8485: ST_TO_ADDR
// Yakotich := NewCharacter ( Yakotich ) ;
8486: LD_ADDR_EXP 54
8490: PUSH
8491: LD_STRING Yakotich
8493: PPUSH
8494: CALL_OW 25
8498: ST_TO_ADDR
// Gleb := NewCharacter ( Gleb ) ;
8499: LD_ADDR_EXP 55
8503: PUSH
8504: LD_STRING Gleb
8506: PPUSH
8507: CALL_OW 25
8511: ST_TO_ADDR
// if TestCharacters ( 03_Cornel ) then
8512: LD_STRING 03_Cornel
8514: PPUSH
8515: CALL_OW 28
8519: IFFALSE 8567
// begin Bierezov := NewCharacter ( Mikhail ) ;
8521: LD_ADDR_EXP 56
8525: PUSH
8526: LD_STRING Mikhail
8528: PPUSH
8529: CALL_OW 25
8533: ST_TO_ADDR
// PlaceUnitXYR ( Bierezov , 197 , 111 , 9 , false ) ;
8534: LD_EXP 56
8538: PPUSH
8539: LD_INT 197
8541: PPUSH
8542: LD_INT 111
8544: PPUSH
8545: LD_INT 9
8547: PPUSH
8548: LD_INT 0
8550: PPUSH
8551: CALL_OW 50
// SetClass ( Bierezov , 3 ) ;
8555: LD_EXP 56
8559: PPUSH
8560: LD_INT 3
8562: PPUSH
8563: CALL_OW 336
// end ; PlaceHumanInUnit ( Platonov , ru_depot ) ;
8567: LD_EXP 53
8571: PPUSH
8572: LD_INT 126
8574: PPUSH
8575: CALL_OW 52
// PlaceUnitXYR ( Yakotich , 197 , 111 , 9 , false ) ;
8579: LD_EXP 54
8583: PPUSH
8584: LD_INT 197
8586: PPUSH
8587: LD_INT 111
8589: PPUSH
8590: LD_INT 9
8592: PPUSH
8593: LD_INT 0
8595: PPUSH
8596: CALL_OW 50
// PlaceUnitXYR ( Gleb , 197 , 111 , 9 , false ) ;
8600: LD_EXP 55
8604: PPUSH
8605: LD_INT 197
8607: PPUSH
8608: LD_INT 111
8610: PPUSH
8611: LD_INT 9
8613: PPUSH
8614: LD_INT 0
8616: PPUSH
8617: CALL_OW 50
// tmp := PrepareBase ( ru_depot , russianBaseArea , zhukov , [ 9 , 10 , 10 ] [ Difficulty ] , [ 90000 , 1000 , 300 ] , [ 21 , 8 , 13 , 8 ] ) ;
8621: LD_ADDR_VAR 0 5
8625: PUSH
8626: LD_INT 126
8628: PPUSH
8629: LD_INT 2
8631: PPUSH
8632: LD_STRING zhukov
8634: PPUSH
8635: LD_INT 9
8637: PUSH
8638: LD_INT 10
8640: PUSH
8641: LD_INT 10
8643: PUSH
8644: EMPTY
8645: LIST
8646: LIST
8647: LIST
8648: PUSH
8649: LD_OWVAR 67
8653: ARRAY
8654: PPUSH
8655: LD_INT 90000
8657: PUSH
8658: LD_INT 1000
8660: PUSH
8661: LD_INT 300
8663: PUSH
8664: EMPTY
8665: LIST
8666: LIST
8667: LIST
8668: PPUSH
8669: LD_INT 21
8671: PUSH
8672: LD_INT 8
8674: PUSH
8675: LD_INT 13
8677: PUSH
8678: LD_INT 8
8680: PUSH
8681: EMPTY
8682: LIST
8683: LIST
8684: LIST
8685: LIST
8686: PPUSH
8687: CALL 61030 0 6
8691: ST_TO_ADDR
// base := GetBase ( ru_depot2 ) ;
8692: LD_ADDR_VAR 0 4
8696: PUSH
8697: LD_INT 267
8699: PPUSH
8700: CALL_OW 274
8704: ST_TO_ADDR
// SetResourceType ( base , mat_cans , 5000 ) ;
8705: LD_VAR 0 4
8709: PPUSH
8710: LD_INT 1
8712: PPUSH
8713: LD_INT 5000
8715: PPUSH
8716: CALL_OW 277
// SetResourceType ( base , mat_oil , 200 ) ;
8720: LD_VAR 0 4
8724: PPUSH
8725: LD_INT 2
8727: PPUSH
8728: LD_INT 200
8730: PPUSH
8731: CALL_OW 277
// SetResourceType ( base , mat_siberit , 200 ) ;
8735: LD_VAR 0 4
8739: PPUSH
8740: LD_INT 3
8742: PPUSH
8743: LD_INT 200
8745: PPUSH
8746: CALL_OW 277
// mc_bases := Replace ( mc_bases , 2 , tmp union FilterAllUnits ( [ [ f_side , side ] , [ f_not , [ f_type , unit_vehicle ] ] ] ) diff Platonov ) ;
8750: LD_ADDR_EXP 76
8754: PUSH
8755: LD_EXP 76
8759: PPUSH
8760: LD_INT 2
8762: PPUSH
8763: LD_VAR 0 5
8767: PUSH
8768: LD_INT 22
8770: PUSH
8771: LD_VAR 0 6
8775: PUSH
8776: EMPTY
8777: LIST
8778: LIST
8779: PUSH
8780: LD_INT 3
8782: PUSH
8783: LD_INT 21
8785: PUSH
8786: LD_INT 2
8788: PUSH
8789: EMPTY
8790: LIST
8791: LIST
8792: PUSH
8793: EMPTY
8794: LIST
8795: LIST
8796: PUSH
8797: EMPTY
8798: LIST
8799: LIST
8800: PPUSH
8801: CALL_OW 69
8805: UNION
8806: PUSH
8807: LD_EXP 53
8811: DIFF
8812: PPUSH
8813: CALL_OW 1
8817: ST_TO_ADDR
// behemoths := [ ] ;
8818: LD_ADDR_EXP 57
8822: PUSH
8823: EMPTY
8824: ST_TO_ADDR
// behemothBuilders := [ ] ;
8825: LD_ADDR_EXP 58
8829: PUSH
8830: EMPTY
8831: ST_TO_ADDR
// j := 3 ;
8832: LD_ADDR_VAR 0 3
8836: PUSH
8837: LD_INT 3
8839: ST_TO_ADDR
// for i in FilterAllUnits ( [ [ f_side , 3 ] , [ f_class , 3 ] ] ) do
8840: LD_ADDR_VAR 0 2
8844: PUSH
8845: LD_INT 22
8847: PUSH
8848: LD_INT 3
8850: PUSH
8851: EMPTY
8852: LIST
8853: LIST
8854: PUSH
8855: LD_INT 25
8857: PUSH
8858: LD_INT 3
8860: PUSH
8861: EMPTY
8862: LIST
8863: LIST
8864: PUSH
8865: EMPTY
8866: LIST
8867: LIST
8868: PPUSH
8869: CALL_OW 69
8873: PUSH
8874: FOR_IN
8875: IFFALSE 8925
// begin behemothBuilders := Join ( behemothBuilders , i ) ;
8877: LD_ADDR_EXP 58
8881: PUSH
8882: LD_EXP 58
8886: PPUSH
8887: LD_VAR 0 2
8891: PPUSH
8892: CALL 93369 0 2
8896: ST_TO_ADDR
// j := j - 1 ;
8897: LD_ADDR_VAR 0 3
8901: PUSH
8902: LD_VAR 0 3
8906: PUSH
8907: LD_INT 1
8909: MINUS
8910: ST_TO_ADDR
// if j = 0 then
8911: LD_VAR 0 3
8915: PUSH
8916: LD_INT 0
8918: EQUAL
8919: IFFALSE 8923
// break ;
8921: GO 8925
// end ;
8923: GO 8874
8925: POP
8926: POP
// end ;
8927: LD_VAR 0 1
8931: RET
// export function BuildBehemoths ; var i , j , xy , tmp ; begin
8932: LD_INT 0
8934: PPUSH
8935: PPUSH
8936: PPUSH
8937: PPUSH
8938: PPUSH
// xy := [ [ 209 , 149 ] , [ 219 , 154 ] , [ 223 , 149 ] , [ 232 , 155 ] ] ;
8939: LD_ADDR_VAR 0 4
8943: PUSH
8944: LD_INT 209
8946: PUSH
8947: LD_INT 149
8949: PUSH
8950: EMPTY
8951: LIST
8952: LIST
8953: PUSH
8954: LD_INT 219
8956: PUSH
8957: LD_INT 154
8959: PUSH
8960: EMPTY
8961: LIST
8962: LIST
8963: PUSH
8964: LD_INT 223
8966: PUSH
8967: LD_INT 149
8969: PUSH
8970: EMPTY
8971: LIST
8972: LIST
8973: PUSH
8974: LD_INT 232
8976: PUSH
8977: LD_INT 155
8979: PUSH
8980: EMPTY
8981: LIST
8982: LIST
8983: PUSH
8984: EMPTY
8985: LIST
8986: LIST
8987: LIST
8988: LIST
8989: ST_TO_ADDR
// if not behemothBuilders then
8990: LD_EXP 58
8994: NOT
8995: IFFALSE 8999
// exit ;
8997: GO 9103
// j := 1 ;
8999: LD_ADDR_VAR 0 3
9003: PUSH
9004: LD_INT 1
9006: ST_TO_ADDR
// for i in behemothBuilders do
9007: LD_ADDR_VAR 0 2
9011: PUSH
9012: LD_EXP 58
9016: PUSH
9017: FOR_IN
9018: IFFALSE 9101
// begin if IsInUnit ( i ) then
9020: LD_VAR 0 2
9024: PPUSH
9025: CALL_OW 310
9029: IFFALSE 9040
// ComExitBuilding ( i ) ;
9031: LD_VAR 0 2
9035: PPUSH
9036: CALL_OW 122
// AddComBuildBehemoth ( i , b_behemoth , xy [ j ] [ 1 ] , xy [ j ] [ 2 ] , 0 ) ;
9040: LD_VAR 0 2
9044: PPUSH
9045: LD_INT 37
9047: PPUSH
9048: LD_VAR 0 4
9052: PUSH
9053: LD_VAR 0 3
9057: ARRAY
9058: PUSH
9059: LD_INT 1
9061: ARRAY
9062: PPUSH
9063: LD_VAR 0 4
9067: PUSH
9068: LD_VAR 0 3
9072: ARRAY
9073: PUSH
9074: LD_INT 2
9076: ARRAY
9077: PPUSH
9078: LD_INT 0
9080: PPUSH
9081: CALL_OW 230
// j := j + 1 ;
9085: LD_ADDR_VAR 0 3
9089: PUSH
9090: LD_VAR 0 3
9094: PUSH
9095: LD_INT 1
9097: PLUS
9098: ST_TO_ADDR
// end ;
9099: GO 9017
9101: POP
9102: POP
// end ;
9103: LD_VAR 0 1
9107: RET
// every 0 0$3 trigger GetBehemoths ( 3 ) and not FilterAllUnits ( [ [ f_side , 3 ] , [ f_btype , b_behemoth ] ] ) do var i , tmp ;
9108: LD_INT 3
9110: PPUSH
9111: CALL 93417 0 1
9115: PUSH
9116: LD_INT 22
9118: PUSH
9119: LD_INT 3
9121: PUSH
9122: EMPTY
9123: LIST
9124: LIST
9125: PUSH
9126: LD_INT 30
9128: PUSH
9129: LD_INT 37
9131: PUSH
9132: EMPTY
9133: LIST
9134: LIST
9135: PUSH
9136: EMPTY
9137: LIST
9138: LIST
9139: PPUSH
9140: CALL_OW 69
9144: NOT
9145: AND
9146: IFFALSE 9332
9148: GO 9150
9150: DISABLE
9151: LD_INT 0
9153: PPUSH
9154: PPUSH
// begin enable ;
9155: ENABLE
// tmp := GetBehemoths ( 3 ) ;
9156: LD_ADDR_VAR 0 2
9160: PUSH
9161: LD_INT 3
9163: PPUSH
9164: CALL 93417 0 1
9168: ST_TO_ADDR
// for i in tmp do
9169: LD_ADDR_VAR 0 1
9173: PUSH
9174: LD_VAR 0 2
9178: PUSH
9179: FOR_IN
9180: IFFALSE 9330
// begin if IsInArea ( i , powellBase ) and not GetTag ( i ) = 2 then
9182: LD_VAR 0 1
9186: PPUSH
9187: LD_INT 7
9189: PPUSH
9190: CALL_OW 308
9194: PUSH
9195: LD_VAR 0 1
9199: PPUSH
9200: CALL_OW 110
9204: PUSH
9205: LD_INT 2
9207: EQUAL
9208: NOT
9209: AND
9210: IFFALSE 9224
// SetTag ( i , 2 ) ;
9212: LD_VAR 0 1
9216: PPUSH
9217: LD_INT 2
9219: PPUSH
9220: CALL_OW 109
// if not FilterAllUnits ( [ [ f_enemy , 3 ] , [ f_dist , i , 12 ] ] ) and not GetTag ( i ) = 2 then
9224: LD_INT 81
9226: PUSH
9227: LD_INT 3
9229: PUSH
9230: EMPTY
9231: LIST
9232: LIST
9233: PUSH
9234: LD_INT 91
9236: PUSH
9237: LD_VAR 0 1
9241: PUSH
9242: LD_INT 12
9244: PUSH
9245: EMPTY
9246: LIST
9247: LIST
9248: LIST
9249: PUSH
9250: EMPTY
9251: LIST
9252: LIST
9253: PPUSH
9254: CALL_OW 69
9258: NOT
9259: PUSH
9260: LD_VAR 0 1
9264: PPUSH
9265: CALL_OW 110
9269: PUSH
9270: LD_INT 2
9272: EQUAL
9273: NOT
9274: AND
9275: IFFALSE 9294
// ComAgressiveMove ( i , 64 , 93 ) else
9277: LD_VAR 0 1
9281: PPUSH
9282: LD_INT 64
9284: PPUSH
9285: LD_INT 93
9287: PPUSH
9288: CALL_OW 114
9292: GO 9328
// ComAttackUnit ( i , NearestUnitToUnit ( FilterAllUnits ( [ f_enemy , 3 ] ) , i ) ) ;
9294: LD_VAR 0 1
9298: PPUSH
9299: LD_INT 81
9301: PUSH
9302: LD_INT 3
9304: PUSH
9305: EMPTY
9306: LIST
9307: LIST
9308: PPUSH
9309: CALL_OW 69
9313: PPUSH
9314: LD_VAR 0 1
9318: PPUSH
9319: CALL_OW 74
9323: PPUSH
9324: CALL_OW 115
// end ;
9328: GO 9179
9330: POP
9331: POP
// end ;
9332: PPOPN 2
9334: END
// every 11 11$30 trigger not russianDestroyed and not MC_GetVehicles ( 2 , true ) do var i , tmp , target , teleport ;
9335: LD_EXP 2
9339: NOT
9340: PUSH
9341: LD_INT 2
9343: PPUSH
9344: LD_INT 1
9346: PPUSH
9347: CALL 45580 0 2
9351: NOT
9352: AND
9353: IFFALSE 10273
9355: GO 9357
9357: DISABLE
9358: LD_INT 0
9360: PPUSH
9361: PPUSH
9362: PPUSH
9363: PPUSH
// begin enable ;
9364: ENABLE
// if not FilterAllUnits ( [ [ f_side , 3 ] , [ f_btype , b_factory ] ] ) then
9365: LD_INT 22
9367: PUSH
9368: LD_INT 3
9370: PUSH
9371: EMPTY
9372: LIST
9373: LIST
9374: PUSH
9375: LD_INT 30
9377: PUSH
9378: LD_INT 3
9380: PUSH
9381: EMPTY
9382: LIST
9383: LIST
9384: PUSH
9385: EMPTY
9386: LIST
9387: LIST
9388: PPUSH
9389: CALL_OW 69
9393: NOT
9394: IFFALSE 9398
// exit ;
9396: GO 10273
// teleport := FilterAllUnits ( [ [ f_side , 3 ] , [ f_btype , b_teleport ] ] ) ;
9398: LD_ADDR_VAR 0 4
9402: PUSH
9403: LD_INT 22
9405: PUSH
9406: LD_INT 3
9408: PUSH
9409: EMPTY
9410: LIST
9411: LIST
9412: PUSH
9413: LD_INT 30
9415: PUSH
9416: LD_INT 34
9418: PUSH
9419: EMPTY
9420: LIST
9421: LIST
9422: PUSH
9423: EMPTY
9424: LIST
9425: LIST
9426: PPUSH
9427: CALL_OW 69
9431: ST_TO_ADDR
// if Prob ( 40 ) then
9432: LD_INT 40
9434: PPUSH
9435: CALL_OW 13
9439: IFFALSE 9566
// begin MC_InsertProduceList ( 2 , [ [ ru_medium_tracked , engine_siberite , control_computer , ru_time_lapser ] , [ ru_medium_tracked , engine_siberite , control_computer , ru_time_lapser ] , [ ru_medium_tracked , engine_siberite , control_computer , ru_time_lapser ] , [ ru_heavy_tracked , engine_siberite , control_computer , ru_heavy_gun ] , [ ru_heavy_tracked , engine_siberite , control_computer , ru_heavy_gun ] , [ ru_heavy_tracked , engine_siberite , control_computer , ru_heavy_gun ] ] ) ;
9441: LD_INT 2
9443: PPUSH
9444: LD_INT 22
9446: PUSH
9447: LD_INT 3
9449: PUSH
9450: LD_INT 3
9452: PUSH
9453: LD_INT 49
9455: PUSH
9456: EMPTY
9457: LIST
9458: LIST
9459: LIST
9460: LIST
9461: PUSH
9462: LD_INT 22
9464: PUSH
9465: LD_INT 3
9467: PUSH
9468: LD_INT 3
9470: PUSH
9471: LD_INT 49
9473: PUSH
9474: EMPTY
9475: LIST
9476: LIST
9477: LIST
9478: LIST
9479: PUSH
9480: LD_INT 22
9482: PUSH
9483: LD_INT 3
9485: PUSH
9486: LD_INT 3
9488: PUSH
9489: LD_INT 49
9491: PUSH
9492: EMPTY
9493: LIST
9494: LIST
9495: LIST
9496: LIST
9497: PUSH
9498: LD_INT 24
9500: PUSH
9501: LD_INT 3
9503: PUSH
9504: LD_INT 3
9506: PUSH
9507: LD_INT 46
9509: PUSH
9510: EMPTY
9511: LIST
9512: LIST
9513: LIST
9514: LIST
9515: PUSH
9516: LD_INT 24
9518: PUSH
9519: LD_INT 3
9521: PUSH
9522: LD_INT 3
9524: PUSH
9525: LD_INT 46
9527: PUSH
9528: EMPTY
9529: LIST
9530: LIST
9531: LIST
9532: LIST
9533: PUSH
9534: LD_INT 24
9536: PUSH
9537: LD_INT 3
9539: PUSH
9540: LD_INT 3
9542: PUSH
9543: LD_INT 46
9545: PUSH
9546: EMPTY
9547: LIST
9548: LIST
9549: LIST
9550: LIST
9551: PUSH
9552: EMPTY
9553: LIST
9554: LIST
9555: LIST
9556: LIST
9557: LIST
9558: LIST
9559: PPUSH
9560: CALL 44162 0 2
// end else
9564: GO 9689
// begin MC_InsertProduceList ( 2 , [ [ ru_heavy_tracked , engine_siberite , control_computer , ru_rocket ] , [ ru_heavy_tracked , engine_siberite , control_computer , ru_rocket ] , [ ru_heavy_tracked , engine_siberite , control_computer , ru_rocket ] , [ ru_heavy_tracked , engine_siberite , control_computer , ru_heavy_gun ] , [ ru_heavy_tracked , engine_siberite , control_computer , ru_heavy_gun ] , [ ru_heavy_tracked , engine_siberite , control_computer , ru_heavy_gun ] ] ) ;
9566: LD_INT 2
9568: PPUSH
9569: LD_INT 24
9571: PUSH
9572: LD_INT 3
9574: PUSH
9575: LD_INT 3
9577: PUSH
9578: LD_INT 47
9580: PUSH
9581: EMPTY
9582: LIST
9583: LIST
9584: LIST
9585: LIST
9586: PUSH
9587: LD_INT 24
9589: PUSH
9590: LD_INT 3
9592: PUSH
9593: LD_INT 3
9595: PUSH
9596: LD_INT 47
9598: PUSH
9599: EMPTY
9600: LIST
9601: LIST
9602: LIST
9603: LIST
9604: PUSH
9605: LD_INT 24
9607: PUSH
9608: LD_INT 3
9610: PUSH
9611: LD_INT 3
9613: PUSH
9614: LD_INT 47
9616: PUSH
9617: EMPTY
9618: LIST
9619: LIST
9620: LIST
9621: LIST
9622: PUSH
9623: LD_INT 24
9625: PUSH
9626: LD_INT 3
9628: PUSH
9629: LD_INT 3
9631: PUSH
9632: LD_INT 46
9634: PUSH
9635: EMPTY
9636: LIST
9637: LIST
9638: LIST
9639: LIST
9640: PUSH
9641: LD_INT 24
9643: PUSH
9644: LD_INT 3
9646: PUSH
9647: LD_INT 3
9649: PUSH
9650: LD_INT 46
9652: PUSH
9653: EMPTY
9654: LIST
9655: LIST
9656: LIST
9657: LIST
9658: PUSH
9659: LD_INT 24
9661: PUSH
9662: LD_INT 3
9664: PUSH
9665: LD_INT 3
9667: PUSH
9668: LD_INT 46
9670: PUSH
9671: EMPTY
9672: LIST
9673: LIST
9674: LIST
9675: LIST
9676: PUSH
9677: EMPTY
9678: LIST
9679: LIST
9680: LIST
9681: LIST
9682: LIST
9683: LIST
9684: PPUSH
9685: CALL 44162 0 2
// end ; if Difficulty > 1 then
9689: LD_OWVAR 67
9693: PUSH
9694: LD_INT 1
9696: GREATER
9697: IFFALSE 9727
// MC_InsertProduceList ( 2 , [ [ ru_heavy_tracked , engine_siberite , control_computer , ru_rocket ] ] ) ;
9699: LD_INT 2
9701: PPUSH
9702: LD_INT 24
9704: PUSH
9705: LD_INT 3
9707: PUSH
9708: LD_INT 3
9710: PUSH
9711: LD_INT 47
9713: PUSH
9714: EMPTY
9715: LIST
9716: LIST
9717: LIST
9718: LIST
9719: PUSH
9720: EMPTY
9721: LIST
9722: PPUSH
9723: CALL 44162 0 2
// repeat wait ( 0 0$1 ) ;
9727: LD_INT 35
9729: PPUSH
9730: CALL_OW 67
// until MC_GetVehicles ( 2 , true ) >= [ 6 , 7 , 7 ] [ Difficulty ] ;
9734: LD_INT 2
9736: PPUSH
9737: LD_INT 1
9739: PPUSH
9740: CALL 45580 0 2
9744: PUSH
9745: LD_INT 6
9747: PUSH
9748: LD_INT 7
9750: PUSH
9751: LD_INT 7
9753: PUSH
9754: EMPTY
9755: LIST
9756: LIST
9757: LIST
9758: PUSH
9759: LD_OWVAR 67
9763: ARRAY
9764: GREATEREQUAL
9765: IFFALSE 9727
// wait ( 0 0$30 ) ;
9767: LD_INT 1050
9769: PPUSH
9770: CALL_OW 67
// tmp := MC_GetVehicles ( 2 , true ) ;
9774: LD_ADDR_VAR 0 2
9778: PUSH
9779: LD_INT 2
9781: PPUSH
9782: LD_INT 1
9784: PPUSH
9785: CALL 45580 0 2
9789: ST_TO_ADDR
// mc_vehicles := Replace ( mc_vehicles , 2 , mc_vehicles [ 2 ] diff tmp ) ;
9790: LD_ADDR_EXP 95
9794: PUSH
9795: LD_EXP 95
9799: PPUSH
9800: LD_INT 2
9802: PPUSH
9803: LD_EXP 95
9807: PUSH
9808: LD_INT 2
9810: ARRAY
9811: PUSH
9812: LD_VAR 0 2
9816: DIFF
9817: PPUSH
9818: CALL_OW 1
9822: ST_TO_ADDR
// target := rand ( 0 , 1 ) ;
9823: LD_ADDR_VAR 0 3
9827: PUSH
9828: LD_INT 0
9830: PPUSH
9831: LD_INT 1
9833: PPUSH
9834: CALL_OW 12
9838: ST_TO_ADDR
// if target then
9839: LD_VAR 0 3
9843: IFFALSE 9971
// begin repeat tmp := UnitFilter ( tmp , [ f_lives , 250 ] ) ;
9845: LD_ADDR_VAR 0 2
9849: PUSH
9850: LD_VAR 0 2
9854: PPUSH
9855: LD_INT 24
9857: PUSH
9858: LD_INT 250
9860: PUSH
9861: EMPTY
9862: LIST
9863: LIST
9864: PPUSH
9865: CALL_OW 72
9869: ST_TO_ADDR
// for i in tmp do
9870: LD_ADDR_VAR 0 1
9874: PUSH
9875: LD_VAR 0 2
9879: PUSH
9880: FOR_IN
9881: IFFALSE 9921
// if GetDistUnitXY ( i , 139 , 89 ) > 9 then
9883: LD_VAR 0 1
9887: PPUSH
9888: LD_INT 139
9890: PPUSH
9891: LD_INT 89
9893: PPUSH
9894: CALL_OW 297
9898: PUSH
9899: LD_INT 9
9901: GREATER
9902: IFFALSE 9919
// ComMoveXY ( i , 139 , 89 ) ;
9904: LD_VAR 0 1
9908: PPUSH
9909: LD_INT 139
9911: PPUSH
9912: LD_INT 89
9914: PPUSH
9915: CALL_OW 111
9919: GO 9880
9921: POP
9922: POP
// wait ( 0 0$1 ) ;
9923: LD_INT 35
9925: PPUSH
9926: CALL_OW 67
// until UnitFilter ( tmp , [ f_distxy , 139 , 89 , 9 ] ) >= ( tmp - 1 ) ;
9930: LD_VAR 0 2
9934: PPUSH
9935: LD_INT 92
9937: PUSH
9938: LD_INT 139
9940: PUSH
9941: LD_INT 89
9943: PUSH
9944: LD_INT 9
9946: PUSH
9947: EMPTY
9948: LIST
9949: LIST
9950: LIST
9951: LIST
9952: PPUSH
9953: CALL_OW 72
9957: PUSH
9958: LD_VAR 0 2
9962: PUSH
9963: LD_INT 1
9965: MINUS
9966: GREATEREQUAL
9967: IFFALSE 9845
// end else
9969: GO 10113
// begin ComEnterUnit ( tmp , teleport [ 1 ] ) ;
9971: LD_VAR 0 2
9975: PPUSH
9976: LD_VAR 0 4
9980: PUSH
9981: LD_INT 1
9983: ARRAY
9984: PPUSH
9985: CALL_OW 120
// repeat tmp := UnitFilter ( tmp , [ f_lives , 250 ] ) ;
9989: LD_ADDR_VAR 0 2
9993: PUSH
9994: LD_VAR 0 2
9998: PPUSH
9999: LD_INT 24
10001: PUSH
10002: LD_INT 250
10004: PUSH
10005: EMPTY
10006: LIST
10007: LIST
10008: PPUSH
10009: CALL_OW 72
10013: ST_TO_ADDR
// for i in tmp do
10014: LD_ADDR_VAR 0 1
10018: PUSH
10019: LD_VAR 0 2
10023: PUSH
10024: FOR_IN
10025: IFFALSE 10065
// if GetDistUnitXY ( i , 124 , 139 ) > 9 then
10027: LD_VAR 0 1
10031: PPUSH
10032: LD_INT 124
10034: PPUSH
10035: LD_INT 139
10037: PPUSH
10038: CALL_OW 297
10042: PUSH
10043: LD_INT 9
10045: GREATER
10046: IFFALSE 10063
// ComMoveXY ( i , 124 , 139 ) ;
10048: LD_VAR 0 1
10052: PPUSH
10053: LD_INT 124
10055: PPUSH
10056: LD_INT 139
10058: PPUSH
10059: CALL_OW 111
10063: GO 10024
10065: POP
10066: POP
// wait ( 0 0$1 ) ;
10067: LD_INT 35
10069: PPUSH
10070: CALL_OW 67
// until UnitFilter ( tmp , [ f_distxy , 124 , 139 , 9 ] ) >= ( tmp - 1 ) ;
10074: LD_VAR 0 2
10078: PPUSH
10079: LD_INT 92
10081: PUSH
10082: LD_INT 124
10084: PUSH
10085: LD_INT 139
10087: PUSH
10088: LD_INT 9
10090: PUSH
10091: EMPTY
10092: LIST
10093: LIST
10094: LIST
10095: LIST
10096: PPUSH
10097: CALL_OW 72
10101: PUSH
10102: LD_VAR 0 2
10106: PUSH
10107: LD_INT 1
10109: MINUS
10110: GREATEREQUAL
10111: IFFALSE 9989
// end ; repeat wait ( 0 0$1 ) ;
10113: LD_INT 35
10115: PPUSH
10116: CALL_OW 67
// for i in tmp do
10120: LD_ADDR_VAR 0 1
10124: PUSH
10125: LD_VAR 0 2
10129: PUSH
10130: FOR_IN
10131: IFFALSE 10264
// begin if GetLives ( i ) > 251 then
10133: LD_VAR 0 1
10137: PPUSH
10138: CALL_OW 256
10142: PUSH
10143: LD_INT 251
10145: GREATER
10146: IFFALSE 10235
// begin if GetWeapon ( i ) = ru_time_lapser then
10148: LD_VAR 0 1
10152: PPUSH
10153: CALL_OW 264
10157: PUSH
10158: LD_INT 49
10160: EQUAL
10161: IFFALSE 10199
// ComMoveUnit ( i , NearestUnitToUnit ( FilterAllUnits ( [ f_enemy , 3 ] ) , i ) ) else
10163: LD_VAR 0 1
10167: PPUSH
10168: LD_INT 81
10170: PUSH
10171: LD_INT 3
10173: PUSH
10174: EMPTY
10175: LIST
10176: LIST
10177: PPUSH
10178: CALL_OW 69
10182: PPUSH
10183: LD_VAR 0 1
10187: PPUSH
10188: CALL_OW 74
10192: PPUSH
10193: CALL_OW 112
10197: GO 10233
// ComAttackUnit ( i , NearestUnitToUnit ( FilterAllUnits ( [ f_enemy , 3 ] ) , i ) ) ;
10199: LD_VAR 0 1
10203: PPUSH
10204: LD_INT 81
10206: PUSH
10207: LD_INT 3
10209: PUSH
10210: EMPTY
10211: LIST
10212: LIST
10213: PPUSH
10214: CALL_OW 69
10218: PPUSH
10219: LD_VAR 0 1
10223: PPUSH
10224: CALL_OW 74
10228: PPUSH
10229: CALL_OW 115
// end else
10233: GO 10262
// if IsDead ( i ) then
10235: LD_VAR 0 1
10239: PPUSH
10240: CALL_OW 301
10244: IFFALSE 10262
// tmp := tmp diff i ;
10246: LD_ADDR_VAR 0 2
10250: PUSH
10251: LD_VAR 0 2
10255: PUSH
10256: LD_VAR 0 1
10260: DIFF
10261: ST_TO_ADDR
// end ;
10262: GO 10130
10264: POP
10265: POP
// until not tmp ;
10266: LD_VAR 0 2
10270: NOT
10271: IFFALSE 10113
// end ;
10273: PPOPN 4
10275: END
// every 30 30$00 trigger not russianDestroyed do
10276: LD_EXP 2
10280: NOT
10281: IFFALSE 10346
10283: GO 10285
10285: DISABLE
// begin wait ( [ 50 50$00 , 40 40$00 , 30 30$00 ] [ Difficulty ] ) ;
10286: LD_INT 105000
10288: PUSH
10289: LD_INT 84000
10291: PUSH
10292: LD_INT 63000
10294: PUSH
10295: EMPTY
10296: LIST
10297: LIST
10298: LIST
10299: PUSH
10300: LD_OWVAR 67
10304: ARRAY
10305: PPUSH
10306: CALL_OW 67
// if russianDestroyed then
10310: LD_EXP 2
10314: IFFALSE 10318
// exit ;
10316: GO 10346
// MC_InsertProduceList ( 2 , [ [ ru_heavy_wheeled , engine_siberite , control_manual , ru_siberium_rocket ] ] ) ;
10318: LD_INT 2
10320: PPUSH
10321: LD_INT 23
10323: PUSH
10324: LD_INT 3
10326: PUSH
10327: LD_INT 1
10329: PUSH
10330: LD_INT 48
10332: PUSH
10333: EMPTY
10334: LIST
10335: LIST
10336: LIST
10337: LIST
10338: PUSH
10339: EMPTY
10340: LIST
10341: PPUSH
10342: CALL 44162 0 2
// end ; end_of_file
10346: END
// export function CustomEvent ( event ) ; begin
10347: LD_INT 0
10349: PPUSH
// end ;
10350: LD_VAR 0 2
10354: RET
// on SibDepositContaminated ( unit , x , y ) do begin if InArea ( x , y , motherLodeArea ) then
10355: LD_VAR 0 2
10359: PPUSH
10360: LD_VAR 0 3
10364: PPUSH
10365: LD_INT 15
10367: PPUSH
10368: CALL_OW 309
10372: IFFALSE 10381
// YouLost ( MothContaminate ) ;
10374: LD_STRING MothContaminate
10376: PPUSH
10377: CALL_OW 104
// end ;
10381: PPOPN 3
10383: END
// on SiberiteRocketExploded ( unit , x , y ) do begin if InArea ( x , y , motherLodeArea ) then
10384: LD_VAR 0 2
10388: PPUSH
10389: LD_VAR 0 3
10393: PPUSH
10394: LD_INT 15
10396: PPUSH
10397: CALL_OW 309
10401: IFFALSE 10417
// begin wait ( 0 0$6 ) ;
10403: LD_INT 210
10405: PPUSH
10406: CALL_OW 67
// YouLost ( MothContaminateBomb ) ;
10410: LD_STRING MothContaminateBomb
10412: PPUSH
10413: CALL_OW 104
// end ; end ;
10417: PPOPN 3
10419: END
// on UnitDestroyed ( un ) do begin if un = JMM then
10420: LD_VAR 0 1
10424: PUSH
10425: LD_EXP 14
10429: EQUAL
10430: IFFALSE 10441
// begin YouLost ( JMM ) ;
10432: LD_STRING JMM
10434: PPUSH
10435: CALL_OW 104
// exit ;
10439: GO 10540
// end ; if un = Powell then
10441: LD_VAR 0 1
10445: PUSH
10446: LD_EXP 49
10450: EQUAL
10451: IFFALSE 10461
// americanDestroyed := true ;
10453: LD_ADDR_EXP 4
10457: PUSH
10458: LD_INT 1
10460: ST_TO_ADDR
// if un = Platonov then
10461: LD_VAR 0 1
10465: PUSH
10466: LD_EXP 53
10470: EQUAL
10471: IFFALSE 10481
// russianDestroyed := true ;
10473: LD_ADDR_EXP 2
10477: PUSH
10478: LD_INT 1
10480: ST_TO_ADDR
// if un in FilterAllUnits ( [ [ f_side , 7 ] , [ f_type , unit_vehicle ] ] ) then
10481: LD_VAR 0 1
10485: PUSH
10486: LD_INT 22
10488: PUSH
10489: LD_INT 7
10491: PUSH
10492: EMPTY
10493: LIST
10494: LIST
10495: PUSH
10496: LD_INT 21
10498: PUSH
10499: LD_INT 2
10501: PUSH
10502: EMPTY
10503: LIST
10504: LIST
10505: PUSH
10506: EMPTY
10507: LIST
10508: LIST
10509: PPUSH
10510: CALL_OW 69
10514: IN
10515: IFFALSE 10531
// vehicleLostCounter := vehicleLostCounter + 1 ;
10517: LD_ADDR_EXP 12
10521: PUSH
10522: LD_EXP 12
10526: PUSH
10527: LD_INT 1
10529: PLUS
10530: ST_TO_ADDR
// MCE_UnitDestroyed ( un ) ;
10531: LD_VAR 0 1
10535: PPUSH
10536: CALL 47554 0 1
// end ;
10540: PPOPN 1
10542: END
// on BuildingStarted ( building , builder ) do begin MCE_BuildingStarted ( building , builder ) ;
10543: LD_VAR 0 1
10547: PPUSH
10548: LD_VAR 0 2
10552: PPUSH
10553: CALL 49888 0 2
// end ;
10557: PPOPN 2
10559: END
// on UpgradeComplete ( building ) do begin MCE_UpgradeComplete ( building ) ;
10560: LD_VAR 0 1
10564: PPUSH
10565: CALL 48956 0 1
// end ;
10569: PPOPN 1
10571: END
// on BuildingComplete ( building ) do begin if building in FilterAllUnits ( [ [ f_side , 8 ] , [ f_btype , b_workshop ] , [ f_nation , 3 ] ] ) then
10572: LD_VAR 0 1
10576: PUSH
10577: LD_INT 22
10579: PUSH
10580: LD_INT 8
10582: PUSH
10583: EMPTY
10584: LIST
10585: LIST
10586: PUSH
10587: LD_INT 30
10589: PUSH
10590: LD_INT 2
10592: PUSH
10593: EMPTY
10594: LIST
10595: LIST
10596: PUSH
10597: LD_INT 23
10599: PUSH
10600: LD_INT 3
10602: PUSH
10603: EMPTY
10604: LIST
10605: LIST
10606: PUSH
10607: EMPTY
10608: LIST
10609: LIST
10610: LIST
10611: PPUSH
10612: CALL_OW 69
10616: IN
10617: IFFALSE 10644
// begin ComUpgrade ( building ) ;
10619: LD_VAR 0 1
10623: PPUSH
10624: CALL_OW 146
// ComComplete ( Kozlov , building ) ;
10628: LD_EXP 52
10632: PPUSH
10633: LD_VAR 0 1
10637: PPUSH
10638: CALL 60594 0 2
// exit ;
10642: GO 10653
// end ; MCE_BuildingComplete ( building ) ;
10644: LD_VAR 0 1
10648: PPUSH
10649: CALL 49197 0 1
// end ;
10653: PPOPN 1
10655: END
// on ResearchComplete ( tech , lab ) do begin MCE_ResearchComplete ( tech , lab ) ;
10656: LD_VAR 0 1
10660: PPUSH
10661: LD_VAR 0 2
10665: PPUSH
10666: CALL 47250 0 2
// end ;
10670: PPOPN 2
10672: END
// on CrateSpawn ( id , x , y , amount , mode ) do begin MCE_CrateSpawn ( id , x , y , amount , mode ) ;
10673: LD_VAR 0 1
10677: PPUSH
10678: LD_VAR 0 2
10682: PPUSH
10683: LD_VAR 0 3
10687: PPUSH
10688: LD_VAR 0 4
10692: PPUSH
10693: LD_VAR 0 5
10697: PPUSH
10698: CALL 46870 0 5
// end ;
10702: PPOPN 5
10704: END
// on VehicleConstructed ( vehicle , factory ) do begin MCE_VehicleConstructed ( vehicle , factory ) ;
10705: LD_VAR 0 1
10709: PPUSH
10710: LD_VAR 0 2
10714: PPUSH
10715: CALL 46466 0 2
// end ;
10719: PPOPN 2
10721: END
// on VehicleCaptured ( new , old , side , capturing_unit ) do begin MCE_VehicleCaptured ( new , old , side , capturing_unit ) ;
10722: LD_VAR 0 1
10726: PPUSH
10727: LD_VAR 0 2
10731: PPUSH
10732: LD_VAR 0 3
10736: PPUSH
10737: LD_VAR 0 4
10741: PPUSH
10742: CALL 46304 0 4
// end ;
10746: PPOPN 4
10748: END
// on BuildingCaptured ( building , side , capturning_unit ) do begin MCE_BuildingCaptured ( building , side , capturning_unit ) ;
10749: LD_VAR 0 1
10753: PPUSH
10754: LD_VAR 0 2
10758: PPUSH
10759: LD_VAR 0 3
10763: PPUSH
10764: CALL 46079 0 3
// end ;
10768: PPOPN 3
10770: END
// on EnterBuilding ( building , unit ) do begin MCE_EnterBuilding ( building , unit ) ;
10771: LD_VAR 0 1
10775: PPUSH
10776: LD_VAR 0 2
10780: PPUSH
10781: CALL 45964 0 2
// end ;
10785: PPOPN 2
10787: END
// on LeaveBuilding ( building , unit ) do begin MCE_LeaveBuilding ( building , unit ) ;
10788: LD_VAR 0 1
10792: PPUSH
10793: LD_VAR 0 2
10797: PPUSH
10798: CALL 50149 0 2
// end ;
10802: PPOPN 2
10804: END
// on EvacuateVehicle ( driver , abandoned_vehicle , unknown1 , unknown2 ) do begin MCE_EvacuateVehicle ( driver , abandoned_vehicle , unknown1 , unknown2 ) ;
10805: LD_VAR 0 1
10809: PPUSH
10810: LD_VAR 0 2
10814: PPUSH
10815: LD_VAR 0 3
10819: PPUSH
10820: LD_VAR 0 4
10824: PPUSH
10825: CALL 50365 0 4
// end ;
10829: PPOPN 4
10831: END
// on ApemanTamed ( ape , sci ) do begin MCE_ApemanTamed ( ape , sci ) ;
10832: LD_VAR 0 1
10836: PPUSH
10837: LD_VAR 0 2
10841: PPUSH
10842: CALL 45773 0 2
// end ;
10846: PPOPN 2
10848: END
// on Command ( cmd ) do begin SOS_Command ( cmd ) ;
10849: LD_VAR 0 1
10853: PPUSH
10854: CALL 93769 0 1
// end ; end_of_file
10858: PPOPN 1
10860: END
// export function Action ; begin
10861: LD_INT 0
10863: PPUSH
// InGameOn ;
10864: CALL_OW 8
// CenterNowOnXY ( 206 , 11 ) ;
10868: LD_INT 206
10870: PPUSH
10871: LD_INT 11
10873: PPUSH
10874: CALL_OW 86
// wait ( 0 0$1 ) ;
10878: LD_INT 35
10880: PPUSH
10881: CALL_OW 67
// Say ( JMM , DStart-JMM-JMM-1 ) ;
10885: LD_EXP 14
10889: PPUSH
10890: LD_STRING DStart-JMM-JMM-1
10892: PPUSH
10893: CALL_OW 88
// Say ( Burlak , DStart-JMM-Bur-1 ) ;
10897: LD_EXP 46
10901: PPUSH
10902: LD_STRING DStart-JMM-Bur-1
10904: PPUSH
10905: CALL_OW 88
// Say ( JMM , DStart-JMM-JMM-2 ) ;
10909: LD_EXP 14
10913: PPUSH
10914: LD_STRING DStart-JMM-JMM-2
10916: PPUSH
10917: CALL_OW 88
// Say ( Burlak , DStart-JMM-Bur-2 ) ;
10921: LD_EXP 46
10925: PPUSH
10926: LD_STRING DStart-JMM-Bur-2
10928: PPUSH
10929: CALL_OW 88
// InGameOff ;
10933: CALL_OW 9
// ChangeMissionObjectives ( MStart ) ;
10937: LD_STRING MStart
10939: PPUSH
10940: CALL_OW 337
// end ;
10944: LD_VAR 0 1
10948: RET
// every 0 0$2 trigger SeeXY ( 7 , 255 , 219 ) do var speaker ;
10949: LD_INT 7
10951: PPUSH
10952: LD_INT 255
10954: PPUSH
10955: LD_INT 219
10957: PPUSH
10958: CALL_OW 293
10962: IFFALSE 11571
10964: GO 10966
10966: DISABLE
10967: LD_INT 0
10969: PPUSH
// begin wait ( 0 0$3 ) ;
10970: LD_INT 105
10972: PPUSH
10973: CALL_OW 67
// alienSpotted := true ;
10977: LD_ADDR_EXP 7
10981: PUSH
10982: LD_INT 1
10984: ST_TO_ADDR
// speaker := FilterAllUnits ( [ [ f_side , 7 ] , [ f_nation , 3 ] , [ f_type , unit_human ] , [ f_sex , sex_male ] ] ) diff [ Burlak , Titov , Dolgov , Petrosyan , Kuzmov , Kovalyuk , Scholtze ] ;
10985: LD_ADDR_VAR 0 1
10989: PUSH
10990: LD_INT 22
10992: PUSH
10993: LD_INT 7
10995: PUSH
10996: EMPTY
10997: LIST
10998: LIST
10999: PUSH
11000: LD_INT 23
11002: PUSH
11003: LD_INT 3
11005: PUSH
11006: EMPTY
11007: LIST
11008: LIST
11009: PUSH
11010: LD_INT 21
11012: PUSH
11013: LD_INT 1
11015: PUSH
11016: EMPTY
11017: LIST
11018: LIST
11019: PUSH
11020: LD_INT 26
11022: PUSH
11023: LD_INT 1
11025: PUSH
11026: EMPTY
11027: LIST
11028: LIST
11029: PUSH
11030: EMPTY
11031: LIST
11032: LIST
11033: LIST
11034: LIST
11035: PPUSH
11036: CALL_OW 69
11040: PUSH
11041: LD_EXP 46
11045: PUSH
11046: LD_EXP 34
11050: PUSH
11051: LD_EXP 36
11055: PUSH
11056: LD_EXP 37
11060: PUSH
11061: LD_EXP 44
11065: PUSH
11066: LD_EXP 43
11070: PUSH
11071: LD_EXP 38
11075: PUSH
11076: EMPTY
11077: LIST
11078: LIST
11079: LIST
11080: LIST
11081: LIST
11082: LIST
11083: LIST
11084: DIFF
11085: ST_TO_ADDR
// DialogueOn ;
11086: CALL_OW 6
// PlaceSeeing ( 255 , 219 , 7 , - 20 ) ;
11090: LD_INT 255
11092: PPUSH
11093: LD_INT 219
11095: PPUSH
11096: LD_INT 7
11098: PPUSH
11099: LD_INT 20
11101: NEG
11102: PPUSH
11103: CALL_OW 330
// CenterNowOnXY ( 255 , 219 ) ;
11107: LD_INT 255
11109: PPUSH
11110: LD_INT 219
11112: PPUSH
11113: CALL_OW 86
// if speaker then
11117: LD_VAR 0 1
11121: IFFALSE 11139
// Say ( speaker [ 1 ] , DAlienBase-RSol1-1 ) ;
11123: LD_VAR 0 1
11127: PUSH
11128: LD_INT 1
11130: ARRAY
11131: PPUSH
11132: LD_STRING DAlienBase-RSol1-1
11134: PPUSH
11135: CALL_OW 88
// Say ( JMM , DAlienBase-JMM-1 ) ;
11139: LD_EXP 14
11143: PPUSH
11144: LD_STRING DAlienBase-JMM-1
11146: PPUSH
11147: CALL_OW 88
// if IsOk ( Burlak ) then
11151: LD_EXP 46
11155: PPUSH
11156: CALL_OW 302
11160: IFFALSE 11181
// begin dwait ( 0 0$1 ) ;
11162: LD_INT 35
11164: PPUSH
11165: CALL_OW 68
// Say ( Burlak , DAlienBase-Bur-1 ) ;
11169: LD_EXP 46
11173: PPUSH
11174: LD_STRING DAlienBase-Bur-1
11176: PPUSH
11177: CALL_OW 88
// end ; if IsOk ( Roth ) then
11181: LD_EXP 15
11185: PPUSH
11186: CALL_OW 302
11190: IFFALSE 11204
// Say ( Roth , DAlienBase-Roth-1 ) ;
11192: LD_EXP 15
11196: PPUSH
11197: LD_STRING DAlienBase-Roth-1
11199: PPUSH
11200: CALL_OW 88
// if IsOk ( Gossudarov ) then
11204: LD_EXP 32
11208: PPUSH
11209: CALL_OW 302
11213: IFFALSE 11229
// Say ( Gossudarov , DAlienBase-Gos-1 ) else
11215: LD_EXP 32
11219: PPUSH
11220: LD_STRING DAlienBase-Gos-1
11222: PPUSH
11223: CALL_OW 88
11227: GO 11346
// begin speaker := FilterAllUnits ( [ [ f_side , 7 ] , [ f_class , 4 ] , [ f_type , unit_human ] , [ f_sex , sex_male ] ] ) diff [ Roth , JMM , Burlak , Titov , Kuzmov , Kovalyuk ] ;
11229: LD_ADDR_VAR 0 1
11233: PUSH
11234: LD_INT 22
11236: PUSH
11237: LD_INT 7
11239: PUSH
11240: EMPTY
11241: LIST
11242: LIST
11243: PUSH
11244: LD_INT 25
11246: PUSH
11247: LD_INT 4
11249: PUSH
11250: EMPTY
11251: LIST
11252: LIST
11253: PUSH
11254: LD_INT 21
11256: PUSH
11257: LD_INT 1
11259: PUSH
11260: EMPTY
11261: LIST
11262: LIST
11263: PUSH
11264: LD_INT 26
11266: PUSH
11267: LD_INT 1
11269: PUSH
11270: EMPTY
11271: LIST
11272: LIST
11273: PUSH
11274: EMPTY
11275: LIST
11276: LIST
11277: LIST
11278: LIST
11279: PPUSH
11280: CALL_OW 69
11284: PUSH
11285: LD_EXP 15
11289: PUSH
11290: LD_EXP 14
11294: PUSH
11295: LD_EXP 46
11299: PUSH
11300: LD_EXP 34
11304: PUSH
11305: LD_EXP 44
11309: PUSH
11310: LD_EXP 43
11314: PUSH
11315: EMPTY
11316: LIST
11317: LIST
11318: LIST
11319: LIST
11320: LIST
11321: LIST
11322: DIFF
11323: ST_TO_ADDR
// if speaker then
11324: LD_VAR 0 1
11328: IFFALSE 11346
// Say ( speaker [ 1 ] , DAlienBase-Sci1-1 ) ;
11330: LD_VAR 0 1
11334: PUSH
11335: LD_INT 1
11337: ARRAY
11338: PPUSH
11339: LD_STRING DAlienBase-Sci1-1
11341: PPUSH
11342: CALL_OW 88
// end ; RemoveSeeing ( 255 , 219 , 7 ) ;
11346: LD_INT 255
11348: PPUSH
11349: LD_INT 219
11351: PPUSH
11352: LD_INT 7
11354: PPUSH
11355: CALL_OW 331
// DialogueOff ;
11359: CALL_OW 7
// repeat wait ( 0 0$1 ) ;
11363: LD_INT 35
11365: PPUSH
11366: CALL_OW 67
// until IsSelected ( alien ) ;
11370: LD_INT 1
11372: PPUSH
11373: CALL_OW 306
11377: IFFALSE 11363
// if not artifactIResearched or not artifactIIResearched then
11379: LD_EXP 9
11383: NOT
11384: PUSH
11385: LD_EXP 10
11389: NOT
11390: OR
11391: IFFALSE 11571
// begin if IsOk ( Roth ) then
11393: LD_EXP 15
11397: PPUSH
11398: CALL_OW 302
11402: IFFALSE 11418
// Say ( Roth , DAlieBaseNotReady-Roth-1 ) else
11404: LD_EXP 15
11408: PPUSH
11409: LD_STRING DAlieBaseNotReady-Roth-1
11411: PPUSH
11412: CALL_OW 88
11416: GO 11571
// if IsOk ( Gossudarov ) then
11418: LD_EXP 32
11422: PPUSH
11423: CALL_OW 302
11427: IFFALSE 11443
// Say ( Gossudarov , DAlieBaseNotReady-Gos-1 ) else
11429: LD_EXP 32
11433: PPUSH
11434: LD_STRING DAlieBaseNotReady-Gos-1
11436: PPUSH
11437: CALL_OW 88
11441: GO 11571
// begin speaker := FilterAllUnits ( [ [ f_side , 7 ] , [ f_nation , 3 ] , [ f_class , 4 ] , [ f_type , unit_human ] , [ f_sex , sex_male ] ] ) diff [ Roth , JMM , Burlak , Titov , Kuzmov , Kovalyuk ] ;
11443: LD_ADDR_VAR 0 1
11447: PUSH
11448: LD_INT 22
11450: PUSH
11451: LD_INT 7
11453: PUSH
11454: EMPTY
11455: LIST
11456: LIST
11457: PUSH
11458: LD_INT 23
11460: PUSH
11461: LD_INT 3
11463: PUSH
11464: EMPTY
11465: LIST
11466: LIST
11467: PUSH
11468: LD_INT 25
11470: PUSH
11471: LD_INT 4
11473: PUSH
11474: EMPTY
11475: LIST
11476: LIST
11477: PUSH
11478: LD_INT 21
11480: PUSH
11481: LD_INT 1
11483: PUSH
11484: EMPTY
11485: LIST
11486: LIST
11487: PUSH
11488: LD_INT 26
11490: PUSH
11491: LD_INT 1
11493: PUSH
11494: EMPTY
11495: LIST
11496: LIST
11497: PUSH
11498: EMPTY
11499: LIST
11500: LIST
11501: LIST
11502: LIST
11503: LIST
11504: PPUSH
11505: CALL_OW 69
11509: PUSH
11510: LD_EXP 15
11514: PUSH
11515: LD_EXP 14
11519: PUSH
11520: LD_EXP 46
11524: PUSH
11525: LD_EXP 34
11529: PUSH
11530: LD_EXP 44
11534: PUSH
11535: LD_EXP 43
11539: PUSH
11540: EMPTY
11541: LIST
11542: LIST
11543: LIST
11544: LIST
11545: LIST
11546: LIST
11547: DIFF
11548: ST_TO_ADDR
// if speaker then
11549: LD_VAR 0 1
11553: IFFALSE 11571
// Say ( speaker [ 1 ] , DAlieBaseNotReady-RSci1-1 ) ;
11555: LD_VAR 0 1
11559: PUSH
11560: LD_INT 1
11562: ARRAY
11563: PPUSH
11564: LD_STRING DAlieBaseNotReady-RSci1-1
11566: PPUSH
11567: CALL_OW 88
// end ; end ; end ;
11571: PPOPN 1
11573: END
// every 0 0$1 trigger GetTech ( tech_Artifact , 7 ) = state_researched do var speaker ;
11574: LD_INT 24
11576: PPUSH
11577: LD_INT 7
11579: PPUSH
11580: CALL_OW 321
11584: PUSH
11585: LD_INT 2
11587: EQUAL
11588: IFFALSE 12279
11590: GO 11592
11592: DISABLE
11593: LD_INT 0
11595: PPUSH
// begin speaker := FilterAllUnits ( [ [ f_side , 7 ] , [ f_nation , 3 ] , [ f_class , 4 ] , [ f_type , unit_human ] , [ f_sex , sex_male ] ] ) diff [ Roth , JMM , Burlak , Titov , Kuzmov , Kovalyuk ] ;
11596: LD_ADDR_VAR 0 1
11600: PUSH
11601: LD_INT 22
11603: PUSH
11604: LD_INT 7
11606: PUSH
11607: EMPTY
11608: LIST
11609: LIST
11610: PUSH
11611: LD_INT 23
11613: PUSH
11614: LD_INT 3
11616: PUSH
11617: EMPTY
11618: LIST
11619: LIST
11620: PUSH
11621: LD_INT 25
11623: PUSH
11624: LD_INT 4
11626: PUSH
11627: EMPTY
11628: LIST
11629: LIST
11630: PUSH
11631: LD_INT 21
11633: PUSH
11634: LD_INT 1
11636: PUSH
11637: EMPTY
11638: LIST
11639: LIST
11640: PUSH
11641: LD_INT 26
11643: PUSH
11644: LD_INT 1
11646: PUSH
11647: EMPTY
11648: LIST
11649: LIST
11650: PUSH
11651: EMPTY
11652: LIST
11653: LIST
11654: LIST
11655: LIST
11656: LIST
11657: PPUSH
11658: CALL_OW 69
11662: PUSH
11663: LD_EXP 15
11667: PUSH
11668: LD_EXP 14
11672: PUSH
11673: LD_EXP 46
11677: PUSH
11678: LD_EXP 34
11682: PUSH
11683: LD_EXP 44
11687: PUSH
11688: LD_EXP 43
11692: PUSH
11693: EMPTY
11694: LIST
11695: LIST
11696: LIST
11697: LIST
11698: LIST
11699: LIST
11700: DIFF
11701: ST_TO_ADDR
// if not speaker then
11702: LD_VAR 0 1
11706: NOT
11707: IFFALSE 11711
// exit ;
11709: GO 12279
// DialogueOn ;
11711: CALL_OW 6
// Say ( speaker [ 1 ] , DArtefTechnology-RSci1-1 ) ;
11715: LD_VAR 0 1
11719: PUSH
11720: LD_INT 1
11722: ARRAY
11723: PPUSH
11724: LD_STRING DArtefTechnology-RSci1-1
11726: PPUSH
11727: CALL_OW 88
// if IsOk ( Burlak ) then
11731: LD_EXP 46
11735: PPUSH
11736: CALL_OW 302
11740: IFFALSE 11754
// Say ( Burlak , DArtefTechnology-Bur-1 ) ;
11742: LD_EXP 46
11746: PPUSH
11747: LD_STRING DArtefTechnology-Bur-1
11749: PPUSH
11750: CALL_OW 88
// Say ( speaker [ 1 ] , DArtefTechnology-RSci1-2 ) ;
11754: LD_VAR 0 1
11758: PUSH
11759: LD_INT 1
11761: ARRAY
11762: PPUSH
11763: LD_STRING DArtefTechnology-RSci1-2
11765: PPUSH
11766: CALL_OW 88
// if Denis then
11770: LD_EXP 20
11774: IFFALSE 11791
// speaker := [ Denis ] else
11776: LD_ADDR_VAR 0 1
11780: PUSH
11781: LD_EXP 20
11785: PUSH
11786: EMPTY
11787: LIST
11788: ST_TO_ADDR
11789: GO 11897
// speaker := FilterAllUnits ( [ [ f_side , 7 ] , [ f_nation , 1 ] , [ f_class , 4 ] , [ f_type , unit_human ] , [ f_sex , sex_male ] ] ) diff [ Roth , JMM , Burlak , Titov , Kuzmov , Kovalyuk ] ;
11791: LD_ADDR_VAR 0 1
11795: PUSH
11796: LD_INT 22
11798: PUSH
11799: LD_INT 7
11801: PUSH
11802: EMPTY
11803: LIST
11804: LIST
11805: PUSH
11806: LD_INT 23
11808: PUSH
11809: LD_INT 1
11811: PUSH
11812: EMPTY
11813: LIST
11814: LIST
11815: PUSH
11816: LD_INT 25
11818: PUSH
11819: LD_INT 4
11821: PUSH
11822: EMPTY
11823: LIST
11824: LIST
11825: PUSH
11826: LD_INT 21
11828: PUSH
11829: LD_INT 1
11831: PUSH
11832: EMPTY
11833: LIST
11834: LIST
11835: PUSH
11836: LD_INT 26
11838: PUSH
11839: LD_INT 1
11841: PUSH
11842: EMPTY
11843: LIST
11844: LIST
11845: PUSH
11846: EMPTY
11847: LIST
11848: LIST
11849: LIST
11850: LIST
11851: LIST
11852: PPUSH
11853: CALL_OW 69
11857: PUSH
11858: LD_EXP 15
11862: PUSH
11863: LD_EXP 14
11867: PUSH
11868: LD_EXP 46
11872: PUSH
11873: LD_EXP 34
11877: PUSH
11878: LD_EXP 44
11882: PUSH
11883: LD_EXP 43
11887: PUSH
11888: EMPTY
11889: LIST
11890: LIST
11891: LIST
11892: LIST
11893: LIST
11894: LIST
11895: DIFF
11896: ST_TO_ADDR
// if speaker then
11897: LD_VAR 0 1
11901: IFFALSE 11919
// Say ( speaker [ 1 ] , DArtefTechnology-Sci1-2 ) ;
11903: LD_VAR 0 1
11907: PUSH
11908: LD_INT 1
11910: ARRAY
11911: PPUSH
11912: LD_STRING DArtefTechnology-Sci1-2
11914: PPUSH
11915: CALL_OW 88
// speaker := FilterAllUnits ( [ [ f_side , 7 ] , [ f_nation , 3 ] , [ f_class , 4 ] , [ f_type , unit_human ] , [ f_sex , sex_male ] ] ) diff [ Roth , JMM , Burlak , Titov , Kuzmov , Kovalyuk ] ;
11919: LD_ADDR_VAR 0 1
11923: PUSH
11924: LD_INT 22
11926: PUSH
11927: LD_INT 7
11929: PUSH
11930: EMPTY
11931: LIST
11932: LIST
11933: PUSH
11934: LD_INT 23
11936: PUSH
11937: LD_INT 3
11939: PUSH
11940: EMPTY
11941: LIST
11942: LIST
11943: PUSH
11944: LD_INT 25
11946: PUSH
11947: LD_INT 4
11949: PUSH
11950: EMPTY
11951: LIST
11952: LIST
11953: PUSH
11954: LD_INT 21
11956: PUSH
11957: LD_INT 1
11959: PUSH
11960: EMPTY
11961: LIST
11962: LIST
11963: PUSH
11964: LD_INT 26
11966: PUSH
11967: LD_INT 1
11969: PUSH
11970: EMPTY
11971: LIST
11972: LIST
11973: PUSH
11974: EMPTY
11975: LIST
11976: LIST
11977: LIST
11978: LIST
11979: LIST
11980: PPUSH
11981: CALL_OW 69
11985: PUSH
11986: LD_EXP 15
11990: PUSH
11991: LD_EXP 14
11995: PUSH
11996: LD_EXP 46
12000: PUSH
12001: LD_EXP 34
12005: PUSH
12006: LD_EXP 44
12010: PUSH
12011: LD_EXP 43
12015: PUSH
12016: EMPTY
12017: LIST
12018: LIST
12019: LIST
12020: LIST
12021: LIST
12022: LIST
12023: DIFF
12024: ST_TO_ADDR
// if speaker and ( artifactArCaptured or arabianDestroyed ) then
12025: LD_VAR 0 1
12029: PUSH
12030: LD_EXP 6
12034: PUSH
12035: LD_EXP 5
12039: OR
12040: AND
12041: IFFALSE 12275
// begin if arabianDestroyed and IsOk ( Burlak ) then
12043: LD_EXP 5
12047: PUSH
12048: LD_EXP 46
12052: PPUSH
12053: CALL_OW 302
12057: AND
12058: IFFALSE 12074
// Say ( Burlak , DArtefTechnology-Bur-2 ) else
12060: LD_EXP 46
12064: PPUSH
12065: LD_STRING DArtefTechnology-Bur-2
12067: PPUSH
12068: CALL_OW 88
12072: GO 12086
// Say ( JMM , DArtefTechnology-JMM-2 ) ;
12074: LD_EXP 14
12078: PPUSH
12079: LD_STRING DArtefTechnology-JMM-2
12081: PPUSH
12082: CALL_OW 88
// Say ( speaker [ 1 ] , DArtefTechnology-RSci1-3 ) ;
12086: LD_VAR 0 1
12090: PUSH
12091: LD_INT 1
12093: ARRAY
12094: PPUSH
12095: LD_STRING DArtefTechnology-RSci1-3
12097: PPUSH
12098: CALL_OW 88
// if Denis then
12102: LD_EXP 20
12106: IFFALSE 12123
// speaker := [ Denis ] else
12108: LD_ADDR_VAR 0 1
12112: PUSH
12113: LD_EXP 20
12117: PUSH
12118: EMPTY
12119: LIST
12120: ST_TO_ADDR
12121: GO 12229
// speaker := FilterAllUnits ( [ [ f_side , 7 ] , [ f_nation , 1 ] , [ f_class , 4 ] , [ f_type , unit_human ] , [ f_sex , sex_male ] ] ) diff [ Roth , JMM , Burlak , Titov , Kuzmov , Kovalyuk ] ;
12123: LD_ADDR_VAR 0 1
12127: PUSH
12128: LD_INT 22
12130: PUSH
12131: LD_INT 7
12133: PUSH
12134: EMPTY
12135: LIST
12136: LIST
12137: PUSH
12138: LD_INT 23
12140: PUSH
12141: LD_INT 1
12143: PUSH
12144: EMPTY
12145: LIST
12146: LIST
12147: PUSH
12148: LD_INT 25
12150: PUSH
12151: LD_INT 4
12153: PUSH
12154: EMPTY
12155: LIST
12156: LIST
12157: PUSH
12158: LD_INT 21
12160: PUSH
12161: LD_INT 1
12163: PUSH
12164: EMPTY
12165: LIST
12166: LIST
12167: PUSH
12168: LD_INT 26
12170: PUSH
12171: LD_INT 1
12173: PUSH
12174: EMPTY
12175: LIST
12176: LIST
12177: PUSH
12178: EMPTY
12179: LIST
12180: LIST
12181: LIST
12182: LIST
12183: LIST
12184: PPUSH
12185: CALL_OW 69
12189: PUSH
12190: LD_EXP 15
12194: PUSH
12195: LD_EXP 14
12199: PUSH
12200: LD_EXP 46
12204: PUSH
12205: LD_EXP 34
12209: PUSH
12210: LD_EXP 44
12214: PUSH
12215: LD_EXP 43
12219: PUSH
12220: EMPTY
12221: LIST
12222: LIST
12223: LIST
12224: LIST
12225: LIST
12226: LIST
12227: DIFF
12228: ST_TO_ADDR
// if speaker then
12229: LD_VAR 0 1
12233: IFFALSE 12275
// if alienSpotted then
12235: LD_EXP 7
12239: IFFALSE 12259
// Say ( speaker [ 1 ] , DArtefTechnology-Sci1-3 ) else
12241: LD_VAR 0 1
12245: PUSH
12246: LD_INT 1
12248: ARRAY
12249: PPUSH
12250: LD_STRING DArtefTechnology-Sci1-3
12252: PPUSH
12253: CALL_OW 88
12257: GO 12275
// Say ( speaker [ 1 ] , DArtefTechnology-Sci1-3a ) ;
12259: LD_VAR 0 1
12263: PUSH
12264: LD_INT 1
12266: ARRAY
12267: PPUSH
12268: LD_STRING DArtefTechnology-Sci1-3a
12270: PPUSH
12271: CALL_OW 88
// end ; DialogueOff ;
12275: CALL_OW 7
// end ;
12279: PPOPN 1
12281: END
// every 0 0$1 trigger artifactIResearched do var speaker ;
12282: LD_EXP 9
12286: IFFALSE 12481
12288: GO 12290
12290: DISABLE
12291: LD_INT 0
12293: PPUSH
// begin if Denis then
12294: LD_EXP 20
12298: IFFALSE 12315
// speaker := [ Denis ] else
12300: LD_ADDR_VAR 0 1
12304: PUSH
12305: LD_EXP 20
12309: PUSH
12310: EMPTY
12311: LIST
12312: ST_TO_ADDR
12313: GO 12421
// speaker := FilterAllUnits ( [ [ f_side , 7 ] , [ f_nation , 1 ] , [ f_class , 4 ] , [ f_type , unit_human ] , [ f_sex , sex_male ] ] ) diff [ Roth , JMM , Burlak , Titov , Kuzmov , Kovalyuk ] ;
12315: LD_ADDR_VAR 0 1
12319: PUSH
12320: LD_INT 22
12322: PUSH
12323: LD_INT 7
12325: PUSH
12326: EMPTY
12327: LIST
12328: LIST
12329: PUSH
12330: LD_INT 23
12332: PUSH
12333: LD_INT 1
12335: PUSH
12336: EMPTY
12337: LIST
12338: LIST
12339: PUSH
12340: LD_INT 25
12342: PUSH
12343: LD_INT 4
12345: PUSH
12346: EMPTY
12347: LIST
12348: LIST
12349: PUSH
12350: LD_INT 21
12352: PUSH
12353: LD_INT 1
12355: PUSH
12356: EMPTY
12357: LIST
12358: LIST
12359: PUSH
12360: LD_INT 26
12362: PUSH
12363: LD_INT 1
12365: PUSH
12366: EMPTY
12367: LIST
12368: LIST
12369: PUSH
12370: EMPTY
12371: LIST
12372: LIST
12373: LIST
12374: LIST
12375: LIST
12376: PPUSH
12377: CALL_OW 69
12381: PUSH
12382: LD_EXP 15
12386: PUSH
12387: LD_EXP 14
12391: PUSH
12392: LD_EXP 46
12396: PUSH
12397: LD_EXP 34
12401: PUSH
12402: LD_EXP 44
12406: PUSH
12407: LD_EXP 43
12411: PUSH
12412: EMPTY
12413: LIST
12414: LIST
12415: LIST
12416: LIST
12417: LIST
12418: LIST
12419: DIFF
12420: ST_TO_ADDR
// if not speaker then
12421: LD_VAR 0 1
12425: NOT
12426: IFFALSE 12430
// exit ;
12428: GO 12481
// Say ( speaker [ 1 ] , DArtefTechnologyAm-Sci1-1 ) ;
12430: LD_VAR 0 1
12434: PUSH
12435: LD_INT 1
12437: ARRAY
12438: PPUSH
12439: LD_STRING DArtefTechnologyAm-Sci1-1
12441: PPUSH
12442: CALL_OW 88
// if IsOk ( Burlak ) then
12446: LD_EXP 46
12450: PPUSH
12451: CALL_OW 302
12455: IFFALSE 12469
// Say ( Burlak , DArtefTechnologyAm-Bur-1 ) ;
12457: LD_EXP 46
12461: PPUSH
12462: LD_STRING DArtefTechnologyAm-Bur-1
12464: PPUSH
12465: CALL_OW 88
// Say ( JMM , DArtefTechnologyAm-JMM-1 ) ;
12469: LD_EXP 14
12473: PPUSH
12474: LD_STRING DArtefTechnologyAm-JMM-1
12476: PPUSH
12477: CALL_OW 88
// end ;
12481: PPOPN 1
12483: END
// every 0 0$1 trigger artifactIIResearched do var speaker ;
12484: LD_EXP 10
12488: IFFALSE 12699
12490: GO 12492
12492: DISABLE
12493: LD_INT 0
12495: PPUSH
// begin if Denis then
12496: LD_EXP 20
12500: IFFALSE 12517
// speaker := [ Denis ] else
12502: LD_ADDR_VAR 0 1
12506: PUSH
12507: LD_EXP 20
12511: PUSH
12512: EMPTY
12513: LIST
12514: ST_TO_ADDR
12515: GO 12623
// speaker := FilterAllUnits ( [ [ f_side , 7 ] , [ f_nation , 3 ] , [ f_class , 4 ] , [ f_type , unit_human ] , [ f_sex , sex_male ] ] ) diff [ Roth , JMM , Burlak , Titov , Kuzmov , Kovalyuk ] ;
12517: LD_ADDR_VAR 0 1
12521: PUSH
12522: LD_INT 22
12524: PUSH
12525: LD_INT 7
12527: PUSH
12528: EMPTY
12529: LIST
12530: LIST
12531: PUSH
12532: LD_INT 23
12534: PUSH
12535: LD_INT 3
12537: PUSH
12538: EMPTY
12539: LIST
12540: LIST
12541: PUSH
12542: LD_INT 25
12544: PUSH
12545: LD_INT 4
12547: PUSH
12548: EMPTY
12549: LIST
12550: LIST
12551: PUSH
12552: LD_INT 21
12554: PUSH
12555: LD_INT 1
12557: PUSH
12558: EMPTY
12559: LIST
12560: LIST
12561: PUSH
12562: LD_INT 26
12564: PUSH
12565: LD_INT 1
12567: PUSH
12568: EMPTY
12569: LIST
12570: LIST
12571: PUSH
12572: EMPTY
12573: LIST
12574: LIST
12575: LIST
12576: LIST
12577: LIST
12578: PPUSH
12579: CALL_OW 69
12583: PUSH
12584: LD_EXP 15
12588: PUSH
12589: LD_EXP 14
12593: PUSH
12594: LD_EXP 46
12598: PUSH
12599: LD_EXP 34
12603: PUSH
12604: LD_EXP 44
12608: PUSH
12609: LD_EXP 43
12613: PUSH
12614: EMPTY
12615: LIST
12616: LIST
12617: LIST
12618: LIST
12619: LIST
12620: LIST
12621: DIFF
12622: ST_TO_ADDR
// if not speaker then
12623: LD_VAR 0 1
12627: NOT
12628: IFFALSE 12632
// exit ;
12630: GO 12699
// Say ( speaker [ 1 ] , DArtefTechnologyRu-RSci1-1 ) ;
12632: LD_VAR 0 1
12636: PUSH
12637: LD_INT 1
12639: ARRAY
12640: PPUSH
12641: LD_STRING DArtefTechnologyRu-RSci1-1
12643: PPUSH
12644: CALL_OW 88
// if IsOk ( Burlak ) then
12648: LD_EXP 46
12652: PPUSH
12653: CALL_OW 302
12657: IFFALSE 12671
// Say ( Burlak , DArtefTechnologyRu-Bur-1 ) ;
12659: LD_EXP 46
12663: PPUSH
12664: LD_STRING DArtefTechnologyRu-Bur-1
12666: PPUSH
12667: CALL_OW 88
// Say ( speaker [ 1 ] , DArtefTechnologyRu-RSci1-2 ) ;
12671: LD_VAR 0 1
12675: PUSH
12676: LD_INT 1
12678: ARRAY
12679: PPUSH
12680: LD_STRING DArtefTechnologyRu-RSci1-2
12682: PPUSH
12683: CALL_OW 88
// Say ( JMM , DArtefTechnologyRu-JMM-1 ) ;
12687: LD_EXP 14
12691: PPUSH
12692: LD_STRING DArtefTechnologyRu-JMM-1
12694: PPUSH
12695: CALL_OW 88
// end ;
12699: PPOPN 1
12701: END
// every 0 0$1 trigger GetTech ( tech_Artifact , 7 ) = state_researched and GetSide ( alien ) = 7 do var speaker ;
12702: LD_INT 24
12704: PPUSH
12705: LD_INT 7
12707: PPUSH
12708: CALL_OW 321
12712: PUSH
12713: LD_INT 2
12715: EQUAL
12716: PUSH
12717: LD_INT 1
12719: PPUSH
12720: CALL_OW 255
12724: PUSH
12725: LD_INT 7
12727: EQUAL
12728: AND
12729: IFFALSE 12889
12731: GO 12733
12733: DISABLE
12734: LD_INT 0
12736: PPUSH
// begin if Denis then
12737: LD_EXP 20
12741: IFFALSE 12758
// speaker := [ Denis ] else
12743: LD_ADDR_VAR 0 1
12747: PUSH
12748: LD_EXP 20
12752: PUSH
12753: EMPTY
12754: LIST
12755: ST_TO_ADDR
12756: GO 12864
// speaker := FilterAllUnits ( [ [ f_side , 7 ] , [ f_nation , 1 ] , [ f_class , 4 ] , [ f_type , unit_human ] , [ f_sex , sex_male ] ] ) diff [ Roth , JMM , Burlak , Titov , Kuzmov , Kovalyuk ] ;
12758: LD_ADDR_VAR 0 1
12762: PUSH
12763: LD_INT 22
12765: PUSH
12766: LD_INT 7
12768: PUSH
12769: EMPTY
12770: LIST
12771: LIST
12772: PUSH
12773: LD_INT 23
12775: PUSH
12776: LD_INT 1
12778: PUSH
12779: EMPTY
12780: LIST
12781: LIST
12782: PUSH
12783: LD_INT 25
12785: PUSH
12786: LD_INT 4
12788: PUSH
12789: EMPTY
12790: LIST
12791: LIST
12792: PUSH
12793: LD_INT 21
12795: PUSH
12796: LD_INT 1
12798: PUSH
12799: EMPTY
12800: LIST
12801: LIST
12802: PUSH
12803: LD_INT 26
12805: PUSH
12806: LD_INT 1
12808: PUSH
12809: EMPTY
12810: LIST
12811: LIST
12812: PUSH
12813: EMPTY
12814: LIST
12815: LIST
12816: LIST
12817: LIST
12818: LIST
12819: PPUSH
12820: CALL_OW 69
12824: PUSH
12825: LD_EXP 15
12829: PUSH
12830: LD_EXP 14
12834: PUSH
12835: LD_EXP 46
12839: PUSH
12840: LD_EXP 34
12844: PUSH
12845: LD_EXP 44
12849: PUSH
12850: LD_EXP 43
12854: PUSH
12855: EMPTY
12856: LIST
12857: LIST
12858: LIST
12859: LIST
12860: LIST
12861: LIST
12862: DIFF
12863: ST_TO_ADDR
// if not speaker then
12864: LD_VAR 0 1
12868: NOT
12869: IFFALSE 12873
// exit ;
12871: GO 12889
// Say ( speaker [ 1 ] , DArtefTechnologyArStart-Sci1-1 ) ;
12873: LD_VAR 0 1
12877: PUSH
12878: LD_INT 1
12880: ARRAY
12881: PPUSH
12882: LD_STRING DArtefTechnologyArStart-Sci1-1
12884: PPUSH
12885: CALL_OW 88
// end ;
12889: PPOPN 1
12891: END
// every 0 0$1 trigger artifactIIIResearched do var speaker ;
12892: LD_EXP 11
12896: IFFALSE 13177
12898: GO 12900
12900: DISABLE
12901: LD_INT 0
12903: PPUSH
// begin speaker := FilterAllUnits ( [ [ f_side , 7 ] , [ f_nation , 3 ] , [ f_class , 4 ] , [ f_type , unit_human ] , [ f_sex , sex_male ] ] ) diff [ Roth , JMM , Burlak , Titov , Kuzmov , Kovalyuk ] ;
12904: LD_ADDR_VAR 0 1
12908: PUSH
12909: LD_INT 22
12911: PUSH
12912: LD_INT 7
12914: PUSH
12915: EMPTY
12916: LIST
12917: LIST
12918: PUSH
12919: LD_INT 23
12921: PUSH
12922: LD_INT 3
12924: PUSH
12925: EMPTY
12926: LIST
12927: LIST
12928: PUSH
12929: LD_INT 25
12931: PUSH
12932: LD_INT 4
12934: PUSH
12935: EMPTY
12936: LIST
12937: LIST
12938: PUSH
12939: LD_INT 21
12941: PUSH
12942: LD_INT 1
12944: PUSH
12945: EMPTY
12946: LIST
12947: LIST
12948: PUSH
12949: LD_INT 26
12951: PUSH
12952: LD_INT 1
12954: PUSH
12955: EMPTY
12956: LIST
12957: LIST
12958: PUSH
12959: EMPTY
12960: LIST
12961: LIST
12962: LIST
12963: LIST
12964: LIST
12965: PPUSH
12966: CALL_OW 69
12970: PUSH
12971: LD_EXP 15
12975: PUSH
12976: LD_EXP 14
12980: PUSH
12981: LD_EXP 46
12985: PUSH
12986: LD_EXP 34
12990: PUSH
12991: LD_EXP 44
12995: PUSH
12996: LD_EXP 43
13000: PUSH
13001: EMPTY
13002: LIST
13003: LIST
13004: LIST
13005: LIST
13006: LIST
13007: LIST
13008: DIFF
13009: ST_TO_ADDR
// if not speaker then
13010: LD_VAR 0 1
13014: NOT
13015: IFFALSE 13019
// exit ;
13017: GO 13177
// DialogueOn ;
13019: CALL_OW 6
// Say ( speaker [ 1 ] , DArtefTechnologyAr-RSci1-1 ) ;
13023: LD_VAR 0 1
13027: PUSH
13028: LD_INT 1
13030: ARRAY
13031: PPUSH
13032: LD_STRING DArtefTechnologyAr-RSci1-1
13034: PPUSH
13035: CALL_OW 88
// Say ( JMM , DArtefTechnologyAr-JMM-1 ) ;
13039: LD_EXP 14
13043: PPUSH
13044: LD_STRING DArtefTechnologyAr-JMM-1
13046: PPUSH
13047: CALL_OW 88
// Say ( speaker [ 1 ] , DArtefTechnologyAr-RSci1-2 ) ;
13051: LD_VAR 0 1
13055: PUSH
13056: LD_INT 1
13058: ARRAY
13059: PPUSH
13060: LD_STRING DArtefTechnologyAr-RSci1-2
13062: PPUSH
13063: CALL_OW 88
// Say ( JMM , DArtefTechnologyAr-JMM-2 ) ;
13067: LD_EXP 14
13071: PPUSH
13072: LD_STRING DArtefTechnologyAr-JMM-2
13074: PPUSH
13075: CALL_OW 88
// Say ( speaker [ 1 ] , DArtefTechnologyAr-RSci1-3 ) ;
13079: LD_VAR 0 1
13083: PUSH
13084: LD_INT 1
13086: ARRAY
13087: PPUSH
13088: LD_STRING DArtefTechnologyAr-RSci1-3
13090: PPUSH
13091: CALL_OW 88
// Say ( JMM , DArtefTechnologyAr-JMM-3 ) ;
13095: LD_EXP 14
13099: PPUSH
13100: LD_STRING DArtefTechnologyAr-JMM-3
13102: PPUSH
13103: CALL_OW 88
// Say ( speaker [ 1 ] , DArtefTechnologyAr-RSci1-4 ) ;
13107: LD_VAR 0 1
13111: PUSH
13112: LD_INT 1
13114: ARRAY
13115: PPUSH
13116: LD_STRING DArtefTechnologyAr-RSci1-4
13118: PPUSH
13119: CALL_OW 88
// if IsOk ( Burlak ) then
13123: LD_EXP 46
13127: PPUSH
13128: CALL_OW 302
13132: IFFALSE 13146
// Say ( Burlak , DArtefTechnologyAr-Bur-4 ) ;
13134: LD_EXP 46
13138: PPUSH
13139: LD_STRING DArtefTechnologyAr-Bur-4
13141: PPUSH
13142: CALL_OW 88
// Say ( JMM , DArtefTechnologyAr-JMM-4 ) ;
13146: LD_EXP 14
13150: PPUSH
13151: LD_STRING DArtefTechnologyAr-JMM-4
13153: PPUSH
13154: CALL_OW 88
// DialogueOff ;
13158: CALL_OW 7
// wait ( 0 0$45 ) ;
13162: LD_INT 1575
13164: PPUSH
13165: CALL_OW 67
// spawnOmar := true ;
13169: LD_ADDR_EXP 8
13173: PUSH
13174: LD_INT 1
13176: ST_TO_ADDR
// end ;
13177: PPOPN 1
13179: END
// every 0 0$1 trigger spawnOmar do
13180: LD_EXP 8
13184: IFFALSE 13564
13186: GO 13188
13188: DISABLE
// begin PrepareOmarAli ;
13189: CALL 6681 0 0
// if not HasTask ( Omar ) then
13193: LD_EXP 50
13197: PPUSH
13198: CALL_OW 314
13202: NOT
13203: IFFALSE 13220
// ComMoveXY ( Omar , 252 , 220 ) ;
13205: LD_EXP 50
13209: PPUSH
13210: LD_INT 252
13212: PPUSH
13213: LD_INT 220
13215: PPUSH
13216: CALL_OW 111
// if not Omar then
13220: LD_EXP 50
13224: NOT
13225: IFFALSE 13229
// exit ;
13227: GO 13564
// repeat wait ( 0 0$1 ) ;
13229: LD_INT 35
13231: PPUSH
13232: CALL_OW 67
// if not HasTask ( Omar ) and GetDistUnitXY ( Omar , 252 , 220 ) > 6 then
13236: LD_EXP 50
13240: PPUSH
13241: CALL_OW 314
13245: NOT
13246: PUSH
13247: LD_EXP 50
13251: PPUSH
13252: LD_INT 252
13254: PPUSH
13255: LD_INT 220
13257: PPUSH
13258: CALL_OW 297
13262: PUSH
13263: LD_INT 6
13265: GREATER
13266: AND
13267: IFFALSE 13284
// ComMoveXY ( Omar , 252 , 220 ) ;
13269: LD_EXP 50
13273: PPUSH
13274: LD_INT 252
13276: PPUSH
13277: LD_INT 220
13279: PPUSH
13280: CALL_OW 111
// until See ( 7 , Omar ) ;
13284: LD_INT 7
13286: PPUSH
13287: LD_EXP 50
13291: PPUSH
13292: CALL_OW 292
13296: IFFALSE 13229
// CenterNowOnUnits ( Omar ) ;
13298: LD_EXP 50
13302: PPUSH
13303: CALL_OW 87
// DialogueOn ;
13307: CALL_OW 6
// Say ( Omar , DOmar-Omar-1 ) ;
13311: LD_EXP 50
13315: PPUSH
13316: LD_STRING DOmar-Omar-1
13318: PPUSH
13319: CALL_OW 88
// Say ( JMM , DOmar-JMM-1 ) ;
13323: LD_EXP 14
13327: PPUSH
13328: LD_STRING DOmar-JMM-1
13330: PPUSH
13331: CALL_OW 88
// Say ( Omar , DOmar-Omar-2 ) ;
13335: LD_EXP 50
13339: PPUSH
13340: LD_STRING DOmar-Omar-2
13342: PPUSH
13343: CALL_OW 88
// Say ( JMM , DOmar-JMM-2 ) ;
13347: LD_EXP 14
13351: PPUSH
13352: LD_STRING DOmar-JMM-2
13354: PPUSH
13355: CALL_OW 88
// Say ( Omar , DOmar-Omar-3 ) ;
13359: LD_EXP 50
13363: PPUSH
13364: LD_STRING DOmar-Omar-3
13366: PPUSH
13367: CALL_OW 88
// if IsOk ( Burlak ) then
13371: LD_EXP 46
13375: PPUSH
13376: CALL_OW 302
13380: IFFALSE 13396
// Say ( Burlak , DOmar-Bur-3 ) else
13382: LD_EXP 46
13386: PPUSH
13387: LD_STRING DOmar-Bur-3
13389: PPUSH
13390: CALL_OW 88
13394: GO 13408
// Say ( JMM , DOmar-JMM-3 ) ;
13396: LD_EXP 14
13400: PPUSH
13401: LD_STRING DOmar-JMM-3
13403: PPUSH
13404: CALL_OW 88
// Say ( Omar , DOmar-Omar-4 ) ;
13408: LD_EXP 50
13412: PPUSH
13413: LD_STRING DOmar-Omar-4
13415: PPUSH
13416: CALL_OW 88
// case Query ( QAccept ) of 1 :
13420: LD_STRING QAccept
13422: PPUSH
13423: CALL_OW 97
13427: PUSH
13428: LD_INT 1
13430: DOUBLE
13431: EQUAL
13432: IFTRUE 13436
13434: GO 13472
13436: POP
// begin Say ( JMM , DQrAccept#1-JMM-1 ) ;
13437: LD_EXP 14
13441: PPUSH
13442: LD_STRING DQrAccept#1-JMM-1
13444: PPUSH
13445: CALL_OW 88
// SetSide ( Omar , 7 ) ;
13449: LD_EXP 50
13453: PPUSH
13454: LD_INT 7
13456: PPUSH
13457: CALL_OW 235
// ComStop ( Omar ) ;
13461: LD_EXP 50
13465: PPUSH
13466: CALL_OW 141
// end ; 2 :
13470: GO 13521
13472: LD_INT 2
13474: DOUBLE
13475: EQUAL
13476: IFTRUE 13480
13478: GO 13520
13480: POP
// begin if IsOk ( Burlak ) then
13481: LD_EXP 46
13485: PPUSH
13486: CALL_OW 302
13490: IFFALSE 13506
// Say ( Burlak , DQrAccept#2-Bur-1 ) else
13492: LD_EXP 46
13496: PPUSH
13497: LD_STRING DQrAccept#2-Bur-1
13499: PPUSH
13500: CALL_OW 88
13504: GO 13518
// Say ( JMM , DQrAccept#2-JMM-1 ) ;
13506: LD_EXP 14
13510: PPUSH
13511: LD_STRING DQrAccept#2-JMM-1
13513: PPUSH
13514: CALL_OW 88
// end ; end ;
13518: GO 13521
13520: POP
// DialogueOff ;
13521: CALL_OW 7
// if GetSide ( Omar ) = 7 then
13525: LD_EXP 50
13529: PPUSH
13530: CALL_OW 255
13534: PUSH
13535: LD_INT 7
13537: EQUAL
13538: IFFALSE 13549
// begin SetAchievement ( ACH_OMAR ) ;
13540: LD_STRING ACH_OMAR
13542: PPUSH
13543: CALL_OW 543
// exit ;
13547: GO 13564
// end ; ComMoveXY ( Omar , 202 , 115 ) ;
13549: LD_EXP 50
13553: PPUSH
13554: LD_INT 202
13556: PPUSH
13557: LD_INT 115
13559: PPUSH
13560: CALL_OW 111
// end ;
13564: END
// every 0 0$1 trigger GetDistUnitXY ( Omar , 200 , 98 ) < 40 and russianDestroyed do
13565: LD_EXP 50
13569: PPUSH
13570: LD_INT 200
13572: PPUSH
13573: LD_INT 98
13575: PPUSH
13576: CALL_OW 297
13580: PUSH
13581: LD_INT 40
13583: LESS
13584: PUSH
13585: LD_EXP 2
13589: AND
13590: IFFALSE 13808
13592: GO 13594
13594: DISABLE
// begin SetSide ( Omar , 5 ) ;
13595: LD_EXP 50
13599: PPUSH
13600: LD_INT 5
13602: PPUSH
13603: CALL_OW 235
// if IsInUnit ( Omar ) then
13607: LD_EXP 50
13611: PPUSH
13612: CALL_OW 310
13616: IFFALSE 13627
// ComExitVehicle ( Omar ) ;
13618: LD_EXP 50
13622: PPUSH
13623: CALL_OW 121
// if IsInUnit ( Omar ) then
13627: LD_EXP 50
13631: PPUSH
13632: CALL_OW 310
13636: IFFALSE 13647
// ComExitBuilding ( Omar ) ;
13638: LD_EXP 50
13642: PPUSH
13643: CALL_OW 122
// wait ( 0 0$1 ) ;
13647: LD_INT 35
13649: PPUSH
13650: CALL_OW 67
// ComMoveXY ( Omar , 203 , 120 ) ;
13654: LD_EXP 50
13658: PPUSH
13659: LD_INT 203
13661: PPUSH
13662: LD_INT 120
13664: PPUSH
13665: CALL_OW 111
// repeat wait ( 0 0$1 ) ;
13669: LD_INT 35
13671: PPUSH
13672: CALL_OW 67
// until IsSelected ( Omar ) or GetDistUnitXY ( Omar , 203 , 120 ) < 6 ;
13676: LD_EXP 50
13680: PPUSH
13681: CALL_OW 306
13685: PUSH
13686: LD_EXP 50
13690: PPUSH
13691: LD_INT 203
13693: PPUSH
13694: LD_INT 120
13696: PPUSH
13697: CALL_OW 297
13701: PUSH
13702: LD_INT 6
13704: LESS
13705: OR
13706: IFFALSE 13669
// CenterNowOnUnits ( Omar ) ;
13708: LD_EXP 50
13712: PPUSH
13713: CALL_OW 87
// DialogueOn ;
13717: CALL_OW 6
// Say ( JMM , DOmarContam-JMM-1 ) ;
13721: LD_EXP 14
13725: PPUSH
13726: LD_STRING DOmarContam-JMM-1
13728: PPUSH
13729: CALL_OW 88
// Say ( Omar , DOmarContam-Omar-1 ) ;
13733: LD_EXP 50
13737: PPUSH
13738: LD_STRING DOmarContam-Omar-1
13740: PPUSH
13741: CALL_OW 88
// Say ( JMM , DOmarContam-JMM-2 ) ;
13745: LD_EXP 14
13749: PPUSH
13750: LD_STRING DOmarContam-JMM-2
13752: PPUSH
13753: CALL_OW 88
// DialogueOff ;
13757: CALL_OW 7
// SetAttitude ( 5 , 7 , att_enemy , true ) ;
13761: LD_INT 5
13763: PPUSH
13764: LD_INT 7
13766: PPUSH
13767: LD_INT 2
13769: PPUSH
13770: LD_INT 1
13772: PPUSH
13773: CALL_OW 80
// repeat wait ( 0 0$3 ) ;
13777: LD_INT 105
13779: PPUSH
13780: CALL_OW 67
// until IsAt ( Omar , 203 , 120 ) ;
13784: LD_EXP 50
13788: PPUSH
13789: LD_INT 203
13791: PPUSH
13792: LD_INT 120
13794: PPUSH
13795: CALL_OW 307
13799: IFFALSE 13777
// YouLost ( MothContaminate ) ;
13801: LD_STRING MothContaminate
13803: PPUSH
13804: CALL_OW 104
// end ;
13808: END
// every 0 0$2 trigger not americanDestroyed and FilterAllUnits ( [ [ f_side , 1 ] , [ f_weapon , us_siberium_rocket ] ] ) do
13809: LD_EXP 4
13813: NOT
13814: PUSH
13815: LD_INT 22
13817: PUSH
13818: LD_INT 1
13820: PUSH
13821: EMPTY
13822: LIST
13823: LIST
13824: PUSH
13825: LD_INT 34
13827: PUSH
13828: LD_INT 8
13830: PUSH
13831: EMPTY
13832: LIST
13833: LIST
13834: PUSH
13835: EMPTY
13836: LIST
13837: LIST
13838: PPUSH
13839: CALL_OW 69
13843: AND
13844: IFFALSE 13925
13846: GO 13848
13848: DISABLE
// begin if not IsOk ( Powell ) then
13849: LD_EXP 49
13853: PPUSH
13854: CALL_OW 302
13858: NOT
13859: IFFALSE 13863
// exit ;
13861: GO 13925
// DialogueOn ;
13863: CALL_OW 6
// SayRadio ( Powell , DWinAmericans-Pow-1 ) ;
13867: LD_EXP 49
13871: PPUSH
13872: LD_STRING DWinAmericans-Pow-1
13874: PPUSH
13875: CALL_OW 94
// if IsOk ( Burlak ) then
13879: LD_EXP 46
13883: PPUSH
13884: CALL_OW 302
13888: IFFALSE 13902
// Say ( Burlak , DWinAmericans-Bur-1 ) ;
13890: LD_EXP 46
13894: PPUSH
13895: LD_STRING DWinAmericans-Bur-1
13897: PPUSH
13898: CALL_OW 88
// Say ( JMM , DWinAmericans-JMM-1 ) ;
13902: LD_EXP 14
13906: PPUSH
13907: LD_STRING DWinAmericans-JMM-1
13909: PPUSH
13910: CALL_OW 88
// DialogueOff ;
13914: CALL_OW 7
// YouLost ( AmBomb ) ;
13918: LD_STRING AmBomb
13920: PPUSH
13921: CALL_OW 104
// end ;
13925: END
// every 0 0$2 trigger not russianDestroyed and FilterAllUnits ( [ [ f_side , 3 ] , [ f_weapon , ru_siberium_rocket ] ] ) do
13926: LD_EXP 2
13930: NOT
13931: PUSH
13932: LD_INT 22
13934: PUSH
13935: LD_INT 3
13937: PUSH
13938: EMPTY
13939: LIST
13940: LIST
13941: PUSH
13942: LD_INT 34
13944: PUSH
13945: LD_INT 48
13947: PUSH
13948: EMPTY
13949: LIST
13950: LIST
13951: PUSH
13952: EMPTY
13953: LIST
13954: LIST
13955: PPUSH
13956: CALL_OW 69
13960: AND
13961: IFFALSE 14042
13963: GO 13965
13965: DISABLE
// begin if not IsOk ( Platonov ) then
13966: LD_EXP 53
13970: PPUSH
13971: CALL_OW 302
13975: NOT
13976: IFFALSE 13980
// exit ;
13978: GO 14042
// DialogueOn ;
13980: CALL_OW 6
// SayRadio ( Platonov , DWinRussians-Pla-1 ) ;
13984: LD_EXP 53
13988: PPUSH
13989: LD_STRING DWinRussians-Pla-1
13991: PPUSH
13992: CALL_OW 94
// if IsOk ( Burlak ) then
13996: LD_EXP 46
14000: PPUSH
14001: CALL_OW 302
14005: IFFALSE 14019
// Say ( Burlak , DWinRussians-Bur-1 ) ;
14007: LD_EXP 46
14011: PPUSH
14012: LD_STRING DWinRussians-Bur-1
14014: PPUSH
14015: CALL_OW 88
// Say ( JMM , DWinRussians-JMM-1 ) ;
14019: LD_EXP 14
14023: PPUSH
14024: LD_STRING DWinRussians-JMM-1
14026: PPUSH
14027: CALL_OW 88
// DialogueOff ;
14031: CALL_OW 7
// YouLost ( RuBomb ) ;
14035: LD_STRING RuBomb
14037: PPUSH
14038: CALL_OW 104
// end ;
14042: END
// every 0 0$20 trigger FilterUnitsInArea ( powellBase , [ f_side , 7 ] ) and not americanDestroyed do
14043: LD_INT 7
14045: PPUSH
14046: LD_INT 22
14048: PUSH
14049: LD_INT 7
14051: PUSH
14052: EMPTY
14053: LIST
14054: LIST
14055: PPUSH
14056: CALL_OW 70
14060: PUSH
14061: LD_EXP 4
14065: NOT
14066: AND
14067: IFFALSE 14096
14069: GO 14071
14071: DISABLE
// begin SayRadio ( Powell , DSurrenderAmericans-Pow-1 ) ;
14072: LD_EXP 49
14076: PPUSH
14077: LD_STRING DSurrenderAmericans-Pow-1
14079: PPUSH
14080: CALL_OW 94
// Say ( JMM , DSurrenderAmericans-JMM-1 ) ;
14084: LD_EXP 14
14088: PPUSH
14089: LD_STRING DSurrenderAmericans-JMM-1
14091: PPUSH
14092: CALL_OW 88
// end ;
14096: END
// every 0 0$20 trigger FilterUnitsInArea ( russianBaseArea , [ f_side , 7 ] ) and not russianDestroyed and Burlak do
14097: LD_INT 2
14099: PPUSH
14100: LD_INT 22
14102: PUSH
14103: LD_INT 7
14105: PUSH
14106: EMPTY
14107: LIST
14108: LIST
14109: PPUSH
14110: CALL_OW 70
14114: PUSH
14115: LD_EXP 2
14119: NOT
14120: AND
14121: PUSH
14122: LD_EXP 46
14126: AND
14127: IFFALSE 14156
14129: GO 14131
14131: DISABLE
// begin SayRadio ( Platonov , DSurrenderRussians-Pla-1 ) ;
14132: LD_EXP 53
14136: PPUSH
14137: LD_STRING DSurrenderRussians-Pla-1
14139: PPUSH
14140: CALL_OW 94
// Say ( Burlak , DSurrenderRussians-Bur-1 ) ;
14144: LD_EXP 46
14148: PPUSH
14149: LD_STRING DSurrenderRussians-Bur-1
14151: PPUSH
14152: CALL_OW 88
// end ;
14156: END
// every 0 0$2 + 0 0$5 trigger americanDestroyed do var i , tmp , speaker ;
14157: LD_EXP 4
14161: IFFALSE 14536
14163: GO 14165
14165: DISABLE
14166: LD_INT 0
14168: PPUSH
14169: PPUSH
14170: PPUSH
// begin MC_Kill ( 4 ) ;
14171: LD_INT 4
14173: PPUSH
14174: CALL 20702 0 1
// SetAttitude ( 1 , 7 , att_friend , true ) ;
14178: LD_INT 1
14180: PPUSH
14181: LD_INT 7
14183: PPUSH
14184: LD_INT 1
14186: PPUSH
14187: LD_INT 1
14189: PPUSH
14190: CALL_OW 80
// speaker := FilterAllUnits ( [ [ f_side , 1 ] , [ f_sex , sex_male ] , [ f_nation , 1 ] ] ) diff [ Powell , Gladstone , Cyrus , Bobby , Gary , Houten ] ;
14194: LD_ADDR_VAR 0 3
14198: PUSH
14199: LD_INT 22
14201: PUSH
14202: LD_INT 1
14204: PUSH
14205: EMPTY
14206: LIST
14207: LIST
14208: PUSH
14209: LD_INT 26
14211: PUSH
14212: LD_INT 1
14214: PUSH
14215: EMPTY
14216: LIST
14217: LIST
14218: PUSH
14219: LD_INT 23
14221: PUSH
14222: LD_INT 1
14224: PUSH
14225: EMPTY
14226: LIST
14227: LIST
14228: PUSH
14229: EMPTY
14230: LIST
14231: LIST
14232: LIST
14233: PPUSH
14234: CALL_OW 69
14238: PUSH
14239: LD_EXP 49
14243: PUSH
14244: LD_EXP 22
14248: PUSH
14249: LD_EXP 19
14253: PUSH
14254: LD_EXP 18
14258: PUSH
14259: LD_EXP 25
14263: PUSH
14264: LD_EXP 23
14268: PUSH
14269: EMPTY
14270: LIST
14271: LIST
14272: LIST
14273: LIST
14274: LIST
14275: LIST
14276: DIFF
14277: ST_TO_ADDR
// if speaker then
14278: LD_VAR 0 3
14282: IFFALSE 14308
// begin DialogueOn ;
14284: CALL_OW 6
// SayRadio ( speaker [ 1 ] , DSurrenderAmericans-Sol1-1a ) ;
14288: LD_VAR 0 3
14292: PUSH
14293: LD_INT 1
14295: ARRAY
14296: PPUSH
14297: LD_STRING DSurrenderAmericans-Sol1-1a
14299: PPUSH
14300: CALL_OW 94
// DialogueOff ;
14304: CALL_OW 7
// end ; tmp := FilterAllUnits ( [ [ f_side , 1 ] , [ f_type , unit_human ] ] ) ^ FilterAllUnits ( [ [ f_side , 1 ] , [ f_type , unit_vehicle ] , [ control_manual ] ] ) ;
14308: LD_ADDR_VAR 0 2
14312: PUSH
14313: LD_INT 22
14315: PUSH
14316: LD_INT 1
14318: PUSH
14319: EMPTY
14320: LIST
14321: LIST
14322: PUSH
14323: LD_INT 21
14325: PUSH
14326: LD_INT 1
14328: PUSH
14329: EMPTY
14330: LIST
14331: LIST
14332: PUSH
14333: EMPTY
14334: LIST
14335: LIST
14336: PPUSH
14337: CALL_OW 69
14341: PUSH
14342: LD_INT 22
14344: PUSH
14345: LD_INT 1
14347: PUSH
14348: EMPTY
14349: LIST
14350: LIST
14351: PUSH
14352: LD_INT 21
14354: PUSH
14355: LD_INT 2
14357: PUSH
14358: EMPTY
14359: LIST
14360: LIST
14361: PUSH
14362: LD_INT 1
14364: PUSH
14365: EMPTY
14366: LIST
14367: PUSH
14368: EMPTY
14369: LIST
14370: LIST
14371: LIST
14372: PPUSH
14373: CALL_OW 69
14377: ADD
14378: ST_TO_ADDR
// if tmp then
14379: LD_VAR 0 2
14383: IFFALSE 14536
// repeat wait ( 0 0$1 ) ;
14385: LD_INT 35
14387: PPUSH
14388: CALL_OW 67
// for i in tmp do
14392: LD_ADDR_VAR 0 1
14396: PUSH
14397: LD_VAR 0 2
14401: PUSH
14402: FOR_IN
14403: IFFALSE 14485
// begin if IsInUnit ( i ) and GetType ( IsInUnit ( i ) ) = unit_building then
14405: LD_VAR 0 1
14409: PPUSH
14410: CALL_OW 310
14414: PUSH
14415: LD_VAR 0 1
14419: PPUSH
14420: CALL_OW 310
14424: PPUSH
14425: CALL_OW 247
14429: PUSH
14430: LD_INT 3
14432: EQUAL
14433: AND
14434: IFFALSE 14445
// ComExitBuilding ( i ) ;
14436: LD_VAR 0 1
14440: PPUSH
14441: CALL_OW 122
// AddComMoveXY ( i , 122 , 242 ) ;
14445: LD_VAR 0 1
14449: PPUSH
14450: LD_INT 122
14452: PPUSH
14453: LD_INT 242
14455: PPUSH
14456: CALL_OW 171
// if IsInArea ( i , americanEscape ) then
14460: LD_VAR 0 1
14464: PPUSH
14465: LD_INT 35
14467: PPUSH
14468: CALL_OW 308
14472: IFFALSE 14483
// RemoveUnit ( i ) ;
14474: LD_VAR 0 1
14478: PPUSH
14479: CALL_OW 64
// end ;
14483: GO 14402
14485: POP
14486: POP
// until not FilterAllUnits ( [ [ f_side , 1 ] , [ f_or , [ f_type , unit_human ] , [ f_control , control_manual ] ] ] ) ;
14487: LD_INT 22
14489: PUSH
14490: LD_INT 1
14492: PUSH
14493: EMPTY
14494: LIST
14495: LIST
14496: PUSH
14497: LD_INT 2
14499: PUSH
14500: LD_INT 21
14502: PUSH
14503: LD_INT 1
14505: PUSH
14506: EMPTY
14507: LIST
14508: LIST
14509: PUSH
14510: LD_INT 33
14512: PUSH
14513: LD_INT 1
14515: PUSH
14516: EMPTY
14517: LIST
14518: LIST
14519: PUSH
14520: EMPTY
14521: LIST
14522: LIST
14523: LIST
14524: PUSH
14525: EMPTY
14526: LIST
14527: LIST
14528: PPUSH
14529: CALL_OW 69
14533: NOT
14534: IFFALSE 14385
// end ;
14536: PPOPN 3
14538: END
// every 0 0$2 + 0 0$5 trigger russianDestroyed do var i , tmp , speaker ;
14539: LD_EXP 2
14543: IFFALSE 14936
14545: GO 14547
14547: DISABLE
14548: LD_INT 0
14550: PPUSH
14551: PPUSH
14552: PPUSH
// begin repeat wait ( 0 0$1 ) ;
14553: LD_INT 35
14555: PPUSH
14556: CALL_OW 67
// until IsDead ( Yakotich ) ;
14560: LD_EXP 54
14564: PPUSH
14565: CALL_OW 301
14569: IFFALSE 14553
// MC_Kill ( 2 ) ;
14571: LD_INT 2
14573: PPUSH
14574: CALL 20702 0 1
// SetAttitude ( 3 , 7 , att_friend , true ) ;
14578: LD_INT 3
14580: PPUSH
14581: LD_INT 7
14583: PPUSH
14584: LD_INT 1
14586: PPUSH
14587: LD_INT 1
14589: PPUSH
14590: CALL_OW 80
// speaker := FilterAllUnits ( [ [ f_side , 3 ] , [ f_sex , sex_male ] , [ f_nation , 3 ] ] ) diff [ Platonov , Yakotich ] ;
14594: LD_ADDR_VAR 0 3
14598: PUSH
14599: LD_INT 22
14601: PUSH
14602: LD_INT 3
14604: PUSH
14605: EMPTY
14606: LIST
14607: LIST
14608: PUSH
14609: LD_INT 26
14611: PUSH
14612: LD_INT 1
14614: PUSH
14615: EMPTY
14616: LIST
14617: LIST
14618: PUSH
14619: LD_INT 23
14621: PUSH
14622: LD_INT 3
14624: PUSH
14625: EMPTY
14626: LIST
14627: LIST
14628: PUSH
14629: EMPTY
14630: LIST
14631: LIST
14632: LIST
14633: PPUSH
14634: CALL_OW 69
14638: PUSH
14639: LD_EXP 53
14643: PUSH
14644: LD_EXP 54
14648: PUSH
14649: EMPTY
14650: LIST
14651: LIST
14652: DIFF
14653: ST_TO_ADDR
// if speaker then
14654: LD_VAR 0 3
14658: IFFALSE 14708
// begin DialogueOn ;
14660: CALL_OW 6
// if Burlak then
14664: LD_EXP 46
14668: IFFALSE 14688
// SayRadio ( speaker [ 1 ] , DSurrenderRussians-RSol1-1 ) else
14670: LD_VAR 0 3
14674: PUSH
14675: LD_INT 1
14677: ARRAY
14678: PPUSH
14679: LD_STRING DSurrenderRussians-RSol1-1
14681: PPUSH
14682: CALL_OW 94
14686: GO 14704
// SayRadio ( speaker [ 1 ] , DSurrenderRussians-RSol1-1a ) ;
14688: LD_VAR 0 3
14692: PUSH
14693: LD_INT 1
14695: ARRAY
14696: PPUSH
14697: LD_STRING DSurrenderRussians-RSol1-1a
14699: PPUSH
14700: CALL_OW 94
// DialogueOff ;
14704: CALL_OW 7
// end ; tmp := FilterAllUnits ( [ [ f_side , 3 ] , [ f_type , unit_human ] ] ) ^ FilterAllUnits ( [ [ f_side , 3 ] , [ f_type , unit_vehicle ] , [ control_manual ] ] ) ;
14708: LD_ADDR_VAR 0 2
14712: PUSH
14713: LD_INT 22
14715: PUSH
14716: LD_INT 3
14718: PUSH
14719: EMPTY
14720: LIST
14721: LIST
14722: PUSH
14723: LD_INT 21
14725: PUSH
14726: LD_INT 1
14728: PUSH
14729: EMPTY
14730: LIST
14731: LIST
14732: PUSH
14733: EMPTY
14734: LIST
14735: LIST
14736: PPUSH
14737: CALL_OW 69
14741: PUSH
14742: LD_INT 22
14744: PUSH
14745: LD_INT 3
14747: PUSH
14748: EMPTY
14749: LIST
14750: LIST
14751: PUSH
14752: LD_INT 21
14754: PUSH
14755: LD_INT 2
14757: PUSH
14758: EMPTY
14759: LIST
14760: LIST
14761: PUSH
14762: LD_INT 1
14764: PUSH
14765: EMPTY
14766: LIST
14767: PUSH
14768: EMPTY
14769: LIST
14770: LIST
14771: LIST
14772: PPUSH
14773: CALL_OW 69
14777: ADD
14778: ST_TO_ADDR
// if tmp then
14779: LD_VAR 0 2
14783: IFFALSE 14936
// repeat wait ( 0 0$1 ) ;
14785: LD_INT 35
14787: PPUSH
14788: CALL_OW 67
// for i in tmp do
14792: LD_ADDR_VAR 0 1
14796: PUSH
14797: LD_VAR 0 2
14801: PUSH
14802: FOR_IN
14803: IFFALSE 14885
// begin if IsInUnit ( i ) and GetType ( IsInUnit ( i ) ) = unit_building then
14805: LD_VAR 0 1
14809: PPUSH
14810: CALL_OW 310
14814: PUSH
14815: LD_VAR 0 1
14819: PPUSH
14820: CALL_OW 310
14824: PPUSH
14825: CALL_OW 247
14829: PUSH
14830: LD_INT 3
14832: EQUAL
14833: AND
14834: IFFALSE 14845
// ComExitBuilding ( i ) ;
14836: LD_VAR 0 1
14840: PPUSH
14841: CALL_OW 122
// AddComMoveXY ( i , 154 , 1 ) ;
14845: LD_VAR 0 1
14849: PPUSH
14850: LD_INT 154
14852: PPUSH
14853: LD_INT 1
14855: PPUSH
14856: CALL_OW 171
// if IsInArea ( i , russianEscape ) then
14860: LD_VAR 0 1
14864: PPUSH
14865: LD_INT 36
14867: PPUSH
14868: CALL_OW 308
14872: IFFALSE 14883
// RemoveUnit ( i ) ;
14874: LD_VAR 0 1
14878: PPUSH
14879: CALL_OW 64
// end ;
14883: GO 14802
14885: POP
14886: POP
// until not FilterAllUnits ( [ [ f_side , 3 ] , [ f_or , [ f_type , unit_human ] , [ f_control , control_manual ] ] ] ) ;
14887: LD_INT 22
14889: PUSH
14890: LD_INT 3
14892: PUSH
14893: EMPTY
14894: LIST
14895: LIST
14896: PUSH
14897: LD_INT 2
14899: PUSH
14900: LD_INT 21
14902: PUSH
14903: LD_INT 1
14905: PUSH
14906: EMPTY
14907: LIST
14908: LIST
14909: PUSH
14910: LD_INT 33
14912: PUSH
14913: LD_INT 1
14915: PUSH
14916: EMPTY
14917: LIST
14918: LIST
14919: PUSH
14920: EMPTY
14921: LIST
14922: LIST
14923: LIST
14924: PUSH
14925: EMPTY
14926: LIST
14927: LIST
14928: PPUSH
14929: CALL_OW 69
14933: NOT
14934: IFFALSE 14785
// end ;
14936: PPOPN 3
14938: END
// every 0 0$3 trigger FilterAllUnits ( [ [ f_side , 8 ] , [ f_type , unit_human ] , [ f_nation , 2 ] ] ) < 18 or IsDead ( Kozlov ) or GetSide ( ar_depot1 ) = 7 do
14939: LD_INT 22
14941: PUSH
14942: LD_INT 8
14944: PUSH
14945: EMPTY
14946: LIST
14947: LIST
14948: PUSH
14949: LD_INT 21
14951: PUSH
14952: LD_INT 1
14954: PUSH
14955: EMPTY
14956: LIST
14957: LIST
14958: PUSH
14959: LD_INT 23
14961: PUSH
14962: LD_INT 2
14964: PUSH
14965: EMPTY
14966: LIST
14967: LIST
14968: PUSH
14969: EMPTY
14970: LIST
14971: LIST
14972: LIST
14973: PPUSH
14974: CALL_OW 69
14978: PUSH
14979: LD_INT 18
14981: LESS
14982: PUSH
14983: LD_EXP 52
14987: PPUSH
14988: CALL_OW 301
14992: OR
14993: PUSH
14994: LD_INT 324
14996: PPUSH
14997: CALL_OW 255
15001: PUSH
15002: LD_INT 7
15004: EQUAL
15005: OR
15006: IFFALSE 15019
15008: GO 15010
15010: DISABLE
// legionDestroyed := true ;
15011: LD_ADDR_EXP 3
15015: PUSH
15016: LD_INT 1
15018: ST_TO_ADDR
15019: END
// every 0 0$3 trigger FilterAllUnits ( [ [ f_side , 2 ] , [ f_type , unit_human ] , [ f_nation , 2 ] ] ) < 9 do
15020: LD_INT 22
15022: PUSH
15023: LD_INT 2
15025: PUSH
15026: EMPTY
15027: LIST
15028: LIST
15029: PUSH
15030: LD_INT 21
15032: PUSH
15033: LD_INT 1
15035: PUSH
15036: EMPTY
15037: LIST
15038: LIST
15039: PUSH
15040: LD_INT 23
15042: PUSH
15043: LD_INT 2
15045: PUSH
15046: EMPTY
15047: LIST
15048: LIST
15049: PUSH
15050: EMPTY
15051: LIST
15052: LIST
15053: LIST
15054: PPUSH
15055: CALL_OW 69
15059: PUSH
15060: LD_INT 9
15062: LESS
15063: IFFALSE 15076
15065: GO 15067
15067: DISABLE
// arabianDestroyed := true ;
15068: LD_ADDR_EXP 5
15072: PUSH
15073: LD_INT 1
15075: ST_TO_ADDR
15076: END
// every 0 0$1 trigger arabianDestroyed do var i , tmp ;
15077: LD_EXP 5
15081: IFFALSE 15341
15083: GO 15085
15085: DISABLE
15086: LD_INT 0
15088: PPUSH
15089: PPUSH
// begin MC_Kill ( 1 ) ;
15090: LD_INT 1
15092: PPUSH
15093: CALL 20702 0 1
// SetAttitude ( 2 , 7 , att_friend , true ) ;
15097: LD_INT 2
15099: PPUSH
15100: LD_INT 7
15102: PPUSH
15103: LD_INT 1
15105: PPUSH
15106: LD_INT 1
15108: PPUSH
15109: CALL_OW 80
// tmp := FilterAllUnits ( [ [ f_side , 2 ] , [ f_type , unit_human ] ] ) ^ FilterAllUnits ( [ [ f_side , 8 ] , [ f_type , unit_vehicle ] , [ control_manual ] ] ) ;
15113: LD_ADDR_VAR 0 2
15117: PUSH
15118: LD_INT 22
15120: PUSH
15121: LD_INT 2
15123: PUSH
15124: EMPTY
15125: LIST
15126: LIST
15127: PUSH
15128: LD_INT 21
15130: PUSH
15131: LD_INT 1
15133: PUSH
15134: EMPTY
15135: LIST
15136: LIST
15137: PUSH
15138: EMPTY
15139: LIST
15140: LIST
15141: PPUSH
15142: CALL_OW 69
15146: PUSH
15147: LD_INT 22
15149: PUSH
15150: LD_INT 8
15152: PUSH
15153: EMPTY
15154: LIST
15155: LIST
15156: PUSH
15157: LD_INT 21
15159: PUSH
15160: LD_INT 2
15162: PUSH
15163: EMPTY
15164: LIST
15165: LIST
15166: PUSH
15167: LD_INT 1
15169: PUSH
15170: EMPTY
15171: LIST
15172: PUSH
15173: EMPTY
15174: LIST
15175: LIST
15176: LIST
15177: PPUSH
15178: CALL_OW 69
15182: ADD
15183: ST_TO_ADDR
// if tmp then
15184: LD_VAR 0 2
15188: IFFALSE 15341
// repeat wait ( 0 0$1 ) ;
15190: LD_INT 35
15192: PPUSH
15193: CALL_OW 67
// for i in tmp do
15197: LD_ADDR_VAR 0 1
15201: PUSH
15202: LD_VAR 0 2
15206: PUSH
15207: FOR_IN
15208: IFFALSE 15290
// begin if IsInUnit ( i ) and GetType ( IsInUnit ( i ) ) = unit_building then
15210: LD_VAR 0 1
15214: PPUSH
15215: CALL_OW 310
15219: PUSH
15220: LD_VAR 0 1
15224: PPUSH
15225: CALL_OW 310
15229: PPUSH
15230: CALL_OW 247
15234: PUSH
15235: LD_INT 3
15237: EQUAL
15238: AND
15239: IFFALSE 15250
// ComExitBuilding ( i ) ;
15241: LD_VAR 0 1
15245: PPUSH
15246: CALL_OW 122
// AddComMoveXY ( i , 254 , 268 ) ;
15250: LD_VAR 0 1
15254: PPUSH
15255: LD_INT 254
15257: PPUSH
15258: LD_INT 268
15260: PPUSH
15261: CALL_OW 171
// if IsInArea ( i , arabEscape ) then
15265: LD_VAR 0 1
15269: PPUSH
15270: LD_INT 34
15272: PPUSH
15273: CALL_OW 308
15277: IFFALSE 15288
// RemoveUnit ( i ) ;
15279: LD_VAR 0 1
15283: PPUSH
15284: CALL_OW 64
// end ;
15288: GO 15207
15290: POP
15291: POP
// until not FilterAllUnits ( [ [ f_side , 2 ] , [ f_or , [ f_type , unit_human ] , [ f_control , control_manual ] ] ] ) ;
15292: LD_INT 22
15294: PUSH
15295: LD_INT 2
15297: PUSH
15298: EMPTY
15299: LIST
15300: LIST
15301: PUSH
15302: LD_INT 2
15304: PUSH
15305: LD_INT 21
15307: PUSH
15308: LD_INT 1
15310: PUSH
15311: EMPTY
15312: LIST
15313: LIST
15314: PUSH
15315: LD_INT 33
15317: PUSH
15318: LD_INT 1
15320: PUSH
15321: EMPTY
15322: LIST
15323: LIST
15324: PUSH
15325: EMPTY
15326: LIST
15327: LIST
15328: LIST
15329: PUSH
15330: EMPTY
15331: LIST
15332: LIST
15333: PPUSH
15334: CALL_OW 69
15338: NOT
15339: IFFALSE 15190
// end ;
15341: PPOPN 2
15343: END
// every 0 0$1 trigger legionDestroyed do var i , tmp ;
15344: LD_EXP 3
15348: IFFALSE 15692
15350: GO 15352
15352: DISABLE
15353: LD_INT 0
15355: PPUSH
15356: PPUSH
// begin MC_Kill ( 3 ) ;
15357: LD_INT 3
15359: PPUSH
15360: CALL 20702 0 1
// SetAttitude ( 8 , 7 , att_friend , true ) ;
15364: LD_INT 8
15366: PPUSH
15367: LD_INT 7
15369: PPUSH
15370: LD_INT 1
15372: PPUSH
15373: LD_INT 1
15375: PPUSH
15376: CALL_OW 80
// DialogueOn ;
15380: CALL_OW 6
// SayRadio ( Schulz , D15-Szulc-1 ) ;
15384: LD_EXP 51
15388: PPUSH
15389: LD_STRING D15-Szulc-1
15391: PPUSH
15392: CALL_OW 94
// DialogueOff ;
15396: CALL_OW 7
// for i in FilterAllUnits ( [ [ f_side , 8 ] , [ f_type , unit_building ] , [ f_nation , 3 ] ] ) do
15400: LD_ADDR_VAR 0 1
15404: PUSH
15405: LD_INT 22
15407: PUSH
15408: LD_INT 8
15410: PUSH
15411: EMPTY
15412: LIST
15413: LIST
15414: PUSH
15415: LD_INT 21
15417: PUSH
15418: LD_INT 3
15420: PUSH
15421: EMPTY
15422: LIST
15423: LIST
15424: PUSH
15425: LD_INT 23
15427: PUSH
15428: LD_INT 3
15430: PUSH
15431: EMPTY
15432: LIST
15433: LIST
15434: PUSH
15435: EMPTY
15436: LIST
15437: LIST
15438: LIST
15439: PPUSH
15440: CALL_OW 69
15444: PUSH
15445: FOR_IN
15446: IFFALSE 15462
// SetLives ( i , 3 ) ;
15448: LD_VAR 0 1
15452: PPUSH
15453: LD_INT 3
15455: PPUSH
15456: CALL_OW 234
15460: GO 15445
15462: POP
15463: POP
// tmp := FilterAllUnits ( [ [ f_side , 8 ] , [ f_type , unit_human ] ] ) ^ FilterAllUnits ( [ [ f_side , 8 ] , [ f_type , unit_vehicle ] , [ control_manual ] ] ) ;
15464: LD_ADDR_VAR 0 2
15468: PUSH
15469: LD_INT 22
15471: PUSH
15472: LD_INT 8
15474: PUSH
15475: EMPTY
15476: LIST
15477: LIST
15478: PUSH
15479: LD_INT 21
15481: PUSH
15482: LD_INT 1
15484: PUSH
15485: EMPTY
15486: LIST
15487: LIST
15488: PUSH
15489: EMPTY
15490: LIST
15491: LIST
15492: PPUSH
15493: CALL_OW 69
15497: PUSH
15498: LD_INT 22
15500: PUSH
15501: LD_INT 8
15503: PUSH
15504: EMPTY
15505: LIST
15506: LIST
15507: PUSH
15508: LD_INT 21
15510: PUSH
15511: LD_INT 2
15513: PUSH
15514: EMPTY
15515: LIST
15516: LIST
15517: PUSH
15518: LD_INT 1
15520: PUSH
15521: EMPTY
15522: LIST
15523: PUSH
15524: EMPTY
15525: LIST
15526: LIST
15527: LIST
15528: PPUSH
15529: CALL_OW 69
15533: ADD
15534: ST_TO_ADDR
// if tmp then
15535: LD_VAR 0 2
15539: IFFALSE 15692
// repeat wait ( 0 0$1 ) ;
15541: LD_INT 35
15543: PPUSH
15544: CALL_OW 67
// for i in tmp do
15548: LD_ADDR_VAR 0 1
15552: PUSH
15553: LD_VAR 0 2
15557: PUSH
15558: FOR_IN
15559: IFFALSE 15641
// begin if IsInUnit ( i ) and GetType ( IsInUnit ( i ) ) = unit_building then
15561: LD_VAR 0 1
15565: PPUSH
15566: CALL_OW 310
15570: PUSH
15571: LD_VAR 0 1
15575: PPUSH
15576: CALL_OW 310
15580: PPUSH
15581: CALL_OW 247
15585: PUSH
15586: LD_INT 3
15588: EQUAL
15589: AND
15590: IFFALSE 15601
// ComExitBuilding ( i ) ;
15592: LD_VAR 0 1
15596: PPUSH
15597: CALL_OW 122
// AddComMoveXY ( i , 10 , 1 ) ;
15601: LD_VAR 0 1
15605: PPUSH
15606: LD_INT 10
15608: PPUSH
15609: LD_INT 1
15611: PPUSH
15612: CALL_OW 171
// if IsInArea ( i , legionEscape ) then
15616: LD_VAR 0 1
15620: PPUSH
15621: LD_INT 32
15623: PPUSH
15624: CALL_OW 308
15628: IFFALSE 15639
// RemoveUnit ( i ) ;
15630: LD_VAR 0 1
15634: PPUSH
15635: CALL_OW 64
// end ;
15639: GO 15558
15641: POP
15642: POP
// until not FilterAllUnits ( [ [ f_side , 8 ] , [ f_or , [ f_type , unit_human ] , [ f_control , control_manual ] ] ] ) ;
15643: LD_INT 22
15645: PUSH
15646: LD_INT 8
15648: PUSH
15649: EMPTY
15650: LIST
15651: LIST
15652: PUSH
15653: LD_INT 2
15655: PUSH
15656: LD_INT 21
15658: PUSH
15659: LD_INT 1
15661: PUSH
15662: EMPTY
15663: LIST
15664: LIST
15665: PUSH
15666: LD_INT 33
15668: PUSH
15669: LD_INT 1
15671: PUSH
15672: EMPTY
15673: LIST
15674: LIST
15675: PUSH
15676: EMPTY
15677: LIST
15678: LIST
15679: LIST
15680: PUSH
15681: EMPTY
15682: LIST
15683: LIST
15684: PPUSH
15685: CALL_OW 69
15689: NOT
15690: IFFALSE 15541
// end ;
15692: PPOPN 2
15694: END
// every 0 0$3 trigger americanDestroyed and russianDestroyed and legionDestroyed and arabianDestroyed do var med1 , med2 ;
15695: LD_EXP 4
15699: PUSH
15700: LD_EXP 2
15704: AND
15705: PUSH
15706: LD_EXP 3
15710: AND
15711: PUSH
15712: LD_EXP 5
15716: AND
15717: IFFALSE 17101
15719: GO 15721
15721: DISABLE
15722: LD_INT 0
15724: PPUSH
15725: PPUSH
// begin music_class := 5 ;
15726: LD_ADDR_OWVAR 72
15730: PUSH
15731: LD_INT 5
15733: ST_TO_ADDR
// music_nat := 5 ;
15734: LD_ADDR_OWVAR 71
15738: PUSH
15739: LD_INT 5
15741: ST_TO_ADDR
// if vehicleLostCounter < 3 then
15742: LD_EXP 12
15746: PUSH
15747: LD_INT 3
15749: LESS
15750: IFFALSE 15759
// SetAchievement ( ACH_ECONOMY ) ;
15752: LD_STRING ACH_ECONOMY
15754: PPUSH
15755: CALL_OW 543
// if tick < 60 60$00 then
15759: LD_OWVAR 1
15763: PUSH
15764: LD_INT 126000
15766: LESS
15767: IFFALSE 15783
// begin wait ( 3 ) ;
15769: LD_INT 3
15771: PPUSH
15772: CALL_OW 67
// SetAchievement ( ACH_ASPEED_19 ) ;
15776: LD_STRING ACH_ASPEED_19
15778: PPUSH
15779: CALL_OW 543
// end ; CenterNowOnUnits ( JMM ) ;
15783: LD_EXP 14
15787: PPUSH
15788: CALL_OW 87
// InGameOn ;
15792: CALL_OW 8
// DialogueOn ;
15796: CALL_OW 6
// Say ( JMM , DEnd-JMM-JMM-1 ) ;
15800: LD_EXP 14
15804: PPUSH
15805: LD_STRING DEnd-JMM-JMM-1
15807: PPUSH
15808: CALL_OW 88
// if Joan then
15812: LD_EXP 29
15816: IFFALSE 15832
// Say ( Joan , DEnd-JMM-Joan-1 ) else
15818: LD_EXP 29
15822: PPUSH
15823: LD_STRING DEnd-JMM-Joan-1
15825: PPUSH
15826: CALL_OW 88
15830: GO 15876
// if Lisa and GetSide ( Lisa ) = 7 and IsPlaced ( Lisa ) then
15832: LD_EXP 16
15836: PUSH
15837: LD_EXP 16
15841: PPUSH
15842: CALL_OW 255
15846: PUSH
15847: LD_INT 7
15849: EQUAL
15850: AND
15851: PUSH
15852: LD_EXP 16
15856: PPUSH
15857: CALL_OW 305
15861: AND
15862: IFFALSE 15876
// Say ( Lisa , DEnd-JMM-Lisa-1 ) ;
15864: LD_EXP 16
15868: PPUSH
15869: LD_STRING DEnd-JMM-Lisa-1
15871: PPUSH
15872: CALL_OW 88
// if Frank and IsPlaced ( Frank ) then
15876: LD_EXP 26
15880: PUSH
15881: LD_EXP 26
15885: PPUSH
15886: CALL_OW 305
15890: AND
15891: IFFALSE 15905
// Say ( Frank , DEnd-JMM-Frank-1 ) ;
15893: LD_EXP 26
15897: PPUSH
15898: LD_STRING DEnd-JMM-Frank-1
15900: PPUSH
15901: CALL_OW 88
// if Cyrus and GetSide ( Cyrus ) = 7 and IsPlaced ( Cyrus ) then
15905: LD_EXP 19
15909: PUSH
15910: LD_EXP 19
15914: PPUSH
15915: CALL_OW 255
15919: PUSH
15920: LD_INT 7
15922: EQUAL
15923: AND
15924: PUSH
15925: LD_EXP 19
15929: PPUSH
15930: CALL_OW 305
15934: AND
15935: IFFALSE 15949
// Say ( Cyrus , DEnd-JMM-Cyrus-1 ) ;
15937: LD_EXP 19
15941: PPUSH
15942: LD_STRING DEnd-JMM-Cyrus-1
15944: PPUSH
15945: CALL_OW 88
// if Burlak then
15949: LD_EXP 46
15953: IFFALSE 15967
// Say ( Burlak , DEnd-JMM-Bur-1 ) ;
15955: LD_EXP 46
15959: PPUSH
15960: LD_STRING DEnd-JMM-Bur-1
15962: PPUSH
15963: CALL_OW 88
// if Joan and Lisa and GetSide ( Lisa ) = 7 and IsPlaced ( Lisa ) then
15967: LD_EXP 29
15971: PUSH
15972: LD_EXP 16
15976: AND
15977: PUSH
15978: LD_EXP 16
15982: PPUSH
15983: CALL_OW 255
15987: PUSH
15988: LD_INT 7
15990: EQUAL
15991: AND
15992: PUSH
15993: LD_EXP 16
15997: PPUSH
15998: CALL_OW 305
16002: AND
16003: IFFALSE 16017
// Say ( Lisa , DEnd-Burlak-Lisa-1 ) ;
16005: LD_EXP 16
16009: PPUSH
16010: LD_STRING DEnd-Burlak-Lisa-1
16012: PPUSH
16013: CALL_OW 88
// if Belkov and IsPlaced ( Belkov ) then
16017: LD_EXP 47
16021: PUSH
16022: LD_EXP 47
16026: PPUSH
16027: CALL_OW 305
16031: AND
16032: IFFALSE 16046
// Say ( Belkov , DEnd-JMM-Bel-1 ) ;
16034: LD_EXP 47
16038: PPUSH
16039: LD_STRING DEnd-JMM-Bel-1
16041: PPUSH
16042: CALL_OW 88
// if Gnyevko and IsPlaced ( Gnyevko ) then
16046: LD_EXP 48
16050: PUSH
16051: LD_EXP 48
16055: PPUSH
16056: CALL_OW 305
16060: AND
16061: IFFALSE 16075
// Say ( Gnyevko , DEnd-JMM-Gny-1 ) ;
16063: LD_EXP 48
16067: PPUSH
16068: LD_STRING DEnd-JMM-Gny-1
16070: PPUSH
16071: CALL_OW 88
// if Cornel and GetSide ( Cornel ) = 7 and IsPlaced ( Cornel ) then
16075: LD_EXP 24
16079: PUSH
16080: LD_EXP 24
16084: PPUSH
16085: CALL_OW 255
16089: PUSH
16090: LD_INT 7
16092: EQUAL
16093: AND
16094: PUSH
16095: LD_EXP 24
16099: PPUSH
16100: CALL_OW 305
16104: AND
16105: IFFALSE 16119
// Say ( Cornel , DEnd-JMM-Corn-1 ) ;
16107: LD_EXP 24
16111: PPUSH
16112: LD_STRING DEnd-JMM-Corn-1
16114: PPUSH
16115: CALL_OW 88
// if Donaldson and GetSide ( Donaldson ) = 7 and IsPlaced ( Donaldson ) then
16119: LD_EXP 17
16123: PUSH
16124: LD_EXP 17
16128: PPUSH
16129: CALL_OW 255
16133: PUSH
16134: LD_INT 7
16136: EQUAL
16137: AND
16138: PUSH
16139: LD_EXP 17
16143: PPUSH
16144: CALL_OW 305
16148: AND
16149: IFFALSE 16163
// Say ( Donaldson , DEnd-JMM-Don-1 ) ;
16151: LD_EXP 17
16155: PPUSH
16156: LD_STRING DEnd-JMM-Don-1
16158: PPUSH
16159: CALL_OW 88
// if Bobby and GetSide ( Bobby ) = 7 and IsPlaced ( Bobby ) then
16163: LD_EXP 18
16167: PUSH
16168: LD_EXP 18
16172: PPUSH
16173: CALL_OW 255
16177: PUSH
16178: LD_INT 7
16180: EQUAL
16181: AND
16182: PUSH
16183: LD_EXP 18
16187: PPUSH
16188: CALL_OW 305
16192: AND
16193: IFFALSE 16207
// Say ( Bobby , DEnd-JMM-Bobby-1 ) ;
16195: LD_EXP 18
16199: PPUSH
16200: LD_STRING DEnd-JMM-Bobby-1
16202: PPUSH
16203: CALL_OW 88
// if Denis and GetSide ( Denis ) = 7 and IsPlaced ( Denis ) then
16207: LD_EXP 20
16211: PUSH
16212: LD_EXP 20
16216: PPUSH
16217: CALL_OW 255
16221: PUSH
16222: LD_INT 7
16224: EQUAL
16225: AND
16226: PUSH
16227: LD_EXP 20
16231: PPUSH
16232: CALL_OW 305
16236: AND
16237: IFFALSE 16251
// Say ( Denis , DEnd-JMM-Den-1 ) ;
16239: LD_EXP 20
16243: PPUSH
16244: LD_STRING DEnd-JMM-Den-1
16246: PPUSH
16247: CALL_OW 88
// if Gladstone and GetSide ( Gladstone ) = 7 and IsPlaced ( Gladstone ) then
16251: LD_EXP 22
16255: PUSH
16256: LD_EXP 22
16260: PPUSH
16261: CALL_OW 255
16265: PUSH
16266: LD_INT 7
16268: EQUAL
16269: AND
16270: PUSH
16271: LD_EXP 22
16275: PPUSH
16276: CALL_OW 305
16280: AND
16281: IFFALSE 16295
// Say ( Gladstone , DEnd-JMM-Glad-1 ) ;
16283: LD_EXP 22
16287: PPUSH
16288: LD_STRING DEnd-JMM-Glad-1
16290: PPUSH
16291: CALL_OW 88
// if Kikuchi and GetSide ( Kikuchi ) = 7 and IsPlaced ( Kikuchi ) then
16295: LD_EXP 27
16299: PUSH
16300: LD_EXP 27
16304: PPUSH
16305: CALL_OW 255
16309: PUSH
16310: LD_INT 7
16312: EQUAL
16313: AND
16314: PUSH
16315: LD_EXP 27
16319: PPUSH
16320: CALL_OW 305
16324: AND
16325: IFFALSE 16339
// Say ( Kikuchi , DEnd-JMM-Yam-1 ) ;
16327: LD_EXP 27
16331: PPUSH
16332: LD_STRING DEnd-JMM-Yam-1
16334: PPUSH
16335: CALL_OW 88
// if Brown and GetSide ( Brown ) = 7 and IsPlaced ( Brown ) then
16339: LD_EXP 21
16343: PUSH
16344: LD_EXP 21
16348: PPUSH
16349: CALL_OW 255
16353: PUSH
16354: LD_INT 7
16356: EQUAL
16357: AND
16358: PUSH
16359: LD_EXP 21
16363: PPUSH
16364: CALL_OW 305
16368: AND
16369: IFFALSE 16383
// Say ( Brown , DEnd-JMM-Brown-1 ) ;
16371: LD_EXP 21
16375: PPUSH
16376: LD_STRING DEnd-JMM-Brown-1
16378: PPUSH
16379: CALL_OW 88
// if Connie and GetSide ( Connie ) = 7 and IsPlaced ( Connie ) then
16383: LD_EXP 31
16387: PUSH
16388: LD_EXP 31
16392: PPUSH
16393: CALL_OW 255
16397: PUSH
16398: LD_INT 7
16400: EQUAL
16401: AND
16402: PUSH
16403: LD_EXP 31
16407: PPUSH
16408: CALL_OW 305
16412: AND
16413: IFFALSE 16427
// Say ( Connie , DEnd-JMM-Con-1 ) ;
16415: LD_EXP 31
16419: PPUSH
16420: LD_STRING DEnd-JMM-Con-1
16422: PPUSH
16423: CALL_OW 88
// if Gary and GetSide ( Gary ) = 7 and IsPlaced ( Gary ) then
16427: LD_EXP 25
16431: PUSH
16432: LD_EXP 25
16436: PPUSH
16437: CALL_OW 255
16441: PUSH
16442: LD_INT 7
16444: EQUAL
16445: AND
16446: PUSH
16447: LD_EXP 25
16451: PPUSH
16452: CALL_OW 305
16456: AND
16457: IFFALSE 16471
// Say ( Gary , DEnd-JMM-Gary-1 ) ;
16459: LD_EXP 25
16463: PPUSH
16464: LD_STRING DEnd-JMM-Gary-1
16466: PPUSH
16467: CALL_OW 88
// if Simms and Roth and IsPlaced ( Simms ) then
16471: LD_EXP 28
16475: PUSH
16476: LD_EXP 15
16480: AND
16481: PUSH
16482: LD_EXP 28
16486: PPUSH
16487: CALL_OW 305
16491: AND
16492: IFFALSE 16506
// Say ( Simms , DEnd-JMM-Sim-1 ) ;
16494: LD_EXP 28
16498: PPUSH
16499: LD_STRING DEnd-JMM-Sim-1
16501: PPUSH
16502: CALL_OW 88
// if Houten and GetSide ( Houten ) = 7 and IsPlaced ( Houten ) then
16506: LD_EXP 23
16510: PUSH
16511: LD_EXP 23
16515: PPUSH
16516: CALL_OW 255
16520: PUSH
16521: LD_INT 7
16523: EQUAL
16524: AND
16525: PUSH
16526: LD_EXP 23
16530: PPUSH
16531: CALL_OW 305
16535: AND
16536: IFFALSE 16550
// Say ( Houten , DEnd-JMM-VanH-1 ) ;
16538: LD_EXP 23
16542: PPUSH
16543: LD_STRING DEnd-JMM-VanH-1
16545: PPUSH
16546: CALL_OW 88
// if Dolgov and IsPlaced ( Dolgov ) then
16550: LD_EXP 36
16554: PUSH
16555: LD_EXP 36
16559: PPUSH
16560: CALL_OW 305
16564: AND
16565: IFFALSE 16579
// Say ( Dolgov , DEnd-JMM-Dol-1 ) ;
16567: LD_EXP 36
16571: PPUSH
16572: LD_STRING DEnd-JMM-Dol-1
16574: PPUSH
16575: CALL_OW 88
// if Kapitsova and IsPlaced ( Kapitsova ) then
16579: LD_EXP 40
16583: PUSH
16584: LD_EXP 40
16588: PPUSH
16589: CALL_OW 305
16593: AND
16594: IFFALSE 16608
// Say ( Kapitsova , DEnd-JMM-Kap-1 ) ;
16596: LD_EXP 40
16600: PPUSH
16601: LD_STRING DEnd-JMM-Kap-1
16603: PPUSH
16604: CALL_OW 88
// if Kovalyuk and IsPlaced ( Kovalyuk ) then
16608: LD_EXP 43
16612: PUSH
16613: LD_EXP 43
16617: PPUSH
16618: CALL_OW 305
16622: AND
16623: IFFALSE 16637
// Say ( Kovalyuk , DEnd-JMM-Kov-1 ) ;
16625: LD_EXP 43
16629: PPUSH
16630: LD_STRING DEnd-JMM-Kov-1
16632: PPUSH
16633: CALL_OW 88
// if Scholtze and IsPlaced ( Scholtze ) then
16637: LD_EXP 38
16641: PUSH
16642: LD_EXP 38
16646: PPUSH
16647: CALL_OW 305
16651: AND
16652: IFFALSE 16666
// Say ( Scholtze , DEnd-JMM-Sch-1 ) ;
16654: LD_EXP 38
16658: PPUSH
16659: LD_STRING DEnd-JMM-Sch-1
16661: PPUSH
16662: CALL_OW 88
// if Titov and IsPlaced ( Titov ) then
16666: LD_EXP 34
16670: PUSH
16671: LD_EXP 34
16675: PPUSH
16676: CALL_OW 305
16680: AND
16681: IFFALSE 16695
// Say ( Titov , DEnd-JMM-Tit-1 ) ;
16683: LD_EXP 34
16687: PPUSH
16688: LD_STRING DEnd-JMM-Tit-1
16690: PPUSH
16691: CALL_OW 88
// if Oblukov and IsPlaced ( Oblukov ) then
16695: LD_EXP 39
16699: PUSH
16700: LD_EXP 39
16704: PPUSH
16705: CALL_OW 305
16709: AND
16710: IFFALSE 16724
// Say ( Oblukov , DEnd-JMM-Obl-1 ) ;
16712: LD_EXP 39
16716: PPUSH
16717: LD_STRING DEnd-JMM-Obl-1
16719: PPUSH
16720: CALL_OW 88
// if Lipshchin and IsPlaced ( Lipshchin ) then
16724: LD_EXP 41
16728: PUSH
16729: LD_EXP 41
16733: PPUSH
16734: CALL_OW 305
16738: AND
16739: IFFALSE 16753
// Say ( Lipshchin , DEnd-JMM-Lip-1 ) ;
16741: LD_EXP 41
16745: PPUSH
16746: LD_STRING DEnd-JMM-Lip-1
16748: PPUSH
16749: CALL_OW 88
// if Fadeev and IsPlaced ( Fadeev ) and Burlak then
16753: LD_EXP 35
16757: PUSH
16758: LD_EXP 35
16762: PPUSH
16763: CALL_OW 305
16767: AND
16768: PUSH
16769: LD_EXP 46
16773: AND
16774: IFFALSE 16788
// Say ( Fadeev , DEnd-Burlak-Fad-1 ) ;
16776: LD_EXP 35
16780: PPUSH
16781: LD_STRING DEnd-Burlak-Fad-1
16783: PPUSH
16784: CALL_OW 88
// if Petrovova and IsPlaced ( Petrovova ) then
16788: LD_EXP 42
16792: PUSH
16793: LD_EXP 42
16797: PPUSH
16798: CALL_OW 305
16802: AND
16803: IFFALSE 16817
// Say ( Petrovova , DEnd-Burlak-Ptr-1 ) ;
16805: LD_EXP 42
16809: PPUSH
16810: LD_STRING DEnd-Burlak-Ptr-1
16812: PPUSH
16813: CALL_OW 88
// if Kuzmov and IsPlaced ( Kuzmov ) then
16817: LD_EXP 44
16821: PUSH
16822: LD_EXP 44
16826: PPUSH
16827: CALL_OW 305
16831: AND
16832: IFFALSE 16846
// Say ( Kuzmov , DEnd-Burlak-Kuz-1 ) ;
16834: LD_EXP 44
16838: PPUSH
16839: LD_STRING DEnd-Burlak-Kuz-1
16841: PPUSH
16842: CALL_OW 88
// if Kirilenkova and IsPlaced ( Kirilenkova ) and Burlak then
16846: LD_EXP 33
16850: PUSH
16851: LD_EXP 33
16855: PPUSH
16856: CALL_OW 305
16860: AND
16861: PUSH
16862: LD_EXP 46
16866: AND
16867: IFFALSE 16881
// Say ( Kirilenkova , DEnd-Burlak-Kir-1 ) ;
16869: LD_EXP 33
16873: PPUSH
16874: LD_STRING DEnd-Burlak-Kir-1
16876: PPUSH
16877: CALL_OW 88
// if Burlak then
16881: LD_EXP 46
16885: IFFALSE 16899
// Say ( JMM , DEnd-Burlak-JMM-1 ) ;
16887: LD_EXP 14
16891: PPUSH
16892: LD_STRING DEnd-Burlak-JMM-1
16894: PPUSH
16895: CALL_OW 88
// dwait ( 0 0$2 ) ;
16899: LD_INT 70
16901: PPUSH
16902: CALL_OW 68
// SayRadio ( Schulz , DEnd-Szulc ) ;
16906: LD_EXP 51
16910: PPUSH
16911: LD_STRING DEnd-Szulc
16913: PPUSH
16914: CALL_OW 94
// dwait ( 0 0$1 ) ;
16918: LD_INT 35
16920: PPUSH
16921: CALL_OW 68
// if IsLive ( Burlak ) then
16925: LD_EXP 46
16929: PPUSH
16930: CALL_OW 300
16934: IFFALSE 16946
// med1 := 1 else
16936: LD_ADDR_VAR 0 1
16940: PUSH
16941: LD_INT 1
16943: ST_TO_ADDR
16944: GO 16955
// med1 := - 1 ;
16946: LD_ADDR_VAR 0 1
16950: PUSH
16951: LD_INT 1
16953: NEG
16954: ST_TO_ADDR
// if artifactIResearched and artifactIIResearched and artifactIIIResearched then
16955: LD_EXP 9
16959: PUSH
16960: LD_EXP 10
16964: AND
16965: PUSH
16966: LD_EXP 11
16970: AND
16971: IFFALSE 16983
// med2 := 1 else
16973: LD_ADDR_VAR 0 2
16977: PUSH
16978: LD_INT 1
16980: ST_TO_ADDR
16981: GO 16992
// med2 := - 1 ;
16983: LD_ADDR_VAR 0 2
16987: PUSH
16988: LD_INT 1
16990: NEG
16991: ST_TO_ADDR
// AddMedal ( Hero , 1 ) ;
16992: LD_STRING Hero
16994: PPUSH
16995: LD_INT 1
16997: PPUSH
16998: CALL_OW 101
// AddMedal ( Artefact , med2 ) ;
17002: LD_STRING Artefact
17004: PPUSH
17005: LD_VAR 0 2
17009: PPUSH
17010: CALL_OW 101
// AddMedal ( ReconcileBurlak , med1 ) ;
17014: LD_STRING ReconcileBurlak
17016: PPUSH
17017: LD_VAR 0 1
17021: PPUSH
17022: CALL_OW 101
// if Difficulty = 3 and med1 = 1 and med2 = 1 then
17026: LD_OWVAR 67
17030: PUSH
17031: LD_INT 3
17033: EQUAL
17034: PUSH
17035: LD_VAR 0 1
17039: PUSH
17040: LD_INT 1
17042: EQUAL
17043: AND
17044: PUSH
17045: LD_VAR 0 2
17049: PUSH
17050: LD_INT 1
17052: EQUAL
17053: AND
17054: IFFALSE 17066
// SetAchievementEX ( ACH_AMER , 19 ) ;
17056: LD_STRING ACH_AMER
17058: PPUSH
17059: LD_INT 19
17061: PPUSH
17062: CALL_OW 564
// GiveMedals ( MAIN ) ;
17066: LD_STRING MAIN
17068: PPUSH
17069: CALL_OW 102
// InGameOff ;
17073: CALL_OW 9
// DialogueOff ;
17077: CALL_OW 7
// music_nat := 1 ;
17081: LD_ADDR_OWVAR 71
17085: PUSH
17086: LD_INT 1
17088: ST_TO_ADDR
// music_class := 4 ;
17089: LD_ADDR_OWVAR 72
17093: PUSH
17094: LD_INT 4
17096: ST_TO_ADDR
// YouWin ;
17097: CALL_OW 103
// end ; end_of_file
17101: PPOPN 2
17103: END
// export function InitNature ; begin
17104: LD_INT 0
17106: PPUSH
// PrepareNature ( 3 , 3 , 2 , 1 , 1 , 0 , 0 , natureArea1 , 0 ) ;
17107: LD_INT 3
17109: PPUSH
17110: LD_INT 3
17112: PPUSH
17113: LD_INT 2
17115: PPUSH
17116: LD_INT 1
17118: PPUSH
17119: LD_INT 1
17121: PPUSH
17122: LD_INT 0
17124: PPUSH
17125: LD_INT 0
17127: PPUSH
17128: LD_INT 17
17130: PPUSH
17131: LD_INT 0
17133: PPUSH
17134: CALL 85412 0 9
// PrepareNature ( 2 , 1 , 1 , 1 , 1 , 0 , 0 , natureArea2 , 0 ) ;
17138: LD_INT 2
17140: PPUSH
17141: LD_INT 1
17143: PPUSH
17144: LD_INT 1
17146: PPUSH
17147: LD_INT 1
17149: PPUSH
17150: LD_INT 1
17152: PPUSH
17153: LD_INT 0
17155: PPUSH
17156: LD_INT 0
17158: PPUSH
17159: LD_INT 18
17161: PPUSH
17162: LD_INT 0
17164: PPUSH
17165: CALL 85412 0 9
// PrepareNature ( 4 , 1 , 2 , 4 , 2 , 1 , 0 , natureArea3 , 0 ) ;
17169: LD_INT 4
17171: PPUSH
17172: LD_INT 1
17174: PPUSH
17175: LD_INT 2
17177: PPUSH
17178: LD_INT 4
17180: PPUSH
17181: LD_INT 2
17183: PPUSH
17184: LD_INT 1
17186: PPUSH
17187: LD_INT 0
17189: PPUSH
17190: LD_INT 19
17192: PPUSH
17193: LD_INT 0
17195: PPUSH
17196: CALL 85412 0 9
// PrepareNature ( 0 , 0 , 0 , 0 , 0 , 0 , 9 , 0 , natureWaterArea ) ;
17200: LD_INT 0
17202: PPUSH
17203: LD_INT 0
17205: PPUSH
17206: LD_INT 0
17208: PPUSH
17209: LD_INT 0
17211: PPUSH
17212: LD_INT 0
17214: PPUSH
17215: LD_INT 0
17217: PPUSH
17218: LD_INT 9
17220: PPUSH
17221: LD_INT 0
17223: PPUSH
17224: LD_INT 20
17226: PPUSH
17227: CALL 85412 0 9
// end ; end_of_file
17231: LD_VAR 0 1
17235: RET
// every 0 0$30 do var time ;
17236: GO 17238
17238: DISABLE
17239: LD_INT 0
17241: PPUSH
// begin time := 0 0$50 ;
17242: LD_ADDR_VAR 0 1
17246: PUSH
17247: LD_INT 1750
17249: ST_TO_ADDR
// repeat wait ( time ) ;
17250: LD_VAR 0 1
17254: PPUSH
17255: CALL_OW 67
// if Prob ( 50 ) then
17259: LD_INT 50
17261: PPUSH
17262: CALL_OW 13
17266: IFFALSE 17295
// CreateCratesXYR ( rand ( 1 , 5 ) , 106 , 89 , 45 , true ) ;
17268: LD_INT 1
17270: PPUSH
17271: LD_INT 5
17273: PPUSH
17274: CALL_OW 12
17278: PPUSH
17279: LD_INT 106
17281: PPUSH
17282: LD_INT 89
17284: PPUSH
17285: LD_INT 45
17287: PPUSH
17288: LD_INT 1
17290: PPUSH
17291: CALL_OW 56
// time := time + 0 0$3 ;
17295: LD_ADDR_VAR 0 1
17299: PUSH
17300: LD_VAR 0 1
17304: PUSH
17305: LD_INT 105
17307: PLUS
17308: ST_TO_ADDR
// if Prob ( 30 ) then
17309: LD_INT 30
17311: PPUSH
17312: CALL_OW 13
17316: IFFALSE 17362
// begin wait ( rand ( 0 0$15 , 0 0$21 ) ) ;
17318: LD_INT 525
17320: PPUSH
17321: LD_INT 735
17323: PPUSH
17324: CALL_OW 12
17328: PPUSH
17329: CALL_OW 67
// CreateCratesXYR ( rand ( 1 , 5 ) , 21 , 26 , 12 , true ) ;
17333: LD_INT 1
17335: PPUSH
17336: LD_INT 5
17338: PPUSH
17339: CALL_OW 12
17343: PPUSH
17344: LD_INT 21
17346: PPUSH
17347: LD_INT 26
17349: PPUSH
17350: LD_INT 12
17352: PPUSH
17353: LD_INT 1
17355: PPUSH
17356: CALL_OW 56
// end else
17360: GO 17398
// begin wait ( rand ( 0 0$20 , 0 0$35 ) ) ;
17362: LD_INT 700
17364: PPUSH
17365: LD_INT 1225
17367: PPUSH
17368: CALL_OW 12
17372: PPUSH
17373: CALL_OW 67
// CreateCratesArea ( rand ( 1 , 5 ) , russianCratesArea , true ) ;
17377: LD_INT 1
17379: PPUSH
17380: LD_INT 5
17382: PPUSH
17383: CALL_OW 12
17387: PPUSH
17388: LD_INT 14
17390: PPUSH
17391: LD_INT 1
17393: PPUSH
17394: CALL_OW 55
// end ; if Prob ( 50 ) then
17398: LD_INT 50
17400: PPUSH
17401: CALL_OW 13
17405: IFFALSE 17451
// begin wait ( rand ( 0 0$20 , 0 0$30 ) ) ;
17407: LD_INT 700
17409: PPUSH
17410: LD_INT 1050
17412: PPUSH
17413: CALL_OW 12
17417: PPUSH
17418: CALL_OW 67
// CreateCratesXYR ( rand ( 1 , 5 ) , 181 , 218 , 16 , true ) ;
17422: LD_INT 1
17424: PPUSH
17425: LD_INT 5
17427: PPUSH
17428: CALL_OW 12
17432: PPUSH
17433: LD_INT 181
17435: PPUSH
17436: LD_INT 218
17438: PPUSH
17439: LD_INT 16
17441: PPUSH
17442: LD_INT 1
17444: PPUSH
17445: CALL_OW 56
// end else
17449: GO 17523
// begin wait ( rand ( 0 0$10 , 0 0$15 ) ) ;
17451: LD_INT 350
17453: PPUSH
17454: LD_INT 525
17456: PPUSH
17457: CALL_OW 12
17461: PPUSH
17462: CALL_OW 67
// CreateCratesArea ( rand ( 1 , 5 ) , legionCratesArea , true ) ;
17466: LD_INT 1
17468: PPUSH
17469: LD_INT 5
17471: PPUSH
17472: CALL_OW 12
17476: PPUSH
17477: LD_INT 13
17479: PPUSH
17480: LD_INT 1
17482: PPUSH
17483: CALL_OW 55
// wait ( rand ( 0 0$10 , 0 0$20 ) ) ;
17487: LD_INT 350
17489: PPUSH
17490: LD_INT 700
17492: PPUSH
17493: CALL_OW 12
17497: PPUSH
17498: CALL_OW 67
// CreateCratesArea ( rand ( 1 , 5 ) , americanCratesArea , true ) ;
17502: LD_INT 1
17504: PPUSH
17505: LD_INT 5
17507: PPUSH
17508: CALL_OW 12
17512: PPUSH
17513: LD_INT 33
17515: PPUSH
17516: LD_INT 1
17518: PPUSH
17519: CALL_OW 55
// end ; if Prob ( [ 65 , 62 , 55 ] [ Difficulty ] ) then
17523: LD_INT 65
17525: PUSH
17526: LD_INT 62
17528: PUSH
17529: LD_INT 55
17531: PUSH
17532: EMPTY
17533: LIST
17534: LIST
17535: LIST
17536: PUSH
17537: LD_OWVAR 67
17541: ARRAY
17542: PPUSH
17543: CALL_OW 13
17547: IFFALSE 17593
// begin wait ( rand ( 0 0$15 , 0 0$25 ) ) ;
17549: LD_INT 525
17551: PPUSH
17552: LD_INT 875
17554: PPUSH
17555: CALL_OW 12
17559: PPUSH
17560: CALL_OW 67
// CreateCratesXYR ( rand ( 1 , 5 ) , 294 , 211 , 30 , true ) ;
17564: LD_INT 1
17566: PPUSH
17567: LD_INT 5
17569: PPUSH
17570: CALL_OW 12
17574: PPUSH
17575: LD_INT 294
17577: PPUSH
17578: LD_INT 211
17580: PPUSH
17581: LD_INT 30
17583: PPUSH
17584: LD_INT 1
17586: PPUSH
17587: CALL_OW 56
// end else
17591: GO 17635
// begin wait ( rand ( 0 0$12 , 0 0$22 ) ) ;
17593: LD_INT 420
17595: PPUSH
17596: LD_INT 770
17598: PPUSH
17599: CALL_OW 12
17603: PPUSH
17604: CALL_OW 67
// CreateCratesXYR ( rand ( 1 , 5 ) , 294 , 211 , 30 , true ) ;
17608: LD_INT 1
17610: PPUSH
17611: LD_INT 5
17613: PPUSH
17614: CALL_OW 12
17618: PPUSH
17619: LD_INT 294
17621: PPUSH
17622: LD_INT 211
17624: PPUSH
17625: LD_INT 30
17627: PPUSH
17628: LD_INT 1
17630: PPUSH
17631: CALL_OW 56
// end ; if time > 2 2$20 then
17635: LD_VAR 0 1
17639: PUSH
17640: LD_INT 4900
17642: GREATER
17643: IFFALSE 17653
// time := 0 0$50 ;
17645: LD_ADDR_VAR 0 1
17649: PUSH
17650: LD_INT 1750
17652: ST_TO_ADDR
// until false ;
17653: LD_INT 0
17655: IFFALSE 17250
// end ;
17657: PPOPN 1
17659: END
// every 0 0$45 trigger tick < 10 10$00 do
17660: LD_OWVAR 1
17664: PUSH
17665: LD_INT 21000
17667: LESS
17668: IFFALSE 17716
17670: GO 17672
17672: DISABLE
// begin enable ;
17673: ENABLE
// wait ( rand ( 0 0$10 , 0 0$20 ) ) ;
17674: LD_INT 350
17676: PPUSH
17677: LD_INT 700
17679: PPUSH
17680: CALL_OW 12
17684: PPUSH
17685: CALL_OW 67
// CreateCratesXYR ( rand ( 3 , 5 ) , 181 , 13 , 20 , true ) ;
17689: LD_INT 3
17691: PPUSH
17692: LD_INT 5
17694: PPUSH
17695: CALL_OW 12
17699: PPUSH
17700: LD_INT 181
17702: PPUSH
17703: LD_INT 13
17705: PPUSH
17706: LD_INT 20
17708: PPUSH
17709: LD_INT 1
17711: PPUSH
17712: CALL_OW 56
// end ; end_of_file
17716: END
// export artifactsPos , artifactsRecharge , artifactsSibCost , artifactsResearched , artifactsLabsWorking ; export artifactsResDifficulty , artifactsResProgress , artifactsLabs , artifactsButtons , artifactsReady ; export function InitArtifact ; begin
17717: LD_INT 0
17719: PPUSH
// SetArtifactRes ( 7 , true ) ;
17720: LD_INT 7
17722: PPUSH
17723: LD_INT 1
17725: PPUSH
17726: CALL_OW 467
// artifactsPos := [ [ ] , [ ] , [ ] ] ;
17730: LD_ADDR_EXP 59
17734: PUSH
17735: EMPTY
17736: PUSH
17737: EMPTY
17738: PUSH
17739: EMPTY
17740: PUSH
17741: EMPTY
17742: LIST
17743: LIST
17744: LIST
17745: ST_TO_ADDR
// artifactsRecharge := [ 0 0$30 * Difficulty , 1 1$20 * Difficulty , - 1 ] ;
17746: LD_ADDR_EXP 60
17750: PUSH
17751: LD_INT 1050
17753: PUSH
17754: LD_OWVAR 67
17758: MUL
17759: PUSH
17760: LD_INT 2800
17762: PUSH
17763: LD_OWVAR 67
17767: MUL
17768: PUSH
17769: LD_INT 1
17771: NEG
17772: PUSH
17773: EMPTY
17774: LIST
17775: LIST
17776: LIST
17777: ST_TO_ADDR
// artifactsSibCost := [ 10 , 35 , 100 ] ;
17778: LD_ADDR_EXP 61
17782: PUSH
17783: LD_INT 10
17785: PUSH
17786: LD_INT 35
17788: PUSH
17789: LD_INT 100
17791: PUSH
17792: EMPTY
17793: LIST
17794: LIST
17795: LIST
17796: ST_TO_ADDR
// artifactsResearched := [ 0 , 0 , 0 ] ;
17797: LD_ADDR_EXP 62
17801: PUSH
17802: LD_INT 0
17804: PUSH
17805: LD_INT 0
17807: PUSH
17808: LD_INT 0
17810: PUSH
17811: EMPTY
17812: LIST
17813: LIST
17814: LIST
17815: ST_TO_ADDR
// artifactsResDifficulty := [ 300 , 500 , 800 ] ;
17816: LD_ADDR_EXP 64
17820: PUSH
17821: LD_INT 300
17823: PUSH
17824: LD_INT 500
17826: PUSH
17827: LD_INT 800
17829: PUSH
17830: EMPTY
17831: LIST
17832: LIST
17833: LIST
17834: ST_TO_ADDR
// artifactsResProgress := [ 0 , 0 , 0 ] ;
17835: LD_ADDR_EXP 65
17839: PUSH
17840: LD_INT 0
17842: PUSH
17843: LD_INT 0
17845: PUSH
17846: LD_INT 0
17848: PUSH
17849: EMPTY
17850: LIST
17851: LIST
17852: LIST
17853: ST_TO_ADDR
// artifactsLabs := [ 0 , 0 , 0 ] ;
17854: LD_ADDR_EXP 66
17858: PUSH
17859: LD_INT 0
17861: PUSH
17862: LD_INT 0
17864: PUSH
17865: LD_INT 0
17867: PUSH
17868: EMPTY
17869: LIST
17870: LIST
17871: LIST
17872: ST_TO_ADDR
// artifactsLabsWorking := [ 0 , 0 , 0 ] ;
17873: LD_ADDR_EXP 63
17877: PUSH
17878: LD_INT 0
17880: PUSH
17881: LD_INT 0
17883: PUSH
17884: LD_INT 0
17886: PUSH
17887: EMPTY
17888: LIST
17889: LIST
17890: LIST
17891: ST_TO_ADDR
// artifactsButtons := [ [ art_use_eye , art_place , art_exp_left ] , [ art_use_sibexplosion , art_unit , art_exp_mid ] , [ art_use_teleport , art_place , art_exp_right ] ] ;
17892: LD_ADDR_EXP 67
17896: PUSH
17897: LD_INT 4
17899: PUSH
17900: LD_INT 3
17902: PUSH
17903: LD_INT 1
17905: PUSH
17906: EMPTY
17907: LIST
17908: LIST
17909: LIST
17910: PUSH
17911: LD_INT 5
17913: PUSH
17914: LD_INT 4
17916: PUSH
17917: LD_INT 2
17919: PUSH
17920: EMPTY
17921: LIST
17922: LIST
17923: LIST
17924: PUSH
17925: LD_INT 6
17927: PUSH
17928: LD_INT 3
17930: PUSH
17931: LD_INT 3
17933: PUSH
17934: EMPTY
17935: LIST
17936: LIST
17937: LIST
17938: PUSH
17939: EMPTY
17940: LIST
17941: LIST
17942: LIST
17943: ST_TO_ADDR
// artifactsReady := [ 0 , 0 , 0 ] ;
17944: LD_ADDR_EXP 68
17948: PUSH
17949: LD_INT 0
17951: PUSH
17952: LD_INT 0
17954: PUSH
17955: LD_INT 0
17957: PUSH
17958: EMPTY
17959: LIST
17960: LIST
17961: LIST
17962: ST_TO_ADDR
// end ;
17963: LD_VAR 0 1
17967: RET
// every 0 0$1 trigger GetTech ( tech_artifact , 7 ) = state_researched do var i , pos , j , labs , nearestLab ;
17968: LD_INT 24
17970: PPUSH
17971: LD_INT 7
17973: PPUSH
17974: CALL_OW 321
17978: PUSH
17979: LD_INT 2
17981: EQUAL
17982: IFFALSE 18908
17984: GO 17986
17986: DISABLE
17987: LD_INT 0
17989: PPUSH
17990: PPUSH
17991: PPUSH
17992: PPUSH
17993: PPUSH
// begin enable ;
17994: ENABLE
// for i = 1 to 3 do
17995: LD_ADDR_VAR 0 1
17999: PUSH
18000: DOUBLE
18001: LD_INT 1
18003: DEC
18004: ST_TO_ADDR
18005: LD_INT 3
18007: PUSH
18008: FOR_TO
18009: IFFALSE 18906
// begin pos := FindArtifact ( i + 2 ) ;
18011: LD_ADDR_VAR 0 2
18015: PUSH
18016: LD_VAR 0 1
18020: PUSH
18021: LD_INT 2
18023: PLUS
18024: PPUSH
18025: CALL_OW 469
18029: ST_TO_ADDR
// artifactsPos := Replace ( artifactsPos , i , pos ) ;
18030: LD_ADDR_EXP 59
18034: PUSH
18035: LD_EXP 59
18039: PPUSH
18040: LD_VAR 0 1
18044: PPUSH
18045: LD_VAR 0 2
18049: PPUSH
18050: CALL_OW 1
18054: ST_TO_ADDR
// if pos then
18055: LD_VAR 0 2
18059: IFFALSE 18767
// begin case i of 1 :
18061: LD_VAR 0 1
18065: PUSH
18066: LD_INT 1
18068: DOUBLE
18069: EQUAL
18070: IFTRUE 18074
18072: GO 18151
18074: POP
// labs := FilterAllUnits ( [ [ f_side , 7 ] , [ f_nation , 1 ] , [ f_or , [ f_btype , b_lab_full ] , [ f_btype , b_lab_half ] , [ f_btype , b_lab_siberium ] ] ] ) ; 2 :
18075: LD_ADDR_VAR 0 4
18079: PUSH
18080: LD_INT 22
18082: PUSH
18083: LD_INT 7
18085: PUSH
18086: EMPTY
18087: LIST
18088: LIST
18089: PUSH
18090: LD_INT 23
18092: PUSH
18093: LD_INT 1
18095: PUSH
18096: EMPTY
18097: LIST
18098: LIST
18099: PUSH
18100: LD_INT 2
18102: PUSH
18103: LD_INT 30
18105: PUSH
18106: LD_INT 8
18108: PUSH
18109: EMPTY
18110: LIST
18111: LIST
18112: PUSH
18113: LD_INT 30
18115: PUSH
18116: LD_INT 7
18118: PUSH
18119: EMPTY
18120: LIST
18121: LIST
18122: PUSH
18123: LD_INT 30
18125: PUSH
18126: LD_INT 11
18128: PUSH
18129: EMPTY
18130: LIST
18131: LIST
18132: PUSH
18133: EMPTY
18134: LIST
18135: LIST
18136: LIST
18137: LIST
18138: PUSH
18139: EMPTY
18140: LIST
18141: LIST
18142: LIST
18143: PPUSH
18144: CALL_OW 69
18148: ST_TO_ADDR
18149: GO 18259
18151: LD_INT 2
18153: DOUBLE
18154: EQUAL
18155: IFTRUE 18159
18157: GO 18236
18159: POP
// labs := FilterAllUnits ( [ [ f_side , 7 ] , [ f_nation , 3 ] , [ f_or , [ f_btype , b_lab_full ] , [ f_btype , b_lab_half ] , [ f_btype , b_lab_siberium ] ] ] ) ; 3 :
18160: LD_ADDR_VAR 0 4
18164: PUSH
18165: LD_INT 22
18167: PUSH
18168: LD_INT 7
18170: PUSH
18171: EMPTY
18172: LIST
18173: LIST
18174: PUSH
18175: LD_INT 23
18177: PUSH
18178: LD_INT 3
18180: PUSH
18181: EMPTY
18182: LIST
18183: LIST
18184: PUSH
18185: LD_INT 2
18187: PUSH
18188: LD_INT 30
18190: PUSH
18191: LD_INT 8
18193: PUSH
18194: EMPTY
18195: LIST
18196: LIST
18197: PUSH
18198: LD_INT 30
18200: PUSH
18201: LD_INT 7
18203: PUSH
18204: EMPTY
18205: LIST
18206: LIST
18207: PUSH
18208: LD_INT 30
18210: PUSH
18211: LD_INT 11
18213: PUSH
18214: EMPTY
18215: LIST
18216: LIST
18217: PUSH
18218: EMPTY
18219: LIST
18220: LIST
18221: LIST
18222: LIST
18223: PUSH
18224: EMPTY
18225: LIST
18226: LIST
18227: LIST
18228: PPUSH
18229: CALL_OW 69
18233: ST_TO_ADDR
18234: GO 18259
18236: LD_INT 3
18238: DOUBLE
18239: EQUAL
18240: IFTRUE 18244
18242: GO 18258
18244: POP
// labs := [ alien ] ; end ;
18245: LD_ADDR_VAR 0 4
18249: PUSH
18250: LD_INT 1
18252: PUSH
18253: EMPTY
18254: LIST
18255: ST_TO_ADDR
18256: GO 18259
18258: POP
// if not labs then
18259: LD_VAR 0 4
18263: NOT
18264: IFFALSE 18268
// continue ;
18266: GO 18008
// nearestLab := NearestUnitToXY ( labs , artifactsPos [ i ] [ 1 ] , artifactsPos [ i ] [ 2 ] ) ;
18268: LD_ADDR_VAR 0 5
18272: PUSH
18273: LD_VAR 0 4
18277: PPUSH
18278: LD_EXP 59
18282: PUSH
18283: LD_VAR 0 1
18287: ARRAY
18288: PUSH
18289: LD_INT 1
18291: ARRAY
18292: PPUSH
18293: LD_EXP 59
18297: PUSH
18298: LD_VAR 0 1
18302: ARRAY
18303: PUSH
18304: LD_INT 2
18306: ARRAY
18307: PPUSH
18308: CALL_OW 73
18312: ST_TO_ADDR
// if not nearestLab or nearestLab <> artifactsLabs [ i ] then
18313: LD_VAR 0 5
18317: NOT
18318: PUSH
18319: LD_VAR 0 5
18323: PUSH
18324: LD_EXP 66
18328: PUSH
18329: LD_VAR 0 1
18333: ARRAY
18334: NONEQUAL
18335: OR
18336: IFFALSE 18441
// begin SetArtifactUse ( 7 , artifactsButtons [ i ] [ 3 ] , art_no , artifactsLabs [ i ] ) ;
18338: LD_INT 7
18340: PPUSH
18341: LD_EXP 67
18345: PUSH
18346: LD_VAR 0 1
18350: ARRAY
18351: PUSH
18352: LD_INT 3
18354: ARRAY
18355: PPUSH
18356: LD_INT 0
18358: PPUSH
18359: LD_EXP 66
18363: PUSH
18364: LD_VAR 0 1
18368: ARRAY
18369: PPUSH
18370: CALL_OW 468
// SetArtifactUse ( 7 , artifactsButtons [ i ] [ 1 ] , art_no , artifactsLabs [ i ] ) ;
18374: LD_INT 7
18376: PPUSH
18377: LD_EXP 67
18381: PUSH
18382: LD_VAR 0 1
18386: ARRAY
18387: PUSH
18388: LD_INT 1
18390: ARRAY
18391: PPUSH
18392: LD_INT 0
18394: PPUSH
18395: LD_EXP 66
18399: PUSH
18400: LD_VAR 0 1
18404: ARRAY
18405: PPUSH
18406: CALL_OW 468
// if nearestLab then
18410: LD_VAR 0 5
18414: IFFALSE 18441
// artifactsLabs := Replace ( artifactsLabs , i , nearestLab ) ;
18416: LD_ADDR_EXP 66
18420: PUSH
18421: LD_EXP 66
18425: PPUSH
18426: LD_VAR 0 1
18430: PPUSH
18431: LD_VAR 0 5
18435: PPUSH
18436: CALL_OW 1
18440: ST_TO_ADDR
// end ; if not nearestLab then
18441: LD_VAR 0 5
18445: NOT
18446: IFFALSE 18450
// continue ;
18448: GO 18008
// if GetDistUnitXY ( nearestLab , artifactsPos [ i ] [ 1 ] , artifactsPos [ i ] [ 2 ] ) < 8 then
18450: LD_VAR 0 5
18454: PPUSH
18455: LD_EXP 59
18459: PUSH
18460: LD_VAR 0 1
18464: ARRAY
18465: PUSH
18466: LD_INT 1
18468: ARRAY
18469: PPUSH
18470: LD_EXP 59
18474: PUSH
18475: LD_VAR 0 1
18479: ARRAY
18480: PUSH
18481: LD_INT 2
18483: ARRAY
18484: PPUSH
18485: CALL_OW 297
18489: PUSH
18490: LD_INT 8
18492: LESS
18493: IFFALSE 18690
// begin if not artifactsResearched [ i ] then
18495: LD_EXP 62
18499: PUSH
18500: LD_VAR 0 1
18504: ARRAY
18505: NOT
18506: IFFALSE 18587
// begin if BuildingStatus ( nearestLab ) = bs_idle then
18508: LD_VAR 0 5
18512: PPUSH
18513: CALL_OW 461
18517: PUSH
18518: LD_INT 2
18520: EQUAL
18521: IFFALSE 18555
// SetArtifactUse ( 7 , artifactsButtons [ i ] [ 3 ] , art_instant , nearestLab ) else
18523: LD_INT 7
18525: PPUSH
18526: LD_EXP 67
18530: PUSH
18531: LD_VAR 0 1
18535: ARRAY
18536: PUSH
18537: LD_INT 3
18539: ARRAY
18540: PPUSH
18541: LD_INT 2
18543: PPUSH
18544: LD_VAR 0 5
18548: PPUSH
18549: CALL_OW 468
18553: GO 18585
// SetArtifactUse ( 7 , artifactsButtons [ i ] [ 3 ] , art_gray , nearestLab ) ;
18555: LD_INT 7
18557: PPUSH
18558: LD_EXP 67
18562: PUSH
18563: LD_VAR 0 1
18567: ARRAY
18568: PUSH
18569: LD_INT 3
18571: ARRAY
18572: PPUSH
18573: LD_INT 1
18575: PPUSH
18576: LD_VAR 0 5
18580: PPUSH
18581: CALL_OW 468
// end else
18585: GO 18688
// begin if BuildingStatus ( nearestLab ) = bs_idle and artifactsReady [ i ] then
18587: LD_VAR 0 5
18591: PPUSH
18592: CALL_OW 461
18596: PUSH
18597: LD_INT 2
18599: EQUAL
18600: PUSH
18601: LD_EXP 68
18605: PUSH
18606: LD_VAR 0 1
18610: ARRAY
18611: AND
18612: IFFALSE 18658
// SetArtifactUse ( 7 , artifactsButtons [ i ] [ 1 ] , artifactsButtons [ i ] [ 2 ] , nearestLab ) else
18614: LD_INT 7
18616: PPUSH
18617: LD_EXP 67
18621: PUSH
18622: LD_VAR 0 1
18626: ARRAY
18627: PUSH
18628: LD_INT 1
18630: ARRAY
18631: PPUSH
18632: LD_EXP 67
18636: PUSH
18637: LD_VAR 0 1
18641: ARRAY
18642: PUSH
18643: LD_INT 2
18645: ARRAY
18646: PPUSH
18647: LD_VAR 0 5
18651: PPUSH
18652: CALL_OW 468
18656: GO 18688
// SetArtifactUse ( 7 , artifactsButtons [ i ] [ 1 ] , art_gray , nearestLab ) end ;
18658: LD_INT 7
18660: PPUSH
18661: LD_EXP 67
18665: PUSH
18666: LD_VAR 0 1
18670: ARRAY
18671: PUSH
18672: LD_INT 1
18674: ARRAY
18675: PPUSH
18676: LD_INT 1
18678: PPUSH
18679: LD_VAR 0 5
18683: PPUSH
18684: CALL_OW 468
// end else
18688: GO 18765
// begin if not artifactsResearched [ i ] then
18690: LD_EXP 62
18694: PUSH
18695: LD_VAR 0 1
18699: ARRAY
18700: NOT
18701: IFFALSE 18735
// SetArtifactUse ( 7 , artifactsButtons [ i ] [ 3 ] , art_no , nearestLab ) else
18703: LD_INT 7
18705: PPUSH
18706: LD_EXP 67
18710: PUSH
18711: LD_VAR 0 1
18715: ARRAY
18716: PUSH
18717: LD_INT 3
18719: ARRAY
18720: PPUSH
18721: LD_INT 0
18723: PPUSH
18724: LD_VAR 0 5
18728: PPUSH
18729: CALL_OW 468
18733: GO 18765
// SetArtifactUse ( 7 , artifactsButtons [ i ] [ 1 ] , art_no , nearestLab ) ;
18735: LD_INT 7
18737: PPUSH
18738: LD_EXP 67
18742: PUSH
18743: LD_VAR 0 1
18747: ARRAY
18748: PUSH
18749: LD_INT 1
18751: ARRAY
18752: PPUSH
18753: LD_INT 0
18755: PPUSH
18756: LD_VAR 0 5
18760: PPUSH
18761: CALL_OW 468
// end ; end else
18765: GO 18904
// begin if not artifactsLabs [ i ] then
18767: LD_EXP 66
18771: PUSH
18772: LD_VAR 0 1
18776: ARRAY
18777: NOT
18778: IFFALSE 18782
// continue ;
18780: GO 18008
// SetArtifactUse ( 7 , artifactsButtons [ i ] [ 3 ] , art_no , artifactsLabs [ i ] ) ;
18782: LD_INT 7
18784: PPUSH
18785: LD_EXP 67
18789: PUSH
18790: LD_VAR 0 1
18794: ARRAY
18795: PUSH
18796: LD_INT 3
18798: ARRAY
18799: PPUSH
18800: LD_INT 0
18802: PPUSH
18803: LD_EXP 66
18807: PUSH
18808: LD_VAR 0 1
18812: ARRAY
18813: PPUSH
18814: CALL_OW 468
// SetArtifactUse ( 7 , artifactsButtons [ i ] [ 1 ] , art_no , artifactsLabs [ i ] ) ;
18818: LD_INT 7
18820: PPUSH
18821: LD_EXP 67
18825: PUSH
18826: LD_VAR 0 1
18830: ARRAY
18831: PUSH
18832: LD_INT 1
18834: ARRAY
18835: PPUSH
18836: LD_INT 0
18838: PPUSH
18839: LD_EXP 66
18843: PUSH
18844: LD_VAR 0 1
18848: ARRAY
18849: PPUSH
18850: CALL_OW 468
// if artifactsLabsWorking [ i ] then
18854: LD_EXP 63
18858: PUSH
18859: LD_VAR 0 1
18863: ARRAY
18864: IFFALSE 18904
// begin artifactsLabsWorking := Replace ( artifactsLabsWorking , i , false ) ;
18866: LD_ADDR_EXP 63
18870: PUSH
18871: LD_EXP 63
18875: PPUSH
18876: LD_VAR 0 1
18880: PPUSH
18881: LD_INT 0
18883: PPUSH
18884: CALL_OW 1
18888: ST_TO_ADDR
// ComCancel ( artifactsLabs [ i ] ) ;
18889: LD_EXP 66
18893: PUSH
18894: LD_VAR 0 1
18898: ARRAY
18899: PPUSH
18900: CALL_OW 127
// end ; end ; end ;
18904: GO 18008
18906: POP
18907: POP
// end ;
18908: PPOPN 5
18910: END
// on ArtifactUsed ( side , icon , x , y ) do var i , lab , time , list , un ;
18911: LD_INT 0
18913: PPUSH
18914: PPUSH
18915: PPUSH
18916: PPUSH
18917: PPUSH
// begin if icon = artifactsButtons [ 1 ] [ 3 ] then
18918: LD_VAR 0 2
18922: PUSH
18923: LD_EXP 67
18927: PUSH
18928: LD_INT 1
18930: ARRAY
18931: PUSH
18932: LD_INT 3
18934: ARRAY
18935: EQUAL
18936: IFFALSE 19059
// begin lab := artifactsLabs [ 1 ] ;
18938: LD_ADDR_VAR 0 6
18942: PUSH
18943: LD_EXP 66
18947: PUSH
18948: LD_INT 1
18950: ARRAY
18951: ST_TO_ADDR
// if not lab then
18952: LD_VAR 0 6
18956: NOT
18957: IFFALSE 18961
// exit ;
18959: GO 20028
// SetSpecResearch ( lab , artifactsResDifficulty [ 1 ] , true ) ;
18961: LD_VAR 0 6
18965: PPUSH
18966: LD_EXP 64
18970: PUSH
18971: LD_INT 1
18973: ARRAY
18974: PPUSH
18975: LD_INT 1
18977: PPUSH
18978: CALL_OW 486
// if artifactsResProgress [ 1 ] then
18982: LD_EXP 65
18986: PUSH
18987: LD_INT 1
18989: ARRAY
18990: IFFALSE 19010
// SetWorkingProgress ( lab , artifactsResProgress [ 1 ] ) ;
18992: LD_VAR 0 6
18996: PPUSH
18997: LD_EXP 65
19001: PUSH
19002: LD_INT 1
19004: ARRAY
19005: PPUSH
19006: CALL_OW 329
// artifactsLabsWorking := Replace ( artifactsLabsWorking , 1 , 1 ) ;
19010: LD_ADDR_EXP 63
19014: PUSH
19015: LD_EXP 63
19019: PPUSH
19020: LD_INT 1
19022: PPUSH
19023: LD_INT 1
19025: PPUSH
19026: CALL_OW 1
19030: ST_TO_ADDR
// SetArtifactUse ( 7 , artifactsButtons [ 1 ] [ 3 ] , art_no , lab ) ;
19031: LD_INT 7
19033: PPUSH
19034: LD_EXP 67
19038: PUSH
19039: LD_INT 1
19041: ARRAY
19042: PUSH
19043: LD_INT 3
19045: ARRAY
19046: PPUSH
19047: LD_INT 0
19049: PPUSH
19050: LD_VAR 0 6
19054: PPUSH
19055: CALL_OW 468
// end ; if icon = artifactsButtons [ 2 ] [ 3 ] then
19059: LD_VAR 0 2
19063: PUSH
19064: LD_EXP 67
19068: PUSH
19069: LD_INT 2
19071: ARRAY
19072: PUSH
19073: LD_INT 3
19075: ARRAY
19076: EQUAL
19077: IFFALSE 19200
// begin lab := artifactsLabs [ 2 ] ;
19079: LD_ADDR_VAR 0 6
19083: PUSH
19084: LD_EXP 66
19088: PUSH
19089: LD_INT 2
19091: ARRAY
19092: ST_TO_ADDR
// if not lab then
19093: LD_VAR 0 6
19097: NOT
19098: IFFALSE 19102
// exit ;
19100: GO 20028
// SetSpecResearch ( lab , artifactsResDifficulty [ 2 ] , true ) ;
19102: LD_VAR 0 6
19106: PPUSH
19107: LD_EXP 64
19111: PUSH
19112: LD_INT 2
19114: ARRAY
19115: PPUSH
19116: LD_INT 1
19118: PPUSH
19119: CALL_OW 486
// if artifactsResProgress [ 2 ] then
19123: LD_EXP 65
19127: PUSH
19128: LD_INT 2
19130: ARRAY
19131: IFFALSE 19151
// SetWorkingProgress ( lab , artifactsResProgress [ 2 ] ) ;
19133: LD_VAR 0 6
19137: PPUSH
19138: LD_EXP 65
19142: PUSH
19143: LD_INT 2
19145: ARRAY
19146: PPUSH
19147: CALL_OW 329
// artifactsLabsWorking := Replace ( artifactsLabsWorking , 2 , 1 ) ;
19151: LD_ADDR_EXP 63
19155: PUSH
19156: LD_EXP 63
19160: PPUSH
19161: LD_INT 2
19163: PPUSH
19164: LD_INT 1
19166: PPUSH
19167: CALL_OW 1
19171: ST_TO_ADDR
// SetArtifactUse ( 7 , artifactsButtons [ 2 ] [ 3 ] , art_no , lab ) ;
19172: LD_INT 7
19174: PPUSH
19175: LD_EXP 67
19179: PUSH
19180: LD_INT 2
19182: ARRAY
19183: PUSH
19184: LD_INT 3
19186: ARRAY
19187: PPUSH
19188: LD_INT 0
19190: PPUSH
19191: LD_VAR 0 6
19195: PPUSH
19196: CALL_OW 468
// end ; if icon = artifactsButtons [ 3 ] [ 3 ] then
19200: LD_VAR 0 2
19204: PUSH
19205: LD_EXP 67
19209: PUSH
19210: LD_INT 3
19212: ARRAY
19213: PUSH
19214: LD_INT 3
19216: ARRAY
19217: EQUAL
19218: IFFALSE 19341
// begin lab := artifactsLabs [ 3 ] ;
19220: LD_ADDR_VAR 0 6
19224: PUSH
19225: LD_EXP 66
19229: PUSH
19230: LD_INT 3
19232: ARRAY
19233: ST_TO_ADDR
// if not lab then
19234: LD_VAR 0 6
19238: NOT
19239: IFFALSE 19243
// exit ;
19241: GO 20028
// SetSpecResearch ( lab , artifactsResDifficulty [ 3 ] , true ) ;
19243: LD_VAR 0 6
19247: PPUSH
19248: LD_EXP 64
19252: PUSH
19253: LD_INT 3
19255: ARRAY
19256: PPUSH
19257: LD_INT 1
19259: PPUSH
19260: CALL_OW 486
// if artifactsResProgress [ 3 ] then
19264: LD_EXP 65
19268: PUSH
19269: LD_INT 3
19271: ARRAY
19272: IFFALSE 19292
// SetWorkingProgress ( lab , artifactsResProgress [ 3 ] ) ;
19274: LD_VAR 0 6
19278: PPUSH
19279: LD_EXP 65
19283: PUSH
19284: LD_INT 3
19286: ARRAY
19287: PPUSH
19288: CALL_OW 329
// artifactsLabsWorking := Replace ( artifactsLabsWorking , 3 , 1 ) ;
19292: LD_ADDR_EXP 63
19296: PUSH
19297: LD_EXP 63
19301: PPUSH
19302: LD_INT 3
19304: PPUSH
19305: LD_INT 1
19307: PPUSH
19308: CALL_OW 1
19312: ST_TO_ADDR
// SetArtifactUse ( 7 , artifactsButtons [ 3 ] [ 3 ] , art_no , lab ) ;
19313: LD_INT 7
19315: PPUSH
19316: LD_EXP 67
19320: PUSH
19321: LD_INT 3
19323: ARRAY
19324: PUSH
19325: LD_INT 3
19327: ARRAY
19328: PPUSH
19329: LD_INT 0
19331: PPUSH
19332: LD_VAR 0 6
19336: PPUSH
19337: CALL_OW 468
// end ; if icon = artifactsButtons [ 1 ] [ 1 ] then
19341: LD_VAR 0 2
19345: PUSH
19346: LD_EXP 67
19350: PUSH
19351: LD_INT 1
19353: ARRAY
19354: PUSH
19355: LD_INT 1
19357: ARRAY
19358: EQUAL
19359: IFFALSE 19517
// begin lab := artifactsLabs [ 1 ] ;
19361: LD_ADDR_VAR 0 6
19365: PUSH
19366: LD_EXP 66
19370: PUSH
19371: LD_INT 1
19373: ARRAY
19374: ST_TO_ADDR
// if GetBaseMaterials ( GetBase ( lab ) ) [ 3 ] < artifactsSibCost [ 1 ] then
19375: LD_VAR 0 6
19379: PPUSH
19380: CALL_OW 274
19384: PPUSH
19385: CALL 93586 0 1
19389: PUSH
19390: LD_INT 3
19392: ARRAY
19393: PUSH
19394: LD_EXP 61
19398: PUSH
19399: LD_INT 1
19401: ARRAY
19402: LESS
19403: IFFALSE 19417
// begin HintSpec ( ArtifactCost , 2 ) ;
19405: LD_STRING ArtifactCost
19407: PPUSH
19408: LD_INT 2
19410: PPUSH
19411: CALL_OW 338
// exit ;
19415: GO 20028
// end ; artifactsReady := Replace ( artifactsReady , 1 , false ) ;
19417: LD_ADDR_EXP 68
19421: PUSH
19422: LD_EXP 68
19426: PPUSH
19427: LD_INT 1
19429: PPUSH
19430: LD_INT 0
19432: PPUSH
19433: CALL_OW 1
19437: ST_TO_ADDR
// PlaceSeeing ( x , y , 7 , - 12 ) ;
19438: LD_VAR 0 3
19442: PPUSH
19443: LD_VAR 0 4
19447: PPUSH
19448: LD_INT 7
19450: PPUSH
19451: LD_INT 12
19453: NEG
19454: PPUSH
19455: CALL_OW 330
// wait ( 0 0$30 ) ;
19459: LD_INT 1050
19461: PPUSH
19462: CALL_OW 67
// RemoveSeeing ( x , y , 7 ) ;
19466: LD_VAR 0 3
19470: PPUSH
19471: LD_VAR 0 4
19475: PPUSH
19476: LD_INT 7
19478: PPUSH
19479: CALL_OW 331
// wait ( artifactsRecharge [ 1 ] ) ;
19483: LD_EXP 60
19487: PUSH
19488: LD_INT 1
19490: ARRAY
19491: PPUSH
19492: CALL_OW 67
// artifactsReady := Replace ( artifactsReady , 1 , true ) ;
19496: LD_ADDR_EXP 68
19500: PUSH
19501: LD_EXP 68
19505: PPUSH
19506: LD_INT 1
19508: PPUSH
19509: LD_INT 1
19511: PPUSH
19512: CALL_OW 1
19516: ST_TO_ADDR
// end ; if icon = artifactsButtons [ 2 ] [ 1 ] then
19517: LD_VAR 0 2
19521: PUSH
19522: LD_EXP 67
19526: PUSH
19527: LD_INT 2
19529: ARRAY
19530: PUSH
19531: LD_INT 1
19533: ARRAY
19534: EQUAL
19535: IFFALSE 19761
// begin lab := artifactsLabs [ 2 ] ;
19537: LD_ADDR_VAR 0 6
19541: PUSH
19542: LD_EXP 66
19546: PUSH
19547: LD_INT 2
19549: ARRAY
19550: ST_TO_ADDR
// if not x in FilterAllUnits ( [ [ f_enemy , 7 ] , [ f_or , [ f_engine , engine_siberite ] , [ f_btype , b_siberite_power ] , [ f_btype , b_siberite_mine ] , [ f_bweapon , ru_time_lapser ] , [ f_weapon , ru_time_lapser ] ] ] ) then
19551: LD_VAR 0 3
19555: PUSH
19556: LD_INT 81
19558: PUSH
19559: LD_INT 7
19561: PUSH
19562: EMPTY
19563: LIST
19564: LIST
19565: PUSH
19566: LD_INT 2
19568: PUSH
19569: LD_INT 32
19571: PUSH
19572: LD_INT 3
19574: PUSH
19575: EMPTY
19576: LIST
19577: LIST
19578: PUSH
19579: LD_INT 30
19581: PUSH
19582: LD_INT 28
19584: PUSH
19585: EMPTY
19586: LIST
19587: LIST
19588: PUSH
19589: LD_INT 30
19591: PUSH
19592: LD_INT 30
19594: PUSH
19595: EMPTY
19596: LIST
19597: LIST
19598: PUSH
19599: LD_INT 35
19601: PUSH
19602: LD_INT 49
19604: PUSH
19605: EMPTY
19606: LIST
19607: LIST
19608: PUSH
19609: LD_INT 34
19611: PUSH
19612: LD_INT 49
19614: PUSH
19615: EMPTY
19616: LIST
19617: LIST
19618: PUSH
19619: EMPTY
19620: LIST
19621: LIST
19622: LIST
19623: LIST
19624: LIST
19625: LIST
19626: PUSH
19627: EMPTY
19628: LIST
19629: LIST
19630: PPUSH
19631: CALL_OW 69
19635: IN
19636: NOT
19637: IFFALSE 19641
// exit ;
19639: GO 20028
// if GetBaseMaterials ( GetBase ( lab ) ) [ 3 ] < artifactsSibCost [ 2 ] then
19641: LD_VAR 0 6
19645: PPUSH
19646: CALL_OW 274
19650: PPUSH
19651: CALL 93586 0 1
19655: PUSH
19656: LD_INT 3
19658: ARRAY
19659: PUSH
19660: LD_EXP 61
19664: PUSH
19665: LD_INT 2
19667: ARRAY
19668: LESS
19669: IFFALSE 19683
// begin HintSpec ( ArtifactCost , 2 ) ;
19671: LD_STRING ArtifactCost
19673: PPUSH
19674: LD_INT 2
19676: PPUSH
19677: CALL_OW 338
// exit ;
19681: GO 20028
// end ; artifactsReady := Replace ( artifactsReady , 2 , false ) ;
19683: LD_ADDR_EXP 68
19687: PUSH
19688: LD_EXP 68
19692: PPUSH
19693: LD_INT 2
19695: PPUSH
19696: LD_INT 0
19698: PPUSH
19699: CALL_OW 1
19703: ST_TO_ADDR
// KillUnit ( x ) ;
19704: LD_VAR 0 3
19708: PPUSH
19709: CALL_OW 66
// artifactDestroyCounter := artifactDestroyCounter + 1 ;
19713: LD_ADDR_EXP 13
19717: PUSH
19718: LD_EXP 13
19722: PUSH
19723: LD_INT 1
19725: PLUS
19726: ST_TO_ADDR
// wait ( artifactsRecharge [ 2 ] ) ;
19727: LD_EXP 60
19731: PUSH
19732: LD_INT 2
19734: ARRAY
19735: PPUSH
19736: CALL_OW 67
// artifactsReady := Replace ( artifactsReady , 2 , true ) ;
19740: LD_ADDR_EXP 68
19744: PUSH
19745: LD_EXP 68
19749: PPUSH
19750: LD_INT 2
19752: PPUSH
19753: LD_INT 1
19755: PPUSH
19756: CALL_OW 1
19760: ST_TO_ADDR
// end ; if icon = artifactsButtons [ 3 ] [ 1 ] then
19761: LD_VAR 0 2
19765: PUSH
19766: LD_EXP 67
19770: PUSH
19771: LD_INT 3
19773: ARRAY
19774: PUSH
19775: LD_INT 1
19777: ARRAY
19778: EQUAL
19779: IFFALSE 20028
// begin lab := artifactsLabs [ 3 ] ;
19781: LD_ADDR_VAR 0 6
19785: PUSH
19786: LD_EXP 66
19790: PUSH
19791: LD_INT 3
19793: ARRAY
19794: ST_TO_ADDR
// if GetBaseMaterials ( GetBase ( lab ) ) [ 3 ] < artifactsSibCost [ 3 ] then
19795: LD_VAR 0 6
19799: PPUSH
19800: CALL_OW 274
19804: PPUSH
19805: CALL 93586 0 1
19809: PUSH
19810: LD_INT 3
19812: ARRAY
19813: PUSH
19814: LD_EXP 61
19818: PUSH
19819: LD_INT 3
19821: ARRAY
19822: LESS
19823: IFFALSE 19837
// begin HintSpec ( ArtifactCost , 2 ) ;
19825: LD_STRING ArtifactCost
19827: PPUSH
19828: LD_INT 2
19830: PPUSH
19831: CALL_OW 338
// exit ;
19835: GO 20028
// end ; SetAreaMapShow ( teleportArea , 1 ) ;
19837: LD_INT 37
19839: PPUSH
19840: LD_INT 1
19842: PPUSH
19843: CALL_OW 424
// time := 0 0$30 ;
19847: LD_ADDR_VAR 0 7
19851: PUSH
19852: LD_INT 1050
19854: ST_TO_ADDR
// artifactsReady := Replace ( artifactsReady , 3 , false ) ;
19855: LD_ADDR_EXP 68
19859: PUSH
19860: LD_EXP 68
19864: PPUSH
19865: LD_INT 3
19867: PPUSH
19868: LD_INT 0
19870: PPUSH
19871: CALL_OW 1
19875: ST_TO_ADDR
// repeat display_strings := [ #Am15a-1 , time ] ;
19876: LD_ADDR_OWVAR 47
19880: PUSH
19881: LD_STRING #Am15a-1
19883: PUSH
19884: LD_VAR 0 7
19888: PUSH
19889: EMPTY
19890: LIST
19891: LIST
19892: ST_TO_ADDR
// wait ( 0 0$1 ) ;
19893: LD_INT 35
19895: PPUSH
19896: CALL_OW 67
// time := time - 0 0$1 ;
19900: LD_ADDR_VAR 0 7
19904: PUSH
19905: LD_VAR 0 7
19909: PUSH
19910: LD_INT 35
19912: MINUS
19913: ST_TO_ADDR
// until time = 0 0$00 ;
19914: LD_VAR 0 7
19918: PUSH
19919: LD_INT 0
19921: EQUAL
19922: IFFALSE 19876
// display_strings :=  ;
19924: LD_ADDR_OWVAR 47
19928: PUSH
19929: LD_STRING 
19931: ST_TO_ADDR
// SetAreaMapShow ( teleportArea , 0 ) ;
19932: LD_INT 37
19934: PPUSH
19935: LD_INT 0
19937: PPUSH
19938: CALL_OW 424
// list := FilterUnitsInArea ( teleportArea , [ f_not , [ f_type , unit_building ] ] ) ;
19942: LD_ADDR_VAR 0 8
19946: PUSH
19947: LD_INT 37
19949: PPUSH
19950: LD_INT 3
19952: PUSH
19953: LD_INT 21
19955: PUSH
19956: LD_INT 3
19958: PUSH
19959: EMPTY
19960: LIST
19961: LIST
19962: PUSH
19963: EMPTY
19964: LIST
19965: LIST
19966: PPUSH
19967: CALL_OW 70
19971: ST_TO_ADDR
// CenterOnXY ( x , y ) ;
19972: LD_VAR 0 3
19976: PPUSH
19977: LD_VAR 0 4
19981: PPUSH
19982: CALL_OW 84
// for un in list do
19986: LD_ADDR_VAR 0 9
19990: PUSH
19991: LD_VAR 0 8
19995: PUSH
19996: FOR_IN
19997: IFFALSE 20026
// TeleportUnit ( un , x , y , 12 , true ) ;
19999: LD_VAR 0 9
20003: PPUSH
20004: LD_VAR 0 3
20008: PPUSH
20009: LD_VAR 0 4
20013: PPUSH
20014: LD_INT 12
20016: PPUSH
20017: LD_INT 1
20019: PPUSH
20020: CALL_OW 483
20024: GO 19996
20026: POP
20027: POP
// end ; end ;
20028: PPOPN 9
20030: END
// on SpecResearchCancel ( lab , progress ) do var i , labNum ;
20031: LD_INT 0
20033: PPUSH
20034: PPUSH
// begin labNum := 0 ;
20035: LD_ADDR_VAR 0 4
20039: PUSH
20040: LD_INT 0
20042: ST_TO_ADDR
// for i = 1 to artifactsLabs do
20043: LD_ADDR_VAR 0 3
20047: PUSH
20048: DOUBLE
20049: LD_INT 1
20051: DEC
20052: ST_TO_ADDR
20053: LD_EXP 66
20057: PUSH
20058: FOR_TO
20059: IFFALSE 20093
// if artifactsLabs [ i ] = lab then
20061: LD_EXP 66
20065: PUSH
20066: LD_VAR 0 3
20070: ARRAY
20071: PUSH
20072: LD_VAR 0 1
20076: EQUAL
20077: IFFALSE 20091
// begin labNum := i ;
20079: LD_ADDR_VAR 0 4
20083: PUSH
20084: LD_VAR 0 3
20088: ST_TO_ADDR
// break ;
20089: GO 20093
// end ;
20091: GO 20058
20093: POP
20094: POP
// if not labNum then
20095: LD_VAR 0 4
20099: NOT
20100: IFFALSE 20104
// exit ;
20102: GO 20182
// SetArtifactUse ( 7 , artifactsButtons [ labNum ] [ 3 ] , art_instant , lab ) ;
20104: LD_INT 7
20106: PPUSH
20107: LD_EXP 67
20111: PUSH
20112: LD_VAR 0 4
20116: ARRAY
20117: PUSH
20118: LD_INT 3
20120: ARRAY
20121: PPUSH
20122: LD_INT 2
20124: PPUSH
20125: LD_VAR 0 1
20129: PPUSH
20130: CALL_OW 468
// artifactsResProgress := Replace ( artifactsResProgress , labNum , progress ) ;
20134: LD_ADDR_EXP 65
20138: PUSH
20139: LD_EXP 65
20143: PPUSH
20144: LD_VAR 0 4
20148: PPUSH
20149: LD_VAR 0 2
20153: PPUSH
20154: CALL_OW 1
20158: ST_TO_ADDR
// artifactsLabsWorking := Replace ( artifactsLabsWorking , labNum , 0 ) ;
20159: LD_ADDR_EXP 63
20163: PUSH
20164: LD_EXP 63
20168: PPUSH
20169: LD_VAR 0 4
20173: PPUSH
20174: LD_INT 0
20176: PPUSH
20177: CALL_OW 1
20181: ST_TO_ADDR
// end ;
20182: PPOPN 4
20184: END
// on SpecResearchComplete ( lab ) do var i , labNum ;
20185: LD_INT 0
20187: PPUSH
20188: PPUSH
// begin labNum := 0 ;
20189: LD_ADDR_VAR 0 3
20193: PUSH
20194: LD_INT 0
20196: ST_TO_ADDR
// for i = 1 to artifactsLabs do
20197: LD_ADDR_VAR 0 2
20201: PUSH
20202: DOUBLE
20203: LD_INT 1
20205: DEC
20206: ST_TO_ADDR
20207: LD_EXP 66
20211: PUSH
20212: FOR_TO
20213: IFFALSE 20247
// if artifactsLabs [ i ] = lab then
20215: LD_EXP 66
20219: PUSH
20220: LD_VAR 0 2
20224: ARRAY
20225: PUSH
20226: LD_VAR 0 1
20230: EQUAL
20231: IFFALSE 20245
// begin labNum := i ;
20233: LD_ADDR_VAR 0 3
20237: PUSH
20238: LD_VAR 0 2
20242: ST_TO_ADDR
// break ;
20243: GO 20247
// end ;
20245: GO 20212
20247: POP
20248: POP
// if not labNum then
20249: LD_VAR 0 3
20253: NOT
20254: IFFALSE 20258
// exit ;
20256: GO 20420
// SetArtifactUse ( 7 , artifactsButtons [ labNum ] [ 3 ] , art_no , lab ) ;
20258: LD_INT 7
20260: PPUSH
20261: LD_EXP 67
20265: PUSH
20266: LD_VAR 0 3
20270: ARRAY
20271: PUSH
20272: LD_INT 3
20274: ARRAY
20275: PPUSH
20276: LD_INT 0
20278: PPUSH
20279: LD_VAR 0 1
20283: PPUSH
20284: CALL_OW 468
// artifactsResearched := Replace ( artifactsResearched , labNum , true ) ;
20288: LD_ADDR_EXP 62
20292: PUSH
20293: LD_EXP 62
20297: PPUSH
20298: LD_VAR 0 3
20302: PPUSH
20303: LD_INT 1
20305: PPUSH
20306: CALL_OW 1
20310: ST_TO_ADDR
// artifactsReady := Replace ( artifactsReady , labNum , true ) ;
20311: LD_ADDR_EXP 68
20315: PUSH
20316: LD_EXP 68
20320: PPUSH
20321: LD_VAR 0 3
20325: PPUSH
20326: LD_INT 1
20328: PPUSH
20329: CALL_OW 1
20333: ST_TO_ADDR
// artifactsLabsWorking := Replace ( artifactsLabsWorking , labNum , false ) ;
20334: LD_ADDR_EXP 63
20338: PUSH
20339: LD_EXP 63
20343: PPUSH
20344: LD_VAR 0 3
20348: PPUSH
20349: LD_INT 0
20351: PPUSH
20352: CALL_OW 1
20356: ST_TO_ADDR
// case labNum of 1 :
20357: LD_VAR 0 3
20361: PUSH
20362: LD_INT 1
20364: DOUBLE
20365: EQUAL
20366: IFTRUE 20370
20368: GO 20381
20370: POP
// artifactIResearched := true ; 2 :
20371: LD_ADDR_EXP 9
20375: PUSH
20376: LD_INT 1
20378: ST_TO_ADDR
20379: GO 20420
20381: LD_INT 2
20383: DOUBLE
20384: EQUAL
20385: IFTRUE 20389
20387: GO 20400
20389: POP
// artifactIIResearched := true ; 3 :
20390: LD_ADDR_EXP 10
20394: PUSH
20395: LD_INT 1
20397: ST_TO_ADDR
20398: GO 20420
20400: LD_INT 3
20402: DOUBLE
20403: EQUAL
20404: IFTRUE 20408
20406: GO 20419
20408: POP
// artifactIIIResearched := true ; end ;
20409: LD_ADDR_EXP 11
20413: PUSH
20414: LD_INT 1
20416: ST_TO_ADDR
20417: GO 20420
20419: POP
// end ; end_of_file
20420: PPOPN 3
20422: END
// export ru_radar , ru_big_cargo_bay , us_hack , us_artillery , ar_bio_bomb ; every 1 do
20423: GO 20425
20425: DISABLE
// begin ru_radar := 98 ;
20426: LD_ADDR_EXP 69
20430: PUSH
20431: LD_INT 98
20433: ST_TO_ADDR
// ru_big_cargo_bay := 89 ;
20434: LD_ADDR_EXP 70
20438: PUSH
20439: LD_INT 89
20441: ST_TO_ADDR
// us_hack := 99 ;
20442: LD_ADDR_EXP 71
20446: PUSH
20447: LD_INT 99
20449: ST_TO_ADDR
// us_artillery := 97 ;
20450: LD_ADDR_EXP 72
20454: PUSH
20455: LD_INT 97
20457: ST_TO_ADDR
// ar_bio_bomb := 91 ;
20458: LD_ADDR_EXP 73
20462: PUSH
20463: LD_INT 91
20465: ST_TO_ADDR
// end ; end_of_file
20466: END
// export skirmish , debug_mc ; export mc_bases , mc_building_need_repair , mc_building_repairs , mc_need_heal , mc_healers , mc_build_list , mc_builders , mc_construct_list , mc_turret_list , mc_empty_turret_list , mc_busy_turret_list , mc_defender_limit , mc_repair_vehicle , mc_mines , mc_miners , mc_minefields , mc_crates , mc_crates_collector , mc_crates_area , mc_vehicles , mc_attack , mc_produce , mc_defender , mc_scan , mc_parking , mc_scan_area , mc_sides , mc_tech , mc_can_tame , mc_ape , mc_ape_in_lab , mc_taming , mc_build_upgrade , mc_lab , mc_lab_upgrade , mc_teleport_exit , mc_teleport_exit_set , mc_deposits_xy , mc_deposits_finder , mc_allowed_tower_weapons , mc_remote_driver , mc_class , mc_class_case_use ; export function InitMacro ; var i ; begin
20467: LD_INT 0
20469: PPUSH
20470: PPUSH
// skirmish := false ;
20471: LD_ADDR_EXP 74
20475: PUSH
20476: LD_INT 0
20478: ST_TO_ADDR
// debug_mc := false ;
20479: LD_ADDR_EXP 75
20483: PUSH
20484: LD_INT 0
20486: ST_TO_ADDR
// mc_bases := [ ] ;
20487: LD_ADDR_EXP 76
20491: PUSH
20492: EMPTY
20493: ST_TO_ADDR
// mc_sides := [ ] ;
20494: LD_ADDR_EXP 102
20498: PUSH
20499: EMPTY
20500: ST_TO_ADDR
// mc_building_need_repair := [ ] ;
20501: LD_ADDR_EXP 77
20505: PUSH
20506: EMPTY
20507: ST_TO_ADDR
// mc_building_repairs := [ ] ;
20508: LD_ADDR_EXP 78
20512: PUSH
20513: EMPTY
20514: ST_TO_ADDR
// mc_need_heal := [ ] ;
20515: LD_ADDR_EXP 79
20519: PUSH
20520: EMPTY
20521: ST_TO_ADDR
// mc_healers := [ ] ;
20522: LD_ADDR_EXP 80
20526: PUSH
20527: EMPTY
20528: ST_TO_ADDR
// mc_build_list := [ ] ;
20529: LD_ADDR_EXP 81
20533: PUSH
20534: EMPTY
20535: ST_TO_ADDR
// mc_build_upgrade := [ ] ;
20536: LD_ADDR_EXP 108
20540: PUSH
20541: EMPTY
20542: ST_TO_ADDR
// mc_builders := [ ] ;
20543: LD_ADDR_EXP 82
20547: PUSH
20548: EMPTY
20549: ST_TO_ADDR
// mc_construct_list := [ ] ;
20550: LD_ADDR_EXP 83
20554: PUSH
20555: EMPTY
20556: ST_TO_ADDR
// mc_turret_list := [ ] ;
20557: LD_ADDR_EXP 84
20561: PUSH
20562: EMPTY
20563: ST_TO_ADDR
// mc_empty_turret_list := [ ] ;
20564: LD_ADDR_EXP 85
20568: PUSH
20569: EMPTY
20570: ST_TO_ADDR
// mc_miners := [ ] ;
20571: LD_ADDR_EXP 90
20575: PUSH
20576: EMPTY
20577: ST_TO_ADDR
// mc_mines := [ ] ;
20578: LD_ADDR_EXP 89
20582: PUSH
20583: EMPTY
20584: ST_TO_ADDR
// mc_minefields := [ ] ;
20585: LD_ADDR_EXP 91
20589: PUSH
20590: EMPTY
20591: ST_TO_ADDR
// mc_crates := [ ] ;
20592: LD_ADDR_EXP 92
20596: PUSH
20597: EMPTY
20598: ST_TO_ADDR
// mc_crates_collector := [ ] ;
20599: LD_ADDR_EXP 93
20603: PUSH
20604: EMPTY
20605: ST_TO_ADDR
// mc_crates_area := [ ] ;
20606: LD_ADDR_EXP 94
20610: PUSH
20611: EMPTY
20612: ST_TO_ADDR
// mc_vehicles := [ ] ;
20613: LD_ADDR_EXP 95
20617: PUSH
20618: EMPTY
20619: ST_TO_ADDR
// mc_attack := [ ] ;
20620: LD_ADDR_EXP 96
20624: PUSH
20625: EMPTY
20626: ST_TO_ADDR
// mc_produce := [ ] ;
20627: LD_ADDR_EXP 97
20631: PUSH
20632: EMPTY
20633: ST_TO_ADDR
// mc_defender := [ ] ;
20634: LD_ADDR_EXP 98
20638: PUSH
20639: EMPTY
20640: ST_TO_ADDR
// mc_parking := [ ] ;
20641: LD_ADDR_EXP 100
20645: PUSH
20646: EMPTY
20647: ST_TO_ADDR
// mc_busy_turret_list := [ ] ;
20648: LD_ADDR_EXP 86
20652: PUSH
20653: EMPTY
20654: ST_TO_ADDR
// mc_repair_vehicle := [ ] ;
20655: LD_ADDR_EXP 88
20659: PUSH
20660: EMPTY
20661: ST_TO_ADDR
// mc_scan := [ ] ;
20662: LD_ADDR_EXP 99
20666: PUSH
20667: EMPTY
20668: ST_TO_ADDR
// mc_scan_area := [ ] ;
20669: LD_ADDR_EXP 101
20673: PUSH
20674: EMPTY
20675: ST_TO_ADDR
// mc_tech := [ ] ;
20676: LD_ADDR_EXP 103
20680: PUSH
20681: EMPTY
20682: ST_TO_ADDR
// mc_class := [ ] ;
20683: LD_ADDR_EXP 117
20687: PUSH
20688: EMPTY
20689: ST_TO_ADDR
// mc_class_case_use := [ ] ;
20690: LD_ADDR_EXP 118
20694: PUSH
20695: EMPTY
20696: ST_TO_ADDR
// end ;
20697: LD_VAR 0 1
20701: RET
// export function MC_Kill ( base ) ; begin
20702: LD_INT 0
20704: PPUSH
// mc_bases := Replace ( mc_bases , base , [ ] ) ;
20705: LD_ADDR_EXP 76
20709: PUSH
20710: LD_EXP 76
20714: PPUSH
20715: LD_VAR 0 1
20719: PPUSH
20720: EMPTY
20721: PPUSH
20722: CALL_OW 1
20726: ST_TO_ADDR
// mc_building_need_repair := Replace ( mc_building_need_repair , base , [ ] ) ;
20727: LD_ADDR_EXP 77
20731: PUSH
20732: LD_EXP 77
20736: PPUSH
20737: LD_VAR 0 1
20741: PPUSH
20742: EMPTY
20743: PPUSH
20744: CALL_OW 1
20748: ST_TO_ADDR
// mc_building_repairs := Replace ( mc_building_repairs , base , [ ] ) ;
20749: LD_ADDR_EXP 78
20753: PUSH
20754: LD_EXP 78
20758: PPUSH
20759: LD_VAR 0 1
20763: PPUSH
20764: EMPTY
20765: PPUSH
20766: CALL_OW 1
20770: ST_TO_ADDR
// mc_need_heal := Replace ( mc_need_heal , base , [ ] ) ;
20771: LD_ADDR_EXP 79
20775: PUSH
20776: LD_EXP 79
20780: PPUSH
20781: LD_VAR 0 1
20785: PPUSH
20786: EMPTY
20787: PPUSH
20788: CALL_OW 1
20792: ST_TO_ADDR
// mc_healers := Replace ( mc_healers , base , [ ] ) ;
20793: LD_ADDR_EXP 80
20797: PUSH
20798: LD_EXP 80
20802: PPUSH
20803: LD_VAR 0 1
20807: PPUSH
20808: EMPTY
20809: PPUSH
20810: CALL_OW 1
20814: ST_TO_ADDR
// mc_build_list := Replace ( mc_build_list , base , [ ] ) ;
20815: LD_ADDR_EXP 81
20819: PUSH
20820: LD_EXP 81
20824: PPUSH
20825: LD_VAR 0 1
20829: PPUSH
20830: EMPTY
20831: PPUSH
20832: CALL_OW 1
20836: ST_TO_ADDR
// mc_builders := Replace ( mc_builders , base , [ ] ) ;
20837: LD_ADDR_EXP 82
20841: PUSH
20842: LD_EXP 82
20846: PPUSH
20847: LD_VAR 0 1
20851: PPUSH
20852: EMPTY
20853: PPUSH
20854: CALL_OW 1
20858: ST_TO_ADDR
// mc_construct_list := Replace ( mc_construct_list , base , [ ] ) ;
20859: LD_ADDR_EXP 83
20863: PUSH
20864: LD_EXP 83
20868: PPUSH
20869: LD_VAR 0 1
20873: PPUSH
20874: EMPTY
20875: PPUSH
20876: CALL_OW 1
20880: ST_TO_ADDR
// mc_turret_list := Replace ( mc_turret_list , base , [ ] ) ;
20881: LD_ADDR_EXP 84
20885: PUSH
20886: LD_EXP 84
20890: PPUSH
20891: LD_VAR 0 1
20895: PPUSH
20896: EMPTY
20897: PPUSH
20898: CALL_OW 1
20902: ST_TO_ADDR
// mc_empty_turret_list := Replace ( mc_empty_turret_list , base , [ ] ) ;
20903: LD_ADDR_EXP 85
20907: PUSH
20908: LD_EXP 85
20912: PPUSH
20913: LD_VAR 0 1
20917: PPUSH
20918: EMPTY
20919: PPUSH
20920: CALL_OW 1
20924: ST_TO_ADDR
// mc_busy_turret_list := Replace ( mc_busy_turret_list , base , [ ] ) ;
20925: LD_ADDR_EXP 86
20929: PUSH
20930: LD_EXP 86
20934: PPUSH
20935: LD_VAR 0 1
20939: PPUSH
20940: EMPTY
20941: PPUSH
20942: CALL_OW 1
20946: ST_TO_ADDR
// mc_defender_limit := Replace ( mc_defender_limit , base , 0 ) ;
20947: LD_ADDR_EXP 87
20951: PUSH
20952: LD_EXP 87
20956: PPUSH
20957: LD_VAR 0 1
20961: PPUSH
20962: LD_INT 0
20964: PPUSH
20965: CALL_OW 1
20969: ST_TO_ADDR
// mc_repair_vehicle := Replace ( mc_repair_vehicle , base , [ ] ) ;
20970: LD_ADDR_EXP 88
20974: PUSH
20975: LD_EXP 88
20979: PPUSH
20980: LD_VAR 0 1
20984: PPUSH
20985: EMPTY
20986: PPUSH
20987: CALL_OW 1
20991: ST_TO_ADDR
// mc_mines := Replace ( mc_mines , base , [ ] ) ;
20992: LD_ADDR_EXP 89
20996: PUSH
20997: LD_EXP 89
21001: PPUSH
21002: LD_VAR 0 1
21006: PPUSH
21007: EMPTY
21008: PPUSH
21009: CALL_OW 1
21013: ST_TO_ADDR
// mc_miners := Replace ( mc_miners , base , [ ] ) ;
21014: LD_ADDR_EXP 90
21018: PUSH
21019: LD_EXP 90
21023: PPUSH
21024: LD_VAR 0 1
21028: PPUSH
21029: EMPTY
21030: PPUSH
21031: CALL_OW 1
21035: ST_TO_ADDR
// mc_minefields := Replace ( mc_minefields , base , [ ] ) ;
21036: LD_ADDR_EXP 91
21040: PUSH
21041: LD_EXP 91
21045: PPUSH
21046: LD_VAR 0 1
21050: PPUSH
21051: EMPTY
21052: PPUSH
21053: CALL_OW 1
21057: ST_TO_ADDR
// mc_crates := Replace ( mc_crates , base , [ ] ) ;
21058: LD_ADDR_EXP 92
21062: PUSH
21063: LD_EXP 92
21067: PPUSH
21068: LD_VAR 0 1
21072: PPUSH
21073: EMPTY
21074: PPUSH
21075: CALL_OW 1
21079: ST_TO_ADDR
// mc_crates_collector := Replace ( mc_crates_collector , base , [ ] ) ;
21080: LD_ADDR_EXP 93
21084: PUSH
21085: LD_EXP 93
21089: PPUSH
21090: LD_VAR 0 1
21094: PPUSH
21095: EMPTY
21096: PPUSH
21097: CALL_OW 1
21101: ST_TO_ADDR
// mc_crates_area := Replace ( mc_crates_area , base , [ ] ) ;
21102: LD_ADDR_EXP 94
21106: PUSH
21107: LD_EXP 94
21111: PPUSH
21112: LD_VAR 0 1
21116: PPUSH
21117: EMPTY
21118: PPUSH
21119: CALL_OW 1
21123: ST_TO_ADDR
// mc_vehicles := Replace ( mc_vehicles , base , [ ] ) ;
21124: LD_ADDR_EXP 95
21128: PUSH
21129: LD_EXP 95
21133: PPUSH
21134: LD_VAR 0 1
21138: PPUSH
21139: EMPTY
21140: PPUSH
21141: CALL_OW 1
21145: ST_TO_ADDR
// mc_attack := Replace ( mc_attack , base , [ ] ) ;
21146: LD_ADDR_EXP 96
21150: PUSH
21151: LD_EXP 96
21155: PPUSH
21156: LD_VAR 0 1
21160: PPUSH
21161: EMPTY
21162: PPUSH
21163: CALL_OW 1
21167: ST_TO_ADDR
// mc_produce := Replace ( mc_produce , base , [ ] ) ;
21168: LD_ADDR_EXP 97
21172: PUSH
21173: LD_EXP 97
21177: PPUSH
21178: LD_VAR 0 1
21182: PPUSH
21183: EMPTY
21184: PPUSH
21185: CALL_OW 1
21189: ST_TO_ADDR
// mc_defender := Replace ( mc_defender , base , [ ] ) ;
21190: LD_ADDR_EXP 98
21194: PUSH
21195: LD_EXP 98
21199: PPUSH
21200: LD_VAR 0 1
21204: PPUSH
21205: EMPTY
21206: PPUSH
21207: CALL_OW 1
21211: ST_TO_ADDR
// mc_scan := Replace ( mc_scan , base , [ ] ) ;
21212: LD_ADDR_EXP 99
21216: PUSH
21217: LD_EXP 99
21221: PPUSH
21222: LD_VAR 0 1
21226: PPUSH
21227: EMPTY
21228: PPUSH
21229: CALL_OW 1
21233: ST_TO_ADDR
// mc_parking := Replace ( mc_parking , base , [ ] ) ;
21234: LD_ADDR_EXP 100
21238: PUSH
21239: LD_EXP 100
21243: PPUSH
21244: LD_VAR 0 1
21248: PPUSH
21249: EMPTY
21250: PPUSH
21251: CALL_OW 1
21255: ST_TO_ADDR
// mc_scan_area := Replace ( mc_scan_area , base , [ ] ) ;
21256: LD_ADDR_EXP 101
21260: PUSH
21261: LD_EXP 101
21265: PPUSH
21266: LD_VAR 0 1
21270: PPUSH
21271: EMPTY
21272: PPUSH
21273: CALL_OW 1
21277: ST_TO_ADDR
// mc_tech := Replace ( mc_tech , base , [ ] ) ;
21278: LD_ADDR_EXP 103
21282: PUSH
21283: LD_EXP 103
21287: PPUSH
21288: LD_VAR 0 1
21292: PPUSH
21293: EMPTY
21294: PPUSH
21295: CALL_OW 1
21299: ST_TO_ADDR
// mc_ape := Replace ( mc_ape , base , [ ] ) ;
21300: LD_ADDR_EXP 105
21304: PUSH
21305: LD_EXP 105
21309: PPUSH
21310: LD_VAR 0 1
21314: PPUSH
21315: EMPTY
21316: PPUSH
21317: CALL_OW 1
21321: ST_TO_ADDR
// mc_ape_in_lab := Replace ( mc_ape_in_lab , base , [ ] ) ;
21322: LD_ADDR_EXP 106
21326: PUSH
21327: LD_EXP 106
21331: PPUSH
21332: LD_VAR 0 1
21336: PPUSH
21337: EMPTY
21338: PPUSH
21339: CALL_OW 1
21343: ST_TO_ADDR
// mc_taming := Replace ( mc_taming , base , [ ] ) ;
21344: LD_ADDR_EXP 107
21348: PUSH
21349: LD_EXP 107
21353: PPUSH
21354: LD_VAR 0 1
21358: PPUSH
21359: EMPTY
21360: PPUSH
21361: CALL_OW 1
21365: ST_TO_ADDR
// mc_build_upgrade := Replace ( mc_build_upgrade , base , [ ] ) ;
21366: LD_ADDR_EXP 108
21370: PUSH
21371: LD_EXP 108
21375: PPUSH
21376: LD_VAR 0 1
21380: PPUSH
21381: EMPTY
21382: PPUSH
21383: CALL_OW 1
21387: ST_TO_ADDR
// mc_lab := Replace ( mc_lab , base , [ ] ) ;
21388: LD_ADDR_EXP 109
21392: PUSH
21393: LD_EXP 109
21397: PPUSH
21398: LD_VAR 0 1
21402: PPUSH
21403: EMPTY
21404: PPUSH
21405: CALL_OW 1
21409: ST_TO_ADDR
// mc_lab_upgrade := Replace ( mc_lab_upgrade , base , [ ] ) ;
21410: LD_ADDR_EXP 110
21414: PUSH
21415: LD_EXP 110
21419: PPUSH
21420: LD_VAR 0 1
21424: PPUSH
21425: EMPTY
21426: PPUSH
21427: CALL_OW 1
21431: ST_TO_ADDR
// mc_teleport_exit := Replace ( mc_teleport_exit , base , [ ] ) ;
21432: LD_ADDR_EXP 111
21436: PUSH
21437: LD_EXP 111
21441: PPUSH
21442: LD_VAR 0 1
21446: PPUSH
21447: EMPTY
21448: PPUSH
21449: CALL_OW 1
21453: ST_TO_ADDR
// mc_teleport_exit_set := Replace ( mc_teleport_exit_set , base , [ ] ) ;
21454: LD_ADDR_EXP 112
21458: PUSH
21459: LD_EXP 112
21463: PPUSH
21464: LD_VAR 0 1
21468: PPUSH
21469: EMPTY
21470: PPUSH
21471: CALL_OW 1
21475: ST_TO_ADDR
// mc_deposits_xy := Replace ( mc_deposits_xy , base , [ ] ) ;
21476: LD_ADDR_EXP 113
21480: PUSH
21481: LD_EXP 113
21485: PPUSH
21486: LD_VAR 0 1
21490: PPUSH
21491: EMPTY
21492: PPUSH
21493: CALL_OW 1
21497: ST_TO_ADDR
// mc_deposits_finder := Replace ( mc_deposits_finder , base , [ ] ) ;
21498: LD_ADDR_EXP 114
21502: PUSH
21503: LD_EXP 114
21507: PPUSH
21508: LD_VAR 0 1
21512: PPUSH
21513: EMPTY
21514: PPUSH
21515: CALL_OW 1
21519: ST_TO_ADDR
// mc_allowed_tower_weapons := Replace ( mc_allowed_tower_weapons , base , [ ] ) ;
21520: LD_ADDR_EXP 115
21524: PUSH
21525: LD_EXP 115
21529: PPUSH
21530: LD_VAR 0 1
21534: PPUSH
21535: EMPTY
21536: PPUSH
21537: CALL_OW 1
21541: ST_TO_ADDR
// mc_remote_driver := Replace ( mc_remote_driver , base , [ ] ) ;
21542: LD_ADDR_EXP 116
21546: PUSH
21547: LD_EXP 116
21551: PPUSH
21552: LD_VAR 0 1
21556: PPUSH
21557: EMPTY
21558: PPUSH
21559: CALL_OW 1
21563: ST_TO_ADDR
// mc_class := Replace ( mc_class , base , [ ] ) ;
21564: LD_ADDR_EXP 117
21568: PUSH
21569: LD_EXP 117
21573: PPUSH
21574: LD_VAR 0 1
21578: PPUSH
21579: EMPTY
21580: PPUSH
21581: CALL_OW 1
21585: ST_TO_ADDR
// mc_class_case_use := Replace ( mc_class_case_use , base , 0 ) ;
21586: LD_ADDR_EXP 118
21590: PUSH
21591: LD_EXP 118
21595: PPUSH
21596: LD_VAR 0 1
21600: PPUSH
21601: LD_INT 0
21603: PPUSH
21604: CALL_OW 1
21608: ST_TO_ADDR
// end ;
21609: LD_VAR 0 2
21613: RET
// export function MC_Add ( side , units ) ; var base ; begin
21614: LD_INT 0
21616: PPUSH
21617: PPUSH
// base := mc_bases + 1 ;
21618: LD_ADDR_VAR 0 4
21622: PUSH
21623: LD_EXP 76
21627: PUSH
21628: LD_INT 1
21630: PLUS
21631: ST_TO_ADDR
// mc_sides := Replace ( mc_sides , base , side ) ;
21632: LD_ADDR_EXP 102
21636: PUSH
21637: LD_EXP 102
21641: PPUSH
21642: LD_VAR 0 4
21646: PPUSH
21647: LD_VAR 0 1
21651: PPUSH
21652: CALL_OW 1
21656: ST_TO_ADDR
// mc_bases := Replace ( mc_bases , base , units ) ;
21657: LD_ADDR_EXP 76
21661: PUSH
21662: LD_EXP 76
21666: PPUSH
21667: LD_VAR 0 4
21671: PPUSH
21672: LD_VAR 0 2
21676: PPUSH
21677: CALL_OW 1
21681: ST_TO_ADDR
// mc_building_need_repair := Replace ( mc_building_need_repair , base , [ ] ) ;
21682: LD_ADDR_EXP 77
21686: PUSH
21687: LD_EXP 77
21691: PPUSH
21692: LD_VAR 0 4
21696: PPUSH
21697: EMPTY
21698: PPUSH
21699: CALL_OW 1
21703: ST_TO_ADDR
// mc_building_repairs := Replace ( mc_building_repairs , base , [ ] ) ;
21704: LD_ADDR_EXP 78
21708: PUSH
21709: LD_EXP 78
21713: PPUSH
21714: LD_VAR 0 4
21718: PPUSH
21719: EMPTY
21720: PPUSH
21721: CALL_OW 1
21725: ST_TO_ADDR
// mc_need_heal := Replace ( mc_need_heal , base , [ ] ) ;
21726: LD_ADDR_EXP 79
21730: PUSH
21731: LD_EXP 79
21735: PPUSH
21736: LD_VAR 0 4
21740: PPUSH
21741: EMPTY
21742: PPUSH
21743: CALL_OW 1
21747: ST_TO_ADDR
// mc_healers := Replace ( mc_healers , base , [ ] ) ;
21748: LD_ADDR_EXP 80
21752: PUSH
21753: LD_EXP 80
21757: PPUSH
21758: LD_VAR 0 4
21762: PPUSH
21763: EMPTY
21764: PPUSH
21765: CALL_OW 1
21769: ST_TO_ADDR
// mc_build_list := Replace ( mc_build_list , base , [ ] ) ;
21770: LD_ADDR_EXP 81
21774: PUSH
21775: LD_EXP 81
21779: PPUSH
21780: LD_VAR 0 4
21784: PPUSH
21785: EMPTY
21786: PPUSH
21787: CALL_OW 1
21791: ST_TO_ADDR
// mc_builders := Replace ( mc_builders , base , [ ] ) ;
21792: LD_ADDR_EXP 82
21796: PUSH
21797: LD_EXP 82
21801: PPUSH
21802: LD_VAR 0 4
21806: PPUSH
21807: EMPTY
21808: PPUSH
21809: CALL_OW 1
21813: ST_TO_ADDR
// mc_construct_list := Replace ( mc_construct_list , base , [ ] ) ;
21814: LD_ADDR_EXP 83
21818: PUSH
21819: LD_EXP 83
21823: PPUSH
21824: LD_VAR 0 4
21828: PPUSH
21829: EMPTY
21830: PPUSH
21831: CALL_OW 1
21835: ST_TO_ADDR
// mc_turret_list := Replace ( mc_turret_list , base , [ ] ) ;
21836: LD_ADDR_EXP 84
21840: PUSH
21841: LD_EXP 84
21845: PPUSH
21846: LD_VAR 0 4
21850: PPUSH
21851: EMPTY
21852: PPUSH
21853: CALL_OW 1
21857: ST_TO_ADDR
// mc_empty_turret_list := Replace ( mc_empty_turret_list , base , [ ] ) ;
21858: LD_ADDR_EXP 85
21862: PUSH
21863: LD_EXP 85
21867: PPUSH
21868: LD_VAR 0 4
21872: PPUSH
21873: EMPTY
21874: PPUSH
21875: CALL_OW 1
21879: ST_TO_ADDR
// mc_busy_turret_list := Replace ( mc_busy_turret_list , base , [ ] ) ;
21880: LD_ADDR_EXP 86
21884: PUSH
21885: LD_EXP 86
21889: PPUSH
21890: LD_VAR 0 4
21894: PPUSH
21895: EMPTY
21896: PPUSH
21897: CALL_OW 1
21901: ST_TO_ADDR
// mc_defender_limit := Replace ( mc_defender_limit , base , 0 ) ;
21902: LD_ADDR_EXP 87
21906: PUSH
21907: LD_EXP 87
21911: PPUSH
21912: LD_VAR 0 4
21916: PPUSH
21917: LD_INT 0
21919: PPUSH
21920: CALL_OW 1
21924: ST_TO_ADDR
// mc_repair_vehicle := Replace ( mc_repair_vehicle , base , [ ] ) ;
21925: LD_ADDR_EXP 88
21929: PUSH
21930: LD_EXP 88
21934: PPUSH
21935: LD_VAR 0 4
21939: PPUSH
21940: EMPTY
21941: PPUSH
21942: CALL_OW 1
21946: ST_TO_ADDR
// mc_mines := Replace ( mc_mines , base , [ ] ) ;
21947: LD_ADDR_EXP 89
21951: PUSH
21952: LD_EXP 89
21956: PPUSH
21957: LD_VAR 0 4
21961: PPUSH
21962: EMPTY
21963: PPUSH
21964: CALL_OW 1
21968: ST_TO_ADDR
// mc_miners := Replace ( mc_miners , base , [ ] ) ;
21969: LD_ADDR_EXP 90
21973: PUSH
21974: LD_EXP 90
21978: PPUSH
21979: LD_VAR 0 4
21983: PPUSH
21984: EMPTY
21985: PPUSH
21986: CALL_OW 1
21990: ST_TO_ADDR
// mc_minefields := Replace ( mc_minefields , base , [ ] ) ;
21991: LD_ADDR_EXP 91
21995: PUSH
21996: LD_EXP 91
22000: PPUSH
22001: LD_VAR 0 4
22005: PPUSH
22006: EMPTY
22007: PPUSH
22008: CALL_OW 1
22012: ST_TO_ADDR
// mc_crates := Replace ( mc_crates , base , [ ] ) ;
22013: LD_ADDR_EXP 92
22017: PUSH
22018: LD_EXP 92
22022: PPUSH
22023: LD_VAR 0 4
22027: PPUSH
22028: EMPTY
22029: PPUSH
22030: CALL_OW 1
22034: ST_TO_ADDR
// mc_crates_collector := Replace ( mc_crates_collector , base , [ ] ) ;
22035: LD_ADDR_EXP 93
22039: PUSH
22040: LD_EXP 93
22044: PPUSH
22045: LD_VAR 0 4
22049: PPUSH
22050: EMPTY
22051: PPUSH
22052: CALL_OW 1
22056: ST_TO_ADDR
// mc_crates_area := Replace ( mc_crates_area , base , [ ] ) ;
22057: LD_ADDR_EXP 94
22061: PUSH
22062: LD_EXP 94
22066: PPUSH
22067: LD_VAR 0 4
22071: PPUSH
22072: EMPTY
22073: PPUSH
22074: CALL_OW 1
22078: ST_TO_ADDR
// mc_vehicles := Replace ( mc_vehicles , base , [ ] ) ;
22079: LD_ADDR_EXP 95
22083: PUSH
22084: LD_EXP 95
22088: PPUSH
22089: LD_VAR 0 4
22093: PPUSH
22094: EMPTY
22095: PPUSH
22096: CALL_OW 1
22100: ST_TO_ADDR
// mc_attack := Replace ( mc_attack , base , [ ] ) ;
22101: LD_ADDR_EXP 96
22105: PUSH
22106: LD_EXP 96
22110: PPUSH
22111: LD_VAR 0 4
22115: PPUSH
22116: EMPTY
22117: PPUSH
22118: CALL_OW 1
22122: ST_TO_ADDR
// mc_produce := Replace ( mc_produce , base , [ ] ) ;
22123: LD_ADDR_EXP 97
22127: PUSH
22128: LD_EXP 97
22132: PPUSH
22133: LD_VAR 0 4
22137: PPUSH
22138: EMPTY
22139: PPUSH
22140: CALL_OW 1
22144: ST_TO_ADDR
// mc_defender := Replace ( mc_defender , base , [ ] ) ;
22145: LD_ADDR_EXP 98
22149: PUSH
22150: LD_EXP 98
22154: PPUSH
22155: LD_VAR 0 4
22159: PPUSH
22160: EMPTY
22161: PPUSH
22162: CALL_OW 1
22166: ST_TO_ADDR
// mc_scan := Replace ( mc_scan , base , [ ] ) ;
22167: LD_ADDR_EXP 99
22171: PUSH
22172: LD_EXP 99
22176: PPUSH
22177: LD_VAR 0 4
22181: PPUSH
22182: EMPTY
22183: PPUSH
22184: CALL_OW 1
22188: ST_TO_ADDR
// mc_parking := Replace ( mc_parking , base , [ ] ) ;
22189: LD_ADDR_EXP 100
22193: PUSH
22194: LD_EXP 100
22198: PPUSH
22199: LD_VAR 0 4
22203: PPUSH
22204: EMPTY
22205: PPUSH
22206: CALL_OW 1
22210: ST_TO_ADDR
// mc_scan_area := Replace ( mc_scan_area , base , [ ] ) ;
22211: LD_ADDR_EXP 101
22215: PUSH
22216: LD_EXP 101
22220: PPUSH
22221: LD_VAR 0 4
22225: PPUSH
22226: EMPTY
22227: PPUSH
22228: CALL_OW 1
22232: ST_TO_ADDR
// mc_tech := Replace ( mc_tech , base , [ ] ) ;
22233: LD_ADDR_EXP 103
22237: PUSH
22238: LD_EXP 103
22242: PPUSH
22243: LD_VAR 0 4
22247: PPUSH
22248: EMPTY
22249: PPUSH
22250: CALL_OW 1
22254: ST_TO_ADDR
// mc_ape := Replace ( mc_ape , base , [ ] ) ;
22255: LD_ADDR_EXP 105
22259: PUSH
22260: LD_EXP 105
22264: PPUSH
22265: LD_VAR 0 4
22269: PPUSH
22270: EMPTY
22271: PPUSH
22272: CALL_OW 1
22276: ST_TO_ADDR
// mc_ape_in_lab := Replace ( mc_ape_in_lab , base , [ ] ) ;
22277: LD_ADDR_EXP 106
22281: PUSH
22282: LD_EXP 106
22286: PPUSH
22287: LD_VAR 0 4
22291: PPUSH
22292: EMPTY
22293: PPUSH
22294: CALL_OW 1
22298: ST_TO_ADDR
// mc_taming := Replace ( mc_taming , base , [ ] ) ;
22299: LD_ADDR_EXP 107
22303: PUSH
22304: LD_EXP 107
22308: PPUSH
22309: LD_VAR 0 4
22313: PPUSH
22314: EMPTY
22315: PPUSH
22316: CALL_OW 1
22320: ST_TO_ADDR
// mc_build_upgrade := Replace ( mc_build_upgrade , base , [ ] ) ;
22321: LD_ADDR_EXP 108
22325: PUSH
22326: LD_EXP 108
22330: PPUSH
22331: LD_VAR 0 4
22335: PPUSH
22336: EMPTY
22337: PPUSH
22338: CALL_OW 1
22342: ST_TO_ADDR
// mc_lab := Replace ( mc_lab , base , [ ] ) ;
22343: LD_ADDR_EXP 109
22347: PUSH
22348: LD_EXP 109
22352: PPUSH
22353: LD_VAR 0 4
22357: PPUSH
22358: EMPTY
22359: PPUSH
22360: CALL_OW 1
22364: ST_TO_ADDR
// mc_lab_upgrade := Replace ( mc_lab_upgrade , base , [ ] ) ;
22365: LD_ADDR_EXP 110
22369: PUSH
22370: LD_EXP 110
22374: PPUSH
22375: LD_VAR 0 4
22379: PPUSH
22380: EMPTY
22381: PPUSH
22382: CALL_OW 1
22386: ST_TO_ADDR
// mc_teleport_exit := Replace ( mc_teleport_exit , base , [ ] ) ;
22387: LD_ADDR_EXP 111
22391: PUSH
22392: LD_EXP 111
22396: PPUSH
22397: LD_VAR 0 4
22401: PPUSH
22402: EMPTY
22403: PPUSH
22404: CALL_OW 1
22408: ST_TO_ADDR
// mc_teleport_exit_set := Replace ( mc_teleport_exit_set , base , [ ] ) ;
22409: LD_ADDR_EXP 112
22413: PUSH
22414: LD_EXP 112
22418: PPUSH
22419: LD_VAR 0 4
22423: PPUSH
22424: EMPTY
22425: PPUSH
22426: CALL_OW 1
22430: ST_TO_ADDR
// mc_deposits_xy := Replace ( mc_deposits_xy , base , [ ] ) ;
22431: LD_ADDR_EXP 113
22435: PUSH
22436: LD_EXP 113
22440: PPUSH
22441: LD_VAR 0 4
22445: PPUSH
22446: EMPTY
22447: PPUSH
22448: CALL_OW 1
22452: ST_TO_ADDR
// mc_deposits_finder := Replace ( mc_deposits_finder , base , [ ] ) ;
22453: LD_ADDR_EXP 114
22457: PUSH
22458: LD_EXP 114
22462: PPUSH
22463: LD_VAR 0 4
22467: PPUSH
22468: EMPTY
22469: PPUSH
22470: CALL_OW 1
22474: ST_TO_ADDR
// mc_allowed_tower_weapons := Replace ( mc_allowed_tower_weapons , base , [ ] ) ;
22475: LD_ADDR_EXP 115
22479: PUSH
22480: LD_EXP 115
22484: PPUSH
22485: LD_VAR 0 4
22489: PPUSH
22490: EMPTY
22491: PPUSH
22492: CALL_OW 1
22496: ST_TO_ADDR
// mc_remote_driver := Replace ( mc_remote_driver , base , [ ] ) ;
22497: LD_ADDR_EXP 116
22501: PUSH
22502: LD_EXP 116
22506: PPUSH
22507: LD_VAR 0 4
22511: PPUSH
22512: EMPTY
22513: PPUSH
22514: CALL_OW 1
22518: ST_TO_ADDR
// mc_class := Replace ( mc_class , base , [ ] ) ;
22519: LD_ADDR_EXP 117
22523: PUSH
22524: LD_EXP 117
22528: PPUSH
22529: LD_VAR 0 4
22533: PPUSH
22534: EMPTY
22535: PPUSH
22536: CALL_OW 1
22540: ST_TO_ADDR
// mc_class_case_use := Replace ( mc_class_case_use , base , 0 ) ;
22541: LD_ADDR_EXP 118
22545: PUSH
22546: LD_EXP 118
22550: PPUSH
22551: LD_VAR 0 4
22555: PPUSH
22556: LD_INT 0
22558: PPUSH
22559: CALL_OW 1
22563: ST_TO_ADDR
// result := base ;
22564: LD_ADDR_VAR 0 3
22568: PUSH
22569: LD_VAR 0 4
22573: ST_TO_ADDR
// end ;
22574: LD_VAR 0 3
22578: RET
// export function MC_Start ( ) ; var i ; begin
22579: LD_INT 0
22581: PPUSH
22582: PPUSH
// for i = 1 to mc_bases do
22583: LD_ADDR_VAR 0 2
22587: PUSH
22588: DOUBLE
22589: LD_INT 1
22591: DEC
22592: ST_TO_ADDR
22593: LD_EXP 76
22597: PUSH
22598: FOR_TO
22599: IFFALSE 23676
// begin mc_bases := Replace ( mc_bases , i , mc_bases [ i ] diff 0 ) ;
22601: LD_ADDR_EXP 76
22605: PUSH
22606: LD_EXP 76
22610: PPUSH
22611: LD_VAR 0 2
22615: PPUSH
22616: LD_EXP 76
22620: PUSH
22621: LD_VAR 0 2
22625: ARRAY
22626: PUSH
22627: LD_INT 0
22629: DIFF
22630: PPUSH
22631: CALL_OW 1
22635: ST_TO_ADDR
// mc_building_need_repair := Replace ( mc_building_need_repair , i , [ ] ) ;
22636: LD_ADDR_EXP 77
22640: PUSH
22641: LD_EXP 77
22645: PPUSH
22646: LD_VAR 0 2
22650: PPUSH
22651: EMPTY
22652: PPUSH
22653: CALL_OW 1
22657: ST_TO_ADDR
// mc_building_repairs := Replace ( mc_building_repairs , i , [ ] ) ;
22658: LD_ADDR_EXP 78
22662: PUSH
22663: LD_EXP 78
22667: PPUSH
22668: LD_VAR 0 2
22672: PPUSH
22673: EMPTY
22674: PPUSH
22675: CALL_OW 1
22679: ST_TO_ADDR
// mc_need_heal := Replace ( mc_need_heal , i , [ ] ) ;
22680: LD_ADDR_EXP 79
22684: PUSH
22685: LD_EXP 79
22689: PPUSH
22690: LD_VAR 0 2
22694: PPUSH
22695: EMPTY
22696: PPUSH
22697: CALL_OW 1
22701: ST_TO_ADDR
// mc_healers := Replace ( mc_healers , i , [ [ ] , [ ] ] ) ;
22702: LD_ADDR_EXP 80
22706: PUSH
22707: LD_EXP 80
22711: PPUSH
22712: LD_VAR 0 2
22716: PPUSH
22717: EMPTY
22718: PUSH
22719: EMPTY
22720: PUSH
22721: EMPTY
22722: LIST
22723: LIST
22724: PPUSH
22725: CALL_OW 1
22729: ST_TO_ADDR
// mc_build_list := Replace ( mc_build_list , i , [ ] ) ;
22730: LD_ADDR_EXP 81
22734: PUSH
22735: LD_EXP 81
22739: PPUSH
22740: LD_VAR 0 2
22744: PPUSH
22745: EMPTY
22746: PPUSH
22747: CALL_OW 1
22751: ST_TO_ADDR
// mc_build_upgrade := Replace ( mc_build_upgrade , i , [ ] ) ;
22752: LD_ADDR_EXP 108
22756: PUSH
22757: LD_EXP 108
22761: PPUSH
22762: LD_VAR 0 2
22766: PPUSH
22767: EMPTY
22768: PPUSH
22769: CALL_OW 1
22773: ST_TO_ADDR
// mc_builders := Replace ( mc_builders , i , [ ] ) ;
22774: LD_ADDR_EXP 82
22778: PUSH
22779: LD_EXP 82
22783: PPUSH
22784: LD_VAR 0 2
22788: PPUSH
22789: EMPTY
22790: PPUSH
22791: CALL_OW 1
22795: ST_TO_ADDR
// mc_construct_list := Replace ( mc_construct_list , i , [ ] ) ;
22796: LD_ADDR_EXP 83
22800: PUSH
22801: LD_EXP 83
22805: PPUSH
22806: LD_VAR 0 2
22810: PPUSH
22811: EMPTY
22812: PPUSH
22813: CALL_OW 1
22817: ST_TO_ADDR
// mc_turret_list := Replace ( mc_turret_list , i , UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_bunker ] , [ f_btype , b_turret ] ] ) ) ;
22818: LD_ADDR_EXP 84
22822: PUSH
22823: LD_EXP 84
22827: PPUSH
22828: LD_VAR 0 2
22832: PPUSH
22833: LD_EXP 76
22837: PUSH
22838: LD_VAR 0 2
22842: ARRAY
22843: PPUSH
22844: LD_INT 2
22846: PUSH
22847: LD_INT 30
22849: PUSH
22850: LD_INT 32
22852: PUSH
22853: EMPTY
22854: LIST
22855: LIST
22856: PUSH
22857: LD_INT 30
22859: PUSH
22860: LD_INT 33
22862: PUSH
22863: EMPTY
22864: LIST
22865: LIST
22866: PUSH
22867: EMPTY
22868: LIST
22869: LIST
22870: LIST
22871: PPUSH
22872: CALL_OW 72
22876: PPUSH
22877: CALL_OW 1
22881: ST_TO_ADDR
// mc_empty_turret_list := Replace ( mc_empty_turret_list , i , UnitFilter ( mc_bases [ i ] , [ [ f_or , [ f_btype , b_bunker ] , [ f_btype , b_breastwork ] ] , [ f_empty ] ] ) ) ;
22882: LD_ADDR_EXP 85
22886: PUSH
22887: LD_EXP 85
22891: PPUSH
22892: LD_VAR 0 2
22896: PPUSH
22897: LD_EXP 76
22901: PUSH
22902: LD_VAR 0 2
22906: ARRAY
22907: PPUSH
22908: LD_INT 2
22910: PUSH
22911: LD_INT 30
22913: PUSH
22914: LD_INT 32
22916: PUSH
22917: EMPTY
22918: LIST
22919: LIST
22920: PUSH
22921: LD_INT 30
22923: PUSH
22924: LD_INT 31
22926: PUSH
22927: EMPTY
22928: LIST
22929: LIST
22930: PUSH
22931: EMPTY
22932: LIST
22933: LIST
22934: LIST
22935: PUSH
22936: LD_INT 58
22938: PUSH
22939: EMPTY
22940: LIST
22941: PUSH
22942: EMPTY
22943: LIST
22944: LIST
22945: PPUSH
22946: CALL_OW 72
22950: PPUSH
22951: CALL_OW 1
22955: ST_TO_ADDR
// mc_busy_turret_list := Replace ( mc_busy_turret_list , i , [ ] ) ;
22956: LD_ADDR_EXP 86
22960: PUSH
22961: LD_EXP 86
22965: PPUSH
22966: LD_VAR 0 2
22970: PPUSH
22971: EMPTY
22972: PPUSH
22973: CALL_OW 1
22977: ST_TO_ADDR
// mc_miners := Replace ( mc_miners , i , [ ] ) ;
22978: LD_ADDR_EXP 90
22982: PUSH
22983: LD_EXP 90
22987: PPUSH
22988: LD_VAR 0 2
22992: PPUSH
22993: EMPTY
22994: PPUSH
22995: CALL_OW 1
22999: ST_TO_ADDR
// mc_mines := Replace ( mc_mines , i , [ ] ) ;
23000: LD_ADDR_EXP 89
23004: PUSH
23005: LD_EXP 89
23009: PPUSH
23010: LD_VAR 0 2
23014: PPUSH
23015: EMPTY
23016: PPUSH
23017: CALL_OW 1
23021: ST_TO_ADDR
// mc_minefields := Replace ( mc_minefields , i , [ ] ) ;
23022: LD_ADDR_EXP 91
23026: PUSH
23027: LD_EXP 91
23031: PPUSH
23032: LD_VAR 0 2
23036: PPUSH
23037: EMPTY
23038: PPUSH
23039: CALL_OW 1
23043: ST_TO_ADDR
// mc_crates := Replace ( mc_crates , i , [ ] ) ;
23044: LD_ADDR_EXP 92
23048: PUSH
23049: LD_EXP 92
23053: PPUSH
23054: LD_VAR 0 2
23058: PPUSH
23059: EMPTY
23060: PPUSH
23061: CALL_OW 1
23065: ST_TO_ADDR
// mc_crates_collector := Replace ( mc_crates_collector , i , [ ] ) ;
23066: LD_ADDR_EXP 93
23070: PUSH
23071: LD_EXP 93
23075: PPUSH
23076: LD_VAR 0 2
23080: PPUSH
23081: EMPTY
23082: PPUSH
23083: CALL_OW 1
23087: ST_TO_ADDR
// mc_crates_area := Replace ( mc_crates_area , i , [ ] ) ;
23088: LD_ADDR_EXP 94
23092: PUSH
23093: LD_EXP 94
23097: PPUSH
23098: LD_VAR 0 2
23102: PPUSH
23103: EMPTY
23104: PPUSH
23105: CALL_OW 1
23109: ST_TO_ADDR
// mc_vehicles := Replace ( mc_vehicles , i , [ ] ) ;
23110: LD_ADDR_EXP 95
23114: PUSH
23115: LD_EXP 95
23119: PPUSH
23120: LD_VAR 0 2
23124: PPUSH
23125: EMPTY
23126: PPUSH
23127: CALL_OW 1
23131: ST_TO_ADDR
// mc_attack := Replace ( mc_attack , i , [ ] ) ;
23132: LD_ADDR_EXP 96
23136: PUSH
23137: LD_EXP 96
23141: PPUSH
23142: LD_VAR 0 2
23146: PPUSH
23147: EMPTY
23148: PPUSH
23149: CALL_OW 1
23153: ST_TO_ADDR
// mc_produce := Replace ( mc_produce , i , [ ] ) ;
23154: LD_ADDR_EXP 97
23158: PUSH
23159: LD_EXP 97
23163: PPUSH
23164: LD_VAR 0 2
23168: PPUSH
23169: EMPTY
23170: PPUSH
23171: CALL_OW 1
23175: ST_TO_ADDR
// mc_defender := Replace ( mc_defender , i , [ ] ) ;
23176: LD_ADDR_EXP 98
23180: PUSH
23181: LD_EXP 98
23185: PPUSH
23186: LD_VAR 0 2
23190: PPUSH
23191: EMPTY
23192: PPUSH
23193: CALL_OW 1
23197: ST_TO_ADDR
// mc_defender_limit := Replace ( mc_defender_limit , i , 0 ) ;
23198: LD_ADDR_EXP 87
23202: PUSH
23203: LD_EXP 87
23207: PPUSH
23208: LD_VAR 0 2
23212: PPUSH
23213: LD_INT 0
23215: PPUSH
23216: CALL_OW 1
23220: ST_TO_ADDR
// mc_parking := Replace ( mc_parking , i , 0 ) ;
23221: LD_ADDR_EXP 100
23225: PUSH
23226: LD_EXP 100
23230: PPUSH
23231: LD_VAR 0 2
23235: PPUSH
23236: LD_INT 0
23238: PPUSH
23239: CALL_OW 1
23243: ST_TO_ADDR
// mc_repair_vehicle := Replace ( mc_repair_vehicle , i , [ ] ) ;
23244: LD_ADDR_EXP 88
23248: PUSH
23249: LD_EXP 88
23253: PPUSH
23254: LD_VAR 0 2
23258: PPUSH
23259: EMPTY
23260: PPUSH
23261: CALL_OW 1
23265: ST_TO_ADDR
// mc_scan := Replace ( mc_scan , i , 0 ) ;
23266: LD_ADDR_EXP 99
23270: PUSH
23271: LD_EXP 99
23275: PPUSH
23276: LD_VAR 0 2
23280: PPUSH
23281: LD_INT 0
23283: PPUSH
23284: CALL_OW 1
23288: ST_TO_ADDR
// mc_scan_area := Replace ( mc_scan_area , i , [ ] ) ;
23289: LD_ADDR_EXP 101
23293: PUSH
23294: LD_EXP 101
23298: PPUSH
23299: LD_VAR 0 2
23303: PPUSH
23304: EMPTY
23305: PPUSH
23306: CALL_OW 1
23310: ST_TO_ADDR
// mc_can_tame := Replace ( mc_can_tame , i , 0 ) ;
23311: LD_ADDR_EXP 104
23315: PUSH
23316: LD_EXP 104
23320: PPUSH
23321: LD_VAR 0 2
23325: PPUSH
23326: LD_INT 0
23328: PPUSH
23329: CALL_OW 1
23333: ST_TO_ADDR
// mc_ape := Replace ( mc_ape , i , [ ] ) ;
23334: LD_ADDR_EXP 105
23338: PUSH
23339: LD_EXP 105
23343: PPUSH
23344: LD_VAR 0 2
23348: PPUSH
23349: EMPTY
23350: PPUSH
23351: CALL_OW 1
23355: ST_TO_ADDR
// mc_ape_in_lab := Replace ( mc_ape_in_lab , i , [ ] ) ;
23356: LD_ADDR_EXP 106
23360: PUSH
23361: LD_EXP 106
23365: PPUSH
23366: LD_VAR 0 2
23370: PPUSH
23371: EMPTY
23372: PPUSH
23373: CALL_OW 1
23377: ST_TO_ADDR
// mc_taming := Replace ( mc_taming , i , [ ] ) ;
23378: LD_ADDR_EXP 107
23382: PUSH
23383: LD_EXP 107
23387: PPUSH
23388: LD_VAR 0 2
23392: PPUSH
23393: EMPTY
23394: PPUSH
23395: CALL_OW 1
23399: ST_TO_ADDR
// mc_lab := Replace ( mc_lab , i , UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_lab ] , [ f_btype , b_lab_half ] , [ f_btype , b_lab_full ] ] ) ) ;
23400: LD_ADDR_EXP 109
23404: PUSH
23405: LD_EXP 109
23409: PPUSH
23410: LD_VAR 0 2
23414: PPUSH
23415: LD_EXP 76
23419: PUSH
23420: LD_VAR 0 2
23424: ARRAY
23425: PPUSH
23426: LD_INT 2
23428: PUSH
23429: LD_INT 30
23431: PUSH
23432: LD_INT 6
23434: PUSH
23435: EMPTY
23436: LIST
23437: LIST
23438: PUSH
23439: LD_INT 30
23441: PUSH
23442: LD_INT 7
23444: PUSH
23445: EMPTY
23446: LIST
23447: LIST
23448: PUSH
23449: LD_INT 30
23451: PUSH
23452: LD_INT 8
23454: PUSH
23455: EMPTY
23456: LIST
23457: LIST
23458: PUSH
23459: EMPTY
23460: LIST
23461: LIST
23462: LIST
23463: LIST
23464: PPUSH
23465: CALL_OW 72
23469: PPUSH
23470: CALL_OW 1
23474: ST_TO_ADDR
// mc_lab_upgrade := Replace ( mc_lab_upgrade , i , [ ] ) ;
23475: LD_ADDR_EXP 110
23479: PUSH
23480: LD_EXP 110
23484: PPUSH
23485: LD_VAR 0 2
23489: PPUSH
23490: EMPTY
23491: PPUSH
23492: CALL_OW 1
23496: ST_TO_ADDR
// mc_teleport_exit := Replace ( mc_teleport_exit , i , [ ] ) ;
23497: LD_ADDR_EXP 111
23501: PUSH
23502: LD_EXP 111
23506: PPUSH
23507: LD_VAR 0 2
23511: PPUSH
23512: EMPTY
23513: PPUSH
23514: CALL_OW 1
23518: ST_TO_ADDR
// mc_teleport_exit_set := Replace ( mc_teleport_exit_set , i , [ ] ) ;
23519: LD_ADDR_EXP 112
23523: PUSH
23524: LD_EXP 112
23528: PPUSH
23529: LD_VAR 0 2
23533: PPUSH
23534: EMPTY
23535: PPUSH
23536: CALL_OW 1
23540: ST_TO_ADDR
// mc_deposits_xy := Replace ( mc_deposits_xy , i , [ ] ) ;
23541: LD_ADDR_EXP 113
23545: PUSH
23546: LD_EXP 113
23550: PPUSH
23551: LD_VAR 0 2
23555: PPUSH
23556: EMPTY
23557: PPUSH
23558: CALL_OW 1
23562: ST_TO_ADDR
// mc_deposits_finder := Replace ( mc_deposits_finder , i , [ ] ) ;
23563: LD_ADDR_EXP 114
23567: PUSH
23568: LD_EXP 114
23572: PPUSH
23573: LD_VAR 0 2
23577: PPUSH
23578: EMPTY
23579: PPUSH
23580: CALL_OW 1
23584: ST_TO_ADDR
// mc_allowed_tower_weapons := Replace ( mc_allowed_tower_weapons , i , [ ] ) ;
23585: LD_ADDR_EXP 115
23589: PUSH
23590: LD_EXP 115
23594: PPUSH
23595: LD_VAR 0 2
23599: PPUSH
23600: EMPTY
23601: PPUSH
23602: CALL_OW 1
23606: ST_TO_ADDR
// mc_remote_driver := Replace ( mc_remote_driver , i , [ ] ) ;
23607: LD_ADDR_EXP 116
23611: PUSH
23612: LD_EXP 116
23616: PPUSH
23617: LD_VAR 0 2
23621: PPUSH
23622: EMPTY
23623: PPUSH
23624: CALL_OW 1
23628: ST_TO_ADDR
// mc_class := Replace ( mc_class , i , [ ] ) ;
23629: LD_ADDR_EXP 117
23633: PUSH
23634: LD_EXP 117
23638: PPUSH
23639: LD_VAR 0 2
23643: PPUSH
23644: EMPTY
23645: PPUSH
23646: CALL_OW 1
23650: ST_TO_ADDR
// mc_class_case_use := Replace ( mc_class_case_use , i , 0 ) ;
23651: LD_ADDR_EXP 118
23655: PUSH
23656: LD_EXP 118
23660: PPUSH
23661: LD_VAR 0 2
23665: PPUSH
23666: LD_INT 0
23668: PPUSH
23669: CALL_OW 1
23673: ST_TO_ADDR
// end ;
23674: GO 22598
23676: POP
23677: POP
// MC_InitSides ( ) ;
23678: CALL 23964 0 0
// MC_InitResearch ( ) ;
23682: CALL 23703 0 0
// CustomInitMacro ( ) ;
23686: CALL 189 0 0
// skirmish := true ;
23690: LD_ADDR_EXP 74
23694: PUSH
23695: LD_INT 1
23697: ST_TO_ADDR
// end ;
23698: LD_VAR 0 1
23702: RET
// export function MC_InitResearch ( ) ; var i , j , nation , tmp , un ; begin
23703: LD_INT 0
23705: PPUSH
23706: PPUSH
23707: PPUSH
23708: PPUSH
23709: PPUSH
23710: PPUSH
// if not mc_bases then
23711: LD_EXP 76
23715: NOT
23716: IFFALSE 23720
// exit ;
23718: GO 23959
// for i = 1 to 8 do
23720: LD_ADDR_VAR 0 2
23724: PUSH
23725: DOUBLE
23726: LD_INT 1
23728: DEC
23729: ST_TO_ADDR
23730: LD_INT 8
23732: PUSH
23733: FOR_TO
23734: IFFALSE 23760
// mc_tech := Replace ( mc_tech , i , [ ] ) ;
23736: LD_ADDR_EXP 103
23740: PUSH
23741: LD_EXP 103
23745: PPUSH
23746: LD_VAR 0 2
23750: PPUSH
23751: EMPTY
23752: PPUSH
23753: CALL_OW 1
23757: ST_TO_ADDR
23758: GO 23733
23760: POP
23761: POP
// tmp := [ ] ;
23762: LD_ADDR_VAR 0 5
23766: PUSH
23767: EMPTY
23768: ST_TO_ADDR
// for i = 1 to mc_sides do
23769: LD_ADDR_VAR 0 2
23773: PUSH
23774: DOUBLE
23775: LD_INT 1
23777: DEC
23778: ST_TO_ADDR
23779: LD_EXP 102
23783: PUSH
23784: FOR_TO
23785: IFFALSE 23843
// if not mc_sides [ i ] in tmp then
23787: LD_EXP 102
23791: PUSH
23792: LD_VAR 0 2
23796: ARRAY
23797: PUSH
23798: LD_VAR 0 5
23802: IN
23803: NOT
23804: IFFALSE 23841
// tmp := Insert ( tmp , tmp + 1 , mc_sides [ i ] ) ;
23806: LD_ADDR_VAR 0 5
23810: PUSH
23811: LD_VAR 0 5
23815: PPUSH
23816: LD_VAR 0 5
23820: PUSH
23821: LD_INT 1
23823: PLUS
23824: PPUSH
23825: LD_EXP 102
23829: PUSH
23830: LD_VAR 0 2
23834: ARRAY
23835: PPUSH
23836: CALL_OW 2
23840: ST_TO_ADDR
23841: GO 23784
23843: POP
23844: POP
// if not tmp then
23845: LD_VAR 0 5
23849: NOT
23850: IFFALSE 23854
// exit ;
23852: GO 23959
// for j in tmp do
23854: LD_ADDR_VAR 0 3
23858: PUSH
23859: LD_VAR 0 5
23863: PUSH
23864: FOR_IN
23865: IFFALSE 23957
// begin un := FilterAllUnits ( [ f_side , j ] ) ;
23867: LD_ADDR_VAR 0 6
23871: PUSH
23872: LD_INT 22
23874: PUSH
23875: LD_VAR 0 3
23879: PUSH
23880: EMPTY
23881: LIST
23882: LIST
23883: PPUSH
23884: CALL_OW 69
23888: ST_TO_ADDR
// if not un then
23889: LD_VAR 0 6
23893: NOT
23894: IFFALSE 23898
// continue ;
23896: GO 23864
// nation := GetNation ( un [ 1 ] ) ;
23898: LD_ADDR_VAR 0 4
23902: PUSH
23903: LD_VAR 0 6
23907: PUSH
23908: LD_INT 1
23910: ARRAY
23911: PPUSH
23912: CALL_OW 248
23916: ST_TO_ADDR
// mc_tech := Replace ( mc_tech , j , GetTechNation ( j , nation , state_enabled ) ) ;
23917: LD_ADDR_EXP 103
23921: PUSH
23922: LD_EXP 103
23926: PPUSH
23927: LD_VAR 0 3
23931: PPUSH
23932: LD_VAR 0 3
23936: PPUSH
23937: LD_VAR 0 4
23941: PPUSH
23942: LD_INT 1
23944: PPUSH
23945: CALL 50569 0 3
23949: PPUSH
23950: CALL_OW 1
23954: ST_TO_ADDR
// end ;
23955: GO 23864
23957: POP
23958: POP
// end ;
23959: LD_VAR 0 1
23963: RET
// export function MC_InitSides ( ) ; var i ; begin
23964: LD_INT 0
23966: PPUSH
23967: PPUSH
// if not mc_bases then
23968: LD_EXP 76
23972: NOT
23973: IFFALSE 23977
// exit ;
23975: GO 24051
// for i = 1 to mc_bases do
23977: LD_ADDR_VAR 0 2
23981: PUSH
23982: DOUBLE
23983: LD_INT 1
23985: DEC
23986: ST_TO_ADDR
23987: LD_EXP 76
23991: PUSH
23992: FOR_TO
23993: IFFALSE 24049
// if mc_bases [ i ] then
23995: LD_EXP 76
23999: PUSH
24000: LD_VAR 0 2
24004: ARRAY
24005: IFFALSE 24047
// mc_sides := Replace ( mc_sides , i , GetSide ( mc_bases [ i ] [ 1 ] ) ) ;
24007: LD_ADDR_EXP 102
24011: PUSH
24012: LD_EXP 102
24016: PPUSH
24017: LD_VAR 0 2
24021: PPUSH
24022: LD_EXP 76
24026: PUSH
24027: LD_VAR 0 2
24031: ARRAY
24032: PUSH
24033: LD_INT 1
24035: ARRAY
24036: PPUSH
24037: CALL_OW 255
24041: PPUSH
24042: CALL_OW 1
24046: ST_TO_ADDR
24047: GO 23992
24049: POP
24050: POP
// end ;
24051: LD_VAR 0 1
24055: RET
// every 0 0$01 trigger skirmish do
24056: LD_EXP 74
24060: IFFALSE 24214
24062: GO 24064
24064: DISABLE
// begin enable ;
24065: ENABLE
// MC_CheckBuildings ( ) ;
24066: CALL 28712 0 0
// MC_CheckPeopleLife ( ) ;
24070: CALL 28837 0 0
// RaiseSailEvent ( 100 ) ;
24074: LD_INT 100
24076: PPUSH
24077: CALL_OW 427
// RaiseSailEvent ( 103 ) ;
24081: LD_INT 103
24083: PPUSH
24084: CALL_OW 427
// RaiseSailEvent ( 104 ) ;
24088: LD_INT 104
24090: PPUSH
24091: CALL_OW 427
// RaiseSailEvent ( 105 ) ;
24095: LD_INT 105
24097: PPUSH
24098: CALL_OW 427
// RaiseSailEvent ( 106 ) ;
24102: LD_INT 106
24104: PPUSH
24105: CALL_OW 427
// RaiseSailEvent ( 107 ) ;
24109: LD_INT 107
24111: PPUSH
24112: CALL_OW 427
// RaiseSailEvent ( 108 ) ;
24116: LD_INT 108
24118: PPUSH
24119: CALL_OW 427
// RaiseSailEvent ( 109 ) ;
24123: LD_INT 109
24125: PPUSH
24126: CALL_OW 427
// RaiseSailEvent ( 110 ) ;
24130: LD_INT 110
24132: PPUSH
24133: CALL_OW 427
// RaiseSailEvent ( 111 ) ;
24137: LD_INT 111
24139: PPUSH
24140: CALL_OW 427
// RaiseSailEvent ( 112 ) ;
24144: LD_INT 112
24146: PPUSH
24147: CALL_OW 427
// RaiseSailEvent ( 113 ) ;
24151: LD_INT 113
24153: PPUSH
24154: CALL_OW 427
// RaiseSailEvent ( 120 ) ;
24158: LD_INT 120
24160: PPUSH
24161: CALL_OW 427
// RaiseSailEvent ( 121 ) ;
24165: LD_INT 121
24167: PPUSH
24168: CALL_OW 427
// RaiseSailEvent ( 122 ) ;
24172: LD_INT 122
24174: PPUSH
24175: CALL_OW 427
// RaiseSailEvent ( 123 ) ;
24179: LD_INT 123
24181: PPUSH
24182: CALL_OW 427
// RaiseSailEvent ( 124 ) ;
24186: LD_INT 124
24188: PPUSH
24189: CALL_OW 427
// RaiseSailEvent ( 125 ) ;
24193: LD_INT 125
24195: PPUSH
24196: CALL_OW 427
// RaiseSailEvent ( 126 ) ;
24200: LD_INT 126
24202: PPUSH
24203: CALL_OW 427
// RaiseSailEvent ( 200 ) ;
24207: LD_INT 200
24209: PPUSH
24210: CALL_OW 427
// end ;
24214: END
// on SailEvent ( event ) do begin if event < 100 then
24215: LD_VAR 0 1
24219: PUSH
24220: LD_INT 100
24222: LESS
24223: IFFALSE 24234
// CustomEvent ( event ) ;
24225: LD_VAR 0 1
24229: PPUSH
24230: CALL 10347 0 1
// if event = 100 then
24234: LD_VAR 0 1
24238: PUSH
24239: LD_INT 100
24241: EQUAL
24242: IFFALSE 24248
// MC_ClassManager ( ) ;
24244: CALL 24640 0 0
// if event = 101 then
24248: LD_VAR 0 1
24252: PUSH
24253: LD_INT 101
24255: EQUAL
24256: IFFALSE 24262
// MC_RepairBuildings ( ) ;
24258: CALL 29433 0 0
// if event = 102 then
24262: LD_VAR 0 1
24266: PUSH
24267: LD_INT 102
24269: EQUAL
24270: IFFALSE 24276
// MC_Heal ( ) ;
24272: CALL 30297 0 0
// if event = 103 then
24276: LD_VAR 0 1
24280: PUSH
24281: LD_INT 103
24283: EQUAL
24284: IFFALSE 24290
// MC_Build ( ) ;
24286: CALL 30719 0 0
// if event = 104 then
24290: LD_VAR 0 1
24294: PUSH
24295: LD_INT 104
24297: EQUAL
24298: IFFALSE 24304
// MC_TurretWeapon ( ) ;
24300: CALL 32332 0 0
// if event = 105 then
24304: LD_VAR 0 1
24308: PUSH
24309: LD_INT 105
24311: EQUAL
24312: IFFALSE 24318
// MC_BuildUpgrade ( ) ;
24314: CALL 31883 0 0
// if event = 106 then
24318: LD_VAR 0 1
24322: PUSH
24323: LD_INT 106
24325: EQUAL
24326: IFFALSE 24332
// MC_PlantMines ( ) ;
24328: CALL 32762 0 0
// if event = 107 then
24332: LD_VAR 0 1
24336: PUSH
24337: LD_INT 107
24339: EQUAL
24340: IFFALSE 24346
// MC_CollectCrates ( ) ;
24342: CALL 33560 0 0
// if event = 108 then
24346: LD_VAR 0 1
24350: PUSH
24351: LD_INT 108
24353: EQUAL
24354: IFFALSE 24360
// MC_LinkRemoteControl ( ) ;
24356: CALL 35336 0 0
// if event = 109 then
24360: LD_VAR 0 1
24364: PUSH
24365: LD_INT 109
24367: EQUAL
24368: IFFALSE 24374
// MC_ProduceVehicle ( ) ;
24370: CALL 35517 0 0
// if event = 110 then
24374: LD_VAR 0 1
24378: PUSH
24379: LD_INT 110
24381: EQUAL
24382: IFFALSE 24388
// MC_SendAttack ( ) ;
24384: CALL 35983 0 0
// if event = 111 then
24388: LD_VAR 0 1
24392: PUSH
24393: LD_INT 111
24395: EQUAL
24396: IFFALSE 24402
// MC_Defend ( ) ;
24398: CALL 36091 0 0
// if event = 112 then
24402: LD_VAR 0 1
24406: PUSH
24407: LD_INT 112
24409: EQUAL
24410: IFFALSE 24416
// MC_Research ( ) ;
24412: CALL 36696 0 0
// if event = 113 then
24416: LD_VAR 0 1
24420: PUSH
24421: LD_INT 113
24423: EQUAL
24424: IFFALSE 24430
// MC_MinesTrigger ( ) ;
24426: CALL 37810 0 0
// if event = 120 then
24430: LD_VAR 0 1
24434: PUSH
24435: LD_INT 120
24437: EQUAL
24438: IFFALSE 24444
// MC_RepairVehicle ( ) ;
24440: CALL 37909 0 0
// if event = 121 then
24444: LD_VAR 0 1
24448: PUSH
24449: LD_INT 121
24451: EQUAL
24452: IFFALSE 24458
// MC_TameApe ( ) ;
24454: CALL 38639 0 0
// if event = 122 then
24458: LD_VAR 0 1
24462: PUSH
24463: LD_INT 122
24465: EQUAL
24466: IFFALSE 24472
// MC_ChangeApeClass ( ) ;
24468: CALL 39468 0 0
// if event = 123 then
24472: LD_VAR 0 1
24476: PUSH
24477: LD_INT 123
24479: EQUAL
24480: IFFALSE 24486
// MC_Bazooka ( ) ;
24482: CALL 40118 0 0
// if event = 124 then
24486: LD_VAR 0 1
24490: PUSH
24491: LD_INT 124
24493: EQUAL
24494: IFFALSE 24500
// MC_TeleportExit ( ) ;
24496: CALL 40316 0 0
// if event = 125 then
24500: LD_VAR 0 1
24504: PUSH
24505: LD_INT 125
24507: EQUAL
24508: IFFALSE 24514
// MC_Deposits ( ) ;
24510: CALL 40963 0 0
// if event = 126 then
24514: LD_VAR 0 1
24518: PUSH
24519: LD_INT 126
24521: EQUAL
24522: IFFALSE 24528
// MC_RemoteDriver ( ) ;
24524: CALL 41588 0 0
// if event = 200 then
24528: LD_VAR 0 1
24532: PUSH
24533: LD_INT 200
24535: EQUAL
24536: IFFALSE 24542
// MC_Idle ( ) ;
24538: CALL 43537 0 0
// end ;
24542: PPOPN 1
24544: END
// export function MC_Reset ( base , tag ) ; var i ; begin
24545: LD_INT 0
24547: PPUSH
24548: PPUSH
// if not mc_bases [ base ] or not tag then
24549: LD_EXP 76
24553: PUSH
24554: LD_VAR 0 1
24558: ARRAY
24559: NOT
24560: PUSH
24561: LD_VAR 0 2
24565: NOT
24566: OR
24567: IFFALSE 24571
// exit ;
24569: GO 24635
// for i in mc_bases [ base ] union mc_ape [ base ] do
24571: LD_ADDR_VAR 0 4
24575: PUSH
24576: LD_EXP 76
24580: PUSH
24581: LD_VAR 0 1
24585: ARRAY
24586: PUSH
24587: LD_EXP 105
24591: PUSH
24592: LD_VAR 0 1
24596: ARRAY
24597: UNION
24598: PUSH
24599: FOR_IN
24600: IFFALSE 24633
// if GetTag ( i ) = tag then
24602: LD_VAR 0 4
24606: PPUSH
24607: CALL_OW 110
24611: PUSH
24612: LD_VAR 0 2
24616: EQUAL
24617: IFFALSE 24631
// SetTag ( i , 0 ) ;
24619: LD_VAR 0 4
24623: PPUSH
24624: LD_INT 0
24626: PPUSH
24627: CALL_OW 109
24631: GO 24599
24633: POP
24634: POP
// end ;
24635: LD_VAR 0 3
24639: RET
// export function MC_ClassManager ( ) ; var i , j , tmp , p , b , e , k ; begin
24640: LD_INT 0
24642: PPUSH
24643: PPUSH
24644: PPUSH
24645: PPUSH
24646: PPUSH
24647: PPUSH
24648: PPUSH
24649: PPUSH
// if not mc_bases then
24650: LD_EXP 76
24654: NOT
24655: IFFALSE 24659
// exit ;
24657: GO 25117
// for i = 1 to mc_bases do
24659: LD_ADDR_VAR 0 2
24663: PUSH
24664: DOUBLE
24665: LD_INT 1
24667: DEC
24668: ST_TO_ADDR
24669: LD_EXP 76
24673: PUSH
24674: FOR_TO
24675: IFFALSE 25115
// begin tmp := MC_ClassCheckReq ( i ) ;
24677: LD_ADDR_VAR 0 4
24681: PUSH
24682: LD_VAR 0 2
24686: PPUSH
24687: CALL 25122 0 1
24691: ST_TO_ADDR
// mc_class := Replace ( mc_class , i , tmp ) ;
24692: LD_ADDR_EXP 117
24696: PUSH
24697: LD_EXP 117
24701: PPUSH
24702: LD_VAR 0 2
24706: PPUSH
24707: LD_VAR 0 4
24711: PPUSH
24712: CALL_OW 1
24716: ST_TO_ADDR
// if not tmp then
24717: LD_VAR 0 4
24721: NOT
24722: IFFALSE 24726
// continue ;
24724: GO 24674
// b := [ UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_armoury ] , [ f_btype , b_barracks ] ] ) , UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) , UnitFilter ( mc_bases [ i ] , [ f_btype , b_factory ] ) , UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_lab ] , [ f_btype , b_lab_half ] , [ f_btype , b_lab_full ] ] ) ] ;
24726: LD_ADDR_VAR 0 6
24730: PUSH
24731: LD_EXP 76
24735: PUSH
24736: LD_VAR 0 2
24740: ARRAY
24741: PPUSH
24742: LD_INT 2
24744: PUSH
24745: LD_INT 30
24747: PUSH
24748: LD_INT 4
24750: PUSH
24751: EMPTY
24752: LIST
24753: LIST
24754: PUSH
24755: LD_INT 30
24757: PUSH
24758: LD_INT 5
24760: PUSH
24761: EMPTY
24762: LIST
24763: LIST
24764: PUSH
24765: EMPTY
24766: LIST
24767: LIST
24768: LIST
24769: PPUSH
24770: CALL_OW 72
24774: PUSH
24775: LD_EXP 76
24779: PUSH
24780: LD_VAR 0 2
24784: ARRAY
24785: PPUSH
24786: LD_INT 2
24788: PUSH
24789: LD_INT 30
24791: PUSH
24792: LD_INT 0
24794: PUSH
24795: EMPTY
24796: LIST
24797: LIST
24798: PUSH
24799: LD_INT 30
24801: PUSH
24802: LD_INT 1
24804: PUSH
24805: EMPTY
24806: LIST
24807: LIST
24808: PUSH
24809: EMPTY
24810: LIST
24811: LIST
24812: LIST
24813: PPUSH
24814: CALL_OW 72
24818: PUSH
24819: LD_EXP 76
24823: PUSH
24824: LD_VAR 0 2
24828: ARRAY
24829: PPUSH
24830: LD_INT 30
24832: PUSH
24833: LD_INT 3
24835: PUSH
24836: EMPTY
24837: LIST
24838: LIST
24839: PPUSH
24840: CALL_OW 72
24844: PUSH
24845: LD_EXP 76
24849: PUSH
24850: LD_VAR 0 2
24854: ARRAY
24855: PPUSH
24856: LD_INT 2
24858: PUSH
24859: LD_INT 30
24861: PUSH
24862: LD_INT 6
24864: PUSH
24865: EMPTY
24866: LIST
24867: LIST
24868: PUSH
24869: LD_INT 30
24871: PUSH
24872: LD_INT 7
24874: PUSH
24875: EMPTY
24876: LIST
24877: LIST
24878: PUSH
24879: LD_INT 30
24881: PUSH
24882: LD_INT 8
24884: PUSH
24885: EMPTY
24886: LIST
24887: LIST
24888: PUSH
24889: EMPTY
24890: LIST
24891: LIST
24892: LIST
24893: LIST
24894: PPUSH
24895: CALL_OW 72
24899: PUSH
24900: EMPTY
24901: LIST
24902: LIST
24903: LIST
24904: LIST
24905: ST_TO_ADDR
// for j = 1 to 4 do
24906: LD_ADDR_VAR 0 3
24910: PUSH
24911: DOUBLE
24912: LD_INT 1
24914: DEC
24915: ST_TO_ADDR
24916: LD_INT 4
24918: PUSH
24919: FOR_TO
24920: IFFALSE 25111
// begin if not tmp [ j ] then
24922: LD_VAR 0 4
24926: PUSH
24927: LD_VAR 0 3
24931: ARRAY
24932: NOT
24933: IFFALSE 24937
// continue ;
24935: GO 24919
// for p in tmp [ j ] do
24937: LD_ADDR_VAR 0 5
24941: PUSH
24942: LD_VAR 0 4
24946: PUSH
24947: LD_VAR 0 3
24951: ARRAY
24952: PUSH
24953: FOR_IN
24954: IFFALSE 25107
// begin if not b [ j ] then
24956: LD_VAR 0 6
24960: PUSH
24961: LD_VAR 0 3
24965: ARRAY
24966: NOT
24967: IFFALSE 24971
// break ;
24969: GO 25107
// e := 0 ;
24971: LD_ADDR_VAR 0 7
24975: PUSH
24976: LD_INT 0
24978: ST_TO_ADDR
// for k in b [ j ] do
24979: LD_ADDR_VAR 0 8
24983: PUSH
24984: LD_VAR 0 6
24988: PUSH
24989: LD_VAR 0 3
24993: ARRAY
24994: PUSH
24995: FOR_IN
24996: IFFALSE 25023
// if IsNotFull ( k ) then
24998: LD_VAR 0 8
25002: PPUSH
25003: CALL 55009 0 1
25007: IFFALSE 25021
// begin e := k ;
25009: LD_ADDR_VAR 0 7
25013: PUSH
25014: LD_VAR 0 8
25018: ST_TO_ADDR
// break ;
25019: GO 25023
// end ;
25021: GO 24995
25023: POP
25024: POP
// if e and not UnitGoingToBuilding ( p , e ) then
25025: LD_VAR 0 7
25029: PUSH
25030: LD_VAR 0 5
25034: PPUSH
25035: LD_VAR 0 7
25039: PPUSH
25040: CALL 92131 0 2
25044: NOT
25045: AND
25046: IFFALSE 25105
// begin if IsInUnit ( p ) then
25048: LD_VAR 0 5
25052: PPUSH
25053: CALL_OW 310
25057: IFFALSE 25068
// ComExitBuilding ( p ) ;
25059: LD_VAR 0 5
25063: PPUSH
25064: CALL_OW 122
// ComEnterUnit ( p , e ) ;
25068: LD_VAR 0 5
25072: PPUSH
25073: LD_VAR 0 7
25077: PPUSH
25078: CALL_OW 120
// AddComChangeProfession ( p , j ) ;
25082: LD_VAR 0 5
25086: PPUSH
25087: LD_VAR 0 3
25091: PPUSH
25092: CALL_OW 183
// AddComExitBuilding ( p ) ;
25096: LD_VAR 0 5
25100: PPUSH
25101: CALL_OW 182
// end ; end ;
25105: GO 24953
25107: POP
25108: POP
// end ;
25109: GO 24919
25111: POP
25112: POP
// end ;
25113: GO 24674
25115: POP
25116: POP
// end ;
25117: LD_VAR 0 1
25121: RET
// export function MC_ClassCheckReq ( base ) ; var i , tmp , sol , eng , mech , sci , sort , j , p , b , bcount ; begin
25122: LD_INT 0
25124: PPUSH
25125: PPUSH
25126: PPUSH
25127: PPUSH
25128: PPUSH
25129: PPUSH
25130: PPUSH
25131: PPUSH
25132: PPUSH
25133: PPUSH
25134: PPUSH
25135: PPUSH
// if not base or not mc_bases [ base ] or not UnitFilter ( mc_bases [ base ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) then
25136: LD_VAR 0 1
25140: NOT
25141: PUSH
25142: LD_EXP 76
25146: PUSH
25147: LD_VAR 0 1
25151: ARRAY
25152: NOT
25153: OR
25154: PUSH
25155: LD_EXP 76
25159: PUSH
25160: LD_VAR 0 1
25164: ARRAY
25165: PPUSH
25166: LD_INT 2
25168: PUSH
25169: LD_INT 30
25171: PUSH
25172: LD_INT 0
25174: PUSH
25175: EMPTY
25176: LIST
25177: LIST
25178: PUSH
25179: LD_INT 30
25181: PUSH
25182: LD_INT 1
25184: PUSH
25185: EMPTY
25186: LIST
25187: LIST
25188: PUSH
25189: EMPTY
25190: LIST
25191: LIST
25192: LIST
25193: PPUSH
25194: CALL_OW 72
25198: NOT
25199: OR
25200: IFFALSE 25204
// exit ;
25202: GO 28707
// tmp := UnitFilter ( mc_bases [ base ] , [ f_or , [ f_class , 1 ] , [ f_class , 2 ] , [ f_class , 3 ] , [ f_class , 4 ] , [ f_class , 5 ] , [ f_class , 8 ] , [ f_class , 9 ] ] ) ;
25204: LD_ADDR_VAR 0 4
25208: PUSH
25209: LD_EXP 76
25213: PUSH
25214: LD_VAR 0 1
25218: ARRAY
25219: PPUSH
25220: LD_INT 2
25222: PUSH
25223: LD_INT 25
25225: PUSH
25226: LD_INT 1
25228: PUSH
25229: EMPTY
25230: LIST
25231: LIST
25232: PUSH
25233: LD_INT 25
25235: PUSH
25236: LD_INT 2
25238: PUSH
25239: EMPTY
25240: LIST
25241: LIST
25242: PUSH
25243: LD_INT 25
25245: PUSH
25246: LD_INT 3
25248: PUSH
25249: EMPTY
25250: LIST
25251: LIST
25252: PUSH
25253: LD_INT 25
25255: PUSH
25256: LD_INT 4
25258: PUSH
25259: EMPTY
25260: LIST
25261: LIST
25262: PUSH
25263: LD_INT 25
25265: PUSH
25266: LD_INT 5
25268: PUSH
25269: EMPTY
25270: LIST
25271: LIST
25272: PUSH
25273: LD_INT 25
25275: PUSH
25276: LD_INT 8
25278: PUSH
25279: EMPTY
25280: LIST
25281: LIST
25282: PUSH
25283: LD_INT 25
25285: PUSH
25286: LD_INT 9
25288: PUSH
25289: EMPTY
25290: LIST
25291: LIST
25292: PUSH
25293: EMPTY
25294: LIST
25295: LIST
25296: LIST
25297: LIST
25298: LIST
25299: LIST
25300: LIST
25301: LIST
25302: PPUSH
25303: CALL_OW 72
25307: ST_TO_ADDR
// if not tmp then
25308: LD_VAR 0 4
25312: NOT
25313: IFFALSE 25317
// exit ;
25315: GO 28707
// for i in tmp do
25317: LD_ADDR_VAR 0 3
25321: PUSH
25322: LD_VAR 0 4
25326: PUSH
25327: FOR_IN
25328: IFFALSE 25359
// if GetTag ( i ) then
25330: LD_VAR 0 3
25334: PPUSH
25335: CALL_OW 110
25339: IFFALSE 25357
// tmp := tmp diff i ;
25341: LD_ADDR_VAR 0 4
25345: PUSH
25346: LD_VAR 0 4
25350: PUSH
25351: LD_VAR 0 3
25355: DIFF
25356: ST_TO_ADDR
25357: GO 25327
25359: POP
25360: POP
// if not tmp then
25361: LD_VAR 0 4
25365: NOT
25366: IFFALSE 25370
// exit ;
25368: GO 28707
// sol := UnitFilter ( mc_bases [ base ] , [ f_or , [ f_class , 1 ] , [ f_class , 5 ] , [ f_class , 8 ] , [ f_class , 9 ] ] ) ;
25370: LD_ADDR_VAR 0 5
25374: PUSH
25375: LD_EXP 76
25379: PUSH
25380: LD_VAR 0 1
25384: ARRAY
25385: PPUSH
25386: LD_INT 2
25388: PUSH
25389: LD_INT 25
25391: PUSH
25392: LD_INT 1
25394: PUSH
25395: EMPTY
25396: LIST
25397: LIST
25398: PUSH
25399: LD_INT 25
25401: PUSH
25402: LD_INT 5
25404: PUSH
25405: EMPTY
25406: LIST
25407: LIST
25408: PUSH
25409: LD_INT 25
25411: PUSH
25412: LD_INT 8
25414: PUSH
25415: EMPTY
25416: LIST
25417: LIST
25418: PUSH
25419: LD_INT 25
25421: PUSH
25422: LD_INT 9
25424: PUSH
25425: EMPTY
25426: LIST
25427: LIST
25428: PUSH
25429: EMPTY
25430: LIST
25431: LIST
25432: LIST
25433: LIST
25434: LIST
25435: PPUSH
25436: CALL_OW 72
25440: ST_TO_ADDR
// eng := UnitFilter ( mc_bases [ base ] , [ f_class , 2 ] ) ;
25441: LD_ADDR_VAR 0 6
25445: PUSH
25446: LD_EXP 76
25450: PUSH
25451: LD_VAR 0 1
25455: ARRAY
25456: PPUSH
25457: LD_INT 25
25459: PUSH
25460: LD_INT 2
25462: PUSH
25463: EMPTY
25464: LIST
25465: LIST
25466: PPUSH
25467: CALL_OW 72
25471: ST_TO_ADDR
// mech := UnitFilter ( mc_bases [ base ] , [ f_class , 3 ] ) ;
25472: LD_ADDR_VAR 0 7
25476: PUSH
25477: LD_EXP 76
25481: PUSH
25482: LD_VAR 0 1
25486: ARRAY
25487: PPUSH
25488: LD_INT 25
25490: PUSH
25491: LD_INT 3
25493: PUSH
25494: EMPTY
25495: LIST
25496: LIST
25497: PPUSH
25498: CALL_OW 72
25502: ST_TO_ADDR
// sci := UnitFilter ( mc_bases [ base ] , [ [ f_class , 4 ] , [ f_lives , 251 ] ] ) ;
25503: LD_ADDR_VAR 0 8
25507: PUSH
25508: LD_EXP 76
25512: PUSH
25513: LD_VAR 0 1
25517: ARRAY
25518: PPUSH
25519: LD_INT 25
25521: PUSH
25522: LD_INT 4
25524: PUSH
25525: EMPTY
25526: LIST
25527: LIST
25528: PUSH
25529: LD_INT 24
25531: PUSH
25532: LD_INT 251
25534: PUSH
25535: EMPTY
25536: LIST
25537: LIST
25538: PUSH
25539: EMPTY
25540: LIST
25541: LIST
25542: PPUSH
25543: CALL_OW 72
25547: ST_TO_ADDR
// if mc_scan [ base ] then
25548: LD_EXP 99
25552: PUSH
25553: LD_VAR 0 1
25557: ARRAY
25558: IFFALSE 26019
// begin mc_class_case_use := Replace ( mc_class_case_use , base , 4 ) ;
25560: LD_ADDR_EXP 118
25564: PUSH
25565: LD_EXP 118
25569: PPUSH
25570: LD_VAR 0 1
25574: PPUSH
25575: LD_INT 4
25577: PPUSH
25578: CALL_OW 1
25582: ST_TO_ADDR
// b := UnitFilter ( mc_bases [ base ] , [ f_or , [ f_btype , b_armoury ] , [ f_btype , b_barracks ] ] ) ;
25583: LD_ADDR_VAR 0 12
25587: PUSH
25588: LD_EXP 76
25592: PUSH
25593: LD_VAR 0 1
25597: ARRAY
25598: PPUSH
25599: LD_INT 2
25601: PUSH
25602: LD_INT 30
25604: PUSH
25605: LD_INT 4
25607: PUSH
25608: EMPTY
25609: LIST
25610: LIST
25611: PUSH
25612: LD_INT 30
25614: PUSH
25615: LD_INT 5
25617: PUSH
25618: EMPTY
25619: LIST
25620: LIST
25621: PUSH
25622: EMPTY
25623: LIST
25624: LIST
25625: LIST
25626: PPUSH
25627: CALL_OW 72
25631: ST_TO_ADDR
// if not b then
25632: LD_VAR 0 12
25636: NOT
25637: IFFALSE 25641
// exit ;
25639: GO 28707
// p := [ ] ;
25641: LD_ADDR_VAR 0 11
25645: PUSH
25646: EMPTY
25647: ST_TO_ADDR
// if sci >= 2 then
25648: LD_VAR 0 8
25652: PUSH
25653: LD_INT 2
25655: GREATEREQUAL
25656: IFFALSE 25687
// sci := [ sci [ 1 ] , sci [ 2 ] ] else
25658: LD_ADDR_VAR 0 8
25662: PUSH
25663: LD_VAR 0 8
25667: PUSH
25668: LD_INT 1
25670: ARRAY
25671: PUSH
25672: LD_VAR 0 8
25676: PUSH
25677: LD_INT 2
25679: ARRAY
25680: PUSH
25681: EMPTY
25682: LIST
25683: LIST
25684: ST_TO_ADDR
25685: GO 25748
// if sci = 1 then
25687: LD_VAR 0 8
25691: PUSH
25692: LD_INT 1
25694: EQUAL
25695: IFFALSE 25716
// sci := [ sci [ 1 ] ] else
25697: LD_ADDR_VAR 0 8
25701: PUSH
25702: LD_VAR 0 8
25706: PUSH
25707: LD_INT 1
25709: ARRAY
25710: PUSH
25711: EMPTY
25712: LIST
25713: ST_TO_ADDR
25714: GO 25748
// if sci = 0 then
25716: LD_VAR 0 8
25720: PUSH
25721: LD_INT 0
25723: EQUAL
25724: IFFALSE 25748
// p := SortBySkill ( tmp , 4 ) [ 1 ] ;
25726: LD_ADDR_VAR 0 11
25730: PUSH
25731: LD_VAR 0 4
25735: PPUSH
25736: LD_INT 4
25738: PPUSH
25739: CALL 91994 0 2
25743: PUSH
25744: LD_INT 1
25746: ARRAY
25747: ST_TO_ADDR
// if eng > 4 then
25748: LD_VAR 0 6
25752: PUSH
25753: LD_INT 4
25755: GREATER
25756: IFFALSE 25802
// for i = eng downto 4 do
25758: LD_ADDR_VAR 0 3
25762: PUSH
25763: DOUBLE
25764: LD_VAR 0 6
25768: INC
25769: ST_TO_ADDR
25770: LD_INT 4
25772: PUSH
25773: FOR_DOWNTO
25774: IFFALSE 25800
// eng := eng diff eng [ i ] ;
25776: LD_ADDR_VAR 0 6
25780: PUSH
25781: LD_VAR 0 6
25785: PUSH
25786: LD_VAR 0 6
25790: PUSH
25791: LD_VAR 0 3
25795: ARRAY
25796: DIFF
25797: ST_TO_ADDR
25798: GO 25773
25800: POP
25801: POP
// tmp := tmp diff ( sol union eng union mech union sci ) ;
25802: LD_ADDR_VAR 0 4
25806: PUSH
25807: LD_VAR 0 4
25811: PUSH
25812: LD_VAR 0 5
25816: PUSH
25817: LD_VAR 0 6
25821: UNION
25822: PUSH
25823: LD_VAR 0 7
25827: UNION
25828: PUSH
25829: LD_VAR 0 8
25833: UNION
25834: DIFF
25835: ST_TO_ADDR
// bcount := UnitFilter ( mc_bases [ base ] , [ f_or , [ f_btype , b_bunker ] , [ f_btype , b_breastwork ] ] ) + UnitFilter ( mc_bases [ base ] , [ f_or , [ f_btype , b_armoury ] , [ f_btype , b_barracks ] ] ) * 6 ;
25836: LD_ADDR_VAR 0 13
25840: PUSH
25841: LD_EXP 76
25845: PUSH
25846: LD_VAR 0 1
25850: ARRAY
25851: PPUSH
25852: LD_INT 2
25854: PUSH
25855: LD_INT 30
25857: PUSH
25858: LD_INT 32
25860: PUSH
25861: EMPTY
25862: LIST
25863: LIST
25864: PUSH
25865: LD_INT 30
25867: PUSH
25868: LD_INT 31
25870: PUSH
25871: EMPTY
25872: LIST
25873: LIST
25874: PUSH
25875: EMPTY
25876: LIST
25877: LIST
25878: LIST
25879: PPUSH
25880: CALL_OW 72
25884: PUSH
25885: LD_EXP 76
25889: PUSH
25890: LD_VAR 0 1
25894: ARRAY
25895: PPUSH
25896: LD_INT 2
25898: PUSH
25899: LD_INT 30
25901: PUSH
25902: LD_INT 4
25904: PUSH
25905: EMPTY
25906: LIST
25907: LIST
25908: PUSH
25909: LD_INT 30
25911: PUSH
25912: LD_INT 5
25914: PUSH
25915: EMPTY
25916: LIST
25917: LIST
25918: PUSH
25919: EMPTY
25920: LIST
25921: LIST
25922: LIST
25923: PPUSH
25924: CALL_OW 72
25928: PUSH
25929: LD_INT 6
25931: MUL
25932: PLUS
25933: ST_TO_ADDR
// if bcount < tmp then
25934: LD_VAR 0 13
25938: PUSH
25939: LD_VAR 0 4
25943: LESS
25944: IFFALSE 25990
// for i = tmp downto bcount do
25946: LD_ADDR_VAR 0 3
25950: PUSH
25951: DOUBLE
25952: LD_VAR 0 4
25956: INC
25957: ST_TO_ADDR
25958: LD_VAR 0 13
25962: PUSH
25963: FOR_DOWNTO
25964: IFFALSE 25988
// tmp := Delete ( tmp , tmp ) ;
25966: LD_ADDR_VAR 0 4
25970: PUSH
25971: LD_VAR 0 4
25975: PPUSH
25976: LD_VAR 0 4
25980: PPUSH
25981: CALL_OW 3
25985: ST_TO_ADDR
25986: GO 25963
25988: POP
25989: POP
// result := [ tmp , 0 , 0 , p ] ;
25990: LD_ADDR_VAR 0 2
25994: PUSH
25995: LD_VAR 0 4
25999: PUSH
26000: LD_INT 0
26002: PUSH
26003: LD_INT 0
26005: PUSH
26006: LD_VAR 0 11
26010: PUSH
26011: EMPTY
26012: LIST
26013: LIST
26014: LIST
26015: LIST
26016: ST_TO_ADDR
// exit ;
26017: GO 28707
// end ; if not UnitFilter ( mc_bases [ base ] , [ f_or , [ f_btype , b_lab ] , [ f_btype , b_lab_half ] , [ f_btype , b_lab_full ] ] ) and not UnitFilter ( mc_bases [ base ] , [ f_btype , b_factory ] ) then
26019: LD_EXP 76
26023: PUSH
26024: LD_VAR 0 1
26028: ARRAY
26029: PPUSH
26030: LD_INT 2
26032: PUSH
26033: LD_INT 30
26035: PUSH
26036: LD_INT 6
26038: PUSH
26039: EMPTY
26040: LIST
26041: LIST
26042: PUSH
26043: LD_INT 30
26045: PUSH
26046: LD_INT 7
26048: PUSH
26049: EMPTY
26050: LIST
26051: LIST
26052: PUSH
26053: LD_INT 30
26055: PUSH
26056: LD_INT 8
26058: PUSH
26059: EMPTY
26060: LIST
26061: LIST
26062: PUSH
26063: EMPTY
26064: LIST
26065: LIST
26066: LIST
26067: LIST
26068: PPUSH
26069: CALL_OW 72
26073: NOT
26074: PUSH
26075: LD_EXP 76
26079: PUSH
26080: LD_VAR 0 1
26084: ARRAY
26085: PPUSH
26086: LD_INT 30
26088: PUSH
26089: LD_INT 3
26091: PUSH
26092: EMPTY
26093: LIST
26094: LIST
26095: PPUSH
26096: CALL_OW 72
26100: NOT
26101: AND
26102: IFFALSE 26174
// begin if eng = tmp then
26104: LD_VAR 0 6
26108: PUSH
26109: LD_VAR 0 4
26113: EQUAL
26114: IFFALSE 26118
// exit ;
26116: GO 28707
// mc_class_case_use := Replace ( mc_class_case_use , base , 1 ) ;
26118: LD_ADDR_EXP 118
26122: PUSH
26123: LD_EXP 118
26127: PPUSH
26128: LD_VAR 0 1
26132: PPUSH
26133: LD_INT 1
26135: PPUSH
26136: CALL_OW 1
26140: ST_TO_ADDR
// result := [ 0 , tmp diff eng , 0 , 0 ] ;
26141: LD_ADDR_VAR 0 2
26145: PUSH
26146: LD_INT 0
26148: PUSH
26149: LD_VAR 0 4
26153: PUSH
26154: LD_VAR 0 6
26158: DIFF
26159: PUSH
26160: LD_INT 0
26162: PUSH
26163: LD_INT 0
26165: PUSH
26166: EMPTY
26167: LIST
26168: LIST
26169: LIST
26170: LIST
26171: ST_TO_ADDR
// exit ;
26172: GO 28707
// end ; if mc_tech [ mc_sides [ base ] ] and UnitFilter ( mc_bases [ base ] , [ f_or , [ f_btype , b_lab ] , [ f_btype , b_lab_half ] , [ f_btype , b_lab_full ] ] ) and not UnitFilter ( mc_bases [ base ] , [ f_btype , b_factory ] ) then
26174: LD_EXP 103
26178: PUSH
26179: LD_EXP 102
26183: PUSH
26184: LD_VAR 0 1
26188: ARRAY
26189: ARRAY
26190: PUSH
26191: LD_EXP 76
26195: PUSH
26196: LD_VAR 0 1
26200: ARRAY
26201: PPUSH
26202: LD_INT 2
26204: PUSH
26205: LD_INT 30
26207: PUSH
26208: LD_INT 6
26210: PUSH
26211: EMPTY
26212: LIST
26213: LIST
26214: PUSH
26215: LD_INT 30
26217: PUSH
26218: LD_INT 7
26220: PUSH
26221: EMPTY
26222: LIST
26223: LIST
26224: PUSH
26225: LD_INT 30
26227: PUSH
26228: LD_INT 8
26230: PUSH
26231: EMPTY
26232: LIST
26233: LIST
26234: PUSH
26235: EMPTY
26236: LIST
26237: LIST
26238: LIST
26239: LIST
26240: PPUSH
26241: CALL_OW 72
26245: AND
26246: PUSH
26247: LD_EXP 76
26251: PUSH
26252: LD_VAR 0 1
26256: ARRAY
26257: PPUSH
26258: LD_INT 30
26260: PUSH
26261: LD_INT 3
26263: PUSH
26264: EMPTY
26265: LIST
26266: LIST
26267: PPUSH
26268: CALL_OW 72
26272: NOT
26273: AND
26274: IFFALSE 26488
// begin if sci >= 6 then
26276: LD_VAR 0 8
26280: PUSH
26281: LD_INT 6
26283: GREATEREQUAL
26284: IFFALSE 26288
// exit ;
26286: GO 28707
// mc_class_case_use := Replace ( mc_class_case_use , base , 2 ) ;
26288: LD_ADDR_EXP 118
26292: PUSH
26293: LD_EXP 118
26297: PPUSH
26298: LD_VAR 0 1
26302: PPUSH
26303: LD_INT 2
26305: PPUSH
26306: CALL_OW 1
26310: ST_TO_ADDR
// sort := SortBySkill ( tmp diff sci , 4 ) ;
26311: LD_ADDR_VAR 0 9
26315: PUSH
26316: LD_VAR 0 4
26320: PUSH
26321: LD_VAR 0 8
26325: DIFF
26326: PPUSH
26327: LD_INT 4
26329: PPUSH
26330: CALL 91994 0 2
26334: ST_TO_ADDR
// p := [ ] ;
26335: LD_ADDR_VAR 0 11
26339: PUSH
26340: EMPTY
26341: ST_TO_ADDR
// if sci < 6 and sort > 6 then
26342: LD_VAR 0 8
26346: PUSH
26347: LD_INT 6
26349: LESS
26350: PUSH
26351: LD_VAR 0 9
26355: PUSH
26356: LD_INT 6
26358: GREATER
26359: AND
26360: IFFALSE 26441
// begin for i = 1 to 6 - sci do
26362: LD_ADDR_VAR 0 3
26366: PUSH
26367: DOUBLE
26368: LD_INT 1
26370: DEC
26371: ST_TO_ADDR
26372: LD_INT 6
26374: PUSH
26375: LD_VAR 0 8
26379: MINUS
26380: PUSH
26381: FOR_TO
26382: IFFALSE 26437
// begin p := Insert ( p , p + 1 , sort [ 1 ] ) ;
26384: LD_ADDR_VAR 0 11
26388: PUSH
26389: LD_VAR 0 11
26393: PPUSH
26394: LD_VAR 0 11
26398: PUSH
26399: LD_INT 1
26401: PLUS
26402: PPUSH
26403: LD_VAR 0 9
26407: PUSH
26408: LD_INT 1
26410: ARRAY
26411: PPUSH
26412: CALL_OW 2
26416: ST_TO_ADDR
// sort := Delete ( sort , 1 ) ;
26417: LD_ADDR_VAR 0 9
26421: PUSH
26422: LD_VAR 0 9
26426: PPUSH
26427: LD_INT 1
26429: PPUSH
26430: CALL_OW 3
26434: ST_TO_ADDR
// end ;
26435: GO 26381
26437: POP
26438: POP
// end else
26439: GO 26461
// if sort then
26441: LD_VAR 0 9
26445: IFFALSE 26461
// p := sort [ 1 ] ;
26447: LD_ADDR_VAR 0 11
26451: PUSH
26452: LD_VAR 0 9
26456: PUSH
26457: LD_INT 1
26459: ARRAY
26460: ST_TO_ADDR
// result := [ 0 , 0 , 0 , p ] ;
26461: LD_ADDR_VAR 0 2
26465: PUSH
26466: LD_INT 0
26468: PUSH
26469: LD_INT 0
26471: PUSH
26472: LD_INT 0
26474: PUSH
26475: LD_VAR 0 11
26479: PUSH
26480: EMPTY
26481: LIST
26482: LIST
26483: LIST
26484: LIST
26485: ST_TO_ADDR
// exit ;
26486: GO 28707
// end ; if mc_tech [ mc_sides [ base ] ] and UnitFilter ( mc_bases [ base ] , [ f_or , [ f_btype , b_lab ] , [ f_btype , b_lab_half ] , [ f_btype , b_lab_full ] ] ) and UnitFilter ( mc_bases [ base ] , [ f_btype , b_factory ] ) then
26488: LD_EXP 103
26492: PUSH
26493: LD_EXP 102
26497: PUSH
26498: LD_VAR 0 1
26502: ARRAY
26503: ARRAY
26504: PUSH
26505: LD_EXP 76
26509: PUSH
26510: LD_VAR 0 1
26514: ARRAY
26515: PPUSH
26516: LD_INT 2
26518: PUSH
26519: LD_INT 30
26521: PUSH
26522: LD_INT 6
26524: PUSH
26525: EMPTY
26526: LIST
26527: LIST
26528: PUSH
26529: LD_INT 30
26531: PUSH
26532: LD_INT 7
26534: PUSH
26535: EMPTY
26536: LIST
26537: LIST
26538: PUSH
26539: LD_INT 30
26541: PUSH
26542: LD_INT 8
26544: PUSH
26545: EMPTY
26546: LIST
26547: LIST
26548: PUSH
26549: EMPTY
26550: LIST
26551: LIST
26552: LIST
26553: LIST
26554: PPUSH
26555: CALL_OW 72
26559: AND
26560: PUSH
26561: LD_EXP 76
26565: PUSH
26566: LD_VAR 0 1
26570: ARRAY
26571: PPUSH
26572: LD_INT 30
26574: PUSH
26575: LD_INT 3
26577: PUSH
26578: EMPTY
26579: LIST
26580: LIST
26581: PPUSH
26582: CALL_OW 72
26586: AND
26587: IFFALSE 27321
// begin mc_class_case_use := Replace ( mc_class_case_use , base , 3 ) ;
26589: LD_ADDR_EXP 118
26593: PUSH
26594: LD_EXP 118
26598: PPUSH
26599: LD_VAR 0 1
26603: PPUSH
26604: LD_INT 3
26606: PPUSH
26607: CALL_OW 1
26611: ST_TO_ADDR
// result := [ 0 , 0 , 0 , 0 ] ;
26612: LD_ADDR_VAR 0 2
26616: PUSH
26617: LD_INT 0
26619: PUSH
26620: LD_INT 0
26622: PUSH
26623: LD_INT 0
26625: PUSH
26626: LD_INT 0
26628: PUSH
26629: EMPTY
26630: LIST
26631: LIST
26632: LIST
26633: LIST
26634: ST_TO_ADDR
// if not eng then
26635: LD_VAR 0 6
26639: NOT
26640: IFFALSE 26703
// begin p := SortBySkill ( tmp , 2 ) [ 1 ] ;
26642: LD_ADDR_VAR 0 11
26646: PUSH
26647: LD_VAR 0 4
26651: PPUSH
26652: LD_INT 2
26654: PPUSH
26655: CALL 91994 0 2
26659: PUSH
26660: LD_INT 1
26662: ARRAY
26663: ST_TO_ADDR
// result := Replace ( result , 2 , p ) ;
26664: LD_ADDR_VAR 0 2
26668: PUSH
26669: LD_VAR 0 2
26673: PPUSH
26674: LD_INT 2
26676: PPUSH
26677: LD_VAR 0 11
26681: PPUSH
26682: CALL_OW 1
26686: ST_TO_ADDR
// tmp := tmp diff p ;
26687: LD_ADDR_VAR 0 4
26691: PUSH
26692: LD_VAR 0 4
26696: PUSH
26697: LD_VAR 0 11
26701: DIFF
26702: ST_TO_ADDR
// end ; if tmp and sci < 6 then
26703: LD_VAR 0 4
26707: PUSH
26708: LD_VAR 0 8
26712: PUSH
26713: LD_INT 6
26715: LESS
26716: AND
26717: IFFALSE 26905
// begin sort := SortBySkill ( tmp diff ( sci union mech ) , 4 ) ;
26719: LD_ADDR_VAR 0 9
26723: PUSH
26724: LD_VAR 0 4
26728: PUSH
26729: LD_VAR 0 8
26733: PUSH
26734: LD_VAR 0 7
26738: UNION
26739: DIFF
26740: PPUSH
26741: LD_INT 4
26743: PPUSH
26744: CALL 91994 0 2
26748: ST_TO_ADDR
// p := [ ] ;
26749: LD_ADDR_VAR 0 11
26753: PUSH
26754: EMPTY
26755: ST_TO_ADDR
// if sort then
26756: LD_VAR 0 9
26760: IFFALSE 26876
// for i = 1 to 6 - sci do
26762: LD_ADDR_VAR 0 3
26766: PUSH
26767: DOUBLE
26768: LD_INT 1
26770: DEC
26771: ST_TO_ADDR
26772: LD_INT 6
26774: PUSH
26775: LD_VAR 0 8
26779: MINUS
26780: PUSH
26781: FOR_TO
26782: IFFALSE 26874
// begin if i = sort then
26784: LD_VAR 0 3
26788: PUSH
26789: LD_VAR 0 9
26793: EQUAL
26794: IFFALSE 26798
// break ;
26796: GO 26874
// if GetClass ( i ) = 4 then
26798: LD_VAR 0 3
26802: PPUSH
26803: CALL_OW 257
26807: PUSH
26808: LD_INT 4
26810: EQUAL
26811: IFFALSE 26815
// continue ;
26813: GO 26781
// p := Insert ( p , p + 1 , sort [ i ] ) ;
26815: LD_ADDR_VAR 0 11
26819: PUSH
26820: LD_VAR 0 11
26824: PPUSH
26825: LD_VAR 0 11
26829: PUSH
26830: LD_INT 1
26832: PLUS
26833: PPUSH
26834: LD_VAR 0 9
26838: PUSH
26839: LD_VAR 0 3
26843: ARRAY
26844: PPUSH
26845: CALL_OW 2
26849: ST_TO_ADDR
// tmp := tmp diff sort [ i ] ;
26850: LD_ADDR_VAR 0 4
26854: PUSH
26855: LD_VAR 0 4
26859: PUSH
26860: LD_VAR 0 9
26864: PUSH
26865: LD_VAR 0 3
26869: ARRAY
26870: DIFF
26871: ST_TO_ADDR
// end ;
26872: GO 26781
26874: POP
26875: POP
// if p then
26876: LD_VAR 0 11
26880: IFFALSE 26905
// result := Replace ( result , 4 , p ) ;
26882: LD_ADDR_VAR 0 2
26886: PUSH
26887: LD_VAR 0 2
26891: PPUSH
26892: LD_INT 4
26894: PPUSH
26895: LD_VAR 0 11
26899: PPUSH
26900: CALL_OW 1
26904: ST_TO_ADDR
// end ; if tmp and mech < 6 then
26905: LD_VAR 0 4
26909: PUSH
26910: LD_VAR 0 7
26914: PUSH
26915: LD_INT 6
26917: LESS
26918: AND
26919: IFFALSE 27107
// begin sort := SortBySkill ( tmp diff ( sci union mech ) , 3 ) ;
26921: LD_ADDR_VAR 0 9
26925: PUSH
26926: LD_VAR 0 4
26930: PUSH
26931: LD_VAR 0 8
26935: PUSH
26936: LD_VAR 0 7
26940: UNION
26941: DIFF
26942: PPUSH
26943: LD_INT 3
26945: PPUSH
26946: CALL 91994 0 2
26950: ST_TO_ADDR
// p := [ ] ;
26951: LD_ADDR_VAR 0 11
26955: PUSH
26956: EMPTY
26957: ST_TO_ADDR
// if sort then
26958: LD_VAR 0 9
26962: IFFALSE 27078
// for i = 1 to 6 - mech do
26964: LD_ADDR_VAR 0 3
26968: PUSH
26969: DOUBLE
26970: LD_INT 1
26972: DEC
26973: ST_TO_ADDR
26974: LD_INT 6
26976: PUSH
26977: LD_VAR 0 7
26981: MINUS
26982: PUSH
26983: FOR_TO
26984: IFFALSE 27076
// begin if i = sort then
26986: LD_VAR 0 3
26990: PUSH
26991: LD_VAR 0 9
26995: EQUAL
26996: IFFALSE 27000
// break ;
26998: GO 27076
// if GetClass ( i ) = 3 then
27000: LD_VAR 0 3
27004: PPUSH
27005: CALL_OW 257
27009: PUSH
27010: LD_INT 3
27012: EQUAL
27013: IFFALSE 27017
// continue ;
27015: GO 26983
// p := Insert ( p , p + 1 , sort [ i ] ) ;
27017: LD_ADDR_VAR 0 11
27021: PUSH
27022: LD_VAR 0 11
27026: PPUSH
27027: LD_VAR 0 11
27031: PUSH
27032: LD_INT 1
27034: PLUS
27035: PPUSH
27036: LD_VAR 0 9
27040: PUSH
27041: LD_VAR 0 3
27045: ARRAY
27046: PPUSH
27047: CALL_OW 2
27051: ST_TO_ADDR
// tmp := tmp diff sort [ i ] ;
27052: LD_ADDR_VAR 0 4
27056: PUSH
27057: LD_VAR 0 4
27061: PUSH
27062: LD_VAR 0 9
27066: PUSH
27067: LD_VAR 0 3
27071: ARRAY
27072: DIFF
27073: ST_TO_ADDR
// end ;
27074: GO 26983
27076: POP
27077: POP
// if p then
27078: LD_VAR 0 11
27082: IFFALSE 27107
// result := Replace ( result , 3 , p ) ;
27084: LD_ADDR_VAR 0 2
27088: PUSH
27089: LD_VAR 0 2
27093: PPUSH
27094: LD_INT 3
27096: PPUSH
27097: LD_VAR 0 11
27101: PPUSH
27102: CALL_OW 1
27106: ST_TO_ADDR
// end ; if tmp > 6 and eng < 6 then
27107: LD_VAR 0 4
27111: PUSH
27112: LD_INT 6
27114: GREATER
27115: PUSH
27116: LD_VAR 0 6
27120: PUSH
27121: LD_INT 6
27123: LESS
27124: AND
27125: IFFALSE 27319
// begin sort := SortBySkill ( tmp diff ( sci union mech union eng ) , 2 ) ;
27127: LD_ADDR_VAR 0 9
27131: PUSH
27132: LD_VAR 0 4
27136: PUSH
27137: LD_VAR 0 8
27141: PUSH
27142: LD_VAR 0 7
27146: UNION
27147: PUSH
27148: LD_VAR 0 6
27152: UNION
27153: DIFF
27154: PPUSH
27155: LD_INT 2
27157: PPUSH
27158: CALL 91994 0 2
27162: ST_TO_ADDR
// p := [ ] ;
27163: LD_ADDR_VAR 0 11
27167: PUSH
27168: EMPTY
27169: ST_TO_ADDR
// if sort then
27170: LD_VAR 0 9
27174: IFFALSE 27290
// for i = 1 to 6 - eng do
27176: LD_ADDR_VAR 0 3
27180: PUSH
27181: DOUBLE
27182: LD_INT 1
27184: DEC
27185: ST_TO_ADDR
27186: LD_INT 6
27188: PUSH
27189: LD_VAR 0 6
27193: MINUS
27194: PUSH
27195: FOR_TO
27196: IFFALSE 27288
// begin if i = sort then
27198: LD_VAR 0 3
27202: PUSH
27203: LD_VAR 0 9
27207: EQUAL
27208: IFFALSE 27212
// break ;
27210: GO 27288
// if GetClass ( i ) = 2 then
27212: LD_VAR 0 3
27216: PPUSH
27217: CALL_OW 257
27221: PUSH
27222: LD_INT 2
27224: EQUAL
27225: IFFALSE 27229
// continue ;
27227: GO 27195
// p := Insert ( p , p + 1 , sort [ i ] ) ;
27229: LD_ADDR_VAR 0 11
27233: PUSH
27234: LD_VAR 0 11
27238: PPUSH
27239: LD_VAR 0 11
27243: PUSH
27244: LD_INT 1
27246: PLUS
27247: PPUSH
27248: LD_VAR 0 9
27252: PUSH
27253: LD_VAR 0 3
27257: ARRAY
27258: PPUSH
27259: CALL_OW 2
27263: ST_TO_ADDR
// tmp := tmp diff sort [ i ] ;
27264: LD_ADDR_VAR 0 4
27268: PUSH
27269: LD_VAR 0 4
27273: PUSH
27274: LD_VAR 0 9
27278: PUSH
27279: LD_VAR 0 3
27283: ARRAY
27284: DIFF
27285: ST_TO_ADDR
// end ;
27286: GO 27195
27288: POP
27289: POP
// if p then
27290: LD_VAR 0 11
27294: IFFALSE 27319
// result := Replace ( result , 2 , p ) ;
27296: LD_ADDR_VAR 0 2
27300: PUSH
27301: LD_VAR 0 2
27305: PPUSH
27306: LD_INT 2
27308: PPUSH
27309: LD_VAR 0 11
27313: PPUSH
27314: CALL_OW 1
27318: ST_TO_ADDR
// end ; exit ;
27319: GO 28707
// end ; if not mc_tech [ mc_sides [ base ] ] and UnitFilter ( mc_bases [ base ] , [ f_btype , b_factory ] ) and mc_build_list [ base ] then
27321: LD_EXP 103
27325: PUSH
27326: LD_EXP 102
27330: PUSH
27331: LD_VAR 0 1
27335: ARRAY
27336: ARRAY
27337: NOT
27338: PUSH
27339: LD_EXP 76
27343: PUSH
27344: LD_VAR 0 1
27348: ARRAY
27349: PPUSH
27350: LD_INT 30
27352: PUSH
27353: LD_INT 3
27355: PUSH
27356: EMPTY
27357: LIST
27358: LIST
27359: PPUSH
27360: CALL_OW 72
27364: AND
27365: PUSH
27366: LD_EXP 81
27370: PUSH
27371: LD_VAR 0 1
27375: ARRAY
27376: AND
27377: IFFALSE 27985
// begin mc_class_case_use := Replace ( mc_class_case_use , base , 5 ) ;
27379: LD_ADDR_EXP 118
27383: PUSH
27384: LD_EXP 118
27388: PPUSH
27389: LD_VAR 0 1
27393: PPUSH
27394: LD_INT 5
27396: PPUSH
27397: CALL_OW 1
27401: ST_TO_ADDR
// result := [ 0 , 0 , 0 , 0 ] ;
27402: LD_ADDR_VAR 0 2
27406: PUSH
27407: LD_INT 0
27409: PUSH
27410: LD_INT 0
27412: PUSH
27413: LD_INT 0
27415: PUSH
27416: LD_INT 0
27418: PUSH
27419: EMPTY
27420: LIST
27421: LIST
27422: LIST
27423: LIST
27424: ST_TO_ADDR
// if sci > 1 then
27425: LD_VAR 0 8
27429: PUSH
27430: LD_INT 1
27432: GREATER
27433: IFFALSE 27461
// tmp := tmp diff ( sci diff sci [ 1 ] ) ;
27435: LD_ADDR_VAR 0 4
27439: PUSH
27440: LD_VAR 0 4
27444: PUSH
27445: LD_VAR 0 8
27449: PUSH
27450: LD_VAR 0 8
27454: PUSH
27455: LD_INT 1
27457: ARRAY
27458: DIFF
27459: DIFF
27460: ST_TO_ADDR
// if tmp and not sci then
27461: LD_VAR 0 4
27465: PUSH
27466: LD_VAR 0 8
27470: NOT
27471: AND
27472: IFFALSE 27541
// begin sort := SortBySkill ( tmp , 4 ) ;
27474: LD_ADDR_VAR 0 9
27478: PUSH
27479: LD_VAR 0 4
27483: PPUSH
27484: LD_INT 4
27486: PPUSH
27487: CALL 91994 0 2
27491: ST_TO_ADDR
// if sort then
27492: LD_VAR 0 9
27496: IFFALSE 27512
// p := sort [ 1 ] ;
27498: LD_ADDR_VAR 0 11
27502: PUSH
27503: LD_VAR 0 9
27507: PUSH
27508: LD_INT 1
27510: ARRAY
27511: ST_TO_ADDR
// if p then
27512: LD_VAR 0 11
27516: IFFALSE 27541
// result := Replace ( result , 4 , p ) ;
27518: LD_ADDR_VAR 0 2
27522: PUSH
27523: LD_VAR 0 2
27527: PPUSH
27528: LD_INT 4
27530: PPUSH
27531: LD_VAR 0 11
27535: PPUSH
27536: CALL_OW 1
27540: ST_TO_ADDR
// end ; tmp := tmp diff mech ;
27541: LD_ADDR_VAR 0 4
27545: PUSH
27546: LD_VAR 0 4
27550: PUSH
27551: LD_VAR 0 7
27555: DIFF
27556: ST_TO_ADDR
// if tmp and mech < 6 then
27557: LD_VAR 0 4
27561: PUSH
27562: LD_VAR 0 7
27566: PUSH
27567: LD_INT 6
27569: LESS
27570: AND
27571: IFFALSE 27759
// begin sort := SortBySkill ( tmp diff ( sci union mech ) , 3 ) ;
27573: LD_ADDR_VAR 0 9
27577: PUSH
27578: LD_VAR 0 4
27582: PUSH
27583: LD_VAR 0 8
27587: PUSH
27588: LD_VAR 0 7
27592: UNION
27593: DIFF
27594: PPUSH
27595: LD_INT 3
27597: PPUSH
27598: CALL 91994 0 2
27602: ST_TO_ADDR
// p := [ ] ;
27603: LD_ADDR_VAR 0 11
27607: PUSH
27608: EMPTY
27609: ST_TO_ADDR
// if sort then
27610: LD_VAR 0 9
27614: IFFALSE 27730
// for i = 1 to 6 - mech do
27616: LD_ADDR_VAR 0 3
27620: PUSH
27621: DOUBLE
27622: LD_INT 1
27624: DEC
27625: ST_TO_ADDR
27626: LD_INT 6
27628: PUSH
27629: LD_VAR 0 7
27633: MINUS
27634: PUSH
27635: FOR_TO
27636: IFFALSE 27728
// begin if i = sort then
27638: LD_VAR 0 3
27642: PUSH
27643: LD_VAR 0 9
27647: EQUAL
27648: IFFALSE 27652
// break ;
27650: GO 27728
// if GetClass ( i ) = 3 then
27652: LD_VAR 0 3
27656: PPUSH
27657: CALL_OW 257
27661: PUSH
27662: LD_INT 3
27664: EQUAL
27665: IFFALSE 27669
// continue ;
27667: GO 27635
// p := Insert ( p , p + 1 , sort [ i ] ) ;
27669: LD_ADDR_VAR 0 11
27673: PUSH
27674: LD_VAR 0 11
27678: PPUSH
27679: LD_VAR 0 11
27683: PUSH
27684: LD_INT 1
27686: PLUS
27687: PPUSH
27688: LD_VAR 0 9
27692: PUSH
27693: LD_VAR 0 3
27697: ARRAY
27698: PPUSH
27699: CALL_OW 2
27703: ST_TO_ADDR
// tmp := tmp diff sort [ i ] ;
27704: LD_ADDR_VAR 0 4
27708: PUSH
27709: LD_VAR 0 4
27713: PUSH
27714: LD_VAR 0 9
27718: PUSH
27719: LD_VAR 0 3
27723: ARRAY
27724: DIFF
27725: ST_TO_ADDR
// end ;
27726: GO 27635
27728: POP
27729: POP
// if p then
27730: LD_VAR 0 11
27734: IFFALSE 27759
// result := Replace ( result , 3 , p ) ;
27736: LD_ADDR_VAR 0 2
27740: PUSH
27741: LD_VAR 0 2
27745: PPUSH
27746: LD_INT 3
27748: PPUSH
27749: LD_VAR 0 11
27753: PPUSH
27754: CALL_OW 1
27758: ST_TO_ADDR
// end ; tmp := tmp diff eng ;
27759: LD_ADDR_VAR 0 4
27763: PUSH
27764: LD_VAR 0 4
27768: PUSH
27769: LD_VAR 0 6
27773: DIFF
27774: ST_TO_ADDR
// if tmp and eng < 6 then
27775: LD_VAR 0 4
27779: PUSH
27780: LD_VAR 0 6
27784: PUSH
27785: LD_INT 6
27787: LESS
27788: AND
27789: IFFALSE 27983
// begin sort := SortBySkill ( tmp diff ( sci union mech union eng ) , 2 ) ;
27791: LD_ADDR_VAR 0 9
27795: PUSH
27796: LD_VAR 0 4
27800: PUSH
27801: LD_VAR 0 8
27805: PUSH
27806: LD_VAR 0 7
27810: UNION
27811: PUSH
27812: LD_VAR 0 6
27816: UNION
27817: DIFF
27818: PPUSH
27819: LD_INT 2
27821: PPUSH
27822: CALL 91994 0 2
27826: ST_TO_ADDR
// p := [ ] ;
27827: LD_ADDR_VAR 0 11
27831: PUSH
27832: EMPTY
27833: ST_TO_ADDR
// if sort then
27834: LD_VAR 0 9
27838: IFFALSE 27954
// for i = 1 to 6 - eng do
27840: LD_ADDR_VAR 0 3
27844: PUSH
27845: DOUBLE
27846: LD_INT 1
27848: DEC
27849: ST_TO_ADDR
27850: LD_INT 6
27852: PUSH
27853: LD_VAR 0 6
27857: MINUS
27858: PUSH
27859: FOR_TO
27860: IFFALSE 27952
// begin if i = sort then
27862: LD_VAR 0 3
27866: PUSH
27867: LD_VAR 0 9
27871: EQUAL
27872: IFFALSE 27876
// break ;
27874: GO 27952
// if GetClass ( i ) = 2 then
27876: LD_VAR 0 3
27880: PPUSH
27881: CALL_OW 257
27885: PUSH
27886: LD_INT 2
27888: EQUAL
27889: IFFALSE 27893
// continue ;
27891: GO 27859
// p := Insert ( p , p + 1 , sort [ i ] ) ;
27893: LD_ADDR_VAR 0 11
27897: PUSH
27898: LD_VAR 0 11
27902: PPUSH
27903: LD_VAR 0 11
27907: PUSH
27908: LD_INT 1
27910: PLUS
27911: PPUSH
27912: LD_VAR 0 9
27916: PUSH
27917: LD_VAR 0 3
27921: ARRAY
27922: PPUSH
27923: CALL_OW 2
27927: ST_TO_ADDR
// tmp := tmp diff sort [ i ] ;
27928: LD_ADDR_VAR 0 4
27932: PUSH
27933: LD_VAR 0 4
27937: PUSH
27938: LD_VAR 0 9
27942: PUSH
27943: LD_VAR 0 3
27947: ARRAY
27948: DIFF
27949: ST_TO_ADDR
// end ;
27950: GO 27859
27952: POP
27953: POP
// if p then
27954: LD_VAR 0 11
27958: IFFALSE 27983
// result := Replace ( result , 2 , p ) ;
27960: LD_ADDR_VAR 0 2
27964: PUSH
27965: LD_VAR 0 2
27969: PPUSH
27970: LD_INT 2
27972: PPUSH
27973: LD_VAR 0 11
27977: PPUSH
27978: CALL_OW 1
27982: ST_TO_ADDR
// end ; exit ;
27983: GO 28707
// end ; if not mc_tech [ mc_sides [ base ] ] and UnitFilter ( mc_bases [ base ] , [ f_btype , b_factory ] ) and not mc_build_list [ base ] then
27985: LD_EXP 103
27989: PUSH
27990: LD_EXP 102
27994: PUSH
27995: LD_VAR 0 1
27999: ARRAY
28000: ARRAY
28001: NOT
28002: PUSH
28003: LD_EXP 76
28007: PUSH
28008: LD_VAR 0 1
28012: ARRAY
28013: PPUSH
28014: LD_INT 30
28016: PUSH
28017: LD_INT 3
28019: PUSH
28020: EMPTY
28021: LIST
28022: LIST
28023: PPUSH
28024: CALL_OW 72
28028: AND
28029: PUSH
28030: LD_EXP 81
28034: PUSH
28035: LD_VAR 0 1
28039: ARRAY
28040: NOT
28041: AND
28042: IFFALSE 28707
// begin mc_class_case_use := Replace ( mc_class_case_use , base , 6 ) ;
28044: LD_ADDR_EXP 118
28048: PUSH
28049: LD_EXP 118
28053: PPUSH
28054: LD_VAR 0 1
28058: PPUSH
28059: LD_INT 6
28061: PPUSH
28062: CALL_OW 1
28066: ST_TO_ADDR
// result := [ 0 , 0 , 0 , 0 ] ;
28067: LD_ADDR_VAR 0 2
28071: PUSH
28072: LD_INT 0
28074: PUSH
28075: LD_INT 0
28077: PUSH
28078: LD_INT 0
28080: PUSH
28081: LD_INT 0
28083: PUSH
28084: EMPTY
28085: LIST
28086: LIST
28087: LIST
28088: LIST
28089: ST_TO_ADDR
// if sci >= 1 then
28090: LD_VAR 0 8
28094: PUSH
28095: LD_INT 1
28097: GREATEREQUAL
28098: IFFALSE 28120
// tmp := tmp diff sci [ 1 ] ;
28100: LD_ADDR_VAR 0 4
28104: PUSH
28105: LD_VAR 0 4
28109: PUSH
28110: LD_VAR 0 8
28114: PUSH
28115: LD_INT 1
28117: ARRAY
28118: DIFF
28119: ST_TO_ADDR
// if tmp and not sci then
28120: LD_VAR 0 4
28124: PUSH
28125: LD_VAR 0 8
28129: NOT
28130: AND
28131: IFFALSE 28200
// begin sort := SortBySkill ( tmp , 4 ) ;
28133: LD_ADDR_VAR 0 9
28137: PUSH
28138: LD_VAR 0 4
28142: PPUSH
28143: LD_INT 4
28145: PPUSH
28146: CALL 91994 0 2
28150: ST_TO_ADDR
// if sort then
28151: LD_VAR 0 9
28155: IFFALSE 28171
// p := sort [ 1 ] ;
28157: LD_ADDR_VAR 0 11
28161: PUSH
28162: LD_VAR 0 9
28166: PUSH
28167: LD_INT 1
28169: ARRAY
28170: ST_TO_ADDR
// if p then
28171: LD_VAR 0 11
28175: IFFALSE 28200
// result := Replace ( result , 4 , p ) ;
28177: LD_ADDR_VAR 0 2
28181: PUSH
28182: LD_VAR 0 2
28186: PPUSH
28187: LD_INT 4
28189: PPUSH
28190: LD_VAR 0 11
28194: PPUSH
28195: CALL_OW 1
28199: ST_TO_ADDR
// end ; tmp := tmp diff mech ;
28200: LD_ADDR_VAR 0 4
28204: PUSH
28205: LD_VAR 0 4
28209: PUSH
28210: LD_VAR 0 7
28214: DIFF
28215: ST_TO_ADDR
// if tmp and mech < 6 then
28216: LD_VAR 0 4
28220: PUSH
28221: LD_VAR 0 7
28225: PUSH
28226: LD_INT 6
28228: LESS
28229: AND
28230: IFFALSE 28412
// begin sort := SortBySkill ( tmp diff mech , 3 ) ;
28232: LD_ADDR_VAR 0 9
28236: PUSH
28237: LD_VAR 0 4
28241: PUSH
28242: LD_VAR 0 7
28246: DIFF
28247: PPUSH
28248: LD_INT 3
28250: PPUSH
28251: CALL 91994 0 2
28255: ST_TO_ADDR
// p := [ ] ;
28256: LD_ADDR_VAR 0 11
28260: PUSH
28261: EMPTY
28262: ST_TO_ADDR
// if sort then
28263: LD_VAR 0 9
28267: IFFALSE 28383
// for i = 1 to 6 - mech do
28269: LD_ADDR_VAR 0 3
28273: PUSH
28274: DOUBLE
28275: LD_INT 1
28277: DEC
28278: ST_TO_ADDR
28279: LD_INT 6
28281: PUSH
28282: LD_VAR 0 7
28286: MINUS
28287: PUSH
28288: FOR_TO
28289: IFFALSE 28381
// begin if i = sort then
28291: LD_VAR 0 3
28295: PUSH
28296: LD_VAR 0 9
28300: EQUAL
28301: IFFALSE 28305
// break ;
28303: GO 28381
// if GetClass ( i ) = 3 then
28305: LD_VAR 0 3
28309: PPUSH
28310: CALL_OW 257
28314: PUSH
28315: LD_INT 3
28317: EQUAL
28318: IFFALSE 28322
// continue ;
28320: GO 28288
// p := Insert ( p , p + 1 , sort [ i ] ) ;
28322: LD_ADDR_VAR 0 11
28326: PUSH
28327: LD_VAR 0 11
28331: PPUSH
28332: LD_VAR 0 11
28336: PUSH
28337: LD_INT 1
28339: PLUS
28340: PPUSH
28341: LD_VAR 0 9
28345: PUSH
28346: LD_VAR 0 3
28350: ARRAY
28351: PPUSH
28352: CALL_OW 2
28356: ST_TO_ADDR
// tmp := tmp diff sort [ i ] ;
28357: LD_ADDR_VAR 0 4
28361: PUSH
28362: LD_VAR 0 4
28366: PUSH
28367: LD_VAR 0 9
28371: PUSH
28372: LD_VAR 0 3
28376: ARRAY
28377: DIFF
28378: ST_TO_ADDR
// end ;
28379: GO 28288
28381: POP
28382: POP
// if p then
28383: LD_VAR 0 11
28387: IFFALSE 28412
// result := Replace ( result , 3 , p ) ;
28389: LD_ADDR_VAR 0 2
28393: PUSH
28394: LD_VAR 0 2
28398: PPUSH
28399: LD_INT 3
28401: PPUSH
28402: LD_VAR 0 11
28406: PPUSH
28407: CALL_OW 1
28411: ST_TO_ADDR
// end ; tmp := tmp diff eng ;
28412: LD_ADDR_VAR 0 4
28416: PUSH
28417: LD_VAR 0 4
28421: PUSH
28422: LD_VAR 0 6
28426: DIFF
28427: ST_TO_ADDR
// if tmp and eng < 4 then
28428: LD_VAR 0 4
28432: PUSH
28433: LD_VAR 0 6
28437: PUSH
28438: LD_INT 4
28440: LESS
28441: AND
28442: IFFALSE 28632
// begin sort := SortBySkill ( tmp diff ( mech union eng ) , 2 ) ;
28444: LD_ADDR_VAR 0 9
28448: PUSH
28449: LD_VAR 0 4
28453: PUSH
28454: LD_VAR 0 7
28458: PUSH
28459: LD_VAR 0 6
28463: UNION
28464: DIFF
28465: PPUSH
28466: LD_INT 2
28468: PPUSH
28469: CALL 91994 0 2
28473: ST_TO_ADDR
// p := [ ] ;
28474: LD_ADDR_VAR 0 11
28478: PUSH
28479: EMPTY
28480: ST_TO_ADDR
// if sort then
28481: LD_VAR 0 9
28485: IFFALSE 28601
// for i = 1 to 4 - eng do
28487: LD_ADDR_VAR 0 3
28491: PUSH
28492: DOUBLE
28493: LD_INT 1
28495: DEC
28496: ST_TO_ADDR
28497: LD_INT 4
28499: PUSH
28500: LD_VAR 0 6
28504: MINUS
28505: PUSH
28506: FOR_TO
28507: IFFALSE 28599
// begin if i = sort then
28509: LD_VAR 0 3
28513: PUSH
28514: LD_VAR 0 9
28518: EQUAL
28519: IFFALSE 28523
// break ;
28521: GO 28599
// if GetClass ( i ) = 2 then
28523: LD_VAR 0 3
28527: PPUSH
28528: CALL_OW 257
28532: PUSH
28533: LD_INT 2
28535: EQUAL
28536: IFFALSE 28540
// continue ;
28538: GO 28506
// p := Insert ( p , p + 1 , sort [ i ] ) ;
28540: LD_ADDR_VAR 0 11
28544: PUSH
28545: LD_VAR 0 11
28549: PPUSH
28550: LD_VAR 0 11
28554: PUSH
28555: LD_INT 1
28557: PLUS
28558: PPUSH
28559: LD_VAR 0 9
28563: PUSH
28564: LD_VAR 0 3
28568: ARRAY
28569: PPUSH
28570: CALL_OW 2
28574: ST_TO_ADDR
// tmp := tmp diff sort [ i ] ;
28575: LD_ADDR_VAR 0 4
28579: PUSH
28580: LD_VAR 0 4
28584: PUSH
28585: LD_VAR 0 9
28589: PUSH
28590: LD_VAR 0 3
28594: ARRAY
28595: DIFF
28596: ST_TO_ADDR
// end ;
28597: GO 28506
28599: POP
28600: POP
// if p then
28601: LD_VAR 0 11
28605: IFFALSE 28630
// result := Replace ( result , 2 , p ) ;
28607: LD_ADDR_VAR 0 2
28611: PUSH
28612: LD_VAR 0 2
28616: PPUSH
28617: LD_INT 2
28619: PPUSH
28620: LD_VAR 0 11
28624: PPUSH
28625: CALL_OW 1
28629: ST_TO_ADDR
// end else
28630: GO 28676
// for i = eng downto 5 do
28632: LD_ADDR_VAR 0 3
28636: PUSH
28637: DOUBLE
28638: LD_VAR 0 6
28642: INC
28643: ST_TO_ADDR
28644: LD_INT 5
28646: PUSH
28647: FOR_DOWNTO
28648: IFFALSE 28674
// tmp := tmp union eng [ i ] ;
28650: LD_ADDR_VAR 0 4
28654: PUSH
28655: LD_VAR 0 4
28659: PUSH
28660: LD_VAR 0 6
28664: PUSH
28665: LD_VAR 0 3
28669: ARRAY
28670: UNION
28671: ST_TO_ADDR
28672: GO 28647
28674: POP
28675: POP
// result := Replace ( result , 1 , tmp diff sol ) ;
28676: LD_ADDR_VAR 0 2
28680: PUSH
28681: LD_VAR 0 2
28685: PPUSH
28686: LD_INT 1
28688: PPUSH
28689: LD_VAR 0 4
28693: PUSH
28694: LD_VAR 0 5
28698: DIFF
28699: PPUSH
28700: CALL_OW 1
28704: ST_TO_ADDR
// exit ;
28705: GO 28707
// end ; end ;
28707: LD_VAR 0 2
28711: RET
// export function MC_CheckBuildings ( ) ; var i , tmp ; begin
28712: LD_INT 0
28714: PPUSH
28715: PPUSH
28716: PPUSH
// if not mc_bases then
28717: LD_EXP 76
28721: NOT
28722: IFFALSE 28726
// exit ;
28724: GO 28832
// for i = 1 to mc_bases do
28726: LD_ADDR_VAR 0 2
28730: PUSH
28731: DOUBLE
28732: LD_INT 1
28734: DEC
28735: ST_TO_ADDR
28736: LD_EXP 76
28740: PUSH
28741: FOR_TO
28742: IFFALSE 28823
// begin tmp := UnitFilter ( mc_bases [ i ] , [ [ f_type , unit_building ] , [ f_not , [ f_lives , 1000 ] ] ] ) ;
28744: LD_ADDR_VAR 0 3
28748: PUSH
28749: LD_EXP 76
28753: PUSH
28754: LD_VAR 0 2
28758: ARRAY
28759: PPUSH
28760: LD_INT 21
28762: PUSH
28763: LD_INT 3
28765: PUSH
28766: EMPTY
28767: LIST
28768: LIST
28769: PUSH
28770: LD_INT 3
28772: PUSH
28773: LD_INT 24
28775: PUSH
28776: LD_INT 1000
28778: PUSH
28779: EMPTY
28780: LIST
28781: LIST
28782: PUSH
28783: EMPTY
28784: LIST
28785: LIST
28786: PUSH
28787: EMPTY
28788: LIST
28789: LIST
28790: PPUSH
28791: CALL_OW 72
28795: ST_TO_ADDR
// mc_building_need_repair := Replace ( mc_building_need_repair , i , tmp ) ;
28796: LD_ADDR_EXP 77
28800: PUSH
28801: LD_EXP 77
28805: PPUSH
28806: LD_VAR 0 2
28810: PPUSH
28811: LD_VAR 0 3
28815: PPUSH
28816: CALL_OW 1
28820: ST_TO_ADDR
// end ;
28821: GO 28741
28823: POP
28824: POP
// RaiseSailEvent ( 101 ) ;
28825: LD_INT 101
28827: PPUSH
28828: CALL_OW 427
// end ;
28832: LD_VAR 0 1
28836: RET
// export function MC_CheckPeopleLife ( ) ; var i , j , k , tmp , need_heal_1 , need_heal_2 ; begin
28837: LD_INT 0
28839: PPUSH
28840: PPUSH
28841: PPUSH
28842: PPUSH
28843: PPUSH
28844: PPUSH
28845: PPUSH
// if not mc_bases then
28846: LD_EXP 76
28850: NOT
28851: IFFALSE 28855
// exit ;
28853: GO 29428
// for i = 1 to mc_bases do
28855: LD_ADDR_VAR 0 2
28859: PUSH
28860: DOUBLE
28861: LD_INT 1
28863: DEC
28864: ST_TO_ADDR
28865: LD_EXP 76
28869: PUSH
28870: FOR_TO
28871: IFFALSE 29419
// begin tmp := UnitFilter ( mc_bases [ i ] union mc_ape [ i ] , [ [ f_type , unit_human ] , [ f_and , [ f_not , [ f_inside ] ] , [ f_not , [ f_lives , 800 ] ] ] ] ) ;
28873: LD_ADDR_VAR 0 5
28877: PUSH
28878: LD_EXP 76
28882: PUSH
28883: LD_VAR 0 2
28887: ARRAY
28888: PUSH
28889: LD_EXP 105
28893: PUSH
28894: LD_VAR 0 2
28898: ARRAY
28899: UNION
28900: PPUSH
28901: LD_INT 21
28903: PUSH
28904: LD_INT 1
28906: PUSH
28907: EMPTY
28908: LIST
28909: LIST
28910: PUSH
28911: LD_INT 1
28913: PUSH
28914: LD_INT 3
28916: PUSH
28917: LD_INT 54
28919: PUSH
28920: EMPTY
28921: LIST
28922: PUSH
28923: EMPTY
28924: LIST
28925: LIST
28926: PUSH
28927: LD_INT 3
28929: PUSH
28930: LD_INT 24
28932: PUSH
28933: LD_INT 800
28935: PUSH
28936: EMPTY
28937: LIST
28938: LIST
28939: PUSH
28940: EMPTY
28941: LIST
28942: LIST
28943: PUSH
28944: EMPTY
28945: LIST
28946: LIST
28947: LIST
28948: PUSH
28949: EMPTY
28950: LIST
28951: LIST
28952: PPUSH
28953: CALL_OW 72
28957: ST_TO_ADDR
// need_heal_1 := UnitFilter ( mc_bases [ i ] , [ [ f_type , unit_human ] , [ f_and , [ f_not , [ f_inside ] ] , [ f_not , [ f_lives , 250 ] ] ] ] ) ;
28958: LD_ADDR_VAR 0 6
28962: PUSH
28963: LD_EXP 76
28967: PUSH
28968: LD_VAR 0 2
28972: ARRAY
28973: PPUSH
28974: LD_INT 21
28976: PUSH
28977: LD_INT 1
28979: PUSH
28980: EMPTY
28981: LIST
28982: LIST
28983: PUSH
28984: LD_INT 1
28986: PUSH
28987: LD_INT 3
28989: PUSH
28990: LD_INT 54
28992: PUSH
28993: EMPTY
28994: LIST
28995: PUSH
28996: EMPTY
28997: LIST
28998: LIST
28999: PUSH
29000: LD_INT 3
29002: PUSH
29003: LD_INT 24
29005: PUSH
29006: LD_INT 250
29008: PUSH
29009: EMPTY
29010: LIST
29011: LIST
29012: PUSH
29013: EMPTY
29014: LIST
29015: LIST
29016: PUSH
29017: EMPTY
29018: LIST
29019: LIST
29020: LIST
29021: PUSH
29022: EMPTY
29023: LIST
29024: LIST
29025: PPUSH
29026: CALL_OW 72
29030: ST_TO_ADDR
// need_heal_2 := tmp diff need_heal_1 ;
29031: LD_ADDR_VAR 0 7
29035: PUSH
29036: LD_VAR 0 5
29040: PUSH
29041: LD_VAR 0 6
29045: DIFF
29046: ST_TO_ADDR
// if not need_heal_1 then
29047: LD_VAR 0 6
29051: NOT
29052: IFFALSE 29085
// mc_need_heal := ReplaceIn ( mc_need_heal , [ i , 1 ] , [ ] ) else
29054: LD_ADDR_EXP 79
29058: PUSH
29059: LD_EXP 79
29063: PPUSH
29064: LD_VAR 0 2
29068: PUSH
29069: LD_INT 1
29071: PUSH
29072: EMPTY
29073: LIST
29074: LIST
29075: PPUSH
29076: EMPTY
29077: PPUSH
29078: CALL 57743 0 3
29082: ST_TO_ADDR
29083: GO 29155
// mc_need_heal := ReplaceIn ( mc_need_heal , [ i , 1 ] , UnitFilter ( mc_need_heal [ i ] [ 1 ] , [ f_not , [ f_lives , 1000 ] ] ) union need_heal_1 ) ;
29085: LD_ADDR_EXP 79
29089: PUSH
29090: LD_EXP 79
29094: PPUSH
29095: LD_VAR 0 2
29099: PUSH
29100: LD_INT 1
29102: PUSH
29103: EMPTY
29104: LIST
29105: LIST
29106: PPUSH
29107: LD_EXP 79
29111: PUSH
29112: LD_VAR 0 2
29116: ARRAY
29117: PUSH
29118: LD_INT 1
29120: ARRAY
29121: PPUSH
29122: LD_INT 3
29124: PUSH
29125: LD_INT 24
29127: PUSH
29128: LD_INT 1000
29130: PUSH
29131: EMPTY
29132: LIST
29133: LIST
29134: PUSH
29135: EMPTY
29136: LIST
29137: LIST
29138: PPUSH
29139: CALL_OW 72
29143: PUSH
29144: LD_VAR 0 6
29148: UNION
29149: PPUSH
29150: CALL 57743 0 3
29154: ST_TO_ADDR
// if not need_heal_2 then
29155: LD_VAR 0 7
29159: NOT
29160: IFFALSE 29193
// mc_need_heal := ReplaceIn ( mc_need_heal , [ i , 2 ] , [ ] ) else
29162: LD_ADDR_EXP 79
29166: PUSH
29167: LD_EXP 79
29171: PPUSH
29172: LD_VAR 0 2
29176: PUSH
29177: LD_INT 2
29179: PUSH
29180: EMPTY
29181: LIST
29182: LIST
29183: PPUSH
29184: EMPTY
29185: PPUSH
29186: CALL 57743 0 3
29190: ST_TO_ADDR
29191: GO 29225
// mc_need_heal := ReplaceIn ( mc_need_heal , [ i , 2 ] , need_heal_2 ) ;
29193: LD_ADDR_EXP 79
29197: PUSH
29198: LD_EXP 79
29202: PPUSH
29203: LD_VAR 0 2
29207: PUSH
29208: LD_INT 2
29210: PUSH
29211: EMPTY
29212: LIST
29213: LIST
29214: PPUSH
29215: LD_VAR 0 7
29219: PPUSH
29220: CALL 57743 0 3
29224: ST_TO_ADDR
// if need_heal_2 then
29225: LD_VAR 0 7
29229: IFFALSE 29401
// for j in need_heal_2 do
29231: LD_ADDR_VAR 0 3
29235: PUSH
29236: LD_VAR 0 7
29240: PUSH
29241: FOR_IN
29242: IFFALSE 29399
// begin tmp := UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_lab ] , [ f_btype , b_lab_half ] , [ f_btype , b_lab_full ] , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] , [ f_class , 4 ] ] ) ;
29244: LD_ADDR_VAR 0 5
29248: PUSH
29249: LD_EXP 76
29253: PUSH
29254: LD_VAR 0 2
29258: ARRAY
29259: PPUSH
29260: LD_INT 2
29262: PUSH
29263: LD_INT 30
29265: PUSH
29266: LD_INT 6
29268: PUSH
29269: EMPTY
29270: LIST
29271: LIST
29272: PUSH
29273: LD_INT 30
29275: PUSH
29276: LD_INT 7
29278: PUSH
29279: EMPTY
29280: LIST
29281: LIST
29282: PUSH
29283: LD_INT 30
29285: PUSH
29286: LD_INT 8
29288: PUSH
29289: EMPTY
29290: LIST
29291: LIST
29292: PUSH
29293: LD_INT 30
29295: PUSH
29296: LD_INT 0
29298: PUSH
29299: EMPTY
29300: LIST
29301: LIST
29302: PUSH
29303: LD_INT 30
29305: PUSH
29306: LD_INT 1
29308: PUSH
29309: EMPTY
29310: LIST
29311: LIST
29312: PUSH
29313: LD_INT 25
29315: PUSH
29316: LD_INT 4
29318: PUSH
29319: EMPTY
29320: LIST
29321: LIST
29322: PUSH
29323: EMPTY
29324: LIST
29325: LIST
29326: LIST
29327: LIST
29328: LIST
29329: LIST
29330: LIST
29331: PPUSH
29332: CALL_OW 72
29336: ST_TO_ADDR
// if tmp then
29337: LD_VAR 0 5
29341: IFFALSE 29397
// begin k := NearestUnitToUnit ( tmp , j ) ;
29343: LD_ADDR_VAR 0 4
29347: PUSH
29348: LD_VAR 0 5
29352: PPUSH
29353: LD_VAR 0 3
29357: PPUSH
29358: CALL_OW 74
29362: ST_TO_ADDR
// if GetDistUnits ( j , k ) > 7 then
29363: LD_VAR 0 3
29367: PPUSH
29368: LD_VAR 0 4
29372: PPUSH
29373: CALL_OW 296
29377: PUSH
29378: LD_INT 7
29380: GREATER
29381: IFFALSE 29397
// ComMoveUnit ( j , k ) ;
29383: LD_VAR 0 3
29387: PPUSH
29388: LD_VAR 0 4
29392: PPUSH
29393: CALL_OW 112
// end ; end ;
29397: GO 29241
29399: POP
29400: POP
// if not need_heal_1 and not need_heal_2 then
29401: LD_VAR 0 6
29405: NOT
29406: PUSH
29407: LD_VAR 0 7
29411: NOT
29412: AND
29413: IFFALSE 29417
// continue ;
29415: GO 28870
// end ;
29417: GO 28870
29419: POP
29420: POP
// RaiseSailEvent ( 102 ) ;
29421: LD_INT 102
29423: PPUSH
29424: CALL_OW 427
// end ;
29428: LD_VAR 0 1
29432: RET
// export function MC_RepairBuildings ( ) ; var i , j , un , tmp , cranes , to_repair_tmp , to_repair ; begin
29433: LD_INT 0
29435: PPUSH
29436: PPUSH
29437: PPUSH
29438: PPUSH
29439: PPUSH
29440: PPUSH
29441: PPUSH
29442: PPUSH
// if not mc_bases then
29443: LD_EXP 76
29447: NOT
29448: IFFALSE 29452
// exit ;
29450: GO 30292
// for i = 1 to mc_bases do
29452: LD_ADDR_VAR 0 2
29456: PUSH
29457: DOUBLE
29458: LD_INT 1
29460: DEC
29461: ST_TO_ADDR
29462: LD_EXP 76
29466: PUSH
29467: FOR_TO
29468: IFFALSE 30290
// begin if not mc_building_need_repair [ i ] then
29470: LD_EXP 77
29474: PUSH
29475: LD_VAR 0 2
29479: ARRAY
29480: NOT
29481: IFFALSE 29655
// begin cranes := UnitFilter ( mc_vehicles [ i ] , [ [ f_not , [ f_lives , 1000 ] ] , [ f_or , [ f_weapon , us_crane ] , [ f_weapon , ru_crane ] ] ] ) ;
29483: LD_ADDR_VAR 0 6
29487: PUSH
29488: LD_EXP 95
29492: PUSH
29493: LD_VAR 0 2
29497: ARRAY
29498: PPUSH
29499: LD_INT 3
29501: PUSH
29502: LD_INT 24
29504: PUSH
29505: LD_INT 1000
29507: PUSH
29508: EMPTY
29509: LIST
29510: LIST
29511: PUSH
29512: EMPTY
29513: LIST
29514: LIST
29515: PUSH
29516: LD_INT 2
29518: PUSH
29519: LD_INT 34
29521: PUSH
29522: LD_INT 13
29524: PUSH
29525: EMPTY
29526: LIST
29527: LIST
29528: PUSH
29529: LD_INT 34
29531: PUSH
29532: LD_INT 52
29534: PUSH
29535: EMPTY
29536: LIST
29537: LIST
29538: PUSH
29539: EMPTY
29540: LIST
29541: LIST
29542: LIST
29543: PUSH
29544: EMPTY
29545: LIST
29546: LIST
29547: PPUSH
29548: CALL_OW 72
29552: ST_TO_ADDR
// if cranes then
29553: LD_VAR 0 6
29557: IFFALSE 29619
// for j in cranes do
29559: LD_ADDR_VAR 0 3
29563: PUSH
29564: LD_VAR 0 6
29568: PUSH
29569: FOR_IN
29570: IFFALSE 29617
// if not IsInArea ( j , mc_parking [ i ] ) then
29572: LD_VAR 0 3
29576: PPUSH
29577: LD_EXP 100
29581: PUSH
29582: LD_VAR 0 2
29586: ARRAY
29587: PPUSH
29588: CALL_OW 308
29592: NOT
29593: IFFALSE 29615
// ComMoveToArea ( j , mc_parking [ i ] ) ;
29595: LD_VAR 0 3
29599: PPUSH
29600: LD_EXP 100
29604: PUSH
29605: LD_VAR 0 2
29609: ARRAY
29610: PPUSH
29611: CALL_OW 113
29615: GO 29569
29617: POP
29618: POP
// mc_building_repairs := Replace ( mc_building_repairs , i , [ ] ) ;
29619: LD_ADDR_EXP 78
29623: PUSH
29624: LD_EXP 78
29628: PPUSH
29629: LD_VAR 0 2
29633: PPUSH
29634: EMPTY
29635: PPUSH
29636: CALL_OW 1
29640: ST_TO_ADDR
// MC_Reset ( i , 101 ) ;
29641: LD_VAR 0 2
29645: PPUSH
29646: LD_INT 101
29648: PPUSH
29649: CALL 24545 0 2
// continue ;
29653: GO 29467
// end ; mc_builders := Replace ( mc_builders , i , [ ] ) ;
29655: LD_ADDR_EXP 82
29659: PUSH
29660: LD_EXP 82
29664: PPUSH
29665: LD_VAR 0 2
29669: PPUSH
29670: EMPTY
29671: PPUSH
29672: CALL_OW 1
29676: ST_TO_ADDR
// MC_Reset ( i , 103 ) ;
29677: LD_VAR 0 2
29681: PPUSH
29682: LD_INT 103
29684: PPUSH
29685: CALL 24545 0 2
// tmp := UnitFilter ( mc_bases [ i ] union mc_ape [ i ] , [ [ f_or , [ f_class , 2 ] , [ f_class , 16 ] ] ] ) ;
29689: LD_ADDR_VAR 0 5
29693: PUSH
29694: LD_EXP 76
29698: PUSH
29699: LD_VAR 0 2
29703: ARRAY
29704: PUSH
29705: LD_EXP 105
29709: PUSH
29710: LD_VAR 0 2
29714: ARRAY
29715: UNION
29716: PPUSH
29717: LD_INT 2
29719: PUSH
29720: LD_INT 25
29722: PUSH
29723: LD_INT 2
29725: PUSH
29726: EMPTY
29727: LIST
29728: LIST
29729: PUSH
29730: LD_INT 25
29732: PUSH
29733: LD_INT 16
29735: PUSH
29736: EMPTY
29737: LIST
29738: LIST
29739: PUSH
29740: EMPTY
29741: LIST
29742: LIST
29743: LIST
29744: PUSH
29745: EMPTY
29746: LIST
29747: PPUSH
29748: CALL_OW 72
29752: ST_TO_ADDR
// cranes := UnitFilter ( mc_vehicles [ i ] , [ f_or , [ f_weapon , us_crane ] , [ f_weapon , ru_crane ] ] ) ;
29753: LD_ADDR_VAR 0 6
29757: PUSH
29758: LD_EXP 95
29762: PUSH
29763: LD_VAR 0 2
29767: ARRAY
29768: PPUSH
29769: LD_INT 2
29771: PUSH
29772: LD_INT 34
29774: PUSH
29775: LD_INT 13
29777: PUSH
29778: EMPTY
29779: LIST
29780: LIST
29781: PUSH
29782: LD_INT 34
29784: PUSH
29785: LD_INT 52
29787: PUSH
29788: EMPTY
29789: LIST
29790: LIST
29791: PUSH
29792: EMPTY
29793: LIST
29794: LIST
29795: LIST
29796: PPUSH
29797: CALL_OW 72
29801: ST_TO_ADDR
// if cranes then
29802: LD_VAR 0 6
29806: IFFALSE 29942
// begin for j in cranes do
29808: LD_ADDR_VAR 0 3
29812: PUSH
29813: LD_VAR 0 6
29817: PUSH
29818: FOR_IN
29819: IFFALSE 29940
// if GetLives ( j ) >= 500 and not HasTask ( j ) then
29821: LD_VAR 0 3
29825: PPUSH
29826: CALL_OW 256
29830: PUSH
29831: LD_INT 500
29833: GREATEREQUAL
29834: PUSH
29835: LD_VAR 0 3
29839: PPUSH
29840: CALL_OW 314
29844: NOT
29845: AND
29846: IFFALSE 29880
// ComRepairBuilding ( j , NearestUnitToUnit ( mc_building_need_repair [ i ] , j ) ) else
29848: LD_VAR 0 3
29852: PPUSH
29853: LD_EXP 77
29857: PUSH
29858: LD_VAR 0 2
29862: ARRAY
29863: PPUSH
29864: LD_VAR 0 3
29868: PPUSH
29869: CALL_OW 74
29873: PPUSH
29874: CALL_OW 130
29878: GO 29938
// if GetLives ( j ) < 500 and not IsInArea ( j , mc_parking [ i ] ) then
29880: LD_VAR 0 3
29884: PPUSH
29885: CALL_OW 256
29889: PUSH
29890: LD_INT 500
29892: LESS
29893: PUSH
29894: LD_VAR 0 3
29898: PPUSH
29899: LD_EXP 100
29903: PUSH
29904: LD_VAR 0 2
29908: ARRAY
29909: PPUSH
29910: CALL_OW 308
29914: NOT
29915: AND
29916: IFFALSE 29938
// ComMoveToArea ( j , mc_parking [ i ] ) ;
29918: LD_VAR 0 3
29922: PPUSH
29923: LD_EXP 100
29927: PUSH
29928: LD_VAR 0 2
29932: ARRAY
29933: PPUSH
29934: CALL_OW 113
29938: GO 29818
29940: POP
29941: POP
// end ; if not tmp then
29942: LD_VAR 0 5
29946: NOT
29947: IFFALSE 29951
// continue ;
29949: GO 29467
// for j in tmp do
29951: LD_ADDR_VAR 0 3
29955: PUSH
29956: LD_VAR 0 5
29960: PUSH
29961: FOR_IN
29962: IFFALSE 30286
// begin if mc_need_heal [ i ] then
29964: LD_EXP 79
29968: PUSH
29969: LD_VAR 0 2
29973: ARRAY
29974: IFFALSE 30022
// if j in mc_need_heal [ i ] [ 1 ] or j in mc_need_heal [ i ] [ 2 ] then
29976: LD_VAR 0 3
29980: PUSH
29981: LD_EXP 79
29985: PUSH
29986: LD_VAR 0 2
29990: ARRAY
29991: PUSH
29992: LD_INT 1
29994: ARRAY
29995: IN
29996: PUSH
29997: LD_VAR 0 3
30001: PUSH
30002: LD_EXP 79
30006: PUSH
30007: LD_VAR 0 2
30011: ARRAY
30012: PUSH
30013: LD_INT 2
30015: ARRAY
30016: IN
30017: OR
30018: IFFALSE 30022
// continue ;
30020: GO 29961
// if IsInUnit ( j ) then
30022: LD_VAR 0 3
30026: PPUSH
30027: CALL_OW 310
30031: IFFALSE 30042
// ComExitBuilding ( j ) ;
30033: LD_VAR 0 3
30037: PPUSH
30038: CALL_OW 122
// if not j in mc_building_repairs [ i ] then
30042: LD_VAR 0 3
30046: PUSH
30047: LD_EXP 78
30051: PUSH
30052: LD_VAR 0 2
30056: ARRAY
30057: IN
30058: NOT
30059: IFFALSE 30117
// begin SetTag ( j , 101 ) ;
30061: LD_VAR 0 3
30065: PPUSH
30066: LD_INT 101
30068: PPUSH
30069: CALL_OW 109
// mc_building_repairs := ReplaceIn ( mc_building_repairs , [ i , mc_building_repairs [ i ] + 1 ] , j ) ;
30073: LD_ADDR_EXP 78
30077: PUSH
30078: LD_EXP 78
30082: PPUSH
30083: LD_VAR 0 2
30087: PUSH
30088: LD_EXP 78
30092: PUSH
30093: LD_VAR 0 2
30097: ARRAY
30098: PUSH
30099: LD_INT 1
30101: PLUS
30102: PUSH
30103: EMPTY
30104: LIST
30105: LIST
30106: PPUSH
30107: LD_VAR 0 3
30111: PPUSH
30112: CALL 57743 0 3
30116: ST_TO_ADDR
// end ; wait ( 1 ) ;
30117: LD_INT 1
30119: PPUSH
30120: CALL_OW 67
// to_repair_tmp := mc_building_need_repair [ i ] ;
30124: LD_ADDR_VAR 0 7
30128: PUSH
30129: LD_EXP 77
30133: PUSH
30134: LD_VAR 0 2
30138: ARRAY
30139: ST_TO_ADDR
// if mc_scan [ i ] then
30140: LD_EXP 99
30144: PUSH
30145: LD_VAR 0 2
30149: ARRAY
30150: IFFALSE 30219
// to_repair_tmp := UnitFilter ( mc_building_need_repair [ i ] , [ f_not , [ f_or , [ f_btype , b_bunker ] , [ f_btype , b_turret ] , [ f_btype , b_breastwork ] ] ] ) ;
30152: LD_ADDR_VAR 0 7
30156: PUSH
30157: LD_EXP 77
30161: PUSH
30162: LD_VAR 0 2
30166: ARRAY
30167: PPUSH
30168: LD_INT 3
30170: PUSH
30171: LD_INT 2
30173: PUSH
30174: LD_INT 30
30176: PUSH
30177: LD_INT 32
30179: PUSH
30180: EMPTY
30181: LIST
30182: LIST
30183: PUSH
30184: LD_INT 30
30186: PUSH
30187: LD_INT 33
30189: PUSH
30190: EMPTY
30191: LIST
30192: LIST
30193: PUSH
30194: LD_INT 30
30196: PUSH
30197: LD_INT 31
30199: PUSH
30200: EMPTY
30201: LIST
30202: LIST
30203: PUSH
30204: EMPTY
30205: LIST
30206: LIST
30207: LIST
30208: LIST
30209: PUSH
30210: EMPTY
30211: LIST
30212: LIST
30213: PPUSH
30214: CALL_OW 72
30218: ST_TO_ADDR
// if not to_repair_tmp then
30219: LD_VAR 0 7
30223: NOT
30224: IFFALSE 30228
// continue ;
30226: GO 29961
// to_repair := NearestUnitToUnit ( to_repair_tmp , j ) ;
30228: LD_ADDR_VAR 0 8
30232: PUSH
30233: LD_VAR 0 7
30237: PPUSH
30238: LD_VAR 0 3
30242: PPUSH
30243: CALL_OW 74
30247: ST_TO_ADDR
// if DangerAtRange ( to_repair , 14 ) [ 4 ] < 5 then
30248: LD_VAR 0 8
30252: PPUSH
30253: LD_INT 14
30255: PPUSH
30256: CALL 60336 0 2
30260: PUSH
30261: LD_INT 4
30263: ARRAY
30264: PUSH
30265: LD_INT 5
30267: LESS
30268: IFFALSE 30284
// ComRepairBuilding ( j , to_repair ) ;
30270: LD_VAR 0 3
30274: PPUSH
30275: LD_VAR 0 8
30279: PPUSH
30280: CALL_OW 130
// end ;
30284: GO 29961
30286: POP
30287: POP
// end ;
30288: GO 29467
30290: POP
30291: POP
// end ;
30292: LD_VAR 0 1
30296: RET
// export function MC_Heal ; var i , j , tmp ; begin
30297: LD_INT 0
30299: PPUSH
30300: PPUSH
30301: PPUSH
30302: PPUSH
// if not mc_bases then
30303: LD_EXP 76
30307: NOT
30308: IFFALSE 30312
// exit ;
30310: GO 30714
// for i = 1 to mc_bases do
30312: LD_ADDR_VAR 0 2
30316: PUSH
30317: DOUBLE
30318: LD_INT 1
30320: DEC
30321: ST_TO_ADDR
30322: LD_EXP 76
30326: PUSH
30327: FOR_TO
30328: IFFALSE 30712
// begin if not mc_need_heal [ i ] [ 1 ] and not mc_need_heal [ i ] [ 2 ] then
30330: LD_EXP 79
30334: PUSH
30335: LD_VAR 0 2
30339: ARRAY
30340: PUSH
30341: LD_INT 1
30343: ARRAY
30344: NOT
30345: PUSH
30346: LD_EXP 79
30350: PUSH
30351: LD_VAR 0 2
30355: ARRAY
30356: PUSH
30357: LD_INT 2
30359: ARRAY
30360: NOT
30361: AND
30362: IFFALSE 30400
// begin mc_healers := Replace ( mc_healers , i , [ ] ) ;
30364: LD_ADDR_EXP 80
30368: PUSH
30369: LD_EXP 80
30373: PPUSH
30374: LD_VAR 0 2
30378: PPUSH
30379: EMPTY
30380: PPUSH
30381: CALL_OW 1
30385: ST_TO_ADDR
// MC_Reset ( i , 102 ) ;
30386: LD_VAR 0 2
30390: PPUSH
30391: LD_INT 102
30393: PPUSH
30394: CALL 24545 0 2
// continue ;
30398: GO 30327
// end ; tmp := UnitFilter ( mc_bases [ i ] , [ f_class , 4 ] ) ;
30400: LD_ADDR_VAR 0 4
30404: PUSH
30405: LD_EXP 76
30409: PUSH
30410: LD_VAR 0 2
30414: ARRAY
30415: PPUSH
30416: LD_INT 25
30418: PUSH
30419: LD_INT 4
30421: PUSH
30422: EMPTY
30423: LIST
30424: LIST
30425: PPUSH
30426: CALL_OW 72
30430: ST_TO_ADDR
// if not tmp then
30431: LD_VAR 0 4
30435: NOT
30436: IFFALSE 30440
// continue ;
30438: GO 30327
// if mc_taming [ i ] then
30440: LD_EXP 107
30444: PUSH
30445: LD_VAR 0 2
30449: ARRAY
30450: IFFALSE 30474
// mc_taming := Replace ( mc_taming , i , [ ] ) ;
30452: LD_ADDR_EXP 107
30456: PUSH
30457: LD_EXP 107
30461: PPUSH
30462: LD_VAR 0 2
30466: PPUSH
30467: EMPTY
30468: PPUSH
30469: CALL_OW 1
30473: ST_TO_ADDR
// for j in tmp do
30474: LD_ADDR_VAR 0 3
30478: PUSH
30479: LD_VAR 0 4
30483: PUSH
30484: FOR_IN
30485: IFFALSE 30708
// begin if IsInUnit ( j ) then
30487: LD_VAR 0 3
30491: PPUSH
30492: CALL_OW 310
30496: IFFALSE 30507
// ComExitBuilding ( j ) ;
30498: LD_VAR 0 3
30502: PPUSH
30503: CALL_OW 122
// if not j in mc_healers [ i ] then
30507: LD_VAR 0 3
30511: PUSH
30512: LD_EXP 80
30516: PUSH
30517: LD_VAR 0 2
30521: ARRAY
30522: IN
30523: NOT
30524: IFFALSE 30570
// mc_healers := ReplaceIn ( mc_healers , [ i , mc_healers [ i ] + 1 ] , j ) ;
30526: LD_ADDR_EXP 80
30530: PUSH
30531: LD_EXP 80
30535: PPUSH
30536: LD_VAR 0 2
30540: PUSH
30541: LD_EXP 80
30545: PUSH
30546: LD_VAR 0 2
30550: ARRAY
30551: PUSH
30552: LD_INT 1
30554: PLUS
30555: PUSH
30556: EMPTY
30557: LIST
30558: LIST
30559: PPUSH
30560: LD_VAR 0 3
30564: PPUSH
30565: CALL 57743 0 3
30569: ST_TO_ADDR
// if GetTag ( j ) <> 102 then
30570: LD_VAR 0 3
30574: PPUSH
30575: CALL_OW 110
30579: PUSH
30580: LD_INT 102
30582: NONEQUAL
30583: IFFALSE 30597
// SetTag ( j , 102 ) ;
30585: LD_VAR 0 3
30589: PPUSH
30590: LD_INT 102
30592: PPUSH
30593: CALL_OW 109
// Wait ( 3 ) ;
30597: LD_INT 3
30599: PPUSH
30600: CALL_OW 67
// if mc_need_heal [ i ] [ 1 ] then
30604: LD_EXP 79
30608: PUSH
30609: LD_VAR 0 2
30613: ARRAY
30614: PUSH
30615: LD_INT 1
30617: ARRAY
30618: IFFALSE 30650
// ComHeal ( j , mc_need_heal [ i ] [ 1 ] [ 1 ] ) else
30620: LD_VAR 0 3
30624: PPUSH
30625: LD_EXP 79
30629: PUSH
30630: LD_VAR 0 2
30634: ARRAY
30635: PUSH
30636: LD_INT 1
30638: ARRAY
30639: PUSH
30640: LD_INT 1
30642: ARRAY
30643: PPUSH
30644: CALL_OW 128
30648: GO 30706
// if not HasTask ( j ) and mc_need_heal [ i ] [ 2 ] then
30650: LD_VAR 0 3
30654: PPUSH
30655: CALL_OW 314
30659: NOT
30660: PUSH
30661: LD_EXP 79
30665: PUSH
30666: LD_VAR 0 2
30670: ARRAY
30671: PUSH
30672: LD_INT 2
30674: ARRAY
30675: AND
30676: IFFALSE 30706
// ComHeal ( j , mc_need_heal [ i ] [ 2 ] [ 1 ] ) ;
30678: LD_VAR 0 3
30682: PPUSH
30683: LD_EXP 79
30687: PUSH
30688: LD_VAR 0 2
30692: ARRAY
30693: PUSH
30694: LD_INT 2
30696: ARRAY
30697: PUSH
30698: LD_INT 1
30700: ARRAY
30701: PPUSH
30702: CALL_OW 128
// end ;
30706: GO 30484
30708: POP
30709: POP
// end ;
30710: GO 30327
30712: POP
30713: POP
// end ;
30714: LD_VAR 0 1
30718: RET
// export function MC_Build ( ) ; var i , j , tmp , depot ; begin
30719: LD_INT 0
30721: PPUSH
30722: PPUSH
30723: PPUSH
30724: PPUSH
30725: PPUSH
// if not mc_bases then
30726: LD_EXP 76
30730: NOT
30731: IFFALSE 30735
// exit ;
30733: GO 31878
// for i = 1 to mc_bases do
30735: LD_ADDR_VAR 0 2
30739: PUSH
30740: DOUBLE
30741: LD_INT 1
30743: DEC
30744: ST_TO_ADDR
30745: LD_EXP 76
30749: PUSH
30750: FOR_TO
30751: IFFALSE 31876
// begin if mc_scan [ i ] then
30753: LD_EXP 99
30757: PUSH
30758: LD_VAR 0 2
30762: ARRAY
30763: IFFALSE 30767
// continue ;
30765: GO 30750
// if not mc_build_list [ i ] and not mc_construct_list [ i ] and mc_builders [ i ] then
30767: LD_EXP 81
30771: PUSH
30772: LD_VAR 0 2
30776: ARRAY
30777: NOT
30778: PUSH
30779: LD_EXP 83
30783: PUSH
30784: LD_VAR 0 2
30788: ARRAY
30789: NOT
30790: AND
30791: PUSH
30792: LD_EXP 82
30796: PUSH
30797: LD_VAR 0 2
30801: ARRAY
30802: AND
30803: IFFALSE 30841
// begin mc_builders := Replace ( mc_builders , i , [ ] ) ;
30805: LD_ADDR_EXP 82
30809: PUSH
30810: LD_EXP 82
30814: PPUSH
30815: LD_VAR 0 2
30819: PPUSH
30820: EMPTY
30821: PPUSH
30822: CALL_OW 1
30826: ST_TO_ADDR
// MC_Reset ( i , 103 ) ;
30827: LD_VAR 0 2
30831: PPUSH
30832: LD_INT 103
30834: PPUSH
30835: CALL 24545 0 2
// continue ;
30839: GO 30750
// end ; if mc_construct_list [ i ] then
30841: LD_EXP 83
30845: PUSH
30846: LD_VAR 0 2
30850: ARRAY
30851: IFFALSE 31071
// begin tmp := UnitFilter ( mc_bases [ i ] , [ f_class , 2 ] ) diff mc_building_repairs [ i ] ;
30853: LD_ADDR_VAR 0 4
30857: PUSH
30858: LD_EXP 76
30862: PUSH
30863: LD_VAR 0 2
30867: ARRAY
30868: PPUSH
30869: LD_INT 25
30871: PUSH
30872: LD_INT 2
30874: PUSH
30875: EMPTY
30876: LIST
30877: LIST
30878: PPUSH
30879: CALL_OW 72
30883: PUSH
30884: LD_EXP 78
30888: PUSH
30889: LD_VAR 0 2
30893: ARRAY
30894: DIFF
30895: ST_TO_ADDR
// if not tmp then
30896: LD_VAR 0 4
30900: NOT
30901: IFFALSE 30905
// continue ;
30903: GO 30750
// for j in tmp do
30905: LD_ADDR_VAR 0 3
30909: PUSH
30910: LD_VAR 0 4
30914: PUSH
30915: FOR_IN
30916: IFFALSE 31067
// begin if not mc_builders [ i ] then
30918: LD_EXP 82
30922: PUSH
30923: LD_VAR 0 2
30927: ARRAY
30928: NOT
30929: IFFALSE 30987
// begin SetTag ( j , 103 ) ;
30931: LD_VAR 0 3
30935: PPUSH
30936: LD_INT 103
30938: PPUSH
30939: CALL_OW 109
// mc_builders := ReplaceIn ( mc_builders , [ i , mc_builders [ i ] + 1 ] , j ) ;
30943: LD_ADDR_EXP 82
30947: PUSH
30948: LD_EXP 82
30952: PPUSH
30953: LD_VAR 0 2
30957: PUSH
30958: LD_EXP 82
30962: PUSH
30963: LD_VAR 0 2
30967: ARRAY
30968: PUSH
30969: LD_INT 1
30971: PLUS
30972: PUSH
30973: EMPTY
30974: LIST
30975: LIST
30976: PPUSH
30977: LD_VAR 0 3
30981: PPUSH
30982: CALL 57743 0 3
30986: ST_TO_ADDR
// end ; if IsInUnit ( j ) then
30987: LD_VAR 0 3
30991: PPUSH
30992: CALL_OW 310
30996: IFFALSE 31007
// ComExitBuilding ( j ) ;
30998: LD_VAR 0 3
31002: PPUSH
31003: CALL_OW 122
// wait ( 3 ) ;
31007: LD_INT 3
31009: PPUSH
31010: CALL_OW 67
// if not mc_construct_list [ i ] then
31014: LD_EXP 83
31018: PUSH
31019: LD_VAR 0 2
31023: ARRAY
31024: NOT
31025: IFFALSE 31029
// break ;
31027: GO 31067
// if not HasTask ( j ) then
31029: LD_VAR 0 3
31033: PPUSH
31034: CALL_OW 314
31038: NOT
31039: IFFALSE 31065
// ComComplete ( j , mc_construct_list [ i ] [ 1 ] ) ;
31041: LD_VAR 0 3
31045: PPUSH
31046: LD_EXP 83
31050: PUSH
31051: LD_VAR 0 2
31055: ARRAY
31056: PUSH
31057: LD_INT 1
31059: ARRAY
31060: PPUSH
31061: CALL 60594 0 2
// end ;
31065: GO 30915
31067: POP
31068: POP
// end else
31069: GO 31874
// if mc_build_list [ i ] then
31071: LD_EXP 81
31075: PUSH
31076: LD_VAR 0 2
31080: ARRAY
31081: IFFALSE 31874
// begin depot := UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) ;
31083: LD_ADDR_VAR 0 5
31087: PUSH
31088: LD_EXP 76
31092: PUSH
31093: LD_VAR 0 2
31097: ARRAY
31098: PPUSH
31099: LD_INT 2
31101: PUSH
31102: LD_INT 30
31104: PUSH
31105: LD_INT 0
31107: PUSH
31108: EMPTY
31109: LIST
31110: LIST
31111: PUSH
31112: LD_INT 30
31114: PUSH
31115: LD_INT 1
31117: PUSH
31118: EMPTY
31119: LIST
31120: LIST
31121: PUSH
31122: EMPTY
31123: LIST
31124: LIST
31125: LIST
31126: PPUSH
31127: CALL_OW 72
31131: ST_TO_ADDR
// if depot then
31132: LD_VAR 0 5
31136: IFFALSE 31154
// depot := depot [ 1 ] else
31138: LD_ADDR_VAR 0 5
31142: PUSH
31143: LD_VAR 0 5
31147: PUSH
31148: LD_INT 1
31150: ARRAY
31151: ST_TO_ADDR
31152: GO 31162
// depot := 0 ;
31154: LD_ADDR_VAR 0 5
31158: PUSH
31159: LD_INT 0
31161: ST_TO_ADDR
// if IsExtension ( mc_build_list [ i ] [ 1 ] [ 1 ] ) and not UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_workshop ] , [ f_btype , b_factory ] ] ) then
31162: LD_EXP 81
31166: PUSH
31167: LD_VAR 0 2
31171: ARRAY
31172: PUSH
31173: LD_INT 1
31175: ARRAY
31176: PUSH
31177: LD_INT 1
31179: ARRAY
31180: PPUSH
31181: CALL 60424 0 1
31185: PUSH
31186: LD_EXP 76
31190: PUSH
31191: LD_VAR 0 2
31195: ARRAY
31196: PPUSH
31197: LD_INT 2
31199: PUSH
31200: LD_INT 30
31202: PUSH
31203: LD_INT 2
31205: PUSH
31206: EMPTY
31207: LIST
31208: LIST
31209: PUSH
31210: LD_INT 30
31212: PUSH
31213: LD_INT 3
31215: PUSH
31216: EMPTY
31217: LIST
31218: LIST
31219: PUSH
31220: EMPTY
31221: LIST
31222: LIST
31223: LIST
31224: PPUSH
31225: CALL_OW 72
31229: NOT
31230: AND
31231: IFFALSE 31336
// begin for j = 1 to mc_build_list [ i ] do
31233: LD_ADDR_VAR 0 3
31237: PUSH
31238: DOUBLE
31239: LD_INT 1
31241: DEC
31242: ST_TO_ADDR
31243: LD_EXP 81
31247: PUSH
31248: LD_VAR 0 2
31252: ARRAY
31253: PUSH
31254: FOR_TO
31255: IFFALSE 31334
// if mc_build_list [ i ] [ j ] [ 1 ] = b_workshop then
31257: LD_EXP 81
31261: PUSH
31262: LD_VAR 0 2
31266: ARRAY
31267: PUSH
31268: LD_VAR 0 3
31272: ARRAY
31273: PUSH
31274: LD_INT 1
31276: ARRAY
31277: PUSH
31278: LD_INT 2
31280: EQUAL
31281: IFFALSE 31332
// begin mc_build_list := Replace ( mc_build_list , i , Reindex ( mc_build_list [ i ] , j , 1 , false ) ) ;
31283: LD_ADDR_EXP 81
31287: PUSH
31288: LD_EXP 81
31292: PPUSH
31293: LD_VAR 0 2
31297: PPUSH
31298: LD_EXP 81
31302: PUSH
31303: LD_VAR 0 2
31307: ARRAY
31308: PPUSH
31309: LD_VAR 0 3
31313: PPUSH
31314: LD_INT 1
31316: PPUSH
31317: LD_INT 0
31319: PPUSH
31320: CALL 57161 0 4
31324: PPUSH
31325: CALL_OW 1
31329: ST_TO_ADDR
// break ;
31330: GO 31334
// end ;
31332: GO 31254
31334: POP
31335: POP
// end ; if mc_build_list [ i ] [ 1 ] [ 1 ] = b_depot or ( depot and CanBeBuilt ( depot , mc_build_list [ i ] [ 1 ] [ 1 ] , mc_build_list [ i ] [ 1 ] [ 2 ] , mc_build_list [ i ] [ 1 ] [ 3 ] , mc_build_list [ i ] [ 1 ] [ 4 ] ) ) then
31336: LD_EXP 81
31340: PUSH
31341: LD_VAR 0 2
31345: ARRAY
31346: PUSH
31347: LD_INT 1
31349: ARRAY
31350: PUSH
31351: LD_INT 1
31353: ARRAY
31354: PUSH
31355: LD_INT 0
31357: EQUAL
31358: PUSH
31359: LD_VAR 0 5
31363: PUSH
31364: LD_VAR 0 5
31368: PPUSH
31369: LD_EXP 81
31373: PUSH
31374: LD_VAR 0 2
31378: ARRAY
31379: PUSH
31380: LD_INT 1
31382: ARRAY
31383: PUSH
31384: LD_INT 1
31386: ARRAY
31387: PPUSH
31388: LD_EXP 81
31392: PUSH
31393: LD_VAR 0 2
31397: ARRAY
31398: PUSH
31399: LD_INT 1
31401: ARRAY
31402: PUSH
31403: LD_INT 2
31405: ARRAY
31406: PPUSH
31407: LD_EXP 81
31411: PUSH
31412: LD_VAR 0 2
31416: ARRAY
31417: PUSH
31418: LD_INT 1
31420: ARRAY
31421: PUSH
31422: LD_INT 3
31424: ARRAY
31425: PPUSH
31426: LD_EXP 81
31430: PUSH
31431: LD_VAR 0 2
31435: ARRAY
31436: PUSH
31437: LD_INT 1
31439: ARRAY
31440: PUSH
31441: LD_INT 4
31443: ARRAY
31444: PPUSH
31445: CALL 65158 0 5
31449: AND
31450: OR
31451: IFFALSE 31732
// begin tmp := UnitFilter ( mc_bases [ i ] , [ f_class , 2 ] ) diff mc_building_repairs [ i ] ;
31453: LD_ADDR_VAR 0 4
31457: PUSH
31458: LD_EXP 76
31462: PUSH
31463: LD_VAR 0 2
31467: ARRAY
31468: PPUSH
31469: LD_INT 25
31471: PUSH
31472: LD_INT 2
31474: PUSH
31475: EMPTY
31476: LIST
31477: LIST
31478: PPUSH
31479: CALL_OW 72
31483: PUSH
31484: LD_EXP 78
31488: PUSH
31489: LD_VAR 0 2
31493: ARRAY
31494: DIFF
31495: ST_TO_ADDR
// if not tmp then
31496: LD_VAR 0 4
31500: NOT
31501: IFFALSE 31505
// continue ;
31503: GO 30750
// for j in tmp do
31505: LD_ADDR_VAR 0 3
31509: PUSH
31510: LD_VAR 0 4
31514: PUSH
31515: FOR_IN
31516: IFFALSE 31728
// begin if not mc_builders [ i ] then
31518: LD_EXP 82
31522: PUSH
31523: LD_VAR 0 2
31527: ARRAY
31528: NOT
31529: IFFALSE 31587
// begin SetTag ( j , 103 ) ;
31531: LD_VAR 0 3
31535: PPUSH
31536: LD_INT 103
31538: PPUSH
31539: CALL_OW 109
// mc_builders := ReplaceIn ( mc_builders , [ i , mc_builders [ i ] + 1 ] , j ) ;
31543: LD_ADDR_EXP 82
31547: PUSH
31548: LD_EXP 82
31552: PPUSH
31553: LD_VAR 0 2
31557: PUSH
31558: LD_EXP 82
31562: PUSH
31563: LD_VAR 0 2
31567: ARRAY
31568: PUSH
31569: LD_INT 1
31571: PLUS
31572: PUSH
31573: EMPTY
31574: LIST
31575: LIST
31576: PPUSH
31577: LD_VAR 0 3
31581: PPUSH
31582: CALL 57743 0 3
31586: ST_TO_ADDR
// end ; if IsInUnit ( j ) then
31587: LD_VAR 0 3
31591: PPUSH
31592: CALL_OW 310
31596: IFFALSE 31607
// ComExitBuilding ( j ) ;
31598: LD_VAR 0 3
31602: PPUSH
31603: CALL_OW 122
// wait ( 3 ) ;
31607: LD_INT 3
31609: PPUSH
31610: CALL_OW 67
// if not mc_build_list [ i ] then
31614: LD_EXP 81
31618: PUSH
31619: LD_VAR 0 2
31623: ARRAY
31624: NOT
31625: IFFALSE 31629
// break ;
31627: GO 31728
// if not HasTask ( j ) then
31629: LD_VAR 0 3
31633: PPUSH
31634: CALL_OW 314
31638: NOT
31639: IFFALSE 31726
// ComBuild ( j , mc_build_list [ i ] [ 1 ] [ 1 ] , mc_build_list [ i ] [ 1 ] [ 2 ] , mc_build_list [ i ] [ 1 ] [ 3 ] , mc_build_list [ i ] [ 1 ] [ 4 ] ) ;
31641: LD_VAR 0 3
31645: PPUSH
31646: LD_EXP 81
31650: PUSH
31651: LD_VAR 0 2
31655: ARRAY
31656: PUSH
31657: LD_INT 1
31659: ARRAY
31660: PUSH
31661: LD_INT 1
31663: ARRAY
31664: PPUSH
31665: LD_EXP 81
31669: PUSH
31670: LD_VAR 0 2
31674: ARRAY
31675: PUSH
31676: LD_INT 1
31678: ARRAY
31679: PUSH
31680: LD_INT 2
31682: ARRAY
31683: PPUSH
31684: LD_EXP 81
31688: PUSH
31689: LD_VAR 0 2
31693: ARRAY
31694: PUSH
31695: LD_INT 1
31697: ARRAY
31698: PUSH
31699: LD_INT 3
31701: ARRAY
31702: PPUSH
31703: LD_EXP 81
31707: PUSH
31708: LD_VAR 0 2
31712: ARRAY
31713: PUSH
31714: LD_INT 1
31716: ARRAY
31717: PUSH
31718: LD_INT 4
31720: ARRAY
31721: PPUSH
31722: CALL_OW 145
// end ;
31726: GO 31515
31728: POP
31729: POP
// end else
31730: GO 31874
// if not TryClearPlaceForBuilding ( mc_bases [ i ] , mc_build_list [ i ] [ 1 ] [ 1 ] , mc_build_list [ i ] [ 1 ] [ 2 ] , mc_build_list [ i ] [ 1 ] [ 3 ] , mc_build_list [ i ] [ 1 ] [ 4 ] ) then
31732: LD_EXP 76
31736: PUSH
31737: LD_VAR 0 2
31741: ARRAY
31742: PPUSH
31743: LD_EXP 81
31747: PUSH
31748: LD_VAR 0 2
31752: ARRAY
31753: PUSH
31754: LD_INT 1
31756: ARRAY
31757: PUSH
31758: LD_INT 1
31760: ARRAY
31761: PPUSH
31762: LD_EXP 81
31766: PUSH
31767: LD_VAR 0 2
31771: ARRAY
31772: PUSH
31773: LD_INT 1
31775: ARRAY
31776: PUSH
31777: LD_INT 2
31779: ARRAY
31780: PPUSH
31781: LD_EXP 81
31785: PUSH
31786: LD_VAR 0 2
31790: ARRAY
31791: PUSH
31792: LD_INT 1
31794: ARRAY
31795: PUSH
31796: LD_INT 3
31798: ARRAY
31799: PPUSH
31800: LD_EXP 81
31804: PUSH
31805: LD_VAR 0 2
31809: ARRAY
31810: PUSH
31811: LD_INT 1
31813: ARRAY
31814: PUSH
31815: LD_INT 4
31817: ARRAY
31818: PPUSH
31819: CALL 64494 0 5
31823: NOT
31824: IFFALSE 31874
// begin mc_build_list := Replace ( mc_build_list , i , Reindex ( mc_build_list [ i ] , 1 , - 1 , false ) ) ;
31826: LD_ADDR_EXP 81
31830: PUSH
31831: LD_EXP 81
31835: PPUSH
31836: LD_VAR 0 2
31840: PPUSH
31841: LD_EXP 81
31845: PUSH
31846: LD_VAR 0 2
31850: ARRAY
31851: PPUSH
31852: LD_INT 1
31854: PPUSH
31855: LD_INT 1
31857: NEG
31858: PPUSH
31859: LD_INT 0
31861: PPUSH
31862: CALL 57161 0 4
31866: PPUSH
31867: CALL_OW 1
31871: ST_TO_ADDR
// continue ;
31872: GO 30750
// end ; end ; end ;
31874: GO 30750
31876: POP
31877: POP
// end ;
31878: LD_VAR 0 1
31882: RET
// export function MC_BuildUpgrade ( ) ; var i , j , tmp , depot , lab ; begin
31883: LD_INT 0
31885: PPUSH
31886: PPUSH
31887: PPUSH
31888: PPUSH
31889: PPUSH
31890: PPUSH
// if not mc_bases then
31891: LD_EXP 76
31895: NOT
31896: IFFALSE 31900
// exit ;
31898: GO 32327
// for i = 1 to mc_bases do
31900: LD_ADDR_VAR 0 2
31904: PUSH
31905: DOUBLE
31906: LD_INT 1
31908: DEC
31909: ST_TO_ADDR
31910: LD_EXP 76
31914: PUSH
31915: FOR_TO
31916: IFFALSE 32325
// begin tmp := mc_build_upgrade [ i ] ;
31918: LD_ADDR_VAR 0 4
31922: PUSH
31923: LD_EXP 108
31927: PUSH
31928: LD_VAR 0 2
31932: ARRAY
31933: ST_TO_ADDR
// lab := UnitFilter ( mc_lab [ i ] , [ f_or , [ f_btype , b_lab ] , [ f_btype , b_lab_half ] ] ) ;
31934: LD_ADDR_VAR 0 6
31938: PUSH
31939: LD_EXP 109
31943: PUSH
31944: LD_VAR 0 2
31948: ARRAY
31949: PPUSH
31950: LD_INT 2
31952: PUSH
31953: LD_INT 30
31955: PUSH
31956: LD_INT 6
31958: PUSH
31959: EMPTY
31960: LIST
31961: LIST
31962: PUSH
31963: LD_INT 30
31965: PUSH
31966: LD_INT 7
31968: PUSH
31969: EMPTY
31970: LIST
31971: LIST
31972: PUSH
31973: EMPTY
31974: LIST
31975: LIST
31976: LIST
31977: PPUSH
31978: CALL_OW 72
31982: ST_TO_ADDR
// if not tmp and not lab then
31983: LD_VAR 0 4
31987: NOT
31988: PUSH
31989: LD_VAR 0 6
31993: NOT
31994: AND
31995: IFFALSE 31999
// continue ;
31997: GO 31915
// if tmp then
31999: LD_VAR 0 4
32003: IFFALSE 32123
// for j in tmp do
32005: LD_ADDR_VAR 0 3
32009: PUSH
32010: LD_VAR 0 4
32014: PUSH
32015: FOR_IN
32016: IFFALSE 32121
// begin if UpgradeCost ( j ) then
32018: LD_VAR 0 3
32022: PPUSH
32023: CALL 64154 0 1
32027: IFFALSE 32119
// begin ComUpgrade ( j ) ;
32029: LD_VAR 0 3
32033: PPUSH
32034: CALL_OW 146
// mc_build_upgrade := Replace ( mc_build_upgrade , i , mc_build_upgrade [ i ] diff j ) ;
32038: LD_ADDR_EXP 108
32042: PUSH
32043: LD_EXP 108
32047: PPUSH
32048: LD_VAR 0 2
32052: PPUSH
32053: LD_EXP 108
32057: PUSH
32058: LD_VAR 0 2
32062: ARRAY
32063: PUSH
32064: LD_VAR 0 3
32068: DIFF
32069: PPUSH
32070: CALL_OW 1
32074: ST_TO_ADDR
// mc_construct_list := ReplaceIn ( mc_construct_list , [ i , mc_construct_list [ i ] + 1 ] , j ) ;
32075: LD_ADDR_EXP 83
32079: PUSH
32080: LD_EXP 83
32084: PPUSH
32085: LD_VAR 0 2
32089: PUSH
32090: LD_EXP 83
32094: PUSH
32095: LD_VAR 0 2
32099: ARRAY
32100: PUSH
32101: LD_INT 1
32103: PLUS
32104: PUSH
32105: EMPTY
32106: LIST
32107: LIST
32108: PPUSH
32109: LD_VAR 0 3
32113: PPUSH
32114: CALL 57743 0 3
32118: ST_TO_ADDR
// end ; end ;
32119: GO 32015
32121: POP
32122: POP
// if not lab or not mc_lab_upgrade [ i ] then
32123: LD_VAR 0 6
32127: NOT
32128: PUSH
32129: LD_EXP 110
32133: PUSH
32134: LD_VAR 0 2
32138: ARRAY
32139: NOT
32140: OR
32141: IFFALSE 32145
// continue ;
32143: GO 31915
// for j in lab do
32145: LD_ADDR_VAR 0 3
32149: PUSH
32150: LD_VAR 0 6
32154: PUSH
32155: FOR_IN
32156: IFFALSE 32321
// begin if GetBType ( j ) in [ b_lab , b_lab_half ] and BuildingStatus ( j ) <> bs_build then
32158: LD_VAR 0 3
32162: PPUSH
32163: CALL_OW 266
32167: PUSH
32168: LD_INT 6
32170: PUSH
32171: LD_INT 7
32173: PUSH
32174: EMPTY
32175: LIST
32176: LIST
32177: IN
32178: PUSH
32179: LD_VAR 0 3
32183: PPUSH
32184: CALL_OW 461
32188: PUSH
32189: LD_INT 1
32191: NONEQUAL
32192: AND
32193: IFFALSE 32319
// begin if UpgradeLabCost ( j , mc_lab_upgrade [ i ] [ 1 ] ) then
32195: LD_VAR 0 3
32199: PPUSH
32200: LD_EXP 110
32204: PUSH
32205: LD_VAR 0 2
32209: ARRAY
32210: PUSH
32211: LD_INT 1
32213: ARRAY
32214: PPUSH
32215: CALL 64359 0 2
32219: IFFALSE 32319
// begin ComCancel ( j ) ;
32221: LD_VAR 0 3
32225: PPUSH
32226: CALL_OW 127
// AddComUpgradeLab ( j , mc_lab_upgrade [ i ] [ 1 ] ) ;
32230: LD_VAR 0 3
32234: PPUSH
32235: LD_EXP 110
32239: PUSH
32240: LD_VAR 0 2
32244: ARRAY
32245: PUSH
32246: LD_INT 1
32248: ARRAY
32249: PPUSH
32250: CALL_OW 207
// if not j in mc_construct_list [ i ] then
32254: LD_VAR 0 3
32258: PUSH
32259: LD_EXP 83
32263: PUSH
32264: LD_VAR 0 2
32268: ARRAY
32269: IN
32270: NOT
32271: IFFALSE 32317
// mc_construct_list := ReplaceIn ( mc_construct_list , [ i , mc_construct_list [ i ] + 1 ] , j ) ;
32273: LD_ADDR_EXP 83
32277: PUSH
32278: LD_EXP 83
32282: PPUSH
32283: LD_VAR 0 2
32287: PUSH
32288: LD_EXP 83
32292: PUSH
32293: LD_VAR 0 2
32297: ARRAY
32298: PUSH
32299: LD_INT 1
32301: PLUS
32302: PUSH
32303: EMPTY
32304: LIST
32305: LIST
32306: PPUSH
32307: LD_VAR 0 3
32311: PPUSH
32312: CALL 57743 0 3
32316: ST_TO_ADDR
// break ;
32317: GO 32321
// end ; end ; end ;
32319: GO 32155
32321: POP
32322: POP
// end ;
32323: GO 31915
32325: POP
32326: POP
// end ;
32327: LD_VAR 0 1
32331: RET
// export function MC_TurretWeapon ( ) ; var i , j , tmp , tmp2 , t , tw , busy , weapon ; begin
32332: LD_INT 0
32334: PPUSH
32335: PPUSH
32336: PPUSH
32337: PPUSH
32338: PPUSH
32339: PPUSH
32340: PPUSH
32341: PPUSH
32342: PPUSH
// if not mc_bases then
32343: LD_EXP 76
32347: NOT
32348: IFFALSE 32352
// exit ;
32350: GO 32757
// for i = 1 to mc_bases do
32352: LD_ADDR_VAR 0 2
32356: PUSH
32357: DOUBLE
32358: LD_INT 1
32360: DEC
32361: ST_TO_ADDR
32362: LD_EXP 76
32366: PUSH
32367: FOR_TO
32368: IFFALSE 32755
// begin if not mc_turret_list [ i ] or not UnitFilter ( mc_bases [ i ] , [ f_btype , b_factory ] ) then
32370: LD_EXP 84
32374: PUSH
32375: LD_VAR 0 2
32379: ARRAY
32380: NOT
32381: PUSH
32382: LD_EXP 76
32386: PUSH
32387: LD_VAR 0 2
32391: ARRAY
32392: PPUSH
32393: LD_INT 30
32395: PUSH
32396: LD_INT 3
32398: PUSH
32399: EMPTY
32400: LIST
32401: LIST
32402: PPUSH
32403: CALL_OW 72
32407: NOT
32408: OR
32409: IFFALSE 32413
// continue ;
32411: GO 32367
// busy := false ;
32413: LD_ADDR_VAR 0 8
32417: PUSH
32418: LD_INT 0
32420: ST_TO_ADDR
// tmp := UnitFilter ( mc_bases [ i ] , [ f_btype , b_factory ] ) ;
32421: LD_ADDR_VAR 0 4
32425: PUSH
32426: LD_EXP 76
32430: PUSH
32431: LD_VAR 0 2
32435: ARRAY
32436: PPUSH
32437: LD_INT 30
32439: PUSH
32440: LD_INT 3
32442: PUSH
32443: EMPTY
32444: LIST
32445: LIST
32446: PPUSH
32447: CALL_OW 72
32451: ST_TO_ADDR
// t := UnitFilter ( mc_turret_list [ i ] , [ f_or , [ f_btype , b_bunker ] , [ f_btype , b_turret ] ] ) ;
32452: LD_ADDR_VAR 0 6
32456: PUSH
32457: LD_EXP 84
32461: PUSH
32462: LD_VAR 0 2
32466: ARRAY
32467: PPUSH
32468: LD_INT 2
32470: PUSH
32471: LD_INT 30
32473: PUSH
32474: LD_INT 32
32476: PUSH
32477: EMPTY
32478: LIST
32479: LIST
32480: PUSH
32481: LD_INT 30
32483: PUSH
32484: LD_INT 33
32486: PUSH
32487: EMPTY
32488: LIST
32489: LIST
32490: PUSH
32491: EMPTY
32492: LIST
32493: LIST
32494: LIST
32495: PPUSH
32496: CALL_OW 72
32500: ST_TO_ADDR
// if not t then
32501: LD_VAR 0 6
32505: NOT
32506: IFFALSE 32510
// continue ;
32508: GO 32367
// for j in tmp do
32510: LD_ADDR_VAR 0 3
32514: PUSH
32515: LD_VAR 0 4
32519: PUSH
32520: FOR_IN
32521: IFFALSE 32551
// if not BuildingStatus ( j ) = bs_idle then
32523: LD_VAR 0 3
32527: PPUSH
32528: CALL_OW 461
32532: PUSH
32533: LD_INT 2
32535: EQUAL
32536: NOT
32537: IFFALSE 32549
// begin busy := true ;
32539: LD_ADDR_VAR 0 8
32543: PUSH
32544: LD_INT 1
32546: ST_TO_ADDR
// break ;
32547: GO 32551
// end ;
32549: GO 32520
32551: POP
32552: POP
// if busy then
32553: LD_VAR 0 8
32557: IFFALSE 32561
// continue ;
32559: GO 32367
// tw := UnitFilter ( t , [ f_bweapon , 0 ] ) ;
32561: LD_ADDR_VAR 0 7
32565: PUSH
32566: LD_VAR 0 6
32570: PPUSH
32571: LD_INT 35
32573: PUSH
32574: LD_INT 0
32576: PUSH
32577: EMPTY
32578: LIST
32579: LIST
32580: PPUSH
32581: CALL_OW 72
32585: ST_TO_ADDR
// if tw then
32586: LD_VAR 0 7
32590: IFFALSE 32667
// begin tw := tw [ 1 ] ;
32592: LD_ADDR_VAR 0 7
32596: PUSH
32597: LD_VAR 0 7
32601: PUSH
32602: LD_INT 1
32604: ARRAY
32605: ST_TO_ADDR
// weapon := GetTurretWeapon ( tw , mc_scan_area [ i ] ) ;
32606: LD_ADDR_VAR 0 9
32610: PUSH
32611: LD_VAR 0 7
32615: PPUSH
32616: LD_EXP 101
32620: PUSH
32621: LD_VAR 0 2
32625: ARRAY
32626: PPUSH
32627: CALL 62713 0 2
32631: ST_TO_ADDR
// if mc_allowed_tower_weapons [ i ] then
32632: LD_EXP 115
32636: PUSH
32637: LD_VAR 0 2
32641: ARRAY
32642: IFFALSE 32665
// if not weapon in mc_allowed_tower_weapons [ i ] then
32644: LD_VAR 0 9
32648: PUSH
32649: LD_EXP 115
32653: PUSH
32654: LD_VAR 0 2
32658: ARRAY
32659: IN
32660: NOT
32661: IFFALSE 32665
// continue ;
32663: GO 32367
// end else
32665: GO 32730
// begin tmp2 := UpgradeTurretsWeapon ( mc_turret_list [ i ] , tmp ) ;
32667: LD_ADDR_VAR 0 5
32671: PUSH
32672: LD_EXP 84
32676: PUSH
32677: LD_VAR 0 2
32681: ARRAY
32682: PPUSH
32683: LD_VAR 0 4
32687: PPUSH
32688: CALL 92917 0 2
32692: ST_TO_ADDR
// if not tmp2 then
32693: LD_VAR 0 5
32697: NOT
32698: IFFALSE 32702
// continue ;
32700: GO 32367
// tw := tmp2 [ 1 ] ;
32702: LD_ADDR_VAR 0 7
32706: PUSH
32707: LD_VAR 0 5
32711: PUSH
32712: LD_INT 1
32714: ARRAY
32715: ST_TO_ADDR
// weapon := tmp2 [ 2 ] ;
32716: LD_ADDR_VAR 0 9
32720: PUSH
32721: LD_VAR 0 5
32725: PUSH
32726: LD_INT 2
32728: ARRAY
32729: ST_TO_ADDR
// end ; if not weapon then
32730: LD_VAR 0 9
32734: NOT
32735: IFFALSE 32739
// continue ;
32737: GO 32367
// ComPlaceWeapon ( tw , weapon ) ;
32739: LD_VAR 0 7
32743: PPUSH
32744: LD_VAR 0 9
32748: PPUSH
32749: CALL_OW 148
// end ;
32753: GO 32367
32755: POP
32756: POP
// end ;
32757: LD_VAR 0 1
32761: RET
// export function MC_PlantMines ( ) ; var i , j , k , tmp , list ; begin
32762: LD_INT 0
32764: PPUSH
32765: PPUSH
32766: PPUSH
32767: PPUSH
32768: PPUSH
32769: PPUSH
// if not mc_bases then
32770: LD_EXP 76
32774: NOT
32775: IFFALSE 32779
// exit ;
32777: GO 33555
// for i = 1 to mc_bases do
32779: LD_ADDR_VAR 0 2
32783: PUSH
32784: DOUBLE
32785: LD_INT 1
32787: DEC
32788: ST_TO_ADDR
32789: LD_EXP 76
32793: PUSH
32794: FOR_TO
32795: IFFALSE 33553
// begin if not mc_mines [ i ] or mc_mines [ i ] = mc_miners [ i ] or mc_scan [ i ] then
32797: LD_EXP 89
32801: PUSH
32802: LD_VAR 0 2
32806: ARRAY
32807: NOT
32808: PUSH
32809: LD_EXP 89
32813: PUSH
32814: LD_VAR 0 2
32818: ARRAY
32819: PUSH
32820: LD_EXP 90
32824: PUSH
32825: LD_VAR 0 2
32829: ARRAY
32830: EQUAL
32831: OR
32832: PUSH
32833: LD_EXP 99
32837: PUSH
32838: LD_VAR 0 2
32842: ARRAY
32843: OR
32844: IFFALSE 32848
// continue ;
32846: GO 32794
// if mc_miners [ i ] then
32848: LD_EXP 90
32852: PUSH
32853: LD_VAR 0 2
32857: ARRAY
32858: IFFALSE 33240
// begin for j = mc_miners [ i ] downto 1 do
32860: LD_ADDR_VAR 0 3
32864: PUSH
32865: DOUBLE
32866: LD_EXP 90
32870: PUSH
32871: LD_VAR 0 2
32875: ARRAY
32876: INC
32877: ST_TO_ADDR
32878: LD_INT 1
32880: PUSH
32881: FOR_DOWNTO
32882: IFFALSE 33238
// begin if IsDead ( mc_miners [ i ] [ j ] ) or GetClass ( mc_miners [ i ] [ j ] ) <> 1 then
32884: LD_EXP 90
32888: PUSH
32889: LD_VAR 0 2
32893: ARRAY
32894: PUSH
32895: LD_VAR 0 3
32899: ARRAY
32900: PPUSH
32901: CALL_OW 301
32905: PUSH
32906: LD_EXP 90
32910: PUSH
32911: LD_VAR 0 2
32915: ARRAY
32916: PUSH
32917: LD_VAR 0 3
32921: ARRAY
32922: PPUSH
32923: CALL_OW 257
32927: PUSH
32928: LD_INT 1
32930: NONEQUAL
32931: OR
32932: IFFALSE 32995
// begin tmp := mc_miners [ i ] diff mc_miners [ i ] [ j ] ;
32934: LD_ADDR_VAR 0 5
32938: PUSH
32939: LD_EXP 90
32943: PUSH
32944: LD_VAR 0 2
32948: ARRAY
32949: PUSH
32950: LD_EXP 90
32954: PUSH
32955: LD_VAR 0 2
32959: ARRAY
32960: PUSH
32961: LD_VAR 0 3
32965: ARRAY
32966: DIFF
32967: ST_TO_ADDR
// mc_miners := Replace ( mc_miners , i , tmp ) ;
32968: LD_ADDR_EXP 90
32972: PUSH
32973: LD_EXP 90
32977: PPUSH
32978: LD_VAR 0 2
32982: PPUSH
32983: LD_VAR 0 5
32987: PPUSH
32988: CALL_OW 1
32992: ST_TO_ADDR
// continue ;
32993: GO 32881
// end ; if GetClass ( mc_miners [ i ] [ j ] ) = 1 and not MineOfUnit ( mc_miners [ i ] [ j ] ) and not HasTask ( mc_miners [ i ] [ j ] ) then
32995: LD_EXP 90
32999: PUSH
33000: LD_VAR 0 2
33004: ARRAY
33005: PUSH
33006: LD_VAR 0 3
33010: ARRAY
33011: PPUSH
33012: CALL_OW 257
33016: PUSH
33017: LD_INT 1
33019: EQUAL
33020: PUSH
33021: LD_EXP 90
33025: PUSH
33026: LD_VAR 0 2
33030: ARRAY
33031: PUSH
33032: LD_VAR 0 3
33036: ARRAY
33037: PPUSH
33038: CALL_OW 459
33042: NOT
33043: AND
33044: PUSH
33045: LD_EXP 90
33049: PUSH
33050: LD_VAR 0 2
33054: ARRAY
33055: PUSH
33056: LD_VAR 0 3
33060: ARRAY
33061: PPUSH
33062: CALL_OW 314
33066: NOT
33067: AND
33068: IFFALSE 33236
// begin if IsInUnit ( mc_miners [ i ] [ j ] ) then
33070: LD_EXP 90
33074: PUSH
33075: LD_VAR 0 2
33079: ARRAY
33080: PUSH
33081: LD_VAR 0 3
33085: ARRAY
33086: PPUSH
33087: CALL_OW 310
33091: IFFALSE 33114
// ComExitBuilding ( mc_miners [ i ] [ j ] ) ;
33093: LD_EXP 90
33097: PUSH
33098: LD_VAR 0 2
33102: ARRAY
33103: PUSH
33104: LD_VAR 0 3
33108: ARRAY
33109: PPUSH
33110: CALL_OW 122
// if not HasTask ( mc_miners [ i ] [ j ] ) then
33114: LD_EXP 90
33118: PUSH
33119: LD_VAR 0 2
33123: ARRAY
33124: PUSH
33125: LD_VAR 0 3
33129: ARRAY
33130: PPUSH
33131: CALL_OW 314
33135: NOT
33136: IFFALSE 33236
// AddComPlaceRemoteCharge ( mc_miners [ i ] [ j ] , mc_mines [ i ] [ j mod mc_mines [ i ] + 1 ] [ 1 ] , mc_mines [ i ] [ j mod mc_mines [ i ] + 1 ] [ 2 ] , 0 ) ;
33138: LD_EXP 90
33142: PUSH
33143: LD_VAR 0 2
33147: ARRAY
33148: PUSH
33149: LD_VAR 0 3
33153: ARRAY
33154: PPUSH
33155: LD_EXP 89
33159: PUSH
33160: LD_VAR 0 2
33164: ARRAY
33165: PUSH
33166: LD_VAR 0 3
33170: PUSH
33171: LD_EXP 89
33175: PUSH
33176: LD_VAR 0 2
33180: ARRAY
33181: MOD
33182: PUSH
33183: LD_INT 1
33185: PLUS
33186: ARRAY
33187: PUSH
33188: LD_INT 1
33190: ARRAY
33191: PPUSH
33192: LD_EXP 89
33196: PUSH
33197: LD_VAR 0 2
33201: ARRAY
33202: PUSH
33203: LD_VAR 0 3
33207: PUSH
33208: LD_EXP 89
33212: PUSH
33213: LD_VAR 0 2
33217: ARRAY
33218: MOD
33219: PUSH
33220: LD_INT 1
33222: PLUS
33223: ARRAY
33224: PUSH
33225: LD_INT 2
33227: ARRAY
33228: PPUSH
33229: LD_INT 0
33231: PPUSH
33232: CALL_OW 193
// end ; end ;
33236: GO 32881
33238: POP
33239: POP
// end ; tmp := UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_armoury ] , [ f_btype , b_barracks ] , [ f_btype , b_bunker ] ] ) ;
33240: LD_ADDR_VAR 0 5
33244: PUSH
33245: LD_EXP 76
33249: PUSH
33250: LD_VAR 0 2
33254: ARRAY
33255: PPUSH
33256: LD_INT 2
33258: PUSH
33259: LD_INT 30
33261: PUSH
33262: LD_INT 4
33264: PUSH
33265: EMPTY
33266: LIST
33267: LIST
33268: PUSH
33269: LD_INT 30
33271: PUSH
33272: LD_INT 5
33274: PUSH
33275: EMPTY
33276: LIST
33277: LIST
33278: PUSH
33279: LD_INT 30
33281: PUSH
33282: LD_INT 32
33284: PUSH
33285: EMPTY
33286: LIST
33287: LIST
33288: PUSH
33289: EMPTY
33290: LIST
33291: LIST
33292: LIST
33293: LIST
33294: PPUSH
33295: CALL_OW 72
33299: ST_TO_ADDR
// if not tmp then
33300: LD_VAR 0 5
33304: NOT
33305: IFFALSE 33309
// continue ;
33307: GO 32794
// list := [ ] ;
33309: LD_ADDR_VAR 0 6
33313: PUSH
33314: EMPTY
33315: ST_TO_ADDR
// for j in tmp do
33316: LD_ADDR_VAR 0 3
33320: PUSH
33321: LD_VAR 0 5
33325: PUSH
33326: FOR_IN
33327: IFFALSE 33396
// begin for k in UnitsInside ( j ) do
33329: LD_ADDR_VAR 0 4
33333: PUSH
33334: LD_VAR 0 3
33338: PPUSH
33339: CALL_OW 313
33343: PUSH
33344: FOR_IN
33345: IFFALSE 33392
// if GetClass ( k ) = 1 and not MineOfUnit ( k ) then
33347: LD_VAR 0 4
33351: PPUSH
33352: CALL_OW 257
33356: PUSH
33357: LD_INT 1
33359: EQUAL
33360: PUSH
33361: LD_VAR 0 4
33365: PPUSH
33366: CALL_OW 459
33370: NOT
33371: AND
33372: IFFALSE 33390
// list := list ^ k ;
33374: LD_ADDR_VAR 0 6
33378: PUSH
33379: LD_VAR 0 6
33383: PUSH
33384: LD_VAR 0 4
33388: ADD
33389: ST_TO_ADDR
33390: GO 33344
33392: POP
33393: POP
// end ;
33394: GO 33326
33396: POP
33397: POP
// list := list diff mc_miners [ i ] ;
33398: LD_ADDR_VAR 0 6
33402: PUSH
33403: LD_VAR 0 6
33407: PUSH
33408: LD_EXP 90
33412: PUSH
33413: LD_VAR 0 2
33417: ARRAY
33418: DIFF
33419: ST_TO_ADDR
// if not list then
33420: LD_VAR 0 6
33424: NOT
33425: IFFALSE 33429
// continue ;
33427: GO 32794
// k := mc_mines [ i ] - mc_miners [ i ] ;
33429: LD_ADDR_VAR 0 4
33433: PUSH
33434: LD_EXP 89
33438: PUSH
33439: LD_VAR 0 2
33443: ARRAY
33444: PUSH
33445: LD_EXP 90
33449: PUSH
33450: LD_VAR 0 2
33454: ARRAY
33455: MINUS
33456: ST_TO_ADDR
// if k > list then
33457: LD_VAR 0 4
33461: PUSH
33462: LD_VAR 0 6
33466: GREATER
33467: IFFALSE 33479
// k := list ;
33469: LD_ADDR_VAR 0 4
33473: PUSH
33474: LD_VAR 0 6
33478: ST_TO_ADDR
// for j = 1 to k do
33479: LD_ADDR_VAR 0 3
33483: PUSH
33484: DOUBLE
33485: LD_INT 1
33487: DEC
33488: ST_TO_ADDR
33489: LD_VAR 0 4
33493: PUSH
33494: FOR_TO
33495: IFFALSE 33549
// mc_miners := ReplaceIn ( mc_miners , [ i , mc_miners [ i ] + 1 ] , list [ j ] ) ;
33497: LD_ADDR_EXP 90
33501: PUSH
33502: LD_EXP 90
33506: PPUSH
33507: LD_VAR 0 2
33511: PUSH
33512: LD_EXP 90
33516: PUSH
33517: LD_VAR 0 2
33521: ARRAY
33522: PUSH
33523: LD_INT 1
33525: PLUS
33526: PUSH
33527: EMPTY
33528: LIST
33529: LIST
33530: PPUSH
33531: LD_VAR 0 6
33535: PUSH
33536: LD_VAR 0 3
33540: ARRAY
33541: PPUSH
33542: CALL 57743 0 3
33546: ST_TO_ADDR
33547: GO 33494
33549: POP
33550: POP
// end ;
33551: GO 32794
33553: POP
33554: POP
// end ;
33555: LD_VAR 0 1
33559: RET
// export function MC_CollectCrates ( ) ; var i , j , k , tmp , target , cargo , depot , fac , components ; begin
33560: LD_INT 0
33562: PPUSH
33563: PPUSH
33564: PPUSH
33565: PPUSH
33566: PPUSH
33567: PPUSH
33568: PPUSH
33569: PPUSH
33570: PPUSH
33571: PPUSH
// if not mc_bases then
33572: LD_EXP 76
33576: NOT
33577: IFFALSE 33581
// exit ;
33579: GO 35331
// for i = 1 to mc_bases do
33581: LD_ADDR_VAR 0 2
33585: PUSH
33586: DOUBLE
33587: LD_INT 1
33589: DEC
33590: ST_TO_ADDR
33591: LD_EXP 76
33595: PUSH
33596: FOR_TO
33597: IFFALSE 35329
// begin if not mc_bases [ i ] or mc_construct_list [ i ] then
33599: LD_EXP 76
33603: PUSH
33604: LD_VAR 0 2
33608: ARRAY
33609: NOT
33610: PUSH
33611: LD_EXP 83
33615: PUSH
33616: LD_VAR 0 2
33620: ARRAY
33621: OR
33622: IFFALSE 33626
// continue ;
33624: GO 33596
// if not mc_crates [ i ] and mc_crates_collector [ i ] then
33626: LD_EXP 92
33630: PUSH
33631: LD_VAR 0 2
33635: ARRAY
33636: NOT
33637: PUSH
33638: LD_EXP 93
33642: PUSH
33643: LD_VAR 0 2
33647: ARRAY
33648: AND
33649: IFFALSE 33687
// begin mc_crates_collector := Replace ( mc_crates_collector , i , [ ] ) ;
33651: LD_ADDR_EXP 93
33655: PUSH
33656: LD_EXP 93
33660: PPUSH
33661: LD_VAR 0 2
33665: PPUSH
33666: EMPTY
33667: PPUSH
33668: CALL_OW 1
33672: ST_TO_ADDR
// MC_Reset ( i , 107 ) ;
33673: LD_VAR 0 2
33677: PPUSH
33678: LD_INT 107
33680: PPUSH
33681: CALL 24545 0 2
// continue ;
33685: GO 33596
// end ; target := [ ] ;
33687: LD_ADDR_VAR 0 6
33691: PUSH
33692: EMPTY
33693: ST_TO_ADDR
// for j = mc_crates [ i ] downto 1 do
33694: LD_ADDR_VAR 0 3
33698: PUSH
33699: DOUBLE
33700: LD_EXP 92
33704: PUSH
33705: LD_VAR 0 2
33709: ARRAY
33710: INC
33711: ST_TO_ADDR
33712: LD_INT 1
33714: PUSH
33715: FOR_DOWNTO
33716: IFFALSE 33976
// begin if ValidHex ( mc_crates [ i ] [ j ] [ 2 ] , mc_crates [ i ] [ j ] [ 3 ] ) and GetResourceAmountXY ( mc_crates [ i ] [ j ] [ 2 ] , mc_crates [ i ] [ j ] [ 3 ] ) = 0 then
33718: LD_EXP 92
33722: PUSH
33723: LD_VAR 0 2
33727: ARRAY
33728: PUSH
33729: LD_VAR 0 3
33733: ARRAY
33734: PUSH
33735: LD_INT 2
33737: ARRAY
33738: PPUSH
33739: LD_EXP 92
33743: PUSH
33744: LD_VAR 0 2
33748: ARRAY
33749: PUSH
33750: LD_VAR 0 3
33754: ARRAY
33755: PUSH
33756: LD_INT 3
33758: ARRAY
33759: PPUSH
33760: CALL_OW 488
33764: PUSH
33765: LD_EXP 92
33769: PUSH
33770: LD_VAR 0 2
33774: ARRAY
33775: PUSH
33776: LD_VAR 0 3
33780: ARRAY
33781: PUSH
33782: LD_INT 2
33784: ARRAY
33785: PPUSH
33786: LD_EXP 92
33790: PUSH
33791: LD_VAR 0 2
33795: ARRAY
33796: PUSH
33797: LD_VAR 0 3
33801: ARRAY
33802: PUSH
33803: LD_INT 3
33805: ARRAY
33806: PPUSH
33807: CALL_OW 284
33811: PUSH
33812: LD_INT 0
33814: EQUAL
33815: AND
33816: IFFALSE 33871
// begin tmp := Delete ( mc_crates [ i ] , j ) ;
33818: LD_ADDR_VAR 0 5
33822: PUSH
33823: LD_EXP 92
33827: PUSH
33828: LD_VAR 0 2
33832: ARRAY
33833: PPUSH
33834: LD_VAR 0 3
33838: PPUSH
33839: CALL_OW 3
33843: ST_TO_ADDR
// mc_crates := Replace ( mc_crates , i , tmp ) ;
33844: LD_ADDR_EXP 92
33848: PUSH
33849: LD_EXP 92
33853: PPUSH
33854: LD_VAR 0 2
33858: PPUSH
33859: LD_VAR 0 5
33863: PPUSH
33864: CALL_OW 1
33868: ST_TO_ADDR
// continue ;
33869: GO 33715
// end ; if DangerAtRangeXY ( GetSide ( mc_bases [ i ] [ 1 ] ) , mc_crates [ i ] [ j ] [ 2 ] , mc_crates [ i ] [ j ] [ 3 ] , 30 ) [ 4 ] = 0 then
33871: LD_EXP 76
33875: PUSH
33876: LD_VAR 0 2
33880: ARRAY
33881: PUSH
33882: LD_INT 1
33884: ARRAY
33885: PPUSH
33886: CALL_OW 255
33890: PPUSH
33891: LD_EXP 92
33895: PUSH
33896: LD_VAR 0 2
33900: ARRAY
33901: PUSH
33902: LD_VAR 0 3
33906: ARRAY
33907: PUSH
33908: LD_INT 2
33910: ARRAY
33911: PPUSH
33912: LD_EXP 92
33916: PUSH
33917: LD_VAR 0 2
33921: ARRAY
33922: PUSH
33923: LD_VAR 0 3
33927: ARRAY
33928: PUSH
33929: LD_INT 3
33931: ARRAY
33932: PPUSH
33933: LD_INT 30
33935: PPUSH
33936: CALL 58639 0 4
33940: PUSH
33941: LD_INT 4
33943: ARRAY
33944: PUSH
33945: LD_INT 0
33947: EQUAL
33948: IFFALSE 33974
// begin target := mc_crates [ i ] [ j ] ;
33950: LD_ADDR_VAR 0 6
33954: PUSH
33955: LD_EXP 92
33959: PUSH
33960: LD_VAR 0 2
33964: ARRAY
33965: PUSH
33966: LD_VAR 0 3
33970: ARRAY
33971: ST_TO_ADDR
// break ;
33972: GO 33976
// end ; end ;
33974: GO 33715
33976: POP
33977: POP
// if not target then
33978: LD_VAR 0 6
33982: NOT
33983: IFFALSE 33987
// continue ;
33985: GO 33596
// cargo := UnitFilter ( mc_vehicles [ i ] , [ [ f_or , [ f_not , [ f_empty ] ] , [ f_linked ] , [ f_control , control_apeman ] , [ f_control , control_computer ] ] , [ f_or , [ f_weapon , ar_cargo_bay ] , [ f_weapon , ru_cargo_bay ] , [ f_weapon , us_cargo_bay ] ] ] ) ;
33987: LD_ADDR_VAR 0 7
33991: PUSH
33992: LD_EXP 95
33996: PUSH
33997: LD_VAR 0 2
34001: ARRAY
34002: PPUSH
34003: LD_INT 2
34005: PUSH
34006: LD_INT 3
34008: PUSH
34009: LD_INT 58
34011: PUSH
34012: EMPTY
34013: LIST
34014: PUSH
34015: EMPTY
34016: LIST
34017: LIST
34018: PUSH
34019: LD_INT 61
34021: PUSH
34022: EMPTY
34023: LIST
34024: PUSH
34025: LD_INT 33
34027: PUSH
34028: LD_INT 5
34030: PUSH
34031: EMPTY
34032: LIST
34033: LIST
34034: PUSH
34035: LD_INT 33
34037: PUSH
34038: LD_INT 3
34040: PUSH
34041: EMPTY
34042: LIST
34043: LIST
34044: PUSH
34045: EMPTY
34046: LIST
34047: LIST
34048: LIST
34049: LIST
34050: LIST
34051: PUSH
34052: LD_INT 2
34054: PUSH
34055: LD_INT 34
34057: PUSH
34058: LD_INT 32
34060: PUSH
34061: EMPTY
34062: LIST
34063: LIST
34064: PUSH
34065: LD_INT 34
34067: PUSH
34068: LD_INT 51
34070: PUSH
34071: EMPTY
34072: LIST
34073: LIST
34074: PUSH
34075: LD_INT 34
34077: PUSH
34078: LD_INT 12
34080: PUSH
34081: EMPTY
34082: LIST
34083: LIST
34084: PUSH
34085: EMPTY
34086: LIST
34087: LIST
34088: LIST
34089: LIST
34090: PUSH
34091: EMPTY
34092: LIST
34093: LIST
34094: PPUSH
34095: CALL_OW 72
34099: ST_TO_ADDR
// if not cargo then
34100: LD_VAR 0 7
34104: NOT
34105: IFFALSE 34748
// begin if mc_crates_collector [ i ] < 5 then
34107: LD_EXP 93
34111: PUSH
34112: LD_VAR 0 2
34116: ARRAY
34117: PUSH
34118: LD_INT 5
34120: LESS
34121: IFFALSE 34487
// begin if mc_ape [ i ] then
34123: LD_EXP 105
34127: PUSH
34128: LD_VAR 0 2
34132: ARRAY
34133: IFFALSE 34180
// tmp := UnitFilter ( mc_ape [ i ] , [ [ f_class , 16 ] , [ f_lives , 750 ] ] ) ;
34135: LD_ADDR_VAR 0 5
34139: PUSH
34140: LD_EXP 105
34144: PUSH
34145: LD_VAR 0 2
34149: ARRAY
34150: PPUSH
34151: LD_INT 25
34153: PUSH
34154: LD_INT 16
34156: PUSH
34157: EMPTY
34158: LIST
34159: LIST
34160: PUSH
34161: LD_INT 24
34163: PUSH
34164: LD_INT 750
34166: PUSH
34167: EMPTY
34168: LIST
34169: LIST
34170: PUSH
34171: EMPTY
34172: LIST
34173: LIST
34174: PPUSH
34175: CALL_OW 72
34179: ST_TO_ADDR
// if not tmp then
34180: LD_VAR 0 5
34184: NOT
34185: IFFALSE 34232
// tmp := UnitFilter ( mc_bases [ i ] , [ [ f_class , 2 ] , [ f_lives , 750 ] ] ) ;
34187: LD_ADDR_VAR 0 5
34191: PUSH
34192: LD_EXP 76
34196: PUSH
34197: LD_VAR 0 2
34201: ARRAY
34202: PPUSH
34203: LD_INT 25
34205: PUSH
34206: LD_INT 2
34208: PUSH
34209: EMPTY
34210: LIST
34211: LIST
34212: PUSH
34213: LD_INT 24
34215: PUSH
34216: LD_INT 750
34218: PUSH
34219: EMPTY
34220: LIST
34221: LIST
34222: PUSH
34223: EMPTY
34224: LIST
34225: LIST
34226: PPUSH
34227: CALL_OW 72
34231: ST_TO_ADDR
// if mc_ape [ i ] and UnitFilter ( mc_bases [ i ] , [ [ f_class , 2 ] , [ f_lives , 750 ] ] ) and tmp < 5 then
34232: LD_EXP 105
34236: PUSH
34237: LD_VAR 0 2
34241: ARRAY
34242: PUSH
34243: LD_EXP 76
34247: PUSH
34248: LD_VAR 0 2
34252: ARRAY
34253: PPUSH
34254: LD_INT 25
34256: PUSH
34257: LD_INT 2
34259: PUSH
34260: EMPTY
34261: LIST
34262: LIST
34263: PUSH
34264: LD_INT 24
34266: PUSH
34267: LD_INT 750
34269: PUSH
34270: EMPTY
34271: LIST
34272: LIST
34273: PUSH
34274: EMPTY
34275: LIST
34276: LIST
34277: PPUSH
34278: CALL_OW 72
34282: AND
34283: PUSH
34284: LD_VAR 0 5
34288: PUSH
34289: LD_INT 5
34291: LESS
34292: AND
34293: IFFALSE 34375
// begin for j in UnitFilter ( mc_bases [ i ] , [ [ f_class , 2 ] , [ f_lives , 750 ] ] ) do
34295: LD_ADDR_VAR 0 3
34299: PUSH
34300: LD_EXP 76
34304: PUSH
34305: LD_VAR 0 2
34309: ARRAY
34310: PPUSH
34311: LD_INT 25
34313: PUSH
34314: LD_INT 2
34316: PUSH
34317: EMPTY
34318: LIST
34319: LIST
34320: PUSH
34321: LD_INT 24
34323: PUSH
34324: LD_INT 750
34326: PUSH
34327: EMPTY
34328: LIST
34329: LIST
34330: PUSH
34331: EMPTY
34332: LIST
34333: LIST
34334: PPUSH
34335: CALL_OW 72
34339: PUSH
34340: FOR_IN
34341: IFFALSE 34373
// begin tmp := tmp union j ;
34343: LD_ADDR_VAR 0 5
34347: PUSH
34348: LD_VAR 0 5
34352: PUSH
34353: LD_VAR 0 3
34357: UNION
34358: ST_TO_ADDR
// if tmp >= 5 then
34359: LD_VAR 0 5
34363: PUSH
34364: LD_INT 5
34366: GREATEREQUAL
34367: IFFALSE 34371
// break ;
34369: GO 34373
// end ;
34371: GO 34340
34373: POP
34374: POP
// end ; if not tmp then
34375: LD_VAR 0 5
34379: NOT
34380: IFFALSE 34384
// continue ;
34382: GO 33596
// for j in tmp do
34384: LD_ADDR_VAR 0 3
34388: PUSH
34389: LD_VAR 0 5
34393: PUSH
34394: FOR_IN
34395: IFFALSE 34485
// if not GetTag ( j ) then
34397: LD_VAR 0 3
34401: PPUSH
34402: CALL_OW 110
34406: NOT
34407: IFFALSE 34483
// begin mc_crates_collector := ReplaceIn ( mc_crates_collector , [ i , mc_crates_collector [ i ] + 1 ] , j ) ;
34409: LD_ADDR_EXP 93
34413: PUSH
34414: LD_EXP 93
34418: PPUSH
34419: LD_VAR 0 2
34423: PUSH
34424: LD_EXP 93
34428: PUSH
34429: LD_VAR 0 2
34433: ARRAY
34434: PUSH
34435: LD_INT 1
34437: PLUS
34438: PUSH
34439: EMPTY
34440: LIST
34441: LIST
34442: PPUSH
34443: LD_VAR 0 3
34447: PPUSH
34448: CALL 57743 0 3
34452: ST_TO_ADDR
// SetTag ( j , 107 ) ;
34453: LD_VAR 0 3
34457: PPUSH
34458: LD_INT 107
34460: PPUSH
34461: CALL_OW 109
// if mc_crates_collector [ i ] >= 5 then
34465: LD_EXP 93
34469: PUSH
34470: LD_VAR 0 2
34474: ARRAY
34475: PUSH
34476: LD_INT 5
34478: GREATEREQUAL
34479: IFFALSE 34483
// break ;
34481: GO 34485
// end ;
34483: GO 34394
34485: POP
34486: POP
// end ; if mc_crates_collector [ i ] and target then
34487: LD_EXP 93
34491: PUSH
34492: LD_VAR 0 2
34496: ARRAY
34497: PUSH
34498: LD_VAR 0 6
34502: AND
34503: IFFALSE 34746
// begin if mc_crates_collector [ i ] < target [ 1 ] then
34505: LD_EXP 93
34509: PUSH
34510: LD_VAR 0 2
34514: ARRAY
34515: PUSH
34516: LD_VAR 0 6
34520: PUSH
34521: LD_INT 1
34523: ARRAY
34524: LESS
34525: IFFALSE 34545
// tmp := mc_crates_collector [ i ] else
34527: LD_ADDR_VAR 0 5
34531: PUSH
34532: LD_EXP 93
34536: PUSH
34537: LD_VAR 0 2
34541: ARRAY
34542: ST_TO_ADDR
34543: GO 34559
// tmp := target [ 1 ] ;
34545: LD_ADDR_VAR 0 5
34549: PUSH
34550: LD_VAR 0 6
34554: PUSH
34555: LD_INT 1
34557: ARRAY
34558: ST_TO_ADDR
// k := 0 ;
34559: LD_ADDR_VAR 0 4
34563: PUSH
34564: LD_INT 0
34566: ST_TO_ADDR
// for j in mc_crates_collector [ i ] do
34567: LD_ADDR_VAR 0 3
34571: PUSH
34572: LD_EXP 93
34576: PUSH
34577: LD_VAR 0 2
34581: ARRAY
34582: PUSH
34583: FOR_IN
34584: IFFALSE 34744
// begin k := k + 1 ;
34586: LD_ADDR_VAR 0 4
34590: PUSH
34591: LD_VAR 0 4
34595: PUSH
34596: LD_INT 1
34598: PLUS
34599: ST_TO_ADDR
// if k > tmp then
34600: LD_VAR 0 4
34604: PUSH
34605: LD_VAR 0 5
34609: GREATER
34610: IFFALSE 34614
// break ;
34612: GO 34744
// if not GetClass ( j ) in [ 2 , 16 ] then
34614: LD_VAR 0 3
34618: PPUSH
34619: CALL_OW 257
34623: PUSH
34624: LD_INT 2
34626: PUSH
34627: LD_INT 16
34629: PUSH
34630: EMPTY
34631: LIST
34632: LIST
34633: IN
34634: NOT
34635: IFFALSE 34688
// begin mc_crates_collector := Replace ( mc_crates_collector , i , mc_crates_collector [ i ] diff j ) ;
34637: LD_ADDR_EXP 93
34641: PUSH
34642: LD_EXP 93
34646: PPUSH
34647: LD_VAR 0 2
34651: PPUSH
34652: LD_EXP 93
34656: PUSH
34657: LD_VAR 0 2
34661: ARRAY
34662: PUSH
34663: LD_VAR 0 3
34667: DIFF
34668: PPUSH
34669: CALL_OW 1
34673: ST_TO_ADDR
// SetTag ( j , 0 ) ;
34674: LD_VAR 0 3
34678: PPUSH
34679: LD_INT 0
34681: PPUSH
34682: CALL_OW 109
// continue ;
34686: GO 34583
// end ; if IsInUnit ( j ) then
34688: LD_VAR 0 3
34692: PPUSH
34693: CALL_OW 310
34697: IFFALSE 34708
// ComExitBuilding ( j ) ;
34699: LD_VAR 0 3
34703: PPUSH
34704: CALL_OW 122
// wait ( 3 ) ;
34708: LD_INT 3
34710: PPUSH
34711: CALL_OW 67
// ComCollect ( j , target [ 2 ] , target [ 3 ] ) ;
34715: LD_VAR 0 3
34719: PPUSH
34720: LD_VAR 0 6
34724: PUSH
34725: LD_INT 2
34727: ARRAY
34728: PPUSH
34729: LD_VAR 0 6
34733: PUSH
34734: LD_INT 3
34736: ARRAY
34737: PPUSH
34738: CALL_OW 117
// end ;
34742: GO 34583
34744: POP
34745: POP
// end ; end else
34746: GO 35327
// begin for j in cargo do
34748: LD_ADDR_VAR 0 3
34752: PUSH
34753: LD_VAR 0 7
34757: PUSH
34758: FOR_IN
34759: IFFALSE 35325
// begin if GetTag ( j ) <> 0 then
34761: LD_VAR 0 3
34765: PPUSH
34766: CALL_OW 110
34770: PUSH
34771: LD_INT 0
34773: NONEQUAL
34774: IFFALSE 34778
// continue ;
34776: GO 34758
// if GetLives ( j ) < 1000 and not IsInArea ( j , mc_parking [ i ] ) then
34778: LD_VAR 0 3
34782: PPUSH
34783: CALL_OW 256
34787: PUSH
34788: LD_INT 1000
34790: LESS
34791: PUSH
34792: LD_VAR 0 3
34796: PPUSH
34797: LD_EXP 100
34801: PUSH
34802: LD_VAR 0 2
34806: ARRAY
34807: PPUSH
34808: CALL_OW 308
34812: NOT
34813: AND
34814: IFFALSE 34836
// ComMoveToArea ( j , mc_parking [ i ] ) ;
34816: LD_VAR 0 3
34820: PPUSH
34821: LD_EXP 100
34825: PUSH
34826: LD_VAR 0 2
34830: ARRAY
34831: PPUSH
34832: CALL_OW 113
// if GetLives ( j ) < 1000 and IsInArea ( j , mc_parking [ i ] ) then
34836: LD_VAR 0 3
34840: PPUSH
34841: CALL_OW 256
34845: PUSH
34846: LD_INT 1000
34848: LESS
34849: PUSH
34850: LD_VAR 0 3
34854: PPUSH
34855: LD_EXP 100
34859: PUSH
34860: LD_VAR 0 2
34864: ARRAY
34865: PPUSH
34866: CALL_OW 308
34870: AND
34871: IFFALSE 34875
// continue ;
34873: GO 34758
// if GetEngine ( j ) = engine_solar and GetFuel ( j ) < 15 then
34875: LD_VAR 0 3
34879: PPUSH
34880: CALL_OW 262
34884: PUSH
34885: LD_INT 2
34887: EQUAL
34888: PUSH
34889: LD_VAR 0 3
34893: PPUSH
34894: CALL_OW 261
34898: PUSH
34899: LD_INT 15
34901: LESS
34902: AND
34903: IFFALSE 34907
// continue ;
34905: GO 34758
// if GetEngine ( j ) = engine_combustion and GetFuel ( j ) < 10 then
34907: LD_VAR 0 3
34911: PPUSH
34912: CALL_OW 262
34916: PUSH
34917: LD_INT 1
34919: EQUAL
34920: PUSH
34921: LD_VAR 0 3
34925: PPUSH
34926: CALL_OW 261
34930: PUSH
34931: LD_INT 10
34933: LESS
34934: AND
34935: IFFALSE 35264
// begin depot := UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) ;
34937: LD_ADDR_VAR 0 8
34941: PUSH
34942: LD_EXP 76
34946: PUSH
34947: LD_VAR 0 2
34951: ARRAY
34952: PPUSH
34953: LD_INT 2
34955: PUSH
34956: LD_INT 30
34958: PUSH
34959: LD_INT 0
34961: PUSH
34962: EMPTY
34963: LIST
34964: LIST
34965: PUSH
34966: LD_INT 30
34968: PUSH
34969: LD_INT 1
34971: PUSH
34972: EMPTY
34973: LIST
34974: LIST
34975: PUSH
34976: EMPTY
34977: LIST
34978: LIST
34979: LIST
34980: PPUSH
34981: CALL_OW 72
34985: ST_TO_ADDR
// if not depot then
34986: LD_VAR 0 8
34990: NOT
34991: IFFALSE 34995
// continue ;
34993: GO 34758
// if GetDistUnits ( j , NearestUnitToUnit ( depot , j ) ) < 6 then
34995: LD_VAR 0 3
34999: PPUSH
35000: LD_VAR 0 8
35004: PPUSH
35005: LD_VAR 0 3
35009: PPUSH
35010: CALL_OW 74
35014: PPUSH
35015: CALL_OW 296
35019: PUSH
35020: LD_INT 6
35022: LESS
35023: IFFALSE 35039
// SetFuel ( j , 100 ) else
35025: LD_VAR 0 3
35029: PPUSH
35030: LD_INT 100
35032: PPUSH
35033: CALL_OW 240
35037: GO 35264
// if GetFuel ( j ) = 0 then
35039: LD_VAR 0 3
35043: PPUSH
35044: CALL_OW 261
35048: PUSH
35049: LD_INT 0
35051: EQUAL
35052: IFFALSE 35264
// begin mc_vehicles := Replace ( mc_vehicles , i , mc_vehicles [ i ] diff j ) ;
35054: LD_ADDR_EXP 95
35058: PUSH
35059: LD_EXP 95
35063: PPUSH
35064: LD_VAR 0 2
35068: PPUSH
35069: LD_EXP 95
35073: PUSH
35074: LD_VAR 0 2
35078: ARRAY
35079: PUSH
35080: LD_VAR 0 3
35084: DIFF
35085: PPUSH
35086: CALL_OW 1
35090: ST_TO_ADDR
// if GetControl ( j ) = control_manual then
35091: LD_VAR 0 3
35095: PPUSH
35096: CALL_OW 263
35100: PUSH
35101: LD_INT 1
35103: EQUAL
35104: IFFALSE 35120
// ComExitVehicle ( IsInUnit ( j ) ) ;
35106: LD_VAR 0 3
35110: PPUSH
35111: CALL_OW 310
35115: PPUSH
35116: CALL_OW 121
// if GetControl ( j ) = control_remote then
35120: LD_VAR 0 3
35124: PPUSH
35125: CALL_OW 263
35129: PUSH
35130: LD_INT 2
35132: EQUAL
35133: IFFALSE 35144
// ComUnlink ( j ) ;
35135: LD_VAR 0 3
35139: PPUSH
35140: CALL_OW 136
// fac := MC_GetBuildings ( i , b_factory ) ;
35144: LD_ADDR_VAR 0 9
35148: PUSH
35149: LD_VAR 0 2
35153: PPUSH
35154: LD_INT 3
35156: PPUSH
35157: CALL 44617 0 2
35161: ST_TO_ADDR
// if fac then
35162: LD_VAR 0 9
35166: IFFALSE 35262
// begin for k in fac do
35168: LD_ADDR_VAR 0 4
35172: PUSH
35173: LD_VAR 0 9
35177: PUSH
35178: FOR_IN
35179: IFFALSE 35260
// begin components := Produce ( fac , GetChassis ( j ) , GetEngine ( j ) , GetControl ( j ) , GetWeapon ( j ) ) ;
35181: LD_ADDR_VAR 0 10
35185: PUSH
35186: LD_VAR 0 9
35190: PPUSH
35191: LD_VAR 0 3
35195: PPUSH
35196: CALL_OW 265
35200: PPUSH
35201: LD_VAR 0 3
35205: PPUSH
35206: CALL_OW 262
35210: PPUSH
35211: LD_VAR 0 3
35215: PPUSH
35216: CALL_OW 263
35220: PPUSH
35221: LD_VAR 0 3
35225: PPUSH
35226: CALL_OW 264
35230: PPUSH
35231: CALL 55275 0 5
35235: ST_TO_ADDR
// if components then
35236: LD_VAR 0 10
35240: IFFALSE 35258
// begin MC_InsertProduceList ( i , components ) ;
35242: LD_VAR 0 2
35246: PPUSH
35247: LD_VAR 0 10
35251: PPUSH
35252: CALL 44162 0 2
// break ;
35256: GO 35260
// end ; end ;
35258: GO 35178
35260: POP
35261: POP
// end ; continue ;
35262: GO 34758
// end ; end ; if GetCargo ( j , mat_cans ) < 100 and not HasTask ( j ) then
35264: LD_VAR 0 3
35268: PPUSH
35269: LD_INT 1
35271: PPUSH
35272: CALL_OW 289
35276: PUSH
35277: LD_INT 100
35279: LESS
35280: PUSH
35281: LD_VAR 0 3
35285: PPUSH
35286: CALL_OW 314
35290: NOT
35291: AND
35292: IFFALSE 35321
// ComCollect ( j , target [ 2 ] , target [ 3 ] ) ;
35294: LD_VAR 0 3
35298: PPUSH
35299: LD_VAR 0 6
35303: PUSH
35304: LD_INT 2
35306: ARRAY
35307: PPUSH
35308: LD_VAR 0 6
35312: PUSH
35313: LD_INT 3
35315: ARRAY
35316: PPUSH
35317: CALL_OW 117
// break ;
35321: GO 35325
// end ;
35323: GO 34758
35325: POP
35326: POP
// end ; end ;
35327: GO 33596
35329: POP
35330: POP
// end ;
35331: LD_VAR 0 1
35335: RET
// export function MC_LinkRemoteControl ( ) ; var i , j , tmp ; begin
35336: LD_INT 0
35338: PPUSH
35339: PPUSH
35340: PPUSH
35341: PPUSH
// if not mc_bases then
35342: LD_EXP 76
35346: NOT
35347: IFFALSE 35351
// exit ;
35349: GO 35512
// for i = 1 to mc_bases do
35351: LD_ADDR_VAR 0 2
35355: PUSH
35356: DOUBLE
35357: LD_INT 1
35359: DEC
35360: ST_TO_ADDR
35361: LD_EXP 76
35365: PUSH
35366: FOR_TO
35367: IFFALSE 35510
// begin tmp := UnitFilter ( mc_vehicles [ i ] union mc_defender [ i ] , [ f_control , control_remote ] ) ;
35369: LD_ADDR_VAR 0 4
35373: PUSH
35374: LD_EXP 95
35378: PUSH
35379: LD_VAR 0 2
35383: ARRAY
35384: PUSH
35385: LD_EXP 98
35389: PUSH
35390: LD_VAR 0 2
35394: ARRAY
35395: UNION
35396: PPUSH
35397: LD_INT 33
35399: PUSH
35400: LD_INT 2
35402: PUSH
35403: EMPTY
35404: LIST
35405: LIST
35406: PPUSH
35407: CALL_OW 72
35411: ST_TO_ADDR
// if tmp then
35412: LD_VAR 0 4
35416: IFFALSE 35508
// for j in tmp do
35418: LD_ADDR_VAR 0 3
35422: PUSH
35423: LD_VAR 0 4
35427: PUSH
35428: FOR_IN
35429: IFFALSE 35506
// if not IsControledBy ( j ) and GetLives ( j ) >= 250 then
35431: LD_VAR 0 3
35435: PPUSH
35436: CALL_OW 312
35440: NOT
35441: PUSH
35442: LD_VAR 0 3
35446: PPUSH
35447: CALL_OW 256
35451: PUSH
35452: LD_INT 250
35454: GREATEREQUAL
35455: AND
35456: IFFALSE 35469
// Connect ( j ) else
35458: LD_VAR 0 3
35462: PPUSH
35463: CALL 60676 0 1
35467: GO 35504
// if GetLives ( j ) < 250 and IsControledBy ( j ) then
35469: LD_VAR 0 3
35473: PPUSH
35474: CALL_OW 256
35478: PUSH
35479: LD_INT 250
35481: LESS
35482: PUSH
35483: LD_VAR 0 3
35487: PPUSH
35488: CALL_OW 312
35492: AND
35493: IFFALSE 35504
// ComUnlink ( j ) ;
35495: LD_VAR 0 3
35499: PPUSH
35500: CALL_OW 136
35504: GO 35428
35506: POP
35507: POP
// end ;
35508: GO 35366
35510: POP
35511: POP
// end ;
35512: LD_VAR 0 1
35516: RET
// export function MC_ProduceVehicle ( ) ; var i , j , tmp , fac ; begin
35517: LD_INT 0
35519: PPUSH
35520: PPUSH
35521: PPUSH
35522: PPUSH
35523: PPUSH
// if not mc_bases then
35524: LD_EXP 76
35528: NOT
35529: IFFALSE 35533
// exit ;
35531: GO 35978
// for i = 1 to mc_bases do
35533: LD_ADDR_VAR 0 2
35537: PUSH
35538: DOUBLE
35539: LD_INT 1
35541: DEC
35542: ST_TO_ADDR
35543: LD_EXP 76
35547: PUSH
35548: FOR_TO
35549: IFFALSE 35976
// begin if not mc_produce [ i ] then
35551: LD_EXP 97
35555: PUSH
35556: LD_VAR 0 2
35560: ARRAY
35561: NOT
35562: IFFALSE 35566
// continue ;
35564: GO 35548
// fac := UnitFilter ( mc_bases [ i ] , [ f_btype , b_factory ] ) ;
35566: LD_ADDR_VAR 0 5
35570: PUSH
35571: LD_EXP 76
35575: PUSH
35576: LD_VAR 0 2
35580: ARRAY
35581: PPUSH
35582: LD_INT 30
35584: PUSH
35585: LD_INT 3
35587: PUSH
35588: EMPTY
35589: LIST
35590: LIST
35591: PPUSH
35592: CALL_OW 72
35596: ST_TO_ADDR
// if not fac then
35597: LD_VAR 0 5
35601: NOT
35602: IFFALSE 35606
// continue ;
35604: GO 35548
// for j in fac do
35606: LD_ADDR_VAR 0 3
35610: PUSH
35611: LD_VAR 0 5
35615: PUSH
35616: FOR_IN
35617: IFFALSE 35972
// begin if BuildingStatus ( j ) <> bs_idle or DangerAtRange ( j , 15 ) [ 4 ] then
35619: LD_VAR 0 3
35623: PPUSH
35624: CALL_OW 461
35628: PUSH
35629: LD_INT 2
35631: NONEQUAL
35632: PUSH
35633: LD_VAR 0 3
35637: PPUSH
35638: LD_INT 15
35640: PPUSH
35641: CALL 60336 0 2
35645: PUSH
35646: LD_INT 4
35648: ARRAY
35649: OR
35650: IFFALSE 35654
// continue ;
35652: GO 35616
// if CanBeConstructed ( j , mc_produce [ i ] [ 1 ] [ 1 ] , mc_produce [ i ] [ 1 ] [ 2 ] , mc_produce [ i ] [ 1 ] [ 3 ] , mc_produce [ i ] [ 1 ] [ 4 ] ) and VehicleCost ( j , [ mc_produce [ i ] [ 1 ] [ 1 ] , mc_produce [ i ] [ 1 ] [ 2 ] , mc_produce [ i ] [ 1 ] [ 3 ] , mc_produce [ i ] [ 1 ] [ 4 ] ] ) then
35654: LD_VAR 0 3
35658: PPUSH
35659: LD_EXP 97
35663: PUSH
35664: LD_VAR 0 2
35668: ARRAY
35669: PUSH
35670: LD_INT 1
35672: ARRAY
35673: PUSH
35674: LD_INT 1
35676: ARRAY
35677: PPUSH
35678: LD_EXP 97
35682: PUSH
35683: LD_VAR 0 2
35687: ARRAY
35688: PUSH
35689: LD_INT 1
35691: ARRAY
35692: PUSH
35693: LD_INT 2
35695: ARRAY
35696: PPUSH
35697: LD_EXP 97
35701: PUSH
35702: LD_VAR 0 2
35706: ARRAY
35707: PUSH
35708: LD_INT 1
35710: ARRAY
35711: PUSH
35712: LD_INT 3
35714: ARRAY
35715: PPUSH
35716: LD_EXP 97
35720: PUSH
35721: LD_VAR 0 2
35725: ARRAY
35726: PUSH
35727: LD_INT 1
35729: ARRAY
35730: PUSH
35731: LD_INT 4
35733: ARRAY
35734: PPUSH
35735: CALL_OW 448
35739: PUSH
35740: LD_VAR 0 3
35744: PPUSH
35745: LD_EXP 97
35749: PUSH
35750: LD_VAR 0 2
35754: ARRAY
35755: PUSH
35756: LD_INT 1
35758: ARRAY
35759: PUSH
35760: LD_INT 1
35762: ARRAY
35763: PUSH
35764: LD_EXP 97
35768: PUSH
35769: LD_VAR 0 2
35773: ARRAY
35774: PUSH
35775: LD_INT 1
35777: ARRAY
35778: PUSH
35779: LD_INT 2
35781: ARRAY
35782: PUSH
35783: LD_EXP 97
35787: PUSH
35788: LD_VAR 0 2
35792: ARRAY
35793: PUSH
35794: LD_INT 1
35796: ARRAY
35797: PUSH
35798: LD_INT 3
35800: ARRAY
35801: PUSH
35802: LD_EXP 97
35806: PUSH
35807: LD_VAR 0 2
35811: ARRAY
35812: PUSH
35813: LD_INT 1
35815: ARRAY
35816: PUSH
35817: LD_INT 4
35819: ARRAY
35820: PUSH
35821: EMPTY
35822: LIST
35823: LIST
35824: LIST
35825: LIST
35826: PPUSH
35827: CALL 64007 0 2
35831: AND
35832: IFFALSE 35970
// begin AddComConstruct ( j , mc_produce [ i ] [ 1 ] [ 1 ] , mc_produce [ i ] [ 1 ] [ 2 ] , mc_produce [ i ] [ 1 ] [ 3 ] , mc_produce [ i ] [ 1 ] [ 4 ] ) ;
35834: LD_VAR 0 3
35838: PPUSH
35839: LD_EXP 97
35843: PUSH
35844: LD_VAR 0 2
35848: ARRAY
35849: PUSH
35850: LD_INT 1
35852: ARRAY
35853: PUSH
35854: LD_INT 1
35856: ARRAY
35857: PPUSH
35858: LD_EXP 97
35862: PUSH
35863: LD_VAR 0 2
35867: ARRAY
35868: PUSH
35869: LD_INT 1
35871: ARRAY
35872: PUSH
35873: LD_INT 2
35875: ARRAY
35876: PPUSH
35877: LD_EXP 97
35881: PUSH
35882: LD_VAR 0 2
35886: ARRAY
35887: PUSH
35888: LD_INT 1
35890: ARRAY
35891: PUSH
35892: LD_INT 3
35894: ARRAY
35895: PPUSH
35896: LD_EXP 97
35900: PUSH
35901: LD_VAR 0 2
35905: ARRAY
35906: PUSH
35907: LD_INT 1
35909: ARRAY
35910: PUSH
35911: LD_INT 4
35913: ARRAY
35914: PPUSH
35915: CALL_OW 185
// tmp := Delete ( mc_produce [ i ] , 1 ) ;
35919: LD_ADDR_VAR 0 4
35923: PUSH
35924: LD_EXP 97
35928: PUSH
35929: LD_VAR 0 2
35933: ARRAY
35934: PPUSH
35935: LD_INT 1
35937: PPUSH
35938: CALL_OW 3
35942: ST_TO_ADDR
// mc_produce := Replace ( mc_produce , i , tmp ) ;
35943: LD_ADDR_EXP 97
35947: PUSH
35948: LD_EXP 97
35952: PPUSH
35953: LD_VAR 0 2
35957: PPUSH
35958: LD_VAR 0 4
35962: PPUSH
35963: CALL_OW 1
35967: ST_TO_ADDR
// break ;
35968: GO 35972
// end ; end ;
35970: GO 35616
35972: POP
35973: POP
// end ;
35974: GO 35548
35976: POP
35977: POP
// end ;
35978: LD_VAR 0 1
35982: RET
// export function MC_SendAttack ( ) ; var i , tmp ; begin
35983: LD_INT 0
35985: PPUSH
35986: PPUSH
35987: PPUSH
// if not mc_bases then
35988: LD_EXP 76
35992: NOT
35993: IFFALSE 35997
// exit ;
35995: GO 36086
// for i = 1 to mc_bases do
35997: LD_ADDR_VAR 0 2
36001: PUSH
36002: DOUBLE
36003: LD_INT 1
36005: DEC
36006: ST_TO_ADDR
36007: LD_EXP 76
36011: PUSH
36012: FOR_TO
36013: IFFALSE 36084
// begin if mc_attack [ i ] then
36015: LD_EXP 96
36019: PUSH
36020: LD_VAR 0 2
36024: ARRAY
36025: IFFALSE 36082
// begin tmp := mc_attack [ i ] [ 1 ] ;
36027: LD_ADDR_VAR 0 3
36031: PUSH
36032: LD_EXP 96
36036: PUSH
36037: LD_VAR 0 2
36041: ARRAY
36042: PUSH
36043: LD_INT 1
36045: ARRAY
36046: ST_TO_ADDR
// mc_attack := Replace ( mc_attack , i , [ ] ) ;
36047: LD_ADDR_EXP 96
36051: PUSH
36052: LD_EXP 96
36056: PPUSH
36057: LD_VAR 0 2
36061: PPUSH
36062: EMPTY
36063: PPUSH
36064: CALL_OW 1
36068: ST_TO_ADDR
// Attack ( tmp ) ;
36069: LD_VAR 0 3
36073: PPUSH
36074: CALL 86197 0 1
// exit ;
36078: POP
36079: POP
36080: GO 36086
// end ; end ;
36082: GO 36012
36084: POP
36085: POP
// end ;
36086: LD_VAR 0 1
36090: RET
// export function MC_Defend ( ) ; var i , j , tmp , t , x , class ; begin
36091: LD_INT 0
36093: PPUSH
36094: PPUSH
36095: PPUSH
36096: PPUSH
36097: PPUSH
36098: PPUSH
36099: PPUSH
// if not mc_bases then
36100: LD_EXP 76
36104: NOT
36105: IFFALSE 36109
// exit ;
36107: GO 36691
// for i = 1 to mc_bases do
36109: LD_ADDR_VAR 0 2
36113: PUSH
36114: DOUBLE
36115: LD_INT 1
36117: DEC
36118: ST_TO_ADDR
36119: LD_EXP 76
36123: PUSH
36124: FOR_TO
36125: IFFALSE 36689
// begin if not mc_bases [ i ] then
36127: LD_EXP 76
36131: PUSH
36132: LD_VAR 0 2
36136: ARRAY
36137: NOT
36138: IFFALSE 36142
// continue ;
36140: GO 36124
// class := AllowSpecClass ( mc_bases [ i ] [ 1 ] ) ;
36142: LD_ADDR_VAR 0 7
36146: PUSH
36147: LD_EXP 76
36151: PUSH
36152: LD_VAR 0 2
36156: ARRAY
36157: PUSH
36158: LD_INT 1
36160: ARRAY
36161: PPUSH
36162: CALL 54579 0 1
36166: ST_TO_ADDR
// mc_scan := Replace ( mc_scan , i , ScanBase ( GetSide ( mc_bases [ i ] [ 1 ] ) , mc_scan_area [ i ] ) ) ;
36167: LD_ADDR_EXP 99
36171: PUSH
36172: LD_EXP 99
36176: PPUSH
36177: LD_VAR 0 2
36181: PPUSH
36182: LD_EXP 76
36186: PUSH
36187: LD_VAR 0 2
36191: ARRAY
36192: PUSH
36193: LD_INT 1
36195: ARRAY
36196: PPUSH
36197: CALL_OW 255
36201: PPUSH
36202: LD_EXP 101
36206: PUSH
36207: LD_VAR 0 2
36211: ARRAY
36212: PPUSH
36213: CALL 52133 0 2
36217: PPUSH
36218: CALL_OW 1
36222: ST_TO_ADDR
// if not mc_scan [ i ] then
36223: LD_EXP 99
36227: PUSH
36228: LD_VAR 0 2
36232: ARRAY
36233: NOT
36234: IFFALSE 36389
// begin tmp := UnitFilter ( mc_bases [ i ] , [ f_or , [ f_class , 5 ] , [ f_class , 8 ] , [ f_class , 9 ] ] ) ;
36236: LD_ADDR_VAR 0 4
36240: PUSH
36241: LD_EXP 76
36245: PUSH
36246: LD_VAR 0 2
36250: ARRAY
36251: PPUSH
36252: LD_INT 2
36254: PUSH
36255: LD_INT 25
36257: PUSH
36258: LD_INT 5
36260: PUSH
36261: EMPTY
36262: LIST
36263: LIST
36264: PUSH
36265: LD_INT 25
36267: PUSH
36268: LD_INT 8
36270: PUSH
36271: EMPTY
36272: LIST
36273: LIST
36274: PUSH
36275: LD_INT 25
36277: PUSH
36278: LD_INT 9
36280: PUSH
36281: EMPTY
36282: LIST
36283: LIST
36284: PUSH
36285: EMPTY
36286: LIST
36287: LIST
36288: LIST
36289: LIST
36290: PPUSH
36291: CALL_OW 72
36295: ST_TO_ADDR
// if not tmp then
36296: LD_VAR 0 4
36300: NOT
36301: IFFALSE 36305
// continue ;
36303: GO 36124
// for j in tmp do
36305: LD_ADDR_VAR 0 3
36309: PUSH
36310: LD_VAR 0 4
36314: PUSH
36315: FOR_IN
36316: IFFALSE 36387
// if GetBType ( IsInUnit ( j ) ) = b_barracks and GetClass ( j ) = 1 and not MineOfUnit ( j ) and class then
36318: LD_VAR 0 3
36322: PPUSH
36323: CALL_OW 310
36327: PPUSH
36328: CALL_OW 266
36332: PUSH
36333: LD_INT 5
36335: EQUAL
36336: PUSH
36337: LD_VAR 0 3
36341: PPUSH
36342: CALL_OW 257
36346: PUSH
36347: LD_INT 1
36349: EQUAL
36350: AND
36351: PUSH
36352: LD_VAR 0 3
36356: PPUSH
36357: CALL_OW 459
36361: NOT
36362: AND
36363: PUSH
36364: LD_VAR 0 7
36368: AND
36369: IFFALSE 36385
// ComChangeProfession ( j , class ) ;
36371: LD_VAR 0 3
36375: PPUSH
36376: LD_VAR 0 7
36380: PPUSH
36381: CALL_OW 123
36385: GO 36315
36387: POP
36388: POP
// end ; if mc_scan [ i ] and not mc_defender [ i ] and not UnitFilter ( mc_bases [ i ] , [ f_btype , b_bunker ] ) and not UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_armoury ] , [ f_btype , b_barracks ] ] ) then
36389: LD_EXP 99
36393: PUSH
36394: LD_VAR 0 2
36398: ARRAY
36399: PUSH
36400: LD_EXP 98
36404: PUSH
36405: LD_VAR 0 2
36409: ARRAY
36410: NOT
36411: AND
36412: PUSH
36413: LD_EXP 76
36417: PUSH
36418: LD_VAR 0 2
36422: ARRAY
36423: PPUSH
36424: LD_INT 30
36426: PUSH
36427: LD_INT 32
36429: PUSH
36430: EMPTY
36431: LIST
36432: LIST
36433: PPUSH
36434: CALL_OW 72
36438: NOT
36439: AND
36440: PUSH
36441: LD_EXP 76
36445: PUSH
36446: LD_VAR 0 2
36450: ARRAY
36451: PPUSH
36452: LD_INT 2
36454: PUSH
36455: LD_INT 30
36457: PUSH
36458: LD_INT 4
36460: PUSH
36461: EMPTY
36462: LIST
36463: LIST
36464: PUSH
36465: LD_INT 30
36467: PUSH
36468: LD_INT 5
36470: PUSH
36471: EMPTY
36472: LIST
36473: LIST
36474: PUSH
36475: EMPTY
36476: LIST
36477: LIST
36478: LIST
36479: PPUSH
36480: CALL_OW 72
36484: NOT
36485: AND
36486: IFFALSE 36618
// begin tmp := UnitFilter ( mc_bases [ i ] , [ f_or , [ f_class , 1 ] , [ f_class , 5 ] , [ f_class , 8 ] , [ f_class , 9 ] ] ) ;
36488: LD_ADDR_VAR 0 4
36492: PUSH
36493: LD_EXP 76
36497: PUSH
36498: LD_VAR 0 2
36502: ARRAY
36503: PPUSH
36504: LD_INT 2
36506: PUSH
36507: LD_INT 25
36509: PUSH
36510: LD_INT 1
36512: PUSH
36513: EMPTY
36514: LIST
36515: LIST
36516: PUSH
36517: LD_INT 25
36519: PUSH
36520: LD_INT 5
36522: PUSH
36523: EMPTY
36524: LIST
36525: LIST
36526: PUSH
36527: LD_INT 25
36529: PUSH
36530: LD_INT 8
36532: PUSH
36533: EMPTY
36534: LIST
36535: LIST
36536: PUSH
36537: LD_INT 25
36539: PUSH
36540: LD_INT 9
36542: PUSH
36543: EMPTY
36544: LIST
36545: LIST
36546: PUSH
36547: EMPTY
36548: LIST
36549: LIST
36550: LIST
36551: LIST
36552: LIST
36553: PPUSH
36554: CALL_OW 72
36558: ST_TO_ADDR
// tmp := tmp diff FilterByTag ( tmp , 18 ) ;
36559: LD_ADDR_VAR 0 4
36563: PUSH
36564: LD_VAR 0 4
36568: PUSH
36569: LD_VAR 0 4
36573: PPUSH
36574: LD_INT 18
36576: PPUSH
36577: CALL 91006 0 2
36581: DIFF
36582: ST_TO_ADDR
// if tmp then
36583: LD_VAR 0 4
36587: IFFALSE 36618
// begin BasicDefend ( i , tmp , mc_scan_area [ i ] ) ;
36589: LD_VAR 0 2
36593: PPUSH
36594: LD_VAR 0 4
36598: PPUSH
36599: LD_EXP 101
36603: PUSH
36604: LD_VAR 0 2
36608: ARRAY
36609: PPUSH
36610: CALL 52168 0 3
// exit ;
36614: POP
36615: POP
36616: GO 36691
// end ; end ; if mc_scan [ i ] and mc_defender [ i ] then
36618: LD_EXP 99
36622: PUSH
36623: LD_VAR 0 2
36627: ARRAY
36628: PUSH
36629: LD_EXP 98
36633: PUSH
36634: LD_VAR 0 2
36638: ARRAY
36639: AND
36640: IFFALSE 36687
// begin tmp := mc_defender [ i ] ;
36642: LD_ADDR_VAR 0 4
36646: PUSH
36647: LD_EXP 98
36651: PUSH
36652: LD_VAR 0 2
36656: ARRAY
36657: ST_TO_ADDR
// Defend ( i , tmp , mc_scan [ i ] ) ;
36658: LD_VAR 0 2
36662: PPUSH
36663: LD_VAR 0 4
36667: PPUSH
36668: LD_EXP 99
36672: PUSH
36673: LD_VAR 0 2
36677: ARRAY
36678: PPUSH
36679: CALL 52729 0 3
// exit ;
36683: POP
36684: POP
36685: GO 36691
// end ; end ;
36687: GO 36124
36689: POP
36690: POP
// end ;
36691: LD_VAR 0 1
36695: RET
// export function MC_Research ( ) ; var i , j , side , t , tmp , x , sci , tmp2 , researching , idle_lab ; begin
36696: LD_INT 0
36698: PPUSH
36699: PPUSH
36700: PPUSH
36701: PPUSH
36702: PPUSH
36703: PPUSH
36704: PPUSH
36705: PPUSH
36706: PPUSH
36707: PPUSH
36708: PPUSH
// if not mc_bases then
36709: LD_EXP 76
36713: NOT
36714: IFFALSE 36718
// exit ;
36716: GO 37805
// for i = 1 to mc_bases do
36718: LD_ADDR_VAR 0 2
36722: PUSH
36723: DOUBLE
36724: LD_INT 1
36726: DEC
36727: ST_TO_ADDR
36728: LD_EXP 76
36732: PUSH
36733: FOR_TO
36734: IFFALSE 37803
// begin tmp := mc_lab [ i ] ;
36736: LD_ADDR_VAR 0 6
36740: PUSH
36741: LD_EXP 109
36745: PUSH
36746: LD_VAR 0 2
36750: ARRAY
36751: ST_TO_ADDR
// if not tmp then
36752: LD_VAR 0 6
36756: NOT
36757: IFFALSE 36761
// continue ;
36759: GO 36733
// idle_lab := 0 ;
36761: LD_ADDR_VAR 0 11
36765: PUSH
36766: LD_INT 0
36768: ST_TO_ADDR
// for j in tmp do
36769: LD_ADDR_VAR 0 3
36773: PUSH
36774: LD_VAR 0 6
36778: PUSH
36779: FOR_IN
36780: IFFALSE 37799
// begin researching := false ;
36782: LD_ADDR_VAR 0 10
36786: PUSH
36787: LD_INT 0
36789: ST_TO_ADDR
// side := GetSide ( j ) ;
36790: LD_ADDR_VAR 0 4
36794: PUSH
36795: LD_VAR 0 3
36799: PPUSH
36800: CALL_OW 255
36804: ST_TO_ADDR
// if not mc_tech [ side ] then
36805: LD_EXP 103
36809: PUSH
36810: LD_VAR 0 4
36814: ARRAY
36815: NOT
36816: IFFALSE 36820
// continue ;
36818: GO 36779
// if BuildingStatus ( j ) = bs_idle then
36820: LD_VAR 0 3
36824: PPUSH
36825: CALL_OW 461
36829: PUSH
36830: LD_INT 2
36832: EQUAL
36833: IFFALSE 37021
// begin if idle_lab and UnitsInside ( j ) < 6 then
36835: LD_VAR 0 11
36839: PUSH
36840: LD_VAR 0 3
36844: PPUSH
36845: CALL_OW 313
36849: PUSH
36850: LD_INT 6
36852: LESS
36853: AND
36854: IFFALSE 36925
// begin tmp2 := UnitsInside ( idle_lab ) ;
36856: LD_ADDR_VAR 0 9
36860: PUSH
36861: LD_VAR 0 11
36865: PPUSH
36866: CALL_OW 313
36870: ST_TO_ADDR
// if tmp2 then
36871: LD_VAR 0 9
36875: IFFALSE 36917
// for x in tmp2 do
36877: LD_ADDR_VAR 0 7
36881: PUSH
36882: LD_VAR 0 9
36886: PUSH
36887: FOR_IN
36888: IFFALSE 36915
// begin ComExitBuilding ( x ) ;
36890: LD_VAR 0 7
36894: PPUSH
36895: CALL_OW 122
// AddComEnterUnit ( x , j ) ;
36899: LD_VAR 0 7
36903: PPUSH
36904: LD_VAR 0 3
36908: PPUSH
36909: CALL_OW 180
// end ;
36913: GO 36887
36915: POP
36916: POP
// idle_lab := 0 ;
36917: LD_ADDR_VAR 0 11
36921: PUSH
36922: LD_INT 0
36924: ST_TO_ADDR
// end ; for t in mc_tech [ side ] do
36925: LD_ADDR_VAR 0 5
36929: PUSH
36930: LD_EXP 103
36934: PUSH
36935: LD_VAR 0 4
36939: ARRAY
36940: PUSH
36941: FOR_IN
36942: IFFALSE 37002
// if CanBeResearched ( j , t ) and TechCanBeResearch ( side , t ) then
36944: LD_VAR 0 3
36948: PPUSH
36949: LD_VAR 0 5
36953: PPUSH
36954: CALL_OW 430
36958: PUSH
36959: LD_VAR 0 4
36963: PPUSH
36964: LD_VAR 0 5
36968: PPUSH
36969: CALL 51238 0 2
36973: AND
36974: IFFALSE 37000
// begin researching := true ;
36976: LD_ADDR_VAR 0 10
36980: PUSH
36981: LD_INT 1
36983: ST_TO_ADDR
// ComResearch ( j , t ) ;
36984: LD_VAR 0 3
36988: PPUSH
36989: LD_VAR 0 5
36993: PPUSH
36994: CALL_OW 124
// break ;
36998: GO 37002
// end ;
37000: GO 36941
37002: POP
37003: POP
// if not researching then
37004: LD_VAR 0 10
37008: NOT
37009: IFFALSE 37021
// idle_lab := j ;
37011: LD_ADDR_VAR 0 11
37015: PUSH
37016: LD_VAR 0 3
37020: ST_TO_ADDR
// end ; if BuildingStatus ( j ) = bs_need_ape then
37021: LD_VAR 0 3
37025: PPUSH
37026: CALL_OW 461
37030: PUSH
37031: LD_INT 10
37033: EQUAL
37034: IFFALSE 37622
// begin if not mc_ape [ i ] and not mc_ape_in_lab [ i ] and mc_tech [ side ] > 1 then
37036: LD_EXP 105
37040: PUSH
37041: LD_VAR 0 2
37045: ARRAY
37046: NOT
37047: PUSH
37048: LD_EXP 106
37052: PUSH
37053: LD_VAR 0 2
37057: ARRAY
37058: NOT
37059: AND
37060: PUSH
37061: LD_EXP 103
37065: PUSH
37066: LD_VAR 0 4
37070: ARRAY
37071: PUSH
37072: LD_INT 1
37074: GREATER
37075: AND
37076: IFFALSE 37207
// begin ComCancel ( j ) ;
37078: LD_VAR 0 3
37082: PPUSH
37083: CALL_OW 127
// mc_tech := Replace ( mc_tech , side , Reindex ( mc_tech [ side ] , mc_tech [ side ] - 1 , mc_tech [ side ] , false ) ) ;
37087: LD_ADDR_EXP 103
37091: PUSH
37092: LD_EXP 103
37096: PPUSH
37097: LD_VAR 0 4
37101: PPUSH
37102: LD_EXP 103
37106: PUSH
37107: LD_VAR 0 4
37111: ARRAY
37112: PPUSH
37113: LD_EXP 103
37117: PUSH
37118: LD_VAR 0 4
37122: ARRAY
37123: PUSH
37124: LD_INT 1
37126: MINUS
37127: PPUSH
37128: LD_EXP 103
37132: PUSH
37133: LD_VAR 0 4
37137: ARRAY
37138: PPUSH
37139: LD_INT 0
37141: PPUSH
37142: CALL 57161 0 4
37146: PPUSH
37147: CALL_OW 1
37151: ST_TO_ADDR
// mc_tech := Replace ( mc_tech , side , Reindex ( mc_tech [ side ] , mc_tech [ side ] , 1 , false ) ) ;
37152: LD_ADDR_EXP 103
37156: PUSH
37157: LD_EXP 103
37161: PPUSH
37162: LD_VAR 0 4
37166: PPUSH
37167: LD_EXP 103
37171: PUSH
37172: LD_VAR 0 4
37176: ARRAY
37177: PPUSH
37178: LD_EXP 103
37182: PUSH
37183: LD_VAR 0 4
37187: ARRAY
37188: PPUSH
37189: LD_INT 1
37191: PPUSH
37192: LD_INT 0
37194: PPUSH
37195: CALL 57161 0 4
37199: PPUSH
37200: CALL_OW 1
37204: ST_TO_ADDR
// continue ;
37205: GO 36779
// end ; if mc_ape [ i ] and not mc_ape_in_lab [ i ] then
37207: LD_EXP 105
37211: PUSH
37212: LD_VAR 0 2
37216: ARRAY
37217: PUSH
37218: LD_EXP 106
37222: PUSH
37223: LD_VAR 0 2
37227: ARRAY
37228: NOT
37229: AND
37230: IFFALSE 37357
// begin mc_ape_in_lab := ReplaceIn ( mc_ape_in_lab , [ i , mc_ape_in_lab [ i ] + 1 ] , mc_ape [ i ] [ 1 ] ) ;
37232: LD_ADDR_EXP 106
37236: PUSH
37237: LD_EXP 106
37241: PPUSH
37242: LD_VAR 0 2
37246: PUSH
37247: LD_EXP 106
37251: PUSH
37252: LD_VAR 0 2
37256: ARRAY
37257: PUSH
37258: LD_INT 1
37260: PLUS
37261: PUSH
37262: EMPTY
37263: LIST
37264: LIST
37265: PPUSH
37266: LD_EXP 105
37270: PUSH
37271: LD_VAR 0 2
37275: ARRAY
37276: PUSH
37277: LD_INT 1
37279: ARRAY
37280: PPUSH
37281: CALL 57743 0 3
37285: ST_TO_ADDR
// SetTag ( mc_ape [ i ] [ 1 ] , 112 ) ;
37286: LD_EXP 105
37290: PUSH
37291: LD_VAR 0 2
37295: ARRAY
37296: PUSH
37297: LD_INT 1
37299: ARRAY
37300: PPUSH
37301: LD_INT 112
37303: PPUSH
37304: CALL_OW 109
// tmp2 := Delete ( mc_ape [ i ] , 1 ) ;
37308: LD_ADDR_VAR 0 9
37312: PUSH
37313: LD_EXP 105
37317: PUSH
37318: LD_VAR 0 2
37322: ARRAY
37323: PPUSH
37324: LD_INT 1
37326: PPUSH
37327: CALL_OW 3
37331: ST_TO_ADDR
// mc_ape := Replace ( mc_ape , i , tmp2 ) ;
37332: LD_ADDR_EXP 105
37336: PUSH
37337: LD_EXP 105
37341: PPUSH
37342: LD_VAR 0 2
37346: PPUSH
37347: LD_VAR 0 9
37351: PPUSH
37352: CALL_OW 1
37356: ST_TO_ADDR
// end ; if mc_ape [ i ] and mc_ape_in_lab [ i ] and not IsInUnit ( mc_ape_in_lab [ i ] [ 1 ] ) and UnitsInside ( j ) = 6 then
37357: LD_EXP 105
37361: PUSH
37362: LD_VAR 0 2
37366: ARRAY
37367: PUSH
37368: LD_EXP 106
37372: PUSH
37373: LD_VAR 0 2
37377: ARRAY
37378: AND
37379: PUSH
37380: LD_EXP 106
37384: PUSH
37385: LD_VAR 0 2
37389: ARRAY
37390: PUSH
37391: LD_INT 1
37393: ARRAY
37394: PPUSH
37395: CALL_OW 310
37399: NOT
37400: AND
37401: PUSH
37402: LD_VAR 0 3
37406: PPUSH
37407: CALL_OW 313
37411: PUSH
37412: LD_INT 6
37414: EQUAL
37415: AND
37416: IFFALSE 37472
// begin tmp2 := UnitsInside ( j ) ;
37418: LD_ADDR_VAR 0 9
37422: PUSH
37423: LD_VAR 0 3
37427: PPUSH
37428: CALL_OW 313
37432: ST_TO_ADDR
// if tmp2 = 6 then
37433: LD_VAR 0 9
37437: PUSH
37438: LD_INT 6
37440: EQUAL
37441: IFFALSE 37472
// begin SetTag ( tmp2 [ 1 ] , 112 ) ;
37443: LD_VAR 0 9
37447: PUSH
37448: LD_INT 1
37450: ARRAY
37451: PPUSH
37452: LD_INT 112
37454: PPUSH
37455: CALL_OW 109
// ComExitBuilding ( tmp2 [ 1 ] ) ;
37459: LD_VAR 0 9
37463: PUSH
37464: LD_INT 1
37466: ARRAY
37467: PPUSH
37468: CALL_OW 122
// end ; end ; if mc_ape_in_lab [ i ] and not HasTask ( mc_ape_in_lab [ i ] [ 1 ] ) and not IsInUnit ( mc_ape_in_lab [ i ] [ 1 ] ) then
37472: LD_EXP 106
37476: PUSH
37477: LD_VAR 0 2
37481: ARRAY
37482: PUSH
37483: LD_EXP 106
37487: PUSH
37488: LD_VAR 0 2
37492: ARRAY
37493: PUSH
37494: LD_INT 1
37496: ARRAY
37497: PPUSH
37498: CALL_OW 314
37502: NOT
37503: AND
37504: PUSH
37505: LD_EXP 106
37509: PUSH
37510: LD_VAR 0 2
37514: ARRAY
37515: PUSH
37516: LD_INT 1
37518: ARRAY
37519: PPUSH
37520: CALL_OW 310
37524: NOT
37525: AND
37526: IFFALSE 37552
// ComEnterUnit ( mc_ape_in_lab [ i ] [ 1 ] , j ) ;
37528: LD_EXP 106
37532: PUSH
37533: LD_VAR 0 2
37537: ARRAY
37538: PUSH
37539: LD_INT 1
37541: ARRAY
37542: PPUSH
37543: LD_VAR 0 3
37547: PPUSH
37548: CALL_OW 120
// if IsInUnit ( mc_ape_in_lab [ i ] [ 1 ] ) and BuildingStatus ( IsInUnit ( mc_ape_in_lab [ i ] [ 1 ] ) ) <> bs_working then
37552: LD_EXP 106
37556: PUSH
37557: LD_VAR 0 2
37561: ARRAY
37562: PUSH
37563: LD_INT 1
37565: ARRAY
37566: PPUSH
37567: CALL_OW 310
37571: PUSH
37572: LD_EXP 106
37576: PUSH
37577: LD_VAR 0 2
37581: ARRAY
37582: PUSH
37583: LD_INT 1
37585: ARRAY
37586: PPUSH
37587: CALL_OW 310
37591: PPUSH
37592: CALL_OW 461
37596: PUSH
37597: LD_INT 3
37599: NONEQUAL
37600: AND
37601: IFFALSE 37622
// ComExitBuilding ( mc_ape_in_lab [ i ] [ 1 ] ) ;
37603: LD_EXP 106
37607: PUSH
37608: LD_VAR 0 2
37612: ARRAY
37613: PUSH
37614: LD_INT 1
37616: ARRAY
37617: PPUSH
37618: CALL_OW 122
// end ; if BuildingStatus ( j ) = bs_need_people and tmp > 1 then
37622: LD_VAR 0 3
37626: PPUSH
37627: CALL_OW 461
37631: PUSH
37632: LD_INT 6
37634: EQUAL
37635: PUSH
37636: LD_VAR 0 6
37640: PUSH
37641: LD_INT 1
37643: GREATER
37644: AND
37645: IFFALSE 37797
// begin sci := [ ] ;
37647: LD_ADDR_VAR 0 8
37651: PUSH
37652: EMPTY
37653: ST_TO_ADDR
// for x in ( tmp diff j ) do
37654: LD_ADDR_VAR 0 7
37658: PUSH
37659: LD_VAR 0 6
37663: PUSH
37664: LD_VAR 0 3
37668: DIFF
37669: PUSH
37670: FOR_IN
37671: IFFALSE 37723
// begin if sci = 6 then
37673: LD_VAR 0 8
37677: PUSH
37678: LD_INT 6
37680: EQUAL
37681: IFFALSE 37685
// break ;
37683: GO 37723
// if BuildingStatus ( x ) = bs_idle then
37685: LD_VAR 0 7
37689: PPUSH
37690: CALL_OW 461
37694: PUSH
37695: LD_INT 2
37697: EQUAL
37698: IFFALSE 37721
// sci := sci ^ UnitsInside ( x ) ;
37700: LD_ADDR_VAR 0 8
37704: PUSH
37705: LD_VAR 0 8
37709: PUSH
37710: LD_VAR 0 7
37714: PPUSH
37715: CALL_OW 313
37719: ADD
37720: ST_TO_ADDR
// end ;
37721: GO 37670
37723: POP
37724: POP
// if not sci then
37725: LD_VAR 0 8
37729: NOT
37730: IFFALSE 37734
// continue ;
37732: GO 36779
// for x in sci do
37734: LD_ADDR_VAR 0 7
37738: PUSH
37739: LD_VAR 0 8
37743: PUSH
37744: FOR_IN
37745: IFFALSE 37795
// if IsInUnit ( x ) and not HasTask ( x ) then
37747: LD_VAR 0 7
37751: PPUSH
37752: CALL_OW 310
37756: PUSH
37757: LD_VAR 0 7
37761: PPUSH
37762: CALL_OW 314
37766: NOT
37767: AND
37768: IFFALSE 37793
// begin ComExitBuilding ( x ) ;
37770: LD_VAR 0 7
37774: PPUSH
37775: CALL_OW 122
// AddComEnterUnit ( x , j ) ;
37779: LD_VAR 0 7
37783: PPUSH
37784: LD_VAR 0 3
37788: PPUSH
37789: CALL_OW 180
// end ;
37793: GO 37744
37795: POP
37796: POP
// end ; end ;
37797: GO 36779
37799: POP
37800: POP
// end ;
37801: GO 36733
37803: POP
37804: POP
// end ;
37805: LD_VAR 0 1
37809: RET
// export function MC_MinesTrigger ( ) ; var i ; begin
37810: LD_INT 0
37812: PPUSH
37813: PPUSH
// if not mc_bases then
37814: LD_EXP 76
37818: NOT
37819: IFFALSE 37823
// exit ;
37821: GO 37904
// for i = 1 to mc_bases do
37823: LD_ADDR_VAR 0 2
37827: PUSH
37828: DOUBLE
37829: LD_INT 1
37831: DEC
37832: ST_TO_ADDR
37833: LD_EXP 76
37837: PUSH
37838: FOR_TO
37839: IFFALSE 37902
// if mc_mines [ i ] and mc_miners [ i ] then
37841: LD_EXP 89
37845: PUSH
37846: LD_VAR 0 2
37850: ARRAY
37851: PUSH
37852: LD_EXP 90
37856: PUSH
37857: LD_VAR 0 2
37861: ARRAY
37862: AND
37863: IFFALSE 37900
// DetonateMines ( GetSide ( mc_miners [ i ] [ 1 ] ) , mc_mines [ i ] ) ;
37865: LD_EXP 90
37869: PUSH
37870: LD_VAR 0 2
37874: ARRAY
37875: PUSH
37876: LD_INT 1
37878: ARRAY
37879: PPUSH
37880: CALL_OW 255
37884: PPUSH
37885: LD_EXP 89
37889: PUSH
37890: LD_VAR 0 2
37894: ARRAY
37895: PPUSH
37896: CALL 54732 0 2
37900: GO 37838
37902: POP
37903: POP
// end ;
37904: LD_VAR 0 1
37908: RET
// export function MC_RepairVehicle ( ) ; var i , j , k , side , fac , vehs , tmp ; begin
37909: LD_INT 0
37911: PPUSH
37912: PPUSH
37913: PPUSH
37914: PPUSH
37915: PPUSH
37916: PPUSH
37917: PPUSH
37918: PPUSH
// if not mc_bases or not mc_parking then
37919: LD_EXP 76
37923: NOT
37924: PUSH
37925: LD_EXP 100
37929: NOT
37930: OR
37931: IFFALSE 37935
// exit ;
37933: GO 38634
// for i = 1 to mc_bases do
37935: LD_ADDR_VAR 0 2
37939: PUSH
37940: DOUBLE
37941: LD_INT 1
37943: DEC
37944: ST_TO_ADDR
37945: LD_EXP 76
37949: PUSH
37950: FOR_TO
37951: IFFALSE 38632
// begin if not mc_bases [ i ] or not mc_parking [ i ] then
37953: LD_EXP 76
37957: PUSH
37958: LD_VAR 0 2
37962: ARRAY
37963: NOT
37964: PUSH
37965: LD_EXP 100
37969: PUSH
37970: LD_VAR 0 2
37974: ARRAY
37975: NOT
37976: OR
37977: IFFALSE 37981
// continue ;
37979: GO 37950
// side := GetSide ( mc_bases [ i ] [ 1 ] ) ;
37981: LD_ADDR_VAR 0 5
37985: PUSH
37986: LD_EXP 76
37990: PUSH
37991: LD_VAR 0 2
37995: ARRAY
37996: PUSH
37997: LD_INT 1
37999: ARRAY
38000: PPUSH
38001: CALL_OW 255
38005: ST_TO_ADDR
// fac := UnitFilter ( mc_bases [ i ] , [ f_btype , b_factory ] ) ;
38006: LD_ADDR_VAR 0 6
38010: PUSH
38011: LD_EXP 76
38015: PUSH
38016: LD_VAR 0 2
38020: ARRAY
38021: PPUSH
38022: LD_INT 30
38024: PUSH
38025: LD_INT 3
38027: PUSH
38028: EMPTY
38029: LIST
38030: LIST
38031: PPUSH
38032: CALL_OW 72
38036: ST_TO_ADDR
// if not fac then
38037: LD_VAR 0 6
38041: NOT
38042: IFFALSE 38093
// fac := UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) ;
38044: LD_ADDR_VAR 0 6
38048: PUSH
38049: LD_EXP 76
38053: PUSH
38054: LD_VAR 0 2
38058: ARRAY
38059: PPUSH
38060: LD_INT 2
38062: PUSH
38063: LD_INT 30
38065: PUSH
38066: LD_INT 0
38068: PUSH
38069: EMPTY
38070: LIST
38071: LIST
38072: PUSH
38073: LD_INT 30
38075: PUSH
38076: LD_INT 1
38078: PUSH
38079: EMPTY
38080: LIST
38081: LIST
38082: PUSH
38083: EMPTY
38084: LIST
38085: LIST
38086: LIST
38087: PPUSH
38088: CALL_OW 72
38092: ST_TO_ADDR
// if not fac then
38093: LD_VAR 0 6
38097: NOT
38098: IFFALSE 38102
// continue ;
38100: GO 37950
// vehs := FilterUnitsInArea ( mc_parking [ i ] , [ [ f_side , side ] , [ f_type , unit_vehicle ] , [ f_not , [ f_lives , 1000 ] ] ] ) ;
38102: LD_ADDR_VAR 0 7
38106: PUSH
38107: LD_EXP 100
38111: PUSH
38112: LD_VAR 0 2
38116: ARRAY
38117: PPUSH
38118: LD_INT 22
38120: PUSH
38121: LD_VAR 0 5
38125: PUSH
38126: EMPTY
38127: LIST
38128: LIST
38129: PUSH
38130: LD_INT 21
38132: PUSH
38133: LD_INT 2
38135: PUSH
38136: EMPTY
38137: LIST
38138: LIST
38139: PUSH
38140: LD_INT 3
38142: PUSH
38143: LD_INT 24
38145: PUSH
38146: LD_INT 1000
38148: PUSH
38149: EMPTY
38150: LIST
38151: LIST
38152: PUSH
38153: EMPTY
38154: LIST
38155: LIST
38156: PUSH
38157: EMPTY
38158: LIST
38159: LIST
38160: LIST
38161: PPUSH
38162: CALL_OW 70
38166: ST_TO_ADDR
// for j in fac do
38167: LD_ADDR_VAR 0 3
38171: PUSH
38172: LD_VAR 0 6
38176: PUSH
38177: FOR_IN
38178: IFFALSE 38259
// vehs := vehs union FilterAllUnits ( [ [ f_side , side ] , [ f_dist , j , 15 ] , [ f_type , unit_vehicle ] , [ f_not , [ f_lives , 1000 ] ] ] ) ;
38180: LD_ADDR_VAR 0 7
38184: PUSH
38185: LD_VAR 0 7
38189: PUSH
38190: LD_INT 22
38192: PUSH
38193: LD_VAR 0 5
38197: PUSH
38198: EMPTY
38199: LIST
38200: LIST
38201: PUSH
38202: LD_INT 91
38204: PUSH
38205: LD_VAR 0 3
38209: PUSH
38210: LD_INT 15
38212: PUSH
38213: EMPTY
38214: LIST
38215: LIST
38216: LIST
38217: PUSH
38218: LD_INT 21
38220: PUSH
38221: LD_INT 2
38223: PUSH
38224: EMPTY
38225: LIST
38226: LIST
38227: PUSH
38228: LD_INT 3
38230: PUSH
38231: LD_INT 24
38233: PUSH
38234: LD_INT 1000
38236: PUSH
38237: EMPTY
38238: LIST
38239: LIST
38240: PUSH
38241: EMPTY
38242: LIST
38243: LIST
38244: PUSH
38245: EMPTY
38246: LIST
38247: LIST
38248: LIST
38249: LIST
38250: PPUSH
38251: CALL_OW 69
38255: UNION
38256: ST_TO_ADDR
38257: GO 38177
38259: POP
38260: POP
// if not vehs then
38261: LD_VAR 0 7
38265: NOT
38266: IFFALSE 38292
// begin mc_repair_vehicle := Replace ( mc_repair_vehicle , i , [ ] ) ;
38268: LD_ADDR_EXP 88
38272: PUSH
38273: LD_EXP 88
38277: PPUSH
38278: LD_VAR 0 2
38282: PPUSH
38283: EMPTY
38284: PPUSH
38285: CALL_OW 1
38289: ST_TO_ADDR
// continue ;
38290: GO 37950
// end ; tmp := UnitFilter ( mc_bases [ i ] , [ f_btype , b_factory ] ) ;
38292: LD_ADDR_VAR 0 8
38296: PUSH
38297: LD_EXP 76
38301: PUSH
38302: LD_VAR 0 2
38306: ARRAY
38307: PPUSH
38308: LD_INT 30
38310: PUSH
38311: LD_INT 3
38313: PUSH
38314: EMPTY
38315: LIST
38316: LIST
38317: PPUSH
38318: CALL_OW 72
38322: ST_TO_ADDR
// if tmp then
38323: LD_VAR 0 8
38327: IFFALSE 38430
// begin for j in tmp do
38329: LD_ADDR_VAR 0 3
38333: PUSH
38334: LD_VAR 0 8
38338: PUSH
38339: FOR_IN
38340: IFFALSE 38428
// for k in UnitsInside ( j ) do
38342: LD_ADDR_VAR 0 4
38346: PUSH
38347: LD_VAR 0 3
38351: PPUSH
38352: CALL_OW 313
38356: PUSH
38357: FOR_IN
38358: IFFALSE 38424
// if k then
38360: LD_VAR 0 4
38364: IFFALSE 38422
// if not k in mc_repair_vehicle [ i ] then
38366: LD_VAR 0 4
38370: PUSH
38371: LD_EXP 88
38375: PUSH
38376: LD_VAR 0 2
38380: ARRAY
38381: IN
38382: NOT
38383: IFFALSE 38422
// mc_repair_vehicle := Replace ( mc_repair_vehicle , i , mc_repair_vehicle [ i ] union k ) ;
38385: LD_ADDR_EXP 88
38389: PUSH
38390: LD_EXP 88
38394: PPUSH
38395: LD_VAR 0 2
38399: PPUSH
38400: LD_EXP 88
38404: PUSH
38405: LD_VAR 0 2
38409: ARRAY
38410: PUSH
38411: LD_VAR 0 4
38415: UNION
38416: PPUSH
38417: CALL_OW 1
38421: ST_TO_ADDR
38422: GO 38357
38424: POP
38425: POP
38426: GO 38339
38428: POP
38429: POP
// end ; if not mc_repair_vehicle [ i ] then
38430: LD_EXP 88
38434: PUSH
38435: LD_VAR 0 2
38439: ARRAY
38440: NOT
38441: IFFALSE 38445
// continue ;
38443: GO 37950
// for j in mc_repair_vehicle [ i ] do
38445: LD_ADDR_VAR 0 3
38449: PUSH
38450: LD_EXP 88
38454: PUSH
38455: LD_VAR 0 2
38459: ARRAY
38460: PUSH
38461: FOR_IN
38462: IFFALSE 38628
// begin if GetClass ( j ) <> 3 then
38464: LD_VAR 0 3
38468: PPUSH
38469: CALL_OW 257
38473: PUSH
38474: LD_INT 3
38476: NONEQUAL
38477: IFFALSE 38518
// begin mc_repair_vehicle := Replace ( mc_repair_vehicle , i , mc_repair_vehicle [ i ] diff j ) ;
38479: LD_ADDR_EXP 88
38483: PUSH
38484: LD_EXP 88
38488: PPUSH
38489: LD_VAR 0 2
38493: PPUSH
38494: LD_EXP 88
38498: PUSH
38499: LD_VAR 0 2
38503: ARRAY
38504: PUSH
38505: LD_VAR 0 3
38509: DIFF
38510: PPUSH
38511: CALL_OW 1
38515: ST_TO_ADDR
// continue ;
38516: GO 38461
// end ; if not IsDrivenBy ( j ) and not j in mc_need_heal [ i ] [ 1 ] and not j in mc_need_heal [ i ] [ 2 ] then
38518: LD_VAR 0 3
38522: PPUSH
38523: CALL_OW 311
38527: NOT
38528: PUSH
38529: LD_VAR 0 3
38533: PUSH
38534: LD_EXP 79
38538: PUSH
38539: LD_VAR 0 2
38543: ARRAY
38544: PUSH
38545: LD_INT 1
38547: ARRAY
38548: IN
38549: NOT
38550: AND
38551: PUSH
38552: LD_VAR 0 3
38556: PUSH
38557: LD_EXP 79
38561: PUSH
38562: LD_VAR 0 2
38566: ARRAY
38567: PUSH
38568: LD_INT 2
38570: ARRAY
38571: IN
38572: NOT
38573: AND
38574: IFFALSE 38626
// begin if IsInUnit ( j ) then
38576: LD_VAR 0 3
38580: PPUSH
38581: CALL_OW 310
38585: IFFALSE 38596
// ComExitBuilding ( j ) ;
38587: LD_VAR 0 3
38591: PPUSH
38592: CALL_OW 122
// if not HasTask ( j ) then
38596: LD_VAR 0 3
38600: PPUSH
38601: CALL_OW 314
38605: NOT
38606: IFFALSE 38626
// AddComRepairVehicle ( j , vehs [ 1 ] ) ;
38608: LD_VAR 0 3
38612: PPUSH
38613: LD_VAR 0 7
38617: PUSH
38618: LD_INT 1
38620: ARRAY
38621: PPUSH
38622: CALL_OW 189
// end ; end ;
38626: GO 38461
38628: POP
38629: POP
// end ;
38630: GO 37950
38632: POP
38633: POP
// end ;
38634: LD_VAR 0 1
38638: RET
// export function MC_TameApe ( ) ; var i , j , x , y , ape , apes , tmp , dep , danger_at_area , side ; begin
38639: LD_INT 0
38641: PPUSH
38642: PPUSH
38643: PPUSH
38644: PPUSH
38645: PPUSH
38646: PPUSH
38647: PPUSH
38648: PPUSH
38649: PPUSH
38650: PPUSH
38651: PPUSH
// if not mc_bases then
38652: LD_EXP 76
38656: NOT
38657: IFFALSE 38661
// exit ;
38659: GO 39463
// for i = 1 to mc_bases do
38661: LD_ADDR_VAR 0 2
38665: PUSH
38666: DOUBLE
38667: LD_INT 1
38669: DEC
38670: ST_TO_ADDR
38671: LD_EXP 76
38675: PUSH
38676: FOR_TO
38677: IFFALSE 39461
// begin if not mc_can_tame [ i ] or mc_need_heal [ i ] [ 1 ] or mc_need_heal [ i ] [ 2 ] or not Researched ( mc_sides [ i ] , tech_apelang ) or mc_scan [ i ] then
38679: LD_EXP 104
38683: PUSH
38684: LD_VAR 0 2
38688: ARRAY
38689: NOT
38690: PUSH
38691: LD_EXP 79
38695: PUSH
38696: LD_VAR 0 2
38700: ARRAY
38701: PUSH
38702: LD_INT 1
38704: ARRAY
38705: OR
38706: PUSH
38707: LD_EXP 79
38711: PUSH
38712: LD_VAR 0 2
38716: ARRAY
38717: PUSH
38718: LD_INT 2
38720: ARRAY
38721: OR
38722: PUSH
38723: LD_EXP 102
38727: PUSH
38728: LD_VAR 0 2
38732: ARRAY
38733: PPUSH
38734: LD_INT 1
38736: PPUSH
38737: CALL_OW 325
38741: NOT
38742: OR
38743: PUSH
38744: LD_EXP 99
38748: PUSH
38749: LD_VAR 0 2
38753: ARRAY
38754: OR
38755: IFFALSE 38759
// continue ;
38757: GO 38676
// tmp := UnitFilter ( mc_bases [ i ] , [ [ f_class , 4 ] , [ f_ok ] , [ f_not , [ f_hastask ] ] ] ) diff mc_healers [ i ] ;
38759: LD_ADDR_VAR 0 8
38763: PUSH
38764: LD_EXP 76
38768: PUSH
38769: LD_VAR 0 2
38773: ARRAY
38774: PPUSH
38775: LD_INT 25
38777: PUSH
38778: LD_INT 4
38780: PUSH
38781: EMPTY
38782: LIST
38783: LIST
38784: PUSH
38785: LD_INT 50
38787: PUSH
38788: EMPTY
38789: LIST
38790: PUSH
38791: LD_INT 3
38793: PUSH
38794: LD_INT 60
38796: PUSH
38797: EMPTY
38798: LIST
38799: PUSH
38800: EMPTY
38801: LIST
38802: LIST
38803: PUSH
38804: EMPTY
38805: LIST
38806: LIST
38807: LIST
38808: PPUSH
38809: CALL_OW 72
38813: PUSH
38814: LD_EXP 80
38818: PUSH
38819: LD_VAR 0 2
38823: ARRAY
38824: DIFF
38825: ST_TO_ADDR
// dep := UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) ;
38826: LD_ADDR_VAR 0 9
38830: PUSH
38831: LD_EXP 76
38835: PUSH
38836: LD_VAR 0 2
38840: ARRAY
38841: PPUSH
38842: LD_INT 2
38844: PUSH
38845: LD_INT 30
38847: PUSH
38848: LD_INT 0
38850: PUSH
38851: EMPTY
38852: LIST
38853: LIST
38854: PUSH
38855: LD_INT 30
38857: PUSH
38858: LD_INT 1
38860: PUSH
38861: EMPTY
38862: LIST
38863: LIST
38864: PUSH
38865: EMPTY
38866: LIST
38867: LIST
38868: LIST
38869: PPUSH
38870: CALL_OW 72
38874: ST_TO_ADDR
// if not tmp or not dep then
38875: LD_VAR 0 8
38879: NOT
38880: PUSH
38881: LD_VAR 0 9
38885: NOT
38886: OR
38887: IFFALSE 38891
// continue ;
38889: GO 38676
// side := GetSide ( tmp [ 1 ] ) ;
38891: LD_ADDR_VAR 0 11
38895: PUSH
38896: LD_VAR 0 8
38900: PUSH
38901: LD_INT 1
38903: ARRAY
38904: PPUSH
38905: CALL_OW 255
38909: ST_TO_ADDR
// dep := dep [ 1 ] ;
38910: LD_ADDR_VAR 0 9
38914: PUSH
38915: LD_VAR 0 9
38919: PUSH
38920: LD_INT 1
38922: ARRAY
38923: ST_TO_ADDR
// apes := FilterUnitsInArea ( mc_can_tame [ i ] , [ [ f_side , 0 ] , [ f_class , class_apeman ] ] ) union FilterAllUnits ( [ [ f_side , 0 ] , [ f_class , class_apeman ] , [ f_dist , dep , 20 ] ] ) ;
38924: LD_ADDR_VAR 0 7
38928: PUSH
38929: LD_EXP 104
38933: PUSH
38934: LD_VAR 0 2
38938: ARRAY
38939: PPUSH
38940: LD_INT 22
38942: PUSH
38943: LD_INT 0
38945: PUSH
38946: EMPTY
38947: LIST
38948: LIST
38949: PUSH
38950: LD_INT 25
38952: PUSH
38953: LD_INT 12
38955: PUSH
38956: EMPTY
38957: LIST
38958: LIST
38959: PUSH
38960: EMPTY
38961: LIST
38962: LIST
38963: PPUSH
38964: CALL_OW 70
38968: PUSH
38969: LD_INT 22
38971: PUSH
38972: LD_INT 0
38974: PUSH
38975: EMPTY
38976: LIST
38977: LIST
38978: PUSH
38979: LD_INT 25
38981: PUSH
38982: LD_INT 12
38984: PUSH
38985: EMPTY
38986: LIST
38987: LIST
38988: PUSH
38989: LD_INT 91
38991: PUSH
38992: LD_VAR 0 9
38996: PUSH
38997: LD_INT 20
38999: PUSH
39000: EMPTY
39001: LIST
39002: LIST
39003: LIST
39004: PUSH
39005: EMPTY
39006: LIST
39007: LIST
39008: LIST
39009: PPUSH
39010: CALL_OW 69
39014: UNION
39015: ST_TO_ADDR
// danger_at_area := FilterUnitsInArea ( mc_can_tame [ i ] , [ f_enemy , side ] ) ;
39016: LD_ADDR_VAR 0 10
39020: PUSH
39021: LD_EXP 104
39025: PUSH
39026: LD_VAR 0 2
39030: ARRAY
39031: PPUSH
39032: LD_INT 81
39034: PUSH
39035: LD_VAR 0 11
39039: PUSH
39040: EMPTY
39041: LIST
39042: LIST
39043: PPUSH
39044: CALL_OW 70
39048: ST_TO_ADDR
// if not apes or danger_at_area then
39049: LD_VAR 0 7
39053: NOT
39054: PUSH
39055: LD_VAR 0 10
39059: OR
39060: IFFALSE 39110
// begin if mc_taming [ i ] then
39062: LD_EXP 107
39066: PUSH
39067: LD_VAR 0 2
39071: ARRAY
39072: IFFALSE 39108
// begin MC_Reset ( i , 121 ) ;
39074: LD_VAR 0 2
39078: PPUSH
39079: LD_INT 121
39081: PPUSH
39082: CALL 24545 0 2
// mc_taming := Replace ( mc_taming , i , [ ] ) ;
39086: LD_ADDR_EXP 107
39090: PUSH
39091: LD_EXP 107
39095: PPUSH
39096: LD_VAR 0 2
39100: PPUSH
39101: EMPTY
39102: PPUSH
39103: CALL_OW 1
39107: ST_TO_ADDR
// end ; continue ;
39108: GO 38676
// end ; for j in tmp do
39110: LD_ADDR_VAR 0 3
39114: PUSH
39115: LD_VAR 0 8
39119: PUSH
39120: FOR_IN
39121: IFFALSE 39457
// begin if not j in mc_taming [ i ] and mc_taming [ i ] < 3 then
39123: LD_VAR 0 3
39127: PUSH
39128: LD_EXP 107
39132: PUSH
39133: LD_VAR 0 2
39137: ARRAY
39138: IN
39139: NOT
39140: PUSH
39141: LD_EXP 107
39145: PUSH
39146: LD_VAR 0 2
39150: ARRAY
39151: PUSH
39152: LD_INT 3
39154: LESS
39155: AND
39156: IFFALSE 39214
// begin SetTag ( j , 121 ) ;
39158: LD_VAR 0 3
39162: PPUSH
39163: LD_INT 121
39165: PPUSH
39166: CALL_OW 109
// mc_taming := ReplaceIn ( mc_taming , [ i , mc_taming [ i ] + 1 ] , j ) ;
39170: LD_ADDR_EXP 107
39174: PUSH
39175: LD_EXP 107
39179: PPUSH
39180: LD_VAR 0 2
39184: PUSH
39185: LD_EXP 107
39189: PUSH
39190: LD_VAR 0 2
39194: ARRAY
39195: PUSH
39196: LD_INT 1
39198: PLUS
39199: PUSH
39200: EMPTY
39201: LIST
39202: LIST
39203: PPUSH
39204: LD_VAR 0 3
39208: PPUSH
39209: CALL 57743 0 3
39213: ST_TO_ADDR
// end ; if j in mc_taming [ i ] then
39214: LD_VAR 0 3
39218: PUSH
39219: LD_EXP 107
39223: PUSH
39224: LD_VAR 0 2
39228: ARRAY
39229: IN
39230: IFFALSE 39455
// begin if GetClass ( j ) <> 4 then
39232: LD_VAR 0 3
39236: PPUSH
39237: CALL_OW 257
39241: PUSH
39242: LD_INT 4
39244: NONEQUAL
39245: IFFALSE 39298
// begin mc_taming := Replace ( mc_taming , i , mc_taming [ i ] diff j ) ;
39247: LD_ADDR_EXP 107
39251: PUSH
39252: LD_EXP 107
39256: PPUSH
39257: LD_VAR 0 2
39261: PPUSH
39262: LD_EXP 107
39266: PUSH
39267: LD_VAR 0 2
39271: ARRAY
39272: PUSH
39273: LD_VAR 0 3
39277: DIFF
39278: PPUSH
39279: CALL_OW 1
39283: ST_TO_ADDR
// SetTag ( j , 0 ) ;
39284: LD_VAR 0 3
39288: PPUSH
39289: LD_INT 0
39291: PPUSH
39292: CALL_OW 109
// continue ;
39296: GO 39120
// end ; if IsInUnit ( j ) then
39298: LD_VAR 0 3
39302: PPUSH
39303: CALL_OW 310
39307: IFFALSE 39318
// ComExitBuilding ( j ) ;
39309: LD_VAR 0 3
39313: PPUSH
39314: CALL_OW 122
// ape := NearestUnitToUnit ( apes , j ) ;
39318: LD_ADDR_VAR 0 6
39322: PUSH
39323: LD_VAR 0 7
39327: PPUSH
39328: LD_VAR 0 3
39332: PPUSH
39333: CALL_OW 74
39337: ST_TO_ADDR
// if not ape then
39338: LD_VAR 0 6
39342: NOT
39343: IFFALSE 39347
// break ;
39345: GO 39457
// x := GetX ( ape ) ;
39347: LD_ADDR_VAR 0 4
39351: PUSH
39352: LD_VAR 0 6
39356: PPUSH
39357: CALL_OW 250
39361: ST_TO_ADDR
// y := GetY ( ape ) ;
39362: LD_ADDR_VAR 0 5
39366: PUSH
39367: LD_VAR 0 6
39371: PPUSH
39372: CALL_OW 251
39376: ST_TO_ADDR
// if not ValidHex ( x , y ) or DangerAtRangeXY ( side , x , y , 20 ) [ 4 ] then
39377: LD_VAR 0 4
39381: PPUSH
39382: LD_VAR 0 5
39386: PPUSH
39387: CALL_OW 488
39391: NOT
39392: PUSH
39393: LD_VAR 0 11
39397: PPUSH
39398: LD_VAR 0 4
39402: PPUSH
39403: LD_VAR 0 5
39407: PPUSH
39408: LD_INT 20
39410: PPUSH
39411: CALL 58639 0 4
39415: PUSH
39416: LD_INT 4
39418: ARRAY
39419: OR
39420: IFFALSE 39424
// break ;
39422: GO 39457
// if not HasTask ( j ) then
39424: LD_VAR 0 3
39428: PPUSH
39429: CALL_OW 314
39433: NOT
39434: IFFALSE 39455
// ComTameXY ( j , x , y ) ;
39436: LD_VAR 0 3
39440: PPUSH
39441: LD_VAR 0 4
39445: PPUSH
39446: LD_VAR 0 5
39450: PPUSH
39451: CALL_OW 131
// end ; end ;
39455: GO 39120
39457: POP
39458: POP
// end ;
39459: GO 38676
39461: POP
39462: POP
// end ;
39463: LD_VAR 0 1
39467: RET
// export function MC_ChangeApeClass ( ) ; var i , j , tmp , side , depot , selected , barracks ; begin
39468: LD_INT 0
39470: PPUSH
39471: PPUSH
39472: PPUSH
39473: PPUSH
39474: PPUSH
39475: PPUSH
39476: PPUSH
39477: PPUSH
// if not mc_bases then
39478: LD_EXP 76
39482: NOT
39483: IFFALSE 39487
// exit ;
39485: GO 40113
// for i = 1 to mc_bases do
39487: LD_ADDR_VAR 0 2
39491: PUSH
39492: DOUBLE
39493: LD_INT 1
39495: DEC
39496: ST_TO_ADDR
39497: LD_EXP 76
39501: PUSH
39502: FOR_TO
39503: IFFALSE 40111
// begin if not mc_ape [ i ] or not UnitFilter ( mc_ape [ i ] , [ f_class , 12 ] ) then
39505: LD_EXP 105
39509: PUSH
39510: LD_VAR 0 2
39514: ARRAY
39515: NOT
39516: PUSH
39517: LD_EXP 105
39521: PUSH
39522: LD_VAR 0 2
39526: ARRAY
39527: PPUSH
39528: LD_INT 25
39530: PUSH
39531: LD_INT 12
39533: PUSH
39534: EMPTY
39535: LIST
39536: LIST
39537: PPUSH
39538: CALL_OW 72
39542: NOT
39543: OR
39544: IFFALSE 39548
// continue ;
39546: GO 39502
// side := GetSide ( mc_ape [ i ] [ 1 ] ) ;
39548: LD_ADDR_VAR 0 5
39552: PUSH
39553: LD_EXP 105
39557: PUSH
39558: LD_VAR 0 2
39562: ARRAY
39563: PUSH
39564: LD_INT 1
39566: ARRAY
39567: PPUSH
39568: CALL_OW 255
39572: ST_TO_ADDR
// if Researched ( side , tech_apepsych ) then
39573: LD_VAR 0 5
39577: PPUSH
39578: LD_INT 2
39580: PPUSH
39581: CALL_OW 325
39585: IFFALSE 39838
// begin tmp := UnitFilter ( mc_ape [ i ] , [ f_class , 16 ] ) ;
39587: LD_ADDR_VAR 0 4
39591: PUSH
39592: LD_EXP 105
39596: PUSH
39597: LD_VAR 0 2
39601: ARRAY
39602: PPUSH
39603: LD_INT 25
39605: PUSH
39606: LD_INT 16
39608: PUSH
39609: EMPTY
39610: LIST
39611: LIST
39612: PPUSH
39613: CALL_OW 72
39617: ST_TO_ADDR
// if tmp < 6 then
39618: LD_VAR 0 4
39622: PUSH
39623: LD_INT 6
39625: LESS
39626: IFFALSE 39838
// begin depot := UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) ;
39628: LD_ADDR_VAR 0 6
39632: PUSH
39633: LD_EXP 76
39637: PUSH
39638: LD_VAR 0 2
39642: ARRAY
39643: PPUSH
39644: LD_INT 2
39646: PUSH
39647: LD_INT 30
39649: PUSH
39650: LD_INT 0
39652: PUSH
39653: EMPTY
39654: LIST
39655: LIST
39656: PUSH
39657: LD_INT 30
39659: PUSH
39660: LD_INT 1
39662: PUSH
39663: EMPTY
39664: LIST
39665: LIST
39666: PUSH
39667: EMPTY
39668: LIST
39669: LIST
39670: LIST
39671: PPUSH
39672: CALL_OW 72
39676: ST_TO_ADDR
// if depot then
39677: LD_VAR 0 6
39681: IFFALSE 39838
// begin selected := 0 ;
39683: LD_ADDR_VAR 0 7
39687: PUSH
39688: LD_INT 0
39690: ST_TO_ADDR
// for j in depot do
39691: LD_ADDR_VAR 0 3
39695: PUSH
39696: LD_VAR 0 6
39700: PUSH
39701: FOR_IN
39702: IFFALSE 39733
// begin if UnitsInside ( j ) < 6 then
39704: LD_VAR 0 3
39708: PPUSH
39709: CALL_OW 313
39713: PUSH
39714: LD_INT 6
39716: LESS
39717: IFFALSE 39731
// begin selected := j ;
39719: LD_ADDR_VAR 0 7
39723: PUSH
39724: LD_VAR 0 3
39728: ST_TO_ADDR
// break ;
39729: GO 39733
// end ; end ;
39731: GO 39701
39733: POP
39734: POP
// if selected then
39735: LD_VAR 0 7
39739: IFFALSE 39838
// begin for j in UnitFilter ( mc_ape [ i ] , [ f_class , 12 ] ) do
39741: LD_ADDR_VAR 0 3
39745: PUSH
39746: LD_EXP 105
39750: PUSH
39751: LD_VAR 0 2
39755: ARRAY
39756: PPUSH
39757: LD_INT 25
39759: PUSH
39760: LD_INT 12
39762: PUSH
39763: EMPTY
39764: LIST
39765: LIST
39766: PPUSH
39767: CALL_OW 72
39771: PUSH
39772: FOR_IN
39773: IFFALSE 39836
// if not HasTask ( j ) then
39775: LD_VAR 0 3
39779: PPUSH
39780: CALL_OW 314
39784: NOT
39785: IFFALSE 39834
// begin if not IsInUnit ( j ) then
39787: LD_VAR 0 3
39791: PPUSH
39792: CALL_OW 310
39796: NOT
39797: IFFALSE 39813
// ComEnterUnit ( j , selected ) ;
39799: LD_VAR 0 3
39803: PPUSH
39804: LD_VAR 0 7
39808: PPUSH
39809: CALL_OW 120
// AddComChangeProfession ( j , 16 ) ;
39813: LD_VAR 0 3
39817: PPUSH
39818: LD_INT 16
39820: PPUSH
39821: CALL_OW 183
// AddComExitBuilding ( j ) ;
39825: LD_VAR 0 3
39829: PPUSH
39830: CALL_OW 182
// end ;
39834: GO 39772
39836: POP
39837: POP
// end ; end ; end ; end ; if Researched ( side , tech_apeagres ) then
39838: LD_VAR 0 5
39842: PPUSH
39843: LD_INT 11
39845: PPUSH
39846: CALL_OW 325
39850: IFFALSE 40109
// begin tmp := UnitFilter ( mc_ape [ i ] , [ f_class , 16 ] ) ;
39852: LD_ADDR_VAR 0 4
39856: PUSH
39857: LD_EXP 105
39861: PUSH
39862: LD_VAR 0 2
39866: ARRAY
39867: PPUSH
39868: LD_INT 25
39870: PUSH
39871: LD_INT 16
39873: PUSH
39874: EMPTY
39875: LIST
39876: LIST
39877: PPUSH
39878: CALL_OW 72
39882: ST_TO_ADDR
// if tmp >= 6 or not Researched ( side , tech_apepsych ) then
39883: LD_VAR 0 4
39887: PUSH
39888: LD_INT 6
39890: GREATEREQUAL
39891: PUSH
39892: LD_VAR 0 5
39896: PPUSH
39897: LD_INT 2
39899: PPUSH
39900: CALL_OW 325
39904: NOT
39905: OR
39906: IFFALSE 40109
// begin barracks := UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_armoury ] , [ f_btype , b_barracks ] ] ) ;
39908: LD_ADDR_VAR 0 8
39912: PUSH
39913: LD_EXP 76
39917: PUSH
39918: LD_VAR 0 2
39922: ARRAY
39923: PPUSH
39924: LD_INT 2
39926: PUSH
39927: LD_INT 30
39929: PUSH
39930: LD_INT 4
39932: PUSH
39933: EMPTY
39934: LIST
39935: LIST
39936: PUSH
39937: LD_INT 30
39939: PUSH
39940: LD_INT 5
39942: PUSH
39943: EMPTY
39944: LIST
39945: LIST
39946: PUSH
39947: EMPTY
39948: LIST
39949: LIST
39950: LIST
39951: PPUSH
39952: CALL_OW 72
39956: ST_TO_ADDR
// if barracks then
39957: LD_VAR 0 8
39961: IFFALSE 40109
// begin selected := 0 ;
39963: LD_ADDR_VAR 0 7
39967: PUSH
39968: LD_INT 0
39970: ST_TO_ADDR
// for j in barracks do
39971: LD_ADDR_VAR 0 3
39975: PUSH
39976: LD_VAR 0 8
39980: PUSH
39981: FOR_IN
39982: IFFALSE 40013
// begin if UnitsInside ( j ) < 6 then
39984: LD_VAR 0 3
39988: PPUSH
39989: CALL_OW 313
39993: PUSH
39994: LD_INT 6
39996: LESS
39997: IFFALSE 40011
// begin selected := j ;
39999: LD_ADDR_VAR 0 7
40003: PUSH
40004: LD_VAR 0 3
40008: ST_TO_ADDR
// break ;
40009: GO 40013
// end ; end ;
40011: GO 39981
40013: POP
40014: POP
// if selected then
40015: LD_VAR 0 7
40019: IFFALSE 40109
// begin for j in UnitFilter ( mc_ape [ i ] , [ f_class , 12 ] ) do
40021: LD_ADDR_VAR 0 3
40025: PUSH
40026: LD_EXP 105
40030: PUSH
40031: LD_VAR 0 2
40035: ARRAY
40036: PPUSH
40037: LD_INT 25
40039: PUSH
40040: LD_INT 12
40042: PUSH
40043: EMPTY
40044: LIST
40045: LIST
40046: PPUSH
40047: CALL_OW 72
40051: PUSH
40052: FOR_IN
40053: IFFALSE 40107
// if not IsInUnit ( j ) and not HasTask ( j ) then
40055: LD_VAR 0 3
40059: PPUSH
40060: CALL_OW 310
40064: NOT
40065: PUSH
40066: LD_VAR 0 3
40070: PPUSH
40071: CALL_OW 314
40075: NOT
40076: AND
40077: IFFALSE 40105
// begin ComEnterUnit ( j , selected ) ;
40079: LD_VAR 0 3
40083: PPUSH
40084: LD_VAR 0 7
40088: PPUSH
40089: CALL_OW 120
// AddComChangeProfession ( j , 15 ) ;
40093: LD_VAR 0 3
40097: PPUSH
40098: LD_INT 15
40100: PPUSH
40101: CALL_OW 183
// end ;
40105: GO 40052
40107: POP
40108: POP
// end ; end ; end ; end ; end ;
40109: GO 39502
40111: POP
40112: POP
// end ;
40113: LD_VAR 0 1
40117: RET
// export function MC_Bazooka ( ) ; var i , j , tmp ; begin
40118: LD_INT 0
40120: PPUSH
40121: PPUSH
40122: PPUSH
40123: PPUSH
// if not mc_bases then
40124: LD_EXP 76
40128: NOT
40129: IFFALSE 40133
// exit ;
40131: GO 40311
// for i = 1 to mc_bases do
40133: LD_ADDR_VAR 0 2
40137: PUSH
40138: DOUBLE
40139: LD_INT 1
40141: DEC
40142: ST_TO_ADDR
40143: LD_EXP 76
40147: PUSH
40148: FOR_TO
40149: IFFALSE 40309
// begin tmp := UnitFilter ( mc_bases [ i ] , [ f_class , class_bazooker ] ) ;
40151: LD_ADDR_VAR 0 4
40155: PUSH
40156: LD_EXP 76
40160: PUSH
40161: LD_VAR 0 2
40165: ARRAY
40166: PPUSH
40167: LD_INT 25
40169: PUSH
40170: LD_INT 9
40172: PUSH
40173: EMPTY
40174: LIST
40175: LIST
40176: PPUSH
40177: CALL_OW 72
40181: ST_TO_ADDR
// if not tmp then
40182: LD_VAR 0 4
40186: NOT
40187: IFFALSE 40191
// continue ;
40189: GO 40148
// if not Researched ( mc_sides [ i ] , tech_spacanom ) and not Researched ( mc_sides [ i ] , tech_taurad ) then
40191: LD_EXP 102
40195: PUSH
40196: LD_VAR 0 2
40200: ARRAY
40201: PPUSH
40202: LD_INT 29
40204: PPUSH
40205: CALL_OW 325
40209: NOT
40210: PUSH
40211: LD_EXP 102
40215: PUSH
40216: LD_VAR 0 2
40220: ARRAY
40221: PPUSH
40222: LD_INT 28
40224: PPUSH
40225: CALL_OW 325
40229: NOT
40230: AND
40231: IFFALSE 40235
// continue ;
40233: GO 40148
// for j in tmp do
40235: LD_ADDR_VAR 0 3
40239: PUSH
40240: LD_VAR 0 4
40244: PUSH
40245: FOR_IN
40246: IFFALSE 40305
// if not j in mc_need_heal [ i ] [ 1 ] and not j in mc_need_heal [ i ] [ 2 ] then
40248: LD_VAR 0 3
40252: PUSH
40253: LD_EXP 79
40257: PUSH
40258: LD_VAR 0 2
40262: ARRAY
40263: PUSH
40264: LD_INT 1
40266: ARRAY
40267: IN
40268: NOT
40269: PUSH
40270: LD_VAR 0 3
40274: PUSH
40275: LD_EXP 79
40279: PUSH
40280: LD_VAR 0 2
40284: ARRAY
40285: PUSH
40286: LD_INT 2
40288: ARRAY
40289: IN
40290: NOT
40291: AND
40292: IFFALSE 40303
// ComSpaceTimeShoot ( j ) ;
40294: LD_VAR 0 3
40298: PPUSH
40299: CALL 51329 0 1
40303: GO 40245
40305: POP
40306: POP
// end ;
40307: GO 40148
40309: POP
40310: POP
// end ;
40311: LD_VAR 0 1
40315: RET
// export function MC_TeleportExit ( ) ; var i , j , x , y , save_point , tmp , teleports , sci ; begin
40316: LD_INT 0
40318: PPUSH
40319: PPUSH
40320: PPUSH
40321: PPUSH
40322: PPUSH
40323: PPUSH
40324: PPUSH
40325: PPUSH
40326: PPUSH
// if not mc_bases then
40327: LD_EXP 76
40331: NOT
40332: IFFALSE 40336
// exit ;
40334: GO 40958
// for i = 1 to mc_bases do
40336: LD_ADDR_VAR 0 2
40340: PUSH
40341: DOUBLE
40342: LD_INT 1
40344: DEC
40345: ST_TO_ADDR
40346: LD_EXP 76
40350: PUSH
40351: FOR_TO
40352: IFFALSE 40956
// begin if not mc_teleport_exit [ i ] or GetTech ( tech_targTeleport , mc_sides [ i ] ) <> state_researched then
40354: LD_EXP 111
40358: PUSH
40359: LD_VAR 0 2
40363: ARRAY
40364: NOT
40365: PUSH
40366: LD_INT 38
40368: PPUSH
40369: LD_EXP 102
40373: PUSH
40374: LD_VAR 0 2
40378: ARRAY
40379: PPUSH
40380: CALL_OW 321
40384: PUSH
40385: LD_INT 2
40387: NONEQUAL
40388: OR
40389: IFFALSE 40393
// continue ;
40391: GO 40351
// teleports := UnitFilter ( mc_bases [ i ] , [ f_btype , b_teleport ] ) ;
40393: LD_ADDR_VAR 0 8
40397: PUSH
40398: LD_EXP 76
40402: PUSH
40403: LD_VAR 0 2
40407: ARRAY
40408: PPUSH
40409: LD_INT 30
40411: PUSH
40412: LD_INT 34
40414: PUSH
40415: EMPTY
40416: LIST
40417: LIST
40418: PPUSH
40419: CALL_OW 72
40423: ST_TO_ADDR
// sci := FilterByTag ( UnitFilter ( mc_bases [ i ] , [ f_class , 4 ] ) , 0 ) ;
40424: LD_ADDR_VAR 0 9
40428: PUSH
40429: LD_EXP 76
40433: PUSH
40434: LD_VAR 0 2
40438: ARRAY
40439: PPUSH
40440: LD_INT 25
40442: PUSH
40443: LD_INT 4
40445: PUSH
40446: EMPTY
40447: LIST
40448: LIST
40449: PPUSH
40450: CALL_OW 72
40454: PPUSH
40455: LD_INT 0
40457: PPUSH
40458: CALL 91006 0 2
40462: ST_TO_ADDR
// if not sci or not teleports or FilterByTag ( mc_bases [ i ] , 124 ) then
40463: LD_VAR 0 9
40467: NOT
40468: PUSH
40469: LD_VAR 0 8
40473: NOT
40474: OR
40475: PUSH
40476: LD_EXP 76
40480: PUSH
40481: LD_VAR 0 2
40485: ARRAY
40486: PPUSH
40487: LD_INT 124
40489: PPUSH
40490: CALL 91006 0 2
40494: OR
40495: IFFALSE 40499
// continue ;
40497: GO 40351
// if mc_teleport_exit_set [ i ] < mc_teleport_exit [ i ] and mc_teleport_exit_set [ i ] < teleports then
40499: LD_EXP 112
40503: PUSH
40504: LD_VAR 0 2
40508: ARRAY
40509: PUSH
40510: LD_EXP 111
40514: PUSH
40515: LD_VAR 0 2
40519: ARRAY
40520: LESS
40521: PUSH
40522: LD_EXP 112
40526: PUSH
40527: LD_VAR 0 2
40531: ARRAY
40532: PUSH
40533: LD_VAR 0 8
40537: LESS
40538: AND
40539: IFFALSE 40954
// begin tmp := sci [ 1 ] ;
40541: LD_ADDR_VAR 0 7
40545: PUSH
40546: LD_VAR 0 9
40550: PUSH
40551: LD_INT 1
40553: ARRAY
40554: ST_TO_ADDR
// SetTag ( tmp , 124 ) ;
40555: LD_VAR 0 7
40559: PPUSH
40560: LD_INT 124
40562: PPUSH
40563: CALL_OW 109
// for j = mc_teleport_exit [ i ] downto mc_teleport_exit [ i ] do
40567: LD_ADDR_VAR 0 3
40571: PUSH
40572: DOUBLE
40573: LD_EXP 111
40577: PUSH
40578: LD_VAR 0 2
40582: ARRAY
40583: INC
40584: ST_TO_ADDR
40585: LD_EXP 111
40589: PUSH
40590: LD_VAR 0 2
40594: ARRAY
40595: PUSH
40596: FOR_DOWNTO
40597: IFFALSE 40940
// begin if IsInUnit ( tmp ) then
40599: LD_VAR 0 7
40603: PPUSH
40604: CALL_OW 310
40608: IFFALSE 40619
// ComExitBuilding ( tmp ) ;
40610: LD_VAR 0 7
40614: PPUSH
40615: CALL_OW 122
// repeat wait ( 0 0$1 ) ;
40619: LD_INT 35
40621: PPUSH
40622: CALL_OW 67
// until not IsInUnit ( tmp ) and not HasTask ( tmp ) ;
40626: LD_VAR 0 7
40630: PPUSH
40631: CALL_OW 310
40635: NOT
40636: PUSH
40637: LD_VAR 0 7
40641: PPUSH
40642: CALL_OW 314
40646: NOT
40647: AND
40648: IFFALSE 40619
// save_point := [ GetX ( tmp ) , GetY ( tmp ) ] ;
40650: LD_ADDR_VAR 0 6
40654: PUSH
40655: LD_VAR 0 7
40659: PPUSH
40660: CALL_OW 250
40664: PUSH
40665: LD_VAR 0 7
40669: PPUSH
40670: CALL_OW 251
40674: PUSH
40675: EMPTY
40676: LIST
40677: LIST
40678: ST_TO_ADDR
// repeat wait ( 0 0$1 ) ;
40679: LD_INT 35
40681: PPUSH
40682: CALL_OW 67
// x := mc_teleport_exit [ i ] [ j ] [ 1 ] ;
40686: LD_ADDR_VAR 0 4
40690: PUSH
40691: LD_EXP 111
40695: PUSH
40696: LD_VAR 0 2
40700: ARRAY
40701: PUSH
40702: LD_VAR 0 3
40706: ARRAY
40707: PUSH
40708: LD_INT 1
40710: ARRAY
40711: ST_TO_ADDR
// y := mc_teleport_exit [ i ] [ j ] [ 2 ] ;
40712: LD_ADDR_VAR 0 5
40716: PUSH
40717: LD_EXP 111
40721: PUSH
40722: LD_VAR 0 2
40726: ARRAY
40727: PUSH
40728: LD_VAR 0 3
40732: ARRAY
40733: PUSH
40734: LD_INT 2
40736: ARRAY
40737: ST_TO_ADDR
// if DangerAtRange ( tmp , 10 ) [ 4 ] then
40738: LD_VAR 0 7
40742: PPUSH
40743: LD_INT 10
40745: PPUSH
40746: CALL 60336 0 2
40750: PUSH
40751: LD_INT 4
40753: ARRAY
40754: IFFALSE 40792
// begin ComMoveXY ( tmp , save_point [ 1 ] , save_point [ 2 ] ) ;
40756: LD_VAR 0 7
40760: PPUSH
40761: LD_VAR 0 6
40765: PUSH
40766: LD_INT 1
40768: ARRAY
40769: PPUSH
40770: LD_VAR 0 6
40774: PUSH
40775: LD_INT 2
40777: ARRAY
40778: PPUSH
40779: CALL_OW 111
// wait ( 0 0$10 ) ;
40783: LD_INT 350
40785: PPUSH
40786: CALL_OW 67
// end else
40790: GO 40818
// begin ComMoveXY ( tmp , x , y ) ;
40792: LD_VAR 0 7
40796: PPUSH
40797: LD_VAR 0 4
40801: PPUSH
40802: LD_VAR 0 5
40806: PPUSH
40807: CALL_OW 111
// wait ( 0 0$3 ) ;
40811: LD_INT 105
40813: PPUSH
40814: CALL_OW 67
// end ; until IsAt ( tmp , x , y ) ;
40818: LD_VAR 0 7
40822: PPUSH
40823: LD_VAR 0 4
40827: PPUSH
40828: LD_VAR 0 5
40832: PPUSH
40833: CALL_OW 307
40837: IFFALSE 40679
// ComTeleportExit ( tmp , x , y , teleports [ j ] ) ;
40839: LD_VAR 0 7
40843: PPUSH
40844: LD_VAR 0 4
40848: PPUSH
40849: LD_VAR 0 5
40853: PPUSH
40854: LD_VAR 0 8
40858: PUSH
40859: LD_VAR 0 3
40863: ARRAY
40864: PPUSH
40865: CALL_OW 156
// repeat wait ( 0 0$1 ) ;
40869: LD_INT 35
40871: PPUSH
40872: CALL_OW 67
// until not HasTask ( tmp ) ;
40876: LD_VAR 0 7
40880: PPUSH
40881: CALL_OW 314
40885: NOT
40886: IFFALSE 40869
// mc_teleport_exit_set := ReplaceIn ( mc_teleport_exit_set , [ i , mc_teleport_exit_set [ i ] + 1 ] , teleports [ j ] ) ;
40888: LD_ADDR_EXP 112
40892: PUSH
40893: LD_EXP 112
40897: PPUSH
40898: LD_VAR 0 2
40902: PUSH
40903: LD_EXP 112
40907: PUSH
40908: LD_VAR 0 2
40912: ARRAY
40913: PUSH
40914: LD_INT 1
40916: PLUS
40917: PUSH
40918: EMPTY
40919: LIST
40920: LIST
40921: PPUSH
40922: LD_VAR 0 8
40926: PUSH
40927: LD_VAR 0 3
40931: ARRAY
40932: PPUSH
40933: CALL 57743 0 3
40937: ST_TO_ADDR
// end ;
40938: GO 40596
40940: POP
40941: POP
// MC_Reset ( i , 124 ) ;
40942: LD_VAR 0 2
40946: PPUSH
40947: LD_INT 124
40949: PPUSH
40950: CALL 24545 0 2
// end ; end ;
40954: GO 40351
40956: POP
40957: POP
// end ;
40958: LD_VAR 0 1
40962: RET
// export function MC_Deposits ( ) ; var i , tmp ; begin
40963: LD_INT 0
40965: PPUSH
40966: PPUSH
40967: PPUSH
// if not mc_bases then
40968: LD_EXP 76
40972: NOT
40973: IFFALSE 40977
// exit ;
40975: GO 41583
// for i = 1 to mc_bases do
40977: LD_ADDR_VAR 0 2
40981: PUSH
40982: DOUBLE
40983: LD_INT 1
40985: DEC
40986: ST_TO_ADDR
40987: LD_EXP 76
40991: PUSH
40992: FOR_TO
40993: IFFALSE 41581
// begin tmp := UnitFilter ( mc_bases [ i ] , [ f_class , 4 ] ) ;
40995: LD_ADDR_VAR 0 3
40999: PUSH
41000: LD_EXP 76
41004: PUSH
41005: LD_VAR 0 2
41009: ARRAY
41010: PPUSH
41011: LD_INT 25
41013: PUSH
41014: LD_INT 4
41016: PUSH
41017: EMPTY
41018: LIST
41019: LIST
41020: PPUSH
41021: CALL_OW 72
41025: ST_TO_ADDR
// if not tmp or not mc_deposits_xy [ i ] or not UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) then
41026: LD_VAR 0 3
41030: NOT
41031: PUSH
41032: LD_EXP 113
41036: PUSH
41037: LD_VAR 0 2
41041: ARRAY
41042: NOT
41043: OR
41044: PUSH
41045: LD_EXP 76
41049: PUSH
41050: LD_VAR 0 2
41054: ARRAY
41055: PPUSH
41056: LD_INT 2
41058: PUSH
41059: LD_INT 30
41061: PUSH
41062: LD_INT 0
41064: PUSH
41065: EMPTY
41066: LIST
41067: LIST
41068: PUSH
41069: LD_INT 30
41071: PUSH
41072: LD_INT 1
41074: PUSH
41075: EMPTY
41076: LIST
41077: LIST
41078: PUSH
41079: EMPTY
41080: LIST
41081: LIST
41082: LIST
41083: PPUSH
41084: CALL_OW 72
41088: NOT
41089: OR
41090: IFFALSE 41140
// begin if mc_deposits_finder [ i ] then
41092: LD_EXP 114
41096: PUSH
41097: LD_VAR 0 2
41101: ARRAY
41102: IFFALSE 41138
// begin MC_Reset ( i , 125 ) ;
41104: LD_VAR 0 2
41108: PPUSH
41109: LD_INT 125
41111: PPUSH
41112: CALL 24545 0 2
// mc_deposits_finder := Replace ( mc_deposits_finder , i , [ ] ) ;
41116: LD_ADDR_EXP 114
41120: PUSH
41121: LD_EXP 114
41125: PPUSH
41126: LD_VAR 0 2
41130: PPUSH
41131: EMPTY
41132: PPUSH
41133: CALL_OW 1
41137: ST_TO_ADDR
// end ; continue ;
41138: GO 40992
// end ; if mc_deposits_xy [ i ] [ 1 ] [ 3 ] = 1 and GetTech ( tech_sibdet , mc_sides [ i ] ) <> state_researched then
41140: LD_EXP 113
41144: PUSH
41145: LD_VAR 0 2
41149: ARRAY
41150: PUSH
41151: LD_INT 1
41153: ARRAY
41154: PUSH
41155: LD_INT 3
41157: ARRAY
41158: PUSH
41159: LD_INT 1
41161: EQUAL
41162: PUSH
41163: LD_INT 20
41165: PPUSH
41166: LD_EXP 102
41170: PUSH
41171: LD_VAR 0 2
41175: ARRAY
41176: PPUSH
41177: CALL_OW 321
41181: PUSH
41182: LD_INT 2
41184: NONEQUAL
41185: AND
41186: IFFALSE 41236
// begin if mc_deposits_finder [ i ] then
41188: LD_EXP 114
41192: PUSH
41193: LD_VAR 0 2
41197: ARRAY
41198: IFFALSE 41234
// begin MC_Reset ( i , 125 ) ;
41200: LD_VAR 0 2
41204: PPUSH
41205: LD_INT 125
41207: PPUSH
41208: CALL 24545 0 2
// mc_deposits_finder := Replace ( mc_deposits_finder , i , [ ] ) ;
41212: LD_ADDR_EXP 114
41216: PUSH
41217: LD_EXP 114
41221: PPUSH
41222: LD_VAR 0 2
41226: PPUSH
41227: EMPTY
41228: PPUSH
41229: CALL_OW 1
41233: ST_TO_ADDR
// end ; continue ;
41234: GO 40992
// end ; if GetResourceVisibility ( mc_deposits_xy [ i ] [ 1 ] [ 1 ] , mc_deposits_xy [ i ] [ 1 ] [ 2 ] , mc_sides [ i ] ) then
41236: LD_EXP 113
41240: PUSH
41241: LD_VAR 0 2
41245: ARRAY
41246: PUSH
41247: LD_INT 1
41249: ARRAY
41250: PUSH
41251: LD_INT 1
41253: ARRAY
41254: PPUSH
41255: LD_EXP 113
41259: PUSH
41260: LD_VAR 0 2
41264: ARRAY
41265: PUSH
41266: LD_INT 1
41268: ARRAY
41269: PUSH
41270: LD_INT 2
41272: ARRAY
41273: PPUSH
41274: LD_EXP 102
41278: PUSH
41279: LD_VAR 0 2
41283: ARRAY
41284: PPUSH
41285: CALL_OW 440
41289: IFFALSE 41332
// mc_deposits_xy := Replace ( mc_deposits_xy , i , Delete ( mc_deposits_xy [ i ] , 1 ) ) else
41291: LD_ADDR_EXP 113
41295: PUSH
41296: LD_EXP 113
41300: PPUSH
41301: LD_VAR 0 2
41305: PPUSH
41306: LD_EXP 113
41310: PUSH
41311: LD_VAR 0 2
41315: ARRAY
41316: PPUSH
41317: LD_INT 1
41319: PPUSH
41320: CALL_OW 3
41324: PPUSH
41325: CALL_OW 1
41329: ST_TO_ADDR
41330: GO 41579
// begin if not mc_deposits_finder [ i ] then
41332: LD_EXP 114
41336: PUSH
41337: LD_VAR 0 2
41341: ARRAY
41342: NOT
41343: IFFALSE 41395
// begin mc_deposits_finder := Replace ( mc_deposits_finder , i , [ tmp [ 1 ] ] ) ;
41345: LD_ADDR_EXP 114
41349: PUSH
41350: LD_EXP 114
41354: PPUSH
41355: LD_VAR 0 2
41359: PPUSH
41360: LD_VAR 0 3
41364: PUSH
41365: LD_INT 1
41367: ARRAY
41368: PUSH
41369: EMPTY
41370: LIST
41371: PPUSH
41372: CALL_OW 1
41376: ST_TO_ADDR
// SetTag ( tmp [ 1 ] , 125 ) ;
41377: LD_VAR 0 3
41381: PUSH
41382: LD_INT 1
41384: ARRAY
41385: PPUSH
41386: LD_INT 125
41388: PPUSH
41389: CALL_OW 109
// end else
41393: GO 41579
// begin if IsInUnit ( mc_deposits_finder [ i ] [ 1 ] ) then
41395: LD_EXP 114
41399: PUSH
41400: LD_VAR 0 2
41404: ARRAY
41405: PUSH
41406: LD_INT 1
41408: ARRAY
41409: PPUSH
41410: CALL_OW 310
41414: IFFALSE 41437
// ComExitBuilding ( mc_deposits_finder [ i ] [ 1 ] ) else
41416: LD_EXP 114
41420: PUSH
41421: LD_VAR 0 2
41425: ARRAY
41426: PUSH
41427: LD_INT 1
41429: ARRAY
41430: PPUSH
41431: CALL_OW 122
41435: GO 41579
// if not HasTask ( mc_deposits_finder [ i ] [ 1 ] ) and GetDistUnitXY ( mc_deposits_finder [ i ] [ 1 ] , mc_deposits_xy [ i ] [ 1 ] [ 1 ] , mc_deposits_xy [ i ] [ 1 ] [ 2 ] ) > 6 then
41437: LD_EXP 114
41441: PUSH
41442: LD_VAR 0 2
41446: ARRAY
41447: PUSH
41448: LD_INT 1
41450: ARRAY
41451: PPUSH
41452: CALL_OW 314
41456: NOT
41457: PUSH
41458: LD_EXP 114
41462: PUSH
41463: LD_VAR 0 2
41467: ARRAY
41468: PUSH
41469: LD_INT 1
41471: ARRAY
41472: PPUSH
41473: LD_EXP 113
41477: PUSH
41478: LD_VAR 0 2
41482: ARRAY
41483: PUSH
41484: LD_INT 1
41486: ARRAY
41487: PUSH
41488: LD_INT 1
41490: ARRAY
41491: PPUSH
41492: LD_EXP 113
41496: PUSH
41497: LD_VAR 0 2
41501: ARRAY
41502: PUSH
41503: LD_INT 1
41505: ARRAY
41506: PUSH
41507: LD_INT 2
41509: ARRAY
41510: PPUSH
41511: CALL_OW 297
41515: PUSH
41516: LD_INT 6
41518: GREATER
41519: AND
41520: IFFALSE 41579
// ComMoveXY ( mc_deposits_finder [ i ] [ 1 ] , mc_deposits_xy [ i ] [ 1 ] [ 1 ] , mc_deposits_xy [ i ] [ 1 ] [ 2 ] ) ;
41522: LD_EXP 114
41526: PUSH
41527: LD_VAR 0 2
41531: ARRAY
41532: PUSH
41533: LD_INT 1
41535: ARRAY
41536: PPUSH
41537: LD_EXP 113
41541: PUSH
41542: LD_VAR 0 2
41546: ARRAY
41547: PUSH
41548: LD_INT 1
41550: ARRAY
41551: PUSH
41552: LD_INT 1
41554: ARRAY
41555: PPUSH
41556: LD_EXP 113
41560: PUSH
41561: LD_VAR 0 2
41565: ARRAY
41566: PUSH
41567: LD_INT 1
41569: ARRAY
41570: PUSH
41571: LD_INT 2
41573: ARRAY
41574: PPUSH
41575: CALL_OW 111
// end ; end ; end ;
41579: GO 40992
41581: POP
41582: POP
// end ;
41583: LD_VAR 0 1
41587: RET
// export function MC_RemoteDriver ( ) ; var i , j , k , places , tmp , nation , ct , cts , mcts , x ; begin
41588: LD_INT 0
41590: PPUSH
41591: PPUSH
41592: PPUSH
41593: PPUSH
41594: PPUSH
41595: PPUSH
41596: PPUSH
41597: PPUSH
41598: PPUSH
41599: PPUSH
41600: PPUSH
// if not mc_bases then
41601: LD_EXP 76
41605: NOT
41606: IFFALSE 41610
// exit ;
41608: GO 42550
// for i = 1 to mc_bases do
41610: LD_ADDR_VAR 0 2
41614: PUSH
41615: DOUBLE
41616: LD_INT 1
41618: DEC
41619: ST_TO_ADDR
41620: LD_EXP 76
41624: PUSH
41625: FOR_TO
41626: IFFALSE 42548
// begin if not mc_bases [ i ] or mc_scan [ i ] then
41628: LD_EXP 76
41632: PUSH
41633: LD_VAR 0 2
41637: ARRAY
41638: NOT
41639: PUSH
41640: LD_EXP 99
41644: PUSH
41645: LD_VAR 0 2
41649: ARRAY
41650: OR
41651: IFFALSE 41655
// continue ;
41653: GO 41625
// nation := GetNation ( mc_bases [ i ] [ 1 ] ) ;
41655: LD_ADDR_VAR 0 7
41659: PUSH
41660: LD_EXP 76
41664: PUSH
41665: LD_VAR 0 2
41669: ARRAY
41670: PUSH
41671: LD_INT 1
41673: ARRAY
41674: PPUSH
41675: CALL_OW 248
41679: ST_TO_ADDR
// if nation = 3 or not UnitFilter ( mc_vehicles [ i ] union mc_defender [ i ] , [ f_control , control_remote ] ) then
41680: LD_VAR 0 7
41684: PUSH
41685: LD_INT 3
41687: EQUAL
41688: PUSH
41689: LD_EXP 95
41693: PUSH
41694: LD_VAR 0 2
41698: ARRAY
41699: PUSH
41700: LD_EXP 98
41704: PUSH
41705: LD_VAR 0 2
41709: ARRAY
41710: UNION
41711: PPUSH
41712: LD_INT 33
41714: PUSH
41715: LD_INT 2
41717: PUSH
41718: EMPTY
41719: LIST
41720: LIST
41721: PPUSH
41722: CALL_OW 72
41726: NOT
41727: OR
41728: IFFALSE 41732
// continue ;
41730: GO 41625
// cts := UnitFilter ( mc_bases [ i ] , [ f_btype , b_control_tower ] ) ;
41732: LD_ADDR_VAR 0 9
41736: PUSH
41737: LD_EXP 76
41741: PUSH
41742: LD_VAR 0 2
41746: ARRAY
41747: PPUSH
41748: LD_INT 30
41750: PUSH
41751: LD_INT 36
41753: PUSH
41754: EMPTY
41755: LIST
41756: LIST
41757: PPUSH
41758: CALL_OW 72
41762: ST_TO_ADDR
// mcts := UnitFilter ( mc_vehicles [ i ] , [ f_weapon , ar_control_tower ] ) ;
41763: LD_ADDR_VAR 0 10
41767: PUSH
41768: LD_EXP 95
41772: PUSH
41773: LD_VAR 0 2
41777: ARRAY
41778: PPUSH
41779: LD_INT 34
41781: PUSH
41782: LD_INT 31
41784: PUSH
41785: EMPTY
41786: LIST
41787: LIST
41788: PPUSH
41789: CALL_OW 72
41793: ST_TO_ADDR
// if not cts and not mcts then
41794: LD_VAR 0 9
41798: NOT
41799: PUSH
41800: LD_VAR 0 10
41804: NOT
41805: AND
41806: IFFALSE 41810
// continue ;
41808: GO 41625
// x := cts ;
41810: LD_ADDR_VAR 0 11
41814: PUSH
41815: LD_VAR 0 9
41819: ST_TO_ADDR
// if not x then
41820: LD_VAR 0 11
41824: NOT
41825: IFFALSE 41837
// x := mcts ;
41827: LD_ADDR_VAR 0 11
41831: PUSH
41832: LD_VAR 0 10
41836: ST_TO_ADDR
// if not x then
41837: LD_VAR 0 11
41841: NOT
41842: IFFALSE 41846
// continue ;
41844: GO 41625
// if mc_remote_driver [ i ] then
41846: LD_EXP 116
41850: PUSH
41851: LD_VAR 0 2
41855: ARRAY
41856: IFFALSE 42243
// for j in mc_remote_driver [ i ] do
41858: LD_ADDR_VAR 0 3
41862: PUSH
41863: LD_EXP 116
41867: PUSH
41868: LD_VAR 0 2
41872: ARRAY
41873: PUSH
41874: FOR_IN
41875: IFFALSE 42241
// begin if GetClass ( j ) <> 3 then
41877: LD_VAR 0 3
41881: PPUSH
41882: CALL_OW 257
41886: PUSH
41887: LD_INT 3
41889: NONEQUAL
41890: IFFALSE 41943
// begin mc_remote_driver := Replace ( mc_remote_driver , i , mc_remote_driver [ i ] diff j ) ;
41892: LD_ADDR_EXP 116
41896: PUSH
41897: LD_EXP 116
41901: PPUSH
41902: LD_VAR 0 2
41906: PPUSH
41907: LD_EXP 116
41911: PUSH
41912: LD_VAR 0 2
41916: ARRAY
41917: PUSH
41918: LD_VAR 0 3
41922: DIFF
41923: PPUSH
41924: CALL_OW 1
41928: ST_TO_ADDR
// SetTag ( j , 0 ) ;
41929: LD_VAR 0 3
41933: PPUSH
41934: LD_INT 0
41936: PPUSH
41937: CALL_OW 109
// continue ;
41941: GO 41874
// end ; if UnitFilter ( mc_vehicles [ i ] , [ [ f_weapon , ar_control_tower ] , [ f_empty ] ] ) and not IsDriver ( j ) then
41943: LD_EXP 95
41947: PUSH
41948: LD_VAR 0 2
41952: ARRAY
41953: PPUSH
41954: LD_INT 34
41956: PUSH
41957: LD_INT 31
41959: PUSH
41960: EMPTY
41961: LIST
41962: LIST
41963: PUSH
41964: LD_INT 58
41966: PUSH
41967: EMPTY
41968: LIST
41969: PUSH
41970: EMPTY
41971: LIST
41972: LIST
41973: PPUSH
41974: CALL_OW 72
41978: PUSH
41979: LD_VAR 0 3
41983: PPUSH
41984: CALL 91094 0 1
41988: NOT
41989: AND
41990: IFFALSE 42061
// begin if IsInUnit ( j ) then
41992: LD_VAR 0 3
41996: PPUSH
41997: CALL_OW 310
42001: IFFALSE 42012
// ComExitBuilding ( j ) ;
42003: LD_VAR 0 3
42007: PPUSH
42008: CALL_OW 122
// AddComEnterUnit ( j , UnitFilter ( mc_vehicles [ i ] , [ [ f_weapon , ar_control_tower ] , [ f_empty ] ] ) [ 1 ] ) ;
42012: LD_VAR 0 3
42016: PPUSH
42017: LD_EXP 95
42021: PUSH
42022: LD_VAR 0 2
42026: ARRAY
42027: PPUSH
42028: LD_INT 34
42030: PUSH
42031: LD_INT 31
42033: PUSH
42034: EMPTY
42035: LIST
42036: LIST
42037: PUSH
42038: LD_INT 58
42040: PUSH
42041: EMPTY
42042: LIST
42043: PUSH
42044: EMPTY
42045: LIST
42046: LIST
42047: PPUSH
42048: CALL_OW 72
42052: PUSH
42053: LD_INT 1
42055: ARRAY
42056: PPUSH
42057: CALL_OW 180
// end ; if not IsInUnit ( j ) or ( GetBType ( IsInUnit ( j ) ) <> b_control_tower and not IsDriver ( j ) ) then
42061: LD_VAR 0 3
42065: PPUSH
42066: CALL_OW 310
42070: NOT
42071: PUSH
42072: LD_VAR 0 3
42076: PPUSH
42077: CALL_OW 310
42081: PPUSH
42082: CALL_OW 266
42086: PUSH
42087: LD_INT 36
42089: NONEQUAL
42090: PUSH
42091: LD_VAR 0 3
42095: PPUSH
42096: CALL 91094 0 1
42100: NOT
42101: AND
42102: OR
42103: IFFALSE 42239
// begin if IsInUnit ( j ) then
42105: LD_VAR 0 3
42109: PPUSH
42110: CALL_OW 310
42114: IFFALSE 42125
// ComExitBuilding ( j ) ;
42116: LD_VAR 0 3
42120: PPUSH
42121: CALL_OW 122
// ct := 0 ;
42125: LD_ADDR_VAR 0 8
42129: PUSH
42130: LD_INT 0
42132: ST_TO_ADDR
// for k in x do
42133: LD_ADDR_VAR 0 4
42137: PUSH
42138: LD_VAR 0 11
42142: PUSH
42143: FOR_IN
42144: IFFALSE 42217
// if ( GetWeapon ( k ) = ar_control_tower and not IsDrivenBy ( k ) ) or ( GetBType ( k ) = b_control_tower and UnitsInside ( k ) < 3 ) then
42146: LD_VAR 0 4
42150: PPUSH
42151: CALL_OW 264
42155: PUSH
42156: LD_INT 31
42158: EQUAL
42159: PUSH
42160: LD_VAR 0 4
42164: PPUSH
42165: CALL_OW 311
42169: NOT
42170: AND
42171: PUSH
42172: LD_VAR 0 4
42176: PPUSH
42177: CALL_OW 266
42181: PUSH
42182: LD_INT 36
42184: EQUAL
42185: PUSH
42186: LD_VAR 0 4
42190: PPUSH
42191: CALL_OW 313
42195: PUSH
42196: LD_INT 3
42198: LESS
42199: AND
42200: OR
42201: IFFALSE 42215
// begin ct := k ;
42203: LD_ADDR_VAR 0 8
42207: PUSH
42208: LD_VAR 0 4
42212: ST_TO_ADDR
// break ;
42213: GO 42217
// end ;
42215: GO 42143
42217: POP
42218: POP
// if ct then
42219: LD_VAR 0 8
42223: IFFALSE 42239
// ComEnterUnit ( j , ct ) ;
42225: LD_VAR 0 3
42229: PPUSH
42230: LD_VAR 0 8
42234: PPUSH
42235: CALL_OW 120
// end ; end ;
42239: GO 41874
42241: POP
42242: POP
// places := 0 ;
42243: LD_ADDR_VAR 0 5
42247: PUSH
42248: LD_INT 0
42250: ST_TO_ADDR
// for j = 1 to x do
42251: LD_ADDR_VAR 0 3
42255: PUSH
42256: DOUBLE
42257: LD_INT 1
42259: DEC
42260: ST_TO_ADDR
42261: LD_VAR 0 11
42265: PUSH
42266: FOR_TO
42267: IFFALSE 42343
// if GetWeapon ( x [ j ] ) = ar_control_tower then
42269: LD_VAR 0 11
42273: PUSH
42274: LD_VAR 0 3
42278: ARRAY
42279: PPUSH
42280: CALL_OW 264
42284: PUSH
42285: LD_INT 31
42287: EQUAL
42288: IFFALSE 42306
// places := places + 1 else
42290: LD_ADDR_VAR 0 5
42294: PUSH
42295: LD_VAR 0 5
42299: PUSH
42300: LD_INT 1
42302: PLUS
42303: ST_TO_ADDR
42304: GO 42341
// if GetBType ( x [ j ] ) = b_control_tower then
42306: LD_VAR 0 11
42310: PUSH
42311: LD_VAR 0 3
42315: ARRAY
42316: PPUSH
42317: CALL_OW 266
42321: PUSH
42322: LD_INT 36
42324: EQUAL
42325: IFFALSE 42341
// places := places + 3 ;
42327: LD_ADDR_VAR 0 5
42331: PUSH
42332: LD_VAR 0 5
42336: PUSH
42337: LD_INT 3
42339: PLUS
42340: ST_TO_ADDR
42341: GO 42266
42343: POP
42344: POP
// if places = 0 or places <= mc_remote_driver [ i ] then
42345: LD_VAR 0 5
42349: PUSH
42350: LD_INT 0
42352: EQUAL
42353: PUSH
42354: LD_VAR 0 5
42358: PUSH
42359: LD_EXP 116
42363: PUSH
42364: LD_VAR 0 2
42368: ARRAY
42369: LESSEQUAL
42370: OR
42371: IFFALSE 42375
// continue ;
42373: GO 41625
// tmp := SortBySkill ( UnitFilter ( mc_bases [ i ] , [ f_class , 3 ] ) diff mc_remote_driver [ i ] , 3 ) ;
42375: LD_ADDR_VAR 0 6
42379: PUSH
42380: LD_EXP 76
42384: PUSH
42385: LD_VAR 0 2
42389: ARRAY
42390: PPUSH
42391: LD_INT 25
42393: PUSH
42394: LD_INT 3
42396: PUSH
42397: EMPTY
42398: LIST
42399: LIST
42400: PPUSH
42401: CALL_OW 72
42405: PUSH
42406: LD_EXP 116
42410: PUSH
42411: LD_VAR 0 2
42415: ARRAY
42416: DIFF
42417: PPUSH
42418: LD_INT 3
42420: PPUSH
42421: CALL 91994 0 2
42425: ST_TO_ADDR
// for j in tmp do
42426: LD_ADDR_VAR 0 3
42430: PUSH
42431: LD_VAR 0 6
42435: PUSH
42436: FOR_IN
42437: IFFALSE 42472
// if GetTag ( j ) > 0 then
42439: LD_VAR 0 3
42443: PPUSH
42444: CALL_OW 110
42448: PUSH
42449: LD_INT 0
42451: GREATER
42452: IFFALSE 42470
// tmp := tmp diff j ;
42454: LD_ADDR_VAR 0 6
42458: PUSH
42459: LD_VAR 0 6
42463: PUSH
42464: LD_VAR 0 3
42468: DIFF
42469: ST_TO_ADDR
42470: GO 42436
42472: POP
42473: POP
// if not tmp then
42474: LD_VAR 0 6
42478: NOT
42479: IFFALSE 42483
// continue ;
42481: GO 41625
// if places then
42483: LD_VAR 0 5
42487: IFFALSE 42546
// begin mc_remote_driver := Replace ( mc_remote_driver , i , mc_remote_driver [ i ] union tmp [ 1 ] ) ;
42489: LD_ADDR_EXP 116
42493: PUSH
42494: LD_EXP 116
42498: PPUSH
42499: LD_VAR 0 2
42503: PPUSH
42504: LD_EXP 116
42508: PUSH
42509: LD_VAR 0 2
42513: ARRAY
42514: PUSH
42515: LD_VAR 0 6
42519: PUSH
42520: LD_INT 1
42522: ARRAY
42523: UNION
42524: PPUSH
42525: CALL_OW 1
42529: ST_TO_ADDR
// SetTag ( tmp [ 1 ] , 126 ) ;
42530: LD_VAR 0 6
42534: PUSH
42535: LD_INT 1
42537: ARRAY
42538: PPUSH
42539: LD_INT 126
42541: PPUSH
42542: CALL_OW 109
// end ; end ;
42546: GO 41625
42548: POP
42549: POP
// end ;
42550: LD_VAR 0 1
42554: RET
// export function MC_Back ( base , base_unit_list , unit , class ) ; var i , j , tmp , x , depot ; begin
42555: LD_INT 0
42557: PPUSH
42558: PPUSH
42559: PPUSH
42560: PPUSH
42561: PPUSH
42562: PPUSH
// if not base or not base_unit_list or not unit or not class in [ 1 , 2 , 3 , 4 , 5 , 8 , 9 , 15 , 16 ] then
42563: LD_VAR 0 1
42567: NOT
42568: PUSH
42569: LD_VAR 0 2
42573: NOT
42574: OR
42575: PUSH
42576: LD_VAR 0 3
42580: NOT
42581: OR
42582: PUSH
42583: LD_VAR 0 4
42587: PUSH
42588: LD_INT 1
42590: PUSH
42591: LD_INT 2
42593: PUSH
42594: LD_INT 3
42596: PUSH
42597: LD_INT 4
42599: PUSH
42600: LD_INT 5
42602: PUSH
42603: LD_INT 8
42605: PUSH
42606: LD_INT 9
42608: PUSH
42609: LD_INT 15
42611: PUSH
42612: LD_INT 16
42614: PUSH
42615: EMPTY
42616: LIST
42617: LIST
42618: LIST
42619: LIST
42620: LIST
42621: LIST
42622: LIST
42623: LIST
42624: LIST
42625: IN
42626: NOT
42627: OR
42628: IFFALSE 42632
// exit ;
42630: GO 43532
// base_unit_list := UnitFilter ( base_unit_list , [ [ f_type , unit_building ] , [ f_lives , 250 ] ] ) ;
42632: LD_ADDR_VAR 0 2
42636: PUSH
42637: LD_VAR 0 2
42641: PPUSH
42642: LD_INT 21
42644: PUSH
42645: LD_INT 3
42647: PUSH
42648: EMPTY
42649: LIST
42650: LIST
42651: PUSH
42652: LD_INT 24
42654: PUSH
42655: LD_INT 250
42657: PUSH
42658: EMPTY
42659: LIST
42660: LIST
42661: PUSH
42662: EMPTY
42663: LIST
42664: LIST
42665: PPUSH
42666: CALL_OW 72
42670: ST_TO_ADDR
// case class of 1 , 15 :
42671: LD_VAR 0 4
42675: PUSH
42676: LD_INT 1
42678: DOUBLE
42679: EQUAL
42680: IFTRUE 42690
42682: LD_INT 15
42684: DOUBLE
42685: EQUAL
42686: IFTRUE 42690
42688: GO 42775
42690: POP
// tmp := UnitFilter ( base_unit_list , [ f_or , [ f_btype , b_bunker ] , [ f_btype , b_breastwork ] ] ) ^ UnitFilter ( base_unit_list , [ f_or , [ f_btype , b_armoury ] , [ f_btype , b_barracks ] ] ) ; 2 , 16 :
42691: LD_ADDR_VAR 0 8
42695: PUSH
42696: LD_VAR 0 2
42700: PPUSH
42701: LD_INT 2
42703: PUSH
42704: LD_INT 30
42706: PUSH
42707: LD_INT 32
42709: PUSH
42710: EMPTY
42711: LIST
42712: LIST
42713: PUSH
42714: LD_INT 30
42716: PUSH
42717: LD_INT 31
42719: PUSH
42720: EMPTY
42721: LIST
42722: LIST
42723: PUSH
42724: EMPTY
42725: LIST
42726: LIST
42727: LIST
42728: PPUSH
42729: CALL_OW 72
42733: PUSH
42734: LD_VAR 0 2
42738: PPUSH
42739: LD_INT 2
42741: PUSH
42742: LD_INT 30
42744: PUSH
42745: LD_INT 4
42747: PUSH
42748: EMPTY
42749: LIST
42750: LIST
42751: PUSH
42752: LD_INT 30
42754: PUSH
42755: LD_INT 5
42757: PUSH
42758: EMPTY
42759: LIST
42760: LIST
42761: PUSH
42762: EMPTY
42763: LIST
42764: LIST
42765: LIST
42766: PPUSH
42767: CALL_OW 72
42771: ADD
42772: ST_TO_ADDR
42773: GO 43021
42775: LD_INT 2
42777: DOUBLE
42778: EQUAL
42779: IFTRUE 42789
42781: LD_INT 16
42783: DOUBLE
42784: EQUAL
42785: IFTRUE 42789
42787: GO 42835
42789: POP
// tmp := UnitFilter ( base_unit_list , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) ; 3 :
42790: LD_ADDR_VAR 0 8
42794: PUSH
42795: LD_VAR 0 2
42799: PPUSH
42800: LD_INT 2
42802: PUSH
42803: LD_INT 30
42805: PUSH
42806: LD_INT 0
42808: PUSH
42809: EMPTY
42810: LIST
42811: LIST
42812: PUSH
42813: LD_INT 30
42815: PUSH
42816: LD_INT 1
42818: PUSH
42819: EMPTY
42820: LIST
42821: LIST
42822: PUSH
42823: EMPTY
42824: LIST
42825: LIST
42826: LIST
42827: PPUSH
42828: CALL_OW 72
42832: ST_TO_ADDR
42833: GO 43021
42835: LD_INT 3
42837: DOUBLE
42838: EQUAL
42839: IFTRUE 42843
42841: GO 42889
42843: POP
// tmp := UnitFilter ( base_unit_list , [ f_or , [ f_btype , b_workshop ] , [ f_btype , b_factory ] ] ) ; 4 :
42844: LD_ADDR_VAR 0 8
42848: PUSH
42849: LD_VAR 0 2
42853: PPUSH
42854: LD_INT 2
42856: PUSH
42857: LD_INT 30
42859: PUSH
42860: LD_INT 2
42862: PUSH
42863: EMPTY
42864: LIST
42865: LIST
42866: PUSH
42867: LD_INT 30
42869: PUSH
42870: LD_INT 3
42872: PUSH
42873: EMPTY
42874: LIST
42875: LIST
42876: PUSH
42877: EMPTY
42878: LIST
42879: LIST
42880: LIST
42881: PPUSH
42882: CALL_OW 72
42886: ST_TO_ADDR
42887: GO 43021
42889: LD_INT 4
42891: DOUBLE
42892: EQUAL
42893: IFTRUE 42897
42895: GO 42954
42897: POP
// tmp := UnitFilter ( base_unit_list , [ f_or , [ f_btype , b_lab ] , [ f_btype , b_lab_half ] , [ f_btype , b_lab_full ] ] ) ; 5 , 8 , 9 :
42898: LD_ADDR_VAR 0 8
42902: PUSH
42903: LD_VAR 0 2
42907: PPUSH
42908: LD_INT 2
42910: PUSH
42911: LD_INT 30
42913: PUSH
42914: LD_INT 6
42916: PUSH
42917: EMPTY
42918: LIST
42919: LIST
42920: PUSH
42921: LD_INT 30
42923: PUSH
42924: LD_INT 7
42926: PUSH
42927: EMPTY
42928: LIST
42929: LIST
42930: PUSH
42931: LD_INT 30
42933: PUSH
42934: LD_INT 8
42936: PUSH
42937: EMPTY
42938: LIST
42939: LIST
42940: PUSH
42941: EMPTY
42942: LIST
42943: LIST
42944: LIST
42945: LIST
42946: PPUSH
42947: CALL_OW 72
42951: ST_TO_ADDR
42952: GO 43021
42954: LD_INT 5
42956: DOUBLE
42957: EQUAL
42958: IFTRUE 42974
42960: LD_INT 8
42962: DOUBLE
42963: EQUAL
42964: IFTRUE 42974
42966: LD_INT 9
42968: DOUBLE
42969: EQUAL
42970: IFTRUE 42974
42972: GO 43020
42974: POP
// tmp := UnitFilter ( base_unit_list , [ f_or , [ f_btype , b_armoury ] , [ f_btype , b_barracks ] ] ) ; end ;
42975: LD_ADDR_VAR 0 8
42979: PUSH
42980: LD_VAR 0 2
42984: PPUSH
42985: LD_INT 2
42987: PUSH
42988: LD_INT 30
42990: PUSH
42991: LD_INT 4
42993: PUSH
42994: EMPTY
42995: LIST
42996: LIST
42997: PUSH
42998: LD_INT 30
43000: PUSH
43001: LD_INT 5
43003: PUSH
43004: EMPTY
43005: LIST
43006: LIST
43007: PUSH
43008: EMPTY
43009: LIST
43010: LIST
43011: LIST
43012: PPUSH
43013: CALL_OW 72
43017: ST_TO_ADDR
43018: GO 43021
43020: POP
// if not tmp then
43021: LD_VAR 0 8
43025: NOT
43026: IFFALSE 43030
// exit ;
43028: GO 43532
// if class in [ 1 , 15 ] and mc_empty_turret_list [ base ] then
43030: LD_VAR 0 4
43034: PUSH
43035: LD_INT 1
43037: PUSH
43038: LD_INT 15
43040: PUSH
43041: EMPTY
43042: LIST
43043: LIST
43044: IN
43045: PUSH
43046: LD_EXP 85
43050: PUSH
43051: LD_VAR 0 1
43055: ARRAY
43056: AND
43057: IFFALSE 43213
// begin x := mc_empty_turret_list [ base ] [ 1 ] ;
43059: LD_ADDR_VAR 0 9
43063: PUSH
43064: LD_EXP 85
43068: PUSH
43069: LD_VAR 0 1
43073: ARRAY
43074: PUSH
43075: LD_INT 1
43077: ARRAY
43078: ST_TO_ADDR
// if not x in mc_busy_turret_list [ base ] then
43079: LD_VAR 0 9
43083: PUSH
43084: LD_EXP 86
43088: PUSH
43089: LD_VAR 0 1
43093: ARRAY
43094: IN
43095: NOT
43096: IFFALSE 43211
// begin mc_busy_turret_list := ReplaceIn ( mc_busy_turret_list , [ base , mc_busy_turret_list [ base ] + 1 ] , x ) ;
43098: LD_ADDR_EXP 86
43102: PUSH
43103: LD_EXP 86
43107: PPUSH
43108: LD_VAR 0 1
43112: PUSH
43113: LD_EXP 86
43117: PUSH
43118: LD_VAR 0 1
43122: ARRAY
43123: PUSH
43124: LD_INT 1
43126: PLUS
43127: PUSH
43128: EMPTY
43129: LIST
43130: LIST
43131: PPUSH
43132: LD_VAR 0 9
43136: PPUSH
43137: CALL 57743 0 3
43141: ST_TO_ADDR
// mc_empty_turret_list := Replace ( mc_empty_turret_list , base , mc_empty_turret_list [ base ] diff x ) ;
43142: LD_ADDR_EXP 85
43146: PUSH
43147: LD_EXP 85
43151: PPUSH
43152: LD_VAR 0 1
43156: PPUSH
43157: LD_EXP 85
43161: PUSH
43162: LD_VAR 0 1
43166: ARRAY
43167: PUSH
43168: LD_VAR 0 9
43172: DIFF
43173: PPUSH
43174: CALL_OW 1
43178: ST_TO_ADDR
// ComEnterUnit ( unit , mc_busy_turret_list [ base ] [ mc_busy_turret_list [ base ] ] ) ;
43179: LD_VAR 0 3
43183: PPUSH
43184: LD_EXP 86
43188: PUSH
43189: LD_VAR 0 1
43193: ARRAY
43194: PUSH
43195: LD_EXP 86
43199: PUSH
43200: LD_VAR 0 1
43204: ARRAY
43205: ARRAY
43206: PPUSH
43207: CALL_OW 120
// end ; exit ;
43211: GO 43532
// end ; if tmp > 1 then
43213: LD_VAR 0 8
43217: PUSH
43218: LD_INT 1
43220: GREATER
43221: IFFALSE 43325
// for i = 2 to tmp do
43223: LD_ADDR_VAR 0 6
43227: PUSH
43228: DOUBLE
43229: LD_INT 2
43231: DEC
43232: ST_TO_ADDR
43233: LD_VAR 0 8
43237: PUSH
43238: FOR_TO
43239: IFFALSE 43323
// if BuildingStatus ( tmp [ i ] ) = bs_need_people then
43241: LD_VAR 0 8
43245: PUSH
43246: LD_VAR 0 6
43250: ARRAY
43251: PPUSH
43252: CALL_OW 461
43256: PUSH
43257: LD_INT 6
43259: EQUAL
43260: IFFALSE 43321
// begin x := tmp [ i ] ;
43262: LD_ADDR_VAR 0 9
43266: PUSH
43267: LD_VAR 0 8
43271: PUSH
43272: LD_VAR 0 6
43276: ARRAY
43277: ST_TO_ADDR
// tmp := Delete ( tmp , i ) ;
43278: LD_ADDR_VAR 0 8
43282: PUSH
43283: LD_VAR 0 8
43287: PPUSH
43288: LD_VAR 0 6
43292: PPUSH
43293: CALL_OW 3
43297: ST_TO_ADDR
// tmp := Insert ( tmp , 1 , x ) ;
43298: LD_ADDR_VAR 0 8
43302: PUSH
43303: LD_VAR 0 8
43307: PPUSH
43308: LD_INT 1
43310: PPUSH
43311: LD_VAR 0 9
43315: PPUSH
43316: CALL_OW 2
43320: ST_TO_ADDR
// end ;
43321: GO 43238
43323: POP
43324: POP
// for i in tmp do
43325: LD_ADDR_VAR 0 6
43329: PUSH
43330: LD_VAR 0 8
43334: PUSH
43335: FOR_IN
43336: IFFALSE 43405
// begin if ( UnitsInside ( i ) < 6 and not GetBType ( i ) in [ b_breastwork , b_bunker ] ) or UnitsInside ( i ) = 0 then
43338: LD_VAR 0 6
43342: PPUSH
43343: CALL_OW 313
43347: PUSH
43348: LD_INT 6
43350: LESS
43351: PUSH
43352: LD_VAR 0 6
43356: PPUSH
43357: CALL_OW 266
43361: PUSH
43362: LD_INT 31
43364: PUSH
43365: LD_INT 32
43367: PUSH
43368: EMPTY
43369: LIST
43370: LIST
43371: IN
43372: NOT
43373: AND
43374: PUSH
43375: LD_VAR 0 6
43379: PPUSH
43380: CALL_OW 313
43384: PUSH
43385: LD_INT 0
43387: EQUAL
43388: OR
43389: IFFALSE 43403
// begin j := i ;
43391: LD_ADDR_VAR 0 7
43395: PUSH
43396: LD_VAR 0 6
43400: ST_TO_ADDR
// break ;
43401: GO 43405
// end ; end ;
43403: GO 43335
43405: POP
43406: POP
// if j then
43407: LD_VAR 0 7
43411: IFFALSE 43429
// ComEnterUnit ( unit , j ) else
43413: LD_VAR 0 3
43417: PPUSH
43418: LD_VAR 0 7
43422: PPUSH
43423: CALL_OW 120
43427: GO 43532
// begin depot := UnitFilter ( base_unit_list , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) ;
43429: LD_ADDR_VAR 0 10
43433: PUSH
43434: LD_VAR 0 2
43438: PPUSH
43439: LD_INT 2
43441: PUSH
43442: LD_INT 30
43444: PUSH
43445: LD_INT 0
43447: PUSH
43448: EMPTY
43449: LIST
43450: LIST
43451: PUSH
43452: LD_INT 30
43454: PUSH
43455: LD_INT 1
43457: PUSH
43458: EMPTY
43459: LIST
43460: LIST
43461: PUSH
43462: EMPTY
43463: LIST
43464: LIST
43465: LIST
43466: PPUSH
43467: CALL_OW 72
43471: ST_TO_ADDR
// if depot then
43472: LD_VAR 0 10
43476: IFFALSE 43532
// begin depot := NearestUnitToUnit ( depot , unit ) ;
43478: LD_ADDR_VAR 0 10
43482: PUSH
43483: LD_VAR 0 10
43487: PPUSH
43488: LD_VAR 0 3
43492: PPUSH
43493: CALL_OW 74
43497: ST_TO_ADDR
// if GetDistUnits ( unit , depot ) > 10 then
43498: LD_VAR 0 3
43502: PPUSH
43503: LD_VAR 0 10
43507: PPUSH
43508: CALL_OW 296
43512: PUSH
43513: LD_INT 10
43515: GREATER
43516: IFFALSE 43532
// ComStandNearbyBuilding ( unit , depot ) ;
43518: LD_VAR 0 3
43522: PPUSH
43523: LD_VAR 0 10
43527: PPUSH
43528: CALL 51946 0 2
// end ; end ; end ;
43532: LD_VAR 0 5
43536: RET
// export function MC_Idle ( ) ; var i , j , tmp ; begin
43537: LD_INT 0
43539: PPUSH
43540: PPUSH
43541: PPUSH
43542: PPUSH
// if not mc_bases then
43543: LD_EXP 76
43547: NOT
43548: IFFALSE 43552
// exit ;
43550: GO 43791
// for i = 1 to mc_bases do
43552: LD_ADDR_VAR 0 2
43556: PUSH
43557: DOUBLE
43558: LD_INT 1
43560: DEC
43561: ST_TO_ADDR
43562: LD_EXP 76
43566: PUSH
43567: FOR_TO
43568: IFFALSE 43789
// begin tmp := UnitFilter ( mc_bases [ i ] , [ f_type , unit_human ] ) union mc_ape [ i ] ;
43570: LD_ADDR_VAR 0 4
43574: PUSH
43575: LD_EXP 76
43579: PUSH
43580: LD_VAR 0 2
43584: ARRAY
43585: PPUSH
43586: LD_INT 21
43588: PUSH
43589: LD_INT 1
43591: PUSH
43592: EMPTY
43593: LIST
43594: LIST
43595: PPUSH
43596: CALL_OW 72
43600: PUSH
43601: LD_EXP 105
43605: PUSH
43606: LD_VAR 0 2
43610: ARRAY
43611: UNION
43612: ST_TO_ADDR
// if not tmp then
43613: LD_VAR 0 4
43617: NOT
43618: IFFALSE 43622
// continue ;
43620: GO 43567
// for j in tmp do
43622: LD_ADDR_VAR 0 3
43626: PUSH
43627: LD_VAR 0 4
43631: PUSH
43632: FOR_IN
43633: IFFALSE 43785
// begin if not GetTag ( j ) and not HasTask ( j ) and not IsDrivenBy ( j ) and not IsInUnit ( j ) and not j in mc_need_heal [ i ] [ 1 ] and not j in mc_need_heal [ i ] [ 2 ] and not j in mc_repair_vehicle [ i ] then
43635: LD_VAR 0 3
43639: PPUSH
43640: CALL_OW 110
43644: NOT
43645: PUSH
43646: LD_VAR 0 3
43650: PPUSH
43651: CALL_OW 314
43655: NOT
43656: AND
43657: PUSH
43658: LD_VAR 0 3
43662: PPUSH
43663: CALL_OW 311
43667: NOT
43668: AND
43669: PUSH
43670: LD_VAR 0 3
43674: PPUSH
43675: CALL_OW 310
43679: NOT
43680: AND
43681: PUSH
43682: LD_VAR 0 3
43686: PUSH
43687: LD_EXP 79
43691: PUSH
43692: LD_VAR 0 2
43696: ARRAY
43697: PUSH
43698: LD_INT 1
43700: ARRAY
43701: IN
43702: NOT
43703: AND
43704: PUSH
43705: LD_VAR 0 3
43709: PUSH
43710: LD_EXP 79
43714: PUSH
43715: LD_VAR 0 2
43719: ARRAY
43720: PUSH
43721: LD_INT 2
43723: ARRAY
43724: IN
43725: NOT
43726: AND
43727: PUSH
43728: LD_VAR 0 3
43732: PUSH
43733: LD_EXP 88
43737: PUSH
43738: LD_VAR 0 2
43742: ARRAY
43743: IN
43744: NOT
43745: AND
43746: IFFALSE 43783
// MC_Back ( i , mc_bases [ i ] , j , GetClass ( j ) ) ;
43748: LD_VAR 0 2
43752: PPUSH
43753: LD_EXP 76
43757: PUSH
43758: LD_VAR 0 2
43762: ARRAY
43763: PPUSH
43764: LD_VAR 0 3
43768: PPUSH
43769: LD_VAR 0 3
43773: PPUSH
43774: CALL_OW 257
43778: PPUSH
43779: CALL 42555 0 4
// end ;
43783: GO 43632
43785: POP
43786: POP
// end ;
43787: GO 43567
43789: POP
43790: POP
// end ;
43791: LD_VAR 0 1
43795: RET
// export function MC_SetMinesField ( base , amount , area ) ; var i , tmp , list , x , j ; begin
43796: LD_INT 0
43798: PPUSH
43799: PPUSH
43800: PPUSH
43801: PPUSH
43802: PPUSH
43803: PPUSH
// if not mc_bases [ base ] then
43804: LD_EXP 76
43808: PUSH
43809: LD_VAR 0 1
43813: ARRAY
43814: NOT
43815: IFFALSE 43819
// exit ;
43817: GO 44001
// tmp := [ ] ;
43819: LD_ADDR_VAR 0 6
43823: PUSH
43824: EMPTY
43825: ST_TO_ADDR
// list := AreaToList ( area , 0 ) ;
43826: LD_ADDR_VAR 0 7
43830: PUSH
43831: LD_VAR 0 3
43835: PPUSH
43836: LD_INT 0
43838: PPUSH
43839: CALL_OW 517
43843: ST_TO_ADDR
// if not list then
43844: LD_VAR 0 7
43848: NOT
43849: IFFALSE 43853
// exit ;
43851: GO 44001
// for i = 1 to amount do
43853: LD_ADDR_VAR 0 5
43857: PUSH
43858: DOUBLE
43859: LD_INT 1
43861: DEC
43862: ST_TO_ADDR
43863: LD_VAR 0 2
43867: PUSH
43868: FOR_TO
43869: IFFALSE 43949
// begin x := rand ( 1 , list [ 1 ] ) ;
43871: LD_ADDR_VAR 0 8
43875: PUSH
43876: LD_INT 1
43878: PPUSH
43879: LD_VAR 0 7
43883: PUSH
43884: LD_INT 1
43886: ARRAY
43887: PPUSH
43888: CALL_OW 12
43892: ST_TO_ADDR
// tmp := Replace ( tmp , i , [ list [ 1 ] [ x ] , list [ 2 ] [ x ] ] ) ;
43893: LD_ADDR_VAR 0 6
43897: PUSH
43898: LD_VAR 0 6
43902: PPUSH
43903: LD_VAR 0 5
43907: PPUSH
43908: LD_VAR 0 7
43912: PUSH
43913: LD_INT 1
43915: ARRAY
43916: PUSH
43917: LD_VAR 0 8
43921: ARRAY
43922: PUSH
43923: LD_VAR 0 7
43927: PUSH
43928: LD_INT 2
43930: ARRAY
43931: PUSH
43932: LD_VAR 0 8
43936: ARRAY
43937: PUSH
43938: EMPTY
43939: LIST
43940: LIST
43941: PPUSH
43942: CALL_OW 1
43946: ST_TO_ADDR
// end ;
43947: GO 43868
43949: POP
43950: POP
// mc_mines := Replace ( mc_mines , base , tmp ) ;
43951: LD_ADDR_EXP 89
43955: PUSH
43956: LD_EXP 89
43960: PPUSH
43961: LD_VAR 0 1
43965: PPUSH
43966: LD_VAR 0 6
43970: PPUSH
43971: CALL_OW 1
43975: ST_TO_ADDR
// mc_minefields := Replace ( mc_minefields , base , area ) ;
43976: LD_ADDR_EXP 91
43980: PUSH
43981: LD_EXP 91
43985: PPUSH
43986: LD_VAR 0 1
43990: PPUSH
43991: LD_VAR 0 3
43995: PPUSH
43996: CALL_OW 1
44000: ST_TO_ADDR
// end ;
44001: LD_VAR 0 4
44005: RET
// export function MC_SetBuildingList ( base , construct_list ) ; begin
44006: LD_INT 0
44008: PPUSH
// if not mc_bases [ base ] then
44009: LD_EXP 76
44013: PUSH
44014: LD_VAR 0 1
44018: ARRAY
44019: NOT
44020: IFFALSE 44024
// exit ;
44022: GO 44049
// mc_build_list := Replace ( mc_build_list , base , construct_list ) ;
44024: LD_ADDR_EXP 81
44028: PUSH
44029: LD_EXP 81
44033: PPUSH
44034: LD_VAR 0 1
44038: PPUSH
44039: LD_VAR 0 2
44043: PPUSH
44044: CALL_OW 1
44048: ST_TO_ADDR
// end ;
44049: LD_VAR 0 3
44053: RET
// export function MC_InsertBuildingList ( base , list ) ; begin
44054: LD_INT 0
44056: PPUSH
// if not mc_bases [ base ] then
44057: LD_EXP 76
44061: PUSH
44062: LD_VAR 0 1
44066: ARRAY
44067: NOT
44068: IFFALSE 44072
// exit ;
44070: GO 44109
// mc_build_list := Replace ( mc_build_list , base , mc_build_list [ base ] union list ) ;
44072: LD_ADDR_EXP 81
44076: PUSH
44077: LD_EXP 81
44081: PPUSH
44082: LD_VAR 0 1
44086: PPUSH
44087: LD_EXP 81
44091: PUSH
44092: LD_VAR 0 1
44096: ARRAY
44097: PUSH
44098: LD_VAR 0 2
44102: UNION
44103: PPUSH
44104: CALL_OW 1
44108: ST_TO_ADDR
// end ;
44109: LD_VAR 0 3
44113: RET
// export function MC_SetProduceList ( base , produce_list ) ; begin
44114: LD_INT 0
44116: PPUSH
// if not mc_bases [ base ] then
44117: LD_EXP 76
44121: PUSH
44122: LD_VAR 0 1
44126: ARRAY
44127: NOT
44128: IFFALSE 44132
// exit ;
44130: GO 44157
// mc_produce := Replace ( mc_produce , base , produce_list ) ;
44132: LD_ADDR_EXP 97
44136: PUSH
44137: LD_EXP 97
44141: PPUSH
44142: LD_VAR 0 1
44146: PPUSH
44147: LD_VAR 0 2
44151: PPUSH
44152: CALL_OW 1
44156: ST_TO_ADDR
// end ;
44157: LD_VAR 0 3
44161: RET
// export function MC_InsertProduceList ( base , components ) ; begin
44162: LD_INT 0
44164: PPUSH
// if not mc_bases [ base ] then
44165: LD_EXP 76
44169: PUSH
44170: LD_VAR 0 1
44174: ARRAY
44175: NOT
44176: IFFALSE 44180
// exit ;
44178: GO 44217
// mc_produce := Replace ( mc_produce , base , mc_produce [ base ] ^ components ) ;
44180: LD_ADDR_EXP 97
44184: PUSH
44185: LD_EXP 97
44189: PPUSH
44190: LD_VAR 0 1
44194: PPUSH
44195: LD_EXP 97
44199: PUSH
44200: LD_VAR 0 1
44204: ARRAY
44205: PUSH
44206: LD_VAR 0 2
44210: ADD
44211: PPUSH
44212: CALL_OW 1
44216: ST_TO_ADDR
// end ;
44217: LD_VAR 0 3
44221: RET
// export function MC_SetDefenderList ( base , deflist ) ; begin
44222: LD_INT 0
44224: PPUSH
// if not mc_bases [ base ] then
44225: LD_EXP 76
44229: PUSH
44230: LD_VAR 0 1
44234: ARRAY
44235: NOT
44236: IFFALSE 44240
// exit ;
44238: GO 44294
// mc_defender := Replace ( mc_defender , base , deflist ) ;
44240: LD_ADDR_EXP 98
44244: PUSH
44245: LD_EXP 98
44249: PPUSH
44250: LD_VAR 0 1
44254: PPUSH
44255: LD_VAR 0 2
44259: PPUSH
44260: CALL_OW 1
44264: ST_TO_ADDR
// mc_defender_limit := Replace ( mc_defender_limit , base , deflist + 0 ) ;
44265: LD_ADDR_EXP 87
44269: PUSH
44270: LD_EXP 87
44274: PPUSH
44275: LD_VAR 0 1
44279: PPUSH
44280: LD_VAR 0 2
44284: PUSH
44285: LD_INT 0
44287: PLUS
44288: PPUSH
44289: CALL_OW 1
44293: ST_TO_ADDR
// end ;
44294: LD_VAR 0 3
44298: RET
// export function MC_SetDefenderLimit ( base , limit ) ; begin
44299: LD_INT 0
44301: PPUSH
// if not mc_bases [ base ] then
44302: LD_EXP 76
44306: PUSH
44307: LD_VAR 0 1
44311: ARRAY
44312: NOT
44313: IFFALSE 44317
// exit ;
44315: GO 44342
// mc_defender_limit := Replace ( mc_defender_limit , base , limit ) ;
44317: LD_ADDR_EXP 87
44321: PUSH
44322: LD_EXP 87
44326: PPUSH
44327: LD_VAR 0 1
44331: PPUSH
44332: LD_VAR 0 2
44336: PPUSH
44337: CALL_OW 1
44341: ST_TO_ADDR
// end ;
44342: LD_VAR 0 3
44346: RET
// export function MC_PrepareAttack ( base , group , path , flags ) ; var i , j , tmp ; begin
44347: LD_INT 0
44349: PPUSH
44350: PPUSH
44351: PPUSH
44352: PPUSH
// if not mc_bases [ base ] then
44353: LD_EXP 76
44357: PUSH
44358: LD_VAR 0 1
44362: ARRAY
44363: NOT
44364: IFFALSE 44368
// exit ;
44366: GO 44433
// mc_attack := ReplaceIn ( mc_attack , [ base , mc_attack [ base ] + 1 ] , [ base , group , path , flags ] ) ;
44368: LD_ADDR_EXP 96
44372: PUSH
44373: LD_EXP 96
44377: PPUSH
44378: LD_VAR 0 1
44382: PUSH
44383: LD_EXP 96
44387: PUSH
44388: LD_VAR 0 1
44392: ARRAY
44393: PUSH
44394: LD_INT 1
44396: PLUS
44397: PUSH
44398: EMPTY
44399: LIST
44400: LIST
44401: PPUSH
44402: LD_VAR 0 1
44406: PUSH
44407: LD_VAR 0 2
44411: PUSH
44412: LD_VAR 0 3
44416: PUSH
44417: LD_VAR 0 4
44421: PUSH
44422: EMPTY
44423: LIST
44424: LIST
44425: LIST
44426: LIST
44427: PPUSH
44428: CALL 57743 0 3
44432: ST_TO_ADDR
// end ;
44433: LD_VAR 0 5
44437: RET
// export function MC_SetDepositsXY ( base , deposits_list ) ; begin
44438: LD_INT 0
44440: PPUSH
// if not mc_bases [ base ] then
44441: LD_EXP 76
44445: PUSH
44446: LD_VAR 0 1
44450: ARRAY
44451: NOT
44452: IFFALSE 44456
// exit ;
44454: GO 44481
// mc_deposits_xy := Replace ( mc_deposits_xy , base , deposits_list ) ;
44456: LD_ADDR_EXP 113
44460: PUSH
44461: LD_EXP 113
44465: PPUSH
44466: LD_VAR 0 1
44470: PPUSH
44471: LD_VAR 0 2
44475: PPUSH
44476: CALL_OW 1
44480: ST_TO_ADDR
// end ;
44481: LD_VAR 0 3
44485: RET
// export function MC_GetMinesField ( base ) ; begin
44486: LD_INT 0
44488: PPUSH
// result := mc_mines [ base ] ;
44489: LD_ADDR_VAR 0 2
44493: PUSH
44494: LD_EXP 89
44498: PUSH
44499: LD_VAR 0 1
44503: ARRAY
44504: ST_TO_ADDR
// end ;
44505: LD_VAR 0 2
44509: RET
// export function MC_GetProduceList ( base ) ; begin
44510: LD_INT 0
44512: PPUSH
// result := mc_produce [ base ] ;
44513: LD_ADDR_VAR 0 2
44517: PUSH
44518: LD_EXP 97
44522: PUSH
44523: LD_VAR 0 1
44527: ARRAY
44528: ST_TO_ADDR
// end ;
44529: LD_VAR 0 2
44533: RET
// export function MC_GetBuilding ( base , btype ) ; var i ; begin
44534: LD_INT 0
44536: PPUSH
44537: PPUSH
// if not mc_bases then
44538: LD_EXP 76
44542: NOT
44543: IFFALSE 44547
// exit ;
44545: GO 44612
// if mc_bases [ base ] then
44547: LD_EXP 76
44551: PUSH
44552: LD_VAR 0 1
44556: ARRAY
44557: IFFALSE 44612
// begin result := UnitFilter ( mc_bases [ base ] , [ f_btype , btype ] ) ;
44559: LD_ADDR_VAR 0 3
44563: PUSH
44564: LD_EXP 76
44568: PUSH
44569: LD_VAR 0 1
44573: ARRAY
44574: PPUSH
44575: LD_INT 30
44577: PUSH
44578: LD_VAR 0 2
44582: PUSH
44583: EMPTY
44584: LIST
44585: LIST
44586: PPUSH
44587: CALL_OW 72
44591: ST_TO_ADDR
// if result then
44592: LD_VAR 0 3
44596: IFFALSE 44612
// result := result [ 1 ] ;
44598: LD_ADDR_VAR 0 3
44602: PUSH
44603: LD_VAR 0 3
44607: PUSH
44608: LD_INT 1
44610: ARRAY
44611: ST_TO_ADDR
// end ; end ;
44612: LD_VAR 0 3
44616: RET
// export function MC_GetBuildings ( base , btype ) ; var i ; begin
44617: LD_INT 0
44619: PPUSH
44620: PPUSH
// if not mc_bases then
44621: LD_EXP 76
44625: NOT
44626: IFFALSE 44630
// exit ;
44628: GO 44675
// if mc_bases [ base ] then
44630: LD_EXP 76
44634: PUSH
44635: LD_VAR 0 1
44639: ARRAY
44640: IFFALSE 44675
// result := UnitFilter ( mc_bases [ base ] , [ f_btype , btype ] ) ;
44642: LD_ADDR_VAR 0 3
44646: PUSH
44647: LD_EXP 76
44651: PUSH
44652: LD_VAR 0 1
44656: ARRAY
44657: PPUSH
44658: LD_INT 30
44660: PUSH
44661: LD_VAR 0 2
44665: PUSH
44666: EMPTY
44667: LIST
44668: LIST
44669: PPUSH
44670: CALL_OW 72
44674: ST_TO_ADDR
// end ;
44675: LD_VAR 0 3
44679: RET
// export function MC_SetTame ( base , area ) ; begin
44680: LD_INT 0
44682: PPUSH
// if not mc_bases or not base then
44683: LD_EXP 76
44687: NOT
44688: PUSH
44689: LD_VAR 0 1
44693: NOT
44694: OR
44695: IFFALSE 44699
// exit ;
44697: GO 44724
// mc_can_tame := Replace ( mc_can_tame , base , area ) ;
44699: LD_ADDR_EXP 104
44703: PUSH
44704: LD_EXP 104
44708: PPUSH
44709: LD_VAR 0 1
44713: PPUSH
44714: LD_VAR 0 2
44718: PPUSH
44719: CALL_OW 1
44723: ST_TO_ADDR
// end ;
44724: LD_VAR 0 3
44728: RET
// export function MC_SetUpgradeBuilding ( base , btype ) ; var tmp ; begin
44729: LD_INT 0
44731: PPUSH
44732: PPUSH
// if not mc_bases or not base then
44733: LD_EXP 76
44737: NOT
44738: PUSH
44739: LD_VAR 0 1
44743: NOT
44744: OR
44745: IFFALSE 44749
// exit ;
44747: GO 44851
// tmp := UnitFilter ( mc_bases [ base ] , [ f_btype , btype ] ) ;
44749: LD_ADDR_VAR 0 4
44753: PUSH
44754: LD_EXP 76
44758: PUSH
44759: LD_VAR 0 1
44763: ARRAY
44764: PPUSH
44765: LD_INT 30
44767: PUSH
44768: LD_VAR 0 2
44772: PUSH
44773: EMPTY
44774: LIST
44775: LIST
44776: PPUSH
44777: CALL_OW 72
44781: ST_TO_ADDR
// if not tmp then
44782: LD_VAR 0 4
44786: NOT
44787: IFFALSE 44791
// exit ;
44789: GO 44851
// mc_build_upgrade := Replace ( mc_build_upgrade , base , Insert ( mc_build_upgrade [ base ] , mc_build_upgrade [ base ] + 1 , tmp [ 1 ] ) ) ;
44791: LD_ADDR_EXP 108
44795: PUSH
44796: LD_EXP 108
44800: PPUSH
44801: LD_VAR 0 1
44805: PPUSH
44806: LD_EXP 108
44810: PUSH
44811: LD_VAR 0 1
44815: ARRAY
44816: PPUSH
44817: LD_EXP 108
44821: PUSH
44822: LD_VAR 0 1
44826: ARRAY
44827: PUSH
44828: LD_INT 1
44830: PLUS
44831: PPUSH
44832: LD_VAR 0 4
44836: PUSH
44837: LD_INT 1
44839: ARRAY
44840: PPUSH
44841: CALL_OW 2
44845: PPUSH
44846: CALL_OW 1
44850: ST_TO_ADDR
// end ;
44851: LD_VAR 0 3
44855: RET
// export function MC_SetLabKind ( base , kinds ) ; var i ; begin
44856: LD_INT 0
44858: PPUSH
44859: PPUSH
// if not mc_bases or not base or not kinds then
44860: LD_EXP 76
44864: NOT
44865: PUSH
44866: LD_VAR 0 1
44870: NOT
44871: OR
44872: PUSH
44873: LD_VAR 0 2
44877: NOT
44878: OR
44879: IFFALSE 44883
// exit ;
44881: GO 44944
// for i in kinds do
44883: LD_ADDR_VAR 0 4
44887: PUSH
44888: LD_VAR 0 2
44892: PUSH
44893: FOR_IN
44894: IFFALSE 44942
// mc_lab_upgrade := ReplaceIn ( mc_lab_upgrade , [ base , mc_lab_upgrade [ base ] + 1 ] , i ) ;
44896: LD_ADDR_EXP 110
44900: PUSH
44901: LD_EXP 110
44905: PPUSH
44906: LD_VAR 0 1
44910: PUSH
44911: LD_EXP 110
44915: PUSH
44916: LD_VAR 0 1
44920: ARRAY
44921: PUSH
44922: LD_INT 1
44924: PLUS
44925: PUSH
44926: EMPTY
44927: LIST
44928: LIST
44929: PPUSH
44930: LD_VAR 0 4
44934: PPUSH
44935: CALL 57743 0 3
44939: ST_TO_ADDR
44940: GO 44893
44942: POP
44943: POP
// end ;
44944: LD_VAR 0 3
44948: RET
// export function MC_SetCratesArea ( base , areas ) ; begin
44949: LD_INT 0
44951: PPUSH
// if not mc_bases or not base or not areas then
44952: LD_EXP 76
44956: NOT
44957: PUSH
44958: LD_VAR 0 1
44962: NOT
44963: OR
44964: PUSH
44965: LD_VAR 0 2
44969: NOT
44970: OR
44971: IFFALSE 44975
// exit ;
44973: GO 45000
// mc_crates_area := Replace ( mc_crates_area , base , areas ) ;
44975: LD_ADDR_EXP 94
44979: PUSH
44980: LD_EXP 94
44984: PPUSH
44985: LD_VAR 0 1
44989: PPUSH
44990: LD_VAR 0 2
44994: PPUSH
44995: CALL_OW 1
44999: ST_TO_ADDR
// end ;
45000: LD_VAR 0 3
45004: RET
// export function MC_SetTeleportExit ( base , teleports_exit ) ; begin
45005: LD_INT 0
45007: PPUSH
// if not mc_bases or not base or not teleports_exit then
45008: LD_EXP 76
45012: NOT
45013: PUSH
45014: LD_VAR 0 1
45018: NOT
45019: OR
45020: PUSH
45021: LD_VAR 0 2
45025: NOT
45026: OR
45027: IFFALSE 45031
// exit ;
45029: GO 45056
// mc_teleport_exit := Replace ( mc_teleport_exit , base , teleports_exit ) ;
45031: LD_ADDR_EXP 111
45035: PUSH
45036: LD_EXP 111
45040: PPUSH
45041: LD_VAR 0 1
45045: PPUSH
45046: LD_VAR 0 2
45050: PPUSH
45051: CALL_OW 1
45055: ST_TO_ADDR
// end ;
45056: LD_VAR 0 3
45060: RET
// export function MC_SetFactoryExtension ( base , x , y , d , ext_list ) ; var i , tmp ; begin
45061: LD_INT 0
45063: PPUSH
45064: PPUSH
45065: PPUSH
// if not mc_bases or not base or not ext_list then
45066: LD_EXP 76
45070: NOT
45071: PUSH
45072: LD_VAR 0 1
45076: NOT
45077: OR
45078: PUSH
45079: LD_VAR 0 5
45083: NOT
45084: OR
45085: IFFALSE 45089
// exit ;
45087: GO 45262
// tmp := GetFacExtXYD ( x , y , d ) ;
45089: LD_ADDR_VAR 0 8
45093: PUSH
45094: LD_VAR 0 2
45098: PPUSH
45099: LD_VAR 0 3
45103: PPUSH
45104: LD_VAR 0 4
45108: PPUSH
45109: CALL 91124 0 3
45113: ST_TO_ADDR
// if not tmp then
45114: LD_VAR 0 8
45118: NOT
45119: IFFALSE 45123
// exit ;
45121: GO 45262
// for i in tmp do
45123: LD_ADDR_VAR 0 7
45127: PUSH
45128: LD_VAR 0 8
45132: PUSH
45133: FOR_IN
45134: IFFALSE 45260
// begin mc_build_list := Replace ( mc_build_list , base , Insert ( mc_build_list [ base ] , mc_build_list [ base ] + 1 , [ ext_list [ 1 ] , i [ 1 ] , i [ 2 ] , i [ 3 ] ] ) ) ;
45136: LD_ADDR_EXP 81
45140: PUSH
45141: LD_EXP 81
45145: PPUSH
45146: LD_VAR 0 1
45150: PPUSH
45151: LD_EXP 81
45155: PUSH
45156: LD_VAR 0 1
45160: ARRAY
45161: PPUSH
45162: LD_EXP 81
45166: PUSH
45167: LD_VAR 0 1
45171: ARRAY
45172: PUSH
45173: LD_INT 1
45175: PLUS
45176: PPUSH
45177: LD_VAR 0 5
45181: PUSH
45182: LD_INT 1
45184: ARRAY
45185: PUSH
45186: LD_VAR 0 7
45190: PUSH
45191: LD_INT 1
45193: ARRAY
45194: PUSH
45195: LD_VAR 0 7
45199: PUSH
45200: LD_INT 2
45202: ARRAY
45203: PUSH
45204: LD_VAR 0 7
45208: PUSH
45209: LD_INT 3
45211: ARRAY
45212: PUSH
45213: EMPTY
45214: LIST
45215: LIST
45216: LIST
45217: LIST
45218: PPUSH
45219: CALL_OW 2
45223: PPUSH
45224: CALL_OW 1
45228: ST_TO_ADDR
// ext_list := Delete ( ext_list , 1 ) ;
45229: LD_ADDR_VAR 0 5
45233: PUSH
45234: LD_VAR 0 5
45238: PPUSH
45239: LD_INT 1
45241: PPUSH
45242: CALL_OW 3
45246: ST_TO_ADDR
// if not ext_list then
45247: LD_VAR 0 5
45251: NOT
45252: IFFALSE 45258
// exit ;
45254: POP
45255: POP
45256: GO 45262
// end ;
45258: GO 45133
45260: POP
45261: POP
// end ;
45262: LD_VAR 0 6
45266: RET
// export function MC_SetAllowedTurretWeapons ( base , weapon_list ) ; begin
45267: LD_INT 0
45269: PPUSH
// if not mc_bases or not base or not weapon_list then
45270: LD_EXP 76
45274: NOT
45275: PUSH
45276: LD_VAR 0 1
45280: NOT
45281: OR
45282: PUSH
45283: LD_VAR 0 2
45287: NOT
45288: OR
45289: IFFALSE 45293
// exit ;
45291: GO 45318
// mc_allowed_tower_weapons := Replace ( mc_allowed_tower_weapons , base , weapon_list ) ;
45293: LD_ADDR_EXP 115
45297: PUSH
45298: LD_EXP 115
45302: PPUSH
45303: LD_VAR 0 1
45307: PPUSH
45308: LD_VAR 0 2
45312: PPUSH
45313: CALL_OW 1
45317: ST_TO_ADDR
// end ;
45318: LD_VAR 0 3
45322: RET
// export function MC_SetTechList ( base , tech_list ) ; begin
45323: LD_INT 0
45325: PPUSH
// if not mc_bases or not base or not tech_list then
45326: LD_EXP 76
45330: NOT
45331: PUSH
45332: LD_VAR 0 1
45336: NOT
45337: OR
45338: PUSH
45339: LD_VAR 0 2
45343: NOT
45344: OR
45345: IFFALSE 45349
// exit ;
45347: GO 45374
// mc_tech := Replace ( mc_tech , base , tech_list ) ;
45349: LD_ADDR_EXP 103
45353: PUSH
45354: LD_EXP 103
45358: PPUSH
45359: LD_VAR 0 1
45363: PPUSH
45364: LD_VAR 0 2
45368: PPUSH
45369: CALL_OW 1
45373: ST_TO_ADDR
// end ;
45374: LD_VAR 0 3
45378: RET
// export function MC_SetParkingArea ( base , parking_area ) ; begin
45379: LD_INT 0
45381: PPUSH
// if not mc_bases or not parking_area or not base then
45382: LD_EXP 76
45386: NOT
45387: PUSH
45388: LD_VAR 0 2
45392: NOT
45393: OR
45394: PUSH
45395: LD_VAR 0 1
45399: NOT
45400: OR
45401: IFFALSE 45405
// exit ;
45403: GO 45430
// mc_parking := Replace ( mc_parking , base , parking_area ) ;
45405: LD_ADDR_EXP 100
45409: PUSH
45410: LD_EXP 100
45414: PPUSH
45415: LD_VAR 0 1
45419: PPUSH
45420: LD_VAR 0 2
45424: PPUSH
45425: CALL_OW 1
45429: ST_TO_ADDR
// end ;
45430: LD_VAR 0 3
45434: RET
// export function MC_SetScanArea ( base , scan_area ) ; begin
45435: LD_INT 0
45437: PPUSH
// if not mc_bases or not base or not scan_area then
45438: LD_EXP 76
45442: NOT
45443: PUSH
45444: LD_VAR 0 1
45448: NOT
45449: OR
45450: PUSH
45451: LD_VAR 0 2
45455: NOT
45456: OR
45457: IFFALSE 45461
// exit ;
45459: GO 45486
// mc_scan_area := Replace ( mc_scan_area , base , scan_area ) ;
45461: LD_ADDR_EXP 101
45465: PUSH
45466: LD_EXP 101
45470: PPUSH
45471: LD_VAR 0 1
45475: PPUSH
45476: LD_VAR 0 2
45480: PPUSH
45481: CALL_OW 1
45485: ST_TO_ADDR
// end ;
45486: LD_VAR 0 3
45490: RET
// export function MC_NotTameApeman ( base ) ; var ape_techs ; begin
45491: LD_INT 0
45493: PPUSH
45494: PPUSH
// if not mc_bases or not base then
45495: LD_EXP 76
45499: NOT
45500: PUSH
45501: LD_VAR 0 1
45505: NOT
45506: OR
45507: IFFALSE 45511
// exit ;
45509: GO 45575
// ape_techs := [ 1 , 2 , 3 , 4 , 11 ] ;
45511: LD_ADDR_VAR 0 3
45515: PUSH
45516: LD_INT 1
45518: PUSH
45519: LD_INT 2
45521: PUSH
45522: LD_INT 3
45524: PUSH
45525: LD_INT 4
45527: PUSH
45528: LD_INT 11
45530: PUSH
45531: EMPTY
45532: LIST
45533: LIST
45534: LIST
45535: LIST
45536: LIST
45537: ST_TO_ADDR
// mc_tech := Replace ( mc_tech , base , mc_tech [ base ] diff ape_techs ) ;
45538: LD_ADDR_EXP 103
45542: PUSH
45543: LD_EXP 103
45547: PPUSH
45548: LD_VAR 0 1
45552: PPUSH
45553: LD_EXP 103
45557: PUSH
45558: LD_VAR 0 1
45562: ARRAY
45563: PUSH
45564: LD_VAR 0 3
45568: DIFF
45569: PPUSH
45570: CALL_OW 1
45574: ST_TO_ADDR
// end ;
45575: LD_VAR 0 2
45579: RET
// export function MC_GetVehicles ( base , onlyCombat ) ; begin
45580: LD_INT 0
45582: PPUSH
// result := mc_vehicles [ base ] ;
45583: LD_ADDR_VAR 0 3
45587: PUSH
45588: LD_EXP 95
45592: PUSH
45593: LD_VAR 0 1
45597: ARRAY
45598: ST_TO_ADDR
// if onlyCombat then
45599: LD_VAR 0 2
45603: IFFALSE 45768
// result := result diff UnitFilter ( result , [ f_or , [ f_weapon , us_cargo_bay ] , [ f_weapon , ru_cargo_bay ] , [ f_weapon , ru_big_cargo_bay ] , [ f_weapon , ar_cargo_bay ] , [ f_weapon , us_crane ] , [ f_weapon , ru_crane ] , [ f_weapon , us_bulldozer ] , [ f_weapon , ru_bulldozer ] , [ f_weapon , ru_radar ] , [ f_weapon , ar_control_tower ] , [ f_weapon , ru_siberium_rocket ] , [ f_weapon , us_siberium_rocket ] ] ) ;
45605: LD_ADDR_VAR 0 3
45609: PUSH
45610: LD_VAR 0 3
45614: PUSH
45615: LD_VAR 0 3
45619: PPUSH
45620: LD_INT 2
45622: PUSH
45623: LD_INT 34
45625: PUSH
45626: LD_INT 12
45628: PUSH
45629: EMPTY
45630: LIST
45631: LIST
45632: PUSH
45633: LD_INT 34
45635: PUSH
45636: LD_INT 51
45638: PUSH
45639: EMPTY
45640: LIST
45641: LIST
45642: PUSH
45643: LD_INT 34
45645: PUSH
45646: LD_EXP 70
45650: PUSH
45651: EMPTY
45652: LIST
45653: LIST
45654: PUSH
45655: LD_INT 34
45657: PUSH
45658: LD_INT 32
45660: PUSH
45661: EMPTY
45662: LIST
45663: LIST
45664: PUSH
45665: LD_INT 34
45667: PUSH
45668: LD_INT 13
45670: PUSH
45671: EMPTY
45672: LIST
45673: LIST
45674: PUSH
45675: LD_INT 34
45677: PUSH
45678: LD_INT 52
45680: PUSH
45681: EMPTY
45682: LIST
45683: LIST
45684: PUSH
45685: LD_INT 34
45687: PUSH
45688: LD_INT 14
45690: PUSH
45691: EMPTY
45692: LIST
45693: LIST
45694: PUSH
45695: LD_INT 34
45697: PUSH
45698: LD_INT 53
45700: PUSH
45701: EMPTY
45702: LIST
45703: LIST
45704: PUSH
45705: LD_INT 34
45707: PUSH
45708: LD_EXP 69
45712: PUSH
45713: EMPTY
45714: LIST
45715: LIST
45716: PUSH
45717: LD_INT 34
45719: PUSH
45720: LD_INT 31
45722: PUSH
45723: EMPTY
45724: LIST
45725: LIST
45726: PUSH
45727: LD_INT 34
45729: PUSH
45730: LD_INT 48
45732: PUSH
45733: EMPTY
45734: LIST
45735: LIST
45736: PUSH
45737: LD_INT 34
45739: PUSH
45740: LD_INT 8
45742: PUSH
45743: EMPTY
45744: LIST
45745: LIST
45746: PUSH
45747: EMPTY
45748: LIST
45749: LIST
45750: LIST
45751: LIST
45752: LIST
45753: LIST
45754: LIST
45755: LIST
45756: LIST
45757: LIST
45758: LIST
45759: LIST
45760: LIST
45761: PPUSH
45762: CALL_OW 72
45766: DIFF
45767: ST_TO_ADDR
// end ; end_of_file
45768: LD_VAR 0 3
45772: RET
// export function MCE_ApemanTamed ( ape , sci ) ; var i , tmp ; begin
45773: LD_INT 0
45775: PPUSH
45776: PPUSH
45777: PPUSH
// if not mc_bases or not skirmish then
45778: LD_EXP 76
45782: NOT
45783: PUSH
45784: LD_EXP 74
45788: NOT
45789: OR
45790: IFFALSE 45794
// exit ;
45792: GO 45959
// for i = 1 to mc_bases do
45794: LD_ADDR_VAR 0 4
45798: PUSH
45799: DOUBLE
45800: LD_INT 1
45802: DEC
45803: ST_TO_ADDR
45804: LD_EXP 76
45808: PUSH
45809: FOR_TO
45810: IFFALSE 45957
// begin if sci in mc_bases [ i ] then
45812: LD_VAR 0 2
45816: PUSH
45817: LD_EXP 76
45821: PUSH
45822: LD_VAR 0 4
45826: ARRAY
45827: IN
45828: IFFALSE 45955
// begin mc_ape := ReplaceIn ( mc_ape , [ i , mc_ape [ i ] + 1 ] , ape ) ;
45830: LD_ADDR_EXP 105
45834: PUSH
45835: LD_EXP 105
45839: PPUSH
45840: LD_VAR 0 4
45844: PUSH
45845: LD_EXP 105
45849: PUSH
45850: LD_VAR 0 4
45854: ARRAY
45855: PUSH
45856: LD_INT 1
45858: PLUS
45859: PUSH
45860: EMPTY
45861: LIST
45862: LIST
45863: PPUSH
45864: LD_VAR 0 1
45868: PPUSH
45869: CALL 57743 0 3
45873: ST_TO_ADDR
// tmp := NearestUnitToUnit ( UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) , ape ) ;
45874: LD_ADDR_VAR 0 5
45878: PUSH
45879: LD_EXP 76
45883: PUSH
45884: LD_VAR 0 4
45888: ARRAY
45889: PPUSH
45890: LD_INT 2
45892: PUSH
45893: LD_INT 30
45895: PUSH
45896: LD_INT 0
45898: PUSH
45899: EMPTY
45900: LIST
45901: LIST
45902: PUSH
45903: LD_INT 30
45905: PUSH
45906: LD_INT 1
45908: PUSH
45909: EMPTY
45910: LIST
45911: LIST
45912: PUSH
45913: EMPTY
45914: LIST
45915: LIST
45916: LIST
45917: PPUSH
45918: CALL_OW 72
45922: PPUSH
45923: LD_VAR 0 1
45927: PPUSH
45928: CALL_OW 74
45932: ST_TO_ADDR
// if tmp then
45933: LD_VAR 0 5
45937: IFFALSE 45953
// ComStandNearbyBuilding ( ape , tmp ) ;
45939: LD_VAR 0 1
45943: PPUSH
45944: LD_VAR 0 5
45948: PPUSH
45949: CALL 51946 0 2
// break ;
45953: GO 45957
// end ; end ;
45955: GO 45809
45957: POP
45958: POP
// end ;
45959: LD_VAR 0 3
45963: RET
// export function MCE_EnterBuilding ( building , unit ) ; var i , tmp ; begin
45964: LD_INT 0
45966: PPUSH
45967: PPUSH
45968: PPUSH
// if not mc_bases or not skirmish then
45969: LD_EXP 76
45973: NOT
45974: PUSH
45975: LD_EXP 74
45979: NOT
45980: OR
45981: IFFALSE 45985
// exit ;
45983: GO 46074
// for i = 1 to mc_bases do
45985: LD_ADDR_VAR 0 4
45989: PUSH
45990: DOUBLE
45991: LD_INT 1
45993: DEC
45994: ST_TO_ADDR
45995: LD_EXP 76
45999: PUSH
46000: FOR_TO
46001: IFFALSE 46072
// begin if building in mc_busy_turret_list [ i ] then
46003: LD_VAR 0 1
46007: PUSH
46008: LD_EXP 86
46012: PUSH
46013: LD_VAR 0 4
46017: ARRAY
46018: IN
46019: IFFALSE 46070
// begin tmp := mc_busy_turret_list [ i ] diff building ;
46021: LD_ADDR_VAR 0 5
46025: PUSH
46026: LD_EXP 86
46030: PUSH
46031: LD_VAR 0 4
46035: ARRAY
46036: PUSH
46037: LD_VAR 0 1
46041: DIFF
46042: ST_TO_ADDR
// mc_busy_turret_list := Replace ( mc_busy_turret_list , i , tmp ) ;
46043: LD_ADDR_EXP 86
46047: PUSH
46048: LD_EXP 86
46052: PPUSH
46053: LD_VAR 0 4
46057: PPUSH
46058: LD_VAR 0 5
46062: PPUSH
46063: CALL_OW 1
46067: ST_TO_ADDR
// break ;
46068: GO 46072
// end ; end ;
46070: GO 46000
46072: POP
46073: POP
// end ;
46074: LD_VAR 0 3
46078: RET
// export function MCE_BuildingCaptured ( building , side , capturning_unit ) ; var i , tmp ; begin
46079: LD_INT 0
46081: PPUSH
46082: PPUSH
46083: PPUSH
// if not mc_bases or not skirmish then
46084: LD_EXP 76
46088: NOT
46089: PUSH
46090: LD_EXP 74
46094: NOT
46095: OR
46096: IFFALSE 46100
// exit ;
46098: GO 46299
// for i = 1 to mc_bases do
46100: LD_ADDR_VAR 0 5
46104: PUSH
46105: DOUBLE
46106: LD_INT 1
46108: DEC
46109: ST_TO_ADDR
46110: LD_EXP 76
46114: PUSH
46115: FOR_TO
46116: IFFALSE 46297
// if building in mc_bases [ i ] then
46118: LD_VAR 0 1
46122: PUSH
46123: LD_EXP 76
46127: PUSH
46128: LD_VAR 0 5
46132: ARRAY
46133: IN
46134: IFFALSE 46295
// begin tmp := mc_bases [ i ] diff building ;
46136: LD_ADDR_VAR 0 6
46140: PUSH
46141: LD_EXP 76
46145: PUSH
46146: LD_VAR 0 5
46150: ARRAY
46151: PUSH
46152: LD_VAR 0 1
46156: DIFF
46157: ST_TO_ADDR
// mc_bases := Replace ( mc_bases , i , tmp ) ;
46158: LD_ADDR_EXP 76
46162: PUSH
46163: LD_EXP 76
46167: PPUSH
46168: LD_VAR 0 5
46172: PPUSH
46173: LD_VAR 0 6
46177: PPUSH
46178: CALL_OW 1
46182: ST_TO_ADDR
// if building in mc_turret_list [ i ] then
46183: LD_VAR 0 1
46187: PUSH
46188: LD_EXP 84
46192: PUSH
46193: LD_VAR 0 5
46197: ARRAY
46198: IN
46199: IFFALSE 46238
// mc_turret_list := Replace ( mc_turret_list , i , mc_turret_list [ i ] diff building ) ;
46201: LD_ADDR_EXP 84
46205: PUSH
46206: LD_EXP 84
46210: PPUSH
46211: LD_VAR 0 5
46215: PPUSH
46216: LD_EXP 84
46220: PUSH
46221: LD_VAR 0 5
46225: ARRAY
46226: PUSH
46227: LD_VAR 0 1
46231: DIFF
46232: PPUSH
46233: CALL_OW 1
46237: ST_TO_ADDR
// if building in mc_empty_turret_list [ i ] then
46238: LD_VAR 0 1
46242: PUSH
46243: LD_EXP 85
46247: PUSH
46248: LD_VAR 0 5
46252: ARRAY
46253: IN
46254: IFFALSE 46293
// mc_empty_turret_list := Replace ( mc_empty_turret_list , i , mc_empty_turret_list [ i ] diff building ) ;
46256: LD_ADDR_EXP 85
46260: PUSH
46261: LD_EXP 85
46265: PPUSH
46266: LD_VAR 0 5
46270: PPUSH
46271: LD_EXP 85
46275: PUSH
46276: LD_VAR 0 5
46280: ARRAY
46281: PUSH
46282: LD_VAR 0 1
46286: DIFF
46287: PPUSH
46288: CALL_OW 1
46292: ST_TO_ADDR
// break ;
46293: GO 46297
// end ;
46295: GO 46115
46297: POP
46298: POP
// end ;
46299: LD_VAR 0 4
46303: RET
// export function MCE_VehicleCaptured ( new , old , side , capturing_unit ) ; var i , tmp ; begin
46304: LD_INT 0
46306: PPUSH
46307: PPUSH
46308: PPUSH
// if not mc_bases or not skirmish or not side in mc_sides then
46309: LD_EXP 76
46313: NOT
46314: PUSH
46315: LD_EXP 74
46319: NOT
46320: OR
46321: PUSH
46322: LD_VAR 0 3
46326: PUSH
46327: LD_EXP 102
46331: IN
46332: NOT
46333: OR
46334: IFFALSE 46338
// exit ;
46336: GO 46461
// for i = 1 to mc_vehicles do
46338: LD_ADDR_VAR 0 6
46342: PUSH
46343: DOUBLE
46344: LD_INT 1
46346: DEC
46347: ST_TO_ADDR
46348: LD_EXP 95
46352: PUSH
46353: FOR_TO
46354: IFFALSE 46459
// if old in mc_vehicles [ i ] or new in mc_vehicles [ i ] then
46356: LD_VAR 0 2
46360: PUSH
46361: LD_EXP 95
46365: PUSH
46366: LD_VAR 0 6
46370: ARRAY
46371: IN
46372: PUSH
46373: LD_VAR 0 1
46377: PUSH
46378: LD_EXP 95
46382: PUSH
46383: LD_VAR 0 6
46387: ARRAY
46388: IN
46389: OR
46390: IFFALSE 46457
// begin tmp := mc_vehicles [ i ] diff old ;
46392: LD_ADDR_VAR 0 7
46396: PUSH
46397: LD_EXP 95
46401: PUSH
46402: LD_VAR 0 6
46406: ARRAY
46407: PUSH
46408: LD_VAR 0 2
46412: DIFF
46413: ST_TO_ADDR
// tmp := tmp diff new ;
46414: LD_ADDR_VAR 0 7
46418: PUSH
46419: LD_VAR 0 7
46423: PUSH
46424: LD_VAR 0 1
46428: DIFF
46429: ST_TO_ADDR
// mc_vehicles := Replace ( mc_vehicles , i , tmp ) ;
46430: LD_ADDR_EXP 95
46434: PUSH
46435: LD_EXP 95
46439: PPUSH
46440: LD_VAR 0 6
46444: PPUSH
46445: LD_VAR 0 7
46449: PPUSH
46450: CALL_OW 1
46454: ST_TO_ADDR
// break ;
46455: GO 46459
// end ;
46457: GO 46353
46459: POP
46460: POP
// end ;
46461: LD_VAR 0 5
46465: RET
// export function MCE_VehicleConstructed ( vehicle , factory ) ; var i , side , tmp ; begin
46466: LD_INT 0
46468: PPUSH
46469: PPUSH
46470: PPUSH
46471: PPUSH
// if not mc_bases or not skirmish then
46472: LD_EXP 76
46476: NOT
46477: PUSH
46478: LD_EXP 74
46482: NOT
46483: OR
46484: IFFALSE 46488
// exit ;
46486: GO 46865
// side := GetSide ( vehicle ) ;
46488: LD_ADDR_VAR 0 5
46492: PUSH
46493: LD_VAR 0 1
46497: PPUSH
46498: CALL_OW 255
46502: ST_TO_ADDR
// for i = 1 to mc_bases do
46503: LD_ADDR_VAR 0 4
46507: PUSH
46508: DOUBLE
46509: LD_INT 1
46511: DEC
46512: ST_TO_ADDR
46513: LD_EXP 76
46517: PUSH
46518: FOR_TO
46519: IFFALSE 46863
// begin if factory in mc_bases [ i ] then
46521: LD_VAR 0 2
46525: PUSH
46526: LD_EXP 76
46530: PUSH
46531: LD_VAR 0 4
46535: ARRAY
46536: IN
46537: IFFALSE 46861
// begin if mc_defender [ i ] < mc_defender_limit [ i ] and not GetWeapon ( vehicle ) in [ ar_control_tower , ar_cargo_bay , ru_cargo_bay , ru_big_cargo_bay , us_cargo_bay , ar_radar , ru_radar , us_radar , ru_bulldozer , us_bulldozer , ar_bio_bomb , ar_selfpropelled_bomb , us_hack , us_crane , ru_crane , ru_siberium_rocket , us_siberium_rocket ] then
46539: LD_EXP 98
46543: PUSH
46544: LD_VAR 0 4
46548: ARRAY
46549: PUSH
46550: LD_EXP 87
46554: PUSH
46555: LD_VAR 0 4
46559: ARRAY
46560: LESS
46561: PUSH
46562: LD_VAR 0 1
46566: PPUSH
46567: CALL_OW 264
46571: PUSH
46572: LD_INT 31
46574: PUSH
46575: LD_INT 32
46577: PUSH
46578: LD_INT 51
46580: PUSH
46581: LD_EXP 70
46585: PUSH
46586: LD_INT 12
46588: PUSH
46589: LD_INT 30
46591: PUSH
46592: LD_EXP 69
46596: PUSH
46597: LD_INT 11
46599: PUSH
46600: LD_INT 53
46602: PUSH
46603: LD_INT 14
46605: PUSH
46606: LD_EXP 73
46610: PUSH
46611: LD_INT 29
46613: PUSH
46614: LD_EXP 71
46618: PUSH
46619: LD_INT 13
46621: PUSH
46622: LD_INT 52
46624: PUSH
46625: LD_INT 48
46627: PUSH
46628: LD_INT 8
46630: PUSH
46631: EMPTY
46632: LIST
46633: LIST
46634: LIST
46635: LIST
46636: LIST
46637: LIST
46638: LIST
46639: LIST
46640: LIST
46641: LIST
46642: LIST
46643: LIST
46644: LIST
46645: LIST
46646: LIST
46647: LIST
46648: LIST
46649: IN
46650: NOT
46651: AND
46652: IFFALSE 46700
// mc_defender := ReplaceIn ( mc_defender , [ i , mc_defender [ i ] + 1 ] , vehicle ) else
46654: LD_ADDR_EXP 98
46658: PUSH
46659: LD_EXP 98
46663: PPUSH
46664: LD_VAR 0 4
46668: PUSH
46669: LD_EXP 98
46673: PUSH
46674: LD_VAR 0 4
46678: ARRAY
46679: PUSH
46680: LD_INT 1
46682: PLUS
46683: PUSH
46684: EMPTY
46685: LIST
46686: LIST
46687: PPUSH
46688: LD_VAR 0 1
46692: PPUSH
46693: CALL 57743 0 3
46697: ST_TO_ADDR
46698: GO 46744
// mc_vehicles := ReplaceIn ( mc_vehicles , [ i , mc_vehicles [ i ] + 1 ] , vehicle ) ;
46700: LD_ADDR_EXP 95
46704: PUSH
46705: LD_EXP 95
46709: PPUSH
46710: LD_VAR 0 4
46714: PUSH
46715: LD_EXP 95
46719: PUSH
46720: LD_VAR 0 4
46724: ARRAY
46725: PUSH
46726: LD_INT 1
46728: PLUS
46729: PUSH
46730: EMPTY
46731: LIST
46732: LIST
46733: PPUSH
46734: LD_VAR 0 1
46738: PPUSH
46739: CALL 57743 0 3
46743: ST_TO_ADDR
// if GetControl ( vehicle ) = control_remote then
46744: LD_VAR 0 1
46748: PPUSH
46749: CALL_OW 263
46753: PUSH
46754: LD_INT 2
46756: EQUAL
46757: IFFALSE 46777
// begin repeat wait ( 0 0$1 ) ;
46759: LD_INT 35
46761: PPUSH
46762: CALL_OW 67
// until IsControledBy ( vehicle ) ;
46766: LD_VAR 0 1
46770: PPUSH
46771: CALL_OW 312
46775: IFFALSE 46759
// end ; ComMoveToArea ( vehicle , mc_parking [ i ] ) ;
46777: LD_VAR 0 1
46781: PPUSH
46782: LD_EXP 100
46786: PUSH
46787: LD_VAR 0 4
46791: ARRAY
46792: PPUSH
46793: CALL_OW 113
// if GetControl ( vehicle ) <> control_manual then
46797: LD_VAR 0 1
46801: PPUSH
46802: CALL_OW 263
46806: PUSH
46807: LD_INT 1
46809: NONEQUAL
46810: IFFALSE 46814
// break ;
46812: GO 46863
// repeat wait ( 0 0$1 ) ;
46814: LD_INT 35
46816: PPUSH
46817: CALL_OW 67
// until IsInArea ( vehicle , mc_parking [ i ] ) ;
46821: LD_VAR 0 1
46825: PPUSH
46826: LD_EXP 100
46830: PUSH
46831: LD_VAR 0 4
46835: ARRAY
46836: PPUSH
46837: CALL_OW 308
46841: IFFALSE 46814
// ComExitVehicle ( IsDrivenBy ( vehicle ) ) ;
46843: LD_VAR 0 1
46847: PPUSH
46848: CALL_OW 311
46852: PPUSH
46853: CALL_OW 121
// exit ;
46857: POP
46858: POP
46859: GO 46865
// end ; end ;
46861: GO 46518
46863: POP
46864: POP
// end ;
46865: LD_VAR 0 3
46869: RET
// export function MCE_CrateSpawn ( id , x , y , amount , mode ) ; var i , j , depot ; begin
46870: LD_INT 0
46872: PPUSH
46873: PPUSH
46874: PPUSH
46875: PPUSH
// if not mc_bases or not skirmish then
46876: LD_EXP 76
46880: NOT
46881: PUSH
46882: LD_EXP 74
46886: NOT
46887: OR
46888: IFFALSE 46892
// exit ;
46890: GO 47245
// repeat wait ( 0 0$1 ) ;
46892: LD_INT 35
46894: PPUSH
46895: CALL_OW 67
// until GetResourceAmountXY ( x , y ) ;
46899: LD_VAR 0 2
46903: PPUSH
46904: LD_VAR 0 3
46908: PPUSH
46909: CALL_OW 284
46913: IFFALSE 46892
// if GetResourceTypeXY ( x , y ) = mat_artefact then
46915: LD_VAR 0 2
46919: PPUSH
46920: LD_VAR 0 3
46924: PPUSH
46925: CALL_OW 283
46929: PUSH
46930: LD_INT 4
46932: EQUAL
46933: IFFALSE 46937
// exit ;
46935: GO 47245
// for i = 1 to mc_bases do
46937: LD_ADDR_VAR 0 7
46941: PUSH
46942: DOUBLE
46943: LD_INT 1
46945: DEC
46946: ST_TO_ADDR
46947: LD_EXP 76
46951: PUSH
46952: FOR_TO
46953: IFFALSE 47243
// begin if mc_crates_area [ i ] then
46955: LD_EXP 94
46959: PUSH
46960: LD_VAR 0 7
46964: ARRAY
46965: IFFALSE 47076
// for j in mc_crates_area [ i ] do
46967: LD_ADDR_VAR 0 8
46971: PUSH
46972: LD_EXP 94
46976: PUSH
46977: LD_VAR 0 7
46981: ARRAY
46982: PUSH
46983: FOR_IN
46984: IFFALSE 47074
// if InArea ( x , y , j ) then
46986: LD_VAR 0 2
46990: PPUSH
46991: LD_VAR 0 3
46995: PPUSH
46996: LD_VAR 0 8
47000: PPUSH
47001: CALL_OW 309
47005: IFFALSE 47072
// begin mc_crates := ReplaceIn ( mc_crates , [ i , mc_crates [ i ] + 1 ] , [ amount , x , y ] ) ;
47007: LD_ADDR_EXP 92
47011: PUSH
47012: LD_EXP 92
47016: PPUSH
47017: LD_VAR 0 7
47021: PUSH
47022: LD_EXP 92
47026: PUSH
47027: LD_VAR 0 7
47031: ARRAY
47032: PUSH
47033: LD_INT 1
47035: PLUS
47036: PUSH
47037: EMPTY
47038: LIST
47039: LIST
47040: PPUSH
47041: LD_VAR 0 4
47045: PUSH
47046: LD_VAR 0 2
47050: PUSH
47051: LD_VAR 0 3
47055: PUSH
47056: EMPTY
47057: LIST
47058: LIST
47059: LIST
47060: PPUSH
47061: CALL 57743 0 3
47065: ST_TO_ADDR
// exit ;
47066: POP
47067: POP
47068: POP
47069: POP
47070: GO 47245
// end ;
47072: GO 46983
47074: POP
47075: POP
// depot := UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) ;
47076: LD_ADDR_VAR 0 9
47080: PUSH
47081: LD_EXP 76
47085: PUSH
47086: LD_VAR 0 7
47090: ARRAY
47091: PPUSH
47092: LD_INT 2
47094: PUSH
47095: LD_INT 30
47097: PUSH
47098: LD_INT 0
47100: PUSH
47101: EMPTY
47102: LIST
47103: LIST
47104: PUSH
47105: LD_INT 30
47107: PUSH
47108: LD_INT 1
47110: PUSH
47111: EMPTY
47112: LIST
47113: LIST
47114: PUSH
47115: EMPTY
47116: LIST
47117: LIST
47118: LIST
47119: PPUSH
47120: CALL_OW 72
47124: ST_TO_ADDR
// if not depot then
47125: LD_VAR 0 9
47129: NOT
47130: IFFALSE 47134
// continue ;
47132: GO 46952
// for j in depot do
47134: LD_ADDR_VAR 0 8
47138: PUSH
47139: LD_VAR 0 9
47143: PUSH
47144: FOR_IN
47145: IFFALSE 47239
// if GetDistUnitXY ( j , x , y ) < 30 then
47147: LD_VAR 0 8
47151: PPUSH
47152: LD_VAR 0 2
47156: PPUSH
47157: LD_VAR 0 3
47161: PPUSH
47162: CALL_OW 297
47166: PUSH
47167: LD_INT 30
47169: LESS
47170: IFFALSE 47237
// begin mc_crates := ReplaceIn ( mc_crates , [ i , mc_crates [ i ] + 1 ] , [ amount , x , y ] ) ;
47172: LD_ADDR_EXP 92
47176: PUSH
47177: LD_EXP 92
47181: PPUSH
47182: LD_VAR 0 7
47186: PUSH
47187: LD_EXP 92
47191: PUSH
47192: LD_VAR 0 7
47196: ARRAY
47197: PUSH
47198: LD_INT 1
47200: PLUS
47201: PUSH
47202: EMPTY
47203: LIST
47204: LIST
47205: PPUSH
47206: LD_VAR 0 4
47210: PUSH
47211: LD_VAR 0 2
47215: PUSH
47216: LD_VAR 0 3
47220: PUSH
47221: EMPTY
47222: LIST
47223: LIST
47224: LIST
47225: PPUSH
47226: CALL 57743 0 3
47230: ST_TO_ADDR
// exit ;
47231: POP
47232: POP
47233: POP
47234: POP
47235: GO 47245
// end ;
47237: GO 47144
47239: POP
47240: POP
// end ;
47241: GO 46952
47243: POP
47244: POP
// end ;
47245: LD_VAR 0 6
47249: RET
// export function MCE_ResearchComplete ( tech , lab ) ; var side , i , tmp ; begin
47250: LD_INT 0
47252: PPUSH
47253: PPUSH
47254: PPUSH
47255: PPUSH
// if not mc_bases or not skirmish then
47256: LD_EXP 76
47260: NOT
47261: PUSH
47262: LD_EXP 74
47266: NOT
47267: OR
47268: IFFALSE 47272
// exit ;
47270: GO 47549
// side := GetSide ( lab ) ;
47272: LD_ADDR_VAR 0 4
47276: PUSH
47277: LD_VAR 0 2
47281: PPUSH
47282: CALL_OW 255
47286: ST_TO_ADDR
// if not side in mc_sides or not mc_tech or not mc_bases then
47287: LD_VAR 0 4
47291: PUSH
47292: LD_EXP 102
47296: IN
47297: NOT
47298: PUSH
47299: LD_EXP 103
47303: NOT
47304: OR
47305: PUSH
47306: LD_EXP 76
47310: NOT
47311: OR
47312: IFFALSE 47316
// exit ;
47314: GO 47549
// mc_tech := Replace ( mc_tech , side , mc_tech [ side ] diff tech ) ;
47316: LD_ADDR_EXP 103
47320: PUSH
47321: LD_EXP 103
47325: PPUSH
47326: LD_VAR 0 4
47330: PPUSH
47331: LD_EXP 103
47335: PUSH
47336: LD_VAR 0 4
47340: ARRAY
47341: PUSH
47342: LD_VAR 0 1
47346: DIFF
47347: PPUSH
47348: CALL_OW 1
47352: ST_TO_ADDR
// for i = 1 to mc_bases do
47353: LD_ADDR_VAR 0 5
47357: PUSH
47358: DOUBLE
47359: LD_INT 1
47361: DEC
47362: ST_TO_ADDR
47363: LD_EXP 76
47367: PUSH
47368: FOR_TO
47369: IFFALSE 47547
// begin if lab in mc_bases [ i ] then
47371: LD_VAR 0 2
47375: PUSH
47376: LD_EXP 76
47380: PUSH
47381: LD_VAR 0 5
47385: ARRAY
47386: IN
47387: IFFALSE 47545
// begin if tech in [ tech_apeagres , tech_apebrain , tech_apeneural , tech_apepsych ] and mc_ape_in_lab [ i ] then
47389: LD_VAR 0 1
47393: PUSH
47394: LD_INT 11
47396: PUSH
47397: LD_INT 4
47399: PUSH
47400: LD_INT 3
47402: PUSH
47403: LD_INT 2
47405: PUSH
47406: EMPTY
47407: LIST
47408: LIST
47409: LIST
47410: LIST
47411: IN
47412: PUSH
47413: LD_EXP 106
47417: PUSH
47418: LD_VAR 0 5
47422: ARRAY
47423: AND
47424: IFFALSE 47545
// begin tmp := mc_ape_in_lab [ i ] [ 1 ] ;
47426: LD_ADDR_VAR 0 6
47430: PUSH
47431: LD_EXP 106
47435: PUSH
47436: LD_VAR 0 5
47440: ARRAY
47441: PUSH
47442: LD_INT 1
47444: ARRAY
47445: ST_TO_ADDR
// mc_ape_in_lab := Replace ( mc_ape_in_lab , i , [ ] ) ;
47446: LD_ADDR_EXP 106
47450: PUSH
47451: LD_EXP 106
47455: PPUSH
47456: LD_VAR 0 5
47460: PPUSH
47461: EMPTY
47462: PPUSH
47463: CALL_OW 1
47467: ST_TO_ADDR
// SetTag ( tmp , 0 ) ;
47468: LD_VAR 0 6
47472: PPUSH
47473: LD_INT 0
47475: PPUSH
47476: CALL_OW 109
// ComExitBuilding ( tmp ) ;
47480: LD_VAR 0 6
47484: PPUSH
47485: CALL_OW 122
// mc_ape := Replace ( mc_ape , i , Insert ( mc_ape [ i ] , 1 , tmp ) ) ;
47489: LD_ADDR_EXP 105
47493: PUSH
47494: LD_EXP 105
47498: PPUSH
47499: LD_VAR 0 5
47503: PPUSH
47504: LD_EXP 105
47508: PUSH
47509: LD_VAR 0 5
47513: ARRAY
47514: PPUSH
47515: LD_INT 1
47517: PPUSH
47518: LD_VAR 0 6
47522: PPUSH
47523: CALL_OW 2
47527: PPUSH
47528: CALL_OW 1
47532: ST_TO_ADDR
// MC_Reset ( i , 112 ) ;
47533: LD_VAR 0 5
47537: PPUSH
47538: LD_INT 112
47540: PPUSH
47541: CALL 24545 0 2
// end ; end ; end ;
47545: GO 47368
47547: POP
47548: POP
// end ;
47549: LD_VAR 0 3
47553: RET
// export function MCE_UnitDestroyed ( un ) ; var i , j , btype , pos , tmp , fac , components ; begin
47554: LD_INT 0
47556: PPUSH
47557: PPUSH
47558: PPUSH
47559: PPUSH
47560: PPUSH
47561: PPUSH
47562: PPUSH
47563: PPUSH
// if not mc_bases or not skirmish then
47564: LD_EXP 76
47568: NOT
47569: PUSH
47570: LD_EXP 74
47574: NOT
47575: OR
47576: IFFALSE 47580
// exit ;
47578: GO 48951
// for i = 1 to mc_bases do
47580: LD_ADDR_VAR 0 3
47584: PUSH
47585: DOUBLE
47586: LD_INT 1
47588: DEC
47589: ST_TO_ADDR
47590: LD_EXP 76
47594: PUSH
47595: FOR_TO
47596: IFFALSE 48949
// if un in mc_bases [ i ] or un in mc_construct_list [ i ] or un in mc_defender [ i ] or un in mc_vehicles [ i ] or un in mc_ape [ i ] or un in mc_ape_in_lab [ i ] then
47598: LD_VAR 0 1
47602: PUSH
47603: LD_EXP 76
47607: PUSH
47608: LD_VAR 0 3
47612: ARRAY
47613: IN
47614: PUSH
47615: LD_VAR 0 1
47619: PUSH
47620: LD_EXP 83
47624: PUSH
47625: LD_VAR 0 3
47629: ARRAY
47630: IN
47631: OR
47632: PUSH
47633: LD_VAR 0 1
47637: PUSH
47638: LD_EXP 98
47642: PUSH
47643: LD_VAR 0 3
47647: ARRAY
47648: IN
47649: OR
47650: PUSH
47651: LD_VAR 0 1
47655: PUSH
47656: LD_EXP 95
47660: PUSH
47661: LD_VAR 0 3
47665: ARRAY
47666: IN
47667: OR
47668: PUSH
47669: LD_VAR 0 1
47673: PUSH
47674: LD_EXP 105
47678: PUSH
47679: LD_VAR 0 3
47683: ARRAY
47684: IN
47685: OR
47686: PUSH
47687: LD_VAR 0 1
47691: PUSH
47692: LD_EXP 106
47696: PUSH
47697: LD_VAR 0 3
47701: ARRAY
47702: IN
47703: OR
47704: IFFALSE 48947
// begin if un in mc_ape [ i ] then
47706: LD_VAR 0 1
47710: PUSH
47711: LD_EXP 105
47715: PUSH
47716: LD_VAR 0 3
47720: ARRAY
47721: IN
47722: IFFALSE 47761
// begin mc_ape := Replace ( mc_ape , i , mc_ape [ i ] diff un ) ;
47724: LD_ADDR_EXP 105
47728: PUSH
47729: LD_EXP 105
47733: PPUSH
47734: LD_VAR 0 3
47738: PPUSH
47739: LD_EXP 105
47743: PUSH
47744: LD_VAR 0 3
47748: ARRAY
47749: PUSH
47750: LD_VAR 0 1
47754: DIFF
47755: PPUSH
47756: CALL_OW 1
47760: ST_TO_ADDR
// end ; if un in mc_ape_in_lab [ i ] then
47761: LD_VAR 0 1
47765: PUSH
47766: LD_EXP 106
47770: PUSH
47771: LD_VAR 0 3
47775: ARRAY
47776: IN
47777: IFFALSE 47801
// begin mc_ape_in_lab := Replace ( mc_ape_in_lab , i , [ ] ) ;
47779: LD_ADDR_EXP 106
47783: PUSH
47784: LD_EXP 106
47788: PPUSH
47789: LD_VAR 0 3
47793: PPUSH
47794: EMPTY
47795: PPUSH
47796: CALL_OW 1
47800: ST_TO_ADDR
// end ; if GetType ( un ) = unit_vehicle and ( GetTag ( un ) = 20 or un in mc_defender [ i ] or GetWeapon ( un ) in [ us_cargo_bay , ru_cargo_bay , ru_big_cargo_bay , ar_cargo_bay , us_crane , ru_crane , ar_control_tower ] ) then
47801: LD_VAR 0 1
47805: PPUSH
47806: CALL_OW 247
47810: PUSH
47811: LD_INT 2
47813: EQUAL
47814: PUSH
47815: LD_VAR 0 1
47819: PPUSH
47820: CALL_OW 110
47824: PUSH
47825: LD_INT 20
47827: EQUAL
47828: PUSH
47829: LD_VAR 0 1
47833: PUSH
47834: LD_EXP 98
47838: PUSH
47839: LD_VAR 0 3
47843: ARRAY
47844: IN
47845: OR
47846: PUSH
47847: LD_VAR 0 1
47851: PPUSH
47852: CALL_OW 264
47856: PUSH
47857: LD_INT 12
47859: PUSH
47860: LD_INT 51
47862: PUSH
47863: LD_EXP 70
47867: PUSH
47868: LD_INT 32
47870: PUSH
47871: LD_INT 13
47873: PUSH
47874: LD_INT 52
47876: PUSH
47877: LD_INT 31
47879: PUSH
47880: EMPTY
47881: LIST
47882: LIST
47883: LIST
47884: LIST
47885: LIST
47886: LIST
47887: LIST
47888: IN
47889: OR
47890: AND
47891: IFFALSE 48199
// begin if un in mc_defender [ i ] then
47893: LD_VAR 0 1
47897: PUSH
47898: LD_EXP 98
47902: PUSH
47903: LD_VAR 0 3
47907: ARRAY
47908: IN
47909: IFFALSE 47948
// mc_defender := Replace ( mc_defender , i , mc_defender [ i ] diff un ) ;
47911: LD_ADDR_EXP 98
47915: PUSH
47916: LD_EXP 98
47920: PPUSH
47921: LD_VAR 0 3
47925: PPUSH
47926: LD_EXP 98
47930: PUSH
47931: LD_VAR 0 3
47935: ARRAY
47936: PUSH
47937: LD_VAR 0 1
47941: DIFF
47942: PPUSH
47943: CALL_OW 1
47947: ST_TO_ADDR
// fac := MC_GetBuildings ( i , b_factory ) ;
47948: LD_ADDR_VAR 0 8
47952: PUSH
47953: LD_VAR 0 3
47957: PPUSH
47958: LD_INT 3
47960: PPUSH
47961: CALL 44617 0 2
47965: ST_TO_ADDR
// if fac then
47966: LD_VAR 0 8
47970: IFFALSE 48199
// begin for j in fac do
47972: LD_ADDR_VAR 0 4
47976: PUSH
47977: LD_VAR 0 8
47981: PUSH
47982: FOR_IN
47983: IFFALSE 48197
// begin components := Produce ( fac , GetChassis ( un ) , GetEngine ( un ) , GetControl ( un ) , GetWeapon ( un ) ) ;
47985: LD_ADDR_VAR 0 9
47989: PUSH
47990: LD_VAR 0 8
47994: PPUSH
47995: LD_VAR 0 1
47999: PPUSH
48000: CALL_OW 265
48004: PPUSH
48005: LD_VAR 0 1
48009: PPUSH
48010: CALL_OW 262
48014: PPUSH
48015: LD_VAR 0 1
48019: PPUSH
48020: CALL_OW 263
48024: PPUSH
48025: LD_VAR 0 1
48029: PPUSH
48030: CALL_OW 264
48034: PPUSH
48035: CALL 55275 0 5
48039: ST_TO_ADDR
// if components then
48040: LD_VAR 0 9
48044: IFFALSE 48195
// begin if GetWeapon ( un ) = ar_control_tower then
48046: LD_VAR 0 1
48050: PPUSH
48051: CALL_OW 264
48055: PUSH
48056: LD_INT 31
48058: EQUAL
48059: IFFALSE 48176
// begin SetTag ( IsDrivenBy ( un ) , 0 ) ;
48061: LD_VAR 0 1
48065: PPUSH
48066: CALL_OW 311
48070: PPUSH
48071: LD_INT 0
48073: PPUSH
48074: CALL_OW 109
// mc_remote_driver := Replace ( mc_remote_driver , i , mc_remote_driver [ i ] diff IsDrivenBy ( un ) ) ;
48078: LD_ADDR_EXP 116
48082: PUSH
48083: LD_EXP 116
48087: PPUSH
48088: LD_VAR 0 3
48092: PPUSH
48093: LD_EXP 116
48097: PUSH
48098: LD_VAR 0 3
48102: ARRAY
48103: PUSH
48104: LD_VAR 0 1
48108: PPUSH
48109: CALL_OW 311
48113: DIFF
48114: PPUSH
48115: CALL_OW 1
48119: ST_TO_ADDR
// tmp := Insert ( mc_produce [ i ] , 1 , components ) ;
48120: LD_ADDR_VAR 0 7
48124: PUSH
48125: LD_EXP 97
48129: PUSH
48130: LD_VAR 0 3
48134: ARRAY
48135: PPUSH
48136: LD_INT 1
48138: PPUSH
48139: LD_VAR 0 9
48143: PPUSH
48144: CALL_OW 2
48148: ST_TO_ADDR
// mc_produce := Replace ( mc_produce , i , tmp ) ;
48149: LD_ADDR_EXP 97
48153: PUSH
48154: LD_EXP 97
48158: PPUSH
48159: LD_VAR 0 3
48163: PPUSH
48164: LD_VAR 0 7
48168: PPUSH
48169: CALL_OW 1
48173: ST_TO_ADDR
// end else
48174: GO 48193
// MC_InsertProduceList ( i , [ components ] ) ;
48176: LD_VAR 0 3
48180: PPUSH
48181: LD_VAR 0 9
48185: PUSH
48186: EMPTY
48187: LIST
48188: PPUSH
48189: CALL 44162 0 2
// break ;
48193: GO 48197
// end ; end ;
48195: GO 47982
48197: POP
48198: POP
// end ; end ; if GetType ( un ) = unit_building then
48199: LD_VAR 0 1
48203: PPUSH
48204: CALL_OW 247
48208: PUSH
48209: LD_INT 3
48211: EQUAL
48212: IFFALSE 48615
// begin btype := GetBType ( un ) ;
48214: LD_ADDR_VAR 0 5
48218: PUSH
48219: LD_VAR 0 1
48223: PPUSH
48224: CALL_OW 266
48228: ST_TO_ADDR
// if btype in [ b_oil_mine , b_siberite_mine ] then
48229: LD_VAR 0 5
48233: PUSH
48234: LD_INT 29
48236: PUSH
48237: LD_INT 30
48239: PUSH
48240: EMPTY
48241: LIST
48242: LIST
48243: IN
48244: IFFALSE 48317
// begin if not GetResourceVisibility ( GetX ( un ) , GetY ( un ) , GetSide ( un ) ) then
48246: LD_VAR 0 1
48250: PPUSH
48251: CALL_OW 250
48255: PPUSH
48256: LD_VAR 0 1
48260: PPUSH
48261: CALL_OW 251
48265: PPUSH
48266: LD_VAR 0 1
48270: PPUSH
48271: CALL_OW 255
48275: PPUSH
48276: CALL_OW 440
48280: NOT
48281: IFFALSE 48317
// SetResourceVisibility ( GetX ( un ) , GetY ( un ) , GetSide ( un ) ) ;
48283: LD_VAR 0 1
48287: PPUSH
48288: CALL_OW 250
48292: PPUSH
48293: LD_VAR 0 1
48297: PPUSH
48298: CALL_OW 251
48302: PPUSH
48303: LD_VAR 0 1
48307: PPUSH
48308: CALL_OW 255
48312: PPUSH
48313: CALL_OW 441
// end ; if btype = b_warehouse then
48317: LD_VAR 0 5
48321: PUSH
48322: LD_INT 1
48324: EQUAL
48325: IFFALSE 48343
// begin btype := b_depot ;
48327: LD_ADDR_VAR 0 5
48331: PUSH
48332: LD_INT 0
48334: ST_TO_ADDR
// pos := 1 ;
48335: LD_ADDR_VAR 0 6
48339: PUSH
48340: LD_INT 1
48342: ST_TO_ADDR
// end ; if btype = b_factory then
48343: LD_VAR 0 5
48347: PUSH
48348: LD_INT 3
48350: EQUAL
48351: IFFALSE 48369
// begin btype := b_workshop ;
48353: LD_ADDR_VAR 0 5
48357: PUSH
48358: LD_INT 2
48360: ST_TO_ADDR
// pos := 1 ;
48361: LD_ADDR_VAR 0 6
48365: PUSH
48366: LD_INT 1
48368: ST_TO_ADDR
// end ; if btype = b_barracks then
48369: LD_VAR 0 5
48373: PUSH
48374: LD_INT 5
48376: EQUAL
48377: IFFALSE 48387
// btype := b_armoury ;
48379: LD_ADDR_VAR 0 5
48383: PUSH
48384: LD_INT 4
48386: ST_TO_ADDR
// if btype in [ b_lab_half , b_lab_full ] then
48387: LD_VAR 0 5
48391: PUSH
48392: LD_INT 7
48394: PUSH
48395: LD_INT 8
48397: PUSH
48398: EMPTY
48399: LIST
48400: LIST
48401: IN
48402: IFFALSE 48412
// btype := b_lab ;
48404: LD_ADDR_VAR 0 5
48408: PUSH
48409: LD_INT 6
48411: ST_TO_ADDR
// mc_build_list := ReplaceIn ( mc_build_list , [ i , mc_build_list [ i ] + 1 ] , [ btype , GetX ( un ) , GetY ( un ) , GetDir ( un ) ] ) ;
48412: LD_ADDR_EXP 81
48416: PUSH
48417: LD_EXP 81
48421: PPUSH
48422: LD_VAR 0 3
48426: PUSH
48427: LD_EXP 81
48431: PUSH
48432: LD_VAR 0 3
48436: ARRAY
48437: PUSH
48438: LD_INT 1
48440: PLUS
48441: PUSH
48442: EMPTY
48443: LIST
48444: LIST
48445: PPUSH
48446: LD_VAR 0 5
48450: PUSH
48451: LD_VAR 0 1
48455: PPUSH
48456: CALL_OW 250
48460: PUSH
48461: LD_VAR 0 1
48465: PPUSH
48466: CALL_OW 251
48470: PUSH
48471: LD_VAR 0 1
48475: PPUSH
48476: CALL_OW 254
48480: PUSH
48481: EMPTY
48482: LIST
48483: LIST
48484: LIST
48485: LIST
48486: PPUSH
48487: CALL 57743 0 3
48491: ST_TO_ADDR
// if pos = 1 then
48492: LD_VAR 0 6
48496: PUSH
48497: LD_INT 1
48499: EQUAL
48500: IFFALSE 48615
// begin tmp := mc_build_list [ i ] ;
48502: LD_ADDR_VAR 0 7
48506: PUSH
48507: LD_EXP 81
48511: PUSH
48512: LD_VAR 0 3
48516: ARRAY
48517: ST_TO_ADDR
// if UnitFilter ( tmp , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) then
48518: LD_VAR 0 7
48522: PPUSH
48523: LD_INT 2
48525: PUSH
48526: LD_INT 30
48528: PUSH
48529: LD_INT 0
48531: PUSH
48532: EMPTY
48533: LIST
48534: LIST
48535: PUSH
48536: LD_INT 30
48538: PUSH
48539: LD_INT 1
48541: PUSH
48542: EMPTY
48543: LIST
48544: LIST
48545: PUSH
48546: EMPTY
48547: LIST
48548: LIST
48549: LIST
48550: PPUSH
48551: CALL_OW 72
48555: IFFALSE 48565
// pos := 2 ;
48557: LD_ADDR_VAR 0 6
48561: PUSH
48562: LD_INT 2
48564: ST_TO_ADDR
// tmp := ReplaceWith ( tmp , pos , tmp ) ;
48565: LD_ADDR_VAR 0 7
48569: PUSH
48570: LD_VAR 0 7
48574: PPUSH
48575: LD_VAR 0 6
48579: PPUSH
48580: LD_VAR 0 7
48584: PPUSH
48585: CALL 58069 0 3
48589: ST_TO_ADDR
// mc_build_list := Replace ( mc_build_list , i , tmp ) ;
48590: LD_ADDR_EXP 81
48594: PUSH
48595: LD_EXP 81
48599: PPUSH
48600: LD_VAR 0 3
48604: PPUSH
48605: LD_VAR 0 7
48609: PPUSH
48610: CALL_OW 1
48614: ST_TO_ADDR
// end ; end ; if un in mc_bases [ i ] then
48615: LD_VAR 0 1
48619: PUSH
48620: LD_EXP 76
48624: PUSH
48625: LD_VAR 0 3
48629: ARRAY
48630: IN
48631: IFFALSE 48670
// begin mc_bases := Replace ( mc_bases , i , mc_bases [ i ] diff un ) ;
48633: LD_ADDR_EXP 76
48637: PUSH
48638: LD_EXP 76
48642: PPUSH
48643: LD_VAR 0 3
48647: PPUSH
48648: LD_EXP 76
48652: PUSH
48653: LD_VAR 0 3
48657: ARRAY
48658: PUSH
48659: LD_VAR 0 1
48663: DIFF
48664: PPUSH
48665: CALL_OW 1
48669: ST_TO_ADDR
// end ; if un in mc_construct_list [ i ] then
48670: LD_VAR 0 1
48674: PUSH
48675: LD_EXP 83
48679: PUSH
48680: LD_VAR 0 3
48684: ARRAY
48685: IN
48686: IFFALSE 48725
// begin mc_construct_list := Replace ( mc_construct_list , i , mc_construct_list [ i ] diff un ) ;
48688: LD_ADDR_EXP 83
48692: PUSH
48693: LD_EXP 83
48697: PPUSH
48698: LD_VAR 0 3
48702: PPUSH
48703: LD_EXP 83
48707: PUSH
48708: LD_VAR 0 3
48712: ARRAY
48713: PUSH
48714: LD_VAR 0 1
48718: DIFF
48719: PPUSH
48720: CALL_OW 1
48724: ST_TO_ADDR
// end ; if un in mc_vehicles [ i ] then
48725: LD_VAR 0 1
48729: PUSH
48730: LD_EXP 95
48734: PUSH
48735: LD_VAR 0 3
48739: ARRAY
48740: IN
48741: IFFALSE 48780
// begin mc_vehicles := Replace ( mc_vehicles , i , mc_vehicles [ i ] diff un ) ;
48743: LD_ADDR_EXP 95
48747: PUSH
48748: LD_EXP 95
48752: PPUSH
48753: LD_VAR 0 3
48757: PPUSH
48758: LD_EXP 95
48762: PUSH
48763: LD_VAR 0 3
48767: ARRAY
48768: PUSH
48769: LD_VAR 0 1
48773: DIFF
48774: PPUSH
48775: CALL_OW 1
48779: ST_TO_ADDR
// end ; if un in mc_defender [ i ] then
48780: LD_VAR 0 1
48784: PUSH
48785: LD_EXP 98
48789: PUSH
48790: LD_VAR 0 3
48794: ARRAY
48795: IN
48796: IFFALSE 48835
// begin mc_defender := Replace ( mc_defender , i , mc_defender [ i ] diff un ) ;
48798: LD_ADDR_EXP 98
48802: PUSH
48803: LD_EXP 98
48807: PPUSH
48808: LD_VAR 0 3
48812: PPUSH
48813: LD_EXP 98
48817: PUSH
48818: LD_VAR 0 3
48822: ARRAY
48823: PUSH
48824: LD_VAR 0 1
48828: DIFF
48829: PPUSH
48830: CALL_OW 1
48834: ST_TO_ADDR
// end ; if un in mc_empty_turret_list [ i ] then
48835: LD_VAR 0 1
48839: PUSH
48840: LD_EXP 85
48844: PUSH
48845: LD_VAR 0 3
48849: ARRAY
48850: IN
48851: IFFALSE 48890
// begin mc_empty_turret_list := Replace ( mc_empty_turret_list , i , mc_empty_turret_list [ i ] diff un ) ;
48853: LD_ADDR_EXP 85
48857: PUSH
48858: LD_EXP 85
48862: PPUSH
48863: LD_VAR 0 3
48867: PPUSH
48868: LD_EXP 85
48872: PUSH
48873: LD_VAR 0 3
48877: ARRAY
48878: PUSH
48879: LD_VAR 0 1
48883: DIFF
48884: PPUSH
48885: CALL_OW 1
48889: ST_TO_ADDR
// end ; if un in mc_turret_list [ i ] then
48890: LD_VAR 0 1
48894: PUSH
48895: LD_EXP 84
48899: PUSH
48900: LD_VAR 0 3
48904: ARRAY
48905: IN
48906: IFFALSE 48945
// begin mc_turret_list := Replace ( mc_turret_list , i , mc_turret_list [ i ] diff un ) ;
48908: LD_ADDR_EXP 84
48912: PUSH
48913: LD_EXP 84
48917: PPUSH
48918: LD_VAR 0 3
48922: PPUSH
48923: LD_EXP 84
48927: PUSH
48928: LD_VAR 0 3
48932: ARRAY
48933: PUSH
48934: LD_VAR 0 1
48938: DIFF
48939: PPUSH
48940: CALL_OW 1
48944: ST_TO_ADDR
// end ; break ;
48945: GO 48949
// end ;
48947: GO 47595
48949: POP
48950: POP
// end ;
48951: LD_VAR 0 2
48955: RET
// export function MCE_UpgradeComplete ( building ) ; var i , j ; begin
48956: LD_INT 0
48958: PPUSH
48959: PPUSH
48960: PPUSH
// if not mc_bases or not skirmish then
48961: LD_EXP 76
48965: NOT
48966: PUSH
48967: LD_EXP 74
48971: NOT
48972: OR
48973: IFFALSE 48977
// exit ;
48975: GO 49192
// for i = 1 to mc_bases do
48977: LD_ADDR_VAR 0 3
48981: PUSH
48982: DOUBLE
48983: LD_INT 1
48985: DEC
48986: ST_TO_ADDR
48987: LD_EXP 76
48991: PUSH
48992: FOR_TO
48993: IFFALSE 49190
// begin if building in mc_construct_list [ i ] then
48995: LD_VAR 0 1
48999: PUSH
49000: LD_EXP 83
49004: PUSH
49005: LD_VAR 0 3
49009: ARRAY
49010: IN
49011: IFFALSE 49188
// begin mc_construct_list := Replace ( mc_construct_list , i , mc_construct_list [ i ] diff building ) ;
49013: LD_ADDR_EXP 83
49017: PUSH
49018: LD_EXP 83
49022: PPUSH
49023: LD_VAR 0 3
49027: PPUSH
49028: LD_EXP 83
49032: PUSH
49033: LD_VAR 0 3
49037: ARRAY
49038: PUSH
49039: LD_VAR 0 1
49043: DIFF
49044: PPUSH
49045: CALL_OW 1
49049: ST_TO_ADDR
// if building in mc_lab [ i ] then
49050: LD_VAR 0 1
49054: PUSH
49055: LD_EXP 109
49059: PUSH
49060: LD_VAR 0 3
49064: ARRAY
49065: IN
49066: IFFALSE 49121
// mc_lab_upgrade := Replace ( mc_lab_upgrade , i , Reindex ( mc_lab_upgrade [ i ] , 1 , mc_lab_upgrade [ i ] , false ) ) ;
49068: LD_ADDR_EXP 110
49072: PUSH
49073: LD_EXP 110
49077: PPUSH
49078: LD_VAR 0 3
49082: PPUSH
49083: LD_EXP 110
49087: PUSH
49088: LD_VAR 0 3
49092: ARRAY
49093: PPUSH
49094: LD_INT 1
49096: PPUSH
49097: LD_EXP 110
49101: PUSH
49102: LD_VAR 0 3
49106: ARRAY
49107: PPUSH
49108: LD_INT 0
49110: PPUSH
49111: CALL 57161 0 4
49115: PPUSH
49116: CALL_OW 1
49120: ST_TO_ADDR
// if not building in mc_bases [ i ] then
49121: LD_VAR 0 1
49125: PUSH
49126: LD_EXP 76
49130: PUSH
49131: LD_VAR 0 3
49135: ARRAY
49136: IN
49137: NOT
49138: IFFALSE 49184
// mc_bases := ReplaceIn ( mc_bases , [ i , mc_bases [ i ] + 1 ] , building ) ;
49140: LD_ADDR_EXP 76
49144: PUSH
49145: LD_EXP 76
49149: PPUSH
49150: LD_VAR 0 3
49154: PUSH
49155: LD_EXP 76
49159: PUSH
49160: LD_VAR 0 3
49164: ARRAY
49165: PUSH
49166: LD_INT 1
49168: PLUS
49169: PUSH
49170: EMPTY
49171: LIST
49172: LIST
49173: PPUSH
49174: LD_VAR 0 1
49178: PPUSH
49179: CALL 57743 0 3
49183: ST_TO_ADDR
// exit ;
49184: POP
49185: POP
49186: GO 49192
// end ; end ;
49188: GO 48992
49190: POP
49191: POP
// end ;
49192: LD_VAR 0 2
49196: RET
// export function MCE_BuildingComplete ( building ) ; var i , j , btype , tmp , units , side ; begin
49197: LD_INT 0
49199: PPUSH
49200: PPUSH
49201: PPUSH
49202: PPUSH
49203: PPUSH
49204: PPUSH
49205: PPUSH
// if not mc_bases or not skirmish then
49206: LD_EXP 76
49210: NOT
49211: PUSH
49212: LD_EXP 74
49216: NOT
49217: OR
49218: IFFALSE 49222
// exit ;
49220: GO 49883
// for i = 1 to mc_bases do
49222: LD_ADDR_VAR 0 3
49226: PUSH
49227: DOUBLE
49228: LD_INT 1
49230: DEC
49231: ST_TO_ADDR
49232: LD_EXP 76
49236: PUSH
49237: FOR_TO
49238: IFFALSE 49881
// begin if building in mc_construct_list [ i ] then
49240: LD_VAR 0 1
49244: PUSH
49245: LD_EXP 83
49249: PUSH
49250: LD_VAR 0 3
49254: ARRAY
49255: IN
49256: IFFALSE 49879
// begin mc_construct_list := Replace ( mc_construct_list , i , mc_construct_list [ i ] diff building ) ;
49258: LD_ADDR_EXP 83
49262: PUSH
49263: LD_EXP 83
49267: PPUSH
49268: LD_VAR 0 3
49272: PPUSH
49273: LD_EXP 83
49277: PUSH
49278: LD_VAR 0 3
49282: ARRAY
49283: PUSH
49284: LD_VAR 0 1
49288: DIFF
49289: PPUSH
49290: CALL_OW 1
49294: ST_TO_ADDR
// mc_bases := ReplaceIn ( mc_bases , [ i , mc_bases [ i ] + 1 ] , building ) ;
49295: LD_ADDR_EXP 76
49299: PUSH
49300: LD_EXP 76
49304: PPUSH
49305: LD_VAR 0 3
49309: PUSH
49310: LD_EXP 76
49314: PUSH
49315: LD_VAR 0 3
49319: ARRAY
49320: PUSH
49321: LD_INT 1
49323: PLUS
49324: PUSH
49325: EMPTY
49326: LIST
49327: LIST
49328: PPUSH
49329: LD_VAR 0 1
49333: PPUSH
49334: CALL 57743 0 3
49338: ST_TO_ADDR
// btype := GetBType ( building ) ;
49339: LD_ADDR_VAR 0 5
49343: PUSH
49344: LD_VAR 0 1
49348: PPUSH
49349: CALL_OW 266
49353: ST_TO_ADDR
// side := GetSide ( building ) ;
49354: LD_ADDR_VAR 0 8
49358: PUSH
49359: LD_VAR 0 1
49363: PPUSH
49364: CALL_OW 255
49368: ST_TO_ADDR
// if btype = b_lab then
49369: LD_VAR 0 5
49373: PUSH
49374: LD_INT 6
49376: EQUAL
49377: IFFALSE 49427
// begin mc_lab := ReplaceIn ( mc_lab , [ i , mc_lab [ i ] + 1 ] , building ) ;
49379: LD_ADDR_EXP 109
49383: PUSH
49384: LD_EXP 109
49388: PPUSH
49389: LD_VAR 0 3
49393: PUSH
49394: LD_EXP 109
49398: PUSH
49399: LD_VAR 0 3
49403: ARRAY
49404: PUSH
49405: LD_INT 1
49407: PLUS
49408: PUSH
49409: EMPTY
49410: LIST
49411: LIST
49412: PPUSH
49413: LD_VAR 0 1
49417: PPUSH
49418: CALL 57743 0 3
49422: ST_TO_ADDR
// exit ;
49423: POP
49424: POP
49425: GO 49883
// end ; if btype in [ b_depot , b_workshop , b_armoury ] then
49427: LD_VAR 0 5
49431: PUSH
49432: LD_INT 0
49434: PUSH
49435: LD_INT 2
49437: PUSH
49438: LD_INT 4
49440: PUSH
49441: EMPTY
49442: LIST
49443: LIST
49444: LIST
49445: IN
49446: IFFALSE 49570
// begin if btype = b_armoury then
49448: LD_VAR 0 5
49452: PUSH
49453: LD_INT 4
49455: EQUAL
49456: IFFALSE 49466
// btype := b_barracks ;
49458: LD_ADDR_VAR 0 5
49462: PUSH
49463: LD_INT 5
49465: ST_TO_ADDR
// if btype = b_depot then
49466: LD_VAR 0 5
49470: PUSH
49471: LD_INT 0
49473: EQUAL
49474: IFFALSE 49484
// btype := b_warehouse ;
49476: LD_ADDR_VAR 0 5
49480: PUSH
49481: LD_INT 1
49483: ST_TO_ADDR
// if btype = b_workshop then
49484: LD_VAR 0 5
49488: PUSH
49489: LD_INT 2
49491: EQUAL
49492: IFFALSE 49502
// btype := b_factory ;
49494: LD_ADDR_VAR 0 5
49498: PUSH
49499: LD_INT 3
49501: ST_TO_ADDR
// if GetRestrict ( btype , side ) = state_enabled then
49502: LD_VAR 0 5
49506: PPUSH
49507: LD_VAR 0 8
49511: PPUSH
49512: CALL_OW 323
49516: PUSH
49517: LD_INT 1
49519: EQUAL
49520: IFFALSE 49566
// mc_build_upgrade := ReplaceIn ( mc_build_upgrade , [ i , mc_build_upgrade [ i ] + 1 ] , building ) ;
49522: LD_ADDR_EXP 108
49526: PUSH
49527: LD_EXP 108
49531: PPUSH
49532: LD_VAR 0 3
49536: PUSH
49537: LD_EXP 108
49541: PUSH
49542: LD_VAR 0 3
49546: ARRAY
49547: PUSH
49548: LD_INT 1
49550: PLUS
49551: PUSH
49552: EMPTY
49553: LIST
49554: LIST
49555: PPUSH
49556: LD_VAR 0 1
49560: PPUSH
49561: CALL 57743 0 3
49565: ST_TO_ADDR
// exit ;
49566: POP
49567: POP
49568: GO 49883
// end ; if btype in [ b_bunker , b_turret ] then
49570: LD_VAR 0 5
49574: PUSH
49575: LD_INT 32
49577: PUSH
49578: LD_INT 33
49580: PUSH
49581: EMPTY
49582: LIST
49583: LIST
49584: IN
49585: IFFALSE 49875
// begin mc_turret_list := ReplaceIn ( mc_turret_list , [ i , mc_turret_list [ i ] + 1 ] , building ) ;
49587: LD_ADDR_EXP 84
49591: PUSH
49592: LD_EXP 84
49596: PPUSH
49597: LD_VAR 0 3
49601: PUSH
49602: LD_EXP 84
49606: PUSH
49607: LD_VAR 0 3
49611: ARRAY
49612: PUSH
49613: LD_INT 1
49615: PLUS
49616: PUSH
49617: EMPTY
49618: LIST
49619: LIST
49620: PPUSH
49621: LD_VAR 0 1
49625: PPUSH
49626: CALL 57743 0 3
49630: ST_TO_ADDR
// if btype = b_bunker then
49631: LD_VAR 0 5
49635: PUSH
49636: LD_INT 32
49638: EQUAL
49639: IFFALSE 49875
// begin mc_empty_turret_list := ReplaceIn ( mc_empty_turret_list , [ i , mc_empty_turret_list [ i ] + 1 ] , building ) ;
49641: LD_ADDR_EXP 85
49645: PUSH
49646: LD_EXP 85
49650: PPUSH
49651: LD_VAR 0 3
49655: PUSH
49656: LD_EXP 85
49660: PUSH
49661: LD_VAR 0 3
49665: ARRAY
49666: PUSH
49667: LD_INT 1
49669: PLUS
49670: PUSH
49671: EMPTY
49672: LIST
49673: LIST
49674: PPUSH
49675: LD_VAR 0 1
49679: PPUSH
49680: CALL 57743 0 3
49684: ST_TO_ADDR
// tmp := UnitFilter ( mc_bases [ i ] , [ [ f_class , 1 ] , [ f_not , [ f_inside ] ] ] ) ;
49685: LD_ADDR_VAR 0 6
49689: PUSH
49690: LD_EXP 76
49694: PUSH
49695: LD_VAR 0 3
49699: ARRAY
49700: PPUSH
49701: LD_INT 25
49703: PUSH
49704: LD_INT 1
49706: PUSH
49707: EMPTY
49708: LIST
49709: LIST
49710: PUSH
49711: LD_INT 3
49713: PUSH
49714: LD_INT 54
49716: PUSH
49717: EMPTY
49718: LIST
49719: PUSH
49720: EMPTY
49721: LIST
49722: LIST
49723: PUSH
49724: EMPTY
49725: LIST
49726: LIST
49727: PPUSH
49728: CALL_OW 72
49732: ST_TO_ADDR
// if tmp then
49733: LD_VAR 0 6
49737: IFFALSE 49743
// exit ;
49739: POP
49740: POP
49741: GO 49883
// tmp := UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_armoury ] , [ f_btype , b_barracks ] ] ) ;
49743: LD_ADDR_VAR 0 6
49747: PUSH
49748: LD_EXP 76
49752: PUSH
49753: LD_VAR 0 3
49757: ARRAY
49758: PPUSH
49759: LD_INT 2
49761: PUSH
49762: LD_INT 30
49764: PUSH
49765: LD_INT 4
49767: PUSH
49768: EMPTY
49769: LIST
49770: LIST
49771: PUSH
49772: LD_INT 30
49774: PUSH
49775: LD_INT 5
49777: PUSH
49778: EMPTY
49779: LIST
49780: LIST
49781: PUSH
49782: EMPTY
49783: LIST
49784: LIST
49785: LIST
49786: PPUSH
49787: CALL_OW 72
49791: ST_TO_ADDR
// if not tmp then
49792: LD_VAR 0 6
49796: NOT
49797: IFFALSE 49803
// exit ;
49799: POP
49800: POP
49801: GO 49883
// for j in tmp do
49803: LD_ADDR_VAR 0 4
49807: PUSH
49808: LD_VAR 0 6
49812: PUSH
49813: FOR_IN
49814: IFFALSE 49873
// begin units := UnitFilter ( UnitsInside ( j ) , [ f_class , 1 ] ) ;
49816: LD_ADDR_VAR 0 7
49820: PUSH
49821: LD_VAR 0 4
49825: PPUSH
49826: CALL_OW 313
49830: PPUSH
49831: LD_INT 25
49833: PUSH
49834: LD_INT 1
49836: PUSH
49837: EMPTY
49838: LIST
49839: LIST
49840: PPUSH
49841: CALL_OW 72
49845: ST_TO_ADDR
// if units then
49846: LD_VAR 0 7
49850: IFFALSE 49871
// begin ComExitBuilding ( units [ 1 ] ) ;
49852: LD_VAR 0 7
49856: PUSH
49857: LD_INT 1
49859: ARRAY
49860: PPUSH
49861: CALL_OW 122
// exit ;
49865: POP
49866: POP
49867: POP
49868: POP
49869: GO 49883
// end ; end ;
49871: GO 49813
49873: POP
49874: POP
// end ; end ; exit ;
49875: POP
49876: POP
49877: GO 49883
// end ; end ;
49879: GO 49237
49881: POP
49882: POP
// end ;
49883: LD_VAR 0 2
49887: RET
// export function MCE_BuildingStarted ( building , builder ) ; var i , j , btype , x , y , d ; begin
49888: LD_INT 0
49890: PPUSH
49891: PPUSH
49892: PPUSH
49893: PPUSH
49894: PPUSH
49895: PPUSH
49896: PPUSH
// if not mc_bases or not skirmish then
49897: LD_EXP 76
49901: NOT
49902: PUSH
49903: LD_EXP 74
49907: NOT
49908: OR
49909: IFFALSE 49913
// exit ;
49911: GO 50144
// btype := GetBType ( building ) ;
49913: LD_ADDR_VAR 0 6
49917: PUSH
49918: LD_VAR 0 1
49922: PPUSH
49923: CALL_OW 266
49927: ST_TO_ADDR
// x := GetX ( building ) ;
49928: LD_ADDR_VAR 0 7
49932: PUSH
49933: LD_VAR 0 1
49937: PPUSH
49938: CALL_OW 250
49942: ST_TO_ADDR
// y := GetY ( building ) ;
49943: LD_ADDR_VAR 0 8
49947: PUSH
49948: LD_VAR 0 1
49952: PPUSH
49953: CALL_OW 251
49957: ST_TO_ADDR
// d := GetDir ( building ) ;
49958: LD_ADDR_VAR 0 9
49962: PUSH
49963: LD_VAR 0 1
49967: PPUSH
49968: CALL_OW 254
49972: ST_TO_ADDR
// for i = 1 to mc_bases do
49973: LD_ADDR_VAR 0 4
49977: PUSH
49978: DOUBLE
49979: LD_INT 1
49981: DEC
49982: ST_TO_ADDR
49983: LD_EXP 76
49987: PUSH
49988: FOR_TO
49989: IFFALSE 50142
// begin if not mc_build_list [ i ] then
49991: LD_EXP 81
49995: PUSH
49996: LD_VAR 0 4
50000: ARRAY
50001: NOT
50002: IFFALSE 50006
// continue ;
50004: GO 49988
// if CompareArray ( [ btype , x , y , d ] , mc_build_list [ i ] [ 1 ] ) then
50006: LD_VAR 0 6
50010: PUSH
50011: LD_VAR 0 7
50015: PUSH
50016: LD_VAR 0 8
50020: PUSH
50021: LD_VAR 0 9
50025: PUSH
50026: EMPTY
50027: LIST
50028: LIST
50029: LIST
50030: LIST
50031: PPUSH
50032: LD_EXP 81
50036: PUSH
50037: LD_VAR 0 4
50041: ARRAY
50042: PUSH
50043: LD_INT 1
50045: ARRAY
50046: PPUSH
50047: CALL 63912 0 2
50051: IFFALSE 50140
// begin mc_build_list := Replace ( mc_build_list , i , Delete ( mc_build_list [ i ] , 1 ) ) ;
50053: LD_ADDR_EXP 81
50057: PUSH
50058: LD_EXP 81
50062: PPUSH
50063: LD_VAR 0 4
50067: PPUSH
50068: LD_EXP 81
50072: PUSH
50073: LD_VAR 0 4
50077: ARRAY
50078: PPUSH
50079: LD_INT 1
50081: PPUSH
50082: CALL_OW 3
50086: PPUSH
50087: CALL_OW 1
50091: ST_TO_ADDR
// mc_construct_list := ReplaceIn ( mc_construct_list , [ i , mc_construct_list [ i ] + 1 ] , building ) ;
50092: LD_ADDR_EXP 83
50096: PUSH
50097: LD_EXP 83
50101: PPUSH
50102: LD_VAR 0 4
50106: PUSH
50107: LD_EXP 83
50111: PUSH
50112: LD_VAR 0 4
50116: ARRAY
50117: PUSH
50118: LD_INT 1
50120: PLUS
50121: PUSH
50122: EMPTY
50123: LIST
50124: LIST
50125: PPUSH
50126: LD_VAR 0 1
50130: PPUSH
50131: CALL 57743 0 3
50135: ST_TO_ADDR
// exit ;
50136: POP
50137: POP
50138: GO 50144
// end ; end ;
50140: GO 49988
50142: POP
50143: POP
// end ;
50144: LD_VAR 0 3
50148: RET
// export function MCE_LeaveBuilding ( building , unit ) ; var i , tmp ; begin
50149: LD_INT 0
50151: PPUSH
50152: PPUSH
50153: PPUSH
// if not mc_bases or not skirmish then
50154: LD_EXP 76
50158: NOT
50159: PUSH
50160: LD_EXP 74
50164: NOT
50165: OR
50166: IFFALSE 50170
// exit ;
50168: GO 50360
// for i = 1 to mc_bases do
50170: LD_ADDR_VAR 0 4
50174: PUSH
50175: DOUBLE
50176: LD_INT 1
50178: DEC
50179: ST_TO_ADDR
50180: LD_EXP 76
50184: PUSH
50185: FOR_TO
50186: IFFALSE 50273
// begin if building in mc_turret_list [ i ] and not building in mc_empty_turret_list [ i ] then
50188: LD_VAR 0 1
50192: PUSH
50193: LD_EXP 84
50197: PUSH
50198: LD_VAR 0 4
50202: ARRAY
50203: IN
50204: PUSH
50205: LD_VAR 0 1
50209: PUSH
50210: LD_EXP 85
50214: PUSH
50215: LD_VAR 0 4
50219: ARRAY
50220: IN
50221: NOT
50222: AND
50223: IFFALSE 50271
// begin mc_empty_turret_list := ReplaceIn ( mc_empty_turret_list , [ i , mc_empty_turret_list [ i ] + 1 ] , building ) ;
50225: LD_ADDR_EXP 85
50229: PUSH
50230: LD_EXP 85
50234: PPUSH
50235: LD_VAR 0 4
50239: PUSH
50240: LD_EXP 85
50244: PUSH
50245: LD_VAR 0 4
50249: ARRAY
50250: PUSH
50251: LD_INT 1
50253: PLUS
50254: PUSH
50255: EMPTY
50256: LIST
50257: LIST
50258: PPUSH
50259: LD_VAR 0 1
50263: PPUSH
50264: CALL 57743 0 3
50268: ST_TO_ADDR
// break ;
50269: GO 50273
// end ; end ;
50271: GO 50185
50273: POP
50274: POP
// if GetClass ( building ) in mc_sides and GetBType ( building ) = b_barracks and GetTag ( unit ) <> 18 then
50275: LD_VAR 0 1
50279: PPUSH
50280: CALL_OW 257
50284: PUSH
50285: LD_EXP 102
50289: IN
50290: PUSH
50291: LD_VAR 0 1
50295: PPUSH
50296: CALL_OW 266
50300: PUSH
50301: LD_INT 5
50303: EQUAL
50304: AND
50305: PUSH
50306: LD_VAR 0 2
50310: PPUSH
50311: CALL_OW 110
50315: PUSH
50316: LD_INT 18
50318: NONEQUAL
50319: AND
50320: IFFALSE 50360
// if GetClass ( unit ) in [ 5 , 8 , 9 ] then
50322: LD_VAR 0 2
50326: PPUSH
50327: CALL_OW 257
50331: PUSH
50332: LD_INT 5
50334: PUSH
50335: LD_INT 8
50337: PUSH
50338: LD_INT 9
50340: PUSH
50341: EMPTY
50342: LIST
50343: LIST
50344: LIST
50345: IN
50346: IFFALSE 50360
// SetClass ( unit , 1 ) ;
50348: LD_VAR 0 2
50352: PPUSH
50353: LD_INT 1
50355: PPUSH
50356: CALL_OW 336
// end ;
50360: LD_VAR 0 3
50364: RET
// export function MCE_EvacuateVehicle ( driver , abandoned_vehicle , unknown1 , unknown2 ) ; var i ; begin
50365: LD_INT 0
50367: PPUSH
50368: PPUSH
// if not mc_bases or not skirmish then
50369: LD_EXP 76
50373: NOT
50374: PUSH
50375: LD_EXP 74
50379: NOT
50380: OR
50381: IFFALSE 50385
// exit ;
50383: GO 50501
// if GetLives ( abandoned_vehicle ) > 250 then
50385: LD_VAR 0 2
50389: PPUSH
50390: CALL_OW 256
50394: PUSH
50395: LD_INT 250
50397: GREATER
50398: IFFALSE 50402
// exit ;
50400: GO 50501
// for i = 1 to mc_bases do
50402: LD_ADDR_VAR 0 6
50406: PUSH
50407: DOUBLE
50408: LD_INT 1
50410: DEC
50411: ST_TO_ADDR
50412: LD_EXP 76
50416: PUSH
50417: FOR_TO
50418: IFFALSE 50499
// begin if driver in mc_bases [ i ] then
50420: LD_VAR 0 1
50424: PUSH
50425: LD_EXP 76
50429: PUSH
50430: LD_VAR 0 6
50434: ARRAY
50435: IN
50436: IFFALSE 50497
// begin ComMoveUnit ( driver , UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) [ 1 ] ) ;
50438: LD_VAR 0 1
50442: PPUSH
50443: LD_EXP 76
50447: PUSH
50448: LD_VAR 0 6
50452: ARRAY
50453: PPUSH
50454: LD_INT 2
50456: PUSH
50457: LD_INT 30
50459: PUSH
50460: LD_INT 0
50462: PUSH
50463: EMPTY
50464: LIST
50465: LIST
50466: PUSH
50467: LD_INT 30
50469: PUSH
50470: LD_INT 1
50472: PUSH
50473: EMPTY
50474: LIST
50475: LIST
50476: PUSH
50477: EMPTY
50478: LIST
50479: LIST
50480: LIST
50481: PPUSH
50482: CALL_OW 72
50486: PUSH
50487: LD_INT 1
50489: ARRAY
50490: PPUSH
50491: CALL_OW 112
// break ;
50495: GO 50499
// end ; end ;
50497: GO 50417
50499: POP
50500: POP
// end ; end_of_file
50501: LD_VAR 0 5
50505: RET
// export function PrepareUnit ( ident , exist_mode , prefix ) ; var unit ; begin
50506: LD_INT 0
50508: PPUSH
50509: PPUSH
// if exist_mode then
50510: LD_VAR 0 2
50514: IFFALSE 50539
// unit := CreateCharacter ( prefix & ident ) else
50516: LD_ADDR_VAR 0 5
50520: PUSH
50521: LD_VAR 0 3
50525: PUSH
50526: LD_VAR 0 1
50530: STR
50531: PPUSH
50532: CALL_OW 34
50536: ST_TO_ADDR
50537: GO 50554
// unit := NewCharacter ( ident ) ;
50539: LD_ADDR_VAR 0 5
50543: PUSH
50544: LD_VAR 0 1
50548: PPUSH
50549: CALL_OW 25
50553: ST_TO_ADDR
// result := unit ;
50554: LD_ADDR_VAR 0 4
50558: PUSH
50559: LD_VAR 0 5
50563: ST_TO_ADDR
// end ;
50564: LD_VAR 0 4
50568: RET
// export function GetTechNation ( side , nation , state ) ; var i ; begin
50569: LD_INT 0
50571: PPUSH
50572: PPUSH
// if not side or not nation then
50573: LD_VAR 0 1
50577: NOT
50578: PUSH
50579: LD_VAR 0 2
50583: NOT
50584: OR
50585: IFFALSE 50589
// exit ;
50587: GO 51233
// case nation of nation_american :
50589: LD_VAR 0 2
50593: PUSH
50594: LD_INT 1
50596: DOUBLE
50597: EQUAL
50598: IFTRUE 50602
50600: GO 50776
50602: POP
// result := [ 35 , 45 , 46 , 47 , 1 , 2 , 6 , 15 , 16 , 7 , 12 , 13 , 10 , 14 , 20 , 21 , 22 , 25 , 32 , 27 , 36 , 69 , 39 , 34 , 40 , 48 , 49 , 50 , 51 , 52 , 53 , 54 , 55 , 56 , 57 , 58 , 59 , 60 , 61 , 62 , 80 ] ; nation_arabian :
50603: LD_ADDR_VAR 0 4
50607: PUSH
50608: LD_INT 35
50610: PUSH
50611: LD_INT 45
50613: PUSH
50614: LD_INT 46
50616: PUSH
50617: LD_INT 47
50619: PUSH
50620: LD_INT 1
50622: PUSH
50623: LD_INT 2
50625: PUSH
50626: LD_INT 6
50628: PUSH
50629: LD_INT 15
50631: PUSH
50632: LD_INT 16
50634: PUSH
50635: LD_INT 7
50637: PUSH
50638: LD_INT 12
50640: PUSH
50641: LD_INT 13
50643: PUSH
50644: LD_INT 10
50646: PUSH
50647: LD_INT 14
50649: PUSH
50650: LD_INT 20
50652: PUSH
50653: LD_INT 21
50655: PUSH
50656: LD_INT 22
50658: PUSH
50659: LD_INT 25
50661: PUSH
50662: LD_INT 32
50664: PUSH
50665: LD_INT 27
50667: PUSH
50668: LD_INT 36
50670: PUSH
50671: LD_INT 69
50673: PUSH
50674: LD_INT 39
50676: PUSH
50677: LD_INT 34
50679: PUSH
50680: LD_INT 40
50682: PUSH
50683: LD_INT 48
50685: PUSH
50686: LD_INT 49
50688: PUSH
50689: LD_INT 50
50691: PUSH
50692: LD_INT 51
50694: PUSH
50695: LD_INT 52
50697: PUSH
50698: LD_INT 53
50700: PUSH
50701: LD_INT 54
50703: PUSH
50704: LD_INT 55
50706: PUSH
50707: LD_INT 56
50709: PUSH
50710: LD_INT 57
50712: PUSH
50713: LD_INT 58
50715: PUSH
50716: LD_INT 59
50718: PUSH
50719: LD_INT 60
50721: PUSH
50722: LD_INT 61
50724: PUSH
50725: LD_INT 62
50727: PUSH
50728: LD_INT 80
50730: PUSH
50731: EMPTY
50732: LIST
50733: LIST
50734: LIST
50735: LIST
50736: LIST
50737: LIST
50738: LIST
50739: LIST
50740: LIST
50741: LIST
50742: LIST
50743: LIST
50744: LIST
50745: LIST
50746: LIST
50747: LIST
50748: LIST
50749: LIST
50750: LIST
50751: LIST
50752: LIST
50753: LIST
50754: LIST
50755: LIST
50756: LIST
50757: LIST
50758: LIST
50759: LIST
50760: LIST
50761: LIST
50762: LIST
50763: LIST
50764: LIST
50765: LIST
50766: LIST
50767: LIST
50768: LIST
50769: LIST
50770: LIST
50771: LIST
50772: LIST
50773: ST_TO_ADDR
50774: GO 51157
50776: LD_INT 2
50778: DOUBLE
50779: EQUAL
50780: IFTRUE 50784
50782: GO 50966
50784: POP
// result := [ 35 , 45 , 46 , 47 , 70 , 1 , 11 , 3 , 4 , 5 , 6 , 15 , 18 , 7 , 17 , 8 , 20 , 21 , 22 , 72 , 26 , 69 , 39 , 40 , 41 , 42 , 43 , 48 , 49 , 50 , 51 , 52 , 53 , 54 , 55 , 56 , 60 , 61 , 62 , 66 , 67 , 68 , 81 ] ; nation_russian :
50785: LD_ADDR_VAR 0 4
50789: PUSH
50790: LD_INT 35
50792: PUSH
50793: LD_INT 45
50795: PUSH
50796: LD_INT 46
50798: PUSH
50799: LD_INT 47
50801: PUSH
50802: LD_INT 70
50804: PUSH
50805: LD_INT 1
50807: PUSH
50808: LD_INT 11
50810: PUSH
50811: LD_INT 3
50813: PUSH
50814: LD_INT 4
50816: PUSH
50817: LD_INT 5
50819: PUSH
50820: LD_INT 6
50822: PUSH
50823: LD_INT 15
50825: PUSH
50826: LD_INT 18
50828: PUSH
50829: LD_INT 7
50831: PUSH
50832: LD_INT 17
50834: PUSH
50835: LD_INT 8
50837: PUSH
50838: LD_INT 20
50840: PUSH
50841: LD_INT 21
50843: PUSH
50844: LD_INT 22
50846: PUSH
50847: LD_INT 72
50849: PUSH
50850: LD_INT 26
50852: PUSH
50853: LD_INT 69
50855: PUSH
50856: LD_INT 39
50858: PUSH
50859: LD_INT 40
50861: PUSH
50862: LD_INT 41
50864: PUSH
50865: LD_INT 42
50867: PUSH
50868: LD_INT 43
50870: PUSH
50871: LD_INT 48
50873: PUSH
50874: LD_INT 49
50876: PUSH
50877: LD_INT 50
50879: PUSH
50880: LD_INT 51
50882: PUSH
50883: LD_INT 52
50885: PUSH
50886: LD_INT 53
50888: PUSH
50889: LD_INT 54
50891: PUSH
50892: LD_INT 55
50894: PUSH
50895: LD_INT 56
50897: PUSH
50898: LD_INT 60
50900: PUSH
50901: LD_INT 61
50903: PUSH
50904: LD_INT 62
50906: PUSH
50907: LD_INT 66
50909: PUSH
50910: LD_INT 67
50912: PUSH
50913: LD_INT 68
50915: PUSH
50916: LD_INT 81
50918: PUSH
50919: EMPTY
50920: LIST
50921: LIST
50922: LIST
50923: LIST
50924: LIST
50925: LIST
50926: LIST
50927: LIST
50928: LIST
50929: LIST
50930: LIST
50931: LIST
50932: LIST
50933: LIST
50934: LIST
50935: LIST
50936: LIST
50937: LIST
50938: LIST
50939: LIST
50940: LIST
50941: LIST
50942: LIST
50943: LIST
50944: LIST
50945: LIST
50946: LIST
50947: LIST
50948: LIST
50949: LIST
50950: LIST
50951: LIST
50952: LIST
50953: LIST
50954: LIST
50955: LIST
50956: LIST
50957: LIST
50958: LIST
50959: LIST
50960: LIST
50961: LIST
50962: LIST
50963: ST_TO_ADDR
50964: GO 51157
50966: LD_INT 3
50968: DOUBLE
50969: EQUAL
50970: IFTRUE 50974
50972: GO 51156
50974: POP
// result := [ 46 , 47 , 1 , 2 , 11 , 9 , 20 , 19 , 21 , 24 , 22 , 25 , 28 , 29 , 30 , 31 , 37 , 38 , 32 , 27 , 33 , 69 , 39 , 34 , 40 , 71 , 23 , 44 , 48 , 49 , 50 , 51 , 52 , 53 , 54 , 55 , 56 , 57 , 58 , 59 , 63 , 64 , 65 ] ; end ;
50975: LD_ADDR_VAR 0 4
50979: PUSH
50980: LD_INT 46
50982: PUSH
50983: LD_INT 47
50985: PUSH
50986: LD_INT 1
50988: PUSH
50989: LD_INT 2
50991: PUSH
50992: LD_INT 11
50994: PUSH
50995: LD_INT 9
50997: PUSH
50998: LD_INT 20
51000: PUSH
51001: LD_INT 19
51003: PUSH
51004: LD_INT 21
51006: PUSH
51007: LD_INT 24
51009: PUSH
51010: LD_INT 22
51012: PUSH
51013: LD_INT 25
51015: PUSH
51016: LD_INT 28
51018: PUSH
51019: LD_INT 29
51021: PUSH
51022: LD_INT 30
51024: PUSH
51025: LD_INT 31
51027: PUSH
51028: LD_INT 37
51030: PUSH
51031: LD_INT 38
51033: PUSH
51034: LD_INT 32
51036: PUSH
51037: LD_INT 27
51039: PUSH
51040: LD_INT 33
51042: PUSH
51043: LD_INT 69
51045: PUSH
51046: LD_INT 39
51048: PUSH
51049: LD_INT 34
51051: PUSH
51052: LD_INT 40
51054: PUSH
51055: LD_INT 71
51057: PUSH
51058: LD_INT 23
51060: PUSH
51061: LD_INT 44
51063: PUSH
51064: LD_INT 48
51066: PUSH
51067: LD_INT 49
51069: PUSH
51070: LD_INT 50
51072: PUSH
51073: LD_INT 51
51075: PUSH
51076: LD_INT 52
51078: PUSH
51079: LD_INT 53
51081: PUSH
51082: LD_INT 54
51084: PUSH
51085: LD_INT 55
51087: PUSH
51088: LD_INT 56
51090: PUSH
51091: LD_INT 57
51093: PUSH
51094: LD_INT 58
51096: PUSH
51097: LD_INT 59
51099: PUSH
51100: LD_INT 63
51102: PUSH
51103: LD_INT 64
51105: PUSH
51106: LD_INT 65
51108: PUSH
51109: EMPTY
51110: LIST
51111: LIST
51112: LIST
51113: LIST
51114: LIST
51115: LIST
51116: LIST
51117: LIST
51118: LIST
51119: LIST
51120: LIST
51121: LIST
51122: LIST
51123: LIST
51124: LIST
51125: LIST
51126: LIST
51127: LIST
51128: LIST
51129: LIST
51130: LIST
51131: LIST
51132: LIST
51133: LIST
51134: LIST
51135: LIST
51136: LIST
51137: LIST
51138: LIST
51139: LIST
51140: LIST
51141: LIST
51142: LIST
51143: LIST
51144: LIST
51145: LIST
51146: LIST
51147: LIST
51148: LIST
51149: LIST
51150: LIST
51151: LIST
51152: LIST
51153: ST_TO_ADDR
51154: GO 51157
51156: POP
// if state > - 1 and state < 3 then
51157: LD_VAR 0 3
51161: PUSH
51162: LD_INT 1
51164: NEG
51165: GREATER
51166: PUSH
51167: LD_VAR 0 3
51171: PUSH
51172: LD_INT 3
51174: LESS
51175: AND
51176: IFFALSE 51233
// for i in result do
51178: LD_ADDR_VAR 0 5
51182: PUSH
51183: LD_VAR 0 4
51187: PUSH
51188: FOR_IN
51189: IFFALSE 51231
// if GetTech ( i , side ) <> state then
51191: LD_VAR 0 5
51195: PPUSH
51196: LD_VAR 0 1
51200: PPUSH
51201: CALL_OW 321
51205: PUSH
51206: LD_VAR 0 3
51210: NONEQUAL
51211: IFFALSE 51229
// result := result diff i ;
51213: LD_ADDR_VAR 0 4
51217: PUSH
51218: LD_VAR 0 4
51222: PUSH
51223: LD_VAR 0 5
51227: DIFF
51228: ST_TO_ADDR
51229: GO 51188
51231: POP
51232: POP
// end ;
51233: LD_VAR 0 4
51237: RET
// export function TechCanBeResearch ( side , tech ) ; var i , tmp ; begin
51238: LD_INT 0
51240: PPUSH
51241: PPUSH
51242: PPUSH
// result := true ;
51243: LD_ADDR_VAR 0 3
51247: PUSH
51248: LD_INT 1
51250: ST_TO_ADDR
// tmp := GetTechTechsReq ( tech ) ;
51251: LD_ADDR_VAR 0 5
51255: PUSH
51256: LD_VAR 0 2
51260: PPUSH
51261: CALL_OW 480
51265: ST_TO_ADDR
// if not tmp then
51266: LD_VAR 0 5
51270: NOT
51271: IFFALSE 51275
// exit ;
51273: GO 51324
// for i in tmp do
51275: LD_ADDR_VAR 0 4
51279: PUSH
51280: LD_VAR 0 5
51284: PUSH
51285: FOR_IN
51286: IFFALSE 51322
// if GetTech ( i , side ) <> state_researched then
51288: LD_VAR 0 4
51292: PPUSH
51293: LD_VAR 0 1
51297: PPUSH
51298: CALL_OW 321
51302: PUSH
51303: LD_INT 2
51305: NONEQUAL
51306: IFFALSE 51320
// begin result := false ;
51308: LD_ADDR_VAR 0 3
51312: PUSH
51313: LD_INT 0
51315: ST_TO_ADDR
// exit ;
51316: POP
51317: POP
51318: GO 51324
// end ;
51320: GO 51285
51322: POP
51323: POP
// end ;
51324: LD_VAR 0 3
51328: RET
// export function ComSpaceTimeShoot ( unit ) ; var i , x , y , _x , _y , tmp , side , enemy , in_unit , tech_space , tech_time , missile ; begin
51329: LD_INT 0
51331: PPUSH
51332: PPUSH
51333: PPUSH
51334: PPUSH
51335: PPUSH
51336: PPUSH
51337: PPUSH
51338: PPUSH
51339: PPUSH
51340: PPUSH
51341: PPUSH
51342: PPUSH
51343: PPUSH
// if not unit or GetClass ( unit ) <> class_bazooker then
51344: LD_VAR 0 1
51348: NOT
51349: PUSH
51350: LD_VAR 0 1
51354: PPUSH
51355: CALL_OW 257
51359: PUSH
51360: LD_INT 9
51362: NONEQUAL
51363: OR
51364: IFFALSE 51368
// exit ;
51366: GO 51941
// side := GetSide ( unit ) ;
51368: LD_ADDR_VAR 0 9
51372: PUSH
51373: LD_VAR 0 1
51377: PPUSH
51378: CALL_OW 255
51382: ST_TO_ADDR
// tech_space := tech_spacanom ;
51383: LD_ADDR_VAR 0 12
51387: PUSH
51388: LD_INT 29
51390: ST_TO_ADDR
// tech_time := tech_taurad ;
51391: LD_ADDR_VAR 0 13
51395: PUSH
51396: LD_INT 28
51398: ST_TO_ADDR
// in_unit := IsInUnit ( unit ) ;
51399: LD_ADDR_VAR 0 11
51403: PUSH
51404: LD_VAR 0 1
51408: PPUSH
51409: CALL_OW 310
51413: ST_TO_ADDR
// if GetType ( in_unit ) = unit_vehicle then
51414: LD_VAR 0 11
51418: PPUSH
51419: CALL_OW 247
51423: PUSH
51424: LD_INT 2
51426: EQUAL
51427: IFFALSE 51431
// exit ;
51429: GO 51941
// tmp := FilterAllUnits ( [ [ f_enemy , side ] , [ f_not , [ f_type , unit_building ] ] ] ) ;
51431: LD_ADDR_VAR 0 8
51435: PUSH
51436: LD_INT 81
51438: PUSH
51439: LD_VAR 0 9
51443: PUSH
51444: EMPTY
51445: LIST
51446: LIST
51447: PUSH
51448: LD_INT 3
51450: PUSH
51451: LD_INT 21
51453: PUSH
51454: LD_INT 3
51456: PUSH
51457: EMPTY
51458: LIST
51459: LIST
51460: PUSH
51461: EMPTY
51462: LIST
51463: LIST
51464: PUSH
51465: EMPTY
51466: LIST
51467: LIST
51468: PPUSH
51469: CALL_OW 69
51473: ST_TO_ADDR
// if not tmp then
51474: LD_VAR 0 8
51478: NOT
51479: IFFALSE 51483
// exit ;
51481: GO 51941
// if in_unit then
51483: LD_VAR 0 11
51487: IFFALSE 51511
// enemy := NearestUnitToUnit ( tmp , in_unit ) else
51489: LD_ADDR_VAR 0 10
51493: PUSH
51494: LD_VAR 0 8
51498: PPUSH
51499: LD_VAR 0 11
51503: PPUSH
51504: CALL_OW 74
51508: ST_TO_ADDR
51509: GO 51531
// enemy := NearestUnitToUnit ( tmp , unit ) ;
51511: LD_ADDR_VAR 0 10
51515: PUSH
51516: LD_VAR 0 8
51520: PPUSH
51521: LD_VAR 0 1
51525: PPUSH
51526: CALL_OW 74
51530: ST_TO_ADDR
// if not enemy then
51531: LD_VAR 0 10
51535: NOT
51536: IFFALSE 51540
// exit ;
51538: GO 51941
// if ( in_unit and GetDistUnits ( in_unit , enemy ) > 13 ) or GetDistUnits ( unit , enemy ) > 12 then
51540: LD_VAR 0 11
51544: PUSH
51545: LD_VAR 0 11
51549: PPUSH
51550: LD_VAR 0 10
51554: PPUSH
51555: CALL_OW 296
51559: PUSH
51560: LD_INT 13
51562: GREATER
51563: AND
51564: PUSH
51565: LD_VAR 0 1
51569: PPUSH
51570: LD_VAR 0 10
51574: PPUSH
51575: CALL_OW 296
51579: PUSH
51580: LD_INT 12
51582: GREATER
51583: OR
51584: IFFALSE 51588
// exit ;
51586: GO 51941
// missile := [ 1 ] ;
51588: LD_ADDR_VAR 0 14
51592: PUSH
51593: LD_INT 1
51595: PUSH
51596: EMPTY
51597: LIST
51598: ST_TO_ADDR
// if Researched ( side , tech_space ) then
51599: LD_VAR 0 9
51603: PPUSH
51604: LD_VAR 0 12
51608: PPUSH
51609: CALL_OW 325
51613: IFFALSE 51642
// missile := Insert ( missile , missile + 1 , 2 ) ;
51615: LD_ADDR_VAR 0 14
51619: PUSH
51620: LD_VAR 0 14
51624: PPUSH
51625: LD_VAR 0 14
51629: PUSH
51630: LD_INT 1
51632: PLUS
51633: PPUSH
51634: LD_INT 2
51636: PPUSH
51637: CALL_OW 2
51641: ST_TO_ADDR
// if Researched ( side , tech_time ) and not Researched ( GetSide ( enemy ) , tech_time ) then
51642: LD_VAR 0 9
51646: PPUSH
51647: LD_VAR 0 13
51651: PPUSH
51652: CALL_OW 325
51656: PUSH
51657: LD_VAR 0 10
51661: PPUSH
51662: CALL_OW 255
51666: PPUSH
51667: LD_VAR 0 13
51671: PPUSH
51672: CALL_OW 325
51676: NOT
51677: AND
51678: IFFALSE 51707
// missile := Insert ( missile , missile + 1 , 3 ) ;
51680: LD_ADDR_VAR 0 14
51684: PUSH
51685: LD_VAR 0 14
51689: PPUSH
51690: LD_VAR 0 14
51694: PUSH
51695: LD_INT 1
51697: PLUS
51698: PPUSH
51699: LD_INT 3
51701: PPUSH
51702: CALL_OW 2
51706: ST_TO_ADDR
// if missile < 2 then
51707: LD_VAR 0 14
51711: PUSH
51712: LD_INT 2
51714: LESS
51715: IFFALSE 51719
// exit ;
51717: GO 51941
// x := GetX ( enemy ) ;
51719: LD_ADDR_VAR 0 4
51723: PUSH
51724: LD_VAR 0 10
51728: PPUSH
51729: CALL_OW 250
51733: ST_TO_ADDR
// y := GetY ( enemy ) ;
51734: LD_ADDR_VAR 0 5
51738: PUSH
51739: LD_VAR 0 10
51743: PPUSH
51744: CALL_OW 251
51748: ST_TO_ADDR
// _x := x + rand ( - 1 , 1 ) ;
51749: LD_ADDR_VAR 0 6
51753: PUSH
51754: LD_VAR 0 4
51758: PUSH
51759: LD_INT 1
51761: NEG
51762: PPUSH
51763: LD_INT 1
51765: PPUSH
51766: CALL_OW 12
51770: PLUS
51771: ST_TO_ADDR
// _y := y + rand ( - 1 , 1 ) ;
51772: LD_ADDR_VAR 0 7
51776: PUSH
51777: LD_VAR 0 5
51781: PUSH
51782: LD_INT 1
51784: NEG
51785: PPUSH
51786: LD_INT 1
51788: PPUSH
51789: CALL_OW 12
51793: PLUS
51794: ST_TO_ADDR
// if not ValidHex ( _x , _y ) then
51795: LD_VAR 0 6
51799: PPUSH
51800: LD_VAR 0 7
51804: PPUSH
51805: CALL_OW 488
51809: NOT
51810: IFFALSE 51832
// begin _x := x ;
51812: LD_ADDR_VAR 0 6
51816: PUSH
51817: LD_VAR 0 4
51821: ST_TO_ADDR
// _y := y ;
51822: LD_ADDR_VAR 0 7
51826: PUSH
51827: LD_VAR 0 5
51831: ST_TO_ADDR
// end ; i := rand ( 1 , missile ) ;
51832: LD_ADDR_VAR 0 3
51836: PUSH
51837: LD_INT 1
51839: PPUSH
51840: LD_VAR 0 14
51844: PPUSH
51845: CALL_OW 12
51849: ST_TO_ADDR
// case i of 1 :
51850: LD_VAR 0 3
51854: PUSH
51855: LD_INT 1
51857: DOUBLE
51858: EQUAL
51859: IFTRUE 51863
51861: GO 51880
51863: POP
// ComAttackUnit ( unit , enemy ) ; 2 :
51864: LD_VAR 0 1
51868: PPUSH
51869: LD_VAR 0 10
51873: PPUSH
51874: CALL_OW 115
51878: GO 51941
51880: LD_INT 2
51882: DOUBLE
51883: EQUAL
51884: IFTRUE 51888
51886: GO 51910
51888: POP
// ComSpaceShift ( unit , _x , _y ) ; 3 :
51889: LD_VAR 0 1
51893: PPUSH
51894: LD_VAR 0 6
51898: PPUSH
51899: LD_VAR 0 7
51903: PPUSH
51904: CALL_OW 153
51908: GO 51941
51910: LD_INT 3
51912: DOUBLE
51913: EQUAL
51914: IFTRUE 51918
51916: GO 51940
51918: POP
// ComTimeShift ( unit , _x , _y ) ; end ;
51919: LD_VAR 0 1
51923: PPUSH
51924: LD_VAR 0 6
51928: PPUSH
51929: LD_VAR 0 7
51933: PPUSH
51934: CALL_OW 154
51938: GO 51941
51940: POP
// end ;
51941: LD_VAR 0 2
51945: RET
// export function ComStandNearbyBuilding ( unit , building ) ; var i , x , y , _x , _y ; begin
51946: LD_INT 0
51948: PPUSH
51949: PPUSH
51950: PPUSH
51951: PPUSH
51952: PPUSH
51953: PPUSH
// if not unit or not building then
51954: LD_VAR 0 1
51958: NOT
51959: PUSH
51960: LD_VAR 0 2
51964: NOT
51965: OR
51966: IFFALSE 51970
// exit ;
51968: GO 52128
// x := GetX ( building ) ;
51970: LD_ADDR_VAR 0 5
51974: PUSH
51975: LD_VAR 0 2
51979: PPUSH
51980: CALL_OW 250
51984: ST_TO_ADDR
// y := GetY ( building ) ;
51985: LD_ADDR_VAR 0 6
51989: PUSH
51990: LD_VAR 0 2
51994: PPUSH
51995: CALL_OW 251
51999: ST_TO_ADDR
// for i = 0 to 5 do
52000: LD_ADDR_VAR 0 4
52004: PUSH
52005: DOUBLE
52006: LD_INT 0
52008: DEC
52009: ST_TO_ADDR
52010: LD_INT 5
52012: PUSH
52013: FOR_TO
52014: IFFALSE 52126
// begin _x := ShiftX ( x , i , 3 ) ;
52016: LD_ADDR_VAR 0 7
52020: PUSH
52021: LD_VAR 0 5
52025: PPUSH
52026: LD_VAR 0 4
52030: PPUSH
52031: LD_INT 3
52033: PPUSH
52034: CALL_OW 272
52038: ST_TO_ADDR
// _y := ShiftY ( y , i , 3 ) ;
52039: LD_ADDR_VAR 0 8
52043: PUSH
52044: LD_VAR 0 6
52048: PPUSH
52049: LD_VAR 0 4
52053: PPUSH
52054: LD_INT 3
52056: PPUSH
52057: CALL_OW 273
52061: ST_TO_ADDR
// if not ValidHex ( _x , _y ) then
52062: LD_VAR 0 7
52066: PPUSH
52067: LD_VAR 0 8
52071: PPUSH
52072: CALL_OW 488
52076: NOT
52077: IFFALSE 52081
// continue ;
52079: GO 52013
// if HexInfo ( _x , _y ) = 0 then
52081: LD_VAR 0 7
52085: PPUSH
52086: LD_VAR 0 8
52090: PPUSH
52091: CALL_OW 428
52095: PUSH
52096: LD_INT 0
52098: EQUAL
52099: IFFALSE 52124
// begin ComMoveXY ( unit , _x , _y ) ;
52101: LD_VAR 0 1
52105: PPUSH
52106: LD_VAR 0 7
52110: PPUSH
52111: LD_VAR 0 8
52115: PPUSH
52116: CALL_OW 111
// exit ;
52120: POP
52121: POP
52122: GO 52128
// end ; end ;
52124: GO 52013
52126: POP
52127: POP
// end ;
52128: LD_VAR 0 3
52132: RET
// export function ScanBase ( side , base_area ) ; begin
52133: LD_INT 0
52135: PPUSH
// result := FilterUnitsInArea ( base_area , [ f_enemy , side ] ) ;
52136: LD_ADDR_VAR 0 3
52140: PUSH
52141: LD_VAR 0 2
52145: PPUSH
52146: LD_INT 81
52148: PUSH
52149: LD_VAR 0 1
52153: PUSH
52154: EMPTY
52155: LIST
52156: LIST
52157: PPUSH
52158: CALL_OW 70
52162: ST_TO_ADDR
// end ;
52163: LD_VAR 0 3
52167: RET
// export function BasicDefend ( base , solds , area ) ; var enemy , side , i , hex ; begin
52168: LD_INT 0
52170: PPUSH
52171: PPUSH
52172: PPUSH
52173: PPUSH
52174: PPUSH
// if not base or not mc_bases [ base ] or not solds or not area then
52175: LD_VAR 0 1
52179: NOT
52180: PUSH
52181: LD_EXP 76
52185: PUSH
52186: LD_VAR 0 1
52190: ARRAY
52191: NOT
52192: OR
52193: PUSH
52194: LD_VAR 0 2
52198: NOT
52199: OR
52200: PUSH
52201: LD_VAR 0 3
52205: NOT
52206: OR
52207: IFFALSE 52211
// exit ;
52209: GO 52724
// side := mc_sides [ base ] ;
52211: LD_ADDR_VAR 0 6
52215: PUSH
52216: LD_EXP 102
52220: PUSH
52221: LD_VAR 0 1
52225: ARRAY
52226: ST_TO_ADDR
// if not side then
52227: LD_VAR 0 6
52231: NOT
52232: IFFALSE 52236
// exit ;
52234: GO 52724
// for i in solds do
52236: LD_ADDR_VAR 0 7
52240: PUSH
52241: LD_VAR 0 2
52245: PUSH
52246: FOR_IN
52247: IFFALSE 52308
// if GetBType ( IsInUnit ( i ) ) in [ b_bunker , b_breastwork ] then
52249: LD_VAR 0 7
52253: PPUSH
52254: CALL_OW 310
52258: PPUSH
52259: CALL_OW 266
52263: PUSH
52264: LD_INT 32
52266: PUSH
52267: LD_INT 31
52269: PUSH
52270: EMPTY
52271: LIST
52272: LIST
52273: IN
52274: IFFALSE 52294
// solds := solds diff i else
52276: LD_ADDR_VAR 0 2
52280: PUSH
52281: LD_VAR 0 2
52285: PUSH
52286: LD_VAR 0 7
52290: DIFF
52291: ST_TO_ADDR
52292: GO 52306
// SetTag ( i , 18 ) ;
52294: LD_VAR 0 7
52298: PPUSH
52299: LD_INT 18
52301: PPUSH
52302: CALL_OW 109
52306: GO 52246
52308: POP
52309: POP
// if not solds then
52310: LD_VAR 0 2
52314: NOT
52315: IFFALSE 52319
// exit ;
52317: GO 52724
// repeat wait ( 0 0$1 ) ;
52319: LD_INT 35
52321: PPUSH
52322: CALL_OW 67
// enemy := ScanBase ( side , area ) ;
52326: LD_ADDR_VAR 0 5
52330: PUSH
52331: LD_VAR 0 6
52335: PPUSH
52336: LD_VAR 0 3
52340: PPUSH
52341: CALL 52133 0 2
52345: ST_TO_ADDR
// if not mc_bases [ base ] or mc_bases [ base ] = [ ] then
52346: LD_EXP 76
52350: PUSH
52351: LD_VAR 0 1
52355: ARRAY
52356: NOT
52357: PUSH
52358: LD_EXP 76
52362: PUSH
52363: LD_VAR 0 1
52367: ARRAY
52368: PUSH
52369: EMPTY
52370: EQUAL
52371: OR
52372: IFFALSE 52409
// begin for i in solds do
52374: LD_ADDR_VAR 0 7
52378: PUSH
52379: LD_VAR 0 2
52383: PUSH
52384: FOR_IN
52385: IFFALSE 52398
// ComStop ( i ) ;
52387: LD_VAR 0 7
52391: PPUSH
52392: CALL_OW 141
52396: GO 52384
52398: POP
52399: POP
// solds := [ ] ;
52400: LD_ADDR_VAR 0 2
52404: PUSH
52405: EMPTY
52406: ST_TO_ADDR
// exit ;
52407: GO 52724
// end ; if not enemy or enemy > 3 or mc_defender [ base ] then
52409: LD_VAR 0 5
52413: NOT
52414: PUSH
52415: LD_VAR 0 5
52419: PUSH
52420: LD_INT 3
52422: GREATER
52423: OR
52424: PUSH
52425: LD_EXP 98
52429: PUSH
52430: LD_VAR 0 1
52434: ARRAY
52435: OR
52436: IFFALSE 52477
// begin for i in solds do
52438: LD_ADDR_VAR 0 7
52442: PUSH
52443: LD_VAR 0 2
52447: PUSH
52448: FOR_IN
52449: IFFALSE 52473
// if HasTask ( i ) then
52451: LD_VAR 0 7
52455: PPUSH
52456: CALL_OW 314
52460: IFFALSE 52471
// ComStop ( i ) ;
52462: LD_VAR 0 7
52466: PPUSH
52467: CALL_OW 141
52471: GO 52448
52473: POP
52474: POP
// break ;
52475: GO 52712
// end ; for i in solds do
52477: LD_ADDR_VAR 0 7
52481: PUSH
52482: LD_VAR 0 2
52486: PUSH
52487: FOR_IN
52488: IFFALSE 52704
// begin if IsInUnit ( i ) then
52490: LD_VAR 0 7
52494: PPUSH
52495: CALL_OW 310
52499: IFFALSE 52510
// ComExitBuilding ( i ) ;
52501: LD_VAR 0 7
52505: PPUSH
52506: CALL_OW 122
// if GetLives ( i ) > 333 then
52510: LD_VAR 0 7
52514: PPUSH
52515: CALL_OW 256
52519: PUSH
52520: LD_INT 333
52522: GREATER
52523: IFFALSE 52551
// ComAttackUnit ( i , NearestUnitToUnit ( enemy , i ) ) else
52525: LD_VAR 0 7
52529: PPUSH
52530: LD_VAR 0 5
52534: PPUSH
52535: LD_VAR 0 7
52539: PPUSH
52540: CALL_OW 74
52544: PPUSH
52545: CALL_OW 115
52549: GO 52702
// begin hex := NearestUnitToUnit ( UnitFilter ( mc_bases [ base ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] , [ f_btype , b_lab ] ] ) , i ) ;
52551: LD_ADDR_VAR 0 8
52555: PUSH
52556: LD_EXP 76
52560: PUSH
52561: LD_VAR 0 1
52565: ARRAY
52566: PPUSH
52567: LD_INT 2
52569: PUSH
52570: LD_INT 30
52572: PUSH
52573: LD_INT 0
52575: PUSH
52576: EMPTY
52577: LIST
52578: LIST
52579: PUSH
52580: LD_INT 30
52582: PUSH
52583: LD_INT 1
52585: PUSH
52586: EMPTY
52587: LIST
52588: LIST
52589: PUSH
52590: LD_INT 30
52592: PUSH
52593: LD_INT 6
52595: PUSH
52596: EMPTY
52597: LIST
52598: LIST
52599: PUSH
52600: EMPTY
52601: LIST
52602: LIST
52603: LIST
52604: LIST
52605: PPUSH
52606: CALL_OW 72
52610: PPUSH
52611: LD_VAR 0 7
52615: PPUSH
52616: CALL_OW 74
52620: ST_TO_ADDR
// ComMoveXY ( i , ShiftX ( GetX ( hex ) , 3 , 5 ) , ShiftY ( GetY ( hex ) , 3 , 5 ) ) ;
52621: LD_VAR 0 7
52625: PPUSH
52626: LD_VAR 0 8
52630: PPUSH
52631: CALL_OW 250
52635: PPUSH
52636: LD_INT 3
52638: PPUSH
52639: LD_INT 5
52641: PPUSH
52642: CALL_OW 272
52646: PPUSH
52647: LD_VAR 0 8
52651: PPUSH
52652: CALL_OW 251
52656: PPUSH
52657: LD_INT 3
52659: PPUSH
52660: LD_INT 5
52662: PPUSH
52663: CALL_OW 273
52667: PPUSH
52668: CALL_OW 111
// SetTag ( i , 0 ) ;
52672: LD_VAR 0 7
52676: PPUSH
52677: LD_INT 0
52679: PPUSH
52680: CALL_OW 109
// solds := solds diff i ;
52684: LD_ADDR_VAR 0 2
52688: PUSH
52689: LD_VAR 0 2
52693: PUSH
52694: LD_VAR 0 7
52698: DIFF
52699: ST_TO_ADDR
// continue ;
52700: GO 52487
// end ; end ;
52702: GO 52487
52704: POP
52705: POP
// until solds ;
52706: LD_VAR 0 2
52710: IFFALSE 52319
// MC_Reset ( base , 18 ) ;
52712: LD_VAR 0 1
52716: PPUSH
52717: LD_INT 18
52719: PPUSH
52720: CALL 24545 0 2
// end ;
52724: LD_VAR 0 4
52728: RET
// export function Defend ( base , defenders , enemy ) ; var i , j , x , depot , solds , mech , un , tmp , mechs , e , fac , components , depot_under_attack , sold_defenders , b , can_defend ; begin
52729: LD_INT 0
52731: PPUSH
52732: PPUSH
52733: PPUSH
52734: PPUSH
52735: PPUSH
52736: PPUSH
52737: PPUSH
52738: PPUSH
52739: PPUSH
52740: PPUSH
52741: PPUSH
52742: PPUSH
52743: PPUSH
52744: PPUSH
52745: PPUSH
52746: PPUSH
52747: PPUSH
// mechs := UnitFilter ( mc_bases [ base ] , [ f_class , 3 ] ) ;
52748: LD_ADDR_VAR 0 13
52752: PUSH
52753: LD_EXP 76
52757: PUSH
52758: LD_VAR 0 1
52762: ARRAY
52763: PPUSH
52764: LD_INT 25
52766: PUSH
52767: LD_INT 3
52769: PUSH
52770: EMPTY
52771: LIST
52772: LIST
52773: PPUSH
52774: CALL_OW 72
52778: ST_TO_ADDR
// if mc_remote_driver [ base ] then
52779: LD_EXP 116
52783: PUSH
52784: LD_VAR 0 1
52788: ARRAY
52789: IFFALSE 52813
// mechs := mechs diff mc_remote_driver [ base ] ;
52791: LD_ADDR_VAR 0 13
52795: PUSH
52796: LD_VAR 0 13
52800: PUSH
52801: LD_EXP 116
52805: PUSH
52806: LD_VAR 0 1
52810: ARRAY
52811: DIFF
52812: ST_TO_ADDR
// for i in mechs do
52813: LD_ADDR_VAR 0 5
52817: PUSH
52818: LD_VAR 0 13
52822: PUSH
52823: FOR_IN
52824: IFFALSE 52859
// if GetTag ( i ) > 0 then
52826: LD_VAR 0 5
52830: PPUSH
52831: CALL_OW 110
52835: PUSH
52836: LD_INT 0
52838: GREATER
52839: IFFALSE 52857
// mechs := mechs diff i ;
52841: LD_ADDR_VAR 0 13
52845: PUSH
52846: LD_VAR 0 13
52850: PUSH
52851: LD_VAR 0 5
52855: DIFF
52856: ST_TO_ADDR
52857: GO 52823
52859: POP
52860: POP
// solds := UnitFilter ( mc_bases [ base ] , [ f_or , [ f_class , 1 ] , [ f_class , 5 ] , [ f_class , 8 ] , [ f_class , 9 ] ] ) ;
52861: LD_ADDR_VAR 0 9
52865: PUSH
52866: LD_EXP 76
52870: PUSH
52871: LD_VAR 0 1
52875: ARRAY
52876: PPUSH
52877: LD_INT 2
52879: PUSH
52880: LD_INT 25
52882: PUSH
52883: LD_INT 1
52885: PUSH
52886: EMPTY
52887: LIST
52888: LIST
52889: PUSH
52890: LD_INT 25
52892: PUSH
52893: LD_INT 5
52895: PUSH
52896: EMPTY
52897: LIST
52898: LIST
52899: PUSH
52900: LD_INT 25
52902: PUSH
52903: LD_INT 8
52905: PUSH
52906: EMPTY
52907: LIST
52908: LIST
52909: PUSH
52910: LD_INT 25
52912: PUSH
52913: LD_INT 9
52915: PUSH
52916: EMPTY
52917: LIST
52918: LIST
52919: PUSH
52920: EMPTY
52921: LIST
52922: LIST
52923: LIST
52924: LIST
52925: LIST
52926: PPUSH
52927: CALL_OW 72
52931: ST_TO_ADDR
// if not defenders and not solds then
52932: LD_VAR 0 2
52936: NOT
52937: PUSH
52938: LD_VAR 0 9
52942: NOT
52943: AND
52944: IFFALSE 52948
// exit ;
52946: GO 54574
// depot_under_attack := false ;
52948: LD_ADDR_VAR 0 17
52952: PUSH
52953: LD_INT 0
52955: ST_TO_ADDR
// sold_defenders := [ ] ;
52956: LD_ADDR_VAR 0 18
52960: PUSH
52961: EMPTY
52962: ST_TO_ADDR
// if mechs then
52963: LD_VAR 0 13
52967: IFFALSE 53096
// for i in defenders do
52969: LD_ADDR_VAR 0 5
52973: PUSH
52974: LD_VAR 0 2
52978: PUSH
52979: FOR_IN
52980: IFFALSE 53094
// begin SetTag ( i , 20 ) ;
52982: LD_VAR 0 5
52986: PPUSH
52987: LD_INT 20
52989: PPUSH
52990: CALL_OW 109
// if GetControl ( i ) = control_manual and not IsDrivenBy ( i ) and mechs then
52994: LD_VAR 0 5
52998: PPUSH
52999: CALL_OW 263
53003: PUSH
53004: LD_INT 1
53006: EQUAL
53007: PUSH
53008: LD_VAR 0 5
53012: PPUSH
53013: CALL_OW 311
53017: NOT
53018: AND
53019: PUSH
53020: LD_VAR 0 13
53024: AND
53025: IFFALSE 53092
// begin un := mechs [ 1 ] ;
53027: LD_ADDR_VAR 0 11
53031: PUSH
53032: LD_VAR 0 13
53036: PUSH
53037: LD_INT 1
53039: ARRAY
53040: ST_TO_ADDR
// ComExitBuilding ( un ) ;
53041: LD_VAR 0 11
53045: PPUSH
53046: CALL_OW 122
// AddComEnterUnit ( un , i ) ;
53050: LD_VAR 0 11
53054: PPUSH
53055: LD_VAR 0 5
53059: PPUSH
53060: CALL_OW 180
// SetTag ( un , 19 ) ;
53064: LD_VAR 0 11
53068: PPUSH
53069: LD_INT 19
53071: PPUSH
53072: CALL_OW 109
// mechs := mechs diff un ;
53076: LD_ADDR_VAR 0 13
53080: PUSH
53081: LD_VAR 0 13
53085: PUSH
53086: LD_VAR 0 11
53090: DIFF
53091: ST_TO_ADDR
// end ; end ;
53092: GO 52979
53094: POP
53095: POP
// if solds then
53096: LD_VAR 0 9
53100: IFFALSE 53159
// for i in solds do
53102: LD_ADDR_VAR 0 5
53106: PUSH
53107: LD_VAR 0 9
53111: PUSH
53112: FOR_IN
53113: IFFALSE 53157
// if not GetTag ( i ) then
53115: LD_VAR 0 5
53119: PPUSH
53120: CALL_OW 110
53124: NOT
53125: IFFALSE 53155
// begin defenders := defenders union i ;
53127: LD_ADDR_VAR 0 2
53131: PUSH
53132: LD_VAR 0 2
53136: PUSH
53137: LD_VAR 0 5
53141: UNION
53142: ST_TO_ADDR
// SetTag ( i , 18 ) ;
53143: LD_VAR 0 5
53147: PPUSH
53148: LD_INT 18
53150: PPUSH
53151: CALL_OW 109
// end ;
53155: GO 53112
53157: POP
53158: POP
// repeat wait ( 0 0$1 ) ;
53159: LD_INT 35
53161: PPUSH
53162: CALL_OW 67
// enemy := mc_scan [ base ] ;
53166: LD_ADDR_VAR 0 3
53170: PUSH
53171: LD_EXP 99
53175: PUSH
53176: LD_VAR 0 1
53180: ARRAY
53181: ST_TO_ADDR
// if not mc_bases [ base ] or mc_bases [ base ] = [ ] then
53182: LD_EXP 76
53186: PUSH
53187: LD_VAR 0 1
53191: ARRAY
53192: NOT
53193: PUSH
53194: LD_EXP 76
53198: PUSH
53199: LD_VAR 0 1
53203: ARRAY
53204: PUSH
53205: EMPTY
53206: EQUAL
53207: OR
53208: IFFALSE 53245
// begin for i in defenders do
53210: LD_ADDR_VAR 0 5
53214: PUSH
53215: LD_VAR 0 2
53219: PUSH
53220: FOR_IN
53221: IFFALSE 53234
// ComStop ( i ) ;
53223: LD_VAR 0 5
53227: PPUSH
53228: CALL_OW 141
53232: GO 53220
53234: POP
53235: POP
// defenders := [ ] ;
53236: LD_ADDR_VAR 0 2
53240: PUSH
53241: EMPTY
53242: ST_TO_ADDR
// exit ;
53243: GO 54574
// end ; for i in defenders do
53245: LD_ADDR_VAR 0 5
53249: PUSH
53250: LD_VAR 0 2
53254: PUSH
53255: FOR_IN
53256: IFFALSE 54074
// begin e := NearestUnitToUnit ( enemy , i ) ;
53258: LD_ADDR_VAR 0 14
53262: PUSH
53263: LD_VAR 0 3
53267: PPUSH
53268: LD_VAR 0 5
53272: PPUSH
53273: CALL_OW 74
53277: ST_TO_ADDR
// depot := UnitFilter ( mc_bases [ base ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) ;
53278: LD_ADDR_VAR 0 8
53282: PUSH
53283: LD_EXP 76
53287: PUSH
53288: LD_VAR 0 1
53292: ARRAY
53293: PPUSH
53294: LD_INT 2
53296: PUSH
53297: LD_INT 30
53299: PUSH
53300: LD_INT 0
53302: PUSH
53303: EMPTY
53304: LIST
53305: LIST
53306: PUSH
53307: LD_INT 30
53309: PUSH
53310: LD_INT 1
53312: PUSH
53313: EMPTY
53314: LIST
53315: LIST
53316: PUSH
53317: EMPTY
53318: LIST
53319: LIST
53320: LIST
53321: PPUSH
53322: CALL_OW 72
53326: ST_TO_ADDR
// depot_under_attack := ( not depot or UnitFilter ( depot , [ f_not , [ f_lives , 600 ] ] ) ) ;
53327: LD_ADDR_VAR 0 17
53331: PUSH
53332: LD_VAR 0 8
53336: NOT
53337: PUSH
53338: LD_VAR 0 8
53342: PPUSH
53343: LD_INT 3
53345: PUSH
53346: LD_INT 24
53348: PUSH
53349: LD_INT 600
53351: PUSH
53352: EMPTY
53353: LIST
53354: LIST
53355: PUSH
53356: EMPTY
53357: LIST
53358: LIST
53359: PPUSH
53360: CALL_OW 72
53364: OR
53365: ST_TO_ADDR
// case GetType ( i ) of unit_vehicle :
53366: LD_VAR 0 5
53370: PPUSH
53371: CALL_OW 247
53375: PUSH
53376: LD_INT 2
53378: DOUBLE
53379: EQUAL
53380: IFTRUE 53384
53382: GO 53780
53384: POP
// begin if GetLives ( i ) > 650 and ( GetDistUnits ( i , e ) < 40 or IsInArea ( e , mc_scan_area [ base ] ) ) then
53385: LD_VAR 0 5
53389: PPUSH
53390: CALL_OW 256
53394: PUSH
53395: LD_INT 650
53397: GREATER
53398: PUSH
53399: LD_VAR 0 5
53403: PPUSH
53404: LD_VAR 0 14
53408: PPUSH
53409: CALL_OW 296
53413: PUSH
53414: LD_INT 40
53416: LESS
53417: PUSH
53418: LD_VAR 0 14
53422: PPUSH
53423: LD_EXP 101
53427: PUSH
53428: LD_VAR 0 1
53432: ARRAY
53433: PPUSH
53434: CALL_OW 308
53438: OR
53439: AND
53440: IFFALSE 53562
// begin if GetEngine ( i ) = engine_combustion and GetFuel ( i ) < 30 and depot then
53442: LD_VAR 0 5
53446: PPUSH
53447: CALL_OW 262
53451: PUSH
53452: LD_INT 1
53454: EQUAL
53455: PUSH
53456: LD_VAR 0 5
53460: PPUSH
53461: CALL_OW 261
53465: PUSH
53466: LD_INT 30
53468: LESS
53469: AND
53470: PUSH
53471: LD_VAR 0 8
53475: AND
53476: IFFALSE 53546
// begin ComMoveUnit ( i , NearestUnitToUnit ( depot , i ) ) ;
53478: LD_VAR 0 5
53482: PPUSH
53483: LD_VAR 0 8
53487: PPUSH
53488: LD_VAR 0 5
53492: PPUSH
53493: CALL_OW 74
53497: PPUSH
53498: CALL_OW 112
// if GetDistUnits ( i , NearestUnitToUnit ( depot , i ) ) < 6 then
53502: LD_VAR 0 5
53506: PPUSH
53507: LD_VAR 0 8
53511: PPUSH
53512: LD_VAR 0 5
53516: PPUSH
53517: CALL_OW 74
53521: PPUSH
53522: CALL_OW 296
53526: PUSH
53527: LD_INT 6
53529: LESS
53530: IFFALSE 53544
// SetFuel ( i , 100 ) ;
53532: LD_VAR 0 5
53536: PPUSH
53537: LD_INT 100
53539: PPUSH
53540: CALL_OW 240
// end else
53544: GO 53560
// ComAttackUnit ( i , e ) ;
53546: LD_VAR 0 5
53550: PPUSH
53551: LD_VAR 0 14
53555: PPUSH
53556: CALL_OW 115
// end else
53560: GO 53663
// if ( ( not IsInArea ( e , mc_scan_area [ base ] ) and GetDistUnits ( i , e ) >= 40 ) or GetLives ( i ) <= 650 ) and not IsInArea ( i , mc_parking [ base ] ) then
53562: LD_VAR 0 14
53566: PPUSH
53567: LD_EXP 101
53571: PUSH
53572: LD_VAR 0 1
53576: ARRAY
53577: PPUSH
53578: CALL_OW 308
53582: NOT
53583: PUSH
53584: LD_VAR 0 5
53588: PPUSH
53589: LD_VAR 0 14
53593: PPUSH
53594: CALL_OW 296
53598: PUSH
53599: LD_INT 40
53601: GREATEREQUAL
53602: AND
53603: PUSH
53604: LD_VAR 0 5
53608: PPUSH
53609: CALL_OW 256
53613: PUSH
53614: LD_INT 650
53616: LESSEQUAL
53617: OR
53618: PUSH
53619: LD_VAR 0 5
53623: PPUSH
53624: LD_EXP 100
53628: PUSH
53629: LD_VAR 0 1
53633: ARRAY
53634: PPUSH
53635: CALL_OW 308
53639: NOT
53640: AND
53641: IFFALSE 53663
// ComMoveToArea ( i , mc_parking [ base ] ) ;
53643: LD_VAR 0 5
53647: PPUSH
53648: LD_EXP 100
53652: PUSH
53653: LD_VAR 0 1
53657: ARRAY
53658: PPUSH
53659: CALL_OW 113
// if GetLives ( i ) < 998 and GetControl ( i ) = control_manual and IsDrivenBy ( i ) and IsInArea ( i , mc_parking [ base ] ) then
53663: LD_VAR 0 5
53667: PPUSH
53668: CALL_OW 256
53672: PUSH
53673: LD_INT 998
53675: LESS
53676: PUSH
53677: LD_VAR 0 5
53681: PPUSH
53682: CALL_OW 263
53686: PUSH
53687: LD_INT 1
53689: EQUAL
53690: AND
53691: PUSH
53692: LD_VAR 0 5
53696: PPUSH
53697: CALL_OW 311
53701: AND
53702: PUSH
53703: LD_VAR 0 5
53707: PPUSH
53708: LD_EXP 100
53712: PUSH
53713: LD_VAR 0 1
53717: ARRAY
53718: PPUSH
53719: CALL_OW 308
53723: AND
53724: IFFALSE 53778
// begin mech := IsDrivenBy ( i ) ;
53726: LD_ADDR_VAR 0 10
53730: PUSH
53731: LD_VAR 0 5
53735: PPUSH
53736: CALL_OW 311
53740: ST_TO_ADDR
// ComExitVehicle ( mech ) ;
53741: LD_VAR 0 10
53745: PPUSH
53746: CALL_OW 121
// AddComRepairVehicle ( mech , i ) ;
53750: LD_VAR 0 10
53754: PPUSH
53755: LD_VAR 0 5
53759: PPUSH
53760: CALL_OW 189
// AddComEnterUnit ( mech , i ) ;
53764: LD_VAR 0 10
53768: PPUSH
53769: LD_VAR 0 5
53773: PPUSH
53774: CALL_OW 180
// end ; end ; unit_human :
53778: GO 54045
53780: LD_INT 1
53782: DOUBLE
53783: EQUAL
53784: IFTRUE 53788
53786: GO 54044
53788: POP
// begin b := IsInUnit ( i ) ;
53789: LD_ADDR_VAR 0 19
53793: PUSH
53794: LD_VAR 0 5
53798: PPUSH
53799: CALL_OW 310
53803: ST_TO_ADDR
// can_defend := ( not b or GetBType ( b ) in [ b_bunker , b_breastwork ] ) ;
53804: LD_ADDR_VAR 0 20
53808: PUSH
53809: LD_VAR 0 19
53813: NOT
53814: PUSH
53815: LD_VAR 0 19
53819: PPUSH
53820: CALL_OW 266
53824: PUSH
53825: LD_INT 32
53827: PUSH
53828: LD_INT 31
53830: PUSH
53831: EMPTY
53832: LIST
53833: LIST
53834: IN
53835: OR
53836: ST_TO_ADDR
// if ( depot_under_attack or UnitFilter ( defenders , [ f_type , unit_vehicle ] ) <= 1 ) and can_defend and not i in sold_defenders then
53837: LD_VAR 0 17
53841: PUSH
53842: LD_VAR 0 2
53846: PPUSH
53847: LD_INT 21
53849: PUSH
53850: LD_INT 2
53852: PUSH
53853: EMPTY
53854: LIST
53855: LIST
53856: PPUSH
53857: CALL_OW 72
53861: PUSH
53862: LD_INT 1
53864: LESSEQUAL
53865: OR
53866: PUSH
53867: LD_VAR 0 20
53871: AND
53872: PUSH
53873: LD_VAR 0 5
53877: PUSH
53878: LD_VAR 0 18
53882: IN
53883: NOT
53884: AND
53885: IFFALSE 53978
// begin if b then
53887: LD_VAR 0 19
53891: IFFALSE 53940
// if GetDistUnits ( b , NearestUnitToUnit ( enemy , b ) ) < 10 and BuildingStatus ( b ) <> bs_need_power then
53893: LD_VAR 0 19
53897: PPUSH
53898: LD_VAR 0 3
53902: PPUSH
53903: LD_VAR 0 19
53907: PPUSH
53908: CALL_OW 74
53912: PPUSH
53913: CALL_OW 296
53917: PUSH
53918: LD_INT 10
53920: LESS
53921: PUSH
53922: LD_VAR 0 19
53926: PPUSH
53927: CALL_OW 461
53931: PUSH
53932: LD_INT 7
53934: NONEQUAL
53935: AND
53936: IFFALSE 53940
// continue ;
53938: GO 53255
// sold_defenders := Replace ( sold_defenders , sold_defenders + 1 , i ) ;
53940: LD_ADDR_VAR 0 18
53944: PUSH
53945: LD_VAR 0 18
53949: PPUSH
53950: LD_VAR 0 18
53954: PUSH
53955: LD_INT 1
53957: PLUS
53958: PPUSH
53959: LD_VAR 0 5
53963: PPUSH
53964: CALL_OW 1
53968: ST_TO_ADDR
// ComExitBuilding ( i ) ;
53969: LD_VAR 0 5
53973: PPUSH
53974: CALL_OW 122
// end ; if sold_defenders then
53978: LD_VAR 0 18
53982: IFFALSE 54042
// if i in sold_defenders then
53984: LD_VAR 0 5
53988: PUSH
53989: LD_VAR 0 18
53993: IN
53994: IFFALSE 54042
// begin if not HasTask ( i ) and GetDistUnits ( i , e ) < 30 then
53996: LD_VAR 0 5
54000: PPUSH
54001: CALL_OW 314
54005: NOT
54006: PUSH
54007: LD_VAR 0 5
54011: PPUSH
54012: LD_VAR 0 14
54016: PPUSH
54017: CALL_OW 296
54021: PUSH
54022: LD_INT 30
54024: LESS
54025: AND
54026: IFFALSE 54042
// ComAttackUnit ( i , e ) ;
54028: LD_VAR 0 5
54032: PPUSH
54033: LD_VAR 0 14
54037: PPUSH
54038: CALL_OW 115
// end ; end ; end ;
54042: GO 54045
54044: POP
// if IsDead ( i ) then
54045: LD_VAR 0 5
54049: PPUSH
54050: CALL_OW 301
54054: IFFALSE 54072
// defenders := defenders diff i ;
54056: LD_ADDR_VAR 0 2
54060: PUSH
54061: LD_VAR 0 2
54065: PUSH
54066: LD_VAR 0 5
54070: DIFF
54071: ST_TO_ADDR
// end ;
54072: GO 53255
54074: POP
54075: POP
// until not enemy or not defenders or not mc_bases [ base ] ;
54076: LD_VAR 0 3
54080: NOT
54081: PUSH
54082: LD_VAR 0 2
54086: NOT
54087: OR
54088: PUSH
54089: LD_EXP 76
54093: PUSH
54094: LD_VAR 0 1
54098: ARRAY
54099: NOT
54100: OR
54101: IFFALSE 53159
// MC_Reset ( base , 18 ) ;
54103: LD_VAR 0 1
54107: PPUSH
54108: LD_INT 18
54110: PPUSH
54111: CALL 24545 0 2
// defenders := defenders diff UnitFilter ( defenders , [ f_or , [ f_class , 1 ] , [ f_class , 5 ] , [ f_class , 8 ] , [ f_class , 9 ] ] ) ;
54115: LD_ADDR_VAR 0 2
54119: PUSH
54120: LD_VAR 0 2
54124: PUSH
54125: LD_VAR 0 2
54129: PPUSH
54130: LD_INT 2
54132: PUSH
54133: LD_INT 25
54135: PUSH
54136: LD_INT 1
54138: PUSH
54139: EMPTY
54140: LIST
54141: LIST
54142: PUSH
54143: LD_INT 25
54145: PUSH
54146: LD_INT 5
54148: PUSH
54149: EMPTY
54150: LIST
54151: LIST
54152: PUSH
54153: LD_INT 25
54155: PUSH
54156: LD_INT 8
54158: PUSH
54159: EMPTY
54160: LIST
54161: LIST
54162: PUSH
54163: LD_INT 25
54165: PUSH
54166: LD_INT 9
54168: PUSH
54169: EMPTY
54170: LIST
54171: LIST
54172: PUSH
54173: EMPTY
54174: LIST
54175: LIST
54176: LIST
54177: LIST
54178: LIST
54179: PPUSH
54180: CALL_OW 72
54184: DIFF
54185: ST_TO_ADDR
// if not enemy and UnitFilter ( defenders , [ f_type , unit_vehicle ] ) then
54186: LD_VAR 0 3
54190: NOT
54191: PUSH
54192: LD_VAR 0 2
54196: PPUSH
54197: LD_INT 21
54199: PUSH
54200: LD_INT 2
54202: PUSH
54203: EMPTY
54204: LIST
54205: LIST
54206: PPUSH
54207: CALL_OW 72
54211: AND
54212: IFFALSE 54550
// begin tmp := FilterByTag ( defenders , 19 ) ;
54214: LD_ADDR_VAR 0 12
54218: PUSH
54219: LD_VAR 0 2
54223: PPUSH
54224: LD_INT 19
54226: PPUSH
54227: CALL 91006 0 2
54231: ST_TO_ADDR
// if tmp then
54232: LD_VAR 0 12
54236: IFFALSE 54306
// begin tmp := UnitFilter ( tmp , [ f_class , 3 ] ) ;
54238: LD_ADDR_VAR 0 12
54242: PUSH
54243: LD_VAR 0 12
54247: PPUSH
54248: LD_INT 25
54250: PUSH
54251: LD_INT 3
54253: PUSH
54254: EMPTY
54255: LIST
54256: LIST
54257: PPUSH
54258: CALL_OW 72
54262: ST_TO_ADDR
// if tmp then
54263: LD_VAR 0 12
54267: IFFALSE 54306
// mc_repair_vehicle := Replace ( mc_repair_vehicle , base , mc_repair_vehicle [ base ] union tmp ) ;
54269: LD_ADDR_EXP 88
54273: PUSH
54274: LD_EXP 88
54278: PPUSH
54279: LD_VAR 0 1
54283: PPUSH
54284: LD_EXP 88
54288: PUSH
54289: LD_VAR 0 1
54293: ARRAY
54294: PUSH
54295: LD_VAR 0 12
54299: UNION
54300: PPUSH
54301: CALL_OW 1
54305: ST_TO_ADDR
// end ; MC_Reset ( base , 19 ) ;
54306: LD_VAR 0 1
54310: PPUSH
54311: LD_INT 19
54313: PPUSH
54314: CALL 24545 0 2
// repeat wait ( 0 0$1 ) ;
54318: LD_INT 35
54320: PPUSH
54321: CALL_OW 67
// if not mc_bases [ base ] or mc_bases [ base ] = [ ] then
54325: LD_EXP 76
54329: PUSH
54330: LD_VAR 0 1
54334: ARRAY
54335: NOT
54336: PUSH
54337: LD_EXP 76
54341: PUSH
54342: LD_VAR 0 1
54346: ARRAY
54347: PUSH
54348: EMPTY
54349: EQUAL
54350: OR
54351: IFFALSE 54388
// begin for i in defenders do
54353: LD_ADDR_VAR 0 5
54357: PUSH
54358: LD_VAR 0 2
54362: PUSH
54363: FOR_IN
54364: IFFALSE 54377
// ComStop ( i ) ;
54366: LD_VAR 0 5
54370: PPUSH
54371: CALL_OW 141
54375: GO 54363
54377: POP
54378: POP
// defenders := [ ] ;
54379: LD_ADDR_VAR 0 2
54383: PUSH
54384: EMPTY
54385: ST_TO_ADDR
// exit ;
54386: GO 54574
// end ; for i in defenders do
54388: LD_ADDR_VAR 0 5
54392: PUSH
54393: LD_VAR 0 2
54397: PUSH
54398: FOR_IN
54399: IFFALSE 54488
// begin if not IsInArea ( i , mc_parking [ base ] ) then
54401: LD_VAR 0 5
54405: PPUSH
54406: LD_EXP 100
54410: PUSH
54411: LD_VAR 0 1
54415: ARRAY
54416: PPUSH
54417: CALL_OW 308
54421: NOT
54422: IFFALSE 54446
// ComMoveToArea ( i , mc_parking [ base ] ) else
54424: LD_VAR 0 5
54428: PPUSH
54429: LD_EXP 100
54433: PUSH
54434: LD_VAR 0 1
54438: ARRAY
54439: PPUSH
54440: CALL_OW 113
54444: GO 54486
// if GetControl ( i ) = control_manual then
54446: LD_VAR 0 5
54450: PPUSH
54451: CALL_OW 263
54455: PUSH
54456: LD_INT 1
54458: EQUAL
54459: IFFALSE 54486
// if IsDrivenBy ( i ) then
54461: LD_VAR 0 5
54465: PPUSH
54466: CALL_OW 311
54470: IFFALSE 54486
// ComExitVehicle ( IsDrivenBy ( i ) ) ;
54472: LD_VAR 0 5
54476: PPUSH
54477: CALL_OW 311
54481: PPUSH
54482: CALL_OW 121
// end ;
54486: GO 54398
54488: POP
54489: POP
// until UnitFilter ( defenders , [ f_inarea , mc_parking [ base ] ] ) = defenders or mc_scan [ base ] or not mc_bases [ base ] ;
54490: LD_VAR 0 2
54494: PPUSH
54495: LD_INT 95
54497: PUSH
54498: LD_EXP 100
54502: PUSH
54503: LD_VAR 0 1
54507: ARRAY
54508: PUSH
54509: EMPTY
54510: LIST
54511: LIST
54512: PPUSH
54513: CALL_OW 72
54517: PUSH
54518: LD_VAR 0 2
54522: EQUAL
54523: PUSH
54524: LD_EXP 99
54528: PUSH
54529: LD_VAR 0 1
54533: ARRAY
54534: OR
54535: PUSH
54536: LD_EXP 76
54540: PUSH
54541: LD_VAR 0 1
54545: ARRAY
54546: NOT
54547: OR
54548: IFFALSE 54318
// end ; MC_Reset ( base , 19 ) ;
54550: LD_VAR 0 1
54554: PPUSH
54555: LD_INT 19
54557: PPUSH
54558: CALL 24545 0 2
// MC_Reset ( base , 20 ) ;
54562: LD_VAR 0 1
54566: PPUSH
54567: LD_INT 20
54569: PPUSH
54570: CALL 24545 0 2
// end ;
54574: LD_VAR 0 4
54578: RET
// export function AllowSpecClass ( unit ) ; var side , nat , tech ; begin
54579: LD_INT 0
54581: PPUSH
54582: PPUSH
54583: PPUSH
54584: PPUSH
// result := false ;
54585: LD_ADDR_VAR 0 2
54589: PUSH
54590: LD_INT 0
54592: ST_TO_ADDR
// side := GetSide ( unit ) ;
54593: LD_ADDR_VAR 0 3
54597: PUSH
54598: LD_VAR 0 1
54602: PPUSH
54603: CALL_OW 255
54607: ST_TO_ADDR
// nat := GetNation ( unit ) ;
54608: LD_ADDR_VAR 0 4
54612: PUSH
54613: LD_VAR 0 1
54617: PPUSH
54618: CALL_OW 248
54622: ST_TO_ADDR
// case nat of 1 :
54623: LD_VAR 0 4
54627: PUSH
54628: LD_INT 1
54630: DOUBLE
54631: EQUAL
54632: IFTRUE 54636
54634: GO 54647
54636: POP
// tech := tech_lassight ; 2 :
54637: LD_ADDR_VAR 0 5
54641: PUSH
54642: LD_INT 12
54644: ST_TO_ADDR
54645: GO 54686
54647: LD_INT 2
54649: DOUBLE
54650: EQUAL
54651: IFTRUE 54655
54653: GO 54666
54655: POP
// tech := tech_mortar ; 3 :
54656: LD_ADDR_VAR 0 5
54660: PUSH
54661: LD_INT 41
54663: ST_TO_ADDR
54664: GO 54686
54666: LD_INT 3
54668: DOUBLE
54669: EQUAL
54670: IFTRUE 54674
54672: GO 54685
54674: POP
// tech := tech_bazooka ; end ;
54675: LD_ADDR_VAR 0 5
54679: PUSH
54680: LD_INT 44
54682: ST_TO_ADDR
54683: GO 54686
54685: POP
// if Researched ( side , tech ) then
54686: LD_VAR 0 3
54690: PPUSH
54691: LD_VAR 0 5
54695: PPUSH
54696: CALL_OW 325
54700: IFFALSE 54727
// result := [ class_sniper , class_mortar , class_bazooker ] [ nat ] ;
54702: LD_ADDR_VAR 0 2
54706: PUSH
54707: LD_INT 5
54709: PUSH
54710: LD_INT 8
54712: PUSH
54713: LD_INT 9
54715: PUSH
54716: EMPTY
54717: LIST
54718: LIST
54719: LIST
54720: PUSH
54721: LD_VAR 0 4
54725: ARRAY
54726: ST_TO_ADDR
// end ;
54727: LD_VAR 0 2
54731: RET
// export function DetonateMines ( side , mines ) ; var i , tmp ; begin
54732: LD_INT 0
54734: PPUSH
54735: PPUSH
54736: PPUSH
// if not mines then
54737: LD_VAR 0 2
54741: NOT
54742: IFFALSE 54746
// exit ;
54744: GO 54890
// tmp := FilterAllUnits ( [ [ f_enemy , side ] , [ f_not , [ f_type , unit_building ] ] ] ) ;
54746: LD_ADDR_VAR 0 5
54750: PUSH
54751: LD_INT 81
54753: PUSH
54754: LD_VAR 0 1
54758: PUSH
54759: EMPTY
54760: LIST
54761: LIST
54762: PUSH
54763: LD_INT 3
54765: PUSH
54766: LD_INT 21
54768: PUSH
54769: LD_INT 3
54771: PUSH
54772: EMPTY
54773: LIST
54774: LIST
54775: PUSH
54776: EMPTY
54777: LIST
54778: LIST
54779: PUSH
54780: EMPTY
54781: LIST
54782: LIST
54783: PPUSH
54784: CALL_OW 69
54788: ST_TO_ADDR
// for i in mines do
54789: LD_ADDR_VAR 0 4
54793: PUSH
54794: LD_VAR 0 2
54798: PUSH
54799: FOR_IN
54800: IFFALSE 54888
// begin if not MineAtPos ( i [ 1 ] , i [ 2 ] ) then
54802: LD_VAR 0 4
54806: PUSH
54807: LD_INT 1
54809: ARRAY
54810: PPUSH
54811: LD_VAR 0 4
54815: PUSH
54816: LD_INT 2
54818: ARRAY
54819: PPUSH
54820: CALL_OW 458
54824: NOT
54825: IFFALSE 54829
// continue ;
54827: GO 54799
// if HexInfo ( i [ 1 ] , i [ 2 ] ) in tmp then
54829: LD_VAR 0 4
54833: PUSH
54834: LD_INT 1
54836: ARRAY
54837: PPUSH
54838: LD_VAR 0 4
54842: PUSH
54843: LD_INT 2
54845: ARRAY
54846: PPUSH
54847: CALL_OW 428
54851: PUSH
54852: LD_VAR 0 5
54856: IN
54857: IFFALSE 54886
// LaunchMineAtPos ( i [ 1 ] , i [ 2 ] , side ) ;
54859: LD_VAR 0 4
54863: PUSH
54864: LD_INT 1
54866: ARRAY
54867: PPUSH
54868: LD_VAR 0 4
54872: PUSH
54873: LD_INT 2
54875: ARRAY
54876: PPUSH
54877: LD_VAR 0 1
54881: PPUSH
54882: CALL_OW 456
// end ;
54886: GO 54799
54888: POP
54889: POP
// end ;
54890: LD_VAR 0 3
54894: RET
// export function Count ( array ) ; var i ; begin
54895: LD_INT 0
54897: PPUSH
54898: PPUSH
// result := 0 ;
54899: LD_ADDR_VAR 0 2
54903: PUSH
54904: LD_INT 0
54906: ST_TO_ADDR
// for i in array do
54907: LD_ADDR_VAR 0 3
54911: PUSH
54912: LD_VAR 0 1
54916: PUSH
54917: FOR_IN
54918: IFFALSE 54942
// if i then
54920: LD_VAR 0 3
54924: IFFALSE 54940
// result := result + 1 ;
54926: LD_ADDR_VAR 0 2
54930: PUSH
54931: LD_VAR 0 2
54935: PUSH
54936: LD_INT 1
54938: PLUS
54939: ST_TO_ADDR
54940: GO 54917
54942: POP
54943: POP
// end ;
54944: LD_VAR 0 2
54948: RET
// export function IsEmpty ( building ) ; begin
54949: LD_INT 0
54951: PPUSH
// if not building then
54952: LD_VAR 0 1
54956: NOT
54957: IFFALSE 54961
// exit ;
54959: GO 55004
// result := building in FilterAllUnits ( [ [ f_side , GetSide ( building ) ] , [ f_empty ] ] ) ;
54961: LD_ADDR_VAR 0 2
54965: PUSH
54966: LD_VAR 0 1
54970: PUSH
54971: LD_INT 22
54973: PUSH
54974: LD_VAR 0 1
54978: PPUSH
54979: CALL_OW 255
54983: PUSH
54984: EMPTY
54985: LIST
54986: LIST
54987: PUSH
54988: LD_INT 58
54990: PUSH
54991: EMPTY
54992: LIST
54993: PUSH
54994: EMPTY
54995: LIST
54996: LIST
54997: PPUSH
54998: CALL_OW 69
55002: IN
55003: ST_TO_ADDR
// end ;
55004: LD_VAR 0 2
55008: RET
// export function IsNotFull ( building ) ; begin
55009: LD_INT 0
55011: PPUSH
// if not building then
55012: LD_VAR 0 1
55016: NOT
55017: IFFALSE 55021
// exit ;
55019: GO 55040
// result := UnitsInside ( building ) < 6 ;
55021: LD_ADDR_VAR 0 2
55025: PUSH
55026: LD_VAR 0 1
55030: PPUSH
55031: CALL_OW 313
55035: PUSH
55036: LD_INT 6
55038: LESS
55039: ST_TO_ADDR
// end ;
55040: LD_VAR 0 2
55044: RET
// export function GetFacExt ( factory ) ; var tmp , i , list ; begin
55045: LD_INT 0
55047: PPUSH
55048: PPUSH
55049: PPUSH
55050: PPUSH
// tmp := [ ] ;
55051: LD_ADDR_VAR 0 3
55055: PUSH
55056: EMPTY
55057: ST_TO_ADDR
// list := [ ] ;
55058: LD_ADDR_VAR 0 5
55062: PUSH
55063: EMPTY
55064: ST_TO_ADDR
// for i = 16 to 25 do
55065: LD_ADDR_VAR 0 4
55069: PUSH
55070: DOUBLE
55071: LD_INT 16
55073: DEC
55074: ST_TO_ADDR
55075: LD_INT 25
55077: PUSH
55078: FOR_TO
55079: IFFALSE 55152
// tmp := tmp ^ FilterAllUnits ( [ [ [ f_side , GetSide ( factory ) ] , [ f_dist , factory , 6 ] , [ f_btype , i ] ] ] ) ;
55081: LD_ADDR_VAR 0 3
55085: PUSH
55086: LD_VAR 0 3
55090: PUSH
55091: LD_INT 22
55093: PUSH
55094: LD_VAR 0 1
55098: PPUSH
55099: CALL_OW 255
55103: PUSH
55104: EMPTY
55105: LIST
55106: LIST
55107: PUSH
55108: LD_INT 91
55110: PUSH
55111: LD_VAR 0 1
55115: PUSH
55116: LD_INT 6
55118: PUSH
55119: EMPTY
55120: LIST
55121: LIST
55122: LIST
55123: PUSH
55124: LD_INT 30
55126: PUSH
55127: LD_VAR 0 4
55131: PUSH
55132: EMPTY
55133: LIST
55134: LIST
55135: PUSH
55136: EMPTY
55137: LIST
55138: LIST
55139: LIST
55140: PUSH
55141: EMPTY
55142: LIST
55143: PPUSH
55144: CALL_OW 69
55148: ADD
55149: ST_TO_ADDR
55150: GO 55078
55152: POP
55153: POP
// for i = 1 to tmp do
55154: LD_ADDR_VAR 0 4
55158: PUSH
55159: DOUBLE
55160: LD_INT 1
55162: DEC
55163: ST_TO_ADDR
55164: LD_VAR 0 3
55168: PUSH
55169: FOR_TO
55170: IFFALSE 55258
// list := list ^ [ [ GetBType ( tmp [ i ] ) , GetX ( tmp [ i ] ) , GetY ( tmp [ i ] ) , GetDir ( tmp [ i ] ) ] ] ;
55172: LD_ADDR_VAR 0 5
55176: PUSH
55177: LD_VAR 0 5
55181: PUSH
55182: LD_VAR 0 3
55186: PUSH
55187: LD_VAR 0 4
55191: ARRAY
55192: PPUSH
55193: CALL_OW 266
55197: PUSH
55198: LD_VAR 0 3
55202: PUSH
55203: LD_VAR 0 4
55207: ARRAY
55208: PPUSH
55209: CALL_OW 250
55213: PUSH
55214: LD_VAR 0 3
55218: PUSH
55219: LD_VAR 0 4
55223: ARRAY
55224: PPUSH
55225: CALL_OW 251
55229: PUSH
55230: LD_VAR 0 3
55234: PUSH
55235: LD_VAR 0 4
55239: ARRAY
55240: PPUSH
55241: CALL_OW 254
55245: PUSH
55246: EMPTY
55247: LIST
55248: LIST
55249: LIST
55250: LIST
55251: PUSH
55252: EMPTY
55253: LIST
55254: ADD
55255: ST_TO_ADDR
55256: GO 55169
55258: POP
55259: POP
// result := list ;
55260: LD_ADDR_VAR 0 2
55264: PUSH
55265: LD_VAR 0 5
55269: ST_TO_ADDR
// end ;
55270: LD_VAR 0 2
55274: RET
// export function Produce ( factory , chassis , engine , control , weapon ) ; var i , tmp , _chassis , _weapon , _engine , _control ; begin
55275: LD_INT 0
55277: PPUSH
55278: PPUSH
55279: PPUSH
55280: PPUSH
55281: PPUSH
55282: PPUSH
55283: PPUSH
// if not factory then
55284: LD_VAR 0 1
55288: NOT
55289: IFFALSE 55293
// exit ;
55291: GO 55886
// if control = control_apeman then
55293: LD_VAR 0 4
55297: PUSH
55298: LD_INT 5
55300: EQUAL
55301: IFFALSE 55410
// begin tmp := UnitsInside ( factory ) ;
55303: LD_ADDR_VAR 0 8
55307: PUSH
55308: LD_VAR 0 1
55312: PPUSH
55313: CALL_OW 313
55317: ST_TO_ADDR
// if not UnitFilter ( tmp , [ f_class , class_apeman ] ) then
55318: LD_VAR 0 8
55322: PPUSH
55323: LD_INT 25
55325: PUSH
55326: LD_INT 12
55328: PUSH
55329: EMPTY
55330: LIST
55331: LIST
55332: PPUSH
55333: CALL_OW 72
55337: NOT
55338: IFFALSE 55348
// control := control_manual ;
55340: LD_ADDR_VAR 0 4
55344: PUSH
55345: LD_INT 1
55347: ST_TO_ADDR
// tmp := GetFacExt ( factory ) ;
55348: LD_ADDR_VAR 0 8
55352: PUSH
55353: LD_VAR 0 1
55357: PPUSH
55358: CALL 55045 0 1
55362: ST_TO_ADDR
// if tmp then
55363: LD_VAR 0 8
55367: IFFALSE 55410
// begin for i in tmp do
55369: LD_ADDR_VAR 0 7
55373: PUSH
55374: LD_VAR 0 8
55378: PUSH
55379: FOR_IN
55380: IFFALSE 55408
// if i [ 1 ] = b_ext_radio then
55382: LD_VAR 0 7
55386: PUSH
55387: LD_INT 1
55389: ARRAY
55390: PUSH
55391: LD_INT 22
55393: EQUAL
55394: IFFALSE 55406
// begin control := control_remote ;
55396: LD_ADDR_VAR 0 4
55400: PUSH
55401: LD_INT 2
55403: ST_TO_ADDR
// break ;
55404: GO 55408
// end ;
55406: GO 55379
55408: POP
55409: POP
// end ; end ; if CanBeConstructed ( factory , chassis , engine , control , weapon ) then
55410: LD_VAR 0 1
55414: PPUSH
55415: LD_VAR 0 2
55419: PPUSH
55420: LD_VAR 0 3
55424: PPUSH
55425: LD_VAR 0 4
55429: PPUSH
55430: LD_VAR 0 5
55434: PPUSH
55435: CALL_OW 448
55439: IFFALSE 55474
// begin result := [ chassis , engine , control , weapon ] ;
55441: LD_ADDR_VAR 0 6
55445: PUSH
55446: LD_VAR 0 2
55450: PUSH
55451: LD_VAR 0 3
55455: PUSH
55456: LD_VAR 0 4
55460: PUSH
55461: LD_VAR 0 5
55465: PUSH
55466: EMPTY
55467: LIST
55468: LIST
55469: LIST
55470: LIST
55471: ST_TO_ADDR
// exit ;
55472: GO 55886
// end ; _chassis := AvailableChassisList ( factory ) ;
55474: LD_ADDR_VAR 0 9
55478: PUSH
55479: LD_VAR 0 1
55483: PPUSH
55484: CALL_OW 475
55488: ST_TO_ADDR
// _engine := AvailableEngineList ( factory ) ;
55489: LD_ADDR_VAR 0 11
55493: PUSH
55494: LD_VAR 0 1
55498: PPUSH
55499: CALL_OW 476
55503: ST_TO_ADDR
// _control := AvailableControlList ( factory ) ;
55504: LD_ADDR_VAR 0 12
55508: PUSH
55509: LD_VAR 0 1
55513: PPUSH
55514: CALL_OW 477
55518: ST_TO_ADDR
// _weapon := AvailableWeaponList ( factory ) ;
55519: LD_ADDR_VAR 0 10
55523: PUSH
55524: LD_VAR 0 1
55528: PPUSH
55529: CALL_OW 478
55533: ST_TO_ADDR
// if not _chassis or not _engine or not _control or not _weapon then
55534: LD_VAR 0 9
55538: NOT
55539: PUSH
55540: LD_VAR 0 11
55544: NOT
55545: OR
55546: PUSH
55547: LD_VAR 0 12
55551: NOT
55552: OR
55553: PUSH
55554: LD_VAR 0 10
55558: NOT
55559: OR
55560: IFFALSE 55595
// begin result := [ chassis , engine , control , weapon ] ;
55562: LD_ADDR_VAR 0 6
55566: PUSH
55567: LD_VAR 0 2
55571: PUSH
55572: LD_VAR 0 3
55576: PUSH
55577: LD_VAR 0 4
55581: PUSH
55582: LD_VAR 0 5
55586: PUSH
55587: EMPTY
55588: LIST
55589: LIST
55590: LIST
55591: LIST
55592: ST_TO_ADDR
// exit ;
55593: GO 55886
// end ; if not chassis in _chassis then
55595: LD_VAR 0 2
55599: PUSH
55600: LD_VAR 0 9
55604: IN
55605: NOT
55606: IFFALSE 55632
// chassis := _chassis [ rand ( 1 , _chassis ) ] ;
55608: LD_ADDR_VAR 0 2
55612: PUSH
55613: LD_VAR 0 9
55617: PUSH
55618: LD_INT 1
55620: PPUSH
55621: LD_VAR 0 9
55625: PPUSH
55626: CALL_OW 12
55630: ARRAY
55631: ST_TO_ADDR
// if not EngineCanBeMount ( chassis , engine ) then
55632: LD_VAR 0 2
55636: PPUSH
55637: LD_VAR 0 3
55641: PPUSH
55642: CALL 55891 0 2
55646: NOT
55647: IFFALSE 55706
// repeat engine := _engine [ 1 ] ;
55649: LD_ADDR_VAR 0 3
55653: PUSH
55654: LD_VAR 0 11
55658: PUSH
55659: LD_INT 1
55661: ARRAY
55662: ST_TO_ADDR
// _engine := Delete ( _engine , 1 ) ;
55663: LD_ADDR_VAR 0 11
55667: PUSH
55668: LD_VAR 0 11
55672: PPUSH
55673: LD_INT 1
55675: PPUSH
55676: CALL_OW 3
55680: ST_TO_ADDR
// until EngineCanBeMount ( chassis , engine ) or _engine = [ ] ;
55681: LD_VAR 0 2
55685: PPUSH
55686: LD_VAR 0 3
55690: PPUSH
55691: CALL 55891 0 2
55695: PUSH
55696: LD_VAR 0 11
55700: PUSH
55701: EMPTY
55702: EQUAL
55703: OR
55704: IFFALSE 55649
// if not control in _control then
55706: LD_VAR 0 4
55710: PUSH
55711: LD_VAR 0 12
55715: IN
55716: NOT
55717: IFFALSE 55743
// control := _control [ rand ( 1 , _control ) ] ;
55719: LD_ADDR_VAR 0 4
55723: PUSH
55724: LD_VAR 0 12
55728: PUSH
55729: LD_INT 1
55731: PPUSH
55732: LD_VAR 0 12
55736: PPUSH
55737: CALL_OW 12
55741: ARRAY
55742: ST_TO_ADDR
// if not WeaponCanBeMount ( chassis , weapon ) then
55743: LD_VAR 0 2
55747: PPUSH
55748: LD_VAR 0 5
55752: PPUSH
55753: CALL 56111 0 2
55757: NOT
55758: IFFALSE 55817
// repeat weapon := _weapon [ 1 ] ;
55760: LD_ADDR_VAR 0 5
55764: PUSH
55765: LD_VAR 0 10
55769: PUSH
55770: LD_INT 1
55772: ARRAY
55773: ST_TO_ADDR
// _weapon := Delete ( _weapon , 1 ) ;
55774: LD_ADDR_VAR 0 10
55778: PUSH
55779: LD_VAR 0 10
55783: PPUSH
55784: LD_INT 1
55786: PPUSH
55787: CALL_OW 3
55791: ST_TO_ADDR
// until WeaponCanBeMount ( chassis , weapon ) or _weapon = [ ] ;
55792: LD_VAR 0 2
55796: PPUSH
55797: LD_VAR 0 5
55801: PPUSH
55802: CALL 56111 0 2
55806: PUSH
55807: LD_VAR 0 10
55811: PUSH
55812: EMPTY
55813: EQUAL
55814: OR
55815: IFFALSE 55760
// result := [ ] ;
55817: LD_ADDR_VAR 0 6
55821: PUSH
55822: EMPTY
55823: ST_TO_ADDR
// if CanBeConstructed ( factory , chassis , engine , control , weapon ) then
55824: LD_VAR 0 1
55828: PPUSH
55829: LD_VAR 0 2
55833: PPUSH
55834: LD_VAR 0 3
55838: PPUSH
55839: LD_VAR 0 4
55843: PPUSH
55844: LD_VAR 0 5
55848: PPUSH
55849: CALL_OW 448
55853: IFFALSE 55886
// result := [ chassis , engine , control , weapon ] ;
55855: LD_ADDR_VAR 0 6
55859: PUSH
55860: LD_VAR 0 2
55864: PUSH
55865: LD_VAR 0 3
55869: PUSH
55870: LD_VAR 0 4
55874: PUSH
55875: LD_VAR 0 5
55879: PUSH
55880: EMPTY
55881: LIST
55882: LIST
55883: LIST
55884: LIST
55885: ST_TO_ADDR
// end ;
55886: LD_VAR 0 6
55890: RET
// export function EngineCanBeMount ( chassis , engine ) ; begin
55891: LD_INT 0
55893: PPUSH
// if not chassis or not engine then
55894: LD_VAR 0 1
55898: NOT
55899: PUSH
55900: LD_VAR 0 2
55904: NOT
55905: OR
55906: IFFALSE 55910
// exit ;
55908: GO 56106
// case engine of engine_solar :
55910: LD_VAR 0 2
55914: PUSH
55915: LD_INT 2
55917: DOUBLE
55918: EQUAL
55919: IFTRUE 55923
55921: GO 55961
55923: POP
// result := [ ar_hovercraft , ar_light_trike , ar_medium_trike , ar_half_tracked , us_light_wheeled , us_medium_wheeled , us_medium_tracked ] ; engine_combustion :
55924: LD_ADDR_VAR 0 3
55928: PUSH
55929: LD_INT 11
55931: PUSH
55932: LD_INT 12
55934: PUSH
55935: LD_INT 13
55937: PUSH
55938: LD_INT 14
55940: PUSH
55941: LD_INT 1
55943: PUSH
55944: LD_INT 2
55946: PUSH
55947: LD_INT 3
55949: PUSH
55950: EMPTY
55951: LIST
55952: LIST
55953: LIST
55954: LIST
55955: LIST
55956: LIST
55957: LIST
55958: ST_TO_ADDR
55959: GO 56090
55961: LD_INT 1
55963: DOUBLE
55964: EQUAL
55965: IFTRUE 55969
55967: GO 56031
55969: POP
// result := [ ar_hovercraft , ar_light_trike , ar_medium_trike , ar_half_tracked , us_light_wheeled , us_medium_wheeled , us_medium_tracked , us_heavy_tracked , us_morphling , ru_medium_wheeled , ru_heavy_wheeled , ru_medium_tracked , ru_heavy_tracked ] ; engine_siberite :
55970: LD_ADDR_VAR 0 3
55974: PUSH
55975: LD_INT 11
55977: PUSH
55978: LD_INT 12
55980: PUSH
55981: LD_INT 13
55983: PUSH
55984: LD_INT 14
55986: PUSH
55987: LD_INT 1
55989: PUSH
55990: LD_INT 2
55992: PUSH
55993: LD_INT 3
55995: PUSH
55996: LD_INT 4
55998: PUSH
55999: LD_INT 5
56001: PUSH
56002: LD_INT 21
56004: PUSH
56005: LD_INT 23
56007: PUSH
56008: LD_INT 22
56010: PUSH
56011: LD_INT 24
56013: PUSH
56014: EMPTY
56015: LIST
56016: LIST
56017: LIST
56018: LIST
56019: LIST
56020: LIST
56021: LIST
56022: LIST
56023: LIST
56024: LIST
56025: LIST
56026: LIST
56027: LIST
56028: ST_TO_ADDR
56029: GO 56090
56031: LD_INT 3
56033: DOUBLE
56034: EQUAL
56035: IFTRUE 56039
56037: GO 56089
56039: POP
// result := [ ar_medium_trike , ar_half_tracked , us_medium_wheeled , us_medium_tracked , us_heavy_tracked , us_morphling , ru_medium_wheeled , ru_medium_tracked , ru_heavy_wheeled , ru_heavy_tracked ] ; end ;
56040: LD_ADDR_VAR 0 3
56044: PUSH
56045: LD_INT 13
56047: PUSH
56048: LD_INT 14
56050: PUSH
56051: LD_INT 2
56053: PUSH
56054: LD_INT 3
56056: PUSH
56057: LD_INT 4
56059: PUSH
56060: LD_INT 5
56062: PUSH
56063: LD_INT 21
56065: PUSH
56066: LD_INT 22
56068: PUSH
56069: LD_INT 23
56071: PUSH
56072: LD_INT 24
56074: PUSH
56075: EMPTY
56076: LIST
56077: LIST
56078: LIST
56079: LIST
56080: LIST
56081: LIST
56082: LIST
56083: LIST
56084: LIST
56085: LIST
56086: ST_TO_ADDR
56087: GO 56090
56089: POP
// result := ( chassis in result ) ;
56090: LD_ADDR_VAR 0 3
56094: PUSH
56095: LD_VAR 0 1
56099: PUSH
56100: LD_VAR 0 3
56104: IN
56105: ST_TO_ADDR
// end ;
56106: LD_VAR 0 3
56110: RET
// export function WeaponCanBeMount ( chassis , weapon ) ; begin
56111: LD_INT 0
56113: PPUSH
// if not chassis or not weapon then
56114: LD_VAR 0 1
56118: NOT
56119: PUSH
56120: LD_VAR 0 2
56124: NOT
56125: OR
56126: IFFALSE 56130
// exit ;
56128: GO 57156
// case weapon of us_machine_gun :
56130: LD_VAR 0 2
56134: PUSH
56135: LD_INT 2
56137: DOUBLE
56138: EQUAL
56139: IFTRUE 56143
56141: GO 56173
56143: POP
// result := [ us_light_wheeled , us_medium_wheeled , us_medium_tracked , us_heavy_tracked , us_morphling ] ; us_light_gun :
56144: LD_ADDR_VAR 0 3
56148: PUSH
56149: LD_INT 1
56151: PUSH
56152: LD_INT 2
56154: PUSH
56155: LD_INT 3
56157: PUSH
56158: LD_INT 4
56160: PUSH
56161: LD_INT 5
56163: PUSH
56164: EMPTY
56165: LIST
56166: LIST
56167: LIST
56168: LIST
56169: LIST
56170: ST_TO_ADDR
56171: GO 57140
56173: LD_INT 3
56175: DOUBLE
56176: EQUAL
56177: IFTRUE 56181
56179: GO 56211
56181: POP
// result := [ us_light_wheeled , us_medium_wheeled , us_medium_tracked , us_heavy_tracked , us_morphling ] ; us_radar :
56182: LD_ADDR_VAR 0 3
56186: PUSH
56187: LD_INT 1
56189: PUSH
56190: LD_INT 2
56192: PUSH
56193: LD_INT 3
56195: PUSH
56196: LD_INT 4
56198: PUSH
56199: LD_INT 5
56201: PUSH
56202: EMPTY
56203: LIST
56204: LIST
56205: LIST
56206: LIST
56207: LIST
56208: ST_TO_ADDR
56209: GO 57140
56211: LD_INT 11
56213: DOUBLE
56214: EQUAL
56215: IFTRUE 56219
56217: GO 56249
56219: POP
// result := [ us_light_wheeled , us_medium_wheeled , us_medium_tracked , us_heavy_tracked , us_morphling ] ; us_gatling_gun :
56220: LD_ADDR_VAR 0 3
56224: PUSH
56225: LD_INT 1
56227: PUSH
56228: LD_INT 2
56230: PUSH
56231: LD_INT 3
56233: PUSH
56234: LD_INT 4
56236: PUSH
56237: LD_INT 5
56239: PUSH
56240: EMPTY
56241: LIST
56242: LIST
56243: LIST
56244: LIST
56245: LIST
56246: ST_TO_ADDR
56247: GO 57140
56249: LD_INT 4
56251: DOUBLE
56252: EQUAL
56253: IFTRUE 56257
56255: GO 56283
56257: POP
// result := [ us_medium_wheeled , us_medium_tracked , us_heavy_tracked , us_morphling ] ; us_double_gun :
56258: LD_ADDR_VAR 0 3
56262: PUSH
56263: LD_INT 2
56265: PUSH
56266: LD_INT 3
56268: PUSH
56269: LD_INT 4
56271: PUSH
56272: LD_INT 5
56274: PUSH
56275: EMPTY
56276: LIST
56277: LIST
56278: LIST
56279: LIST
56280: ST_TO_ADDR
56281: GO 57140
56283: LD_INT 5
56285: DOUBLE
56286: EQUAL
56287: IFTRUE 56291
56289: GO 56317
56291: POP
// result := [ us_medium_wheeled , us_medium_tracked , us_heavy_tracked , us_morphling ] ; us_laser :
56292: LD_ADDR_VAR 0 3
56296: PUSH
56297: LD_INT 2
56299: PUSH
56300: LD_INT 3
56302: PUSH
56303: LD_INT 4
56305: PUSH
56306: LD_INT 5
56308: PUSH
56309: EMPTY
56310: LIST
56311: LIST
56312: LIST
56313: LIST
56314: ST_TO_ADDR
56315: GO 57140
56317: LD_INT 9
56319: DOUBLE
56320: EQUAL
56321: IFTRUE 56325
56323: GO 56351
56325: POP
// result := [ us_medium_wheeled , us_medium_tracked , us_heavy_tracked , us_morphling ] ; us_rocket_launcher :
56326: LD_ADDR_VAR 0 3
56330: PUSH
56331: LD_INT 2
56333: PUSH
56334: LD_INT 3
56336: PUSH
56337: LD_INT 4
56339: PUSH
56340: LD_INT 5
56342: PUSH
56343: EMPTY
56344: LIST
56345: LIST
56346: LIST
56347: LIST
56348: ST_TO_ADDR
56349: GO 57140
56351: LD_INT 7
56353: DOUBLE
56354: EQUAL
56355: IFTRUE 56359
56357: GO 56385
56359: POP
// result := [ us_medium_wheeled , us_medium_tracked , us_heavy_tracked , us_morphling ] ; us_cargo_bay :
56360: LD_ADDR_VAR 0 3
56364: PUSH
56365: LD_INT 2
56367: PUSH
56368: LD_INT 3
56370: PUSH
56371: LD_INT 4
56373: PUSH
56374: LD_INT 5
56376: PUSH
56377: EMPTY
56378: LIST
56379: LIST
56380: LIST
56381: LIST
56382: ST_TO_ADDR
56383: GO 57140
56385: LD_INT 12
56387: DOUBLE
56388: EQUAL
56389: IFTRUE 56393
56391: GO 56419
56393: POP
// result := [ us_medium_wheeled , us_medium_tracked , us_heavy_tracked , us_morphling ] ; us_crane :
56394: LD_ADDR_VAR 0 3
56398: PUSH
56399: LD_INT 2
56401: PUSH
56402: LD_INT 3
56404: PUSH
56405: LD_INT 4
56407: PUSH
56408: LD_INT 5
56410: PUSH
56411: EMPTY
56412: LIST
56413: LIST
56414: LIST
56415: LIST
56416: ST_TO_ADDR
56417: GO 57140
56419: LD_INT 13
56421: DOUBLE
56422: EQUAL
56423: IFTRUE 56427
56425: GO 56453
56427: POP
// result := [ us_medium_wheeled , us_medium_tracked , us_heavy_tracked , us_morphling ] ; us_bulldozer :
56428: LD_ADDR_VAR 0 3
56432: PUSH
56433: LD_INT 2
56435: PUSH
56436: LD_INT 3
56438: PUSH
56439: LD_INT 4
56441: PUSH
56442: LD_INT 5
56444: PUSH
56445: EMPTY
56446: LIST
56447: LIST
56448: LIST
56449: LIST
56450: ST_TO_ADDR
56451: GO 57140
56453: LD_INT 14
56455: DOUBLE
56456: EQUAL
56457: IFTRUE 56461
56459: GO 56479
56461: POP
// result := [ us_heavy_tracked , us_morphling ] ; us_heavy_gun :
56462: LD_ADDR_VAR 0 3
56466: PUSH
56467: LD_INT 4
56469: PUSH
56470: LD_INT 5
56472: PUSH
56473: EMPTY
56474: LIST
56475: LIST
56476: ST_TO_ADDR
56477: GO 57140
56479: LD_INT 6
56481: DOUBLE
56482: EQUAL
56483: IFTRUE 56487
56485: GO 56505
56487: POP
// result := [ us_heavy_tracked , us_morphling ] ; us_double_laser :
56488: LD_ADDR_VAR 0 3
56492: PUSH
56493: LD_INT 4
56495: PUSH
56496: LD_INT 5
56498: PUSH
56499: EMPTY
56500: LIST
56501: LIST
56502: ST_TO_ADDR
56503: GO 57140
56505: LD_INT 10
56507: DOUBLE
56508: EQUAL
56509: IFTRUE 56513
56511: GO 56531
56513: POP
// result := [ us_heavy_tracked , us_morphling ] ; ar_multimissile_ballista :
56514: LD_ADDR_VAR 0 3
56518: PUSH
56519: LD_INT 4
56521: PUSH
56522: LD_INT 5
56524: PUSH
56525: EMPTY
56526: LIST
56527: LIST
56528: ST_TO_ADDR
56529: GO 57140
56531: LD_INT 22
56533: DOUBLE
56534: EQUAL
56535: IFTRUE 56539
56537: GO 56565
56539: POP
// result := [ ar_hovercraft , ar_light_trike , ar_medium_trike , ar_half_tracked ] ; ar_light_gun :
56540: LD_ADDR_VAR 0 3
56544: PUSH
56545: LD_INT 11
56547: PUSH
56548: LD_INT 12
56550: PUSH
56551: LD_INT 13
56553: PUSH
56554: LD_INT 14
56556: PUSH
56557: EMPTY
56558: LIST
56559: LIST
56560: LIST
56561: LIST
56562: ST_TO_ADDR
56563: GO 57140
56565: LD_INT 23
56567: DOUBLE
56568: EQUAL
56569: IFTRUE 56573
56571: GO 56599
56573: POP
// result := [ ar_hovercraft , ar_light_trike , ar_medium_trike , ar_half_tracked ] ; ar_double_machine_gun :
56574: LD_ADDR_VAR 0 3
56578: PUSH
56579: LD_INT 11
56581: PUSH
56582: LD_INT 12
56584: PUSH
56585: LD_INT 13
56587: PUSH
56588: LD_INT 14
56590: PUSH
56591: EMPTY
56592: LIST
56593: LIST
56594: LIST
56595: LIST
56596: ST_TO_ADDR
56597: GO 57140
56599: LD_INT 24
56601: DOUBLE
56602: EQUAL
56603: IFTRUE 56607
56605: GO 56633
56607: POP
// result := [ ar_hovercraft , ar_light_trike , ar_medium_trike , ar_half_tracked ] ; ar_radar :
56608: LD_ADDR_VAR 0 3
56612: PUSH
56613: LD_INT 11
56615: PUSH
56616: LD_INT 12
56618: PUSH
56619: LD_INT 13
56621: PUSH
56622: LD_INT 14
56624: PUSH
56625: EMPTY
56626: LIST
56627: LIST
56628: LIST
56629: LIST
56630: ST_TO_ADDR
56631: GO 57140
56633: LD_INT 30
56635: DOUBLE
56636: EQUAL
56637: IFTRUE 56641
56639: GO 56667
56641: POP
// result := [ ar_hovercraft , ar_light_trike , ar_medium_trike , ar_half_tracked ] ; ar_gatling_gun :
56642: LD_ADDR_VAR 0 3
56646: PUSH
56647: LD_INT 11
56649: PUSH
56650: LD_INT 12
56652: PUSH
56653: LD_INT 13
56655: PUSH
56656: LD_INT 14
56658: PUSH
56659: EMPTY
56660: LIST
56661: LIST
56662: LIST
56663: LIST
56664: ST_TO_ADDR
56665: GO 57140
56667: LD_INT 25
56669: DOUBLE
56670: EQUAL
56671: IFTRUE 56675
56673: GO 56693
56675: POP
// result := [ ar_medium_trike , ar_half_tracked ] ; ar_gun :
56676: LD_ADDR_VAR 0 3
56680: PUSH
56681: LD_INT 13
56683: PUSH
56684: LD_INT 14
56686: PUSH
56687: EMPTY
56688: LIST
56689: LIST
56690: ST_TO_ADDR
56691: GO 57140
56693: LD_INT 27
56695: DOUBLE
56696: EQUAL
56697: IFTRUE 56701
56699: GO 56719
56701: POP
// result := [ ar_medium_trike , ar_half_tracked ] ; ar_rocket_launcher :
56702: LD_ADDR_VAR 0 3
56706: PUSH
56707: LD_INT 13
56709: PUSH
56710: LD_INT 14
56712: PUSH
56713: EMPTY
56714: LIST
56715: LIST
56716: ST_TO_ADDR
56717: GO 57140
56719: LD_INT 28
56721: DOUBLE
56722: EQUAL
56723: IFTRUE 56727
56725: GO 56745
56727: POP
// result := [ ar_medium_trike , ar_half_tracked ] ; ar_selfpropelled_bomb :
56728: LD_ADDR_VAR 0 3
56732: PUSH
56733: LD_INT 13
56735: PUSH
56736: LD_INT 14
56738: PUSH
56739: EMPTY
56740: LIST
56741: LIST
56742: ST_TO_ADDR
56743: GO 57140
56745: LD_INT 29
56747: DOUBLE
56748: EQUAL
56749: IFTRUE 56753
56751: GO 56771
56753: POP
// result := [ ar_medium_trike , ar_half_tracked ] ; ar_control_tower :
56754: LD_ADDR_VAR 0 3
56758: PUSH
56759: LD_INT 13
56761: PUSH
56762: LD_INT 14
56764: PUSH
56765: EMPTY
56766: LIST
56767: LIST
56768: ST_TO_ADDR
56769: GO 57140
56771: LD_INT 31
56773: DOUBLE
56774: EQUAL
56775: IFTRUE 56779
56777: GO 56797
56779: POP
// result := [ ar_medium_trike , ar_half_tracked ] ; ar_flame_thrower :
56780: LD_ADDR_VAR 0 3
56784: PUSH
56785: LD_INT 13
56787: PUSH
56788: LD_INT 14
56790: PUSH
56791: EMPTY
56792: LIST
56793: LIST
56794: ST_TO_ADDR
56795: GO 57140
56797: LD_INT 26
56799: DOUBLE
56800: EQUAL
56801: IFTRUE 56805
56803: GO 56823
56805: POP
// result := [ ar_medium_trike , ar_half_tracked ] ; ru_heavy_machine_gun :
56806: LD_ADDR_VAR 0 3
56810: PUSH
56811: LD_INT 13
56813: PUSH
56814: LD_INT 14
56816: PUSH
56817: EMPTY
56818: LIST
56819: LIST
56820: ST_TO_ADDR
56821: GO 57140
56823: LD_INT 42
56825: DOUBLE
56826: EQUAL
56827: IFTRUE 56831
56829: GO 56857
56831: POP
// result := [ ru_medium_wheeled , ru_medium_tracked , ru_heavy_wheeled , ru_heavy_tracked ] ; ru_gatling_gun :
56832: LD_ADDR_VAR 0 3
56836: PUSH
56837: LD_INT 21
56839: PUSH
56840: LD_INT 22
56842: PUSH
56843: LD_INT 23
56845: PUSH
56846: LD_INT 24
56848: PUSH
56849: EMPTY
56850: LIST
56851: LIST
56852: LIST
56853: LIST
56854: ST_TO_ADDR
56855: GO 57140
56857: LD_INT 43
56859: DOUBLE
56860: EQUAL
56861: IFTRUE 56865
56863: GO 56891
56865: POP
// result := [ ru_medium_wheeled , ru_medium_tracked , ru_heavy_wheeled , ru_heavy_tracked ] ; ru_gun :
56866: LD_ADDR_VAR 0 3
56870: PUSH
56871: LD_INT 21
56873: PUSH
56874: LD_INT 22
56876: PUSH
56877: LD_INT 23
56879: PUSH
56880: LD_INT 24
56882: PUSH
56883: EMPTY
56884: LIST
56885: LIST
56886: LIST
56887: LIST
56888: ST_TO_ADDR
56889: GO 57140
56891: LD_INT 44
56893: DOUBLE
56894: EQUAL
56895: IFTRUE 56899
56897: GO 56925
56899: POP
// result := [ ru_medium_wheeled , ru_medium_tracked , ru_heavy_wheeled , ru_heavy_tracked ] ; ru_rocket_launcher :
56900: LD_ADDR_VAR 0 3
56904: PUSH
56905: LD_INT 21
56907: PUSH
56908: LD_INT 22
56910: PUSH
56911: LD_INT 23
56913: PUSH
56914: LD_INT 24
56916: PUSH
56917: EMPTY
56918: LIST
56919: LIST
56920: LIST
56921: LIST
56922: ST_TO_ADDR
56923: GO 57140
56925: LD_INT 45
56927: DOUBLE
56928: EQUAL
56929: IFTRUE 56933
56931: GO 56959
56933: POP
// result := [ ru_medium_wheeled , ru_medium_tracked , ru_heavy_wheeled , ru_heavy_tracked ] ; ru_time_lapser :
56934: LD_ADDR_VAR 0 3
56938: PUSH
56939: LD_INT 21
56941: PUSH
56942: LD_INT 22
56944: PUSH
56945: LD_INT 23
56947: PUSH
56948: LD_INT 24
56950: PUSH
56951: EMPTY
56952: LIST
56953: LIST
56954: LIST
56955: LIST
56956: ST_TO_ADDR
56957: GO 57140
56959: LD_INT 49
56961: DOUBLE
56962: EQUAL
56963: IFTRUE 56967
56965: GO 56993
56967: POP
// result := [ ru_medium_wheeled , ru_medium_tracked , ru_heavy_wheeled , ru_heavy_tracked ] ; ru_cargo_bay :
56968: LD_ADDR_VAR 0 3
56972: PUSH
56973: LD_INT 21
56975: PUSH
56976: LD_INT 22
56978: PUSH
56979: LD_INT 23
56981: PUSH
56982: LD_INT 24
56984: PUSH
56985: EMPTY
56986: LIST
56987: LIST
56988: LIST
56989: LIST
56990: ST_TO_ADDR
56991: GO 57140
56993: LD_INT 51
56995: DOUBLE
56996: EQUAL
56997: IFTRUE 57001
56999: GO 57027
57001: POP
// result := [ ru_medium_wheeled , ru_medium_tracked , ru_heavy_wheeled , ru_heavy_tracked ] ; ru_crane :
57002: LD_ADDR_VAR 0 3
57006: PUSH
57007: LD_INT 21
57009: PUSH
57010: LD_INT 22
57012: PUSH
57013: LD_INT 23
57015: PUSH
57016: LD_INT 24
57018: PUSH
57019: EMPTY
57020: LIST
57021: LIST
57022: LIST
57023: LIST
57024: ST_TO_ADDR
57025: GO 57140
57027: LD_INT 52
57029: DOUBLE
57030: EQUAL
57031: IFTRUE 57035
57033: GO 57061
57035: POP
// result := [ ru_medium_wheeled , ru_medium_tracked , ru_heavy_wheeled , ru_heavy_tracked ] ; ru_bulldozer :
57036: LD_ADDR_VAR 0 3
57040: PUSH
57041: LD_INT 21
57043: PUSH
57044: LD_INT 22
57046: PUSH
57047: LD_INT 23
57049: PUSH
57050: LD_INT 24
57052: PUSH
57053: EMPTY
57054: LIST
57055: LIST
57056: LIST
57057: LIST
57058: ST_TO_ADDR
57059: GO 57140
57061: LD_INT 53
57063: DOUBLE
57064: EQUAL
57065: IFTRUE 57069
57067: GO 57087
57069: POP
// result := [ ru_heavy_wheeled , ru_heavy_tracked ] ; ru_heavy_gun :
57070: LD_ADDR_VAR 0 3
57074: PUSH
57075: LD_INT 23
57077: PUSH
57078: LD_INT 24
57080: PUSH
57081: EMPTY
57082: LIST
57083: LIST
57084: ST_TO_ADDR
57085: GO 57140
57087: LD_INT 46
57089: DOUBLE
57090: EQUAL
57091: IFTRUE 57095
57093: GO 57113
57095: POP
// result := [ ru_heavy_wheeled , ru_heavy_tracked ] ; ru_rocket :
57096: LD_ADDR_VAR 0 3
57100: PUSH
57101: LD_INT 23
57103: PUSH
57104: LD_INT 24
57106: PUSH
57107: EMPTY
57108: LIST
57109: LIST
57110: ST_TO_ADDR
57111: GO 57140
57113: LD_INT 47
57115: DOUBLE
57116: EQUAL
57117: IFTRUE 57121
57119: GO 57139
57121: POP
// result := [ ru_heavy_wheeled , ru_heavy_tracked ] ; end ;
57122: LD_ADDR_VAR 0 3
57126: PUSH
57127: LD_INT 23
57129: PUSH
57130: LD_INT 24
57132: PUSH
57133: EMPTY
57134: LIST
57135: LIST
57136: ST_TO_ADDR
57137: GO 57140
57139: POP
// result := ( chassis in result ) ;
57140: LD_ADDR_VAR 0 3
57144: PUSH
57145: LD_VAR 0 1
57149: PUSH
57150: LD_VAR 0 3
57154: IN
57155: ST_TO_ADDR
// end ;
57156: LD_VAR 0 3
57160: RET
// export function Reindex ( array , i_from , i_to , direction ) ; var i , j , k , d , tmp , length ; begin
57161: LD_INT 0
57163: PPUSH
57164: PPUSH
57165: PPUSH
57166: PPUSH
57167: PPUSH
57168: PPUSH
57169: PPUSH
// result := array ;
57170: LD_ADDR_VAR 0 5
57174: PUSH
57175: LD_VAR 0 1
57179: ST_TO_ADDR
// if not array or not i_from or not i_to or i_from > array or i_to > array then
57180: LD_VAR 0 1
57184: NOT
57185: PUSH
57186: LD_VAR 0 2
57190: NOT
57191: OR
57192: PUSH
57193: LD_VAR 0 3
57197: NOT
57198: OR
57199: PUSH
57200: LD_VAR 0 2
57204: PUSH
57205: LD_VAR 0 1
57209: GREATER
57210: OR
57211: PUSH
57212: LD_VAR 0 3
57216: PUSH
57217: LD_VAR 0 1
57221: GREATER
57222: OR
57223: IFFALSE 57227
// exit ;
57225: GO 57523
// if direction then
57227: LD_VAR 0 4
57231: IFFALSE 57295
// begin d := 1 ;
57233: LD_ADDR_VAR 0 9
57237: PUSH
57238: LD_INT 1
57240: ST_TO_ADDR
// if i_from > i_to then
57241: LD_VAR 0 2
57245: PUSH
57246: LD_VAR 0 3
57250: GREATER
57251: IFFALSE 57277
// length := ( array - i_from ) + i_to else
57253: LD_ADDR_VAR 0 11
57257: PUSH
57258: LD_VAR 0 1
57262: PUSH
57263: LD_VAR 0 2
57267: MINUS
57268: PUSH
57269: LD_VAR 0 3
57273: PLUS
57274: ST_TO_ADDR
57275: GO 57293
// length := i_to - i_from ;
57277: LD_ADDR_VAR 0 11
57281: PUSH
57282: LD_VAR 0 3
57286: PUSH
57287: LD_VAR 0 2
57291: MINUS
57292: ST_TO_ADDR
// end else
57293: GO 57356
// begin d := - 1 ;
57295: LD_ADDR_VAR 0 9
57299: PUSH
57300: LD_INT 1
57302: NEG
57303: ST_TO_ADDR
// if i_from > i_to then
57304: LD_VAR 0 2
57308: PUSH
57309: LD_VAR 0 3
57313: GREATER
57314: IFFALSE 57334
// length := i_from - i_to else
57316: LD_ADDR_VAR 0 11
57320: PUSH
57321: LD_VAR 0 2
57325: PUSH
57326: LD_VAR 0 3
57330: MINUS
57331: ST_TO_ADDR
57332: GO 57356
// length := ( array - i_to ) + i_from ;
57334: LD_ADDR_VAR 0 11
57338: PUSH
57339: LD_VAR 0 1
57343: PUSH
57344: LD_VAR 0 3
57348: MINUS
57349: PUSH
57350: LD_VAR 0 2
57354: PLUS
57355: ST_TO_ADDR
// end ; if not length then
57356: LD_VAR 0 11
57360: NOT
57361: IFFALSE 57365
// exit ;
57363: GO 57523
// tmp := array ;
57365: LD_ADDR_VAR 0 10
57369: PUSH
57370: LD_VAR 0 1
57374: ST_TO_ADDR
// for i = 1 to length do
57375: LD_ADDR_VAR 0 6
57379: PUSH
57380: DOUBLE
57381: LD_INT 1
57383: DEC
57384: ST_TO_ADDR
57385: LD_VAR 0 11
57389: PUSH
57390: FOR_TO
57391: IFFALSE 57511
// begin for j = 1 to array do
57393: LD_ADDR_VAR 0 7
57397: PUSH
57398: DOUBLE
57399: LD_INT 1
57401: DEC
57402: ST_TO_ADDR
57403: LD_VAR 0 1
57407: PUSH
57408: FOR_TO
57409: IFFALSE 57497
// begin k := j + d ;
57411: LD_ADDR_VAR 0 8
57415: PUSH
57416: LD_VAR 0 7
57420: PUSH
57421: LD_VAR 0 9
57425: PLUS
57426: ST_TO_ADDR
// if k > array then
57427: LD_VAR 0 8
57431: PUSH
57432: LD_VAR 0 1
57436: GREATER
57437: IFFALSE 57447
// k := 1 ;
57439: LD_ADDR_VAR 0 8
57443: PUSH
57444: LD_INT 1
57446: ST_TO_ADDR
// if not k then
57447: LD_VAR 0 8
57451: NOT
57452: IFFALSE 57464
// k := array ;
57454: LD_ADDR_VAR 0 8
57458: PUSH
57459: LD_VAR 0 1
57463: ST_TO_ADDR
// tmp := Replace ( tmp , k , array [ j ] ) ;
57464: LD_ADDR_VAR 0 10
57468: PUSH
57469: LD_VAR 0 10
57473: PPUSH
57474: LD_VAR 0 8
57478: PPUSH
57479: LD_VAR 0 1
57483: PUSH
57484: LD_VAR 0 7
57488: ARRAY
57489: PPUSH
57490: CALL_OW 1
57494: ST_TO_ADDR
// end ;
57495: GO 57408
57497: POP
57498: POP
// array := tmp ;
57499: LD_ADDR_VAR 0 1
57503: PUSH
57504: LD_VAR 0 10
57508: ST_TO_ADDR
// end ;
57509: GO 57390
57511: POP
57512: POP
// result := array ;
57513: LD_ADDR_VAR 0 5
57517: PUSH
57518: LD_VAR 0 1
57522: ST_TO_ADDR
// end ;
57523: LD_VAR 0 5
57527: RET
// export function GetElementIndex ( array , value ) ; var i ; begin
57528: LD_INT 0
57530: PPUSH
57531: PPUSH
// result := 0 ;
57532: LD_ADDR_VAR 0 3
57536: PUSH
57537: LD_INT 0
57539: ST_TO_ADDR
// if not array or not value in array then
57540: LD_VAR 0 1
57544: NOT
57545: PUSH
57546: LD_VAR 0 2
57550: PUSH
57551: LD_VAR 0 1
57555: IN
57556: NOT
57557: OR
57558: IFFALSE 57562
// exit ;
57560: GO 57616
// for i = 1 to array do
57562: LD_ADDR_VAR 0 4
57566: PUSH
57567: DOUBLE
57568: LD_INT 1
57570: DEC
57571: ST_TO_ADDR
57572: LD_VAR 0 1
57576: PUSH
57577: FOR_TO
57578: IFFALSE 57614
// if value = array [ i ] then
57580: LD_VAR 0 2
57584: PUSH
57585: LD_VAR 0 1
57589: PUSH
57590: LD_VAR 0 4
57594: ARRAY
57595: EQUAL
57596: IFFALSE 57612
// begin result := i ;
57598: LD_ADDR_VAR 0 3
57602: PUSH
57603: LD_VAR 0 4
57607: ST_TO_ADDR
// exit ;
57608: POP
57609: POP
57610: GO 57616
// end ;
57612: GO 57577
57614: POP
57615: POP
// end ;
57616: LD_VAR 0 3
57620: RET
// export function PrepareVehicle ( chassis , engine , control , weapon , fuel ) ; begin
57621: LD_INT 0
57623: PPUSH
// vc_chassis := chassis ;
57624: LD_ADDR_OWVAR 37
57628: PUSH
57629: LD_VAR 0 1
57633: ST_TO_ADDR
// vc_engine := engine ;
57634: LD_ADDR_OWVAR 39
57638: PUSH
57639: LD_VAR 0 2
57643: ST_TO_ADDR
// vc_control := control ;
57644: LD_ADDR_OWVAR 38
57648: PUSH
57649: LD_VAR 0 3
57653: ST_TO_ADDR
// vc_weapon := weapon ;
57654: LD_ADDR_OWVAR 40
57658: PUSH
57659: LD_VAR 0 4
57663: ST_TO_ADDR
// vc_fuel_battery := fuel ;
57664: LD_ADDR_OWVAR 41
57668: PUSH
57669: LD_VAR 0 5
57673: ST_TO_ADDR
// end ;
57674: LD_VAR 0 6
57678: RET
// export function WantPlant ( unit ) ; var task ; begin
57679: LD_INT 0
57681: PPUSH
57682: PPUSH
// result := false ;
57683: LD_ADDR_VAR 0 2
57687: PUSH
57688: LD_INT 0
57690: ST_TO_ADDR
// task := GetTaskList ( unit ) ;
57691: LD_ADDR_VAR 0 3
57695: PUSH
57696: LD_VAR 0 1
57700: PPUSH
57701: CALL_OW 437
57705: ST_TO_ADDR
// if task then
57706: LD_VAR 0 3
57710: IFFALSE 57738
// if task [ 1 ] [ 1 ] = p then
57712: LD_VAR 0 3
57716: PUSH
57717: LD_INT 1
57719: ARRAY
57720: PUSH
57721: LD_INT 1
57723: ARRAY
57724: PUSH
57725: LD_STRING p
57727: EQUAL
57728: IFFALSE 57738
// result := true ;
57730: LD_ADDR_VAR 0 2
57734: PUSH
57735: LD_INT 1
57737: ST_TO_ADDR
// end ;
57738: LD_VAR 0 2
57742: RET
// export function ReplaceIn ( arr , pos , value ) ; var i , tmp , s_arr ; begin
57743: LD_INT 0
57745: PPUSH
57746: PPUSH
57747: PPUSH
57748: PPUSH
// if pos < 1 then
57749: LD_VAR 0 2
57753: PUSH
57754: LD_INT 1
57756: LESS
57757: IFFALSE 57761
// exit ;
57759: GO 58064
// if pos = 1 then
57761: LD_VAR 0 2
57765: PUSH
57766: LD_INT 1
57768: EQUAL
57769: IFFALSE 57802
// result := Replace ( arr , pos [ 1 ] , value ) else
57771: LD_ADDR_VAR 0 4
57775: PUSH
57776: LD_VAR 0 1
57780: PPUSH
57781: LD_VAR 0 2
57785: PUSH
57786: LD_INT 1
57788: ARRAY
57789: PPUSH
57790: LD_VAR 0 3
57794: PPUSH
57795: CALL_OW 1
57799: ST_TO_ADDR
57800: GO 58064
// begin tmp := arr ;
57802: LD_ADDR_VAR 0 6
57806: PUSH
57807: LD_VAR 0 1
57811: ST_TO_ADDR
// s_arr := [ tmp ] ;
57812: LD_ADDR_VAR 0 7
57816: PUSH
57817: LD_VAR 0 6
57821: PUSH
57822: EMPTY
57823: LIST
57824: ST_TO_ADDR
// for i = 1 to pos - 1 do
57825: LD_ADDR_VAR 0 5
57829: PUSH
57830: DOUBLE
57831: LD_INT 1
57833: DEC
57834: ST_TO_ADDR
57835: LD_VAR 0 2
57839: PUSH
57840: LD_INT 1
57842: MINUS
57843: PUSH
57844: FOR_TO
57845: IFFALSE 57890
// begin tmp := tmp [ pos [ i ] ] ;
57847: LD_ADDR_VAR 0 6
57851: PUSH
57852: LD_VAR 0 6
57856: PUSH
57857: LD_VAR 0 2
57861: PUSH
57862: LD_VAR 0 5
57866: ARRAY
57867: ARRAY
57868: ST_TO_ADDR
// s_arr := s_arr ^ [ tmp ] ;
57869: LD_ADDR_VAR 0 7
57873: PUSH
57874: LD_VAR 0 7
57878: PUSH
57879: LD_VAR 0 6
57883: PUSH
57884: EMPTY
57885: LIST
57886: ADD
57887: ST_TO_ADDR
// end ;
57888: GO 57844
57890: POP
57891: POP
// tmp := Replace ( tmp , pos [ pos ] , value ) ;
57892: LD_ADDR_VAR 0 6
57896: PUSH
57897: LD_VAR 0 6
57901: PPUSH
57902: LD_VAR 0 2
57906: PUSH
57907: LD_VAR 0 2
57911: ARRAY
57912: PPUSH
57913: LD_VAR 0 3
57917: PPUSH
57918: CALL_OW 1
57922: ST_TO_ADDR
// s_arr := Replace ( s_arr , s_arr , tmp ) ;
57923: LD_ADDR_VAR 0 7
57927: PUSH
57928: LD_VAR 0 7
57932: PPUSH
57933: LD_VAR 0 7
57937: PPUSH
57938: LD_VAR 0 6
57942: PPUSH
57943: CALL_OW 1
57947: ST_TO_ADDR
// for i = s_arr downto 2 do
57948: LD_ADDR_VAR 0 5
57952: PUSH
57953: DOUBLE
57954: LD_VAR 0 7
57958: INC
57959: ST_TO_ADDR
57960: LD_INT 2
57962: PUSH
57963: FOR_DOWNTO
57964: IFFALSE 58048
// begin tmp := Replace ( s_arr [ i - 1 ] , pos [ i - 1 ] , s_arr [ i ] ) ;
57966: LD_ADDR_VAR 0 6
57970: PUSH
57971: LD_VAR 0 7
57975: PUSH
57976: LD_VAR 0 5
57980: PUSH
57981: LD_INT 1
57983: MINUS
57984: ARRAY
57985: PPUSH
57986: LD_VAR 0 2
57990: PUSH
57991: LD_VAR 0 5
57995: PUSH
57996: LD_INT 1
57998: MINUS
57999: ARRAY
58000: PPUSH
58001: LD_VAR 0 7
58005: PUSH
58006: LD_VAR 0 5
58010: ARRAY
58011: PPUSH
58012: CALL_OW 1
58016: ST_TO_ADDR
// s_arr := Replace ( s_arr , i - 1 , tmp ) ;
58017: LD_ADDR_VAR 0 7
58021: PUSH
58022: LD_VAR 0 7
58026: PPUSH
58027: LD_VAR 0 5
58031: PUSH
58032: LD_INT 1
58034: MINUS
58035: PPUSH
58036: LD_VAR 0 6
58040: PPUSH
58041: CALL_OW 1
58045: ST_TO_ADDR
// end ;
58046: GO 57963
58048: POP
58049: POP
// result := s_arr [ 1 ] ;
58050: LD_ADDR_VAR 0 4
58054: PUSH
58055: LD_VAR 0 7
58059: PUSH
58060: LD_INT 1
58062: ARRAY
58063: ST_TO_ADDR
// end ; end ;
58064: LD_VAR 0 4
58068: RET
// export function ReplaceWith ( list , pos1 , pos2 ) ; var i ; begin
58069: LD_INT 0
58071: PPUSH
58072: PPUSH
// if not list then
58073: LD_VAR 0 1
58077: NOT
58078: IFFALSE 58082
// exit ;
58080: GO 58173
// i := list [ pos1 ] ;
58082: LD_ADDR_VAR 0 5
58086: PUSH
58087: LD_VAR 0 1
58091: PUSH
58092: LD_VAR 0 2
58096: ARRAY
58097: ST_TO_ADDR
// if not i then
58098: LD_VAR 0 5
58102: NOT
58103: IFFALSE 58107
// exit ;
58105: GO 58173
// list := Replace ( list , pos1 , list [ pos2 ] ) ;
58107: LD_ADDR_VAR 0 1
58111: PUSH
58112: LD_VAR 0 1
58116: PPUSH
58117: LD_VAR 0 2
58121: PPUSH
58122: LD_VAR 0 1
58126: PUSH
58127: LD_VAR 0 3
58131: ARRAY
58132: PPUSH
58133: CALL_OW 1
58137: ST_TO_ADDR
// list := Replace ( list , pos2 , i ) ;
58138: LD_ADDR_VAR 0 1
58142: PUSH
58143: LD_VAR 0 1
58147: PPUSH
58148: LD_VAR 0 3
58152: PPUSH
58153: LD_VAR 0 5
58157: PPUSH
58158: CALL_OW 1
58162: ST_TO_ADDR
// result := list ;
58163: LD_ADDR_VAR 0 4
58167: PUSH
58168: LD_VAR 0 1
58172: ST_TO_ADDR
// end ;
58173: LD_VAR 0 4
58177: RET
// export function SortByDistanceUnit ( unit , list , asc , mode ) ; begin
58178: LD_INT 0
58180: PPUSH
// result := SortByDistanceXY ( GetX ( unit ) , GetY ( unit ) , list , asc , mode ) ;
58181: LD_ADDR_VAR 0 5
58185: PUSH
58186: LD_VAR 0 1
58190: PPUSH
58191: CALL_OW 250
58195: PPUSH
58196: LD_VAR 0 1
58200: PPUSH
58201: CALL_OW 251
58205: PPUSH
58206: LD_VAR 0 2
58210: PPUSH
58211: LD_VAR 0 3
58215: PPUSH
58216: LD_VAR 0 4
58220: PPUSH
58221: CALL 58231 0 5
58225: ST_TO_ADDR
// end ;
58226: LD_VAR 0 5
58230: RET
// export function SortByDistanceXY ( x , y , list , asc , mode ) ; var i , j , tmp ; begin
58231: LD_INT 0
58233: PPUSH
58234: PPUSH
58235: PPUSH
58236: PPUSH
// if not list then
58237: LD_VAR 0 3
58241: NOT
58242: IFFALSE 58246
// exit ;
58244: GO 58634
// result := [ ] ;
58246: LD_ADDR_VAR 0 6
58250: PUSH
58251: EMPTY
58252: ST_TO_ADDR
// for i in list do
58253: LD_ADDR_VAR 0 7
58257: PUSH
58258: LD_VAR 0 3
58262: PUSH
58263: FOR_IN
58264: IFFALSE 58466
// begin tmp := GetDistUnitXY ( i , x , y ) ;
58266: LD_ADDR_VAR 0 9
58270: PUSH
58271: LD_VAR 0 7
58275: PPUSH
58276: LD_VAR 0 1
58280: PPUSH
58281: LD_VAR 0 2
58285: PPUSH
58286: CALL_OW 297
58290: ST_TO_ADDR
// if not result then
58291: LD_VAR 0 6
58295: NOT
58296: IFFALSE 58322
// result := [ [ i , tmp ] ] else
58298: LD_ADDR_VAR 0 6
58302: PUSH
58303: LD_VAR 0 7
58307: PUSH
58308: LD_VAR 0 9
58312: PUSH
58313: EMPTY
58314: LIST
58315: LIST
58316: PUSH
58317: EMPTY
58318: LIST
58319: ST_TO_ADDR
58320: GO 58464
// begin if result [ result ] [ 2 ] < tmp then
58322: LD_VAR 0 6
58326: PUSH
58327: LD_VAR 0 6
58331: ARRAY
58332: PUSH
58333: LD_INT 2
58335: ARRAY
58336: PUSH
58337: LD_VAR 0 9
58341: LESS
58342: IFFALSE 58384
// result := Insert ( result , result + 1 , [ i , tmp ] ) else
58344: LD_ADDR_VAR 0 6
58348: PUSH
58349: LD_VAR 0 6
58353: PPUSH
58354: LD_VAR 0 6
58358: PUSH
58359: LD_INT 1
58361: PLUS
58362: PPUSH
58363: LD_VAR 0 7
58367: PUSH
58368: LD_VAR 0 9
58372: PUSH
58373: EMPTY
58374: LIST
58375: LIST
58376: PPUSH
58377: CALL_OW 2
58381: ST_TO_ADDR
58382: GO 58464
// for j = 1 to result do
58384: LD_ADDR_VAR 0 8
58388: PUSH
58389: DOUBLE
58390: LD_INT 1
58392: DEC
58393: ST_TO_ADDR
58394: LD_VAR 0 6
58398: PUSH
58399: FOR_TO
58400: IFFALSE 58462
// begin if tmp < result [ j ] [ 2 ] then
58402: LD_VAR 0 9
58406: PUSH
58407: LD_VAR 0 6
58411: PUSH
58412: LD_VAR 0 8
58416: ARRAY
58417: PUSH
58418: LD_INT 2
58420: ARRAY
58421: LESS
58422: IFFALSE 58460
// begin result := Insert ( result , j , [ i , tmp ] ) ;
58424: LD_ADDR_VAR 0 6
58428: PUSH
58429: LD_VAR 0 6
58433: PPUSH
58434: LD_VAR 0 8
58438: PPUSH
58439: LD_VAR 0 7
58443: PUSH
58444: LD_VAR 0 9
58448: PUSH
58449: EMPTY
58450: LIST
58451: LIST
58452: PPUSH
58453: CALL_OW 2
58457: ST_TO_ADDR
// break ;
58458: GO 58462
// end ; end ;
58460: GO 58399
58462: POP
58463: POP
// end ; end ;
58464: GO 58263
58466: POP
58467: POP
// if result and not asc then
58468: LD_VAR 0 6
58472: PUSH
58473: LD_VAR 0 4
58477: NOT
58478: AND
58479: IFFALSE 58554
// begin tmp := result ;
58481: LD_ADDR_VAR 0 9
58485: PUSH
58486: LD_VAR 0 6
58490: ST_TO_ADDR
// for i = tmp downto 1 do
58491: LD_ADDR_VAR 0 7
58495: PUSH
58496: DOUBLE
58497: LD_VAR 0 9
58501: INC
58502: ST_TO_ADDR
58503: LD_INT 1
58505: PUSH
58506: FOR_DOWNTO
58507: IFFALSE 58552
// result := Replace ( result , tmp - i + 1 , tmp [ i ] ) ;
58509: LD_ADDR_VAR 0 6
58513: PUSH
58514: LD_VAR 0 6
58518: PPUSH
58519: LD_VAR 0 9
58523: PUSH
58524: LD_VAR 0 7
58528: MINUS
58529: PUSH
58530: LD_INT 1
58532: PLUS
58533: PPUSH
58534: LD_VAR 0 9
58538: PUSH
58539: LD_VAR 0 7
58543: ARRAY
58544: PPUSH
58545: CALL_OW 1
58549: ST_TO_ADDR
58550: GO 58506
58552: POP
58553: POP
// end ; tmp := [ ] ;
58554: LD_ADDR_VAR 0 9
58558: PUSH
58559: EMPTY
58560: ST_TO_ADDR
// if mode then
58561: LD_VAR 0 5
58565: IFFALSE 58634
// begin for i = 1 to result do
58567: LD_ADDR_VAR 0 7
58571: PUSH
58572: DOUBLE
58573: LD_INT 1
58575: DEC
58576: ST_TO_ADDR
58577: LD_VAR 0 6
58581: PUSH
58582: FOR_TO
58583: IFFALSE 58622
// tmp := Replace ( tmp , i , result [ i ] [ 1 ] ) ;
58585: LD_ADDR_VAR 0 9
58589: PUSH
58590: LD_VAR 0 9
58594: PPUSH
58595: LD_VAR 0 7
58599: PPUSH
58600: LD_VAR 0 6
58604: PUSH
58605: LD_VAR 0 7
58609: ARRAY
58610: PUSH
58611: LD_INT 1
58613: ARRAY
58614: PPUSH
58615: CALL_OW 1
58619: ST_TO_ADDR
58620: GO 58582
58622: POP
58623: POP
// result := tmp ;
58624: LD_ADDR_VAR 0 6
58628: PUSH
58629: LD_VAR 0 9
58633: ST_TO_ADDR
// end ; end ;
58634: LD_VAR 0 6
58638: RET
// export function DangerAtRangeXY ( side , x , y , range ) ; var i , j , tmp , points , bpoints ; begin
58639: LD_INT 0
58641: PPUSH
58642: PPUSH
58643: PPUSH
58644: PPUSH
58645: PPUSH
58646: PPUSH
// result := [ 0 , 0 , 0 , [ ] ] ;
58647: LD_ADDR_VAR 0 5
58651: PUSH
58652: LD_INT 0
58654: PUSH
58655: LD_INT 0
58657: PUSH
58658: LD_INT 0
58660: PUSH
58661: EMPTY
58662: PUSH
58663: EMPTY
58664: LIST
58665: LIST
58666: LIST
58667: LIST
58668: ST_TO_ADDR
// if not x or not y then
58669: LD_VAR 0 2
58673: NOT
58674: PUSH
58675: LD_VAR 0 3
58679: NOT
58680: OR
58681: IFFALSE 58685
// exit ;
58683: GO 60331
// if not range then
58685: LD_VAR 0 4
58689: NOT
58690: IFFALSE 58700
// range := 10 ;
58692: LD_ADDR_VAR 0 4
58696: PUSH
58697: LD_INT 10
58699: ST_TO_ADDR
// tmp := FilterAllUnits ( [ [ f_enemy , side ] , [ f_distxy , x , y , range ] , [ f_not , [ f_type , unit_building ] ] ] ) ;
58700: LD_ADDR_VAR 0 8
58704: PUSH
58705: LD_INT 81
58707: PUSH
58708: LD_VAR 0 1
58712: PUSH
58713: EMPTY
58714: LIST
58715: LIST
58716: PUSH
58717: LD_INT 92
58719: PUSH
58720: LD_VAR 0 2
58724: PUSH
58725: LD_VAR 0 3
58729: PUSH
58730: LD_VAR 0 4
58734: PUSH
58735: EMPTY
58736: LIST
58737: LIST
58738: LIST
58739: LIST
58740: PUSH
58741: LD_INT 3
58743: PUSH
58744: LD_INT 21
58746: PUSH
58747: LD_INT 3
58749: PUSH
58750: EMPTY
58751: LIST
58752: LIST
58753: PUSH
58754: EMPTY
58755: LIST
58756: LIST
58757: PUSH
58758: EMPTY
58759: LIST
58760: LIST
58761: LIST
58762: PPUSH
58763: CALL_OW 69
58767: ST_TO_ADDR
// if not tmp then
58768: LD_VAR 0 8
58772: NOT
58773: IFFALSE 58777
// exit ;
58775: GO 60331
// for i in tmp do
58777: LD_ADDR_VAR 0 6
58781: PUSH
58782: LD_VAR 0 8
58786: PUSH
58787: FOR_IN
58788: IFFALSE 60306
// begin points := [ 0 , 0 , 0 ] ;
58790: LD_ADDR_VAR 0 9
58794: PUSH
58795: LD_INT 0
58797: PUSH
58798: LD_INT 0
58800: PUSH
58801: LD_INT 0
58803: PUSH
58804: EMPTY
58805: LIST
58806: LIST
58807: LIST
58808: ST_TO_ADDR
// bpoints := 1 ;
58809: LD_ADDR_VAR 0 10
58813: PUSH
58814: LD_INT 1
58816: ST_TO_ADDR
// case GetType ( i ) of unit_human :
58817: LD_VAR 0 6
58821: PPUSH
58822: CALL_OW 247
58826: PUSH
58827: LD_INT 1
58829: DOUBLE
58830: EQUAL
58831: IFTRUE 58835
58833: GO 59413
58835: POP
// begin if GetClass ( i ) = 1 then
58836: LD_VAR 0 6
58840: PPUSH
58841: CALL_OW 257
58845: PUSH
58846: LD_INT 1
58848: EQUAL
58849: IFFALSE 58870
// points := [ 10 , 5 , 3 ] ;
58851: LD_ADDR_VAR 0 9
58855: PUSH
58856: LD_INT 10
58858: PUSH
58859: LD_INT 5
58861: PUSH
58862: LD_INT 3
58864: PUSH
58865: EMPTY
58866: LIST
58867: LIST
58868: LIST
58869: ST_TO_ADDR
// if GetClass ( i ) in [ 2 , 3 , 4 ] then
58870: LD_VAR 0 6
58874: PPUSH
58875: CALL_OW 257
58879: PUSH
58880: LD_INT 2
58882: PUSH
58883: LD_INT 3
58885: PUSH
58886: LD_INT 4
58888: PUSH
58889: EMPTY
58890: LIST
58891: LIST
58892: LIST
58893: IN
58894: IFFALSE 58915
// points := [ 3 , 2 , 1 ] ;
58896: LD_ADDR_VAR 0 9
58900: PUSH
58901: LD_INT 3
58903: PUSH
58904: LD_INT 2
58906: PUSH
58907: LD_INT 1
58909: PUSH
58910: EMPTY
58911: LIST
58912: LIST
58913: LIST
58914: ST_TO_ADDR
// if GetClass ( i ) = 5 then
58915: LD_VAR 0 6
58919: PPUSH
58920: CALL_OW 257
58924: PUSH
58925: LD_INT 5
58927: EQUAL
58928: IFFALSE 58949
// points := [ 130 , 5 , 2 ] ;
58930: LD_ADDR_VAR 0 9
58934: PUSH
58935: LD_INT 130
58937: PUSH
58938: LD_INT 5
58940: PUSH
58941: LD_INT 2
58943: PUSH
58944: EMPTY
58945: LIST
58946: LIST
58947: LIST
58948: ST_TO_ADDR
// if GetClass ( i ) = 8 then
58949: LD_VAR 0 6
58953: PPUSH
58954: CALL_OW 257
58958: PUSH
58959: LD_INT 8
58961: EQUAL
58962: IFFALSE 58983
// points := [ 35 , 35 , 30 ] ;
58964: LD_ADDR_VAR 0 9
58968: PUSH
58969: LD_INT 35
58971: PUSH
58972: LD_INT 35
58974: PUSH
58975: LD_INT 30
58977: PUSH
58978: EMPTY
58979: LIST
58980: LIST
58981: LIST
58982: ST_TO_ADDR
// if GetClass ( i ) = 9 then
58983: LD_VAR 0 6
58987: PPUSH
58988: CALL_OW 257
58992: PUSH
58993: LD_INT 9
58995: EQUAL
58996: IFFALSE 59017
// points := [ 20 , 55 , 40 ] ;
58998: LD_ADDR_VAR 0 9
59002: PUSH
59003: LD_INT 20
59005: PUSH
59006: LD_INT 55
59008: PUSH
59009: LD_INT 40
59011: PUSH
59012: EMPTY
59013: LIST
59014: LIST
59015: LIST
59016: ST_TO_ADDR
// if GetClass ( i ) in [ 12 , 16 ] then
59017: LD_VAR 0 6
59021: PPUSH
59022: CALL_OW 257
59026: PUSH
59027: LD_INT 12
59029: PUSH
59030: LD_INT 16
59032: PUSH
59033: EMPTY
59034: LIST
59035: LIST
59036: IN
59037: IFFALSE 59058
// points := [ 5 , 3 , 2 ] ;
59039: LD_ADDR_VAR 0 9
59043: PUSH
59044: LD_INT 5
59046: PUSH
59047: LD_INT 3
59049: PUSH
59050: LD_INT 2
59052: PUSH
59053: EMPTY
59054: LIST
59055: LIST
59056: LIST
59057: ST_TO_ADDR
// if GetClass ( i ) = 17 then
59058: LD_VAR 0 6
59062: PPUSH
59063: CALL_OW 257
59067: PUSH
59068: LD_INT 17
59070: EQUAL
59071: IFFALSE 59092
// points := [ 100 , 50 , 75 ] ;
59073: LD_ADDR_VAR 0 9
59077: PUSH
59078: LD_INT 100
59080: PUSH
59081: LD_INT 50
59083: PUSH
59084: LD_INT 75
59086: PUSH
59087: EMPTY
59088: LIST
59089: LIST
59090: LIST
59091: ST_TO_ADDR
// if GetClass ( i ) = 15 then
59092: LD_VAR 0 6
59096: PPUSH
59097: CALL_OW 257
59101: PUSH
59102: LD_INT 15
59104: EQUAL
59105: IFFALSE 59126
// points := [ 10 , 5 , 3 ] ;
59107: LD_ADDR_VAR 0 9
59111: PUSH
59112: LD_INT 10
59114: PUSH
59115: LD_INT 5
59117: PUSH
59118: LD_INT 3
59120: PUSH
59121: EMPTY
59122: LIST
59123: LIST
59124: LIST
59125: ST_TO_ADDR
// if GetClass ( i ) = 14 then
59126: LD_VAR 0 6
59130: PPUSH
59131: CALL_OW 257
59135: PUSH
59136: LD_INT 14
59138: EQUAL
59139: IFFALSE 59160
// points := [ 10 , 0 , 0 ] ;
59141: LD_ADDR_VAR 0 9
59145: PUSH
59146: LD_INT 10
59148: PUSH
59149: LD_INT 0
59151: PUSH
59152: LD_INT 0
59154: PUSH
59155: EMPTY
59156: LIST
59157: LIST
59158: LIST
59159: ST_TO_ADDR
// if GetClass ( i ) = 11 then
59160: LD_VAR 0 6
59164: PPUSH
59165: CALL_OW 257
59169: PUSH
59170: LD_INT 11
59172: EQUAL
59173: IFFALSE 59194
// points := [ 30 , 10 , 5 ] ;
59175: LD_ADDR_VAR 0 9
59179: PUSH
59180: LD_INT 30
59182: PUSH
59183: LD_INT 10
59185: PUSH
59186: LD_INT 5
59188: PUSH
59189: EMPTY
59190: LIST
59191: LIST
59192: LIST
59193: ST_TO_ADDR
// if GetTech ( side , tech_stimdrugs ) = state_researched then
59194: LD_VAR 0 1
59198: PPUSH
59199: LD_INT 5
59201: PPUSH
59202: CALL_OW 321
59206: PUSH
59207: LD_INT 2
59209: EQUAL
59210: IFFALSE 59227
// bpoints := bpoints * 1.8 ;
59212: LD_ADDR_VAR 0 10
59216: PUSH
59217: LD_VAR 0 10
59221: PUSH
59222: LD_REAL  1.80000000000000E+0000
59225: MUL
59226: ST_TO_ADDR
// if GetClass ( i ) in [ 1 , 2 , 3 , 4 ] and GetTech ( side , tech_weap1 ) = state_researched then
59227: LD_VAR 0 6
59231: PPUSH
59232: CALL_OW 257
59236: PUSH
59237: LD_INT 1
59239: PUSH
59240: LD_INT 2
59242: PUSH
59243: LD_INT 3
59245: PUSH
59246: LD_INT 4
59248: PUSH
59249: EMPTY
59250: LIST
59251: LIST
59252: LIST
59253: LIST
59254: IN
59255: PUSH
59256: LD_VAR 0 1
59260: PPUSH
59261: LD_INT 51
59263: PPUSH
59264: CALL_OW 321
59268: PUSH
59269: LD_INT 2
59271: EQUAL
59272: AND
59273: IFFALSE 59290
// bpoints := bpoints * 1.2 ;
59275: LD_ADDR_VAR 0 10
59279: PUSH
59280: LD_VAR 0 10
59284: PUSH
59285: LD_REAL  1.20000000000000E+0000
59288: MUL
59289: ST_TO_ADDR
// if GetClass ( i ) in [ 5 , 7 , 9 ] and GetTech ( side , tech_weap2 ) = state_researched then
59290: LD_VAR 0 6
59294: PPUSH
59295: CALL_OW 257
59299: PUSH
59300: LD_INT 5
59302: PUSH
59303: LD_INT 7
59305: PUSH
59306: LD_INT 9
59308: PUSH
59309: EMPTY
59310: LIST
59311: LIST
59312: LIST
59313: IN
59314: PUSH
59315: LD_VAR 0 1
59319: PPUSH
59320: LD_INT 52
59322: PPUSH
59323: CALL_OW 321
59327: PUSH
59328: LD_INT 2
59330: EQUAL
59331: AND
59332: IFFALSE 59349
// bpoints := bpoints * 1.5 ;
59334: LD_ADDR_VAR 0 10
59338: PUSH
59339: LD_VAR 0 10
59343: PUSH
59344: LD_REAL  1.50000000000000E+0000
59347: MUL
59348: ST_TO_ADDR
// if GetTech ( side , tech_bio1 ) = state_researched then
59349: LD_VAR 0 1
59353: PPUSH
59354: LD_INT 66
59356: PPUSH
59357: CALL_OW 321
59361: PUSH
59362: LD_INT 2
59364: EQUAL
59365: IFFALSE 59382
// bpoints := bpoints * 1.1 ;
59367: LD_ADDR_VAR 0 10
59371: PUSH
59372: LD_VAR 0 10
59376: PUSH
59377: LD_REAL  1.10000000000000E+0000
59380: MUL
59381: ST_TO_ADDR
// bpoints := bpoints * ( GetSkill ( i , 1 ) * 1.15 ) ;
59382: LD_ADDR_VAR 0 10
59386: PUSH
59387: LD_VAR 0 10
59391: PUSH
59392: LD_VAR 0 6
59396: PPUSH
59397: LD_INT 1
59399: PPUSH
59400: CALL_OW 259
59404: PUSH
59405: LD_REAL  1.15000000000000E+0000
59408: MUL
59409: MUL
59410: ST_TO_ADDR
// end ; unit_vehicle :
59411: GO 60235
59413: LD_INT 2
59415: DOUBLE
59416: EQUAL
59417: IFTRUE 59421
59419: GO 60223
59421: POP
// begin if GetWeapon ( i ) in [ us_machine_gun , ru_heavy_machine_gun , ar_double_machine_gun ] then
59422: LD_VAR 0 6
59426: PPUSH
59427: CALL_OW 264
59431: PUSH
59432: LD_INT 2
59434: PUSH
59435: LD_INT 42
59437: PUSH
59438: LD_INT 24
59440: PUSH
59441: EMPTY
59442: LIST
59443: LIST
59444: LIST
59445: IN
59446: IFFALSE 59467
// points := [ 25 , 5 , 3 ] ;
59448: LD_ADDR_VAR 0 9
59452: PUSH
59453: LD_INT 25
59455: PUSH
59456: LD_INT 5
59458: PUSH
59459: LD_INT 3
59461: PUSH
59462: EMPTY
59463: LIST
59464: LIST
59465: LIST
59466: ST_TO_ADDR
// if GetWeapon ( i ) in [ us_gatling_gun , ru_gatling_gun , ar_gatling_gun ] then
59467: LD_VAR 0 6
59471: PPUSH
59472: CALL_OW 264
59476: PUSH
59477: LD_INT 4
59479: PUSH
59480: LD_INT 43
59482: PUSH
59483: LD_INT 25
59485: PUSH
59486: EMPTY
59487: LIST
59488: LIST
59489: LIST
59490: IN
59491: IFFALSE 59512
// points := [ 40 , 15 , 5 ] ;
59493: LD_ADDR_VAR 0 9
59497: PUSH
59498: LD_INT 40
59500: PUSH
59501: LD_INT 15
59503: PUSH
59504: LD_INT 5
59506: PUSH
59507: EMPTY
59508: LIST
59509: LIST
59510: LIST
59511: ST_TO_ADDR
// if GetWeapon ( i ) in [ us_light_gun , ar_light_gun ] then
59512: LD_VAR 0 6
59516: PPUSH
59517: CALL_OW 264
59521: PUSH
59522: LD_INT 3
59524: PUSH
59525: LD_INT 23
59527: PUSH
59528: EMPTY
59529: LIST
59530: LIST
59531: IN
59532: IFFALSE 59553
// points := [ 7 , 25 , 8 ] ;
59534: LD_ADDR_VAR 0 9
59538: PUSH
59539: LD_INT 7
59541: PUSH
59542: LD_INT 25
59544: PUSH
59545: LD_INT 8
59547: PUSH
59548: EMPTY
59549: LIST
59550: LIST
59551: LIST
59552: ST_TO_ADDR
// if GetWeapon ( i ) in [ us_double_gun , ar_gun , ru_gun ] then
59553: LD_VAR 0 6
59557: PPUSH
59558: CALL_OW 264
59562: PUSH
59563: LD_INT 5
59565: PUSH
59566: LD_INT 27
59568: PUSH
59569: LD_INT 44
59571: PUSH
59572: EMPTY
59573: LIST
59574: LIST
59575: LIST
59576: IN
59577: IFFALSE 59598
// points := [ 14 , 50 , 16 ] ;
59579: LD_ADDR_VAR 0 9
59583: PUSH
59584: LD_INT 14
59586: PUSH
59587: LD_INT 50
59589: PUSH
59590: LD_INT 16
59592: PUSH
59593: EMPTY
59594: LIST
59595: LIST
59596: LIST
59597: ST_TO_ADDR
// if GetWeapon ( i ) in [ us_heavy_gun , ru_heavy_gun ] then
59598: LD_VAR 0 6
59602: PPUSH
59603: CALL_OW 264
59607: PUSH
59608: LD_INT 6
59610: PUSH
59611: LD_INT 46
59613: PUSH
59614: EMPTY
59615: LIST
59616: LIST
59617: IN
59618: IFFALSE 59639
// points := [ 32 , 120 , 70 ] ;
59620: LD_ADDR_VAR 0 9
59624: PUSH
59625: LD_INT 32
59627: PUSH
59628: LD_INT 120
59630: PUSH
59631: LD_INT 70
59633: PUSH
59634: EMPTY
59635: LIST
59636: LIST
59637: LIST
59638: ST_TO_ADDR
// if GetWeapon ( i ) in [ us_rocket_launcher , ar_rocket_launcher , ru_rocket_launcher ] then
59639: LD_VAR 0 6
59643: PPUSH
59644: CALL_OW 264
59648: PUSH
59649: LD_INT 7
59651: PUSH
59652: LD_INT 28
59654: PUSH
59655: LD_INT 45
59657: PUSH
59658: EMPTY
59659: LIST
59660: LIST
59661: LIST
59662: IN
59663: IFFALSE 59684
// points := [ 35 , 20 , 45 ] ;
59665: LD_ADDR_VAR 0 9
59669: PUSH
59670: LD_INT 35
59672: PUSH
59673: LD_INT 20
59675: PUSH
59676: LD_INT 45
59678: PUSH
59679: EMPTY
59680: LIST
59681: LIST
59682: LIST
59683: ST_TO_ADDR
// if GetWeapon ( i ) in [ ru_rocket ] then
59684: LD_VAR 0 6
59688: PPUSH
59689: CALL_OW 264
59693: PUSH
59694: LD_INT 47
59696: PUSH
59697: EMPTY
59698: LIST
59699: IN
59700: IFFALSE 59721
// points := [ 67 , 45 , 75 ] ;
59702: LD_ADDR_VAR 0 9
59706: PUSH
59707: LD_INT 67
59709: PUSH
59710: LD_INT 45
59712: PUSH
59713: LD_INT 75
59715: PUSH
59716: EMPTY
59717: LIST
59718: LIST
59719: LIST
59720: ST_TO_ADDR
// if GetWeapon ( i ) in [ ar_flame_thrower ] then
59721: LD_VAR 0 6
59725: PPUSH
59726: CALL_OW 264
59730: PUSH
59731: LD_INT 26
59733: PUSH
59734: EMPTY
59735: LIST
59736: IN
59737: IFFALSE 59758
// points := [ 120 , 30 , 80 ] ;
59739: LD_ADDR_VAR 0 9
59743: PUSH
59744: LD_INT 120
59746: PUSH
59747: LD_INT 30
59749: PUSH
59750: LD_INT 80
59752: PUSH
59753: EMPTY
59754: LIST
59755: LIST
59756: LIST
59757: ST_TO_ADDR
// if GetWeapon ( i ) in [ ar_multimissile_ballista ] then
59758: LD_VAR 0 6
59762: PPUSH
59763: CALL_OW 264
59767: PUSH
59768: LD_INT 22
59770: PUSH
59771: EMPTY
59772: LIST
59773: IN
59774: IFFALSE 59795
// points := [ 40 , 1 , 1 ] ;
59776: LD_ADDR_VAR 0 9
59780: PUSH
59781: LD_INT 40
59783: PUSH
59784: LD_INT 1
59786: PUSH
59787: LD_INT 1
59789: PUSH
59790: EMPTY
59791: LIST
59792: LIST
59793: LIST
59794: ST_TO_ADDR
// if GetWeapon ( i ) in [ ar_selfpropelled_bomb ] then
59795: LD_VAR 0 6
59799: PPUSH
59800: CALL_OW 264
59804: PUSH
59805: LD_INT 29
59807: PUSH
59808: EMPTY
59809: LIST
59810: IN
59811: IFFALSE 59832
// points := [ 70 , 200 , 400 ] ;
59813: LD_ADDR_VAR 0 9
59817: PUSH
59818: LD_INT 70
59820: PUSH
59821: LD_INT 200
59823: PUSH
59824: LD_INT 400
59826: PUSH
59827: EMPTY
59828: LIST
59829: LIST
59830: LIST
59831: ST_TO_ADDR
// if GetWeapon ( i ) in [ us_bulldozer , ru_bulldozer ] then
59832: LD_VAR 0 6
59836: PPUSH
59837: CALL_OW 264
59841: PUSH
59842: LD_INT 14
59844: PUSH
59845: LD_INT 53
59847: PUSH
59848: EMPTY
59849: LIST
59850: LIST
59851: IN
59852: IFFALSE 59873
// points := [ 40 , 10 , 20 ] ;
59854: LD_ADDR_VAR 0 9
59858: PUSH
59859: LD_INT 40
59861: PUSH
59862: LD_INT 10
59864: PUSH
59865: LD_INT 20
59867: PUSH
59868: EMPTY
59869: LIST
59870: LIST
59871: LIST
59872: ST_TO_ADDR
// if GetWeapon ( i ) in [ us_laser ] then
59873: LD_VAR 0 6
59877: PPUSH
59878: CALL_OW 264
59882: PUSH
59883: LD_INT 9
59885: PUSH
59886: EMPTY
59887: LIST
59888: IN
59889: IFFALSE 59910
// points := [ 5 , 70 , 20 ] ;
59891: LD_ADDR_VAR 0 9
59895: PUSH
59896: LD_INT 5
59898: PUSH
59899: LD_INT 70
59901: PUSH
59902: LD_INT 20
59904: PUSH
59905: EMPTY
59906: LIST
59907: LIST
59908: LIST
59909: ST_TO_ADDR
// if GetWeapon ( i ) in [ us_double_laser ] then
59910: LD_VAR 0 6
59914: PPUSH
59915: CALL_OW 264
59919: PUSH
59920: LD_INT 10
59922: PUSH
59923: EMPTY
59924: LIST
59925: IN
59926: IFFALSE 59947
// points := [ 35 , 110 , 70 ] ;
59928: LD_ADDR_VAR 0 9
59932: PUSH
59933: LD_INT 35
59935: PUSH
59936: LD_INT 110
59938: PUSH
59939: LD_INT 70
59941: PUSH
59942: EMPTY
59943: LIST
59944: LIST
59945: LIST
59946: ST_TO_ADDR
// if GetChassis ( i ) = 25 then
59947: LD_VAR 0 6
59951: PPUSH
59952: CALL_OW 265
59956: PUSH
59957: LD_INT 25
59959: EQUAL
59960: IFFALSE 59981
// points := [ 80 , 65 , 100 ] ;
59962: LD_ADDR_VAR 0 9
59966: PUSH
59967: LD_INT 80
59969: PUSH
59970: LD_INT 65
59972: PUSH
59973: LD_INT 100
59975: PUSH
59976: EMPTY
59977: LIST
59978: LIST
59979: LIST
59980: ST_TO_ADDR
// if GetControl ( i ) = control_manual then
59981: LD_VAR 0 6
59985: PPUSH
59986: CALL_OW 263
59990: PUSH
59991: LD_INT 1
59993: EQUAL
59994: IFFALSE 60029
// bpoints := bpoints * ( GetSkill ( IsDrivenBy ( i ) , 3 ) * 4 ) ;
59996: LD_ADDR_VAR 0 10
60000: PUSH
60001: LD_VAR 0 10
60005: PUSH
60006: LD_VAR 0 6
60010: PPUSH
60011: CALL_OW 311
60015: PPUSH
60016: LD_INT 3
60018: PPUSH
60019: CALL_OW 259
60023: PUSH
60024: LD_INT 4
60026: MUL
60027: MUL
60028: ST_TO_ADDR
// if GetControl ( i ) = control_remote then
60029: LD_VAR 0 6
60033: PPUSH
60034: CALL_OW 263
60038: PUSH
60039: LD_INT 2
60041: EQUAL
60042: IFFALSE 60093
// begin j := IsControledBy ( i ) ;
60044: LD_ADDR_VAR 0 7
60048: PUSH
60049: LD_VAR 0 6
60053: PPUSH
60054: CALL_OW 312
60058: ST_TO_ADDR
// if j then
60059: LD_VAR 0 7
60063: IFFALSE 60093
// bpoints := bpoints * ( GetSkill ( j , 3 ) * 3 ) ;
60065: LD_ADDR_VAR 0 10
60069: PUSH
60070: LD_VAR 0 10
60074: PUSH
60075: LD_VAR 0 7
60079: PPUSH
60080: LD_INT 3
60082: PPUSH
60083: CALL_OW 259
60087: PUSH
60088: LD_INT 3
60090: MUL
60091: MUL
60092: ST_TO_ADDR
// end ; if GetWeapon ( i ) in [ us_double_gun , us_heavy_gun , ru_heavy_gun , ru_gun , ru_rocket , ru_rocket_launcher , ar_rocket_launcher , us_rocket_launcher , ar_gun , ar_selfpropelled_bomb ] and GetTech ( side , tech_weap2 ) = state_researched then
60093: LD_VAR 0 6
60097: PPUSH
60098: CALL_OW 264
60102: PUSH
60103: LD_INT 5
60105: PUSH
60106: LD_INT 6
60108: PUSH
60109: LD_INT 46
60111: PUSH
60112: LD_INT 44
60114: PUSH
60115: LD_INT 47
60117: PUSH
60118: LD_INT 45
60120: PUSH
60121: LD_INT 28
60123: PUSH
60124: LD_INT 7
60126: PUSH
60127: LD_INT 27
60129: PUSH
60130: LD_INT 29
60132: PUSH
60133: EMPTY
60134: LIST
60135: LIST
60136: LIST
60137: LIST
60138: LIST
60139: LIST
60140: LIST
60141: LIST
60142: LIST
60143: LIST
60144: IN
60145: PUSH
60146: LD_VAR 0 1
60150: PPUSH
60151: LD_INT 52
60153: PPUSH
60154: CALL_OW 321
60158: PUSH
60159: LD_INT 2
60161: EQUAL
60162: AND
60163: IFFALSE 60180
// bpoints := bpoints * 1.2 ;
60165: LD_ADDR_VAR 0 10
60169: PUSH
60170: LD_VAR 0 10
60174: PUSH
60175: LD_REAL  1.20000000000000E+0000
60178: MUL
60179: ST_TO_ADDR
// if GetWeapon ( i ) in [ us_heavy_gun , ru_heavy_gun , ru_rocket ] then
60180: LD_VAR 0 6
60184: PPUSH
60185: CALL_OW 264
60189: PUSH
60190: LD_INT 6
60192: PUSH
60193: LD_INT 46
60195: PUSH
60196: LD_INT 47
60198: PUSH
60199: EMPTY
60200: LIST
60201: LIST
60202: LIST
60203: IN
60204: IFFALSE 60221
// bpoints := bpoints * 1.2 ;
60206: LD_ADDR_VAR 0 10
60210: PUSH
60211: LD_VAR 0 10
60215: PUSH
60216: LD_REAL  1.20000000000000E+0000
60219: MUL
60220: ST_TO_ADDR
// end ; unit_building :
60221: GO 60235
60223: LD_INT 3
60225: DOUBLE
60226: EQUAL
60227: IFTRUE 60231
60229: GO 60234
60231: POP
// ; end ;
60232: GO 60235
60234: POP
// for j = 1 to 3 do
60235: LD_ADDR_VAR 0 7
60239: PUSH
60240: DOUBLE
60241: LD_INT 1
60243: DEC
60244: ST_TO_ADDR
60245: LD_INT 3
60247: PUSH
60248: FOR_TO
60249: IFFALSE 60302
// result := Replace ( result , j , result [ j ] + ( points [ j ] * bpoints ) ) ;
60251: LD_ADDR_VAR 0 5
60255: PUSH
60256: LD_VAR 0 5
60260: PPUSH
60261: LD_VAR 0 7
60265: PPUSH
60266: LD_VAR 0 5
60270: PUSH
60271: LD_VAR 0 7
60275: ARRAY
60276: PUSH
60277: LD_VAR 0 9
60281: PUSH
60282: LD_VAR 0 7
60286: ARRAY
60287: PUSH
60288: LD_VAR 0 10
60292: MUL
60293: PLUS
60294: PPUSH
60295: CALL_OW 1
60299: ST_TO_ADDR
60300: GO 60248
60302: POP
60303: POP
// end ;
60304: GO 58787
60306: POP
60307: POP
// result := Replace ( result , 4 , tmp ) ;
60308: LD_ADDR_VAR 0 5
60312: PUSH
60313: LD_VAR 0 5
60317: PPUSH
60318: LD_INT 4
60320: PPUSH
60321: LD_VAR 0 8
60325: PPUSH
60326: CALL_OW 1
60330: ST_TO_ADDR
// end ;
60331: LD_VAR 0 5
60335: RET
// export function DangerAtRange ( unit , range ) ; begin
60336: LD_INT 0
60338: PPUSH
// result := DangerAtRangeXY ( GetSide ( unit ) , GetX ( unit ) , GetY ( unit ) , range ) ;
60339: LD_ADDR_VAR 0 3
60343: PUSH
60344: LD_VAR 0 1
60348: PPUSH
60349: CALL_OW 255
60353: PPUSH
60354: LD_VAR 0 1
60358: PPUSH
60359: CALL_OW 250
60363: PPUSH
60364: LD_VAR 0 1
60368: PPUSH
60369: CALL_OW 251
60373: PPUSH
60374: LD_VAR 0 2
60378: PPUSH
60379: CALL 58639 0 4
60383: ST_TO_ADDR
// end ;
60384: LD_VAR 0 3
60388: RET
// export function DangerInArea ( side , area ) ; begin
60389: LD_INT 0
60391: PPUSH
// result := FilterUnitsInArea ( area , [ f_enemy , side ] ) ;
60392: LD_ADDR_VAR 0 3
60396: PUSH
60397: LD_VAR 0 2
60401: PPUSH
60402: LD_INT 81
60404: PUSH
60405: LD_VAR 0 1
60409: PUSH
60410: EMPTY
60411: LIST
60412: LIST
60413: PPUSH
60414: CALL_OW 70
60418: ST_TO_ADDR
// end ;
60419: LD_VAR 0 3
60423: RET
// export function IsExtension ( b ) ; begin
60424: LD_INT 0
60426: PPUSH
// result := b in [ b_ext_stitch , b_ext_radar , b_ext_radio , b_ext_gun , b_ext_computer , b_ext_siberium , b_ext_noncombat , b_ext_track , b_ext_laser , b_ext_rocket ] ;
60427: LD_ADDR_VAR 0 2
60431: PUSH
60432: LD_VAR 0 1
60436: PUSH
60437: LD_INT 23
60439: PUSH
60440: LD_INT 20
60442: PUSH
60443: LD_INT 22
60445: PUSH
60446: LD_INT 17
60448: PUSH
60449: LD_INT 24
60451: PUSH
60452: LD_INT 21
60454: PUSH
60455: LD_INT 19
60457: PUSH
60458: LD_INT 16
60460: PUSH
60461: LD_INT 25
60463: PUSH
60464: LD_INT 18
60466: PUSH
60467: EMPTY
60468: LIST
60469: LIST
60470: LIST
60471: LIST
60472: LIST
60473: LIST
60474: LIST
60475: LIST
60476: LIST
60477: LIST
60478: IN
60479: ST_TO_ADDR
// end ;
60480: LD_VAR 0 2
60484: RET
// export function GetBaseBuildings ( base , area ) ; var tmp , i ; begin
60485: LD_INT 0
60487: PPUSH
60488: PPUSH
60489: PPUSH
// result := [ ] ;
60490: LD_ADDR_VAR 0 3
60494: PUSH
60495: EMPTY
60496: ST_TO_ADDR
// tmp := FilterUnitsInArea ( area , [ f_type , unit_building ] ) ;
60497: LD_ADDR_VAR 0 4
60501: PUSH
60502: LD_VAR 0 2
60506: PPUSH
60507: LD_INT 21
60509: PUSH
60510: LD_INT 3
60512: PUSH
60513: EMPTY
60514: LIST
60515: LIST
60516: PPUSH
60517: CALL_OW 70
60521: ST_TO_ADDR
// if not tmp then
60522: LD_VAR 0 4
60526: NOT
60527: IFFALSE 60531
// exit ;
60529: GO 60589
// for i in tmp do
60531: LD_ADDR_VAR 0 5
60535: PUSH
60536: LD_VAR 0 4
60540: PUSH
60541: FOR_IN
60542: IFFALSE 60577
// if GetBase ( i ) <> base then
60544: LD_VAR 0 5
60548: PPUSH
60549: CALL_OW 274
60553: PUSH
60554: LD_VAR 0 1
60558: NONEQUAL
60559: IFFALSE 60575
// ComLinkToBase ( base , i ) ;
60561: LD_VAR 0 1
60565: PPUSH
60566: LD_VAR 0 5
60570: PPUSH
60571: CALL_OW 169
60575: GO 60541
60577: POP
60578: POP
// result := tmp ;
60579: LD_ADDR_VAR 0 3
60583: PUSH
60584: LD_VAR 0 4
60588: ST_TO_ADDR
// end ;
60589: LD_VAR 0 3
60593: RET
// export function ComComplete ( unit , b ) ; var i ; begin
60594: LD_INT 0
60596: PPUSH
60597: PPUSH
// if BuildingStatus ( b ) = bs_build then
60598: LD_VAR 0 2
60602: PPUSH
60603: CALL_OW 461
60607: PUSH
60608: LD_INT 1
60610: EQUAL
60611: IFFALSE 60671
// SetTaskList ( unit , [ [ h , GetX ( b ) , GetY ( b ) , b , 0 , 0 , 0 ] ] ) ;
60613: LD_VAR 0 1
60617: PPUSH
60618: LD_STRING h
60620: PUSH
60621: LD_VAR 0 2
60625: PPUSH
60626: CALL_OW 250
60630: PUSH
60631: LD_VAR 0 2
60635: PPUSH
60636: CALL_OW 251
60640: PUSH
60641: LD_VAR 0 2
60645: PUSH
60646: LD_INT 0
60648: PUSH
60649: LD_INT 0
60651: PUSH
60652: LD_INT 0
60654: PUSH
60655: EMPTY
60656: LIST
60657: LIST
60658: LIST
60659: LIST
60660: LIST
60661: LIST
60662: LIST
60663: PUSH
60664: EMPTY
60665: LIST
60666: PPUSH
60667: CALL_OW 446
// end ;
60671: LD_VAR 0 3
60675: RET
// export function Connect ( vehicle ) ; var i , t , mech , tmp , j ; begin
60676: LD_INT 0
60678: PPUSH
60679: PPUSH
60680: PPUSH
60681: PPUSH
60682: PPUSH
60683: PPUSH
// if not vehicle or not GetControl ( vehicle ) = control_remote then
60684: LD_VAR 0 1
60688: NOT
60689: PUSH
60690: LD_VAR 0 1
60694: PPUSH
60695: CALL_OW 263
60699: PUSH
60700: LD_INT 2
60702: EQUAL
60703: NOT
60704: OR
60705: IFFALSE 60709
// exit ;
60707: GO 61025
// tmp := FilterAllUnits ( [ [ f_side , GetSide ( vehicle ) ] , [ f_or , [ f_btype , b_control_tower ] , [ f_weapon , ar_control_tower ] ] ] ) ;
60709: LD_ADDR_VAR 0 6
60713: PUSH
60714: LD_INT 22
60716: PUSH
60717: LD_VAR 0 1
60721: PPUSH
60722: CALL_OW 255
60726: PUSH
60727: EMPTY
60728: LIST
60729: LIST
60730: PUSH
60731: LD_INT 2
60733: PUSH
60734: LD_INT 30
60736: PUSH
60737: LD_INT 36
60739: PUSH
60740: EMPTY
60741: LIST
60742: LIST
60743: PUSH
60744: LD_INT 34
60746: PUSH
60747: LD_INT 31
60749: PUSH
60750: EMPTY
60751: LIST
60752: LIST
60753: PUSH
60754: EMPTY
60755: LIST
60756: LIST
60757: LIST
60758: PUSH
60759: EMPTY
60760: LIST
60761: LIST
60762: PPUSH
60763: CALL_OW 69
60767: ST_TO_ADDR
// if not tmp then
60768: LD_VAR 0 6
60772: NOT
60773: IFFALSE 60777
// exit ;
60775: GO 61025
// result := [ ] ;
60777: LD_ADDR_VAR 0 2
60781: PUSH
60782: EMPTY
60783: ST_TO_ADDR
// for i in tmp do
60784: LD_ADDR_VAR 0 3
60788: PUSH
60789: LD_VAR 0 6
60793: PUSH
60794: FOR_IN
60795: IFFALSE 60866
// begin t := UnitsInside ( i ) ;
60797: LD_ADDR_VAR 0 4
60801: PUSH
60802: LD_VAR 0 3
60806: PPUSH
60807: CALL_OW 313
60811: ST_TO_ADDR
// if t then
60812: LD_VAR 0 4
60816: IFFALSE 60864
// for j in t do
60818: LD_ADDR_VAR 0 7
60822: PUSH
60823: LD_VAR 0 4
60827: PUSH
60828: FOR_IN
60829: IFFALSE 60862
// result := Insert ( result , result + 1 , j ) ;
60831: LD_ADDR_VAR 0 2
60835: PUSH
60836: LD_VAR 0 2
60840: PPUSH
60841: LD_VAR 0 2
60845: PUSH
60846: LD_INT 1
60848: PLUS
60849: PPUSH
60850: LD_VAR 0 7
60854: PPUSH
60855: CALL_OW 2
60859: ST_TO_ADDR
60860: GO 60828
60862: POP
60863: POP
// end ;
60864: GO 60794
60866: POP
60867: POP
// if not result then
60868: LD_VAR 0 2
60872: NOT
60873: IFFALSE 60877
// exit ;
60875: GO 61025
// mech := result [ 1 ] ;
60877: LD_ADDR_VAR 0 5
60881: PUSH
60882: LD_VAR 0 2
60886: PUSH
60887: LD_INT 1
60889: ARRAY
60890: ST_TO_ADDR
// if result > 1 then
60891: LD_VAR 0 2
60895: PUSH
60896: LD_INT 1
60898: GREATER
60899: IFFALSE 61011
// for i = 2 to result do
60901: LD_ADDR_VAR 0 3
60905: PUSH
60906: DOUBLE
60907: LD_INT 2
60909: DEC
60910: ST_TO_ADDR
60911: LD_VAR 0 2
60915: PUSH
60916: FOR_TO
60917: IFFALSE 61009
// begin t := GetSkill ( result [ i ] , 3 ) - UnitsLinked ( result [ i ] ) ;
60919: LD_ADDR_VAR 0 4
60923: PUSH
60924: LD_VAR 0 2
60928: PUSH
60929: LD_VAR 0 3
60933: ARRAY
60934: PPUSH
60935: LD_INT 3
60937: PPUSH
60938: CALL_OW 259
60942: PUSH
60943: LD_VAR 0 2
60947: PUSH
60948: LD_VAR 0 3
60952: ARRAY
60953: PPUSH
60954: CALL_OW 432
60958: MINUS
60959: ST_TO_ADDR
// if t >= ( GetSkill ( mech , 3 ) - UnitsLinked ( mech ) ) then
60960: LD_VAR 0 4
60964: PUSH
60965: LD_VAR 0 5
60969: PPUSH
60970: LD_INT 3
60972: PPUSH
60973: CALL_OW 259
60977: PUSH
60978: LD_VAR 0 5
60982: PPUSH
60983: CALL_OW 432
60987: MINUS
60988: GREATEREQUAL
60989: IFFALSE 61007
// mech := result [ i ] ;
60991: LD_ADDR_VAR 0 5
60995: PUSH
60996: LD_VAR 0 2
61000: PUSH
61001: LD_VAR 0 3
61005: ARRAY
61006: ST_TO_ADDR
// end ;
61007: GO 60916
61009: POP
61010: POP
// ComLinkTo ( vehicle , mech ) ;
61011: LD_VAR 0 1
61015: PPUSH
61016: LD_VAR 0 5
61020: PPUSH
61021: CALL_OW 135
// end ;
61025: LD_VAR 0 2
61029: RET
// export function PrepareBase ( base_dep , area , name , skill , sources , personel ) ; var i , j , d , b , f , x , un , base , side , nation , buildings , tmp ; begin
61030: LD_INT 0
61032: PPUSH
61033: PPUSH
61034: PPUSH
61035: PPUSH
61036: PPUSH
61037: PPUSH
61038: PPUSH
61039: PPUSH
61040: PPUSH
61041: PPUSH
61042: PPUSH
61043: PPUSH
61044: PPUSH
// result := [ ] ;
61045: LD_ADDR_VAR 0 7
61049: PUSH
61050: EMPTY
61051: ST_TO_ADDR
// if not GetBType ( base_dep ) in [ b_depot , b_warehouse ] then
61052: LD_VAR 0 1
61056: PPUSH
61057: CALL_OW 266
61061: PUSH
61062: LD_INT 0
61064: PUSH
61065: LD_INT 1
61067: PUSH
61068: EMPTY
61069: LIST
61070: LIST
61071: IN
61072: NOT
61073: IFFALSE 61077
// exit ;
61075: GO 62708
// if name then
61077: LD_VAR 0 3
61081: IFFALSE 61097
// SetBName ( base_dep , name ) ;
61083: LD_VAR 0 1
61087: PPUSH
61088: LD_VAR 0 3
61092: PPUSH
61093: CALL_OW 500
// base := GetBase ( base_dep ) ;
61097: LD_ADDR_VAR 0 15
61101: PUSH
61102: LD_VAR 0 1
61106: PPUSH
61107: CALL_OW 274
61111: ST_TO_ADDR
// side := GetSide ( base_dep ) ;
61112: LD_ADDR_VAR 0 16
61116: PUSH
61117: LD_VAR 0 1
61121: PPUSH
61122: CALL_OW 255
61126: ST_TO_ADDR
// nation := GetNation ( base_dep ) ;
61127: LD_ADDR_VAR 0 17
61131: PUSH
61132: LD_VAR 0 1
61136: PPUSH
61137: CALL_OW 248
61141: ST_TO_ADDR
// if sources then
61142: LD_VAR 0 5
61146: IFFALSE 61193
// for i = 1 to 3 do
61148: LD_ADDR_VAR 0 8
61152: PUSH
61153: DOUBLE
61154: LD_INT 1
61156: DEC
61157: ST_TO_ADDR
61158: LD_INT 3
61160: PUSH
61161: FOR_TO
61162: IFFALSE 61191
// AddResourceType ( base , i , sources [ i ] ) ;
61164: LD_VAR 0 15
61168: PPUSH
61169: LD_VAR 0 8
61173: PPUSH
61174: LD_VAR 0 5
61178: PUSH
61179: LD_VAR 0 8
61183: ARRAY
61184: PPUSH
61185: CALL_OW 276
61189: GO 61161
61191: POP
61192: POP
// buildings := GetBaseBuildings ( base , area ) ;
61193: LD_ADDR_VAR 0 18
61197: PUSH
61198: LD_VAR 0 15
61202: PPUSH
61203: LD_VAR 0 2
61207: PPUSH
61208: CALL 60485 0 2
61212: ST_TO_ADDR
// InitHc ;
61213: CALL_OW 19
// InitUc ;
61217: CALL_OW 18
// uc_side := side ;
61221: LD_ADDR_OWVAR 20
61225: PUSH
61226: LD_VAR 0 16
61230: ST_TO_ADDR
// uc_nation := nation ;
61231: LD_ADDR_OWVAR 21
61235: PUSH
61236: LD_VAR 0 17
61240: ST_TO_ADDR
// if buildings then
61241: LD_VAR 0 18
61245: IFFALSE 62567
// begin tmp := UnitFilter ( buildings , [ f_or , [ f_btype , b_oil_mine ] , [ f_btype , b_siberite_mine ] ] ) ;
61247: LD_ADDR_VAR 0 19
61251: PUSH
61252: LD_VAR 0 18
61256: PPUSH
61257: LD_INT 2
61259: PUSH
61260: LD_INT 30
61262: PUSH
61263: LD_INT 29
61265: PUSH
61266: EMPTY
61267: LIST
61268: LIST
61269: PUSH
61270: LD_INT 30
61272: PUSH
61273: LD_INT 30
61275: PUSH
61276: EMPTY
61277: LIST
61278: LIST
61279: PUSH
61280: EMPTY
61281: LIST
61282: LIST
61283: LIST
61284: PPUSH
61285: CALL_OW 72
61289: ST_TO_ADDR
// if tmp then
61290: LD_VAR 0 19
61294: IFFALSE 61342
// for i in tmp do
61296: LD_ADDR_VAR 0 8
61300: PUSH
61301: LD_VAR 0 19
61305: PUSH
61306: FOR_IN
61307: IFFALSE 61340
// SetResourceVisibility ( GetX ( i ) , GetY ( i ) , side ) ;
61309: LD_VAR 0 8
61313: PPUSH
61314: CALL_OW 250
61318: PPUSH
61319: LD_VAR 0 8
61323: PPUSH
61324: CALL_OW 251
61328: PPUSH
61329: LD_VAR 0 16
61333: PPUSH
61334: CALL_OW 441
61338: GO 61306
61340: POP
61341: POP
// if UnitFilter ( buildings , [ f_or , [ f_btype , b_bunker ] , [ f_btype , b_turret ] ] ) then
61342: LD_VAR 0 18
61346: PPUSH
61347: LD_INT 2
61349: PUSH
61350: LD_INT 30
61352: PUSH
61353: LD_INT 32
61355: PUSH
61356: EMPTY
61357: LIST
61358: LIST
61359: PUSH
61360: LD_INT 30
61362: PUSH
61363: LD_INT 33
61365: PUSH
61366: EMPTY
61367: LIST
61368: LIST
61369: PUSH
61370: EMPTY
61371: LIST
61372: LIST
61373: LIST
61374: PPUSH
61375: CALL_OW 72
61379: IFFALSE 61467
// begin for i in UnitFilter ( buildings , [ f_or , [ f_btype , b_bunker ] , [ f_btype , b_turret ] ] ) do
61381: LD_ADDR_VAR 0 8
61385: PUSH
61386: LD_VAR 0 18
61390: PPUSH
61391: LD_INT 2
61393: PUSH
61394: LD_INT 30
61396: PUSH
61397: LD_INT 32
61399: PUSH
61400: EMPTY
61401: LIST
61402: LIST
61403: PUSH
61404: LD_INT 30
61406: PUSH
61407: LD_INT 33
61409: PUSH
61410: EMPTY
61411: LIST
61412: LIST
61413: PUSH
61414: EMPTY
61415: LIST
61416: LIST
61417: LIST
61418: PPUSH
61419: CALL_OW 72
61423: PUSH
61424: FOR_IN
61425: IFFALSE 61465
// begin if not GetBWeapon ( i ) then
61427: LD_VAR 0 8
61431: PPUSH
61432: CALL_OW 269
61436: NOT
61437: IFFALSE 61463
// PlaceWeaponTurret ( i , GetTurretWeapon ( i , area ) ) ;
61439: LD_VAR 0 8
61443: PPUSH
61444: LD_VAR 0 8
61448: PPUSH
61449: LD_VAR 0 2
61453: PPUSH
61454: CALL 62713 0 2
61458: PPUSH
61459: CALL_OW 431
// end ;
61463: GO 61424
61465: POP
61466: POP
// end ; for i = 1 to personel do
61467: LD_ADDR_VAR 0 8
61471: PUSH
61472: DOUBLE
61473: LD_INT 1
61475: DEC
61476: ST_TO_ADDR
61477: LD_VAR 0 6
61481: PUSH
61482: FOR_TO
61483: IFFALSE 62547
// begin if i > 4 then
61485: LD_VAR 0 8
61489: PUSH
61490: LD_INT 4
61492: GREATER
61493: IFFALSE 61497
// break ;
61495: GO 62547
// case i of 1 :
61497: LD_VAR 0 8
61501: PUSH
61502: LD_INT 1
61504: DOUBLE
61505: EQUAL
61506: IFTRUE 61510
61508: GO 61590
61510: POP
// f := UnitFilter ( buildings , [ [ f_side , side ] , [ f_empty ] , [ f_or , [ f_btype , b_bunker ] , [ f_btype , b_armoury ] , [ f_btype , b_barracks ] ] ] ) ; 2 :
61511: LD_ADDR_VAR 0 12
61515: PUSH
61516: LD_VAR 0 18
61520: PPUSH
61521: LD_INT 22
61523: PUSH
61524: LD_VAR 0 16
61528: PUSH
61529: EMPTY
61530: LIST
61531: LIST
61532: PUSH
61533: LD_INT 58
61535: PUSH
61536: EMPTY
61537: LIST
61538: PUSH
61539: LD_INT 2
61541: PUSH
61542: LD_INT 30
61544: PUSH
61545: LD_INT 32
61547: PUSH
61548: EMPTY
61549: LIST
61550: LIST
61551: PUSH
61552: LD_INT 30
61554: PUSH
61555: LD_INT 4
61557: PUSH
61558: EMPTY
61559: LIST
61560: LIST
61561: PUSH
61562: LD_INT 30
61564: PUSH
61565: LD_INT 5
61567: PUSH
61568: EMPTY
61569: LIST
61570: LIST
61571: PUSH
61572: EMPTY
61573: LIST
61574: LIST
61575: LIST
61576: LIST
61577: PUSH
61578: EMPTY
61579: LIST
61580: LIST
61581: LIST
61582: PPUSH
61583: CALL_OW 72
61587: ST_TO_ADDR
61588: GO 61812
61590: LD_INT 2
61592: DOUBLE
61593: EQUAL
61594: IFTRUE 61598
61596: GO 61660
61598: POP
// f := UnitFilter ( buildings , [ [ f_side , side ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ] ) ; 3 :
61599: LD_ADDR_VAR 0 12
61603: PUSH
61604: LD_VAR 0 18
61608: PPUSH
61609: LD_INT 22
61611: PUSH
61612: LD_VAR 0 16
61616: PUSH
61617: EMPTY
61618: LIST
61619: LIST
61620: PUSH
61621: LD_INT 2
61623: PUSH
61624: LD_INT 30
61626: PUSH
61627: LD_INT 0
61629: PUSH
61630: EMPTY
61631: LIST
61632: LIST
61633: PUSH
61634: LD_INT 30
61636: PUSH
61637: LD_INT 1
61639: PUSH
61640: EMPTY
61641: LIST
61642: LIST
61643: PUSH
61644: EMPTY
61645: LIST
61646: LIST
61647: LIST
61648: PUSH
61649: EMPTY
61650: LIST
61651: LIST
61652: PPUSH
61653: CALL_OW 72
61657: ST_TO_ADDR
61658: GO 61812
61660: LD_INT 3
61662: DOUBLE
61663: EQUAL
61664: IFTRUE 61668
61666: GO 61730
61668: POP
// f := UnitFilter ( buildings , [ [ f_side , side ] , [ f_or , [ f_btype , b_workshop ] , [ f_btype , b_factory ] ] ] ) ; 4 :
61669: LD_ADDR_VAR 0 12
61673: PUSH
61674: LD_VAR 0 18
61678: PPUSH
61679: LD_INT 22
61681: PUSH
61682: LD_VAR 0 16
61686: PUSH
61687: EMPTY
61688: LIST
61689: LIST
61690: PUSH
61691: LD_INT 2
61693: PUSH
61694: LD_INT 30
61696: PUSH
61697: LD_INT 2
61699: PUSH
61700: EMPTY
61701: LIST
61702: LIST
61703: PUSH
61704: LD_INT 30
61706: PUSH
61707: LD_INT 3
61709: PUSH
61710: EMPTY
61711: LIST
61712: LIST
61713: PUSH
61714: EMPTY
61715: LIST
61716: LIST
61717: LIST
61718: PUSH
61719: EMPTY
61720: LIST
61721: LIST
61722: PPUSH
61723: CALL_OW 72
61727: ST_TO_ADDR
61728: GO 61812
61730: LD_INT 4
61732: DOUBLE
61733: EQUAL
61734: IFTRUE 61738
61736: GO 61811
61738: POP
// f := UnitFilter ( buildings , [ [ f_side , side ] , [ f_or , [ f_btype , b_lab ] , [ f_btype , b_lab_half ] , [ f_btype , b_lab_full ] ] ] ) ; end ;
61739: LD_ADDR_VAR 0 12
61743: PUSH
61744: LD_VAR 0 18
61748: PPUSH
61749: LD_INT 22
61751: PUSH
61752: LD_VAR 0 16
61756: PUSH
61757: EMPTY
61758: LIST
61759: LIST
61760: PUSH
61761: LD_INT 2
61763: PUSH
61764: LD_INT 30
61766: PUSH
61767: LD_INT 6
61769: PUSH
61770: EMPTY
61771: LIST
61772: LIST
61773: PUSH
61774: LD_INT 30
61776: PUSH
61777: LD_INT 7
61779: PUSH
61780: EMPTY
61781: LIST
61782: LIST
61783: PUSH
61784: LD_INT 30
61786: PUSH
61787: LD_INT 8
61789: PUSH
61790: EMPTY
61791: LIST
61792: LIST
61793: PUSH
61794: EMPTY
61795: LIST
61796: LIST
61797: LIST
61798: LIST
61799: PUSH
61800: EMPTY
61801: LIST
61802: LIST
61803: PPUSH
61804: CALL_OW 72
61808: ST_TO_ADDR
61809: GO 61812
61811: POP
// if i = 1 then
61812: LD_VAR 0 8
61816: PUSH
61817: LD_INT 1
61819: EQUAL
61820: IFFALSE 61931
// begin tmp := [ ] ;
61822: LD_ADDR_VAR 0 19
61826: PUSH
61827: EMPTY
61828: ST_TO_ADDR
// for j in f do
61829: LD_ADDR_VAR 0 9
61833: PUSH
61834: LD_VAR 0 12
61838: PUSH
61839: FOR_IN
61840: IFFALSE 61913
// if GetBType ( j ) = b_bunker then
61842: LD_VAR 0 9
61846: PPUSH
61847: CALL_OW 266
61851: PUSH
61852: LD_INT 32
61854: EQUAL
61855: IFFALSE 61882
// tmp := Insert ( tmp , 1 , j ) else
61857: LD_ADDR_VAR 0 19
61861: PUSH
61862: LD_VAR 0 19
61866: PPUSH
61867: LD_INT 1
61869: PPUSH
61870: LD_VAR 0 9
61874: PPUSH
61875: CALL_OW 2
61879: ST_TO_ADDR
61880: GO 61911
// tmp := Insert ( tmp , tmp + 1 , j ) ;
61882: LD_ADDR_VAR 0 19
61886: PUSH
61887: LD_VAR 0 19
61891: PPUSH
61892: LD_VAR 0 19
61896: PUSH
61897: LD_INT 1
61899: PLUS
61900: PPUSH
61901: LD_VAR 0 9
61905: PPUSH
61906: CALL_OW 2
61910: ST_TO_ADDR
61911: GO 61839
61913: POP
61914: POP
// if tmp then
61915: LD_VAR 0 19
61919: IFFALSE 61931
// f := tmp ;
61921: LD_ADDR_VAR 0 12
61925: PUSH
61926: LD_VAR 0 19
61930: ST_TO_ADDR
// end ; x := personel [ i ] ;
61931: LD_ADDR_VAR 0 13
61935: PUSH
61936: LD_VAR 0 6
61940: PUSH
61941: LD_VAR 0 8
61945: ARRAY
61946: ST_TO_ADDR
// if x = - 1 then
61947: LD_VAR 0 13
61951: PUSH
61952: LD_INT 1
61954: NEG
61955: EQUAL
61956: IFFALSE 62165
// begin for j in f do
61958: LD_ADDR_VAR 0 9
61962: PUSH
61963: LD_VAR 0 12
61967: PUSH
61968: FOR_IN
61969: IFFALSE 62161
// repeat InitHc ;
61971: CALL_OW 19
// if GetBType ( j ) = b_barracks then
61975: LD_VAR 0 9
61979: PPUSH
61980: CALL_OW 266
61984: PUSH
61985: LD_INT 5
61987: EQUAL
61988: IFFALSE 62058
// begin if UnitsInside ( j ) < 3 then
61990: LD_VAR 0 9
61994: PPUSH
61995: CALL_OW 313
61999: PUSH
62000: LD_INT 3
62002: LESS
62003: IFFALSE 62039
// PrepareHuman ( false , [ class_sniper , class_mortar , class_bazooker ] [ nation ] , skill ) else
62005: LD_INT 0
62007: PPUSH
62008: LD_INT 5
62010: PUSH
62011: LD_INT 8
62013: PUSH
62014: LD_INT 9
62016: PUSH
62017: EMPTY
62018: LIST
62019: LIST
62020: LIST
62021: PUSH
62022: LD_VAR 0 17
62026: ARRAY
62027: PPUSH
62028: LD_VAR 0 4
62032: PPUSH
62033: CALL_OW 380
62037: GO 62056
// PrepareHuman ( false , i , skill ) ;
62039: LD_INT 0
62041: PPUSH
62042: LD_VAR 0 8
62046: PPUSH
62047: LD_VAR 0 4
62051: PPUSH
62052: CALL_OW 380
// end else
62056: GO 62075
// PrepareHuman ( false , i , skill ) ;
62058: LD_INT 0
62060: PPUSH
62061: LD_VAR 0 8
62065: PPUSH
62066: LD_VAR 0 4
62070: PPUSH
62071: CALL_OW 380
// un := CreateHuman ;
62075: LD_ADDR_VAR 0 14
62079: PUSH
62080: CALL_OW 44
62084: ST_TO_ADDR
// result := Insert ( result , 1 , un ) ;
62085: LD_ADDR_VAR 0 7
62089: PUSH
62090: LD_VAR 0 7
62094: PPUSH
62095: LD_INT 1
62097: PPUSH
62098: LD_VAR 0 14
62102: PPUSH
62103: CALL_OW 2
62107: ST_TO_ADDR
// PlaceHumanInUnit ( un , j ) ;
62108: LD_VAR 0 14
62112: PPUSH
62113: LD_VAR 0 9
62117: PPUSH
62118: CALL_OW 52
// until UnitsInside ( j ) = 6 or GetBType ( j ) in [ b_bunker , b_breastwork ] ;
62122: LD_VAR 0 9
62126: PPUSH
62127: CALL_OW 313
62131: PUSH
62132: LD_INT 6
62134: EQUAL
62135: PUSH
62136: LD_VAR 0 9
62140: PPUSH
62141: CALL_OW 266
62145: PUSH
62146: LD_INT 32
62148: PUSH
62149: LD_INT 31
62151: PUSH
62152: EMPTY
62153: LIST
62154: LIST
62155: IN
62156: OR
62157: IFFALSE 61971
62159: GO 61968
62161: POP
62162: POP
// end else
62163: GO 62545
// for j = 1 to x do
62165: LD_ADDR_VAR 0 9
62169: PUSH
62170: DOUBLE
62171: LD_INT 1
62173: DEC
62174: ST_TO_ADDR
62175: LD_VAR 0 13
62179: PUSH
62180: FOR_TO
62181: IFFALSE 62543
// begin InitHc ;
62183: CALL_OW 19
// if not f then
62187: LD_VAR 0 12
62191: NOT
62192: IFFALSE 62281
// begin PrepareHuman ( false , i , skill ) ;
62194: LD_INT 0
62196: PPUSH
62197: LD_VAR 0 8
62201: PPUSH
62202: LD_VAR 0 4
62206: PPUSH
62207: CALL_OW 380
// un := CreateHuman ;
62211: LD_ADDR_VAR 0 14
62215: PUSH
62216: CALL_OW 44
62220: ST_TO_ADDR
// result := Insert ( result , 1 , un ) ;
62221: LD_ADDR_VAR 0 7
62225: PUSH
62226: LD_VAR 0 7
62230: PPUSH
62231: LD_INT 1
62233: PPUSH
62234: LD_VAR 0 14
62238: PPUSH
62239: CALL_OW 2
62243: ST_TO_ADDR
// PlaceUnitXYR ( un , GetX ( base_dep ) , GetY ( base_dep ) , 10 , false ) ;
62244: LD_VAR 0 14
62248: PPUSH
62249: LD_VAR 0 1
62253: PPUSH
62254: CALL_OW 250
62258: PPUSH
62259: LD_VAR 0 1
62263: PPUSH
62264: CALL_OW 251
62268: PPUSH
62269: LD_INT 10
62271: PPUSH
62272: LD_INT 0
62274: PPUSH
62275: CALL_OW 50
// continue ;
62279: GO 62180
// end ; if ( UnitsInside ( f [ 1 ] ) and GetBType ( f [ 1 ] ) in [ b_bunker , b_breastwork ] ) or ( UnitsInside ( f [ 1 ] ) = 6 ) then
62281: LD_VAR 0 12
62285: PUSH
62286: LD_INT 1
62288: ARRAY
62289: PPUSH
62290: CALL_OW 313
62294: PUSH
62295: LD_VAR 0 12
62299: PUSH
62300: LD_INT 1
62302: ARRAY
62303: PPUSH
62304: CALL_OW 266
62308: PUSH
62309: LD_INT 32
62311: PUSH
62312: LD_INT 31
62314: PUSH
62315: EMPTY
62316: LIST
62317: LIST
62318: IN
62319: AND
62320: PUSH
62321: LD_VAR 0 12
62325: PUSH
62326: LD_INT 1
62328: ARRAY
62329: PPUSH
62330: CALL_OW 313
62334: PUSH
62335: LD_INT 6
62337: EQUAL
62338: OR
62339: IFFALSE 62359
// f := Delete ( f , 1 ) ;
62341: LD_ADDR_VAR 0 12
62345: PUSH
62346: LD_VAR 0 12
62350: PPUSH
62351: LD_INT 1
62353: PPUSH
62354: CALL_OW 3
62358: ST_TO_ADDR
// if not f then
62359: LD_VAR 0 12
62363: NOT
62364: IFFALSE 62382
// begin x := x + 2 ;
62366: LD_ADDR_VAR 0 13
62370: PUSH
62371: LD_VAR 0 13
62375: PUSH
62376: LD_INT 2
62378: PLUS
62379: ST_TO_ADDR
// continue ;
62380: GO 62180
// end ; if GetBType ( f [ 1 ] ) = b_barracks then
62382: LD_VAR 0 12
62386: PUSH
62387: LD_INT 1
62389: ARRAY
62390: PPUSH
62391: CALL_OW 266
62395: PUSH
62396: LD_INT 5
62398: EQUAL
62399: IFFALSE 62473
// begin if UnitsInside ( f [ 1 ] ) < 3 then
62401: LD_VAR 0 12
62405: PUSH
62406: LD_INT 1
62408: ARRAY
62409: PPUSH
62410: CALL_OW 313
62414: PUSH
62415: LD_INT 3
62417: LESS
62418: IFFALSE 62454
// PrepareHuman ( false , [ class_sniper , class_mortar , class_bazooker ] [ nation ] , skill ) else
62420: LD_INT 0
62422: PPUSH
62423: LD_INT 5
62425: PUSH
62426: LD_INT 8
62428: PUSH
62429: LD_INT 9
62431: PUSH
62432: EMPTY
62433: LIST
62434: LIST
62435: LIST
62436: PUSH
62437: LD_VAR 0 17
62441: ARRAY
62442: PPUSH
62443: LD_VAR 0 4
62447: PPUSH
62448: CALL_OW 380
62452: GO 62471
// PrepareHuman ( false , i , skill ) ;
62454: LD_INT 0
62456: PPUSH
62457: LD_VAR 0 8
62461: PPUSH
62462: LD_VAR 0 4
62466: PPUSH
62467: CALL_OW 380
// end else
62471: GO 62490
// PrepareHuman ( false , i , skill ) ;
62473: LD_INT 0
62475: PPUSH
62476: LD_VAR 0 8
62480: PPUSH
62481: LD_VAR 0 4
62485: PPUSH
62486: CALL_OW 380
// un := CreateHuman ;
62490: LD_ADDR_VAR 0 14
62494: PUSH
62495: CALL_OW 44
62499: ST_TO_ADDR
// result := Insert ( result , 1 , un ) ;
62500: LD_ADDR_VAR 0 7
62504: PUSH
62505: LD_VAR 0 7
62509: PPUSH
62510: LD_INT 1
62512: PPUSH
62513: LD_VAR 0 14
62517: PPUSH
62518: CALL_OW 2
62522: ST_TO_ADDR
// PlaceHumanInUnit ( un , f [ 1 ] ) ;
62523: LD_VAR 0 14
62527: PPUSH
62528: LD_VAR 0 12
62532: PUSH
62533: LD_INT 1
62535: ARRAY
62536: PPUSH
62537: CALL_OW 52
// end ;
62541: GO 62180
62543: POP
62544: POP
// end ;
62545: GO 61482
62547: POP
62548: POP
// result := result ^ buildings ;
62549: LD_ADDR_VAR 0 7
62553: PUSH
62554: LD_VAR 0 7
62558: PUSH
62559: LD_VAR 0 18
62563: ADD
62564: ST_TO_ADDR
// end else
62565: GO 62708
// begin for i = 1 to personel do
62567: LD_ADDR_VAR 0 8
62571: PUSH
62572: DOUBLE
62573: LD_INT 1
62575: DEC
62576: ST_TO_ADDR
62577: LD_VAR 0 6
62581: PUSH
62582: FOR_TO
62583: IFFALSE 62706
// begin if i > 4 then
62585: LD_VAR 0 8
62589: PUSH
62590: LD_INT 4
62592: GREATER
62593: IFFALSE 62597
// break ;
62595: GO 62706
// x := personel [ i ] ;
62597: LD_ADDR_VAR 0 13
62601: PUSH
62602: LD_VAR 0 6
62606: PUSH
62607: LD_VAR 0 8
62611: ARRAY
62612: ST_TO_ADDR
// if x = - 1 then
62613: LD_VAR 0 13
62617: PUSH
62618: LD_INT 1
62620: NEG
62621: EQUAL
62622: IFFALSE 62626
// continue ;
62624: GO 62582
// PrepareHuman ( false , i , skill ) ;
62626: LD_INT 0
62628: PPUSH
62629: LD_VAR 0 8
62633: PPUSH
62634: LD_VAR 0 4
62638: PPUSH
62639: CALL_OW 380
// un := CreateHuman ;
62643: LD_ADDR_VAR 0 14
62647: PUSH
62648: CALL_OW 44
62652: ST_TO_ADDR
// PlaceUnitXYR ( un , GetX ( base_dep ) , GetY ( base_dep ) , 10 , false ) ;
62653: LD_VAR 0 14
62657: PPUSH
62658: LD_VAR 0 1
62662: PPUSH
62663: CALL_OW 250
62667: PPUSH
62668: LD_VAR 0 1
62672: PPUSH
62673: CALL_OW 251
62677: PPUSH
62678: LD_INT 10
62680: PPUSH
62681: LD_INT 0
62683: PPUSH
62684: CALL_OW 50
// result := result ^ un ;
62688: LD_ADDR_VAR 0 7
62692: PUSH
62693: LD_VAR 0 7
62697: PUSH
62698: LD_VAR 0 14
62702: ADD
62703: ST_TO_ADDR
// end ;
62704: GO 62582
62706: POP
62707: POP
// end ; end ;
62708: LD_VAR 0 7
62712: RET
// export function GetTurretWeapon ( tower , area ) ; var hex , list , factories , base , i , j , x , y , nat , h , tmp , height , side , fac_list , weapon ; begin
62713: LD_INT 0
62715: PPUSH
62716: PPUSH
62717: PPUSH
62718: PPUSH
62719: PPUSH
62720: PPUSH
62721: PPUSH
62722: PPUSH
62723: PPUSH
62724: PPUSH
62725: PPUSH
62726: PPUSH
62727: PPUSH
62728: PPUSH
62729: PPUSH
62730: PPUSH
// result := false ;
62731: LD_ADDR_VAR 0 3
62735: PUSH
62736: LD_INT 0
62738: ST_TO_ADDR
// if not tower or not GetBType ( tower ) in [ b_bunker , b_turret ] then
62739: LD_VAR 0 1
62743: NOT
62744: PUSH
62745: LD_VAR 0 1
62749: PPUSH
62750: CALL_OW 266
62754: PUSH
62755: LD_INT 32
62757: PUSH
62758: LD_INT 33
62760: PUSH
62761: EMPTY
62762: LIST
62763: LIST
62764: IN
62765: NOT
62766: OR
62767: IFFALSE 62771
// exit ;
62769: GO 63907
// nat := GetNation ( tower ) ;
62771: LD_ADDR_VAR 0 12
62775: PUSH
62776: LD_VAR 0 1
62780: PPUSH
62781: CALL_OW 248
62785: ST_TO_ADDR
// side := GetSide ( tower ) ;
62786: LD_ADDR_VAR 0 16
62790: PUSH
62791: LD_VAR 0 1
62795: PPUSH
62796: CALL_OW 255
62800: ST_TO_ADDR
// x := GetX ( tower ) ;
62801: LD_ADDR_VAR 0 10
62805: PUSH
62806: LD_VAR 0 1
62810: PPUSH
62811: CALL_OW 250
62815: ST_TO_ADDR
// y := GetY ( tower ) ;
62816: LD_ADDR_VAR 0 11
62820: PUSH
62821: LD_VAR 0 1
62825: PPUSH
62826: CALL_OW 251
62830: ST_TO_ADDR
// if not x or not y then
62831: LD_VAR 0 10
62835: NOT
62836: PUSH
62837: LD_VAR 0 11
62841: NOT
62842: OR
62843: IFFALSE 62847
// exit ;
62845: GO 63907
// weapon := 0 ;
62847: LD_ADDR_VAR 0 18
62851: PUSH
62852: LD_INT 0
62854: ST_TO_ADDR
// fac_list := [ ] ;
62855: LD_ADDR_VAR 0 17
62859: PUSH
62860: EMPTY
62861: ST_TO_ADDR
// factories := UnitFilter ( GetBaseBuildings ( GetBase ( tower ) , area ) , [ f_btype , b_factory ] ) ;
62862: LD_ADDR_VAR 0 6
62866: PUSH
62867: LD_VAR 0 1
62871: PPUSH
62872: CALL_OW 274
62876: PPUSH
62877: LD_VAR 0 2
62881: PPUSH
62882: CALL 60485 0 2
62886: PPUSH
62887: LD_INT 30
62889: PUSH
62890: LD_INT 3
62892: PUSH
62893: EMPTY
62894: LIST
62895: LIST
62896: PPUSH
62897: CALL_OW 72
62901: ST_TO_ADDR
// if not factories then
62902: LD_VAR 0 6
62906: NOT
62907: IFFALSE 62911
// exit ;
62909: GO 63907
// for i in factories do
62911: LD_ADDR_VAR 0 8
62915: PUSH
62916: LD_VAR 0 6
62920: PUSH
62921: FOR_IN
62922: IFFALSE 62947
// fac_list := fac_list union AvailableWeaponList ( i ) ;
62924: LD_ADDR_VAR 0 17
62928: PUSH
62929: LD_VAR 0 17
62933: PUSH
62934: LD_VAR 0 8
62938: PPUSH
62939: CALL_OW 478
62943: UNION
62944: ST_TO_ADDR
62945: GO 62921
62947: POP
62948: POP
// if not fac_list then
62949: LD_VAR 0 17
62953: NOT
62954: IFFALSE 62958
// exit ;
62956: GO 63907
// list := [ [ us_gatling_gun , us_double_gun , us_laser , us_double_laser , us_heavy_gun , us_rocket_launcher , us_radar ] , [ ar_gun , ar_rocket_launcher , ar_flame_thrower , ar_radar ] , [ ru_gatling_gun , ru_gun , ru_heavy_gun , ru_rocket_launcher , ru_rocket , ru_time_lapser ] ] [ nat ] ;
62958: LD_ADDR_VAR 0 5
62962: PUSH
62963: LD_INT 4
62965: PUSH
62966: LD_INT 5
62968: PUSH
62969: LD_INT 9
62971: PUSH
62972: LD_INT 10
62974: PUSH
62975: LD_INT 6
62977: PUSH
62978: LD_INT 7
62980: PUSH
62981: LD_INT 11
62983: PUSH
62984: EMPTY
62985: LIST
62986: LIST
62987: LIST
62988: LIST
62989: LIST
62990: LIST
62991: LIST
62992: PUSH
62993: LD_INT 27
62995: PUSH
62996: LD_INT 28
62998: PUSH
62999: LD_INT 26
63001: PUSH
63002: LD_INT 30
63004: PUSH
63005: EMPTY
63006: LIST
63007: LIST
63008: LIST
63009: LIST
63010: PUSH
63011: LD_INT 43
63013: PUSH
63014: LD_INT 44
63016: PUSH
63017: LD_INT 46
63019: PUSH
63020: LD_INT 45
63022: PUSH
63023: LD_INT 47
63025: PUSH
63026: LD_INT 49
63028: PUSH
63029: EMPTY
63030: LIST
63031: LIST
63032: LIST
63033: LIST
63034: LIST
63035: LIST
63036: PUSH
63037: EMPTY
63038: LIST
63039: LIST
63040: LIST
63041: PUSH
63042: LD_VAR 0 12
63046: ARRAY
63047: ST_TO_ADDR
// for i in list do
63048: LD_ADDR_VAR 0 8
63052: PUSH
63053: LD_VAR 0 5
63057: PUSH
63058: FOR_IN
63059: IFFALSE 63092
// if not i in fac_list then
63061: LD_VAR 0 8
63065: PUSH
63066: LD_VAR 0 17
63070: IN
63071: NOT
63072: IFFALSE 63090
// list := list diff i ;
63074: LD_ADDR_VAR 0 5
63078: PUSH
63079: LD_VAR 0 5
63083: PUSH
63084: LD_VAR 0 8
63088: DIFF
63089: ST_TO_ADDR
63090: GO 63058
63092: POP
63093: POP
// if not list then
63094: LD_VAR 0 5
63098: NOT
63099: IFFALSE 63103
// exit ;
63101: GO 63907
// if nat = nation_russian and ru_time_lapser in list and GetTech ( tech_lapser , side ) = state_researched then
63103: LD_VAR 0 12
63107: PUSH
63108: LD_INT 3
63110: EQUAL
63111: PUSH
63112: LD_INT 49
63114: PUSH
63115: LD_VAR 0 5
63119: IN
63120: AND
63121: PUSH
63122: LD_INT 31
63124: PPUSH
63125: LD_VAR 0 16
63129: PPUSH
63130: CALL_OW 321
63134: PUSH
63135: LD_INT 2
63137: EQUAL
63138: AND
63139: IFFALSE 63199
// begin if not FilterAllUnits ( [ [ f_side , side ] , [ f_bweapon , ru_time_lapser ] , [ f_dist , tower , 10 ] ] ) then
63141: LD_INT 22
63143: PUSH
63144: LD_VAR 0 16
63148: PUSH
63149: EMPTY
63150: LIST
63151: LIST
63152: PUSH
63153: LD_INT 35
63155: PUSH
63156: LD_INT 49
63158: PUSH
63159: EMPTY
63160: LIST
63161: LIST
63162: PUSH
63163: LD_INT 91
63165: PUSH
63166: LD_VAR 0 1
63170: PUSH
63171: LD_INT 10
63173: PUSH
63174: EMPTY
63175: LIST
63176: LIST
63177: LIST
63178: PUSH
63179: EMPTY
63180: LIST
63181: LIST
63182: LIST
63183: PPUSH
63184: CALL_OW 69
63188: NOT
63189: IFFALSE 63199
// weapon := ru_time_lapser ;
63191: LD_ADDR_VAR 0 18
63195: PUSH
63196: LD_INT 49
63198: ST_TO_ADDR
// end ; if nat in [ 1 , 2 ] and ( us_radar in list or ar_radar in list ) and GetTech ( tech_radar , side ) = state_researched then
63199: LD_VAR 0 12
63203: PUSH
63204: LD_INT 1
63206: PUSH
63207: LD_INT 2
63209: PUSH
63210: EMPTY
63211: LIST
63212: LIST
63213: IN
63214: PUSH
63215: LD_INT 11
63217: PUSH
63218: LD_VAR 0 5
63222: IN
63223: PUSH
63224: LD_INT 30
63226: PUSH
63227: LD_VAR 0 5
63231: IN
63232: OR
63233: AND
63234: PUSH
63235: LD_INT 6
63237: PPUSH
63238: LD_VAR 0 16
63242: PPUSH
63243: CALL_OW 321
63247: PUSH
63248: LD_INT 2
63250: EQUAL
63251: AND
63252: IFFALSE 63417
// begin if not FilterAllUnits ( [ [ f_side , side ] , [ f_or , [ f_bweapon , us_radar ] , [ f_bweapon , ar_radar ] ] , [ f_dist , tower , 18 ] ] ) and FilterAllUnits ( [ [ [ f_side , side ] , [ f_or , [ f_btype , b_bunker ] , [ f_btype , b_turret ] ] , [ f_dist , tower , 12 ] ] ] ) > 2 then
63254: LD_INT 22
63256: PUSH
63257: LD_VAR 0 16
63261: PUSH
63262: EMPTY
63263: LIST
63264: LIST
63265: PUSH
63266: LD_INT 2
63268: PUSH
63269: LD_INT 35
63271: PUSH
63272: LD_INT 11
63274: PUSH
63275: EMPTY
63276: LIST
63277: LIST
63278: PUSH
63279: LD_INT 35
63281: PUSH
63282: LD_INT 30
63284: PUSH
63285: EMPTY
63286: LIST
63287: LIST
63288: PUSH
63289: EMPTY
63290: LIST
63291: LIST
63292: LIST
63293: PUSH
63294: LD_INT 91
63296: PUSH
63297: LD_VAR 0 1
63301: PUSH
63302: LD_INT 18
63304: PUSH
63305: EMPTY
63306: LIST
63307: LIST
63308: LIST
63309: PUSH
63310: EMPTY
63311: LIST
63312: LIST
63313: LIST
63314: PPUSH
63315: CALL_OW 69
63319: NOT
63320: PUSH
63321: LD_INT 22
63323: PUSH
63324: LD_VAR 0 16
63328: PUSH
63329: EMPTY
63330: LIST
63331: LIST
63332: PUSH
63333: LD_INT 2
63335: PUSH
63336: LD_INT 30
63338: PUSH
63339: LD_INT 32
63341: PUSH
63342: EMPTY
63343: LIST
63344: LIST
63345: PUSH
63346: LD_INT 30
63348: PUSH
63349: LD_INT 33
63351: PUSH
63352: EMPTY
63353: LIST
63354: LIST
63355: PUSH
63356: EMPTY
63357: LIST
63358: LIST
63359: LIST
63360: PUSH
63361: LD_INT 91
63363: PUSH
63364: LD_VAR 0 1
63368: PUSH
63369: LD_INT 12
63371: PUSH
63372: EMPTY
63373: LIST
63374: LIST
63375: LIST
63376: PUSH
63377: EMPTY
63378: LIST
63379: LIST
63380: LIST
63381: PUSH
63382: EMPTY
63383: LIST
63384: PPUSH
63385: CALL_OW 69
63389: PUSH
63390: LD_INT 2
63392: GREATER
63393: AND
63394: IFFALSE 63417
// weapon := [ us_radar , ar_radar ] [ nat ] ;
63396: LD_ADDR_VAR 0 18
63400: PUSH
63401: LD_INT 11
63403: PUSH
63404: LD_INT 30
63406: PUSH
63407: EMPTY
63408: LIST
63409: LIST
63410: PUSH
63411: LD_VAR 0 12
63415: ARRAY
63416: ST_TO_ADDR
// end ; if not weapon and GetTech ( tech_rocket , side ) = state_researched and ( us_rocket_launcher in list or ar_rocket_launcher in list or ru_rocket_launcher in list ) then
63417: LD_VAR 0 18
63421: NOT
63422: PUSH
63423: LD_INT 40
63425: PPUSH
63426: LD_VAR 0 16
63430: PPUSH
63431: CALL_OW 321
63435: PUSH
63436: LD_INT 2
63438: EQUAL
63439: AND
63440: PUSH
63441: LD_INT 7
63443: PUSH
63444: LD_VAR 0 5
63448: IN
63449: PUSH
63450: LD_INT 28
63452: PUSH
63453: LD_VAR 0 5
63457: IN
63458: OR
63459: PUSH
63460: LD_INT 45
63462: PUSH
63463: LD_VAR 0 5
63467: IN
63468: OR
63469: AND
63470: IFFALSE 63724
// begin hex := GetHexInfo ( x , y ) ;
63472: LD_ADDR_VAR 0 4
63476: PUSH
63477: LD_VAR 0 10
63481: PPUSH
63482: LD_VAR 0 11
63486: PPUSH
63487: CALL_OW 546
63491: ST_TO_ADDR
// if hex [ 1 ] then
63492: LD_VAR 0 4
63496: PUSH
63497: LD_INT 1
63499: ARRAY
63500: IFFALSE 63504
// exit ;
63502: GO 63907
// height := hex [ 2 ] ;
63504: LD_ADDR_VAR 0 15
63508: PUSH
63509: LD_VAR 0 4
63513: PUSH
63514: LD_INT 2
63516: ARRAY
63517: ST_TO_ADDR
// tmp := [ 0 , 2 , 3 , 5 ] ;
63518: LD_ADDR_VAR 0 14
63522: PUSH
63523: LD_INT 0
63525: PUSH
63526: LD_INT 2
63528: PUSH
63529: LD_INT 3
63531: PUSH
63532: LD_INT 5
63534: PUSH
63535: EMPTY
63536: LIST
63537: LIST
63538: LIST
63539: LIST
63540: ST_TO_ADDR
// for i in tmp do
63541: LD_ADDR_VAR 0 8
63545: PUSH
63546: LD_VAR 0 14
63550: PUSH
63551: FOR_IN
63552: IFFALSE 63722
// begin j := [ ShiftX ( x , i , 5 ) , ShiftY ( y , i , 5 ) ] ;
63554: LD_ADDR_VAR 0 9
63558: PUSH
63559: LD_VAR 0 10
63563: PPUSH
63564: LD_VAR 0 8
63568: PPUSH
63569: LD_INT 5
63571: PPUSH
63572: CALL_OW 272
63576: PUSH
63577: LD_VAR 0 11
63581: PPUSH
63582: LD_VAR 0 8
63586: PPUSH
63587: LD_INT 5
63589: PPUSH
63590: CALL_OW 273
63594: PUSH
63595: EMPTY
63596: LIST
63597: LIST
63598: ST_TO_ADDR
// if ValidHex ( j [ 1 ] , j [ 2 ] ) then
63599: LD_VAR 0 9
63603: PUSH
63604: LD_INT 1
63606: ARRAY
63607: PPUSH
63608: LD_VAR 0 9
63612: PUSH
63613: LD_INT 2
63615: ARRAY
63616: PPUSH
63617: CALL_OW 488
63621: IFFALSE 63720
// begin hex := GetHexInfo ( j [ 1 ] , j [ 2 ] ) ;
63623: LD_ADDR_VAR 0 4
63627: PUSH
63628: LD_VAR 0 9
63632: PUSH
63633: LD_INT 1
63635: ARRAY
63636: PPUSH
63637: LD_VAR 0 9
63641: PUSH
63642: LD_INT 2
63644: ARRAY
63645: PPUSH
63646: CALL_OW 546
63650: ST_TO_ADDR
// if hex [ 1 ] then
63651: LD_VAR 0 4
63655: PUSH
63656: LD_INT 1
63658: ARRAY
63659: IFFALSE 63663
// continue ;
63661: GO 63551
// h := hex [ 2 ] ;
63663: LD_ADDR_VAR 0 13
63667: PUSH
63668: LD_VAR 0 4
63672: PUSH
63673: LD_INT 2
63675: ARRAY
63676: ST_TO_ADDR
// if h + 7 < height then
63677: LD_VAR 0 13
63681: PUSH
63682: LD_INT 7
63684: PLUS
63685: PUSH
63686: LD_VAR 0 15
63690: LESS
63691: IFFALSE 63720
// begin weapon := [ us_rocket_launcher , ar_rocket_launcher , ru_rocket_launcher ] [ nat ] ;
63693: LD_ADDR_VAR 0 18
63697: PUSH
63698: LD_INT 7
63700: PUSH
63701: LD_INT 28
63703: PUSH
63704: LD_INT 45
63706: PUSH
63707: EMPTY
63708: LIST
63709: LIST
63710: LIST
63711: PUSH
63712: LD_VAR 0 12
63716: ARRAY
63717: ST_TO_ADDR
// break ;
63718: GO 63722
// end ; end ; end ;
63720: GO 63551
63722: POP
63723: POP
// end ; if not weapon then
63724: LD_VAR 0 18
63728: NOT
63729: IFFALSE 63789
// begin list := list diff [ us_radar , ar_radar , ru_time_lapser ] ;
63731: LD_ADDR_VAR 0 5
63735: PUSH
63736: LD_VAR 0 5
63740: PUSH
63741: LD_INT 11
63743: PUSH
63744: LD_INT 30
63746: PUSH
63747: LD_INT 49
63749: PUSH
63750: EMPTY
63751: LIST
63752: LIST
63753: LIST
63754: DIFF
63755: ST_TO_ADDR
// if not list then
63756: LD_VAR 0 5
63760: NOT
63761: IFFALSE 63765
// exit ;
63763: GO 63907
// weapon := list [ rand ( 1 , list ) ] ;
63765: LD_ADDR_VAR 0 18
63769: PUSH
63770: LD_VAR 0 5
63774: PUSH
63775: LD_INT 1
63777: PPUSH
63778: LD_VAR 0 5
63782: PPUSH
63783: CALL_OW 12
63787: ARRAY
63788: ST_TO_ADDR
// end ; if weapon then
63789: LD_VAR 0 18
63793: IFFALSE 63907
// begin tmp := CostOfWeapon ( weapon ) ;
63795: LD_ADDR_VAR 0 14
63799: PUSH
63800: LD_VAR 0 18
63804: PPUSH
63805: CALL_OW 451
63809: ST_TO_ADDR
// j := GetBase ( tower ) ;
63810: LD_ADDR_VAR 0 9
63814: PUSH
63815: LD_VAR 0 1
63819: PPUSH
63820: CALL_OW 274
63824: ST_TO_ADDR
// if GetResourceType ( j , mat_cans ) >= tmp [ 1 ] and GetResourceType ( j , mat_oil ) >= tmp [ 2 ] and GetResourceType ( j , mat_siberit ) >= tmp [ 3 ] then
63825: LD_VAR 0 9
63829: PPUSH
63830: LD_INT 1
63832: PPUSH
63833: CALL_OW 275
63837: PUSH
63838: LD_VAR 0 14
63842: PUSH
63843: LD_INT 1
63845: ARRAY
63846: GREATEREQUAL
63847: PUSH
63848: LD_VAR 0 9
63852: PPUSH
63853: LD_INT 2
63855: PPUSH
63856: CALL_OW 275
63860: PUSH
63861: LD_VAR 0 14
63865: PUSH
63866: LD_INT 2
63868: ARRAY
63869: GREATEREQUAL
63870: AND
63871: PUSH
63872: LD_VAR 0 9
63876: PPUSH
63877: LD_INT 3
63879: PPUSH
63880: CALL_OW 275
63884: PUSH
63885: LD_VAR 0 14
63889: PUSH
63890: LD_INT 3
63892: ARRAY
63893: GREATEREQUAL
63894: AND
63895: IFFALSE 63907
// result := weapon ;
63897: LD_ADDR_VAR 0 3
63901: PUSH
63902: LD_VAR 0 18
63906: ST_TO_ADDR
// end ; end ;
63907: LD_VAR 0 3
63911: RET
// export function CompareArray ( array1 , array2 ) ; var i ; begin
63912: LD_INT 0
63914: PPUSH
63915: PPUSH
// result := true ;
63916: LD_ADDR_VAR 0 3
63920: PUSH
63921: LD_INT 1
63923: ST_TO_ADDR
// if array1 = array2 then
63924: LD_VAR 0 1
63928: PUSH
63929: LD_VAR 0 2
63933: EQUAL
63934: IFFALSE 63994
// begin for i = 1 to array1 do
63936: LD_ADDR_VAR 0 4
63940: PUSH
63941: DOUBLE
63942: LD_INT 1
63944: DEC
63945: ST_TO_ADDR
63946: LD_VAR 0 1
63950: PUSH
63951: FOR_TO
63952: IFFALSE 63990
// if array1 [ i ] <> array2 [ i ] then
63954: LD_VAR 0 1
63958: PUSH
63959: LD_VAR 0 4
63963: ARRAY
63964: PUSH
63965: LD_VAR 0 2
63969: PUSH
63970: LD_VAR 0 4
63974: ARRAY
63975: NONEQUAL
63976: IFFALSE 63988
// begin result := false ;
63978: LD_ADDR_VAR 0 3
63982: PUSH
63983: LD_INT 0
63985: ST_TO_ADDR
// break ;
63986: GO 63990
// end ;
63988: GO 63951
63990: POP
63991: POP
// end else
63992: GO 64002
// result := false ;
63994: LD_ADDR_VAR 0 3
63998: PUSH
63999: LD_INT 0
64001: ST_TO_ADDR
// end ;
64002: LD_VAR 0 3
64006: RET
// export function VehicleCost ( fac , list ) ; var cost , pom ; begin
64007: LD_INT 0
64009: PPUSH
64010: PPUSH
64011: PPUSH
// pom := GetBase ( fac ) ;
64012: LD_ADDR_VAR 0 5
64016: PUSH
64017: LD_VAR 0 1
64021: PPUSH
64022: CALL_OW 274
64026: ST_TO_ADDR
// cost := CostOfVehicle ( list [ 1 ] , list [ 2 ] , list [ 3 ] , list [ 4 ] ) ;
64027: LD_ADDR_VAR 0 4
64031: PUSH
64032: LD_VAR 0 2
64036: PUSH
64037: LD_INT 1
64039: ARRAY
64040: PPUSH
64041: LD_VAR 0 2
64045: PUSH
64046: LD_INT 2
64048: ARRAY
64049: PPUSH
64050: LD_VAR 0 2
64054: PUSH
64055: LD_INT 3
64057: ARRAY
64058: PPUSH
64059: LD_VAR 0 2
64063: PUSH
64064: LD_INT 4
64066: ARRAY
64067: PPUSH
64068: CALL_OW 449
64072: ST_TO_ADDR
// result := GetResourceType ( pom , mat_cans ) >= cost [ 1 ] and GetResourceType ( pom , mat_oil ) >= cost [ 2 ] and GetResourceType ( pom , mat_siberit ) >= cost [ 3 ] ;
64073: LD_ADDR_VAR 0 3
64077: PUSH
64078: LD_VAR 0 5
64082: PPUSH
64083: LD_INT 1
64085: PPUSH
64086: CALL_OW 275
64090: PUSH
64091: LD_VAR 0 4
64095: PUSH
64096: LD_INT 1
64098: ARRAY
64099: GREATEREQUAL
64100: PUSH
64101: LD_VAR 0 5
64105: PPUSH
64106: LD_INT 2
64108: PPUSH
64109: CALL_OW 275
64113: PUSH
64114: LD_VAR 0 4
64118: PUSH
64119: LD_INT 2
64121: ARRAY
64122: GREATEREQUAL
64123: AND
64124: PUSH
64125: LD_VAR 0 5
64129: PPUSH
64130: LD_INT 3
64132: PPUSH
64133: CALL_OW 275
64137: PUSH
64138: LD_VAR 0 4
64142: PUSH
64143: LD_INT 3
64145: ARRAY
64146: GREATEREQUAL
64147: AND
64148: ST_TO_ADDR
// end ;
64149: LD_VAR 0 3
64153: RET
// export function UpgradeCost ( building ) ; var pom , cost , btype ; begin
64154: LD_INT 0
64156: PPUSH
64157: PPUSH
64158: PPUSH
64159: PPUSH
// pom := GetBase ( building ) ;
64160: LD_ADDR_VAR 0 3
64164: PUSH
64165: LD_VAR 0 1
64169: PPUSH
64170: CALL_OW 274
64174: ST_TO_ADDR
// if not pom then
64175: LD_VAR 0 3
64179: NOT
64180: IFFALSE 64184
// exit ;
64182: GO 64354
// btype := GetBType ( building ) ;
64184: LD_ADDR_VAR 0 5
64188: PUSH
64189: LD_VAR 0 1
64193: PPUSH
64194: CALL_OW 266
64198: ST_TO_ADDR
// if btype = b_armoury then
64199: LD_VAR 0 5
64203: PUSH
64204: LD_INT 4
64206: EQUAL
64207: IFFALSE 64217
// btype := b_barracks ;
64209: LD_ADDR_VAR 0 5
64213: PUSH
64214: LD_INT 5
64216: ST_TO_ADDR
// if btype = b_depot then
64217: LD_VAR 0 5
64221: PUSH
64222: LD_INT 0
64224: EQUAL
64225: IFFALSE 64235
// btype := b_warehouse ;
64227: LD_ADDR_VAR 0 5
64231: PUSH
64232: LD_INT 1
64234: ST_TO_ADDR
// if btype = b_workshop then
64235: LD_VAR 0 5
64239: PUSH
64240: LD_INT 2
64242: EQUAL
64243: IFFALSE 64253
// btype := b_factory ;
64245: LD_ADDR_VAR 0 5
64249: PUSH
64250: LD_INT 3
64252: ST_TO_ADDR
// cost := CostOfBuilding ( btype , GetNation ( building ) ) ;
64253: LD_ADDR_VAR 0 4
64257: PUSH
64258: LD_VAR 0 5
64262: PPUSH
64263: LD_VAR 0 1
64267: PPUSH
64268: CALL_OW 248
64272: PPUSH
64273: CALL_OW 450
64277: ST_TO_ADDR
// result := GetResourceType ( pom , mat_cans ) >= cost [ 1 ] and GetResourceType ( pom , mat_oil ) >= cost [ 2 ] and GetResourceType ( pom , mat_siberit ) >= cost [ 3 ] ;
64278: LD_ADDR_VAR 0 2
64282: PUSH
64283: LD_VAR 0 3
64287: PPUSH
64288: LD_INT 1
64290: PPUSH
64291: CALL_OW 275
64295: PUSH
64296: LD_VAR 0 4
64300: PUSH
64301: LD_INT 1
64303: ARRAY
64304: GREATEREQUAL
64305: PUSH
64306: LD_VAR 0 3
64310: PPUSH
64311: LD_INT 2
64313: PPUSH
64314: CALL_OW 275
64318: PUSH
64319: LD_VAR 0 4
64323: PUSH
64324: LD_INT 2
64326: ARRAY
64327: GREATEREQUAL
64328: AND
64329: PUSH
64330: LD_VAR 0 3
64334: PPUSH
64335: LD_INT 3
64337: PPUSH
64338: CALL_OW 275
64342: PUSH
64343: LD_VAR 0 4
64347: PUSH
64348: LD_INT 3
64350: ARRAY
64351: GREATEREQUAL
64352: AND
64353: ST_TO_ADDR
// end ;
64354: LD_VAR 0 2
64358: RET
// export function UpgradeLabCost ( building , btype ) ; var pom , cost ; begin
64359: LD_INT 0
64361: PPUSH
64362: PPUSH
64363: PPUSH
// pom := GetBase ( building ) ;
64364: LD_ADDR_VAR 0 4
64368: PUSH
64369: LD_VAR 0 1
64373: PPUSH
64374: CALL_OW 274
64378: ST_TO_ADDR
// if not pom then
64379: LD_VAR 0 4
64383: NOT
64384: IFFALSE 64388
// exit ;
64386: GO 64489
// cost := CostOfBuilding ( btype , GetNation ( building ) ) ;
64388: LD_ADDR_VAR 0 5
64392: PUSH
64393: LD_VAR 0 2
64397: PPUSH
64398: LD_VAR 0 1
64402: PPUSH
64403: CALL_OW 248
64407: PPUSH
64408: CALL_OW 450
64412: ST_TO_ADDR
// result := GetResourceType ( pom , mat_cans ) >= cost [ 1 ] and GetResourceType ( pom , mat_oil ) >= cost [ 2 ] and GetResourceType ( pom , mat_siberit ) >= cost [ 3 ] ;
64413: LD_ADDR_VAR 0 3
64417: PUSH
64418: LD_VAR 0 4
64422: PPUSH
64423: LD_INT 1
64425: PPUSH
64426: CALL_OW 275
64430: PUSH
64431: LD_VAR 0 5
64435: PUSH
64436: LD_INT 1
64438: ARRAY
64439: GREATEREQUAL
64440: PUSH
64441: LD_VAR 0 4
64445: PPUSH
64446: LD_INT 2
64448: PPUSH
64449: CALL_OW 275
64453: PUSH
64454: LD_VAR 0 5
64458: PUSH
64459: LD_INT 2
64461: ARRAY
64462: GREATEREQUAL
64463: AND
64464: PUSH
64465: LD_VAR 0 4
64469: PPUSH
64470: LD_INT 3
64472: PPUSH
64473: CALL_OW 275
64477: PUSH
64478: LD_VAR 0 5
64482: PUSH
64483: LD_INT 3
64485: ARRAY
64486: GREATEREQUAL
64487: AND
64488: ST_TO_ADDR
// end ;
64489: LD_VAR 0 3
64493: RET
// export function TryClearPlaceForBuilding ( base , btype , x , y , d ) ; var i , j , _x , _y , tmp , hexes , r , xy , dep ; begin
64494: LD_INT 0
64496: PPUSH
64497: PPUSH
64498: PPUSH
64499: PPUSH
64500: PPUSH
64501: PPUSH
64502: PPUSH
64503: PPUSH
64504: PPUSH
64505: PPUSH
// result := false ;
64506: LD_ADDR_VAR 0 6
64510: PUSH
64511: LD_INT 0
64513: ST_TO_ADDR
// if not base or not btype or not x or not y then
64514: LD_VAR 0 1
64518: NOT
64519: PUSH
64520: LD_VAR 0 2
64524: NOT
64525: OR
64526: PUSH
64527: LD_VAR 0 3
64531: NOT
64532: OR
64533: PUSH
64534: LD_VAR 0 4
64538: NOT
64539: OR
64540: IFFALSE 64544
// exit ;
64542: GO 65153
// hexes := GetBuildingHexes ( btype , x , y , d , GetNation ( base [ 1 ] ) , 0 ) ;
64544: LD_ADDR_VAR 0 12
64548: PUSH
64549: LD_VAR 0 2
64553: PPUSH
64554: LD_VAR 0 3
64558: PPUSH
64559: LD_VAR 0 4
64563: PPUSH
64564: LD_VAR 0 5
64568: PPUSH
64569: LD_VAR 0 1
64573: PUSH
64574: LD_INT 1
64576: ARRAY
64577: PPUSH
64578: CALL_OW 248
64582: PPUSH
64583: LD_INT 0
64585: PPUSH
64586: CALL 65990 0 6
64590: ST_TO_ADDR
// if not hexes then
64591: LD_VAR 0 12
64595: NOT
64596: IFFALSE 64600
// exit ;
64598: GO 65153
// for i = 1 to hexes do
64600: LD_ADDR_VAR 0 7
64604: PUSH
64605: DOUBLE
64606: LD_INT 1
64608: DEC
64609: ST_TO_ADDR
64610: LD_VAR 0 12
64614: PUSH
64615: FOR_TO
64616: IFFALSE 65151
// begin tmp := HexInfo ( hexes [ i ] [ 1 ] , hexes [ i ] [ 2 ] ) ;
64618: LD_ADDR_VAR 0 11
64622: PUSH
64623: LD_VAR 0 12
64627: PUSH
64628: LD_VAR 0 7
64632: ARRAY
64633: PUSH
64634: LD_INT 1
64636: ARRAY
64637: PPUSH
64638: LD_VAR 0 12
64642: PUSH
64643: LD_VAR 0 7
64647: ARRAY
64648: PUSH
64649: LD_INT 2
64651: ARRAY
64652: PPUSH
64653: CALL_OW 428
64657: ST_TO_ADDR
// if IsEnvironment ( hexes [ i ] [ 1 ] , hexes [ i ] [ 2 ] ) or not ValidHex ( hexes [ i ] [ 1 ] , hexes [ i ] [ 2 ] ) or GetType ( tmp ) = unit_building then
64658: LD_VAR 0 12
64662: PUSH
64663: LD_VAR 0 7
64667: ARRAY
64668: PUSH
64669: LD_INT 1
64671: ARRAY
64672: PPUSH
64673: LD_VAR 0 12
64677: PUSH
64678: LD_VAR 0 7
64682: ARRAY
64683: PUSH
64684: LD_INT 2
64686: ARRAY
64687: PPUSH
64688: CALL_OW 351
64692: PUSH
64693: LD_VAR 0 12
64697: PUSH
64698: LD_VAR 0 7
64702: ARRAY
64703: PUSH
64704: LD_INT 1
64706: ARRAY
64707: PPUSH
64708: LD_VAR 0 12
64712: PUSH
64713: LD_VAR 0 7
64717: ARRAY
64718: PUSH
64719: LD_INT 2
64721: ARRAY
64722: PPUSH
64723: CALL_OW 488
64727: NOT
64728: OR
64729: PUSH
64730: LD_VAR 0 11
64734: PPUSH
64735: CALL_OW 247
64739: PUSH
64740: LD_INT 3
64742: EQUAL
64743: OR
64744: IFFALSE 64750
// exit ;
64746: POP
64747: POP
64748: GO 65153
// if not tmp or not tmp in base then
64750: LD_VAR 0 11
64754: NOT
64755: PUSH
64756: LD_VAR 0 11
64760: PUSH
64761: LD_VAR 0 1
64765: IN
64766: NOT
64767: OR
64768: IFFALSE 64772
// continue ;
64770: GO 64615
// result := true ;
64772: LD_ADDR_VAR 0 6
64776: PUSH
64777: LD_INT 1
64779: ST_TO_ADDR
// dep := UnitFilter ( base , [ [ f_side , GetSide ( tmp ) ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ] ) ;
64780: LD_ADDR_VAR 0 15
64784: PUSH
64785: LD_VAR 0 1
64789: PPUSH
64790: LD_INT 22
64792: PUSH
64793: LD_VAR 0 11
64797: PPUSH
64798: CALL_OW 255
64802: PUSH
64803: EMPTY
64804: LIST
64805: LIST
64806: PUSH
64807: LD_INT 2
64809: PUSH
64810: LD_INT 30
64812: PUSH
64813: LD_INT 0
64815: PUSH
64816: EMPTY
64817: LIST
64818: LIST
64819: PUSH
64820: LD_INT 30
64822: PUSH
64823: LD_INT 1
64825: PUSH
64826: EMPTY
64827: LIST
64828: LIST
64829: PUSH
64830: EMPTY
64831: LIST
64832: LIST
64833: LIST
64834: PUSH
64835: EMPTY
64836: LIST
64837: LIST
64838: PPUSH
64839: CALL_OW 72
64843: ST_TO_ADDR
// if dep then
64844: LD_VAR 0 15
64848: IFFALSE 64984
// begin xy := [ ShiftX ( GetX ( dep [ 1 ] ) , GetDir ( dep [ 1 ] ) , 5 ) , ShiftY ( GetY ( dep [ 1 ] ) , GetDir ( dep [ 1 ] ) , 5 ) ] ;
64850: LD_ADDR_VAR 0 14
64854: PUSH
64855: LD_VAR 0 15
64859: PUSH
64860: LD_INT 1
64862: ARRAY
64863: PPUSH
64864: CALL_OW 250
64868: PPUSH
64869: LD_VAR 0 15
64873: PUSH
64874: LD_INT 1
64876: ARRAY
64877: PPUSH
64878: CALL_OW 254
64882: PPUSH
64883: LD_INT 5
64885: PPUSH
64886: CALL_OW 272
64890: PUSH
64891: LD_VAR 0 15
64895: PUSH
64896: LD_INT 1
64898: ARRAY
64899: PPUSH
64900: CALL_OW 251
64904: PPUSH
64905: LD_VAR 0 15
64909: PUSH
64910: LD_INT 1
64912: ARRAY
64913: PPUSH
64914: CALL_OW 254
64918: PPUSH
64919: LD_INT 5
64921: PPUSH
64922: CALL_OW 273
64926: PUSH
64927: EMPTY
64928: LIST
64929: LIST
64930: ST_TO_ADDR
// if ValidHex ( xy [ 1 ] , xy [ 2 ] ) then
64931: LD_VAR 0 14
64935: PUSH
64936: LD_INT 1
64938: ARRAY
64939: PPUSH
64940: LD_VAR 0 14
64944: PUSH
64945: LD_INT 2
64947: ARRAY
64948: PPUSH
64949: CALL_OW 488
64953: IFFALSE 64984
// begin ComMoveXY ( tmp , xy [ 1 ] , xy [ 2 ] ) ;
64955: LD_VAR 0 11
64959: PPUSH
64960: LD_VAR 0 14
64964: PUSH
64965: LD_INT 1
64967: ARRAY
64968: PPUSH
64969: LD_VAR 0 14
64973: PUSH
64974: LD_INT 2
64976: ARRAY
64977: PPUSH
64978: CALL_OW 111
// continue ;
64982: GO 64615
// end ; end ; r := GetDir ( tmp ) ;
64984: LD_ADDR_VAR 0 13
64988: PUSH
64989: LD_VAR 0 11
64993: PPUSH
64994: CALL_OW 254
64998: ST_TO_ADDR
// if r = 5 then
64999: LD_VAR 0 13
65003: PUSH
65004: LD_INT 5
65006: EQUAL
65007: IFFALSE 65017
// r := 0 ;
65009: LD_ADDR_VAR 0 13
65013: PUSH
65014: LD_INT 0
65016: ST_TO_ADDR
// for j = r to 5 do
65017: LD_ADDR_VAR 0 8
65021: PUSH
65022: DOUBLE
65023: LD_VAR 0 13
65027: DEC
65028: ST_TO_ADDR
65029: LD_INT 5
65031: PUSH
65032: FOR_TO
65033: IFFALSE 65147
// begin _x := ShiftX ( GetX ( tmp ) , j , 2 ) ;
65035: LD_ADDR_VAR 0 9
65039: PUSH
65040: LD_VAR 0 11
65044: PPUSH
65045: CALL_OW 250
65049: PPUSH
65050: LD_VAR 0 8
65054: PPUSH
65055: LD_INT 2
65057: PPUSH
65058: CALL_OW 272
65062: ST_TO_ADDR
// _y := ShiftY ( GetY ( tmp ) , j , 2 ) ;
65063: LD_ADDR_VAR 0 10
65067: PUSH
65068: LD_VAR 0 11
65072: PPUSH
65073: CALL_OW 251
65077: PPUSH
65078: LD_VAR 0 8
65082: PPUSH
65083: LD_INT 2
65085: PPUSH
65086: CALL_OW 273
65090: ST_TO_ADDR
// if ValidHex ( _x , _y ) and not HexInfo ( _x , _y ) then
65091: LD_VAR 0 9
65095: PPUSH
65096: LD_VAR 0 10
65100: PPUSH
65101: CALL_OW 488
65105: PUSH
65106: LD_VAR 0 9
65110: PPUSH
65111: LD_VAR 0 10
65115: PPUSH
65116: CALL_OW 428
65120: NOT
65121: AND
65122: IFFALSE 65145
// begin ComMoveXY ( tmp , _x , _y ) ;
65124: LD_VAR 0 11
65128: PPUSH
65129: LD_VAR 0 9
65133: PPUSH
65134: LD_VAR 0 10
65138: PPUSH
65139: CALL_OW 111
// break ;
65143: GO 65147
// end ; end ;
65145: GO 65032
65147: POP
65148: POP
// end ;
65149: GO 64615
65151: POP
65152: POP
// end ;
65153: LD_VAR 0 6
65157: RET
// export function CanBeBuilt ( depot , btype , x , y , d ) ; var i , j , side , pom , cost , hexes , height , dist , hex ; begin
65158: LD_INT 0
65160: PPUSH
65161: PPUSH
65162: PPUSH
65163: PPUSH
65164: PPUSH
65165: PPUSH
65166: PPUSH
65167: PPUSH
65168: PPUSH
65169: PPUSH
// result := false ;
65170: LD_ADDR_VAR 0 6
65174: PUSH
65175: LD_INT 0
65177: ST_TO_ADDR
// if not depot or not GetBType ( depot ) in [ b_depot , b_warehouse ] or not btype or not d in [ 0 , 1 , 2 , 3 , 4 , 5 ] or not ValidHex ( x , y ) then
65178: LD_VAR 0 1
65182: NOT
65183: PUSH
65184: LD_VAR 0 1
65188: PPUSH
65189: CALL_OW 266
65193: PUSH
65194: LD_INT 0
65196: PUSH
65197: LD_INT 1
65199: PUSH
65200: EMPTY
65201: LIST
65202: LIST
65203: IN
65204: NOT
65205: OR
65206: PUSH
65207: LD_VAR 0 2
65211: NOT
65212: OR
65213: PUSH
65214: LD_VAR 0 5
65218: PUSH
65219: LD_INT 0
65221: PUSH
65222: LD_INT 1
65224: PUSH
65225: LD_INT 2
65227: PUSH
65228: LD_INT 3
65230: PUSH
65231: LD_INT 4
65233: PUSH
65234: LD_INT 5
65236: PUSH
65237: EMPTY
65238: LIST
65239: LIST
65240: LIST
65241: LIST
65242: LIST
65243: LIST
65244: IN
65245: NOT
65246: OR
65247: PUSH
65248: LD_VAR 0 3
65252: PPUSH
65253: LD_VAR 0 4
65257: PPUSH
65258: CALL_OW 488
65262: NOT
65263: OR
65264: IFFALSE 65268
// exit ;
65266: GO 65985
// pom := GetBase ( depot ) ;
65268: LD_ADDR_VAR 0 10
65272: PUSH
65273: LD_VAR 0 1
65277: PPUSH
65278: CALL_OW 274
65282: ST_TO_ADDR
// cost := CostOfBuilding ( btype , GetNation ( depot ) ) ;
65283: LD_ADDR_VAR 0 11
65287: PUSH
65288: LD_VAR 0 2
65292: PPUSH
65293: LD_VAR 0 1
65297: PPUSH
65298: CALL_OW 248
65302: PPUSH
65303: CALL_OW 450
65307: ST_TO_ADDR
// if not ( GetResourceType ( pom , mat_cans ) >= cost [ 1 ] and GetResourceType ( pom , mat_oil ) >= cost [ 2 ] and GetResourceType ( pom , mat_siberit ) >= cost [ 3 ] ) then
65308: LD_VAR 0 10
65312: PPUSH
65313: LD_INT 1
65315: PPUSH
65316: CALL_OW 275
65320: PUSH
65321: LD_VAR 0 11
65325: PUSH
65326: LD_INT 1
65328: ARRAY
65329: GREATEREQUAL
65330: PUSH
65331: LD_VAR 0 10
65335: PPUSH
65336: LD_INT 2
65338: PPUSH
65339: CALL_OW 275
65343: PUSH
65344: LD_VAR 0 11
65348: PUSH
65349: LD_INT 2
65351: ARRAY
65352: GREATEREQUAL
65353: AND
65354: PUSH
65355: LD_VAR 0 10
65359: PPUSH
65360: LD_INT 3
65362: PPUSH
65363: CALL_OW 275
65367: PUSH
65368: LD_VAR 0 11
65372: PUSH
65373: LD_INT 3
65375: ARRAY
65376: GREATEREQUAL
65377: AND
65378: NOT
65379: IFFALSE 65383
// exit ;
65381: GO 65985
// if GetBType ( depot ) = b_depot then
65383: LD_VAR 0 1
65387: PPUSH
65388: CALL_OW 266
65392: PUSH
65393: LD_INT 0
65395: EQUAL
65396: IFFALSE 65408
// dist := 28 else
65398: LD_ADDR_VAR 0 14
65402: PUSH
65403: LD_INT 28
65405: ST_TO_ADDR
65406: GO 65416
// dist := 36 ;
65408: LD_ADDR_VAR 0 14
65412: PUSH
65413: LD_INT 36
65415: ST_TO_ADDR
// if GetDistUnitXY ( depot , x , y ) > dist then
65416: LD_VAR 0 1
65420: PPUSH
65421: LD_VAR 0 3
65425: PPUSH
65426: LD_VAR 0 4
65430: PPUSH
65431: CALL_OW 297
65435: PUSH
65436: LD_VAR 0 14
65440: GREATER
65441: IFFALSE 65445
// exit ;
65443: GO 65985
// hexes := GetBuildingHexes ( btype , x , y , d , GetNation ( depot ) , 0 ) ;
65445: LD_ADDR_VAR 0 12
65449: PUSH
65450: LD_VAR 0 2
65454: PPUSH
65455: LD_VAR 0 3
65459: PPUSH
65460: LD_VAR 0 4
65464: PPUSH
65465: LD_VAR 0 5
65469: PPUSH
65470: LD_VAR 0 1
65474: PPUSH
65475: CALL_OW 248
65479: PPUSH
65480: LD_INT 0
65482: PPUSH
65483: CALL 65990 0 6
65487: ST_TO_ADDR
// if not hexes then
65488: LD_VAR 0 12
65492: NOT
65493: IFFALSE 65497
// exit ;
65495: GO 65985
// hex := GetHexInfo ( x , y ) ;
65497: LD_ADDR_VAR 0 15
65501: PUSH
65502: LD_VAR 0 3
65506: PPUSH
65507: LD_VAR 0 4
65511: PPUSH
65512: CALL_OW 546
65516: ST_TO_ADDR
// if hex [ 1 ] then
65517: LD_VAR 0 15
65521: PUSH
65522: LD_INT 1
65524: ARRAY
65525: IFFALSE 65529
// exit ;
65527: GO 65985
// height := hex [ 2 ] ;
65529: LD_ADDR_VAR 0 13
65533: PUSH
65534: LD_VAR 0 15
65538: PUSH
65539: LD_INT 2
65541: ARRAY
65542: ST_TO_ADDR
// for i = 1 to hexes do
65543: LD_ADDR_VAR 0 7
65547: PUSH
65548: DOUBLE
65549: LD_INT 1
65551: DEC
65552: ST_TO_ADDR
65553: LD_VAR 0 12
65557: PUSH
65558: FOR_TO
65559: IFFALSE 65889
// begin if not ValidHex ( hexes [ i ] [ 1 ] , hexes [ i ] [ 2 ] ) or HexInfo ( hexes [ i ] [ 1 ] , hexes [ i ] [ 2 ] ) > 0 or IsEnvironment ( hexes [ i ] [ 1 ] , hexes [ i ] [ 2 ] ) then
65561: LD_VAR 0 12
65565: PUSH
65566: LD_VAR 0 7
65570: ARRAY
65571: PUSH
65572: LD_INT 1
65574: ARRAY
65575: PPUSH
65576: LD_VAR 0 12
65580: PUSH
65581: LD_VAR 0 7
65585: ARRAY
65586: PUSH
65587: LD_INT 2
65589: ARRAY
65590: PPUSH
65591: CALL_OW 488
65595: NOT
65596: PUSH
65597: LD_VAR 0 12
65601: PUSH
65602: LD_VAR 0 7
65606: ARRAY
65607: PUSH
65608: LD_INT 1
65610: ARRAY
65611: PPUSH
65612: LD_VAR 0 12
65616: PUSH
65617: LD_VAR 0 7
65621: ARRAY
65622: PUSH
65623: LD_INT 2
65625: ARRAY
65626: PPUSH
65627: CALL_OW 428
65631: PUSH
65632: LD_INT 0
65634: GREATER
65635: OR
65636: PUSH
65637: LD_VAR 0 12
65641: PUSH
65642: LD_VAR 0 7
65646: ARRAY
65647: PUSH
65648: LD_INT 1
65650: ARRAY
65651: PPUSH
65652: LD_VAR 0 12
65656: PUSH
65657: LD_VAR 0 7
65661: ARRAY
65662: PUSH
65663: LD_INT 2
65665: ARRAY
65666: PPUSH
65667: CALL_OW 351
65671: OR
65672: IFFALSE 65678
// exit ;
65674: POP
65675: POP
65676: GO 65985
// j := GetHexInfo ( hexes [ i ] [ 1 ] , hexes [ i ] [ 2 ] ) ;
65678: LD_ADDR_VAR 0 8
65682: PUSH
65683: LD_VAR 0 12
65687: PUSH
65688: LD_VAR 0 7
65692: ARRAY
65693: PUSH
65694: LD_INT 1
65696: ARRAY
65697: PPUSH
65698: LD_VAR 0 12
65702: PUSH
65703: LD_VAR 0 7
65707: ARRAY
65708: PUSH
65709: LD_INT 2
65711: ARRAY
65712: PPUSH
65713: CALL_OW 546
65717: ST_TO_ADDR
// if j [ 1 ] or j [ 2 ] > height + 2 or j [ 2 ] < height - 2 or not j [ 3 ] in [ 0 , 8 , 9 , 10 , 11 , 12 , 13 , 16 , 17 , 18 , 19 , 20 , 21 ] or not j [ 5 ] or not j [ 6 ] in [ 1 , 2 , 7 , 9 , 10 , 11 ] then
65718: LD_VAR 0 8
65722: PUSH
65723: LD_INT 1
65725: ARRAY
65726: PUSH
65727: LD_VAR 0 8
65731: PUSH
65732: LD_INT 2
65734: ARRAY
65735: PUSH
65736: LD_VAR 0 13
65740: PUSH
65741: LD_INT 2
65743: PLUS
65744: GREATER
65745: OR
65746: PUSH
65747: LD_VAR 0 8
65751: PUSH
65752: LD_INT 2
65754: ARRAY
65755: PUSH
65756: LD_VAR 0 13
65760: PUSH
65761: LD_INT 2
65763: MINUS
65764: LESS
65765: OR
65766: PUSH
65767: LD_VAR 0 8
65771: PUSH
65772: LD_INT 3
65774: ARRAY
65775: PUSH
65776: LD_INT 0
65778: PUSH
65779: LD_INT 8
65781: PUSH
65782: LD_INT 9
65784: PUSH
65785: LD_INT 10
65787: PUSH
65788: LD_INT 11
65790: PUSH
65791: LD_INT 12
65793: PUSH
65794: LD_INT 13
65796: PUSH
65797: LD_INT 16
65799: PUSH
65800: LD_INT 17
65802: PUSH
65803: LD_INT 18
65805: PUSH
65806: LD_INT 19
65808: PUSH
65809: LD_INT 20
65811: PUSH
65812: LD_INT 21
65814: PUSH
65815: EMPTY
65816: LIST
65817: LIST
65818: LIST
65819: LIST
65820: LIST
65821: LIST
65822: LIST
65823: LIST
65824: LIST
65825: LIST
65826: LIST
65827: LIST
65828: LIST
65829: IN
65830: NOT
65831: OR
65832: PUSH
65833: LD_VAR 0 8
65837: PUSH
65838: LD_INT 5
65840: ARRAY
65841: NOT
65842: OR
65843: PUSH
65844: LD_VAR 0 8
65848: PUSH
65849: LD_INT 6
65851: ARRAY
65852: PUSH
65853: LD_INT 1
65855: PUSH
65856: LD_INT 2
65858: PUSH
65859: LD_INT 7
65861: PUSH
65862: LD_INT 9
65864: PUSH
65865: LD_INT 10
65867: PUSH
65868: LD_INT 11
65870: PUSH
65871: EMPTY
65872: LIST
65873: LIST
65874: LIST
65875: LIST
65876: LIST
65877: LIST
65878: IN
65879: NOT
65880: OR
65881: IFFALSE 65887
// exit ;
65883: POP
65884: POP
65885: GO 65985
// end ;
65887: GO 65558
65889: POP
65890: POP
// side := GetSide ( depot ) ;
65891: LD_ADDR_VAR 0 9
65895: PUSH
65896: LD_VAR 0 1
65900: PPUSH
65901: CALL_OW 255
65905: ST_TO_ADDR
// if DangerAtRangeXY ( side , x , y , 20 ) [ 4 ] then
65906: LD_VAR 0 9
65910: PPUSH
65911: LD_VAR 0 3
65915: PPUSH
65916: LD_VAR 0 4
65920: PPUSH
65921: LD_INT 20
65923: PPUSH
65924: CALL 58639 0 4
65928: PUSH
65929: LD_INT 4
65931: ARRAY
65932: IFFALSE 65936
// exit ;
65934: GO 65985
// if btype in [ b_oil_mine , b_siberite_mine ] and not GetResourceVisibility ( x , y , side ) then
65936: LD_VAR 0 2
65940: PUSH
65941: LD_INT 29
65943: PUSH
65944: LD_INT 30
65946: PUSH
65947: EMPTY
65948: LIST
65949: LIST
65950: IN
65951: PUSH
65952: LD_VAR 0 3
65956: PPUSH
65957: LD_VAR 0 4
65961: PPUSH
65962: LD_VAR 0 9
65966: PPUSH
65967: CALL_OW 440
65971: NOT
65972: AND
65973: IFFALSE 65977
// exit ;
65975: GO 65985
// result := true ;
65977: LD_ADDR_VAR 0 6
65981: PUSH
65982: LD_INT 1
65984: ST_TO_ADDR
// end ;
65985: LD_VAR 0 6
65989: RET
// export function GetBuildingHexes ( btype , x , y , dir , nation , mode ) ; var i , temp_list , temp_list2 ; var DepotAm0 , DepotAm1 , DepotAm2 , DepotAm3 , DepotAm4 , DepotAm5 , DepotAr0 , DepotAr1 , DepotAr2 , DepotAr3 , DepotAr4 , DepotAr5 , DepotRu0 , DepotRu1 , DepotRu2 , DepotRu3 , DepotRu4 , DepotRu5 ; var Factory0 , Factory1 , Factory2 , Factory3 , Factory4 , Factory5 , Ext0 , Ext1 , Ext2 , Ext3 , Ext4 , Ext5 ; var Lab0 , Lab1 , Lab2 , Lab3 , Lab4 , Lab5 , ControlTower0 , ControlTower1 , ControlTower2 , ControlTower3 , ControlTower4 , ControlTower5 ; var Barracks0 , Barracks1 , Barracks2 , Barracks3 , Barracks4 , Barracks5 , Bunker0 , Bunker1 , Bunker2 , Bunker3 , Bunker4 , Bunker5 ; begin
65990: LD_INT 0
65992: PPUSH
65993: PPUSH
65994: PPUSH
65995: PPUSH
65996: PPUSH
65997: PPUSH
65998: PPUSH
65999: PPUSH
66000: PPUSH
66001: PPUSH
66002: PPUSH
66003: PPUSH
66004: PPUSH
66005: PPUSH
66006: PPUSH
66007: PPUSH
66008: PPUSH
66009: PPUSH
66010: PPUSH
66011: PPUSH
66012: PPUSH
66013: PPUSH
66014: PPUSH
66015: PPUSH
66016: PPUSH
66017: PPUSH
66018: PPUSH
66019: PPUSH
66020: PPUSH
66021: PPUSH
66022: PPUSH
66023: PPUSH
66024: PPUSH
66025: PPUSH
66026: PPUSH
66027: PPUSH
66028: PPUSH
66029: PPUSH
66030: PPUSH
66031: PPUSH
66032: PPUSH
66033: PPUSH
66034: PPUSH
66035: PPUSH
66036: PPUSH
66037: PPUSH
66038: PPUSH
66039: PPUSH
66040: PPUSH
66041: PPUSH
66042: PPUSH
66043: PPUSH
66044: PPUSH
66045: PPUSH
66046: PPUSH
66047: PPUSH
66048: PPUSH
66049: PPUSH
// result = [ ] ;
66050: LD_ADDR_VAR 0 7
66054: PUSH
66055: EMPTY
66056: ST_TO_ADDR
// temp_list = [ ] ;
66057: LD_ADDR_VAR 0 9
66061: PUSH
66062: EMPTY
66063: ST_TO_ADDR
// if not dir in [ 0 , 1 , 2 , 3 , 4 , 5 ] or ( btype in [ b_depot , b_warehouse ] and not nation in [ nation_american , nation_arabian , nation_russian ] ) then
66064: LD_VAR 0 4
66068: PUSH
66069: LD_INT 0
66071: PUSH
66072: LD_INT 1
66074: PUSH
66075: LD_INT 2
66077: PUSH
66078: LD_INT 3
66080: PUSH
66081: LD_INT 4
66083: PUSH
66084: LD_INT 5
66086: PUSH
66087: EMPTY
66088: LIST
66089: LIST
66090: LIST
66091: LIST
66092: LIST
66093: LIST
66094: IN
66095: NOT
66096: PUSH
66097: LD_VAR 0 1
66101: PUSH
66102: LD_INT 0
66104: PUSH
66105: LD_INT 1
66107: PUSH
66108: EMPTY
66109: LIST
66110: LIST
66111: IN
66112: PUSH
66113: LD_VAR 0 5
66117: PUSH
66118: LD_INT 1
66120: PUSH
66121: LD_INT 2
66123: PUSH
66124: LD_INT 3
66126: PUSH
66127: EMPTY
66128: LIST
66129: LIST
66130: LIST
66131: IN
66132: NOT
66133: AND
66134: OR
66135: IFFALSE 66139
// exit ;
66137: GO 84530
// if btype in [ b_lab , b_lab_half , b_lab_full , b_lab_biological , b_lab_computer , b_lab_opto , b_lab_siberium , b_lab_spacetime , b_lab_weapon ] then
66139: LD_VAR 0 1
66143: PUSH
66144: LD_INT 6
66146: PUSH
66147: LD_INT 7
66149: PUSH
66150: LD_INT 8
66152: PUSH
66153: LD_INT 13
66155: PUSH
66156: LD_INT 12
66158: PUSH
66159: LD_INT 15
66161: PUSH
66162: LD_INT 11
66164: PUSH
66165: LD_INT 14
66167: PUSH
66168: LD_INT 10
66170: PUSH
66171: EMPTY
66172: LIST
66173: LIST
66174: LIST
66175: LIST
66176: LIST
66177: LIST
66178: LIST
66179: LIST
66180: LIST
66181: IN
66182: IFFALSE 66192
// btype = b_lab ;
66184: LD_ADDR_VAR 0 1
66188: PUSH
66189: LD_INT 6
66191: ST_TO_ADDR
// if not mode in [ 0 , 1 , 2 ] or ( not btype in [ b_depot , b_warehouse , b_workshop , b_factory , b_lab , b_control_tower , b_armoury , b_barracks , b_breastwork , b_bunker , b_turret ] and mode = 1 ) or ( not btype in [ b_workshop , b_factory ] and mode = 2 ) then
66192: LD_VAR 0 6
66196: PUSH
66197: LD_INT 0
66199: PUSH
66200: LD_INT 1
66202: PUSH
66203: LD_INT 2
66205: PUSH
66206: EMPTY
66207: LIST
66208: LIST
66209: LIST
66210: IN
66211: NOT
66212: PUSH
66213: LD_VAR 0 1
66217: PUSH
66218: LD_INT 0
66220: PUSH
66221: LD_INT 1
66223: PUSH
66224: LD_INT 2
66226: PUSH
66227: LD_INT 3
66229: PUSH
66230: LD_INT 6
66232: PUSH
66233: LD_INT 36
66235: PUSH
66236: LD_INT 4
66238: PUSH
66239: LD_INT 5
66241: PUSH
66242: LD_INT 31
66244: PUSH
66245: LD_INT 32
66247: PUSH
66248: LD_INT 33
66250: PUSH
66251: EMPTY
66252: LIST
66253: LIST
66254: LIST
66255: LIST
66256: LIST
66257: LIST
66258: LIST
66259: LIST
66260: LIST
66261: LIST
66262: LIST
66263: IN
66264: NOT
66265: PUSH
66266: LD_VAR 0 6
66270: PUSH
66271: LD_INT 1
66273: EQUAL
66274: AND
66275: OR
66276: PUSH
66277: LD_VAR 0 1
66281: PUSH
66282: LD_INT 2
66284: PUSH
66285: LD_INT 3
66287: PUSH
66288: EMPTY
66289: LIST
66290: LIST
66291: IN
66292: NOT
66293: PUSH
66294: LD_VAR 0 6
66298: PUSH
66299: LD_INT 2
66301: EQUAL
66302: AND
66303: OR
66304: IFFALSE 66314
// mode = 0 ;
66306: LD_ADDR_VAR 0 6
66310: PUSH
66311: LD_INT 0
66313: ST_TO_ADDR
// case mode of 0 :
66314: LD_VAR 0 6
66318: PUSH
66319: LD_INT 0
66321: DOUBLE
66322: EQUAL
66323: IFTRUE 66327
66325: GO 77780
66327: POP
// begin DepotAm0 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ 1 , 3 ] , [ 0 , 3 ] , [ - 1 , 2 ] ] ;
66328: LD_ADDR_VAR 0 11
66332: PUSH
66333: LD_INT 0
66335: PUSH
66336: LD_INT 0
66338: PUSH
66339: EMPTY
66340: LIST
66341: LIST
66342: PUSH
66343: LD_INT 0
66345: PUSH
66346: LD_INT 1
66348: NEG
66349: PUSH
66350: EMPTY
66351: LIST
66352: LIST
66353: PUSH
66354: LD_INT 1
66356: PUSH
66357: LD_INT 0
66359: PUSH
66360: EMPTY
66361: LIST
66362: LIST
66363: PUSH
66364: LD_INT 1
66366: PUSH
66367: LD_INT 1
66369: PUSH
66370: EMPTY
66371: LIST
66372: LIST
66373: PUSH
66374: LD_INT 0
66376: PUSH
66377: LD_INT 1
66379: PUSH
66380: EMPTY
66381: LIST
66382: LIST
66383: PUSH
66384: LD_INT 1
66386: NEG
66387: PUSH
66388: LD_INT 0
66390: PUSH
66391: EMPTY
66392: LIST
66393: LIST
66394: PUSH
66395: LD_INT 1
66397: NEG
66398: PUSH
66399: LD_INT 1
66401: NEG
66402: PUSH
66403: EMPTY
66404: LIST
66405: LIST
66406: PUSH
66407: LD_INT 1
66409: NEG
66410: PUSH
66411: LD_INT 2
66413: NEG
66414: PUSH
66415: EMPTY
66416: LIST
66417: LIST
66418: PUSH
66419: LD_INT 0
66421: PUSH
66422: LD_INT 2
66424: NEG
66425: PUSH
66426: EMPTY
66427: LIST
66428: LIST
66429: PUSH
66430: LD_INT 1
66432: PUSH
66433: LD_INT 1
66435: NEG
66436: PUSH
66437: EMPTY
66438: LIST
66439: LIST
66440: PUSH
66441: LD_INT 1
66443: PUSH
66444: LD_INT 2
66446: PUSH
66447: EMPTY
66448: LIST
66449: LIST
66450: PUSH
66451: LD_INT 0
66453: PUSH
66454: LD_INT 2
66456: PUSH
66457: EMPTY
66458: LIST
66459: LIST
66460: PUSH
66461: LD_INT 1
66463: NEG
66464: PUSH
66465: LD_INT 1
66467: PUSH
66468: EMPTY
66469: LIST
66470: LIST
66471: PUSH
66472: LD_INT 1
66474: PUSH
66475: LD_INT 3
66477: PUSH
66478: EMPTY
66479: LIST
66480: LIST
66481: PUSH
66482: LD_INT 0
66484: PUSH
66485: LD_INT 3
66487: PUSH
66488: EMPTY
66489: LIST
66490: LIST
66491: PUSH
66492: LD_INT 1
66494: NEG
66495: PUSH
66496: LD_INT 2
66498: PUSH
66499: EMPTY
66500: LIST
66501: LIST
66502: PUSH
66503: EMPTY
66504: LIST
66505: LIST
66506: LIST
66507: LIST
66508: LIST
66509: LIST
66510: LIST
66511: LIST
66512: LIST
66513: LIST
66514: LIST
66515: LIST
66516: LIST
66517: LIST
66518: LIST
66519: LIST
66520: ST_TO_ADDR
// DepotAm1 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , 1 ] , [ - 3 , 0 ] , [ - 3 , - 1 ] ] ;
66521: LD_ADDR_VAR 0 12
66525: PUSH
66526: LD_INT 0
66528: PUSH
66529: LD_INT 0
66531: PUSH
66532: EMPTY
66533: LIST
66534: LIST
66535: PUSH
66536: LD_INT 0
66538: PUSH
66539: LD_INT 1
66541: NEG
66542: PUSH
66543: EMPTY
66544: LIST
66545: LIST
66546: PUSH
66547: LD_INT 1
66549: PUSH
66550: LD_INT 0
66552: PUSH
66553: EMPTY
66554: LIST
66555: LIST
66556: PUSH
66557: LD_INT 1
66559: PUSH
66560: LD_INT 1
66562: PUSH
66563: EMPTY
66564: LIST
66565: LIST
66566: PUSH
66567: LD_INT 0
66569: PUSH
66570: LD_INT 1
66572: PUSH
66573: EMPTY
66574: LIST
66575: LIST
66576: PUSH
66577: LD_INT 1
66579: NEG
66580: PUSH
66581: LD_INT 0
66583: PUSH
66584: EMPTY
66585: LIST
66586: LIST
66587: PUSH
66588: LD_INT 1
66590: NEG
66591: PUSH
66592: LD_INT 1
66594: NEG
66595: PUSH
66596: EMPTY
66597: LIST
66598: LIST
66599: PUSH
66600: LD_INT 1
66602: PUSH
66603: LD_INT 1
66605: NEG
66606: PUSH
66607: EMPTY
66608: LIST
66609: LIST
66610: PUSH
66611: LD_INT 2
66613: PUSH
66614: LD_INT 0
66616: PUSH
66617: EMPTY
66618: LIST
66619: LIST
66620: PUSH
66621: LD_INT 2
66623: PUSH
66624: LD_INT 1
66626: PUSH
66627: EMPTY
66628: LIST
66629: LIST
66630: PUSH
66631: LD_INT 1
66633: NEG
66634: PUSH
66635: LD_INT 1
66637: PUSH
66638: EMPTY
66639: LIST
66640: LIST
66641: PUSH
66642: LD_INT 2
66644: NEG
66645: PUSH
66646: LD_INT 0
66648: PUSH
66649: EMPTY
66650: LIST
66651: LIST
66652: PUSH
66653: LD_INT 2
66655: NEG
66656: PUSH
66657: LD_INT 1
66659: NEG
66660: PUSH
66661: EMPTY
66662: LIST
66663: LIST
66664: PUSH
66665: LD_INT 2
66667: NEG
66668: PUSH
66669: LD_INT 1
66671: PUSH
66672: EMPTY
66673: LIST
66674: LIST
66675: PUSH
66676: LD_INT 3
66678: NEG
66679: PUSH
66680: LD_INT 0
66682: PUSH
66683: EMPTY
66684: LIST
66685: LIST
66686: PUSH
66687: LD_INT 3
66689: NEG
66690: PUSH
66691: LD_INT 1
66693: NEG
66694: PUSH
66695: EMPTY
66696: LIST
66697: LIST
66698: PUSH
66699: EMPTY
66700: LIST
66701: LIST
66702: LIST
66703: LIST
66704: LIST
66705: LIST
66706: LIST
66707: LIST
66708: LIST
66709: LIST
66710: LIST
66711: LIST
66712: LIST
66713: LIST
66714: LIST
66715: LIST
66716: ST_TO_ADDR
// DepotAm2 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ - 2 , - 3 ] , [ - 3 , - 2 ] , [ - 3 , - 3 ] ] ;
66717: LD_ADDR_VAR 0 13
66721: PUSH
66722: LD_INT 0
66724: PUSH
66725: LD_INT 0
66727: PUSH
66728: EMPTY
66729: LIST
66730: LIST
66731: PUSH
66732: LD_INT 0
66734: PUSH
66735: LD_INT 1
66737: NEG
66738: PUSH
66739: EMPTY
66740: LIST
66741: LIST
66742: PUSH
66743: LD_INT 1
66745: PUSH
66746: LD_INT 0
66748: PUSH
66749: EMPTY
66750: LIST
66751: LIST
66752: PUSH
66753: LD_INT 1
66755: PUSH
66756: LD_INT 1
66758: PUSH
66759: EMPTY
66760: LIST
66761: LIST
66762: PUSH
66763: LD_INT 0
66765: PUSH
66766: LD_INT 1
66768: PUSH
66769: EMPTY
66770: LIST
66771: LIST
66772: PUSH
66773: LD_INT 1
66775: NEG
66776: PUSH
66777: LD_INT 0
66779: PUSH
66780: EMPTY
66781: LIST
66782: LIST
66783: PUSH
66784: LD_INT 1
66786: NEG
66787: PUSH
66788: LD_INT 1
66790: NEG
66791: PUSH
66792: EMPTY
66793: LIST
66794: LIST
66795: PUSH
66796: LD_INT 1
66798: NEG
66799: PUSH
66800: LD_INT 2
66802: NEG
66803: PUSH
66804: EMPTY
66805: LIST
66806: LIST
66807: PUSH
66808: LD_INT 2
66810: PUSH
66811: LD_INT 1
66813: PUSH
66814: EMPTY
66815: LIST
66816: LIST
66817: PUSH
66818: LD_INT 2
66820: PUSH
66821: LD_INT 2
66823: PUSH
66824: EMPTY
66825: LIST
66826: LIST
66827: PUSH
66828: LD_INT 1
66830: PUSH
66831: LD_INT 2
66833: PUSH
66834: EMPTY
66835: LIST
66836: LIST
66837: PUSH
66838: LD_INT 2
66840: NEG
66841: PUSH
66842: LD_INT 1
66844: NEG
66845: PUSH
66846: EMPTY
66847: LIST
66848: LIST
66849: PUSH
66850: LD_INT 2
66852: NEG
66853: PUSH
66854: LD_INT 2
66856: NEG
66857: PUSH
66858: EMPTY
66859: LIST
66860: LIST
66861: PUSH
66862: LD_INT 2
66864: NEG
66865: PUSH
66866: LD_INT 3
66868: NEG
66869: PUSH
66870: EMPTY
66871: LIST
66872: LIST
66873: PUSH
66874: LD_INT 3
66876: NEG
66877: PUSH
66878: LD_INT 2
66880: NEG
66881: PUSH
66882: EMPTY
66883: LIST
66884: LIST
66885: PUSH
66886: LD_INT 3
66888: NEG
66889: PUSH
66890: LD_INT 3
66892: NEG
66893: PUSH
66894: EMPTY
66895: LIST
66896: LIST
66897: PUSH
66898: EMPTY
66899: LIST
66900: LIST
66901: LIST
66902: LIST
66903: LIST
66904: LIST
66905: LIST
66906: LIST
66907: LIST
66908: LIST
66909: LIST
66910: LIST
66911: LIST
66912: LIST
66913: LIST
66914: LIST
66915: ST_TO_ADDR
// DepotAm3 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 1 , - 3 ] , [ 0 , - 3 ] , [ 1 , - 2 ] ] ;
66916: LD_ADDR_VAR 0 14
66920: PUSH
66921: LD_INT 0
66923: PUSH
66924: LD_INT 0
66926: PUSH
66927: EMPTY
66928: LIST
66929: LIST
66930: PUSH
66931: LD_INT 0
66933: PUSH
66934: LD_INT 1
66936: NEG
66937: PUSH
66938: EMPTY
66939: LIST
66940: LIST
66941: PUSH
66942: LD_INT 1
66944: PUSH
66945: LD_INT 0
66947: PUSH
66948: EMPTY
66949: LIST
66950: LIST
66951: PUSH
66952: LD_INT 1
66954: PUSH
66955: LD_INT 1
66957: PUSH
66958: EMPTY
66959: LIST
66960: LIST
66961: PUSH
66962: LD_INT 0
66964: PUSH
66965: LD_INT 1
66967: PUSH
66968: EMPTY
66969: LIST
66970: LIST
66971: PUSH
66972: LD_INT 1
66974: NEG
66975: PUSH
66976: LD_INT 0
66978: PUSH
66979: EMPTY
66980: LIST
66981: LIST
66982: PUSH
66983: LD_INT 1
66985: NEG
66986: PUSH
66987: LD_INT 1
66989: NEG
66990: PUSH
66991: EMPTY
66992: LIST
66993: LIST
66994: PUSH
66995: LD_INT 1
66997: NEG
66998: PUSH
66999: LD_INT 2
67001: NEG
67002: PUSH
67003: EMPTY
67004: LIST
67005: LIST
67006: PUSH
67007: LD_INT 0
67009: PUSH
67010: LD_INT 2
67012: NEG
67013: PUSH
67014: EMPTY
67015: LIST
67016: LIST
67017: PUSH
67018: LD_INT 1
67020: PUSH
67021: LD_INT 1
67023: NEG
67024: PUSH
67025: EMPTY
67026: LIST
67027: LIST
67028: PUSH
67029: LD_INT 1
67031: PUSH
67032: LD_INT 2
67034: PUSH
67035: EMPTY
67036: LIST
67037: LIST
67038: PUSH
67039: LD_INT 0
67041: PUSH
67042: LD_INT 2
67044: PUSH
67045: EMPTY
67046: LIST
67047: LIST
67048: PUSH
67049: LD_INT 1
67051: NEG
67052: PUSH
67053: LD_INT 1
67055: PUSH
67056: EMPTY
67057: LIST
67058: LIST
67059: PUSH
67060: LD_INT 1
67062: NEG
67063: PUSH
67064: LD_INT 3
67066: NEG
67067: PUSH
67068: EMPTY
67069: LIST
67070: LIST
67071: PUSH
67072: LD_INT 0
67074: PUSH
67075: LD_INT 3
67077: NEG
67078: PUSH
67079: EMPTY
67080: LIST
67081: LIST
67082: PUSH
67083: LD_INT 1
67085: PUSH
67086: LD_INT 2
67088: NEG
67089: PUSH
67090: EMPTY
67091: LIST
67092: LIST
67093: PUSH
67094: EMPTY
67095: LIST
67096: LIST
67097: LIST
67098: LIST
67099: LIST
67100: LIST
67101: LIST
67102: LIST
67103: LIST
67104: LIST
67105: LIST
67106: LIST
67107: LIST
67108: LIST
67109: LIST
67110: LIST
67111: ST_TO_ADDR
// DepotAm4 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ 2 , - 1 ] , [ 3 , 0 ] , [ 3 , 1 ] ] ;
67112: LD_ADDR_VAR 0 15
67116: PUSH
67117: LD_INT 0
67119: PUSH
67120: LD_INT 0
67122: PUSH
67123: EMPTY
67124: LIST
67125: LIST
67126: PUSH
67127: LD_INT 0
67129: PUSH
67130: LD_INT 1
67132: NEG
67133: PUSH
67134: EMPTY
67135: LIST
67136: LIST
67137: PUSH
67138: LD_INT 1
67140: PUSH
67141: LD_INT 0
67143: PUSH
67144: EMPTY
67145: LIST
67146: LIST
67147: PUSH
67148: LD_INT 1
67150: PUSH
67151: LD_INT 1
67153: PUSH
67154: EMPTY
67155: LIST
67156: LIST
67157: PUSH
67158: LD_INT 0
67160: PUSH
67161: LD_INT 1
67163: PUSH
67164: EMPTY
67165: LIST
67166: LIST
67167: PUSH
67168: LD_INT 1
67170: NEG
67171: PUSH
67172: LD_INT 0
67174: PUSH
67175: EMPTY
67176: LIST
67177: LIST
67178: PUSH
67179: LD_INT 1
67181: NEG
67182: PUSH
67183: LD_INT 1
67185: NEG
67186: PUSH
67187: EMPTY
67188: LIST
67189: LIST
67190: PUSH
67191: LD_INT 1
67193: PUSH
67194: LD_INT 1
67196: NEG
67197: PUSH
67198: EMPTY
67199: LIST
67200: LIST
67201: PUSH
67202: LD_INT 2
67204: PUSH
67205: LD_INT 0
67207: PUSH
67208: EMPTY
67209: LIST
67210: LIST
67211: PUSH
67212: LD_INT 2
67214: PUSH
67215: LD_INT 1
67217: PUSH
67218: EMPTY
67219: LIST
67220: LIST
67221: PUSH
67222: LD_INT 1
67224: NEG
67225: PUSH
67226: LD_INT 1
67228: PUSH
67229: EMPTY
67230: LIST
67231: LIST
67232: PUSH
67233: LD_INT 2
67235: NEG
67236: PUSH
67237: LD_INT 0
67239: PUSH
67240: EMPTY
67241: LIST
67242: LIST
67243: PUSH
67244: LD_INT 2
67246: NEG
67247: PUSH
67248: LD_INT 1
67250: NEG
67251: PUSH
67252: EMPTY
67253: LIST
67254: LIST
67255: PUSH
67256: LD_INT 2
67258: PUSH
67259: LD_INT 1
67261: NEG
67262: PUSH
67263: EMPTY
67264: LIST
67265: LIST
67266: PUSH
67267: LD_INT 3
67269: PUSH
67270: LD_INT 0
67272: PUSH
67273: EMPTY
67274: LIST
67275: LIST
67276: PUSH
67277: LD_INT 3
67279: PUSH
67280: LD_INT 1
67282: PUSH
67283: EMPTY
67284: LIST
67285: LIST
67286: PUSH
67287: EMPTY
67288: LIST
67289: LIST
67290: LIST
67291: LIST
67292: LIST
67293: LIST
67294: LIST
67295: LIST
67296: LIST
67297: LIST
67298: LIST
67299: LIST
67300: LIST
67301: LIST
67302: LIST
67303: LIST
67304: ST_TO_ADDR
// DepotAm5 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ 3 , 2 ] , [ 3 , 3 ] , [ 2 , 3 ] ] ;
67305: LD_ADDR_VAR 0 16
67309: PUSH
67310: LD_INT 0
67312: PUSH
67313: LD_INT 0
67315: PUSH
67316: EMPTY
67317: LIST
67318: LIST
67319: PUSH
67320: LD_INT 0
67322: PUSH
67323: LD_INT 1
67325: NEG
67326: PUSH
67327: EMPTY
67328: LIST
67329: LIST
67330: PUSH
67331: LD_INT 1
67333: PUSH
67334: LD_INT 0
67336: PUSH
67337: EMPTY
67338: LIST
67339: LIST
67340: PUSH
67341: LD_INT 1
67343: PUSH
67344: LD_INT 1
67346: PUSH
67347: EMPTY
67348: LIST
67349: LIST
67350: PUSH
67351: LD_INT 0
67353: PUSH
67354: LD_INT 1
67356: PUSH
67357: EMPTY
67358: LIST
67359: LIST
67360: PUSH
67361: LD_INT 1
67363: NEG
67364: PUSH
67365: LD_INT 0
67367: PUSH
67368: EMPTY
67369: LIST
67370: LIST
67371: PUSH
67372: LD_INT 1
67374: NEG
67375: PUSH
67376: LD_INT 1
67378: NEG
67379: PUSH
67380: EMPTY
67381: LIST
67382: LIST
67383: PUSH
67384: LD_INT 1
67386: NEG
67387: PUSH
67388: LD_INT 2
67390: NEG
67391: PUSH
67392: EMPTY
67393: LIST
67394: LIST
67395: PUSH
67396: LD_INT 2
67398: PUSH
67399: LD_INT 1
67401: PUSH
67402: EMPTY
67403: LIST
67404: LIST
67405: PUSH
67406: LD_INT 2
67408: PUSH
67409: LD_INT 2
67411: PUSH
67412: EMPTY
67413: LIST
67414: LIST
67415: PUSH
67416: LD_INT 1
67418: PUSH
67419: LD_INT 2
67421: PUSH
67422: EMPTY
67423: LIST
67424: LIST
67425: PUSH
67426: LD_INT 2
67428: NEG
67429: PUSH
67430: LD_INT 1
67432: NEG
67433: PUSH
67434: EMPTY
67435: LIST
67436: LIST
67437: PUSH
67438: LD_INT 2
67440: NEG
67441: PUSH
67442: LD_INT 2
67444: NEG
67445: PUSH
67446: EMPTY
67447: LIST
67448: LIST
67449: PUSH
67450: LD_INT 3
67452: PUSH
67453: LD_INT 2
67455: PUSH
67456: EMPTY
67457: LIST
67458: LIST
67459: PUSH
67460: LD_INT 3
67462: PUSH
67463: LD_INT 3
67465: PUSH
67466: EMPTY
67467: LIST
67468: LIST
67469: PUSH
67470: LD_INT 2
67472: PUSH
67473: LD_INT 3
67475: PUSH
67476: EMPTY
67477: LIST
67478: LIST
67479: PUSH
67480: EMPTY
67481: LIST
67482: LIST
67483: LIST
67484: LIST
67485: LIST
67486: LIST
67487: LIST
67488: LIST
67489: LIST
67490: LIST
67491: LIST
67492: LIST
67493: LIST
67494: LIST
67495: LIST
67496: LIST
67497: ST_TO_ADDR
// DepotAr0 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
67498: LD_ADDR_VAR 0 17
67502: PUSH
67503: LD_INT 0
67505: PUSH
67506: LD_INT 0
67508: PUSH
67509: EMPTY
67510: LIST
67511: LIST
67512: PUSH
67513: LD_INT 0
67515: PUSH
67516: LD_INT 1
67518: NEG
67519: PUSH
67520: EMPTY
67521: LIST
67522: LIST
67523: PUSH
67524: LD_INT 1
67526: PUSH
67527: LD_INT 0
67529: PUSH
67530: EMPTY
67531: LIST
67532: LIST
67533: PUSH
67534: LD_INT 1
67536: PUSH
67537: LD_INT 1
67539: PUSH
67540: EMPTY
67541: LIST
67542: LIST
67543: PUSH
67544: LD_INT 0
67546: PUSH
67547: LD_INT 1
67549: PUSH
67550: EMPTY
67551: LIST
67552: LIST
67553: PUSH
67554: LD_INT 1
67556: NEG
67557: PUSH
67558: LD_INT 0
67560: PUSH
67561: EMPTY
67562: LIST
67563: LIST
67564: PUSH
67565: LD_INT 1
67567: NEG
67568: PUSH
67569: LD_INT 1
67571: NEG
67572: PUSH
67573: EMPTY
67574: LIST
67575: LIST
67576: PUSH
67577: LD_INT 1
67579: NEG
67580: PUSH
67581: LD_INT 2
67583: NEG
67584: PUSH
67585: EMPTY
67586: LIST
67587: LIST
67588: PUSH
67589: LD_INT 0
67591: PUSH
67592: LD_INT 2
67594: NEG
67595: PUSH
67596: EMPTY
67597: LIST
67598: LIST
67599: PUSH
67600: LD_INT 1
67602: PUSH
67603: LD_INT 1
67605: NEG
67606: PUSH
67607: EMPTY
67608: LIST
67609: LIST
67610: PUSH
67611: LD_INT 2
67613: PUSH
67614: LD_INT 0
67616: PUSH
67617: EMPTY
67618: LIST
67619: LIST
67620: PUSH
67621: LD_INT 2
67623: PUSH
67624: LD_INT 1
67626: PUSH
67627: EMPTY
67628: LIST
67629: LIST
67630: PUSH
67631: LD_INT 2
67633: PUSH
67634: LD_INT 2
67636: PUSH
67637: EMPTY
67638: LIST
67639: LIST
67640: PUSH
67641: LD_INT 1
67643: PUSH
67644: LD_INT 2
67646: PUSH
67647: EMPTY
67648: LIST
67649: LIST
67650: PUSH
67651: LD_INT 0
67653: PUSH
67654: LD_INT 2
67656: PUSH
67657: EMPTY
67658: LIST
67659: LIST
67660: PUSH
67661: LD_INT 1
67663: NEG
67664: PUSH
67665: LD_INT 1
67667: PUSH
67668: EMPTY
67669: LIST
67670: LIST
67671: PUSH
67672: LD_INT 2
67674: NEG
67675: PUSH
67676: LD_INT 0
67678: PUSH
67679: EMPTY
67680: LIST
67681: LIST
67682: PUSH
67683: LD_INT 2
67685: NEG
67686: PUSH
67687: LD_INT 1
67689: NEG
67690: PUSH
67691: EMPTY
67692: LIST
67693: LIST
67694: PUSH
67695: LD_INT 2
67697: NEG
67698: PUSH
67699: LD_INT 2
67701: NEG
67702: PUSH
67703: EMPTY
67704: LIST
67705: LIST
67706: PUSH
67707: EMPTY
67708: LIST
67709: LIST
67710: LIST
67711: LIST
67712: LIST
67713: LIST
67714: LIST
67715: LIST
67716: LIST
67717: LIST
67718: LIST
67719: LIST
67720: LIST
67721: LIST
67722: LIST
67723: LIST
67724: LIST
67725: LIST
67726: LIST
67727: ST_TO_ADDR
// DepotAr1 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
67728: LD_ADDR_VAR 0 18
67732: PUSH
67733: LD_INT 0
67735: PUSH
67736: LD_INT 0
67738: PUSH
67739: EMPTY
67740: LIST
67741: LIST
67742: PUSH
67743: LD_INT 0
67745: PUSH
67746: LD_INT 1
67748: NEG
67749: PUSH
67750: EMPTY
67751: LIST
67752: LIST
67753: PUSH
67754: LD_INT 1
67756: PUSH
67757: LD_INT 0
67759: PUSH
67760: EMPTY
67761: LIST
67762: LIST
67763: PUSH
67764: LD_INT 1
67766: PUSH
67767: LD_INT 1
67769: PUSH
67770: EMPTY
67771: LIST
67772: LIST
67773: PUSH
67774: LD_INT 0
67776: PUSH
67777: LD_INT 1
67779: PUSH
67780: EMPTY
67781: LIST
67782: LIST
67783: PUSH
67784: LD_INT 1
67786: NEG
67787: PUSH
67788: LD_INT 0
67790: PUSH
67791: EMPTY
67792: LIST
67793: LIST
67794: PUSH
67795: LD_INT 1
67797: NEG
67798: PUSH
67799: LD_INT 1
67801: NEG
67802: PUSH
67803: EMPTY
67804: LIST
67805: LIST
67806: PUSH
67807: LD_INT 1
67809: NEG
67810: PUSH
67811: LD_INT 2
67813: NEG
67814: PUSH
67815: EMPTY
67816: LIST
67817: LIST
67818: PUSH
67819: LD_INT 0
67821: PUSH
67822: LD_INT 2
67824: NEG
67825: PUSH
67826: EMPTY
67827: LIST
67828: LIST
67829: PUSH
67830: LD_INT 1
67832: PUSH
67833: LD_INT 1
67835: NEG
67836: PUSH
67837: EMPTY
67838: LIST
67839: LIST
67840: PUSH
67841: LD_INT 2
67843: PUSH
67844: LD_INT 0
67846: PUSH
67847: EMPTY
67848: LIST
67849: LIST
67850: PUSH
67851: LD_INT 2
67853: PUSH
67854: LD_INT 1
67856: PUSH
67857: EMPTY
67858: LIST
67859: LIST
67860: PUSH
67861: LD_INT 2
67863: PUSH
67864: LD_INT 2
67866: PUSH
67867: EMPTY
67868: LIST
67869: LIST
67870: PUSH
67871: LD_INT 1
67873: PUSH
67874: LD_INT 2
67876: PUSH
67877: EMPTY
67878: LIST
67879: LIST
67880: PUSH
67881: LD_INT 0
67883: PUSH
67884: LD_INT 2
67886: PUSH
67887: EMPTY
67888: LIST
67889: LIST
67890: PUSH
67891: LD_INT 1
67893: NEG
67894: PUSH
67895: LD_INT 1
67897: PUSH
67898: EMPTY
67899: LIST
67900: LIST
67901: PUSH
67902: LD_INT 2
67904: NEG
67905: PUSH
67906: LD_INT 0
67908: PUSH
67909: EMPTY
67910: LIST
67911: LIST
67912: PUSH
67913: LD_INT 2
67915: NEG
67916: PUSH
67917: LD_INT 1
67919: NEG
67920: PUSH
67921: EMPTY
67922: LIST
67923: LIST
67924: PUSH
67925: LD_INT 2
67927: NEG
67928: PUSH
67929: LD_INT 2
67931: NEG
67932: PUSH
67933: EMPTY
67934: LIST
67935: LIST
67936: PUSH
67937: EMPTY
67938: LIST
67939: LIST
67940: LIST
67941: LIST
67942: LIST
67943: LIST
67944: LIST
67945: LIST
67946: LIST
67947: LIST
67948: LIST
67949: LIST
67950: LIST
67951: LIST
67952: LIST
67953: LIST
67954: LIST
67955: LIST
67956: LIST
67957: ST_TO_ADDR
// DepotAr2 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
67958: LD_ADDR_VAR 0 19
67962: PUSH
67963: LD_INT 0
67965: PUSH
67966: LD_INT 0
67968: PUSH
67969: EMPTY
67970: LIST
67971: LIST
67972: PUSH
67973: LD_INT 0
67975: PUSH
67976: LD_INT 1
67978: NEG
67979: PUSH
67980: EMPTY
67981: LIST
67982: LIST
67983: PUSH
67984: LD_INT 1
67986: PUSH
67987: LD_INT 0
67989: PUSH
67990: EMPTY
67991: LIST
67992: LIST
67993: PUSH
67994: LD_INT 1
67996: PUSH
67997: LD_INT 1
67999: PUSH
68000: EMPTY
68001: LIST
68002: LIST
68003: PUSH
68004: LD_INT 0
68006: PUSH
68007: LD_INT 1
68009: PUSH
68010: EMPTY
68011: LIST
68012: LIST
68013: PUSH
68014: LD_INT 1
68016: NEG
68017: PUSH
68018: LD_INT 0
68020: PUSH
68021: EMPTY
68022: LIST
68023: LIST
68024: PUSH
68025: LD_INT 1
68027: NEG
68028: PUSH
68029: LD_INT 1
68031: NEG
68032: PUSH
68033: EMPTY
68034: LIST
68035: LIST
68036: PUSH
68037: LD_INT 1
68039: NEG
68040: PUSH
68041: LD_INT 2
68043: NEG
68044: PUSH
68045: EMPTY
68046: LIST
68047: LIST
68048: PUSH
68049: LD_INT 0
68051: PUSH
68052: LD_INT 2
68054: NEG
68055: PUSH
68056: EMPTY
68057: LIST
68058: LIST
68059: PUSH
68060: LD_INT 1
68062: PUSH
68063: LD_INT 1
68065: NEG
68066: PUSH
68067: EMPTY
68068: LIST
68069: LIST
68070: PUSH
68071: LD_INT 2
68073: PUSH
68074: LD_INT 0
68076: PUSH
68077: EMPTY
68078: LIST
68079: LIST
68080: PUSH
68081: LD_INT 2
68083: PUSH
68084: LD_INT 1
68086: PUSH
68087: EMPTY
68088: LIST
68089: LIST
68090: PUSH
68091: LD_INT 2
68093: PUSH
68094: LD_INT 2
68096: PUSH
68097: EMPTY
68098: LIST
68099: LIST
68100: PUSH
68101: LD_INT 1
68103: PUSH
68104: LD_INT 2
68106: PUSH
68107: EMPTY
68108: LIST
68109: LIST
68110: PUSH
68111: LD_INT 0
68113: PUSH
68114: LD_INT 2
68116: PUSH
68117: EMPTY
68118: LIST
68119: LIST
68120: PUSH
68121: LD_INT 1
68123: NEG
68124: PUSH
68125: LD_INT 1
68127: PUSH
68128: EMPTY
68129: LIST
68130: LIST
68131: PUSH
68132: LD_INT 2
68134: NEG
68135: PUSH
68136: LD_INT 0
68138: PUSH
68139: EMPTY
68140: LIST
68141: LIST
68142: PUSH
68143: LD_INT 2
68145: NEG
68146: PUSH
68147: LD_INT 1
68149: NEG
68150: PUSH
68151: EMPTY
68152: LIST
68153: LIST
68154: PUSH
68155: LD_INT 2
68157: NEG
68158: PUSH
68159: LD_INT 2
68161: NEG
68162: PUSH
68163: EMPTY
68164: LIST
68165: LIST
68166: PUSH
68167: EMPTY
68168: LIST
68169: LIST
68170: LIST
68171: LIST
68172: LIST
68173: LIST
68174: LIST
68175: LIST
68176: LIST
68177: LIST
68178: LIST
68179: LIST
68180: LIST
68181: LIST
68182: LIST
68183: LIST
68184: LIST
68185: LIST
68186: LIST
68187: ST_TO_ADDR
// DepotAr3 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
68188: LD_ADDR_VAR 0 20
68192: PUSH
68193: LD_INT 0
68195: PUSH
68196: LD_INT 0
68198: PUSH
68199: EMPTY
68200: LIST
68201: LIST
68202: PUSH
68203: LD_INT 0
68205: PUSH
68206: LD_INT 1
68208: NEG
68209: PUSH
68210: EMPTY
68211: LIST
68212: LIST
68213: PUSH
68214: LD_INT 1
68216: PUSH
68217: LD_INT 0
68219: PUSH
68220: EMPTY
68221: LIST
68222: LIST
68223: PUSH
68224: LD_INT 1
68226: PUSH
68227: LD_INT 1
68229: PUSH
68230: EMPTY
68231: LIST
68232: LIST
68233: PUSH
68234: LD_INT 0
68236: PUSH
68237: LD_INT 1
68239: PUSH
68240: EMPTY
68241: LIST
68242: LIST
68243: PUSH
68244: LD_INT 1
68246: NEG
68247: PUSH
68248: LD_INT 0
68250: PUSH
68251: EMPTY
68252: LIST
68253: LIST
68254: PUSH
68255: LD_INT 1
68257: NEG
68258: PUSH
68259: LD_INT 1
68261: NEG
68262: PUSH
68263: EMPTY
68264: LIST
68265: LIST
68266: PUSH
68267: LD_INT 1
68269: NEG
68270: PUSH
68271: LD_INT 2
68273: NEG
68274: PUSH
68275: EMPTY
68276: LIST
68277: LIST
68278: PUSH
68279: LD_INT 0
68281: PUSH
68282: LD_INT 2
68284: NEG
68285: PUSH
68286: EMPTY
68287: LIST
68288: LIST
68289: PUSH
68290: LD_INT 1
68292: PUSH
68293: LD_INT 1
68295: NEG
68296: PUSH
68297: EMPTY
68298: LIST
68299: LIST
68300: PUSH
68301: LD_INT 2
68303: PUSH
68304: LD_INT 0
68306: PUSH
68307: EMPTY
68308: LIST
68309: LIST
68310: PUSH
68311: LD_INT 2
68313: PUSH
68314: LD_INT 1
68316: PUSH
68317: EMPTY
68318: LIST
68319: LIST
68320: PUSH
68321: LD_INT 2
68323: PUSH
68324: LD_INT 2
68326: PUSH
68327: EMPTY
68328: LIST
68329: LIST
68330: PUSH
68331: LD_INT 1
68333: PUSH
68334: LD_INT 2
68336: PUSH
68337: EMPTY
68338: LIST
68339: LIST
68340: PUSH
68341: LD_INT 0
68343: PUSH
68344: LD_INT 2
68346: PUSH
68347: EMPTY
68348: LIST
68349: LIST
68350: PUSH
68351: LD_INT 1
68353: NEG
68354: PUSH
68355: LD_INT 1
68357: PUSH
68358: EMPTY
68359: LIST
68360: LIST
68361: PUSH
68362: LD_INT 2
68364: NEG
68365: PUSH
68366: LD_INT 0
68368: PUSH
68369: EMPTY
68370: LIST
68371: LIST
68372: PUSH
68373: LD_INT 2
68375: NEG
68376: PUSH
68377: LD_INT 1
68379: NEG
68380: PUSH
68381: EMPTY
68382: LIST
68383: LIST
68384: PUSH
68385: LD_INT 2
68387: NEG
68388: PUSH
68389: LD_INT 2
68391: NEG
68392: PUSH
68393: EMPTY
68394: LIST
68395: LIST
68396: PUSH
68397: EMPTY
68398: LIST
68399: LIST
68400: LIST
68401: LIST
68402: LIST
68403: LIST
68404: LIST
68405: LIST
68406: LIST
68407: LIST
68408: LIST
68409: LIST
68410: LIST
68411: LIST
68412: LIST
68413: LIST
68414: LIST
68415: LIST
68416: LIST
68417: ST_TO_ADDR
// DepotAr4 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
68418: LD_ADDR_VAR 0 21
68422: PUSH
68423: LD_INT 0
68425: PUSH
68426: LD_INT 0
68428: PUSH
68429: EMPTY
68430: LIST
68431: LIST
68432: PUSH
68433: LD_INT 0
68435: PUSH
68436: LD_INT 1
68438: NEG
68439: PUSH
68440: EMPTY
68441: LIST
68442: LIST
68443: PUSH
68444: LD_INT 1
68446: PUSH
68447: LD_INT 0
68449: PUSH
68450: EMPTY
68451: LIST
68452: LIST
68453: PUSH
68454: LD_INT 1
68456: PUSH
68457: LD_INT 1
68459: PUSH
68460: EMPTY
68461: LIST
68462: LIST
68463: PUSH
68464: LD_INT 0
68466: PUSH
68467: LD_INT 1
68469: PUSH
68470: EMPTY
68471: LIST
68472: LIST
68473: PUSH
68474: LD_INT 1
68476: NEG
68477: PUSH
68478: LD_INT 0
68480: PUSH
68481: EMPTY
68482: LIST
68483: LIST
68484: PUSH
68485: LD_INT 1
68487: NEG
68488: PUSH
68489: LD_INT 1
68491: NEG
68492: PUSH
68493: EMPTY
68494: LIST
68495: LIST
68496: PUSH
68497: LD_INT 1
68499: NEG
68500: PUSH
68501: LD_INT 2
68503: NEG
68504: PUSH
68505: EMPTY
68506: LIST
68507: LIST
68508: PUSH
68509: LD_INT 0
68511: PUSH
68512: LD_INT 2
68514: NEG
68515: PUSH
68516: EMPTY
68517: LIST
68518: LIST
68519: PUSH
68520: LD_INT 1
68522: PUSH
68523: LD_INT 1
68525: NEG
68526: PUSH
68527: EMPTY
68528: LIST
68529: LIST
68530: PUSH
68531: LD_INT 2
68533: PUSH
68534: LD_INT 0
68536: PUSH
68537: EMPTY
68538: LIST
68539: LIST
68540: PUSH
68541: LD_INT 2
68543: PUSH
68544: LD_INT 1
68546: PUSH
68547: EMPTY
68548: LIST
68549: LIST
68550: PUSH
68551: LD_INT 2
68553: PUSH
68554: LD_INT 2
68556: PUSH
68557: EMPTY
68558: LIST
68559: LIST
68560: PUSH
68561: LD_INT 1
68563: PUSH
68564: LD_INT 2
68566: PUSH
68567: EMPTY
68568: LIST
68569: LIST
68570: PUSH
68571: LD_INT 0
68573: PUSH
68574: LD_INT 2
68576: PUSH
68577: EMPTY
68578: LIST
68579: LIST
68580: PUSH
68581: LD_INT 1
68583: NEG
68584: PUSH
68585: LD_INT 1
68587: PUSH
68588: EMPTY
68589: LIST
68590: LIST
68591: PUSH
68592: LD_INT 2
68594: NEG
68595: PUSH
68596: LD_INT 0
68598: PUSH
68599: EMPTY
68600: LIST
68601: LIST
68602: PUSH
68603: LD_INT 2
68605: NEG
68606: PUSH
68607: LD_INT 1
68609: NEG
68610: PUSH
68611: EMPTY
68612: LIST
68613: LIST
68614: PUSH
68615: LD_INT 2
68617: NEG
68618: PUSH
68619: LD_INT 2
68621: NEG
68622: PUSH
68623: EMPTY
68624: LIST
68625: LIST
68626: PUSH
68627: EMPTY
68628: LIST
68629: LIST
68630: LIST
68631: LIST
68632: LIST
68633: LIST
68634: LIST
68635: LIST
68636: LIST
68637: LIST
68638: LIST
68639: LIST
68640: LIST
68641: LIST
68642: LIST
68643: LIST
68644: LIST
68645: LIST
68646: LIST
68647: ST_TO_ADDR
// DepotAr5 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
68648: LD_ADDR_VAR 0 22
68652: PUSH
68653: LD_INT 0
68655: PUSH
68656: LD_INT 0
68658: PUSH
68659: EMPTY
68660: LIST
68661: LIST
68662: PUSH
68663: LD_INT 0
68665: PUSH
68666: LD_INT 1
68668: NEG
68669: PUSH
68670: EMPTY
68671: LIST
68672: LIST
68673: PUSH
68674: LD_INT 1
68676: PUSH
68677: LD_INT 0
68679: PUSH
68680: EMPTY
68681: LIST
68682: LIST
68683: PUSH
68684: LD_INT 1
68686: PUSH
68687: LD_INT 1
68689: PUSH
68690: EMPTY
68691: LIST
68692: LIST
68693: PUSH
68694: LD_INT 0
68696: PUSH
68697: LD_INT 1
68699: PUSH
68700: EMPTY
68701: LIST
68702: LIST
68703: PUSH
68704: LD_INT 1
68706: NEG
68707: PUSH
68708: LD_INT 0
68710: PUSH
68711: EMPTY
68712: LIST
68713: LIST
68714: PUSH
68715: LD_INT 1
68717: NEG
68718: PUSH
68719: LD_INT 1
68721: NEG
68722: PUSH
68723: EMPTY
68724: LIST
68725: LIST
68726: PUSH
68727: LD_INT 1
68729: NEG
68730: PUSH
68731: LD_INT 2
68733: NEG
68734: PUSH
68735: EMPTY
68736: LIST
68737: LIST
68738: PUSH
68739: LD_INT 0
68741: PUSH
68742: LD_INT 2
68744: NEG
68745: PUSH
68746: EMPTY
68747: LIST
68748: LIST
68749: PUSH
68750: LD_INT 1
68752: PUSH
68753: LD_INT 1
68755: NEG
68756: PUSH
68757: EMPTY
68758: LIST
68759: LIST
68760: PUSH
68761: LD_INT 2
68763: PUSH
68764: LD_INT 0
68766: PUSH
68767: EMPTY
68768: LIST
68769: LIST
68770: PUSH
68771: LD_INT 2
68773: PUSH
68774: LD_INT 1
68776: PUSH
68777: EMPTY
68778: LIST
68779: LIST
68780: PUSH
68781: LD_INT 2
68783: PUSH
68784: LD_INT 2
68786: PUSH
68787: EMPTY
68788: LIST
68789: LIST
68790: PUSH
68791: LD_INT 1
68793: PUSH
68794: LD_INT 2
68796: PUSH
68797: EMPTY
68798: LIST
68799: LIST
68800: PUSH
68801: LD_INT 0
68803: PUSH
68804: LD_INT 2
68806: PUSH
68807: EMPTY
68808: LIST
68809: LIST
68810: PUSH
68811: LD_INT 1
68813: NEG
68814: PUSH
68815: LD_INT 1
68817: PUSH
68818: EMPTY
68819: LIST
68820: LIST
68821: PUSH
68822: LD_INT 2
68824: NEG
68825: PUSH
68826: LD_INT 0
68828: PUSH
68829: EMPTY
68830: LIST
68831: LIST
68832: PUSH
68833: LD_INT 2
68835: NEG
68836: PUSH
68837: LD_INT 1
68839: NEG
68840: PUSH
68841: EMPTY
68842: LIST
68843: LIST
68844: PUSH
68845: LD_INT 2
68847: NEG
68848: PUSH
68849: LD_INT 2
68851: NEG
68852: PUSH
68853: EMPTY
68854: LIST
68855: LIST
68856: PUSH
68857: EMPTY
68858: LIST
68859: LIST
68860: LIST
68861: LIST
68862: LIST
68863: LIST
68864: LIST
68865: LIST
68866: LIST
68867: LIST
68868: LIST
68869: LIST
68870: LIST
68871: LIST
68872: LIST
68873: LIST
68874: LIST
68875: LIST
68876: LIST
68877: ST_TO_ADDR
// DepotRu0 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ - 2 , - 3 ] , [ - 1 , - 3 ] , [ 1 , - 2 ] , [ 2 , - 1 ] ] ;
68878: LD_ADDR_VAR 0 23
68882: PUSH
68883: LD_INT 0
68885: PUSH
68886: LD_INT 0
68888: PUSH
68889: EMPTY
68890: LIST
68891: LIST
68892: PUSH
68893: LD_INT 0
68895: PUSH
68896: LD_INT 1
68898: NEG
68899: PUSH
68900: EMPTY
68901: LIST
68902: LIST
68903: PUSH
68904: LD_INT 1
68906: PUSH
68907: LD_INT 0
68909: PUSH
68910: EMPTY
68911: LIST
68912: LIST
68913: PUSH
68914: LD_INT 1
68916: PUSH
68917: LD_INT 1
68919: PUSH
68920: EMPTY
68921: LIST
68922: LIST
68923: PUSH
68924: LD_INT 0
68926: PUSH
68927: LD_INT 1
68929: PUSH
68930: EMPTY
68931: LIST
68932: LIST
68933: PUSH
68934: LD_INT 1
68936: NEG
68937: PUSH
68938: LD_INT 0
68940: PUSH
68941: EMPTY
68942: LIST
68943: LIST
68944: PUSH
68945: LD_INT 1
68947: NEG
68948: PUSH
68949: LD_INT 1
68951: NEG
68952: PUSH
68953: EMPTY
68954: LIST
68955: LIST
68956: PUSH
68957: LD_INT 1
68959: NEG
68960: PUSH
68961: LD_INT 2
68963: NEG
68964: PUSH
68965: EMPTY
68966: LIST
68967: LIST
68968: PUSH
68969: LD_INT 0
68971: PUSH
68972: LD_INT 2
68974: NEG
68975: PUSH
68976: EMPTY
68977: LIST
68978: LIST
68979: PUSH
68980: LD_INT 1
68982: PUSH
68983: LD_INT 1
68985: NEG
68986: PUSH
68987: EMPTY
68988: LIST
68989: LIST
68990: PUSH
68991: LD_INT 2
68993: PUSH
68994: LD_INT 0
68996: PUSH
68997: EMPTY
68998: LIST
68999: LIST
69000: PUSH
69001: LD_INT 2
69003: PUSH
69004: LD_INT 1
69006: PUSH
69007: EMPTY
69008: LIST
69009: LIST
69010: PUSH
69011: LD_INT 2
69013: PUSH
69014: LD_INT 2
69016: PUSH
69017: EMPTY
69018: LIST
69019: LIST
69020: PUSH
69021: LD_INT 1
69023: PUSH
69024: LD_INT 2
69026: PUSH
69027: EMPTY
69028: LIST
69029: LIST
69030: PUSH
69031: LD_INT 0
69033: PUSH
69034: LD_INT 2
69036: PUSH
69037: EMPTY
69038: LIST
69039: LIST
69040: PUSH
69041: LD_INT 1
69043: NEG
69044: PUSH
69045: LD_INT 1
69047: PUSH
69048: EMPTY
69049: LIST
69050: LIST
69051: PUSH
69052: LD_INT 2
69054: NEG
69055: PUSH
69056: LD_INT 0
69058: PUSH
69059: EMPTY
69060: LIST
69061: LIST
69062: PUSH
69063: LD_INT 2
69065: NEG
69066: PUSH
69067: LD_INT 1
69069: NEG
69070: PUSH
69071: EMPTY
69072: LIST
69073: LIST
69074: PUSH
69075: LD_INT 2
69077: NEG
69078: PUSH
69079: LD_INT 2
69081: NEG
69082: PUSH
69083: EMPTY
69084: LIST
69085: LIST
69086: PUSH
69087: LD_INT 2
69089: NEG
69090: PUSH
69091: LD_INT 3
69093: NEG
69094: PUSH
69095: EMPTY
69096: LIST
69097: LIST
69098: PUSH
69099: LD_INT 1
69101: NEG
69102: PUSH
69103: LD_INT 3
69105: NEG
69106: PUSH
69107: EMPTY
69108: LIST
69109: LIST
69110: PUSH
69111: LD_INT 1
69113: PUSH
69114: LD_INT 2
69116: NEG
69117: PUSH
69118: EMPTY
69119: LIST
69120: LIST
69121: PUSH
69122: LD_INT 2
69124: PUSH
69125: LD_INT 1
69127: NEG
69128: PUSH
69129: EMPTY
69130: LIST
69131: LIST
69132: PUSH
69133: EMPTY
69134: LIST
69135: LIST
69136: LIST
69137: LIST
69138: LIST
69139: LIST
69140: LIST
69141: LIST
69142: LIST
69143: LIST
69144: LIST
69145: LIST
69146: LIST
69147: LIST
69148: LIST
69149: LIST
69150: LIST
69151: LIST
69152: LIST
69153: LIST
69154: LIST
69155: LIST
69156: LIST
69157: ST_TO_ADDR
// DepotRu1 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ 1 , - 2 ] , [ 2 , - 1 ] , [ 3 , 1 ] , [ 3 , 2 ] ] ;
69158: LD_ADDR_VAR 0 24
69162: PUSH
69163: LD_INT 0
69165: PUSH
69166: LD_INT 0
69168: PUSH
69169: EMPTY
69170: LIST
69171: LIST
69172: PUSH
69173: LD_INT 0
69175: PUSH
69176: LD_INT 1
69178: NEG
69179: PUSH
69180: EMPTY
69181: LIST
69182: LIST
69183: PUSH
69184: LD_INT 1
69186: PUSH
69187: LD_INT 0
69189: PUSH
69190: EMPTY
69191: LIST
69192: LIST
69193: PUSH
69194: LD_INT 1
69196: PUSH
69197: LD_INT 1
69199: PUSH
69200: EMPTY
69201: LIST
69202: LIST
69203: PUSH
69204: LD_INT 0
69206: PUSH
69207: LD_INT 1
69209: PUSH
69210: EMPTY
69211: LIST
69212: LIST
69213: PUSH
69214: LD_INT 1
69216: NEG
69217: PUSH
69218: LD_INT 0
69220: PUSH
69221: EMPTY
69222: LIST
69223: LIST
69224: PUSH
69225: LD_INT 1
69227: NEG
69228: PUSH
69229: LD_INT 1
69231: NEG
69232: PUSH
69233: EMPTY
69234: LIST
69235: LIST
69236: PUSH
69237: LD_INT 1
69239: NEG
69240: PUSH
69241: LD_INT 2
69243: NEG
69244: PUSH
69245: EMPTY
69246: LIST
69247: LIST
69248: PUSH
69249: LD_INT 0
69251: PUSH
69252: LD_INT 2
69254: NEG
69255: PUSH
69256: EMPTY
69257: LIST
69258: LIST
69259: PUSH
69260: LD_INT 1
69262: PUSH
69263: LD_INT 1
69265: NEG
69266: PUSH
69267: EMPTY
69268: LIST
69269: LIST
69270: PUSH
69271: LD_INT 2
69273: PUSH
69274: LD_INT 0
69276: PUSH
69277: EMPTY
69278: LIST
69279: LIST
69280: PUSH
69281: LD_INT 2
69283: PUSH
69284: LD_INT 1
69286: PUSH
69287: EMPTY
69288: LIST
69289: LIST
69290: PUSH
69291: LD_INT 2
69293: PUSH
69294: LD_INT 2
69296: PUSH
69297: EMPTY
69298: LIST
69299: LIST
69300: PUSH
69301: LD_INT 1
69303: PUSH
69304: LD_INT 2
69306: PUSH
69307: EMPTY
69308: LIST
69309: LIST
69310: PUSH
69311: LD_INT 0
69313: PUSH
69314: LD_INT 2
69316: PUSH
69317: EMPTY
69318: LIST
69319: LIST
69320: PUSH
69321: LD_INT 1
69323: NEG
69324: PUSH
69325: LD_INT 1
69327: PUSH
69328: EMPTY
69329: LIST
69330: LIST
69331: PUSH
69332: LD_INT 2
69334: NEG
69335: PUSH
69336: LD_INT 0
69338: PUSH
69339: EMPTY
69340: LIST
69341: LIST
69342: PUSH
69343: LD_INT 2
69345: NEG
69346: PUSH
69347: LD_INT 1
69349: NEG
69350: PUSH
69351: EMPTY
69352: LIST
69353: LIST
69354: PUSH
69355: LD_INT 2
69357: NEG
69358: PUSH
69359: LD_INT 2
69361: NEG
69362: PUSH
69363: EMPTY
69364: LIST
69365: LIST
69366: PUSH
69367: LD_INT 1
69369: PUSH
69370: LD_INT 2
69372: NEG
69373: PUSH
69374: EMPTY
69375: LIST
69376: LIST
69377: PUSH
69378: LD_INT 2
69380: PUSH
69381: LD_INT 1
69383: NEG
69384: PUSH
69385: EMPTY
69386: LIST
69387: LIST
69388: PUSH
69389: LD_INT 3
69391: PUSH
69392: LD_INT 1
69394: PUSH
69395: EMPTY
69396: LIST
69397: LIST
69398: PUSH
69399: LD_INT 3
69401: PUSH
69402: LD_INT 2
69404: PUSH
69405: EMPTY
69406: LIST
69407: LIST
69408: PUSH
69409: EMPTY
69410: LIST
69411: LIST
69412: LIST
69413: LIST
69414: LIST
69415: LIST
69416: LIST
69417: LIST
69418: LIST
69419: LIST
69420: LIST
69421: LIST
69422: LIST
69423: LIST
69424: LIST
69425: LIST
69426: LIST
69427: LIST
69428: LIST
69429: LIST
69430: LIST
69431: LIST
69432: LIST
69433: ST_TO_ADDR
// DepotRu2 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ 3 , 1 ] , [ 3 , 2 ] , [ 2 , 3 ] , [ 1 , 3 ] ] ;
69434: LD_ADDR_VAR 0 25
69438: PUSH
69439: LD_INT 0
69441: PUSH
69442: LD_INT 0
69444: PUSH
69445: EMPTY
69446: LIST
69447: LIST
69448: PUSH
69449: LD_INT 0
69451: PUSH
69452: LD_INT 1
69454: NEG
69455: PUSH
69456: EMPTY
69457: LIST
69458: LIST
69459: PUSH
69460: LD_INT 1
69462: PUSH
69463: LD_INT 0
69465: PUSH
69466: EMPTY
69467: LIST
69468: LIST
69469: PUSH
69470: LD_INT 1
69472: PUSH
69473: LD_INT 1
69475: PUSH
69476: EMPTY
69477: LIST
69478: LIST
69479: PUSH
69480: LD_INT 0
69482: PUSH
69483: LD_INT 1
69485: PUSH
69486: EMPTY
69487: LIST
69488: LIST
69489: PUSH
69490: LD_INT 1
69492: NEG
69493: PUSH
69494: LD_INT 0
69496: PUSH
69497: EMPTY
69498: LIST
69499: LIST
69500: PUSH
69501: LD_INT 1
69503: NEG
69504: PUSH
69505: LD_INT 1
69507: NEG
69508: PUSH
69509: EMPTY
69510: LIST
69511: LIST
69512: PUSH
69513: LD_INT 1
69515: NEG
69516: PUSH
69517: LD_INT 2
69519: NEG
69520: PUSH
69521: EMPTY
69522: LIST
69523: LIST
69524: PUSH
69525: LD_INT 0
69527: PUSH
69528: LD_INT 2
69530: NEG
69531: PUSH
69532: EMPTY
69533: LIST
69534: LIST
69535: PUSH
69536: LD_INT 1
69538: PUSH
69539: LD_INT 1
69541: NEG
69542: PUSH
69543: EMPTY
69544: LIST
69545: LIST
69546: PUSH
69547: LD_INT 2
69549: PUSH
69550: LD_INT 0
69552: PUSH
69553: EMPTY
69554: LIST
69555: LIST
69556: PUSH
69557: LD_INT 2
69559: PUSH
69560: LD_INT 1
69562: PUSH
69563: EMPTY
69564: LIST
69565: LIST
69566: PUSH
69567: LD_INT 2
69569: PUSH
69570: LD_INT 2
69572: PUSH
69573: EMPTY
69574: LIST
69575: LIST
69576: PUSH
69577: LD_INT 1
69579: PUSH
69580: LD_INT 2
69582: PUSH
69583: EMPTY
69584: LIST
69585: LIST
69586: PUSH
69587: LD_INT 0
69589: PUSH
69590: LD_INT 2
69592: PUSH
69593: EMPTY
69594: LIST
69595: LIST
69596: PUSH
69597: LD_INT 1
69599: NEG
69600: PUSH
69601: LD_INT 1
69603: PUSH
69604: EMPTY
69605: LIST
69606: LIST
69607: PUSH
69608: LD_INT 2
69610: NEG
69611: PUSH
69612: LD_INT 0
69614: PUSH
69615: EMPTY
69616: LIST
69617: LIST
69618: PUSH
69619: LD_INT 2
69621: NEG
69622: PUSH
69623: LD_INT 1
69625: NEG
69626: PUSH
69627: EMPTY
69628: LIST
69629: LIST
69630: PUSH
69631: LD_INT 2
69633: NEG
69634: PUSH
69635: LD_INT 2
69637: NEG
69638: PUSH
69639: EMPTY
69640: LIST
69641: LIST
69642: PUSH
69643: LD_INT 3
69645: PUSH
69646: LD_INT 1
69648: PUSH
69649: EMPTY
69650: LIST
69651: LIST
69652: PUSH
69653: LD_INT 3
69655: PUSH
69656: LD_INT 2
69658: PUSH
69659: EMPTY
69660: LIST
69661: LIST
69662: PUSH
69663: LD_INT 2
69665: PUSH
69666: LD_INT 3
69668: PUSH
69669: EMPTY
69670: LIST
69671: LIST
69672: PUSH
69673: LD_INT 1
69675: PUSH
69676: LD_INT 3
69678: PUSH
69679: EMPTY
69680: LIST
69681: LIST
69682: PUSH
69683: EMPTY
69684: LIST
69685: LIST
69686: LIST
69687: LIST
69688: LIST
69689: LIST
69690: LIST
69691: LIST
69692: LIST
69693: LIST
69694: LIST
69695: LIST
69696: LIST
69697: LIST
69698: LIST
69699: LIST
69700: LIST
69701: LIST
69702: LIST
69703: LIST
69704: LIST
69705: LIST
69706: LIST
69707: ST_TO_ADDR
// DepotRu3 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ 2 , 3 ] , [ 1 , 3 ] , [ - 1 , 2 ] , [ - 2 , 1 ] ] ;
69708: LD_ADDR_VAR 0 26
69712: PUSH
69713: LD_INT 0
69715: PUSH
69716: LD_INT 0
69718: PUSH
69719: EMPTY
69720: LIST
69721: LIST
69722: PUSH
69723: LD_INT 0
69725: PUSH
69726: LD_INT 1
69728: NEG
69729: PUSH
69730: EMPTY
69731: LIST
69732: LIST
69733: PUSH
69734: LD_INT 1
69736: PUSH
69737: LD_INT 0
69739: PUSH
69740: EMPTY
69741: LIST
69742: LIST
69743: PUSH
69744: LD_INT 1
69746: PUSH
69747: LD_INT 1
69749: PUSH
69750: EMPTY
69751: LIST
69752: LIST
69753: PUSH
69754: LD_INT 0
69756: PUSH
69757: LD_INT 1
69759: PUSH
69760: EMPTY
69761: LIST
69762: LIST
69763: PUSH
69764: LD_INT 1
69766: NEG
69767: PUSH
69768: LD_INT 0
69770: PUSH
69771: EMPTY
69772: LIST
69773: LIST
69774: PUSH
69775: LD_INT 1
69777: NEG
69778: PUSH
69779: LD_INT 1
69781: NEG
69782: PUSH
69783: EMPTY
69784: LIST
69785: LIST
69786: PUSH
69787: LD_INT 1
69789: NEG
69790: PUSH
69791: LD_INT 2
69793: NEG
69794: PUSH
69795: EMPTY
69796: LIST
69797: LIST
69798: PUSH
69799: LD_INT 0
69801: PUSH
69802: LD_INT 2
69804: NEG
69805: PUSH
69806: EMPTY
69807: LIST
69808: LIST
69809: PUSH
69810: LD_INT 1
69812: PUSH
69813: LD_INT 1
69815: NEG
69816: PUSH
69817: EMPTY
69818: LIST
69819: LIST
69820: PUSH
69821: LD_INT 2
69823: PUSH
69824: LD_INT 0
69826: PUSH
69827: EMPTY
69828: LIST
69829: LIST
69830: PUSH
69831: LD_INT 2
69833: PUSH
69834: LD_INT 1
69836: PUSH
69837: EMPTY
69838: LIST
69839: LIST
69840: PUSH
69841: LD_INT 2
69843: PUSH
69844: LD_INT 2
69846: PUSH
69847: EMPTY
69848: LIST
69849: LIST
69850: PUSH
69851: LD_INT 1
69853: PUSH
69854: LD_INT 2
69856: PUSH
69857: EMPTY
69858: LIST
69859: LIST
69860: PUSH
69861: LD_INT 0
69863: PUSH
69864: LD_INT 2
69866: PUSH
69867: EMPTY
69868: LIST
69869: LIST
69870: PUSH
69871: LD_INT 1
69873: NEG
69874: PUSH
69875: LD_INT 1
69877: PUSH
69878: EMPTY
69879: LIST
69880: LIST
69881: PUSH
69882: LD_INT 2
69884: NEG
69885: PUSH
69886: LD_INT 0
69888: PUSH
69889: EMPTY
69890: LIST
69891: LIST
69892: PUSH
69893: LD_INT 2
69895: NEG
69896: PUSH
69897: LD_INT 1
69899: NEG
69900: PUSH
69901: EMPTY
69902: LIST
69903: LIST
69904: PUSH
69905: LD_INT 2
69907: NEG
69908: PUSH
69909: LD_INT 2
69911: NEG
69912: PUSH
69913: EMPTY
69914: LIST
69915: LIST
69916: PUSH
69917: LD_INT 2
69919: PUSH
69920: LD_INT 3
69922: PUSH
69923: EMPTY
69924: LIST
69925: LIST
69926: PUSH
69927: LD_INT 1
69929: PUSH
69930: LD_INT 3
69932: PUSH
69933: EMPTY
69934: LIST
69935: LIST
69936: PUSH
69937: LD_INT 1
69939: NEG
69940: PUSH
69941: LD_INT 2
69943: PUSH
69944: EMPTY
69945: LIST
69946: LIST
69947: PUSH
69948: LD_INT 2
69950: NEG
69951: PUSH
69952: LD_INT 1
69954: PUSH
69955: EMPTY
69956: LIST
69957: LIST
69958: PUSH
69959: EMPTY
69960: LIST
69961: LIST
69962: LIST
69963: LIST
69964: LIST
69965: LIST
69966: LIST
69967: LIST
69968: LIST
69969: LIST
69970: LIST
69971: LIST
69972: LIST
69973: LIST
69974: LIST
69975: LIST
69976: LIST
69977: LIST
69978: LIST
69979: LIST
69980: LIST
69981: LIST
69982: LIST
69983: ST_TO_ADDR
// DepotRu4 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ - 1 , 2 ] , [ - 2 , 1 ] , [ - 3 , - 1 ] , [ - 3 , - 2 ] ] ;
69984: LD_ADDR_VAR 0 27
69988: PUSH
69989: LD_INT 0
69991: PUSH
69992: LD_INT 0
69994: PUSH
69995: EMPTY
69996: LIST
69997: LIST
69998: PUSH
69999: LD_INT 0
70001: PUSH
70002: LD_INT 1
70004: NEG
70005: PUSH
70006: EMPTY
70007: LIST
70008: LIST
70009: PUSH
70010: LD_INT 1
70012: PUSH
70013: LD_INT 0
70015: PUSH
70016: EMPTY
70017: LIST
70018: LIST
70019: PUSH
70020: LD_INT 1
70022: PUSH
70023: LD_INT 1
70025: PUSH
70026: EMPTY
70027: LIST
70028: LIST
70029: PUSH
70030: LD_INT 0
70032: PUSH
70033: LD_INT 1
70035: PUSH
70036: EMPTY
70037: LIST
70038: LIST
70039: PUSH
70040: LD_INT 1
70042: NEG
70043: PUSH
70044: LD_INT 0
70046: PUSH
70047: EMPTY
70048: LIST
70049: LIST
70050: PUSH
70051: LD_INT 1
70053: NEG
70054: PUSH
70055: LD_INT 1
70057: NEG
70058: PUSH
70059: EMPTY
70060: LIST
70061: LIST
70062: PUSH
70063: LD_INT 1
70065: NEG
70066: PUSH
70067: LD_INT 2
70069: NEG
70070: PUSH
70071: EMPTY
70072: LIST
70073: LIST
70074: PUSH
70075: LD_INT 0
70077: PUSH
70078: LD_INT 2
70080: NEG
70081: PUSH
70082: EMPTY
70083: LIST
70084: LIST
70085: PUSH
70086: LD_INT 1
70088: PUSH
70089: LD_INT 1
70091: NEG
70092: PUSH
70093: EMPTY
70094: LIST
70095: LIST
70096: PUSH
70097: LD_INT 2
70099: PUSH
70100: LD_INT 0
70102: PUSH
70103: EMPTY
70104: LIST
70105: LIST
70106: PUSH
70107: LD_INT 2
70109: PUSH
70110: LD_INT 1
70112: PUSH
70113: EMPTY
70114: LIST
70115: LIST
70116: PUSH
70117: LD_INT 2
70119: PUSH
70120: LD_INT 2
70122: PUSH
70123: EMPTY
70124: LIST
70125: LIST
70126: PUSH
70127: LD_INT 1
70129: PUSH
70130: LD_INT 2
70132: PUSH
70133: EMPTY
70134: LIST
70135: LIST
70136: PUSH
70137: LD_INT 0
70139: PUSH
70140: LD_INT 2
70142: PUSH
70143: EMPTY
70144: LIST
70145: LIST
70146: PUSH
70147: LD_INT 1
70149: NEG
70150: PUSH
70151: LD_INT 1
70153: PUSH
70154: EMPTY
70155: LIST
70156: LIST
70157: PUSH
70158: LD_INT 2
70160: NEG
70161: PUSH
70162: LD_INT 0
70164: PUSH
70165: EMPTY
70166: LIST
70167: LIST
70168: PUSH
70169: LD_INT 2
70171: NEG
70172: PUSH
70173: LD_INT 1
70175: NEG
70176: PUSH
70177: EMPTY
70178: LIST
70179: LIST
70180: PUSH
70181: LD_INT 2
70183: NEG
70184: PUSH
70185: LD_INT 2
70187: NEG
70188: PUSH
70189: EMPTY
70190: LIST
70191: LIST
70192: PUSH
70193: LD_INT 1
70195: NEG
70196: PUSH
70197: LD_INT 2
70199: PUSH
70200: EMPTY
70201: LIST
70202: LIST
70203: PUSH
70204: LD_INT 2
70206: NEG
70207: PUSH
70208: LD_INT 1
70210: PUSH
70211: EMPTY
70212: LIST
70213: LIST
70214: PUSH
70215: LD_INT 3
70217: NEG
70218: PUSH
70219: LD_INT 1
70221: NEG
70222: PUSH
70223: EMPTY
70224: LIST
70225: LIST
70226: PUSH
70227: LD_INT 3
70229: NEG
70230: PUSH
70231: LD_INT 2
70233: NEG
70234: PUSH
70235: EMPTY
70236: LIST
70237: LIST
70238: PUSH
70239: EMPTY
70240: LIST
70241: LIST
70242: LIST
70243: LIST
70244: LIST
70245: LIST
70246: LIST
70247: LIST
70248: LIST
70249: LIST
70250: LIST
70251: LIST
70252: LIST
70253: LIST
70254: LIST
70255: LIST
70256: LIST
70257: LIST
70258: LIST
70259: LIST
70260: LIST
70261: LIST
70262: LIST
70263: ST_TO_ADDR
// DepotRu5 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ - 2 , - 3 ] , [ - 1 , - 3 ] , [ - 3 , - 1 ] , [ - 3 , - 2 ] ] ;
70264: LD_ADDR_VAR 0 28
70268: PUSH
70269: LD_INT 0
70271: PUSH
70272: LD_INT 0
70274: PUSH
70275: EMPTY
70276: LIST
70277: LIST
70278: PUSH
70279: LD_INT 0
70281: PUSH
70282: LD_INT 1
70284: NEG
70285: PUSH
70286: EMPTY
70287: LIST
70288: LIST
70289: PUSH
70290: LD_INT 1
70292: PUSH
70293: LD_INT 0
70295: PUSH
70296: EMPTY
70297: LIST
70298: LIST
70299: PUSH
70300: LD_INT 1
70302: PUSH
70303: LD_INT 1
70305: PUSH
70306: EMPTY
70307: LIST
70308: LIST
70309: PUSH
70310: LD_INT 0
70312: PUSH
70313: LD_INT 1
70315: PUSH
70316: EMPTY
70317: LIST
70318: LIST
70319: PUSH
70320: LD_INT 1
70322: NEG
70323: PUSH
70324: LD_INT 0
70326: PUSH
70327: EMPTY
70328: LIST
70329: LIST
70330: PUSH
70331: LD_INT 1
70333: NEG
70334: PUSH
70335: LD_INT 1
70337: NEG
70338: PUSH
70339: EMPTY
70340: LIST
70341: LIST
70342: PUSH
70343: LD_INT 1
70345: NEG
70346: PUSH
70347: LD_INT 2
70349: NEG
70350: PUSH
70351: EMPTY
70352: LIST
70353: LIST
70354: PUSH
70355: LD_INT 0
70357: PUSH
70358: LD_INT 2
70360: NEG
70361: PUSH
70362: EMPTY
70363: LIST
70364: LIST
70365: PUSH
70366: LD_INT 1
70368: PUSH
70369: LD_INT 1
70371: NEG
70372: PUSH
70373: EMPTY
70374: LIST
70375: LIST
70376: PUSH
70377: LD_INT 2
70379: PUSH
70380: LD_INT 0
70382: PUSH
70383: EMPTY
70384: LIST
70385: LIST
70386: PUSH
70387: LD_INT 2
70389: PUSH
70390: LD_INT 1
70392: PUSH
70393: EMPTY
70394: LIST
70395: LIST
70396: PUSH
70397: LD_INT 2
70399: PUSH
70400: LD_INT 2
70402: PUSH
70403: EMPTY
70404: LIST
70405: LIST
70406: PUSH
70407: LD_INT 1
70409: PUSH
70410: LD_INT 2
70412: PUSH
70413: EMPTY
70414: LIST
70415: LIST
70416: PUSH
70417: LD_INT 0
70419: PUSH
70420: LD_INT 2
70422: PUSH
70423: EMPTY
70424: LIST
70425: LIST
70426: PUSH
70427: LD_INT 1
70429: NEG
70430: PUSH
70431: LD_INT 1
70433: PUSH
70434: EMPTY
70435: LIST
70436: LIST
70437: PUSH
70438: LD_INT 2
70440: NEG
70441: PUSH
70442: LD_INT 0
70444: PUSH
70445: EMPTY
70446: LIST
70447: LIST
70448: PUSH
70449: LD_INT 2
70451: NEG
70452: PUSH
70453: LD_INT 1
70455: NEG
70456: PUSH
70457: EMPTY
70458: LIST
70459: LIST
70460: PUSH
70461: LD_INT 2
70463: NEG
70464: PUSH
70465: LD_INT 2
70467: NEG
70468: PUSH
70469: EMPTY
70470: LIST
70471: LIST
70472: PUSH
70473: LD_INT 2
70475: NEG
70476: PUSH
70477: LD_INT 3
70479: NEG
70480: PUSH
70481: EMPTY
70482: LIST
70483: LIST
70484: PUSH
70485: LD_INT 1
70487: NEG
70488: PUSH
70489: LD_INT 3
70491: NEG
70492: PUSH
70493: EMPTY
70494: LIST
70495: LIST
70496: PUSH
70497: LD_INT 3
70499: NEG
70500: PUSH
70501: LD_INT 1
70503: NEG
70504: PUSH
70505: EMPTY
70506: LIST
70507: LIST
70508: PUSH
70509: LD_INT 3
70511: NEG
70512: PUSH
70513: LD_INT 2
70515: NEG
70516: PUSH
70517: EMPTY
70518: LIST
70519: LIST
70520: PUSH
70521: EMPTY
70522: LIST
70523: LIST
70524: LIST
70525: LIST
70526: LIST
70527: LIST
70528: LIST
70529: LIST
70530: LIST
70531: LIST
70532: LIST
70533: LIST
70534: LIST
70535: LIST
70536: LIST
70537: LIST
70538: LIST
70539: LIST
70540: LIST
70541: LIST
70542: LIST
70543: LIST
70544: LIST
70545: ST_TO_ADDR
// Factory0 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ - 2 , - 3 ] , [ 2 , - 1 ] , [ 3 , 1 ] , [ 1 , 3 ] , [ - 1 , 2 ] , [ - 3 , - 2 ] ] ;
70546: LD_ADDR_VAR 0 29
70550: PUSH
70551: LD_INT 0
70553: PUSH
70554: LD_INT 0
70556: PUSH
70557: EMPTY
70558: LIST
70559: LIST
70560: PUSH
70561: LD_INT 0
70563: PUSH
70564: LD_INT 1
70566: NEG
70567: PUSH
70568: EMPTY
70569: LIST
70570: LIST
70571: PUSH
70572: LD_INT 1
70574: PUSH
70575: LD_INT 0
70577: PUSH
70578: EMPTY
70579: LIST
70580: LIST
70581: PUSH
70582: LD_INT 1
70584: PUSH
70585: LD_INT 1
70587: PUSH
70588: EMPTY
70589: LIST
70590: LIST
70591: PUSH
70592: LD_INT 0
70594: PUSH
70595: LD_INT 1
70597: PUSH
70598: EMPTY
70599: LIST
70600: LIST
70601: PUSH
70602: LD_INT 1
70604: NEG
70605: PUSH
70606: LD_INT 0
70608: PUSH
70609: EMPTY
70610: LIST
70611: LIST
70612: PUSH
70613: LD_INT 1
70615: NEG
70616: PUSH
70617: LD_INT 1
70619: NEG
70620: PUSH
70621: EMPTY
70622: LIST
70623: LIST
70624: PUSH
70625: LD_INT 1
70627: NEG
70628: PUSH
70629: LD_INT 2
70631: NEG
70632: PUSH
70633: EMPTY
70634: LIST
70635: LIST
70636: PUSH
70637: LD_INT 0
70639: PUSH
70640: LD_INT 2
70642: NEG
70643: PUSH
70644: EMPTY
70645: LIST
70646: LIST
70647: PUSH
70648: LD_INT 1
70650: PUSH
70651: LD_INT 1
70653: NEG
70654: PUSH
70655: EMPTY
70656: LIST
70657: LIST
70658: PUSH
70659: LD_INT 2
70661: PUSH
70662: LD_INT 0
70664: PUSH
70665: EMPTY
70666: LIST
70667: LIST
70668: PUSH
70669: LD_INT 2
70671: PUSH
70672: LD_INT 1
70674: PUSH
70675: EMPTY
70676: LIST
70677: LIST
70678: PUSH
70679: LD_INT 1
70681: PUSH
70682: LD_INT 2
70684: PUSH
70685: EMPTY
70686: LIST
70687: LIST
70688: PUSH
70689: LD_INT 0
70691: PUSH
70692: LD_INT 2
70694: PUSH
70695: EMPTY
70696: LIST
70697: LIST
70698: PUSH
70699: LD_INT 1
70701: NEG
70702: PUSH
70703: LD_INT 1
70705: PUSH
70706: EMPTY
70707: LIST
70708: LIST
70709: PUSH
70710: LD_INT 2
70712: NEG
70713: PUSH
70714: LD_INT 1
70716: NEG
70717: PUSH
70718: EMPTY
70719: LIST
70720: LIST
70721: PUSH
70722: LD_INT 2
70724: NEG
70725: PUSH
70726: LD_INT 2
70728: NEG
70729: PUSH
70730: EMPTY
70731: LIST
70732: LIST
70733: PUSH
70734: LD_INT 2
70736: NEG
70737: PUSH
70738: LD_INT 3
70740: NEG
70741: PUSH
70742: EMPTY
70743: LIST
70744: LIST
70745: PUSH
70746: LD_INT 2
70748: PUSH
70749: LD_INT 1
70751: NEG
70752: PUSH
70753: EMPTY
70754: LIST
70755: LIST
70756: PUSH
70757: LD_INT 3
70759: PUSH
70760: LD_INT 1
70762: PUSH
70763: EMPTY
70764: LIST
70765: LIST
70766: PUSH
70767: LD_INT 1
70769: PUSH
70770: LD_INT 3
70772: PUSH
70773: EMPTY
70774: LIST
70775: LIST
70776: PUSH
70777: LD_INT 1
70779: NEG
70780: PUSH
70781: LD_INT 2
70783: PUSH
70784: EMPTY
70785: LIST
70786: LIST
70787: PUSH
70788: LD_INT 3
70790: NEG
70791: PUSH
70792: LD_INT 2
70794: NEG
70795: PUSH
70796: EMPTY
70797: LIST
70798: LIST
70799: PUSH
70800: EMPTY
70801: LIST
70802: LIST
70803: LIST
70804: LIST
70805: LIST
70806: LIST
70807: LIST
70808: LIST
70809: LIST
70810: LIST
70811: LIST
70812: LIST
70813: LIST
70814: LIST
70815: LIST
70816: LIST
70817: LIST
70818: LIST
70819: LIST
70820: LIST
70821: LIST
70822: LIST
70823: LIST
70824: ST_TO_ADDR
// Factory1 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 1 , - 3 ] , [ 1 , - 2 ] , [ 3 , 2 ] , [ 2 , 3 ] , [ - 2 , 1 ] , [ - 3 , - 1 ] ] ;
70825: LD_ADDR_VAR 0 30
70829: PUSH
70830: LD_INT 0
70832: PUSH
70833: LD_INT 0
70835: PUSH
70836: EMPTY
70837: LIST
70838: LIST
70839: PUSH
70840: LD_INT 0
70842: PUSH
70843: LD_INT 1
70845: NEG
70846: PUSH
70847: EMPTY
70848: LIST
70849: LIST
70850: PUSH
70851: LD_INT 1
70853: PUSH
70854: LD_INT 0
70856: PUSH
70857: EMPTY
70858: LIST
70859: LIST
70860: PUSH
70861: LD_INT 1
70863: PUSH
70864: LD_INT 1
70866: PUSH
70867: EMPTY
70868: LIST
70869: LIST
70870: PUSH
70871: LD_INT 0
70873: PUSH
70874: LD_INT 1
70876: PUSH
70877: EMPTY
70878: LIST
70879: LIST
70880: PUSH
70881: LD_INT 1
70883: NEG
70884: PUSH
70885: LD_INT 0
70887: PUSH
70888: EMPTY
70889: LIST
70890: LIST
70891: PUSH
70892: LD_INT 1
70894: NEG
70895: PUSH
70896: LD_INT 1
70898: NEG
70899: PUSH
70900: EMPTY
70901: LIST
70902: LIST
70903: PUSH
70904: LD_INT 1
70906: NEG
70907: PUSH
70908: LD_INT 2
70910: NEG
70911: PUSH
70912: EMPTY
70913: LIST
70914: LIST
70915: PUSH
70916: LD_INT 0
70918: PUSH
70919: LD_INT 2
70921: NEG
70922: PUSH
70923: EMPTY
70924: LIST
70925: LIST
70926: PUSH
70927: LD_INT 1
70929: PUSH
70930: LD_INT 1
70932: NEG
70933: PUSH
70934: EMPTY
70935: LIST
70936: LIST
70937: PUSH
70938: LD_INT 2
70940: PUSH
70941: LD_INT 0
70943: PUSH
70944: EMPTY
70945: LIST
70946: LIST
70947: PUSH
70948: LD_INT 2
70950: PUSH
70951: LD_INT 1
70953: PUSH
70954: EMPTY
70955: LIST
70956: LIST
70957: PUSH
70958: LD_INT 2
70960: PUSH
70961: LD_INT 2
70963: PUSH
70964: EMPTY
70965: LIST
70966: LIST
70967: PUSH
70968: LD_INT 1
70970: PUSH
70971: LD_INT 2
70973: PUSH
70974: EMPTY
70975: LIST
70976: LIST
70977: PUSH
70978: LD_INT 1
70980: NEG
70981: PUSH
70982: LD_INT 1
70984: PUSH
70985: EMPTY
70986: LIST
70987: LIST
70988: PUSH
70989: LD_INT 2
70991: NEG
70992: PUSH
70993: LD_INT 0
70995: PUSH
70996: EMPTY
70997: LIST
70998: LIST
70999: PUSH
71000: LD_INT 2
71002: NEG
71003: PUSH
71004: LD_INT 1
71006: NEG
71007: PUSH
71008: EMPTY
71009: LIST
71010: LIST
71011: PUSH
71012: LD_INT 1
71014: NEG
71015: PUSH
71016: LD_INT 3
71018: NEG
71019: PUSH
71020: EMPTY
71021: LIST
71022: LIST
71023: PUSH
71024: LD_INT 1
71026: PUSH
71027: LD_INT 2
71029: NEG
71030: PUSH
71031: EMPTY
71032: LIST
71033: LIST
71034: PUSH
71035: LD_INT 3
71037: PUSH
71038: LD_INT 2
71040: PUSH
71041: EMPTY
71042: LIST
71043: LIST
71044: PUSH
71045: LD_INT 2
71047: PUSH
71048: LD_INT 3
71050: PUSH
71051: EMPTY
71052: LIST
71053: LIST
71054: PUSH
71055: LD_INT 2
71057: NEG
71058: PUSH
71059: LD_INT 1
71061: PUSH
71062: EMPTY
71063: LIST
71064: LIST
71065: PUSH
71066: LD_INT 3
71068: NEG
71069: PUSH
71070: LD_INT 1
71072: NEG
71073: PUSH
71074: EMPTY
71075: LIST
71076: LIST
71077: PUSH
71078: EMPTY
71079: LIST
71080: LIST
71081: LIST
71082: LIST
71083: LIST
71084: LIST
71085: LIST
71086: LIST
71087: LIST
71088: LIST
71089: LIST
71090: LIST
71091: LIST
71092: LIST
71093: LIST
71094: LIST
71095: LIST
71096: LIST
71097: LIST
71098: LIST
71099: LIST
71100: LIST
71101: LIST
71102: ST_TO_ADDR
// Factory2 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ - 2 , - 3 ] , [ 2 , - 1 ] , [ 3 , 1 ] , [ 1 , 3 ] , [ - 1 , 2 ] , [ - 3 , - 2 ] ] ;
71103: LD_ADDR_VAR 0 31
71107: PUSH
71108: LD_INT 0
71110: PUSH
71111: LD_INT 0
71113: PUSH
71114: EMPTY
71115: LIST
71116: LIST
71117: PUSH
71118: LD_INT 0
71120: PUSH
71121: LD_INT 1
71123: NEG
71124: PUSH
71125: EMPTY
71126: LIST
71127: LIST
71128: PUSH
71129: LD_INT 1
71131: PUSH
71132: LD_INT 0
71134: PUSH
71135: EMPTY
71136: LIST
71137: LIST
71138: PUSH
71139: LD_INT 1
71141: PUSH
71142: LD_INT 1
71144: PUSH
71145: EMPTY
71146: LIST
71147: LIST
71148: PUSH
71149: LD_INT 0
71151: PUSH
71152: LD_INT 1
71154: PUSH
71155: EMPTY
71156: LIST
71157: LIST
71158: PUSH
71159: LD_INT 1
71161: NEG
71162: PUSH
71163: LD_INT 0
71165: PUSH
71166: EMPTY
71167: LIST
71168: LIST
71169: PUSH
71170: LD_INT 1
71172: NEG
71173: PUSH
71174: LD_INT 1
71176: NEG
71177: PUSH
71178: EMPTY
71179: LIST
71180: LIST
71181: PUSH
71182: LD_INT 1
71184: NEG
71185: PUSH
71186: LD_INT 2
71188: NEG
71189: PUSH
71190: EMPTY
71191: LIST
71192: LIST
71193: PUSH
71194: LD_INT 1
71196: PUSH
71197: LD_INT 1
71199: NEG
71200: PUSH
71201: EMPTY
71202: LIST
71203: LIST
71204: PUSH
71205: LD_INT 2
71207: PUSH
71208: LD_INT 0
71210: PUSH
71211: EMPTY
71212: LIST
71213: LIST
71214: PUSH
71215: LD_INT 2
71217: PUSH
71218: LD_INT 1
71220: PUSH
71221: EMPTY
71222: LIST
71223: LIST
71224: PUSH
71225: LD_INT 2
71227: PUSH
71228: LD_INT 2
71230: PUSH
71231: EMPTY
71232: LIST
71233: LIST
71234: PUSH
71235: LD_INT 1
71237: PUSH
71238: LD_INT 2
71240: PUSH
71241: EMPTY
71242: LIST
71243: LIST
71244: PUSH
71245: LD_INT 0
71247: PUSH
71248: LD_INT 2
71250: PUSH
71251: EMPTY
71252: LIST
71253: LIST
71254: PUSH
71255: LD_INT 1
71257: NEG
71258: PUSH
71259: LD_INT 1
71261: PUSH
71262: EMPTY
71263: LIST
71264: LIST
71265: PUSH
71266: LD_INT 2
71268: NEG
71269: PUSH
71270: LD_INT 1
71272: NEG
71273: PUSH
71274: EMPTY
71275: LIST
71276: LIST
71277: PUSH
71278: LD_INT 2
71280: NEG
71281: PUSH
71282: LD_INT 2
71284: NEG
71285: PUSH
71286: EMPTY
71287: LIST
71288: LIST
71289: PUSH
71290: LD_INT 2
71292: NEG
71293: PUSH
71294: LD_INT 3
71296: NEG
71297: PUSH
71298: EMPTY
71299: LIST
71300: LIST
71301: PUSH
71302: LD_INT 2
71304: PUSH
71305: LD_INT 1
71307: NEG
71308: PUSH
71309: EMPTY
71310: LIST
71311: LIST
71312: PUSH
71313: LD_INT 3
71315: PUSH
71316: LD_INT 1
71318: PUSH
71319: EMPTY
71320: LIST
71321: LIST
71322: PUSH
71323: LD_INT 1
71325: PUSH
71326: LD_INT 3
71328: PUSH
71329: EMPTY
71330: LIST
71331: LIST
71332: PUSH
71333: LD_INT 1
71335: NEG
71336: PUSH
71337: LD_INT 2
71339: PUSH
71340: EMPTY
71341: LIST
71342: LIST
71343: PUSH
71344: LD_INT 3
71346: NEG
71347: PUSH
71348: LD_INT 2
71350: NEG
71351: PUSH
71352: EMPTY
71353: LIST
71354: LIST
71355: PUSH
71356: EMPTY
71357: LIST
71358: LIST
71359: LIST
71360: LIST
71361: LIST
71362: LIST
71363: LIST
71364: LIST
71365: LIST
71366: LIST
71367: LIST
71368: LIST
71369: LIST
71370: LIST
71371: LIST
71372: LIST
71373: LIST
71374: LIST
71375: LIST
71376: LIST
71377: LIST
71378: LIST
71379: LIST
71380: ST_TO_ADDR
// Factory3 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 1 , - 3 ] , [ 1 , - 2 ] , [ 3 , 2 ] , [ 2 , 3 ] , [ - 2 , 1 ] , [ - 3 , - 1 ] ] ;
71381: LD_ADDR_VAR 0 32
71385: PUSH
71386: LD_INT 0
71388: PUSH
71389: LD_INT 0
71391: PUSH
71392: EMPTY
71393: LIST
71394: LIST
71395: PUSH
71396: LD_INT 0
71398: PUSH
71399: LD_INT 1
71401: NEG
71402: PUSH
71403: EMPTY
71404: LIST
71405: LIST
71406: PUSH
71407: LD_INT 1
71409: PUSH
71410: LD_INT 0
71412: PUSH
71413: EMPTY
71414: LIST
71415: LIST
71416: PUSH
71417: LD_INT 1
71419: PUSH
71420: LD_INT 1
71422: PUSH
71423: EMPTY
71424: LIST
71425: LIST
71426: PUSH
71427: LD_INT 0
71429: PUSH
71430: LD_INT 1
71432: PUSH
71433: EMPTY
71434: LIST
71435: LIST
71436: PUSH
71437: LD_INT 1
71439: NEG
71440: PUSH
71441: LD_INT 0
71443: PUSH
71444: EMPTY
71445: LIST
71446: LIST
71447: PUSH
71448: LD_INT 1
71450: NEG
71451: PUSH
71452: LD_INT 1
71454: NEG
71455: PUSH
71456: EMPTY
71457: LIST
71458: LIST
71459: PUSH
71460: LD_INT 1
71462: NEG
71463: PUSH
71464: LD_INT 2
71466: NEG
71467: PUSH
71468: EMPTY
71469: LIST
71470: LIST
71471: PUSH
71472: LD_INT 0
71474: PUSH
71475: LD_INT 2
71477: NEG
71478: PUSH
71479: EMPTY
71480: LIST
71481: LIST
71482: PUSH
71483: LD_INT 1
71485: PUSH
71486: LD_INT 1
71488: NEG
71489: PUSH
71490: EMPTY
71491: LIST
71492: LIST
71493: PUSH
71494: LD_INT 2
71496: PUSH
71497: LD_INT 1
71499: PUSH
71500: EMPTY
71501: LIST
71502: LIST
71503: PUSH
71504: LD_INT 2
71506: PUSH
71507: LD_INT 2
71509: PUSH
71510: EMPTY
71511: LIST
71512: LIST
71513: PUSH
71514: LD_INT 1
71516: PUSH
71517: LD_INT 2
71519: PUSH
71520: EMPTY
71521: LIST
71522: LIST
71523: PUSH
71524: LD_INT 0
71526: PUSH
71527: LD_INT 2
71529: PUSH
71530: EMPTY
71531: LIST
71532: LIST
71533: PUSH
71534: LD_INT 1
71536: NEG
71537: PUSH
71538: LD_INT 1
71540: PUSH
71541: EMPTY
71542: LIST
71543: LIST
71544: PUSH
71545: LD_INT 2
71547: NEG
71548: PUSH
71549: LD_INT 0
71551: PUSH
71552: EMPTY
71553: LIST
71554: LIST
71555: PUSH
71556: LD_INT 2
71558: NEG
71559: PUSH
71560: LD_INT 1
71562: NEG
71563: PUSH
71564: EMPTY
71565: LIST
71566: LIST
71567: PUSH
71568: LD_INT 1
71570: NEG
71571: PUSH
71572: LD_INT 3
71574: NEG
71575: PUSH
71576: EMPTY
71577: LIST
71578: LIST
71579: PUSH
71580: LD_INT 1
71582: PUSH
71583: LD_INT 2
71585: NEG
71586: PUSH
71587: EMPTY
71588: LIST
71589: LIST
71590: PUSH
71591: LD_INT 3
71593: PUSH
71594: LD_INT 2
71596: PUSH
71597: EMPTY
71598: LIST
71599: LIST
71600: PUSH
71601: LD_INT 2
71603: PUSH
71604: LD_INT 3
71606: PUSH
71607: EMPTY
71608: LIST
71609: LIST
71610: PUSH
71611: LD_INT 2
71613: NEG
71614: PUSH
71615: LD_INT 1
71617: PUSH
71618: EMPTY
71619: LIST
71620: LIST
71621: PUSH
71622: LD_INT 3
71624: NEG
71625: PUSH
71626: LD_INT 1
71628: NEG
71629: PUSH
71630: EMPTY
71631: LIST
71632: LIST
71633: PUSH
71634: EMPTY
71635: LIST
71636: LIST
71637: LIST
71638: LIST
71639: LIST
71640: LIST
71641: LIST
71642: LIST
71643: LIST
71644: LIST
71645: LIST
71646: LIST
71647: LIST
71648: LIST
71649: LIST
71650: LIST
71651: LIST
71652: LIST
71653: LIST
71654: LIST
71655: LIST
71656: LIST
71657: LIST
71658: ST_TO_ADDR
// Factory4 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ - 2 , - 3 ] , [ 2 , - 1 ] , [ 3 , 1 ] , [ 1 , 3 ] , [ - 1 , 2 ] , [ - 3 , - 2 ] ] ;
71659: LD_ADDR_VAR 0 33
71663: PUSH
71664: LD_INT 0
71666: PUSH
71667: LD_INT 0
71669: PUSH
71670: EMPTY
71671: LIST
71672: LIST
71673: PUSH
71674: LD_INT 0
71676: PUSH
71677: LD_INT 1
71679: NEG
71680: PUSH
71681: EMPTY
71682: LIST
71683: LIST
71684: PUSH
71685: LD_INT 1
71687: PUSH
71688: LD_INT 0
71690: PUSH
71691: EMPTY
71692: LIST
71693: LIST
71694: PUSH
71695: LD_INT 1
71697: PUSH
71698: LD_INT 1
71700: PUSH
71701: EMPTY
71702: LIST
71703: LIST
71704: PUSH
71705: LD_INT 0
71707: PUSH
71708: LD_INT 1
71710: PUSH
71711: EMPTY
71712: LIST
71713: LIST
71714: PUSH
71715: LD_INT 1
71717: NEG
71718: PUSH
71719: LD_INT 0
71721: PUSH
71722: EMPTY
71723: LIST
71724: LIST
71725: PUSH
71726: LD_INT 1
71728: NEG
71729: PUSH
71730: LD_INT 1
71732: NEG
71733: PUSH
71734: EMPTY
71735: LIST
71736: LIST
71737: PUSH
71738: LD_INT 1
71740: NEG
71741: PUSH
71742: LD_INT 2
71744: NEG
71745: PUSH
71746: EMPTY
71747: LIST
71748: LIST
71749: PUSH
71750: LD_INT 1
71752: PUSH
71753: LD_INT 1
71755: NEG
71756: PUSH
71757: EMPTY
71758: LIST
71759: LIST
71760: PUSH
71761: LD_INT 2
71763: PUSH
71764: LD_INT 0
71766: PUSH
71767: EMPTY
71768: LIST
71769: LIST
71770: PUSH
71771: LD_INT 2
71773: PUSH
71774: LD_INT 1
71776: PUSH
71777: EMPTY
71778: LIST
71779: LIST
71780: PUSH
71781: LD_INT 1
71783: PUSH
71784: LD_INT 2
71786: PUSH
71787: EMPTY
71788: LIST
71789: LIST
71790: PUSH
71791: LD_INT 0
71793: PUSH
71794: LD_INT 2
71796: PUSH
71797: EMPTY
71798: LIST
71799: LIST
71800: PUSH
71801: LD_INT 1
71803: NEG
71804: PUSH
71805: LD_INT 1
71807: PUSH
71808: EMPTY
71809: LIST
71810: LIST
71811: PUSH
71812: LD_INT 2
71814: NEG
71815: PUSH
71816: LD_INT 0
71818: PUSH
71819: EMPTY
71820: LIST
71821: LIST
71822: PUSH
71823: LD_INT 2
71825: NEG
71826: PUSH
71827: LD_INT 1
71829: NEG
71830: PUSH
71831: EMPTY
71832: LIST
71833: LIST
71834: PUSH
71835: LD_INT 2
71837: NEG
71838: PUSH
71839: LD_INT 2
71841: NEG
71842: PUSH
71843: EMPTY
71844: LIST
71845: LIST
71846: PUSH
71847: LD_INT 2
71849: NEG
71850: PUSH
71851: LD_INT 3
71853: NEG
71854: PUSH
71855: EMPTY
71856: LIST
71857: LIST
71858: PUSH
71859: LD_INT 2
71861: PUSH
71862: LD_INT 1
71864: NEG
71865: PUSH
71866: EMPTY
71867: LIST
71868: LIST
71869: PUSH
71870: LD_INT 3
71872: PUSH
71873: LD_INT 1
71875: PUSH
71876: EMPTY
71877: LIST
71878: LIST
71879: PUSH
71880: LD_INT 1
71882: PUSH
71883: LD_INT 3
71885: PUSH
71886: EMPTY
71887: LIST
71888: LIST
71889: PUSH
71890: LD_INT 1
71892: NEG
71893: PUSH
71894: LD_INT 2
71896: PUSH
71897: EMPTY
71898: LIST
71899: LIST
71900: PUSH
71901: LD_INT 3
71903: NEG
71904: PUSH
71905: LD_INT 2
71907: NEG
71908: PUSH
71909: EMPTY
71910: LIST
71911: LIST
71912: PUSH
71913: EMPTY
71914: LIST
71915: LIST
71916: LIST
71917: LIST
71918: LIST
71919: LIST
71920: LIST
71921: LIST
71922: LIST
71923: LIST
71924: LIST
71925: LIST
71926: LIST
71927: LIST
71928: LIST
71929: LIST
71930: LIST
71931: LIST
71932: LIST
71933: LIST
71934: LIST
71935: LIST
71936: LIST
71937: ST_TO_ADDR
// Factory5 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ - 1 , - 3 ] , [ 1 , - 2 ] , [ 3 , 2 ] , [ 2 , 3 ] , [ - 2 , 1 ] , [ - 3 , - 1 ] ] ;
71938: LD_ADDR_VAR 0 34
71942: PUSH
71943: LD_INT 0
71945: PUSH
71946: LD_INT 0
71948: PUSH
71949: EMPTY
71950: LIST
71951: LIST
71952: PUSH
71953: LD_INT 0
71955: PUSH
71956: LD_INT 1
71958: NEG
71959: PUSH
71960: EMPTY
71961: LIST
71962: LIST
71963: PUSH
71964: LD_INT 1
71966: PUSH
71967: LD_INT 0
71969: PUSH
71970: EMPTY
71971: LIST
71972: LIST
71973: PUSH
71974: LD_INT 1
71976: PUSH
71977: LD_INT 1
71979: PUSH
71980: EMPTY
71981: LIST
71982: LIST
71983: PUSH
71984: LD_INT 0
71986: PUSH
71987: LD_INT 1
71989: PUSH
71990: EMPTY
71991: LIST
71992: LIST
71993: PUSH
71994: LD_INT 1
71996: NEG
71997: PUSH
71998: LD_INT 0
72000: PUSH
72001: EMPTY
72002: LIST
72003: LIST
72004: PUSH
72005: LD_INT 1
72007: NEG
72008: PUSH
72009: LD_INT 1
72011: NEG
72012: PUSH
72013: EMPTY
72014: LIST
72015: LIST
72016: PUSH
72017: LD_INT 1
72019: NEG
72020: PUSH
72021: LD_INT 2
72023: NEG
72024: PUSH
72025: EMPTY
72026: LIST
72027: LIST
72028: PUSH
72029: LD_INT 0
72031: PUSH
72032: LD_INT 2
72034: NEG
72035: PUSH
72036: EMPTY
72037: LIST
72038: LIST
72039: PUSH
72040: LD_INT 1
72042: PUSH
72043: LD_INT 1
72045: NEG
72046: PUSH
72047: EMPTY
72048: LIST
72049: LIST
72050: PUSH
72051: LD_INT 2
72053: PUSH
72054: LD_INT 1
72056: PUSH
72057: EMPTY
72058: LIST
72059: LIST
72060: PUSH
72061: LD_INT 2
72063: PUSH
72064: LD_INT 2
72066: PUSH
72067: EMPTY
72068: LIST
72069: LIST
72070: PUSH
72071: LD_INT 1
72073: PUSH
72074: LD_INT 2
72076: PUSH
72077: EMPTY
72078: LIST
72079: LIST
72080: PUSH
72081: LD_INT 1
72083: NEG
72084: PUSH
72085: LD_INT 1
72087: PUSH
72088: EMPTY
72089: LIST
72090: LIST
72091: PUSH
72092: LD_INT 2
72094: NEG
72095: PUSH
72096: LD_INT 0
72098: PUSH
72099: EMPTY
72100: LIST
72101: LIST
72102: PUSH
72103: LD_INT 2
72105: NEG
72106: PUSH
72107: LD_INT 1
72109: NEG
72110: PUSH
72111: EMPTY
72112: LIST
72113: LIST
72114: PUSH
72115: LD_INT 2
72117: NEG
72118: PUSH
72119: LD_INT 2
72121: NEG
72122: PUSH
72123: EMPTY
72124: LIST
72125: LIST
72126: PUSH
72127: LD_INT 1
72129: NEG
72130: PUSH
72131: LD_INT 3
72133: NEG
72134: PUSH
72135: EMPTY
72136: LIST
72137: LIST
72138: PUSH
72139: LD_INT 1
72141: PUSH
72142: LD_INT 2
72144: NEG
72145: PUSH
72146: EMPTY
72147: LIST
72148: LIST
72149: PUSH
72150: LD_INT 3
72152: PUSH
72153: LD_INT 2
72155: PUSH
72156: EMPTY
72157: LIST
72158: LIST
72159: PUSH
72160: LD_INT 2
72162: PUSH
72163: LD_INT 3
72165: PUSH
72166: EMPTY
72167: LIST
72168: LIST
72169: PUSH
72170: LD_INT 2
72172: NEG
72173: PUSH
72174: LD_INT 1
72176: PUSH
72177: EMPTY
72178: LIST
72179: LIST
72180: PUSH
72181: LD_INT 3
72183: NEG
72184: PUSH
72185: LD_INT 1
72187: NEG
72188: PUSH
72189: EMPTY
72190: LIST
72191: LIST
72192: PUSH
72193: EMPTY
72194: LIST
72195: LIST
72196: LIST
72197: LIST
72198: LIST
72199: LIST
72200: LIST
72201: LIST
72202: LIST
72203: LIST
72204: LIST
72205: LIST
72206: LIST
72207: LIST
72208: LIST
72209: LIST
72210: LIST
72211: LIST
72212: LIST
72213: LIST
72214: LIST
72215: LIST
72216: LIST
72217: ST_TO_ADDR
// Ext0 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ 2 , 1 ] , [ - 2 , - 1 ] ] ;
72218: LD_ADDR_VAR 0 35
72222: PUSH
72223: LD_INT 0
72225: PUSH
72226: LD_INT 0
72228: PUSH
72229: EMPTY
72230: LIST
72231: LIST
72232: PUSH
72233: LD_INT 0
72235: PUSH
72236: LD_INT 1
72238: NEG
72239: PUSH
72240: EMPTY
72241: LIST
72242: LIST
72243: PUSH
72244: LD_INT 1
72246: PUSH
72247: LD_INT 0
72249: PUSH
72250: EMPTY
72251: LIST
72252: LIST
72253: PUSH
72254: LD_INT 1
72256: PUSH
72257: LD_INT 1
72259: PUSH
72260: EMPTY
72261: LIST
72262: LIST
72263: PUSH
72264: LD_INT 0
72266: PUSH
72267: LD_INT 1
72269: PUSH
72270: EMPTY
72271: LIST
72272: LIST
72273: PUSH
72274: LD_INT 1
72276: NEG
72277: PUSH
72278: LD_INT 0
72280: PUSH
72281: EMPTY
72282: LIST
72283: LIST
72284: PUSH
72285: LD_INT 1
72287: NEG
72288: PUSH
72289: LD_INT 1
72291: NEG
72292: PUSH
72293: EMPTY
72294: LIST
72295: LIST
72296: PUSH
72297: LD_INT 2
72299: PUSH
72300: LD_INT 1
72302: PUSH
72303: EMPTY
72304: LIST
72305: LIST
72306: PUSH
72307: LD_INT 2
72309: NEG
72310: PUSH
72311: LD_INT 1
72313: NEG
72314: PUSH
72315: EMPTY
72316: LIST
72317: LIST
72318: PUSH
72319: EMPTY
72320: LIST
72321: LIST
72322: LIST
72323: LIST
72324: LIST
72325: LIST
72326: LIST
72327: LIST
72328: LIST
72329: ST_TO_ADDR
// Ext1 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 1 , 2 ] ] ;
72330: LD_ADDR_VAR 0 36
72334: PUSH
72335: LD_INT 0
72337: PUSH
72338: LD_INT 0
72340: PUSH
72341: EMPTY
72342: LIST
72343: LIST
72344: PUSH
72345: LD_INT 0
72347: PUSH
72348: LD_INT 1
72350: NEG
72351: PUSH
72352: EMPTY
72353: LIST
72354: LIST
72355: PUSH
72356: LD_INT 1
72358: PUSH
72359: LD_INT 0
72361: PUSH
72362: EMPTY
72363: LIST
72364: LIST
72365: PUSH
72366: LD_INT 1
72368: PUSH
72369: LD_INT 1
72371: PUSH
72372: EMPTY
72373: LIST
72374: LIST
72375: PUSH
72376: LD_INT 0
72378: PUSH
72379: LD_INT 1
72381: PUSH
72382: EMPTY
72383: LIST
72384: LIST
72385: PUSH
72386: LD_INT 1
72388: NEG
72389: PUSH
72390: LD_INT 0
72392: PUSH
72393: EMPTY
72394: LIST
72395: LIST
72396: PUSH
72397: LD_INT 1
72399: NEG
72400: PUSH
72401: LD_INT 1
72403: NEG
72404: PUSH
72405: EMPTY
72406: LIST
72407: LIST
72408: PUSH
72409: LD_INT 1
72411: NEG
72412: PUSH
72413: LD_INT 2
72415: NEG
72416: PUSH
72417: EMPTY
72418: LIST
72419: LIST
72420: PUSH
72421: LD_INT 1
72423: PUSH
72424: LD_INT 2
72426: PUSH
72427: EMPTY
72428: LIST
72429: LIST
72430: PUSH
72431: EMPTY
72432: LIST
72433: LIST
72434: LIST
72435: LIST
72436: LIST
72437: LIST
72438: LIST
72439: LIST
72440: LIST
72441: ST_TO_ADDR
// Ext2 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ 1 , - 1 ] , [ - 1 , 1 ] ] ;
72442: LD_ADDR_VAR 0 37
72446: PUSH
72447: LD_INT 0
72449: PUSH
72450: LD_INT 0
72452: PUSH
72453: EMPTY
72454: LIST
72455: LIST
72456: PUSH
72457: LD_INT 0
72459: PUSH
72460: LD_INT 1
72462: NEG
72463: PUSH
72464: EMPTY
72465: LIST
72466: LIST
72467: PUSH
72468: LD_INT 1
72470: PUSH
72471: LD_INT 0
72473: PUSH
72474: EMPTY
72475: LIST
72476: LIST
72477: PUSH
72478: LD_INT 1
72480: PUSH
72481: LD_INT 1
72483: PUSH
72484: EMPTY
72485: LIST
72486: LIST
72487: PUSH
72488: LD_INT 0
72490: PUSH
72491: LD_INT 1
72493: PUSH
72494: EMPTY
72495: LIST
72496: LIST
72497: PUSH
72498: LD_INT 1
72500: NEG
72501: PUSH
72502: LD_INT 0
72504: PUSH
72505: EMPTY
72506: LIST
72507: LIST
72508: PUSH
72509: LD_INT 1
72511: NEG
72512: PUSH
72513: LD_INT 1
72515: NEG
72516: PUSH
72517: EMPTY
72518: LIST
72519: LIST
72520: PUSH
72521: LD_INT 1
72523: PUSH
72524: LD_INT 1
72526: NEG
72527: PUSH
72528: EMPTY
72529: LIST
72530: LIST
72531: PUSH
72532: LD_INT 1
72534: NEG
72535: PUSH
72536: LD_INT 1
72538: PUSH
72539: EMPTY
72540: LIST
72541: LIST
72542: PUSH
72543: EMPTY
72544: LIST
72545: LIST
72546: LIST
72547: LIST
72548: LIST
72549: LIST
72550: LIST
72551: LIST
72552: LIST
72553: ST_TO_ADDR
// Ext3 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ 2 , 1 ] , [ - 2 , - 1 ] ] ;
72554: LD_ADDR_VAR 0 38
72558: PUSH
72559: LD_INT 0
72561: PUSH
72562: LD_INT 0
72564: PUSH
72565: EMPTY
72566: LIST
72567: LIST
72568: PUSH
72569: LD_INT 0
72571: PUSH
72572: LD_INT 1
72574: NEG
72575: PUSH
72576: EMPTY
72577: LIST
72578: LIST
72579: PUSH
72580: LD_INT 1
72582: PUSH
72583: LD_INT 0
72585: PUSH
72586: EMPTY
72587: LIST
72588: LIST
72589: PUSH
72590: LD_INT 1
72592: PUSH
72593: LD_INT 1
72595: PUSH
72596: EMPTY
72597: LIST
72598: LIST
72599: PUSH
72600: LD_INT 0
72602: PUSH
72603: LD_INT 1
72605: PUSH
72606: EMPTY
72607: LIST
72608: LIST
72609: PUSH
72610: LD_INT 1
72612: NEG
72613: PUSH
72614: LD_INT 0
72616: PUSH
72617: EMPTY
72618: LIST
72619: LIST
72620: PUSH
72621: LD_INT 1
72623: NEG
72624: PUSH
72625: LD_INT 1
72627: NEG
72628: PUSH
72629: EMPTY
72630: LIST
72631: LIST
72632: PUSH
72633: LD_INT 2
72635: PUSH
72636: LD_INT 1
72638: PUSH
72639: EMPTY
72640: LIST
72641: LIST
72642: PUSH
72643: LD_INT 2
72645: NEG
72646: PUSH
72647: LD_INT 1
72649: NEG
72650: PUSH
72651: EMPTY
72652: LIST
72653: LIST
72654: PUSH
72655: EMPTY
72656: LIST
72657: LIST
72658: LIST
72659: LIST
72660: LIST
72661: LIST
72662: LIST
72663: LIST
72664: LIST
72665: ST_TO_ADDR
// Ext4 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 1 , 2 ] ] ;
72666: LD_ADDR_VAR 0 39
72670: PUSH
72671: LD_INT 0
72673: PUSH
72674: LD_INT 0
72676: PUSH
72677: EMPTY
72678: LIST
72679: LIST
72680: PUSH
72681: LD_INT 0
72683: PUSH
72684: LD_INT 1
72686: NEG
72687: PUSH
72688: EMPTY
72689: LIST
72690: LIST
72691: PUSH
72692: LD_INT 1
72694: PUSH
72695: LD_INT 0
72697: PUSH
72698: EMPTY
72699: LIST
72700: LIST
72701: PUSH
72702: LD_INT 1
72704: PUSH
72705: LD_INT 1
72707: PUSH
72708: EMPTY
72709: LIST
72710: LIST
72711: PUSH
72712: LD_INT 0
72714: PUSH
72715: LD_INT 1
72717: PUSH
72718: EMPTY
72719: LIST
72720: LIST
72721: PUSH
72722: LD_INT 1
72724: NEG
72725: PUSH
72726: LD_INT 0
72728: PUSH
72729: EMPTY
72730: LIST
72731: LIST
72732: PUSH
72733: LD_INT 1
72735: NEG
72736: PUSH
72737: LD_INT 1
72739: NEG
72740: PUSH
72741: EMPTY
72742: LIST
72743: LIST
72744: PUSH
72745: LD_INT 1
72747: NEG
72748: PUSH
72749: LD_INT 2
72751: NEG
72752: PUSH
72753: EMPTY
72754: LIST
72755: LIST
72756: PUSH
72757: LD_INT 1
72759: PUSH
72760: LD_INT 2
72762: PUSH
72763: EMPTY
72764: LIST
72765: LIST
72766: PUSH
72767: EMPTY
72768: LIST
72769: LIST
72770: LIST
72771: LIST
72772: LIST
72773: LIST
72774: LIST
72775: LIST
72776: LIST
72777: ST_TO_ADDR
// Ext5 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ 1 , - 1 ] , [ - 1 , 1 ] ] ;
72778: LD_ADDR_VAR 0 40
72782: PUSH
72783: LD_INT 0
72785: PUSH
72786: LD_INT 0
72788: PUSH
72789: EMPTY
72790: LIST
72791: LIST
72792: PUSH
72793: LD_INT 0
72795: PUSH
72796: LD_INT 1
72798: NEG
72799: PUSH
72800: EMPTY
72801: LIST
72802: LIST
72803: PUSH
72804: LD_INT 1
72806: PUSH
72807: LD_INT 0
72809: PUSH
72810: EMPTY
72811: LIST
72812: LIST
72813: PUSH
72814: LD_INT 1
72816: PUSH
72817: LD_INT 1
72819: PUSH
72820: EMPTY
72821: LIST
72822: LIST
72823: PUSH
72824: LD_INT 0
72826: PUSH
72827: LD_INT 1
72829: PUSH
72830: EMPTY
72831: LIST
72832: LIST
72833: PUSH
72834: LD_INT 1
72836: NEG
72837: PUSH
72838: LD_INT 0
72840: PUSH
72841: EMPTY
72842: LIST
72843: LIST
72844: PUSH
72845: LD_INT 1
72847: NEG
72848: PUSH
72849: LD_INT 1
72851: NEG
72852: PUSH
72853: EMPTY
72854: LIST
72855: LIST
72856: PUSH
72857: LD_INT 1
72859: PUSH
72860: LD_INT 1
72862: NEG
72863: PUSH
72864: EMPTY
72865: LIST
72866: LIST
72867: PUSH
72868: LD_INT 1
72870: NEG
72871: PUSH
72872: LD_INT 1
72874: PUSH
72875: EMPTY
72876: LIST
72877: LIST
72878: PUSH
72879: EMPTY
72880: LIST
72881: LIST
72882: LIST
72883: LIST
72884: LIST
72885: LIST
72886: LIST
72887: LIST
72888: LIST
72889: ST_TO_ADDR
// Lab0 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ - 2 , - 3 ] , [ 2 , - 1 ] , [ 3 , 0 ] , [ 3 , 1 ] , [ 3 , 2 ] , [ 3 , 3 ] , [ 2 , 3 ] , [ - 2 , 1 ] , [ - 3 , 0 ] , [ - 3 , - 1 ] , [ - 3 , - 2 ] , [ - 3 , - 3 ] ] ;
72890: LD_ADDR_VAR 0 41
72894: PUSH
72895: LD_INT 0
72897: PUSH
72898: LD_INT 0
72900: PUSH
72901: EMPTY
72902: LIST
72903: LIST
72904: PUSH
72905: LD_INT 0
72907: PUSH
72908: LD_INT 1
72910: NEG
72911: PUSH
72912: EMPTY
72913: LIST
72914: LIST
72915: PUSH
72916: LD_INT 1
72918: PUSH
72919: LD_INT 0
72921: PUSH
72922: EMPTY
72923: LIST
72924: LIST
72925: PUSH
72926: LD_INT 1
72928: PUSH
72929: LD_INT 1
72931: PUSH
72932: EMPTY
72933: LIST
72934: LIST
72935: PUSH
72936: LD_INT 0
72938: PUSH
72939: LD_INT 1
72941: PUSH
72942: EMPTY
72943: LIST
72944: LIST
72945: PUSH
72946: LD_INT 1
72948: NEG
72949: PUSH
72950: LD_INT 0
72952: PUSH
72953: EMPTY
72954: LIST
72955: LIST
72956: PUSH
72957: LD_INT 1
72959: NEG
72960: PUSH
72961: LD_INT 1
72963: NEG
72964: PUSH
72965: EMPTY
72966: LIST
72967: LIST
72968: PUSH
72969: LD_INT 1
72971: NEG
72972: PUSH
72973: LD_INT 2
72975: NEG
72976: PUSH
72977: EMPTY
72978: LIST
72979: LIST
72980: PUSH
72981: LD_INT 1
72983: PUSH
72984: LD_INT 1
72986: NEG
72987: PUSH
72988: EMPTY
72989: LIST
72990: LIST
72991: PUSH
72992: LD_INT 2
72994: PUSH
72995: LD_INT 0
72997: PUSH
72998: EMPTY
72999: LIST
73000: LIST
73001: PUSH
73002: LD_INT 2
73004: PUSH
73005: LD_INT 1
73007: PUSH
73008: EMPTY
73009: LIST
73010: LIST
73011: PUSH
73012: LD_INT 2
73014: PUSH
73015: LD_INT 2
73017: PUSH
73018: EMPTY
73019: LIST
73020: LIST
73021: PUSH
73022: LD_INT 1
73024: PUSH
73025: LD_INT 2
73027: PUSH
73028: EMPTY
73029: LIST
73030: LIST
73031: PUSH
73032: LD_INT 1
73034: NEG
73035: PUSH
73036: LD_INT 1
73038: PUSH
73039: EMPTY
73040: LIST
73041: LIST
73042: PUSH
73043: LD_INT 2
73045: NEG
73046: PUSH
73047: LD_INT 0
73049: PUSH
73050: EMPTY
73051: LIST
73052: LIST
73053: PUSH
73054: LD_INT 2
73056: NEG
73057: PUSH
73058: LD_INT 1
73060: NEG
73061: PUSH
73062: EMPTY
73063: LIST
73064: LIST
73065: PUSH
73066: LD_INT 2
73068: NEG
73069: PUSH
73070: LD_INT 2
73072: NEG
73073: PUSH
73074: EMPTY
73075: LIST
73076: LIST
73077: PUSH
73078: LD_INT 2
73080: NEG
73081: PUSH
73082: LD_INT 3
73084: NEG
73085: PUSH
73086: EMPTY
73087: LIST
73088: LIST
73089: PUSH
73090: LD_INT 2
73092: PUSH
73093: LD_INT 1
73095: NEG
73096: PUSH
73097: EMPTY
73098: LIST
73099: LIST
73100: PUSH
73101: LD_INT 3
73103: PUSH
73104: LD_INT 0
73106: PUSH
73107: EMPTY
73108: LIST
73109: LIST
73110: PUSH
73111: LD_INT 3
73113: PUSH
73114: LD_INT 1
73116: PUSH
73117: EMPTY
73118: LIST
73119: LIST
73120: PUSH
73121: LD_INT 3
73123: PUSH
73124: LD_INT 2
73126: PUSH
73127: EMPTY
73128: LIST
73129: LIST
73130: PUSH
73131: LD_INT 3
73133: PUSH
73134: LD_INT 3
73136: PUSH
73137: EMPTY
73138: LIST
73139: LIST
73140: PUSH
73141: LD_INT 2
73143: PUSH
73144: LD_INT 3
73146: PUSH
73147: EMPTY
73148: LIST
73149: LIST
73150: PUSH
73151: LD_INT 2
73153: NEG
73154: PUSH
73155: LD_INT 1
73157: PUSH
73158: EMPTY
73159: LIST
73160: LIST
73161: PUSH
73162: LD_INT 3
73164: NEG
73165: PUSH
73166: LD_INT 0
73168: PUSH
73169: EMPTY
73170: LIST
73171: LIST
73172: PUSH
73173: LD_INT 3
73175: NEG
73176: PUSH
73177: LD_INT 1
73179: NEG
73180: PUSH
73181: EMPTY
73182: LIST
73183: LIST
73184: PUSH
73185: LD_INT 3
73187: NEG
73188: PUSH
73189: LD_INT 2
73191: NEG
73192: PUSH
73193: EMPTY
73194: LIST
73195: LIST
73196: PUSH
73197: LD_INT 3
73199: NEG
73200: PUSH
73201: LD_INT 3
73203: NEG
73204: PUSH
73205: EMPTY
73206: LIST
73207: LIST
73208: PUSH
73209: EMPTY
73210: LIST
73211: LIST
73212: LIST
73213: LIST
73214: LIST
73215: LIST
73216: LIST
73217: LIST
73218: LIST
73219: LIST
73220: LIST
73221: LIST
73222: LIST
73223: LIST
73224: LIST
73225: LIST
73226: LIST
73227: LIST
73228: LIST
73229: LIST
73230: LIST
73231: LIST
73232: LIST
73233: LIST
73234: LIST
73235: LIST
73236: LIST
73237: LIST
73238: LIST
73239: ST_TO_ADDR
// Lab1 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ - 2 , - 3 ] , [ - 1 , - 3 ] , [ 0 , - 3 ] , [ 1 , - 2 ] , [ 3 , 2 ] , [ 3 , 3 ] , [ 2 , 3 ] , [ 1 , 3 ] , [ 0 , 3 ] , [ - 1 , 2 ] , [ - 3 , - 2 ] , [ - 3 , - 3 ] ] ;
73240: LD_ADDR_VAR 0 42
73244: PUSH
73245: LD_INT 0
73247: PUSH
73248: LD_INT 0
73250: PUSH
73251: EMPTY
73252: LIST
73253: LIST
73254: PUSH
73255: LD_INT 0
73257: PUSH
73258: LD_INT 1
73260: NEG
73261: PUSH
73262: EMPTY
73263: LIST
73264: LIST
73265: PUSH
73266: LD_INT 1
73268: PUSH
73269: LD_INT 0
73271: PUSH
73272: EMPTY
73273: LIST
73274: LIST
73275: PUSH
73276: LD_INT 1
73278: PUSH
73279: LD_INT 1
73281: PUSH
73282: EMPTY
73283: LIST
73284: LIST
73285: PUSH
73286: LD_INT 0
73288: PUSH
73289: LD_INT 1
73291: PUSH
73292: EMPTY
73293: LIST
73294: LIST
73295: PUSH
73296: LD_INT 1
73298: NEG
73299: PUSH
73300: LD_INT 0
73302: PUSH
73303: EMPTY
73304: LIST
73305: LIST
73306: PUSH
73307: LD_INT 1
73309: NEG
73310: PUSH
73311: LD_INT 1
73313: NEG
73314: PUSH
73315: EMPTY
73316: LIST
73317: LIST
73318: PUSH
73319: LD_INT 1
73321: NEG
73322: PUSH
73323: LD_INT 2
73325: NEG
73326: PUSH
73327: EMPTY
73328: LIST
73329: LIST
73330: PUSH
73331: LD_INT 0
73333: PUSH
73334: LD_INT 2
73336: NEG
73337: PUSH
73338: EMPTY
73339: LIST
73340: LIST
73341: PUSH
73342: LD_INT 1
73344: PUSH
73345: LD_INT 1
73347: NEG
73348: PUSH
73349: EMPTY
73350: LIST
73351: LIST
73352: PUSH
73353: LD_INT 2
73355: PUSH
73356: LD_INT 1
73358: PUSH
73359: EMPTY
73360: LIST
73361: LIST
73362: PUSH
73363: LD_INT 2
73365: PUSH
73366: LD_INT 2
73368: PUSH
73369: EMPTY
73370: LIST
73371: LIST
73372: PUSH
73373: LD_INT 1
73375: PUSH
73376: LD_INT 2
73378: PUSH
73379: EMPTY
73380: LIST
73381: LIST
73382: PUSH
73383: LD_INT 0
73385: PUSH
73386: LD_INT 2
73388: PUSH
73389: EMPTY
73390: LIST
73391: LIST
73392: PUSH
73393: LD_INT 1
73395: NEG
73396: PUSH
73397: LD_INT 1
73399: PUSH
73400: EMPTY
73401: LIST
73402: LIST
73403: PUSH
73404: LD_INT 2
73406: NEG
73407: PUSH
73408: LD_INT 1
73410: NEG
73411: PUSH
73412: EMPTY
73413: LIST
73414: LIST
73415: PUSH
73416: LD_INT 2
73418: NEG
73419: PUSH
73420: LD_INT 2
73422: NEG
73423: PUSH
73424: EMPTY
73425: LIST
73426: LIST
73427: PUSH
73428: LD_INT 2
73430: NEG
73431: PUSH
73432: LD_INT 3
73434: NEG
73435: PUSH
73436: EMPTY
73437: LIST
73438: LIST
73439: PUSH
73440: LD_INT 1
73442: NEG
73443: PUSH
73444: LD_INT 3
73446: NEG
73447: PUSH
73448: EMPTY
73449: LIST
73450: LIST
73451: PUSH
73452: LD_INT 0
73454: PUSH
73455: LD_INT 3
73457: NEG
73458: PUSH
73459: EMPTY
73460: LIST
73461: LIST
73462: PUSH
73463: LD_INT 1
73465: PUSH
73466: LD_INT 2
73468: NEG
73469: PUSH
73470: EMPTY
73471: LIST
73472: LIST
73473: PUSH
73474: LD_INT 3
73476: PUSH
73477: LD_INT 2
73479: PUSH
73480: EMPTY
73481: LIST
73482: LIST
73483: PUSH
73484: LD_INT 3
73486: PUSH
73487: LD_INT 3
73489: PUSH
73490: EMPTY
73491: LIST
73492: LIST
73493: PUSH
73494: LD_INT 2
73496: PUSH
73497: LD_INT 3
73499: PUSH
73500: EMPTY
73501: LIST
73502: LIST
73503: PUSH
73504: LD_INT 1
73506: PUSH
73507: LD_INT 3
73509: PUSH
73510: EMPTY
73511: LIST
73512: LIST
73513: PUSH
73514: LD_INT 0
73516: PUSH
73517: LD_INT 3
73519: PUSH
73520: EMPTY
73521: LIST
73522: LIST
73523: PUSH
73524: LD_INT 1
73526: NEG
73527: PUSH
73528: LD_INT 2
73530: PUSH
73531: EMPTY
73532: LIST
73533: LIST
73534: PUSH
73535: LD_INT 3
73537: NEG
73538: PUSH
73539: LD_INT 2
73541: NEG
73542: PUSH
73543: EMPTY
73544: LIST
73545: LIST
73546: PUSH
73547: LD_INT 3
73549: NEG
73550: PUSH
73551: LD_INT 3
73553: NEG
73554: PUSH
73555: EMPTY
73556: LIST
73557: LIST
73558: PUSH
73559: EMPTY
73560: LIST
73561: LIST
73562: LIST
73563: LIST
73564: LIST
73565: LIST
73566: LIST
73567: LIST
73568: LIST
73569: LIST
73570: LIST
73571: LIST
73572: LIST
73573: LIST
73574: LIST
73575: LIST
73576: LIST
73577: LIST
73578: LIST
73579: LIST
73580: LIST
73581: LIST
73582: LIST
73583: LIST
73584: LIST
73585: LIST
73586: LIST
73587: LIST
73588: LIST
73589: ST_TO_ADDR
// Lab2 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 1 , - 3 ] , [ 0 , - 3 ] , [ 1 , - 2 ] , [ 2 , - 1 ] , [ 3 , 0 ] , [ 3 , 1 ] , [ 1 , 3 ] , [ 0 , 3 ] , [ - 1 , 2 ] , [ - 2 , 1 ] , [ - 3 , 0 ] , [ - 3 , - 1 ] ] ;
73590: LD_ADDR_VAR 0 43
73594: PUSH
73595: LD_INT 0
73597: PUSH
73598: LD_INT 0
73600: PUSH
73601: EMPTY
73602: LIST
73603: LIST
73604: PUSH
73605: LD_INT 0
73607: PUSH
73608: LD_INT 1
73610: NEG
73611: PUSH
73612: EMPTY
73613: LIST
73614: LIST
73615: PUSH
73616: LD_INT 1
73618: PUSH
73619: LD_INT 0
73621: PUSH
73622: EMPTY
73623: LIST
73624: LIST
73625: PUSH
73626: LD_INT 1
73628: PUSH
73629: LD_INT 1
73631: PUSH
73632: EMPTY
73633: LIST
73634: LIST
73635: PUSH
73636: LD_INT 0
73638: PUSH
73639: LD_INT 1
73641: PUSH
73642: EMPTY
73643: LIST
73644: LIST
73645: PUSH
73646: LD_INT 1
73648: NEG
73649: PUSH
73650: LD_INT 0
73652: PUSH
73653: EMPTY
73654: LIST
73655: LIST
73656: PUSH
73657: LD_INT 1
73659: NEG
73660: PUSH
73661: LD_INT 1
73663: NEG
73664: PUSH
73665: EMPTY
73666: LIST
73667: LIST
73668: PUSH
73669: LD_INT 1
73671: NEG
73672: PUSH
73673: LD_INT 2
73675: NEG
73676: PUSH
73677: EMPTY
73678: LIST
73679: LIST
73680: PUSH
73681: LD_INT 0
73683: PUSH
73684: LD_INT 2
73686: NEG
73687: PUSH
73688: EMPTY
73689: LIST
73690: LIST
73691: PUSH
73692: LD_INT 1
73694: PUSH
73695: LD_INT 1
73697: NEG
73698: PUSH
73699: EMPTY
73700: LIST
73701: LIST
73702: PUSH
73703: LD_INT 2
73705: PUSH
73706: LD_INT 0
73708: PUSH
73709: EMPTY
73710: LIST
73711: LIST
73712: PUSH
73713: LD_INT 2
73715: PUSH
73716: LD_INT 1
73718: PUSH
73719: EMPTY
73720: LIST
73721: LIST
73722: PUSH
73723: LD_INT 1
73725: PUSH
73726: LD_INT 2
73728: PUSH
73729: EMPTY
73730: LIST
73731: LIST
73732: PUSH
73733: LD_INT 0
73735: PUSH
73736: LD_INT 2
73738: PUSH
73739: EMPTY
73740: LIST
73741: LIST
73742: PUSH
73743: LD_INT 1
73745: NEG
73746: PUSH
73747: LD_INT 1
73749: PUSH
73750: EMPTY
73751: LIST
73752: LIST
73753: PUSH
73754: LD_INT 2
73756: NEG
73757: PUSH
73758: LD_INT 0
73760: PUSH
73761: EMPTY
73762: LIST
73763: LIST
73764: PUSH
73765: LD_INT 2
73767: NEG
73768: PUSH
73769: LD_INT 1
73771: NEG
73772: PUSH
73773: EMPTY
73774: LIST
73775: LIST
73776: PUSH
73777: LD_INT 1
73779: NEG
73780: PUSH
73781: LD_INT 3
73783: NEG
73784: PUSH
73785: EMPTY
73786: LIST
73787: LIST
73788: PUSH
73789: LD_INT 0
73791: PUSH
73792: LD_INT 3
73794: NEG
73795: PUSH
73796: EMPTY
73797: LIST
73798: LIST
73799: PUSH
73800: LD_INT 1
73802: PUSH
73803: LD_INT 2
73805: NEG
73806: PUSH
73807: EMPTY
73808: LIST
73809: LIST
73810: PUSH
73811: LD_INT 2
73813: PUSH
73814: LD_INT 1
73816: NEG
73817: PUSH
73818: EMPTY
73819: LIST
73820: LIST
73821: PUSH
73822: LD_INT 3
73824: PUSH
73825: LD_INT 0
73827: PUSH
73828: EMPTY
73829: LIST
73830: LIST
73831: PUSH
73832: LD_INT 3
73834: PUSH
73835: LD_INT 1
73837: PUSH
73838: EMPTY
73839: LIST
73840: LIST
73841: PUSH
73842: LD_INT 1
73844: PUSH
73845: LD_INT 3
73847: PUSH
73848: EMPTY
73849: LIST
73850: LIST
73851: PUSH
73852: LD_INT 0
73854: PUSH
73855: LD_INT 3
73857: PUSH
73858: EMPTY
73859: LIST
73860: LIST
73861: PUSH
73862: LD_INT 1
73864: NEG
73865: PUSH
73866: LD_INT 2
73868: PUSH
73869: EMPTY
73870: LIST
73871: LIST
73872: PUSH
73873: LD_INT 2
73875: NEG
73876: PUSH
73877: LD_INT 1
73879: PUSH
73880: EMPTY
73881: LIST
73882: LIST
73883: PUSH
73884: LD_INT 3
73886: NEG
73887: PUSH
73888: LD_INT 0
73890: PUSH
73891: EMPTY
73892: LIST
73893: LIST
73894: PUSH
73895: LD_INT 3
73897: NEG
73898: PUSH
73899: LD_INT 1
73901: NEG
73902: PUSH
73903: EMPTY
73904: LIST
73905: LIST
73906: PUSH
73907: EMPTY
73908: LIST
73909: LIST
73910: LIST
73911: LIST
73912: LIST
73913: LIST
73914: LIST
73915: LIST
73916: LIST
73917: LIST
73918: LIST
73919: LIST
73920: LIST
73921: LIST
73922: LIST
73923: LIST
73924: LIST
73925: LIST
73926: LIST
73927: LIST
73928: LIST
73929: LIST
73930: LIST
73931: LIST
73932: LIST
73933: LIST
73934: LIST
73935: LIST
73936: LIST
73937: ST_TO_ADDR
// Lab3 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ - 2 , - 3 ] , [ 2 , - 1 ] , [ 3 , 0 ] , [ 3 , 1 ] , [ 3 , 2 ] , [ 3 , 3 ] , [ 2 , 3 ] , [ - 2 , 1 ] , [ - 3 , 0 ] , [ - 3 , - 1 ] , [ - 3 , - 2 ] , [ - 3 , - 3 ] ] ;
73938: LD_ADDR_VAR 0 44
73942: PUSH
73943: LD_INT 0
73945: PUSH
73946: LD_INT 0
73948: PUSH
73949: EMPTY
73950: LIST
73951: LIST
73952: PUSH
73953: LD_INT 0
73955: PUSH
73956: LD_INT 1
73958: NEG
73959: PUSH
73960: EMPTY
73961: LIST
73962: LIST
73963: PUSH
73964: LD_INT 1
73966: PUSH
73967: LD_INT 0
73969: PUSH
73970: EMPTY
73971: LIST
73972: LIST
73973: PUSH
73974: LD_INT 1
73976: PUSH
73977: LD_INT 1
73979: PUSH
73980: EMPTY
73981: LIST
73982: LIST
73983: PUSH
73984: LD_INT 0
73986: PUSH
73987: LD_INT 1
73989: PUSH
73990: EMPTY
73991: LIST
73992: LIST
73993: PUSH
73994: LD_INT 1
73996: NEG
73997: PUSH
73998: LD_INT 0
74000: PUSH
74001: EMPTY
74002: LIST
74003: LIST
74004: PUSH
74005: LD_INT 1
74007: NEG
74008: PUSH
74009: LD_INT 1
74011: NEG
74012: PUSH
74013: EMPTY
74014: LIST
74015: LIST
74016: PUSH
74017: LD_INT 1
74019: NEG
74020: PUSH
74021: LD_INT 2
74023: NEG
74024: PUSH
74025: EMPTY
74026: LIST
74027: LIST
74028: PUSH
74029: LD_INT 1
74031: PUSH
74032: LD_INT 1
74034: NEG
74035: PUSH
74036: EMPTY
74037: LIST
74038: LIST
74039: PUSH
74040: LD_INT 2
74042: PUSH
74043: LD_INT 0
74045: PUSH
74046: EMPTY
74047: LIST
74048: LIST
74049: PUSH
74050: LD_INT 2
74052: PUSH
74053: LD_INT 1
74055: PUSH
74056: EMPTY
74057: LIST
74058: LIST
74059: PUSH
74060: LD_INT 2
74062: PUSH
74063: LD_INT 2
74065: PUSH
74066: EMPTY
74067: LIST
74068: LIST
74069: PUSH
74070: LD_INT 1
74072: PUSH
74073: LD_INT 2
74075: PUSH
74076: EMPTY
74077: LIST
74078: LIST
74079: PUSH
74080: LD_INT 1
74082: NEG
74083: PUSH
74084: LD_INT 1
74086: PUSH
74087: EMPTY
74088: LIST
74089: LIST
74090: PUSH
74091: LD_INT 2
74093: NEG
74094: PUSH
74095: LD_INT 0
74097: PUSH
74098: EMPTY
74099: LIST
74100: LIST
74101: PUSH
74102: LD_INT 2
74104: NEG
74105: PUSH
74106: LD_INT 1
74108: NEG
74109: PUSH
74110: EMPTY
74111: LIST
74112: LIST
74113: PUSH
74114: LD_INT 2
74116: NEG
74117: PUSH
74118: LD_INT 2
74120: NEG
74121: PUSH
74122: EMPTY
74123: LIST
74124: LIST
74125: PUSH
74126: LD_INT 2
74128: NEG
74129: PUSH
74130: LD_INT 3
74132: NEG
74133: PUSH
74134: EMPTY
74135: LIST
74136: LIST
74137: PUSH
74138: LD_INT 2
74140: PUSH
74141: LD_INT 1
74143: NEG
74144: PUSH
74145: EMPTY
74146: LIST
74147: LIST
74148: PUSH
74149: LD_INT 3
74151: PUSH
74152: LD_INT 0
74154: PUSH
74155: EMPTY
74156: LIST
74157: LIST
74158: PUSH
74159: LD_INT 3
74161: PUSH
74162: LD_INT 1
74164: PUSH
74165: EMPTY
74166: LIST
74167: LIST
74168: PUSH
74169: LD_INT 3
74171: PUSH
74172: LD_INT 2
74174: PUSH
74175: EMPTY
74176: LIST
74177: LIST
74178: PUSH
74179: LD_INT 3
74181: PUSH
74182: LD_INT 3
74184: PUSH
74185: EMPTY
74186: LIST
74187: LIST
74188: PUSH
74189: LD_INT 2
74191: PUSH
74192: LD_INT 3
74194: PUSH
74195: EMPTY
74196: LIST
74197: LIST
74198: PUSH
74199: LD_INT 2
74201: NEG
74202: PUSH
74203: LD_INT 1
74205: PUSH
74206: EMPTY
74207: LIST
74208: LIST
74209: PUSH
74210: LD_INT 3
74212: NEG
74213: PUSH
74214: LD_INT 0
74216: PUSH
74217: EMPTY
74218: LIST
74219: LIST
74220: PUSH
74221: LD_INT 3
74223: NEG
74224: PUSH
74225: LD_INT 1
74227: NEG
74228: PUSH
74229: EMPTY
74230: LIST
74231: LIST
74232: PUSH
74233: LD_INT 3
74235: NEG
74236: PUSH
74237: LD_INT 2
74239: NEG
74240: PUSH
74241: EMPTY
74242: LIST
74243: LIST
74244: PUSH
74245: LD_INT 3
74247: NEG
74248: PUSH
74249: LD_INT 3
74251: NEG
74252: PUSH
74253: EMPTY
74254: LIST
74255: LIST
74256: PUSH
74257: EMPTY
74258: LIST
74259: LIST
74260: LIST
74261: LIST
74262: LIST
74263: LIST
74264: LIST
74265: LIST
74266: LIST
74267: LIST
74268: LIST
74269: LIST
74270: LIST
74271: LIST
74272: LIST
74273: LIST
74274: LIST
74275: LIST
74276: LIST
74277: LIST
74278: LIST
74279: LIST
74280: LIST
74281: LIST
74282: LIST
74283: LIST
74284: LIST
74285: LIST
74286: LIST
74287: ST_TO_ADDR
// Lab4 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ - 2 , - 3 ] , [ - 1 , - 3 ] , [ 0 , - 3 ] , [ 1 , - 2 ] , [ 3 , 2 ] , [ 3 , 3 ] , [ 2 , 3 ] , [ 1 , 3 ] , [ 0 , 3 ] , [ - 1 , 2 ] , [ - 3 , - 2 ] , [ - 3 , - 3 ] ] ;
74288: LD_ADDR_VAR 0 45
74292: PUSH
74293: LD_INT 0
74295: PUSH
74296: LD_INT 0
74298: PUSH
74299: EMPTY
74300: LIST
74301: LIST
74302: PUSH
74303: LD_INT 0
74305: PUSH
74306: LD_INT 1
74308: NEG
74309: PUSH
74310: EMPTY
74311: LIST
74312: LIST
74313: PUSH
74314: LD_INT 1
74316: PUSH
74317: LD_INT 0
74319: PUSH
74320: EMPTY
74321: LIST
74322: LIST
74323: PUSH
74324: LD_INT 1
74326: PUSH
74327: LD_INT 1
74329: PUSH
74330: EMPTY
74331: LIST
74332: LIST
74333: PUSH
74334: LD_INT 0
74336: PUSH
74337: LD_INT 1
74339: PUSH
74340: EMPTY
74341: LIST
74342: LIST
74343: PUSH
74344: LD_INT 1
74346: NEG
74347: PUSH
74348: LD_INT 0
74350: PUSH
74351: EMPTY
74352: LIST
74353: LIST
74354: PUSH
74355: LD_INT 1
74357: NEG
74358: PUSH
74359: LD_INT 1
74361: NEG
74362: PUSH
74363: EMPTY
74364: LIST
74365: LIST
74366: PUSH
74367: LD_INT 1
74369: NEG
74370: PUSH
74371: LD_INT 2
74373: NEG
74374: PUSH
74375: EMPTY
74376: LIST
74377: LIST
74378: PUSH
74379: LD_INT 0
74381: PUSH
74382: LD_INT 2
74384: NEG
74385: PUSH
74386: EMPTY
74387: LIST
74388: LIST
74389: PUSH
74390: LD_INT 1
74392: PUSH
74393: LD_INT 1
74395: NEG
74396: PUSH
74397: EMPTY
74398: LIST
74399: LIST
74400: PUSH
74401: LD_INT 2
74403: PUSH
74404: LD_INT 1
74406: PUSH
74407: EMPTY
74408: LIST
74409: LIST
74410: PUSH
74411: LD_INT 2
74413: PUSH
74414: LD_INT 2
74416: PUSH
74417: EMPTY
74418: LIST
74419: LIST
74420: PUSH
74421: LD_INT 1
74423: PUSH
74424: LD_INT 2
74426: PUSH
74427: EMPTY
74428: LIST
74429: LIST
74430: PUSH
74431: LD_INT 0
74433: PUSH
74434: LD_INT 2
74436: PUSH
74437: EMPTY
74438: LIST
74439: LIST
74440: PUSH
74441: LD_INT 1
74443: NEG
74444: PUSH
74445: LD_INT 1
74447: PUSH
74448: EMPTY
74449: LIST
74450: LIST
74451: PUSH
74452: LD_INT 2
74454: NEG
74455: PUSH
74456: LD_INT 1
74458: NEG
74459: PUSH
74460: EMPTY
74461: LIST
74462: LIST
74463: PUSH
74464: LD_INT 2
74466: NEG
74467: PUSH
74468: LD_INT 2
74470: NEG
74471: PUSH
74472: EMPTY
74473: LIST
74474: LIST
74475: PUSH
74476: LD_INT 2
74478: NEG
74479: PUSH
74480: LD_INT 3
74482: NEG
74483: PUSH
74484: EMPTY
74485: LIST
74486: LIST
74487: PUSH
74488: LD_INT 1
74490: NEG
74491: PUSH
74492: LD_INT 3
74494: NEG
74495: PUSH
74496: EMPTY
74497: LIST
74498: LIST
74499: PUSH
74500: LD_INT 0
74502: PUSH
74503: LD_INT 3
74505: NEG
74506: PUSH
74507: EMPTY
74508: LIST
74509: LIST
74510: PUSH
74511: LD_INT 1
74513: PUSH
74514: LD_INT 2
74516: NEG
74517: PUSH
74518: EMPTY
74519: LIST
74520: LIST
74521: PUSH
74522: LD_INT 3
74524: PUSH
74525: LD_INT 2
74527: PUSH
74528: EMPTY
74529: LIST
74530: LIST
74531: PUSH
74532: LD_INT 3
74534: PUSH
74535: LD_INT 3
74537: PUSH
74538: EMPTY
74539: LIST
74540: LIST
74541: PUSH
74542: LD_INT 2
74544: PUSH
74545: LD_INT 3
74547: PUSH
74548: EMPTY
74549: LIST
74550: LIST
74551: PUSH
74552: LD_INT 1
74554: PUSH
74555: LD_INT 3
74557: PUSH
74558: EMPTY
74559: LIST
74560: LIST
74561: PUSH
74562: LD_INT 0
74564: PUSH
74565: LD_INT 3
74567: PUSH
74568: EMPTY
74569: LIST
74570: LIST
74571: PUSH
74572: LD_INT 1
74574: NEG
74575: PUSH
74576: LD_INT 2
74578: PUSH
74579: EMPTY
74580: LIST
74581: LIST
74582: PUSH
74583: LD_INT 3
74585: NEG
74586: PUSH
74587: LD_INT 2
74589: NEG
74590: PUSH
74591: EMPTY
74592: LIST
74593: LIST
74594: PUSH
74595: LD_INT 3
74597: NEG
74598: PUSH
74599: LD_INT 3
74601: NEG
74602: PUSH
74603: EMPTY
74604: LIST
74605: LIST
74606: PUSH
74607: EMPTY
74608: LIST
74609: LIST
74610: LIST
74611: LIST
74612: LIST
74613: LIST
74614: LIST
74615: LIST
74616: LIST
74617: LIST
74618: LIST
74619: LIST
74620: LIST
74621: LIST
74622: LIST
74623: LIST
74624: LIST
74625: LIST
74626: LIST
74627: LIST
74628: LIST
74629: LIST
74630: LIST
74631: LIST
74632: LIST
74633: LIST
74634: LIST
74635: LIST
74636: LIST
74637: ST_TO_ADDR
// Lab5 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 1 , - 3 ] , [ 0 , - 3 ] , [ 1 , - 2 ] , [ 2 , - 1 ] , [ 3 , 0 ] , [ 3 , 1 ] , [ 1 , 3 ] , [ 0 , 3 ] , [ - 1 , 2 ] , [ - 2 , 1 ] , [ - 3 , 0 ] , [ - 3 , - 1 ] ] ;
74638: LD_ADDR_VAR 0 46
74642: PUSH
74643: LD_INT 0
74645: PUSH
74646: LD_INT 0
74648: PUSH
74649: EMPTY
74650: LIST
74651: LIST
74652: PUSH
74653: LD_INT 0
74655: PUSH
74656: LD_INT 1
74658: NEG
74659: PUSH
74660: EMPTY
74661: LIST
74662: LIST
74663: PUSH
74664: LD_INT 1
74666: PUSH
74667: LD_INT 0
74669: PUSH
74670: EMPTY
74671: LIST
74672: LIST
74673: PUSH
74674: LD_INT 1
74676: PUSH
74677: LD_INT 1
74679: PUSH
74680: EMPTY
74681: LIST
74682: LIST
74683: PUSH
74684: LD_INT 0
74686: PUSH
74687: LD_INT 1
74689: PUSH
74690: EMPTY
74691: LIST
74692: LIST
74693: PUSH
74694: LD_INT 1
74696: NEG
74697: PUSH
74698: LD_INT 0
74700: PUSH
74701: EMPTY
74702: LIST
74703: LIST
74704: PUSH
74705: LD_INT 1
74707: NEG
74708: PUSH
74709: LD_INT 1
74711: NEG
74712: PUSH
74713: EMPTY
74714: LIST
74715: LIST
74716: PUSH
74717: LD_INT 1
74719: NEG
74720: PUSH
74721: LD_INT 2
74723: NEG
74724: PUSH
74725: EMPTY
74726: LIST
74727: LIST
74728: PUSH
74729: LD_INT 0
74731: PUSH
74732: LD_INT 2
74734: NEG
74735: PUSH
74736: EMPTY
74737: LIST
74738: LIST
74739: PUSH
74740: LD_INT 1
74742: PUSH
74743: LD_INT 1
74745: NEG
74746: PUSH
74747: EMPTY
74748: LIST
74749: LIST
74750: PUSH
74751: LD_INT 2
74753: PUSH
74754: LD_INT 0
74756: PUSH
74757: EMPTY
74758: LIST
74759: LIST
74760: PUSH
74761: LD_INT 2
74763: PUSH
74764: LD_INT 1
74766: PUSH
74767: EMPTY
74768: LIST
74769: LIST
74770: PUSH
74771: LD_INT 1
74773: PUSH
74774: LD_INT 2
74776: PUSH
74777: EMPTY
74778: LIST
74779: LIST
74780: PUSH
74781: LD_INT 0
74783: PUSH
74784: LD_INT 2
74786: PUSH
74787: EMPTY
74788: LIST
74789: LIST
74790: PUSH
74791: LD_INT 1
74793: NEG
74794: PUSH
74795: LD_INT 1
74797: PUSH
74798: EMPTY
74799: LIST
74800: LIST
74801: PUSH
74802: LD_INT 2
74804: NEG
74805: PUSH
74806: LD_INT 0
74808: PUSH
74809: EMPTY
74810: LIST
74811: LIST
74812: PUSH
74813: LD_INT 2
74815: NEG
74816: PUSH
74817: LD_INT 1
74819: NEG
74820: PUSH
74821: EMPTY
74822: LIST
74823: LIST
74824: PUSH
74825: LD_INT 1
74827: NEG
74828: PUSH
74829: LD_INT 3
74831: NEG
74832: PUSH
74833: EMPTY
74834: LIST
74835: LIST
74836: PUSH
74837: LD_INT 0
74839: PUSH
74840: LD_INT 3
74842: NEG
74843: PUSH
74844: EMPTY
74845: LIST
74846: LIST
74847: PUSH
74848: LD_INT 1
74850: PUSH
74851: LD_INT 2
74853: NEG
74854: PUSH
74855: EMPTY
74856: LIST
74857: LIST
74858: PUSH
74859: LD_INT 2
74861: PUSH
74862: LD_INT 1
74864: NEG
74865: PUSH
74866: EMPTY
74867: LIST
74868: LIST
74869: PUSH
74870: LD_INT 3
74872: PUSH
74873: LD_INT 0
74875: PUSH
74876: EMPTY
74877: LIST
74878: LIST
74879: PUSH
74880: LD_INT 3
74882: PUSH
74883: LD_INT 1
74885: PUSH
74886: EMPTY
74887: LIST
74888: LIST
74889: PUSH
74890: LD_INT 1
74892: PUSH
74893: LD_INT 3
74895: PUSH
74896: EMPTY
74897: LIST
74898: LIST
74899: PUSH
74900: LD_INT 0
74902: PUSH
74903: LD_INT 3
74905: PUSH
74906: EMPTY
74907: LIST
74908: LIST
74909: PUSH
74910: LD_INT 1
74912: NEG
74913: PUSH
74914: LD_INT 2
74916: PUSH
74917: EMPTY
74918: LIST
74919: LIST
74920: PUSH
74921: LD_INT 2
74923: NEG
74924: PUSH
74925: LD_INT 1
74927: PUSH
74928: EMPTY
74929: LIST
74930: LIST
74931: PUSH
74932: LD_INT 3
74934: NEG
74935: PUSH
74936: LD_INT 0
74938: PUSH
74939: EMPTY
74940: LIST
74941: LIST
74942: PUSH
74943: LD_INT 3
74945: NEG
74946: PUSH
74947: LD_INT 1
74949: NEG
74950: PUSH
74951: EMPTY
74952: LIST
74953: LIST
74954: PUSH
74955: EMPTY
74956: LIST
74957: LIST
74958: LIST
74959: LIST
74960: LIST
74961: LIST
74962: LIST
74963: LIST
74964: LIST
74965: LIST
74966: LIST
74967: LIST
74968: LIST
74969: LIST
74970: LIST
74971: LIST
74972: LIST
74973: LIST
74974: LIST
74975: LIST
74976: LIST
74977: LIST
74978: LIST
74979: LIST
74980: LIST
74981: LIST
74982: LIST
74983: LIST
74984: LIST
74985: ST_TO_ADDR
// ControlTower0 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
74986: LD_ADDR_VAR 0 47
74990: PUSH
74991: LD_INT 0
74993: PUSH
74994: LD_INT 0
74996: PUSH
74997: EMPTY
74998: LIST
74999: LIST
75000: PUSH
75001: LD_INT 0
75003: PUSH
75004: LD_INT 1
75006: NEG
75007: PUSH
75008: EMPTY
75009: LIST
75010: LIST
75011: PUSH
75012: LD_INT 1
75014: PUSH
75015: LD_INT 0
75017: PUSH
75018: EMPTY
75019: LIST
75020: LIST
75021: PUSH
75022: LD_INT 1
75024: PUSH
75025: LD_INT 1
75027: PUSH
75028: EMPTY
75029: LIST
75030: LIST
75031: PUSH
75032: LD_INT 0
75034: PUSH
75035: LD_INT 1
75037: PUSH
75038: EMPTY
75039: LIST
75040: LIST
75041: PUSH
75042: LD_INT 1
75044: NEG
75045: PUSH
75046: LD_INT 0
75048: PUSH
75049: EMPTY
75050: LIST
75051: LIST
75052: PUSH
75053: LD_INT 1
75055: NEG
75056: PUSH
75057: LD_INT 1
75059: NEG
75060: PUSH
75061: EMPTY
75062: LIST
75063: LIST
75064: PUSH
75065: LD_INT 1
75067: NEG
75068: PUSH
75069: LD_INT 2
75071: NEG
75072: PUSH
75073: EMPTY
75074: LIST
75075: LIST
75076: PUSH
75077: LD_INT 0
75079: PUSH
75080: LD_INT 2
75082: NEG
75083: PUSH
75084: EMPTY
75085: LIST
75086: LIST
75087: PUSH
75088: LD_INT 1
75090: PUSH
75091: LD_INT 1
75093: NEG
75094: PUSH
75095: EMPTY
75096: LIST
75097: LIST
75098: PUSH
75099: LD_INT 2
75101: NEG
75102: PUSH
75103: LD_INT 1
75105: NEG
75106: PUSH
75107: EMPTY
75108: LIST
75109: LIST
75110: PUSH
75111: LD_INT 2
75113: NEG
75114: PUSH
75115: LD_INT 2
75117: NEG
75118: PUSH
75119: EMPTY
75120: LIST
75121: LIST
75122: PUSH
75123: EMPTY
75124: LIST
75125: LIST
75126: LIST
75127: LIST
75128: LIST
75129: LIST
75130: LIST
75131: LIST
75132: LIST
75133: LIST
75134: LIST
75135: LIST
75136: ST_TO_ADDR
// ControlTower1 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] ] ;
75137: LD_ADDR_VAR 0 48
75141: PUSH
75142: LD_INT 0
75144: PUSH
75145: LD_INT 0
75147: PUSH
75148: EMPTY
75149: LIST
75150: LIST
75151: PUSH
75152: LD_INT 0
75154: PUSH
75155: LD_INT 1
75157: NEG
75158: PUSH
75159: EMPTY
75160: LIST
75161: LIST
75162: PUSH
75163: LD_INT 1
75165: PUSH
75166: LD_INT 0
75168: PUSH
75169: EMPTY
75170: LIST
75171: LIST
75172: PUSH
75173: LD_INT 1
75175: PUSH
75176: LD_INT 1
75178: PUSH
75179: EMPTY
75180: LIST
75181: LIST
75182: PUSH
75183: LD_INT 0
75185: PUSH
75186: LD_INT 1
75188: PUSH
75189: EMPTY
75190: LIST
75191: LIST
75192: PUSH
75193: LD_INT 1
75195: NEG
75196: PUSH
75197: LD_INT 0
75199: PUSH
75200: EMPTY
75201: LIST
75202: LIST
75203: PUSH
75204: LD_INT 1
75206: NEG
75207: PUSH
75208: LD_INT 1
75210: NEG
75211: PUSH
75212: EMPTY
75213: LIST
75214: LIST
75215: PUSH
75216: LD_INT 1
75218: NEG
75219: PUSH
75220: LD_INT 2
75222: NEG
75223: PUSH
75224: EMPTY
75225: LIST
75226: LIST
75227: PUSH
75228: LD_INT 0
75230: PUSH
75231: LD_INT 2
75233: NEG
75234: PUSH
75235: EMPTY
75236: LIST
75237: LIST
75238: PUSH
75239: LD_INT 1
75241: PUSH
75242: LD_INT 1
75244: NEG
75245: PUSH
75246: EMPTY
75247: LIST
75248: LIST
75249: PUSH
75250: LD_INT 2
75252: PUSH
75253: LD_INT 0
75255: PUSH
75256: EMPTY
75257: LIST
75258: LIST
75259: PUSH
75260: LD_INT 2
75262: PUSH
75263: LD_INT 1
75265: PUSH
75266: EMPTY
75267: LIST
75268: LIST
75269: PUSH
75270: EMPTY
75271: LIST
75272: LIST
75273: LIST
75274: LIST
75275: LIST
75276: LIST
75277: LIST
75278: LIST
75279: LIST
75280: LIST
75281: LIST
75282: LIST
75283: ST_TO_ADDR
// ControlTower2 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] ] ;
75284: LD_ADDR_VAR 0 49
75288: PUSH
75289: LD_INT 0
75291: PUSH
75292: LD_INT 0
75294: PUSH
75295: EMPTY
75296: LIST
75297: LIST
75298: PUSH
75299: LD_INT 0
75301: PUSH
75302: LD_INT 1
75304: NEG
75305: PUSH
75306: EMPTY
75307: LIST
75308: LIST
75309: PUSH
75310: LD_INT 1
75312: PUSH
75313: LD_INT 0
75315: PUSH
75316: EMPTY
75317: LIST
75318: LIST
75319: PUSH
75320: LD_INT 1
75322: PUSH
75323: LD_INT 1
75325: PUSH
75326: EMPTY
75327: LIST
75328: LIST
75329: PUSH
75330: LD_INT 0
75332: PUSH
75333: LD_INT 1
75335: PUSH
75336: EMPTY
75337: LIST
75338: LIST
75339: PUSH
75340: LD_INT 1
75342: NEG
75343: PUSH
75344: LD_INT 0
75346: PUSH
75347: EMPTY
75348: LIST
75349: LIST
75350: PUSH
75351: LD_INT 1
75353: NEG
75354: PUSH
75355: LD_INT 1
75357: NEG
75358: PUSH
75359: EMPTY
75360: LIST
75361: LIST
75362: PUSH
75363: LD_INT 1
75365: PUSH
75366: LD_INT 1
75368: NEG
75369: PUSH
75370: EMPTY
75371: LIST
75372: LIST
75373: PUSH
75374: LD_INT 2
75376: PUSH
75377: LD_INT 0
75379: PUSH
75380: EMPTY
75381: LIST
75382: LIST
75383: PUSH
75384: LD_INT 2
75386: PUSH
75387: LD_INT 1
75389: PUSH
75390: EMPTY
75391: LIST
75392: LIST
75393: PUSH
75394: LD_INT 2
75396: PUSH
75397: LD_INT 2
75399: PUSH
75400: EMPTY
75401: LIST
75402: LIST
75403: PUSH
75404: LD_INT 1
75406: PUSH
75407: LD_INT 2
75409: PUSH
75410: EMPTY
75411: LIST
75412: LIST
75413: PUSH
75414: EMPTY
75415: LIST
75416: LIST
75417: LIST
75418: LIST
75419: LIST
75420: LIST
75421: LIST
75422: LIST
75423: LIST
75424: LIST
75425: LIST
75426: LIST
75427: ST_TO_ADDR
// ControlTower3 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] ] ;
75428: LD_ADDR_VAR 0 50
75432: PUSH
75433: LD_INT 0
75435: PUSH
75436: LD_INT 0
75438: PUSH
75439: EMPTY
75440: LIST
75441: LIST
75442: PUSH
75443: LD_INT 0
75445: PUSH
75446: LD_INT 1
75448: NEG
75449: PUSH
75450: EMPTY
75451: LIST
75452: LIST
75453: PUSH
75454: LD_INT 1
75456: PUSH
75457: LD_INT 0
75459: PUSH
75460: EMPTY
75461: LIST
75462: LIST
75463: PUSH
75464: LD_INT 1
75466: PUSH
75467: LD_INT 1
75469: PUSH
75470: EMPTY
75471: LIST
75472: LIST
75473: PUSH
75474: LD_INT 0
75476: PUSH
75477: LD_INT 1
75479: PUSH
75480: EMPTY
75481: LIST
75482: LIST
75483: PUSH
75484: LD_INT 1
75486: NEG
75487: PUSH
75488: LD_INT 0
75490: PUSH
75491: EMPTY
75492: LIST
75493: LIST
75494: PUSH
75495: LD_INT 1
75497: NEG
75498: PUSH
75499: LD_INT 1
75501: NEG
75502: PUSH
75503: EMPTY
75504: LIST
75505: LIST
75506: PUSH
75507: LD_INT 2
75509: PUSH
75510: LD_INT 1
75512: PUSH
75513: EMPTY
75514: LIST
75515: LIST
75516: PUSH
75517: LD_INT 2
75519: PUSH
75520: LD_INT 2
75522: PUSH
75523: EMPTY
75524: LIST
75525: LIST
75526: PUSH
75527: LD_INT 1
75529: PUSH
75530: LD_INT 2
75532: PUSH
75533: EMPTY
75534: LIST
75535: LIST
75536: PUSH
75537: LD_INT 0
75539: PUSH
75540: LD_INT 2
75542: PUSH
75543: EMPTY
75544: LIST
75545: LIST
75546: PUSH
75547: LD_INT 1
75549: NEG
75550: PUSH
75551: LD_INT 1
75553: PUSH
75554: EMPTY
75555: LIST
75556: LIST
75557: PUSH
75558: EMPTY
75559: LIST
75560: LIST
75561: LIST
75562: LIST
75563: LIST
75564: LIST
75565: LIST
75566: LIST
75567: LIST
75568: LIST
75569: LIST
75570: LIST
75571: ST_TO_ADDR
// ControlTower4 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] ] ;
75572: LD_ADDR_VAR 0 51
75576: PUSH
75577: LD_INT 0
75579: PUSH
75580: LD_INT 0
75582: PUSH
75583: EMPTY
75584: LIST
75585: LIST
75586: PUSH
75587: LD_INT 0
75589: PUSH
75590: LD_INT 1
75592: NEG
75593: PUSH
75594: EMPTY
75595: LIST
75596: LIST
75597: PUSH
75598: LD_INT 1
75600: PUSH
75601: LD_INT 0
75603: PUSH
75604: EMPTY
75605: LIST
75606: LIST
75607: PUSH
75608: LD_INT 1
75610: PUSH
75611: LD_INT 1
75613: PUSH
75614: EMPTY
75615: LIST
75616: LIST
75617: PUSH
75618: LD_INT 0
75620: PUSH
75621: LD_INT 1
75623: PUSH
75624: EMPTY
75625: LIST
75626: LIST
75627: PUSH
75628: LD_INT 1
75630: NEG
75631: PUSH
75632: LD_INT 0
75634: PUSH
75635: EMPTY
75636: LIST
75637: LIST
75638: PUSH
75639: LD_INT 1
75641: NEG
75642: PUSH
75643: LD_INT 1
75645: NEG
75646: PUSH
75647: EMPTY
75648: LIST
75649: LIST
75650: PUSH
75651: LD_INT 1
75653: PUSH
75654: LD_INT 2
75656: PUSH
75657: EMPTY
75658: LIST
75659: LIST
75660: PUSH
75661: LD_INT 0
75663: PUSH
75664: LD_INT 2
75666: PUSH
75667: EMPTY
75668: LIST
75669: LIST
75670: PUSH
75671: LD_INT 1
75673: NEG
75674: PUSH
75675: LD_INT 1
75677: PUSH
75678: EMPTY
75679: LIST
75680: LIST
75681: PUSH
75682: LD_INT 2
75684: NEG
75685: PUSH
75686: LD_INT 0
75688: PUSH
75689: EMPTY
75690: LIST
75691: LIST
75692: PUSH
75693: LD_INT 2
75695: NEG
75696: PUSH
75697: LD_INT 1
75699: NEG
75700: PUSH
75701: EMPTY
75702: LIST
75703: LIST
75704: PUSH
75705: EMPTY
75706: LIST
75707: LIST
75708: LIST
75709: LIST
75710: LIST
75711: LIST
75712: LIST
75713: LIST
75714: LIST
75715: LIST
75716: LIST
75717: LIST
75718: ST_TO_ADDR
// ControlTower5 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
75719: LD_ADDR_VAR 0 52
75723: PUSH
75724: LD_INT 0
75726: PUSH
75727: LD_INT 0
75729: PUSH
75730: EMPTY
75731: LIST
75732: LIST
75733: PUSH
75734: LD_INT 0
75736: PUSH
75737: LD_INT 1
75739: NEG
75740: PUSH
75741: EMPTY
75742: LIST
75743: LIST
75744: PUSH
75745: LD_INT 1
75747: PUSH
75748: LD_INT 0
75750: PUSH
75751: EMPTY
75752: LIST
75753: LIST
75754: PUSH
75755: LD_INT 1
75757: PUSH
75758: LD_INT 1
75760: PUSH
75761: EMPTY
75762: LIST
75763: LIST
75764: PUSH
75765: LD_INT 0
75767: PUSH
75768: LD_INT 1
75770: PUSH
75771: EMPTY
75772: LIST
75773: LIST
75774: PUSH
75775: LD_INT 1
75777: NEG
75778: PUSH
75779: LD_INT 0
75781: PUSH
75782: EMPTY
75783: LIST
75784: LIST
75785: PUSH
75786: LD_INT 1
75788: NEG
75789: PUSH
75790: LD_INT 1
75792: NEG
75793: PUSH
75794: EMPTY
75795: LIST
75796: LIST
75797: PUSH
75798: LD_INT 1
75800: NEG
75801: PUSH
75802: LD_INT 2
75804: NEG
75805: PUSH
75806: EMPTY
75807: LIST
75808: LIST
75809: PUSH
75810: LD_INT 1
75812: NEG
75813: PUSH
75814: LD_INT 1
75816: PUSH
75817: EMPTY
75818: LIST
75819: LIST
75820: PUSH
75821: LD_INT 2
75823: NEG
75824: PUSH
75825: LD_INT 0
75827: PUSH
75828: EMPTY
75829: LIST
75830: LIST
75831: PUSH
75832: LD_INT 2
75834: NEG
75835: PUSH
75836: LD_INT 1
75838: NEG
75839: PUSH
75840: EMPTY
75841: LIST
75842: LIST
75843: PUSH
75844: LD_INT 2
75846: NEG
75847: PUSH
75848: LD_INT 2
75850: NEG
75851: PUSH
75852: EMPTY
75853: LIST
75854: LIST
75855: PUSH
75856: EMPTY
75857: LIST
75858: LIST
75859: LIST
75860: LIST
75861: LIST
75862: LIST
75863: LIST
75864: LIST
75865: LIST
75866: LIST
75867: LIST
75868: LIST
75869: ST_TO_ADDR
// Barracks0 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
75870: LD_ADDR_VAR 0 53
75874: PUSH
75875: LD_INT 0
75877: PUSH
75878: LD_INT 0
75880: PUSH
75881: EMPTY
75882: LIST
75883: LIST
75884: PUSH
75885: LD_INT 0
75887: PUSH
75888: LD_INT 1
75890: NEG
75891: PUSH
75892: EMPTY
75893: LIST
75894: LIST
75895: PUSH
75896: LD_INT 1
75898: PUSH
75899: LD_INT 0
75901: PUSH
75902: EMPTY
75903: LIST
75904: LIST
75905: PUSH
75906: LD_INT 1
75908: PUSH
75909: LD_INT 1
75911: PUSH
75912: EMPTY
75913: LIST
75914: LIST
75915: PUSH
75916: LD_INT 0
75918: PUSH
75919: LD_INT 1
75921: PUSH
75922: EMPTY
75923: LIST
75924: LIST
75925: PUSH
75926: LD_INT 1
75928: NEG
75929: PUSH
75930: LD_INT 0
75932: PUSH
75933: EMPTY
75934: LIST
75935: LIST
75936: PUSH
75937: LD_INT 1
75939: NEG
75940: PUSH
75941: LD_INT 1
75943: NEG
75944: PUSH
75945: EMPTY
75946: LIST
75947: LIST
75948: PUSH
75949: LD_INT 1
75951: NEG
75952: PUSH
75953: LD_INT 2
75955: NEG
75956: PUSH
75957: EMPTY
75958: LIST
75959: LIST
75960: PUSH
75961: LD_INT 0
75963: PUSH
75964: LD_INT 2
75966: NEG
75967: PUSH
75968: EMPTY
75969: LIST
75970: LIST
75971: PUSH
75972: LD_INT 1
75974: PUSH
75975: LD_INT 1
75977: NEG
75978: PUSH
75979: EMPTY
75980: LIST
75981: LIST
75982: PUSH
75983: LD_INT 2
75985: PUSH
75986: LD_INT 0
75988: PUSH
75989: EMPTY
75990: LIST
75991: LIST
75992: PUSH
75993: LD_INT 2
75995: PUSH
75996: LD_INT 1
75998: PUSH
75999: EMPTY
76000: LIST
76001: LIST
76002: PUSH
76003: LD_INT 2
76005: PUSH
76006: LD_INT 2
76008: PUSH
76009: EMPTY
76010: LIST
76011: LIST
76012: PUSH
76013: LD_INT 1
76015: PUSH
76016: LD_INT 2
76018: PUSH
76019: EMPTY
76020: LIST
76021: LIST
76022: PUSH
76023: LD_INT 0
76025: PUSH
76026: LD_INT 2
76028: PUSH
76029: EMPTY
76030: LIST
76031: LIST
76032: PUSH
76033: LD_INT 1
76035: NEG
76036: PUSH
76037: LD_INT 1
76039: PUSH
76040: EMPTY
76041: LIST
76042: LIST
76043: PUSH
76044: LD_INT 2
76046: NEG
76047: PUSH
76048: LD_INT 0
76050: PUSH
76051: EMPTY
76052: LIST
76053: LIST
76054: PUSH
76055: LD_INT 2
76057: NEG
76058: PUSH
76059: LD_INT 1
76061: NEG
76062: PUSH
76063: EMPTY
76064: LIST
76065: LIST
76066: PUSH
76067: LD_INT 2
76069: NEG
76070: PUSH
76071: LD_INT 2
76073: NEG
76074: PUSH
76075: EMPTY
76076: LIST
76077: LIST
76078: PUSH
76079: EMPTY
76080: LIST
76081: LIST
76082: LIST
76083: LIST
76084: LIST
76085: LIST
76086: LIST
76087: LIST
76088: LIST
76089: LIST
76090: LIST
76091: LIST
76092: LIST
76093: LIST
76094: LIST
76095: LIST
76096: LIST
76097: LIST
76098: LIST
76099: ST_TO_ADDR
// Barracks1 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
76100: LD_ADDR_VAR 0 54
76104: PUSH
76105: LD_INT 0
76107: PUSH
76108: LD_INT 0
76110: PUSH
76111: EMPTY
76112: LIST
76113: LIST
76114: PUSH
76115: LD_INT 0
76117: PUSH
76118: LD_INT 1
76120: NEG
76121: PUSH
76122: EMPTY
76123: LIST
76124: LIST
76125: PUSH
76126: LD_INT 1
76128: PUSH
76129: LD_INT 0
76131: PUSH
76132: EMPTY
76133: LIST
76134: LIST
76135: PUSH
76136: LD_INT 1
76138: PUSH
76139: LD_INT 1
76141: PUSH
76142: EMPTY
76143: LIST
76144: LIST
76145: PUSH
76146: LD_INT 0
76148: PUSH
76149: LD_INT 1
76151: PUSH
76152: EMPTY
76153: LIST
76154: LIST
76155: PUSH
76156: LD_INT 1
76158: NEG
76159: PUSH
76160: LD_INT 0
76162: PUSH
76163: EMPTY
76164: LIST
76165: LIST
76166: PUSH
76167: LD_INT 1
76169: NEG
76170: PUSH
76171: LD_INT 1
76173: NEG
76174: PUSH
76175: EMPTY
76176: LIST
76177: LIST
76178: PUSH
76179: LD_INT 1
76181: NEG
76182: PUSH
76183: LD_INT 2
76185: NEG
76186: PUSH
76187: EMPTY
76188: LIST
76189: LIST
76190: PUSH
76191: LD_INT 0
76193: PUSH
76194: LD_INT 2
76196: NEG
76197: PUSH
76198: EMPTY
76199: LIST
76200: LIST
76201: PUSH
76202: LD_INT 1
76204: PUSH
76205: LD_INT 1
76207: NEG
76208: PUSH
76209: EMPTY
76210: LIST
76211: LIST
76212: PUSH
76213: LD_INT 2
76215: PUSH
76216: LD_INT 0
76218: PUSH
76219: EMPTY
76220: LIST
76221: LIST
76222: PUSH
76223: LD_INT 2
76225: PUSH
76226: LD_INT 1
76228: PUSH
76229: EMPTY
76230: LIST
76231: LIST
76232: PUSH
76233: LD_INT 2
76235: PUSH
76236: LD_INT 2
76238: PUSH
76239: EMPTY
76240: LIST
76241: LIST
76242: PUSH
76243: LD_INT 1
76245: PUSH
76246: LD_INT 2
76248: PUSH
76249: EMPTY
76250: LIST
76251: LIST
76252: PUSH
76253: LD_INT 0
76255: PUSH
76256: LD_INT 2
76258: PUSH
76259: EMPTY
76260: LIST
76261: LIST
76262: PUSH
76263: LD_INT 1
76265: NEG
76266: PUSH
76267: LD_INT 1
76269: PUSH
76270: EMPTY
76271: LIST
76272: LIST
76273: PUSH
76274: LD_INT 2
76276: NEG
76277: PUSH
76278: LD_INT 0
76280: PUSH
76281: EMPTY
76282: LIST
76283: LIST
76284: PUSH
76285: LD_INT 2
76287: NEG
76288: PUSH
76289: LD_INT 1
76291: NEG
76292: PUSH
76293: EMPTY
76294: LIST
76295: LIST
76296: PUSH
76297: LD_INT 2
76299: NEG
76300: PUSH
76301: LD_INT 2
76303: NEG
76304: PUSH
76305: EMPTY
76306: LIST
76307: LIST
76308: PUSH
76309: EMPTY
76310: LIST
76311: LIST
76312: LIST
76313: LIST
76314: LIST
76315: LIST
76316: LIST
76317: LIST
76318: LIST
76319: LIST
76320: LIST
76321: LIST
76322: LIST
76323: LIST
76324: LIST
76325: LIST
76326: LIST
76327: LIST
76328: LIST
76329: ST_TO_ADDR
// Barracks2 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
76330: LD_ADDR_VAR 0 55
76334: PUSH
76335: LD_INT 0
76337: PUSH
76338: LD_INT 0
76340: PUSH
76341: EMPTY
76342: LIST
76343: LIST
76344: PUSH
76345: LD_INT 0
76347: PUSH
76348: LD_INT 1
76350: NEG
76351: PUSH
76352: EMPTY
76353: LIST
76354: LIST
76355: PUSH
76356: LD_INT 1
76358: PUSH
76359: LD_INT 0
76361: PUSH
76362: EMPTY
76363: LIST
76364: LIST
76365: PUSH
76366: LD_INT 1
76368: PUSH
76369: LD_INT 1
76371: PUSH
76372: EMPTY
76373: LIST
76374: LIST
76375: PUSH
76376: LD_INT 0
76378: PUSH
76379: LD_INT 1
76381: PUSH
76382: EMPTY
76383: LIST
76384: LIST
76385: PUSH
76386: LD_INT 1
76388: NEG
76389: PUSH
76390: LD_INT 0
76392: PUSH
76393: EMPTY
76394: LIST
76395: LIST
76396: PUSH
76397: LD_INT 1
76399: NEG
76400: PUSH
76401: LD_INT 1
76403: NEG
76404: PUSH
76405: EMPTY
76406: LIST
76407: LIST
76408: PUSH
76409: LD_INT 1
76411: NEG
76412: PUSH
76413: LD_INT 2
76415: NEG
76416: PUSH
76417: EMPTY
76418: LIST
76419: LIST
76420: PUSH
76421: LD_INT 0
76423: PUSH
76424: LD_INT 2
76426: NEG
76427: PUSH
76428: EMPTY
76429: LIST
76430: LIST
76431: PUSH
76432: LD_INT 1
76434: PUSH
76435: LD_INT 1
76437: NEG
76438: PUSH
76439: EMPTY
76440: LIST
76441: LIST
76442: PUSH
76443: LD_INT 2
76445: PUSH
76446: LD_INT 0
76448: PUSH
76449: EMPTY
76450: LIST
76451: LIST
76452: PUSH
76453: LD_INT 2
76455: PUSH
76456: LD_INT 1
76458: PUSH
76459: EMPTY
76460: LIST
76461: LIST
76462: PUSH
76463: LD_INT 2
76465: PUSH
76466: LD_INT 2
76468: PUSH
76469: EMPTY
76470: LIST
76471: LIST
76472: PUSH
76473: LD_INT 1
76475: PUSH
76476: LD_INT 2
76478: PUSH
76479: EMPTY
76480: LIST
76481: LIST
76482: PUSH
76483: LD_INT 0
76485: PUSH
76486: LD_INT 2
76488: PUSH
76489: EMPTY
76490: LIST
76491: LIST
76492: PUSH
76493: LD_INT 1
76495: NEG
76496: PUSH
76497: LD_INT 1
76499: PUSH
76500: EMPTY
76501: LIST
76502: LIST
76503: PUSH
76504: LD_INT 2
76506: NEG
76507: PUSH
76508: LD_INT 0
76510: PUSH
76511: EMPTY
76512: LIST
76513: LIST
76514: PUSH
76515: LD_INT 2
76517: NEG
76518: PUSH
76519: LD_INT 1
76521: NEG
76522: PUSH
76523: EMPTY
76524: LIST
76525: LIST
76526: PUSH
76527: LD_INT 2
76529: NEG
76530: PUSH
76531: LD_INT 2
76533: NEG
76534: PUSH
76535: EMPTY
76536: LIST
76537: LIST
76538: PUSH
76539: EMPTY
76540: LIST
76541: LIST
76542: LIST
76543: LIST
76544: LIST
76545: LIST
76546: LIST
76547: LIST
76548: LIST
76549: LIST
76550: LIST
76551: LIST
76552: LIST
76553: LIST
76554: LIST
76555: LIST
76556: LIST
76557: LIST
76558: LIST
76559: ST_TO_ADDR
// Barracks3 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
76560: LD_ADDR_VAR 0 56
76564: PUSH
76565: LD_INT 0
76567: PUSH
76568: LD_INT 0
76570: PUSH
76571: EMPTY
76572: LIST
76573: LIST
76574: PUSH
76575: LD_INT 0
76577: PUSH
76578: LD_INT 1
76580: NEG
76581: PUSH
76582: EMPTY
76583: LIST
76584: LIST
76585: PUSH
76586: LD_INT 1
76588: PUSH
76589: LD_INT 0
76591: PUSH
76592: EMPTY
76593: LIST
76594: LIST
76595: PUSH
76596: LD_INT 1
76598: PUSH
76599: LD_INT 1
76601: PUSH
76602: EMPTY
76603: LIST
76604: LIST
76605: PUSH
76606: LD_INT 0
76608: PUSH
76609: LD_INT 1
76611: PUSH
76612: EMPTY
76613: LIST
76614: LIST
76615: PUSH
76616: LD_INT 1
76618: NEG
76619: PUSH
76620: LD_INT 0
76622: PUSH
76623: EMPTY
76624: LIST
76625: LIST
76626: PUSH
76627: LD_INT 1
76629: NEG
76630: PUSH
76631: LD_INT 1
76633: NEG
76634: PUSH
76635: EMPTY
76636: LIST
76637: LIST
76638: PUSH
76639: LD_INT 1
76641: NEG
76642: PUSH
76643: LD_INT 2
76645: NEG
76646: PUSH
76647: EMPTY
76648: LIST
76649: LIST
76650: PUSH
76651: LD_INT 0
76653: PUSH
76654: LD_INT 2
76656: NEG
76657: PUSH
76658: EMPTY
76659: LIST
76660: LIST
76661: PUSH
76662: LD_INT 1
76664: PUSH
76665: LD_INT 1
76667: NEG
76668: PUSH
76669: EMPTY
76670: LIST
76671: LIST
76672: PUSH
76673: LD_INT 2
76675: PUSH
76676: LD_INT 0
76678: PUSH
76679: EMPTY
76680: LIST
76681: LIST
76682: PUSH
76683: LD_INT 2
76685: PUSH
76686: LD_INT 1
76688: PUSH
76689: EMPTY
76690: LIST
76691: LIST
76692: PUSH
76693: LD_INT 2
76695: PUSH
76696: LD_INT 2
76698: PUSH
76699: EMPTY
76700: LIST
76701: LIST
76702: PUSH
76703: LD_INT 1
76705: PUSH
76706: LD_INT 2
76708: PUSH
76709: EMPTY
76710: LIST
76711: LIST
76712: PUSH
76713: LD_INT 0
76715: PUSH
76716: LD_INT 2
76718: PUSH
76719: EMPTY
76720: LIST
76721: LIST
76722: PUSH
76723: LD_INT 1
76725: NEG
76726: PUSH
76727: LD_INT 1
76729: PUSH
76730: EMPTY
76731: LIST
76732: LIST
76733: PUSH
76734: LD_INT 2
76736: NEG
76737: PUSH
76738: LD_INT 0
76740: PUSH
76741: EMPTY
76742: LIST
76743: LIST
76744: PUSH
76745: LD_INT 2
76747: NEG
76748: PUSH
76749: LD_INT 1
76751: NEG
76752: PUSH
76753: EMPTY
76754: LIST
76755: LIST
76756: PUSH
76757: LD_INT 2
76759: NEG
76760: PUSH
76761: LD_INT 2
76763: NEG
76764: PUSH
76765: EMPTY
76766: LIST
76767: LIST
76768: PUSH
76769: EMPTY
76770: LIST
76771: LIST
76772: LIST
76773: LIST
76774: LIST
76775: LIST
76776: LIST
76777: LIST
76778: LIST
76779: LIST
76780: LIST
76781: LIST
76782: LIST
76783: LIST
76784: LIST
76785: LIST
76786: LIST
76787: LIST
76788: LIST
76789: ST_TO_ADDR
// Barracks4 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
76790: LD_ADDR_VAR 0 57
76794: PUSH
76795: LD_INT 0
76797: PUSH
76798: LD_INT 0
76800: PUSH
76801: EMPTY
76802: LIST
76803: LIST
76804: PUSH
76805: LD_INT 0
76807: PUSH
76808: LD_INT 1
76810: NEG
76811: PUSH
76812: EMPTY
76813: LIST
76814: LIST
76815: PUSH
76816: LD_INT 1
76818: PUSH
76819: LD_INT 0
76821: PUSH
76822: EMPTY
76823: LIST
76824: LIST
76825: PUSH
76826: LD_INT 1
76828: PUSH
76829: LD_INT 1
76831: PUSH
76832: EMPTY
76833: LIST
76834: LIST
76835: PUSH
76836: LD_INT 0
76838: PUSH
76839: LD_INT 1
76841: PUSH
76842: EMPTY
76843: LIST
76844: LIST
76845: PUSH
76846: LD_INT 1
76848: NEG
76849: PUSH
76850: LD_INT 0
76852: PUSH
76853: EMPTY
76854: LIST
76855: LIST
76856: PUSH
76857: LD_INT 1
76859: NEG
76860: PUSH
76861: LD_INT 1
76863: NEG
76864: PUSH
76865: EMPTY
76866: LIST
76867: LIST
76868: PUSH
76869: LD_INT 1
76871: NEG
76872: PUSH
76873: LD_INT 2
76875: NEG
76876: PUSH
76877: EMPTY
76878: LIST
76879: LIST
76880: PUSH
76881: LD_INT 0
76883: PUSH
76884: LD_INT 2
76886: NEG
76887: PUSH
76888: EMPTY
76889: LIST
76890: LIST
76891: PUSH
76892: LD_INT 1
76894: PUSH
76895: LD_INT 1
76897: NEG
76898: PUSH
76899: EMPTY
76900: LIST
76901: LIST
76902: PUSH
76903: LD_INT 2
76905: PUSH
76906: LD_INT 0
76908: PUSH
76909: EMPTY
76910: LIST
76911: LIST
76912: PUSH
76913: LD_INT 2
76915: PUSH
76916: LD_INT 1
76918: PUSH
76919: EMPTY
76920: LIST
76921: LIST
76922: PUSH
76923: LD_INT 2
76925: PUSH
76926: LD_INT 2
76928: PUSH
76929: EMPTY
76930: LIST
76931: LIST
76932: PUSH
76933: LD_INT 1
76935: PUSH
76936: LD_INT 2
76938: PUSH
76939: EMPTY
76940: LIST
76941: LIST
76942: PUSH
76943: LD_INT 0
76945: PUSH
76946: LD_INT 2
76948: PUSH
76949: EMPTY
76950: LIST
76951: LIST
76952: PUSH
76953: LD_INT 1
76955: NEG
76956: PUSH
76957: LD_INT 1
76959: PUSH
76960: EMPTY
76961: LIST
76962: LIST
76963: PUSH
76964: LD_INT 2
76966: NEG
76967: PUSH
76968: LD_INT 0
76970: PUSH
76971: EMPTY
76972: LIST
76973: LIST
76974: PUSH
76975: LD_INT 2
76977: NEG
76978: PUSH
76979: LD_INT 1
76981: NEG
76982: PUSH
76983: EMPTY
76984: LIST
76985: LIST
76986: PUSH
76987: LD_INT 2
76989: NEG
76990: PUSH
76991: LD_INT 2
76993: NEG
76994: PUSH
76995: EMPTY
76996: LIST
76997: LIST
76998: PUSH
76999: EMPTY
77000: LIST
77001: LIST
77002: LIST
77003: LIST
77004: LIST
77005: LIST
77006: LIST
77007: LIST
77008: LIST
77009: LIST
77010: LIST
77011: LIST
77012: LIST
77013: LIST
77014: LIST
77015: LIST
77016: LIST
77017: LIST
77018: LIST
77019: ST_TO_ADDR
// Barracks5 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
77020: LD_ADDR_VAR 0 58
77024: PUSH
77025: LD_INT 0
77027: PUSH
77028: LD_INT 0
77030: PUSH
77031: EMPTY
77032: LIST
77033: LIST
77034: PUSH
77035: LD_INT 0
77037: PUSH
77038: LD_INT 1
77040: NEG
77041: PUSH
77042: EMPTY
77043: LIST
77044: LIST
77045: PUSH
77046: LD_INT 1
77048: PUSH
77049: LD_INT 0
77051: PUSH
77052: EMPTY
77053: LIST
77054: LIST
77055: PUSH
77056: LD_INT 1
77058: PUSH
77059: LD_INT 1
77061: PUSH
77062: EMPTY
77063: LIST
77064: LIST
77065: PUSH
77066: LD_INT 0
77068: PUSH
77069: LD_INT 1
77071: PUSH
77072: EMPTY
77073: LIST
77074: LIST
77075: PUSH
77076: LD_INT 1
77078: NEG
77079: PUSH
77080: LD_INT 0
77082: PUSH
77083: EMPTY
77084: LIST
77085: LIST
77086: PUSH
77087: LD_INT 1
77089: NEG
77090: PUSH
77091: LD_INT 1
77093: NEG
77094: PUSH
77095: EMPTY
77096: LIST
77097: LIST
77098: PUSH
77099: LD_INT 1
77101: NEG
77102: PUSH
77103: LD_INT 2
77105: NEG
77106: PUSH
77107: EMPTY
77108: LIST
77109: LIST
77110: PUSH
77111: LD_INT 0
77113: PUSH
77114: LD_INT 2
77116: NEG
77117: PUSH
77118: EMPTY
77119: LIST
77120: LIST
77121: PUSH
77122: LD_INT 1
77124: PUSH
77125: LD_INT 1
77127: NEG
77128: PUSH
77129: EMPTY
77130: LIST
77131: LIST
77132: PUSH
77133: LD_INT 2
77135: PUSH
77136: LD_INT 0
77138: PUSH
77139: EMPTY
77140: LIST
77141: LIST
77142: PUSH
77143: LD_INT 2
77145: PUSH
77146: LD_INT 1
77148: PUSH
77149: EMPTY
77150: LIST
77151: LIST
77152: PUSH
77153: LD_INT 2
77155: PUSH
77156: LD_INT 2
77158: PUSH
77159: EMPTY
77160: LIST
77161: LIST
77162: PUSH
77163: LD_INT 1
77165: PUSH
77166: LD_INT 2
77168: PUSH
77169: EMPTY
77170: LIST
77171: LIST
77172: PUSH
77173: LD_INT 0
77175: PUSH
77176: LD_INT 2
77178: PUSH
77179: EMPTY
77180: LIST
77181: LIST
77182: PUSH
77183: LD_INT 1
77185: NEG
77186: PUSH
77187: LD_INT 1
77189: PUSH
77190: EMPTY
77191: LIST
77192: LIST
77193: PUSH
77194: LD_INT 2
77196: NEG
77197: PUSH
77198: LD_INT 0
77200: PUSH
77201: EMPTY
77202: LIST
77203: LIST
77204: PUSH
77205: LD_INT 2
77207: NEG
77208: PUSH
77209: LD_INT 1
77211: NEG
77212: PUSH
77213: EMPTY
77214: LIST
77215: LIST
77216: PUSH
77217: LD_INT 2
77219: NEG
77220: PUSH
77221: LD_INT 2
77223: NEG
77224: PUSH
77225: EMPTY
77226: LIST
77227: LIST
77228: PUSH
77229: EMPTY
77230: LIST
77231: LIST
77232: LIST
77233: LIST
77234: LIST
77235: LIST
77236: LIST
77237: LIST
77238: LIST
77239: LIST
77240: LIST
77241: LIST
77242: LIST
77243: LIST
77244: LIST
77245: LIST
77246: LIST
77247: LIST
77248: LIST
77249: ST_TO_ADDR
// Bunker0 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] ] ;
77250: LD_ADDR_VAR 0 59
77254: PUSH
77255: LD_INT 0
77257: PUSH
77258: LD_INT 0
77260: PUSH
77261: EMPTY
77262: LIST
77263: LIST
77264: PUSH
77265: LD_INT 0
77267: PUSH
77268: LD_INT 1
77270: NEG
77271: PUSH
77272: EMPTY
77273: LIST
77274: LIST
77275: PUSH
77276: LD_INT 1
77278: PUSH
77279: LD_INT 0
77281: PUSH
77282: EMPTY
77283: LIST
77284: LIST
77285: PUSH
77286: LD_INT 1
77288: PUSH
77289: LD_INT 1
77291: PUSH
77292: EMPTY
77293: LIST
77294: LIST
77295: PUSH
77296: LD_INT 0
77298: PUSH
77299: LD_INT 1
77301: PUSH
77302: EMPTY
77303: LIST
77304: LIST
77305: PUSH
77306: LD_INT 1
77308: NEG
77309: PUSH
77310: LD_INT 0
77312: PUSH
77313: EMPTY
77314: LIST
77315: LIST
77316: PUSH
77317: LD_INT 1
77319: NEG
77320: PUSH
77321: LD_INT 1
77323: NEG
77324: PUSH
77325: EMPTY
77326: LIST
77327: LIST
77328: PUSH
77329: EMPTY
77330: LIST
77331: LIST
77332: LIST
77333: LIST
77334: LIST
77335: LIST
77336: LIST
77337: ST_TO_ADDR
// Bunker1 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] ] ;
77338: LD_ADDR_VAR 0 60
77342: PUSH
77343: LD_INT 0
77345: PUSH
77346: LD_INT 0
77348: PUSH
77349: EMPTY
77350: LIST
77351: LIST
77352: PUSH
77353: LD_INT 0
77355: PUSH
77356: LD_INT 1
77358: NEG
77359: PUSH
77360: EMPTY
77361: LIST
77362: LIST
77363: PUSH
77364: LD_INT 1
77366: PUSH
77367: LD_INT 0
77369: PUSH
77370: EMPTY
77371: LIST
77372: LIST
77373: PUSH
77374: LD_INT 1
77376: PUSH
77377: LD_INT 1
77379: PUSH
77380: EMPTY
77381: LIST
77382: LIST
77383: PUSH
77384: LD_INT 0
77386: PUSH
77387: LD_INT 1
77389: PUSH
77390: EMPTY
77391: LIST
77392: LIST
77393: PUSH
77394: LD_INT 1
77396: NEG
77397: PUSH
77398: LD_INT 0
77400: PUSH
77401: EMPTY
77402: LIST
77403: LIST
77404: PUSH
77405: LD_INT 1
77407: NEG
77408: PUSH
77409: LD_INT 1
77411: NEG
77412: PUSH
77413: EMPTY
77414: LIST
77415: LIST
77416: PUSH
77417: EMPTY
77418: LIST
77419: LIST
77420: LIST
77421: LIST
77422: LIST
77423: LIST
77424: LIST
77425: ST_TO_ADDR
// Bunker2 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] ] ;
77426: LD_ADDR_VAR 0 61
77430: PUSH
77431: LD_INT 0
77433: PUSH
77434: LD_INT 0
77436: PUSH
77437: EMPTY
77438: LIST
77439: LIST
77440: PUSH
77441: LD_INT 0
77443: PUSH
77444: LD_INT 1
77446: NEG
77447: PUSH
77448: EMPTY
77449: LIST
77450: LIST
77451: PUSH
77452: LD_INT 1
77454: PUSH
77455: LD_INT 0
77457: PUSH
77458: EMPTY
77459: LIST
77460: LIST
77461: PUSH
77462: LD_INT 1
77464: PUSH
77465: LD_INT 1
77467: PUSH
77468: EMPTY
77469: LIST
77470: LIST
77471: PUSH
77472: LD_INT 0
77474: PUSH
77475: LD_INT 1
77477: PUSH
77478: EMPTY
77479: LIST
77480: LIST
77481: PUSH
77482: LD_INT 1
77484: NEG
77485: PUSH
77486: LD_INT 0
77488: PUSH
77489: EMPTY
77490: LIST
77491: LIST
77492: PUSH
77493: LD_INT 1
77495: NEG
77496: PUSH
77497: LD_INT 1
77499: NEG
77500: PUSH
77501: EMPTY
77502: LIST
77503: LIST
77504: PUSH
77505: EMPTY
77506: LIST
77507: LIST
77508: LIST
77509: LIST
77510: LIST
77511: LIST
77512: LIST
77513: ST_TO_ADDR
// Bunker3 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] ] ;
77514: LD_ADDR_VAR 0 62
77518: PUSH
77519: LD_INT 0
77521: PUSH
77522: LD_INT 0
77524: PUSH
77525: EMPTY
77526: LIST
77527: LIST
77528: PUSH
77529: LD_INT 0
77531: PUSH
77532: LD_INT 1
77534: NEG
77535: PUSH
77536: EMPTY
77537: LIST
77538: LIST
77539: PUSH
77540: LD_INT 1
77542: PUSH
77543: LD_INT 0
77545: PUSH
77546: EMPTY
77547: LIST
77548: LIST
77549: PUSH
77550: LD_INT 1
77552: PUSH
77553: LD_INT 1
77555: PUSH
77556: EMPTY
77557: LIST
77558: LIST
77559: PUSH
77560: LD_INT 0
77562: PUSH
77563: LD_INT 1
77565: PUSH
77566: EMPTY
77567: LIST
77568: LIST
77569: PUSH
77570: LD_INT 1
77572: NEG
77573: PUSH
77574: LD_INT 0
77576: PUSH
77577: EMPTY
77578: LIST
77579: LIST
77580: PUSH
77581: LD_INT 1
77583: NEG
77584: PUSH
77585: LD_INT 1
77587: NEG
77588: PUSH
77589: EMPTY
77590: LIST
77591: LIST
77592: PUSH
77593: EMPTY
77594: LIST
77595: LIST
77596: LIST
77597: LIST
77598: LIST
77599: LIST
77600: LIST
77601: ST_TO_ADDR
// Bunker4 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] ] ;
77602: LD_ADDR_VAR 0 63
77606: PUSH
77607: LD_INT 0
77609: PUSH
77610: LD_INT 0
77612: PUSH
77613: EMPTY
77614: LIST
77615: LIST
77616: PUSH
77617: LD_INT 0
77619: PUSH
77620: LD_INT 1
77622: NEG
77623: PUSH
77624: EMPTY
77625: LIST
77626: LIST
77627: PUSH
77628: LD_INT 1
77630: PUSH
77631: LD_INT 0
77633: PUSH
77634: EMPTY
77635: LIST
77636: LIST
77637: PUSH
77638: LD_INT 1
77640: PUSH
77641: LD_INT 1
77643: PUSH
77644: EMPTY
77645: LIST
77646: LIST
77647: PUSH
77648: LD_INT 0
77650: PUSH
77651: LD_INT 1
77653: PUSH
77654: EMPTY
77655: LIST
77656: LIST
77657: PUSH
77658: LD_INT 1
77660: NEG
77661: PUSH
77662: LD_INT 0
77664: PUSH
77665: EMPTY
77666: LIST
77667: LIST
77668: PUSH
77669: LD_INT 1
77671: NEG
77672: PUSH
77673: LD_INT 1
77675: NEG
77676: PUSH
77677: EMPTY
77678: LIST
77679: LIST
77680: PUSH
77681: EMPTY
77682: LIST
77683: LIST
77684: LIST
77685: LIST
77686: LIST
77687: LIST
77688: LIST
77689: ST_TO_ADDR
// Bunker5 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] ] ;
77690: LD_ADDR_VAR 0 64
77694: PUSH
77695: LD_INT 0
77697: PUSH
77698: LD_INT 0
77700: PUSH
77701: EMPTY
77702: LIST
77703: LIST
77704: PUSH
77705: LD_INT 0
77707: PUSH
77708: LD_INT 1
77710: NEG
77711: PUSH
77712: EMPTY
77713: LIST
77714: LIST
77715: PUSH
77716: LD_INT 1
77718: PUSH
77719: LD_INT 0
77721: PUSH
77722: EMPTY
77723: LIST
77724: LIST
77725: PUSH
77726: LD_INT 1
77728: PUSH
77729: LD_INT 1
77731: PUSH
77732: EMPTY
77733: LIST
77734: LIST
77735: PUSH
77736: LD_INT 0
77738: PUSH
77739: LD_INT 1
77741: PUSH
77742: EMPTY
77743: LIST
77744: LIST
77745: PUSH
77746: LD_INT 1
77748: NEG
77749: PUSH
77750: LD_INT 0
77752: PUSH
77753: EMPTY
77754: LIST
77755: LIST
77756: PUSH
77757: LD_INT 1
77759: NEG
77760: PUSH
77761: LD_INT 1
77763: NEG
77764: PUSH
77765: EMPTY
77766: LIST
77767: LIST
77768: PUSH
77769: EMPTY
77770: LIST
77771: LIST
77772: LIST
77773: LIST
77774: LIST
77775: LIST
77776: LIST
77777: ST_TO_ADDR
// end ; 1 :
77778: GO 83675
77780: LD_INT 1
77782: DOUBLE
77783: EQUAL
77784: IFTRUE 77788
77786: GO 80411
77788: POP
// begin DepotAm0 = [ [ - 1 , - 3 ] , [ 0 , - 3 ] , [ 1 , - 2 ] ] ;
77789: LD_ADDR_VAR 0 11
77793: PUSH
77794: LD_INT 1
77796: NEG
77797: PUSH
77798: LD_INT 3
77800: NEG
77801: PUSH
77802: EMPTY
77803: LIST
77804: LIST
77805: PUSH
77806: LD_INT 0
77808: PUSH
77809: LD_INT 3
77811: NEG
77812: PUSH
77813: EMPTY
77814: LIST
77815: LIST
77816: PUSH
77817: LD_INT 1
77819: PUSH
77820: LD_INT 2
77822: NEG
77823: PUSH
77824: EMPTY
77825: LIST
77826: LIST
77827: PUSH
77828: EMPTY
77829: LIST
77830: LIST
77831: LIST
77832: ST_TO_ADDR
// DepotAm1 = [ [ 2 , - 1 ] , [ 3 , 0 ] , [ 3 , 1 ] ] ;
77833: LD_ADDR_VAR 0 12
77837: PUSH
77838: LD_INT 2
77840: PUSH
77841: LD_INT 1
77843: NEG
77844: PUSH
77845: EMPTY
77846: LIST
77847: LIST
77848: PUSH
77849: LD_INT 3
77851: PUSH
77852: LD_INT 0
77854: PUSH
77855: EMPTY
77856: LIST
77857: LIST
77858: PUSH
77859: LD_INT 3
77861: PUSH
77862: LD_INT 1
77864: PUSH
77865: EMPTY
77866: LIST
77867: LIST
77868: PUSH
77869: EMPTY
77870: LIST
77871: LIST
77872: LIST
77873: ST_TO_ADDR
// DepotAm2 = [ [ 3 , 2 ] , [ 3 , 3 ] , [ 2 , 3 ] ] ;
77874: LD_ADDR_VAR 0 13
77878: PUSH
77879: LD_INT 3
77881: PUSH
77882: LD_INT 2
77884: PUSH
77885: EMPTY
77886: LIST
77887: LIST
77888: PUSH
77889: LD_INT 3
77891: PUSH
77892: LD_INT 3
77894: PUSH
77895: EMPTY
77896: LIST
77897: LIST
77898: PUSH
77899: LD_INT 2
77901: PUSH
77902: LD_INT 3
77904: PUSH
77905: EMPTY
77906: LIST
77907: LIST
77908: PUSH
77909: EMPTY
77910: LIST
77911: LIST
77912: LIST
77913: ST_TO_ADDR
// DepotAm3 = [ [ 1 , 3 ] , [ 0 , 3 ] , [ - 1 , 2 ] ] ;
77914: LD_ADDR_VAR 0 14
77918: PUSH
77919: LD_INT 1
77921: PUSH
77922: LD_INT 3
77924: PUSH
77925: EMPTY
77926: LIST
77927: LIST
77928: PUSH
77929: LD_INT 0
77931: PUSH
77932: LD_INT 3
77934: PUSH
77935: EMPTY
77936: LIST
77937: LIST
77938: PUSH
77939: LD_INT 1
77941: NEG
77942: PUSH
77943: LD_INT 2
77945: PUSH
77946: EMPTY
77947: LIST
77948: LIST
77949: PUSH
77950: EMPTY
77951: LIST
77952: LIST
77953: LIST
77954: ST_TO_ADDR
// DepotAm4 = [ [ - 2 , 1 ] , [ - 3 , 0 ] , [ - 3 , - 1 ] ] ;
77955: LD_ADDR_VAR 0 15
77959: PUSH
77960: LD_INT 2
77962: NEG
77963: PUSH
77964: LD_INT 1
77966: PUSH
77967: EMPTY
77968: LIST
77969: LIST
77970: PUSH
77971: LD_INT 3
77973: NEG
77974: PUSH
77975: LD_INT 0
77977: PUSH
77978: EMPTY
77979: LIST
77980: LIST
77981: PUSH
77982: LD_INT 3
77984: NEG
77985: PUSH
77986: LD_INT 1
77988: NEG
77989: PUSH
77990: EMPTY
77991: LIST
77992: LIST
77993: PUSH
77994: EMPTY
77995: LIST
77996: LIST
77997: LIST
77998: ST_TO_ADDR
// DepotAm5 = [ [ - 2 , - 3 ] , [ - 3 , - 2 ] , [ - 3 , - 3 ] ] ;
77999: LD_ADDR_VAR 0 16
78003: PUSH
78004: LD_INT 2
78006: NEG
78007: PUSH
78008: LD_INT 3
78010: NEG
78011: PUSH
78012: EMPTY
78013: LIST
78014: LIST
78015: PUSH
78016: LD_INT 3
78018: NEG
78019: PUSH
78020: LD_INT 2
78022: NEG
78023: PUSH
78024: EMPTY
78025: LIST
78026: LIST
78027: PUSH
78028: LD_INT 3
78030: NEG
78031: PUSH
78032: LD_INT 3
78034: NEG
78035: PUSH
78036: EMPTY
78037: LIST
78038: LIST
78039: PUSH
78040: EMPTY
78041: LIST
78042: LIST
78043: LIST
78044: ST_TO_ADDR
// DepotAr0 = [ [ - 1 , - 3 ] , [ 0 , - 3 ] , [ 1 , - 2 ] ] ;
78045: LD_ADDR_VAR 0 17
78049: PUSH
78050: LD_INT 1
78052: NEG
78053: PUSH
78054: LD_INT 3
78056: NEG
78057: PUSH
78058: EMPTY
78059: LIST
78060: LIST
78061: PUSH
78062: LD_INT 0
78064: PUSH
78065: LD_INT 3
78067: NEG
78068: PUSH
78069: EMPTY
78070: LIST
78071: LIST
78072: PUSH
78073: LD_INT 1
78075: PUSH
78076: LD_INT 2
78078: NEG
78079: PUSH
78080: EMPTY
78081: LIST
78082: LIST
78083: PUSH
78084: EMPTY
78085: LIST
78086: LIST
78087: LIST
78088: ST_TO_ADDR
// DepotAr1 = [ [ 2 , - 1 ] , [ 3 , 0 ] , [ 3 , 1 ] ] ;
78089: LD_ADDR_VAR 0 18
78093: PUSH
78094: LD_INT 2
78096: PUSH
78097: LD_INT 1
78099: NEG
78100: PUSH
78101: EMPTY
78102: LIST
78103: LIST
78104: PUSH
78105: LD_INT 3
78107: PUSH
78108: LD_INT 0
78110: PUSH
78111: EMPTY
78112: LIST
78113: LIST
78114: PUSH
78115: LD_INT 3
78117: PUSH
78118: LD_INT 1
78120: PUSH
78121: EMPTY
78122: LIST
78123: LIST
78124: PUSH
78125: EMPTY
78126: LIST
78127: LIST
78128: LIST
78129: ST_TO_ADDR
// DepotAr2 = [ [ 3 , 2 ] , [ 3 , 3 ] , [ 2 , 3 ] ] ;
78130: LD_ADDR_VAR 0 19
78134: PUSH
78135: LD_INT 3
78137: PUSH
78138: LD_INT 2
78140: PUSH
78141: EMPTY
78142: LIST
78143: LIST
78144: PUSH
78145: LD_INT 3
78147: PUSH
78148: LD_INT 3
78150: PUSH
78151: EMPTY
78152: LIST
78153: LIST
78154: PUSH
78155: LD_INT 2
78157: PUSH
78158: LD_INT 3
78160: PUSH
78161: EMPTY
78162: LIST
78163: LIST
78164: PUSH
78165: EMPTY
78166: LIST
78167: LIST
78168: LIST
78169: ST_TO_ADDR
// DepotAr3 = [ [ 1 , 3 ] , [ 0 , 3 ] , [ - 1 , 2 ] ] ;
78170: LD_ADDR_VAR 0 20
78174: PUSH
78175: LD_INT 1
78177: PUSH
78178: LD_INT 3
78180: PUSH
78181: EMPTY
78182: LIST
78183: LIST
78184: PUSH
78185: LD_INT 0
78187: PUSH
78188: LD_INT 3
78190: PUSH
78191: EMPTY
78192: LIST
78193: LIST
78194: PUSH
78195: LD_INT 1
78197: NEG
78198: PUSH
78199: LD_INT 2
78201: PUSH
78202: EMPTY
78203: LIST
78204: LIST
78205: PUSH
78206: EMPTY
78207: LIST
78208: LIST
78209: LIST
78210: ST_TO_ADDR
// DepotAr4 = [ [ - 2 , 1 ] , [ - 3 , 0 ] , [ - 3 , - 1 ] ] ;
78211: LD_ADDR_VAR 0 21
78215: PUSH
78216: LD_INT 2
78218: NEG
78219: PUSH
78220: LD_INT 1
78222: PUSH
78223: EMPTY
78224: LIST
78225: LIST
78226: PUSH
78227: LD_INT 3
78229: NEG
78230: PUSH
78231: LD_INT 0
78233: PUSH
78234: EMPTY
78235: LIST
78236: LIST
78237: PUSH
78238: LD_INT 3
78240: NEG
78241: PUSH
78242: LD_INT 1
78244: NEG
78245: PUSH
78246: EMPTY
78247: LIST
78248: LIST
78249: PUSH
78250: EMPTY
78251: LIST
78252: LIST
78253: LIST
78254: ST_TO_ADDR
// DepotAr5 = [ [ - 2 , - 3 ] , [ - 3 , - 2 ] , [ - 3 , - 3 ] ] ;
78255: LD_ADDR_VAR 0 22
78259: PUSH
78260: LD_INT 2
78262: NEG
78263: PUSH
78264: LD_INT 3
78266: NEG
78267: PUSH
78268: EMPTY
78269: LIST
78270: LIST
78271: PUSH
78272: LD_INT 3
78274: NEG
78275: PUSH
78276: LD_INT 2
78278: NEG
78279: PUSH
78280: EMPTY
78281: LIST
78282: LIST
78283: PUSH
78284: LD_INT 3
78286: NEG
78287: PUSH
78288: LD_INT 3
78290: NEG
78291: PUSH
78292: EMPTY
78293: LIST
78294: LIST
78295: PUSH
78296: EMPTY
78297: LIST
78298: LIST
78299: LIST
78300: ST_TO_ADDR
// DepotRu0 = [ [ 0 , - 3 ] , [ - 1 , - 4 ] , [ 1 , - 3 ] ] ;
78301: LD_ADDR_VAR 0 23
78305: PUSH
78306: LD_INT 0
78308: PUSH
78309: LD_INT 3
78311: NEG
78312: PUSH
78313: EMPTY
78314: LIST
78315: LIST
78316: PUSH
78317: LD_INT 1
78319: NEG
78320: PUSH
78321: LD_INT 4
78323: NEG
78324: PUSH
78325: EMPTY
78326: LIST
78327: LIST
78328: PUSH
78329: LD_INT 1
78331: PUSH
78332: LD_INT 3
78334: NEG
78335: PUSH
78336: EMPTY
78337: LIST
78338: LIST
78339: PUSH
78340: EMPTY
78341: LIST
78342: LIST
78343: LIST
78344: ST_TO_ADDR
// DepotRu1 = [ [ 3 , 0 ] , [ 3 , - 1 ] , [ 4 , 1 ] ] ;
78345: LD_ADDR_VAR 0 24
78349: PUSH
78350: LD_INT 3
78352: PUSH
78353: LD_INT 0
78355: PUSH
78356: EMPTY
78357: LIST
78358: LIST
78359: PUSH
78360: LD_INT 3
78362: PUSH
78363: LD_INT 1
78365: NEG
78366: PUSH
78367: EMPTY
78368: LIST
78369: LIST
78370: PUSH
78371: LD_INT 4
78373: PUSH
78374: LD_INT 1
78376: PUSH
78377: EMPTY
78378: LIST
78379: LIST
78380: PUSH
78381: EMPTY
78382: LIST
78383: LIST
78384: LIST
78385: ST_TO_ADDR
// DepotRu2 = [ [ 3 , 3 ] , [ 4 , 3 ] , [ 3 , 4 ] ] ;
78386: LD_ADDR_VAR 0 25
78390: PUSH
78391: LD_INT 3
78393: PUSH
78394: LD_INT 3
78396: PUSH
78397: EMPTY
78398: LIST
78399: LIST
78400: PUSH
78401: LD_INT 4
78403: PUSH
78404: LD_INT 3
78406: PUSH
78407: EMPTY
78408: LIST
78409: LIST
78410: PUSH
78411: LD_INT 3
78413: PUSH
78414: LD_INT 4
78416: PUSH
78417: EMPTY
78418: LIST
78419: LIST
78420: PUSH
78421: EMPTY
78422: LIST
78423: LIST
78424: LIST
78425: ST_TO_ADDR
// DepotRu3 = [ [ 0 , 3 ] , [ 1 , 4 ] , [ - 1 , 3 ] ] ;
78426: LD_ADDR_VAR 0 26
78430: PUSH
78431: LD_INT 0
78433: PUSH
78434: LD_INT 3
78436: PUSH
78437: EMPTY
78438: LIST
78439: LIST
78440: PUSH
78441: LD_INT 1
78443: PUSH
78444: LD_INT 4
78446: PUSH
78447: EMPTY
78448: LIST
78449: LIST
78450: PUSH
78451: LD_INT 1
78453: NEG
78454: PUSH
78455: LD_INT 3
78457: PUSH
78458: EMPTY
78459: LIST
78460: LIST
78461: PUSH
78462: EMPTY
78463: LIST
78464: LIST
78465: LIST
78466: ST_TO_ADDR
// DepotRu4 = [ [ - 3 , 0 ] , [ - 3 , 1 ] , [ - 4 , - 1 ] ] ;
78467: LD_ADDR_VAR 0 27
78471: PUSH
78472: LD_INT 3
78474: NEG
78475: PUSH
78476: LD_INT 0
78478: PUSH
78479: EMPTY
78480: LIST
78481: LIST
78482: PUSH
78483: LD_INT 3
78485: NEG
78486: PUSH
78487: LD_INT 1
78489: PUSH
78490: EMPTY
78491: LIST
78492: LIST
78493: PUSH
78494: LD_INT 4
78496: NEG
78497: PUSH
78498: LD_INT 1
78500: NEG
78501: PUSH
78502: EMPTY
78503: LIST
78504: LIST
78505: PUSH
78506: EMPTY
78507: LIST
78508: LIST
78509: LIST
78510: ST_TO_ADDR
// DepotRu5 = [ [ - 3 , - 3 ] , [ - 3 , - 4 ] , [ - 4 , - 3 ] ] ;
78511: LD_ADDR_VAR 0 28
78515: PUSH
78516: LD_INT 3
78518: NEG
78519: PUSH
78520: LD_INT 3
78522: NEG
78523: PUSH
78524: EMPTY
78525: LIST
78526: LIST
78527: PUSH
78528: LD_INT 3
78530: NEG
78531: PUSH
78532: LD_INT 4
78534: NEG
78535: PUSH
78536: EMPTY
78537: LIST
78538: LIST
78539: PUSH
78540: LD_INT 4
78542: NEG
78543: PUSH
78544: LD_INT 3
78546: NEG
78547: PUSH
78548: EMPTY
78549: LIST
78550: LIST
78551: PUSH
78552: EMPTY
78553: LIST
78554: LIST
78555: LIST
78556: ST_TO_ADDR
// Factory0 = [ [ - 1 , - 3 ] , [ 0 , - 3 ] , [ 1 , - 2 ] , [ - 1 , - 4 ] , [ 0 , - 4 ] , [ 1 , - 3 ] , [ - 1 , - 5 ] , [ 0 , - 5 ] , [ 1 , - 4 ] , [ - 1 , - 6 ] , [ 0 , - 6 ] , [ 1 , - 5 ] ] ;
78557: LD_ADDR_VAR 0 29
78561: PUSH
78562: LD_INT 1
78564: NEG
78565: PUSH
78566: LD_INT 3
78568: NEG
78569: PUSH
78570: EMPTY
78571: LIST
78572: LIST
78573: PUSH
78574: LD_INT 0
78576: PUSH
78577: LD_INT 3
78579: NEG
78580: PUSH
78581: EMPTY
78582: LIST
78583: LIST
78584: PUSH
78585: LD_INT 1
78587: PUSH
78588: LD_INT 2
78590: NEG
78591: PUSH
78592: EMPTY
78593: LIST
78594: LIST
78595: PUSH
78596: LD_INT 1
78598: NEG
78599: PUSH
78600: LD_INT 4
78602: NEG
78603: PUSH
78604: EMPTY
78605: LIST
78606: LIST
78607: PUSH
78608: LD_INT 0
78610: PUSH
78611: LD_INT 4
78613: NEG
78614: PUSH
78615: EMPTY
78616: LIST
78617: LIST
78618: PUSH
78619: LD_INT 1
78621: PUSH
78622: LD_INT 3
78624: NEG
78625: PUSH
78626: EMPTY
78627: LIST
78628: LIST
78629: PUSH
78630: LD_INT 1
78632: NEG
78633: PUSH
78634: LD_INT 5
78636: NEG
78637: PUSH
78638: EMPTY
78639: LIST
78640: LIST
78641: PUSH
78642: LD_INT 0
78644: PUSH
78645: LD_INT 5
78647: NEG
78648: PUSH
78649: EMPTY
78650: LIST
78651: LIST
78652: PUSH
78653: LD_INT 1
78655: PUSH
78656: LD_INT 4
78658: NEG
78659: PUSH
78660: EMPTY
78661: LIST
78662: LIST
78663: PUSH
78664: LD_INT 1
78666: NEG
78667: PUSH
78668: LD_INT 6
78670: NEG
78671: PUSH
78672: EMPTY
78673: LIST
78674: LIST
78675: PUSH
78676: LD_INT 0
78678: PUSH
78679: LD_INT 6
78681: NEG
78682: PUSH
78683: EMPTY
78684: LIST
78685: LIST
78686: PUSH
78687: LD_INT 1
78689: PUSH
78690: LD_INT 5
78692: NEG
78693: PUSH
78694: EMPTY
78695: LIST
78696: LIST
78697: PUSH
78698: EMPTY
78699: LIST
78700: LIST
78701: LIST
78702: LIST
78703: LIST
78704: LIST
78705: LIST
78706: LIST
78707: LIST
78708: LIST
78709: LIST
78710: LIST
78711: ST_TO_ADDR
// Factory1 = [ [ 2 , - 1 ] , [ 3 , 0 ] , [ 3 , 1 ] , [ 3 , - 1 ] , [ 4 , 0 ] , [ 4 , 1 ] , [ 4 , - 1 ] , [ 5 , 0 ] , [ 5 , 1 ] , [ 5 , - 1 ] , [ 6 , 0 ] , [ 6 , 1 ] ] ;
78712: LD_ADDR_VAR 0 30
78716: PUSH
78717: LD_INT 2
78719: PUSH
78720: LD_INT 1
78722: NEG
78723: PUSH
78724: EMPTY
78725: LIST
78726: LIST
78727: PUSH
78728: LD_INT 3
78730: PUSH
78731: LD_INT 0
78733: PUSH
78734: EMPTY
78735: LIST
78736: LIST
78737: PUSH
78738: LD_INT 3
78740: PUSH
78741: LD_INT 1
78743: PUSH
78744: EMPTY
78745: LIST
78746: LIST
78747: PUSH
78748: LD_INT 3
78750: PUSH
78751: LD_INT 1
78753: NEG
78754: PUSH
78755: EMPTY
78756: LIST
78757: LIST
78758: PUSH
78759: LD_INT 4
78761: PUSH
78762: LD_INT 0
78764: PUSH
78765: EMPTY
78766: LIST
78767: LIST
78768: PUSH
78769: LD_INT 4
78771: PUSH
78772: LD_INT 1
78774: PUSH
78775: EMPTY
78776: LIST
78777: LIST
78778: PUSH
78779: LD_INT 4
78781: PUSH
78782: LD_INT 1
78784: NEG
78785: PUSH
78786: EMPTY
78787: LIST
78788: LIST
78789: PUSH
78790: LD_INT 5
78792: PUSH
78793: LD_INT 0
78795: PUSH
78796: EMPTY
78797: LIST
78798: LIST
78799: PUSH
78800: LD_INT 5
78802: PUSH
78803: LD_INT 1
78805: PUSH
78806: EMPTY
78807: LIST
78808: LIST
78809: PUSH
78810: LD_INT 5
78812: PUSH
78813: LD_INT 1
78815: NEG
78816: PUSH
78817: EMPTY
78818: LIST
78819: LIST
78820: PUSH
78821: LD_INT 6
78823: PUSH
78824: LD_INT 0
78826: PUSH
78827: EMPTY
78828: LIST
78829: LIST
78830: PUSH
78831: LD_INT 6
78833: PUSH
78834: LD_INT 1
78836: PUSH
78837: EMPTY
78838: LIST
78839: LIST
78840: PUSH
78841: EMPTY
78842: LIST
78843: LIST
78844: LIST
78845: LIST
78846: LIST
78847: LIST
78848: LIST
78849: LIST
78850: LIST
78851: LIST
78852: LIST
78853: LIST
78854: ST_TO_ADDR
// Factory2 = [ [ 3 , 2 ] , [ 3 , 3 ] , [ 2 , 3 ] , [ 4 , 3 ] , [ 4 , 4 ] , [ 3 , 4 ] , [ 5 , 4 ] , [ 5 , 5 ] , [ 4 , 5 ] , [ 6 , 5 ] , [ 6 , 6 ] , [ 5 , 6 ] ] ;
78855: LD_ADDR_VAR 0 31
78859: PUSH
78860: LD_INT 3
78862: PUSH
78863: LD_INT 2
78865: PUSH
78866: EMPTY
78867: LIST
78868: LIST
78869: PUSH
78870: LD_INT 3
78872: PUSH
78873: LD_INT 3
78875: PUSH
78876: EMPTY
78877: LIST
78878: LIST
78879: PUSH
78880: LD_INT 2
78882: PUSH
78883: LD_INT 3
78885: PUSH
78886: EMPTY
78887: LIST
78888: LIST
78889: PUSH
78890: LD_INT 4
78892: PUSH
78893: LD_INT 3
78895: PUSH
78896: EMPTY
78897: LIST
78898: LIST
78899: PUSH
78900: LD_INT 4
78902: PUSH
78903: LD_INT 4
78905: PUSH
78906: EMPTY
78907: LIST
78908: LIST
78909: PUSH
78910: LD_INT 3
78912: PUSH
78913: LD_INT 4
78915: PUSH
78916: EMPTY
78917: LIST
78918: LIST
78919: PUSH
78920: LD_INT 5
78922: PUSH
78923: LD_INT 4
78925: PUSH
78926: EMPTY
78927: LIST
78928: LIST
78929: PUSH
78930: LD_INT 5
78932: PUSH
78933: LD_INT 5
78935: PUSH
78936: EMPTY
78937: LIST
78938: LIST
78939: PUSH
78940: LD_INT 4
78942: PUSH
78943: LD_INT 5
78945: PUSH
78946: EMPTY
78947: LIST
78948: LIST
78949: PUSH
78950: LD_INT 6
78952: PUSH
78953: LD_INT 5
78955: PUSH
78956: EMPTY
78957: LIST
78958: LIST
78959: PUSH
78960: LD_INT 6
78962: PUSH
78963: LD_INT 6
78965: PUSH
78966: EMPTY
78967: LIST
78968: LIST
78969: PUSH
78970: LD_INT 5
78972: PUSH
78973: LD_INT 6
78975: PUSH
78976: EMPTY
78977: LIST
78978: LIST
78979: PUSH
78980: EMPTY
78981: LIST
78982: LIST
78983: LIST
78984: LIST
78985: LIST
78986: LIST
78987: LIST
78988: LIST
78989: LIST
78990: LIST
78991: LIST
78992: LIST
78993: ST_TO_ADDR
// Factory3 = [ [ 1 , 3 ] , [ 0 , 3 ] , [ - 1 , 2 ] , [ 1 , 4 ] , [ 0 , 4 ] , [ - 1 , 3 ] , [ 1 , 5 ] , [ 0 , 5 ] , [ - 1 , 4 ] , [ 1 , 6 ] , [ 0 , 6 ] , [ - 1 , 5 ] ] ;
78994: LD_ADDR_VAR 0 32
78998: PUSH
78999: LD_INT 1
79001: PUSH
79002: LD_INT 3
79004: PUSH
79005: EMPTY
79006: LIST
79007: LIST
79008: PUSH
79009: LD_INT 0
79011: PUSH
79012: LD_INT 3
79014: PUSH
79015: EMPTY
79016: LIST
79017: LIST
79018: PUSH
79019: LD_INT 1
79021: NEG
79022: PUSH
79023: LD_INT 2
79025: PUSH
79026: EMPTY
79027: LIST
79028: LIST
79029: PUSH
79030: LD_INT 1
79032: PUSH
79033: LD_INT 4
79035: PUSH
79036: EMPTY
79037: LIST
79038: LIST
79039: PUSH
79040: LD_INT 0
79042: PUSH
79043: LD_INT 4
79045: PUSH
79046: EMPTY
79047: LIST
79048: LIST
79049: PUSH
79050: LD_INT 1
79052: NEG
79053: PUSH
79054: LD_INT 3
79056: PUSH
79057: EMPTY
79058: LIST
79059: LIST
79060: PUSH
79061: LD_INT 1
79063: PUSH
79064: LD_INT 5
79066: PUSH
79067: EMPTY
79068: LIST
79069: LIST
79070: PUSH
79071: LD_INT 0
79073: PUSH
79074: LD_INT 5
79076: PUSH
79077: EMPTY
79078: LIST
79079: LIST
79080: PUSH
79081: LD_INT 1
79083: NEG
79084: PUSH
79085: LD_INT 4
79087: PUSH
79088: EMPTY
79089: LIST
79090: LIST
79091: PUSH
79092: LD_INT 1
79094: PUSH
79095: LD_INT 6
79097: PUSH
79098: EMPTY
79099: LIST
79100: LIST
79101: PUSH
79102: LD_INT 0
79104: PUSH
79105: LD_INT 6
79107: PUSH
79108: EMPTY
79109: LIST
79110: LIST
79111: PUSH
79112: LD_INT 1
79114: NEG
79115: PUSH
79116: LD_INT 5
79118: PUSH
79119: EMPTY
79120: LIST
79121: LIST
79122: PUSH
79123: EMPTY
79124: LIST
79125: LIST
79126: LIST
79127: LIST
79128: LIST
79129: LIST
79130: LIST
79131: LIST
79132: LIST
79133: LIST
79134: LIST
79135: LIST
79136: ST_TO_ADDR
// Factory4 = [ [ - 2 , 1 ] , [ - 3 , 0 ] , [ - 3 , - 1 ] , [ - 3 , 1 ] , [ - 4 , 0 ] , [ - 4 , - 1 ] , [ - 4 , 1 ] , [ - 5 , 0 ] , [ - 5 , - 1 ] , [ - 5 , 1 ] , [ - 6 , 0 ] , [ - 6 , - 1 ] ] ;
79137: LD_ADDR_VAR 0 33
79141: PUSH
79142: LD_INT 2
79144: NEG
79145: PUSH
79146: LD_INT 1
79148: PUSH
79149: EMPTY
79150: LIST
79151: LIST
79152: PUSH
79153: LD_INT 3
79155: NEG
79156: PUSH
79157: LD_INT 0
79159: PUSH
79160: EMPTY
79161: LIST
79162: LIST
79163: PUSH
79164: LD_INT 3
79166: NEG
79167: PUSH
79168: LD_INT 1
79170: NEG
79171: PUSH
79172: EMPTY
79173: LIST
79174: LIST
79175: PUSH
79176: LD_INT 3
79178: NEG
79179: PUSH
79180: LD_INT 1
79182: PUSH
79183: EMPTY
79184: LIST
79185: LIST
79186: PUSH
79187: LD_INT 4
79189: NEG
79190: PUSH
79191: LD_INT 0
79193: PUSH
79194: EMPTY
79195: LIST
79196: LIST
79197: PUSH
79198: LD_INT 4
79200: NEG
79201: PUSH
79202: LD_INT 1
79204: NEG
79205: PUSH
79206: EMPTY
79207: LIST
79208: LIST
79209: PUSH
79210: LD_INT 4
79212: NEG
79213: PUSH
79214: LD_INT 1
79216: PUSH
79217: EMPTY
79218: LIST
79219: LIST
79220: PUSH
79221: LD_INT 5
79223: NEG
79224: PUSH
79225: LD_INT 0
79227: PUSH
79228: EMPTY
79229: LIST
79230: LIST
79231: PUSH
79232: LD_INT 5
79234: NEG
79235: PUSH
79236: LD_INT 1
79238: NEG
79239: PUSH
79240: EMPTY
79241: LIST
79242: LIST
79243: PUSH
79244: LD_INT 5
79246: NEG
79247: PUSH
79248: LD_INT 1
79250: PUSH
79251: EMPTY
79252: LIST
79253: LIST
79254: PUSH
79255: LD_INT 6
79257: NEG
79258: PUSH
79259: LD_INT 0
79261: PUSH
79262: EMPTY
79263: LIST
79264: LIST
79265: PUSH
79266: LD_INT 6
79268: NEG
79269: PUSH
79270: LD_INT 1
79272: NEG
79273: PUSH
79274: EMPTY
79275: LIST
79276: LIST
79277: PUSH
79278: EMPTY
79279: LIST
79280: LIST
79281: LIST
79282: LIST
79283: LIST
79284: LIST
79285: LIST
79286: LIST
79287: LIST
79288: LIST
79289: LIST
79290: LIST
79291: ST_TO_ADDR
// Factory5 = [ [ - 2 , - 3 ] , [ - 3 , - 2 ] , [ - 3 , - 3 ] , [ - 3 , - 4 ] , [ - 4 , - 3 ] , [ - 4 , - 4 ] , [ - 4 , - 5 ] , [ - 5 , - 4 ] , [ - 5 , - 5 ] , [ - 5 , - 6 ] , [ - 6 , - 5 ] , [ - 6 , - 6 ] ] ;
79292: LD_ADDR_VAR 0 34
79296: PUSH
79297: LD_INT 2
79299: NEG
79300: PUSH
79301: LD_INT 3
79303: NEG
79304: PUSH
79305: EMPTY
79306: LIST
79307: LIST
79308: PUSH
79309: LD_INT 3
79311: NEG
79312: PUSH
79313: LD_INT 2
79315: NEG
79316: PUSH
79317: EMPTY
79318: LIST
79319: LIST
79320: PUSH
79321: LD_INT 3
79323: NEG
79324: PUSH
79325: LD_INT 3
79327: NEG
79328: PUSH
79329: EMPTY
79330: LIST
79331: LIST
79332: PUSH
79333: LD_INT 3
79335: NEG
79336: PUSH
79337: LD_INT 4
79339: NEG
79340: PUSH
79341: EMPTY
79342: LIST
79343: LIST
79344: PUSH
79345: LD_INT 4
79347: NEG
79348: PUSH
79349: LD_INT 3
79351: NEG
79352: PUSH
79353: EMPTY
79354: LIST
79355: LIST
79356: PUSH
79357: LD_INT 4
79359: NEG
79360: PUSH
79361: LD_INT 4
79363: NEG
79364: PUSH
79365: EMPTY
79366: LIST
79367: LIST
79368: PUSH
79369: LD_INT 4
79371: NEG
79372: PUSH
79373: LD_INT 5
79375: NEG
79376: PUSH
79377: EMPTY
79378: LIST
79379: LIST
79380: PUSH
79381: LD_INT 5
79383: NEG
79384: PUSH
79385: LD_INT 4
79387: NEG
79388: PUSH
79389: EMPTY
79390: LIST
79391: LIST
79392: PUSH
79393: LD_INT 5
79395: NEG
79396: PUSH
79397: LD_INT 5
79399: NEG
79400: PUSH
79401: EMPTY
79402: LIST
79403: LIST
79404: PUSH
79405: LD_INT 5
79407: NEG
79408: PUSH
79409: LD_INT 6
79411: NEG
79412: PUSH
79413: EMPTY
79414: LIST
79415: LIST
79416: PUSH
79417: LD_INT 6
79419: NEG
79420: PUSH
79421: LD_INT 5
79423: NEG
79424: PUSH
79425: EMPTY
79426: LIST
79427: LIST
79428: PUSH
79429: LD_INT 6
79431: NEG
79432: PUSH
79433: LD_INT 6
79435: NEG
79436: PUSH
79437: EMPTY
79438: LIST
79439: LIST
79440: PUSH
79441: EMPTY
79442: LIST
79443: LIST
79444: LIST
79445: LIST
79446: LIST
79447: LIST
79448: LIST
79449: LIST
79450: LIST
79451: LIST
79452: LIST
79453: LIST
79454: ST_TO_ADDR
// Lab0 = [ [ 0 , - 2 ] , [ - 1 , - 3 ] , [ 1 , - 2 ] ] ;
79455: LD_ADDR_VAR 0 41
79459: PUSH
79460: LD_INT 0
79462: PUSH
79463: LD_INT 2
79465: NEG
79466: PUSH
79467: EMPTY
79468: LIST
79469: LIST
79470: PUSH
79471: LD_INT 1
79473: NEG
79474: PUSH
79475: LD_INT 3
79477: NEG
79478: PUSH
79479: EMPTY
79480: LIST
79481: LIST
79482: PUSH
79483: LD_INT 1
79485: PUSH
79486: LD_INT 2
79488: NEG
79489: PUSH
79490: EMPTY
79491: LIST
79492: LIST
79493: PUSH
79494: EMPTY
79495: LIST
79496: LIST
79497: LIST
79498: ST_TO_ADDR
// Lab1 = [ [ 2 , 0 ] , [ 2 , - 1 ] , [ 3 , 1 ] ] ;
79499: LD_ADDR_VAR 0 42
79503: PUSH
79504: LD_INT 2
79506: PUSH
79507: LD_INT 0
79509: PUSH
79510: EMPTY
79511: LIST
79512: LIST
79513: PUSH
79514: LD_INT 2
79516: PUSH
79517: LD_INT 1
79519: NEG
79520: PUSH
79521: EMPTY
79522: LIST
79523: LIST
79524: PUSH
79525: LD_INT 3
79527: PUSH
79528: LD_INT 1
79530: PUSH
79531: EMPTY
79532: LIST
79533: LIST
79534: PUSH
79535: EMPTY
79536: LIST
79537: LIST
79538: LIST
79539: ST_TO_ADDR
// Lab2 = [ [ 2 , 2 ] , [ 3 , 2 ] , [ 2 , 3 ] ] ;
79540: LD_ADDR_VAR 0 43
79544: PUSH
79545: LD_INT 2
79547: PUSH
79548: LD_INT 2
79550: PUSH
79551: EMPTY
79552: LIST
79553: LIST
79554: PUSH
79555: LD_INT 3
79557: PUSH
79558: LD_INT 2
79560: PUSH
79561: EMPTY
79562: LIST
79563: LIST
79564: PUSH
79565: LD_INT 2
79567: PUSH
79568: LD_INT 3
79570: PUSH
79571: EMPTY
79572: LIST
79573: LIST
79574: PUSH
79575: EMPTY
79576: LIST
79577: LIST
79578: LIST
79579: ST_TO_ADDR
// Lab3 = [ [ 0 , 2 ] , [ 1 , 3 ] , [ - 1 , 2 ] ] ;
79580: LD_ADDR_VAR 0 44
79584: PUSH
79585: LD_INT 0
79587: PUSH
79588: LD_INT 2
79590: PUSH
79591: EMPTY
79592: LIST
79593: LIST
79594: PUSH
79595: LD_INT 1
79597: PUSH
79598: LD_INT 3
79600: PUSH
79601: EMPTY
79602: LIST
79603: LIST
79604: PUSH
79605: LD_INT 1
79607: NEG
79608: PUSH
79609: LD_INT 2
79611: PUSH
79612: EMPTY
79613: LIST
79614: LIST
79615: PUSH
79616: EMPTY
79617: LIST
79618: LIST
79619: LIST
79620: ST_TO_ADDR
// Lab4 = [ [ - 2 , 0 ] , [ - 2 , 1 ] , [ - 3 , - 1 ] ] ;
79621: LD_ADDR_VAR 0 45
79625: PUSH
79626: LD_INT 2
79628: NEG
79629: PUSH
79630: LD_INT 0
79632: PUSH
79633: EMPTY
79634: LIST
79635: LIST
79636: PUSH
79637: LD_INT 2
79639: NEG
79640: PUSH
79641: LD_INT 1
79643: PUSH
79644: EMPTY
79645: LIST
79646: LIST
79647: PUSH
79648: LD_INT 3
79650: NEG
79651: PUSH
79652: LD_INT 1
79654: NEG
79655: PUSH
79656: EMPTY
79657: LIST
79658: LIST
79659: PUSH
79660: EMPTY
79661: LIST
79662: LIST
79663: LIST
79664: ST_TO_ADDR
// Lab5 = [ [ - 2 , - 2 ] , [ - 2 , - 3 ] , [ - 3 , - 2 ] ] ;
79665: LD_ADDR_VAR 0 46
79669: PUSH
79670: LD_INT 2
79672: NEG
79673: PUSH
79674: LD_INT 2
79676: NEG
79677: PUSH
79678: EMPTY
79679: LIST
79680: LIST
79681: PUSH
79682: LD_INT 2
79684: NEG
79685: PUSH
79686: LD_INT 3
79688: NEG
79689: PUSH
79690: EMPTY
79691: LIST
79692: LIST
79693: PUSH
79694: LD_INT 3
79696: NEG
79697: PUSH
79698: LD_INT 2
79700: NEG
79701: PUSH
79702: EMPTY
79703: LIST
79704: LIST
79705: PUSH
79706: EMPTY
79707: LIST
79708: LIST
79709: LIST
79710: ST_TO_ADDR
// ControlTower0 = [ [ - 2 , - 3 ] , [ - 1 , - 3 ] ] ;
79711: LD_ADDR_VAR 0 47
79715: PUSH
79716: LD_INT 2
79718: NEG
79719: PUSH
79720: LD_INT 3
79722: NEG
79723: PUSH
79724: EMPTY
79725: LIST
79726: LIST
79727: PUSH
79728: LD_INT 1
79730: NEG
79731: PUSH
79732: LD_INT 3
79734: NEG
79735: PUSH
79736: EMPTY
79737: LIST
79738: LIST
79739: PUSH
79740: EMPTY
79741: LIST
79742: LIST
79743: ST_TO_ADDR
// ControlTower1 = [ [ 1 , - 2 ] , [ 2 , - 1 ] ] ;
79744: LD_ADDR_VAR 0 48
79748: PUSH
79749: LD_INT 1
79751: PUSH
79752: LD_INT 2
79754: NEG
79755: PUSH
79756: EMPTY
79757: LIST
79758: LIST
79759: PUSH
79760: LD_INT 2
79762: PUSH
79763: LD_INT 1
79765: NEG
79766: PUSH
79767: EMPTY
79768: LIST
79769: LIST
79770: PUSH
79771: EMPTY
79772: LIST
79773: LIST
79774: ST_TO_ADDR
// ControlTower2 = [ [ 3 , 1 ] , [ 3 , 2 ] ] ;
79775: LD_ADDR_VAR 0 49
79779: PUSH
79780: LD_INT 3
79782: PUSH
79783: LD_INT 1
79785: PUSH
79786: EMPTY
79787: LIST
79788: LIST
79789: PUSH
79790: LD_INT 3
79792: PUSH
79793: LD_INT 2
79795: PUSH
79796: EMPTY
79797: LIST
79798: LIST
79799: PUSH
79800: EMPTY
79801: LIST
79802: LIST
79803: ST_TO_ADDR
// ControlTower3 = [ [ 2 , 3 ] , [ 1 , 3 ] ] ;
79804: LD_ADDR_VAR 0 50
79808: PUSH
79809: LD_INT 2
79811: PUSH
79812: LD_INT 3
79814: PUSH
79815: EMPTY
79816: LIST
79817: LIST
79818: PUSH
79819: LD_INT 1
79821: PUSH
79822: LD_INT 3
79824: PUSH
79825: EMPTY
79826: LIST
79827: LIST
79828: PUSH
79829: EMPTY
79830: LIST
79831: LIST
79832: ST_TO_ADDR
// ControlTower4 = [ [ - 1 , 2 ] , [ - 2 , 1 ] ] ;
79833: LD_ADDR_VAR 0 51
79837: PUSH
79838: LD_INT 1
79840: NEG
79841: PUSH
79842: LD_INT 2
79844: PUSH
79845: EMPTY
79846: LIST
79847: LIST
79848: PUSH
79849: LD_INT 2
79851: NEG
79852: PUSH
79853: LD_INT 1
79855: PUSH
79856: EMPTY
79857: LIST
79858: LIST
79859: PUSH
79860: EMPTY
79861: LIST
79862: LIST
79863: ST_TO_ADDR
// ControlTower5 = [ [ - 3 , - 1 ] , [ - 3 , - 2 ] ] ;
79864: LD_ADDR_VAR 0 52
79868: PUSH
79869: LD_INT 3
79871: NEG
79872: PUSH
79873: LD_INT 1
79875: NEG
79876: PUSH
79877: EMPTY
79878: LIST
79879: LIST
79880: PUSH
79881: LD_INT 3
79883: NEG
79884: PUSH
79885: LD_INT 2
79887: NEG
79888: PUSH
79889: EMPTY
79890: LIST
79891: LIST
79892: PUSH
79893: EMPTY
79894: LIST
79895: LIST
79896: ST_TO_ADDR
// Barracks0 = [ [ - 1 , - 3 ] , [ 0 , - 3 ] , [ 1 , - 2 ] ] ;
79897: LD_ADDR_VAR 0 53
79901: PUSH
79902: LD_INT 1
79904: NEG
79905: PUSH
79906: LD_INT 3
79908: NEG
79909: PUSH
79910: EMPTY
79911: LIST
79912: LIST
79913: PUSH
79914: LD_INT 0
79916: PUSH
79917: LD_INT 3
79919: NEG
79920: PUSH
79921: EMPTY
79922: LIST
79923: LIST
79924: PUSH
79925: LD_INT 1
79927: PUSH
79928: LD_INT 2
79930: NEG
79931: PUSH
79932: EMPTY
79933: LIST
79934: LIST
79935: PUSH
79936: EMPTY
79937: LIST
79938: LIST
79939: LIST
79940: ST_TO_ADDR
// Barracks1 = [ [ 2 , - 1 ] , [ 3 , 0 ] , [ 3 , 1 ] ] ;
79941: LD_ADDR_VAR 0 54
79945: PUSH
79946: LD_INT 2
79948: PUSH
79949: LD_INT 1
79951: NEG
79952: PUSH
79953: EMPTY
79954: LIST
79955: LIST
79956: PUSH
79957: LD_INT 3
79959: PUSH
79960: LD_INT 0
79962: PUSH
79963: EMPTY
79964: LIST
79965: LIST
79966: PUSH
79967: LD_INT 3
79969: PUSH
79970: LD_INT 1
79972: PUSH
79973: EMPTY
79974: LIST
79975: LIST
79976: PUSH
79977: EMPTY
79978: LIST
79979: LIST
79980: LIST
79981: ST_TO_ADDR
// Barracks2 = [ [ 3 , 2 ] , [ 3 , 3 ] , [ 2 , 3 ] ] ;
79982: LD_ADDR_VAR 0 55
79986: PUSH
79987: LD_INT 3
79989: PUSH
79990: LD_INT 2
79992: PUSH
79993: EMPTY
79994: LIST
79995: LIST
79996: PUSH
79997: LD_INT 3
79999: PUSH
80000: LD_INT 3
80002: PUSH
80003: EMPTY
80004: LIST
80005: LIST
80006: PUSH
80007: LD_INT 2
80009: PUSH
80010: LD_INT 3
80012: PUSH
80013: EMPTY
80014: LIST
80015: LIST
80016: PUSH
80017: EMPTY
80018: LIST
80019: LIST
80020: LIST
80021: ST_TO_ADDR
// Barracks3 = [ [ 1 , 3 ] , [ 0 , 3 ] , [ - 1 , 2 ] ] ;
80022: LD_ADDR_VAR 0 56
80026: PUSH
80027: LD_INT 1
80029: PUSH
80030: LD_INT 3
80032: PUSH
80033: EMPTY
80034: LIST
80035: LIST
80036: PUSH
80037: LD_INT 0
80039: PUSH
80040: LD_INT 3
80042: PUSH
80043: EMPTY
80044: LIST
80045: LIST
80046: PUSH
80047: LD_INT 1
80049: NEG
80050: PUSH
80051: LD_INT 2
80053: PUSH
80054: EMPTY
80055: LIST
80056: LIST
80057: PUSH
80058: EMPTY
80059: LIST
80060: LIST
80061: LIST
80062: ST_TO_ADDR
// Barracks4 = [ [ - 2 , 1 ] , [ - 3 , 0 ] , [ - 3 , - 1 ] ] ;
80063: LD_ADDR_VAR 0 57
80067: PUSH
80068: LD_INT 2
80070: NEG
80071: PUSH
80072: LD_INT 1
80074: PUSH
80075: EMPTY
80076: LIST
80077: LIST
80078: PUSH
80079: LD_INT 3
80081: NEG
80082: PUSH
80083: LD_INT 0
80085: PUSH
80086: EMPTY
80087: LIST
80088: LIST
80089: PUSH
80090: LD_INT 3
80092: NEG
80093: PUSH
80094: LD_INT 1
80096: NEG
80097: PUSH
80098: EMPTY
80099: LIST
80100: LIST
80101: PUSH
80102: EMPTY
80103: LIST
80104: LIST
80105: LIST
80106: ST_TO_ADDR
// Barracks5 = [ [ - 2 , - 3 ] , [ - 3 , - 2 ] , [ - 3 , - 3 ] ] ;
80107: LD_ADDR_VAR 0 58
80111: PUSH
80112: LD_INT 2
80114: NEG
80115: PUSH
80116: LD_INT 3
80118: NEG
80119: PUSH
80120: EMPTY
80121: LIST
80122: LIST
80123: PUSH
80124: LD_INT 3
80126: NEG
80127: PUSH
80128: LD_INT 2
80130: NEG
80131: PUSH
80132: EMPTY
80133: LIST
80134: LIST
80135: PUSH
80136: LD_INT 3
80138: NEG
80139: PUSH
80140: LD_INT 3
80142: NEG
80143: PUSH
80144: EMPTY
80145: LIST
80146: LIST
80147: PUSH
80148: EMPTY
80149: LIST
80150: LIST
80151: LIST
80152: ST_TO_ADDR
// Bunker0 = [ [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] ] ;
80153: LD_ADDR_VAR 0 59
80157: PUSH
80158: LD_INT 1
80160: NEG
80161: PUSH
80162: LD_INT 2
80164: NEG
80165: PUSH
80166: EMPTY
80167: LIST
80168: LIST
80169: PUSH
80170: LD_INT 0
80172: PUSH
80173: LD_INT 2
80175: NEG
80176: PUSH
80177: EMPTY
80178: LIST
80179: LIST
80180: PUSH
80181: LD_INT 1
80183: PUSH
80184: LD_INT 1
80186: NEG
80187: PUSH
80188: EMPTY
80189: LIST
80190: LIST
80191: PUSH
80192: EMPTY
80193: LIST
80194: LIST
80195: LIST
80196: ST_TO_ADDR
// Bunker1 = [ [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] ] ;
80197: LD_ADDR_VAR 0 60
80201: PUSH
80202: LD_INT 1
80204: PUSH
80205: LD_INT 1
80207: NEG
80208: PUSH
80209: EMPTY
80210: LIST
80211: LIST
80212: PUSH
80213: LD_INT 2
80215: PUSH
80216: LD_INT 0
80218: PUSH
80219: EMPTY
80220: LIST
80221: LIST
80222: PUSH
80223: LD_INT 2
80225: PUSH
80226: LD_INT 1
80228: PUSH
80229: EMPTY
80230: LIST
80231: LIST
80232: PUSH
80233: EMPTY
80234: LIST
80235: LIST
80236: LIST
80237: ST_TO_ADDR
// Bunker2 = [ [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] ] ;
80238: LD_ADDR_VAR 0 61
80242: PUSH
80243: LD_INT 2
80245: PUSH
80246: LD_INT 1
80248: PUSH
80249: EMPTY
80250: LIST
80251: LIST
80252: PUSH
80253: LD_INT 2
80255: PUSH
80256: LD_INT 2
80258: PUSH
80259: EMPTY
80260: LIST
80261: LIST
80262: PUSH
80263: LD_INT 1
80265: PUSH
80266: LD_INT 2
80268: PUSH
80269: EMPTY
80270: LIST
80271: LIST
80272: PUSH
80273: EMPTY
80274: LIST
80275: LIST
80276: LIST
80277: ST_TO_ADDR
// Bunker3 = [ [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] ] ;
80278: LD_ADDR_VAR 0 62
80282: PUSH
80283: LD_INT 1
80285: PUSH
80286: LD_INT 2
80288: PUSH
80289: EMPTY
80290: LIST
80291: LIST
80292: PUSH
80293: LD_INT 0
80295: PUSH
80296: LD_INT 2
80298: PUSH
80299: EMPTY
80300: LIST
80301: LIST
80302: PUSH
80303: LD_INT 1
80305: NEG
80306: PUSH
80307: LD_INT 1
80309: PUSH
80310: EMPTY
80311: LIST
80312: LIST
80313: PUSH
80314: EMPTY
80315: LIST
80316: LIST
80317: LIST
80318: ST_TO_ADDR
// Bunker4 = [ [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] ] ;
80319: LD_ADDR_VAR 0 63
80323: PUSH
80324: LD_INT 1
80326: NEG
80327: PUSH
80328: LD_INT 1
80330: PUSH
80331: EMPTY
80332: LIST
80333: LIST
80334: PUSH
80335: LD_INT 2
80337: NEG
80338: PUSH
80339: LD_INT 0
80341: PUSH
80342: EMPTY
80343: LIST
80344: LIST
80345: PUSH
80346: LD_INT 2
80348: NEG
80349: PUSH
80350: LD_INT 1
80352: NEG
80353: PUSH
80354: EMPTY
80355: LIST
80356: LIST
80357: PUSH
80358: EMPTY
80359: LIST
80360: LIST
80361: LIST
80362: ST_TO_ADDR
// Bunker5 = [ [ - 1 , - 2 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
80363: LD_ADDR_VAR 0 64
80367: PUSH
80368: LD_INT 1
80370: NEG
80371: PUSH
80372: LD_INT 2
80374: NEG
80375: PUSH
80376: EMPTY
80377: LIST
80378: LIST
80379: PUSH
80380: LD_INT 2
80382: NEG
80383: PUSH
80384: LD_INT 1
80386: NEG
80387: PUSH
80388: EMPTY
80389: LIST
80390: LIST
80391: PUSH
80392: LD_INT 2
80394: NEG
80395: PUSH
80396: LD_INT 2
80398: NEG
80399: PUSH
80400: EMPTY
80401: LIST
80402: LIST
80403: PUSH
80404: EMPTY
80405: LIST
80406: LIST
80407: LIST
80408: ST_TO_ADDR
// end ; 2 :
80409: GO 83675
80411: LD_INT 2
80413: DOUBLE
80414: EQUAL
80415: IFTRUE 80419
80417: GO 83674
80419: POP
// begin Factory0 = [ [ 4 , 0 ] , [ 4 , - 1 ] , [ 5 , 0 ] , [ 5 , 1 ] , [ 4 , 1 ] , [ 3 , 0 ] , [ 3 , - 1 ] , [ 3 , - 2 ] , [ 5 , 2 ] , [ 3 , 3 ] , [ 3 , 2 ] , [ 4 , 3 ] , [ 4 , 4 ] , [ 3 , 4 ] , [ 2 , 3 ] , [ 2 , 2 ] , [ 4 , 2 ] , [ 2 , 4 ] , [ 0 , 4 ] , [ 0 , 3 ] , [ 1 , 4 ] , [ 1 , 5 ] , [ 0 , 5 ] , [ - 1 , 4 ] , [ - 1 , 3 ] , [ 2 , 5 ] , [ - 2 , 3 ] , [ - 3 , 0 ] , [ - 3 , - 1 ] , [ - 2 , 0 ] , [ - 2 , 1 ] , [ - 3 , 1 ] , [ - 4 , 0 ] , [ - 4 , - 1 ] , [ - 4 , - 2 ] , [ - 2 , 2 ] , [ - 4 , - 4 ] , [ - 4 , - 5 ] , [ - 3 , - 4 ] , [ - 3 , - 3 ] , [ - 4 , - 3 ] , [ - 5 , - 4 ] , [ - 5 , - 5 ] , [ - 3 , - 5 ] , [ - 5 , - 3 ] ] ;
80420: LD_ADDR_VAR 0 29
80424: PUSH
80425: LD_INT 4
80427: PUSH
80428: LD_INT 0
80430: PUSH
80431: EMPTY
80432: LIST
80433: LIST
80434: PUSH
80435: LD_INT 4
80437: PUSH
80438: LD_INT 1
80440: NEG
80441: PUSH
80442: EMPTY
80443: LIST
80444: LIST
80445: PUSH
80446: LD_INT 5
80448: PUSH
80449: LD_INT 0
80451: PUSH
80452: EMPTY
80453: LIST
80454: LIST
80455: PUSH
80456: LD_INT 5
80458: PUSH
80459: LD_INT 1
80461: PUSH
80462: EMPTY
80463: LIST
80464: LIST
80465: PUSH
80466: LD_INT 4
80468: PUSH
80469: LD_INT 1
80471: PUSH
80472: EMPTY
80473: LIST
80474: LIST
80475: PUSH
80476: LD_INT 3
80478: PUSH
80479: LD_INT 0
80481: PUSH
80482: EMPTY
80483: LIST
80484: LIST
80485: PUSH
80486: LD_INT 3
80488: PUSH
80489: LD_INT 1
80491: NEG
80492: PUSH
80493: EMPTY
80494: LIST
80495: LIST
80496: PUSH
80497: LD_INT 3
80499: PUSH
80500: LD_INT 2
80502: NEG
80503: PUSH
80504: EMPTY
80505: LIST
80506: LIST
80507: PUSH
80508: LD_INT 5
80510: PUSH
80511: LD_INT 2
80513: PUSH
80514: EMPTY
80515: LIST
80516: LIST
80517: PUSH
80518: LD_INT 3
80520: PUSH
80521: LD_INT 3
80523: PUSH
80524: EMPTY
80525: LIST
80526: LIST
80527: PUSH
80528: LD_INT 3
80530: PUSH
80531: LD_INT 2
80533: PUSH
80534: EMPTY
80535: LIST
80536: LIST
80537: PUSH
80538: LD_INT 4
80540: PUSH
80541: LD_INT 3
80543: PUSH
80544: EMPTY
80545: LIST
80546: LIST
80547: PUSH
80548: LD_INT 4
80550: PUSH
80551: LD_INT 4
80553: PUSH
80554: EMPTY
80555: LIST
80556: LIST
80557: PUSH
80558: LD_INT 3
80560: PUSH
80561: LD_INT 4
80563: PUSH
80564: EMPTY
80565: LIST
80566: LIST
80567: PUSH
80568: LD_INT 2
80570: PUSH
80571: LD_INT 3
80573: PUSH
80574: EMPTY
80575: LIST
80576: LIST
80577: PUSH
80578: LD_INT 2
80580: PUSH
80581: LD_INT 2
80583: PUSH
80584: EMPTY
80585: LIST
80586: LIST
80587: PUSH
80588: LD_INT 4
80590: PUSH
80591: LD_INT 2
80593: PUSH
80594: EMPTY
80595: LIST
80596: LIST
80597: PUSH
80598: LD_INT 2
80600: PUSH
80601: LD_INT 4
80603: PUSH
80604: EMPTY
80605: LIST
80606: LIST
80607: PUSH
80608: LD_INT 0
80610: PUSH
80611: LD_INT 4
80613: PUSH
80614: EMPTY
80615: LIST
80616: LIST
80617: PUSH
80618: LD_INT 0
80620: PUSH
80621: LD_INT 3
80623: PUSH
80624: EMPTY
80625: LIST
80626: LIST
80627: PUSH
80628: LD_INT 1
80630: PUSH
80631: LD_INT 4
80633: PUSH
80634: EMPTY
80635: LIST
80636: LIST
80637: PUSH
80638: LD_INT 1
80640: PUSH
80641: LD_INT 5
80643: PUSH
80644: EMPTY
80645: LIST
80646: LIST
80647: PUSH
80648: LD_INT 0
80650: PUSH
80651: LD_INT 5
80653: PUSH
80654: EMPTY
80655: LIST
80656: LIST
80657: PUSH
80658: LD_INT 1
80660: NEG
80661: PUSH
80662: LD_INT 4
80664: PUSH
80665: EMPTY
80666: LIST
80667: LIST
80668: PUSH
80669: LD_INT 1
80671: NEG
80672: PUSH
80673: LD_INT 3
80675: PUSH
80676: EMPTY
80677: LIST
80678: LIST
80679: PUSH
80680: LD_INT 2
80682: PUSH
80683: LD_INT 5
80685: PUSH
80686: EMPTY
80687: LIST
80688: LIST
80689: PUSH
80690: LD_INT 2
80692: NEG
80693: PUSH
80694: LD_INT 3
80696: PUSH
80697: EMPTY
80698: LIST
80699: LIST
80700: PUSH
80701: LD_INT 3
80703: NEG
80704: PUSH
80705: LD_INT 0
80707: PUSH
80708: EMPTY
80709: LIST
80710: LIST
80711: PUSH
80712: LD_INT 3
80714: NEG
80715: PUSH
80716: LD_INT 1
80718: NEG
80719: PUSH
80720: EMPTY
80721: LIST
80722: LIST
80723: PUSH
80724: LD_INT 2
80726: NEG
80727: PUSH
80728: LD_INT 0
80730: PUSH
80731: EMPTY
80732: LIST
80733: LIST
80734: PUSH
80735: LD_INT 2
80737: NEG
80738: PUSH
80739: LD_INT 1
80741: PUSH
80742: EMPTY
80743: LIST
80744: LIST
80745: PUSH
80746: LD_INT 3
80748: NEG
80749: PUSH
80750: LD_INT 1
80752: PUSH
80753: EMPTY
80754: LIST
80755: LIST
80756: PUSH
80757: LD_INT 4
80759: NEG
80760: PUSH
80761: LD_INT 0
80763: PUSH
80764: EMPTY
80765: LIST
80766: LIST
80767: PUSH
80768: LD_INT 4
80770: NEG
80771: PUSH
80772: LD_INT 1
80774: NEG
80775: PUSH
80776: EMPTY
80777: LIST
80778: LIST
80779: PUSH
80780: LD_INT 4
80782: NEG
80783: PUSH
80784: LD_INT 2
80786: NEG
80787: PUSH
80788: EMPTY
80789: LIST
80790: LIST
80791: PUSH
80792: LD_INT 2
80794: NEG
80795: PUSH
80796: LD_INT 2
80798: PUSH
80799: EMPTY
80800: LIST
80801: LIST
80802: PUSH
80803: LD_INT 4
80805: NEG
80806: PUSH
80807: LD_INT 4
80809: NEG
80810: PUSH
80811: EMPTY
80812: LIST
80813: LIST
80814: PUSH
80815: LD_INT 4
80817: NEG
80818: PUSH
80819: LD_INT 5
80821: NEG
80822: PUSH
80823: EMPTY
80824: LIST
80825: LIST
80826: PUSH
80827: LD_INT 3
80829: NEG
80830: PUSH
80831: LD_INT 4
80833: NEG
80834: PUSH
80835: EMPTY
80836: LIST
80837: LIST
80838: PUSH
80839: LD_INT 3
80841: NEG
80842: PUSH
80843: LD_INT 3
80845: NEG
80846: PUSH
80847: EMPTY
80848: LIST
80849: LIST
80850: PUSH
80851: LD_INT 4
80853: NEG
80854: PUSH
80855: LD_INT 3
80857: NEG
80858: PUSH
80859: EMPTY
80860: LIST
80861: LIST
80862: PUSH
80863: LD_INT 5
80865: NEG
80866: PUSH
80867: LD_INT 4
80869: NEG
80870: PUSH
80871: EMPTY
80872: LIST
80873: LIST
80874: PUSH
80875: LD_INT 5
80877: NEG
80878: PUSH
80879: LD_INT 5
80881: NEG
80882: PUSH
80883: EMPTY
80884: LIST
80885: LIST
80886: PUSH
80887: LD_INT 3
80889: NEG
80890: PUSH
80891: LD_INT 5
80893: NEG
80894: PUSH
80895: EMPTY
80896: LIST
80897: LIST
80898: PUSH
80899: LD_INT 5
80901: NEG
80902: PUSH
80903: LD_INT 3
80905: NEG
80906: PUSH
80907: EMPTY
80908: LIST
80909: LIST
80910: PUSH
80911: EMPTY
80912: LIST
80913: LIST
80914: LIST
80915: LIST
80916: LIST
80917: LIST
80918: LIST
80919: LIST
80920: LIST
80921: LIST
80922: LIST
80923: LIST
80924: LIST
80925: LIST
80926: LIST
80927: LIST
80928: LIST
80929: LIST
80930: LIST
80931: LIST
80932: LIST
80933: LIST
80934: LIST
80935: LIST
80936: LIST
80937: LIST
80938: LIST
80939: LIST
80940: LIST
80941: LIST
80942: LIST
80943: LIST
80944: LIST
80945: LIST
80946: LIST
80947: LIST
80948: LIST
80949: LIST
80950: LIST
80951: LIST
80952: LIST
80953: LIST
80954: LIST
80955: LIST
80956: LIST
80957: ST_TO_ADDR
// Factory1 = [ [ 4 , 4 ] , [ 4 , 3 ] , [ 5 , 4 ] , [ 5 , 5 ] , [ 4 , 5 ] , [ 3 , 4 ] , [ 3 , 3 ] , [ 5 , 3 ] , [ 3 , 5 ] , [ 0 , 3 ] , [ 0 , 2 ] , [ 1 , 3 ] , [ 1 , 4 ] , [ 0 , 4 ] , [ - 1 , 3 ] , [ - 1 , 2 ] , [ 2 , 4 ] , [ - 2 , 2 ] , [ - 4 , 0 ] , [ - 4 , - 1 ] , [ - 3 , 0 ] , [ - 3 , 1 ] , [ - 4 , 1 ] , [ - 5 , 0 ] , [ - 5 , - 1 ] , [ - 5 , - 2 ] , [ - 3 , 2 ] , [ - 3 , - 3 ] , [ - 3 , - 4 ] , [ - 2 , - 3 ] , [ - 2 , - 2 ] , [ - 3 , - 2 ] , [ - 4 , - 3 ] , [ - 4 , - 4 ] , [ - 2 , - 4 ] , [ - 4 , - 2 ] , [ 0 , - 4 ] , [ 0 , - 5 ] , [ 1 , - 4 ] , [ 1 , - 3 ] , [ 0 , - 3 ] , [ - 1 , - 4 ] , [ - 1 , - 5 ] , [ 2 , - 3 ] , [ - 2 , - 5 ] ] ;
80958: LD_ADDR_VAR 0 30
80962: PUSH
80963: LD_INT 4
80965: PUSH
80966: LD_INT 4
80968: PUSH
80969: EMPTY
80970: LIST
80971: LIST
80972: PUSH
80973: LD_INT 4
80975: PUSH
80976: LD_INT 3
80978: PUSH
80979: EMPTY
80980: LIST
80981: LIST
80982: PUSH
80983: LD_INT 5
80985: PUSH
80986: LD_INT 4
80988: PUSH
80989: EMPTY
80990: LIST
80991: LIST
80992: PUSH
80993: LD_INT 5
80995: PUSH
80996: LD_INT 5
80998: PUSH
80999: EMPTY
81000: LIST
81001: LIST
81002: PUSH
81003: LD_INT 4
81005: PUSH
81006: LD_INT 5
81008: PUSH
81009: EMPTY
81010: LIST
81011: LIST
81012: PUSH
81013: LD_INT 3
81015: PUSH
81016: LD_INT 4
81018: PUSH
81019: EMPTY
81020: LIST
81021: LIST
81022: PUSH
81023: LD_INT 3
81025: PUSH
81026: LD_INT 3
81028: PUSH
81029: EMPTY
81030: LIST
81031: LIST
81032: PUSH
81033: LD_INT 5
81035: PUSH
81036: LD_INT 3
81038: PUSH
81039: EMPTY
81040: LIST
81041: LIST
81042: PUSH
81043: LD_INT 3
81045: PUSH
81046: LD_INT 5
81048: PUSH
81049: EMPTY
81050: LIST
81051: LIST
81052: PUSH
81053: LD_INT 0
81055: PUSH
81056: LD_INT 3
81058: PUSH
81059: EMPTY
81060: LIST
81061: LIST
81062: PUSH
81063: LD_INT 0
81065: PUSH
81066: LD_INT 2
81068: PUSH
81069: EMPTY
81070: LIST
81071: LIST
81072: PUSH
81073: LD_INT 1
81075: PUSH
81076: LD_INT 3
81078: PUSH
81079: EMPTY
81080: LIST
81081: LIST
81082: PUSH
81083: LD_INT 1
81085: PUSH
81086: LD_INT 4
81088: PUSH
81089: EMPTY
81090: LIST
81091: LIST
81092: PUSH
81093: LD_INT 0
81095: PUSH
81096: LD_INT 4
81098: PUSH
81099: EMPTY
81100: LIST
81101: LIST
81102: PUSH
81103: LD_INT 1
81105: NEG
81106: PUSH
81107: LD_INT 3
81109: PUSH
81110: EMPTY
81111: LIST
81112: LIST
81113: PUSH
81114: LD_INT 1
81116: NEG
81117: PUSH
81118: LD_INT 2
81120: PUSH
81121: EMPTY
81122: LIST
81123: LIST
81124: PUSH
81125: LD_INT 2
81127: PUSH
81128: LD_INT 4
81130: PUSH
81131: EMPTY
81132: LIST
81133: LIST
81134: PUSH
81135: LD_INT 2
81137: NEG
81138: PUSH
81139: LD_INT 2
81141: PUSH
81142: EMPTY
81143: LIST
81144: LIST
81145: PUSH
81146: LD_INT 4
81148: NEG
81149: PUSH
81150: LD_INT 0
81152: PUSH
81153: EMPTY
81154: LIST
81155: LIST
81156: PUSH
81157: LD_INT 4
81159: NEG
81160: PUSH
81161: LD_INT 1
81163: NEG
81164: PUSH
81165: EMPTY
81166: LIST
81167: LIST
81168: PUSH
81169: LD_INT 3
81171: NEG
81172: PUSH
81173: LD_INT 0
81175: PUSH
81176: EMPTY
81177: LIST
81178: LIST
81179: PUSH
81180: LD_INT 3
81182: NEG
81183: PUSH
81184: LD_INT 1
81186: PUSH
81187: EMPTY
81188: LIST
81189: LIST
81190: PUSH
81191: LD_INT 4
81193: NEG
81194: PUSH
81195: LD_INT 1
81197: PUSH
81198: EMPTY
81199: LIST
81200: LIST
81201: PUSH
81202: LD_INT 5
81204: NEG
81205: PUSH
81206: LD_INT 0
81208: PUSH
81209: EMPTY
81210: LIST
81211: LIST
81212: PUSH
81213: LD_INT 5
81215: NEG
81216: PUSH
81217: LD_INT 1
81219: NEG
81220: PUSH
81221: EMPTY
81222: LIST
81223: LIST
81224: PUSH
81225: LD_INT 5
81227: NEG
81228: PUSH
81229: LD_INT 2
81231: NEG
81232: PUSH
81233: EMPTY
81234: LIST
81235: LIST
81236: PUSH
81237: LD_INT 3
81239: NEG
81240: PUSH
81241: LD_INT 2
81243: PUSH
81244: EMPTY
81245: LIST
81246: LIST
81247: PUSH
81248: LD_INT 3
81250: NEG
81251: PUSH
81252: LD_INT 3
81254: NEG
81255: PUSH
81256: EMPTY
81257: LIST
81258: LIST
81259: PUSH
81260: LD_INT 3
81262: NEG
81263: PUSH
81264: LD_INT 4
81266: NEG
81267: PUSH
81268: EMPTY
81269: LIST
81270: LIST
81271: PUSH
81272: LD_INT 2
81274: NEG
81275: PUSH
81276: LD_INT 3
81278: NEG
81279: PUSH
81280: EMPTY
81281: LIST
81282: LIST
81283: PUSH
81284: LD_INT 2
81286: NEG
81287: PUSH
81288: LD_INT 2
81290: NEG
81291: PUSH
81292: EMPTY
81293: LIST
81294: LIST
81295: PUSH
81296: LD_INT 3
81298: NEG
81299: PUSH
81300: LD_INT 2
81302: NEG
81303: PUSH
81304: EMPTY
81305: LIST
81306: LIST
81307: PUSH
81308: LD_INT 4
81310: NEG
81311: PUSH
81312: LD_INT 3
81314: NEG
81315: PUSH
81316: EMPTY
81317: LIST
81318: LIST
81319: PUSH
81320: LD_INT 4
81322: NEG
81323: PUSH
81324: LD_INT 4
81326: NEG
81327: PUSH
81328: EMPTY
81329: LIST
81330: LIST
81331: PUSH
81332: LD_INT 2
81334: NEG
81335: PUSH
81336: LD_INT 4
81338: NEG
81339: PUSH
81340: EMPTY
81341: LIST
81342: LIST
81343: PUSH
81344: LD_INT 4
81346: NEG
81347: PUSH
81348: LD_INT 2
81350: NEG
81351: PUSH
81352: EMPTY
81353: LIST
81354: LIST
81355: PUSH
81356: LD_INT 0
81358: PUSH
81359: LD_INT 4
81361: NEG
81362: PUSH
81363: EMPTY
81364: LIST
81365: LIST
81366: PUSH
81367: LD_INT 0
81369: PUSH
81370: LD_INT 5
81372: NEG
81373: PUSH
81374: EMPTY
81375: LIST
81376: LIST
81377: PUSH
81378: LD_INT 1
81380: PUSH
81381: LD_INT 4
81383: NEG
81384: PUSH
81385: EMPTY
81386: LIST
81387: LIST
81388: PUSH
81389: LD_INT 1
81391: PUSH
81392: LD_INT 3
81394: NEG
81395: PUSH
81396: EMPTY
81397: LIST
81398: LIST
81399: PUSH
81400: LD_INT 0
81402: PUSH
81403: LD_INT 3
81405: NEG
81406: PUSH
81407: EMPTY
81408: LIST
81409: LIST
81410: PUSH
81411: LD_INT 1
81413: NEG
81414: PUSH
81415: LD_INT 4
81417: NEG
81418: PUSH
81419: EMPTY
81420: LIST
81421: LIST
81422: PUSH
81423: LD_INT 1
81425: NEG
81426: PUSH
81427: LD_INT 5
81429: NEG
81430: PUSH
81431: EMPTY
81432: LIST
81433: LIST
81434: PUSH
81435: LD_INT 2
81437: PUSH
81438: LD_INT 3
81440: NEG
81441: PUSH
81442: EMPTY
81443: LIST
81444: LIST
81445: PUSH
81446: LD_INT 2
81448: NEG
81449: PUSH
81450: LD_INT 5
81452: NEG
81453: PUSH
81454: EMPTY
81455: LIST
81456: LIST
81457: PUSH
81458: EMPTY
81459: LIST
81460: LIST
81461: LIST
81462: LIST
81463: LIST
81464: LIST
81465: LIST
81466: LIST
81467: LIST
81468: LIST
81469: LIST
81470: LIST
81471: LIST
81472: LIST
81473: LIST
81474: LIST
81475: LIST
81476: LIST
81477: LIST
81478: LIST
81479: LIST
81480: LIST
81481: LIST
81482: LIST
81483: LIST
81484: LIST
81485: LIST
81486: LIST
81487: LIST
81488: LIST
81489: LIST
81490: LIST
81491: LIST
81492: LIST
81493: LIST
81494: LIST
81495: LIST
81496: LIST
81497: LIST
81498: LIST
81499: LIST
81500: LIST
81501: LIST
81502: LIST
81503: LIST
81504: ST_TO_ADDR
// Factory2 = [ [ 0 , 4 ] , [ 0 , 3 ] , [ 1 , 4 ] , [ 1 , 5 ] , [ 0 , 5 ] , [ - 1 , 4 ] , [ - 1 , 3 ] , [ 2 , 5 ] , [ - 2 , 3 ] , [ - 3 , 0 ] , [ - 3 , - 1 ] , [ - 2 , 0 ] , [ - 2 , 1 ] , [ - 3 , 1 ] , [ - 4 , 0 ] , [ - 4 , - 1 ] , [ - 4 , - 2 ] , [ - 2 , 2 ] , [ - 4 , - 4 ] , [ - 4 , - 5 ] , [ - 3 , - 4 ] , [ - 3 , - 3 ] , [ - 4 , - 3 ] , [ - 5 , - 4 ] , [ - 5 , - 5 ] , [ - 3 , - 5 ] , [ - 5 , - 3 ] , [ 0 , - 3 ] , [ 0 , - 4 ] , [ 1 , - 3 ] , [ 1 , - 2 ] , [ 0 , - 2 ] , [ - 1 , - 3 ] , [ - 1 , - 4 ] , [ 2 , - 2 ] , [ - 2 , - 4 ] , [ 4 , 0 ] , [ 4 , - 1 ] , [ 5 , 0 ] , [ 5 , 1 ] , [ 4 , 1 ] , [ 3 , 0 ] , [ 3 , - 1 ] , [ 3 , - 2 ] , [ 5 , 2 ] ] ;
81505: LD_ADDR_VAR 0 31
81509: PUSH
81510: LD_INT 0
81512: PUSH
81513: LD_INT 4
81515: PUSH
81516: EMPTY
81517: LIST
81518: LIST
81519: PUSH
81520: LD_INT 0
81522: PUSH
81523: LD_INT 3
81525: PUSH
81526: EMPTY
81527: LIST
81528: LIST
81529: PUSH
81530: LD_INT 1
81532: PUSH
81533: LD_INT 4
81535: PUSH
81536: EMPTY
81537: LIST
81538: LIST
81539: PUSH
81540: LD_INT 1
81542: PUSH
81543: LD_INT 5
81545: PUSH
81546: EMPTY
81547: LIST
81548: LIST
81549: PUSH
81550: LD_INT 0
81552: PUSH
81553: LD_INT 5
81555: PUSH
81556: EMPTY
81557: LIST
81558: LIST
81559: PUSH
81560: LD_INT 1
81562: NEG
81563: PUSH
81564: LD_INT 4
81566: PUSH
81567: EMPTY
81568: LIST
81569: LIST
81570: PUSH
81571: LD_INT 1
81573: NEG
81574: PUSH
81575: LD_INT 3
81577: PUSH
81578: EMPTY
81579: LIST
81580: LIST
81581: PUSH
81582: LD_INT 2
81584: PUSH
81585: LD_INT 5
81587: PUSH
81588: EMPTY
81589: LIST
81590: LIST
81591: PUSH
81592: LD_INT 2
81594: NEG
81595: PUSH
81596: LD_INT 3
81598: PUSH
81599: EMPTY
81600: LIST
81601: LIST
81602: PUSH
81603: LD_INT 3
81605: NEG
81606: PUSH
81607: LD_INT 0
81609: PUSH
81610: EMPTY
81611: LIST
81612: LIST
81613: PUSH
81614: LD_INT 3
81616: NEG
81617: PUSH
81618: LD_INT 1
81620: NEG
81621: PUSH
81622: EMPTY
81623: LIST
81624: LIST
81625: PUSH
81626: LD_INT 2
81628: NEG
81629: PUSH
81630: LD_INT 0
81632: PUSH
81633: EMPTY
81634: LIST
81635: LIST
81636: PUSH
81637: LD_INT 2
81639: NEG
81640: PUSH
81641: LD_INT 1
81643: PUSH
81644: EMPTY
81645: LIST
81646: LIST
81647: PUSH
81648: LD_INT 3
81650: NEG
81651: PUSH
81652: LD_INT 1
81654: PUSH
81655: EMPTY
81656: LIST
81657: LIST
81658: PUSH
81659: LD_INT 4
81661: NEG
81662: PUSH
81663: LD_INT 0
81665: PUSH
81666: EMPTY
81667: LIST
81668: LIST
81669: PUSH
81670: LD_INT 4
81672: NEG
81673: PUSH
81674: LD_INT 1
81676: NEG
81677: PUSH
81678: EMPTY
81679: LIST
81680: LIST
81681: PUSH
81682: LD_INT 4
81684: NEG
81685: PUSH
81686: LD_INT 2
81688: NEG
81689: PUSH
81690: EMPTY
81691: LIST
81692: LIST
81693: PUSH
81694: LD_INT 2
81696: NEG
81697: PUSH
81698: LD_INT 2
81700: PUSH
81701: EMPTY
81702: LIST
81703: LIST
81704: PUSH
81705: LD_INT 4
81707: NEG
81708: PUSH
81709: LD_INT 4
81711: NEG
81712: PUSH
81713: EMPTY
81714: LIST
81715: LIST
81716: PUSH
81717: LD_INT 4
81719: NEG
81720: PUSH
81721: LD_INT 5
81723: NEG
81724: PUSH
81725: EMPTY
81726: LIST
81727: LIST
81728: PUSH
81729: LD_INT 3
81731: NEG
81732: PUSH
81733: LD_INT 4
81735: NEG
81736: PUSH
81737: EMPTY
81738: LIST
81739: LIST
81740: PUSH
81741: LD_INT 3
81743: NEG
81744: PUSH
81745: LD_INT 3
81747: NEG
81748: PUSH
81749: EMPTY
81750: LIST
81751: LIST
81752: PUSH
81753: LD_INT 4
81755: NEG
81756: PUSH
81757: LD_INT 3
81759: NEG
81760: PUSH
81761: EMPTY
81762: LIST
81763: LIST
81764: PUSH
81765: LD_INT 5
81767: NEG
81768: PUSH
81769: LD_INT 4
81771: NEG
81772: PUSH
81773: EMPTY
81774: LIST
81775: LIST
81776: PUSH
81777: LD_INT 5
81779: NEG
81780: PUSH
81781: LD_INT 5
81783: NEG
81784: PUSH
81785: EMPTY
81786: LIST
81787: LIST
81788: PUSH
81789: LD_INT 3
81791: NEG
81792: PUSH
81793: LD_INT 5
81795: NEG
81796: PUSH
81797: EMPTY
81798: LIST
81799: LIST
81800: PUSH
81801: LD_INT 5
81803: NEG
81804: PUSH
81805: LD_INT 3
81807: NEG
81808: PUSH
81809: EMPTY
81810: LIST
81811: LIST
81812: PUSH
81813: LD_INT 0
81815: PUSH
81816: LD_INT 3
81818: NEG
81819: PUSH
81820: EMPTY
81821: LIST
81822: LIST
81823: PUSH
81824: LD_INT 0
81826: PUSH
81827: LD_INT 4
81829: NEG
81830: PUSH
81831: EMPTY
81832: LIST
81833: LIST
81834: PUSH
81835: LD_INT 1
81837: PUSH
81838: LD_INT 3
81840: NEG
81841: PUSH
81842: EMPTY
81843: LIST
81844: LIST
81845: PUSH
81846: LD_INT 1
81848: PUSH
81849: LD_INT 2
81851: NEG
81852: PUSH
81853: EMPTY
81854: LIST
81855: LIST
81856: PUSH
81857: LD_INT 0
81859: PUSH
81860: LD_INT 2
81862: NEG
81863: PUSH
81864: EMPTY
81865: LIST
81866: LIST
81867: PUSH
81868: LD_INT 1
81870: NEG
81871: PUSH
81872: LD_INT 3
81874: NEG
81875: PUSH
81876: EMPTY
81877: LIST
81878: LIST
81879: PUSH
81880: LD_INT 1
81882: NEG
81883: PUSH
81884: LD_INT 4
81886: NEG
81887: PUSH
81888: EMPTY
81889: LIST
81890: LIST
81891: PUSH
81892: LD_INT 2
81894: PUSH
81895: LD_INT 2
81897: NEG
81898: PUSH
81899: EMPTY
81900: LIST
81901: LIST
81902: PUSH
81903: LD_INT 2
81905: NEG
81906: PUSH
81907: LD_INT 4
81909: NEG
81910: PUSH
81911: EMPTY
81912: LIST
81913: LIST
81914: PUSH
81915: LD_INT 4
81917: PUSH
81918: LD_INT 0
81920: PUSH
81921: EMPTY
81922: LIST
81923: LIST
81924: PUSH
81925: LD_INT 4
81927: PUSH
81928: LD_INT 1
81930: NEG
81931: PUSH
81932: EMPTY
81933: LIST
81934: LIST
81935: PUSH
81936: LD_INT 5
81938: PUSH
81939: LD_INT 0
81941: PUSH
81942: EMPTY
81943: LIST
81944: LIST
81945: PUSH
81946: LD_INT 5
81948: PUSH
81949: LD_INT 1
81951: PUSH
81952: EMPTY
81953: LIST
81954: LIST
81955: PUSH
81956: LD_INT 4
81958: PUSH
81959: LD_INT 1
81961: PUSH
81962: EMPTY
81963: LIST
81964: LIST
81965: PUSH
81966: LD_INT 3
81968: PUSH
81969: LD_INT 0
81971: PUSH
81972: EMPTY
81973: LIST
81974: LIST
81975: PUSH
81976: LD_INT 3
81978: PUSH
81979: LD_INT 1
81981: NEG
81982: PUSH
81983: EMPTY
81984: LIST
81985: LIST
81986: PUSH
81987: LD_INT 3
81989: PUSH
81990: LD_INT 2
81992: NEG
81993: PUSH
81994: EMPTY
81995: LIST
81996: LIST
81997: PUSH
81998: LD_INT 5
82000: PUSH
82001: LD_INT 2
82003: PUSH
82004: EMPTY
82005: LIST
82006: LIST
82007: PUSH
82008: EMPTY
82009: LIST
82010: LIST
82011: LIST
82012: LIST
82013: LIST
82014: LIST
82015: LIST
82016: LIST
82017: LIST
82018: LIST
82019: LIST
82020: LIST
82021: LIST
82022: LIST
82023: LIST
82024: LIST
82025: LIST
82026: LIST
82027: LIST
82028: LIST
82029: LIST
82030: LIST
82031: LIST
82032: LIST
82033: LIST
82034: LIST
82035: LIST
82036: LIST
82037: LIST
82038: LIST
82039: LIST
82040: LIST
82041: LIST
82042: LIST
82043: LIST
82044: LIST
82045: LIST
82046: LIST
82047: LIST
82048: LIST
82049: LIST
82050: LIST
82051: LIST
82052: LIST
82053: LIST
82054: ST_TO_ADDR
// Factory3 = [ [ - 4 , 0 ] , [ - 4 , - 1 ] , [ - 3 , 0 ] , [ - 3 , 1 ] , [ - 4 , 1 ] , [ - 5 , 0 ] , [ - 5 , - 1 ] , [ - 5 , - 2 ] , [ - 3 , 2 ] , [ - 3 , - 3 ] , [ - 3 , - 4 ] , [ - 2 , - 3 ] , [ - 2 , - 2 ] , [ - 3 , - 2 ] , [ - 4 , - 3 ] , [ - 4 , - 4 ] , [ - 2 , - 4 ] , [ - 4 , - 2 ] , [ 0 , - 4 ] , [ 0 , - 5 ] , [ 1 , - 4 ] , [ 1 , - 3 ] , [ 0 , - 3 ] , [ - 1 , - 4 ] , [ - 1 , - 5 ] , [ 2 , - 3 ] , [ - 2 , - 5 ] , [ 3 , 0 ] , [ 3 , - 1 ] , [ 4 , 0 ] , [ 4 , 1 ] , [ 3 , 1 ] , [ 2 , 0 ] , [ 2 , - 1 ] , [ 2 , - 2 ] , [ 4 , 2 ] , [ 4 , 4 ] , [ 4 , 3 ] , [ 5 , 4 ] , [ 5 , 5 ] , [ 4 , 5 ] , [ 3 , 4 ] , [ 3 , 3 ] , [ 5 , 3 ] , [ 3 , 5 ] ] ;
82055: LD_ADDR_VAR 0 32
82059: PUSH
82060: LD_INT 4
82062: NEG
82063: PUSH
82064: LD_INT 0
82066: PUSH
82067: EMPTY
82068: LIST
82069: LIST
82070: PUSH
82071: LD_INT 4
82073: NEG
82074: PUSH
82075: LD_INT 1
82077: NEG
82078: PUSH
82079: EMPTY
82080: LIST
82081: LIST
82082: PUSH
82083: LD_INT 3
82085: NEG
82086: PUSH
82087: LD_INT 0
82089: PUSH
82090: EMPTY
82091: LIST
82092: LIST
82093: PUSH
82094: LD_INT 3
82096: NEG
82097: PUSH
82098: LD_INT 1
82100: PUSH
82101: EMPTY
82102: LIST
82103: LIST
82104: PUSH
82105: LD_INT 4
82107: NEG
82108: PUSH
82109: LD_INT 1
82111: PUSH
82112: EMPTY
82113: LIST
82114: LIST
82115: PUSH
82116: LD_INT 5
82118: NEG
82119: PUSH
82120: LD_INT 0
82122: PUSH
82123: EMPTY
82124: LIST
82125: LIST
82126: PUSH
82127: LD_INT 5
82129: NEG
82130: PUSH
82131: LD_INT 1
82133: NEG
82134: PUSH
82135: EMPTY
82136: LIST
82137: LIST
82138: PUSH
82139: LD_INT 5
82141: NEG
82142: PUSH
82143: LD_INT 2
82145: NEG
82146: PUSH
82147: EMPTY
82148: LIST
82149: LIST
82150: PUSH
82151: LD_INT 3
82153: NEG
82154: PUSH
82155: LD_INT 2
82157: PUSH
82158: EMPTY
82159: LIST
82160: LIST
82161: PUSH
82162: LD_INT 3
82164: NEG
82165: PUSH
82166: LD_INT 3
82168: NEG
82169: PUSH
82170: EMPTY
82171: LIST
82172: LIST
82173: PUSH
82174: LD_INT 3
82176: NEG
82177: PUSH
82178: LD_INT 4
82180: NEG
82181: PUSH
82182: EMPTY
82183: LIST
82184: LIST
82185: PUSH
82186: LD_INT 2
82188: NEG
82189: PUSH
82190: LD_INT 3
82192: NEG
82193: PUSH
82194: EMPTY
82195: LIST
82196: LIST
82197: PUSH
82198: LD_INT 2
82200: NEG
82201: PUSH
82202: LD_INT 2
82204: NEG
82205: PUSH
82206: EMPTY
82207: LIST
82208: LIST
82209: PUSH
82210: LD_INT 3
82212: NEG
82213: PUSH
82214: LD_INT 2
82216: NEG
82217: PUSH
82218: EMPTY
82219: LIST
82220: LIST
82221: PUSH
82222: LD_INT 4
82224: NEG
82225: PUSH
82226: LD_INT 3
82228: NEG
82229: PUSH
82230: EMPTY
82231: LIST
82232: LIST
82233: PUSH
82234: LD_INT 4
82236: NEG
82237: PUSH
82238: LD_INT 4
82240: NEG
82241: PUSH
82242: EMPTY
82243: LIST
82244: LIST
82245: PUSH
82246: LD_INT 2
82248: NEG
82249: PUSH
82250: LD_INT 4
82252: NEG
82253: PUSH
82254: EMPTY
82255: LIST
82256: LIST
82257: PUSH
82258: LD_INT 4
82260: NEG
82261: PUSH
82262: LD_INT 2
82264: NEG
82265: PUSH
82266: EMPTY
82267: LIST
82268: LIST
82269: PUSH
82270: LD_INT 0
82272: PUSH
82273: LD_INT 4
82275: NEG
82276: PUSH
82277: EMPTY
82278: LIST
82279: LIST
82280: PUSH
82281: LD_INT 0
82283: PUSH
82284: LD_INT 5
82286: NEG
82287: PUSH
82288: EMPTY
82289: LIST
82290: LIST
82291: PUSH
82292: LD_INT 1
82294: PUSH
82295: LD_INT 4
82297: NEG
82298: PUSH
82299: EMPTY
82300: LIST
82301: LIST
82302: PUSH
82303: LD_INT 1
82305: PUSH
82306: LD_INT 3
82308: NEG
82309: PUSH
82310: EMPTY
82311: LIST
82312: LIST
82313: PUSH
82314: LD_INT 0
82316: PUSH
82317: LD_INT 3
82319: NEG
82320: PUSH
82321: EMPTY
82322: LIST
82323: LIST
82324: PUSH
82325: LD_INT 1
82327: NEG
82328: PUSH
82329: LD_INT 4
82331: NEG
82332: PUSH
82333: EMPTY
82334: LIST
82335: LIST
82336: PUSH
82337: LD_INT 1
82339: NEG
82340: PUSH
82341: LD_INT 5
82343: NEG
82344: PUSH
82345: EMPTY
82346: LIST
82347: LIST
82348: PUSH
82349: LD_INT 2
82351: PUSH
82352: LD_INT 3
82354: NEG
82355: PUSH
82356: EMPTY
82357: LIST
82358: LIST
82359: PUSH
82360: LD_INT 2
82362: NEG
82363: PUSH
82364: LD_INT 5
82366: NEG
82367: PUSH
82368: EMPTY
82369: LIST
82370: LIST
82371: PUSH
82372: LD_INT 3
82374: PUSH
82375: LD_INT 0
82377: PUSH
82378: EMPTY
82379: LIST
82380: LIST
82381: PUSH
82382: LD_INT 3
82384: PUSH
82385: LD_INT 1
82387: NEG
82388: PUSH
82389: EMPTY
82390: LIST
82391: LIST
82392: PUSH
82393: LD_INT 4
82395: PUSH
82396: LD_INT 0
82398: PUSH
82399: EMPTY
82400: LIST
82401: LIST
82402: PUSH
82403: LD_INT 4
82405: PUSH
82406: LD_INT 1
82408: PUSH
82409: EMPTY
82410: LIST
82411: LIST
82412: PUSH
82413: LD_INT 3
82415: PUSH
82416: LD_INT 1
82418: PUSH
82419: EMPTY
82420: LIST
82421: LIST
82422: PUSH
82423: LD_INT 2
82425: PUSH
82426: LD_INT 0
82428: PUSH
82429: EMPTY
82430: LIST
82431: LIST
82432: PUSH
82433: LD_INT 2
82435: PUSH
82436: LD_INT 1
82438: NEG
82439: PUSH
82440: EMPTY
82441: LIST
82442: LIST
82443: PUSH
82444: LD_INT 2
82446: PUSH
82447: LD_INT 2
82449: NEG
82450: PUSH
82451: EMPTY
82452: LIST
82453: LIST
82454: PUSH
82455: LD_INT 4
82457: PUSH
82458: LD_INT 2
82460: PUSH
82461: EMPTY
82462: LIST
82463: LIST
82464: PUSH
82465: LD_INT 4
82467: PUSH
82468: LD_INT 4
82470: PUSH
82471: EMPTY
82472: LIST
82473: LIST
82474: PUSH
82475: LD_INT 4
82477: PUSH
82478: LD_INT 3
82480: PUSH
82481: EMPTY
82482: LIST
82483: LIST
82484: PUSH
82485: LD_INT 5
82487: PUSH
82488: LD_INT 4
82490: PUSH
82491: EMPTY
82492: LIST
82493: LIST
82494: PUSH
82495: LD_INT 5
82497: PUSH
82498: LD_INT 5
82500: PUSH
82501: EMPTY
82502: LIST
82503: LIST
82504: PUSH
82505: LD_INT 4
82507: PUSH
82508: LD_INT 5
82510: PUSH
82511: EMPTY
82512: LIST
82513: LIST
82514: PUSH
82515: LD_INT 3
82517: PUSH
82518: LD_INT 4
82520: PUSH
82521: EMPTY
82522: LIST
82523: LIST
82524: PUSH
82525: LD_INT 3
82527: PUSH
82528: LD_INT 3
82530: PUSH
82531: EMPTY
82532: LIST
82533: LIST
82534: PUSH
82535: LD_INT 5
82537: PUSH
82538: LD_INT 3
82540: PUSH
82541: EMPTY
82542: LIST
82543: LIST
82544: PUSH
82545: LD_INT 3
82547: PUSH
82548: LD_INT 5
82550: PUSH
82551: EMPTY
82552: LIST
82553: LIST
82554: PUSH
82555: EMPTY
82556: LIST
82557: LIST
82558: LIST
82559: LIST
82560: LIST
82561: LIST
82562: LIST
82563: LIST
82564: LIST
82565: LIST
82566: LIST
82567: LIST
82568: LIST
82569: LIST
82570: LIST
82571: LIST
82572: LIST
82573: LIST
82574: LIST
82575: LIST
82576: LIST
82577: LIST
82578: LIST
82579: LIST
82580: LIST
82581: LIST
82582: LIST
82583: LIST
82584: LIST
82585: LIST
82586: LIST
82587: LIST
82588: LIST
82589: LIST
82590: LIST
82591: LIST
82592: LIST
82593: LIST
82594: LIST
82595: LIST
82596: LIST
82597: LIST
82598: LIST
82599: LIST
82600: LIST
82601: ST_TO_ADDR
// Factory4 = [ [ - 4 , - 4 ] , [ - 4 , - 5 ] , [ - 3 , - 4 ] , [ - 3 , - 3 ] , [ - 4 , - 3 ] , [ - 5 , - 4 ] , [ - 5 , - 5 ] , [ - 3 , - 5 ] , [ - 5 , - 3 ] , [ 0 , - 3 ] , [ 0 , - 4 ] , [ 1 , - 3 ] , [ 1 , - 2 ] , [ 0 , - 2 ] , [ - 1 , - 3 ] , [ - 1 , - 4 ] , [ 2 , - 2 ] , [ - 2 , - 4 ] , [ 4 , 0 ] , [ 4 , - 1 ] , [ 5 , 0 ] , [ 5 , 1 ] , [ 4 , 1 ] , [ 3 , 0 ] , [ 3 , - 1 ] , [ 3 , - 2 ] , [ 5 , 2 ] , [ 3 , 3 ] , [ 3 , 2 ] , [ 4 , 3 ] , [ 4 , 4 ] , [ 3 , 4 ] , [ 2 , 3 ] , [ 2 , 2 ] , [ 4 , 2 ] , [ 2 , 4 ] , [ 0 , 4 ] , [ 0 , 3 ] , [ 1 , 4 ] , [ 1 , 5 ] , [ 0 , 5 ] , [ - 1 , 4 ] , [ - 1 , 3 ] , [ 2 , 5 ] , [ - 2 , 3 ] ] ;
82602: LD_ADDR_VAR 0 33
82606: PUSH
82607: LD_INT 4
82609: NEG
82610: PUSH
82611: LD_INT 4
82613: NEG
82614: PUSH
82615: EMPTY
82616: LIST
82617: LIST
82618: PUSH
82619: LD_INT 4
82621: NEG
82622: PUSH
82623: LD_INT 5
82625: NEG
82626: PUSH
82627: EMPTY
82628: LIST
82629: LIST
82630: PUSH
82631: LD_INT 3
82633: NEG
82634: PUSH
82635: LD_INT 4
82637: NEG
82638: PUSH
82639: EMPTY
82640: LIST
82641: LIST
82642: PUSH
82643: LD_INT 3
82645: NEG
82646: PUSH
82647: LD_INT 3
82649: NEG
82650: PUSH
82651: EMPTY
82652: LIST
82653: LIST
82654: PUSH
82655: LD_INT 4
82657: NEG
82658: PUSH
82659: LD_INT 3
82661: NEG
82662: PUSH
82663: EMPTY
82664: LIST
82665: LIST
82666: PUSH
82667: LD_INT 5
82669: NEG
82670: PUSH
82671: LD_INT 4
82673: NEG
82674: PUSH
82675: EMPTY
82676: LIST
82677: LIST
82678: PUSH
82679: LD_INT 5
82681: NEG
82682: PUSH
82683: LD_INT 5
82685: NEG
82686: PUSH
82687: EMPTY
82688: LIST
82689: LIST
82690: PUSH
82691: LD_INT 3
82693: NEG
82694: PUSH
82695: LD_INT 5
82697: NEG
82698: PUSH
82699: EMPTY
82700: LIST
82701: LIST
82702: PUSH
82703: LD_INT 5
82705: NEG
82706: PUSH
82707: LD_INT 3
82709: NEG
82710: PUSH
82711: EMPTY
82712: LIST
82713: LIST
82714: PUSH
82715: LD_INT 0
82717: PUSH
82718: LD_INT 3
82720: NEG
82721: PUSH
82722: EMPTY
82723: LIST
82724: LIST
82725: PUSH
82726: LD_INT 0
82728: PUSH
82729: LD_INT 4
82731: NEG
82732: PUSH
82733: EMPTY
82734: LIST
82735: LIST
82736: PUSH
82737: LD_INT 1
82739: PUSH
82740: LD_INT 3
82742: NEG
82743: PUSH
82744: EMPTY
82745: LIST
82746: LIST
82747: PUSH
82748: LD_INT 1
82750: PUSH
82751: LD_INT 2
82753: NEG
82754: PUSH
82755: EMPTY
82756: LIST
82757: LIST
82758: PUSH
82759: LD_INT 0
82761: PUSH
82762: LD_INT 2
82764: NEG
82765: PUSH
82766: EMPTY
82767: LIST
82768: LIST
82769: PUSH
82770: LD_INT 1
82772: NEG
82773: PUSH
82774: LD_INT 3
82776: NEG
82777: PUSH
82778: EMPTY
82779: LIST
82780: LIST
82781: PUSH
82782: LD_INT 1
82784: NEG
82785: PUSH
82786: LD_INT 4
82788: NEG
82789: PUSH
82790: EMPTY
82791: LIST
82792: LIST
82793: PUSH
82794: LD_INT 2
82796: PUSH
82797: LD_INT 2
82799: NEG
82800: PUSH
82801: EMPTY
82802: LIST
82803: LIST
82804: PUSH
82805: LD_INT 2
82807: NEG
82808: PUSH
82809: LD_INT 4
82811: NEG
82812: PUSH
82813: EMPTY
82814: LIST
82815: LIST
82816: PUSH
82817: LD_INT 4
82819: PUSH
82820: LD_INT 0
82822: PUSH
82823: EMPTY
82824: LIST
82825: LIST
82826: PUSH
82827: LD_INT 4
82829: PUSH
82830: LD_INT 1
82832: NEG
82833: PUSH
82834: EMPTY
82835: LIST
82836: LIST
82837: PUSH
82838: LD_INT 5
82840: PUSH
82841: LD_INT 0
82843: PUSH
82844: EMPTY
82845: LIST
82846: LIST
82847: PUSH
82848: LD_INT 5
82850: PUSH
82851: LD_INT 1
82853: PUSH
82854: EMPTY
82855: LIST
82856: LIST
82857: PUSH
82858: LD_INT 4
82860: PUSH
82861: LD_INT 1
82863: PUSH
82864: EMPTY
82865: LIST
82866: LIST
82867: PUSH
82868: LD_INT 3
82870: PUSH
82871: LD_INT 0
82873: PUSH
82874: EMPTY
82875: LIST
82876: LIST
82877: PUSH
82878: LD_INT 3
82880: PUSH
82881: LD_INT 1
82883: NEG
82884: PUSH
82885: EMPTY
82886: LIST
82887: LIST
82888: PUSH
82889: LD_INT 3
82891: PUSH
82892: LD_INT 2
82894: NEG
82895: PUSH
82896: EMPTY
82897: LIST
82898: LIST
82899: PUSH
82900: LD_INT 5
82902: PUSH
82903: LD_INT 2
82905: PUSH
82906: EMPTY
82907: LIST
82908: LIST
82909: PUSH
82910: LD_INT 3
82912: PUSH
82913: LD_INT 3
82915: PUSH
82916: EMPTY
82917: LIST
82918: LIST
82919: PUSH
82920: LD_INT 3
82922: PUSH
82923: LD_INT 2
82925: PUSH
82926: EMPTY
82927: LIST
82928: LIST
82929: PUSH
82930: LD_INT 4
82932: PUSH
82933: LD_INT 3
82935: PUSH
82936: EMPTY
82937: LIST
82938: LIST
82939: PUSH
82940: LD_INT 4
82942: PUSH
82943: LD_INT 4
82945: PUSH
82946: EMPTY
82947: LIST
82948: LIST
82949: PUSH
82950: LD_INT 3
82952: PUSH
82953: LD_INT 4
82955: PUSH
82956: EMPTY
82957: LIST
82958: LIST
82959: PUSH
82960: LD_INT 2
82962: PUSH
82963: LD_INT 3
82965: PUSH
82966: EMPTY
82967: LIST
82968: LIST
82969: PUSH
82970: LD_INT 2
82972: PUSH
82973: LD_INT 2
82975: PUSH
82976: EMPTY
82977: LIST
82978: LIST
82979: PUSH
82980: LD_INT 4
82982: PUSH
82983: LD_INT 2
82985: PUSH
82986: EMPTY
82987: LIST
82988: LIST
82989: PUSH
82990: LD_INT 2
82992: PUSH
82993: LD_INT 4
82995: PUSH
82996: EMPTY
82997: LIST
82998: LIST
82999: PUSH
83000: LD_INT 0
83002: PUSH
83003: LD_INT 4
83005: PUSH
83006: EMPTY
83007: LIST
83008: LIST
83009: PUSH
83010: LD_INT 0
83012: PUSH
83013: LD_INT 3
83015: PUSH
83016: EMPTY
83017: LIST
83018: LIST
83019: PUSH
83020: LD_INT 1
83022: PUSH
83023: LD_INT 4
83025: PUSH
83026: EMPTY
83027: LIST
83028: LIST
83029: PUSH
83030: LD_INT 1
83032: PUSH
83033: LD_INT 5
83035: PUSH
83036: EMPTY
83037: LIST
83038: LIST
83039: PUSH
83040: LD_INT 0
83042: PUSH
83043: LD_INT 5
83045: PUSH
83046: EMPTY
83047: LIST
83048: LIST
83049: PUSH
83050: LD_INT 1
83052: NEG
83053: PUSH
83054: LD_INT 4
83056: PUSH
83057: EMPTY
83058: LIST
83059: LIST
83060: PUSH
83061: LD_INT 1
83063: NEG
83064: PUSH
83065: LD_INT 3
83067: PUSH
83068: EMPTY
83069: LIST
83070: LIST
83071: PUSH
83072: LD_INT 2
83074: PUSH
83075: LD_INT 5
83077: PUSH
83078: EMPTY
83079: LIST
83080: LIST
83081: PUSH
83082: LD_INT 2
83084: NEG
83085: PUSH
83086: LD_INT 3
83088: PUSH
83089: EMPTY
83090: LIST
83091: LIST
83092: PUSH
83093: EMPTY
83094: LIST
83095: LIST
83096: LIST
83097: LIST
83098: LIST
83099: LIST
83100: LIST
83101: LIST
83102: LIST
83103: LIST
83104: LIST
83105: LIST
83106: LIST
83107: LIST
83108: LIST
83109: LIST
83110: LIST
83111: LIST
83112: LIST
83113: LIST
83114: LIST
83115: LIST
83116: LIST
83117: LIST
83118: LIST
83119: LIST
83120: LIST
83121: LIST
83122: LIST
83123: LIST
83124: LIST
83125: LIST
83126: LIST
83127: LIST
83128: LIST
83129: LIST
83130: LIST
83131: LIST
83132: LIST
83133: LIST
83134: LIST
83135: LIST
83136: LIST
83137: LIST
83138: LIST
83139: ST_TO_ADDR
// Factory5 = [ [ 0 , - 4 ] , [ 0 , - 5 ] , [ 1 , - 4 ] , [ 1 , - 3 ] , [ 0 , - 3 ] , [ - 1 , - 4 ] , [ - 1 , - 5 ] , [ 2 , - 3 ] , [ - 2 , - 5 ] , [ 3 , 0 ] , [ 3 , - 1 ] , [ 4 , 0 ] , [ 4 , 1 ] , [ 3 , 1 ] , [ 2 , 0 ] , [ 2 , - 1 ] , [ 2 , - 2 ] , [ 4 , 2 ] , [ 4 , 4 ] , [ 4 , 3 ] , [ 5 , 4 ] , [ 5 , 5 ] , [ 4 , 5 ] , [ 3 , 4 ] , [ 3 , 3 ] , [ 5 , 3 ] , [ 3 , 5 ] , [ 0 , 3 ] , [ 0 , 2 ] , [ 1 , 3 ] , [ 1 , 4 ] , [ 0 , 4 ] , [ - 1 , 3 ] , [ - 1 , 2 ] , [ 2 , 4 ] , [ - 2 , 2 ] , [ - 4 , 0 ] , [ - 4 , - 1 ] , [ - 3 , 0 ] , [ - 3 , 1 ] , [ - 4 , 1 ] , [ - 5 , 0 ] , [ - 5 , - 1 ] , [ - 5 , - 2 ] , [ - 3 , 2 ] ] ;
83140: LD_ADDR_VAR 0 34
83144: PUSH
83145: LD_INT 0
83147: PUSH
83148: LD_INT 4
83150: NEG
83151: PUSH
83152: EMPTY
83153: LIST
83154: LIST
83155: PUSH
83156: LD_INT 0
83158: PUSH
83159: LD_INT 5
83161: NEG
83162: PUSH
83163: EMPTY
83164: LIST
83165: LIST
83166: PUSH
83167: LD_INT 1
83169: PUSH
83170: LD_INT 4
83172: NEG
83173: PUSH
83174: EMPTY
83175: LIST
83176: LIST
83177: PUSH
83178: LD_INT 1
83180: PUSH
83181: LD_INT 3
83183: NEG
83184: PUSH
83185: EMPTY
83186: LIST
83187: LIST
83188: PUSH
83189: LD_INT 0
83191: PUSH
83192: LD_INT 3
83194: NEG
83195: PUSH
83196: EMPTY
83197: LIST
83198: LIST
83199: PUSH
83200: LD_INT 1
83202: NEG
83203: PUSH
83204: LD_INT 4
83206: NEG
83207: PUSH
83208: EMPTY
83209: LIST
83210: LIST
83211: PUSH
83212: LD_INT 1
83214: NEG
83215: PUSH
83216: LD_INT 5
83218: NEG
83219: PUSH
83220: EMPTY
83221: LIST
83222: LIST
83223: PUSH
83224: LD_INT 2
83226: PUSH
83227: LD_INT 3
83229: NEG
83230: PUSH
83231: EMPTY
83232: LIST
83233: LIST
83234: PUSH
83235: LD_INT 2
83237: NEG
83238: PUSH
83239: LD_INT 5
83241: NEG
83242: PUSH
83243: EMPTY
83244: LIST
83245: LIST
83246: PUSH
83247: LD_INT 3
83249: PUSH
83250: LD_INT 0
83252: PUSH
83253: EMPTY
83254: LIST
83255: LIST
83256: PUSH
83257: LD_INT 3
83259: PUSH
83260: LD_INT 1
83262: NEG
83263: PUSH
83264: EMPTY
83265: LIST
83266: LIST
83267: PUSH
83268: LD_INT 4
83270: PUSH
83271: LD_INT 0
83273: PUSH
83274: EMPTY
83275: LIST
83276: LIST
83277: PUSH
83278: LD_INT 4
83280: PUSH
83281: LD_INT 1
83283: PUSH
83284: EMPTY
83285: LIST
83286: LIST
83287: PUSH
83288: LD_INT 3
83290: PUSH
83291: LD_INT 1
83293: PUSH
83294: EMPTY
83295: LIST
83296: LIST
83297: PUSH
83298: LD_INT 2
83300: PUSH
83301: LD_INT 0
83303: PUSH
83304: EMPTY
83305: LIST
83306: LIST
83307: PUSH
83308: LD_INT 2
83310: PUSH
83311: LD_INT 1
83313: NEG
83314: PUSH
83315: EMPTY
83316: LIST
83317: LIST
83318: PUSH
83319: LD_INT 2
83321: PUSH
83322: LD_INT 2
83324: NEG
83325: PUSH
83326: EMPTY
83327: LIST
83328: LIST
83329: PUSH
83330: LD_INT 4
83332: PUSH
83333: LD_INT 2
83335: PUSH
83336: EMPTY
83337: LIST
83338: LIST
83339: PUSH
83340: LD_INT 4
83342: PUSH
83343: LD_INT 4
83345: PUSH
83346: EMPTY
83347: LIST
83348: LIST
83349: PUSH
83350: LD_INT 4
83352: PUSH
83353: LD_INT 3
83355: PUSH
83356: EMPTY
83357: LIST
83358: LIST
83359: PUSH
83360: LD_INT 5
83362: PUSH
83363: LD_INT 4
83365: PUSH
83366: EMPTY
83367: LIST
83368: LIST
83369: PUSH
83370: LD_INT 5
83372: PUSH
83373: LD_INT 5
83375: PUSH
83376: EMPTY
83377: LIST
83378: LIST
83379: PUSH
83380: LD_INT 4
83382: PUSH
83383: LD_INT 5
83385: PUSH
83386: EMPTY
83387: LIST
83388: LIST
83389: PUSH
83390: LD_INT 3
83392: PUSH
83393: LD_INT 4
83395: PUSH
83396: EMPTY
83397: LIST
83398: LIST
83399: PUSH
83400: LD_INT 3
83402: PUSH
83403: LD_INT 3
83405: PUSH
83406: EMPTY
83407: LIST
83408: LIST
83409: PUSH
83410: LD_INT 5
83412: PUSH
83413: LD_INT 3
83415: PUSH
83416: EMPTY
83417: LIST
83418: LIST
83419: PUSH
83420: LD_INT 3
83422: PUSH
83423: LD_INT 5
83425: PUSH
83426: EMPTY
83427: LIST
83428: LIST
83429: PUSH
83430: LD_INT 0
83432: PUSH
83433: LD_INT 3
83435: PUSH
83436: EMPTY
83437: LIST
83438: LIST
83439: PUSH
83440: LD_INT 0
83442: PUSH
83443: LD_INT 2
83445: PUSH
83446: EMPTY
83447: LIST
83448: LIST
83449: PUSH
83450: LD_INT 1
83452: PUSH
83453: LD_INT 3
83455: PUSH
83456: EMPTY
83457: LIST
83458: LIST
83459: PUSH
83460: LD_INT 1
83462: PUSH
83463: LD_INT 4
83465: PUSH
83466: EMPTY
83467: LIST
83468: LIST
83469: PUSH
83470: LD_INT 0
83472: PUSH
83473: LD_INT 4
83475: PUSH
83476: EMPTY
83477: LIST
83478: LIST
83479: PUSH
83480: LD_INT 1
83482: NEG
83483: PUSH
83484: LD_INT 3
83486: PUSH
83487: EMPTY
83488: LIST
83489: LIST
83490: PUSH
83491: LD_INT 1
83493: NEG
83494: PUSH
83495: LD_INT 2
83497: PUSH
83498: EMPTY
83499: LIST
83500: LIST
83501: PUSH
83502: LD_INT 2
83504: PUSH
83505: LD_INT 4
83507: PUSH
83508: EMPTY
83509: LIST
83510: LIST
83511: PUSH
83512: LD_INT 2
83514: NEG
83515: PUSH
83516: LD_INT 2
83518: PUSH
83519: EMPTY
83520: LIST
83521: LIST
83522: PUSH
83523: LD_INT 4
83525: NEG
83526: PUSH
83527: LD_INT 0
83529: PUSH
83530: EMPTY
83531: LIST
83532: LIST
83533: PUSH
83534: LD_INT 4
83536: NEG
83537: PUSH
83538: LD_INT 1
83540: NEG
83541: PUSH
83542: EMPTY
83543: LIST
83544: LIST
83545: PUSH
83546: LD_INT 3
83548: NEG
83549: PUSH
83550: LD_INT 0
83552: PUSH
83553: EMPTY
83554: LIST
83555: LIST
83556: PUSH
83557: LD_INT 3
83559: NEG
83560: PUSH
83561: LD_INT 1
83563: PUSH
83564: EMPTY
83565: LIST
83566: LIST
83567: PUSH
83568: LD_INT 4
83570: NEG
83571: PUSH
83572: LD_INT 1
83574: PUSH
83575: EMPTY
83576: LIST
83577: LIST
83578: PUSH
83579: LD_INT 5
83581: NEG
83582: PUSH
83583: LD_INT 0
83585: PUSH
83586: EMPTY
83587: LIST
83588: LIST
83589: PUSH
83590: LD_INT 5
83592: NEG
83593: PUSH
83594: LD_INT 1
83596: NEG
83597: PUSH
83598: EMPTY
83599: LIST
83600: LIST
83601: PUSH
83602: LD_INT 5
83604: NEG
83605: PUSH
83606: LD_INT 2
83608: NEG
83609: PUSH
83610: EMPTY
83611: LIST
83612: LIST
83613: PUSH
83614: LD_INT 3
83616: NEG
83617: PUSH
83618: LD_INT 2
83620: PUSH
83621: EMPTY
83622: LIST
83623: LIST
83624: PUSH
83625: EMPTY
83626: LIST
83627: LIST
83628: LIST
83629: LIST
83630: LIST
83631: LIST
83632: LIST
83633: LIST
83634: LIST
83635: LIST
83636: LIST
83637: LIST
83638: LIST
83639: LIST
83640: LIST
83641: LIST
83642: LIST
83643: LIST
83644: LIST
83645: LIST
83646: LIST
83647: LIST
83648: LIST
83649: LIST
83650: LIST
83651: LIST
83652: LIST
83653: LIST
83654: LIST
83655: LIST
83656: LIST
83657: LIST
83658: LIST
83659: LIST
83660: LIST
83661: LIST
83662: LIST
83663: LIST
83664: LIST
83665: LIST
83666: LIST
83667: LIST
83668: LIST
83669: LIST
83670: LIST
83671: ST_TO_ADDR
// end ; end ;
83672: GO 83675
83674: POP
// case btype of b_depot , b_warehouse :
83675: LD_VAR 0 1
83679: PUSH
83680: LD_INT 0
83682: DOUBLE
83683: EQUAL
83684: IFTRUE 83694
83686: LD_INT 1
83688: DOUBLE
83689: EQUAL
83690: IFTRUE 83694
83692: GO 83895
83694: POP
// case nation of nation_american :
83695: LD_VAR 0 5
83699: PUSH
83700: LD_INT 1
83702: DOUBLE
83703: EQUAL
83704: IFTRUE 83708
83706: GO 83764
83708: POP
// temp_list = [ DepotAm0 , DepotAm1 , DepotAm2 , DepotAm3 , DepotAm4 , DepotAm5 ] [ dir + 1 ] ; nation_arabian :
83709: LD_ADDR_VAR 0 9
83713: PUSH
83714: LD_VAR 0 11
83718: PUSH
83719: LD_VAR 0 12
83723: PUSH
83724: LD_VAR 0 13
83728: PUSH
83729: LD_VAR 0 14
83733: PUSH
83734: LD_VAR 0 15
83738: PUSH
83739: LD_VAR 0 16
83743: PUSH
83744: EMPTY
83745: LIST
83746: LIST
83747: LIST
83748: LIST
83749: LIST
83750: LIST
83751: PUSH
83752: LD_VAR 0 4
83756: PUSH
83757: LD_INT 1
83759: PLUS
83760: ARRAY
83761: ST_TO_ADDR
83762: GO 83893
83764: LD_INT 2
83766: DOUBLE
83767: EQUAL
83768: IFTRUE 83772
83770: GO 83828
83772: POP
// temp_list = [ DepotAr0 , DepotAr1 , DepotAr2 , DepotAr3 , DepotAr4 , DepotAr5 ] [ dir + 1 ] ; nation_russian :
83773: LD_ADDR_VAR 0 9
83777: PUSH
83778: LD_VAR 0 17
83782: PUSH
83783: LD_VAR 0 18
83787: PUSH
83788: LD_VAR 0 19
83792: PUSH
83793: LD_VAR 0 20
83797: PUSH
83798: LD_VAR 0 21
83802: PUSH
83803: LD_VAR 0 22
83807: PUSH
83808: EMPTY
83809: LIST
83810: LIST
83811: LIST
83812: LIST
83813: LIST
83814: LIST
83815: PUSH
83816: LD_VAR 0 4
83820: PUSH
83821: LD_INT 1
83823: PLUS
83824: ARRAY
83825: ST_TO_ADDR
83826: GO 83893
83828: LD_INT 3
83830: DOUBLE
83831: EQUAL
83832: IFTRUE 83836
83834: GO 83892
83836: POP
// temp_list = [ DepotRu0 , DepotRu1 , DepotRu2 , DepotRu3 , DepotRu4 , DepotRu5 ] [ dir + 1 ] ; end ; b_workshop , b_factory :
83837: LD_ADDR_VAR 0 9
83841: PUSH
83842: LD_VAR 0 23
83846: PUSH
83847: LD_VAR 0 24
83851: PUSH
83852: LD_VAR 0 25
83856: PUSH
83857: LD_VAR 0 26
83861: PUSH
83862: LD_VAR 0 27
83866: PUSH
83867: LD_VAR 0 28
83871: PUSH
83872: EMPTY
83873: LIST
83874: LIST
83875: LIST
83876: LIST
83877: LIST
83878: LIST
83879: PUSH
83880: LD_VAR 0 4
83884: PUSH
83885: LD_INT 1
83887: PLUS
83888: ARRAY
83889: ST_TO_ADDR
83890: GO 83893
83892: POP
83893: GO 84448
83895: LD_INT 2
83897: DOUBLE
83898: EQUAL
83899: IFTRUE 83909
83901: LD_INT 3
83903: DOUBLE
83904: EQUAL
83905: IFTRUE 83909
83907: GO 83965
83909: POP
// temp_list = [ Factory0 , Factory1 , Factory2 , Factory3 , Factory4 , Factory5 ] [ dir + 1 ] ; b_ext_track , b_ext_gun , b_ext_rocket , b_ext_noncombat , b_ext_radio , b_ext_radar , b_ext_siberium , b_ext_stitch , b_ext_computer , b_ext_laser :
83910: LD_ADDR_VAR 0 9
83914: PUSH
83915: LD_VAR 0 29
83919: PUSH
83920: LD_VAR 0 30
83924: PUSH
83925: LD_VAR 0 31
83929: PUSH
83930: LD_VAR 0 32
83934: PUSH
83935: LD_VAR 0 33
83939: PUSH
83940: LD_VAR 0 34
83944: PUSH
83945: EMPTY
83946: LIST
83947: LIST
83948: LIST
83949: LIST
83950: LIST
83951: LIST
83952: PUSH
83953: LD_VAR 0 4
83957: PUSH
83958: LD_INT 1
83960: PLUS
83961: ARRAY
83962: ST_TO_ADDR
83963: GO 84448
83965: LD_INT 16
83967: DOUBLE
83968: EQUAL
83969: IFTRUE 84027
83971: LD_INT 17
83973: DOUBLE
83974: EQUAL
83975: IFTRUE 84027
83977: LD_INT 18
83979: DOUBLE
83980: EQUAL
83981: IFTRUE 84027
83983: LD_INT 19
83985: DOUBLE
83986: EQUAL
83987: IFTRUE 84027
83989: LD_INT 22
83991: DOUBLE
83992: EQUAL
83993: IFTRUE 84027
83995: LD_INT 20
83997: DOUBLE
83998: EQUAL
83999: IFTRUE 84027
84001: LD_INT 21
84003: DOUBLE
84004: EQUAL
84005: IFTRUE 84027
84007: LD_INT 23
84009: DOUBLE
84010: EQUAL
84011: IFTRUE 84027
84013: LD_INT 24
84015: DOUBLE
84016: EQUAL
84017: IFTRUE 84027
84019: LD_INT 25
84021: DOUBLE
84022: EQUAL
84023: IFTRUE 84027
84025: GO 84083
84027: POP
// temp_list = [ Ext0 , Ext1 , Ext2 , Ext3 , Ext4 , Ext5 ] [ dir + 1 ] ; b_lab , b_lab_half , b_lab_full , b_lab_biological , b_lab_computer , b_lab_opto , b_lab_siberium , b_lab_spacetime , b_lab_weapon :
84028: LD_ADDR_VAR 0 9
84032: PUSH
84033: LD_VAR 0 35
84037: PUSH
84038: LD_VAR 0 36
84042: PUSH
84043: LD_VAR 0 37
84047: PUSH
84048: LD_VAR 0 38
84052: PUSH
84053: LD_VAR 0 39
84057: PUSH
84058: LD_VAR 0 40
84062: PUSH
84063: EMPTY
84064: LIST
84065: LIST
84066: LIST
84067: LIST
84068: LIST
84069: LIST
84070: PUSH
84071: LD_VAR 0 4
84075: PUSH
84076: LD_INT 1
84078: PLUS
84079: ARRAY
84080: ST_TO_ADDR
84081: GO 84448
84083: LD_INT 6
84085: DOUBLE
84086: EQUAL
84087: IFTRUE 84139
84089: LD_INT 7
84091: DOUBLE
84092: EQUAL
84093: IFTRUE 84139
84095: LD_INT 8
84097: DOUBLE
84098: EQUAL
84099: IFTRUE 84139
84101: LD_INT 13
84103: DOUBLE
84104: EQUAL
84105: IFTRUE 84139
84107: LD_INT 12
84109: DOUBLE
84110: EQUAL
84111: IFTRUE 84139
84113: LD_INT 15
84115: DOUBLE
84116: EQUAL
84117: IFTRUE 84139
84119: LD_INT 11
84121: DOUBLE
84122: EQUAL
84123: IFTRUE 84139
84125: LD_INT 14
84127: DOUBLE
84128: EQUAL
84129: IFTRUE 84139
84131: LD_INT 10
84133: DOUBLE
84134: EQUAL
84135: IFTRUE 84139
84137: GO 84195
84139: POP
// temp_list = [ Lab0 , Lab1 , Lab2 , Lab3 , Lab4 , Lab5 ] [ dir + 1 ] ; b_control_tower :
84140: LD_ADDR_VAR 0 9
84144: PUSH
84145: LD_VAR 0 41
84149: PUSH
84150: LD_VAR 0 42
84154: PUSH
84155: LD_VAR 0 43
84159: PUSH
84160: LD_VAR 0 44
84164: PUSH
84165: LD_VAR 0 45
84169: PUSH
84170: LD_VAR 0 46
84174: PUSH
84175: EMPTY
84176: LIST
84177: LIST
84178: LIST
84179: LIST
84180: LIST
84181: LIST
84182: PUSH
84183: LD_VAR 0 4
84187: PUSH
84188: LD_INT 1
84190: PLUS
84191: ARRAY
84192: ST_TO_ADDR
84193: GO 84448
84195: LD_INT 36
84197: DOUBLE
84198: EQUAL
84199: IFTRUE 84203
84201: GO 84259
84203: POP
// temp_list = [ ControlTower0 , ControlTower1 , ControlTower2 , ControlTower3 , ControlTower4 , ControlTower5 ] [ dir + 1 ] ; b_armoury , b_barracks , b_teleport , b_behemoth :
84204: LD_ADDR_VAR 0 9
84208: PUSH
84209: LD_VAR 0 47
84213: PUSH
84214: LD_VAR 0 48
84218: PUSH
84219: LD_VAR 0 49
84223: PUSH
84224: LD_VAR 0 50
84228: PUSH
84229: LD_VAR 0 51
84233: PUSH
84234: LD_VAR 0 52
84238: PUSH
84239: EMPTY
84240: LIST
84241: LIST
84242: LIST
84243: LIST
84244: LIST
84245: LIST
84246: PUSH
84247: LD_VAR 0 4
84251: PUSH
84252: LD_INT 1
84254: PLUS
84255: ARRAY
84256: ST_TO_ADDR
84257: GO 84448
84259: LD_INT 4
84261: DOUBLE
84262: EQUAL
84263: IFTRUE 84285
84265: LD_INT 5
84267: DOUBLE
84268: EQUAL
84269: IFTRUE 84285
84271: LD_INT 34
84273: DOUBLE
84274: EQUAL
84275: IFTRUE 84285
84277: LD_INT 37
84279: DOUBLE
84280: EQUAL
84281: IFTRUE 84285
84283: GO 84341
84285: POP
// temp_list = [ Barracks0 , Barracks1 , Barracks2 , Barracks3 , Barracks4 , Barracks5 ] [ dir + 1 ] ; b_breastwork , b_bunker , b_turret , b_solar_power , b_oil_power , b_siberite_power , b_oil_mine , b_siberite_mine :
84286: LD_ADDR_VAR 0 9
84290: PUSH
84291: LD_VAR 0 53
84295: PUSH
84296: LD_VAR 0 54
84300: PUSH
84301: LD_VAR 0 55
84305: PUSH
84306: LD_VAR 0 56
84310: PUSH
84311: LD_VAR 0 57
84315: PUSH
84316: LD_VAR 0 58
84320: PUSH
84321: EMPTY
84322: LIST
84323: LIST
84324: LIST
84325: LIST
84326: LIST
84327: LIST
84328: PUSH
84329: LD_VAR 0 4
84333: PUSH
84334: LD_INT 1
84336: PLUS
84337: ARRAY
84338: ST_TO_ADDR
84339: GO 84448
84341: LD_INT 31
84343: DOUBLE
84344: EQUAL
84345: IFTRUE 84391
84347: LD_INT 32
84349: DOUBLE
84350: EQUAL
84351: IFTRUE 84391
84353: LD_INT 33
84355: DOUBLE
84356: EQUAL
84357: IFTRUE 84391
84359: LD_INT 27
84361: DOUBLE
84362: EQUAL
84363: IFTRUE 84391
84365: LD_INT 26
84367: DOUBLE
84368: EQUAL
84369: IFTRUE 84391
84371: LD_INT 28
84373: DOUBLE
84374: EQUAL
84375: IFTRUE 84391
84377: LD_INT 29
84379: DOUBLE
84380: EQUAL
84381: IFTRUE 84391
84383: LD_INT 30
84385: DOUBLE
84386: EQUAL
84387: IFTRUE 84391
84389: GO 84447
84391: POP
// temp_list = [ Bunker0 , Bunker1 , Bunker2 , Bunker3 , Bunker4 , Bunker5 ] [ dir + 1 ] ; end ;
84392: LD_ADDR_VAR 0 9
84396: PUSH
84397: LD_VAR 0 59
84401: PUSH
84402: LD_VAR 0 60
84406: PUSH
84407: LD_VAR 0 61
84411: PUSH
84412: LD_VAR 0 62
84416: PUSH
84417: LD_VAR 0 63
84421: PUSH
84422: LD_VAR 0 64
84426: PUSH
84427: EMPTY
84428: LIST
84429: LIST
84430: LIST
84431: LIST
84432: LIST
84433: LIST
84434: PUSH
84435: LD_VAR 0 4
84439: PUSH
84440: LD_INT 1
84442: PLUS
84443: ARRAY
84444: ST_TO_ADDR
84445: GO 84448
84447: POP
// temp_list2 = [ ] ;
84448: LD_ADDR_VAR 0 10
84452: PUSH
84453: EMPTY
84454: ST_TO_ADDR
// for i in temp_list do
84455: LD_ADDR_VAR 0 8
84459: PUSH
84460: LD_VAR 0 9
84464: PUSH
84465: FOR_IN
84466: IFFALSE 84518
// temp_list2 = temp_list2 ^ [ [ i [ 1 ] + x , i [ 2 ] + y ] ] ;
84468: LD_ADDR_VAR 0 10
84472: PUSH
84473: LD_VAR 0 10
84477: PUSH
84478: LD_VAR 0 8
84482: PUSH
84483: LD_INT 1
84485: ARRAY
84486: PUSH
84487: LD_VAR 0 2
84491: PLUS
84492: PUSH
84493: LD_VAR 0 8
84497: PUSH
84498: LD_INT 2
84500: ARRAY
84501: PUSH
84502: LD_VAR 0 3
84506: PLUS
84507: PUSH
84508: EMPTY
84509: LIST
84510: LIST
84511: PUSH
84512: EMPTY
84513: LIST
84514: ADD
84515: ST_TO_ADDR
84516: GO 84465
84518: POP
84519: POP
// result = temp_list2 ;
84520: LD_ADDR_VAR 0 7
84524: PUSH
84525: LD_VAR 0 10
84529: ST_TO_ADDR
// end ;
84530: LD_VAR 0 7
84534: RET
// export function EnemyInRange ( unit , dist ) ; begin
84535: LD_INT 0
84537: PPUSH
// result := DangerAtRangeXY ( GetSide ( unit ) , GetX ( unit ) , GetY ( unit ) , dist ) [ 4 ] ;
84538: LD_ADDR_VAR 0 3
84542: PUSH
84543: LD_VAR 0 1
84547: PPUSH
84548: CALL_OW 255
84552: PPUSH
84553: LD_VAR 0 1
84557: PPUSH
84558: CALL_OW 250
84562: PPUSH
84563: LD_VAR 0 1
84567: PPUSH
84568: CALL_OW 251
84572: PPUSH
84573: LD_VAR 0 2
84577: PPUSH
84578: CALL 58639 0 4
84582: PUSH
84583: LD_INT 4
84585: ARRAY
84586: ST_TO_ADDR
// end ;
84587: LD_VAR 0 3
84591: RET
// export function PlayerSeeMe ( unit ) ; begin
84592: LD_INT 0
84594: PPUSH
// result := See ( your_side , unit ) ;
84595: LD_ADDR_VAR 0 2
84599: PUSH
84600: LD_OWVAR 2
84604: PPUSH
84605: LD_VAR 0 1
84609: PPUSH
84610: CALL_OW 292
84614: ST_TO_ADDR
// end ;
84615: LD_VAR 0 2
84619: RET
// export function ReverseDir ( unit ) ; begin
84620: LD_INT 0
84622: PPUSH
// if not unit then
84623: LD_VAR 0 1
84627: NOT
84628: IFFALSE 84632
// exit ;
84630: GO 84655
// result := ( GetDir ( unit ) + 3 ) mod 6 ;
84632: LD_ADDR_VAR 0 2
84636: PUSH
84637: LD_VAR 0 1
84641: PPUSH
84642: CALL_OW 254
84646: PUSH
84647: LD_INT 3
84649: PLUS
84650: PUSH
84651: LD_INT 6
84653: MOD
84654: ST_TO_ADDR
// end ;
84655: LD_VAR 0 2
84659: RET
// export function GetClosestHex ( unit , hexes ) ; var i , dist , tmp , hex ; begin
84660: LD_INT 0
84662: PPUSH
84663: PPUSH
84664: PPUSH
84665: PPUSH
84666: PPUSH
// if not hexes then
84667: LD_VAR 0 2
84671: NOT
84672: IFFALSE 84676
// exit ;
84674: GO 84824
// dist := 9999 ;
84676: LD_ADDR_VAR 0 5
84680: PUSH
84681: LD_INT 9999
84683: ST_TO_ADDR
// for i = 1 to hexes do
84684: LD_ADDR_VAR 0 4
84688: PUSH
84689: DOUBLE
84690: LD_INT 1
84692: DEC
84693: ST_TO_ADDR
84694: LD_VAR 0 2
84698: PUSH
84699: FOR_TO
84700: IFFALSE 84812
// begin if GetDistUnitXY ( unit , hexes [ i ] [ 1 ] , hexes [ i ] [ 2 ] ) < dist then
84702: LD_VAR 0 1
84706: PPUSH
84707: LD_VAR 0 2
84711: PUSH
84712: LD_VAR 0 4
84716: ARRAY
84717: PUSH
84718: LD_INT 1
84720: ARRAY
84721: PPUSH
84722: LD_VAR 0 2
84726: PUSH
84727: LD_VAR 0 4
84731: ARRAY
84732: PUSH
84733: LD_INT 2
84735: ARRAY
84736: PPUSH
84737: CALL_OW 297
84741: PUSH
84742: LD_VAR 0 5
84746: LESS
84747: IFFALSE 84810
// begin hex := hexes [ i ] ;
84749: LD_ADDR_VAR 0 7
84753: PUSH
84754: LD_VAR 0 2
84758: PUSH
84759: LD_VAR 0 4
84763: ARRAY
84764: ST_TO_ADDR
// dist := GetDistUnitXY ( unit , hexes [ i ] [ 1 ] , hexes [ i ] [ 2 ] ) ;
84765: LD_ADDR_VAR 0 5
84769: PUSH
84770: LD_VAR 0 1
84774: PPUSH
84775: LD_VAR 0 2
84779: PUSH
84780: LD_VAR 0 4
84784: ARRAY
84785: PUSH
84786: LD_INT 1
84788: ARRAY
84789: PPUSH
84790: LD_VAR 0 2
84794: PUSH
84795: LD_VAR 0 4
84799: ARRAY
84800: PUSH
84801: LD_INT 2
84803: ARRAY
84804: PPUSH
84805: CALL_OW 297
84809: ST_TO_ADDR
// end ; end ;
84810: GO 84699
84812: POP
84813: POP
// result := hex ;
84814: LD_ADDR_VAR 0 3
84818: PUSH
84819: LD_VAR 0 7
84823: ST_TO_ADDR
// end ;
84824: LD_VAR 0 3
84828: RET
// export function ComAutodestruct ( unit ) ; var i ; begin
84829: LD_INT 0
84831: PPUSH
84832: PPUSH
// if not unit or not unit in FilterAllUnits ( [ [ f_type , unit_vehicle ] , [ f_nation , 2 ] ] ) then
84833: LD_VAR 0 1
84837: NOT
84838: PUSH
84839: LD_VAR 0 1
84843: PUSH
84844: LD_INT 21
84846: PUSH
84847: LD_INT 2
84849: PUSH
84850: EMPTY
84851: LIST
84852: LIST
84853: PUSH
84854: LD_INT 23
84856: PUSH
84857: LD_INT 2
84859: PUSH
84860: EMPTY
84861: LIST
84862: LIST
84863: PUSH
84864: EMPTY
84865: LIST
84866: LIST
84867: PPUSH
84868: CALL_OW 69
84872: IN
84873: NOT
84874: OR
84875: IFFALSE 84879
// exit ;
84877: GO 84926
// for i = 1 to 3 do
84879: LD_ADDR_VAR 0 3
84883: PUSH
84884: DOUBLE
84885: LD_INT 1
84887: DEC
84888: ST_TO_ADDR
84889: LD_INT 3
84891: PUSH
84892: FOR_TO
84893: IFFALSE 84924
// MineExplosion ( GetX ( unit ) , GetY ( unit ) , 1 ) ;
84895: LD_VAR 0 1
84899: PPUSH
84900: CALL_OW 250
84904: PPUSH
84905: LD_VAR 0 1
84909: PPUSH
84910: CALL_OW 251
84914: PPUSH
84915: LD_INT 1
84917: PPUSH
84918: CALL_OW 453
84922: GO 84892
84924: POP
84925: POP
// end ;
84926: LD_VAR 0 2
84930: RET
// export function AttackHovercraft ( unit , enemy_unit ) ; var i , j , tmp , x , y ; begin
84931: LD_INT 0
84933: PPUSH
84934: PPUSH
84935: PPUSH
84936: PPUSH
84937: PPUSH
84938: PPUSH
// if not unit or not enemy_unit or HasTask ( unit ) then
84939: LD_VAR 0 1
84943: NOT
84944: PUSH
84945: LD_VAR 0 2
84949: NOT
84950: OR
84951: PUSH
84952: LD_VAR 0 1
84956: PPUSH
84957: CALL_OW 314
84961: OR
84962: IFFALSE 84966
// exit ;
84964: GO 85407
// x := GetX ( enemy_unit ) ;
84966: LD_ADDR_VAR 0 7
84970: PUSH
84971: LD_VAR 0 2
84975: PPUSH
84976: CALL_OW 250
84980: ST_TO_ADDR
// y := GetY ( enemy_unit ) ;
84981: LD_ADDR_VAR 0 8
84985: PUSH
84986: LD_VAR 0 2
84990: PPUSH
84991: CALL_OW 251
84995: ST_TO_ADDR
// if not x or not y then
84996: LD_VAR 0 7
85000: NOT
85001: PUSH
85002: LD_VAR 0 8
85006: NOT
85007: OR
85008: IFFALSE 85012
// exit ;
85010: GO 85407
// tmp := [ [ ShiftX ( x , 0 , 4 ) , ShiftY ( y , 0 , 4 ) ] , [ ShiftX ( x , 1 , 4 ) , ShiftY ( y , 1 , 4 ) ] , [ ShiftX ( x , 2 , 4 ) , ShiftY ( y , 2 , 4 ) ] , [ ShiftX ( x , 3 , 4 ) , ShiftY ( y , 3 , 4 ) ] , [ ShiftX ( x , 4 , 4 ) , ShiftY ( y , 4 , 4 ) ] , [ ShiftX ( x , 5 , 4 ) , ShiftY ( y , 5 , 4 ) ] ] ;
85012: LD_ADDR_VAR 0 6
85016: PUSH
85017: LD_VAR 0 7
85021: PPUSH
85022: LD_INT 0
85024: PPUSH
85025: LD_INT 4
85027: PPUSH
85028: CALL_OW 272
85032: PUSH
85033: LD_VAR 0 8
85037: PPUSH
85038: LD_INT 0
85040: PPUSH
85041: LD_INT 4
85043: PPUSH
85044: CALL_OW 273
85048: PUSH
85049: EMPTY
85050: LIST
85051: LIST
85052: PUSH
85053: LD_VAR 0 7
85057: PPUSH
85058: LD_INT 1
85060: PPUSH
85061: LD_INT 4
85063: PPUSH
85064: CALL_OW 272
85068: PUSH
85069: LD_VAR 0 8
85073: PPUSH
85074: LD_INT 1
85076: PPUSH
85077: LD_INT 4
85079: PPUSH
85080: CALL_OW 273
85084: PUSH
85085: EMPTY
85086: LIST
85087: LIST
85088: PUSH
85089: LD_VAR 0 7
85093: PPUSH
85094: LD_INT 2
85096: PPUSH
85097: LD_INT 4
85099: PPUSH
85100: CALL_OW 272
85104: PUSH
85105: LD_VAR 0 8
85109: PPUSH
85110: LD_INT 2
85112: PPUSH
85113: LD_INT 4
85115: PPUSH
85116: CALL_OW 273
85120: PUSH
85121: EMPTY
85122: LIST
85123: LIST
85124: PUSH
85125: LD_VAR 0 7
85129: PPUSH
85130: LD_INT 3
85132: PPUSH
85133: LD_INT 4
85135: PPUSH
85136: CALL_OW 272
85140: PUSH
85141: LD_VAR 0 8
85145: PPUSH
85146: LD_INT 3
85148: PPUSH
85149: LD_INT 4
85151: PPUSH
85152: CALL_OW 273
85156: PUSH
85157: EMPTY
85158: LIST
85159: LIST
85160: PUSH
85161: LD_VAR 0 7
85165: PPUSH
85166: LD_INT 4
85168: PPUSH
85169: LD_INT 4
85171: PPUSH
85172: CALL_OW 272
85176: PUSH
85177: LD_VAR 0 8
85181: PPUSH
85182: LD_INT 4
85184: PPUSH
85185: LD_INT 4
85187: PPUSH
85188: CALL_OW 273
85192: PUSH
85193: EMPTY
85194: LIST
85195: LIST
85196: PUSH
85197: LD_VAR 0 7
85201: PPUSH
85202: LD_INT 5
85204: PPUSH
85205: LD_INT 4
85207: PPUSH
85208: CALL_OW 272
85212: PUSH
85213: LD_VAR 0 8
85217: PPUSH
85218: LD_INT 5
85220: PPUSH
85221: LD_INT 4
85223: PPUSH
85224: CALL_OW 273
85228: PUSH
85229: EMPTY
85230: LIST
85231: LIST
85232: PUSH
85233: EMPTY
85234: LIST
85235: LIST
85236: LIST
85237: LIST
85238: LIST
85239: LIST
85240: ST_TO_ADDR
// for i = tmp downto 1 do
85241: LD_ADDR_VAR 0 4
85245: PUSH
85246: DOUBLE
85247: LD_VAR 0 6
85251: INC
85252: ST_TO_ADDR
85253: LD_INT 1
85255: PUSH
85256: FOR_DOWNTO
85257: IFFALSE 85358
// if not ValidHex ( tmp [ i ] [ 1 ] , tmp [ i ] [ 2 ] ) or HexInfo ( tmp [ i ] [ 1 ] , tmp [ i ] [ 2 ] ) <> 0 then
85259: LD_VAR 0 6
85263: PUSH
85264: LD_VAR 0 4
85268: ARRAY
85269: PUSH
85270: LD_INT 1
85272: ARRAY
85273: PPUSH
85274: LD_VAR 0 6
85278: PUSH
85279: LD_VAR 0 4
85283: ARRAY
85284: PUSH
85285: LD_INT 2
85287: ARRAY
85288: PPUSH
85289: CALL_OW 488
85293: NOT
85294: PUSH
85295: LD_VAR 0 6
85299: PUSH
85300: LD_VAR 0 4
85304: ARRAY
85305: PUSH
85306: LD_INT 1
85308: ARRAY
85309: PPUSH
85310: LD_VAR 0 6
85314: PUSH
85315: LD_VAR 0 4
85319: ARRAY
85320: PUSH
85321: LD_INT 2
85323: ARRAY
85324: PPUSH
85325: CALL_OW 428
85329: PUSH
85330: LD_INT 0
85332: NONEQUAL
85333: OR
85334: IFFALSE 85356
// tmp := Delete ( tmp , i ) ;
85336: LD_ADDR_VAR 0 6
85340: PUSH
85341: LD_VAR 0 6
85345: PPUSH
85346: LD_VAR 0 4
85350: PPUSH
85351: CALL_OW 3
85355: ST_TO_ADDR
85356: GO 85256
85358: POP
85359: POP
// j := GetClosestHex ( unit , tmp ) ;
85360: LD_ADDR_VAR 0 5
85364: PUSH
85365: LD_VAR 0 1
85369: PPUSH
85370: LD_VAR 0 6
85374: PPUSH
85375: CALL 84660 0 2
85379: ST_TO_ADDR
// ComMoveXY ( unit , j [ 1 ] , j [ 2 ] ) ;
85380: LD_VAR 0 1
85384: PPUSH
85385: LD_VAR 0 5
85389: PUSH
85390: LD_INT 1
85392: ARRAY
85393: PPUSH
85394: LD_VAR 0 5
85398: PUSH
85399: LD_INT 2
85401: ARRAY
85402: PPUSH
85403: CALL_OW 111
// end ;
85407: LD_VAR 0 3
85411: RET
// export function PrepareNature ( birds , tigers , apemans , enchidnas , horses , mastodonts , fishes , nat_area , wat_area ) ; var i , animal ; begin
85412: LD_INT 0
85414: PPUSH
85415: PPUSH
85416: PPUSH
// uc_side = 0 ;
85417: LD_ADDR_OWVAR 20
85421: PUSH
85422: LD_INT 0
85424: ST_TO_ADDR
// uc_nation = 0 ;
85425: LD_ADDR_OWVAR 21
85429: PUSH
85430: LD_INT 0
85432: ST_TO_ADDR
// InitHc ;
85433: CALL_OW 19
// InitVc ;
85437: CALL_OW 20
// if mastodonts then
85441: LD_VAR 0 6
85445: IFFALSE 85512
// for i = 1 to mastodonts do
85447: LD_ADDR_VAR 0 11
85451: PUSH
85452: DOUBLE
85453: LD_INT 1
85455: DEC
85456: ST_TO_ADDR
85457: LD_VAR 0 6
85461: PUSH
85462: FOR_TO
85463: IFFALSE 85510
// begin vc_chassis := 31 ;
85465: LD_ADDR_OWVAR 37
85469: PUSH
85470: LD_INT 31
85472: ST_TO_ADDR
// vc_control := control_rider ;
85473: LD_ADDR_OWVAR 38
85477: PUSH
85478: LD_INT 4
85480: ST_TO_ADDR
// animal := CreateVehicle ;
85481: LD_ADDR_VAR 0 12
85485: PUSH
85486: CALL_OW 45
85490: ST_TO_ADDR
// PlaceUnitInArea ( animal , nat_area , false ) ;
85491: LD_VAR 0 12
85495: PPUSH
85496: LD_VAR 0 8
85500: PPUSH
85501: LD_INT 0
85503: PPUSH
85504: CALL 92283 0 3
// end ;
85508: GO 85462
85510: POP
85511: POP
// if horses then
85512: LD_VAR 0 5
85516: IFFALSE 85583
// for i = 1 to horses do
85518: LD_ADDR_VAR 0 11
85522: PUSH
85523: DOUBLE
85524: LD_INT 1
85526: DEC
85527: ST_TO_ADDR
85528: LD_VAR 0 5
85532: PUSH
85533: FOR_TO
85534: IFFALSE 85581
// begin hc_class := 21 ;
85536: LD_ADDR_OWVAR 28
85540: PUSH
85541: LD_INT 21
85543: ST_TO_ADDR
// hc_gallery :=  ;
85544: LD_ADDR_OWVAR 33
85548: PUSH
85549: LD_STRING 
85551: ST_TO_ADDR
// animal := CreateHuman ;
85552: LD_ADDR_VAR 0 12
85556: PUSH
85557: CALL_OW 44
85561: ST_TO_ADDR
// PlaceUnitInArea ( animal , nat_area , false ) ;
85562: LD_VAR 0 12
85566: PPUSH
85567: LD_VAR 0 8
85571: PPUSH
85572: LD_INT 0
85574: PPUSH
85575: CALL 92283 0 3
// end ;
85579: GO 85533
85581: POP
85582: POP
// if birds then
85583: LD_VAR 0 1
85587: IFFALSE 85654
// for i = 1 to birds do
85589: LD_ADDR_VAR 0 11
85593: PUSH
85594: DOUBLE
85595: LD_INT 1
85597: DEC
85598: ST_TO_ADDR
85599: LD_VAR 0 1
85603: PUSH
85604: FOR_TO
85605: IFFALSE 85652
// begin hc_class = 18 ;
85607: LD_ADDR_OWVAR 28
85611: PUSH
85612: LD_INT 18
85614: ST_TO_ADDR
// hc_gallery =  ;
85615: LD_ADDR_OWVAR 33
85619: PUSH
85620: LD_STRING 
85622: ST_TO_ADDR
// animal := CreateHuman ;
85623: LD_ADDR_VAR 0 12
85627: PUSH
85628: CALL_OW 44
85632: ST_TO_ADDR
// PlaceUnitInArea ( animal , nat_area , false ) ;
85633: LD_VAR 0 12
85637: PPUSH
85638: LD_VAR 0 8
85642: PPUSH
85643: LD_INT 0
85645: PPUSH
85646: CALL 92283 0 3
// end ;
85650: GO 85604
85652: POP
85653: POP
// if tigers then
85654: LD_VAR 0 2
85658: IFFALSE 85742
// for i = 1 to tigers do
85660: LD_ADDR_VAR 0 11
85664: PUSH
85665: DOUBLE
85666: LD_INT 1
85668: DEC
85669: ST_TO_ADDR
85670: LD_VAR 0 2
85674: PUSH
85675: FOR_TO
85676: IFFALSE 85740
// begin hc_class = class_tiger ;
85678: LD_ADDR_OWVAR 28
85682: PUSH
85683: LD_INT 14
85685: ST_TO_ADDR
// hc_gallery =  ;
85686: LD_ADDR_OWVAR 33
85690: PUSH
85691: LD_STRING 
85693: ST_TO_ADDR
// hc_agressivity = Rand ( - 7 , 7 ) ;
85694: LD_ADDR_OWVAR 35
85698: PUSH
85699: LD_INT 7
85701: NEG
85702: PPUSH
85703: LD_INT 7
85705: PPUSH
85706: CALL_OW 12
85710: ST_TO_ADDR
// animal := CreateHuman ;
85711: LD_ADDR_VAR 0 12
85715: PUSH
85716: CALL_OW 44
85720: ST_TO_ADDR
// PlaceUnitInArea ( animal , nat_area , false ) ;
85721: LD_VAR 0 12
85725: PPUSH
85726: LD_VAR 0 8
85730: PPUSH
85731: LD_INT 0
85733: PPUSH
85734: CALL 92283 0 3
// end ;
85738: GO 85675
85740: POP
85741: POP
// if apemans then
85742: LD_VAR 0 3
85746: IFFALSE 85869
// for i = 1 to apemans do
85748: LD_ADDR_VAR 0 11
85752: PUSH
85753: DOUBLE
85754: LD_INT 1
85756: DEC
85757: ST_TO_ADDR
85758: LD_VAR 0 3
85762: PUSH
85763: FOR_TO
85764: IFFALSE 85867
// begin hc_class = class_apeman ;
85766: LD_ADDR_OWVAR 28
85770: PUSH
85771: LD_INT 12
85773: ST_TO_ADDR
// hc_gallery =  ;
85774: LD_ADDR_OWVAR 33
85778: PUSH
85779: LD_STRING 
85781: ST_TO_ADDR
// hc_agressivity = rand ( - 5 , 5 ) ;
85782: LD_ADDR_OWVAR 35
85786: PUSH
85787: LD_INT 5
85789: NEG
85790: PPUSH
85791: LD_INT 5
85793: PPUSH
85794: CALL_OW 12
85798: ST_TO_ADDR
// hc_skills := [ rand ( 1 , 3 ) , rand ( 1 , 3 ) , 0 , 0 ] ;
85799: LD_ADDR_OWVAR 31
85803: PUSH
85804: LD_INT 1
85806: PPUSH
85807: LD_INT 3
85809: PPUSH
85810: CALL_OW 12
85814: PUSH
85815: LD_INT 1
85817: PPUSH
85818: LD_INT 3
85820: PPUSH
85821: CALL_OW 12
85825: PUSH
85826: LD_INT 0
85828: PUSH
85829: LD_INT 0
85831: PUSH
85832: EMPTY
85833: LIST
85834: LIST
85835: LIST
85836: LIST
85837: ST_TO_ADDR
// animal := CreateHuman ;
85838: LD_ADDR_VAR 0 12
85842: PUSH
85843: CALL_OW 44
85847: ST_TO_ADDR
// PlaceUnitInArea ( animal , nat_area , false ) ;
85848: LD_VAR 0 12
85852: PPUSH
85853: LD_VAR 0 8
85857: PPUSH
85858: LD_INT 0
85860: PPUSH
85861: CALL 92283 0 3
// end ;
85865: GO 85763
85867: POP
85868: POP
// if enchidnas then
85869: LD_VAR 0 4
85873: IFFALSE 85940
// for i = 1 to enchidnas do
85875: LD_ADDR_VAR 0 11
85879: PUSH
85880: DOUBLE
85881: LD_INT 1
85883: DEC
85884: ST_TO_ADDR
85885: LD_VAR 0 4
85889: PUSH
85890: FOR_TO
85891: IFFALSE 85938
// begin hc_class = 13 ;
85893: LD_ADDR_OWVAR 28
85897: PUSH
85898: LD_INT 13
85900: ST_TO_ADDR
// hc_gallery =  ;
85901: LD_ADDR_OWVAR 33
85905: PUSH
85906: LD_STRING 
85908: ST_TO_ADDR
// animal := CreateHuman ;
85909: LD_ADDR_VAR 0 12
85913: PUSH
85914: CALL_OW 44
85918: ST_TO_ADDR
// PlaceUnitInArea ( animal , nat_area , false ) ;
85919: LD_VAR 0 12
85923: PPUSH
85924: LD_VAR 0 8
85928: PPUSH
85929: LD_INT 0
85931: PPUSH
85932: CALL 92283 0 3
// end ;
85936: GO 85890
85938: POP
85939: POP
// if fishes then
85940: LD_VAR 0 7
85944: IFFALSE 86011
// for i = 1 to fishes do
85946: LD_ADDR_VAR 0 11
85950: PUSH
85951: DOUBLE
85952: LD_INT 1
85954: DEC
85955: ST_TO_ADDR
85956: LD_VAR 0 7
85960: PUSH
85961: FOR_TO
85962: IFFALSE 86009
// begin hc_class = 20 ;
85964: LD_ADDR_OWVAR 28
85968: PUSH
85969: LD_INT 20
85971: ST_TO_ADDR
// hc_gallery =  ;
85972: LD_ADDR_OWVAR 33
85976: PUSH
85977: LD_STRING 
85979: ST_TO_ADDR
// animal := CreateHuman ;
85980: LD_ADDR_VAR 0 12
85984: PUSH
85985: CALL_OW 44
85989: ST_TO_ADDR
// PlaceUnitInArea ( animal , wat_area , false ) ;
85990: LD_VAR 0 12
85994: PPUSH
85995: LD_VAR 0 9
85999: PPUSH
86000: LD_INT 0
86002: PPUSH
86003: CALL 92283 0 3
// end ;
86007: GO 85961
86009: POP
86010: POP
// end ;
86011: LD_VAR 0 10
86015: RET
// export function WantHeal ( sci , unit ) ; begin
86016: LD_INT 0
86018: PPUSH
// if GetTaskList ( sci ) > 0 then
86019: LD_VAR 0 1
86023: PPUSH
86024: CALL_OW 437
86028: PUSH
86029: LD_INT 0
86031: GREATER
86032: IFFALSE 86102
// begin if GetTaskList ( sci ) [ 1 ] [ 1 ] = l and GetTaskList ( sci ) [ 1 ] [ 4 ] = unit then
86034: LD_VAR 0 1
86038: PPUSH
86039: CALL_OW 437
86043: PUSH
86044: LD_INT 1
86046: ARRAY
86047: PUSH
86048: LD_INT 1
86050: ARRAY
86051: PUSH
86052: LD_STRING l
86054: EQUAL
86055: PUSH
86056: LD_VAR 0 1
86060: PPUSH
86061: CALL_OW 437
86065: PUSH
86066: LD_INT 1
86068: ARRAY
86069: PUSH
86070: LD_INT 4
86072: ARRAY
86073: PUSH
86074: LD_VAR 0 2
86078: EQUAL
86079: AND
86080: IFFALSE 86092
// result := true else
86082: LD_ADDR_VAR 0 3
86086: PUSH
86087: LD_INT 1
86089: ST_TO_ADDR
86090: GO 86100
// result := false ;
86092: LD_ADDR_VAR 0 3
86096: PUSH
86097: LD_INT 0
86099: ST_TO_ADDR
// end else
86100: GO 86110
// result := false ;
86102: LD_ADDR_VAR 0 3
86106: PUSH
86107: LD_INT 0
86109: ST_TO_ADDR
// end ;
86110: LD_VAR 0 3
86114: RET
// export function HealTarget ( sci ) ; begin
86115: LD_INT 0
86117: PPUSH
// if not sci then
86118: LD_VAR 0 1
86122: NOT
86123: IFFALSE 86127
// exit ;
86125: GO 86192
// result := 0 ;
86127: LD_ADDR_VAR 0 2
86131: PUSH
86132: LD_INT 0
86134: ST_TO_ADDR
// if GetTaskList ( sci ) then
86135: LD_VAR 0 1
86139: PPUSH
86140: CALL_OW 437
86144: IFFALSE 86192
// if GetTaskList ( sci ) [ 1 ] [ 1 ] = l then
86146: LD_VAR 0 1
86150: PPUSH
86151: CALL_OW 437
86155: PUSH
86156: LD_INT 1
86158: ARRAY
86159: PUSH
86160: LD_INT 1
86162: ARRAY
86163: PUSH
86164: LD_STRING l
86166: EQUAL
86167: IFFALSE 86192
// result := GetTaskList ( sci ) [ 1 ] [ 4 ] ;
86169: LD_ADDR_VAR 0 2
86173: PUSH
86174: LD_VAR 0 1
86178: PPUSH
86179: CALL_OW 437
86183: PUSH
86184: LD_INT 1
86186: ARRAY
86187: PUSH
86188: LD_INT 4
86190: ARRAY
86191: ST_TO_ADDR
// end ;
86192: LD_VAR 0 2
86196: RET
// export function Attack ( list ) ; var base , group , path , flags , i , j , k , x , y , d , z , tmp , tmp2 , units_path , f_ignore_area , f_capture , f_ignore_civ , f_murder , f_mines , f_repair , f_heal , f_spacetime , f_attack_depot , f_crawl , mined , bombed , attacking , to_heal , healers , to_repair , repairs , empty_vehs , side ; begin
86197: LD_INT 0
86199: PPUSH
86200: PPUSH
86201: PPUSH
86202: PPUSH
86203: PPUSH
86204: PPUSH
86205: PPUSH
86206: PPUSH
86207: PPUSH
86208: PPUSH
86209: PPUSH
86210: PPUSH
86211: PPUSH
86212: PPUSH
86213: PPUSH
86214: PPUSH
86215: PPUSH
86216: PPUSH
86217: PPUSH
86218: PPUSH
86219: PPUSH
86220: PPUSH
86221: PPUSH
86222: PPUSH
86223: PPUSH
86224: PPUSH
86225: PPUSH
86226: PPUSH
86227: PPUSH
86228: PPUSH
86229: PPUSH
86230: PPUSH
86231: PPUSH
86232: PPUSH
// if not list then
86233: LD_VAR 0 1
86237: NOT
86238: IFFALSE 86242
// exit ;
86240: GO 90894
// base := list [ 1 ] ;
86242: LD_ADDR_VAR 0 3
86246: PUSH
86247: LD_VAR 0 1
86251: PUSH
86252: LD_INT 1
86254: ARRAY
86255: ST_TO_ADDR
// group := list [ 2 ] ;
86256: LD_ADDR_VAR 0 4
86260: PUSH
86261: LD_VAR 0 1
86265: PUSH
86266: LD_INT 2
86268: ARRAY
86269: ST_TO_ADDR
// path := list [ 3 ] ;
86270: LD_ADDR_VAR 0 5
86274: PUSH
86275: LD_VAR 0 1
86279: PUSH
86280: LD_INT 3
86282: ARRAY
86283: ST_TO_ADDR
// flags := list [ 4 ] ;
86284: LD_ADDR_VAR 0 6
86288: PUSH
86289: LD_VAR 0 1
86293: PUSH
86294: LD_INT 4
86296: ARRAY
86297: ST_TO_ADDR
// mined := [ ] ;
86298: LD_ADDR_VAR 0 27
86302: PUSH
86303: EMPTY
86304: ST_TO_ADDR
// bombed := [ ] ;
86305: LD_ADDR_VAR 0 28
86309: PUSH
86310: EMPTY
86311: ST_TO_ADDR
// healers := [ ] ;
86312: LD_ADDR_VAR 0 31
86316: PUSH
86317: EMPTY
86318: ST_TO_ADDR
// to_heal := [ ] ;
86319: LD_ADDR_VAR 0 30
86323: PUSH
86324: EMPTY
86325: ST_TO_ADDR
// repairs := [ ] ;
86326: LD_ADDR_VAR 0 33
86330: PUSH
86331: EMPTY
86332: ST_TO_ADDR
// to_repair := [ ] ;
86333: LD_ADDR_VAR 0 32
86337: PUSH
86338: EMPTY
86339: ST_TO_ADDR
// if not group or not path then
86340: LD_VAR 0 4
86344: NOT
86345: PUSH
86346: LD_VAR 0 5
86350: NOT
86351: OR
86352: IFFALSE 86356
// exit ;
86354: GO 90894
// side := GetSide ( group [ 1 ] ) ;
86356: LD_ADDR_VAR 0 35
86360: PUSH
86361: LD_VAR 0 4
86365: PUSH
86366: LD_INT 1
86368: ARRAY
86369: PPUSH
86370: CALL_OW 255
86374: ST_TO_ADDR
// if flags then
86375: LD_VAR 0 6
86379: IFFALSE 86523
// begin f_ignore_area := flags [ 1 ] ;
86381: LD_ADDR_VAR 0 17
86385: PUSH
86386: LD_VAR 0 6
86390: PUSH
86391: LD_INT 1
86393: ARRAY
86394: ST_TO_ADDR
// f_capture := flags [ 2 ] ;
86395: LD_ADDR_VAR 0 18
86399: PUSH
86400: LD_VAR 0 6
86404: PUSH
86405: LD_INT 2
86407: ARRAY
86408: ST_TO_ADDR
// f_ignore_civ := flags [ 3 ] ;
86409: LD_ADDR_VAR 0 19
86413: PUSH
86414: LD_VAR 0 6
86418: PUSH
86419: LD_INT 3
86421: ARRAY
86422: ST_TO_ADDR
// f_murder := flags [ 4 ] ;
86423: LD_ADDR_VAR 0 20
86427: PUSH
86428: LD_VAR 0 6
86432: PUSH
86433: LD_INT 4
86435: ARRAY
86436: ST_TO_ADDR
// f_mines := flags [ 5 ] ;
86437: LD_ADDR_VAR 0 21
86441: PUSH
86442: LD_VAR 0 6
86446: PUSH
86447: LD_INT 5
86449: ARRAY
86450: ST_TO_ADDR
// f_repair := flags [ 6 ] ;
86451: LD_ADDR_VAR 0 22
86455: PUSH
86456: LD_VAR 0 6
86460: PUSH
86461: LD_INT 6
86463: ARRAY
86464: ST_TO_ADDR
// f_heal := flags [ 7 ] ;
86465: LD_ADDR_VAR 0 23
86469: PUSH
86470: LD_VAR 0 6
86474: PUSH
86475: LD_INT 7
86477: ARRAY
86478: ST_TO_ADDR
// f_spacetime := flags [ 8 ] ;
86479: LD_ADDR_VAR 0 24
86483: PUSH
86484: LD_VAR 0 6
86488: PUSH
86489: LD_INT 8
86491: ARRAY
86492: ST_TO_ADDR
// f_attack_depot := flags [ 9 ] ;
86493: LD_ADDR_VAR 0 25
86497: PUSH
86498: LD_VAR 0 6
86502: PUSH
86503: LD_INT 9
86505: ARRAY
86506: ST_TO_ADDR
// f_crawl := flags [ 10 ] ;
86507: LD_ADDR_VAR 0 26
86511: PUSH
86512: LD_VAR 0 6
86516: PUSH
86517: LD_INT 10
86519: ARRAY
86520: ST_TO_ADDR
// end else
86521: GO 86603
// begin f_ignore_area := false ;
86523: LD_ADDR_VAR 0 17
86527: PUSH
86528: LD_INT 0
86530: ST_TO_ADDR
// f_capture := false ;
86531: LD_ADDR_VAR 0 18
86535: PUSH
86536: LD_INT 0
86538: ST_TO_ADDR
// f_ignore_civ := false ;
86539: LD_ADDR_VAR 0 19
86543: PUSH
86544: LD_INT 0
86546: ST_TO_ADDR
// f_murder := false ;
86547: LD_ADDR_VAR 0 20
86551: PUSH
86552: LD_INT 0
86554: ST_TO_ADDR
// f_mines := false ;
86555: LD_ADDR_VAR 0 21
86559: PUSH
86560: LD_INT 0
86562: ST_TO_ADDR
// f_repair := false ;
86563: LD_ADDR_VAR 0 22
86567: PUSH
86568: LD_INT 0
86570: ST_TO_ADDR
// f_heal := false ;
86571: LD_ADDR_VAR 0 23
86575: PUSH
86576: LD_INT 0
86578: ST_TO_ADDR
// f_spacetime := false ;
86579: LD_ADDR_VAR 0 24
86583: PUSH
86584: LD_INT 0
86586: ST_TO_ADDR
// f_attack_depot := false ;
86587: LD_ADDR_VAR 0 25
86591: PUSH
86592: LD_INT 0
86594: ST_TO_ADDR
// f_crawl := false ;
86595: LD_ADDR_VAR 0 26
86599: PUSH
86600: LD_INT 0
86602: ST_TO_ADDR
// end ; if f_heal then
86603: LD_VAR 0 23
86607: IFFALSE 86634
// healers := UnitFilter ( group , [ f_class , 4 ] ) ;
86609: LD_ADDR_VAR 0 31
86613: PUSH
86614: LD_VAR 0 4
86618: PPUSH
86619: LD_INT 25
86621: PUSH
86622: LD_INT 4
86624: PUSH
86625: EMPTY
86626: LIST
86627: LIST
86628: PPUSH
86629: CALL_OW 72
86633: ST_TO_ADDR
// if f_repair then
86634: LD_VAR 0 22
86638: IFFALSE 86665
// repairs := UnitFilter ( group , [ f_class , 3 ] ) ;
86640: LD_ADDR_VAR 0 33
86644: PUSH
86645: LD_VAR 0 4
86649: PPUSH
86650: LD_INT 25
86652: PUSH
86653: LD_INT 3
86655: PUSH
86656: EMPTY
86657: LIST
86658: LIST
86659: PPUSH
86660: CALL_OW 72
86664: ST_TO_ADDR
// units_path := [ ] ;
86665: LD_ADDR_VAR 0 16
86669: PUSH
86670: EMPTY
86671: ST_TO_ADDR
// for i = 1 to group do
86672: LD_ADDR_VAR 0 7
86676: PUSH
86677: DOUBLE
86678: LD_INT 1
86680: DEC
86681: ST_TO_ADDR
86682: LD_VAR 0 4
86686: PUSH
86687: FOR_TO
86688: IFFALSE 86717
// units_path := Replace ( units_path , i , path ) ;
86690: LD_ADDR_VAR 0 16
86694: PUSH
86695: LD_VAR 0 16
86699: PPUSH
86700: LD_VAR 0 7
86704: PPUSH
86705: LD_VAR 0 5
86709: PPUSH
86710: CALL_OW 1
86714: ST_TO_ADDR
86715: GO 86687
86717: POP
86718: POP
// repeat for i = group downto 1 do
86719: LD_ADDR_VAR 0 7
86723: PUSH
86724: DOUBLE
86725: LD_VAR 0 4
86729: INC
86730: ST_TO_ADDR
86731: LD_INT 1
86733: PUSH
86734: FOR_DOWNTO
86735: IFFALSE 90857
// begin wait ( 5 ) ;
86737: LD_INT 5
86739: PPUSH
86740: CALL_OW 67
// tmp := [ ] ;
86744: LD_ADDR_VAR 0 14
86748: PUSH
86749: EMPTY
86750: ST_TO_ADDR
// attacking := false ;
86751: LD_ADDR_VAR 0 29
86755: PUSH
86756: LD_INT 0
86758: ST_TO_ADDR
// if IsDead ( group [ i ] ) or not group [ i ] then
86759: LD_VAR 0 4
86763: PUSH
86764: LD_VAR 0 7
86768: ARRAY
86769: PPUSH
86770: CALL_OW 301
86774: PUSH
86775: LD_VAR 0 4
86779: PUSH
86780: LD_VAR 0 7
86784: ARRAY
86785: NOT
86786: OR
86787: IFFALSE 86896
// begin if GetType ( group [ i ] ) = unit_human then
86789: LD_VAR 0 4
86793: PUSH
86794: LD_VAR 0 7
86798: ARRAY
86799: PPUSH
86800: CALL_OW 247
86804: PUSH
86805: LD_INT 1
86807: EQUAL
86808: IFFALSE 86854
// begin to_heal := to_heal diff group [ i ] ;
86810: LD_ADDR_VAR 0 30
86814: PUSH
86815: LD_VAR 0 30
86819: PUSH
86820: LD_VAR 0 4
86824: PUSH
86825: LD_VAR 0 7
86829: ARRAY
86830: DIFF
86831: ST_TO_ADDR
// healers := healers diff group [ i ] ;
86832: LD_ADDR_VAR 0 31
86836: PUSH
86837: LD_VAR 0 31
86841: PUSH
86842: LD_VAR 0 4
86846: PUSH
86847: LD_VAR 0 7
86851: ARRAY
86852: DIFF
86853: ST_TO_ADDR
// end ; group := Delete ( group , i ) ;
86854: LD_ADDR_VAR 0 4
86858: PUSH
86859: LD_VAR 0 4
86863: PPUSH
86864: LD_VAR 0 7
86868: PPUSH
86869: CALL_OW 3
86873: ST_TO_ADDR
// units_path := Delete ( units_path , i ) ;
86874: LD_ADDR_VAR 0 16
86878: PUSH
86879: LD_VAR 0 16
86883: PPUSH
86884: LD_VAR 0 7
86888: PPUSH
86889: CALL_OW 3
86893: ST_TO_ADDR
// continue ;
86894: GO 86734
// end ; if f_repair then
86896: LD_VAR 0 22
86900: IFFALSE 87389
// begin if GetType ( group [ i ] ) = unit_vehicle then
86902: LD_VAR 0 4
86906: PUSH
86907: LD_VAR 0 7
86911: ARRAY
86912: PPUSH
86913: CALL_OW 247
86917: PUSH
86918: LD_INT 2
86920: EQUAL
86921: IFFALSE 87111
// begin if GetLives ( group [ i ] ) < 700 and not group [ i ] in to_repair then
86923: LD_VAR 0 4
86927: PUSH
86928: LD_VAR 0 7
86932: ARRAY
86933: PPUSH
86934: CALL_OW 256
86938: PUSH
86939: LD_INT 700
86941: LESS
86942: PUSH
86943: LD_VAR 0 4
86947: PUSH
86948: LD_VAR 0 7
86952: ARRAY
86953: PUSH
86954: LD_VAR 0 32
86958: IN
86959: NOT
86960: AND
86961: IFFALSE 86985
// to_repair := to_repair union group [ i ] ;
86963: LD_ADDR_VAR 0 32
86967: PUSH
86968: LD_VAR 0 32
86972: PUSH
86973: LD_VAR 0 4
86977: PUSH
86978: LD_VAR 0 7
86982: ARRAY
86983: UNION
86984: ST_TO_ADDR
// if GetLives ( group [ i ] ) = 1000 and group [ i ] in to_repair then
86985: LD_VAR 0 4
86989: PUSH
86990: LD_VAR 0 7
86994: ARRAY
86995: PPUSH
86996: CALL_OW 256
87000: PUSH
87001: LD_INT 1000
87003: EQUAL
87004: PUSH
87005: LD_VAR 0 4
87009: PUSH
87010: LD_VAR 0 7
87014: ARRAY
87015: PUSH
87016: LD_VAR 0 32
87020: IN
87021: AND
87022: IFFALSE 87046
// to_repair := to_repair diff group [ i ] ;
87024: LD_ADDR_VAR 0 32
87028: PUSH
87029: LD_VAR 0 32
87033: PUSH
87034: LD_VAR 0 4
87038: PUSH
87039: LD_VAR 0 7
87043: ARRAY
87044: DIFF
87045: ST_TO_ADDR
// if group [ i ] in to_repair then
87046: LD_VAR 0 4
87050: PUSH
87051: LD_VAR 0 7
87055: ARRAY
87056: PUSH
87057: LD_VAR 0 32
87061: IN
87062: IFFALSE 87109
// begin if not IsInArea ( group [ i ] , f_repair ) then
87064: LD_VAR 0 4
87068: PUSH
87069: LD_VAR 0 7
87073: ARRAY
87074: PPUSH
87075: LD_VAR 0 22
87079: PPUSH
87080: CALL_OW 308
87084: NOT
87085: IFFALSE 87107
// ComMoveToArea ( group [ i ] , f_repair ) ;
87087: LD_VAR 0 4
87091: PUSH
87092: LD_VAR 0 7
87096: ARRAY
87097: PPUSH
87098: LD_VAR 0 22
87102: PPUSH
87103: CALL_OW 113
// continue ;
87107: GO 86734
// end ; end else
87109: GO 87389
// if group [ i ] in repairs then
87111: LD_VAR 0 4
87115: PUSH
87116: LD_VAR 0 7
87120: ARRAY
87121: PUSH
87122: LD_VAR 0 33
87126: IN
87127: IFFALSE 87389
// begin if IsInUnit ( group [ i ] ) then
87129: LD_VAR 0 4
87133: PUSH
87134: LD_VAR 0 7
87138: ARRAY
87139: PPUSH
87140: CALL_OW 310
87144: IFFALSE 87212
// begin z := IsInUnit ( group [ i ] ) ;
87146: LD_ADDR_VAR 0 13
87150: PUSH
87151: LD_VAR 0 4
87155: PUSH
87156: LD_VAR 0 7
87160: ARRAY
87161: PPUSH
87162: CALL_OW 310
87166: ST_TO_ADDR
// if z in to_repair and IsInArea ( z , f_repair ) then
87167: LD_VAR 0 13
87171: PUSH
87172: LD_VAR 0 32
87176: IN
87177: PUSH
87178: LD_VAR 0 13
87182: PPUSH
87183: LD_VAR 0 22
87187: PPUSH
87188: CALL_OW 308
87192: AND
87193: IFFALSE 87210
// ComExitVehicle ( group [ i ] ) ;
87195: LD_VAR 0 4
87199: PUSH
87200: LD_VAR 0 7
87204: ARRAY
87205: PPUSH
87206: CALL_OW 121
// end else
87210: GO 87389
// begin z := UnitFilter ( group , [ [ f_inarea , f_repair ] , [ f_empty ] ] ) ;
87212: LD_ADDR_VAR 0 13
87216: PUSH
87217: LD_VAR 0 4
87221: PPUSH
87222: LD_INT 95
87224: PUSH
87225: LD_VAR 0 22
87229: PUSH
87230: EMPTY
87231: LIST
87232: LIST
87233: PUSH
87234: LD_INT 58
87236: PUSH
87237: EMPTY
87238: LIST
87239: PUSH
87240: EMPTY
87241: LIST
87242: LIST
87243: PPUSH
87244: CALL_OW 72
87248: ST_TO_ADDR
// if not HasTask ( group [ i ] ) then
87249: LD_VAR 0 4
87253: PUSH
87254: LD_VAR 0 7
87258: ARRAY
87259: PPUSH
87260: CALL_OW 314
87264: NOT
87265: IFFALSE 87387
// begin x := NearestUnitToUnit ( z , group [ i ] ) ;
87267: LD_ADDR_VAR 0 10
87271: PUSH
87272: LD_VAR 0 13
87276: PPUSH
87277: LD_VAR 0 4
87281: PUSH
87282: LD_VAR 0 7
87286: ARRAY
87287: PPUSH
87288: CALL_OW 74
87292: ST_TO_ADDR
// if not x then
87293: LD_VAR 0 10
87297: NOT
87298: IFFALSE 87302
// continue ;
87300: GO 86734
// if GetLives ( x ) < 1000 then
87302: LD_VAR 0 10
87306: PPUSH
87307: CALL_OW 256
87311: PUSH
87312: LD_INT 1000
87314: LESS
87315: IFFALSE 87339
// ComRepairVehicle ( group [ i ] , x ) else
87317: LD_VAR 0 4
87321: PUSH
87322: LD_VAR 0 7
87326: ARRAY
87327: PPUSH
87328: LD_VAR 0 10
87332: PPUSH
87333: CALL_OW 129
87337: GO 87387
// if not ( f_heal and GetLives ( group [ i ] ) < 1000 ) then
87339: LD_VAR 0 23
87343: PUSH
87344: LD_VAR 0 4
87348: PUSH
87349: LD_VAR 0 7
87353: ARRAY
87354: PPUSH
87355: CALL_OW 256
87359: PUSH
87360: LD_INT 1000
87362: LESS
87363: AND
87364: NOT
87365: IFFALSE 87387
// ComEnterUnit ( group [ i ] , x ) ;
87367: LD_VAR 0 4
87371: PUSH
87372: LD_VAR 0 7
87376: ARRAY
87377: PPUSH
87378: LD_VAR 0 10
87382: PPUSH
87383: CALL_OW 120
// end ; continue ;
87387: GO 86734
// end ; end ; end ; if f_heal and GetType ( group [ i ] ) = unit_human then
87389: LD_VAR 0 23
87393: PUSH
87394: LD_VAR 0 4
87398: PUSH
87399: LD_VAR 0 7
87403: ARRAY
87404: PPUSH
87405: CALL_OW 247
87409: PUSH
87410: LD_INT 1
87412: EQUAL
87413: AND
87414: IFFALSE 87892
// begin if group [ i ] in healers then
87416: LD_VAR 0 4
87420: PUSH
87421: LD_VAR 0 7
87425: ARRAY
87426: PUSH
87427: LD_VAR 0 31
87431: IN
87432: IFFALSE 87705
// begin if not IsInArea ( group [ i ] , f_heal ) and not HasTask ( group [ i ] ) then
87434: LD_VAR 0 4
87438: PUSH
87439: LD_VAR 0 7
87443: ARRAY
87444: PPUSH
87445: LD_VAR 0 23
87449: PPUSH
87450: CALL_OW 308
87454: NOT
87455: PUSH
87456: LD_VAR 0 4
87460: PUSH
87461: LD_VAR 0 7
87465: ARRAY
87466: PPUSH
87467: CALL_OW 314
87471: NOT
87472: AND
87473: IFFALSE 87497
// ComMoveToArea ( group [ i ] , f_heal ) else
87475: LD_VAR 0 4
87479: PUSH
87480: LD_VAR 0 7
87484: ARRAY
87485: PPUSH
87486: LD_VAR 0 23
87490: PPUSH
87491: CALL_OW 113
87495: GO 87703
// if GetLives ( HealTarget ( group [ i ] ) ) = 1000 then
87497: LD_VAR 0 4
87501: PUSH
87502: LD_VAR 0 7
87506: ARRAY
87507: PPUSH
87508: CALL 86115 0 1
87512: PPUSH
87513: CALL_OW 256
87517: PUSH
87518: LD_INT 1000
87520: EQUAL
87521: IFFALSE 87540
// ComStop ( group [ i ] ) else
87523: LD_VAR 0 4
87527: PUSH
87528: LD_VAR 0 7
87532: ARRAY
87533: PPUSH
87534: CALL_OW 141
87538: GO 87703
// if not HasTask ( group [ i ] ) and to_heal then
87540: LD_VAR 0 4
87544: PUSH
87545: LD_VAR 0 7
87549: ARRAY
87550: PPUSH
87551: CALL_OW 314
87555: NOT
87556: PUSH
87557: LD_VAR 0 30
87561: AND
87562: IFFALSE 87703
// begin z := NearestUnitToUnit ( UnitFilter ( to_heal , [ f_not , [ f_inside ] ] ) , group [ i ] ) ;
87564: LD_ADDR_VAR 0 13
87568: PUSH
87569: LD_VAR 0 30
87573: PPUSH
87574: LD_INT 3
87576: PUSH
87577: LD_INT 54
87579: PUSH
87580: EMPTY
87581: LIST
87582: PUSH
87583: EMPTY
87584: LIST
87585: LIST
87586: PPUSH
87587: CALL_OW 72
87591: PPUSH
87592: LD_VAR 0 4
87596: PUSH
87597: LD_VAR 0 7
87601: ARRAY
87602: PPUSH
87603: CALL_OW 74
87607: ST_TO_ADDR
// if z then
87608: LD_VAR 0 13
87612: IFFALSE 87703
// if FilterAllUnits ( [ [ f_dist , z , 10 ] , [ f_enemy , GetSide ( z ) ] ] ) = 0 then
87614: LD_INT 91
87616: PUSH
87617: LD_VAR 0 13
87621: PUSH
87622: LD_INT 10
87624: PUSH
87625: EMPTY
87626: LIST
87627: LIST
87628: LIST
87629: PUSH
87630: LD_INT 81
87632: PUSH
87633: LD_VAR 0 13
87637: PPUSH
87638: CALL_OW 255
87642: PUSH
87643: EMPTY
87644: LIST
87645: LIST
87646: PUSH
87647: EMPTY
87648: LIST
87649: LIST
87650: PPUSH
87651: CALL_OW 69
87655: PUSH
87656: LD_INT 0
87658: EQUAL
87659: IFFALSE 87683
// ComHeal ( group [ i ] , z ) else
87661: LD_VAR 0 4
87665: PUSH
87666: LD_VAR 0 7
87670: ARRAY
87671: PPUSH
87672: LD_VAR 0 13
87676: PPUSH
87677: CALL_OW 128
87681: GO 87703
// ComMoveToArea ( group [ i ] , f_heal ) ;
87683: LD_VAR 0 4
87687: PUSH
87688: LD_VAR 0 7
87692: ARRAY
87693: PPUSH
87694: LD_VAR 0 23
87698: PPUSH
87699: CALL_OW 113
// end ; continue ;
87703: GO 86734
// end ; if GetLives ( group [ i ] ) < 700 and not group [ i ] in to_heal then
87705: LD_VAR 0 4
87709: PUSH
87710: LD_VAR 0 7
87714: ARRAY
87715: PPUSH
87716: CALL_OW 256
87720: PUSH
87721: LD_INT 700
87723: LESS
87724: PUSH
87725: LD_VAR 0 4
87729: PUSH
87730: LD_VAR 0 7
87734: ARRAY
87735: PUSH
87736: LD_VAR 0 30
87740: IN
87741: NOT
87742: AND
87743: IFFALSE 87767
// to_heal := to_heal union group [ i ] ;
87745: LD_ADDR_VAR 0 30
87749: PUSH
87750: LD_VAR 0 30
87754: PUSH
87755: LD_VAR 0 4
87759: PUSH
87760: LD_VAR 0 7
87764: ARRAY
87765: UNION
87766: ST_TO_ADDR
// if group [ i ] in to_heal then
87767: LD_VAR 0 4
87771: PUSH
87772: LD_VAR 0 7
87776: ARRAY
87777: PUSH
87778: LD_VAR 0 30
87782: IN
87783: IFFALSE 87892
// begin if GetLives ( group [ i ] ) = 1000 then
87785: LD_VAR 0 4
87789: PUSH
87790: LD_VAR 0 7
87794: ARRAY
87795: PPUSH
87796: CALL_OW 256
87800: PUSH
87801: LD_INT 1000
87803: EQUAL
87804: IFFALSE 87830
// to_heal := to_heal diff group [ i ] else
87806: LD_ADDR_VAR 0 30
87810: PUSH
87811: LD_VAR 0 30
87815: PUSH
87816: LD_VAR 0 4
87820: PUSH
87821: LD_VAR 0 7
87825: ARRAY
87826: DIFF
87827: ST_TO_ADDR
87828: GO 87892
// begin if not IsInArea ( group [ i ] , to_heal ) then
87830: LD_VAR 0 4
87834: PUSH
87835: LD_VAR 0 7
87839: ARRAY
87840: PPUSH
87841: LD_VAR 0 30
87845: PPUSH
87846: CALL_OW 308
87850: NOT
87851: IFFALSE 87875
// ComMoveToArea ( group [ i ] , f_heal ) else
87853: LD_VAR 0 4
87857: PUSH
87858: LD_VAR 0 7
87862: ARRAY
87863: PPUSH
87864: LD_VAR 0 23
87868: PPUSH
87869: CALL_OW 113
87873: GO 87890
// ComHold ( group [ i ] ) ;
87875: LD_VAR 0 4
87879: PUSH
87880: LD_VAR 0 7
87884: ARRAY
87885: PPUSH
87886: CALL_OW 140
// continue ;
87890: GO 86734
// end ; end ; end ; if not EnemyInRange ( group [ i ] , 10 ) and not units_path [ i ] = [ ] then
87892: LD_VAR 0 4
87896: PUSH
87897: LD_VAR 0 7
87901: ARRAY
87902: PPUSH
87903: LD_INT 10
87905: PPUSH
87906: CALL 84535 0 2
87910: NOT
87911: PUSH
87912: LD_VAR 0 16
87916: PUSH
87917: LD_VAR 0 7
87921: ARRAY
87922: PUSH
87923: EMPTY
87924: EQUAL
87925: NOT
87926: AND
87927: IFFALSE 88193
// begin if GetEngine ( group [ i ] ) in [ engine_combustion , engine_solar ] then
87929: LD_VAR 0 4
87933: PUSH
87934: LD_VAR 0 7
87938: ARRAY
87939: PPUSH
87940: CALL_OW 262
87944: PUSH
87945: LD_INT 1
87947: PUSH
87948: LD_INT 2
87950: PUSH
87951: EMPTY
87952: LIST
87953: LIST
87954: IN
87955: IFFALSE 87996
// if GetFuel ( group [ i ] ) < 10 then
87957: LD_VAR 0 4
87961: PUSH
87962: LD_VAR 0 7
87966: ARRAY
87967: PPUSH
87968: CALL_OW 261
87972: PUSH
87973: LD_INT 10
87975: LESS
87976: IFFALSE 87996
// SetFuel ( group [ i ] , 12 ) ;
87978: LD_VAR 0 4
87982: PUSH
87983: LD_VAR 0 7
87987: ARRAY
87988: PPUSH
87989: LD_INT 12
87991: PPUSH
87992: CALL_OW 240
// if units_path [ i ] then
87996: LD_VAR 0 16
88000: PUSH
88001: LD_VAR 0 7
88005: ARRAY
88006: IFFALSE 88191
// begin if GetDistUnitXY ( group [ i ] , units_path [ i ] [ 1 ] [ 1 ] , units_path [ i ] [ 1 ] [ 2 ] ) > 6 then
88008: LD_VAR 0 4
88012: PUSH
88013: LD_VAR 0 7
88017: ARRAY
88018: PPUSH
88019: LD_VAR 0 16
88023: PUSH
88024: LD_VAR 0 7
88028: ARRAY
88029: PUSH
88030: LD_INT 1
88032: ARRAY
88033: PUSH
88034: LD_INT 1
88036: ARRAY
88037: PPUSH
88038: LD_VAR 0 16
88042: PUSH
88043: LD_VAR 0 7
88047: ARRAY
88048: PUSH
88049: LD_INT 1
88051: ARRAY
88052: PUSH
88053: LD_INT 2
88055: ARRAY
88056: PPUSH
88057: CALL_OW 297
88061: PUSH
88062: LD_INT 6
88064: GREATER
88065: IFFALSE 88140
// begin if not HasTask ( group [ i ] ) then
88067: LD_VAR 0 4
88071: PUSH
88072: LD_VAR 0 7
88076: ARRAY
88077: PPUSH
88078: CALL_OW 314
88082: NOT
88083: IFFALSE 88138
// ComAgressiveMove ( group [ i ] , units_path [ i ] [ 1 ] [ 1 ] , units_path [ i ] [ 1 ] [ 2 ] ) ;
88085: LD_VAR 0 4
88089: PUSH
88090: LD_VAR 0 7
88094: ARRAY
88095: PPUSH
88096: LD_VAR 0 16
88100: PUSH
88101: LD_VAR 0 7
88105: ARRAY
88106: PUSH
88107: LD_INT 1
88109: ARRAY
88110: PUSH
88111: LD_INT 1
88113: ARRAY
88114: PPUSH
88115: LD_VAR 0 16
88119: PUSH
88120: LD_VAR 0 7
88124: ARRAY
88125: PUSH
88126: LD_INT 1
88128: ARRAY
88129: PUSH
88130: LD_INT 2
88132: ARRAY
88133: PPUSH
88134: CALL_OW 114
// end else
88138: GO 88191
// begin tmp2 := Delete ( units_path [ i ] , 1 ) ;
88140: LD_ADDR_VAR 0 15
88144: PUSH
88145: LD_VAR 0 16
88149: PUSH
88150: LD_VAR 0 7
88154: ARRAY
88155: PPUSH
88156: LD_INT 1
88158: PPUSH
88159: CALL_OW 3
88163: ST_TO_ADDR
// units_path := Replace ( units_path , i , tmp2 ) ;
88164: LD_ADDR_VAR 0 16
88168: PUSH
88169: LD_VAR 0 16
88173: PPUSH
88174: LD_VAR 0 7
88178: PPUSH
88179: LD_VAR 0 15
88183: PPUSH
88184: CALL_OW 1
88188: ST_TO_ADDR
// continue ;
88189: GO 86734
// end ; end ; end else
88191: GO 90855
// begin tmp := FilterAllUnits ( [ f_enemy , GetSide ( group [ i ] ) ] ) ;
88193: LD_ADDR_VAR 0 14
88197: PUSH
88198: LD_INT 81
88200: PUSH
88201: LD_VAR 0 4
88205: PUSH
88206: LD_VAR 0 7
88210: ARRAY
88211: PPUSH
88212: CALL_OW 255
88216: PUSH
88217: EMPTY
88218: LIST
88219: LIST
88220: PPUSH
88221: CALL_OW 69
88225: ST_TO_ADDR
// if not tmp then
88226: LD_VAR 0 14
88230: NOT
88231: IFFALSE 88235
// continue ;
88233: GO 86734
// if f_ignore_area then
88235: LD_VAR 0 17
88239: IFFALSE 88327
// begin tmp2 := UnitFilter ( tmp , [ f_not , [ f_distxy , f_ignore_area [ 1 ] , f_ignore_area [ 2 ] , f_ignore_area [ 3 ] ] ] ) ;
88241: LD_ADDR_VAR 0 15
88245: PUSH
88246: LD_VAR 0 14
88250: PPUSH
88251: LD_INT 3
88253: PUSH
88254: LD_INT 92
88256: PUSH
88257: LD_VAR 0 17
88261: PUSH
88262: LD_INT 1
88264: ARRAY
88265: PUSH
88266: LD_VAR 0 17
88270: PUSH
88271: LD_INT 2
88273: ARRAY
88274: PUSH
88275: LD_VAR 0 17
88279: PUSH
88280: LD_INT 3
88282: ARRAY
88283: PUSH
88284: EMPTY
88285: LIST
88286: LIST
88287: LIST
88288: LIST
88289: PUSH
88290: EMPTY
88291: LIST
88292: LIST
88293: PPUSH
88294: CALL_OW 72
88298: ST_TO_ADDR
// if ( tmp diff tmp2 ) then
88299: LD_VAR 0 14
88303: PUSH
88304: LD_VAR 0 15
88308: DIFF
88309: IFFALSE 88327
// tmp := tmp diff tmp2 ;
88311: LD_ADDR_VAR 0 14
88315: PUSH
88316: LD_VAR 0 14
88320: PUSH
88321: LD_VAR 0 15
88325: DIFF
88326: ST_TO_ADDR
// end ; if not f_murder then
88327: LD_VAR 0 20
88331: NOT
88332: IFFALSE 88390
// begin tmp2 := UnitFilter ( tmp , [ f_not , [ f_ok ] ] ) ;
88334: LD_ADDR_VAR 0 15
88338: PUSH
88339: LD_VAR 0 14
88343: PPUSH
88344: LD_INT 3
88346: PUSH
88347: LD_INT 50
88349: PUSH
88350: EMPTY
88351: LIST
88352: PUSH
88353: EMPTY
88354: LIST
88355: LIST
88356: PPUSH
88357: CALL_OW 72
88361: ST_TO_ADDR
// if ( tmp diff tmp2 ) then
88362: LD_VAR 0 14
88366: PUSH
88367: LD_VAR 0 15
88371: DIFF
88372: IFFALSE 88390
// tmp := tmp diff tmp2 ;
88374: LD_ADDR_VAR 0 14
88378: PUSH
88379: LD_VAR 0 14
88383: PUSH
88384: LD_VAR 0 15
88388: DIFF
88389: ST_TO_ADDR
// end ; tmp := SortByDistanceUnit ( group [ i ] , tmp , true , true ) ;
88390: LD_ADDR_VAR 0 14
88394: PUSH
88395: LD_VAR 0 4
88399: PUSH
88400: LD_VAR 0 7
88404: ARRAY
88405: PPUSH
88406: LD_VAR 0 14
88410: PPUSH
88411: LD_INT 1
88413: PPUSH
88414: LD_INT 1
88416: PPUSH
88417: CALL 58178 0 4
88421: ST_TO_ADDR
// if GetClass ( group [ i ] ) = 1 then
88422: LD_VAR 0 4
88426: PUSH
88427: LD_VAR 0 7
88431: ARRAY
88432: PPUSH
88433: CALL_OW 257
88437: PUSH
88438: LD_INT 1
88440: EQUAL
88441: IFFALSE 88889
// begin if WantPlant ( group [ i ] ) then
88443: LD_VAR 0 4
88447: PUSH
88448: LD_VAR 0 7
88452: ARRAY
88453: PPUSH
88454: CALL 57679 0 1
88458: IFFALSE 88462
// continue ;
88460: GO 86734
// if f_capture and not IsInUnit ( group [ i ] ) and tmp [ 1 ] in UnitFilter ( tmp , [ [ f_type , unit_vehicle ] , [ f_empty ] ] ) then
88462: LD_VAR 0 18
88466: PUSH
88467: LD_VAR 0 4
88471: PUSH
88472: LD_VAR 0 7
88476: ARRAY
88477: PPUSH
88478: CALL_OW 310
88482: NOT
88483: AND
88484: PUSH
88485: LD_VAR 0 14
88489: PUSH
88490: LD_INT 1
88492: ARRAY
88493: PUSH
88494: LD_VAR 0 14
88498: PPUSH
88499: LD_INT 21
88501: PUSH
88502: LD_INT 2
88504: PUSH
88505: EMPTY
88506: LIST
88507: LIST
88508: PUSH
88509: LD_INT 58
88511: PUSH
88512: EMPTY
88513: LIST
88514: PUSH
88515: EMPTY
88516: LIST
88517: LIST
88518: PPUSH
88519: CALL_OW 72
88523: IN
88524: AND
88525: IFFALSE 88561
// begin ComEnterUnit ( group [ i ] , tmp [ 1 ] ) ;
88527: LD_VAR 0 4
88531: PUSH
88532: LD_VAR 0 7
88536: ARRAY
88537: PPUSH
88538: LD_VAR 0 14
88542: PUSH
88543: LD_INT 1
88545: ARRAY
88546: PPUSH
88547: CALL_OW 120
// attacking := true ;
88551: LD_ADDR_VAR 0 29
88555: PUSH
88556: LD_INT 1
88558: ST_TO_ADDR
// continue ;
88559: GO 86734
// end ; if f_crawl and GetClass ( group [ i ] ) = 1 and GetLives ( group [ i ] ) < 800 and not Crawls ( group [ i ] ) then
88561: LD_VAR 0 26
88565: PUSH
88566: LD_VAR 0 4
88570: PUSH
88571: LD_VAR 0 7
88575: ARRAY
88576: PPUSH
88577: CALL_OW 257
88581: PUSH
88582: LD_INT 1
88584: EQUAL
88585: AND
88586: PUSH
88587: LD_VAR 0 4
88591: PUSH
88592: LD_VAR 0 7
88596: ARRAY
88597: PPUSH
88598: CALL_OW 256
88602: PUSH
88603: LD_INT 800
88605: LESS
88606: AND
88607: PUSH
88608: LD_VAR 0 4
88612: PUSH
88613: LD_VAR 0 7
88617: ARRAY
88618: PPUSH
88619: CALL_OW 318
88623: NOT
88624: AND
88625: IFFALSE 88642
// ComCrawl ( group [ i ] ) ;
88627: LD_VAR 0 4
88631: PUSH
88632: LD_VAR 0 7
88636: ARRAY
88637: PPUSH
88638: CALL_OW 137
// if f_mines then
88642: LD_VAR 0 21
88646: IFFALSE 88889
// begin if GetType ( tmp [ 1 ] ) = unit_building and not tmp [ 1 ] in mined then
88648: LD_VAR 0 14
88652: PUSH
88653: LD_INT 1
88655: ARRAY
88656: PPUSH
88657: CALL_OW 247
88661: PUSH
88662: LD_INT 3
88664: EQUAL
88665: PUSH
88666: LD_VAR 0 14
88670: PUSH
88671: LD_INT 1
88673: ARRAY
88674: PUSH
88675: LD_VAR 0 27
88679: IN
88680: NOT
88681: AND
88682: IFFALSE 88889
// begin x := GetX ( tmp [ 1 ] ) ;
88684: LD_ADDR_VAR 0 10
88688: PUSH
88689: LD_VAR 0 14
88693: PUSH
88694: LD_INT 1
88696: ARRAY
88697: PPUSH
88698: CALL_OW 250
88702: ST_TO_ADDR
// y := GetY ( tmp [ 1 ] ) ;
88703: LD_ADDR_VAR 0 11
88707: PUSH
88708: LD_VAR 0 14
88712: PUSH
88713: LD_INT 1
88715: ARRAY
88716: PPUSH
88717: CALL_OW 251
88721: ST_TO_ADDR
// d := ReverseDir ( group [ i ] ) ;
88722: LD_ADDR_VAR 0 12
88726: PUSH
88727: LD_VAR 0 4
88731: PUSH
88732: LD_VAR 0 7
88736: ARRAY
88737: PPUSH
88738: CALL 84620 0 1
88742: ST_TO_ADDR
// ComPlaceDelayedCharge ( group [ i ] , x , y , tmp [ 1 ] ) ;
88743: LD_VAR 0 4
88747: PUSH
88748: LD_VAR 0 7
88752: ARRAY
88753: PPUSH
88754: LD_VAR 0 10
88758: PPUSH
88759: LD_VAR 0 11
88763: PPUSH
88764: LD_VAR 0 14
88768: PUSH
88769: LD_INT 1
88771: ARRAY
88772: PPUSH
88773: CALL_OW 132
// AddComMoveXY ( group [ i ] , ShiftX ( x , d , 7 ) , ShiftY ( y , d , 7 ) ) ;
88777: LD_VAR 0 4
88781: PUSH
88782: LD_VAR 0 7
88786: ARRAY
88787: PPUSH
88788: LD_VAR 0 10
88792: PPUSH
88793: LD_VAR 0 12
88797: PPUSH
88798: LD_INT 7
88800: PPUSH
88801: CALL_OW 272
88805: PPUSH
88806: LD_VAR 0 11
88810: PPUSH
88811: LD_VAR 0 12
88815: PPUSH
88816: LD_INT 7
88818: PPUSH
88819: CALL_OW 273
88823: PPUSH
88824: CALL_OW 171
// SetTag ( group [ i ] , 71 ) ;
88828: LD_VAR 0 4
88832: PUSH
88833: LD_VAR 0 7
88837: ARRAY
88838: PPUSH
88839: LD_INT 71
88841: PPUSH
88842: CALL_OW 109
// mined := Replace ( mined , mined + 1 , tmp [ 1 ] ) ;
88846: LD_ADDR_VAR 0 27
88850: PUSH
88851: LD_VAR 0 27
88855: PPUSH
88856: LD_VAR 0 27
88860: PUSH
88861: LD_INT 1
88863: PLUS
88864: PPUSH
88865: LD_VAR 0 14
88869: PUSH
88870: LD_INT 1
88872: ARRAY
88873: PPUSH
88874: CALL_OW 1
88878: ST_TO_ADDR
// attacking := true ;
88879: LD_ADDR_VAR 0 29
88883: PUSH
88884: LD_INT 1
88886: ST_TO_ADDR
// continue ;
88887: GO 86734
// end ; end ; end ; if GetClass ( group [ i ] ) = 17 and not GetTag ( group [ i ] ) = 71 then
88889: LD_VAR 0 4
88893: PUSH
88894: LD_VAR 0 7
88898: ARRAY
88899: PPUSH
88900: CALL_OW 257
88904: PUSH
88905: LD_INT 17
88907: EQUAL
88908: PUSH
88909: LD_VAR 0 4
88913: PUSH
88914: LD_VAR 0 7
88918: ARRAY
88919: PPUSH
88920: CALL_OW 110
88924: PUSH
88925: LD_INT 71
88927: EQUAL
88928: NOT
88929: AND
88930: IFFALSE 89076
// begin attacking := false ;
88932: LD_ADDR_VAR 0 29
88936: PUSH
88937: LD_INT 0
88939: ST_TO_ADDR
// k := 5 ;
88940: LD_ADDR_VAR 0 9
88944: PUSH
88945: LD_INT 5
88947: ST_TO_ADDR
// if tmp < k then
88948: LD_VAR 0 14
88952: PUSH
88953: LD_VAR 0 9
88957: LESS
88958: IFFALSE 88970
// k := tmp ;
88960: LD_ADDR_VAR 0 9
88964: PUSH
88965: LD_VAR 0 14
88969: ST_TO_ADDR
// for j = 1 to k do
88970: LD_ADDR_VAR 0 8
88974: PUSH
88975: DOUBLE
88976: LD_INT 1
88978: DEC
88979: ST_TO_ADDR
88980: LD_VAR 0 9
88984: PUSH
88985: FOR_TO
88986: IFFALSE 89074
// begin if not tmp [ j ] in UnitFilter ( tmp , [ f_empty ] ) then
88988: LD_VAR 0 14
88992: PUSH
88993: LD_VAR 0 8
88997: ARRAY
88998: PUSH
88999: LD_VAR 0 14
89003: PPUSH
89004: LD_INT 58
89006: PUSH
89007: EMPTY
89008: LIST
89009: PPUSH
89010: CALL_OW 72
89014: IN
89015: NOT
89016: IFFALSE 89072
// begin ComAttackUnit ( group [ i ] , tmp [ j ] ) ;
89018: LD_VAR 0 4
89022: PUSH
89023: LD_VAR 0 7
89027: ARRAY
89028: PPUSH
89029: LD_VAR 0 14
89033: PUSH
89034: LD_VAR 0 8
89038: ARRAY
89039: PPUSH
89040: CALL_OW 115
// attacking := true ;
89044: LD_ADDR_VAR 0 29
89048: PUSH
89049: LD_INT 1
89051: ST_TO_ADDR
// SetTag ( group [ i ] , 71 ) ;
89052: LD_VAR 0 4
89056: PUSH
89057: LD_VAR 0 7
89061: ARRAY
89062: PPUSH
89063: LD_INT 71
89065: PPUSH
89066: CALL_OW 109
// continue ;
89070: GO 88985
// end ; end ;
89072: GO 88985
89074: POP
89075: POP
// end ; if GetClass ( group [ i ] ) = 8 or GetWeapon ( group [ i ] ) in [ ar_rocket_launcher , ru_rocket_launcher , us_rocket_launcher , ru_rocket ] then
89076: LD_VAR 0 4
89080: PUSH
89081: LD_VAR 0 7
89085: ARRAY
89086: PPUSH
89087: CALL_OW 257
89091: PUSH
89092: LD_INT 8
89094: EQUAL
89095: PUSH
89096: LD_VAR 0 4
89100: PUSH
89101: LD_VAR 0 7
89105: ARRAY
89106: PPUSH
89107: CALL_OW 264
89111: PUSH
89112: LD_INT 28
89114: PUSH
89115: LD_INT 45
89117: PUSH
89118: LD_INT 7
89120: PUSH
89121: LD_INT 47
89123: PUSH
89124: EMPTY
89125: LIST
89126: LIST
89127: LIST
89128: LIST
89129: IN
89130: OR
89131: IFFALSE 89387
// begin attacking := false ;
89133: LD_ADDR_VAR 0 29
89137: PUSH
89138: LD_INT 0
89140: ST_TO_ADDR
// if GetBType ( tmp [ 1 ] ) in [ b_bunker , b_breastwork , b_turret , b_armoury , b_barracks ] then
89141: LD_VAR 0 14
89145: PUSH
89146: LD_INT 1
89148: ARRAY
89149: PPUSH
89150: CALL_OW 266
89154: PUSH
89155: LD_INT 32
89157: PUSH
89158: LD_INT 31
89160: PUSH
89161: LD_INT 33
89163: PUSH
89164: LD_INT 4
89166: PUSH
89167: LD_INT 5
89169: PUSH
89170: EMPTY
89171: LIST
89172: LIST
89173: LIST
89174: LIST
89175: LIST
89176: IN
89177: IFFALSE 89363
// begin k := GetBuildingHexes ( GetBType ( tmp [ 1 ] ) , GetX ( tmp [ 1 ] ) , GetY ( tmp [ 1 ] ) , GetDir ( tmp [ 1 ] ) , GetNation ( tmp [ 1 ] ) , 0 ) ;
89179: LD_ADDR_VAR 0 9
89183: PUSH
89184: LD_VAR 0 14
89188: PUSH
89189: LD_INT 1
89191: ARRAY
89192: PPUSH
89193: CALL_OW 266
89197: PPUSH
89198: LD_VAR 0 14
89202: PUSH
89203: LD_INT 1
89205: ARRAY
89206: PPUSH
89207: CALL_OW 250
89211: PPUSH
89212: LD_VAR 0 14
89216: PUSH
89217: LD_INT 1
89219: ARRAY
89220: PPUSH
89221: CALL_OW 251
89225: PPUSH
89226: LD_VAR 0 14
89230: PUSH
89231: LD_INT 1
89233: ARRAY
89234: PPUSH
89235: CALL_OW 254
89239: PPUSH
89240: LD_VAR 0 14
89244: PUSH
89245: LD_INT 1
89247: ARRAY
89248: PPUSH
89249: CALL_OW 248
89253: PPUSH
89254: LD_INT 0
89256: PPUSH
89257: CALL 65990 0 6
89261: ST_TO_ADDR
// j := GetClosestHex ( group [ i ] , k ) ;
89262: LD_ADDR_VAR 0 8
89266: PUSH
89267: LD_VAR 0 4
89271: PUSH
89272: LD_VAR 0 7
89276: ARRAY
89277: PPUSH
89278: LD_VAR 0 9
89282: PPUSH
89283: CALL 84660 0 2
89287: ST_TO_ADDR
// if j then
89288: LD_VAR 0 8
89292: IFFALSE 89361
// if ValidHex ( j [ 1 ] , j [ 2 ] ) then
89294: LD_VAR 0 8
89298: PUSH
89299: LD_INT 1
89301: ARRAY
89302: PPUSH
89303: LD_VAR 0 8
89307: PUSH
89308: LD_INT 2
89310: ARRAY
89311: PPUSH
89312: CALL_OW 488
89316: IFFALSE 89361
// begin ComAttackPlace ( group [ i ] , j [ 1 ] , j [ 2 ] ) ;
89318: LD_VAR 0 4
89322: PUSH
89323: LD_VAR 0 7
89327: ARRAY
89328: PPUSH
89329: LD_VAR 0 8
89333: PUSH
89334: LD_INT 1
89336: ARRAY
89337: PPUSH
89338: LD_VAR 0 8
89342: PUSH
89343: LD_INT 2
89345: ARRAY
89346: PPUSH
89347: CALL_OW 116
// attacking := true ;
89351: LD_ADDR_VAR 0 29
89355: PUSH
89356: LD_INT 1
89358: ST_TO_ADDR
// continue ;
89359: GO 86734
// end ; end else
89361: GO 89387
// ComAttackUnit ( group [ i ] , tmp [ 1 ] ) ;
89363: LD_VAR 0 4
89367: PUSH
89368: LD_VAR 0 7
89372: ARRAY
89373: PPUSH
89374: LD_VAR 0 14
89378: PUSH
89379: LD_INT 1
89381: ARRAY
89382: PPUSH
89383: CALL_OW 115
// end ; if GetChassis ( group [ i ] ) = ar_hovercraft then
89387: LD_VAR 0 4
89391: PUSH
89392: LD_VAR 0 7
89396: ARRAY
89397: PPUSH
89398: CALL_OW 265
89402: PUSH
89403: LD_INT 11
89405: EQUAL
89406: IFFALSE 89684
// begin k := 10 ;
89408: LD_ADDR_VAR 0 9
89412: PUSH
89413: LD_INT 10
89415: ST_TO_ADDR
// x := 0 ;
89416: LD_ADDR_VAR 0 10
89420: PUSH
89421: LD_INT 0
89423: ST_TO_ADDR
// if tmp < k then
89424: LD_VAR 0 14
89428: PUSH
89429: LD_VAR 0 9
89433: LESS
89434: IFFALSE 89446
// k := tmp ;
89436: LD_ADDR_VAR 0 9
89440: PUSH
89441: LD_VAR 0 14
89445: ST_TO_ADDR
// for j = k downto 1 do
89446: LD_ADDR_VAR 0 8
89450: PUSH
89451: DOUBLE
89452: LD_VAR 0 9
89456: INC
89457: ST_TO_ADDR
89458: LD_INT 1
89460: PUSH
89461: FOR_DOWNTO
89462: IFFALSE 89537
// begin if GetType ( tmp [ j ] ) = unit_human then
89464: LD_VAR 0 14
89468: PUSH
89469: LD_VAR 0 8
89473: ARRAY
89474: PPUSH
89475: CALL_OW 247
89479: PUSH
89480: LD_INT 1
89482: EQUAL
89483: IFFALSE 89535
// begin AttackHovercraft ( group [ i ] , tmp [ j ] ) ;
89485: LD_VAR 0 4
89489: PUSH
89490: LD_VAR 0 7
89494: ARRAY
89495: PPUSH
89496: LD_VAR 0 14
89500: PUSH
89501: LD_VAR 0 8
89505: ARRAY
89506: PPUSH
89507: CALL 84931 0 2
// x := tmp [ j ] ;
89511: LD_ADDR_VAR 0 10
89515: PUSH
89516: LD_VAR 0 14
89520: PUSH
89521: LD_VAR 0 8
89525: ARRAY
89526: ST_TO_ADDR
// attacking := true ;
89527: LD_ADDR_VAR 0 29
89531: PUSH
89532: LD_INT 1
89534: ST_TO_ADDR
// end ; end ;
89535: GO 89461
89537: POP
89538: POP
// if not x then
89539: LD_VAR 0 10
89543: NOT
89544: IFFALSE 89684
// begin attacking := true ;
89546: LD_ADDR_VAR 0 29
89550: PUSH
89551: LD_INT 1
89553: ST_TO_ADDR
// if GetHexInfo ( GetX ( group [ i ] ) , GetY ( group [ i ] ) ) [ 2 ] = GetHexInfo ( GetX ( tmp [ 1 ] ) , GetY ( tmp [ 1 ] ) ) [ 2 ] then
89554: LD_VAR 0 4
89558: PUSH
89559: LD_VAR 0 7
89563: ARRAY
89564: PPUSH
89565: CALL_OW 250
89569: PPUSH
89570: LD_VAR 0 4
89574: PUSH
89575: LD_VAR 0 7
89579: ARRAY
89580: PPUSH
89581: CALL_OW 251
89585: PPUSH
89586: CALL_OW 546
89590: PUSH
89591: LD_INT 2
89593: ARRAY
89594: PUSH
89595: LD_VAR 0 14
89599: PUSH
89600: LD_INT 1
89602: ARRAY
89603: PPUSH
89604: CALL_OW 250
89608: PPUSH
89609: LD_VAR 0 14
89613: PUSH
89614: LD_INT 1
89616: ARRAY
89617: PPUSH
89618: CALL_OW 251
89622: PPUSH
89623: CALL_OW 546
89627: PUSH
89628: LD_INT 2
89630: ARRAY
89631: EQUAL
89632: IFFALSE 89660
// AttackHovercraft ( group [ i ] , tmp [ 1 ] ) else
89634: LD_VAR 0 4
89638: PUSH
89639: LD_VAR 0 7
89643: ARRAY
89644: PPUSH
89645: LD_VAR 0 14
89649: PUSH
89650: LD_INT 1
89652: ARRAY
89653: PPUSH
89654: CALL 84931 0 2
89658: GO 89684
// ComAttackUnit ( group [ i ] , tmp [ 1 ] ) ;
89660: LD_VAR 0 4
89664: PUSH
89665: LD_VAR 0 7
89669: ARRAY
89670: PPUSH
89671: LD_VAR 0 14
89675: PUSH
89676: LD_INT 1
89678: ARRAY
89679: PPUSH
89680: CALL_OW 115
// end ; end ; if GetWeapon ( group [ i ] ) = ar_selfpropelled_bomb then
89684: LD_VAR 0 4
89688: PUSH
89689: LD_VAR 0 7
89693: ARRAY
89694: PPUSH
89695: CALL_OW 264
89699: PUSH
89700: LD_INT 29
89702: EQUAL
89703: IFFALSE 90069
// begin if WantsToAttack ( group [ i ] ) in bombed then
89705: LD_VAR 0 4
89709: PUSH
89710: LD_VAR 0 7
89714: ARRAY
89715: PPUSH
89716: CALL_OW 319
89720: PUSH
89721: LD_VAR 0 28
89725: IN
89726: IFFALSE 89730
// continue ;
89728: GO 86734
// k := 8 ;
89730: LD_ADDR_VAR 0 9
89734: PUSH
89735: LD_INT 8
89737: ST_TO_ADDR
// x := 0 ;
89738: LD_ADDR_VAR 0 10
89742: PUSH
89743: LD_INT 0
89745: ST_TO_ADDR
// if tmp < k then
89746: LD_VAR 0 14
89750: PUSH
89751: LD_VAR 0 9
89755: LESS
89756: IFFALSE 89768
// k := tmp ;
89758: LD_ADDR_VAR 0 9
89762: PUSH
89763: LD_VAR 0 14
89767: ST_TO_ADDR
// for j = 1 to k do
89768: LD_ADDR_VAR 0 8
89772: PUSH
89773: DOUBLE
89774: LD_INT 1
89776: DEC
89777: ST_TO_ADDR
89778: LD_VAR 0 9
89782: PUSH
89783: FOR_TO
89784: IFFALSE 89916
// begin if GetType ( tmp [ j ] ) = unit_building then
89786: LD_VAR 0 14
89790: PUSH
89791: LD_VAR 0 8
89795: ARRAY
89796: PPUSH
89797: CALL_OW 247
89801: PUSH
89802: LD_INT 3
89804: EQUAL
89805: IFFALSE 89914
// if not tmp [ j ] in bombed and UnitsInside ( tmp [ j ] ) then
89807: LD_VAR 0 14
89811: PUSH
89812: LD_VAR 0 8
89816: ARRAY
89817: PUSH
89818: LD_VAR 0 28
89822: IN
89823: NOT
89824: PUSH
89825: LD_VAR 0 14
89829: PUSH
89830: LD_VAR 0 8
89834: ARRAY
89835: PPUSH
89836: CALL_OW 313
89840: AND
89841: IFFALSE 89914
// begin ComAttackUnit ( group [ i ] , tmp [ j ] ) ;
89843: LD_VAR 0 4
89847: PUSH
89848: LD_VAR 0 7
89852: ARRAY
89853: PPUSH
89854: LD_VAR 0 14
89858: PUSH
89859: LD_VAR 0 8
89863: ARRAY
89864: PPUSH
89865: CALL_OW 115
// bombed := Replace ( bombed , bombed + 1 , tmp [ j ] ) ;
89869: LD_ADDR_VAR 0 28
89873: PUSH
89874: LD_VAR 0 28
89878: PPUSH
89879: LD_VAR 0 28
89883: PUSH
89884: LD_INT 1
89886: PLUS
89887: PPUSH
89888: LD_VAR 0 14
89892: PUSH
89893: LD_VAR 0 8
89897: ARRAY
89898: PPUSH
89899: CALL_OW 1
89903: ST_TO_ADDR
// attacking := true ;
89904: LD_ADDR_VAR 0 29
89908: PUSH
89909: LD_INT 1
89911: ST_TO_ADDR
// break ;
89912: GO 89916
// end ; end ;
89914: GO 89783
89916: POP
89917: POP
// if not attacking and f_attack_depot then
89918: LD_VAR 0 29
89922: NOT
89923: PUSH
89924: LD_VAR 0 25
89928: AND
89929: IFFALSE 90024
// begin z := UnitFilter ( tmp , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) ;
89931: LD_ADDR_VAR 0 13
89935: PUSH
89936: LD_VAR 0 14
89940: PPUSH
89941: LD_INT 2
89943: PUSH
89944: LD_INT 30
89946: PUSH
89947: LD_INT 0
89949: PUSH
89950: EMPTY
89951: LIST
89952: LIST
89953: PUSH
89954: LD_INT 30
89956: PUSH
89957: LD_INT 1
89959: PUSH
89960: EMPTY
89961: LIST
89962: LIST
89963: PUSH
89964: EMPTY
89965: LIST
89966: LIST
89967: LIST
89968: PPUSH
89969: CALL_OW 72
89973: ST_TO_ADDR
// if z then
89974: LD_VAR 0 13
89978: IFFALSE 90024
// begin ComAttackUnit ( group [ i ] , NearestUnitToUnit ( z , group [ i ] ) ) ;
89980: LD_VAR 0 4
89984: PUSH
89985: LD_VAR 0 7
89989: ARRAY
89990: PPUSH
89991: LD_VAR 0 13
89995: PPUSH
89996: LD_VAR 0 4
90000: PUSH
90001: LD_VAR 0 7
90005: ARRAY
90006: PPUSH
90007: CALL_OW 74
90011: PPUSH
90012: CALL_OW 115
// attacking := true ;
90016: LD_ADDR_VAR 0 29
90020: PUSH
90021: LD_INT 1
90023: ST_TO_ADDR
// end ; end ; if GetLives ( group [ i ] ) < 500 then
90024: LD_VAR 0 4
90028: PUSH
90029: LD_VAR 0 7
90033: ARRAY
90034: PPUSH
90035: CALL_OW 256
90039: PUSH
90040: LD_INT 500
90042: LESS
90043: IFFALSE 90069
// ComAttackUnit ( group [ i ] , tmp [ 1 ] ) ;
90045: LD_VAR 0 4
90049: PUSH
90050: LD_VAR 0 7
90054: ARRAY
90055: PPUSH
90056: LD_VAR 0 14
90060: PUSH
90061: LD_INT 1
90063: ARRAY
90064: PPUSH
90065: CALL_OW 115
// end ; if GetWeapon ( group [ i ] ) = ru_time_lapser then
90069: LD_VAR 0 4
90073: PUSH
90074: LD_VAR 0 7
90078: ARRAY
90079: PPUSH
90080: CALL_OW 264
90084: PUSH
90085: LD_INT 49
90087: EQUAL
90088: IFFALSE 90209
// begin if not HasTask ( group [ i ] ) then
90090: LD_VAR 0 4
90094: PUSH
90095: LD_VAR 0 7
90099: ARRAY
90100: PPUSH
90101: CALL_OW 314
90105: NOT
90106: IFFALSE 90209
// begin k := NearestUnitToUnit ( FilterAllUnits ( [ f_enemy , GetSide ( group [ i ] ) ] ) , group [ i ] ) ;
90108: LD_ADDR_VAR 0 9
90112: PUSH
90113: LD_INT 81
90115: PUSH
90116: LD_VAR 0 4
90120: PUSH
90121: LD_VAR 0 7
90125: ARRAY
90126: PPUSH
90127: CALL_OW 255
90131: PUSH
90132: EMPTY
90133: LIST
90134: LIST
90135: PPUSH
90136: CALL_OW 69
90140: PPUSH
90141: LD_VAR 0 4
90145: PUSH
90146: LD_VAR 0 7
90150: ARRAY
90151: PPUSH
90152: CALL_OW 74
90156: ST_TO_ADDR
// if k then
90157: LD_VAR 0 9
90161: IFFALSE 90209
// if GetDistUnits ( group [ i ] , k ) > 10 then
90163: LD_VAR 0 4
90167: PUSH
90168: LD_VAR 0 7
90172: ARRAY
90173: PPUSH
90174: LD_VAR 0 9
90178: PPUSH
90179: CALL_OW 296
90183: PUSH
90184: LD_INT 10
90186: GREATER
90187: IFFALSE 90209
// ComMoveUnit ( group [ i ] , k ) ;
90189: LD_VAR 0 4
90193: PUSH
90194: LD_VAR 0 7
90198: ARRAY
90199: PPUSH
90200: LD_VAR 0 9
90204: PPUSH
90205: CALL_OW 112
// end ; end ; if GetLives ( group [ i ] ) < 250 and group [ i ] in FilterAllUnits ( [ [ f_type , unit_vehicle ] , [ f_nation , 2 ] ] ) then
90209: LD_VAR 0 4
90213: PUSH
90214: LD_VAR 0 7
90218: ARRAY
90219: PPUSH
90220: CALL_OW 256
90224: PUSH
90225: LD_INT 250
90227: LESS
90228: PUSH
90229: LD_VAR 0 4
90233: PUSH
90234: LD_VAR 0 7
90238: ARRAY
90239: PUSH
90240: LD_INT 21
90242: PUSH
90243: LD_INT 2
90245: PUSH
90246: EMPTY
90247: LIST
90248: LIST
90249: PUSH
90250: LD_INT 23
90252: PUSH
90253: LD_INT 2
90255: PUSH
90256: EMPTY
90257: LIST
90258: LIST
90259: PUSH
90260: EMPTY
90261: LIST
90262: LIST
90263: PPUSH
90264: CALL_OW 69
90268: IN
90269: AND
90270: IFFALSE 90395
// begin k := NearestUnitToUnit ( all_units diff group [ i ] , group [ i ] ) ;
90272: LD_ADDR_VAR 0 9
90276: PUSH
90277: LD_OWVAR 3
90281: PUSH
90282: LD_VAR 0 4
90286: PUSH
90287: LD_VAR 0 7
90291: ARRAY
90292: DIFF
90293: PPUSH
90294: LD_VAR 0 4
90298: PUSH
90299: LD_VAR 0 7
90303: ARRAY
90304: PPUSH
90305: CALL_OW 74
90309: ST_TO_ADDR
// if not k then
90310: LD_VAR 0 9
90314: NOT
90315: IFFALSE 90319
// continue ;
90317: GO 86734
// if k in FilterAllUnits ( [ f_enemy , GetSide ( group [ i ] ) ] ) and GetDistUnits ( k , group [ i ] ) < 5 then
90319: LD_VAR 0 9
90323: PUSH
90324: LD_INT 81
90326: PUSH
90327: LD_VAR 0 4
90331: PUSH
90332: LD_VAR 0 7
90336: ARRAY
90337: PPUSH
90338: CALL_OW 255
90342: PUSH
90343: EMPTY
90344: LIST
90345: LIST
90346: PPUSH
90347: CALL_OW 69
90351: IN
90352: PUSH
90353: LD_VAR 0 9
90357: PPUSH
90358: LD_VAR 0 4
90362: PUSH
90363: LD_VAR 0 7
90367: ARRAY
90368: PPUSH
90369: CALL_OW 296
90373: PUSH
90374: LD_INT 5
90376: LESS
90377: AND
90378: IFFALSE 90395
// ComAutodestruct ( group [ i ] ) ;
90380: LD_VAR 0 4
90384: PUSH
90385: LD_VAR 0 7
90389: ARRAY
90390: PPUSH
90391: CALL 84829 0 1
// end ; if f_attack_depot then
90395: LD_VAR 0 25
90399: IFFALSE 90511
// begin k := 6 ;
90401: LD_ADDR_VAR 0 9
90405: PUSH
90406: LD_INT 6
90408: ST_TO_ADDR
// if tmp < k then
90409: LD_VAR 0 14
90413: PUSH
90414: LD_VAR 0 9
90418: LESS
90419: IFFALSE 90431
// k := tmp ;
90421: LD_ADDR_VAR 0 9
90425: PUSH
90426: LD_VAR 0 14
90430: ST_TO_ADDR
// for j = 1 to k do
90431: LD_ADDR_VAR 0 8
90435: PUSH
90436: DOUBLE
90437: LD_INT 1
90439: DEC
90440: ST_TO_ADDR
90441: LD_VAR 0 9
90445: PUSH
90446: FOR_TO
90447: IFFALSE 90509
// if GetBType ( j ) in [ b_depot , b_warehouse ] then
90449: LD_VAR 0 8
90453: PPUSH
90454: CALL_OW 266
90458: PUSH
90459: LD_INT 0
90461: PUSH
90462: LD_INT 1
90464: PUSH
90465: EMPTY
90466: LIST
90467: LIST
90468: IN
90469: IFFALSE 90507
// begin ComAttackUnit ( group [ i ] , tmp [ j ] ) ;
90471: LD_VAR 0 4
90475: PUSH
90476: LD_VAR 0 7
90480: ARRAY
90481: PPUSH
90482: LD_VAR 0 14
90486: PUSH
90487: LD_VAR 0 8
90491: ARRAY
90492: PPUSH
90493: CALL_OW 115
// attacking := true ;
90497: LD_ADDR_VAR 0 29
90501: PUSH
90502: LD_INT 1
90504: ST_TO_ADDR
// break ;
90505: GO 90509
// end ;
90507: GO 90446
90509: POP
90510: POP
// end ; if IsOk ( group [ i ] ) and not attacking then
90511: LD_VAR 0 4
90515: PUSH
90516: LD_VAR 0 7
90520: ARRAY
90521: PPUSH
90522: CALL_OW 302
90526: PUSH
90527: LD_VAR 0 29
90531: NOT
90532: AND
90533: IFFALSE 90855
// begin if GetTag ( group [ i ] ) = 71 then
90535: LD_VAR 0 4
90539: PUSH
90540: LD_VAR 0 7
90544: ARRAY
90545: PPUSH
90546: CALL_OW 110
90550: PUSH
90551: LD_INT 71
90553: EQUAL
90554: IFFALSE 90595
// begin if HasTask ( group [ i ] ) then
90556: LD_VAR 0 4
90560: PUSH
90561: LD_VAR 0 7
90565: ARRAY
90566: PPUSH
90567: CALL_OW 314
90571: IFFALSE 90577
// continue else
90573: GO 86734
90575: GO 90595
// SetTag ( group [ i ] , 0 ) ;
90577: LD_VAR 0 4
90581: PUSH
90582: LD_VAR 0 7
90586: ARRAY
90587: PPUSH
90588: LD_INT 0
90590: PPUSH
90591: CALL_OW 109
// end ; k := 8 ;
90595: LD_ADDR_VAR 0 9
90599: PUSH
90600: LD_INT 8
90602: ST_TO_ADDR
// x := 0 ;
90603: LD_ADDR_VAR 0 10
90607: PUSH
90608: LD_INT 0
90610: ST_TO_ADDR
// if tmp < k then
90611: LD_VAR 0 14
90615: PUSH
90616: LD_VAR 0 9
90620: LESS
90621: IFFALSE 90633
// k := tmp ;
90623: LD_ADDR_VAR 0 9
90627: PUSH
90628: LD_VAR 0 14
90632: ST_TO_ADDR
// for j = 1 to k do
90633: LD_ADDR_VAR 0 8
90637: PUSH
90638: DOUBLE
90639: LD_INT 1
90641: DEC
90642: ST_TO_ADDR
90643: LD_VAR 0 9
90647: PUSH
90648: FOR_TO
90649: IFFALSE 90747
// if GetType ( tmp [ j ] ) = unit_human and ( ( GetLives ( tmp [ j ] ) < 250 and f_murder ) or ( not f_murder and GetLives ( tmp [ j ] ) >= 250 ) ) then
90651: LD_VAR 0 14
90655: PUSH
90656: LD_VAR 0 8
90660: ARRAY
90661: PPUSH
90662: CALL_OW 247
90666: PUSH
90667: LD_INT 1
90669: EQUAL
90670: PUSH
90671: LD_VAR 0 14
90675: PUSH
90676: LD_VAR 0 8
90680: ARRAY
90681: PPUSH
90682: CALL_OW 256
90686: PUSH
90687: LD_INT 250
90689: LESS
90690: PUSH
90691: LD_VAR 0 20
90695: AND
90696: PUSH
90697: LD_VAR 0 20
90701: NOT
90702: PUSH
90703: LD_VAR 0 14
90707: PUSH
90708: LD_VAR 0 8
90712: ARRAY
90713: PPUSH
90714: CALL_OW 256
90718: PUSH
90719: LD_INT 250
90721: GREATEREQUAL
90722: AND
90723: OR
90724: AND
90725: IFFALSE 90745
// begin x := tmp [ j ] ;
90727: LD_ADDR_VAR 0 10
90731: PUSH
90732: LD_VAR 0 14
90736: PUSH
90737: LD_VAR 0 8
90741: ARRAY
90742: ST_TO_ADDR
// break ;
90743: GO 90747
// end ;
90745: GO 90648
90747: POP
90748: POP
// if x then
90749: LD_VAR 0 10
90753: IFFALSE 90777
// ComAttackUnit ( group [ i ] , x ) else
90755: LD_VAR 0 4
90759: PUSH
90760: LD_VAR 0 7
90764: ARRAY
90765: PPUSH
90766: LD_VAR 0 10
90770: PPUSH
90771: CALL_OW 115
90775: GO 90801
// ComAttackUnit ( group [ i ] , tmp [ 1 ] ) ;
90777: LD_VAR 0 4
90781: PUSH
90782: LD_VAR 0 7
90786: ARRAY
90787: PPUSH
90788: LD_VAR 0 14
90792: PUSH
90793: LD_INT 1
90795: ARRAY
90796: PPUSH
90797: CALL_OW 115
// if not HasTask ( group [ i ] ) then
90801: LD_VAR 0 4
90805: PUSH
90806: LD_VAR 0 7
90810: ARRAY
90811: PPUSH
90812: CALL_OW 314
90816: NOT
90817: IFFALSE 90855
// ComAttackUnit ( group [ i ] , NearestUnitToUnit ( tmp , group [ i ] ) ) ;
90819: LD_VAR 0 4
90823: PUSH
90824: LD_VAR 0 7
90828: ARRAY
90829: PPUSH
90830: LD_VAR 0 14
90834: PPUSH
90835: LD_VAR 0 4
90839: PUSH
90840: LD_VAR 0 7
90844: ARRAY
90845: PPUSH
90846: CALL_OW 74
90850: PPUSH
90851: CALL_OW 115
// end ; end ; end ;
90855: GO 86734
90857: POP
90858: POP
// wait ( 0 0$1 ) ;
90859: LD_INT 35
90861: PPUSH
90862: CALL_OW 67
// until group = [ ] or not FilterAllUnits ( [ f_enemy , side ] ) ;
90866: LD_VAR 0 4
90870: PUSH
90871: EMPTY
90872: EQUAL
90873: PUSH
90874: LD_INT 81
90876: PUSH
90877: LD_VAR 0 35
90881: PUSH
90882: EMPTY
90883: LIST
90884: LIST
90885: PPUSH
90886: CALL_OW 69
90890: NOT
90891: OR
90892: IFFALSE 86719
// end ;
90894: LD_VAR 0 2
90898: RET
// export function _ScanBase ( base_units ) ; var i , t , tmp ; begin
90899: LD_INT 0
90901: PPUSH
90902: PPUSH
90903: PPUSH
90904: PPUSH
// if not base_units then
90905: LD_VAR 0 1
90909: NOT
90910: IFFALSE 90914
// exit ;
90912: GO 91001
// result := false ;
90914: LD_ADDR_VAR 0 2
90918: PUSH
90919: LD_INT 0
90921: ST_TO_ADDR
// tmp := UnitFilter ( base_units , [ f_type , unit_building ] ) ;
90922: LD_ADDR_VAR 0 5
90926: PUSH
90927: LD_VAR 0 1
90931: PPUSH
90932: LD_INT 21
90934: PUSH
90935: LD_INT 3
90937: PUSH
90938: EMPTY
90939: LIST
90940: LIST
90941: PPUSH
90942: CALL_OW 72
90946: ST_TO_ADDR
// if not tmp then
90947: LD_VAR 0 5
90951: NOT
90952: IFFALSE 90956
// exit ;
90954: GO 91001
// for i in tmp do
90956: LD_ADDR_VAR 0 3
90960: PUSH
90961: LD_VAR 0 5
90965: PUSH
90966: FOR_IN
90967: IFFALSE 90999
// begin result := EnemyInRange ( i , 22 ) ;
90969: LD_ADDR_VAR 0 2
90973: PUSH
90974: LD_VAR 0 3
90978: PPUSH
90979: LD_INT 22
90981: PPUSH
90982: CALL 84535 0 2
90986: ST_TO_ADDR
// if result then
90987: LD_VAR 0 2
90991: IFFALSE 90997
// exit ;
90993: POP
90994: POP
90995: GO 91001
// end ;
90997: GO 90966
90999: POP
91000: POP
// end ;
91001: LD_VAR 0 2
91005: RET
// export function FilterByTag ( units , tag ) ; var i ; begin
91006: LD_INT 0
91008: PPUSH
91009: PPUSH
// if not units then
91010: LD_VAR 0 1
91014: NOT
91015: IFFALSE 91019
// exit ;
91017: GO 91089
// result := [ ] ;
91019: LD_ADDR_VAR 0 3
91023: PUSH
91024: EMPTY
91025: ST_TO_ADDR
// for i in units do
91026: LD_ADDR_VAR 0 4
91030: PUSH
91031: LD_VAR 0 1
91035: PUSH
91036: FOR_IN
91037: IFFALSE 91087
// if GetTag ( i ) = tag then
91039: LD_VAR 0 4
91043: PPUSH
91044: CALL_OW 110
91048: PUSH
91049: LD_VAR 0 2
91053: EQUAL
91054: IFFALSE 91085
// result := Insert ( result , result + 1 , i ) ;
91056: LD_ADDR_VAR 0 3
91060: PUSH
91061: LD_VAR 0 3
91065: PPUSH
91066: LD_VAR 0 3
91070: PUSH
91071: LD_INT 1
91073: PLUS
91074: PPUSH
91075: LD_VAR 0 4
91079: PPUSH
91080: CALL_OW 2
91084: ST_TO_ADDR
91085: GO 91036
91087: POP
91088: POP
// end ;
91089: LD_VAR 0 3
91093: RET
// export function IsDriver ( un ) ; begin
91094: LD_INT 0
91096: PPUSH
// result := un in FilterAllUnits ( [ f_driving ] ) ;
91097: LD_ADDR_VAR 0 2
91101: PUSH
91102: LD_VAR 0 1
91106: PUSH
91107: LD_INT 55
91109: PUSH
91110: EMPTY
91111: LIST
91112: PPUSH
91113: CALL_OW 69
91117: IN
91118: ST_TO_ADDR
// end ;
91119: LD_VAR 0 2
91123: RET
// export function GetFacExtXYD ( x , y , d ) ; var list ; begin
91124: LD_INT 0
91126: PPUSH
91127: PPUSH
// list := [ ] ;
91128: LD_ADDR_VAR 0 5
91132: PUSH
91133: EMPTY
91134: ST_TO_ADDR
// case d of 0 :
91135: LD_VAR 0 3
91139: PUSH
91140: LD_INT 0
91142: DOUBLE
91143: EQUAL
91144: IFTRUE 91148
91146: GO 91281
91148: POP
// begin list := [ [ x - 4 , y - 4 , 2 ] , [ x - 3 , y , 1 ] , [ x + 4 , y , 4 ] , [ x + 3 , y + 3 , 5 ] , [ x , y + 4 , 0 ] ] ;
91149: LD_ADDR_VAR 0 5
91153: PUSH
91154: LD_VAR 0 1
91158: PUSH
91159: LD_INT 4
91161: MINUS
91162: PUSH
91163: LD_VAR 0 2
91167: PUSH
91168: LD_INT 4
91170: MINUS
91171: PUSH
91172: LD_INT 2
91174: PUSH
91175: EMPTY
91176: LIST
91177: LIST
91178: LIST
91179: PUSH
91180: LD_VAR 0 1
91184: PUSH
91185: LD_INT 3
91187: MINUS
91188: PUSH
91189: LD_VAR 0 2
91193: PUSH
91194: LD_INT 1
91196: PUSH
91197: EMPTY
91198: LIST
91199: LIST
91200: LIST
91201: PUSH
91202: LD_VAR 0 1
91206: PUSH
91207: LD_INT 4
91209: PLUS
91210: PUSH
91211: LD_VAR 0 2
91215: PUSH
91216: LD_INT 4
91218: PUSH
91219: EMPTY
91220: LIST
91221: LIST
91222: LIST
91223: PUSH
91224: LD_VAR 0 1
91228: PUSH
91229: LD_INT 3
91231: PLUS
91232: PUSH
91233: LD_VAR 0 2
91237: PUSH
91238: LD_INT 3
91240: PLUS
91241: PUSH
91242: LD_INT 5
91244: PUSH
91245: EMPTY
91246: LIST
91247: LIST
91248: LIST
91249: PUSH
91250: LD_VAR 0 1
91254: PUSH
91255: LD_VAR 0 2
91259: PUSH
91260: LD_INT 4
91262: PLUS
91263: PUSH
91264: LD_INT 0
91266: PUSH
91267: EMPTY
91268: LIST
91269: LIST
91270: LIST
91271: PUSH
91272: EMPTY
91273: LIST
91274: LIST
91275: LIST
91276: LIST
91277: LIST
91278: ST_TO_ADDR
// end ; 1 :
91279: GO 91979
91281: LD_INT 1
91283: DOUBLE
91284: EQUAL
91285: IFTRUE 91289
91287: GO 91422
91289: POP
// begin list := [ [ x , y - 4 , 3 ] , [ x - 3 , y - 3 , 2 ] , [ x - 4 , y , 1 ] , [ x , y + 3 , 0 ] , [ x + 4 , y + 4 , 5 ] ] ;
91290: LD_ADDR_VAR 0 5
91294: PUSH
91295: LD_VAR 0 1
91299: PUSH
91300: LD_VAR 0 2
91304: PUSH
91305: LD_INT 4
91307: MINUS
91308: PUSH
91309: LD_INT 3
91311: PUSH
91312: EMPTY
91313: LIST
91314: LIST
91315: LIST
91316: PUSH
91317: LD_VAR 0 1
91321: PUSH
91322: LD_INT 3
91324: MINUS
91325: PUSH
91326: LD_VAR 0 2
91330: PUSH
91331: LD_INT 3
91333: MINUS
91334: PUSH
91335: LD_INT 2
91337: PUSH
91338: EMPTY
91339: LIST
91340: LIST
91341: LIST
91342: PUSH
91343: LD_VAR 0 1
91347: PUSH
91348: LD_INT 4
91350: MINUS
91351: PUSH
91352: LD_VAR 0 2
91356: PUSH
91357: LD_INT 1
91359: PUSH
91360: EMPTY
91361: LIST
91362: LIST
91363: LIST
91364: PUSH
91365: LD_VAR 0 1
91369: PUSH
91370: LD_VAR 0 2
91374: PUSH
91375: LD_INT 3
91377: PLUS
91378: PUSH
91379: LD_INT 0
91381: PUSH
91382: EMPTY
91383: LIST
91384: LIST
91385: LIST
91386: PUSH
91387: LD_VAR 0 1
91391: PUSH
91392: LD_INT 4
91394: PLUS
91395: PUSH
91396: LD_VAR 0 2
91400: PUSH
91401: LD_INT 4
91403: PLUS
91404: PUSH
91405: LD_INT 5
91407: PUSH
91408: EMPTY
91409: LIST
91410: LIST
91411: LIST
91412: PUSH
91413: EMPTY
91414: LIST
91415: LIST
91416: LIST
91417: LIST
91418: LIST
91419: ST_TO_ADDR
// end ; 2 :
91420: GO 91979
91422: LD_INT 2
91424: DOUBLE
91425: EQUAL
91426: IFTRUE 91430
91428: GO 91559
91430: POP
// begin list := [ [ x , y - 3 , 3 ] , [ x + 4 , y , 4 ] , [ x , y + 4 , 0 ] , [ x - 3 , y , 1 ] , [ x - 4 , y - 4 , 2 ] ] ;
91431: LD_ADDR_VAR 0 5
91435: PUSH
91436: LD_VAR 0 1
91440: PUSH
91441: LD_VAR 0 2
91445: PUSH
91446: LD_INT 3
91448: MINUS
91449: PUSH
91450: LD_INT 3
91452: PUSH
91453: EMPTY
91454: LIST
91455: LIST
91456: LIST
91457: PUSH
91458: LD_VAR 0 1
91462: PUSH
91463: LD_INT 4
91465: PLUS
91466: PUSH
91467: LD_VAR 0 2
91471: PUSH
91472: LD_INT 4
91474: PUSH
91475: EMPTY
91476: LIST
91477: LIST
91478: LIST
91479: PUSH
91480: LD_VAR 0 1
91484: PUSH
91485: LD_VAR 0 2
91489: PUSH
91490: LD_INT 4
91492: PLUS
91493: PUSH
91494: LD_INT 0
91496: PUSH
91497: EMPTY
91498: LIST
91499: LIST
91500: LIST
91501: PUSH
91502: LD_VAR 0 1
91506: PUSH
91507: LD_INT 3
91509: MINUS
91510: PUSH
91511: LD_VAR 0 2
91515: PUSH
91516: LD_INT 1
91518: PUSH
91519: EMPTY
91520: LIST
91521: LIST
91522: LIST
91523: PUSH
91524: LD_VAR 0 1
91528: PUSH
91529: LD_INT 4
91531: MINUS
91532: PUSH
91533: LD_VAR 0 2
91537: PUSH
91538: LD_INT 4
91540: MINUS
91541: PUSH
91542: LD_INT 2
91544: PUSH
91545: EMPTY
91546: LIST
91547: LIST
91548: LIST
91549: PUSH
91550: EMPTY
91551: LIST
91552: LIST
91553: LIST
91554: LIST
91555: LIST
91556: ST_TO_ADDR
// end ; 3 :
91557: GO 91979
91559: LD_INT 3
91561: DOUBLE
91562: EQUAL
91563: IFTRUE 91567
91565: GO 91700
91567: POP
// begin list := [ [ x + 3 , y , 4 ] , [ x + 4 , y + 4 , 5 ] , [ x - 4 , y , 1 ] , [ x , y - 4 , 3 ] , [ x - 3 , y - 3 , 2 ] ] ;
91568: LD_ADDR_VAR 0 5
91572: PUSH
91573: LD_VAR 0 1
91577: PUSH
91578: LD_INT 3
91580: PLUS
91581: PUSH
91582: LD_VAR 0 2
91586: PUSH
91587: LD_INT 4
91589: PUSH
91590: EMPTY
91591: LIST
91592: LIST
91593: LIST
91594: PUSH
91595: LD_VAR 0 1
91599: PUSH
91600: LD_INT 4
91602: PLUS
91603: PUSH
91604: LD_VAR 0 2
91608: PUSH
91609: LD_INT 4
91611: PLUS
91612: PUSH
91613: LD_INT 5
91615: PUSH
91616: EMPTY
91617: LIST
91618: LIST
91619: LIST
91620: PUSH
91621: LD_VAR 0 1
91625: PUSH
91626: LD_INT 4
91628: MINUS
91629: PUSH
91630: LD_VAR 0 2
91634: PUSH
91635: LD_INT 1
91637: PUSH
91638: EMPTY
91639: LIST
91640: LIST
91641: LIST
91642: PUSH
91643: LD_VAR 0 1
91647: PUSH
91648: LD_VAR 0 2
91652: PUSH
91653: LD_INT 4
91655: MINUS
91656: PUSH
91657: LD_INT 3
91659: PUSH
91660: EMPTY
91661: LIST
91662: LIST
91663: LIST
91664: PUSH
91665: LD_VAR 0 1
91669: PUSH
91670: LD_INT 3
91672: MINUS
91673: PUSH
91674: LD_VAR 0 2
91678: PUSH
91679: LD_INT 3
91681: MINUS
91682: PUSH
91683: LD_INT 2
91685: PUSH
91686: EMPTY
91687: LIST
91688: LIST
91689: LIST
91690: PUSH
91691: EMPTY
91692: LIST
91693: LIST
91694: LIST
91695: LIST
91696: LIST
91697: ST_TO_ADDR
// end ; 4 :
91698: GO 91979
91700: LD_INT 4
91702: DOUBLE
91703: EQUAL
91704: IFTRUE 91708
91706: GO 91841
91708: POP
// begin list := [ [ x , y + 4 , 0 ] , [ x + 3 , y + 3 , 5 ] , [ x + 4 , y , 4 ] , [ x , y - 3 , 3 ] , [ x - 4 , y - 4 , 2 ] ] ;
91709: LD_ADDR_VAR 0 5
91713: PUSH
91714: LD_VAR 0 1
91718: PUSH
91719: LD_VAR 0 2
91723: PUSH
91724: LD_INT 4
91726: PLUS
91727: PUSH
91728: LD_INT 0
91730: PUSH
91731: EMPTY
91732: LIST
91733: LIST
91734: LIST
91735: PUSH
91736: LD_VAR 0 1
91740: PUSH
91741: LD_INT 3
91743: PLUS
91744: PUSH
91745: LD_VAR 0 2
91749: PUSH
91750: LD_INT 3
91752: PLUS
91753: PUSH
91754: LD_INT 5
91756: PUSH
91757: EMPTY
91758: LIST
91759: LIST
91760: LIST
91761: PUSH
91762: LD_VAR 0 1
91766: PUSH
91767: LD_INT 4
91769: PLUS
91770: PUSH
91771: LD_VAR 0 2
91775: PUSH
91776: LD_INT 4
91778: PUSH
91779: EMPTY
91780: LIST
91781: LIST
91782: LIST
91783: PUSH
91784: LD_VAR 0 1
91788: PUSH
91789: LD_VAR 0 2
91793: PUSH
91794: LD_INT 3
91796: MINUS
91797: PUSH
91798: LD_INT 3
91800: PUSH
91801: EMPTY
91802: LIST
91803: LIST
91804: LIST
91805: PUSH
91806: LD_VAR 0 1
91810: PUSH
91811: LD_INT 4
91813: MINUS
91814: PUSH
91815: LD_VAR 0 2
91819: PUSH
91820: LD_INT 4
91822: MINUS
91823: PUSH
91824: LD_INT 2
91826: PUSH
91827: EMPTY
91828: LIST
91829: LIST
91830: LIST
91831: PUSH
91832: EMPTY
91833: LIST
91834: LIST
91835: LIST
91836: LIST
91837: LIST
91838: ST_TO_ADDR
// end ; 5 :
91839: GO 91979
91841: LD_INT 5
91843: DOUBLE
91844: EQUAL
91845: IFTRUE 91849
91847: GO 91978
91849: POP
// begin list := [ [ x - 4 , y , 1 ] , [ x , y - 4 , 3 ] , [ x + 4 , y + 4 , 5 ] , [ x + 3 , y , 4 ] , [ x , y + 3 , 0 ] ] ;
91850: LD_ADDR_VAR 0 5
91854: PUSH
91855: LD_VAR 0 1
91859: PUSH
91860: LD_INT 4
91862: MINUS
91863: PUSH
91864: LD_VAR 0 2
91868: PUSH
91869: LD_INT 1
91871: PUSH
91872: EMPTY
91873: LIST
91874: LIST
91875: LIST
91876: PUSH
91877: LD_VAR 0 1
91881: PUSH
91882: LD_VAR 0 2
91886: PUSH
91887: LD_INT 4
91889: MINUS
91890: PUSH
91891: LD_INT 3
91893: PUSH
91894: EMPTY
91895: LIST
91896: LIST
91897: LIST
91898: PUSH
91899: LD_VAR 0 1
91903: PUSH
91904: LD_INT 4
91906: PLUS
91907: PUSH
91908: LD_VAR 0 2
91912: PUSH
91913: LD_INT 4
91915: PLUS
91916: PUSH
91917: LD_INT 5
91919: PUSH
91920: EMPTY
91921: LIST
91922: LIST
91923: LIST
91924: PUSH
91925: LD_VAR 0 1
91929: PUSH
91930: LD_INT 3
91932: PLUS
91933: PUSH
91934: LD_VAR 0 2
91938: PUSH
91939: LD_INT 4
91941: PUSH
91942: EMPTY
91943: LIST
91944: LIST
91945: LIST
91946: PUSH
91947: LD_VAR 0 1
91951: PUSH
91952: LD_VAR 0 2
91956: PUSH
91957: LD_INT 3
91959: PLUS
91960: PUSH
91961: LD_INT 0
91963: PUSH
91964: EMPTY
91965: LIST
91966: LIST
91967: LIST
91968: PUSH
91969: EMPTY
91970: LIST
91971: LIST
91972: LIST
91973: LIST
91974: LIST
91975: ST_TO_ADDR
// end ; end ;
91976: GO 91979
91978: POP
// result := list ;
91979: LD_ADDR_VAR 0 4
91983: PUSH
91984: LD_VAR 0 5
91988: ST_TO_ADDR
// end ;
91989: LD_VAR 0 4
91993: RET
// export function SortBySkill ( units , class ) ; var i , tmp ; begin
91994: LD_INT 0
91996: PPUSH
91997: PPUSH
91998: PPUSH
// if not units or not class in [ 1 , 2 , 3 , 4 ] then
91999: LD_VAR 0 1
92003: NOT
92004: PUSH
92005: LD_VAR 0 2
92009: PUSH
92010: LD_INT 1
92012: PUSH
92013: LD_INT 2
92015: PUSH
92016: LD_INT 3
92018: PUSH
92019: LD_INT 4
92021: PUSH
92022: EMPTY
92023: LIST
92024: LIST
92025: LIST
92026: LIST
92027: IN
92028: NOT
92029: OR
92030: IFFALSE 92034
// exit ;
92032: GO 92126
// tmp := [ ] ;
92034: LD_ADDR_VAR 0 5
92038: PUSH
92039: EMPTY
92040: ST_TO_ADDR
// for i in units do
92041: LD_ADDR_VAR 0 4
92045: PUSH
92046: LD_VAR 0 1
92050: PUSH
92051: FOR_IN
92052: IFFALSE 92095
// tmp := Insert ( tmp , tmp + 1 , GetSkill ( i , class ) ) ;
92054: LD_ADDR_VAR 0 5
92058: PUSH
92059: LD_VAR 0 5
92063: PPUSH
92064: LD_VAR 0 5
92068: PUSH
92069: LD_INT 1
92071: PLUS
92072: PPUSH
92073: LD_VAR 0 4
92077: PPUSH
92078: LD_VAR 0 2
92082: PPUSH
92083: CALL_OW 259
92087: PPUSH
92088: CALL_OW 2
92092: ST_TO_ADDR
92093: GO 92051
92095: POP
92096: POP
// if not tmp then
92097: LD_VAR 0 5
92101: NOT
92102: IFFALSE 92106
// exit ;
92104: GO 92126
// result := SortListByListDesc ( units , tmp ) ;
92106: LD_ADDR_VAR 0 3
92110: PUSH
92111: LD_VAR 0 1
92115: PPUSH
92116: LD_VAR 0 5
92120: PPUSH
92121: CALL_OW 77
92125: ST_TO_ADDR
// end ;
92126: LD_VAR 0 3
92130: RET
// export function UnitGoingToBuilding ( unit , building ) ; var x , y ; begin
92131: LD_INT 0
92133: PPUSH
92134: PPUSH
92135: PPUSH
// x := GetX ( building ) ;
92136: LD_ADDR_VAR 0 4
92140: PUSH
92141: LD_VAR 0 2
92145: PPUSH
92146: CALL_OW 250
92150: ST_TO_ADDR
// y := GetY ( building ) ;
92151: LD_ADDR_VAR 0 5
92155: PUSH
92156: LD_VAR 0 2
92160: PPUSH
92161: CALL_OW 251
92165: ST_TO_ADDR
// if GetTaskList ( unit ) then
92166: LD_VAR 0 1
92170: PPUSH
92171: CALL_OW 437
92175: IFFALSE 92270
// begin if e = GetTaskList ( unit ) [ 1 ] [ 1 ] and x = GetTaskList ( unit ) [ 1 ] [ 2 ] and y = GetTaskList ( unit ) [ 1 ] [ 3 ] then
92177: LD_STRING e
92179: PUSH
92180: LD_VAR 0 1
92184: PPUSH
92185: CALL_OW 437
92189: PUSH
92190: LD_INT 1
92192: ARRAY
92193: PUSH
92194: LD_INT 1
92196: ARRAY
92197: EQUAL
92198: PUSH
92199: LD_VAR 0 4
92203: PUSH
92204: LD_VAR 0 1
92208: PPUSH
92209: CALL_OW 437
92213: PUSH
92214: LD_INT 1
92216: ARRAY
92217: PUSH
92218: LD_INT 2
92220: ARRAY
92221: EQUAL
92222: AND
92223: PUSH
92224: LD_VAR 0 5
92228: PUSH
92229: LD_VAR 0 1
92233: PPUSH
92234: CALL_OW 437
92238: PUSH
92239: LD_INT 1
92241: ARRAY
92242: PUSH
92243: LD_INT 3
92245: ARRAY
92246: EQUAL
92247: AND
92248: IFFALSE 92260
// result := true else
92250: LD_ADDR_VAR 0 3
92254: PUSH
92255: LD_INT 1
92257: ST_TO_ADDR
92258: GO 92268
// result := false ;
92260: LD_ADDR_VAR 0 3
92264: PUSH
92265: LD_INT 0
92267: ST_TO_ADDR
// end else
92268: GO 92278
// result := false ;
92270: LD_ADDR_VAR 0 3
92274: PUSH
92275: LD_INT 0
92277: ST_TO_ADDR
// end ;
92278: LD_VAR 0 3
92282: RET
// export function PlaceUnitInArea ( unit , area , mode ) ; var i , tmp , hex ; begin
92283: LD_INT 0
92285: PPUSH
92286: PPUSH
92287: PPUSH
92288: PPUSH
// if not unit or not area then
92289: LD_VAR 0 1
92293: NOT
92294: PUSH
92295: LD_VAR 0 2
92299: NOT
92300: OR
92301: IFFALSE 92305
// exit ;
92303: GO 92469
// tmp := AreaToList ( area , i ) ;
92305: LD_ADDR_VAR 0 6
92309: PUSH
92310: LD_VAR 0 2
92314: PPUSH
92315: LD_VAR 0 5
92319: PPUSH
92320: CALL_OW 517
92324: ST_TO_ADDR
// for i = 1 to tmp [ 1 ] do
92325: LD_ADDR_VAR 0 5
92329: PUSH
92330: DOUBLE
92331: LD_INT 1
92333: DEC
92334: ST_TO_ADDR
92335: LD_VAR 0 6
92339: PUSH
92340: LD_INT 1
92342: ARRAY
92343: PUSH
92344: FOR_TO
92345: IFFALSE 92467
// begin hex := [ tmp [ 1 ] [ i ] , tmp [ 2 ] [ i ] ] ;
92347: LD_ADDR_VAR 0 7
92351: PUSH
92352: LD_VAR 0 6
92356: PUSH
92357: LD_INT 1
92359: ARRAY
92360: PUSH
92361: LD_VAR 0 5
92365: ARRAY
92366: PUSH
92367: LD_VAR 0 6
92371: PUSH
92372: LD_INT 2
92374: ARRAY
92375: PUSH
92376: LD_VAR 0 5
92380: ARRAY
92381: PUSH
92382: EMPTY
92383: LIST
92384: LIST
92385: ST_TO_ADDR
// if HexInfo ( hex [ 1 ] , hex [ 2 ] ) = 0 then
92386: LD_VAR 0 7
92390: PUSH
92391: LD_INT 1
92393: ARRAY
92394: PPUSH
92395: LD_VAR 0 7
92399: PUSH
92400: LD_INT 2
92402: ARRAY
92403: PPUSH
92404: CALL_OW 428
92408: PUSH
92409: LD_INT 0
92411: EQUAL
92412: IFFALSE 92465
// begin PlaceUnitXY ( unit , hex [ 1 ] , hex [ 2 ] , mode ) ;
92414: LD_VAR 0 1
92418: PPUSH
92419: LD_VAR 0 7
92423: PUSH
92424: LD_INT 1
92426: ARRAY
92427: PPUSH
92428: LD_VAR 0 7
92432: PUSH
92433: LD_INT 2
92435: ARRAY
92436: PPUSH
92437: LD_VAR 0 3
92441: PPUSH
92442: CALL_OW 48
// result := IsPlaced ( unit ) ;
92446: LD_ADDR_VAR 0 4
92450: PUSH
92451: LD_VAR 0 1
92455: PPUSH
92456: CALL_OW 305
92460: ST_TO_ADDR
// exit ;
92461: POP
92462: POP
92463: GO 92469
// end ; end ;
92465: GO 92344
92467: POP
92468: POP
// end ;
92469: LD_VAR 0 4
92473: RET
// export function BuildingsListDump ( side ) ; var i , tmp ; begin
92474: LD_INT 0
92476: PPUSH
92477: PPUSH
92478: PPUSH
// if not side or side > 8 then
92479: LD_VAR 0 1
92483: NOT
92484: PUSH
92485: LD_VAR 0 1
92489: PUSH
92490: LD_INT 8
92492: GREATER
92493: OR
92494: IFFALSE 92498
// exit ;
92496: GO 92685
// tmp := FilterAllUnits ( [ [ f_side , side ] , [ f_type , unit_building ] ] ) ;
92498: LD_ADDR_VAR 0 4
92502: PUSH
92503: LD_INT 22
92505: PUSH
92506: LD_VAR 0 1
92510: PUSH
92511: EMPTY
92512: LIST
92513: LIST
92514: PUSH
92515: LD_INT 21
92517: PUSH
92518: LD_INT 3
92520: PUSH
92521: EMPTY
92522: LIST
92523: LIST
92524: PUSH
92525: EMPTY
92526: LIST
92527: LIST
92528: PPUSH
92529: CALL_OW 69
92533: ST_TO_ADDR
// if not tmp then
92534: LD_VAR 0 4
92538: NOT
92539: IFFALSE 92543
// exit ;
92541: GO 92685
// enable_addtolog := true ;
92543: LD_ADDR_OWVAR 81
92547: PUSH
92548: LD_INT 1
92550: ST_TO_ADDR
// AddToLog ( [ ) ;
92551: LD_STRING [
92553: PPUSH
92554: CALL_OW 561
// for i in tmp do
92558: LD_ADDR_VAR 0 3
92562: PUSH
92563: LD_VAR 0 4
92567: PUSH
92568: FOR_IN
92569: IFFALSE 92676
// begin AddToLog ( [ & GetBType ( i ) & ,  & GetX ( i ) & ,  & GetY ( i ) & ,  & GetDir ( i ) & ,  & GetLabKind ( i , 1 ) & ,  & GetLabKind ( i , 2 ) & ], ) ;
92571: LD_STRING [
92573: PUSH
92574: LD_VAR 0 3
92578: PPUSH
92579: CALL_OW 266
92583: STR
92584: PUSH
92585: LD_STRING , 
92587: STR
92588: PUSH
92589: LD_VAR 0 3
92593: PPUSH
92594: CALL_OW 250
92598: STR
92599: PUSH
92600: LD_STRING , 
92602: STR
92603: PUSH
92604: LD_VAR 0 3
92608: PPUSH
92609: CALL_OW 251
92613: STR
92614: PUSH
92615: LD_STRING , 
92617: STR
92618: PUSH
92619: LD_VAR 0 3
92623: PPUSH
92624: CALL_OW 254
92628: STR
92629: PUSH
92630: LD_STRING , 
92632: STR
92633: PUSH
92634: LD_VAR 0 3
92638: PPUSH
92639: LD_INT 1
92641: PPUSH
92642: CALL_OW 268
92646: STR
92647: PUSH
92648: LD_STRING , 
92650: STR
92651: PUSH
92652: LD_VAR 0 3
92656: PPUSH
92657: LD_INT 2
92659: PPUSH
92660: CALL_OW 268
92664: STR
92665: PUSH
92666: LD_STRING ],
92668: STR
92669: PPUSH
92670: CALL_OW 561
// end ;
92674: GO 92568
92676: POP
92677: POP
// AddToLog ( ]; ) ;
92678: LD_STRING ];
92680: PPUSH
92681: CALL_OW 561
// end ;
92685: LD_VAR 0 2
92689: RET
// export function Crates ( area , rate , min , max ) ; var i , r , time , amount ; begin
92690: LD_INT 0
92692: PPUSH
92693: PPUSH
92694: PPUSH
92695: PPUSH
92696: PPUSH
// if not area or not rate or not max then
92697: LD_VAR 0 1
92701: NOT
92702: PUSH
92703: LD_VAR 0 2
92707: NOT
92708: OR
92709: PUSH
92710: LD_VAR 0 4
92714: NOT
92715: OR
92716: IFFALSE 92720
// exit ;
92718: GO 92912
// while 1 do
92720: LD_INT 1
92722: IFFALSE 92912
// begin amount := GetResourceArea ( area , mat_cans ) * 10 ;
92724: LD_ADDR_VAR 0 9
92728: PUSH
92729: LD_VAR 0 1
92733: PPUSH
92734: LD_INT 1
92736: PPUSH
92737: CALL_OW 287
92741: PUSH
92742: LD_INT 10
92744: MUL
92745: ST_TO_ADDR
// r := rate / 10 ;
92746: LD_ADDR_VAR 0 7
92750: PUSH
92751: LD_VAR 0 2
92755: PUSH
92756: LD_INT 10
92758: DIVREAL
92759: ST_TO_ADDR
// time := 1 1$00 ;
92760: LD_ADDR_VAR 0 8
92764: PUSH
92765: LD_INT 2100
92767: ST_TO_ADDR
// if amount < min then
92768: LD_VAR 0 9
92772: PUSH
92773: LD_VAR 0 3
92777: LESS
92778: IFFALSE 92796
// r := r * 2 else
92780: LD_ADDR_VAR 0 7
92784: PUSH
92785: LD_VAR 0 7
92789: PUSH
92790: LD_INT 2
92792: MUL
92793: ST_TO_ADDR
92794: GO 92822
// if amount > max then
92796: LD_VAR 0 9
92800: PUSH
92801: LD_VAR 0 4
92805: GREATER
92806: IFFALSE 92822
// r := r / 2 ;
92808: LD_ADDR_VAR 0 7
92812: PUSH
92813: LD_VAR 0 7
92817: PUSH
92818: LD_INT 2
92820: DIVREAL
92821: ST_TO_ADDR
// time := time / r ;
92822: LD_ADDR_VAR 0 8
92826: PUSH
92827: LD_VAR 0 8
92831: PUSH
92832: LD_VAR 0 7
92836: DIVREAL
92837: ST_TO_ADDR
// if time < 0 then
92838: LD_VAR 0 8
92842: PUSH
92843: LD_INT 0
92845: LESS
92846: IFFALSE 92863
// time := time * - 1 ;
92848: LD_ADDR_VAR 0 8
92852: PUSH
92853: LD_VAR 0 8
92857: PUSH
92858: LD_INT 1
92860: NEG
92861: MUL
92862: ST_TO_ADDR
// wait ( time ) ;
92863: LD_VAR 0 8
92867: PPUSH
92868: CALL_OW 67
// wait ( rand ( 0 0$01 , 0 0$25 ) ) ;
92872: LD_INT 35
92874: PPUSH
92875: LD_INT 875
92877: PPUSH
92878: CALL_OW 12
92882: PPUSH
92883: CALL_OW 67
// CreateCratesArea ( rand ( 1 , 5 ) , area , true ) ;
92887: LD_INT 1
92889: PPUSH
92890: LD_INT 5
92892: PPUSH
92893: CALL_OW 12
92897: PPUSH
92898: LD_VAR 0 1
92902: PPUSH
92903: LD_INT 1
92905: PPUSH
92906: CALL_OW 55
// end ;
92910: GO 92720
// end ;
92912: LD_VAR 0 5
92916: RET
// export function UpgradeTurretsWeapon ( turrets , factories ) ; var i , j , k , nat , weapon , weapons , list ; begin
92917: LD_INT 0
92919: PPUSH
92920: PPUSH
92921: PPUSH
92922: PPUSH
92923: PPUSH
92924: PPUSH
92925: PPUSH
92926: PPUSH
// if not turrets or not factories then
92927: LD_VAR 0 1
92931: NOT
92932: PUSH
92933: LD_VAR 0 2
92937: NOT
92938: OR
92939: IFFALSE 92943
// exit ;
92941: GO 93250
// list := [ [ [ us_double_gun , us_heavy_gun ] , [ us_machine_gun , us_gatling_gun ] , [ us_light_gun , us_double_gun ] ] , [ [ ar_double_machine_gun , ar_gatling_gun ] , [ ar_light_gun , ar_gun ] ] , [ [ ru_heavy_machine_gun , ru_gatling_gun ] , [ ru_gun , ru_heavy_gun ] , [ ru_rocket_launcher , ru_rocket ] ] , ] ;
92943: LD_ADDR_VAR 0 10
92947: PUSH
92948: LD_INT 5
92950: PUSH
92951: LD_INT 6
92953: PUSH
92954: EMPTY
92955: LIST
92956: LIST
92957: PUSH
92958: LD_INT 2
92960: PUSH
92961: LD_INT 4
92963: PUSH
92964: EMPTY
92965: LIST
92966: LIST
92967: PUSH
92968: LD_INT 3
92970: PUSH
92971: LD_INT 5
92973: PUSH
92974: EMPTY
92975: LIST
92976: LIST
92977: PUSH
92978: EMPTY
92979: LIST
92980: LIST
92981: LIST
92982: PUSH
92983: LD_INT 24
92985: PUSH
92986: LD_INT 25
92988: PUSH
92989: EMPTY
92990: LIST
92991: LIST
92992: PUSH
92993: LD_INT 23
92995: PUSH
92996: LD_INT 27
92998: PUSH
92999: EMPTY
93000: LIST
93001: LIST
93002: PUSH
93003: EMPTY
93004: LIST
93005: LIST
93006: PUSH
93007: LD_INT 42
93009: PUSH
93010: LD_INT 43
93012: PUSH
93013: EMPTY
93014: LIST
93015: LIST
93016: PUSH
93017: LD_INT 44
93019: PUSH
93020: LD_INT 46
93022: PUSH
93023: EMPTY
93024: LIST
93025: LIST
93026: PUSH
93027: LD_INT 45
93029: PUSH
93030: LD_INT 47
93032: PUSH
93033: EMPTY
93034: LIST
93035: LIST
93036: PUSH
93037: EMPTY
93038: LIST
93039: LIST
93040: LIST
93041: PUSH
93042: EMPTY
93043: LIST
93044: LIST
93045: LIST
93046: ST_TO_ADDR
// result := [ ] ;
93047: LD_ADDR_VAR 0 3
93051: PUSH
93052: EMPTY
93053: ST_TO_ADDR
// for i in turrets do
93054: LD_ADDR_VAR 0 4
93058: PUSH
93059: LD_VAR 0 1
93063: PUSH
93064: FOR_IN
93065: IFFALSE 93248
// begin nat := GetNation ( i ) ;
93067: LD_ADDR_VAR 0 7
93071: PUSH
93072: LD_VAR 0 4
93076: PPUSH
93077: CALL_OW 248
93081: ST_TO_ADDR
// weapon := 0 ;
93082: LD_ADDR_VAR 0 8
93086: PUSH
93087: LD_INT 0
93089: ST_TO_ADDR
// if not nat then
93090: LD_VAR 0 7
93094: NOT
93095: IFFALSE 93099
// continue ;
93097: GO 93064
// for j in list [ nat ] do
93099: LD_ADDR_VAR 0 5
93103: PUSH
93104: LD_VAR 0 10
93108: PUSH
93109: LD_VAR 0 7
93113: ARRAY
93114: PUSH
93115: FOR_IN
93116: IFFALSE 93157
// if GetBWeapon ( i ) = j [ 1 ] then
93118: LD_VAR 0 4
93122: PPUSH
93123: CALL_OW 269
93127: PUSH
93128: LD_VAR 0 5
93132: PUSH
93133: LD_INT 1
93135: ARRAY
93136: EQUAL
93137: IFFALSE 93155
// begin weapon := j [ 2 ] ;
93139: LD_ADDR_VAR 0 8
93143: PUSH
93144: LD_VAR 0 5
93148: PUSH
93149: LD_INT 2
93151: ARRAY
93152: ST_TO_ADDR
// break ;
93153: GO 93157
// end ;
93155: GO 93115
93157: POP
93158: POP
// if not weapon then
93159: LD_VAR 0 8
93163: NOT
93164: IFFALSE 93168
// continue ;
93166: GO 93064
// for k in factories do
93168: LD_ADDR_VAR 0 6
93172: PUSH
93173: LD_VAR 0 2
93177: PUSH
93178: FOR_IN
93179: IFFALSE 93244
// begin weapons := AvailableWeaponList ( k ) ;
93181: LD_ADDR_VAR 0 9
93185: PUSH
93186: LD_VAR 0 6
93190: PPUSH
93191: CALL_OW 478
93195: ST_TO_ADDR
// if not weapons then
93196: LD_VAR 0 9
93200: NOT
93201: IFFALSE 93205
// continue ;
93203: GO 93178
// if weapon in weapons then
93205: LD_VAR 0 8
93209: PUSH
93210: LD_VAR 0 9
93214: IN
93215: IFFALSE 93242
// begin result := [ i , weapon ] ;
93217: LD_ADDR_VAR 0 3
93221: PUSH
93222: LD_VAR 0 4
93226: PUSH
93227: LD_VAR 0 8
93231: PUSH
93232: EMPTY
93233: LIST
93234: LIST
93235: ST_TO_ADDR
// exit ;
93236: POP
93237: POP
93238: POP
93239: POP
93240: GO 93250
// end ; end ;
93242: GO 93178
93244: POP
93245: POP
// end ;
93246: GO 93064
93248: POP
93249: POP
// end ;
93250: LD_VAR 0 3
93254: RET
// export function RevealMapOnXY ( x , y , side , range ) ; begin
93255: LD_INT 0
93257: PPUSH
// if not side or side > 8 then
93258: LD_VAR 0 3
93262: NOT
93263: PUSH
93264: LD_VAR 0 3
93268: PUSH
93269: LD_INT 8
93271: GREATER
93272: OR
93273: IFFALSE 93277
// exit ;
93275: GO 93336
// if not range then
93277: LD_VAR 0 4
93281: NOT
93282: IFFALSE 93293
// range := - 12 ;
93284: LD_ADDR_VAR 0 4
93288: PUSH
93289: LD_INT 12
93291: NEG
93292: ST_TO_ADDR
// PlaceSeeing ( x , y , side , range ) ;
93293: LD_VAR 0 1
93297: PPUSH
93298: LD_VAR 0 2
93302: PPUSH
93303: LD_VAR 0 3
93307: PPUSH
93308: LD_VAR 0 4
93312: PPUSH
93313: CALL_OW 330
// RemoveSeeing ( x , y , side ) ;
93317: LD_VAR 0 1
93321: PPUSH
93322: LD_VAR 0 2
93326: PPUSH
93327: LD_VAR 0 3
93331: PPUSH
93332: CALL_OW 331
// end ;
93336: LD_VAR 0 5
93340: RET
// export function Video ( mode ) ; begin
93341: LD_INT 0
93343: PPUSH
// ingame_video = mode ;
93344: LD_ADDR_OWVAR 52
93348: PUSH
93349: LD_VAR 0 1
93353: ST_TO_ADDR
// interface_hidden = mode ;
93354: LD_ADDR_OWVAR 54
93358: PUSH
93359: LD_VAR 0 1
93363: ST_TO_ADDR
// end ;
93364: LD_VAR 0 2
93368: RET
// export function Join ( array , element ) ; begin
93369: LD_INT 0
93371: PPUSH
// result := array ^ element ;
93372: LD_ADDR_VAR 0 3
93376: PUSH
93377: LD_VAR 0 1
93381: PUSH
93382: LD_VAR 0 2
93386: ADD
93387: ST_TO_ADDR
// end ;
93388: LD_VAR 0 3
93392: RET
// export function JoinUnion ( array , element ) ; begin
93393: LD_INT 0
93395: PPUSH
// result := array union element ;
93396: LD_ADDR_VAR 0 3
93400: PUSH
93401: LD_VAR 0 1
93405: PUSH
93406: LD_VAR 0 2
93410: UNION
93411: ST_TO_ADDR
// end ;
93412: LD_VAR 0 3
93416: RET
// export function GetBehemoths ( side ) ; begin
93417: LD_INT 0
93419: PPUSH
// result := FilterAllUnits ( [ [ f_side , side ] , [ f_chassis , 25 ] ] ) ;
93420: LD_ADDR_VAR 0 2
93424: PUSH
93425: LD_INT 22
93427: PUSH
93428: LD_VAR 0 1
93432: PUSH
93433: EMPTY
93434: LIST
93435: LIST
93436: PUSH
93437: LD_INT 31
93439: PUSH
93440: LD_INT 25
93442: PUSH
93443: EMPTY
93444: LIST
93445: LIST
93446: PUSH
93447: EMPTY
93448: LIST
93449: LIST
93450: PPUSH
93451: CALL_OW 69
93455: ST_TO_ADDR
// end ;
93456: LD_VAR 0 2
93460: RET
// export function Shuffle ( array ) ; var i , index ; begin
93461: LD_INT 0
93463: PPUSH
93464: PPUSH
93465: PPUSH
// result := [ ] ;
93466: LD_ADDR_VAR 0 2
93470: PUSH
93471: EMPTY
93472: ST_TO_ADDR
// if not array then
93473: LD_VAR 0 1
93477: NOT
93478: IFFALSE 93482
// exit ;
93480: GO 93581
// Randomize ;
93482: CALL_OW 10
// for i = array downto 1 do
93486: LD_ADDR_VAR 0 3
93490: PUSH
93491: DOUBLE
93492: LD_VAR 0 1
93496: INC
93497: ST_TO_ADDR
93498: LD_INT 1
93500: PUSH
93501: FOR_DOWNTO
93502: IFFALSE 93579
// begin index := rand ( 1 , array ) ;
93504: LD_ADDR_VAR 0 4
93508: PUSH
93509: LD_INT 1
93511: PPUSH
93512: LD_VAR 0 1
93516: PPUSH
93517: CALL_OW 12
93521: ST_TO_ADDR
// result := Insert ( result , result + 1 , array [ index ] ) ;
93522: LD_ADDR_VAR 0 2
93526: PUSH
93527: LD_VAR 0 2
93531: PPUSH
93532: LD_VAR 0 2
93536: PUSH
93537: LD_INT 1
93539: PLUS
93540: PPUSH
93541: LD_VAR 0 1
93545: PUSH
93546: LD_VAR 0 4
93550: ARRAY
93551: PPUSH
93552: CALL_OW 2
93556: ST_TO_ADDR
// array := Delete ( array , index ) ;
93557: LD_ADDR_VAR 0 1
93561: PUSH
93562: LD_VAR 0 1
93566: PPUSH
93567: LD_VAR 0 4
93571: PPUSH
93572: CALL_OW 3
93576: ST_TO_ADDR
// end ;
93577: GO 93501
93579: POP
93580: POP
// end ;
93581: LD_VAR 0 2
93585: RET
// export function GetBaseMaterials ( base ) ; begin
93586: LD_INT 0
93588: PPUSH
// result := [ 0 , 0 , 0 ] ;
93589: LD_ADDR_VAR 0 2
93593: PUSH
93594: LD_INT 0
93596: PUSH
93597: LD_INT 0
93599: PUSH
93600: LD_INT 0
93602: PUSH
93603: EMPTY
93604: LIST
93605: LIST
93606: LIST
93607: ST_TO_ADDR
// if not base then
93608: LD_VAR 0 1
93612: NOT
93613: IFFALSE 93617
// exit ;
93615: GO 93666
// result := [ GetResourceType ( base , mat_cans ) , GetResourceType ( base , mat_oil ) , GetResourceType ( base , mat_siberit ) ] ;
93617: LD_ADDR_VAR 0 2
93621: PUSH
93622: LD_VAR 0 1
93626: PPUSH
93627: LD_INT 1
93629: PPUSH
93630: CALL_OW 275
93634: PUSH
93635: LD_VAR 0 1
93639: PPUSH
93640: LD_INT 2
93642: PPUSH
93643: CALL_OW 275
93647: PUSH
93648: LD_VAR 0 1
93652: PPUSH
93653: LD_INT 3
93655: PPUSH
93656: CALL_OW 275
93660: PUSH
93661: EMPTY
93662: LIST
93663: LIST
93664: LIST
93665: ST_TO_ADDR
// end ; end_of_file end_of_file end_of_file
93666: LD_VAR 0 2
93670: RET
// export function SOS_UnitExtraDestroyed ( un , killerSide , killerUnit ) ; var i , eff , side ; begin
93671: LD_INT 0
93673: PPUSH
93674: PPUSH
93675: PPUSH
93676: PPUSH
// if GetWeapon ( un ) = ar_bio_bomb then
93677: LD_VAR 0 1
93681: PPUSH
93682: CALL_OW 264
93686: PUSH
93687: LD_EXP 73
93691: EQUAL
93692: IFFALSE 93764
// begin if GetTech ( tech_bio3 , GetSide ( un ) ) = state_researched then
93694: LD_INT 68
93696: PPUSH
93697: LD_VAR 0 1
93701: PPUSH
93702: CALL_OW 255
93706: PPUSH
93707: CALL_OW 321
93711: PUSH
93712: LD_INT 2
93714: EQUAL
93715: IFFALSE 93727
// eff := 70 else
93717: LD_ADDR_VAR 0 6
93721: PUSH
93722: LD_INT 70
93724: ST_TO_ADDR
93725: GO 93735
// eff := 30 ;
93727: LD_ADDR_VAR 0 6
93731: PUSH
93732: LD_INT 30
93734: ST_TO_ADDR
// ArtContamination ( GetX ( un ) , GetY ( un ) , eff ) ;
93735: LD_VAR 0 1
93739: PPUSH
93740: CALL_OW 250
93744: PPUSH
93745: LD_VAR 0 1
93749: PPUSH
93750: CALL_OW 251
93754: PPUSH
93755: LD_VAR 0 6
93759: PPUSH
93760: CALL_OW 495
// end ; end ;
93764: LD_VAR 0 4
93768: RET
// export function SOS_Command ( cmd ) ; var i , j , tmp , taskList , _taskList ; begin
93769: LD_INT 0
93771: PPUSH
93772: PPUSH
93773: PPUSH
93774: PPUSH
93775: PPUSH
93776: PPUSH
// if cmd = 124 then
93777: LD_VAR 0 1
93781: PUSH
93782: LD_INT 124
93784: EQUAL
93785: IFFALSE 93991
// begin tmp := FilterAllUnits ( [ f_or , [ f_weapon , ru_bulldozer ] , [ f_weapon , us_bulldozer ] ] ) ;
93787: LD_ADDR_VAR 0 5
93791: PUSH
93792: LD_INT 2
93794: PUSH
93795: LD_INT 34
93797: PUSH
93798: LD_INT 53
93800: PUSH
93801: EMPTY
93802: LIST
93803: LIST
93804: PUSH
93805: LD_INT 34
93807: PUSH
93808: LD_INT 14
93810: PUSH
93811: EMPTY
93812: LIST
93813: LIST
93814: PUSH
93815: EMPTY
93816: LIST
93817: LIST
93818: LIST
93819: PPUSH
93820: CALL_OW 69
93824: ST_TO_ADDR
// if not tmp then
93825: LD_VAR 0 5
93829: NOT
93830: IFFALSE 93834
// exit ;
93832: GO 93991
// for i in tmp do
93834: LD_ADDR_VAR 0 3
93838: PUSH
93839: LD_VAR 0 5
93843: PUSH
93844: FOR_IN
93845: IFFALSE 93989
// begin taskList := GetTaskList ( i ) ;
93847: LD_ADDR_VAR 0 6
93851: PUSH
93852: LD_VAR 0 3
93856: PPUSH
93857: CALL_OW 437
93861: ST_TO_ADDR
// if not taskList then
93862: LD_VAR 0 6
93866: NOT
93867: IFFALSE 93871
// continue ;
93869: GO 93844
// for j = 1 to taskList do
93871: LD_ADDR_VAR 0 4
93875: PUSH
93876: DOUBLE
93877: LD_INT 1
93879: DEC
93880: ST_TO_ADDR
93881: LD_VAR 0 6
93885: PUSH
93886: FOR_TO
93887: IFFALSE 93985
// if taskList [ j ] [ 1 ] = | then
93889: LD_VAR 0 6
93893: PUSH
93894: LD_VAR 0 4
93898: ARRAY
93899: PUSH
93900: LD_INT 1
93902: ARRAY
93903: PUSH
93904: LD_STRING |
93906: EQUAL
93907: IFFALSE 93983
// begin _taskList := Delete ( taskList , 1 ) ;
93909: LD_ADDR_VAR 0 7
93913: PUSH
93914: LD_VAR 0 6
93918: PPUSH
93919: LD_INT 1
93921: PPUSH
93922: CALL_OW 3
93926: ST_TO_ADDR
// SetTaskList ( i , _taskList ) ;
93927: LD_VAR 0 3
93931: PPUSH
93932: LD_VAR 0 7
93936: PPUSH
93937: CALL_OW 446
// CutTreeXYR ( i , taskList [ j ] [ 2 ] , taskList [ j ] [ 3 ] , 8 ) ;
93941: LD_VAR 0 3
93945: PPUSH
93946: LD_VAR 0 6
93950: PUSH
93951: LD_VAR 0 4
93955: ARRAY
93956: PUSH
93957: LD_INT 2
93959: ARRAY
93960: PPUSH
93961: LD_VAR 0 6
93965: PUSH
93966: LD_VAR 0 4
93970: ARRAY
93971: PUSH
93972: LD_INT 3
93974: ARRAY
93975: PPUSH
93976: LD_INT 8
93978: PPUSH
93979: CALL 93996 0 4
// end ;
93983: GO 93886
93985: POP
93986: POP
// end ;
93987: GO 93844
93989: POP
93990: POP
// end ; end ;
93991: LD_VAR 0 2
93995: RET
// function CutTreeXYR ( bulldozer , x , y , r ) ; var i , min_x , min_y , max_x , max_y , _x , _y , list ; begin
93996: LD_INT 0
93998: PPUSH
93999: PPUSH
94000: PPUSH
94001: PPUSH
94002: PPUSH
94003: PPUSH
94004: PPUSH
94005: PPUSH
94006: PPUSH
// if not bulldozer or not ValidHex ( x , y ) or not r then
94007: LD_VAR 0 1
94011: NOT
94012: PUSH
94013: LD_VAR 0 2
94017: PPUSH
94018: LD_VAR 0 3
94022: PPUSH
94023: CALL_OW 488
94027: NOT
94028: OR
94029: PUSH
94030: LD_VAR 0 4
94034: NOT
94035: OR
94036: IFFALSE 94040
// exit ;
94038: GO 94380
// list := [ ] ;
94040: LD_ADDR_VAR 0 13
94044: PUSH
94045: EMPTY
94046: ST_TO_ADDR
// if x - r < 0 then
94047: LD_VAR 0 2
94051: PUSH
94052: LD_VAR 0 4
94056: MINUS
94057: PUSH
94058: LD_INT 0
94060: LESS
94061: IFFALSE 94073
// min_x := 0 else
94063: LD_ADDR_VAR 0 7
94067: PUSH
94068: LD_INT 0
94070: ST_TO_ADDR
94071: GO 94089
// min_x := x - r ;
94073: LD_ADDR_VAR 0 7
94077: PUSH
94078: LD_VAR 0 2
94082: PUSH
94083: LD_VAR 0 4
94087: MINUS
94088: ST_TO_ADDR
// if y - r < 0 then
94089: LD_VAR 0 3
94093: PUSH
94094: LD_VAR 0 4
94098: MINUS
94099: PUSH
94100: LD_INT 0
94102: LESS
94103: IFFALSE 94115
// min_y := 0 else
94105: LD_ADDR_VAR 0 8
94109: PUSH
94110: LD_INT 0
94112: ST_TO_ADDR
94113: GO 94131
// min_y := y - r ;
94115: LD_ADDR_VAR 0 8
94119: PUSH
94120: LD_VAR 0 3
94124: PUSH
94125: LD_VAR 0 4
94129: MINUS
94130: ST_TO_ADDR
// max_x := x + r ;
94131: LD_ADDR_VAR 0 9
94135: PUSH
94136: LD_VAR 0 2
94140: PUSH
94141: LD_VAR 0 4
94145: PLUS
94146: ST_TO_ADDR
// max_y := y + r ;
94147: LD_ADDR_VAR 0 10
94151: PUSH
94152: LD_VAR 0 3
94156: PUSH
94157: LD_VAR 0 4
94161: PLUS
94162: ST_TO_ADDR
// for _x = min_x to max_x do
94163: LD_ADDR_VAR 0 11
94167: PUSH
94168: DOUBLE
94169: LD_VAR 0 7
94173: DEC
94174: ST_TO_ADDR
94175: LD_VAR 0 9
94179: PUSH
94180: FOR_TO
94181: IFFALSE 94298
// for _y = min_y to max_y do
94183: LD_ADDR_VAR 0 12
94187: PUSH
94188: DOUBLE
94189: LD_VAR 0 8
94193: DEC
94194: ST_TO_ADDR
94195: LD_VAR 0 10
94199: PUSH
94200: FOR_TO
94201: IFFALSE 94294
// begin if not ValidHex ( _x , _y ) then
94203: LD_VAR 0 11
94207: PPUSH
94208: LD_VAR 0 12
94212: PPUSH
94213: CALL_OW 488
94217: NOT
94218: IFFALSE 94222
// continue ;
94220: GO 94200
// if IsEnvironment ( _x , _y ) and IsEnvironmentDestroyable ( _x , _y ) then
94222: LD_VAR 0 11
94226: PPUSH
94227: LD_VAR 0 12
94231: PPUSH
94232: CALL_OW 351
94236: PUSH
94237: LD_VAR 0 11
94241: PPUSH
94242: LD_VAR 0 12
94246: PPUSH
94247: CALL_OW 554
94251: AND
94252: IFFALSE 94292
// list := Insert ( list , list + 1 , [ _x , _y ] ) ;
94254: LD_ADDR_VAR 0 13
94258: PUSH
94259: LD_VAR 0 13
94263: PPUSH
94264: LD_VAR 0 13
94268: PUSH
94269: LD_INT 1
94271: PLUS
94272: PPUSH
94273: LD_VAR 0 11
94277: PUSH
94278: LD_VAR 0 12
94282: PUSH
94283: EMPTY
94284: LIST
94285: LIST
94286: PPUSH
94287: CALL_OW 2
94291: ST_TO_ADDR
// end ;
94292: GO 94200
94294: POP
94295: POP
94296: GO 94180
94298: POP
94299: POP
// if not list then
94300: LD_VAR 0 13
94304: NOT
94305: IFFALSE 94309
// exit ;
94307: GO 94380
// for i in list do
94309: LD_ADDR_VAR 0 6
94313: PUSH
94314: LD_VAR 0 13
94318: PUSH
94319: FOR_IN
94320: IFFALSE 94378
// AddTaskList ( bulldozer , [ [ M , i [ 1 ] , i [ 2 ] , 0 , 0 , 0 , 0 ] ] ) ;
94322: LD_VAR 0 1
94326: PPUSH
94327: LD_STRING M
94329: PUSH
94330: LD_VAR 0 6
94334: PUSH
94335: LD_INT 1
94337: ARRAY
94338: PUSH
94339: LD_VAR 0 6
94343: PUSH
94344: LD_INT 2
94346: ARRAY
94347: PUSH
94348: LD_INT 0
94350: PUSH
94351: LD_INT 0
94353: PUSH
94354: LD_INT 0
94356: PUSH
94357: LD_INT 0
94359: PUSH
94360: EMPTY
94361: LIST
94362: LIST
94363: LIST
94364: LIST
94365: LIST
94366: LIST
94367: LIST
94368: PUSH
94369: EMPTY
94370: LIST
94371: PPUSH
94372: CALL_OW 447
94376: GO 94319
94378: POP
94379: POP
// end ;
94380: LD_VAR 0 5
94384: RET
